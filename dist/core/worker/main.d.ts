import { BaseCollectorReducerAction, Collector, Diff, DiffOne } from "../../collector";
import { MainEngine, WorkThreadEngine } from "../base";
import { IOffscreenCanvasOptionType, ICameraOpt, IActiveToolsDataType, IActiveWorkDataType, IWorkerMessage, ILayerOptionType, IworkId, IUpdateNodeOpt, IRectType } from "../types";
import { ECanvasContextType, EPostMessageType } from "../enum";
import { BezierPencilPluginOptions } from "../../plugin";
import { CursorManager } from "../../cursors";
export declare class MainEngineForWorker extends MainEngine {
    protected dpr: number;
    protected threadEngine?: WorkThreadEngine;
    private pluginOptions?;
    static defaultScreenCanvasOpt: {
        autoRender: boolean;
        contextType: ECanvasContextType;
    };
    static defauleLayerOpt: {
        offscreen: boolean;
        handleEvent: boolean;
        depth: boolean;
    };
    static maxLastSyncTime: number;
    protected layerOpt: ILayerOptionType;
    protected msgEmitter: Worker;
    offscreenCanvasOpt: IOffscreenCanvasOptionType;
    originalPoint: [number, number];
    protected cameraOpt: ICameraOpt;
    protected localPointsBatchData: number[];
    taskBatchData: Map<unknown, IWorkerMessage>;
    protected currentToolsData: IActiveToolsDataType;
    protected currentLocalWorkData: IActiveWorkDataType;
    private animationId;
    private subWorker;
    private subWorkerDrawCount;
    private wokerDrawCount;
    private maxDrawCount;
    private cacheDrawCount;
    private reRenders;
    private bgCanvas;
    private floatCanvas;
    private methodBuilder?;
    private zIndexNodeMethod?;
    private localEventTimerId?;
    private undoTickerId?;
    private snapshotMap;
    private boundingRectMap;
    private cursor;
    private cachePoint?;
    private clearAllResolve?;
    constructor(collector: Collector, cursor: CursorManager, options?: BezierPencilPluginOptions);
    private sendCursorEvent;
    private internalMsgEmitterListener;
    private showFloatBar;
    private removeSelectorFromStore;
    private internalMsgEmitterRemoveListener;
    private createSceneLintener;
    private originalEventLintener;
    private destroySubWorker;
    private createThreadEngine;
    private render;
    runAnimation(): void;
    private setLayerOpt;
    updateCanvas(opt: IOffscreenCanvasOptionType): void;
    private pushPoint;
    transformToScenePoint(p: [number, number]): [number, number];
    transformToOriginPoint(p: [number, number]): [number, number];
    getCameraOpt(): ICameraOpt;
    getDpr(): number;
    initSyncData(callBack?: (key: string, value: BaseCollectorReducerAction | undefined) => void): void;
    getRelevantWork(diff: Diff<any>): string | undefined;
    onServiceDerive(key: string, data: DiffOne<BaseCollectorReducerAction | undefined>, relevantId?: string): void;
    private onLocalEventEnd;
    private onLocalEventDoing;
    private onLocalEventStart;
    consume(): void;
    post(msg: Map<unknown, IWorkerMessage>): void;
    on(): void;
    private createOptimizationWorker;
    private collectorSyncData;
    private collectorAsyncData;
    clearAll(justLocal?: boolean): Promise<void>;
    unabled(): void;
    abled(): void;
    destroy(): void;
    updateNode(workId: IworkId, updateNodeOpt: IUpdateNodeOpt): void;
    setCurrentLocalWorkData(currentLocalWorkData: IActiveWorkDataType, msgType?: EPostMessageType): void;
    setCurrentToolsData(currentToolsData: IActiveToolsDataType): void;
    setCameraOpt(cameraOpt: ICameraOpt): void;
    getSnapshot(scenePath: string, width?: number, height?: number, camera?: Pick<ICameraOpt, "centerX" | "centerY" | "scale">): Promise<ImageBitmap> | undefined;
    getBoundingRect(scenePath: string): Promise<IRectType> | undefined;
}
