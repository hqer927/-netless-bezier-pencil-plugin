import * as vl from "react";
import nl, { useContext as id, useState as Hl, useMemo as kl, useEffect as _l, useRef as Yi } from "react";
import zs from "eventemitter2";
import { toJS as Ms, autorun as ks, isRoom as Gd, isPlayer as vs, ApplianceNames as zl, InvisiblePlugin as yt, RoomPhase as wi } from "white-web-sdk";
import { decompress as Lt, compress as It } from "lz-string";
import "lineclip";
import xi from "react-dom";
import ii from "react-draggable";
import { Resizable as Yt } from "re-resizable";
import { WindowManager as xt } from "@netless/window-manager";
var hi;
(function(b) {
  b[b.pedding = 0] = "pedding", b[b.mounted = 1] = "mounted", b[b.update = 2] = "update", b[b.unmounted = 3] = "unmounted";
})(hi || (hi = {}));
var Ad;
(function(b) {
  b[b.Normal = 0] = "Normal", b[b.Stroke = 1] = "Stroke", b[b.Dotted = 2] = "Dotted", b[b.LongDotted = 3] = "LongDotted";
})(Ad || (Ad = {}));
var nd;
(function(b) {
  b.Triangle = "triangle", b.Rhombus = "rhombus", b.Pentagram = "pentagram", b.SpeechBalloon = "speechBalloon", b.Star = "star", b.Polygon = "polygon";
})(nd || (nd = {}));
var hl;
(function(b) {
  b.None = "None", b.ShowFloatBar = "ShowFloatBar", b.ZIndexFloatBar = "ZIndexFloatBar", b.DeleteNode = "DeleteNode", b.CopyNode = "CopyNode", b.ZIndexActive = "ZIndexActive", b.ZIndexNode = "ZIndexNode", b.RotateNode = "RotateNode", b.SetColorNode = "SetColorNode", b.TranslateNode = "TranslateNode", b.ScaleNode = "ScaleNode", b.OriginalEvent = "OriginalEvent", b.CreateScene = "CreateScene", b.ActiveCursor = "ActiveCursor", b.MoveCursor = "MoveCursor", b.CommandEditor = "CommandEditor", b.SetEditorData = "SetEditorData", b.SetFontStyle = "SetFontStyle", b.SetPoint = "SetPoint";
})(hl || (hl = {}));
var Sl;
(function(b) {
  b.DisplayState = "DisplayState", b.FloatBar = "FloatBar", b.CanvasSelector = "CanvasSelector", b.MainEngine = "MainEngine", b.DisplayContainer = "DisplayContainer", b.Cursor = "Cursor", b.TextEditor = "TextEditor", b.BindMainView = "BindMainView", b.MountMainView = "MountMainView", b.MountAppView = "MountAppView";
})(Sl || (Sl = {}));
var Pi;
(function(b) {
  b[b.MainView = 0] = "MainView", b[b.Plugin = 1] = "Plugin", b[b.Both = 2] = "Both";
})(Pi || (Pi = {}));
const Wd = "++", Il = "selector", rt = "all";
class Us {
  constructor(d) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.plugin = d, this.uid = d.displayer.uid;
  }
  getNamespaceData() {
    var d;
    return Ms((d = this.plugin) == null ? void 0 : d.attributes[this.namespace]) || {};
  }
  getUidFromKey(d) {
    return d.split(Wd).length === 2 && d.split(Wd)[0] || this.uid;
  }
  isLocalId(d) {
    return d.split(Wd).length === 1;
  }
  getLocalId(d) {
    return d.split(Wd)[1];
  }
  isSelector(d) {
    return this.getLocalId(d) === Il;
  }
}
var Gl;
(function(b) {
  b[b.Pencil = 1] = "Pencil", b[b.Eraser = 2] = "Eraser", b[b.Selector = 3] = "Selector", b[b.Clicker = 4] = "Clicker", b[b.Arrow = 5] = "Arrow", b[b.Hand = 6] = "Hand", b[b.LaserPen = 7] = "LaserPen", b[b.Text = 8] = "Text", b[b.Straight = 9] = "Straight", b[b.Rectangle = 10] = "Rectangle", b[b.Ellipse = 11] = "Ellipse", b[b.Star = 12] = "Star", b[b.Triangle = 13] = "Triangle", b[b.Rhombus = 14] = "Rhombus", b[b.Polygon = 15] = "Polygon", b[b.SpeechBalloon = 16] = "SpeechBalloon";
})(Gl || (Gl = {}));
var Jl;
(function(b) {
  b[b.Local = 1] = "Local", b[b.Service = 2] = "Service", b[b.Worker = 3] = "Worker";
})(Jl || (Jl = {}));
var ul;
(function(b) {
  b[b.Pending = 0] = "Pending", b[b.Start = 1] = "Start", b[b.Doing = 2] = "Doing", b[b.Done = 3] = "Done", b[b.Freeze = 4] = "Freeze", b[b.Unwritable = 5] = "Unwritable";
})(ul || (ul = {}));
var yl;
(function(b) {
  b[b.Init = 0] = "Init", b[b.UpdateCamera = 1] = "UpdateCamera", b[b.UpdateTools = 2] = "UpdateTools", b[b.CreateWork = 3] = "CreateWork", b[b.DrawWork = 4] = "DrawWork", b[b.FullWork = 5] = "FullWork", b[b.UpdateNode = 6] = "UpdateNode", b[b.RemoveNode = 7] = "RemoveNode", b[b.Clear = 8] = "Clear", b[b.Select = 9] = "Select", b[b.Destroy = 10] = "Destroy", b[b.None = 11] = "None", b[b.Snapshot = 12] = "Snapshot", b[b.BoundingBox = 13] = "BoundingBox", b[b.Cursor = 14] = "Cursor", b[b.TextUpdate = 15] = "TextUpdate", b[b.GetTextActive = 16] = "GetTextActive", b[b.TasksQueue = 17] = "TasksQueue";
})(yl || (yl = {}));
var qd;
(function(b) {
  b.Webgl2 = "webgl2", b.Webgl = "webgl", b.Canvas2d = "2d";
})(qd || (qd = {}));
var ud;
(function(b) {
  b[b.Float = 1] = "Float", b[b.Bg = 2] = "Bg", b[b.Selector = 3] = "Selector", b[b.None = 4] = "None";
})(ud || (ud = {}));
var Sd;
(function(b) {
  b[b.Cursor = 1] = "Cursor", b[b.TextCreate = 2] = "TextCreate";
})(Sd || (Sd = {}));
var Rd;
(function(b) {
  b[b.Top = 1] = "Top", b[b.Bottom = 2] = "Bottom";
})(Rd || (Rd = {}));
var Nd;
(function(b) {
  b[b.none = 1] = "none", b[b.all = 2] = "all", b[b.both = 3] = "both";
})(Nd || (Nd = {}));
function Rt(b) {
  return JSON.parse(Lt(b));
}
function St(b) {
  return It(JSON.stringify(b));
}
const sd = Object.keys;
var Bd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Cd(b) {
  return b && b.__esModule && Object.prototype.hasOwnProperty.call(b, "default") ? b.default : b;
}
function Kt() {
  this.__data__ = [], this.size = 0;
}
var Ct = Kt;
function Jt(b, d) {
  return b === d || b !== b && d !== d;
}
var ri = Jt, Tt = ri;
function Ft(b, d) {
  for (var l = b.length; l--; )
    if (Tt(b[l][0], d))
      return l;
  return -1;
}
var si = Ft, Nt = si, Ht = Array.prototype, gt = Ht.splice;
function zt(b) {
  var d = this.__data__, l = Nt(d, b);
  if (l < 0)
    return !1;
  var i = d.length - 1;
  return l == i ? d.pop() : gt.call(d, l, 1), --this.size, !0;
}
var Mt = zt, kt = si;
function vt(b) {
  var d = this.__data__, l = kt(d, b);
  return l < 0 ? void 0 : d[l][1];
}
var Ut = vt, Qt = si;
function wt(b) {
  return Qt(this.__data__, b) > -1;
}
var Pt = wt, ft = si;
function Et(b, d) {
  var l = this.__data__, i = ft(l, b);
  return i < 0 ? (++this.size, l.push([b, d])) : l[i][1] = d, this;
}
var Bt = Et, jt = Ct, Ot = Mt, Dt = Ut, At = Pt, qt = Bt;
function gd(b) {
  var d = -1, l = b == null ? 0 : b.length;
  for (this.clear(); ++d < l; ) {
    var i = b[d];
    this.set(i[0], i[1]);
  }
}
gd.prototype.clear = jt;
gd.prototype.delete = Ot;
gd.prototype.get = Dt;
gd.prototype.has = At;
gd.prototype.set = qt;
var ti = gd, $t = ti;
function _t() {
  this.__data__ = new $t(), this.size = 0;
}
var lc = _t;
function dc(b) {
  var d = this.__data__, l = d.delete(b);
  return this.size = d.size, l;
}
var ic = dc;
function sc(b) {
  return this.__data__.get(b);
}
var tc = sc;
function cc(b) {
  return this.__data__.has(b);
}
var bc = cc, Zc = typeof Bd == "object" && Bd && Bd.Object === Object && Bd, Qs = Zc, mc = Qs, nc = typeof self == "object" && self && self.Object === Object && self, Xc = mc || nc || Function("return this")(), ad = Xc, ec = ad, ac = ec.Symbol, ci = ac, fi = ci, ws = Object.prototype, oc = ws.hasOwnProperty, Gc = ws.toString, wd = fi ? fi.toStringTag : void 0;
function Wc(b) {
  var d = oc.call(b, wd), l = b[wd];
  try {
    b[wd] = void 0;
    var i = !0;
  } catch {
  }
  var s = Gc.call(b);
  return i && (d ? b[wd] = l : delete b[wd]), s;
}
var uc = Wc, hc = Object.prototype, Vc = hc.toString;
function pc(b) {
  return Vc.call(b);
}
var yc = pc, Ei = ci, Lc = uc, Ic = yc, Yc = "[object Null]", xc = "[object Undefined]", Bi = Ei ? Ei.toStringTag : void 0;
function rc(b) {
  return b == null ? b === void 0 ? xc : Yc : Bi && Bi in Object(b) ? Lc(b) : Ic(b);
}
var Jd = rc;
function Rc(b) {
  var d = typeof b;
  return b != null && (d == "object" || d == "function");
}
var xd = Rc, Sc = Jd, Kc = xd, Cc = "[object AsyncFunction]", Jc = "[object Function]", Tc = "[object GeneratorFunction]", Fc = "[object Proxy]";
function Nc(b) {
  if (!Kc(b))
    return !1;
  var d = Sc(b);
  return d == Jc || d == Tc || d == Cc || d == Fc;
}
var Ps = Nc, Hc = ad, gc = Hc["__core-js_shared__"], zc = gc, ai = zc, ji = function() {
  var b = /[^.]+$/.exec(ai && ai.keys && ai.keys.IE_PROTO || "");
  return b ? "Symbol(src)_1." + b : "";
}();
function Mc(b) {
  return !!ji && ji in b;
}
var kc = Mc, vc = Function.prototype, Uc = vc.toString;
function Qc(b) {
  if (b != null) {
    try {
      return Uc.call(b);
    } catch {
    }
    try {
      return b + "";
    } catch {
    }
  }
  return "";
}
var fs = Qc, wc = Ps, Pc = kc, fc = xd, Ec = fs, Bc = /[\\^$.*+?()[\]{}|]/g, jc = /^\[object .+?Constructor\]$/, Oc = Function.prototype, Dc = Object.prototype, Ac = Oc.toString, qc = Dc.hasOwnProperty, $c = RegExp(
  "^" + Ac.call(qc).replace(Bc, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function _c(b) {
  if (!fc(b) || Pc(b))
    return !1;
  var d = wc(b) ? $c : jc;
  return d.test(Ec(b));
}
var lb = _c;
function db(b, d) {
  return b == null ? void 0 : b[d];
}
var ib = db, sb = lb, tb = ib;
function cb(b, d) {
  var l = tb(b, d);
  return sb(l) ? l : void 0;
}
var Td = cb, bb = Td, Zb = ad, mb = bb(Zb, "Map"), Ri = mb, nb = Td, Xb = nb(Object, "create"), bi = Xb, Oi = bi;
function eb() {
  this.__data__ = Oi ? Oi(null) : {}, this.size = 0;
}
var ab = eb;
function ob(b) {
  var d = this.has(b) && delete this.__data__[b];
  return this.size -= d ? 1 : 0, d;
}
var Gb = ob, Wb = bi, ub = "__lodash_hash_undefined__", hb = Object.prototype, Vb = hb.hasOwnProperty;
function pb(b) {
  var d = this.__data__;
  if (Wb) {
    var l = d[b];
    return l === ub ? void 0 : l;
  }
  return Vb.call(d, b) ? d[b] : void 0;
}
var yb = pb, Lb = bi, Ib = Object.prototype, Yb = Ib.hasOwnProperty;
function xb(b) {
  var d = this.__data__;
  return Lb ? d[b] !== void 0 : Yb.call(d, b);
}
var rb = xb, Rb = bi, Sb = "__lodash_hash_undefined__";
function Kb(b, d) {
  var l = this.__data__;
  return this.size += this.has(b) ? 0 : 1, l[b] = Rb && d === void 0 ? Sb : d, this;
}
var Cb = Kb, Jb = ab, Tb = Gb, Fb = yb, Nb = rb, Hb = Cb;
function zd(b) {
  var d = -1, l = b == null ? 0 : b.length;
  for (this.clear(); ++d < l; ) {
    var i = b[d];
    this.set(i[0], i[1]);
  }
}
zd.prototype.clear = Jb;
zd.prototype.delete = Tb;
zd.prototype.get = Fb;
zd.prototype.has = Nb;
zd.prototype.set = Hb;
var gb = zd, Di = gb, zb = ti, Mb = Ri;
function kb() {
  this.size = 0, this.__data__ = {
    hash: new Di(),
    map: new (Mb || zb)(),
    string: new Di()
  };
}
var vb = kb;
function Ub(b) {
  var d = typeof b;
  return d == "string" || d == "number" || d == "symbol" || d == "boolean" ? b !== "__proto__" : b === null;
}
var Qb = Ub, wb = Qb;
function Pb(b, d) {
  var l = b.__data__;
  return wb(d) ? l[typeof d == "string" ? "string" : "hash"] : l.map;
}
var Zi = Pb, fb = Zi;
function Eb(b) {
  var d = fb(this, b).delete(b);
  return this.size -= d ? 1 : 0, d;
}
var Bb = Eb, jb = Zi;
function Ob(b) {
  return jb(this, b).get(b);
}
var Db = Ob, Ab = Zi;
function qb(b) {
  return Ab(this, b).has(b);
}
var $b = qb, _b = Zi;
function lZ(b, d) {
  var l = _b(this, b), i = l.size;
  return l.set(b, d), this.size += l.size == i ? 0 : 1, this;
}
var dZ = lZ, iZ = vb, sZ = Bb, tZ = Db, cZ = $b, bZ = dZ;
function Md(b) {
  var d = -1, l = b == null ? 0 : b.length;
  for (this.clear(); ++d < l; ) {
    var i = b[d];
    this.set(i[0], i[1]);
  }
}
Md.prototype.clear = iZ;
Md.prototype.delete = sZ;
Md.prototype.get = tZ;
Md.prototype.has = cZ;
Md.prototype.set = bZ;
var Es = Md, ZZ = ti, mZ = Ri, nZ = Es, XZ = 200;
function eZ(b, d) {
  var l = this.__data__;
  if (l instanceof ZZ) {
    var i = l.__data__;
    if (!mZ || i.length < XZ - 1)
      return i.push([b, d]), this.size = ++l.size, this;
    l = this.__data__ = new nZ(i);
  }
  return l.set(b, d), this.size = l.size, this;
}
var aZ = eZ, oZ = ti, GZ = lc, WZ = ic, uZ = tc, hZ = bc, VZ = aZ;
function kd(b) {
  var d = this.__data__ = new oZ(b);
  this.size = d.size;
}
kd.prototype.clear = GZ;
kd.prototype.delete = WZ;
kd.prototype.get = uZ;
kd.prototype.has = hZ;
kd.prototype.set = VZ;
var Bs = kd, pZ = "__lodash_hash_undefined__";
function yZ(b) {
  return this.__data__.set(b, pZ), this;
}
var LZ = yZ;
function IZ(b) {
  return this.__data__.has(b);
}
var YZ = IZ, xZ = Es, rZ = LZ, RZ = YZ;
function $d(b) {
  var d = -1, l = b == null ? 0 : b.length;
  for (this.__data__ = new xZ(); ++d < l; )
    this.add(b[d]);
}
$d.prototype.add = $d.prototype.push = rZ;
$d.prototype.has = RZ;
var SZ = $d;
function KZ(b, d) {
  for (var l = -1, i = b == null ? 0 : b.length; ++l < i; )
    if (d(b[l], l, b))
      return !0;
  return !1;
}
var CZ = KZ;
function JZ(b, d) {
  return b.has(d);
}
var TZ = JZ, FZ = SZ, NZ = CZ, HZ = TZ, gZ = 1, zZ = 2;
function MZ(b, d, l, i, s, c) {
  var m = l & gZ, n = b.length, X = d.length;
  if (n != X && !(m && X > n))
    return !1;
  var G = c.get(b), L = c.get(d);
  if (G && L)
    return G == d && L == b;
  var o = -1, h = !0, p = l & zZ ? new FZ() : void 0;
  for (c.set(b, d), c.set(d, b); ++o < n; ) {
    var r = b[o], V = d[o];
    if (i)
      var W = m ? i(V, r, o, d, b, c) : i(r, V, o, b, d, c);
    if (W !== void 0) {
      if (W)
        continue;
      h = !1;
      break;
    }
    if (p) {
      if (!NZ(d, function(y, t) {
        if (!HZ(p, t) && (r === y || s(r, y, l, i, c)))
          return p.push(t);
      })) {
        h = !1;
        break;
      }
    } else if (!(r === V || s(r, V, l, i, c))) {
      h = !1;
      break;
    }
  }
  return c.delete(b), c.delete(d), h;
}
var js = MZ, kZ = ad, vZ = kZ.Uint8Array, Os = vZ;
function UZ(b) {
  var d = -1, l = Array(b.size);
  return b.forEach(function(i, s) {
    l[++d] = [s, i];
  }), l;
}
var QZ = UZ;
function wZ(b) {
  var d = -1, l = Array(b.size);
  return b.forEach(function(i) {
    l[++d] = i;
  }), l;
}
var PZ = wZ, Ai = ci, qi = Os, fZ = ri, EZ = js, BZ = QZ, jZ = PZ, OZ = 1, DZ = 2, AZ = "[object Boolean]", qZ = "[object Date]", $Z = "[object Error]", _Z = "[object Map]", lm = "[object Number]", dm = "[object RegExp]", im = "[object Set]", sm = "[object String]", tm = "[object Symbol]", cm = "[object ArrayBuffer]", bm = "[object DataView]", $i = Ai ? Ai.prototype : void 0, oi = $i ? $i.valueOf : void 0;
function Zm(b, d, l, i, s, c, m) {
  switch (l) {
    case bm:
      if (b.byteLength != d.byteLength || b.byteOffset != d.byteOffset)
        return !1;
      b = b.buffer, d = d.buffer;
    case cm:
      return !(b.byteLength != d.byteLength || !c(new qi(b), new qi(d)));
    case AZ:
    case qZ:
    case lm:
      return fZ(+b, +d);
    case $Z:
      return b.name == d.name && b.message == d.message;
    case dm:
    case sm:
      return b == d + "";
    case _Z:
      var n = BZ;
    case im:
      var X = i & OZ;
      if (n || (n = jZ), b.size != d.size && !X)
        return !1;
      var G = m.get(b);
      if (G)
        return G == d;
      i |= DZ, m.set(b, d);
      var L = EZ(n(b), n(d), i, s, c, m);
      return m.delete(b), L;
    case tm:
      if (oi)
        return oi.call(b) == oi.call(d);
  }
  return !1;
}
var mm = Zm;
function nm(b, d) {
  for (var l = -1, i = d.length, s = b.length; ++l < i; )
    b[s + l] = d[l];
  return b;
}
var Ds = nm, Xm = Array.isArray, mi = Xm, em = Ds, am = mi;
function om(b, d, l) {
  var i = d(b);
  return am(b) ? i : em(i, l(b));
}
var As = om;
function Gm(b, d) {
  for (var l = -1, i = b == null ? 0 : b.length, s = 0, c = []; ++l < i; ) {
    var m = b[l];
    d(m, l, b) && (c[s++] = m);
  }
  return c;
}
var Wm = Gm;
function um() {
  return [];
}
var qs = um, hm = Wm, Vm = qs, pm = Object.prototype, ym = pm.propertyIsEnumerable, _i = Object.getOwnPropertySymbols, Lm = _i ? function(b) {
  return b == null ? [] : (b = Object(b), hm(_i(b), function(d) {
    return ym.call(b, d);
  }));
} : Vm, Si = Lm;
function Im(b, d) {
  for (var l = -1, i = Array(b); ++l < b; )
    i[l] = d(l);
  return i;
}
var Ym = Im;
function xm(b) {
  return b != null && typeof b == "object";
}
var Ld = xm, rm = Jd, Rm = Ld, Sm = "[object Arguments]";
function Km(b) {
  return Rm(b) && rm(b) == Sm;
}
var Cm = Km, ls = Cm, Jm = Ld, $s = Object.prototype, Tm = $s.hasOwnProperty, Fm = $s.propertyIsEnumerable, Nm = ls(/* @__PURE__ */ function() {
  return arguments;
}()) ? ls : function(b) {
  return Jm(b) && Tm.call(b, "callee") && !Fm.call(b, "callee");
}, Hm = Nm, _d = { exports: {} };
function gm() {
  return !1;
}
var zm = gm;
_d.exports;
(function(b, d) {
  var l = ad, i = zm, s = d && !d.nodeType && d, c = s && !0 && b && !b.nodeType && b, m = c && c.exports === s, n = m ? l.Buffer : void 0, X = n ? n.isBuffer : void 0, G = X || i;
  b.exports = G;
})(_d, _d.exports);
var Ki = _d.exports, Mm = 9007199254740991, km = /^(?:0|[1-9]\d*)$/;
function vm(b, d) {
  var l = typeof b;
  return d = d ?? Mm, !!d && (l == "number" || l != "symbol" && km.test(b)) && b > -1 && b % 1 == 0 && b < d;
}
var Um = vm, Qm = 9007199254740991;
function wm(b) {
  return typeof b == "number" && b > -1 && b % 1 == 0 && b <= Qm;
}
var _s = wm, Pm = Jd, fm = _s, Em = Ld, Bm = "[object Arguments]", jm = "[object Array]", Om = "[object Boolean]", Dm = "[object Date]", Am = "[object Error]", qm = "[object Function]", $m = "[object Map]", _m = "[object Number]", l0 = "[object Object]", d0 = "[object RegExp]", i0 = "[object Set]", s0 = "[object String]", t0 = "[object WeakMap]", c0 = "[object ArrayBuffer]", b0 = "[object DataView]", Z0 = "[object Float32Array]", m0 = "[object Float64Array]", n0 = "[object Int8Array]", X0 = "[object Int16Array]", e0 = "[object Int32Array]", a0 = "[object Uint8Array]", o0 = "[object Uint8ClampedArray]", G0 = "[object Uint16Array]", W0 = "[object Uint32Array]", gl = {};
gl[Z0] = gl[m0] = gl[n0] = gl[X0] = gl[e0] = gl[a0] = gl[o0] = gl[G0] = gl[W0] = !0;
gl[Bm] = gl[jm] = gl[c0] = gl[Om] = gl[b0] = gl[Dm] = gl[Am] = gl[qm] = gl[$m] = gl[_m] = gl[l0] = gl[d0] = gl[i0] = gl[s0] = gl[t0] = !1;
function u0(b) {
  return Em(b) && fm(b.length) && !!gl[Pm(b)];
}
var h0 = u0;
function V0(b) {
  return function(d) {
    return b(d);
  };
}
var Ci = V0, li = { exports: {} };
li.exports;
(function(b, d) {
  var l = Qs, i = d && !d.nodeType && d, s = i && !0 && b && !b.nodeType && b, c = s && s.exports === i, m = c && l.process, n = function() {
    try {
      var X = s && s.require && s.require("util").types;
      return X || m && m.binding && m.binding("util");
    } catch {
    }
  }();
  b.exports = n;
})(li, li.exports);
var Ji = li.exports, p0 = h0, y0 = Ci, ds = Ji, is = ds && ds.isTypedArray, L0 = is ? y0(is) : p0, lt = L0, I0 = Ym, Y0 = Hm, x0 = mi, r0 = Ki, R0 = Um, S0 = lt, K0 = Object.prototype, C0 = K0.hasOwnProperty;
function J0(b, d) {
  var l = x0(b), i = !l && Y0(b), s = !l && !i && r0(b), c = !l && !i && !s && S0(b), m = l || i || s || c, n = m ? I0(b.length, String) : [], X = n.length;
  for (var G in b)
    (d || C0.call(b, G)) && !(m && // Safari 9 has enumerable `arguments.length` in strict mode.
    (G == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    s && (G == "offset" || G == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    c && (G == "buffer" || G == "byteLength" || G == "byteOffset") || // Skip index properties.
    R0(G, X))) && n.push(G);
  return n;
}
var dt = J0, T0 = Object.prototype;
function F0(b) {
  var d = b && b.constructor, l = typeof d == "function" && d.prototype || T0;
  return b === l;
}
var Ti = F0;
function N0(b, d) {
  return function(l) {
    return b(d(l));
  };
}
var it = N0, H0 = it, g0 = H0(Object.keys, Object), z0 = g0, M0 = Ti, k0 = z0, v0 = Object.prototype, U0 = v0.hasOwnProperty;
function Q0(b) {
  if (!M0(b))
    return k0(b);
  var d = [];
  for (var l in Object(b))
    U0.call(b, l) && l != "constructor" && d.push(l);
  return d;
}
var w0 = Q0, P0 = Ps, f0 = _s;
function E0(b) {
  return b != null && f0(b.length) && !P0(b);
}
var st = E0, B0 = dt, j0 = w0, O0 = st;
function D0(b) {
  return O0(b) ? B0(b) : j0(b);
}
var Fi = D0, A0 = As, q0 = Si, $0 = Fi;
function _0(b) {
  return A0(b, $0, q0);
}
var tt = _0, ss = tt, ln = 1, dn = Object.prototype, sn = dn.hasOwnProperty;
function tn(b, d, l, i, s, c) {
  var m = l & ln, n = ss(b), X = n.length, G = ss(d), L = G.length;
  if (X != L && !m)
    return !1;
  for (var o = X; o--; ) {
    var h = n[o];
    if (!(m ? h in d : sn.call(d, h)))
      return !1;
  }
  var p = c.get(b), r = c.get(d);
  if (p && r)
    return p == d && r == b;
  var V = !0;
  c.set(b, d), c.set(d, b);
  for (var W = m; ++o < X; ) {
    h = n[o];
    var y = b[h], t = d[h];
    if (i)
      var e = m ? i(t, y, h, d, b, c) : i(y, t, h, b, d, c);
    if (!(e === void 0 ? y === t || s(y, t, l, i, c) : e)) {
      V = !1;
      break;
    }
    W || (W = h == "constructor");
  }
  if (V && !W) {
    var Z = b.constructor, a = d.constructor;
    Z != a && "constructor" in b && "constructor" in d && !(typeof Z == "function" && Z instanceof Z && typeof a == "function" && a instanceof a) && (V = !1);
  }
  return c.delete(b), c.delete(d), V;
}
var cn = tn, bn = Td, Zn = ad, mn = bn(Zn, "DataView"), nn = mn, Xn = Td, en = ad, an = Xn(en, "Promise"), on = an, Gn = Td, Wn = ad, un = Gn(Wn, "Set"), hn = un, Vn = Td, pn = ad, yn = Vn(pn, "WeakMap"), Ln = yn, Vi = nn, pi = Ri, yi = on, Li = hn, Ii = Ln, ct = Jd, vd = fs, ts = "[object Map]", In = "[object Object]", cs = "[object Promise]", bs = "[object Set]", Zs = "[object WeakMap]", ms = "[object DataView]", Yn = vd(Vi), xn = vd(pi), rn = vd(yi), Rn = vd(Li), Sn = vd(Ii), rd = ct;
(Vi && rd(new Vi(new ArrayBuffer(1))) != ms || pi && rd(new pi()) != ts || yi && rd(yi.resolve()) != cs || Li && rd(new Li()) != bs || Ii && rd(new Ii()) != Zs) && (rd = function(b) {
  var d = ct(b), l = d == In ? b.constructor : void 0, i = l ? vd(l) : "";
  if (i)
    switch (i) {
      case Yn:
        return ms;
      case xn:
        return ts;
      case rn:
        return cs;
      case Rn:
        return bs;
      case Sn:
        return Zs;
    }
  return d;
});
var ni = rd, Gi = Bs, Kn = js, Cn = mm, Jn = cn, ns = ni, Xs = mi, es = Ki, Tn = lt, Fn = 1, as = "[object Arguments]", os = "[object Array]", jd = "[object Object]", Nn = Object.prototype, Gs = Nn.hasOwnProperty;
function Hn(b, d, l, i, s, c) {
  var m = Xs(b), n = Xs(d), X = m ? os : ns(b), G = n ? os : ns(d);
  X = X == as ? jd : X, G = G == as ? jd : G;
  var L = X == jd, o = G == jd, h = X == G;
  if (h && es(b)) {
    if (!es(d))
      return !1;
    m = !0, L = !1;
  }
  if (h && !L)
    return c || (c = new Gi()), m || Tn(b) ? Kn(b, d, l, i, s, c) : Cn(b, d, X, l, i, s, c);
  if (!(l & Fn)) {
    var p = L && Gs.call(b, "__wrapped__"), r = o && Gs.call(d, "__wrapped__");
    if (p || r) {
      var V = p ? b.value() : b, W = r ? d.value() : d;
      return c || (c = new Gi()), s(V, W, l, i, c);
    }
  }
  return h ? (c || (c = new Gi()), Jn(b, d, l, i, s, c)) : !1;
}
var gn = Hn, zn = gn, Ws = Ld;
function bt(b, d, l, i, s) {
  return b === d ? !0 : b == null || d == null || !Ws(b) && !Ws(d) ? b !== b && d !== d : zn(b, d, l, i, bt, s);
}
var Mn = bt, kn = Mn;
function vn(b, d) {
  return kn(b, d);
}
var Un = vn;
const ld = /* @__PURE__ */ Cd(Un);
function Qn(b, d) {
  for (var l = -1, i = b == null ? 0 : b.length; ++l < i && d(b[l], l, b) !== !1; )
    ;
  return b;
}
var wn = Qn, Pn = Td, fn = function() {
  try {
    var b = Pn(Object, "defineProperty");
    return b({}, "", {}), b;
  } catch {
  }
}(), En = fn, us = En;
function Bn(b, d, l) {
  d == "__proto__" && us ? us(b, d, {
    configurable: !0,
    enumerable: !0,
    value: l,
    writable: !0
  }) : b[d] = l;
}
var Zt = Bn, jn = Zt, On = ri, Dn = Object.prototype, An = Dn.hasOwnProperty;
function qn(b, d, l) {
  var i = b[d];
  (!(An.call(b, d) && On(i, l)) || l === void 0 && !(d in b)) && jn(b, d, l);
}
var mt = qn, $n = mt, _n = Zt;
function lX(b, d, l, i) {
  var s = !l;
  l || (l = {});
  for (var c = -1, m = d.length; ++c < m; ) {
    var n = d[c], X = i ? i(l[n], b[n], n, l, b) : void 0;
    X === void 0 && (X = b[n]), s ? _n(l, n, X) : $n(l, n, X);
  }
  return l;
}
var Xi = lX, dX = Xi, iX = Fi;
function sX(b, d) {
  return b && dX(d, iX(d), b);
}
var tX = sX;
function cX(b) {
  var d = [];
  if (b != null)
    for (var l in Object(b))
      d.push(l);
  return d;
}
var bX = cX, ZX = xd, mX = Ti, nX = bX, XX = Object.prototype, eX = XX.hasOwnProperty;
function aX(b) {
  if (!ZX(b))
    return nX(b);
  var d = mX(b), l = [];
  for (var i in b)
    i == "constructor" && (d || !eX.call(b, i)) || l.push(i);
  return l;
}
var oX = aX, GX = dt, WX = oX, uX = st;
function hX(b) {
  return uX(b) ? GX(b, !0) : WX(b);
}
var Ni = hX, VX = Xi, pX = Ni;
function yX(b, d) {
  return b && VX(d, pX(d), b);
}
var LX = yX, di = { exports: {} };
di.exports;
(function(b, d) {
  var l = ad, i = d && !d.nodeType && d, s = i && !0 && b && !b.nodeType && b, c = s && s.exports === i, m = c ? l.Buffer : void 0, n = m ? m.allocUnsafe : void 0;
  function X(G, L) {
    if (L)
      return G.slice();
    var o = G.length, h = n ? n(o) : new G.constructor(o);
    return G.copy(h), h;
  }
  b.exports = X;
})(di, di.exports);
var IX = di.exports;
function YX(b, d) {
  var l = -1, i = b.length;
  for (d || (d = Array(i)); ++l < i; )
    d[l] = b[l];
  return d;
}
var xX = YX, rX = Xi, RX = Si;
function SX(b, d) {
  return rX(b, RX(b), d);
}
var KX = SX, CX = it, JX = CX(Object.getPrototypeOf, Object), nt = JX, TX = Ds, FX = nt, NX = Si, HX = qs, gX = Object.getOwnPropertySymbols, zX = gX ? function(b) {
  for (var d = []; b; )
    TX(d, NX(b)), b = FX(b);
  return d;
} : HX, Xt = zX, MX = Xi, kX = Xt;
function vX(b, d) {
  return MX(b, kX(b), d);
}
var UX = vX, QX = As, wX = Xt, PX = Ni;
function fX(b) {
  return QX(b, PX, wX);
}
var EX = fX, BX = Object.prototype, jX = BX.hasOwnProperty;
function OX(b) {
  var d = b.length, l = new b.constructor(d);
  return d && typeof b[0] == "string" && jX.call(b, "index") && (l.index = b.index, l.input = b.input), l;
}
var DX = OX, hs = Os;
function AX(b) {
  var d = new b.constructor(b.byteLength);
  return new hs(d).set(new hs(b)), d;
}
var Hi = AX, qX = Hi;
function $X(b, d) {
  var l = d ? qX(b.buffer) : b.buffer;
  return new b.constructor(l, b.byteOffset, b.byteLength);
}
var _X = $X, le = /\w*$/;
function de(b) {
  var d = new b.constructor(b.source, le.exec(b));
  return d.lastIndex = b.lastIndex, d;
}
var ie = de, Vs = ci, ps = Vs ? Vs.prototype : void 0, ys = ps ? ps.valueOf : void 0;
function se(b) {
  return ys ? Object(ys.call(b)) : {};
}
var te = se, ce = Hi;
function be(b, d) {
  var l = d ? ce(b.buffer) : b.buffer;
  return new b.constructor(l, b.byteOffset, b.length);
}
var Ze = be, me = Hi, ne = _X, Xe = ie, ee = te, ae = Ze, oe = "[object Boolean]", Ge = "[object Date]", We = "[object Map]", ue = "[object Number]", he = "[object RegExp]", Ve = "[object Set]", pe = "[object String]", ye = "[object Symbol]", Le = "[object ArrayBuffer]", Ie = "[object DataView]", Ye = "[object Float32Array]", xe = "[object Float64Array]", re = "[object Int8Array]", Re = "[object Int16Array]", Se = "[object Int32Array]", Ke = "[object Uint8Array]", Ce = "[object Uint8ClampedArray]", Je = "[object Uint16Array]", Te = "[object Uint32Array]";
function Fe(b, d, l) {
  var i = b.constructor;
  switch (d) {
    case Le:
      return me(b);
    case oe:
    case Ge:
      return new i(+b);
    case Ie:
      return ne(b, l);
    case Ye:
    case xe:
    case re:
    case Re:
    case Se:
    case Ke:
    case Ce:
    case Je:
    case Te:
      return ae(b, l);
    case We:
      return new i();
    case ue:
    case pe:
      return new i(b);
    case he:
      return Xe(b);
    case Ve:
      return new i();
    case ye:
      return ee(b);
  }
}
var Ne = Fe, He = xd, Ls = Object.create, ge = /* @__PURE__ */ function() {
  function b() {
  }
  return function(d) {
    if (!He(d))
      return {};
    if (Ls)
      return Ls(d);
    b.prototype = d;
    var l = new b();
    return b.prototype = void 0, l;
  };
}(), ze = ge, Me = ze, ke = nt, ve = Ti;
function Ue(b) {
  return typeof b.constructor == "function" && !ve(b) ? Me(ke(b)) : {};
}
var Qe = Ue, we = ni, Pe = Ld, fe = "[object Map]";
function Ee(b) {
  return Pe(b) && we(b) == fe;
}
var Be = Ee, je = Be, Oe = Ci, Is = Ji, Ys = Is && Is.isMap, De = Ys ? Oe(Ys) : je, Ae = De, qe = ni, $e = Ld, _e = "[object Set]";
function la(b) {
  return $e(b) && qe(b) == _e;
}
var da = la, ia = da, sa = Ci, xs = Ji, rs = xs && xs.isSet, ta = rs ? sa(rs) : ia, ca = ta, ba = Bs, Za = wn, ma = mt, na = tX, Xa = LX, ea = IX, aa = xX, oa = KX, Ga = UX, Wa = tt, ua = EX, ha = ni, Va = DX, pa = Ne, ya = Qe, La = mi, Ia = Ki, Ya = Ae, xa = xd, ra = ca, Ra = Fi, Sa = Ni, Ka = 1, Ca = 2, Ja = 4, et = "[object Arguments]", Ta = "[object Array]", Fa = "[object Boolean]", Na = "[object Date]", Ha = "[object Error]", at = "[object Function]", ga = "[object GeneratorFunction]", za = "[object Map]", Ma = "[object Number]", ot = "[object Object]", ka = "[object RegExp]", va = "[object Set]", Ua = "[object String]", Qa = "[object Symbol]", wa = "[object WeakMap]", Pa = "[object ArrayBuffer]", fa = "[object DataView]", Ea = "[object Float32Array]", Ba = "[object Float64Array]", ja = "[object Int8Array]", Oa = "[object Int16Array]", Da = "[object Int32Array]", Aa = "[object Uint8Array]", qa = "[object Uint8ClampedArray]", $a = "[object Uint16Array]", _a = "[object Uint32Array]", Nl = {};
Nl[et] = Nl[Ta] = Nl[Pa] = Nl[fa] = Nl[Fa] = Nl[Na] = Nl[Ea] = Nl[Ba] = Nl[ja] = Nl[Oa] = Nl[Da] = Nl[za] = Nl[Ma] = Nl[ot] = Nl[ka] = Nl[va] = Nl[Ua] = Nl[Qa] = Nl[Aa] = Nl[qa] = Nl[$a] = Nl[_a] = !0;
Nl[Ha] = Nl[at] = Nl[wa] = !1;
function Dd(b, d, l, i, s, c) {
  var m, n = d & Ka, X = d & Ca, G = d & Ja;
  if (l && (m = s ? l(b, i, s, c) : l(b)), m !== void 0)
    return m;
  if (!xa(b))
    return b;
  var L = La(b);
  if (L) {
    if (m = Va(b), !n)
      return aa(b, m);
  } else {
    var o = ha(b), h = o == at || o == ga;
    if (Ia(b))
      return ea(b, n);
    if (o == ot || o == et || h && !s) {
      if (m = X || h ? {} : ya(b), !n)
        return X ? Ga(b, Xa(m, b)) : oa(b, na(m, b));
    } else {
      if (!Nl[o])
        return s ? b : {};
      m = pa(b, o, n);
    }
  }
  c || (c = new ba());
  var p = c.get(b);
  if (p)
    return p;
  c.set(b, m), ra(b) ? b.forEach(function(W) {
    m.add(Dd(W, d, l, W, b, c));
  }) : Ya(b) && b.forEach(function(W, y) {
    m.set(y, Dd(W, d, l, y, b, c));
  });
  var r = G ? X ? ua : Wa : X ? Sa : Ra, V = L ? void 0 : r(b);
  return Za(V || b, function(W, y) {
    V && (y = W, W = b[y]), ma(m, y, Dd(W, d, l, y, b, c));
  }), m;
}
var Gt = Dd, lo = Gt, io = 1, so = 4;
function to(b) {
  return lo(b, io | so);
}
var co = to;
const Al = /* @__PURE__ */ Cd(co), bo = {
  linear: (b) => b,
  easeInQuad: (b) => b * b,
  easeOutQuad: (b) => b * (2 - b),
  easeInOutQuad: (b) => b < 0.5 ? 2 * b * b : -1 + (4 - 2 * b) * b,
  easeInCubic: (b) => b * b * b,
  easeOutCubic: (b) => --b * b * b + 1,
  easeInOutCubic: (b) => b < 0.5 ? 4 * b * b * b : (b - 1) * (2 * b - 2) * (2 * b - 2) + 1,
  easeInQuart: (b) => b * b * b * b,
  easeOutQuart: (b) => 1 - --b * b * b * b,
  easeInOutQuart: (b) => b < 0.5 ? 8 * b * b * b * b : 1 - 8 * --b * b * b * b,
  easeInQuint: (b) => b * b * b * b * b,
  easeOutQuint: (b) => 1 + --b * b * b * b * b,
  easeInOutQuint: (b) => b < 0.5 ? 16 * b * b * b * b * b : 1 + 16 * --b * b * b * b * b,
  easeInSine: (b) => 1 - Math.cos(b * Math.PI / 2),
  easeOutSine: (b) => Math.sin(b * Math.PI / 2),
  easeInOutSine: (b) => -(Math.cos(Math.PI * b) - 1) / 2,
  easeInExpo: (b) => b <= 0 ? 0 : Math.pow(2, 10 * b - 10),
  easeOutExpo: (b) => b >= 1 ? 1 : 1 - Math.pow(2, -10 * b),
  easeInOutExpo: (b) => b <= 0 ? 0 : b >= 1 ? 1 : b < 0.5 ? Math.pow(2, 20 * b - 10) / 2 : (2 - Math.pow(2, -20 * b + 10)) / 2
};
class Vl {
  constructor(d = 0, l = 0, i = 1) {
    Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    });
  }
  get XY() {
    return [this.x, this.y];
  }
  setz(d) {
    return this.z = d, this;
  }
  setXY(d = this.x, l = this.y) {
    return this.x = d, this.y = l, this;
  }
  set(d = this.x, l = this.y, i = this.z) {
    return this.x = d, this.y = l, this.z = i, this;
  }
  setTo({ x: d = 0, y: l = 0, z: i = 1 }) {
    return this.x = d, this.y = l, this.z = i, this;
  }
  rot(d) {
    if (d === 0)
      return this;
    const { x: l, y: i } = this, s = Math.sin(d), c = Math.cos(d);
    return this.x = l * c - i * s, this.y = l * s + i * c, this;
  }
  rotWith(d, l) {
    if (l === 0)
      return this;
    const i = this.x - d.x, s = this.y - d.y, c = Math.sin(l), m = Math.cos(l);
    return this.x = d.x + (i * m - s * c), this.y = d.y + (i * c + s * m), this;
  }
  clone() {
    const { x: d, y: l, z: i } = this;
    return new Vl(d, l, i);
  }
  sub(d) {
    return this.x -= d.x, this.y -= d.y, this;
  }
  subXY(d, l) {
    return this.x -= d, this.y -= l, this;
  }
  subScalar(d) {
    return this.x -= d, this.y -= d, this;
  }
  add(d) {
    return this.x += d.x, this.y += d.y, this;
  }
  addXY(d, l) {
    return this.x += d, this.y += l, this;
  }
  addScalar(d) {
    return this.x += d, this.y += d, this;
  }
  clamp(d, l) {
    return this.x = Math.max(this.x, d), this.y = Math.max(this.y, d), l !== void 0 && (this.x = Math.min(this.x, l), this.y = Math.min(this.y, l)), this;
  }
  div(d) {
    return this.x /= d, this.y /= d, this;
  }
  divV(d) {
    return this.x /= d.x, this.y /= d.y, this;
  }
  mul(d) {
    return this.x *= d, this.y *= d, this;
  }
  mulV(d) {
    return this.x *= d.x, this.y *= d.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(d, l) {
    const i = Vl.Tan(d, this);
    return this.add(i.mul(l));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(d) {
    return this.x = this.y * d.z - this.z * d.y, this.y = this.z * d.x - this.x * d.z, this;
  }
  dpr(d) {
    return Vl.Dpr(this, d);
  }
  cpr(d) {
    return Vl.Cpr(this, d);
  }
  len2() {
    return Vl.Len2(this);
  }
  len() {
    return Vl.Len(this);
  }
  pry(d) {
    return Vl.Pry(this, d);
  }
  per() {
    const { x: d, y: l } = this;
    return this.x = l, this.y = -d, this;
  }
  uni() {
    return Vl.Uni(this);
  }
  tan(d) {
    return Vl.Tan(this, d);
  }
  dist(d) {
    return Vl.Dist(this, d);
  }
  distanceToLineSegment(d, l) {
    return Vl.DistanceToLineSegment(d, l, this);
  }
  slope(d) {
    return Vl.Slope(this, d);
  }
  snapToGrid(d) {
    return this.x = Math.round(this.x / d) * d, this.y = Math.round(this.y / d) * d, this;
  }
  angle(d) {
    return Vl.Angle(this, d);
  }
  toAngle() {
    return Vl.ToAngle(this);
  }
  lrp(d, l) {
    return this.x = this.x + (d.x - this.x) * l, this.y = this.y + (d.y - this.y) * l, this;
  }
  equals(d, l) {
    return Vl.Equals(this, d, l);
  }
  equalsXY(d, l) {
    return Vl.EqualsXY(this, d, l);
  }
  norm() {
    const d = this.len();
    return this.x = d === 0 ? 0 : this.x / d, this.y = d === 0 ? 0 : this.y / d, this;
  }
  toFixed() {
    return Vl.ToFixed(this);
  }
  toString() {
    return Vl.ToString(Vl.ToFixed(this));
  }
  toJson() {
    return Vl.ToJson(this);
  }
  toArray() {
    return Vl.ToArray(this);
  }
  static Add(d, l) {
    return new Vl(d.x + l.x, d.y + l.y);
  }
  static AddXY(d, l, i) {
    return new Vl(d.x + l, d.y + i);
  }
  static Sub(d, l) {
    return new Vl(d.x - l.x, d.y - l.y);
  }
  static SubXY(d, l, i) {
    return new Vl(d.x - l, d.y - i);
  }
  static AddScalar(d, l) {
    return new Vl(d.x + l, d.y + l);
  }
  static SubScalar(d, l) {
    return new Vl(d.x - l, d.y - l);
  }
  static Div(d, l) {
    return new Vl(d.x / l, d.y / l);
  }
  static Mul(d, l) {
    return new Vl(d.x * l, d.y * l);
  }
  static DivV(d, l) {
    return new Vl(d.x / l.x, d.y / l.y);
  }
  static MulV(d, l) {
    return new Vl(d.x * l.x, d.y * l.y);
  }
  static Neg(d) {
    return new Vl(-d.x, -d.y);
  }
  static Per(d) {
    return new Vl(d.y, -d.x);
  }
  static Dist2(d, l) {
    return Vl.Sub(d, l).len2();
  }
  static Abs(d) {
    return new Vl(Math.abs(d.x), Math.abs(d.y));
  }
  static Dist(d, l) {
    return Math.hypot(d.y - l.y, d.x - l.x);
  }
  static Dpr(d, l) {
    return d.x * l.x + d.y * l.y;
  }
  static Cross(d, l) {
    return new Vl(
      d.y * l.z - d.z * l.y,
      d.z * l.x - d.x * l.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  static Cpr(d, l) {
    return d.x * l.y - l.x * d.y;
  }
  static Len2(d) {
    return d.x * d.x + d.y * d.y;
  }
  static Len(d) {
    return Math.hypot(d.x, d.y);
  }
  static Pry(d, l) {
    return Vl.Dpr(d, l) / Vl.Len(l);
  }
  static Uni(d) {
    return Vl.Div(d, Vl.Len(d));
  }
  static Tan(d, l) {
    return Vl.Uni(Vl.Sub(d, l));
  }
  static Min(d, l) {
    return new Vl(Math.min(d.x, l.x), Math.min(d.y, l.y));
  }
  static Max(d, l) {
    return new Vl(Math.max(d.x, l.x), Math.max(d.y, l.y));
  }
  static From(d) {
    return new Vl().add(d);
  }
  static FromArray(d) {
    return new Vl(d[0], d[1]);
  }
  static Rot(d, l = 0) {
    const i = Math.sin(l), s = Math.cos(l);
    return new Vl(d.x * s - d.y * i, d.x * i + d.y * s);
  }
  static RotWith(d, l, i) {
    const s = d.x - l.x, c = d.y - l.y, m = Math.sin(i), n = Math.cos(i);
    return new Vl(l.x + (s * n - c * m), l.y + (s * m + c * n));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(d, l, i) {
    return Vl.Mul(l, Vl.Sub(i, d).pry(l)).add(d);
  }
  static NearestPointOnLineSegment(d, l, i, s = !0) {
    const c = Vl.Tan(l, d), m = Vl.Add(d, Vl.Mul(c, Vl.Sub(i, d).pry(c)));
    if (s) {
      if (m.x < Math.min(d.x, l.x))
        return Vl.Cast(d.x < l.x ? d : l);
      if (m.x > Math.max(d.x, l.x))
        return Vl.Cast(d.x > l.x ? d : l);
      if (m.y < Math.min(d.y, l.y))
        return Vl.Cast(d.y < l.y ? d : l);
      if (m.y > Math.max(d.y, l.y))
        return Vl.Cast(d.y > l.y ? d : l);
    }
    return m;
  }
  static DistanceToLineThroughPoint(d, l, i) {
    return Vl.Dist(i, Vl.NearestPointOnLineThroughPoint(d, l, i));
  }
  static DistanceToLineSegment(d, l, i, s = !0) {
    return Vl.Dist(i, Vl.NearestPointOnLineSegment(d, l, i, s));
  }
  static Snap(d, l = 1) {
    return new Vl(Math.round(d.x / l) * l, Math.round(d.y / l) * l);
  }
  static Cast(d) {
    return d instanceof Vl ? d : Vl.From(d);
  }
  static Slope(d, l) {
    return d.x === l.y ? NaN : (d.y - l.y) / (d.x - l.x);
  }
  static Angle(d, l) {
    return Math.atan2(l.y - d.y, l.x - d.x);
  }
  static Lrp(d, l, i) {
    return Vl.Sub(l, d).mul(i).add(d);
  }
  static Med(d, l) {
    return new Vl((d.x + l.x) / 2, (d.y + l.y) / 2);
  }
  static Equals(d, l, i = 1e-4) {
    return Math.abs(d.x - l.x) < i && Math.abs(d.y - l.y) < i;
  }
  static EqualsXY(d, l, i) {
    return d.x === l && d.y === i;
  }
  static EqualsXYZ(d, l, i = 1e-4) {
    return Vl.Equals(d, l, i) && Math.abs((d.z || 0) - (l.z || 0)) < i;
  }
  static Clockwise(d, l, i) {
    return (i.x - d.x) * (l.y - d.y) - (l.x - d.x) * (i.y - d.y) < 0;
  }
  static Rescale(d, l) {
    const i = Vl.Len(d);
    return new Vl(l * d.x / i, l * d.y / i);
  }
  static ScaleWithOrigin(d, l, i) {
    return Vl.Sub(d, i).mul(l).add(i);
  }
  static ScaleWOrigin(d, l, i) {
    return Vl.Sub(d, i).mulV(l).add(i);
  }
  static ToFixed(d, l = 2) {
    return new Vl(+d.x.toFixed(l), +d.y.toFixed(l), +d.z.toFixed(l));
  }
  static Nudge(d, l, i) {
    return Vl.Add(d, Vl.Tan(l, d).mul(i));
  }
  static ToString(d) {
    return `${d.x}, ${d.y}`;
  }
  static ToAngle(d) {
    let l = Math.atan2(d.y, d.x);
    return l < 0 && (l += Math.PI * 2), l;
  }
  static FromAngle(d, l = 1) {
    return new Vl(Math.cos(d) * l, Math.sin(d) * l);
  }
  static ToArray(d) {
    return [d.x, d.y, d.z];
  }
  static ToJson(d) {
    const { x: l, y: i, z: s } = d;
    return { x: l, y: i, z: s };
  }
  static Average(d) {
    const l = d.length, i = new Vl(0, 0);
    for (let s = 0; s < l; s++)
      i.add(d[s]);
    return i.div(l);
  }
  static Clamp(d, l, i) {
    return i === void 0 ? new Vl(Math.min(Math.max(d.x, l)), Math.min(Math.max(d.y, l))) : new Vl(Math.min(Math.max(d.x, l), i), Math.min(Math.max(d.y, l), i));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(d, l, i = 6) {
    const s = [];
    for (let c = 0; c < i; c++) {
      const m = bo.easeInQuad(c / (i - 1)), n = Vl.Lrp(d, l, m);
      n.z = Math.min(1, 0.5 + Math.abs(0.5 - Zo(m)) * 0.65), s.push(n);
    }
    return s;
  }
  static SnapToGrid(d, l = 8) {
    return new Vl(Math.round(d.x / l) * l, Math.round(d.y / l) * l);
  }
}
const Zo = (b) => b < 0.5 ? 2 * b * b : -1 + (4 - 2 * b) * b;
class Ml extends Vl {
  constructor(d = 0, l = 0, i = 0, s = { x: 0, y: 0 }, c = 0, m = 0) {
    super(d, l, i), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "v", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "t", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: c
    }), Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: m
    });
  }
  get timestamp() {
    return this.t;
  }
  get pressure() {
    return this.z;
  }
  get angleNum() {
    return this.a;
  }
  get XY() {
    return [this.x, this.y];
  }
  setA(d) {
    this.a = d;
  }
  setT(d) {
    this.t = d;
  }
  setv(d) {
    return this.v = { x: d.x, y: d.y }, this;
  }
  set(d = this.x, l = this.y, i = this.z, s = this.v, c = this.t, m = this.a) {
    return this.x = d, this.y = l, this.z = i, this.v = s, this.t = c, this.a = m, this;
  }
  clone() {
    const { x: d, y: l, z: i, v: s, t: c, a: m } = this, n = { x: s.x, y: s.y };
    return new Ml(d, l, i, n, c, m);
  }
  distance(d) {
    return Ml.GetDistance(this, d);
  }
  isNear(d, l) {
    return Ml.IsNear(this, d, l);
  }
  getAngleByPoints(d, l) {
    return Ml.GetAngleByPoints(d, this, l);
  }
  static Sub(d, l) {
    return new Ml(d.x - l.x, d.y - l.y);
  }
  static Add(d, l) {
    return new Ml(d.x + l.x, d.y + l.y);
  }
  static GetDistance(d, l) {
    return Ml.Len(d.clone().sub(l));
  }
  static GetAngleByPoints(d, l, i) {
    const s = l.x - d.x, c = i.x - l.x, m = l.y - d.y, n = i.y - l.y;
    let X = 0;
    const G = Math.sqrt(s * s + m * m), L = Math.sqrt(c * c + n * n);
    if (G && L) {
      const o = s * c + m * n;
      X = Math.acos(o / (G * L)), X = X / Math.PI * 180;
      let h = s * n - m * c;
      h = h > 0 ? 1 : -1, X = 180 + h * X;
    }
    return X;
  }
  static IsNear(d, l, i) {
    return Ml.Len(d.clone().sub(l)) < i;
  }
  static RotWith(d, l, i, s = 2) {
    const c = d.x - l.x, m = d.y - l.y, n = Math.sin(i), X = Math.cos(i), G = Math.pow(10, s), L = Math.floor((l.x + (c * X - m * n)) * G) / G, o = Math.floor((l.y + (c * n + m * X)) * G) / G;
    return new Ml(L, o);
  }
  /**
   * 根据圆心和半径，获取圆上的等份点
   * @param o 圆心
   * @param radius 半径
   * @param average 均分数
   * @returns
   */
  static GetDotStroke(d, l, i = 16) {
    const s = new Vl(1, 1), c = Math.PI + 1e-3, m = Ml.Add(d, Ml.Sub(d, s).uni().per().mul(-l)), n = [];
    for (let X = 1 / i, G = X; G <= 1; G += X)
      n.push(Ml.RotWith(m, d, c * 2 * G));
    return n;
  }
  /**
   * 根据圆心和圆上的起始点，获取半圆上的等份点
   * @param o 圆心
   * @param p 圆弧起始点
   * @param radian 1，逆时针180度 -1，顺时针
   * @param average 均分数
   * @returns
   */
  static GetSemicircleStroke(d, l, i = -1, s = 8) {
    const c = i * (Math.PI + 1e-3), m = [];
    for (let n = 1 / s, X = n; X <= 1; X += n)
      m.push(Ml.RotWith(l, d, c * X));
    return m;
  }
}
var mo = Jd, no = Ld, Xo = "[object Number]";
function eo(b) {
  return typeof b == "number" || no(b) && mo(b) == Xo;
}
var ao = eo;
const $l = /* @__PURE__ */ Cd(ao);
var Fl = (
  /******/
  function(b) {
    var d = {};
    function l(i) {
      if (d[i])
        return d[i].exports;
      var s = d[i] = {
        /******/
        i,
        /******/
        l: !1,
        /******/
        exports: {}
        /******/
      };
      return b[i].call(s.exports, s, s.exports, l), s.l = !0, s.exports;
    }
    return l.m = b, l.c = d, l.d = function(i, s, c) {
      l.o(i, s) || Object.defineProperty(i, s, { enumerable: !0, get: c });
    }, l.r = function(i) {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
    }, l.t = function(i, s) {
      if (s & 1 && (i = l(i)), s & 8 || s & 4 && typeof i == "object" && i && i.__esModule)
        return i;
      var c = /* @__PURE__ */ Object.create(null);
      if (l.r(c), Object.defineProperty(c, "default", { enumerable: !0, value: i }), s & 2 && typeof i != "string")
        for (var m in i)
          l.d(c, m, (function(n) {
            return i[n];
          }).bind(null, m));
      return c;
    }, l.n = function(i) {
      var s = i && i.__esModule ? (
        /******/
        function() {
          return i.default;
        }
      ) : (
        /******/
        function() {
          return i;
        }
      );
      return l.d(s, "a", s), s;
    }, l.o = function(i, s) {
      return Object.prototype.hasOwnProperty.call(i, s);
    }, l.p = "/js/", l(l.s = 0);
  }([
    /* 0 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "version", function() {
        return P;
      }), l.d(d, "helpers", function() {
        return N;
      }), l.d(d, "createElement", function() {
        return F;
      }), l.d(d, "isSpriteNode", function() {
        return R;
      }), l.d(d, "registerNode", function() {
        return S;
      });
      var i = l(12);
      l.d(d, "ENV", function() {
        return i.ENV;
      });
      var s = l(68);
      l.d(d, "requestAnimationFrame", function() {
        return s.requestAnimationFrame;
      }), l.d(d, "cancelAnimationFrame", function() {
        return s.cancelAnimationFrame;
      });
      var c = l(70);
      l.d(d, "Node", function() {
        return c.default;
      });
      var m = l(217);
      l.d(d, "Cloud", function() {
        return m.default;
      });
      var n = l(219);
      l.d(d, "Block", function() {
        return n.default;
      });
      var X = l(224);
      l.d(d, "Sprite", function() {
        return X.default;
      });
      var G = l(226);
      l.d(d, "Path", function() {
        return G.default;
      });
      var L = l(229);
      l.d(d, "Rect", function() {
        return L.default;
      });
      var o = l(231);
      l.d(d, "Triangle", function() {
        return o.default;
      });
      var h = l(236);
      l.d(d, "Parallel", function() {
        return h.default;
      });
      var p = l(238);
      l.d(d, "Regular", function() {
        return p.default;
      });
      var r = l(240);
      l.d(d, "Star", function() {
        return r.default;
      });
      var V = l(242);
      l.d(d, "Ellipse", function() {
        return V.default;
      });
      var W = l(244);
      l.d(d, "Arc", function() {
        return W.default;
      });
      var y = l(246);
      l.d(d, "Ring", function() {
        return y.default;
      });
      var t = l(232);
      l.d(d, "Polyline", function() {
        return t.default;
      });
      var e = l(248);
      l.d(d, "Label", function() {
        return e.default;
      });
      var Z = l(250);
      l.d(d, "Group", function() {
        return Z.default;
      });
      var a = l(286);
      l.d(d, "Layer", function() {
        return a.default;
      });
      var x = l(287);
      l.d(d, "SpriteSvg", function() {
        return x.default;
      });
      var K = l(289);
      l.d(d, "LayerWorker", function() {
        return K.default;
      });
      var C = l(290);
      l.d(d, "Scene", function() {
        return C.default;
      });
      var T = l(213), I = l(221);
      l.d(d, "Color", function() {
        return I.Color;
      }), l.d(d, "Gradient", function() {
        return I.Gradient;
      });
      var J = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const F = T.default.createElement, R = T.default.isSpriteNode, S = T.default.registerNode, N = {
        parseColor: I.parseColor,
        sizeToPixel: J.sizeToPixel,
        toArray: J.toArray,
        toString: J.toString,
        toNumber: J.toNumber
      };
      let Q;
      Q = "3.8.3";
      const P = Q;
    },
    /* 1 */
    /***/
    function(b, d, l) {
      l.r(d);
      var i = l(2);
      l.d(d, "glMatrix", function() {
        return i;
      });
      var s = l(3);
      l.d(d, "mat2", function() {
        return s;
      });
      var c = l(4);
      l.d(d, "mat2d", function() {
        return c;
      });
      var m = l(5);
      l.d(d, "mat3", function() {
        return m;
      });
      var n = l(6);
      l.d(d, "mat4", function() {
        return n;
      });
      var X = l(7);
      l.d(d, "quat", function() {
        return X;
      });
      var G = l(10);
      l.d(d, "quat2", function() {
        return G;
      });
      var L = l(11);
      l.d(d, "vec2", function() {
        return L;
      });
      var o = l(8);
      l.d(d, "vec3", function() {
        return o;
      });
      var h = l(9);
      l.d(d, "vec4", function() {
        return h;
      });
    },
    /* 2 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "EPSILON", function() {
        return i;
      }), l.d(d, "ARRAY_TYPE", function() {
        return s;
      }), l.d(d, "RANDOM", function() {
        return c;
      }), l.d(d, "setMatrixArrayType", function() {
        return m;
      }), l.d(d, "toRadian", function() {
        return X;
      }), l.d(d, "equals", function() {
        return G;
      });
      var i = 1e-6, s = typeof Float32Array < "u" ? Float32Array : Array, c = Math.random;
      function m(L) {
        s = L;
      }
      var n = Math.PI / 180;
      function X(L) {
        return L * n;
      }
      function G(L, o) {
        return Math.abs(L - o) <= i * Math.max(1, Math.abs(L), Math.abs(o));
      }
      Math.hypot || (Math.hypot = function() {
        for (var L = 0, o = arguments.length; o--; )
          L += arguments[o] * arguments[o];
        return Math.sqrt(L);
      });
    },
    /* 3 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return s;
      }), l.d(d, "clone", function() {
        return c;
      }), l.d(d, "copy", function() {
        return m;
      }), l.d(d, "identity", function() {
        return n;
      }), l.d(d, "fromValues", function() {
        return X;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "transpose", function() {
        return L;
      }), l.d(d, "invert", function() {
        return o;
      }), l.d(d, "adjoint", function() {
        return h;
      }), l.d(d, "determinant", function() {
        return p;
      }), l.d(d, "multiply", function() {
        return r;
      }), l.d(d, "rotate", function() {
        return V;
      }), l.d(d, "scale", function() {
        return W;
      }), l.d(d, "fromRotation", function() {
        return y;
      }), l.d(d, "fromScaling", function() {
        return t;
      }), l.d(d, "str", function() {
        return e;
      }), l.d(d, "frob", function() {
        return Z;
      }), l.d(d, "LDU", function() {
        return a;
      }), l.d(d, "add", function() {
        return x;
      }), l.d(d, "subtract", function() {
        return K;
      }), l.d(d, "exactEquals", function() {
        return C;
      }), l.d(d, "equals", function() {
        return T;
      }), l.d(d, "multiplyScalar", function() {
        return I;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return J;
      }), l.d(d, "mul", function() {
        return F;
      }), l.d(d, "sub", function() {
        return R;
      });
      var i = l(2);
      function s() {
        var S = new i.ARRAY_TYPE(4);
        return i.ARRAY_TYPE != Float32Array && (S[1] = 0, S[2] = 0), S[0] = 1, S[3] = 1, S;
      }
      function c(S) {
        var N = new i.ARRAY_TYPE(4);
        return N[0] = S[0], N[1] = S[1], N[2] = S[2], N[3] = S[3], N;
      }
      function m(S, N) {
        return S[0] = N[0], S[1] = N[1], S[2] = N[2], S[3] = N[3], S;
      }
      function n(S) {
        return S[0] = 1, S[1] = 0, S[2] = 0, S[3] = 1, S;
      }
      function X(S, N, Q, P) {
        var j = new i.ARRAY_TYPE(4);
        return j[0] = S, j[1] = N, j[2] = Q, j[3] = P, j;
      }
      function G(S, N, Q, P, j) {
        return S[0] = N, S[1] = Q, S[2] = P, S[3] = j, S;
      }
      function L(S, N) {
        if (S === N) {
          var Q = N[1];
          S[1] = N[2], S[2] = Q;
        } else
          S[0] = N[0], S[1] = N[2], S[2] = N[1], S[3] = N[3];
        return S;
      }
      function o(S, N) {
        var Q = N[0], P = N[1], j = N[2], D = N[3], z = Q * D - j * P;
        return z ? (z = 1 / z, S[0] = D * z, S[1] = -P * z, S[2] = -j * z, S[3] = Q * z, S) : null;
      }
      function h(S, N) {
        var Q = N[0];
        return S[0] = N[3], S[1] = -N[1], S[2] = -N[2], S[3] = Q, S;
      }
      function p(S) {
        return S[0] * S[3] - S[2] * S[1];
      }
      function r(S, N, Q) {
        var P = N[0], j = N[1], D = N[2], z = N[3], w = Q[0], A = Q[1], ll = Q[2], _ = Q[3];
        return S[0] = P * w + D * A, S[1] = j * w + z * A, S[2] = P * ll + D * _, S[3] = j * ll + z * _, S;
      }
      function V(S, N, Q) {
        var P = N[0], j = N[1], D = N[2], z = N[3], w = Math.sin(Q), A = Math.cos(Q);
        return S[0] = P * A + D * w, S[1] = j * A + z * w, S[2] = P * -w + D * A, S[3] = j * -w + z * A, S;
      }
      function W(S, N, Q) {
        var P = N[0], j = N[1], D = N[2], z = N[3], w = Q[0], A = Q[1];
        return S[0] = P * w, S[1] = j * w, S[2] = D * A, S[3] = z * A, S;
      }
      function y(S, N) {
        var Q = Math.sin(N), P = Math.cos(N);
        return S[0] = P, S[1] = Q, S[2] = -Q, S[3] = P, S;
      }
      function t(S, N) {
        return S[0] = N[0], S[1] = 0, S[2] = 0, S[3] = N[1], S;
      }
      function e(S) {
        return "mat2(" + S[0] + ", " + S[1] + ", " + S[2] + ", " + S[3] + ")";
      }
      function Z(S) {
        return Math.hypot(S[0], S[1], S[2], S[3]);
      }
      function a(S, N, Q, P) {
        return S[2] = P[2] / P[0], Q[0] = P[0], Q[1] = P[1], Q[3] = P[3] - S[2] * Q[1], [S, N, Q];
      }
      function x(S, N, Q) {
        return S[0] = N[0] + Q[0], S[1] = N[1] + Q[1], S[2] = N[2] + Q[2], S[3] = N[3] + Q[3], S;
      }
      function K(S, N, Q) {
        return S[0] = N[0] - Q[0], S[1] = N[1] - Q[1], S[2] = N[2] - Q[2], S[3] = N[3] - Q[3], S;
      }
      function C(S, N) {
        return S[0] === N[0] && S[1] === N[1] && S[2] === N[2] && S[3] === N[3];
      }
      function T(S, N) {
        var Q = S[0], P = S[1], j = S[2], D = S[3], z = N[0], w = N[1], A = N[2], ll = N[3];
        return Math.abs(Q - z) <= i.EPSILON * Math.max(1, Math.abs(Q), Math.abs(z)) && Math.abs(P - w) <= i.EPSILON * Math.max(1, Math.abs(P), Math.abs(w)) && Math.abs(j - A) <= i.EPSILON * Math.max(1, Math.abs(j), Math.abs(A)) && Math.abs(D - ll) <= i.EPSILON * Math.max(1, Math.abs(D), Math.abs(ll));
      }
      function I(S, N, Q) {
        return S[0] = N[0] * Q, S[1] = N[1] * Q, S[2] = N[2] * Q, S[3] = N[3] * Q, S;
      }
      function J(S, N, Q, P) {
        return S[0] = N[0] + Q[0] * P, S[1] = N[1] + Q[1] * P, S[2] = N[2] + Q[2] * P, S[3] = N[3] + Q[3] * P, S;
      }
      var F = r, R = K;
    },
    /* 4 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return s;
      }), l.d(d, "clone", function() {
        return c;
      }), l.d(d, "copy", function() {
        return m;
      }), l.d(d, "identity", function() {
        return n;
      }), l.d(d, "fromValues", function() {
        return X;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "invert", function() {
        return L;
      }), l.d(d, "determinant", function() {
        return o;
      }), l.d(d, "multiply", function() {
        return h;
      }), l.d(d, "rotate", function() {
        return p;
      }), l.d(d, "scale", function() {
        return r;
      }), l.d(d, "translate", function() {
        return V;
      }), l.d(d, "fromRotation", function() {
        return W;
      }), l.d(d, "fromScaling", function() {
        return y;
      }), l.d(d, "fromTranslation", function() {
        return t;
      }), l.d(d, "str", function() {
        return e;
      }), l.d(d, "frob", function() {
        return Z;
      }), l.d(d, "add", function() {
        return a;
      }), l.d(d, "subtract", function() {
        return x;
      }), l.d(d, "multiplyScalar", function() {
        return K;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return C;
      }), l.d(d, "exactEquals", function() {
        return T;
      }), l.d(d, "equals", function() {
        return I;
      }), l.d(d, "mul", function() {
        return J;
      }), l.d(d, "sub", function() {
        return F;
      });
      var i = l(2);
      function s() {
        var R = new i.ARRAY_TYPE(6);
        return i.ARRAY_TYPE != Float32Array && (R[1] = 0, R[2] = 0, R[4] = 0, R[5] = 0), R[0] = 1, R[3] = 1, R;
      }
      function c(R) {
        var S = new i.ARRAY_TYPE(6);
        return S[0] = R[0], S[1] = R[1], S[2] = R[2], S[3] = R[3], S[4] = R[4], S[5] = R[5], S;
      }
      function m(R, S) {
        return R[0] = S[0], R[1] = S[1], R[2] = S[2], R[3] = S[3], R[4] = S[4], R[5] = S[5], R;
      }
      function n(R) {
        return R[0] = 1, R[1] = 0, R[2] = 0, R[3] = 1, R[4] = 0, R[5] = 0, R;
      }
      function X(R, S, N, Q, P, j) {
        var D = new i.ARRAY_TYPE(6);
        return D[0] = R, D[1] = S, D[2] = N, D[3] = Q, D[4] = P, D[5] = j, D;
      }
      function G(R, S, N, Q, P, j, D) {
        return R[0] = S, R[1] = N, R[2] = Q, R[3] = P, R[4] = j, R[5] = D, R;
      }
      function L(R, S) {
        var N = S[0], Q = S[1], P = S[2], j = S[3], D = S[4], z = S[5], w = N * j - Q * P;
        return w ? (w = 1 / w, R[0] = j * w, R[1] = -Q * w, R[2] = -P * w, R[3] = N * w, R[4] = (P * z - j * D) * w, R[5] = (Q * D - N * z) * w, R) : null;
      }
      function o(R) {
        return R[0] * R[3] - R[1] * R[2];
      }
      function h(R, S, N) {
        var Q = S[0], P = S[1], j = S[2], D = S[3], z = S[4], w = S[5], A = N[0], ll = N[1], _ = N[2], cl = N[3], $ = N[4], al = N[5];
        return R[0] = Q * A + j * ll, R[1] = P * A + D * ll, R[2] = Q * _ + j * cl, R[3] = P * _ + D * cl, R[4] = Q * $ + j * al + z, R[5] = P * $ + D * al + w, R;
      }
      function p(R, S, N) {
        var Q = S[0], P = S[1], j = S[2], D = S[3], z = S[4], w = S[5], A = Math.sin(N), ll = Math.cos(N);
        return R[0] = Q * ll + j * A, R[1] = P * ll + D * A, R[2] = Q * -A + j * ll, R[3] = P * -A + D * ll, R[4] = z, R[5] = w, R;
      }
      function r(R, S, N) {
        var Q = S[0], P = S[1], j = S[2], D = S[3], z = S[4], w = S[5], A = N[0], ll = N[1];
        return R[0] = Q * A, R[1] = P * A, R[2] = j * ll, R[3] = D * ll, R[4] = z, R[5] = w, R;
      }
      function V(R, S, N) {
        var Q = S[0], P = S[1], j = S[2], D = S[3], z = S[4], w = S[5], A = N[0], ll = N[1];
        return R[0] = Q, R[1] = P, R[2] = j, R[3] = D, R[4] = Q * A + j * ll + z, R[5] = P * A + D * ll + w, R;
      }
      function W(R, S) {
        var N = Math.sin(S), Q = Math.cos(S);
        return R[0] = Q, R[1] = N, R[2] = -N, R[3] = Q, R[4] = 0, R[5] = 0, R;
      }
      function y(R, S) {
        return R[0] = S[0], R[1] = 0, R[2] = 0, R[3] = S[1], R[4] = 0, R[5] = 0, R;
      }
      function t(R, S) {
        return R[0] = 1, R[1] = 0, R[2] = 0, R[3] = 1, R[4] = S[0], R[5] = S[1], R;
      }
      function e(R) {
        return "mat2d(" + R[0] + ", " + R[1] + ", " + R[2] + ", " + R[3] + ", " + R[4] + ", " + R[5] + ")";
      }
      function Z(R) {
        return Math.hypot(R[0], R[1], R[2], R[3], R[4], R[5], 1);
      }
      function a(R, S, N) {
        return R[0] = S[0] + N[0], R[1] = S[1] + N[1], R[2] = S[2] + N[2], R[3] = S[3] + N[3], R[4] = S[4] + N[4], R[5] = S[5] + N[5], R;
      }
      function x(R, S, N) {
        return R[0] = S[0] - N[0], R[1] = S[1] - N[1], R[2] = S[2] - N[2], R[3] = S[3] - N[3], R[4] = S[4] - N[4], R[5] = S[5] - N[5], R;
      }
      function K(R, S, N) {
        return R[0] = S[0] * N, R[1] = S[1] * N, R[2] = S[2] * N, R[3] = S[3] * N, R[4] = S[4] * N, R[5] = S[5] * N, R;
      }
      function C(R, S, N, Q) {
        return R[0] = S[0] + N[0] * Q, R[1] = S[1] + N[1] * Q, R[2] = S[2] + N[2] * Q, R[3] = S[3] + N[3] * Q, R[4] = S[4] + N[4] * Q, R[5] = S[5] + N[5] * Q, R;
      }
      function T(R, S) {
        return R[0] === S[0] && R[1] === S[1] && R[2] === S[2] && R[3] === S[3] && R[4] === S[4] && R[5] === S[5];
      }
      function I(R, S) {
        var N = R[0], Q = R[1], P = R[2], j = R[3], D = R[4], z = R[5], w = S[0], A = S[1], ll = S[2], _ = S[3], cl = S[4], $ = S[5];
        return Math.abs(N - w) <= i.EPSILON * Math.max(1, Math.abs(N), Math.abs(w)) && Math.abs(Q - A) <= i.EPSILON * Math.max(1, Math.abs(Q), Math.abs(A)) && Math.abs(P - ll) <= i.EPSILON * Math.max(1, Math.abs(P), Math.abs(ll)) && Math.abs(j - _) <= i.EPSILON * Math.max(1, Math.abs(j), Math.abs(_)) && Math.abs(D - cl) <= i.EPSILON * Math.max(1, Math.abs(D), Math.abs(cl)) && Math.abs(z - $) <= i.EPSILON * Math.max(1, Math.abs(z), Math.abs($));
      }
      var J = h, F = x;
    },
    /* 5 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return s;
      }), l.d(d, "fromMat4", function() {
        return c;
      }), l.d(d, "clone", function() {
        return m;
      }), l.d(d, "copy", function() {
        return n;
      }), l.d(d, "fromValues", function() {
        return X;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "identity", function() {
        return L;
      }), l.d(d, "transpose", function() {
        return o;
      }), l.d(d, "invert", function() {
        return h;
      }), l.d(d, "adjoint", function() {
        return p;
      }), l.d(d, "determinant", function() {
        return r;
      }), l.d(d, "multiply", function() {
        return V;
      }), l.d(d, "translate", function() {
        return W;
      }), l.d(d, "rotate", function() {
        return y;
      }), l.d(d, "scale", function() {
        return t;
      }), l.d(d, "fromTranslation", function() {
        return e;
      }), l.d(d, "fromRotation", function() {
        return Z;
      }), l.d(d, "fromScaling", function() {
        return a;
      }), l.d(d, "fromMat2d", function() {
        return x;
      }), l.d(d, "fromQuat", function() {
        return K;
      }), l.d(d, "normalFromMat4", function() {
        return C;
      }), l.d(d, "projection", function() {
        return T;
      }), l.d(d, "str", function() {
        return I;
      }), l.d(d, "frob", function() {
        return J;
      }), l.d(d, "add", function() {
        return F;
      }), l.d(d, "subtract", function() {
        return R;
      }), l.d(d, "multiplyScalar", function() {
        return S;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return N;
      }), l.d(d, "exactEquals", function() {
        return Q;
      }), l.d(d, "equals", function() {
        return P;
      }), l.d(d, "mul", function() {
        return j;
      }), l.d(d, "sub", function() {
        return D;
      });
      var i = l(2);
      function s() {
        var z = new i.ARRAY_TYPE(9);
        return i.ARRAY_TYPE != Float32Array && (z[1] = 0, z[2] = 0, z[3] = 0, z[5] = 0, z[6] = 0, z[7] = 0), z[0] = 1, z[4] = 1, z[8] = 1, z;
      }
      function c(z, w) {
        return z[0] = w[0], z[1] = w[1], z[2] = w[2], z[3] = w[4], z[4] = w[5], z[5] = w[6], z[6] = w[8], z[7] = w[9], z[8] = w[10], z;
      }
      function m(z) {
        var w = new i.ARRAY_TYPE(9);
        return w[0] = z[0], w[1] = z[1], w[2] = z[2], w[3] = z[3], w[4] = z[4], w[5] = z[5], w[6] = z[6], w[7] = z[7], w[8] = z[8], w;
      }
      function n(z, w) {
        return z[0] = w[0], z[1] = w[1], z[2] = w[2], z[3] = w[3], z[4] = w[4], z[5] = w[5], z[6] = w[6], z[7] = w[7], z[8] = w[8], z;
      }
      function X(z, w, A, ll, _, cl, $, al, Xl) {
        var M = new i.ARRAY_TYPE(9);
        return M[0] = z, M[1] = w, M[2] = A, M[3] = ll, M[4] = _, M[5] = cl, M[6] = $, M[7] = al, M[8] = Xl, M;
      }
      function G(z, w, A, ll, _, cl, $, al, Xl, M) {
        return z[0] = w, z[1] = A, z[2] = ll, z[3] = _, z[4] = cl, z[5] = $, z[6] = al, z[7] = Xl, z[8] = M, z;
      }
      function L(z) {
        return z[0] = 1, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = 1, z[5] = 0, z[6] = 0, z[7] = 0, z[8] = 1, z;
      }
      function o(z, w) {
        if (z === w) {
          var A = w[1], ll = w[2], _ = w[5];
          z[1] = w[3], z[2] = w[6], z[3] = A, z[5] = w[7], z[6] = ll, z[7] = _;
        } else
          z[0] = w[0], z[1] = w[3], z[2] = w[6], z[3] = w[1], z[4] = w[4], z[5] = w[7], z[6] = w[2], z[7] = w[5], z[8] = w[8];
        return z;
      }
      function h(z, w) {
        var A = w[0], ll = w[1], _ = w[2], cl = w[3], $ = w[4], al = w[5], Xl = w[6], M = w[7], k = w[8], E = k * $ - al * M, O = -k * cl + al * Xl, g = M * cl - $ * Xl, U = A * E + ll * O + _ * g;
        return U ? (U = 1 / U, z[0] = E * U, z[1] = (-k * ll + _ * M) * U, z[2] = (al * ll - _ * $) * U, z[3] = O * U, z[4] = (k * A - _ * Xl) * U, z[5] = (-al * A + _ * cl) * U, z[6] = g * U, z[7] = (-M * A + ll * Xl) * U, z[8] = ($ * A - ll * cl) * U, z) : null;
      }
      function p(z, w) {
        var A = w[0], ll = w[1], _ = w[2], cl = w[3], $ = w[4], al = w[5], Xl = w[6], M = w[7], k = w[8];
        return z[0] = $ * k - al * M, z[1] = _ * M - ll * k, z[2] = ll * al - _ * $, z[3] = al * Xl - cl * k, z[4] = A * k - _ * Xl, z[5] = _ * cl - A * al, z[6] = cl * M - $ * Xl, z[7] = ll * Xl - A * M, z[8] = A * $ - ll * cl, z;
      }
      function r(z) {
        var w = z[0], A = z[1], ll = z[2], _ = z[3], cl = z[4], $ = z[5], al = z[6], Xl = z[7], M = z[8];
        return w * (M * cl - $ * Xl) + A * (-M * _ + $ * al) + ll * (Xl * _ - cl * al);
      }
      function V(z, w, A) {
        var ll = w[0], _ = w[1], cl = w[2], $ = w[3], al = w[4], Xl = w[5], M = w[6], k = w[7], E = w[8], O = A[0], g = A[1], U = A[2], u = A[3], Y = A[4], H = A[5], v = A[6], f = A[7], B = A[8];
        return z[0] = O * ll + g * $ + U * M, z[1] = O * _ + g * al + U * k, z[2] = O * cl + g * Xl + U * E, z[3] = u * ll + Y * $ + H * M, z[4] = u * _ + Y * al + H * k, z[5] = u * cl + Y * Xl + H * E, z[6] = v * ll + f * $ + B * M, z[7] = v * _ + f * al + B * k, z[8] = v * cl + f * Xl + B * E, z;
      }
      function W(z, w, A) {
        var ll = w[0], _ = w[1], cl = w[2], $ = w[3], al = w[4], Xl = w[5], M = w[6], k = w[7], E = w[8], O = A[0], g = A[1];
        return z[0] = ll, z[1] = _, z[2] = cl, z[3] = $, z[4] = al, z[5] = Xl, z[6] = O * ll + g * $ + M, z[7] = O * _ + g * al + k, z[8] = O * cl + g * Xl + E, z;
      }
      function y(z, w, A) {
        var ll = w[0], _ = w[1], cl = w[2], $ = w[3], al = w[4], Xl = w[5], M = w[6], k = w[7], E = w[8], O = Math.sin(A), g = Math.cos(A);
        return z[0] = g * ll + O * $, z[1] = g * _ + O * al, z[2] = g * cl + O * Xl, z[3] = g * $ - O * ll, z[4] = g * al - O * _, z[5] = g * Xl - O * cl, z[6] = M, z[7] = k, z[8] = E, z;
      }
      function t(z, w, A) {
        var ll = A[0], _ = A[1];
        return z[0] = ll * w[0], z[1] = ll * w[1], z[2] = ll * w[2], z[3] = _ * w[3], z[4] = _ * w[4], z[5] = _ * w[5], z[6] = w[6], z[7] = w[7], z[8] = w[8], z;
      }
      function e(z, w) {
        return z[0] = 1, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = 1, z[5] = 0, z[6] = w[0], z[7] = w[1], z[8] = 1, z;
      }
      function Z(z, w) {
        var A = Math.sin(w), ll = Math.cos(w);
        return z[0] = ll, z[1] = A, z[2] = 0, z[3] = -A, z[4] = ll, z[5] = 0, z[6] = 0, z[7] = 0, z[8] = 1, z;
      }
      function a(z, w) {
        return z[0] = w[0], z[1] = 0, z[2] = 0, z[3] = 0, z[4] = w[1], z[5] = 0, z[6] = 0, z[7] = 0, z[8] = 1, z;
      }
      function x(z, w) {
        return z[0] = w[0], z[1] = w[1], z[2] = 0, z[3] = w[2], z[4] = w[3], z[5] = 0, z[6] = w[4], z[7] = w[5], z[8] = 1, z;
      }
      function K(z, w) {
        var A = w[0], ll = w[1], _ = w[2], cl = w[3], $ = A + A, al = ll + ll, Xl = _ + _, M = A * $, k = ll * $, E = ll * al, O = _ * $, g = _ * al, U = _ * Xl, u = cl * $, Y = cl * al, H = cl * Xl;
        return z[0] = 1 - E - U, z[3] = k - H, z[6] = O + Y, z[1] = k + H, z[4] = 1 - M - U, z[7] = g - u, z[2] = O - Y, z[5] = g + u, z[8] = 1 - M - E, z;
      }
      function C(z, w) {
        var A = w[0], ll = w[1], _ = w[2], cl = w[3], $ = w[4], al = w[5], Xl = w[6], M = w[7], k = w[8], E = w[9], O = w[10], g = w[11], U = w[12], u = w[13], Y = w[14], H = w[15], v = A * al - ll * $, f = A * Xl - _ * $, B = A * M - cl * $, q = ll * Xl - _ * al, dl = ll * M - cl * al, il = _ * M - cl * Xl, bl = k * u - E * U, ml = k * Y - O * U, tl = k * H - g * U, sl = E * Y - O * u, Zl = E * H - g * u, ol = O * H - g * Y, Wl = v * ol - f * Zl + B * sl + q * tl - dl * ml + il * bl;
        return Wl ? (Wl = 1 / Wl, z[0] = (al * ol - Xl * Zl + M * sl) * Wl, z[1] = (Xl * tl - $ * ol - M * ml) * Wl, z[2] = ($ * Zl - al * tl + M * bl) * Wl, z[3] = (_ * Zl - ll * ol - cl * sl) * Wl, z[4] = (A * ol - _ * tl + cl * ml) * Wl, z[5] = (ll * tl - A * Zl - cl * bl) * Wl, z[6] = (u * il - Y * dl + H * q) * Wl, z[7] = (Y * B - U * il - H * f) * Wl, z[8] = (U * dl - u * B + H * v) * Wl, z) : null;
      }
      function T(z, w, A) {
        return z[0] = 2 / w, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = -2 / A, z[5] = 0, z[6] = -1, z[7] = 1, z[8] = 1, z;
      }
      function I(z) {
        return "mat3(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ", " + z[4] + ", " + z[5] + ", " + z[6] + ", " + z[7] + ", " + z[8] + ")";
      }
      function J(z) {
        return Math.hypot(z[0], z[1], z[2], z[3], z[4], z[5], z[6], z[7], z[8]);
      }
      function F(z, w, A) {
        return z[0] = w[0] + A[0], z[1] = w[1] + A[1], z[2] = w[2] + A[2], z[3] = w[3] + A[3], z[4] = w[4] + A[4], z[5] = w[5] + A[5], z[6] = w[6] + A[6], z[7] = w[7] + A[7], z[8] = w[8] + A[8], z;
      }
      function R(z, w, A) {
        return z[0] = w[0] - A[0], z[1] = w[1] - A[1], z[2] = w[2] - A[2], z[3] = w[3] - A[3], z[4] = w[4] - A[4], z[5] = w[5] - A[5], z[6] = w[6] - A[6], z[7] = w[7] - A[7], z[8] = w[8] - A[8], z;
      }
      function S(z, w, A) {
        return z[0] = w[0] * A, z[1] = w[1] * A, z[2] = w[2] * A, z[3] = w[3] * A, z[4] = w[4] * A, z[5] = w[5] * A, z[6] = w[6] * A, z[7] = w[7] * A, z[8] = w[8] * A, z;
      }
      function N(z, w, A, ll) {
        return z[0] = w[0] + A[0] * ll, z[1] = w[1] + A[1] * ll, z[2] = w[2] + A[2] * ll, z[3] = w[3] + A[3] * ll, z[4] = w[4] + A[4] * ll, z[5] = w[5] + A[5] * ll, z[6] = w[6] + A[6] * ll, z[7] = w[7] + A[7] * ll, z[8] = w[8] + A[8] * ll, z;
      }
      function Q(z, w) {
        return z[0] === w[0] && z[1] === w[1] && z[2] === w[2] && z[3] === w[3] && z[4] === w[4] && z[5] === w[5] && z[6] === w[6] && z[7] === w[7] && z[8] === w[8];
      }
      function P(z, w) {
        var A = z[0], ll = z[1], _ = z[2], cl = z[3], $ = z[4], al = z[5], Xl = z[6], M = z[7], k = z[8], E = w[0], O = w[1], g = w[2], U = w[3], u = w[4], Y = w[5], H = w[6], v = w[7], f = w[8];
        return Math.abs(A - E) <= i.EPSILON * Math.max(1, Math.abs(A), Math.abs(E)) && Math.abs(ll - O) <= i.EPSILON * Math.max(1, Math.abs(ll), Math.abs(O)) && Math.abs(_ - g) <= i.EPSILON * Math.max(1, Math.abs(_), Math.abs(g)) && Math.abs(cl - U) <= i.EPSILON * Math.max(1, Math.abs(cl), Math.abs(U)) && Math.abs($ - u) <= i.EPSILON * Math.max(1, Math.abs($), Math.abs(u)) && Math.abs(al - Y) <= i.EPSILON * Math.max(1, Math.abs(al), Math.abs(Y)) && Math.abs(Xl - H) <= i.EPSILON * Math.max(1, Math.abs(Xl), Math.abs(H)) && Math.abs(M - v) <= i.EPSILON * Math.max(1, Math.abs(M), Math.abs(v)) && Math.abs(k - f) <= i.EPSILON * Math.max(1, Math.abs(k), Math.abs(f));
      }
      var j = V, D = R;
    },
    /* 6 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return s;
      }), l.d(d, "clone", function() {
        return c;
      }), l.d(d, "copy", function() {
        return m;
      }), l.d(d, "fromValues", function() {
        return n;
      }), l.d(d, "set", function() {
        return X;
      }), l.d(d, "identity", function() {
        return G;
      }), l.d(d, "transpose", function() {
        return L;
      }), l.d(d, "invert", function() {
        return o;
      }), l.d(d, "adjoint", function() {
        return h;
      }), l.d(d, "determinant", function() {
        return p;
      }), l.d(d, "multiply", function() {
        return r;
      }), l.d(d, "translate", function() {
        return V;
      }), l.d(d, "scale", function() {
        return W;
      }), l.d(d, "rotate", function() {
        return y;
      }), l.d(d, "rotateX", function() {
        return t;
      }), l.d(d, "rotateY", function() {
        return e;
      }), l.d(d, "rotateZ", function() {
        return Z;
      }), l.d(d, "fromTranslation", function() {
        return a;
      }), l.d(d, "fromScaling", function() {
        return x;
      }), l.d(d, "fromRotation", function() {
        return K;
      }), l.d(d, "fromXRotation", function() {
        return C;
      }), l.d(d, "fromYRotation", function() {
        return T;
      }), l.d(d, "fromZRotation", function() {
        return I;
      }), l.d(d, "fromRotationTranslation", function() {
        return J;
      }), l.d(d, "fromQuat2", function() {
        return F;
      }), l.d(d, "getTranslation", function() {
        return R;
      }), l.d(d, "getScaling", function() {
        return S;
      }), l.d(d, "getRotation", function() {
        return N;
      }), l.d(d, "fromRotationTranslationScale", function() {
        return Q;
      }), l.d(d, "fromRotationTranslationScaleOrigin", function() {
        return P;
      }), l.d(d, "fromQuat", function() {
        return j;
      }), l.d(d, "frustum", function() {
        return D;
      }), l.d(d, "perspective", function() {
        return z;
      }), l.d(d, "perspectiveFromFieldOfView", function() {
        return w;
      }), l.d(d, "ortho", function() {
        return A;
      }), l.d(d, "lookAt", function() {
        return ll;
      }), l.d(d, "targetTo", function() {
        return _;
      }), l.d(d, "str", function() {
        return cl;
      }), l.d(d, "frob", function() {
        return $;
      }), l.d(d, "add", function() {
        return al;
      }), l.d(d, "subtract", function() {
        return Xl;
      }), l.d(d, "multiplyScalar", function() {
        return M;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return k;
      }), l.d(d, "exactEquals", function() {
        return E;
      }), l.d(d, "equals", function() {
        return O;
      }), l.d(d, "mul", function() {
        return g;
      }), l.d(d, "sub", function() {
        return U;
      });
      var i = l(2);
      function s() {
        var u = new i.ARRAY_TYPE(16);
        return i.ARRAY_TYPE != Float32Array && (u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0), u[0] = 1, u[5] = 1, u[10] = 1, u[15] = 1, u;
      }
      function c(u) {
        var Y = new i.ARRAY_TYPE(16);
        return Y[0] = u[0], Y[1] = u[1], Y[2] = u[2], Y[3] = u[3], Y[4] = u[4], Y[5] = u[5], Y[6] = u[6], Y[7] = u[7], Y[8] = u[8], Y[9] = u[9], Y[10] = u[10], Y[11] = u[11], Y[12] = u[12], Y[13] = u[13], Y[14] = u[14], Y[15] = u[15], Y;
      }
      function m(u, Y) {
        return u[0] = Y[0], u[1] = Y[1], u[2] = Y[2], u[3] = Y[3], u[4] = Y[4], u[5] = Y[5], u[6] = Y[6], u[7] = Y[7], u[8] = Y[8], u[9] = Y[9], u[10] = Y[10], u[11] = Y[11], u[12] = Y[12], u[13] = Y[13], u[14] = Y[14], u[15] = Y[15], u;
      }
      function n(u, Y, H, v, f, B, q, dl, il, bl, ml, tl, sl, Zl, ol, Wl) {
        var el = new i.ARRAY_TYPE(16);
        return el[0] = u, el[1] = Y, el[2] = H, el[3] = v, el[4] = f, el[5] = B, el[6] = q, el[7] = dl, el[8] = il, el[9] = bl, el[10] = ml, el[11] = tl, el[12] = sl, el[13] = Zl, el[14] = ol, el[15] = Wl, el;
      }
      function X(u, Y, H, v, f, B, q, dl, il, bl, ml, tl, sl, Zl, ol, Wl, el) {
        return u[0] = Y, u[1] = H, u[2] = v, u[3] = f, u[4] = B, u[5] = q, u[6] = dl, u[7] = il, u[8] = bl, u[9] = ml, u[10] = tl, u[11] = sl, u[12] = Zl, u[13] = ol, u[14] = Wl, u[15] = el, u;
      }
      function G(u) {
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function L(u, Y) {
        if (u === Y) {
          var H = Y[1], v = Y[2], f = Y[3], B = Y[6], q = Y[7], dl = Y[11];
          u[1] = Y[4], u[2] = Y[8], u[3] = Y[12], u[4] = H, u[6] = Y[9], u[7] = Y[13], u[8] = v, u[9] = B, u[11] = Y[14], u[12] = f, u[13] = q, u[14] = dl;
        } else
          u[0] = Y[0], u[1] = Y[4], u[2] = Y[8], u[3] = Y[12], u[4] = Y[1], u[5] = Y[5], u[6] = Y[9], u[7] = Y[13], u[8] = Y[2], u[9] = Y[6], u[10] = Y[10], u[11] = Y[14], u[12] = Y[3], u[13] = Y[7], u[14] = Y[11], u[15] = Y[15];
        return u;
      }
      function o(u, Y) {
        var H = Y[0], v = Y[1], f = Y[2], B = Y[3], q = Y[4], dl = Y[5], il = Y[6], bl = Y[7], ml = Y[8], tl = Y[9], sl = Y[10], Zl = Y[11], ol = Y[12], Wl = Y[13], el = Y[14], pl = Y[15], Kl = H * dl - v * q, Yl = H * il - f * q, xl = H * bl - B * q, rl = v * il - f * dl, Rl = v * bl - B * dl, fl = f * bl - B * il, Ul = ml * Wl - tl * ol, Ql = ml * el - sl * ol, wl = ml * pl - Zl * ol, Bl = tl * el - sl * Wl, jl = tl * pl - Zl * Wl, Dl = sl * pl - Zl * el, Tl = Kl * Dl - Yl * jl + xl * Bl + rl * wl - Rl * Ql + fl * Ul;
        return Tl ? (Tl = 1 / Tl, u[0] = (dl * Dl - il * jl + bl * Bl) * Tl, u[1] = (f * jl - v * Dl - B * Bl) * Tl, u[2] = (Wl * fl - el * Rl + pl * rl) * Tl, u[3] = (sl * Rl - tl * fl - Zl * rl) * Tl, u[4] = (il * wl - q * Dl - bl * Ql) * Tl, u[5] = (H * Dl - f * wl + B * Ql) * Tl, u[6] = (el * xl - ol * fl - pl * Yl) * Tl, u[7] = (ml * fl - sl * xl + Zl * Yl) * Tl, u[8] = (q * jl - dl * wl + bl * Ul) * Tl, u[9] = (v * wl - H * jl - B * Ul) * Tl, u[10] = (ol * Rl - Wl * xl + pl * Kl) * Tl, u[11] = (tl * xl - ml * Rl - Zl * Kl) * Tl, u[12] = (dl * Ql - q * Bl - il * Ul) * Tl, u[13] = (H * Bl - v * Ql + f * Ul) * Tl, u[14] = (Wl * Yl - ol * rl - el * Kl) * Tl, u[15] = (ml * rl - tl * Yl + sl * Kl) * Tl, u) : null;
      }
      function h(u, Y) {
        var H = Y[0], v = Y[1], f = Y[2], B = Y[3], q = Y[4], dl = Y[5], il = Y[6], bl = Y[7], ml = Y[8], tl = Y[9], sl = Y[10], Zl = Y[11], ol = Y[12], Wl = Y[13], el = Y[14], pl = Y[15];
        return u[0] = dl * (sl * pl - Zl * el) - tl * (il * pl - bl * el) + Wl * (il * Zl - bl * sl), u[1] = -(v * (sl * pl - Zl * el) - tl * (f * pl - B * el) + Wl * (f * Zl - B * sl)), u[2] = v * (il * pl - bl * el) - dl * (f * pl - B * el) + Wl * (f * bl - B * il), u[3] = -(v * (il * Zl - bl * sl) - dl * (f * Zl - B * sl) + tl * (f * bl - B * il)), u[4] = -(q * (sl * pl - Zl * el) - ml * (il * pl - bl * el) + ol * (il * Zl - bl * sl)), u[5] = H * (sl * pl - Zl * el) - ml * (f * pl - B * el) + ol * (f * Zl - B * sl), u[6] = -(H * (il * pl - bl * el) - q * (f * pl - B * el) + ol * (f * bl - B * il)), u[7] = H * (il * Zl - bl * sl) - q * (f * Zl - B * sl) + ml * (f * bl - B * il), u[8] = q * (tl * pl - Zl * Wl) - ml * (dl * pl - bl * Wl) + ol * (dl * Zl - bl * tl), u[9] = -(H * (tl * pl - Zl * Wl) - ml * (v * pl - B * Wl) + ol * (v * Zl - B * tl)), u[10] = H * (dl * pl - bl * Wl) - q * (v * pl - B * Wl) + ol * (v * bl - B * dl), u[11] = -(H * (dl * Zl - bl * tl) - q * (v * Zl - B * tl) + ml * (v * bl - B * dl)), u[12] = -(q * (tl * el - sl * Wl) - ml * (dl * el - il * Wl) + ol * (dl * sl - il * tl)), u[13] = H * (tl * el - sl * Wl) - ml * (v * el - f * Wl) + ol * (v * sl - f * tl), u[14] = -(H * (dl * el - il * Wl) - q * (v * el - f * Wl) + ol * (v * il - f * dl)), u[15] = H * (dl * sl - il * tl) - q * (v * sl - f * tl) + ml * (v * il - f * dl), u;
      }
      function p(u) {
        var Y = u[0], H = u[1], v = u[2], f = u[3], B = u[4], q = u[5], dl = u[6], il = u[7], bl = u[8], ml = u[9], tl = u[10], sl = u[11], Zl = u[12], ol = u[13], Wl = u[14], el = u[15], pl = Y * q - H * B, Kl = Y * dl - v * B, Yl = Y * il - f * B, xl = H * dl - v * q, rl = H * il - f * q, Rl = v * il - f * dl, fl = bl * ol - ml * Zl, Ul = bl * Wl - tl * Zl, Ql = bl * el - sl * Zl, wl = ml * Wl - tl * ol, Bl = ml * el - sl * ol, jl = tl * el - sl * Wl;
        return pl * jl - Kl * Bl + Yl * wl + xl * Ql - rl * Ul + Rl * fl;
      }
      function r(u, Y, H) {
        var v = Y[0], f = Y[1], B = Y[2], q = Y[3], dl = Y[4], il = Y[5], bl = Y[6], ml = Y[7], tl = Y[8], sl = Y[9], Zl = Y[10], ol = Y[11], Wl = Y[12], el = Y[13], pl = Y[14], Kl = Y[15], Yl = H[0], xl = H[1], rl = H[2], Rl = H[3];
        return u[0] = Yl * v + xl * dl + rl * tl + Rl * Wl, u[1] = Yl * f + xl * il + rl * sl + Rl * el, u[2] = Yl * B + xl * bl + rl * Zl + Rl * pl, u[3] = Yl * q + xl * ml + rl * ol + Rl * Kl, Yl = H[4], xl = H[5], rl = H[6], Rl = H[7], u[4] = Yl * v + xl * dl + rl * tl + Rl * Wl, u[5] = Yl * f + xl * il + rl * sl + Rl * el, u[6] = Yl * B + xl * bl + rl * Zl + Rl * pl, u[7] = Yl * q + xl * ml + rl * ol + Rl * Kl, Yl = H[8], xl = H[9], rl = H[10], Rl = H[11], u[8] = Yl * v + xl * dl + rl * tl + Rl * Wl, u[9] = Yl * f + xl * il + rl * sl + Rl * el, u[10] = Yl * B + xl * bl + rl * Zl + Rl * pl, u[11] = Yl * q + xl * ml + rl * ol + Rl * Kl, Yl = H[12], xl = H[13], rl = H[14], Rl = H[15], u[12] = Yl * v + xl * dl + rl * tl + Rl * Wl, u[13] = Yl * f + xl * il + rl * sl + Rl * el, u[14] = Yl * B + xl * bl + rl * Zl + Rl * pl, u[15] = Yl * q + xl * ml + rl * ol + Rl * Kl, u;
      }
      function V(u, Y, H) {
        var v = H[0], f = H[1], B = H[2], q, dl, il, bl, ml, tl, sl, Zl, ol, Wl, el, pl;
        return Y === u ? (u[12] = Y[0] * v + Y[4] * f + Y[8] * B + Y[12], u[13] = Y[1] * v + Y[5] * f + Y[9] * B + Y[13], u[14] = Y[2] * v + Y[6] * f + Y[10] * B + Y[14], u[15] = Y[3] * v + Y[7] * f + Y[11] * B + Y[15]) : (q = Y[0], dl = Y[1], il = Y[2], bl = Y[3], ml = Y[4], tl = Y[5], sl = Y[6], Zl = Y[7], ol = Y[8], Wl = Y[9], el = Y[10], pl = Y[11], u[0] = q, u[1] = dl, u[2] = il, u[3] = bl, u[4] = ml, u[5] = tl, u[6] = sl, u[7] = Zl, u[8] = ol, u[9] = Wl, u[10] = el, u[11] = pl, u[12] = q * v + ml * f + ol * B + Y[12], u[13] = dl * v + tl * f + Wl * B + Y[13], u[14] = il * v + sl * f + el * B + Y[14], u[15] = bl * v + Zl * f + pl * B + Y[15]), u;
      }
      function W(u, Y, H) {
        var v = H[0], f = H[1], B = H[2];
        return u[0] = Y[0] * v, u[1] = Y[1] * v, u[2] = Y[2] * v, u[3] = Y[3] * v, u[4] = Y[4] * f, u[5] = Y[5] * f, u[6] = Y[6] * f, u[7] = Y[7] * f, u[8] = Y[8] * B, u[9] = Y[9] * B, u[10] = Y[10] * B, u[11] = Y[11] * B, u[12] = Y[12], u[13] = Y[13], u[14] = Y[14], u[15] = Y[15], u;
      }
      function y(u, Y, H, v) {
        var f = v[0], B = v[1], q = v[2], dl = Math.hypot(f, B, q), il, bl, ml, tl, sl, Zl, ol, Wl, el, pl, Kl, Yl, xl, rl, Rl, fl, Ul, Ql, wl, Bl, jl, Dl, Tl, md;
        return dl < i.EPSILON ? null : (dl = 1 / dl, f *= dl, B *= dl, q *= dl, il = Math.sin(H), bl = Math.cos(H), ml = 1 - bl, tl = Y[0], sl = Y[1], Zl = Y[2], ol = Y[3], Wl = Y[4], el = Y[5], pl = Y[6], Kl = Y[7], Yl = Y[8], xl = Y[9], rl = Y[10], Rl = Y[11], fl = f * f * ml + bl, Ul = B * f * ml + q * il, Ql = q * f * ml - B * il, wl = f * B * ml - q * il, Bl = B * B * ml + bl, jl = q * B * ml + f * il, Dl = f * q * ml + B * il, Tl = B * q * ml - f * il, md = q * q * ml + bl, u[0] = tl * fl + Wl * Ul + Yl * Ql, u[1] = sl * fl + el * Ul + xl * Ql, u[2] = Zl * fl + pl * Ul + rl * Ql, u[3] = ol * fl + Kl * Ul + Rl * Ql, u[4] = tl * wl + Wl * Bl + Yl * jl, u[5] = sl * wl + el * Bl + xl * jl, u[6] = Zl * wl + pl * Bl + rl * jl, u[7] = ol * wl + Kl * Bl + Rl * jl, u[8] = tl * Dl + Wl * Tl + Yl * md, u[9] = sl * Dl + el * Tl + xl * md, u[10] = Zl * Dl + pl * Tl + rl * md, u[11] = ol * Dl + Kl * Tl + Rl * md, Y !== u && (u[12] = Y[12], u[13] = Y[13], u[14] = Y[14], u[15] = Y[15]), u);
      }
      function t(u, Y, H) {
        var v = Math.sin(H), f = Math.cos(H), B = Y[4], q = Y[5], dl = Y[6], il = Y[7], bl = Y[8], ml = Y[9], tl = Y[10], sl = Y[11];
        return Y !== u && (u[0] = Y[0], u[1] = Y[1], u[2] = Y[2], u[3] = Y[3], u[12] = Y[12], u[13] = Y[13], u[14] = Y[14], u[15] = Y[15]), u[4] = B * f + bl * v, u[5] = q * f + ml * v, u[6] = dl * f + tl * v, u[7] = il * f + sl * v, u[8] = bl * f - B * v, u[9] = ml * f - q * v, u[10] = tl * f - dl * v, u[11] = sl * f - il * v, u;
      }
      function e(u, Y, H) {
        var v = Math.sin(H), f = Math.cos(H), B = Y[0], q = Y[1], dl = Y[2], il = Y[3], bl = Y[8], ml = Y[9], tl = Y[10], sl = Y[11];
        return Y !== u && (u[4] = Y[4], u[5] = Y[5], u[6] = Y[6], u[7] = Y[7], u[12] = Y[12], u[13] = Y[13], u[14] = Y[14], u[15] = Y[15]), u[0] = B * f - bl * v, u[1] = q * f - ml * v, u[2] = dl * f - tl * v, u[3] = il * f - sl * v, u[8] = B * v + bl * f, u[9] = q * v + ml * f, u[10] = dl * v + tl * f, u[11] = il * v + sl * f, u;
      }
      function Z(u, Y, H) {
        var v = Math.sin(H), f = Math.cos(H), B = Y[0], q = Y[1], dl = Y[2], il = Y[3], bl = Y[4], ml = Y[5], tl = Y[6], sl = Y[7];
        return Y !== u && (u[8] = Y[8], u[9] = Y[9], u[10] = Y[10], u[11] = Y[11], u[12] = Y[12], u[13] = Y[13], u[14] = Y[14], u[15] = Y[15]), u[0] = B * f + bl * v, u[1] = q * f + ml * v, u[2] = dl * f + tl * v, u[3] = il * f + sl * v, u[4] = bl * f - B * v, u[5] = ml * f - q * v, u[6] = tl * f - dl * v, u[7] = sl * f - il * v, u;
      }
      function a(u, Y) {
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = Y[0], u[13] = Y[1], u[14] = Y[2], u[15] = 1, u;
      }
      function x(u, Y) {
        return u[0] = Y[0], u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = Y[1], u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = Y[2], u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function K(u, Y, H) {
        var v = H[0], f = H[1], B = H[2], q = Math.hypot(v, f, B), dl, il, bl;
        return q < i.EPSILON ? null : (q = 1 / q, v *= q, f *= q, B *= q, dl = Math.sin(Y), il = Math.cos(Y), bl = 1 - il, u[0] = v * v * bl + il, u[1] = f * v * bl + B * dl, u[2] = B * v * bl - f * dl, u[3] = 0, u[4] = v * f * bl - B * dl, u[5] = f * f * bl + il, u[6] = B * f * bl + v * dl, u[7] = 0, u[8] = v * B * bl + f * dl, u[9] = f * B * bl - v * dl, u[10] = B * B * bl + il, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u);
      }
      function C(u, Y) {
        var H = Math.sin(Y), v = Math.cos(Y);
        return u[0] = 1, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = v, u[6] = H, u[7] = 0, u[8] = 0, u[9] = -H, u[10] = v, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function T(u, Y) {
        var H = Math.sin(Y), v = Math.cos(Y);
        return u[0] = v, u[1] = 0, u[2] = -H, u[3] = 0, u[4] = 0, u[5] = 1, u[6] = 0, u[7] = 0, u[8] = H, u[9] = 0, u[10] = v, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function I(u, Y) {
        var H = Math.sin(Y), v = Math.cos(Y);
        return u[0] = v, u[1] = H, u[2] = 0, u[3] = 0, u[4] = -H, u[5] = v, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 1, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function J(u, Y, H) {
        var v = Y[0], f = Y[1], B = Y[2], q = Y[3], dl = v + v, il = f + f, bl = B + B, ml = v * dl, tl = v * il, sl = v * bl, Zl = f * il, ol = f * bl, Wl = B * bl, el = q * dl, pl = q * il, Kl = q * bl;
        return u[0] = 1 - (Zl + Wl), u[1] = tl + Kl, u[2] = sl - pl, u[3] = 0, u[4] = tl - Kl, u[5] = 1 - (ml + Wl), u[6] = ol + el, u[7] = 0, u[8] = sl + pl, u[9] = ol - el, u[10] = 1 - (ml + Zl), u[11] = 0, u[12] = H[0], u[13] = H[1], u[14] = H[2], u[15] = 1, u;
      }
      function F(u, Y) {
        var H = new i.ARRAY_TYPE(3), v = -Y[0], f = -Y[1], B = -Y[2], q = Y[3], dl = Y[4], il = Y[5], bl = Y[6], ml = Y[7], tl = v * v + f * f + B * B + q * q;
        return tl > 0 ? (H[0] = (dl * q + ml * v + il * B - bl * f) * 2 / tl, H[1] = (il * q + ml * f + bl * v - dl * B) * 2 / tl, H[2] = (bl * q + ml * B + dl * f - il * v) * 2 / tl) : (H[0] = (dl * q + ml * v + il * B - bl * f) * 2, H[1] = (il * q + ml * f + bl * v - dl * B) * 2, H[2] = (bl * q + ml * B + dl * f - il * v) * 2), J(u, Y, H), u;
      }
      function R(u, Y) {
        return u[0] = Y[12], u[1] = Y[13], u[2] = Y[14], u;
      }
      function S(u, Y) {
        var H = Y[0], v = Y[1], f = Y[2], B = Y[4], q = Y[5], dl = Y[6], il = Y[8], bl = Y[9], ml = Y[10];
        return u[0] = Math.hypot(H, v, f), u[1] = Math.hypot(B, q, dl), u[2] = Math.hypot(il, bl, ml), u;
      }
      function N(u, Y) {
        var H = new i.ARRAY_TYPE(3);
        S(H, Y);
        var v = 1 / H[0], f = 1 / H[1], B = 1 / H[2], q = Y[0] * v, dl = Y[1] * f, il = Y[2] * B, bl = Y[4] * v, ml = Y[5] * f, tl = Y[6] * B, sl = Y[8] * v, Zl = Y[9] * f, ol = Y[10] * B, Wl = q + ml + ol, el = 0;
        return Wl > 0 ? (el = Math.sqrt(Wl + 1) * 2, u[3] = 0.25 * el, u[0] = (tl - Zl) / el, u[1] = (sl - il) / el, u[2] = (dl - bl) / el) : q > ml && q > ol ? (el = Math.sqrt(1 + q - ml - ol) * 2, u[3] = (tl - Zl) / el, u[0] = 0.25 * el, u[1] = (dl + bl) / el, u[2] = (sl + il) / el) : ml > ol ? (el = Math.sqrt(1 + ml - q - ol) * 2, u[3] = (sl - il) / el, u[0] = (dl + bl) / el, u[1] = 0.25 * el, u[2] = (tl + Zl) / el) : (el = Math.sqrt(1 + ol - q - ml) * 2, u[3] = (dl - bl) / el, u[0] = (sl + il) / el, u[1] = (tl + Zl) / el, u[2] = 0.25 * el), u;
      }
      function Q(u, Y, H, v) {
        var f = Y[0], B = Y[1], q = Y[2], dl = Y[3], il = f + f, bl = B + B, ml = q + q, tl = f * il, sl = f * bl, Zl = f * ml, ol = B * bl, Wl = B * ml, el = q * ml, pl = dl * il, Kl = dl * bl, Yl = dl * ml, xl = v[0], rl = v[1], Rl = v[2];
        return u[0] = (1 - (ol + el)) * xl, u[1] = (sl + Yl) * xl, u[2] = (Zl - Kl) * xl, u[3] = 0, u[4] = (sl - Yl) * rl, u[5] = (1 - (tl + el)) * rl, u[6] = (Wl + pl) * rl, u[7] = 0, u[8] = (Zl + Kl) * Rl, u[9] = (Wl - pl) * Rl, u[10] = (1 - (tl + ol)) * Rl, u[11] = 0, u[12] = H[0], u[13] = H[1], u[14] = H[2], u[15] = 1, u;
      }
      function P(u, Y, H, v, f) {
        var B = Y[0], q = Y[1], dl = Y[2], il = Y[3], bl = B + B, ml = q + q, tl = dl + dl, sl = B * bl, Zl = B * ml, ol = B * tl, Wl = q * ml, el = q * tl, pl = dl * tl, Kl = il * bl, Yl = il * ml, xl = il * tl, rl = v[0], Rl = v[1], fl = v[2], Ul = f[0], Ql = f[1], wl = f[2], Bl = (1 - (Wl + pl)) * rl, jl = (Zl + xl) * rl, Dl = (ol - Yl) * rl, Tl = (Zl - xl) * Rl, md = (1 - (sl + pl)) * Rl, Ud = (el + Kl) * Rl, Qd = (ol + Yl) * fl, Ui = (el - Kl) * fl, Qi = (1 - (sl + Wl)) * fl;
        return u[0] = Bl, u[1] = jl, u[2] = Dl, u[3] = 0, u[4] = Tl, u[5] = md, u[6] = Ud, u[7] = 0, u[8] = Qd, u[9] = Ui, u[10] = Qi, u[11] = 0, u[12] = H[0] + Ul - (Bl * Ul + Tl * Ql + Qd * wl), u[13] = H[1] + Ql - (jl * Ul + md * Ql + Ui * wl), u[14] = H[2] + wl - (Dl * Ul + Ud * Ql + Qi * wl), u[15] = 1, u;
      }
      function j(u, Y) {
        var H = Y[0], v = Y[1], f = Y[2], B = Y[3], q = H + H, dl = v + v, il = f + f, bl = H * q, ml = v * q, tl = v * dl, sl = f * q, Zl = f * dl, ol = f * il, Wl = B * q, el = B * dl, pl = B * il;
        return u[0] = 1 - tl - ol, u[1] = ml + pl, u[2] = sl - el, u[3] = 0, u[4] = ml - pl, u[5] = 1 - bl - ol, u[6] = Zl + Wl, u[7] = 0, u[8] = sl + el, u[9] = Zl - Wl, u[10] = 1 - bl - tl, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, u;
      }
      function D(u, Y, H, v, f, B, q) {
        var dl = 1 / (H - Y), il = 1 / (f - v), bl = 1 / (B - q);
        return u[0] = B * 2 * dl, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = B * 2 * il, u[6] = 0, u[7] = 0, u[8] = (H + Y) * dl, u[9] = (f + v) * il, u[10] = (q + B) * bl, u[11] = -1, u[12] = 0, u[13] = 0, u[14] = q * B * 2 * bl, u[15] = 0, u;
      }
      function z(u, Y, H, v, f) {
        var B = 1 / Math.tan(Y / 2), q;
        return u[0] = B / H, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = B, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[11] = -1, u[12] = 0, u[13] = 0, u[15] = 0, f != null && f !== 1 / 0 ? (q = 1 / (v - f), u[10] = (f + v) * q, u[14] = 2 * f * v * q) : (u[10] = -1, u[14] = -2 * v), u;
      }
      function w(u, Y, H, v) {
        var f = Math.tan(Y.upDegrees * Math.PI / 180), B = Math.tan(Y.downDegrees * Math.PI / 180), q = Math.tan(Y.leftDegrees * Math.PI / 180), dl = Math.tan(Y.rightDegrees * Math.PI / 180), il = 2 / (q + dl), bl = 2 / (f + B);
        return u[0] = il, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = bl, u[6] = 0, u[7] = 0, u[8] = -((q - dl) * il * 0.5), u[9] = (f - B) * bl * 0.5, u[10] = v / (H - v), u[11] = -1, u[12] = 0, u[13] = 0, u[14] = v * H / (H - v), u[15] = 0, u;
      }
      function A(u, Y, H, v, f, B, q) {
        var dl = 1 / (Y - H), il = 1 / (v - f), bl = 1 / (B - q);
        return u[0] = -2 * dl, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = -2 * il, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = 2 * bl, u[11] = 0, u[12] = (Y + H) * dl, u[13] = (f + v) * il, u[14] = (q + B) * bl, u[15] = 1, u;
      }
      function ll(u, Y, H, v) {
        var f, B, q, dl, il, bl, ml, tl, sl, Zl, ol = Y[0], Wl = Y[1], el = Y[2], pl = v[0], Kl = v[1], Yl = v[2], xl = H[0], rl = H[1], Rl = H[2];
        return Math.abs(ol - xl) < i.EPSILON && Math.abs(Wl - rl) < i.EPSILON && Math.abs(el - Rl) < i.EPSILON ? G(u) : (ml = ol - xl, tl = Wl - rl, sl = el - Rl, Zl = 1 / Math.hypot(ml, tl, sl), ml *= Zl, tl *= Zl, sl *= Zl, f = Kl * sl - Yl * tl, B = Yl * ml - pl * sl, q = pl * tl - Kl * ml, Zl = Math.hypot(f, B, q), Zl ? (Zl = 1 / Zl, f *= Zl, B *= Zl, q *= Zl) : (f = 0, B = 0, q = 0), dl = tl * q - sl * B, il = sl * f - ml * q, bl = ml * B - tl * f, Zl = Math.hypot(dl, il, bl), Zl ? (Zl = 1 / Zl, dl *= Zl, il *= Zl, bl *= Zl) : (dl = 0, il = 0, bl = 0), u[0] = f, u[1] = dl, u[2] = ml, u[3] = 0, u[4] = B, u[5] = il, u[6] = tl, u[7] = 0, u[8] = q, u[9] = bl, u[10] = sl, u[11] = 0, u[12] = -(f * ol + B * Wl + q * el), u[13] = -(dl * ol + il * Wl + bl * el), u[14] = -(ml * ol + tl * Wl + sl * el), u[15] = 1, u);
      }
      function _(u, Y, H, v) {
        var f = Y[0], B = Y[1], q = Y[2], dl = v[0], il = v[1], bl = v[2], ml = f - H[0], tl = B - H[1], sl = q - H[2], Zl = ml * ml + tl * tl + sl * sl;
        Zl > 0 && (Zl = 1 / Math.sqrt(Zl), ml *= Zl, tl *= Zl, sl *= Zl);
        var ol = il * sl - bl * tl, Wl = bl * ml - dl * sl, el = dl * tl - il * ml;
        return Zl = ol * ol + Wl * Wl + el * el, Zl > 0 && (Zl = 1 / Math.sqrt(Zl), ol *= Zl, Wl *= Zl, el *= Zl), u[0] = ol, u[1] = Wl, u[2] = el, u[3] = 0, u[4] = tl * el - sl * Wl, u[5] = sl * ol - ml * el, u[6] = ml * Wl - tl * ol, u[7] = 0, u[8] = ml, u[9] = tl, u[10] = sl, u[11] = 0, u[12] = f, u[13] = B, u[14] = q, u[15] = 1, u;
      }
      function cl(u) {
        return "mat4(" + u[0] + ", " + u[1] + ", " + u[2] + ", " + u[3] + ", " + u[4] + ", " + u[5] + ", " + u[6] + ", " + u[7] + ", " + u[8] + ", " + u[9] + ", " + u[10] + ", " + u[11] + ", " + u[12] + ", " + u[13] + ", " + u[14] + ", " + u[15] + ")";
      }
      function $(u) {
        return Math.hypot(u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], u[8], u[9], u[10], u[11], u[12], u[13], u[14], u[15]);
      }
      function al(u, Y, H) {
        return u[0] = Y[0] + H[0], u[1] = Y[1] + H[1], u[2] = Y[2] + H[2], u[3] = Y[3] + H[3], u[4] = Y[4] + H[4], u[5] = Y[5] + H[5], u[6] = Y[6] + H[6], u[7] = Y[7] + H[7], u[8] = Y[8] + H[8], u[9] = Y[9] + H[9], u[10] = Y[10] + H[10], u[11] = Y[11] + H[11], u[12] = Y[12] + H[12], u[13] = Y[13] + H[13], u[14] = Y[14] + H[14], u[15] = Y[15] + H[15], u;
      }
      function Xl(u, Y, H) {
        return u[0] = Y[0] - H[0], u[1] = Y[1] - H[1], u[2] = Y[2] - H[2], u[3] = Y[3] - H[3], u[4] = Y[4] - H[4], u[5] = Y[5] - H[5], u[6] = Y[6] - H[6], u[7] = Y[7] - H[7], u[8] = Y[8] - H[8], u[9] = Y[9] - H[9], u[10] = Y[10] - H[10], u[11] = Y[11] - H[11], u[12] = Y[12] - H[12], u[13] = Y[13] - H[13], u[14] = Y[14] - H[14], u[15] = Y[15] - H[15], u;
      }
      function M(u, Y, H) {
        return u[0] = Y[0] * H, u[1] = Y[1] * H, u[2] = Y[2] * H, u[3] = Y[3] * H, u[4] = Y[4] * H, u[5] = Y[5] * H, u[6] = Y[6] * H, u[7] = Y[7] * H, u[8] = Y[8] * H, u[9] = Y[9] * H, u[10] = Y[10] * H, u[11] = Y[11] * H, u[12] = Y[12] * H, u[13] = Y[13] * H, u[14] = Y[14] * H, u[15] = Y[15] * H, u;
      }
      function k(u, Y, H, v) {
        return u[0] = Y[0] + H[0] * v, u[1] = Y[1] + H[1] * v, u[2] = Y[2] + H[2] * v, u[3] = Y[3] + H[3] * v, u[4] = Y[4] + H[4] * v, u[5] = Y[5] + H[5] * v, u[6] = Y[6] + H[6] * v, u[7] = Y[7] + H[7] * v, u[8] = Y[8] + H[8] * v, u[9] = Y[9] + H[9] * v, u[10] = Y[10] + H[10] * v, u[11] = Y[11] + H[11] * v, u[12] = Y[12] + H[12] * v, u[13] = Y[13] + H[13] * v, u[14] = Y[14] + H[14] * v, u[15] = Y[15] + H[15] * v, u;
      }
      function E(u, Y) {
        return u[0] === Y[0] && u[1] === Y[1] && u[2] === Y[2] && u[3] === Y[3] && u[4] === Y[4] && u[5] === Y[5] && u[6] === Y[6] && u[7] === Y[7] && u[8] === Y[8] && u[9] === Y[9] && u[10] === Y[10] && u[11] === Y[11] && u[12] === Y[12] && u[13] === Y[13] && u[14] === Y[14] && u[15] === Y[15];
      }
      function O(u, Y) {
        var H = u[0], v = u[1], f = u[2], B = u[3], q = u[4], dl = u[5], il = u[6], bl = u[7], ml = u[8], tl = u[9], sl = u[10], Zl = u[11], ol = u[12], Wl = u[13], el = u[14], pl = u[15], Kl = Y[0], Yl = Y[1], xl = Y[2], rl = Y[3], Rl = Y[4], fl = Y[5], Ul = Y[6], Ql = Y[7], wl = Y[8], Bl = Y[9], jl = Y[10], Dl = Y[11], Tl = Y[12], md = Y[13], Ud = Y[14], Qd = Y[15];
        return Math.abs(H - Kl) <= i.EPSILON * Math.max(1, Math.abs(H), Math.abs(Kl)) && Math.abs(v - Yl) <= i.EPSILON * Math.max(1, Math.abs(v), Math.abs(Yl)) && Math.abs(f - xl) <= i.EPSILON * Math.max(1, Math.abs(f), Math.abs(xl)) && Math.abs(B - rl) <= i.EPSILON * Math.max(1, Math.abs(B), Math.abs(rl)) && Math.abs(q - Rl) <= i.EPSILON * Math.max(1, Math.abs(q), Math.abs(Rl)) && Math.abs(dl - fl) <= i.EPSILON * Math.max(1, Math.abs(dl), Math.abs(fl)) && Math.abs(il - Ul) <= i.EPSILON * Math.max(1, Math.abs(il), Math.abs(Ul)) && Math.abs(bl - Ql) <= i.EPSILON * Math.max(1, Math.abs(bl), Math.abs(Ql)) && Math.abs(ml - wl) <= i.EPSILON * Math.max(1, Math.abs(ml), Math.abs(wl)) && Math.abs(tl - Bl) <= i.EPSILON * Math.max(1, Math.abs(tl), Math.abs(Bl)) && Math.abs(sl - jl) <= i.EPSILON * Math.max(1, Math.abs(sl), Math.abs(jl)) && Math.abs(Zl - Dl) <= i.EPSILON * Math.max(1, Math.abs(Zl), Math.abs(Dl)) && Math.abs(ol - Tl) <= i.EPSILON * Math.max(1, Math.abs(ol), Math.abs(Tl)) && Math.abs(Wl - md) <= i.EPSILON * Math.max(1, Math.abs(Wl), Math.abs(md)) && Math.abs(el - Ud) <= i.EPSILON * Math.max(1, Math.abs(el), Math.abs(Ud)) && Math.abs(pl - Qd) <= i.EPSILON * Math.max(1, Math.abs(pl), Math.abs(Qd));
      }
      var g = r, U = Xl;
    },
    /* 7 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return n;
      }), l.d(d, "identity", function() {
        return X;
      }), l.d(d, "setAxisAngle", function() {
        return G;
      }), l.d(d, "getAxisAngle", function() {
        return L;
      }), l.d(d, "getAngle", function() {
        return o;
      }), l.d(d, "multiply", function() {
        return h;
      }), l.d(d, "rotateX", function() {
        return p;
      }), l.d(d, "rotateY", function() {
        return r;
      }), l.d(d, "rotateZ", function() {
        return V;
      }), l.d(d, "calculateW", function() {
        return W;
      }), l.d(d, "exp", function() {
        return y;
      }), l.d(d, "ln", function() {
        return t;
      }), l.d(d, "pow", function() {
        return e;
      }), l.d(d, "slerp", function() {
        return Z;
      }), l.d(d, "random", function() {
        return a;
      }), l.d(d, "invert", function() {
        return x;
      }), l.d(d, "conjugate", function() {
        return K;
      }), l.d(d, "fromMat3", function() {
        return C;
      }), l.d(d, "fromEuler", function() {
        return T;
      }), l.d(d, "str", function() {
        return I;
      }), l.d(d, "clone", function() {
        return J;
      }), l.d(d, "fromValues", function() {
        return F;
      }), l.d(d, "copy", function() {
        return R;
      }), l.d(d, "set", function() {
        return S;
      }), l.d(d, "add", function() {
        return N;
      }), l.d(d, "mul", function() {
        return Q;
      }), l.d(d, "scale", function() {
        return P;
      }), l.d(d, "dot", function() {
        return j;
      }), l.d(d, "lerp", function() {
        return D;
      }), l.d(d, "length", function() {
        return z;
      }), l.d(d, "len", function() {
        return w;
      }), l.d(d, "squaredLength", function() {
        return A;
      }), l.d(d, "sqrLen", function() {
        return ll;
      }), l.d(d, "normalize", function() {
        return _;
      }), l.d(d, "exactEquals", function() {
        return cl;
      }), l.d(d, "equals", function() {
        return $;
      }), l.d(d, "rotationTo", function() {
        return al;
      }), l.d(d, "sqlerp", function() {
        return Xl;
      }), l.d(d, "setAxes", function() {
        return M;
      });
      var i = l(2), s = l(5), c = l(8), m = l(9);
      function n() {
        var k = new i.ARRAY_TYPE(4);
        return i.ARRAY_TYPE != Float32Array && (k[0] = 0, k[1] = 0, k[2] = 0), k[3] = 1, k;
      }
      function X(k) {
        return k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 1, k;
      }
      function G(k, E, O) {
        O = O * 0.5;
        var g = Math.sin(O);
        return k[0] = g * E[0], k[1] = g * E[1], k[2] = g * E[2], k[3] = Math.cos(O), k;
      }
      function L(k, E) {
        var O = Math.acos(E[3]) * 2, g = Math.sin(O / 2);
        return g > i.EPSILON ? (k[0] = E[0] / g, k[1] = E[1] / g, k[2] = E[2] / g) : (k[0] = 1, k[1] = 0, k[2] = 0), O;
      }
      function o(k, E) {
        var O = j(k, E);
        return Math.acos(2 * O * O - 1);
      }
      function h(k, E, O) {
        var g = E[0], U = E[1], u = E[2], Y = E[3], H = O[0], v = O[1], f = O[2], B = O[3];
        return k[0] = g * B + Y * H + U * f - u * v, k[1] = U * B + Y * v + u * H - g * f, k[2] = u * B + Y * f + g * v - U * H, k[3] = Y * B - g * H - U * v - u * f, k;
      }
      function p(k, E, O) {
        O *= 0.5;
        var g = E[0], U = E[1], u = E[2], Y = E[3], H = Math.sin(O), v = Math.cos(O);
        return k[0] = g * v + Y * H, k[1] = U * v + u * H, k[2] = u * v - U * H, k[3] = Y * v - g * H, k;
      }
      function r(k, E, O) {
        O *= 0.5;
        var g = E[0], U = E[1], u = E[2], Y = E[3], H = Math.sin(O), v = Math.cos(O);
        return k[0] = g * v - u * H, k[1] = U * v + Y * H, k[2] = u * v + g * H, k[3] = Y * v - U * H, k;
      }
      function V(k, E, O) {
        O *= 0.5;
        var g = E[0], U = E[1], u = E[2], Y = E[3], H = Math.sin(O), v = Math.cos(O);
        return k[0] = g * v + U * H, k[1] = U * v - g * H, k[2] = u * v + Y * H, k[3] = Y * v - u * H, k;
      }
      function W(k, E) {
        var O = E[0], g = E[1], U = E[2];
        return k[0] = O, k[1] = g, k[2] = U, k[3] = Math.sqrt(Math.abs(1 - O * O - g * g - U * U)), k;
      }
      function y(k, E) {
        var O = E[0], g = E[1], U = E[2], u = E[3], Y = Math.sqrt(O * O + g * g + U * U), H = Math.exp(u), v = Y > 0 ? H * Math.sin(Y) / Y : 0;
        return k[0] = O * v, k[1] = g * v, k[2] = U * v, k[3] = H * Math.cos(Y), k;
      }
      function t(k, E) {
        var O = E[0], g = E[1], U = E[2], u = E[3], Y = Math.sqrt(O * O + g * g + U * U), H = Y > 0 ? Math.atan2(Y, u) / Y : 0;
        return k[0] = O * H, k[1] = g * H, k[2] = U * H, k[3] = 0.5 * Math.log(O * O + g * g + U * U + u * u), k;
      }
      function e(k, E, O) {
        return t(k, E), P(k, k, O), y(k, k), k;
      }
      function Z(k, E, O, g) {
        var U = E[0], u = E[1], Y = E[2], H = E[3], v = O[0], f = O[1], B = O[2], q = O[3], dl, il, bl, ml, tl;
        return il = U * v + u * f + Y * B + H * q, il < 0 && (il = -il, v = -v, f = -f, B = -B, q = -q), 1 - il > i.EPSILON ? (dl = Math.acos(il), bl = Math.sin(dl), ml = Math.sin((1 - g) * dl) / bl, tl = Math.sin(g * dl) / bl) : (ml = 1 - g, tl = g), k[0] = ml * U + tl * v, k[1] = ml * u + tl * f, k[2] = ml * Y + tl * B, k[3] = ml * H + tl * q, k;
      }
      function a(k) {
        var E = i.RANDOM(), O = i.RANDOM(), g = i.RANDOM(), U = Math.sqrt(1 - E), u = Math.sqrt(E);
        return k[0] = U * Math.sin(2 * Math.PI * O), k[1] = U * Math.cos(2 * Math.PI * O), k[2] = u * Math.sin(2 * Math.PI * g), k[3] = u * Math.cos(2 * Math.PI * g), k;
      }
      function x(k, E) {
        var O = E[0], g = E[1], U = E[2], u = E[3], Y = O * O + g * g + U * U + u * u, H = Y ? 1 / Y : 0;
        return k[0] = -O * H, k[1] = -g * H, k[2] = -U * H, k[3] = u * H, k;
      }
      function K(k, E) {
        return k[0] = -E[0], k[1] = -E[1], k[2] = -E[2], k[3] = E[3], k;
      }
      function C(k, E) {
        var O = E[0] + E[4] + E[8], g;
        if (O > 0)
          g = Math.sqrt(O + 1), k[3] = 0.5 * g, g = 0.5 / g, k[0] = (E[5] - E[7]) * g, k[1] = (E[6] - E[2]) * g, k[2] = (E[1] - E[3]) * g;
        else {
          var U = 0;
          E[4] > E[0] && (U = 1), E[8] > E[U * 3 + U] && (U = 2);
          var u = (U + 1) % 3, Y = (U + 2) % 3;
          g = Math.sqrt(E[U * 3 + U] - E[u * 3 + u] - E[Y * 3 + Y] + 1), k[U] = 0.5 * g, g = 0.5 / g, k[3] = (E[u * 3 + Y] - E[Y * 3 + u]) * g, k[u] = (E[u * 3 + U] + E[U * 3 + u]) * g, k[Y] = (E[Y * 3 + U] + E[U * 3 + Y]) * g;
        }
        return k;
      }
      function T(k, E, O, g) {
        var U = 0.5 * Math.PI / 180;
        E *= U, O *= U, g *= U;
        var u = Math.sin(E), Y = Math.cos(E), H = Math.sin(O), v = Math.cos(O), f = Math.sin(g), B = Math.cos(g);
        return k[0] = u * v * B - Y * H * f, k[1] = Y * H * B + u * v * f, k[2] = Y * v * f - u * H * B, k[3] = Y * v * B + u * H * f, k;
      }
      function I(k) {
        return "quat(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ")";
      }
      var J = m.clone, F = m.fromValues, R = m.copy, S = m.set, N = m.add, Q = h, P = m.scale, j = m.dot, D = m.lerp, z = m.length, w = z, A = m.squaredLength, ll = A, _ = m.normalize, cl = m.exactEquals, $ = m.equals, al = function() {
        var k = c.create(), E = c.fromValues(1, 0, 0), O = c.fromValues(0, 1, 0);
        return function(g, U, u) {
          var Y = c.dot(U, u);
          return Y < -0.999999 ? (c.cross(k, E, U), c.len(k) < 1e-6 && c.cross(k, O, U), c.normalize(k, k), G(g, k, Math.PI), g) : Y > 0.999999 ? (g[0] = 0, g[1] = 0, g[2] = 0, g[3] = 1, g) : (c.cross(k, U, u), g[0] = k[0], g[1] = k[1], g[2] = k[2], g[3] = 1 + Y, _(g, g));
        };
      }(), Xl = function() {
        var k = n(), E = n();
        return function(O, g, U, u, Y, H) {
          return Z(k, g, Y, H), Z(E, U, u, H), Z(O, k, E, 2 * H * (1 - H)), O;
        };
      }(), M = function() {
        var k = s.create();
        return function(E, O, g, U) {
          return k[0] = g[0], k[3] = g[1], k[6] = g[2], k[1] = U[0], k[4] = U[1], k[7] = U[2], k[2] = -O[0], k[5] = -O[1], k[8] = -O[2], _(E, C(E, k));
        };
      }();
    },
    /* 8 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return s;
      }), l.d(d, "clone", function() {
        return c;
      }), l.d(d, "length", function() {
        return m;
      }), l.d(d, "fromValues", function() {
        return n;
      }), l.d(d, "copy", function() {
        return X;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "add", function() {
        return L;
      }), l.d(d, "subtract", function() {
        return o;
      }), l.d(d, "multiply", function() {
        return h;
      }), l.d(d, "divide", function() {
        return p;
      }), l.d(d, "ceil", function() {
        return r;
      }), l.d(d, "floor", function() {
        return V;
      }), l.d(d, "min", function() {
        return W;
      }), l.d(d, "max", function() {
        return y;
      }), l.d(d, "round", function() {
        return t;
      }), l.d(d, "scale", function() {
        return e;
      }), l.d(d, "scaleAndAdd", function() {
        return Z;
      }), l.d(d, "distance", function() {
        return a;
      }), l.d(d, "squaredDistance", function() {
        return x;
      }), l.d(d, "squaredLength", function() {
        return K;
      }), l.d(d, "negate", function() {
        return C;
      }), l.d(d, "inverse", function() {
        return T;
      }), l.d(d, "normalize", function() {
        return I;
      }), l.d(d, "dot", function() {
        return J;
      }), l.d(d, "cross", function() {
        return F;
      }), l.d(d, "lerp", function() {
        return R;
      }), l.d(d, "hermite", function() {
        return S;
      }), l.d(d, "bezier", function() {
        return N;
      }), l.d(d, "random", function() {
        return Q;
      }), l.d(d, "transformMat4", function() {
        return P;
      }), l.d(d, "transformMat3", function() {
        return j;
      }), l.d(d, "transformQuat", function() {
        return D;
      }), l.d(d, "rotateX", function() {
        return z;
      }), l.d(d, "rotateY", function() {
        return w;
      }), l.d(d, "rotateZ", function() {
        return A;
      }), l.d(d, "angle", function() {
        return ll;
      }), l.d(d, "zero", function() {
        return _;
      }), l.d(d, "str", function() {
        return cl;
      }), l.d(d, "exactEquals", function() {
        return $;
      }), l.d(d, "equals", function() {
        return al;
      }), l.d(d, "sub", function() {
        return Xl;
      }), l.d(d, "mul", function() {
        return M;
      }), l.d(d, "div", function() {
        return k;
      }), l.d(d, "dist", function() {
        return E;
      }), l.d(d, "sqrDist", function() {
        return O;
      }), l.d(d, "len", function() {
        return g;
      }), l.d(d, "sqrLen", function() {
        return U;
      }), l.d(d, "forEach", function() {
        return u;
      });
      var i = l(2);
      function s() {
        var Y = new i.ARRAY_TYPE(3);
        return i.ARRAY_TYPE != Float32Array && (Y[0] = 0, Y[1] = 0, Y[2] = 0), Y;
      }
      function c(Y) {
        var H = new i.ARRAY_TYPE(3);
        return H[0] = Y[0], H[1] = Y[1], H[2] = Y[2], H;
      }
      function m(Y) {
        var H = Y[0], v = Y[1], f = Y[2];
        return Math.hypot(H, v, f);
      }
      function n(Y, H, v) {
        var f = new i.ARRAY_TYPE(3);
        return f[0] = Y, f[1] = H, f[2] = v, f;
      }
      function X(Y, H) {
        return Y[0] = H[0], Y[1] = H[1], Y[2] = H[2], Y;
      }
      function G(Y, H, v, f) {
        return Y[0] = H, Y[1] = v, Y[2] = f, Y;
      }
      function L(Y, H, v) {
        return Y[0] = H[0] + v[0], Y[1] = H[1] + v[1], Y[2] = H[2] + v[2], Y;
      }
      function o(Y, H, v) {
        return Y[0] = H[0] - v[0], Y[1] = H[1] - v[1], Y[2] = H[2] - v[2], Y;
      }
      function h(Y, H, v) {
        return Y[0] = H[0] * v[0], Y[1] = H[1] * v[1], Y[2] = H[2] * v[2], Y;
      }
      function p(Y, H, v) {
        return Y[0] = H[0] / v[0], Y[1] = H[1] / v[1], Y[2] = H[2] / v[2], Y;
      }
      function r(Y, H) {
        return Y[0] = Math.ceil(H[0]), Y[1] = Math.ceil(H[1]), Y[2] = Math.ceil(H[2]), Y;
      }
      function V(Y, H) {
        return Y[0] = Math.floor(H[0]), Y[1] = Math.floor(H[1]), Y[2] = Math.floor(H[2]), Y;
      }
      function W(Y, H, v) {
        return Y[0] = Math.min(H[0], v[0]), Y[1] = Math.min(H[1], v[1]), Y[2] = Math.min(H[2], v[2]), Y;
      }
      function y(Y, H, v) {
        return Y[0] = Math.max(H[0], v[0]), Y[1] = Math.max(H[1], v[1]), Y[2] = Math.max(H[2], v[2]), Y;
      }
      function t(Y, H) {
        return Y[0] = Math.round(H[0]), Y[1] = Math.round(H[1]), Y[2] = Math.round(H[2]), Y;
      }
      function e(Y, H, v) {
        return Y[0] = H[0] * v, Y[1] = H[1] * v, Y[2] = H[2] * v, Y;
      }
      function Z(Y, H, v, f) {
        return Y[0] = H[0] + v[0] * f, Y[1] = H[1] + v[1] * f, Y[2] = H[2] + v[2] * f, Y;
      }
      function a(Y, H) {
        var v = H[0] - Y[0], f = H[1] - Y[1], B = H[2] - Y[2];
        return Math.hypot(v, f, B);
      }
      function x(Y, H) {
        var v = H[0] - Y[0], f = H[1] - Y[1], B = H[2] - Y[2];
        return v * v + f * f + B * B;
      }
      function K(Y) {
        var H = Y[0], v = Y[1], f = Y[2];
        return H * H + v * v + f * f;
      }
      function C(Y, H) {
        return Y[0] = -H[0], Y[1] = -H[1], Y[2] = -H[2], Y;
      }
      function T(Y, H) {
        return Y[0] = 1 / H[0], Y[1] = 1 / H[1], Y[2] = 1 / H[2], Y;
      }
      function I(Y, H) {
        var v = H[0], f = H[1], B = H[2], q = v * v + f * f + B * B;
        return q > 0 && (q = 1 / Math.sqrt(q)), Y[0] = H[0] * q, Y[1] = H[1] * q, Y[2] = H[2] * q, Y;
      }
      function J(Y, H) {
        return Y[0] * H[0] + Y[1] * H[1] + Y[2] * H[2];
      }
      function F(Y, H, v) {
        var f = H[0], B = H[1], q = H[2], dl = v[0], il = v[1], bl = v[2];
        return Y[0] = B * bl - q * il, Y[1] = q * dl - f * bl, Y[2] = f * il - B * dl, Y;
      }
      function R(Y, H, v, f) {
        var B = H[0], q = H[1], dl = H[2];
        return Y[0] = B + f * (v[0] - B), Y[1] = q + f * (v[1] - q), Y[2] = dl + f * (v[2] - dl), Y;
      }
      function S(Y, H, v, f, B, q) {
        var dl = q * q, il = dl * (2 * q - 3) + 1, bl = dl * (q - 2) + q, ml = dl * (q - 1), tl = dl * (3 - 2 * q);
        return Y[0] = H[0] * il + v[0] * bl + f[0] * ml + B[0] * tl, Y[1] = H[1] * il + v[1] * bl + f[1] * ml + B[1] * tl, Y[2] = H[2] * il + v[2] * bl + f[2] * ml + B[2] * tl, Y;
      }
      function N(Y, H, v, f, B, q) {
        var dl = 1 - q, il = dl * dl, bl = q * q, ml = il * dl, tl = 3 * q * il, sl = 3 * bl * dl, Zl = bl * q;
        return Y[0] = H[0] * ml + v[0] * tl + f[0] * sl + B[0] * Zl, Y[1] = H[1] * ml + v[1] * tl + f[1] * sl + B[1] * Zl, Y[2] = H[2] * ml + v[2] * tl + f[2] * sl + B[2] * Zl, Y;
      }
      function Q(Y, H) {
        H = H || 1;
        var v = i.RANDOM() * 2 * Math.PI, f = i.RANDOM() * 2 - 1, B = Math.sqrt(1 - f * f) * H;
        return Y[0] = Math.cos(v) * B, Y[1] = Math.sin(v) * B, Y[2] = f * H, Y;
      }
      function P(Y, H, v) {
        var f = H[0], B = H[1], q = H[2], dl = v[3] * f + v[7] * B + v[11] * q + v[15];
        return dl = dl || 1, Y[0] = (v[0] * f + v[4] * B + v[8] * q + v[12]) / dl, Y[1] = (v[1] * f + v[5] * B + v[9] * q + v[13]) / dl, Y[2] = (v[2] * f + v[6] * B + v[10] * q + v[14]) / dl, Y;
      }
      function j(Y, H, v) {
        var f = H[0], B = H[1], q = H[2];
        return Y[0] = f * v[0] + B * v[3] + q * v[6], Y[1] = f * v[1] + B * v[4] + q * v[7], Y[2] = f * v[2] + B * v[5] + q * v[8], Y;
      }
      function D(Y, H, v) {
        var f = v[0], B = v[1], q = v[2], dl = v[3], il = H[0], bl = H[1], ml = H[2], tl = B * ml - q * bl, sl = q * il - f * ml, Zl = f * bl - B * il, ol = B * Zl - q * sl, Wl = q * tl - f * Zl, el = f * sl - B * tl, pl = dl * 2;
        return tl *= pl, sl *= pl, Zl *= pl, ol *= 2, Wl *= 2, el *= 2, Y[0] = il + tl + ol, Y[1] = bl + sl + Wl, Y[2] = ml + Zl + el, Y;
      }
      function z(Y, H, v, f) {
        var B = [], q = [];
        return B[0] = H[0] - v[0], B[1] = H[1] - v[1], B[2] = H[2] - v[2], q[0] = B[0], q[1] = B[1] * Math.cos(f) - B[2] * Math.sin(f), q[2] = B[1] * Math.sin(f) + B[2] * Math.cos(f), Y[0] = q[0] + v[0], Y[1] = q[1] + v[1], Y[2] = q[2] + v[2], Y;
      }
      function w(Y, H, v, f) {
        var B = [], q = [];
        return B[0] = H[0] - v[0], B[1] = H[1] - v[1], B[2] = H[2] - v[2], q[0] = B[2] * Math.sin(f) + B[0] * Math.cos(f), q[1] = B[1], q[2] = B[2] * Math.cos(f) - B[0] * Math.sin(f), Y[0] = q[0] + v[0], Y[1] = q[1] + v[1], Y[2] = q[2] + v[2], Y;
      }
      function A(Y, H, v, f) {
        var B = [], q = [];
        return B[0] = H[0] - v[0], B[1] = H[1] - v[1], B[2] = H[2] - v[2], q[0] = B[0] * Math.cos(f) - B[1] * Math.sin(f), q[1] = B[0] * Math.sin(f) + B[1] * Math.cos(f), q[2] = B[2], Y[0] = q[0] + v[0], Y[1] = q[1] + v[1], Y[2] = q[2] + v[2], Y;
      }
      function ll(Y, H) {
        var v = Y[0], f = Y[1], B = Y[2], q = H[0], dl = H[1], il = H[2], bl = Math.sqrt(v * v + f * f + B * B), ml = Math.sqrt(q * q + dl * dl + il * il), tl = bl * ml, sl = tl && J(Y, H) / tl;
        return Math.acos(Math.min(Math.max(sl, -1), 1));
      }
      function _(Y) {
        return Y[0] = 0, Y[1] = 0, Y[2] = 0, Y;
      }
      function cl(Y) {
        return "vec3(" + Y[0] + ", " + Y[1] + ", " + Y[2] + ")";
      }
      function $(Y, H) {
        return Y[0] === H[0] && Y[1] === H[1] && Y[2] === H[2];
      }
      function al(Y, H) {
        var v = Y[0], f = Y[1], B = Y[2], q = H[0], dl = H[1], il = H[2];
        return Math.abs(v - q) <= i.EPSILON * Math.max(1, Math.abs(v), Math.abs(q)) && Math.abs(f - dl) <= i.EPSILON * Math.max(1, Math.abs(f), Math.abs(dl)) && Math.abs(B - il) <= i.EPSILON * Math.max(1, Math.abs(B), Math.abs(il));
      }
      var Xl = o, M = h, k = p, E = a, O = x, g = m, U = K, u = function() {
        var Y = s();
        return function(H, v, f, B, q, dl) {
          var il, bl;
          for (v || (v = 3), f || (f = 0), B ? bl = Math.min(B * v + f, H.length) : bl = H.length, il = f; il < bl; il += v)
            Y[0] = H[il], Y[1] = H[il + 1], Y[2] = H[il + 2], q(Y, Y, dl), H[il] = Y[0], H[il + 1] = Y[1], H[il + 2] = Y[2];
          return H;
        };
      }();
    },
    /* 9 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return s;
      }), l.d(d, "clone", function() {
        return c;
      }), l.d(d, "fromValues", function() {
        return m;
      }), l.d(d, "copy", function() {
        return n;
      }), l.d(d, "set", function() {
        return X;
      }), l.d(d, "add", function() {
        return G;
      }), l.d(d, "subtract", function() {
        return L;
      }), l.d(d, "multiply", function() {
        return o;
      }), l.d(d, "divide", function() {
        return h;
      }), l.d(d, "ceil", function() {
        return p;
      }), l.d(d, "floor", function() {
        return r;
      }), l.d(d, "min", function() {
        return V;
      }), l.d(d, "max", function() {
        return W;
      }), l.d(d, "round", function() {
        return y;
      }), l.d(d, "scale", function() {
        return t;
      }), l.d(d, "scaleAndAdd", function() {
        return e;
      }), l.d(d, "distance", function() {
        return Z;
      }), l.d(d, "squaredDistance", function() {
        return a;
      }), l.d(d, "length", function() {
        return x;
      }), l.d(d, "squaredLength", function() {
        return K;
      }), l.d(d, "negate", function() {
        return C;
      }), l.d(d, "inverse", function() {
        return T;
      }), l.d(d, "normalize", function() {
        return I;
      }), l.d(d, "dot", function() {
        return J;
      }), l.d(d, "cross", function() {
        return F;
      }), l.d(d, "lerp", function() {
        return R;
      }), l.d(d, "random", function() {
        return S;
      }), l.d(d, "transformMat4", function() {
        return N;
      }), l.d(d, "transformQuat", function() {
        return Q;
      }), l.d(d, "zero", function() {
        return P;
      }), l.d(d, "str", function() {
        return j;
      }), l.d(d, "exactEquals", function() {
        return D;
      }), l.d(d, "equals", function() {
        return z;
      }), l.d(d, "sub", function() {
        return w;
      }), l.d(d, "mul", function() {
        return A;
      }), l.d(d, "div", function() {
        return ll;
      }), l.d(d, "dist", function() {
        return _;
      }), l.d(d, "sqrDist", function() {
        return cl;
      }), l.d(d, "len", function() {
        return $;
      }), l.d(d, "sqrLen", function() {
        return al;
      }), l.d(d, "forEach", function() {
        return Xl;
      });
      var i = l(2);
      function s() {
        var M = new i.ARRAY_TYPE(4);
        return i.ARRAY_TYPE != Float32Array && (M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 0), M;
      }
      function c(M) {
        var k = new i.ARRAY_TYPE(4);
        return k[0] = M[0], k[1] = M[1], k[2] = M[2], k[3] = M[3], k;
      }
      function m(M, k, E, O) {
        var g = new i.ARRAY_TYPE(4);
        return g[0] = M, g[1] = k, g[2] = E, g[3] = O, g;
      }
      function n(M, k) {
        return M[0] = k[0], M[1] = k[1], M[2] = k[2], M[3] = k[3], M;
      }
      function X(M, k, E, O, g) {
        return M[0] = k, M[1] = E, M[2] = O, M[3] = g, M;
      }
      function G(M, k, E) {
        return M[0] = k[0] + E[0], M[1] = k[1] + E[1], M[2] = k[2] + E[2], M[3] = k[3] + E[3], M;
      }
      function L(M, k, E) {
        return M[0] = k[0] - E[0], M[1] = k[1] - E[1], M[2] = k[2] - E[2], M[3] = k[3] - E[3], M;
      }
      function o(M, k, E) {
        return M[0] = k[0] * E[0], M[1] = k[1] * E[1], M[2] = k[2] * E[2], M[3] = k[3] * E[3], M;
      }
      function h(M, k, E) {
        return M[0] = k[0] / E[0], M[1] = k[1] / E[1], M[2] = k[2] / E[2], M[3] = k[3] / E[3], M;
      }
      function p(M, k) {
        return M[0] = Math.ceil(k[0]), M[1] = Math.ceil(k[1]), M[2] = Math.ceil(k[2]), M[3] = Math.ceil(k[3]), M;
      }
      function r(M, k) {
        return M[0] = Math.floor(k[0]), M[1] = Math.floor(k[1]), M[2] = Math.floor(k[2]), M[3] = Math.floor(k[3]), M;
      }
      function V(M, k, E) {
        return M[0] = Math.min(k[0], E[0]), M[1] = Math.min(k[1], E[1]), M[2] = Math.min(k[2], E[2]), M[3] = Math.min(k[3], E[3]), M;
      }
      function W(M, k, E) {
        return M[0] = Math.max(k[0], E[0]), M[1] = Math.max(k[1], E[1]), M[2] = Math.max(k[2], E[2]), M[3] = Math.max(k[3], E[3]), M;
      }
      function y(M, k) {
        return M[0] = Math.round(k[0]), M[1] = Math.round(k[1]), M[2] = Math.round(k[2]), M[3] = Math.round(k[3]), M;
      }
      function t(M, k, E) {
        return M[0] = k[0] * E, M[1] = k[1] * E, M[2] = k[2] * E, M[3] = k[3] * E, M;
      }
      function e(M, k, E, O) {
        return M[0] = k[0] + E[0] * O, M[1] = k[1] + E[1] * O, M[2] = k[2] + E[2] * O, M[3] = k[3] + E[3] * O, M;
      }
      function Z(M, k) {
        var E = k[0] - M[0], O = k[1] - M[1], g = k[2] - M[2], U = k[3] - M[3];
        return Math.hypot(E, O, g, U);
      }
      function a(M, k) {
        var E = k[0] - M[0], O = k[1] - M[1], g = k[2] - M[2], U = k[3] - M[3];
        return E * E + O * O + g * g + U * U;
      }
      function x(M) {
        var k = M[0], E = M[1], O = M[2], g = M[3];
        return Math.hypot(k, E, O, g);
      }
      function K(M) {
        var k = M[0], E = M[1], O = M[2], g = M[3];
        return k * k + E * E + O * O + g * g;
      }
      function C(M, k) {
        return M[0] = -k[0], M[1] = -k[1], M[2] = -k[2], M[3] = -k[3], M;
      }
      function T(M, k) {
        return M[0] = 1 / k[0], M[1] = 1 / k[1], M[2] = 1 / k[2], M[3] = 1 / k[3], M;
      }
      function I(M, k) {
        var E = k[0], O = k[1], g = k[2], U = k[3], u = E * E + O * O + g * g + U * U;
        return u > 0 && (u = 1 / Math.sqrt(u)), M[0] = E * u, M[1] = O * u, M[2] = g * u, M[3] = U * u, M;
      }
      function J(M, k) {
        return M[0] * k[0] + M[1] * k[1] + M[2] * k[2] + M[3] * k[3];
      }
      function F(M, k, E, O) {
        var g = E[0] * O[1] - E[1] * O[0], U = E[0] * O[2] - E[2] * O[0], u = E[0] * O[3] - E[3] * O[0], Y = E[1] * O[2] - E[2] * O[1], H = E[1] * O[3] - E[3] * O[1], v = E[2] * O[3] - E[3] * O[2], f = k[0], B = k[1], q = k[2], dl = k[3];
        return M[0] = B * v - q * H + dl * Y, M[1] = -(f * v) + q * u - dl * U, M[2] = f * H - B * u + dl * g, M[3] = -(f * Y) + B * U - q * g, M;
      }
      function R(M, k, E, O) {
        var g = k[0], U = k[1], u = k[2], Y = k[3];
        return M[0] = g + O * (E[0] - g), M[1] = U + O * (E[1] - U), M[2] = u + O * (E[2] - u), M[3] = Y + O * (E[3] - Y), M;
      }
      function S(M, k) {
        k = k || 1;
        var E, O, g, U, u, Y;
        do
          E = i.RANDOM() * 2 - 1, O = i.RANDOM() * 2 - 1, u = E * E + O * O;
        while (u >= 1);
        do
          g = i.RANDOM() * 2 - 1, U = i.RANDOM() * 2 - 1, Y = g * g + U * U;
        while (Y >= 1);
        var H = Math.sqrt((1 - u) / Y);
        return M[0] = k * E, M[1] = k * O, M[2] = k * g * H, M[3] = k * U * H, M;
      }
      function N(M, k, E) {
        var O = k[0], g = k[1], U = k[2], u = k[3];
        return M[0] = E[0] * O + E[4] * g + E[8] * U + E[12] * u, M[1] = E[1] * O + E[5] * g + E[9] * U + E[13] * u, M[2] = E[2] * O + E[6] * g + E[10] * U + E[14] * u, M[3] = E[3] * O + E[7] * g + E[11] * U + E[15] * u, M;
      }
      function Q(M, k, E) {
        var O = k[0], g = k[1], U = k[2], u = E[0], Y = E[1], H = E[2], v = E[3], f = v * O + Y * U - H * g, B = v * g + H * O - u * U, q = v * U + u * g - Y * O, dl = -u * O - Y * g - H * U;
        return M[0] = f * v + dl * -u + B * -H - q * -Y, M[1] = B * v + dl * -Y + q * -u - f * -H, M[2] = q * v + dl * -H + f * -Y - B * -u, M[3] = k[3], M;
      }
      function P(M) {
        return M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 0, M;
      }
      function j(M) {
        return "vec4(" + M[0] + ", " + M[1] + ", " + M[2] + ", " + M[3] + ")";
      }
      function D(M, k) {
        return M[0] === k[0] && M[1] === k[1] && M[2] === k[2] && M[3] === k[3];
      }
      function z(M, k) {
        var E = M[0], O = M[1], g = M[2], U = M[3], u = k[0], Y = k[1], H = k[2], v = k[3];
        return Math.abs(E - u) <= i.EPSILON * Math.max(1, Math.abs(E), Math.abs(u)) && Math.abs(O - Y) <= i.EPSILON * Math.max(1, Math.abs(O), Math.abs(Y)) && Math.abs(g - H) <= i.EPSILON * Math.max(1, Math.abs(g), Math.abs(H)) && Math.abs(U - v) <= i.EPSILON * Math.max(1, Math.abs(U), Math.abs(v));
      }
      var w = L, A = o, ll = h, _ = Z, cl = a, $ = x, al = K, Xl = function() {
        var M = s();
        return function(k, E, O, g, U, u) {
          var Y, H;
          for (E || (E = 4), O || (O = 0), g ? H = Math.min(g * E + O, k.length) : H = k.length, Y = O; Y < H; Y += E)
            M[0] = k[Y], M[1] = k[Y + 1], M[2] = k[Y + 2], M[3] = k[Y + 3], U(M, M, u), k[Y] = M[0], k[Y + 1] = M[1], k[Y + 2] = M[2], k[Y + 3] = M[3];
          return k;
        };
      }();
    },
    /* 10 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return m;
      }), l.d(d, "clone", function() {
        return n;
      }), l.d(d, "fromValues", function() {
        return X;
      }), l.d(d, "fromRotationTranslationValues", function() {
        return G;
      }), l.d(d, "fromRotationTranslation", function() {
        return L;
      }), l.d(d, "fromTranslation", function() {
        return o;
      }), l.d(d, "fromRotation", function() {
        return h;
      }), l.d(d, "fromMat4", function() {
        return p;
      }), l.d(d, "copy", function() {
        return r;
      }), l.d(d, "identity", function() {
        return V;
      }), l.d(d, "set", function() {
        return W;
      }), l.d(d, "getReal", function() {
        return y;
      }), l.d(d, "getDual", function() {
        return t;
      }), l.d(d, "setReal", function() {
        return e;
      }), l.d(d, "setDual", function() {
        return Z;
      }), l.d(d, "getTranslation", function() {
        return a;
      }), l.d(d, "translate", function() {
        return x;
      }), l.d(d, "rotateX", function() {
        return K;
      }), l.d(d, "rotateY", function() {
        return C;
      }), l.d(d, "rotateZ", function() {
        return T;
      }), l.d(d, "rotateByQuatAppend", function() {
        return I;
      }), l.d(d, "rotateByQuatPrepend", function() {
        return J;
      }), l.d(d, "rotateAroundAxis", function() {
        return F;
      }), l.d(d, "add", function() {
        return R;
      }), l.d(d, "multiply", function() {
        return S;
      }), l.d(d, "mul", function() {
        return N;
      }), l.d(d, "scale", function() {
        return Q;
      }), l.d(d, "dot", function() {
        return P;
      }), l.d(d, "lerp", function() {
        return j;
      }), l.d(d, "invert", function() {
        return D;
      }), l.d(d, "conjugate", function() {
        return z;
      }), l.d(d, "length", function() {
        return w;
      }), l.d(d, "len", function() {
        return A;
      }), l.d(d, "squaredLength", function() {
        return ll;
      }), l.d(d, "sqrLen", function() {
        return _;
      }), l.d(d, "normalize", function() {
        return cl;
      }), l.d(d, "str", function() {
        return $;
      }), l.d(d, "exactEquals", function() {
        return al;
      }), l.d(d, "equals", function() {
        return Xl;
      });
      var i = l(2), s = l(7), c = l(6);
      function m() {
        var M = new i.ARRAY_TYPE(8);
        return i.ARRAY_TYPE != Float32Array && (M[0] = 0, M[1] = 0, M[2] = 0, M[4] = 0, M[5] = 0, M[6] = 0, M[7] = 0), M[3] = 1, M;
      }
      function n(M) {
        var k = new i.ARRAY_TYPE(8);
        return k[0] = M[0], k[1] = M[1], k[2] = M[2], k[3] = M[3], k[4] = M[4], k[5] = M[5], k[6] = M[6], k[7] = M[7], k;
      }
      function X(M, k, E, O, g, U, u, Y) {
        var H = new i.ARRAY_TYPE(8);
        return H[0] = M, H[1] = k, H[2] = E, H[3] = O, H[4] = g, H[5] = U, H[6] = u, H[7] = Y, H;
      }
      function G(M, k, E, O, g, U, u) {
        var Y = new i.ARRAY_TYPE(8);
        Y[0] = M, Y[1] = k, Y[2] = E, Y[3] = O;
        var H = g * 0.5, v = U * 0.5, f = u * 0.5;
        return Y[4] = H * O + v * E - f * k, Y[5] = v * O + f * M - H * E, Y[6] = f * O + H * k - v * M, Y[7] = -H * M - v * k - f * E, Y;
      }
      function L(M, k, E) {
        var O = E[0] * 0.5, g = E[1] * 0.5, U = E[2] * 0.5, u = k[0], Y = k[1], H = k[2], v = k[3];
        return M[0] = u, M[1] = Y, M[2] = H, M[3] = v, M[4] = O * v + g * H - U * Y, M[5] = g * v + U * u - O * H, M[6] = U * v + O * Y - g * u, M[7] = -O * u - g * Y - U * H, M;
      }
      function o(M, k) {
        return M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 1, M[4] = k[0] * 0.5, M[5] = k[1] * 0.5, M[6] = k[2] * 0.5, M[7] = 0, M;
      }
      function h(M, k) {
        return M[0] = k[0], M[1] = k[1], M[2] = k[2], M[3] = k[3], M[4] = 0, M[5] = 0, M[6] = 0, M[7] = 0, M;
      }
      function p(M, k) {
        var E = s.create();
        c.getRotation(E, k);
        var O = new i.ARRAY_TYPE(3);
        return c.getTranslation(O, k), L(M, E, O), M;
      }
      function r(M, k) {
        return M[0] = k[0], M[1] = k[1], M[2] = k[2], M[3] = k[3], M[4] = k[4], M[5] = k[5], M[6] = k[6], M[7] = k[7], M;
      }
      function V(M) {
        return M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 1, M[4] = 0, M[5] = 0, M[6] = 0, M[7] = 0, M;
      }
      function W(M, k, E, O, g, U, u, Y, H) {
        return M[0] = k, M[1] = E, M[2] = O, M[3] = g, M[4] = U, M[5] = u, M[6] = Y, M[7] = H, M;
      }
      var y = s.copy;
      function t(M, k) {
        return M[0] = k[4], M[1] = k[5], M[2] = k[6], M[3] = k[7], M;
      }
      var e = s.copy;
      function Z(M, k) {
        return M[4] = k[0], M[5] = k[1], M[6] = k[2], M[7] = k[3], M;
      }
      function a(M, k) {
        var E = k[4], O = k[5], g = k[6], U = k[7], u = -k[0], Y = -k[1], H = -k[2], v = k[3];
        return M[0] = (E * v + U * u + O * H - g * Y) * 2, M[1] = (O * v + U * Y + g * u - E * H) * 2, M[2] = (g * v + U * H + E * Y - O * u) * 2, M;
      }
      function x(M, k, E) {
        var O = k[0], g = k[1], U = k[2], u = k[3], Y = E[0] * 0.5, H = E[1] * 0.5, v = E[2] * 0.5, f = k[4], B = k[5], q = k[6], dl = k[7];
        return M[0] = O, M[1] = g, M[2] = U, M[3] = u, M[4] = u * Y + g * v - U * H + f, M[5] = u * H + U * Y - O * v + B, M[6] = u * v + O * H - g * Y + q, M[7] = -O * Y - g * H - U * v + dl, M;
      }
      function K(M, k, E) {
        var O = -k[0], g = -k[1], U = -k[2], u = k[3], Y = k[4], H = k[5], v = k[6], f = k[7], B = Y * u + f * O + H * U - v * g, q = H * u + f * g + v * O - Y * U, dl = v * u + f * U + Y * g - H * O, il = f * u - Y * O - H * g - v * U;
        return s.rotateX(M, k, E), O = M[0], g = M[1], U = M[2], u = M[3], M[4] = B * u + il * O + q * U - dl * g, M[5] = q * u + il * g + dl * O - B * U, M[6] = dl * u + il * U + B * g - q * O, M[7] = il * u - B * O - q * g - dl * U, M;
      }
      function C(M, k, E) {
        var O = -k[0], g = -k[1], U = -k[2], u = k[3], Y = k[4], H = k[5], v = k[6], f = k[7], B = Y * u + f * O + H * U - v * g, q = H * u + f * g + v * O - Y * U, dl = v * u + f * U + Y * g - H * O, il = f * u - Y * O - H * g - v * U;
        return s.rotateY(M, k, E), O = M[0], g = M[1], U = M[2], u = M[3], M[4] = B * u + il * O + q * U - dl * g, M[5] = q * u + il * g + dl * O - B * U, M[6] = dl * u + il * U + B * g - q * O, M[7] = il * u - B * O - q * g - dl * U, M;
      }
      function T(M, k, E) {
        var O = -k[0], g = -k[1], U = -k[2], u = k[3], Y = k[4], H = k[5], v = k[6], f = k[7], B = Y * u + f * O + H * U - v * g, q = H * u + f * g + v * O - Y * U, dl = v * u + f * U + Y * g - H * O, il = f * u - Y * O - H * g - v * U;
        return s.rotateZ(M, k, E), O = M[0], g = M[1], U = M[2], u = M[3], M[4] = B * u + il * O + q * U - dl * g, M[5] = q * u + il * g + dl * O - B * U, M[6] = dl * u + il * U + B * g - q * O, M[7] = il * u - B * O - q * g - dl * U, M;
      }
      function I(M, k, E) {
        var O = E[0], g = E[1], U = E[2], u = E[3], Y = k[0], H = k[1], v = k[2], f = k[3];
        return M[0] = Y * u + f * O + H * U - v * g, M[1] = H * u + f * g + v * O - Y * U, M[2] = v * u + f * U + Y * g - H * O, M[3] = f * u - Y * O - H * g - v * U, Y = k[4], H = k[5], v = k[6], f = k[7], M[4] = Y * u + f * O + H * U - v * g, M[5] = H * u + f * g + v * O - Y * U, M[6] = v * u + f * U + Y * g - H * O, M[7] = f * u - Y * O - H * g - v * U, M;
      }
      function J(M, k, E) {
        var O = k[0], g = k[1], U = k[2], u = k[3], Y = E[0], H = E[1], v = E[2], f = E[3];
        return M[0] = O * f + u * Y + g * v - U * H, M[1] = g * f + u * H + U * Y - O * v, M[2] = U * f + u * v + O * H - g * Y, M[3] = u * f - O * Y - g * H - U * v, Y = E[4], H = E[5], v = E[6], f = E[7], M[4] = O * f + u * Y + g * v - U * H, M[5] = g * f + u * H + U * Y - O * v, M[6] = U * f + u * v + O * H - g * Y, M[7] = u * f - O * Y - g * H - U * v, M;
      }
      function F(M, k, E, O) {
        if (Math.abs(O) < i.EPSILON)
          return r(M, k);
        var g = Math.hypot(E[0], E[1], E[2]);
        O = O * 0.5;
        var U = Math.sin(O), u = U * E[0] / g, Y = U * E[1] / g, H = U * E[2] / g, v = Math.cos(O), f = k[0], B = k[1], q = k[2], dl = k[3];
        M[0] = f * v + dl * u + B * H - q * Y, M[1] = B * v + dl * Y + q * u - f * H, M[2] = q * v + dl * H + f * Y - B * u, M[3] = dl * v - f * u - B * Y - q * H;
        var il = k[4], bl = k[5], ml = k[6], tl = k[7];
        return M[4] = il * v + tl * u + bl * H - ml * Y, M[5] = bl * v + tl * Y + ml * u - il * H, M[6] = ml * v + tl * H + il * Y - bl * u, M[7] = tl * v - il * u - bl * Y - ml * H, M;
      }
      function R(M, k, E) {
        return M[0] = k[0] + E[0], M[1] = k[1] + E[1], M[2] = k[2] + E[2], M[3] = k[3] + E[3], M[4] = k[4] + E[4], M[5] = k[5] + E[5], M[6] = k[6] + E[6], M[7] = k[7] + E[7], M;
      }
      function S(M, k, E) {
        var O = k[0], g = k[1], U = k[2], u = k[3], Y = E[4], H = E[5], v = E[6], f = E[7], B = k[4], q = k[5], dl = k[6], il = k[7], bl = E[0], ml = E[1], tl = E[2], sl = E[3];
        return M[0] = O * sl + u * bl + g * tl - U * ml, M[1] = g * sl + u * ml + U * bl - O * tl, M[2] = U * sl + u * tl + O * ml - g * bl, M[3] = u * sl - O * bl - g * ml - U * tl, M[4] = O * f + u * Y + g * v - U * H + B * sl + il * bl + q * tl - dl * ml, M[5] = g * f + u * H + U * Y - O * v + q * sl + il * ml + dl * bl - B * tl, M[6] = U * f + u * v + O * H - g * Y + dl * sl + il * tl + B * ml - q * bl, M[7] = u * f - O * Y - g * H - U * v + il * sl - B * bl - q * ml - dl * tl, M;
      }
      var N = S;
      function Q(M, k, E) {
        return M[0] = k[0] * E, M[1] = k[1] * E, M[2] = k[2] * E, M[3] = k[3] * E, M[4] = k[4] * E, M[5] = k[5] * E, M[6] = k[6] * E, M[7] = k[7] * E, M;
      }
      var P = s.dot;
      function j(M, k, E, O) {
        var g = 1 - O;
        return P(k, E) < 0 && (O = -O), M[0] = k[0] * g + E[0] * O, M[1] = k[1] * g + E[1] * O, M[2] = k[2] * g + E[2] * O, M[3] = k[3] * g + E[3] * O, M[4] = k[4] * g + E[4] * O, M[5] = k[5] * g + E[5] * O, M[6] = k[6] * g + E[6] * O, M[7] = k[7] * g + E[7] * O, M;
      }
      function D(M, k) {
        var E = ll(k);
        return M[0] = -k[0] / E, M[1] = -k[1] / E, M[2] = -k[2] / E, M[3] = k[3] / E, M[4] = -k[4] / E, M[5] = -k[5] / E, M[6] = -k[6] / E, M[7] = k[7] / E, M;
      }
      function z(M, k) {
        return M[0] = -k[0], M[1] = -k[1], M[2] = -k[2], M[3] = k[3], M[4] = -k[4], M[5] = -k[5], M[6] = -k[6], M[7] = k[7], M;
      }
      var w = s.length, A = w, ll = s.squaredLength, _ = ll;
      function cl(M, k) {
        var E = ll(k);
        if (E > 0) {
          E = Math.sqrt(E);
          var O = k[0] / E, g = k[1] / E, U = k[2] / E, u = k[3] / E, Y = k[4], H = k[5], v = k[6], f = k[7], B = O * Y + g * H + U * v + u * f;
          M[0] = O, M[1] = g, M[2] = U, M[3] = u, M[4] = (Y - O * B) / E, M[5] = (H - g * B) / E, M[6] = (v - U * B) / E, M[7] = (f - u * B) / E;
        }
        return M;
      }
      function $(M) {
        return "quat2(" + M[0] + ", " + M[1] + ", " + M[2] + ", " + M[3] + ", " + M[4] + ", " + M[5] + ", " + M[6] + ", " + M[7] + ")";
      }
      function al(M, k) {
        return M[0] === k[0] && M[1] === k[1] && M[2] === k[2] && M[3] === k[3] && M[4] === k[4] && M[5] === k[5] && M[6] === k[6] && M[7] === k[7];
      }
      function Xl(M, k) {
        var E = M[0], O = M[1], g = M[2], U = M[3], u = M[4], Y = M[5], H = M[6], v = M[7], f = k[0], B = k[1], q = k[2], dl = k[3], il = k[4], bl = k[5], ml = k[6], tl = k[7];
        return Math.abs(E - f) <= i.EPSILON * Math.max(1, Math.abs(E), Math.abs(f)) && Math.abs(O - B) <= i.EPSILON * Math.max(1, Math.abs(O), Math.abs(B)) && Math.abs(g - q) <= i.EPSILON * Math.max(1, Math.abs(g), Math.abs(q)) && Math.abs(U - dl) <= i.EPSILON * Math.max(1, Math.abs(U), Math.abs(dl)) && Math.abs(u - il) <= i.EPSILON * Math.max(1, Math.abs(u), Math.abs(il)) && Math.abs(Y - bl) <= i.EPSILON * Math.max(1, Math.abs(Y), Math.abs(bl)) && Math.abs(H - ml) <= i.EPSILON * Math.max(1, Math.abs(H), Math.abs(ml)) && Math.abs(v - tl) <= i.EPSILON * Math.max(1, Math.abs(v), Math.abs(tl));
      }
    },
    /* 11 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return s;
      }), l.d(d, "clone", function() {
        return c;
      }), l.d(d, "fromValues", function() {
        return m;
      }), l.d(d, "copy", function() {
        return n;
      }), l.d(d, "set", function() {
        return X;
      }), l.d(d, "add", function() {
        return G;
      }), l.d(d, "subtract", function() {
        return L;
      }), l.d(d, "multiply", function() {
        return o;
      }), l.d(d, "divide", function() {
        return h;
      }), l.d(d, "ceil", function() {
        return p;
      }), l.d(d, "floor", function() {
        return r;
      }), l.d(d, "min", function() {
        return V;
      }), l.d(d, "max", function() {
        return W;
      }), l.d(d, "round", function() {
        return y;
      }), l.d(d, "scale", function() {
        return t;
      }), l.d(d, "scaleAndAdd", function() {
        return e;
      }), l.d(d, "distance", function() {
        return Z;
      }), l.d(d, "squaredDistance", function() {
        return a;
      }), l.d(d, "length", function() {
        return x;
      }), l.d(d, "squaredLength", function() {
        return K;
      }), l.d(d, "negate", function() {
        return C;
      }), l.d(d, "inverse", function() {
        return T;
      }), l.d(d, "normalize", function() {
        return I;
      }), l.d(d, "dot", function() {
        return J;
      }), l.d(d, "cross", function() {
        return F;
      }), l.d(d, "lerp", function() {
        return R;
      }), l.d(d, "random", function() {
        return S;
      }), l.d(d, "transformMat2", function() {
        return N;
      }), l.d(d, "transformMat2d", function() {
        return Q;
      }), l.d(d, "transformMat3", function() {
        return P;
      }), l.d(d, "transformMat4", function() {
        return j;
      }), l.d(d, "rotate", function() {
        return D;
      }), l.d(d, "angle", function() {
        return z;
      }), l.d(d, "zero", function() {
        return w;
      }), l.d(d, "str", function() {
        return A;
      }), l.d(d, "exactEquals", function() {
        return ll;
      }), l.d(d, "equals", function() {
        return _;
      }), l.d(d, "len", function() {
        return cl;
      }), l.d(d, "sub", function() {
        return $;
      }), l.d(d, "mul", function() {
        return al;
      }), l.d(d, "div", function() {
        return Xl;
      }), l.d(d, "dist", function() {
        return M;
      }), l.d(d, "sqrDist", function() {
        return k;
      }), l.d(d, "sqrLen", function() {
        return E;
      }), l.d(d, "forEach", function() {
        return O;
      });
      var i = l(2);
      function s() {
        var g = new i.ARRAY_TYPE(2);
        return i.ARRAY_TYPE != Float32Array && (g[0] = 0, g[1] = 0), g;
      }
      function c(g) {
        var U = new i.ARRAY_TYPE(2);
        return U[0] = g[0], U[1] = g[1], U;
      }
      function m(g, U) {
        var u = new i.ARRAY_TYPE(2);
        return u[0] = g, u[1] = U, u;
      }
      function n(g, U) {
        return g[0] = U[0], g[1] = U[1], g;
      }
      function X(g, U, u) {
        return g[0] = U, g[1] = u, g;
      }
      function G(g, U, u) {
        return g[0] = U[0] + u[0], g[1] = U[1] + u[1], g;
      }
      function L(g, U, u) {
        return g[0] = U[0] - u[0], g[1] = U[1] - u[1], g;
      }
      function o(g, U, u) {
        return g[0] = U[0] * u[0], g[1] = U[1] * u[1], g;
      }
      function h(g, U, u) {
        return g[0] = U[0] / u[0], g[1] = U[1] / u[1], g;
      }
      function p(g, U) {
        return g[0] = Math.ceil(U[0]), g[1] = Math.ceil(U[1]), g;
      }
      function r(g, U) {
        return g[0] = Math.floor(U[0]), g[1] = Math.floor(U[1]), g;
      }
      function V(g, U, u) {
        return g[0] = Math.min(U[0], u[0]), g[1] = Math.min(U[1], u[1]), g;
      }
      function W(g, U, u) {
        return g[0] = Math.max(U[0], u[0]), g[1] = Math.max(U[1], u[1]), g;
      }
      function y(g, U) {
        return g[0] = Math.round(U[0]), g[1] = Math.round(U[1]), g;
      }
      function t(g, U, u) {
        return g[0] = U[0] * u, g[1] = U[1] * u, g;
      }
      function e(g, U, u, Y) {
        return g[0] = U[0] + u[0] * Y, g[1] = U[1] + u[1] * Y, g;
      }
      function Z(g, U) {
        var u = U[0] - g[0], Y = U[1] - g[1];
        return Math.hypot(u, Y);
      }
      function a(g, U) {
        var u = U[0] - g[0], Y = U[1] - g[1];
        return u * u + Y * Y;
      }
      function x(g) {
        var U = g[0], u = g[1];
        return Math.hypot(U, u);
      }
      function K(g) {
        var U = g[0], u = g[1];
        return U * U + u * u;
      }
      function C(g, U) {
        return g[0] = -U[0], g[1] = -U[1], g;
      }
      function T(g, U) {
        return g[0] = 1 / U[0], g[1] = 1 / U[1], g;
      }
      function I(g, U) {
        var u = U[0], Y = U[1], H = u * u + Y * Y;
        return H > 0 && (H = 1 / Math.sqrt(H)), g[0] = U[0] * H, g[1] = U[1] * H, g;
      }
      function J(g, U) {
        return g[0] * U[0] + g[1] * U[1];
      }
      function F(g, U, u) {
        var Y = U[0] * u[1] - U[1] * u[0];
        return g[0] = g[1] = 0, g[2] = Y, g;
      }
      function R(g, U, u, Y) {
        var H = U[0], v = U[1];
        return g[0] = H + Y * (u[0] - H), g[1] = v + Y * (u[1] - v), g;
      }
      function S(g, U) {
        U = U || 1;
        var u = i.RANDOM() * 2 * Math.PI;
        return g[0] = Math.cos(u) * U, g[1] = Math.sin(u) * U, g;
      }
      function N(g, U, u) {
        var Y = U[0], H = U[1];
        return g[0] = u[0] * Y + u[2] * H, g[1] = u[1] * Y + u[3] * H, g;
      }
      function Q(g, U, u) {
        var Y = U[0], H = U[1];
        return g[0] = u[0] * Y + u[2] * H + u[4], g[1] = u[1] * Y + u[3] * H + u[5], g;
      }
      function P(g, U, u) {
        var Y = U[0], H = U[1];
        return g[0] = u[0] * Y + u[3] * H + u[6], g[1] = u[1] * Y + u[4] * H + u[7], g;
      }
      function j(g, U, u) {
        var Y = U[0], H = U[1];
        return g[0] = u[0] * Y + u[4] * H + u[12], g[1] = u[1] * Y + u[5] * H + u[13], g;
      }
      function D(g, U, u, Y) {
        var H = U[0] - u[0], v = U[1] - u[1], f = Math.sin(Y), B = Math.cos(Y);
        return g[0] = H * B - v * f + u[0], g[1] = H * f + v * B + u[1], g;
      }
      function z(g, U) {
        var u = g[0], Y = g[1], H = U[0], v = U[1], f = Math.sqrt(u * u + Y * Y) * Math.sqrt(H * H + v * v), B = f && (u * H + Y * v) / f;
        return Math.acos(Math.min(Math.max(B, -1), 1));
      }
      function w(g) {
        return g[0] = 0, g[1] = 0, g;
      }
      function A(g) {
        return "vec2(" + g[0] + ", " + g[1] + ")";
      }
      function ll(g, U) {
        return g[0] === U[0] && g[1] === U[1];
      }
      function _(g, U) {
        var u = g[0], Y = g[1], H = U[0], v = U[1];
        return Math.abs(u - H) <= i.EPSILON * Math.max(1, Math.abs(u), Math.abs(H)) && Math.abs(Y - v) <= i.EPSILON * Math.max(1, Math.abs(Y), Math.abs(v));
      }
      var cl = x, $ = L, al = o, Xl = h, M = Z, k = a, E = K, O = function() {
        var g = s();
        return function(U, u, Y, H, v, f) {
          var B, q;
          for (u || (u = 2), Y || (Y = 0), H ? q = Math.min(H * u + Y, U.length) : q = U.length, B = Y; B < q; B += u)
            g[0] = U[B], g[1] = U[B + 1], v(g, g, f), U[B] = g[0], U[B + 1] = g[1];
          return U;
        };
      }();
    },
    /* 12 */
    /***/
    function(b, d, l) {
      l.r(d);
      var i = l(13);
      l.d(d, "Renderer", function() {
        return i.default;
      });
      var s = l(40);
      l.d(d, "Figure2D", function() {
        return s.default;
      });
      var c = l(56);
      l.d(d, "Mesh2D", function() {
        return c.default;
      });
      var m = l(29);
      l.d(d, "MeshCloud", function() {
        return m.default;
      });
      var n = l(23);
      l.d(d, "parseFont", function() {
        return n.default;
      });
      var X = l(31);
      l.d(d, "parseColor", function() {
        return X.default;
      });
      var G = l(21);
      l.d(d, "ENV", function() {
        return G.default;
      }), l(1).glMatrix.setMatrixArrayType(Array);
    },
    /* 13 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return T;
      });
      var i = l(14), s = l(1), c = l(20), m = l(27), n = l(25), X = l(40), G = l(56), L = l(29), o = l(59), h = l(21), p = l(63);
      l(1).glMatrix.setMatrixArrayType(Array);
      const r = {
        autoUpdate: !1,
        // premultipliedAlpha: true,
        preserveDrawingBuffer: !1,
        // depth: false,
        // antialias: false,
        bufferSize: 1500
      }, V = `attribute vec3 a_vertexPosition;
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

void main() {
  gl_PointSize = 1.0;
  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);    
  vTextureCoord = a_vertexTextureCoord;              
}
`, W = `precision mediump float;
varying vec3 vTextureCoord;
uniform sampler2D u_texSampler;
void main() {
  gl_FragColor = texture2D(u_texSampler, vTextureCoord.xy);
}
`, y = Symbol("glRenderer"), t = Symbol("canvasRenderer"), e = Symbol("options"), Z = Symbol("globalTransform"), a = Symbol("applyGlobalTransform"), x = Symbol("canvas");
      function K(I) {
        const J = I.gl, F = I.fbo;
        F && J.bindFramebuffer(J.FRAMEBUFFER, F), I._draw(), F && J.bindFramebuffer(J.FRAMEBUFFER, null);
      }
      function C(I, J, F, R) {
        const S = I.createTexture(J.canvas), N = [[[0, 0], [F, 0], [F, R], [0, R], [0, 0]]];
        N.closed = !0;
        const Q = new G.default({
          contours: N
        });
        Q.setTexture(S), I.setMeshData([Q.meshData]), K(I), S.delete(), J.clearRect(0, 0, F, R), delete J._filter;
      }
      class T {
        constructor(J, F = {}) {
          let R = F.contextType;
          if (R || (typeof WebGL2RenderingContext == "function" ? R = "webgl2" : typeof WebGLRenderingContext == "function" ? R = "webgl" : R = "2d"), !J.getContext) {
            const S = J;
            J = {
              getContext() {
                return S;
              },
              width: F.width,
              height: F.height
            }, S.canvas = J, R = "2d";
          }
          if (this[x] = J, R !== "webgl" && R !== "webgl2" && R !== "2d")
            throw new Error(`Unknown context type ${R}`);
          if (F.contextType = R, this[e] = Object.assign({}, r, F), R === "webgl" || R === "webgl2") {
            R === "webgl2" && (this[e].webgl2 = !0);
            const S = new i.default(J, this[e]);
            R === "webgl2" && !S.isWebGL2 && (F.contextType = "webgl"), Object(p.createShaders)(S), Object(p.applyShader)(S), Object(p.createCloudShaders)(S);
            const N = S.gl;
            N.clearColor(0, 0, 0, 0), N.blendFuncSeparate(N.SRC_ALPHA, N.ONE_MINUS_SRC_ALPHA, N.ONE, N.ONE_MINUS_SRC_ALPHA), this[y] = S;
          } else
            this[t] = new c.default(J, this[e]);
          this[Z] = [1, 0, 0, 0, 1, 0, 0, 0, 1], this.updateResolution();
        }
        get canvas() {
          return this[x];
        }
        get canvasRenderer() {
          return this[t];
        }
        get glRenderer() {
          return this[y];
        }
        get isWebGL2() {
          return this[y] && this[y].isWebGL2;
        }
        get options() {
          return this[e];
        }
        get globalTransformMatrix() {
          const J = this[Z];
          return [J[0], J[1], J[3], J[4], J[6], J[7]];
        }
        get viewMatrix() {
          return this[Z];
        }
        [a]() {
          const J = this[y] || this[t];
          if (this[y]) {
            const {
              width: F,
              height: R
            } = this.canvas;
            J.uniforms.viewMatrix = this.viewMatrix, J.uniforms.projectionMatrix = this.projectionMatrix, J.uniforms.u_resolution = [F, R];
          }
        }
        updateResolution() {
          const {
            width: J,
            height: F
          } = this.canvas, R = [
            // translation
            1,
            0,
            0,
            0,
            1,
            0,
            -J / 2,
            -F / 2,
            1
          ], S = [
            // scale
            2 / J,
            0,
            0,
            0,
            -2 / F,
            0,
            0,
            0,
            1
          ], N = s.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, R);
          this.projectionMatrix = N, this[y] && this[y].gl.viewport(0, 0, J, F);
        }
        createTexture(J, F) {
          return (this[y] || this[t]).createTexture(J, F);
        }
        /* async */
        loadTexture(J, {
          useImageBitmap: F = !1
        } = {}) {
          return (this[y] || this[t]).loadTexture(J, {
            useImageBitmap: F
          });
        }
        createText(J, {
          font: F = "16px arial",
          fillColor: R = null,
          strokeColor: S = null,
          strokeWidth: N = 1
        } = {}) {
          if (this[y]) {
            const Q = h.default.createText(J, {
              font: F,
              fillColor: R,
              strokeColor: S,
              strokeWidth: N
            });
            return {
              image: this.createTexture(Q.image),
              rect: Q.rect
            };
          }
          return {
            _img: {
              font: F,
              fillColor: R,
              strokeColor: S,
              strokeWidth: N,
              text: J
            }
          };
        }
        createProgram({
          vertex: J,
          fragment: F,
          options: R
        } = {}) {
          if (this[y]) {
            const S = this[y].compileSync(F, J);
            return S._attribOpts = R, S;
          }
          throw new Error("Context 2D cannot create webgl program.");
        }
        createPassProgram({
          vertex: J = V,
          fragment: F = W,
          options: R
        } = {}) {
          return this.createProgram({
            vertex: J,
            fragment: F,
            options: R
          });
        }
        useProgram(J, F = {}) {
          if (this[y]) {
            const R = Object.assign({}, J._attribOpts, F);
            return this[y].useProgram(J, R);
          }
          throw new Error("Context 2D cannot use webgl program.");
        }
        deleteTexture(J) {
          return (this[y] || this[t]).deleteTexture(J);
        }
        clear(...J) {
          if (this[y]) {
            const F = this[y].gl;
            F.clear(F.COLOR_BUFFER_BIT);
          } else
            this[t].clear(...J);
        }
        drawMeshCloud(J, {
          clear: F = !1,
          program: R = null
        } = {}) {
          const S = this[y] || this[t], N = R || J.program;
          if (this[y]) {
            const Q = S.gl;
            if (F && Q.clear(Q.COLOR_BUFFER_BIT), N)
              S.program !== N && this.useProgram(N, {
                a_color: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_fillCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_strokeCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_frameIndex: {
                  type: "UNSIGNED_BYTE",
                  normalize: !1
                }
              });
            else {
              const P = J.mesh.meshData, j = !!P.uniforms.u_texSampler, D = !!P.uniforms.u_filterFlag, z = !!P.uniforms.u_radialGradientVector, w = J.hasCloudColor, A = J.hasCloudFilter, ll = !!P.uniforms.u_clipSampler;
              Object(p.applyCloudShader)(S, {
                hasTexture: j,
                hasFilter: D,
                hasGradient: z,
                hasCloudColor: w,
                hasCloudFilter: A,
                hasClipPath: ll
              });
            }
            this[a](), S.setMeshData([J.meshData]), J.beforeRender && J.beforeRender(Q, J), K(S), J.afterRender && J.afterRender(Q, J);
          } else
            S.setTransform(this.globalTransformMatrix), S.drawMeshCloud(J, {
              clear: F,
              hook: !1
            });
        }
        drawMeshes(J, {
          clear: F = !1,
          program: R = null
        } = {}) {
          const S = this[y] || this[t];
          if (this[y]) {
            const N = S.fbo, Q = Object(m.default)(this, J, R == null), P = S.gl;
            F && P.clear(P.COLOR_BUFFER_BIT);
            const j = !Object(o.isUnitTransform)(this.globalTransformMatrix);
            this._drawCalls = 0;
            for (const D of Q) {
              this._drawCalls++;
              const z = R || D.program;
              if (D instanceof L.default)
                this.drawMeshCloud(D, {
                  clear: F,
                  program: z
                });
              else {
                const {
                  width: w,
                  height: A
                } = this.canvas;
                if (D.beforeRender && D.beforeRender(P, D), D.pass.length && ((!this.fbo || this.fbo.width !== w || this.fbo.height !== A) && (this.fbo = {
                  width: w,
                  height: A,
                  target: S.createFBO(),
                  buffer: S.createFBO(),
                  swap() {
                    [this.target, this.buffer] = [this.buffer, this.target];
                  }
                }), S.bindFBO(this.fbo.target)), !z && D.filterCanvas) {
                  Object(p.applyShader)(S, {
                    hasTexture: !0
                  });
                  let ll = this.filterContext;
                  ll || (ll = h.default.createCanvas(w, A).getContext("2d"), this.filterContext = ll);
                  const _ = J[D.packIndex], cl = _.filter, $ = J[D.packIndex + 1], al = J[D.packIndex - 1];
                  (!al || !al.filterCanvas || al.filter !== cl) && (!$ || !$.filterCanvas || $.filter !== cl) ? (j ? (ll.save(), Object(n.drawMesh2D)(_, ll, !1), ll.restore(), Object(n.applyFilter)(ll, cl)) : Object(n.drawMesh2D)(_, ll, !0), this[a](), C(S, ll, w, A)) : (j && ll.save(), Object(n.drawMesh2D)(_, ll, !1), j && ll.restore(), (!$ || !$.filterCanvas || _.filter !== $.filter) && (Object(n.applyFilter)(ll, cl), this[a](), C(S, ll, w, A)));
                } else {
                  if (z)
                    S.program !== z && this.useProgram(z, {
                      a_color: {
                        type: "UNSIGNED_BYTE",
                        normalize: !0
                      }
                    });
                  else {
                    const ll = !!D.uniforms.u_texSampler, _ = !!D.uniforms.u_filterFlag, cl = !!D.uniforms.u_radialGradientVector, $ = !!D.uniforms.u_clipSampler;
                    Object(p.applyShader)(S, {
                      hasTexture: ll,
                      hasFilter: _,
                      hasGradient: cl,
                      hasClipPath: $
                    });
                  }
                  D.filterCanvas && console.warn("User program ignored some filter effects."), this[a](), S.setMeshData([D]), K(S);
                }
                if (D.pass.length) {
                  const ll = D.pass.length;
                  D.pass.forEach((_, cl) => {
                    _.blend = D.enableBlend, _.setTexture(S.fbo.texture), cl === ll - 1 ? S.bindFBO(N) : (this.fbo.swap(), S.bindFBO(this.fbo.target)), _.program ? S.useProgram(_.program) : (this.defaultPassProgram = this.defaultPassProgram || this.createPassProgram(), S.useProgram(this.defaultPassProgram)), S.setMeshData([_.meshData]), P.clear(P.COLOR_BUFFER_BIT), K(S);
                  });
                }
                D.afterRender && D.afterRender(P, D);
              }
            }
          } else
            S.setTransform(this.globalTransformMatrix), S.drawMeshes(J, {
              clear: F
            });
        }
        drawImage(J, ...F) {
          const R = F.length;
          if (R < 2)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': 3 arguments required, but only ${F.length + 1} present.`);
          if (R !== 2 && R !== 4 && R !== 8)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': Valid arities are: [3, 5, 9], but ${F.length + 1} arguments provided.`);
          let S = null, N = null;
          R === 2 ? S = [F[0], F[1], J.width, J.height] : R === 4 ? S = F : R === 8 && (N = F.slice(0, 4), S = F.slice(4));
          const Q = this.createTexture(J), {
            width: P,
            height: j
          } = this.canvas, D = new X.default();
          D.rect(S[0], S[1], P, j);
          const z = new G.default(D, {
            width: P,
            height: j
          });
          z.setTexture(Q, {
            rect: S,
            srcRect: N
          }), this.drawMeshes([z]), this.deleteTexture(Q);
        }
        setGlobalTransform(...J) {
          return this[Z] = [J[0], J[1], 0, J[2], J[3], 0, J[4], J[5], 1], this;
        }
        globalTransform(...J) {
          const F = this[Z];
          return this[Z] = s.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), F, J), this;
        }
        globalTranslate(J, F) {
          let R = s.mat3.create();
          return R = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), R, [J, F]), this.globalTransform(...R);
        }
        globalRotate(J, [F, R] = [0, 0]) {
          let S = s.mat3.create();
          return S = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, [F, R]), S = s.mat3.rotate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, J), S = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, [-F, -R]), this.globalTransform(...S);
        }
        globalScale(J, F = J, [R, S] = [0, 0]) {
          let N = s.mat3.create();
          return N = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), N, [R, S]), N = s.mat3.scale(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), N, [J, F]), N = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), N, [-R, -S]), this.globalTransform(...N);
        }
        globalSkew(J, F = J, [R, S] = [0, 0]) {
          let N = s.mat3.create();
          return N = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), N, [R, S]), N = s.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), N, s.mat3.fromValues(1, Math.tan(F), Math.tan(J), 1, 0, 0)), N = s.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), N, [-R, -S]), this.globalTransform(...N);
        }
        transformPoint(J, F, R) {
          let S = this.globalTransformMatrix;
          R && (S = s.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, R));
          const N = J * S[0] + F * S[2] + S[4], Q = J * S[1] + F * S[3] + S[5];
          return [N, Q];
        }
      }
    },
    /* 14 */
    /***/
    function(b, d, l) {
      l.r(d);
      var i = l(15);
      l(1).glMatrix.setMatrixArrayType(Array), d.default = i.default;
    },
    /* 15 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return p;
      });
      var i = l(16), s = l(17), c = l(18), m = l(19);
      l(1).glMatrix.setMatrixArrayType(Array);
      function n(r, V, W) {
        return V in r ? Object.defineProperty(r, V, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : r[V] = W, r;
      }
      const X = {};
      function G(r, V = 3) {
        const W = [], y = r.length;
        for (let t = 0; t < y; t++)
          t % V < 2 && W.push(0.5 * (r[t] + 1));
        return W;
      }
      function L(r, V) {
        const W = V._buffers;
        Object.values(W).forEach((y) => {
          r.deleteBuffer(y);
        }), V._buffers = {};
      }
      function o(r, V, W) {
        return r.activeTexture(r.TEXTURE0 + W), Array.isArray(V._img) ? r.bindTexture(r.TEXTURE_CUBE_MAP, V) : r.bindTexture(r.TEXTURE_2D, V), V;
      }
      const h = {
        int: "1i",
        ivec2: "2i",
        ivec3: "3i",
        ivec4: "4i",
        float: "1f",
        vec2: "2f",
        vec3: "3f",
        vec4: "4f",
        mat2: "Matrix2fv",
        mat3: "Matrix3fv",
        mat4: "Matrix4fv",
        sampler1D: "sampler1D",
        sampler2D: "sampler2D",
        sampler3D: "sampler3D",
        samplerCube: "samplerCube",
        sampler1DShadow: "sampler1DShadow",
        sampler2DShadow: "sampler2DShadow",
        sampler2DRect: "sampler2DRect",
        sampler2DRectShadow: "sampler2DRectShadow"
      };
      class p {
        static addLibs(V = {}) {
          Object.assign(X, V);
        }
        static FLOAT(V, W) {
          return Object(i.pointsToBuffer)(V, Float32Array, W);
        }
        static UNSIGNED_BYTE(V, W) {
          return Object(i.pointsToBuffer)(V, Uint8Array, W);
        }
        static UNSIGNED_SHORT(V, W) {
          return Object(i.pointsToBuffer)(V, Uint16Array, W);
        }
        static BYTE(V, W) {
          return Object(i.pointsToBuffer)(V, Int8Array, W);
        }
        static SHORT(V, W) {
          return Object(i.pointsToBuffer)(V, Int16Array, W);
        }
        constructor(V, W = {}) {
          this.options = Object.assign({}, p.defaultOptions, W), this.canvas = V;
          let y;
          this.options.webgl2 && (y = V.getContext("webgl2", this.options)), y == null && (y = Object(i.setupWebGL)(V, this.options), this.aia_ext = y.getExtension("ANGLE_instanced_arrays")), this.gl = y, y.viewport(0, 0, V.width, V.height), y.clearColor(0, 0, 0, 0), y.blendFuncSeparate(y.SRC_ALPHA, y.ONE_MINUS_SRC_ALPHA, y.ONE, y.ONE_MINUS_SRC_ALPHA), this.programs = [], this._events = {};
        }
        get program() {
          const V = this.gl;
          return V.getParameter(V.CURRENT_PROGRAM);
        }
        // WebGLRenderingContext.uniform[1234][fi][v]()
        // WebGLRenderingContext.uniformMatrix[234]fv()
        _declareUniform(V, W, y = "1f") {
          const t = this.gl, e = t.getUniformLocation(V, W);
          let Z;
          const a = this;
          if (/^sampler/.test(y)) {
            const x = V._samplerMap, K = V._bindTextures;
            Object.defineProperty(V.uniforms, W, {
              get() {
                return Z;
              },
              set(C) {
                Z = C;
                const T = x[W] != null ? x[W] : K.length;
                K[T] = C, o(t, C, T), x[W] || (x[W] = T, t.uniform1i(e, T)), a.options.autoUpdate && a.update();
              },
              configurable: !1,
              enumerable: !0
            });
          } else {
            const x = y.indexOf("Matrix") === 0, K = !x && /v$/.test(y), C = t[`uniform${y}`].bind(t);
            Object.defineProperty(V.uniforms, W, {
              get() {
                return Z;
              },
              set(T) {
                Z = T, typeof T == "number" && (T = [T]), x ? C(e, !1, T) : K ? C(e, T) : C(e, ...T), a.options.autoUpdate && a.update();
              },
              configurable: !1,
              enumerable: !0
            });
          }
        }
        _draw() {
          const V = this.program;
          V.meshData.forEach((W, y) => {
            const {
              positions: t,
              cells: e,
              instanceCount: Z,
              cellsCount: a,
              attributes: x,
              uniforms: K,
              textureCoord: C,
              enableBlend: T
            } = W, I = this.gl;
            let J = W.mode != null ? W.mode : I.TRIANGLES;
            typeof J == "string" && (J = I[J]), T ? I.enable(I.BLEND) : I.disable(I.BLEND), I.bindBuffer(I.ARRAY_BUFFER, V._buffers.verticesBuffer), I.bufferData(I.ARRAY_BUFFER, t, I.STATIC_DRAW), e && (I.bindBuffer(I.ELEMENT_ARRAY_BUFFER, V._buffers.cellsBuffer), I.bufferData(I.ELEMENT_ARRAY_BUFFER, e, I.STATIC_DRAW));
            const F = [];
            x && Object.values(x).forEach(({
              name: S,
              data: N,
              divisor: Q
            }) => {
              if (I.bindBuffer(I.ARRAY_BUFFER, V._buffers[S]), I.bufferData(I.ARRAY_BUFFER, N, I.STATIC_DRAW), Q != null) {
                const P = I.getAttribLocation(V, S);
                P >= 0 && (I.enableVertexAttribArray(P), F.push(P), I.vertexAttribDivisor ? I.vertexAttribDivisor(P, Q) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(P, Q));
              }
            }), K && Object.entries(K).forEach(([S, N]) => {
              this.uniforms[S] = N;
            });
            let R;
            if (!e) {
              const S = V._dimension;
              R = t.length / S;
            }
            if (V._enableTextures && V._buffers.texCoordBuffer) {
              const S = C || G(t, V._dimension);
              I.bindBuffer(I.ARRAY_BUFFER, V._buffers.texCoordBuffer), I.bufferData(I.ARRAY_BUFFER, p.FLOAT(S), I.STATIC_DRAW);
            }
            Z != null ? (e ? I.drawElementsInstanced ? I.drawElementsInstanced(J, a, I.UNSIGNED_SHORT, 0, Z) : this.aia_ext && this.aia_ext.drawElementsInstancedANGLE(J, a, I.UNSIGNED_SHORT, 0, Z) : I.drawArraysInstanced ? I.drawArraysInstanced(J, 0, R, Z) : this.aia_ext.drawArraysInstancedANGLE(J, 0, R, Z), F.forEach((S) => {
              I.vertexAttribDivisor ? I.vertexAttribDivisor(S, null) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(S, null);
            })) : e ? I.drawElements(J, a, I.UNSIGNED_SHORT, 0) : I.drawArrays(J, 0, R);
          });
        }
        get isWebGL2() {
          return typeof WebGL2RenderingContext < "u" && this.gl instanceof WebGL2RenderingContext;
        }
        get enableTextures() {
          return this.program && this.program._enableTextures;
        }
        get uniforms() {
          const V = this.program;
          if (!V || !V.uniforms)
            throw Error("No avaliable program.");
          return V.uniforms;
        }
        deleteProgram(V) {
          const W = this.gl;
          this.program === V && (this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID), W.useProgram(null));
          const y = this.programs.indexOf(V);
          y >= 0 && this.programs.splice(y, 1), L(W, V), W.deleteProgram(V);
        }
        /**
          [{
            positions: ...
            cells: ...
            textureCoord: ...
            attributes: {name: {data:..., normalize: true}},
            uniforms: ...
          }]
         */
        setMeshData(V) {
          Array.isArray(V) || (V = [V]);
          const W = this.program;
          W.meshData = V.map(({
            mode: y,
            positions: t,
            instanceCount: e,
            cells: Z,
            cellsCount: a,
            attributes: x,
            uniforms: K,
            textureCoord: C,
            enableBlend: T
          }) => {
            const I = {
              positions: p.FLOAT(t),
              uniforms: K,
              enableBlend: !!T,
              textureCoord: p.FLOAT(C)
            };
            if (Z && (I.cells = p.USHORT(Z), I.cellsCount = a || I.cells.length), y != null && (I.mode = y), e != null) {
              if (!this.isWebGL2 && !this.aia_ext)
                throw new Error("Cannot use instanceCount in this rendering context, use webgl2 context instead.");
              I.instanceCount = e;
            }
            if (x) {
              const J = {};
              Object.entries(x).forEach(([F, R]) => {
                if (!W._attribute[F])
                  W._attribute[F] = "ignored";
                else if (W._attribute[F] !== "ignored") {
                  const {
                    name: S,
                    type: N
                  } = W._attribute[F];
                  let Q = R.data || R;
                  if (Array.isArray(Q) && (Q = p[N](Q)), J[F] = {
                    name: S,
                    data: Q
                  }, R.divisor != null) {
                    if (!this.isWebGL2 && !this.aia_ext)
                      throw new Error("Cannot use divisor in this rendering context, use webgl2 context instead.");
                    J[F].divisor = R.divisor;
                  }
                }
              }), I.attributes = J;
            }
            return I;
          }), this.options.autoUpdate && this.update();
        }
        createProgram(V, W) {
          const y = /^\s*uniform\s+sampler/mg.test(V);
          V == null && (V = c.default), W == null && (W = y ? m.default : s.default);
          const t = this.gl, e = Object(i.createProgram)(t, W, V);
          e.shaderText = {
            vertexShader: W,
            fragmentShader: V
          }, e._buffers = {}, e._attribute = {}, e.uniforms = {}, e._samplerMap = {}, e._bindTextures = [];
          const Z = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexPosition}`, "im");
          let a = W.match(Z);
          a && (e._dimension = Number(a[1]));
          const x = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexTextureCoord}`, "im");
          a = W.match(x), a && (e._texCoordSize = Number(a[1]));
          const K = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/gim;
          if (a = W.match(K), a)
            for (let I = 0; I < a.length; I++) {
              const J = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/im, F = a[I].match(J);
              if (F && F[3] !== this.options.vertexPosition && F[3] !== this.options.vertexTextureCoord) {
                let [, R, S, N] = F;
                R === "mat" && (S **= 2), e._buffers[N] = t.createBuffer(), e._attribute[N] = {
                  name: N,
                  type: R,
                  size: Number(S) || 1
                };
              }
            }
          const C = /^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/mg;
          a = W.match(C) || [], a = a.concat(V.match(C) || []), a.forEach((I) => {
            const J = I.match(/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/);
            let [F, R, S] = J.slice(1);
            F = h[F], S = !!S, F.indexOf("Matrix") !== 0 && S && (F += "v"), this._declareUniform(e, R, F);
          }), e._buffers.verticesBuffer = t.createBuffer(), e._buffers.cellsBuffer = t.createBuffer();
          const T = t.getAttribLocation(e, this.options.vertexTextureCoord);
          return e._enableTextures = T >= 0, e._enableTextures && (e._buffers.texCoordBuffer = t.createBuffer()), this.programs.push(e), e;
        }
        useProgram(V, W = {}) {
          this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID);
          const y = this.gl;
          y.useProgram(V);
          const t = V._dimension;
          y.bindBuffer(y.ARRAY_BUFFER, V._buffers.verticesBuffer);
          const e = y.getAttribLocation(V, this.options.vertexPosition);
          if (y.vertexAttribPointer(e, t, y.FLOAT, !1, 0, 0), y.enableVertexAttribArray(e), V._enableTextures) {
            y.bindBuffer(y.ARRAY_BUFFER, V._buffers.texCoordBuffer);
            const Z = y.getAttribLocation(V, this.options.vertexTextureCoord);
            y.vertexAttribPointer(Z, V._texCoordSize || 2, y.FLOAT, !1, 0, 0), y.enableVertexAttribArray(Z);
          }
          if (Object.entries(V._attribute).forEach(([Z, a]) => {
            if (a !== "ignored") {
              const x = a.size, K = W[Z] || {}, C = !!K.normalize;
              let T = K.type || "FLOAT";
              const I = K.key || Z;
              T === "UBYTE" && (T = "UNSIGNED_BYTE"), T === "USHORT" && (T = "UNSIGNED_SHORT"), a.type = T, I && I !== Z && (V._attribute[I] = a), y.bindBuffer(y.ARRAY_BUFFER, V._buffers[Z]);
              const J = y.getAttribLocation(V, Z);
              J >= 0 && (y.vertexAttribPointer(J, x, y[T], C, 0, 0), y.enableVertexAttribArray(J));
            }
          }), !V.meshData) {
            const Z = [[-1, -1, 0, 1].slice(0, t), [1, -1, 0, 1].slice(0, t), [1, 1, 0, 1].slice(0, t), [-1, 1, 0, 1].slice(0, t)], a = [[0, 1, 3], [3, 1, 2]];
            this.setMeshData({
              positions: Z,
              cells: a
            });
          }
          return V;
        }
        compileSync(V, W) {
          V = V || c.default;
          const y = {};
          function t(x) {
            x = x.replace(/^\s*/mg, "");
            const K = [], C = x.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let T = 0; T < C.length; T++) {
                const J = C[T].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const F = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let R = J[1];
                  if (R === "graph" && (R = "graphics"), y[R])
                    K.push(`/* included ${R} */`);
                  else if (y[R] = !0, F === "lib") {
                    const S = t(X[R]);
                    K.push(S);
                  } else if (F === "link")
                    throw new Error("Cannot load external links synchronously. Use compile instead of compileSync.");
                }
              }
              K.forEach((T) => {
                x = x.replace(/^#pragma\s+include\s+.*/m, T);
              });
            }
            return x;
          }
          const e = t(V), Z = W ? t(W) : null;
          return this.createProgram(e, Z);
        }
        async compile(V, W) {
          V = V || c.default;
          const y = {};
          async function t(x) {
            x = x.replace(/^\s*/mg, "");
            const K = [], C = x.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let T = 0; T < C.length; T++) {
                const J = C[T].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const F = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let R = J[1];
                  if (R === "graph" && (R = "graphics"), y[R])
                    K.push(`/* included ${R} */`);
                  else if (y[R] = !0, F === "lib") {
                    const S = await t(X[R]);
                    K.push(S);
                  } else if (F === "link") {
                    let S = await p.fetchShader(R);
                    S = await t(S), K.push(S);
                  }
                }
              }
              K.forEach((T) => {
                x = x.replace(/^#pragma\s+include\s+.*/m, T);
              });
            }
            return x;
          }
          const e = await t(V), Z = W ? await t(W) : null;
          return this.createProgram(e, Z);
        }
        async load(V, W = null) {
          return V = await p.fetchShader(V), W && (W = await p.fetchShader(W)), this.compile(V, W);
        }
        createTexture(V = null, {
          wrapS: W = this.gl.CLAMP_TO_EDGE,
          wrapT: y = this.gl.CLAMP_TO_EDGE,
          minFilter: t = this.gl.LINEAR,
          magFilter: e = this.gl.LINEAR
        } = {}) {
          const Z = this.gl, a = Array.isArray(V) ? Z.TEXTURE_CUBE_MAP : Z.TEXTURE_2D;
          this._max_texture_image_units = this._max_texture_image_units || Z.getParameter(Z.MAX_COMBINED_TEXTURE_IMAGE_UNITS), Z.activeTexture(Z.TEXTURE0 + this._max_texture_image_units - 1);
          const x = Z.createTexture();
          Z.bindTexture(a, x), Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL, !0);
          const {
            width: K,
            height: C
          } = this.canvas;
          if (V)
            if (a === Z.TEXTURE_CUBE_MAP)
              for (let T = 0; T < 6; T++)
                Z.texImage2D(Z.TEXTURE_CUBE_MAP_POSITIVE_X + T, 0, Z.RGBA, Z.RGBA, Z.UNSIGNED_BYTE, V[T]);
            else
              Z.texImage2D(a, 0, Z.RGBA, Z.RGBA, Z.UNSIGNED_BYTE, V);
          else if (a === Z.TEXTURE_CUBE_MAP)
            for (let T = 0; T < 6; T++)
              this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + T, 0, Z.RGBA, K, C, 0, Z.RGBA, Z.UNSIGNED_BYTE, null);
          else
            Z.texImage2D(a, 0, Z.RGBA, K, C, 0, Z.RGBA, Z.UNSIGNED_BYTE, null);
          return Z.texParameteri(a, Z.TEXTURE_MIN_FILTER, t), Z.texParameteri(a, Z.TEXTURE_MAG_FILTER, e), Z.texParameteri(a, Z.TEXTURE_WRAP_S, W), Z.texParameteri(a, Z.TEXTURE_WRAP_T, y), a === Z.TEXTURE_CUBE_MAP && (V.width = V[0].width, V.height = V[0].height), Z.bindTexture(a, null), x._img = V || {
            width: K,
            height: C
          }, x.delete = () => {
            this.deleteTexture(x);
          }, x;
        }
        deleteTexture(V) {
          const W = V._img;
          this.gl.deleteTexture(V), typeof W.close == "function" && W.close();
        }
        async loadTexture(V, {
          useImageBitmap: W = !0
        } = {}) {
          const y = await p.loadImage(V, {
            useImageBitmap: W
          });
          return this.createTexture(y);
        }
        createFBO({
          color: V = 1,
          blend: W = !1,
          depth: y = this.options.depth !== !1,
          stencil: t = !!this.options.stencil
        } = {}) {
          const e = this.gl, Z = e.createFramebuffer();
          e.bindFramebuffer(e.FRAMEBUFFER, Z);
          const a = [];
          for (let C = 0; C < V; C++) {
            const T = this.createTexture();
            e.framebufferTexture2D(
              e.FRAMEBUFFER,
              e.COLOR_ATTACHMENT0 + C,
              e.TEXTURE_2D,
              T,
              0
              /* level */
            ), a.push(T);
          }
          Z.textures = a, Z.texture = a[0], Z.blend = W;
          const {
            width: x,
            height: K
          } = this.canvas;
          return y && !t && (Z.depthBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, Z.depthBuffer), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, x, K), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, Z.depthBuffer)), t && !y && (Z.stencilBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, Z.stencilBuffer), e.renderbufferStorage(e.RENDERBUFFER, e.STENCIL_INDEX8, x, K), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.STENCIL_ATTACHMENT, e.RENDERBUFFER, Z.stencilBuffer)), y && t && (Z.depthStencilBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, Z.depthStencilBuffer), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, x, K), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, Z.depthStencilBuffer)), e.bindFramebuffer(e.FRAMEBUFFER, null), Z;
        }
        bindFBO(V = null) {
          this.fbo = V;
        }
        render({
          clearBuffer: V = !0
        } = {}) {
          this.startRender = !0;
          const W = this.gl;
          let y = this.program;
          y || (y = this.createProgram(), this.useProgram(y)), this.fbo && W.bindFramebuffer(W.FRAMEBUFFER, this.fbo);
          const t = this.options.depth;
          t && W.enable(W.DEPTH_TEST), this.gl.clear(this.gl.COLOR_BUFFER_BIT | (t ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.options.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));
          const e = this._renderFrameID;
          this._draw(), this.fbo && W.bindFramebuffer(W.FRAMEBUFFER, null), this._renderFrameID === e && (this._renderFrameID = null);
        }
        update() {
          this.startRender && this._renderFrameID == null && (this._renderFrameID = requestAnimationFrame(this.render.bind(this)));
        }
      }
      n(p, "defaultOptions", {
        preserveDrawingBuffer: !0,
        autoUpdate: !0,
        vertexPosition: "a_vertexPosition",
        vertexTextureCoord: "a_vertexTextureCoord",
        webgl2: !1
      }), n(p, "UBYTE", p.UNSIGNED_BYTE), n(p, "USHORT", p.UNSIGNED_SHORT), n(p, "fetchShader", i.fetchShader), n(p, "loadImage", i.loadImage);
    },
    /* 16 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "setupWebGL", function() {
        return s;
      }), l.d(d, "createProgram", function() {
        return c;
      }), l.d(d, "pointsToBuffer", function() {
        return m;
      }), l.d(d, "loadImage", function() {
        return X;
      }), l.d(d, "fetchShader", function() {
        return L;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(o, h) {
        const p = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        let r = null;
        for (let V = 0; V < p.length; ++V) {
          try {
            r = o.getContext(p[V], h);
          } catch {
          }
          if (r)
            break;
        }
        return r;
      }
      function s(o, h) {
        const p = i(o, h);
        if (!p)
          throw new Error("Sorry, your browser doesn't support WebGL.");
        return p;
      }
      function c(o, h, p) {
        const r = o.createShader(o.VERTEX_SHADER);
        if (o.shaderSource(r, h), o.compileShader(r), !o.getShaderParameter(r, o.COMPILE_STATUS)) {
          const y = `Vertex shader failed to compile.  The error log is:${o.getShaderInfoLog(r)}`;
          throw new Error(y);
        }
        const V = o.createShader(o.FRAGMENT_SHADER);
        if (o.shaderSource(V, p), o.compileShader(V), !o.getShaderParameter(V, o.COMPILE_STATUS)) {
          const y = `Fragment shader failed to compile.  The error log is:${o.getShaderInfoLog(V)}`;
          throw new Error(y);
        }
        const W = o.createProgram();
        if (o.attachShader(W, r), o.attachShader(W, V), o.linkProgram(W), !o.getProgramParameter(W, o.LINK_STATUS)) {
          const y = `Shader program failed to link.  The error log is:${o.getProgramInfoLog(W)}`;
          throw new Error(y);
        }
        return o.deleteShader(r), o.deleteShader(V), W;
      }
      function m(o, h = Float32Array, p = null) {
        if (p && !(p instanceof h))
          throw new TypeError("Wrong buffer type.");
        if (o == null || o instanceof h)
          return o;
        if (o[0] == null || o[0].length == null)
          return p ? (p.set(o, 0), p) : new h(o);
        const r = o[0].length, V = o.length;
        p || (p = new h(r * V));
        let W = 0;
        for (let y = 0; y < V; y++)
          for (let t = 0; t < r; t++)
            p[W++] = o[y][t];
        return p;
      }
      const n = {};
      function X(o, {
        useImageBitmap: h = !0,
        alias: p = null
      } = {}) {
        if (!n[o]) {
          if (typeof Image == "function") {
            const r = new Image();
            typeof o == "string" && !(typeof location == "object" && /^file:/.test(location.href)) && !/^data:/.test(o) && (r.crossOrigin = "anonymous"), n[o] = new Promise((V) => {
              r.onload = function() {
                h && typeof createImageBitmap == "function" ? createImageBitmap(r, {
                  imageOrientation: "flipY"
                }).then((W) => {
                  n[o] = W, p && (n[p] = W), V(W);
                }) : (n[o] = r, p && (n[p] = r), V(r));
              }, r.src = o;
            }), p && (n[p] = n[o]);
          } else if (typeof fetch == "function")
            return fetch(o, {
              method: "GET",
              mode: "cors",
              cache: "default"
            }).then((r) => r.blob()).then((r) => createImageBitmap(r, {
              imageOrientation: "flipY"
            }).then((V) => (n[o] = V, p && (n[p] = V), V)));
        }
        return n[o];
      }
      const G = {};
      async function L(o) {
        if (G[o])
          return G[o];
        const h = await fetch(o);
        if (h.status >= 200 && h.status < 300) {
          const p = await h.text();
          return G[o] = p, p;
        }
        throw new Error("Shader loaded error.");
      }
    },
    /* 17 */
    /***/
    function(b, d, l) {
      l.r(d), d.default = `attribute vec3 a_vertexPosition;

void main() {
  gl_PointSize = 1.0;
  gl_Position = vec4(a_vertexPosition, 1);
}`;
    },
    /* 18 */
    /***/
    function(b, d, l) {
      l.r(d), d.default = `#ifdef GL_ES
precision mediump float;
#endif

void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
}`;
    },
    /* 19 */
    /***/
    function(b, d, l) {
      l.r(d), d.default = `attribute vec4 a_vertexPosition;
attribute vec2 a_vertexTextureCoord;
varying vec2 vTextureCoord;

void main() {
  gl_PointSize = 1.0;
  gl_Position = a_vertexPosition;
  vTextureCoord = a_vertexTextureCoord;
}`;
    },
    /* 20 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return m;
      });
      var i = l(21), s = l(25);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol("transform");
      class m {
        constructor(X, G) {
          this.context = X.getContext("2d"), this.options = G, this[c] = [1, 0, 0, 1, 0, 0];
        }
        createTexture(X) {
          return {
            _img: X
          };
        }
        async loadTexture(X) {
          const G = await i.default.loadImage(X, {
            useImageBitmap: !1
          });
          return this.createTexture(G);
        }
        deleteTexture(X) {
          return X;
        }
        clear(X, G, L, o) {
          const h = this.context;
          X = X || 0, G = G || 0, L = L || h.canvas.width - X, o = o || h.canvas.height - G, h.clearRect(X, G, L, o);
        }
        drawMeshCloud(X, {
          clear: G = !1
        } = {}) {
          const L = [];
          for (let o = 0; o < X.amount; o++) {
            const h = X.getTransform(o);
            let p = X.getTextureFrame(o);
            p && (p = p._img);
            const r = X.getFilter(o), {
              fill: V,
              stroke: W
            } = X.getCloudRGBA(o);
            L.push({
              mesh: X.mesh,
              _cloudOptions: [V, W, p, h, r]
            });
          }
          X.beforeRender && X.beforeRender(this.context, X), this.drawMeshes(L, {
            clear: G,
            hook: !1
          }), X.afterRender && X.afterRender(this.context, X);
        }
        drawMeshes(X, {
          clear: G = !1,
          hook: L = !0
        } = {}) {
          const o = this.context;
          G && o.clearRect(0, 0, o.canvas.width, o.canvas.height);
          let h = null;
          const {
            width: p,
            height: r
          } = o.canvas, V = X.length;
          X.forEach((W, y) => {
            let t, e, Z, a, x;
            L && W.beforeRender && W.beforeRender(o, W), W._cloudOptions && ([t, e, Z, a, x] = W._cloudOptions, W = W.mesh);
            let K = W.filter;
            if (x && (K = K ? `${K} ${x}` : x), K && !this.filterBuffer && this.filterBuffer !== !1) {
              const C = i.default.createCanvas(p, r);
              C ? this.filterBuffer = C.getContext("2d") : this.filterBuffer = !1;
            }
            h && h !== K && (Object(s.applyFilter)(this.filterBuffer, h), o.drawImage(this.filterBuffer.canvas, 0, 0, p, r), this.filterBuffer.clearRect(0, 0, p, r), h = null), K && this.filterBuffer ? (this.filterBuffer.save(), this.filterBuffer.transform(...this[c]), Object(s.drawMesh2D)(W, this.filterBuffer, !1, t, e, Z, a), this.filterBuffer.restore(), y === V - 1 ? (Object(s.applyFilter)(this.filterBuffer, K), o.drawImage(this.filterBuffer.canvas, 0, 0, p, r), this.filterBuffer.clearRect(0, 0, p, r)) : h = K) : (o.save(), o.transform(...this[c]), Object(s.drawMesh2D)(W, o, !1, t, e, Z, a), o.restore()), L && W.afterRender && W.afterRender(o, W);
          });
        }
        setTransform(X) {
          this[c] = X;
        }
      }
    },
    /* 21 */
    /***/
    function(b, d, l) {
      l.r(d), (function(i) {
        var s = l(14), c = l(23), m = l(24);
        l(1).glMatrix.setMatrixArrayType(Array);
        const n = {};
        function X(p, r) {
          const {
            style: V,
            variant: W,
            weight: y,
            stretch: t,
            size: e,
            pxLineHeight: Z,
            family: a
          } = p;
          return t === "normal" ? `${V} ${W} ${y} ${e * r}px/${Z * r}px ${a}` : `${V} ${W} ${y} ${t} ${e * r}px/${Z * r}px ${a}`;
        }
        function G(p, {
          font: r,
          fillColor: V,
          strokeColor: W,
          strokeWidth: y,
          ratio: t = 1,
          textCanvas: e,
          cachable: Z = !1
        }) {
          let a;
          if (Z) {
            a = [p, r, String(V), String(W), String(y)].join("###");
            const Q = n[a];
            if (Q)
              return Q;
          }
          e || (e = o(1, 1));
          const x = e.getContext("2d");
          x.save(), x.font = r;
          let {
            width: K
          } = x.measureText(p);
          x.restore();
          const C = Object(c.default)(r), T = Math.max(C.pxLineHeight, C.pxHeight * 1.13);
          /italic|oblique/.test(r) && (K += T * Math.tan(15 * Math.PI / 180)), !V && !W && (V = "#000");
          const I = x.canvas, J = Math.ceil(K), F = Math.ceil(T);
          I.width = Math.round(J * t), I.height = Math.round(F * t), x.save(), x.font = X(C, t), x.textAlign = "center", x.textBaseline = "middle";
          const R = I.height * 0.5 + C.pxHeight * 0.05 * t, S = I.width * 0.5;
          if (V) {
            if (Array.isArray(V))
              V = Object(m.default)(V);
            else if (V.vector) {
              let Q;
              const {
                vector: P,
                colors: j
              } = V;
              P.length === 6 ? Q = x.createRadialGradient(...P) : Q = x.createLinearGradient(...P), j.forEach(({
                offset: D,
                color: z
              }) => {
                Q.addColorStop(D, z);
              }), V = Q;
            }
            x.fillStyle = V, x.fillText(p, S, R);
          }
          if (W) {
            if (x.lineWidth = y * t, Array.isArray(W))
              W = Object(m.default)(W);
            else if (W.vector) {
              let Q;
              const {
                vector: P,
                colors: j
              } = W;
              P.length === 6 ? Q = x.createRadialGradient(...P) : Q = x.createLinearGradient(...P), j.forEach(({
                offset: D,
                color: z
              }) => {
                Q.addColorStop(D, z);
              }), W = Q;
            }
            x.strokeStyle = W, x.strokeText(p, S, R);
          }
          x.restore();
          const N = {
            image: e,
            rect: [0, 0, J, F]
          };
          return Z && (n[a] = N), N;
        }
        let L = !1;
        if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
          const p = navigator.userAgent.toLowerCase().match(/chrome\/(\d+)/);
          p && (L = Number(p[1]) < 70);
        }
        function o(p, r, V = {}) {
          const W = V.offscreen || !L && V.offscreen !== !1;
          let y;
          return typeof i < "u" && typeof i.createCanvas == "function" ? y = i.createCanvas(p, r, V) : W && typeof OffscreenCanvas == "function" ? y = new OffscreenCanvas(p, r) : (y = document.createElement("canvas"), y.width = p, y.height = r), y;
        }
        const h = {
          createCanvas: o,
          createText: G,
          loadImage: s.default.loadImage
        };
        d.default = h;
      }).call(this, l(22));
    },
    /* 22 */
    /***/
    function(b, d) {
      var l;
      l = /* @__PURE__ */ function() {
        return this;
      }();
      try {
        l = l || new Function("return this")();
      } catch {
        typeof window == "object" && (l = window);
      }
      b.exports = l;
    },
    /* 23 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return V;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(W, y) {
        if (typeof W == "string") {
          const Z = W.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%)$/);
          Z ? W = {
            size: parseFloat(Z[1]),
            unit: Z[2]
          } : W = {
            size: parseInt(W, 10),
            unit: "px"
          };
        }
        let {
          size: t,
          unit: e
        } = W;
        if (e === "pt")
          t /= 0.75;
        else if (e === "pc")
          t *= 16;
        else if (e === "in")
          t *= 96;
        else if (e === "cm")
          t *= 96 / 2.54;
        else if (e === "mm")
          t *= 96 / 25.4;
        else if (e === "em" || e === "rem" || e === "ex") {
          if (!y && typeof getComputedStyle == "function" && typeof document < "u") {
            const Z = getComputedStyle(document.documentElement).fontSize;
            y = i(Z, 16);
          }
          t *= y, e === "ex" && (t /= 2);
        } else if (e === "q")
          t *= 96 / 25.4 / 4;
        else if (e === "vw" || e === "vh") {
          if (typeof document < "u") {
            const Z = e === "vw" ? document.documentElement.clientWidth : document.documentElement.clientHeight;
            t *= Z / 100;
          }
        } else if ((e === "vmax" || e === "vmin") && typeof document < "u") {
          const Z = document.documentElement.clientWidth, a = document.documentElement.clientHeight;
          e === "vmax" ? t *= Math.max(Z, a) / 100 : t *= Math.min(Z, a) / 100;
        }
        return t;
      }
      const s = "bold|bolder|lighter|[1-9]00", c = "italic|oblique", m = "small-caps", n = "ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded", X = "px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%", G = `'([^']+)'|"([^"]+)"|([\\w-]|[一-龥])+`, L = new RegExp(`(${s}) +`, "i"), o = new RegExp(`(${c}) +`, "i"), h = new RegExp(`(${m}) +`, "i"), p = new RegExp(`(${n}) +`, "i"), r = new RegExp("([\\d\\.]+)(" + X + ")(?:\\/([\\d\\.]+)(" + X + "))? *((?:" + G + ")( *, *(?:" + G + "))*)");
      function V(W, y) {
        const t = r.exec(W);
        if (!t)
          return;
        const e = parseFloat(t[3]), Z = {
          weight: "normal",
          style: "normal",
          stretch: "normal",
          variant: "normal",
          size: parseFloat(t[1]),
          unit: t[2],
          lineHeight: Number.isFinite(e) ? e : void 0,
          lineHeightUnit: t[4],
          family: t[5].replace(/ *, */g, ",")
        }, a = W.substring(0, t.index), x = L.exec(a), K = o.exec(a), C = h.exec(a), T = p.exec(a);
        return x && (Z.weight = x[1]), K && (Z.style = K[1]), C && (Z.variant = C[1]), T && (Z.stretch = T[1]), Z.pxHeight = i({
          size: Z.size,
          unit: Z.unit
        }, y), Z.pxLineHeight = i({
          size: Z.lineHeight || Z.size,
          unit: Z.lineHeightUnit || Z.unit
        }, y), Z;
      }
    },
    /* 24 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return i;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(s) {
        return `rgba(${s.map((c, m) => m < 3 ? Math.round(c * 255) : c).join()})`;
      }
    },
    /* 25 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "applyFilter", function() {
        return n;
      }), l.d(d, "drawMesh2D", function() {
        return G;
      });
      var i = l(1), s = l(24), c = l(23), m = l(26);
      l(1).glMatrix.setMatrixArrayType(Array);
      function n(L, o) {
        const h = L.canvas;
        L.save(), L.filter = o, L.drawImage(h, 0, 0, h.width, h.height), L.restore();
      }
      function X(L, o) {
        const h = /rgba\((\d+),(\d+),(\d+),(\d+)\)/;
        L = L.match(h).slice(1, 5).map(Number), o = o.match(h).slice(1, 5).map(Number);
        const p = [], r = o[3];
        for (let V = 0; V < 4; V++)
          p[V] = Object(m.mix)(L[V], o[V], r);
        return `rgba(${p.join()})`;
      }
      function G(L, o, h = !0, p = null, r = null, V = null, W = null) {
        o.save();
        let y = !1, t = !1;
        if (o.globalAlpha = L.getOpacity(), L._updateMatrix && L.transformScale / L.contours.scale > 1.5 && L.accurate(L.transformScale), L.lineWidth) {
          let a = L.gradient && L.gradient.stroke;
          if (a) {
            const {
              vector: x,
              colors: K
            } = a;
            if (x.length === 6)
              a = o.createRadialGradient(...x);
            else if (x.length === 4)
              a = o.createLinearGradient(...x);
            else if (x.length === 3)
              a = o.createCircularGradient(...x);
            else
              throw new TypeError("Invalid vector dimension.");
            K.forEach(({
              offset: C,
              color: T
            }) => {
              let I = Object(s.default)(T);
              r && (I = X(I, r)), a.addColorStop(C, I);
            }), o.strokeStyle = a, y = !0;
          } else
            L.strokeStyle && (r ? o.strokeStyle = X(L.strokeStyle, r) : o.strokeStyle = L.strokeStyle, y = !0);
        }
        y && (o.lineWidth = L.lineWidth, o.lineJoin = L.lineJoin, o.lineCap = L.lineCap, o.miterLimit = L.miterLimit, L.lineDash && (o.setLineDash(L.lineDash), L.lineDashOffset && (o.lineDashOffset = L.lineDashOffset)));
        let e = L.gradient && L.gradient.fill;
        if (e) {
          const {
            vector: a,
            colors: x
          } = e;
          if (a.length === 6)
            e = o.createRadialGradient(...a);
          else if (a.length === 4)
            e = o.createLinearGradient(...a);
          else if (a.length === 3)
            e = o.createCircularGradient(...a);
          else
            throw new TypeError("Invalid vector dimension.");
          x.forEach(({
            offset: K,
            color: C
          }) => {
            let T = Object(s.default)(C);
            r && (T = X(T, r)), e.addColorStop(K, T);
          }), o.fillStyle = e, t = !0;
        } else
          L.fillStyle && (p ? o.fillStyle = X(L.fillStyle, p) : o.fillStyle = L.fillStyle, t = !0);
        if (W && o.transform(...W), o.transform(...L.transformMatrix), L.clipPath) {
          const a = L.clipPath, x = new Path2D(a);
          o.clip(x);
        }
        const Z = L.contours.length;
        if (L.contours.forEach((a, x) => {
          const K = a.length, C = K > 1 && i.vec2.equals(a[0], a[K - 1]), T = x === Z - 1 && L.texture;
          if (a && K > 0) {
            if (t || y || T) {
              o.beginPath(), o.moveTo(...a[0]);
              for (let I = 1; I < K; I++)
                I === K - 1 && C ? o.closePath() : o.lineTo(...a[I]);
            }
            if (t && o.fill(L.fillRule), T) {
              o.save(), o.clip();
              let {
                image: I,
                options: J
              } = L.texture;
              if (V && (I = V), J.repeat && console.warn("Context 2D not supported image repeat yet."), I.font) {
                J.scale && console.warn("Context 2D not supported text scale yet."), J.srcRect && console.warn("Context 2D not supported text srcRect yet.");
                let {
                  font: F,
                  fillColor: R,
                  strokeColor: S,
                  strokeWidth: N,
                  text: Q
                } = I;
                !R && !S && (R = "#000"), Array.isArray(R) && (R = Object(s.default)(R)), Array.isArray(S) && (S = Object(s.default)(S)), o.font = F;
                const {
                  width: P
                } = o.measureText(Q), j = Object(c.default)(F), D = Math.max(j.pxLineHeight, j.pxHeight * 1.13);
                o.textAlign = "center", o.textBaseline = "middle";
                const z = J.rect, w = z[0] + D * 0.5 + j.pxHeight * 0.06, A = z[1] + P * 0.5;
                z[2] != null && o.scale(z[2] / P, z[3] / D), R && (o.fillStyle = R, o.fillText(Q, A, w)), S && (o.lineWidth = N, o.strokeStyle = S, o.strokeText(Q, A, w));
              } else {
                let F = J.rect;
                const R = J.srcRect;
                J.scale && (F = [0, 0, o.canvas.width, o.canvas.height]), J.rotated && F && (F = [-F[1], F[0], F[3], F[2]]), R && (F = F || [0, 0, R[2], R[3]]), J.rotated && (o.translate(0, F ? F[2] : I.width), o.rotate(-0.5 * Math.PI)), R ? o.drawImage(I, ...R, ...F) : F ? o.drawImage(I, ...F) : o.drawImage(I, 0, 0);
              }
              o.restore();
            }
            y && o.stroke();
          }
        }), o.restore(), h) {
          const a = L.filter;
          a && n(o, a);
        }
      }
    },
    /* 26 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "clamp", function() {
        return i;
      }), l.d(d, "mix", function() {
        return s;
      }), l.d(d, "transformPoint", function() {
        return c;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(m, n, X) {
        return n > X && ([n, X] = [X, n]), m < n ? n : m > X ? X : m;
      }
      function s(m, n, X) {
        return m * (1 - X) + n * X;
      }
      function c(m, n) {
        const [X, G] = m;
        return [X * n[0] + G * n[2] + n[4], X * n[1] + G * n[3] + n[5]];
      }
    },
    /* 27 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return X;
      });
      var i = l(28), s = l(29);
      l(1).glMatrix.setMatrixArrayType(Array);
      function c(G, L, o) {
        const h = G.uniforms || {}, p = L.uniforms || {};
        if (h.u_texSampler && p.u_texSampler && h.u_texSampler !== p.u_texSampler)
          return !1;
        const r = Object.keys(h), V = Object.keys(p), W = r.indexOf("u_texSampler"), y = V.indexOf("u_texSampler");
        if (W >= 0 && r.splice(W, 1), y >= 0 && V.splice(y, 1), r.length !== V.length)
          return !1;
        const t = r.every((e) => {
          const Z = h[e], a = p[e];
          if (Z === a)
            return !0;
          if (Z.length && a.length && Z.length === a.length) {
            for (let x = 0; x < Z.length; x++)
              if (Z[x] !== a[x])
                return !1;
            return !0;
          }
          return !1;
        });
        if (t) {
          if (h.u_texSampler && !p.u_texSampler)
            L.setTexture(h.u_texSampler, {
              hidden: !0
            });
          else if (!h.u_texSampler && p.u_texSampler)
            for (let e = 0; e < o.length; e++)
              o[e].setTexture(p.u_texSampler, {
                hidden: !0
              });
        }
        return t;
      }
      const m = {};
      function n(G, L) {
        if (G.length) {
          const o = Object(i.default)(G, m);
          return o.enableBlend = L, G[0].filterCanvas && (o.filterCanvas = !0), o.packIndex = G[0].packIndex, o.packLength = G.length, o.beforeRender = G[0].beforeRender, o.pass = G[0].pass, o.afterRender = G[G.length - 1].afterRender, G.length = 0, o;
        }
      }
      function* X(G, L, o = !1) {
        const h = [], p = G.options.bufferSize;
        let r = 0, V = !1;
        for (let W = 0; W < L.length; W++) {
          const y = L[W];
          if (y instanceof s.default)
            h.length && (yield n(h, V)), r = 0, V = !1, yield y;
          else {
            const t = y.meshData;
            if (t.clipPath && !t.uniforms.u_clipSampler) {
              const Z = G.createTexture(t.clipPath);
              t.uniforms.u_clipSampler = Z;
            }
            let e = 0;
            if ((!o || !y.canIgnore()) && t && t.positions.length) {
              y.packIndex = W;
              const Z = y.filterCanvas;
              if (e = t.positions.length, Z || r + e > p)
                h.length && (yield n(h, V)), r = 0, V = !1;
              else if (r) {
                const a = h[h.length - 1];
                a && (a.filterCanvas || a.afterRender || y.beforeRender || a.pass.length || y.pass.length || a.program !== y.program || !c(a, y, h)) && (yield n(h, V), r = 0, V = !1);
              }
              h.push(y), V = V || y.enableBlend, r += e;
            }
            W === L.length - 1 && h.length && (yield n(h, V));
          }
        }
      }
    },
    /* 28 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return c;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const i = {
        UNSIGNED_BYTE: Uint8Array,
        UNSIGNED_SHORT: Uint16Array,
        BYTE: Int8Array,
        SHORT: Int16Array,
        FLOAT: Float32Array
      };
      function s(m, n) {
        let X = 0, G = 0, L = 0, o = 0, h = 0, p = 0, r = 0;
        const V = m[0].program;
        for (let W = 0; W < m.length; W++) {
          const y = m[W].meshData;
          if (y) {
            r += y.positions.length;
            const t = y.positions[0].length;
            X += y.positions.length * t, G += y.cells.length * 3, p += y.attributes.a_color.length * 4;
            const e = y.textureCoord;
            e && (L += e.length * e[0].length);
            const Z = y.attributes.a_sourceRect;
            Z && (o += Z.length * 4);
            const a = y.attributes.a_clipUV;
            a && (h += a.length * 2);
          }
        }
        if ((!n.positions || n.positions.length < X) && (n.positions = new Float32Array(X)), (!n.cells || n.cells.length < G) && (n.cells = new Uint16Array(G)), L && (!n.textureCoord || n.textureCoord.length < L) && (n.textureCoord = new Float32Array(L)), (!n.a_color || n.a_color.length < p) && (n.a_color = new Uint8Array(p)), o && (!n.a_sourceRect || n.a_sourceRect.length < o) && (n.a_sourceRect = new Float32Array(o)), h && (!n.a_clipUV || n.a_clipUV.length < h) && (n.a_clipUV = new Float32Array(h)), V) {
          const W = Object.entries(V._attribute), y = V._attribOpts || {};
          for (let t = 0; t < W.length; t++) {
            const [e, Z] = W[t];
            if (e !== "a_color" && e !== "a_sourceRect" && Z !== "ignored") {
              const a = y[e] ? y[e].type : "FLOAT", x = i[a], K = Z.size * r;
              (!n[e] || n[e].length < K) && (n[e] = new x(K));
            }
          }
        }
        return n;
      }
      function c(m, n) {
        let X = [], G = [], L = [], o = [], h = [], p = [], r = 0, V = 0;
        const W = m[0] ? m[0].uniforms || {} : {}, y = m[0] ? m[0].program : null;
        n && (s(m, n), G = n.cells, X = n.positions, L = n.textureCoord, o = n.a_color, h = n.a_sourceRect, p = n.a_clipUV);
        let t = !1, e = !1;
        const Z = {};
        for (let x = 0; x < m.length; x++) {
          let K = m[x];
          if (K) {
            if (K.meshData && (K = K.meshData), n) {
              const T = K.positions;
              for (let I = 0; I < T.length; I++) {
                const J = T[I], F = 3 * (r + I);
                for (let R = 0; R < J.length; R++)
                  X[F + R] = J[R];
              }
            } else
              X.push(...K.positions);
            const C = K.cells;
            for (let T = 0; T < C.length; T++) {
              const I = C[T];
              if (n) {
                const J = 3 * (V + T);
                G[J] = I[0] + r, G[J + 1] = I[1] + r, G[J + 2] = I[2] + r;
              } else
                G.push([I[0] + r, I[1] + r, I[2] + r]);
            }
            if (n) {
              const T = K.attributes.a_color;
              for (let I = 0; I < T.length; I++) {
                const J = T[I], F = 4 * (r + I);
                o[F] = J[0], o[F + 1] = J[1], o[F + 2] = J[2], o[F + 3] = J[3];
              }
            } else
              o.push(...K.attributes.a_color);
            if (K.attributes.a_sourceRect)
              if (t = !0, n) {
                const T = K.attributes.a_sourceRect;
                for (let I = 0; I < T.length; I++) {
                  const J = T[I], F = 4 * (r + I);
                  h[F] = J[0], h[F + 1] = J[1], h[F + 2] = J[2], h[F + 3] = J[3];
                }
              } else
                h.push(...K.attributes.a_sourceRect);
            if (K.attributes.a_clipUV)
              if (e = !0, n) {
                const T = K.attributes.a_clipUV;
                for (let I = 0; I < T.length; I++) {
                  const J = T[I], F = 2 * (r + I);
                  p[F] = J[0], p[F + 1] = J[1];
                }
              } else
                p.push(...K.attributes.a_clipUV);
            if (K.textureCoord)
              if (n) {
                const T = K.textureCoord;
                for (let I = 0; I < T.length; I++) {
                  const J = T[I], F = 3 * (r + I);
                  for (let R = 0; R < J.length; R++)
                    L[F + R] = J[R];
                }
              } else
                L.push(...K.textureCoord);
            if (y) {
              const T = Object.entries(y._attribute);
              for (let I = 0; I < T.length; I++) {
                const [J, F] = T[I];
                if (J !== "a_color" && J !== "a_sourceRect" && F !== "ignored")
                  if (Z[J] = [], n) {
                    Z[J] = n[J];
                    const R = K.attributes[J], S = R[0].length;
                    for (let N = 0; N < R.length; N++) {
                      const Q = R[N], P = S * (r + N);
                      for (let j = 0; j < Q.length; j++)
                        Z[J][P + j] = Q[j];
                    }
                  } else
                    Z[J].push(...K.attributes[J]);
              }
            }
            r += K.positions.length, V += K.cells.length;
          }
        }
        Z.a_color = o, t && h && h.length > 0 && (Z.a_sourceRect = h);
        const a = {
          positions: X,
          cells: G,
          attributes: Z,
          uniforms: W,
          cellsCount: V * 3,
          program: y
        };
        return L && L.length && (a.textureCoord = L), e && p.length > 0 && (Z.a_clipUV = p), a;
      }
    },
    /* 29 */
    /***/
    function(b, d, l) {
      l.r(d);
      var i = l(1), s = l(30), c = l(26), m = l(31);
      l(1).glMatrix.setMatrixArrayType(Array);
      function n(Z, a) {
        var x = Object.keys(Z);
        if (Object.getOwnPropertySymbols) {
          var K = Object.getOwnPropertySymbols(Z);
          a && (K = K.filter(function(C) {
            return Object.getOwnPropertyDescriptor(Z, C).enumerable;
          })), x.push.apply(x, K);
        }
        return x;
      }
      function X(Z) {
        for (var a = 1; a < arguments.length; a++) {
          var x = arguments[a] != null ? arguments[a] : {};
          a % 2 ? n(Object(x), !0).forEach(function(K) {
            G(Z, K, x[K]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Z, Object.getOwnPropertyDescriptors(x)) : n(Object(x)).forEach(function(K) {
            Object.defineProperty(Z, K, Object.getOwnPropertyDescriptor(x, K));
          });
        }
        return Z;
      }
      function G(Z, a, x) {
        return a in Z ? Object.defineProperty(Z, a, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : Z[a] = x, Z;
      }
      const L = Symbol("mesh"), o = Symbol("count"), h = Symbol("blend"), p = Symbol("filter"), r = Symbol("textures"), V = Symbol("textureOptions"), W = Symbol("cloudColor"), y = Symbol("cloudFilter"), t = Symbol("buffer");
      function e(Z, a = null) {
        const x = new Float32Array(3 * Z), K = new Float32Array(3 * Z), C = new Float32Array(4 * Z), T = new Float32Array(4 * Z), I = new Float32Array(4 * Z), J = new Float32Array(4 * Z), F = new Float32Array(4 * Z), R = new Uint8Array(Z), S = new Uint8Array(4 * Z), N = new Uint8Array(4 * Z);
        return a && (x.set(a.transform0, 0), K.set(a.transform1, 0), C.set(a.color0, 0), T.set(a.color1, 0), I.set(a.color2, 0), J.set(a.color3, 0), F.set(a.color4, 0), R.set(a.frameIndex, 0), S.set(a.fillColor, 0), N.set(a.strokeColor, 0)), {
          bufferSize: Z,
          transform0: x,
          transform1: K,
          color0: C,
          color1: T,
          color2: I,
          color3: J,
          color4: F,
          frameIndex: R,
          fillColor: S,
          strokeColor: N
        };
      }
      d.default = class {
        constructor(Z, a = 1, {
          buffer: x = 1e3
        } = {}) {
          x = Math.max(x, a), this[o] = a, this[L] = Z, this[t] = e(x), this[r] = [], this[p] = [], this[W] = !1, this[y] = !1, this[h] = !1, this.initBuffer();
        }
        initBuffer(Z = 0) {
          const a = this[o];
          for (let x = Z; x < a; x++)
            this[t].transform0.set([1, 0, 0], x * 3), this[t].transform1.set([0, 1, 0], x * 3), this[t].frameIndex.set([-1], x), this[t].fillColor.set([0, 0, 0, 0], x * 4), this[t].strokeColor.set([0, 0, 0, 0], x * 4), this.setColorTransform(x, null);
        }
        get bufferSize() {
          return this[t].bufferSize;
        }
        get mesh() {
          return this[L];
        }
        set mesh(Z) {
          this[L] = Z, this[r] && this.setTextureFrames(this[r], this[V]);
        }
        get hasCloudColor() {
          return this[W];
        }
        get hasCloudFilter() {
          return this[y];
        }
        _getFilter(Z) {
          return this[p][Z] = this[p][Z] || [], this[p][Z];
        }
        getFilter(Z) {
          return this._getFilter(Z).join(" ");
        }
        get enableBlend() {
          return this[L].enableBlend || this[h];
        }
        canIgnore() {
          return this[L].canIgnore();
        }
        delete(Z) {
          if (Z >= this[o] || Z < 0)
            throw new Error("Out of range.");
          const {
            transform0: a,
            transform1: x,
            color0: K,
            color1: C,
            color2: T,
            color3: I,
            color4: J,
            frameIndex: F,
            fillColor: R,
            strokeColor: S
          } = this[t];
          a.set(a.subarray(3 * (Z + 1)), 3 * Z), x.set(x.subarray(3 * (Z + 1)), 3 * Z), K.set(K.subarray(4 * (Z + 1)), 4 * Z), C.set(C.subarray(4 * (Z + 1)), 4 * Z), T.set(T.subarray(4 * (Z + 1)), 4 * Z), I.set(I.subarray(4 * (Z + 1)), 4 * Z), J.set(J.subarray(4 * (Z + 1)), 4 * Z), F.set(F.subarray(Z + 1), Z), R.set(R.subarray(4 * (Z + 1)), 4 * Z), S.set(S.subarray(4 * (Z + 1)), 4 * Z);
          for (const N in this[p])
            N === Z ? delete this[p][N] : N > Z && (this[p][N - 1] = this[p][N], delete this[p][N]);
          this[o]--;
        }
        setColorTransform(Z, a) {
          if (Z >= this[o] || Z < 0)
            throw new Error("Out of range.");
          Z *= 4;
          const {
            color0: x,
            color1: K,
            color2: C,
            color3: T,
            color4: I
          } = this[t];
          return a != null ? (x.set([a[0], a[5], a[10], a[15]], Z), K.set([a[1], a[6], a[11], a[16]], Z), C.set([a[2], a[7], a[12], a[17]], Z), T.set([a[3], a[8], a[13], a[18]], Z), I.set([a[4], a[9], a[14], a[19]], Z), this[h] = this[h] || a[18] < 1, this[y] = !0) : (x.set([1, 0, 0, 0], Z), K.set([0, 1, 0, 0], Z), C.set([0, 0, 1, 0], Z), T.set([0, 0, 0, 1], Z), I.set([0, 0, 0, 0], Z)), this;
        }
        getColorTransform(Z) {
          if (Z >= this[o] || Z < 0)
            throw new Error("Out of range.");
          Z *= 4;
          const {
            color0: a,
            color1: x,
            color2: K,
            color3: C,
            color4: T
          } = this[t];
          return [a[Z], x[Z], K[Z], C[Z], T[Z], a[Z + 1], x[Z + 1], K[Z + 1], C[Z + 1], T[Z + 1], a[Z + 2], x[Z + 2], K[Z + 2], C[Z + 2], T[Z + 2], a[Z + 3], x[Z + 3], K[Z + 3], C[Z + 3], T[Z + 3]];
        }
        transformColor(Z, a) {
          let x = this.getColorTransform(Z);
          return x = Object(s.multiply)(x, a), this.setColorTransform(Z, x), this;
        }
        setFillColor(Z, a) {
          if (Z >= this[o] || Z < 0)
            throw new Error("Out of range.");
          typeof a == "string" && (a = Object(m.default)(a)), a[3] > 0 && (this[W] = !0), this[t].fillColor.set(a.map((x) => Math.round(255 * x)), 4 * Z);
        }
        setStrokeColor(Z, a) {
          if (Z >= this[o] || Z < 0)
            throw new Error("Out of range.");
          typeof a == "string" && (a = Object(m.default)(a)), a[3] > 0 && (this[W] = !0), this[t].strokeColor.set(a.map((x) => Math.round(255 * x)), 4 * Z);
        }
        getCloudRGBA(Z) {
          if (Z >= this[o] || Z < 0)
            throw new Error("Out of range.");
          Z *= 4;
          const {
            fillColor: a,
            strokeColor: x
          } = this[t], K = [a[Z], a[Z + 1], a[Z + 2], a[Z + 3]], C = [x[Z], x[Z + 1], x[Z + 2], x[Z + 3]];
          return K[3] /= 255, C[3] /= 255, {
            fill: `rgba(${K.join()})`,
            stroke: `rgba(${C.join()})`
          };
        }
        grayscale(Z, a) {
          this.transformColor(Z, Object(s.grayscale)(a)), this._getFilter(Z).push(`grayscale(${100 * a}%)`);
        }
        brightness(Z, a) {
          this.transformColor(Z, Object(s.brightness)(a)), this._getFilter(Z).push(`brightness(${100 * a}%)`);
        }
        saturate(Z, a) {
          this.transformColor(Z, Object(s.saturate)(a)), this._getFilter(Z).push(`saturate(${100 * a}%)`);
        }
        contrast(Z, a) {
          this.transformColor(Z, Object(s.contrast)(a)), this._getFilter(Z).push(`contrast(${100 * a}%)`);
        }
        invert(Z, a) {
          this.transformColor(Z, Object(s.invert)(a)), this._getFilter(Z).push(`invert(${100 * a}%)`);
        }
        sepia(Z, a) {
          this.transformColor(Z, Object(s.sepia)(a)), this._getFilter(Z).push(`sepia(${100 * a}%)`);
        }
        opacity(Z, a) {
          this.transformColor(Z, Object(s.opacity)(a)), this._getFilter(Z).push(`opacity(${100 * a}%)`);
        }
        hueRotate(Z, a) {
          this.transformColor(Z, Object(s.hueRotate)(a)), this._getFilter(Z).push(`hue-rotate(${a}deg)`);
        }
        setTransform(Z, a) {
          if (Z >= this[o] || Z < 0)
            throw new Error("Out of range.");
          Z *= 3, a == null && (a = [1, 0, 0, 1, 0, 0]);
          const {
            transform0: x,
            transform1: K
          } = this[t];
          return x.set([a[0], a[2], a[4]], Z), K.set([a[1], a[3], a[5]], Z), this;
        }
        getTransform(Z) {
          if (Z >= this[o] || Z < 0)
            throw new Error("Out of range.");
          Z *= 3;
          const {
            transform0: a,
            transform1: x
          } = this[t];
          return [a[Z], x[Z], a[Z + 1], x[Z + 1], a[Z + 2], x[Z + 2]];
        }
        getTextureFrame(Z) {
          return this[r][this[t].frameIndex[Z]];
        }
        setTextureFrames(Z = [], a = {}) {
          if (Z.length > 12)
            throw new Error("Max frames exceed. Allow 12 frames.");
          Z.length && this[L].setTexture(Z[0], a), this[r] = Z, this[V] = a;
        }
        setFrameIndex(Z, a) {
          if (Z >= this[o] || Z < 0)
            throw new Error("Out of range.");
          const x = this[r].length;
          if (x <= 0)
            throw new Error("No frames");
          this[t].frameIndex[Z] = a % x;
        }
        get amount() {
          return this[o];
        }
        set amount(Z) {
          const a = this[o];
          Z !== a && (Z > this[t].bufferSize && (this[t] = e(Math.max(Z, this[t].bufferSize + 1e3), this[t])), this[o] = Z, Z > a && this.initBuffer(a));
        }
        get meshData() {
          const {
            attributes: Z,
            cells: a,
            positions: x,
            textureCoord: K,
            uniforms: C
          } = this[L].meshData, T = this[r], I = {
            attributes: X({}, Z),
            cells: a,
            positions: x,
            textureCoord: K,
            uniforms: X({}, C),
            instanceCount: this[o],
            enableBlend: this.enableBlend
          };
          T.length && T.forEach((w, A) => {
            I.uniforms[`u_texFrame${A}`] = w;
          });
          const {
            transform0: J,
            transform1: F,
            color0: R,
            color1: S,
            color2: N,
            color3: Q,
            color4: P,
            fillColor: j,
            strokeColor: D,
            frameIndex: z
          } = this[t];
          return this[L].uniforms.u_texSampler && (I.attributes.a_frameIndex = {
            data: z,
            divisor: 1
          }), I.attributes.a_transform0 = {
            data: J,
            divisor: 1
          }, I.attributes.a_transform1 = {
            data: F,
            divisor: 1
          }, I.attributes.a_colorCloud0 = {
            data: R,
            divisor: 1
          }, I.attributes.a_colorCloud1 = {
            data: S,
            divisor: 1
          }, I.attributes.a_colorCloud2 = {
            data: N,
            divisor: 1
          }, I.attributes.a_colorCloud3 = {
            data: Q,
            divisor: 1
          }, I.attributes.a_colorCloud4 = {
            data: P,
            divisor: 1
          }, this.hasCloudColor && (I.attributes.a_fillCloudColor = {
            data: j,
            divisor: 1
          }, I.attributes.a_strokeCloudColor = {
            data: D,
            divisor: 1
          }), I;
        }
        setProgram(Z) {
          this[L].setProgram(Z);
        }
        get program() {
          return this[L].program;
        }
        transform(Z, a) {
          const x = this.getTransform(Z);
          return a = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), x, a), this.setTransform(Z, a), this;
        }
        translate(Z, [a, x]) {
          let K = i.mat2d.create();
          return K = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), K, [a, x]), this.transform(Z, K);
        }
        rotate(Z, a, [x, K] = [0, 0]) {
          let C = i.mat2d.create();
          return C = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [x, K]), C = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), C, a), C = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [-x, -K]), this.transform(Z, C);
        }
        scale(Z, [a, x = a], [K, C] = [0, 0]) {
          let T = i.mat2d.create();
          return T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [K, C]), T = i.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), T, [a, x]), T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-K, -C]), this.transform(Z, T);
        }
        skew(Z, [a, x = a], [K, C] = [0, 0]) {
          let T = i.mat2d.create();
          return T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [K, C]), T = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), T, i.mat2d.fromValues(1, Math.tan(x), Math.tan(a), 1, 0, 0)), T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-K, -C]), this.transform(Z, T);
        }
        isPointCollision(Z, [a, x], K = "both") {
          const C = this.getTransform(Z), T = Object(c.transformPoint)([a, x], i.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C));
          return this[L].isPointCollision(...T, K);
        }
        isPointInFill(Z, [a, x]) {
          return this.isPointCollision(Z, [a, x], "fill");
        }
        isPointInStroke(Z, [a, x]) {
          return this.isPointCollision(Z, [a, x], "stroke");
        }
      };
    },
    /* 30 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "multiply", function() {
        return s;
      }), l.d(d, "grayscale", function() {
        return c;
      }), l.d(d, "brightness", function() {
        return m;
      }), l.d(d, "saturate", function() {
        return n;
      }), l.d(d, "contrast", function() {
        return X;
      }), l.d(d, "invert", function() {
        return G;
      }), l.d(d, "sepia", function() {
        return L;
      }), l.d(d, "opacity", function() {
        return o;
      }), l.d(d, "hueRotate", function() {
        return h;
      });
      var i = l(26);
      l(1).glMatrix.setMatrixArrayType(Array);
      function s(p, r) {
        const V = [], W = p[0], y = p[1], t = p[2], e = p[3], Z = p[4], a = p[5], x = p[6], K = p[7], C = p[8], T = p[9], I = p[10], J = p[11], F = p[12], R = p[13], S = p[14], N = p[15], Q = p[16], P = p[17], j = p[18], D = p[19];
        let z = r[0], w = r[1], A = r[2], ll = r[3], _ = r[4];
        return V[0] = z * W + w * a + A * I + ll * N, V[1] = z * y + w * x + A * J + ll * Q, V[2] = z * t + w * K + A * F + ll * P, V[3] = z * e + w * C + A * R + ll * j, V[4] = z * Z + w * T + A * S + ll * D + _, z = r[5], w = r[6], A = r[7], ll = r[8], _ = r[9], V[5] = z * W + w * a + A * I + ll * N, V[6] = z * y + w * x + A * J + ll * Q, V[7] = z * t + w * K + A * F + ll * P, V[8] = z * e + w * C + A * R + ll * j, V[9] = z * Z + w * T + A * S + ll * D + _, z = r[10], w = r[11], A = r[12], ll = r[13], _ = r[14], V[10] = z * W + w * a + A * I + ll * N, V[11] = z * y + w * x + A * J + ll * Q, V[12] = z * t + w * K + A * F + ll * P, V[13] = z * e + w * C + A * R + ll * j, V[14] = z * Z + w * T + A * S + ll * D + _, z = r[15], w = r[16], A = r[17], ll = r[18], _ = r[19], V[15] = z * W + w * a + A * I + ll * N, V[16] = z * y + w * x + A * J + ll * Q, V[17] = z * t + w * K + A * F + ll * P, V[18] = z * e + w * C + A * R + ll * j, V[19] = z * Z + w * T + A * S + ll * D + _, V;
      }
      function c(p) {
        p = Object(i.clamp)(0, 1, p);
        const r = 0.2126 * p, V = 0.7152 * p, W = 0.0722 * p;
        return [r + 1 - p, V, W, 0, 0, r, V + 1 - p, W, 0, 0, r, V, W + 1 - p, 0, 0, 0, 0, 0, 1, 0];
      }
      function m(p) {
        return [p, 0, 0, 0, 0, 0, p, 0, 0, 0, 0, 0, p, 0, 0, 0, 0, 0, 1, 0];
      }
      function n(p) {
        const r = 0.2126 * (1 - p), V = 0.7152 * (1 - p), W = 0.0722 * (1 - p);
        return [r + p, V, W, 0, 0, r, V + p, W, 0, 0, r, V, W + p, 0, 0, 0, 0, 0, 1, 0];
      }
      function X(p) {
        const r = 0.5 * (1 - p);
        return [p, 0, 0, 0, r, 0, p, 0, 0, r, 0, 0, p, 0, r, 0, 0, 0, 1, 0];
      }
      function G(p) {
        const r = 1 - 2 * p;
        return [r, 0, 0, 0, p, 0, r, 0, 0, p, 0, 0, r, 0, p, 0, 0, 0, 1, 0];
      }
      function L(p) {
        return [1 - 0.607 * p, 0.769 * p, 0.189 * p, 0, 0, 0.349 * p, 1 - 0.314 * p, 0.168 * p, 0, 0, 0.272 * p, 0.534 * p, 1 - 0.869 * p, 0, 0, 0, 0, 0, 1, 0];
      }
      function o(p) {
        return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, p, 0];
      }
      function h(p) {
        const r = p / 180 * Math.PI, V = Math.cos(r), W = Math.sin(r), y = 0.2126, t = 0.7152, e = 0.0722;
        return [y + V * (1 - y) + W * -y, t + V * -t + W * -t, e + V * -e + W * (1 - e), 0, 0, y + V * -y + W * 0.143, t + V * (1 - t) + W * 0.14, e + V * -e + W * -0.283, 0, 0, y + V * -y + W * -(1 - y), t + V * -t + W * t, e + V * (1 - e) + W * e, 0, 0, 0, 0, 0, 1, 0];
      }
    },
    /* 31 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return c;
      });
      var i = l(32), s = /* @__PURE__ */ l.n(i);
      l(1).glMatrix.setMatrixArrayType(Array);
      function c(m) {
        const n = s()(m);
        if (!n || !n.length)
          throw new TypeError("Invalid color value.");
        return [n[0] / 255, n[1] / 255, n[2] / 255, n[3]];
      }
    },
    /* 32 */
    /***/
    function(b, d, l) {
      var i = l(33), s = l(37), c = l(39);
      b.exports = function(n) {
        var X, G = i(n);
        return G.space ? (X = Array(3), X[0] = c(G.values[0], 0, 255), X[1] = c(G.values[1], 0, 255), X[2] = c(G.values[2], 0, 255), G.space[0] === "h" && (X = s.rgb(X)), X.push(c(G.alpha, 0, 1)), X) : [];
      };
    },
    /* 33 */
    /***/
    function(b, d, l) {
      (function(i) {
        var s = l(34), c = l(35), m = l(36);
        b.exports = X;
        var n = {
          red: 0,
          orange: 60,
          yellow: 120,
          green: 180,
          blue: 240,
          purple: 300
        };
        function X(G) {
          var L, o = [], h = 1, p;
          if (typeof G == "string")
            if (s[G])
              o = s[G].slice(), p = "rgb";
            else if (G === "transparent")
              h = 0, p = "rgb", o = [0, 0, 0];
            else if (/^#[A-Fa-f0-9]+$/.test(G)) {
              var r = G.slice(1), V = r.length, W = V <= 4;
              h = 1, W ? (o = [
                parseInt(r[0] + r[0], 16),
                parseInt(r[1] + r[1], 16),
                parseInt(r[2] + r[2], 16)
              ], V === 4 && (h = parseInt(r[3] + r[3], 16) / 255)) : (o = [
                parseInt(r[0] + r[1], 16),
                parseInt(r[2] + r[3], 16),
                parseInt(r[4] + r[5], 16)
              ], V === 8 && (h = parseInt(r[6] + r[7], 16) / 255)), o[0] || (o[0] = 0), o[1] || (o[1] = 0), o[2] || (o[2] = 0), p = "rgb";
            } else if (L = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(G)) {
              var y = L[1], t = y === "rgb", r = y.replace(/a$/, "");
              p = r;
              var V = r === "cmyk" ? 4 : r === "gray" ? 1 : 3;
              o = L[2].trim().split(/\s*,\s*/).map(function(x, K) {
                if (/%$/.test(x))
                  return K === V ? parseFloat(x) / 100 : r === "rgb" ? parseFloat(x) * 255 / 100 : parseFloat(x);
                if (r[K] === "h") {
                  if (/deg$/.test(x))
                    return parseFloat(x);
                  if (n[x] !== void 0)
                    return n[x];
                }
                return parseFloat(x);
              }), y === r && o.push(1), h = t || o[V] === void 0 ? 1 : o[V], o = o.slice(0, V);
            } else
              G.length > 10 && /[0-9](?:\s|\/)/.test(G) && (o = G.match(/([0-9]+)/g).map(function(Z) {
                return parseFloat(Z);
              }), p = G.match(/([a-z])/ig).join("").toLowerCase());
          else if (!isNaN(G))
            p = "rgb", o = [G >>> 16, (G & 65280) >>> 8, G & 255];
          else if (c(G)) {
            var e = m(G.r, G.red, G.R, null);
            e !== null ? (p = "rgb", o = [
              e,
              m(G.g, G.green, G.G),
              m(G.b, G.blue, G.B)
            ]) : (p = "hsl", o = [
              m(G.h, G.hue, G.H),
              m(G.s, G.saturation, G.S),
              m(G.l, G.lightness, G.L, G.b, G.brightness)
            ]), h = m(G.a, G.alpha, G.opacity, 1), G.opacity != null && (h /= 100);
          } else
            (Array.isArray(G) || i.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(G)) && (o = [G[0], G[1], G[2]], p = "rgb", h = G.length === 4 ? G[3] : 1);
          return {
            space: p,
            values: o,
            alpha: h
          };
        }
      }).call(this, l(22));
    },
    /* 34 */
    /***/
    function(b, d, l) {
      b.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    },
    /* 35 */
    /***/
    function(b, d, l) {
      var i = Object.prototype.toString;
      b.exports = function(s) {
        var c;
        return i.call(s) === "[object Object]" && (c = Object.getPrototypeOf(s), c === null || c === Object.getPrototypeOf({}));
      };
    },
    /* 36 */
    /***/
    function(b, d) {
      b.exports = function() {
        for (var l = 0; l < arguments.length; l++)
          if (arguments[l] !== void 0)
            return arguments[l];
      };
    },
    /* 37 */
    /***/
    function(b, d, l) {
      var i = l(38);
      b.exports = {
        name: "hsl",
        min: [0, 0, 0],
        max: [360, 100, 100],
        channel: ["hue", "saturation", "lightness"],
        alias: ["HSL"],
        rgb: function(s) {
          var c = s[0] / 360, m = s[1] / 100, n = s[2] / 100, X, G, L, o, h;
          if (m === 0)
            return h = n * 255, [h, h, h];
          n < 0.5 ? G = n * (1 + m) : G = n + m - n * m, X = 2 * n - G, o = [0, 0, 0];
          for (var p = 0; p < 3; p++)
            L = c + 1 / 3 * -(p - 1), L < 0 ? L++ : L > 1 && L--, 6 * L < 1 ? h = X + (G - X) * 6 * L : 2 * L < 1 ? h = G : 3 * L < 2 ? h = X + (G - X) * (2 / 3 - L) * 6 : h = X, o[p] = h * 255;
          return o;
        }
      }, i.hsl = function(s) {
        var c = s[0] / 255, m = s[1] / 255, n = s[2] / 255, X = Math.min(c, m, n), G = Math.max(c, m, n), L = G - X, o, h, p;
        return G === X ? o = 0 : c === G ? o = (m - n) / L : m === G ? o = 2 + (n - c) / L : n === G && (o = 4 + (c - m) / L), o = Math.min(o * 60, 360), o < 0 && (o += 360), p = (X + G) / 2, G === X ? h = 0 : p <= 0.5 ? h = L / (G + X) : h = L / (2 - G - X), [o, h * 100, p * 100];
      };
    },
    /* 38 */
    /***/
    function(b, d, l) {
      b.exports = {
        name: "rgb",
        min: [0, 0, 0],
        max: [255, 255, 255],
        channel: ["red", "green", "blue"],
        alias: ["RGB"]
      };
    },
    /* 39 */
    /***/
    function(b, d) {
      b.exports = l;
      function l(i, s, c) {
        return s < c ? i < s ? s : i > c ? c : i : i < c ? c : i > s ? s : i;
      }
    },
    /* 40 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var i = l(41), s = /* @__PURE__ */ l.n(i), c = l(42), m = /* @__PURE__ */ l.n(c), n = l(43), X = /* @__PURE__ */ l.n(n), G = l(44), L = l(46), o = /* @__PURE__ */ l.n(L), h = l(53), p = l(55);
      l(1).glMatrix.setMatrixArrayType(Array);
      const r = Symbol("contours"), V = Symbol("path"), W = Symbol("simplify"), y = Symbol("scale"), t = 2 * Math.PI;
      class e {
        constructor(a = {}) {
          typeof a == "string" && (a = {
            path: a
          }), a.path ? this[V] = s()(a.path) : this[V] = [], this[r] = null, this[W] = a.simplify != null ? a.simplify : 0, this[y] = a.scale != null ? a.scale : 2;
        }
        get contours() {
          let a = null;
          if (!this[r] && this[V]) {
            const x = Object(G.default)(X()(this[V]));
            this[r] = o()(x, this[y], this[W]), this[r].path = x, this[r].simplify = this[W], this[r].scale = this[y];
          }
          return this[r] && (a = this[r].map((x) => [...x]), a.path = this[r].path, a.simplify = this[r].simplify, a.scale = this[r].scale), a;
        }
        get path() {
          return this[V];
        }
        get simplify() {
          return this[W];
        }
        get boundingBox() {
          const a = this.contours;
          if (a && a.length) {
            const x = a.reduce((K, C) => [...K, ...C]);
            return m()(x);
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const a = this.boundingBox;
          return a ? [0.5 * (a[0][0] + a[1][0]), 0.5 * (a[0][1] + a[1][1])] : [0, 0];
        }
        normalize(a = 0, x = 0) {
          const K = Object(G.default)(X()(this[V])).map(([C, ...T]) => {
            const I = [C];
            for (let J = 0; J < T.length; J += 2) {
              const F = T[J] - a, R = T[J + 1] - x;
              I.push(F, R);
            }
            return I;
          });
          return this.beginPath(), this[V].push(...K), this;
        }
        getPointAtLength(a) {
          return this.contours ? Object(h.getPointAtLength)(this[r], a) : null;
        }
        getTotalLength() {
          return this.contours ? Object(h.getTotalLength)(this[r]) : 0;
        }
        addPath(a) {
          this[r] = null, typeof a == "string" && (a = s()(a)), this[V].push(...a);
        }
        beginPath() {
          this[V] = [], this[r] = null;
        }
        clear() {
          this.beginPath();
        }
        ellipse(a, x, K, C, T, I, J, F = 0) {
          if (I += T, J += T, K <= 0 || C <= 0 || J === I)
            return;
          J < I && (J = I + t + (J - I) % t), J - I > t && (J = I + t);
          const R = J - I;
          R >= t && (J -= 1e-3);
          let S = this[V].length > 0 && R < t ? "L" : "M";
          const N = Object(p.getPoint)(a, x, K, C, I), Q = Object(p.getPoint)(a, x, K, C, J), P = +!F;
          let j = R > Math.PI ? 1 : 0;
          F && (j = 1 - j), S += N.join(" "), S += `A${K} ${C} 0 ${j} ${P} ${Q.join(" ")}`, R >= t && (S += "Z"), this.addPath(S);
        }
        arc(a, x, K, C, T, I = 0) {
          return this.ellipse(a, x, K, K, 0, C, T, I);
        }
        arcTo(a, x, K, C, T, I, J) {
          this[r] = null, this[V].push(["A", a, x, K, C, T, I, J]);
        }
        moveTo(a, x) {
          this[r] = null, this[V].push(["M", a, x]);
        }
        lineTo(a, x) {
          this[r] = null, this[V].push(["L", a, x]);
        }
        bezierCurveTo(a, x, K, C, T, I) {
          this[r] = null, this[V].push(["C", a, x, K, C, T, I]);
        }
        quadraticCurveTo(a, x, K, C) {
          this[r] = null, this[V].push(["Q", a, x, K, C]);
        }
        rect(a, x, K, C) {
          const T = `M${a} ${x}L${a + K} ${x}L${a + K} ${x + C}L${a} ${x + C}Z`;
          this.addPath(T);
        }
        closePath() {
          this[r] = null;
          let a = [];
          const x = this[V].length;
          x > 0 && (a = this[V][x - 1]), a[0] !== "Z" && a[0] !== "z" && this[V].push(["Z"]);
        }
      }
    },
    /* 41 */
    /***/
    function(b, d) {
      b.exports = s;
      var l = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, i = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function s(n) {
        var X = [];
        return n.replace(i, function(G, L, o) {
          var h = L.toLowerCase();
          for (o = m(o), h == "m" && o.length > 2 && (X.push([L].concat(o.splice(0, 2))), h = "l", L = L == "m" ? "l" : "L"); ; ) {
            if (o.length == l[h])
              return o.unshift(L), X.push(o);
            if (o.length < l[h])
              throw new Error("malformed path data");
            X.push([L].concat(o.splice(0, l[h])));
          }
        }), X;
      }
      var c = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function m(n) {
        var X = n.match(c);
        return X ? X.map(Number) : [];
      }
    },
    /* 42 */
    /***/
    function(b, d, l) {
      b.exports = i;
      function i(s) {
        var c = s.length;
        if (c === 0)
          return [[], []];
        for (var m = s[0].length, n = s[0].slice(), X = s[0].slice(), G = 1; G < c; ++G)
          for (var L = s[G], o = 0; o < m; ++o) {
            var h = L[o];
            n[o] = Math.min(n[o], h), X[o] = Math.max(X[o], h);
          }
        return [n, X];
      }
    },
    /* 43 */
    /***/
    function(b, d) {
      b.exports = l;
      function l(i) {
        var s = 0, c = 0, m = 0, n = 0;
        return i.map(function(X) {
          X = X.slice();
          var G = X[0], L = G.toUpperCase();
          if (G != L)
            switch (X[0] = L, G) {
              case "a":
                X[6] += m, X[7] += n;
                break;
              case "v":
                X[1] += n;
                break;
              case "h":
                X[1] += m;
                break;
              default:
                for (var o = 1; o < X.length; )
                  X[o++] += m, X[o++] += n;
            }
          switch (L) {
            case "Z":
              m = s, n = c;
              break;
            case "H":
              m = X[1];
              break;
            case "V":
              n = X[1];
              break;
            case "M":
              m = s = X[1], n = c = X[2];
              break;
            default:
              m = X[X.length - 2], n = X[X.length - 1];
          }
          return X;
        });
      }
    },
    /* 44 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return s;
      });
      var i = l(45);
      l(1).glMatrix.setMatrixArrayType(Array);
      function s(n) {
        for (var X, G = [], L = 0, o = 0, h = 0, p = 0, r = null, V = null, W = 0, y = 0, t = 0, e = n.length; t < e; t++) {
          var Z = n[t], a = Z[0];
          switch (a) {
            case "M":
              h = Z[1], p = Z[2];
              break;
            case "A":
              var x = Object(i.default)(W, y, Z[6], Z[7], Z[4], Z[5], Z[1], Z[2], Z[3]);
              if (!x.length)
                continue;
              x = x.map((J) => {
                const [F, R, S, N, Q, P, j, D] = J;
                return {
                  x1: S,
                  y1: N,
                  x2: Q,
                  y2: P,
                  x: j,
                  y: D
                };
              });
              for (var K = 0, C; K < x.length; K++)
                C = x[K], Z = ["C", C.x1, C.y1, C.x2, C.y2, C.x, C.y], K < x.length - 1 && G.push(Z);
              break;
            case "S":
              var T = W, I = y;
              (X == "C" || X == "S") && (T += T - L, I += I - o), Z = ["C", T, I, Z[1], Z[2], Z[3], Z[4]];
              break;
            case "T":
              X == "Q" || X == "T" ? (r = W * 2 - r, V = y * 2 - V) : (r = W, V = y), Z = m(W, y, r, V, Z[1], Z[2]);
              break;
            case "Q":
              r = Z[1], V = Z[2], Z = m(W, y, Z[1], Z[2], Z[3], Z[4]);
              break;
            case "L":
              Z = c(W, y, Z[1], Z[2]);
              break;
            case "H":
              Z = c(W, y, Z[1], y);
              break;
            case "V":
              Z = c(W, y, W, Z[1]);
              break;
            case "Z":
              Z = c(W, y, h, p);
              break;
          }
          X = a, W = Z[Z.length - 2], y = Z[Z.length - 1], Z.length > 4 ? (L = Z[Z.length - 4], o = Z[Z.length - 3]) : (L = W, o = y), G.push(Z);
        }
        return G;
      }
      function c(n, X, G, L) {
        return ["C", n, X, G, L, G, L];
      }
      function m(n, X, G, L, o, h) {
        return ["C", n / 3 + 2 / 3 * G, X / 3 + 2 / 3 * L, o / 3 + 2 / 3 * G, h / 3 + 2 / 3 * L, o, h];
      }
    },
    /* 45 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const i = Math.PI * 2;
      function s(X, G, L, o) {
        const h = X * o - G * L < 0 ? -1 : 1;
        let p = X * L + G * o;
        return p > 1 && (p = 1), p < -1 && (p = -1), h * Math.acos(p);
      }
      function c(X, G, L, o, h, p, r, V, W, y) {
        const t = y * (X - L) / 2 + W * (G - o) / 2, e = -W * (X - L) / 2 + y * (G - o) / 2, Z = r * r, a = V * V, x = t * t, K = e * e;
        let C = Z * a - Z * K - a * x;
        C < 0 && (C = 0), C /= Z * K + a * x, C = Math.sqrt(C) * (h === p ? -1 : 1);
        const T = C * r / V * e, I = C * -V / r * t, J = y * T - W * I + (X + L) / 2, F = W * T + y * I + (G + o) / 2, R = (t - T) / r, S = (e - I) / V, N = (-t - T) / r, Q = (-e - I) / V, P = s(1, 0, R, S);
        let j = s(R, S, N, Q);
        return p === 0 && j > 0 && (j -= i), p === 1 && j < 0 && (j += i), [J, F, P, j];
      }
      function m(X, G) {
        const L = 1.3333333333333333 * Math.tan(G / 4), o = Math.cos(X), h = Math.sin(X), p = Math.cos(X + G), r = Math.sin(X + G);
        return [o, h, o - h * L, h + o * L, p + r * L, r - p * L, p, r];
      }
      function n(X, G, L, o, h, p, r, V, W) {
        const y = Math.sin(W * i / 360), t = Math.cos(W * i / 360), e = t * (X - L) / 2 + y * (G - o) / 2, Z = -y * (X - L) / 2 + t * (G - o) / 2;
        if (e === 0 && Z === 0)
          return [];
        if (r === 0 || V === 0)
          return [];
        r = Math.abs(r), V = Math.abs(V);
        const a = e * e / (r * r) + Z * Z / (V * V);
        a > 1 && (r *= Math.sqrt(a), V *= Math.sqrt(a));
        const x = c(X, G, L, o, h, p, r, V, y, t), K = [];
        let C = x[2], T = x[3];
        const I = Math.max(Math.ceil(Math.abs(T) / (i / 4)), 1);
        T /= I;
        for (let J = 0; J < I; J++)
          K.push(m(C, T)), C += T;
        return K.map((J) => {
          for (let F = 0; F < J.length; F += 2) {
            let R = J[F + 0], S = J[F + 1];
            R *= r, S *= V;
            const N = t * R - y * S, Q = y * R + t * S;
            J[F + 0] = N + x[0], J[F + 1] = Q + x[1];
          }
          return J;
        });
      }
    },
    /* 46 */
    /***/
    function(b, d, l) {
      l(1).glMatrix.setMatrixArrayType(Array);
      var i = l(47), {
        copy: s
      } = l(49), c = l(50);
      function m(o, h, p) {
        return o[0] = h, o[1] = p, o;
      }
      var n = [0, 0], X = [0, 0], G = [0, 0];
      function L(o, h, p, r) {
        i(p, m(n, r[1], r[2]), m(X, r[3], r[4]), m(G, r[5], r[6]), h, o);
      }
      b.exports = function(h, p, r) {
        var V = [], W = [], y = [0, 0];
        return h.forEach(function(t, e, Z) {
          if (t[0] === "M")
            s(y, t.slice(1)), W.length > 0 && (V.push(W), W = []);
          else if (t[0] === "C")
            L(W, p, y, t), m(y, t[5], t[6]);
          else
            throw new Error("illegal type in SVG: " + t[0]);
        }), W.length > 0 && V.push(W), V.map(function(t) {
          return c(t, r || 0);
        });
      };
    },
    /* 47 */
    /***/
    function(b, d, l) {
      b.exports = l(48)();
    },
    /* 48 */
    /***/
    function(b, d) {
      function l(s) {
        return [s[0], s[1]];
      }
      function i(s, c) {
        return [s, c];
      }
      b.exports = function(c) {
        c = c || {};
        var m = typeof c.recursion == "number" ? c.recursion : 8, n = typeof c.epsilon == "number" ? c.epsilon : 11920929e-14, X = typeof c.pathEpsilon == "number" ? c.pathEpsilon : 1, G = typeof c.angleEpsilon == "number" ? c.angleEpsilon : 0.01, L = c.angleTolerance || 0, o = c.cuspLimit || 0;
        return function(V, W, y, t, e, Z) {
          Z || (Z = []), e = typeof e == "number" ? e : 1;
          var a = X / e;
          return a *= a, h(V, W, y, t, Z, a), Z;
        };
        function h(r, V, W, y, t, e) {
          t.push(l(r));
          var Z = r[0], a = r[1], x = V[0], K = V[1], C = W[0], T = W[1], I = y[0], J = y[1];
          p(Z, a, x, K, C, T, I, J, t, e, 0), t.push(l(y));
        }
        function p(r, V, W, y, t, e, Z, a, x, K, C) {
          if (!(C > m)) {
            var T = Math.PI, I = (r + W) / 2, J = (V + y) / 2, F = (W + t) / 2, R = (y + e) / 2, S = (t + Z) / 2, N = (e + a) / 2, Q = (I + F) / 2, P = (J + R) / 2, j = (F + S) / 2, D = (R + N) / 2, z = (Q + j) / 2, w = (P + D) / 2;
            if (C > 0) {
              var A = Z - r, ll = a - V, _ = Math.abs((W - Z) * ll - (y - a) * A), cl = Math.abs((t - Z) * ll - (e - a) * A), $, al;
              if (_ > n && cl > n) {
                if ((_ + cl) * (_ + cl) <= K * (A * A + ll * ll)) {
                  if (L < G) {
                    x.push(i(z, w));
                    return;
                  }
                  var Xl = Math.atan2(e - y, t - W);
                  if ($ = Math.abs(Xl - Math.atan2(y - V, W - r)), al = Math.abs(Math.atan2(a - e, Z - t) - Xl), $ >= T && ($ = 2 * T - $), al >= T && (al = 2 * T - al), $ + al < L) {
                    x.push(i(z, w));
                    return;
                  }
                  if (o !== 0) {
                    if ($ > o) {
                      x.push(i(W, y));
                      return;
                    }
                    if (al > o) {
                      x.push(i(t, e));
                      return;
                    }
                  }
                }
              } else if (_ > n) {
                if (_ * _ <= K * (A * A + ll * ll)) {
                  if (L < G) {
                    x.push(i(z, w));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(e - y, t - W) - Math.atan2(y - V, W - r)), $ >= T && ($ = 2 * T - $), $ < L) {
                    x.push(i(W, y)), x.push(i(t, e));
                    return;
                  }
                  if (o !== 0 && $ > o) {
                    x.push(i(W, y));
                    return;
                  }
                }
              } else if (cl > n) {
                if (cl * cl <= K * (A * A + ll * ll)) {
                  if (L < G) {
                    x.push(i(z, w));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(a - e, Z - t) - Math.atan2(e - y, t - W)), $ >= T && ($ = 2 * T - $), $ < L) {
                    x.push(i(W, y)), x.push(i(t, e));
                    return;
                  }
                  if (o !== 0 && $ > o) {
                    x.push(i(t, e));
                    return;
                  }
                }
              } else if (A = z - (r + Z) / 2, ll = w - (V + a) / 2, A * A + ll * ll <= K) {
                x.push(i(z, w));
                return;
              }
            }
            p(r, V, I, J, Q, P, z, w, x, K, C + 1), p(z, w, j, D, S, N, Z, a, x, K, C + 1);
          }
        }
      };
    },
    /* 49 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "create", function() {
        return c;
      }), l.d(d, "clone", function() {
        return s;
      }), l.d(d, "copy", function() {
        return m;
      }), l.d(d, "scaleAndAdd", function() {
        return n;
      }), l.d(d, "dot", function() {
        return X;
      }), l.d(d, "rotate", function() {
        return G;
      }), l.d(d, "cross", function() {
        return L;
      }), l.d(d, "sub", function() {
        return o;
      }), l.d(d, "add", function() {
        return h;
      }), l.d(d, "computeMiter", function() {
        return W;
      }), l.d(d, "normal", function() {
        return y;
      }), l.d(d, "direction", function() {
        return t;
      });
      var i = l(1);
      l(1).glMatrix.setMatrixArrayType(Array);
      function s(e) {
        return [e[0], e[1]];
      }
      function c() {
        return [0, 0];
      }
      const m = i.vec2.copy, n = i.vec2.scaleAndAdd, X = i.vec2.dot, G = i.vec2.rotate, L = i.vec2.cross, o = i.vec2.sub, h = i.vec2.add, p = i.vec2.normalize, r = i.vec2.set, V = c();
      function W(e, Z, a, x, K) {
        h(e, a, x), p(e, e), r(Z, -e[1], e[0]), r(V, -a[1], a[0]);
        const C = K / X(Z, V);
        return Math.abs(C);
      }
      function y(e, Z) {
        return r(e, -Z[1], Z[0]), e;
      }
      function t(e, Z, a) {
        return o(e, Z, a), p(e, e), e;
      }
    },
    /* 50 */
    /***/
    function(b, d, l) {
      var i = l(51), s = l(52);
      b.exports = function(m, n) {
        return m = i(m, n), m = s(m, n), m;
      }, b.exports.radialDistance = i, b.exports.douglasPeucker = s;
    },
    /* 51 */
    /***/
    function(b, d) {
      function l(i, s) {
        var c = i[0] - s[0], m = i[1] - s[1];
        return c * c + m * m;
      }
      b.exports = function(s, c) {
        if (s.length <= 1)
          return s;
        c = typeof c == "number" ? c : 1;
        for (var m = c * c, n = s[0], X = [n], G, L = 1, o = s.length; L < o; L++)
          G = s[L], l(G, n) > m && (X.push(G), n = G);
        return n !== G && X.push(G), X;
      };
    },
    /* 52 */
    /***/
    function(b, d) {
      function l(s, c, m) {
        var n = c[0], X = c[1], G = m[0] - n, L = m[1] - X;
        if (G !== 0 || L !== 0) {
          var o = ((s[0] - n) * G + (s[1] - X) * L) / (G * G + L * L);
          o > 1 ? (n = m[0], X = m[1]) : o > 0 && (n += G * o, X += L * o);
        }
        return G = s[0] - n, L = s[1] - X, G * G + L * L;
      }
      function i(s, c, m, n, X) {
        for (var G = n, L, o = c + 1; o < m; o++) {
          var h = l(s[o], s[c], s[m]);
          h > G && (L = o, G = h);
        }
        G > n && (L - c > 1 && i(s, c, L, n, X), X.push(s[L]), m - L > 1 && i(s, L, m, n, X));
      }
      b.exports = function(c, m) {
        if (c.length <= 1)
          return c;
        m = typeof m == "number" ? m : 1;
        var n = m * m, X = c.length - 1, G = [c[0]];
        return i(c, 0, X, n, G), G.push(c[X]), G;
      };
    },
    /* 53 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "getTotalLength", function() {
        return s;
      }), l.d(d, "getPointAtLength", function() {
        return m;
      }), l.d(d, "getDashContours", function() {
        return n;
      });
      var i = l(54);
      l(1).glMatrix.setMatrixArrayType(Array);
      function s(X) {
        if (X.totalLength != null)
          return X.totalLength;
        let G = 0;
        return X.forEach((L) => {
          let o = L[0];
          for (let h = 1; h < L.length; h++) {
            const p = L[h];
            G += Object(i.distance)(o, p), o = p;
          }
        }), X.totalLength = G, G;
      }
      function c(X, G, L = !0) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (G <= 0)
          throw new TypeError("Length must > 0");
        const o = s(X);
        if (G >= o) {
          const p = X[X.length - 1], r = p[p.length - 2], V = p[p.length - 1], W = Math.atan2(V[1] - r[1], V[0] - r[0]);
          return {
            current: X.map((y) => [...y]),
            point: {
              x: V[0],
              y: V[1],
              angle: W
            }
          };
        }
        const h = [];
        for (let p = 0; p < X.length; p++) {
          h[p] = [];
          const r = X[p];
          let V = r[0];
          for (let W = 1; W < r.length; W++) {
            const y = r[W], t = Object(i.distance)(V, y);
            if (G < t) {
              const e = G / t, Z = Math.atan2(y[1] - V[1], y[0] - V[0]), a = {
                x: V[0] * (1 - e) + y[0] * e,
                y: V[1] * (1 - e) + y[1] * e,
                angle: Z
              };
              if (h[p].push(V), G > 0 && h[p].push([a.x, a.y]), !L)
                return {
                  current: h,
                  point: a
                };
              const x = [], K = p;
              for (; p < X.length; p++) {
                for (x[p - K] = [], p === K && x[0].push([a.x, a.y]); W < r.length; W++)
                  x[p - K].push(r[W]);
                W = 0;
              }
              return {
                current: h,
                point: a,
                rest: x
              };
            }
            G -= t, h[p].push(V), V = y;
          }
        }
      }
      function m(X, G) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (X.length <= 0)
          return {
            x: 0,
            y: 0,
            angle: 0
          };
        if (G <= 0) {
          const L = X[0][0], o = X[0][1], h = Math.atan2(o[1] - L[1], o[0] - L[0]);
          return {
            x: L[0],
            y: L[1],
            angle: h
          };
        }
        return c(X, G, !1).point;
      }
      function n(X, G, L) {
        let o = 0, h = G[0], p = X;
        const r = [], V = G.length;
        if (L > 0) {
          do
            L -= G[o % V], o++;
          while (L > 0);
          L < 0 && (h = -L, o--);
        } else if (L < 0) {
          o = -1;
          do
            L += G[o % V + V - 1], o--;
          while (L < 0);
          L >= 0 && (o++, h = G[o % V + V - 1] - L);
        }
        do {
          const W = c(p, h);
          p = W.rest, ++o % 2 && r.push(...W.current);
          let y = o % V;
          y < 0 && (y += V), h = G[y];
        } while (p);
        return r;
      }
    },
    /* 54 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "normalize", function() {
        return i;
      }), l.d(d, "distance", function() {
        return s;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i([c, m, n], X, G, L) {
        return c = c * 2 / X - 1, m = 1 - m * 2 / G, Number.isFinite(L) ? (n = n * 2 / L - 1, [c, m, n]) : [c, m];
      }
      function s([c, m, n = 0], [X, G, L = 0]) {
        return Math.hypot(X - c, G - m, L - n);
      }
    },
    /* 55 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "getPoint", function() {
        return s;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const i = Math.PI * 2;
      function s(c, m, n, X, G) {
        G %= i, G < 0 && (G += i);
        const L = Math.tan(G);
        if (Math.abs(L) < 1e5) {
          const o = m - L * c, h = 1 / n ** 2 + L ** 2 / X ** 2;
          let p = -1;
          (G <= Math.PI / 2 || G > 3 * Math.PI / 2) && (p = 1);
          const r = p * Math.sqrt(1 / h) + c, V = L * r + o;
          return [r, V];
        }
        return G < Math.PI ? [c, m + X] : [c, m - X];
      }
    },
    /* 56 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return E;
      });
      var i = l(1), s = l(42), c = /* @__PURE__ */ l.n(s), m = l(57), n = l(28), X = l(24), G = l(30), L = l(59), o = l(53), h = l(60), p = /* @__PURE__ */ l.n(h), r = l(46), V = /* @__PURE__ */ l.n(r), W = l(31), y = l(40), t = l(21);
      l(1).glMatrix.setMatrixArrayType(Array);
      function e(O, g) {
        if (O == null)
          return {};
        var U = Z(O, g), u, Y;
        if (Object.getOwnPropertySymbols) {
          var H = Object.getOwnPropertySymbols(O);
          for (Y = 0; Y < H.length; Y++)
            u = H[Y], !(g.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(O, u) && (U[u] = O[u]);
        }
        return U;
      }
      function Z(O, g) {
        if (O == null)
          return {};
        var U = {}, u = Object.keys(O), Y, H;
        for (H = 0; H < u.length; H++)
          Y = u[H], !(g.indexOf(Y) >= 0) && (U[Y] = O[Y]);
        return U;
      }
      const a = Symbol("mesh"), x = Symbol("contours"), K = Symbol("stroke"), C = Symbol("fill"), T = Symbol("strokeColor"), I = Symbol("fillColor"), J = Symbol("transform"), F = Symbol("invertTransform"), R = Symbol("uniforms"), S = Symbol("texOptions"), N = Symbol("blend"), Q = Symbol("applyTexture"), P = Symbol("applyTransform"), j = Symbol("applyGradientTransform"), D = Symbol("applyProgram"), z = Symbol("gradient"), w = Symbol("filter"), A = Symbol("opacity"), ll = Symbol("program"), _ = Symbol("attributes"), cl = Symbol("pass"), $ = Symbol("clipContext"), al = Symbol("applyClipPath");
      function Xl(O, g) {
        const [U, u] = [O[1][0] - O[0][0], O[1][1] - O[0][1]], Y = [];
        for (let H = 0; H < g.length; H++) {
          const v = g[H], f = [(v[0] - O[0][0]) / U, 1 - (v[1] - O[0][1]) / u];
          Y.push(f);
        }
        return Y;
      }
      function M([O, g], [U, u, Y, H], {
        scale: v
      }) {
        return v || (O /= Y, g = 1 - g / H, O -= U, g += u), [O, g, 0];
      }
      function k(O, g, U) {
        const u = V()(O, g, U);
        return u.path = O, u.simplify = U, u.scale = g, u;
      }
      class E {
        constructor(g) {
          this[K] = null, this[C] = null, this[J] = [1, 0, 0, 1, 0, 0], this[A] = 1, this[R] = {}, this[w] = [], this[N] = null, this[S] = {}, this.contours = g.contours, this[ll] = null, this[_] = {}, this[cl] = [];
        }
        get contours() {
          return this[x];
        }
        set contours(g) {
          this[a] = null, this[x] = g;
          const U = g.scale;
          this.transformScale / U > 1.5 && this.accurate(this.transformScale);
        }
        setProgram(g) {
          this[ll] = g, this[a] && this[D](g);
        }
        get program() {
          return this[ll];
        }
        setAttribute(g, U) {
          U == null ? delete this[_][g] : this[_][g] = U;
        }
        getOpacity() {
          return this[A];
        }
        setOpacity(g) {
          if (g < 0 || g > 1)
            throw new TypeError("Invalid opacity value.");
          this[a] && this[a].positions.forEach((U) => {
            U[2] = 1 / U[2] > 0 ? g : -g;
          }), this[A] = g;
        }
        setClipPath(g) {
          this.clipPath = g, this[R].u_clipSampler && this[R].u_clipSampler.delete(), this.setUniforms({
            u_clipSampler: null
          }), this[a] && delete this[a].attributes.a_clipUV, g && this[a] && this[al]();
        }
        [al]() {
          if (this.clipPath) {
            this[$] || (this[$] = t.default.createCanvas(1, 1));
            const [[g, U], [u, Y]] = this.boundingBox;
            u && Y && (this[$].width = u - g, this[$].height = Y - U);
            const H = this[$].getContext("2d"), v = new Path2D(this.clipPath);
            H.clearRect(0, 0, this[$].width, this[$].height), H.save(), H.translate(-g, -U), H.fillStyle = "white", H.fill(v), H.restore(), this[a].clipPath = this[$];
            const f = Xl(this.boundingBox, this[a].position0);
            this[a].attributes.a_clipUV = f;
          }
        }
        getPointAtLength(g) {
          return Object(o.getPointAtLength)(this[x], g);
        }
        getTotalLength() {
          return Object(o.getTotalLength)(this[x]);
        }
        get blend() {
          return this[N] == null ? "auto" : this[N];
        }
        set blend(g) {
          this[N] = g, this[a] && (this[a].enableBlend = this.enableBlend);
        }
        get boundingBox() {
          if (this[a] && this[a].boundingBox)
            return this[a].boundingBox;
          const g = this.meshData;
          if (g) {
            const U = g.position0;
            if (U.length)
              g.boundingBox = c()(U);
            else
              return [[0, 0], [0, 0]];
            return g.boundingBox;
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const g = this.boundingBox;
          return g ? [0.5 * (g[0][0] + g[1][0]), 0.5 * (g[0][1] + g[1][1])] : [0, 0];
        }
        get fillRule() {
          return this[C] ? this[C].rule : "nonzero";
        }
        get lineWidth() {
          return this[K] ? this[K].lineWidth : 0;
        }
        get lineCap() {
          return this[K] ? this[K].lineCap : "";
        }
        get lineJoin() {
          return this[K] ? this[K].lineJoin : "";
        }
        get miterLimit() {
          return this[K] ? this[K].miterLimit : 0;
        }
        get strokeStyle() {
          return this[T] && this[T][3] !== 0 ? Object(X.default)(this[T]) : "";
        }
        get lineDash() {
          return this[K] ? this[K].lineDash : null;
        }
        get lineDashOffset() {
          return this[K] ? this[K].lineDashOffset : 0;
        }
        get fillStyle() {
          return this[I] && this[I][3] !== 0 ? Object(X.default)(this[I]) : "";
        }
        get gradient() {
          return this[z];
        }
        get texture() {
          return this[R].u_texSampler ? {
            image: this[R].u_texSampler._img,
            options: this[S]
          } : null;
        }
        get enableBlend() {
          return this[N] === !0 || this[N] === !1 ? this[N] : this[A] < 1 || this[T] != null && this[T][3] < 1 || this[I] != null && this[I][3] < 1 || this[R].u_colorMatrix != null && this[R].u_colorMatrix[18] < 1 || this[R].u_radialGradientVector != null || this.beforeRender || this.afterRender;
        }
        get filterCanvas() {
          return /blur|drop-shadow|url/.test(this.filter);
        }
        get filter() {
          return this[w].join(" ");
        }
        get transformMatrix() {
          return this[J];
        }
        get invertMatrix() {
          if (!this[F]) {
            const g = i.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this[J]);
            this[F] = g;
          }
          return this[F];
        }
        get transformScale() {
          const g = this[J];
          return Math.max(Math.hypot(g[0], g[1]), Math.hypot(g[2], g[3]));
        }
        get uniforms() {
          return this[R];
        }
        get pass() {
          return this[cl];
        }
        [D](g) {
          const U = this[_], u = this[a].position0, Y = Object.entries(g._attribute);
          for (let H = 0; H < Y.length; H++) {
            const [v, f] = Y[H];
            if (v !== "a_color" && v !== "a_sourceRect" && f !== "ignored") {
              const B = U[v];
              if (v === "uv" && !B) {
                const q = this[a].boundingBox || c()(u);
                this[a].attributes[v] = Xl(q, u);
              } else {
                this[a].attributes[v] = [];
                for (let q = 0; q < u.length; q++) {
                  const dl = u[q];
                  this[a].attributes[v].push(B ? B(dl, H, u) : Array(f.size).fill(0));
                }
              }
            }
          }
        }
        // {stroke, fill}
        get meshData() {
          if (this._updateMatrix && this.transformScale / this.contours.scale > 1.5 && this.accurate(this.transformScale), !this[a]) {
            !this[C] && !this[K] && this.setFill();
            const g = this[x], U = {};
            if (g && g.length) {
              if (this[C])
                try {
                  const H = p()(g, this[C]);
                  H.positions = H.positions.map((v) => (v.push(this[A]), v)), H.attributes = {
                    a_color: Array.from({
                      length: H.positions.length
                    }).map(() => this[I].map((v) => Math.round(255 * v)))
                    // a_sourceRect: Array.from({length: mesh.positions.length}).map(() => [0, 0, 0, 0]),
                  }, U.fill = H;
                } catch {
                }
              if (this[K]) {
                const H = this[K].lineDash;
                let v = g;
                if (H) {
                  const B = this[K].lineDashOffset;
                  v = Object(o.getDashContours)(g, H, B);
                }
                const f = v.map((B, q) => {
                  const dl = B.length > 1 && i.vec2.equals(B[0], B[B.length - 1]), il = this[K].build(B, dl);
                  return p()([il]);
                });
                f.forEach((B) => {
                  B.positions = B.positions.map((q) => (q.push(-this[A]), q)), B.attributes = {
                    a_color: Array.from({
                      length: B.positions.length
                    }).map(() => this[T].map((q) => Math.round(255 * q)))
                  };
                }), U.stroke = Object(n.default)(f);
              }
            }
            const u = Object(n.default)([U.fill, U.stroke]);
            u.fillPointCount = U.fill ? U.fill.positions.length : 0, u.enableBlend = this.enableBlend, u.position0 = u.positions.map(([H, v, f]) => [H, v, f]), u.uniforms = this[R], this[a] = u, this[R].u_texSampler && this[Q](u, this[S]);
            const Y = this[J];
            Object(L.isUnitTransform)(Y) || (this[P](u, Y), this[R].u_radialGradientVector && this[j]()), this.clipPath && this[al](), this[ll] && this[D](this[ll]);
          }
          return this._updateMatrix && (this[a].matrix = this[J], this[P](this[a], this[J]), this[R].u_radialGradientVector && this[j]()), this[a];
        }
        [P](g, U) {
          const {
            positions: u,
            position0: Y
          } = g;
          for (let H = 0; H < u.length; H++) {
            const [v, f] = Y[H], B = u[H];
            B[0] = v * U[0] + f * U[2] + U[4], B[1] = v * U[1] + f * U[3] + U[5];
          }
          this._updateMatrix = !1;
        }
        [j]() {
          const g = this[J], U = [...this._radialGradientVector];
          if (U) {
            const [u, Y, , H, v] = U;
            U[0] = u * g[0] + Y * g[2] + g[4], U[1] = u * g[1] + Y * g[3] + g[5], U[3] = H * g[0] + v * g[2] + g[4], U[4] = H * g[1] + v * g[3] + g[5], this[R].u_radialGradientVector = U;
          }
        }
        [Q](g, U) {
          function u(q, dl) {
            return q == null && dl == null ? !0 : q == null || dl == null ? !1 : q[0] === dl[0] && q[1] === dl[1] && q[2] === dl[2] && q[3] === dl[3];
          }
          const Y = this[R].u_texSampler;
          if (!Y)
            return;
          const {
            width: H,
            height: v
          } = Y._img, f = U.srcRect;
          let B = U.rect || [0, 0];
          if (U.rotated && (B = [-B[1], B[0], B[3], B[2]]), B[2] == null && (B[2] = f ? f[2] : H), B[3] == null && (B[3] = f ? f[3] : v), U.hidden)
            g.textureCoord = g.positions.map(() => [-1, -1, -1]);
          else if (!g.textureCoord || !u(this[S].rect, U.rect) || this[S].hidden !== U.hidden || this[S].rotated !== U.rotated) {
            let q = null;
            U.rotated && (q = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), i.mat2d.fromValues(1, 0, 0, 1, 0, 0), 0.5 * Math.PI), q = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), q, [0, -B[2]])), g.textureCoord = g.position0.map(([dl, il, bl]) => {
              if (1 / bl > 0) {
                if (U.rotated) {
                  const tl = dl * q[0] + il * q[2] + q[4], sl = dl * q[1] + il * q[3] + q[5];
                  [dl, il] = [tl, sl];
                }
                const ml = M([dl, il], [B[0] / B[2], B[1] / B[3], B[2], B[3]], U);
                return U.repeat && (ml[2] = 1), ml;
              }
              return [-1, -1, -1];
            });
          }
          if (f) {
            const q = [f[0] / H, f[1] / v, f[2] / H, f[3] / v];
            g.attributes.a_sourceRect = g.positions.map(() => [...q]);
          } else
            g.attributes.a_sourceRect = g.positions.map(() => [0, 0, 0, 0]);
        }
        accurate(g) {
          if (!this.contours)
            return;
          if (this.contours.path) {
            const u = this.contours.simplify, Y = k(this.contours.path, 2 * g, u);
            this[a] = null, this[x] = Y;
          }
        }
        canIgnore() {
          const g = this[K] == null || this[K].lineWidth === 0 || this[T][3] === 0, U = this[C] == null || this[I][3] === 0, u = this[R].u_radialGradientVector == null, Y = this[R].u_texSampler == null;
          return this[A] === 0 || this[ll] == null && g && U && u && Y && !this.beforeRender && !this.afterRender;
        }
        // join: 'miter' or 'bevel'
        // cap: 'butt' or 'square'
        // lineDash: null
        // lineDashOffset: 0
        setStroke({
          thickness: g = 1,
          cap: U = "butt",
          join: u = "miter",
          miterLimit: Y = 10,
          color: H = [0, 0, 0, 0],
          lineDash: v = null,
          lineDashOffset: f = 0,
          roundSegments: B = 20
        } = {}) {
          return this[a] = null, this[K] = new m.default({
            lineWidth: g,
            lineCap: U,
            lineJoin: u,
            miterLimit: Y,
            roundSegments: B
          }), typeof H == "string" && (H = Object(W.default)(H)), this[T] = H, this[K].lineDash = v, this[K].lineDashOffset = f, this;
        }
        setFill({
          rule: g = this.fillRule,
          color: U = [0, 0, 0, 0]
        } = {}) {
          return this[a] = null, this[C] = {
            rule: g
          }, typeof U == "string" && (U = Object(W.default)(U)), this[I] = U, this;
        }
        /**
          options: {
            scale: false,
            repeat: false,
            rotated: false,
            rect: [10, 10],
            srcRect: [...],
            hidden: false,
          }
         */
        setTexture(g, U = {}) {
          if (g && g.image) {
            const {
              image: u,
              rect: Y
            } = g;
            if (g = u, U.rect)
              for (let H = 0; H < U.rect.length; H++)
                Y[H] = U.rect[H];
            U.rect = Y;
          }
          return this[C] || this.setFill(), this.setUniforms({
            u_texSampler: g
          }), this[a] && this[Q](this[a], U), this[S] = U, this;
        }
        setCircularGradient({
          vector: g,
          colors: U,
          type: u = "fill"
        } = {}) {
          if (g.length !== 3)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: u
          });
        }
        setLinearGradient({
          vector: g,
          colors: U,
          type: u = "fill"
        } = {}) {
          if (g.length !== 4)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: u
          });
        }
        setRadialGradient({
          vector: g,
          colors: U,
          type: u = "fill"
        } = {}) {
          if (g.length !== 6)
            throw new TypeError("Invalid radialGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: u
          });
        }
        /**
          vector: [x0, y0, r0, x1, y1, r1],
          colors: [{offset:0, color}, {offset:1, color}, ...],
         */
        setGradient({
          vector: g,
          colors: U,
          type: u = "fill"
        } = {}) {
          U = U.map(({
            offset: v,
            color: f
          }) => (typeof f == "string" && (f = Object(W.default)(f)), {
            offset: v,
            color: f
          })), this[z] = this[z] || {}, this[z][u] = {
            vector: g,
            colors: U
          }, U.sort((v, f) => v.offset - f.offset);
          const Y = [];
          U.forEach(({
            offset: v,
            color: f
          }) => {
            Y.push(v, ...f);
          });
          let H;
          if (g.length === 4 ? H = [g[0], g[1], 0, g[2], g[3], 0] : H = [...g], Y.length < 40 && Y.push(-1), Y.length > 40)
            throw new Error("Too many colors, should be less than 8 colors");
          return this._radialGradientVector = H, this[R].u_colorSteps = Y, u === "fill" ? this[R].u_gradientType = 1 : this[R].u_gradientType = 0, this[j](), this;
        }
        setUniforms(g = {}) {
          return Object.assign(this[R], g), this;
        }
        setTransform(...g) {
          const U = this[J];
          return i.mat2d.equals(g, U) || (this[J] = g, delete this[F], this._updateMatrix = !0), this;
        }
        transform(...g) {
          const U = this[J];
          return this[J] = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), U, g), delete this[F], this._updateMatrix = !0, this;
        }
        translate(g, U) {
          let u = i.mat2d.create();
          return u = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), u, [g, U]), this.transform(...u);
        }
        rotate(g, [U, u] = [0, 0]) {
          let Y = i.mat2d.create();
          return Y = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), Y, [U, u]), Y = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), Y, g), Y = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), Y, [-U, -u]), this.transform(...Y);
        }
        scale(g, U = g, [u, Y] = [0, 0]) {
          let H = i.mat2d.create();
          return H = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), H, [u, Y]), H = i.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), H, [g, U]), H = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), H, [-u, -Y]), this.transform(...H);
        }
        skew(g, U = g, [u, Y] = [0, 0]) {
          let H = i.mat2d.create();
          return H = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), H, [u, Y]), H = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), H, i.mat2d.fromValues(1, Math.tan(U), Math.tan(g), 1, 0, 0)), H = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), H, [-u, -Y]), this.transform(...H);
        }
        clearFilter() {
          return this.setColorTransform(null), this[w].length = 0, this;
        }
        setColorTransform(...g) {
          return g[0] === null ? this.setUniforms({
            u_filterFlag: 0,
            u_colorMatrix: 0
          }) : this.setUniforms({
            u_filterFlag: 1,
            u_colorMatrix: g
          }), this;
        }
        // apply linear color transform
        transformColor(...g) {
          let U = this.uniforms.u_colorMatrix;
          return U ? U = Object(G.multiply)(U, g) : U = g, this.setColorTransform(...U), this;
        }
        blur(g) {
          return this[w].push(`blur(${g}px)`), this;
        }
        brightness(g = 1) {
          return this[w].push(`brightness(${100 * g}%)`), this.transformColor(...Object(G.brightness)(g));
        }
        contrast(g = 1) {
          return this[w].push(`contrast(${100 * g}%)`), this.transformColor(...Object(G.contrast)(g));
        }
        dropShadow(g, U, u = 0, Y = [0, 0, 0, 1]) {
          return Array.isArray(Y) && (Y = Object(X.default)(Y)), this[w].push(`drop-shadow(${g}px ${U}px ${u}px ${Y})`), this;
        }
        grayscale(g = 1) {
          return this[w].push(`grayscale(${100 * g}%)`), this.transformColor(...Object(G.grayscale)(g));
        }
        // https://github.com/phoboslab/WebGLImageFilter/blob/master/webgl-image-filter.js#L371
        hueRotate(g = 0) {
          return this[w].push(`hue-rotate(${g}deg)`), this.transformColor(...Object(G.hueRotate)(g));
        }
        invert(g = 1) {
          return this[w].push(`invert(${100 * g}%)`), this.transformColor(...Object(G.invert)(g));
        }
        opacity(g = 1) {
          return this[w].push(`opacity(${100 * g}%)`), this.transformColor(...Object(G.opacity)(g));
        }
        saturate(g = 1) {
          return this[w].push(`saturate(${100 * g}%)`), this.transformColor(...Object(G.saturate)(g));
        }
        sepia(g = 1) {
          return this[w].push(`sepia(${100 * g}%)`), this.transformColor(...Object(G.sepia)(g));
        }
        url(g) {
          return this[w].push(`url(${g})`), this;
        }
        isPointCollision(g, U, u = "both") {
          const Y = this.meshData, {
            positions: H,
            cells: v
          } = Y, f = this.invertMatrix, B = f[0] * g + f[2] * U + f[4], q = f[1] * g + f[3] * U + f[5], dl = this.boundingBox;
          if (B < dl[0][0] || B > dl[1][0] || q < dl[0][1] || q > dl[1][1])
            return !1;
          function il([bl, ml], [tl, sl], [Zl, ol]) {
            const Wl = Zl - tl, el = ol - sl, pl = ((bl - tl) * Wl + (ml - sl) * el) / (Wl ** 2 + el ** 2);
            return pl >= 0 && pl <= 1;
          }
          for (let bl = 0; bl < v.length; bl++) {
            const ml = v[bl];
            if (u === "fill" && ml[0] >= Y.fillPointCount)
              break;
            if (u === "stroke" && ml[0] < Y.fillPointCount)
              continue;
            const [[tl, sl], [Zl, ol], [Wl, el]] = ml.map((xl) => H[xl]), pl = Math.sign((g - tl) * (ol - sl) - (Zl - tl) * (U - sl));
            if (pl === 0 && il([g, U], [tl, sl], [Zl, ol]))
              return !0;
            const Kl = Math.sign((g - Zl) * (el - ol) - (Wl - Zl) * (U - ol));
            if (Kl === 0 && il([g, U], [Zl, ol], [Wl, el]))
              return !0;
            const Yl = Math.sign((g - Wl) * (sl - el) - (tl - Wl) * (U - el));
            if (Yl === 0 && il([g, U], [Wl, el], [tl, sl]) || pl === 1 && Kl === 1 && Yl === 1 || pl === -1 && Kl === -1 && Yl === -1)
              return !0;
          }
          return !1;
        }
        isPointInFill(g, U) {
          return this.isPointCollision(g, U, "fill");
        }
        isPointInStroke(g, U) {
          return this.isPointCollision(g, U, "stroke");
        }
        addPass(g, U = {}) {
          let {
            width: u,
            height: Y
          } = U, H = e(U, ["width", "height"]);
          const v = new y.default();
          v.rect(0, 0, u, Y);
          const f = new E(v, {
            width: u,
            height: Y
          });
          f.setUniforms(H), f.setProgram(g), this[cl].push(f);
        }
      }
    },
    /* 57 */
    /***/
    function(b, d, l) {
      l.r(d);
      var i = l(58);
      l(1).glMatrix.setMatrixArrayType(Array), d.default = i.Stroke;
    },
    /* 58 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "Stroke", function() {
        return L;
      });
      var i = l(49);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = Object(i.create)(), c = Object(i.create)(), m = Object(i.create)(), n = Object(i.create)(), X = Object(i.create)(), G = 1e20;
      class L {
        constructor({
          lineWidth: V = 1,
          lineJoin: W = "miter",
          miterLimit: y = 10,
          lineCap: t = "butt",
          roundSegments: e = 20
        } = {}) {
          this.lineWidth = V, this.lineJoin = W, this.miterLimit = y, this.lineCap = t, this.roundSegments = e, this._normal = null;
        }
        build(V, W = !1) {
          let y = V.length;
          if (V = [...V], y < 2)
            return V;
          W && ((V[0][0] !== V[y - 1][0] || V[0][1] !== V[y - 1][1]) && V.push([...V[0]]), V.push([...V[1]])), y = V.length, this._normal = null;
          const t = {
            left: [],
            right: []
          }, e = this.lineWidth / 2, Z = this.lineCap;
          if (!W && Z === "square") {
            Object(i.direction)(c, V[0], V[1]), Object(i.scaleAndAdd)(V[0], V[0], c, e);
            const x = V.length - 1;
            Object(i.direction)(c, V[x], V[x - 1]), Object(i.scaleAndAdd)(V[x], V[x], c, e);
          }
          for (let x = 1; x < y; x++) {
            const K = V[x - 1], C = V[x], T = V[x + 1];
            this._seg(t, K, C, T, e, W);
          }
          return !W && Z === "round" && p(t, this.roundSegments), [...t.left, ...t.right.reverse()];
        }
        _seg(V, W, y, t, e, Z) {
          const a = this.lineJoin === "bevel", x = this.lineJoin === "round";
          if (Object(i.direction)(c, y, W), this._normal || (this._normal = Object(i.create)(), Object(i.normal)(this._normal, c)), V.left.length || h(V, W, this._normal, e), !t)
            Object(i.normal)(this._normal, c), Z ? h(V, W, this._normal, e) : h(V, y, this._normal, e);
          else {
            Object(i.direction)(m, t, y);
            let K = Object(i.computeMiter)(n, X, c, m, e);
            K = Math.min(K, G);
            const C = Object(i.dot)(n, this._normal) < 0 ? -1 : 1;
            let T = a || x;
            if (!T && this.lineJoin === "miter" && K / e > this.miterLimit && (T = !0), T) {
              Object(i.scaleAndAdd)(s, y, this._normal, -e * C), o(V, s, C);
              let I = 1 / 0;
              W && (I = Math.min(I, Math.hypot(y[0] - W[0], y[1] - W[1]))), t && (I = Math.min(I, Math.hypot(t[0] - y[0], t[1] - y[1])));
              const J = Math.max(e, Math.min(K, I));
              if (Object(i.scaleAndAdd)(s, y, X, J * C), o(V, s, -C), t)
                if (Object(i.normal)(s, m), Object(i.copy)(this._normal, s), Object(i.scaleAndAdd)(s, y, s, -e * C), x) {
                  const F = Object(i.clone)(s), R = C > 0 ? V.left[V.left.length - 1] : V.right[V.right.length - 1], S = Object(i.clone)(y), N = Object(i.sub)(Object(i.create)(), R, S), Q = Object(i.sub)(Object(i.create)(), F, S), P = Math.PI / this.roundSegments;
                  for (let j = 0; j < this.roundSegments && (Object(i.rotate)(N, N, [0, 0], C * P), Math.sign(Object(i.cross)(s, N, Q)[2]) === C); j++)
                    Object(i.add)(s, N, S), o(V, s, C);
                  o(V, F, C);
                } else
                  o(V, s, C);
            } else
              h(V, y, X, K), Object(i.copy)(this._normal, X);
          }
        }
      }
      function o(r, V, W) {
        W > 0 ? r.left.push(Object(i.clone)(V)) : r.right.push(Object(i.clone)(V));
      }
      function h(r, V, W, y, t = -1) {
        Object(i.scaleAndAdd)(s, V, W, -y), o(r, s, -t), Object(i.scaleAndAdd)(s, V, W, y), o(r, s, t);
      }
      function p({
        left: r,
        right: V
      }, W) {
        const y = Object(i.create)(), t = Object(i.create)();
        let e = r[0], Z = V[0], a = [0.5 * (e[0] + Z[0]), 0.5 * (e[1] + Z[1])];
        Object(i.sub)(t, e, a);
        for (let x = 1; x <= W; x++) {
          const K = -1 * Math.PI * x / W;
          Object(i.rotate)(y, t, [0, 0], K), Object(i.add)(s, a, y), r.unshift(Object(i.clone)(s));
        }
        e = V[V.length - 1], Z = r[r.length - 1], a = [0.5 * (e[0] + Z[0]), 0.5 * (e[1] + Z[1])], Object(i.sub)(t, e, a);
        for (let x = 1; x <= W; x++) {
          const K = -1 * Math.PI * x / W;
          Object(i.rotate)(y, t, [0, 0], K), Object(i.add)(s, a, y), V.push(Object(i.clone)(s));
        }
      }
    },
    /* 59 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "isUnitTransform", function() {
        return i;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(s) {
        return s[0] === 1 && s[1] === 0 && s[2] === 0 && s[3] === 1 && s[4] === 0 && s[5] === 0;
      }
    },
    /* 60 */
    /***/
    function(b, d, l) {
      l(1).glMatrix.setMatrixArrayType(Array);
      var i = l(61), s = l(62);
      b.exports = function(c, m) {
        if (m = m || {}, c = c.filter(function(W) {
          return W.length > 2;
        }), c.length === 0)
          return {
            positions: [],
            cells: []
          };
        typeof m.vertexSize != "number" && (m.vertexSize = c[0][0].length), c = c.map(function(W) {
          return W.reduce(function(y, t) {
            return y.concat(t);
          });
        });
        const n = m.rule === "evenodd" ? i.WINDING_ODD : i.WINDING_NONZERO;
        for (var X = i.tesselate(s({
          contours: c,
          windingRule: n,
          elementType: i.POLYGONS,
          polySize: 3,
          vertexSize: 2
        }, m)), G = [], L = 0; L < X.vertices.length; L += m.vertexSize) {
          var o = X.vertices.slice(L, L + m.vertexSize);
          G.push(o);
        }
        var h = [];
        for (L = 0; L < X.elements.length; L += 3) {
          var p = X.elements[L], r = X.elements[L + 1], V = X.elements[L + 2];
          h.push([p, r, V]);
        }
        return {
          positions: G,
          cells: h
        };
      };
    },
    /* 61 */
    /***/
    function(b, d, l) {
      l(1).glMatrix.setMatrixArrayType(Array);
      var i = {}, s = {};
      b.exports = i, i.WINDING_ODD = 0, i.WINDING_NONZERO = 1, i.WINDING_POSITIVE = 2, i.WINDING_NEGATIVE = 3, i.WINDING_ABS_GEQ_TWO = 4, i.POLYGONS = 0, i.CONNECTED_POLYGONS = 1, i.BOUNDARY_CONTOURS = 2, i.tesselate = function(t) {
        for (var e = t.debug || !1, Z = new y(), a = 0; a < t.contours.length; a++)
          Z.addContour(t.vertexSize || 2, t.contours[a]);
        return Z.tesselate(t.windingRule || i.WINDING_ODD, t.elementType || i.POLYGONS, t.polySize || 3, t.vertexSize || 2, t.normal || [0, 0, 1]), {
          vertices: Z.vertices,
          vertexIndices: Z.vertexIndices,
          vertexCount: Z.vertexCount,
          elements: Z.elements,
          elementCount: Z.elementCount,
          mesh: e ? Z.mesh : void 0
        };
      };
      var c = function(t) {
        if (!t)
          throw "Assertion Failed!";
      };
      function m() {
        this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
      }
      function n() {
        this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1;
      }
      function X(t) {
        this.next = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Org = null, this.Lface = null, this.activeRegion = null, this.winding = 0, this.side = t;
      }
      X.prototype = {
        get Rface() {
          return this.Sym.Lface;
        },
        set Rface(t) {
          this.Sym.Lface = t;
        },
        get Dst() {
          return this.Sym.Org;
        },
        set Dst(t) {
          this.Sym.Org = t;
        },
        get Oprev() {
          return this.Sym.Lnext;
        },
        set Oprev(t) {
          this.Sym.Lnext = t;
        },
        get Lprev() {
          return this.Onext.Sym;
        },
        set Lprev(t) {
          this.Onext.Sym = t;
        },
        get Dprev() {
          return this.Lnext.Sym;
        },
        set Dprev(t) {
          this.Lnext.Sym = t;
        },
        get Rprev() {
          return this.Sym.Onext;
        },
        set Rprev(t) {
          this.Sym.Onext = t;
        },
        get Dnext() {
          return (
            /*this.Rprev*/
            this.Sym.Onext.Sym
          );
        },
        /* 3 pointers */
        set Dnext(t) {
          this.Sym.Onext.Sym = t;
        },
        /* 3 pointers */
        get Rnext() {
          return (
            /*this.Oprev*/
            this.Sym.Lnext.Sym
          );
        },
        /* 3 pointers */
        set Rnext(t) {
          this.Sym.Lnext.Sym = t;
        }
        /* 3 pointers */
      };
      function G() {
        var t = new m(), e = new n(), Z = new X(0), a = new X(1);
        t.next = t.prev = t, t.anEdge = null, e.next = e.prev = e, e.anEdge = null, e.trail = null, e.marked = !1, e.inside = !1, Z.next = Z, Z.Sym = a, Z.Onext = null, Z.Lnext = null, Z.Org = null, Z.Lface = null, Z.winding = 0, Z.activeRegion = null, a.next = a, a.Sym = Z, a.Onext = null, a.Lnext = null, a.Org = null, a.Lface = null, a.winding = 0, a.activeRegion = null, this.vHead = t, this.fHead = e, this.eHead = Z, this.eHeadSym = a;
      }
      G.prototype = {
        /* MakeEdge creates a new pair of half-edges which form their own loop.
        * No vertex or face structures are allocated, but these must be assigned
        * before the current edge operation is completed.
        */
        //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
        makeEdge_: function(t) {
          var e = new X(0), Z = new X(1);
          t.Sym.side < t.side && (t = t.Sym);
          var a = t.Sym.next;
          return Z.next = a, a.Sym.next = e, e.next = t, t.Sym.next = Z, e.Sym = Z, e.Onext = e, e.Lnext = Z, e.Org = null, e.Lface = null, e.winding = 0, e.activeRegion = null, Z.Sym = e, Z.Onext = Z, Z.Lnext = e, Z.Org = null, Z.Lface = null, Z.winding = 0, Z.activeRegion = null, e;
        },
        /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
        * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
        * a->Onext and b->Onext are exchanged.  This can have various effects
        * depending on whether a and b belong to different face or vertex rings.
        * For more explanation see tessMeshSplice() below.
        */
        // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
        splice_: function(t, e) {
          var Z = t.Onext, a = e.Onext;
          Z.Sym.Lnext = e, a.Sym.Lnext = t, t.Onext = a, e.Onext = Z;
        },
        /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
        * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
        * a place to insert the new vertex in the global vertex list.  We insert
        * the new vertex *before* vNext so that algorithms which walk the vertex
        * list will not see the newly created vertices.
        */
        //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
        makeVertex_: function(t, e, Z) {
          var a = t;
          c(a !== null);
          var x = Z.prev;
          a.prev = x, x.next = a, a.next = Z, Z.prev = a, a.anEdge = e;
          var K = e;
          do
            K.Org = a, K = K.Onext;
          while (K !== e);
        },
        /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
        * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
        * a place to insert the new face in the global face list.  We insert
        * the new face *before* fNext so that algorithms which walk the face
        * list will not see the newly created faces.
        */
        // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
        makeFace_: function(t, e, Z) {
          var a = t;
          c(a !== null);
          var x = Z.prev;
          a.prev = x, x.next = a, a.next = Z, Z.prev = a, a.anEdge = e, a.trail = null, a.marked = !1, a.inside = Z.inside;
          var K = e;
          do
            K.Lface = a, K = K.Lnext;
          while (K !== e);
        },
        /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
        * and removes from the global edge list.
        */
        //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
        killEdge_: function(t) {
          t.Sym.side < t.side && (t = t.Sym);
          var e = t.next, Z = t.Sym.next;
          e.Sym.next = Z, Z.Sym.next = e;
        },
        /* KillVertex( vDel ) destroys a vertex and removes it from the global
        * vertex list.  It updates the vertex loop to point to a given new vertex.
        */
        //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
        killVertex_: function(t, e) {
          var Z = t.anEdge, a = Z;
          do
            a.Org = e, a = a.Onext;
          while (a !== Z);
          var x = t.prev, K = t.next;
          K.prev = x, x.next = K;
        },
        /* KillFace( fDel ) destroys a face and removes it from the global face
        * list.  It updates the face loop to point to a given new face.
        */
        //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
        killFace_: function(t, e) {
          var Z = t.anEdge, a = Z;
          do
            a.Lface = e, a = a.Lnext;
          while (a !== Z);
          var x = t.prev, K = t.next;
          K.prev = x, x.next = K;
        },
        /****************** Basic Edge Operations **********************/
        /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
        * The loop consists of the two new half-edges.
        */
        //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
        makeEdge: function() {
          var t = new m(), e = new m(), Z = new n(), a = this.makeEdge_(this.eHead);
          return this.makeVertex_(t, a, this.vHead), this.makeVertex_(e, a.Sym, this.vHead), this.makeFace_(Z, a, this.fHead), a;
        },
        /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
        * mesh connectivity and topology.  It changes the mesh so that
        *	eOrg->Onext <- OLD( eDst->Onext )
        *	eDst->Onext <- OLD( eOrg->Onext )
        * where OLD(...) means the value before the meshSplice operation.
        *
        * This can have two effects on the vertex structure:
        *  - if eOrg->Org != eDst->Org, the two vertices are merged together
        *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
        * In both cases, eDst->Org is changed and eOrg->Org is untouched.
        *
        * Similarly (and independently) for the face structure,
        *  - if eOrg->Lface == eDst->Lface, one loop is split into two
        *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
        * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
        *
        * Some special cases:
        * If eDst == eOrg, the operation has no effect.
        * If eDst == eOrg->Lnext, the new face will have a single edge.
        * If eDst == eOrg->Lprev, the old face will have a single edge.
        * If eDst == eOrg->Onext, the new vertex will have a single edge.
        * If eDst == eOrg->Oprev, the old vertex will have a single edge.
        */
        //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
        splice: function(t, e) {
          var Z = !1, a = !1;
          if (t !== e) {
            if (e.Org !== t.Org && (a = !0, this.killVertex_(e.Org, t.Org)), e.Lface !== t.Lface && (Z = !0, this.killFace_(e.Lface, t.Lface)), this.splice_(e, t), !a) {
              var x = new m();
              this.makeVertex_(x, e, t.Org), t.Org.anEdge = t;
            }
            if (!Z) {
              var K = new n();
              this.makeFace_(K, e, t.Lface), t.Lface.anEdge = t;
            }
          }
        },
        /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
        * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
        * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
        * the newly created loop will contain eDel->Dst.  If the deletion of eDel
        * would create isolated vertices, those are deleted as well.
        *
        * This function could be implemented as two calls to tessMeshSplice
        * plus a few calls to memFree, but this would allocate and delete
        * unnecessary vertices and faces.
        */
        //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
        delete: function(t) {
          var e = t.Sym, Z = !1;
          if (t.Lface !== t.Rface && (Z = !0, this.killFace_(t.Lface, t.Rface)), t.Onext === t)
            this.killVertex_(t.Org, null);
          else if (t.Rface.anEdge = t.Oprev, t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev), !Z) {
            var a = new n();
            this.makeFace_(a, t, t.Lface);
          }
          e.Onext === e ? (this.killVertex_(e.Org, null), this.killFace_(e.Lface, null)) : (t.Lface.anEdge = e.Oprev, e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev)), this.killEdge_(t);
        },
        /******************** Other Edge Operations **********************/
        /* All these routines can be implemented with the basic edge
        * operations above.  They are provided for convenience and efficiency.
        */
        /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
        * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
        addEdgeVertex: function(t) {
          var e = this.makeEdge_(t), Z = e.Sym;
          this.splice_(e, t.Lnext), e.Org = t.Dst;
          var a = new m();
          return this.makeVertex_(a, Z, e.Org), e.Lface = Z.Lface = t.Lface, e;
        },
        /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
        * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
        splitEdge: function(t, e) {
          var Z = this.addEdgeVertex(t), a = Z.Sym;
          return this.splice_(t.Sym, t.Sym.Oprev), this.splice_(t.Sym, a), t.Dst = a.Org, a.Dst.anEdge = a.Sym, a.Rface = t.Rface, a.winding = t.winding, a.Sym.winding = t.Sym.winding, a;
        },
        /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
        * to eDst->Org, and returns the corresponding half-edge eNew.
        * If eOrg->Lface == eDst->Lface, this splits one loop into two,
        * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
        * loops are merged into one, and the loop eDst->Lface is destroyed.
        *
        * If (eOrg == eDst), the new face will have only two edges.
        * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
        * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
        */
        // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
        connect: function(t, e) {
          var Z = !1, a = this.makeEdge_(t), x = a.Sym;
          if (e.Lface !== t.Lface && (Z = !0, this.killFace_(e.Lface, t.Lface)), this.splice_(a, t.Lnext), this.splice_(x, e), a.Org = t.Dst, x.Org = e.Org, a.Lface = x.Lface = t.Lface, t.Lface.anEdge = x, !Z) {
            var K = new n();
            this.makeFace_(K, a, t.Lface);
          }
          return a;
        },
        /* tessMeshZapFace( fZap ) destroys a face and removes it from the
        * global face list.  All edges of fZap will have a NULL pointer as their
        * left face.  Any edges which also have a NULL pointer as their right face
        * are deleted entirely (along with any isolated vertices this produces).
        * An entire mesh can be deleted by zapping its faces, one at a time,
        * in any order.  Zapped faces cannot be used in further mesh operations!
        */
        zapFace: function(t) {
          var e = t.anEdge, Z, a, x, K, C;
          a = e.Lnext;
          do
            Z = a, a = Z.Lnext, Z.Lface = null, Z.Rface === null && (Z.Onext === Z ? this.killVertex_(Z.Org, null) : (Z.Org.anEdge = Z.Onext, this.splice_(Z, Z.Oprev)), x = Z.Sym, x.Onext === x ? this.killVertex_(x.Org, null) : (x.Org.anEdge = x.Onext, this.splice_(x, x.Oprev)), this.killEdge_(Z));
          while (Z != e);
          K = t.prev, C = t.next, C.prev = K, K.next = C;
        },
        countFaceVerts_: function(t) {
          var e = t.anEdge, Z = 0;
          do
            Z++, e = e.Lnext;
          while (e !== t.anEdge);
          return Z;
        },
        //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
        mergeConvexFaces: function(t) {
          var e, Z, a, x, K, C, T;
          for (e = this.fHead.next; e !== this.fHead; e = e.next)
            if (e.inside)
              for (Z = e.anEdge, K = Z.Org; a = Z.Lnext, x = Z.Sym, x && x.Lface && x.Lface.inside && (C = this.countFaceVerts_(e), T = this.countFaceVerts_(x.Lface), C + T - 2 <= t && s.vertCCW(Z.Lprev.Org, Z.Org, x.Lnext.Lnext.Org) && s.vertCCW(x.Lprev.Org, x.Org, Z.Lnext.Lnext.Org) && (a = x.Lnext, this.delete(x), Z = null, x = null)), !(Z && Z.Lnext.Org === K); )
                Z = a;
          return !0;
        },
        /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
        */
        check: function() {
          var t = this.fHead, e = this.vHead, Z = this.eHead, a, x, K, C, T, I;
          for (x = t, x = t; (a = x.next) !== t; x = a) {
            c(a.prev === x), T = a.anEdge;
            do
              c(T.Sym !== T), c(T.Sym.Sym === T), c(T.Lnext.Onext.Sym === T), c(T.Onext.Sym.Lnext === T), c(T.Lface === a), T = T.Lnext;
            while (T !== a.anEdge);
          }
          for (c(a.prev === x && a.anEdge === null), C = e, C = e; (K = C.next) !== e; C = K) {
            c(K.prev === C), T = K.anEdge;
            do
              c(T.Sym !== T), c(T.Sym.Sym === T), c(T.Lnext.Onext.Sym === T), c(T.Onext.Sym.Lnext === T), c(T.Org === K), T = T.Onext;
            while (T !== K.anEdge);
          }
          for (c(K.prev === C && K.anEdge === null), I = Z, I = Z; (T = I.next) !== Z; I = T)
            c(T.Sym.next === I.Sym), c(T.Sym !== T), c(T.Sym.Sym === T), c(T.Org !== null), c(T.Dst !== null), c(T.Lnext.Onext.Sym === T), c(T.Onext.Sym.Lnext === T);
          c(T.Sym.next === I.Sym && T.Sym === this.eHeadSym && T.Sym.Sym === T && T.Org === null && T.Dst === null && T.Lface === null && T.Rface === null);
        }
      }, s.vertEq = function(t, e) {
        return t.s === e.s && t.t === e.t;
      }, s.vertLeq = function(t, e) {
        return t.s < e.s || t.s === e.s && t.t <= e.t;
      }, s.transLeq = function(t, e) {
        return t.t < e.t || t.t === e.t && t.s <= e.s;
      }, s.edgeGoesLeft = function(t) {
        return s.vertLeq(t.Dst, t.Org);
      }, s.edgeGoesRight = function(t) {
        return s.vertLeq(t.Org, t.Dst);
      }, s.vertL1dist = function(t, e) {
        return Math.abs(t.s - e.s) + Math.abs(t.t - e.t);
      }, s.edgeEval = function(t, e, Z) {
        c(s.vertLeq(t, e) && s.vertLeq(e, Z));
        var a = e.s - t.s, x = Z.s - e.s;
        return a + x > 0 ? a < x ? e.t - t.t + (t.t - Z.t) * (a / (a + x)) : e.t - Z.t + (Z.t - t.t) * (x / (a + x)) : 0;
      }, s.edgeSign = function(t, e, Z) {
        c(s.vertLeq(t, e) && s.vertLeq(e, Z));
        var a = e.s - t.s, x = Z.s - e.s;
        return a + x > 0 ? (e.t - Z.t) * a + (e.t - t.t) * x : 0;
      }, s.transEval = function(t, e, Z) {
        c(s.transLeq(t, e) && s.transLeq(e, Z));
        var a = e.t - t.t, x = Z.t - e.t;
        return a + x > 0 ? a < x ? e.s - t.s + (t.s - Z.s) * (a / (a + x)) : e.s - Z.s + (Z.s - t.s) * (x / (a + x)) : 0;
      }, s.transSign = function(t, e, Z) {
        c(s.transLeq(t, e) && s.transLeq(e, Z));
        var a = e.t - t.t, x = Z.t - e.t;
        return a + x > 0 ? (e.s - Z.s) * a + (e.s - t.s) * x : 0;
      }, s.vertCCW = function(t, e, Z) {
        return t.s * (e.t - Z.t) + e.s * (Z.t - t.t) + Z.s * (t.t - e.t) >= 0;
      }, s.interpolate = function(t, e, Z, a) {
        return t = t < 0 ? 0 : t, Z = Z < 0 ? 0 : Z, t <= Z ? Z === 0 ? (e + a) / 2 : e + (a - e) * (t / (t + Z)) : a + (e - a) * (Z / (t + Z));
      }, s.intersect = function(t, e, Z, a, x) {
        var K, C, T;
        s.vertLeq(t, e) || (T = t, t = e, e = T), s.vertLeq(Z, a) || (T = Z, Z = a, a = T), s.vertLeq(t, Z) || (T = t, t = Z, Z = T, T = e, e = a, a = T), s.vertLeq(Z, e) ? s.vertLeq(e, a) ? (K = s.edgeEval(t, Z, e), C = s.edgeEval(Z, e, a), K + C < 0 && (K = -K, C = -C), x.s = s.interpolate(K, Z.s, C, e.s)) : (K = s.edgeSign(t, Z, e), C = -s.edgeSign(t, a, e), K + C < 0 && (K = -K, C = -C), x.s = s.interpolate(K, Z.s, C, a.s)) : x.s = (Z.s + e.s) / 2, s.transLeq(t, e) || (T = t, t = e, e = T), s.transLeq(Z, a) || (T = Z, Z = a, a = T), s.transLeq(t, Z) || (T = t, t = Z, Z = T, T = e, e = a, a = T), s.transLeq(Z, e) ? s.transLeq(e, a) ? (K = s.transEval(t, Z, e), C = s.transEval(Z, e, a), K + C < 0 && (K = -K, C = -C), x.t = s.interpolate(K, Z.t, C, e.t)) : (K = s.transSign(t, Z, e), C = -s.transSign(t, a, e), K + C < 0 && (K = -K, C = -C), x.t = s.interpolate(K, Z.t, C, a.t)) : x.t = (Z.t + e.t) / 2;
      };
      function L() {
        this.key = null, this.next = null, this.prev = null;
      }
      function o(t, e) {
        this.head = new L(), this.head.next = this.head, this.head.prev = this.head, this.frame = t, this.leq = e;
      }
      o.prototype = {
        min: function() {
          return this.head.next;
        },
        max: function() {
          return this.head.prev;
        },
        insert: function(t) {
          return this.insertBefore(this.head, t);
        },
        search: function(t) {
          var e = this.head;
          do
            e = e.next;
          while (e.key !== null && !this.leq(this.frame, t, e.key));
          return e;
        },
        insertBefore: function(t, e) {
          do
            t = t.prev;
          while (t.key !== null && !this.leq(this.frame, t.key, e));
          var Z = new L();
          return Z.key = e, Z.next = t.next, t.next.prev = Z, Z.prev = t, t.next = Z, Z;
        },
        delete: function(t) {
          t.next.prev = t.prev, t.prev.next = t.next;
        }
      };
      function h() {
        this.handle = null;
      }
      function p() {
        this.key = null, this.node = null;
      }
      function r(t, e) {
        this.size = 0, this.max = t, this.nodes = [], this.nodes.length = t + 1;
        var Z;
        for (Z = 0; Z < this.nodes.length; Z++)
          this.nodes[Z] = new h();
        for (this.handles = [], this.handles.length = t + 1, Z = 0; Z < this.handles.length; Z++)
          this.handles[Z] = new p();
        this.initialized = !1, this.freeList = 0, this.leq = e, this.nodes[1].handle = 1, this.handles[1].key = null;
      }
      r.prototype = {
        floatDown_: function(t) {
          var e = this.nodes, Z = this.handles, a, x, K;
          for (a = e[t].handle; ; ) {
            if (K = t << 1, K < this.size && this.leq(Z[e[K + 1].handle].key, Z[e[K].handle].key) && ++K, c(K <= this.max), x = e[K].handle, K > this.size || this.leq(Z[a].key, Z[x].key)) {
              e[t].handle = a, Z[a].node = t;
              break;
            }
            e[t].handle = x, Z[x].node = t, t = K;
          }
        },
        floatUp_: function(t) {
          var e = this.nodes, Z = this.handles, a, x, K;
          for (a = e[t].handle; ; ) {
            if (K = t >> 1, x = e[K].handle, K === 0 || this.leq(Z[x].key, Z[a].key)) {
              e[t].handle = a, Z[a].node = t;
              break;
            }
            e[t].handle = x, Z[x].node = t, t = K;
          }
        },
        init: function() {
          for (var t = this.size; t >= 1; --t)
            this.floatDown_(t);
          this.initialized = !0;
        },
        min: function() {
          return this.handles[this.nodes[1].handle].key;
        },
        /* really pqHeapInsert */
        /* returns INV_HANDLE iff out of memory */
        //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
        insert: function(t) {
          var e, Z;
          if (e = ++this.size, e * 2 > this.max) {
            this.max *= 2;
            var a, x;
            for (x = this.nodes.length, this.nodes.length = this.max + 1, a = x; a < this.nodes.length; a++)
              this.nodes[a] = new h();
            for (x = this.handles.length, this.handles.length = this.max + 1, a = x; a < this.handles.length; a++)
              this.handles[a] = new p();
          }
          return this.freeList === 0 ? Z = e : (Z = this.freeList, this.freeList = this.handles[Z].node), this.nodes[e].handle = Z, this.handles[Z].node = e, this.handles[Z].key = t, this.initialized && this.floatUp_(e), Z;
        },
        //PQkey pqHeapExtractMin( PriorityQHeap *pq )
        extractMin: function() {
          var t = this.nodes, e = this.handles, Z = t[1].handle, a = e[Z].key;
          return this.size > 0 && (t[1].handle = t[this.size].handle, e[t[1].handle].node = 1, e[Z].key = null, e[Z].node = this.freeList, this.freeList = Z, --this.size, this.size > 0 && this.floatDown_(1)), a;
        },
        delete: function(t) {
          var e = this.nodes, Z = this.handles, a;
          c(t >= 1 && t <= this.max && Z[t].key !== null), a = Z[t].node, e[a].handle = e[this.size].handle, Z[e[a].handle].node = a, --this.size, a <= this.size && (a <= 1 || this.leq(Z[e[a >> 1].handle].key, Z[e[a].handle].key) ? this.floatDown_(a) : this.floatUp_(a)), Z[t].key = null, Z[t].node = this.freeList, this.freeList = t;
        }
      };
      function V() {
        this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1;
      }
      var W = {};
      W.regionBelow = function(t) {
        return t.nodeUp.prev.key;
      }, W.regionAbove = function(t) {
        return t.nodeUp.next.key;
      }, W.debugEvent = function(t) {
      }, W.addWinding = function(t, e) {
        t.winding += e.winding, t.Sym.winding += e.Sym.winding;
      }, W.edgeLeq = function(t, e, Z) {
        var a = t.event, C, T, x = e.eUp, K = Z.eUp;
        if (x.Dst === a)
          return K.Dst === a ? s.vertLeq(x.Org, K.Org) ? s.edgeSign(K.Dst, x.Org, K.Org) <= 0 : s.edgeSign(x.Dst, K.Org, x.Org) >= 0 : s.edgeSign(K.Dst, a, K.Org) <= 0;
        if (K.Dst === a)
          return s.edgeSign(x.Dst, a, x.Org) >= 0;
        var C = s.edgeEval(x.Dst, a, x.Org), T = s.edgeEval(K.Dst, a, K.Org);
        return C >= T;
      }, W.deleteRegion = function(t, e) {
        e.fixUpperEdge && c(e.eUp.winding === 0), e.eUp.activeRegion = null, t.dict.delete(e.nodeUp);
      }, W.fixUpperEdge = function(t, e, Z) {
        c(e.fixUpperEdge), t.mesh.delete(e.eUp), e.fixUpperEdge = !1, e.eUp = Z, Z.activeRegion = e;
      }, W.topLeftRegion = function(t, e) {
        var Z = e.eUp.Org, a;
        do
          e = W.regionAbove(e);
        while (e.eUp.Org === Z);
        if (e.fixUpperEdge) {
          if (a = t.mesh.connect(W.regionBelow(e).eUp.Sym, e.eUp.Lnext), a === null)
            return null;
          W.fixUpperEdge(t, e, a), e = W.regionAbove(e);
        }
        return e;
      }, W.topRightRegion = function(t) {
        var e = t.eUp.Dst;
        do
          t = W.regionAbove(t);
        while (t.eUp.Dst === e);
        return t;
      }, W.addRegionBelow = function(t, e, Z) {
        var a = new V();
        return a.eUp = Z, a.nodeUp = t.dict.insertBefore(e.nodeUp, a), a.fixUpperEdge = !1, a.sentinel = !1, a.dirty = !1, Z.activeRegion = a, a;
      }, W.isWindingInside = function(t, e) {
        switch (t.windingRule) {
          case i.WINDING_ODD:
            return (e & 1) !== 0;
          case i.WINDING_NONZERO:
            return e !== 0;
          case i.WINDING_POSITIVE:
            return e > 0;
          case i.WINDING_NEGATIVE:
            return e < 0;
          case i.WINDING_ABS_GEQ_TWO:
            return e >= 2 || e <= -2;
        }
        return c(!1), !1;
      }, W.computeWinding = function(t, e) {
        e.windingNumber = W.regionAbove(e).windingNumber + e.eUp.winding, e.inside = W.isWindingInside(t, e.windingNumber);
      }, W.finishRegion = function(t, e) {
        var Z = e.eUp, a = Z.Lface;
        a.inside = e.inside, a.anEdge = Z, W.deleteRegion(t, e);
      }, W.finishLeftRegions = function(t, e, Z) {
        for (var a, C, x = null, K = e, C = e.eUp; K !== Z; ) {
          if (K.fixUpperEdge = !1, x = W.regionBelow(K), a = x.eUp, a.Org != C.Org) {
            if (!x.fixUpperEdge) {
              W.finishRegion(t, K);
              break;
            }
            a = t.mesh.connect(C.Lprev, a.Sym), W.fixUpperEdge(t, x, a);
          }
          C.Onext !== a && (t.mesh.splice(a.Oprev, a), t.mesh.splice(C, a)), W.finishRegion(t, K), C = x.eUp, K = x;
        }
        return C;
      }, W.addRightEdges = function(t, e, Z, a, x, K) {
        var C, T, I, J, F = !0;
        I = Z;
        do
          c(s.vertLeq(I.Org, I.Dst)), W.addRegionBelow(t, e, I.Sym), I = I.Onext;
        while (I !== a);
        for (x === null && (x = W.regionBelow(e).eUp.Rprev), T = e, J = x; C = W.regionBelow(T), I = C.eUp.Sym, I.Org === J.Org; )
          I.Onext !== J && (t.mesh.splice(I.Oprev, I), t.mesh.splice(J.Oprev, I)), C.windingNumber = T.windingNumber - I.winding, C.inside = W.isWindingInside(t, C.windingNumber), T.dirty = !0, !F && W.checkForRightSplice(t, T) && (W.addWinding(I, J), W.deleteRegion(t, T), t.mesh.delete(J)), F = !1, T = C, J = I;
        T.dirty = !0, c(T.windingNumber - I.winding === C.windingNumber), K && W.walkDirtyRegions(t, T);
      }, W.spliceMergeVertices = function(t, e, Z) {
        t.mesh.splice(e, Z);
      }, W.vertexWeights = function(t, e, Z) {
        var a = s.vertL1dist(e, t), x = s.vertL1dist(Z, t), K = 0.5 * x / (a + x), C = 0.5 * a / (a + x);
        t.coords[0] += K * e.coords[0] + C * Z.coords[0], t.coords[1] += K * e.coords[1] + C * Z.coords[1], t.coords[2] += K * e.coords[2] + C * Z.coords[2];
      }, W.getIntersectData = function(t, e, Z, a, x, K) {
        e.coords[0] = e.coords[1] = e.coords[2] = 0, e.idx = -1, W.vertexWeights(e, Z, a), W.vertexWeights(e, x, K);
      }, W.checkForRightSplice = function(t, e) {
        var Z = W.regionBelow(e), a = e.eUp, x = Z.eUp;
        if (s.vertLeq(a.Org, x.Org)) {
          if (s.edgeSign(x.Dst, a.Org, x.Org) > 0)
            return !1;
          s.vertEq(a.Org, x.Org) ? a.Org !== x.Org && (t.pq.delete(a.Org.pqHandle), W.spliceMergeVertices(t, x.Oprev, a)) : (t.mesh.splitEdge(x.Sym), t.mesh.splice(a, x.Oprev), e.dirty = Z.dirty = !0);
        } else {
          if (s.edgeSign(a.Dst, x.Org, a.Org) < 0)
            return !1;
          W.regionAbove(e).dirty = e.dirty = !0, t.mesh.splitEdge(a.Sym), t.mesh.splice(x.Oprev, a);
        }
        return !0;
      }, W.checkForLeftSplice = function(t, e) {
        var Z = W.regionBelow(e), a = e.eUp, x = Z.eUp, K;
        if (c(!s.vertEq(a.Dst, x.Dst)), s.vertLeq(a.Dst, x.Dst)) {
          if (s.edgeSign(a.Dst, x.Dst, a.Org) < 0)
            return !1;
          W.regionAbove(e).dirty = e.dirty = !0, K = t.mesh.splitEdge(a), t.mesh.splice(x.Sym, K), K.Lface.inside = e.inside;
        } else {
          if (s.edgeSign(x.Dst, a.Dst, x.Org) > 0)
            return !1;
          e.dirty = Z.dirty = !0, K = t.mesh.splitEdge(x), t.mesh.splice(a.Lnext, x.Sym), K.Rface.inside = e.inside;
        }
        return !0;
      }, W.checkForIntersect = function(t, e) {
        var Z = W.regionBelow(e), a = e.eUp, x = Z.eUp, K = a.Org, C = x.Org, T = a.Dst, I = x.Dst, J, F, R = new m(), S, N;
        if (c(!s.vertEq(I, T)), c(s.edgeSign(T, t.event, K) <= 0), c(s.edgeSign(I, t.event, C) >= 0), c(K !== t.event && C !== t.event), c(!e.fixUpperEdge && !Z.fixUpperEdge), K === C || (J = Math.min(K.t, T.t), F = Math.max(C.t, I.t), J > F))
          return !1;
        if (s.vertLeq(K, C)) {
          if (s.edgeSign(I, K, C) > 0)
            return !1;
        } else if (s.edgeSign(T, C, K) < 0)
          return !1;
        return W.debugEvent(t), s.intersect(T, K, I, C, R), c(Math.min(K.t, T.t) <= R.t), c(R.t <= Math.max(C.t, I.t)), c(Math.min(I.s, T.s) <= R.s), c(R.s <= Math.max(C.s, K.s)), s.vertLeq(R, t.event) && (R.s = t.event.s, R.t = t.event.t), S = s.vertLeq(K, C) ? K : C, s.vertLeq(S, R) && (R.s = S.s, R.t = S.t), s.vertEq(R, K) || s.vertEq(R, C) ? (W.checkForRightSplice(t, e), !1) : !s.vertEq(T, t.event) && s.edgeSign(T, t.event, R) >= 0 || !s.vertEq(I, t.event) && s.edgeSign(I, t.event, R) <= 0 ? I === t.event ? (t.mesh.splitEdge(a.Sym), t.mesh.splice(x.Sym, a), e = W.topLeftRegion(t, e), a = W.regionBelow(e).eUp, W.finishLeftRegions(t, W.regionBelow(e), Z), W.addRightEdges(t, e, a.Oprev, a, a, !0), !0) : T === t.event ? (t.mesh.splitEdge(x.Sym), t.mesh.splice(a.Lnext, x.Oprev), Z = e, e = W.topRightRegion(e), N = W.regionBelow(e).eUp.Rprev, Z.eUp = x.Oprev, x = W.finishLeftRegions(t, Z, null), W.addRightEdges(t, e, x.Onext, a.Rprev, N, !0), !0) : (s.edgeSign(T, t.event, R) >= 0 && (W.regionAbove(e).dirty = e.dirty = !0, t.mesh.splitEdge(a.Sym), a.Org.s = t.event.s, a.Org.t = t.event.t), s.edgeSign(I, t.event, R) <= 0 && (e.dirty = Z.dirty = !0, t.mesh.splitEdge(x.Sym), x.Org.s = t.event.s, x.Org.t = t.event.t), !1) : (t.mesh.splitEdge(a.Sym), t.mesh.splitEdge(x.Sym), t.mesh.splice(x.Oprev, a), a.Org.s = R.s, a.Org.t = R.t, a.Org.pqHandle = t.pq.insert(a.Org), W.getIntersectData(t, a.Org, K, T, C, I), W.regionAbove(e).dirty = e.dirty = Z.dirty = !0, !1);
      }, W.walkDirtyRegions = function(t, e) {
        for (var Z = W.regionBelow(e), a, x; ; ) {
          for (; Z.dirty; )
            e = Z, Z = W.regionBelow(Z);
          if (!e.dirty && (Z = e, e = W.regionAbove(e), e === null || !e.dirty))
            return;
          if (e.dirty = !1, a = e.eUp, x = Z.eUp, a.Dst !== x.Dst && W.checkForLeftSplice(t, e) && (Z.fixUpperEdge ? (W.deleteRegion(t, Z), t.mesh.delete(x), Z = W.regionBelow(e), x = Z.eUp) : e.fixUpperEdge && (W.deleteRegion(t, e), t.mesh.delete(a), e = W.regionAbove(Z), a = e.eUp)), a.Org !== x.Org)
            if (a.Dst !== x.Dst && !e.fixUpperEdge && !Z.fixUpperEdge && (a.Dst === t.event || x.Dst === t.event)) {
              if (W.checkForIntersect(t, e))
                return;
            } else
              W.checkForRightSplice(t, e);
          a.Org === x.Org && a.Dst === x.Dst && (W.addWinding(x, a), W.deleteRegion(t, e), t.mesh.delete(a), e = W.regionAbove(Z));
        }
      }, W.connectRightVertex = function(t, e, Z) {
        var a, x = Z.Onext, K = W.regionBelow(e), C = e.eUp, T = K.eUp, I = !1;
        if (C.Dst !== T.Dst && W.checkForIntersect(t, e), s.vertEq(C.Org, t.event) && (t.mesh.splice(x.Oprev, C), e = W.topLeftRegion(t, e), x = W.regionBelow(e).eUp, W.finishLeftRegions(t, W.regionBelow(e), K), I = !0), s.vertEq(T.Org, t.event) && (t.mesh.splice(Z, T.Oprev), Z = W.finishLeftRegions(t, K, null), I = !0), I) {
          W.addRightEdges(t, e, Z.Onext, x, x, !0);
          return;
        }
        s.vertLeq(T.Org, C.Org) ? a = T.Oprev : a = C, a = t.mesh.connect(Z.Lprev, a), W.addRightEdges(t, e, a, a.Onext, a.Onext, !1), a.Sym.activeRegion.fixUpperEdge = !0, W.walkDirtyRegions(t, e);
      }, W.connectLeftDegenerate = function(t, e, Z) {
        var a, x, K, C, T;
        if (a = e.eUp, s.vertEq(a.Org, Z)) {
          c(
            !1
            /*TOLERANCE_NONZERO*/
          ), W.spliceMergeVertices(t, a, Z.anEdge);
          return;
        }
        if (!s.vertEq(a.Dst, Z)) {
          t.mesh.splitEdge(a.Sym), e.fixUpperEdge && (t.mesh.delete(a.Onext), e.fixUpperEdge = !1), t.mesh.splice(Z.anEdge, a), W.sweepEvent(t, Z);
          return;
        }
        c(
          !1
          /*TOLERANCE_NONZERO*/
        ), e = W.topRightRegion(e), T = W.regionBelow(e), K = T.eUp.Sym, x = C = K.Onext, T.fixUpperEdge && (c(x !== K), W.deleteRegion(t, T), t.mesh.delete(K), K = x.Oprev), t.mesh.splice(Z.anEdge, K), s.edgeGoesLeft(x) || (x = null), W.addRightEdges(t, e, K.Onext, C, x, !0);
      }, W.connectLeftVertex = function(t, e) {
        var Z, a, x, K, C, T, I = new V();
        if (I.eUp = e.anEdge.Sym, Z = t.dict.search(I).key, a = W.regionBelow(Z), !!a) {
          if (K = Z.eUp, C = a.eUp, s.edgeSign(K.Dst, e, K.Org) === 0) {
            W.connectLeftDegenerate(t, Z, e);
            return;
          }
          if (x = s.vertLeq(C.Dst, K.Dst) ? Z : a, Z.inside || x.fixUpperEdge) {
            if (x === Z)
              T = t.mesh.connect(e.anEdge.Sym, K.Lnext);
            else {
              var J = t.mesh.connect(C.Dnext, e.anEdge);
              T = J.Sym;
            }
            x.fixUpperEdge ? W.fixUpperEdge(t, x, T) : W.computeWinding(t, W.addRegionBelow(t, Z, T)), W.sweepEvent(t, e);
          } else
            W.addRightEdges(t, Z, e.anEdge, e.anEdge, null, !0);
        }
      }, W.sweepEvent = function(t, e) {
        t.event = e, W.debugEvent(t);
        for (var Z = e.anEdge; Z.activeRegion === null; )
          if (Z = Z.Onext, Z === e.anEdge) {
            W.connectLeftVertex(t, e);
            return;
          }
        var a = W.topLeftRegion(t, Z.activeRegion);
        c(a !== null);
        var x = W.regionBelow(a), K = x.eUp, C = W.finishLeftRegions(t, x, null);
        C.Onext === K ? W.connectRightVertex(t, a, C) : W.addRightEdges(t, a, C.Onext, K, K, !0);
      }, W.addSentinel = function(t, e, Z, a) {
        var x = new V(), K = t.mesh.makeEdge();
        K.Org.s = Z, K.Org.t = a, K.Dst.s = e, K.Dst.t = a, t.event = K.Dst, x.eUp = K, x.windingNumber = 0, x.inside = !1, x.fixUpperEdge = !1, x.sentinel = !0, x.dirty = !1, x.nodeUp = t.dict.insert(x);
      }, W.initEdgeDict = function(t) {
        t.dict = new o(t, W.edgeLeq);
        var e = t.bmax[0] - t.bmin[0], Z = t.bmax[1] - t.bmin[1], a = t.bmin[0] - e, x = t.bmax[0] + e, K = t.bmin[1] - Z, C = t.bmax[1] + Z;
        W.addSentinel(t, a, x, K), W.addSentinel(t, a, x, C);
      }, W.doneEdgeDict = function(t) {
        for (var e, Z = 0; (e = t.dict.min().key) !== null; )
          e.sentinel || (c(e.fixUpperEdge), c(++Z === 1)), c(e.windingNumber === 0), W.deleteRegion(t, e);
      }, W.removeDegenerateEdges = function(t) {
        var e, Z, a, x = t.mesh.eHead;
        for (e = x.next; e !== x; e = Z)
          Z = e.next, a = e.Lnext, s.vertEq(e.Org, e.Dst) && e.Lnext.Lnext !== e && (W.spliceMergeVertices(t, a, e), t.mesh.delete(e), e = a, a = e.Lnext), a.Lnext === e && (a !== e && ((a === Z || a === Z.Sym) && (Z = Z.next), t.mesh.delete(a)), (e === Z || e === Z.Sym) && (Z = Z.next), t.mesh.delete(e));
      }, W.initPriorityQ = function(t) {
        var e, Z, a, x = 0;
        for (a = t.mesh.vHead, Z = a.next; Z !== a; Z = Z.next)
          x++;
        for (x += 8, e = t.pq = new r(x, s.vertLeq), a = t.mesh.vHead, Z = a.next; Z !== a; Z = Z.next)
          Z.pqHandle = e.insert(Z);
        return Z !== a ? !1 : (e.init(), !0);
      }, W.donePriorityQ = function(t) {
        t.pq = null;
      }, W.removeDegenerateFaces = function(t, e) {
        var Z, a, x;
        for (Z = e.fHead.next; Z !== e.fHead; Z = a)
          a = Z.next, x = Z.anEdge, c(x.Lnext !== x), x.Lnext.Lnext === x && (W.addWinding(x.Onext, x), t.mesh.delete(x));
        return !0;
      }, W.computeInterior = function(t) {
        var e, Z;
        if (W.removeDegenerateEdges(t), !W.initPriorityQ(t))
          return !1;
        for (W.initEdgeDict(t); (e = t.pq.extractMin()) !== null; ) {
          for (; Z = t.pq.min(), !(Z === null || !s.vertEq(Z, e)); )
            Z = t.pq.extractMin(), W.spliceMergeVertices(t, e.anEdge, Z.anEdge);
          W.sweepEvent(t, e);
        }
        return t.event = t.dict.min().key.eUp.Org, W.debugEvent(t), W.doneEdgeDict(t), W.donePriorityQ(t), W.removeDegenerateFaces(t, t.mesh) ? (t.mesh.check(), !0) : !1;
      };
      function y() {
        this.mesh = null, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = i.WINDING_ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
      }
      y.prototype = {
        dot_: function(t, e) {
          return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
        },
        normalize_: function(t) {
          var e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2];
          c(e > 0), e = Math.sqrt(e), t[0] /= e, t[1] /= e, t[2] /= e;
        },
        longAxis_: function(t) {
          var e = 0;
          return Math.abs(t[1]) > Math.abs(t[0]) && (e = 1), Math.abs(t[2]) > Math.abs(t[e]) && (e = 2), e;
        },
        computeNormal_: function(t) {
          var e, Z, a, x, K, C, T = [0, 0, 0], I = [0, 0, 0], J = [0, 0, 0], F = [0, 0, 0], R = [0, 0, 0], S = [null, null, null], N = [null, null, null], Q = this.mesh.vHead, P;
          for (e = Q.next, P = 0; P < 3; ++P)
            x = e.coords[P], I[P] = x, N[P] = e, T[P] = x, S[P] = e;
          for (e = Q.next; e !== Q; e = e.next)
            for (P = 0; P < 3; ++P)
              x = e.coords[P], x < I[P] && (I[P] = x, N[P] = e), x > T[P] && (T[P] = x, S[P] = e);
          if (P = 0, T[1] - I[1] > T[0] - I[0] && (P = 1), T[2] - I[2] > T[P] - I[P] && (P = 2), I[P] >= T[P]) {
            t[0] = 0, t[1] = 0, t[2] = 1;
            return;
          }
          for (C = 0, Z = N[P], a = S[P], J[0] = Z.coords[0] - a.coords[0], J[1] = Z.coords[1] - a.coords[1], J[2] = Z.coords[2] - a.coords[2], e = Q.next; e !== Q; e = e.next)
            F[0] = e.coords[0] - a.coords[0], F[1] = e.coords[1] - a.coords[1], F[2] = e.coords[2] - a.coords[2], R[0] = J[1] * F[2] - J[2] * F[1], R[1] = J[2] * F[0] - J[0] * F[2], R[2] = J[0] * F[1] - J[1] * F[0], K = R[0] * R[0] + R[1] * R[1] + R[2] * R[2], K > C && (C = K, t[0] = R[0], t[1] = R[1], t[2] = R[2]);
          C <= 0 && (t[0] = t[1] = t[2] = 0, t[this.longAxis_(J)] = 1);
        },
        checkOrientation_: function() {
          var t, e, Z = this.mesh.fHead, a, x = this.mesh.vHead, K;
          for (t = 0, e = Z.next; e !== Z; e = e.next)
            if (K = e.anEdge, !(K.winding <= 0))
              do
                t += (K.Org.s - K.Dst.s) * (K.Org.t + K.Dst.t), K = K.Lnext;
              while (K !== e.anEdge);
          if (t < 0) {
            for (a = x.next; a !== x; a = a.next)
              a.t = -a.t;
            this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
          }
        },
        /*	#ifdef FOR_TRITE_TEST_PROGRAM
          #include <stdlib.h>
          extern int RandomSweep;
          #define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
          #define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
          #else
          #if defined(SLANTED_SWEEP) */
        /* The "feature merging" is not intended to be complete.  There are
        * special cases where edges are nearly parallel to the sweep line
        * which are not implemented.  The algorithm should still behave
        * robustly (ie. produce a reasonable tesselation) in the presence
        * of such edges, however it may miss features which could have been
        * merged.  We could minimize this effect by choosing the sweep line
        * direction to be something unusual (ie. not parallel to one of the
        * coordinate axes).
        */
        /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
          #define S_UNIT_Y	(TESSreal)0.86052074622010633
          #else
          #define S_UNIT_X	(TESSreal)1.0
          #define S_UNIT_Y	(TESSreal)0.0
          #endif
          #endif*/
        /* Determine the polygon normal and project vertices onto the plane
        * of the polygon.
        */
        projectPolygon_: function() {
          var t, e = this.mesh.vHead, Z = [0, 0, 0], a, x, K, C, T = !1;
          for (Z[0] = this.normal[0], Z[1] = this.normal[1], Z[2] = this.normal[2], Z[0] === 0 && Z[1] === 0 && Z[2] === 0 && (this.computeNormal_(Z), T = !0), a = this.sUnit, x = this.tUnit, K = this.longAxis_(Z), a[K] = 0, a[(K + 1) % 3] = 1, a[(K + 2) % 3] = 0, x[K] = 0, x[(K + 1) % 3] = 0, x[(K + 2) % 3] = Z[K] > 0 ? 1 : -1, t = e.next; t !== e; t = t.next)
            t.s = this.dot_(t.coords, a), t.t = this.dot_(t.coords, x);
          for (T && this.checkOrientation_(), C = !0, t = e.next; t !== e; t = t.next)
            C ? (this.bmin[0] = this.bmax[0] = t.s, this.bmin[1] = this.bmax[1] = t.t, C = !1) : (t.s < this.bmin[0] && (this.bmin[0] = t.s), t.s > this.bmax[0] && (this.bmax[0] = t.s), t.t < this.bmin[1] && (this.bmin[1] = t.t), t.t > this.bmax[1] && (this.bmax[1] = t.t));
        },
        addWinding_: function(t, e) {
          t.winding += e.winding, t.Sym.winding += e.Sym.winding;
        },
        /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
        * (what else would it do??)  The region must consist of a single
        * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
        * case means that any vertical line intersects the interior of the
        * region in a single interval.  
        *
        * Tessellation consists of adding interior edges (actually pairs of
        * half-edges), to split the region into non-overlapping triangles.
        *
        * The basic idea is explained in Preparata and Shamos (which I don''t
        * have handy right now), although their implementation is more
        * complicated than this one.  The are two edge chains, an upper chain
        * and a lower chain.  We process all vertices from both chains in order,
        * from right to left.
        *
        * The algorithm ensures that the following invariant holds after each
        * vertex is processed: the untessellated region consists of two
        * chains, where one chain (say the upper) is a single edge, and
        * the other chain is concave.  The left vertex of the single edge
        * is always to the left of all vertices in the concave chain.
        *
        * Each step consists of adding the rightmost unprocessed vertex to one
        * of the two chains, and forming a fan of triangles from the rightmost
        * of two chain endpoints.  Determining whether we can add each triangle
        * to the fan is a simple orientation test.  By making the fan as large
        * as possible, we restore the invariant (check it yourself).
        */
        //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
        tessellateMonoRegion_: function(t, e) {
          var Z, a;
          for (Z = e.anEdge, c(Z.Lnext !== Z && Z.Lnext.Lnext !== Z); s.vertLeq(Z.Dst, Z.Org); Z = Z.Lprev)
            ;
          for (; s.vertLeq(Z.Org, Z.Dst); Z = Z.Lnext)
            ;
          for (a = Z.Lprev; Z.Lnext !== a; )
            if (s.vertLeq(Z.Dst, a.Org)) {
              for (; a.Lnext !== Z && (s.edgeGoesLeft(a.Lnext) || s.edgeSign(a.Org, a.Dst, a.Lnext.Dst) <= 0); ) {
                var x = t.connect(a.Lnext, a);
                a = x.Sym;
              }
              a = a.Lprev;
            } else {
              for (; a.Lnext !== Z && (s.edgeGoesRight(Z.Lprev) || s.edgeSign(Z.Dst, Z.Org, Z.Lprev.Org) >= 0); ) {
                var x = t.connect(Z, Z.Lprev);
                Z = x.Sym;
              }
              Z = Z.Lnext;
            }
          for (c(a.Lnext !== Z); a.Lnext.Lnext !== Z; ) {
            var x = t.connect(a.Lnext, a);
            a = x.Sym;
          }
          return !0;
        },
        /* tessMeshTessellateInterior( mesh ) tessellates each region of
        * the mesh which is marked "inside" the polygon.  Each such region
        * must be monotone.
        */
        //int tessMeshTessellateInterior( TESSmesh *mesh )
        tessellateInterior_: function(t) {
          var e, Z;
          for (e = t.fHead.next; e !== t.fHead; e = Z)
            if (Z = e.next, e.inside && !this.tessellateMonoRegion_(t, e))
              return !1;
          return !0;
        },
        /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
        * which are not marked "inside" the polygon.  Since further mesh operations
        * on NULL faces are not allowed, the main purpose is to clean up the
        * mesh so that exterior loops are not represented in the data structure.
        */
        //void tessMeshDiscardExterior( TESSmesh *mesh )
        discardExterior_: function(t) {
          var e, Z;
          for (e = t.fHead.next; e !== t.fHead; e = Z)
            Z = e.next, e.inside || t.zapFace(e);
        },
        /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
        * winding numbers on all edges so that regions marked "inside" the
        * polygon have a winding number of "value", and regions outside
        * have a winding number of 0.
        *
        * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
        * separate an interior region from an exterior one.
        */
        //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
        setWindingNumber_: function(t, e, Z) {
          var a, x;
          for (a = t.eHead.next; a !== t.eHead; a = x)
            x = a.next, a.Rface.inside !== a.Lface.inside ? a.winding = a.Lface.inside ? e : -e : Z ? t.delete(a) : a.winding = 0;
        },
        getNeighbourFace_: function(t) {
          return !t.Rface || !t.Rface.inside ? -1 : t.Rface.n;
        },
        outputPolymesh_: function(t, e, Z, a) {
          var x, K, C, T = 0, I = 0, J, F;
          for (Z > 3 && t.mergeConvexFaces(Z), x = t.vHead.next; x !== t.vHead; x = x.next)
            x.n = -1;
          for (K = t.fHead.next; K !== t.fHead; K = K.next)
            if (K.n = -1, !!K.inside) {
              C = K.anEdge, J = 0;
              do
                x = C.Org, x.n === -1 && (x.n = I, I++), J++, C = C.Lnext;
              while (C !== K.anEdge);
              c(J <= Z), K.n = T, ++T;
            }
          for (this.elementCount = T, e === i.CONNECTED_POLYGONS && (T *= 2), this.elements = [], this.elements.length = T * Z, this.vertexCount = I, this.vertices = [], this.vertices.length = I * a, this.vertexIndices = [], this.vertexIndices.length = I, x = t.vHead.next; x !== t.vHead; x = x.next)
            if (x.n !== -1) {
              var R = x.n * a;
              this.vertices[R + 0] = x.coords[0], this.vertices[R + 1] = x.coords[1], a > 2 && (this.vertices[R + 2] = x.coords[2]), this.vertexIndices[x.n] = x.idx;
            }
          var S = 0;
          for (K = t.fHead.next; K !== t.fHead; K = K.next)
            if (K.inside) {
              C = K.anEdge, J = 0;
              do
                x = C.Org, this.elements[S++] = x.n, J++, C = C.Lnext;
              while (C !== K.anEdge);
              for (F = J; F < Z; ++F)
                this.elements[S++] = -1;
              if (e === i.CONNECTED_POLYGONS) {
                C = K.anEdge;
                do
                  this.elements[S++] = this.getNeighbourFace_(C), C = C.Lnext;
                while (C !== K.anEdge);
                for (F = J; F < Z; ++F)
                  this.elements[S++] = -1;
              }
            }
        },
        //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
        outputContours_: function(t, e) {
          var Z, a, x, K = 0, C = 0;
          for (this.vertexCount = 0, this.elementCount = 0, Z = t.fHead.next; Z !== t.fHead; Z = Z.next)
            if (Z.inside) {
              x = a = Z.anEdge;
              do
                this.vertexCount++, a = a.Lnext;
              while (a !== x);
              this.elementCount++;
            }
          this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * e, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
          var T = 0, I = 0, J = 0;
          for (K = 0, Z = t.fHead.next; Z !== t.fHead; Z = Z.next)
            if (Z.inside) {
              C = 0, x = a = Z.anEdge;
              do
                this.vertices[T++] = a.Org.coords[0], this.vertices[T++] = a.Org.coords[1], e > 2 && (this.vertices[T++] = a.Org.coords[2]), this.vertexIndices[I++] = a.Org.idx, C++, a = a.Lnext;
              while (a !== x);
              this.elements[J++] = K, this.elements[J++] = C, K += C;
            }
        },
        addContour: function(t, e) {
          var Z, a;
          for (this.mesh === null && (this.mesh = new G()), t < 2 && (t = 2), t > 3 && (t = 3), Z = null, a = 0; a < e.length; a += t)
            Z === null ? (Z = this.mesh.makeEdge(), this.mesh.splice(Z, Z.Sym)) : (this.mesh.splitEdge(Z), Z = Z.Lnext), Z.Org.coords[0] = e[a + 0], Z.Org.coords[1] = e[a + 1], t > 2 ? Z.Org.coords[2] = e[a + 2] : Z.Org.coords[2] = 0, Z.Org.idx = this.vertexIndexCounter++, Z.winding = 1, Z.Sym.winding = -1;
        },
        //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
        tesselate: function(t, e, Z, a, x) {
          if (this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, x && (this.normal[0] = x[0], this.normal[1] = x[1], this.normal[2] = x[2]), this.windingRule = t, a < 2 && (a = 2), a > 3 && (a = 3), !this.mesh)
            return !1;
          this.projectPolygon_(), W.computeInterior(this);
          var K = this.mesh;
          return e === i.BOUNDARY_CONTOURS ? this.setWindingNumber_(K, 1, !0) : this.tessellateInterior_(K), K.check(), e === i.BOUNDARY_CONTOURS ? this.outputContours_(K, a) : this.outputPolymesh_(K, e, Z, a), !0;
        }
      };
    },
    /* 62 */
    /***/
    function(b, d) {
      b.exports = i;
      var l = Object.prototype.hasOwnProperty;
      function i() {
        for (var s = {}, c = 0; c < arguments.length; c++) {
          var m = arguments[c];
          for (var n in m)
            l.call(m, n) && (s[n] = m[n]);
        }
        return s;
      }
    },
    /* 63 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "createShaders", function() {
        return X;
      }), l.d(d, "applyShader", function() {
        return G;
      }), l.d(d, "createCloudShaders", function() {
        return o;
      }), l.d(d, "applyCloudShader", function() {
        return h;
      });
      var i = l(64), s = l(65), c = l(66), m = l(67);
      l(1).glMatrix.setMatrixArrayType(Array);
      const n = Symbol("shaders");
      function X(p) {
        p[n] = [];
        for (let r = 0; r < 16; r++) {
          const V = [], W = !!(r & 1), y = !!(r & 2), t = !!(r & 4), e = !!(r & 8);
          W && V.push("#define TEXTURE 1"), y && V.push("#define FILTER 1"), t && V.push("#define GRADIENT 1"), e && V.push("#define CLIPPATH 1");
          const Z = `${V.join(`
`)}
`, a = [];
          W && a.push("uniform sampler2D u_texSampler;"), e && a.push("uniform sampler2D u_clipSampler;"), p[n][r] = [Z + a.join(`
`) + s.default, Z + i.default];
        }
      }
      function G(p, {
        hasTexture: r = !1,
        hasFilter: V = !1,
        hasGradient: W = !1,
        hasClipPath: y = !1
      } = {}) {
        const t = r | V << 1 | W << 2 | y << 3;
        let e = p[n][t];
        Array.isArray(e) && (e = p.createProgram(...e), p[n][t] = e), p.program !== e && p.useProgram(e, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          }
        });
      }
      const L = [];
      function o(p) {
        for (let r = 0; r < 64; r++) {
          const V = [], W = !!(r & 1), y = !!(r & 2), t = !!(r & 4), e = !!(r & 8), Z = !!(r & 16), a = !!(r & 32);
          W && V.push("#define TEXTURE 1"), y && V.push("#define FILTER 1"), t && V.push("#define GRADIENT 1"), e && V.push("#define CLOUDCOLOR 1"), Z && V.push("#define CLOUDFILTER 1"), a && V.push("#define CLIPPATH 1");
          const x = `${V.join(`
`)}
`, K = [];
          if (W) {
            K.push("uniform sampler2D u_texSampler;");
            for (let C = 0; C < 12; C++)
              K.push(`uniform sampler2D u_texFrame${C};`);
          }
          a && K.push("uniform sampler2D u_clipSampler;"), L[r] = [x + K.join(`
`) + m.default, x + c.default];
        }
      }
      function h(p, {
        hasTexture: r = !1,
        hasFilter: V = !1,
        hasGradient: W = !1,
        hasCloudColor: y = !1,
        hasCloudFilter: t = !1,
        hasClipPath: e = !1
      } = {}) {
        const Z = r | V << 1 | W << 2 | y << 3 | t << 4 | e << 5;
        let a = L[Z];
        Array.isArray(a) && (a = p.createProgram(...a), L[Z] = a), p.program !== a && p.useProgram(a, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_fillCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_strokeCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_frameIndex: {
            type: "UNSIGNED_BYTE",
            normalize: !1
          }
        });
      }
    },
    /* 64 */
    /***/
    function(b, d, l) {
      l.r(d), d.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;
  vColor = a_color;

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif
}`;
    },
    /* 65 */
    /***/
    function(b, d, l) {
      l.r(d), d.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;
// uniform float u_radialGradientVector[6];

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

#ifdef FILTER
void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      vec4 texColor = texture2D(u_texSampler, texCoord.xy);
      float alpha = texColor.a;
      if(opacity < 1.0) {
        texColor.a *= opacity;
        alpha *= mix(0.465, 1.0, opacity);
      }
      // color = mix(color, texColor, texColor.a);
      color.rgb = mix(color.rgb, texColor.rgb, alpha);
      // color.rgb = mix(texColor.rgb, color.rgb, color.a);
      color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
      color.a = texColor.a + (1.0 - texColor.a) * color.a;
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 66 */
    /***/
    function(b, d, l) {
      l.r(d), d.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
attribute vec3 a_transform0;
attribute vec3 a_transform1;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute float a_frameIndex;
varying float frameIndex;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef CLOUDFILTER
attribute vec4 a_colorCloud0;
attribute vec4 a_colorCloud1;
attribute vec4 a_colorCloud2;
attribute vec4 a_colorCloud3;
attribute vec4 a_colorCloud4;
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef CLOUDCOLOR
attribute vec4 a_fillCloudColor;
attribute vec4 a_strokeCloudColor;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  mat3 modelMatrix = mat3(
    a_transform0.x, a_transform1.x, 0, 
    a_transform0.y, a_transform1.y, 0,
    a_transform0.z, a_transform1.z, 1
  );

  vec3 pos = projectionMatrix * viewMatrix * modelMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;

#ifdef CLOUDCOLOR
  if(flagBackground > 0.0) {
    vColor = mix(a_color, a_fillCloudColor, a_fillCloudColor.a);
  } else {
    vColor = mix(a_color, a_strokeCloudColor, a_strokeCloudColor.a);
  }
#else
  vColor = a_color;
#endif

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  frameIndex = a_frameIndex;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif

#ifdef CLOUDFILTER
  colorCloud0 = a_colorCloud0;
  colorCloud1 = a_colorCloud1;
  colorCloud2 = a_colorCloud2;
  colorCloud3 = a_colorCloud3;
  colorCloud4 = a_colorCloud4;
#endif
}`;
    },
    /* 67 */
    /***/
    function(b, d, l) {
      l.r(d), d.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying float frameIndex;
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef CLOUDFILTER
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}

#ifdef CLOUDFILTER
void buildCloudColor(inout float colorCloudMatrix[20]) {
  colorCloudMatrix[0] = colorCloud0[0];
  colorCloudMatrix[1] = colorCloud1[0];
  colorCloudMatrix[2] = colorCloud2[0];
  colorCloudMatrix[3] = colorCloud3[0];
  colorCloudMatrix[4] = colorCloud4[0];

  colorCloudMatrix[5] = colorCloud0[1];
  colorCloudMatrix[6] = colorCloud1[1];
  colorCloudMatrix[7] = colorCloud2[1];
  colorCloudMatrix[8] = colorCloud3[1];
  colorCloudMatrix[9] = colorCloud4[1];

  colorCloudMatrix[10] = colorCloud0[2];
  colorCloudMatrix[11] = colorCloud1[2];
  colorCloudMatrix[12] = colorCloud2[2];
  colorCloudMatrix[13] = colorCloud3[2];
  colorCloudMatrix[14] = colorCloud4[2];

  colorCloudMatrix[15] = colorCloud0[3];
  colorCloudMatrix[16] = colorCloud1[3];
  colorCloudMatrix[17] = colorCloud2[3];
  colorCloudMatrix[18] = colorCloud3[3];
  colorCloudMatrix[19] = colorCloud4[3];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      if(frameIndex < 0.0) {
        vec4 texColor = texture2D(u_texSampler, texCoord.xy);
        color = mix(color, texColor, texColor.a);
      } else {
        int index = int(floor(clamp(0.0, 11.0, frameIndex)));
        vec4 texColor;
        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);
        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);
        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);
        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);
        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);
        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);
        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);
        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);
        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);
        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);
        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);
        else texColor = texture2D(u_texFrame11, texCoord.xy);
        float alpha = texColor.a;
        if(opacity < 1.0) {
          texColor.a *= opacity;
          alpha *= mix(0.465, 1.0, opacity);
        }
        // color = mix(color, texColor, texColor.a);
        color.rgb = mix(color.rgb, texColor.rgb, alpha);
        // color.rgb = mix(texColor.rgb, color.rgb, color.a);
        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
        color.a = texColor.a + (1.0 - texColor.a) * color.a;
      }
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLOUDFILTER
  float colorCloudMatrix[20];
  buildCloudColor(colorCloudMatrix);
  transformColor(color, colorCloudMatrix);
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 68 */
    /***/
    function(b, d, l) {
      l.r(d), (function(i, s) {
        l.d(d, "requestAnimationFrame", function() {
          return m;
        }), l.d(d, "cancelAnimationFrame", function() {
          return n;
        }), l(1).glMatrix.setMatrixArrayType(Array);
        function c() {
          if (typeof performance < "u" && performance.now)
            return performance.now();
          if (typeof i < "u" && i.hrtime) {
            const [X, G] = i.hrtime();
            return X * 1e3 + G * 1e-6;
          }
          return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
        }
        let m, n;
        typeof s < "u" && typeof s.requestAnimationFrame == "function" ? (m = s.requestAnimationFrame, n = s.cancelAnimationFrame) : (m = function(X) {
          return setTimeout(() => {
            X(c());
          }, 16);
        }, n = function(X) {
          return clearTimeout(X);
        });
      }).call(this, l(69), l(22));
    },
    /* 69 */
    /***/
    function(b, d) {
      var l = b.exports = {}, i, s;
      function c() {
        throw new Error("setTimeout has not been defined");
      }
      function m() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? i = setTimeout : i = c;
        } catch {
          i = c;
        }
        try {
          typeof clearTimeout == "function" ? s = clearTimeout : s = m;
        } catch {
          s = m;
        }
      })();
      function n(y) {
        if (i === setTimeout)
          return setTimeout(y, 0);
        if ((i === c || !i) && setTimeout)
          return i = setTimeout, setTimeout(y, 0);
        try {
          return i(y, 0);
        } catch {
          try {
            return i.call(null, y, 0);
          } catch {
            return i.call(this, y, 0);
          }
        }
      }
      function X(y) {
        if (s === clearTimeout)
          return clearTimeout(y);
        if ((s === m || !s) && clearTimeout)
          return s = clearTimeout, clearTimeout(y);
        try {
          return s(y);
        } catch {
          try {
            return s.call(null, y);
          } catch {
            return s.call(this, y);
          }
        }
      }
      var G = [], L = !1, o, h = -1;
      function p() {
        !L || !o || (L = !1, o.length ? G = o.concat(G) : h = -1, G.length && r());
      }
      function r() {
        if (!L) {
          var y = n(p);
          L = !0;
          for (var t = G.length; t; ) {
            for (o = G, G = []; ++h < t; )
              o && o[h].run();
            h = -1, t = G.length;
          }
          o = null, L = !1, X(y);
        }
      }
      l.nextTick = function(y) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var e = 1; e < arguments.length; e++)
            t[e - 1] = arguments[e];
        G.push(new V(y, t)), G.length === 1 && !L && n(r);
      };
      function V(y, t) {
        this.fun = y, this.array = t;
      }
      V.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, l.title = "browser", l.browser = !0, l.env = {}, l.argv = [], l.version = "", l.versions = {};
      function W() {
      }
      l.on = W, l.addListener = W, l.once = W, l.off = W, l.removeListener = W, l.removeAllListeners = W, l.emit = W, l.prependListener = W, l.prependOnceListener = W, l.listeners = function(y) {
        return [];
      }, l.binding = function(y) {
        throw new Error("process.binding is not supported");
      }, l.cwd = function() {
        return "/";
      }, l.chdir = function(y) {
        throw new Error("process.chdir is not supported");
      }, l.umask = function() {
        return 0;
      };
    },
    /* 70 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return C;
      });
      var i = l(1), s = l(71), c = l(73), m = l(213), n = l(214), X = l(215), G = l(216);
      l(1).glMatrix.setMatrixArrayType(Array);
      function L(T, I) {
        var J = Object.keys(T);
        if (Object.getOwnPropertySymbols) {
          var F = Object.getOwnPropertySymbols(T);
          I && (F = F.filter(function(R) {
            return Object.getOwnPropertyDescriptor(T, R).enumerable;
          })), J.push.apply(J, F);
        }
        return J;
      }
      function o(T) {
        for (var I = 1; I < arguments.length; I++) {
          var J = arguments[I] != null ? arguments[I] : {};
          I % 2 ? L(Object(J), !0).forEach(function(F) {
            h(T, F, J[F]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(T, Object.getOwnPropertyDescriptors(J)) : L(Object(J)).forEach(function(F) {
            Object.defineProperty(T, F, Object.getOwnPropertyDescriptor(J, F));
          });
        }
        return T;
      }
      function h(T, I, J) {
        return I in T ? Object.defineProperty(T, I, { value: J, enumerable: !0, configurable: !0, writable: !0 }) : T[I] = J, T;
      }
      const p = Symbol.for("spritejs_changedAttrs"), r = Symbol.for("spritejs_attributes"), V = Symbol("resolution"), W = Symbol("animations"), y = Symbol("eventListeners"), t = Symbol("captureEventListeners"), e = Symbol("filters"), Z = Symbol("display"), a = Symbol("program"), x = Symbol("shaderAttrs"), K = Symbol("uniforms");
      class C {
        constructor(I = {}) {
          this.attributes = new this.constructor.Attr(this), this[V] = {
            width: 300,
            height: 150
          }, Object.assign(this.attributes, I), this[W] = /* @__PURE__ */ new Set(), this[y] = {}, this[t] = {};
        }
        get ancestors() {
          let I = this.parent;
          const J = [];
          for (; I; )
            J.push(I), I = I.parent;
          return J;
        }
        get animations() {
          return this[W];
        }
        get filters() {
          return this[e] || this.parent && this.parent.filters;
        }
        get isVisible() {
          return !1;
        }
        get layer() {
          return this.parent ? this.parent.layer : null;
        }
        get localMatrix() {
          const I = this.transformMatrix, {
            x: J,
            y: F
          } = this.attributes;
          return I[4] += J, I[5] += F, I;
        }
        get opacity() {
          let I = this.attributes.opacity;
          return this.parent && this.parent.opacity != null && (I *= this.parent.opacity), I;
        }
        get parentNode() {
          return this.parent;
        }
        get nextSibling() {
          return this.getNodeNearBy(1);
        }
        get previousSibling() {
          return this.getNodeNearBy(-1);
        }
        get program() {
          return this[a];
        }
        /* get parent defined by connect method */
        get renderer() {
          return this.parent ? this.parent.renderer : null;
        }
        get renderMatrix() {
          if (this.__cacheRenderMatrix)
            return this.__cacheRenderMatrix;
          let I = this.localMatrix;
          const J = this.parent;
          if (J) {
            const F = J.__cacheRenderMatrix || J.renderMatrix;
            F && (I = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), F, I));
          }
          return I;
        }
        get worldScaling() {
          const I = this.renderMatrix;
          return [Math.hypot(I[0], I[1]), Math.hypot(I[2], I[3])];
        }
        get worldRotation() {
          const I = this.renderMatrix;
          return Math.atan2(I[1], I[3]);
        }
        get worldPosition() {
          const I = this.renderMatrix;
          return [I[4], I[5]];
        }
        get uniforms() {
          return this[K];
        }
        /* get zOrder defined by connect method */
        /* attributes */
        get className() {
          return this.attributes.className;
        }
        set className(I) {
          this.attributes.className = I;
        }
        get id() {
          return this.attributes.id;
        }
        set id(I) {
          this.attributes.id = I;
        }
        get name() {
          return this.attributes.name;
        }
        set name(I) {
          this.attributes.name = I;
        }
        get zIndex() {
          return this.attributes.zIndex;
        }
        set zIndex(I) {
          this.attributes.zIndex = I;
        }
        get mesh() {
          return null;
        }
        get shaderAttrs() {
          return this[x] || {};
        }
        activateAnimations() {
          const I = this.layer;
          if (I) {
            const J = this[W];
            J.forEach((R) => {
              R.baseTimeline = I.timeline, R.play(), R.finished.then(() => {
                J.delete(R);
              });
            });
            const F = this.children;
            F && F.forEach((R) => {
              R.activateAnimations && R.activateAnimations();
            });
          }
        }
        addEventListener(I, J, F = {}) {
          I === "mousewheel" && (I = "wheel"), typeof F == "boolean" && (F = {
            capture: F
          });
          const {
            capture: R,
            once: S
          } = F, N = R ? t : y;
          return this[N][I] = this[N][I] || [], this[N][I].push({
            listener: J,
            once: S
          }), this;
        }
        animate(I, J) {
          const F = new c.default(this, I, J);
          return this.effects && F.applyEffects(this.effects), this.layer && (F.baseTimeline = this.layer.timeline, F.play(), F.finished.then(() => {
            this[W].delete(F);
          })), this[W].add(F), F;
        }
        attr(...I) {
          if (I.length === 0)
            return this.attributes[r];
          if (I.length > 1) {
            let [J, F] = I;
            return typeof F == "function" && (F = F(this.attr(J))), this.setAttribute(J, F), this;
          }
          return typeof I[0] == "string" ? this.getAttribute(I[0]) : (Object.assign(this.attributes, I[0]), this);
        }
        cloneNode() {
          const I = new this.constructor(), J = this.attributes[p];
          return I.attr(J), I;
        }
        connect(I, J) {
          Object.defineProperty(this, "parent", {
            value: I,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: J,
            writable: !1,
            configurable: !0
          }), I.timeline && this.activateAnimations(), this.setResolution(I.getResolution()), this.forceUpdate(), this.dispatchEvent({
            type: "append",
            detail: {
              parent: I,
              zOrder: J
            }
          });
        }
        contains(I) {
          for (; I && this !== I; )
            I = I.parent;
          return !!I;
        }
        deactivateAnimations() {
          this[W].forEach((J) => J.cancel());
          const I = this.children;
          I && I.forEach((J) => {
            J.deactivateAnimations && J.deactivateAnimations();
          });
        }
        disconnect() {
          const {
            parent: I,
            zOrder: J
          } = this;
          delete this.parent, delete this.zOrder, this.deactivateAnimations(), this.dispatchEvent({
            type: "remove",
            detail: {
              parent: I,
              zOrder: J
            }
          }), I && I.forceUpdate();
        }
        dispatchEvent(I) {
          I instanceof n.default || (I = new n.default(I)), I.target = this;
          let J = I.type;
          J === "mousewheel" && (J = "wheel");
          const F = [this];
          let R = this.parent;
          for (; I.bubbles && R; )
            F.push(R), R = R.parent;
          for (let S = F.length - 1; S >= 0; S--) {
            const N = F[S], Q = N[t] && N[t][J];
            if (Q && Q.length && (I.currentTarget = N, Q.forEach(({
              listener: P,
              once: j
            }) => {
              P.call(this, I), j && F.removeEventListener(P);
            }), delete I.currentTarget), !I.bubbles && I.cancelBubble)
              break;
          }
          if (!I.cancelBubble)
            for (let S = 0; S < F.length; S++) {
              const N = F[S], Q = N[y] && N[y][J];
              if (Q && Q.length && (I.currentTarget = N, Q.forEach(({
                listener: P,
                once: j
              }) => {
                P.call(this, I), j && F.removeEventListener(P);
              }), delete I.currentTarget), !I.bubbles || I.cancelBubble)
                break;
            }
        }
        dispatchPointerEvent(I) {
          const {
            layerX: J,
            layerY: F
          } = I;
          return this.isPointCollision(J, F) ? (this.dispatchEvent(I), !0) : !1;
        }
        draw(I = []) {
          const J = this.mesh;
          if (J) {
            if (Object(X.applyFilters)(J, this.filters), I.push(J), this[a]) {
              J.setProgram(this[a]);
              const F = this[x];
              F && Object.entries(F).forEach(([S, N]) => {
                J.setAttribute(S, N);
              });
              const R = this[K];
              if (this[K]) {
                const S = {};
                Object.entries(R).forEach(([N, Q]) => {
                  typeof Q == "function" && (Q = Q(this, N)), S[N] = Q;
                }), J.setUniforms(S);
              }
            }
            Object(G.default)(this, J);
          }
          return I;
        }
        forceUpdate() {
          this.parent && this.parent.forceUpdate();
        }
        getAttribute(I) {
          return this.attributes[I];
        }
        getListeners(I, {
          capture: J = !1
        } = {}) {
          return [...this[J ? t : y][I] || []];
        }
        getNodeNearBy(I = 1) {
          if (!this.parent)
            return null;
          if (I === 0)
            return this;
          const J = this.parent.children, F = J.indexOf(this);
          return J[F + I];
        }
        getWorldPosition(I, J) {
          const F = this.renderMatrix, R = I * F[0] + J * F[2] + F[4], S = I * F[1] + J * F[3] + F[5];
          return [R, S];
        }
        getOffsetPosition(I, J) {
          const F = i.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this.renderMatrix), R = I * F[0] + J * F[2] + F[4], S = I * F[1] + J * F[3] + F[5];
          return [R, S];
        }
        getResolution() {
          return o({}, this[V]);
        }
        isPointCollision(I, J) {
          if (!this.mesh)
            return !1;
          const F = this.attributes.pointerEvents;
          if (F === "none" || F !== "all" && !this.isVisible)
            return !1;
          let R = "both";
          return F === "visibleFill" && (R = "fill"), F === "visibleStroke" && (R = "stroke"), this.mesh.isPointCollision(I, J, R);
        }
        onPropertyChange(I, J, F) {
          I !== "id" && I !== "name" && I !== "className" && I !== "pointerEvents" && I !== "passEvents" && this.forceUpdate(), I === "filter" && (this[e] = Object(X.parseFilterString)(J)), I === "zIndex" && this.parent && this.parent.reorder();
        }
        setAttribute(I, J) {
          I === "attrs" && this.attr(J), this.attributes[I] = J;
        }
        setMouseCapture() {
          this.layer && (this.layer.__mouseCapturedTarget = this);
        }
        // layer.renderer.createProgram(fragmentShader, vertexShader, attributeOptions)
        setProgram(I) {
          this[a] = I, this.forceUpdate();
        }
        setShaderAttribute(I, J) {
          this[x] = this[x] || {}, this[x][I] = J, this.forceUpdate();
        }
        setUniforms(I) {
          this[K] = this[K] || {}, Object.assign(this[K], I), this.forceUpdate();
        }
        setResolution({
          width: I,
          height: J
        }) {
          const {
            width: F,
            height: R
          } = this[V];
          (F !== I || R !== J) && (this[V] = {
            width: I,
            height: J
          }, this.forceUpdate(), this.dispatchEvent({
            type: "resolutionchange",
            detail: {
              width: I,
              height: J
            }
          }));
        }
        show() {
          this.attributes.display === "none" && (this.attributes.display = this[Z] || "");
        }
        hide() {
          this.attributes.display !== "none" && (this[Z] = this.attributes.display, this.attributes.display = "none");
        }
        releaseMouseCapture() {
          this.layer && this.layer.__mouseCapturedTarget === this && (this.layer.__mouseCapturedTarget = null);
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        removeAllListeners(I, J = {}) {
          typeof J == "boolean" && (J = {
            capture: J
          });
          const R = J.capture ? t : y;
          return this[R][I] && (this[R][I] = []), this;
        }
        removeAttribute(I) {
          this.setAttribute(I, null);
        }
        removeEventListener(I, J, F = {}) {
          typeof F == "boolean" && (F = {
            capture: F
          });
          const S = F.capture ? t : y;
          if (this[S][I]) {
            const N = this[S][I];
            if (N)
              for (let Q = 0; Q < N.length; Q++) {
                const {
                  listener: P
                } = N[Q];
                if (P === J) {
                  this[S][I].splice(Q, 1);
                  break;
                }
              }
          }
          return this;
        }
        transition(I, J = "linear") {
          const F = this, R = Symbol("animation");
          J = J || "linear";
          let S = 0;
          return typeof I == "object" && (S = I.delay || 0, I = I.duration), {
            [R]: null,
            cancel(N = !1) {
              const Q = this[R];
              Q && Q.cancel(N);
            },
            end() {
              const N = this[R];
              N && (N.playState === "running" || N.playState === "pending") && N.finish();
            },
            reverse() {
              const N = this[R];
              if (N)
                if (N.playState === "running" || N.playState === "pending")
                  N.playbackRate = -N.playbackRate;
                else {
                  const Q = N.timing.direction;
                  N.timing.direction = Q === "reverse" ? "normal" : "reverse", N.play();
                }
              return N.finished;
            },
            attr(N, Q) {
              return this.end(), typeof N == "string" && (N = {
                [N]: Q
              }), Object.entries(N).forEach(([P, j]) => {
                typeof j == "function" && (N[P] = j(F.attr(P)));
              }), this[R] = F.animate([N], {
                duration: I * 1e3,
                delay: S * 1e3,
                fill: "forwards",
                easing: J
              }), this[R].finished;
            }
          };
        }
        updateContours() {
        }
      }
      h(C, "Attr", s.default), m.default.registerNode(C, "node");
    },
    /* 71 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return C;
      });
      var i = l(1), s = l(12), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_declareAlias"), X = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), L = Symbol.for("spritejs_attributes"), o = Symbol.for("spritejs_changedAttrs"), h = Symbol("subject"), p = Symbol("attr"), r = Symbol("default"), V = Symbol("alias");
      function W(T, [I, J]) {
        let F = i.mat2d.fromValues(1, 0, 0, 1, 0, 0);
        return [...T].forEach(([R, S]) => {
          if ((I || J) && (F = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [I, J])), R === "matrix")
            F = i.mat2d.multiply(F, F, S);
          else if (R === "offsetTranslate")
            F[4] += S[0], F[5] += S[1];
          else if (R === "offsetRotate")
            F = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), F, S);
          else if (R === "skew") {
            const [N, Q] = S;
            F = i.mat2d.multiply(F, F, i.mat2d.fromValues(1, Math.tan(Q), Math.tan(N), 1, 0, 0));
          } else
            i.mat2d[R](F, F, S);
          (I || J) && (F = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [-I, -J]));
        }), F;
      }
      const y = Symbol("transformMatrix"), t = Symbol("transforms"), e = Symbol("changedAttrs"), Z = Symbol("lastChangedAttr"), a = Symbol("offsetFigure");
      function x(T, I, J) {
        const F = T[p][I];
        if (T[X](I, J, !1) || T[Z] !== I) {
          const S = T[t];
          S.has(I) && S.delete(I), J && (I === "rotate" && (J = Math.PI * J / 180), I === "scale" && (J = J.map((N) => Math.abs(N) > 1e-5 ? N : 1 / N > 0 ? 1e-5 : -1e-5)), S.set(I, J)), T[y] = null, T[h].onPropertyChange(I, J, F, T);
        }
      }
      function K(T) {
        const I = T[a], J = T.offsetDistance * I.getTotalLength(), F = I.getPointAtLength(J);
        if (F) {
          const R = T[t];
          let S = T.offsetRotate;
          S === "auto" ? S = F.angle : S === "reverse" ? S = Math.PI + F.angle : S = Math.PI * S / 180, R.set("offsetRotate", S), R.set("offsetTranslate", [F.x, F.y]), T[y] = null;
        }
      }
      class C {
        static setDefault(I, ...J) {
          return I[m](...J);
        }
        static declareAlias(I, ...J) {
          return I[n](...J);
        }
        static setAttribute(I, ...J) {
          return I[X](...J);
        }
        static getAttribute(I, ...J) {
          return I[G](...J);
        }
        static getAttributes(I) {
          return I[L];
        }
        static getChangedAttributes(I) {
          return I[o];
        }
        constructor(I) {
          this[h] = I, this[p] = {}, this[y] = i.mat2d.fromValues(1, 0, 0, 1, 0, 0), this[t] = /* @__PURE__ */ new Map(), this[r] = {}, this[V] = [], Object.defineProperty(I, "transformMatrix", {
            get: () => (this[y] || (this[y] = W(this[t], this.transformOrigin)), [...this[y]])
          }), this[m]({
            id: "",
            name: "",
            className: "",
            /* class */
            x: 0,
            y: 0,
            /* pos */
            transformOrigin: [0, 0],
            transform: "",
            translate: [0, 0],
            rotate: 0,
            scale: [1, 1],
            skew: [0, 0],
            opacity: 1,
            zIndex: 0,
            offsetPath: void 0,
            offsetDistance: 0,
            offsetRotate: "auto",
            pointerEvents: "visible",
            // none | visible | visibleFill | visibleStroke | all
            filter: "none",
            display: ""
          }), this[n]("class", "pos"), this[e] = /* @__PURE__ */ new Set(), this[a] = new s.Figure2D({
            scale: 5,
            simplify: 0
          });
        }
        get [o]() {
          const I = {};
          return [...this[e]].forEach((J) => {
            I[J] = this[p][J];
          }), I;
        }
        get [L]() {
          const I = Object.assign({}, this[p]);
          for (let J = 0; J < this[V].length; J++) {
            const F = this[V][J];
            I[F] = this[F];
          }
          return I;
        }
        [m](I) {
          Object.assign(this[r], I), Object.assign(this[p], I);
        }
        [n](...I) {
          this[V].push(...I);
        }
        [X](I, J, F = !0) {
          const R = this[p][I], S = this[h];
          return J == null && (J = this[r][I]), Object(c.compareValue)(R, J) ? !1 : (this[p][I] = J, this[e].has(I) && this[e].delete(I), this[e].add(I), this[Z] = I, F && S.onPropertyChange(I, J, R, this), !0);
        }
        [G](I) {
          return this[p][I];
        }
        set id(I) {
          this[X]("id", I);
        }
        get id() {
          return this[G]("id");
        }
        set name(I) {
          this[X]("name", I);
        }
        get name() {
          return this[G]("name");
        }
        set className(I) {
          this[X]("className", I);
        }
        get className() {
          return this[G]("className");
        }
        set class(I) {
          this.className = I;
        }
        get class() {
          return this.className;
        }
        get x() {
          return this[G]("x");
        }
        set x(I) {
          this[X]("x", Object(c.toNumber)(I));
        }
        get y() {
          return this[G]("y");
        }
        set y(I) {
          this[X]("y", Object(c.toNumber)(I));
        }
        get pos() {
          return [this.x, this.y];
        }
        set pos(I) {
          I = Object(c.toArray)(I), Array.isArray(I) || (I = [I, I]), this.x = I[0], this.y = I[1];
        }
        get transform() {
          return this[G]("transform");
        }
        set transform(I) {
          let J = null;
          if (Array.isArray(I) && (J = I, I = `matrix(${I.map(c.toNumber).join()})`), typeof I == "string")
            I = I.replace(/\s*,\s*/g, ",");
          else if (I != null)
            throw new TypeError("Invalid transform value.");
          const F = this[p].transform;
          if (this[X]("transform", I, !1)) {
            const R = this[t];
            if (R.has("matrix") && R.delete("matrix"), J)
              R.set("matrix", J);
            else if (I) {
              const S = I.match(/(matrix|translate|rotate|scale|skew)\([^()]+\)/g);
              if (S) {
                let N = i.mat2d.fromValues(1, 0, 0, 1, 0, 0);
                for (let Q = 0; Q < S.length; Q++) {
                  const j = S[Q].match(/^(matrix|translate|rotate|scale|skew)\(([^()]+)\)/);
                  if (j) {
                    let [, D, z] = j;
                    D === "rotate" ? z = Math.PI * parseFloat(z) / 180 : z = z.trim().split(/[\s,]+/).map((w) => Object(c.toNumber)(w)), D === "matrix" ? N = i.mat2d.multiply(N, N, z) : D === "skew" ? N = i.mat2d.multiply(N, N, i.mat2d.fromValues(1, Math.tan(z[1]), Math.tan(z[0]), 1, 0, 0)) : i.mat2d[D](N, N, z), R.set("matrix", N);
                  }
                }
              } else
                throw new TypeError("Invalid transform value.");
            }
            this[y] = null, this[h].onPropertyChange("transform", I, F, this);
          }
        }
        get transformOrigin() {
          return this[G]("transformOrigin");
        }
        set transformOrigin(I) {
          I = Object(c.toArray)(I, !0), I != null && !Array.isArray(I) && (I = [I, I]), this[X]("transformOrigin", I) && (this[y] = null);
        }
        get rotate() {
          return this[G]("rotate");
        }
        set rotate(I) {
          x(this, "rotate", I);
        }
        get translate() {
          return this[G]("translate");
        }
        set translate(I) {
          I = Object(c.toArray)(I, !0), I != null && !Array.isArray(I) && (I = [I, I]), x(this, "translate", I);
        }
        get scale() {
          return this[G]("scale");
        }
        set scale(I) {
          I = Object(c.toArray)(I, !0), I != null && !Array.isArray(I) && (I = [I, I]), x(this, "scale", I);
        }
        get skew() {
          return this[G]("skew");
        }
        set skew(I) {
          I = Object(c.toArray)(I, !0), I != null && !Array.isArray(I) && (I = [I, I]), x(this, "skew", I);
        }
        get opacity() {
          return this[G]("opacity");
        }
        set opacity(I) {
          I != null && (I = Number(I)), this[X]("opacity", I);
        }
        get zIndex() {
          return this[G]("zIndex");
        }
        set zIndex(I) {
          I != null && (I = Number(I)), this[X]("zIndex", I);
        }
        get offsetPath() {
          return this[G]("offsetPath");
        }
        set offsetPath(I) {
          this[X]("offsetPath", I) && (this[a].beginPath(), I != null && this[a].addPath(I), K(this));
        }
        get offsetDistance() {
          return this[G]("offsetDistance");
        }
        set offsetDistance(I) {
          this[X]("offsetDistance", Object(c.toNumber)(I)) && K(this);
        }
        get offsetRotate() {
          return this[G]("offsetRotate");
        }
        set offsetRotate(I) {
          this[X]("offsetRotate", I), K(this);
        }
        get pointerEvents() {
          return this[G]("pointerEvents");
        }
        set pointerEvents(I) {
          if (I != null && I !== "none" && I !== "visible" && I !== "visibleFill" && I !== "visibleStroke" && I !== "all")
            throw new TypeError("Invalid pointerEvents type.");
          this[X]("pointerEvents", I);
        }
        get filter() {
          return this[G]("filter");
        }
        set filter(I) {
          this[X]("filter", I);
        }
        get display() {
          return this[G]("display");
        }
        set display(I) {
          this[X]("display", I);
        }
        /* istanbul ignore next */
        set offset(I) {
        }
      }
    },
    /* 72 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "sizeToPixel", function() {
        return i;
      }), l.d(d, "toString", function() {
        return s;
      }), l.d(d, "toNumber", function() {
        return c;
      }), l.d(d, "toArray", function() {
        return m;
      }), l.d(d, "compareValue", function() {
        return n;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(X, G) {
        const L = X.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/);
        L ? X = {
          size: parseFloat(L[1]),
          unit: L[2]
        } : X = {
          size: parseFloat(X),
          unit: "px"
        };
        let {
          size: o,
          unit: h
        } = X;
        if (h === "pt")
          o /= 0.75;
        else if (h === "pc")
          o *= 16;
        else if (h === "in")
          o *= 96;
        else if (h === "cm")
          o *= 96 / 2.54;
        else if (h === "mm")
          o *= 96 / 25.4;
        else if (h === "em" || h === "rem" || h === "ex") {
          if (!G && typeof getComputedStyle == "function" && typeof document < "u") {
            const p = getComputedStyle(document.documentElement).fontSize;
            p ? G = i(p, 16) : G = 16;
          }
          o *= G, h === "ex" && (o /= 2);
        } else if (h === "q")
          o *= 96 / 25.4 / 4;
        else if (h === "vw" || h === "vh") {
          if (typeof document < "u") {
            const p = h === "vw" ? window.innerWidth || document.documentElement.clientWidth : window.innerHeight || document.documentElement.clientHeight;
            o *= p / 100;
          }
        } else if ((h === "vmax" || h === "vmin") && typeof document < "u") {
          const p = window.innerWidth || document.documentElement.clientWidth, r = window.innerHeight || document.documentElement.clientHeight;
          h === "vmax" ? o *= Math.max(p, r) / 100 : o *= Math.min(p, r) / 100;
        }
        return o;
      }
      function s(X) {
        return X == null ? X : String(X);
      }
      function c(X) {
        if (X == null)
          return X;
        if (typeof X == "string" && (X = i(X)), !Number.isFinite(X))
          throw new TypeError("Invalid value");
        return X;
      }
      function m(X, G = !1) {
        return X === "" ? null : (typeof X == "string" && (X = X.split(/[\s,]+/g)), Array.isArray(X) && (G && (X = X.map(c)), X.length === 1) ? X[0] : X);
      }
      function n(X, G) {
        if (Array.isArray(X) && Array.isArray(G)) {
          if (X.length !== G.length)
            return !1;
          for (let L = 0; L < X.length; L++)
            if (X[L] !== G[L])
              return !1;
          return !0;
        }
        return X == null && G == null || X === G;
      }
    },
    /* 73 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return h;
      });
      var i = l(74), s = l(32), c = /* @__PURE__ */ l.n(s), m = l(68), n = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      function X() {
        return X = Object.assign || function(p) {
          for (var r = 1; r < arguments.length; r++) {
            var V = arguments[r];
            for (var W in V)
              Object.prototype.hasOwnProperty.call(V, W) && (p[W] = V[W]);
          }
          return p;
        }, X.apply(this, arguments);
      }
      function G(p) {
        if (typeof p == "string") {
          if (p = p.trim(), /^[0-9.]+%$/.test(p))
            return parseFloat(p) / 100;
          if (/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/.test(p))
            return Object(n.sizeToPixel)(p);
        }
        return p;
      }
      function L(p, r, V, W, y) {
        return typeof p == "string" && (p = c()(p)), typeof r == "string" && (r = c()(r)), i.Effects.default(p, r, V, W, y);
      }
      function o(p, r, V, W, y) {
        return i.Effects.default(p, r, V, W, y);
      }
      i.Effects.default = function(p, r, V, W, y) {
        return Array.isArray(p) && Array.isArray(r) ? p.map((t, e) => t + (V - W) / (y - W) * (r[e] - t)) : typeof p == "number" && typeof r == "number" ? p + (V - W) / (y - W) * (r - p) : V - W > y - V ? r : p;
      }, i.Effects.fillColor = L, i.Effects.strokeColor = L, i.Effects.bgcolor = L, i.Effects.borderColor = L, i.Effects.text = o;
      class h extends i.Animator {
        constructor(r, V, W) {
          const y = r.attr();
          Object.entries(y).forEach(([t, e]) => {
            y[t] = i.Effects[t] ? e : G(e);
          }), V = V.map((t) => {
            let e = X({}, t);
            const Z = {};
            return Object.entries(e).forEach(([a, x]) => {
              Z[a] = i.Effects[a] ? x : G(x);
            }), Z;
          }), super(y, V, W), this.target = r, this.setter = function(t, e) {
            e.attr(t);
          };
        }
        get playState() {
          return this.target.parent ? super.playState : "idle";
        }
        get finished() {
          return super.finished.then(() => {
            const r = this;
            return new Promise((V) => {
              function W() {
                r.setter(r.frame, r.target);
                const y = r.playState;
                y === "finished" || y === "idle" ? (Object(m.cancelAnimationFrame)(r.requestId), V()) : Object(m.requestAnimationFrame)(W);
              }
              W();
            });
          });
        }
        finish() {
          super.finish(), Object(m.cancelAnimationFrame)(this.requestId), this.setter(this.frame, this.target);
        }
        play() {
          if (!this.target.parent || this.playState === "running")
            return;
          super.play(), this.setter(this.frame, this.target);
          const r = this;
          this.ready.then(() => {
            r.setter(r.frame, r.target), r.requestId = Object(m.requestAnimationFrame)(function V() {
              const W = r.target;
              if (typeof document < "u" && document.documentElement && document.documentElement.contains && W.layer && W.layer.canvas && !document.documentElement.contains(W.layer.canvas)) {
                r.cancel();
                return;
              }
              const y = r.playState;
              r.setter(r.frame, r.target), y !== "idle" && (y === "running" ? r.requestId = Object(m.requestAnimationFrame)(V) : (y === "paused" || y === "pending" && r.timeline.currentTime < 0) && r.ready.then(() => {
                r.setter(r.frame, r.target), r.requestId = Object(m.requestAnimationFrame)(V);
              }));
            });
          });
        }
        cancel(r = !1) {
          Object(m.cancelAnimationFrame)(this.requestId), r ? (this.setter(this.frame, this.target), super.cancel()) : (super.cancel(), this.setter(this.frame, this.target));
        }
      }
    },
    /* 74 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.Timeline = d.Effects = d.Easings = d.Animator = void 0;
      var i = l(75), s = L(i), c = l(187), m = L(c), n = l(188), X = l(190), G = L(X);
      function L(o) {
        return o && o.__esModule ? o : { default: o };
      }
      d.Animator = G.default, d.Easings = n.Easings, d.Effects = m.default, d.Timeline = s.default;
    },
    /* 75 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      });
      var i = l(76), s = t(i), c = l(133), m = t(c), n = l(141), X = t(n), G = l(164), L = t(G), o = l(170), h = t(o), p = l(171), r = t(p), V = l(175), W = t(V), y = l(186);
      function t(F) {
        return F && F.__esModule ? F : { default: F };
      }
      var e = (0, y.createNowTime)(), Z = {
        originTime: 0,
        playbackRate: 1
      }, a = (0, W.default)("timeMark"), x = (0, W.default)("playbackRate"), K = (0, W.default)("timers"), C = (0, W.default)("originTime"), T = (0, W.default)("setTimer"), I = (0, W.default)("parent"), J = function() {
        function F(R, S) {
          (0, h.default)(this, F), R instanceof F && (S = R, R = {}), R = (0, L.default)({}, Z, R), S && (this[I] = S);
          var N = R.nowtime || e;
          if (S)
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return S.currentTime;
              }
            });
          else {
            var Q = N();
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return N() - Q;
              }
            });
          }
          this[a] = [{
            globalTime: this.globalTime,
            localTime: -R.originTime,
            entropy: -R.originTime,
            playbackRate: R.playbackRate,
            globalEntropy: 0
          }], this[I] && (this[a][0].globalEntropy = this[I].entropy), this[C] = R.originTime, this[x] = R.playbackRate, this[K] = new X.default();
        }
        return (0, r.default)(F, [{
          key: "markTime",
          value: function() {
            var S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, N = S.time, Q = N === void 0 ? this.currentTime : N, P = S.entropy, j = P === void 0 ? this.entropy : P, D = S.playbackRate, z = D === void 0 ? this.playbackRate : D, w = {
              globalTime: this.globalTime,
              localTime: Q,
              entropy: j,
              playbackRate: z,
              globalEntropy: this.globalEntropy
            };
            this[a].push(w);
          }
        }, {
          key: "fork",
          value: function(S) {
            return new F(S, this);
          }
        }, {
          key: "seekGlobalTime",
          value: function(S) {
            var N = this.seekTimeMark(S), Q = this[a][N], P = Q.entropy, j = Q.playbackRate, D = Q.globalTime;
            return D + (S - P) / Math.abs(j);
          }
        }, {
          key: "seekLocalTime",
          value: function(S) {
            var N = this.seekTimeMark(S), Q = this[a][N], P = Q.localTime, j = Q.entropy, D = Q.playbackRate;
            return D > 0 ? P + (S - j) : P - (S - j);
          }
        }, {
          key: "seekTimeMark",
          value: function(S) {
            var N = this[a], Q = 0, P = N.length - 1;
            if (S <= N[Q].entropy)
              return Q;
            if (S >= N[P].entropy)
              return P;
            for (var j = Math.floor((Q + P) / 2); j > Q && j < P; ) {
              if (S === N[j].entropy)
                return j;
              S < N[j].entropy ? P = j : S > N[j].entropy && (Q = j), j = Math.floor((Q + P) / 2);
            }
            return Q;
          }
        }, {
          key: "updateTimers",
          value: function() {
            var S = this, N = [].concat((0, m.default)(this[K]));
            N.forEach(function(Q) {
              var P = (0, s.default)(Q, 2), j = P[0], D = P[1];
              S[T](D.handler, D.time, j);
            });
          }
        }, {
          key: "clearTimeout",
          value: function(R) {
            function S(N) {
              return R.apply(this, arguments);
            }
            return S.toString = function() {
              return R.toString();
            }, S;
          }(function(R) {
            var S = this[K].get(R);
            S && S.timerID != null && (this[I] ? this[I].clearTimeout(S.timerID) : clearTimeout(S.timerID)), this[K].delete(R);
          })
        }, {
          key: "clearInterval",
          value: function(S) {
            return this.clearTimeout(S);
          }
        }, {
          key: "clear",
          value: function() {
            var S = this, N = this[K];
            [].concat((0, m.default)(N.keys())).forEach(function(Q) {
              S.clearTimeout(Q);
            });
          }
          /*
            setTimeout(func, {delay: 100, isEntropy: true})
            setTimeout(func, {entropy: 100})
            setTimeout(func, 100})
           */
        }, {
          key: "setTimeout",
          value: function(S) {
            var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 };
            return this[T](S, N);
          }
        }, {
          key: "setInterval",
          value: function(S) {
            var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 }, Q = this, P = this[T](function j() {
              Q[T](j, N, P), S();
            }, N);
            return P;
          }
        }, {
          key: T,
          value: function(S, N) {
            var Q = this, P = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, W.default)("timerID");
            N = (0, y.formatDelay)(N);
            var j = this[K].get(P), D = void 0, z = null, w = void 0, A = void 0;
            j ? (this.clearTimeout(P), N.isEntropy ? D = (N.delay - (this.entropy - j.startEntropy)) / Math.abs(this.playbackRate) : D = (N.delay - (this.currentTime - j.startTime)) / this.playbackRate, w = j.startTime, A = j.startEntropy) : (D = N.delay / (N.isEntropy ? Math.abs(this.playbackRate) : this.playbackRate), w = this.currentTime, A = this.entropy);
            var ll = this[I], _ = ll ? ll.setTimeout.bind(ll) : setTimeout, cl = N.heading;
            return !ll && cl === !1 && D < 0 && (D = 1 / 0), (isFinite(D) || ll) && (D = Math.ceil(D), _ !== setTimeout && (D = { delay: D, heading: cl }), z = _(function() {
              Q[K].delete(P), S();
            }, D)), this[K].set(P, {
              timerID: z,
              handler: S,
              time: N,
              startTime: w,
              startEntropy: A
            }), P;
          }
        }, {
          key: "parent",
          get: function() {
            return this[I];
          }
        }, {
          key: "lastTimeMark",
          get: function() {
            return this[a][this[a].length - 1];
          }
        }, {
          key: "currentTime",
          get: function() {
            var S = this.lastTimeMark, N = S.localTime, Q = S.globalTime;
            return N + (this.globalTime - Q) * this.playbackRate;
          },
          set: function(S) {
            var N = this, Q = this.currentTime, P = S, j = this[K];
            this.markTime({ time: S }), [].concat((0, m.default)(j)).forEach(function(D) {
              var z = (0, s.default)(D, 2), w = z[0], A = z[1];
              if (j.has(w)) {
                var ll = A.time, _ = ll.isEntropy, cl = ll.delay, $ = ll.heading, al = A.handler, Xl = A.startTime;
                if (_)
                  cl === 0 && (al(), N.clearTimeout(w));
                else {
                  var M = Xl + cl;
                  (cl === 0 || $ !== !1 && (P - Q) * cl <= 0 || Q <= M && M <= P || Q >= M && M >= P) && (al(), N.clearTimeout(w));
                }
              }
            }), this.updateTimers();
          }
          // Both currentTime and entropy should be influenced by playbackRate.
          // If current playbackRate is negative, the currentTime should go backwards
          // while the entropy remain to go forwards.
          // Both of the initial values is set to -originTime
        }, {
          key: "entropy",
          get: function() {
            var S = this.lastTimeMark, N = S.entropy, Q = S.globalEntropy;
            return N + Math.abs((this.globalEntropy - Q) * this.playbackRate);
          },
          // get globalTime() {
          //   if(this[_parent]) {
          //     return this[_parent].currentTime;
          //   }
          //   return nowtime();
          // }
          // change entropy will NOT cause currentTime changing but may influence the pass
          // and the future of the timeline. (It may change the result of seek***Time)
          // While entropy is set, all the marks behind will be droped
          set: function(S) {
            if (this.entropy > S) {
              var N = this.seekTimeMark(S);
              this[a].length = N + 1;
            }
            this.markTime({ entropy: S }), this.updateTimers();
          }
        }, {
          key: "globalEntropy",
          get: function() {
            return this[I] ? this[I].entropy : this.globalTime;
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[x];
          },
          set: function(S) {
            S !== this.playbackRate && (this.markTime({ playbackRate: S }), this[x] = S, this.updateTimers());
          }
        }, {
          key: "paused",
          get: function() {
            if (this.playbackRate === 0)
              return !0;
            for (var S = this.parent; S; ) {
              if (S.playbackRate === 0)
                return !0;
              S = S.parent;
            }
            return !1;
          }
        }]), F;
      }();
      d.default = J;
    },
    /* 76 */
    /***/
    function(b, d, l) {
      d.__esModule = !0;
      var i = l(77), s = n(i), c = l(129), m = n(c);
      function n(X) {
        return X && X.__esModule ? X : { default: X };
      }
      d.default = /* @__PURE__ */ function() {
        function X(G, L) {
          var o = [], h = !0, p = !1, r = void 0;
          try {
            for (var V = (0, m.default)(G), W; !(h = (W = V.next()).done) && (o.push(W.value), !(L && o.length === L)); h = !0)
              ;
          } catch (y) {
            p = !0, r = y;
          } finally {
            try {
              !h && V.return && V.return();
            } finally {
              if (p)
                throw r;
            }
          }
          return o;
        }
        return function(G, L) {
          if (Array.isArray(G))
            return G;
          if ((0, s.default)(Object(G)))
            return X(G, L);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }();
    },
    /* 77 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(78), __esModule: !0 };
    },
    /* 78 */
    /***/
    function(b, d, l) {
      l(79), l(125), b.exports = l(127);
    },
    /* 79 */
    /***/
    function(b, d, l) {
      l(80);
      for (var i = l(91), s = l(95), c = l(83), m = l(122)("toStringTag"), n = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), X = 0; X < n.length; X++) {
        var G = n[X], L = i[G], o = L && L.prototype;
        o && !o[m] && s(o, m, G), c[G] = c.Array;
      }
    },
    /* 80 */
    /***/
    function(b, d, l) {
      var i = l(81), s = l(82), c = l(83), m = l(84);
      b.exports = l(88)(Array, "Array", function(n, X) {
        this._t = m(n), this._i = 0, this._k = X;
      }, function() {
        var n = this._t, X = this._k, G = this._i++;
        return !n || G >= n.length ? (this._t = void 0, s(1)) : X == "keys" ? s(0, G) : X == "values" ? s(0, n[G]) : s(0, [G, n[G]]);
      }, "values"), c.Arguments = c.Array, i("keys"), i("values"), i("entries");
    },
    /* 81 */
    /***/
    function(b, d) {
      b.exports = function() {
      };
    },
    /* 82 */
    /***/
    function(b, d) {
      b.exports = function(l, i) {
        return { value: i, done: !!l };
      };
    },
    /* 83 */
    /***/
    function(b, d) {
      b.exports = {};
    },
    /* 84 */
    /***/
    function(b, d, l) {
      var i = l(85), s = l(87);
      b.exports = function(c) {
        return i(s(c));
      };
    },
    /* 85 */
    /***/
    function(b, d, l) {
      var i = l(86);
      b.exports = Object("z").propertyIsEnumerable(0) ? Object : function(s) {
        return i(s) == "String" ? s.split("") : Object(s);
      };
    },
    /* 86 */
    /***/
    function(b, d) {
      var l = {}.toString;
      b.exports = function(i) {
        return l.call(i).slice(8, -1);
      };
    },
    /* 87 */
    /***/
    function(b, d) {
      b.exports = function(l) {
        if (l == null)
          throw TypeError("Can't call method on  " + l);
        return l;
      };
    },
    /* 88 */
    /***/
    function(b, d, l) {
      var i = l(89), s = l(90), c = l(106), m = l(95), n = l(83), X = l(107), G = l(121), L = l(123), o = l(122)("iterator"), h = !([].keys && "next" in [].keys()), p = "@@iterator", r = "keys", V = "values", W = function() {
        return this;
      };
      b.exports = function(y, t, e, Z, a, x, K) {
        X(e, t, Z);
        var C = function(z) {
          if (!h && z in F)
            return F[z];
          switch (z) {
            case r:
              return function() {
                return new e(this, z);
              };
            case V:
              return function() {
                return new e(this, z);
              };
          }
          return function() {
            return new e(this, z);
          };
        }, T = t + " Iterator", I = a == V, J = !1, F = y.prototype, R = F[o] || F[p] || a && F[a], S = R || C(a), N = a ? I ? C("entries") : S : void 0, Q = t == "Array" && F.entries || R, P, j, D;
        if (Q && (D = L(Q.call(new y())), D !== Object.prototype && D.next && (G(D, T, !0), !i && typeof D[o] != "function" && m(D, o, W))), I && R && R.name !== V && (J = !0, S = function() {
          return R.call(this);
        }), (!i || K) && (h || J || !F[o]) && m(F, o, S), n[t] = S, n[T] = W, a)
          if (P = {
            values: I ? S : C(V),
            keys: x ? S : C(r),
            entries: N
          }, K)
            for (j in P)
              j in F || c(F, j, P[j]);
          else
            s(s.P + s.F * (h || J), t, P);
        return P;
      };
    },
    /* 89 */
    /***/
    function(b, d) {
      b.exports = !0;
    },
    /* 90 */
    /***/
    function(b, d, l) {
      var i = l(91), s = l(92), c = l(93), m = l(95), n = l(105), X = "prototype", G = function(L, o, h) {
        var p = L & G.F, r = L & G.G, V = L & G.S, W = L & G.P, y = L & G.B, t = L & G.W, e = r ? s : s[o] || (s[o] = {}), Z = e[X], a = r ? i : V ? i[o] : (i[o] || {})[X], x, K, C;
        r && (h = o);
        for (x in h)
          K = !p && a && a[x] !== void 0, !(K && n(e, x)) && (C = K ? a[x] : h[x], e[x] = r && typeof a[x] != "function" ? h[x] : y && K ? c(C, i) : t && a[x] == C ? function(T) {
            var I = function(J, F, R) {
              if (this instanceof T) {
                switch (arguments.length) {
                  case 0:
                    return new T();
                  case 1:
                    return new T(J);
                  case 2:
                    return new T(J, F);
                }
                return new T(J, F, R);
              }
              return T.apply(this, arguments);
            };
            return I[X] = T[X], I;
          }(C) : W && typeof C == "function" ? c(Function.call, C) : C, W && ((e.virtual || (e.virtual = {}))[x] = C, L & G.R && Z && !Z[x] && m(Z, x, C)));
      };
      G.F = 1, G.G = 2, G.S = 4, G.P = 8, G.B = 16, G.W = 32, G.U = 64, G.R = 128, b.exports = G;
    },
    /* 91 */
    /***/
    function(b, d) {
      var l = b.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
      typeof __g == "number" && (__g = l);
    },
    /* 92 */
    /***/
    function(b, d) {
      var l = b.exports = { version: "2.6.11" };
      typeof __e == "number" && (__e = l);
    },
    /* 93 */
    /***/
    function(b, d, l) {
      var i = l(94);
      b.exports = function(s, c, m) {
        if (i(s), c === void 0)
          return s;
        switch (m) {
          case 1:
            return function(n) {
              return s.call(c, n);
            };
          case 2:
            return function(n, X) {
              return s.call(c, n, X);
            };
          case 3:
            return function(n, X, G) {
              return s.call(c, n, X, G);
            };
        }
        return function() {
          return s.apply(c, arguments);
        };
      };
    },
    /* 94 */
    /***/
    function(b, d) {
      b.exports = function(l) {
        if (typeof l != "function")
          throw TypeError(l + " is not a function!");
        return l;
      };
    },
    /* 95 */
    /***/
    function(b, d, l) {
      var i = l(96), s = l(104);
      b.exports = l(100) ? function(c, m, n) {
        return i.f(c, m, s(1, n));
      } : function(c, m, n) {
        return c[m] = n, c;
      };
    },
    /* 96 */
    /***/
    function(b, d, l) {
      var i = l(97), s = l(99), c = l(103), m = Object.defineProperty;
      d.f = l(100) ? Object.defineProperty : function(X, G, L) {
        if (i(X), G = c(G, !0), i(L), s)
          try {
            return m(X, G, L);
          } catch {
          }
        if ("get" in L || "set" in L)
          throw TypeError("Accessors not supported!");
        return "value" in L && (X[G] = L.value), X;
      };
    },
    /* 97 */
    /***/
    function(b, d, l) {
      var i = l(98);
      b.exports = function(s) {
        if (!i(s))
          throw TypeError(s + " is not an object!");
        return s;
      };
    },
    /* 98 */
    /***/
    function(b, d) {
      b.exports = function(l) {
        return typeof l == "object" ? l !== null : typeof l == "function";
      };
    },
    /* 99 */
    /***/
    function(b, d, l) {
      b.exports = !l(100) && !l(101)(function() {
        return Object.defineProperty(l(102)("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 100 */
    /***/
    function(b, d, l) {
      b.exports = !l(101)(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 101 */
    /***/
    function(b, d) {
      b.exports = function(l) {
        try {
          return !!l();
        } catch {
          return !0;
        }
      };
    },
    /* 102 */
    /***/
    function(b, d, l) {
      var i = l(98), s = l(91).document, c = i(s) && i(s.createElement);
      b.exports = function(m) {
        return c ? s.createElement(m) : {};
      };
    },
    /* 103 */
    /***/
    function(b, d, l) {
      var i = l(98);
      b.exports = function(s, c) {
        if (!i(s))
          return s;
        var m, n;
        if (c && typeof (m = s.toString) == "function" && !i(n = m.call(s)) || typeof (m = s.valueOf) == "function" && !i(n = m.call(s)) || !c && typeof (m = s.toString) == "function" && !i(n = m.call(s)))
          return n;
        throw TypeError("Can't convert object to primitive value");
      };
    },
    /* 104 */
    /***/
    function(b, d) {
      b.exports = function(l, i) {
        return {
          enumerable: !(l & 1),
          configurable: !(l & 2),
          writable: !(l & 4),
          value: i
        };
      };
    },
    /* 105 */
    /***/
    function(b, d) {
      var l = {}.hasOwnProperty;
      b.exports = function(i, s) {
        return l.call(i, s);
      };
    },
    /* 106 */
    /***/
    function(b, d, l) {
      b.exports = l(95);
    },
    /* 107 */
    /***/
    function(b, d, l) {
      var i = l(108), s = l(104), c = l(121), m = {};
      l(95)(m, l(122)("iterator"), function() {
        return this;
      }), b.exports = function(n, X, G) {
        n.prototype = i(m, { next: s(1, G) }), c(n, X + " Iterator");
      };
    },
    /* 108 */
    /***/
    function(b, d, l) {
      var i = l(97), s = l(109), c = l(119), m = l(116)("IE_PROTO"), n = function() {
      }, X = "prototype", G = function() {
        var L = l(102)("iframe"), o = c.length, h = "<", p = ">", r;
        for (L.style.display = "none", l(120).appendChild(L), L.src = "javascript:", r = L.contentWindow.document, r.open(), r.write(h + "script" + p + "document.F=Object" + h + "/script" + p), r.close(), G = r.F; o--; )
          delete G[X][c[o]];
        return G();
      };
      b.exports = Object.create || function(o, h) {
        var p;
        return o !== null ? (n[X] = i(o), p = new n(), n[X] = null, p[m] = o) : p = G(), h === void 0 ? p : s(p, h);
      };
    },
    /* 109 */
    /***/
    function(b, d, l) {
      var i = l(96), s = l(97), c = l(110);
      b.exports = l(100) ? Object.defineProperties : function(n, X) {
        s(n);
        for (var G = c(X), L = G.length, o = 0, h; L > o; )
          i.f(n, h = G[o++], X[h]);
        return n;
      };
    },
    /* 110 */
    /***/
    function(b, d, l) {
      var i = l(111), s = l(119);
      b.exports = Object.keys || function(m) {
        return i(m, s);
      };
    },
    /* 111 */
    /***/
    function(b, d, l) {
      var i = l(105), s = l(84), c = l(112)(!1), m = l(116)("IE_PROTO");
      b.exports = function(n, X) {
        var G = s(n), L = 0, o = [], h;
        for (h in G)
          h != m && i(G, h) && o.push(h);
        for (; X.length > L; )
          i(G, h = X[L++]) && (~c(o, h) || o.push(h));
        return o;
      };
    },
    /* 112 */
    /***/
    function(b, d, l) {
      var i = l(84), s = l(113), c = l(115);
      b.exports = function(m) {
        return function(n, X, G) {
          var L = i(n), o = s(L.length), h = c(G, o), p;
          if (m && X != X) {
            for (; o > h; )
              if (p = L[h++], p != p)
                return !0;
          } else
            for (; o > h; h++)
              if ((m || h in L) && L[h] === X)
                return m || h || 0;
          return !m && -1;
        };
      };
    },
    /* 113 */
    /***/
    function(b, d, l) {
      var i = l(114), s = Math.min;
      b.exports = function(c) {
        return c > 0 ? s(i(c), 9007199254740991) : 0;
      };
    },
    /* 114 */
    /***/
    function(b, d) {
      var l = Math.ceil, i = Math.floor;
      b.exports = function(s) {
        return isNaN(s = +s) ? 0 : (s > 0 ? i : l)(s);
      };
    },
    /* 115 */
    /***/
    function(b, d, l) {
      var i = l(114), s = Math.max, c = Math.min;
      b.exports = function(m, n) {
        return m = i(m), m < 0 ? s(m + n, 0) : c(m, n);
      };
    },
    /* 116 */
    /***/
    function(b, d, l) {
      var i = l(117)("keys"), s = l(118);
      b.exports = function(c) {
        return i[c] || (i[c] = s(c));
      };
    },
    /* 117 */
    /***/
    function(b, d, l) {
      var i = l(92), s = l(91), c = "__core-js_shared__", m = s[c] || (s[c] = {});
      (b.exports = function(n, X) {
        return m[n] || (m[n] = X !== void 0 ? X : {});
      })("versions", []).push({
        version: i.version,
        mode: l(89) ? "pure" : "global",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
      });
    },
    /* 118 */
    /***/
    function(b, d) {
      var l = 0, i = Math.random();
      b.exports = function(s) {
        return "Symbol(".concat(s === void 0 ? "" : s, ")_", (++l + i).toString(36));
      };
    },
    /* 119 */
    /***/
    function(b, d) {
      b.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    },
    /* 120 */
    /***/
    function(b, d, l) {
      var i = l(91).document;
      b.exports = i && i.documentElement;
    },
    /* 121 */
    /***/
    function(b, d, l) {
      var i = l(96).f, s = l(105), c = l(122)("toStringTag");
      b.exports = function(m, n, X) {
        m && !s(m = X ? m : m.prototype, c) && i(m, c, { configurable: !0, value: n });
      };
    },
    /* 122 */
    /***/
    function(b, d, l) {
      var i = l(117)("wks"), s = l(118), c = l(91).Symbol, m = typeof c == "function", n = b.exports = function(X) {
        return i[X] || (i[X] = m && c[X] || (m ? c : s)("Symbol." + X));
      };
      n.store = i;
    },
    /* 123 */
    /***/
    function(b, d, l) {
      var i = l(105), s = l(124), c = l(116)("IE_PROTO"), m = Object.prototype;
      b.exports = Object.getPrototypeOf || function(n) {
        return n = s(n), i(n, c) ? n[c] : typeof n.constructor == "function" && n instanceof n.constructor ? n.constructor.prototype : n instanceof Object ? m : null;
      };
    },
    /* 124 */
    /***/
    function(b, d, l) {
      var i = l(87);
      b.exports = function(s) {
        return Object(i(s));
      };
    },
    /* 125 */
    /***/
    function(b, d, l) {
      var i = l(126)(!0);
      l(88)(String, "String", function(s) {
        this._t = String(s), this._i = 0;
      }, function() {
        var s = this._t, c = this._i, m;
        return c >= s.length ? { value: void 0, done: !0 } : (m = i(s, c), this._i += m.length, { value: m, done: !1 });
      });
    },
    /* 126 */
    /***/
    function(b, d, l) {
      var i = l(114), s = l(87);
      b.exports = function(c) {
        return function(m, n) {
          var X = String(s(m)), G = i(n), L = X.length, o, h;
          return G < 0 || G >= L ? c ? "" : void 0 : (o = X.charCodeAt(G), o < 55296 || o > 56319 || G + 1 === L || (h = X.charCodeAt(G + 1)) < 56320 || h > 57343 ? c ? X.charAt(G) : o : c ? X.slice(G, G + 2) : (o - 55296 << 10) + (h - 56320) + 65536);
        };
      };
    },
    /* 127 */
    /***/
    function(b, d, l) {
      var i = l(128), s = l(122)("iterator"), c = l(83);
      b.exports = l(92).isIterable = function(m) {
        var n = Object(m);
        return n[s] !== void 0 || "@@iterator" in n || c.hasOwnProperty(i(n));
      };
    },
    /* 128 */
    /***/
    function(b, d, l) {
      var i = l(86), s = l(122)("toStringTag"), c = i(/* @__PURE__ */ function() {
        return arguments;
      }()) == "Arguments", m = function(n, X) {
        try {
          return n[X];
        } catch {
        }
      };
      b.exports = function(n) {
        var X, G, L;
        return n === void 0 ? "Undefined" : n === null ? "Null" : typeof (G = m(X = Object(n), s)) == "string" ? G : c ? i(X) : (L = i(X)) == "Object" && typeof X.callee == "function" ? "Arguments" : L;
      };
    },
    /* 129 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(130), __esModule: !0 };
    },
    /* 130 */
    /***/
    function(b, d, l) {
      l(79), l(125), b.exports = l(131);
    },
    /* 131 */
    /***/
    function(b, d, l) {
      var i = l(97), s = l(132);
      b.exports = l(92).getIterator = function(c) {
        var m = s(c);
        if (typeof m != "function")
          throw TypeError(c + " is not iterable!");
        return i(m.call(c));
      };
    },
    /* 132 */
    /***/
    function(b, d, l) {
      var i = l(128), s = l(122)("iterator"), c = l(83);
      b.exports = l(92).getIteratorMethod = function(m) {
        if (m != null)
          return m[s] || m["@@iterator"] || c[i(m)];
      };
    },
    /* 133 */
    /***/
    function(b, d, l) {
      d.__esModule = !0;
      var i = l(134), s = c(i);
      function c(m) {
        return m && m.__esModule ? m : { default: m };
      }
      d.default = function(m) {
        if (Array.isArray(m)) {
          for (var n = 0, X = Array(m.length); n < m.length; n++)
            X[n] = m[n];
          return X;
        } else
          return (0, s.default)(m);
      };
    },
    /* 134 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(135), __esModule: !0 };
    },
    /* 135 */
    /***/
    function(b, d, l) {
      l(125), l(136), b.exports = l(92).Array.from;
    },
    /* 136 */
    /***/
    function(b, d, l) {
      var i = l(93), s = l(90), c = l(124), m = l(137), n = l(138), X = l(113), G = l(139), L = l(132);
      s(s.S + s.F * !l(140)(function(o) {
        Array.from(o);
      }), "Array", {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function(h) {
          var p = c(h), r = typeof this == "function" ? this : Array, V = arguments.length, W = V > 1 ? arguments[1] : void 0, y = W !== void 0, t = 0, e = L(p), Z, a, x, K;
          if (y && (W = i(W, V > 2 ? arguments[2] : void 0, 2)), e != null && !(r == Array && n(e)))
            for (K = e.call(p), a = new r(); !(x = K.next()).done; t++)
              G(a, t, y ? m(K, W, [x.value, t], !0) : x.value);
          else
            for (Z = X(p.length), a = new r(Z); Z > t; t++)
              G(a, t, y ? W(p[t], t) : p[t]);
          return a.length = t, a;
        }
      });
    },
    /* 137 */
    /***/
    function(b, d, l) {
      var i = l(97);
      b.exports = function(s, c, m, n) {
        try {
          return n ? c(i(m)[0], m[1]) : c(m);
        } catch (G) {
          var X = s.return;
          throw X !== void 0 && i(X.call(s)), G;
        }
      };
    },
    /* 138 */
    /***/
    function(b, d, l) {
      var i = l(83), s = l(122)("iterator"), c = Array.prototype;
      b.exports = function(m) {
        return m !== void 0 && (i.Array === m || c[s] === m);
      };
    },
    /* 139 */
    /***/
    function(b, d, l) {
      var i = l(96), s = l(104);
      b.exports = function(c, m, n) {
        m in c ? i.f(c, m, s(0, n)) : c[m] = n;
      };
    },
    /* 140 */
    /***/
    function(b, d, l) {
      var i = l(122)("iterator"), s = !1;
      try {
        var c = [7][i]();
        c.return = function() {
          s = !0;
        }, Array.from(c, function() {
          throw 2;
        });
      } catch {
      }
      b.exports = function(m, n) {
        if (!n && !s)
          return !1;
        var X = !1;
        try {
          var G = [7], L = G[i]();
          L.next = function() {
            return { done: X = !0 };
          }, G[i] = function() {
            return L;
          }, m(G);
        } catch {
        }
        return X;
      };
    },
    /* 141 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(142), __esModule: !0 };
    },
    /* 142 */
    /***/
    function(b, d, l) {
      l(143), l(125), l(79), l(144), l(157), l(160), l(162), b.exports = l(92).Map;
    },
    /* 143 */
    /***/
    function(b, d) {
    },
    /* 144 */
    /***/
    function(b, d, l) {
      var i = l(145), s = l(151), c = "Map";
      b.exports = l(152)(c, function(m) {
        return function() {
          return m(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function(n) {
          var X = i.getEntry(s(this, c), n);
          return X && X.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function(n, X) {
          return i.def(s(this, c), n === 0 ? 0 : n, X);
        }
      }, i, !0);
    },
    /* 145 */
    /***/
    function(b, d, l) {
      var i = l(96).f, s = l(108), c = l(146), m = l(93), n = l(147), X = l(148), G = l(88), L = l(82), o = l(149), h = l(100), p = l(150).fastKey, r = l(151), V = h ? "_s" : "size", W = function(y, t) {
        var e = p(t), Z;
        if (e !== "F")
          return y._i[e];
        for (Z = y._f; Z; Z = Z.n)
          if (Z.k == t)
            return Z;
      };
      b.exports = {
        getConstructor: function(y, t, e, Z) {
          var a = y(function(x, K) {
            n(x, a, t, "_i"), x._t = t, x._i = s(null), x._f = void 0, x._l = void 0, x[V] = 0, K != null && X(K, e, x[Z], x);
          });
          return c(a.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function() {
              for (var K = r(this, t), C = K._i, T = K._f; T; T = T.n)
                T.r = !0, T.p && (T.p = T.p.n = void 0), delete C[T.i];
              K._f = K._l = void 0, K[V] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            delete: function(x) {
              var K = r(this, t), C = W(K, x);
              if (C) {
                var T = C.n, I = C.p;
                delete K._i[C.i], C.r = !0, I && (I.n = T), T && (T.p = I), K._f == C && (K._f = T), K._l == C && (K._l = I), K[V]--;
              }
              return !!C;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function(K) {
              r(this, t);
              for (var C = m(K, arguments.length > 1 ? arguments[1] : void 0, 3), T; T = T ? T.n : this._f; )
                for (C(T.v, T.k, this); T && T.r; )
                  T = T.p;
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function(K) {
              return !!W(r(this, t), K);
            }
          }), h && i(a.prototype, "size", {
            get: function() {
              return r(this, t)[V];
            }
          }), a;
        },
        def: function(y, t, e) {
          var Z = W(y, t), a, x;
          return Z ? Z.v = e : (y._l = Z = {
            i: x = p(t, !0),
            // <- index
            k: t,
            // <- key
            v: e,
            // <- value
            p: a = y._l,
            // <- previous entry
            n: void 0,
            // <- next entry
            r: !1
            // <- removed
          }, y._f || (y._f = Z), a && (a.n = Z), y[V]++, x !== "F" && (y._i[x] = Z)), y;
        },
        getEntry: W,
        setStrong: function(y, t, e) {
          G(y, t, function(Z, a) {
            this._t = r(Z, t), this._k = a, this._l = void 0;
          }, function() {
            for (var Z = this, a = Z._k, x = Z._l; x && x.r; )
              x = x.p;
            return !Z._t || !(Z._l = x = x ? x.n : Z._t._f) ? (Z._t = void 0, L(1)) : a == "keys" ? L(0, x.k) : a == "values" ? L(0, x.v) : L(0, [x.k, x.v]);
          }, e ? "entries" : "values", !e, !0), o(t);
        }
      };
    },
    /* 146 */
    /***/
    function(b, d, l) {
      var i = l(95);
      b.exports = function(s, c, m) {
        for (var n in c)
          m && s[n] ? s[n] = c[n] : i(s, n, c[n]);
        return s;
      };
    },
    /* 147 */
    /***/
    function(b, d) {
      b.exports = function(l, i, s, c) {
        if (!(l instanceof i) || c !== void 0 && c in l)
          throw TypeError(s + ": incorrect invocation!");
        return l;
      };
    },
    /* 148 */
    /***/
    function(b, o, l) {
      var i = l(93), s = l(137), c = l(138), m = l(97), n = l(113), X = l(132), G = {}, L = {}, o = b.exports = function(h, p, r, V, W) {
        var y = W ? function() {
          return h;
        } : X(h), t = i(r, V, p ? 2 : 1), e = 0, Z, a, x, K;
        if (typeof y != "function")
          throw TypeError(h + " is not iterable!");
        if (c(y)) {
          for (Z = n(h.length); Z > e; e++)
            if (K = p ? t(m(a = h[e])[0], a[1]) : t(h[e]), K === G || K === L)
              return K;
        } else
          for (x = y.call(h); !(a = x.next()).done; )
            if (K = s(x, t, a.value, p), K === G || K === L)
              return K;
      };
      o.BREAK = G, o.RETURN = L;
    },
    /* 149 */
    /***/
    function(b, d, l) {
      var i = l(91), s = l(92), c = l(96), m = l(100), n = l(122)("species");
      b.exports = function(X) {
        var G = typeof s[X] == "function" ? s[X] : i[X];
        m && G && !G[n] && c.f(G, n, {
          configurable: !0,
          get: function() {
            return this;
          }
        });
      };
    },
    /* 150 */
    /***/
    function(b, d, l) {
      var i = l(118)("meta"), s = l(98), c = l(105), m = l(96).f, n = 0, X = Object.isExtensible || function() {
        return !0;
      }, G = !l(101)(function() {
        return X(Object.preventExtensions({}));
      }), L = function(V) {
        m(V, i, { value: {
          i: "O" + ++n,
          // object ID
          w: {}
          // weak collections IDs
        } });
      }, o = function(V, W) {
        if (!s(V))
          return typeof V == "symbol" ? V : (typeof V == "string" ? "S" : "P") + V;
        if (!c(V, i)) {
          if (!X(V))
            return "F";
          if (!W)
            return "E";
          L(V);
        }
        return V[i].i;
      }, h = function(V, W) {
        if (!c(V, i)) {
          if (!X(V))
            return !0;
          if (!W)
            return !1;
          L(V);
        }
        return V[i].w;
      }, p = function(V) {
        return G && r.NEED && X(V) && !c(V, i) && L(V), V;
      }, r = b.exports = {
        KEY: i,
        NEED: !1,
        fastKey: o,
        getWeak: h,
        onFreeze: p
      };
    },
    /* 151 */
    /***/
    function(b, d, l) {
      var i = l(98);
      b.exports = function(s, c) {
        if (!i(s) || s._t !== c)
          throw TypeError("Incompatible receiver, " + c + " required!");
        return s;
      };
    },
    /* 152 */
    /***/
    function(b, d, l) {
      var i = l(91), s = l(90), c = l(150), m = l(101), n = l(95), X = l(146), G = l(148), L = l(147), o = l(98), h = l(121), p = l(96).f, r = l(153)(0), V = l(100);
      b.exports = function(W, y, t, e, Z, a) {
        var x = i[W], K = x, C = Z ? "set" : "add", T = K && K.prototype, I = {};
        return !V || typeof K != "function" || !(a || T.forEach && !m(function() {
          new K().entries().next();
        })) ? (K = e.getConstructor(y, W, Z, C), X(K.prototype, t), c.NEED = !0) : (K = y(function(J, F) {
          L(J, K, W, "_c"), J._c = new x(), F != null && G(F, Z, J[C], J);
        }), r("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(J) {
          var F = J == "add" || J == "set";
          J in T && !(a && J == "clear") && n(K.prototype, J, function(R, S) {
            if (L(this, K, J), !F && a && !o(R))
              return J == "get" ? void 0 : !1;
            var N = this._c[J](R === 0 ? 0 : R, S);
            return F ? this : N;
          });
        }), a || p(K.prototype, "size", {
          get: function() {
            return this._c.size;
          }
        })), h(K, W), I[W] = K, s(s.G + s.W + s.F, I), a || e.setStrong(K, W, Z), K;
      };
    },
    /* 153 */
    /***/
    function(b, d, l) {
      var i = l(93), s = l(85), c = l(124), m = l(113), n = l(154);
      b.exports = function(X, G) {
        var L = X == 1, o = X == 2, h = X == 3, p = X == 4, r = X == 6, V = X == 5 || r, W = G || n;
        return function(y, t, e) {
          for (var Z = c(y), a = s(Z), x = i(t, e, 3), K = m(a.length), C = 0, T = L ? W(y, K) : o ? W(y, 0) : void 0, I, J; K > C; C++)
            if ((V || C in a) && (I = a[C], J = x(I, C, Z), X)) {
              if (L)
                T[C] = J;
              else if (J)
                switch (X) {
                  case 3:
                    return !0;
                  case 5:
                    return I;
                  case 6:
                    return C;
                  case 2:
                    T.push(I);
                }
              else if (p)
                return !1;
            }
          return r ? -1 : h || p ? p : T;
        };
      };
    },
    /* 154 */
    /***/
    function(b, d, l) {
      var i = l(155);
      b.exports = function(s, c) {
        return new (i(s))(c);
      };
    },
    /* 155 */
    /***/
    function(b, d, l) {
      var i = l(98), s = l(156), c = l(122)("species");
      b.exports = function(m) {
        var n;
        return s(m) && (n = m.constructor, typeof n == "function" && (n === Array || s(n.prototype)) && (n = void 0), i(n) && (n = n[c], n === null && (n = void 0))), n === void 0 ? Array : n;
      };
    },
    /* 156 */
    /***/
    function(b, d, l) {
      var i = l(86);
      b.exports = Array.isArray || function(c) {
        return i(c) == "Array";
      };
    },
    /* 157 */
    /***/
    function(b, d, l) {
      var i = l(90);
      i(i.P + i.R, "Map", { toJSON: l(158)("Map") });
    },
    /* 158 */
    /***/
    function(b, d, l) {
      var i = l(128), s = l(159);
      b.exports = function(c) {
        return function() {
          if (i(this) != c)
            throw TypeError(c + "#toJSON isn't generic");
          return s(this);
        };
      };
    },
    /* 159 */
    /***/
    function(b, d, l) {
      var i = l(148);
      b.exports = function(s, c) {
        var m = [];
        return i(s, !1, m.push, m, c), m;
      };
    },
    /* 160 */
    /***/
    function(b, d, l) {
      l(161)("Map");
    },
    /* 161 */
    /***/
    function(b, d, l) {
      var i = l(90);
      b.exports = function(s) {
        i(i.S, s, { of: function() {
          for (var m = arguments.length, n = new Array(m); m--; )
            n[m] = arguments[m];
          return new this(n);
        } });
      };
    },
    /* 162 */
    /***/
    function(b, d, l) {
      l(163)("Map");
    },
    /* 163 */
    /***/
    function(b, d, l) {
      var i = l(90), s = l(94), c = l(93), m = l(148);
      b.exports = function(n) {
        i(i.S, n, { from: function(G) {
          var L = arguments[1], o, h, p, r;
          return s(this), o = L !== void 0, o && s(L), G == null ? new this() : (h = [], o ? (p = 0, r = c(L, arguments[2], 2), m(G, !1, function(V) {
            h.push(r(V, p++));
          })) : m(G, !1, h.push, h), new this(h));
        } });
      };
    },
    /* 164 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(165), __esModule: !0 };
    },
    /* 165 */
    /***/
    function(b, d, l) {
      l(166), b.exports = l(92).Object.assign;
    },
    /* 166 */
    /***/
    function(b, d, l) {
      var i = l(90);
      i(i.S + i.F, "Object", { assign: l(167) });
    },
    /* 167 */
    /***/
    function(b, d, l) {
      var i = l(100), s = l(110), c = l(168), m = l(169), n = l(124), X = l(85), G = Object.assign;
      b.exports = !G || l(101)(function() {
        var L = {}, o = {}, h = Symbol(), p = "abcdefghijklmnopqrst";
        return L[h] = 7, p.split("").forEach(function(r) {
          o[r] = r;
        }), G({}, L)[h] != 7 || Object.keys(G({}, o)).join("") != p;
      }) ? function(o, h) {
        for (var p = n(o), r = arguments.length, V = 1, W = c.f, y = m.f; r > V; )
          for (var t = X(arguments[V++]), e = W ? s(t).concat(W(t)) : s(t), Z = e.length, a = 0, x; Z > a; )
            x = e[a++], (!i || y.call(t, x)) && (p[x] = t[x]);
        return p;
      } : G;
    },
    /* 168 */
    /***/
    function(b, d) {
      d.f = Object.getOwnPropertySymbols;
    },
    /* 169 */
    /***/
    function(b, d) {
      d.f = {}.propertyIsEnumerable;
    },
    /* 170 */
    /***/
    function(b, d, l) {
      d.__esModule = !0, d.default = function(i, s) {
        if (!(i instanceof s))
          throw new TypeError("Cannot call a class as a function");
      };
    },
    /* 171 */
    /***/
    function(b, d, l) {
      d.__esModule = !0;
      var i = l(172), s = c(i);
      function c(m) {
        return m && m.__esModule ? m : { default: m };
      }
      d.default = /* @__PURE__ */ function() {
        function m(n, X) {
          for (var G = 0; G < X.length; G++) {
            var L = X[G];
            L.enumerable = L.enumerable || !1, L.configurable = !0, "value" in L && (L.writable = !0), (0, s.default)(n, L.key, L);
          }
        }
        return function(n, X, G) {
          return X && m(n.prototype, X), G && m(n, G), n;
        };
      }();
    },
    /* 172 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(173), __esModule: !0 };
    },
    /* 173 */
    /***/
    function(b, d, l) {
      l(174);
      var i = l(92).Object;
      b.exports = function(c, m, n) {
        return i.defineProperty(c, m, n);
      };
    },
    /* 174 */
    /***/
    function(b, d, l) {
      var i = l(90);
      i(i.S + i.F * !l(100), "Object", { defineProperty: l(96).f });
    },
    /* 175 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(176), __esModule: !0 };
    },
    /* 176 */
    /***/
    function(b, d, l) {
      l(177), l(143), l(184), l(185), b.exports = l(92).Symbol;
    },
    /* 177 */
    /***/
    function(b, d, l) {
      var i = l(91), s = l(105), c = l(100), m = l(90), n = l(106), X = l(150).KEY, G = l(101), L = l(117), o = l(121), h = l(118), p = l(122), r = l(178), V = l(179), W = l(180), y = l(156), t = l(97), e = l(98), Z = l(124), a = l(84), x = l(103), K = l(104), C = l(108), T = l(181), I = l(183), J = l(168), F = l(96), R = l(110), S = I.f, N = F.f, Q = T.f, P = i.Symbol, j = i.JSON, D = j && j.stringify, z = "prototype", w = p("_hidden"), A = p("toPrimitive"), ll = {}.propertyIsEnumerable, _ = L("symbol-registry"), cl = L("symbols"), $ = L("op-symbols"), al = Object[z], Xl = typeof P == "function" && !!J.f, M = i.QObject, k = !M || !M[z] || !M[z].findChild, E = c && G(function() {
        return C(N({}, "a", {
          get: function() {
            return N(this, "a", { value: 7 }).a;
          }
        })).a != 7;
      }) ? function(tl, sl, Zl) {
        var ol = S(al, sl);
        ol && delete al[sl], N(tl, sl, Zl), ol && tl !== al && N(al, sl, ol);
      } : N, O = function(tl) {
        var sl = cl[tl] = C(P[z]);
        return sl._k = tl, sl;
      }, g = Xl && typeof P.iterator == "symbol" ? function(tl) {
        return typeof tl == "symbol";
      } : function(tl) {
        return tl instanceof P;
      }, U = function(sl, Zl, ol) {
        return sl === al && U($, Zl, ol), t(sl), Zl = x(Zl, !0), t(ol), s(cl, Zl) ? (ol.enumerable ? (s(sl, w) && sl[w][Zl] && (sl[w][Zl] = !1), ol = C(ol, { enumerable: K(0, !1) })) : (s(sl, w) || N(sl, w, K(1, {})), sl[w][Zl] = !0), E(sl, Zl, ol)) : N(sl, Zl, ol);
      }, u = function(sl, Zl) {
        t(sl);
        for (var ol = W(Zl = a(Zl)), Wl = 0, el = ol.length, pl; el > Wl; )
          U(sl, pl = ol[Wl++], Zl[pl]);
        return sl;
      }, Y = function(sl, Zl) {
        return Zl === void 0 ? C(sl) : u(C(sl), Zl);
      }, H = function(sl) {
        var Zl = ll.call(this, sl = x(sl, !0));
        return this === al && s(cl, sl) && !s($, sl) ? !1 : Zl || !s(this, sl) || !s(cl, sl) || s(this, w) && this[w][sl] ? Zl : !0;
      }, v = function(sl, Zl) {
        if (sl = a(sl), Zl = x(Zl, !0), !(sl === al && s(cl, Zl) && !s($, Zl))) {
          var ol = S(sl, Zl);
          return ol && s(cl, Zl) && !(s(sl, w) && sl[w][Zl]) && (ol.enumerable = !0), ol;
        }
      }, f = function(sl) {
        for (var Zl = Q(a(sl)), ol = [], Wl = 0, el; Zl.length > Wl; )
          !s(cl, el = Zl[Wl++]) && el != w && el != X && ol.push(el);
        return ol;
      }, B = function(sl) {
        for (var Zl = sl === al, ol = Q(Zl ? $ : a(sl)), Wl = [], el = 0, pl; ol.length > el; )
          s(cl, pl = ol[el++]) && (!Zl || s(al, pl)) && Wl.push(cl[pl]);
        return Wl;
      };
      Xl || (P = function() {
        if (this instanceof P)
          throw TypeError("Symbol is not a constructor!");
        var sl = h(arguments.length > 0 ? arguments[0] : void 0), Zl = function(ol) {
          this === al && Zl.call($, ol), s(this, w) && s(this[w], sl) && (this[w][sl] = !1), E(this, sl, K(1, ol));
        };
        return c && k && E(al, sl, { configurable: !0, set: Zl }), O(sl);
      }, n(P[z], "toString", function() {
        return this._k;
      }), I.f = v, F.f = U, l(182).f = T.f = f, l(169).f = H, J.f = B, c && !l(89) && n(al, "propertyIsEnumerable", H, !0), r.f = function(tl) {
        return O(p(tl));
      }), m(m.G + m.W + m.F * !Xl, { Symbol: P });
      for (var q = (
        // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
        "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(",")
      ), dl = 0; q.length > dl; )
        p(q[dl++]);
      for (var il = R(p.store), bl = 0; il.length > bl; )
        V(il[bl++]);
      m(m.S + m.F * !Xl, "Symbol", {
        // 19.4.2.1 Symbol.for(key)
        for: function(tl) {
          return s(_, tl += "") ? _[tl] : _[tl] = P(tl);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function(sl) {
          if (!g(sl))
            throw TypeError(sl + " is not a symbol!");
          for (var Zl in _)
            if (_[Zl] === sl)
              return Zl;
        },
        useSetter: function() {
          k = !0;
        },
        useSimple: function() {
          k = !1;
        }
      }), m(m.S + m.F * !Xl, "Object", {
        // 19.1.2.2 Object.create(O [, Properties])
        create: Y,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: U,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: u,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: v,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: f,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: B
      });
      var ml = G(function() {
        J.f(1);
      });
      m(m.S + m.F * ml, "Object", {
        getOwnPropertySymbols: function(sl) {
          return J.f(Z(sl));
        }
      }), j && m(m.S + m.F * (!Xl || G(function() {
        var tl = P();
        return D([tl]) != "[null]" || D({ a: tl }) != "{}" || D(Object(tl)) != "{}";
      })), "JSON", {
        stringify: function(sl) {
          for (var Zl = [sl], ol = 1, Wl, el; arguments.length > ol; )
            Zl.push(arguments[ol++]);
          if (el = Wl = Zl[1], !(!e(Wl) && sl === void 0 || g(sl)))
            return y(Wl) || (Wl = function(pl, Kl) {
              if (typeof el == "function" && (Kl = el.call(this, pl, Kl)), !g(Kl))
                return Kl;
            }), Zl[1] = Wl, D.apply(j, Zl);
        }
      }), P[z][A] || l(95)(P[z], A, P[z].valueOf), o(P, "Symbol"), o(Math, "Math", !0), o(i.JSON, "JSON", !0);
    },
    /* 178 */
    /***/
    function(b, d, l) {
      d.f = l(122);
    },
    /* 179 */
    /***/
    function(b, d, l) {
      var i = l(91), s = l(92), c = l(89), m = l(178), n = l(96).f;
      b.exports = function(X) {
        var G = s.Symbol || (s.Symbol = c ? {} : i.Symbol || {});
        X.charAt(0) != "_" && !(X in G) && n(G, X, { value: m.f(X) });
      };
    },
    /* 180 */
    /***/
    function(b, d, l) {
      var i = l(110), s = l(168), c = l(169);
      b.exports = function(m) {
        var n = i(m), X = s.f;
        if (X)
          for (var G = X(m), L = c.f, o = 0, h; G.length > o; )
            L.call(m, h = G[o++]) && n.push(h);
        return n;
      };
    },
    /* 181 */
    /***/
    function(b, d, l) {
      var i = l(84), s = l(182).f, c = {}.toString, m = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], n = function(X) {
        try {
          return s(X);
        } catch {
          return m.slice();
        }
      };
      b.exports.f = function(G) {
        return m && c.call(G) == "[object Window]" ? n(G) : s(i(G));
      };
    },
    /* 182 */
    /***/
    function(b, d, l) {
      var i = l(111), s = l(119).concat("length", "prototype");
      d.f = Object.getOwnPropertyNames || function(m) {
        return i(m, s);
      };
    },
    /* 183 */
    /***/
    function(b, d, l) {
      var i = l(169), s = l(104), c = l(84), m = l(103), n = l(105), X = l(99), G = Object.getOwnPropertyDescriptor;
      d.f = l(100) ? G : function(o, h) {
        if (o = c(o), h = m(h, !0), X)
          try {
            return G(o, h);
          } catch {
          }
        if (n(o, h))
          return s(!i.f.call(o, h), o[h]);
      };
    },
    /* 184 */
    /***/
    function(b, d, l) {
      l(179)("asyncIterator");
    },
    /* 185 */
    /***/
    function(b, d, l) {
      l(179)("observable");
    },
    /* 186 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.createNowTime = i, d.formatDelay = s;
      function i() {
        var c = null;
        return Date.now ? c = Date.now : c = function() {
          return (/* @__PURE__ */ new Date()).getTime();
        }, c;
      }
      function s(c) {
        return typeof c == "number" ? c = { delay: c } : "entropy" in c && (c = { delay: c.entropy, isEntropy: !0 }), c;
      }
    },
    /* 187 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.default = {
        // s - startFrame, e - endFrame
        default: function(s, c, m, n, X) {
          return typeof s == "number" && typeof c == "number" ? s + (m - n) / (X - n) * (c - s) : m - n > X - m ? c : s;
        }
      };
    },
    /* 188 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.parseEasing = d.Easings = void 0;
      var i = l(76), s = G(i), c = l(133), m = G(c), n = l(141), X = G(n);
      function G(y) {
        return y && y.__esModule ? y : { default: y };
      }
      var L = l(189), o = new X.default();
      function h() {
        for (var y = arguments.length, t = Array(y), e = 0; e < y; e++)
          t[e] = arguments[e];
        var Z = o.get(t);
        return Z || (Z = L.apply(void 0, t), o.set(t, Z), Z);
      }
      function p(y) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "end";
        return function(e, Z) {
          for (var a = 1; a < Z.length; a++) {
            var x = Z[a].offset;
            if (e <= x) {
              var K = Z[a - 1].offset, C = x, T = (e - K) / (C - K), I = 1 / y, J = T / I;
              return t === "end" ? J = Math.floor(J) : J = Math.ceil(J), I * J * (C - K) + K;
            }
          }
          return 0;
        };
      }
      function r(y) {
        var t = /^cubic-bezier\((.*)\)/, e = y.match(t);
        if (e) {
          var Z = e[1].trim();
          return Z = Z.split(",").map(function(I) {
            return parseFloat(I.trim());
          }), h.apply(void 0, (0, m.default)(Z));
        }
        if (t = /^steps\((.*)\)/, e = y.match(t), e) {
          var a = e[1].trim();
          a = a.split(",").map(function(I) {
            return I.trim();
          });
          var x = a, K = (0, s.default)(x, 2), C = K[0], T = K[1];
          return p(parseInt(C, 10), T);
        }
        return y;
      }
      var V = {
        linear: function(t) {
          return t;
        },
        ease: h(0.25, 0.1, 0.25, 1),
        "ease-in": h(0.42, 0, 1, 1),
        "ease-out": h(0, 0, 0.58, 1),
        "ease-in-out": h(0.42, 0, 0.58, 1),
        // 'step-start': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     ret = offset
        //     if(p < offset){
        //       break
        //     }
        //   }
        //   return ret
        // },
        // 'step-end': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     if(p < offset){
        //       break
        //     }
        //     ret = offset
        //   }
        //   return ret
        // }
        "step-start": p(1, "start"),
        "step-end": p(1, "end")
      };
      function W(y) {
        return typeof y == "string" ? V[y] ? y = V[y] : y = r(y) : y.type === "cubic-bezier" ? y = h.apply(void 0, (0, m.default)(y.value)) : y.type === "steps" && (y = p(y.step, y.pos)), y;
      }
      d.Easings = V, d.parseEasing = W;
    },
    /* 189 */
    /***/
    function(b, d) {
      var l = 4, i = 1e-3, s = 1e-7, c = 10, m = 11, n = 1 / (m - 1), X = typeof Float32Array == "function";
      function G(y, t) {
        return 1 - 3 * t + 3 * y;
      }
      function L(y, t) {
        return 3 * t - 6 * y;
      }
      function o(y) {
        return 3 * y;
      }
      function h(y, t, e) {
        return ((G(t, e) * y + L(t, e)) * y + o(t)) * y;
      }
      function p(y, t, e) {
        return 3 * G(t, e) * y * y + 2 * L(t, e) * y + o(t);
      }
      function r(y, t, e, Z, a) {
        var x, K, C = 0;
        do
          K = t + (e - t) / 2, x = h(K, Z, a) - y, x > 0 ? e = K : t = K;
        while (Math.abs(x) > s && ++C < c);
        return K;
      }
      function V(y, t, e, Z) {
        for (var a = 0; a < l; ++a) {
          var x = p(t, e, Z);
          if (x === 0)
            return t;
          var K = h(t, e, Z) - y;
          t -= K / x;
        }
        return t;
      }
      function W(y) {
        return y;
      }
      b.exports = function(t, e, Z, a) {
        if (!(0 <= t && t <= 1 && 0 <= Z && Z <= 1))
          throw new Error("bezier x values must be in [0, 1] range");
        if (t === e && Z === a)
          return W;
        for (var x = X ? new Float32Array(m) : new Array(m), K = 0; K < m; ++K)
          x[K] = h(K * n, t, Z);
        function C(T) {
          for (var I = 0, J = 1, F = m - 1; J !== F && x[J] <= T; ++J)
            I += n;
          --J;
          var R = (T - x[J]) / (x[J + 1] - x[J]), S = I + R * n, N = p(S, t, Z);
          return N >= i ? V(T, S, t, Z) : N === 0 ? S : r(T, I, I + n, t, Z);
        }
        return function(I) {
          return I === 0 ? 0 : I === 1 ? 1 : h(C(I), e, a);
        };
      };
    },
    /* 190 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      });
      var i = l(191), s = e(i), c = l(204), m = e(c), n = l(164), X = e(n), G = l(170), L = e(G), o = l(171), h = e(o), p = l(175), r = e(p), V = l(75), W = e(V), y = l(208), t = l(188);
      function e(N) {
        return N && N.__esModule ? N : { default: N };
      }
      var Z = (0, r.default)("timing"), a = (0, r.default)("keyframes"), x = (0, r.default)("initState"), K = (0, r.default)("readyDefer"), C = (0, r.default)("finishedDefer"), T = (0, r.default)("effects"), I = (0, r.default)("activeReadyTimer"), J = (0, r.default)("activeFinishTimer"), F = (0, r.default)("removeDefer"), R = {
        delay: 0,
        endDelay: 0,
        fill: "auto",
        iterations: 1,
        playbackRate: 1,
        direction: "normal",
        easing: "linear",
        effect: null
      }, S = function() {
        function N(Q, P, j) {
          var D = this;
          if ((0, L.default)(this, N), Array.isArray(Q)) {
            var z = [Q[0], Q, P];
            Q = z[0], P = z[1], j = z[2];
          }
          typeof j == "number" && (j = { duration: j }), this[Z] = (0, X.default)({}, R, j), this[Z].easing = (0, t.parseEasing)(this[Z].easing), this[a] = (0, y.calculateFramesOffset)(P);
          var w = this[a][this[a].length - 1];
          this[x] = {}, (0, m.default)(w).forEach(function(A) {
            Object.prototype.hasOwnProperty.call(Q, A) && A !== "easing" && A !== "offset" && (D[x][A] = Q[A]);
          }), this[a] = this[a].map(function(A) {
            return (0, X.default)({}, D[x], A);
          }), this[a][0].offset !== 0 && this[a].unshift((0, X.default)({}, this[x], { offset: 0 })), w.offset < 1 && this[a].push((0, X.default)({}, w, { offset: 1 })), this[T] = {}, this.timeline = null;
        }
        return (0, h.default)(N, [{
          key: "pause",
          value: function() {
            this.timeline.playbackRate = 0;
          }
        }, {
          key: I,
          value: function() {
            var P = this;
            this[K] && !this[K].timerID && (this.timeline.currentTime < 0 ? this[K].timerID = this.timeline.setTimeout(function() {
              P[K].resolve(), delete P[K];
            }, { delay: -this.timeline.currentTime, heading: !1 }) : this[K].timerID = this.timeline.setTimeout(function() {
              P[K].resolve(), delete P[K];
            }, { delay: 0, isEntropy: !0 }));
          }
        }, {
          key: J,
          value: function() {
            var P = this, j = this[Z], D = j.duration, z = j.iterations, w = j.endDelay, A = Math.ceil(D * z + w - this.timeline.currentTime) + 1;
            this[C] && !this[C].timerID && (this[C].timerID = this.timeline.setTimeout(function() {
              P[C].resolve(), P[F](K), P[F](C);
            }, { delay: A, heading: !1 }), this[C].reverseTimerID = this.timeline.setTimeout(function() {
              P[C].resolve(), P[F](K), P[F](C), P.timeline = null;
            }, { delay: -this[Z].delay - 1, heading: !1 }));
          }
        }, {
          key: "play",
          value: function() {
            if (this.playState === "finished" && this.cancel(), this.playState === "idle") {
              if (this.playbackRate <= 0)
                return;
              var P = this[Z], j = P.delay, D = P.playbackRate, z = P.timeline;
              this.timeline = new W.default({
                originTime: j,
                playbackRate: D
              }, z), this[I](), this[J]();
            } else
              this.playState === "paused" && (this.timeline.playbackRate = this.playbackRate, this[I]());
          }
        }, {
          key: F,
          value: function(P) {
            var j = this[P], D = this.timeline;
            j && D && (D.clearTimeout(j.timerID), j.reverseTimerID && D.clearTimeout(j.reverseTimerID)), delete this[P];
          }
        }, {
          key: "cancel",
          value: function() {
            this[F](K), this[F](C), this.timeline = null;
          }
        }, {
          key: "finish",
          value: function() {
            this.timeline && (this.timeline.currentTime = 1 / 0 / this.playbackRate), this[F](K), this[F](C);
          }
        }, {
          key: "applyEffects",
          value: function(P) {
            return (0, X.default)(this[T], P);
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[Z].playbackRate;
          },
          set: function(P) {
            this.timeline && (this.timeline.playbackRate = P), this[Z].playbackRate = P;
          }
        }, {
          key: "playState",
          get: function() {
            var P = this.timeline, j = this[Z], D = j.iterations, z = j.duration, w = j.endDelay, A = "running";
            if (P == null)
              A = "idle";
            else if (P.paused)
              A = "paused";
            else if (P.currentTime < 0)
              A = "pending";
            else {
              var ll = P.currentTime - D * z;
              ll > 0 && ll < w ? A = "pending" : ll >= w && (A = "finished");
            }
            return A;
          }
        }, {
          key: "progress",
          get: function() {
            if (!this.timeline)
              return 0;
            var P = this[Z], j = P.duration, D = P.iterations, z = this.timeline, w = this.playState, A = void 0;
            if (w === "idle")
              A = 0;
            else if (w === "paused" && z.currentTime < 0)
              A = 0;
            else if (w === "pending")
              if (z.currentTime < 0)
                A = 0;
              else {
                var ll = z.seekLocalTime(D * j);
                A = (0, y.periodicity)(ll, j)[1] / j;
              }
            else
              (w === "running" || w === "paused") && (A = (0, y.periodicity)(z.currentTime, j)[1] / j);
            return w === "finished" && (A = (0, y.periodicity)(D, 1)[1]), A;
          }
        }, {
          key: "frame",
          get: function() {
            var P = this.playState, j = this[x], D = this[Z].fill;
            if (P === "idle")
              return j;
            var z = this.timeline.currentTime, w = this[a].slice(0), A = (0, y.getProgress)(this.timeline, this[Z], this.progress), ll = A.p, _ = A.inverted, cl = j;
            return z < 0 && P === "pending" ? (D === "backwards" || D === "both") && (cl = _ ? w[w.length - 1] : w[0]) : (P !== "pending" && P !== "finished" || D === "forwards" || D === "both") && (cl = (0, y.getCurrentFrame)(this[Z], w, this[T], ll)), cl;
          }
        }, {
          key: "timing",
          get: function() {
            return this[Z];
          }
        }, {
          key: "effects",
          get: function() {
            return this[T];
          }
        }, {
          key: "baseTimeline",
          set: function(P) {
            this[Z].timeline = P;
          },
          get: function() {
            return this[Z].timeline;
          }
        }, {
          key: "ready",
          get: function() {
            return this[K] ? this[K].promise : this.timeline && this.timeline.currentTime >= 0 && this.playState !== "paused" ? s.default.resolve() : (this[K] = (0, y.defer)(), this.timeline && this[I](), this[K] ? this[K].promise : s.default.resolve());
          }
        }, {
          key: "finished",
          get: function() {
            return this.playState === "finished" ? s.default.resolve() : (this[C] || (this[C] = (0, y.defer)(), this.timeline && this[J]()), this[C].promise);
          }
        }]), N;
      }();
      d.default = S;
    },
    /* 191 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(192), __esModule: !0 };
    },
    /* 192 */
    /***/
    function(b, d, l) {
      l(143), l(125), l(79), l(193), l(202), l(203), b.exports = l(92).Promise;
    },
    /* 193 */
    /***/
    function(b, d, l) {
      var i = l(89), s = l(91), c = l(93), m = l(128), n = l(90), X = l(98), G = l(94), L = l(147), o = l(148), h = l(194), p = l(195).set, r = l(197)(), V = l(198), W = l(199), y = l(200), t = l(201), e = "Promise", Z = s.TypeError, a = s.process, x = a && a.versions, K = x && x.v8 || "", C = s[e], T = m(a) == "process", I = function() {
      }, J, F, R, S, N = F = V.f, Q = !!function() {
        try {
          var _ = C.resolve(1), cl = (_.constructor = {})[l(122)("species")] = function($) {
            $(I, I);
          };
          return (T || typeof PromiseRejectionEvent == "function") && _.then(I) instanceof cl && K.indexOf("6.6") !== 0 && y.indexOf("Chrome/66") === -1;
        } catch {
        }
      }(), P = function(_) {
        var cl;
        return X(_) && typeof (cl = _.then) == "function" ? cl : !1;
      }, j = function(_, cl) {
        if (!_._n) {
          _._n = !0;
          var $ = _._c;
          r(function() {
            for (var al = _._v, Xl = _._s == 1, M = 0, k = function(E) {
              var O = Xl ? E.ok : E.fail, g = E.resolve, U = E.reject, u = E.domain, Y, H, v;
              try {
                O ? (Xl || (_._h == 2 && w(_), _._h = 1), O === !0 ? Y = al : (u && u.enter(), Y = O(al), u && (u.exit(), v = !0)), Y === E.promise ? U(Z("Promise-chain cycle")) : (H = P(Y)) ? H.call(Y, g, U) : g(Y)) : U(al);
              } catch (f) {
                u && !v && u.exit(), U(f);
              }
            }; $.length > M; )
              k($[M++]);
            _._c = [], _._n = !1, cl && !_._h && D(_);
          });
        }
      }, D = function(_) {
        p.call(s, function() {
          var cl = _._v, $ = z(_), al, Xl, M;
          if ($ && (al = W(function() {
            T ? a.emit("unhandledRejection", cl, _) : (Xl = s.onunhandledrejection) ? Xl({ promise: _, reason: cl }) : (M = s.console) && M.error && M.error("Unhandled promise rejection", cl);
          }), _._h = T || z(_) ? 2 : 1), _._a = void 0, $ && al.e)
            throw al.v;
        });
      }, z = function(_) {
        return _._h !== 1 && (_._a || _._c).length === 0;
      }, w = function(_) {
        p.call(s, function() {
          var cl;
          T ? a.emit("rejectionHandled", _) : (cl = s.onrejectionhandled) && cl({ promise: _, reason: _._v });
        });
      }, A = function(_) {
        var cl = this;
        cl._d || (cl._d = !0, cl = cl._w || cl, cl._v = _, cl._s = 2, cl._a || (cl._a = cl._c.slice()), j(cl, !0));
      }, ll = function(_) {
        var cl = this, $;
        if (!cl._d) {
          cl._d = !0, cl = cl._w || cl;
          try {
            if (cl === _)
              throw Z("Promise can't be resolved itself");
            ($ = P(_)) ? r(function() {
              var al = { _w: cl, _d: !1 };
              try {
                $.call(_, c(ll, al, 1), c(A, al, 1));
              } catch (Xl) {
                A.call(al, Xl);
              }
            }) : (cl._v = _, cl._s = 1, j(cl, !1));
          } catch (al) {
            A.call({ _w: cl, _d: !1 }, al);
          }
        }
      };
      Q || (C = function(cl) {
        L(this, C, e, "_h"), G(cl), J.call(this);
        try {
          cl(c(ll, this, 1), c(A, this, 1));
        } catch ($) {
          A.call(this, $);
        }
      }, J = function(cl) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
      }, J.prototype = l(146)(C.prototype, {
        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function(cl, $) {
          var al = N(h(this, C));
          return al.ok = typeof cl == "function" ? cl : !0, al.fail = typeof $ == "function" && $, al.domain = T ? a.domain : void 0, this._c.push(al), this._a && this._a.push(al), this._s && j(this, !1), al.promise;
        },
        // 25.4.5.1 Promise.prototype.catch(onRejected)
        catch: function(_) {
          return this.then(void 0, _);
        }
      }), R = function() {
        var _ = new J();
        this.promise = _, this.resolve = c(ll, _, 1), this.reject = c(A, _, 1);
      }, V.f = N = function(_) {
        return _ === C || _ === S ? new R(_) : F(_);
      }), n(n.G + n.W + n.F * !Q, { Promise: C }), l(121)(C, e), l(149)(e), S = l(92)[e], n(n.S + n.F * !Q, e, {
        // 25.4.4.5 Promise.reject(r)
        reject: function(cl) {
          var $ = N(this), al = $.reject;
          return al(cl), $.promise;
        }
      }), n(n.S + n.F * (i || !Q), e, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function(cl) {
          return t(i && this === S ? C : this, cl);
        }
      }), n(n.S + n.F * !(Q && l(140)(function(_) {
        C.all(_).catch(I);
      })), e, {
        // 25.4.4.1 Promise.all(iterable)
        all: function(cl) {
          var $ = this, al = N($), Xl = al.resolve, M = al.reject, k = W(function() {
            var E = [], O = 0, g = 1;
            o(cl, !1, function(U) {
              var u = O++, Y = !1;
              E.push(void 0), g++, $.resolve(U).then(function(H) {
                Y || (Y = !0, E[u] = H, --g || Xl(E));
              }, M);
            }), --g || Xl(E);
          });
          return k.e && M(k.v), al.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function(cl) {
          var $ = this, al = N($), Xl = al.reject, M = W(function() {
            o(cl, !1, function(k) {
              $.resolve(k).then(al.resolve, Xl);
            });
          });
          return M.e && Xl(M.v), al.promise;
        }
      });
    },
    /* 194 */
    /***/
    function(b, d, l) {
      var i = l(97), s = l(94), c = l(122)("species");
      b.exports = function(m, n) {
        var X = i(m).constructor, G;
        return X === void 0 || (G = i(X)[c]) == null ? n : s(G);
      };
    },
    /* 195 */
    /***/
    function(b, d, l) {
      var i = l(93), s = l(196), c = l(120), m = l(102), n = l(91), X = n.process, G = n.setImmediate, L = n.clearImmediate, o = n.MessageChannel, h = n.Dispatch, p = 0, r = {}, V = "onreadystatechange", W, y, t, e = function() {
        var a = +this;
        if (r.hasOwnProperty(a)) {
          var x = r[a];
          delete r[a], x();
        }
      }, Z = function(a) {
        e.call(a.data);
      };
      (!G || !L) && (G = function(x) {
        for (var K = [], C = 1; arguments.length > C; )
          K.push(arguments[C++]);
        return r[++p] = function() {
          s(typeof x == "function" ? x : Function(x), K);
        }, W(p), p;
      }, L = function(x) {
        delete r[x];
      }, l(86)(X) == "process" ? W = function(a) {
        X.nextTick(i(e, a, 1));
      } : h && h.now ? W = function(a) {
        h.now(i(e, a, 1));
      } : o ? (y = new o(), t = y.port2, y.port1.onmessage = Z, W = i(t.postMessage, t, 1)) : n.addEventListener && typeof postMessage == "function" && !n.importScripts ? (W = function(a) {
        n.postMessage(a + "", "*");
      }, n.addEventListener("message", Z, !1)) : V in m("script") ? W = function(a) {
        c.appendChild(m("script"))[V] = function() {
          c.removeChild(this), e.call(a);
        };
      } : W = function(a) {
        setTimeout(i(e, a, 1), 0);
      }), b.exports = {
        set: G,
        clear: L
      };
    },
    /* 196 */
    /***/
    function(b, d) {
      b.exports = function(l, i, s) {
        var c = s === void 0;
        switch (i.length) {
          case 0:
            return c ? l() : l.call(s);
          case 1:
            return c ? l(i[0]) : l.call(s, i[0]);
          case 2:
            return c ? l(i[0], i[1]) : l.call(s, i[0], i[1]);
          case 3:
            return c ? l(i[0], i[1], i[2]) : l.call(s, i[0], i[1], i[2]);
          case 4:
            return c ? l(i[0], i[1], i[2], i[3]) : l.call(s, i[0], i[1], i[2], i[3]);
        }
        return l.apply(s, i);
      };
    },
    /* 197 */
    /***/
    function(b, d, l) {
      var i = l(91), s = l(195).set, c = i.MutationObserver || i.WebKitMutationObserver, m = i.process, n = i.Promise, X = l(86)(m) == "process";
      b.exports = function() {
        var G, L, o, h = function() {
          var W, y;
          for (X && (W = m.domain) && W.exit(); G; ) {
            y = G.fn, G = G.next;
            try {
              y();
            } catch (t) {
              throw G ? o() : L = void 0, t;
            }
          }
          L = void 0, W && W.enter();
        };
        if (X)
          o = function() {
            m.nextTick(h);
          };
        else if (c && !(i.navigator && i.navigator.standalone)) {
          var p = !0, r = document.createTextNode("");
          new c(h).observe(r, { characterData: !0 }), o = function() {
            r.data = p = !p;
          };
        } else if (n && n.resolve) {
          var V = n.resolve(void 0);
          o = function() {
            V.then(h);
          };
        } else
          o = function() {
            s.call(i, h);
          };
        return function(W) {
          var y = { fn: W, next: void 0 };
          L && (L.next = y), G || (G = y, o()), L = y;
        };
      };
    },
    /* 198 */
    /***/
    function(b, d, l) {
      var i = l(94);
      function s(c) {
        var m, n;
        this.promise = new c(function(X, G) {
          if (m !== void 0 || n !== void 0)
            throw TypeError("Bad Promise constructor");
          m = X, n = G;
        }), this.resolve = i(m), this.reject = i(n);
      }
      b.exports.f = function(c) {
        return new s(c);
      };
    },
    /* 199 */
    /***/
    function(b, d) {
      b.exports = function(l) {
        try {
          return { e: !1, v: l() };
        } catch (i) {
          return { e: !0, v: i };
        }
      };
    },
    /* 200 */
    /***/
    function(b, d, l) {
      var i = l(91), s = i.navigator;
      b.exports = s && s.userAgent || "";
    },
    /* 201 */
    /***/
    function(b, d, l) {
      var i = l(97), s = l(98), c = l(198);
      b.exports = function(m, n) {
        if (i(m), s(n) && n.constructor === m)
          return n;
        var X = c.f(m), G = X.resolve;
        return G(n), X.promise;
      };
    },
    /* 202 */
    /***/
    function(b, d, l) {
      var i = l(90), s = l(92), c = l(91), m = l(194), n = l(201);
      i(i.P + i.R, "Promise", { finally: function(X) {
        var G = m(this, s.Promise || c.Promise), L = typeof X == "function";
        return this.then(
          L ? function(o) {
            return n(G, X()).then(function() {
              return o;
            });
          } : X,
          L ? function(o) {
            return n(G, X()).then(function() {
              throw o;
            });
          } : X
        );
      } });
    },
    /* 203 */
    /***/
    function(b, d, l) {
      var i = l(90), s = l(198), c = l(199);
      i(i.S, "Promise", { try: function(m) {
        var n = s.f(this), X = c(m);
        return (X.e ? n.reject : n.resolve)(X.v), n.promise;
      } });
    },
    /* 204 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(205), __esModule: !0 };
    },
    /* 205 */
    /***/
    function(b, d, l) {
      l(206), b.exports = l(92).Object.keys;
    },
    /* 206 */
    /***/
    function(b, d, l) {
      var i = l(124), s = l(110);
      l(207)("keys", function() {
        return function(m) {
          return s(i(m));
        };
      });
    },
    /* 207 */
    /***/
    function(b, d, l) {
      var i = l(90), s = l(92), c = l(101);
      b.exports = function(m, n) {
        var X = (s.Object || {})[m] || Object[m], G = {};
        G[m] = n(X), i(i.S + i.F * c(function() {
          X(1);
        }), "Object", G);
      };
    },
    /* 208 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      });
      var i = l(76), s = r(i), c = l(209), m = r(c), n = l(164), X = r(n), G = l(191), L = r(G);
      d.defer = V, d.periodicity = W, d.calculateFramesOffset = y, d.getProgress = t, d.getCurrentFrame = Z;
      var o = l(188), h = l(187), p = r(h);
      function r(a) {
        return a && a.__esModule ? a : { default: a };
      }
      function V() {
        var a = {};
        return a.promise = new L.default(function(x, K) {
          a.resolve = x, a.reject = K;
        }), a;
      }
      function W(a, x) {
        var K = Math.floor(a / x), C = a - K * x;
        return C === 0 && K > 0 && (C = x, K--), [K, C];
      }
      function y(a) {
        a = a.slice(0);
        var x = a[0], K = a[a.length - 1];
        K.offset = K.offset || 1, x.offset = x.offset || 0;
        for (var C = 0, T = -1, I = 0; I < a.length; I++) {
          var J = a[I];
          if (J.offset != null) {
            var F = I - T;
            if (F > 1)
              for (var R = (J.offset - C) / F, S = 0; S < F - 1; S++)
                a[T + S + 1].offset = C + R * (S + 1);
            C = J.offset, T = I;
          }
          if (J.easing != null && (J.easing = (0, o.parseEasing)(J.easing)), I > 0) {
            var N = a[I].easing != null;
            a[I] = (0, X.default)({}, a[I - 1], a[I]), N || delete a[I].easing;
          }
        }
        return a;
      }
      function t(a, x, K) {
        var C = a.currentTime, T = x.direction, I = x.duration, J = !1;
        if (T === "reverse")
          K = 1 - K, J = !0;
        else if (T === "alternate" || T === "alternate-reverse") {
          var F = Math.floor(C / I);
          K === 1 && F--, F % 2 ^ T === "alternate-reverse" && (K = 1 - K, J = !0);
        }
        return { p: K, inverted: J };
      }
      function e(a, x, K, C) {
        var T = {};
        return (0, m.default)(x).forEach(function(I) {
          var J = (0, s.default)(I, 2), F = J[0], R = J[1];
          if (F !== "offset" && F !== "easing") {
            var S = K[F] || K.default, N = S(a[F], R, C, a.offset, x.offset);
            N != null && (T[F] = N);
          }
        }), T;
      }
      function Z(a, x, K, C) {
        var T = a.easing, I = a.effect;
        I || (K = (0, X.default)({}, p.default, K));
        var J = {};
        C = T(C, x);
        for (var F = 1; F < x.length; F++) {
          var R = x[F], S = R.offset;
          if (S >= C || F === x.length - 1) {
            var N = x[F - 1], Q = N.offset, P = N.easing, j = C;
            if (P) {
              var D = S - Q;
              j = P((C - Q) / D) * D + Q;
            }
            I ? J = I(N, R, j, Q, S) : J = e(N, R, K, j);
            break;
          }
        }
        return J;
      }
    },
    /* 209 */
    /***/
    function(b, d, l) {
      b.exports = { default: l(210), __esModule: !0 };
    },
    /* 210 */
    /***/
    function(b, d, l) {
      l(211), b.exports = l(92).Object.entries;
    },
    /* 211 */
    /***/
    function(b, d, l) {
      var i = l(90), s = l(212)(!0);
      i(i.S, "Object", {
        entries: function(m) {
          return s(m);
        }
      });
    },
    /* 212 */
    /***/
    function(b, d, l) {
      var i = l(100), s = l(110), c = l(84), m = l(169).f;
      b.exports = function(n) {
        return function(X) {
          for (var G = c(X), L = s(G), o = L.length, h = 0, p = [], r; o > h; )
            r = L[h++], (!i || m.call(G, r)) && p.push(n ? [r, G[r]] : G[r]);
          return p;
        };
      };
    },
    /* 213 */
    /***/
    function(b, d, l) {
      l.r(d), l(1).glMatrix.setMatrixArrayType(Array);
      const i = /* @__PURE__ */ new Map();
      function s(m, n = {}, X = []) {
        m = m.toLowerCase();
        const G = i.get(m);
        if (!G)
          throw new TypeError(`Invalid node: ${m}`);
        const L = new G(n);
        return X.forEach((o) => {
          L.appendChild(o);
        }), L;
      }
      const c = {
        registerNode(m, n, X = 100) {
          if (n = n.toLowerCase(), i.has(n))
            throw new TypeError(`Cannot registerNode, ${n} has been taken.`);
          i.set(n, m), Object.defineProperties(m.prototype, {
            nodeType: {
              value: X
            },
            tagName: {
              value: n.toUpperCase()
            },
            nodeName: {
              value: n
            },
            ownerDocument: {
              value: c
            },
            namespaceURI: {
              value: `http://spritejs.com/${n}`
            }
          });
        },
        createElement: s,
        createElementNS(m, n) {
          return s(n);
        },
        isSpriteNode(m) {
          return i.has(m.toLowerCase());
        }
      };
      d.default = c;
    },
    /* 214 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const i = Symbol("type"), s = Symbol("bubbles"), c = Symbol("originalEvent"), m = Symbol("detail");
      class n {
        constructor(G, {
          bubbles: L = null
        } = {}) {
          if (typeof G == "string" ? (this[i] = G, this[s] = !!L) : (this[i] = G.type, this[c] = G, this[s] = L != null ? !!L : !!G.bubbles, G.detail && (this[m] = G.detail)), !this[i])
            throw new TypeError("Invalid event type.");
          this.cancelBubble = !1;
        }
        setOriginalEvent(G) {
          this[c] = G;
        }
        get originalEvent() {
          return this[c];
        }
        get type() {
          return this[i];
        }
        get bubbles() {
          return this[s];
        }
        get detail() {
          return this[m];
        }
        stopPropagation() {
          this.cancelBubble = !0;
        }
      }
    },
    /* 215 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "parseFilterString", function() {
        return s;
      }), l.d(d, "applyFilters", function() {
        return c;
      });
      var i = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      function s(m) {
        if (m = m.trim(), !m || m === "none")
          return null;
        const n = /^(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+$/i, X = m.match(/(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+?/ig), G = [];
        return X && X.forEach((L) => {
          const o = L.match(n);
          if (!o)
            throw new TypeError("Invalid fitler string.");
          let [, h, p] = o;
          h = h.toLowerCase(), p = p.trim().match(/([^( )]+|([^( )]+\(.*\)))(?=\s|$)/g).map((r, V) => {
            let W;
            return h === "url" || h === "drop-shadow" && V === 3 ? W = r : W = Object(i.toNumber)(r), /%$/.test(r) && (W /= 100), W;
          }), G.push({
            type: h,
            args: p
          });
        }), G;
      }
      function c(m, n) {
        m.clearFilter(), n && n.forEach(({
          type: X,
          args: G
        }) => {
          let L = X;
          L === "drop-shadow" ? L = "dropShadow" : L === "hue-rotate" && (L = "hueRotate"), m[L](...G);
        });
      }
    },
    /* 216 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return i;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(s, c) {
        if (!c)
          return;
        const m = s.getListeners("beforerender"), n = s.getListeners("afterrender");
        m.length && !c.beforeRender ? c.beforeRender = (X) => {
          s.dispatchEvent({
            type: "beforerender",
            detail: {
              context: X
            }
          });
        } : m.length || (c.beforeRender = null), n.length && !c.afterRender ? c.afterRender = (X) => {
          s.dispatchEvent({
            type: "afterrender",
            detail: {
              context: X
            }
          });
        } : n.length || (c.afterRender = null);
      }
    },
    /* 217 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(12), s = l(218), c = l(70), m = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      const n = Symbol("amount"), X = Symbol("meshCloud");
      class G extends c.default {
        constructor(o, h = 1) {
          super(), this.meshNode = o, o.connect(this), this[n] = h, this[X] = null;
        }
        get meshCloud() {
          const o = this.meshNode, h = this[n];
          return !this[X] && o.mesh && (this[X] = new i.MeshCloud(o.mesh, h)), this[X];
        }
        /* override */
        get isVisible() {
          return !!this.meshNode && this.meshNode.isVisible;
        }
        get amount() {
          return this[n];
        }
        set amount(o) {
          this[n] = o, this[X] && (this[X].amount = o);
        }
        brightness(o, h) {
          this.meshCloud && (this.meshCloud.brightness(o, h), this.forceUpdate());
        }
        contrast(o, h) {
          this.meshCloud && (this.meshCloud.contrast(o, h), this.forceUpdate());
        }
        delete(o) {
          this.meshCloud && (this.meshCloud.delete(o), this[n]--, this.forceUpdate());
        }
        /* override */
        draw(o = []) {
          if (super.draw(o), this.meshCloud) {
            if (this.program) {
              this.meshCloud.setProgram(this.program);
              const h = this.shaderAttrs;
              h && Object.entries(h).forEach(([r, V]) => {
                this.meshCloud.mesh.setAttribute(r, V);
              });
              const p = this.uniforms;
              if (this.uniforms) {
                const r = {};
                Object.entries(p).forEach(([V, W]) => {
                  typeof W == "function" && (W = W(this, V)), r[V] = W;
                }), this.meshCloud.mesh.setUniforms(r);
              }
            }
            this.meshNode.textureImage && Object(s.drawTexture)(this.meshNode, this.meshNode.mesh), o.push(this.meshCloud);
          }
          return o;
        }
        getTransform(o) {
          if (this.meshCloud)
            return this.meshCloud.getTransform(o);
        }
        grayscale(o, h) {
          this.meshCloud && (this.meshCloud.grayscale(o, h), this.forceUpdate());
        }
        hueRotate(o, h) {
          this.meshCloud && (this.meshCloud.hueRotate(o, h), this.forceUpdate());
        }
        invert(o, h) {
          this.meshCloud && (this.meshCloud.invert(o, h), this.forceUpdate());
        }
        /* override */
        isPointCollision(o, h) {
          if (!this.meshCloud)
            return !1;
          const p = this.attributes.pointerEvents;
          if (p === "none" || p !== "all" && !this.isVisible)
            return !1;
          let r = "both";
          p === "visibleFill" && (r = "fill"), p === "visibleStroke" && (r = "stroke");
          for (let V = 0; V < this[n]; V++)
            if (!this.meshCloud.isPointCollision(V, [o, h], r))
              return !1;
          return !0;
        }
        setOpacity(o, h) {
          this.meshCloud && (this.meshCloud.opacity(o, h), this.forceUpdate());
        }
        rotate(o, h, [p, r] = [0, 0]) {
          const V = Math.PI * h / 180;
          if (this.meshCloud) {
            const {
              x: W,
              y
            } = this.meshNode.attributes;
            this.meshCloud.rotate(o, V, [p + W, r + y]), this.forceUpdate();
          }
        }
        saturate(o, h) {
          this.meshCloud && (this.meshCloud.saturate(o, h), this.forceUpdate());
        }
        scale(o, [h, p = h], [r, V] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: W,
              y
            } = this.meshNode.attributes, t = 1e-5;
            Math.abs(h) < t && (h = 1 / h > 0 ? t : -t), Math.abs(p) < t && (p = 1 / p > 0 ? t : -t), this.meshCloud.scale(o, [h, p], [r + W, V + y]), this.forceUpdate();
          }
        }
        setColorTransform(o, h) {
          this.meshCloud && (this.meshCloud.setColorTransform(o, h), this.forceUpdate());
        }
        setFillColor(o, h) {
          this.meshCloud && (Array.isArray(h) && (h = [...h], h[0] /= 255, h[1] /= 255, h[2] /= 255), this.meshCloud.setFillColor(o, h), this.forceUpdate());
        }
        sepia(o, h) {
          this.meshCloud && (this.meshCloud.sepia(o, h), this.forceUpdate());
        }
        /* override */
        setResolution({
          width: o,
          height: h
        }) {
          super.setResolution({
            width: o,
            height: h
          }), this.meshNode.setResolution({
            width: o,
            height: h
          });
        }
        setStrokeColor(o, h) {
          this.meshCloud && (Array.isArray(h) && (h = [...h], h[0] /= 255, h[1] /= 255, h[2] /= 255), this.meshCloud.setStrokeColor(o, h), this.forceUpdate());
        }
        setTransform(o, h) {
          this.meshCloud && (this.meshCloud.setTransform(o, h), this.forceUpdate());
        }
        skew(o, [h, p = h], [r, V] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: W,
              y
            } = this.meshNode.attributes;
            this.meshCloud.skew(o, [h, p], [r + W, V + y]), this.forceUpdate();
          }
        }
        transform(o, h) {
          this.meshCloud && (this.meshCloud.transform(o, h), this.forceUpdate());
        }
        transformColor(o, h) {
          this.meshCloud && (this.meshCloud.transformColor(o, h), this.forceUpdate());
        }
        translate(o, [h, p]) {
          this.meshCloud && (this.meshCloud.translate(o, [h, p]), this.forceUpdate());
        }
        updateMesh() {
          this[X] && (this[X].mesh = this.meshNode.mesh, this.forceUpdate());
        }
      }
      m.default.registerNode(G, "cloud");
    },
    /* 218 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "loadTexture", function() {
        return m;
      }), l.d(d, "applyTexture", function() {
        return n;
      }), l.d(d, "createTexture", function() {
        return G;
      }), l.d(d, "deleteTexture", function() {
        return L;
      }), l.d(d, "drawTexture", function() {
        return h;
      }), l.d(d, "loadFrames", function() {
        return p;
      });
      var i = l(12), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = {};
      function m(r, V) {
        if (c[r])
          return c[r];
        const W = i.ENV.loadImage(r, {
          alias: V,
          useImageBitmap: !1
        });
        return W ?? r;
      }
      async function n(r, V, W) {
        let y = V;
        if (typeof V == "string" && (y = m(V)), y && typeof y.then == "function" && (y = await y), V === r.attributes.texture) {
          y && y.image && (y.sourceRect && (r.attributes.sourceRect = y.sourceRect), r.textureImageRotated = !!y.rotated, y = y.image);
          const {
            width: t,
            height: e,
            textureRect: Z
          } = r.attributes, a = r.textureImage;
          r.textureImage = y, W && a !== y && !Z && (t == null || e == null) && r.updateContours(), r.forceUpdate();
        }
        return y;
      }
      const X = Symbol("textureMap");
      function G(r, V) {
        if (V[X] = V[X] || /* @__PURE__ */ new Map(), V[X].has(r))
          return V[X].get(r);
        const W = V.createTexture(r);
        return !/^blob:/.test(r.src) && typeof r.getContext != "function" && V[X].set(r, W), W;
      }
      function L(r, V) {
        if (V[X] && V[X].has(r)) {
          const W = V[X].get(r);
          return V.deleteTexture(W), V[X].delete(r), !0;
        }
        return !1;
      }
      const o = Symbol("textureContext");
      function h(r, V) {
        const W = r.textureImage instanceof String ? String(r.textureImage) : r.textureImage, y = r.textureImageRotated, t = V.texture, e = r.renderer;
        if (W) {
          const Z = r.originalContentRect;
          let a = r.attributes.textureRect;
          const x = r.attributes.textureRepeat, K = r.attributes.sourceRect;
          if (!t || r[o] && r[o] !== e || t.image !== W || t.options.repeat !== x || !Object(s.compareValue)(t.options.rect, a) || !Object(s.compareValue)(t.options.srcRect, K)) {
            const C = G(W, e);
            a ? (a[0] += Z[0], a[1] += Z[1]) : a = Z;
            let T = null;
            t && !e[X].has(t.image) && (!t.options || !t.options.hidden) && (T = V.uniforms.u_texSampler), V.setTexture(C, {
              rect: a,
              repeat: x,
              srcRect: K,
              rotated: y
            }), T && T.delete && T.delete(), r[o] = e;
          }
        } else if (t) {
          let Z = null;
          !e[X].has(t.image) && (!t.options || !t.options.hidden) && (Z = V.uniforms.u_texSampler), V.setTexture(null), Z && Z.delete && Z.delete();
        }
      }
      async function p(r, V) {
        typeof V == "string" && (V = await (await fetch(V, {
          method: "GET",
          mode: "cors",
          cache: "default"
        })).json());
        const W = await m(r), y = V.frames;
        return Object.entries(y).forEach(([t, e]) => {
          const {
            x: Z,
            y: a,
            w: x,
            h: K
          } = e.frame;
          let C = [Z, a, x, K];
          const T = e.rotated;
          T && (C = [C[0], C[1], C[3], C[2]]), c[t] = {
            image: W,
            sourceRect: C,
            rotated: T
          };
        }), W;
      }
    },
    /* 219 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return p;
      });
      var i = l(1), s = l(12), c = l(70), m = l(220), n = l(221), X = l(222), G = l(213), L = l(223);
      l(1).glMatrix.setMatrixArrayType(Array);
      function o(r, V, W) {
        return V in r ? Object.defineProperty(r, V, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : r[V] = W, r;
      }
      const h = Symbol("mesh");
      class p extends c.default {
        constructor(V = {}) {
          super(V);
        }
        get borderSize() {
          const {
            paddingTop: V,
            paddingRight: W,
            paddingBottom: y,
            paddingLeft: t,
            borderWidth: e
          } = this.attributes, [Z, a] = this.contentSize;
          return [t + Z + W + e, V + a + y + e];
        }
        // content + padding
        get clientSize() {
          const {
            paddingTop: V,
            paddingRight: W,
            paddingBottom: y,
            paddingLeft: t
          } = this.attributes, [e, Z] = this.contentSize;
          return [t + e + W, V + Z + y];
        }
        get contentSize() {
          let {
            width: V,
            height: W,
            boxSizing: y,
            paddingTop: t,
            paddingRight: e,
            paddingBottom: Z,
            paddingLeft: a
          } = this.attributes;
          if (V = V || 0, W = W || 0, y === "border-box") {
            const x = 2 * this.attributes.borderWidth;
            V -= x + e + a, W -= x + t + Z, V = Math.max(0, V), W = Math.max(0, W);
          }
          return [V, W];
        }
        get hasBorder() {
          return this.attributes.borderWidth > 0;
        }
        /* override */
        get isVisible() {
          const [V, W] = this.borderSize;
          return V > 0 && W > 0;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const V = this.clientBox;
          if (V) {
            let W = this[h];
            if (W)
              W.box !== V && (W.contours = V.contours, W.box = V);
            else {
              W = new s.Mesh2D(V), W.box = V;
              const t = this.attributes.bgcolor;
              if (Object(n.setFillColor)(W, {
                color: t
              }), this.hasBorder) {
                const {
                  borderColor: Z,
                  borderWidth: a,
                  borderDash: x,
                  borderDashOffset: K
                } = this.attributes;
                Object(n.setStrokeColor)(W, {
                  color: Z,
                  lineWidth: a,
                  lineDash: x,
                  lineDashOffset: K
                });
              }
              this[h] = W;
              const e = this.attributes.clipPath;
              e && this[h].setClipPath(e);
            }
            const y = this.opacity;
            return W.getOpacity() !== y && W.setOpacity(y), W.setTransform(...this.renderMatrix), W;
          }
          return null;
        }
        // content + padding + border
        get offsetSize() {
          const {
            paddingTop: V,
            paddingRight: W,
            paddingBottom: y,
            paddingLeft: t,
            borderWidth: e
          } = this.attributes, [Z, a] = this.contentSize, x = 2 * e;
          return [t + Z + W + x, V + a + y + x];
        }
        get originalClientRect() {
          if (this.mesh) {
            const V = this.mesh.boundingBox;
            return [V[0][0], V[0][1], V[1][0] - V[0][0], V[1][1] - V[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalContentRect() {
          const [V, W, y, t] = this.originalClientRect, e = this.attributes.padding;
          return [V + e[0], W + e[1], y - e[0] - e[2], t - e[1] - e[3]];
        }
        getBoundingClientRect() {
          let V = this.renderMatrix;
          this.layer && this.layer.layerTransformInvert && (V = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), this.layer.transformMatrix, V));
          let W = null;
          if (this.mesh) {
            W = [...this.mesh.boundingBox];
            const y = this.attributes.borderWidth;
            y && (W[0] = [W[0][0] - y, W[0][1] - y], W[1] = [W[1][0] + y, W[1][1] + y]);
          }
          return Object(L.default)(W, V);
        }
        // transformPoint(x, y) {
        //   const m = mat2d.invert(this.renderMatrix);
        //   const newX = x * m[0] + y * m[2] + m[4];
        //   const newY = x * m[1] + y * m[3] + m[5];
        //   return [newX, newY];
        // }
        /* override */
        onPropertyChange(V, W, y) {
          if (super.onPropertyChange(V, W, y), (V === "anchorX" || V === "anchorY" || V === "boxSizing" || V === "width" || V === "height" || V === "borderWidth" || V === "paddingLeft" || V === "paddingRight" || V === "paddingTop" || V === "paddingBottom" || /^border(TopLeft|TopRight|BottomRight|BottomLeft)Radius$/.test(V)) && this.updateContours(), this[h] && V === "clipPath" && this[h].setClipPath(W), this[h] && V === "bgcolor" && Object(n.setFillColor)(this[h], {
            color: W
          }), this[h] && (V === "borderColor" || V === "borderWidth" || V === "borderDash" || V === "borderDashOffset")) {
            const {
              borderColor: t,
              borderWidth: e,
              borderDash: Z,
              borderDashOffset: a
            } = this.attributes;
            Object(n.setStrokeColor)(this[h], {
              color: t,
              lineWidth: e,
              lineDash: e ? Z : 0,
              lineDashOffset: a
            });
          }
        }
        /* override */
        updateContours() {
          const {
            anchorX: V,
            anchorY: W,
            borderWidth: y,
            borderRadius: t
          } = this.attributes, [e, Z] = this.borderSize, a = this.offsetSize, x = 0.5 * y, K = -V * a[0] + x, C = -W * a[1] + x;
          this.clientBox = new s.Figure2D(), Object(X.createRadiusBox)(this.clientBox, [K, C, e, Z], t);
        }
      }
      o(p, "Attr", m.default), G.default.registerNode(p, "block");
    },
    /* 220 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return L;
      });
      var i = l(71), s = l(72), c = l(221);
      l(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), X = Symbol.for("spritejs_setAttributeDefault"), G = Symbol.for("spritejs_declareAlias");
      class L extends i.default {
        constructor(h) {
          super(h), this[X]({
            anchorX: 0,
            anchorY: 0,
            /* anchor */
            width: void 0,
            height: void 0,
            /* size */
            borderWidth: 0,
            borderColor: "rgba(0,0,0,1)",
            /* border */
            borderDash: void 0,
            borderDashOffset: 0,
            borderTopLeftRadius: [0, 0],
            borderTopRightRadius: [0, 0],
            borderBottomRightRadius: [0, 0],
            borderBottomLeftRadius: [0, 0],
            /* borderRadius */
            bgcolor: "rgba(0,0,0,0)",
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            /* padding */
            boxSizing: "content-box",
            clipPath: void 0
          }), this[G]("anchor", "size", "border", "borderRadius", "padding");
        }
        get anchorX() {
          return this[n]("anchorX");
        }
        set anchorX(h) {
          this[m]("anchorX", Object(s.toNumber)(h));
        }
        get anchorY() {
          return this[n]("anchorY");
        }
        set anchorY(h) {
          this[m]("anchorY", Object(s.toNumber)(h));
        }
        get anchor() {
          return [this.anchorX, this.anchorY];
        }
        set anchor(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h, h]), this.anchorX = h[0], this.anchorY = h[1];
        }
        get width() {
          return this[n]("width");
        }
        set width(h) {
          this[m]("width", Object(s.toNumber)(h));
        }
        get height() {
          return this[n]("height");
        }
        set height(h) {
          this[m]("height", Object(s.toNumber)(h));
        }
        get size() {
          return [this.width, this.height];
        }
        set size(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h, h]), this.width = h[0], this.height = h[1];
        }
        get borderWidth() {
          return this[n]("borderWidth");
        }
        set borderWidth(h) {
          this[m]("borderWidth", Object(s.toNumber)(h));
        }
        get borderColor() {
          return this[n]("borderColor");
        }
        set borderColor(h) {
          this[m]("borderColor", Object(c.parseColor)(h));
        }
        get border() {
          return [this.borderWidth, this.borderColor];
        }
        set border(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h]), this.borderWidth = h[0], h[1] != null && (this.borderColor = h[1]);
        }
        get borderDash() {
          return this[n]("borderDash");
        }
        set borderDash(h) {
          h = Object(s.toArray)(h, !0), h != null && !Array.isArray(h) && (h = [h]), this[m]("borderDash", h ? h.map(s.toNumber) : null);
        }
        get borderDashOffset() {
          return this[n]("borderDashOffset");
        }
        set borderDashOffset(h) {
          this[m]("borderDashOffset", Object(s.toNumber)(h));
        }
        get borderTopLeftRadius() {
          return this[n]("borderTopLeftRadius");
        }
        set borderTopLeftRadius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this[m]("borderTopLeftRadius", h.map(s.toNumber));
        }
        get borderTopRightRadius() {
          return this[n]("borderTopRightRadius");
        }
        set borderTopRightRadius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this[m]("borderTopRightRadius", h.map(s.toNumber));
        }
        get borderBottomRightRadius() {
          return this[n]("borderBottomRightRadius");
        }
        set borderBottomRightRadius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this[m]("borderBottomRightRadius", h.map(s.toNumber));
        }
        get borderBottomLeftRadius() {
          return this[n]("borderBottomLeftRadius");
        }
        set borderBottomLeftRadius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this[m]("borderBottomLeftRadius", h.map(s.toNumber));
        }
        get borderRadius() {
          return [...this.borderTopLeftRadius, ...this.borderTopRightRadius, ...this.borderBottomRightRadius, ...this.borderBottomLeftRadius];
        }
        set borderRadius(h) {
          if (h = Object(s.toArray)(h), !Array.isArray(h))
            h = Array(8).fill(h);
          else if (h.length === 2)
            h = [h[0], h[1], h[0], h[1], h[0], h[1], h[0], h[1]];
          else if (h.length === 4)
            h = [h[0], h[1], h[2], h[3], h[0], h[1], h[2], h[3]];
          else if (h.length === 6)
            h = [h[0], h[1], h[2], h[3], h[4], h[5], h[2], h[3]];
          else if (h.length !== 8)
            throw new TypeError("Invalid borderRadius value.");
          this.borderTopLeftRadius = [h[0], h[1]], this.borderTopRightRadius = [h[2], h[3]], this.borderBottomRightRadius = [h[4], h[5]], this.borderBottomLeftRadius = [h[6], h[7]];
        }
        get bgcolor() {
          return this[n]("bgcolor");
        }
        set bgcolor(h) {
          this[m]("bgcolor", Object(c.parseColor)(h));
        }
        get paddingTop() {
          return this[n]("paddingTop");
        }
        set paddingTop(h) {
          this[m]("paddingTop", Object(s.toNumber)(h));
        }
        get paddingRight() {
          return this[n]("paddingRight");
        }
        set paddingRight(h) {
          this[m]("paddingRight", Object(s.toNumber)(h));
        }
        get paddingBottom() {
          return this[n]("paddingBottom");
        }
        set paddingBottom(h) {
          this[m]("paddingBottom", Object(s.toNumber)(h));
        }
        get paddingLeft() {
          return this[n]("paddingLeft");
        }
        set paddingLeft(h) {
          this[m]("paddingLeft", Object(s.toNumber)(h));
        }
        get padding() {
          return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
        }
        set padding(h) {
          h = Object(s.toArray)(h), Array.isArray(h) ? h.length === 2 ? h = [h[0], h[1], h[0], h[1]] : h.length === 3 && (h = [h[0], h[1], h[2], h[1]]) : h = [h, h, h, h], this.paddingTop = h[0], this.paddingRight = h[1], this.paddingBottom = h[2], this.paddingLeft = h[3];
        }
        get clipPath() {
          return this[n]("clipPath");
        }
        set clipPath(h) {
          this[m]("clipPath", h);
        }
        get boxSizing() {
          return this[n]("boxSizing");
        }
        set boxSizing(h) {
          if (h != null && h !== "border-box" && h !== "content-box")
            throw new TypeError("Invalid boxSizing type.");
          this[m]("boxSizing", h);
        }
      }
    },
    /* 221 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "Gradient", function() {
        return c;
      }), l.d(d, "isTransparent", function() {
        return m;
      }), l.d(d, "parseColor", function() {
        return n;
      }), l.d(d, "setFillColor", function() {
        return G;
      }), l.d(d, "setStrokeColor", function() {
        return L;
      }), l.d(d, "Color", function() {
        return o;
      });
      var i = l(32), s = /* @__PURE__ */ l.n(i);
      l(1).glMatrix.setMatrixArrayType(Array);
      class c {
        constructor({
          vector: p,
          colors: r
        }) {
          if (!Array.isArray(p) || p.length !== 4 && p.length !== 6 && p.length !== 3)
            throw new TypeError("Invalid gradient");
          this.vector = p, this.colors = r.map(({
            offset: V,
            color: W
          }) => ({
            offset: V,
            color: n(W)
          }));
        }
        toString() {
          return JSON.stringify({
            vector: this.vector,
            colors: this.colors
          });
        }
      }
      function m(h) {
        return h instanceof c ? !1 : h == null ? !0 : s()(h)[3] === 0;
      }
      function n(h) {
        if (h == null || (h || (h = "transparent"), h instanceof c))
          return h;
        const p = s()(h);
        if (!p || !p.length)
          throw new TypeError("Invalid color value.");
        return `rgba(${p.join()})`;
      }
      function X(h, p, r) {
        const V = h.boundingBox[0];
        if (r.vector) {
          let {
            vector: W,
            colors: y
          } = r;
          W.length === 4 ? (W = [W[0] + V[0], W[1] + V[1], W[2] + V[0], W[3] + V[1]], h.setLinearGradient({
            vector: W,
            colors: y,
            type: p
          })) : W.length === 3 ? (W = [W[0] + V[0], W[1] + V[1], W[2]], h.setCircularGradient({
            vector: W,
            colors: y,
            type: p
          })) : (W = [W[0] + V[0], W[1] + V[1], W[2], W[3] + V[0], W[4] + V[1], W[5]], h.setRadialGradient({
            vector: W,
            colors: y,
            type: p
          }));
        } else
          h.gradient && h.gradient[p] && (delete h.gradient[p], delete h.uniforms.u_radialGradientVector);
      }
      function G(h, {
        color: p,
        rule: r = "nonzero"
      }) {
        return X(h, "fill", p), p.vector || h.setFill({
          color: p,
          rule: r
        }), h;
      }
      function L(h, {
        color: p,
        lineWidth: r,
        lineCap: V,
        lineJoin: W,
        lineDash: y,
        lineDashOffset: t,
        miterLimit: e,
        roundSegments: Z
      }) {
        X(h, "stroke", p), p.vector && (p = [0, 0, 0, 1]), h.setStroke({
          color: p,
          thickness: r,
          cap: V,
          join: W,
          miterLimit: e,
          lineDash: y,
          lineDashOffset: t,
          roundSegments: Z
        });
      }
      class o extends Array {
        constructor(p = 0, r = 0, V = 0, W = 0) {
          return Array.isArray(p) && ([p, r, V, W] = p), typeof p == "string" && ([p, r, V, W] = s()(p), p /= 255, r /= 255, V /= 255), super(p, r, V, W), this;
        }
        get r() {
          return Math.round(this[0] * 255);
        }
        set r(p) {
          this[0] = p / 255;
        }
        get g() {
          return Math.round(this[1] * 255);
        }
        set g(p) {
          this[1] = p / 255;
        }
        get b() {
          return Math.round(this[2] * 255);
        }
        set b(p) {
          this[2] = p / 255;
        }
        get a() {
          return this[3];
        }
        set a(p) {
          this[3] = p;
        }
        get hex() {
          const p = `0${this.r.toString(16)}`.slice(-2), r = `0${this.g.toString(16)}`.slice(-2), V = `0${this.b.toString(16)}`.slice(-2);
          let W;
          return this.a < 1 && (W = Math.round(this[3] * 255), W = `0${W.toString(16)}`.slice(-2)), `#${p}${r}${V}${W || ""}`;
        }
        get rgba() {
          return `rgba(${this.r},${this.g},${this.b},${this.a})`;
        }
        fromColor(p) {
          return typeof p == "string" && (p = s()(p), p[0] /= 255, p[1] /= 255, p[2] /= 255), this[0] = p[0], this[1] = p[1], this[2] = p[2], this[3] = p[3], this;
        }
      }
    },
    /* 222 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "createRadiusBox", function() {
        return s;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(c, m, n, X, G, L = "leftTop") {
        const o = 0.5522848, h = X / 2 * o, p = G / 2 * o, r = m + X, V = n + G, W = m + X / 2, y = n + G / 2;
        L === "leftTop" ? (c.moveTo(m, y), c.bezierCurveTo(m, y - p, W - h, n, W, n)) : L === "rightTop" ? c.bezierCurveTo(W + h, n, r, y - p, r, y) : L === "rightBottom" ? c.bezierCurveTo(r, y + p, W + h, V, W, V) : L === "leftBottom" && c.bezierCurveTo(W - h, V, m, y + p, m, y);
      }
      function s(c, [m, n, X, G], L) {
        if (!L || Array.isArray(L) && L.every((o) => o === 0))
          c.beginPath(), c.rect(m, n, X, G);
        else {
          typeof L == "number" && (L = Array(8).fill(L));
          const [o, h, p, r, V, W, y, t] = L.map((e, Z) => Z % 2 ? Math.min(e, G / 2) : Math.min(e, X / 2));
          c.beginPath(), c.moveTo(m, n + h), i(c, m, n, o * 2, h * 2, "leftTop"), c.lineTo(m + X - p, n), i(c, m + X - p * 2, n, p * 2, r * 2, "rightTop"), c.lineTo(m + X, n + G - W), i(c, m + X - V * 2, n + G - W * 2, V * 2, W * 2, "rightBottom"), c.lineTo(m + y, n + G), i(c, m, n + G - t * 2, y * 2, t * 2, "leftBottom"), c.closePath();
        }
        return c;
      }
    },
    /* 223 */
    /***/
    function(b, d, l) {
      l.r(d), l(1).glMatrix.setMatrixArrayType(Array), d.default = function(i, s) {
        if (!i)
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
        const [[c, m], [n, X]] = i, G = c * s[0] + m * s[2] + s[4], L = c * s[1] + m * s[3] + s[5], o = n * s[0] + m * s[2] + s[4], h = n * s[1] + m * s[3] + s[5], p = n * s[0] + X * s[2] + s[4], r = n * s[1] + X * s[3] + s[5], V = c * s[0] + X * s[2] + s[4], W = c * s[1] + X * s[3] + s[5], y = Math.min(G, o, p, V), t = Math.min(L, h, r, W), e = Math.max(G, o, p, V), Z = Math.max(L, h, r, W);
        return {
          x: y,
          y: t,
          width: e - y,
          height: Z - t,
          left: y,
          top: t,
          right: e,
          bottom: Z
        };
      };
    },
    /* 224 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(218), s = l(219), c = l(225), m = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      function n(L, o, h) {
        return o in L ? Object.defineProperty(L, o, { value: h, enumerable: !0, configurable: !0, writable: !0 }) : L[o] = h, L;
      }
      const X = Symbol("textureTask");
      class G extends s.default {
        constructor(o = {}) {
          typeof o == "string" && (o = {
            texture: o
          }), super(o);
        }
        /* override */
        get contentSize() {
          let [o, h] = super.contentSize;
          const {
            width: p,
            height: r
          } = this.attributes;
          if (p == null || r == null) {
            const V = this.textureImage, W = this.attributes.textureRect, y = this.attributes.sourceRect;
            if (W)
              p == null && (o = W[0] + W[2]), r == null && (h = W[1] + W[3]);
            else if (y) {
              const t = this.layer ? this.layer.displayRatio : 1;
              p == null && (o = y[2] / t), r == null && (h = y[3] / t);
            } else if (V) {
              const t = this.layer ? this.layer.displayRatio : 1;
              p == null && (o = V.width / t), r == null && (h = V.height / t);
            }
          }
          return [o, h];
        }
        get textureImageReady() {
          return this[X] || Promise.resolve();
        }
        /* override */
        draw(o = []) {
          super.draw(o);
          const h = this.mesh;
          return h && Object(i.drawTexture)(this, h), o;
        }
        /* override */
        onPropertyChange(o, h, p) {
          if (super.onPropertyChange(o, h, p), o === "texture" && (this[X] = Object(i.applyTexture)(this, h, !0)), o === "textureRect") {
            const {
              width: r,
              height: V
            } = this.attributes;
            (r == null || V == null) && this.updateContours();
          }
        }
      }
      n(G, "Attr", c.default), m.default.registerNode(G, "sprite");
    },
    /* 225 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(220);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol.for("spritejs_setAttributeDefault"), c = Symbol.for("spritejs_setAttribute"), m = Symbol.for("spritejs_getAttribute");
      class n extends i.default {
        constructor(G) {
          super(G), this[s]({
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0
          });
        }
        get texture() {
          return this[m]("texture");
        }
        set texture(G) {
          this[c]("texture", G);
        }
        get textureRect() {
          return this[m]("textureRect");
        }
        set textureRect(G) {
          this[c]("textureRect", G);
        }
        get sourceRect() {
          return this[m]("sourceRect");
        }
        set sourceRect(G) {
          this[c]("sourceRect", G);
        }
        get textureRepeat() {
          return this[m]("textureRepeat");
        }
        set textureRepeat(G) {
          this[c]("textureRepeat", !!G);
        }
      }
    },
    /* 226 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return r;
      });
      var i = l(12), s = l(227), c = /* @__PURE__ */ l.n(s), m = l(70), n = l(228), X = l(221), G = l(218), L = l(213), o = l(223);
      l(1).glMatrix.setMatrixArrayType(Array);
      function h(V, W, y) {
        return W in V ? Object.defineProperty(V, W, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : V[W] = y, V;
      }
      const p = Symbol("mesh");
      class r extends m.default {
        constructor(W = {}) {
          typeof W == "string" && (W = {
            d: W
          }), super(W), this.effects = {
            d(y, t, e, Z, a) {
              const x = (e - Z) / (a - Z);
              if (x <= 0)
                return y;
              if (x >= 1)
                return t;
              const K = c.a._preprocessing(c.a.path2shapes(y), c.a.path2shapes(t)), C = c.a._lerp(...K, x)[0];
              return C.reduce((I, J) => `${I}${J.slice(2).join(" ")} `, `M${C[0][0]} ${C[0][1]}C`).trim();
            }
          };
        }
        /* override */
        get isVisible() {
          return !!this.d;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const W = this.path;
          if (W) {
            let y = this[p];
            if (y)
              y.path !== W && (y.contours = W.contours, y.path = W);
            else {
              y = new i.Mesh2D(this.path), y.path = W;
              const e = this.attributes.fillColor, Z = this.attributes.fillRule;
              e && Object(X.setFillColor)(y, {
                color: e,
                rule: Z
              });
              const a = this.attributes.lineWidth, x = this.attributes.strokeColor;
              if (x && a > 0) {
                const {
                  lineCap: C,
                  lineJoin: T,
                  miterLimit: I,
                  lineDash: J,
                  lineDashOffset: F,
                  roundSegments: R
                } = this.attributes;
                Object(X.setStrokeColor)(y, {
                  color: x,
                  lineWidth: a,
                  lineCap: C,
                  lineJoin: T,
                  miterLimit: I,
                  lineDash: J,
                  lineDashOffset: F,
                  roundSegments: R
                });
              }
              this[p] = y;
              const K = this.attributes.clipPath;
              K && this[p].setClipPath(K);
            }
            const t = this.opacity;
            return y.getOpacity() !== t && y.setOpacity(t), y.setTransform(...this.renderMatrix), y;
          }
          return null;
        }
        get originalContentRect() {
          if (this.path) {
            const W = this.path.boundingBox;
            return [W[0][0], W[0][1], W[1][0] - W[0][0], W[1][1] - W[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientRect() {
          if (this.mesh) {
            const W = this.mesh.boundingBox;
            return [W[0][0], W[0][1], W[1][0] - W[0][0], W[1][1] - W[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientCenter() {
          return this.mesh ? this.mesh.boundingCenter : [0, 0];
        }
        set d(W) {
          this.attributes.d = W;
        }
        get d() {
          return this.attributes.d;
        }
        /* override */
        draw(W = []) {
          super.draw(W);
          const y = this.mesh;
          return y && Object(G.drawTexture)(this, y), W;
        }
        getBoundingClientRect() {
          let W = null;
          return this.mesh && (W = this.mesh.boundingBox), Object(o.default)(W, this.renderMatrix);
        }
        getPathLength() {
          return this.mesh ? this.mesh.getTotalLength() : 0;
        }
        getPointAtLength(W) {
          if (this.mesh) {
            const y = this.mesh.getPointAtLength(W);
            if (y)
              return [y.x, y.y];
          }
          return [0, 0];
        }
        /* override */
        onPropertyChange(W, y, t) {
          if (super.onPropertyChange(W, y, t), (W === "d" || W === "normalize") && this.updateContours(), this[p] && (W === "fillColor" || W === "fillRule")) {
            const {
              fillColor: e,
              fillRule: Z
            } = this.attributes;
            Object(X.setFillColor)(this[p], {
              color: e,
              rule: Z
            });
          }
          if (this[p] && (W === "strokeColor" || W === "lineWidth" || W === "lineCap" || W === "lineJoin" || W === "lineDash" || W === "lineDashOffset" || W === "roundSegments")) {
            const {
              strokeColor: e,
              lineWidth: Z
            } = this.attributes;
            if (e && Z > 0) {
              const {
                lineCap: a,
                lineJoin: x,
                lineDash: K,
                lineDashOffset: C,
                miterLimit: T,
                roundSegments: I
              } = this.attributes;
              Object(X.setStrokeColor)(this[p], {
                color: e,
                lineCap: a,
                lineJoin: x,
                lineWidth: Z,
                lineDash: K,
                lineDashOffset: C,
                miterLimit: T,
                roundSegments: I
              });
            }
          }
          this[p] && W === "clipPath" && this[p].setClipPath(y), W === "texture" && Object(G.applyTexture)(this, y);
        }
        /* override */
        updateContours() {
          this.path = new i.Figure2D(), this.path.addPath(this.attributes.d), this.attributes.normalize && this.path.normalize(...this.path.boundingCenter);
        }
      }
      h(r, "Attr", n.default), L.default.registerNode(r, "path");
    },
    /* 227 */
    /***/
    function(b, d, l) {
      (function(i, s) {
        b.exports = s();
      })(this, function() {
        var i = /* @__PURE__ */ function() {
          function J(F, R) {
            var S = [], N = !0, Q = !1, P = void 0;
            try {
              for (var j = F[Symbol.iterator](), D; !(N = (D = j.next()).done) && (S.push(D.value), !(R && S.length === R)); N = !0)
                ;
            } catch (z) {
              Q = !0, P = z;
            } finally {
              try {
                !N && j.return && j.return();
              } finally {
                if (Q)
                  throw P;
              }
            }
            return S;
          }
          return function(F, R) {
            if (Array.isArray(F))
              return F;
            if (Symbol.iterator in Object(F))
              return J(F, R);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), s = Math.PI * 2, c = function(F, R, S, N, Q, P, j) {
          var D = F.x, z = F.y;
          D *= R, z *= S;
          var w = N * D - Q * z, A = Q * D + N * z;
          return {
            x: w + P,
            y: A + j
          };
        }, m = function(F, R) {
          var S = 1.3333333333333333 * Math.tan(R / 4), N = Math.cos(F), Q = Math.sin(F), P = Math.cos(F + R), j = Math.sin(F + R);
          return [{
            x: N - Q * S,
            y: Q + N * S
          }, {
            x: P + j * S,
            y: j - P * S
          }, {
            x: P,
            y: j
          }];
        }, n = function(F, R, S, N) {
          var Q = F * N - R * S < 0 ? -1 : 1, P = Math.sqrt(F * F + R * R), j = Math.sqrt(F * F + R * R), D = F * S + R * N, z = D / (P * j);
          return z > 1 && (z = 1), z < -1 && (z = -1), Q * Math.acos(z);
        }, X = function(F, R, S, N, Q, P, j, D, z, w, A, ll) {
          var _ = Math.pow(Q, 2), cl = Math.pow(P, 2), $ = Math.pow(A, 2), al = Math.pow(ll, 2), Xl = _ * cl - _ * al - cl * $;
          Xl < 0 && (Xl = 0), Xl /= _ * al + cl * $, Xl = Math.sqrt(Xl) * (j === D ? -1 : 1);
          var M = Xl * Q / P * ll, k = Xl * -P / Q * A, E = w * M - z * k + (F + S) / 2, O = z * M + w * k + (R + N) / 2, g = (A - M) / Q, U = (ll - k) / P, u = (-A - M) / Q, Y = (-ll - k) / P, H = n(1, 0, g, U), v = n(g, U, u, Y);
          return D === 0 && v > 0 && (v -= s), D === 1 && v < 0 && (v += s), [E, O, H, v];
        }, G = function(F) {
          var R = F.px, S = F.py, N = F.cx, Q = F.cy, P = F.rx, j = F.ry, D = F.xAxisRotation, z = D === void 0 ? 0 : D, w = F.largeArcFlag, A = w === void 0 ? 0 : w, ll = F.sweepFlag, _ = ll === void 0 ? 0 : ll, cl = [];
          if (P === 0 || j === 0)
            return [];
          var $ = Math.sin(z * s / 360), al = Math.cos(z * s / 360), Xl = al * (R - N) / 2 + $ * (S - Q) / 2, M = -$ * (R - N) / 2 + al * (S - Q) / 2;
          if (Xl === 0 && M === 0)
            return [];
          P = Math.abs(P), j = Math.abs(j);
          var k = Math.pow(Xl, 2) / Math.pow(P, 2) + Math.pow(M, 2) / Math.pow(j, 2);
          k > 1 && (P *= Math.sqrt(k), j *= Math.sqrt(k));
          var E = X(R, S, N, Q, P, j, A, _, $, al, Xl, M), O = i(E, 4), g = O[0], U = O[1], u = O[2], Y = O[3], H = Math.max(Math.ceil(Math.abs(Y) / (s / 4)), 1);
          Y /= H;
          for (var v = 0; v < H; v++)
            cl.push(m(u, Y)), u += Y;
          return cl.map(function(f) {
            var B = c(f[0], P, j, al, $, g, U), q = B.x, dl = B.y, il = c(f[1], P, j, al, $, g, U), bl = il.x, ml = il.y, tl = c(f[2], P, j, al, $, g, U), sl = tl.x, Zl = tl.y;
            return { x1: q, y1: dl, x2: bl, y2: ml, x: sl, y: Zl };
          });
        }, L = {
          a: 7,
          c: 6,
          h: 1,
          l: 2,
          m: 2,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          z: 0
          /**
           * segment pattern
           * @type {RegExp}
           */
        }, o = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function h(J) {
          var F = [];
          return J.replace(o, function(R, S, N) {
            var Q = S.toLowerCase();
            for (N = r(N), Q == "m" && N.length > 2 && (F.push([S].concat(N.splice(0, 2))), Q = "l", S = S == "m" ? "l" : "L"); ; ) {
              if (N.length == L[Q])
                return N.unshift(S), F.push(N);
              if (N.length < L[Q])
                throw new Error("malformed path data");
              F.push([S].concat(N.splice(0, L[Q])));
            }
          }), F;
        }
        var p = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function r(J) {
          var F = J.match(p);
          return F ? F.map(Number) : [];
        }
        function V(J) {
          var F = J[0][0], R = J[0][1], S = F, N = R;
          return J.forEach(function(Q) {
            var P = Q[0], j = Q[2], D = Q[4], z = Q[6], w = Q[1], A = Q[3], ll = Q[5], _ = Q[7];
            F = Math.min(F, P, j, D, z), R = Math.min(R, w, A, ll, _), S = Math.max(S, P, j, D, z), N = Math.max(N, w, A, ll, _);
          }), [F, R, S, N];
        }
        function W(J, F) {
          return Math.sqrt(Math.pow(J[0] - F[0], 2) + Math.pow(J[1] - F[1], 2)) + Math.sqrt(Math.pow(J[2] - F[2], 2) + Math.pow(J[3] - F[3], 2));
        }
        function y(J, F) {
          var R = J[0], S = J[2], N = J[4], Q = J[6], P = J[1], j = J[3], D = J[5], z = J[7], w = F[0], A = F[2], ll = F[4], _ = F[6], cl = F[1], $ = F[3], al = F[5], Xl = F[7];
          return Math.sqrt(Math.pow(w - R, 2) + Math.pow(cl - P, 2)) + Math.sqrt(Math.pow(A - S, 2) + Math.pow($ - j, 2)) + Math.sqrt(Math.pow(ll - N, 2) + Math.pow(al - D, 2)) + Math.sqrt(Math.pow(_ - Q, 2) + Math.pow(Xl - z, 2));
        }
        function t(J, F) {
          var R = Z(J.length), S = [];
          R.forEach(function(Q) {
            var P = 0, j = 0;
            Q.forEach(function(D) {
              P += y(J[D], F[j++]);
            }), S.push({ index: Q, distance: P });
          }), S.sort(function(Q, P) {
            return Q.distance - P.distance;
          });
          var N = [];
          return S[0].index.forEach(function(Q) {
            N.push(J[Q]);
          }), N;
        }
        function e(J, F) {
          var R = a(J.length), S = [];
          R.forEach(function(Q) {
            var P = 0;
            Q.forEach(function(j) {
              P += W(V(J[j]), V(F[j]));
            }), S.push({ index: Q, distance: P });
          }), S.sort(function(Q, P) {
            return Q.distance - P.distance;
          });
          var N = [];
          return S[0].index.forEach(function(Q) {
            N.push(J[Q]);
          }), N;
        }
        function Z(J) {
          for (var F = [], R = 0; R < J; R++) {
            for (var S = [], N = 0; N < J; N++) {
              var Q = N + R;
              Q > J - 1 && (Q -= J), S[Q] = N;
            }
            F.push(S);
          }
          return F;
        }
        function a(J) {
          for (var F = [], R = 0; R < J; R++)
            F.push(R);
          return x(F);
        }
        function x(J) {
          var F = [], R = [];
          function S(N) {
            var Q, P;
            for (Q = 0; Q < N.length; Q++)
              P = N.splice(Q, 1)[0], R.push(P), N.length == 0 && F.push(R.slice()), S(N), N.splice(Q, 0, P), R.pop();
            return F;
          }
          return S(J);
        }
        var K = {};
        K.parser = h, K.lerpCurve = function(J, F, R) {
          return K.lerpPoints(J[0], J[1], F[0], F[1], R).concat(K.lerpPoints(J[2], J[3], F[2], F[3], R)).concat(K.lerpPoints(J[4], J[5], F[4], F[5], R)).concat(K.lerpPoints(J[6], J[7], F[6], F[7], R));
        }, K.lerpPoints = function(J, F, R, S, N) {
          return [J + (R - J) * N, F + (S - F) * N];
        }, K.q2b = function(J, F, R, S, N, Q) {
          return [J, F, (J + 2 * R) / 3, (F + 2 * S) / 3, (N + 2 * R) / 3, (Q + 2 * S) / 3, N, Q];
        }, K.path2shapes = function(J) {
          for (var F = K.parser(J), R = 0, S = 0, N = 0, Q = F.length, P = [], j = null, D = void 0, z = void 0, w = void 0, A = void 0, ll = void 0, _ = void 0, cl = void 0; N < Q; N++) {
            var $ = F[N], al = $[0], Xl = F[N - 1];
            switch (al) {
              case "m":
                ll = P.length, P[ll] = [], j = P[ll], R = R + $[1], S = S + $[2];
                break;
              case "M":
                ll = P.length, P[ll] = [], j = P[ll], R = $[1], S = $[2];
                break;
              case "l":
                j.push([R, S, R, S, R, S, R + $[1], S + $[2]]), R += $[1], S += $[2];
                break;
              case "L":
                j.push([R, S, $[1], $[2], $[1], $[2], $[1], $[2]]), R = $[1], S = $[2];
                break;
              case "h":
                j.push([R, S, R, S, R, S, R + $[1], S]), R += $[1];
                break;
              case "H":
                j.push([R, S, $[1], S, $[1], S, $[1], S]), R = $[1];
                break;
              case "v":
                j.push([R, S, R, S, R, S, R, S + $[1]]), S += $[1];
                break;
              case "V":
                j.push([R, S, R, $[1], R, $[1], R, $[1]]), S = $[1];
                break;
              case "C":
                j.push([R, S, $[1], $[2], $[3], $[4], $[5], $[6]]), R = $[5], S = $[6];
                break;
              case "S":
                Xl[0] === "C" || Xl[0] === "c" ? j.push([R, S, R + Xl[5] - Xl[3], S + Xl[6] - Xl[4], $[1], $[2], $[3], $[4]]) : (Xl[0] === "S" || Xl[0] === "s") && j.push([R, S, R + Xl[3] - Xl[1], S + Xl[4] - Xl[2], $[1], $[2], $[3], $[4]]), R = $[3], S = $[4];
                break;
              case "c":
                j.push([R, S, R + $[1], S + $[2], R + $[3], S + $[4], R + $[5], S + $[6]]), R = R + $[5], S = S + $[6];
                break;
              case "s":
                Xl[0] === "C" || Xl[0] === "c" ? j.push([R, S, R + Xl[5] - Xl[3], S + Xl[6] - Xl[4], R + $[1], S + $[2], R + $[3], S + $[4]]) : (Xl[0] === "S" || Xl[0] === "s") && j.push([R, S, R + Xl[3] - Xl[1], S + Xl[4] - Xl[2], R + $[1], S + $[2], R + $[3], S + $[4]]), R = R + $[3], S = S + $[4];
                break;
              case "a":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: R,
                  py: S,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: R + $[6],
                  cy: S + $[7]
                }), cl = _[_.length - 1], _.forEach(function(M, k) {
                  k === 0 ? j.push([R, S, M.x1, M.y1, M.x2, M.y2, M.x, M.y]) : j.push([_[k - 1].x, _[k - 1].y, M.x1, M.y1, M.x2, M.y2, M.x, M.y]);
                }), R = cl.x, S = cl.y;
                break;
              case "A":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: R,
                  py: S,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: $[6],
                  cy: $[7]
                }), cl = _[_.length - 1], _.forEach(function(M, k) {
                  k === 0 ? j.push([R, S, M.x1, M.y1, M.x2, M.y2, M.x, M.y]) : j.push([_[k - 1].x, _[k - 1].y, M.x1, M.y1, M.x2, M.y2, M.x, M.y]);
                }), R = cl.x, S = cl.y;
                break;
              case "Q":
                j.push(K.q2b(R, S, $[1], $[2], $[3], $[4])), R = $[3], S = $[4];
                break;
              case "q":
                j.push(K.q2b(R, S, R + $[1], S + $[2], $[3] + R, $[4] + S)), R += $[3], S += $[4];
                break;
              case "T":
                Xl[0] === "Q" || Xl[0] === "q" ? (w = R + Xl[3] - Xl[1], A = S + Xl[4] - Xl[2], j.push(K.q2b(R, S, w, A, $[1], $[2]))) : (Xl[0] === "T" || Xl[0] === "t") && (j.push(K.q2b(R, S, R + R - w, S + S - A, $[1], $[2])), w = R + R - w, A = S + S - A), R = $[1], S = $[2];
                break;
              case "t":
                Xl[0] === "Q" || Xl[0] === "q" ? (w = R + Xl[3] - Xl[1], A = S + Xl[4] - Xl[2], j.push(K.q2b(R, S, w, A, R + $[1], S + $[2]))) : (Xl[0] === "T" || Xl[0] === "t") && (j.push(K.q2b(R, S, R + R - w, S + S - A, R + $[1], S + $[2])), w = R + R - w, A = S + S - A), R += $[1], S += $[2];
                break;
              case "Z":
                D = j[0][0], z = j[0][1], j.push([R, S, D, z, D, z, D, z]);
                break;
              case "z":
                D = j[0][0], z = j[0][1], j.push([R, S, D, z, D, z, D, z]);
                break;
            }
          }
          return P;
        }, K._upCurves = function(J, F) {
          for (var R = 0, S = 0, N = J.length; R < F; R++)
            J.push(J[S].slice(0)), S++, S > N - 1 && (S -= N);
        };
        function C(J, F, R, S, N, Q, P, j, D) {
          return {
            left: T(J, F, R, S, N, Q, P, j, D),
            right: T(P, j, N, Q, R, S, J, F, 1 - D, !0)
          };
        }
        function T(J, F, R, S, N, Q, P, j, D, z) {
          var w = (R - J) * D + J, A = (S - F) * D + F, ll = (N - R) * D + R, _ = (Q - S) * D + S, cl = (P - N) * D + N, $ = (j - Q) * D + Q, al = (ll - w) * D + w, Xl = (_ - A) * D + A, M = (cl - ll) * D + ll, k = ($ - _) * D + _, E = (M - al) * D + al, O = (k - Xl) * D + Xl;
          return z ? [E, O, al, Xl, w, A, J, F] : [J, F, w, A, al, Xl, E, O];
        }
        K._splitCurves = function(J, F) {
          for (var R = 0, S = 0; R < F; R++) {
            var N = J[S], Q = C(N[0], N[1], N[2], N[3], N[4], N[5], N[6], N[7], 0.5);
            J.splice(S, 1), J.splice(S, 0, Q.left, Q.right), S += 2, S >= J.length - 1 && (S = 0);
          }
        };
        function I(J, F) {
          for (var R = function(Q) {
            var P = J[J.length - 1], j = [];
            P.forEach(function(D) {
              j.push(D.slice(0));
            }), J.push(j);
          }, S = 0; S < F; S++)
            R();
        }
        return K.lerp = function(J, F, R) {
          return K._lerp(K.path2shapes(J), K.path2shapes(F), R);
        }, K.MIM_CURVES_COUNT = 100, K._preprocessing = function(J, F) {
          var R = J.length, S = F.length, N = JSON.parse(JSON.stringify(J)), Q = JSON.parse(JSON.stringify(F));
          return R > S ? I(Q, R - S) : R < S && I(N, S - R), N = e(N, Q), N.forEach(function(P, j) {
            var D = P.length, z = Q[j].length;
            D > z ? D < K.MIM_CURVES_COUNT ? (K._splitCurves(P, K.MIM_CURVES_COUNT - D), K._splitCurves(Q[j], K.MIM_CURVES_COUNT - z)) : K._splitCurves(Q[j], D - z) : D < z && (z < K.MIM_CURVES_COUNT ? (K._splitCurves(P, K.MIM_CURVES_COUNT - D), K._splitCurves(Q[j], K.MIM_CURVES_COUNT - z)) : K._splitCurves(P, z - D));
          }), N.forEach(function(P, j) {
            N[j] = t(P, Q[j]);
          }), [N, Q];
        }, K._lerp = function(J, F, R) {
          var S = [];
          return J.forEach(function(N, Q) {
            var P = [];
            N.forEach(function(j, D) {
              P.push(K.lerpCurve(j, F[Q][D], R));
            }), S.push(P);
          }), S;
        }, K.animate = function(J) {
          var F = K.path2shapes(J.from), R = K.path2shapes(J.to), S = K._preprocessing(F, R), N = /* @__PURE__ */ new Date(), Q = J.end || function() {
          }, P = J.progress || function() {
          }, j = J.begin || function() {
          }, D = J.easing || function(_) {
            return _;
          }, z = null, w = null, A = J.time;
          j(F);
          var ll = function _() {
            var cl = /* @__PURE__ */ new Date() - N;
            if (cl >= A) {
              w = R, P(w, 1), Q(w), cancelAnimationFrame(z);
              return;
            }
            var $ = D(cl / A);
            w = K._lerp(S[0], S[1], $), P(w, $), z = requestAnimationFrame(_);
          };
          ll();
        }, K;
      });
    },
    /* 228 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(71), s = l(221), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), X = Symbol.for("spritejs_getAttribute");
      class G extends i.default {
        constructor(o) {
          super(o), this[m]({
            d: "",
            normalize: !1,
            fillColor: void 0,
            fillRule: "nonzero",
            strokeColor: void 0,
            lineWidth: 1,
            lineJoin: "miter",
            // 'miter' or 'bevel' or 'round'
            lineCap: "butt",
            // 'butt' or 'square' or 'round'
            roundSegments: 20,
            // default roundSegment if lineJoin or lineCap is round
            lineDash: void 0,
            lineDashOffset: 0,
            miterLimit: 10,
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0,
            clipPath: void 0
          });
        }
        get d() {
          return this[X]("d");
        }
        set d(o) {
          this[n]("d", o);
        }
        get normalize() {
          return this[X]("normalize");
        }
        set normalize(o) {
          this[n]("normalize", !!o);
        }
        get fillColor() {
          return this[X]("fillColor");
        }
        set fillColor(o) {
          this[n]("fillColor", Object(s.parseColor)(o));
        }
        get fillRule() {
          return this[X]("fillRule");
        }
        set fillRule(o) {
          if (o != null && o !== "nonzero" && o !== "evenodd")
            throw new TypeError("Invalid fill rule.");
          this[n]("fillRule", o);
        }
        get strokeColor() {
          return this[X]("strokeColor");
        }
        set strokeColor(o) {
          this[n]("strokeColor", Object(s.parseColor)(o));
        }
        get lineWidth() {
          return this[X]("lineWidth");
        }
        set lineWidth(o) {
          this[n]("lineWidth", Object(c.toNumber)(o));
        }
        get lineJoin() {
          return this[X]("lineJoin");
        }
        set lineJoin(o) {
          if (o != null && o !== "miter" && o !== "bevel" && o !== "round")
            throw new TypeError("Invalid lineJoin type.");
          this[n]("lineJoin", o);
        }
        get lineCap() {
          return this[X]("lineCap");
        }
        set lineCap(o) {
          if (o != null && o !== "butt" && o !== "square" && o !== "round")
            throw new TypeError("Invalid lineCap type.");
          this[n]("lineCap", o);
        }
        get lineDash() {
          return this[X]("lineDash");
        }
        set lineDash(o) {
          o = Object(c.toArray)(o, !0), o != null && !Array.isArray(o) && (o = [o]), this[n]("lineDash", o ? o.map(c.toNumber) : null);
        }
        get lineDashOffset() {
          return this[X]("lineDashOffset");
        }
        set lineDashOffset(o) {
          this[n]("lineDashOffset", Object(c.toNumber)(o));
        }
        get miterLimit() {
          return this[X]("miterLimit");
        }
        set miterLimit(o) {
          this[n]("miterLimit", Object(c.toNumber)(o));
        }
        get roundSegments() {
          return this[X]("roundSegments");
        }
        set roundSegments(o) {
          this[n]("roundSegments", o);
        }
        get texture() {
          return this[X]("texture");
        }
        set texture(o) {
          this[n]("texture", o);
        }
        get textureRect() {
          return this[X]("textureRect");
        }
        set textureRect(o) {
          this[n]("textureRect", o);
        }
        get sourceRect() {
          return this[X]("sourceRect");
        }
        set sourceRect(o) {
          this[n]("sourceRect", o);
        }
        get textureRepeat() {
          return this[X]("textureRepeat");
        }
        set textureRepeat(o) {
          this[n]("textureRepeat", !!o);
        }
        get clipPath() {
          return this[X]("clipPath");
        }
        set clipPath(o) {
          this[n]("clipPath", o);
        }
      }
    },
    /* 229 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(226), s = l(213), c = l(230);
      l(1).glMatrix.setMatrixArrayType(Array);
      function m(X, G, L) {
        return G in X ? Object.defineProperty(X, G, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : X[G] = L, X;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            width: G,
            height: L
          } = this.attributes;
          return G > 0 && L > 0 && super.isVisible;
        }
      }
      m(n, "Attr", c.default), s.default.registerNode(n, "rect");
    },
    /* 230 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return L;
      });
      var i = l(228), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol.for("spritejs_setAttributeDefault"), m = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), X = Symbol.for("spritejs_declareAlias");
      function G(o) {
        const {
          width: h,
          height: p
        } = o;
        return `M0 0L${h} 0L${h} ${p}L0 ${p}Z`;
      }
      class L extends i.default {
        constructor(h) {
          super(h), this[c]({
            width: 0,
            height: 0
            /* size */
          }), this[X]("size");
        }
        // readonly
        get d() {
          return this[n]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get width() {
          return this[n]("width");
        }
        set width(h) {
          if (h = Object(s.toNumber)(h), this[m]("width", h)) {
            const p = G(this);
            this[m]("d", p);
          }
        }
        get height() {
          return this[n]("height");
        }
        set height(h) {
          if (h = Object(s.toNumber)(h), this[m]("height", h)) {
            const p = G(this);
            this[m]("d", p);
          }
        }
        get size() {
          return [this.width, this.height];
        }
        set size(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h, h]), this.width = h[0], this.height = h[1];
        }
      }
    },
    /* 231 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(232), s = l(213), c = l(235);
      l(1).glMatrix.setMatrixArrayType(Array);
      function m(X, G, L) {
        return G in X ? Object.defineProperty(X, G, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : X[G] = L, X;
      }
      class n extends i.default {
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      m(n, "Attr", c.default), s.default.registerNode(n, "triangle");
    },
    /* 232 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(226), s = l(213), c = l(233);
      l(1).glMatrix.setMatrixArrayType(Array);
      function m(X, G, L) {
        return G in X ? Object.defineProperty(X, G, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : X[G] = L, X;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            points: G
          } = this.attributes;
          return G.length > 0 && super.isVisible;
        }
      }
      m(n, "Attr", c.default), s.default.registerNode(n, "polyline");
    },
    /* 233 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return o;
      });
      var i = l(228), s = l(72), c = l(234);
      l(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), X = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function L(h) {
        const {
          points: p,
          smooth: r,
          smoothRange: V,
          close: W
        } = h, y = [];
        for (let e = 0; e < p.length; e += 2)
          y.push([p[e], p[e + 1]]);
        let t = "";
        return r ? t = Object(c.makeSmoothCurveLine)(y, V) : y.length && (t = `M${y.map((e) => e.join(" ")).join("L")}`), t && W && (t += "Z"), t;
      }
      class o extends i.default {
        constructor(p) {
          super(p), this[m]({
            points: [],
            smooth: !1,
            smoothRange: [0],
            closeType: "none"
            // none | normal
            /* close */
          }), this[G]("close");
        }
        // readonly
        get d() {
          return this[X]("d");
        }
        set d(p) {
        }
        // eslint-disable-line no-empty-function
        get close() {
          return this.closeType !== "none";
        }
        set close(p) {
          p = p ? "normal" : "none", this.closeType = p;
        }
        get closeType() {
          return this[X]("closeType");
        }
        set closeType(p) {
          if (p != null && p !== "none" && p !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[n]("closeType", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get smooth() {
          return this[X]("smooth");
        }
        set smooth(p) {
          if (this[n]("smooth", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get smoothRange() {
          return this[X]("smoothRange");
        }
        set smoothRange(p) {
          if (p && !Array.isArray(p) && (p = [p]), this[n]("smoothRange", p) && this.smooth) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get points() {
          return this[X]("points");
        }
        set points(p) {
          if (p = Object(s.toArray)(p), Array.isArray(p) && (p = p.reduce((r, V) => Array.isArray(V) ? [...r, ...V.map((W) => Object(s.toNumber)(W))] : [...r, Object(s.toNumber)(V)], [])), this[n]("points", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
      }
    },
    /* 234 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "makeSmoothCurveLine", function() {
        return i;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(s, c = [0]) {
        function m(G, L = 0.168, o = 0.168) {
          let h, p, r, V;
          if ((s[G].x === s[G + 1].x || s[G].y === s[G + 1].y) && (L = 0, o = 0), G < 1 ? (h = s[0].x + (s[1].x - s[0].x) * L, p = s[0].y + (s[1].y - s[0].y) * L) : (h = s[G].x + (s[G + 1].x - s[G - 1].x) * L, p = s[G].y + (s[G + 1].y - s[G - 1].y) * L), G > s.length - 3) {
            const W = s.length - 1;
            r = s[W].x - (s[W].x - s[W - 1].x) * o, V = s[W].y - (s[W].y - s[W - 1].y) * o;
          } else
            r = s[G + 1].x - (s[G + 2].x - s[G].x) * o, V = s[G + 1].y - (s[G + 2].y - s[G].y) * o;
          return [{
            x: h,
            y: p
          }, {
            x: r,
            y: V
          }];
        }
        s = s.map(([G, L]) => ({
          x: G,
          y: L
        }));
        let n = "", X = 0;
        return s.forEach((G, L) => {
          if (L === 0)
            n += `M${G.x} ${G.y}`;
          else {
            for (; L > c[X]; )
              X++;
            if (X % 2) {
              const [o, h] = m(L - 1);
              n += `C${[o.x, o.y, h.x, h.y, G.x, G.y].join(" ")}`;
            } else
              n += `L${G.x} ${G.y}`;
          }
        }), n;
      }
    },
    /* 235 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(233), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol.for("spritejs_setAttributeDefault"), m = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      function X(L) {
        const [o, h] = L.sides;
        let p = L.angle % 360;
        return p < 0 && (p += 360), p = Math.PI * p / 180, [0, 0, o, 0, h * Math.cos(p), h * Math.sin(p)];
      }
      class G extends i.default {
        constructor(o) {
          super(o), this[c]({
            sides: [0, 0],
            angle: 60,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(o) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[n]("sides");
        }
        set sides(o) {
          if (o = Object(s.toArray)(o, !0), o != null && !Array.isArray(o) && (o = [o, o]), this[m]("sides", o)) {
            const h = X(this);
            super.points = h;
          }
        }
        get angle() {
          return this[n]("angle");
        }
        set angle(o) {
          if (o = Object(s.toNumber)(o), this[m]("angle", o)) {
            const h = X(this);
            super.points = h;
          }
        }
      }
    },
    /* 236 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(232), s = l(213), c = l(237);
      l(1).glMatrix.setMatrixArrayType(Array);
      function m(X, G, L) {
        return G in X ? Object.defineProperty(X, G, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : X[G] = L, X;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      m(n, "Attr", c.default), s.default.registerNode(n, "parallel");
    },
    /* 237 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(233), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol.for("spritejs_setAttributeDefault"), m = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      function X(L) {
        const [o, h] = L.sides;
        let p = L.angle % 360;
        p < 0 && (p += 360), p = Math.PI * p / 180;
        const r = h * Math.cos(p), V = h * Math.sin(p);
        return [0, 0, o, 0, r + o, V, r, V];
      }
      class G extends i.default {
        constructor(o) {
          super(o), this[c]({
            sides: [0, 0],
            angle: 90,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(o) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[n]("sides");
        }
        set sides(o) {
          if (o = Object(s.toArray)(o, !0), o != null && !Array.isArray(o) && (o = [o, o]), this[m]("sides", o)) {
            const h = X(this);
            super.points = h;
          }
        }
        get angle() {
          return this[n]("angle");
        }
        set angle(o) {
          if (o = Object(s.toNumber)(o), this[m]("angle", o)) {
            const h = X(this);
            super.points = h;
          }
        }
      }
    },
    /* 238 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(232), s = l(213), c = l(239);
      l(1).glMatrix.setMatrixArrayType(Array);
      function m(X, G, L) {
        return G in X ? Object.defineProperty(X, G, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : X[G] = L, X;
      }
      class n extends i.default {
      }
      m(n, "Attr", c.default), s.default.registerNode(n, "regular");
    },
    /* 239 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(233), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol.for("spritejs_setAttributeDefault"), m = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      function X(L) {
        const {
          edges: o,
          radius: h,
          offsetAngle: p
        } = L, r = Math.PI * p / 180 - 0.5 * Math.PI;
        if (o < 3 || h <= 0)
          return [];
        const V = [];
        for (let W = 0; W < o; W++) {
          const y = W * 2 * Math.PI / o + r, t = h * Math.cos(y), e = h * Math.sin(y);
          V.push(t, e);
        }
        return V;
      }
      class G extends i.default {
        constructor(o) {
          super(o), this[c]({
            edges: 3,
            radius: 0,
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(o) {
        }
        // eslint-disable-line no-empty-function
        get edges() {
          return this[n]("edges");
        }
        set edges(o) {
          if (o = Object(s.toNumber)(o), this[m]("edges", o)) {
            const h = X(this);
            super.points = h;
          }
        }
        get radius() {
          return this[n]("radius");
        }
        set radius(o) {
          if (o = Object(s.toNumber)(o), this[m]("radius", o)) {
            const h = X(this);
            super.points = h;
          }
        }
        get offsetAngle() {
          return this[n]("offsetAngle");
        }
        set offsetAngle(o) {
          if (o = Object(s.toNumber)(o), this[m]("offsetAngle", o)) {
            const h = X(this);
            super.points = h;
          }
        }
      }
    },
    /* 240 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(232), s = l(213), c = l(241);
      l(1).glMatrix.setMatrixArrayType(Array);
      function m(X, G, L) {
        return G in X ? Object.defineProperty(X, G, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : X[G] = L, X;
      }
      class n extends i.default {
      }
      m(n, "Attr", c.default), s.default.registerNode(n, "star");
    },
    /* 241 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(233), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol.for("spritejs_setAttributeDefault"), m = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      function X(L) {
        const {
          angles: o,
          innerRadius: h,
          outerRadius: p,
          offsetAngle: r
        } = L, V = Math.PI * r / 180 - 0.5 * Math.PI;
        if (o < 3 || h <= 0 || p <= 0)
          return [];
        const W = [];
        for (let y = 0; y < o * 2; y++) {
          const t = y * Math.PI / o + V, e = y % 2 ? h : p, Z = e * Math.cos(t), a = e * Math.sin(t);
          W.push(Z, a);
        }
        return W;
      }
      class G extends i.default {
        constructor(o) {
          super(o), this[c]({
            angles: 5,
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(o) {
        }
        // eslint-disable-line no-empty-function
        get angles() {
          return this[n]("angles");
        }
        set angles(o) {
          if (o = Object(s.toNumber)(o), this[m]("angles", o)) {
            const h = X(this);
            super.points = h;
          }
        }
        get innerRadius() {
          return this[n]("innerRadius");
        }
        set innerRadius(o) {
          if (o = Object(s.toNumber)(o), this[m]("innerRadius", o)) {
            const h = X(this);
            super.points = h;
          }
        }
        get outerRadius() {
          return this[n]("outerRadius");
        }
        set outerRadius(o) {
          if (o = Object(s.toNumber)(o), this[m]("outerRadius", o)) {
            const h = X(this);
            super.points = h;
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(o) {
          o = Object(s.toArray)(o, !0), Array.isArray(o) || (o = [o, o]), this.innerRadius = o[0], this.outerRadius = o[1];
        }
        get offsetAngle() {
          return this[n]("offsetAngle");
        }
        set offsetAngle(o) {
          if (o = Object(s.toNumber)(o), this[m]("offsetAngle", o)) {
            const h = X(this);
            super.points = h;
          }
        }
      }
    },
    /* 242 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(226), s = l(213), c = l(243);
      l(1).glMatrix.setMatrixArrayType(Array);
      function m(X, G, L) {
        return G in X ? Object.defineProperty(X, G, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : X[G] = L, X;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            radiusX: G,
            radiusY: L,
            startAngle: o,
            endAngle: h
          } = this.attributes;
          return G > 0 && L > 0 && o !== h && super.isVisible;
        }
      }
      m(n, "Attr", c.default), s.default.registerNode(n, "ellipse");
    },
    /* 243 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return o;
      });
      var i = l(12), s = l(228), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), X = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function L(h) {
        const {
          radiusX: p,
          radiusY: r,
          startAngle: V,
          endAngle: W,
          direction: y,
          closeType: t
        } = h, e = y === "anitclockwise", Z = new i.Figure2D();
        return t === "sector" && Z.moveTo(0, 0), Z.ellipse(0, 0, p, r, 0, Math.PI * V / 180, Math.PI * W / 180, e), t !== "none" && Z.closePath(), Z.path.reduce((K, C) => K + C.join(" "), "");
      }
      class o extends s.default {
        constructor(p) {
          super(p), this[m]({
            radiusX: 0,
            radiusY: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360,
            /* angle */
            direction: "clockwise",
            // clockwise | anticlockwise
            closeType: "none"
            // none | sector | normal
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[X]("d");
        }
        set d(p) {
        }
        // eslint-disable-line no-empty-function
        get radiusX() {
          return this[X]("radiusX");
        }
        set radiusX(p) {
          if (p = Object(c.toNumber)(p), this[n]("radiusX", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get radiusY() {
          return this[X]("radiusY");
        }
        set radiusY(p) {
          if (p = Object(c.toNumber)(p), this[n]("radiusY", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get radius() {
          return [this.radiusX, this.radiusY];
        }
        set radius(p) {
          p = Object(c.toArray)(p, !0), Array.isArray(p) || (p = [p, p]), this.radiusX = p[0], this.radiusY = p[1];
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(p) {
          p = Object(c.toArray)(p), Array.isArray(p) || (p = [p, p]), this.startAngle = p[0], this.endAngle = p[1];
        }
        get direction() {
          return this[X]("direction");
        }
        set direction(p) {
          if (p != null && p !== "clockwise" && p !== "anticlockwise")
            throw new TypeError("Invalid direction type.");
          this[n]("direction", p);
        }
        get startAngle() {
          return this[X]("startAngle");
        }
        set startAngle(p) {
          if (p = Object(c.toNumber)(p), this[n]("startAngle", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get endAngle() {
          return this[X]("endAngle");
        }
        set endAngle(p) {
          if (p = Object(c.toNumber)(p), this[n]("endAngle", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get closeType() {
          return this[X]("closeType");
        }
        set closeType(p) {
          if (p != null && p !== "none" && p !== "sector" && p !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[n]("closeType", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
      }
    },
    /* 244 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(242), s = l(213), c = l(245);
      l(1).glMatrix.setMatrixArrayType(Array);
      function m(X, G, L) {
        return G in X ? Object.defineProperty(X, G, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : X[G] = L, X;
      }
      class n extends i.default {
      }
      m(n, "Attr", c.default), s.default.registerNode(n, "arc");
    },
    /* 245 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return c;
      });
      var i = l(243), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      class c extends i.default {
        get radius() {
          return super.radiusX;
        }
        set radius(n) {
          n = Object(s.toNumber)(n), super.radiusX = n, super.radiusY = n;
        }
      }
    },
    /* 246 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(226), s = l(213), c = l(247);
      l(1).glMatrix.setMatrixArrayType(Array);
      function m(X, G, L) {
        return G in X ? Object.defineProperty(X, G, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : X[G] = L, X;
      }
      class n extends i.default {
        /* override */
        get isVisible() {
          const {
            innerRadius: G,
            outerRadius: L,
            startAngle: o,
            endAngle: h
          } = this.attributes;
          return (G > 0 || L > 0) && o !== h && super.isVisible;
        }
      }
      m(n, "Attr", c.default), s.default.registerNode(n, "ring");
    },
    /* 247 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return o;
      });
      var i = l(12), s = l(228), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const m = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), X = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function L(h) {
        let {
          innerRadius: p,
          outerRadius: r,
          startAngle: V,
          endAngle: W
        } = h;
        const y = new i.Figure2D();
        if (V = Math.PI * V / 180, W = Math.PI * W / 180, p > r && ([p, r] = [r, p]), p <= 0 && y.moveTo(0, 0), y.arc(0, 0, r, V, W, !1), p > 0) {
          const Z = Math.PI * 2;
          W < V && (W = V + Z + (W - V) % Z), W - V >= Z && (W = V + Z - 1e-6), y.arc(0, 0, p, W, V, !0);
        }
        return y.closePath(), y.path.reduce((Z, a) => Z + a.join(" "), "");
      }
      class o extends s.default {
        constructor(p) {
          super(p), this[m]({
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360
            /* angle */
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[X]("d");
        }
        set d(p) {
        }
        // eslint-disable-line no-empty-function
        get innerRadius() {
          return this[X]("innerRadius");
        }
        set innerRadius(p) {
          if (p = Object(c.toNumber)(p), this[n]("innerRadius", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get outerRadius() {
          return this[X]("outerRadius");
        }
        set outerRadius(p) {
          if (p = Object(c.toNumber)(p), this[n]("outerRadius", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(p) {
          p = Object(c.toArray)(p, !0), Array.isArray(p) || (p = [p, p]), this.innerRadius = p[0], this.outerRadius = p[1];
        }
        get startAngle() {
          return this[X]("startAngle");
        }
        set startAngle(p) {
          if (p = Object(c.toNumber)(p), this[n]("startAngle", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get endAngle() {
          return this[X]("endAngle");
        }
        set endAngle(p) {
          if (p = Object(c.toNumber)(p), this[n]("endAngle", p)) {
            const r = L(this);
            this[n]("d", r);
          }
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(p) {
          p = Object(c.toArray)(p), Array.isArray(p) || (p = [p, p]), this.startAngle = p[0], this.endAngle = p[1];
        }
      }
    },
    /* 248 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return r;
      });
      var i = l(12), s = l(218), c = l(219), m = l(249), n = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      function X(V, W, y) {
        return W in V ? Object.defineProperty(V, W, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : V[W] = y, V;
      }
      const G = Symbol("textImage"), L = Symbol("textImageTask"), o = Symbol("textureContext"), h = Symbol("updateTextureRect"), p = Symbol("textCanvas");
      class r extends c.default {
        constructor(W = {}) {
          typeof W == "string" && (W = {
            text: W
          }), super(W);
        }
        /* override */
        get contentSize() {
          let [W, y] = super.contentSize;
          const {
            width: t,
            height: e
          } = this.attributes;
          if (t == null || e == null) {
            const Z = this[G];
            Z && (t == null && (W = Z.rect[2]), e == null && (y = Z.rect[3]));
          }
          return [W, y];
        }
        get text() {
          return this.attributes.text;
        }
        set text(W) {
          this.attributes.text = W;
        }
        get textContent() {
          return this.attributes.text;
        }
        set textContent(W) {
          this.attributes.text = W;
        }
        get textImage() {
          return this[G] || {};
        }
        get textImageReady() {
          return this[L] || Promise.resolve();
        }
        /* override */
        draw(W) {
          super.draw(W);
          const y = this.mesh;
          if (y) {
            const t = this[G];
            if (t) {
              let e = y.texture;
              if (!e || this[o] && this[o] !== this.renderer || t.needsUpdate ? (t.needsUpdate = !1, Object(s.deleteTexture)(t.image, this.renderer), e = Object(s.createTexture)(t.image, this.renderer), this[h] = !0) : e = y.uniforms.u_texSampler, this[h]) {
                const [Z, a] = t.rect.slice(2), [x, K] = this.contentSize, C = this.attributes.textAlign, T = this.attributes.verticalAlign;
                let I = 0;
                C === "center" ? I = (x - Z) / 2 : (C === "right" || C === "end") && (I = x - Z);
                const J = this.attributes.fontSize, F = this.attributes.lineHeight;
                let R = 0;
                T === "top" ? R = (J - F) / 2 : T === "bottom" && (R = (F - J) / 2);
                const {
                  paddingLeft: S,
                  paddingTop: N
                } = this.attributes, {
                  borderWidth: Q
                } = this.attributes;
                I += S + Q, R += N + Q;
                const {
                  anchorX: P,
                  anchorY: j
                } = this.attributes;
                I -= this.offsetSize[0] * P, R -= this.offsetSize[1] * j, y.setTexture(e, {
                  rect: [I, R, Z, a]
                }), this[h] = !1, this[o] = this.renderer;
              }
            }
          }
          return W;
        }
        /* override */
        onPropertyChange(W, y, t) {
          W === "text" || W === "fontSize" || W === "fontFamily" || W === "fontStyle" || W === "fontVariant" || W === "fontWeight" || W === "fontStretch" || W === "lineHeight" || W === "strokeColor" || W === "fillColor" || W === "strokeWidth" ? this.updateText() : ((W === "textAlign" || W === "verticalAlign") && (this[h] = !0), super.onPropertyChange(W, y, t));
        }
        /* override */
        updateContours() {
          super.updateContours(), this[h] = !0;
        }
        updateText() {
          this[L] || (this[L] = Promise.resolve().then(() => {
            this[L] = null;
            const {
              text: W,
              font: y,
              fillColor: t,
              strokeColor: e,
              strokeWidth: Z
            } = this.attributes, a = this.layer ? this.layer.displayRatio : 1;
            return this[p] = this[p] || i.ENV.createCanvas(1, 1), this[G] = i.ENV.createText(W, {
              font: y,
              fillColor: t,
              strokeColor: e,
              strokeWidth: Z,
              parseFont: i.parseFont,
              ratio: a,
              textCanvas: this[p]
            }), this[G].needsUpdate = !0, this.updateContours(), this.forceUpdate(), this[G];
          }));
        }
      }
      X(r, "Attr", m.default), n.default.registerNode(r, "label");
    },
    /* 249 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return o;
      });
      var i = l(12), s = l(72), c = l(221), m = l(220);
      l(1).glMatrix.setMatrixArrayType(Array);
      const n = Symbol.for("spritejs_setAttributeDefault"), X = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), L = Symbol.for("spritejs_declareAlias");
      class o extends m.default {
        constructor(p) {
          super(p), this[n]({
            text: "",
            fontSize: 16,
            fontFamily: "Helvetica,Arial,sans-serif",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            fontStretch: "normal",
            lineHeight: "",
            /* font */
            textAlign: "left",
            strokeColor: void 0,
            strokeWidth: 1,
            fillColor: void 0,
            verticalAlign: "middle"
          }), this[L]("font");
        }
        get text() {
          return this[G]("text") || " ";
        }
        set text(p) {
          this[X]("text", p);
        }
        get fontSize() {
          return this[G]("fontSize");
        }
        set fontSize(p) {
          this[X]("fontSize", Object(s.toNumber)(p));
        }
        get fontFamily() {
          return this[G]("fontFamily");
        }
        set fontFamily(p) {
          this[X]("fontFamily", p);
        }
        get fontStyle() {
          return this[G]("fontStyle");
        }
        set fontStyle(p) {
          this[X]("fontStyle", p);
        }
        get fontVariant() {
          return this[G]("fontVariant");
        }
        set fontVariant(p) {
          this[X]("fontVariant", p);
        }
        get fontWeight() {
          return this[G]("fontWeight");
        }
        set fontWeight(p) {
          this[X]("fontWeight", p);
        }
        get fontStretch() {
          return this[G]("fontStretch");
        }
        set fontStretch(p) {
          this[X]("fontStretch", p);
        }
        get lineHeight() {
          return this[G]("lineHeight") || this.fontSize;
        }
        set lineHeight(p) {
          this[X]("lineHeight", Object(s.toNumber)(p));
        }
        get textAlign() {
          return this[G]("textAlign");
        }
        set textAlign(p) {
          this[X]("textAlign", p);
        }
        get strokeColor() {
          return this[G]("strokeColor");
        }
        set strokeColor(p) {
          this[X]("strokeColor", Object(c.parseColor)(p));
        }
        get strokeWidth() {
          return this[G]("strokeWidth");
        }
        set strokeWidth(p) {
          this[X]("strokeWidth", Object(s.toNumber)(p));
        }
        get verticalAlign() {
          return this[G]("verticalAlign");
        }
        set verticalAlign(p) {
          this[X]("verticalAlign", p);
        }
        get fillColor() {
          return this[G]("fillColor");
        }
        set fillColor(p) {
          this[X]("fillColor", Object(c.parseColor)(p));
        }
        get font() {
          const {
            fontStyle: p,
            fontVariant: r,
            fontWeight: V,
            fontStretch: W,
            fontSize: y,
            lineHeight: t,
            fontFamily: e
          } = this;
          return `${p} ${r} ${V} ${W} ${y}px/${t}px ${e}`;
        }
        set font(p) {
          if (p == null)
            this.fontStyle = null, this.fontVariant = null, this.fontWeight = null, this.fontStretch = null, this.fontSize = null, this.lineHeight = null, this.fontFamily = null;
          else {
            const r = Object(i.parseFont)(p);
            this.fontStyle = r.style, this.fontVariant = r.variant, this.fontWeight = r.weight, this.fontStretch = r.stretch, this.fontSize = Object(s.toNumber)(`${r.size}${r.unit}`), r.lineHeight && (this.lineHeight = r.pxLineHeight), this.fontFamily = r.family;
          }
        }
      }
    },
    /* 250 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return p;
      });
      var i = l(12), s = l(219), c = l(251), m = l(213), n = l(252);
      l(1).glMatrix.setMatrixArrayType(Array);
      function X(r, V, W) {
        return V in r ? Object.defineProperty(r, V, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : r[V] = W, r;
      }
      const G = Symbol("zOrder"), L = Symbol("ordered"), o = Symbol("children"), h = Symbol("sealed");
      class p extends s.default {
        constructor(V = {}) {
          super(V), this[o] = [], this[L] = null, this[G] = 0;
        }
        get childNodes() {
          return this[o];
        }
        get children() {
          return this[o];
        }
        get orderedChildren() {
          return this[L] || (this[L] = [...this[o]], this[L].sort((V, W) => V.zIndex - W.zIndex || V.zOrder - W.zOrder)), this[L];
        }
        append(...V) {
          return V.map((W) => this.appendChild(W));
        }
        appendChild(V) {
          return V.remove(), this[o].push(V), V.connect(this, this[G]++), this[L] && (this[L].length && V.zIndex < this[L][this[L].length - 1].zIndex ? this.reorder() : this[L].push(V)), V;
        }
        /* override */
        // get isVisible() {
        //   return this.attributes.opacity > 0 && this[_children].length > 0;
        // }
        /* override */
        cloneNode(V = !1) {
          const W = super.cloneNode();
          return V && this[o].forEach((y) => {
            const t = y.cloneNode(V);
            W.appendChild(t);
          }), W;
        }
        /* override */
        dispatchPointerEvent(V) {
          const W = this.orderedChildren;
          for (let y = W.length - 1; y >= 0; y--)
            if (W[y].dispatchPointerEvent(V))
              return !0;
          return super.dispatchPointerEvent(V);
        }
        /* override */
        draw(V = []) {
          if (this.__cacheRenderMatrix = this.renderMatrix, super.draw(V), !this[h] && this.attributes.display !== "none") {
            const W = this.orderedChildren;
            for (let y = 0; y < W.length; y++)
              W[y].draw(V);
          }
          return this.__cacheRenderMatrix = null, V;
        }
        getElementById(V) {
          return Object(n.querySelector)(`#${V}`, this);
        }
        getElementsByClassName(V) {
          return Object(n.querySelectorAll)(`.${V}`, this);
        }
        getElementsByName(V) {
          return Object(n.querySelectorAll)(`[name="${V}"]`, this);
        }
        getElementsByTagName(V) {
          return Object(n.querySelectorAll)(V, this);
        }
        insertBefore(V, W) {
          if (W == null)
            return this.appendChild(V);
          V.remove();
          const y = this[o].indexOf(W);
          if (y < 0)
            throw new Error("Invalid reference node.");
          const t = W.zOrder;
          for (let e = y; e < this[o].length; e++) {
            const Z = this[o][e].zOrder, a = this[o][e];
            delete a.zOrder, Object.defineProperty(a, "zOrder", {
              value: Z + 1,
              writable: !1,
              configurable: !0
            });
          }
          if (this[o].splice(y, 0, V), V.connect(this, t), this[L])
            if (V.zIndex !== W.zIndex)
              this.reorder();
            else {
              const e = this[L].indexOf(W);
              this[L].splice(e, 0, V);
            }
          return V;
        }
        querySelector(V) {
          return Object(n.querySelector)(V, this);
        }
        querySelectorAll(V) {
          return Object(n.querySelectorAll)(V, this);
        }
        replaceChild(V, W) {
          V.remove();
          const y = this[o].indexOf(W);
          if (y < 0)
            throw new Error("Invalid reference node.");
          if (this[o][y] = V, V.connect(this, W.zOrder), this[L])
            if (V.zIndex !== W.zIndex)
              this.reorder();
            else {
              const t = this[L].indexOf(W);
              this[L][t] = V;
            }
          return W.disconnect(this), V;
        }
        removeAllChildren() {
          const V = this[o];
          for (let W = V.length - 1; W >= 0; W--)
            V[W].remove();
        }
        removeChild(V) {
          const W = this[o].indexOf(V);
          if (W >= 0) {
            if (this[o].splice(W, 1), this[L]) {
              const y = this[L].indexOf(V);
              this[L].splice(y, 1);
            }
            return V.disconnect(this), V;
          }
          return null;
        }
        reorder() {
          this[L] = null;
        }
        seal() {
          function V(e, Z) {
            const a = [];
            for (let x = 0; x < e.length; x++) {
              const K = [...e[x]];
              for (let C = 1; C < K.length; C += 2) {
                const T = K[C], I = K[C + 1];
                K[C] = T * Z[0] + I * Z[2] + Z[4], K[C + 1] = T * Z[1] + I * Z[3] + Z[5];
              }
              a.push(K);
            }
            return a;
          }
          const W = this.orderedChildren, y = new i.Figure2D(), t = this.localMatrix;
          for (let e = 0; e < W.length; e++) {
            let Z = W[e];
            if (Z instanceof p && (Z = Z.seal()), Z.clientBox) {
              let a = Z.clientBox.contours.path;
              a = V(a, Z.localMatrix), y.addPath(a);
            }
            if (Z.path) {
              let a = Z.path.contours.path;
              a = V(a, Z.localMatrix), y.addPath(a);
            }
          }
          return this[h] = !0, this.clientBox = y, {
            clientBox: y,
            localMatrix: t
          };
        }
        /* override */
        setResolution({
          width: V,
          height: W
        }) {
          super.setResolution({
            width: V,
            height: W
          }), this[o].forEach((y) => {
            y.setResolution({
              width: V,
              height: W
            });
          });
        }
        /* override */
        updateContours() {
          this[h] || super.updateContours();
        }
      }
      X(p, "Attr", c.default), m.default.registerNode(p, "group");
    },
    /* 251 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return s;
      });
      var i = l(220);
      l(1).glMatrix.setMatrixArrayType(Array);
      class s extends i.default {
        // constructor(subject) {
        //   super(subject);
        //   this[setDefault]({
        //     pointerEvents: 'all',
        //   });
        // }
      }
    },
    /* 252 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "querySelectorAll", function() {
        return h;
      }), l.d(d, "querySelector", function() {
        return p;
      }), l.d(d, "isMatched", function() {
        return r;
      }), l.d(d, "compile", function() {
        return V;
      });
      var i = l(221), s = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = l(253);
      function m(W) {
        return W.nodeType === 1 || s.default.isSpriteNode(W.nodeName);
      }
      function n(W) {
        return Array.from(W.childNodes || []);
      }
      function X(W) {
        return s.default.isSpriteNode(W.nodeName) ? W.parent || W.canvas || W.container : W.parentElement;
      }
      function G(W) {
        let y = W.length, t, e, Z;
        for (; --y > -1; ) {
          for (t = e = W[y], W[y] = null, Z = !0; e; ) {
            if (W.indexOf(e) > -1) {
              Z = !1, W.splice(y, 1);
              break;
            }
            e = X(e);
          }
          Z && (W[y] = t);
        }
        return W;
      }
      const L = {
        isTag: m,
        existsOne(W, y) {
          return y.some((t) => m(t) ? W(t) || L.existsOne(W, n(t)) : !1);
        },
        getSiblings(W) {
          const y = X(W);
          return y && n(y);
        },
        getChildren: n,
        getParent: X,
        getAttributeValue(W, y) {
          if (W.nodeType === 1 && y === "class" || y === "id")
            return W[y];
          if (this.hasAttrib(W, y)) {
            let t = W.attributes[y];
            return Array.isArray(t) && (t = `[${t.join()}]`), String(t);
          }
        },
        hasAttrib(W, y) {
          return W.attributes[y] != null;
        },
        removeSubsets: G,
        getName(W) {
          return W.tagName ? W.tagName.toLowerCase() : null;
        },
        findOne: function W(y, t) {
          let e = null;
          for (let Z = 0, a = t.length; Z < a && !e; Z++)
            if (y(t[Z]))
              e = t[Z];
            else {
              const x = n(t[Z]);
              x && x.length > 0 && (e = W(y, x));
            }
          return e;
        },
        findAll: function W(y, t) {
          let e = [];
          for (let Z = 0, a = t.length; Z < a; Z++) {
            if (!m(t[Z]))
              continue;
            y(t[Z]) && e.push(t[Z]);
            const x = n(t[Z]);
            x && (e = e.concat(W(y, x)));
          }
          return e;
        },
        getText: function W(y) {
          return Array.isArray(y) ? y.map(W).join("") : m(y) ? W(n(y)) : y.nodeType === 3 ? y.nodeValue : s.default.isSpriteNode(y.nodeName) ? y.text : "";
        }
      };
      function o(W) {
        if (typeof W != "string")
          return W;
        let y = W.match(/\[(bgcolor|fillColor|strokeColor|color)\s*=\s*['"]?\w+['"]?\]/g);
        return y && (y = y.map((t) => {
          const e = t.slice(1, -1).split("="), Z = Object(i.parseColor)(e[1].replace(/['"]/g, ""));
          return [t, `[${e[0]}="${Z}"]`];
        }), y.forEach(([t, e]) => {
          W = W.replace(t, e);
        })), y = W.match(/\[\w+\s*=\s*['"]\[.+?\]['"]\]/g), y && (y = y.map((t) => {
          const e = t.slice(1, -1).split("="), Z = e[1].slice(2, -2).split(/,/g).map((a) => a.trim());
          return [t, `[${e[0]}="[${Z}]"]`];
        }), y.forEach(([t, e]) => {
          W = W.replace(t, e);
        })), W;
      }
      function h(W, y) {
        return c.selectAll(o(W), y, {
          adapter: L
        });
      }
      function p(W, y) {
        return c.selectOne(o(W), y, {
          adapter: L
        });
      }
      function r(W, y) {
        return c.is(W, o(y), {
          adapter: L
        });
      }
      function V(W) {
        return c.compile(o(W), {
          adapter: L
        });
      }
    },
    /* 253 */
    /***/
    function(b, d, l) {
      b.exports = V;
      var i = l(254), s = l(273).falseFunc, c = l(274);
      function m(W) {
        return function(t, e, Z) {
          return e = e || {}, e.adapter = e.adapter || i, W(t, e, Z);
        };
      }
      var n = m(c), X = m(c.compileUnsafe);
      function G(W) {
        return function(t, e, Z) {
          return Z = Z || {}, Z.adapter = Z.adapter || i, typeof t != "function" && (t = X(t, Z, e)), t.shouldTestNextSiblings && (e = o(Z && Z.context || e, Z.adapter)), Array.isArray(e) ? e = Z.adapter.removeSubsets(e) : e = Z.adapter.getChildren(e), W(t, e, Z);
        };
      }
      function L(W, y) {
        var t = y.getSiblings(W);
        if (!Array.isArray(t))
          return [];
        for (t = t.slice(0); t.shift() !== W; )
          ;
        return t;
      }
      function o(W, y) {
        Array.isArray(W) || (W = [W]);
        for (var t = W.slice(0), e = 0, Z = W.length; e < Z; e++) {
          var a = L(t[e], y);
          t.push.apply(t, a);
        }
        return t;
      }
      var h = G(function(y, t, e) {
        return y === s || !t || t.length === 0 ? [] : e.adapter.findAll(y, t);
      }), p = G(function(y, t, e) {
        return y === s || !t || t.length === 0 ? null : e.adapter.findOne(y, t);
      });
      function r(W, y, t) {
        return t = t || {}, t.adapter = t.adapter || i, (typeof y == "function" ? y : n(y, t))(W);
      }
      function V(W, y, t) {
        return h(W, y, t);
      }
      V.compile = n, V.filters = c.Pseudos.filters, V.pseudos = c.Pseudos.pseudos, V.selectAll = h, V.selectOne = p, V.is = r, V.parse = n, V.iterate = h, V._compileUnsafe = X, V._compileToken = c.compileToken;
    },
    /* 254 */
    /***/
    function(b, d, l) {
      var i = b.exports;
      [
        l(255),
        l(268),
        l(269),
        l(270),
        l(271),
        l(272)
      ].forEach(function(s) {
        Object.keys(s).forEach(function(c) {
          i[c] = s[c].bind(i);
        });
      });
    },
    /* 255 */
    /***/
    function(b, d, l) {
      var i = l(256), s = l(257), c = i.isTag;
      b.exports = {
        getInnerHTML: m,
        getOuterHTML: s,
        getText: n
      };
      function m(X, G) {
        return X.children ? X.children.map(function(L) {
          return s(L, G);
        }).join("") : "";
      }
      function n(X) {
        return Array.isArray(X) ? X.map(n).join("") : c(X) ? X.name === "br" ? `
` : n(X.children) : X.type === i.CDATA ? n(X.children) : X.type === i.Text ? X.data : "";
      }
    },
    /* 256 */
    /***/
    function(b, d) {
      b.exports = {
        Text: "text",
        //Text
        Directive: "directive",
        //<? ... ?>
        Comment: "comment",
        //<!-- ... -->
        Script: "script",
        //<script> tags
        Style: "style",
        //<style> tags
        Tag: "tag",
        //Any tag
        CDATA: "cdata",
        //<![CDATA[ ... ]]>
        Doctype: "doctype",
        isTag: function(l) {
          return l.type === "tag" || l.type === "script" || l.type === "style";
        }
      };
    },
    /* 257 */
    /***/
    function(b, d, l) {
      var i = l(258), s = l(259), c = l(267);
      c.elementNames.__proto__ = null, c.attributeNames.__proto__ = null;
      var m = {
        __proto__: null,
        style: !0,
        script: !0,
        xmp: !0,
        iframe: !0,
        noembed: !0,
        noframes: !0,
        plaintext: !0,
        noscript: !0
      };
      function n(W, y) {
        if (W) {
          var t = "", e;
          for (var Z in W)
            e = W[Z], t && (t += " "), y.xmlMode === "foreign" && (Z = c.attributeNames[Z] || Z), t += Z, (e !== null && e !== "" || y.xmlMode) && (t += '="' + (y.decodeEntities ? s.encodeXML(e) : e.replace(/\"/g, "&quot;")) + '"');
          return t;
        }
      }
      var X = {
        __proto__: null,
        area: !0,
        base: !0,
        basefont: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        isindex: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, G = b.exports = function(W, y) {
        !Array.isArray(W) && !W.cheerio && (W = [W]), y = y || {};
        for (var t = "", e = 0; e < W.length; e++) {
          var Z = W[e];
          Z.type === "root" ? t += G(Z.children, y) : i.isTag(Z) ? t += o(Z, y) : Z.type === i.Directive ? t += h(Z) : Z.type === i.Comment ? t += V(Z) : Z.type === i.CDATA ? t += r(Z) : t += p(Z, y);
        }
        return t;
      }, L = [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ];
      function o(W, y) {
        y.xmlMode === "foreign" && (W.name = c.elementNames[W.name] || W.name, W.parent && L.indexOf(W.parent.name) >= 0 && (y = Object.assign({}, y, { xmlMode: !1 }))), !y.xmlMode && ["svg", "math"].indexOf(W.name) >= 0 && (y = Object.assign({}, y, { xmlMode: "foreign" }));
        var t = "<" + W.name, e = n(W.attribs, y);
        return e && (t += " " + e), y.xmlMode && (!W.children || W.children.length === 0) ? t += "/>" : (t += ">", W.children && (t += G(W.children, y)), (!X[W.name] || y.xmlMode) && (t += "</" + W.name + ">")), t;
      }
      function h(W) {
        return "<" + W.data + ">";
      }
      function p(W, y) {
        var t = W.data || "";
        return y.decodeEntities && !(W.parent && W.parent.name in m) && (t = s.encodeXML(t)), t;
      }
      function r(W) {
        return "<![CDATA[" + W.children[0].data + "]]>";
      }
      function V(W) {
        return "<!--" + W.data + "-->";
      }
    },
    /* 258 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 });
      function i(s) {
        return s.type === "tag" || s.type === "script" || s.type === "style";
      }
      d.isTag = i, d.Text = "text", d.Directive = "directive", d.Comment = "comment", d.Script = "script", d.Style = "style", d.Tag = "tag", d.CDATA = "cdata", d.Doctype = "doctype";
    },
    /* 259 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 }), d.encode = d.decodeStrict = d.decode = void 0;
      var i = l(260), s = l(266);
      function c(L, o) {
        return (!o || o <= 0 ? i.decodeXML : i.decodeHTML)(L);
      }
      d.decode = c;
      function m(L, o) {
        return (!o || o <= 0 ? i.decodeXML : i.decodeHTMLStrict)(L);
      }
      d.decodeStrict = m;
      function n(L, o) {
        return (!o || o <= 0 ? s.encodeXML : s.encodeHTML)(L);
      }
      d.encode = n;
      var X = l(266);
      Object.defineProperty(d, "encodeXML", { enumerable: !0, get: function() {
        return X.encodeXML;
      } }), Object.defineProperty(d, "encodeHTML", { enumerable: !0, get: function() {
        return X.encodeHTML;
      } }), Object.defineProperty(d, "escape", { enumerable: !0, get: function() {
        return X.escape;
      } }), Object.defineProperty(d, "encodeHTML4", { enumerable: !0, get: function() {
        return X.encodeHTML;
      } }), Object.defineProperty(d, "encodeHTML5", { enumerable: !0, get: function() {
        return X.encodeHTML;
      } });
      var G = l(260);
      Object.defineProperty(d, "decodeXML", { enumerable: !0, get: function() {
        return G.decodeXML;
      } }), Object.defineProperty(d, "decodeHTML", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(d, "decodeHTMLStrict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(d, "decodeHTML4", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(d, "decodeHTML5", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(d, "decodeHTML4Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(d, "decodeHTML5Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(d, "decodeXMLStrict", { enumerable: !0, get: function() {
        return G.decodeXML;
      } });
    },
    /* 260 */
    /***/
    function(b, d, l) {
      var i = this && this.__importDefault || function(o) {
        return o && o.__esModule ? o : { default: o };
      };
      Object.defineProperty(d, "__esModule", { value: !0 }), d.decodeHTML = d.decodeHTMLStrict = d.decodeXML = void 0;
      var s = i(l(261)), c = i(l(262)), m = i(l(263)), n = i(l(264));
      d.decodeXML = X(m.default), d.decodeHTMLStrict = X(s.default);
      function X(o) {
        var h = Object.keys(o).join("|"), p = L(o);
        h += "|#[xX][\\da-fA-F]+|#\\d+";
        var r = new RegExp("&(?:" + h + ");", "g");
        return function(V) {
          return String(V).replace(r, p);
        };
      }
      var G = function(o, h) {
        return o < h ? 1 : -1;
      };
      d.decodeHTML = function() {
        for (var o = Object.keys(c.default).sort(G), h = Object.keys(s.default).sort(G), p = 0, r = 0; p < h.length; p++)
          o[r] === h[p] ? (h[p] += ";?", r++) : h[p] += ";";
        var V = new RegExp("&(?:" + h.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), W = L(s.default);
        function y(t) {
          return t.substr(-1) !== ";" && (t += ";"), W(t);
        }
        return function(t) {
          return String(t).replace(V, y);
        };
      }();
      function L(o) {
        return function(p) {
          if (p.charAt(1) === "#") {
            var r = p.charAt(2);
            return r === "X" || r === "x" ? n.default(parseInt(p.substr(3), 16)) : n.default(parseInt(p.substr(2), 10));
          }
          return o[p.slice(1, -1)];
        };
      }
    },
    /* 261 */
    /***/
    function(b) {
      b.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');
    },
    /* 262 */
    /***/
    function(b) {
      b.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');
    },
    /* 263 */
    /***/
    function(b) {
      b.exports = JSON.parse(`{"amp":"&","apos":"'","gt":">","lt":"<","quot":"\\""}`);
    },
    /* 264 */
    /***/
    function(b, d, l) {
      var i = this && this.__importDefault || function(m) {
        return m && m.__esModule ? m : { default: m };
      };
      Object.defineProperty(d, "__esModule", { value: !0 });
      var s = i(l(265));
      function c(m) {
        if (m >= 55296 && m <= 57343 || m > 1114111)
          return "�";
        m in s.default && (m = s.default[m]);
        var n = "";
        return m > 65535 && (m -= 65536, n += String.fromCharCode(m >>> 10 & 1023 | 55296), m = 56320 | m & 1023), n += String.fromCharCode(m), n;
      }
      d.default = c;
    },
    /* 265 */
    /***/
    function(b) {
      b.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');
    },
    /* 266 */
    /***/
    function(b, d, l) {
      var i = this && this.__importDefault || function(y) {
        return y && y.__esModule ? y : { default: y };
      };
      Object.defineProperty(d, "__esModule", { value: !0 }), d.escape = d.encodeHTML = d.encodeXML = void 0;
      var s = i(l(263)), c = L(s.default), m = o(c);
      d.encodeXML = r(c, m);
      var n = i(l(261)), X = L(n.default), G = o(X);
      d.encodeHTML = r(X, G);
      function L(y) {
        return Object.keys(y).sort().reduce(function(t, e) {
          return t[y[e]] = "&" + e + ";", t;
        }, {});
      }
      function o(y) {
        for (var t = [], e = [], Z = 0, a = Object.keys(y); Z < a.length; Z++) {
          var x = a[Z];
          x.length === 1 ? t.push("\\" + x) : e.push(x);
        }
        t.sort();
        for (var K = 0; K < t.length - 1; K++) {
          for (var C = K; C < t.length - 1 && t[C].charCodeAt(1) + 1 === t[C + 1].charCodeAt(1); )
            C += 1;
          var T = 1 + C - K;
          T < 3 || t.splice(K, T, t[K] + "-" + t[C]);
        }
        return e.unshift("[" + t.join("") + "]"), new RegExp(e.join("|"), "g");
      }
      var h = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
      function p(y) {
        return "&#x" + y.codePointAt(0).toString(16).toUpperCase() + ";";
      }
      function r(y, t) {
        return function(e) {
          return e.replace(t, function(Z) {
            return y[Z];
          }).replace(h, p);
        };
      }
      var V = o(c);
      function W(y) {
        return y.replace(V, p).replace(h, p);
      }
      d.escape = W;
    },
    /* 267 */
    /***/
    function(b) {
      b.exports = JSON.parse('{"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}}');
    },
    /* 268 */
    /***/
    function(b, d) {
      var l = d.getChildren = function(s) {
        return s.children;
      }, i = d.getParent = function(s) {
        return s.parent;
      };
      d.getSiblings = function(s) {
        var c = i(s);
        return c ? l(c) : [s];
      }, d.getAttributeValue = function(s, c) {
        return s.attribs && s.attribs[c];
      }, d.hasAttrib = function(s, c) {
        return !!s.attribs && hasOwnProperty.call(s.attribs, c);
      }, d.getName = function(s) {
        return s.name;
      };
    },
    /* 269 */
    /***/
    function(b, d) {
      d.removeElement = function(l) {
        if (l.prev && (l.prev.next = l.next), l.next && (l.next.prev = l.prev), l.parent) {
          var i = l.parent.children;
          i.splice(i.lastIndexOf(l), 1);
        }
      }, d.replaceElement = function(l, i) {
        var s = i.prev = l.prev;
        s && (s.next = i);
        var c = i.next = l.next;
        c && (c.prev = i);
        var m = i.parent = l.parent;
        if (m) {
          var n = m.children;
          n[n.lastIndexOf(l)] = i;
        }
      }, d.appendChild = function(l, i) {
        if (i.parent = l, l.children.push(i) !== 1) {
          var s = l.children[l.children.length - 2];
          s.next = i, i.prev = s, i.next = null;
        }
      }, d.append = function(l, i) {
        var s = l.parent, c = l.next;
        if (i.next = c, i.prev = l, l.next = i, i.parent = s, c) {
          if (c.prev = i, s) {
            var m = s.children;
            m.splice(m.lastIndexOf(c), 0, i);
          }
        } else
          s && s.children.push(i);
      }, d.prepend = function(l, i) {
        var s = l.parent;
        if (s) {
          var c = s.children;
          c.splice(c.lastIndexOf(l), 0, i);
        }
        l.prev && (l.prev.next = i), i.parent = s, i.prev = l.prev, i.next = l, l.prev = i;
      };
    },
    /* 270 */
    /***/
    function(b, d, l) {
      var i = l(256).isTag;
      b.exports = {
        filter: s,
        find: c,
        findOneChild: m,
        findOne: n,
        existsOne: X,
        findAll: G
      };
      function s(L, o, h, p) {
        return Array.isArray(o) || (o = [o]), (typeof p != "number" || !isFinite(p)) && (p = 1 / 0), c(L, o, h !== !1, p);
      }
      function c(L, o, h, p) {
        for (var r = [], V, W = 0, y = o.length; W < y && !(L(o[W]) && (r.push(o[W]), --p <= 0) || (V = o[W].children, h && V && V.length > 0 && (V = c(L, V, h, p), r = r.concat(V), p -= V.length, p <= 0))); W++)
          ;
        return r;
      }
      function m(L, o) {
        for (var h = 0, p = o.length; h < p; h++)
          if (L(o[h]))
            return o[h];
        return null;
      }
      function n(L, o) {
        for (var h = null, p = 0, r = o.length; p < r && !h; p++)
          if (i(o[p]))
            L(o[p]) ? h = o[p] : o[p].children.length > 0 && (h = n(L, o[p].children));
          else
            continue;
        return h;
      }
      function X(L, o) {
        for (var h = 0, p = o.length; h < p; h++)
          if (i(o[h]) && (L(o[h]) || o[h].children.length > 0 && X(L, o[h].children)))
            return !0;
        return !1;
      }
      function G(L, o) {
        for (var h = [], p = o.slice(); p.length; ) {
          var r = p.shift();
          i(r) && (r.children && r.children.length > 0 && p.unshift.apply(p, r.children), L(r) && h.push(r));
        }
        return h;
      }
    },
    /* 271 */
    /***/
    function(b, d, l) {
      var i = l(256), s = d.isTag = i.isTag;
      d.testElement = function(X, G) {
        for (var L in X)
          if (X.hasOwnProperty(L)) {
            if (L === "tag_name") {
              if (!s(G) || !X.tag_name(G.name))
                return !1;
            } else if (L === "tag_type") {
              if (!X.tag_type(G.type))
                return !1;
            } else if (L === "tag_contains") {
              if (s(G) || !X.tag_contains(G.data))
                return !1;
            } else if (!G.attribs || !X[L](G.attribs[L]))
              return !1;
          }
        return !0;
      };
      var c = {
        tag_name: function(X) {
          return typeof X == "function" ? function(G) {
            return s(G) && X(G.name);
          } : X === "*" ? s : function(G) {
            return s(G) && G.name === X;
          };
        },
        tag_type: function(X) {
          return typeof X == "function" ? function(G) {
            return X(G.type);
          } : function(G) {
            return G.type === X;
          };
        },
        tag_contains: function(X) {
          return typeof X == "function" ? function(G) {
            return !s(G) && X(G.data);
          } : function(G) {
            return !s(G) && G.data === X;
          };
        }
      };
      function m(X, G) {
        return typeof G == "function" ? function(L) {
          return L.attribs && G(L.attribs[X]);
        } : function(L) {
          return L.attribs && L.attribs[X] === G;
        };
      }
      function n(X, G) {
        return function(L) {
          return X(L) || G(L);
        };
      }
      d.getElements = function(X, G, L, o) {
        var h = Object.keys(X).map(function(p) {
          var r = X[p];
          return p in c ? c[p](r) : m(p, r);
        });
        return h.length === 0 ? [] : this.filter(
          h.reduce(n),
          G,
          L,
          o
        );
      }, d.getElementById = function(X, G, L) {
        return Array.isArray(G) || (G = [G]), this.findOne(m("id", X), G, L !== !1);
      }, d.getElementsByTagName = function(X, G, L, o) {
        return this.filter(c.tag_name(X), G, L, o);
      }, d.getElementsByTagType = function(X, G, L, o) {
        return this.filter(c.tag_type(X), G, L, o);
      };
    },
    /* 272 */
    /***/
    function(b, d) {
      d.removeSubsets = function(s) {
        for (var c = s.length, m, n, X; --c > -1; ) {
          for (m = n = s[c], s[c] = null, X = !0; n; ) {
            if (s.indexOf(n) > -1) {
              X = !1, s.splice(c, 1);
              break;
            }
            n = n.parent;
          }
          X && (s[c] = m);
        }
        return s;
      };
      var l = {
        DISCONNECTED: 1,
        PRECEDING: 2,
        FOLLOWING: 4,
        CONTAINS: 8,
        CONTAINED_BY: 16
      }, i = d.compareDocumentPosition = function(s, c) {
        var m = [], n = [], X, G, L, o, h, p;
        if (s === c)
          return 0;
        for (X = s; X; )
          m.unshift(X), X = X.parent;
        for (X = c; X; )
          n.unshift(X), X = X.parent;
        for (p = 0; m[p] === n[p]; )
          p++;
        return p === 0 ? l.DISCONNECTED : (G = m[p - 1], L = G.children, o = m[p], h = n[p], L.indexOf(o) > L.indexOf(h) ? G === c ? l.FOLLOWING | l.CONTAINED_BY : l.FOLLOWING : G === s ? l.PRECEDING | l.CONTAINS : l.PRECEDING);
      };
      d.uniqueSort = function(s) {
        var c = s.length, m, n;
        for (s = s.slice(); --c > -1; )
          m = s[c], n = s.indexOf(m), n > -1 && n < c && s.splice(c, 1);
        return s.sort(function(X, G) {
          var L = i(X, G);
          return L & l.PRECEDING ? -1 : L & l.FOLLOWING ? 1 : 0;
        }), s;
      };
    },
    /* 273 */
    /***/
    function(b, d) {
      b.exports = {
        trueFunc: function() {
          return !0;
        },
        falseFunc: function() {
          return !1;
        }
      };
    },
    /* 274 */
    /***/
    function(b, d, l) {
      b.exports = h;
      var i = l(275).parse, s = l(273), c = l(278), m = l(279), n = l(280), X = l(282), G = s.trueFunc, L = s.falseFunc, o = X.filters;
      function h(I, J, F) {
        var R = r(I, J, F);
        return p(R, J);
      }
      function p(I, J) {
        var F = J.adapter;
        return function(S) {
          return F.isTag(S) && I(S);
        };
      }
      function r(I, J, F) {
        var R = i(I, J);
        return a(R, J, F);
      }
      function V(I) {
        return I.type === "pseudo" && (I.name === "scope" || Array.isArray(I.data) && I.data.some(function(J) {
          return J.some(V);
        }));
      }
      var W = { type: "descendant" }, y = { type: "_flexibleDescendant" }, t = { type: "pseudo", name: "scope" }, e = {};
      function Z(I, J, F) {
        var R = J.adapter, S = !!F && !!F.length && F.every(function(N) {
          return N === e || !!R.getParent(N);
        });
        I.forEach(function(N) {
          if (!(N.length > 0 && x(N[0]) && N[0].type !== "descendant"))
            if (S && !(Array.isArray(N) ? N.some(V) : V(N)))
              N.unshift(W);
            else
              return;
          N.unshift(t);
        });
      }
      function a(I, J, F) {
        I = I.filter(function(Q) {
          return Q.length > 0;
        }), I.forEach(c);
        var R = Array.isArray(F);
        F = J && J.context || F, F && !R && (F = [F]), Z(I, J, F);
        var S = !1, N = I.map(function(Q) {
          if (Q[0] && Q[1] && Q[0].name === "scope") {
            var P = Q[1].type;
            R && P === "descendant" ? Q[1] = y : (P === "adjacent" || P === "sibling") && (S = !0);
          }
          return K(Q, J, F);
        }).reduce(C, L);
        return N.shouldTestNextSiblings = S, N;
      }
      function x(I) {
        return m[I.type] < 0;
      }
      function K(I, J, F) {
        return I.reduce(function(R, S) {
          if (R === L)
            return R;
          if (!(S.type in n))
            throw new Error("Rule type " + S.type + " is not supported by css-select");
          return n[S.type](R, S, J, F);
        }, J && J.rootFunc || G);
      }
      function C(I, J) {
        return J === L || I === G ? I : I === L || J === G ? J : function(R) {
          return I(R) || J(R);
        };
      }
      function T(I) {
        return I.some(x);
      }
      o.not = function(I, J, F, R) {
        var S = {
          xmlMode: !!(F && F.xmlMode),
          strict: !!(F && F.strict),
          adapter: F.adapter
        };
        if (S.strict && (J.length > 1 || J.some(T)))
          throw new Error("complex selectors in :not aren't allowed in strict mode");
        var N = a(J, S, R);
        return N === L ? I : N === G ? L : function(P) {
          return !N(P) && I(P);
        };
      }, o.has = function(I, J, F) {
        var R = F.adapter, S = {
          xmlMode: !!(F && F.xmlMode),
          strict: !!(F && F.strict),
          adapter: R
        }, N = J.some(T) ? [e] : null, Q = a(J, S, N);
        return Q === L ? L : Q === G ? function(j) {
          return R.getChildren(j).some(R.isTag) && I(j);
        } : (Q = p(Q, F), N ? function(j) {
          return I(j) && (N[0] = j, R.existsOne(Q, R.getChildren(j)));
        } : function(j) {
          return I(j) && R.existsOne(Q, R.getChildren(j));
        });
      }, o.matches = function(I, J, F, R) {
        var S = {
          xmlMode: !!(F && F.xmlMode),
          strict: !!(F && F.strict),
          rootFunc: I,
          adapter: F.adapter
        };
        return a(J, S, R);
      }, h.compileToken = a, h.compileUnsafe = r, h.Pseudos = X;
    },
    /* 275 */
    /***/
    function(b, d, l) {
      var i = this && this.__createBinding || (Object.create ? function(n, X, G, L) {
        L === void 0 && (L = G), Object.defineProperty(n, L, { enumerable: !0, get: function() {
          return X[G];
        } });
      } : function(n, X, G, L) {
        L === void 0 && (L = G), n[L] = X[G];
      }), s = this && this.__exportStar || function(n, X) {
        for (var G in n)
          G !== "default" && !X.hasOwnProperty(G) && i(X, n, G);
      };
      Object.defineProperty(d, "__esModule", { value: !0 }), s(l(276), d);
      var c = l(276);
      Object.defineProperty(d, "parse", { enumerable: !0, get: function() {
        return c.default;
      } });
      var m = l(277);
      Object.defineProperty(d, "stringify", { enumerable: !0, get: function() {
        return m.default;
      } });
    },
    /* 276 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 }), d.default = V;
      var i = /^[^\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, s = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, c = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/, m = {
        undefined: "exists",
        "": "equals",
        "~": "element",
        "^": "start",
        $: "end",
        "*": "any",
        "!": "not",
        "|": "hyphen"
      }, n = {
        ">": "child",
        "<": "parent",
        "~": "sibling",
        "+": "adjacent"
      }, X = {
        "#": ["id", "equals"],
        ".": ["class", "element"]
      }, G = /* @__PURE__ */ new Set(["has", "not", "matches"]), L = /* @__PURE__ */ new Set(["contains", "icontains"]), o = /* @__PURE__ */ new Set(['"', "'"]);
      function h(t, e, Z) {
        var a = parseInt(e, 16) - 65536;
        return a !== a || Z ? e : a < 0 ? (
          // BMP codepoint
          String.fromCharCode(a + 65536)
        ) : (
          // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(a >> 10 | 55296, a & 1023 | 56320)
        );
      }
      function p(t) {
        return t.replace(s, h);
      }
      function r(t) {
        return t === " " || t === `
` || t === "	" || t === "\f" || t === "\r";
      }
      function V(t, e) {
        var Z = [];
        if (t = W(Z, "" + t, e), t !== "")
          throw new Error("Unmatched selector: " + t);
        return Z;
      }
      function W(t, e, Z) {
        var a = [], x = !1;
        function K() {
          var A = e.match(i);
          if (!A)
            throw new Error("Expected name, found " + e);
          var ll = A[0];
          return e = e.substr(ll.length), p(ll);
        }
        function C(A) {
          for (; r(e.charAt(A)); )
            A++;
          e = e.substr(A);
        }
        function T(A) {
          for (var ll = 0; e.charAt(--A) === "\\"; )
            ll++;
          return (ll & 1) === 1;
        }
        for (C(0); e !== ""; ) {
          var I = e.charAt(0);
          if (r(I))
            x = !0, C(1);
          else if (I in n)
            a.push({ type: n[I] }), x = !1, C(1);
          else if (I === ",") {
            if (a.length === 0)
              throw new Error("Empty sub-selector");
            t.push(a), a = [], x = !1, C(1);
          } else if (x && (a.length > 0 && a.push({ type: "descendant" }), x = !1), I === "*")
            e = e.substr(1), a.push({ type: "universal" });
          else if (I in X) {
            var J = X[I], F = J[0], R = J[1];
            e = e.substr(1), a.push({
              type: "attribute",
              name: F,
              action: R,
              value: K(),
              ignoreCase: !1
            });
          } else if (I === "[") {
            e = e.substr(1);
            var S = e.match(c);
            if (!S)
              throw new Error("Malformed attribute selector: " + e);
            e = e.substr(S[0].length);
            var N = p(S[1]);
            (!Z || ("lowerCaseAttributeNames" in Z ? Z.lowerCaseAttributeNames : !Z.xmlMode)) && (N = N.toLowerCase()), a.push({
              type: "attribute",
              name: N,
              action: m[S[2]],
              value: p(S[4] || S[5] || ""),
              ignoreCase: !!S[6]
            });
          } else if (I === ":") {
            if (e.charAt(1) === ":") {
              e = e.substr(2), a.push({
                type: "pseudo-element",
                name: K().toLowerCase()
              });
              continue;
            }
            e = e.substr(1);
            var Q = K().toLowerCase(), S = null;
            if (e.charAt(0) === "(")
              if (G.has(Q)) {
                var P = e.charAt(1), j = o.has(P);
                if (e = e.substr(j ? 2 : 1), S = [], e = W(S, e, Z), j) {
                  if (e.charAt(0) !== P)
                    throw new Error("Unmatched quotes in :" + Q);
                  e = e.substr(1);
                }
                if (e.charAt(0) !== ")")
                  throw new Error("Missing closing parenthesis in :" + Q + " (" + e + ")");
                e = e.substr(1);
              } else {
                for (var D = 1, z = 1; z > 0 && D < e.length; D++)
                  e.charAt(D) === "(" && !T(D) ? z++ : e.charAt(D) === ")" && !T(D) && z--;
                if (z)
                  throw new Error("Parenthesis not matched");
                if (S = e.substr(1, D - 2), e = e.substr(D), L.has(Q)) {
                  var P = S.charAt(0);
                  P === S.slice(-1) && o.has(P) && (S = S.slice(1, -1)), S = p(S);
                }
              }
            a.push({ type: "pseudo", name: Q, data: S });
          } else if (i.test(e)) {
            var w = K();
            (!Z || ("lowerCaseTags" in Z ? Z.lowerCaseTags : !Z.xmlMode)) && (w = w.toLowerCase()), a.push({ type: "tag", name: w });
          } else
            return a.length && a[a.length - 1].type === "descendant" && a.pop(), y(t, a), e;
        }
        return y(t, a), e;
      }
      function y(t, e) {
        if (t.length > 0 && e.length === 0)
          throw new Error("Empty sub-selector");
        t.push(e);
      }
    },
    /* 277 */
    /***/
    function(b, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 });
      var i = {
        equals: "",
        element: "~",
        start: "^",
        end: "$",
        any: "*",
        not: "!",
        hyphen: "|"
      };
      function s(X) {
        return X.map(c).join(", ");
      }
      d.default = s;
      function c(X) {
        return X.map(m).join("");
      }
      function m(X) {
        switch (X.type) {
          case "child":
            return " > ";
          case "parent":
            return " < ";
          case "sibling":
            return " ~ ";
          case "adjacent":
            return " + ";
          case "descendant":
            return " ";
          case "universal":
            return "*";
          case "tag":
            return X.name;
          case "pseudo-element":
            return "::" + X.name;
          case "pseudo":
            return X.data === null ? ":" + X.name : typeof X.data == "string" ? ":" + X.name + "(" + X.data + ")" : ":" + X.name + "(" + s(X.data) + ")";
          case "attribute":
            return X.action === "exists" ? "[" + X.name + "]" : X.name === "id" && X.action === "equals" && !X.ignoreCase ? "#" + X.value : X.name === "class" && X.action === "element" && !X.ignoreCase ? "." + X.value : "[" + X.name + i[X.action] + "='" + X.value + "'" + (X.ignoreCase ? "i" : "") + "]";
          default:
            throw new Error("Unknown type");
        }
      }
      function n(X) {
        return X;
      }
    },
    /* 278 */
    /***/
    function(b, d, l) {
      b.exports = c;
      var i = l(279), s = {
        __proto__: null,
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4
      };
      function c(n) {
        for (var X = n.map(m), G = 1; G < n.length; G++) {
          var L = X[G];
          if (!(L < 0))
            for (var o = G - 1; o >= 0 && L < X[o]; o--) {
              var h = n[o + 1];
              n[o + 1] = n[o], n[o] = h, X[o + 1] = X[o], X[o] = L;
            }
        }
      }
      function m(n) {
        var X = i[n.type];
        if (X === i.attribute)
          X = s[n.action], X === s.equals && n.name === "id" && (X = 9), n.ignoreCase && (X >>= 1);
        else if (X === i.pseudo)
          if (!n.data)
            X = 3;
          else if (n.name === "has" || n.name === "contains")
            X = 0;
          else if (n.name === "matches" || n.name === "not") {
            X = 0;
            for (var G = 0; G < n.data.length; G++)
              if (n.data[G].length === 1) {
                var L = m(n.data[G][0]);
                if (L === 0) {
                  X = 0;
                  break;
                }
                L > X && (X = L);
              }
            n.data.length > 1 && X > 0 && (X -= 1);
          } else
            X = 1;
        return X;
      }
    },
    /* 279 */
    /***/
    function(b) {
      b.exports = JSON.parse('{"universal":50,"tag":30,"attribute":1,"pseudo":0,"descendant":-1,"child":-1,"parent":-1,"sibling":-1,"adjacent":-1}');
    },
    /* 280 */
    /***/
    function(b, d, l) {
      var i = l(281), s = l(282);
      b.exports = {
        __proto__: null,
        attribute: i.compile,
        pseudo: s.compile,
        //tags
        tag: function(c, m, n) {
          var X = m.name, G = n.adapter;
          return function(o) {
            return G.getName(o) === X && c(o);
          };
        },
        //traversal
        descendant: function(c, m, n) {
          var X = typeof WeakSet < "u" ? /* @__PURE__ */ new WeakSet() : null, G = n.adapter;
          return function(o) {
            for (var h = !1; !h && (o = G.getParent(o)); )
              (!X || !X.has(o)) && (h = c(o), !h && X && X.add(o));
            return h;
          };
        },
        _flexibleDescendant: function(c, m, n) {
          var X = n.adapter;
          return function(L) {
            for (var o = c(L); !o && (L = X.getParent(L)); )
              o = c(L);
            return o;
          };
        },
        parent: function(c, m, n) {
          if (n && n.strict)
            throw new Error("Parent selector isn't part of CSS3");
          var X = n.adapter;
          return function(o) {
            return X.getChildren(o).some(G);
          };
          function G(L) {
            return X.isTag(L) && c(L);
          }
        },
        child: function(c, m, n) {
          var X = n.adapter;
          return function(L) {
            var o = X.getParent(L);
            return !!o && c(o);
          };
        },
        sibling: function(c, m, n) {
          var X = n.adapter;
          return function(L) {
            for (var o = X.getSiblings(L), h = 0; h < o.length; h++)
              if (X.isTag(o[h])) {
                if (o[h] === L)
                  break;
                if (c(o[h]))
                  return !0;
              }
            return !1;
          };
        },
        adjacent: function(c, m, n) {
          var X = n.adapter;
          return function(L) {
            for (var o = X.getSiblings(L), h, p = 0; p < o.length; p++)
              if (X.isTag(o[p])) {
                if (o[p] === L)
                  break;
                h = o[p];
              }
            return !!h && c(h);
          };
        },
        universal: function(c) {
          return c;
        }
      };
    },
    /* 281 */
    /***/
    function(b, d, l) {
      var i = l(273).falseFunc, s = /[-[\]{}()*+?.,\\^$|#\s]/g, c = {
        __proto__: null,
        equals: function(m, n, X) {
          var G = n.name, L = n.value, o = X.adapter;
          return n.ignoreCase ? (L = L.toLowerCase(), function(p) {
            var r = o.getAttributeValue(p, G);
            return r != null && r.toLowerCase() === L && m(p);
          }) : function(p) {
            return o.getAttributeValue(p, G) === L && m(p);
          };
        },
        hyphen: function(m, n, X) {
          var G = n.name, L = n.value, o = L.length, h = X.adapter;
          return n.ignoreCase ? (L = L.toLowerCase(), function(r) {
            var V = h.getAttributeValue(r, G);
            return V != null && (V.length === o || V.charAt(o) === "-") && V.substr(0, o).toLowerCase() === L && m(r);
          }) : function(r) {
            var V = h.getAttributeValue(r, G);
            return V != null && V.substr(0, o) === L && (V.length === o || V.charAt(o) === "-") && m(r);
          };
        },
        element: function(m, n, X) {
          var G = n.name, L = n.value, o = X.adapter;
          if (/\s/.test(L))
            return i;
          L = L.replace(s, "\\$&");
          var h = "(?:^|\\s)" + L + "(?:$|\\s)", p = n.ignoreCase ? "i" : "", r = new RegExp(h, p);
          return function(W) {
            var y = o.getAttributeValue(W, G);
            return y != null && r.test(y) && m(W);
          };
        },
        exists: function(m, n, X) {
          var G = n.name, L = X.adapter;
          return function(h) {
            return L.hasAttrib(h, G) && m(h);
          };
        },
        start: function(m, n, X) {
          var G = n.name, L = n.value, o = L.length, h = X.adapter;
          return o === 0 ? i : n.ignoreCase ? (L = L.toLowerCase(), function(r) {
            var V = h.getAttributeValue(r, G);
            return V != null && V.substr(0, o).toLowerCase() === L && m(r);
          }) : function(r) {
            var V = h.getAttributeValue(r, G);
            return V != null && V.substr(0, o) === L && m(r);
          };
        },
        end: function(m, n, X) {
          var G = n.name, L = n.value, o = -L.length, h = X.adapter;
          return o === 0 ? i : n.ignoreCase ? (L = L.toLowerCase(), function(r) {
            var V = h.getAttributeValue(r, G);
            return V != null && V.substr(o).toLowerCase() === L && m(r);
          }) : function(r) {
            var V = h.getAttributeValue(r, G);
            return V != null && V.substr(o) === L && m(r);
          };
        },
        any: function(m, n, X) {
          var G = n.name, L = n.value, o = X.adapter;
          if (L === "")
            return i;
          if (n.ignoreCase) {
            var h = new RegExp(L.replace(s, "\\$&"), "i");
            return function(r) {
              var V = o.getAttributeValue(r, G);
              return V != null && h.test(V) && m(r);
            };
          }
          return function(r) {
            var V = o.getAttributeValue(r, G);
            return V != null && V.indexOf(L) >= 0 && m(r);
          };
        },
        not: function(m, n, X) {
          var G = n.name, L = n.value, o = X.adapter;
          return L === "" ? function(p) {
            return !!o.getAttributeValue(p, G) && m(p);
          } : n.ignoreCase ? (L = L.toLowerCase(), function(p) {
            var r = o.getAttributeValue(p, G);
            return r != null && r.toLowerCase() !== L && m(p);
          }) : function(p) {
            return o.getAttributeValue(p, G) !== L && m(p);
          };
        }
      };
      b.exports = {
        compile: function(m, n, X) {
          if (X && X.strict && (n.ignoreCase || n.action === "not"))
            throw new Error("Unsupported attribute selector");
          return c[n.action](m, n, X);
        },
        rules: c
      };
    },
    /* 282 */
    /***/
    function(b, d, l) {
      var i = l(283), s = l(273), c = l(281), m = s.trueFunc, n = s.falseFunc, X = c.rules.equals;
      function G(y, t) {
        var e = { name: y, value: t };
        return function(a, x, K) {
          return X(a, e, K);
        };
      }
      function L(y, t) {
        return function(e) {
          return !!t.getParent(e) && y(e);
        };
      }
      var o = {
        contains: function(y, t, e) {
          var Z = e.adapter;
          return function(x) {
            return y(x) && Z.getText(x).indexOf(t) >= 0;
          };
        },
        icontains: function(y, t, e) {
          var Z = t.toLowerCase(), a = e.adapter;
          return function(K) {
            return y(K) && a.getText(K).toLowerCase().indexOf(Z) >= 0;
          };
        },
        //location specific methods
        "nth-child": function(y, t, e) {
          var Z = i(t), a = e.adapter;
          return Z === n ? Z : Z === m ? L(y, a) : function(K) {
            for (var C = a.getSiblings(K), T = 0, I = 0; T < C.length; T++)
              if (a.isTag(C[T])) {
                if (C[T] === K)
                  break;
                I++;
              }
            return Z(I) && y(K);
          };
        },
        "nth-last-child": function(y, t, e) {
          var Z = i(t), a = e.adapter;
          return Z === n ? Z : Z === m ? L(y, a) : function(K) {
            for (var C = a.getSiblings(K), T = 0, I = C.length - 1; I >= 0; I--)
              if (a.isTag(C[I])) {
                if (C[I] === K)
                  break;
                T++;
              }
            return Z(T) && y(K);
          };
        },
        "nth-of-type": function(y, t, e) {
          var Z = i(t), a = e.adapter;
          return Z === n ? Z : Z === m ? L(y, a) : function(K) {
            for (var C = a.getSiblings(K), T = 0, I = 0; I < C.length; I++)
              if (a.isTag(C[I])) {
                if (C[I] === K)
                  break;
                a.getName(C[I]) === a.getName(K) && T++;
              }
            return Z(T) && y(K);
          };
        },
        "nth-last-of-type": function(y, t, e) {
          var Z = i(t), a = e.adapter;
          return Z === n ? Z : Z === m ? L(y, a) : function(K) {
            for (var C = a.getSiblings(K), T = 0, I = C.length - 1; I >= 0; I--)
              if (a.isTag(C[I])) {
                if (C[I] === K)
                  break;
                a.getName(C[I]) === a.getName(K) && T++;
              }
            return Z(T) && y(K);
          };
        },
        //TODO determine the actual root element
        root: function(y, t, e) {
          var Z = e.adapter;
          return function(a) {
            return !Z.getParent(a) && y(a);
          };
        },
        scope: function(y, t, e, Z) {
          var a = e.adapter;
          if (!Z || Z.length === 0)
            return o.root(y, t, e);
          function x(K, C) {
            return typeof a.equals == "function" ? a.equals(K, C) : K === C;
          }
          return Z.length === 1 ? function(K) {
            return x(Z[0], K) && y(K);
          } : function(K) {
            return Z.indexOf(K) >= 0 && y(K);
          };
        },
        //jQuery extensions (others follow as pseudos)
        checkbox: G("type", "checkbox"),
        file: G("type", "file"),
        password: G("type", "password"),
        radio: G("type", "radio"),
        reset: G("type", "reset"),
        image: G("type", "image"),
        submit: G("type", "submit"),
        //dynamic state pseudos. These depend on optional Adapter methods.
        hover: function(y, t, e) {
          var Z = e.adapter;
          return typeof Z.isHovered == "function" ? function(x) {
            return y(x) && Z.isHovered(x);
          } : n;
        },
        visited: function(y, t, e) {
          var Z = e.adapter;
          return typeof Z.isVisited == "function" ? function(x) {
            return y(x) && Z.isVisited(x);
          } : n;
        },
        active: function(y, t, e) {
          var Z = e.adapter;
          return typeof Z.isActive == "function" ? function(x) {
            return y(x) && Z.isActive(x);
          } : n;
        }
      };
      function h(y, t) {
        for (var e = 0; y && e < y.length; e++)
          if (t.isTag(y[e]))
            return y[e];
      }
      var p = {
        empty: function(y, t) {
          return !t.getChildren(y).some(function(e) {
            return t.isTag(e) || e.type === "text";
          });
        },
        "first-child": function(y, t) {
          return h(t.getSiblings(y), t) === y;
        },
        "last-child": function(y, t) {
          for (var e = t.getSiblings(y), Z = e.length - 1; Z >= 0; Z--) {
            if (e[Z] === y)
              return !0;
            if (t.isTag(e[Z]))
              break;
          }
          return !1;
        },
        "first-of-type": function(y, t) {
          for (var e = t.getSiblings(y), Z = 0; Z < e.length; Z++)
            if (t.isTag(e[Z])) {
              if (e[Z] === y)
                return !0;
              if (t.getName(e[Z]) === t.getName(y))
                break;
            }
          return !1;
        },
        "last-of-type": function(y, t) {
          for (var e = t.getSiblings(y), Z = e.length - 1; Z >= 0; Z--)
            if (t.isTag(e[Z])) {
              if (e[Z] === y)
                return !0;
              if (t.getName(e[Z]) === t.getName(y))
                break;
            }
          return !1;
        },
        "only-of-type": function(y, t) {
          for (var e = t.getSiblings(y), Z = 0, a = e.length; Z < a; Z++)
            if (t.isTag(e[Z])) {
              if (e[Z] === y)
                continue;
              if (t.getName(e[Z]) === t.getName(y))
                return !1;
            }
          return !0;
        },
        "only-child": function(y, t) {
          for (var e = t.getSiblings(y), Z = 0; Z < e.length; Z++)
            if (t.isTag(e[Z]) && e[Z] !== y)
              return !1;
          return !0;
        },
        //:matches(a, area, link)[href]
        link: function(y, t) {
          return t.hasAttrib(y, "href");
        },
        //TODO: :any-link once the name is finalized (as an alias of :link)
        //forms
        //to consider: :target
        //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
        selected: function(y, t) {
          if (t.hasAttrib(y, "selected"))
            return !0;
          if (t.getName(y) !== "option")
            return !1;
          var e = t.getParent(y);
          if (!e || t.getName(e) !== "select" || t.hasAttrib(e, "multiple"))
            return !1;
          for (var Z = t.getChildren(e), a = !1, x = 0; x < Z.length; x++)
            if (t.isTag(Z[x]))
              if (Z[x] === y)
                a = !0;
              else if (a) {
                if (t.hasAttrib(Z[x], "selected"))
                  return !1;
              } else
                return !1;
          return a;
        },
        //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        //:matches(
        //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
        //  optgroup[disabled] > option),
        // fieldset[disabled] * //TODO not child of first <legend>
        //)
        disabled: function(y, t) {
          return t.hasAttrib(y, "disabled");
        },
        enabled: function(y, t) {
          return !t.hasAttrib(y, "disabled");
        },
        //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
        checked: function(y, t) {
          return t.hasAttrib(y, "checked") || p.selected(y, t);
        },
        //:matches(input, select, textarea)[required]
        required: function(y, t) {
          return t.hasAttrib(y, "required");
        },
        //:matches(input, select, textarea):not([required])
        optional: function(y, t) {
          return !t.hasAttrib(y, "required");
        },
        //jQuery extensions
        //:not(:empty)
        parent: function(y, t) {
          return !p.empty(y, t);
        },
        //:matches(h1, h2, h3, h4, h5, h6)
        header: r(["h1", "h2", "h3", "h4", "h5", "h6"]),
        //:matches(button, input[type=button])
        button: function(y, t) {
          var e = t.getName(y);
          return e === "button" || e === "input" && t.getAttributeValue(y, "type") === "button";
        },
        //:matches(input, textarea, select, button)
        input: r(["input", "textarea", "select", "button"]),
        //input:matches(:not([type!='']), [type='text' i])
        text: function(y, t) {
          var e;
          return t.getName(y) === "input" && (!(e = t.getAttributeValue(y, "type")) || e.toLowerCase() === "text");
        }
      };
      function r(y) {
        if (typeof Set < "u") {
          var t = new Set(y);
          return function(e, Z) {
            return t.has(Z.getName(e));
          };
        }
        return function(e, Z) {
          return y.indexOf(Z.getName(e)) >= 0;
        };
      }
      function V(y, t, e) {
        if (e === null) {
          if (y.length > 2 && t !== "scope")
            throw new Error("pseudo-selector :" + t + " requires an argument");
        } else if (y.length === 2)
          throw new Error("pseudo-selector :" + t + " doesn't have any arguments");
      }
      var W = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
      b.exports = {
        compile: function(y, t, e, Z) {
          var a = t.name, x = t.data, K = e.adapter;
          if (e && e.strict && !W.test(a))
            throw new Error(":" + a + " isn't part of CSS3");
          if (typeof o[a] == "function")
            return o[a](y, x, e, Z);
          if (typeof p[a] == "function") {
            var C = p[a];
            return V(C, a, x), C === n ? C : y === m ? function(I) {
              return C(I, K, x);
            } : function(I) {
              return C(I, K, x) && y(I);
            };
          } else
            throw new Error("unmatched pseudo-class :" + a);
        },
        filters: o,
        pseudos: p
      };
    },
    /* 283 */
    /***/
    function(b, d, l) {
      var i = l(284), s = l(285);
      b.exports = function(m) {
        return s(i(m));
      }, b.exports.parse = i, b.exports.compile = s;
    },
    /* 284 */
    /***/
    function(b, d) {
      b.exports = i;
      var l = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
      function i(s) {
        if (s = s.trim().toLowerCase(), s === "even")
          return [2, 0];
        if (s === "odd")
          return [2, 1];
        var c = s.match(l);
        if (!c)
          throw new SyntaxError("n-th rule couldn't be parsed ('" + s + "')");
        var m;
        return c[1] ? (m = parseInt(c[1], 10), isNaN(m) && (c[1].charAt(0) === "-" ? m = -1 : m = 1)) : m = 0, [
          m,
          c[3] ? parseInt((c[2] || "") + c[3], 10) : 0
        ];
      }
    },
    /* 285 */
    /***/
    function(b, d, l) {
      b.exports = m;
      var i = l(273), s = i.trueFunc, c = i.falseFunc;
      function m(n) {
        var X = n[0], G = n[1] - 1;
        if (G < 0 && X <= 0)
          return c;
        if (X === -1)
          return function(o) {
            return o <= G;
          };
        if (X === 0)
          return function(o) {
            return o === G;
          };
        if (X === 1)
          return G < 0 ? s : function(o) {
            return o >= G;
          };
        var L = G % X;
        return L < 0 && (L += X), X > 1 ? function(o) {
          return o >= G && o % X === L;
        } : (X *= -1, function(o) {
          return o <= G && o % X === L;
        });
      }
    },
    /* 286 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return x;
      });
      var i = l(12), s = l(74), c = l(1), m = l(68), n = l(250), X = l(213), G = l(218);
      l(1).glMatrix.setMatrixArrayType(Array);
      function L(K, C) {
        if (K == null)
          return {};
        var T = o(K, C), I, J;
        if (Object.getOwnPropertySymbols) {
          var F = Object.getOwnPropertySymbols(K);
          for (J = 0; J < F.length; J++)
            I = F[J], !(C.indexOf(I) >= 0) && Object.prototype.propertyIsEnumerable.call(K, I) && (T[I] = K[I]);
        }
        return T;
      }
      function o(K, C) {
        if (K == null)
          return {};
        var T = {}, I = Object.keys(K), J, F;
        for (F = 0; F < I.length; F++)
          J = I[F], !(C.indexOf(J) >= 0) && (T[J] = K[J]);
        return T;
      }
      const h = {
        antialias: !0,
        autoRender: !0,
        alpha: !0
        // for wx-miniprogram
      }, p = Symbol("autoRender"), r = Symbol("renderer"), V = Symbol("timeline"), W = Symbol("prepareRender"), y = Symbol("tickRender"), t = Symbol("pass"), e = Symbol("fbo"), Z = Symbol("tickers"), a = Symbol("layerTransformInvert");
      class x extends n.default {
        constructor(C = {}) {
          if (super(), !C.canvas) {
            const {
              width: F,
              height: R
            } = this.getResolution(), S = i.ENV.createCanvas(F, R, {
              offscreen: !!C.offscreen,
              id: C.id,
              extra: C.extra
            });
            S.style && (S.style.position = "absolute"), S.dataset && (S.dataset.layerId = C.id), S.contextType && (C.contextType = S.contextType), C.canvas = S;
          }
          const T = C.canvas, I = Object.assign({}, h, C);
          this[p] = I.autoRender, delete C.autoRender;
          const J = I.Renderer || i.Renderer;
          this[r] = new J(T, I), this.options = C, this.id = C.id, this[t] = [], this.setResolution(T), this.canvas = T, this[V] = new s.Timeline(), this.__mouseCapturedTarget = null, this[a] = null;
        }
        get autoRender() {
          return this[p];
        }
        get displayRatio() {
          return this.parent && this.parent.options ? this.parent.options.displayRatio : 1;
        }
        get height() {
          const {
            height: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get gl() {
          return this.renderer.glRenderer ? this.renderer.glRenderer.gl : null;
        }
        /* override */
        get layer() {
          return this;
        }
        get offscreen() {
          return !!this.options.offscreen || this.canvas._offscreen;
        }
        get pass() {
          return this[t];
        }
        get prepareRender() {
          return this[W] ? this[W] : Promise.resolve();
        }
        /* override */
        get renderer() {
          return this[r];
        }
        get renderOffset() {
          if (this.parent && this.parent.options) {
            const {
              left: C,
              top: T
            } = this.parent.options;
            return [C, T];
          }
          return [this.options.left | 0, this.options.top | 0];
        }
        get timeline() {
          return this[V];
        }
        get width() {
          const {
            width: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get localMatrix() {
          const {
            x: C,
            y: T
          } = this.attributes;
          return [1, 0, 0, 1, C, T];
        }
        get layerTransformInvert() {
          if (this[a])
            return this[a];
          const C = this.transformMatrix;
          return C[0] === 1 && C[1] === 0 && C[2] === 0 && C[3] === 1 && C[4] === 0 && C[5] === 0 ? null : (this[a] = c.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C), this[a]);
        }
        forceContextLoss() {
          const C = this.renderer.glRenderer;
          if (C) {
            const T = C.getExtension("WEBGL_lose_context");
            if (T)
              return T.loseContext(), !0;
          }
          return !1;
        }
        // isPointCollision(x, y) {
        //   return true;
        // }
        addPass({
          vertex: C,
          fragment: T,
          options: I,
          uniforms: J
        } = {}) {
          if (this.renderer.glRenderer) {
            const {
              width: F,
              height: R
            } = this.getResolution(), S = this.renderer.createPassProgram({
              vertex: C,
              fragment: T,
              options: I
            }), N = new i.Figure2D();
            N.rect(0, 0, F / this.displayRatio, R / this.displayRatio);
            const Q = new i.Mesh2D(N);
            return Q.setUniforms(J), Q.setProgram(S), this[t].push(Q), this.forceUpdate(), Q;
          }
          return null;
        }
        // delete unused texture to release memory.
        deleteTexture(C) {
          return Object(G.deleteTexture)(C, this.renderer);
        }
        /* override */
        dispatchPointerEvent(C) {
          const T = C.type;
          if (T === "mousedown" || T === "mouseup" || T === "mousemove") {
            const S = this.__mouseCapturedTarget;
            if (S) {
              if (S.layer === this)
                return S.dispatchEvent(C), !0;
              this.__mouseCapturedTarget = null;
            }
          }
          let I, J;
          const F = this.layerTransformInvert;
          if (F) {
            I = C.x, J = C.y;
            const S = F, N = S[0] * I + S[2] * J + S[4], Q = S[1] * I + S[3] * J + S[5];
            delete C.x, delete C.y, delete C.layerX, delete C.layerY, Object.defineProperties(C, {
              layerX: {
                value: N,
                configurable: !0
              },
              layerY: {
                value: Q,
                configurable: !0
              },
              x: {
                value: N,
                configurable: !0
              },
              y: {
                value: Q,
                configurable: !0
              }
            });
          }
          const R = super.dispatchPointerEvent(C);
          return F && Object.defineProperties(C, {
            layerX: {
              value: I,
              configurable: !0
            },
            layerY: {
              value: J,
              configurable: !0
            },
            x: {
              value: I,
              configurable: !0
            },
            y: {
              value: J,
              configurable: !0
            }
          }), R;
        }
        /* override */
        forceUpdate() {
          if (!this[W])
            if (this.parent && this.parent.hasOffscreenCanvas) {
              this.parent.forceUpdate();
              let C = null;
              const T = new Promise((I) => {
                C = I;
              });
              T._resolve = C, this[W] = T;
            } else {
              let C = null, T = null;
              const I = new Promise((J) => {
                C = J, this[p] && (T = Object(m.requestAnimationFrame)(() => {
                  delete I._requestID, this.render();
                }));
              });
              I._resolve = C, I._requestID = T, this[W] = I;
            }
        }
        getFBO() {
          const C = this.renderer.glRenderer, {
            width: T,
            height: I
          } = this.getResolution();
          return C && (!this[e] || this[e].width !== T || this[e].height !== I) ? (this[e] = {
            width: T,
            height: I,
            target: C.createFBO(),
            buffer: C.createFBO(),
            swap() {
              [this.target, this.buffer] = [this.buffer, this.target];
            }
          }, this[e]) : this[e] ? this[e] : null;
        }
        updateGlobalTransform() {
          if (this.layerTransformInvert) {
            const C = this.renderer, T = C.__globalTransformMatrix || C.globalTransformMatrix;
            C.__globalTransformMatrix = T;
            const I = c.mat2d.fromValues(1, 0, 0, 1, 0, 0);
            C.setGlobalTransform(...c.mat2d.multiply(I, T, this.transformMatrix));
          }
        }
        /* override */
        onPropertyChange(C, T, I) {
          if (super.onPropertyChange(C, T, I), C === "zIndex" && (this.canvas.style.zIndex = T), C === "transform" || C === "translate" || C === "rotate" || C === "scale" || C === "skew") {
            const J = this[a];
            if (this[a] = null, this.updateGlobalTransform(), J && !this.layerTransformInvert) {
              const F = this.renderer, R = F.__globalTransformMatrix || F.globalTransformMatrix;
              F.setGlobalTransform(...R);
            }
          }
        }
        _prepareRenderFinished() {
          this[W] && (this[W]._requestID && Object(m.cancelAnimationFrame)(this[W]._requestID), this[W]._resolve(), delete this[W]);
        }
        render({
          clear: C = !0
        } = {}) {
          const T = this[t].length ? this.getFBO() : null;
          T && this.renderer.glRenderer.bindFBO(T.target), C && this[r].clear();
          const I = this.draw();
          if (I && I.length && (this.renderer.drawMeshes(I), this.canvas.draw && this.canvas.draw()), T) {
            const J = this.renderer.glRenderer, F = this[t].length, {
              width: R,
              height: S
            } = this.getResolution(), N = [0, 0, R / this.displayRatio, S / this.displayRatio];
            this[t].forEach((Q, P) => {
              Q.blend = !0, Q.setTexture(T.target.texture, {
                rect: N
              }), P === F - 1 ? J.bindFBO(null) : (T.swap(), J.bindFBO(T.target)), this[r].clear(), this.renderer.drawMeshes([Q]);
            });
          }
          this._prepareRenderFinished();
        }
        /* override */
        setResolution({
          width: C,
          height: T
        }) {
          const I = this.renderer, J = I.__globalTransformMatrix || I.globalTransformMatrix, F = J[4], R = J[5], S = J[0], {
            width: N,
            height: Q
          } = this.getResolution();
          (N !== C || Q !== T) && (super.setResolution({
            width: C,
            height: T
          }), this.canvas && (this.canvas.width = C, this.canvas.height = T, I.updateResolution && I.updateResolution()), this.attributes.size = [C, T], this[t].length && this[t].forEach((z) => {
            const w = new i.Figure2D();
            w.rect(0, 0, C / this.displayRatio, T / this.displayRatio), z.contours = w.contours;
          }));
          const [P, j] = this.renderOffset, D = this.displayRatio;
          (F !== P || R !== j || S !== D) && (I.setGlobalTransform(D, 0, 0, D, P, j), I.__globalTransformMatrix = null, this[a] = null, this.updateGlobalTransform(), this.forceUpdate());
        }
        /**
         * tick(handler, {originTime = 0, playbackRate = 1.0, duration = Infinity})
         * @param {*} handler
         * @param {*} options
         */
        tick(C = null, T = {}) {
          let {
            duration: I = 1 / 0
          } = T, J = L(T, ["duration"]);
          const F = this.timeline.fork(J), R = this;
          this[Z] = this[Z] || [], this[Z].push({
            handler: C,
            duration: I
          });
          const S = () => {
            let N = null, Q = null;
            const P = () => {
              const j = this[Z].map(({
                handler: D,
                duration: z
              }) => {
                const w = Math.min(1, F.currentTime / z);
                return {
                  value: D ? D(F.currentTime, w) : null,
                  p: w
                };
              });
              R[y] || (R[y] = Promise.resolve().then(() => {
                R[p] && R.render(), delete R[y];
                for (let D = j.length - 1; D >= 0; D--) {
                  const {
                    value: z,
                    p: w
                  } = j[D];
                  (z === !1 || w >= 1) && this[Z].splice(D, 1);
                }
                this[Z].length > 0 && S();
              }));
            };
            if (this[W] && this[W]._type !== "ticker" && (Object(m.cancelAnimationFrame)(this[W]._requestID), delete this[W]), !this[W]) {
              const j = new Promise((D) => {
                N = D, Q = Object(m.requestAnimationFrame)(P);
              });
              j._resolve = N, j._requestID = Q, j._type = "ticker", this[W] = j;
            }
          };
          S();
        }
        toGlobalPos(C, T) {
          if (this.layerTransformInvert) {
            const N = this.transformMatrix;
            C = N[0] * C + N[2] * T + N[4], T = N[1] * C + N[3] * T + N[5];
          }
          const {
            width: I,
            height: J
          } = this.getResolution(), F = this.renderOffset, R = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * R[0] / I + F[0], T = T * R[1] / J + F[1];
          const S = this.displayRatio;
          return C *= S, T *= S, [C, T];
        }
        toLocalPos(C, T) {
          const {
            width: I,
            height: J
          } = this.getResolution(), F = this.renderOffset, R = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * I / R[0] - F[0], T = T * J / R[1] - F[1];
          const S = this.displayRatio;
          C /= S, T /= S;
          const N = this.layerTransformInvert;
          return N && (C = N[0] * C + N[2] * T + N[4], T = N[1] * C + N[3] * T + N[5]), [C, T];
        }
      }
      X.default.registerNode(x, "layer");
    },
    /* 287 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return W;
      });
      var i = l(224), s = l(288), c = l(213), m = l(252), n = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      function X(y, t) {
        if (y == null)
          return {};
        var e = G(y, t), Z, a;
        if (Object.getOwnPropertySymbols) {
          var x = Object.getOwnPropertySymbols(y);
          for (a = 0; a < x.length; a++)
            Z = x[a], !(t.indexOf(Z) >= 0) && Object.prototype.propertyIsEnumerable.call(y, Z) && (e[Z] = y[Z]);
        }
        return e;
      }
      function G(y, t) {
        if (y == null)
          return {};
        var e = {}, Z = Object.keys(y), a, x;
        for (x = 0; x < Z.length; x++)
          a = Z[x], !(t.indexOf(a) >= 0) && (e[a] = y[a]);
        return e;
      }
      function L(y, t, e) {
        return t in y ? Object.defineProperty(y, t, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : y[t] = e, y;
      }
      const o = "http://www.w3.org/2000/svg", h = Symbol.for("spritejs_setAttribute"), p = Symbol("root"), r = Symbol("task");
      function V(y, t = !0) {
        const e = y[p];
        if (e && e.children[0]) {
          const Z = y.svg, a = y.layer ? y.layer.displayRatio : 1;
          if (!Z.hasAttribute("data-original-width")) {
            let C = Z.getAttribute("width");
            C = C ? Object(n.sizeToPixel)(C) : 300;
            let T = Z.getAttribute("height");
            T = T ? Object(n.sizeToPixel)(T) : 150, Z.hasAttribute("viewBox") || Z.setAttribute("viewBox", `0 0 ${Math.round(C)} ${Math.round(T)}`), Z.setAttribute("data-original-width", C), Z.setAttribute("data-original-height", T);
          }
          let x = y.attributes.width || Number(Z.getAttribute("data-original-width")), K = y.attributes.height || Number(Z.getAttribute("data-original-height"));
          if (x *= a, K *= a, t && y.attributes.flexible) {
            const C = y.attributes.scale[0];
            if (x *= C, K *= C, Z.setAttribute("width", x), Z.setAttribute("height", K), x && K && y.textureImage) {
              const T = y.textureImage.width, I = y.textureImage.height, J = y.clientSize;
              y.attributes.textureRect = [0, 0, Math.round(J[0] * T / x), Math.round(J[1] * I / K)];
            }
          } else
            y[r] || (Z.setAttribute("width", x), Z.setAttribute("height", K), y[r] = Promise.resolve().then(() => {
              delete y[r];
              const C = e.innerHTML, T = new Blob([C], {
                type: "image/svg+xml"
              }), I = URL.createObjectURL(T), J = new Image();
              J.onload = function() {
                J.width && J.height ? (y.attributes[h]("texture", J), y.attributes.flexible && (y.attributes.textureRect = null)) : y.attributes[h]("texture", null);
              }, J.src = I;
            }));
        }
      }
      class W extends i.default {
        constructor(t = {}) {
          typeof t == "string" && (t = {
            svgText: t
          });
          let {
            svgText: e
          } = t, Z = X(t, ["svgText"]);
          if (super(Z), this[p] = document.createElement("div"), e) {
            this[p].innerHTML = e;
            const a = this[p].children[0];
            a ? a.setAttribute("xmlns", o) : (fetch(e).then((x) => x.text()).then((x) => {
              this[p].innerHTML = x, (!this.observer || this.attributes.flexible) && V(this);
            }), e = null);
          }
          if (!e) {
            const a = document.createElementNS(o, "svg");
            a.setAttribute("xmlns", o), this[p].appendChild(a);
          }
          if (typeof MutationObserver == "function") {
            const a = new MutationObserver((x) => {
              V(this, !1);
            });
            a.observe(this[p], {
              attributes: !0,
              subtree: !0,
              characterData: !0,
              childList: !0
            }), this.observer = a;
          }
        }
        get children() {
          return [this.svg];
        }
        get childNodes() {
          return [this.svg];
        }
        get svg() {
          return this[p] ? this[p].children[0] : null;
        }
        /* override */
        setResolution({
          width: t,
          height: e
        }) {
          super.setResolution({
            width: t,
            height: e
          }), V(this);
        }
        /* override */
        dispatchPointerEvent(t) {
          const e = super.dispatchPointerEvent(t);
          if (e && this.attributes.passEvents && typeof MouseEvent == "function") {
            const {
              x: Z,
              y: a
            } = t;
            let [x, K] = this.getOffsetPosition(Z, a);
            const C = t.originalEvent, T = this.attributes.anchor, I = this.clientSize;
            x = (x + T[0] * I[0]) / 2, K = (K + T[1] * I[1]) / 2;
            const J = t.type;
            if (J === C.type) {
              let F = null;
              if (C instanceof MouseEvent)
                F = new MouseEvent(J, {
                  screenX: x,
                  screenY: K,
                  clientX: x,
                  clientY: K,
                  bubbles: C.bubbles,
                  button: C.button,
                  buttons: C.buttons,
                  cancelBubble: C.cancelBubble,
                  cancelable: C.cancelable,
                  currentTarget: C.currentTarget,
                  fromElement: C.fromElement,
                  relatedTarget: C.relatedTarget,
                  returnValue: C.returnValue,
                  srcElement: C.srcElement,
                  target: C.target,
                  toElement: C.toElement,
                  // view: originalEvent.view,
                  which: C.witch
                });
              else if (C instanceof TouchEvent) {
                let R = null;
                const S = C.changedTouches || [C];
                for (let N = 0; N < S.length; N++) {
                  const Q = S[N];
                  if (t.identifier === Q.identifier) {
                    R = Q;
                    break;
                  }
                }
                if (R) {
                  const N = new Touch({
                    identifier: R.identifier,
                    target: R.target,
                    clientX: x,
                    clientY: K,
                    screenX: x,
                    screenY: K,
                    pageX: x,
                    pageY: K,
                    radiusX: R.radiusX,
                    radiusY: R.radiusY,
                    rotationAngle: R.rotationAngle,
                    force: R.force
                  });
                  F = new TouchEvent(J, {
                    cancelable: C.cancelable,
                    bubbles: C.bubbles,
                    composed: C.composed,
                    touches: [N],
                    targetTouches: [N],
                    changedTouches: [N]
                  });
                }
              } else
                F = C;
              F && this.svg.dispatchEvent(F);
            }
          }
          return e;
        }
        getElementById(t) {
          return Object(m.querySelector)(`#${t}`, this);
        }
        getElementsByClassName(t) {
          return Object(m.querySelectorAll)(`.${t}`, this);
        }
        getElementsByName(t) {
          return Object(m.querySelectorAll)(`[name="${t}"]`, this);
        }
        getElementsByTagName(t) {
          return Object(m.querySelectorAll)(t, this);
        }
        querySelector(t) {
          return Object(m.querySelector)(t, this);
        }
        querySelectorAll(t) {
          return Object(m.querySelectorAll)(t, this);
        }
        /* override */
        onPropertyChange(t, e, Z) {
          super.onPropertyChange(t, e, Z), t === "flexible" && V(this), this.attributes.flexible && (t === "width" || t === "height" || t === "scale" || t === "transform") && V(this);
        }
      }
      L(W, "Attr", s.default), c.default.registerNode(W, "spritesvg");
    },
    /* 288 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(225);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol.for("spritejs_getAttribute"), c = Symbol.for("spritejs_setAttribute"), m = Symbol.for("spritejs_setAttributeDefault");
      class n extends i.default {
        constructor(G) {
          super(G), this[m]({
            passEvents: !1,
            flexible: !1
          });
        }
        // readonly
        get texture() {
          return this[s]("texture");
        }
        set texture(G) {
        }
        // eslint-disable-line no-empty-function
        get passEvents() {
          return this[s]("passEvents");
        }
        set passEvents(G) {
          return this[c]("passEvents", G);
        }
        get flexible() {
          return this[s]("flexible");
        }
        set flexible(G) {
          return this[c]("flexible", G);
        }
      }
    },
    /* 289 */
    /***/
    function(b, d, l) {
      l.r(d);
      var i = l(12);
      l(1).glMatrix.setMatrixArrayType(Array);
      function s(G, L) {
        var o = Object.keys(G);
        if (Object.getOwnPropertySymbols) {
          var h = Object.getOwnPropertySymbols(G);
          L && (h = h.filter(function(p) {
            return Object.getOwnPropertyDescriptor(G, p).enumerable;
          })), o.push.apply(o, h);
        }
        return o;
      }
      function c(G) {
        for (var L = 1; L < arguments.length; L++) {
          var o = arguments[L] != null ? arguments[L] : {};
          L % 2 ? s(Object(o), !0).forEach(function(h) {
            m(G, h, o[h]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(G, Object.getOwnPropertyDescriptors(o)) : s(Object(o)).forEach(function(h) {
            Object.defineProperty(G, h, Object.getOwnPropertyDescriptor(o, h));
          });
        }
        return G;
      }
      function m(G, L, o) {
        return L in G ? Object.defineProperty(G, L, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : G[L] = o, G;
      }
      const n = Symbol("inited");
      let X = null;
      typeof Worker == "function" && (X = class extends Worker {
        constructor(G) {
          if (G.worker === !0 && (G.worker = `./${G.id}.worker.js`), super(G.worker), this.options = G, !G.canvas) {
            const {
              width: L,
              height: o
            } = this.getResolution(), h = i.ENV.createCanvas(L, o, {
              offscreen: !1
            });
            h.style && (h.style.position = "absolute"), h.dataset && (h.dataset.layerId = G.id), G.canvas = h;
          }
          this.canvas = G.canvas;
        }
        get id() {
          return this.options.id;
        }
        setResolution({
          width: G,
          height: L
        }) {
          if (this[n])
            this.postMessage({
              type: "resolution_change",
              width: G,
              height: L
            });
          else {
            this.canvas.width = G, this.canvas.height = L;
            const o = this.options, h = o.canvas.transferControlToOffscreen(), p = c({}, o);
            delete p.container, p.canvas = h, this.postMessage({
              type: "create",
              options: p
            }, [h]), this[n] = !0;
          }
        }
        getResolution() {
          if (this.canvas) {
            const {
              width: G,
              height: L
            } = this.canvas;
            return {
              width: G,
              height: L
            };
          }
          return {
            width: 300,
            height: 150
          };
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        connect(G, L) {
          Object.defineProperty(this, "parent", {
            value: G,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: L,
            writable: !1,
            configurable: !0
          });
        }
        disconnect() {
          delete this.parent, delete this.zOrder;
        }
        dispatchPointerEvent(G) {
          this.postMessage({
            type: "event",
            event: {
              cancelBubble: G.cancelBubble,
              bubbles: G.bubbles,
              detail: G.detail,
              identifier: G.identifier,
              layerX: G.layerX,
              layerY: G.layerY,
              originalX: G.originalX,
              originalY: G.originalY,
              type: G.type,
              x: G.x,
              y: G.y
            }
          });
        }
      }), d.default = X;
    },
    /* 290 */
    /***/
    function(b, d, l) {
      l.r(d), (function(i) {
        l.d(d, "default", function() {
          return x;
        });
        var s = l(12), c = l(68), m = l(70), n = l(286), X = l(289), G = l(250), L = l(291), o = l(214), h = l(218), p = l(213);
        l(1).glMatrix.setMatrixArrayType(Array);
        const r = Symbol("enteredTargets");
        function V(K) {
          return K.id = K.id || `_layer${Math.random().toString(36).slice(2, 12)}`, K.dataset || (K.dataset = {}), K.dataset.layerId = K.id, K.connect = (C, T) => {
            K.parent = C, Object.defineProperty(K, "zOrder", {
              value: T,
              writable: !1,
              configurable: !0
            });
          }, K.disconnect = (C) => {
            delete K.zOrder;
          }, K.canvas = K, K.getResolution = () => ({
            width: 0,
            height: 0
          }), K.setResolution = () => !1, K.options = {
            handleEvent: !1
          }, K;
        }
        function W(K, C) {
          const T = K.children;
          let I = null;
          for (let J = 0; J < T.length; J++) {
            const F = T[J];
            if ((C === F || I != null) && (I = F), I && I !== C && !I.offscreen)
              return I.canvas;
          }
          return null;
        }
        function y(K, C) {
          const [T, I] = K.renderOffset, {
            width: J,
            height: F
          } = K.getResolution(), R = K.displayRatio;
          K.renderer.drawImage(C.canvas, -T / R, -I / R, J / R, F / R);
        }
        const t = {};
        function e(K) {
          const C = ["mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "touchstart", "touchend", "touchmove", "touchcancel", "click", "dblclick", "longpress", "tap", "contextmenu"], T = K.container;
          T.addEventListener("mouseleave", (I) => {
            const J = K[r];
            if (J.size) {
              const F = new o.default("mouseleave");
              F.setOriginalEvent(I), [...J].forEach((R) => {
                R.dispatchEvent(F);
              }), K[r].clear();
            }
          }, {
            passive: !0
          }), C.forEach((I) => {
            T.addEventListener(I, (J) => {
              const {
                left: F,
                top: R,
                displayRatio: S
              } = K.options, N = K.orderedChildren;
              Object(L.default)(J, {
                offsetLeft: F,
                offsetTop: R,
                displayRatio: S
              }).forEach((P) => {
                const j = P.identifier;
                if (P.type === "touchmove" || P.type === "touchend") {
                  const z = t[j];
                  z && z.dispatchEvent(P), P.type === "touchend" && delete t[j];
                } else {
                  for (let z = N.length - 1; z >= 0; z--) {
                    const w = N[z];
                    if (w.options.handleEvent !== !1) {
                      if (w.dispatchPointerEvent(P) && P.target !== w)
                        break;
                      P.cancelBubble = !1;
                    }
                  }
                  if (P.target === N[0])
                    for (let z = N.length - 1; z >= 0; z--) {
                      const w = N[z];
                      if (w.options.handleEvent !== !1) {
                        P.target = w;
                        break;
                      }
                    }
                }
                const D = P.target;
                if (P.type === "touchstart" && (t[j] = P.target), P.type === "mousemove") {
                  const z = K[r];
                  let w;
                  if (D) {
                    const _ = D.ancestors || [];
                    w = /* @__PURE__ */ new Set([D, ..._]);
                  } else
                    w = /* @__PURE__ */ new Set();
                  const A = Object.entries(J);
                  if (!z.has(D) && D) {
                    const _ = new o.default("mouseenter");
                    _.setOriginalEvent(J), A.forEach(([$, al]) => {
                      _[$] = al;
                    }), z.add(D), D.dispatchEvent(_);
                    const cl = D.ancestors;
                    cl && cl.forEach(($) => {
                      $ instanceof m.default && !z.has($) && (z.add($), $.dispatchEvent(_));
                    });
                  }
                  const ll = new o.default("mouseleave");
                  ll.setOriginalEvent(J), A.forEach(([_, cl]) => {
                    ll[_] = cl;
                  }), [...z].forEach((_) => {
                    w.has(_) || (z.delete(_), _.dispatchEvent(ll));
                  });
                }
              });
            }, {
              passive: I !== "contextmenu"
            });
          });
        }
        function Z(K, C) {
          if (C && C.style) {
            let {
              width: T,
              height: I,
              mode: J,
              container: F
            } = K;
            const {
              clientWidth: R,
              clientHeight: S
            } = F;
            T = T || R, I = I || S, J === "static" ? (C.style.width = `${T}px`, C.style.height = `${I}px`) : (C.style.top = "0", C.style.left = "0", C.style.width = `${R}px`, C.style.height = `${S}px`, C.style.transform = "", C.style.webkitTransform = "");
          }
        }
        const a = Symbol("offscreenLayerCount");
        class x extends G.default {
          /**
            width
            height
            mode: 'static', 'scale', 'stickyWidth', 'stickyHeight', 'stickyTop', 'stickyBottom', 'stickyLeft', 'stickyRight'
           */
          constructor(C = {}) {
            if (super(), !C.container)
              if (typeof s.ENV.Container == "function")
                C.container = new s.ENV.Container(C.width || 300, C.height || 150);
              else
                throw new Error("No container specified.");
            if (this.container = C.container, this.container.style && (this.container.style.overflow || (this.container.style.overflow = "hidden"), this.container.style.position || (this.container.style.position = "relative")), this.options = C, C.displayRatio = C.displayRatio || 1, C.mode = C.mode || "scale", C.left = 0, C.top = 0, C.autoResize = C.autoResize !== !1, C.autoResize) {
              let T;
              if (typeof globalThis < "u" ? T = globalThis : T = typeof window < "u" ? window : i, T.addEventListener) {
                const I = this;
                T.addEventListener("resize", function J() {
                  typeof document < "u" && document.contains(I.container) ? I.resize() : T.removeEventListener("resize", J);
                });
              }
            }
            this[r] = /* @__PURE__ */ new Set(), this.setResolution(C), e(this), this[a] = 0;
          }
          get hasOffscreenCanvas() {
            return this[a] > 0;
          }
          set displayRatio(C) {
            this.options.displayRatio !== C && (this.options.displayRatio = C, this.resize());
          }
          get displayRatio() {
            return this.options.displayRatio;
          }
          set height(C) {
            this.options.height !== C && (this.options.height = C, this.resize());
          }
          get height() {
            return this.options.height;
          }
          set mode(C) {
            this.options.mode !== C && (this.options.mode = C, this.resize());
          }
          get mode() {
            return this.options.mode;
          }
          set width(C) {
            this.options.width !== C && (this.options.width = C, this.resize());
          }
          get width() {
            return this.options.width;
          }
          /* override */
          appendChild(C) {
            !(C instanceof n.default) && !(C instanceof X.default) && V(C);
            const T = super.appendChild(C), I = C.canvas;
            return C.offscreen ? this[a]++ : this.container.appendChild(I), Z(this.options, I), C.setResolution(this.getResolution()), T;
          }
          /* override */
          forceUpdate() {
            this.hasOffscreenCanvas && !this._requestID && (this._requestID = Object(c.requestAnimationFrame)(() => {
              delete this._requestID, this.render();
            }));
          }
          /* override */
          insertBefore(C, T) {
            !(C instanceof n.default) && !(C instanceof X.default) && V(C);
            const I = super.insertBefore(C, T), J = C.canvas;
            if (!C.offscreen) {
              const F = W(this, C);
              this.container.insertBefore(J, F);
            }
            return Z(this.options, J), C.setResolution(this.getResolution()), I;
          }
          layer(C = "default", T = {}) {
            T = Object.assign({}, this.options, T), T.id = C;
            const I = this.orderedChildren;
            for (let R = 0; R < I.length; R++)
              if (I[R].id === C)
                return I[R];
            const J = T.worker;
            let F;
            return J ? F = new X.default(T) : F = new n.default(T), this.appendChild(F), F;
          }
          async preload(...C) {
            const T = [], I = [], J = [];
            for (let F = 0; F < C.length; F++) {
              const R = C[F];
              let S;
              if (typeof R == "string")
                S = Object(h.loadTexture)(R);
              else if (Array.isArray(R))
                S = Object(h.loadFrames)(...R);
              else {
                const {
                  id: N,
                  src: Q
                } = R;
                S = Object(h.loadTexture)(Q, N);
              }
              S instanceof Promise || (S = Promise.resolve(S)), I.push(S.then((N) => {
                T.push(N), J[F] = N;
                const Q = new o.default({
                  type: "preload",
                  detail: {
                    current: N,
                    loaded: T,
                    resources: C
                  }
                });
                this.dispatchEvent(Q);
              }));
            }
            return await Promise.all(I), J;
          }
          /* override */
          removeChild(C) {
            const T = super.removeChild(C);
            if (T) {
              C._prepareRenderFinished && C._prepareRenderFinished();
              const I = C.canvas;
              I && I.remove && I.remove(), C.offscreen && this[a]--;
            }
            return T;
          }
          // for offscreen mode rendering
          render() {
            const C = this.orderedChildren;
            let T = null;
            const I = [];
            for (let J = 0; J < C.length; J++) {
              const F = C[J], R = I.length > 0;
              if (F instanceof n.default && !F.offscreen)
                if (!F.autoRender)
                  R && (console.warn("Some offscreen canvas will not be rendered."), I.length = 0);
                else if (T = F, R) {
                  F.renderer.clear();
                  for (let S = 0; S < I.length; S++) {
                    const N = I[S];
                    N.render(), y(F, N);
                  }
                  I.length = 0, F.render({
                    clear: !1
                  });
                } else
                  F.prepareRender && F.render();
              else
                F.offscreen ? T ? (F.prepareRender && F.render(), y(T, F)) : I.push(F) : F instanceof X.default && R && (console.warn("Some offscreen canvas will not be rendered."), I.length = 0);
            }
          }
          /* override */
          replaceChild(C, T) {
            const I = super.replaceChild(C, T);
            T.canvas.remove && T.canvas.remove(), T.offscreen && this[a]--;
            const J = C.canvas;
            if (!C.offscreen) {
              const F = W(this, C);
              this.container.insertBefore(J, F);
            }
            return Z(this.options, J), C.setResolution(this.getResolution()), I;
          }
          resize() {
            const C = this.options;
            this.children.forEach((T) => {
              Z(C, T.canvas);
            }), this.setResolution(C), this.dispatchEvent({
              type: "resize"
            });
          }
          /* override */
          setResolution({
            width: C,
            height: T
          } = {}) {
            const I = this.container, {
              clientWidth: J,
              clientHeight: F
            } = I;
            (C == null || T == null) && (C = C ?? J, T = T ?? F);
            const {
              mode: R,
              displayRatio: S
            } = this.options;
            if (C *= S, T *= S, this.options.left = 0, this.options.top = 0, R === "stickyHeight" || R === "stickyLeft" || R === "stickyRight") {
              const N = C;
              C = J * T / F, R === "stickyHeight" && (this.options.left = 0.5 * (C - N)), R === "stickyRight" && (this.options.left = C - N);
            } else if (R === "stickyWidth" || R === "stickyTop" || R === "stickyBottom") {
              const N = T;
              T = F * C / J, R === "stickyWidth" && (this.options.top = 0.5 * (T - N)), R === "stickyBottom" && (this.options.top = T - N);
            }
            super.setResolution({
              width: C,
              height: T
            });
          }
          snapshot({
            offscreen: C = !1,
            layers: T
          } = {}) {
            const I = C ? "snapshotOffScreenCanvas" : "snapshotCanvas", {
              width: J,
              height: F
            } = this.getResolution();
            this[I] = this[I] || s.ENV.createCanvas(J, F, {
              offscreen: C
            });
            const R = this[I].getContext("2d");
            T = T || this.orderedChildren, this[I].width = J, this[I].height = F;
            for (let S = 0; S < T.length; S++) {
              const N = T[S];
              if (!N.options.ignoreSnapshot) {
                N.render && N.render();
                const Q = N.canvas;
                Q && Q !== N && R.drawImage(Q, 0, 0, J, F);
              }
            }
            return this[I];
          }
        }
        typeof document < "u" && (x.prototype.layer3d = function(K, C = {}) {
          const T = C.url || "https://unpkg.com/sprite-extend-3d/dist/sprite-extend-3d.min.js";
          return new Promise((I, J) => {
            const F = document.createElement("script");
            F.async = !1, F.src = T, F.onload = () => {
              try {
                I(this.layer3d(K, C));
              } catch (R) {
                J(R);
              }
            }, document.documentElement.appendChild(F);
          });
        }), p.default.registerNode(x, "scene");
      }).call(this, l(22));
    },
    /* 291 */
    /***/
    function(b, d, l) {
      l.r(d), l.d(d, "default", function() {
        return s;
      });
      var i = l(214);
      l(1).glMatrix.setMatrixArrayType(Array);
      function s(c, {
        offsetTop: m = 0,
        offsetLeft: n = 0,
        displayRatio: X = 1
      } = {}) {
        let G, L;
        const o = [], {
          left: h,
          top: p,
          width: r,
          height: V
        } = c.target.getBoundingClientRect(), W = c.target.width, y = c.target.height, t = c.changedTouches || [c];
        for (let Z = 0; Z < t.length; Z++) {
          const a = t[Z], x = a.identifier, {
            clientX: K,
            clientY: C
          } = a;
          K != null && C != null && o.push({
            x: Math.round((K | 0) - h),
            y: Math.round((C | 0) - p),
            identifier: x
          });
        }
        o.length <= 0 && o.push({
          x: G,
          y: L
        });
        const e = [];
        return o.forEach((Z) => {
          Z.x != null && Z.y != null && (G = (Z.x * W / r - n) / X, L = (Z.y * y / V - m) / X);
          const a = new i.default(c);
          Object.defineProperties(a, {
            layerX: {
              value: G,
              configurable: !0
            },
            layerY: {
              value: L,
              configurable: !0
            },
            originalX: {
              value: Z.x
            },
            originalY: {
              value: Z.y
            },
            x: {
              value: G,
              configurable: !0
            },
            y: {
              value: L,
              configurable: !0
            },
            identifier: {
              value: Z.identifier
            }
          }), e.push(a);
        }), e;
      }
    }
    /******/
  ])
);
Fl.version;
Fl.Arc;
Fl.Block;
Fl.Cloud;
Fl.Color;
Fl.Ellipse;
Fl.Gradient;
Fl.Group;
Fl.Label;
Fl.Layer;
Fl.LayerWorker;
Fl.Node;
Fl.Parallel;
Fl.Path;
Fl.Polyline;
Fl.Rect;
Fl.Regular;
Fl.Ring;
Fl.Scene;
Fl.Sprite;
Fl.SpriteSvg;
Fl.Star;
Fl.Triangle;
Fl.helpers;
Fl.createElement;
Fl.isSpriteNode;
Fl.registerNode;
Fl.requestAnimationFrame;
Fl.cancelAnimationFrame;
Fl.ENV;
var oo = Jd, Go = Ld, Wo = "[object Boolean]";
function uo(b) {
  return b === !0 || b === !1 || Go(b) && oo(b) == Wo;
}
var ho = uo;
const Fd = /* @__PURE__ */ Cd(ho);
function Vo(b, d) {
  if (b && d) {
    const l = Math.min(b.originX, d.originX), i = Math.min(b.originY, d.originY), s = Math.max(b.originX + b.width, d.originX + d.width), c = Math.max(b.originY + b.height, d.originY + d.height), m = s - l, n = c - i;
    return { originX: l, originY: i, width: m, height: n };
  }
  return d || b;
}
const Hd = (b, d) => new Promise(function(l) {
  window.requestIdleCallback ? requestIdleCallback(() => {
    l(1);
  }, { timeout: d }) : setTimeout(() => {
    l(2);
  }, d);
}).then(function() {
  b();
}, () => {
  b();
}), gi = (b) => {
  const d = b.webkitBackingStorePixelRatio || b.mozBackingStorePixelRatio || b.msBackingStorePixelRatio || b.oBackingStorePixelRatio || b.backingStorePixelRatio || 1;
  return Math.max(1, (window.devicePixelRatio || 1) / d);
};
class pd extends Us {
  constructor(d, l) {
    super(d), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serviceStorage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncClockState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), pd.syncInterval = (l || pd.syncInterval) * 0.5, this.namespace = pd.namespace, this.serviceStorage = this.getNamespaceData(), this.storage = Al(this.serviceStorage);
  }
  getViewIdBySecenPath(d) {
    const l = this.getNamespaceData();
    for (const [i, s] of Object.entries(l))
      for (const c of Object.keys(s))
        if (c === d)
          return i;
  }
  getScenePathData(d) {
    const l = this.getNamespaceData();
    for (const i of Object.values(l))
      for (const s of Object.keys(i))
        if (s === d)
          return Al(i[s]);
  }
  getStorageData(d, l) {
    const i = this.getNamespaceData();
    return i[d] && Al(i[d][l]) || void 0;
  }
  hasSelector(d, l) {
    const i = this.storage && this.storage[d] && this.storage[d][l];
    return !!(i && Object.keys(i).find((s) => this.isOwn(s) && this.getLocalId(s) === Il));
  }
  addStorageStateListener(d) {
    this.stateDisposer = ks(async () => {
      const l = this.getNamespaceData(), i = this.diffFun(this.serviceStorage, l);
      this.serviceStorage = l;
      for (const [s, c] of Object.entries(i))
        if (c && c.newValue === void 0) {
          const { viewId: m, scenePath: n } = c;
          m && n && this.storage[m] && delete this.storage[m][n][s];
        } else if (c && c.newValue) {
          const { viewId: m, scenePath: n } = c;
          this.storage[m] || (this.storage[m] = {}), this.storage[m][n] || (this.storage[m][n] = {}), this.storage[m][n][s] = Al(c.newValue);
        }
      Object.keys(i).length > 0 && d(i);
    });
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  diffFun(d, l) {
    const i = sd(d), s = sd(l), c = {};
    for (const m of i) {
      if (ld(d[m], l[m]))
        continue;
      const n = this.diffFunByscenePath(d[m] || {}, l[m] || {}, m);
      Object.assign(c, n);
    }
    for (const m of s)
      if (!i.includes(m)) {
        const n = this.diffFunByscenePath(d[m] || {}, l[m] || {}, m);
        Object.assign(c, n);
      }
    return c;
  }
  diffFunByscenePath(d, l, i) {
    const s = sd(d), c = sd(l), m = {};
    for (const n of s) {
      if (ld(d[n], l[n]))
        continue;
      const X = this.diffFunByKeys(d[n] || {}, l[n] || {}, n, i);
      Object.assign(m, X);
    }
    for (const n of c)
      if (!s.includes(n)) {
        const X = this.diffFunByKeys(d[n] || {}, l[n] || {}, n, i);
        Object.assign(m, X);
      }
    return m;
  }
  diffFunByKeys(d, l, i, s) {
    const c = sd(d), m = sd(l), n = {};
    for (const X of c) {
      if (m.includes(X)) {
        if (ld(d[X], l[X]))
          continue;
        n[X] = {
          oldValue: d[X],
          newValue: l[X],
          viewId: s,
          scenePath: i
        };
        continue;
      }
      n[X] = {
        oldValue: d[X],
        newValue: void 0,
        viewId: s,
        scenePath: i
      };
    }
    for (const X of m)
      c.includes(X) || (n[X] = {
        oldValue: void 0,
        newValue: l[X],
        viewId: s,
        scenePath: i
      });
    return n;
  }
  transformKey(d) {
    return this.uid + Wd + d;
  }
  isOwn(d) {
    return d.split(Wd)[0] === this.uid;
  }
  dispatch(d) {
    const { type: l, workId: i, ops: s, index: c, opt: m, toolsType: n, removeIds: X, updateNodeOpt: G, op: L, selectIds: o, isSync: h, scenePath: p, viewId: r } = d;
    if (r)
      switch (l) {
        case yl.Clear:
          const V = {};
          p && this.storage[r] && this.storage[r][p] ? (delete this.storage[r][p], this.setState(V, { isSync: h, viewId: r, scenePath: p })) : this.storage[r] && (delete this.storage[r], this.setState(V, { isSync: h, viewId: r, scenePath: "" }));
          break;
        case yl.CreateWork:
          if (p && i && n && m) {
            const Z = this.isLocalId(i.toString()) ? this.transformKey(i) : i;
            this.updateValue(Z.toString(), {
              type: yl.CreateWork,
              workId: i,
              toolsType: n,
              opt: m
            }, { isSync: h, viewId: r, scenePath: p });
          }
          break;
        case yl.DrawWork:
          if (p && i && typeof c == "number" && (L != null && L.length)) {
            const Z = this.isLocalId(i.toString()) ? this.transformKey(i) : i, a = this.storage[r][p][Z], x = c ? ((a == null ? void 0 : a.op) || []).slice(0, c).concat(L) : L || (a == null ? void 0 : a.op);
            a && x && this.updateValue(Z.toString(), {
              ...a,
              type: yl.DrawWork,
              op: x,
              index: c
            }, { isSync: h, viewId: r, scenePath: p });
          }
          break;
        case yl.FullWork:
          if (p && i) {
            const Z = this.isLocalId(i.toString()) ? this.transformKey(i) : i, a = this.storage[r][p][Z], x = G || (a == null ? void 0 : a.updateNodeOpt), K = n || (a == null ? void 0 : a.toolsType), C = m || (a == null ? void 0 : a.opt), T = s || (a == null ? void 0 : a.ops);
            K && C && this.updateValue(Z.toString(), {
              type: yl.FullWork,
              updateNodeOpt: x,
              workId: Z,
              toolsType: K,
              opt: C,
              ops: T
            }, { isSync: h, viewId: r, scenePath: p });
          }
          break;
        case yl.RemoveNode:
          if (p && (X != null && X.length)) {
            const Z = X.map((a) => this.isLocalId(a + "") ? this.transformKey(a) : a);
            this.storage[r] && this.storage[r][p] && Object.keys(this.storage[r][p]).map((a) => {
              Z != null && Z.includes(a) && this.updateValue(a, void 0, { isSync: h, viewId: r, scenePath: p });
            });
          }
          break;
        case yl.UpdateNode:
          if (p && i && (G || s || m)) {
            const Z = this.isLocalId(i.toString()) ? this.transformKey(i) : i, a = this.storage[r][p][Z];
            a && (a.updateNodeOpt = G, (s || L) && (a.ops = s, a.op = L), m && (a.opt = m), a.type = yl.FullWork, this.updateValue(Z.toString(), a, { isSync: h, viewId: r, scenePath: p }));
          }
          break;
        case yl.Select:
          if (!p)
            return;
          let W;
          o != null && o.length && (W = o.map((Z) => this.isLocalId(Z + "") ? this.transformKey(Z) : Z));
          const y = this.transformKey(Il), t = this.storage[r][p][y], e = m || (t == null ? void 0 : t.opt);
          W && this.checkOtherSelector(y, W, { isSync: h, viewId: r, scenePath: p }), this.updateValue(y, W && {
            type: yl.Select,
            toolsType: Gl.Selector,
            opt: e,
            selectIds: W
          }, { isSync: h, viewId: r, scenePath: p });
          break;
      }
  }
  checkOtherSelector(d, l, i) {
    const { viewId: s, scenePath: c } = i;
    for (const m of Object.keys(this.storage[s][c]))
      if (m !== d && this.getLocalId(m) === Il) {
        const n = this.storage[s][c][m];
        if (n && n.selectIds) {
          const X = n.selectIds.filter((G) => !l.includes(G));
          X.length > 0 && (n.selectIds = X), this.updateValue(m, X.length && n || void 0, i);
        }
      }
  }
  setState(d, l) {
    const { viewId: i, scenePath: s } = l, c = sd(d);
    for (let m = 0; m < c.length; m++) {
      const n = c[m], X = d[n];
      typeof X < "u" ? (this.storage[i] || (this.storage[i] = {}), this.storage[i][s] || (this.storage[i][s] = {}), this.storage[i][s][n] = X) : delete this.storage[i][s][n];
    }
    this.runSyncService(l);
  }
  updateValue(d, l, i) {
    const { viewId: s, scenePath: c } = i;
    l === void 0 ? delete this.storage[s][c][d] : (this.storage[s] || (this.storage[s] = {}), this.storage[s][c] || (this.storage[s][c] = {}), this.storage[s][c][d] = l), this.runSyncService(i);
  }
  runSyncService(d) {
    this.asyncClockState || (this.asyncClockState = !0, setTimeout(() => {
      d.isSync ? (this.asyncClockState = !1, this.syncSerivice(d.isAfterUpdate)) : Hd(() => {
        this.asyncClockState = !1, this.syncSerivice(d.isAfterUpdate);
      }, pd.syncInterval);
    }, d != null && d.isSync ? 0 : pd.syncInterval));
  }
  syncSerivice(d = !1) {
    const l = sd(this.serviceStorage), i = sd(this.storage), s = /* @__PURE__ */ new Map();
    for (const c of l) {
      if (!i.includes(c)) {
        s.set(c, void 0);
        continue;
      }
      ld(this.serviceStorage[c], this.storage[c]) || this.syncViewData(c, d);
    }
    for (const c of i)
      l.includes(c) || s.set(c, this.storage[c]);
    if (s.size > 5)
      this.syncStorageView(this.storage, d);
    else
      for (const [c, m] of s.entries())
        this.syncUpdataView(c, m, d);
  }
  syncViewData(d, l = !1) {
    const i = sd(this.serviceStorage[d]), s = sd(this.storage[d]), c = /* @__PURE__ */ new Map();
    for (const m of i) {
      if (!s.includes(m)) {
        c.set(m, void 0);
        continue;
      }
      ld(this.serviceStorage[d][m], this.storage[d][m]) || this.syncScenePathData(d, m, l);
    }
    for (const m of s)
      i.includes(m) || c.set(m, this.storage[d][m]);
    if (c.size > 5)
      this.syncStorageScenePath(d, this.storage[d], l);
    else
      for (const [m, n] of c.entries())
        this.syncUpdataScenePath(d, m, n, l);
  }
  syncScenePathData(d, l, i = !1) {
    const s = sd(this.serviceStorage[d][l]), c = sd(this.storage[d][l]), m = /* @__PURE__ */ new Map();
    for (const n of s) {
      if (!c.includes(n)) {
        m.set(n, void 0);
        continue;
      }
      ld(this.serviceStorage[d][l][n], this.storage[d][l][n]) || m.set(n, this.storage[d][l][n]);
    }
    for (const n of c)
      s.includes(n) || m.set(n, this.storage[d][l][n]);
    if (m.size > 5)
      this.syncStorageKey(d, l, this.storage[d][l], i);
    else
      for (const [n, X] of m.entries())
        this.syncUpdataKey(d, l, n, X, i);
  }
  syncUpdataView(d, l, i = !1) {
    var c;
    Object.keys(this.serviceStorage).length ? (i || (l === void 0 ? delete this.serviceStorage[d] : this.serviceStorage[d] = Al(l)), (c = this.plugin) == null || c.updateAttributes([this.namespace, d], l)) : this.syncStorageView(this.storage, i);
  }
  syncStorageView(d, l = !1) {
    var i;
    l || d && (this.serviceStorage = Al(d)), (i = this.plugin) == null || i.updateAttributes([this.namespace], d);
  }
  syncUpdataScenePath(d, l, i, s = !1) {
    var m;
    Object.keys(this.serviceStorage[d]).length ? (s || (i === void 0 ? delete this.serviceStorage[d][l] : this.serviceStorage[d][l] = i), (m = this.plugin) == null || m.updateAttributes([this.namespace, d, l], i)) : this.syncStorageScenePath(d, this.storage[d], s);
  }
  syncStorageScenePath(d, l, i = !1) {
    var s;
    i || l && (this.serviceStorage[d] = l), (s = this.plugin) == null || s.updateAttributes([this.namespace, d], l);
  }
  syncUpdataKey(d, l, i, s, c = !1) {
    var n;
    Object.keys(this.serviceStorage[d][l]).length ? (c || (s === void 0 ? delete this.serviceStorage[d][l][i] : this.serviceStorage[d][l][i] = s), (n = this.plugin) == null || n.updateAttributes([this.namespace, d, l, i], s)) : this.syncStorageKey(d, l, this.storage[d][l], c);
  }
  syncStorageKey(d, l, i, s = !1) {
    var c;
    s || (this.serviceStorage[d][l] = i), (c = this.plugin) == null || c.updateAttributes([this.namespace, d, l], i);
  }
  keyTransformWorkId(d) {
    const l = d.split(Wd);
    return l.length === 2 ? l[1] : d;
  }
  destroy() {
    this.removeStorageStateListener(), this.serviceStorage = {}, this.storage = {};
  }
}
Object.defineProperty(pd, "namespace", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PluginState"
});
Object.defineProperty(pd, "syncInterval", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
class po {
  constructor() {
    Object.defineProperty(this, "roomMembers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "onChangeHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    });
  }
  setRoomMembers(d) {
    this.executChangeUidHook(this.roomMembers, d), this.roomMembers = d;
  }
  executChangeUidHook(d, l) {
    const i = {
      online: l.map((s) => {
        var c;
        return ((c = s.payload) == null ? void 0 : c.uid) || s.session;
      }),
      offline: d.map((s) => {
        var c;
        return ((c = s.payload) == null ? void 0 : c.uid) || s.session;
      })
    };
    this.onChangeHooks.forEach((s) => s(i));
  }
  getRoomMember(d) {
    return this.roomMembers.find((l) => {
      var i;
      return ((i = l.payload) == null ? void 0 : i.uid) === d;
    });
  }
  isOnLine(d) {
    return !this.getRoomMember(d);
  }
  onUidChangeHook(d) {
    this.onChangeHooks.add(d);
  }
  destroy() {
    this.onChangeHooks.clear();
  }
}
var ed;
(function(b) {
  b[b.Text = 1] = "Text", b[b.Shape = 2] = "Shape";
})(ed || (ed = {}));
class Ol {
  createProxy(d) {
    const l = new Proxy(d, {
      get(i, s, c) {
        const m = Ol.interceptors.hasOwnProperty(s) ? Ol.interceptors : i;
        return Reflect.get(m, s, c);
      }
    });
    return Ol.proxyToRaw.set(l, d), l;
  }
}
Object.defineProperty(Ol, "proxyToRaw", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /* @__PURE__ */ new WeakMap()
});
Object.defineProperty(Ol, "interceptors", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    entries(...b) {
      return Ol.proxyToRaw.get(this).entries(...b);
    },
    forEach(...b) {
      return Ol.proxyToRaw.get(this).forEach(...b);
    },
    size() {
      return Ol.proxyToRaw.get(this).size;
    },
    get(b) {
      return Ol.proxyToRaw.get(this).get(b);
    },
    set(b, d) {
      return Ol.proxyToRaw.get(this).set(b, d);
    },
    delete(b, d) {
      return Ol.proxyToRaw.get(this).delete(b);
    },
    clear() {
      return Ol.proxyToRaw.get(this).clear();
    }
  }
});
class yo {
  constructor(d) {
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "editors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "activeId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "proxyMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { control: l, internalMsgEmitter: i } = d;
    this.control = l, this.internalMsgEmitter = i;
    const s = /* @__PURE__ */ new Map();
    this.proxyMap = new Ol();
    const c = this, m = Ol.interceptors.set;
    Ol.interceptors.set = function(X, G) {
      return c.interceptors.set(X, G), m.call(this, X, G);
    };
    const n = Ol.interceptors.delete;
    Ol.interceptors.delete = function(X, G) {
      return c.interceptors.delete(X, G), n.call(this, X);
    }, this.editors = this.proxyMap.createProxy(s);
  }
  get collector() {
    return this.control.collector;
  }
  filterEditor(d) {
    const l = /* @__PURE__ */ new Map();
    return this.editors.forEach((i, s) => {
      i.viewId === d && l.set(s, i);
    }), l;
  }
  get interceptors() {
    return {
      set: (d, l) => {
        var p, r, V, W, y, t, e, Z;
        if (!this.collector)
          return !0;
        const { viewId: i, scenePath: s, canSync: c, canWorker: m, type: n, opt: X, dataType: G } = l;
        if (!m && !c)
          return !0;
        const o = ((p = this.collector) == null ? void 0 : p.isLocalId(d)) ? (r = this.collector) == null ? void 0 : r.transformKey(d) : d, h = ((V = this.collector) == null ? void 0 : V.storage[i]) && this.collector.storage[i][s] && this.collector.storage[i][s][o] || void 0;
        h ? h.toolsType === Gl.Text && (m && ((e = this.control.worker) == null || e.taskBatchData.add({
          workId: d,
          msgType: yl.UpdateNode,
          dataType: G || Jl.Local,
          toolsType: Gl.Text,
          opt: X,
          viewId: i,
          scenePath: s
        }), (Z = this.control.worker) == null || Z.runAnimation()), c && Hd(() => {
          var a;
          (a = this.collector) == null || a.dispatch({
            type: yl.UpdateNode,
            workId: d,
            toolsType: Gl.Text,
            opt: X,
            viewId: i,
            scenePath: s
          });
        }, this.control.worker.maxLastSyncTime)) : n === ed.Text && (c && ((W = this.collector) == null || W.dispatch({
          type: X.text && yl.FullWork || yl.CreateWork,
          workId: d,
          toolsType: Gl.Text,
          opt: X,
          isSync: !0,
          viewId: i,
          scenePath: s
        })), m && ((y = this.control.worker) == null || y.taskBatchData.add({
          workId: d,
          msgType: X.text && yl.FullWork || yl.CreateWork,
          dataType: G || Jl.Local,
          toolsType: Gl.Text,
          opt: X,
          viewId: i,
          scenePath: s
        }), (t = this.control.worker) == null || t.runAnimation()));
      },
      delete: (d) => {
        var L, o, h, p, r, V, W;
        if (!this.collector)
          return !0;
        const l = this.editors.get(d);
        if (!l)
          return !0;
        const { viewId: i, scenePath: s, canSync: c, canWorker: m } = l;
        if (!m && !c)
          return !0;
        const X = ((L = this.collector) == null ? void 0 : L.isLocalId(d)) ? (o = this.collector) == null ? void 0 : o.transformKey(d) : d, G = ((h = this.collector) == null ? void 0 : h.storage[i]) && ((p = this.collector) == null ? void 0 : p.storage[i][s]) && ((r = this.collector) == null ? void 0 : r.storage[i][s][X]) || void 0;
        G && G.toolsType === Gl.Text && (m && ((V = this.control.worker) == null || V.taskBatchData.add({
          workId: d,
          toolsType: Gl.Text,
          msgType: yl.RemoveNode,
          dataType: Jl.Local,
          viewId: i,
          scenePath: s
        }), (W = this.control.worker) == null || W.runAnimation()), c && Hd(() => {
          var y;
          (y = this.collector) == null || y.dispatch({
            type: yl.RemoveNode,
            removeIds: [d],
            toolsType: Gl.Text,
            viewId: i,
            scenePath: s
          });
        }, this.control.worker.maxLastSyncTime));
      },
      clear() {
        return !0;
      }
    };
  }
  computeTextActive(d, l) {
    var c, m, n, X;
    const i = (c = this.control.viewContainerManager) == null ? void 0 : c.transformToScenePoint(d, l), s = (m = this.control.viewContainerManager) == null ? void 0 : m.getCurScenePath(l);
    l && s && ((n = this.control.worker) == null || n.taskBatchData.add({
      msgType: yl.GetTextActive,
      dataType: Jl.Local,
      op: i,
      viewId: l,
      scenePath: s
    }), (X = this.control.worker) == null || X.runAnimation());
  }
  checkEmptyTextBlur() {
    if (this.activeId) {
      const d = this.editors.get(this.activeId);
      (d == null ? void 0 : d.opt.text) && (d == null ? void 0 : d.opt.text.replace(/\s*,/g, "")) ? this.unActive() : this.delete(this.activeId, !0, !0);
    }
  }
  onCameraChange(d, l) {
    var i, s;
    for (const [c, m] of this.editors.entries())
      if (m.viewId === l) {
        const { boxPoint: n, boxSize: X } = m.opt, G = n && ((i = this.control.viewContainerManager) == null ? void 0 : i.transformToOriginPoint(n, m.viewId)), L = (s = this.control.viewContainerManager) == null ? void 0 : s.getCurScenePath(l);
        if (L && l) {
          const o = {
            x: G && G[0] || 0,
            y: G && G[1] || 0,
            w: X && X[0] || 0,
            h: X && X[1] || 0,
            opt: m.opt,
            scale: d.scale,
            type: ed.Text,
            viewId: l,
            scenePath: L,
            canWorker: !1,
            canSync: !1
          };
          this.editors.set(c, o), this.control.viewContainerManager.setActiveTextEditor(l, this.activeId);
        }
      }
  }
  onServiceDerive(d) {
    var r, V;
    const { workId: l, opt: i, msgType: s, viewId: c, scenePath: m } = d;
    if (!l || !c || !m)
      return;
    const n = l.toString();
    if (s === yl.RemoveNode) {
      this.delete(n, !1, !0);
      return;
    }
    const { boxPoint: X, boxSize: G, workState: L } = i, o = X && ((r = this.control.viewContainerManager) == null ? void 0 : r.transformToOriginPoint(X, c)), h = this.control.viewContainerManager.getView(c), p = {
      x: o && o[0] || 0,
      y: o && o[1] || 0,
      w: G && G[0] || 0,
      h: G && G[1] || 0,
      opt: i,
      type: ed.Text,
      canWorker: !0,
      canSync: !1,
      dataType: Jl.Service,
      scale: ((V = h == null ? void 0 : h.cameraOpt) == null ? void 0 : V.scale) || 1,
      viewId: c,
      scenePath: m
    };
    this.editors.set(n, p), (L === ul.Doing || L === ul.Start) && (this.activeId = n), this.control.viewContainerManager.setActiveTextEditor(c, this.activeId);
  }
  updateForLocalEditor(d, l) {
    this.editors.set(d, l);
  }
  active(d) {
    const l = this.editors.get(d);
    l && l.viewId && (l.isActive = !0, l.opt.workState = ul.Start, this.activeId = d, this.control.viewContainerManager.setActiveTextEditor(l.viewId, this.activeId));
  }
  unActive() {
    const d = this.activeId && this.editors.get(this.activeId);
    d && d.viewId && this.activeId && (d.opt.workState = ul.Done, d.canWorker = !1, d.canSync = !0, this.updateForLocalEditor(this.activeId, d), this.activeId = void 0, this.control.viewContainerManager.setActiveTextEditor(d.viewId, this.activeId));
  }
  createTextForMasterController(d) {
    const { workId: l, isActive: i, ...s } = d;
    i && (this.checkEmptyTextBlur(), this.activeId = l), s.dataType = Jl.Local, s.canWorker = !0, s.canSync = !0, this.editors.set(l, s), this.control.viewContainerManager.setActiveTextEditor(s.viewId, this.activeId);
  }
  updateTextForMasterController(d) {
    const { workId: l, ...i } = d, s = this.editors.get(l) || {};
    i.dataType = Jl.Local, i.canWorker = !0, i.canSync = !0, this.editors.set(l, { ...s, ...i }), this.control.viewContainerManager.setActiveTextEditor(i.viewId, this.activeId);
  }
  updateTextForWorker(d) {
    const { workId: l, isActive: i, dataType: s, ...c } = d;
    let m = this.editors.get(l);
    i ? m && (m.dataType = s, m.canWorker = !1, m.canSync = !1, this.editors.set(l, m), this.active(l)) : (m = m || {}, m.canWorker = !1, m.canSync = !0, this.editors.set(l, { ...m, ...c })), this.control.viewContainerManager.setActiveTextEditor(c.viewId, this.activeId);
  }
  get(d) {
    return this.editors.get(d);
  }
  delete(d, l, i) {
    const s = this.editors.get(d);
    if (s) {
      const c = s.viewId;
      s.canSync = l, s.canWorker = i, this.editors.delete(d), this.activeId === d && (this.activeId = void 0), this.control.viewContainerManager.setActiveTextEditor(c, this.activeId);
    }
  }
  deleteBatch(d, l, i) {
    const s = /* @__PURE__ */ new Set();
    for (const c of d) {
      const m = this.editors.get(c);
      if (m) {
        const n = m.viewId;
        m.canSync = l, m.canWorker = i, this.editors.delete(c), this.activeId === c && (this.activeId = void 0), s.add(n);
      }
    }
    for (const c of s)
      this.control.viewContainerManager.setActiveTextEditor(c, this.activeId);
  }
  clear(d, l) {
    this.editors.forEach((i, s) => {
      i.viewId === d && (l && (i.canSync = !1), i.canWorker = !1, this.editors.delete(s));
    }), this.activeId = void 0, this.control.viewContainerManager.setActiveTextEditor(d, this.activeId);
  }
  destory() {
    this.editors.clear(), this.activeId = void 0;
  }
}
class yd extends Us {
  constructor(d, l) {
    super(d), Object.defineProperty(this, "serviceStorage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncClockTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.namespace = yd.namespace, yd.syncInterval = (l || yd.syncInterval) * 0.5, this.serviceStorage = this.getNamespaceData(), this.storage = Al(this.serviceStorage);
  }
  addStorageStateListener(d) {
    this.stateDisposer = ks(async () => {
      const l = this.getNamespaceData(), i = this.getDiffMap(this.serviceStorage, l);
      this.serviceStorage = l, i.size && d(i);
    });
  }
  getDiffMap(d, l) {
    const i = /* @__PURE__ */ new Map();
    for (const [s, c] of Object.entries(l))
      s !== this.uid && (c && ld(d[s], c) || c && i.set(s, c));
    return i;
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  transformKey(d) {
    return this.uid + Wd + d;
  }
  isOwn(d) {
    return d === this.uid;
  }
  dispatch(d) {
    const { type: l, op: i, isSync: s, viewId: c } = d;
    switch (l) {
      case Sd.Cursor:
        i && this.pushValue(this.uid, {
          type: Sd.Cursor,
          op: i,
          viewId: c
        }, { isSync: s });
        break;
    }
  }
  pushValue(d, l, i) {
    var s;
    this.storage[d] || (this.storage[d] = []), (s = this.storage[d]) == null || s.push(l), this.runSyncService(i);
  }
  clearValue(d) {
    var i;
    this.storage[d] = void 0, Object.keys(this.serviceStorage).length && ((i = this.plugin) == null || i.updateAttributes([this.namespace, d], void 0));
  }
  runSyncService(d) {
    this.asyncClockTimer || (this.asyncClockTimer = setTimeout(() => {
      d != null && d.isSync ? (this.asyncClockTimer = void 0, this.syncSerivice()) : Hd(() => {
        this.asyncClockTimer = void 0, this.syncSerivice();
      }, yd.syncInterval);
    }, d != null && d.isSync ? 0 : yd.syncInterval));
  }
  syncSerivice() {
    var l;
    Object.keys(this.serviceStorage).length ? Object.keys(this.storage).forEach((i) => {
      var s;
      (s = this.plugin) == null || s.updateAttributes([this.namespace, i], this.storage[i]);
    }) : (l = this.plugin) == null || l.updateAttributes(this.namespace, this.storage), this.storage = {};
  }
  destroy() {
    this.removeStorageStateListener(), this.storage = {}, this.serviceStorage = {};
  }
}
Object.defineProperty(yd, "syncInterval", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 100
});
Object.defineProperty(yd, "namespace", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PluginEvent"
});
var Rs;
(function(b) {
  b[b.Event = 0] = "Event", b[b.Storage = 1] = "Storage";
})(Rs || (Rs = {}));
class Lo {
  constructor(d) {
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "eventCollector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomMember", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "removeTimerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationPointWorkers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "animationDrawWorkers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
    const { control: l, internalMsgEmitter: i } = d;
    this.internalMsgEmitter = i, this.control = l, this.roomMember = l.roomMember;
  }
  activeCollector() {
    var d, l;
    this.control.plugin && (this.eventCollector = new yd(this.control.plugin, Math.min(((l = (d = this.control.pluginOptions) == null ? void 0 : d.syncOpt) == null ? void 0 : l.interval) || 100, 100)), this.eventCollector.addStorageStateListener((i) => {
      i.forEach((s, c) => {
        var m;
        if (((m = this.eventCollector) == null ? void 0 : m.uid) !== c) {
          const n = /* @__PURE__ */ new Map();
          s == null || s.forEach((X) => {
            if (X && X.type === Sd.Cursor && X.op && X.viewId) {
              const G = [];
              for (let L = 0; L < X.op.length; L += 2) {
                const o = X.op[L], h = X.op[L + 1];
                if ($l(o) && $l(h)) {
                  const p = this.control.viewContainerManager.transformToOriginPoint([o, h], X.viewId);
                  G.push(p[0], p[1]);
                } else
                  G.push(o, h);
              }
              n.set(X.viewId, G);
            }
          }), n.size && (this.activePointWorkShape(c, n), this.runAnimation());
        }
      });
    }));
  }
  onFocusViewChange() {
    const d = this.control.viewContainerManager.focuedViewId;
    for (const i of this.animationDrawWorkers.keys()) {
      const s = this.getUidAndviewId(i).uid, c = this.getUidAndviewId(i).viewId;
      c !== d && this.activeDrawWorkShape(s, [void 0, void 0], ul.Done, c);
    }
    const l = /* @__PURE__ */ new Map();
    for (const i of this.animationPointWorkers.keys()) {
      const s = this.getUidAndviewId(i).uid, c = this.getUidAndviewId(i).viewId;
      if (c !== d) {
        const m = l.get(s) || /* @__PURE__ */ new Map();
        m.set(c, [void 0, void 0]), l.set(s, m);
      }
    }
    if (l.size)
      for (const [i, s] of l.entries())
        this.activePointWorkShape(i, s);
    this.runAnimation();
  }
  activePointWorkShape(d, l) {
    var s;
    if (this.roomMember.getRoomMember(d))
      for (const [c, m] of l.entries()) {
        const n = this.getKey(d, c);
        let X = !1;
        const G = this.control.viewContainerManager.getAllViews().map((o) => o == null ? void 0 : o.id);
        for (const o of G)
          if (o && o !== c) {
            const h = this.getKey(d, o), p = this.animationDrawWorkers.get(h);
            if ((p == null ? void 0 : p.workState) === ul.Start || (p == null ? void 0 : p.workState) === ul.Doing || !1) {
              X = !0;
              break;
            } else if (this.removeTimerId && (clearTimeout(this.removeTimerId), this.removeTimerId = void 0), p)
              this.activeDrawWorkShape(d, [void 0, void 0], ul.Done, o), this.runAnimation();
            else {
              const V = this.animationPointWorkers.get(h);
              if (V)
                V.animationWorkData = [void 0, void 0], V.animationIndex = 0, V.freeze = !1;
              else {
                const W = {
                  animationIndex: 0,
                  animationWorkData: [void 0, void 0],
                  freeze: !1
                };
                this.animationPointWorkers.set(h, W);
              }
            }
          }
        const L = this.animationPointWorkers.get(n);
        if (m) {
          if (!L) {
            const o = {
              animationIndex: 0,
              animationWorkData: m,
              freeze: X
            };
            (s = this.animationPointWorkers) == null || s.set(n, o);
            return;
          }
          L.animationWorkData = m, L.animationIndex = 0, L.freeze = X;
        }
      }
  }
  getKey(d, l) {
    return `${d}${Wd}${l}`;
  }
  getUidAndviewId(d) {
    const [l, i] = d.split(Wd);
    return { uid: l, viewId: i };
  }
  animationCursor() {
    this.animationId = void 0;
    const d = /* @__PURE__ */ new Map();
    this.animationPointWorkers.forEach((l, i) => {
      const { uid: s } = this.getUidAndviewId(i);
      if (l.freeze)
        return;
      const m = l.animationIndex, n = this.roomMember.getRoomMember(s);
      if (n) {
        l.animationWorkData.length - 1 > m && (l.animationIndex = m + 2);
        const X = l.animationWorkData[m], G = l.animationWorkData[m + 1];
        d.set(i, {
          x: X,
          y: G,
          roomMember: $l(X) && $l(G) && n || void 0
        }), l.animationWorkData.length - 1 <= l.animationIndex && this.animationPointWorkers.delete(i);
      }
    }), this.animationDrawWorkers.forEach((l, i) => {
      const { uid: s } = this.getUidAndviewId(i), c = l.animationIndex, m = this.roomMember.getRoomMember(s);
      if (m) {
        l.animationWorkData.length - 1 > c && (l.animationIndex = c + 2);
        const n = l.animationWorkData[c], X = l.animationWorkData[c + 1];
        d.set(i, {
          x: n,
          y: X,
          roomMember: $l(n) && $l(X) && m || void 0
        }), l.animationWorkData.length - 1 <= l.animationIndex && this.animationDrawWorkers.delete(i);
      }
    });
    for (const [l, i] of d.entries()) {
      const { viewId: s } = this.getUidAndviewId(l);
      this.control.viewContainerManager.setActiveCursor(s, i);
    }
    (this.animationPointWorkers.size || this.animationDrawWorkers.size) && this.runAnimation();
  }
  activeDrawWorkShape(d, l, i, s) {
    var X, G;
    if (!this.roomMember.getRoomMember(d))
      return;
    const m = this.getKey(d, s);
    if (i === ul.Start) {
      const L = this.animationPointWorkers.get(m);
      if (L)
        L.animationWorkData = [], L.animationIndex = 0, L.freeze = !0;
      else {
        const o = {
          animationIndex: 0,
          animationWorkData: [],
          freeze: !0
        };
        (X = this.animationDrawWorkers) == null || X.set(m, o);
      }
    } else if (i === ul.Done) {
      const L = this.animationPointWorkers.get(m);
      L && (L.freeze = !1);
    }
    const n = this.animationDrawWorkers.get(m);
    if (l) {
      if (!n) {
        const L = {
          animationIndex: 0,
          animationWorkData: l,
          workState: i
        };
        (G = this.animationDrawWorkers) == null || G.set(m, L);
        return;
      }
      n.animationWorkData = l, n.animationIndex = 0, n.workState = i;
    }
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.animationCursor.bind(this)));
  }
  sendEvent(d, l) {
    var i;
    (i = this.eventCollector) == null || i.dispatch({
      type: Sd.Cursor,
      op: $l(d[0]) && $l(d[1]) && this.control.viewContainerManager.transformToScenePoint(d, l) || [void 0, void 0],
      viewId: l
    });
  }
  collectServiceCursor(d) {
    const { op: l, uid: i, workState: s, viewId: c } = d;
    if (i && l && s && c) {
      const m = this.control.viewContainerManager.focuedViewId;
      if (s === ul.Done) {
        if (c !== m) {
          this.activeDrawWorkShape(i, [void 0, void 0], s, c), this.runAnimation();
          return;
        }
        this.removeTimerId && (clearTimeout(this.removeTimerId), this.removeTimerId = void 0), this.removeTimerId = setTimeout(() => {
          this.removeTimerId = void 0, this.activeDrawWorkShape(i, [void 0, void 0], ul.Done, c), this.runAnimation();
        }, 1e4);
      }
      if ($l(l[0]) && $l(l[1])) {
        const n = this.control.viewContainerManager.transformToOriginPoint(l, c);
        this.activeDrawWorkShape(i, n, s, c);
      }
      this.runAnimation();
    }
  }
  unable() {
    var d;
    (d = this.eventCollector) == null || d.dispatch({
      type: Sd.Cursor,
      op: [void 0, void 0],
      viewId: this.control.viewContainerManager.focuedViewId
    });
  }
  destroy() {
    var d;
    (d = this.eventCollector) == null || d.destroy();
  }
}
const Wt = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBNZT10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIHBlKGQpe3JldHVybiBkJiZkLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLCJkZWZhdWx0Iik/ZC5kZWZhdWx0OmR9ZnVuY3Rpb24gTG4oKXt0aGlzLl9fZGF0YV9fPVtdLHRoaXMuc2l6ZT0wfXZhciBEbj1MbjtmdW5jdGlvbiB3bihkLGUpe3JldHVybiBkPT09ZXx8ZCE9PWQmJmUhPT1lfXZhciBvcj13bixObj1vcjtmdW5jdGlvbiBqbihkLGUpe2Zvcih2YXIgdD1kLmxlbmd0aDt0LS07KWlmKE5uKGRbdF1bMF0sZSkpcmV0dXJuIHQ7cmV0dXJuLTF9dmFyIFRlPWpuLEJuPVRlLFduPUFycmF5LnByb3RvdHlwZSxGbj1Xbi5zcGxpY2U7ZnVuY3Rpb24gVW4oZCl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PUJuKGUsZCk7aWYodDwwKXJldHVybiExO3ZhciByPWUubGVuZ3RoLTE7cmV0dXJuIHQ9PXI/ZS5wb3AoKTpGbi5jYWxsKGUsdCwxKSwtLXRoaXMuc2l6ZSwhMH12YXIgem49VW4sJG49VGU7ZnVuY3Rpb24gR24oZCl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PSRuKGUsZCk7cmV0dXJuIHQ8MD92b2lkIDA6ZVt0XVsxXX12YXIgS249R24sSG49VGU7ZnVuY3Rpb24gVm4oZCl7cmV0dXJuIEhuKHRoaXMuX19kYXRhX18sZCk+LTF9dmFyIFluPVZuLFhuPVRlO2Z1bmN0aW9uIEpuKGQsZSl7dmFyIHQ9dGhpcy5fX2RhdGFfXyxyPVhuKHQsZCk7cmV0dXJuIHI8MD8oKyt0aGlzLnNpemUsdC5wdXNoKFtkLGVdKSk6dFtyXVsxXT1lLHRoaXN9dmFyIFpuPUpuLFFuPURuLGtuPXpuLHFuPUtuLF9uPVluLHRpPVpuO2Z1bmN0aW9uIG9lKGQpe3ZhciBlPS0xLHQ9ZD09bnVsbD8wOmQubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj1kW2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fW9lLnByb3RvdHlwZS5jbGVhcj1RbixvZS5wcm90b3R5cGUuZGVsZXRlPWtuLG9lLnByb3RvdHlwZS5nZXQ9cW4sb2UucHJvdG90eXBlLmhhcz1fbixvZS5wcm90b3R5cGUuc2V0PXRpO3ZhciBFZT1vZSxlaT1FZTtmdW5jdGlvbiByaSgpe3RoaXMuX19kYXRhX189bmV3IGVpLHRoaXMuc2l6ZT0wfXZhciBuaT1yaTtmdW5jdGlvbiBpaShkKXt2YXIgZT10aGlzLl9fZGF0YV9fLHQ9ZS5kZWxldGUoZCk7cmV0dXJuIHRoaXMuc2l6ZT1lLnNpemUsdH12YXIgc2k9aWk7ZnVuY3Rpb24gb2koZCl7cmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGQpfXZhciBhaT1vaTtmdW5jdGlvbiBsaShkKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoZCl9dmFyIGNpPWxpLHVpPXR5cGVvZiBNZT09Im9iamVjdCImJk1lJiZNZS5PYmplY3Q9PT1PYmplY3QmJk1lLGFyPXVpLGZpPWFyLGhpPXR5cGVvZiBzZWxmPT0ib2JqZWN0IiYmc2VsZiYmc2VsZi5PYmplY3Q9PT1PYmplY3QmJnNlbGYsZGk9Zml8fGhpfHxGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpLFZ0PWRpLGdpPVZ0LG1pPWdpLlN5bWJvbCxGZT1taSxscj1GZSxjcj1PYmplY3QucHJvdG90eXBlLHZpPWNyLmhhc093blByb3BlcnR5LHBpPWNyLnRvU3RyaW5nLHllPWxyP2xyLnRvU3RyaW5nVGFnOnZvaWQgMDtmdW5jdGlvbiB5aShkKXt2YXIgZT12aS5jYWxsKGQseWUpLHQ9ZFt5ZV07dHJ5e2RbeWVdPXZvaWQgMDt2YXIgcj0hMH1jYXRjaHt9dmFyIG49cGkuY2FsbChkKTtyZXR1cm4gciYmKGU/ZFt5ZV09dDpkZWxldGUgZFt5ZV0pLG59dmFyIHhpPXlpLE9pPU9iamVjdC5wcm90b3R5cGUsUGk9T2kudG9TdHJpbmc7ZnVuY3Rpb24gYmkoZCl7cmV0dXJuIFBpLmNhbGwoZCl9dmFyIFNpPWJpLHVyPUZlLE1pPXhpLFRpPVNpLEVpPSJbb2JqZWN0IE51bGxdIixBaT0iW29iamVjdCBVbmRlZmluZWRdIixmcj11cj91ci50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24gQ2koZCl7cmV0dXJuIGQ9PW51bGw/ZD09PXZvaWQgMD9BaTpFaTpmciYmZnIgaW4gT2JqZWN0KGQpP01pKGQpOlRpKGQpfXZhciByZT1DaTtmdW5jdGlvbiBSaShkKXt2YXIgZT10eXBlb2YgZDtyZXR1cm4gZCE9bnVsbCYmKGU9PSJvYmplY3QifHxlPT0iZnVuY3Rpb24iKX12YXIgX3Q9UmksSWk9cmUsTGk9X3QsRGk9IltvYmplY3QgQXN5bmNGdW5jdGlvbl0iLHdpPSJbb2JqZWN0IEZ1bmN0aW9uXSIsTmk9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixqaT0iW29iamVjdCBQcm94eV0iO2Z1bmN0aW9uIEJpKGQpe2lmKCFMaShkKSlyZXR1cm4hMTt2YXIgZT1JaShkKTtyZXR1cm4gZT09d2l8fGU9PU5pfHxlPT1EaXx8ZT09aml9dmFyIGhyPUJpLFdpPVZ0LEZpPVdpWyJfX2NvcmUtanNfc2hhcmVkX18iXSxVaT1GaSxVZT1VaSxkcj1mdW5jdGlvbigpe3ZhciBkPS9bXi5dKyQvLmV4ZWMoVWUmJlVlLmtleXMmJlVlLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gZD8iU3ltYm9sKHNyYylfMS4iK2Q6IiJ9KCk7ZnVuY3Rpb24gemkoZCl7cmV0dXJuISFkciYmZHIgaW4gZH12YXIgJGk9emksR2k9RnVuY3Rpb24ucHJvdG90eXBlLEtpPUdpLnRvU3RyaW5nO2Z1bmN0aW9uIEhpKGQpe2lmKGQhPW51bGwpe3RyeXtyZXR1cm4gS2kuY2FsbChkKX1jYXRjaHt9dHJ5e3JldHVybiBkKyIifWNhdGNoe319cmV0dXJuIiJ9dmFyIGdyPUhpLFZpPWhyLFlpPSRpLFhpPV90LEppPWdyLFppPS9bXFxeJC4qKz8oKVtcXXt9fF0vZyxRaT0vXlxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXF0kLyxraT1GdW5jdGlvbi5wcm90b3R5cGUscWk9T2JqZWN0LnByb3RvdHlwZSxfaT1raS50b1N0cmluZyx0cz1xaS5oYXNPd25Qcm9wZXJ0eSxlcz1SZWdFeHAoIl4iK19pLmNhbGwodHMpLnJlcGxhY2UoWmksIlxcJCYiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcKCl8IGZvciAuKz8oPz1cXFxdKS9nLCIkMS4qPyIpKyIkIik7ZnVuY3Rpb24gcnMoZCl7aWYoIVhpKGQpfHxZaShkKSlyZXR1cm4hMTt2YXIgZT1WaShkKT9lczpRaTtyZXR1cm4gZS50ZXN0KEppKGQpKX12YXIgbnM9cnM7ZnVuY3Rpb24gaXMoZCxlKXtyZXR1cm4gZD09bnVsbD92b2lkIDA6ZFtlXX12YXIgc3M9aXMsb3M9bnMsYXM9c3M7ZnVuY3Rpb24gbHMoZCxlKXt2YXIgdD1hcyhkLGUpO3JldHVybiBvcyh0KT90OnZvaWQgMH12YXIgbmU9bHMsY3M9bmUsdXM9VnQsZnM9Y3ModXMsIk1hcCIpLHplPWZzLGhzPW5lLGRzPWhzKE9iamVjdCwiY3JlYXRlIiksQWU9ZHMsbXI9QWU7ZnVuY3Rpb24gZ3MoKXt0aGlzLl9fZGF0YV9fPW1yP21yKG51bGwpOnt9LHRoaXMuc2l6ZT0wfXZhciBtcz1ncztmdW5jdGlvbiB2cyhkKXt2YXIgZT10aGlzLmhhcyhkKSYmZGVsZXRlIHRoaXMuX19kYXRhX19bZF07cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX12YXIgcHM9dnMseXM9QWUseHM9Il9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18iLE9zPU9iamVjdC5wcm90b3R5cGUsUHM9T3MuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gYnMoZCl7dmFyIGU9dGhpcy5fX2RhdGFfXztpZih5cyl7dmFyIHQ9ZVtkXTtyZXR1cm4gdD09PXhzP3ZvaWQgMDp0fXJldHVybiBQcy5jYWxsKGUsZCk/ZVtkXTp2b2lkIDB9dmFyIFNzPWJzLE1zPUFlLFRzPU9iamVjdC5wcm90b3R5cGUsRXM9VHMuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gQXMoZCl7dmFyIGU9dGhpcy5fX2RhdGFfXztyZXR1cm4gTXM/ZVtkXSE9PXZvaWQgMDpFcy5jYWxsKGUsZCl9dmFyIENzPUFzLFJzPUFlLElzPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIjtmdW5jdGlvbiBMcyhkLGUpe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXMoZCk/MDoxLHRbZF09UnMmJmU9PT12b2lkIDA/SXM6ZSx0aGlzfXZhciBEcz1Mcyx3cz1tcyxOcz1wcyxqcz1TcyxCcz1DcyxXcz1EcztmdW5jdGlvbiBhZShkKXt2YXIgZT0tMSx0PWQ9PW51bGw/MDpkLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9ZFtlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1hZS5wcm90b3R5cGUuY2xlYXI9d3MsYWUucHJvdG90eXBlLmRlbGV0ZT1OcyxhZS5wcm90b3R5cGUuZ2V0PWpzLGFlLnByb3RvdHlwZS5oYXM9QnMsYWUucHJvdG90eXBlLnNldD1Xczt2YXIgRnM9YWUsdnI9RnMsVXM9RWUsenM9emU7ZnVuY3Rpb24gJHMoKXt0aGlzLnNpemU9MCx0aGlzLl9fZGF0YV9fPXtoYXNoOm5ldyB2cixtYXA6bmV3KHpzfHxVcyksc3RyaW5nOm5ldyB2cn19dmFyIEdzPSRzO2Z1bmN0aW9uIEtzKGQpe3ZhciBlPXR5cGVvZiBkO3JldHVybiBlPT0ic3RyaW5nInx8ZT09Im51bWJlciJ8fGU9PSJzeW1ib2wifHxlPT0iYm9vbGVhbiI/ZCE9PSJfX3Byb3RvX18iOmQ9PT1udWxsfXZhciBIcz1LcyxWcz1IcztmdW5jdGlvbiBZcyhkLGUpe3ZhciB0PWQuX19kYXRhX187cmV0dXJuIFZzKGUpP3RbdHlwZW9mIGU9PSJzdHJpbmciPyJzdHJpbmciOiJoYXNoIl06dC5tYXB9dmFyIENlPVlzLFhzPUNlO2Z1bmN0aW9uIEpzKGQpe3ZhciBlPVhzKHRoaXMsZCkuZGVsZXRlKGQpO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIFpzPUpzLFFzPUNlO2Z1bmN0aW9uIGtzKGQpe3JldHVybiBRcyh0aGlzLGQpLmdldChkKX12YXIgcXM9a3MsX3M9Q2U7ZnVuY3Rpb24gdG8oZCl7cmV0dXJuIF9zKHRoaXMsZCkuaGFzKGQpfXZhciBlbz10byxybz1DZTtmdW5jdGlvbiBubyhkLGUpe3ZhciB0PXJvKHRoaXMsZCkscj10LnNpemU7cmV0dXJuIHQuc2V0KGQsZSksdGhpcy5zaXplKz10LnNpemU9PXI/MDoxLHRoaXN9dmFyIGlvPW5vLHNvPUdzLG9vPVpzLGFvPXFzLGxvPWVvLGNvPWlvO2Z1bmN0aW9uIGxlKGQpe3ZhciBlPS0xLHQ9ZD09bnVsbD8wOmQubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj1kW2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fWxlLnByb3RvdHlwZS5jbGVhcj1zbyxsZS5wcm90b3R5cGUuZGVsZXRlPW9vLGxlLnByb3RvdHlwZS5nZXQ9YW8sbGUucHJvdG90eXBlLmhhcz1sbyxsZS5wcm90b3R5cGUuc2V0PWNvO3ZhciB1bz1sZSxmbz1FZSxobz16ZSxnbz11byxtbz0yMDA7ZnVuY3Rpb24gdm8oZCxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO2lmKHQgaW5zdGFuY2VvZiBmbyl7dmFyIHI9dC5fX2RhdGFfXztpZighaG98fHIubGVuZ3RoPG1vLTEpcmV0dXJuIHIucHVzaChbZCxlXSksdGhpcy5zaXplPSsrdC5zaXplLHRoaXM7dD10aGlzLl9fZGF0YV9fPW5ldyBnbyhyKX1yZXR1cm4gdC5zZXQoZCxlKSx0aGlzLnNpemU9dC5zaXplLHRoaXN9dmFyIHBvPXZvLHlvPUVlLHhvPW5pLE9vPXNpLFBvPWFpLGJvPWNpLFNvPXBvO2Z1bmN0aW9uIGNlKGQpe3ZhciBlPXRoaXMuX19kYXRhX189bmV3IHlvKGQpO3RoaXMuc2l6ZT1lLnNpemV9Y2UucHJvdG90eXBlLmNsZWFyPXhvLGNlLnByb3RvdHlwZS5kZWxldGU9T28sY2UucHJvdG90eXBlLmdldD1QbyxjZS5wcm90b3R5cGUuaGFzPWJvLGNlLnByb3RvdHlwZS5zZXQ9U287dmFyIE1vPWNlO2Z1bmN0aW9uIFRvKGQsZSl7Zm9yKHZhciB0PS0xLHI9ZD09bnVsbD8wOmQubGVuZ3RoOysrdDxyJiZlKGRbdF0sdCxkKSE9PSExOyk7cmV0dXJuIGR9dmFyIEVvPVRvLEFvPW5lLENvPWZ1bmN0aW9uKCl7dHJ5e3ZhciBkPUFvKE9iamVjdCwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gZCh7fSwiIix7fSksZH1jYXRjaHt9fSgpLFJvPUNvLHByPVJvO2Z1bmN0aW9uIElvKGQsZSx0KXtlPT0iX19wcm90b19fIiYmcHI/cHIoZCxlLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0LHdyaXRhYmxlOiEwfSk6ZFtlXT10fXZhciB5cj1JbyxMbz15cixEbz1vcix3bz1PYmplY3QucHJvdG90eXBlLE5vPXdvLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIGpvKGQsZSx0KXt2YXIgcj1kW2VdOyghKE5vLmNhbGwoZCxlKSYmRG8ocix0KSl8fHQ9PT12b2lkIDAmJiEoZSBpbiBkKSkmJkxvKGQsZSx0KX12YXIgeHI9am8sQm89eHIsV289eXI7ZnVuY3Rpb24gRm8oZCxlLHQscil7dmFyIG49IXQ7dHx8KHQ9e30pO2Zvcih2YXIgcz0tMSxsPWUubGVuZ3RoOysrczxsOyl7dmFyIGM9ZVtzXSxvPXI/cih0W2NdLGRbY10sYyx0LGQpOnZvaWQgMDtvPT09dm9pZCAwJiYobz1kW2NdKSxuP1dvKHQsYyxvKTpCbyh0LGMsbyl9cmV0dXJuIHR9dmFyIFJlPUZvO2Z1bmN0aW9uIFVvKGQsZSl7Zm9yKHZhciB0PS0xLHI9QXJyYXkoZCk7Kyt0PGQ7KXJbdF09ZSh0KTtyZXR1cm4gcn12YXIgem89VW87ZnVuY3Rpb24gJG8oZCl7cmV0dXJuIGQhPW51bGwmJnR5cGVvZiBkPT0ib2JqZWN0In12YXIgdGU9JG8sR289cmUsS289dGUsSG89IltvYmplY3QgQXJndW1lbnRzXSI7ZnVuY3Rpb24gVm8oZCl7cmV0dXJuIEtvKGQpJiZHbyhkKT09SG99dmFyIFlvPVZvLE9yPVlvLFhvPXRlLFByPU9iamVjdC5wcm90b3R5cGUsSm89UHIuaGFzT3duUHJvcGVydHksWm89UHIucHJvcGVydHlJc0VudW1lcmFibGUsUW89T3IoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT9PcjpmdW5jdGlvbihkKXtyZXR1cm4gWG8oZCkmJkpvLmNhbGwoZCwiY2FsbGVlIikmJiFaby5jYWxsKGQsImNhbGxlZSIpfSxrbz1Rbyxxbz1BcnJheS5pc0FycmF5LCRlPXFvLEllPXtleHBvcnRzOnt9fTtmdW5jdGlvbiBfbygpe3JldHVybiExfXZhciB0YT1fbztJZS5leHBvcnRzLGZ1bmN0aW9uKGQsZSl7dmFyIHQ9VnQscj10YSxuPWUmJiFlLm5vZGVUeXBlJiZlLHM9biYmITAmJmQmJiFkLm5vZGVUeXBlJiZkLGw9cyYmcy5leHBvcnRzPT09bixjPWw/dC5CdWZmZXI6dm9pZCAwLG89Yz9jLmlzQnVmZmVyOnZvaWQgMCxmPW98fHI7ZC5leHBvcnRzPWZ9KEllLEllLmV4cG9ydHMpO3ZhciBicj1JZS5leHBvcnRzLGVhPTkwMDcxOTkyNTQ3NDA5OTEscmE9L14oPzowfFsxLTldXGQqKSQvO2Z1bmN0aW9uIG5hKGQsZSl7dmFyIHQ9dHlwZW9mIGQ7cmV0dXJuIGU9ZT8/ZWEsISFlJiYodD09Im51bWJlciJ8fHQhPSJzeW1ib2wiJiZyYS50ZXN0KGQpKSYmZD4tMSYmZCUxPT0wJiZkPGV9dmFyIGlhPW5hLHNhPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24gb2EoZCl7cmV0dXJuIHR5cGVvZiBkPT0ibnVtYmVyIiYmZD4tMSYmZCUxPT0wJiZkPD1zYX12YXIgU3I9b2EsYWE9cmUsbGE9U3IsY2E9dGUsdWE9IltvYmplY3QgQXJndW1lbnRzXSIsZmE9IltvYmplY3QgQXJyYXldIixoYT0iW29iamVjdCBCb29sZWFuXSIsZGE9IltvYmplY3QgRGF0ZV0iLGdhPSJbb2JqZWN0IEVycm9yXSIsbWE9IltvYmplY3QgRnVuY3Rpb25dIix2YT0iW29iamVjdCBNYXBdIixwYT0iW29iamVjdCBOdW1iZXJdIix5YT0iW29iamVjdCBPYmplY3RdIix4YT0iW29iamVjdCBSZWdFeHBdIixPYT0iW29iamVjdCBTZXRdIixQYT0iW29iamVjdCBTdHJpbmddIixiYT0iW29iamVjdCBXZWFrTWFwXSIsU2E9IltvYmplY3QgQXJyYXlCdWZmZXJdIixNYT0iW29iamVjdCBEYXRhVmlld10iLFRhPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLEVhPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLEFhPSJbb2JqZWN0IEludDhBcnJheV0iLENhPSJbb2JqZWN0IEludDE2QXJyYXldIixSYT0iW29iamVjdCBJbnQzMkFycmF5XSIsSWE9IltvYmplY3QgVWludDhBcnJheV0iLExhPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsRGE9IltvYmplY3QgVWludDE2QXJyYXldIix3YT0iW29iamVjdCBVaW50MzJBcnJheV0iLGp0PXt9O2p0W1RhXT1qdFtFYV09anRbQWFdPWp0W0NhXT1qdFtSYV09anRbSWFdPWp0W0xhXT1qdFtEYV09anRbd2FdPSEwLGp0W3VhXT1qdFtmYV09anRbU2FdPWp0W2hhXT1qdFtNYV09anRbZGFdPWp0W2dhXT1qdFttYV09anRbdmFdPWp0W3BhXT1qdFt5YV09anRbeGFdPWp0W09hXT1qdFtQYV09anRbYmFdPSExO2Z1bmN0aW9uIE5hKGQpe3JldHVybiBjYShkKSYmbGEoZC5sZW5ndGgpJiYhIWp0W2FhKGQpXX12YXIgamE9TmE7ZnVuY3Rpb24gQmEoZCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBkKGUpfX12YXIgR2U9QmEsTGU9e2V4cG9ydHM6e319O0xlLmV4cG9ydHMsZnVuY3Rpb24oZCxlKXt2YXIgdD1hcixyPWUmJiFlLm5vZGVUeXBlJiZlLG49ciYmITAmJmQmJiFkLm5vZGVUeXBlJiZkLHM9biYmbi5leHBvcnRzPT09cixsPXMmJnQucHJvY2VzcyxjPWZ1bmN0aW9uKCl7dHJ5e3ZhciBvPW4mJm4ucmVxdWlyZSYmbi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7cmV0dXJuIG98fGwmJmwuYmluZGluZyYmbC5iaW5kaW5nKCJ1dGlsIil9Y2F0Y2h7fX0oKTtkLmV4cG9ydHM9Y30oTGUsTGUuZXhwb3J0cyk7dmFyIEtlPUxlLmV4cG9ydHMsV2E9amEsRmE9R2UsTXI9S2UsVHI9TXImJk1yLmlzVHlwZWRBcnJheSxVYT1Ucj9GYShUcik6V2EsemE9VWEsJGE9em8sR2E9a28sS2E9JGUsSGE9YnIsVmE9aWEsWWE9emEsWGE9T2JqZWN0LnByb3RvdHlwZSxKYT1YYS5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBaYShkLGUpe3ZhciB0PUthKGQpLHI9IXQmJkdhKGQpLG49IXQmJiFyJiZIYShkKSxzPSF0JiYhciYmIW4mJllhKGQpLGw9dHx8cnx8bnx8cyxjPWw/JGEoZC5sZW5ndGgsU3RyaW5nKTpbXSxvPWMubGVuZ3RoO2Zvcih2YXIgZiBpbiBkKShlfHxKYS5jYWxsKGQsZikpJiYhKGwmJihmPT0ibGVuZ3RoInx8biYmKGY9PSJvZmZzZXQifHxmPT0icGFyZW50Iil8fHMmJihmPT0iYnVmZmVyInx8Zj09ImJ5dGVMZW5ndGgifHxmPT0iYnl0ZU9mZnNldCIpfHxWYShmLG8pKSkmJmMucHVzaChmKTtyZXR1cm4gY312YXIgRXI9WmEsUWE9T2JqZWN0LnByb3RvdHlwZTtmdW5jdGlvbiBrYShkKXt2YXIgZT1kJiZkLmNvbnN0cnVjdG9yLHQ9dHlwZW9mIGU9PSJmdW5jdGlvbiImJmUucHJvdG90eXBlfHxRYTtyZXR1cm4gZD09PXR9dmFyIEhlPWthO2Z1bmN0aW9uIHFhKGQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBkKGUodCkpfX12YXIgQXI9cWEsX2E9QXIsdGw9X2EoT2JqZWN0LmtleXMsT2JqZWN0KSxlbD10bCxybD1IZSxubD1lbCxpbD1PYmplY3QucHJvdG90eXBlLHNsPWlsLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIG9sKGQpe2lmKCFybChkKSlyZXR1cm4gbmwoZCk7dmFyIGU9W107Zm9yKHZhciB0IGluIE9iamVjdChkKSlzbC5jYWxsKGQsdCkmJnQhPSJjb25zdHJ1Y3RvciImJmUucHVzaCh0KTtyZXR1cm4gZX12YXIgYWw9b2wsbGw9aHIsY2w9U3I7ZnVuY3Rpb24gdWwoZCl7cmV0dXJuIGQhPW51bGwmJmNsKGQubGVuZ3RoKSYmIWxsKGQpfXZhciBDcj11bCxmbD1FcixobD1hbCxkbD1DcjtmdW5jdGlvbiBnbChkKXtyZXR1cm4gZGwoZCk/ZmwoZCk6aGwoZCl9dmFyIFZlPWdsLG1sPVJlLHZsPVZlO2Z1bmN0aW9uIHBsKGQsZSl7cmV0dXJuIGQmJm1sKGUsdmwoZSksZCl9dmFyIHlsPXBsO2Z1bmN0aW9uIHhsKGQpe3ZhciBlPVtdO2lmKGQhPW51bGwpZm9yKHZhciB0IGluIE9iamVjdChkKSllLnB1c2godCk7cmV0dXJuIGV9dmFyIE9sPXhsLFBsPV90LGJsPUhlLFNsPU9sLE1sPU9iamVjdC5wcm90b3R5cGUsVGw9TWwuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gRWwoZCl7aWYoIVBsKGQpKXJldHVybiBTbChkKTt2YXIgZT1ibChkKSx0PVtdO2Zvcih2YXIgciBpbiBkKXI9PSJjb25zdHJ1Y3RvciImJihlfHwhVGwuY2FsbChkLHIpKXx8dC5wdXNoKHIpO3JldHVybiB0fXZhciBBbD1FbCxDbD1FcixSbD1BbCxJbD1DcjtmdW5jdGlvbiBMbChkKXtyZXR1cm4gSWwoZCk/Q2woZCwhMCk6UmwoZCl9dmFyIFllPUxsLERsPVJlLHdsPVllO2Z1bmN0aW9uIE5sKGQsZSl7cmV0dXJuIGQmJkRsKGUsd2woZSksZCl9dmFyIGpsPU5sLERlPXtleHBvcnRzOnt9fTtEZS5leHBvcnRzLGZ1bmN0aW9uKGQsZSl7dmFyIHQ9VnQscj1lJiYhZS5ub2RlVHlwZSYmZSxuPXImJiEwJiZkJiYhZC5ub2RlVHlwZSYmZCxzPW4mJm4uZXhwb3J0cz09PXIsbD1zP3QuQnVmZmVyOnZvaWQgMCxjPWw/bC5hbGxvY1Vuc2FmZTp2b2lkIDA7ZnVuY3Rpb24gbyhmLHgpe2lmKHgpcmV0dXJuIGYuc2xpY2UoKTt2YXIgZz1mLmxlbmd0aCx5PWM/YyhnKTpuZXcgZi5jb25zdHJ1Y3RvcihnKTtyZXR1cm4gZi5jb3B5KHkpLHl9ZC5leHBvcnRzPW99KERlLERlLmV4cG9ydHMpO3ZhciBCbD1EZS5leHBvcnRzO2Z1bmN0aW9uIFdsKGQsZSl7dmFyIHQ9LTEscj1kLmxlbmd0aDtmb3IoZXx8KGU9QXJyYXkocikpOysrdDxyOyllW3RdPWRbdF07cmV0dXJuIGV9dmFyIEZsPVdsO2Z1bmN0aW9uIFVsKGQsZSl7Zm9yKHZhciB0PS0xLHI9ZD09bnVsbD8wOmQubGVuZ3RoLG49MCxzPVtdOysrdDxyOyl7dmFyIGw9ZFt0XTtlKGwsdCxkKSYmKHNbbisrXT1sKX1yZXR1cm4gc312YXIgemw9VWw7ZnVuY3Rpb24gJGwoKXtyZXR1cm5bXX12YXIgUnI9JGwsR2w9emwsS2w9UnIsSGw9T2JqZWN0LnByb3RvdHlwZSxWbD1IbC5wcm9wZXJ0eUlzRW51bWVyYWJsZSxJcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFlsPUlyP2Z1bmN0aW9uKGQpe3JldHVybiBkPT1udWxsP1tdOihkPU9iamVjdChkKSxHbChJcihkKSxmdW5jdGlvbihlKXtyZXR1cm4gVmwuY2FsbChkLGUpfSkpfTpLbCxYZT1ZbCxYbD1SZSxKbD1YZTtmdW5jdGlvbiBabChkLGUpe3JldHVybiBYbChkLEpsKGQpLGUpfXZhciBRbD1abDtmdW5jdGlvbiBrbChkLGUpe2Zvcih2YXIgdD0tMSxyPWUubGVuZ3RoLG49ZC5sZW5ndGg7Kyt0PHI7KWRbbit0XT1lW3RdO3JldHVybiBkfXZhciBMcj1rbCxxbD1BcixfbD1xbChPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KSxEcj1fbCx0Yz1McixlYz1EcixyYz1YZSxuYz1ScixpYz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLHNjPWljP2Z1bmN0aW9uKGQpe2Zvcih2YXIgZT1bXTtkOyl0YyhlLHJjKGQpKSxkPWVjKGQpO3JldHVybiBlfTpuYyx3cj1zYyxvYz1SZSxhYz13cjtmdW5jdGlvbiBsYyhkLGUpe3JldHVybiBvYyhkLGFjKGQpLGUpfXZhciBjYz1sYyx1Yz1McixmYz0kZTtmdW5jdGlvbiBoYyhkLGUsdCl7dmFyIHI9ZShkKTtyZXR1cm4gZmMoZCk/cjp1YyhyLHQoZCkpfXZhciBOcj1oYyxkYz1OcixnYz1YZSxtYz1WZTtmdW5jdGlvbiB2YyhkKXtyZXR1cm4gZGMoZCxtYyxnYyl9dmFyIHBjPXZjLHljPU5yLHhjPXdyLE9jPVllO2Z1bmN0aW9uIFBjKGQpe3JldHVybiB5YyhkLE9jLHhjKX12YXIgYmM9UGMsU2M9bmUsTWM9VnQsVGM9U2MoTWMsIkRhdGFWaWV3IiksRWM9VGMsQWM9bmUsQ2M9VnQsUmM9QWMoQ2MsIlByb21pc2UiKSxJYz1SYyxMYz1uZSxEYz1WdCx3Yz1MYyhEYywiU2V0IiksTmM9d2MsamM9bmUsQmM9VnQsV2M9amMoQmMsIldlYWtNYXAiKSxGYz1XYyxKZT1FYyxaZT16ZSxRZT1JYyxrZT1OYyxxZT1GYyxqcj1yZSx1ZT1ncixCcj0iW29iamVjdCBNYXBdIixVYz0iW29iamVjdCBPYmplY3RdIixXcj0iW29iamVjdCBQcm9taXNlXSIsRnI9IltvYmplY3QgU2V0XSIsVXI9IltvYmplY3QgV2Vha01hcF0iLHpyPSJbb2JqZWN0IERhdGFWaWV3XSIsemM9dWUoSmUpLCRjPXVlKFplKSxHYz11ZShRZSksS2M9dWUoa2UpLEhjPXVlKHFlKSxpZT1qcjsoSmUmJmllKG5ldyBKZShuZXcgQXJyYXlCdWZmZXIoMSkpKSE9enJ8fFplJiZpZShuZXcgWmUpIT1Ccnx8UWUmJmllKFFlLnJlc29sdmUoKSkhPVdyfHxrZSYmaWUobmV3IGtlKSE9RnJ8fHFlJiZpZShuZXcgcWUpIT1VcikmJihpZT1mdW5jdGlvbihkKXt2YXIgZT1qcihkKSx0PWU9PVVjP2QuY29uc3RydWN0b3I6dm9pZCAwLHI9dD91ZSh0KToiIjtpZihyKXN3aXRjaChyKXtjYXNlIHpjOnJldHVybiB6cjtjYXNlICRjOnJldHVybiBCcjtjYXNlIEdjOnJldHVybiBXcjtjYXNlIEtjOnJldHVybiBGcjtjYXNlIEhjOnJldHVybiBVcn1yZXR1cm4gZX0pO3ZhciBfZT1pZSxWYz1PYmplY3QucHJvdG90eXBlLFljPVZjLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIFhjKGQpe3ZhciBlPWQubGVuZ3RoLHQ9bmV3IGQuY29uc3RydWN0b3IoZSk7cmV0dXJuIGUmJnR5cGVvZiBkWzBdPT0ic3RyaW5nIiYmWWMuY2FsbChkLCJpbmRleCIpJiYodC5pbmRleD1kLmluZGV4LHQuaW5wdXQ9ZC5pbnB1dCksdH12YXIgSmM9WGMsWmM9VnQsUWM9WmMuVWludDhBcnJheSxrYz1RYywkcj1rYztmdW5jdGlvbiBxYyhkKXt2YXIgZT1uZXcgZC5jb25zdHJ1Y3RvcihkLmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgJHIoZSkuc2V0KG5ldyAkcihkKSksZX12YXIgdHI9cWMsX2M9dHI7ZnVuY3Rpb24gdHUoZCxlKXt2YXIgdD1lP19jKGQuYnVmZmVyKTpkLmJ1ZmZlcjtyZXR1cm4gbmV3IGQuY29uc3RydWN0b3IodCxkLmJ5dGVPZmZzZXQsZC5ieXRlTGVuZ3RoKX12YXIgZXU9dHUscnU9L1x3KiQvO2Z1bmN0aW9uIG51KGQpe3ZhciBlPW5ldyBkLmNvbnN0cnVjdG9yKGQuc291cmNlLHJ1LmV4ZWMoZCkpO3JldHVybiBlLmxhc3RJbmRleD1kLmxhc3RJbmRleCxlfXZhciBpdT1udSxHcj1GZSxLcj1Hcj9Hci5wcm90b3R5cGU6dm9pZCAwLEhyPUtyP0tyLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIHN1KGQpe3JldHVybiBIcj9PYmplY3QoSHIuY2FsbChkKSk6e319dmFyIG91PXN1LGF1PXRyO2Z1bmN0aW9uIGx1KGQsZSl7dmFyIHQ9ZT9hdShkLmJ1ZmZlcik6ZC5idWZmZXI7cmV0dXJuIG5ldyBkLmNvbnN0cnVjdG9yKHQsZC5ieXRlT2Zmc2V0LGQubGVuZ3RoKX12YXIgY3U9bHUsdXU9dHIsZnU9ZXUsaHU9aXUsZHU9b3UsZ3U9Y3UsbXU9IltvYmplY3QgQm9vbGVhbl0iLHZ1PSJbb2JqZWN0IERhdGVdIixwdT0iW29iamVjdCBNYXBdIix5dT0iW29iamVjdCBOdW1iZXJdIix4dT0iW29iamVjdCBSZWdFeHBdIixPdT0iW29iamVjdCBTZXRdIixQdT0iW29iamVjdCBTdHJpbmddIixidT0iW29iamVjdCBTeW1ib2xdIixTdT0iW29iamVjdCBBcnJheUJ1ZmZlcl0iLE11PSJbb2JqZWN0IERhdGFWaWV3XSIsVHU9IltvYmplY3QgRmxvYXQzMkFycmF5XSIsRXU9IltvYmplY3QgRmxvYXQ2NEFycmF5XSIsQXU9IltvYmplY3QgSW50OEFycmF5XSIsQ3U9IltvYmplY3QgSW50MTZBcnJheV0iLFJ1PSJbb2JqZWN0IEludDMyQXJyYXldIixJdT0iW29iamVjdCBVaW50OEFycmF5XSIsTHU9IltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIixEdT0iW29iamVjdCBVaW50MTZBcnJheV0iLHd1PSJbb2JqZWN0IFVpbnQzMkFycmF5XSI7ZnVuY3Rpb24gTnUoZCxlLHQpe3ZhciByPWQuY29uc3RydWN0b3I7c3dpdGNoKGUpe2Nhc2UgU3U6cmV0dXJuIHV1KGQpO2Nhc2UgbXU6Y2FzZSB2dTpyZXR1cm4gbmV3IHIoK2QpO2Nhc2UgTXU6cmV0dXJuIGZ1KGQsdCk7Y2FzZSBUdTpjYXNlIEV1OmNhc2UgQXU6Y2FzZSBDdTpjYXNlIFJ1OmNhc2UgSXU6Y2FzZSBMdTpjYXNlIER1OmNhc2Ugd3U6cmV0dXJuIGd1KGQsdCk7Y2FzZSBwdTpyZXR1cm4gbmV3IHI7Y2FzZSB5dTpjYXNlIFB1OnJldHVybiBuZXcgcihkKTtjYXNlIHh1OnJldHVybiBodShkKTtjYXNlIE91OnJldHVybiBuZXcgcjtjYXNlIGJ1OnJldHVybiBkdShkKX19dmFyIGp1PU51LEJ1PV90LFZyPU9iamVjdC5jcmVhdGUsV3U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKCl7fXJldHVybiBmdW5jdGlvbihlKXtpZighQnUoZSkpcmV0dXJue307aWYoVnIpcmV0dXJuIFZyKGUpO2QucHJvdG90eXBlPWU7dmFyIHQ9bmV3IGQ7cmV0dXJuIGQucHJvdG90eXBlPXZvaWQgMCx0fX0oKSxGdT1XdSxVdT1GdSx6dT1EciwkdT1IZTtmdW5jdGlvbiBHdShkKXtyZXR1cm4gdHlwZW9mIGQuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiEkdShkKT9VdSh6dShkKSk6e319dmFyIEt1PUd1LEh1PV9lLFZ1PXRlLFl1PSJbb2JqZWN0IE1hcF0iO2Z1bmN0aW9uIFh1KGQpe3JldHVybiBWdShkKSYmSHUoZCk9PVl1fXZhciBKdT1YdSxadT1KdSxRdT1HZSxZcj1LZSxYcj1ZciYmWXIuaXNNYXAsa3U9WHI/UXUoWHIpOlp1LHF1PWt1LF91PV9lLHRmPXRlLGVmPSJbb2JqZWN0IFNldF0iO2Z1bmN0aW9uIHJmKGQpe3JldHVybiB0ZihkKSYmX3UoZCk9PWVmfXZhciBuZj1yZixzZj1uZixvZj1HZSxKcj1LZSxacj1KciYmSnIuaXNTZXQsYWY9WnI/b2YoWnIpOnNmLGxmPWFmLGNmPU1vLHVmPUVvLGZmPXhyLGhmPXlsLGRmPWpsLGdmPUJsLG1mPUZsLHZmPVFsLHBmPWNjLHlmPXBjLHhmPWJjLE9mPV9lLFBmPUpjLGJmPWp1LFNmPUt1LE1mPSRlLFRmPWJyLEVmPXF1LEFmPV90LENmPWxmLFJmPVZlLElmPVllLExmPTEsRGY9Mix3Zj00LFFyPSJbb2JqZWN0IEFyZ3VtZW50c10iLE5mPSJbb2JqZWN0IEFycmF5XSIsamY9IltvYmplY3QgQm9vbGVhbl0iLEJmPSJbb2JqZWN0IERhdGVdIixXZj0iW29iamVjdCBFcnJvcl0iLGtyPSJbb2JqZWN0IEZ1bmN0aW9uXSIsRmY9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixVZj0iW29iamVjdCBNYXBdIix6Zj0iW29iamVjdCBOdW1iZXJdIixxcj0iW29iamVjdCBPYmplY3RdIiwkZj0iW29iamVjdCBSZWdFeHBdIixHZj0iW29iamVjdCBTZXRdIixLZj0iW29iamVjdCBTdHJpbmddIixIZj0iW29iamVjdCBTeW1ib2xdIixWZj0iW29iamVjdCBXZWFrTWFwXSIsWWY9IltvYmplY3QgQXJyYXlCdWZmZXJdIixYZj0iW29iamVjdCBEYXRhVmlld10iLEpmPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLFpmPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFFmPSJbb2JqZWN0IEludDhBcnJheV0iLGtmPSJbb2JqZWN0IEludDE2QXJyYXldIixxZj0iW29iamVjdCBJbnQzMkFycmF5XSIsX2Y9IltvYmplY3QgVWludDhBcnJheV0iLHRoPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsZWg9IltvYmplY3QgVWludDE2QXJyYXldIixyaD0iW29iamVjdCBVaW50MzJBcnJheV0iLHd0PXt9O3d0W1FyXT13dFtOZl09d3RbWWZdPXd0W1hmXT13dFtqZl09d3RbQmZdPXd0W0pmXT13dFtaZl09d3RbUWZdPXd0W2tmXT13dFtxZl09d3RbVWZdPXd0W3pmXT13dFtxcl09d3RbJGZdPXd0W0dmXT13dFtLZl09d3RbSGZdPXd0W19mXT13dFt0aF09d3RbZWhdPXd0W3JoXT0hMCx3dFtXZl09d3Rba3JdPXd0W1ZmXT0hMTtmdW5jdGlvbiB3ZShkLGUsdCxyLG4scyl7dmFyIGwsYz1lJkxmLG89ZSZEZixmPWUmd2Y7aWYodCYmKGw9bj90KGQscixuLHMpOnQoZCkpLGwhPT12b2lkIDApcmV0dXJuIGw7aWYoIUFmKGQpKXJldHVybiBkO3ZhciB4PU1mKGQpO2lmKHgpe2lmKGw9UGYoZCksIWMpcmV0dXJuIG1mKGQsbCl9ZWxzZXt2YXIgZz1PZihkKSx5PWc9PWtyfHxnPT1GZjtpZihUZihkKSlyZXR1cm4gZ2YoZCxjKTtpZihnPT1xcnx8Zz09UXJ8fHkmJiFuKXtpZihsPW98fHk/e306U2YoZCksIWMpcmV0dXJuIG8/cGYoZCxkZihsLGQpKTp2ZihkLGhmKGwsZCkpfWVsc2V7aWYoIXd0W2ddKXJldHVybiBuP2Q6e307bD1iZihkLGcsYyl9fXN8fChzPW5ldyBjZik7dmFyIG09cy5nZXQoZCk7aWYobSlyZXR1cm4gbTtzLnNldChkLGwpLENmKGQpP2QuZm9yRWFjaChmdW5jdGlvbih2KXtsLmFkZCh3ZSh2LGUsdCx2LGQscykpfSk6RWYoZCkmJmQuZm9yRWFjaChmdW5jdGlvbih2LFApe2wuc2V0KFAsd2UodixlLHQsUCxkLHMpKX0pO3ZhciBUPWY/bz94Zjp5ZjpvP0lmOlJmLE89eD92b2lkIDA6VChkKTtyZXR1cm4gdWYoT3x8ZCxmdW5jdGlvbih2LFApe08mJihQPXYsdj1kW1BdKSxmZihsLFAsd2UodixlLHQsUCxkLHMpKX0pLGx9dmFyIG5oPXdlLGloPW5oLHNoPTEsb2g9NDtmdW5jdGlvbiBhaChkKXtyZXR1cm4gaWgoZCxzaHxvaCl9dmFyIGxoPWFoLFl0PXBlKGxoKSxfcjsoZnVuY3Rpb24oZCl7ZFtkLnBlZGRpbmc9MF09InBlZGRpbmciLGRbZC5tb3VudGVkPTFdPSJtb3VudGVkIixkW2QudXBkYXRlPTJdPSJ1cGRhdGUiLGRbZC51bm1vdW50ZWQ9M109InVubW91bnRlZCJ9KShfcnx8KF9yPXt9KSk7dmFyIHp0OyhmdW5jdGlvbihkKXtkW2QuTm9ybWFsPTBdPSJOb3JtYWwiLGRbZC5TdHJva2U9MV09IlN0cm9rZSIsZFtkLkRvdHRlZD0yXT0iRG90dGVkIixkW2QuTG9uZ0RvdHRlZD0zXT0iTG9uZ0RvdHRlZCJ9KSh6dHx8KHp0PXt9KSk7dmFyIHRuOyhmdW5jdGlvbihkKXtkLlRyaWFuZ2xlPSJ0cmlhbmdsZSIsZC5SaG9tYnVzPSJyaG9tYnVzIixkLlBlbnRhZ3JhbT0icGVudGFncmFtIixkLlNwZWVjaEJhbGxvb249InNwZWVjaEJhbGxvb24iLGQuU3Rhcj0ic3RhciIsZC5Qb2x5Z29uPSJwb2x5Z29uIn0pKHRufHwodG49e30pKTt2YXIgQ3Q7KGZ1bmN0aW9uKGQpe2QuTm9uZT0iTm9uZSIsZC5TaG93RmxvYXRCYXI9IlNob3dGbG9hdEJhciIsZC5aSW5kZXhGbG9hdEJhcj0iWkluZGV4RmxvYXRCYXIiLGQuRGVsZXRlTm9kZT0iRGVsZXRlTm9kZSIsZC5Db3B5Tm9kZT0iQ29weU5vZGUiLGQuWkluZGV4QWN0aXZlPSJaSW5kZXhBY3RpdmUiLGQuWkluZGV4Tm9kZT0iWkluZGV4Tm9kZSIsZC5Sb3RhdGVOb2RlPSJSb3RhdGVOb2RlIixkLlNldENvbG9yTm9kZT0iU2V0Q29sb3JOb2RlIixkLlRyYW5zbGF0ZU5vZGU9IlRyYW5zbGF0ZU5vZGUiLGQuU2NhbGVOb2RlPSJTY2FsZU5vZGUiLGQuT3JpZ2luYWxFdmVudD0iT3JpZ2luYWxFdmVudCIsZC5DcmVhdGVTY2VuZT0iQ3JlYXRlU2NlbmUiLGQuQWN0aXZlQ3Vyc29yPSJBY3RpdmVDdXJzb3IiLGQuTW92ZUN1cnNvcj0iTW92ZUN1cnNvciIsZC5Db21tYW5kRWRpdG9yPSJDb21tYW5kRWRpdG9yIixkLlNldEVkaXRvckRhdGE9IlNldEVkaXRvckRhdGEiLGQuU2V0Rm9udFN0eWxlPSJTZXRGb250U3R5bGUiLGQuU2V0UG9pbnQ9IlNldFBvaW50In0pKEN0fHwoQ3Q9e30pKTt2YXIgZW47KGZ1bmN0aW9uKGQpe2QuRGlzcGxheVN0YXRlPSJEaXNwbGF5U3RhdGUiLGQuRmxvYXRCYXI9IkZsb2F0QmFyIixkLkNhbnZhc1NlbGVjdG9yPSJDYW52YXNTZWxlY3RvciIsZC5NYWluRW5naW5lPSJNYWluRW5naW5lIixkLkRpc3BsYXlDb250YWluZXI9IkRpc3BsYXlDb250YWluZXIiLGQuQ3Vyc29yPSJDdXJzb3IiLGQuVGV4dEVkaXRvcj0iVGV4dEVkaXRvciIsZC5CaW5kTWFpblZpZXc9IkJpbmRNYWluVmlldyIsZC5Nb3VudE1haW5WaWV3PSJNb3VudE1haW5WaWV3IixkLk1vdW50QXBwVmlldz0iTW91bnRBcHBWaWV3In0pKGVufHwoZW49e30pKTt2YXIgcm47KGZ1bmN0aW9uKGQpe2RbZC5NYWluVmlldz0wXT0iTWFpblZpZXciLGRbZC5QbHVnaW49MV09IlBsdWdpbiIsZFtkLkJvdGg9Ml09IkJvdGgifSkocm58fChybj17fSkpO3ZhciB2dDsoZnVuY3Rpb24oZCl7ZFtkLlBlbmNpbD0xXT0iUGVuY2lsIixkW2QuRXJhc2VyPTJdPSJFcmFzZXIiLGRbZC5TZWxlY3Rvcj0zXT0iU2VsZWN0b3IiLGRbZC5DbGlja2VyPTRdPSJDbGlja2VyIixkW2QuQXJyb3c9NV09IkFycm93IixkW2QuSGFuZD02XT0iSGFuZCIsZFtkLkxhc2VyUGVuPTddPSJMYXNlclBlbiIsZFtkLlRleHQ9OF09IlRleHQiLGRbZC5TdHJhaWdodD05XT0iU3RyYWlnaHQiLGRbZC5SZWN0YW5nbGU9MTBdPSJSZWN0YW5nbGUiLGRbZC5FbGxpcHNlPTExXT0iRWxsaXBzZSIsZFtkLlN0YXI9MTJdPSJTdGFyIixkW2QuVHJpYW5nbGU9MTNdPSJUcmlhbmdsZSIsZFtkLlJob21idXM9MTRdPSJSaG9tYnVzIixkW2QuUG9seWdvbj0xNV09IlBvbHlnb24iLGRbZC5TcGVlY2hCYWxsb29uPTE2XT0iU3BlZWNoQmFsbG9vbiJ9KSh2dHx8KHZ0PXt9KSk7dmFyIFB0OyhmdW5jdGlvbihkKXtkW2QuTG9jYWw9MV09IkxvY2FsIixkW2QuU2VydmljZT0yXT0iU2VydmljZSIsZFtkLldvcmtlcj0zXT0iV29ya2VyIn0pKFB0fHwoUHQ9e30pKTt2YXIgSXQ7KGZ1bmN0aW9uKGQpe2RbZC5QZW5kaW5nPTBdPSJQZW5kaW5nIixkW2QuU3RhcnQ9MV09IlN0YXJ0IixkW2QuRG9pbmc9Ml09IkRvaW5nIixkW2QuRG9uZT0zXT0iRG9uZSIsZFtkLkZyZWV6ZT00XT0iRnJlZXplIixkW2QuVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KShJdHx8KEl0PXt9KSk7dmFyIHV0OyhmdW5jdGlvbihkKXtkW2QuSW5pdD0wXT0iSW5pdCIsZFtkLlVwZGF0ZUNhbWVyYT0xXT0iVXBkYXRlQ2FtZXJhIixkW2QuVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixkW2QuQ3JlYXRlV29yaz0zXT0iQ3JlYXRlV29yayIsZFtkLkRyYXdXb3JrPTRdPSJEcmF3V29yayIsZFtkLkZ1bGxXb3JrPTVdPSJGdWxsV29yayIsZFtkLlVwZGF0ZU5vZGU9Nl09IlVwZGF0ZU5vZGUiLGRbZC5SZW1vdmVOb2RlPTddPSJSZW1vdmVOb2RlIixkW2QuQ2xlYXI9OF09IkNsZWFyIixkW2QuU2VsZWN0PTldPSJTZWxlY3QiLGRbZC5EZXN0cm95PTEwXT0iRGVzdHJveSIsZFtkLk5vbmU9MTFdPSJOb25lIixkW2QuU25hcHNob3Q9MTJdPSJTbmFwc2hvdCIsZFtkLkJvdW5kaW5nQm94PTEzXT0iQm91bmRpbmdCb3giLGRbZC5DdXJzb3I9MTRdPSJDdXJzb3IiLGRbZC5UZXh0VXBkYXRlPTE1XT0iVGV4dFVwZGF0ZSIsZFtkLkdldFRleHRBY3RpdmU9MTZdPSJHZXRUZXh0QWN0aXZlIixkW2QuVGFza3NRdWV1ZT0xN109IlRhc2tzUXVldWUifSkodXR8fCh1dD17fSkpO3ZhciBubjsoZnVuY3Rpb24oZCl7ZC5XZWJnbDI9IndlYmdsMiIsZC5XZWJnbD0id2ViZ2wiLGQuQ2FudmFzMmQ9IjJkIn0pKG5ufHwobm49e30pKTt2YXIgeHQ7KGZ1bmN0aW9uKGQpe2RbZC5GbG9hdD0xXT0iRmxvYXQiLGRbZC5CZz0yXT0iQmciLGRbZC5TZWxlY3Rvcj0zXT0iU2VsZWN0b3IiLGRbZC5Ob25lPTRdPSJOb25lIn0pKHh0fHwoeHQ9e30pKTt2YXIgc247KGZ1bmN0aW9uKGQpe2RbZC5DdXJzb3I9MV09IkN1cnNvciIsZFtkLlRleHRDcmVhdGU9Ml09IlRleHRDcmVhdGUifSkoc258fChzbj17fSkpO3ZhciBvbjsoZnVuY3Rpb24oZCl7ZFtkLlRvcD0xXT0iVG9wIixkW2QuQm90dG9tPTJdPSJCb3R0b20ifSkob258fChvbj17fSkpO3ZhciBLdDsoZnVuY3Rpb24oZCl7ZFtkLm5vbmU9MV09Im5vbmUiLGRbZC5hbGw9Ml09ImFsbCIsZFtkLmJvdGg9M109ImJvdGgifSkoS3R8fChLdD17fSkpO2NsYXNzIFF0e2NvbnN0cnVjdG9yKCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pfXJlZ2lzdGVyRm9yV29ya2VyKGUsdCl7cmV0dXJuIHRoaXMubG9jYWxXb3JrPWUsdGhpcy5zZXJ2aWNlV29yaz10LHRoaXN9fWNvbnN0IGNoPXtsaW5lYXI6ZD0+ZCxlYXNlSW5RdWFkOmQ9PmQqZCxlYXNlT3V0UXVhZDpkPT5kKigyLWQpLGVhc2VJbk91dFF1YWQ6ZD0+ZDwuNT8yKmQqZDotMSsoNC0yKmQpKmQsZWFzZUluQ3ViaWM6ZD0+ZCpkKmQsZWFzZU91dEN1YmljOmQ9Pi0tZCpkKmQrMSxlYXNlSW5PdXRDdWJpYzpkPT5kPC41PzQqZCpkKmQ6KGQtMSkqKDIqZC0yKSooMipkLTIpKzEsZWFzZUluUXVhcnQ6ZD0+ZCpkKmQqZCxlYXNlT3V0UXVhcnQ6ZD0+MS0gLS1kKmQqZCpkLGVhc2VJbk91dFF1YXJ0OmQ9PmQ8LjU/OCpkKmQqZCpkOjEtOCotLWQqZCpkKmQsZWFzZUluUXVpbnQ6ZD0+ZCpkKmQqZCpkLGVhc2VPdXRRdWludDpkPT4xKy0tZCpkKmQqZCpkLGVhc2VJbk91dFF1aW50OmQ9PmQ8LjU/MTYqZCpkKmQqZCpkOjErMTYqLS1kKmQqZCpkKmQsZWFzZUluU2luZTpkPT4xLU1hdGguY29zKGQqTWF0aC5QSS8yKSxlYXNlT3V0U2luZTpkPT5NYXRoLnNpbihkKk1hdGguUEkvMiksZWFzZUluT3V0U2luZTpkPT4tKE1hdGguY29zKE1hdGguUEkqZCktMSkvMixlYXNlSW5FeHBvOmQ9PmQ8PTA/MDpNYXRoLnBvdygyLDEwKmQtMTApLGVhc2VPdXRFeHBvOmQ9PmQ+PTE/MToxLU1hdGgucG93KDIsLTEwKmQpLGVhc2VJbk91dEV4cG86ZD0+ZDw9MD8wOmQ+PTE/MTpkPC41P01hdGgucG93KDIsMjAqZC0xMCkvMjooMi1NYXRoLnBvdygyLC0yMCpkKzEwKSkvMn07Y2xhc3MgX3tjb25zdHJ1Y3RvcihlPTAsdD0wLHI9MSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyfSl9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldHooZSl7cmV0dXJuIHRoaXMuej1lLHRoaXN9c2V0WFkoZT10aGlzLngsdD10aGlzLnkpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxyPXRoaXMueil7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9c2V0VG8oe3g6ZT0wLHk6dD0wLHo6cj0xfSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9cm90KGUpe2lmKGU9PT0wKXJldHVybiB0aGlzO2NvbnN0e3g6dCx5OnJ9PXRoaXMsbj1NYXRoLnNpbihlKSxzPU1hdGguY29zKGUpO3JldHVybiB0aGlzLng9dCpzLXIqbix0aGlzLnk9dCpuK3Iqcyx0aGlzfXJvdFdpdGgoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztjb25zdCByPXRoaXMueC1lLngsbj10aGlzLnktZS55LHM9TWF0aC5zaW4odCksbD1NYXRoLmNvcyh0KTtyZXR1cm4gdGhpcy54PWUueCsocipsLW4qcyksdGhpcy55PWUueSsocipzK24qbCksdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpyfT10aGlzO3JldHVybiBuZXcgXyhlLHQscil9c3ViKGUpe3JldHVybiB0aGlzLngtPWUueCx0aGlzLnktPWUueSx0aGlzfXN1YlhZKGUsdCl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPXQsdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpc31hZGQoZSl7cmV0dXJuIHRoaXMueCs9ZS54LHRoaXMueSs9ZS55LHRoaXN9YWRkWFkoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9dCx0aGlzfWFkZFNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9ZSx0aGlzfWNsYW1wKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsZSksdGhpcy55PU1hdGgubWF4KHRoaXMueSxlKSx0IT09dm9pZCAwJiYodGhpcy54PU1hdGgubWluKHRoaXMueCx0KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQpKSx0aGlzfWRpdihlKXtyZXR1cm4gdGhpcy54Lz1lLHRoaXMueS89ZSx0aGlzfWRpdlYoZSl7cmV0dXJuIHRoaXMueC89ZS54LHRoaXMueS89ZS55LHRoaXN9bXVsKGUpe3JldHVybiB0aGlzLngqPWUsdGhpcy55Kj1lLHRoaXN9bXVsVihlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpc31hYnMoKXtyZXR1cm4gdGhpcy54PU1hdGguYWJzKHRoaXMueCksdGhpcy55PU1hdGguYWJzKHRoaXMueSksdGhpc31udWRnZShlLHQpe2NvbnN0IHI9Xy5UYW4oZSx0aGlzKTtyZXR1cm4gdGhpcy5hZGQoci5tdWwodCkpfW5lZygpe3JldHVybiB0aGlzLngqPS0xLHRoaXMueSo9LTEsdGhpc31jcm9zcyhlKXtyZXR1cm4gdGhpcy54PXRoaXMueSplLnotdGhpcy56KmUueSx0aGlzLnk9dGhpcy56KmUueC10aGlzLngqZS56LHRoaXN9ZHByKGUpe3JldHVybiBfLkRwcih0aGlzLGUpfWNwcihlKXtyZXR1cm4gXy5DcHIodGhpcyxlKX1sZW4yKCl7cmV0dXJuIF8uTGVuMih0aGlzKX1sZW4oKXtyZXR1cm4gXy5MZW4odGhpcyl9cHJ5KGUpe3JldHVybiBfLlByeSh0aGlzLGUpfXBlcigpe2NvbnN0e3g6ZSx5OnR9PXRoaXM7cmV0dXJuIHRoaXMueD10LHRoaXMueT0tZSx0aGlzfXVuaSgpe3JldHVybiBfLlVuaSh0aGlzKX10YW4oZSl7cmV0dXJuIF8uVGFuKHRoaXMsZSl9ZGlzdChlKXtyZXR1cm4gXy5EaXN0KHRoaXMsZSl9ZGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCl7cmV0dXJuIF8uRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCx0aGlzKX1zbG9wZShlKXtyZXR1cm4gXy5TbG9wZSh0aGlzLGUpfXNuYXBUb0dyaWQoZSl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueC9lKSplLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueS9lKSplLHRoaXN9YW5nbGUoZSl7cmV0dXJuIF8uQW5nbGUodGhpcyxlKX10b0FuZ2xlKCl7cmV0dXJuIF8uVG9BbmdsZSh0aGlzKX1scnAoZSx0KXtyZXR1cm4gdGhpcy54PXRoaXMueCsoZS54LXRoaXMueCkqdCx0aGlzLnk9dGhpcy55KyhlLnktdGhpcy55KSp0LHRoaXN9ZXF1YWxzKGUsdCl7cmV0dXJuIF8uRXF1YWxzKHRoaXMsZSx0KX1lcXVhbHNYWShlLHQpe3JldHVybiBfLkVxdWFsc1hZKHRoaXMsZSx0KX1ub3JtKCl7Y29uc3QgZT10aGlzLmxlbigpO3JldHVybiB0aGlzLng9ZT09PTA/MDp0aGlzLngvZSx0aGlzLnk9ZT09PTA/MDp0aGlzLnkvZSx0aGlzfXRvRml4ZWQoKXtyZXR1cm4gXy5Ub0ZpeGVkKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuIF8uVG9TdHJpbmcoXy5Ub0ZpeGVkKHRoaXMpKX10b0pzb24oKXtyZXR1cm4gXy5Ub0pzb24odGhpcyl9dG9BcnJheSgpe3JldHVybiBfLlRvQXJyYXkodGhpcyl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgXyhlLngrdC54LGUueSt0LnkpfXN0YXRpYyBBZGRYWShlLHQscil7cmV0dXJuIG5ldyBfKGUueCt0LGUueStyKX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBfKGUueC10LngsZS55LXQueSl9c3RhdGljIFN1YlhZKGUsdCxyKXtyZXR1cm4gbmV3IF8oZS54LXQsZS55LXIpfXN0YXRpYyBBZGRTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IF8oZS54K3QsZS55K3QpfXN0YXRpYyBTdWJTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IF8oZS54LXQsZS55LXQpfXN0YXRpYyBEaXYoZSx0KXtyZXR1cm4gbmV3IF8oZS54L3QsZS55L3QpfXN0YXRpYyBNdWwoZSx0KXtyZXR1cm4gbmV3IF8oZS54KnQsZS55KnQpfXN0YXRpYyBEaXZWKGUsdCl7cmV0dXJuIG5ldyBfKGUueC90LngsZS55L3QueSl9c3RhdGljIE11bFYoZSx0KXtyZXR1cm4gbmV3IF8oZS54KnQueCxlLnkqdC55KX1zdGF0aWMgTmVnKGUpe3JldHVybiBuZXcgXygtZS54LC1lLnkpfXN0YXRpYyBQZXIoZSl7cmV0dXJuIG5ldyBfKGUueSwtZS54KX1zdGF0aWMgRGlzdDIoZSx0KXtyZXR1cm4gXy5TdWIoZSx0KS5sZW4yKCl9c3RhdGljIEFicyhlKXtyZXR1cm4gbmV3IF8oTWF0aC5hYnMoZS54KSxNYXRoLmFicyhlLnkpKX1zdGF0aWMgRGlzdChlLHQpe3JldHVybiBNYXRoLmh5cG90KGUueS10LnksZS54LXQueCl9c3RhdGljIERwcihlLHQpe3JldHVybiBlLngqdC54K2UueSp0Lnl9c3RhdGljIENyb3NzKGUsdCl7cmV0dXJuIG5ldyBfKGUueSp0LnotZS56KnQueSxlLnoqdC54LWUueCp0LnopfXN0YXRpYyBDcHIoZSx0KXtyZXR1cm4gZS54KnQueS10LngqZS55fXN0YXRpYyBMZW4yKGUpe3JldHVybiBlLngqZS54K2UueSplLnl9c3RhdGljIExlbihlKXtyZXR1cm4gTWF0aC5oeXBvdChlLngsZS55KX1zdGF0aWMgUHJ5KGUsdCl7cmV0dXJuIF8uRHByKGUsdCkvXy5MZW4odCl9c3RhdGljIFVuaShlKXtyZXR1cm4gXy5EaXYoZSxfLkxlbihlKSl9c3RhdGljIFRhbihlLHQpe3JldHVybiBfLlVuaShfLlN1YihlLHQpKX1zdGF0aWMgTWluKGUsdCl7cmV0dXJuIG5ldyBfKE1hdGgubWluKGUueCx0LngpLE1hdGgubWluKGUueSx0LnkpKX1zdGF0aWMgTWF4KGUsdCl7cmV0dXJuIG5ldyBfKE1hdGgubWF4KGUueCx0LngpLE1hdGgubWF4KGUueSx0LnkpKX1zdGF0aWMgRnJvbShlKXtyZXR1cm4gbmV3IF8oKS5hZGQoZSl9c3RhdGljIEZyb21BcnJheShlKXtyZXR1cm4gbmV3IF8oZVswXSxlWzFdKX1zdGF0aWMgUm90KGUsdD0wKXtjb25zdCByPU1hdGguc2luKHQpLG49TWF0aC5jb3ModCk7cmV0dXJuIG5ldyBfKGUueCpuLWUueSpyLGUueCpyK2UueSpuKX1zdGF0aWMgUm90V2l0aChlLHQscil7Y29uc3Qgbj1lLngtdC54LHM9ZS55LXQueSxsPU1hdGguc2luKHIpLGM9TWF0aC5jb3Mocik7cmV0dXJuIG5ldyBfKHQueCsobipjLXMqbCksdC55KyhuKmwrcypjKSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQscil7cmV0dXJuIF8uTXVsKHQsXy5TdWIocixlKS5wcnkodCkpLmFkZChlKX1zdGF0aWMgTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQscixuPSEwKXtjb25zdCBzPV8uVGFuKHQsZSksbD1fLkFkZChlLF8uTXVsKHMsXy5TdWIocixlKS5wcnkocykpKTtpZihuKXtpZihsLng8TWF0aC5taW4oZS54LHQueCkpcmV0dXJuIF8uQ2FzdChlLng8dC54P2U6dCk7aWYobC54Pk1hdGgubWF4KGUueCx0LngpKXJldHVybiBfLkNhc3QoZS54PnQueD9lOnQpO2lmKGwueTxNYXRoLm1pbihlLnksdC55KSlyZXR1cm4gXy5DYXN0KGUueTx0Lnk/ZTp0KTtpZihsLnk+TWF0aC5tYXgoZS55LHQueSkpcmV0dXJuIF8uQ2FzdChlLnk+dC55P2U6dCl9cmV0dXJuIGx9c3RhdGljIERpc3RhbmNlVG9MaW5lVGhyb3VnaFBvaW50KGUsdCxyKXtyZXR1cm4gXy5EaXN0KHIsXy5OZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LHIpKX1zdGF0aWMgRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCxyLG49ITApe3JldHVybiBfLkRpc3QocixfLk5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoZSx0LHIsbikpfXN0YXRpYyBTbmFwKGUsdD0xKXtyZXR1cm4gbmV3IF8oTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX1zdGF0aWMgQ2FzdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIF8/ZTpfLkZyb20oZSl9c3RhdGljIFNsb3BlKGUsdCl7cmV0dXJuIGUueD09PXQueT9OYU46KGUueS10LnkpLyhlLngtdC54KX1zdGF0aWMgQW5nbGUoZSx0KXtyZXR1cm4gTWF0aC5hdGFuMih0LnktZS55LHQueC1lLngpfXN0YXRpYyBMcnAoZSx0LHIpe3JldHVybiBfLlN1Yih0LGUpLm11bChyKS5hZGQoZSl9c3RhdGljIE1lZChlLHQpe3JldHVybiBuZXcgXygoZS54K3QueCkvMiwoZS55K3QueSkvMil9c3RhdGljIEVxdWFscyhlLHQscj0xZS00KXtyZXR1cm4gTWF0aC5hYnMoZS54LXQueCk8ciYmTWF0aC5hYnMoZS55LXQueSk8cn1zdGF0aWMgRXF1YWxzWFkoZSx0LHIpe3JldHVybiBlLng9PT10JiZlLnk9PT1yfXN0YXRpYyBFcXVhbHNYWVooZSx0LHI9MWUtNCl7cmV0dXJuIF8uRXF1YWxzKGUsdCxyKSYmTWF0aC5hYnMoKGUuenx8MCktKHQuenx8MCkpPHJ9c3RhdGljIENsb2Nrd2lzZShlLHQscil7cmV0dXJuKHIueC1lLngpKih0LnktZS55KS0odC54LWUueCkqKHIueS1lLnkpPDB9c3RhdGljIFJlc2NhbGUoZSx0KXtjb25zdCByPV8uTGVuKGUpO3JldHVybiBuZXcgXyh0KmUueC9yLHQqZS55L3IpfXN0YXRpYyBTY2FsZVdpdGhPcmlnaW4oZSx0LHIpe3JldHVybiBfLlN1YihlLHIpLm11bCh0KS5hZGQocil9c3RhdGljIFNjYWxlV09yaWdpbihlLHQscil7cmV0dXJuIF8uU3ViKGUscikubXVsVih0KS5hZGQocil9c3RhdGljIFRvRml4ZWQoZSx0PTIpe3JldHVybiBuZXcgXygrZS54LnRvRml4ZWQodCksK2UueS50b0ZpeGVkKHQpLCtlLnoudG9GaXhlZCh0KSl9c3RhdGljIE51ZGdlKGUsdCxyKXtyZXR1cm4gXy5BZGQoZSxfLlRhbih0LGUpLm11bChyKSl9c3RhdGljIFRvU3RyaW5nKGUpe3JldHVybmAke2UueH0sICR7ZS55fWB9c3RhdGljIFRvQW5nbGUoZSl7bGV0IHQ9TWF0aC5hdGFuMihlLnksZS54KTtyZXR1cm4gdDwwJiYodCs9TWF0aC5QSSoyKSx0fXN0YXRpYyBGcm9tQW5nbGUoZSx0PTEpe3JldHVybiBuZXcgXyhNYXRoLmNvcyhlKSp0LE1hdGguc2luKGUpKnQpfXN0YXRpYyBUb0FycmF5KGUpe3JldHVybltlLngsZS55LGUuel19c3RhdGljIFRvSnNvbihlKXtjb25zdHt4OnQseTpyLHo6bn09ZTtyZXR1cm57eDp0LHk6cix6Om59fXN0YXRpYyBBdmVyYWdlKGUpe2NvbnN0IHQ9ZS5sZW5ndGgscj1uZXcgXygwLDApO2ZvcihsZXQgbj0wO248dDtuKyspci5hZGQoZVtuXSk7cmV0dXJuIHIuZGl2KHQpfXN0YXRpYyBDbGFtcChlLHQscil7cmV0dXJuIHI9PT12b2lkIDA/bmV3IF8oTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkpKTpuZXcgXyhNYXRoLm1pbihNYXRoLm1heChlLngsdCksciksTWF0aC5taW4oTWF0aC5tYXgoZS55LHQpLHIpKX1zdGF0aWMgUG9pbnRzQmV0d2VlbihlLHQscj02KXtjb25zdCBuPVtdO2ZvcihsZXQgcz0wO3M8cjtzKyspe2NvbnN0IGw9Y2guZWFzZUluUXVhZChzLyhyLTEpKSxjPV8uTHJwKGUsdCxsKTtjLno9TWF0aC5taW4oMSwuNStNYXRoLmFicyguNS11aChsKSkqLjY1KSxuLnB1c2goYyl9cmV0dXJuIG59c3RhdGljIFNuYXBUb0dyaWQoZSx0PTgpe3JldHVybiBuZXcgXyhNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfX1jb25zdCB1aD1kPT5kPC41PzIqZCpkOi0xKyg0LTIqZCkqZDtjbGFzcyBPdCBleHRlbmRzIF97Y29uc3RydWN0b3IoZT0wLHQ9MCxyPTAsbj17eDowLHk6MH0scz0wLGw9MCl7c3VwZXIoZSx0LHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6cn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6c30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bH0pfWdldCB0aW1lc3RhbXAoKXtyZXR1cm4gdGhpcy50fWdldCBwcmVzc3VyZSgpe3JldHVybiB0aGlzLnp9Z2V0IGFuZ2xlTnVtKCl7cmV0dXJuIHRoaXMuYX1nZXQgWFkoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0QShlKXt0aGlzLmE9ZX1zZXRUKGUpe3RoaXMudD1lfXNldHYoZSl7cmV0dXJuIHRoaXMudj17eDplLngseTplLnl9LHRoaXN9c2V0KGU9dGhpcy54LHQ9dGhpcy55LHI9dGhpcy56LG49dGhpcy52LHM9dGhpcy50LGw9dGhpcy5hKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PXIsdGhpcy52PW4sdGhpcy50PXMsdGhpcy5hPWwsdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpyLHY6bix0OnMsYTpsfT10aGlzLGM9e3g6bi54LHk6bi55fTtyZXR1cm4gbmV3IE90KGUsdCxyLGMscyxsKX1kaXN0YW5jZShlKXtyZXR1cm4gT3QuR2V0RGlzdGFuY2UodGhpcyxlKX1pc05lYXIoZSx0KXtyZXR1cm4gT3QuSXNOZWFyKHRoaXMsZSx0KX1nZXRBbmdsZUJ5UG9pbnRzKGUsdCl7cmV0dXJuIE90LkdldEFuZ2xlQnlQb2ludHMoZSx0aGlzLHQpfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IE90KGUueC10LngsZS55LXQueSl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgT3QoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgR2V0RGlzdGFuY2UoZSx0KXtyZXR1cm4gT3QuTGVuKGUuY2xvbmUoKS5zdWIodCkpfXN0YXRpYyBHZXRBbmdsZUJ5UG9pbnRzKGUsdCxyKXtjb25zdCBuPXQueC1lLngscz1yLngtdC54LGw9dC55LWUueSxjPXIueS10Lnk7bGV0IG89MDtjb25zdCBmPU1hdGguc3FydChuKm4rbCpsKSx4PU1hdGguc3FydChzKnMrYypjKTtpZihmJiZ4KXtjb25zdCBnPW4qcytsKmM7bz1NYXRoLmFjb3MoZy8oZip4KSksbz1vL01hdGguUEkqMTgwO2xldCB5PW4qYy1sKnM7eT15PjA/MTotMSxvPTE4MCt5Km99cmV0dXJuIG99c3RhdGljIElzTmVhcihlLHQscil7cmV0dXJuIE90LkxlbihlLmNsb25lKCkuc3ViKHQpKTxyfXN0YXRpYyBSb3RXaXRoKGUsdCxyLG49Mil7Y29uc3Qgcz1lLngtdC54LGw9ZS55LXQueSxjPU1hdGguc2luKHIpLG89TWF0aC5jb3MociksZj1NYXRoLnBvdygxMCxuKSx4PU1hdGguZmxvb3IoKHQueCsocypvLWwqYykpKmYpL2YsZz1NYXRoLmZsb29yKCh0LnkrKHMqYytsKm8pKSpmKS9mO3JldHVybiBuZXcgT3QoeCxnKX1zdGF0aWMgR2V0RG90U3Ryb2tlKGUsdCxyPTE2KXtjb25zdCBuPW5ldyBfKDEsMSkscz1NYXRoLlBJKy4wMDEsbD1PdC5BZGQoZSxPdC5TdWIoZSxuKS51bmkoKS5wZXIoKS5tdWwoLXQpKSxjPVtdO2ZvcihsZXQgbz0xL3IsZj1vO2Y8PTE7Zis9byljLnB1c2goT3QuUm90V2l0aChsLGUscyoyKmYpKTtyZXR1cm4gY31zdGF0aWMgR2V0U2VtaWNpcmNsZVN0cm9rZShlLHQscj0tMSxuPTgpe2NvbnN0IHM9ciooTWF0aC5QSSsuMDAxKSxsPVtdO2ZvcihsZXQgYz0xL24sbz1jO288PTE7bys9YylsLnB1c2goT3QuUm90V2l0aCh0LGUscypvKSk7cmV0dXJuIGx9fWZ1bmN0aW9uIGZoKGQsZSl7cmV0dXJue3g6ZC54LWUseTpkLnktZSx3OmQudytlKjIsaDpkLmgrZSoyfX1mdW5jdGlvbiBidChkLGUpe2lmKGQmJmUpe2NvbnN0IHQ9TWF0aC5taW4oZC54LGUueCkscj1NYXRoLm1pbihkLnksZS55KSxuPU1hdGgubWF4KGQueCtkLncsZS54K2Uudykscz1NYXRoLm1heChkLnkrZC5oLGUueStlLmgpLGw9bi10LGM9cy1yO3JldHVybnt4OnQseTpyLHc6bCxoOmN9fXJldHVybiBlfHxkfWZ1bmN0aW9uIE50KGQsZT0wKXtjb25zdCB0PXt4OjAseTowLHc6MCxoOjB9O2xldCByPTEvMCxuPTEvMCxzPS0xLzAsbD0tMS8wO3JldHVybiBkLmZvckVhY2goYz0+e2NvbnN0W28sZl09Yy5YWTtyPU1hdGgubWluKHIsby1lKSxuPU1hdGgubWluKG4sZi1lKSxzPU1hdGgubWF4KHMsbytlKSxsPU1hdGgubWF4KGwsZitlKX0pLHQueD1yLHQueT1uLHQudz1zLXIsdC5oPWwtbix0fWZ1bmN0aW9uIHhlKGQsZSl7cmV0dXJuIShkLngrZC53PGUueHx8ZC54PmUueCtlLnd8fGQueStkLmg8ZS55fHxkLnk+ZS55K2UuaCl9ZnVuY3Rpb24gaGgoZCxlKXtyZXR1cm4gZC5sZW5ndGg9PT1lLmxlbmd0aCYmZC5zb3J0KCkudG9TdHJpbmcoKT09PWUuc29ydCgpLnRvU3RyaW5nKCl9ZnVuY3Rpb24gZmUoZCxlPTEwKXtyZXR1cm57eDpNYXRoLmZsb29yKGQueC1lKSx5Ok1hdGguZmxvb3IoZC55LWUpLHc6TWF0aC5mbG9vcihkLncrZSoyKSxoOk1hdGguZmxvb3IoZC5oK2UqMil9fWZ1bmN0aW9uIGFuKGQsZSl7cmV0dXJue3g6ZC54K2VbMF0seTpkLnkrZVsxXSx3OmQudyxoOmQuaH19ZnVuY3Rpb24gZGgoZCxlKXtjb25zdCB0PW5ldyBfKGQueCxkLnkpLHI9bmV3IF8oZC54K2QudyxkLnkpLG49bmV3IF8oZC54K2QudyxkLnkrZC5oKSxzPW5ldyBfKGQueCxkLnkrZC5oKSxsPW5ldyBfKGQueCtkLncvMixkLnkrZC5oLzIpLGM9TWF0aC5QSSplLzE4MCxvPV8uUm90V2l0aCh0LGwsYyksZj1fLlJvdFdpdGgocixsLGMpLHg9Xy5Sb3RXaXRoKG4sbCxjKSxnPV8uUm90V2l0aChzLGwsYyk7cmV0dXJuIE50KFtvLGYseCxnXSl9ZnVuY3Rpb24gZ2goZCxlKXtjb25zdCB0PW5ldyBfKGQueCxkLnkpLHI9bmV3IF8oZC54K2QudyxkLnkpLG49bmV3IF8oZC54K2QudyxkLnkrZC5oKSxzPW5ldyBfKGQueCxkLnkrZC5oKSxsPW5ldyBfKGQueCtkLncvMixkLnkrZC5oLzIpLGM9bmV3IF8oZVswXSxlWzFdKSxvPV8uU2NhbGVXT3JpZ2luKHQsYyxsKSxmPV8uU2NhbGVXT3JpZ2luKHIsYyxsKSx4PV8uU2NhbGVXT3JpZ2luKG4sYyxsKSxnPV8uU2NhbGVXT3JpZ2luKHMsYyxsKTtyZXR1cm4gTnQoW28sZix4LGddKX1mdW5jdGlvbiBtaChkLGUsdCl7Y29uc3Qgcj1uZXcgXyhlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248ZC5sZW5ndGg7bis9Myl7Y29uc3Qgcz1uZXcgXyhkW25dLGRbbisxXSksbD1NYXRoLlBJKnQvMTgwLGM9Xy5Sb3RXaXRoKHMscixsKTtkW25dPWMueCxkW24rMV09Yy55fX1mdW5jdGlvbiB2aChkLGUsdCl7Y29uc3Qgcj1uZXcgXyhlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248ZC5sZW5ndGg7bis9Myl7Y29uc3Qgcz1uZXcgXyhkW25dLGRbbisxXSksbD1uZXcgXyh0WzBdLHRbMV0pO2lmKG48ZC5sZW5ndGgtMyl7Y29uc3Qgbz1uZXcgXyhkW24rM10sZFtuKzRdKSxmPV8uVGFuKG8scykucGVyKCkubXVsKGRbbisyXSkubXVsVihsKS5sZW4oKTtkW24rMl09Zn1lbHNlIGlmKG49PT1kLmxlbmd0aC0zKXtjb25zdCBvPW5ldyBfKGRbbi0zXSxkW24tMl0pLGY9Xy5UYW4ocyxvKS5wZXIoKS5tdWwoZFtuKzJdKS5tdWxWKGwpLmxlbigpO2RbbisyXT1mfWNvbnN0IGM9Xy5TY2FsZVdPcmlnaW4ocyxsLHIpO2Rbbl09Yy54LGRbbisxXT1jLnl9fWZ1bmN0aW9uIHBoKGQsZSl7cmV0dXJuIGRbMF0+PWUueCYmZFswXTw9ZS54K2UudyYmZFsxXT49ZS55JiZkWzFdPD1lLnkrZS5ofWZ1bmN0aW9uIGxuKGQsZSl7Y29uc3QgdD1kPD1lPzE6ZC9lLHI9ZTw9ZD8xOmUvZDtyZXR1cm5bdCxyXX1jb25zdCBOZT1kPT57aWYoZC50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgZT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGQpLmZpbmQodD0+dC50b1N0cmluZygpPT09IlN5bWJvbChzZWFsZWQpIik7aWYoZSYmZFtlXSlyZXR1cm4hMH1yZXR1cm4hMX0sY249ZD0+ZCE9PXZ0LlRleHQ7ZnVuY3Rpb24gaGUoZCl7cmV0dXJuYCR7amUoZC54KX0sJHtqZShkLnkpfSBgfWZ1bmN0aW9uIGRlKGQsZSl7cmV0dXJuYCR7amUoKGQueCtlLngpLzIpfSwke2plKChkLnkrZS55KS8yKX0gYH1mdW5jdGlvbiBqZShkKXtyZXR1cm4rZC50b0ZpeGVkKDQpfXZhciB5aD1yZSx4aD10ZSxPaD0iW29iamVjdCBOdW1iZXJdIjtmdW5jdGlvbiBQaChkKXtyZXR1cm4gdHlwZW9mIGQ9PSJudW1iZXIifHx4aChkKSYmeWgoZCk9PU9ofXZhciBiaD1QaCxlcj1wZShiaCk7Y2xhc3MgZ3R7Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNVbml0VGltZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjFlM30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Tm9kZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KTtjb25zdHt2Tm9kZXM6dCxmdWxsTGF5ZXI6cixkcmF3TGF5ZXI6bn09ZTt0aGlzLnZOb2Rlcz10LHRoaXMuZnVsbExheWVyPXIsdGhpcy5kcmF3TGF5ZXI9bn1zZXRXb3JrSWQoZSl7dGhpcy53b3JrSWQ9ZX1nZXRXb3JrSWQoKXtyZXR1cm4gdGhpcy53b3JrSWR9Z2V0V29ya09wdGlvbnMoKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9uc31zZXRXb3JrT3B0aW9ucyhlKXt0aGlzLndvcmtPcHRpb25zPWUsdGhpcy5zeW5jVW5pdFRpbWU9ZS5zeW5jVW5pdFRpbWV8fHRoaXMuc3luY1VuaXRUaW1lfXVwZGF0YU9wdFNlcnZpY2UoZSl7dmFyIG47bGV0IHQ7Y29uc3Qgcj0obj10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOm4udG9TdHJpbmcoKTtpZihyJiZlKXtjb25zdCBzPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHIpfHx0aGlzLmRyYXdMYXllciYmdGhpcy5kcmF3TGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUocil8fFtdO2lmKHMubGVuZ3RoIT09MSlyZXR1cm47Y29uc3QgbD1zWzBdLHtwb3M6Yyx6SW5kZXg6byxzY2FsZTpmLGFuZ2xlOngsdHJhbnNsYXRlOmd9PWUseT17fTt0eXBlb2Ygbz09Im51bWJlciImJih5LnpJbmRleD1vKSxjJiYoeS5wb3M9W2NbMF0sY1sxXV0pLGYmJih5LnNjYWxlPWYpLHgmJih5LnJvdGF0ZT14KSxnJiYoeS50cmFuc2xhdGU9ZyksbC5hdHRyKHkpO2NvbnN0IG09bD09bnVsbD92b2lkIDA6bC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4gbSYmKHQ9YnQodCx7eDpNYXRoLmZsb29yKG0ueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKG0ueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKG0ud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKG0uaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfSkpLHRoaXMudk5vZGVzLnNldEluZm8ocix7cmVjdDp0LGNlbnRlclBvczpjfSksdH19c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpuLHdpbGxTZXJpYWxpemVEYXRhOnMsdGFyZ2V0Tm9kZTpsfT1lLHt6SW5kZXg6Yyx0cmFuc2xhdGU6byxhbmdsZTpmLGJveDp4LGJveFNjYWxlOmcsYm94VHJhbnNsYXRlOnkscG9pbnRNYXA6bX09cjtsZXQgVDtjb25zdCBPPWwmJll0KGwpfHxuLmdldCh0Lm5hbWUpO2lmKCFPKXJldHVybjtjJiYodC5zZXRBdHRyaWJ1dGUoInpJbmRleCIsYyksTy5vcHQuekluZGV4PWMpO2NvbnN0IHY9dC5wYXJlbnQ7aWYodil7aWYoeCYmeSYmZyl7Y29uc3R7cmVjdDpQfT1PLGk9W107Zm9yKGxldCBJPTA7STxPLm9wLmxlbmd0aDtJKz0zKWkucHVzaChuZXcgT3QoTy5vcFtJXSxPLm9wW0krMV0sTy5vcFtJKzJdKSk7Y29uc3QgdT1OdChpKSxhPVt1Lncqdi53b3JsZFNjYWxpbmdbMF0sdS5oKnYud29ybGRTY2FsaW5nWzBdXSxoPVtQLnctYVswXSxQLmgtYVsxXV0sYj1bKFAudypnWzBdLWhbMF0pL2FbMF0sKFAuaCpnWzFdLWhbMV0pL2FbMV1dLEU9W3lbMF0vdi53b3JsZFNjYWxpbmdbMF0seVsxXS92LndvcmxkU2NhbGluZ1sxXV0sQT1PLm9wLm1hcCgoSSxEKT0+e2NvbnN0IFI9RCUzO3JldHVybiBSPT09MD9JK0VbMF06Uj09PTE/SStFWzFdOkl9KSxMPVtPLmNlbnRlclBvc1swXStFWzBdLE8uY2VudGVyUG9zWzFdK0VbMV1dO3ZoKEEsTCxiKTtjb25zdCBTPVtdO2ZvcihsZXQgST0wO0k8QS5sZW5ndGg7SSs9MylTLnB1c2gobmV3IE90KEFbSV0sQVtJKzFdLEFbSSsyXSkpO08ub3A9QSxPLmNlbnRlclBvcz1MfWVsc2UgaWYobyl7Y29uc3QgUD1bb1swXS92LndvcmxkU2NhbGluZ1swXSxvWzFdL3Yud29ybGRTY2FsaW5nWzFdXTt0LnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixQKSxPLm9wdC50cmFuc2xhdGU9UCxsJiYoVD1hbihPLnJlY3QsbyksTy5yZWN0PVQpfWVsc2UgZXIoZikmJih0LnNldEF0dHJpYnV0ZSgicm90YXRlIixmKSxPLm9wdC5yb3RhdGU9ZixsJiYoVD1kaChPLnJlY3QsZiksTy5yZWN0PVQpKTtpZihtKXtjb25zdCBQPW0uZ2V0KHQubmFtZSk7aWYoUClmb3IobGV0IGk9MCx1PTA7aTxPLm9wLmxlbmd0aDtpKz0zLHUrKylPLm9wW2ldPVBbdV1bMF0sTy5vcFtpKzFdPVBbdV1bMV19aWYocyl7aWYobyl7Y29uc3QgUD1bb1swXS92LndvcmxkU2NhbGluZ1swXSxvWzFdL3Yud29ybGRTY2FsaW5nWzFdXSxpPU8ub3AubWFwKCh1LGEpPT57Y29uc3QgaD1hJTM7cmV0dXJuIGg9PT0wP3UrUFswXTpoPT09MT91K1BbMV06dX0pO08ub3A9aSxPLmNlbnRlclBvcz1bTy5jZW50ZXJQb3NbMF0rUFswXSxPLmNlbnRlclBvc1sxXStQWzFdXSxPIT1udWxsJiZPLm9wdCYmKE8ub3B0LnRyYW5zbGF0ZT12b2lkIDApfWVsc2UgaWYoZXIoZikpe2NvbnN0IFA9Ty5vcDttaChQLE8uY2VudGVyUG9zLGYpLE8ub3A9UCxPIT1udWxsJiZPLm9wdCYmKE8ub3B0LnJvdGF0ZT12b2lkIDApfX1PJiZuLnNldEluZm8odC5uYW1lLE8pfX1zdGF0aWMgZ2V0Q2VudGVyUG9zKGUsdCl7Y29uc3R7d29ybGRQb3NpdGlvbjpyLHdvcmxkU2NhbGluZzpufT10O3JldHVyblsoZS54K2Uudy8yLXJbMF0pL25bMF0sKGUueStlLmgvMi1yWzFdKS9uWzFdXX1zdGF0aWMgZ2V0UmVjdEZyb21MYXllcihlLHQpe2NvbnN0IHI9ZS5nZXRFbGVtZW50c0J5TmFtZSh0KVswXTtpZihyKXtjb25zdCBuPXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihuLngtZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihuLnktZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihuLndpZHRoK2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihuLmhlaWdodCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKX19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZ3QsIlNhZmVCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KTt2YXIgRHQ9ZnVuY3Rpb24oZCl7dmFyIGU9e307ZnVuY3Rpb24gdChyKXtpZihlW3JdKXJldHVybiBlW3JdLmV4cG9ydHM7dmFyIG49ZVtyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGRbcl0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsdCksbi5sPSEwLG4uZXhwb3J0c31yZXR1cm4gdC5tPWQsdC5jPWUsdC5kPWZ1bmN0aW9uKHIsbixzKXt0Lm8ocixuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsbix7ZW51bWVyYWJsZTohMCxnZXQ6c30pfSx0LnI9ZnVuY3Rpb24ocil7dHlwZW9mIFN5bWJvbDwidSImJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZToiTW9kdWxlIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX0sdC50PWZ1bmN0aW9uKHIsbil7aWYobiYxJiYocj10KHIpKSxuJjh8fG4mNCYmdHlwZW9mIHI9PSJvYmplY3QiJiZyJiZyLl9fZXNNb2R1bGUpcmV0dXJuIHI7dmFyIHM9T2JqZWN0LmNyZWF0ZShudWxsKTtpZih0LnIocyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnJ9KSxuJjImJnR5cGVvZiByIT0ic3RyaW5nIilmb3IodmFyIGwgaW4gcil0LmQocyxsLChmdW5jdGlvbihjKXtyZXR1cm4gcltjXX0pLmJpbmQobnVsbCxsKSk7cmV0dXJuIHN9LHQubj1mdW5jdGlvbihyKXt2YXIgbj1yJiZyLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiByfTtyZXR1cm4gdC5kKG4sImEiLG4pLG59LHQubz1mdW5jdGlvbihyLG4pe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixuKX0sdC5wPSIvanMvIix0KHQucz0wKX0oW2Z1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsInZlcnNpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwiaGVscGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJjcmVhdGVFbGVtZW50IixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImlzU3ByaXRlTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyZWdpc3Rlck5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KTt2YXIgcj10KDEyKTt0LmQoZSwiRU5WIixmdW5jdGlvbigpe3JldHVybiByLkVOVn0pO3ZhciBuPXQoNjgpO3QuZChlLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIG4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBuLmNhbmNlbEFuaW1hdGlvbkZyYW1lfSk7dmFyIHM9dCg3MCk7dC5kKGUsIk5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdH0pO3ZhciBsPXQoMjE3KTt0LmQoZSwiQ2xvdWQiLGZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH0pO3ZhciBjPXQoMjE5KTt0LmQoZSwiQmxvY2siLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pO3ZhciBvPXQoMjI0KTt0LmQoZSwiU3ByaXRlIixmdW5jdGlvbigpe3JldHVybiBvLmRlZmF1bHR9KTt2YXIgZj10KDIyNik7dC5kKGUsIlBhdGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pO3ZhciB4PXQoMjI5KTt0LmQoZSwiUmVjdCIsZnVuY3Rpb24oKXtyZXR1cm4geC5kZWZhdWx0fSk7dmFyIGc9dCgyMzEpO3QuZChlLCJUcmlhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fSk7dmFyIHk9dCgyMzYpO3QuZChlLCJQYXJhbGxlbCIsZnVuY3Rpb24oKXtyZXR1cm4geS5kZWZhdWx0fSk7dmFyIG09dCgyMzgpO3QuZChlLCJSZWd1bGFyIixmdW5jdGlvbigpe3JldHVybiBtLmRlZmF1bHR9KTt2YXIgVD10KDI0MCk7dC5kKGUsIlN0YXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFQuZGVmYXVsdH0pO3ZhciBPPXQoMjQyKTt0LmQoZSwiRWxsaXBzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTy5kZWZhdWx0fSk7dmFyIHY9dCgyNDQpO3QuZChlLCJBcmMiLGZ1bmN0aW9uKCl7cmV0dXJuIHYuZGVmYXVsdH0pO3ZhciBQPXQoMjQ2KTt0LmQoZSwiUmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gUC5kZWZhdWx0fSk7dmFyIGk9dCgyMzIpO3QuZChlLCJQb2x5bGluZSIsZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0fSk7dmFyIHU9dCgyNDgpO3QuZChlLCJMYWJlbCIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIGE9dCgyNTApO3QuZChlLCJHcm91cCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5kZWZhdWx0fSk7dmFyIGg9dCgyODYpO3QuZChlLCJMYXllciIsZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWZhdWx0fSk7dmFyIGI9dCgyODcpO3QuZChlLCJTcHJpdGVTdmciLGZ1bmN0aW9uKCl7cmV0dXJuIGIuZGVmYXVsdH0pO3ZhciBFPXQoMjg5KTt0LmQoZSwiTGF5ZXJXb3JrZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEUuZGVmYXVsdH0pO3ZhciBBPXQoMjkwKTt0LmQoZSwiU2NlbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIEEuZGVmYXVsdH0pO3ZhciBMPXQoMjEzKSxTPXQoMjIxKTt0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIFMuQ29sb3J9KSx0LmQoZSwiR3JhZGllbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIFMuR3JhZGllbnR9KTt2YXIgST10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgRD1MLmRlZmF1bHQuY3JlYXRlRWxlbWVudCxSPUwuZGVmYXVsdC5pc1Nwcml0ZU5vZGUsQz1MLmRlZmF1bHQucmVnaXN0ZXJOb2RlLGo9e3BhcnNlQ29sb3I6Uy5wYXJzZUNvbG9yLHNpemVUb1BpeGVsOkkuc2l6ZVRvUGl4ZWwsdG9BcnJheTpJLnRvQXJyYXksdG9TdHJpbmc6SS50b1N0cmluZyx0b051bWJlcjpJLnRvTnVtYmVyfTtsZXQgJDskPSIzLjguMyI7Y29uc3QgSD0kfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpO3ZhciByPXQoMik7dC5kKGUsImdsTWF0cml4IixmdW5jdGlvbigpe3JldHVybiByfSk7dmFyIG49dCgzKTt0LmQoZSwibWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciBzPXQoNCk7dC5kKGUsIm1hdDJkIixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIGw9dCg1KTt0LmQoZSwibWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciBjPXQoNik7dC5kKGUsIm1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgbz10KDcpO3QuZChlLCJxdWF0IixmdW5jdGlvbigpe3JldHVybiBvfSk7dmFyIGY9dCgxMCk7dC5kKGUsInF1YXQyIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHg9dCgxMSk7dC5kKGUsInZlYzIiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgZz10KDgpO3QuZChlLCJ2ZWMzIixmdW5jdGlvbigpe3JldHVybiBnfSk7dmFyIHk9dCg5KTt0LmQoZSwidmVjNCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJFUFNJTE9OIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsIkFSUkFZX1RZUEUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiUkFORE9NIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInNldE1hdHJpeEFycmF5VHlwZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJ0b1JhZGlhbiIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj0xZS02LG49dHlwZW9mIEZsb2F0MzJBcnJheTwidSI/RmxvYXQzMkFycmF5OkFycmF5LHM9TWF0aC5yYW5kb207ZnVuY3Rpb24gbCh4KXtuPXh9dmFyIGM9TWF0aC5QSS8xODA7ZnVuY3Rpb24gbyh4KXtyZXR1cm4geCpjfWZ1bmN0aW9uIGYoeCxnKXtyZXR1cm4gTWF0aC5hYnMoeC1nKTw9cipNYXRoLm1heCgxLE1hdGguYWJzKHgpLE1hdGguYWJzKGcpKX1NYXRoLmh5cG90fHwoTWF0aC5oeXBvdD1mdW5jdGlvbigpe2Zvcih2YXIgeD0wLGc9YXJndW1lbnRzLmxlbmd0aDtnLS07KXgrPWFyZ3VtZW50c1tnXSphcmd1bWVudHNbZ107cmV0dXJuIE1hdGguc3FydCh4KX0pfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJMRFUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBSfSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBuKCl7dmFyIEM9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihDWzFdPTAsQ1syXT0wKSxDWzBdPTEsQ1szXT0xLEN9ZnVuY3Rpb24gcyhDKXt2YXIgaj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBqWzBdPUNbMF0salsxXT1DWzFdLGpbMl09Q1syXSxqWzNdPUNbM10san1mdW5jdGlvbiBsKEMsail7cmV0dXJuIENbMF09alswXSxDWzFdPWpbMV0sQ1syXT1qWzJdLENbM109alszXSxDfWZ1bmN0aW9uIGMoQyl7cmV0dXJuIENbMF09MSxDWzFdPTAsQ1syXT0wLENbM109MSxDfWZ1bmN0aW9uIG8oQyxqLCQsSCl7dmFyIEo9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gSlswXT1DLEpbMV09aixKWzJdPSQsSlszXT1ILEp9ZnVuY3Rpb24gZihDLGosJCxILEope3JldHVybiBDWzBdPWosQ1sxXT0kLENbMl09SCxDWzNdPUosQ31mdW5jdGlvbiB4KEMsail7aWYoQz09PWope3ZhciAkPWpbMV07Q1sxXT1qWzJdLENbMl09JH1lbHNlIENbMF09alswXSxDWzFdPWpbMl0sQ1syXT1qWzFdLENbM109alszXTtyZXR1cm4gQ31mdW5jdGlvbiBnKEMsail7dmFyICQ9alswXSxIPWpbMV0sSj1qWzJdLHE9alszXSxGPSQqcS1KKkg7cmV0dXJuIEY/KEY9MS9GLENbMF09cSpGLENbMV09LUgqRixDWzJdPS1KKkYsQ1szXT0kKkYsQyk6bnVsbH1mdW5jdGlvbiB5KEMsail7dmFyICQ9alswXTtyZXR1cm4gQ1swXT1qWzNdLENbMV09LWpbMV0sQ1syXT0talsyXSxDWzNdPSQsQ31mdW5jdGlvbiBtKEMpe3JldHVybiBDWzBdKkNbM10tQ1syXSpDWzFdfWZ1bmN0aW9uIFQoQyxqLCQpe3ZhciBIPWpbMF0sSj1qWzFdLHE9alsyXSxGPWpbM10sRz0kWzBdLFo9JFsxXSx0dD0kWzJdLGV0PSRbM107cmV0dXJuIENbMF09SCpHK3EqWixDWzFdPUoqRytGKlosQ1syXT1IKnR0K3EqZXQsQ1szXT1KKnR0K0YqZXQsQ31mdW5jdGlvbiBPKEMsaiwkKXt2YXIgSD1qWzBdLEo9alsxXSxxPWpbMl0sRj1qWzNdLEc9TWF0aC5zaW4oJCksWj1NYXRoLmNvcygkKTtyZXR1cm4gQ1swXT1IKlorcSpHLENbMV09SipaK0YqRyxDWzJdPUgqLUcrcSpaLENbM109SiotRytGKlosQ31mdW5jdGlvbiB2KEMsaiwkKXt2YXIgSD1qWzBdLEo9alsxXSxxPWpbMl0sRj1qWzNdLEc9JFswXSxaPSRbMV07cmV0dXJuIENbMF09SCpHLENbMV09SipHLENbMl09cSpaLENbM109RipaLEN9ZnVuY3Rpb24gUChDLGope3ZhciAkPU1hdGguc2luKGopLEg9TWF0aC5jb3Moaik7cmV0dXJuIENbMF09SCxDWzFdPSQsQ1syXT0tJCxDWzNdPUgsQ31mdW5jdGlvbiBpKEMsail7cmV0dXJuIENbMF09alswXSxDWzFdPTAsQ1syXT0wLENbM109alsxXSxDfWZ1bmN0aW9uIHUoQyl7cmV0dXJuIm1hdDIoIitDWzBdKyIsICIrQ1sxXSsiLCAiK0NbMl0rIiwgIitDWzNdKyIpIn1mdW5jdGlvbiBhKEMpe3JldHVybiBNYXRoLmh5cG90KENbMF0sQ1sxXSxDWzJdLENbM10pfWZ1bmN0aW9uIGgoQyxqLCQsSCl7cmV0dXJuIENbMl09SFsyXS9IWzBdLCRbMF09SFswXSwkWzFdPUhbMV0sJFszXT1IWzNdLUNbMl0qJFsxXSxbQyxqLCRdfWZ1bmN0aW9uIGIoQyxqLCQpe3JldHVybiBDWzBdPWpbMF0rJFswXSxDWzFdPWpbMV0rJFsxXSxDWzJdPWpbMl0rJFsyXSxDWzNdPWpbM10rJFszXSxDfWZ1bmN0aW9uIEUoQyxqLCQpe3JldHVybiBDWzBdPWpbMF0tJFswXSxDWzFdPWpbMV0tJFsxXSxDWzJdPWpbMl0tJFsyXSxDWzNdPWpbM10tJFszXSxDfWZ1bmN0aW9uIEEoQyxqKXtyZXR1cm4gQ1swXT09PWpbMF0mJkNbMV09PT1qWzFdJiZDWzJdPT09alsyXSYmQ1szXT09PWpbM119ZnVuY3Rpb24gTChDLGope3ZhciAkPUNbMF0sSD1DWzFdLEo9Q1syXSxxPUNbM10sRj1qWzBdLEc9alsxXSxaPWpbMl0sdHQ9alszXTtyZXR1cm4gTWF0aC5hYnMoJC1GKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoJCksTWF0aC5hYnMoRikpJiZNYXRoLmFicyhILUcpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhIKSxNYXRoLmFicyhHKSkmJk1hdGguYWJzKEotWik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEopLE1hdGguYWJzKFopKSYmTWF0aC5hYnMocS10dCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHEpLE1hdGguYWJzKHR0KSl9ZnVuY3Rpb24gUyhDLGosJCl7cmV0dXJuIENbMF09alswXSokLENbMV09alsxXSokLENbMl09alsyXSokLENbM109alszXSokLEN9ZnVuY3Rpb24gSShDLGosJCxIKXtyZXR1cm4gQ1swXT1qWzBdKyRbMF0qSCxDWzFdPWpbMV0rJFsxXSpILENbMl09alsyXSskWzJdKkgsQ1szXT1qWzNdKyRbM10qSCxDfXZhciBEPVQsUj1FfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBSPW5ldyByLkFSUkFZX1RZUEUoNik7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoUlsxXT0wLFJbMl09MCxSWzRdPTAsUls1XT0wKSxSWzBdPTEsUlszXT0xLFJ9ZnVuY3Rpb24gcyhSKXt2YXIgQz1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiBDWzBdPVJbMF0sQ1sxXT1SWzFdLENbMl09UlsyXSxDWzNdPVJbM10sQ1s0XT1SWzRdLENbNV09Uls1XSxDfWZ1bmN0aW9uIGwoUixDKXtyZXR1cm4gUlswXT1DWzBdLFJbMV09Q1sxXSxSWzJdPUNbMl0sUlszXT1DWzNdLFJbNF09Q1s0XSxSWzVdPUNbNV0sUn1mdW5jdGlvbiBjKFIpe3JldHVybiBSWzBdPTEsUlsxXT0wLFJbMl09MCxSWzNdPTEsUls0XT0wLFJbNV09MCxSfWZ1bmN0aW9uIG8oUixDLGosJCxILEope3ZhciBxPW5ldyByLkFSUkFZX1RZUEUoNik7cmV0dXJuIHFbMF09UixxWzFdPUMscVsyXT1qLHFbM109JCxxWzRdPUgscVs1XT1KLHF9ZnVuY3Rpb24gZihSLEMsaiwkLEgsSixxKXtyZXR1cm4gUlswXT1DLFJbMV09aixSWzJdPSQsUlszXT1ILFJbNF09SixSWzVdPXEsUn1mdW5jdGlvbiB4KFIsQyl7dmFyIGo9Q1swXSwkPUNbMV0sSD1DWzJdLEo9Q1szXSxxPUNbNF0sRj1DWzVdLEc9aipKLSQqSDtyZXR1cm4gRz8oRz0xL0csUlswXT1KKkcsUlsxXT0tJCpHLFJbMl09LUgqRyxSWzNdPWoqRyxSWzRdPShIKkYtSipxKSpHLFJbNV09KCQqcS1qKkYpKkcsUik6bnVsbH1mdW5jdGlvbiBnKFIpe3JldHVybiBSWzBdKlJbM10tUlsxXSpSWzJdfWZ1bmN0aW9uIHkoUixDLGope3ZhciAkPUNbMF0sSD1DWzFdLEo9Q1syXSxxPUNbM10sRj1DWzRdLEc9Q1s1XSxaPWpbMF0sdHQ9alsxXSxldD1qWzJdLGl0PWpbM10saz1qWzRdLGh0PWpbNV07cmV0dXJuIFJbMF09JCpaK0oqdHQsUlsxXT1IKlorcSp0dCxSWzJdPSQqZXQrSippdCxSWzNdPUgqZXQrcSppdCxSWzRdPSQqaytKKmh0K0YsUls1XT1IKmsrcSpodCtHLFJ9ZnVuY3Rpb24gbShSLEMsail7dmFyICQ9Q1swXSxIPUNbMV0sSj1DWzJdLHE9Q1szXSxGPUNbNF0sRz1DWzVdLFo9TWF0aC5zaW4oaiksdHQ9TWF0aC5jb3Moaik7cmV0dXJuIFJbMF09JCp0dCtKKlosUlsxXT1IKnR0K3EqWixSWzJdPSQqLVorSip0dCxSWzNdPUgqLVorcSp0dCxSWzRdPUYsUls1XT1HLFJ9ZnVuY3Rpb24gVChSLEMsail7dmFyICQ9Q1swXSxIPUNbMV0sSj1DWzJdLHE9Q1szXSxGPUNbNF0sRz1DWzVdLFo9alswXSx0dD1qWzFdO3JldHVybiBSWzBdPSQqWixSWzFdPUgqWixSWzJdPUoqdHQsUlszXT1xKnR0LFJbNF09RixSWzVdPUcsUn1mdW5jdGlvbiBPKFIsQyxqKXt2YXIgJD1DWzBdLEg9Q1sxXSxKPUNbMl0scT1DWzNdLEY9Q1s0XSxHPUNbNV0sWj1qWzBdLHR0PWpbMV07cmV0dXJuIFJbMF09JCxSWzFdPUgsUlsyXT1KLFJbM109cSxSWzRdPSQqWitKKnR0K0YsUls1XT1IKlorcSp0dCtHLFJ9ZnVuY3Rpb24gdihSLEMpe3ZhciBqPU1hdGguc2luKEMpLCQ9TWF0aC5jb3MoQyk7cmV0dXJuIFJbMF09JCxSWzFdPWosUlsyXT0taixSWzNdPSQsUls0XT0wLFJbNV09MCxSfWZ1bmN0aW9uIFAoUixDKXtyZXR1cm4gUlswXT1DWzBdLFJbMV09MCxSWzJdPTAsUlszXT1DWzFdLFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiBpKFIsQyl7cmV0dXJuIFJbMF09MSxSWzFdPTAsUlsyXT0wLFJbM109MSxSWzRdPUNbMF0sUls1XT1DWzFdLFJ9ZnVuY3Rpb24gdShSKXtyZXR1cm4ibWF0MmQoIitSWzBdKyIsICIrUlsxXSsiLCAiK1JbMl0rIiwgIitSWzNdKyIsICIrUls0XSsiLCAiK1JbNV0rIikifWZ1bmN0aW9uIGEoUil7cmV0dXJuIE1hdGguaHlwb3QoUlswXSxSWzFdLFJbMl0sUlszXSxSWzRdLFJbNV0sMSl9ZnVuY3Rpb24gaChSLEMsail7cmV0dXJuIFJbMF09Q1swXStqWzBdLFJbMV09Q1sxXStqWzFdLFJbMl09Q1syXStqWzJdLFJbM109Q1szXStqWzNdLFJbNF09Q1s0XStqWzRdLFJbNV09Q1s1XStqWzVdLFJ9ZnVuY3Rpb24gYihSLEMsail7cmV0dXJuIFJbMF09Q1swXS1qWzBdLFJbMV09Q1sxXS1qWzFdLFJbMl09Q1syXS1qWzJdLFJbM109Q1szXS1qWzNdLFJbNF09Q1s0XS1qWzRdLFJbNV09Q1s1XS1qWzVdLFJ9ZnVuY3Rpb24gRShSLEMsail7cmV0dXJuIFJbMF09Q1swXSpqLFJbMV09Q1sxXSpqLFJbMl09Q1syXSpqLFJbM109Q1szXSpqLFJbNF09Q1s0XSpqLFJbNV09Q1s1XSpqLFJ9ZnVuY3Rpb24gQShSLEMsaiwkKXtyZXR1cm4gUlswXT1DWzBdK2pbMF0qJCxSWzFdPUNbMV0ralsxXSokLFJbMl09Q1syXStqWzJdKiQsUlszXT1DWzNdK2pbM10qJCxSWzRdPUNbNF0rals0XSokLFJbNV09Q1s1XStqWzVdKiQsUn1mdW5jdGlvbiBMKFIsQyl7cmV0dXJuIFJbMF09PT1DWzBdJiZSWzFdPT09Q1sxXSYmUlsyXT09PUNbMl0mJlJbM109PT1DWzNdJiZSWzRdPT09Q1s0XSYmUls1XT09PUNbNV19ZnVuY3Rpb24gUyhSLEMpe3ZhciBqPVJbMF0sJD1SWzFdLEg9UlsyXSxKPVJbM10scT1SWzRdLEY9Uls1XSxHPUNbMF0sWj1DWzFdLHR0PUNbMl0sZXQ9Q1szXSxpdD1DWzRdLGs9Q1s1XTtyZXR1cm4gTWF0aC5hYnMoai1HKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaiksTWF0aC5hYnMoRykpJiZNYXRoLmFicygkLVopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKEgtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhIKSxNYXRoLmFicyh0dCkpJiZNYXRoLmFicyhKLWV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMoZXQpKSYmTWF0aC5hYnMocS1pdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHEpLE1hdGguYWJzKGl0KSkmJk1hdGguYWJzKEYtayk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEYpLE1hdGguYWJzKGspKX12YXIgST15LEQ9Yn0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJmcm9tTWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZnJvbVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibm9ybWFsRnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwicHJvamVjdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuICR9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgRj1uZXcgci5BUlJBWV9UWVBFKDkpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKEZbMV09MCxGWzJdPTAsRlszXT0wLEZbNV09MCxGWzZdPTAsRls3XT0wKSxGWzBdPTEsRls0XT0xLEZbOF09MSxGfWZ1bmN0aW9uIHMoRixHKXtyZXR1cm4gRlswXT1HWzBdLEZbMV09R1sxXSxGWzJdPUdbMl0sRlszXT1HWzRdLEZbNF09R1s1XSxGWzVdPUdbNl0sRls2XT1HWzhdLEZbN109R1s5XSxGWzhdPUdbMTBdLEZ9ZnVuY3Rpb24gbChGKXt2YXIgRz1uZXcgci5BUlJBWV9UWVBFKDkpO3JldHVybiBHWzBdPUZbMF0sR1sxXT1GWzFdLEdbMl09RlsyXSxHWzNdPUZbM10sR1s0XT1GWzRdLEdbNV09Rls1XSxHWzZdPUZbNl0sR1s3XT1GWzddLEdbOF09Rls4XSxHfWZ1bmN0aW9uIGMoRixHKXtyZXR1cm4gRlswXT1HWzBdLEZbMV09R1sxXSxGWzJdPUdbMl0sRlszXT1HWzNdLEZbNF09R1s0XSxGWzVdPUdbNV0sRls2XT1HWzZdLEZbN109R1s3XSxGWzhdPUdbOF0sRn1mdW5jdGlvbiBvKEYsRyxaLHR0LGV0LGl0LGssaHQsZnQpe3ZhciBCPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIEJbMF09RixCWzFdPUcsQlsyXT1aLEJbM109dHQsQls0XT1ldCxCWzVdPWl0LEJbNl09ayxCWzddPWh0LEJbOF09ZnQsQn1mdW5jdGlvbiBmKEYsRyxaLHR0LGV0LGl0LGssaHQsZnQsQil7cmV0dXJuIEZbMF09RyxGWzFdPVosRlsyXT10dCxGWzNdPWV0LEZbNF09aXQsRls1XT1rLEZbNl09aHQsRls3XT1mdCxGWzhdPUIsRn1mdW5jdGlvbiB4KEYpe3JldHVybiBGWzBdPTEsRlsxXT0wLEZbMl09MCxGWzNdPTAsRls0XT0xLEZbNV09MCxGWzZdPTAsRls3XT0wLEZbOF09MSxGfWZ1bmN0aW9uIGcoRixHKXtpZihGPT09Ryl7dmFyIFo9R1sxXSx0dD1HWzJdLGV0PUdbNV07RlsxXT1HWzNdLEZbMl09R1s2XSxGWzNdPVosRls1XT1HWzddLEZbNl09dHQsRls3XT1ldH1lbHNlIEZbMF09R1swXSxGWzFdPUdbM10sRlsyXT1HWzZdLEZbM109R1sxXSxGWzRdPUdbNF0sRls1XT1HWzddLEZbNl09R1syXSxGWzddPUdbNV0sRls4XT1HWzhdO3JldHVybiBGfWZ1bmN0aW9uIHkoRixHKXt2YXIgWj1HWzBdLHR0PUdbMV0sZXQ9R1syXSxpdD1HWzNdLGs9R1s0XSxodD1HWzVdLGZ0PUdbNl0sQj1HWzddLFc9R1s4XSxWPVcqay1odCpCLFg9LVcqaXQraHQqZnQsTj1CKml0LWsqZnQsej1aKlYrdHQqWCtldCpOO3JldHVybiB6Pyh6PTEveixGWzBdPVYqeixGWzFdPSgtVyp0dCtldCpCKSp6LEZbMl09KGh0KnR0LWV0KmspKnosRlszXT1YKnosRls0XT0oVypaLWV0KmZ0KSp6LEZbNV09KC1odCpaK2V0Kml0KSp6LEZbNl09Tip6LEZbN109KC1CKlordHQqZnQpKnosRls4XT0oaypaLXR0Kml0KSp6LEYpOm51bGx9ZnVuY3Rpb24gbShGLEcpe3ZhciBaPUdbMF0sdHQ9R1sxXSxldD1HWzJdLGl0PUdbM10saz1HWzRdLGh0PUdbNV0sZnQ9R1s2XSxCPUdbN10sVz1HWzhdO3JldHVybiBGWzBdPWsqVy1odCpCLEZbMV09ZXQqQi10dCpXLEZbMl09dHQqaHQtZXQqayxGWzNdPWh0KmZ0LWl0KlcsRls0XT1aKlctZXQqZnQsRls1XT1ldCppdC1aKmh0LEZbNl09aXQqQi1rKmZ0LEZbN109dHQqZnQtWipCLEZbOF09WiprLXR0Kml0LEZ9ZnVuY3Rpb24gVChGKXt2YXIgRz1GWzBdLFo9RlsxXSx0dD1GWzJdLGV0PUZbM10saXQ9Rls0XSxrPUZbNV0saHQ9Rls2XSxmdD1GWzddLEI9Rls4XTtyZXR1cm4gRyooQippdC1rKmZ0KStaKigtQipldCtrKmh0KSt0dCooZnQqZXQtaXQqaHQpfWZ1bmN0aW9uIE8oRixHLFope3ZhciB0dD1HWzBdLGV0PUdbMV0saXQ9R1syXSxrPUdbM10saHQ9R1s0XSxmdD1HWzVdLEI9R1s2XSxXPUdbN10sVj1HWzhdLFg9WlswXSxOPVpbMV0sej1aWzJdLHA9WlszXSxNPVpbNF0sdz1aWzVdLFU9Wls2XSxLPVpbN10sWT1aWzhdO3JldHVybiBGWzBdPVgqdHQrTiprK3oqQixGWzFdPVgqZXQrTipodCt6KlcsRlsyXT1YKml0K04qZnQreipWLEZbM109cCp0dCtNKmsrdypCLEZbNF09cCpldCtNKmh0K3cqVyxGWzVdPXAqaXQrTSpmdCt3KlYsRls2XT1VKnR0K0sqaytZKkIsRls3XT1VKmV0K0sqaHQrWSpXLEZbOF09VSppdCtLKmZ0K1kqVixGfWZ1bmN0aW9uIHYoRixHLFope3ZhciB0dD1HWzBdLGV0PUdbMV0saXQ9R1syXSxrPUdbM10saHQ9R1s0XSxmdD1HWzVdLEI9R1s2XSxXPUdbN10sVj1HWzhdLFg9WlswXSxOPVpbMV07cmV0dXJuIEZbMF09dHQsRlsxXT1ldCxGWzJdPWl0LEZbM109ayxGWzRdPWh0LEZbNV09ZnQsRls2XT1YKnR0K04qaytCLEZbN109WCpldCtOKmh0K1csRls4XT1YKml0K04qZnQrVixGfWZ1bmN0aW9uIFAoRixHLFope3ZhciB0dD1HWzBdLGV0PUdbMV0saXQ9R1syXSxrPUdbM10saHQ9R1s0XSxmdD1HWzVdLEI9R1s2XSxXPUdbN10sVj1HWzhdLFg9TWF0aC5zaW4oWiksTj1NYXRoLmNvcyhaKTtyZXR1cm4gRlswXT1OKnR0K1gqayxGWzFdPU4qZXQrWCpodCxGWzJdPU4qaXQrWCpmdCxGWzNdPU4qay1YKnR0LEZbNF09TipodC1YKmV0LEZbNV09TipmdC1YKml0LEZbNl09QixGWzddPVcsRls4XT1WLEZ9ZnVuY3Rpb24gaShGLEcsWil7dmFyIHR0PVpbMF0sZXQ9WlsxXTtyZXR1cm4gRlswXT10dCpHWzBdLEZbMV09dHQqR1sxXSxGWzJdPXR0KkdbMl0sRlszXT1ldCpHWzNdLEZbNF09ZXQqR1s0XSxGWzVdPWV0KkdbNV0sRls2XT1HWzZdLEZbN109R1s3XSxGWzhdPUdbOF0sRn1mdW5jdGlvbiB1KEYsRyl7cmV0dXJuIEZbMF09MSxGWzFdPTAsRlsyXT0wLEZbM109MCxGWzRdPTEsRls1XT0wLEZbNl09R1swXSxGWzddPUdbMV0sRls4XT0xLEZ9ZnVuY3Rpb24gYShGLEcpe3ZhciBaPU1hdGguc2luKEcpLHR0PU1hdGguY29zKEcpO3JldHVybiBGWzBdPXR0LEZbMV09WixGWzJdPTAsRlszXT0tWixGWzRdPXR0LEZbNV09MCxGWzZdPTAsRls3XT0wLEZbOF09MSxGfWZ1bmN0aW9uIGgoRixHKXtyZXR1cm4gRlswXT1HWzBdLEZbMV09MCxGWzJdPTAsRlszXT0wLEZbNF09R1sxXSxGWzVdPTAsRls2XT0wLEZbN109MCxGWzhdPTEsRn1mdW5jdGlvbiBiKEYsRyl7cmV0dXJuIEZbMF09R1swXSxGWzFdPUdbMV0sRlsyXT0wLEZbM109R1syXSxGWzRdPUdbM10sRls1XT0wLEZbNl09R1s0XSxGWzddPUdbNV0sRls4XT0xLEZ9ZnVuY3Rpb24gRShGLEcpe3ZhciBaPUdbMF0sdHQ9R1sxXSxldD1HWzJdLGl0PUdbM10saz1aK1osaHQ9dHQrdHQsZnQ9ZXQrZXQsQj1aKmssVz10dCprLFY9dHQqaHQsWD1ldCprLE49ZXQqaHQsej1ldCpmdCxwPWl0KmssTT1pdCpodCx3PWl0KmZ0O3JldHVybiBGWzBdPTEtVi16LEZbM109Vy13LEZbNl09WCtNLEZbMV09Vyt3LEZbNF09MS1CLXosRls3XT1OLXAsRlsyXT1YLU0sRls1XT1OK3AsRls4XT0xLUItVixGfWZ1bmN0aW9uIEEoRixHKXt2YXIgWj1HWzBdLHR0PUdbMV0sZXQ9R1syXSxpdD1HWzNdLGs9R1s0XSxodD1HWzVdLGZ0PUdbNl0sQj1HWzddLFc9R1s4XSxWPUdbOV0sWD1HWzEwXSxOPUdbMTFdLHo9R1sxMl0scD1HWzEzXSxNPUdbMTRdLHc9R1sxNV0sVT1aKmh0LXR0KmssSz1aKmZ0LWV0KmssWT1aKkItaXQqayxRPXR0KmZ0LWV0Kmh0LHJ0PXR0KkItaXQqaHQsbnQ9ZXQqQi1pdCpmdCxhdD1XKnAtVip6LGN0PVcqTS1YKnosb3Q9Vyp3LU4qeixzdD1WKk0tWCpwLGx0PVYqdy1OKnAsbXQ9WCp3LU4qTSxwdD1VKm10LUsqbHQrWSpzdCtRKm90LXJ0KmN0K250KmF0O3JldHVybiBwdD8ocHQ9MS9wdCxGWzBdPShodCptdC1mdCpsdCtCKnN0KSpwdCxGWzFdPShmdCpvdC1rKm10LUIqY3QpKnB0LEZbMl09KGsqbHQtaHQqb3QrQiphdCkqcHQsRlszXT0oZXQqbHQtdHQqbXQtaXQqc3QpKnB0LEZbNF09KFoqbXQtZXQqb3QraXQqY3QpKnB0LEZbNV09KHR0Km90LVoqbHQtaXQqYXQpKnB0LEZbNl09KHAqbnQtTSpydCt3KlEpKnB0LEZbN109KE0qWS16Km50LXcqSykqcHQsRls4XT0oeipydC1wKlkrdypVKSpwdCxGKTpudWxsfWZ1bmN0aW9uIEwoRixHLFope3JldHVybiBGWzBdPTIvRyxGWzFdPTAsRlsyXT0wLEZbM109MCxGWzRdPS0yL1osRls1XT0wLEZbNl09LTEsRls3XT0xLEZbOF09MSxGfWZ1bmN0aW9uIFMoRil7cmV0dXJuIm1hdDMoIitGWzBdKyIsICIrRlsxXSsiLCAiK0ZbMl0rIiwgIitGWzNdKyIsICIrRls0XSsiLCAiK0ZbNV0rIiwgIitGWzZdKyIsICIrRls3XSsiLCAiK0ZbOF0rIikifWZ1bmN0aW9uIEkoRil7cmV0dXJuIE1hdGguaHlwb3QoRlswXSxGWzFdLEZbMl0sRlszXSxGWzRdLEZbNV0sRls2XSxGWzddLEZbOF0pfWZ1bmN0aW9uIEQoRixHLFope3JldHVybiBGWzBdPUdbMF0rWlswXSxGWzFdPUdbMV0rWlsxXSxGWzJdPUdbMl0rWlsyXSxGWzNdPUdbM10rWlszXSxGWzRdPUdbNF0rWls0XSxGWzVdPUdbNV0rWls1XSxGWzZdPUdbNl0rWls2XSxGWzddPUdbN10rWls3XSxGWzhdPUdbOF0rWls4XSxGfWZ1bmN0aW9uIFIoRixHLFope3JldHVybiBGWzBdPUdbMF0tWlswXSxGWzFdPUdbMV0tWlsxXSxGWzJdPUdbMl0tWlsyXSxGWzNdPUdbM10tWlszXSxGWzRdPUdbNF0tWls0XSxGWzVdPUdbNV0tWls1XSxGWzZdPUdbNl0tWls2XSxGWzddPUdbN10tWls3XSxGWzhdPUdbOF0tWls4XSxGfWZ1bmN0aW9uIEMoRixHLFope3JldHVybiBGWzBdPUdbMF0qWixGWzFdPUdbMV0qWixGWzJdPUdbMl0qWixGWzNdPUdbM10qWixGWzRdPUdbNF0qWixGWzVdPUdbNV0qWixGWzZdPUdbNl0qWixGWzddPUdbN10qWixGWzhdPUdbOF0qWixGfWZ1bmN0aW9uIGooRixHLFosdHQpe3JldHVybiBGWzBdPUdbMF0rWlswXSp0dCxGWzFdPUdbMV0rWlsxXSp0dCxGWzJdPUdbMl0rWlsyXSp0dCxGWzNdPUdbM10rWlszXSp0dCxGWzRdPUdbNF0rWls0XSp0dCxGWzVdPUdbNV0rWls1XSp0dCxGWzZdPUdbNl0rWls2XSp0dCxGWzddPUdbN10rWls3XSp0dCxGWzhdPUdbOF0rWls4XSp0dCxGfWZ1bmN0aW9uICQoRixHKXtyZXR1cm4gRlswXT09PUdbMF0mJkZbMV09PT1HWzFdJiZGWzJdPT09R1syXSYmRlszXT09PUdbM10mJkZbNF09PT1HWzRdJiZGWzVdPT09R1s1XSYmRls2XT09PUdbNl0mJkZbN109PT1HWzddJiZGWzhdPT09R1s4XX1mdW5jdGlvbiBIKEYsRyl7dmFyIFo9RlswXSx0dD1GWzFdLGV0PUZbMl0saXQ9RlszXSxrPUZbNF0saHQ9Rls1XSxmdD1GWzZdLEI9Rls3XSxXPUZbOF0sVj1HWzBdLFg9R1sxXSxOPUdbMl0sej1HWzNdLHA9R1s0XSxNPUdbNV0sdz1HWzZdLFU9R1s3XSxLPUdbOF07cmV0dXJuIE1hdGguYWJzKFotVik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFopLE1hdGguYWJzKFYpKSYmTWF0aC5hYnModHQtWCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHR0KSxNYXRoLmFicyhYKSkmJk1hdGguYWJzKGV0LU4pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhldCksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhpdC16KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaXQpLE1hdGguYWJzKHopKSYmTWF0aC5hYnMoay1wKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoayksTWF0aC5hYnMocCkpJiZNYXRoLmFicyhodC1NKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaHQpLE1hdGguYWJzKE0pKSYmTWF0aC5hYnMoZnQtdyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGZ0KSxNYXRoLmFicyh3KSkmJk1hdGguYWJzKEItVSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEIpLE1hdGguYWJzKFUpKSYmTWF0aC5hYnMoVy1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVyksTWF0aC5hYnMoSykpfXZhciBKPU8scT1SfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImZyb21YUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZnJvbVlSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJmcm9tWlJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImZyb21RdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJnZXRTY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImdldFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuICR9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJmcnVzdHVtIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInBlcnNwZWN0aXZlIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsInBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3IixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsIm9ydGhvIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImxvb2tBdCIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwidGFyZ2V0VG8iLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gaXR9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBOfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gen0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBwPW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzZdPTAscFs3XT0wLHBbOF09MCxwWzldPTAscFsxMV09MCxwWzEyXT0wLHBbMTNdPTAscFsxNF09MCkscFswXT0xLHBbNV09MSxwWzEwXT0xLHBbMTVdPTEscH1mdW5jdGlvbiBzKHApe3ZhciBNPW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiBNWzBdPXBbMF0sTVsxXT1wWzFdLE1bMl09cFsyXSxNWzNdPXBbM10sTVs0XT1wWzRdLE1bNV09cFs1XSxNWzZdPXBbNl0sTVs3XT1wWzddLE1bOF09cFs4XSxNWzldPXBbOV0sTVsxMF09cFsxMF0sTVsxMV09cFsxMV0sTVsxMl09cFsxMl0sTVsxM109cFsxM10sTVsxNF09cFsxNF0sTVsxNV09cFsxNV0sTX1mdW5jdGlvbiBsKHAsTSl7cmV0dXJuIHBbMF09TVswXSxwWzFdPU1bMV0scFsyXT1NWzJdLHBbM109TVszXSxwWzRdPU1bNF0scFs1XT1NWzVdLHBbNl09TVs2XSxwWzddPU1bN10scFs4XT1NWzhdLHBbOV09TVs5XSxwWzEwXT1NWzEwXSxwWzExXT1NWzExXSxwWzEyXT1NWzEyXSxwWzEzXT1NWzEzXSxwWzE0XT1NWzE0XSxwWzE1XT1NWzE1XSxwfWZ1bmN0aW9uIGMocCxNLHcsVSxLLFksUSxydCxudCxhdCxjdCxvdCxzdCxsdCxtdCxwdCl7dmFyIGR0PW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiBkdFswXT1wLGR0WzFdPU0sZHRbMl09dyxkdFszXT1VLGR0WzRdPUssZHRbNV09WSxkdFs2XT1RLGR0WzddPXJ0LGR0WzhdPW50LGR0WzldPWF0LGR0WzEwXT1jdCxkdFsxMV09b3QsZHRbMTJdPXN0LGR0WzEzXT1sdCxkdFsxNF09bXQsZHRbMTVdPXB0LGR0fWZ1bmN0aW9uIG8ocCxNLHcsVSxLLFksUSxydCxudCxhdCxjdCxvdCxzdCxsdCxtdCxwdCxkdCl7cmV0dXJuIHBbMF09TSxwWzFdPXcscFsyXT1VLHBbM109SyxwWzRdPVkscFs1XT1RLHBbNl09cnQscFs3XT1udCxwWzhdPWF0LHBbOV09Y3QscFsxMF09b3QscFsxMV09c3QscFsxMl09bHQscFsxM109bXQscFsxNF09cHQscFsxNV09ZHQscH1mdW5jdGlvbiBmKHApe3JldHVybiBwWzBdPTEscFsxXT0wLHBbMl09MCxwWzNdPTAscFs0XT0wLHBbNV09MSxwWzZdPTAscFs3XT0wLHBbOF09MCxwWzldPTAscFsxMF09MSxwWzExXT0wLHBbMTJdPTAscFsxM109MCxwWzE0XT0wLHBbMTVdPTEscH1mdW5jdGlvbiB4KHAsTSl7aWYocD09PU0pe3ZhciB3PU1bMV0sVT1NWzJdLEs9TVszXSxZPU1bNl0sUT1NWzddLHJ0PU1bMTFdO3BbMV09TVs0XSxwWzJdPU1bOF0scFszXT1NWzEyXSxwWzRdPXcscFs2XT1NWzldLHBbN109TVsxM10scFs4XT1VLHBbOV09WSxwWzExXT1NWzE0XSxwWzEyXT1LLHBbMTNdPVEscFsxNF09cnR9ZWxzZSBwWzBdPU1bMF0scFsxXT1NWzRdLHBbMl09TVs4XSxwWzNdPU1bMTJdLHBbNF09TVsxXSxwWzVdPU1bNV0scFs2XT1NWzldLHBbN109TVsxM10scFs4XT1NWzJdLHBbOV09TVs2XSxwWzEwXT1NWzEwXSxwWzExXT1NWzE0XSxwWzEyXT1NWzNdLHBbMTNdPU1bN10scFsxNF09TVsxMV0scFsxNV09TVsxNV07cmV0dXJuIHB9ZnVuY3Rpb24gZyhwLE0pe3ZhciB3PU1bMF0sVT1NWzFdLEs9TVsyXSxZPU1bM10sUT1NWzRdLHJ0PU1bNV0sbnQ9TVs2XSxhdD1NWzddLGN0PU1bOF0sb3Q9TVs5XSxzdD1NWzEwXSxsdD1NWzExXSxtdD1NWzEyXSxwdD1NWzEzXSxkdD1NWzE0XSx5dD1NWzE1XSxBdD13KnJ0LVUqUSxTdD13Km50LUsqUSxNdD13KmF0LVkqUSxUdD1VKm50LUsqcnQsRXQ9VSphdC1ZKnJ0LFV0PUsqYXQtWSpudCxCdD1jdCpwdC1vdCptdCxXdD1jdCpkdC1zdCptdCxGdD1jdCp5dC1sdCptdCwkdD1vdCpkdC1zdCpwdCxHdD1vdCp5dC1sdCpwdCxIdD1zdCp5dC1sdCpkdCxMdD1BdCpIdC1TdCpHdCtNdCokdCtUdCpGdC1FdCpXdCtVdCpCdDtyZXR1cm4gTHQ/KEx0PTEvTHQscFswXT0ocnQqSHQtbnQqR3QrYXQqJHQpKkx0LHBbMV09KEsqR3QtVSpIdC1ZKiR0KSpMdCxwWzJdPShwdCpVdC1kdCpFdCt5dCpUdCkqTHQscFszXT0oc3QqRXQtb3QqVXQtbHQqVHQpKkx0LHBbNF09KG50KkZ0LVEqSHQtYXQqV3QpKkx0LHBbNV09KHcqSHQtSypGdCtZKld0KSpMdCxwWzZdPShkdCpNdC1tdCpVdC15dCpTdCkqTHQscFs3XT0oY3QqVXQtc3QqTXQrbHQqU3QpKkx0LHBbOF09KFEqR3QtcnQqRnQrYXQqQnQpKkx0LHBbOV09KFUqRnQtdypHdC1ZKkJ0KSpMdCxwWzEwXT0obXQqRXQtcHQqTXQreXQqQXQpKkx0LHBbMTFdPShvdCpNdC1jdCpFdC1sdCpBdCkqTHQscFsxMl09KHJ0Kld0LVEqJHQtbnQqQnQpKkx0LHBbMTNdPSh3KiR0LVUqV3QrSypCdCkqTHQscFsxNF09KHB0KlN0LW10KlR0LWR0KkF0KSpMdCxwWzE1XT0oY3QqVHQtb3QqU3Qrc3QqQXQpKkx0LHApOm51bGx9ZnVuY3Rpb24geShwLE0pe3ZhciB3PU1bMF0sVT1NWzFdLEs9TVsyXSxZPU1bM10sUT1NWzRdLHJ0PU1bNV0sbnQ9TVs2XSxhdD1NWzddLGN0PU1bOF0sb3Q9TVs5XSxzdD1NWzEwXSxsdD1NWzExXSxtdD1NWzEyXSxwdD1NWzEzXSxkdD1NWzE0XSx5dD1NWzE1XTtyZXR1cm4gcFswXT1ydCooc3QqeXQtbHQqZHQpLW90KihudCp5dC1hdCpkdCkrcHQqKG50Kmx0LWF0KnN0KSxwWzFdPS0oVSooc3QqeXQtbHQqZHQpLW90KihLKnl0LVkqZHQpK3B0KihLKmx0LVkqc3QpKSxwWzJdPVUqKG50Knl0LWF0KmR0KS1ydCooSyp5dC1ZKmR0KStwdCooSyphdC1ZKm50KSxwWzNdPS0oVSoobnQqbHQtYXQqc3QpLXJ0KihLKmx0LVkqc3QpK290KihLKmF0LVkqbnQpKSxwWzRdPS0oUSooc3QqeXQtbHQqZHQpLWN0KihudCp5dC1hdCpkdCkrbXQqKG50Kmx0LWF0KnN0KSkscFs1XT13KihzdCp5dC1sdCpkdCktY3QqKEsqeXQtWSpkdCkrbXQqKEsqbHQtWSpzdCkscFs2XT0tKHcqKG50Knl0LWF0KmR0KS1RKihLKnl0LVkqZHQpK210KihLKmF0LVkqbnQpKSxwWzddPXcqKG50Kmx0LWF0KnN0KS1RKihLKmx0LVkqc3QpK2N0KihLKmF0LVkqbnQpLHBbOF09USoob3QqeXQtbHQqcHQpLWN0KihydCp5dC1hdCpwdCkrbXQqKHJ0Kmx0LWF0Km90KSxwWzldPS0odyoob3QqeXQtbHQqcHQpLWN0KihVKnl0LVkqcHQpK210KihVKmx0LVkqb3QpKSxwWzEwXT13KihydCp5dC1hdCpwdCktUSooVSp5dC1ZKnB0KSttdCooVSphdC1ZKnJ0KSxwWzExXT0tKHcqKHJ0Kmx0LWF0Km90KS1RKihVKmx0LVkqb3QpK2N0KihVKmF0LVkqcnQpKSxwWzEyXT0tKFEqKG90KmR0LXN0KnB0KS1jdCoocnQqZHQtbnQqcHQpK210KihydCpzdC1udCpvdCkpLHBbMTNdPXcqKG90KmR0LXN0KnB0KS1jdCooVSpkdC1LKnB0KSttdCooVSpzdC1LKm90KSxwWzE0XT0tKHcqKHJ0KmR0LW50KnB0KS1RKihVKmR0LUsqcHQpK210KihVKm50LUsqcnQpKSxwWzE1XT13KihydCpzdC1udCpvdCktUSooVSpzdC1LKm90KStjdCooVSpudC1LKnJ0KSxwfWZ1bmN0aW9uIG0ocCl7dmFyIE09cFswXSx3PXBbMV0sVT1wWzJdLEs9cFszXSxZPXBbNF0sUT1wWzVdLHJ0PXBbNl0sbnQ9cFs3XSxhdD1wWzhdLGN0PXBbOV0sb3Q9cFsxMF0sc3Q9cFsxMV0sbHQ9cFsxMl0sbXQ9cFsxM10scHQ9cFsxNF0sZHQ9cFsxNV0seXQ9TSpRLXcqWSxBdD1NKnJ0LVUqWSxTdD1NKm50LUsqWSxNdD13KnJ0LVUqUSxUdD13Km50LUsqUSxFdD1VKm50LUsqcnQsVXQ9YXQqbXQtY3QqbHQsQnQ9YXQqcHQtb3QqbHQsV3Q9YXQqZHQtc3QqbHQsRnQ9Y3QqcHQtb3QqbXQsJHQ9Y3QqZHQtc3QqbXQsR3Q9b3QqZHQtc3QqcHQ7cmV0dXJuIHl0Kkd0LUF0KiR0K1N0KkZ0K010Kld0LVR0KkJ0K0V0KlV0fWZ1bmN0aW9uIFQocCxNLHcpe3ZhciBVPU1bMF0sSz1NWzFdLFk9TVsyXSxRPU1bM10scnQ9TVs0XSxudD1NWzVdLGF0PU1bNl0sY3Q9TVs3XSxvdD1NWzhdLHN0PU1bOV0sbHQ9TVsxMF0sbXQ9TVsxMV0scHQ9TVsxMl0sZHQ9TVsxM10seXQ9TVsxNF0sQXQ9TVsxNV0sU3Q9d1swXSxNdD13WzFdLFR0PXdbMl0sRXQ9d1szXTtyZXR1cm4gcFswXT1TdCpVK010KnJ0K1R0Km90K0V0KnB0LHBbMV09U3QqSytNdCpudCtUdCpzdCtFdCpkdCxwWzJdPVN0KlkrTXQqYXQrVHQqbHQrRXQqeXQscFszXT1TdCpRK010KmN0K1R0Km10K0V0KkF0LFN0PXdbNF0sTXQ9d1s1XSxUdD13WzZdLEV0PXdbN10scFs0XT1TdCpVK010KnJ0K1R0Km90K0V0KnB0LHBbNV09U3QqSytNdCpudCtUdCpzdCtFdCpkdCxwWzZdPVN0KlkrTXQqYXQrVHQqbHQrRXQqeXQscFs3XT1TdCpRK010KmN0K1R0Km10K0V0KkF0LFN0PXdbOF0sTXQ9d1s5XSxUdD13WzEwXSxFdD13WzExXSxwWzhdPVN0KlUrTXQqcnQrVHQqb3QrRXQqcHQscFs5XT1TdCpLK010Km50K1R0KnN0K0V0KmR0LHBbMTBdPVN0KlkrTXQqYXQrVHQqbHQrRXQqeXQscFsxMV09U3QqUStNdCpjdCtUdCptdCtFdCpBdCxTdD13WzEyXSxNdD13WzEzXSxUdD13WzE0XSxFdD13WzE1XSxwWzEyXT1TdCpVK010KnJ0K1R0Km90K0V0KnB0LHBbMTNdPVN0KksrTXQqbnQrVHQqc3QrRXQqZHQscFsxNF09U3QqWStNdCphdCtUdCpsdCtFdCp5dCxwWzE1XT1TdCpRK010KmN0K1R0Km10K0V0KkF0LHB9ZnVuY3Rpb24gTyhwLE0sdyl7dmFyIFU9d1swXSxLPXdbMV0sWT13WzJdLFEscnQsbnQsYXQsY3Qsb3Qsc3QsbHQsbXQscHQsZHQseXQ7cmV0dXJuIE09PT1wPyhwWzEyXT1NWzBdKlUrTVs0XSpLK01bOF0qWStNWzEyXSxwWzEzXT1NWzFdKlUrTVs1XSpLK01bOV0qWStNWzEzXSxwWzE0XT1NWzJdKlUrTVs2XSpLK01bMTBdKlkrTVsxNF0scFsxNV09TVszXSpVK01bN10qSytNWzExXSpZK01bMTVdKTooUT1NWzBdLHJ0PU1bMV0sbnQ9TVsyXSxhdD1NWzNdLGN0PU1bNF0sb3Q9TVs1XSxzdD1NWzZdLGx0PU1bN10sbXQ9TVs4XSxwdD1NWzldLGR0PU1bMTBdLHl0PU1bMTFdLHBbMF09USxwWzFdPXJ0LHBbMl09bnQscFszXT1hdCxwWzRdPWN0LHBbNV09b3QscFs2XT1zdCxwWzddPWx0LHBbOF09bXQscFs5XT1wdCxwWzEwXT1kdCxwWzExXT15dCxwWzEyXT1RKlUrY3QqSyttdCpZK01bMTJdLHBbMTNdPXJ0KlUrb3QqSytwdCpZK01bMTNdLHBbMTRdPW50KlUrc3QqSytkdCpZK01bMTRdLHBbMTVdPWF0KlUrbHQqSyt5dCpZK01bMTVdKSxwfWZ1bmN0aW9uIHYocCxNLHcpe3ZhciBVPXdbMF0sSz13WzFdLFk9d1syXTtyZXR1cm4gcFswXT1NWzBdKlUscFsxXT1NWzFdKlUscFsyXT1NWzJdKlUscFszXT1NWzNdKlUscFs0XT1NWzRdKksscFs1XT1NWzVdKksscFs2XT1NWzZdKksscFs3XT1NWzddKksscFs4XT1NWzhdKlkscFs5XT1NWzldKlkscFsxMF09TVsxMF0qWSxwWzExXT1NWzExXSpZLHBbMTJdPU1bMTJdLHBbMTNdPU1bMTNdLHBbMTRdPU1bMTRdLHBbMTVdPU1bMTVdLHB9ZnVuY3Rpb24gUChwLE0sdyxVKXt2YXIgSz1VWzBdLFk9VVsxXSxRPVVbMl0scnQ9TWF0aC5oeXBvdChLLFksUSksbnQsYXQsY3Qsb3Qsc3QsbHQsbXQscHQsZHQseXQsQXQsU3QsTXQsVHQsRXQsVXQsQnQsV3QsRnQsJHQsR3QsSHQsTHQsWnQ7cmV0dXJuIHJ0PHIuRVBTSUxPTj9udWxsOihydD0xL3J0LEsqPXJ0LFkqPXJ0LFEqPXJ0LG50PU1hdGguc2luKHcpLGF0PU1hdGguY29zKHcpLGN0PTEtYXQsb3Q9TVswXSxzdD1NWzFdLGx0PU1bMl0sbXQ9TVszXSxwdD1NWzRdLGR0PU1bNV0seXQ9TVs2XSxBdD1NWzddLFN0PU1bOF0sTXQ9TVs5XSxUdD1NWzEwXSxFdD1NWzExXSxVdD1LKksqY3QrYXQsQnQ9WSpLKmN0K1EqbnQsV3Q9USpLKmN0LVkqbnQsRnQ9SypZKmN0LVEqbnQsJHQ9WSpZKmN0K2F0LEd0PVEqWSpjdCtLKm50LEh0PUsqUSpjdCtZKm50LEx0PVkqUSpjdC1LKm50LFp0PVEqUSpjdCthdCxwWzBdPW90KlV0K3B0KkJ0K1N0Kld0LHBbMV09c3QqVXQrZHQqQnQrTXQqV3QscFsyXT1sdCpVdCt5dCpCdCtUdCpXdCxwWzNdPW10KlV0K0F0KkJ0K0V0Kld0LHBbNF09b3QqRnQrcHQqJHQrU3QqR3QscFs1XT1zdCpGdCtkdCokdCtNdCpHdCxwWzZdPWx0KkZ0K3l0KiR0K1R0Kkd0LHBbN109bXQqRnQrQXQqJHQrRXQqR3QscFs4XT1vdCpIdCtwdCpMdCtTdCpadCxwWzldPXN0Kkh0K2R0Kkx0K010Klp0LHBbMTBdPWx0Kkh0K3l0Kkx0K1R0Klp0LHBbMTFdPW10Kkh0K0F0Kkx0K0V0Klp0LE0hPT1wJiYocFsxMl09TVsxMl0scFsxM109TVsxM10scFsxNF09TVsxNF0scFsxNV09TVsxNV0pLHApfWZ1bmN0aW9uIGkocCxNLHcpe3ZhciBVPU1hdGguc2luKHcpLEs9TWF0aC5jb3ModyksWT1NWzRdLFE9TVs1XSxydD1NWzZdLG50PU1bN10sYXQ9TVs4XSxjdD1NWzldLG90PU1bMTBdLHN0PU1bMTFdO3JldHVybiBNIT09cCYmKHBbMF09TVswXSxwWzFdPU1bMV0scFsyXT1NWzJdLHBbM109TVszXSxwWzEyXT1NWzEyXSxwWzEzXT1NWzEzXSxwWzE0XT1NWzE0XSxwWzE1XT1NWzE1XSkscFs0XT1ZKksrYXQqVSxwWzVdPVEqSytjdCpVLHBbNl09cnQqSytvdCpVLHBbN109bnQqSytzdCpVLHBbOF09YXQqSy1ZKlUscFs5XT1jdCpLLVEqVSxwWzEwXT1vdCpLLXJ0KlUscFsxMV09c3QqSy1udCpVLHB9ZnVuY3Rpb24gdShwLE0sdyl7dmFyIFU9TWF0aC5zaW4odyksSz1NYXRoLmNvcyh3KSxZPU1bMF0sUT1NWzFdLHJ0PU1bMl0sbnQ9TVszXSxhdD1NWzhdLGN0PU1bOV0sb3Q9TVsxMF0sc3Q9TVsxMV07cmV0dXJuIE0hPT1wJiYocFs0XT1NWzRdLHBbNV09TVs1XSxwWzZdPU1bNl0scFs3XT1NWzddLHBbMTJdPU1bMTJdLHBbMTNdPU1bMTNdLHBbMTRdPU1bMTRdLHBbMTVdPU1bMTVdKSxwWzBdPVkqSy1hdCpVLHBbMV09USpLLWN0KlUscFsyXT1ydCpLLW90KlUscFszXT1udCpLLXN0KlUscFs4XT1ZKlUrYXQqSyxwWzldPVEqVStjdCpLLHBbMTBdPXJ0KlUrb3QqSyxwWzExXT1udCpVK3N0KksscH1mdW5jdGlvbiBhKHAsTSx3KXt2YXIgVT1NYXRoLnNpbih3KSxLPU1hdGguY29zKHcpLFk9TVswXSxRPU1bMV0scnQ9TVsyXSxudD1NWzNdLGF0PU1bNF0sY3Q9TVs1XSxvdD1NWzZdLHN0PU1bN107cmV0dXJuIE0hPT1wJiYocFs4XT1NWzhdLHBbOV09TVs5XSxwWzEwXT1NWzEwXSxwWzExXT1NWzExXSxwWzEyXT1NWzEyXSxwWzEzXT1NWzEzXSxwWzE0XT1NWzE0XSxwWzE1XT1NWzE1XSkscFswXT1ZKksrYXQqVSxwWzFdPVEqSytjdCpVLHBbMl09cnQqSytvdCpVLHBbM109bnQqSytzdCpVLHBbNF09YXQqSy1ZKlUscFs1XT1jdCpLLVEqVSxwWzZdPW90KkstcnQqVSxwWzddPXN0KkstbnQqVSxwfWZ1bmN0aW9uIGgocCxNKXtyZXR1cm4gcFswXT0xLHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzVdPTEscFs2XT0wLHBbN109MCxwWzhdPTAscFs5XT0wLHBbMTBdPTEscFsxMV09MCxwWzEyXT1NWzBdLHBbMTNdPU1bMV0scFsxNF09TVsyXSxwWzE1XT0xLHB9ZnVuY3Rpb24gYihwLE0pe3JldHVybiBwWzBdPU1bMF0scFsxXT0wLHBbMl09MCxwWzNdPTAscFs0XT0wLHBbNV09TVsxXSxwWzZdPTAscFs3XT0wLHBbOF09MCxwWzldPTAscFsxMF09TVsyXSxwWzExXT0wLHBbMTJdPTAscFsxM109MCxwWzE0XT0wLHBbMTVdPTEscH1mdW5jdGlvbiBFKHAsTSx3KXt2YXIgVT13WzBdLEs9d1sxXSxZPXdbMl0sUT1NYXRoLmh5cG90KFUsSyxZKSxydCxudCxhdDtyZXR1cm4gUTxyLkVQU0lMT04/bnVsbDooUT0xL1EsVSo9USxLKj1RLFkqPVEscnQ9TWF0aC5zaW4oTSksbnQ9TWF0aC5jb3MoTSksYXQ9MS1udCxwWzBdPVUqVSphdCtudCxwWzFdPUsqVSphdCtZKnJ0LHBbMl09WSpVKmF0LUsqcnQscFszXT0wLHBbNF09VSpLKmF0LVkqcnQscFs1XT1LKksqYXQrbnQscFs2XT1ZKksqYXQrVSpydCxwWzddPTAscFs4XT1VKlkqYXQrSypydCxwWzldPUsqWSphdC1VKnJ0LHBbMTBdPVkqWSphdCtudCxwWzExXT0wLHBbMTJdPTAscFsxM109MCxwWzE0XT0wLHBbMTVdPTEscCl9ZnVuY3Rpb24gQShwLE0pe3ZhciB3PU1hdGguc2luKE0pLFU9TWF0aC5jb3MoTSk7cmV0dXJuIHBbMF09MSxwWzFdPTAscFsyXT0wLHBbM109MCxwWzRdPTAscFs1XT1VLHBbNl09dyxwWzddPTAscFs4XT0wLHBbOV09LXcscFsxMF09VSxwWzExXT0wLHBbMTJdPTAscFsxM109MCxwWzE0XT0wLHBbMTVdPTEscH1mdW5jdGlvbiBMKHAsTSl7dmFyIHc9TWF0aC5zaW4oTSksVT1NYXRoLmNvcyhNKTtyZXR1cm4gcFswXT1VLHBbMV09MCxwWzJdPS13LHBbM109MCxwWzRdPTAscFs1XT0xLHBbNl09MCxwWzddPTAscFs4XT13LHBbOV09MCxwWzEwXT1VLHBbMTFdPTAscFsxMl09MCxwWzEzXT0wLHBbMTRdPTAscFsxNV09MSxwfWZ1bmN0aW9uIFMocCxNKXt2YXIgdz1NYXRoLnNpbihNKSxVPU1hdGguY29zKE0pO3JldHVybiBwWzBdPVUscFsxXT13LHBbMl09MCxwWzNdPTAscFs0XT0tdyxwWzVdPVUscFs2XT0wLHBbN109MCxwWzhdPTAscFs5XT0wLHBbMTBdPTEscFsxMV09MCxwWzEyXT0wLHBbMTNdPTAscFsxNF09MCxwWzE1XT0xLHB9ZnVuY3Rpb24gSShwLE0sdyl7dmFyIFU9TVswXSxLPU1bMV0sWT1NWzJdLFE9TVszXSxydD1VK1UsbnQ9SytLLGF0PVkrWSxjdD1VKnJ0LG90PVUqbnQsc3Q9VSphdCxsdD1LKm50LG10PUsqYXQscHQ9WSphdCxkdD1RKnJ0LHl0PVEqbnQsQXQ9USphdDtyZXR1cm4gcFswXT0xLShsdCtwdCkscFsxXT1vdCtBdCxwWzJdPXN0LXl0LHBbM109MCxwWzRdPW90LUF0LHBbNV09MS0oY3QrcHQpLHBbNl09bXQrZHQscFs3XT0wLHBbOF09c3QreXQscFs5XT1tdC1kdCxwWzEwXT0xLShjdCtsdCkscFsxMV09MCxwWzEyXT13WzBdLHBbMTNdPXdbMV0scFsxNF09d1syXSxwWzE1XT0xLHB9ZnVuY3Rpb24gRChwLE0pe3ZhciB3PW5ldyByLkFSUkFZX1RZUEUoMyksVT0tTVswXSxLPS1NWzFdLFk9LU1bMl0sUT1NWzNdLHJ0PU1bNF0sbnQ9TVs1XSxhdD1NWzZdLGN0PU1bN10sb3Q9VSpVK0sqSytZKlkrUSpRO3JldHVybiBvdD4wPyh3WzBdPShydCpRK2N0KlUrbnQqWS1hdCpLKSoyL290LHdbMV09KG50KlErY3QqSythdCpVLXJ0KlkpKjIvb3Qsd1syXT0oYXQqUStjdCpZK3J0KkstbnQqVSkqMi9vdCk6KHdbMF09KHJ0KlErY3QqVStudCpZLWF0KkspKjIsd1sxXT0obnQqUStjdCpLK2F0KlUtcnQqWSkqMix3WzJdPShhdCpRK2N0KlkrcnQqSy1udCpVKSoyKSxJKHAsTSx3KSxwfWZ1bmN0aW9uIFIocCxNKXtyZXR1cm4gcFswXT1NWzEyXSxwWzFdPU1bMTNdLHBbMl09TVsxNF0scH1mdW5jdGlvbiBDKHAsTSl7dmFyIHc9TVswXSxVPU1bMV0sSz1NWzJdLFk9TVs0XSxRPU1bNV0scnQ9TVs2XSxudD1NWzhdLGF0PU1bOV0sY3Q9TVsxMF07cmV0dXJuIHBbMF09TWF0aC5oeXBvdCh3LFUsSykscFsxXT1NYXRoLmh5cG90KFksUSxydCkscFsyXT1NYXRoLmh5cG90KG50LGF0LGN0KSxwfWZ1bmN0aW9uIGoocCxNKXt2YXIgdz1uZXcgci5BUlJBWV9UWVBFKDMpO0ModyxNKTt2YXIgVT0xL3dbMF0sSz0xL3dbMV0sWT0xL3dbMl0sUT1NWzBdKlUscnQ9TVsxXSpLLG50PU1bMl0qWSxhdD1NWzRdKlUsY3Q9TVs1XSpLLG90PU1bNl0qWSxzdD1NWzhdKlUsbHQ9TVs5XSpLLG10PU1bMTBdKlkscHQ9UStjdCttdCxkdD0wO3JldHVybiBwdD4wPyhkdD1NYXRoLnNxcnQocHQrMSkqMixwWzNdPS4yNSpkdCxwWzBdPShvdC1sdCkvZHQscFsxXT0oc3QtbnQpL2R0LHBbMl09KHJ0LWF0KS9kdCk6UT5jdCYmUT5tdD8oZHQ9TWF0aC5zcXJ0KDErUS1jdC1tdCkqMixwWzNdPShvdC1sdCkvZHQscFswXT0uMjUqZHQscFsxXT0ocnQrYXQpL2R0LHBbMl09KHN0K250KS9kdCk6Y3Q+bXQ/KGR0PU1hdGguc3FydCgxK2N0LVEtbXQpKjIscFszXT0oc3QtbnQpL2R0LHBbMF09KHJ0K2F0KS9kdCxwWzFdPS4yNSpkdCxwWzJdPShvdCtsdCkvZHQpOihkdD1NYXRoLnNxcnQoMSttdC1RLWN0KSoyLHBbM109KHJ0LWF0KS9kdCxwWzBdPShzdCtudCkvZHQscFsxXT0ob3QrbHQpL2R0LHBbMl09LjI1KmR0KSxwfWZ1bmN0aW9uICQocCxNLHcsVSl7dmFyIEs9TVswXSxZPU1bMV0sUT1NWzJdLHJ0PU1bM10sbnQ9SytLLGF0PVkrWSxjdD1RK1Esb3Q9SypudCxzdD1LKmF0LGx0PUsqY3QsbXQ9WSphdCxwdD1ZKmN0LGR0PVEqY3QseXQ9cnQqbnQsQXQ9cnQqYXQsU3Q9cnQqY3QsTXQ9VVswXSxUdD1VWzFdLEV0PVVbMl07cmV0dXJuIHBbMF09KDEtKG10K2R0KSkqTXQscFsxXT0oc3QrU3QpKk10LHBbMl09KGx0LUF0KSpNdCxwWzNdPTAscFs0XT0oc3QtU3QpKlR0LHBbNV09KDEtKG90K2R0KSkqVHQscFs2XT0ocHQreXQpKlR0LHBbN109MCxwWzhdPShsdCtBdCkqRXQscFs5XT0ocHQteXQpKkV0LHBbMTBdPSgxLShvdCttdCkpKkV0LHBbMTFdPTAscFsxMl09d1swXSxwWzEzXT13WzFdLHBbMTRdPXdbMl0scFsxNV09MSxwfWZ1bmN0aW9uIEgocCxNLHcsVSxLKXt2YXIgWT1NWzBdLFE9TVsxXSxydD1NWzJdLG50PU1bM10sYXQ9WStZLGN0PVErUSxvdD1ydCtydCxzdD1ZKmF0LGx0PVkqY3QsbXQ9WSpvdCxwdD1RKmN0LGR0PVEqb3QseXQ9cnQqb3QsQXQ9bnQqYXQsU3Q9bnQqY3QsTXQ9bnQqb3QsVHQ9VVswXSxFdD1VWzFdLFV0PVVbMl0sQnQ9S1swXSxXdD1LWzFdLEZ0PUtbMl0sJHQ9KDEtKHB0K3l0KSkqVHQsR3Q9KGx0K010KSpUdCxIdD0obXQtU3QpKlR0LEx0PShsdC1NdCkqRXQsWnQ9KDEtKHN0K3l0KSkqRXQsYmU9KGR0K0F0KSpFdCxTZT0obXQrU3QpKlV0LFJuPShkdC1BdCkqVXQsSW49KDEtKHN0K3B0KSkqVXQ7cmV0dXJuIHBbMF09JHQscFsxXT1HdCxwWzJdPUh0LHBbM109MCxwWzRdPUx0LHBbNV09WnQscFs2XT1iZSxwWzddPTAscFs4XT1TZSxwWzldPVJuLHBbMTBdPUluLHBbMTFdPTAscFsxMl09d1swXStCdC0oJHQqQnQrTHQqV3QrU2UqRnQpLHBbMTNdPXdbMV0rV3QtKEd0KkJ0K1p0Kld0K1JuKkZ0KSxwWzE0XT13WzJdK0Z0LShIdCpCdCtiZSpXdCtJbipGdCkscFsxNV09MSxwfWZ1bmN0aW9uIEoocCxNKXt2YXIgdz1NWzBdLFU9TVsxXSxLPU1bMl0sWT1NWzNdLFE9dyt3LHJ0PVUrVSxudD1LK0ssYXQ9dypRLGN0PVUqUSxvdD1VKnJ0LHN0PUsqUSxsdD1LKnJ0LG10PUsqbnQscHQ9WSpRLGR0PVkqcnQseXQ9WSpudDtyZXR1cm4gcFswXT0xLW90LW10LHBbMV09Y3QreXQscFsyXT1zdC1kdCxwWzNdPTAscFs0XT1jdC15dCxwWzVdPTEtYXQtbXQscFs2XT1sdCtwdCxwWzddPTAscFs4XT1zdCtkdCxwWzldPWx0LXB0LHBbMTBdPTEtYXQtb3QscFsxMV09MCxwWzEyXT0wLHBbMTNdPTAscFsxNF09MCxwWzE1XT0xLHB9ZnVuY3Rpb24gcShwLE0sdyxVLEssWSxRKXt2YXIgcnQ9MS8ody1NKSxudD0xLyhLLVUpLGF0PTEvKFktUSk7cmV0dXJuIHBbMF09WSoyKnJ0LHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzVdPVkqMipudCxwWzZdPTAscFs3XT0wLHBbOF09KHcrTSkqcnQscFs5XT0oSytVKSpudCxwWzEwXT0oUStZKSphdCxwWzExXT0tMSxwWzEyXT0wLHBbMTNdPTAscFsxNF09USpZKjIqYXQscFsxNV09MCxwfWZ1bmN0aW9uIEYocCxNLHcsVSxLKXt2YXIgWT0xL01hdGgudGFuKE0vMiksUTtyZXR1cm4gcFswXT1ZL3cscFsxXT0wLHBbMl09MCxwWzNdPTAscFs0XT0wLHBbNV09WSxwWzZdPTAscFs3XT0wLHBbOF09MCxwWzldPTAscFsxMV09LTEscFsxMl09MCxwWzEzXT0wLHBbMTVdPTAsSyE9bnVsbCYmSyE9PTEvMD8oUT0xLyhVLUspLHBbMTBdPShLK1UpKlEscFsxNF09MipLKlUqUSk6KHBbMTBdPS0xLHBbMTRdPS0yKlUpLHB9ZnVuY3Rpb24gRyhwLE0sdyxVKXt2YXIgSz1NYXRoLnRhbihNLnVwRGVncmVlcypNYXRoLlBJLzE4MCksWT1NYXRoLnRhbihNLmRvd25EZWdyZWVzKk1hdGguUEkvMTgwKSxRPU1hdGgudGFuKE0ubGVmdERlZ3JlZXMqTWF0aC5QSS8xODApLHJ0PU1hdGgudGFuKE0ucmlnaHREZWdyZWVzKk1hdGguUEkvMTgwKSxudD0yLyhRK3J0KSxhdD0yLyhLK1kpO3JldHVybiBwWzBdPW50LHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzVdPWF0LHBbNl09MCxwWzddPTAscFs4XT0tKChRLXJ0KSpudCouNSkscFs5XT0oSy1ZKSphdCouNSxwWzEwXT1VLyh3LVUpLHBbMTFdPS0xLHBbMTJdPTAscFsxM109MCxwWzE0XT1VKncvKHctVSkscFsxNV09MCxwfWZ1bmN0aW9uIFoocCxNLHcsVSxLLFksUSl7dmFyIHJ0PTEvKE0tdyksbnQ9MS8oVS1LKSxhdD0xLyhZLVEpO3JldHVybiBwWzBdPS0yKnJ0LHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzVdPS0yKm50LHBbNl09MCxwWzddPTAscFs4XT0wLHBbOV09MCxwWzEwXT0yKmF0LHBbMTFdPTAscFsxMl09KE0rdykqcnQscFsxM109KEsrVSkqbnQscFsxNF09KFErWSkqYXQscFsxNV09MSxwfWZ1bmN0aW9uIHR0KHAsTSx3LFUpe3ZhciBLLFksUSxydCxudCxhdCxjdCxvdCxzdCxsdCxtdD1NWzBdLHB0PU1bMV0sZHQ9TVsyXSx5dD1VWzBdLEF0PVVbMV0sU3Q9VVsyXSxNdD13WzBdLFR0PXdbMV0sRXQ9d1syXTtyZXR1cm4gTWF0aC5hYnMobXQtTXQpPHIuRVBTSUxPTiYmTWF0aC5hYnMocHQtVHQpPHIuRVBTSUxPTiYmTWF0aC5hYnMoZHQtRXQpPHIuRVBTSUxPTj9mKHApOihjdD1tdC1NdCxvdD1wdC1UdCxzdD1kdC1FdCxsdD0xL01hdGguaHlwb3QoY3Qsb3Qsc3QpLGN0Kj1sdCxvdCo9bHQsc3QqPWx0LEs9QXQqc3QtU3Qqb3QsWT1TdCpjdC15dCpzdCxRPXl0Km90LUF0KmN0LGx0PU1hdGguaHlwb3QoSyxZLFEpLGx0PyhsdD0xL2x0LEsqPWx0LFkqPWx0LFEqPWx0KTooSz0wLFk9MCxRPTApLHJ0PW90KlEtc3QqWSxudD1zdCpLLWN0KlEsYXQ9Y3QqWS1vdCpLLGx0PU1hdGguaHlwb3QocnQsbnQsYXQpLGx0PyhsdD0xL2x0LHJ0Kj1sdCxudCo9bHQsYXQqPWx0KToocnQ9MCxudD0wLGF0PTApLHBbMF09SyxwWzFdPXJ0LHBbMl09Y3QscFszXT0wLHBbNF09WSxwWzVdPW50LHBbNl09b3QscFs3XT0wLHBbOF09USxwWzldPWF0LHBbMTBdPXN0LHBbMTFdPTAscFsxMl09LShLKm10K1kqcHQrUSpkdCkscFsxM109LShydCptdCtudCpwdCthdCpkdCkscFsxNF09LShjdCptdCtvdCpwdCtzdCpkdCkscFsxNV09MSxwKX1mdW5jdGlvbiBldChwLE0sdyxVKXt2YXIgSz1NWzBdLFk9TVsxXSxRPU1bMl0scnQ9VVswXSxudD1VWzFdLGF0PVVbMl0sY3Q9Sy13WzBdLG90PVktd1sxXSxzdD1RLXdbMl0sbHQ9Y3QqY3Qrb3Qqb3Qrc3Qqc3Q7bHQ+MCYmKGx0PTEvTWF0aC5zcXJ0KGx0KSxjdCo9bHQsb3QqPWx0LHN0Kj1sdCk7dmFyIG10PW50KnN0LWF0Km90LHB0PWF0KmN0LXJ0KnN0LGR0PXJ0Km90LW50KmN0O3JldHVybiBsdD1tdCptdCtwdCpwdCtkdCpkdCxsdD4wJiYobHQ9MS9NYXRoLnNxcnQobHQpLG10Kj1sdCxwdCo9bHQsZHQqPWx0KSxwWzBdPW10LHBbMV09cHQscFsyXT1kdCxwWzNdPTAscFs0XT1vdCpkdC1zdCpwdCxwWzVdPXN0Km10LWN0KmR0LHBbNl09Y3QqcHQtb3QqbXQscFs3XT0wLHBbOF09Y3QscFs5XT1vdCxwWzEwXT1zdCxwWzExXT0wLHBbMTJdPUsscFsxM109WSxwWzE0XT1RLHBbMTVdPTEscH1mdW5jdGlvbiBpdChwKXtyZXR1cm4ibWF0NCgiK3BbMF0rIiwgIitwWzFdKyIsICIrcFsyXSsiLCAiK3BbM10rIiwgIitwWzRdKyIsICIrcFs1XSsiLCAiK3BbNl0rIiwgIitwWzddKyIsICIrcFs4XSsiLCAiK3BbOV0rIiwgIitwWzEwXSsiLCAiK3BbMTFdKyIsICIrcFsxMl0rIiwgIitwWzEzXSsiLCAiK3BbMTRdKyIsICIrcFsxNV0rIikifWZ1bmN0aW9uIGsocCl7cmV0dXJuIE1hdGguaHlwb3QocFswXSxwWzFdLHBbMl0scFszXSxwWzRdLHBbNV0scFs2XSxwWzddLHBbOF0scFs5XSxwWzEwXSxwWzExXSxwWzEyXSxwWzEzXSxwWzE0XSxwWzE1XSl9ZnVuY3Rpb24gaHQocCxNLHcpe3JldHVybiBwWzBdPU1bMF0rd1swXSxwWzFdPU1bMV0rd1sxXSxwWzJdPU1bMl0rd1syXSxwWzNdPU1bM10rd1szXSxwWzRdPU1bNF0rd1s0XSxwWzVdPU1bNV0rd1s1XSxwWzZdPU1bNl0rd1s2XSxwWzddPU1bN10rd1s3XSxwWzhdPU1bOF0rd1s4XSxwWzldPU1bOV0rd1s5XSxwWzEwXT1NWzEwXSt3WzEwXSxwWzExXT1NWzExXSt3WzExXSxwWzEyXT1NWzEyXSt3WzEyXSxwWzEzXT1NWzEzXSt3WzEzXSxwWzE0XT1NWzE0XSt3WzE0XSxwWzE1XT1NWzE1XSt3WzE1XSxwfWZ1bmN0aW9uIGZ0KHAsTSx3KXtyZXR1cm4gcFswXT1NWzBdLXdbMF0scFsxXT1NWzFdLXdbMV0scFsyXT1NWzJdLXdbMl0scFszXT1NWzNdLXdbM10scFs0XT1NWzRdLXdbNF0scFs1XT1NWzVdLXdbNV0scFs2XT1NWzZdLXdbNl0scFs3XT1NWzddLXdbN10scFs4XT1NWzhdLXdbOF0scFs5XT1NWzldLXdbOV0scFsxMF09TVsxMF0td1sxMF0scFsxMV09TVsxMV0td1sxMV0scFsxMl09TVsxMl0td1sxMl0scFsxM109TVsxM10td1sxM10scFsxNF09TVsxNF0td1sxNF0scFsxNV09TVsxNV0td1sxNV0scH1mdW5jdGlvbiBCKHAsTSx3KXtyZXR1cm4gcFswXT1NWzBdKncscFsxXT1NWzFdKncscFsyXT1NWzJdKncscFszXT1NWzNdKncscFs0XT1NWzRdKncscFs1XT1NWzVdKncscFs2XT1NWzZdKncscFs3XT1NWzddKncscFs4XT1NWzhdKncscFs5XT1NWzldKncscFsxMF09TVsxMF0qdyxwWzExXT1NWzExXSp3LHBbMTJdPU1bMTJdKncscFsxM109TVsxM10qdyxwWzE0XT1NWzE0XSp3LHBbMTVdPU1bMTVdKncscH1mdW5jdGlvbiBXKHAsTSx3LFUpe3JldHVybiBwWzBdPU1bMF0rd1swXSpVLHBbMV09TVsxXSt3WzFdKlUscFsyXT1NWzJdK3dbMl0qVSxwWzNdPU1bM10rd1szXSpVLHBbNF09TVs0XSt3WzRdKlUscFs1XT1NWzVdK3dbNV0qVSxwWzZdPU1bNl0rd1s2XSpVLHBbN109TVs3XSt3WzddKlUscFs4XT1NWzhdK3dbOF0qVSxwWzldPU1bOV0rd1s5XSpVLHBbMTBdPU1bMTBdK3dbMTBdKlUscFsxMV09TVsxMV0rd1sxMV0qVSxwWzEyXT1NWzEyXSt3WzEyXSpVLHBbMTNdPU1bMTNdK3dbMTNdKlUscFsxNF09TVsxNF0rd1sxNF0qVSxwWzE1XT1NWzE1XSt3WzE1XSpVLHB9ZnVuY3Rpb24gVihwLE0pe3JldHVybiBwWzBdPT09TVswXSYmcFsxXT09PU1bMV0mJnBbMl09PT1NWzJdJiZwWzNdPT09TVszXSYmcFs0XT09PU1bNF0mJnBbNV09PT1NWzVdJiZwWzZdPT09TVs2XSYmcFs3XT09PU1bN10mJnBbOF09PT1NWzhdJiZwWzldPT09TVs5XSYmcFsxMF09PT1NWzEwXSYmcFsxMV09PT1NWzExXSYmcFsxMl09PT1NWzEyXSYmcFsxM109PT1NWzEzXSYmcFsxNF09PT1NWzE0XSYmcFsxNV09PT1NWzE1XX1mdW5jdGlvbiBYKHAsTSl7dmFyIHc9cFswXSxVPXBbMV0sSz1wWzJdLFk9cFszXSxRPXBbNF0scnQ9cFs1XSxudD1wWzZdLGF0PXBbN10sY3Q9cFs4XSxvdD1wWzldLHN0PXBbMTBdLGx0PXBbMTFdLG10PXBbMTJdLHB0PXBbMTNdLGR0PXBbMTRdLHl0PXBbMTVdLEF0PU1bMF0sU3Q9TVsxXSxNdD1NWzJdLFR0PU1bM10sRXQ9TVs0XSxVdD1NWzVdLEJ0PU1bNl0sV3Q9TVs3XSxGdD1NWzhdLCR0PU1bOV0sR3Q9TVsxMF0sSHQ9TVsxMV0sTHQ9TVsxMl0sWnQ9TVsxM10sYmU9TVsxNF0sU2U9TVsxNV07cmV0dXJuIE1hdGguYWJzKHctQXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhBdCkpJiZNYXRoLmFicyhVLVN0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoU3QpKSYmTWF0aC5hYnMoSy1NdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEspLE1hdGguYWJzKE10KSkmJk1hdGguYWJzKFktVHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhZKSxNYXRoLmFicyhUdCkpJiZNYXRoLmFicyhRLUV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoUSksTWF0aC5hYnMoRXQpKSYmTWF0aC5hYnMocnQtVXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhydCksTWF0aC5hYnMoVXQpKSYmTWF0aC5hYnMobnQtQnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhudCksTWF0aC5hYnMoQnQpKSYmTWF0aC5hYnMoYXQtV3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhdCksTWF0aC5hYnMoV3QpKSYmTWF0aC5hYnMoY3QtRnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhjdCksTWF0aC5hYnMoRnQpKSYmTWF0aC5hYnMob3QtJHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhvdCksTWF0aC5hYnMoJHQpKSYmTWF0aC5hYnMoc3QtR3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhzdCksTWF0aC5hYnMoR3QpKSYmTWF0aC5hYnMobHQtSHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhsdCksTWF0aC5hYnMoSHQpKSYmTWF0aC5hYnMobXQtTHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhtdCksTWF0aC5hYnMoTHQpKSYmTWF0aC5hYnMocHQtWnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhwdCksTWF0aC5hYnMoWnQpKSYmTWF0aC5hYnMoZHQtYmUpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhkdCksTWF0aC5hYnMoYmUpKSYmTWF0aC5hYnMoeXQtU2UpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh5dCksTWF0aC5hYnMoU2UpKX12YXIgTj1ULHo9ZnR9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzZXRBeGlzQW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZ2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImdldEFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImNhbGN1bGF0ZVciLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZXhwIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImxuIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInBvdyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzbGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJmcm9tTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJmcm9tRXVsZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwicm90YXRpb25UbyIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3FsZXJwIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJzZXRBeGVzIixmdW5jdGlvbigpe3JldHVybiBCfSk7dmFyIHI9dCgyKSxuPXQoNSkscz10KDgpLGw9dCg5KTtmdW5jdGlvbiBjKCl7dmFyIFc9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihXWzBdPTAsV1sxXT0wLFdbMl09MCksV1szXT0xLFd9ZnVuY3Rpb24gbyhXKXtyZXR1cm4gV1swXT0wLFdbMV09MCxXWzJdPTAsV1szXT0xLFd9ZnVuY3Rpb24gZihXLFYsWCl7WD1YKi41O3ZhciBOPU1hdGguc2luKFgpO3JldHVybiBXWzBdPU4qVlswXSxXWzFdPU4qVlsxXSxXWzJdPU4qVlsyXSxXWzNdPU1hdGguY29zKFgpLFd9ZnVuY3Rpb24geChXLFYpe3ZhciBYPU1hdGguYWNvcyhWWzNdKSoyLE49TWF0aC5zaW4oWC8yKTtyZXR1cm4gTj5yLkVQU0lMT04/KFdbMF09VlswXS9OLFdbMV09VlsxXS9OLFdbMl09VlsyXS9OKTooV1swXT0xLFdbMV09MCxXWzJdPTApLFh9ZnVuY3Rpb24gZyhXLFYpe3ZhciBYPUooVyxWKTtyZXR1cm4gTWF0aC5hY29zKDIqWCpYLTEpfWZ1bmN0aW9uIHkoVyxWLFgpe3ZhciBOPVZbMF0sej1WWzFdLHA9VlsyXSxNPVZbM10sdz1YWzBdLFU9WFsxXSxLPVhbMl0sWT1YWzNdO3JldHVybiBXWzBdPU4qWStNKncreipLLXAqVSxXWzFdPXoqWStNKlUrcCp3LU4qSyxXWzJdPXAqWStNKksrTipVLXoqdyxXWzNdPU0qWS1OKncteipVLXAqSyxXfWZ1bmN0aW9uIG0oVyxWLFgpe1gqPS41O3ZhciBOPVZbMF0sej1WWzFdLHA9VlsyXSxNPVZbM10sdz1NYXRoLnNpbihYKSxVPU1hdGguY29zKFgpO3JldHVybiBXWzBdPU4qVStNKncsV1sxXT16KlUrcCp3LFdbMl09cCpVLXoqdyxXWzNdPU0qVS1OKncsV31mdW5jdGlvbiBUKFcsVixYKXtYKj0uNTt2YXIgTj1WWzBdLHo9VlsxXSxwPVZbMl0sTT1WWzNdLHc9TWF0aC5zaW4oWCksVT1NYXRoLmNvcyhYKTtyZXR1cm4gV1swXT1OKlUtcCp3LFdbMV09eipVK00qdyxXWzJdPXAqVStOKncsV1szXT1NKlUteip3LFd9ZnVuY3Rpb24gTyhXLFYsWCl7WCo9LjU7dmFyIE49VlswXSx6PVZbMV0scD1WWzJdLE09VlszXSx3PU1hdGguc2luKFgpLFU9TWF0aC5jb3MoWCk7cmV0dXJuIFdbMF09TipVK3oqdyxXWzFdPXoqVS1OKncsV1syXT1wKlUrTSp3LFdbM109TSpVLXAqdyxXfWZ1bmN0aW9uIHYoVyxWKXt2YXIgWD1WWzBdLE49VlsxXSx6PVZbMl07cmV0dXJuIFdbMF09WCxXWzFdPU4sV1syXT16LFdbM109TWF0aC5zcXJ0KE1hdGguYWJzKDEtWCpYLU4qTi16KnopKSxXfWZ1bmN0aW9uIFAoVyxWKXt2YXIgWD1WWzBdLE49VlsxXSx6PVZbMl0scD1WWzNdLE09TWF0aC5zcXJ0KFgqWCtOKk4reip6KSx3PU1hdGguZXhwKHApLFU9TT4wP3cqTWF0aC5zaW4oTSkvTTowO3JldHVybiBXWzBdPVgqVSxXWzFdPU4qVSxXWzJdPXoqVSxXWzNdPXcqTWF0aC5jb3MoTSksV31mdW5jdGlvbiBpKFcsVil7dmFyIFg9VlswXSxOPVZbMV0sej1WWzJdLHA9VlszXSxNPU1hdGguc3FydChYKlgrTipOK3oqeiksdz1NPjA/TWF0aC5hdGFuMihNLHApL006MDtyZXR1cm4gV1swXT1YKncsV1sxXT1OKncsV1syXT16KncsV1szXT0uNSpNYXRoLmxvZyhYKlgrTipOK3oqeitwKnApLFd9ZnVuY3Rpb24gdShXLFYsWCl7cmV0dXJuIGkoVyxWKSxIKFcsVyxYKSxQKFcsVyksV31mdW5jdGlvbiBhKFcsVixYLE4pe3ZhciB6PVZbMF0scD1WWzFdLE09VlsyXSx3PVZbM10sVT1YWzBdLEs9WFsxXSxZPVhbMl0sUT1YWzNdLHJ0LG50LGF0LGN0LG90O3JldHVybiBudD16KlUrcCpLK00qWSt3KlEsbnQ8MCYmKG50PS1udCxVPS1VLEs9LUssWT0tWSxRPS1RKSwxLW50PnIuRVBTSUxPTj8ocnQ9TWF0aC5hY29zKG50KSxhdD1NYXRoLnNpbihydCksY3Q9TWF0aC5zaW4oKDEtTikqcnQpL2F0LG90PU1hdGguc2luKE4qcnQpL2F0KTooY3Q9MS1OLG90PU4pLFdbMF09Y3QqeitvdCpVLFdbMV09Y3QqcCtvdCpLLFdbMl09Y3QqTStvdCpZLFdbM109Y3QqdytvdCpRLFd9ZnVuY3Rpb24gaChXKXt2YXIgVj1yLlJBTkRPTSgpLFg9ci5SQU5ET00oKSxOPXIuUkFORE9NKCksej1NYXRoLnNxcnQoMS1WKSxwPU1hdGguc3FydChWKTtyZXR1cm4gV1swXT16Kk1hdGguc2luKDIqTWF0aC5QSSpYKSxXWzFdPXoqTWF0aC5jb3MoMipNYXRoLlBJKlgpLFdbMl09cCpNYXRoLnNpbigyKk1hdGguUEkqTiksV1szXT1wKk1hdGguY29zKDIqTWF0aC5QSSpOKSxXfWZ1bmN0aW9uIGIoVyxWKXt2YXIgWD1WWzBdLE49VlsxXSx6PVZbMl0scD1WWzNdLE09WCpYK04qTit6KnorcCpwLHc9TT8xL006MDtyZXR1cm4gV1swXT0tWCp3LFdbMV09LU4qdyxXWzJdPS16KncsV1szXT1wKncsV31mdW5jdGlvbiBFKFcsVil7cmV0dXJuIFdbMF09LVZbMF0sV1sxXT0tVlsxXSxXWzJdPS1WWzJdLFdbM109VlszXSxXfWZ1bmN0aW9uIEEoVyxWKXt2YXIgWD1WWzBdK1ZbNF0rVls4XSxOO2lmKFg+MClOPU1hdGguc3FydChYKzEpLFdbM109LjUqTixOPS41L04sV1swXT0oVls1XS1WWzddKSpOLFdbMV09KFZbNl0tVlsyXSkqTixXWzJdPShWWzFdLVZbM10pKk47ZWxzZXt2YXIgej0wO1ZbNF0+VlswXSYmKHo9MSksVls4XT5WW3oqMyt6XSYmKHo9Mik7dmFyIHA9KHorMSklMyxNPSh6KzIpJTM7Tj1NYXRoLnNxcnQoVlt6KjMrel0tVltwKjMrcF0tVltNKjMrTV0rMSksV1t6XT0uNSpOLE49LjUvTixXWzNdPShWW3AqMytNXS1WW00qMytwXSkqTixXW3BdPShWW3AqMyt6XStWW3oqMytwXSkqTixXW01dPShWW00qMyt6XStWW3oqMytNXSkqTn1yZXR1cm4gV31mdW5jdGlvbiBMKFcsVixYLE4pe3ZhciB6PS41Kk1hdGguUEkvMTgwO1YqPXosWCo9eixOKj16O3ZhciBwPU1hdGguc2luKFYpLE09TWF0aC5jb3MoViksdz1NYXRoLnNpbihYKSxVPU1hdGguY29zKFgpLEs9TWF0aC5zaW4oTiksWT1NYXRoLmNvcyhOKTtyZXR1cm4gV1swXT1wKlUqWS1NKncqSyxXWzFdPU0qdypZK3AqVSpLLFdbMl09TSpVKkstcCp3KlksV1szXT1NKlUqWStwKncqSyxXfWZ1bmN0aW9uIFMoVyl7cmV0dXJuInF1YXQoIitXWzBdKyIsICIrV1sxXSsiLCAiK1dbMl0rIiwgIitXWzNdKyIpIn12YXIgST1sLmNsb25lLEQ9bC5mcm9tVmFsdWVzLFI9bC5jb3B5LEM9bC5zZXQsaj1sLmFkZCwkPXksSD1sLnNjYWxlLEo9bC5kb3QscT1sLmxlcnAsRj1sLmxlbmd0aCxHPUYsWj1sLnNxdWFyZWRMZW5ndGgsdHQ9WixldD1sLm5vcm1hbGl6ZSxpdD1sLmV4YWN0RXF1YWxzLGs9bC5lcXVhbHMsaHQ9ZnVuY3Rpb24oKXt2YXIgVz1zLmNyZWF0ZSgpLFY9cy5mcm9tVmFsdWVzKDEsMCwwKSxYPXMuZnJvbVZhbHVlcygwLDEsMCk7cmV0dXJuIGZ1bmN0aW9uKE4seixwKXt2YXIgTT1zLmRvdCh6LHApO3JldHVybiBNPC0uOTk5OTk5PyhzLmNyb3NzKFcsVix6KSxzLmxlbihXKTwxZS02JiZzLmNyb3NzKFcsWCx6KSxzLm5vcm1hbGl6ZShXLFcpLGYoTixXLE1hdGguUEkpLE4pOk0+Ljk5OTk5OT8oTlswXT0wLE5bMV09MCxOWzJdPTAsTlszXT0xLE4pOihzLmNyb3NzKFcseixwKSxOWzBdPVdbMF0sTlsxXT1XWzFdLE5bMl09V1syXSxOWzNdPTErTSxldChOLE4pKX19KCksZnQ9ZnVuY3Rpb24oKXt2YXIgVz1jKCksVj1jKCk7cmV0dXJuIGZ1bmN0aW9uKFgsTix6LHAsTSx3KXtyZXR1cm4gYShXLE4sTSx3KSxhKFYseixwLHcpLGEoWCxXLFYsMip3KigxLXcpKSxYfX0oKSxCPWZ1bmN0aW9uKCl7dmFyIFc9bi5jcmVhdGUoKTtyZXR1cm4gZnVuY3Rpb24oVixYLE4seil7cmV0dXJuIFdbMF09TlswXSxXWzNdPU5bMV0sV1s2XT1OWzJdLFdbMV09elswXSxXWzRdPXpbMV0sV1s3XT16WzJdLFdbMl09LVhbMF0sV1s1XT0tWFsxXSxXWzhdPS1YWzJdLGV0KFYsQShWLFcpKX19KCl9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiaGVybWl0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJiZXppZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBldH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGl0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiB6fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgTT1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKE1bMF09MCxNWzFdPTAsTVsyXT0wKSxNfWZ1bmN0aW9uIHMoTSl7dmFyIHc9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gd1swXT1NWzBdLHdbMV09TVsxXSx3WzJdPU1bMl0sd31mdW5jdGlvbiBsKE0pe3ZhciB3PU1bMF0sVT1NWzFdLEs9TVsyXTtyZXR1cm4gTWF0aC5oeXBvdCh3LFUsSyl9ZnVuY3Rpb24gYyhNLHcsVSl7dmFyIEs9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gS1swXT1NLEtbMV09dyxLWzJdPVUsS31mdW5jdGlvbiBvKE0sdyl7cmV0dXJuIE1bMF09d1swXSxNWzFdPXdbMV0sTVsyXT13WzJdLE19ZnVuY3Rpb24gZihNLHcsVSxLKXtyZXR1cm4gTVswXT13LE1bMV09VSxNWzJdPUssTX1mdW5jdGlvbiB4KE0sdyxVKXtyZXR1cm4gTVswXT13WzBdK1VbMF0sTVsxXT13WzFdK1VbMV0sTVsyXT13WzJdK1VbMl0sTX1mdW5jdGlvbiBnKE0sdyxVKXtyZXR1cm4gTVswXT13WzBdLVVbMF0sTVsxXT13WzFdLVVbMV0sTVsyXT13WzJdLVVbMl0sTX1mdW5jdGlvbiB5KE0sdyxVKXtyZXR1cm4gTVswXT13WzBdKlVbMF0sTVsxXT13WzFdKlVbMV0sTVsyXT13WzJdKlVbMl0sTX1mdW5jdGlvbiBtKE0sdyxVKXtyZXR1cm4gTVswXT13WzBdL1VbMF0sTVsxXT13WzFdL1VbMV0sTVsyXT13WzJdL1VbMl0sTX1mdW5jdGlvbiBUKE0sdyl7cmV0dXJuIE1bMF09TWF0aC5jZWlsKHdbMF0pLE1bMV09TWF0aC5jZWlsKHdbMV0pLE1bMl09TWF0aC5jZWlsKHdbMl0pLE19ZnVuY3Rpb24gTyhNLHcpe3JldHVybiBNWzBdPU1hdGguZmxvb3Iod1swXSksTVsxXT1NYXRoLmZsb29yKHdbMV0pLE1bMl09TWF0aC5mbG9vcih3WzJdKSxNfWZ1bmN0aW9uIHYoTSx3LFUpe3JldHVybiBNWzBdPU1hdGgubWluKHdbMF0sVVswXSksTVsxXT1NYXRoLm1pbih3WzFdLFVbMV0pLE1bMl09TWF0aC5taW4od1syXSxVWzJdKSxNfWZ1bmN0aW9uIFAoTSx3LFUpe3JldHVybiBNWzBdPU1hdGgubWF4KHdbMF0sVVswXSksTVsxXT1NYXRoLm1heCh3WzFdLFVbMV0pLE1bMl09TWF0aC5tYXgod1syXSxVWzJdKSxNfWZ1bmN0aW9uIGkoTSx3KXtyZXR1cm4gTVswXT1NYXRoLnJvdW5kKHdbMF0pLE1bMV09TWF0aC5yb3VuZCh3WzFdKSxNWzJdPU1hdGgucm91bmQod1syXSksTX1mdW5jdGlvbiB1KE0sdyxVKXtyZXR1cm4gTVswXT13WzBdKlUsTVsxXT13WzFdKlUsTVsyXT13WzJdKlUsTX1mdW5jdGlvbiBhKE0sdyxVLEspe3JldHVybiBNWzBdPXdbMF0rVVswXSpLLE1bMV09d1sxXStVWzFdKkssTVsyXT13WzJdK1VbMl0qSyxNfWZ1bmN0aW9uIGgoTSx3KXt2YXIgVT13WzBdLU1bMF0sSz13WzFdLU1bMV0sWT13WzJdLU1bMl07cmV0dXJuIE1hdGguaHlwb3QoVSxLLFkpfWZ1bmN0aW9uIGIoTSx3KXt2YXIgVT13WzBdLU1bMF0sSz13WzFdLU1bMV0sWT13WzJdLU1bMl07cmV0dXJuIFUqVStLKksrWSpZfWZ1bmN0aW9uIEUoTSl7dmFyIHc9TVswXSxVPU1bMV0sSz1NWzJdO3JldHVybiB3KncrVSpVK0sqS31mdW5jdGlvbiBBKE0sdyl7cmV0dXJuIE1bMF09LXdbMF0sTVsxXT0td1sxXSxNWzJdPS13WzJdLE19ZnVuY3Rpb24gTChNLHcpe3JldHVybiBNWzBdPTEvd1swXSxNWzFdPTEvd1sxXSxNWzJdPTEvd1syXSxNfWZ1bmN0aW9uIFMoTSx3KXt2YXIgVT13WzBdLEs9d1sxXSxZPXdbMl0sUT1VKlUrSypLK1kqWTtyZXR1cm4gUT4wJiYoUT0xL01hdGguc3FydChRKSksTVswXT13WzBdKlEsTVsxXT13WzFdKlEsTVsyXT13WzJdKlEsTX1mdW5jdGlvbiBJKE0sdyl7cmV0dXJuIE1bMF0qd1swXStNWzFdKndbMV0rTVsyXSp3WzJdfWZ1bmN0aW9uIEQoTSx3LFUpe3ZhciBLPXdbMF0sWT13WzFdLFE9d1syXSxydD1VWzBdLG50PVVbMV0sYXQ9VVsyXTtyZXR1cm4gTVswXT1ZKmF0LVEqbnQsTVsxXT1RKnJ0LUsqYXQsTVsyXT1LKm50LVkqcnQsTX1mdW5jdGlvbiBSKE0sdyxVLEspe3ZhciBZPXdbMF0sUT13WzFdLHJ0PXdbMl07cmV0dXJuIE1bMF09WStLKihVWzBdLVkpLE1bMV09UStLKihVWzFdLVEpLE1bMl09cnQrSyooVVsyXS1ydCksTX1mdW5jdGlvbiBDKE0sdyxVLEssWSxRKXt2YXIgcnQ9USpRLG50PXJ0KigyKlEtMykrMSxhdD1ydCooUS0yKStRLGN0PXJ0KihRLTEpLG90PXJ0KigzLTIqUSk7cmV0dXJuIE1bMF09d1swXSpudCtVWzBdKmF0K0tbMF0qY3QrWVswXSpvdCxNWzFdPXdbMV0qbnQrVVsxXSphdCtLWzFdKmN0K1lbMV0qb3QsTVsyXT13WzJdKm50K1VbMl0qYXQrS1syXSpjdCtZWzJdKm90LE19ZnVuY3Rpb24gaihNLHcsVSxLLFksUSl7dmFyIHJ0PTEtUSxudD1ydCpydCxhdD1RKlEsY3Q9bnQqcnQsb3Q9MypRKm50LHN0PTMqYXQqcnQsbHQ9YXQqUTtyZXR1cm4gTVswXT13WzBdKmN0K1VbMF0qb3QrS1swXSpzdCtZWzBdKmx0LE1bMV09d1sxXSpjdCtVWzFdKm90K0tbMV0qc3QrWVsxXSpsdCxNWzJdPXdbMl0qY3QrVVsyXSpvdCtLWzJdKnN0K1lbMl0qbHQsTX1mdW5jdGlvbiAkKE0sdyl7dz13fHwxO3ZhciBVPXIuUkFORE9NKCkqMipNYXRoLlBJLEs9ci5SQU5ET00oKSoyLTEsWT1NYXRoLnNxcnQoMS1LKkspKnc7cmV0dXJuIE1bMF09TWF0aC5jb3MoVSkqWSxNWzFdPU1hdGguc2luKFUpKlksTVsyXT1LKncsTX1mdW5jdGlvbiBIKE0sdyxVKXt2YXIgSz13WzBdLFk9d1sxXSxRPXdbMl0scnQ9VVszXSpLK1VbN10qWStVWzExXSpRK1VbMTVdO3JldHVybiBydD1ydHx8MSxNWzBdPShVWzBdKksrVVs0XSpZK1VbOF0qUStVWzEyXSkvcnQsTVsxXT0oVVsxXSpLK1VbNV0qWStVWzldKlErVVsxM10pL3J0LE1bMl09KFVbMl0qSytVWzZdKlkrVVsxMF0qUStVWzE0XSkvcnQsTX1mdW5jdGlvbiBKKE0sdyxVKXt2YXIgSz13WzBdLFk9d1sxXSxRPXdbMl07cmV0dXJuIE1bMF09SypVWzBdK1kqVVszXStRKlVbNl0sTVsxXT1LKlVbMV0rWSpVWzRdK1EqVVs3XSxNWzJdPUsqVVsyXStZKlVbNV0rUSpVWzhdLE19ZnVuY3Rpb24gcShNLHcsVSl7dmFyIEs9VVswXSxZPVVbMV0sUT1VWzJdLHJ0PVVbM10sbnQ9d1swXSxhdD13WzFdLGN0PXdbMl0sb3Q9WSpjdC1RKmF0LHN0PVEqbnQtSypjdCxsdD1LKmF0LVkqbnQsbXQ9WSpsdC1RKnN0LHB0PVEqb3QtSypsdCxkdD1LKnN0LVkqb3QseXQ9cnQqMjtyZXR1cm4gb3QqPXl0LHN0Kj15dCxsdCo9eXQsbXQqPTIscHQqPTIsZHQqPTIsTVswXT1udCtvdCttdCxNWzFdPWF0K3N0K3B0LE1bMl09Y3QrbHQrZHQsTX1mdW5jdGlvbiBGKE0sdyxVLEspe3ZhciBZPVtdLFE9W107cmV0dXJuIFlbMF09d1swXS1VWzBdLFlbMV09d1sxXS1VWzFdLFlbMl09d1syXS1VWzJdLFFbMF09WVswXSxRWzFdPVlbMV0qTWF0aC5jb3MoSyktWVsyXSpNYXRoLnNpbihLKSxRWzJdPVlbMV0qTWF0aC5zaW4oSykrWVsyXSpNYXRoLmNvcyhLKSxNWzBdPVFbMF0rVVswXSxNWzFdPVFbMV0rVVsxXSxNWzJdPVFbMl0rVVsyXSxNfWZ1bmN0aW9uIEcoTSx3LFUsSyl7dmFyIFk9W10sUT1bXTtyZXR1cm4gWVswXT13WzBdLVVbMF0sWVsxXT13WzFdLVVbMV0sWVsyXT13WzJdLVVbMl0sUVswXT1ZWzJdKk1hdGguc2luKEspK1lbMF0qTWF0aC5jb3MoSyksUVsxXT1ZWzFdLFFbMl09WVsyXSpNYXRoLmNvcyhLKS1ZWzBdKk1hdGguc2luKEspLE1bMF09UVswXStVWzBdLE1bMV09UVsxXStVWzFdLE1bMl09UVsyXStVWzJdLE19ZnVuY3Rpb24gWihNLHcsVSxLKXt2YXIgWT1bXSxRPVtdO3JldHVybiBZWzBdPXdbMF0tVVswXSxZWzFdPXdbMV0tVVsxXSxZWzJdPXdbMl0tVVsyXSxRWzBdPVlbMF0qTWF0aC5jb3MoSyktWVsxXSpNYXRoLnNpbihLKSxRWzFdPVlbMF0qTWF0aC5zaW4oSykrWVsxXSpNYXRoLmNvcyhLKSxRWzJdPVlbMl0sTVswXT1RWzBdK1VbMF0sTVsxXT1RWzFdK1VbMV0sTVsyXT1RWzJdK1VbMl0sTX1mdW5jdGlvbiB0dChNLHcpe3ZhciBVPU1bMF0sSz1NWzFdLFk9TVsyXSxRPXdbMF0scnQ9d1sxXSxudD13WzJdLGF0PU1hdGguc3FydChVKlUrSypLK1kqWSksY3Q9TWF0aC5zcXJ0KFEqUStydCpydCtudCpudCksb3Q9YXQqY3Qsc3Q9b3QmJkkoTSx3KS9vdDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KHN0LC0xKSwxKSl9ZnVuY3Rpb24gZXQoTSl7cmV0dXJuIE1bMF09MCxNWzFdPTAsTVsyXT0wLE19ZnVuY3Rpb24gaXQoTSl7cmV0dXJuInZlYzMoIitNWzBdKyIsICIrTVsxXSsiLCAiK01bMl0rIikifWZ1bmN0aW9uIGsoTSx3KXtyZXR1cm4gTVswXT09PXdbMF0mJk1bMV09PT13WzFdJiZNWzJdPT09d1syXX1mdW5jdGlvbiBodChNLHcpe3ZhciBVPU1bMF0sSz1NWzFdLFk9TVsyXSxRPXdbMF0scnQ9d1sxXSxudD13WzJdO3JldHVybiBNYXRoLmFicyhVLVEpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhVKSxNYXRoLmFicyhRKSkmJk1hdGguYWJzKEstcnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhZLW50KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWSksTWF0aC5hYnMobnQpKX12YXIgZnQ9ZyxCPXksVz1tLFY9aCxYPWIsTj1sLHo9RSxwPWZ1bmN0aW9uKCl7dmFyIE09bigpO3JldHVybiBmdW5jdGlvbih3LFUsSyxZLFEscnQpe3ZhciBudCxhdDtmb3IoVXx8KFU9MyksS3x8KEs9MCksWT9hdD1NYXRoLm1pbihZKlUrSyx3Lmxlbmd0aCk6YXQ9dy5sZW5ndGgsbnQ9SztudDxhdDtudCs9VSlNWzBdPXdbbnRdLE1bMV09d1tudCsxXSxNWzJdPXdbbnQrMl0sUShNLE0scnQpLHdbbnRdPU1bMF0sd1tudCsxXT1NWzFdLHdbbnQrMl09TVsyXTtyZXR1cm4gd319KCl9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJkaXZpZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY2VpbCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJmbG9vciIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJtaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwibWF4IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInJvdW5kIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNxdWFyZWREaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwidHJhbnNmb3JtUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGl0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBuKCl7dmFyIEI9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTApLEJ9ZnVuY3Rpb24gcyhCKXt2YXIgVz1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBXWzBdPUJbMF0sV1sxXT1CWzFdLFdbMl09QlsyXSxXWzNdPUJbM10sV31mdW5jdGlvbiBsKEIsVyxWLFgpe3ZhciBOPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIE5bMF09QixOWzFdPVcsTlsyXT1WLE5bM109WCxOfWZ1bmN0aW9uIGMoQixXKXtyZXR1cm4gQlswXT1XWzBdLEJbMV09V1sxXSxCWzJdPVdbMl0sQlszXT1XWzNdLEJ9ZnVuY3Rpb24gbyhCLFcsVixYLE4pe3JldHVybiBCWzBdPVcsQlsxXT1WLEJbMl09WCxCWzNdPU4sQn1mdW5jdGlvbiBmKEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdK1ZbMF0sQlsxXT1XWzFdK1ZbMV0sQlsyXT1XWzJdK1ZbMl0sQlszXT1XWzNdK1ZbM10sQn1mdW5jdGlvbiB4KEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdLVZbMF0sQlsxXT1XWzFdLVZbMV0sQlsyXT1XWzJdLVZbMl0sQlszXT1XWzNdLVZbM10sQn1mdW5jdGlvbiBnKEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdKlZbMF0sQlsxXT1XWzFdKlZbMV0sQlsyXT1XWzJdKlZbMl0sQlszXT1XWzNdKlZbM10sQn1mdW5jdGlvbiB5KEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdL1ZbMF0sQlsxXT1XWzFdL1ZbMV0sQlsyXT1XWzJdL1ZbMl0sQlszXT1XWzNdL1ZbM10sQn1mdW5jdGlvbiBtKEIsVyl7cmV0dXJuIEJbMF09TWF0aC5jZWlsKFdbMF0pLEJbMV09TWF0aC5jZWlsKFdbMV0pLEJbMl09TWF0aC5jZWlsKFdbMl0pLEJbM109TWF0aC5jZWlsKFdbM10pLEJ9ZnVuY3Rpb24gVChCLFcpe3JldHVybiBCWzBdPU1hdGguZmxvb3IoV1swXSksQlsxXT1NYXRoLmZsb29yKFdbMV0pLEJbMl09TWF0aC5mbG9vcihXWzJdKSxCWzNdPU1hdGguZmxvb3IoV1szXSksQn1mdW5jdGlvbiBPKEIsVyxWKXtyZXR1cm4gQlswXT1NYXRoLm1pbihXWzBdLFZbMF0pLEJbMV09TWF0aC5taW4oV1sxXSxWWzFdKSxCWzJdPU1hdGgubWluKFdbMl0sVlsyXSksQlszXT1NYXRoLm1pbihXWzNdLFZbM10pLEJ9ZnVuY3Rpb24gdihCLFcsVil7cmV0dXJuIEJbMF09TWF0aC5tYXgoV1swXSxWWzBdKSxCWzFdPU1hdGgubWF4KFdbMV0sVlsxXSksQlsyXT1NYXRoLm1heChXWzJdLFZbMl0pLEJbM109TWF0aC5tYXgoV1szXSxWWzNdKSxCfWZ1bmN0aW9uIFAoQixXKXtyZXR1cm4gQlswXT1NYXRoLnJvdW5kKFdbMF0pLEJbMV09TWF0aC5yb3VuZChXWzFdKSxCWzJdPU1hdGgucm91bmQoV1syXSksQlszXT1NYXRoLnJvdW5kKFdbM10pLEJ9ZnVuY3Rpb24gaShCLFcsVil7cmV0dXJuIEJbMF09V1swXSpWLEJbMV09V1sxXSpWLEJbMl09V1syXSpWLEJbM109V1szXSpWLEJ9ZnVuY3Rpb24gdShCLFcsVixYKXtyZXR1cm4gQlswXT1XWzBdK1ZbMF0qWCxCWzFdPVdbMV0rVlsxXSpYLEJbMl09V1syXStWWzJdKlgsQlszXT1XWzNdK1ZbM10qWCxCfWZ1bmN0aW9uIGEoQixXKXt2YXIgVj1XWzBdLUJbMF0sWD1XWzFdLUJbMV0sTj1XWzJdLUJbMl0sej1XWzNdLUJbM107cmV0dXJuIE1hdGguaHlwb3QoVixYLE4seil9ZnVuY3Rpb24gaChCLFcpe3ZhciBWPVdbMF0tQlswXSxYPVdbMV0tQlsxXSxOPVdbMl0tQlsyXSx6PVdbM10tQlszXTtyZXR1cm4gVipWK1gqWCtOKk4reip6fWZ1bmN0aW9uIGIoQil7dmFyIFc9QlswXSxWPUJbMV0sWD1CWzJdLE49QlszXTtyZXR1cm4gTWF0aC5oeXBvdChXLFYsWCxOKX1mdW5jdGlvbiBFKEIpe3ZhciBXPUJbMF0sVj1CWzFdLFg9QlsyXSxOPUJbM107cmV0dXJuIFcqVytWKlYrWCpYK04qTn1mdW5jdGlvbiBBKEIsVyl7cmV0dXJuIEJbMF09LVdbMF0sQlsxXT0tV1sxXSxCWzJdPS1XWzJdLEJbM109LVdbM10sQn1mdW5jdGlvbiBMKEIsVyl7cmV0dXJuIEJbMF09MS9XWzBdLEJbMV09MS9XWzFdLEJbMl09MS9XWzJdLEJbM109MS9XWzNdLEJ9ZnVuY3Rpb24gUyhCLFcpe3ZhciBWPVdbMF0sWD1XWzFdLE49V1syXSx6PVdbM10scD1WKlYrWCpYK04qTit6Kno7cmV0dXJuIHA+MCYmKHA9MS9NYXRoLnNxcnQocCkpLEJbMF09VipwLEJbMV09WCpwLEJbMl09TipwLEJbM109eipwLEJ9ZnVuY3Rpb24gSShCLFcpe3JldHVybiBCWzBdKldbMF0rQlsxXSpXWzFdK0JbMl0qV1syXStCWzNdKldbM119ZnVuY3Rpb24gRChCLFcsVixYKXt2YXIgTj1WWzBdKlhbMV0tVlsxXSpYWzBdLHo9VlswXSpYWzJdLVZbMl0qWFswXSxwPVZbMF0qWFszXS1WWzNdKlhbMF0sTT1WWzFdKlhbMl0tVlsyXSpYWzFdLHc9VlsxXSpYWzNdLVZbM10qWFsxXSxVPVZbMl0qWFszXS1WWzNdKlhbMl0sSz1XWzBdLFk9V1sxXSxRPVdbMl0scnQ9V1szXTtyZXR1cm4gQlswXT1ZKlUtUSp3K3J0Kk0sQlsxXT0tKEsqVSkrUSpwLXJ0KnosQlsyXT1LKnctWSpwK3J0Kk4sQlszXT0tKEsqTSkrWSp6LVEqTixCfWZ1bmN0aW9uIFIoQixXLFYsWCl7dmFyIE49V1swXSx6PVdbMV0scD1XWzJdLE09V1szXTtyZXR1cm4gQlswXT1OK1gqKFZbMF0tTiksQlsxXT16K1gqKFZbMV0teiksQlsyXT1wK1gqKFZbMl0tcCksQlszXT1NK1gqKFZbM10tTSksQn1mdW5jdGlvbiBDKEIsVyl7Vz1XfHwxO3ZhciBWLFgsTix6LHAsTTtkbyBWPXIuUkFORE9NKCkqMi0xLFg9ci5SQU5ET00oKSoyLTEscD1WKlYrWCpYO3doaWxlKHA+PTEpO2RvIE49ci5SQU5ET00oKSoyLTEsej1yLlJBTkRPTSgpKjItMSxNPU4qTit6Kno7d2hpbGUoTT49MSk7dmFyIHc9TWF0aC5zcXJ0KCgxLXApL00pO3JldHVybiBCWzBdPVcqVixCWzFdPVcqWCxCWzJdPVcqTip3LEJbM109Vyp6KncsQn1mdW5jdGlvbiBqKEIsVyxWKXt2YXIgWD1XWzBdLE49V1sxXSx6PVdbMl0scD1XWzNdO3JldHVybiBCWzBdPVZbMF0qWCtWWzRdKk4rVls4XSp6K1ZbMTJdKnAsQlsxXT1WWzFdKlgrVls1XSpOK1ZbOV0qeitWWzEzXSpwLEJbMl09VlsyXSpYK1ZbNl0qTitWWzEwXSp6K1ZbMTRdKnAsQlszXT1WWzNdKlgrVls3XSpOK1ZbMTFdKnorVlsxNV0qcCxCfWZ1bmN0aW9uICQoQixXLFYpe3ZhciBYPVdbMF0sTj1XWzFdLHo9V1syXSxwPVZbMF0sTT1WWzFdLHc9VlsyXSxVPVZbM10sSz1VKlgrTSp6LXcqTixZPVUqTit3KlgtcCp6LFE9VSp6K3AqTi1NKlgscnQ9LXAqWC1NKk4tdyp6O3JldHVybiBCWzBdPUsqVStydCotcCtZKi13LVEqLU0sQlsxXT1ZKlUrcnQqLU0rUSotcC1LKi13LEJbMl09USpVK3J0Ki13K0sqLU0tWSotcCxCWzNdPVdbM10sQn1mdW5jdGlvbiBIKEIpe3JldHVybiBCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTAsQn1mdW5jdGlvbiBKKEIpe3JldHVybiJ2ZWM0KCIrQlswXSsiLCAiK0JbMV0rIiwgIitCWzJdKyIsICIrQlszXSsiKSJ9ZnVuY3Rpb24gcShCLFcpe3JldHVybiBCWzBdPT09V1swXSYmQlsxXT09PVdbMV0mJkJbMl09PT1XWzJdJiZCWzNdPT09V1szXX1mdW5jdGlvbiBGKEIsVyl7dmFyIFY9QlswXSxYPUJbMV0sTj1CWzJdLHo9QlszXSxwPVdbMF0sTT1XWzFdLHc9V1syXSxVPVdbM107cmV0dXJuIE1hdGguYWJzKFYtcCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKHApKSYmTWF0aC5hYnMoWC1NKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMoTSkpJiZNYXRoLmFicyhOLXcpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhOKSxNYXRoLmFicyh3KSkmJk1hdGguYWJzKHotVSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKFUpKX12YXIgRz14LFo9Zyx0dD15LGV0PWEsaXQ9aCxrPWIsaHQ9RSxmdD1mdW5jdGlvbigpe3ZhciBCPW4oKTtyZXR1cm4gZnVuY3Rpb24oVyxWLFgsTix6LHApe3ZhciBNLHc7Zm9yKFZ8fChWPTQpLFh8fChYPTApLE4/dz1NYXRoLm1pbihOKlYrWCxXLmxlbmd0aCk6dz1XLmxlbmd0aCxNPVg7TTx3O00rPVYpQlswXT1XW01dLEJbMV09V1tNKzFdLEJbMl09V1tNKzJdLEJbM109V1tNKzNdLHooQixCLHApLFdbTV09QlswXSxXW00rMV09QlsxXSxXW00rMl09QlsyXSxXW00rM109QlszXTtyZXR1cm4gV319KCl9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZ2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJnZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInNldFJlYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0RHVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwicm90YXRlQnlRdWF0QXBwZW5kIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInJvdGF0ZUJ5UXVhdFByZXBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwicm90YXRlQXJvdW5kQXhpcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaXR9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSk7dmFyIHI9dCgyKSxuPXQoNykscz10KDYpO2Z1bmN0aW9uIGwoKXt2YXIgQj1uZXcgci5BUlJBWV9UWVBFKDgpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKEJbMF09MCxCWzFdPTAsQlsyXT0wLEJbNF09MCxCWzVdPTAsQls2XT0wLEJbN109MCksQlszXT0xLEJ9ZnVuY3Rpb24gYyhCKXt2YXIgVz1uZXcgci5BUlJBWV9UWVBFKDgpO3JldHVybiBXWzBdPUJbMF0sV1sxXT1CWzFdLFdbMl09QlsyXSxXWzNdPUJbM10sV1s0XT1CWzRdLFdbNV09Qls1XSxXWzZdPUJbNl0sV1s3XT1CWzddLFd9ZnVuY3Rpb24gbyhCLFcsVixYLE4seixwLE0pe3ZhciB3PW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIHdbMF09Qix3WzFdPVcsd1syXT1WLHdbM109WCx3WzRdPU4sd1s1XT16LHdbNl09cCx3WzddPU0sd31mdW5jdGlvbiBmKEIsVyxWLFgsTix6LHApe3ZhciBNPW5ldyByLkFSUkFZX1RZUEUoOCk7TVswXT1CLE1bMV09VyxNWzJdPVYsTVszXT1YO3ZhciB3PU4qLjUsVT16Ki41LEs9cCouNTtyZXR1cm4gTVs0XT13KlgrVSpWLUsqVyxNWzVdPVUqWCtLKkItdypWLE1bNl09SypYK3cqVy1VKkIsTVs3XT0tdypCLVUqVy1LKlYsTX1mdW5jdGlvbiB4KEIsVyxWKXt2YXIgWD1WWzBdKi41LE49VlsxXSouNSx6PVZbMl0qLjUscD1XWzBdLE09V1sxXSx3PVdbMl0sVT1XWzNdO3JldHVybiBCWzBdPXAsQlsxXT1NLEJbMl09dyxCWzNdPVUsQls0XT1YKlUrTip3LXoqTSxCWzVdPU4qVSt6KnAtWCp3LEJbNl09eipVK1gqTS1OKnAsQls3XT0tWCpwLU4qTS16KncsQn1mdW5jdGlvbiBnKEIsVyl7cmV0dXJuIEJbMF09MCxCWzFdPTAsQlsyXT0wLEJbM109MSxCWzRdPVdbMF0qLjUsQls1XT1XWzFdKi41LEJbNl09V1syXSouNSxCWzddPTAsQn1mdW5jdGlvbiB5KEIsVyl7cmV0dXJuIEJbMF09V1swXSxCWzFdPVdbMV0sQlsyXT1XWzJdLEJbM109V1szXSxCWzRdPTAsQls1XT0wLEJbNl09MCxCWzddPTAsQn1mdW5jdGlvbiBtKEIsVyl7dmFyIFY9bi5jcmVhdGUoKTtzLmdldFJvdGF0aW9uKFYsVyk7dmFyIFg9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gcy5nZXRUcmFuc2xhdGlvbihYLFcpLHgoQixWLFgpLEJ9ZnVuY3Rpb24gVChCLFcpe3JldHVybiBCWzBdPVdbMF0sQlsxXT1XWzFdLEJbMl09V1syXSxCWzNdPVdbM10sQls0XT1XWzRdLEJbNV09V1s1XSxCWzZdPVdbNl0sQls3XT1XWzddLEJ9ZnVuY3Rpb24gTyhCKXtyZXR1cm4gQlswXT0wLEJbMV09MCxCWzJdPTAsQlszXT0xLEJbNF09MCxCWzVdPTAsQls2XT0wLEJbN109MCxCfWZ1bmN0aW9uIHYoQixXLFYsWCxOLHoscCxNLHcpe3JldHVybiBCWzBdPVcsQlsxXT1WLEJbMl09WCxCWzNdPU4sQls0XT16LEJbNV09cCxCWzZdPU0sQls3XT13LEJ9dmFyIFA9bi5jb3B5O2Z1bmN0aW9uIGkoQixXKXtyZXR1cm4gQlswXT1XWzRdLEJbMV09V1s1XSxCWzJdPVdbNl0sQlszXT1XWzddLEJ9dmFyIHU9bi5jb3B5O2Z1bmN0aW9uIGEoQixXKXtyZXR1cm4gQls0XT1XWzBdLEJbNV09V1sxXSxCWzZdPVdbMl0sQls3XT1XWzNdLEJ9ZnVuY3Rpb24gaChCLFcpe3ZhciBWPVdbNF0sWD1XWzVdLE49V1s2XSx6PVdbN10scD0tV1swXSxNPS1XWzFdLHc9LVdbMl0sVT1XWzNdO3JldHVybiBCWzBdPShWKlUreipwK1gqdy1OKk0pKjIsQlsxXT0oWCpVK3oqTStOKnAtVip3KSoyLEJbMl09KE4qVSt6KncrVipNLVgqcCkqMixCfWZ1bmN0aW9uIGIoQixXLFYpe3ZhciBYPVdbMF0sTj1XWzFdLHo9V1syXSxwPVdbM10sTT1WWzBdKi41LHc9VlsxXSouNSxVPVZbMl0qLjUsSz1XWzRdLFk9V1s1XSxRPVdbNl0scnQ9V1s3XTtyZXR1cm4gQlswXT1YLEJbMV09TixCWzJdPXosQlszXT1wLEJbNF09cCpNK04qVS16KncrSyxCWzVdPXAqdyt6Kk0tWCpVK1ksQls2XT1wKlUrWCp3LU4qTStRLEJbN109LVgqTS1OKncteipVK3J0LEJ9ZnVuY3Rpb24gRShCLFcsVil7dmFyIFg9LVdbMF0sTj0tV1sxXSx6PS1XWzJdLHA9V1szXSxNPVdbNF0sdz1XWzVdLFU9V1s2XSxLPVdbN10sWT1NKnArSypYK3cqei1VKk4sUT13KnArSypOK1UqWC1NKnoscnQ9VSpwK0sqeitNKk4tdypYLG50PUsqcC1NKlgtdypOLVUqejtyZXR1cm4gbi5yb3RhdGVYKEIsVyxWKSxYPUJbMF0sTj1CWzFdLHo9QlsyXSxwPUJbM10sQls0XT1ZKnArbnQqWCtRKnotcnQqTixCWzVdPVEqcCtudCpOK3J0KlgtWSp6LEJbNl09cnQqcCtudCp6K1kqTi1RKlgsQls3XT1udCpwLVkqWC1RKk4tcnQqeixCfWZ1bmN0aW9uIEEoQixXLFYpe3ZhciBYPS1XWzBdLE49LVdbMV0sej0tV1syXSxwPVdbM10sTT1XWzRdLHc9V1s1XSxVPVdbNl0sSz1XWzddLFk9TSpwK0sqWCt3KnotVSpOLFE9dypwK0sqTitVKlgtTSp6LHJ0PVUqcCtLKnorTSpOLXcqWCxudD1LKnAtTSpYLXcqTi1VKno7cmV0dXJuIG4ucm90YXRlWShCLFcsViksWD1CWzBdLE49QlsxXSx6PUJbMl0scD1CWzNdLEJbNF09WSpwK250KlgrUSp6LXJ0Kk4sQls1XT1RKnArbnQqTitydCpYLVkqeixCWzZdPXJ0KnArbnQqeitZKk4tUSpYLEJbN109bnQqcC1ZKlgtUSpOLXJ0KnosQn1mdW5jdGlvbiBMKEIsVyxWKXt2YXIgWD0tV1swXSxOPS1XWzFdLHo9LVdbMl0scD1XWzNdLE09V1s0XSx3PVdbNV0sVT1XWzZdLEs9V1s3XSxZPU0qcCtLKlgrdyp6LVUqTixRPXcqcCtLKk4rVSpYLU0qeixydD1VKnArSyp6K00qTi13KlgsbnQ9SypwLU0qWC13Kk4tVSp6O3JldHVybiBuLnJvdGF0ZVooQixXLFYpLFg9QlswXSxOPUJbMV0sej1CWzJdLHA9QlszXSxCWzRdPVkqcCtudCpYK1Eqei1ydCpOLEJbNV09USpwK250Kk4rcnQqWC1ZKnosQls2XT1ydCpwK250KnorWSpOLVEqWCxCWzddPW50KnAtWSpYLVEqTi1ydCp6LEJ9ZnVuY3Rpb24gUyhCLFcsVil7dmFyIFg9VlswXSxOPVZbMV0sej1WWzJdLHA9VlszXSxNPVdbMF0sdz1XWzFdLFU9V1syXSxLPVdbM107cmV0dXJuIEJbMF09TSpwK0sqWCt3KnotVSpOLEJbMV09dypwK0sqTitVKlgtTSp6LEJbMl09VSpwK0sqeitNKk4tdypYLEJbM109SypwLU0qWC13Kk4tVSp6LE09V1s0XSx3PVdbNV0sVT1XWzZdLEs9V1s3XSxCWzRdPU0qcCtLKlgrdyp6LVUqTixCWzVdPXcqcCtLKk4rVSpYLU0qeixCWzZdPVUqcCtLKnorTSpOLXcqWCxCWzddPUsqcC1NKlgtdypOLVUqeixCfWZ1bmN0aW9uIEkoQixXLFYpe3ZhciBYPVdbMF0sTj1XWzFdLHo9V1syXSxwPVdbM10sTT1WWzBdLHc9VlsxXSxVPVZbMl0sSz1WWzNdO3JldHVybiBCWzBdPVgqSytwKk0rTipVLXoqdyxCWzFdPU4qSytwKncreipNLVgqVSxCWzJdPXoqSytwKlUrWCp3LU4qTSxCWzNdPXAqSy1YKk0tTip3LXoqVSxNPVZbNF0sdz1WWzVdLFU9Vls2XSxLPVZbN10sQls0XT1YKksrcCpNK04qVS16KncsQls1XT1OKksrcCp3K3oqTS1YKlUsQls2XT16KksrcCpVK1gqdy1OKk0sQls3XT1wKkstWCpNLU4qdy16KlUsQn1mdW5jdGlvbiBEKEIsVyxWLFgpe2lmKE1hdGguYWJzKFgpPHIuRVBTSUxPTilyZXR1cm4gVChCLFcpO3ZhciBOPU1hdGguaHlwb3QoVlswXSxWWzFdLFZbMl0pO1g9WCouNTt2YXIgej1NYXRoLnNpbihYKSxwPXoqVlswXS9OLE09eipWWzFdL04sdz16KlZbMl0vTixVPU1hdGguY29zKFgpLEs9V1swXSxZPVdbMV0sUT1XWzJdLHJ0PVdbM107QlswXT1LKlUrcnQqcCtZKnctUSpNLEJbMV09WSpVK3J0Kk0rUSpwLUsqdyxCWzJdPVEqVStydCp3K0sqTS1ZKnAsQlszXT1ydCpVLUsqcC1ZKk0tUSp3O3ZhciBudD1XWzRdLGF0PVdbNV0sY3Q9V1s2XSxvdD1XWzddO3JldHVybiBCWzRdPW50KlUrb3QqcCthdCp3LWN0Kk0sQls1XT1hdCpVK290Kk0rY3QqcC1udCp3LEJbNl09Y3QqVStvdCp3K250Kk0tYXQqcCxCWzddPW90KlUtbnQqcC1hdCpNLWN0KncsQn1mdW5jdGlvbiBSKEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdK1ZbMF0sQlsxXT1XWzFdK1ZbMV0sQlsyXT1XWzJdK1ZbMl0sQlszXT1XWzNdK1ZbM10sQls0XT1XWzRdK1ZbNF0sQls1XT1XWzVdK1ZbNV0sQls2XT1XWzZdK1ZbNl0sQls3XT1XWzddK1ZbN10sQn1mdW5jdGlvbiBDKEIsVyxWKXt2YXIgWD1XWzBdLE49V1sxXSx6PVdbMl0scD1XWzNdLE09Vls0XSx3PVZbNV0sVT1WWzZdLEs9Vls3XSxZPVdbNF0sUT1XWzVdLHJ0PVdbNl0sbnQ9V1s3XSxhdD1WWzBdLGN0PVZbMV0sb3Q9VlsyXSxzdD1WWzNdO3JldHVybiBCWzBdPVgqc3QrcCphdCtOKm90LXoqY3QsQlsxXT1OKnN0K3AqY3QreiphdC1YKm90LEJbMl09eipzdCtwKm90K1gqY3QtTiphdCxCWzNdPXAqc3QtWCphdC1OKmN0LXoqb3QsQls0XT1YKksrcCpNK04qVS16KncrWSpzdCtudCphdCtRKm90LXJ0KmN0LEJbNV09TipLK3Aqdyt6Kk0tWCpVK1Eqc3QrbnQqY3QrcnQqYXQtWSpvdCxCWzZdPXoqSytwKlUrWCp3LU4qTStydCpzdCtudCpvdCtZKmN0LVEqYXQsQls3XT1wKkstWCpNLU4qdy16KlUrbnQqc3QtWSphdC1RKmN0LXJ0Km90LEJ9dmFyIGo9QztmdW5jdGlvbiAkKEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdKlYsQlsxXT1XWzFdKlYsQlsyXT1XWzJdKlYsQlszXT1XWzNdKlYsQls0XT1XWzRdKlYsQls1XT1XWzVdKlYsQls2XT1XWzZdKlYsQls3XT1XWzddKlYsQn12YXIgSD1uLmRvdDtmdW5jdGlvbiBKKEIsVyxWLFgpe3ZhciBOPTEtWDtyZXR1cm4gSChXLFYpPDAmJihYPS1YKSxCWzBdPVdbMF0qTitWWzBdKlgsQlsxXT1XWzFdKk4rVlsxXSpYLEJbMl09V1syXSpOK1ZbMl0qWCxCWzNdPVdbM10qTitWWzNdKlgsQls0XT1XWzRdKk4rVls0XSpYLEJbNV09V1s1XSpOK1ZbNV0qWCxCWzZdPVdbNl0qTitWWzZdKlgsQls3XT1XWzddKk4rVls3XSpYLEJ9ZnVuY3Rpb24gcShCLFcpe3ZhciBWPXR0KFcpO3JldHVybiBCWzBdPS1XWzBdL1YsQlsxXT0tV1sxXS9WLEJbMl09LVdbMl0vVixCWzNdPVdbM10vVixCWzRdPS1XWzRdL1YsQls1XT0tV1s1XS9WLEJbNl09LVdbNl0vVixCWzddPVdbN10vVixCfWZ1bmN0aW9uIEYoQixXKXtyZXR1cm4gQlswXT0tV1swXSxCWzFdPS1XWzFdLEJbMl09LVdbMl0sQlszXT1XWzNdLEJbNF09LVdbNF0sQls1XT0tV1s1XSxCWzZdPS1XWzZdLEJbN109V1s3XSxCfXZhciBHPW4ubGVuZ3RoLFo9Ryx0dD1uLnNxdWFyZWRMZW5ndGgsZXQ9dHQ7ZnVuY3Rpb24gaXQoQixXKXt2YXIgVj10dChXKTtpZihWPjApe1Y9TWF0aC5zcXJ0KFYpO3ZhciBYPVdbMF0vVixOPVdbMV0vVix6PVdbMl0vVixwPVdbM10vVixNPVdbNF0sdz1XWzVdLFU9V1s2XSxLPVdbN10sWT1YKk0rTip3K3oqVStwKks7QlswXT1YLEJbMV09TixCWzJdPXosQlszXT1wLEJbNF09KE0tWCpZKS9WLEJbNV09KHctTipZKS9WLEJbNl09KFUteipZKS9WLEJbN109KEstcCpZKS9WfXJldHVybiBCfWZ1bmN0aW9uIGsoQil7cmV0dXJuInF1YXQyKCIrQlswXSsiLCAiK0JbMV0rIiwgIitCWzJdKyIsICIrQlszXSsiLCAiK0JbNF0rIiwgIitCWzVdKyIsICIrQls2XSsiLCAiK0JbN10rIikifWZ1bmN0aW9uIGh0KEIsVyl7cmV0dXJuIEJbMF09PT1XWzBdJiZCWzFdPT09V1sxXSYmQlsyXT09PVdbMl0mJkJbM109PT1XWzNdJiZCWzRdPT09V1s0XSYmQls1XT09PVdbNV0mJkJbNl09PT1XWzZdJiZCWzddPT09V1s3XX1mdW5jdGlvbiBmdChCLFcpe3ZhciBWPUJbMF0sWD1CWzFdLE49QlsyXSx6PUJbM10scD1CWzRdLE09Qls1XSx3PUJbNl0sVT1CWzddLEs9V1swXSxZPVdbMV0sUT1XWzJdLHJ0PVdbM10sbnQ9V1s0XSxhdD1XWzVdLGN0PVdbNl0sb3Q9V1s3XTtyZXR1cm4gTWF0aC5hYnMoVi1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoViksTWF0aC5hYnMoSykpJiZNYXRoLmFicyhYLVkpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhYKSxNYXRoLmFicyhZKSkmJk1hdGguYWJzKE4tUSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKFEpKSYmTWF0aC5hYnMoei1ydCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKHJ0KSkmJk1hdGguYWJzKHAtbnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhwKSxNYXRoLmFicyhudCkpJiZNYXRoLmFicyhNLWF0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTSksTWF0aC5hYnMoYXQpKSYmTWF0aC5hYnMody1jdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHcpLE1hdGguYWJzKGN0KSkmJk1hdGguYWJzKFUtb3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhVKSxNYXRoLmFicyhvdCkpfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwidHJhbnNmb3JtTWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQzIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gaXR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKE5bMF09MCxOWzFdPTApLE59ZnVuY3Rpb24gcyhOKXt2YXIgej1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiB6WzBdPU5bMF0selsxXT1OWzFdLHp9ZnVuY3Rpb24gbChOLHope3ZhciBwPW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIHBbMF09TixwWzFdPXoscH1mdW5jdGlvbiBjKE4seil7cmV0dXJuIE5bMF09elswXSxOWzFdPXpbMV0sTn1mdW5jdGlvbiBvKE4seixwKXtyZXR1cm4gTlswXT16LE5bMV09cCxOfWZ1bmN0aW9uIGYoTix6LHApe3JldHVybiBOWzBdPXpbMF0rcFswXSxOWzFdPXpbMV0rcFsxXSxOfWZ1bmN0aW9uIHgoTix6LHApe3JldHVybiBOWzBdPXpbMF0tcFswXSxOWzFdPXpbMV0tcFsxXSxOfWZ1bmN0aW9uIGcoTix6LHApe3JldHVybiBOWzBdPXpbMF0qcFswXSxOWzFdPXpbMV0qcFsxXSxOfWZ1bmN0aW9uIHkoTix6LHApe3JldHVybiBOWzBdPXpbMF0vcFswXSxOWzFdPXpbMV0vcFsxXSxOfWZ1bmN0aW9uIG0oTix6KXtyZXR1cm4gTlswXT1NYXRoLmNlaWwoelswXSksTlsxXT1NYXRoLmNlaWwoelsxXSksTn1mdW5jdGlvbiBUKE4seil7cmV0dXJuIE5bMF09TWF0aC5mbG9vcih6WzBdKSxOWzFdPU1hdGguZmxvb3IoelsxXSksTn1mdW5jdGlvbiBPKE4seixwKXtyZXR1cm4gTlswXT1NYXRoLm1pbih6WzBdLHBbMF0pLE5bMV09TWF0aC5taW4oelsxXSxwWzFdKSxOfWZ1bmN0aW9uIHYoTix6LHApe3JldHVybiBOWzBdPU1hdGgubWF4KHpbMF0scFswXSksTlsxXT1NYXRoLm1heCh6WzFdLHBbMV0pLE59ZnVuY3Rpb24gUChOLHope3JldHVybiBOWzBdPU1hdGgucm91bmQoelswXSksTlsxXT1NYXRoLnJvdW5kKHpbMV0pLE59ZnVuY3Rpb24gaShOLHoscCl7cmV0dXJuIE5bMF09elswXSpwLE5bMV09elsxXSpwLE59ZnVuY3Rpb24gdShOLHoscCxNKXtyZXR1cm4gTlswXT16WzBdK3BbMF0qTSxOWzFdPXpbMV0rcFsxXSpNLE59ZnVuY3Rpb24gYShOLHope3ZhciBwPXpbMF0tTlswXSxNPXpbMV0tTlsxXTtyZXR1cm4gTWF0aC5oeXBvdChwLE0pfWZ1bmN0aW9uIGgoTix6KXt2YXIgcD16WzBdLU5bMF0sTT16WzFdLU5bMV07cmV0dXJuIHAqcCtNKk19ZnVuY3Rpb24gYihOKXt2YXIgej1OWzBdLHA9TlsxXTtyZXR1cm4gTWF0aC5oeXBvdCh6LHApfWZ1bmN0aW9uIEUoTil7dmFyIHo9TlswXSxwPU5bMV07cmV0dXJuIHoqeitwKnB9ZnVuY3Rpb24gQShOLHope3JldHVybiBOWzBdPS16WzBdLE5bMV09LXpbMV0sTn1mdW5jdGlvbiBMKE4seil7cmV0dXJuIE5bMF09MS96WzBdLE5bMV09MS96WzFdLE59ZnVuY3Rpb24gUyhOLHope3ZhciBwPXpbMF0sTT16WzFdLHc9cCpwK00qTTtyZXR1cm4gdz4wJiYodz0xL01hdGguc3FydCh3KSksTlswXT16WzBdKncsTlsxXT16WzFdKncsTn1mdW5jdGlvbiBJKE4seil7cmV0dXJuIE5bMF0qelswXStOWzFdKnpbMV19ZnVuY3Rpb24gRChOLHoscCl7dmFyIE09elswXSpwWzFdLXpbMV0qcFswXTtyZXR1cm4gTlswXT1OWzFdPTAsTlsyXT1NLE59ZnVuY3Rpb24gUihOLHoscCxNKXt2YXIgdz16WzBdLFU9elsxXTtyZXR1cm4gTlswXT13K00qKHBbMF0tdyksTlsxXT1VK00qKHBbMV0tVSksTn1mdW5jdGlvbiBDKE4seil7ej16fHwxO3ZhciBwPXIuUkFORE9NKCkqMipNYXRoLlBJO3JldHVybiBOWzBdPU1hdGguY29zKHApKnosTlsxXT1NYXRoLnNpbihwKSp6LE59ZnVuY3Rpb24gaihOLHoscCl7dmFyIE09elswXSx3PXpbMV07cmV0dXJuIE5bMF09cFswXSpNK3BbMl0qdyxOWzFdPXBbMV0qTStwWzNdKncsTn1mdW5jdGlvbiAkKE4seixwKXt2YXIgTT16WzBdLHc9elsxXTtyZXR1cm4gTlswXT1wWzBdKk0rcFsyXSp3K3BbNF0sTlsxXT1wWzFdKk0rcFszXSp3K3BbNV0sTn1mdW5jdGlvbiBIKE4seixwKXt2YXIgTT16WzBdLHc9elsxXTtyZXR1cm4gTlswXT1wWzBdKk0rcFszXSp3K3BbNl0sTlsxXT1wWzFdKk0rcFs0XSp3K3BbN10sTn1mdW5jdGlvbiBKKE4seixwKXt2YXIgTT16WzBdLHc9elsxXTtyZXR1cm4gTlswXT1wWzBdKk0rcFs0XSp3K3BbMTJdLE5bMV09cFsxXSpNK3BbNV0qdytwWzEzXSxOfWZ1bmN0aW9uIHEoTix6LHAsTSl7dmFyIHc9elswXS1wWzBdLFU9elsxXS1wWzFdLEs9TWF0aC5zaW4oTSksWT1NYXRoLmNvcyhNKTtyZXR1cm4gTlswXT13KlktVSpLK3BbMF0sTlsxXT13KksrVSpZK3BbMV0sTn1mdW5jdGlvbiBGKE4seil7dmFyIHA9TlswXSxNPU5bMV0sdz16WzBdLFU9elsxXSxLPU1hdGguc3FydChwKnArTSpNKSpNYXRoLnNxcnQodyp3K1UqVSksWT1LJiYocCp3K00qVSkvSztyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KFksLTEpLDEpKX1mdW5jdGlvbiBHKE4pe3JldHVybiBOWzBdPTAsTlsxXT0wLE59ZnVuY3Rpb24gWihOKXtyZXR1cm4idmVjMigiK05bMF0rIiwgIitOWzFdKyIpIn1mdW5jdGlvbiB0dChOLHope3JldHVybiBOWzBdPT09elswXSYmTlsxXT09PXpbMV19ZnVuY3Rpb24gZXQoTix6KXt2YXIgcD1OWzBdLE09TlsxXSx3PXpbMF0sVT16WzFdO3JldHVybiBNYXRoLmFicyhwLXcpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhwKSxNYXRoLmFicyh3KSkmJk1hdGguYWJzKE0tVSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE0pLE1hdGguYWJzKFUpKX12YXIgaXQ9YixrPXgsaHQ9ZyxmdD15LEI9YSxXPWgsVj1FLFg9ZnVuY3Rpb24oKXt2YXIgTj1uKCk7cmV0dXJuIGZ1bmN0aW9uKHoscCxNLHcsVSxLKXt2YXIgWSxRO2ZvcihwfHwocD0yKSxNfHwoTT0wKSx3P1E9TWF0aC5taW4odypwK00sei5sZW5ndGgpOlE9ei5sZW5ndGgsWT1NO1k8UTtZKz1wKU5bMF09eltZXSxOWzFdPXpbWSsxXSxVKE4sTixLKSx6W1ldPU5bMF0seltZKzFdPU5bMV07cmV0dXJuIHp9fSgpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpO3ZhciByPXQoMTMpO3QuZChlLCJSZW5kZXJlciIsZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0fSk7dmFyIG49dCg0MCk7dC5kKGUsIkZpZ3VyZTJEIixmdW5jdGlvbigpe3JldHVybiBuLmRlZmF1bHR9KTt2YXIgcz10KDU2KTt0LmQoZSwiTWVzaDJEIixmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHR9KTt2YXIgbD10KDI5KTt0LmQoZSwiTWVzaENsb3VkIixmdW5jdGlvbigpe3JldHVybiBsLmRlZmF1bHR9KTt2YXIgYz10KDIzKTt0LmQoZSwicGFyc2VGb250IixmdW5jdGlvbigpe3JldHVybiBjLmRlZmF1bHR9KTt2YXIgbz10KDMxKTt0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gby5kZWZhdWx0fSk7dmFyIGY9dCgyMSk7dC5kKGUsIkVOViIsZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWZhdWx0fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBMfSk7dmFyIHI9dCgxNCksbj10KDEpLHM9dCgyMCksbD10KDI3KSxjPXQoMjUpLG89dCg0MCksZj10KDU2KSx4PXQoMjkpLGc9dCg1OSkseT10KDIxKSxtPXQoNjMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPXthdXRvVXBkYXRlOiExLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMSxidWZmZXJTaXplOjE1MDB9LE89YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKdm9pZCBtYWluKCkgewogIGdsX1BvaW50U2l6ZSA9IDEuMDsKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsgICAgCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOyAgICAgICAgICAgICAgCn0KYCx2PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U2FtcGxlcjsKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3RleFNhbXBsZXIsIHZUZXh0dXJlQ29vcmQueHkpOwp9CmAsUD1TeW1ib2woImdsUmVuZGVyZXIiKSxpPVN5bWJvbCgiY2FudmFzUmVuZGVyZXIiKSx1PVN5bWJvbCgib3B0aW9ucyIpLGE9U3ltYm9sKCJnbG9iYWxUcmFuc2Zvcm0iKSxoPVN5bWJvbCgiYXBwbHlHbG9iYWxUcmFuc2Zvcm0iKSxiPVN5bWJvbCgiY2FudmFzIik7ZnVuY3Rpb24gRShTKXtjb25zdCBJPVMuZ2wsRD1TLmZibztEJiZJLmJpbmRGcmFtZWJ1ZmZlcihJLkZSQU1FQlVGRkVSLEQpLFMuX2RyYXcoKSxEJiZJLmJpbmRGcmFtZWJ1ZmZlcihJLkZSQU1FQlVGRkVSLG51bGwpfWZ1bmN0aW9uIEEoUyxJLEQsUil7Y29uc3QgQz1TLmNyZWF0ZVRleHR1cmUoSS5jYW52YXMpLGo9W1tbMCwwXSxbRCwwXSxbRCxSXSxbMCxSXSxbMCwwXV1dO2ouY2xvc2VkPSEwO2NvbnN0ICQ9bmV3IGYuZGVmYXVsdCh7Y29udG91cnM6an0pOyQuc2V0VGV4dHVyZShDKSxTLnNldE1lc2hEYXRhKFskLm1lc2hEYXRhXSksRShTKSxDLmRlbGV0ZSgpLEkuY2xlYXJSZWN0KDAsMCxELFIpLGRlbGV0ZSBJLl9maWx0ZXJ9Y2xhc3MgTHtjb25zdHJ1Y3RvcihJLEQ9e30pe2xldCBSPUQuY29udGV4dFR5cGU7aWYoUnx8KHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0PT0iZnVuY3Rpb24iP1I9IndlYmdsMiI6dHlwZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dD09ImZ1bmN0aW9uIj9SPSJ3ZWJnbCI6Uj0iMmQiKSwhSS5nZXRDb250ZXh0KXtjb25zdCBDPUk7ST17Z2V0Q29udGV4dCgpe3JldHVybiBDfSx3aWR0aDpELndpZHRoLGhlaWdodDpELmhlaWdodH0sQy5jYW52YXM9SSxSPSIyZCJ9aWYodGhpc1tiXT1JLFIhPT0id2ViZ2wiJiZSIT09IndlYmdsMiImJlIhPT0iMmQiKXRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb250ZXh0IHR5cGUgJHtSfWApO2lmKEQuY29udGV4dFR5cGU9Uix0aGlzW3VdPU9iamVjdC5hc3NpZ24oe30sVCxEKSxSPT09IndlYmdsInx8Uj09PSJ3ZWJnbDIiKXtSPT09IndlYmdsMiImJih0aGlzW3VdLndlYmdsMj0hMCk7Y29uc3QgQz1uZXcgci5kZWZhdWx0KEksdGhpc1t1XSk7Uj09PSJ3ZWJnbDIiJiYhQy5pc1dlYkdMMiYmKEQuY29udGV4dFR5cGU9IndlYmdsIiksT2JqZWN0KG0uY3JlYXRlU2hhZGVycykoQyksT2JqZWN0KG0uYXBwbHlTaGFkZXIpKEMpLE9iamVjdChtLmNyZWF0ZUNsb3VkU2hhZGVycykoQyk7Y29uc3Qgaj1DLmdsO2ouY2xlYXJDb2xvcigwLDAsMCwwKSxqLmJsZW5kRnVuY1NlcGFyYXRlKGouU1JDX0FMUEhBLGouT05FX01JTlVTX1NSQ19BTFBIQSxqLk9ORSxqLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXNbUF09Q31lbHNlIHRoaXNbaV09bmV3IHMuZGVmYXVsdChJLHRoaXNbdV0pO3RoaXNbYV09WzEsMCwwLDAsMSwwLDAsMCwxXSx0aGlzLnVwZGF0ZVJlc29sdXRpb24oKX1nZXQgY2FudmFzKCl7cmV0dXJuIHRoaXNbYl19Z2V0IGNhbnZhc1JlbmRlcmVyKCl7cmV0dXJuIHRoaXNbaV19Z2V0IGdsUmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tQXX1nZXQgaXNXZWJHTDIoKXtyZXR1cm4gdGhpc1tQXSYmdGhpc1tQXS5pc1dlYkdMMn1nZXQgb3B0aW9ucygpe3JldHVybiB0aGlzW3VdfWdldCBnbG9iYWxUcmFuc2Zvcm1NYXRyaXgoKXtjb25zdCBJPXRoaXNbYV07cmV0dXJuW0lbMF0sSVsxXSxJWzNdLElbNF0sSVs2XSxJWzddXX1nZXQgdmlld01hdHJpeCgpe3JldHVybiB0aGlzW2FdfVtoXSgpe2NvbnN0IEk9dGhpc1tQXXx8dGhpc1tpXTtpZih0aGlzW1BdKXtjb25zdHt3aWR0aDpELGhlaWdodDpSfT10aGlzLmNhbnZhcztJLnVuaWZvcm1zLnZpZXdNYXRyaXg9dGhpcy52aWV3TWF0cml4LEkudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeD10aGlzLnByb2plY3Rpb25NYXRyaXgsSS51bmlmb3Jtcy51X3Jlc29sdXRpb249W0QsUl19fXVwZGF0ZVJlc29sdXRpb24oKXtjb25zdHt3aWR0aDpJLGhlaWdodDpEfT10aGlzLmNhbnZhcyxSPVsxLDAsMCwwLDEsMCwtSS8yLC1ELzIsMV0sQz1bMi9JLDAsMCwwLC0yL0QsMCwwLDAsMV0saj1uLm1hdDMubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEMsUik7dGhpcy5wcm9qZWN0aW9uTWF0cml4PWosdGhpc1tQXSYmdGhpc1tQXS5nbC52aWV3cG9ydCgwLDAsSSxEKX1jcmVhdGVUZXh0dXJlKEksRCl7cmV0dXJuKHRoaXNbUF18fHRoaXNbaV0pLmNyZWF0ZVRleHR1cmUoSSxEKX1sb2FkVGV4dHVyZShJLHt1c2VJbWFnZUJpdG1hcDpEPSExfT17fSl7cmV0dXJuKHRoaXNbUF18fHRoaXNbaV0pLmxvYWRUZXh0dXJlKEkse3VzZUltYWdlQml0bWFwOkR9KX1jcmVhdGVUZXh0KEkse2ZvbnQ6RD0iMTZweCBhcmlhbCIsZmlsbENvbG9yOlI9bnVsbCxzdHJva2VDb2xvcjpDPW51bGwsc3Ryb2tlV2lkdGg6aj0xfT17fSl7aWYodGhpc1tQXSl7Y29uc3QgJD15LmRlZmF1bHQuY3JlYXRlVGV4dChJLHtmb250OkQsZmlsbENvbG9yOlIsc3Ryb2tlQ29sb3I6QyxzdHJva2VXaWR0aDpqfSk7cmV0dXJue2ltYWdlOnRoaXMuY3JlYXRlVGV4dHVyZSgkLmltYWdlKSxyZWN0OiQucmVjdH19cmV0dXJue19pbWc6e2ZvbnQ6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpDLHN0cm9rZVdpZHRoOmosdGV4dDpJfX19Y3JlYXRlUHJvZ3JhbSh7dmVydGV4OkksZnJhZ21lbnQ6RCxvcHRpb25zOlJ9PXt9KXtpZih0aGlzW1BdKXtjb25zdCBDPXRoaXNbUF0uY29tcGlsZVN5bmMoRCxJKTtyZXR1cm4gQy5fYXR0cmliT3B0cz1SLEN9dGhyb3cgbmV3IEVycm9yKCJDb250ZXh0IDJEIGNhbm5vdCBjcmVhdGUgd2ViZ2wgcHJvZ3JhbS4iKX1jcmVhdGVQYXNzUHJvZ3JhbSh7dmVydGV4Okk9TyxmcmFnbWVudDpEPXYsb3B0aW9uczpSfT17fSl7cmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbSh7dmVydGV4OkksZnJhZ21lbnQ6RCxvcHRpb25zOlJ9KX11c2VQcm9ncmFtKEksRD17fSl7aWYodGhpc1tQXSl7Y29uc3QgUj1PYmplY3QuYXNzaWduKHt9LEkuX2F0dHJpYk9wdHMsRCk7cmV0dXJuIHRoaXNbUF0udXNlUHJvZ3JhbShJLFIpfXRocm93IG5ldyBFcnJvcigiQ29udGV4dCAyRCBjYW5ub3QgdXNlIHdlYmdsIHByb2dyYW0uIil9ZGVsZXRlVGV4dHVyZShJKXtyZXR1cm4odGhpc1tQXXx8dGhpc1tpXSkuZGVsZXRlVGV4dHVyZShJKX1jbGVhciguLi5JKXtpZih0aGlzW1BdKXtjb25zdCBEPXRoaXNbUF0uZ2w7RC5jbGVhcihELkNPTE9SX0JVRkZFUl9CSVQpfWVsc2UgdGhpc1tpXS5jbGVhciguLi5JKX1kcmF3TWVzaENsb3VkKEkse2NsZWFyOkQ9ITEscHJvZ3JhbTpSPW51bGx9PXt9KXtjb25zdCBDPXRoaXNbUF18fHRoaXNbaV0saj1SfHxJLnByb2dyYW07aWYodGhpc1tQXSl7Y29uc3QgJD1DLmdsO2lmKEQmJiQuY2xlYXIoJC5DT0xPUl9CVUZGRVJfQklUKSxqKUMucHJvZ3JhbSE9PWomJnRoaXMudXNlUHJvZ3JhbShqLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZmlsbENsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9zdHJva2VDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZnJhbWVJbmRleDp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiExfX0pO2Vsc2V7Y29uc3QgSD1JLm1lc2gubWVzaERhdGEsSj0hIUgudW5pZm9ybXMudV90ZXhTYW1wbGVyLHE9ISFILnVuaWZvcm1zLnVfZmlsdGVyRmxhZyxGPSEhSC51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLEc9SS5oYXNDbG91ZENvbG9yLFo9SS5oYXNDbG91ZEZpbHRlcix0dD0hIUgudW5pZm9ybXMudV9jbGlwU2FtcGxlcjtPYmplY3QobS5hcHBseUNsb3VkU2hhZGVyKShDLHtoYXNUZXh0dXJlOkosaGFzRmlsdGVyOnEsaGFzR3JhZGllbnQ6RixoYXNDbG91ZENvbG9yOkcsaGFzQ2xvdWRGaWx0ZXI6WixoYXNDbGlwUGF0aDp0dH0pfXRoaXNbaF0oKSxDLnNldE1lc2hEYXRhKFtJLm1lc2hEYXRhXSksSS5iZWZvcmVSZW5kZXImJkkuYmVmb3JlUmVuZGVyKCQsSSksRShDKSxJLmFmdGVyUmVuZGVyJiZJLmFmdGVyUmVuZGVyKCQsSSl9ZWxzZSBDLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksQy5kcmF3TWVzaENsb3VkKEkse2NsZWFyOkQsaG9vazohMX0pfWRyYXdNZXNoZXMoSSx7Y2xlYXI6RD0hMSxwcm9ncmFtOlI9bnVsbH09e30pe2NvbnN0IEM9dGhpc1tQXXx8dGhpc1tpXTtpZih0aGlzW1BdKXtjb25zdCBqPUMuZmJvLCQ9T2JqZWN0KGwuZGVmYXVsdCkodGhpcyxJLFI9PW51bGwpLEg9Qy5nbDtEJiZILmNsZWFyKEguQ09MT1JfQlVGRkVSX0JJVCk7Y29uc3QgSj0hT2JqZWN0KGcuaXNVbml0VHJhbnNmb3JtKSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCk7dGhpcy5fZHJhd0NhbGxzPTA7Zm9yKGNvbnN0IHEgb2YgJCl7dGhpcy5fZHJhd0NhbGxzKys7Y29uc3QgRj1SfHxxLnByb2dyYW07aWYocSBpbnN0YW5jZW9mIHguZGVmYXVsdCl0aGlzLmRyYXdNZXNoQ2xvdWQocSx7Y2xlYXI6RCxwcm9ncmFtOkZ9KTtlbHNle2NvbnN0e3dpZHRoOkcsaGVpZ2h0Olp9PXRoaXMuY2FudmFzO2lmKHEuYmVmb3JlUmVuZGVyJiZxLmJlZm9yZVJlbmRlcihILHEpLHEucGFzcy5sZW5ndGgmJigoIXRoaXMuZmJvfHx0aGlzLmZiby53aWR0aCE9PUd8fHRoaXMuZmJvLmhlaWdodCE9PVopJiYodGhpcy5mYm89e3dpZHRoOkcsaGVpZ2h0OlosdGFyZ2V0OkMuY3JlYXRlRkJPKCksYnVmZmVyOkMuY3JlYXRlRkJPKCksc3dhcCgpe1t0aGlzLnRhcmdldCx0aGlzLmJ1ZmZlcl09W3RoaXMuYnVmZmVyLHRoaXMudGFyZ2V0XX19KSxDLmJpbmRGQk8odGhpcy5mYm8udGFyZ2V0KSksIUYmJnEuZmlsdGVyQ2FudmFzKXtPYmplY3QobS5hcHBseVNoYWRlcikoQyx7aGFzVGV4dHVyZTohMH0pO2xldCB0dD10aGlzLmZpbHRlckNvbnRleHQ7dHR8fCh0dD15LmRlZmF1bHQuY3JlYXRlQ2FudmFzKEcsWikuZ2V0Q29udGV4dCgiMmQiKSx0aGlzLmZpbHRlckNvbnRleHQ9dHQpO2NvbnN0IGV0PUlbcS5wYWNrSW5kZXhdLGl0PWV0LmZpbHRlcixrPUlbcS5wYWNrSW5kZXgrMV0saHQ9SVtxLnBhY2tJbmRleC0xXTsoIWh0fHwhaHQuZmlsdGVyQ2FudmFzfHxodC5maWx0ZXIhPT1pdCkmJigha3x8IWsuZmlsdGVyQ2FudmFzfHxrLmZpbHRlciE9PWl0KT8oSj8odHQuc2F2ZSgpLE9iamVjdChjLmRyYXdNZXNoMkQpKGV0LHR0LCExKSx0dC5yZXN0b3JlKCksT2JqZWN0KGMuYXBwbHlGaWx0ZXIpKHR0LGl0KSk6T2JqZWN0KGMuZHJhd01lc2gyRCkoZXQsdHQsITApLHRoaXNbaF0oKSxBKEMsdHQsRyxaKSk6KEomJnR0LnNhdmUoKSxPYmplY3QoYy5kcmF3TWVzaDJEKShldCx0dCwhMSksSiYmdHQucmVzdG9yZSgpLCgha3x8IWsuZmlsdGVyQ2FudmFzfHxldC5maWx0ZXIhPT1rLmZpbHRlcikmJihPYmplY3QoYy5hcHBseUZpbHRlcikodHQsaXQpLHRoaXNbaF0oKSxBKEMsdHQsRyxaKSkpfWVsc2V7aWYoRilDLnByb2dyYW0hPT1GJiZ0aGlzLnVzZVByb2dyYW0oRix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pO2Vsc2V7Y29uc3QgdHQ9ISFxLnVuaWZvcm1zLnVfdGV4U2FtcGxlcixldD0hIXEudW5pZm9ybXMudV9maWx0ZXJGbGFnLGl0PSEhcS51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLGs9ISFxLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KG0uYXBwbHlTaGFkZXIpKEMse2hhc1RleHR1cmU6dHQsaGFzRmlsdGVyOmV0LGhhc0dyYWRpZW50Oml0LGhhc0NsaXBQYXRoOmt9KX1xLmZpbHRlckNhbnZhcyYmY29uc29sZS53YXJuKCJVc2VyIHByb2dyYW0gaWdub3JlZCBzb21lIGZpbHRlciBlZmZlY3RzLiIpLHRoaXNbaF0oKSxDLnNldE1lc2hEYXRhKFtxXSksRShDKX1pZihxLnBhc3MubGVuZ3RoKXtjb25zdCB0dD1xLnBhc3MubGVuZ3RoO3EucGFzcy5mb3JFYWNoKChldCxpdCk9PntldC5ibGVuZD1xLmVuYWJsZUJsZW5kLGV0LnNldFRleHR1cmUoQy5mYm8udGV4dHVyZSksaXQ9PT10dC0xP0MuYmluZEZCTyhqKToodGhpcy5mYm8uc3dhcCgpLEMuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSxldC5wcm9ncmFtP0MudXNlUHJvZ3JhbShldC5wcm9ncmFtKToodGhpcy5kZWZhdWx0UGFzc1Byb2dyYW09dGhpcy5kZWZhdWx0UGFzc1Byb2dyYW18fHRoaXMuY3JlYXRlUGFzc1Byb2dyYW0oKSxDLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0UGFzc1Byb2dyYW0pKSxDLnNldE1lc2hEYXRhKFtldC5tZXNoRGF0YV0pLEguY2xlYXIoSC5DT0xPUl9CVUZGRVJfQklUKSxFKEMpfSl9cS5hZnRlclJlbmRlciYmcS5hZnRlclJlbmRlcihILHEpfX19ZWxzZSBDLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksQy5kcmF3TWVzaGVzKEkse2NsZWFyOkR9KX1kcmF3SW1hZ2UoSSwuLi5EKXtjb25zdCBSPUQubGVuZ3RoO2lmKFI8Mil0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiAzIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHtELmxlbmd0aCsxfSBwcmVzZW50LmApO2lmKFIhPT0yJiZSIT09NCYmUiE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ2RyYXdJbWFnZScgb24gJ1JlbmRlcmVyJzogVmFsaWQgYXJpdGllcyBhcmU6IFszLCA1LCA5XSwgYnV0ICR7RC5sZW5ndGgrMX0gYXJndW1lbnRzIHByb3ZpZGVkLmApO2xldCBDPW51bGwsaj1udWxsO1I9PT0yP0M9W0RbMF0sRFsxXSxJLndpZHRoLEkuaGVpZ2h0XTpSPT09ND9DPUQ6Uj09PTgmJihqPUQuc2xpY2UoMCw0KSxDPUQuc2xpY2UoNCkpO2NvbnN0ICQ9dGhpcy5jcmVhdGVUZXh0dXJlKEkpLHt3aWR0aDpILGhlaWdodDpKfT10aGlzLmNhbnZhcyxxPW5ldyBvLmRlZmF1bHQ7cS5yZWN0KENbMF0sQ1sxXSxILEopO2NvbnN0IEY9bmV3IGYuZGVmYXVsdChxLHt3aWR0aDpILGhlaWdodDpKfSk7Ri5zZXRUZXh0dXJlKCQse3JlY3Q6QyxzcmNSZWN0Omp9KSx0aGlzLmRyYXdNZXNoZXMoW0ZdKSx0aGlzLmRlbGV0ZVRleHR1cmUoJCl9c2V0R2xvYmFsVHJhbnNmb3JtKC4uLkkpe3JldHVybiB0aGlzW2FdPVtJWzBdLElbMV0sMCxJWzJdLElbM10sMCxJWzRdLElbNV0sMV0sdGhpc31nbG9iYWxUcmFuc2Zvcm0oLi4uSSl7Y29uc3QgRD10aGlzW2FdO3JldHVybiB0aGlzW2FdPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksRCxJKSx0aGlzfWdsb2JhbFRyYW5zbGF0ZShJLEQpe2xldCBSPW4ubWF0My5jcmVhdGUoKTtyZXR1cm4gUj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxSLFtJLERdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5SKX1nbG9iYWxSb3RhdGUoSSxbRCxSXT1bMCwwXSl7bGV0IEM9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBDPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEMsW0QsUl0pLEM9bi5tYXQzLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxJKSxDPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEMsWy1ELC1SXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQyl9Z2xvYmFsU2NhbGUoSSxEPUksW1IsQ109WzAsMF0pe2xldCBqPW4ubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtSLENdKSxqPW4ubWF0My5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixbSSxEXSksaj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstUiwtQ10pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfWdsb2JhbFNrZXcoSSxEPUksW1IsQ109WzAsMF0pe2xldCBqPW4ubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtSLENdKSxqPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixuLm1hdDMuZnJvbVZhbHVlcygxLE1hdGgudGFuKEQpLE1hdGgudGFuKEkpLDEsMCwwKSksaj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstUiwtQ10pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfXRyYW5zZm9ybVBvaW50KEksRCxSKXtsZXQgQz10aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtSJiYoQz1uLm1hdDMubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEMsUikpO2NvbnN0IGo9SSpDWzBdK0QqQ1syXStDWzRdLCQ9SSpDWzFdK0QqQ1szXStDWzVdO3JldHVybltqLCRdfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSk7dmFyIHI9dCgxNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1yLmRlZmF1bHR9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgcj10KDE2KSxuPXQoMTcpLHM9dCgxOCksbD10KDE5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYyhULE8sdil7cmV0dXJuIE8gaW4gVD9PYmplY3QuZGVmaW5lUHJvcGVydHkoVCxPLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6VFtPXT12LFR9Y29uc3Qgbz17fTtmdW5jdGlvbiBmKFQsTz0zKXtjb25zdCB2PVtdLFA9VC5sZW5ndGg7Zm9yKGxldCBpPTA7aTxQO2krKylpJU88MiYmdi5wdXNoKC41KihUW2ldKzEpKTtyZXR1cm4gdn1mdW5jdGlvbiB4KFQsTyl7Y29uc3Qgdj1PLl9idWZmZXJzO09iamVjdC52YWx1ZXModikuZm9yRWFjaChQPT57VC5kZWxldGVCdWZmZXIoUCl9KSxPLl9idWZmZXJzPXt9fWZ1bmN0aW9uIGcoVCxPLHYpe3JldHVybiBULmFjdGl2ZVRleHR1cmUoVC5URVhUVVJFMCt2KSxBcnJheS5pc0FycmF5KE8uX2ltZyk/VC5iaW5kVGV4dHVyZShULlRFWFRVUkVfQ1VCRV9NQVAsTyk6VC5iaW5kVGV4dHVyZShULlRFWFRVUkVfMkQsTyksT31jb25zdCB5PXtpbnQ6IjFpIixpdmVjMjoiMmkiLGl2ZWMzOiIzaSIsaXZlYzQ6IjRpIixmbG9hdDoiMWYiLHZlYzI6IjJmIix2ZWMzOiIzZiIsdmVjNDoiNGYiLG1hdDI6Ik1hdHJpeDJmdiIsbWF0MzoiTWF0cml4M2Z2IixtYXQ0OiJNYXRyaXg0ZnYiLHNhbXBsZXIxRDoic2FtcGxlcjFEIixzYW1wbGVyMkQ6InNhbXBsZXIyRCIsc2FtcGxlcjNEOiJzYW1wbGVyM0QiLHNhbXBsZXJDdWJlOiJzYW1wbGVyQ3ViZSIsc2FtcGxlcjFEU2hhZG93OiJzYW1wbGVyMURTaGFkb3ciLHNhbXBsZXIyRFNoYWRvdzoic2FtcGxlcjJEU2hhZG93IixzYW1wbGVyMkRSZWN0OiJzYW1wbGVyMkRSZWN0IixzYW1wbGVyMkRSZWN0U2hhZG93OiJzYW1wbGVyMkRSZWN0U2hhZG93In07Y2xhc3MgbXtzdGF0aWMgYWRkTGlicyhPPXt9KXtPYmplY3QuYXNzaWduKG8sTyl9c3RhdGljIEZMT0FUKE8sdil7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShPLEZsb2F0MzJBcnJheSx2KX1zdGF0aWMgVU5TSUdORURfQllURShPLHYpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoTyxVaW50OEFycmF5LHYpfXN0YXRpYyBVTlNJR05FRF9TSE9SVChPLHYpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoTyxVaW50MTZBcnJheSx2KX1zdGF0aWMgQllURShPLHYpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoTyxJbnQ4QXJyYXksdil9c3RhdGljIFNIT1JUKE8sdil7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShPLEludDE2QXJyYXksdil9Y29uc3RydWN0b3IoTyx2PXt9KXt0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSxtLmRlZmF1bHRPcHRpb25zLHYpLHRoaXMuY2FudmFzPU87bGV0IFA7dGhpcy5vcHRpb25zLndlYmdsMiYmKFA9Ty5nZXRDb250ZXh0KCJ3ZWJnbDIiLHRoaXMub3B0aW9ucykpLFA9PW51bGwmJihQPU9iamVjdChyLnNldHVwV2ViR0wpKE8sdGhpcy5vcHRpb25zKSx0aGlzLmFpYV9leHQ9UC5nZXRFeHRlbnNpb24oIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKSksdGhpcy5nbD1QLFAudmlld3BvcnQoMCwwLE8ud2lkdGgsTy5oZWlnaHQpLFAuY2xlYXJDb2xvcigwLDAsMCwwKSxQLmJsZW5kRnVuY1NlcGFyYXRlKFAuU1JDX0FMUEhBLFAuT05FX01JTlVTX1NSQ19BTFBIQSxQLk9ORSxQLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXMucHJvZ3JhbXM9W10sdGhpcy5fZXZlbnRzPXt9fWdldCBwcm9ncmFtKCl7Y29uc3QgTz10aGlzLmdsO3JldHVybiBPLmdldFBhcmFtZXRlcihPLkNVUlJFTlRfUFJPR1JBTSl9X2RlY2xhcmVVbmlmb3JtKE8sdixQPSIxZiIpe2NvbnN0IGk9dGhpcy5nbCx1PWkuZ2V0VW5pZm9ybUxvY2F0aW9uKE8sdik7bGV0IGE7Y29uc3QgaD10aGlzO2lmKC9ec2FtcGxlci8udGVzdChQKSl7Y29uc3QgYj1PLl9zYW1wbGVyTWFwLEU9Ty5fYmluZFRleHR1cmVzO09iamVjdC5kZWZpbmVQcm9wZXJ0eShPLnVuaWZvcm1zLHYse2dldCgpe3JldHVybiBhfSxzZXQoQSl7YT1BO2NvbnN0IEw9Ylt2XSE9bnVsbD9iW3ZdOkUubGVuZ3RoO0VbTF09QSxnKGksQSxMKSxiW3ZdfHwoYlt2XT1MLGkudW5pZm9ybTFpKHUsTCkpLGgub3B0aW9ucy5hdXRvVXBkYXRlJiZoLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfWVsc2V7Y29uc3QgYj1QLmluZGV4T2YoIk1hdHJpeCIpPT09MCxFPSFiJiYvdiQvLnRlc3QoUCksQT1pW2B1bmlmb3JtJHtQfWBdLmJpbmQoaSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE8udW5pZm9ybXMsdix7Z2V0KCl7cmV0dXJuIGF9LHNldChMKXthPUwsdHlwZW9mIEw9PSJudW1iZXIiJiYoTD1bTF0pLGI/QSh1LCExLEwpOkU/QSh1LEwpOkEodSwuLi5MKSxoLm9wdGlvbnMuYXV0b1VwZGF0ZSYmaC51cGRhdGUoKX0sY29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITB9KX19X2RyYXcoKXtjb25zdCBPPXRoaXMucHJvZ3JhbTtPLm1lc2hEYXRhLmZvckVhY2goKHYsUCk9Pntjb25zdHtwb3NpdGlvbnM6aSxjZWxsczp1LGluc3RhbmNlQ291bnQ6YSxjZWxsc0NvdW50OmgsYXR0cmlidXRlczpiLHVuaWZvcm1zOkUsdGV4dHVyZUNvb3JkOkEsZW5hYmxlQmxlbmQ6TH09dixTPXRoaXMuZ2w7bGV0IEk9di5tb2RlIT1udWxsP3YubW9kZTpTLlRSSUFOR0xFUzt0eXBlb2YgST09InN0cmluZyImJihJPVNbSV0pLEw/Uy5lbmFibGUoUy5CTEVORCk6Uy5kaXNhYmxlKFMuQkxFTkQpLFMuYmluZEJ1ZmZlcihTLkFSUkFZX0JVRkZFUixPLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKSxTLmJ1ZmZlckRhdGEoUy5BUlJBWV9CVUZGRVIsaSxTLlNUQVRJQ19EUkFXKSx1JiYoUy5iaW5kQnVmZmVyKFMuRUxFTUVOVF9BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy5jZWxsc0J1ZmZlciksUy5idWZmZXJEYXRhKFMuRUxFTUVOVF9BUlJBWV9CVUZGRVIsdSxTLlNUQVRJQ19EUkFXKSk7Y29uc3QgRD1bXTtiJiZPYmplY3QudmFsdWVzKGIpLmZvckVhY2goKHtuYW1lOkMsZGF0YTpqLGRpdmlzb3I6JH0pPT57aWYoUy5iaW5kQnVmZmVyKFMuQVJSQVlfQlVGRkVSLE8uX2J1ZmZlcnNbQ10pLFMuYnVmZmVyRGF0YShTLkFSUkFZX0JVRkZFUixqLFMuU1RBVElDX0RSQVcpLCQhPW51bGwpe2NvbnN0IEg9Uy5nZXRBdHRyaWJMb2NhdGlvbihPLEMpO0g+PTAmJihTLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEgpLEQucHVzaChIKSxTLnZlcnRleEF0dHJpYkRpdmlzb3I/Uy52ZXJ0ZXhBdHRyaWJEaXZpc29yKEgsJCk6dGhpcy5haWFfZXh0JiZ0aGlzLmFpYV9leHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKEgsJCkpfX0pLEUmJk9iamVjdC5lbnRyaWVzKEUpLmZvckVhY2goKFtDLGpdKT0+e3RoaXMudW5pZm9ybXNbQ109an0pO2xldCBSO2lmKCF1KXtjb25zdCBDPU8uX2RpbWVuc2lvbjtSPWkubGVuZ3RoL0N9aWYoTy5fZW5hYmxlVGV4dHVyZXMmJk8uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpe2NvbnN0IEM9QXx8ZihpLE8uX2RpbWVuc2lvbik7Uy5iaW5kQnVmZmVyKFMuQVJSQVlfQlVGRkVSLE8uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpLFMuYnVmZmVyRGF0YShTLkFSUkFZX0JVRkZFUixtLkZMT0FUKEMpLFMuU1RBVElDX0RSQVcpfWEhPW51bGw/KHU/Uy5kcmF3RWxlbWVudHNJbnN0YW5jZWQ/Uy5kcmF3RWxlbWVudHNJbnN0YW5jZWQoSSxoLFMuVU5TSUdORURfU0hPUlQsMCxhKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShJLGgsUy5VTlNJR05FRF9TSE9SVCwwLGEpOlMuZHJhd0FycmF5c0luc3RhbmNlZD9TLmRyYXdBcnJheXNJbnN0YW5jZWQoSSwwLFIsYSk6dGhpcy5haWFfZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShJLDAsUixhKSxELmZvckVhY2goQz0+e1MudmVydGV4QXR0cmliRGl2aXNvcj9TLnZlcnRleEF0dHJpYkRpdmlzb3IoQyxudWxsKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoQyxudWxsKX0pKTp1P1MuZHJhd0VsZW1lbnRzKEksaCxTLlVOU0lHTkVEX1NIT1JULDApOlMuZHJhd0FycmF5cyhJLDAsUil9KX1nZXQgaXNXZWJHTDIoKXtyZXR1cm4gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ8InUiJiZ0aGlzLmdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH1nZXQgZW5hYmxlVGV4dHVyZXMoKXtyZXR1cm4gdGhpcy5wcm9ncmFtJiZ0aGlzLnByb2dyYW0uX2VuYWJsZVRleHR1cmVzfWdldCB1bmlmb3Jtcygpe2NvbnN0IE89dGhpcy5wcm9ncmFtO2lmKCFPfHwhTy51bmlmb3Jtcyl0aHJvdyBFcnJvcigiTm8gYXZhbGlhYmxlIHByb2dyYW0uIik7cmV0dXJuIE8udW5pZm9ybXN9ZGVsZXRlUHJvZ3JhbShPKXtjb25zdCB2PXRoaXMuZ2w7dGhpcy5wcm9ncmFtPT09TyYmKHRoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKSx2LnVzZVByb2dyYW0obnVsbCkpO2NvbnN0IFA9dGhpcy5wcm9ncmFtcy5pbmRleE9mKE8pO1A+PTAmJnRoaXMucHJvZ3JhbXMuc3BsaWNlKFAsMSkseCh2LE8pLHYuZGVsZXRlUHJvZ3JhbShPKX1zZXRNZXNoRGF0YShPKXtBcnJheS5pc0FycmF5KE8pfHwoTz1bT10pO2NvbnN0IHY9dGhpcy5wcm9ncmFtO3YubWVzaERhdGE9Ty5tYXAoKHttb2RlOlAscG9zaXRpb25zOmksaW5zdGFuY2VDb3VudDp1LGNlbGxzOmEsY2VsbHNDb3VudDpoLGF0dHJpYnV0ZXM6Yix1bmlmb3JtczpFLHRleHR1cmVDb29yZDpBLGVuYWJsZUJsZW5kOkx9KT0+e2NvbnN0IFM9e3Bvc2l0aW9uczptLkZMT0FUKGkpLHVuaWZvcm1zOkUsZW5hYmxlQmxlbmQ6ISFMLHRleHR1cmVDb29yZDptLkZMT0FUKEEpfTtpZihhJiYoUy5jZWxscz1tLlVTSE9SVChhKSxTLmNlbGxzQ291bnQ9aHx8Uy5jZWxscy5sZW5ndGgpLFAhPW51bGwmJihTLm1vZGU9UCksdSE9bnVsbCl7aWYoIXRoaXMuaXNXZWJHTDImJiF0aGlzLmFpYV9leHQpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgdXNlIGluc3RhbmNlQ291bnQgaW4gdGhpcyByZW5kZXJpbmcgY29udGV4dCwgdXNlIHdlYmdsMiBjb250ZXh0IGluc3RlYWQuIik7Uy5pbnN0YW5jZUNvdW50PXV9aWYoYil7Y29uc3QgST17fTtPYmplY3QuZW50cmllcyhiKS5mb3JFYWNoKChbRCxSXSk9PntpZighdi5fYXR0cmlidXRlW0RdKXYuX2F0dHJpYnV0ZVtEXT0iaWdub3JlZCI7ZWxzZSBpZih2Ll9hdHRyaWJ1dGVbRF0hPT0iaWdub3JlZCIpe2NvbnN0e25hbWU6Qyx0eXBlOmp9PXYuX2F0dHJpYnV0ZVtEXTtsZXQgJD1SLmRhdGF8fFI7aWYoQXJyYXkuaXNBcnJheSgkKSYmKCQ9bVtqXSgkKSksSVtEXT17bmFtZTpDLGRhdGE6JH0sUi5kaXZpc29yIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgZGl2aXNvciBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtJW0RdLmRpdmlzb3I9Ui5kaXZpc29yfX19KSxTLmF0dHJpYnV0ZXM9SX1yZXR1cm4gU30pLHRoaXMub3B0aW9ucy5hdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZSgpfWNyZWF0ZVByb2dyYW0oTyx2KXtjb25zdCBQPS9eXHMqdW5pZm9ybVxzK3NhbXBsZXIvbWcudGVzdChPKTtPPT1udWxsJiYoTz1zLmRlZmF1bHQpLHY9PW51bGwmJih2PVA/bC5kZWZhdWx0Om4uZGVmYXVsdCk7Y29uc3QgaT10aGlzLmdsLHU9T2JqZWN0KHIuY3JlYXRlUHJvZ3JhbSkoaSx2LE8pO3Uuc2hhZGVyVGV4dD17dmVydGV4U2hhZGVyOnYsZnJhZ21lbnRTaGFkZXI6T30sdS5fYnVmZmVycz17fSx1Ll9hdHRyaWJ1dGU9e30sdS51bmlmb3Jtcz17fSx1Ll9zYW1wbGVyTWFwPXt9LHUuX2JpbmRUZXh0dXJlcz1bXTtjb25zdCBhPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb259YCwiaW0iKTtsZXQgaD12Lm1hdGNoKGEpO2gmJih1Ll9kaW1lbnNpb249TnVtYmVyKGhbMV0pKTtjb25zdCBiPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkfWAsImltIik7aD12Lm1hdGNoKGIpLGgmJih1Ll90ZXhDb29yZFNpemU9TnVtYmVyKGhbMV0pKTtjb25zdCBFPS9eXHMqKD86YXR0cmlidXRlfGluKSAoXHcrPykoXGQqKSAoXHcrKS9naW07aWYoaD12Lm1hdGNoKEUpLGgpZm9yKGxldCBTPTA7UzxoLmxlbmd0aDtTKyspe2NvbnN0IEk9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2ltLEQ9aFtTXS5tYXRjaChJKTtpZihEJiZEWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uJiZEWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCl7bGV0WyxSLEMsal09RDtSPT09Im1hdCImJihDKio9MiksdS5fYnVmZmVyc1tqXT1pLmNyZWF0ZUJ1ZmZlcigpLHUuX2F0dHJpYnV0ZVtqXT17bmFtZTpqLHR5cGU6UixzaXplOk51bWJlcihDKXx8MX19fWNvbnN0IEE9L15ccyp1bmlmb3JtXHMrKFx3KylccysoXHcrKShcW1xkK1xdKT8vbWc7aD12Lm1hdGNoKEEpfHxbXSxoPWguY29uY2F0KE8ubWF0Y2goQSl8fFtdKSxoLmZvckVhY2goUz0+e2NvbnN0IEk9Uy5tYXRjaCgvXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy8pO2xldFtELFIsQ109SS5zbGljZSgxKTtEPXlbRF0sQz0hIUMsRC5pbmRleE9mKCJNYXRyaXgiKSE9PTAmJkMmJihEKz0idiIpLHRoaXMuX2RlY2xhcmVVbmlmb3JtKHUsUixEKX0pLHUuX2J1ZmZlcnMudmVydGljZXNCdWZmZXI9aS5jcmVhdGVCdWZmZXIoKSx1Ll9idWZmZXJzLmNlbGxzQnVmZmVyPWkuY3JlYXRlQnVmZmVyKCk7Y29uc3QgTD1pLmdldEF0dHJpYkxvY2F0aW9uKHUsdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7cmV0dXJuIHUuX2VuYWJsZVRleHR1cmVzPUw+PTAsdS5fZW5hYmxlVGV4dHVyZXMmJih1Ll9idWZmZXJzLnRleENvb3JkQnVmZmVyPWkuY3JlYXRlQnVmZmVyKCkpLHRoaXMucHJvZ3JhbXMucHVzaCh1KSx1fXVzZVByb2dyYW0oTyx2PXt9KXt0aGlzLnN0YXJ0UmVuZGVyPSExLHRoaXMuX3JlbmRlckZyYW1lSUQmJihjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUlEKSxkZWxldGUgdGhpcy5fcmVuZGVyRnJhbWVJRCk7Y29uc3QgUD10aGlzLmdsO1AudXNlUHJvZ3JhbShPKTtjb25zdCBpPU8uX2RpbWVuc2lvbjtQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcik7Y29uc3QgdT1QLmdldEF0dHJpYkxvY2F0aW9uKE8sdGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uKTtpZihQLnZlcnRleEF0dHJpYlBvaW50ZXIodSxpLFAuRkxPQVQsITEsMCwwKSxQLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHUpLE8uX2VuYWJsZVRleHR1cmVzKXtQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcik7Y29uc3QgYT1QLmdldEF0dHJpYkxvY2F0aW9uKE8sdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7UC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGEsTy5fdGV4Q29vcmRTaXplfHwyLFAuRkxPQVQsITEsMCwwKSxQLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGEpfWlmKE9iamVjdC5lbnRyaWVzKE8uX2F0dHJpYnV0ZSkuZm9yRWFjaCgoW2EsaF0pPT57aWYoaCE9PSJpZ25vcmVkIil7Y29uc3QgYj1oLnNpemUsRT12W2FdfHx7fSxBPSEhRS5ub3JtYWxpemU7bGV0IEw9RS50eXBlfHwiRkxPQVQiO2NvbnN0IFM9RS5rZXl8fGE7TD09PSJVQllURSImJihMPSJVTlNJR05FRF9CWVRFIiksTD09PSJVU0hPUlQiJiYoTD0iVU5TSUdORURfU0hPUlQiKSxoLnR5cGU9TCxTJiZTIT09YSYmKE8uX2F0dHJpYnV0ZVtTXT1oKSxQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsTy5fYnVmZmVyc1thXSk7Y29uc3QgST1QLmdldEF0dHJpYkxvY2F0aW9uKE8sYSk7ST49MCYmKFAudmVydGV4QXR0cmliUG9pbnRlcihJLGIsUFtMXSxBLDAsMCksUC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShJKSl9fSksIU8ubWVzaERhdGEpe2NvbnN0IGE9W1stMSwtMSwwLDFdLnNsaWNlKDAsaSksWzEsLTEsMCwxXS5zbGljZSgwLGkpLFsxLDEsMCwxXS5zbGljZSgwLGkpLFstMSwxLDAsMV0uc2xpY2UoMCxpKV0saD1bWzAsMSwzXSxbMywxLDJdXTt0aGlzLnNldE1lc2hEYXRhKHtwb3NpdGlvbnM6YSxjZWxsczpofSl9cmV0dXJuIE99Y29tcGlsZVN5bmMoTyx2KXtPPU98fHMuZGVmYXVsdDtjb25zdCBQPXt9O2Z1bmN0aW9uIGkoYil7Yj1iLnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEU9W10sQT1iLm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoQSl7Zm9yKGxldCBMPTA7TDxBLmxlbmd0aDtMKyspe2NvbnN0IEk9QVtMXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoSSl7Y29uc3QgRD1JWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBSPUlbMV07aWYoUj09PSJncmFwaCImJihSPSJncmFwaGljcyIpLFBbUl0pRS5wdXNoKGAvKiBpbmNsdWRlZCAke1J9ICovYCk7ZWxzZSBpZihQW1JdPSEwLEQ9PT0ibGliIil7Y29uc3QgQz1pKG9bUl0pO0UucHVzaChDKX1lbHNlIGlmKEQ9PT0ibGluayIpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCBleHRlcm5hbCBsaW5rcyBzeW5jaHJvbm91c2x5LiBVc2UgY29tcGlsZSBpbnN0ZWFkIG9mIGNvbXBpbGVTeW5jLiIpfX1FLmZvckVhY2goTD0+e2I9Yi5yZXBsYWNlKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tLEwpfSl9cmV0dXJuIGJ9Y29uc3QgdT1pKE8pLGE9dj9pKHYpOm51bGw7cmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbSh1LGEpfWFzeW5jIGNvbXBpbGUoTyx2KXtPPU98fHMuZGVmYXVsdDtjb25zdCBQPXt9O2FzeW5jIGZ1bmN0aW9uIGkoYil7Yj1iLnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEU9W10sQT1iLm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoQSl7Zm9yKGxldCBMPTA7TDxBLmxlbmd0aDtMKyspe2NvbnN0IEk9QVtMXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoSSl7Y29uc3QgRD1JWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBSPUlbMV07aWYoUj09PSJncmFwaCImJihSPSJncmFwaGljcyIpLFBbUl0pRS5wdXNoKGAvKiBpbmNsdWRlZCAke1J9ICovYCk7ZWxzZSBpZihQW1JdPSEwLEQ9PT0ibGliIil7Y29uc3QgQz1hd2FpdCBpKG9bUl0pO0UucHVzaChDKX1lbHNlIGlmKEQ9PT0ibGluayIpe2xldCBDPWF3YWl0IG0uZmV0Y2hTaGFkZXIoUik7Qz1hd2FpdCBpKEMpLEUucHVzaChDKX19fUUuZm9yRWFjaChMPT57Yj1iLnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sTCl9KX1yZXR1cm4gYn1jb25zdCB1PWF3YWl0IGkoTyksYT12P2F3YWl0IGkodik6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKHUsYSl9YXN5bmMgbG9hZChPLHY9bnVsbCl7cmV0dXJuIE89YXdhaXQgbS5mZXRjaFNoYWRlcihPKSx2JiYodj1hd2FpdCBtLmZldGNoU2hhZGVyKHYpKSx0aGlzLmNvbXBpbGUoTyx2KX1jcmVhdGVUZXh0dXJlKE89bnVsbCx7d3JhcFM6dj10aGlzLmdsLkNMQU1QX1RPX0VER0Usd3JhcFQ6UD10aGlzLmdsLkNMQU1QX1RPX0VER0UsbWluRmlsdGVyOmk9dGhpcy5nbC5MSU5FQVIsbWFnRmlsdGVyOnU9dGhpcy5nbC5MSU5FQVJ9PXt9KXtjb25zdCBhPXRoaXMuZ2wsaD1BcnJheS5pc0FycmF5KE8pP2EuVEVYVFVSRV9DVUJFX01BUDphLlRFWFRVUkVfMkQ7dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHM9dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHN8fGEuZ2V0UGFyYW1ldGVyKGEuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLGEuYWN0aXZlVGV4dHVyZShhLlRFWFRVUkUwK3RoaXMuX21heF90ZXh0dXJlX2ltYWdlX3VuaXRzLTEpO2NvbnN0IGI9YS5jcmVhdGVUZXh0dXJlKCk7YS5iaW5kVGV4dHVyZShoLGIpLGEucGl4ZWxTdG9yZWkoYS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCEwKTtjb25zdHt3aWR0aDpFLGhlaWdodDpBfT10aGlzLmNhbnZhcztpZihPKWlmKGg9PT1hLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBMPTA7TDw2O0wrKylhLnRleEltYWdlMkQoYS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grTCwwLGEuUkdCQSxhLlJHQkEsYS5VTlNJR05FRF9CWVRFLE9bTF0pO2Vsc2UgYS50ZXhJbWFnZTJEKGgsMCxhLlJHQkEsYS5SR0JBLGEuVU5TSUdORURfQllURSxPKTtlbHNlIGlmKGg9PT1hLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBMPTA7TDw2O0wrKyl0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grTCwwLGEuUkdCQSxFLEEsMCxhLlJHQkEsYS5VTlNJR05FRF9CWVRFLG51bGwpO2Vsc2UgYS50ZXhJbWFnZTJEKGgsMCxhLlJHQkEsRSxBLDAsYS5SR0JBLGEuVU5TSUdORURfQllURSxudWxsKTtyZXR1cm4gYS50ZXhQYXJhbWV0ZXJpKGgsYS5URVhUVVJFX01JTl9GSUxURVIsaSksYS50ZXhQYXJhbWV0ZXJpKGgsYS5URVhUVVJFX01BR19GSUxURVIsdSksYS50ZXhQYXJhbWV0ZXJpKGgsYS5URVhUVVJFX1dSQVBfUyx2KSxhLnRleFBhcmFtZXRlcmkoaCxhLlRFWFRVUkVfV1JBUF9ULFApLGg9PT1hLlRFWFRVUkVfQ1VCRV9NQVAmJihPLndpZHRoPU9bMF0ud2lkdGgsTy5oZWlnaHQ9T1swXS5oZWlnaHQpLGEuYmluZFRleHR1cmUoaCxudWxsKSxiLl9pbWc9T3x8e3dpZHRoOkUsaGVpZ2h0OkF9LGIuZGVsZXRlPSgpPT57dGhpcy5kZWxldGVUZXh0dXJlKGIpfSxifWRlbGV0ZVRleHR1cmUoTyl7Y29uc3Qgdj1PLl9pbWc7dGhpcy5nbC5kZWxldGVUZXh0dXJlKE8pLHR5cGVvZiB2LmNsb3NlPT0iZnVuY3Rpb24iJiZ2LmNsb3NlKCl9YXN5bmMgbG9hZFRleHR1cmUoTyx7dXNlSW1hZ2VCaXRtYXA6dj0hMH09e30pe2NvbnN0IFA9YXdhaXQgbS5sb2FkSW1hZ2UoTyx7dXNlSW1hZ2VCaXRtYXA6dn0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoUCl9Y3JlYXRlRkJPKHtjb2xvcjpPPTEsYmxlbmQ6dj0hMSxkZXB0aDpQPXRoaXMub3B0aW9ucy5kZXB0aCE9PSExLHN0ZW5jaWw6aT0hIXRoaXMub3B0aW9ucy5zdGVuY2lsfT17fSl7Y29uc3QgdT10aGlzLmdsLGE9dS5jcmVhdGVGcmFtZWJ1ZmZlcigpO3UuYmluZEZyYW1lYnVmZmVyKHUuRlJBTUVCVUZGRVIsYSk7Y29uc3QgaD1bXTtmb3IobGV0IEE9MDtBPE87QSsrKXtjb25zdCBMPXRoaXMuY3JlYXRlVGV4dHVyZSgpO3UuZnJhbWVidWZmZXJUZXh0dXJlMkQodS5GUkFNRUJVRkZFUix1LkNPTE9SX0FUVEFDSE1FTlQwK0EsdS5URVhUVVJFXzJELEwsMCksaC5wdXNoKEwpfWEudGV4dHVyZXM9aCxhLnRleHR1cmU9aFswXSxhLmJsZW5kPXY7Y29uc3R7d2lkdGg6YixoZWlnaHQ6RX09dGhpcy5jYW52YXM7cmV0dXJuIFAmJiFpJiYoYS5kZXB0aEJ1ZmZlcj11LmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLHUuYmluZFJlbmRlcmJ1ZmZlcih1LlJFTkRFUkJVRkZFUixhLmRlcHRoQnVmZmVyKSx1LnJlbmRlcmJ1ZmZlclN0b3JhZ2UodS5SRU5ERVJCVUZGRVIsdS5ERVBUSF9DT01QT05FTlQxNixiLEUpLHUuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIodS5GUkFNRUJVRkZFUix1LkRFUFRIX0FUVEFDSE1FTlQsdS5SRU5ERVJCVUZGRVIsYS5kZXB0aEJ1ZmZlcikpLGkmJiFQJiYoYS5zdGVuY2lsQnVmZmVyPXUuY3JlYXRlUmVuZGVyYnVmZmVyKCksdS5iaW5kUmVuZGVyYnVmZmVyKHUuUkVOREVSQlVGRkVSLGEuc3RlbmNpbEJ1ZmZlciksdS5yZW5kZXJidWZmZXJTdG9yYWdlKHUuUkVOREVSQlVGRkVSLHUuU1RFTkNJTF9JTkRFWDgsYixFKSx1LmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHUuRlJBTUVCVUZGRVIsdS5TVEVOQ0lMX0FUVEFDSE1FTlQsdS5SRU5ERVJCVUZGRVIsYS5zdGVuY2lsQnVmZmVyKSksUCYmaSYmKGEuZGVwdGhTdGVuY2lsQnVmZmVyPXUuY3JlYXRlUmVuZGVyYnVmZmVyKCksdS5iaW5kUmVuZGVyYnVmZmVyKHUuUkVOREVSQlVGRkVSLGEuZGVwdGhTdGVuY2lsQnVmZmVyKSx1LnJlbmRlcmJ1ZmZlclN0b3JhZ2UodS5SRU5ERVJCVUZGRVIsdS5ERVBUSF9TVEVOQ0lMLGIsRSksdS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih1LkZSQU1FQlVGRkVSLHUuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULHUuUkVOREVSQlVGRkVSLGEuZGVwdGhTdGVuY2lsQnVmZmVyKSksdS5iaW5kRnJhbWVidWZmZXIodS5GUkFNRUJVRkZFUixudWxsKSxhfWJpbmRGQk8oTz1udWxsKXt0aGlzLmZibz1PfXJlbmRlcih7Y2xlYXJCdWZmZXI6Tz0hMH09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITA7Y29uc3Qgdj10aGlzLmdsO2xldCBQPXRoaXMucHJvZ3JhbTtQfHwoUD10aGlzLmNyZWF0ZVByb2dyYW0oKSx0aGlzLnVzZVByb2dyYW0oUCkpLHRoaXMuZmJvJiZ2LmJpbmRGcmFtZWJ1ZmZlcih2LkZSQU1FQlVGRkVSLHRoaXMuZmJvKTtjb25zdCBpPXRoaXMub3B0aW9ucy5kZXB0aDtpJiZ2LmVuYWJsZSh2LkRFUFRIX1RFU1QpLHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUfChpP3RoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVDowKXwodGhpcy5vcHRpb25zLnN0ZW5jaWw/dGhpcy5nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ6MCkpO2NvbnN0IHU9dGhpcy5fcmVuZGVyRnJhbWVJRDt0aGlzLl9kcmF3KCksdGhpcy5mYm8mJnYuYmluZEZyYW1lYnVmZmVyKHYuRlJBTUVCVUZGRVIsbnVsbCksdGhpcy5fcmVuZGVyRnJhbWVJRD09PXUmJih0aGlzLl9yZW5kZXJGcmFtZUlEPW51bGwpfXVwZGF0ZSgpe3RoaXMuc3RhcnRSZW5kZXImJnRoaXMuX3JlbmRlckZyYW1lSUQ9PW51bGwmJih0aGlzLl9yZW5kZXJGcmFtZUlEPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKSl9fWMobSwiZGVmYXVsdE9wdGlvbnMiLHtwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITAsYXV0b1VwZGF0ZTohMCx2ZXJ0ZXhQb3NpdGlvbjoiYV92ZXJ0ZXhQb3NpdGlvbiIsdmVydGV4VGV4dHVyZUNvb3JkOiJhX3ZlcnRleFRleHR1cmVDb29yZCIsd2ViZ2wyOiExfSksYyhtLCJVQllURSIsbS5VTlNJR05FRF9CWVRFKSxjKG0sIlVTSE9SVCIsbS5VTlNJR05FRF9TSE9SVCksYyhtLCJmZXRjaFNoYWRlciIsci5mZXRjaFNoYWRlciksYyhtLCJsb2FkSW1hZ2UiLHIubG9hZEltYWdlKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwic2V0dXBXZWJHTCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjcmVhdGVQcm9ncmFtIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInBvaW50c1RvQnVmZmVyIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImxvYWRJbWFnZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJmZXRjaFNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGcseSl7Y29uc3QgbT1bIndlYmdsIiwiZXhwZXJpbWVudGFsLXdlYmdsIiwid2Via2l0LTNkIiwibW96LXdlYmdsIl07bGV0IFQ9bnVsbDtmb3IobGV0IE89MDtPPG0ubGVuZ3RoOysrTyl7dHJ5e1Q9Zy5nZXRDb250ZXh0KG1bT10seSl9Y2F0Y2h7fWlmKFQpYnJlYWt9cmV0dXJuIFR9ZnVuY3Rpb24gbihnLHkpe2NvbnN0IG09cihnLHkpO2lmKCFtKXRocm93IG5ldyBFcnJvcigiU29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgV2ViR0wuIik7cmV0dXJuIG19ZnVuY3Rpb24gcyhnLHksbSl7Y29uc3QgVD1nLmNyZWF0ZVNoYWRlcihnLlZFUlRFWF9TSEFERVIpO2lmKGcuc2hhZGVyU291cmNlKFQseSksZy5jb21waWxlU2hhZGVyKFQpLCFnLmdldFNoYWRlclBhcmFtZXRlcihULGcuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBQPWBWZXJ0ZXggc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2cuZ2V0U2hhZGVySW5mb0xvZyhUKX1gO3Rocm93IG5ldyBFcnJvcihQKX1jb25zdCBPPWcuY3JlYXRlU2hhZGVyKGcuRlJBR01FTlRfU0hBREVSKTtpZihnLnNoYWRlclNvdXJjZShPLG0pLGcuY29tcGlsZVNoYWRlcihPKSwhZy5nZXRTaGFkZXJQYXJhbWV0ZXIoTyxnLkNPTVBJTEVfU1RBVFVTKSl7Y29uc3QgUD1gRnJhZ21lbnQgc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2cuZ2V0U2hhZGVySW5mb0xvZyhPKX1gO3Rocm93IG5ldyBFcnJvcihQKX1jb25zdCB2PWcuY3JlYXRlUHJvZ3JhbSgpO2lmKGcuYXR0YWNoU2hhZGVyKHYsVCksZy5hdHRhY2hTaGFkZXIodixPKSxnLmxpbmtQcm9ncmFtKHYpLCFnLmdldFByb2dyYW1QYXJhbWV0ZXIodixnLkxJTktfU1RBVFVTKSl7Y29uc3QgUD1gU2hhZGVyIHByb2dyYW0gZmFpbGVkIHRvIGxpbmsuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zy5nZXRQcm9ncmFtSW5mb0xvZyh2KX1gO3Rocm93IG5ldyBFcnJvcihQKX1yZXR1cm4gZy5kZWxldGVTaGFkZXIoVCksZy5kZWxldGVTaGFkZXIoTyksdn1mdW5jdGlvbiBsKGcseT1GbG9hdDMyQXJyYXksbT1udWxsKXtpZihtJiYhKG0gaW5zdGFuY2VvZiB5KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJXcm9uZyBidWZmZXIgdHlwZS4iKTtpZihnPT1udWxsfHxnIGluc3RhbmNlb2YgeSlyZXR1cm4gZztpZihnWzBdPT1udWxsfHxnWzBdLmxlbmd0aD09bnVsbClyZXR1cm4gbT8obS5zZXQoZywwKSxtKTpuZXcgeShnKTtjb25zdCBUPWdbMF0ubGVuZ3RoLE89Zy5sZW5ndGg7bXx8KG09bmV3IHkoVCpPKSk7bGV0IHY9MDtmb3IobGV0IFA9MDtQPE87UCsrKWZvcihsZXQgaT0wO2k8VDtpKyspbVt2KytdPWdbUF1baV07cmV0dXJuIG19Y29uc3QgYz17fTtmdW5jdGlvbiBvKGcse3VzZUltYWdlQml0bWFwOnk9ITAsYWxpYXM6bT1udWxsfT17fSl7aWYoIWNbZ10pe2lmKHR5cGVvZiBJbWFnZT09ImZ1bmN0aW9uIil7Y29uc3QgVD1uZXcgSW1hZ2U7dHlwZW9mIGc9PSJzdHJpbmciJiYhKHR5cGVvZiBsb2NhdGlvbj09Im9iamVjdCImJi9eZmlsZTovLnRlc3QobG9jYXRpb24uaHJlZikpJiYhL15kYXRhOi8udGVzdChnKSYmKFQuY3Jvc3NPcmlnaW49ImFub255bW91cyIpLGNbZ109bmV3IFByb21pc2UoTz0+e1Qub25sb2FkPWZ1bmN0aW9uKCl7eSYmdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwPT0iZnVuY3Rpb24iP2NyZWF0ZUltYWdlQml0bWFwKFQse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4odj0+e2NbZ109dixtJiYoY1ttXT12KSxPKHYpfSk6KGNbZ109VCxtJiYoY1ttXT1UKSxPKFQpKX0sVC5zcmM9Z30pLG0mJihjW21dPWNbZ10pfWVsc2UgaWYodHlwZW9mIGZldGNoPT0iZnVuY3Rpb24iKXJldHVybiBmZXRjaChnLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkudGhlbihUPT5ULmJsb2IoKSkudGhlbihUPT5jcmVhdGVJbWFnZUJpdG1hcChULHtpbWFnZU9yaWVudGF0aW9uOiJmbGlwWSJ9KS50aGVuKE89PihjW2ddPU8sbSYmKGNbbV09TyksTykpKX1yZXR1cm4gY1tnXX1jb25zdCBmPXt9O2FzeW5jIGZ1bmN0aW9uIHgoZyl7aWYoZltnXSlyZXR1cm4gZltnXTtjb25zdCB5PWF3YWl0IGZldGNoKGcpO2lmKHkuc3RhdHVzPj0yMDAmJnkuc3RhdHVzPDMwMCl7Y29uc3QgbT1hd2FpdCB5LnRleHQoKTtyZXR1cm4gZltnXT1tLG19dGhyb3cgbmV3IEVycm9yKCJTaGFkZXIgbG9hZGVkIGVycm9yLiIpfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gdmVjNChhX3ZlcnRleFBvc2l0aW9uLCAxKTsKfWB9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWAjaWZkZWYgR0xfRVMKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4xKTsKfWB9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjNCBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gYV92ZXJ0ZXhQb3NpdGlvbjsKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7Cn1gfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMSksbj10KDI1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcz1TeW1ib2woInRyYW5zZm9ybSIpO2NsYXNzIGx7Y29uc3RydWN0b3IobyxmKXt0aGlzLmNvbnRleHQ9by5nZXRDb250ZXh0KCIyZCIpLHRoaXMub3B0aW9ucz1mLHRoaXNbc109WzEsMCwwLDEsMCwwXX1jcmVhdGVUZXh0dXJlKG8pe3JldHVybntfaW1nOm99fWFzeW5jIGxvYWRUZXh0dXJlKG8pe2NvbnN0IGY9YXdhaXQgci5kZWZhdWx0LmxvYWRJbWFnZShvLHt1c2VJbWFnZUJpdG1hcDohMX0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoZil9ZGVsZXRlVGV4dHVyZShvKXtyZXR1cm4gb31jbGVhcihvLGYseCxnKXtjb25zdCB5PXRoaXMuY29udGV4dDtvPW98fDAsZj1mfHwwLHg9eHx8eS5jYW52YXMud2lkdGgtbyxnPWd8fHkuY2FudmFzLmhlaWdodC1mLHkuY2xlYXJSZWN0KG8sZix4LGcpfWRyYXdNZXNoQ2xvdWQobyx7Y2xlYXI6Zj0hMX09e30pe2NvbnN0IHg9W107Zm9yKGxldCBnPTA7ZzxvLmFtb3VudDtnKyspe2NvbnN0IHk9by5nZXRUcmFuc2Zvcm0oZyk7bGV0IG09by5nZXRUZXh0dXJlRnJhbWUoZyk7bSYmKG09bS5faW1nKTtjb25zdCBUPW8uZ2V0RmlsdGVyKGcpLHtmaWxsOk8sc3Ryb2tlOnZ9PW8uZ2V0Q2xvdWRSR0JBKGcpO3gucHVzaCh7bWVzaDpvLm1lc2gsX2Nsb3VkT3B0aW9uczpbTyx2LG0seSxUXX0pfW8uYmVmb3JlUmVuZGVyJiZvLmJlZm9yZVJlbmRlcih0aGlzLmNvbnRleHQsbyksdGhpcy5kcmF3TWVzaGVzKHgse2NsZWFyOmYsaG9vazohMX0pLG8uYWZ0ZXJSZW5kZXImJm8uYWZ0ZXJSZW5kZXIodGhpcy5jb250ZXh0LG8pfWRyYXdNZXNoZXMobyx7Y2xlYXI6Zj0hMSxob29rOng9ITB9PXt9KXtjb25zdCBnPXRoaXMuY29udGV4dDtmJiZnLmNsZWFyUmVjdCgwLDAsZy5jYW52YXMud2lkdGgsZy5jYW52YXMuaGVpZ2h0KTtsZXQgeT1udWxsO2NvbnN0e3dpZHRoOm0saGVpZ2h0OlR9PWcuY2FudmFzLE89by5sZW5ndGg7by5mb3JFYWNoKCh2LFApPT57bGV0IGksdSxhLGgsYjt4JiZ2LmJlZm9yZVJlbmRlciYmdi5iZWZvcmVSZW5kZXIoZyx2KSx2Ll9jbG91ZE9wdGlvbnMmJihbaSx1LGEsaCxiXT12Ll9jbG91ZE9wdGlvbnMsdj12Lm1lc2gpO2xldCBFPXYuZmlsdGVyO2lmKGImJihFPUU/YCR7RX0gJHtifWA6YiksRSYmIXRoaXMuZmlsdGVyQnVmZmVyJiZ0aGlzLmZpbHRlckJ1ZmZlciE9PSExKXtjb25zdCBBPXIuZGVmYXVsdC5jcmVhdGVDYW52YXMobSxUKTtBP3RoaXMuZmlsdGVyQnVmZmVyPUEuZ2V0Q29udGV4dCgiMmQiKTp0aGlzLmZpbHRlckJ1ZmZlcj0hMX15JiZ5IT09RSYmKE9iamVjdChuLmFwcGx5RmlsdGVyKSh0aGlzLmZpbHRlckJ1ZmZlcix5KSxnLmRyYXdJbWFnZSh0aGlzLmZpbHRlckJ1ZmZlci5jYW52YXMsMCwwLG0sVCksdGhpcy5maWx0ZXJCdWZmZXIuY2xlYXJSZWN0KDAsMCxtLFQpLHk9bnVsbCksRSYmdGhpcy5maWx0ZXJCdWZmZXI/KHRoaXMuZmlsdGVyQnVmZmVyLnNhdmUoKSx0aGlzLmZpbHRlckJ1ZmZlci50cmFuc2Zvcm0oLi4udGhpc1tzXSksT2JqZWN0KG4uZHJhd01lc2gyRCkodix0aGlzLmZpbHRlckJ1ZmZlciwhMSxpLHUsYSxoKSx0aGlzLmZpbHRlckJ1ZmZlci5yZXN0b3JlKCksUD09PU8tMT8oT2JqZWN0KG4uYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLEUpLGcuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAsbSxUKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLG0sVCkpOnk9RSk6KGcuc2F2ZSgpLGcudHJhbnNmb3JtKC4uLnRoaXNbc10pLE9iamVjdChuLmRyYXdNZXNoMkQpKHYsZywhMSxpLHUsYSxoKSxnLnJlc3RvcmUoKSkseCYmdi5hZnRlclJlbmRlciYmdi5hZnRlclJlbmRlcihnLHYpfSl9c2V0VHJhbnNmb3JtKG8pe3RoaXNbc109b319fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLChmdW5jdGlvbihyKXt2YXIgbj10KDE0KSxzPXQoMjMpLGw9dCgyNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9e307ZnVuY3Rpb24gbyhtLFQpe2NvbnN0e3N0eWxlOk8sdmFyaWFudDp2LHdlaWdodDpQLHN0cmV0Y2g6aSxzaXplOnUscHhMaW5lSGVpZ2h0OmEsZmFtaWx5Omh9PW07cmV0dXJuIGk9PT0ibm9ybWFsIj9gJHtPfSAke3Z9ICR7UH0gJHt1KlR9cHgvJHthKlR9cHggJHtofWA6YCR7T30gJHt2fSAke1B9ICR7aX0gJHt1KlR9cHgvJHthKlR9cHggJHtofWB9ZnVuY3Rpb24gZihtLHtmb250OlQsZmlsbENvbG9yOk8sc3Ryb2tlQ29sb3I6dixzdHJva2VXaWR0aDpQLHJhdGlvOmk9MSx0ZXh0Q2FudmFzOnUsY2FjaGFibGU6YT0hMX0pe2xldCBoO2lmKGEpe2g9W20sVCxTdHJpbmcoTyksU3RyaW5nKHYpLFN0cmluZyhQKV0uam9pbigiIyMjIik7Y29uc3QgJD1jW2hdO2lmKCQpcmV0dXJuICR9dXx8KHU9ZygxLDEpKTtjb25zdCBiPXUuZ2V0Q29udGV4dCgiMmQiKTtiLnNhdmUoKSxiLmZvbnQ9VDtsZXR7d2lkdGg6RX09Yi5tZWFzdXJlVGV4dChtKTtiLnJlc3RvcmUoKTtjb25zdCBBPU9iamVjdChzLmRlZmF1bHQpKFQpLEw9TWF0aC5tYXgoQS5weExpbmVIZWlnaHQsQS5weEhlaWdodCoxLjEzKTsvaXRhbGljfG9ibGlxdWUvLnRlc3QoVCkmJihFKz1MKk1hdGgudGFuKDE1Kk1hdGguUEkvMTgwKSksIU8mJiF2JiYoTz0iIzAwMCIpO2NvbnN0IFM9Yi5jYW52YXMsST1NYXRoLmNlaWwoRSksRD1NYXRoLmNlaWwoTCk7Uy53aWR0aD1NYXRoLnJvdW5kKEkqaSksUy5oZWlnaHQ9TWF0aC5yb3VuZChEKmkpLGIuc2F2ZSgpLGIuZm9udD1vKEEsaSksYi50ZXh0QWxpZ249ImNlbnRlciIsYi50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgUj1TLmhlaWdodCouNStBLnB4SGVpZ2h0Ki4wNSppLEM9Uy53aWR0aCouNTtpZihPKXtpZihBcnJheS5pc0FycmF5KE8pKU89T2JqZWN0KGwuZGVmYXVsdCkoTyk7ZWxzZSBpZihPLnZlY3Rvcil7bGV0ICQ7Y29uc3R7dmVjdG9yOkgsY29sb3JzOkp9PU87SC5sZW5ndGg9PT02PyQ9Yi5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5IKTokPWIuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSCksSi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6Rn0pPT57JC5hZGRDb2xvclN0b3AocSxGKX0pLE89JH1iLmZpbGxTdHlsZT1PLGIuZmlsbFRleHQobSxDLFIpfWlmKHYpe2lmKGIubGluZVdpZHRoPVAqaSxBcnJheS5pc0FycmF5KHYpKXY9T2JqZWN0KGwuZGVmYXVsdCkodik7ZWxzZSBpZih2LnZlY3Rvcil7bGV0ICQ7Y29uc3R7dmVjdG9yOkgsY29sb3JzOkp9PXY7SC5sZW5ndGg9PT02PyQ9Yi5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5IKTokPWIuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSCksSi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6Rn0pPT57JC5hZGRDb2xvclN0b3AocSxGKX0pLHY9JH1iLnN0cm9rZVN0eWxlPXYsYi5zdHJva2VUZXh0KG0sQyxSKX1iLnJlc3RvcmUoKTtjb25zdCBqPXtpbWFnZTp1LHJlY3Q6WzAsMCxJLERdfTtyZXR1cm4gYSYmKGNbaF09aiksan1sZXQgeD0hMTtpZih0eXBlb2YgbmF2aWdhdG9yPT0ib2JqZWN0IiYmdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQ9PSJzdHJpbmciKXtjb25zdCBtPW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvY2hyb21lXC8oXGQrKS8pO20mJih4PU51bWJlcihtWzFdKTw3MCl9ZnVuY3Rpb24gZyhtLFQsTz17fSl7Y29uc3Qgdj1PLm9mZnNjcmVlbnx8IXgmJk8ub2Zmc2NyZWVuIT09ITE7bGV0IFA7cmV0dXJuIHR5cGVvZiByPCJ1IiYmdHlwZW9mIHIuY3JlYXRlQ2FudmFzPT0iZnVuY3Rpb24iP1A9ci5jcmVhdGVDYW52YXMobSxULE8pOnYmJnR5cGVvZiBPZmZzY3JlZW5DYW52YXM9PSJmdW5jdGlvbiI/UD1uZXcgT2Zmc2NyZWVuQ2FudmFzKG0sVCk6KFA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIiksUC53aWR0aD1tLFAuaGVpZ2h0PVQpLFB9Y29uc3QgeT17Y3JlYXRlQ2FudmFzOmcsY3JlYXRlVGV4dDpmLGxvYWRJbWFnZTpuLmRlZmF1bHQubG9hZEltYWdlfTtlLmRlZmF1bHQ9eX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGQsZSl7dmFyIHQ7dD1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXt0PXR8fG5ldyBGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpfWNhdGNoe3R5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiYodD13aW5kb3cpfWQuZXhwb3J0cz10fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBPfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIodixQKXtpZih0eXBlb2Ygdj09InN0cmluZyIpe2NvbnN0IGE9di50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSkkLyk7YT92PXtzaXplOnBhcnNlRmxvYXQoYVsxXSksdW5pdDphWzJdfTp2PXtzaXplOnBhcnNlSW50KHYsMTApLHVuaXQ6InB4In19bGV0e3NpemU6aSx1bml0OnV9PXY7aWYodT09PSJwdCIpaS89Ljc1O2Vsc2UgaWYodT09PSJwYyIpaSo9MTY7ZWxzZSBpZih1PT09ImluIilpKj05NjtlbHNlIGlmKHU9PT0iY20iKWkqPTk2LzIuNTQ7ZWxzZSBpZih1PT09Im1tIilpKj05Ni8yNS40O2Vsc2UgaWYodT09PSJlbSJ8fHU9PT0icmVtInx8dT09PSJleCIpe2lmKCFQJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgYT1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7UD1yKGEsMTYpfWkqPVAsdT09PSJleCImJihpLz0yKX1lbHNlIGlmKHU9PT0icSIpaSo9OTYvMjUuNC80O2Vsc2UgaWYodT09PSJ2dyJ8fHU9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBhPXU9PT0idnciP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2kqPWEvMTAwfX1lbHNlIGlmKCh1PT09InZtYXgifHx1PT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgYT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsaD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3U9PT0idm1heCI/aSo9TWF0aC5tYXgoYSxoKS8xMDA6aSo9TWF0aC5taW4oYSxoKS8xMDB9cmV0dXJuIGl9Y29uc3Qgbj0iYm9sZHxib2xkZXJ8bGlnaHRlcnxbMS05XTAwIixzPSJpdGFsaWN8b2JsaXF1ZSIsbD0ic21hbGwtY2FwcyIsYz0idWx0cmEtY29uZGVuc2VkfGV4dHJhLWNvbmRlbnNlZHxjb25kZW5zZWR8c2VtaS1jb25kZW5zZWR8c2VtaS1leHBhbmRlZHxleHBhbmRlZHxleHRyYS1leHBhbmRlZHx1bHRyYS1leHBhbmRlZCIsbz0icHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWlufCUiLGY9YCcoW14nXSspJ3wiKFteIl0rKSJ8KFtcXHctXXxb5LiALem+pV0pK2AseD1uZXcgUmVnRXhwKGAoJHtufSkgK2AsImkiKSxnPW5ldyBSZWdFeHAoYCgke3N9KSArYCwiaSIpLHk9bmV3IFJlZ0V4cChgKCR7bH0pICtgLCJpIiksbT1uZXcgUmVnRXhwKGAoJHtjfSkgK2AsImkiKSxUPW5ldyBSZWdFeHAoIihbXFxkXFwuXSspKCIrbysiKSg/OlxcLyhbXFxkXFwuXSspKCIrbysiKSk/ICooKD86IitmKyIpKCAqLCAqKD86IitmKyIpKSopIik7ZnVuY3Rpb24gTyh2LFApe2NvbnN0IGk9VC5leGVjKHYpO2lmKCFpKXJldHVybjtjb25zdCB1PXBhcnNlRmxvYXQoaVszXSksYT17d2VpZ2h0OiJub3JtYWwiLHN0eWxlOiJub3JtYWwiLHN0cmV0Y2g6Im5vcm1hbCIsdmFyaWFudDoibm9ybWFsIixzaXplOnBhcnNlRmxvYXQoaVsxXSksdW5pdDppWzJdLGxpbmVIZWlnaHQ6TnVtYmVyLmlzRmluaXRlKHUpP3U6dm9pZCAwLGxpbmVIZWlnaHRVbml0OmlbNF0sZmFtaWx5OmlbNV0ucmVwbGFjZSgvICosICovZywiLCIpfSxoPXYuc3Vic3RyaW5nKDAsaS5pbmRleCksYj14LmV4ZWMoaCksRT1nLmV4ZWMoaCksQT15LmV4ZWMoaCksTD1tLmV4ZWMoaCk7cmV0dXJuIGImJihhLndlaWdodD1iWzFdKSxFJiYoYS5zdHlsZT1FWzFdKSxBJiYoYS52YXJpYW50PUFbMV0pLEwmJihhLnN0cmV0Y2g9TFsxXSksYS5weEhlaWdodD1yKHtzaXplOmEuc2l6ZSx1bml0OmEudW5pdH0sUCksYS5weExpbmVIZWlnaHQ9cih7c2l6ZTphLmxpbmVIZWlnaHR8fGEuc2l6ZSx1bml0OmEubGluZUhlaWdodFVuaXR8fGEudW5pdH0sUCksYX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihuKXtyZXR1cm5gcmdiYSgke24ubWFwKChzLGwpPT5sPDM/TWF0aC5yb3VuZChzKjI1NSk6cykuam9pbigpfSlgfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiYXBwbHlGaWx0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZHJhd01lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMSksbj10KDI0KSxzPXQoMjMpLGw9dCgyNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGMoeCxnKXtjb25zdCB5PXguY2FudmFzO3guc2F2ZSgpLHguZmlsdGVyPWcseC5kcmF3SW1hZ2UoeSwwLDAseS53aWR0aCx5LmhlaWdodCkseC5yZXN0b3JlKCl9ZnVuY3Rpb24gbyh4LGcpe2NvbnN0IHk9L3JnYmFcKChcZCspLChcZCspLChcZCspLChcZCspXCkvO3g9eC5tYXRjaCh5KS5zbGljZSgxLDUpLm1hcChOdW1iZXIpLGc9Zy5tYXRjaCh5KS5zbGljZSgxLDUpLm1hcChOdW1iZXIpO2NvbnN0IG09W10sVD1nWzNdO2ZvcihsZXQgTz0wO088NDtPKyspbVtPXT1PYmplY3QobC5taXgpKHhbT10sZ1tPXSxUKTtyZXR1cm5gcmdiYSgke20uam9pbigpfSlgfWZ1bmN0aW9uIGYoeCxnLHk9ITAsbT1udWxsLFQ9bnVsbCxPPW51bGwsdj1udWxsKXtnLnNhdmUoKTtsZXQgUD0hMSxpPSExO2lmKGcuZ2xvYmFsQWxwaGE9eC5nZXRPcGFjaXR5KCkseC5fdXBkYXRlTWF0cml4JiZ4LnRyYW5zZm9ybVNjYWxlL3guY29udG91cnMuc2NhbGU+MS41JiZ4LmFjY3VyYXRlKHgudHJhbnNmb3JtU2NhbGUpLHgubGluZVdpZHRoKXtsZXQgaD14LmdyYWRpZW50JiZ4LmdyYWRpZW50LnN0cm9rZTtpZihoKXtjb25zdHt2ZWN0b3I6Yixjb2xvcnM6RX09aDtpZihiLmxlbmd0aD09PTYpaD1nLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLmIpO2Vsc2UgaWYoYi5sZW5ndGg9PT00KWg9Zy5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5iKTtlbHNlIGlmKGIubGVuZ3RoPT09MyloPWcuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5iKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtFLmZvckVhY2goKHtvZmZzZXQ6QSxjb2xvcjpMfSk9PntsZXQgUz1PYmplY3Qobi5kZWZhdWx0KShMKTtUJiYoUz1vKFMsVCkpLGguYWRkQ29sb3JTdG9wKEEsUyl9KSxnLnN0cm9rZVN0eWxlPWgsUD0hMH1lbHNlIHguc3Ryb2tlU3R5bGUmJihUP2cuc3Ryb2tlU3R5bGU9byh4LnN0cm9rZVN0eWxlLFQpOmcuc3Ryb2tlU3R5bGU9eC5zdHJva2VTdHlsZSxQPSEwKX1QJiYoZy5saW5lV2lkdGg9eC5saW5lV2lkdGgsZy5saW5lSm9pbj14LmxpbmVKb2luLGcubGluZUNhcD14LmxpbmVDYXAsZy5taXRlckxpbWl0PXgubWl0ZXJMaW1pdCx4LmxpbmVEYXNoJiYoZy5zZXRMaW5lRGFzaCh4LmxpbmVEYXNoKSx4LmxpbmVEYXNoT2Zmc2V0JiYoZy5saW5lRGFzaE9mZnNldD14LmxpbmVEYXNoT2Zmc2V0KSkpO2xldCB1PXguZ3JhZGllbnQmJnguZ3JhZGllbnQuZmlsbDtpZih1KXtjb25zdHt2ZWN0b3I6aCxjb2xvcnM6Yn09dTtpZihoLmxlbmd0aD09PTYpdT1nLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLmgpO2Vsc2UgaWYoaC5sZW5ndGg9PT00KXU9Zy5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5oKTtlbHNlIGlmKGgubGVuZ3RoPT09Myl1PWcuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5oKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtiLmZvckVhY2goKHtvZmZzZXQ6RSxjb2xvcjpBfSk9PntsZXQgTD1PYmplY3Qobi5kZWZhdWx0KShBKTtUJiYoTD1vKEwsVCkpLHUuYWRkQ29sb3JTdG9wKEUsTCl9KSxnLmZpbGxTdHlsZT11LGk9ITB9ZWxzZSB4LmZpbGxTdHlsZSYmKG0/Zy5maWxsU3R5bGU9byh4LmZpbGxTdHlsZSxtKTpnLmZpbGxTdHlsZT14LmZpbGxTdHlsZSxpPSEwKTtpZih2JiZnLnRyYW5zZm9ybSguLi52KSxnLnRyYW5zZm9ybSguLi54LnRyYW5zZm9ybU1hdHJpeCkseC5jbGlwUGF0aCl7Y29uc3QgaD14LmNsaXBQYXRoLGI9bmV3IFBhdGgyRChoKTtnLmNsaXAoYil9Y29uc3QgYT14LmNvbnRvdXJzLmxlbmd0aDtpZih4LmNvbnRvdXJzLmZvckVhY2goKGgsYik9Pntjb25zdCBFPWgubGVuZ3RoLEE9RT4xJiZyLnZlYzIuZXF1YWxzKGhbMF0saFtFLTFdKSxMPWI9PT1hLTEmJngudGV4dHVyZTtpZihoJiZFPjApe2lmKGl8fFB8fEwpe2cuYmVnaW5QYXRoKCksZy5tb3ZlVG8oLi4uaFswXSk7Zm9yKGxldCBTPTE7UzxFO1MrKylTPT09RS0xJiZBP2cuY2xvc2VQYXRoKCk6Zy5saW5lVG8oLi4uaFtTXSl9aWYoaSYmZy5maWxsKHguZmlsbFJ1bGUpLEwpe2cuc2F2ZSgpLGcuY2xpcCgpO2xldHtpbWFnZTpTLG9wdGlvbnM6SX09eC50ZXh0dXJlO2lmKE8mJihTPU8pLEkucmVwZWF0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCBpbWFnZSByZXBlYXQgeWV0LiIpLFMuZm9udCl7SS5zY2FsZSYmY29uc29sZS53YXJuKCJDb250ZXh0IDJEIG5vdCBzdXBwb3J0ZWQgdGV4dCBzY2FsZSB5ZXQuIiksSS5zcmNSZWN0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNyY1JlY3QgeWV0LiIpO2xldHtmb250OkQsZmlsbENvbG9yOlIsc3Ryb2tlQ29sb3I6QyxzdHJva2VXaWR0aDpqLHRleHQ6JH09UzshUiYmIUMmJihSPSIjMDAwIiksQXJyYXkuaXNBcnJheShSKSYmKFI9T2JqZWN0KG4uZGVmYXVsdCkoUikpLEFycmF5LmlzQXJyYXkoQykmJihDPU9iamVjdChuLmRlZmF1bHQpKEMpKSxnLmZvbnQ9RDtjb25zdHt3aWR0aDpIfT1nLm1lYXN1cmVUZXh0KCQpLEo9T2JqZWN0KHMuZGVmYXVsdCkoRCkscT1NYXRoLm1heChKLnB4TGluZUhlaWdodCxKLnB4SGVpZ2h0KjEuMTMpO2cudGV4dEFsaWduPSJjZW50ZXIiLGcudGV4dEJhc2VsaW5lPSJtaWRkbGUiO2NvbnN0IEY9SS5yZWN0LEc9RlswXStxKi41K0oucHhIZWlnaHQqLjA2LFo9RlsxXStIKi41O0ZbMl0hPW51bGwmJmcuc2NhbGUoRlsyXS9ILEZbM10vcSksUiYmKGcuZmlsbFN0eWxlPVIsZy5maWxsVGV4dCgkLFosRykpLEMmJihnLmxpbmVXaWR0aD1qLGcuc3Ryb2tlU3R5bGU9QyxnLnN0cm9rZVRleHQoJCxaLEcpKX1lbHNle2xldCBEPUkucmVjdDtjb25zdCBSPUkuc3JjUmVjdDtJLnNjYWxlJiYoRD1bMCwwLGcuY2FudmFzLndpZHRoLGcuY2FudmFzLmhlaWdodF0pLEkucm90YXRlZCYmRCYmKEQ9Wy1EWzFdLERbMF0sRFszXSxEWzJdXSksUiYmKEQ9RHx8WzAsMCxSWzJdLFJbM11dKSxJLnJvdGF0ZWQmJihnLnRyYW5zbGF0ZSgwLEQ/RFsyXTpTLndpZHRoKSxnLnJvdGF0ZSgtLjUqTWF0aC5QSSkpLFI/Zy5kcmF3SW1hZ2UoUywuLi5SLC4uLkQpOkQ/Zy5kcmF3SW1hZ2UoUywuLi5EKTpnLmRyYXdJbWFnZShTLDAsMCl9Zy5yZXN0b3JlKCl9UCYmZy5zdHJva2UoKX19KSxnLnJlc3RvcmUoKSx5KXtjb25zdCBoPXguZmlsdGVyO2gmJmMoZyxoKX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjbGFtcCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJtaXgiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwidHJhbnNmb3JtUG9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihsLGMsbyl7cmV0dXJuIGM+byYmKFtjLG9dPVtvLGNdKSxsPGM/YzpsPm8/bzpsfWZ1bmN0aW9uIG4obCxjLG8pe3JldHVybiBsKigxLW8pK2Mqb31mdW5jdGlvbiBzKGwsYyl7Y29uc3RbbyxmXT1sO3JldHVybltvKmNbMF0rZipjWzJdK2NbNF0sbypjWzFdK2YqY1szXStjWzVdXX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KTt2YXIgcj10KDI4KSxuPXQoMjkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBzKGYseCxnKXtjb25zdCB5PWYudW5pZm9ybXN8fHt9LG09eC51bmlmb3Jtc3x8e307aWYoeS51X3RleFNhbXBsZXImJm0udV90ZXhTYW1wbGVyJiZ5LnVfdGV4U2FtcGxlciE9PW0udV90ZXhTYW1wbGVyKXJldHVybiExO2NvbnN0IFQ9T2JqZWN0LmtleXMoeSksTz1PYmplY3Qua2V5cyhtKSx2PVQuaW5kZXhPZigidV90ZXhTYW1wbGVyIiksUD1PLmluZGV4T2YoInVfdGV4U2FtcGxlciIpO2lmKHY+PTAmJlQuc3BsaWNlKHYsMSksUD49MCYmTy5zcGxpY2UoUCwxKSxULmxlbmd0aCE9PU8ubGVuZ3RoKXJldHVybiExO2NvbnN0IGk9VC5ldmVyeSh1PT57Y29uc3QgYT15W3VdLGg9bVt1XTtpZihhPT09aClyZXR1cm4hMDtpZihhLmxlbmd0aCYmaC5sZW5ndGgmJmEubGVuZ3RoPT09aC5sZW5ndGgpe2ZvcihsZXQgYj0wO2I8YS5sZW5ndGg7YisrKWlmKGFbYl0hPT1oW2JdKXJldHVybiExO3JldHVybiEwfXJldHVybiExfSk7aWYoaSl7aWYoeS51X3RleFNhbXBsZXImJiFtLnVfdGV4U2FtcGxlcil4LnNldFRleHR1cmUoeS51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pO2Vsc2UgaWYoIXkudV90ZXhTYW1wbGVyJiZtLnVfdGV4U2FtcGxlcilmb3IobGV0IHU9MDt1PGcubGVuZ3RoO3UrKylnW3VdLnNldFRleHR1cmUobS51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pfXJldHVybiBpfWNvbnN0IGw9e307ZnVuY3Rpb24gYyhmLHgpe2lmKGYubGVuZ3RoKXtjb25zdCBnPU9iamVjdChyLmRlZmF1bHQpKGYsbCk7cmV0dXJuIGcuZW5hYmxlQmxlbmQ9eCxmWzBdLmZpbHRlckNhbnZhcyYmKGcuZmlsdGVyQ2FudmFzPSEwKSxnLnBhY2tJbmRleD1mWzBdLnBhY2tJbmRleCxnLnBhY2tMZW5ndGg9Zi5sZW5ndGgsZy5iZWZvcmVSZW5kZXI9ZlswXS5iZWZvcmVSZW5kZXIsZy5wYXNzPWZbMF0ucGFzcyxnLmFmdGVyUmVuZGVyPWZbZi5sZW5ndGgtMV0uYWZ0ZXJSZW5kZXIsZi5sZW5ndGg9MCxnfX1mdW5jdGlvbipvKGYseCxnPSExKXtjb25zdCB5PVtdLG09Zi5vcHRpb25zLmJ1ZmZlclNpemU7bGV0IFQ9MCxPPSExO2ZvcihsZXQgdj0wO3Y8eC5sZW5ndGg7disrKXtjb25zdCBQPXhbdl07aWYoUCBpbnN0YW5jZW9mIG4uZGVmYXVsdCl5Lmxlbmd0aCYmKHlpZWxkIGMoeSxPKSksVD0wLE89ITEseWllbGQgUDtlbHNle2NvbnN0IGk9UC5tZXNoRGF0YTtpZihpLmNsaXBQYXRoJiYhaS51bmlmb3Jtcy51X2NsaXBTYW1wbGVyKXtjb25zdCBhPWYuY3JlYXRlVGV4dHVyZShpLmNsaXBQYXRoKTtpLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI9YX1sZXQgdT0wO2lmKCghZ3x8IVAuY2FuSWdub3JlKCkpJiZpJiZpLnBvc2l0aW9ucy5sZW5ndGgpe1AucGFja0luZGV4PXY7Y29uc3QgYT1QLmZpbHRlckNhbnZhcztpZih1PWkucG9zaXRpb25zLmxlbmd0aCxhfHxUK3U+bSl5Lmxlbmd0aCYmKHlpZWxkIGMoeSxPKSksVD0wLE89ITE7ZWxzZSBpZihUKXtjb25zdCBoPXlbeS5sZW5ndGgtMV07aCYmKGguZmlsdGVyQ2FudmFzfHxoLmFmdGVyUmVuZGVyfHxQLmJlZm9yZVJlbmRlcnx8aC5wYXNzLmxlbmd0aHx8UC5wYXNzLmxlbmd0aHx8aC5wcm9ncmFtIT09UC5wcm9ncmFtfHwhcyhoLFAseSkpJiYoeWllbGQgYyh5LE8pLFQ9MCxPPSExKX15LnB1c2goUCksTz1PfHxQLmVuYWJsZUJsZW5kLFQrPXV9dj09PXgubGVuZ3RoLTEmJnkubGVuZ3RoJiYoeWllbGQgYyh5LE8pKX19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPXtVTlNJR05FRF9CWVRFOlVpbnQ4QXJyYXksVU5TSUdORURfU0hPUlQ6VWludDE2QXJyYXksQllURTpJbnQ4QXJyYXksU0hPUlQ6SW50MTZBcnJheSxGTE9BVDpGbG9hdDMyQXJyYXl9O2Z1bmN0aW9uIG4obCxjKXtsZXQgbz0wLGY9MCx4PTAsZz0wLHk9MCxtPTAsVD0wO2NvbnN0IE89bFswXS5wcm9ncmFtO2ZvcihsZXQgdj0wO3Y8bC5sZW5ndGg7disrKXtjb25zdCBQPWxbdl0ubWVzaERhdGE7aWYoUCl7VCs9UC5wb3NpdGlvbnMubGVuZ3RoO2NvbnN0IGk9UC5wb3NpdGlvbnNbMF0ubGVuZ3RoO28rPVAucG9zaXRpb25zLmxlbmd0aCppLGYrPVAuY2VsbHMubGVuZ3RoKjMsbSs9UC5hdHRyaWJ1dGVzLmFfY29sb3IubGVuZ3RoKjQ7Y29uc3QgdT1QLnRleHR1cmVDb29yZDt1JiYoeCs9dS5sZW5ndGgqdVswXS5sZW5ndGgpO2NvbnN0IGE9UC5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDthJiYoZys9YS5sZW5ndGgqNCk7Y29uc3QgaD1QLmF0dHJpYnV0ZXMuYV9jbGlwVVY7aCYmKHkrPWgubGVuZ3RoKjIpfX1pZigoIWMucG9zaXRpb25zfHxjLnBvc2l0aW9ucy5sZW5ndGg8bykmJihjLnBvc2l0aW9ucz1uZXcgRmxvYXQzMkFycmF5KG8pKSwoIWMuY2VsbHN8fGMuY2VsbHMubGVuZ3RoPGYpJiYoYy5jZWxscz1uZXcgVWludDE2QXJyYXkoZikpLHgmJighYy50ZXh0dXJlQ29vcmR8fGMudGV4dHVyZUNvb3JkLmxlbmd0aDx4KSYmKGMudGV4dHVyZUNvb3JkPW5ldyBGbG9hdDMyQXJyYXkoeCkpLCghYy5hX2NvbG9yfHxjLmFfY29sb3IubGVuZ3RoPG0pJiYoYy5hX2NvbG9yPW5ldyBVaW50OEFycmF5KG0pKSxnJiYoIWMuYV9zb3VyY2VSZWN0fHxjLmFfc291cmNlUmVjdC5sZW5ndGg8ZykmJihjLmFfc291cmNlUmVjdD1uZXcgRmxvYXQzMkFycmF5KGcpKSx5JiYoIWMuYV9jbGlwVVZ8fGMuYV9jbGlwVVYubGVuZ3RoPHkpJiYoYy5hX2NsaXBVVj1uZXcgRmxvYXQzMkFycmF5KHkpKSxPKXtjb25zdCB2PU9iamVjdC5lbnRyaWVzKE8uX2F0dHJpYnV0ZSksUD1PLl9hdHRyaWJPcHRzfHx7fTtmb3IobGV0IGk9MDtpPHYubGVuZ3RoO2krKyl7Y29uc3RbdSxhXT12W2ldO2lmKHUhPT0iYV9jb2xvciImJnUhPT0iYV9zb3VyY2VSZWN0IiYmYSE9PSJpZ25vcmVkIil7Y29uc3QgaD1QW3VdP1BbdV0udHlwZToiRkxPQVQiLGI9cltoXSxFPWEuc2l6ZSpUOyghY1t1XXx8Y1t1XS5sZW5ndGg8RSkmJihjW3VdPW5ldyBiKEUpKX19fXJldHVybiBjfWZ1bmN0aW9uIHMobCxjKXtsZXQgbz1bXSxmPVtdLHg9W10sZz1bXSx5PVtdLG09W10sVD0wLE89MDtjb25zdCB2PWxbMF0/bFswXS51bmlmb3Jtc3x8e306e30sUD1sWzBdP2xbMF0ucHJvZ3JhbTpudWxsO2MmJihuKGwsYyksZj1jLmNlbGxzLG89Yy5wb3NpdGlvbnMseD1jLnRleHR1cmVDb29yZCxnPWMuYV9jb2xvcix5PWMuYV9zb3VyY2VSZWN0LG09Yy5hX2NsaXBVVik7bGV0IGk9ITEsdT0hMTtjb25zdCBhPXt9O2ZvcihsZXQgYj0wO2I8bC5sZW5ndGg7YisrKXtsZXQgRT1sW2JdO2lmKEUpe2lmKEUubWVzaERhdGEmJihFPUUubWVzaERhdGEpLGMpe2NvbnN0IEw9RS5wb3NpdGlvbnM7Zm9yKGxldCBTPTA7UzxMLmxlbmd0aDtTKyspe2NvbnN0IEk9TFtTXSxEPTMqKFQrUyk7Zm9yKGxldCBSPTA7UjxJLmxlbmd0aDtSKyspb1tEK1JdPUlbUl19fWVsc2Ugby5wdXNoKC4uLkUucG9zaXRpb25zKTtjb25zdCBBPUUuY2VsbHM7Zm9yKGxldCBMPTA7TDxBLmxlbmd0aDtMKyspe2NvbnN0IFM9QVtMXTtpZihjKXtjb25zdCBJPTMqKE8rTCk7ZltJXT1TWzBdK1QsZltJKzFdPVNbMV0rVCxmW0krMl09U1syXStUfWVsc2UgZi5wdXNoKFtTWzBdK1QsU1sxXStULFNbMl0rVF0pfWlmKGMpe2NvbnN0IEw9RS5hdHRyaWJ1dGVzLmFfY29sb3I7Zm9yKGxldCBTPTA7UzxMLmxlbmd0aDtTKyspe2NvbnN0IEk9TFtTXSxEPTQqKFQrUyk7Z1tEXT1JWzBdLGdbRCsxXT1JWzFdLGdbRCsyXT1JWzJdLGdbRCszXT1JWzNdfX1lbHNlIGcucHVzaCguLi5FLmF0dHJpYnV0ZXMuYV9jb2xvcik7aWYoRS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdClpZihpPSEwLGMpe2NvbnN0IEw9RS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDtmb3IobGV0IFM9MDtTPEwubGVuZ3RoO1MrKyl7Y29uc3QgST1MW1NdLEQ9NCooVCtTKTt5W0RdPUlbMF0seVtEKzFdPUlbMV0seVtEKzJdPUlbMl0seVtEKzNdPUlbM119fWVsc2UgeS5wdXNoKC4uLkUuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3QpO2lmKEUuYXR0cmlidXRlcy5hX2NsaXBVVilpZih1PSEwLGMpe2NvbnN0IEw9RS5hdHRyaWJ1dGVzLmFfY2xpcFVWO2ZvcihsZXQgUz0wO1M8TC5sZW5ndGg7UysrKXtjb25zdCBJPUxbU10sRD0yKihUK1MpO21bRF09SVswXSxtW0QrMV09SVsxXX19ZWxzZSBtLnB1c2goLi4uRS5hdHRyaWJ1dGVzLmFfY2xpcFVWKTtpZihFLnRleHR1cmVDb29yZClpZihjKXtjb25zdCBMPUUudGV4dHVyZUNvb3JkO2ZvcihsZXQgUz0wO1M8TC5sZW5ndGg7UysrKXtjb25zdCBJPUxbU10sRD0zKihUK1MpO2ZvcihsZXQgUj0wO1I8SS5sZW5ndGg7UisrKXhbRCtSXT1JW1JdfX1lbHNlIHgucHVzaCguLi5FLnRleHR1cmVDb29yZCk7aWYoUCl7Y29uc3QgTD1PYmplY3QuZW50cmllcyhQLl9hdHRyaWJ1dGUpO2ZvcihsZXQgUz0wO1M8TC5sZW5ndGg7UysrKXtjb25zdFtJLERdPUxbU107aWYoSSE9PSJhX2NvbG9yIiYmSSE9PSJhX3NvdXJjZVJlY3QiJiZEIT09Imlnbm9yZWQiKWlmKGFbSV09W10sYyl7YVtJXT1jW0ldO2NvbnN0IFI9RS5hdHRyaWJ1dGVzW0ldLEM9UlswXS5sZW5ndGg7Zm9yKGxldCBqPTA7ajxSLmxlbmd0aDtqKyspe2NvbnN0ICQ9UltqXSxIPUMqKFQraik7Zm9yKGxldCBKPTA7SjwkLmxlbmd0aDtKKyspYVtJXVtIK0pdPSRbSl19fWVsc2UgYVtJXS5wdXNoKC4uLkUuYXR0cmlidXRlc1tJXSl9fVQrPUUucG9zaXRpb25zLmxlbmd0aCxPKz1FLmNlbGxzLmxlbmd0aH19YS5hX2NvbG9yPWcsaSYmeSYmeS5sZW5ndGg+MCYmKGEuYV9zb3VyY2VSZWN0PXkpO2NvbnN0IGg9e3Bvc2l0aW9uczpvLGNlbGxzOmYsYXR0cmlidXRlczphLHVuaWZvcm1zOnYsY2VsbHNDb3VudDpPKjMscHJvZ3JhbTpQfTtyZXR1cm4geCYmeC5sZW5ndGgmJihoLnRleHR1cmVDb29yZD14KSx1JiZtLmxlbmd0aD4wJiYoYS5hX2NsaXBVVj1tKSxofX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKTt2YXIgcj10KDEpLG49dCgzMCkscz10KDI2KSxsPXQoMzEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBjKGEsaCl7dmFyIGI9T2JqZWN0LmtleXMoYSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEU9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhhKTtoJiYoRT1FLmZpbHRlcihmdW5jdGlvbihBKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLEEpLmVudW1lcmFibGV9KSksYi5wdXNoLmFwcGx5KGIsRSl9cmV0dXJuIGJ9ZnVuY3Rpb24gbyhhKXtmb3IodmFyIGg9MTtoPGFyZ3VtZW50cy5sZW5ndGg7aCsrKXt2YXIgYj1hcmd1bWVudHNbaF0hPW51bGw/YXJndW1lbnRzW2hdOnt9O2glMj9jKE9iamVjdChiKSwhMCkuZm9yRWFjaChmdW5jdGlvbihFKXtmKGEsRSxiW0VdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGEsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYikpOmMoT2JqZWN0KGIpKS5mb3JFYWNoKGZ1bmN0aW9uKEUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLEUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiLEUpKX0pfXJldHVybiBhfWZ1bmN0aW9uIGYoYSxoLGIpe3JldHVybiBoIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsaCx7dmFsdWU6YixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbaF09YixhfWNvbnN0IHg9U3ltYm9sKCJtZXNoIiksZz1TeW1ib2woImNvdW50IikseT1TeW1ib2woImJsZW5kIiksbT1TeW1ib2woImZpbHRlciIpLFQ9U3ltYm9sKCJ0ZXh0dXJlcyIpLE89U3ltYm9sKCJ0ZXh0dXJlT3B0aW9ucyIpLHY9U3ltYm9sKCJjbG91ZENvbG9yIiksUD1TeW1ib2woImNsb3VkRmlsdGVyIiksaT1TeW1ib2woImJ1ZmZlciIpO2Z1bmN0aW9uIHUoYSxoPW51bGwpe2NvbnN0IGI9bmV3IEZsb2F0MzJBcnJheSgzKmEpLEU9bmV3IEZsb2F0MzJBcnJheSgzKmEpLEE9bmV3IEZsb2F0MzJBcnJheSg0KmEpLEw9bmV3IEZsb2F0MzJBcnJheSg0KmEpLFM9bmV3IEZsb2F0MzJBcnJheSg0KmEpLEk9bmV3IEZsb2F0MzJBcnJheSg0KmEpLEQ9bmV3IEZsb2F0MzJBcnJheSg0KmEpLFI9bmV3IFVpbnQ4QXJyYXkoYSksQz1uZXcgVWludDhBcnJheSg0KmEpLGo9bmV3IFVpbnQ4QXJyYXkoNCphKTtyZXR1cm4gaCYmKGIuc2V0KGgudHJhbnNmb3JtMCwwKSxFLnNldChoLnRyYW5zZm9ybTEsMCksQS5zZXQoaC5jb2xvcjAsMCksTC5zZXQoaC5jb2xvcjEsMCksUy5zZXQoaC5jb2xvcjIsMCksSS5zZXQoaC5jb2xvcjMsMCksRC5zZXQoaC5jb2xvcjQsMCksUi5zZXQoaC5mcmFtZUluZGV4LDApLEMuc2V0KGguZmlsbENvbG9yLDApLGouc2V0KGguc3Ryb2tlQ29sb3IsMCkpLHtidWZmZXJTaXplOmEsdHJhbnNmb3JtMDpiLHRyYW5zZm9ybTE6RSxjb2xvcjA6QSxjb2xvcjE6TCxjb2xvcjI6Uyxjb2xvcjM6SSxjb2xvcjQ6RCxmcmFtZUluZGV4OlIsZmlsbENvbG9yOkMsc3Ryb2tlQ29sb3I6an19ZS5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKGEsaD0xLHtidWZmZXI6Yj0xZTN9PXt9KXtiPU1hdGgubWF4KGIsaCksdGhpc1tnXT1oLHRoaXNbeF09YSx0aGlzW2ldPXUoYiksdGhpc1tUXT1bXSx0aGlzW21dPVtdLHRoaXNbdl09ITEsdGhpc1tQXT0hMSx0aGlzW3ldPSExLHRoaXMuaW5pdEJ1ZmZlcigpfWluaXRCdWZmZXIoYT0wKXtjb25zdCBoPXRoaXNbZ107Zm9yKGxldCBiPWE7YjxoO2IrKyl0aGlzW2ldLnRyYW5zZm9ybTAuc2V0KFsxLDAsMF0sYiozKSx0aGlzW2ldLnRyYW5zZm9ybTEuc2V0KFswLDEsMF0sYiozKSx0aGlzW2ldLmZyYW1lSW5kZXguc2V0KFstMV0sYiksdGhpc1tpXS5maWxsQ29sb3Iuc2V0KFswLDAsMCwwXSxiKjQpLHRoaXNbaV0uc3Ryb2tlQ29sb3Iuc2V0KFswLDAsMCwwXSxiKjQpLHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0oYixudWxsKX1nZXQgYnVmZmVyU2l6ZSgpe3JldHVybiB0aGlzW2ldLmJ1ZmZlclNpemV9Z2V0IG1lc2goKXtyZXR1cm4gdGhpc1t4XX1zZXQgbWVzaChhKXt0aGlzW3hdPWEsdGhpc1tUXSYmdGhpcy5zZXRUZXh0dXJlRnJhbWVzKHRoaXNbVF0sdGhpc1tPXSl9Z2V0IGhhc0Nsb3VkQ29sb3IoKXtyZXR1cm4gdGhpc1t2XX1nZXQgaGFzQ2xvdWRGaWx0ZXIoKXtyZXR1cm4gdGhpc1tQXX1fZ2V0RmlsdGVyKGEpe3JldHVybiB0aGlzW21dW2FdPXRoaXNbbV1bYV18fFtdLHRoaXNbbV1bYV19Z2V0RmlsdGVyKGEpe3JldHVybiB0aGlzLl9nZXRGaWx0ZXIoYSkuam9pbigiICIpfWdldCBlbmFibGVCbGVuZCgpe3JldHVybiB0aGlzW3hdLmVuYWJsZUJsZW5kfHx0aGlzW3ldfWNhbklnbm9yZSgpe3JldHVybiB0aGlzW3hdLmNhbklnbm9yZSgpfWRlbGV0ZShhKXtpZihhPj10aGlzW2ddfHxhPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Y29uc3R7dHJhbnNmb3JtMDpoLHRyYW5zZm9ybTE6Yixjb2xvcjA6RSxjb2xvcjE6QSxjb2xvcjI6TCxjb2xvcjM6Uyxjb2xvcjQ6SSxmcmFtZUluZGV4OkQsZmlsbENvbG9yOlIsc3Ryb2tlQ29sb3I6Q309dGhpc1tpXTtoLnNldChoLnN1YmFycmF5KDMqKGErMSkpLDMqYSksYi5zZXQoYi5zdWJhcnJheSgzKihhKzEpKSwzKmEpLEUuc2V0KEUuc3ViYXJyYXkoNCooYSsxKSksNCphKSxBLnNldChBLnN1YmFycmF5KDQqKGErMSkpLDQqYSksTC5zZXQoTC5zdWJhcnJheSg0KihhKzEpKSw0KmEpLFMuc2V0KFMuc3ViYXJyYXkoNCooYSsxKSksNCphKSxJLnNldChJLnN1YmFycmF5KDQqKGErMSkpLDQqYSksRC5zZXQoRC5zdWJhcnJheShhKzEpLGEpLFIuc2V0KFIuc3ViYXJyYXkoNCooYSsxKSksNCphKSxDLnNldChDLnN1YmFycmF5KDQqKGErMSkpLDQqYSk7Zm9yKGNvbnN0IGogaW4gdGhpc1ttXSlqPT09YT9kZWxldGUgdGhpc1ttXVtqXTpqPmEmJih0aGlzW21dW2otMV09dGhpc1ttXVtqXSxkZWxldGUgdGhpc1ttXVtqXSk7dGhpc1tnXS0tfXNldENvbG9yVHJhbnNmb3JtKGEsaCl7aWYoYT49dGhpc1tnXXx8YTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2EqPTQ7Y29uc3R7Y29sb3IwOmIsY29sb3IxOkUsY29sb3IyOkEsY29sb3IzOkwsY29sb3I0OlN9PXRoaXNbaV07cmV0dXJuIGghPW51bGw/KGIuc2V0KFtoWzBdLGhbNV0saFsxMF0saFsxNV1dLGEpLEUuc2V0KFtoWzFdLGhbNl0saFsxMV0saFsxNl1dLGEpLEEuc2V0KFtoWzJdLGhbN10saFsxMl0saFsxN11dLGEpLEwuc2V0KFtoWzNdLGhbOF0saFsxM10saFsxOF1dLGEpLFMuc2V0KFtoWzRdLGhbOV0saFsxNF0saFsxOV1dLGEpLHRoaXNbeV09dGhpc1t5XXx8aFsxOF08MSx0aGlzW1BdPSEwKTooYi5zZXQoWzEsMCwwLDBdLGEpLEUuc2V0KFswLDEsMCwwXSxhKSxBLnNldChbMCwwLDEsMF0sYSksTC5zZXQoWzAsMCwwLDFdLGEpLFMuc2V0KFswLDAsMCwwXSxhKSksdGhpc31nZXRDb2xvclRyYW5zZm9ybShhKXtpZihhPj10aGlzW2ddfHxhPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7YSo9NDtjb25zdHtjb2xvcjA6aCxjb2xvcjE6Yixjb2xvcjI6RSxjb2xvcjM6QSxjb2xvcjQ6TH09dGhpc1tpXTtyZXR1cm5baFthXSxiW2FdLEVbYV0sQVthXSxMW2FdLGhbYSsxXSxiW2ErMV0sRVthKzFdLEFbYSsxXSxMW2ErMV0saFthKzJdLGJbYSsyXSxFW2ErMl0sQVthKzJdLExbYSsyXSxoW2ErM10sYlthKzNdLEVbYSszXSxBW2ErM10sTFthKzNdXX10cmFuc2Zvcm1Db2xvcihhLGgpe2xldCBiPXRoaXMuZ2V0Q29sb3JUcmFuc2Zvcm0oYSk7cmV0dXJuIGI9T2JqZWN0KG4ubXVsdGlwbHkpKGIsaCksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShhLGIpLHRoaXN9c2V0RmlsbENvbG9yKGEsaCl7aWYoYT49dGhpc1tnXXx8YTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBoPT0ic3RyaW5nIiYmKGg9T2JqZWN0KGwuZGVmYXVsdCkoaCkpLGhbM10+MCYmKHRoaXNbdl09ITApLHRoaXNbaV0uZmlsbENvbG9yLnNldChoLm1hcChiPT5NYXRoLnJvdW5kKDI1NSpiKSksNCphKX1zZXRTdHJva2VDb2xvcihhLGgpe2lmKGE+PXRoaXNbZ118fGE8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTt0eXBlb2YgaD09InN0cmluZyImJihoPU9iamVjdChsLmRlZmF1bHQpKGgpKSxoWzNdPjAmJih0aGlzW3ZdPSEwKSx0aGlzW2ldLnN0cm9rZUNvbG9yLnNldChoLm1hcChiPT5NYXRoLnJvdW5kKDI1NSpiKSksNCphKX1nZXRDbG91ZFJHQkEoYSl7aWYoYT49dGhpc1tnXXx8YTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2EqPTQ7Y29uc3R7ZmlsbENvbG9yOmgsc3Ryb2tlQ29sb3I6Yn09dGhpc1tpXSxFPVtoW2FdLGhbYSsxXSxoW2ErMl0saFthKzNdXSxBPVtiW2FdLGJbYSsxXSxiW2ErMl0sYlthKzNdXTtyZXR1cm4gRVszXS89MjU1LEFbM10vPTI1NSx7ZmlsbDpgcmdiYSgke0Uuam9pbigpfSlgLHN0cm9rZTpgcmdiYSgke0Euam9pbigpfSlgfX1ncmF5c2NhbGUoYSxoKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGEsT2JqZWN0KG4uZ3JheXNjYWxlKShoKSksdGhpcy5fZ2V0RmlsdGVyKGEpLnB1c2goYGdyYXlzY2FsZSgkezEwMCpofSUpYCl9YnJpZ2h0bmVzcyhhLGgpe3RoaXMudHJhbnNmb3JtQ29sb3IoYSxPYmplY3Qobi5icmlnaHRuZXNzKShoKSksdGhpcy5fZ2V0RmlsdGVyKGEpLnB1c2goYGJyaWdodG5lc3MoJHsxMDAqaH0lKWApfXNhdHVyYXRlKGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLnNhdHVyYXRlKShoKSksdGhpcy5fZ2V0RmlsdGVyKGEpLnB1c2goYHNhdHVyYXRlKCR7MTAwKmh9JSlgKX1jb250cmFzdChhLGgpe3RoaXMudHJhbnNmb3JtQ29sb3IoYSxPYmplY3Qobi5jb250cmFzdCkoaCkpLHRoaXMuX2dldEZpbHRlcihhKS5wdXNoKGBjb250cmFzdCgkezEwMCpofSUpYCl9aW52ZXJ0KGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLmludmVydCkoaCkpLHRoaXMuX2dldEZpbHRlcihhKS5wdXNoKGBpbnZlcnQoJHsxMDAqaH0lKWApfXNlcGlhKGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLnNlcGlhKShoKSksdGhpcy5fZ2V0RmlsdGVyKGEpLnB1c2goYHNlcGlhKCR7MTAwKmh9JSlgKX1vcGFjaXR5KGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLm9wYWNpdHkpKGgpKSx0aGlzLl9nZXRGaWx0ZXIoYSkucHVzaChgb3BhY2l0eSgkezEwMCpofSUpYCl9aHVlUm90YXRlKGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLmh1ZVJvdGF0ZSkoaCkpLHRoaXMuX2dldEZpbHRlcihhKS5wdXNoKGBodWUtcm90YXRlKCR7aH1kZWcpYCl9c2V0VHJhbnNmb3JtKGEsaCl7aWYoYT49dGhpc1tnXXx8YTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2EqPTMsaD09bnVsbCYmKGg9WzEsMCwwLDEsMCwwXSk7Y29uc3R7dHJhbnNmb3JtMDpiLHRyYW5zZm9ybTE6RX09dGhpc1tpXTtyZXR1cm4gYi5zZXQoW2hbMF0saFsyXSxoWzRdXSxhKSxFLnNldChbaFsxXSxoWzNdLGhbNV1dLGEpLHRoaXN9Z2V0VHJhbnNmb3JtKGEpe2lmKGE+PXRoaXNbZ118fGE8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTthKj0zO2NvbnN0e3RyYW5zZm9ybTA6aCx0cmFuc2Zvcm0xOmJ9PXRoaXNbaV07cmV0dXJuW2hbYV0sYlthXSxoW2ErMV0sYlthKzFdLGhbYSsyXSxiW2ErMl1dfWdldFRleHR1cmVGcmFtZShhKXtyZXR1cm4gdGhpc1tUXVt0aGlzW2ldLmZyYW1lSW5kZXhbYV1dfXNldFRleHR1cmVGcmFtZXMoYT1bXSxoPXt9KXtpZihhLmxlbmd0aD4xMil0aHJvdyBuZXcgRXJyb3IoIk1heCBmcmFtZXMgZXhjZWVkLiBBbGxvdyAxMiBmcmFtZXMuIik7YS5sZW5ndGgmJnRoaXNbeF0uc2V0VGV4dHVyZShhWzBdLGgpLHRoaXNbVF09YSx0aGlzW09dPWh9c2V0RnJhbWVJbmRleChhLGgpe2lmKGE+PXRoaXNbZ118fGE8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdCBiPXRoaXNbVF0ubGVuZ3RoO2lmKGI8PTApdGhyb3cgbmV3IEVycm9yKCJObyBmcmFtZXMiKTt0aGlzW2ldLmZyYW1lSW5kZXhbYV09aCVifWdldCBhbW91bnQoKXtyZXR1cm4gdGhpc1tnXX1zZXQgYW1vdW50KGEpe2NvbnN0IGg9dGhpc1tnXTthIT09aCYmKGE+dGhpc1tpXS5idWZmZXJTaXplJiYodGhpc1tpXT11KE1hdGgubWF4KGEsdGhpc1tpXS5idWZmZXJTaXplKzFlMyksdGhpc1tpXSkpLHRoaXNbZ109YSxhPmgmJnRoaXMuaW5pdEJ1ZmZlcihoKSl9Z2V0IG1lc2hEYXRhKCl7Y29uc3R7YXR0cmlidXRlczphLGNlbGxzOmgscG9zaXRpb25zOmIsdGV4dHVyZUNvb3JkOkUsdW5pZm9ybXM6QX09dGhpc1t4XS5tZXNoRGF0YSxMPXRoaXNbVF0sUz17YXR0cmlidXRlczpvKHt9LGEpLGNlbGxzOmgscG9zaXRpb25zOmIsdGV4dHVyZUNvb3JkOkUsdW5pZm9ybXM6byh7fSxBKSxpbnN0YW5jZUNvdW50OnRoaXNbZ10sZW5hYmxlQmxlbmQ6dGhpcy5lbmFibGVCbGVuZH07TC5sZW5ndGgmJkwuZm9yRWFjaCgoRyxaKT0+e1MudW5pZm9ybXNbYHVfdGV4RnJhbWUke1p9YF09R30pO2NvbnN0e3RyYW5zZm9ybTA6SSx0cmFuc2Zvcm0xOkQsY29sb3IwOlIsY29sb3IxOkMsY29sb3IyOmosY29sb3IzOiQsY29sb3I0OkgsZmlsbENvbG9yOkosc3Ryb2tlQ29sb3I6cSxmcmFtZUluZGV4OkZ9PXRoaXNbaV07cmV0dXJuIHRoaXNbeF0udW5pZm9ybXMudV90ZXhTYW1wbGVyJiYoUy5hdHRyaWJ1dGVzLmFfZnJhbWVJbmRleD17ZGF0YTpGLGRpdmlzb3I6MX0pLFMuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTA9e2RhdGE6SSxkaXZpc29yOjF9LFMuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTE9e2RhdGE6RCxkaXZpc29yOjF9LFMuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQwPXtkYXRhOlIsZGl2aXNvcjoxfSxTLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMT17ZGF0YTpDLGRpdmlzb3I6MX0sUy5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDI9e2RhdGE6aixkaXZpc29yOjF9LFMuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQzPXtkYXRhOiQsZGl2aXNvcjoxfSxTLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkND17ZGF0YTpILGRpdmlzb3I6MX0sdGhpcy5oYXNDbG91ZENvbG9yJiYoUy5hdHRyaWJ1dGVzLmFfZmlsbENsb3VkQ29sb3I9e2RhdGE6SixkaXZpc29yOjF9LFMuYXR0cmlidXRlcy5hX3N0cm9rZUNsb3VkQ29sb3I9e2RhdGE6cSxkaXZpc29yOjF9KSxTfXNldFByb2dyYW0oYSl7dGhpc1t4XS5zZXRQcm9ncmFtKGEpfWdldCBwcm9ncmFtKCl7cmV0dXJuIHRoaXNbeF0ucHJvZ3JhbX10cmFuc2Zvcm0oYSxoKXtjb25zdCBiPXRoaXMuZ2V0VHJhbnNmb3JtKGEpO3JldHVybiBoPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLGIsaCksdGhpcy5zZXRUcmFuc2Zvcm0oYSxoKSx0aGlzfXRyYW5zbGF0ZShhLFtoLGJdKXtsZXQgRT1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBFPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxFLFtoLGJdKSx0aGlzLnRyYW5zZm9ybShhLEUpfXJvdGF0ZShhLGgsW2IsRV09WzAsMF0pe2xldCBBPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEE9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEsW2IsRV0pLEE9ci5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEsaCksQT1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQSxbLWIsLUVdKSx0aGlzLnRyYW5zZm9ybShhLEEpfXNjYWxlKGEsW2gsYj1oXSxbRSxBXT1bMCwwXSl7bGV0IEw9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxbRSxBXSksTD1yLm1hdDJkLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFtoLGJdKSxMPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFstRSwtQV0pLHRoaXMudHJhbnNmb3JtKGEsTCl9c2tldyhhLFtoLGI9aF0sW0UsQV09WzAsMF0pe2xldCBMPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEw9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEwsW0UsQV0pLEw9ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxyLm1hdDJkLmZyb21WYWx1ZXMoMSxNYXRoLnRhbihiKSxNYXRoLnRhbihoKSwxLDAsMCkpLEw9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEwsWy1FLC1BXSksdGhpcy50cmFuc2Zvcm0oYSxMKX1pc1BvaW50Q29sbGlzaW9uKGEsW2gsYl0sRT0iYm90aCIpe2NvbnN0IEE9dGhpcy5nZXRUcmFuc2Zvcm0oYSksTD1PYmplY3Qocy50cmFuc2Zvcm1Qb2ludCkoW2gsYl0sci5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEpKTtyZXR1cm4gdGhpc1t4XS5pc1BvaW50Q29sbGlzaW9uKC4uLkwsRSl9aXNQb2ludEluRmlsbChhLFtoLGJdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGEsW2gsYl0sImZpbGwiKX1pc1BvaW50SW5TdHJva2UoYSxbaCxiXSl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihhLFtoLGJdLCJzdHJva2UiKX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJncmF5c2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiYnJpZ2h0bmVzcyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzYXR1cmF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJjb250cmFzdCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwic2VwaWEiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwib3BhY2l0eSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJodWVSb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihtLFQpe2NvbnN0IE89W10sdj1tWzBdLFA9bVsxXSxpPW1bMl0sdT1tWzNdLGE9bVs0XSxoPW1bNV0sYj1tWzZdLEU9bVs3XSxBPW1bOF0sTD1tWzldLFM9bVsxMF0sST1tWzExXSxEPW1bMTJdLFI9bVsxM10sQz1tWzE0XSxqPW1bMTVdLCQ9bVsxNl0sSD1tWzE3XSxKPW1bMThdLHE9bVsxOV07bGV0IEY9VFswXSxHPVRbMV0sWj1UWzJdLHR0PVRbM10sZXQ9VFs0XTtyZXR1cm4gT1swXT1GKnYrRypoK1oqUyt0dCpqLE9bMV09RipQK0cqYitaKkkrdHQqJCxPWzJdPUYqaStHKkUrWipEK3R0KkgsT1szXT1GKnUrRypBK1oqUit0dCpKLE9bNF09RiphK0cqTCtaKkMrdHQqcStldCxGPVRbNV0sRz1UWzZdLFo9VFs3XSx0dD1UWzhdLGV0PVRbOV0sT1s1XT1GKnYrRypoK1oqUyt0dCpqLE9bNl09RipQK0cqYitaKkkrdHQqJCxPWzddPUYqaStHKkUrWipEK3R0KkgsT1s4XT1GKnUrRypBK1oqUit0dCpKLE9bOV09RiphK0cqTCtaKkMrdHQqcStldCxGPVRbMTBdLEc9VFsxMV0sWj1UWzEyXSx0dD1UWzEzXSxldD1UWzE0XSxPWzEwXT1GKnYrRypoK1oqUyt0dCpqLE9bMTFdPUYqUCtHKmIrWipJK3R0KiQsT1sxMl09RippK0cqRStaKkQrdHQqSCxPWzEzXT1GKnUrRypBK1oqUit0dCpKLE9bMTRdPUYqYStHKkwrWipDK3R0KnErZXQsRj1UWzE1XSxHPVRbMTZdLFo9VFsxN10sdHQ9VFsxOF0sZXQ9VFsxOV0sT1sxNV09Rip2K0cqaCtaKlMrdHQqaixPWzE2XT1GKlArRypiK1oqSSt0dCokLE9bMTddPUYqaStHKkUrWipEK3R0KkgsT1sxOF09Rip1K0cqQStaKlIrdHQqSixPWzE5XT1GKmErRypMK1oqQyt0dCpxK2V0LE99ZnVuY3Rpb24gcyhtKXttPU9iamVjdChyLmNsYW1wKSgwLDEsbSk7Y29uc3QgVD0uMjEyNiptLE89LjcxNTIqbSx2PS4wNzIyKm07cmV0dXJuW1QrMS1tLE8sdiwwLDAsVCxPKzEtbSx2LDAsMCxULE8sdisxLW0sMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gbChtKXtyZXR1cm5bbSwwLDAsMCwwLDAsbSwwLDAsMCwwLDAsbSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBjKG0pe2NvbnN0IFQ9LjIxMjYqKDEtbSksTz0uNzE1MiooMS1tKSx2PS4wNzIyKigxLW0pO3JldHVybltUK20sTyx2LDAsMCxULE8rbSx2LDAsMCxULE8sdittLDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIG8obSl7Y29uc3QgVD0uNSooMS1tKTtyZXR1cm5bbSwwLDAsMCxULDAsbSwwLDAsVCwwLDAsbSwwLFQsMCwwLDAsMSwwXX1mdW5jdGlvbiBmKG0pe2NvbnN0IFQ9MS0yKm07cmV0dXJuW1QsMCwwLDAsbSwwLFQsMCwwLG0sMCwwLFQsMCxtLDAsMCwwLDEsMF19ZnVuY3Rpb24geChtKXtyZXR1cm5bMS0uNjA3Km0sLjc2OSptLC4xODkqbSwwLDAsLjM0OSptLDEtLjMxNCptLC4xNjgqbSwwLDAsLjI3MiptLC41MzQqbSwxLS44NjkqbSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBnKG0pe3JldHVyblsxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCxtLDBdfWZ1bmN0aW9uIHkobSl7Y29uc3QgVD1tLzE4MCpNYXRoLlBJLE89TWF0aC5jb3MoVCksdj1NYXRoLnNpbihUKSxQPS4yMTI2LGk9LjcxNTIsdT0uMDcyMjtyZXR1cm5bUCtPKigxLVApK3YqLVAsaStPKi1pK3YqLWksdStPKi11K3YqKDEtdSksMCwwLFArTyotUCt2Ki4xNDMsaStPKigxLWkpK3YqLjE0LHUrTyotdSt2Ki0uMjgzLDAsMCxQK08qLVArdiotKDEtUCksaStPKi1pK3YqaSx1K08qKDEtdSkrdip1LDAsMCwwLDAsMCwxLDBdfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciByPXQoMzIpLG49dC5uKHIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBzKGwpe2NvbnN0IGM9bigpKGwpO2lmKCFjfHwhYy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5bY1swXS8yNTUsY1sxXS8yNTUsY1syXS8yNTUsY1szXV19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgzMyksbj10KDM3KSxzPXQoMzkpO2QuZXhwb3J0cz1mdW5jdGlvbihjKXt2YXIgbyxmPXIoYyk7cmV0dXJuIGYuc3BhY2U/KG89QXJyYXkoMyksb1swXT1zKGYudmFsdWVzWzBdLDAsMjU1KSxvWzFdPXMoZi52YWx1ZXNbMV0sMCwyNTUpLG9bMl09cyhmLnZhbHVlc1syXSwwLDI1NSksZi5zcGFjZVswXT09PSJoIiYmKG89bi5yZ2IobykpLG8ucHVzaChzKGYuYWxwaGEsMCwxKSksbyk6W119fSxmdW5jdGlvbihkLGUsdCl7KGZ1bmN0aW9uKHIpe3ZhciBuPXQoMzQpLHM9dCgzNSksbD10KDM2KTtkLmV4cG9ydHM9bzt2YXIgYz17cmVkOjAsb3JhbmdlOjYwLHllbGxvdzoxMjAsZ3JlZW46MTgwLGJsdWU6MjQwLHB1cnBsZTozMDB9O2Z1bmN0aW9uIG8oZil7dmFyIHgsZz1bXSx5PTEsbTtpZih0eXBlb2YgZj09InN0cmluZyIpaWYobltmXSlnPW5bZl0uc2xpY2UoKSxtPSJyZ2IiO2Vsc2UgaWYoZj09PSJ0cmFuc3BhcmVudCIpeT0wLG09InJnYiIsZz1bMCwwLDBdO2Vsc2UgaWYoL14jW0EtRmEtZjAtOV0rJC8udGVzdChmKSl7dmFyIFQ9Zi5zbGljZSgxKSxPPVQubGVuZ3RoLHY9Tzw9NDt5PTEsdj8oZz1bcGFyc2VJbnQoVFswXStUWzBdLDE2KSxwYXJzZUludChUWzFdK1RbMV0sMTYpLHBhcnNlSW50KFRbMl0rVFsyXSwxNildLE89PT00JiYoeT1wYXJzZUludChUWzNdK1RbM10sMTYpLzI1NSkpOihnPVtwYXJzZUludChUWzBdK1RbMV0sMTYpLHBhcnNlSW50KFRbMl0rVFszXSwxNikscGFyc2VJbnQoVFs0XStUWzVdLDE2KV0sTz09PTgmJih5PXBhcnNlSW50KFRbNl0rVFs3XSwxNikvMjU1KSksZ1swXXx8KGdbMF09MCksZ1sxXXx8KGdbMV09MCksZ1syXXx8KGdbMl09MCksbT0icmdiIn1lbHNlIGlmKHg9L14oKD86cmdifGhzW2x2Yl18aHdifGNteWs/fHh5W3p5XXxncmF5fGxhYnxsY2h1P3Y/fFtseV11dnxsbXMpYT8pXHMqXCgoW15cKV0qKVwpLy5leGVjKGYpKXt2YXIgUD14WzFdLGk9UD09PSJyZ2IiLFQ9UC5yZXBsYWNlKC9hJC8sIiIpO209VDt2YXIgTz1UPT09ImNteWsiPzQ6VD09PSJncmF5Ij8xOjM7Zz14WzJdLnRyaW0oKS5zcGxpdCgvXHMqLFxzKi8pLm1hcChmdW5jdGlvbihiLEUpe2lmKC8lJC8udGVzdChiKSlyZXR1cm4gRT09PU8/cGFyc2VGbG9hdChiKS8xMDA6VD09PSJyZ2IiP3BhcnNlRmxvYXQoYikqMjU1LzEwMDpwYXJzZUZsb2F0KGIpO2lmKFRbRV09PT0iaCIpe2lmKC9kZWckLy50ZXN0KGIpKXJldHVybiBwYXJzZUZsb2F0KGIpO2lmKGNbYl0hPT12b2lkIDApcmV0dXJuIGNbYl19cmV0dXJuIHBhcnNlRmxvYXQoYil9KSxQPT09VCYmZy5wdXNoKDEpLHk9aXx8Z1tPXT09PXZvaWQgMD8xOmdbT10sZz1nLnNsaWNlKDAsTyl9ZWxzZSBmLmxlbmd0aD4xMCYmL1swLTldKD86XHN8XC8pLy50ZXN0KGYpJiYoZz1mLm1hdGNoKC8oWzAtOV0rKS9nKS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIHBhcnNlRmxvYXQoYSl9KSxtPWYubWF0Y2goLyhbYS16XSkvaWcpLmpvaW4oIiIpLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoIWlzTmFOKGYpKW09InJnYiIsZz1bZj4+PjE2LChmJjY1MjgwKT4+PjgsZiYyNTVdO2Vsc2UgaWYocyhmKSl7dmFyIHU9bChmLnIsZi5yZWQsZi5SLG51bGwpO3UhPT1udWxsPyhtPSJyZ2IiLGc9W3UsbChmLmcsZi5ncmVlbixmLkcpLGwoZi5iLGYuYmx1ZSxmLkIpXSk6KG09ImhzbCIsZz1bbChmLmgsZi5odWUsZi5IKSxsKGYucyxmLnNhdHVyYXRpb24sZi5TKSxsKGYubCxmLmxpZ2h0bmVzcyxmLkwsZi5iLGYuYnJpZ2h0bmVzcyldKSx5PWwoZi5hLGYuYWxwaGEsZi5vcGFjaXR5LDEpLGYub3BhY2l0eSE9bnVsbCYmKHkvPTEwMCl9ZWxzZShBcnJheS5pc0FycmF5KGYpfHxyLkFycmF5QnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcmJkFycmF5QnVmZmVyLmlzVmlldyhmKSkmJihnPVtmWzBdLGZbMV0sZlsyXV0sbT0icmdiIix5PWYubGVuZ3RoPT09ND9mWzNdOjEpO3JldHVybntzcGFjZTptLHZhbHVlczpnLGFscGhhOnl9fX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9e2FsaWNlYmx1ZTpbMjQwLDI0OCwyNTVdLGFudGlxdWV3aGl0ZTpbMjUwLDIzNSwyMTVdLGFxdWE6WzAsMjU1LDI1NV0sYXF1YW1hcmluZTpbMTI3LDI1NSwyMTJdLGF6dXJlOlsyNDAsMjU1LDI1NV0sYmVpZ2U6WzI0NSwyNDUsMjIwXSxiaXNxdWU6WzI1NSwyMjgsMTk2XSxibGFjazpbMCwwLDBdLGJsYW5jaGVkYWxtb25kOlsyNTUsMjM1LDIwNV0sYmx1ZTpbMCwwLDI1NV0sYmx1ZXZpb2xldDpbMTM4LDQzLDIyNl0sYnJvd246WzE2NSw0Miw0Ml0sYnVybHl3b29kOlsyMjIsMTg0LDEzNV0sY2FkZXRibHVlOls5NSwxNTgsMTYwXSxjaGFydHJldXNlOlsxMjcsMjU1LDBdLGNob2NvbGF0ZTpbMjEwLDEwNSwzMF0sY29yYWw6WzI1NSwxMjcsODBdLGNvcm5mbG93ZXJibHVlOlsxMDAsMTQ5LDIzN10sY29ybnNpbGs6WzI1NSwyNDgsMjIwXSxjcmltc29uOlsyMjAsMjAsNjBdLGN5YW46WzAsMjU1LDI1NV0sZGFya2JsdWU6WzAsMCwxMzldLGRhcmtjeWFuOlswLDEzOSwxMzldLGRhcmtnb2xkZW5yb2Q6WzE4NCwxMzQsMTFdLGRhcmtncmF5OlsxNjksMTY5LDE2OV0sZGFya2dyZWVuOlswLDEwMCwwXSxkYXJrZ3JleTpbMTY5LDE2OSwxNjldLGRhcmtraGFraTpbMTg5LDE4MywxMDddLGRhcmttYWdlbnRhOlsxMzksMCwxMzldLGRhcmtvbGl2ZWdyZWVuOls4NSwxMDcsNDddLGRhcmtvcmFuZ2U6WzI1NSwxNDAsMF0sZGFya29yY2hpZDpbMTUzLDUwLDIwNF0sZGFya3JlZDpbMTM5LDAsMF0sZGFya3NhbG1vbjpbMjMzLDE1MCwxMjJdLGRhcmtzZWFncmVlbjpbMTQzLDE4OCwxNDNdLGRhcmtzbGF0ZWJsdWU6WzcyLDYxLDEzOV0sZGFya3NsYXRlZ3JheTpbNDcsNzksNzldLGRhcmtzbGF0ZWdyZXk6WzQ3LDc5LDc5XSxkYXJrdHVycXVvaXNlOlswLDIwNiwyMDldLGRhcmt2aW9sZXQ6WzE0OCwwLDIxMV0sZGVlcHBpbms6WzI1NSwyMCwxNDddLGRlZXBza3libHVlOlswLDE5MSwyNTVdLGRpbWdyYXk6WzEwNSwxMDUsMTA1XSxkaW1ncmV5OlsxMDUsMTA1LDEwNV0sZG9kZ2VyYmx1ZTpbMzAsMTQ0LDI1NV0sZmlyZWJyaWNrOlsxNzgsMzQsMzRdLGZsb3JhbHdoaXRlOlsyNTUsMjUwLDI0MF0sZm9yZXN0Z3JlZW46WzM0LDEzOSwzNF0sZnVjaHNpYTpbMjU1LDAsMjU1XSxnYWluc2Jvcm86WzIyMCwyMjAsMjIwXSxnaG9zdHdoaXRlOlsyNDgsMjQ4LDI1NV0sZ29sZDpbMjU1LDIxNSwwXSxnb2xkZW5yb2Q6WzIxOCwxNjUsMzJdLGdyYXk6WzEyOCwxMjgsMTI4XSxncmVlbjpbMCwxMjgsMF0sZ3JlZW55ZWxsb3c6WzE3MywyNTUsNDddLGdyZXk6WzEyOCwxMjgsMTI4XSxob25leWRldzpbMjQwLDI1NSwyNDBdLGhvdHBpbms6WzI1NSwxMDUsMTgwXSxpbmRpYW5yZWQ6WzIwNSw5Miw5Ml0saW5kaWdvOls3NSwwLDEzMF0saXZvcnk6WzI1NSwyNTUsMjQwXSxraGFraTpbMjQwLDIzMCwxNDBdLGxhdmVuZGVyOlsyMzAsMjMwLDI1MF0sbGF2ZW5kZXJibHVzaDpbMjU1LDI0MCwyNDVdLGxhd25ncmVlbjpbMTI0LDI1MiwwXSxsZW1vbmNoaWZmb246WzI1NSwyNTAsMjA1XSxsaWdodGJsdWU6WzE3MywyMTYsMjMwXSxsaWdodGNvcmFsOlsyNDAsMTI4LDEyOF0sbGlnaHRjeWFuOlsyMjQsMjU1LDI1NV0sbGlnaHRnb2xkZW5yb2R5ZWxsb3c6WzI1MCwyNTAsMjEwXSxsaWdodGdyYXk6WzIxMSwyMTEsMjExXSxsaWdodGdyZWVuOlsxNDQsMjM4LDE0NF0sbGlnaHRncmV5OlsyMTEsMjExLDIxMV0sbGlnaHRwaW5rOlsyNTUsMTgyLDE5M10sbGlnaHRzYWxtb246WzI1NSwxNjAsMTIyXSxsaWdodHNlYWdyZWVuOlszMiwxNzgsMTcwXSxsaWdodHNreWJsdWU6WzEzNSwyMDYsMjUwXSxsaWdodHNsYXRlZ3JheTpbMTE5LDEzNiwxNTNdLGxpZ2h0c2xhdGVncmV5OlsxMTksMTM2LDE1M10sbGlnaHRzdGVlbGJsdWU6WzE3NiwxOTYsMjIyXSxsaWdodHllbGxvdzpbMjU1LDI1NSwyMjRdLGxpbWU6WzAsMjU1LDBdLGxpbWVncmVlbjpbNTAsMjA1LDUwXSxsaW5lbjpbMjUwLDI0MCwyMzBdLG1hZ2VudGE6WzI1NSwwLDI1NV0sbWFyb29uOlsxMjgsMCwwXSxtZWRpdW1hcXVhbWFyaW5lOlsxMDIsMjA1LDE3MF0sbWVkaXVtYmx1ZTpbMCwwLDIwNV0sbWVkaXVtb3JjaGlkOlsxODYsODUsMjExXSxtZWRpdW1wdXJwbGU6WzE0NywxMTIsMjE5XSxtZWRpdW1zZWFncmVlbjpbNjAsMTc5LDExM10sbWVkaXVtc2xhdGVibHVlOlsxMjMsMTA0LDIzOF0sbWVkaXVtc3ByaW5nZ3JlZW46WzAsMjUwLDE1NF0sbWVkaXVtdHVycXVvaXNlOls3MiwyMDksMjA0XSxtZWRpdW12aW9sZXRyZWQ6WzE5OSwyMSwxMzNdLG1pZG5pZ2h0Ymx1ZTpbMjUsMjUsMTEyXSxtaW50Y3JlYW06WzI0NSwyNTUsMjUwXSxtaXN0eXJvc2U6WzI1NSwyMjgsMjI1XSxtb2NjYXNpbjpbMjU1LDIyOCwxODFdLG5hdmFqb3doaXRlOlsyNTUsMjIyLDE3M10sbmF2eTpbMCwwLDEyOF0sb2xkbGFjZTpbMjUzLDI0NSwyMzBdLG9saXZlOlsxMjgsMTI4LDBdLG9saXZlZHJhYjpbMTA3LDE0MiwzNV0sb3JhbmdlOlsyNTUsMTY1LDBdLG9yYW5nZXJlZDpbMjU1LDY5LDBdLG9yY2hpZDpbMjE4LDExMiwyMTRdLHBhbGVnb2xkZW5yb2Q6WzIzOCwyMzIsMTcwXSxwYWxlZ3JlZW46WzE1MiwyNTEsMTUyXSxwYWxldHVycXVvaXNlOlsxNzUsMjM4LDIzOF0scGFsZXZpb2xldHJlZDpbMjE5LDExMiwxNDddLHBhcGF5YXdoaXA6WzI1NSwyMzksMjEzXSxwZWFjaHB1ZmY6WzI1NSwyMTgsMTg1XSxwZXJ1OlsyMDUsMTMzLDYzXSxwaW5rOlsyNTUsMTkyLDIwM10scGx1bTpbMjIxLDE2MCwyMjFdLHBvd2RlcmJsdWU6WzE3NiwyMjQsMjMwXSxwdXJwbGU6WzEyOCwwLDEyOF0scmViZWNjYXB1cnBsZTpbMTAyLDUxLDE1M10scmVkOlsyNTUsMCwwXSxyb3N5YnJvd246WzE4OCwxNDMsMTQzXSxyb3lhbGJsdWU6WzY1LDEwNSwyMjVdLHNhZGRsZWJyb3duOlsxMzksNjksMTldLHNhbG1vbjpbMjUwLDEyOCwxMTRdLHNhbmR5YnJvd246WzI0NCwxNjQsOTZdLHNlYWdyZWVuOls0NiwxMzksODddLHNlYXNoZWxsOlsyNTUsMjQ1LDIzOF0sc2llbm5hOlsxNjAsODIsNDVdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLHNreWJsdWU6WzEzNSwyMDYsMjM1XSxzbGF0ZWJsdWU6WzEwNiw5MCwyMDVdLHNsYXRlZ3JheTpbMTEyLDEyOCwxNDRdLHNsYXRlZ3JleTpbMTEyLDEyOCwxNDRdLHNub3c6WzI1NSwyNTAsMjUwXSxzcHJpbmdncmVlbjpbMCwyNTUsMTI3XSxzdGVlbGJsdWU6WzcwLDEzMCwxODBdLHRhbjpbMjEwLDE4MCwxNDBdLHRlYWw6WzAsMTI4LDEyOF0sdGhpc3RsZTpbMjE2LDE5MSwyMTZdLHRvbWF0bzpbMjU1LDk5LDcxXSx0dXJxdW9pc2U6WzY0LDIyNCwyMDhdLHZpb2xldDpbMjM4LDEzMCwyMzhdLHdoZWF0OlsyNDUsMjIyLDE3OV0sd2hpdGU6WzI1NSwyNTUsMjU1XSx3aGl0ZXNtb2tlOlsyNDUsMjQ1LDI0NV0seWVsbG93OlsyNTUsMjU1LDBdLHllbGxvd2dyZWVuOlsxNTQsMjA1LDUwXX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO2QuZXhwb3J0cz1mdW5jdGlvbihuKXt2YXIgcztyZXR1cm4gci5jYWxsKG4pPT09IltvYmplY3QgT2JqZWN0XSImJihzPU9iamVjdC5nZXRQcm90b3R5cGVPZihuKSxzPT09bnVsbHx8cz09PU9iamVjdC5nZXRQcm90b3R5cGVPZih7fSkpfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWlmKGFyZ3VtZW50c1t0XSE9PXZvaWQgMClyZXR1cm4gYXJndW1lbnRzW3RdfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMzgpO2QuZXhwb3J0cz17bmFtZToiaHNsIixtaW46WzAsMCwwXSxtYXg6WzM2MCwxMDAsMTAwXSxjaGFubmVsOlsiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyJdLGFsaWFzOlsiSFNMIl0scmdiOmZ1bmN0aW9uKG4pe3ZhciBzPW5bMF0vMzYwLGw9blsxXS8xMDAsYz1uWzJdLzEwMCxvLGYseCxnLHk7aWYobD09PTApcmV0dXJuIHk9YyoyNTUsW3kseSx5XTtjPC41P2Y9YyooMStsKTpmPWMrbC1jKmwsbz0yKmMtZixnPVswLDAsMF07Zm9yKHZhciBtPTA7bTwzO20rKyl4PXMrMS8zKi0obS0xKSx4PDA/eCsrOng+MSYmeC0tLDYqeDwxP3k9bysoZi1vKSo2Kng6Mip4PDE/eT1mOjMqeDwyP3k9bysoZi1vKSooMi8zLXgpKjY6eT1vLGdbbV09eSoyNTU7cmV0dXJuIGd9fSxyLmhzbD1mdW5jdGlvbihuKXt2YXIgcz1uWzBdLzI1NSxsPW5bMV0vMjU1LGM9blsyXS8yNTUsbz1NYXRoLm1pbihzLGwsYyksZj1NYXRoLm1heChzLGwsYykseD1mLW8sZyx5LG07cmV0dXJuIGY9PT1vP2c9MDpzPT09Zj9nPShsLWMpL3g6bD09PWY/Zz0yKyhjLXMpL3g6Yz09PWYmJihnPTQrKHMtbCkveCksZz1NYXRoLm1pbihnKjYwLDM2MCksZzwwJiYoZys9MzYwKSxtPShvK2YpLzIsZj09PW8/eT0wOm08PS41P3k9eC8oZitvKTp5PXgvKDItZi1vKSxbZyx5KjEwMCxtKjEwMF19fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXtuYW1lOiJyZ2IiLG1pbjpbMCwwLDBdLG1heDpbMjU1LDI1NSwyNTVdLGNoYW5uZWw6WyJyZWQiLCJncmVlbiIsImJsdWUiXSxhbGlhczpbIlJHQiJdfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9dDtmdW5jdGlvbiB0KHIsbixzKXtyZXR1cm4gbjxzP3I8bj9uOnI+cz9zOnI6cjxzP3M6cj5uP246cn19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDQxKSxuPXQubihyKSxzPXQoNDIpLGw9dC5uKHMpLGM9dCg0Myksbz10Lm4oYyksZj10KDQ0KSx4PXQoNDYpLGc9dC5uKHgpLHk9dCg1MyksbT10KDU1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgVD1TeW1ib2woImNvbnRvdXJzIiksTz1TeW1ib2woInBhdGgiKSx2PVN5bWJvbCgic2ltcGxpZnkiKSxQPVN5bWJvbCgic2NhbGUiKSxpPTIqTWF0aC5QSTtjbGFzcyB1e2NvbnN0cnVjdG9yKGg9e30pe3R5cGVvZiBoPT0ic3RyaW5nIiYmKGg9e3BhdGg6aH0pLGgucGF0aD90aGlzW09dPW4oKShoLnBhdGgpOnRoaXNbT109W10sdGhpc1tUXT1udWxsLHRoaXNbdl09aC5zaW1wbGlmeSE9bnVsbD9oLnNpbXBsaWZ5OjAsdGhpc1tQXT1oLnNjYWxlIT1udWxsP2guc2NhbGU6Mn1nZXQgY29udG91cnMoKXtsZXQgaD1udWxsO2lmKCF0aGlzW1RdJiZ0aGlzW09dKXtjb25zdCBiPU9iamVjdChmLmRlZmF1bHQpKG8oKSh0aGlzW09dKSk7dGhpc1tUXT1nKCkoYix0aGlzW1BdLHRoaXNbdl0pLHRoaXNbVF0ucGF0aD1iLHRoaXNbVF0uc2ltcGxpZnk9dGhpc1t2XSx0aGlzW1RdLnNjYWxlPXRoaXNbUF19cmV0dXJuIHRoaXNbVF0mJihoPXRoaXNbVF0ubWFwKGI9PlsuLi5iXSksaC5wYXRoPXRoaXNbVF0ucGF0aCxoLnNpbXBsaWZ5PXRoaXNbVF0uc2ltcGxpZnksaC5zY2FsZT10aGlzW1RdLnNjYWxlKSxofWdldCBwYXRoKCl7cmV0dXJuIHRoaXNbT119Z2V0IHNpbXBsaWZ5KCl7cmV0dXJuIHRoaXNbdl19Z2V0IGJvdW5kaW5nQm94KCl7Y29uc3QgaD10aGlzLmNvbnRvdXJzO2lmKGgmJmgubGVuZ3RoKXtjb25zdCBiPWgucmVkdWNlKChFLEEpPT5bLi4uRSwuLi5BXSk7cmV0dXJuIGwoKShiKX1yZXR1cm5bWzAsMF0sWzAsMF1dfWdldCBib3VuZGluZ0NlbnRlcigpe2NvbnN0IGg9dGhpcy5ib3VuZGluZ0JveDtyZXR1cm4gaD9bLjUqKGhbMF1bMF0raFsxXVswXSksLjUqKGhbMF1bMV0raFsxXVsxXSldOlswLDBdfW5vcm1hbGl6ZShoPTAsYj0wKXtjb25zdCBFPU9iamVjdChmLmRlZmF1bHQpKG8oKSh0aGlzW09dKSkubWFwKChbQSwuLi5MXSk9Pntjb25zdCBTPVtBXTtmb3IobGV0IEk9MDtJPEwubGVuZ3RoO0krPTIpe2NvbnN0IEQ9TFtJXS1oLFI9TFtJKzFdLWI7Uy5wdXNoKEQsUil9cmV0dXJuIFN9KTtyZXR1cm4gdGhpcy5iZWdpblBhdGgoKSx0aGlzW09dLnB1c2goLi4uRSksdGhpc31nZXRQb2ludEF0TGVuZ3RoKGgpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh5LmdldFBvaW50QXRMZW5ndGgpKHRoaXNbVF0saCk6bnVsbH1nZXRUb3RhbExlbmd0aCgpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh5LmdldFRvdGFsTGVuZ3RoKSh0aGlzW1RdKTowfWFkZFBhdGgoaCl7dGhpc1tUXT1udWxsLHR5cGVvZiBoPT0ic3RyaW5nIiYmKGg9bigpKGgpKSx0aGlzW09dLnB1c2goLi4uaCl9YmVnaW5QYXRoKCl7dGhpc1tPXT1bXSx0aGlzW1RdPW51bGx9Y2xlYXIoKXt0aGlzLmJlZ2luUGF0aCgpfWVsbGlwc2UoaCxiLEUsQSxMLFMsSSxEPTApe2lmKFMrPUwsSSs9TCxFPD0wfHxBPD0wfHxJPT09UylyZXR1cm47STxTJiYoST1TK2krKEktUyklaSksSS1TPmkmJihJPVMraSk7Y29uc3QgUj1JLVM7Uj49aSYmKEktPS4wMDEpO2xldCBDPXRoaXNbT10ubGVuZ3RoPjAmJlI8aT8iTCI6Ik0iO2NvbnN0IGo9T2JqZWN0KG0uZ2V0UG9pbnQpKGgsYixFLEEsUyksJD1PYmplY3QobS5nZXRQb2ludCkoaCxiLEUsQSxJKSxIPSshRDtsZXQgSj1SPk1hdGguUEk/MTowO0QmJihKPTEtSiksQys9ai5qb2luKCIgIiksQys9YEEke0V9ICR7QX0gMCAke0p9ICR7SH0gJHskLmpvaW4oIiAiKX1gLFI+PWkmJihDKz0iWiIpLHRoaXMuYWRkUGF0aChDKX1hcmMoaCxiLEUsQSxMLFM9MCl7cmV0dXJuIHRoaXMuZWxsaXBzZShoLGIsRSxFLDAsQSxMLFMpfWFyY1RvKGgsYixFLEEsTCxTLEkpe3RoaXNbVF09bnVsbCx0aGlzW09dLnB1c2goWyJBIixoLGIsRSxBLEwsUyxJXSl9bW92ZVRvKGgsYil7dGhpc1tUXT1udWxsLHRoaXNbT10ucHVzaChbIk0iLGgsYl0pfWxpbmVUbyhoLGIpe3RoaXNbVF09bnVsbCx0aGlzW09dLnB1c2goWyJMIixoLGJdKX1iZXppZXJDdXJ2ZVRvKGgsYixFLEEsTCxTKXt0aGlzW1RdPW51bGwsdGhpc1tPXS5wdXNoKFsiQyIsaCxiLEUsQSxMLFNdKX1xdWFkcmF0aWNDdXJ2ZVRvKGgsYixFLEEpe3RoaXNbVF09bnVsbCx0aGlzW09dLnB1c2goWyJRIixoLGIsRSxBXSl9cmVjdChoLGIsRSxBKXtjb25zdCBMPWBNJHtofSAke2J9TCR7aCtFfSAke2J9TCR7aCtFfSAke2IrQX1MJHtofSAke2IrQX1aYDt0aGlzLmFkZFBhdGgoTCl9Y2xvc2VQYXRoKCl7dGhpc1tUXT1udWxsO2xldCBoPVtdO2NvbnN0IGI9dGhpc1tPXS5sZW5ndGg7Yj4wJiYoaD10aGlzW09dW2ItMV0pLGhbMF0hPT0iWiImJmhbMF0hPT0ieiImJnRoaXNbT10ucHVzaChbIloiXSl9fX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9bjt2YXIgdD17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxyPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gbihjKXt2YXIgbz1bXTtyZXR1cm4gYy5yZXBsYWNlKHIsZnVuY3Rpb24oZix4LGcpe3ZhciB5PXgudG9Mb3dlckNhc2UoKTtmb3IoZz1sKGcpLHk9PSJtIiYmZy5sZW5ndGg+MiYmKG8ucHVzaChbeF0uY29uY2F0KGcuc3BsaWNlKDAsMikpKSx5PSJsIix4PXg9PSJtIj8ibCI6IkwiKTs7KXtpZihnLmxlbmd0aD09dFt5XSlyZXR1cm4gZy51bnNoaWZ0KHgpLG8ucHVzaChnKTtpZihnLmxlbmd0aDx0W3ldKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO28ucHVzaChbeF0uY29uY2F0KGcuc3BsaWNlKDAsdFt5XSkpKX19KSxvfXZhciBzPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIGwoYyl7dmFyIG89Yy5tYXRjaChzKTtyZXR1cm4gbz9vLm1hcChOdW1iZXIpOltdfX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz1yO2Z1bmN0aW9uIHIobil7dmFyIHM9bi5sZW5ndGg7aWYocz09PTApcmV0dXJuW1tdLFtdXTtmb3IodmFyIGw9blswXS5sZW5ndGgsYz1uWzBdLnNsaWNlKCksbz1uWzBdLnNsaWNlKCksZj0xO2Y8czsrK2YpZm9yKHZhciB4PW5bZl0sZz0wO2c8bDsrK2cpe3ZhciB5PXhbZ107Y1tnXT1NYXRoLm1pbihjW2ddLHkpLG9bZ109TWF0aC5tYXgob1tnXSx5KX1yZXR1cm5bYyxvXX19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPXQ7ZnVuY3Rpb24gdChyKXt2YXIgbj0wLHM9MCxsPTAsYz0wO3JldHVybiByLm1hcChmdW5jdGlvbihvKXtvPW8uc2xpY2UoKTt2YXIgZj1vWzBdLHg9Zi50b1VwcGVyQ2FzZSgpO2lmKGYhPXgpc3dpdGNoKG9bMF09eCxmKXtjYXNlImEiOm9bNl0rPWwsb1s3XSs9YzticmVhaztjYXNlInYiOm9bMV0rPWM7YnJlYWs7Y2FzZSJoIjpvWzFdKz1sO2JyZWFrO2RlZmF1bHQ6Zm9yKHZhciBnPTE7ZzxvLmxlbmd0aDspb1tnKytdKz1sLG9bZysrXSs9Y31zd2l0Y2goeCl7Y2FzZSJaIjpsPW4sYz1zO2JyZWFrO2Nhc2UiSCI6bD1vWzFdO2JyZWFrO2Nhc2UiViI6Yz1vWzFdO2JyZWFrO2Nhc2UiTSI6bD1uPW9bMV0sYz1zPW9bMl07YnJlYWs7ZGVmYXVsdDpsPW9bby5sZW5ndGgtMl0sYz1vW28ubGVuZ3RoLTFdfXJldHVybiBvfSl9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIHI9dCg0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oYyl7Zm9yKHZhciBvLGY9W10seD0wLGc9MCx5PTAsbT0wLFQ9bnVsbCxPPW51bGwsdj0wLFA9MCxpPTAsdT1jLmxlbmd0aDtpPHU7aSsrKXt2YXIgYT1jW2ldLGg9YVswXTtzd2l0Y2goaCl7Y2FzZSJNIjp5PWFbMV0sbT1hWzJdO2JyZWFrO2Nhc2UiQSI6dmFyIGI9T2JqZWN0KHIuZGVmYXVsdCkodixQLGFbNl0sYVs3XSxhWzRdLGFbNV0sYVsxXSxhWzJdLGFbM10pO2lmKCFiLmxlbmd0aCljb250aW51ZTtiPWIubWFwKEk9Pntjb25zdFtELFIsQyxqLCQsSCxKLHFdPUk7cmV0dXJue3gxOkMseTE6aix4MjokLHkyOkgseDpKLHk6cX19KTtmb3IodmFyIEU9MCxBO0U8Yi5sZW5ndGg7RSsrKUE9YltFXSxhPVsiQyIsQS54MSxBLnkxLEEueDIsQS55MixBLngsQS55XSxFPGIubGVuZ3RoLTEmJmYucHVzaChhKTticmVhaztjYXNlIlMiOnZhciBMPXYsUz1QOyhvPT0iQyJ8fG89PSJTIikmJihMKz1MLXgsUys9Uy1nKSxhPVsiQyIsTCxTLGFbMV0sYVsyXSxhWzNdLGFbNF1dO2JyZWFrO2Nhc2UiVCI6bz09IlEifHxvPT0iVCI/KFQ9dioyLVQsTz1QKjItTyk6KFQ9dixPPVApLGE9bCh2LFAsVCxPLGFbMV0sYVsyXSk7YnJlYWs7Y2FzZSJRIjpUPWFbMV0sTz1hWzJdLGE9bCh2LFAsYVsxXSxhWzJdLGFbM10sYVs0XSk7YnJlYWs7Y2FzZSJMIjphPXModixQLGFbMV0sYVsyXSk7YnJlYWs7Y2FzZSJIIjphPXModixQLGFbMV0sUCk7YnJlYWs7Y2FzZSJWIjphPXModixQLHYsYVsxXSk7YnJlYWs7Y2FzZSJaIjphPXModixQLHksbSk7YnJlYWt9bz1oLHY9YVthLmxlbmd0aC0yXSxQPWFbYS5sZW5ndGgtMV0sYS5sZW5ndGg+ND8oeD1hW2EubGVuZ3RoLTRdLGc9YVthLmxlbmd0aC0zXSk6KHg9dixnPVApLGYucHVzaChhKX1yZXR1cm4gZn1mdW5jdGlvbiBzKGMsbyxmLHgpe3JldHVyblsiQyIsYyxvLGYseCxmLHhdfWZ1bmN0aW9uIGwoYyxvLGYseCxnLHkpe3JldHVyblsiQyIsYy8zKzIvMypmLG8vMysyLzMqeCxnLzMrMi8zKmYseS8zKzIvMyp4LGcseV19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIG4obyxmLHgsZyl7Y29uc3QgeT1vKmctZip4PDA/LTE6MTtsZXQgbT1vKngrZipnO3JldHVybiBtPjEmJihtPTEpLG08LTEmJihtPS0xKSx5Kk1hdGguYWNvcyhtKX1mdW5jdGlvbiBzKG8sZix4LGcseSxtLFQsTyx2LFApe2NvbnN0IGk9UCooby14KS8yK3YqKGYtZykvMix1PS12KihvLXgpLzIrUCooZi1nKS8yLGE9VCpULGg9TypPLGI9aSppLEU9dSp1O2xldCBBPWEqaC1hKkUtaCpiO0E8MCYmKEE9MCksQS89YSpFK2gqYixBPU1hdGguc3FydChBKSooeT09PW0/LTE6MSk7Y29uc3QgTD1BKlQvTyp1LFM9QSotTy9UKmksST1QKkwtdipTKyhvK3gpLzIsRD12KkwrUCpTKyhmK2cpLzIsUj0oaS1MKS9ULEM9KHUtUykvTyxqPSgtaS1MKS9ULCQ9KC11LVMpL08sSD1uKDEsMCxSLEMpO2xldCBKPW4oUixDLGosJCk7cmV0dXJuIG09PT0wJiZKPjAmJihKLT1yKSxtPT09MSYmSjwwJiYoSis9ciksW0ksRCxILEpdfWZ1bmN0aW9uIGwobyxmKXtjb25zdCB4PTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihmLzQpLGc9TWF0aC5jb3MobykseT1NYXRoLnNpbihvKSxtPU1hdGguY29zKG8rZiksVD1NYXRoLnNpbihvK2YpO3JldHVybltnLHksZy15KngseStnKngsbStUKngsVC1tKngsbSxUXX1mdW5jdGlvbiBjKG8sZix4LGcseSxtLFQsTyx2KXtjb25zdCBQPU1hdGguc2luKHYqci8zNjApLGk9TWF0aC5jb3ModipyLzM2MCksdT1pKihvLXgpLzIrUCooZi1nKS8yLGE9LVAqKG8teCkvMitpKihmLWcpLzI7aWYodT09PTAmJmE9PT0wKXJldHVybltdO2lmKFQ9PT0wfHxPPT09MClyZXR1cm5bXTtUPU1hdGguYWJzKFQpLE89TWF0aC5hYnMoTyk7Y29uc3QgaD11KnUvKFQqVCkrYSphLyhPKk8pO2g+MSYmKFQqPU1hdGguc3FydChoKSxPKj1NYXRoLnNxcnQoaCkpO2NvbnN0IGI9cyhvLGYseCxnLHksbSxULE8sUCxpKSxFPVtdO2xldCBBPWJbMl0sTD1iWzNdO2NvbnN0IFM9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKEwpLyhyLzQpKSwxKTtMLz1TO2ZvcihsZXQgST0wO0k8UztJKyspRS5wdXNoKGwoQSxMKSksQSs9TDtyZXR1cm4gRS5tYXAoST0+e2ZvcihsZXQgRD0wO0Q8SS5sZW5ndGg7RCs9Mil7bGV0IFI9SVtEKzBdLEM9SVtEKzFdO1IqPVQsQyo9Tztjb25zdCBqPWkqUi1QKkMsJD1QKlIraSpDO0lbRCswXT1qK2JbMF0sSVtEKzFdPSQrYlsxXX1yZXR1cm4gSX0pfX0sZnVuY3Rpb24oZCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj10KDQ3KSx7Y29weTpufT10KDQ5KSxzPXQoNTApO2Z1bmN0aW9uIGwoZyx5LG0pe3JldHVybiBnWzBdPXksZ1sxXT1tLGd9dmFyIGM9WzAsMF0sbz1bMCwwXSxmPVswLDBdO2Z1bmN0aW9uIHgoZyx5LG0sVCl7cihtLGwoYyxUWzFdLFRbMl0pLGwobyxUWzNdLFRbNF0pLGwoZixUWzVdLFRbNl0pLHksZyl9ZC5leHBvcnRzPWZ1bmN0aW9uKHksbSxUKXt2YXIgTz1bXSx2PVtdLFA9WzAsMF07cmV0dXJuIHkuZm9yRWFjaChmdW5jdGlvbihpLHUsYSl7aWYoaVswXT09PSJNIiluKFAsaS5zbGljZSgxKSksdi5sZW5ndGg+MCYmKE8ucHVzaCh2KSx2PVtdKTtlbHNlIGlmKGlbMF09PT0iQyIpeCh2LG0sUCxpKSxsKFAsaVs1XSxpWzZdKTtlbHNlIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCB0eXBlIGluIFNWRzogIitpWzBdKX0pLHYubGVuZ3RoPjAmJk8ucHVzaCh2KSxPLm1hcChmdW5jdGlvbihpKXtyZXR1cm4gcyhpLFR8fDApfSl9fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXQoNDgpKCl9LGZ1bmN0aW9uKGQsZSl7ZnVuY3Rpb24gdChuKXtyZXR1cm5bblswXSxuWzFdXX1mdW5jdGlvbiByKG4scyl7cmV0dXJuW24sc119ZC5leHBvcnRzPWZ1bmN0aW9uKHMpe3M9c3x8e307dmFyIGw9dHlwZW9mIHMucmVjdXJzaW9uPT0ibnVtYmVyIj9zLnJlY3Vyc2lvbjo4LGM9dHlwZW9mIHMuZXBzaWxvbj09Im51bWJlciI/cy5lcHNpbG9uOjExOTIwOTI5ZS0xNCxvPXR5cGVvZiBzLnBhdGhFcHNpbG9uPT0ibnVtYmVyIj9zLnBhdGhFcHNpbG9uOjEsZj10eXBlb2Ygcy5hbmdsZUVwc2lsb249PSJudW1iZXIiP3MuYW5nbGVFcHNpbG9uOi4wMSx4PXMuYW5nbGVUb2xlcmFuY2V8fDAsZz1zLmN1c3BMaW1pdHx8MDtyZXR1cm4gZnVuY3Rpb24oTyx2LFAsaSx1LGEpe2F8fChhPVtdKSx1PXR5cGVvZiB1PT0ibnVtYmVyIj91OjE7dmFyIGg9by91O3JldHVybiBoKj1oLHkoTyx2LFAsaSxhLGgpLGF9O2Z1bmN0aW9uIHkoVCxPLHYsUCxpLHUpe2kucHVzaCh0KFQpKTt2YXIgYT1UWzBdLGg9VFsxXSxiPU9bMF0sRT1PWzFdLEE9dlswXSxMPXZbMV0sUz1QWzBdLEk9UFsxXTttKGEsaCxiLEUsQSxMLFMsSSxpLHUsMCksaS5wdXNoKHQoUCkpfWZ1bmN0aW9uIG0oVCxPLHYsUCxpLHUsYSxoLGIsRSxBKXtpZighKEE+bCkpe3ZhciBMPU1hdGguUEksUz0oVCt2KS8yLEk9KE8rUCkvMixEPSh2K2kpLzIsUj0oUCt1KS8yLEM9KGkrYSkvMixqPSh1K2gpLzIsJD0oUytEKS8yLEg9KEkrUikvMixKPShEK0MpLzIscT0oUitqKS8yLEY9KCQrSikvMixHPShIK3EpLzI7aWYoQT4wKXt2YXIgWj1hLVQsdHQ9aC1PLGV0PU1hdGguYWJzKCh2LWEpKnR0LShQLWgpKlopLGl0PU1hdGguYWJzKChpLWEpKnR0LSh1LWgpKlopLGssaHQ7aWYoZXQ+YyYmaXQ+Yyl7aWYoKGV0K2l0KSooZXQraXQpPD1FKihaKlordHQqdHQpKXtpZih4PGYpe2IucHVzaChyKEYsRykpO3JldHVybn12YXIgZnQ9TWF0aC5hdGFuMih1LVAsaS12KTtpZihrPU1hdGguYWJzKGZ0LU1hdGguYXRhbjIoUC1PLHYtVCkpLGh0PU1hdGguYWJzKE1hdGguYXRhbjIoaC11LGEtaSktZnQpLGs+PUwmJihrPTIqTC1rKSxodD49TCYmKGh0PTIqTC1odCksaytodDx4KXtiLnB1c2gocihGLEcpKTtyZXR1cm59aWYoZyE9PTApe2lmKGs+Zyl7Yi5wdXNoKHIodixQKSk7cmV0dXJufWlmKGh0Pmcpe2IucHVzaChyKGksdSkpO3JldHVybn19fX1lbHNlIGlmKGV0PmMpe2lmKGV0KmV0PD1FKihaKlordHQqdHQpKXtpZih4PGYpe2IucHVzaChyKEYsRykpO3JldHVybn1pZihrPU1hdGguYWJzKE1hdGguYXRhbjIodS1QLGktdiktTWF0aC5hdGFuMihQLU8sdi1UKSksaz49TCYmKGs9MipMLWspLGs8eCl7Yi5wdXNoKHIodixQKSksYi5wdXNoKHIoaSx1KSk7cmV0dXJufWlmKGchPT0wJiZrPmcpe2IucHVzaChyKHYsUCkpO3JldHVybn19fWVsc2UgaWYoaXQ+Yyl7aWYoaXQqaXQ8PUUqKFoqWit0dCp0dCkpe2lmKHg8Zil7Yi5wdXNoKHIoRixHKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihoLXUsYS1pKS1NYXRoLmF0YW4yKHUtUCxpLXYpKSxrPj1MJiYoaz0yKkwtayksazx4KXtiLnB1c2gocih2LFApKSxiLnB1c2gocihpLHUpKTtyZXR1cm59aWYoZyE9PTAmJms+Zyl7Yi5wdXNoKHIoaSx1KSk7cmV0dXJufX19ZWxzZSBpZihaPUYtKFQrYSkvMix0dD1HLShPK2gpLzIsWipaK3R0KnR0PD1FKXtiLnB1c2gocihGLEcpKTtyZXR1cm59fW0oVCxPLFMsSSwkLEgsRixHLGIsRSxBKzEpLG0oRixHLEoscSxDLGosYSxoLGIsRSxBKzEpfX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY29tcHV0ZU1pdGVyIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsIm5vcm1hbCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJkaXJlY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTt2YXIgcj10KDEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHUpe3JldHVyblt1WzBdLHVbMV1dfWZ1bmN0aW9uIHMoKXtyZXR1cm5bMCwwXX1jb25zdCBsPXIudmVjMi5jb3B5LGM9ci52ZWMyLnNjYWxlQW5kQWRkLG89ci52ZWMyLmRvdCxmPXIudmVjMi5yb3RhdGUseD1yLnZlYzIuY3Jvc3MsZz1yLnZlYzIuc3ViLHk9ci52ZWMyLmFkZCxtPXIudmVjMi5ub3JtYWxpemUsVD1yLnZlYzIuc2V0LE89cygpO2Z1bmN0aW9uIHYodSxhLGgsYixFKXt5KHUsaCxiKSxtKHUsdSksVChhLC11WzFdLHVbMF0pLFQoTywtaFsxXSxoWzBdKTtjb25zdCBBPUUvbyhhLE8pO3JldHVybiBNYXRoLmFicyhBKX1mdW5jdGlvbiBQKHUsYSl7cmV0dXJuIFQodSwtYVsxXSxhWzBdKSx1fWZ1bmN0aW9uIGkodSxhLGgpe3JldHVybiBnKHUsYSxoKSxtKHUsdSksdX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDUxKSxuPXQoNTIpO2QuZXhwb3J0cz1mdW5jdGlvbihsLGMpe3JldHVybiBsPXIobCxjKSxsPW4obCxjKSxsfSxkLmV4cG9ydHMucmFkaWFsRGlzdGFuY2U9cixkLmV4cG9ydHMuZG91Z2xhc1BldWNrZXI9bn0sZnVuY3Rpb24oZCxlKXtmdW5jdGlvbiB0KHIsbil7dmFyIHM9clswXS1uWzBdLGw9clsxXS1uWzFdO3JldHVybiBzKnMrbCpsfWQuZXhwb3J0cz1mdW5jdGlvbihuLHMpe2lmKG4ubGVuZ3RoPD0xKXJldHVybiBuO3M9dHlwZW9mIHM9PSJudW1iZXIiP3M6MTtmb3IodmFyIGw9cypzLGM9blswXSxvPVtjXSxmLHg9MSxnPW4ubGVuZ3RoO3g8Zzt4KyspZj1uW3hdLHQoZixjKT5sJiYoby5wdXNoKGYpLGM9Zik7cmV0dXJuIGMhPT1mJiZvLnB1c2goZiksb319LGZ1bmN0aW9uKGQsZSl7ZnVuY3Rpb24gdChuLHMsbCl7dmFyIGM9c1swXSxvPXNbMV0sZj1sWzBdLWMseD1sWzFdLW87aWYoZiE9PTB8fHghPT0wKXt2YXIgZz0oKG5bMF0tYykqZisoblsxXS1vKSp4KS8oZipmK3gqeCk7Zz4xPyhjPWxbMF0sbz1sWzFdKTpnPjAmJihjKz1mKmcsbys9eCpnKX1yZXR1cm4gZj1uWzBdLWMseD1uWzFdLW8sZipmK3gqeH1mdW5jdGlvbiByKG4scyxsLGMsbyl7Zm9yKHZhciBmPWMseCxnPXMrMTtnPGw7ZysrKXt2YXIgeT10KG5bZ10sbltzXSxuW2xdKTt5PmYmJih4PWcsZj15KX1mPmMmJih4LXM+MSYmcihuLHMseCxjLG8pLG8ucHVzaChuW3hdKSxsLXg+MSYmcihuLHgsbCxjLG8pKX1kLmV4cG9ydHM9ZnVuY3Rpb24ocyxsKXtpZihzLmxlbmd0aDw9MSlyZXR1cm4gcztsPXR5cGVvZiBsPT0ibnVtYmVyIj9sOjE7dmFyIGM9bCpsLG89cy5sZW5ndGgtMSxmPVtzWzBdXTtyZXR1cm4gcihzLDAsbyxjLGYpLGYucHVzaChzW29dKSxmfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZ2V0VG90YWxMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZ2V0UG9pbnRBdExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJnZXREYXNoQ29udG91cnMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDU0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihvKXtpZihvLnRvdGFsTGVuZ3RoIT1udWxsKXJldHVybiBvLnRvdGFsTGVuZ3RoO2xldCBmPTA7cmV0dXJuIG8uZm9yRWFjaCh4PT57bGV0IGc9eFswXTtmb3IobGV0IHk9MTt5PHgubGVuZ3RoO3krKyl7Y29uc3QgbT14W3ldO2YrPU9iamVjdChyLmRpc3RhbmNlKShnLG0pLGc9bX19KSxvLnRvdGFsTGVuZ3RoPWYsZn1mdW5jdGlvbiBzKG8sZix4PSEwKXtpZihmPU51bWJlcihmKSwhTnVtYmVyLmlzRmluaXRlKGYpKXRocm93IG5ldyBUeXBlRXJyb3IoIkZhaWxlZCB0byBleGVjdXRlICdnZXRQb2ludEF0TGVuZ3RoJyBvbiBmaWd1cmU6IFRoZSBwcm92aWRlZCBmbG9hdCB2YWx1ZSBpcyBub24tZmluaXRlLiIpO2lmKGY8PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiTGVuZ3RoIG11c3QgPiAwIik7Y29uc3QgZz1uKG8pO2lmKGY+PWcpe2NvbnN0IG09b1tvLmxlbmd0aC0xXSxUPW1bbS5sZW5ndGgtMl0sTz1tW20ubGVuZ3RoLTFdLHY9TWF0aC5hdGFuMihPWzFdLVRbMV0sT1swXS1UWzBdKTtyZXR1cm57Y3VycmVudDpvLm1hcChQPT5bLi4uUF0pLHBvaW50Ont4Ok9bMF0seTpPWzFdLGFuZ2xlOnZ9fX1jb25zdCB5PVtdO2ZvcihsZXQgbT0wO208by5sZW5ndGg7bSsrKXt5W21dPVtdO2NvbnN0IFQ9b1ttXTtsZXQgTz1UWzBdO2ZvcihsZXQgdj0xO3Y8VC5sZW5ndGg7disrKXtjb25zdCBQPVRbdl0saT1PYmplY3Qoci5kaXN0YW5jZSkoTyxQKTtpZihmPGkpe2NvbnN0IHU9Zi9pLGE9TWF0aC5hdGFuMihQWzFdLU9bMV0sUFswXS1PWzBdKSxoPXt4Ok9bMF0qKDEtdSkrUFswXSp1LHk6T1sxXSooMS11KStQWzFdKnUsYW5nbGU6YX07aWYoeVttXS5wdXNoKE8pLGY+MCYmeVttXS5wdXNoKFtoLngsaC55XSksIXgpcmV0dXJue2N1cnJlbnQ6eSxwb2ludDpofTtjb25zdCBiPVtdLEU9bTtmb3IoO208by5sZW5ndGg7bSsrKXtmb3IoYlttLUVdPVtdLG09PT1FJiZiWzBdLnB1c2goW2gueCxoLnldKTt2PFQubGVuZ3RoO3YrKyliW20tRV0ucHVzaChUW3ZdKTt2PTB9cmV0dXJue2N1cnJlbnQ6eSxwb2ludDpoLHJlc3Q6Yn19Zi09aSx5W21dLnB1c2goTyksTz1QfX19ZnVuY3Rpb24gbChvLGYpe2lmKGY9TnVtYmVyKGYpLCFOdW1iZXIuaXNGaW5pdGUoZikpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoby5sZW5ndGg8PTApcmV0dXJue3g6MCx5OjAsYW5nbGU6MH07aWYoZjw9MCl7Y29uc3QgeD1vWzBdWzBdLGc9b1swXVsxXSx5PU1hdGguYXRhbjIoZ1sxXS14WzFdLGdbMF0teFswXSk7cmV0dXJue3g6eFswXSx5OnhbMV0sYW5nbGU6eX19cmV0dXJuIHMobyxmLCExKS5wb2ludH1mdW5jdGlvbiBjKG8sZix4KXtsZXQgZz0wLHk9ZlswXSxtPW87Y29uc3QgVD1bXSxPPWYubGVuZ3RoO2lmKHg+MCl7ZG8geC09ZltnJU9dLGcrKzt3aGlsZSh4PjApO3g8MCYmKHk9LXgsZy0tKX1lbHNlIGlmKHg8MCl7Zz0tMTtkbyB4Kz1mW2clTytPLTFdLGctLTt3aGlsZSh4PDApO3g+PTAmJihnKysseT1mW2clTytPLTFdLXgpfWRve2NvbnN0IHY9cyhtLHkpO209di5yZXN0LCsrZyUyJiZULnB1c2goLi4udi5jdXJyZW50KTtsZXQgUD1nJU87UDwwJiYoUCs9TykseT1mW1BdfXdoaWxlKG0pO3JldHVybiBUfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBufSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoW3MsbCxjXSxvLGYseCl7cmV0dXJuIHM9cyoyL28tMSxsPTEtbCoyL2YsTnVtYmVyLmlzRmluaXRlKHgpPyhjPWMqMi94LTEsW3MsbCxjXSk6W3MsbF19ZnVuY3Rpb24gbihbcyxsLGM9MF0sW28sZix4PTBdKXtyZXR1cm4gTWF0aC5oeXBvdChvLXMsZi1sLHgtYyl9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRQb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPU1hdGguUEkqMjtmdW5jdGlvbiBuKHMsbCxjLG8sZil7ZiU9cixmPDAmJihmKz1yKTtjb25zdCB4PU1hdGgudGFuKGYpO2lmKE1hdGguYWJzKHgpPDFlNSl7Y29uc3QgZz1sLXgqcyx5PTEvYyoqMit4KioyL28qKjI7bGV0IG09LTE7KGY8PU1hdGguUEkvMnx8Zj4zKk1hdGguUEkvMikmJihtPTEpO2NvbnN0IFQ9bSpNYXRoLnNxcnQoMS95KStzLE89eCpUK2c7cmV0dXJuW1QsT119cmV0dXJuIGY8TWF0aC5QST9bcyxsK29dOltzLGwtb119fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBWfSk7dmFyIHI9dCgxKSxuPXQoNDIpLHM9dC5uKG4pLGw9dCg1NyksYz10KDI4KSxvPXQoMjQpLGY9dCgzMCkseD10KDU5KSxnPXQoNTMpLHk9dCg2MCksbT10Lm4oeSksVD10KDQ2KSxPPXQubihUKSx2PXQoMzEpLFA9dCg0MCksaT10KDIxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShYLE4pe2lmKFg9PW51bGwpcmV0dXJue307dmFyIHo9YShYLE4pLHAsTTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgdz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFgpO2ZvcihNPTA7TTx3Lmxlbmd0aDtNKyspcD13W01dLCEoTi5pbmRleE9mKHApPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFgscCkmJih6W3BdPVhbcF0pfXJldHVybiB6fWZ1bmN0aW9uIGEoWCxOKXtpZihYPT1udWxsKXJldHVybnt9O3ZhciB6PXt9LHA9T2JqZWN0LmtleXMoWCksTSx3O2Zvcih3PTA7dzxwLmxlbmd0aDt3KyspTT1wW3ddLCEoTi5pbmRleE9mKE0pPj0wKSYmKHpbTV09WFtNXSk7cmV0dXJuIHp9Y29uc3QgaD1TeW1ib2woIm1lc2giKSxiPVN5bWJvbCgiY29udG91cnMiKSxFPVN5bWJvbCgic3Ryb2tlIiksQT1TeW1ib2woImZpbGwiKSxMPVN5bWJvbCgic3Ryb2tlQ29sb3IiKSxTPVN5bWJvbCgiZmlsbENvbG9yIiksST1TeW1ib2woInRyYW5zZm9ybSIpLEQ9U3ltYm9sKCJpbnZlcnRUcmFuc2Zvcm0iKSxSPVN5bWJvbCgidW5pZm9ybXMiKSxDPVN5bWJvbCgidGV4T3B0aW9ucyIpLGo9U3ltYm9sKCJibGVuZCIpLCQ9U3ltYm9sKCJhcHBseVRleHR1cmUiKSxIPVN5bWJvbCgiYXBwbHlUcmFuc2Zvcm0iKSxKPVN5bWJvbCgiYXBwbHlHcmFkaWVudFRyYW5zZm9ybSIpLHE9U3ltYm9sKCJhcHBseVByb2dyYW0iKSxGPVN5bWJvbCgiZ3JhZGllbnQiKSxHPVN5bWJvbCgiZmlsdGVyIiksWj1TeW1ib2woIm9wYWNpdHkiKSx0dD1TeW1ib2woInByb2dyYW0iKSxldD1TeW1ib2woImF0dHJpYnV0ZXMiKSxpdD1TeW1ib2woInBhc3MiKSxrPVN5bWJvbCgiY2xpcENvbnRleHQiKSxodD1TeW1ib2woImFwcGx5Q2xpcFBhdGgiKTtmdW5jdGlvbiBmdChYLE4pe2NvbnN0W3oscF09W1hbMV1bMF0tWFswXVswXSxYWzFdWzFdLVhbMF1bMV1dLE09W107Zm9yKGxldCB3PTA7dzxOLmxlbmd0aDt3Kyspe2NvbnN0IFU9Tlt3XSxLPVsoVVswXS1YWzBdWzBdKS96LDEtKFVbMV0tWFswXVsxXSkvcF07TS5wdXNoKEspfXJldHVybiBNfWZ1bmN0aW9uIEIoW1gsTl0sW3oscCxNLHddLHtzY2FsZTpVfSl7cmV0dXJuIFV8fChYLz1NLE49MS1OL3csWC09eixOKz1wKSxbWCxOLDBdfWZ1bmN0aW9uIFcoWCxOLHope2NvbnN0IHA9TygpKFgsTix6KTtyZXR1cm4gcC5wYXRoPVgscC5zaW1wbGlmeT16LHAuc2NhbGU9TixwfWNsYXNzIFZ7Y29uc3RydWN0b3IoTil7dGhpc1tFXT1udWxsLHRoaXNbQV09bnVsbCx0aGlzW0ldPVsxLDAsMCwxLDAsMF0sdGhpc1taXT0xLHRoaXNbUl09e30sdGhpc1tHXT1bXSx0aGlzW2pdPW51bGwsdGhpc1tDXT17fSx0aGlzLmNvbnRvdXJzPU4uY29udG91cnMsdGhpc1t0dF09bnVsbCx0aGlzW2V0XT17fSx0aGlzW2l0XT1bXX1nZXQgY29udG91cnMoKXtyZXR1cm4gdGhpc1tiXX1zZXQgY29udG91cnMoTil7dGhpc1toXT1udWxsLHRoaXNbYl09Tjtjb25zdCB6PU4uc2NhbGU7dGhpcy50cmFuc2Zvcm1TY2FsZS96PjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKX1zZXRQcm9ncmFtKE4pe3RoaXNbdHRdPU4sdGhpc1toXSYmdGhpc1txXShOKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW3R0XX1zZXRBdHRyaWJ1dGUoTix6KXt6PT1udWxsP2RlbGV0ZSB0aGlzW2V0XVtOXTp0aGlzW2V0XVtOXT16fWdldE9wYWNpdHkoKXtyZXR1cm4gdGhpc1taXX1zZXRPcGFjaXR5KE4pe2lmKE48MHx8Tj4xKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgb3BhY2l0eSB2YWx1ZS4iKTt0aGlzW2hdJiZ0aGlzW2hdLnBvc2l0aW9ucy5mb3JFYWNoKHo9Pnt6WzJdPTEvelsyXT4wP046LU59KSx0aGlzW1pdPU59c2V0Q2xpcFBhdGgoTil7dGhpcy5jbGlwUGF0aD1OLHRoaXNbUl0udV9jbGlwU2FtcGxlciYmdGhpc1tSXS51X2NsaXBTYW1wbGVyLmRlbGV0ZSgpLHRoaXMuc2V0VW5pZm9ybXMoe3VfY2xpcFNhbXBsZXI6bnVsbH0pLHRoaXNbaF0mJmRlbGV0ZSB0aGlzW2hdLmF0dHJpYnV0ZXMuYV9jbGlwVVYsTiYmdGhpc1toXSYmdGhpc1todF0oKX1baHRdKCl7aWYodGhpcy5jbGlwUGF0aCl7dGhpc1trXXx8KHRoaXNba109aS5kZWZhdWx0LmNyZWF0ZUNhbnZhcygxLDEpKTtjb25zdFtbTix6XSxbcCxNXV09dGhpcy5ib3VuZGluZ0JveDtwJiZNJiYodGhpc1trXS53aWR0aD1wLU4sdGhpc1trXS5oZWlnaHQ9TS16KTtjb25zdCB3PXRoaXNba10uZ2V0Q29udGV4dCgiMmQiKSxVPW5ldyBQYXRoMkQodGhpcy5jbGlwUGF0aCk7dy5jbGVhclJlY3QoMCwwLHRoaXNba10ud2lkdGgsdGhpc1trXS5oZWlnaHQpLHcuc2F2ZSgpLHcudHJhbnNsYXRlKC1OLC16KSx3LmZpbGxTdHlsZT0id2hpdGUiLHcuZmlsbChVKSx3LnJlc3RvcmUoKSx0aGlzW2hdLmNsaXBQYXRoPXRoaXNba107Y29uc3QgSz1mdCh0aGlzLmJvdW5kaW5nQm94LHRoaXNbaF0ucG9zaXRpb24wKTt0aGlzW2hdLmF0dHJpYnV0ZXMuYV9jbGlwVVY9S319Z2V0UG9pbnRBdExlbmd0aChOKXtyZXR1cm4gT2JqZWN0KGcuZ2V0UG9pbnRBdExlbmd0aCkodGhpc1tiXSxOKX1nZXRUb3RhbExlbmd0aCgpe3JldHVybiBPYmplY3QoZy5nZXRUb3RhbExlbmd0aCkodGhpc1tiXSl9Z2V0IGJsZW5kKCl7cmV0dXJuIHRoaXNbal09PW51bGw/ImF1dG8iOnRoaXNbal19c2V0IGJsZW5kKE4pe3RoaXNbal09Tix0aGlzW2hdJiYodGhpc1toXS5lbmFibGVCbGVuZD10aGlzLmVuYWJsZUJsZW5kKX1nZXQgYm91bmRpbmdCb3goKXtpZih0aGlzW2hdJiZ0aGlzW2hdLmJvdW5kaW5nQm94KXJldHVybiB0aGlzW2hdLmJvdW5kaW5nQm94O2NvbnN0IE49dGhpcy5tZXNoRGF0YTtpZihOKXtjb25zdCB6PU4ucG9zaXRpb24wO2lmKHoubGVuZ3RoKU4uYm91bmRpbmdCb3g9cygpKHopO2Vsc2UgcmV0dXJuW1swLDBdLFswLDBdXTtyZXR1cm4gTi5ib3VuZGluZ0JveH1yZXR1cm5bWzAsMF0sWzAsMF1dfWdldCBib3VuZGluZ0NlbnRlcigpe2NvbnN0IE49dGhpcy5ib3VuZGluZ0JveDtyZXR1cm4gTj9bLjUqKE5bMF1bMF0rTlsxXVswXSksLjUqKE5bMF1bMV0rTlsxXVsxXSldOlswLDBdfWdldCBmaWxsUnVsZSgpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ucnVsZToibm9uemVybyJ9Z2V0IGxpbmVXaWR0aCgpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ubGluZVdpZHRoOjB9Z2V0IGxpbmVDYXAoKXtyZXR1cm4gdGhpc1tFXT90aGlzW0VdLmxpbmVDYXA6IiJ9Z2V0IGxpbmVKb2luKCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5saW5lSm9pbjoiIn1nZXQgbWl0ZXJMaW1pdCgpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ubWl0ZXJMaW1pdDowfWdldCBzdHJva2VTdHlsZSgpe3JldHVybiB0aGlzW0xdJiZ0aGlzW0xdWzNdIT09MD9PYmplY3Qoby5kZWZhdWx0KSh0aGlzW0xdKToiIn1nZXQgbGluZURhc2goKXtyZXR1cm4gdGhpc1tFXT90aGlzW0VdLmxpbmVEYXNoOm51bGx9Z2V0IGxpbmVEYXNoT2Zmc2V0KCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5saW5lRGFzaE9mZnNldDowfWdldCBmaWxsU3R5bGUoKXtyZXR1cm4gdGhpc1tTXSYmdGhpc1tTXVszXSE9PTA/T2JqZWN0KG8uZGVmYXVsdCkodGhpc1tTXSk6IiJ9Z2V0IGdyYWRpZW50KCl7cmV0dXJuIHRoaXNbRl19Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tSXS51X3RleFNhbXBsZXI/e2ltYWdlOnRoaXNbUl0udV90ZXhTYW1wbGVyLl9pbWcsb3B0aW9uczp0aGlzW0NdfTpudWxsfWdldCBlbmFibGVCbGVuZCgpe3JldHVybiB0aGlzW2pdPT09ITB8fHRoaXNbal09PT0hMT90aGlzW2pdOnRoaXNbWl08MXx8dGhpc1tMXSE9bnVsbCYmdGhpc1tMXVszXTwxfHx0aGlzW1NdIT1udWxsJiZ0aGlzW1NdWzNdPDF8fHRoaXNbUl0udV9jb2xvck1hdHJpeCE9bnVsbCYmdGhpc1tSXS51X2NvbG9yTWF0cml4WzE4XTwxfHx0aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IhPW51bGx8fHRoaXMuYmVmb3JlUmVuZGVyfHx0aGlzLmFmdGVyUmVuZGVyfWdldCBmaWx0ZXJDYW52YXMoKXtyZXR1cm4vYmx1cnxkcm9wLXNoYWRvd3x1cmwvLnRlc3QodGhpcy5maWx0ZXIpfWdldCBmaWx0ZXIoKXtyZXR1cm4gdGhpc1tHXS5qb2luKCIgIil9Z2V0IHRyYW5zZm9ybU1hdHJpeCgpe3JldHVybiB0aGlzW0ldfWdldCBpbnZlcnRNYXRyaXgoKXtpZighdGhpc1tEXSl7Y29uc3QgTj1yLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpc1tJXSk7dGhpc1tEXT1OfXJldHVybiB0aGlzW0RdfWdldCB0cmFuc2Zvcm1TY2FsZSgpe2NvbnN0IE49dGhpc1tJXTtyZXR1cm4gTWF0aC5tYXgoTWF0aC5oeXBvdChOWzBdLE5bMV0pLE1hdGguaHlwb3QoTlsyXSxOWzNdKSl9Z2V0IHVuaWZvcm1zKCl7cmV0dXJuIHRoaXNbUl19Z2V0IHBhc3MoKXtyZXR1cm4gdGhpc1tpdF19W3FdKE4pe2NvbnN0IHo9dGhpc1tldF0scD10aGlzW2hdLnBvc2l0aW9uMCxNPU9iamVjdC5lbnRyaWVzKE4uX2F0dHJpYnV0ZSk7Zm9yKGxldCB3PTA7dzxNLmxlbmd0aDt3Kyspe2NvbnN0W1UsS109TVt3XTtpZihVIT09ImFfY29sb3IiJiZVIT09ImFfc291cmNlUmVjdCImJkshPT0iaWdub3JlZCIpe2NvbnN0IFk9eltVXTtpZihVPT09InV2IiYmIVkpe2NvbnN0IFE9dGhpc1toXS5ib3VuZGluZ0JveHx8cygpKHApO3RoaXNbaF0uYXR0cmlidXRlc1tVXT1mdChRLHApfWVsc2V7dGhpc1toXS5hdHRyaWJ1dGVzW1VdPVtdO2ZvcihsZXQgUT0wO1E8cC5sZW5ndGg7USsrKXtjb25zdCBydD1wW1FdO3RoaXNbaF0uYXR0cmlidXRlc1tVXS5wdXNoKFk/WShydCx3LHApOkFycmF5KEsuc2l6ZSkuZmlsbCgwKSl9fX19fWdldCBtZXNoRGF0YSgpe2lmKHRoaXMuX3VwZGF0ZU1hdHJpeCYmdGhpcy50cmFuc2Zvcm1TY2FsZS90aGlzLmNvbnRvdXJzLnNjYWxlPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKSwhdGhpc1toXSl7IXRoaXNbQV0mJiF0aGlzW0VdJiZ0aGlzLnNldEZpbGwoKTtjb25zdCBOPXRoaXNbYl0sej17fTtpZihOJiZOLmxlbmd0aCl7aWYodGhpc1tBXSl0cnl7Y29uc3Qgdz1tKCkoTix0aGlzW0FdKTt3LnBvc2l0aW9ucz13LnBvc2l0aW9ucy5tYXAoVT0+KFUucHVzaCh0aGlzW1pdKSxVKSksdy5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDp3LnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbU10ubWFwKFU9Pk1hdGgucm91bmQoMjU1KlUpKSl9LHouZmlsbD13fWNhdGNoe31pZih0aGlzW0VdKXtjb25zdCB3PXRoaXNbRV0ubGluZURhc2g7bGV0IFU9TjtpZih3KXtjb25zdCBZPXRoaXNbRV0ubGluZURhc2hPZmZzZXQ7VT1PYmplY3QoZy5nZXREYXNoQ29udG91cnMpKE4sdyxZKX1jb25zdCBLPVUubWFwKChZLFEpPT57Y29uc3QgcnQ9WS5sZW5ndGg+MSYmci52ZWMyLmVxdWFscyhZWzBdLFlbWS5sZW5ndGgtMV0pLG50PXRoaXNbRV0uYnVpbGQoWSxydCk7cmV0dXJuIG0oKShbbnRdKX0pO0suZm9yRWFjaChZPT57WS5wb3NpdGlvbnM9WS5wb3NpdGlvbnMubWFwKFE9PihRLnB1c2goLXRoaXNbWl0pLFEpKSxZLmF0dHJpYnV0ZXM9e2FfY29sb3I6QXJyYXkuZnJvbSh7bGVuZ3RoOlkucG9zaXRpb25zLmxlbmd0aH0pLm1hcCgoKT0+dGhpc1tMXS5tYXAoUT0+TWF0aC5yb3VuZCgyNTUqUSkpKX19KSx6LnN0cm9rZT1PYmplY3QoYy5kZWZhdWx0KShLKX19Y29uc3QgcD1PYmplY3QoYy5kZWZhdWx0KShbei5maWxsLHouc3Ryb2tlXSk7cC5maWxsUG9pbnRDb3VudD16LmZpbGw/ei5maWxsLnBvc2l0aW9ucy5sZW5ndGg6MCxwLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQscC5wb3NpdGlvbjA9cC5wb3NpdGlvbnMubWFwKChbdyxVLEtdKT0+W3csVSxLXSkscC51bmlmb3Jtcz10aGlzW1JdLHRoaXNbaF09cCx0aGlzW1JdLnVfdGV4U2FtcGxlciYmdGhpc1skXShwLHRoaXNbQ10pO2NvbnN0IE09dGhpc1tJXTtPYmplY3QoeC5pc1VuaXRUcmFuc2Zvcm0pKE0pfHwodGhpc1tIXShwLE0pLHRoaXNbUl0udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1tKXSgpKSx0aGlzLmNsaXBQYXRoJiZ0aGlzW2h0XSgpLHRoaXNbdHRdJiZ0aGlzW3FdKHRoaXNbdHRdKX1yZXR1cm4gdGhpcy5fdXBkYXRlTWF0cml4JiYodGhpc1toXS5tYXRyaXg9dGhpc1tJXSx0aGlzW0hdKHRoaXNbaF0sdGhpc1tJXSksdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW0pdKCkpLHRoaXNbaF19W0hdKE4seil7Y29uc3R7cG9zaXRpb25zOnAscG9zaXRpb24wOk19PU47Zm9yKGxldCB3PTA7dzxwLmxlbmd0aDt3Kyspe2NvbnN0W1UsS109TVt3XSxZPXBbd107WVswXT1VKnpbMF0rSyp6WzJdK3pbNF0sWVsxXT1VKnpbMV0rSyp6WzNdK3pbNV19dGhpcy5fdXBkYXRlTWF0cml4PSExfVtKXSgpe2NvbnN0IE49dGhpc1tJXSx6PVsuLi50aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcl07aWYoeil7Y29uc3RbcCxNLCx3LFVdPXo7elswXT1wKk5bMF0rTSpOWzJdK05bNF0selsxXT1wKk5bMV0rTSpOWzNdK05bNV0selszXT13Kk5bMF0rVSpOWzJdK05bNF0sels0XT13Kk5bMV0rVSpOWzNdK05bNV0sdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPXp9fVskXShOLHope2Z1bmN0aW9uIHAoUSxydCl7cmV0dXJuIFE9PW51bGwmJnJ0PT1udWxsPyEwOlE9PW51bGx8fHJ0PT1udWxsPyExOlFbMF09PT1ydFswXSYmUVsxXT09PXJ0WzFdJiZRWzJdPT09cnRbMl0mJlFbM109PT1ydFszXX1jb25zdCBNPXRoaXNbUl0udV90ZXhTYW1wbGVyO2lmKCFNKXJldHVybjtjb25zdHt3aWR0aDp3LGhlaWdodDpVfT1NLl9pbWcsSz16LnNyY1JlY3Q7bGV0IFk9ei5yZWN0fHxbMCwwXTtpZih6LnJvdGF0ZWQmJihZPVstWVsxXSxZWzBdLFlbM10sWVsyXV0pLFlbMl09PW51bGwmJihZWzJdPUs/S1syXTp3KSxZWzNdPT1udWxsJiYoWVszXT1LP0tbM106VSksei5oaWRkZW4pTi50ZXh0dXJlQ29vcmQ9Ti5wb3NpdGlvbnMubWFwKCgpPT5bLTEsLTEsLTFdKTtlbHNlIGlmKCFOLnRleHR1cmVDb29yZHx8IXAodGhpc1tDXS5yZWN0LHoucmVjdCl8fHRoaXNbQ10uaGlkZGVuIT09ei5oaWRkZW58fHRoaXNbQ10ucm90YXRlZCE9PXoucm90YXRlZCl7bGV0IFE9bnVsbDt6LnJvdGF0ZWQmJihRPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxyLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLC41Kk1hdGguUEkpLFE9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFEsWzAsLVlbMl1dKSksTi50ZXh0dXJlQ29vcmQ9Ti5wb3NpdGlvbjAubWFwKChbcnQsbnQsYXRdKT0+e2lmKDEvYXQ+MCl7aWYoei5yb3RhdGVkKXtjb25zdCBvdD1ydCpRWzBdK250KlFbMl0rUVs0XSxzdD1ydCpRWzFdK250KlFbM10rUVs1XTtbcnQsbnRdPVtvdCxzdF19Y29uc3QgY3Q9QihbcnQsbnRdLFtZWzBdL1lbMl0sWVsxXS9ZWzNdLFlbMl0sWVszXV0seik7cmV0dXJuIHoucmVwZWF0JiYoY3RbMl09MSksY3R9cmV0dXJuWy0xLC0xLC0xXX0pfWlmKEspe2NvbnN0IFE9W0tbMF0vdyxLWzFdL1UsS1syXS93LEtbM10vVV07Ti5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1OLnBvc2l0aW9ucy5tYXAoKCk9PlsuLi5RXSl9ZWxzZSBOLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0PU4ucG9zaXRpb25zLm1hcCgoKT0+WzAsMCwwLDBdKX1hY2N1cmF0ZShOKXtpZighdGhpcy5jb250b3VycylyZXR1cm47aWYodGhpcy5jb250b3Vycy5wYXRoKXtjb25zdCBwPXRoaXMuY29udG91cnMuc2ltcGxpZnksTT1XKHRoaXMuY29udG91cnMucGF0aCwyKk4scCk7dGhpc1toXT1udWxsLHRoaXNbYl09TX19Y2FuSWdub3JlKCl7Y29uc3QgTj10aGlzW0VdPT1udWxsfHx0aGlzW0VdLmxpbmVXaWR0aD09PTB8fHRoaXNbTF1bM109PT0wLHo9dGhpc1tBXT09bnVsbHx8dGhpc1tTXVszXT09PTAscD10aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3I9PW51bGwsTT10aGlzW1JdLnVfdGV4U2FtcGxlcj09bnVsbDtyZXR1cm4gdGhpc1taXT09PTB8fHRoaXNbdHRdPT1udWxsJiZOJiZ6JiZwJiZNJiYhdGhpcy5iZWZvcmVSZW5kZXImJiF0aGlzLmFmdGVyUmVuZGVyfXNldFN0cm9rZSh7dGhpY2tuZXNzOk49MSxjYXA6ej0iYnV0dCIsam9pbjpwPSJtaXRlciIsbWl0ZXJMaW1pdDpNPTEwLGNvbG9yOnc9WzAsMCwwLDBdLGxpbmVEYXNoOlU9bnVsbCxsaW5lRGFzaE9mZnNldDpLPTAscm91bmRTZWdtZW50czpZPTIwfT17fSl7cmV0dXJuIHRoaXNbaF09bnVsbCx0aGlzW0VdPW5ldyBsLmRlZmF1bHQoe2xpbmVXaWR0aDpOLGxpbmVDYXA6eixsaW5lSm9pbjpwLG1pdGVyTGltaXQ6TSxyb3VuZFNlZ21lbnRzOll9KSx0eXBlb2Ygdz09InN0cmluZyImJih3PU9iamVjdCh2LmRlZmF1bHQpKHcpKSx0aGlzW0xdPXcsdGhpc1tFXS5saW5lRGFzaD1VLHRoaXNbRV0ubGluZURhc2hPZmZzZXQ9Syx0aGlzfXNldEZpbGwoe3J1bGU6Tj10aGlzLmZpbGxSdWxlLGNvbG9yOno9WzAsMCwwLDBdfT17fSl7cmV0dXJuIHRoaXNbaF09bnVsbCx0aGlzW0FdPXtydWxlOk59LHR5cGVvZiB6PT0ic3RyaW5nIiYmKHo9T2JqZWN0KHYuZGVmYXVsdCkoeikpLHRoaXNbU109eix0aGlzfXNldFRleHR1cmUoTix6PXt9KXtpZihOJiZOLmltYWdlKXtjb25zdHtpbWFnZTpwLHJlY3Q6TX09TjtpZihOPXAsei5yZWN0KWZvcihsZXQgdz0wO3c8ei5yZWN0Lmxlbmd0aDt3KyspTVt3XT16LnJlY3Rbd107ei5yZWN0PU19cmV0dXJuIHRoaXNbQV18fHRoaXMuc2V0RmlsbCgpLHRoaXMuc2V0VW5pZm9ybXMoe3VfdGV4U2FtcGxlcjpOfSksdGhpc1toXSYmdGhpc1skXSh0aGlzW2hdLHopLHRoaXNbQ109eix0aGlzfXNldENpcmN1bGFyR3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczp6LHR5cGU6cD0iZmlsbCJ9PXt9KXtpZihOLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6eix0eXBlOnB9KX1zZXRMaW5lYXJHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOnosdHlwZTpwPSJmaWxsIn09e30pe2lmKE4ubGVuZ3RoIT09NCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVhckdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczp6LHR5cGU6cH0pfXNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6eix0eXBlOnA9ImZpbGwifT17fSl7aWYoTi5sZW5ndGghPT02KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcmFkaWFsR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOnosdHlwZTpwfSl9c2V0R3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczp6LHR5cGU6cD0iZmlsbCJ9PXt9KXt6PXoubWFwKCh7b2Zmc2V0OlUsY29sb3I6S30pPT4odHlwZW9mIEs9PSJzdHJpbmciJiYoSz1PYmplY3Qodi5kZWZhdWx0KShLKSkse29mZnNldDpVLGNvbG9yOkt9KSksdGhpc1tGXT10aGlzW0ZdfHx7fSx0aGlzW0ZdW3BdPXt2ZWN0b3I6Tixjb2xvcnM6en0sei5zb3J0KChVLEspPT5VLm9mZnNldC1LLm9mZnNldCk7Y29uc3QgTT1bXTt6LmZvckVhY2goKHtvZmZzZXQ6VSxjb2xvcjpLfSk9PntNLnB1c2goVSwuLi5LKX0pO2xldCB3O2lmKE4ubGVuZ3RoPT09ND93PVtOWzBdLE5bMV0sMCxOWzJdLE5bM10sMF06dz1bLi4uTl0sTS5sZW5ndGg8NDAmJk0ucHVzaCgtMSksTS5sZW5ndGg+NDApdGhyb3cgbmV3IEVycm9yKCJUb28gbWFueSBjb2xvcnMsIHNob3VsZCBiZSBsZXNzIHRoYW4gOCBjb2xvcnMiKTtyZXR1cm4gdGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3I9dyx0aGlzW1JdLnVfY29sb3JTdGVwcz1NLHA9PT0iZmlsbCI/dGhpc1tSXS51X2dyYWRpZW50VHlwZT0xOnRoaXNbUl0udV9ncmFkaWVudFR5cGU9MCx0aGlzW0pdKCksdGhpc31zZXRVbmlmb3JtcyhOPXt9KXtyZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzW1JdLE4pLHRoaXN9c2V0VHJhbnNmb3JtKC4uLk4pe2NvbnN0IHo9dGhpc1tJXTtyZXR1cm4gci5tYXQyZC5lcXVhbHMoTix6KXx8KHRoaXNbSV09TixkZWxldGUgdGhpc1tEXSx0aGlzLl91cGRhdGVNYXRyaXg9ITApLHRoaXN9dHJhbnNmb3JtKC4uLk4pe2NvbnN0IHo9dGhpc1tJXTtyZXR1cm4gdGhpc1tJXT1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx6LE4pLGRlbGV0ZSB0aGlzW0RdLHRoaXMuX3VwZGF0ZU1hdHJpeD0hMCx0aGlzfXRyYW5zbGF0ZShOLHope2xldCBwPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIHA9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHAsW04sel0pLHRoaXMudHJhbnNmb3JtKC4uLnApfXJvdGF0ZShOLFt6LHBdPVswLDBdKXtsZXQgTT1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBNPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxNLFt6LHBdKSxNPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxNLE4pLE09ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE0sWy16LC1wXSksdGhpcy50cmFuc2Zvcm0oLi4uTSl9c2NhbGUoTix6PU4sW3AsTV09WzAsMF0pe2xldCB3PXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIHc9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsW3AsTV0pLHc9ci5tYXQyZC5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCksdyxbTix6XSksdz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksdyxbLXAsLU1dKSx0aGlzLnRyYW5zZm9ybSguLi53KX1za2V3KE4sej1OLFtwLE1dPVswLDBdKXtsZXQgdz1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiB3PXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx3LFtwLE1dKSx3PXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oeiksTWF0aC50YW4oTiksMSwwLDApKSx3PXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx3LFstcCwtTV0pLHRoaXMudHJhbnNmb3JtKC4uLncpfWNsZWFyRmlsdGVyKCl7cmV0dXJuIHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0obnVsbCksdGhpc1tHXS5sZW5ndGg9MCx0aGlzfXNldENvbG9yVHJhbnNmb3JtKC4uLk4pe3JldHVybiBOWzBdPT09bnVsbD90aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MCx1X2NvbG9yTWF0cml4OjB9KTp0aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MSx1X2NvbG9yTWF0cml4Ok59KSx0aGlzfXRyYW5zZm9ybUNvbG9yKC4uLk4pe2xldCB6PXRoaXMudW5pZm9ybXMudV9jb2xvck1hdHJpeDtyZXR1cm4gej96PU9iamVjdChmLm11bHRpcGx5KSh6LE4pOno9Tix0aGlzLnNldENvbG9yVHJhbnNmb3JtKC4uLnopLHRoaXN9Ymx1cihOKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBibHVyKCR7Tn1weClgKSx0aGlzfWJyaWdodG5lc3MoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBicmlnaHRuZXNzKCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLmJyaWdodG5lc3MpKE4pKX1jb250cmFzdChOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYGNvbnRyYXN0KCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLmNvbnRyYXN0KShOKSl9ZHJvcFNoYWRvdyhOLHoscD0wLE09WzAsMCwwLDFdKXtyZXR1cm4gQXJyYXkuaXNBcnJheShNKSYmKE09T2JqZWN0KG8uZGVmYXVsdCkoTSkpLHRoaXNbR10ucHVzaChgZHJvcC1zaGFkb3coJHtOfXB4ICR7en1weCAke3B9cHggJHtNfSlgKSx0aGlzfWdyYXlzY2FsZShOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYGdyYXlzY2FsZSgkezEwMCpOfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5ncmF5c2NhbGUpKE4pKX1odWVSb3RhdGUoTj0wKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBodWUtcm90YXRlKCR7Tn1kZWcpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5odWVSb3RhdGUpKE4pKX1pbnZlcnQoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBpbnZlcnQoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuaW52ZXJ0KShOKSl9b3BhY2l0eShOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYG9wYWNpdHkoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYub3BhY2l0eSkoTikpfXNhdHVyYXRlKE49MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgc2F0dXJhdGUoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuc2F0dXJhdGUpKE4pKX1zZXBpYShOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYHNlcGlhKCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLnNlcGlhKShOKSl9dXJsKE4pe3JldHVybiB0aGlzW0ddLnB1c2goYHVybCgke059KWApLHRoaXN9aXNQb2ludENvbGxpc2lvbihOLHoscD0iYm90aCIpe2NvbnN0IE09dGhpcy5tZXNoRGF0YSx7cG9zaXRpb25zOncsY2VsbHM6VX09TSxLPXRoaXMuaW52ZXJ0TWF0cml4LFk9S1swXSpOK0tbMl0qeitLWzRdLFE9S1sxXSpOK0tbM10qeitLWzVdLHJ0PXRoaXMuYm91bmRpbmdCb3g7aWYoWTxydFswXVswXXx8WT5ydFsxXVswXXx8UTxydFswXVsxXXx8UT5ydFsxXVsxXSlyZXR1cm4hMTtmdW5jdGlvbiBudChbYXQsY3RdLFtvdCxzdF0sW2x0LG10XSl7Y29uc3QgcHQ9bHQtb3QsZHQ9bXQtc3QseXQ9KChhdC1vdCkqcHQrKGN0LXN0KSpkdCkvKHB0KioyK2R0KioyKTtyZXR1cm4geXQ+PTAmJnl0PD0xfWZvcihsZXQgYXQ9MDthdDxVLmxlbmd0aDthdCsrKXtjb25zdCBjdD1VW2F0XTtpZihwPT09ImZpbGwiJiZjdFswXT49TS5maWxsUG9pbnRDb3VudClicmVhaztpZihwPT09InN0cm9rZSImJmN0WzBdPE0uZmlsbFBvaW50Q291bnQpY29udGludWU7Y29uc3RbW290LHN0XSxbbHQsbXRdLFtwdCxkdF1dPWN0Lm1hcChNdD0+d1tNdF0pLHl0PU1hdGguc2lnbigoTi1vdCkqKG10LXN0KS0obHQtb3QpKih6LXN0KSk7aWYoeXQ9PT0wJiZudChbTix6XSxbb3Qsc3RdLFtsdCxtdF0pKXJldHVybiEwO2NvbnN0IEF0PU1hdGguc2lnbigoTi1sdCkqKGR0LW10KS0ocHQtbHQpKih6LW10KSk7aWYoQXQ9PT0wJiZudChbTix6XSxbbHQsbXRdLFtwdCxkdF0pKXJldHVybiEwO2NvbnN0IFN0PU1hdGguc2lnbigoTi1wdCkqKHN0LWR0KS0ob3QtcHQpKih6LWR0KSk7aWYoU3Q9PT0wJiZudChbTix6XSxbcHQsZHRdLFtvdCxzdF0pfHx5dD09PTEmJkF0PT09MSYmU3Q9PT0xfHx5dD09PS0xJiZBdD09PS0xJiZTdD09PS0xKXJldHVybiEwfXJldHVybiExfWlzUG9pbnRJbkZpbGwoTix6KXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKE4seiwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShOLHope3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oTix6LCJzdHJva2UiKX1hZGRQYXNzKE4sej17fSl7bGV0e3dpZHRoOnAsaGVpZ2h0Ok19PXosdz11KHosWyJ3aWR0aCIsImhlaWdodCJdKTtjb25zdCBVPW5ldyBQLmRlZmF1bHQ7VS5yZWN0KDAsMCxwLE0pO2NvbnN0IEs9bmV3IFYoVSx7d2lkdGg6cCxoZWlnaHQ6TX0pO0suc2V0VW5pZm9ybXModyksSy5zZXRQcm9ncmFtKE4pLHRoaXNbaXRdLnB1c2goSyl9fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKTt2YXIgcj10KDU4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuU3Ryb2tlfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJTdHJva2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDQ5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj1PYmplY3Qoci5jcmVhdGUpKCkscz1PYmplY3Qoci5jcmVhdGUpKCksbD1PYmplY3Qoci5jcmVhdGUpKCksYz1PYmplY3Qoci5jcmVhdGUpKCksbz1PYmplY3Qoci5jcmVhdGUpKCksZj0xZTIwO2NsYXNzIHh7Y29uc3RydWN0b3Ioe2xpbmVXaWR0aDpPPTEsbGluZUpvaW46dj0ibWl0ZXIiLG1pdGVyTGltaXQ6UD0xMCxsaW5lQ2FwOmk9ImJ1dHQiLHJvdW5kU2VnbWVudHM6dT0yMH09e30pe3RoaXMubGluZVdpZHRoPU8sdGhpcy5saW5lSm9pbj12LHRoaXMubWl0ZXJMaW1pdD1QLHRoaXMubGluZUNhcD1pLHRoaXMucm91bmRTZWdtZW50cz11LHRoaXMuX25vcm1hbD1udWxsfWJ1aWxkKE8sdj0hMSl7bGV0IFA9Ty5sZW5ndGg7aWYoTz1bLi4uT10sUDwyKXJldHVybiBPO3YmJigoT1swXVswXSE9PU9bUC0xXVswXXx8T1swXVsxXSE9PU9bUC0xXVsxXSkmJk8ucHVzaChbLi4uT1swXV0pLE8ucHVzaChbLi4uT1sxXV0pKSxQPU8ubGVuZ3RoLHRoaXMuX25vcm1hbD1udWxsO2NvbnN0IGk9e2xlZnQ6W10scmlnaHQ6W119LHU9dGhpcy5saW5lV2lkdGgvMixhPXRoaXMubGluZUNhcDtpZighdiYmYT09PSJzcXVhcmUiKXtPYmplY3Qoci5kaXJlY3Rpb24pKHMsT1swXSxPWzFdKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkoT1swXSxPWzBdLHMsdSk7Y29uc3QgYj1PLmxlbmd0aC0xO09iamVjdChyLmRpcmVjdGlvbikocyxPW2JdLE9bYi0xXSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKE9bYl0sT1tiXSxzLHUpfWZvcihsZXQgYj0xO2I8UDtiKyspe2NvbnN0IEU9T1tiLTFdLEE9T1tiXSxMPU9bYisxXTt0aGlzLl9zZWcoaSxFLEEsTCx1LHYpfXJldHVybiF2JiZhPT09InJvdW5kIiYmbShpLHRoaXMucm91bmRTZWdtZW50cyksWy4uLmkubGVmdCwuLi5pLnJpZ2h0LnJldmVyc2UoKV19X3NlZyhPLHYsUCxpLHUsYSl7Y29uc3QgaD10aGlzLmxpbmVKb2luPT09ImJldmVsIixiPXRoaXMubGluZUpvaW49PT0icm91bmQiO2lmKE9iamVjdChyLmRpcmVjdGlvbikocyxQLHYpLHRoaXMuX25vcm1hbHx8KHRoaXMuX25vcm1hbD1PYmplY3Qoci5jcmVhdGUpKCksT2JqZWN0KHIubm9ybWFsKSh0aGlzLl9ub3JtYWwscykpLE8ubGVmdC5sZW5ndGh8fHkoTyx2LHRoaXMuX25vcm1hbCx1KSwhaSlPYmplY3Qoci5ub3JtYWwpKHRoaXMuX25vcm1hbCxzKSxhP3koTyx2LHRoaXMuX25vcm1hbCx1KTp5KE8sUCx0aGlzLl9ub3JtYWwsdSk7ZWxzZXtPYmplY3Qoci5kaXJlY3Rpb24pKGwsaSxQKTtsZXQgRT1PYmplY3Qoci5jb21wdXRlTWl0ZXIpKGMsbyxzLGwsdSk7RT1NYXRoLm1pbihFLGYpO2NvbnN0IEE9T2JqZWN0KHIuZG90KShjLHRoaXMuX25vcm1hbCk8MD8tMToxO2xldCBMPWh8fGI7aWYoIUwmJnRoaXMubGluZUpvaW49PT0ibWl0ZXIiJiZFL3U+dGhpcy5taXRlckxpbWl0JiYoTD0hMCksTCl7T2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4sUCx0aGlzLl9ub3JtYWwsLXUqQSksZyhPLG4sQSk7bGV0IFM9MS8wO3YmJihTPU1hdGgubWluKFMsTWF0aC5oeXBvdChQWzBdLXZbMF0sUFsxXS12WzFdKSkpLGkmJihTPU1hdGgubWluKFMsTWF0aC5oeXBvdChpWzBdLVBbMF0saVsxXS1QWzFdKSkpO2NvbnN0IEk9TWF0aC5tYXgodSxNYXRoLm1pbihFLFMpKTtpZihPYmplY3Qoci5zY2FsZUFuZEFkZCkobixQLG8sSSpBKSxnKE8sbiwtQSksaSlpZihPYmplY3Qoci5ub3JtYWwpKG4sbCksT2JqZWN0KHIuY29weSkodGhpcy5fbm9ybWFsLG4pLE9iamVjdChyLnNjYWxlQW5kQWRkKShuLFAsbiwtdSpBKSxiKXtjb25zdCBEPU9iamVjdChyLmNsb25lKShuKSxSPUE+MD9PLmxlZnRbTy5sZWZ0Lmxlbmd0aC0xXTpPLnJpZ2h0W08ucmlnaHQubGVuZ3RoLTFdLEM9T2JqZWN0KHIuY2xvbmUpKFApLGo9T2JqZWN0KHIuc3ViKShPYmplY3Qoci5jcmVhdGUpKCksUixDKSwkPU9iamVjdChyLnN1YikoT2JqZWN0KHIuY3JlYXRlKSgpLEQsQyksSD1NYXRoLlBJL3RoaXMucm91bmRTZWdtZW50cztmb3IobGV0IEo9MDtKPHRoaXMucm91bmRTZWdtZW50cyYmKE9iamVjdChyLnJvdGF0ZSkoaixqLFswLDBdLEEqSCksTWF0aC5zaWduKE9iamVjdChyLmNyb3NzKShuLGosJClbMl0pPT09QSk7SisrKU9iamVjdChyLmFkZCkobixqLEMpLGcoTyxuLEEpO2coTyxELEEpfWVsc2UgZyhPLG4sQSl9ZWxzZSB5KE8sUCxvLEUpLE9iamVjdChyLmNvcHkpKHRoaXMuX25vcm1hbCxvKX19fWZ1bmN0aW9uIGcoVCxPLHYpe3Y+MD9ULmxlZnQucHVzaChPYmplY3Qoci5jbG9uZSkoTykpOlQucmlnaHQucHVzaChPYmplY3Qoci5jbG9uZSkoTykpfWZ1bmN0aW9uIHkoVCxPLHYsUCxpPS0xKXtPYmplY3Qoci5zY2FsZUFuZEFkZCkobixPLHYsLVApLGcoVCxuLC1pKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkobixPLHYsUCksZyhULG4saSl9ZnVuY3Rpb24gbSh7bGVmdDpULHJpZ2h0Ok99LHYpe2NvbnN0IFA9T2JqZWN0KHIuY3JlYXRlKSgpLGk9T2JqZWN0KHIuY3JlYXRlKSgpO2xldCB1PVRbMF0sYT1PWzBdLGg9Wy41Kih1WzBdK2FbMF0pLC41Kih1WzFdK2FbMV0pXTtPYmplY3Qoci5zdWIpKGksdSxoKTtmb3IobGV0IGI9MTtiPD12O2IrKyl7Y29uc3QgRT0tMSpNYXRoLlBJKmIvdjtPYmplY3Qoci5yb3RhdGUpKFAsaSxbMCwwXSxFKSxPYmplY3Qoci5hZGQpKG4saCxQKSxULnVuc2hpZnQoT2JqZWN0KHIuY2xvbmUpKG4pKX11PU9bTy5sZW5ndGgtMV0sYT1UW1QubGVuZ3RoLTFdLGg9Wy41Kih1WzBdK2FbMF0pLC41Kih1WzFdK2FbMV0pXSxPYmplY3Qoci5zdWIpKGksdSxoKTtmb3IobGV0IGI9MTtiPD12O2IrKyl7Y29uc3QgRT0tMSpNYXRoLlBJKmIvdjtPYmplY3Qoci5yb3RhdGUpKFAsaSxbMCwwXSxFKSxPYmplY3Qoci5hZGQpKG4saCxQKSxPLnB1c2goT2JqZWN0KHIuY2xvbmUpKG4pKX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJpc1VuaXRUcmFuc2Zvcm0iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihuKXtyZXR1cm4gblswXT09PTEmJm5bMV09PT0wJiZuWzJdPT09MCYmblszXT09PTEmJm5bNF09PT0wJiZuWzVdPT09MH19LGZ1bmN0aW9uKGQsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9dCg2MSksbj10KDYyKTtkLmV4cG9ydHM9ZnVuY3Rpb24ocyxsKXtpZihsPWx8fHt9LHM9cy5maWx0ZXIoZnVuY3Rpb24odil7cmV0dXJuIHYubGVuZ3RoPjJ9KSxzLmxlbmd0aD09PTApcmV0dXJue3Bvc2l0aW9uczpbXSxjZWxsczpbXX07dHlwZW9mIGwudmVydGV4U2l6ZSE9Im51bWJlciImJihsLnZlcnRleFNpemU9c1swXVswXS5sZW5ndGgpLHM9cy5tYXAoZnVuY3Rpb24odil7cmV0dXJuIHYucmVkdWNlKGZ1bmN0aW9uKFAsaSl7cmV0dXJuIFAuY29uY2F0KGkpfSl9KTtjb25zdCBjPWwucnVsZT09PSJldmVub2RkIj9yLldJTkRJTkdfT0REOnIuV0lORElOR19OT05aRVJPO2Zvcih2YXIgbz1yLnRlc3NlbGF0ZShuKHtjb250b3VyczpzLHdpbmRpbmdSdWxlOmMsZWxlbWVudFR5cGU6ci5QT0xZR09OUyxwb2x5U2l6ZTozLHZlcnRleFNpemU6Mn0sbCkpLGY9W10seD0wO3g8by52ZXJ0aWNlcy5sZW5ndGg7eCs9bC52ZXJ0ZXhTaXplKXt2YXIgZz1vLnZlcnRpY2VzLnNsaWNlKHgseCtsLnZlcnRleFNpemUpO2YucHVzaChnKX12YXIgeT1bXTtmb3IoeD0wO3g8by5lbGVtZW50cy5sZW5ndGg7eCs9Myl7dmFyIG09by5lbGVtZW50c1t4XSxUPW8uZWxlbWVudHNbeCsxXSxPPW8uZWxlbWVudHNbeCsyXTt5LnB1c2goW20sVCxPXSl9cmV0dXJue3Bvc2l0aW9uczpmLGNlbGxzOnl9fX0sZnVuY3Rpb24oZCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj17fSxuPXt9O2QuZXhwb3J0cz1yLHIuV0lORElOR19PREQ9MCxyLldJTkRJTkdfTk9OWkVSTz0xLHIuV0lORElOR19QT1NJVElWRT0yLHIuV0lORElOR19ORUdBVElWRT0zLHIuV0lORElOR19BQlNfR0VRX1RXTz00LHIuUE9MWUdPTlM9MCxyLkNPTk5FQ1RFRF9QT0xZR09OUz0xLHIuQk9VTkRBUllfQ09OVE9VUlM9MixyLnRlc3NlbGF0ZT1mdW5jdGlvbihpKXtmb3IodmFyIHU9aS5kZWJ1Z3x8ITEsYT1uZXcgUCxoPTA7aDxpLmNvbnRvdXJzLmxlbmd0aDtoKyspYS5hZGRDb250b3VyKGkudmVydGV4U2l6ZXx8MixpLmNvbnRvdXJzW2hdKTtyZXR1cm4gYS50ZXNzZWxhdGUoaS53aW5kaW5nUnVsZXx8ci5XSU5ESU5HX09ERCxpLmVsZW1lbnRUeXBlfHxyLlBPTFlHT05TLGkucG9seVNpemV8fDMsaS52ZXJ0ZXhTaXplfHwyLGkubm9ybWFsfHxbMCwwLDFdKSx7dmVydGljZXM6YS52ZXJ0aWNlcyx2ZXJ0ZXhJbmRpY2VzOmEudmVydGV4SW5kaWNlcyx2ZXJ0ZXhDb3VudDphLnZlcnRleENvdW50LGVsZW1lbnRzOmEuZWxlbWVudHMsZWxlbWVudENvdW50OmEuZWxlbWVudENvdW50LG1lc2g6dT9hLm1lc2g6dm9pZCAwfX07dmFyIHM9ZnVuY3Rpb24oaSl7aWYoIWkpdGhyb3ciQXNzZXJ0aW9uIEZhaWxlZCEifTtmdW5jdGlvbiBsKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLmNvb3Jkcz1bMCwwLDBdLHRoaXMucz0wLHRoaXMudD0wLHRoaXMucHFIYW5kbGU9MCx0aGlzLm49MCx0aGlzLmlkeD0wfWZ1bmN0aW9uIGMoKXt0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbCx0aGlzLmFuRWRnZT1udWxsLHRoaXMudHJhaWw9bnVsbCx0aGlzLm49MCx0aGlzLm1hcmtlZD0hMSx0aGlzLmluc2lkZT0hMX1mdW5jdGlvbiBvKGkpe3RoaXMubmV4dD1udWxsLHRoaXMuU3ltPW51bGwsdGhpcy5PbmV4dD1udWxsLHRoaXMuTG5leHQ9bnVsbCx0aGlzLk9yZz1udWxsLHRoaXMuTGZhY2U9bnVsbCx0aGlzLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMud2luZGluZz0wLHRoaXMuc2lkZT1pfW8ucHJvdG90eXBlPXtnZXQgUmZhY2UoKXtyZXR1cm4gdGhpcy5TeW0uTGZhY2V9LHNldCBSZmFjZShpKXt0aGlzLlN5bS5MZmFjZT1pfSxnZXQgRHN0KCl7cmV0dXJuIHRoaXMuU3ltLk9yZ30sc2V0IERzdChpKXt0aGlzLlN5bS5Pcmc9aX0sZ2V0IE9wcmV2KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0fSxzZXQgT3ByZXYoaSl7dGhpcy5TeW0uTG5leHQ9aX0sZ2V0IExwcmV2KCl7cmV0dXJuIHRoaXMuT25leHQuU3ltfSxzZXQgTHByZXYoaSl7dGhpcy5PbmV4dC5TeW09aX0sZ2V0IERwcmV2KCl7cmV0dXJuIHRoaXMuTG5leHQuU3ltfSxzZXQgRHByZXYoaSl7dGhpcy5MbmV4dC5TeW09aX0sZ2V0IFJwcmV2KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0fSxzZXQgUnByZXYoaSl7dGhpcy5TeW0uT25leHQ9aX0sZ2V0IERuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0LlN5bX0sc2V0IERuZXh0KGkpe3RoaXMuU3ltLk9uZXh0LlN5bT1pfSxnZXQgUm5leHQoKXtyZXR1cm4gdGhpcy5TeW0uTG5leHQuU3ltfSxzZXQgUm5leHQoaSl7dGhpcy5TeW0uTG5leHQuU3ltPWl9fTtmdW5jdGlvbiBmKCl7dmFyIGk9bmV3IGwsdT1uZXcgYyxhPW5ldyBvKDApLGg9bmV3IG8oMSk7aS5uZXh0PWkucHJldj1pLGkuYW5FZGdlPW51bGwsdS5uZXh0PXUucHJldj11LHUuYW5FZGdlPW51bGwsdS50cmFpbD1udWxsLHUubWFya2VkPSExLHUuaW5zaWRlPSExLGEubmV4dD1hLGEuU3ltPWgsYS5PbmV4dD1udWxsLGEuTG5leHQ9bnVsbCxhLk9yZz1udWxsLGEuTGZhY2U9bnVsbCxhLndpbmRpbmc9MCxhLmFjdGl2ZVJlZ2lvbj1udWxsLGgubmV4dD1oLGguU3ltPWEsaC5PbmV4dD1udWxsLGguTG5leHQ9bnVsbCxoLk9yZz1udWxsLGguTGZhY2U9bnVsbCxoLndpbmRpbmc9MCxoLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMudkhlYWQ9aSx0aGlzLmZIZWFkPXUsdGhpcy5lSGVhZD1hLHRoaXMuZUhlYWRTeW09aH1mLnByb3RvdHlwZT17bWFrZUVkZ2VfOmZ1bmN0aW9uKGkpe3ZhciB1PW5ldyBvKDApLGE9bmV3IG8oMSk7aS5TeW0uc2lkZTxpLnNpZGUmJihpPWkuU3ltKTt2YXIgaD1pLlN5bS5uZXh0O3JldHVybiBhLm5leHQ9aCxoLlN5bS5uZXh0PXUsdS5uZXh0PWksaS5TeW0ubmV4dD1hLHUuU3ltPWEsdS5PbmV4dD11LHUuTG5leHQ9YSx1Lk9yZz1udWxsLHUuTGZhY2U9bnVsbCx1LndpbmRpbmc9MCx1LmFjdGl2ZVJlZ2lvbj1udWxsLGEuU3ltPXUsYS5PbmV4dD1hLGEuTG5leHQ9dSxhLk9yZz1udWxsLGEuTGZhY2U9bnVsbCxhLndpbmRpbmc9MCxhLmFjdGl2ZVJlZ2lvbj1udWxsLHV9LHNwbGljZV86ZnVuY3Rpb24oaSx1KXt2YXIgYT1pLk9uZXh0LGg9dS5PbmV4dDthLlN5bS5MbmV4dD11LGguU3ltLkxuZXh0PWksaS5PbmV4dD1oLHUuT25leHQ9YX0sbWFrZVZlcnRleF86ZnVuY3Rpb24oaSx1LGEpe3ZhciBoPWk7cyhoIT09bnVsbCk7dmFyIGI9YS5wcmV2O2gucHJldj1iLGIubmV4dD1oLGgubmV4dD1hLGEucHJldj1oLGguYW5FZGdlPXU7dmFyIEU9dTtkbyBFLk9yZz1oLEU9RS5PbmV4dDt3aGlsZShFIT09dSl9LG1ha2VGYWNlXzpmdW5jdGlvbihpLHUsYSl7dmFyIGg9aTtzKGghPT1udWxsKTt2YXIgYj1hLnByZXY7aC5wcmV2PWIsYi5uZXh0PWgsaC5uZXh0PWEsYS5wcmV2PWgsaC5hbkVkZ2U9dSxoLnRyYWlsPW51bGwsaC5tYXJrZWQ9ITEsaC5pbnNpZGU9YS5pbnNpZGU7dmFyIEU9dTtkbyBFLkxmYWNlPWgsRT1FLkxuZXh0O3doaWxlKEUhPT11KX0sa2lsbEVkZ2VfOmZ1bmN0aW9uKGkpe2kuU3ltLnNpZGU8aS5zaWRlJiYoaT1pLlN5bSk7dmFyIHU9aS5uZXh0LGE9aS5TeW0ubmV4dDt1LlN5bS5uZXh0PWEsYS5TeW0ubmV4dD11fSxraWxsVmVydGV4XzpmdW5jdGlvbihpLHUpe3ZhciBhPWkuYW5FZGdlLGg9YTtkbyBoLk9yZz11LGg9aC5PbmV4dDt3aGlsZShoIT09YSk7dmFyIGI9aS5wcmV2LEU9aS5uZXh0O0UucHJldj1iLGIubmV4dD1FfSxraWxsRmFjZV86ZnVuY3Rpb24oaSx1KXt2YXIgYT1pLmFuRWRnZSxoPWE7ZG8gaC5MZmFjZT11LGg9aC5MbmV4dDt3aGlsZShoIT09YSk7dmFyIGI9aS5wcmV2LEU9aS5uZXh0O0UucHJldj1iLGIubmV4dD1FfSxtYWtlRWRnZTpmdW5jdGlvbigpe3ZhciBpPW5ldyBsLHU9bmV3IGwsYT1uZXcgYyxoPXRoaXMubWFrZUVkZ2VfKHRoaXMuZUhlYWQpO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKGksaCx0aGlzLnZIZWFkKSx0aGlzLm1ha2VWZXJ0ZXhfKHUsaC5TeW0sdGhpcy52SGVhZCksdGhpcy5tYWtlRmFjZV8oYSxoLHRoaXMuZkhlYWQpLGh9LHNwbGljZTpmdW5jdGlvbihpLHUpe3ZhciBhPSExLGg9ITE7aWYoaSE9PXUpe2lmKHUuT3JnIT09aS5PcmcmJihoPSEwLHRoaXMua2lsbFZlcnRleF8odS5PcmcsaS5PcmcpKSx1LkxmYWNlIT09aS5MZmFjZSYmKGE9ITAsdGhpcy5raWxsRmFjZV8odS5MZmFjZSxpLkxmYWNlKSksdGhpcy5zcGxpY2VfKHUsaSksIWgpe3ZhciBiPW5ldyBsO3RoaXMubWFrZVZlcnRleF8oYix1LGkuT3JnKSxpLk9yZy5hbkVkZ2U9aX1pZighYSl7dmFyIEU9bmV3IGM7dGhpcy5tYWtlRmFjZV8oRSx1LGkuTGZhY2UpLGkuTGZhY2UuYW5FZGdlPWl9fX0sZGVsZXRlOmZ1bmN0aW9uKGkpe3ZhciB1PWkuU3ltLGE9ITE7aWYoaS5MZmFjZSE9PWkuUmZhY2UmJihhPSEwLHRoaXMua2lsbEZhY2VfKGkuTGZhY2UsaS5SZmFjZSkpLGkuT25leHQ9PT1pKXRoaXMua2lsbFZlcnRleF8oaS5PcmcsbnVsbCk7ZWxzZSBpZihpLlJmYWNlLmFuRWRnZT1pLk9wcmV2LGkuT3JnLmFuRWRnZT1pLk9uZXh0LHRoaXMuc3BsaWNlXyhpLGkuT3ByZXYpLCFhKXt2YXIgaD1uZXcgYzt0aGlzLm1ha2VGYWNlXyhoLGksaS5MZmFjZSl9dS5PbmV4dD09PXU/KHRoaXMua2lsbFZlcnRleF8odS5PcmcsbnVsbCksdGhpcy5raWxsRmFjZV8odS5MZmFjZSxudWxsKSk6KGkuTGZhY2UuYW5FZGdlPXUuT3ByZXYsdS5PcmcuYW5FZGdlPXUuT25leHQsdGhpcy5zcGxpY2VfKHUsdS5PcHJldikpLHRoaXMua2lsbEVkZ2VfKGkpfSxhZGRFZGdlVmVydGV4OmZ1bmN0aW9uKGkpe3ZhciB1PXRoaXMubWFrZUVkZ2VfKGkpLGE9dS5TeW07dGhpcy5zcGxpY2VfKHUsaS5MbmV4dCksdS5Pcmc9aS5Ec3Q7dmFyIGg9bmV3IGw7cmV0dXJuIHRoaXMubWFrZVZlcnRleF8oaCxhLHUuT3JnKSx1LkxmYWNlPWEuTGZhY2U9aS5MZmFjZSx1fSxzcGxpdEVkZ2U6ZnVuY3Rpb24oaSx1KXt2YXIgYT10aGlzLmFkZEVkZ2VWZXJ0ZXgoaSksaD1hLlN5bTtyZXR1cm4gdGhpcy5zcGxpY2VfKGkuU3ltLGkuU3ltLk9wcmV2KSx0aGlzLnNwbGljZV8oaS5TeW0saCksaS5Ec3Q9aC5PcmcsaC5Ec3QuYW5FZGdlPWguU3ltLGguUmZhY2U9aS5SZmFjZSxoLndpbmRpbmc9aS53aW5kaW5nLGguU3ltLndpbmRpbmc9aS5TeW0ud2luZGluZyxofSxjb25uZWN0OmZ1bmN0aW9uKGksdSl7dmFyIGE9ITEsaD10aGlzLm1ha2VFZGdlXyhpKSxiPWguU3ltO2lmKHUuTGZhY2UhPT1pLkxmYWNlJiYoYT0hMCx0aGlzLmtpbGxGYWNlXyh1LkxmYWNlLGkuTGZhY2UpKSx0aGlzLnNwbGljZV8oaCxpLkxuZXh0KSx0aGlzLnNwbGljZV8oYix1KSxoLk9yZz1pLkRzdCxiLk9yZz11Lk9yZyxoLkxmYWNlPWIuTGZhY2U9aS5MZmFjZSxpLkxmYWNlLmFuRWRnZT1iLCFhKXt2YXIgRT1uZXcgYzt0aGlzLm1ha2VGYWNlXyhFLGgsaS5MZmFjZSl9cmV0dXJuIGh9LHphcEZhY2U6ZnVuY3Rpb24oaSl7dmFyIHU9aS5hbkVkZ2UsYSxoLGIsRSxBO2g9dS5MbmV4dDtkbyBhPWgsaD1hLkxuZXh0LGEuTGZhY2U9bnVsbCxhLlJmYWNlPT09bnVsbCYmKGEuT25leHQ9PT1hP3RoaXMua2lsbFZlcnRleF8oYS5PcmcsbnVsbCk6KGEuT3JnLmFuRWRnZT1hLk9uZXh0LHRoaXMuc3BsaWNlXyhhLGEuT3ByZXYpKSxiPWEuU3ltLGIuT25leHQ9PT1iP3RoaXMua2lsbFZlcnRleF8oYi5PcmcsbnVsbCk6KGIuT3JnLmFuRWRnZT1iLk9uZXh0LHRoaXMuc3BsaWNlXyhiLGIuT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhhKSk7d2hpbGUoYSE9dSk7RT1pLnByZXYsQT1pLm5leHQsQS5wcmV2PUUsRS5uZXh0PUF9LGNvdW50RmFjZVZlcnRzXzpmdW5jdGlvbihpKXt2YXIgdT1pLmFuRWRnZSxhPTA7ZG8gYSsrLHU9dS5MbmV4dDt3aGlsZSh1IT09aS5hbkVkZ2UpO3JldHVybiBhfSxtZXJnZUNvbnZleEZhY2VzOmZ1bmN0aW9uKGkpe3ZhciB1LGEsaCxiLEUsQSxMO2Zvcih1PXRoaXMuZkhlYWQubmV4dDt1IT09dGhpcy5mSGVhZDt1PXUubmV4dClpZih1Lmluc2lkZSlmb3IoYT11LmFuRWRnZSxFPWEuT3JnO2g9YS5MbmV4dCxiPWEuU3ltLGImJmIuTGZhY2UmJmIuTGZhY2UuaW5zaWRlJiYoQT10aGlzLmNvdW50RmFjZVZlcnRzXyh1KSxMPXRoaXMuY291bnRGYWNlVmVydHNfKGIuTGZhY2UpLEErTC0yPD1pJiZuLnZlcnRDQ1coYS5McHJldi5PcmcsYS5PcmcsYi5MbmV4dC5MbmV4dC5PcmcpJiZuLnZlcnRDQ1coYi5McHJldi5PcmcsYi5PcmcsYS5MbmV4dC5MbmV4dC5PcmcpJiYoaD1iLkxuZXh0LHRoaXMuZGVsZXRlKGIpLGE9bnVsbCxiPW51bGwpKSwhKGEmJmEuTG5leHQuT3JnPT09RSk7KWE9aDtyZXR1cm4hMH0sY2hlY2s6ZnVuY3Rpb24oKXt2YXIgaT10aGlzLmZIZWFkLHU9dGhpcy52SGVhZCxhPXRoaXMuZUhlYWQsaCxiLEUsQSxMLFM7Zm9yKGI9aSxiPWk7KGg9Yi5uZXh0KSE9PWk7Yj1oKXtzKGgucHJldj09PWIpLEw9aC5hbkVkZ2U7ZG8gcyhMLlN5bSE9PUwpLHMoTC5TeW0uU3ltPT09TCkscyhMLkxuZXh0Lk9uZXh0LlN5bT09PUwpLHMoTC5PbmV4dC5TeW0uTG5leHQ9PT1MKSxzKEwuTGZhY2U9PT1oKSxMPUwuTG5leHQ7d2hpbGUoTCE9PWguYW5FZGdlKX1mb3IocyhoLnByZXY9PT1iJiZoLmFuRWRnZT09PW51bGwpLEE9dSxBPXU7KEU9QS5uZXh0KSE9PXU7QT1FKXtzKEUucHJldj09PUEpLEw9RS5hbkVkZ2U7ZG8gcyhMLlN5bSE9PUwpLHMoTC5TeW0uU3ltPT09TCkscyhMLkxuZXh0Lk9uZXh0LlN5bT09PUwpLHMoTC5PbmV4dC5TeW0uTG5leHQ9PT1MKSxzKEwuT3JnPT09RSksTD1MLk9uZXh0O3doaWxlKEwhPT1FLmFuRWRnZSl9Zm9yKHMoRS5wcmV2PT09QSYmRS5hbkVkZ2U9PT1udWxsKSxTPWEsUz1hOyhMPVMubmV4dCkhPT1hO1M9TClzKEwuU3ltLm5leHQ9PT1TLlN5bSkscyhMLlN5bSE9PUwpLHMoTC5TeW0uU3ltPT09TCkscyhMLk9yZyE9PW51bGwpLHMoTC5Ec3QhPT1udWxsKSxzKEwuTG5leHQuT25leHQuU3ltPT09TCkscyhMLk9uZXh0LlN5bS5MbmV4dD09PUwpO3MoTC5TeW0ubmV4dD09PVMuU3ltJiZMLlN5bT09PXRoaXMuZUhlYWRTeW0mJkwuU3ltLlN5bT09PUwmJkwuT3JnPT09bnVsbCYmTC5Ec3Q9PT1udWxsJiZMLkxmYWNlPT09bnVsbCYmTC5SZmFjZT09PW51bGwpfX0sbi52ZXJ0RXE9ZnVuY3Rpb24oaSx1KXtyZXR1cm4gaS5zPT09dS5zJiZpLnQ9PT11LnR9LG4udmVydExlcT1mdW5jdGlvbihpLHUpe3JldHVybiBpLnM8dS5zfHxpLnM9PT11LnMmJmkudDw9dS50fSxuLnRyYW5zTGVxPWZ1bmN0aW9uKGksdSl7cmV0dXJuIGkudDx1LnR8fGkudD09PXUudCYmaS5zPD11LnN9LG4uZWRnZUdvZXNMZWZ0PWZ1bmN0aW9uKGkpe3JldHVybiBuLnZlcnRMZXEoaS5Ec3QsaS5PcmcpfSxuLmVkZ2VHb2VzUmlnaHQ9ZnVuY3Rpb24oaSl7cmV0dXJuIG4udmVydExlcShpLk9yZyxpLkRzdCl9LG4udmVydEwxZGlzdD1mdW5jdGlvbihpLHUpe3JldHVybiBNYXRoLmFicyhpLnMtdS5zKStNYXRoLmFicyhpLnQtdS50KX0sbi5lZGdlRXZhbD1mdW5jdGlvbihpLHUsYSl7cyhuLnZlcnRMZXEoaSx1KSYmbi52ZXJ0TGVxKHUsYSkpO3ZhciBoPXUucy1pLnMsYj1hLnMtdS5zO3JldHVybiBoK2I+MD9oPGI/dS50LWkudCsoaS50LWEudCkqKGgvKGgrYikpOnUudC1hLnQrKGEudC1pLnQpKihiLyhoK2IpKTowfSxuLmVkZ2VTaWduPWZ1bmN0aW9uKGksdSxhKXtzKG4udmVydExlcShpLHUpJiZuLnZlcnRMZXEodSxhKSk7dmFyIGg9dS5zLWkucyxiPWEucy11LnM7cmV0dXJuIGgrYj4wPyh1LnQtYS50KSpoKyh1LnQtaS50KSpiOjB9LG4udHJhbnNFdmFsPWZ1bmN0aW9uKGksdSxhKXtzKG4udHJhbnNMZXEoaSx1KSYmbi50cmFuc0xlcSh1LGEpKTt2YXIgaD11LnQtaS50LGI9YS50LXUudDtyZXR1cm4gaCtiPjA/aDxiP3Uucy1pLnMrKGkucy1hLnMpKihoLyhoK2IpKTp1LnMtYS5zKyhhLnMtaS5zKSooYi8oaCtiKSk6MH0sbi50cmFuc1NpZ249ZnVuY3Rpb24oaSx1LGEpe3Mobi50cmFuc0xlcShpLHUpJiZuLnRyYW5zTGVxKHUsYSkpO3ZhciBoPXUudC1pLnQsYj1hLnQtdS50O3JldHVybiBoK2I+MD8odS5zLWEucykqaCsodS5zLWkucykqYjowfSxuLnZlcnRDQ1c9ZnVuY3Rpb24oaSx1LGEpe3JldHVybiBpLnMqKHUudC1hLnQpK3UucyooYS50LWkudCkrYS5zKihpLnQtdS50KT49MH0sbi5pbnRlcnBvbGF0ZT1mdW5jdGlvbihpLHUsYSxoKXtyZXR1cm4gaT1pPDA/MDppLGE9YTwwPzA6YSxpPD1hP2E9PT0wPyh1K2gpLzI6dSsoaC11KSooaS8oaSthKSk6aCsodS1oKSooYS8oaSthKSl9LG4uaW50ZXJzZWN0PWZ1bmN0aW9uKGksdSxhLGgsYil7dmFyIEUsQSxMO24udmVydExlcShpLHUpfHwoTD1pLGk9dSx1PUwpLG4udmVydExlcShhLGgpfHwoTD1hLGE9aCxoPUwpLG4udmVydExlcShpLGEpfHwoTD1pLGk9YSxhPUwsTD11LHU9aCxoPUwpLG4udmVydExlcShhLHUpP24udmVydExlcSh1LGgpPyhFPW4uZWRnZUV2YWwoaSxhLHUpLEE9bi5lZGdlRXZhbChhLHUsaCksRStBPDAmJihFPS1FLEE9LUEpLGIucz1uLmludGVycG9sYXRlKEUsYS5zLEEsdS5zKSk6KEU9bi5lZGdlU2lnbihpLGEsdSksQT0tbi5lZGdlU2lnbihpLGgsdSksRStBPDAmJihFPS1FLEE9LUEpLGIucz1uLmludGVycG9sYXRlKEUsYS5zLEEsaC5zKSk6Yi5zPShhLnMrdS5zKS8yLG4udHJhbnNMZXEoaSx1KXx8KEw9aSxpPXUsdT1MKSxuLnRyYW5zTGVxKGEsaCl8fChMPWEsYT1oLGg9TCksbi50cmFuc0xlcShpLGEpfHwoTD1pLGk9YSxhPUwsTD11LHU9aCxoPUwpLG4udHJhbnNMZXEoYSx1KT9uLnRyYW5zTGVxKHUsaCk/KEU9bi50cmFuc0V2YWwoaSxhLHUpLEE9bi50cmFuc0V2YWwoYSx1LGgpLEUrQTwwJiYoRT0tRSxBPS1BKSxiLnQ9bi5pbnRlcnBvbGF0ZShFLGEudCxBLHUudCkpOihFPW4udHJhbnNTaWduKGksYSx1KSxBPS1uLnRyYW5zU2lnbihpLGgsdSksRStBPDAmJihFPS1FLEE9LUEpLGIudD1uLmludGVycG9sYXRlKEUsYS50LEEsaC50KSk6Yi50PShhLnQrdS50KS8yfTtmdW5jdGlvbiB4KCl7dGhpcy5rZXk9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbH1mdW5jdGlvbiBnKGksdSl7dGhpcy5oZWFkPW5ldyB4LHRoaXMuaGVhZC5uZXh0PXRoaXMuaGVhZCx0aGlzLmhlYWQucHJldj10aGlzLmhlYWQsdGhpcy5mcmFtZT1pLHRoaXMubGVxPXV9Zy5wcm90b3R5cGU9e21pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQubmV4dH0sbWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5wcmV2fSxpbnNlcnQ6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCxpKX0sc2VhcmNoOmZ1bmN0aW9uKGkpe3ZhciB1PXRoaXMuaGVhZDtkbyB1PXUubmV4dDt3aGlsZSh1LmtleSE9PW51bGwmJiF0aGlzLmxlcSh0aGlzLmZyYW1lLGksdS5rZXkpKTtyZXR1cm4gdX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGksdSl7ZG8gaT1pLnByZXY7d2hpbGUoaS5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxpLmtleSx1KSk7dmFyIGE9bmV3IHg7cmV0dXJuIGEua2V5PXUsYS5uZXh0PWkubmV4dCxpLm5leHQucHJldj1hLGEucHJldj1pLGkubmV4dD1hLGF9LGRlbGV0ZTpmdW5jdGlvbihpKXtpLm5leHQucHJldj1pLnByZXYsaS5wcmV2Lm5leHQ9aS5uZXh0fX07ZnVuY3Rpb24geSgpe3RoaXMuaGFuZGxlPW51bGx9ZnVuY3Rpb24gbSgpe3RoaXMua2V5PW51bGwsdGhpcy5ub2RlPW51bGx9ZnVuY3Rpb24gVChpLHUpe3RoaXMuc2l6ZT0wLHRoaXMubWF4PWksdGhpcy5ub2Rlcz1bXSx0aGlzLm5vZGVzLmxlbmd0aD1pKzE7dmFyIGE7Zm9yKGE9MDthPHRoaXMubm9kZXMubGVuZ3RoO2ErKyl0aGlzLm5vZGVzW2FdPW5ldyB5O2Zvcih0aGlzLmhhbmRsZXM9W10sdGhpcy5oYW5kbGVzLmxlbmd0aD1pKzEsYT0wO2E8dGhpcy5oYW5kbGVzLmxlbmd0aDthKyspdGhpcy5oYW5kbGVzW2FdPW5ldyBtO3RoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5mcmVlTGlzdD0wLHRoaXMubGVxPXUsdGhpcy5ub2Rlc1sxXS5oYW5kbGU9MSx0aGlzLmhhbmRsZXNbMV0ua2V5PW51bGx9VC5wcm90b3R5cGU9e2Zsb2F0RG93bl86ZnVuY3Rpb24oaSl7dmFyIHU9dGhpcy5ub2RlcyxhPXRoaXMuaGFuZGxlcyxoLGIsRTtmb3IoaD11W2ldLmhhbmRsZTs7KXtpZihFPWk8PDEsRTx0aGlzLnNpemUmJnRoaXMubGVxKGFbdVtFKzFdLmhhbmRsZV0ua2V5LGFbdVtFXS5oYW5kbGVdLmtleSkmJisrRSxzKEU8PXRoaXMubWF4KSxiPXVbRV0uaGFuZGxlLEU+dGhpcy5zaXplfHx0aGlzLmxlcShhW2hdLmtleSxhW2JdLmtleSkpe3VbaV0uaGFuZGxlPWgsYVtoXS5ub2RlPWk7YnJlYWt9dVtpXS5oYW5kbGU9YixhW2JdLm5vZGU9aSxpPUV9fSxmbG9hdFVwXzpmdW5jdGlvbihpKXt2YXIgdT10aGlzLm5vZGVzLGE9dGhpcy5oYW5kbGVzLGgsYixFO2ZvcihoPXVbaV0uaGFuZGxlOzspe2lmKEU9aT4+MSxiPXVbRV0uaGFuZGxlLEU9PT0wfHx0aGlzLmxlcShhW2JdLmtleSxhW2hdLmtleSkpe3VbaV0uaGFuZGxlPWgsYVtoXS5ub2RlPWk7YnJlYWt9dVtpXS5oYW5kbGU9YixhW2JdLm5vZGU9aSxpPUV9fSxpbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciBpPXRoaXMuc2l6ZTtpPj0xOy0taSl0aGlzLmZsb2F0RG93bl8oaSk7dGhpcy5pbml0aWFsaXplZD0hMH0sbWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFuZGxlc1t0aGlzLm5vZGVzWzFdLmhhbmRsZV0ua2V5fSxpbnNlcnQ6ZnVuY3Rpb24oaSl7dmFyIHUsYTtpZih1PSsrdGhpcy5zaXplLHUqMj50aGlzLm1heCl7dGhpcy5tYXgqPTI7dmFyIGgsYjtmb3IoYj10aGlzLm5vZGVzLmxlbmd0aCx0aGlzLm5vZGVzLmxlbmd0aD10aGlzLm1heCsxLGg9YjtoPHRoaXMubm9kZXMubGVuZ3RoO2grKyl0aGlzLm5vZGVzW2hdPW5ldyB5O2ZvcihiPXRoaXMuaGFuZGxlcy5sZW5ndGgsdGhpcy5oYW5kbGVzLmxlbmd0aD10aGlzLm1heCsxLGg9YjtoPHRoaXMuaGFuZGxlcy5sZW5ndGg7aCsrKXRoaXMuaGFuZGxlc1toXT1uZXcgbX1yZXR1cm4gdGhpcy5mcmVlTGlzdD09PTA/YT11OihhPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD10aGlzLmhhbmRsZXNbYV0ubm9kZSksdGhpcy5ub2Rlc1t1XS5oYW5kbGU9YSx0aGlzLmhhbmRsZXNbYV0ubm9kZT11LHRoaXMuaGFuZGxlc1thXS5rZXk9aSx0aGlzLmluaXRpYWxpemVkJiZ0aGlzLmZsb2F0VXBfKHUpLGF9LGV4dHJhY3RNaW46ZnVuY3Rpb24oKXt2YXIgaT10aGlzLm5vZGVzLHU9dGhpcy5oYW5kbGVzLGE9aVsxXS5oYW5kbGUsaD11W2FdLmtleTtyZXR1cm4gdGhpcy5zaXplPjAmJihpWzFdLmhhbmRsZT1pW3RoaXMuc2l6ZV0uaGFuZGxlLHVbaVsxXS5oYW5kbGVdLm5vZGU9MSx1W2FdLmtleT1udWxsLHVbYV0ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9YSwtLXRoaXMuc2l6ZSx0aGlzLnNpemU+MCYmdGhpcy5mbG9hdERvd25fKDEpKSxofSxkZWxldGU6ZnVuY3Rpb24oaSl7dmFyIHU9dGhpcy5ub2RlcyxhPXRoaXMuaGFuZGxlcyxoO3MoaT49MSYmaTw9dGhpcy5tYXgmJmFbaV0ua2V5IT09bnVsbCksaD1hW2ldLm5vZGUsdVtoXS5oYW5kbGU9dVt0aGlzLnNpemVdLmhhbmRsZSxhW3VbaF0uaGFuZGxlXS5ub2RlPWgsLS10aGlzLnNpemUsaDw9dGhpcy5zaXplJiYoaDw9MXx8dGhpcy5sZXEoYVt1W2g+PjFdLmhhbmRsZV0ua2V5LGFbdVtoXS5oYW5kbGVdLmtleSk/dGhpcy5mbG9hdERvd25fKGgpOnRoaXMuZmxvYXRVcF8oaCkpLGFbaV0ua2V5PW51bGwsYVtpXS5ub2RlPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD1pfX07ZnVuY3Rpb24gTygpe3RoaXMuZVVwPW51bGwsdGhpcy5ub2RlVXA9bnVsbCx0aGlzLndpbmRpbmdOdW1iZXI9MCx0aGlzLmluc2lkZT0hMSx0aGlzLnNlbnRpbmVsPSExLHRoaXMuZGlydHk9ITEsdGhpcy5maXhVcHBlckVkZ2U9ITF9dmFyIHY9e307di5yZWdpb25CZWxvdz1mdW5jdGlvbihpKXtyZXR1cm4gaS5ub2RlVXAucHJldi5rZXl9LHYucmVnaW9uQWJvdmU9ZnVuY3Rpb24oaSl7cmV0dXJuIGkubm9kZVVwLm5leHQua2V5fSx2LmRlYnVnRXZlbnQ9ZnVuY3Rpb24oaSl7fSx2LmFkZFdpbmRpbmc9ZnVuY3Rpb24oaSx1KXtpLndpbmRpbmcrPXUud2luZGluZyxpLlN5bS53aW5kaW5nKz11LlN5bS53aW5kaW5nfSx2LmVkZ2VMZXE9ZnVuY3Rpb24oaSx1LGEpe3ZhciBoPWkuZXZlbnQsQSxMLGI9dS5lVXAsRT1hLmVVcDtpZihiLkRzdD09PWgpcmV0dXJuIEUuRHN0PT09aD9uLnZlcnRMZXEoYi5PcmcsRS5PcmcpP24uZWRnZVNpZ24oRS5Ec3QsYi5PcmcsRS5PcmcpPD0wOm4uZWRnZVNpZ24oYi5Ec3QsRS5PcmcsYi5PcmcpPj0wOm4uZWRnZVNpZ24oRS5Ec3QsaCxFLk9yZyk8PTA7aWYoRS5Ec3Q9PT1oKXJldHVybiBuLmVkZ2VTaWduKGIuRHN0LGgsYi5PcmcpPj0wO3ZhciBBPW4uZWRnZUV2YWwoYi5Ec3QsaCxiLk9yZyksTD1uLmVkZ2VFdmFsKEUuRHN0LGgsRS5PcmcpO3JldHVybiBBPj1MfSx2LmRlbGV0ZVJlZ2lvbj1mdW5jdGlvbihpLHUpe3UuZml4VXBwZXJFZGdlJiZzKHUuZVVwLndpbmRpbmc9PT0wKSx1LmVVcC5hY3RpdmVSZWdpb249bnVsbCxpLmRpY3QuZGVsZXRlKHUubm9kZVVwKX0sdi5maXhVcHBlckVkZ2U9ZnVuY3Rpb24oaSx1LGEpe3ModS5maXhVcHBlckVkZ2UpLGkubWVzaC5kZWxldGUodS5lVXApLHUuZml4VXBwZXJFZGdlPSExLHUuZVVwPWEsYS5hY3RpdmVSZWdpb249dX0sdi50b3BMZWZ0UmVnaW9uPWZ1bmN0aW9uKGksdSl7dmFyIGE9dS5lVXAuT3JnLGg7ZG8gdT12LnJlZ2lvbkFib3ZlKHUpO3doaWxlKHUuZVVwLk9yZz09PWEpO2lmKHUuZml4VXBwZXJFZGdlKXtpZihoPWkubWVzaC5jb25uZWN0KHYucmVnaW9uQmVsb3codSkuZVVwLlN5bSx1LmVVcC5MbmV4dCksaD09PW51bGwpcmV0dXJuIG51bGw7di5maXhVcHBlckVkZ2UoaSx1LGgpLHU9di5yZWdpb25BYm92ZSh1KX1yZXR1cm4gdX0sdi50b3BSaWdodFJlZ2lvbj1mdW5jdGlvbihpKXt2YXIgdT1pLmVVcC5Ec3Q7ZG8gaT12LnJlZ2lvbkFib3ZlKGkpO3doaWxlKGkuZVVwLkRzdD09PXUpO3JldHVybiBpfSx2LmFkZFJlZ2lvbkJlbG93PWZ1bmN0aW9uKGksdSxhKXt2YXIgaD1uZXcgTztyZXR1cm4gaC5lVXA9YSxoLm5vZGVVcD1pLmRpY3QuaW5zZXJ0QmVmb3JlKHUubm9kZVVwLGgpLGguZml4VXBwZXJFZGdlPSExLGguc2VudGluZWw9ITEsaC5kaXJ0eT0hMSxhLmFjdGl2ZVJlZ2lvbj1oLGh9LHYuaXNXaW5kaW5nSW5zaWRlPWZ1bmN0aW9uKGksdSl7c3dpdGNoKGkud2luZGluZ1J1bGUpe2Nhc2Ugci5XSU5ESU5HX09ERDpyZXR1cm4odSYxKSE9PTA7Y2FzZSByLldJTkRJTkdfTk9OWkVSTzpyZXR1cm4gdSE9PTA7Y2FzZSByLldJTkRJTkdfUE9TSVRJVkU6cmV0dXJuIHU+MDtjYXNlIHIuV0lORElOR19ORUdBVElWRTpyZXR1cm4gdTwwO2Nhc2Ugci5XSU5ESU5HX0FCU19HRVFfVFdPOnJldHVybiB1Pj0yfHx1PD0tMn1yZXR1cm4gcyghMSksITF9LHYuY29tcHV0ZVdpbmRpbmc9ZnVuY3Rpb24oaSx1KXt1LndpbmRpbmdOdW1iZXI9di5yZWdpb25BYm92ZSh1KS53aW5kaW5nTnVtYmVyK3UuZVVwLndpbmRpbmcsdS5pbnNpZGU9di5pc1dpbmRpbmdJbnNpZGUoaSx1LndpbmRpbmdOdW1iZXIpfSx2LmZpbmlzaFJlZ2lvbj1mdW5jdGlvbihpLHUpe3ZhciBhPXUuZVVwLGg9YS5MZmFjZTtoLmluc2lkZT11Lmluc2lkZSxoLmFuRWRnZT1hLHYuZGVsZXRlUmVnaW9uKGksdSl9LHYuZmluaXNoTGVmdFJlZ2lvbnM9ZnVuY3Rpb24oaSx1LGEpe2Zvcih2YXIgaCxBLGI9bnVsbCxFPXUsQT11LmVVcDtFIT09YTspe2lmKEUuZml4VXBwZXJFZGdlPSExLGI9di5yZWdpb25CZWxvdyhFKSxoPWIuZVVwLGguT3JnIT1BLk9yZyl7aWYoIWIuZml4VXBwZXJFZGdlKXt2LmZpbmlzaFJlZ2lvbihpLEUpO2JyZWFrfWg9aS5tZXNoLmNvbm5lY3QoQS5McHJldixoLlN5bSksdi5maXhVcHBlckVkZ2UoaSxiLGgpfUEuT25leHQhPT1oJiYoaS5tZXNoLnNwbGljZShoLk9wcmV2LGgpLGkubWVzaC5zcGxpY2UoQSxoKSksdi5maW5pc2hSZWdpb24oaSxFKSxBPWIuZVVwLEU9Yn1yZXR1cm4gQX0sdi5hZGRSaWdodEVkZ2VzPWZ1bmN0aW9uKGksdSxhLGgsYixFKXt2YXIgQSxMLFMsSSxEPSEwO1M9YTtkbyBzKG4udmVydExlcShTLk9yZyxTLkRzdCkpLHYuYWRkUmVnaW9uQmVsb3coaSx1LFMuU3ltKSxTPVMuT25leHQ7d2hpbGUoUyE9PWgpO2ZvcihiPT09bnVsbCYmKGI9di5yZWdpb25CZWxvdyh1KS5lVXAuUnByZXYpLEw9dSxJPWI7QT12LnJlZ2lvbkJlbG93KEwpLFM9QS5lVXAuU3ltLFMuT3JnPT09SS5Pcmc7KVMuT25leHQhPT1JJiYoaS5tZXNoLnNwbGljZShTLk9wcmV2LFMpLGkubWVzaC5zcGxpY2UoSS5PcHJldixTKSksQS53aW5kaW5nTnVtYmVyPUwud2luZGluZ051bWJlci1TLndpbmRpbmcsQS5pbnNpZGU9di5pc1dpbmRpbmdJbnNpZGUoaSxBLndpbmRpbmdOdW1iZXIpLEwuZGlydHk9ITAsIUQmJnYuY2hlY2tGb3JSaWdodFNwbGljZShpLEwpJiYodi5hZGRXaW5kaW5nKFMsSSksdi5kZWxldGVSZWdpb24oaSxMKSxpLm1lc2guZGVsZXRlKEkpKSxEPSExLEw9QSxJPVM7TC5kaXJ0eT0hMCxzKEwud2luZGluZ051bWJlci1TLndpbmRpbmc9PT1BLndpbmRpbmdOdW1iZXIpLEUmJnYud2Fsa0RpcnR5UmVnaW9ucyhpLEwpfSx2LnNwbGljZU1lcmdlVmVydGljZXM9ZnVuY3Rpb24oaSx1LGEpe2kubWVzaC5zcGxpY2UodSxhKX0sdi52ZXJ0ZXhXZWlnaHRzPWZ1bmN0aW9uKGksdSxhKXt2YXIgaD1uLnZlcnRMMWRpc3QodSxpKSxiPW4udmVydEwxZGlzdChhLGkpLEU9LjUqYi8oaCtiKSxBPS41KmgvKGgrYik7aS5jb29yZHNbMF0rPUUqdS5jb29yZHNbMF0rQSphLmNvb3Jkc1swXSxpLmNvb3Jkc1sxXSs9RSp1LmNvb3Jkc1sxXStBKmEuY29vcmRzWzFdLGkuY29vcmRzWzJdKz1FKnUuY29vcmRzWzJdK0EqYS5jb29yZHNbMl19LHYuZ2V0SW50ZXJzZWN0RGF0YT1mdW5jdGlvbihpLHUsYSxoLGIsRSl7dS5jb29yZHNbMF09dS5jb29yZHNbMV09dS5jb29yZHNbMl09MCx1LmlkeD0tMSx2LnZlcnRleFdlaWdodHModSxhLGgpLHYudmVydGV4V2VpZ2h0cyh1LGIsRSl9LHYuY2hlY2tGb3JSaWdodFNwbGljZT1mdW5jdGlvbihpLHUpe3ZhciBhPXYucmVnaW9uQmVsb3codSksaD11LmVVcCxiPWEuZVVwO2lmKG4udmVydExlcShoLk9yZyxiLk9yZykpe2lmKG4uZWRnZVNpZ24oYi5Ec3QsaC5PcmcsYi5PcmcpPjApcmV0dXJuITE7bi52ZXJ0RXEoaC5PcmcsYi5PcmcpP2guT3JnIT09Yi5PcmcmJihpLnBxLmRlbGV0ZShoLk9yZy5wcUhhbmRsZSksdi5zcGxpY2VNZXJnZVZlcnRpY2VzKGksYi5PcHJldixoKSk6KGkubWVzaC5zcGxpdEVkZ2UoYi5TeW0pLGkubWVzaC5zcGxpY2UoaCxiLk9wcmV2KSx1LmRpcnR5PWEuZGlydHk9ITApfWVsc2V7aWYobi5lZGdlU2lnbihoLkRzdCxiLk9yZyxoLk9yZyk8MClyZXR1cm4hMTt2LnJlZ2lvbkFib3ZlKHUpLmRpcnR5PXUuZGlydHk9ITAsaS5tZXNoLnNwbGl0RWRnZShoLlN5bSksaS5tZXNoLnNwbGljZShiLk9wcmV2LGgpfXJldHVybiEwfSx2LmNoZWNrRm9yTGVmdFNwbGljZT1mdW5jdGlvbihpLHUpe3ZhciBhPXYucmVnaW9uQmVsb3codSksaD11LmVVcCxiPWEuZVVwLEU7aWYocyghbi52ZXJ0RXEoaC5Ec3QsYi5Ec3QpKSxuLnZlcnRMZXEoaC5Ec3QsYi5Ec3QpKXtpZihuLmVkZ2VTaWduKGguRHN0LGIuRHN0LGguT3JnKTwwKXJldHVybiExO3YucmVnaW9uQWJvdmUodSkuZGlydHk9dS5kaXJ0eT0hMCxFPWkubWVzaC5zcGxpdEVkZ2UoaCksaS5tZXNoLnNwbGljZShiLlN5bSxFKSxFLkxmYWNlLmluc2lkZT11Lmluc2lkZX1lbHNle2lmKG4uZWRnZVNpZ24oYi5Ec3QsaC5Ec3QsYi5PcmcpPjApcmV0dXJuITE7dS5kaXJ0eT1hLmRpcnR5PSEwLEU9aS5tZXNoLnNwbGl0RWRnZShiKSxpLm1lc2guc3BsaWNlKGguTG5leHQsYi5TeW0pLEUuUmZhY2UuaW5zaWRlPXUuaW5zaWRlfXJldHVybiEwfSx2LmNoZWNrRm9ySW50ZXJzZWN0PWZ1bmN0aW9uKGksdSl7dmFyIGE9di5yZWdpb25CZWxvdyh1KSxoPXUuZVVwLGI9YS5lVXAsRT1oLk9yZyxBPWIuT3JnLEw9aC5Ec3QsUz1iLkRzdCxJLEQsUj1uZXcgbCxDLGo7aWYocyghbi52ZXJ0RXEoUyxMKSkscyhuLmVkZ2VTaWduKEwsaS5ldmVudCxFKTw9MCkscyhuLmVkZ2VTaWduKFMsaS5ldmVudCxBKT49MCkscyhFIT09aS5ldmVudCYmQSE9PWkuZXZlbnQpLHMoIXUuZml4VXBwZXJFZGdlJiYhYS5maXhVcHBlckVkZ2UpLEU9PT1BfHwoST1NYXRoLm1pbihFLnQsTC50KSxEPU1hdGgubWF4KEEudCxTLnQpLEk+RCkpcmV0dXJuITE7aWYobi52ZXJ0TGVxKEUsQSkpe2lmKG4uZWRnZVNpZ24oUyxFLEEpPjApcmV0dXJuITF9ZWxzZSBpZihuLmVkZ2VTaWduKEwsQSxFKTwwKXJldHVybiExO3JldHVybiB2LmRlYnVnRXZlbnQoaSksbi5pbnRlcnNlY3QoTCxFLFMsQSxSKSxzKE1hdGgubWluKEUudCxMLnQpPD1SLnQpLHMoUi50PD1NYXRoLm1heChBLnQsUy50KSkscyhNYXRoLm1pbihTLnMsTC5zKTw9Ui5zKSxzKFIuczw9TWF0aC5tYXgoQS5zLEUucykpLG4udmVydExlcShSLGkuZXZlbnQpJiYoUi5zPWkuZXZlbnQucyxSLnQ9aS5ldmVudC50KSxDPW4udmVydExlcShFLEEpP0U6QSxuLnZlcnRMZXEoQyxSKSYmKFIucz1DLnMsUi50PUMudCksbi52ZXJ0RXEoUixFKXx8bi52ZXJ0RXEoUixBKT8odi5jaGVja0ZvclJpZ2h0U3BsaWNlKGksdSksITEpOiFuLnZlcnRFcShMLGkuZXZlbnQpJiZuLmVkZ2VTaWduKEwsaS5ldmVudCxSKT49MHx8IW4udmVydEVxKFMsaS5ldmVudCkmJm4uZWRnZVNpZ24oUyxpLmV2ZW50LFIpPD0wP1M9PT1pLmV2ZW50PyhpLm1lc2guc3BsaXRFZGdlKGguU3ltKSxpLm1lc2guc3BsaWNlKGIuU3ltLGgpLHU9di50b3BMZWZ0UmVnaW9uKGksdSksaD12LnJlZ2lvbkJlbG93KHUpLmVVcCx2LmZpbmlzaExlZnRSZWdpb25zKGksdi5yZWdpb25CZWxvdyh1KSxhKSx2LmFkZFJpZ2h0RWRnZXMoaSx1LGguT3ByZXYsaCxoLCEwKSwhMCk6TD09PWkuZXZlbnQ/KGkubWVzaC5zcGxpdEVkZ2UoYi5TeW0pLGkubWVzaC5zcGxpY2UoaC5MbmV4dCxiLk9wcmV2KSxhPXUsdT12LnRvcFJpZ2h0UmVnaW9uKHUpLGo9di5yZWdpb25CZWxvdyh1KS5lVXAuUnByZXYsYS5lVXA9Yi5PcHJldixiPXYuZmluaXNoTGVmdFJlZ2lvbnMoaSxhLG51bGwpLHYuYWRkUmlnaHRFZGdlcyhpLHUsYi5PbmV4dCxoLlJwcmV2LGosITApLCEwKToobi5lZGdlU2lnbihMLGkuZXZlbnQsUik+PTAmJih2LnJlZ2lvbkFib3ZlKHUpLmRpcnR5PXUuZGlydHk9ITAsaS5tZXNoLnNwbGl0RWRnZShoLlN5bSksaC5Pcmcucz1pLmV2ZW50LnMsaC5PcmcudD1pLmV2ZW50LnQpLG4uZWRnZVNpZ24oUyxpLmV2ZW50LFIpPD0wJiYodS5kaXJ0eT1hLmRpcnR5PSEwLGkubWVzaC5zcGxpdEVkZ2UoYi5TeW0pLGIuT3JnLnM9aS5ldmVudC5zLGIuT3JnLnQ9aS5ldmVudC50KSwhMSk6KGkubWVzaC5zcGxpdEVkZ2UoaC5TeW0pLGkubWVzaC5zcGxpdEVkZ2UoYi5TeW0pLGkubWVzaC5zcGxpY2UoYi5PcHJldixoKSxoLk9yZy5zPVIucyxoLk9yZy50PVIudCxoLk9yZy5wcUhhbmRsZT1pLnBxLmluc2VydChoLk9yZyksdi5nZXRJbnRlcnNlY3REYXRhKGksaC5PcmcsRSxMLEEsUyksdi5yZWdpb25BYm92ZSh1KS5kaXJ0eT11LmRpcnR5PWEuZGlydHk9ITAsITEpfSx2LndhbGtEaXJ0eVJlZ2lvbnM9ZnVuY3Rpb24oaSx1KXtmb3IodmFyIGE9di5yZWdpb25CZWxvdyh1KSxoLGI7Oyl7Zm9yKDthLmRpcnR5Oyl1PWEsYT12LnJlZ2lvbkJlbG93KGEpO2lmKCF1LmRpcnR5JiYoYT11LHU9di5yZWdpb25BYm92ZSh1KSx1PT09bnVsbHx8IXUuZGlydHkpKXJldHVybjtpZih1LmRpcnR5PSExLGg9dS5lVXAsYj1hLmVVcCxoLkRzdCE9PWIuRHN0JiZ2LmNoZWNrRm9yTGVmdFNwbGljZShpLHUpJiYoYS5maXhVcHBlckVkZ2U/KHYuZGVsZXRlUmVnaW9uKGksYSksaS5tZXNoLmRlbGV0ZShiKSxhPXYucmVnaW9uQmVsb3codSksYj1hLmVVcCk6dS5maXhVcHBlckVkZ2UmJih2LmRlbGV0ZVJlZ2lvbihpLHUpLGkubWVzaC5kZWxldGUoaCksdT12LnJlZ2lvbkFib3ZlKGEpLGg9dS5lVXApKSxoLk9yZyE9PWIuT3JnKWlmKGguRHN0IT09Yi5Ec3QmJiF1LmZpeFVwcGVyRWRnZSYmIWEuZml4VXBwZXJFZGdlJiYoaC5Ec3Q9PT1pLmV2ZW50fHxiLkRzdD09PWkuZXZlbnQpKXtpZih2LmNoZWNrRm9ySW50ZXJzZWN0KGksdSkpcmV0dXJufWVsc2Ugdi5jaGVja0ZvclJpZ2h0U3BsaWNlKGksdSk7aC5Pcmc9PT1iLk9yZyYmaC5Ec3Q9PT1iLkRzdCYmKHYuYWRkV2luZGluZyhiLGgpLHYuZGVsZXRlUmVnaW9uKGksdSksaS5tZXNoLmRlbGV0ZShoKSx1PXYucmVnaW9uQWJvdmUoYSkpfX0sdi5jb25uZWN0UmlnaHRWZXJ0ZXg9ZnVuY3Rpb24oaSx1LGEpe3ZhciBoLGI9YS5PbmV4dCxFPXYucmVnaW9uQmVsb3codSksQT11LmVVcCxMPUUuZVVwLFM9ITE7aWYoQS5Ec3QhPT1MLkRzdCYmdi5jaGVja0ZvckludGVyc2VjdChpLHUpLG4udmVydEVxKEEuT3JnLGkuZXZlbnQpJiYoaS5tZXNoLnNwbGljZShiLk9wcmV2LEEpLHU9di50b3BMZWZ0UmVnaW9uKGksdSksYj12LnJlZ2lvbkJlbG93KHUpLmVVcCx2LmZpbmlzaExlZnRSZWdpb25zKGksdi5yZWdpb25CZWxvdyh1KSxFKSxTPSEwKSxuLnZlcnRFcShMLk9yZyxpLmV2ZW50KSYmKGkubWVzaC5zcGxpY2UoYSxMLk9wcmV2KSxhPXYuZmluaXNoTGVmdFJlZ2lvbnMoaSxFLG51bGwpLFM9ITApLFMpe3YuYWRkUmlnaHRFZGdlcyhpLHUsYS5PbmV4dCxiLGIsITApO3JldHVybn1uLnZlcnRMZXEoTC5PcmcsQS5PcmcpP2g9TC5PcHJldjpoPUEsaD1pLm1lc2guY29ubmVjdChhLkxwcmV2LGgpLHYuYWRkUmlnaHRFZGdlcyhpLHUsaCxoLk9uZXh0LGguT25leHQsITEpLGguU3ltLmFjdGl2ZVJlZ2lvbi5maXhVcHBlckVkZ2U9ITAsdi53YWxrRGlydHlSZWdpb25zKGksdSl9LHYuY29ubmVjdExlZnREZWdlbmVyYXRlPWZ1bmN0aW9uKGksdSxhKXt2YXIgaCxiLEUsQSxMO2lmKGg9dS5lVXAsbi52ZXJ0RXEoaC5PcmcsYSkpe3MoITEpLHYuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhpLGgsYS5hbkVkZ2UpO3JldHVybn1pZighbi52ZXJ0RXEoaC5Ec3QsYSkpe2kubWVzaC5zcGxpdEVkZ2UoaC5TeW0pLHUuZml4VXBwZXJFZGdlJiYoaS5tZXNoLmRlbGV0ZShoLk9uZXh0KSx1LmZpeFVwcGVyRWRnZT0hMSksaS5tZXNoLnNwbGljZShhLmFuRWRnZSxoKSx2LnN3ZWVwRXZlbnQoaSxhKTtyZXR1cm59cyghMSksdT12LnRvcFJpZ2h0UmVnaW9uKHUpLEw9di5yZWdpb25CZWxvdyh1KSxFPUwuZVVwLlN5bSxiPUE9RS5PbmV4dCxMLmZpeFVwcGVyRWRnZSYmKHMoYiE9PUUpLHYuZGVsZXRlUmVnaW9uKGksTCksaS5tZXNoLmRlbGV0ZShFKSxFPWIuT3ByZXYpLGkubWVzaC5zcGxpY2UoYS5hbkVkZ2UsRSksbi5lZGdlR29lc0xlZnQoYil8fChiPW51bGwpLHYuYWRkUmlnaHRFZGdlcyhpLHUsRS5PbmV4dCxBLGIsITApfSx2LmNvbm5lY3RMZWZ0VmVydGV4PWZ1bmN0aW9uKGksdSl7dmFyIGEsaCxiLEUsQSxMLFM9bmV3IE87aWYoUy5lVXA9dS5hbkVkZ2UuU3ltLGE9aS5kaWN0LnNlYXJjaChTKS5rZXksaD12LnJlZ2lvbkJlbG93KGEpLCEhaCl7aWYoRT1hLmVVcCxBPWguZVVwLG4uZWRnZVNpZ24oRS5Ec3QsdSxFLk9yZyk9PT0wKXt2LmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZShpLGEsdSk7cmV0dXJufWlmKGI9bi52ZXJ0TGVxKEEuRHN0LEUuRHN0KT9hOmgsYS5pbnNpZGV8fGIuZml4VXBwZXJFZGdlKXtpZihiPT09YSlMPWkubWVzaC5jb25uZWN0KHUuYW5FZGdlLlN5bSxFLkxuZXh0KTtlbHNle3ZhciBJPWkubWVzaC5jb25uZWN0KEEuRG5leHQsdS5hbkVkZ2UpO0w9SS5TeW19Yi5maXhVcHBlckVkZ2U/di5maXhVcHBlckVkZ2UoaSxiLEwpOnYuY29tcHV0ZVdpbmRpbmcoaSx2LmFkZFJlZ2lvbkJlbG93KGksYSxMKSksdi5zd2VlcEV2ZW50KGksdSl9ZWxzZSB2LmFkZFJpZ2h0RWRnZXMoaSxhLHUuYW5FZGdlLHUuYW5FZGdlLG51bGwsITApfX0sdi5zd2VlcEV2ZW50PWZ1bmN0aW9uKGksdSl7aS5ldmVudD11LHYuZGVidWdFdmVudChpKTtmb3IodmFyIGE9dS5hbkVkZ2U7YS5hY3RpdmVSZWdpb249PT1udWxsOylpZihhPWEuT25leHQsYT09PXUuYW5FZGdlKXt2LmNvbm5lY3RMZWZ0VmVydGV4KGksdSk7cmV0dXJufXZhciBoPXYudG9wTGVmdFJlZ2lvbihpLGEuYWN0aXZlUmVnaW9uKTtzKGghPT1udWxsKTt2YXIgYj12LnJlZ2lvbkJlbG93KGgpLEU9Yi5lVXAsQT12LmZpbmlzaExlZnRSZWdpb25zKGksYixudWxsKTtBLk9uZXh0PT09RT92LmNvbm5lY3RSaWdodFZlcnRleChpLGgsQSk6di5hZGRSaWdodEVkZ2VzKGksaCxBLk9uZXh0LEUsRSwhMCl9LHYuYWRkU2VudGluZWw9ZnVuY3Rpb24oaSx1LGEsaCl7dmFyIGI9bmV3IE8sRT1pLm1lc2gubWFrZUVkZ2UoKTtFLk9yZy5zPWEsRS5PcmcudD1oLEUuRHN0LnM9dSxFLkRzdC50PWgsaS5ldmVudD1FLkRzdCxiLmVVcD1FLGIud2luZGluZ051bWJlcj0wLGIuaW5zaWRlPSExLGIuZml4VXBwZXJFZGdlPSExLGIuc2VudGluZWw9ITAsYi5kaXJ0eT0hMSxiLm5vZGVVcD1pLmRpY3QuaW5zZXJ0KGIpfSx2LmluaXRFZGdlRGljdD1mdW5jdGlvbihpKXtpLmRpY3Q9bmV3IGcoaSx2LmVkZ2VMZXEpO3ZhciB1PWkuYm1heFswXS1pLmJtaW5bMF0sYT1pLmJtYXhbMV0taS5ibWluWzFdLGg9aS5ibWluWzBdLXUsYj1pLmJtYXhbMF0rdSxFPWkuYm1pblsxXS1hLEE9aS5ibWF4WzFdK2E7di5hZGRTZW50aW5lbChpLGgsYixFKSx2LmFkZFNlbnRpbmVsKGksaCxiLEEpfSx2LmRvbmVFZGdlRGljdD1mdW5jdGlvbihpKXtmb3IodmFyIHUsYT0wOyh1PWkuZGljdC5taW4oKS5rZXkpIT09bnVsbDspdS5zZW50aW5lbHx8KHModS5maXhVcHBlckVkZ2UpLHMoKythPT09MSkpLHModS53aW5kaW5nTnVtYmVyPT09MCksdi5kZWxldGVSZWdpb24oaSx1KX0sdi5yZW1vdmVEZWdlbmVyYXRlRWRnZXM9ZnVuY3Rpb24oaSl7dmFyIHUsYSxoLGI9aS5tZXNoLmVIZWFkO2Zvcih1PWIubmV4dDt1IT09Yjt1PWEpYT11Lm5leHQsaD11LkxuZXh0LG4udmVydEVxKHUuT3JnLHUuRHN0KSYmdS5MbmV4dC5MbmV4dCE9PXUmJih2LnNwbGljZU1lcmdlVmVydGljZXMoaSxoLHUpLGkubWVzaC5kZWxldGUodSksdT1oLGg9dS5MbmV4dCksaC5MbmV4dD09PXUmJihoIT09dSYmKChoPT09YXx8aD09PWEuU3ltKSYmKGE9YS5uZXh0KSxpLm1lc2guZGVsZXRlKGgpKSwodT09PWF8fHU9PT1hLlN5bSkmJihhPWEubmV4dCksaS5tZXNoLmRlbGV0ZSh1KSl9LHYuaW5pdFByaW9yaXR5UT1mdW5jdGlvbihpKXt2YXIgdSxhLGgsYj0wO2ZvcihoPWkubWVzaC52SGVhZCxhPWgubmV4dDthIT09aDthPWEubmV4dCliKys7Zm9yKGIrPTgsdT1pLnBxPW5ldyBUKGIsbi52ZXJ0TGVxKSxoPWkubWVzaC52SGVhZCxhPWgubmV4dDthIT09aDthPWEubmV4dClhLnBxSGFuZGxlPXUuaW5zZXJ0KGEpO3JldHVybiBhIT09aD8hMToodS5pbml0KCksITApfSx2LmRvbmVQcmlvcml0eVE9ZnVuY3Rpb24oaSl7aS5wcT1udWxsfSx2LnJlbW92ZURlZ2VuZXJhdGVGYWNlcz1mdW5jdGlvbihpLHUpe3ZhciBhLGgsYjtmb3IoYT11LmZIZWFkLm5leHQ7YSE9PXUuZkhlYWQ7YT1oKWg9YS5uZXh0LGI9YS5hbkVkZ2UscyhiLkxuZXh0IT09YiksYi5MbmV4dC5MbmV4dD09PWImJih2LmFkZFdpbmRpbmcoYi5PbmV4dCxiKSxpLm1lc2guZGVsZXRlKGIpKTtyZXR1cm4hMH0sdi5jb21wdXRlSW50ZXJpb3I9ZnVuY3Rpb24oaSl7dmFyIHUsYTtpZih2LnJlbW92ZURlZ2VuZXJhdGVFZGdlcyhpKSwhdi5pbml0UHJpb3JpdHlRKGkpKXJldHVybiExO2Zvcih2LmluaXRFZGdlRGljdChpKTsodT1pLnBxLmV4dHJhY3RNaW4oKSkhPT1udWxsOyl7Zm9yKDthPWkucHEubWluKCksIShhPT09bnVsbHx8IW4udmVydEVxKGEsdSkpOylhPWkucHEuZXh0cmFjdE1pbigpLHYuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhpLHUuYW5FZGdlLGEuYW5FZGdlKTt2LnN3ZWVwRXZlbnQoaSx1KX1yZXR1cm4gaS5ldmVudD1pLmRpY3QubWluKCkua2V5LmVVcC5Pcmcsdi5kZWJ1Z0V2ZW50KGkpLHYuZG9uZUVkZ2VEaWN0KGkpLHYuZG9uZVByaW9yaXR5UShpKSx2LnJlbW92ZURlZ2VuZXJhdGVGYWNlcyhpLGkubWVzaCk/KGkubWVzaC5jaGVjaygpLCEwKTohMX07ZnVuY3Rpb24gUCgpe3RoaXMubWVzaD1udWxsLHRoaXMubm9ybWFsPVswLDAsMF0sdGhpcy5zVW5pdD1bMCwwLDBdLHRoaXMudFVuaXQ9WzAsMCwwXSx0aGlzLmJtaW49WzAsMF0sdGhpcy5ibWF4PVswLDBdLHRoaXMud2luZGluZ1J1bGU9ci5XSU5ESU5HX09ERCx0aGlzLmRpY3Q9bnVsbCx0aGlzLnBxPW51bGwsdGhpcy5ldmVudD1udWxsLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhDb3VudD0wLHRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50Q291bnQ9MH1QLnByb3RvdHlwZT17ZG90XzpmdW5jdGlvbihpLHUpe3JldHVybiBpWzBdKnVbMF0raVsxXSp1WzFdK2lbMl0qdVsyXX0sbm9ybWFsaXplXzpmdW5jdGlvbihpKXt2YXIgdT1pWzBdKmlbMF0raVsxXSppWzFdK2lbMl0qaVsyXTtzKHU+MCksdT1NYXRoLnNxcnQodSksaVswXS89dSxpWzFdLz11LGlbMl0vPXV9LGxvbmdBeGlzXzpmdW5jdGlvbihpKXt2YXIgdT0wO3JldHVybiBNYXRoLmFicyhpWzFdKT5NYXRoLmFicyhpWzBdKSYmKHU9MSksTWF0aC5hYnMoaVsyXSk+TWF0aC5hYnMoaVt1XSkmJih1PTIpLHV9LGNvbXB1dGVOb3JtYWxfOmZ1bmN0aW9uKGkpe3ZhciB1LGEsaCxiLEUsQSxMPVswLDAsMF0sUz1bMCwwLDBdLEk9WzAsMCwwXSxEPVswLDAsMF0sUj1bMCwwLDBdLEM9W251bGwsbnVsbCxudWxsXSxqPVtudWxsLG51bGwsbnVsbF0sJD10aGlzLm1lc2gudkhlYWQsSDtmb3IodT0kLm5leHQsSD0wO0g8MzsrK0gpYj11LmNvb3Jkc1tIXSxTW0hdPWIsaltIXT11LExbSF09YixDW0hdPXU7Zm9yKHU9JC5uZXh0O3UhPT0kO3U9dS5uZXh0KWZvcihIPTA7SDwzOysrSCliPXUuY29vcmRzW0hdLGI8U1tIXSYmKFNbSF09YixqW0hdPXUpLGI+TFtIXSYmKExbSF09YixDW0hdPXUpO2lmKEg9MCxMWzFdLVNbMV0+TFswXS1TWzBdJiYoSD0xKSxMWzJdLVNbMl0+TFtIXS1TW0hdJiYoSD0yKSxTW0hdPj1MW0hdKXtpWzBdPTAsaVsxXT0wLGlbMl09MTtyZXR1cm59Zm9yKEE9MCxhPWpbSF0saD1DW0hdLElbMF09YS5jb29yZHNbMF0taC5jb29yZHNbMF0sSVsxXT1hLmNvb3Jkc1sxXS1oLmNvb3Jkc1sxXSxJWzJdPWEuY29vcmRzWzJdLWguY29vcmRzWzJdLHU9JC5uZXh0O3UhPT0kO3U9dS5uZXh0KURbMF09dS5jb29yZHNbMF0taC5jb29yZHNbMF0sRFsxXT11LmNvb3Jkc1sxXS1oLmNvb3Jkc1sxXSxEWzJdPXUuY29vcmRzWzJdLWguY29vcmRzWzJdLFJbMF09SVsxXSpEWzJdLUlbMl0qRFsxXSxSWzFdPUlbMl0qRFswXS1JWzBdKkRbMl0sUlsyXT1JWzBdKkRbMV0tSVsxXSpEWzBdLEU9UlswXSpSWzBdK1JbMV0qUlsxXStSWzJdKlJbMl0sRT5BJiYoQT1FLGlbMF09UlswXSxpWzFdPVJbMV0saVsyXT1SWzJdKTtBPD0wJiYoaVswXT1pWzFdPWlbMl09MCxpW3RoaXMubG9uZ0F4aXNfKEkpXT0xKX0sY2hlY2tPcmllbnRhdGlvbl86ZnVuY3Rpb24oKXt2YXIgaSx1LGE9dGhpcy5tZXNoLmZIZWFkLGgsYj10aGlzLm1lc2gudkhlYWQsRTtmb3IoaT0wLHU9YS5uZXh0O3UhPT1hO3U9dS5uZXh0KWlmKEU9dS5hbkVkZ2UsIShFLndpbmRpbmc8PTApKWRvIGkrPShFLk9yZy5zLUUuRHN0LnMpKihFLk9yZy50K0UuRHN0LnQpLEU9RS5MbmV4dDt3aGlsZShFIT09dS5hbkVkZ2UpO2lmKGk8MCl7Zm9yKGg9Yi5uZXh0O2ghPT1iO2g9aC5uZXh0KWgudD0taC50O3RoaXMudFVuaXRbMF09LXRoaXMudFVuaXRbMF0sdGhpcy50VW5pdFsxXT0tdGhpcy50VW5pdFsxXSx0aGlzLnRVbml0WzJdPS10aGlzLnRVbml0WzJdfX0scHJvamVjdFBvbHlnb25fOmZ1bmN0aW9uKCl7dmFyIGksdT10aGlzLm1lc2gudkhlYWQsYT1bMCwwLDBdLGgsYixFLEEsTD0hMTtmb3IoYVswXT10aGlzLm5vcm1hbFswXSxhWzFdPXRoaXMubm9ybWFsWzFdLGFbMl09dGhpcy5ub3JtYWxbMl0sYVswXT09PTAmJmFbMV09PT0wJiZhWzJdPT09MCYmKHRoaXMuY29tcHV0ZU5vcm1hbF8oYSksTD0hMCksaD10aGlzLnNVbml0LGI9dGhpcy50VW5pdCxFPXRoaXMubG9uZ0F4aXNfKGEpLGhbRV09MCxoWyhFKzEpJTNdPTEsaFsoRSsyKSUzXT0wLGJbRV09MCxiWyhFKzEpJTNdPTAsYlsoRSsyKSUzXT1hW0VdPjA/MTotMSxpPXUubmV4dDtpIT09dTtpPWkubmV4dClpLnM9dGhpcy5kb3RfKGkuY29vcmRzLGgpLGkudD10aGlzLmRvdF8oaS5jb29yZHMsYik7Zm9yKEwmJnRoaXMuY2hlY2tPcmllbnRhdGlvbl8oKSxBPSEwLGk9dS5uZXh0O2khPT11O2k9aS5uZXh0KUE/KHRoaXMuYm1pblswXT10aGlzLmJtYXhbMF09aS5zLHRoaXMuYm1pblsxXT10aGlzLmJtYXhbMV09aS50LEE9ITEpOihpLnM8dGhpcy5ibWluWzBdJiYodGhpcy5ibWluWzBdPWkucyksaS5zPnRoaXMuYm1heFswXSYmKHRoaXMuYm1heFswXT1pLnMpLGkudDx0aGlzLmJtaW5bMV0mJih0aGlzLmJtaW5bMV09aS50KSxpLnQ+dGhpcy5ibWF4WzFdJiYodGhpcy5ibWF4WzFdPWkudCkpfSxhZGRXaW5kaW5nXzpmdW5jdGlvbihpLHUpe2kud2luZGluZys9dS53aW5kaW5nLGkuU3ltLndpbmRpbmcrPXUuU3ltLndpbmRpbmd9LHRlc3NlbGxhdGVNb25vUmVnaW9uXzpmdW5jdGlvbihpLHUpe3ZhciBhLGg7Zm9yKGE9dS5hbkVkZ2UscyhhLkxuZXh0IT09YSYmYS5MbmV4dC5MbmV4dCE9PWEpO24udmVydExlcShhLkRzdCxhLk9yZyk7YT1hLkxwcmV2KTtmb3IoO24udmVydExlcShhLk9yZyxhLkRzdCk7YT1hLkxuZXh0KTtmb3IoaD1hLkxwcmV2O2EuTG5leHQhPT1oOylpZihuLnZlcnRMZXEoYS5Ec3QsaC5PcmcpKXtmb3IoO2guTG5leHQhPT1hJiYobi5lZGdlR29lc0xlZnQoaC5MbmV4dCl8fG4uZWRnZVNpZ24oaC5PcmcsaC5Ec3QsaC5MbmV4dC5Ec3QpPD0wKTspe3ZhciBiPWkuY29ubmVjdChoLkxuZXh0LGgpO2g9Yi5TeW19aD1oLkxwcmV2fWVsc2V7Zm9yKDtoLkxuZXh0IT09YSYmKG4uZWRnZUdvZXNSaWdodChhLkxwcmV2KXx8bi5lZGdlU2lnbihhLkRzdCxhLk9yZyxhLkxwcmV2Lk9yZyk+PTApOyl7dmFyIGI9aS5jb25uZWN0KGEsYS5McHJldik7YT1iLlN5bX1hPWEuTG5leHR9Zm9yKHMoaC5MbmV4dCE9PWEpO2guTG5leHQuTG5leHQhPT1hOyl7dmFyIGI9aS5jb25uZWN0KGguTG5leHQsaCk7aD1iLlN5bX1yZXR1cm4hMH0sdGVzc2VsbGF0ZUludGVyaW9yXzpmdW5jdGlvbihpKXt2YXIgdSxhO2Zvcih1PWkuZkhlYWQubmV4dDt1IT09aS5mSGVhZDt1PWEpaWYoYT11Lm5leHQsdS5pbnNpZGUmJiF0aGlzLnRlc3NlbGxhdGVNb25vUmVnaW9uXyhpLHUpKXJldHVybiExO3JldHVybiEwfSxkaXNjYXJkRXh0ZXJpb3JfOmZ1bmN0aW9uKGkpe3ZhciB1LGE7Zm9yKHU9aS5mSGVhZC5uZXh0O3UhPT1pLmZIZWFkO3U9YSlhPXUubmV4dCx1Lmluc2lkZXx8aS56YXBGYWNlKHUpfSxzZXRXaW5kaW5nTnVtYmVyXzpmdW5jdGlvbihpLHUsYSl7dmFyIGgsYjtmb3IoaD1pLmVIZWFkLm5leHQ7aCE9PWkuZUhlYWQ7aD1iKWI9aC5uZXh0LGguUmZhY2UuaW5zaWRlIT09aC5MZmFjZS5pbnNpZGU/aC53aW5kaW5nPWguTGZhY2UuaW5zaWRlP3U6LXU6YT9pLmRlbGV0ZShoKTpoLndpbmRpbmc9MH0sZ2V0TmVpZ2hib3VyRmFjZV86ZnVuY3Rpb24oaSl7cmV0dXJuIWkuUmZhY2V8fCFpLlJmYWNlLmluc2lkZT8tMTppLlJmYWNlLm59LG91dHB1dFBvbHltZXNoXzpmdW5jdGlvbihpLHUsYSxoKXt2YXIgYixFLEEsTD0wLFM9MCxJLEQ7Zm9yKGE+MyYmaS5tZXJnZUNvbnZleEZhY2VzKGEpLGI9aS52SGVhZC5uZXh0O2IhPT1pLnZIZWFkO2I9Yi5uZXh0KWIubj0tMTtmb3IoRT1pLmZIZWFkLm5leHQ7RSE9PWkuZkhlYWQ7RT1FLm5leHQpaWYoRS5uPS0xLCEhRS5pbnNpZGUpe0E9RS5hbkVkZ2UsST0wO2RvIGI9QS5PcmcsYi5uPT09LTEmJihiLm49UyxTKyspLEkrKyxBPUEuTG5leHQ7d2hpbGUoQSE9PUUuYW5FZGdlKTtzKEk8PWEpLEUubj1MLCsrTH1mb3IodGhpcy5lbGVtZW50Q291bnQ9TCx1PT09ci5DT05ORUNURURfUE9MWUdPTlMmJihMKj0yKSx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPUwqYSx0aGlzLnZlcnRleENvdW50PVMsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD1TKmgsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9UyxiPWkudkhlYWQubmV4dDtiIT09aS52SGVhZDtiPWIubmV4dClpZihiLm4hPT0tMSl7dmFyIFI9Yi5uKmg7dGhpcy52ZXJ0aWNlc1tSKzBdPWIuY29vcmRzWzBdLHRoaXMudmVydGljZXNbUisxXT1iLmNvb3Jkc1sxXSxoPjImJih0aGlzLnZlcnRpY2VzW1IrMl09Yi5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tiLm5dPWIuaWR4fXZhciBDPTA7Zm9yKEU9aS5mSGVhZC5uZXh0O0UhPT1pLmZIZWFkO0U9RS5uZXh0KWlmKEUuaW5zaWRlKXtBPUUuYW5FZGdlLEk9MDtkbyBiPUEuT3JnLHRoaXMuZWxlbWVudHNbQysrXT1iLm4sSSsrLEE9QS5MbmV4dDt3aGlsZShBIT09RS5hbkVkZ2UpO2ZvcihEPUk7RDxhOysrRCl0aGlzLmVsZW1lbnRzW0MrK109LTE7aWYodT09PXIuQ09OTkVDVEVEX1BPTFlHT05TKXtBPUUuYW5FZGdlO2RvIHRoaXMuZWxlbWVudHNbQysrXT10aGlzLmdldE5laWdoYm91ckZhY2VfKEEpLEE9QS5MbmV4dDt3aGlsZShBIT09RS5hbkVkZ2UpO2ZvcihEPUk7RDxhOysrRCl0aGlzLmVsZW1lbnRzW0MrK109LTF9fX0sb3V0cHV0Q29udG91cnNfOmZ1bmN0aW9uKGksdSl7dmFyIGEsaCxiLEU9MCxBPTA7Zm9yKHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRDb3VudD0wLGE9aS5mSGVhZC5uZXh0O2EhPT1pLmZIZWFkO2E9YS5uZXh0KWlmKGEuaW5zaWRlKXtiPWg9YS5hbkVkZ2U7ZG8gdGhpcy52ZXJ0ZXhDb3VudCsrLGg9aC5MbmV4dDt3aGlsZShoIT09Yik7dGhpcy5lbGVtZW50Q291bnQrK310aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPXRoaXMuZWxlbWVudENvdW50KjIsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD10aGlzLnZlcnRleENvdW50KnUsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudDt2YXIgTD0wLFM9MCxJPTA7Zm9yKEU9MCxhPWkuZkhlYWQubmV4dDthIT09aS5mSGVhZDthPWEubmV4dClpZihhLmluc2lkZSl7QT0wLGI9aD1hLmFuRWRnZTtkbyB0aGlzLnZlcnRpY2VzW0wrK109aC5PcmcuY29vcmRzWzBdLHRoaXMudmVydGljZXNbTCsrXT1oLk9yZy5jb29yZHNbMV0sdT4yJiYodGhpcy52ZXJ0aWNlc1tMKytdPWguT3JnLmNvb3Jkc1syXSksdGhpcy52ZXJ0ZXhJbmRpY2VzW1MrK109aC5PcmcuaWR4LEErKyxoPWguTG5leHQ7d2hpbGUoaCE9PWIpO3RoaXMuZWxlbWVudHNbSSsrXT1FLHRoaXMuZWxlbWVudHNbSSsrXT1BLEUrPUF9fSxhZGRDb250b3VyOmZ1bmN0aW9uKGksdSl7dmFyIGEsaDtmb3IodGhpcy5tZXNoPT09bnVsbCYmKHRoaXMubWVzaD1uZXcgZiksaTwyJiYoaT0yKSxpPjMmJihpPTMpLGE9bnVsbCxoPTA7aDx1Lmxlbmd0aDtoKz1pKWE9PT1udWxsPyhhPXRoaXMubWVzaC5tYWtlRWRnZSgpLHRoaXMubWVzaC5zcGxpY2UoYSxhLlN5bSkpOih0aGlzLm1lc2guc3BsaXRFZGdlKGEpLGE9YS5MbmV4dCksYS5PcmcuY29vcmRzWzBdPXVbaCswXSxhLk9yZy5jb29yZHNbMV09dVtoKzFdLGk+Mj9hLk9yZy5jb29yZHNbMl09dVtoKzJdOmEuT3JnLmNvb3Jkc1syXT0wLGEuT3JnLmlkeD10aGlzLnZlcnRleEluZGV4Q291bnRlcisrLGEud2luZGluZz0xLGEuU3ltLndpbmRpbmc9LTF9LHRlc3NlbGF0ZTpmdW5jdGlvbihpLHUsYSxoLGIpe2lmKHRoaXMudmVydGljZXM9W10sdGhpcy5lbGVtZW50cz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXI9MCxiJiYodGhpcy5ub3JtYWxbMF09YlswXSx0aGlzLm5vcm1hbFsxXT1iWzFdLHRoaXMubm9ybWFsWzJdPWJbMl0pLHRoaXMud2luZGluZ1J1bGU9aSxoPDImJihoPTIpLGg+MyYmKGg9MyksIXRoaXMubWVzaClyZXR1cm4hMTt0aGlzLnByb2plY3RQb2x5Z29uXygpLHYuY29tcHV0ZUludGVyaW9yKHRoaXMpO3ZhciBFPXRoaXMubWVzaDtyZXR1cm4gdT09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5zZXRXaW5kaW5nTnVtYmVyXyhFLDEsITApOnRoaXMudGVzc2VsbGF0ZUludGVyaW9yXyhFKSxFLmNoZWNrKCksdT09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5vdXRwdXRDb250b3Vyc18oRSxoKTp0aGlzLm91dHB1dFBvbHltZXNoXyhFLHUsYSxoKSwhMH19fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1yO3ZhciB0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gcigpe2Zvcih2YXIgbj17fSxzPTA7czxhcmd1bWVudHMubGVuZ3RoO3MrKyl7dmFyIGw9YXJndW1lbnRzW3NdO2Zvcih2YXIgYyBpbiBsKXQuY2FsbChsLGMpJiYobltjXT1sW2NdKX1yZXR1cm4gbn19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZVNoYWRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiYXBwbHlTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY3JlYXRlQ2xvdWRTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImFwcGx5Q2xvdWRTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDY0KSxuPXQoNjUpLHM9dCg2NiksbD10KDY3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYz1TeW1ib2woInNoYWRlcnMiKTtmdW5jdGlvbiBvKG0pe21bY109W107Zm9yKGxldCBUPTA7VDwxNjtUKyspe2NvbnN0IE89W10sdj0hIShUJjEpLFA9ISEoVCYyKSxpPSEhKFQmNCksdT0hIShUJjgpO3YmJk8ucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxQJiZPLnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxpJiZPLnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLHUmJk8ucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3QgYT1gJHtPLmpvaW4oYApgKX0KYCxoPVtdO3YmJmgucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpLHUmJmgucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV9jbGlwU2FtcGxlcjsiKSxtW2NdW1RdPVthK2guam9pbihgCmApK24uZGVmYXVsdCxhK3IuZGVmYXVsdF19fWZ1bmN0aW9uIGYobSx7aGFzVGV4dHVyZTpUPSExLGhhc0ZpbHRlcjpPPSExLGhhc0dyYWRpZW50OnY9ITEsaGFzQ2xpcFBhdGg6UD0hMX09e30pe2NvbnN0IGk9VHxPPDwxfHY8PDJ8UDw8MztsZXQgdT1tW2NdW2ldO0FycmF5LmlzQXJyYXkodSkmJih1PW0uY3JlYXRlUHJvZ3JhbSguLi51KSxtW2NdW2ldPXUpLG0ucHJvZ3JhbSE9PXUmJm0udXNlUHJvZ3JhbSh1LHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSl9Y29uc3QgeD1bXTtmdW5jdGlvbiBnKG0pe2ZvcihsZXQgVD0wO1Q8NjQ7VCsrKXtjb25zdCBPPVtdLHY9ISEoVCYxKSxQPSEhKFQmMiksaT0hIShUJjQpLHU9ISEoVCY4KSxhPSEhKFQmMTYpLGg9ISEoVCYzMik7diYmTy5wdXNoKCIjZGVmaW5lIFRFWFRVUkUgMSIpLFAmJk8ucHVzaCgiI2RlZmluZSBGSUxURVIgMSIpLGkmJk8ucHVzaCgiI2RlZmluZSBHUkFESUVOVCAxIiksdSYmTy5wdXNoKCIjZGVmaW5lIENMT1VEQ09MT1IgMSIpLGEmJk8ucHVzaCgiI2RlZmluZSBDTE9VREZJTFRFUiAxIiksaCYmTy5wdXNoKCIjZGVmaW5lIENMSVBQQVRIIDEiKTtjb25zdCBiPWAke08uam9pbihgCmApfQpgLEU9W107aWYodil7RS5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7Iik7Zm9yKGxldCBBPTA7QTwxMjtBKyspRS5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleEZyYW1lJHtBfTtgKX1oJiZFLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IikseFtUXT1bYitFLmpvaW4oYApgKStsLmRlZmF1bHQsYitzLmRlZmF1bHRdfX1mdW5jdGlvbiB5KG0se2hhc1RleHR1cmU6VD0hMSxoYXNGaWx0ZXI6Tz0hMSxoYXNHcmFkaWVudDp2PSExLGhhc0Nsb3VkQ29sb3I6UD0hMSxoYXNDbG91ZEZpbHRlcjppPSExLGhhc0NsaXBQYXRoOnU9ITF9PXt9KXtjb25zdCBhPVR8Tzw8MXx2PDwyfFA8PDN8aTw8NHx1PDw1O2xldCBoPXhbYV07QXJyYXkuaXNBcnJheShoKSYmKGg9bS5jcmVhdGVQcm9ncmFtKC4uLmgpLHhbYV09aCksbS5wcm9ncmFtIT09aCYmbS51c2VQcm9ncmFtKGgse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSl9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKI2lmZGVmIFRFWFRVUkUKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsKCiNpZmRlZiBHUkFESUVOVAogIHZlYzMgdmcxID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclswXSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsxXSwgMS4wKTsKICB2ZWMzIHZnMiA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbM10sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNF0sIDEuMCk7CiAgZmxvYXQgaCA9IHVfcmVzb2x1dGlvbi55OwogIHZnMS55ID0gaCAtIHZnMS55OwogIHZnMi55ID0gaCAtIHZnMi55OwogIHZHcmFkaWVudFZlY3RvcjEgPSB2ZWMzKHZnMS54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsyXSk7CiAgdkdyYWRpZW50VmVjdG9yMiA9IHZlYzModmcyLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzVdKTsKI2VuZGlmCiAgCiAgZmxhZ0JhY2tncm91bmQgPSBhX3ZlcnRleFBvc2l0aW9uLno7CiAgdkNvbG9yID0gYV9jb2xvcjsKCiNpZmRlZiBURVhUVVJFCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCn1gfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp1bmlmb3JtIGludCB1X2ZpbHRlckZsYWc7CnVuaWZvcm0gZmxvYXQgdV9jb2xvck1hdHJpeFsyMF07CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKLy8gdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgojaWZkZWYgRklMVEVSCnZvaWQgdHJhbnNmb3JtQ29sb3IoaW5vdXQgdmVjNCBjb2xvciwgaW4gZmxvYXQgY29sb3JNYXRyaXhbMjBdKSB7CiAgZmxvYXQgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgYSA9IGNvbG9yLmE7CiAgY29sb3JbMF0gPSBjb2xvck1hdHJpeFswXSAqIHIgKyBjb2xvck1hdHJpeFsxXSAqIGcgKyBjb2xvck1hdHJpeFsyXSAqIGIgKyBjb2xvck1hdHJpeFszXSAqIGEgKyBjb2xvck1hdHJpeFs0XTsKICBjb2xvclsxXSA9IGNvbG9yTWF0cml4WzVdICogciArIGNvbG9yTWF0cml4WzZdICogZyArIGNvbG9yTWF0cml4WzddICogYiArIGNvbG9yTWF0cml4WzhdICogYSArIGNvbG9yTWF0cml4WzldOwogIGNvbG9yWzJdID0gY29sb3JNYXRyaXhbMTBdICogciArIGNvbG9yTWF0cml4WzExXSAqIGcgKyBjb2xvck1hdHJpeFsxMl0gKiBiICsgY29sb3JNYXRyaXhbMTNdICogYSArIGNvbG9yTWF0cml4WzE0XTsKICBjb2xvclszXSA9IGNvbG9yTWF0cml4WzE1XSAqIHIgKyBjb2xvck1hdHJpeFsxNl0gKiBnICsgY29sb3JNYXRyaXhbMTddICogYiArIGNvbG9yTWF0cml4WzE4XSAqIGEgKyBjb2xvck1hdHJpeFsxOV07Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgIHRleENvbG9yLmEgKj0gb3BhY2l0eTsKICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgIH0KICAgICAgLy8gY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY2xhbXAoY29sb3IuYSAvIG1heCgwLjAwMDEsIHRleENvbG9yLmEpLCAwLjAsIDEuMCkpOwogICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIGZsb2F0IGNsaXAgPSB0ZXh0dXJlMkQodV9jbGlwU2FtcGxlciwgdkNsaXBVVikucjsKICBjb2xvciAqPSBjbGlwOwojZW5kaWYKCiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7Cn1gfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0wOwphdHRyaWJ1dGUgdmVjMyBhX3RyYW5zZm9ybTE7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIGZsb2F0IGFfZnJhbWVJbmRleDsKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4OwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQwOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQxOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQyOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQzOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQ0Owp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgQ0xPVURDT0xPUgphdHRyaWJ1dGUgdmVjNCBhX2ZpbGxDbG91ZENvbG9yOwphdHRyaWJ1dGUgdmVjNCBhX3N0cm9rZUNsb3VkQ29sb3I7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwojZW5kaWYKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CgogIG1hdDMgbW9kZWxNYXRyaXggPSBtYXQzKAogICAgYV90cmFuc2Zvcm0wLngsIGFfdHJhbnNmb3JtMS54LCAwLCAKICAgIGFfdHJhbnNmb3JtMC55LCBhX3RyYW5zZm9ybTEueSwgMCwKICAgIGFfdHJhbnNmb3JtMC56LCBhX3RyYW5zZm9ybTEueiwgMQogICk7CgogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwoKI2lmZGVmIENMT1VEQ09MT1IKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdkNvbG9yID0gbWl4KGFfY29sb3IsIGFfZmlsbENsb3VkQ29sb3IsIGFfZmlsbENsb3VkQ29sb3IuYSk7CiAgfSBlbHNlIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IsIGFfc3Ryb2tlQ2xvdWRDb2xvci5hKTsKICB9CiNlbHNlCiAgdkNvbG9yID0gYV9jb2xvcjsKI2VuZGlmCgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICBmcmFtZUluZGV4ID0gYV9mcmFtZUluZGV4OwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKICBjb2xvckNsb3VkMCA9IGFfY29sb3JDbG91ZDA7CiAgY29sb3JDbG91ZDEgPSBhX2NvbG9yQ2xvdWQxOwogIGNvbG9yQ2xvdWQyID0gYV9jb2xvckNsb3VkMjsKICBjb2xvckNsb3VkMyA9IGFfY29sb3JDbG91ZDM7CiAgY29sb3JDbG91ZDQgPSBhX2NvbG9yQ2xvdWQ0OwojZW5kaWYKfWB9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CgojaWZkZWYgVEVYVFVSRQp2YXJ5aW5nIGZsb2F0IGZyYW1lSW5kZXg7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JTdGVwc1s0MF07CnVuaWZvcm0gaW50IHVfZ3JhZGllbnRUeXBlOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CgojaWZkZWYgQ0xPVURGSUxURVIKdm9pZCBidWlsZENsb3VkQ29sb3IoaW5vdXQgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF0pIHsKICBjb2xvckNsb3VkTWF0cml4WzBdID0gY29sb3JDbG91ZDBbMF07CiAgY29sb3JDbG91ZE1hdHJpeFsxXSA9IGNvbG9yQ2xvdWQxWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMl0gPSBjb2xvckNsb3VkMlswXTsKICBjb2xvckNsb3VkTWF0cml4WzNdID0gY29sb3JDbG91ZDNbMF07CiAgY29sb3JDbG91ZE1hdHJpeFs0XSA9IGNvbG9yQ2xvdWQ0WzBdOwoKICBjb2xvckNsb3VkTWF0cml4WzVdID0gY29sb3JDbG91ZDBbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs2XSA9IGNvbG9yQ2xvdWQxWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbN10gPSBjb2xvckNsb3VkMlsxXTsKICBjb2xvckNsb3VkTWF0cml4WzhdID0gY29sb3JDbG91ZDNbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs5XSA9IGNvbG9yQ2xvdWQ0WzFdOwoKICBjb2xvckNsb3VkTWF0cml4WzEwXSA9IGNvbG9yQ2xvdWQwWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTFdID0gY29sb3JDbG91ZDFbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxMl0gPSBjb2xvckNsb3VkMlsyXTsKICBjb2xvckNsb3VkTWF0cml4WzEzXSA9IGNvbG9yQ2xvdWQzWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTRdID0gY29sb3JDbG91ZDRbMl07CgogIGNvbG9yQ2xvdWRNYXRyaXhbMTVdID0gY29sb3JDbG91ZDBbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxNl0gPSBjb2xvckNsb3VkMVszXTsKICBjb2xvckNsb3VkTWF0cml4WzE3XSA9IGNvbG9yQ2xvdWQyWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMThdID0gY29sb3JDbG91ZDNbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxOV0gPSBjb2xvckNsb3VkNFszXTsKfQojZW5kaWYKCnZvaWQgbWFpbigpIHsKICB2ZWM0IGNvbG9yID0gdkNvbG9yOwogIGZsb2F0IG9wYWNpdHkgPSBhYnMoZmxhZ0JhY2tncm91bmQpOwoKI2lmZGVmIEdSQURJRU5UCiAgaWYodV9ncmFkaWVudFR5cGUgPiAwICYmIGZsYWdCYWNrZ3JvdW5kID4gMC4wIHx8IHVfZ3JhZGllbnRUeXBlID09IDAgJiYgZmxhZ0JhY2tncm91bmQgPD0gMC4wKSB7CiAgICBncmFkaWVudChjb2xvciwgdkdyYWRpZW50VmVjdG9yMSwgdkdyYWRpZW50VmVjdG9yMiwgdV9jb2xvclN0ZXBzKTsKICB9CiNlbmRpZgoKICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICBjb2xvci5hICo9IG9wYWNpdHk7CiAgfQoKI2lmZGVmIFRFWFRVUkUKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdmVjMyB0ZXhDb29yZCA9IHZUZXh0dXJlQ29vcmQ7CgogICAgaWYodGV4Q29vcmQueiA9PSAxLjApIHsKICAgICAgdGV4Q29vcmQgPSBmcmFjdCh0ZXhDb29yZCk7CiAgICB9CgogICAgaWYodGV4Q29vcmQueCA8PSAxLjAgJiYgdGV4Q29vcmQueCA+PSAwLjAKICAgICAgJiYgdGV4Q29vcmQueSA8PSAxLjAgJiYgdGV4Q29vcmQueSA+PSAwLjApIHsKICAgICAgaWYodlNvdXJjZVJlY3QueiA+IDAuMCkgewogICAgICAgIHRleENvb3JkLnggPSB2U291cmNlUmVjdC54ICsgdGV4Q29vcmQueCAqIHZTb3VyY2VSZWN0Lno7CiAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtICh2U291cmNlUmVjdC55ICsgKDEuMCAtIHRleENvb3JkLnkpICogdlNvdXJjZVJlY3Qudyk7CiAgICAgIH0KICAgICAgaWYoZnJhbWVJbmRleCA8IDAuMCkgewogICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgICAgY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbnQgaW5kZXggPSBpbnQoZmxvb3IoY2xhbXAoMC4wLCAxMS4wLCBmcmFtZUluZGV4KSkpOwogICAgICAgIHZlYzQgdGV4Q29sb3I7CiAgICAgICAgaWYoaW5kZXggPT0gMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAyKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMiwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMykgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTMsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDQpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU0LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA1KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTYsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDcpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU3LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA4KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lOCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTksIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEwKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgICAgfQogICAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgICAgLy8gY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjb2xvci5hKTsKICAgICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICAgIH0KICAgIH0KICB9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgogIGlmKHVfZmlsdGVyRmxhZyA+IDApIHsKICAgIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCB1X2NvbG9yTWF0cml4KTsKICB9CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF07CiAgYnVpbGRDbG91ZENvbG9yKGNvbG9yQ2xvdWRNYXRyaXgpOwogIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCBjb2xvckNsb3VkTWF0cml4KTsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSwoZnVuY3Rpb24ocixuKXt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBjfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHMoKXtpZih0eXBlb2YgcGVyZm9ybWFuY2U8InUiJiZwZXJmb3JtYW5jZS5ub3cpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKHR5cGVvZiByPCJ1IiYmci5ocnRpbWUpe2NvbnN0W28sZl09ci5ocnRpbWUoKTtyZXR1cm4gbyoxZTMrZioxZS02fXJldHVybiBEYXRlLm5vdz9EYXRlLm5vdygpOm5ldyBEYXRlKCkuZ2V0VGltZSgpfWxldCBsLGM7dHlwZW9mIG48InUiJiZ0eXBlb2Ygbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9PSJmdW5jdGlvbiI/KGw9bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsYz1uLmNhbmNlbEFuaW1hdGlvbkZyYW1lKToobD1mdW5jdGlvbihvKXtyZXR1cm4gc2V0VGltZW91dCgoKT0+e28ocygpKX0sMTYpfSxjPWZ1bmN0aW9uKG8pe3JldHVybiBjbGVhclRpbWVvdXQobyl9KX0pLmNhbGwodGhpcyx0KDY5KSx0KDIyKSl9LGZ1bmN0aW9uKGQsZSl7dmFyIHQ9ZC5leHBvcnRzPXt9LHIsbjtmdW5jdGlvbiBzKCl7dGhyb3cgbmV3IEVycm9yKCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9ZnVuY3Rpb24gbCgpe3Rocm93IG5ldyBFcnJvcigiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9KGZ1bmN0aW9uKCl7dHJ5e3R5cGVvZiBzZXRUaW1lb3V0PT0iZnVuY3Rpb24iP3I9c2V0VGltZW91dDpyPXN9Y2F0Y2h7cj1zfXRyeXt0eXBlb2YgY2xlYXJUaW1lb3V0PT0iZnVuY3Rpb24iP249Y2xlYXJUaW1lb3V0Om49bH1jYXRjaHtuPWx9fSkoKTtmdW5jdGlvbiBjKFApe2lmKHI9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KFAsMCk7aWYoKHI9PT1zfHwhcikmJnNldFRpbWVvdXQpcmV0dXJuIHI9c2V0VGltZW91dCxzZXRUaW1lb3V0KFAsMCk7dHJ5e3JldHVybiByKFAsMCl9Y2F0Y2h7dHJ5e3JldHVybiByLmNhbGwobnVsbCxQLDApfWNhdGNoe3JldHVybiByLmNhbGwodGhpcyxQLDApfX19ZnVuY3Rpb24gbyhQKXtpZihuPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQoUCk7aWYoKG49PT1sfHwhbikmJmNsZWFyVGltZW91dClyZXR1cm4gbj1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KFApO3RyeXtyZXR1cm4gbihQKX1jYXRjaHt0cnl7cmV0dXJuIG4uY2FsbChudWxsLFApfWNhdGNoe3JldHVybiBuLmNhbGwodGhpcyxQKX19fXZhciBmPVtdLHg9ITEsZyx5PS0xO2Z1bmN0aW9uIG0oKXsheHx8IWd8fCh4PSExLGcubGVuZ3RoP2Y9Zy5jb25jYXQoZik6eT0tMSxmLmxlbmd0aCYmVCgpKX1mdW5jdGlvbiBUKCl7aWYoIXgpe3ZhciBQPWMobSk7eD0hMDtmb3IodmFyIGk9Zi5sZW5ndGg7aTspe2ZvcihnPWYsZj1bXTsrK3k8aTspZyYmZ1t5XS5ydW4oKTt5PS0xLGk9Zi5sZW5ndGh9Zz1udWxsLHg9ITEsbyhQKX19dC5uZXh0VGljaz1mdW5jdGlvbihQKXt2YXIgaT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciB1PTE7dTxhcmd1bWVudHMubGVuZ3RoO3UrKylpW3UtMV09YXJndW1lbnRzW3VdO2YucHVzaChuZXcgTyhQLGkpKSxmLmxlbmd0aD09PTEmJiF4JiZjKFQpfTtmdW5jdGlvbiBPKFAsaSl7dGhpcy5mdW49UCx0aGlzLmFycmF5PWl9Ty5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0sdC50aXRsZT0iYnJvd3NlciIsdC5icm93c2VyPSEwLHQuZW52PXt9LHQuYXJndj1bXSx0LnZlcnNpb249IiIsdC52ZXJzaW9ucz17fTtmdW5jdGlvbiB2KCl7fXQub249dix0LmFkZExpc3RlbmVyPXYsdC5vbmNlPXYsdC5vZmY9dix0LnJlbW92ZUxpc3RlbmVyPXYsdC5yZW1vdmVBbGxMaXN0ZW5lcnM9dix0LmVtaXQ9dix0LnByZXBlbmRMaXN0ZW5lcj12LHQucHJlcGVuZE9uY2VMaXN0ZW5lcj12LHQubGlzdGVuZXJzPWZ1bmN0aW9uKFApe3JldHVybltdfSx0LmJpbmRpbmc9ZnVuY3Rpb24oUCl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCIpfSx0LmN3ZD1mdW5jdGlvbigpe3JldHVybiIvIn0sdC5jaGRpcj1mdW5jdGlvbihQKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCIpfSx0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBBfSk7dmFyIHI9dCgxKSxuPXQoNzEpLHM9dCg3MyksbD10KDIxMyksYz10KDIxNCksbz10KDIxNSksZj10KDIxNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHgoTCxTKXt2YXIgST1PYmplY3Qua2V5cyhMKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKEwpO1MmJihEPUQuZmlsdGVyKGZ1bmN0aW9uKFIpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEwsUikuZW51bWVyYWJsZX0pKSxJLnB1c2guYXBwbHkoSSxEKX1yZXR1cm4gSX1mdW5jdGlvbiBnKEwpe2Zvcih2YXIgUz0xO1M8YXJndW1lbnRzLmxlbmd0aDtTKyspe3ZhciBJPWFyZ3VtZW50c1tTXSE9bnVsbD9hcmd1bWVudHNbU106e307UyUyP3goT2JqZWN0KEkpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEQpe3koTCxELElbRF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhJKSk6eChPYmplY3QoSSkpLmZvckVhY2goZnVuY3Rpb24oRCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KEwsRCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEksRCkpfSl9cmV0dXJuIEx9ZnVuY3Rpb24geShMLFMsSSl7cmV0dXJuIFMgaW4gTD9PYmplY3QuZGVmaW5lUHJvcGVydHkoTCxTLHt2YWx1ZTpJLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6TFtTXT1JLEx9Y29uc3QgbT1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxUPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxPPVN5bWJvbCgicmVzb2x1dGlvbiIpLHY9U3ltYm9sKCJhbmltYXRpb25zIiksUD1TeW1ib2woImV2ZW50TGlzdGVuZXJzIiksaT1TeW1ib2woImNhcHR1cmVFdmVudExpc3RlbmVycyIpLHU9U3ltYm9sKCJmaWx0ZXJzIiksYT1TeW1ib2woImRpc3BsYXkiKSxoPVN5bWJvbCgicHJvZ3JhbSIpLGI9U3ltYm9sKCJzaGFkZXJBdHRycyIpLEU9U3ltYm9sKCJ1bmlmb3JtcyIpO2NsYXNzIEF7Y29uc3RydWN0b3IoUz17fSl7dGhpcy5hdHRyaWJ1dGVzPW5ldyB0aGlzLmNvbnN0cnVjdG9yLkF0dHIodGhpcyksdGhpc1tPXT17d2lkdGg6MzAwLGhlaWdodDoxNTB9LE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLFMpLHRoaXNbdl09bmV3IFNldCx0aGlzW1BdPXt9LHRoaXNbaV09e319Z2V0IGFuY2VzdG9ycygpe2xldCBTPXRoaXMucGFyZW50O2NvbnN0IEk9W107Zm9yKDtTOylJLnB1c2goUyksUz1TLnBhcmVudDtyZXR1cm4gSX1nZXQgYW5pbWF0aW9ucygpe3JldHVybiB0aGlzW3ZdfWdldCBmaWx0ZXJzKCl7cmV0dXJuIHRoaXNbdV18fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5maWx0ZXJzfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hMX1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQubGF5ZXI6bnVsbH1nZXQgbG9jYWxNYXRyaXgoKXtjb25zdCBTPXRoaXMudHJhbnNmb3JtTWF0cml4LHt4OkkseTpEfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIFNbNF0rPUksU1s1XSs9RCxTfWdldCBvcGFjaXR5KCl7bGV0IFM9dGhpcy5hdHRyaWJ1dGVzLm9wYWNpdHk7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcGFjaXR5IT1udWxsJiYoUyo9dGhpcy5wYXJlbnQub3BhY2l0eSksU31nZXQgcGFyZW50Tm9kZSgpe3JldHVybiB0aGlzLnBhcmVudH1nZXQgbmV4dFNpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KDEpfWdldCBwcmV2aW91c1NpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KC0xKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW2hdfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5yZW5kZXJlcjpudWxsfWdldCByZW5kZXJNYXRyaXgoKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXgpcmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeDtsZXQgUz10aGlzLmxvY2FsTWF0cml4O2NvbnN0IEk9dGhpcy5wYXJlbnQ7aWYoSSl7Y29uc3QgRD1JLl9fY2FjaGVSZW5kZXJNYXRyaXh8fEkucmVuZGVyTWF0cml4O0QmJihTPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsUykpfXJldHVybiBTfWdldCB3b3JsZFNjYWxpbmcoKXtjb25zdCBTPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltNYXRoLmh5cG90KFNbMF0sU1sxXSksTWF0aC5oeXBvdChTWzJdLFNbM10pXX1nZXQgd29ybGRSb3RhdGlvbigpe2NvbnN0IFM9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuIE1hdGguYXRhbjIoU1sxXSxTWzNdKX1nZXQgd29ybGRQb3NpdGlvbigpe2NvbnN0IFM9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuW1NbNF0sU1s1XV19Z2V0IHVuaWZvcm1zKCl7cmV0dXJuIHRoaXNbRV19Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuY2xhc3NOYW1lfXNldCBjbGFzc05hbWUoUyl7dGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZT1TfWdldCBpZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuaWR9c2V0IGlkKFMpe3RoaXMuYXR0cmlidXRlcy5pZD1TfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5uYW1lfXNldCBuYW1lKFMpe3RoaXMuYXR0cmlidXRlcy5uYW1lPVN9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuekluZGV4fXNldCB6SW5kZXgoUyl7dGhpcy5hdHRyaWJ1dGVzLnpJbmRleD1TfWdldCBtZXNoKCl7cmV0dXJuIG51bGx9Z2V0IHNoYWRlckF0dHJzKCl7cmV0dXJuIHRoaXNbYl18fHt9fWFjdGl2YXRlQW5pbWF0aW9ucygpe2NvbnN0IFM9dGhpcy5sYXllcjtpZihTKXtjb25zdCBJPXRoaXNbdl07SS5mb3JFYWNoKFI9PntSLmJhc2VUaW1lbGluZT1TLnRpbWVsaW5lLFIucGxheSgpLFIuZmluaXNoZWQudGhlbigoKT0+e0kuZGVsZXRlKFIpfSl9KTtjb25zdCBEPXRoaXMuY2hpbGRyZW47RCYmRC5mb3JFYWNoKFI9PntSLmFjdGl2YXRlQW5pbWF0aW9ucyYmUi5hY3RpdmF0ZUFuaW1hdGlvbnMoKX0pfX1hZGRFdmVudExpc3RlbmVyKFMsSSxEPXt9KXtTPT09Im1vdXNld2hlZWwiJiYoUz0id2hlZWwiKSx0eXBlb2YgRD09ImJvb2xlYW4iJiYoRD17Y2FwdHVyZTpEfSk7Y29uc3R7Y2FwdHVyZTpSLG9uY2U6Q309RCxqPVI/aTpQO3JldHVybiB0aGlzW2pdW1NdPXRoaXNbal1bU118fFtdLHRoaXNbal1bU10ucHVzaCh7bGlzdGVuZXI6SSxvbmNlOkN9KSx0aGlzfWFuaW1hdGUoUyxJKXtjb25zdCBEPW5ldyBzLmRlZmF1bHQodGhpcyxTLEkpO3JldHVybiB0aGlzLmVmZmVjdHMmJkQuYXBwbHlFZmZlY3RzKHRoaXMuZWZmZWN0cyksdGhpcy5sYXllciYmKEQuYmFzZVRpbWVsaW5lPXRoaXMubGF5ZXIudGltZWxpbmUsRC5wbGF5KCksRC5maW5pc2hlZC50aGVuKCgpPT57dGhpc1t2XS5kZWxldGUoRCl9KSksdGhpc1t2XS5hZGQoRCksRH1hdHRyKC4uLlMpe2lmKFMubGVuZ3RoPT09MClyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW1RdO2lmKFMubGVuZ3RoPjEpe2xldFtJLERdPVM7cmV0dXJuIHR5cGVvZiBEPT0iZnVuY3Rpb24iJiYoRD1EKHRoaXMuYXR0cihJKSkpLHRoaXMuc2V0QXR0cmlidXRlKEksRCksdGhpc31yZXR1cm4gdHlwZW9mIFNbMF09PSJzdHJpbmciP3RoaXMuZ2V0QXR0cmlidXRlKFNbMF0pOihPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxTWzBdKSx0aGlzKX1jbG9uZU5vZGUoKXtjb25zdCBTPW5ldyB0aGlzLmNvbnN0cnVjdG9yLEk9dGhpcy5hdHRyaWJ1dGVzW21dO3JldHVybiBTLmF0dHIoSSksU31jb25uZWN0KFMsSSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOlMsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkksd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksUy50aW1lbGluZSYmdGhpcy5hY3RpdmF0ZUFuaW1hdGlvbnMoKSx0aGlzLnNldFJlc29sdXRpb24oUy5nZXRSZXNvbHV0aW9uKCkpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImFwcGVuZCIsZGV0YWlsOntwYXJlbnQ6Uyx6T3JkZXI6SX19KX1jb250YWlucyhTKXtmb3IoO1MmJnRoaXMhPT1TOylTPVMucGFyZW50O3JldHVybiEhU31kZWFjdGl2YXRlQW5pbWF0aW9ucygpe3RoaXNbdl0uZm9yRWFjaChJPT5JLmNhbmNlbCgpKTtjb25zdCBTPXRoaXMuY2hpbGRyZW47UyYmUy5mb3JFYWNoKEk9PntJLmRlYWN0aXZhdGVBbmltYXRpb25zJiZJLmRlYWN0aXZhdGVBbmltYXRpb25zKCl9KX1kaXNjb25uZWN0KCl7Y29uc3R7cGFyZW50OlMsek9yZGVyOkl9PXRoaXM7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcix0aGlzLmRlYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZW1vdmUiLGRldGFpbDp7cGFyZW50OlMsek9yZGVyOkl9fSksUyYmUy5mb3JjZVVwZGF0ZSgpfWRpc3BhdGNoRXZlbnQoUyl7UyBpbnN0YW5jZW9mIGMuZGVmYXVsdHx8KFM9bmV3IGMuZGVmYXVsdChTKSksUy50YXJnZXQ9dGhpcztsZXQgST1TLnR5cGU7ST09PSJtb3VzZXdoZWVsIiYmKEk9IndoZWVsIik7Y29uc3QgRD1bdGhpc107bGV0IFI9dGhpcy5wYXJlbnQ7Zm9yKDtTLmJ1YmJsZXMmJlI7KUQucHVzaChSKSxSPVIucGFyZW50O2ZvcihsZXQgQz1ELmxlbmd0aC0xO0M+PTA7Qy0tKXtjb25zdCBqPURbQ10sJD1qW2ldJiZqW2ldW0ldO2lmKCQmJiQubGVuZ3RoJiYoUy5jdXJyZW50VGFyZ2V0PWosJC5mb3JFYWNoKCh7bGlzdGVuZXI6SCxvbmNlOkp9KT0+e0guY2FsbCh0aGlzLFMpLEomJkQucmVtb3ZlRXZlbnRMaXN0ZW5lcihIKX0pLGRlbGV0ZSBTLmN1cnJlbnRUYXJnZXQpLCFTLmJ1YmJsZXMmJlMuY2FuY2VsQnViYmxlKWJyZWFrfWlmKCFTLmNhbmNlbEJ1YmJsZSlmb3IobGV0IEM9MDtDPEQubGVuZ3RoO0MrKyl7Y29uc3Qgaj1EW0NdLCQ9altQXSYmaltQXVtJXTtpZigkJiYkLmxlbmd0aCYmKFMuY3VycmVudFRhcmdldD1qLCQuZm9yRWFjaCgoe2xpc3RlbmVyOkgsb25jZTpKfSk9PntILmNhbGwodGhpcyxTKSxKJiZELnJlbW92ZUV2ZW50TGlzdGVuZXIoSCl9KSxkZWxldGUgUy5jdXJyZW50VGFyZ2V0KSwhUy5idWJibGVzfHxTLmNhbmNlbEJ1YmJsZSlicmVha319ZGlzcGF0Y2hQb2ludGVyRXZlbnQoUyl7Y29uc3R7bGF5ZXJYOkksbGF5ZXJZOkR9PVM7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihJLEQpPyh0aGlzLmRpc3BhdGNoRXZlbnQoUyksITApOiExfWRyYXcoUz1bXSl7Y29uc3QgST10aGlzLm1lc2g7aWYoSSl7aWYoT2JqZWN0KG8uYXBwbHlGaWx0ZXJzKShJLHRoaXMuZmlsdGVycyksUy5wdXNoKEkpLHRoaXNbaF0pe0kuc2V0UHJvZ3JhbSh0aGlzW2hdKTtjb25zdCBEPXRoaXNbYl07RCYmT2JqZWN0LmVudHJpZXMoRCkuZm9yRWFjaCgoW0Msal0pPT57SS5zZXRBdHRyaWJ1dGUoQyxqKX0pO2NvbnN0IFI9dGhpc1tFXTtpZih0aGlzW0VdKXtjb25zdCBDPXt9O09iamVjdC5lbnRyaWVzKFIpLmZvckVhY2goKFtqLCRdKT0+e3R5cGVvZiAkPT0iZnVuY3Rpb24iJiYoJD0kKHRoaXMsaikpLENbal09JH0pLEkuc2V0VW5pZm9ybXMoQyl9fU9iamVjdChmLmRlZmF1bHQpKHRoaXMsSSl9cmV0dXJuIFN9Zm9yY2VVcGRhdGUoKXt0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKX1nZXRBdHRyaWJ1dGUoUyl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tTXX1nZXRMaXN0ZW5lcnMoUyx7Y2FwdHVyZTpJPSExfT17fSl7cmV0dXJuWy4uLnRoaXNbST9pOlBdW1NdfHxbXV19Z2V0Tm9kZU5lYXJCeShTPTEpe2lmKCF0aGlzLnBhcmVudClyZXR1cm4gbnVsbDtpZihTPT09MClyZXR1cm4gdGhpcztjb25zdCBJPXRoaXMucGFyZW50LmNoaWxkcmVuLEQ9SS5pbmRleE9mKHRoaXMpO3JldHVybiBJW0QrU119Z2V0V29ybGRQb3NpdGlvbihTLEkpe2NvbnN0IEQ9dGhpcy5yZW5kZXJNYXRyaXgsUj1TKkRbMF0rSSpEWzJdK0RbNF0sQz1TKkRbMV0rSSpEWzNdK0RbNV07cmV0dXJuW1IsQ119Z2V0T2Zmc2V0UG9zaXRpb24oUyxJKXtjb25zdCBEPXIubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLnJlbmRlck1hdHJpeCksUj1TKkRbMF0rSSpEWzJdK0RbNF0sQz1TKkRbMV0rSSpEWzNdK0RbNV07cmV0dXJuW1IsQ119Z2V0UmVzb2x1dGlvbigpe3JldHVybiBnKHt9LHRoaXNbT10pfWlzUG9pbnRDb2xsaXNpb24oUyxJKXtpZighdGhpcy5tZXNoKXJldHVybiExO2NvbnN0IEQ9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoRD09PSJub25lInx8RCE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IFI9ImJvdGgiO3JldHVybiBEPT09InZpc2libGVGaWxsIiYmKFI9ImZpbGwiKSxEPT09InZpc2libGVTdHJva2UiJiYoUj0ic3Ryb2tlIiksdGhpcy5tZXNoLmlzUG9pbnRDb2xsaXNpb24oUyxJLFIpfW9uUHJvcGVydHlDaGFuZ2UoUyxJLEQpe1MhPT0iaWQiJiZTIT09Im5hbWUiJiZTIT09ImNsYXNzTmFtZSImJlMhPT0icG9pbnRlckV2ZW50cyImJlMhPT0icGFzc0V2ZW50cyImJnRoaXMuZm9yY2VVcGRhdGUoKSxTPT09ImZpbHRlciImJih0aGlzW3VdPU9iamVjdChvLnBhcnNlRmlsdGVyU3RyaW5nKShJKSksUz09PSJ6SW5kZXgiJiZ0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVvcmRlcigpfXNldEF0dHJpYnV0ZShTLEkpe1M9PT0iYXR0cnMiJiZ0aGlzLmF0dHIoSSksdGhpcy5hdHRyaWJ1dGVzW1NdPUl9c2V0TW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmKHRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PXRoaXMpfXNldFByb2dyYW0oUyl7dGhpc1toXT1TLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRTaGFkZXJBdHRyaWJ1dGUoUyxJKXt0aGlzW2JdPXRoaXNbYl18fHt9LHRoaXNbYl1bU109SSx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0VW5pZm9ybXMoUyl7dGhpc1tFXT10aGlzW0VdfHx7fSxPYmplY3QuYXNzaWduKHRoaXNbRV0sUyksdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFJlc29sdXRpb24oe3dpZHRoOlMsaGVpZ2h0Okl9KXtjb25zdHt3aWR0aDpELGhlaWdodDpSfT10aGlzW09dOyhEIT09U3x8UiE9PUkpJiYodGhpc1tPXT17d2lkdGg6UyxoZWlnaHQ6SX0sdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzb2x1dGlvbmNoYW5nZSIsZGV0YWlsOnt3aWR0aDpTLGhlaWdodDpJfX0pKX1zaG93KCl7dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSImJih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT10aGlzW2FdfHwiIil9aGlkZSgpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiJiYodGhpc1thXT10aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSx0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT0ibm9uZSIpfXJlbGVhc2VNb3VzZUNhcHR1cmUoKXt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD09PXRoaXMmJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsKX1yZW1vdmUoKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlbW92ZUNoaWxkPyh0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSwhMCk6ITF9cmVtb3ZlQWxsTGlzdGVuZXJzKFMsST17fSl7dHlwZW9mIEk9PSJib29sZWFuIiYmKEk9e2NhcHR1cmU6SX0pO2NvbnN0IFI9SS5jYXB0dXJlP2k6UDtyZXR1cm4gdGhpc1tSXVtTXSYmKHRoaXNbUl1bU109W10pLHRoaXN9cmVtb3ZlQXR0cmlidXRlKFMpe3RoaXMuc2V0QXR0cmlidXRlKFMsbnVsbCl9cmVtb3ZlRXZlbnRMaXN0ZW5lcihTLEksRD17fSl7dHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0IEM9RC5jYXB0dXJlP2k6UDtpZih0aGlzW0NdW1NdKXtjb25zdCBqPXRoaXNbQ11bU107aWYoailmb3IobGV0ICQ9MDskPGoubGVuZ3RoOyQrKyl7Y29uc3R7bGlzdGVuZXI6SH09alskXTtpZihIPT09SSl7dGhpc1tDXVtTXS5zcGxpY2UoJCwxKTticmVha319fXJldHVybiB0aGlzfXRyYW5zaXRpb24oUyxJPSJsaW5lYXIiKXtjb25zdCBEPXRoaXMsUj1TeW1ib2woImFuaW1hdGlvbiIpO0k9SXx8ImxpbmVhciI7bGV0IEM9MDtyZXR1cm4gdHlwZW9mIFM9PSJvYmplY3QiJiYoQz1TLmRlbGF5fHwwLFM9Uy5kdXJhdGlvbikse1tSXTpudWxsLGNhbmNlbChqPSExKXtjb25zdCAkPXRoaXNbUl07JCYmJC5jYW5jZWwoail9LGVuZCgpe2NvbnN0IGo9dGhpc1tSXTtqJiYoai5wbGF5U3RhdGU9PT0icnVubmluZyJ8fGoucGxheVN0YXRlPT09InBlbmRpbmciKSYmai5maW5pc2goKX0scmV2ZXJzZSgpe2NvbnN0IGo9dGhpc1tSXTtpZihqKWlmKGoucGxheVN0YXRlPT09InJ1bm5pbmcifHxqLnBsYXlTdGF0ZT09PSJwZW5kaW5nIilqLnBsYXliYWNrUmF0ZT0tai5wbGF5YmFja1JhdGU7ZWxzZXtjb25zdCAkPWoudGltaW5nLmRpcmVjdGlvbjtqLnRpbWluZy5kaXJlY3Rpb249JD09PSJyZXZlcnNlIj8ibm9ybWFsIjoicmV2ZXJzZSIsai5wbGF5KCl9cmV0dXJuIGouZmluaXNoZWR9LGF0dHIoaiwkKXtyZXR1cm4gdGhpcy5lbmQoKSx0eXBlb2Ygaj09InN0cmluZyImJihqPXtbal06JH0pLE9iamVjdC5lbnRyaWVzKGopLmZvckVhY2goKFtILEpdKT0+e3R5cGVvZiBKPT0iZnVuY3Rpb24iJiYoaltIXT1KKEQuYXR0cihIKSkpfSksdGhpc1tSXT1ELmFuaW1hdGUoW2pdLHtkdXJhdGlvbjpTKjFlMyxkZWxheTpDKjFlMyxmaWxsOiJmb3J3YXJkcyIsZWFzaW5nOkl9KSx0aGlzW1JdLmZpbmlzaGVkfX19dXBkYXRlQ29udG91cnMoKXt9fXkoQSwiQXR0ciIsbi5kZWZhdWx0KSxsLmRlZmF1bHQucmVnaXN0ZXJOb2RlKEEsIm5vZGUiKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pO3ZhciByPXQoMSksbj10KDEyKSxzPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx4PVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxnPVN5bWJvbC5mb3IoInNwcml0ZWpzX2NoYW5nZWRBdHRycyIpLHk9U3ltYm9sKCJzdWJqZWN0IiksbT1TeW1ib2woImF0dHIiKSxUPVN5bWJvbCgiZGVmYXVsdCIpLE89U3ltYm9sKCJhbGlhcyIpO2Z1bmN0aW9uIHYoTCxbUyxJXSl7bGV0IEQ9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtyZXR1cm5bLi4uTF0uZm9yRWFjaCgoW1IsQ10pPT57aWYoKFN8fEkpJiYoRD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRCxbUyxJXSkpLFI9PT0ibWF0cml4IilEPXIubWF0MmQubXVsdGlwbHkoRCxELEMpO2Vsc2UgaWYoUj09PSJvZmZzZXRUcmFuc2xhdGUiKURbNF0rPUNbMF0sRFs1XSs9Q1sxXTtlbHNlIGlmKFI9PT0ib2Zmc2V0Um90YXRlIilEPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELEMpO2Vsc2UgaWYoUj09PSJza2V3Iil7Y29uc3RbaiwkXT1DO0Q9ci5tYXQyZC5tdWx0aXBseShELEQsci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oJCksTWF0aC50YW4oaiksMSwwLDApKX1lbHNlIHIubWF0MmRbUl0oRCxELEMpOyhTfHxJKSYmKEQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsWy1TLC1JXSkpfSksRH1jb25zdCBQPVN5bWJvbCgidHJhbnNmb3JtTWF0cml4IiksaT1TeW1ib2woInRyYW5zZm9ybXMiKSx1PVN5bWJvbCgiY2hhbmdlZEF0dHJzIiksYT1TeW1ib2woImxhc3RDaGFuZ2VkQXR0ciIpLGg9U3ltYm9sKCJvZmZzZXRGaWd1cmUiKTtmdW5jdGlvbiBiKEwsUyxJKXtjb25zdCBEPUxbbV1bU107aWYoTFtvXShTLEksITEpfHxMW2FdIT09Uyl7Y29uc3QgQz1MW2ldO0MuaGFzKFMpJiZDLmRlbGV0ZShTKSxJJiYoUz09PSJyb3RhdGUiJiYoST1NYXRoLlBJKkkvMTgwKSxTPT09InNjYWxlIiYmKEk9SS5tYXAoaj0+TWF0aC5hYnMoaik+MWUtNT9qOjEvaj4wPzFlLTU6LTFlLTUpKSxDLnNldChTLEkpKSxMW1BdPW51bGwsTFt5XS5vblByb3BlcnR5Q2hhbmdlKFMsSSxELEwpfX1mdW5jdGlvbiBFKEwpe2NvbnN0IFM9TFtoXSxJPUwub2Zmc2V0RGlzdGFuY2UqUy5nZXRUb3RhbExlbmd0aCgpLEQ9Uy5nZXRQb2ludEF0TGVuZ3RoKEkpO2lmKEQpe2NvbnN0IFI9TFtpXTtsZXQgQz1MLm9mZnNldFJvdGF0ZTtDPT09ImF1dG8iP0M9RC5hbmdsZTpDPT09InJldmVyc2UiP0M9TWF0aC5QSStELmFuZ2xlOkM9TWF0aC5QSSpDLzE4MCxSLnNldCgib2Zmc2V0Um90YXRlIixDKSxSLnNldCgib2Zmc2V0VHJhbnNsYXRlIixbRC54LEQueV0pLExbUF09bnVsbH19Y2xhc3MgQXtzdGF0aWMgc2V0RGVmYXVsdChTLC4uLkkpe3JldHVybiBTW2xdKC4uLkkpfXN0YXRpYyBkZWNsYXJlQWxpYXMoUywuLi5JKXtyZXR1cm4gU1tjXSguLi5JKX1zdGF0aWMgc2V0QXR0cmlidXRlKFMsLi4uSSl7cmV0dXJuIFNbb10oLi4uSSl9c3RhdGljIGdldEF0dHJpYnV0ZShTLC4uLkkpe3JldHVybiBTW2ZdKC4uLkkpfXN0YXRpYyBnZXRBdHRyaWJ1dGVzKFMpe3JldHVybiBTW3hdfXN0YXRpYyBnZXRDaGFuZ2VkQXR0cmlidXRlcyhTKXtyZXR1cm4gU1tnXX1jb25zdHJ1Y3RvcihTKXt0aGlzW3ldPVMsdGhpc1ttXT17fSx0aGlzW1BdPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCksdGhpc1tpXT1uZXcgTWFwLHRoaXNbVF09e30sdGhpc1tPXT1bXSxPYmplY3QuZGVmaW5lUHJvcGVydHkoUywidHJhbnNmb3JtTWF0cml4Iix7Z2V0OigpPT4odGhpc1tQXXx8KHRoaXNbUF09dih0aGlzW2ldLHRoaXMudHJhbnNmb3JtT3JpZ2luKSksWy4uLnRoaXNbUF1dKX0pLHRoaXNbbF0oe2lkOiIiLG5hbWU6IiIsY2xhc3NOYW1lOiIiLHg6MCx5OjAsdHJhbnNmb3JtT3JpZ2luOlswLDBdLHRyYW5zZm9ybToiIix0cmFuc2xhdGU6WzAsMF0scm90YXRlOjAsc2NhbGU6WzEsMV0sc2tldzpbMCwwXSxvcGFjaXR5OjEsekluZGV4OjAsb2Zmc2V0UGF0aDp2b2lkIDAsb2Zmc2V0RGlzdGFuY2U6MCxvZmZzZXRSb3RhdGU6ImF1dG8iLHBvaW50ZXJFdmVudHM6InZpc2libGUiLGZpbHRlcjoibm9uZSIsZGlzcGxheToiIn0pLHRoaXNbY10oImNsYXNzIiwicG9zIiksdGhpc1t1XT1uZXcgU2V0LHRoaXNbaF09bmV3IG4uRmlndXJlMkQoe3NjYWxlOjUsc2ltcGxpZnk6MH0pfWdldFtnXSgpe2NvbnN0IFM9e307cmV0dXJuWy4uLnRoaXNbdV1dLmZvckVhY2goST0+e1NbSV09dGhpc1ttXVtJXX0pLFN9Z2V0W3hdKCl7Y29uc3QgUz1PYmplY3QuYXNzaWduKHt9LHRoaXNbbV0pO2ZvcihsZXQgST0wO0k8dGhpc1tPXS5sZW5ndGg7SSsrKXtjb25zdCBEPXRoaXNbT11bSV07U1tEXT10aGlzW0RdfXJldHVybiBTfVtsXShTKXtPYmplY3QuYXNzaWduKHRoaXNbVF0sUyksT2JqZWN0LmFzc2lnbih0aGlzW21dLFMpfVtjXSguLi5TKXt0aGlzW09dLnB1c2goLi4uUyl9W29dKFMsSSxEPSEwKXtjb25zdCBSPXRoaXNbbV1bU10sQz10aGlzW3ldO3JldHVybiBJPT1udWxsJiYoST10aGlzW1RdW1NdKSxPYmplY3Qocy5jb21wYXJlVmFsdWUpKFIsSSk/ITE6KHRoaXNbbV1bU109SSx0aGlzW3VdLmhhcyhTKSYmdGhpc1t1XS5kZWxldGUoUyksdGhpc1t1XS5hZGQoUyksdGhpc1thXT1TLEQmJkMub25Qcm9wZXJ0eUNoYW5nZShTLEksUix0aGlzKSwhMCl9W2ZdKFMpe3JldHVybiB0aGlzW21dW1NdfXNldCBpZChTKXt0aGlzW29dKCJpZCIsUyl9Z2V0IGlkKCl7cmV0dXJuIHRoaXNbZl0oImlkIil9c2V0IG5hbWUoUyl7dGhpc1tvXSgibmFtZSIsUyl9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1tmXSgibmFtZSIpfXNldCBjbGFzc05hbWUoUyl7dGhpc1tvXSgiY2xhc3NOYW1lIixTKX1nZXQgY2xhc3NOYW1lKCl7cmV0dXJuIHRoaXNbZl0oImNsYXNzTmFtZSIpfXNldCBjbGFzcyhTKXt0aGlzLmNsYXNzTmFtZT1TfWdldCBjbGFzcygpe3JldHVybiB0aGlzLmNsYXNzTmFtZX1nZXQgeCgpe3JldHVybiB0aGlzW2ZdKCJ4Iil9c2V0IHgoUyl7dGhpc1tvXSgieCIsT2JqZWN0KHMudG9OdW1iZXIpKFMpKX1nZXQgeSgpe3JldHVybiB0aGlzW2ZdKCJ5Iil9c2V0IHkoUyl7dGhpc1tvXSgieSIsT2JqZWN0KHMudG9OdW1iZXIpKFMpKX1nZXQgcG9zKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldCBwb3MoUyl7Uz1PYmplY3Qocy50b0FycmF5KShTKSxBcnJheS5pc0FycmF5KFMpfHwoUz1bUyxTXSksdGhpcy54PVNbMF0sdGhpcy55PVNbMV19Z2V0IHRyYW5zZm9ybSgpe3JldHVybiB0aGlzW2ZdKCJ0cmFuc2Zvcm0iKX1zZXQgdHJhbnNmb3JtKFMpe2xldCBJPW51bGw7aWYoQXJyYXkuaXNBcnJheShTKSYmKEk9UyxTPWBtYXRyaXgoJHtTLm1hcChzLnRvTnVtYmVyKS5qb2luKCl9KWApLHR5cGVvZiBTPT0ic3RyaW5nIilTPVMucmVwbGFjZSgvXHMqLFxzKi9nLCIsIik7ZWxzZSBpZihTIT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpO2NvbnN0IEQ9dGhpc1ttXS50cmFuc2Zvcm07aWYodGhpc1tvXSgidHJhbnNmb3JtIixTLCExKSl7Y29uc3QgUj10aGlzW2ldO2lmKFIuaGFzKCJtYXRyaXgiKSYmUi5kZWxldGUoIm1hdHJpeCIpLEkpUi5zZXQoIm1hdHJpeCIsSSk7ZWxzZSBpZihTKXtjb25zdCBDPVMubWF0Y2goLyhtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoW14oKV0rXCkvZyk7aWYoQyl7bGV0IGo9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtmb3IobGV0ICQ9MDskPEMubGVuZ3RoOyQrKyl7Y29uc3QgSj1DWyRdLm1hdGNoKC9eKG1hdHJpeHx0cmFuc2xhdGV8cm90YXRlfHNjYWxlfHNrZXcpXCgoW14oKV0rKVwpLyk7aWYoSil7bGV0WyxxLEZdPUo7cT09PSJyb3RhdGUiP0Y9TWF0aC5QSSpwYXJzZUZsb2F0KEYpLzE4MDpGPUYudHJpbSgpLnNwbGl0KC9bXHMsXSsvKS5tYXAoRz0+T2JqZWN0KHMudG9OdW1iZXIpKEcpKSxxPT09Im1hdHJpeCI/aj1yLm1hdDJkLm11bHRpcGx5KGosaixGKTpxPT09InNrZXciP2o9ci5tYXQyZC5tdWx0aXBseShqLGosci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRlsxXSksTWF0aC50YW4oRlswXSksMSwwLDApKTpyLm1hdDJkW3FdKGosaixGKSxSLnNldCgibWF0cml4IixqKX19fWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB0cmFuc2Zvcm0gdmFsdWUuIil9dGhpc1tQXT1udWxsLHRoaXNbeV0ub25Qcm9wZXJ0eUNoYW5nZSgidHJhbnNmb3JtIixTLEQsdGhpcyl9fWdldCB0cmFuc2Zvcm1PcmlnaW4oKXtyZXR1cm4gdGhpc1tmXSgidHJhbnNmb3JtT3JpZ2luIil9c2V0IHRyYW5zZm9ybU9yaWdpbihTKXtTPU9iamVjdChzLnRvQXJyYXkpKFMsITApLFMhPW51bGwmJiFBcnJheS5pc0FycmF5KFMpJiYoUz1bUyxTXSksdGhpc1tvXSgidHJhbnNmb3JtT3JpZ2luIixTKSYmKHRoaXNbUF09bnVsbCl9Z2V0IHJvdGF0ZSgpe3JldHVybiB0aGlzW2ZdKCJyb3RhdGUiKX1zZXQgcm90YXRlKFMpe2IodGhpcywicm90YXRlIixTKX1nZXQgdHJhbnNsYXRlKCl7cmV0dXJuIHRoaXNbZl0oInRyYW5zbGF0ZSIpfXNldCB0cmFuc2xhdGUoUyl7Uz1PYmplY3Qocy50b0FycmF5KShTLCEwKSxTIT1udWxsJiYhQXJyYXkuaXNBcnJheShTKSYmKFM9W1MsU10pLGIodGhpcywidHJhbnNsYXRlIixTKX1nZXQgc2NhbGUoKXtyZXR1cm4gdGhpc1tmXSgic2NhbGUiKX1zZXQgc2NhbGUoUyl7Uz1PYmplY3Qocy50b0FycmF5KShTLCEwKSxTIT1udWxsJiYhQXJyYXkuaXNBcnJheShTKSYmKFM9W1MsU10pLGIodGhpcywic2NhbGUiLFMpfWdldCBza2V3KCl7cmV0dXJuIHRoaXNbZl0oInNrZXciKX1zZXQgc2tldyhTKXtTPU9iamVjdChzLnRvQXJyYXkpKFMsITApLFMhPW51bGwmJiFBcnJheS5pc0FycmF5KFMpJiYoUz1bUyxTXSksYih0aGlzLCJza2V3IixTKX1nZXQgb3BhY2l0eSgpe3JldHVybiB0aGlzW2ZdKCJvcGFjaXR5Iil9c2V0IG9wYWNpdHkoUyl7UyE9bnVsbCYmKFM9TnVtYmVyKFMpKSx0aGlzW29dKCJvcGFjaXR5IixTKX1nZXQgekluZGV4KCl7cmV0dXJuIHRoaXNbZl0oInpJbmRleCIpfXNldCB6SW5kZXgoUyl7UyE9bnVsbCYmKFM9TnVtYmVyKFMpKSx0aGlzW29dKCJ6SW5kZXgiLFMpfWdldCBvZmZzZXRQYXRoKCl7cmV0dXJuIHRoaXNbZl0oIm9mZnNldFBhdGgiKX1zZXQgb2Zmc2V0UGF0aChTKXt0aGlzW29dKCJvZmZzZXRQYXRoIixTKSYmKHRoaXNbaF0uYmVnaW5QYXRoKCksUyE9bnVsbCYmdGhpc1toXS5hZGRQYXRoKFMpLEUodGhpcykpfWdldCBvZmZzZXREaXN0YW5jZSgpe3JldHVybiB0aGlzW2ZdKCJvZmZzZXREaXN0YW5jZSIpfXNldCBvZmZzZXREaXN0YW5jZShTKXt0aGlzW29dKCJvZmZzZXREaXN0YW5jZSIsT2JqZWN0KHMudG9OdW1iZXIpKFMpKSYmRSh0aGlzKX1nZXQgb2Zmc2V0Um90YXRlKCl7cmV0dXJuIHRoaXNbZl0oIm9mZnNldFJvdGF0ZSIpfXNldCBvZmZzZXRSb3RhdGUoUyl7dGhpc1tvXSgib2Zmc2V0Um90YXRlIixTKSxFKHRoaXMpfWdldCBwb2ludGVyRXZlbnRzKCl7cmV0dXJuIHRoaXNbZl0oInBvaW50ZXJFdmVudHMiKX1zZXQgcG9pbnRlckV2ZW50cyhTKXtpZihTIT1udWxsJiZTIT09Im5vbmUiJiZTIT09InZpc2libGUiJiZTIT09InZpc2libGVGaWxsIiYmUyE9PSJ2aXNpYmxlU3Ryb2tlIiYmUyE9PSJhbGwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcG9pbnRlckV2ZW50cyB0eXBlLiIpO3RoaXNbb10oInBvaW50ZXJFdmVudHMiLFMpfWdldCBmaWx0ZXIoKXtyZXR1cm4gdGhpc1tmXSgiZmlsdGVyIil9c2V0IGZpbHRlcihTKXt0aGlzW29dKCJmaWx0ZXIiLFMpfWdldCBkaXNwbGF5KCl7cmV0dXJuIHRoaXNbZl0oImRpc3BsYXkiKX1zZXQgZGlzcGxheShTKXt0aGlzW29dKCJkaXNwbGF5IixTKX1zZXQgb2Zmc2V0KFMpe319fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJzaXplVG9QaXhlbCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJ0b051bWJlciIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJ0b0FycmF5IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNvbXBhcmVWYWx1ZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG8sZil7Y29uc3QgeD1vLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLyk7eD9vPXtzaXplOnBhcnNlRmxvYXQoeFsxXSksdW5pdDp4WzJdfTpvPXtzaXplOnBhcnNlRmxvYXQobyksdW5pdDoicHgifTtsZXR7c2l6ZTpnLHVuaXQ6eX09bztpZih5PT09InB0IilnLz0uNzU7ZWxzZSBpZih5PT09InBjIilnKj0xNjtlbHNlIGlmKHk9PT0iaW4iKWcqPTk2O2Vsc2UgaWYoeT09PSJjbSIpZyo9OTYvMi41NDtlbHNlIGlmKHk9PT0ibW0iKWcqPTk2LzI1LjQ7ZWxzZSBpZih5PT09ImVtInx8eT09PSJyZW0ifHx5PT09ImV4Iil7aWYoIWYmJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBtPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTttP2Y9cihtLDE2KTpmPTE2fWcqPWYseT09PSJleCImJihnLz0yKX1lbHNlIGlmKHk9PT0icSIpZyo9OTYvMjUuNC80O2Vsc2UgaWYoeT09PSJ2dyJ8fHk9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBtPXk9PT0idnciP3dpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2cqPW0vMTAwfX1lbHNlIGlmKCh5PT09InZtYXgifHx5PT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgbT13aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFQ9d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3k9PT0idm1heCI/Zyo9TWF0aC5tYXgobSxUKS8xMDA6Zyo9TWF0aC5taW4obSxUKS8xMDB9cmV0dXJuIGd9ZnVuY3Rpb24gbihvKXtyZXR1cm4gbz09bnVsbD9vOlN0cmluZyhvKX1mdW5jdGlvbiBzKG8pe2lmKG89PW51bGwpcmV0dXJuIG87aWYodHlwZW9mIG89PSJzdHJpbmciJiYobz1yKG8pKSwhTnVtYmVyLmlzRmluaXRlKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmFsdWUiKTtyZXR1cm4gb31mdW5jdGlvbiBsKG8sZj0hMSl7cmV0dXJuIG89PT0iIj9udWxsOih0eXBlb2Ygbz09InN0cmluZyImJihvPW8uc3BsaXQoL1tccyxdKy9nKSksQXJyYXkuaXNBcnJheShvKSYmKGYmJihvPW8ubWFwKHMpKSxvLmxlbmd0aD09PTEpP29bMF06byl9ZnVuY3Rpb24gYyhvLGYpe2lmKEFycmF5LmlzQXJyYXkobykmJkFycmF5LmlzQXJyYXkoZikpe2lmKG8ubGVuZ3RoIT09Zi5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB4PTA7eDxvLmxlbmd0aDt4KyspaWYob1t4XSE9PWZbeF0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIG89PW51bGwmJmY9PW51bGx8fG89PT1mfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pO3ZhciByPXQoNzQpLG49dCgzMikscz10Lm4obiksbD10KDY4KSxjPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKCl7cmV0dXJuIG89T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24obSl7Zm9yKHZhciBUPTE7VDxhcmd1bWVudHMubGVuZ3RoO1QrKyl7dmFyIE89YXJndW1lbnRzW1RdO2Zvcih2YXIgdiBpbiBPKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChPLHYpJiYobVt2XT1PW3ZdKX1yZXR1cm4gbX0sby5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gZihtKXtpZih0eXBlb2YgbT09InN0cmluZyIpe2lmKG09bS50cmltKCksL15bMC05Ll0rJSQvLnRlc3QobSkpcmV0dXJuIHBhcnNlRmxvYXQobSkvMTAwO2lmKC9eKFtcZC5dKykocHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWluKSQvLnRlc3QobSkpcmV0dXJuIE9iamVjdChjLnNpemVUb1BpeGVsKShtKX1yZXR1cm4gbX1mdW5jdGlvbiB4KG0sVCxPLHYsUCl7cmV0dXJuIHR5cGVvZiBtPT0ic3RyaW5nIiYmKG09cygpKG0pKSx0eXBlb2YgVD09InN0cmluZyImJihUPXMoKShUKSksci5FZmZlY3RzLmRlZmF1bHQobSxULE8sdixQKX1mdW5jdGlvbiBnKG0sVCxPLHYsUCl7cmV0dXJuIHIuRWZmZWN0cy5kZWZhdWx0KG0sVCxPLHYsUCl9ci5FZmZlY3RzLmRlZmF1bHQ9ZnVuY3Rpb24obSxULE8sdixQKXtyZXR1cm4gQXJyYXkuaXNBcnJheShtKSYmQXJyYXkuaXNBcnJheShUKT9tLm1hcCgoaSx1KT0+aSsoTy12KS8oUC12KSooVFt1XS1pKSk6dHlwZW9mIG09PSJudW1iZXIiJiZ0eXBlb2YgVD09Im51bWJlciI/bSsoTy12KS8oUC12KSooVC1tKTpPLXY+UC1PP1Q6bX0sci5FZmZlY3RzLmZpbGxDb2xvcj14LHIuRWZmZWN0cy5zdHJva2VDb2xvcj14LHIuRWZmZWN0cy5iZ2NvbG9yPXgsci5FZmZlY3RzLmJvcmRlckNvbG9yPXgsci5FZmZlY3RzLnRleHQ9ZztjbGFzcyB5IGV4dGVuZHMgci5BbmltYXRvcntjb25zdHJ1Y3RvcihULE8sdil7Y29uc3QgUD1ULmF0dHIoKTtPYmplY3QuZW50cmllcyhQKS5mb3JFYWNoKChbaSx1XSk9PntQW2ldPXIuRWZmZWN0c1tpXT91OmYodSl9KSxPPU8ubWFwKGk9PntsZXQgdT1vKHt9LGkpO2NvbnN0IGE9e307cmV0dXJuIE9iamVjdC5lbnRyaWVzKHUpLmZvckVhY2goKFtoLGJdKT0+e2FbaF09ci5FZmZlY3RzW2hdP2I6ZihiKX0pLGF9KSxzdXBlcihQLE8sdiksdGhpcy50YXJnZXQ9VCx0aGlzLnNldHRlcj1mdW5jdGlvbihpLHUpe3UuYXR0cihpKX19Z2V0IHBsYXlTdGF0ZSgpe3JldHVybiB0aGlzLnRhcmdldC5wYXJlbnQ/c3VwZXIucGxheVN0YXRlOiJpZGxlIn1nZXQgZmluaXNoZWQoKXtyZXR1cm4gc3VwZXIuZmluaXNoZWQudGhlbigoKT0+e2NvbnN0IFQ9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoTz0+e2Z1bmN0aW9uIHYoKXtULnNldHRlcihULmZyYW1lLFQudGFyZ2V0KTtjb25zdCBQPVQucGxheVN0YXRlO1A9PT0iZmluaXNoZWQifHxQPT09ImlkbGUiPyhPYmplY3QobC5jYW5jZWxBbmltYXRpb25GcmFtZSkoVC5yZXF1ZXN0SWQpLE8oKSk6T2JqZWN0KGwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSh2KX12KCl9KX0pfWZpbmlzaCgpe3N1cGVyLmZpbmlzaCgpLE9iamVjdChsLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzLnJlcXVlc3RJZCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCl9cGxheSgpe2lmKCF0aGlzLnRhcmdldC5wYXJlbnR8fHRoaXMucGxheVN0YXRlPT09InJ1bm5pbmciKXJldHVybjtzdXBlci5wbGF5KCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCk7Y29uc3QgVD10aGlzO3RoaXMucmVhZHkudGhlbigoKT0+e1Quc2V0dGVyKFQuZnJhbWUsVC50YXJnZXQpLFQucmVxdWVzdElkPU9iamVjdChsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoZnVuY3Rpb24gTygpe2NvbnN0IHY9VC50YXJnZXQ7aWYodHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMmJnYubGF5ZXImJnYubGF5ZXIuY2FudmFzJiYhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHYubGF5ZXIuY2FudmFzKSl7VC5jYW5jZWwoKTtyZXR1cm59Y29uc3QgUD1ULnBsYXlTdGF0ZTtULnNldHRlcihULmZyYW1lLFQudGFyZ2V0KSxQIT09ImlkbGUiJiYoUD09PSJydW5uaW5nIj9ULnJlcXVlc3RJZD1PYmplY3QobC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKE8pOihQPT09InBhdXNlZCJ8fFA9PT0icGVuZGluZyImJlQudGltZWxpbmUuY3VycmVudFRpbWU8MCkmJlQucmVhZHkudGhlbigoKT0+e1Quc2V0dGVyKFQuZnJhbWUsVC50YXJnZXQpLFQucmVxdWVzdElkPU9iamVjdChsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoTyl9KSl9KX0pfWNhbmNlbChUPSExKXtPYmplY3QobC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLFQ/KHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpLHN1cGVyLmNhbmNlbCgpKTooc3VwZXIuY2FuY2VsKCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCkpfX19LGZ1bmN0aW9uKGQsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5UaW1lbGluZT1lLkVmZmVjdHM9ZS5FYXNpbmdzPWUuQW5pbWF0b3I9dm9pZCAwO3ZhciByPXQoNzUpLG49eChyKSxzPXQoMTg3KSxsPXgocyksYz10KDE4OCksbz10KDE5MCksZj14KG8pO2Z1bmN0aW9uIHgoZyl7cmV0dXJuIGcmJmcuX19lc01vZHVsZT9nOntkZWZhdWx0Omd9fWUuQW5pbWF0b3I9Zi5kZWZhdWx0LGUuRWFzaW5ncz1jLkVhc2luZ3MsZS5FZmZlY3RzPWwuZGVmYXVsdCxlLlRpbWVsaW5lPW4uZGVmYXVsdH0sZnVuY3Rpb24oZCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxuPWkocikscz10KDEzMyksbD1pKHMpLGM9dCgxNDEpLG89aShjKSxmPXQoMTY0KSx4PWkoZiksZz10KDE3MCkseT1pKGcpLG09dCgxNzEpLFQ9aShtKSxPPXQoMTc1KSx2PWkoTyksUD10KDE4Nik7ZnVuY3Rpb24gaShEKXtyZXR1cm4gRCYmRC5fX2VzTW9kdWxlP0Q6e2RlZmF1bHQ6RH19dmFyIHU9KDAsUC5jcmVhdGVOb3dUaW1lKSgpLGE9e29yaWdpblRpbWU6MCxwbGF5YmFja1JhdGU6MX0saD0oMCx2LmRlZmF1bHQpKCJ0aW1lTWFyayIpLGI9KDAsdi5kZWZhdWx0KSgicGxheWJhY2tSYXRlIiksRT0oMCx2LmRlZmF1bHQpKCJ0aW1lcnMiKSxBPSgwLHYuZGVmYXVsdCkoIm9yaWdpblRpbWUiKSxMPSgwLHYuZGVmYXVsdCkoInNldFRpbWVyIiksUz0oMCx2LmRlZmF1bHQpKCJwYXJlbnQiKSxJPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gRChSLEMpeygwLHkuZGVmYXVsdCkodGhpcyxEKSxSIGluc3RhbmNlb2YgRCYmKEM9UixSPXt9KSxSPSgwLHguZGVmYXVsdCkoe30sYSxSKSxDJiYodGhpc1tTXT1DKTt2YXIgaj1SLm5vd3RpbWV8fHU7aWYoQylPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBDLmN1cnJlbnRUaW1lfX0pO2Vsc2V7dmFyICQ9aigpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJnbG9iYWxUaW1lIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGooKS0kfX0pfXRoaXNbaF09W3tnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6LVIub3JpZ2luVGltZSxlbnRyb3B5Oi1SLm9yaWdpblRpbWUscGxheWJhY2tSYXRlOlIucGxheWJhY2tSYXRlLGdsb2JhbEVudHJvcHk6MH1dLHRoaXNbU10mJih0aGlzW2hdWzBdLmdsb2JhbEVudHJvcHk9dGhpc1tTXS5lbnRyb3B5KSx0aGlzW0FdPVIub3JpZ2luVGltZSx0aGlzW2JdPVIucGxheWJhY2tSYXRlLHRoaXNbRV09bmV3IG8uZGVmYXVsdH1yZXR1cm4oMCxULmRlZmF1bHQpKEQsW3trZXk6Im1hcmtUaW1lIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBDPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxqPUMudGltZSwkPWo9PT12b2lkIDA/dGhpcy5jdXJyZW50VGltZTpqLEg9Qy5lbnRyb3B5LEo9SD09PXZvaWQgMD90aGlzLmVudHJvcHk6SCxxPUMucGxheWJhY2tSYXRlLEY9cT09PXZvaWQgMD90aGlzLnBsYXliYWNrUmF0ZTpxLEc9e2dsb2JhbFRpbWU6dGhpcy5nbG9iYWxUaW1lLGxvY2FsVGltZTokLGVudHJvcHk6SixwbGF5YmFja1JhdGU6RixnbG9iYWxFbnRyb3B5OnRoaXMuZ2xvYmFsRW50cm9weX07dGhpc1toXS5wdXNoKEcpfX0se2tleToiZm9yayIsdmFsdWU6ZnVuY3Rpb24oQyl7cmV0dXJuIG5ldyBEKEMsdGhpcyl9fSx7a2V5OiJzZWVrR2xvYmFsVGltZSIsdmFsdWU6ZnVuY3Rpb24oQyl7dmFyIGo9dGhpcy5zZWVrVGltZU1hcmsoQyksJD10aGlzW2hdW2pdLEg9JC5lbnRyb3B5LEo9JC5wbGF5YmFja1JhdGUscT0kLmdsb2JhbFRpbWU7cmV0dXJuIHErKEMtSCkvTWF0aC5hYnMoSil9fSx7a2V5OiJzZWVrTG9jYWxUaW1lIix2YWx1ZTpmdW5jdGlvbihDKXt2YXIgaj10aGlzLnNlZWtUaW1lTWFyayhDKSwkPXRoaXNbaF1bal0sSD0kLmxvY2FsVGltZSxKPSQuZW50cm9weSxxPSQucGxheWJhY2tSYXRlO3JldHVybiBxPjA/SCsoQy1KKTpILShDLUopfX0se2tleToic2Vla1RpbWVNYXJrIix2YWx1ZTpmdW5jdGlvbihDKXt2YXIgaj10aGlzW2hdLCQ9MCxIPWoubGVuZ3RoLTE7aWYoQzw9alskXS5lbnRyb3B5KXJldHVybiAkO2lmKEM+PWpbSF0uZW50cm9weSlyZXR1cm4gSDtmb3IodmFyIEo9TWF0aC5mbG9vcigoJCtIKS8yKTtKPiQmJko8SDspe2lmKEM9PT1qW0pdLmVudHJvcHkpcmV0dXJuIEo7QzxqW0pdLmVudHJvcHk/SD1KOkM+altKXS5lbnRyb3B5JiYoJD1KKSxKPU1hdGguZmxvb3IoKCQrSCkvMil9cmV0dXJuICR9fSx7a2V5OiJ1cGRhdGVUaW1lcnMiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEM9dGhpcyxqPVtdLmNvbmNhdCgoMCxsLmRlZmF1bHQpKHRoaXNbRV0pKTtqLmZvckVhY2goZnVuY3Rpb24oJCl7dmFyIEg9KDAsbi5kZWZhdWx0KSgkLDIpLEo9SFswXSxxPUhbMV07Q1tMXShxLmhhbmRsZXIscS50aW1lLEopfSl9fSx7a2V5OiJjbGVhclRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKFIpe2Z1bmN0aW9uIEMoail7cmV0dXJuIFIuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBDLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIFIudG9TdHJpbmcoKX0sQ30oZnVuY3Rpb24oUil7dmFyIEM9dGhpc1tFXS5nZXQoUik7QyYmQy50aW1lcklEIT1udWxsJiYodGhpc1tTXT90aGlzW1NdLmNsZWFyVGltZW91dChDLnRpbWVySUQpOmNsZWFyVGltZW91dChDLnRpbWVySUQpKSx0aGlzW0VdLmRlbGV0ZShSKX0pfSx7a2V5OiJjbGVhckludGVydmFsIix2YWx1ZTpmdW5jdGlvbihDKXtyZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoQyl9fSx7a2V5OiJjbGVhciIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgQz10aGlzLGo9dGhpc1tFXTtbXS5jb25jYXQoKDAsbC5kZWZhdWx0KShqLmtleXMoKSkpLmZvckVhY2goZnVuY3Rpb24oJCl7Qy5jbGVhclRpbWVvdXQoJCl9KX19LHtrZXk6InNldFRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKEMpe3ZhciBqPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7ZGVsYXk6MH07cmV0dXJuIHRoaXNbTF0oQyxqKX19LHtrZXk6InNldEludGVydmFsIix2YWx1ZTpmdW5jdGlvbihDKXt2YXIgaj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9LCQ9dGhpcyxIPXRoaXNbTF0oZnVuY3Rpb24gSigpeyRbTF0oSixqLEgpLEMoKX0saik7cmV0dXJuIEh9fSx7a2V5OkwsdmFsdWU6ZnVuY3Rpb24oQyxqKXt2YXIgJD10aGlzLEg9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOigwLHYuZGVmYXVsdCkoInRpbWVySUQiKTtqPSgwLFAuZm9ybWF0RGVsYXkpKGopO3ZhciBKPXRoaXNbRV0uZ2V0KEgpLHE9dm9pZCAwLEY9bnVsbCxHPXZvaWQgMCxaPXZvaWQgMDtKPyh0aGlzLmNsZWFyVGltZW91dChIKSxqLmlzRW50cm9weT9xPShqLmRlbGF5LSh0aGlzLmVudHJvcHktSi5zdGFydEVudHJvcHkpKS9NYXRoLmFicyh0aGlzLnBsYXliYWNrUmF0ZSk6cT0oai5kZWxheS0odGhpcy5jdXJyZW50VGltZS1KLnN0YXJ0VGltZSkpL3RoaXMucGxheWJhY2tSYXRlLEc9Si5zdGFydFRpbWUsWj1KLnN0YXJ0RW50cm9weSk6KHE9ai5kZWxheS8oai5pc0VudHJvcHk/TWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnRoaXMucGxheWJhY2tSYXRlKSxHPXRoaXMuY3VycmVudFRpbWUsWj10aGlzLmVudHJvcHkpO3ZhciB0dD10aGlzW1NdLGV0PXR0P3R0LnNldFRpbWVvdXQuYmluZCh0dCk6c2V0VGltZW91dCxpdD1qLmhlYWRpbmc7cmV0dXJuIXR0JiZpdD09PSExJiZxPDAmJihxPTEvMCksKGlzRmluaXRlKHEpfHx0dCkmJihxPU1hdGguY2VpbChxKSxldCE9PXNldFRpbWVvdXQmJihxPXtkZWxheTpxLGhlYWRpbmc6aXR9KSxGPWV0KGZ1bmN0aW9uKCl7JFtFXS5kZWxldGUoSCksQygpfSxxKSksdGhpc1tFXS5zZXQoSCx7dGltZXJJRDpGLGhhbmRsZXI6Qyx0aW1lOmosc3RhcnRUaW1lOkcsc3RhcnRFbnRyb3B5Olp9KSxIfX0se2tleToicGFyZW50IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tTXX19LHtrZXk6Imxhc3RUaW1lTWFyayIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbaF1bdGhpc1toXS5sZW5ndGgtMV19fSx7a2V5OiJjdXJyZW50VGltZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEM9dGhpcy5sYXN0VGltZU1hcmssaj1DLmxvY2FsVGltZSwkPUMuZ2xvYmFsVGltZTtyZXR1cm4gaisodGhpcy5nbG9iYWxUaW1lLSQpKnRoaXMucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oQyl7dmFyIGo9dGhpcywkPXRoaXMuY3VycmVudFRpbWUsSD1DLEo9dGhpc1tFXTt0aGlzLm1hcmtUaW1lKHt0aW1lOkN9KSxbXS5jb25jYXQoKDAsbC5kZWZhdWx0KShKKSkuZm9yRWFjaChmdW5jdGlvbihxKXt2YXIgRj0oMCxuLmRlZmF1bHQpKHEsMiksRz1GWzBdLFo9RlsxXTtpZihKLmhhcyhHKSl7dmFyIHR0PVoudGltZSxldD10dC5pc0VudHJvcHksaXQ9dHQuZGVsYXksaz10dC5oZWFkaW5nLGh0PVouaGFuZGxlcixmdD1aLnN0YXJ0VGltZTtpZihldClpdD09PTAmJihodCgpLGouY2xlYXJUaW1lb3V0KEcpKTtlbHNle3ZhciBCPWZ0K2l0OyhpdD09PTB8fGshPT0hMSYmKEgtJCkqaXQ8PTB8fCQ8PUImJkI8PUh8fCQ+PUImJkI+PUgpJiYoaHQoKSxqLmNsZWFyVGltZW91dChHKSl9fX0pLHRoaXMudXBkYXRlVGltZXJzKCl9fSx7a2V5OiJlbnRyb3B5IixnZXQ6ZnVuY3Rpb24oKXt2YXIgQz10aGlzLmxhc3RUaW1lTWFyayxqPUMuZW50cm9weSwkPUMuZ2xvYmFsRW50cm9weTtyZXR1cm4gaitNYXRoLmFicygodGhpcy5nbG9iYWxFbnRyb3B5LSQpKnRoaXMucGxheWJhY2tSYXRlKX0sc2V0OmZ1bmN0aW9uKEMpe2lmKHRoaXMuZW50cm9weT5DKXt2YXIgaj10aGlzLnNlZWtUaW1lTWFyayhDKTt0aGlzW2hdLmxlbmd0aD1qKzF9dGhpcy5tYXJrVGltZSh7ZW50cm9weTpDfSksdGhpcy51cGRhdGVUaW1lcnMoKX19LHtrZXk6Imdsb2JhbEVudHJvcHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1NdP3RoaXNbU10uZW50cm9weTp0aGlzLmdsb2JhbFRpbWV9fSx7a2V5OiJwbGF5YmFja1JhdGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2JdfSxzZXQ6ZnVuY3Rpb24oQyl7QyE9PXRoaXMucGxheWJhY2tSYXRlJiYodGhpcy5tYXJrVGltZSh7cGxheWJhY2tSYXRlOkN9KSx0aGlzW2JdPUMsdGhpcy51cGRhdGVUaW1lcnMoKSl9fSx7a2V5OiJwYXVzZWQiLGdldDpmdW5jdGlvbigpe2lmKHRoaXMucGxheWJhY2tSYXRlPT09MClyZXR1cm4hMDtmb3IodmFyIEM9dGhpcy5wYXJlbnQ7Qzspe2lmKEMucGxheWJhY2tSYXRlPT09MClyZXR1cm4hMDtDPUMucGFyZW50fXJldHVybiExfX1dKSxEfSgpO2UuZGVmYXVsdD1JfSxmdW5jdGlvbihkLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPXQoNzcpLG49YyhyKSxzPXQoMTI5KSxsPWMocyk7ZnVuY3Rpb24gYyhvKXtyZXR1cm4gbyYmby5fX2VzTW9kdWxlP286e2RlZmF1bHQ6b319ZS5kZWZhdWx0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbyhmLHgpe3ZhciBnPVtdLHk9ITAsbT0hMSxUPXZvaWQgMDt0cnl7Zm9yKHZhciBPPSgwLGwuZGVmYXVsdCkoZiksdjshKHk9KHY9Ty5uZXh0KCkpLmRvbmUpJiYoZy5wdXNoKHYudmFsdWUpLCEoeCYmZy5sZW5ndGg9PT14KSk7eT0hMCk7fWNhdGNoKFApe209ITAsVD1QfWZpbmFsbHl7dHJ5eyF5JiZPLnJldHVybiYmTy5yZXR1cm4oKX1maW5hbGx5e2lmKG0pdGhyb3cgVH19cmV0dXJuIGd9cmV0dXJuIGZ1bmN0aW9uKGYseCl7aWYoQXJyYXkuaXNBcnJheShmKSlyZXR1cm4gZjtpZigoMCxuLmRlZmF1bHQpKE9iamVjdChmKSkpcmV0dXJuIG8oZix4KTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpfSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXtkZWZhdWx0OnQoNzgpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihkLGUsdCl7dCg3OSksdCgxMjUpLGQuZXhwb3J0cz10KDEyNyl9LGZ1bmN0aW9uKGQsZSx0KXt0KDgwKTtmb3IodmFyIHI9dCg5MSksbj10KDk1KSxzPXQoODMpLGw9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLGM9IkNTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCxNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LFNWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LFRleHRUcmFja0xpc3QsVG91Y2hMaXN0Ii5zcGxpdCgiLCIpLG89MDtvPGMubGVuZ3RoO28rKyl7dmFyIGY9Y1tvXSx4PXJbZl0sZz14JiZ4LnByb3RvdHlwZTtnJiYhZ1tsXSYmbihnLGwsZiksc1tmXT1zLkFycmF5fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoODEpLG49dCg4Mikscz10KDgzKSxsPXQoODQpO2QuZXhwb3J0cz10KDg4KShBcnJheSwiQXJyYXkiLGZ1bmN0aW9uKGMsbyl7dGhpcy5fdD1sKGMpLHRoaXMuX2k9MCx0aGlzLl9rPW99LGZ1bmN0aW9uKCl7dmFyIGM9dGhpcy5fdCxvPXRoaXMuX2ssZj10aGlzLl9pKys7cmV0dXJuIWN8fGY+PWMubGVuZ3RoPyh0aGlzLl90PXZvaWQgMCxuKDEpKTpvPT0ia2V5cyI/bigwLGYpOm89PSJ2YWx1ZXMiP24oMCxjW2ZdKTpuKDAsW2YsY1tmXV0pfSwidmFsdWVzIikscy5Bcmd1bWVudHM9cy5BcnJheSxyKCJrZXlzIikscigidmFsdWVzIikscigiZW50cmllcyIpfSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1mdW5jdGlvbigpe319LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQscil7cmV0dXJue3ZhbHVlOnIsZG9uZTohIXR9fX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9e319LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDg1KSxuPXQoODcpO2QuZXhwb3J0cz1mdW5jdGlvbihzKXtyZXR1cm4gcihuKHMpKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDg2KTtkLmV4cG9ydHM9T2JqZWN0KCJ6IikucHJvcGVydHlJc0VudW1lcmFibGUoMCk/T2JqZWN0OmZ1bmN0aW9uKG4pe3JldHVybiByKG4pPT0iU3RyaW5nIj9uLnNwbGl0KCIiKTpPYmplY3Qobil9fSxmdW5jdGlvbihkLGUpe3ZhciB0PXt9LnRvU3RyaW5nO2QuZXhwb3J0cz1mdW5jdGlvbihyKXtyZXR1cm4gdC5jYWxsKHIpLnNsaWNlKDgsLTEpfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodD09bnVsbCl0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNhbGwgbWV0aG9kIG9uICAiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoODkpLG49dCg5MCkscz10KDEwNiksbD10KDk1KSxjPXQoODMpLG89dCgxMDcpLGY9dCgxMjEpLHg9dCgxMjMpLGc9dCgxMjIpKCJpdGVyYXRvciIpLHk9IShbXS5rZXlzJiYibmV4dCJpbltdLmtleXMoKSksbT0iQEBpdGVyYXRvciIsVD0ia2V5cyIsTz0idmFsdWVzIix2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2QuZXhwb3J0cz1mdW5jdGlvbihQLGksdSxhLGgsYixFKXtvKHUsaSxhKTt2YXIgQT1mdW5jdGlvbihGKXtpZigheSYmRiBpbiBEKXJldHVybiBEW0ZdO3N3aXRjaChGKXtjYXNlIFQ6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB1KHRoaXMsRil9O2Nhc2UgTzpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHUodGhpcyxGKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB1KHRoaXMsRil9fSxMPWkrIiBJdGVyYXRvciIsUz1oPT1PLEk9ITEsRD1QLnByb3RvdHlwZSxSPURbZ118fERbbV18fGgmJkRbaF0sQz1SfHxBKGgpLGo9aD9TP0EoImVudHJpZXMiKTpDOnZvaWQgMCwkPWk9PSJBcnJheSImJkQuZW50cmllc3x8UixILEoscTtpZigkJiYocT14KCQuY2FsbChuZXcgUCkpLHEhPT1PYmplY3QucHJvdG90eXBlJiZxLm5leHQmJihmKHEsTCwhMCksIXImJnR5cGVvZiBxW2ddIT0iZnVuY3Rpb24iJiZsKHEsZyx2KSkpLFMmJlImJlIubmFtZSE9PU8mJihJPSEwLEM9ZnVuY3Rpb24oKXtyZXR1cm4gUi5jYWxsKHRoaXMpfSksKCFyfHxFKSYmKHl8fEl8fCFEW2ddKSYmbChELGcsQyksY1tpXT1DLGNbTF09dixoKWlmKEg9e3ZhbHVlczpTP0M6QShPKSxrZXlzOmI/QzpBKFQpLGVudHJpZXM6an0sRSlmb3IoSiBpbiBIKUogaW4gRHx8cyhELEosSFtKXSk7ZWxzZSBuKG4uUCtuLkYqKHl8fEkpLGksSCk7cmV0dXJuIEh9fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz0hMH0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTEpLG49dCg5Mikscz10KDkzKSxsPXQoOTUpLGM9dCgxMDUpLG89InByb3RvdHlwZSIsZj1mdW5jdGlvbih4LGcseSl7dmFyIG09eCZmLkYsVD14JmYuRyxPPXgmZi5TLHY9eCZmLlAsUD14JmYuQixpPXgmZi5XLHU9VD9uOm5bZ118fChuW2ddPXt9KSxhPXVbb10saD1UP3I6Tz9yW2ddOihyW2ddfHx7fSlbb10sYixFLEE7VCYmKHk9Zyk7Zm9yKGIgaW4geSlFPSFtJiZoJiZoW2JdIT09dm9pZCAwLCEoRSYmYyh1LGIpKSYmKEE9RT9oW2JdOnlbYl0sdVtiXT1UJiZ0eXBlb2YgaFtiXSE9ImZ1bmN0aW9uIj95W2JdOlAmJkU/cyhBLHIpOmkmJmhbYl09PUE/ZnVuY3Rpb24oTCl7dmFyIFM9ZnVuY3Rpb24oSSxELFIpe2lmKHRoaXMgaW5zdGFuY2VvZiBMKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgTDtjYXNlIDE6cmV0dXJuIG5ldyBMKEkpO2Nhc2UgMjpyZXR1cm4gbmV3IEwoSSxEKX1yZXR1cm4gbmV3IEwoSSxELFIpfXJldHVybiBMLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIFNbb109TFtvXSxTfShBKTp2JiZ0eXBlb2YgQT09ImZ1bmN0aW9uIj9zKEZ1bmN0aW9uLmNhbGwsQSk6QSx2JiYoKHUudmlydHVhbHx8KHUudmlydHVhbD17fSkpW2JdPUEseCZmLlImJmEmJiFhW2JdJiZsKGEsYixBKSkpfTtmLkY9MSxmLkc9MixmLlM9NCxmLlA9OCxmLkI9MTYsZi5XPTMyLGYuVT02NCxmLlI9MTI4LGQuZXhwb3J0cz1mfSxmdW5jdGlvbihkLGUpe3ZhciB0PWQuZXhwb3J0cz10eXBlb2Ygd2luZG93PCJ1IiYmd2luZG93Lk1hdGg9PU1hdGg/d2luZG93OnR5cGVvZiBzZWxmPCJ1IiYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oInJldHVybiB0aGlzIikoKTt0eXBlb2YgX19nPT0ibnVtYmVyIiYmKF9fZz10KX0sZnVuY3Rpb24oZCxlKXt2YXIgdD1kLmV4cG9ydHM9e3ZlcnNpb246IjIuNi4xMSJ9O3R5cGVvZiBfX2U9PSJudW1iZXIiJiYoX19lPXQpfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5NCk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4scyxsKXtpZihyKG4pLHM9PT12b2lkIDApcmV0dXJuIG47c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIG4uY2FsbChzLGMpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKGMsbyl7cmV0dXJuIG4uY2FsbChzLGMsbyl9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24oYyxvLGYpe3JldHVybiBuLmNhbGwocyxjLG8sZil9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuLmFwcGx5KHMsYXJndW1lbnRzKX19fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0eXBlb2YgdCE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IodCsiIGlzIG5vdCBhIGZ1bmN0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTYpLG49dCgxMDQpO2QuZXhwb3J0cz10KDEwMCk/ZnVuY3Rpb24ocyxsLGMpe3JldHVybiByLmYocyxsLG4oMSxjKSl9OmZ1bmN0aW9uKHMsbCxjKXtyZXR1cm4gc1tsXT1jLHN9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5Nyksbj10KDk5KSxzPXQoMTAzKSxsPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTtlLmY9dCgxMDApP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihvLGYseCl7aWYocihvKSxmPXMoZiwhMCkscih4KSxuKXRyeXtyZXR1cm4gbChvLGYseCl9Y2F0Y2h7fWlmKCJnZXQiaW4geHx8InNldCJpbiB4KXRocm93IFR5cGVFcnJvcigiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhIik7cmV0dXJuInZhbHVlImluIHgmJihvW2ZdPXgudmFsdWUpLG99fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5OCk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4pe2lmKCFyKG4pKXRocm93IFR5cGVFcnJvcihuKyIgaXMgbm90IGFuIG9iamVjdCEiKTtyZXR1cm4gbn19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im9iamVjdCI/dCE9PW51bGw6dHlwZW9mIHQ9PSJmdW5jdGlvbiJ9fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPSF0KDEwMCkmJiF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQoMTAyKSgiZGl2IiksImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaHtyZXR1cm4hMH19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5OCksbj10KDkxKS5kb2N1bWVudCxzPXIobikmJnIobi5jcmVhdGVFbGVtZW50KTtkLmV4cG9ydHM9ZnVuY3Rpb24obCl7cmV0dXJuIHM/bi5jcmVhdGVFbGVtZW50KGwpOnt9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTgpO2QuZXhwb3J0cz1mdW5jdGlvbihuLHMpe2lmKCFyKG4pKXJldHVybiBuO3ZhciBsLGM7aWYocyYmdHlwZW9mKGw9bi50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFyKGM9bC5jYWxsKG4pKXx8dHlwZW9mKGw9bi52YWx1ZU9mKT09ImZ1bmN0aW9uIiYmIXIoYz1sLmNhbGwobikpfHwhcyYmdHlwZW9mKGw9bi50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFyKGM9bC5jYWxsKG4pKSlyZXR1cm4gYzt0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9ZnVuY3Rpb24odCxyKXtyZXR1cm57ZW51bWVyYWJsZTohKHQmMSksY29uZmlndXJhYmxlOiEodCYyKSx3cml0YWJsZTohKHQmNCksdmFsdWU6cn19fSxmdW5jdGlvbihkLGUpe3ZhciB0PXt9Lmhhc093blByb3BlcnR5O2QuZXhwb3J0cz1mdW5jdGlvbihyLG4pe3JldHVybiB0LmNhbGwocixuKX19LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9dCg5NSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDEwOCksbj10KDEwNCkscz10KDEyMSksbD17fTt0KDk1KShsLHQoMTIyKSgiaXRlcmF0b3IiKSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSksZC5leHBvcnRzPWZ1bmN0aW9uKGMsbyxmKXtjLnByb3RvdHlwZT1yKGwse25leHQ6bigxLGYpfSkscyhjLG8rIiBJdGVyYXRvciIpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTcpLG49dCgxMDkpLHM9dCgxMTkpLGw9dCgxMTYpKCJJRV9QUk9UTyIpLGM9ZnVuY3Rpb24oKXt9LG89InByb3RvdHlwZSIsZj1mdW5jdGlvbigpe3ZhciB4PXQoMTAyKSgiaWZyYW1lIiksZz1zLmxlbmd0aCx5PSI8IixtPSI+IixUO2Zvcih4LnN0eWxlLmRpc3BsYXk9Im5vbmUiLHQoMTIwKS5hcHBlbmRDaGlsZCh4KSx4LnNyYz0iamF2YXNjcmlwdDoiLFQ9eC5jb250ZW50V2luZG93LmRvY3VtZW50LFQub3BlbigpLFQud3JpdGUoeSsic2NyaXB0IittKyJkb2N1bWVudC5GPU9iamVjdCIreSsiL3NjcmlwdCIrbSksVC5jbG9zZSgpLGY9VC5GO2ctLTspZGVsZXRlIGZbb11bc1tnXV07cmV0dXJuIGYoKX07ZC5leHBvcnRzPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKGcseSl7dmFyIG07cmV0dXJuIGchPT1udWxsPyhjW29dPXIoZyksbT1uZXcgYyxjW29dPW51bGwsbVtsXT1nKTptPWYoKSx5PT09dm9pZCAwP206bihtLHkpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTYpLG49dCg5Nykscz10KDExMCk7ZC5leHBvcnRzPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbihjLG8pe24oYyk7Zm9yKHZhciBmPXMobykseD1mLmxlbmd0aCxnPTAseTt4Pmc7KXIuZihjLHk9ZltnKytdLG9beV0pO3JldHVybiBjfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTExKSxuPXQoMTE5KTtkLmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKGwpe3JldHVybiByKGwsbil9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMDUpLG49dCg4NCkscz10KDExMikoITEpLGw9dCgxMTYpKCJJRV9QUk9UTyIpO2QuZXhwb3J0cz1mdW5jdGlvbihjLG8pe3ZhciBmPW4oYykseD0wLGc9W10seTtmb3IoeSBpbiBmKXkhPWwmJnIoZix5KSYmZy5wdXNoKHkpO2Zvcig7by5sZW5ndGg+eDspcihmLHk9b1t4KytdKSYmKH5zKGcseSl8fGcucHVzaCh5KSk7cmV0dXJuIGd9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4NCksbj10KDExMykscz10KDExNSk7ZC5leHBvcnRzPWZ1bmN0aW9uKGwpe3JldHVybiBmdW5jdGlvbihjLG8sZil7dmFyIHg9cihjKSxnPW4oeC5sZW5ndGgpLHk9cyhmLGcpLG07aWYobCYmbyE9byl7Zm9yKDtnPnk7KWlmKG09eFt5KytdLG0hPW0pcmV0dXJuITB9ZWxzZSBmb3IoO2c+eTt5KyspaWYoKGx8fHkgaW4geCkmJnhbeV09PT1vKXJldHVybiBsfHx5fHwwO3JldHVybiFsJiYtMX19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTQpLG49TWF0aC5taW47ZC5leHBvcnRzPWZ1bmN0aW9uKHMpe3JldHVybiBzPjA/bihyKHMpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbihkLGUpe3ZhciB0PU1hdGguY2VpbCxyPU1hdGguZmxvb3I7ZC5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiBpc05hTihuPStuKT8wOihuPjA/cjp0KShuKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDExNCksbj1NYXRoLm1heCxzPU1hdGgubWluO2QuZXhwb3J0cz1mdW5jdGlvbihsLGMpe3JldHVybiBsPXIobCksbDwwP24obCtjLDApOnMobCxjKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDExNykoImtleXMiKSxuPXQoMTE4KTtkLmV4cG9ydHM9ZnVuY3Rpb24ocyl7cmV0dXJuIHJbc118fChyW3NdPW4ocykpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTIpLG49dCg5MSkscz0iX19jb3JlLWpzX3NoYXJlZF9fIixsPW5bc118fChuW3NdPXt9KTsoZC5leHBvcnRzPWZ1bmN0aW9uKGMsbyl7cmV0dXJuIGxbY118fChsW2NdPW8hPT12b2lkIDA/bzp7fSl9KSgidmVyc2lvbnMiLFtdKS5wdXNoKHt2ZXJzaW9uOnIudmVyc2lvbixtb2RlOnQoODkpPyJwdXJlIjoiZ2xvYmFsIixjb3B5cmlnaHQ6IsKpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSkifSl9LGZ1bmN0aW9uKGQsZSl7dmFyIHQ9MCxyPU1hdGgucmFuZG9tKCk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiJTeW1ib2woIi5jb25jYXQobj09PXZvaWQgMD8iIjpuLCIpXyIsKCsrdCtyKS50b1N0cmluZygzNikpfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9ImNvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZiIuc3BsaXQoIiwiKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTEpLmRvY3VtZW50O2QuZXhwb3J0cz1yJiZyLmRvY3VtZW50RWxlbWVudH0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTYpLmYsbj10KDEwNSkscz10KDEyMikoInRvU3RyaW5nVGFnIik7ZC5leHBvcnRzPWZ1bmN0aW9uKGwsYyxvKXtsJiYhbihsPW8/bDpsLnByb3RvdHlwZSxzKSYmcihsLHMse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpjfSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTcpKCJ3a3MiKSxuPXQoMTE4KSxzPXQoOTEpLlN5bWJvbCxsPXR5cGVvZiBzPT0iZnVuY3Rpb24iLGM9ZC5leHBvcnRzPWZ1bmN0aW9uKG8pe3JldHVybiByW29dfHwocltvXT1sJiZzW29dfHwobD9zOm4pKCJTeW1ib2wuIitvKSl9O2Muc3RvcmU9cn0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTA1KSxuPXQoMTI0KSxzPXQoMTE2KSgiSUVfUFJPVE8iKSxsPU9iamVjdC5wcm90b3R5cGU7ZC5leHBvcnRzPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oYyl7cmV0dXJuIGM9bihjKSxyKGMscyk/Y1tzXTp0eXBlb2YgYy5jb25zdHJ1Y3Rvcj09ImZ1bmN0aW9uIiYmYyBpbnN0YW5jZW9mIGMuY29uc3RydWN0b3I/Yy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6YyBpbnN0YW5jZW9mIE9iamVjdD9sOm51bGx9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4Nyk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiBPYmplY3QocihuKSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMjYpKCEwKTt0KDg4KShTdHJpbmcsIlN0cmluZyIsZnVuY3Rpb24obil7dGhpcy5fdD1TdHJpbmcobiksdGhpcy5faT0wfSxmdW5jdGlvbigpe3ZhciBuPXRoaXMuX3Qscz10aGlzLl9pLGw7cmV0dXJuIHM+PW4ubGVuZ3RoP3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06KGw9cihuLHMpLHRoaXMuX2krPWwubGVuZ3RoLHt2YWx1ZTpsLGRvbmU6ITF9KX0pfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTQpLG49dCg4Nyk7ZC5leHBvcnRzPWZ1bmN0aW9uKHMpe3JldHVybiBmdW5jdGlvbihsLGMpe3ZhciBvPVN0cmluZyhuKGwpKSxmPXIoYykseD1vLmxlbmd0aCxnLHk7cmV0dXJuIGY8MHx8Zj49eD9zPyIiOnZvaWQgMDooZz1vLmNoYXJDb2RlQXQoZiksZzw1NTI5Nnx8Zz41NjMxOXx8ZisxPT09eHx8KHk9by5jaGFyQ29kZUF0KGYrMSkpPDU2MzIwfHx5PjU3MzQzP3M/by5jaGFyQXQoZik6ZzpzP28uc2xpY2UoZixmKzIpOihnLTU1Mjk2PDwxMCkrKHktNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMjgpLG49dCgxMjIpKCJpdGVyYXRvciIpLHM9dCg4Myk7ZC5leHBvcnRzPXQoOTIpLmlzSXRlcmFibGU9ZnVuY3Rpb24obCl7dmFyIGM9T2JqZWN0KGwpO3JldHVybiBjW25dIT09dm9pZCAwfHwiQEBpdGVyYXRvciJpbiBjfHxzLmhhc093blByb3BlcnR5KHIoYykpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoODYpLG49dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLHM9cihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpPT0iQXJndW1lbnRzIixsPWZ1bmN0aW9uKGMsbyl7dHJ5e3JldHVybiBjW29dfWNhdGNoe319O2QuZXhwb3J0cz1mdW5jdGlvbihjKXt2YXIgbyxmLHg7cmV0dXJuIGM9PT12b2lkIDA/IlVuZGVmaW5lZCI6Yz09PW51bGw/Ik51bGwiOnR5cGVvZihmPWwobz1PYmplY3QoYyksbikpPT0ic3RyaW5nIj9mOnM/cihvKTooeD1yKG8pKT09Ik9iamVjdCImJnR5cGVvZiBvLmNhbGxlZT09ImZ1bmN0aW9uIj8iQXJndW1lbnRzIjp4fX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDEzMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDc5KSx0KDEyNSksZC5leHBvcnRzPXQoMTMxKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTcpLG49dCgxMzIpO2QuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvcj1mdW5jdGlvbihzKXt2YXIgbD1uKHMpO2lmKHR5cGVvZiBsIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihzKyIgaXMgbm90IGl0ZXJhYmxlISIpO3JldHVybiByKGwuY2FsbChzKSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMjgpLG49dCgxMjIpKCJpdGVyYXRvciIpLHM9dCg4Myk7ZC5leHBvcnRzPXQoOTIpLmdldEl0ZXJhdG9yTWV0aG9kPWZ1bmN0aW9uKGwpe2lmKGwhPW51bGwpcmV0dXJuIGxbbl18fGxbIkBAaXRlcmF0b3IiXXx8c1tyKGwpXX19LGZ1bmN0aW9uKGQsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIHI9dCgxMzQpLG49cyhyKTtmdW5jdGlvbiBzKGwpe3JldHVybiBsJiZsLl9fZXNNb2R1bGU/bDp7ZGVmYXVsdDpsfX1lLmRlZmF1bHQ9ZnVuY3Rpb24obCl7aWYoQXJyYXkuaXNBcnJheShsKSl7Zm9yKHZhciBjPTAsbz1BcnJheShsLmxlbmd0aCk7YzxsLmxlbmd0aDtjKyspb1tjXT1sW2NdO3JldHVybiBvfWVsc2UgcmV0dXJuKDAsbi5kZWZhdWx0KShsKX19LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihkLGUsdCl7dCgxMjUpLHQoMTM2KSxkLmV4cG9ydHM9dCg5MikuQXJyYXkuZnJvbX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTMpLG49dCg5MCkscz10KDEyNCksbD10KDEzNyksYz10KDEzOCksbz10KDExMyksZj10KDEzOSkseD10KDEzMik7bihuLlMrbi5GKiF0KDE0MCkoZnVuY3Rpb24oZyl7QXJyYXkuZnJvbShnKX0pLCJBcnJheSIse2Zyb206ZnVuY3Rpb24oeSl7dmFyIG09cyh5KSxUPXR5cGVvZiB0aGlzPT0iZnVuY3Rpb24iP3RoaXM6QXJyYXksTz1hcmd1bWVudHMubGVuZ3RoLHY9Tz4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsUD12IT09dm9pZCAwLGk9MCx1PXgobSksYSxoLGIsRTtpZihQJiYodj1yKHYsTz4yP2FyZ3VtZW50c1syXTp2b2lkIDAsMikpLHUhPW51bGwmJiEoVD09QXJyYXkmJmModSkpKWZvcihFPXUuY2FsbChtKSxoPW5ldyBUOyEoYj1FLm5leHQoKSkuZG9uZTtpKyspZihoLGksUD9sKEUsdixbYi52YWx1ZSxpXSwhMCk6Yi52YWx1ZSk7ZWxzZSBmb3IoYT1vKG0ubGVuZ3RoKSxoPW5ldyBUKGEpO2E+aTtpKyspZihoLGksUD92KG1baV0saSk6bVtpXSk7cmV0dXJuIGgubGVuZ3RoPWksaH19KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTcpO2QuZXhwb3J0cz1mdW5jdGlvbihuLHMsbCxjKXt0cnl7cmV0dXJuIGM/cyhyKGwpWzBdLGxbMV0pOnMobCl9Y2F0Y2goZil7dmFyIG89bi5yZXR1cm47dGhyb3cgbyE9PXZvaWQgMCYmcihvLmNhbGwobikpLGZ9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoODMpLG49dCgxMjIpKCJpdGVyYXRvciIpLHM9QXJyYXkucHJvdG90eXBlO2QuZXhwb3J0cz1mdW5jdGlvbihsKXtyZXR1cm4gbCE9PXZvaWQgMCYmKHIuQXJyYXk9PT1sfHxzW25dPT09bCl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5Niksbj10KDEwNCk7ZC5leHBvcnRzPWZ1bmN0aW9uKHMsbCxjKXtsIGluIHM/ci5mKHMsbCxuKDAsYykpOnNbbF09Y319LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDEyMikoIml0ZXJhdG9yIiksbj0hMTt0cnl7dmFyIHM9WzddW3JdKCk7cy5yZXR1cm49ZnVuY3Rpb24oKXtuPSEwfSxBcnJheS5mcm9tKHMsZnVuY3Rpb24oKXt0aHJvdyAyfSl9Y2F0Y2h7fWQuZXhwb3J0cz1mdW5jdGlvbihsLGMpe2lmKCFjJiYhbilyZXR1cm4hMTt2YXIgbz0hMTt0cnl7dmFyIGY9WzddLHg9ZltyXSgpO3gubmV4dD1mdW5jdGlvbigpe3JldHVybntkb25lOm89ITB9fSxmW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHh9LGwoZil9Y2F0Y2h7fXJldHVybiBvfX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDE0MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTQ0KSx0KDE1NyksdCgxNjApLHQoMTYyKSxkLmV4cG9ydHM9dCg5MikuTWFwfSxmdW5jdGlvbihkLGUpe30sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTQ1KSxuPXQoMTUxKSxzPSJNYXAiO2QuZXhwb3J0cz10KDE1MikocyxmdW5jdGlvbihsKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKX19LHtnZXQ6ZnVuY3Rpb24oYyl7dmFyIG89ci5nZXRFbnRyeShuKHRoaXMscyksYyk7cmV0dXJuIG8mJm8udn0sc2V0OmZ1bmN0aW9uKGMsbyl7cmV0dXJuIHIuZGVmKG4odGhpcyxzKSxjPT09MD8wOmMsbyl9fSxyLCEwKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTYpLmYsbj10KDEwOCkscz10KDE0NiksbD10KDkzKSxjPXQoMTQ3KSxvPXQoMTQ4KSxmPXQoODgpLHg9dCg4MiksZz10KDE0OSkseT10KDEwMCksbT10KDE1MCkuZmFzdEtleSxUPXQoMTUxKSxPPXk/Il9zIjoic2l6ZSIsdj1mdW5jdGlvbihQLGkpe3ZhciB1PW0oaSksYTtpZih1IT09IkYiKXJldHVybiBQLl9pW3VdO2ZvcihhPVAuX2Y7YTthPWEubilpZihhLms9PWkpcmV0dXJuIGF9O2QuZXhwb3J0cz17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24oUCxpLHUsYSl7dmFyIGg9UChmdW5jdGlvbihiLEUpe2MoYixoLGksIl9pIiksYi5fdD1pLGIuX2k9bihudWxsKSxiLl9mPXZvaWQgMCxiLl9sPXZvaWQgMCxiW09dPTAsRSE9bnVsbCYmbyhFLHUsYlthXSxiKX0pO3JldHVybiBzKGgucHJvdG90eXBlLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgRT1UKHRoaXMsaSksQT1FLl9pLEw9RS5fZjtMO0w9TC5uKUwucj0hMCxMLnAmJihMLnA9TC5wLm49dm9pZCAwKSxkZWxldGUgQVtMLmldO0UuX2Y9RS5fbD12b2lkIDAsRVtPXT0wfSxkZWxldGU6ZnVuY3Rpb24oYil7dmFyIEU9VCh0aGlzLGkpLEE9dihFLGIpO2lmKEEpe3ZhciBMPUEubixTPUEucDtkZWxldGUgRS5faVtBLmldLEEucj0hMCxTJiYoUy5uPUwpLEwmJihMLnA9UyksRS5fZj09QSYmKEUuX2Y9TCksRS5fbD09QSYmKEUuX2w9UyksRVtPXS0tfXJldHVybiEhQX0sZm9yRWFjaDpmdW5jdGlvbihFKXtUKHRoaXMsaSk7Zm9yKHZhciBBPWwoRSxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKSxMO0w9TD9MLm46dGhpcy5fZjspZm9yKEEoTC52LEwuayx0aGlzKTtMJiZMLnI7KUw9TC5wfSxoYXM6ZnVuY3Rpb24oRSl7cmV0dXJuISF2KFQodGhpcyxpKSxFKX19KSx5JiZyKGgucHJvdG90eXBlLCJzaXplIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFQodGhpcyxpKVtPXX19KSxofSxkZWY6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXYoUCxpKSxoLGI7cmV0dXJuIGE/YS52PXU6KFAuX2w9YT17aTpiPW0oaSwhMCksazppLHY6dSxwOmg9UC5fbCxuOnZvaWQgMCxyOiExfSxQLl9mfHwoUC5fZj1hKSxoJiYoaC5uPWEpLFBbT10rKyxiIT09IkYiJiYoUC5faVtiXT1hKSksUH0sZ2V0RW50cnk6dixzZXRTdHJvbmc6ZnVuY3Rpb24oUCxpLHUpe2YoUCxpLGZ1bmN0aW9uKGEsaCl7dGhpcy5fdD1UKGEsaSksdGhpcy5faz1oLHRoaXMuX2w9dm9pZCAwfSxmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLGg9YS5fayxiPWEuX2w7YiYmYi5yOyliPWIucDtyZXR1cm4hYS5fdHx8IShhLl9sPWI9Yj9iLm46YS5fdC5fZik/KGEuX3Q9dm9pZCAwLHgoMSkpOmg9PSJrZXlzIj94KDAsYi5rKTpoPT0idmFsdWVzIj94KDAsYi52KTp4KDAsW2IuayxiLnZdKX0sdT8iZW50cmllcyI6InZhbHVlcyIsIXUsITApLGcoaSl9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTUpO2QuZXhwb3J0cz1mdW5jdGlvbihuLHMsbCl7Zm9yKHZhciBjIGluIHMpbCYmbltjXT9uW2NdPXNbY106cihuLGMsc1tjXSk7cmV0dXJuIG59fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1mdW5jdGlvbih0LHIsbixzKXtpZighKHQgaW5zdGFuY2VvZiByKXx8cyE9PXZvaWQgMCYmcyBpbiB0KXRocm93IFR5cGVFcnJvcihuKyI6IGluY29ycmVjdCBpbnZvY2F0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24oZCxnLHQpe3ZhciByPXQoOTMpLG49dCgxMzcpLHM9dCgxMzgpLGw9dCg5NyksYz10KDExMyksbz10KDEzMiksZj17fSx4PXt9LGc9ZC5leHBvcnRzPWZ1bmN0aW9uKHksbSxULE8sdil7dmFyIFA9dj9mdW5jdGlvbigpe3JldHVybiB5fTpvKHkpLGk9cihULE8sbT8yOjEpLHU9MCxhLGgsYixFO2lmKHR5cGVvZiBQIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcih5KyIgaXMgbm90IGl0ZXJhYmxlISIpO2lmKHMoUCkpe2ZvcihhPWMoeS5sZW5ndGgpO2E+dTt1KyspaWYoRT1tP2kobChoPXlbdV0pWzBdLGhbMV0pOmkoeVt1XSksRT09PWZ8fEU9PT14KXJldHVybiBFfWVsc2UgZm9yKGI9UC5jYWxsKHkpOyEoaD1iLm5leHQoKSkuZG9uZTspaWYoRT1uKGIsaSxoLnZhbHVlLG0pLEU9PT1mfHxFPT09eClyZXR1cm4gRX07Zy5CUkVBSz1mLGcuUkVUVVJOPXh9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkxKSxuPXQoOTIpLHM9dCg5NiksbD10KDEwMCksYz10KDEyMikoInNwZWNpZXMiKTtkLmV4cG9ydHM9ZnVuY3Rpb24obyl7dmFyIGY9dHlwZW9mIG5bb109PSJmdW5jdGlvbiI/bltvXTpyW29dO2wmJmYmJiFmW2NdJiZzLmYoZixjLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9fSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTgpKCJtZXRhIiksbj10KDk4KSxzPXQoMTA1KSxsPXQoOTYpLmYsYz0wLG89T2JqZWN0LmlzRXh0ZW5zaWJsZXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZj0hdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIG8oT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSx4PWZ1bmN0aW9uKE8pe2woTyxyLHt2YWx1ZTp7aToiTyIrICsrYyx3Ont9fX0pfSxnPWZ1bmN0aW9uKE8sdil7aWYoIW4oTykpcmV0dXJuIHR5cGVvZiBPPT0ic3ltYm9sIj9POih0eXBlb2YgTz09InN0cmluZyI/IlMiOiJQIikrTztpZighcyhPLHIpKXtpZighbyhPKSlyZXR1cm4iRiI7aWYoIXYpcmV0dXJuIkUiO3goTyl9cmV0dXJuIE9bcl0uaX0seT1mdW5jdGlvbihPLHYpe2lmKCFzKE8scikpe2lmKCFvKE8pKXJldHVybiEwO2lmKCF2KXJldHVybiExO3goTyl9cmV0dXJuIE9bcl0ud30sbT1mdW5jdGlvbihPKXtyZXR1cm4gZiYmVC5ORUVEJiZvKE8pJiYhcyhPLHIpJiZ4KE8pLE99LFQ9ZC5leHBvcnRzPXtLRVk6cixORUVEOiExLGZhc3RLZXk6ZyxnZXRXZWFrOnksb25GcmVlemU6bX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDk4KTtkLmV4cG9ydHM9ZnVuY3Rpb24obixzKXtpZighcihuKXx8bi5fdCE9PXMpdGhyb3cgVHlwZUVycm9yKCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICIrcysiIHJlcXVpcmVkISIpO3JldHVybiBufX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTEpLG49dCg5MCkscz10KDE1MCksbD10KDEwMSksYz10KDk1KSxvPXQoMTQ2KSxmPXQoMTQ4KSx4PXQoMTQ3KSxnPXQoOTgpLHk9dCgxMjEpLG09dCg5NikuZixUPXQoMTUzKSgwKSxPPXQoMTAwKTtkLmV4cG9ydHM9ZnVuY3Rpb24odixQLGksdSxhLGgpe3ZhciBiPXJbdl0sRT1iLEE9YT8ic2V0IjoiYWRkIixMPUUmJkUucHJvdG90eXBlLFM9e307cmV0dXJuIU98fHR5cGVvZiBFIT0iZnVuY3Rpb24ifHwhKGh8fEwuZm9yRWFjaCYmIWwoZnVuY3Rpb24oKXtuZXcgRSgpLmVudHJpZXMoKS5uZXh0KCl9KSk/KEU9dS5nZXRDb25zdHJ1Y3RvcihQLHYsYSxBKSxvKEUucHJvdG90eXBlLGkpLHMuTkVFRD0hMCk6KEU9UChmdW5jdGlvbihJLEQpe3goSSxFLHYsIl9jIiksSS5fYz1uZXcgYixEIT1udWxsJiZmKEQsYSxJW0FdLEkpfSksVCgiYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OIi5zcGxpdCgiLCIpLGZ1bmN0aW9uKEkpe3ZhciBEPUk9PSJhZGQifHxJPT0ic2V0IjtJIGluIEwmJiEoaCYmST09ImNsZWFyIikmJmMoRS5wcm90b3R5cGUsSSxmdW5jdGlvbihSLEMpe2lmKHgodGhpcyxFLEkpLCFEJiZoJiYhZyhSKSlyZXR1cm4gST09ImdldCI/dm9pZCAwOiExO3ZhciBqPXRoaXMuX2NbSV0oUj09PTA/MDpSLEMpO3JldHVybiBEP3RoaXM6an0pfSksaHx8bShFLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jLnNpemV9fSkpLHkoRSx2KSxTW3ZdPUUsbihuLkcrbi5XK24uRixTKSxofHx1LnNldFN0cm9uZyhFLHYsYSksRX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkzKSxuPXQoODUpLHM9dCgxMjQpLGw9dCgxMTMpLGM9dCgxNTQpO2QuZXhwb3J0cz1mdW5jdGlvbihvLGYpe3ZhciB4PW89PTEsZz1vPT0yLHk9bz09MyxtPW89PTQsVD1vPT02LE89bz09NXx8VCx2PWZ8fGM7cmV0dXJuIGZ1bmN0aW9uKFAsaSx1KXtmb3IodmFyIGE9cyhQKSxoPW4oYSksYj1yKGksdSwzKSxFPWwoaC5sZW5ndGgpLEE9MCxMPXg/dihQLEUpOmc/dihQLDApOnZvaWQgMCxTLEk7RT5BO0ErKylpZigoT3x8QSBpbiBoKSYmKFM9aFtBXSxJPWIoUyxBLGEpLG8pKXtpZih4KUxbQV09STtlbHNlIGlmKEkpc3dpdGNoKG8pe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIFM7Y2FzZSA2OnJldHVybiBBO2Nhc2UgMjpMLnB1c2goUyl9ZWxzZSBpZihtKXJldHVybiExfXJldHVybiBUPy0xOnl8fG0/bTpMfX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDE1NSk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4scyl7cmV0dXJuIG5ldyhyKG4pKShzKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDk4KSxuPXQoMTU2KSxzPXQoMTIyKSgic3BlY2llcyIpO2QuZXhwb3J0cz1mdW5jdGlvbihsKXt2YXIgYztyZXR1cm4gbihsKSYmKGM9bC5jb25zdHJ1Y3Rvcix0eXBlb2YgYz09ImZ1bmN0aW9uIiYmKGM9PT1BcnJheXx8bihjLnByb3RvdHlwZSkpJiYoYz12b2lkIDApLHIoYykmJihjPWNbc10sYz09PW51bGwmJihjPXZvaWQgMCkpKSxjPT09dm9pZCAwP0FycmF5OmN9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4Nik7ZC5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHMpe3JldHVybiByKHMpPT0iQXJyYXkifX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTApO3Ioci5QK3IuUiwiTWFwIix7dG9KU09OOnQoMTU4KSgiTWFwIil9KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTI4KSxuPXQoMTU5KTtkLmV4cG9ydHM9ZnVuY3Rpb24ocyl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYocih0aGlzKSE9cyl0aHJvdyBUeXBlRXJyb3IocysiI3RvSlNPTiBpc24ndCBnZW5lcmljIik7cmV0dXJuIG4odGhpcyl9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTQ4KTtkLmV4cG9ydHM9ZnVuY3Rpb24obixzKXt2YXIgbD1bXTtyZXR1cm4gcihuLCExLGwucHVzaCxsLHMpLGx9fSxmdW5jdGlvbihkLGUsdCl7dCgxNjEpKCJNYXAiKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTApO2QuZXhwb3J0cz1mdW5jdGlvbihuKXtyKHIuUyxuLHtvZjpmdW5jdGlvbigpe2Zvcih2YXIgbD1hcmd1bWVudHMubGVuZ3RoLGM9bmV3IEFycmF5KGwpO2wtLTspY1tsXT1hcmd1bWVudHNbbF07cmV0dXJuIG5ldyB0aGlzKGMpfX0pfX0sZnVuY3Rpb24oZCxlLHQpe3QoMTYzKSgiTWFwIil9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKSxuPXQoOTQpLHM9dCg5MyksbD10KDE0OCk7ZC5leHBvcnRzPWZ1bmN0aW9uKGMpe3Ioci5TLGMse2Zyb206ZnVuY3Rpb24oZil7dmFyIHg9YXJndW1lbnRzWzFdLGcseSxtLFQ7cmV0dXJuIG4odGhpcyksZz14IT09dm9pZCAwLGcmJm4oeCksZj09bnVsbD9uZXcgdGhpczooeT1bXSxnPyhtPTAsVD1zKHgsYXJndW1lbnRzWzJdLDIpLGwoZiwhMSxmdW5jdGlvbihPKXt5LnB1c2goVChPLG0rKykpfSkpOmwoZiwhMSx5LnB1c2gseSksbmV3IHRoaXMoeSkpfX0pfX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDE2NSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDE2NiksZC5leHBvcnRzPXQoOTIpLk9iamVjdC5hc3NpZ259LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKTtyKHIuUytyLkYsIk9iamVjdCIse2Fzc2lnbjp0KDE2Nyl9KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTAwKSxuPXQoMTEwKSxzPXQoMTY4KSxsPXQoMTY5KSxjPXQoMTI0KSxvPXQoODUpLGY9T2JqZWN0LmFzc2lnbjtkLmV4cG9ydHM9IWZ8fHQoMTAxKShmdW5jdGlvbigpe3ZhciB4PXt9LGc9e30seT1TeW1ib2woKSxtPSJhYmNkZWZnaGlqa2xtbm9wcXJzdCI7cmV0dXJuIHhbeV09NyxtLnNwbGl0KCIiKS5mb3JFYWNoKGZ1bmN0aW9uKFQpe2dbVF09VH0pLGYoe30seClbeV0hPTd8fE9iamVjdC5rZXlzKGYoe30sZykpLmpvaW4oIiIpIT1tfSk/ZnVuY3Rpb24oZyx5KXtmb3IodmFyIG09YyhnKSxUPWFyZ3VtZW50cy5sZW5ndGgsTz0xLHY9cy5mLFA9bC5mO1Q+TzspZm9yKHZhciBpPW8oYXJndW1lbnRzW08rK10pLHU9dj9uKGkpLmNvbmNhdCh2KGkpKTpuKGkpLGE9dS5sZW5ndGgsaD0wLGI7YT5oOyliPXVbaCsrXSwoIXJ8fFAuY2FsbChpLGIpKSYmKG1bYl09aVtiXSk7cmV0dXJuIG19OmZ9LGZ1bmN0aW9uKGQsZSl7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LGZ1bmN0aW9uKGQsZSl7ZS5mPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlfSxmdW5jdGlvbihkLGUsdCl7ZS5fX2VzTW9kdWxlPSEwLGUuZGVmYXVsdD1mdW5jdGlvbihyLG4pe2lmKCEociBpbnN0YW5jZW9mIG4pKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfX0sZnVuY3Rpb24oZCxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgcj10KDE3Miksbj1zKHIpO2Z1bmN0aW9uIHMobCl7cmV0dXJuIGwmJmwuX19lc01vZHVsZT9sOntkZWZhdWx0Omx9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGwoYyxvKXtmb3IodmFyIGY9MDtmPG8ubGVuZ3RoO2YrKyl7dmFyIHg9b1tmXTt4LmVudW1lcmFibGU9eC5lbnVtZXJhYmxlfHwhMSx4LmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4geCYmKHgud3JpdGFibGU9ITApLCgwLG4uZGVmYXVsdCkoYyx4LmtleSx4KX19cmV0dXJuIGZ1bmN0aW9uKGMsbyxmKXtyZXR1cm4gbyYmbChjLnByb3RvdHlwZSxvKSxmJiZsKGMsZiksY319KCl9LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNzMpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihkLGUsdCl7dCgxNzQpO3ZhciByPXQoOTIpLk9iamVjdDtkLmV4cG9ydHM9ZnVuY3Rpb24ocyxsLGMpe3JldHVybiByLmRlZmluZVByb3BlcnR5KHMsbCxjKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKTtyKHIuUytyLkYqIXQoMTAwKSwiT2JqZWN0Iix7ZGVmaW5lUHJvcGVydHk6dCg5NikuZn0pfSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXtkZWZhdWx0OnQoMTc2KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oZCxlLHQpe3QoMTc3KSx0KDE0MyksdCgxODQpLHQoMTg1KSxkLmV4cG9ydHM9dCg5MikuU3ltYm9sfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5MSksbj10KDEwNSkscz10KDEwMCksbD10KDkwKSxjPXQoMTA2KSxvPXQoMTUwKS5LRVksZj10KDEwMSkseD10KDExNyksZz10KDEyMSkseT10KDExOCksbT10KDEyMiksVD10KDE3OCksTz10KDE3OSksdj10KDE4MCksUD10KDE1NiksaT10KDk3KSx1PXQoOTgpLGE9dCgxMjQpLGg9dCg4NCksYj10KDEwMyksRT10KDEwNCksQT10KDEwOCksTD10KDE4MSksUz10KDE4MyksST10KDE2OCksRD10KDk2KSxSPXQoMTEwKSxDPVMuZixqPUQuZiwkPUwuZixIPXIuU3ltYm9sLEo9ci5KU09OLHE9SiYmSi5zdHJpbmdpZnksRj0icHJvdG90eXBlIixHPW0oIl9oaWRkZW4iKSxaPW0oInRvUHJpbWl0aXZlIiksdHQ9e30ucHJvcGVydHlJc0VudW1lcmFibGUsZXQ9eCgic3ltYm9sLXJlZ2lzdHJ5IiksaXQ9eCgic3ltYm9scyIpLGs9eCgib3Atc3ltYm9scyIpLGh0PU9iamVjdFtGXSxmdD10eXBlb2YgSD09ImZ1bmN0aW9uIiYmISFJLmYsQj1yLlFPYmplY3QsVz0hQnx8IUJbRl18fCFCW0ZdLmZpbmRDaGlsZCxWPXMmJmYoZnVuY3Rpb24oKXtyZXR1cm4gQShqKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGoodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hIT03fSk/ZnVuY3Rpb24ob3Qsc3QsbHQpe3ZhciBtdD1DKGh0LHN0KTttdCYmZGVsZXRlIGh0W3N0XSxqKG90LHN0LGx0KSxtdCYmb3QhPT1odCYmaihodCxzdCxtdCl9OmosWD1mdW5jdGlvbihvdCl7dmFyIHN0PWl0W290XT1BKEhbRl0pO3JldHVybiBzdC5faz1vdCxzdH0sTj1mdCYmdHlwZW9mIEguaXRlcmF0b3I9PSJzeW1ib2wiP2Z1bmN0aW9uKG90KXtyZXR1cm4gdHlwZW9mIG90PT0ic3ltYm9sIn06ZnVuY3Rpb24ob3Qpe3JldHVybiBvdCBpbnN0YW5jZW9mIEh9LHo9ZnVuY3Rpb24oc3QsbHQsbXQpe3JldHVybiBzdD09PWh0JiZ6KGssbHQsbXQpLGkoc3QpLGx0PWIobHQsITApLGkobXQpLG4oaXQsbHQpPyhtdC5lbnVtZXJhYmxlPyhuKHN0LEcpJiZzdFtHXVtsdF0mJihzdFtHXVtsdF09ITEpLG10PUEobXQse2VudW1lcmFibGU6RSgwLCExKX0pKToobihzdCxHKXx8aihzdCxHLEUoMSx7fSkpLHN0W0ddW2x0XT0hMCksVihzdCxsdCxtdCkpOmooc3QsbHQsbXQpfSxwPWZ1bmN0aW9uKHN0LGx0KXtpKHN0KTtmb3IodmFyIG10PXYobHQ9aChsdCkpLHB0PTAsZHQ9bXQubGVuZ3RoLHl0O2R0PnB0Oyl6KHN0LHl0PW10W3B0KytdLGx0W3l0XSk7cmV0dXJuIHN0fSxNPWZ1bmN0aW9uKHN0LGx0KXtyZXR1cm4gbHQ9PT12b2lkIDA/QShzdCk6cChBKHN0KSxsdCl9LHc9ZnVuY3Rpb24oc3Qpe3ZhciBsdD10dC5jYWxsKHRoaXMsc3Q9YihzdCwhMCkpO3JldHVybiB0aGlzPT09aHQmJm4oaXQsc3QpJiYhbihrLHN0KT8hMTpsdHx8IW4odGhpcyxzdCl8fCFuKGl0LHN0KXx8bih0aGlzLEcpJiZ0aGlzW0ddW3N0XT9sdDohMH0sVT1mdW5jdGlvbihzdCxsdCl7aWYoc3Q9aChzdCksbHQ9YihsdCwhMCksIShzdD09PWh0JiZuKGl0LGx0KSYmIW4oayxsdCkpKXt2YXIgbXQ9QyhzdCxsdCk7cmV0dXJuIG10JiZuKGl0LGx0KSYmIShuKHN0LEcpJiZzdFtHXVtsdF0pJiYobXQuZW51bWVyYWJsZT0hMCksbXR9fSxLPWZ1bmN0aW9uKHN0KXtmb3IodmFyIGx0PSQoaChzdCkpLG10PVtdLHB0PTAsZHQ7bHQubGVuZ3RoPnB0OykhbihpdCxkdD1sdFtwdCsrXSkmJmR0IT1HJiZkdCE9byYmbXQucHVzaChkdCk7cmV0dXJuIG10fSxZPWZ1bmN0aW9uKHN0KXtmb3IodmFyIGx0PXN0PT09aHQsbXQ9JChsdD9rOmgoc3QpKSxwdD1bXSxkdD0wLHl0O210Lmxlbmd0aD5kdDspbihpdCx5dD1tdFtkdCsrXSkmJighbHR8fG4oaHQseXQpKSYmcHQucHVzaChpdFt5dF0pO3JldHVybiBwdH07ZnR8fChIPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIEgpdGhyb3cgVHlwZUVycm9yKCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhIik7dmFyIHN0PXkoYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApLGx0PWZ1bmN0aW9uKG10KXt0aGlzPT09aHQmJmx0LmNhbGwoayxtdCksbih0aGlzLEcpJiZuKHRoaXNbR10sc3QpJiYodGhpc1tHXVtzdF09ITEpLFYodGhpcyxzdCxFKDEsbXQpKX07cmV0dXJuIHMmJlcmJlYoaHQsc3Qse2NvbmZpZ3VyYWJsZTohMCxzZXQ6bHR9KSxYKHN0KX0sYyhIW0ZdLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa30pLFMuZj1VLEQuZj16LHQoMTgyKS5mPUwuZj1LLHQoMTY5KS5mPXcsSS5mPVkscyYmIXQoODkpJiZjKGh0LCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsdywhMCksVC5mPWZ1bmN0aW9uKG90KXtyZXR1cm4gWChtKG90KSl9KSxsKGwuRytsLlcrbC5GKiFmdCx7U3ltYm9sOkh9KTtmb3IodmFyIFE9Imhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzIi5zcGxpdCgiLCIpLHJ0PTA7US5sZW5ndGg+cnQ7KW0oUVtydCsrXSk7Zm9yKHZhciBudD1SKG0uc3RvcmUpLGF0PTA7bnQubGVuZ3RoPmF0OylPKG50W2F0KytdKTtsKGwuUytsLkYqIWZ0LCJTeW1ib2wiLHtmb3I6ZnVuY3Rpb24ob3Qpe3JldHVybiBuKGV0LG90Kz0iIik/ZXRbb3RdOmV0W290XT1IKG90KX0sa2V5Rm9yOmZ1bmN0aW9uKHN0KXtpZighTihzdCkpdGhyb3cgVHlwZUVycm9yKHN0KyIgaXMgbm90IGEgc3ltYm9sISIpO2Zvcih2YXIgbHQgaW4gZXQpaWYoZXRbbHRdPT09c3QpcmV0dXJuIGx0fSx1c2VTZXR0ZXI6ZnVuY3Rpb24oKXtXPSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXtXPSExfX0pLGwobC5TK2wuRiohZnQsIk9iamVjdCIse2NyZWF0ZTpNLGRlZmluZVByb3BlcnR5OnosZGVmaW5lUHJvcGVydGllczpwLGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpVLGdldE93blByb3BlcnR5TmFtZXM6SyxnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6WX0pO3ZhciBjdD1mKGZ1bmN0aW9uKCl7SS5mKDEpfSk7bChsLlMrbC5GKmN0LCJPYmplY3QiLHtnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ZnVuY3Rpb24oc3Qpe3JldHVybiBJLmYoYShzdCkpfX0pLEomJmwobC5TK2wuRiooIWZ0fHxmKGZ1bmN0aW9uKCl7dmFyIG90PUgoKTtyZXR1cm4gcShbb3RdKSE9IltudWxsXSJ8fHEoe2E6b3R9KSE9Int9Inx8cShPYmplY3Qob3QpKSE9Int9In0pKSwiSlNPTiIse3N0cmluZ2lmeTpmdW5jdGlvbihzdCl7Zm9yKHZhciBsdD1bc3RdLG10PTEscHQsZHQ7YXJndW1lbnRzLmxlbmd0aD5tdDspbHQucHVzaChhcmd1bWVudHNbbXQrK10pO2lmKGR0PXB0PWx0WzFdLCEoIXUocHQpJiZzdD09PXZvaWQgMHx8TihzdCkpKXJldHVybiBQKHB0KXx8KHB0PWZ1bmN0aW9uKHl0LEF0KXtpZih0eXBlb2YgZHQ9PSJmdW5jdGlvbiImJihBdD1kdC5jYWxsKHRoaXMseXQsQXQpKSwhTihBdCkpcmV0dXJuIEF0fSksbHRbMV09cHQscS5hcHBseShKLGx0KX19KSxIW0ZdW1pdfHx0KDk1KShIW0ZdLFosSFtGXS52YWx1ZU9mKSxnKEgsIlN5bWJvbCIpLGcoTWF0aCwiTWF0aCIsITApLGcoci5KU09OLCJKU09OIiwhMCl9LGZ1bmN0aW9uKGQsZSx0KXtlLmY9dCgxMjIpfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5MSksbj10KDkyKSxzPXQoODkpLGw9dCgxNzgpLGM9dCg5NikuZjtkLmV4cG9ydHM9ZnVuY3Rpb24obyl7dmFyIGY9bi5TeW1ib2x8fChuLlN5bWJvbD1zP3t9OnIuU3ltYm9sfHx7fSk7by5jaGFyQXQoMCkhPSJfIiYmIShvIGluIGYpJiZjKGYsbyx7dmFsdWU6bC5mKG8pfSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTApLG49dCgxNjgpLHM9dCgxNjkpO2QuZXhwb3J0cz1mdW5jdGlvbihsKXt2YXIgYz1yKGwpLG89bi5mO2lmKG8pZm9yKHZhciBmPW8obCkseD1zLmYsZz0wLHk7Zi5sZW5ndGg+ZzspeC5jYWxsKGwseT1mW2crK10pJiZjLnB1c2goeSk7cmV0dXJuIGN9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4NCksbj10KDE4MikuZixzPXt9LnRvU3RyaW5nLGw9dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXSxjPWZ1bmN0aW9uKG8pe3RyeXtyZXR1cm4gbihvKX1jYXRjaHtyZXR1cm4gbC5zbGljZSgpfX07ZC5leHBvcnRzLmY9ZnVuY3Rpb24oZil7cmV0dXJuIGwmJnMuY2FsbChmKT09IltvYmplY3QgV2luZG93XSI/YyhmKTpuKHIoZikpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTExKSxuPXQoMTE5KS5jb25jYXQoImxlbmd0aCIsInByb3RvdHlwZSIpO2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc3x8ZnVuY3Rpb24obCl7cmV0dXJuIHIobCxuKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDE2OSksbj10KDEwNCkscz10KDg0KSxsPXQoMTAzKSxjPXQoMTA1KSxvPXQoOTkpLGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtlLmY9dCgxMDApP2Y6ZnVuY3Rpb24oZyx5KXtpZihnPXMoZykseT1sKHksITApLG8pdHJ5e3JldHVybiBmKGcseSl9Y2F0Y2h7fWlmKGMoZyx5KSlyZXR1cm4gbighci5mLmNhbGwoZyx5KSxnW3ldKX19LGZ1bmN0aW9uKGQsZSx0KXt0KDE3OSkoImFzeW5jSXRlcmF0b3IiKX0sZnVuY3Rpb24oZCxlLHQpe3QoMTc5KSgib2JzZXJ2YWJsZSIpfSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuY3JlYXRlTm93VGltZT1yLGUuZm9ybWF0RGVsYXk9bjtmdW5jdGlvbiByKCl7dmFyIHM9bnVsbDtyZXR1cm4gRGF0ZS5ub3c/cz1EYXRlLm5vdzpzPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpfSxzfWZ1bmN0aW9uIG4ocyl7cmV0dXJuIHR5cGVvZiBzPT0ibnVtYmVyIj9zPXtkZWxheTpzfToiZW50cm9weSJpbiBzJiYocz17ZGVsYXk6cy5lbnRyb3B5LGlzRW50cm9weTohMH0pLHN9fSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD17ZGVmYXVsdDpmdW5jdGlvbihuLHMsbCxjLG8pe3JldHVybiB0eXBlb2Ygbj09Im51bWJlciImJnR5cGVvZiBzPT0ibnVtYmVyIj9uKyhsLWMpLyhvLWMpKihzLW4pOmwtYz5vLWw/czpufX19LGZ1bmN0aW9uKGQsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5wYXJzZUVhc2luZz1lLkVhc2luZ3M9dm9pZCAwO3ZhciByPXQoNzYpLG49ZihyKSxzPXQoMTMzKSxsPWYocyksYz10KDE0MSksbz1mKGMpO2Z1bmN0aW9uIGYoUCl7cmV0dXJuIFAmJlAuX19lc01vZHVsZT9QOntkZWZhdWx0OlB9fXZhciB4PXQoMTg5KSxnPW5ldyBvLmRlZmF1bHQ7ZnVuY3Rpb24geSgpe2Zvcih2YXIgUD1hcmd1bWVudHMubGVuZ3RoLGk9QXJyYXkoUCksdT0wO3U8UDt1KyspaVt1XT1hcmd1bWVudHNbdV07dmFyIGE9Zy5nZXQoaSk7cmV0dXJuIGF8fChhPXguYXBwbHkodm9pZCAwLGkpLGcuc2V0KGksYSksYSl9ZnVuY3Rpb24gbShQKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06ImVuZCI7cmV0dXJuIGZ1bmN0aW9uKHUsYSl7Zm9yKHZhciBoPTE7aDxhLmxlbmd0aDtoKyspe3ZhciBiPWFbaF0ub2Zmc2V0O2lmKHU8PWIpe3ZhciBFPWFbaC0xXS5vZmZzZXQsQT1iLEw9KHUtRSkvKEEtRSksUz0xL1AsST1ML1M7cmV0dXJuIGk9PT0iZW5kIj9JPU1hdGguZmxvb3IoSSk6ST1NYXRoLmNlaWwoSSksUypJKihBLUUpK0V9fXJldHVybiAwfX1mdW5jdGlvbiBUKFApe3ZhciBpPS9eY3ViaWMtYmV6aWVyXCgoLiopXCkvLHU9UC5tYXRjaChpKTtpZih1KXt2YXIgYT11WzFdLnRyaW0oKTtyZXR1cm4gYT1hLnNwbGl0KCIsIikubWFwKGZ1bmN0aW9uKFMpe3JldHVybiBwYXJzZUZsb2F0KFMudHJpbSgpKX0pLHkuYXBwbHkodm9pZCAwLCgwLGwuZGVmYXVsdCkoYSkpfWlmKGk9L15zdGVwc1woKC4qKVwpLyx1PVAubWF0Y2goaSksdSl7dmFyIGg9dVsxXS50cmltKCk7aD1oLnNwbGl0KCIsIikubWFwKGZ1bmN0aW9uKFMpe3JldHVybiBTLnRyaW0oKX0pO3ZhciBiPWgsRT0oMCxuLmRlZmF1bHQpKGIsMiksQT1FWzBdLEw9RVsxXTtyZXR1cm4gbShwYXJzZUludChBLDEwKSxMKX1yZXR1cm4gUH12YXIgTz17bGluZWFyOmZ1bmN0aW9uKGkpe3JldHVybiBpfSxlYXNlOnkoLjI1LC4xLC4yNSwxKSwiZWFzZS1pbiI6eSguNDIsMCwxLDEpLCJlYXNlLW91dCI6eSgwLDAsLjU4LDEpLCJlYXNlLWluLW91dCI6eSguNDIsMCwuNTgsMSksInN0ZXAtc3RhcnQiOm0oMSwic3RhcnQiKSwic3RlcC1lbmQiOm0oMSwiZW5kIil9O2Z1bmN0aW9uIHYoUCl7cmV0dXJuIHR5cGVvZiBQPT0ic3RyaW5nIj9PW1BdP1A9T1tQXTpQPVQoUCk6UC50eXBlPT09ImN1YmljLWJlemllciI/UD15LmFwcGx5KHZvaWQgMCwoMCxsLmRlZmF1bHQpKFAudmFsdWUpKTpQLnR5cGU9PT0ic3RlcHMiJiYoUD1tKFAuc3RlcCxQLnBvcykpLFB9ZS5FYXNpbmdzPU8sZS5wYXJzZUVhc2luZz12fSxmdW5jdGlvbihkLGUpe3ZhciB0PTQscj0uMDAxLG49MWUtNyxzPTEwLGw9MTEsYz0xLyhsLTEpLG89dHlwZW9mIEZsb2F0MzJBcnJheT09ImZ1bmN0aW9uIjtmdW5jdGlvbiBmKFAsaSl7cmV0dXJuIDEtMyppKzMqUH1mdW5jdGlvbiB4KFAsaSl7cmV0dXJuIDMqaS02KlB9ZnVuY3Rpb24gZyhQKXtyZXR1cm4gMypQfWZ1bmN0aW9uIHkoUCxpLHUpe3JldHVybigoZihpLHUpKlAreChpLHUpKSpQK2coaSkpKlB9ZnVuY3Rpb24gbShQLGksdSl7cmV0dXJuIDMqZihpLHUpKlAqUCsyKngoaSx1KSpQK2coaSl9ZnVuY3Rpb24gVChQLGksdSxhLGgpe3ZhciBiLEUsQT0wO2RvIEU9aSsodS1pKS8yLGI9eShFLGEsaCktUCxiPjA/dT1FOmk9RTt3aGlsZShNYXRoLmFicyhiKT5uJiYrK0E8cyk7cmV0dXJuIEV9ZnVuY3Rpb24gTyhQLGksdSxhKXtmb3IodmFyIGg9MDtoPHQ7KytoKXt2YXIgYj1tKGksdSxhKTtpZihiPT09MClyZXR1cm4gaTt2YXIgRT15KGksdSxhKS1QO2ktPUUvYn1yZXR1cm4gaX1mdW5jdGlvbiB2KFApe3JldHVybiBQfWQuZXhwb3J0cz1mdW5jdGlvbihpLHUsYSxoKXtpZighKDA8PWkmJmk8PTEmJjA8PWEmJmE8PTEpKXRocm93IG5ldyBFcnJvcigiYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlIik7aWYoaT09PXUmJmE9PT1oKXJldHVybiB2O2Zvcih2YXIgYj1vP25ldyBGbG9hdDMyQXJyYXkobCk6bmV3IEFycmF5KGwpLEU9MDtFPGw7KytFKWJbRV09eShFKmMsaSxhKTtmdW5jdGlvbiBBKEwpe2Zvcih2YXIgUz0wLEk9MSxEPWwtMTtJIT09RCYmYltJXTw9TDsrK0kpUys9YzstLUk7dmFyIFI9KEwtYltJXSkvKGJbSSsxXS1iW0ldKSxDPVMrUipjLGo9bShDLGksYSk7cmV0dXJuIGo+PXI/TyhMLEMsaSxhKTpqPT09MD9DOlQoTCxTLFMrYyxpLGEpfXJldHVybiBmdW5jdGlvbihTKXtyZXR1cm4gUz09PTA/MDpTPT09MT8xOnkoQShTKSx1LGgpfX19LGZ1bmN0aW9uKGQsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9dCgxOTEpLG49dShyKSxzPXQoMjA0KSxsPXUocyksYz10KDE2NCksbz11KGMpLGY9dCgxNzApLHg9dShmKSxnPXQoMTcxKSx5PXUoZyksbT10KDE3NSksVD11KG0pLE89dCg3NSksdj11KE8pLFA9dCgyMDgpLGk9dCgxODgpO2Z1bmN0aW9uIHUoail7cmV0dXJuIGomJmouX19lc01vZHVsZT9qOntkZWZhdWx0Omp9fXZhciBhPSgwLFQuZGVmYXVsdCkoInRpbWluZyIpLGg9KDAsVC5kZWZhdWx0KSgia2V5ZnJhbWVzIiksYj0oMCxULmRlZmF1bHQpKCJpbml0U3RhdGUiKSxFPSgwLFQuZGVmYXVsdCkoInJlYWR5RGVmZXIiKSxBPSgwLFQuZGVmYXVsdCkoImZpbmlzaGVkRGVmZXIiKSxMPSgwLFQuZGVmYXVsdCkoImVmZmVjdHMiKSxTPSgwLFQuZGVmYXVsdCkoImFjdGl2ZVJlYWR5VGltZXIiKSxJPSgwLFQuZGVmYXVsdCkoImFjdGl2ZUZpbmlzaFRpbWVyIiksRD0oMCxULmRlZmF1bHQpKCJyZW1vdmVEZWZlciIpLFI9e2RlbGF5OjAsZW5kRGVsYXk6MCxmaWxsOiJhdXRvIixpdGVyYXRpb25zOjEscGxheWJhY2tSYXRlOjEsZGlyZWN0aW9uOiJub3JtYWwiLGVhc2luZzoibGluZWFyIixlZmZlY3Q6bnVsbH0sQz1mdW5jdGlvbigpe2Z1bmN0aW9uIGooJCxILEope3ZhciBxPXRoaXM7aWYoKDAseC5kZWZhdWx0KSh0aGlzLGopLEFycmF5LmlzQXJyYXkoJCkpe3ZhciBGPVskWzBdLCQsSF07JD1GWzBdLEg9RlsxXSxKPUZbMl19dHlwZW9mIEo9PSJudW1iZXIiJiYoSj17ZHVyYXRpb246Sn0pLHRoaXNbYV09KDAsby5kZWZhdWx0KSh7fSxSLEopLHRoaXNbYV0uZWFzaW5nPSgwLGkucGFyc2VFYXNpbmcpKHRoaXNbYV0uZWFzaW5nKSx0aGlzW2hdPSgwLFAuY2FsY3VsYXRlRnJhbWVzT2Zmc2V0KShIKTt2YXIgRz10aGlzW2hdW3RoaXNbaF0ubGVuZ3RoLTFdO3RoaXNbYl09e30sKDAsbC5kZWZhdWx0KShHKS5mb3JFYWNoKGZ1bmN0aW9uKFope09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgkLFopJiZaIT09ImVhc2luZyImJlohPT0ib2Zmc2V0IiYmKHFbYl1bWl09JFtaXSl9KSx0aGlzW2hdPXRoaXNbaF0ubWFwKGZ1bmN0aW9uKFope3JldHVybigwLG8uZGVmYXVsdCkoe30scVtiXSxaKX0pLHRoaXNbaF1bMF0ub2Zmc2V0IT09MCYmdGhpc1toXS51bnNoaWZ0KCgwLG8uZGVmYXVsdCkoe30sdGhpc1tiXSx7b2Zmc2V0OjB9KSksRy5vZmZzZXQ8MSYmdGhpc1toXS5wdXNoKCgwLG8uZGVmYXVsdCkoe30sRyx7b2Zmc2V0OjF9KSksdGhpc1tMXT17fSx0aGlzLnRpbWVsaW5lPW51bGx9cmV0dXJuKDAseS5kZWZhdWx0KShqLFt7a2V5OiJwYXVzZSIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT0wfX0se2tleTpTLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEg9dGhpczt0aGlzW0VdJiYhdGhpc1tFXS50aW1lcklEJiYodGhpcy50aW1lbGluZS5jdXJyZW50VGltZTwwP3RoaXNbRV0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIW0VdLnJlc29sdmUoKSxkZWxldGUgSFtFXX0se2RlbGF5Oi10aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lLGhlYWRpbmc6ITF9KTp0aGlzW0VdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SFtFXS5yZXNvbHZlKCksZGVsZXRlIEhbRV19LHtkZWxheTowLGlzRW50cm9weTohMH0pKX19LHtrZXk6SSx2YWx1ZTpmdW5jdGlvbigpe3ZhciBIPXRoaXMsSj10aGlzW2FdLHE9Si5kdXJhdGlvbixGPUouaXRlcmF0aW9ucyxHPUouZW5kRGVsYXksWj1NYXRoLmNlaWwocSpGK0ctdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSkrMTt0aGlzW0FdJiYhdGhpc1tBXS50aW1lcklEJiYodGhpc1tBXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbQV0ucmVzb2x2ZSgpLEhbRF0oRSksSFtEXShBKX0se2RlbGF5OlosaGVhZGluZzohMX0pLHRoaXNbQV0ucmV2ZXJzZVRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SFtBXS5yZXNvbHZlKCksSFtEXShFKSxIW0RdKEEpLEgudGltZWxpbmU9bnVsbH0se2RlbGF5Oi10aGlzW2FdLmRlbGF5LTEsaGVhZGluZzohMX0pKX19LHtrZXk6InBsYXkiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5wbGF5U3RhdGU9PT0iZmluaXNoZWQiJiZ0aGlzLmNhbmNlbCgpLHRoaXMucGxheVN0YXRlPT09ImlkbGUiKXtpZih0aGlzLnBsYXliYWNrUmF0ZTw9MClyZXR1cm47dmFyIEg9dGhpc1thXSxKPUguZGVsYXkscT1ILnBsYXliYWNrUmF0ZSxGPUgudGltZWxpbmU7dGhpcy50aW1lbGluZT1uZXcgdi5kZWZhdWx0KHtvcmlnaW5UaW1lOkoscGxheWJhY2tSYXRlOnF9LEYpLHRoaXNbU10oKSx0aGlzW0ldKCl9ZWxzZSB0aGlzLnBsYXlTdGF0ZT09PSJwYXVzZWQiJiYodGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9dGhpcy5wbGF5YmFja1JhdGUsdGhpc1tTXSgpKX19LHtrZXk6RCx2YWx1ZTpmdW5jdGlvbihIKXt2YXIgSj10aGlzW0hdLHE9dGhpcy50aW1lbGluZTtKJiZxJiYocS5jbGVhclRpbWVvdXQoSi50aW1lcklEKSxKLnJldmVyc2VUaW1lcklEJiZxLmNsZWFyVGltZW91dChKLnJldmVyc2VUaW1lcklEKSksZGVsZXRlIHRoaXNbSF19fSx7a2V5OiJjYW5jZWwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpc1tEXShFKSx0aGlzW0RdKEEpLHRoaXMudGltZWxpbmU9bnVsbH19LHtrZXk6ImZpbmlzaCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnRpbWVsaW5lJiYodGhpcy50aW1lbGluZS5jdXJyZW50VGltZT0xLzAvdGhpcy5wbGF5YmFja1JhdGUpLHRoaXNbRF0oRSksdGhpc1tEXShBKX19LHtrZXk6ImFwcGx5RWZmZWN0cyIsdmFsdWU6ZnVuY3Rpb24oSCl7cmV0dXJuKDAsby5kZWZhdWx0KSh0aGlzW0xdLEgpfX0se2tleToicGxheWJhY2tSYXRlIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1thXS5wbGF5YmFja1JhdGV9LHNldDpmdW5jdGlvbihIKXt0aGlzLnRpbWVsaW5lJiYodGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9SCksdGhpc1thXS5wbGF5YmFja1JhdGU9SH19LHtrZXk6InBsYXlTdGF0ZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEg9dGhpcy50aW1lbGluZSxKPXRoaXNbYV0scT1KLml0ZXJhdGlvbnMsRj1KLmR1cmF0aW9uLEc9Si5lbmREZWxheSxaPSJydW5uaW5nIjtpZihIPT1udWxsKVo9ImlkbGUiO2Vsc2UgaWYoSC5wYXVzZWQpWj0icGF1c2VkIjtlbHNlIGlmKEguY3VycmVudFRpbWU8MClaPSJwZW5kaW5nIjtlbHNle3ZhciB0dD1ILmN1cnJlbnRUaW1lLXEqRjt0dD4wJiZ0dDxHP1o9InBlbmRpbmciOnR0Pj1HJiYoWj0iZmluaXNoZWQiKX1yZXR1cm4gWn19LHtrZXk6InByb2dyZXNzIixnZXQ6ZnVuY3Rpb24oKXtpZighdGhpcy50aW1lbGluZSlyZXR1cm4gMDt2YXIgSD10aGlzW2FdLEo9SC5kdXJhdGlvbixxPUguaXRlcmF0aW9ucyxGPXRoaXMudGltZWxpbmUsRz10aGlzLnBsYXlTdGF0ZSxaPXZvaWQgMDtpZihHPT09ImlkbGUiKVo9MDtlbHNlIGlmKEc9PT0icGF1c2VkIiYmRi5jdXJyZW50VGltZTwwKVo9MDtlbHNlIGlmKEc9PT0icGVuZGluZyIpaWYoRi5jdXJyZW50VGltZTwwKVo9MDtlbHNle3ZhciB0dD1GLnNlZWtMb2NhbFRpbWUocSpKKTtaPSgwLFAucGVyaW9kaWNpdHkpKHR0LEopWzFdL0p9ZWxzZShHPT09InJ1bm5pbmcifHxHPT09InBhdXNlZCIpJiYoWj0oMCxQLnBlcmlvZGljaXR5KShGLmN1cnJlbnRUaW1lLEopWzFdL0opO3JldHVybiBHPT09ImZpbmlzaGVkIiYmKFo9KDAsUC5wZXJpb2RpY2l0eSkocSwxKVsxXSksWn19LHtrZXk6ImZyYW1lIixnZXQ6ZnVuY3Rpb24oKXt2YXIgSD10aGlzLnBsYXlTdGF0ZSxKPXRoaXNbYl0scT10aGlzW2FdLmZpbGw7aWYoSD09PSJpZGxlIilyZXR1cm4gSjt2YXIgRj10aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lLEc9dGhpc1toXS5zbGljZSgwKSxaPSgwLFAuZ2V0UHJvZ3Jlc3MpKHRoaXMudGltZWxpbmUsdGhpc1thXSx0aGlzLnByb2dyZXNzKSx0dD1aLnAsZXQ9Wi5pbnZlcnRlZCxpdD1KO3JldHVybiBGPDAmJkg9PT0icGVuZGluZyI/KHE9PT0iYmFja3dhcmRzInx8cT09PSJib3RoIikmJihpdD1ldD9HW0cubGVuZ3RoLTFdOkdbMF0pOihIIT09InBlbmRpbmciJiZIIT09ImZpbmlzaGVkInx8cT09PSJmb3J3YXJkcyJ8fHE9PT0iYm90aCIpJiYoaXQ9KDAsUC5nZXRDdXJyZW50RnJhbWUpKHRoaXNbYV0sRyx0aGlzW0xdLHR0KSksaXR9fSx7a2V5OiJ0aW1pbmciLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2FdfX0se2tleToiZWZmZWN0cyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbTF19fSx7a2V5OiJiYXNlVGltZWxpbmUiLHNldDpmdW5jdGlvbihIKXt0aGlzW2FdLnRpbWVsaW5lPUh9LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2FdLnRpbWVsaW5lfX0se2tleToicmVhZHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ucHJvbWlzZTp0aGlzLnRpbWVsaW5lJiZ0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPj0wJiZ0aGlzLnBsYXlTdGF0ZSE9PSJwYXVzZWQiP24uZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbRV09KDAsUC5kZWZlcikoKSx0aGlzLnRpbWVsaW5lJiZ0aGlzW1NdKCksdGhpc1tFXT90aGlzW0VdLnByb21pc2U6bi5kZWZhdWx0LnJlc29sdmUoKSl9fSx7a2V5OiJmaW5pc2hlZCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIj9uLmRlZmF1bHQucmVzb2x2ZSgpOih0aGlzW0FdfHwodGhpc1tBXT0oMCxQLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbSV0oKSksdGhpc1tBXS5wcm9taXNlKX19XSksan0oKTtlLmRlZmF1bHQ9Q30sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDE5MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTkzKSx0KDIwMiksdCgyMDMpLGQuZXhwb3J0cz10KDkyKS5Qcm9taXNlfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4OSksbj10KDkxKSxzPXQoOTMpLGw9dCgxMjgpLGM9dCg5MCksbz10KDk4KSxmPXQoOTQpLHg9dCgxNDcpLGc9dCgxNDgpLHk9dCgxOTQpLG09dCgxOTUpLnNldCxUPXQoMTk3KSgpLE89dCgxOTgpLHY9dCgxOTkpLFA9dCgyMDApLGk9dCgyMDEpLHU9IlByb21pc2UiLGE9bi5UeXBlRXJyb3IsaD1uLnByb2Nlc3MsYj1oJiZoLnZlcnNpb25zLEU9YiYmYi52OHx8IiIsQT1uW3VdLEw9bChoKT09InByb2Nlc3MiLFM9ZnVuY3Rpb24oKXt9LEksRCxSLEMsaj1EPU8uZiwkPSEhZnVuY3Rpb24oKXt0cnl7dmFyIGV0PUEucmVzb2x2ZSgxKSxpdD0oZXQuY29uc3RydWN0b3I9e30pW3QoMTIyKSgic3BlY2llcyIpXT1mdW5jdGlvbihrKXtrKFMsUyl9O3JldHVybihMfHx0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50PT0iZnVuY3Rpb24iKSYmZXQudGhlbihTKWluc3RhbmNlb2YgaXQmJkUuaW5kZXhPZigiNi42IikhPT0wJiZQLmluZGV4T2YoIkNocm9tZS82NiIpPT09LTF9Y2F0Y2h7fX0oKSxIPWZ1bmN0aW9uKGV0KXt2YXIgaXQ7cmV0dXJuIG8oZXQpJiZ0eXBlb2YoaXQ9ZXQudGhlbik9PSJmdW5jdGlvbiI/aXQ6ITF9LEo9ZnVuY3Rpb24oZXQsaXQpe2lmKCFldC5fbil7ZXQuX249ITA7dmFyIGs9ZXQuX2M7VChmdW5jdGlvbigpe2Zvcih2YXIgaHQ9ZXQuX3YsZnQ9ZXQuX3M9PTEsQj0wLFc9ZnVuY3Rpb24oVil7dmFyIFg9ZnQ/Vi5vazpWLmZhaWwsTj1WLnJlc29sdmUsej1WLnJlamVjdCxwPVYuZG9tYWluLE0sdyxVO3RyeXtYPyhmdHx8KGV0Ll9oPT0yJiZHKGV0KSxldC5faD0xKSxYPT09ITA/TT1odDoocCYmcC5lbnRlcigpLE09WChodCkscCYmKHAuZXhpdCgpLFU9ITApKSxNPT09Vi5wcm9taXNlP3ooYSgiUHJvbWlzZS1jaGFpbiBjeWNsZSIpKToodz1IKE0pKT93LmNhbGwoTSxOLHopOk4oTSkpOnooaHQpfWNhdGNoKEspe3AmJiFVJiZwLmV4aXQoKSx6KEspfX07ay5sZW5ndGg+QjspVyhrW0IrK10pO2V0Ll9jPVtdLGV0Ll9uPSExLGl0JiYhZXQuX2gmJnEoZXQpfSl9fSxxPWZ1bmN0aW9uKGV0KXttLmNhbGwobixmdW5jdGlvbigpe3ZhciBpdD1ldC5fdixrPUYoZXQpLGh0LGZ0LEI7aWYoayYmKGh0PXYoZnVuY3Rpb24oKXtMP2guZW1pdCgidW5oYW5kbGVkUmVqZWN0aW9uIixpdCxldCk6KGZ0PW4ub251bmhhbmRsZWRyZWplY3Rpb24pP2Z0KHtwcm9taXNlOmV0LHJlYXNvbjppdH0pOihCPW4uY29uc29sZSkmJkIuZXJyb3ImJkIuZXJyb3IoIlVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbiIsaXQpfSksZXQuX2g9THx8RihldCk/MjoxKSxldC5fYT12b2lkIDAsayYmaHQuZSl0aHJvdyBodC52fSl9LEY9ZnVuY3Rpb24oZXQpe3JldHVybiBldC5faCE9PTEmJihldC5fYXx8ZXQuX2MpLmxlbmd0aD09PTB9LEc9ZnVuY3Rpb24oZXQpe20uY2FsbChuLGZ1bmN0aW9uKCl7dmFyIGl0O0w/aC5lbWl0KCJyZWplY3Rpb25IYW5kbGVkIixldCk6KGl0PW4ub25yZWplY3Rpb25oYW5kbGVkKSYmaXQoe3Byb21pc2U6ZXQscmVhc29uOmV0Ll92fSl9KX0sWj1mdW5jdGlvbihldCl7dmFyIGl0PXRoaXM7aXQuX2R8fChpdC5fZD0hMCxpdD1pdC5fd3x8aXQsaXQuX3Y9ZXQsaXQuX3M9MixpdC5fYXx8KGl0Ll9hPWl0Ll9jLnNsaWNlKCkpLEooaXQsITApKX0sdHQ9ZnVuY3Rpb24oZXQpe3ZhciBpdD10aGlzLGs7aWYoIWl0Ll9kKXtpdC5fZD0hMCxpdD1pdC5fd3x8aXQ7dHJ5e2lmKGl0PT09ZXQpdGhyb3cgYSgiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGYiKTsoaz1IKGV0KSk/VChmdW5jdGlvbigpe3ZhciBodD17X3c6aXQsX2Q6ITF9O3RyeXtrLmNhbGwoZXQscyh0dCxodCwxKSxzKFosaHQsMSkpfWNhdGNoKGZ0KXtaLmNhbGwoaHQsZnQpfX0pOihpdC5fdj1ldCxpdC5fcz0xLEooaXQsITEpKX1jYXRjaChodCl7Wi5jYWxsKHtfdzppdCxfZDohMX0saHQpfX19OyR8fChBPWZ1bmN0aW9uKGl0KXt4KHRoaXMsQSx1LCJfaCIpLGYoaXQpLEkuY2FsbCh0aGlzKTt0cnl7aXQocyh0dCx0aGlzLDEpLHMoWix0aGlzLDEpKX1jYXRjaChrKXtaLmNhbGwodGhpcyxrKX19LEk9ZnVuY3Rpb24oaXQpe3RoaXMuX2M9W10sdGhpcy5fYT12b2lkIDAsdGhpcy5fcz0wLHRoaXMuX2Q9ITEsdGhpcy5fdj12b2lkIDAsdGhpcy5faD0wLHRoaXMuX249ITF9LEkucHJvdG90eXBlPXQoMTQ2KShBLnByb3RvdHlwZSx7dGhlbjpmdW5jdGlvbihpdCxrKXt2YXIgaHQ9aih5KHRoaXMsQSkpO3JldHVybiBodC5vaz10eXBlb2YgaXQ9PSJmdW5jdGlvbiI/aXQ6ITAsaHQuZmFpbD10eXBlb2Ygaz09ImZ1bmN0aW9uIiYmayxodC5kb21haW49TD9oLmRvbWFpbjp2b2lkIDAsdGhpcy5fYy5wdXNoKGh0KSx0aGlzLl9hJiZ0aGlzLl9hLnB1c2goaHQpLHRoaXMuX3MmJkoodGhpcywhMSksaHQucHJvbWlzZX0sY2F0Y2g6ZnVuY3Rpb24oZXQpe3JldHVybiB0aGlzLnRoZW4odm9pZCAwLGV0KX19KSxSPWZ1bmN0aW9uKCl7dmFyIGV0PW5ldyBJO3RoaXMucHJvbWlzZT1ldCx0aGlzLnJlc29sdmU9cyh0dCxldCwxKSx0aGlzLnJlamVjdD1zKFosZXQsMSl9LE8uZj1qPWZ1bmN0aW9uKGV0KXtyZXR1cm4gZXQ9PT1BfHxldD09PUM/bmV3IFIoZXQpOkQoZXQpfSksYyhjLkcrYy5XK2MuRiohJCx7UHJvbWlzZTpBfSksdCgxMjEpKEEsdSksdCgxNDkpKHUpLEM9dCg5MilbdV0sYyhjLlMrYy5GKiEkLHUse3JlamVjdDpmdW5jdGlvbihpdCl7dmFyIGs9aih0aGlzKSxodD1rLnJlamVjdDtyZXR1cm4gaHQoaXQpLGsucHJvbWlzZX19KSxjKGMuUytjLkYqKHJ8fCEkKSx1LHtyZXNvbHZlOmZ1bmN0aW9uKGl0KXtyZXR1cm4gaShyJiZ0aGlzPT09Qz9BOnRoaXMsaXQpfX0pLGMoYy5TK2MuRiohKCQmJnQoMTQwKShmdW5jdGlvbihldCl7QS5hbGwoZXQpLmNhdGNoKFMpfSkpLHUse2FsbDpmdW5jdGlvbihpdCl7dmFyIGs9dGhpcyxodD1qKGspLGZ0PWh0LnJlc29sdmUsQj1odC5yZWplY3QsVz12KGZ1bmN0aW9uKCl7dmFyIFY9W10sWD0wLE49MTtnKGl0LCExLGZ1bmN0aW9uKHope3ZhciBwPVgrKyxNPSExO1YucHVzaCh2b2lkIDApLE4rKyxrLnJlc29sdmUoeikudGhlbihmdW5jdGlvbih3KXtNfHwoTT0hMCxWW3BdPXcsLS1OfHxmdChWKSl9LEIpfSksLS1OfHxmdChWKX0pO3JldHVybiBXLmUmJkIoVy52KSxodC5wcm9taXNlfSxyYWNlOmZ1bmN0aW9uKGl0KXt2YXIgaz10aGlzLGh0PWooayksZnQ9aHQucmVqZWN0LEI9dihmdW5jdGlvbigpe2coaXQsITEsZnVuY3Rpb24oVyl7ay5yZXNvbHZlKFcpLnRoZW4oaHQucmVzb2x2ZSxmdCl9KX0pO3JldHVybiBCLmUmJmZ0KEIudiksaHQucHJvbWlzZX19KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTcpLG49dCg5NCkscz10KDEyMikoInNwZWNpZXMiKTtkLmV4cG9ydHM9ZnVuY3Rpb24obCxjKXt2YXIgbz1yKGwpLmNvbnN0cnVjdG9yLGY7cmV0dXJuIG89PT12b2lkIDB8fChmPXIobylbc10pPT1udWxsP2M6bihmKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkzKSxuPXQoMTk2KSxzPXQoMTIwKSxsPXQoMTAyKSxjPXQoOTEpLG89Yy5wcm9jZXNzLGY9Yy5zZXRJbW1lZGlhdGUseD1jLmNsZWFySW1tZWRpYXRlLGc9Yy5NZXNzYWdlQ2hhbm5lbCx5PWMuRGlzcGF0Y2gsbT0wLFQ9e30sTz0ib25yZWFkeXN0YXRlY2hhbmdlIix2LFAsaSx1PWZ1bmN0aW9uKCl7dmFyIGg9K3RoaXM7aWYoVC5oYXNPd25Qcm9wZXJ0eShoKSl7dmFyIGI9VFtoXTtkZWxldGUgVFtoXSxiKCl9fSxhPWZ1bmN0aW9uKGgpe3UuY2FsbChoLmRhdGEpfTsoIWZ8fCF4KSYmKGY9ZnVuY3Rpb24oYil7Zm9yKHZhciBFPVtdLEE9MTthcmd1bWVudHMubGVuZ3RoPkE7KUUucHVzaChhcmd1bWVudHNbQSsrXSk7cmV0dXJuIFRbKyttXT1mdW5jdGlvbigpe24odHlwZW9mIGI9PSJmdW5jdGlvbiI/YjpGdW5jdGlvbihiKSxFKX0sdihtKSxtfSx4PWZ1bmN0aW9uKGIpe2RlbGV0ZSBUW2JdfSx0KDg2KShvKT09InByb2Nlc3MiP3Y9ZnVuY3Rpb24oaCl7by5uZXh0VGljayhyKHUsaCwxKSl9OnkmJnkubm93P3Y9ZnVuY3Rpb24oaCl7eS5ub3cocih1LGgsMSkpfTpnPyhQPW5ldyBnLGk9UC5wb3J0MixQLnBvcnQxLm9ubWVzc2FnZT1hLHY9cihpLnBvc3RNZXNzYWdlLGksMSkpOmMuYWRkRXZlbnRMaXN0ZW5lciYmdHlwZW9mIHBvc3RNZXNzYWdlPT0iZnVuY3Rpb24iJiYhYy5pbXBvcnRTY3JpcHRzPyh2PWZ1bmN0aW9uKGgpe2MucG9zdE1lc3NhZ2UoaCsiIiwiKiIpfSxjLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGEsITEpKTpPIGluIGwoInNjcmlwdCIpP3Y9ZnVuY3Rpb24oaCl7cy5hcHBlbmRDaGlsZChsKCJzY3JpcHQiKSlbT109ZnVuY3Rpb24oKXtzLnJlbW92ZUNoaWxkKHRoaXMpLHUuY2FsbChoKX19OnY9ZnVuY3Rpb24oaCl7c2V0VGltZW91dChyKHUsaCwxKSwwKX0pLGQuZXhwb3J0cz17c2V0OmYsY2xlYXI6eH19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQscixuKXt2YXIgcz1uPT09dm9pZCAwO3N3aXRjaChyLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBzP3QoKTp0LmNhbGwobik7Y2FzZSAxOnJldHVybiBzP3QoclswXSk6dC5jYWxsKG4sclswXSk7Y2FzZSAyOnJldHVybiBzP3QoclswXSxyWzFdKTp0LmNhbGwobixyWzBdLHJbMV0pO2Nhc2UgMzpyZXR1cm4gcz90KHJbMF0sclsxXSxyWzJdKTp0LmNhbGwobixyWzBdLHJbMV0sclsyXSk7Y2FzZSA0OnJldHVybiBzP3QoclswXSxyWzFdLHJbMl0sclszXSk6dC5jYWxsKG4sclswXSxyWzFdLHJbMl0sclszXSl9cmV0dXJuIHQuYXBwbHkobixyKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkxKSxuPXQoMTk1KS5zZXQscz1yLk11dGF0aW9uT2JzZXJ2ZXJ8fHIuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixsPXIucHJvY2VzcyxjPXIuUHJvbWlzZSxvPXQoODYpKGwpPT0icHJvY2VzcyI7ZC5leHBvcnRzPWZ1bmN0aW9uKCl7dmFyIGYseCxnLHk9ZnVuY3Rpb24oKXt2YXIgdixQO2ZvcihvJiYodj1sLmRvbWFpbikmJnYuZXhpdCgpO2Y7KXtQPWYuZm4sZj1mLm5leHQ7dHJ5e1AoKX1jYXRjaChpKXt0aHJvdyBmP2coKTp4PXZvaWQgMCxpfX14PXZvaWQgMCx2JiZ2LmVudGVyKCl9O2lmKG8pZz1mdW5jdGlvbigpe2wubmV4dFRpY2soeSl9O2Vsc2UgaWYocyYmIShyLm5hdmlnYXRvciYmci5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpe3ZhciBtPSEwLFQ9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIiIpO25ldyBzKHkpLm9ic2VydmUoVCx7Y2hhcmFjdGVyRGF0YTohMH0pLGc9ZnVuY3Rpb24oKXtULmRhdGE9bT0hbX19ZWxzZSBpZihjJiZjLnJlc29sdmUpe3ZhciBPPWMucmVzb2x2ZSh2b2lkIDApO2c9ZnVuY3Rpb24oKXtPLnRoZW4oeSl9fWVsc2UgZz1mdW5jdGlvbigpe24uY2FsbChyLHkpfTtyZXR1cm4gZnVuY3Rpb24odil7dmFyIFA9e2ZuOnYsbmV4dDp2b2lkIDB9O3gmJih4Lm5leHQ9UCksZnx8KGY9UCxnKCkpLHg9UH19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5NCk7ZnVuY3Rpb24gbihzKXt2YXIgbCxjO3RoaXMucHJvbWlzZT1uZXcgcyhmdW5jdGlvbihvLGYpe2lmKGwhPT12b2lkIDB8fGMhPT12b2lkIDApdGhyb3cgVHlwZUVycm9yKCJCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvciIpO2w9byxjPWZ9KSx0aGlzLnJlc29sdmU9cihsKSx0aGlzLnJlamVjdD1yKGMpfWQuZXhwb3J0cy5mPWZ1bmN0aW9uKHMpe3JldHVybiBuZXcgbihzKX19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm57ZTohMSx2OnQoKX19Y2F0Y2gocil7cmV0dXJue2U6ITAsdjpyfX19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5MSksbj1yLm5hdmlnYXRvcjtkLmV4cG9ydHM9biYmbi51c2VyQWdlbnR8fCIifSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5Nyksbj10KDk4KSxzPXQoMTk4KTtkLmV4cG9ydHM9ZnVuY3Rpb24obCxjKXtpZihyKGwpLG4oYykmJmMuY29uc3RydWN0b3I9PT1sKXJldHVybiBjO3ZhciBvPXMuZihsKSxmPW8ucmVzb2x2ZTtyZXR1cm4gZihjKSxvLnByb21pc2V9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5MCksbj10KDkyKSxzPXQoOTEpLGw9dCgxOTQpLGM9dCgyMDEpO3Ioci5QK3IuUiwiUHJvbWlzZSIse2ZpbmFsbHk6ZnVuY3Rpb24obyl7dmFyIGY9bCh0aGlzLG4uUHJvbWlzZXx8cy5Qcm9taXNlKSx4PXR5cGVvZiBvPT0iZnVuY3Rpb24iO3JldHVybiB0aGlzLnRoZW4oeD9mdW5jdGlvbihnKXtyZXR1cm4gYyhmLG8oKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBnfSl9Om8seD9mdW5jdGlvbihnKXtyZXR1cm4gYyhmLG8oKSkudGhlbihmdW5jdGlvbigpe3Rocm93IGd9KX06byl9fSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKSxuPXQoMTk4KSxzPXQoMTk5KTtyKHIuUywiUHJvbWlzZSIse3RyeTpmdW5jdGlvbihsKXt2YXIgYz1uLmYodGhpcyksbz1zKGwpO3JldHVybihvLmU/Yy5yZWplY3Q6Yy5yZXNvbHZlKShvLnYpLGMucHJvbWlzZX19KX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDIwNSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDIwNiksZC5leHBvcnRzPXQoOTIpLk9iamVjdC5rZXlzfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMjQpLG49dCgxMTApO3QoMjA3KSgia2V5cyIsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24obCl7cmV0dXJuIG4ocihsKSl9fSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKSxuPXQoOTIpLHM9dCgxMDEpO2QuZXhwb3J0cz1mdW5jdGlvbihsLGMpe3ZhciBvPShuLk9iamVjdHx8e30pW2xdfHxPYmplY3RbbF0sZj17fTtmW2xdPWMobykscihyLlMrci5GKnMoZnVuY3Rpb24oKXtvKDEpfSksIk9iamVjdCIsZil9fSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXQoNzYpLG49VChyKSxzPXQoMjA5KSxsPVQocyksYz10KDE2NCksbz1UKGMpLGY9dCgxOTEpLHg9VChmKTtlLmRlZmVyPU8sZS5wZXJpb2RpY2l0eT12LGUuY2FsY3VsYXRlRnJhbWVzT2Zmc2V0PVAsZS5nZXRQcm9ncmVzcz1pLGUuZ2V0Q3VycmVudEZyYW1lPWE7dmFyIGc9dCgxODgpLHk9dCgxODcpLG09VCh5KTtmdW5jdGlvbiBUKGgpe3JldHVybiBoJiZoLl9fZXNNb2R1bGU/aDp7ZGVmYXVsdDpofX1mdW5jdGlvbiBPKCl7dmFyIGg9e307cmV0dXJuIGgucHJvbWlzZT1uZXcgeC5kZWZhdWx0KGZ1bmN0aW9uKGIsRSl7aC5yZXNvbHZlPWIsaC5yZWplY3Q9RX0pLGh9ZnVuY3Rpb24gdihoLGIpe3ZhciBFPU1hdGguZmxvb3IoaC9iKSxBPWgtRSpiO3JldHVybiBBPT09MCYmRT4wJiYoQT1iLEUtLSksW0UsQV19ZnVuY3Rpb24gUChoKXtoPWguc2xpY2UoMCk7dmFyIGI9aFswXSxFPWhbaC5sZW5ndGgtMV07RS5vZmZzZXQ9RS5vZmZzZXR8fDEsYi5vZmZzZXQ9Yi5vZmZzZXR8fDA7Zm9yKHZhciBBPTAsTD0tMSxTPTA7UzxoLmxlbmd0aDtTKyspe3ZhciBJPWhbU107aWYoSS5vZmZzZXQhPW51bGwpe3ZhciBEPVMtTDtpZihEPjEpZm9yKHZhciBSPShJLm9mZnNldC1BKS9ELEM9MDtDPEQtMTtDKyspaFtMK0MrMV0ub2Zmc2V0PUErUiooQysxKTtBPUkub2Zmc2V0LEw9U31pZihJLmVhc2luZyE9bnVsbCYmKEkuZWFzaW5nPSgwLGcucGFyc2VFYXNpbmcpKEkuZWFzaW5nKSksUz4wKXt2YXIgaj1oW1NdLmVhc2luZyE9bnVsbDtoW1NdPSgwLG8uZGVmYXVsdCkoe30saFtTLTFdLGhbU10pLGp8fGRlbGV0ZSBoW1NdLmVhc2luZ319cmV0dXJuIGh9ZnVuY3Rpb24gaShoLGIsRSl7dmFyIEE9aC5jdXJyZW50VGltZSxMPWIuZGlyZWN0aW9uLFM9Yi5kdXJhdGlvbixJPSExO2lmKEw9PT0icmV2ZXJzZSIpRT0xLUUsST0hMDtlbHNlIGlmKEw9PT0iYWx0ZXJuYXRlInx8TD09PSJhbHRlcm5hdGUtcmV2ZXJzZSIpe3ZhciBEPU1hdGguZmxvb3IoQS9TKTtFPT09MSYmRC0tLEQlMl5MPT09ImFsdGVybmF0ZS1yZXZlcnNlIiYmKEU9MS1FLEk9ITApfXJldHVybntwOkUsaW52ZXJ0ZWQ6SX19ZnVuY3Rpb24gdShoLGIsRSxBKXt2YXIgTD17fTtyZXR1cm4oMCxsLmRlZmF1bHQpKGIpLmZvckVhY2goZnVuY3Rpb24oUyl7dmFyIEk9KDAsbi5kZWZhdWx0KShTLDIpLEQ9SVswXSxSPUlbMV07aWYoRCE9PSJvZmZzZXQiJiZEIT09ImVhc2luZyIpe3ZhciBDPUVbRF18fEUuZGVmYXVsdCxqPUMoaFtEXSxSLEEsaC5vZmZzZXQsYi5vZmZzZXQpO2ohPW51bGwmJihMW0RdPWopfX0pLEx9ZnVuY3Rpb24gYShoLGIsRSxBKXt2YXIgTD1oLmVhc2luZyxTPWguZWZmZWN0O1N8fChFPSgwLG8uZGVmYXVsdCkoe30sbS5kZWZhdWx0LEUpKTt2YXIgST17fTtBPUwoQSxiKTtmb3IodmFyIEQ9MTtEPGIubGVuZ3RoO0QrKyl7dmFyIFI9YltEXSxDPVIub2Zmc2V0O2lmKEM+PUF8fEQ9PT1iLmxlbmd0aC0xKXt2YXIgaj1iW0QtMV0sJD1qLm9mZnNldCxIPWouZWFzaW5nLEo9QTtpZihIKXt2YXIgcT1DLSQ7Sj1IKChBLSQpL3EpKnErJH1TP0k9UyhqLFIsSiwkLEMpOkk9dShqLFIsRSxKKTticmVha319cmV0dXJuIEl9fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXtkZWZhdWx0OnQoMjEwKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oZCxlLHQpe3QoMjExKSxkLmV4cG9ydHM9dCg5MikuT2JqZWN0LmVudHJpZXN9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKSxuPXQoMjEyKSghMCk7cihyLlMsIk9iamVjdCIse2VudHJpZXM6ZnVuY3Rpb24obCl7cmV0dXJuIG4obCl9fSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDEwMCksbj10KDExMCkscz10KDg0KSxsPXQoMTY5KS5mO2QuZXhwb3J0cz1mdW5jdGlvbihjKXtyZXR1cm4gZnVuY3Rpb24obyl7Zm9yKHZhciBmPXMobykseD1uKGYpLGc9eC5sZW5ndGgseT0wLG09W10sVDtnPnk7KVQ9eFt5KytdLCghcnx8bC5jYWxsKGYsVCkpJiZtLnB1c2goYz9bVCxmW1RdXTpmW1RdKTtyZXR1cm4gbX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPW5ldyBNYXA7ZnVuY3Rpb24gbihsLGM9e30sbz1bXSl7bD1sLnRvTG93ZXJDYXNlKCk7Y29uc3QgZj1yLmdldChsKTtpZighZil0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG5vZGU6ICR7bH1gKTtjb25zdCB4PW5ldyBmKGMpO3JldHVybiBvLmZvckVhY2goZz0+e3guYXBwZW5kQ2hpbGQoZyl9KSx4fWNvbnN0IHM9e3JlZ2lzdGVyTm9kZShsLGMsbz0xMDApe2lmKGM9Yy50b0xvd2VyQ2FzZSgpLHIuaGFzKGMpKXRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCByZWdpc3Rlck5vZGUsICR7Y30gaGFzIGJlZW4gdGFrZW4uYCk7ci5zZXQoYyxsKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsLnByb3RvdHlwZSx7bm9kZVR5cGU6e3ZhbHVlOm99LHRhZ05hbWU6e3ZhbHVlOmMudG9VcHBlckNhc2UoKX0sbm9kZU5hbWU6e3ZhbHVlOmN9LG93bmVyRG9jdW1lbnQ6e3ZhbHVlOnN9LG5hbWVzcGFjZVVSSTp7dmFsdWU6YGh0dHA6Ly9zcHJpdGVqcy5jb20vJHtjfWB9fSl9LGNyZWF0ZUVsZW1lbnQ6bixjcmVhdGVFbGVtZW50TlMobCxjKXtyZXR1cm4gbihjKX0saXNTcHJpdGVOb2RlKGwpe3JldHVybiByLmhhcyhsLnRvTG93ZXJDYXNlKCkpfX07ZS5kZWZhdWx0PXN9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcj1TeW1ib2woInR5cGUiKSxuPVN5bWJvbCgiYnViYmxlcyIpLHM9U3ltYm9sKCJvcmlnaW5hbEV2ZW50IiksbD1TeW1ib2woImRldGFpbCIpO2NsYXNzIGN7Y29uc3RydWN0b3IoZix7YnViYmxlczp4PW51bGx9PXt9KXtpZih0eXBlb2YgZj09InN0cmluZyI/KHRoaXNbcl09Zix0aGlzW25dPSEheCk6KHRoaXNbcl09Zi50eXBlLHRoaXNbc109Zix0aGlzW25dPXghPW51bGw/ISF4OiEhZi5idWJibGVzLGYuZGV0YWlsJiYodGhpc1tsXT1mLmRldGFpbCkpLCF0aGlzW3JdKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZXZlbnQgdHlwZS4iKTt0aGlzLmNhbmNlbEJ1YmJsZT0hMX1zZXRPcmlnaW5hbEV2ZW50KGYpe3RoaXNbc109Zn1nZXQgb3JpZ2luYWxFdmVudCgpe3JldHVybiB0aGlzW3NdfWdldCB0eXBlKCl7cmV0dXJuIHRoaXNbcl19Z2V0IGJ1YmJsZXMoKXtyZXR1cm4gdGhpc1tuXX1nZXQgZGV0YWlsKCl7cmV0dXJuIHRoaXNbbF19c3RvcFByb3BhZ2F0aW9uKCl7dGhpcy5jYW5jZWxCdWJibGU9ITB9fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwicGFyc2VGaWx0ZXJTdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiYXBwbHlGaWx0ZXJzIixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIHI9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4obCl7aWYobD1sLnRyaW0oKSwhbHx8bD09PSJub25lIilyZXR1cm4gbnVsbDtjb25zdCBjPS9eKD86KHVybHxibHVyfGJyaWdodG5lc3N8Y29udHJhc3R8ZHJvcC1zaGFkb3d8Z3JheXNjYWxlfGh1ZS1yb3RhdGV8aW52ZXJ0fG9wYWNpdHl8c2F0dXJhdGV8c2VwaWEpXCgoW14oKV0qKD86XCguKlwpKSpbXigpXSopXCkpKyQvaSxvPWwubWF0Y2goLyg/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSs/L2lnKSxmPVtdO3JldHVybiBvJiZvLmZvckVhY2goeD0+e2NvbnN0IGc9eC5tYXRjaChjKTtpZighZyl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGZpdGxlciBzdHJpbmcuIik7bGV0Wyx5LG1dPWc7eT15LnRvTG93ZXJDYXNlKCksbT1tLnRyaW0oKS5tYXRjaCgvKFteKCApXSt8KFteKCApXStcKC4qXCkpKSg/PVxzfCQpL2cpLm1hcCgoVCxPKT0+e2xldCB2O3JldHVybiB5PT09InVybCJ8fHk9PT0iZHJvcC1zaGFkb3ciJiZPPT09Mz92PVQ6dj1PYmplY3Qoci50b051bWJlcikoVCksLyUkLy50ZXN0KFQpJiYodi89MTAwKSx2fSksZi5wdXNoKHt0eXBlOnksYXJnczptfSl9KSxmfWZ1bmN0aW9uIHMobCxjKXtsLmNsZWFyRmlsdGVyKCksYyYmYy5mb3JFYWNoKCh7dHlwZTpvLGFyZ3M6Zn0pPT57bGV0IHg9bzt4PT09ImRyb3Atc2hhZG93Ij94PSJkcm9wU2hhZG93Ijp4PT09Imh1ZS1yb3RhdGUiJiYoeD0iaHVlUm90YXRlIiksbFt4XSguLi5mKX0pfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG4scyl7aWYoIXMpcmV0dXJuO2NvbnN0IGw9bi5nZXRMaXN0ZW5lcnMoImJlZm9yZXJlbmRlciIpLGM9bi5nZXRMaXN0ZW5lcnMoImFmdGVycmVuZGVyIik7bC5sZW5ndGgmJiFzLmJlZm9yZVJlbmRlcj9zLmJlZm9yZVJlbmRlcj1vPT57bi5kaXNwYXRjaEV2ZW50KHt0eXBlOiJiZWZvcmVyZW5kZXIiLGRldGFpbDp7Y29udGV4dDpvfX0pfTpsLmxlbmd0aHx8KHMuYmVmb3JlUmVuZGVyPW51bGwpLGMubGVuZ3RoJiYhcy5hZnRlclJlbmRlcj9zLmFmdGVyUmVuZGVyPW89PntuLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImFmdGVycmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6b319KX06Yy5sZW5ndGh8fChzLmFmdGVyUmVuZGVyPW51bGwpfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMTIpLG49dCgyMTgpLHM9dCg3MCksbD10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9U3ltYm9sKCJhbW91bnQiKSxvPVN5bWJvbCgibWVzaENsb3VkIik7Y2xhc3MgZiBleHRlbmRzIHMuZGVmYXVsdHtjb25zdHJ1Y3RvcihnLHk9MSl7c3VwZXIoKSx0aGlzLm1lc2hOb2RlPWcsZy5jb25uZWN0KHRoaXMpLHRoaXNbY109eSx0aGlzW29dPW51bGx9Z2V0IG1lc2hDbG91ZCgpe2NvbnN0IGc9dGhpcy5tZXNoTm9kZSx5PXRoaXNbY107cmV0dXJuIXRoaXNbb10mJmcubWVzaCYmKHRoaXNbb109bmV3IHIuTWVzaENsb3VkKGcubWVzaCx5KSksdGhpc1tvXX1nZXQgaXNWaXNpYmxlKCl7cmV0dXJuISF0aGlzLm1lc2hOb2RlJiZ0aGlzLm1lc2hOb2RlLmlzVmlzaWJsZX1nZXQgYW1vdW50KCl7cmV0dXJuIHRoaXNbY119c2V0IGFtb3VudChnKXt0aGlzW2NdPWcsdGhpc1tvXSYmKHRoaXNbb10uYW1vdW50PWcpfWJyaWdodG5lc3MoZyx5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmJyaWdodG5lc3MoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWNvbnRyYXN0KGcseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5jb250cmFzdChnLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9ZGVsZXRlKGcpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuZGVsZXRlKGcpLHRoaXNbY10tLSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRyYXcoZz1bXSl7aWYoc3VwZXIuZHJhdyhnKSx0aGlzLm1lc2hDbG91ZCl7aWYodGhpcy5wcm9ncmFtKXt0aGlzLm1lc2hDbG91ZC5zZXRQcm9ncmFtKHRoaXMucHJvZ3JhbSk7Y29uc3QgeT10aGlzLnNoYWRlckF0dHJzO3kmJk9iamVjdC5lbnRyaWVzKHkpLmZvckVhY2goKFtULE9dKT0+e3RoaXMubWVzaENsb3VkLm1lc2guc2V0QXR0cmlidXRlKFQsTyl9KTtjb25zdCBtPXRoaXMudW5pZm9ybXM7aWYodGhpcy51bmlmb3Jtcyl7Y29uc3QgVD17fTtPYmplY3QuZW50cmllcyhtKS5mb3JFYWNoKChbTyx2XSk9Pnt0eXBlb2Ygdj09ImZ1bmN0aW9uIiYmKHY9dih0aGlzLE8pKSxUW09dPXZ9KSx0aGlzLm1lc2hDbG91ZC5tZXNoLnNldFVuaWZvcm1zKFQpfX10aGlzLm1lc2hOb2RlLnRleHR1cmVJbWFnZSYmT2JqZWN0KG4uZHJhd1RleHR1cmUpKHRoaXMubWVzaE5vZGUsdGhpcy5tZXNoTm9kZS5tZXNoKSxnLnB1c2godGhpcy5tZXNoQ2xvdWQpfXJldHVybiBnfWdldFRyYW5zZm9ybShnKXtpZih0aGlzLm1lc2hDbG91ZClyZXR1cm4gdGhpcy5tZXNoQ2xvdWQuZ2V0VHJhbnNmb3JtKGcpfWdyYXlzY2FsZShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuZ3JheXNjYWxlKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1odWVSb3RhdGUoZyx5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmh1ZVJvdGF0ZShnLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9aW52ZXJ0KGcseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5pbnZlcnQoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWlzUG9pbnRDb2xsaXNpb24oZyx5KXtpZighdGhpcy5tZXNoQ2xvdWQpcmV0dXJuITE7Y29uc3QgbT10aGlzLmF0dHJpYnV0ZXMucG9pbnRlckV2ZW50cztpZihtPT09Im5vbmUifHxtIT09ImFsbCImJiF0aGlzLmlzVmlzaWJsZSlyZXR1cm4hMTtsZXQgVD0iYm90aCI7bT09PSJ2aXNpYmxlRmlsbCImJihUPSJmaWxsIiksbT09PSJ2aXNpYmxlU3Ryb2tlIiYmKFQ9InN0cm9rZSIpO2ZvcihsZXQgTz0wO088dGhpc1tjXTtPKyspaWYoIXRoaXMubWVzaENsb3VkLmlzUG9pbnRDb2xsaXNpb24oTyxbZyx5XSxUKSlyZXR1cm4hMTtyZXR1cm4hMH1zZXRPcGFjaXR5KGcseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5vcGFjaXR5KGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1yb3RhdGUoZyx5LFttLFRdPVswLDBdKXtjb25zdCBPPU1hdGguUEkqeS8xODA7aWYodGhpcy5tZXNoQ2xvdWQpe2NvbnN0e3g6dix5OlB9PXRoaXMubWVzaE5vZGUuYXR0cmlidXRlczt0aGlzLm1lc2hDbG91ZC5yb3RhdGUoZyxPLFttK3YsVCtQXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX1zYXR1cmF0ZShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2F0dXJhdGUoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNjYWxlKGcsW3ksbT15XSxbVCxPXT1bMCwwXSl7aWYodGhpcy5tZXNoQ2xvdWQpe2NvbnN0e3g6dix5OlB9PXRoaXMubWVzaE5vZGUuYXR0cmlidXRlcyxpPTFlLTU7TWF0aC5hYnMoeSk8aSYmKHk9MS95PjA/aTotaSksTWF0aC5hYnMobSk8aSYmKG09MS9tPjA/aTotaSksdGhpcy5tZXNoQ2xvdWQuc2NhbGUoZyxbeSxtXSxbVCt2LE8rUF0pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2V0Q29sb3JUcmFuc2Zvcm0oZyx5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldENvbG9yVHJhbnNmb3JtKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRGaWxsQ29sb3IoZyx5KXt0aGlzLm1lc2hDbG91ZCYmKEFycmF5LmlzQXJyYXkoeSkmJih5PVsuLi55XSx5WzBdLz0yNTUseVsxXS89MjU1LHlbMl0vPTI1NSksdGhpcy5tZXNoQ2xvdWQuc2V0RmlsbENvbG9yKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXBpYShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2VwaWEoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNldFJlc29sdXRpb24oe3dpZHRoOmcsaGVpZ2h0Onl9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpnLGhlaWdodDp5fSksdGhpcy5tZXNoTm9kZS5zZXRSZXNvbHV0aW9uKHt3aWR0aDpnLGhlaWdodDp5fSl9c2V0U3Ryb2tlQ29sb3IoZyx5KXt0aGlzLm1lc2hDbG91ZCYmKEFycmF5LmlzQXJyYXkoeSkmJih5PVsuLi55XSx5WzBdLz0yNTUseVsxXS89MjU1LHlbMl0vPTI1NSksdGhpcy5tZXNoQ2xvdWQuc2V0U3Ryb2tlQ29sb3IoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNldFRyYW5zZm9ybShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2V0VHJhbnNmb3JtKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1za2V3KGcsW3ksbT15XSxbVCxPXT1bMCwwXSl7aWYodGhpcy5tZXNoQ2xvdWQpe2NvbnN0e3g6dix5OlB9PXRoaXMubWVzaE5vZGUuYXR0cmlidXRlczt0aGlzLm1lc2hDbG91ZC5za2V3KGcsW3ksbV0sW1QrdixPK1BdKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXRyYW5zZm9ybShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQudHJhbnNmb3JtKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2Zvcm1Db2xvcihnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQudHJhbnNmb3JtQ29sb3IoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRyYW5zbGF0ZShnLFt5LG1dKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zbGF0ZShnLFt5LG1dKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXVwZGF0ZU1lc2goKXt0aGlzW29dJiYodGhpc1tvXS5tZXNoPXRoaXMubWVzaE5vZGUubWVzaCx0aGlzLmZvcmNlVXBkYXRlKCkpfX1sLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGYsImNsb3VkIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImxvYWRUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImFwcGx5VGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJjcmVhdGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImRlbGV0ZVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZHJhd1RleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwibG9hZEZyYW1lcyIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pO3ZhciByPXQoMTIpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9e307ZnVuY3Rpb24gbChULE8pe2lmKHNbVF0pcmV0dXJuIHNbVF07Y29uc3Qgdj1yLkVOVi5sb2FkSW1hZ2UoVCx7YWxpYXM6Tyx1c2VJbWFnZUJpdG1hcDohMX0pO3JldHVybiB2Pz9UfWFzeW5jIGZ1bmN0aW9uIGMoVCxPLHYpe2xldCBQPU87aWYodHlwZW9mIE89PSJzdHJpbmciJiYoUD1sKE8pKSxQJiZ0eXBlb2YgUC50aGVuPT0iZnVuY3Rpb24iJiYoUD1hd2FpdCBQKSxPPT09VC5hdHRyaWJ1dGVzLnRleHR1cmUpe1AmJlAuaW1hZ2UmJihQLnNvdXJjZVJlY3QmJihULmF0dHJpYnV0ZXMuc291cmNlUmVjdD1QLnNvdXJjZVJlY3QpLFQudGV4dHVyZUltYWdlUm90YXRlZD0hIVAucm90YXRlZCxQPVAuaW1hZ2UpO2NvbnN0e3dpZHRoOmksaGVpZ2h0OnUsdGV4dHVyZVJlY3Q6YX09VC5hdHRyaWJ1dGVzLGg9VC50ZXh0dXJlSW1hZ2U7VC50ZXh0dXJlSW1hZ2U9UCx2JiZoIT09UCYmIWEmJihpPT1udWxsfHx1PT1udWxsKSYmVC51cGRhdGVDb250b3VycygpLFQuZm9yY2VVcGRhdGUoKX1yZXR1cm4gUH1jb25zdCBvPVN5bWJvbCgidGV4dHVyZU1hcCIpO2Z1bmN0aW9uIGYoVCxPKXtpZihPW29dPU9bb118fG5ldyBNYXAsT1tvXS5oYXMoVCkpcmV0dXJuIE9bb10uZ2V0KFQpO2NvbnN0IHY9Ty5jcmVhdGVUZXh0dXJlKFQpO3JldHVybiEvXmJsb2I6Ly50ZXN0KFQuc3JjKSYmdHlwZW9mIFQuZ2V0Q29udGV4dCE9ImZ1bmN0aW9uIiYmT1tvXS5zZXQoVCx2KSx2fWZ1bmN0aW9uIHgoVCxPKXtpZihPW29dJiZPW29dLmhhcyhUKSl7Y29uc3Qgdj1PW29dLmdldChUKTtyZXR1cm4gTy5kZWxldGVUZXh0dXJlKHYpLE9bb10uZGVsZXRlKFQpLCEwfXJldHVybiExfWNvbnN0IGc9U3ltYm9sKCJ0ZXh0dXJlQ29udGV4dCIpO2Z1bmN0aW9uIHkoVCxPKXtjb25zdCB2PVQudGV4dHVyZUltYWdlIGluc3RhbmNlb2YgU3RyaW5nP1N0cmluZyhULnRleHR1cmVJbWFnZSk6VC50ZXh0dXJlSW1hZ2UsUD1ULnRleHR1cmVJbWFnZVJvdGF0ZWQsaT1PLnRleHR1cmUsdT1ULnJlbmRlcmVyO2lmKHYpe2NvbnN0IGE9VC5vcmlnaW5hbENvbnRlbnRSZWN0O2xldCBoPVQuYXR0cmlidXRlcy50ZXh0dXJlUmVjdDtjb25zdCBiPVQuYXR0cmlidXRlcy50ZXh0dXJlUmVwZWF0LEU9VC5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYoIWl8fFRbZ10mJlRbZ10hPT11fHxpLmltYWdlIT09dnx8aS5vcHRpb25zLnJlcGVhdCE9PWJ8fCFPYmplY3Qobi5jb21wYXJlVmFsdWUpKGkub3B0aW9ucy5yZWN0LGgpfHwhT2JqZWN0KG4uY29tcGFyZVZhbHVlKShpLm9wdGlvbnMuc3JjUmVjdCxFKSl7Y29uc3QgQT1mKHYsdSk7aD8oaFswXSs9YVswXSxoWzFdKz1hWzFdKTpoPWE7bGV0IEw9bnVsbDtpJiYhdVtvXS5oYXMoaS5pbWFnZSkmJighaS5vcHRpb25zfHwhaS5vcHRpb25zLmhpZGRlbikmJihMPU8udW5pZm9ybXMudV90ZXhTYW1wbGVyKSxPLnNldFRleHR1cmUoQSx7cmVjdDpoLHJlcGVhdDpiLHNyY1JlY3Q6RSxyb3RhdGVkOlB9KSxMJiZMLmRlbGV0ZSYmTC5kZWxldGUoKSxUW2ddPXV9fWVsc2UgaWYoaSl7bGV0IGE9bnVsbDshdVtvXS5oYXMoaS5pbWFnZSkmJighaS5vcHRpb25zfHwhaS5vcHRpb25zLmhpZGRlbikmJihhPU8udW5pZm9ybXMudV90ZXhTYW1wbGVyKSxPLnNldFRleHR1cmUobnVsbCksYSYmYS5kZWxldGUmJmEuZGVsZXRlKCl9fWFzeW5jIGZ1bmN0aW9uIG0oVCxPKXt0eXBlb2YgTz09InN0cmluZyImJihPPWF3YWl0KGF3YWl0IGZldGNoKE8se21ldGhvZDoiR0VUIixtb2RlOiJjb3JzIixjYWNoZToiZGVmYXVsdCJ9KSkuanNvbigpKTtjb25zdCB2PWF3YWl0IGwoVCksUD1PLmZyYW1lcztyZXR1cm4gT2JqZWN0LmVudHJpZXMoUCkuZm9yRWFjaCgoW2ksdV0pPT57Y29uc3R7eDphLHk6aCx3OmIsaDpFfT11LmZyYW1lO2xldCBBPVthLGgsYixFXTtjb25zdCBMPXUucm90YXRlZDtMJiYoQT1bQVswXSxBWzFdLEFbM10sQVsyXV0pLHNbaV09e2ltYWdlOnYsc291cmNlUmVjdDpBLHJvdGF0ZWQ6TH19KSx2fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pO3ZhciByPXQoMSksbj10KDEyKSxzPXQoNzApLGw9dCgyMjApLGM9dCgyMjEpLG89dCgyMjIpLGY9dCgyMTMpLHg9dCgyMjMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKFQsTyx2KXtyZXR1cm4gTyBpbiBUP09iamVjdC5kZWZpbmVQcm9wZXJ0eShULE8se3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpUW09dPXYsVH1jb25zdCB5PVN5bWJvbCgibWVzaCIpO2NsYXNzIG0gZXh0ZW5kcyBzLmRlZmF1bHR7Y29uc3RydWN0b3IoTz17fSl7c3VwZXIoTyl9Z2V0IGJvcmRlclNpemUoKXtjb25zdHtwYWRkaW5nVG9wOk8scGFkZGluZ1JpZ2h0OnYscGFkZGluZ0JvdHRvbTpQLHBhZGRpbmdMZWZ0OmksYm9yZGVyV2lkdGg6dX09dGhpcy5hdHRyaWJ1dGVzLFthLGhdPXRoaXMuY29udGVudFNpemU7cmV0dXJuW2krYSt2K3UsTytoK1ArdV19Z2V0IGNsaWVudFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOk8scGFkZGluZ1JpZ2h0OnYscGFkZGluZ0JvdHRvbTpQLHBhZGRpbmdMZWZ0Oml9PXRoaXMuYXR0cmlidXRlcyxbdSxhXT10aGlzLmNvbnRlbnRTaXplO3JldHVybltpK3UrdixPK2ErUF19Z2V0IGNvbnRlbnRTaXplKCl7bGV0e3dpZHRoOk8saGVpZ2h0OnYsYm94U2l6aW5nOlAscGFkZGluZ1RvcDppLHBhZGRpbmdSaWdodDp1LHBhZGRpbmdCb3R0b206YSxwYWRkaW5nTGVmdDpofT10aGlzLmF0dHJpYnV0ZXM7aWYoTz1PfHwwLHY9dnx8MCxQPT09ImJvcmRlci1ib3giKXtjb25zdCBiPTIqdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoO08tPWIrdStoLHYtPWIraSthLE89TWF0aC5tYXgoMCxPKSx2PU1hdGgubWF4KDAsdil9cmV0dXJuW08sdl19Z2V0IGhhc0JvcmRlcigpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg+MH1nZXQgaXNWaXNpYmxlKCl7Y29uc3RbTyx2XT10aGlzLmJvcmRlclNpemU7cmV0dXJuIE8+MCYmdj4wfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgTz10aGlzLmNsaWVudEJveDtpZihPKXtsZXQgdj10aGlzW3ldO2lmKHYpdi5ib3ghPT1PJiYodi5jb250b3Vycz1PLmNvbnRvdXJzLHYuYm94PU8pO2Vsc2V7dj1uZXcgbi5NZXNoMkQoTyksdi5ib3g9Tztjb25zdCBpPXRoaXMuYXR0cmlidXRlcy5iZ2NvbG9yO2lmKE9iamVjdChjLnNldEZpbGxDb2xvcikodix7Y29sb3I6aX0pLHRoaXMuaGFzQm9yZGVyKXtjb25zdHtib3JkZXJDb2xvcjphLGJvcmRlcldpZHRoOmgsYm9yZGVyRGFzaDpiLGJvcmRlckRhc2hPZmZzZXQ6RX09dGhpcy5hdHRyaWJ1dGVzO09iamVjdChjLnNldFN0cm9rZUNvbG9yKSh2LHtjb2xvcjphLGxpbmVXaWR0aDpoLGxpbmVEYXNoOmIsbGluZURhc2hPZmZzZXQ6RX0pfXRoaXNbeV09djtjb25zdCB1PXRoaXMuYXR0cmlidXRlcy5jbGlwUGF0aDt1JiZ0aGlzW3ldLnNldENsaXBQYXRoKHUpfWNvbnN0IFA9dGhpcy5vcGFjaXR5O3JldHVybiB2LmdldE9wYWNpdHkoKSE9PVAmJnYuc2V0T3BhY2l0eShQKSx2LnNldFRyYW5zZm9ybSguLi50aGlzLnJlbmRlck1hdHJpeCksdn1yZXR1cm4gbnVsbH1nZXQgb2Zmc2V0U2l6ZSgpe2NvbnN0e3BhZGRpbmdUb3A6TyxwYWRkaW5nUmlnaHQ6dixwYWRkaW5nQm90dG9tOlAscGFkZGluZ0xlZnQ6aSxib3JkZXJXaWR0aDp1fT10aGlzLmF0dHJpYnV0ZXMsW2EsaF09dGhpcy5jb250ZW50U2l6ZSxiPTIqdTtyZXR1cm5baSthK3YrYixPK2grUCtiXX1nZXQgb3JpZ2luYWxDbGllbnRSZWN0KCl7aWYodGhpcy5tZXNoKXtjb25zdCBPPXRoaXMubWVzaC5ib3VuZGluZ0JveDtyZXR1cm5bT1swXVswXSxPWzBdWzFdLE9bMV1bMF0tT1swXVswXSxPWzFdWzFdLU9bMF1bMV1dfXJldHVyblswLDAsMCwwXX1nZXQgb3JpZ2luYWxDb250ZW50UmVjdCgpe2NvbnN0W08sdixQLGldPXRoaXMub3JpZ2luYWxDbGllbnRSZWN0LHU9dGhpcy5hdHRyaWJ1dGVzLnBhZGRpbmc7cmV0dXJuW08rdVswXSx2K3VbMV0sUC11WzBdLXVbMl0saS11WzFdLXVbM11dfWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCBPPXRoaXMucmVuZGVyTWF0cml4O3RoaXMubGF5ZXImJnRoaXMubGF5ZXIubGF5ZXJUcmFuc2Zvcm1JbnZlcnQmJihPPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXMubGF5ZXIudHJhbnNmb3JtTWF0cml4LE8pKTtsZXQgdj1udWxsO2lmKHRoaXMubWVzaCl7dj1bLi4udGhpcy5tZXNoLmJvdW5kaW5nQm94XTtjb25zdCBQPXRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDtQJiYodlswXT1bdlswXVswXS1QLHZbMF1bMV0tUF0sdlsxXT1bdlsxXVswXStQLHZbMV1bMV0rUF0pfXJldHVybiBPYmplY3QoeC5kZWZhdWx0KSh2LE8pfW9uUHJvcGVydHlDaGFuZ2UoTyx2LFApe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoTyx2LFApLChPPT09ImFuY2hvclgifHxPPT09ImFuY2hvclkifHxPPT09ImJveFNpemluZyJ8fE89PT0id2lkdGgifHxPPT09ImhlaWdodCJ8fE89PT0iYm9yZGVyV2lkdGgifHxPPT09InBhZGRpbmdMZWZ0Inx8Tz09PSJwYWRkaW5nUmlnaHQifHxPPT09InBhZGRpbmdUb3AifHxPPT09InBhZGRpbmdCb3R0b20ifHwvXmJvcmRlcihUb3BMZWZ0fFRvcFJpZ2h0fEJvdHRvbVJpZ2h0fEJvdHRvbUxlZnQpUmFkaXVzJC8udGVzdChPKSkmJnRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzW3ldJiZPPT09ImNsaXBQYXRoIiYmdGhpc1t5XS5zZXRDbGlwUGF0aCh2KSx0aGlzW3ldJiZPPT09ImJnY29sb3IiJiZPYmplY3QoYy5zZXRGaWxsQ29sb3IpKHRoaXNbeV0se2NvbG9yOnZ9KSx0aGlzW3ldJiYoTz09PSJib3JkZXJDb2xvciJ8fE89PT0iYm9yZGVyV2lkdGgifHxPPT09ImJvcmRlckRhc2gifHxPPT09ImJvcmRlckRhc2hPZmZzZXQiKSl7Y29uc3R7Ym9yZGVyQ29sb3I6aSxib3JkZXJXaWR0aDp1LGJvcmRlckRhc2g6YSxib3JkZXJEYXNoT2Zmc2V0Omh9PXRoaXMuYXR0cmlidXRlcztPYmplY3QoYy5zZXRTdHJva2VDb2xvcikodGhpc1t5XSx7Y29sb3I6aSxsaW5lV2lkdGg6dSxsaW5lRGFzaDp1P2E6MCxsaW5lRGFzaE9mZnNldDpofSl9fXVwZGF0ZUNvbnRvdXJzKCl7Y29uc3R7YW5jaG9yWDpPLGFuY2hvclk6dixib3JkZXJXaWR0aDpQLGJvcmRlclJhZGl1czppfT10aGlzLmF0dHJpYnV0ZXMsW3UsYV09dGhpcy5ib3JkZXJTaXplLGg9dGhpcy5vZmZzZXRTaXplLGI9LjUqUCxFPS1PKmhbMF0rYixBPS12KmhbMV0rYjt0aGlzLmNsaWVudEJveD1uZXcgbi5GaWd1cmUyRCxPYmplY3Qoby5jcmVhdGVSYWRpdXNCb3gpKHRoaXMuY2xpZW50Qm94LFtFLEEsdSxhXSxpKX19ZyhtLCJBdHRyIixsLmRlZmF1bHQpLGYuZGVmYXVsdC5yZWdpc3Rlck5vZGUobSwiYmxvY2siKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pO3ZhciByPXQoNzEpLG49dCg3Mikscz10KDIyMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2NsYXNzIHggZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tvXSh7YW5jaG9yWDowLGFuY2hvclk6MCx3aWR0aDp2b2lkIDAsaGVpZ2h0OnZvaWQgMCxib3JkZXJXaWR0aDowLGJvcmRlckNvbG9yOiJyZ2JhKDAsMCwwLDEpIixib3JkZXJEYXNoOnZvaWQgMCxib3JkZXJEYXNoT2Zmc2V0OjAsYm9yZGVyVG9wTGVmdFJhZGl1czpbMCwwXSxib3JkZXJUb3BSaWdodFJhZGl1czpbMCwwXSxib3JkZXJCb3R0b21SaWdodFJhZGl1czpbMCwwXSxib3JkZXJCb3R0b21MZWZ0UmFkaXVzOlswLDBdLGJnY29sb3I6InJnYmEoMCwwLDAsMCkiLHBhZGRpbmdUb3A6MCxwYWRkaW5nUmlnaHQ6MCxwYWRkaW5nQm90dG9tOjAscGFkZGluZ0xlZnQ6MCxib3hTaXppbmc6ImNvbnRlbnQtYm94IixjbGlwUGF0aDp2b2lkIDB9KSx0aGlzW2ZdKCJhbmNob3IiLCJzaXplIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwicGFkZGluZyIpfWdldCBhbmNob3JYKCl7cmV0dXJuIHRoaXNbY10oImFuY2hvclgiKX1zZXQgYW5jaG9yWCh5KXt0aGlzW2xdKCJhbmNob3JYIixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCBhbmNob3JZKCl7cmV0dXJuIHRoaXNbY10oImFuY2hvclkiKX1zZXQgYW5jaG9yWSh5KXt0aGlzW2xdKCJhbmNob3JZIixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCBhbmNob3IoKXtyZXR1cm5bdGhpcy5hbmNob3JYLHRoaXMuYW5jaG9yWV19c2V0IGFuY2hvcih5KXt5PU9iamVjdChuLnRvQXJyYXkpKHkpLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzLmFuY2hvclg9eVswXSx0aGlzLmFuY2hvclk9eVsxXX1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpc1tjXSgid2lkdGgiKX1zZXQgd2lkdGgoeSl7dGhpc1tsXSgid2lkdGgiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzW2NdKCJoZWlnaHQiKX1zZXQgaGVpZ2h0KHkpe3RoaXNbbF0oImhlaWdodCIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgc2l6ZSgpe3JldHVyblt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XX1zZXQgc2l6ZSh5KXt5PU9iamVjdChuLnRvQXJyYXkpKHkpLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzLndpZHRoPXlbMF0sdGhpcy5oZWlnaHQ9eVsxXX1nZXQgYm9yZGVyV2lkdGgoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyV2lkdGgiKX1zZXQgYm9yZGVyV2lkdGgoeSl7dGhpc1tsXSgiYm9yZGVyV2lkdGgiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IGJvcmRlckNvbG9yKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlckNvbG9yIil9c2V0IGJvcmRlckNvbG9yKHkpe3RoaXNbbF0oImJvcmRlckNvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKSh5KSl9Z2V0IGJvcmRlcigpe3JldHVyblt0aGlzLmJvcmRlcldpZHRoLHRoaXMuYm9yZGVyQ29sb3JdfXNldCBib3JkZXIoeSl7eT1PYmplY3Qobi50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beV0pLHRoaXMuYm9yZGVyV2lkdGg9eVswXSx5WzFdIT1udWxsJiYodGhpcy5ib3JkZXJDb2xvcj15WzFdKX1nZXQgYm9yZGVyRGFzaCgpe3JldHVybiB0aGlzW2NdKCJib3JkZXJEYXNoIil9c2V0IGJvcmRlckRhc2goeSl7eT1PYmplY3Qobi50b0FycmF5KSh5LCEwKSx5IT1udWxsJiYhQXJyYXkuaXNBcnJheSh5KSYmKHk9W3ldKSx0aGlzW2xdKCJib3JkZXJEYXNoIix5P3kubWFwKG4udG9OdW1iZXIpOm51bGwpfWdldCBib3JkZXJEYXNoT2Zmc2V0KCl7cmV0dXJuIHRoaXNbY10oImJvcmRlckRhc2hPZmZzZXQiKX1zZXQgYm9yZGVyRGFzaE9mZnNldCh5KXt0aGlzW2xdKCJib3JkZXJEYXNoT2Zmc2V0IixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCBib3JkZXJUb3BMZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlclRvcExlZnRSYWRpdXMiKX1zZXQgYm9yZGVyVG9wTGVmdFJhZGl1cyh5KXt5PU9iamVjdChuLnRvQXJyYXkpKHksITApLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzW2xdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIix5Lm1hcChuLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclRvcFJpZ2h0UmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlclRvcFJpZ2h0UmFkaXVzIil9c2V0IGJvcmRlclRvcFJpZ2h0UmFkaXVzKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXNbbF0oImJvcmRlclRvcFJpZ2h0UmFkaXVzIix5Lm1hcChuLnRvTnVtYmVyKSl9Z2V0IGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzIil9c2V0IGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXNbbF0oImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzIix5Lm1hcChuLnRvTnVtYmVyKSl9Z2V0IGJvcmRlckJvdHRvbUxlZnRSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXNbbF0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiLHkubWFwKG4udG9OdW1iZXIpKX1nZXQgYm9yZGVyUmFkaXVzKCl7cmV0dXJuWy4uLnRoaXMuYm9yZGVyVG9wTGVmdFJhZGl1cywuLi50aGlzLmJvcmRlclRvcFJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMsLi4udGhpcy5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzXX1zZXQgYm9yZGVyUmFkaXVzKHkpe2lmKHk9T2JqZWN0KG4udG9BcnJheSkoeSksIUFycmF5LmlzQXJyYXkoeSkpeT1BcnJheSg4KS5maWxsKHkpO2Vsc2UgaWYoeS5sZW5ndGg9PT0yKXk9W3lbMF0seVsxXSx5WzBdLHlbMV0seVswXSx5WzFdLHlbMF0seVsxXV07ZWxzZSBpZih5Lmxlbmd0aD09PTQpeT1beVswXSx5WzFdLHlbMl0seVszXSx5WzBdLHlbMV0seVsyXSx5WzNdXTtlbHNlIGlmKHkubGVuZ3RoPT09Nil5PVt5WzBdLHlbMV0seVsyXSx5WzNdLHlbNF0seVs1XSx5WzJdLHlbM11dO2Vsc2UgaWYoeS5sZW5ndGghPT04KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYm9yZGVyUmFkaXVzIHZhbHVlLiIpO3RoaXMuYm9yZGVyVG9wTGVmdFJhZGl1cz1beVswXSx5WzFdXSx0aGlzLmJvcmRlclRvcFJpZ2h0UmFkaXVzPVt5WzJdLHlbM11dLHRoaXMuYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM9W3lbNF0seVs1XV0sdGhpcy5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzPVt5WzZdLHlbN11dfWdldCBiZ2NvbG9yKCl7cmV0dXJuIHRoaXNbY10oImJnY29sb3IiKX1zZXQgYmdjb2xvcih5KXt0aGlzW2xdKCJiZ2NvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKSh5KSl9Z2V0IHBhZGRpbmdUb3AoKXtyZXR1cm4gdGhpc1tjXSgicGFkZGluZ1RvcCIpfXNldCBwYWRkaW5nVG9wKHkpe3RoaXNbbF0oInBhZGRpbmdUb3AiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IHBhZGRpbmdSaWdodCgpe3JldHVybiB0aGlzW2NdKCJwYWRkaW5nUmlnaHQiKX1zZXQgcGFkZGluZ1JpZ2h0KHkpe3RoaXNbbF0oInBhZGRpbmdSaWdodCIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgcGFkZGluZ0JvdHRvbSgpe3JldHVybiB0aGlzW2NdKCJwYWRkaW5nQm90dG9tIil9c2V0IHBhZGRpbmdCb3R0b20oeSl7dGhpc1tsXSgicGFkZGluZ0JvdHRvbSIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgcGFkZGluZ0xlZnQoKXtyZXR1cm4gdGhpc1tjXSgicGFkZGluZ0xlZnQiKX1zZXQgcGFkZGluZ0xlZnQoeSl7dGhpc1tsXSgicGFkZGluZ0xlZnQiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IHBhZGRpbmcoKXtyZXR1cm5bdGhpcy5wYWRkaW5nVG9wLHRoaXMucGFkZGluZ1JpZ2h0LHRoaXMucGFkZGluZ0JvdHRvbSx0aGlzLnBhZGRpbmdMZWZ0XX1zZXQgcGFkZGluZyh5KXt5PU9iamVjdChuLnRvQXJyYXkpKHkpLEFycmF5LmlzQXJyYXkoeSk/eS5sZW5ndGg9PT0yP3k9W3lbMF0seVsxXSx5WzBdLHlbMV1dOnkubGVuZ3RoPT09MyYmKHk9W3lbMF0seVsxXSx5WzJdLHlbMV1dKTp5PVt5LHkseSx5XSx0aGlzLnBhZGRpbmdUb3A9eVswXSx0aGlzLnBhZGRpbmdSaWdodD15WzFdLHRoaXMucGFkZGluZ0JvdHRvbT15WzJdLHRoaXMucGFkZGluZ0xlZnQ9eVszXX1nZXQgY2xpcFBhdGgoKXtyZXR1cm4gdGhpc1tjXSgiY2xpcFBhdGgiKX1zZXQgY2xpcFBhdGgoeSl7dGhpc1tsXSgiY2xpcFBhdGgiLHkpfWdldCBib3hTaXppbmcoKXtyZXR1cm4gdGhpc1tjXSgiYm94U2l6aW5nIil9c2V0IGJveFNpemluZyh5KXtpZih5IT1udWxsJiZ5IT09ImJvcmRlci1ib3giJiZ5IT09ImNvbnRlbnQtYm94Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJveFNpemluZyB0eXBlLiIpO3RoaXNbbF0oImJveFNpemluZyIseSl9fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiR3JhZGllbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiaXNUcmFuc3BhcmVudCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJwYXJzZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInNldEZpbGxDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzZXRTdHJva2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciByPXQoMzIpLG49dC5uKHIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjbGFzcyBze2NvbnN0cnVjdG9yKHt2ZWN0b3I6bSxjb2xvcnM6VH0pe2lmKCFBcnJheS5pc0FycmF5KG0pfHxtLmxlbmd0aCE9PTQmJm0ubGVuZ3RoIT09NiYmbS5sZW5ndGghPT0zKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZ3JhZGllbnQiKTt0aGlzLnZlY3Rvcj1tLHRoaXMuY29sb3JzPVQubWFwKCh7b2Zmc2V0Ok8sY29sb3I6dn0pPT4oe29mZnNldDpPLGNvbG9yOmModil9KSl9dG9TdHJpbmcoKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoe3ZlY3Rvcjp0aGlzLnZlY3Rvcixjb2xvcnM6dGhpcy5jb2xvcnN9KX19ZnVuY3Rpb24gbCh5KXtyZXR1cm4geSBpbnN0YW5jZW9mIHM/ITE6eT09bnVsbD8hMDpuKCkoeSlbM109PT0wfWZ1bmN0aW9uIGMoeSl7aWYoeT09bnVsbHx8KHl8fCh5PSJ0cmFuc3BhcmVudCIpLHkgaW5zdGFuY2VvZiBzKSlyZXR1cm4geTtjb25zdCBtPW4oKSh5KTtpZighbXx8IW0ubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY29sb3IgdmFsdWUuIik7cmV0dXJuYHJnYmEoJHttLmpvaW4oKX0pYH1mdW5jdGlvbiBvKHksbSxUKXtjb25zdCBPPXkuYm91bmRpbmdCb3hbMF07aWYoVC52ZWN0b3Ipe2xldHt2ZWN0b3I6dixjb2xvcnM6UH09VDt2Lmxlbmd0aD09PTQ/KHY9W3ZbMF0rT1swXSx2WzFdK09bMV0sdlsyXStPWzBdLHZbM10rT1sxXV0seS5zZXRMaW5lYXJHcmFkaWVudCh7dmVjdG9yOnYsY29sb3JzOlAsdHlwZTptfSkpOnYubGVuZ3RoPT09Mz8odj1bdlswXStPWzBdLHZbMV0rT1sxXSx2WzJdXSx5LnNldENpcmN1bGFyR3JhZGllbnQoe3ZlY3Rvcjp2LGNvbG9yczpQLHR5cGU6bX0pKToodj1bdlswXStPWzBdLHZbMV0rT1sxXSx2WzJdLHZbM10rT1swXSx2WzRdK09bMV0sdls1XV0seS5zZXRSYWRpYWxHcmFkaWVudCh7dmVjdG9yOnYsY29sb3JzOlAsdHlwZTptfSkpfWVsc2UgeS5ncmFkaWVudCYmeS5ncmFkaWVudFttXSYmKGRlbGV0ZSB5LmdyYWRpZW50W21dLGRlbGV0ZSB5LnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IpfWZ1bmN0aW9uIGYoeSx7Y29sb3I6bSxydWxlOlQ9Im5vbnplcm8ifSl7cmV0dXJuIG8oeSwiZmlsbCIsbSksbS52ZWN0b3J8fHkuc2V0RmlsbCh7Y29sb3I6bSxydWxlOlR9KSx5fWZ1bmN0aW9uIHgoeSx7Y29sb3I6bSxsaW5lV2lkdGg6VCxsaW5lQ2FwOk8sbGluZUpvaW46dixsaW5lRGFzaDpQLGxpbmVEYXNoT2Zmc2V0OmksbWl0ZXJMaW1pdDp1LHJvdW5kU2VnbWVudHM6YX0pe28oeSwic3Ryb2tlIixtKSxtLnZlY3RvciYmKG09WzAsMCwwLDFdKSx5LnNldFN0cm9rZSh7Y29sb3I6bSx0aGlja25lc3M6VCxjYXA6Tyxqb2luOnYsbWl0ZXJMaW1pdDp1LGxpbmVEYXNoOlAsbGluZURhc2hPZmZzZXQ6aSxyb3VuZFNlZ21lbnRzOmF9KX1jbGFzcyBnIGV4dGVuZHMgQXJyYXl7Y29uc3RydWN0b3IobT0wLFQ9MCxPPTAsdj0wKXtyZXR1cm4gQXJyYXkuaXNBcnJheShtKSYmKFttLFQsTyx2XT1tKSx0eXBlb2YgbT09InN0cmluZyImJihbbSxULE8sdl09bigpKG0pLG0vPTI1NSxULz0yNTUsTy89MjU1KSxzdXBlcihtLFQsTyx2KSx0aGlzfWdldCByKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1swXSoyNTUpfXNldCByKG0pe3RoaXNbMF09bS8yNTV9Z2V0IGcoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzFdKjI1NSl9c2V0IGcobSl7dGhpc1sxXT1tLzI1NX1nZXQgYigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMl0qMjU1KX1zZXQgYihtKXt0aGlzWzJdPW0vMjU1fWdldCBhKCl7cmV0dXJuIHRoaXNbM119c2V0IGEobSl7dGhpc1szXT1tfWdldCBoZXgoKXtjb25zdCBtPWAwJHt0aGlzLnIudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLFQ9YDAke3RoaXMuZy50b1N0cmluZygxNil9YC5zbGljZSgtMiksTz1gMCR7dGhpcy5iLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKTtsZXQgdjtyZXR1cm4gdGhpcy5hPDEmJih2PU1hdGgucm91bmQodGhpc1szXSoyNTUpLHY9YDAke3YudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpKSxgIyR7bX0ke1R9JHtPfSR7dnx8IiJ9YH1nZXQgcmdiYSgpe3JldHVybmByZ2JhKCR7dGhpcy5yfSwke3RoaXMuZ30sJHt0aGlzLmJ9LCR7dGhpcy5hfSlgfWZyb21Db2xvcihtKXtyZXR1cm4gdHlwZW9mIG09PSJzdHJpbmciJiYobT1uKCkobSksbVswXS89MjU1LG1bMV0vPTI1NSxtWzJdLz0yNTUpLHRoaXNbMF09bVswXSx0aGlzWzFdPW1bMV0sdGhpc1syXT1tWzJdLHRoaXNbM109bVszXSx0aGlzfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZVJhZGl1c0JveCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKHMsbCxjLG8sZix4PSJsZWZ0VG9wIil7Y29uc3QgZz0uNTUyMjg0OCx5PW8vMipnLG09Zi8yKmcsVD1sK28sTz1jK2Ysdj1sK28vMixQPWMrZi8yO3g9PT0ibGVmdFRvcCI/KHMubW92ZVRvKGwsUCkscy5iZXppZXJDdXJ2ZVRvKGwsUC1tLHYteSxjLHYsYykpOng9PT0icmlnaHRUb3AiP3MuYmV6aWVyQ3VydmVUbyh2K3ksYyxULFAtbSxULFApOng9PT0icmlnaHRCb3R0b20iP3MuYmV6aWVyQ3VydmVUbyhULFArbSx2K3ksTyx2LE8pOng9PT0ibGVmdEJvdHRvbSImJnMuYmV6aWVyQ3VydmVUbyh2LXksTyxsLFArbSxsLFApfWZ1bmN0aW9uIG4ocyxbbCxjLG8sZl0seCl7aWYoIXh8fEFycmF5LmlzQXJyYXkoeCkmJnguZXZlcnkoZz0+Zz09PTApKXMuYmVnaW5QYXRoKCkscy5yZWN0KGwsYyxvLGYpO2Vsc2V7dHlwZW9mIHg9PSJudW1iZXIiJiYoeD1BcnJheSg4KS5maWxsKHgpKTtjb25zdFtnLHksbSxULE8sdixQLGldPXgubWFwKCh1LGEpPT5hJTI/TWF0aC5taW4odSxmLzIpOk1hdGgubWluKHUsby8yKSk7cy5iZWdpblBhdGgoKSxzLm1vdmVUbyhsLGMreSkscihzLGwsYyxnKjIseSoyLCJsZWZ0VG9wIikscy5saW5lVG8obCtvLW0sYykscihzLGwrby1tKjIsYyxtKjIsVCoyLCJyaWdodFRvcCIpLHMubGluZVRvKGwrbyxjK2YtdikscihzLGwrby1PKjIsYytmLXYqMixPKjIsdioyLCJyaWdodEJvdHRvbSIpLHMubGluZVRvKGwrUCxjK2YpLHIocyxsLGMrZi1pKjIsUCoyLGkqMiwibGVmdEJvdHRvbSIpLHMuY2xvc2VQYXRoKCl9cmV0dXJuIHN9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KSxlLmRlZmF1bHQ9ZnVuY3Rpb24ocixuKXtpZighcilyZXR1cm57eDowLHk6MCx3aWR0aDowLGhlaWdodDowLGxlZnQ6MCx0b3A6MCxyaWdodDowLGJvdHRvbTowfTtjb25zdFtbcyxsXSxbYyxvXV09cixmPXMqblswXStsKm5bMl0rbls0XSx4PXMqblsxXStsKm5bM10rbls1XSxnPWMqblswXStsKm5bMl0rbls0XSx5PWMqblsxXStsKm5bM10rbls1XSxtPWMqblswXStvKm5bMl0rbls0XSxUPWMqblsxXStvKm5bM10rbls1XSxPPXMqblswXStvKm5bMl0rbls0XSx2PXMqblsxXStvKm5bM10rbls1XSxQPU1hdGgubWluKGYsZyxtLE8pLGk9TWF0aC5taW4oeCx5LFQsdiksdT1NYXRoLm1heChmLGcsbSxPKSxhPU1hdGgubWF4KHgseSxULHYpO3JldHVybnt4OlAseTppLHdpZHRoOnUtUCxoZWlnaHQ6YS1pLGxlZnQ6UCx0b3A6aSxyaWdodDp1LGJvdHRvbTphfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDIxOCksbj10KDIxOSkscz10KDIyNSksbD10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGMoeCxnLHkpe3JldHVybiBnIGluIHg/T2JqZWN0LmRlZmluZVByb3BlcnR5KHgsZyx7dmFsdWU6eSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnhbZ109eSx4fWNvbnN0IG89U3ltYm9sKCJ0ZXh0dXJlVGFzayIpO2NsYXNzIGYgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoZz17fSl7dHlwZW9mIGc9PSJzdHJpbmciJiYoZz17dGV4dHVyZTpnfSksc3VwZXIoZyl9Z2V0IGNvbnRlbnRTaXplKCl7bGV0W2cseV09c3VwZXIuY29udGVudFNpemU7Y29uc3R7d2lkdGg6bSxoZWlnaHQ6VH09dGhpcy5hdHRyaWJ1dGVzO2lmKG09PW51bGx8fFQ9PW51bGwpe2NvbnN0IE89dGhpcy50ZXh0dXJlSW1hZ2Usdj10aGlzLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3QsUD10aGlzLmF0dHJpYnV0ZXMuc291cmNlUmVjdDtpZih2KW09PW51bGwmJihnPXZbMF0rdlsyXSksVD09bnVsbCYmKHk9dlsxXSt2WzNdKTtlbHNlIGlmKFApe2NvbnN0IGk9dGhpcy5sYXllcj90aGlzLmxheWVyLmRpc3BsYXlSYXRpbzoxO209PW51bGwmJihnPVBbMl0vaSksVD09bnVsbCYmKHk9UFszXS9pKX1lbHNlIGlmKE8pe2NvbnN0IGk9dGhpcy5sYXllcj90aGlzLmxheWVyLmRpc3BsYXlSYXRpbzoxO209PW51bGwmJihnPU8ud2lkdGgvaSksVD09bnVsbCYmKHk9Ty5oZWlnaHQvaSl9fXJldHVybltnLHldfWdldCB0ZXh0dXJlSW1hZ2VSZWFkeSgpe3JldHVybiB0aGlzW29dfHxQcm9taXNlLnJlc29sdmUoKX1kcmF3KGc9W10pe3N1cGVyLmRyYXcoZyk7Y29uc3QgeT10aGlzLm1lc2g7cmV0dXJuIHkmJk9iamVjdChyLmRyYXdUZXh0dXJlKSh0aGlzLHkpLGd9b25Qcm9wZXJ0eUNoYW5nZShnLHksbSl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShnLHksbSksZz09PSJ0ZXh0dXJlIiYmKHRoaXNbb109T2JqZWN0KHIuYXBwbHlUZXh0dXJlKSh0aGlzLHksITApKSxnPT09InRleHR1cmVSZWN0Iil7Y29uc3R7d2lkdGg6VCxoZWlnaHQ6T309dGhpcy5hdHRyaWJ1dGVzOyhUPT1udWxsfHxPPT1udWxsKSYmdGhpcy51cGRhdGVDb250b3VycygpfX19YyhmLCJBdHRyIixzLmRlZmF1bHQpLGwuZGVmYXVsdC5yZWdpc3Rlck5vZGUoZiwic3ByaXRlIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtjbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbbl0oe3RleHR1cmU6dm9pZCAwLHRleHR1cmVSZWN0OnZvaWQgMCx0ZXh0dXJlUmVwZWF0OiExLHNvdXJjZVJlY3Q6dm9pZCAwfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tsXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe3RoaXNbc10oInRleHR1cmUiLGYpfWdldCB0ZXh0dXJlUmVjdCgpe3JldHVybiB0aGlzW2xdKCJ0ZXh0dXJlUmVjdCIpfXNldCB0ZXh0dXJlUmVjdChmKXt0aGlzW3NdKCJ0ZXh0dXJlUmVjdCIsZil9Z2V0IHNvdXJjZVJlY3QoKXtyZXR1cm4gdGhpc1tsXSgic291cmNlUmVjdCIpfXNldCBzb3VyY2VSZWN0KGYpe3RoaXNbc10oInNvdXJjZVJlY3QiLGYpfWdldCB0ZXh0dXJlUmVwZWF0KCl7cmV0dXJuIHRoaXNbbF0oInRleHR1cmVSZXBlYXQiKX1zZXQgdGV4dHVyZVJlcGVhdChmKXt0aGlzW3NdKCJ0ZXh0dXJlUmVwZWF0IiwhIWYpfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgcj10KDEyKSxuPXQoMjI3KSxzPXQubihuKSxsPXQoNzApLGM9dCgyMjgpLG89dCgyMjEpLGY9dCgyMTgpLHg9dCgyMTMpLGc9dCgyMjMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB5KE8sdixQKXtyZXR1cm4gdiBpbiBPP09iamVjdC5kZWZpbmVQcm9wZXJ0eShPLHYse3ZhbHVlOlAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpPW3ZdPVAsT31jb25zdCBtPVN5bWJvbCgibWVzaCIpO2NsYXNzIFQgZXh0ZW5kcyBsLmRlZmF1bHR7Y29uc3RydWN0b3Iodj17fSl7dHlwZW9mIHY9PSJzdHJpbmciJiYodj17ZDp2fSksc3VwZXIodiksdGhpcy5lZmZlY3RzPXtkKFAsaSx1LGEsaCl7Y29uc3QgYj0odS1hKS8oaC1hKTtpZihiPD0wKXJldHVybiBQO2lmKGI+PTEpcmV0dXJuIGk7Y29uc3QgRT1zLmEuX3ByZXByb2Nlc3Npbmcocy5hLnBhdGgyc2hhcGVzKFApLHMuYS5wYXRoMnNoYXBlcyhpKSksQT1zLmEuX2xlcnAoLi4uRSxiKVswXTtyZXR1cm4gQS5yZWR1Y2UoKFMsSSk9PmAke1N9JHtJLnNsaWNlKDIpLmpvaW4oIiAiKX0gYCxgTSR7QVswXVswXX0gJHtBWzBdWzFdfUNgKS50cmltKCl9fX1nZXQgaXNWaXNpYmxlKCl7cmV0dXJuISF0aGlzLmR9Z2V0IG1lc2goKXtpZih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT09PSJub25lIilyZXR1cm4gbnVsbDtjb25zdCB2PXRoaXMucGF0aDtpZih2KXtsZXQgUD10aGlzW21dO2lmKFApUC5wYXRoIT09diYmKFAuY29udG91cnM9di5jb250b3VycyxQLnBhdGg9dik7ZWxzZXtQPW5ldyByLk1lc2gyRCh0aGlzLnBhdGgpLFAucGF0aD12O2NvbnN0IHU9dGhpcy5hdHRyaWJ1dGVzLmZpbGxDb2xvcixhPXRoaXMuYXR0cmlidXRlcy5maWxsUnVsZTt1JiZPYmplY3Qoby5zZXRGaWxsQ29sb3IpKFAse2NvbG9yOnUscnVsZTphfSk7Y29uc3QgaD10aGlzLmF0dHJpYnV0ZXMubGluZVdpZHRoLGI9dGhpcy5hdHRyaWJ1dGVzLnN0cm9rZUNvbG9yO2lmKGImJmg+MCl7Y29uc3R7bGluZUNhcDpBLGxpbmVKb2luOkwsbWl0ZXJMaW1pdDpTLGxpbmVEYXNoOkksbGluZURhc2hPZmZzZXQ6RCxyb3VuZFNlZ21lbnRzOlJ9PXRoaXMuYXR0cmlidXRlcztPYmplY3Qoby5zZXRTdHJva2VDb2xvcikoUCx7Y29sb3I6YixsaW5lV2lkdGg6aCxsaW5lQ2FwOkEsbGluZUpvaW46TCxtaXRlckxpbWl0OlMsbGluZURhc2g6SSxsaW5lRGFzaE9mZnNldDpELHJvdW5kU2VnbWVudHM6Un0pfXRoaXNbbV09UDtjb25zdCBFPXRoaXMuYXR0cmlidXRlcy5jbGlwUGF0aDtFJiZ0aGlzW21dLnNldENsaXBQYXRoKEUpfWNvbnN0IGk9dGhpcy5vcGFjaXR5O3JldHVybiBQLmdldE9wYWNpdHkoKSE9PWkmJlAuc2V0T3BhY2l0eShpKSxQLnNldFRyYW5zZm9ybSguLi50aGlzLnJlbmRlck1hdHJpeCksUH1yZXR1cm4gbnVsbH1nZXQgb3JpZ2luYWxDb250ZW50UmVjdCgpe2lmKHRoaXMucGF0aCl7Y29uc3Qgdj10aGlzLnBhdGguYm91bmRpbmdCb3g7cmV0dXJuW3ZbMF1bMF0sdlswXVsxXSx2WzFdWzBdLXZbMF1bMF0sdlsxXVsxXS12WzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3Qgdj10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW3ZbMF1bMF0sdlswXVsxXSx2WzFdWzBdLXZbMF1bMF0sdlsxXVsxXS12WzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ2xpZW50Q2VudGVyKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guYm91bmRpbmdDZW50ZXI6WzAsMF19c2V0IGQodil7dGhpcy5hdHRyaWJ1dGVzLmQ9dn1nZXQgZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuZH1kcmF3KHY9W10pe3N1cGVyLmRyYXcodik7Y29uc3QgUD10aGlzLm1lc2g7cmV0dXJuIFAmJk9iamVjdChmLmRyYXdUZXh0dXJlKSh0aGlzLFApLHZ9Z2V0Qm91bmRpbmdDbGllbnRSZWN0KCl7bGV0IHY9bnVsbDtyZXR1cm4gdGhpcy5tZXNoJiYodj10aGlzLm1lc2guYm91bmRpbmdCb3gpLE9iamVjdChnLmRlZmF1bHQpKHYsdGhpcy5yZW5kZXJNYXRyaXgpfWdldFBhdGhMZW5ndGgoKXtyZXR1cm4gdGhpcy5tZXNoP3RoaXMubWVzaC5nZXRUb3RhbExlbmd0aCgpOjB9Z2V0UG9pbnRBdExlbmd0aCh2KXtpZih0aGlzLm1lc2gpe2NvbnN0IFA9dGhpcy5tZXNoLmdldFBvaW50QXRMZW5ndGgodik7aWYoUClyZXR1cm5bUC54LFAueV19cmV0dXJuWzAsMF19b25Qcm9wZXJ0eUNoYW5nZSh2LFAsaSl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZSh2LFAsaSksKHY9PT0iZCJ8fHY9PT0ibm9ybWFsaXplIikmJnRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzW21dJiYodj09PSJmaWxsQ29sb3IifHx2PT09ImZpbGxSdWxlIikpe2NvbnN0e2ZpbGxDb2xvcjp1LGZpbGxSdWxlOmF9PXRoaXMuYXR0cmlidXRlcztPYmplY3Qoby5zZXRGaWxsQ29sb3IpKHRoaXNbbV0se2NvbG9yOnUscnVsZTphfSl9aWYodGhpc1ttXSYmKHY9PT0ic3Ryb2tlQ29sb3IifHx2PT09ImxpbmVXaWR0aCJ8fHY9PT0ibGluZUNhcCJ8fHY9PT0ibGluZUpvaW4ifHx2PT09ImxpbmVEYXNoInx8dj09PSJsaW5lRGFzaE9mZnNldCJ8fHY9PT0icm91bmRTZWdtZW50cyIpKXtjb25zdHtzdHJva2VDb2xvcjp1LGxpbmVXaWR0aDphfT10aGlzLmF0dHJpYnV0ZXM7aWYodSYmYT4wKXtjb25zdHtsaW5lQ2FwOmgsbGluZUpvaW46YixsaW5lRGFzaDpFLGxpbmVEYXNoT2Zmc2V0OkEsbWl0ZXJMaW1pdDpMLHJvdW5kU2VnbWVudHM6U309dGhpcy5hdHRyaWJ1dGVzO09iamVjdChvLnNldFN0cm9rZUNvbG9yKSh0aGlzW21dLHtjb2xvcjp1LGxpbmVDYXA6aCxsaW5lSm9pbjpiLGxpbmVXaWR0aDphLGxpbmVEYXNoOkUsbGluZURhc2hPZmZzZXQ6QSxtaXRlckxpbWl0Okwscm91bmRTZWdtZW50czpTfSl9fXRoaXNbbV0mJnY9PT0iY2xpcFBhdGgiJiZ0aGlzW21dLnNldENsaXBQYXRoKFApLHY9PT0idGV4dHVyZSImJk9iamVjdChmLmFwcGx5VGV4dHVyZSkodGhpcyxQKX11cGRhdGVDb250b3Vycygpe3RoaXMucGF0aD1uZXcgci5GaWd1cmUyRCx0aGlzLnBhdGguYWRkUGF0aCh0aGlzLmF0dHJpYnV0ZXMuZCksdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbGl6ZSYmdGhpcy5wYXRoLm5vcm1hbGl6ZSguLi50aGlzLnBhdGguYm91bmRpbmdDZW50ZXIpfX15KFQsIkF0dHIiLGMuZGVmYXVsdCkseC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShULCJwYXRoIil9LGZ1bmN0aW9uKGQsZSx0KXsoZnVuY3Rpb24ocixuKXtkLmV4cG9ydHM9bigpfSkodGhpcyxmdW5jdGlvbigpe3ZhciByPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gSShELFIpe3ZhciBDPVtdLGo9ITAsJD0hMSxIPXZvaWQgMDt0cnl7Zm9yKHZhciBKPURbU3ltYm9sLml0ZXJhdG9yXSgpLHE7IShqPShxPUoubmV4dCgpKS5kb25lKSYmKEMucHVzaChxLnZhbHVlKSwhKFImJkMubGVuZ3RoPT09UikpO2o9ITApO31jYXRjaChGKXskPSEwLEg9Rn1maW5hbGx5e3RyeXshaiYmSi5yZXR1cm4mJkoucmV0dXJuKCl9ZmluYWxseXtpZigkKXRocm93IEh9fXJldHVybiBDfXJldHVybiBmdW5jdGlvbihELFIpe2lmKEFycmF5LmlzQXJyYXkoRCkpcmV0dXJuIEQ7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChEKSlyZXR1cm4gSShELFIpO3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UiKX19KCksbj1NYXRoLlBJKjIscz1mdW5jdGlvbihELFIsQyxqLCQsSCxKKXt2YXIgcT1ELngsRj1ELnk7cSo9UixGKj1DO3ZhciBHPWoqcS0kKkYsWj0kKnEraipGO3JldHVybnt4OkcrSCx5OlorSn19LGw9ZnVuY3Rpb24oRCxSKXt2YXIgQz0xLjMzMzMzMzMzMzMzMzMzMzMqTWF0aC50YW4oUi80KSxqPU1hdGguY29zKEQpLCQ9TWF0aC5zaW4oRCksSD1NYXRoLmNvcyhEK1IpLEo9TWF0aC5zaW4oRCtSKTtyZXR1cm5be3g6ai0kKkMseTokK2oqQ30se3g6SCtKKkMseTpKLUgqQ30se3g6SCx5Okp9XX0sYz1mdW5jdGlvbihELFIsQyxqKXt2YXIgJD1EKmotUipDPDA/LTE6MSxIPU1hdGguc3FydChEKkQrUipSKSxKPU1hdGguc3FydChEKkQrUipSKSxxPUQqQytSKmosRj1xLyhIKkopO3JldHVybiBGPjEmJihGPTEpLEY8LTEmJihGPS0xKSwkKk1hdGguYWNvcyhGKX0sbz1mdW5jdGlvbihELFIsQyxqLCQsSCxKLHEsRixHLFosdHQpe3ZhciBldD1NYXRoLnBvdygkLDIpLGl0PU1hdGgucG93KEgsMiksaz1NYXRoLnBvdyhaLDIpLGh0PU1hdGgucG93KHR0LDIpLGZ0PWV0Kml0LWV0Kmh0LWl0Kms7ZnQ8MCYmKGZ0PTApLGZ0Lz1ldCpodCtpdCprLGZ0PU1hdGguc3FydChmdCkqKEo9PT1xPy0xOjEpO3ZhciBCPWZ0KiQvSCp0dCxXPWZ0Ki1ILyQqWixWPUcqQi1GKlcrKEQrQykvMixYPUYqQitHKlcrKFIraikvMixOPShaLUIpLyQsej0odHQtVykvSCxwPSgtWi1CKS8kLE09KC10dC1XKS9ILHc9YygxLDAsTix6KSxVPWMoTix6LHAsTSk7cmV0dXJuIHE9PT0wJiZVPjAmJihVLT1uKSxxPT09MSYmVTwwJiYoVSs9biksW1YsWCx3LFVdfSxmPWZ1bmN0aW9uKEQpe3ZhciBSPUQucHgsQz1ELnB5LGo9RC5jeCwkPUQuY3ksSD1ELnJ4LEo9RC5yeSxxPUQueEF4aXNSb3RhdGlvbixGPXE9PT12b2lkIDA/MDpxLEc9RC5sYXJnZUFyY0ZsYWcsWj1HPT09dm9pZCAwPzA6Ryx0dD1ELnN3ZWVwRmxhZyxldD10dD09PXZvaWQgMD8wOnR0LGl0PVtdO2lmKEg9PT0wfHxKPT09MClyZXR1cm5bXTt2YXIgaz1NYXRoLnNpbihGKm4vMzYwKSxodD1NYXRoLmNvcyhGKm4vMzYwKSxmdD1odCooUi1qKS8yK2sqKEMtJCkvMixCPS1rKihSLWopLzIraHQqKEMtJCkvMjtpZihmdD09PTAmJkI9PT0wKXJldHVybltdO0g9TWF0aC5hYnMoSCksSj1NYXRoLmFicyhKKTt2YXIgVz1NYXRoLnBvdyhmdCwyKS9NYXRoLnBvdyhILDIpK01hdGgucG93KEIsMikvTWF0aC5wb3coSiwyKTtXPjEmJihIKj1NYXRoLnNxcnQoVyksSio9TWF0aC5zcXJ0KFcpKTt2YXIgVj1vKFIsQyxqLCQsSCxKLFosZXQsayxodCxmdCxCKSxYPXIoViw0KSxOPVhbMF0sej1YWzFdLHA9WFsyXSxNPVhbM10sdz1NYXRoLm1heChNYXRoLmNlaWwoTWF0aC5hYnMoTSkvKG4vNCkpLDEpO00vPXc7Zm9yKHZhciBVPTA7VTx3O1UrKylpdC5wdXNoKGwocCxNKSkscCs9TTtyZXR1cm4gaXQubWFwKGZ1bmN0aW9uKEspe3ZhciBZPXMoS1swXSxILEosaHQsayxOLHopLFE9WS54LHJ0PVkueSxudD1zKEtbMV0sSCxKLGh0LGssTix6KSxhdD1udC54LGN0PW50Lnksb3Q9cyhLWzJdLEgsSixodCxrLE4seiksc3Q9b3QueCxsdD1vdC55O3JldHVybnt4MTpRLHkxOnJ0LHgyOmF0LHkyOmN0LHg6c3QseTpsdH19KX0seD17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxnPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24geShJKXt2YXIgRD1bXTtyZXR1cm4gSS5yZXBsYWNlKGcsZnVuY3Rpb24oUixDLGope3ZhciAkPUMudG9Mb3dlckNhc2UoKTtmb3Ioaj1UKGopLCQ9PSJtIiYmai5sZW5ndGg+MiYmKEQucHVzaChbQ10uY29uY2F0KGouc3BsaWNlKDAsMikpKSwkPSJsIixDPUM9PSJtIj8ibCI6IkwiKTs7KXtpZihqLmxlbmd0aD09eFskXSlyZXR1cm4gai51bnNoaWZ0KEMpLEQucHVzaChqKTtpZihqLmxlbmd0aDx4WyRdKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO0QucHVzaChbQ10uY29uY2F0KGouc3BsaWNlKDAseFskXSkpKX19KSxEfXZhciBtPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIFQoSSl7dmFyIEQ9SS5tYXRjaChtKTtyZXR1cm4gRD9ELm1hcChOdW1iZXIpOltdfWZ1bmN0aW9uIE8oSSl7dmFyIEQ9SVswXVswXSxSPUlbMF1bMV0sQz1ELGo9UjtyZXR1cm4gSS5mb3JFYWNoKGZ1bmN0aW9uKCQpe3ZhciBIPSRbMF0sSj0kWzJdLHE9JFs0XSxGPSRbNl0sRz0kWzFdLFo9JFszXSx0dD0kWzVdLGV0PSRbN107RD1NYXRoLm1pbihELEgsSixxLEYpLFI9TWF0aC5taW4oUixHLFosdHQsZXQpLEM9TWF0aC5tYXgoQyxILEoscSxGKSxqPU1hdGgubWF4KGosRyxaLHR0LGV0KX0pLFtELFIsQyxqXX1mdW5jdGlvbiB2KEksRCl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhJWzBdLURbMF0sMikrTWF0aC5wb3coSVsxXS1EWzFdLDIpKStNYXRoLnNxcnQoTWF0aC5wb3coSVsyXS1EWzJdLDIpK01hdGgucG93KElbM10tRFszXSwyKSl9ZnVuY3Rpb24gUChJLEQpe3ZhciBSPUlbMF0sQz1JWzJdLGo9SVs0XSwkPUlbNl0sSD1JWzFdLEo9SVszXSxxPUlbNV0sRj1JWzddLEc9RFswXSxaPURbMl0sdHQ9RFs0XSxldD1EWzZdLGl0PURbMV0saz1EWzNdLGh0PURbNV0sZnQ9RFs3XTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KEctUiwyKStNYXRoLnBvdyhpdC1ILDIpKStNYXRoLnNxcnQoTWF0aC5wb3coWi1DLDIpK01hdGgucG93KGstSiwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KHR0LWosMikrTWF0aC5wb3coaHQtcSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KGV0LSQsMikrTWF0aC5wb3coZnQtRiwyKSl9ZnVuY3Rpb24gaShJLEQpe3ZhciBSPWEoSS5sZW5ndGgpLEM9W107Ui5mb3JFYWNoKGZ1bmN0aW9uKCQpe3ZhciBIPTAsSj0wOyQuZm9yRWFjaChmdW5jdGlvbihxKXtIKz1QKElbcV0sRFtKKytdKX0pLEMucHVzaCh7aW5kZXg6JCxkaXN0YW5jZTpIfSl9KSxDLnNvcnQoZnVuY3Rpb24oJCxIKXtyZXR1cm4gJC5kaXN0YW5jZS1ILmRpc3RhbmNlfSk7dmFyIGo9W107cmV0dXJuIENbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbigkKXtqLnB1c2goSVskXSl9KSxqfWZ1bmN0aW9uIHUoSSxEKXt2YXIgUj1oKEkubGVuZ3RoKSxDPVtdO1IuZm9yRWFjaChmdW5jdGlvbigkKXt2YXIgSD0wOyQuZm9yRWFjaChmdW5jdGlvbihKKXtIKz12KE8oSVtKXSksTyhEW0pdKSl9KSxDLnB1c2goe2luZGV4OiQsZGlzdGFuY2U6SH0pfSksQy5zb3J0KGZ1bmN0aW9uKCQsSCl7cmV0dXJuICQuZGlzdGFuY2UtSC5kaXN0YW5jZX0pO3ZhciBqPVtdO3JldHVybiBDWzBdLmluZGV4LmZvckVhY2goZnVuY3Rpb24oJCl7ai5wdXNoKElbJF0pfSksan1mdW5jdGlvbiBhKEkpe2Zvcih2YXIgRD1bXSxSPTA7UjxJO1IrKyl7Zm9yKHZhciBDPVtdLGo9MDtqPEk7aisrKXt2YXIgJD1qK1I7JD5JLTEmJigkLT1JKSxDWyRdPWp9RC5wdXNoKEMpfXJldHVybiBEfWZ1bmN0aW9uIGgoSSl7Zm9yKHZhciBEPVtdLFI9MDtSPEk7UisrKUQucHVzaChSKTtyZXR1cm4gYihEKX1mdW5jdGlvbiBiKEkpe3ZhciBEPVtdLFI9W107ZnVuY3Rpb24gQyhqKXt2YXIgJCxIO2ZvcigkPTA7JDxqLmxlbmd0aDskKyspSD1qLnNwbGljZSgkLDEpWzBdLFIucHVzaChIKSxqLmxlbmd0aD09MCYmRC5wdXNoKFIuc2xpY2UoKSksQyhqKSxqLnNwbGljZSgkLDAsSCksUi5wb3AoKTtyZXR1cm4gRH1yZXR1cm4gQyhJKX12YXIgRT17fTtFLnBhcnNlcj15LEUubGVycEN1cnZlPWZ1bmN0aW9uKEksRCxSKXtyZXR1cm4gRS5sZXJwUG9pbnRzKElbMF0sSVsxXSxEWzBdLERbMV0sUikuY29uY2F0KEUubGVycFBvaW50cyhJWzJdLElbM10sRFsyXSxEWzNdLFIpKS5jb25jYXQoRS5sZXJwUG9pbnRzKElbNF0sSVs1XSxEWzRdLERbNV0sUikpLmNvbmNhdChFLmxlcnBQb2ludHMoSVs2XSxJWzddLERbNl0sRFs3XSxSKSl9LEUubGVycFBvaW50cz1mdW5jdGlvbihJLEQsUixDLGope3JldHVybltJKyhSLUkpKmosRCsoQy1EKSpqXX0sRS5xMmI9ZnVuY3Rpb24oSSxELFIsQyxqLCQpe3JldHVybltJLEQsKEkrMipSKS8zLChEKzIqQykvMywoaisyKlIpLzMsKCQrMipDKS8zLGosJF19LEUucGF0aDJzaGFwZXM9ZnVuY3Rpb24oSSl7Zm9yKHZhciBEPUUucGFyc2VyKEkpLFI9MCxDPTAsaj0wLCQ9RC5sZW5ndGgsSD1bXSxKPW51bGwscT12b2lkIDAsRj12b2lkIDAsRz12b2lkIDAsWj12b2lkIDAsdHQ9dm9pZCAwLGV0PXZvaWQgMCxpdD12b2lkIDA7ajwkO2orKyl7dmFyIGs9RFtqXSxodD1rWzBdLGZ0PURbai0xXTtzd2l0Y2goaHQpe2Nhc2UibSI6dHQ9SC5sZW5ndGgsSFt0dF09W10sSj1IW3R0XSxSPVIra1sxXSxDPUMra1syXTticmVhaztjYXNlIk0iOnR0PUgubGVuZ3RoLEhbdHRdPVtdLEo9SFt0dF0sUj1rWzFdLEM9a1syXTticmVhaztjYXNlImwiOkoucHVzaChbUixDLFIsQyxSLEMsUitrWzFdLEMra1syXV0pLFIrPWtbMV0sQys9a1syXTticmVhaztjYXNlIkwiOkoucHVzaChbUixDLGtbMV0sa1syXSxrWzFdLGtbMl0sa1sxXSxrWzJdXSksUj1rWzFdLEM9a1syXTticmVhaztjYXNlImgiOkoucHVzaChbUixDLFIsQyxSLEMsUitrWzFdLENdKSxSKz1rWzFdO2JyZWFrO2Nhc2UiSCI6Si5wdXNoKFtSLEMsa1sxXSxDLGtbMV0sQyxrWzFdLENdKSxSPWtbMV07YnJlYWs7Y2FzZSJ2IjpKLnB1c2goW1IsQyxSLEMsUixDLFIsQytrWzFdXSksQys9a1sxXTticmVhaztjYXNlIlYiOkoucHVzaChbUixDLFIsa1sxXSxSLGtbMV0sUixrWzFdXSksQz1rWzFdO2JyZWFrO2Nhc2UiQyI6Si5wdXNoKFtSLEMsa1sxXSxrWzJdLGtbM10sa1s0XSxrWzVdLGtbNl1dKSxSPWtbNV0sQz1rWzZdO2JyZWFrO2Nhc2UiUyI6ZnRbMF09PT0iQyJ8fGZ0WzBdPT09ImMiP0oucHVzaChbUixDLFIrZnRbNV0tZnRbM10sQytmdFs2XS1mdFs0XSxrWzFdLGtbMl0sa1szXSxrWzRdXSk6KGZ0WzBdPT09IlMifHxmdFswXT09PSJzIikmJkoucHVzaChbUixDLFIrZnRbM10tZnRbMV0sQytmdFs0XS1mdFsyXSxrWzFdLGtbMl0sa1szXSxrWzRdXSksUj1rWzNdLEM9a1s0XTticmVhaztjYXNlImMiOkoucHVzaChbUixDLFIra1sxXSxDK2tbMl0sUitrWzNdLEMra1s0XSxSK2tbNV0sQytrWzZdXSksUj1SK2tbNV0sQz1DK2tbNl07YnJlYWs7Y2FzZSJzIjpmdFswXT09PSJDInx8ZnRbMF09PT0iYyI/Si5wdXNoKFtSLEMsUitmdFs1XS1mdFszXSxDK2Z0WzZdLWZ0WzRdLFIra1sxXSxDK2tbMl0sUitrWzNdLEMra1s0XV0pOihmdFswXT09PSJTInx8ZnRbMF09PT0icyIpJiZKLnB1c2goW1IsQyxSK2Z0WzNdLWZ0WzFdLEMrZnRbNF0tZnRbMl0sUitrWzFdLEMra1syXSxSK2tbM10sQytrWzRdXSksUj1SK2tbM10sQz1DK2tbNF07YnJlYWs7Y2FzZSJhIjpldD1mKHtyeDprWzFdLHJ5OmtbMl0scHg6UixweTpDLHhBeGlzUm90YXRpb246a1szXSxsYXJnZUFyY0ZsYWc6a1s0XSxzd2VlcEZsYWc6a1s1XSxjeDpSK2tbNl0sY3k6QytrWzddfSksaXQ9ZXRbZXQubGVuZ3RoLTFdLGV0LmZvckVhY2goZnVuY3Rpb24oQixXKXtXPT09MD9KLnB1c2goW1IsQyxCLngxLEIueTEsQi54MixCLnkyLEIueCxCLnldKTpKLnB1c2goW2V0W1ctMV0ueCxldFtXLTFdLnksQi54MSxCLnkxLEIueDIsQi55MixCLngsQi55XSl9KSxSPWl0LngsQz1pdC55O2JyZWFrO2Nhc2UiQSI6ZXQ9Zih7cng6a1sxXSxyeTprWzJdLHB4OlIscHk6Qyx4QXhpc1JvdGF0aW9uOmtbM10sbGFyZ2VBcmNGbGFnOmtbNF0sc3dlZXBGbGFnOmtbNV0sY3g6a1s2XSxjeTprWzddfSksaXQ9ZXRbZXQubGVuZ3RoLTFdLGV0LmZvckVhY2goZnVuY3Rpb24oQixXKXtXPT09MD9KLnB1c2goW1IsQyxCLngxLEIueTEsQi54MixCLnkyLEIueCxCLnldKTpKLnB1c2goW2V0W1ctMV0ueCxldFtXLTFdLnksQi54MSxCLnkxLEIueDIsQi55MixCLngsQi55XSl9KSxSPWl0LngsQz1pdC55O2JyZWFrO2Nhc2UiUSI6Si5wdXNoKEUucTJiKFIsQyxrWzFdLGtbMl0sa1szXSxrWzRdKSksUj1rWzNdLEM9a1s0XTticmVhaztjYXNlInEiOkoucHVzaChFLnEyYihSLEMsUitrWzFdLEMra1syXSxrWzNdK1Isa1s0XStDKSksUis9a1szXSxDKz1rWzRdO2JyZWFrO2Nhc2UiVCI6ZnRbMF09PT0iUSJ8fGZ0WzBdPT09InEiPyhHPVIrZnRbM10tZnRbMV0sWj1DK2Z0WzRdLWZ0WzJdLEoucHVzaChFLnEyYihSLEMsRyxaLGtbMV0sa1syXSkpKTooZnRbMF09PT0iVCJ8fGZ0WzBdPT09InQiKSYmKEoucHVzaChFLnEyYihSLEMsUitSLUcsQytDLVosa1sxXSxrWzJdKSksRz1SK1ItRyxaPUMrQy1aKSxSPWtbMV0sQz1rWzJdO2JyZWFrO2Nhc2UidCI6ZnRbMF09PT0iUSJ8fGZ0WzBdPT09InEiPyhHPVIrZnRbM10tZnRbMV0sWj1DK2Z0WzRdLWZ0WzJdLEoucHVzaChFLnEyYihSLEMsRyxaLFIra1sxXSxDK2tbMl0pKSk6KGZ0WzBdPT09IlQifHxmdFswXT09PSJ0IikmJihKLnB1c2goRS5xMmIoUixDLFIrUi1HLEMrQy1aLFIra1sxXSxDK2tbMl0pKSxHPVIrUi1HLFo9QytDLVopLFIrPWtbMV0sQys9a1syXTticmVhaztjYXNlIloiOnE9SlswXVswXSxGPUpbMF1bMV0sSi5wdXNoKFtSLEMscSxGLHEsRixxLEZdKTticmVhaztjYXNlInoiOnE9SlswXVswXSxGPUpbMF1bMV0sSi5wdXNoKFtSLEMscSxGLHEsRixxLEZdKTticmVha319cmV0dXJuIEh9LEUuX3VwQ3VydmVzPWZ1bmN0aW9uKEksRCl7Zm9yKHZhciBSPTAsQz0wLGo9SS5sZW5ndGg7UjxEO1IrKylJLnB1c2goSVtDXS5zbGljZSgwKSksQysrLEM+ai0xJiYoQy09ail9O2Z1bmN0aW9uIEEoSSxELFIsQyxqLCQsSCxKLHEpe3JldHVybntsZWZ0OkwoSSxELFIsQyxqLCQsSCxKLHEpLHJpZ2h0OkwoSCxKLGosJCxSLEMsSSxELDEtcSwhMCl9fWZ1bmN0aW9uIEwoSSxELFIsQyxqLCQsSCxKLHEsRil7dmFyIEc9KFItSSkqcStJLFo9KEMtRCkqcStELHR0PShqLVIpKnErUixldD0oJC1DKSpxK0MsaXQ9KEgtaikqcStqLGs9KEotJCkqcSskLGh0PSh0dC1HKSpxK0csZnQ9KGV0LVopKnErWixCPShpdC10dCkqcSt0dCxXPShrLWV0KSpxK2V0LFY9KEItaHQpKnEraHQsWD0oVy1mdCkqcStmdDtyZXR1cm4gRj9bVixYLGh0LGZ0LEcsWixJLERdOltJLEQsRyxaLGh0LGZ0LFYsWF19RS5fc3BsaXRDdXJ2ZXM9ZnVuY3Rpb24oSSxEKXtmb3IodmFyIFI9MCxDPTA7UjxEO1IrKyl7dmFyIGo9SVtDXSwkPUEoalswXSxqWzFdLGpbMl0salszXSxqWzRdLGpbNV0sals2XSxqWzddLC41KTtJLnNwbGljZShDLDEpLEkuc3BsaWNlKEMsMCwkLmxlZnQsJC5yaWdodCksQys9MixDPj1JLmxlbmd0aC0xJiYoQz0wKX19O2Z1bmN0aW9uIFMoSSxEKXtmb3IodmFyIFI9ZnVuY3Rpb24oJCl7dmFyIEg9SVtJLmxlbmd0aC0xXSxKPVtdO0guZm9yRWFjaChmdW5jdGlvbihxKXtKLnB1c2gocS5zbGljZSgwKSl9KSxJLnB1c2goSil9LEM9MDtDPEQ7QysrKVIoKX1yZXR1cm4gRS5sZXJwPWZ1bmN0aW9uKEksRCxSKXtyZXR1cm4gRS5fbGVycChFLnBhdGgyc2hhcGVzKEkpLEUucGF0aDJzaGFwZXMoRCksUil9LEUuTUlNX0NVUlZFU19DT1VOVD0xMDAsRS5fcHJlcHJvY2Vzc2luZz1mdW5jdGlvbihJLEQpe3ZhciBSPUkubGVuZ3RoLEM9RC5sZW5ndGgsaj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEkpKSwkPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoRCkpO3JldHVybiBSPkM/UygkLFItQyk6UjxDJiZTKGosQy1SKSxqPXUoaiwkKSxqLmZvckVhY2goZnVuY3Rpb24oSCxKKXt2YXIgcT1ILmxlbmd0aCxGPSRbSl0ubGVuZ3RoO3E+Rj9xPEUuTUlNX0NVUlZFU19DT1VOVD8oRS5fc3BsaXRDdXJ2ZXMoSCxFLk1JTV9DVVJWRVNfQ09VTlQtcSksRS5fc3BsaXRDdXJ2ZXMoJFtKXSxFLk1JTV9DVVJWRVNfQ09VTlQtRikpOkUuX3NwbGl0Q3VydmVzKCRbSl0scS1GKTpxPEYmJihGPEUuTUlNX0NVUlZFU19DT1VOVD8oRS5fc3BsaXRDdXJ2ZXMoSCxFLk1JTV9DVVJWRVNfQ09VTlQtcSksRS5fc3BsaXRDdXJ2ZXMoJFtKXSxFLk1JTV9DVVJWRVNfQ09VTlQtRikpOkUuX3NwbGl0Q3VydmVzKEgsRi1xKSl9KSxqLmZvckVhY2goZnVuY3Rpb24oSCxKKXtqW0pdPWkoSCwkW0pdKX0pLFtqLCRdfSxFLl9sZXJwPWZ1bmN0aW9uKEksRCxSKXt2YXIgQz1bXTtyZXR1cm4gSS5mb3JFYWNoKGZ1bmN0aW9uKGosJCl7dmFyIEg9W107ai5mb3JFYWNoKGZ1bmN0aW9uKEoscSl7SC5wdXNoKEUubGVycEN1cnZlKEosRFskXVtxXSxSKSl9KSxDLnB1c2goSCl9KSxDfSxFLmFuaW1hdGU9ZnVuY3Rpb24oSSl7dmFyIEQ9RS5wYXRoMnNoYXBlcyhJLmZyb20pLFI9RS5wYXRoMnNoYXBlcyhJLnRvKSxDPUUuX3ByZXByb2Nlc3NpbmcoRCxSKSxqPW5ldyBEYXRlLCQ9SS5lbmR8fGZ1bmN0aW9uKCl7fSxIPUkucHJvZ3Jlc3N8fGZ1bmN0aW9uKCl7fSxKPUkuYmVnaW58fGZ1bmN0aW9uKCl7fSxxPUkuZWFzaW5nfHxmdW5jdGlvbihldCl7cmV0dXJuIGV0fSxGPW51bGwsRz1udWxsLFo9SS50aW1lO0ooRCk7dmFyIHR0PWZ1bmN0aW9uIGV0KCl7dmFyIGl0PW5ldyBEYXRlLWo7aWYoaXQ+PVope0c9UixIKEcsMSksJChHKSxjYW5jZWxBbmltYXRpb25GcmFtZShGKTtyZXR1cm59dmFyIGs9cShpdC9aKTtHPUUuX2xlcnAoQ1swXSxDWzFdLGspLEgoRyxrKSxGPXJlcXVlc3RBbmltYXRpb25GcmFtZShldCl9O3R0KCl9LEV9KX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoNzEpLG49dCgyMjEpLHM9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtjbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGcpe3N1cGVyKGcpLHRoaXNbbF0oe2Q6IiIsbm9ybWFsaXplOiExLGZpbGxDb2xvcjp2b2lkIDAsZmlsbFJ1bGU6Im5vbnplcm8iLHN0cm9rZUNvbG9yOnZvaWQgMCxsaW5lV2lkdGg6MSxsaW5lSm9pbjoibWl0ZXIiLGxpbmVDYXA6ImJ1dHQiLHJvdW5kU2VnbWVudHM6MjAsbGluZURhc2g6dm9pZCAwLGxpbmVEYXNoT2Zmc2V0OjAsbWl0ZXJMaW1pdDoxMCx0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMCxjbGlwUGF0aDp2b2lkIDB9KX1nZXQgZCgpe3JldHVybiB0aGlzW29dKCJkIil9c2V0IGQoZyl7dGhpc1tjXSgiZCIsZyl9Z2V0IG5vcm1hbGl6ZSgpe3JldHVybiB0aGlzW29dKCJub3JtYWxpemUiKX1zZXQgbm9ybWFsaXplKGcpe3RoaXNbY10oIm5vcm1hbGl6ZSIsISFnKX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbb10oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IoZyl7dGhpc1tjXSgiZmlsbENvbG9yIixPYmplY3Qobi5wYXJzZUNvbG9yKShnKSl9Z2V0IGZpbGxSdWxlKCl7cmV0dXJuIHRoaXNbb10oImZpbGxSdWxlIil9c2V0IGZpbGxSdWxlKGcpe2lmKGchPW51bGwmJmchPT0ibm9uemVybyImJmchPT0iZXZlbm9kZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaWxsIHJ1bGUuIik7dGhpc1tjXSgiZmlsbFJ1bGUiLGcpfWdldCBzdHJva2VDb2xvcigpe3JldHVybiB0aGlzW29dKCJzdHJva2VDb2xvciIpfXNldCBzdHJva2VDb2xvcihnKXt0aGlzW2NdKCJzdHJva2VDb2xvciIsT2JqZWN0KG4ucGFyc2VDb2xvcikoZykpfWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tvXSgibGluZVdpZHRoIil9c2V0IGxpbmVXaWR0aChnKXt0aGlzW2NdKCJsaW5lV2lkdGgiLE9iamVjdChzLnRvTnVtYmVyKShnKSl9Z2V0IGxpbmVKb2luKCl7cmV0dXJuIHRoaXNbb10oImxpbmVKb2luIil9c2V0IGxpbmVKb2luKGcpe2lmKGchPW51bGwmJmchPT0ibWl0ZXIiJiZnIT09ImJldmVsIiYmZyE9PSJyb3VuZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lSm9pbiB0eXBlLiIpO3RoaXNbY10oImxpbmVKb2luIixnKX1nZXQgbGluZUNhcCgpe3JldHVybiB0aGlzW29dKCJsaW5lQ2FwIil9c2V0IGxpbmVDYXAoZyl7aWYoZyE9bnVsbCYmZyE9PSJidXR0IiYmZyE9PSJzcXVhcmUiJiZnIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVDYXAgdHlwZS4iKTt0aGlzW2NdKCJsaW5lQ2FwIixnKX1nZXQgbGluZURhc2goKXtyZXR1cm4gdGhpc1tvXSgibGluZURhc2giKX1zZXQgbGluZURhc2goZyl7Zz1PYmplY3Qocy50b0FycmF5KShnLCEwKSxnIT1udWxsJiYhQXJyYXkuaXNBcnJheShnKSYmKGc9W2ddKSx0aGlzW2NdKCJsaW5lRGFzaCIsZz9nLm1hcChzLnRvTnVtYmVyKTpudWxsKX1nZXQgbGluZURhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1tvXSgibGluZURhc2hPZmZzZXQiKX1zZXQgbGluZURhc2hPZmZzZXQoZyl7dGhpc1tjXSgibGluZURhc2hPZmZzZXQiLE9iamVjdChzLnRvTnVtYmVyKShnKSl9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tvXSgibWl0ZXJMaW1pdCIpfXNldCBtaXRlckxpbWl0KGcpe3RoaXNbY10oIm1pdGVyTGltaXQiLE9iamVjdChzLnRvTnVtYmVyKShnKSl9Z2V0IHJvdW5kU2VnbWVudHMoKXtyZXR1cm4gdGhpc1tvXSgicm91bmRTZWdtZW50cyIpfXNldCByb3VuZFNlZ21lbnRzKGcpe3RoaXNbY10oInJvdW5kU2VnbWVudHMiLGcpfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbb10oInRleHR1cmUiKX1zZXQgdGV4dHVyZShnKXt0aGlzW2NdKCJ0ZXh0dXJlIixnKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1tvXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoZyl7dGhpc1tjXSgidGV4dHVyZVJlY3QiLGcpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbb10oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChnKXt0aGlzW2NdKCJzb3VyY2VSZWN0IixnKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW29dKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoZyl7dGhpc1tjXSgidGV4dHVyZVJlcGVhdCIsISFnKX1nZXQgY2xpcFBhdGgoKXtyZXR1cm4gdGhpc1tvXSgiY2xpcFBhdGgiKX1zZXQgY2xpcFBhdGgoZyl7dGhpc1tjXSgiY2xpcFBhdGgiLGcpfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIyNiksbj10KDIxMykscz10KDIzMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwobyxmLHgpe3JldHVybiBmIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sZix7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bZl09eCxvfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3dpZHRoOmYsaGVpZ2h0Onh9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gZj4wJiZ4PjAmJnN1cGVyLmlzVmlzaWJsZX19bChjLCJBdHRyIixzLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywicmVjdCIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIHI9dCgyMjgpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIGYoZyl7Y29uc3R7d2lkdGg6eSxoZWlnaHQ6bX09ZztyZXR1cm5gTTAgMEwke3l9IDBMJHt5fSAke219TDAgJHttfVpgfWNsYXNzIHggZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tzXSh7d2lkdGg6MCxoZWlnaHQ6MH0pLHRoaXNbb10oInNpemUiKX1nZXQgZCgpe3JldHVybiB0aGlzW2NdKCJkIil9c2V0IGQoeSl7fWdldCB3aWR0aCgpe3JldHVybiB0aGlzW2NdKCJ3aWR0aCIpfXNldCB3aWR0aCh5KXtpZih5PU9iamVjdChuLnRvTnVtYmVyKSh5KSx0aGlzW2xdKCJ3aWR0aCIseSkpe2NvbnN0IG09Zih0aGlzKTt0aGlzW2xdKCJkIixtKX19Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzW2NdKCJoZWlnaHQiKX1zZXQgaGVpZ2h0KHkpe2lmKHk9T2JqZWN0KG4udG9OdW1iZXIpKHkpLHRoaXNbbF0oImhlaWdodCIseSkpe2NvbnN0IG09Zih0aGlzKTt0aGlzW2xdKCJkIixtKX19Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUoeSl7eT1PYmplY3Qobi50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpcy53aWR0aD15WzBdLHRoaXMuaGVpZ2h0PXlbMV19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxzPXQoMjM1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChvLGYseCl7cmV0dXJuIGYgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxmLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tmXT14LG99Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6Zn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmWzBdPjAmJmZbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX1sKGMsIkF0dHIiLHMuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJ0cmlhbmdsZSIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLHM9dCgyMzMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKG8sZix4KXtyZXR1cm4gZiBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGYse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2ZdPXgsb31jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtwb2ludHM6Zn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmLmxlbmd0aD4wJiZzdXBlci5pc1Zpc2libGV9fWwoYywiQXR0ciIscy5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInBvbHlsaW5lIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDIyOCksbj10KDcyKSxzPXQoMjM0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGY9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24geCh5KXtjb25zdHtwb2ludHM6bSxzbW9vdGg6VCxzbW9vdGhSYW5nZTpPLGNsb3NlOnZ9PXksUD1bXTtmb3IobGV0IHU9MDt1PG0ubGVuZ3RoO3UrPTIpUC5wdXNoKFttW3VdLG1bdSsxXV0pO2xldCBpPSIiO3JldHVybiBUP2k9T2JqZWN0KHMubWFrZVNtb290aEN1cnZlTGluZSkoUCxPKTpQLmxlbmd0aCYmKGk9YE0ke1AubWFwKHU9PnUuam9pbigiICIpKS5qb2luKCJMIil9YCksaSYmdiYmKGkrPSJaIiksaX1jbGFzcyBnIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKG0pe3N1cGVyKG0pLHRoaXNbbF0oe3BvaW50czpbXSxzbW9vdGg6ITEsc21vb3RoUmFuZ2U6WzBdLGNsb3NlVHlwZToibm9uZSJ9KSx0aGlzW2ZdKCJjbG9zZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbb10oImQiKX1zZXQgZChtKXt9Z2V0IGNsb3NlKCl7cmV0dXJuIHRoaXMuY2xvc2VUeXBlIT09Im5vbmUifXNldCBjbG9zZShtKXttPW0/Im5vcm1hbCI6Im5vbmUiLHRoaXMuY2xvc2VUeXBlPW19Z2V0IGNsb3NlVHlwZSgpe3JldHVybiB0aGlzW29dKCJjbG9zZVR5cGUiKX1zZXQgY2xvc2VUeXBlKG0pe2lmKG0hPW51bGwmJm0hPT0ibm9uZSImJm0hPT0ibm9ybWFsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNsb3NlVHlwZSB0eXBlLiIpO2lmKHRoaXNbY10oImNsb3NlVHlwZSIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IHNtb290aCgpe3JldHVybiB0aGlzW29dKCJzbW9vdGgiKX1zZXQgc21vb3RoKG0pe2lmKHRoaXNbY10oInNtb290aCIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IHNtb290aFJhbmdlKCl7cmV0dXJuIHRoaXNbb10oInNtb290aFJhbmdlIil9c2V0IHNtb290aFJhbmdlKG0pe2lmKG0mJiFBcnJheS5pc0FycmF5KG0pJiYobT1bbV0pLHRoaXNbY10oInNtb290aFJhbmdlIixtKSYmdGhpcy5zbW9vdGgpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IHBvaW50cygpe3JldHVybiB0aGlzW29dKCJwb2ludHMiKX1zZXQgcG9pbnRzKG0pe2lmKG09T2JqZWN0KG4udG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKSYmKG09bS5yZWR1Y2UoKFQsTyk9PkFycmF5LmlzQXJyYXkoTyk/Wy4uLlQsLi4uTy5tYXAodj0+T2JqZWN0KG4udG9OdW1iZXIpKHYpKV06Wy4uLlQsT2JqZWN0KG4udG9OdW1iZXIpKE8pXSxbXSkpLHRoaXNbY10oInBvaW50cyIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwibWFrZVNtb290aEN1cnZlTGluZSIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG4scz1bMF0pe2Z1bmN0aW9uIGwoZix4PS4xNjgsZz0uMTY4KXtsZXQgeSxtLFQsTztpZigobltmXS54PT09bltmKzFdLnh8fG5bZl0ueT09PW5bZisxXS55KSYmKHg9MCxnPTApLGY8MT8oeT1uWzBdLngrKG5bMV0ueC1uWzBdLngpKngsbT1uWzBdLnkrKG5bMV0ueS1uWzBdLnkpKngpOih5PW5bZl0ueCsobltmKzFdLngtbltmLTFdLngpKngsbT1uW2ZdLnkrKG5bZisxXS55LW5bZi0xXS55KSp4KSxmPm4ubGVuZ3RoLTMpe2NvbnN0IHY9bi5sZW5ndGgtMTtUPW5bdl0ueC0oblt2XS54LW5bdi0xXS54KSpnLE89blt2XS55LShuW3ZdLnktblt2LTFdLnkpKmd9ZWxzZSBUPW5bZisxXS54LShuW2YrMl0ueC1uW2ZdLngpKmcsTz1uW2YrMV0ueS0obltmKzJdLnktbltmXS55KSpnO3JldHVyblt7eDp5LHk6bX0se3g6VCx5Ok99XX1uPW4ubWFwKChbZix4XSk9Pih7eDpmLHk6eH0pKTtsZXQgYz0iIixvPTA7cmV0dXJuIG4uZm9yRWFjaCgoZix4KT0+e2lmKHg9PT0wKWMrPWBNJHtmLnh9ICR7Zi55fWA7ZWxzZXtmb3IoO3g+c1tvXTspbysrO2lmKG8lMil7Y29uc3RbZyx5XT1sKHgtMSk7Yys9YEMke1tnLngsZy55LHkueCx5LnksZi54LGYueV0uam9pbigiICIpfWB9ZWxzZSBjKz1gTCR7Zi54fSAke2YueX1gfX0pLGN9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHgpe2NvbnN0W2cseV09eC5zaWRlcztsZXQgbT14LmFuZ2xlJTM2MDtyZXR1cm4gbTwwJiYobSs9MzYwKSxtPU1hdGguUEkqbS8xODAsWzAsMCxnLDAseSpNYXRoLmNvcyhtKSx5Kk1hdGguc2luKG0pXX1jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGcpe3N1cGVyKGcpLHRoaXNbc10oe3NpZGVzOlswLDBdLGFuZ2xlOjYwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZyl7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW2NdKCJzaWRlcyIpfXNldCBzaWRlcyhnKXtpZihnPU9iamVjdChuLnRvQXJyYXkpKGcsITApLGchPW51bGwmJiFBcnJheS5pc0FycmF5KGcpJiYoZz1bZyxnXSksdGhpc1tsXSgic2lkZXMiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW2NdKCJhbmdsZSIpfXNldCBhbmdsZShnKXtpZihnPU9iamVjdChuLnRvTnVtYmVyKShnKSx0aGlzW2xdKCJhbmdsZSIsZykpe2NvbnN0IHk9byh0aGlzKTtzdXBlci5wb2ludHM9eX19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxzPXQoMjM3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChvLGYseCl7cmV0dXJuIGYgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxmLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tmXT14LG99Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6Zn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmWzBdPjAmJmZbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX1sKGMsIkF0dHIiLHMuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJwYXJhbGxlbCIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHgpe2NvbnN0W2cseV09eC5zaWRlcztsZXQgbT14LmFuZ2xlJTM2MDttPDAmJihtKz0zNjApLG09TWF0aC5QSSptLzE4MDtjb25zdCBUPXkqTWF0aC5jb3MobSksTz15Kk1hdGguc2luKG0pO3JldHVyblswLDAsZywwLFQrZyxPLFQsT119Y2xhc3MgZiBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihnKXtzdXBlcihnKSx0aGlzW3NdKHtzaWRlczpbMCwwXSxhbmdsZTo5MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGcpe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1tjXSgic2lkZXMiKX1zZXQgc2lkZXMoZyl7aWYoZz1PYmplY3Qobi50b0FycmF5KShnLCEwKSxnIT1udWxsJiYhQXJyYXkuaXNBcnJheShnKSYmKGc9W2csZ10pLHRoaXNbbF0oInNpZGVzIixnKSl7Y29uc3QgeT1vKHRoaXMpO3N1cGVyLnBvaW50cz15fX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1tjXSgiYW5nbGUiKX1zZXQgYW5nbGUoZyl7aWYoZz1PYmplY3Qobi50b051bWJlcikoZyksdGhpc1tsXSgiYW5nbGUiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIzMiksbj10KDIxMykscz10KDIzOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwobyxmLHgpe3JldHVybiBmIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sZix7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bZl09eCxvfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7fWwoYywiQXR0ciIscy5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInJlZ3VsYXIiKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMjMzKSxuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBzPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gbyh4KXtjb25zdHtlZGdlczpnLHJhZGl1czp5LG9mZnNldEFuZ2xlOm19PXgsVD1NYXRoLlBJKm0vMTgwLS41Kk1hdGguUEk7aWYoZzwzfHx5PD0wKXJldHVybltdO2NvbnN0IE89W107Zm9yKGxldCB2PTA7djxnO3YrKyl7Y29uc3QgUD12KjIqTWF0aC5QSS9nK1QsaT15Kk1hdGguY29zKFApLHU9eSpNYXRoLnNpbihQKTtPLnB1c2goaSx1KX1yZXR1cm4gT31jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGcpe3N1cGVyKGcpLHRoaXNbc10oe2VkZ2VzOjMscmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGcpe31nZXQgZWRnZXMoKXtyZXR1cm4gdGhpc1tjXSgiZWRnZXMiKX1zZXQgZWRnZXMoZyl7aWYoZz1PYmplY3Qobi50b051bWJlcikoZyksdGhpc1tsXSgiZWRnZXMiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCByYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgicmFkaXVzIil9c2V0IHJhZGl1cyhnKXtpZihnPU9iamVjdChuLnRvTnVtYmVyKShnKSx0aGlzW2xdKCJyYWRpdXMiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW2NdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShnKXtpZihnPU9iamVjdChuLnRvTnVtYmVyKShnKSx0aGlzW2xdKCJvZmZzZXRBbmdsZSIsZykpe2NvbnN0IHk9byh0aGlzKTtzdXBlci5wb2ludHM9eX19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxzPXQoMjQxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChvLGYseCl7cmV0dXJuIGYgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxmLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tmXT14LG99Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHt9bChjLCJBdHRyIixzLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywic3RhciIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHgpe2NvbnN0e2FuZ2xlczpnLGlubmVyUmFkaXVzOnksb3V0ZXJSYWRpdXM6bSxvZmZzZXRBbmdsZTpUfT14LE89TWF0aC5QSSpULzE4MC0uNSpNYXRoLlBJO2lmKGc8M3x8eTw9MHx8bTw9MClyZXR1cm5bXTtjb25zdCB2PVtdO2ZvcihsZXQgUD0wO1A8ZyoyO1ArKyl7Y29uc3QgaT1QKk1hdGguUEkvZytPLHU9UCUyP3k6bSxhPXUqTWF0aC5jb3MoaSksaD11Kk1hdGguc2luKGkpO3YucHVzaChhLGgpfXJldHVybiB2fWNsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZyl7c3VwZXIoZyksdGhpc1tzXSh7YW5nbGVzOjUsaW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhnKXt9Z2V0IGFuZ2xlcygpe3JldHVybiB0aGlzW2NdKCJhbmdsZXMiKX1zZXQgYW5nbGVzKGcpe2lmKGc9T2JqZWN0KG4udG9OdW1iZXIpKGcpLHRoaXNbbF0oImFuZ2xlcyIsZykpe2NvbnN0IHk9byh0aGlzKTtzdXBlci5wb2ludHM9eX19Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKGcpe2lmKGc9T2JqZWN0KG4udG9OdW1iZXIpKGcpLHRoaXNbbF0oImlubmVyUmFkaXVzIixnKSl7Y29uc3QgeT1vKHRoaXMpO3N1cGVyLnBvaW50cz15fX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoZyl7aWYoZz1PYmplY3Qobi50b051bWJlcikoZyksdGhpc1tsXSgib3V0ZXJSYWRpdXMiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKGcpe2c9T2JqZWN0KG4udG9BcnJheSkoZywhMCksQXJyYXkuaXNBcnJheShnKXx8KGc9W2csZ10pLHRoaXMuaW5uZXJSYWRpdXM9Z1swXSx0aGlzLm91dGVyUmFkaXVzPWdbMV19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbY10oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGcpe2lmKGc9T2JqZWN0KG4udG9OdW1iZXIpKGcpLHRoaXNbbF0oIm9mZnNldEFuZ2xlIixnKSl7Y29uc3QgeT1vKHRoaXMpO3N1cGVyLnBvaW50cz15fX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLHM9dCgyNDMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKG8sZix4KXtyZXR1cm4gZiBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGYse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2ZdPXgsb31jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtyYWRpdXNYOmYscmFkaXVzWTp4LHN0YXJ0QW5nbGU6ZyxlbmRBbmdsZTp5fT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGY+MCYmeD4wJiZnIT09eSYmc3VwZXIuaXNWaXNpYmxlfX1sKGMsIkF0dHIiLHMuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJlbGxpcHNlIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxzPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB4KHkpe2NvbnN0e3JhZGl1c1g6bSxyYWRpdXNZOlQsc3RhcnRBbmdsZTpPLGVuZEFuZ2xlOnYsZGlyZWN0aW9uOlAsY2xvc2VUeXBlOml9PXksdT1QPT09ImFuaXRjbG9ja3dpc2UiLGE9bmV3IHIuRmlndXJlMkQ7cmV0dXJuIGk9PT0ic2VjdG9yIiYmYS5tb3ZlVG8oMCwwKSxhLmVsbGlwc2UoMCwwLG0sVCwwLE1hdGguUEkqTy8xODAsTWF0aC5QSSp2LzE4MCx1KSxpIT09Im5vbmUiJiZhLmNsb3NlUGF0aCgpLGEucGF0aC5yZWR1Y2UoKEUsQSk9PkUrQS5qb2luKCIgIiksIiIpfWNsYXNzIGcgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IobSl7c3VwZXIobSksdGhpc1tsXSh7cmFkaXVzWDowLHJhZGl1c1k6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwLGRpcmVjdGlvbjoiY2xvY2t3aXNlIixjbG9zZVR5cGU6Im5vbmUifSksdGhpc1tmXSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW29dKCJkIil9c2V0IGQobSl7fWdldCByYWRpdXNYKCl7cmV0dXJuIHRoaXNbb10oInJhZGl1c1giKX1zZXQgcmFkaXVzWChtKXtpZihtPU9iamVjdChzLnRvTnVtYmVyKShtKSx0aGlzW2NdKCJyYWRpdXNYIixtKSl7Y29uc3QgVD14KHRoaXMpO3RoaXNbY10oImQiLFQpfX1nZXQgcmFkaXVzWSgpe3JldHVybiB0aGlzW29dKCJyYWRpdXNZIil9c2V0IHJhZGl1c1kobSl7aWYobT1PYmplY3Qocy50b051bWJlcikobSksdGhpc1tjXSgicmFkaXVzWSIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLnJhZGl1c1gsdGhpcy5yYWRpdXNZXX1zZXQgcmFkaXVzKG0pe209T2JqZWN0KHMudG9BcnJheSkobSwhMCksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMucmFkaXVzWD1tWzBdLHRoaXMucmFkaXVzWT1tWzFdfWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKG0pe209T2JqZWN0KHMudG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMuc3RhcnRBbmdsZT1tWzBdLHRoaXMuZW5kQW5nbGU9bVsxXX1nZXQgZGlyZWN0aW9uKCl7cmV0dXJuIHRoaXNbb10oImRpcmVjdGlvbiIpfXNldCBkaXJlY3Rpb24obSl7aWYobSE9bnVsbCYmbSE9PSJjbG9ja3dpc2UiJiZtIT09ImFudGljbG9ja3dpc2UiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZGlyZWN0aW9uIHR5cGUuIik7dGhpc1tjXSgiZGlyZWN0aW9uIixtKX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW29dKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUobSl7aWYobT1PYmplY3Qocy50b051bWJlcikobSksdGhpc1tjXSgic3RhcnRBbmdsZSIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbb10oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKG0pe2lmKG09T2JqZWN0KHMudG9OdW1iZXIpKG0pLHRoaXNbY10oImVuZEFuZ2xlIixtKSl7Y29uc3QgVD14KHRoaXMpO3RoaXNbY10oImQiLFQpfX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbb10oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUobSl7aWYobSE9bnVsbCYmbSE9PSJub25lIiYmbSE9PSJzZWN0b3IiJiZtIT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW2NdKCJjbG9zZVR5cGUiLG0pKXtjb25zdCBUPXgodGhpcyk7dGhpc1tjXSgiZCIsVCl9fX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDI0Miksbj10KDIxMykscz10KDI0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwobyxmLHgpe3JldHVybiBmIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sZix7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bZl09eCxvfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7fWwoYywiQXR0ciIscy5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsImFyYyIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIHI9dCgyNDMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIHMgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IHJhZGl1cygpe3JldHVybiBzdXBlci5yYWRpdXNYfXNldCByYWRpdXMoYyl7Yz1PYmplY3Qobi50b051bWJlcikoYyksc3VwZXIucmFkaXVzWD1jLHN1cGVyLnJhZGl1c1k9Y319fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLHM9dCgyNDcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKG8sZix4KXtyZXR1cm4gZiBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGYse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2ZdPXgsb31jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtpbm5lclJhZGl1czpmLG91dGVyUmFkaXVzOngsc3RhcnRBbmdsZTpnLGVuZEFuZ2xlOnl9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4oZj4wfHx4PjApJiZnIT09eSYmc3VwZXIuaXNWaXNpYmxlfX1sKGMsIkF0dHIiLHMuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJyaW5nIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxzPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB4KHkpe2xldHtpbm5lclJhZGl1czptLG91dGVyUmFkaXVzOlQsc3RhcnRBbmdsZTpPLGVuZEFuZ2xlOnZ9PXk7Y29uc3QgUD1uZXcgci5GaWd1cmUyRDtpZihPPU1hdGguUEkqTy8xODAsdj1NYXRoLlBJKnYvMTgwLG0+VCYmKFttLFRdPVtULG1dKSxtPD0wJiZQLm1vdmVUbygwLDApLFAuYXJjKDAsMCxULE8sdiwhMSksbT4wKXtjb25zdCBhPU1hdGguUEkqMjt2PE8mJih2PU8rYSsodi1PKSVhKSx2LU8+PWEmJih2PU8rYS0xZS02KSxQLmFyYygwLDAsbSx2LE8sITApfXJldHVybiBQLmNsb3NlUGF0aCgpLFAucGF0aC5yZWR1Y2UoKGEsaCk9PmEraC5qb2luKCIgIiksIiIpfWNsYXNzIGcgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IobSl7c3VwZXIobSksdGhpc1tsXSh7aW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjB9KSx0aGlzW2ZdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbb10oImQiKX1zZXQgZChtKXt9Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbb10oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKG0pe2lmKG09T2JqZWN0KHMudG9OdW1iZXIpKG0pLHRoaXNbY10oImlubmVyUmFkaXVzIixtKSl7Y29uc3QgVD14KHRoaXMpO3RoaXNbY10oImQiLFQpfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tvXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMobSl7aWYobT1PYmplY3Qocy50b051bWJlcikobSksdGhpc1tjXSgib3V0ZXJSYWRpdXMiLG0pKXtjb25zdCBUPXgodGhpcyk7dGhpc1tjXSgiZCIsVCl9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKG0pe209T2JqZWN0KHMudG9BcnJheSkobSwhMCksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMuaW5uZXJSYWRpdXM9bVswXSx0aGlzLm91dGVyUmFkaXVzPW1bMV19Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1tvXSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKG0pe2lmKG09T2JqZWN0KHMudG9OdW1iZXIpKG0pLHRoaXNbY10oInN0YXJ0QW5nbGUiLG0pKXtjb25zdCBUPXgodGhpcyk7dGhpc1tjXSgiZCIsVCl9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW29dKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZShtKXtpZihtPU9iamVjdChzLnRvTnVtYmVyKShtKSx0aGlzW2NdKCJlbmRBbmdsZSIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUobSl7bT1PYmplY3Qocy50b0FycmF5KShtKSxBcnJheS5pc0FycmF5KG0pfHwobT1bbSxtXSksdGhpcy5zdGFydEFuZ2xlPW1bMF0sdGhpcy5lbmRBbmdsZT1tWzFdfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgcj10KDEyKSxuPXQoMjE4KSxzPXQoMjE5KSxsPXQoMjQ5KSxjPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhPLHYsUCl7cmV0dXJuIHYgaW4gTz9PYmplY3QuZGVmaW5lUHJvcGVydHkoTyx2LHt2YWx1ZTpQLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6T1t2XT1QLE99Y29uc3QgZj1TeW1ib2woInRleHRJbWFnZSIpLHg9U3ltYm9sKCJ0ZXh0SW1hZ2VUYXNrIiksZz1TeW1ib2woInRleHR1cmVDb250ZXh0IikseT1TeW1ib2woInVwZGF0ZVRleHR1cmVSZWN0IiksbT1TeW1ib2woInRleHRDYW52YXMiKTtjbGFzcyBUIGV4dGVuZHMgcy5kZWZhdWx0e2NvbnN0cnVjdG9yKHY9e30pe3R5cGVvZiB2PT0ic3RyaW5nIiYmKHY9e3RleHQ6dn0pLHN1cGVyKHYpfWdldCBjb250ZW50U2l6ZSgpe2xldFt2LFBdPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOmksaGVpZ2h0OnV9PXRoaXMuYXR0cmlidXRlcztpZihpPT1udWxsfHx1PT1udWxsKXtjb25zdCBhPXRoaXNbZl07YSYmKGk9PW51bGwmJih2PWEucmVjdFsyXSksdT09bnVsbCYmKFA9YS5yZWN0WzNdKSl9cmV0dXJuW3YsUF19Z2V0IHRleHQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHQodil7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9dn1nZXQgdGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHRDb250ZW50KHYpe3RoaXMuYXR0cmlidXRlcy50ZXh0PXZ9Z2V0IHRleHRJbWFnZSgpe3JldHVybiB0aGlzW2ZdfHx7fX1nZXQgdGV4dEltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1t4XXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyh2KXtzdXBlci5kcmF3KHYpO2NvbnN0IFA9dGhpcy5tZXNoO2lmKFApe2NvbnN0IGk9dGhpc1tmXTtpZihpKXtsZXQgdT1QLnRleHR1cmU7aWYoIXV8fHRoaXNbZ10mJnRoaXNbZ10hPT10aGlzLnJlbmRlcmVyfHxpLm5lZWRzVXBkYXRlPyhpLm5lZWRzVXBkYXRlPSExLE9iamVjdChuLmRlbGV0ZVRleHR1cmUpKGkuaW1hZ2UsdGhpcy5yZW5kZXJlciksdT1PYmplY3Qobi5jcmVhdGVUZXh0dXJlKShpLmltYWdlLHRoaXMucmVuZGVyZXIpLHRoaXNbeV09ITApOnU9UC51bmlmb3Jtcy51X3RleFNhbXBsZXIsdGhpc1t5XSl7Y29uc3RbYSxoXT1pLnJlY3Quc2xpY2UoMiksW2IsRV09dGhpcy5jb250ZW50U2l6ZSxBPXRoaXMuYXR0cmlidXRlcy50ZXh0QWxpZ24sTD10aGlzLmF0dHJpYnV0ZXMudmVydGljYWxBbGlnbjtsZXQgUz0wO0E9PT0iY2VudGVyIj9TPShiLWEpLzI6KEE9PT0icmlnaHQifHxBPT09ImVuZCIpJiYoUz1iLWEpO2NvbnN0IEk9dGhpcy5hdHRyaWJ1dGVzLmZvbnRTaXplLEQ9dGhpcy5hdHRyaWJ1dGVzLmxpbmVIZWlnaHQ7bGV0IFI9MDtMPT09InRvcCI/Uj0oSS1EKS8yOkw9PT0iYm90dG9tIiYmKFI9KEQtSSkvMik7Y29uc3R7cGFkZGluZ0xlZnQ6QyxwYWRkaW5nVG9wOmp9PXRoaXMuYXR0cmlidXRlcyx7Ym9yZGVyV2lkdGg6JH09dGhpcy5hdHRyaWJ1dGVzO1MrPUMrJCxSKz1qKyQ7Y29uc3R7YW5jaG9yWDpILGFuY2hvclk6Sn09dGhpcy5hdHRyaWJ1dGVzO1MtPXRoaXMub2Zmc2V0U2l6ZVswXSpILFItPXRoaXMub2Zmc2V0U2l6ZVsxXSpKLFAuc2V0VGV4dHVyZSh1LHtyZWN0OltTLFIsYSxoXX0pLHRoaXNbeV09ITEsdGhpc1tnXT10aGlzLnJlbmRlcmVyfX19cmV0dXJuIHZ9b25Qcm9wZXJ0eUNoYW5nZSh2LFAsaSl7dj09PSJ0ZXh0Inx8dj09PSJmb250U2l6ZSJ8fHY9PT0iZm9udEZhbWlseSJ8fHY9PT0iZm9udFN0eWxlInx8dj09PSJmb250VmFyaWFudCJ8fHY9PT0iZm9udFdlaWdodCJ8fHY9PT0iZm9udFN0cmV0Y2gifHx2PT09ImxpbmVIZWlnaHQifHx2PT09InN0cm9rZUNvbG9yInx8dj09PSJmaWxsQ29sb3IifHx2PT09InN0cm9rZVdpZHRoIj90aGlzLnVwZGF0ZVRleHQoKTooKHY9PT0idGV4dEFsaWduInx8dj09PSJ2ZXJ0aWNhbEFsaWduIikmJih0aGlzW3ldPSEwKSxzdXBlci5vblByb3BlcnR5Q2hhbmdlKHYsUCxpKSl9dXBkYXRlQ29udG91cnMoKXtzdXBlci51cGRhdGVDb250b3VycygpLHRoaXNbeV09ITB9dXBkYXRlVGV4dCgpe3RoaXNbeF18fCh0aGlzW3hdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzW3hdPW51bGw7Y29uc3R7dGV4dDp2LGZvbnQ6UCxmaWxsQ29sb3I6aSxzdHJva2VDb2xvcjp1LHN0cm9rZVdpZHRoOmF9PXRoaXMuYXR0cmlidXRlcyxoPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtyZXR1cm4gdGhpc1ttXT10aGlzW21dfHxyLkVOVi5jcmVhdGVDYW52YXMoMSwxKSx0aGlzW2ZdPXIuRU5WLmNyZWF0ZVRleHQodix7Zm9udDpQLGZpbGxDb2xvcjppLHN0cm9rZUNvbG9yOnUsc3Ryb2tlV2lkdGg6YSxwYXJzZUZvbnQ6ci5wYXJzZUZvbnQscmF0aW86aCx0ZXh0Q2FudmFzOnRoaXNbbV19KSx0aGlzW2ZdLm5lZWRzVXBkYXRlPSEwLHRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpc1tmXX0pKX19byhULCJBdHRyIixsLmRlZmF1bHQpLGMuZGVmYXVsdC5yZWdpc3Rlck5vZGUoVCwibGFiZWwiKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciByPXQoMTIpLG49dCg3Mikscz10KDIyMSksbD10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx4PVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2NsYXNzIGcgZXh0ZW5kcyBsLmRlZmF1bHR7Y29uc3RydWN0b3IobSl7c3VwZXIobSksdGhpc1tjXSh7dGV4dDoiIixmb250U2l6ZToxNixmb250RmFtaWx5OiJIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZiIsZm9udFN0eWxlOiJub3JtYWwiLGZvbnRWYXJpYW50OiJub3JtYWwiLGZvbnRXZWlnaHQ6Im5vcm1hbCIsZm9udFN0cmV0Y2g6Im5vcm1hbCIsbGluZUhlaWdodDoiIix0ZXh0QWxpZ246ImxlZnQiLHN0cm9rZUNvbG9yOnZvaWQgMCxzdHJva2VXaWR0aDoxLGZpbGxDb2xvcjp2b2lkIDAsdmVydGljYWxBbGlnbjoibWlkZGxlIn0pLHRoaXNbeF0oImZvbnQiKX1nZXQgdGV4dCgpe3JldHVybiB0aGlzW2ZdKCJ0ZXh0Iil8fCIgIn1zZXQgdGV4dChtKXt0aGlzW29dKCJ0ZXh0IixtKX1nZXQgZm9udFNpemUoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFNpemUiKX1zZXQgZm9udFNpemUobSl7dGhpc1tvXSgiZm9udFNpemUiLE9iamVjdChuLnRvTnVtYmVyKShtKSl9Z2V0IGZvbnRGYW1pbHkoKXtyZXR1cm4gdGhpc1tmXSgiZm9udEZhbWlseSIpfXNldCBmb250RmFtaWx5KG0pe3RoaXNbb10oImZvbnRGYW1pbHkiLG0pfWdldCBmb250U3R5bGUoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFN0eWxlIil9c2V0IGZvbnRTdHlsZShtKXt0aGlzW29dKCJmb250U3R5bGUiLG0pfWdldCBmb250VmFyaWFudCgpe3JldHVybiB0aGlzW2ZdKCJmb250VmFyaWFudCIpfXNldCBmb250VmFyaWFudChtKXt0aGlzW29dKCJmb250VmFyaWFudCIsbSl9Z2V0IGZvbnRXZWlnaHQoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFdlaWdodCIpfXNldCBmb250V2VpZ2h0KG0pe3RoaXNbb10oImZvbnRXZWlnaHQiLG0pfWdldCBmb250U3RyZXRjaCgpe3JldHVybiB0aGlzW2ZdKCJmb250U3RyZXRjaCIpfXNldCBmb250U3RyZXRjaChtKXt0aGlzW29dKCJmb250U3RyZXRjaCIsbSl9Z2V0IGxpbmVIZWlnaHQoKXtyZXR1cm4gdGhpc1tmXSgibGluZUhlaWdodCIpfHx0aGlzLmZvbnRTaXplfXNldCBsaW5lSGVpZ2h0KG0pe3RoaXNbb10oImxpbmVIZWlnaHQiLE9iamVjdChuLnRvTnVtYmVyKShtKSl9Z2V0IHRleHRBbGlnbigpe3JldHVybiB0aGlzW2ZdKCJ0ZXh0QWxpZ24iKX1zZXQgdGV4dEFsaWduKG0pe3RoaXNbb10oInRleHRBbGlnbiIsbSl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbZl0oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKG0pe3RoaXNbb10oInN0cm9rZUNvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKShtKSl9Z2V0IHN0cm9rZVdpZHRoKCl7cmV0dXJuIHRoaXNbZl0oInN0cm9rZVdpZHRoIil9c2V0IHN0cm9rZVdpZHRoKG0pe3RoaXNbb10oInN0cm9rZVdpZHRoIixPYmplY3Qobi50b051bWJlcikobSkpfWdldCB2ZXJ0aWNhbEFsaWduKCl7cmV0dXJuIHRoaXNbZl0oInZlcnRpY2FsQWxpZ24iKX1zZXQgdmVydGljYWxBbGlnbihtKXt0aGlzW29dKCJ2ZXJ0aWNhbEFsaWduIixtKX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbZl0oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IobSl7dGhpc1tvXSgiZmlsbENvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKShtKSl9Z2V0IGZvbnQoKXtjb25zdHtmb250U3R5bGU6bSxmb250VmFyaWFudDpULGZvbnRXZWlnaHQ6Tyxmb250U3RyZXRjaDp2LGZvbnRTaXplOlAsbGluZUhlaWdodDppLGZvbnRGYW1pbHk6dX09dGhpcztyZXR1cm5gJHttfSAke1R9ICR7T30gJHt2fSAke1B9cHgvJHtpfXB4ICR7dX1gfXNldCBmb250KG0pe2lmKG09PW51bGwpdGhpcy5mb250U3R5bGU9bnVsbCx0aGlzLmZvbnRWYXJpYW50PW51bGwsdGhpcy5mb250V2VpZ2h0PW51bGwsdGhpcy5mb250U3RyZXRjaD1udWxsLHRoaXMuZm9udFNpemU9bnVsbCx0aGlzLmxpbmVIZWlnaHQ9bnVsbCx0aGlzLmZvbnRGYW1pbHk9bnVsbDtlbHNle2NvbnN0IFQ9T2JqZWN0KHIucGFyc2VGb250KShtKTt0aGlzLmZvbnRTdHlsZT1ULnN0eWxlLHRoaXMuZm9udFZhcmlhbnQ9VC52YXJpYW50LHRoaXMuZm9udFdlaWdodD1ULndlaWdodCx0aGlzLmZvbnRTdHJldGNoPVQuc3RyZXRjaCx0aGlzLmZvbnRTaXplPU9iamVjdChuLnRvTnVtYmVyKShgJHtULnNpemV9JHtULnVuaXR9YCksVC5saW5lSGVpZ2h0JiYodGhpcy5saW5lSGVpZ2h0PVQucHhMaW5lSGVpZ2h0KSx0aGlzLmZvbnRGYW1pbHk9VC5mYW1pbHl9fX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgcj10KDEyKSxuPXQoMjE5KSxzPXQoMjUxKSxsPXQoMjEzKSxjPXQoMjUyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhULE8sdil7cmV0dXJuIE8gaW4gVD9PYmplY3QuZGVmaW5lUHJvcGVydHkoVCxPLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6VFtPXT12LFR9Y29uc3QgZj1TeW1ib2woInpPcmRlciIpLHg9U3ltYm9sKCJvcmRlcmVkIiksZz1TeW1ib2woImNoaWxkcmVuIikseT1TeW1ib2woInNlYWxlZCIpO2NsYXNzIG0gZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoTz17fSl7c3VwZXIoTyksdGhpc1tnXT1bXSx0aGlzW3hdPW51bGwsdGhpc1tmXT0wfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuIHRoaXNbZ119Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXNbZ119Z2V0IG9yZGVyZWRDaGlsZHJlbigpe3JldHVybiB0aGlzW3hdfHwodGhpc1t4XT1bLi4udGhpc1tnXV0sdGhpc1t4XS5zb3J0KChPLHYpPT5PLnpJbmRleC12LnpJbmRleHx8Ty56T3JkZXItdi56T3JkZXIpKSx0aGlzW3hdfWFwcGVuZCguLi5PKXtyZXR1cm4gTy5tYXAodj0+dGhpcy5hcHBlbmRDaGlsZCh2KSl9YXBwZW5kQ2hpbGQoTyl7cmV0dXJuIE8ucmVtb3ZlKCksdGhpc1tnXS5wdXNoKE8pLE8uY29ubmVjdCh0aGlzLHRoaXNbZl0rKyksdGhpc1t4XSYmKHRoaXNbeF0ubGVuZ3RoJiZPLnpJbmRleDx0aGlzW3hdW3RoaXNbeF0ubGVuZ3RoLTFdLnpJbmRleD90aGlzLnJlb3JkZXIoKTp0aGlzW3hdLnB1c2goTykpLE99Y2xvbmVOb2RlKE89ITEpe2NvbnN0IHY9c3VwZXIuY2xvbmVOb2RlKCk7cmV0dXJuIE8mJnRoaXNbZ10uZm9yRWFjaChQPT57Y29uc3QgaT1QLmNsb25lTm9kZShPKTt2LmFwcGVuZENoaWxkKGkpfSksdn1kaXNwYXRjaFBvaW50ZXJFdmVudChPKXtjb25zdCB2PXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgUD12Lmxlbmd0aC0xO1A+PTA7UC0tKWlmKHZbUF0uZGlzcGF0Y2hQb2ludGVyRXZlbnQoTykpcmV0dXJuITA7cmV0dXJuIHN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KE8pfWRyYXcoTz1bXSl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PXRoaXMucmVuZGVyTWF0cml4LHN1cGVyLmRyYXcoTyksIXRoaXNbeV0mJnRoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiKXtjb25zdCB2PXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgUD0wO1A8di5sZW5ndGg7UCsrKXZbUF0uZHJhdyhPKX1yZXR1cm4gdGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PW51bGwsT31nZXRFbGVtZW50QnlJZChPKXtyZXR1cm4gT2JqZWN0KGMucXVlcnlTZWxlY3RvcikoYCMke099YCx0aGlzKX1nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKE8pe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yQWxsKShgLiR7T31gLHRoaXMpfWdldEVsZW1lbnRzQnlOYW1lKE8pe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yQWxsKShgW25hbWU9IiR7T30iXWAsdGhpcyl9Z2V0RWxlbWVudHNCeVRhZ05hbWUoTyl7cmV0dXJuIE9iamVjdChjLnF1ZXJ5U2VsZWN0b3JBbGwpKE8sdGhpcyl9aW5zZXJ0QmVmb3JlKE8sdil7aWYodj09bnVsbClyZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChPKTtPLnJlbW92ZSgpO2NvbnN0IFA9dGhpc1tnXS5pbmRleE9mKHYpO2lmKFA8MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7Y29uc3QgaT12LnpPcmRlcjtmb3IobGV0IHU9UDt1PHRoaXNbZ10ubGVuZ3RoO3UrKyl7Y29uc3QgYT10aGlzW2ddW3VdLnpPcmRlcixoPXRoaXNbZ11bdV07ZGVsZXRlIGguek9yZGVyLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLCJ6T3JkZXIiLHt2YWx1ZTphKzEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9aWYodGhpc1tnXS5zcGxpY2UoUCwwLE8pLE8uY29ubmVjdCh0aGlzLGkpLHRoaXNbeF0paWYoTy56SW5kZXghPT12LnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IHU9dGhpc1t4XS5pbmRleE9mKHYpO3RoaXNbeF0uc3BsaWNlKHUsMCxPKX1yZXR1cm4gT31xdWVyeVNlbGVjdG9yKE8pe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yKShPLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoTyl7cmV0dXJuIE9iamVjdChjLnF1ZXJ5U2VsZWN0b3JBbGwpKE8sdGhpcyl9cmVwbGFjZUNoaWxkKE8sdil7Ty5yZW1vdmUoKTtjb25zdCBQPXRoaXNbZ10uaW5kZXhPZih2KTtpZihQPDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2lmKHRoaXNbZ11bUF09TyxPLmNvbm5lY3QodGhpcyx2LnpPcmRlciksdGhpc1t4XSlpZihPLnpJbmRleCE9PXYuekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3QgaT10aGlzW3hdLmluZGV4T2Yodik7dGhpc1t4XVtpXT1PfXJldHVybiB2LmRpc2Nvbm5lY3QodGhpcyksT31yZW1vdmVBbGxDaGlsZHJlbigpe2NvbnN0IE89dGhpc1tnXTtmb3IobGV0IHY9Ty5sZW5ndGgtMTt2Pj0wO3YtLSlPW3ZdLnJlbW92ZSgpfXJlbW92ZUNoaWxkKE8pe2NvbnN0IHY9dGhpc1tnXS5pbmRleE9mKE8pO2lmKHY+PTApe2lmKHRoaXNbZ10uc3BsaWNlKHYsMSksdGhpc1t4XSl7Y29uc3QgUD10aGlzW3hdLmluZGV4T2YoTyk7dGhpc1t4XS5zcGxpY2UoUCwxKX1yZXR1cm4gTy5kaXNjb25uZWN0KHRoaXMpLE99cmV0dXJuIG51bGx9cmVvcmRlcigpe3RoaXNbeF09bnVsbH1zZWFsKCl7ZnVuY3Rpb24gTyh1LGEpe2NvbnN0IGg9W107Zm9yKGxldCBiPTA7Yjx1Lmxlbmd0aDtiKyspe2NvbnN0IEU9Wy4uLnVbYl1dO2ZvcihsZXQgQT0xO0E8RS5sZW5ndGg7QSs9Mil7Y29uc3QgTD1FW0FdLFM9RVtBKzFdO0VbQV09TCphWzBdK1MqYVsyXSthWzRdLEVbQSsxXT1MKmFbMV0rUyphWzNdK2FbNV19aC5wdXNoKEUpfXJldHVybiBofWNvbnN0IHY9dGhpcy5vcmRlcmVkQ2hpbGRyZW4sUD1uZXcgci5GaWd1cmUyRCxpPXRoaXMubG9jYWxNYXRyaXg7Zm9yKGxldCB1PTA7dTx2Lmxlbmd0aDt1Kyspe2xldCBhPXZbdV07aWYoYSBpbnN0YW5jZW9mIG0mJihhPWEuc2VhbCgpKSxhLmNsaWVudEJveCl7bGV0IGg9YS5jbGllbnRCb3guY29udG91cnMucGF0aDtoPU8oaCxhLmxvY2FsTWF0cml4KSxQLmFkZFBhdGgoaCl9aWYoYS5wYXRoKXtsZXQgaD1hLnBhdGguY29udG91cnMucGF0aDtoPU8oaCxhLmxvY2FsTWF0cml4KSxQLmFkZFBhdGgoaCl9fXJldHVybiB0aGlzW3ldPSEwLHRoaXMuY2xpZW50Qm94PVAse2NsaWVudEJveDpQLGxvY2FsTWF0cml4Oml9fXNldFJlc29sdXRpb24oe3dpZHRoOk8saGVpZ2h0OnZ9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpPLGhlaWdodDp2fSksdGhpc1tnXS5mb3JFYWNoKFA9PntQLnNldFJlc29sdXRpb24oe3dpZHRoOk8saGVpZ2h0OnZ9KX0pfXVwZGF0ZUNvbnRvdXJzKCl7dGhpc1t5XXx8c3VwZXIudXBkYXRlQ29udG91cnMoKX19byhtLCJBdHRyIixzLmRlZmF1bHQpLGwuZGVmYXVsdC5yZWdpc3Rlck5vZGUobSwiZ3JvdXAiKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciByPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgbiBleHRlbmRzIHIuZGVmYXVsdHt9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJxdWVyeVNlbGVjdG9yQWxsIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInF1ZXJ5U2VsZWN0b3IiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiaXNNYXRjaGVkIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImNvbXBpbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgcj10KDIyMSksbj10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9dCgyNTMpO2Z1bmN0aW9uIGwodil7cmV0dXJuIHYubm9kZVR5cGU9PT0xfHxuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKHYubm9kZU5hbWUpfWZ1bmN0aW9uIGModil7cmV0dXJuIEFycmF5LmZyb20odi5jaGlsZE5vZGVzfHxbXSl9ZnVuY3Rpb24gbyh2KXtyZXR1cm4gbi5kZWZhdWx0LmlzU3ByaXRlTm9kZSh2Lm5vZGVOYW1lKT92LnBhcmVudHx8di5jYW52YXN8fHYuY29udGFpbmVyOnYucGFyZW50RWxlbWVudH1mdW5jdGlvbiBmKHYpe2xldCBQPXYubGVuZ3RoLGksdSxhO2Zvcig7LS1QPi0xOyl7Zm9yKGk9dT12W1BdLHZbUF09bnVsbCxhPSEwO3U7KXtpZih2LmluZGV4T2YodSk+LTEpe2E9ITEsdi5zcGxpY2UoUCwxKTticmVha311PW8odSl9YSYmKHZbUF09aSl9cmV0dXJuIHZ9Y29uc3QgeD17aXNUYWc6bCxleGlzdHNPbmUodixQKXtyZXR1cm4gUC5zb21lKGk9PmwoaSk/dihpKXx8eC5leGlzdHNPbmUodixjKGkpKTohMSl9LGdldFNpYmxpbmdzKHYpe2NvbnN0IFA9byh2KTtyZXR1cm4gUCYmYyhQKX0sZ2V0Q2hpbGRyZW46YyxnZXRQYXJlbnQ6byxnZXRBdHRyaWJ1dGVWYWx1ZSh2LFApe2lmKHYubm9kZVR5cGU9PT0xJiZQPT09ImNsYXNzInx8UD09PSJpZCIpcmV0dXJuIHZbUF07aWYodGhpcy5oYXNBdHRyaWIodixQKSl7bGV0IGk9di5hdHRyaWJ1dGVzW1BdO3JldHVybiBBcnJheS5pc0FycmF5KGkpJiYoaT1gWyR7aS5qb2luKCl9XWApLFN0cmluZyhpKX19LGhhc0F0dHJpYih2LFApe3JldHVybiB2LmF0dHJpYnV0ZXNbUF0hPW51bGx9LHJlbW92ZVN1YnNldHM6ZixnZXROYW1lKHYpe3JldHVybiB2LnRhZ05hbWU/di50YWdOYW1lLnRvTG93ZXJDYXNlKCk6bnVsbH0sZmluZE9uZTpmdW5jdGlvbiB2KFAsaSl7bGV0IHU9bnVsbDtmb3IobGV0IGE9MCxoPWkubGVuZ3RoO2E8aCYmIXU7YSsrKWlmKFAoaVthXSkpdT1pW2FdO2Vsc2V7Y29uc3QgYj1jKGlbYV0pO2ImJmIubGVuZ3RoPjAmJih1PXYoUCxiKSl9cmV0dXJuIHV9LGZpbmRBbGw6ZnVuY3Rpb24gdihQLGkpe2xldCB1PVtdO2ZvcihsZXQgYT0wLGg9aS5sZW5ndGg7YTxoO2ErKyl7aWYoIWwoaVthXSkpY29udGludWU7UChpW2FdKSYmdS5wdXNoKGlbYV0pO2NvbnN0IGI9YyhpW2FdKTtiJiYodT11LmNvbmNhdCh2KFAsYikpKX1yZXR1cm4gdX0sZ2V0VGV4dDpmdW5jdGlvbiB2KFApe3JldHVybiBBcnJheS5pc0FycmF5KFApP1AubWFwKHYpLmpvaW4oIiIpOmwoUCk/dihjKFApKTpQLm5vZGVUeXBlPT09Mz9QLm5vZGVWYWx1ZTpuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKFAubm9kZU5hbWUpP1AudGV4dDoiIn19O2Z1bmN0aW9uIGcodil7aWYodHlwZW9mIHYhPSJzdHJpbmciKXJldHVybiB2O2xldCBQPXYubWF0Y2goL1xbKGJnY29sb3J8ZmlsbENvbG9yfHN0cm9rZUNvbG9yfGNvbG9yKVxzKj1ccypbJyJdP1x3K1snIl0/XF0vZyk7cmV0dXJuIFAmJihQPVAubWFwKGk9Pntjb25zdCB1PWkuc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxhPU9iamVjdChyLnBhcnNlQ29sb3IpKHVbMV0ucmVwbGFjZSgvWyciXS9nLCIiKSk7cmV0dXJuW2ksYFske3VbMF19PSIke2F9Il1gXX0pLFAuZm9yRWFjaCgoW2ksdV0pPT57dj12LnJlcGxhY2UoaSx1KX0pKSxQPXYubWF0Y2goL1xbXHcrXHMqPVxzKlsnIl1cWy4rP1xdWyciXVxdL2cpLFAmJihQPVAubWFwKGk9Pntjb25zdCB1PWkuc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxhPXVbMV0uc2xpY2UoMiwtMikuc3BsaXQoLywvZykubWFwKGg9PmgudHJpbSgpKTtyZXR1cm5baSxgWyR7dVswXX09Ilske2F9XSJdYF19KSxQLmZvckVhY2goKFtpLHVdKT0+e3Y9di5yZXBsYWNlKGksdSl9KSksdn1mdW5jdGlvbiB5KHYsUCl7cmV0dXJuIHMuc2VsZWN0QWxsKGcodiksUCx7YWRhcHRlcjp4fSl9ZnVuY3Rpb24gbSh2LFApe3JldHVybiBzLnNlbGVjdE9uZShnKHYpLFAse2FkYXB0ZXI6eH0pfWZ1bmN0aW9uIFQodixQKXtyZXR1cm4gcy5pcyh2LGcoUCkse2FkYXB0ZXI6eH0pfWZ1bmN0aW9uIE8odil7cmV0dXJuIHMuY29tcGlsZShnKHYpLHthZGFwdGVyOnh9KX19LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9Tzt2YXIgcj10KDI1NCksbj10KDI3MykuZmFsc2VGdW5jLHM9dCgyNzQpO2Z1bmN0aW9uIGwodil7cmV0dXJuIGZ1bmN0aW9uKGksdSxhKXtyZXR1cm4gdT11fHx7fSx1LmFkYXB0ZXI9dS5hZGFwdGVyfHxyLHYoaSx1LGEpfX12YXIgYz1sKHMpLG89bChzLmNvbXBpbGVVbnNhZmUpO2Z1bmN0aW9uIGYodil7cmV0dXJuIGZ1bmN0aW9uKGksdSxhKXtyZXR1cm4gYT1hfHx7fSxhLmFkYXB0ZXI9YS5hZGFwdGVyfHxyLHR5cGVvZiBpIT0iZnVuY3Rpb24iJiYoaT1vKGksYSx1KSksaS5zaG91bGRUZXN0TmV4dFNpYmxpbmdzJiYodT1nKGEmJmEuY29udGV4dHx8dSxhLmFkYXB0ZXIpKSxBcnJheS5pc0FycmF5KHUpP3U9YS5hZGFwdGVyLnJlbW92ZVN1YnNldHModSk6dT1hLmFkYXB0ZXIuZ2V0Q2hpbGRyZW4odSksdihpLHUsYSl9fWZ1bmN0aW9uIHgodixQKXt2YXIgaT1QLmdldFNpYmxpbmdzKHYpO2lmKCFBcnJheS5pc0FycmF5KGkpKXJldHVybltdO2ZvcihpPWkuc2xpY2UoMCk7aS5zaGlmdCgpIT09djspO3JldHVybiBpfWZ1bmN0aW9uIGcodixQKXtBcnJheS5pc0FycmF5KHYpfHwodj1bdl0pO2Zvcih2YXIgaT12LnNsaWNlKDApLHU9MCxhPXYubGVuZ3RoO3U8YTt1Kyspe3ZhciBoPXgoaVt1XSxQKTtpLnB1c2guYXBwbHkoaSxoKX1yZXR1cm4gaX12YXIgeT1mKGZ1bmN0aW9uKFAsaSx1KXtyZXR1cm4gUD09PW58fCFpfHxpLmxlbmd0aD09PTA/W106dS5hZGFwdGVyLmZpbmRBbGwoUCxpKX0pLG09ZihmdW5jdGlvbihQLGksdSl7cmV0dXJuIFA9PT1ufHwhaXx8aS5sZW5ndGg9PT0wP251bGw6dS5hZGFwdGVyLmZpbmRPbmUoUCxpKX0pO2Z1bmN0aW9uIFQodixQLGkpe3JldHVybiBpPWl8fHt9LGkuYWRhcHRlcj1pLmFkYXB0ZXJ8fHIsKHR5cGVvZiBQPT0iZnVuY3Rpb24iP1A6YyhQLGkpKSh2KX1mdW5jdGlvbiBPKHYsUCxpKXtyZXR1cm4geSh2LFAsaSl9Ty5jb21waWxlPWMsTy5maWx0ZXJzPXMuUHNldWRvcy5maWx0ZXJzLE8ucHNldWRvcz1zLlBzZXVkb3MucHNldWRvcyxPLnNlbGVjdEFsbD15LE8uc2VsZWN0T25lPW0sTy5pcz1ULE8ucGFyc2U9YyxPLml0ZXJhdGU9eSxPLl9jb21waWxlVW5zYWZlPW8sTy5fY29tcGlsZVRva2VuPXMuY29tcGlsZVRva2VufSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9ZC5leHBvcnRzO1t0KDI1NSksdCgyNjgpLHQoMjY5KSx0KDI3MCksdCgyNzEpLHQoMjcyKV0uZm9yRWFjaChmdW5jdGlvbihuKXtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKHMpe3Jbc109bltzXS5iaW5kKHIpfSl9KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMjU2KSxuPXQoMjU3KSxzPXIuaXNUYWc7ZC5leHBvcnRzPXtnZXRJbm5lckhUTUw6bCxnZXRPdXRlckhUTUw6bixnZXRUZXh0OmN9O2Z1bmN0aW9uIGwobyxmKXtyZXR1cm4gby5jaGlsZHJlbj9vLmNoaWxkcmVuLm1hcChmdW5jdGlvbih4KXtyZXR1cm4gbih4LGYpfSkuam9pbigiIik6IiJ9ZnVuY3Rpb24gYyhvKXtyZXR1cm4gQXJyYXkuaXNBcnJheShvKT9vLm1hcChjKS5qb2luKCIiKTpzKG8pP28ubmFtZT09PSJiciI/YApgOmMoby5jaGlsZHJlbik6by50eXBlPT09ci5DREFUQT9jKG8uY2hpbGRyZW4pOm8udHlwZT09PXIuVGV4dD9vLmRhdGE6IiJ9fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz17VGV4dDoidGV4dCIsRGlyZWN0aXZlOiJkaXJlY3RpdmUiLENvbW1lbnQ6ImNvbW1lbnQiLFNjcmlwdDoic2NyaXB0IixTdHlsZToic3R5bGUiLFRhZzoidGFnIixDREFUQToiY2RhdGEiLERvY3R5cGU6ImRvY3R5cGUiLGlzVGFnOmZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGU9PT0idGFnInx8dC50eXBlPT09InNjcmlwdCJ8fHQudHlwZT09PSJzdHlsZSJ9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMjU4KSxuPXQoMjU5KSxzPXQoMjY3KTtzLmVsZW1lbnROYW1lcy5fX3Byb3RvX189bnVsbCxzLmF0dHJpYnV0ZU5hbWVzLl9fcHJvdG9fXz1udWxsO3ZhciBsPXtfX3Byb3RvX186bnVsbCxzdHlsZTohMCxzY3JpcHQ6ITAseG1wOiEwLGlmcmFtZTohMCxub2VtYmVkOiEwLG5vZnJhbWVzOiEwLHBsYWludGV4dDohMCxub3NjcmlwdDohMH07ZnVuY3Rpb24gYyh2LFApe2lmKHYpe3ZhciBpPSIiLHU7Zm9yKHZhciBhIGluIHYpdT12W2FdLGkmJihpKz0iICIpLFAueG1sTW9kZT09PSJmb3JlaWduIiYmKGE9cy5hdHRyaWJ1dGVOYW1lc1thXXx8YSksaSs9YSwodSE9PW51bGwmJnUhPT0iInx8UC54bWxNb2RlKSYmKGkrPSc9IicrKFAuZGVjb2RlRW50aXRpZXM/bi5lbmNvZGVYTUwodSk6dS5yZXBsYWNlKC9cIi9nLCImcXVvdDsiKSkrJyInKTtyZXR1cm4gaX19dmFyIG89e19fcHJvdG9fXzpudWxsLGFyZWE6ITAsYmFzZTohMCxiYXNlZm9udDohMCxicjohMCxjb2w6ITAsY29tbWFuZDohMCxlbWJlZDohMCxmcmFtZTohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsaXNpbmRleDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9LGY9ZC5leHBvcnRzPWZ1bmN0aW9uKHYsUCl7IUFycmF5LmlzQXJyYXkodikmJiF2LmNoZWVyaW8mJih2PVt2XSksUD1QfHx7fTtmb3IodmFyIGk9IiIsdT0wO3U8di5sZW5ndGg7dSsrKXt2YXIgYT12W3VdO2EudHlwZT09PSJyb290Ij9pKz1mKGEuY2hpbGRyZW4sUCk6ci5pc1RhZyhhKT9pKz1nKGEsUCk6YS50eXBlPT09ci5EaXJlY3RpdmU/aSs9eShhKTphLnR5cGU9PT1yLkNvbW1lbnQ/aSs9TyhhKTphLnR5cGU9PT1yLkNEQVRBP2krPVQoYSk6aSs9bShhLFApfXJldHVybiBpfSx4PVsibWkiLCJtbyIsIm1uIiwibXMiLCJtdGV4dCIsImFubm90YXRpb24teG1sIiwiZm9yZWlnbk9iamVjdCIsImRlc2MiLCJ0aXRsZSJdO2Z1bmN0aW9uIGcodixQKXtQLnhtbE1vZGU9PT0iZm9yZWlnbiImJih2Lm5hbWU9cy5lbGVtZW50TmFtZXNbdi5uYW1lXXx8di5uYW1lLHYucGFyZW50JiZ4LmluZGV4T2Yodi5wYXJlbnQubmFtZSk+PTAmJihQPU9iamVjdC5hc3NpZ24oe30sUCx7eG1sTW9kZTohMX0pKSksIVAueG1sTW9kZSYmWyJzdmciLCJtYXRoIl0uaW5kZXhPZih2Lm5hbWUpPj0wJiYoUD1PYmplY3QuYXNzaWduKHt9LFAse3htbE1vZGU6ImZvcmVpZ24ifSkpO3ZhciBpPSI8Iit2Lm5hbWUsdT1jKHYuYXR0cmlicyxQKTtyZXR1cm4gdSYmKGkrPSIgIit1KSxQLnhtbE1vZGUmJighdi5jaGlsZHJlbnx8di5jaGlsZHJlbi5sZW5ndGg9PT0wKT9pKz0iLz4iOihpKz0iPiIsdi5jaGlsZHJlbiYmKGkrPWYodi5jaGlsZHJlbixQKSksKCFvW3YubmFtZV18fFAueG1sTW9kZSkmJihpKz0iPC8iK3YubmFtZSsiPiIpKSxpfWZ1bmN0aW9uIHkodil7cmV0dXJuIjwiK3YuZGF0YSsiPiJ9ZnVuY3Rpb24gbSh2LFApe3ZhciBpPXYuZGF0YXx8IiI7cmV0dXJuIFAuZGVjb2RlRW50aXRpZXMmJiEodi5wYXJlbnQmJnYucGFyZW50Lm5hbWUgaW4gbCkmJihpPW4uZW5jb2RlWE1MKGkpKSxpfWZ1bmN0aW9uIFQodil7cmV0dXJuIjwhW0NEQVRBWyIrdi5jaGlsZHJlblswXS5kYXRhKyJdXT4ifWZ1bmN0aW9uIE8odil7cmV0dXJuIjwhLS0iK3YuZGF0YSsiLS0+In19LGZ1bmN0aW9uKGQsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gcihuKXtyZXR1cm4gbi50eXBlPT09InRhZyJ8fG4udHlwZT09PSJzY3JpcHQifHxuLnR5cGU9PT0ic3R5bGUifWUuaXNUYWc9cixlLlRleHQ9InRleHQiLGUuRGlyZWN0aXZlPSJkaXJlY3RpdmUiLGUuQ29tbWVudD0iY29tbWVudCIsZS5TY3JpcHQ9InNjcmlwdCIsZS5TdHlsZT0ic3R5bGUiLGUuVGFnPSJ0YWciLGUuQ0RBVEE9ImNkYXRhIixlLkRvY3R5cGU9ImRvY3R5cGUifSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZW5jb2RlPWUuZGVjb2RlU3RyaWN0PWUuZGVjb2RlPXZvaWQgMDt2YXIgcj10KDI2MCksbj10KDI2Nik7ZnVuY3Rpb24gcyh4LGcpe3JldHVybighZ3x8Zzw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUwpKHgpfWUuZGVjb2RlPXM7ZnVuY3Rpb24gbCh4LGcpe3JldHVybighZ3x8Zzw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUxTdHJpY3QpKHgpfWUuZGVjb2RlU3RyaWN0PWw7ZnVuY3Rpb24gYyh4LGcpe3JldHVybighZ3x8Zzw9MD9uLmVuY29kZVhNTDpuLmVuY29kZUhUTUwpKHgpfWUuZW5jb2RlPWM7dmFyIG89dCgyNjYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLmVuY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZXNjYXBlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5lc2NhcGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5jb2RlSFRNTH19KTt2YXIgZj10KDI2MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNVN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVYTUx9fSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZyl7cmV0dXJuIGcmJmcuX19lc01vZHVsZT9nOntkZWZhdWx0Omd9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWNvZGVIVE1MPWUuZGVjb2RlSFRNTFN0cmljdD1lLmRlY29kZVhNTD12b2lkIDA7dmFyIG49cih0KDI2MSkpLHM9cih0KDI2MikpLGw9cih0KDI2MykpLGM9cih0KDI2NCkpO2UuZGVjb2RlWE1MPW8obC5kZWZhdWx0KSxlLmRlY29kZUhUTUxTdHJpY3Q9byhuLmRlZmF1bHQpO2Z1bmN0aW9uIG8oZyl7dmFyIHk9T2JqZWN0LmtleXMoZykuam9pbigifCIpLG09eChnKTt5Kz0ifCNbeFhdW1xcZGEtZkEtRl0rfCNcXGQrIjt2YXIgVD1uZXcgUmVnRXhwKCImKD86Iit5KyIpOyIsImciKTtyZXR1cm4gZnVuY3Rpb24oTyl7cmV0dXJuIFN0cmluZyhPKS5yZXBsYWNlKFQsbSl9fXZhciBmPWZ1bmN0aW9uKGcseSl7cmV0dXJuIGc8eT8xOi0xfTtlLmRlY29kZUhUTUw9ZnVuY3Rpb24oKXtmb3IodmFyIGc9T2JqZWN0LmtleXMocy5kZWZhdWx0KS5zb3J0KGYpLHk9T2JqZWN0LmtleXMobi5kZWZhdWx0KS5zb3J0KGYpLG09MCxUPTA7bTx5Lmxlbmd0aDttKyspZ1tUXT09PXlbbV0/KHlbbV0rPSI7PyIsVCsrKTp5W21dKz0iOyI7dmFyIE89bmV3IFJlZ0V4cCgiJig/OiIreS5qb2luKCJ8IikrInwjW3hYXVtcXGRhLWZBLUZdKzs/fCNcXGQrOz8pIiwiZyIpLHY9eChuLmRlZmF1bHQpO2Z1bmN0aW9uIFAoaSl7cmV0dXJuIGkuc3Vic3RyKC0xKSE9PSI7IiYmKGkrPSI7IiksdihpKX1yZXR1cm4gZnVuY3Rpb24oaSl7cmV0dXJuIFN0cmluZyhpKS5yZXBsYWNlKE8sUCl9fSgpO2Z1bmN0aW9uIHgoZyl7cmV0dXJuIGZ1bmN0aW9uKG0pe2lmKG0uY2hhckF0KDEpPT09IiMiKXt2YXIgVD1tLmNoYXJBdCgyKTtyZXR1cm4gVD09PSJYInx8VD09PSJ4Ij9jLmRlZmF1bHQocGFyc2VJbnQobS5zdWJzdHIoMyksMTYpKTpjLmRlZmF1bHQocGFyc2VJbnQobS5zdWJzdHIoMiksMTApKX1yZXR1cm4gZ1ttLnNsaWNlKDEsLTEpXX19fSxmdW5jdGlvbihkKXtkLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWJyZXZlIjoixIIiLCJhYnJldmUiOiLEgyIsImFjIjoi4oi+IiwiYWNkIjoi4oi/IiwiYWNFIjoi4oi+zLMiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBY3kiOiLQkCIsImFjeSI6ItCwIiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJhZiI6IuKBoSIsIkFmciI6IvCdlIQiLCJhZnIiOiLwnZSeIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFsZWZzeW0iOiLihLUiLCJhbGVwaCI6IuKEtSIsIkFscGhhIjoizpEiLCJhbHBoYSI6Is6xIiwiQW1hY3IiOiLEgCIsImFtYWNyIjoixIEiLCJhbWFsZyI6IuKovyIsImFtcCI6IiYiLCJBTVAiOiImIiwiYW5kYW5kIjoi4qmVIiwiQW5kIjoi4qmTIiwiYW5kIjoi4oinIiwiYW5kZCI6IuKpnCIsImFuZHNsb3BlIjoi4qmYIiwiYW5kdiI6IuKpmiIsImFuZyI6IuKIoCIsImFuZ2UiOiLipqQiLCJhbmdsZSI6IuKIoCIsImFuZ21zZGFhIjoi4qaoIiwiYW5nbXNkYWIiOiLipqkiLCJhbmdtc2RhYyI6IuKmqiIsImFuZ21zZGFkIjoi4qarIiwiYW5nbXNkYWUiOiLipqwiLCJhbmdtc2RhZiI6IuKmrSIsImFuZ21zZGFnIjoi4qauIiwiYW5nbXNkYWgiOiLipq8iLCJhbmdtc2QiOiLiiKEiLCJhbmdydCI6IuKInyIsImFuZ3J0dmIiOiLiir4iLCJhbmdydHZiZCI6IuKmnSIsImFuZ3NwaCI6IuKIoiIsImFuZ3N0Ijoiw4UiLCJhbmd6YXJyIjoi4o28IiwiQW9nb24iOiLEhCIsImFvZ29uIjoixIUiLCJBb3BmIjoi8J2UuCIsImFvcGYiOiLwnZWSIiwiYXBhY2lyIjoi4qmvIiwiYXAiOiLiiYgiLCJhcEUiOiLiqbAiLCJhcGUiOiLiiYoiLCJhcGlkIjoi4omLIiwiYXBvcyI6IlwnIiwiQXBwbHlGdW5jdGlvbiI6IuKBoSIsImFwcHJveCI6IuKJiCIsImFwcHJveGVxIjoi4omKIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBc2NyIjoi8J2SnCIsImFzY3IiOiLwnZK2IiwiQXNzaWduIjoi4omUIiwiYXN0IjoiKiIsImFzeW1wIjoi4omIIiwiYXN5bXBlcSI6IuKJjSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJhd2NvbmludCI6IuKIsyIsImF3aW50Ijoi4qiRIiwiYmFja2NvbmciOiLiiYwiLCJiYWNrZXBzaWxvbiI6Is+2IiwiYmFja3ByaW1lIjoi4oC1IiwiYmFja3NpbSI6IuKIvSIsImJhY2tzaW1lcSI6IuKLjSIsIkJhY2tzbGFzaCI6IuKIliIsIkJhcnYiOiLiq6ciLCJiYXJ2ZWUiOiLiir0iLCJiYXJ3ZWQiOiLijIUiLCJCYXJ3ZWQiOiLijIYiLCJiYXJ3ZWRnZSI6IuKMhSIsImJicmsiOiLijrUiLCJiYnJrdGJyayI6IuKOtiIsImJjb25nIjoi4omMIiwiQmN5Ijoi0JEiLCJiY3kiOiLQsSIsImJkcXVvIjoi4oCeIiwiYmVjYXVzIjoi4oi1IiwiYmVjYXVzZSI6IuKItSIsIkJlY2F1c2UiOiLiiLUiLCJiZW1wdHl2Ijoi4qawIiwiYmVwc2kiOiLPtiIsImJlcm5vdSI6IuKErCIsIkJlcm5vdWxsaXMiOiLihKwiLCJCZXRhIjoizpIiLCJiZXRhIjoizrIiLCJiZXRoIjoi4oS2IiwiYmV0d2VlbiI6IuKJrCIsIkJmciI6IvCdlIUiLCJiZnIiOiLwnZSfIiwiYmlnY2FwIjoi4ouCIiwiYmlnY2lyYyI6IuKXryIsImJpZ2N1cCI6IuKLgyIsImJpZ29kb3QiOiLiqIAiLCJiaWdvcGx1cyI6IuKogSIsImJpZ290aW1lcyI6IuKogiIsImJpZ3NxY3VwIjoi4qiGIiwiYmlnc3RhciI6IuKYhSIsImJpZ3RyaWFuZ2xlZG93biI6IuKWvSIsImJpZ3RyaWFuZ2xldXAiOiLilrMiLCJiaWd1cGx1cyI6IuKohCIsImJpZ3ZlZSI6IuKLgSIsImJpZ3dlZGdlIjoi4ouAIiwiYmthcm93Ijoi4qSNIiwiYmxhY2tsb3plbmdlIjoi4qerIiwiYmxhY2tzcXVhcmUiOiLilqoiLCJibGFja3RyaWFuZ2xlIjoi4pa0IiwiYmxhY2t0cmlhbmdsZWRvd24iOiLilr4iLCJibGFja3RyaWFuZ2xlbGVmdCI6IuKXgiIsImJsYWNrdHJpYW5nbGVyaWdodCI6IuKWuCIsImJsYW5rIjoi4pCjIiwiYmxrMTIiOiLilpIiLCJibGsxNCI6IuKWkSIsImJsazM0Ijoi4paTIiwiYmxvY2siOiLilogiLCJibmUiOiI94oOlIiwiYm5lcXVpdiI6IuKJoeKDpSIsImJOb3QiOiLiq60iLCJibm90Ijoi4oyQIiwiQm9wZiI6IvCdlLkiLCJib3BmIjoi8J2VkyIsImJvdCI6IuKKpSIsImJvdHRvbSI6IuKKpSIsImJvd3RpZSI6IuKLiCIsImJveGJveCI6IuKniSIsImJveGRsIjoi4pSQIiwiYm94ZEwiOiLilZUiLCJib3hEbCI6IuKVliIsImJveERMIjoi4pWXIiwiYm94ZHIiOiLilIwiLCJib3hkUiI6IuKVkiIsImJveERyIjoi4pWTIiwiYm94RFIiOiLilZQiLCJib3hoIjoi4pSAIiwiYm94SCI6IuKVkCIsImJveGhkIjoi4pSsIiwiYm94SGQiOiLilaQiLCJib3hoRCI6IuKVpSIsImJveEhEIjoi4pWmIiwiYm94aHUiOiLilLQiLCJib3hIdSI6IuKVpyIsImJveGhVIjoi4pWoIiwiYm94SFUiOiLilakiLCJib3htaW51cyI6IuKKnyIsImJveHBsdXMiOiLiip4iLCJib3h0aW1lcyI6IuKKoCIsImJveHVsIjoi4pSYIiwiYm94dUwiOiLilZsiLCJib3hVbCI6IuKVnCIsImJveFVMIjoi4pWdIiwiYm94dXIiOiLilJQiLCJib3h1UiI6IuKVmCIsImJveFVyIjoi4pWZIiwiYm94VVIiOiLilZoiLCJib3h2Ijoi4pSCIiwiYm94ViI6IuKVkSIsImJveHZoIjoi4pS8IiwiYm94dkgiOiLilaoiLCJib3hWaCI6IuKVqyIsImJveFZIIjoi4pWsIiwiYm94dmwiOiLilKQiLCJib3h2TCI6IuKVoSIsImJveFZsIjoi4pWiIiwiYm94VkwiOiLilaMiLCJib3h2ciI6IuKUnCIsImJveHZSIjoi4pWeIiwiYm94VnIiOiLilZ8iLCJib3hWUiI6IuKVoCIsImJwcmltZSI6IuKAtSIsImJyZXZlIjoiy5giLCJCcmV2ZSI6IsuYIiwiYnJ2YmFyIjoiwqYiLCJic2NyIjoi8J2StyIsIkJzY3IiOiLihKwiLCJic2VtaSI6IuKBjyIsImJzaW0iOiLiiL0iLCJic2ltZSI6IuKLjSIsImJzb2xiIjoi4qeFIiwiYnNvbCI6IlxcXFwiLCJic29saHN1YiI6IuKfiCIsImJ1bGwiOiLigKIiLCJidWxsZXQiOiLigKIiLCJidW1wIjoi4omOIiwiYnVtcEUiOiLiqq4iLCJidW1wZSI6IuKJjyIsIkJ1bXBlcSI6IuKJjiIsImJ1bXBlcSI6IuKJjyIsIkNhY3V0ZSI6IsSGIiwiY2FjdXRlIjoixIciLCJjYXBhbmQiOiLiqYQiLCJjYXBicmN1cCI6IuKpiSIsImNhcGNhcCI6IuKpiyIsImNhcCI6IuKIqSIsIkNhcCI6IuKLkiIsImNhcGN1cCI6IuKphyIsImNhcGRvdCI6IuKpgCIsIkNhcGl0YWxEaWZmZXJlbnRpYWxEIjoi4oWFIiwiY2FwcyI6IuKIqe+4gCIsImNhcmV0Ijoi4oGBIiwiY2Fyb24iOiLLhyIsIkNheWxleXMiOiLihK0iLCJjY2FwcyI6IuKpjSIsIkNjYXJvbiI6IsSMIiwiY2Nhcm9uIjoixI0iLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiQ2NpcmMiOiLEiCIsImNjaXJjIjoixIkiLCJDY29uaW50Ijoi4oiwIiwiY2N1cHMiOiLiqYwiLCJjY3Vwc3NtIjoi4qmQIiwiQ2RvdCI6IsSKIiwiY2RvdCI6IsSLIiwiY2VkaWwiOiLCuCIsIkNlZGlsbGEiOiLCuCIsImNlbXB0eXYiOiLiprIiLCJjZW50IjoiwqIiLCJjZW50ZXJkb3QiOiLCtyIsIkNlbnRlckRvdCI6IsK3IiwiY2ZyIjoi8J2UoCIsIkNmciI6IuKErSIsIkNIY3kiOiLQpyIsImNoY3kiOiLRhyIsImNoZWNrIjoi4pyTIiwiY2hlY2ttYXJrIjoi4pyTIiwiQ2hpIjoizqciLCJjaGkiOiLPhyIsImNpcmMiOiLLhiIsImNpcmNlcSI6IuKJlyIsImNpcmNsZWFycm93bGVmdCI6IuKGuiIsImNpcmNsZWFycm93cmlnaHQiOiLihrsiLCJjaXJjbGVkYXN0Ijoi4oqbIiwiY2lyY2xlZGNpcmMiOiLiipoiLCJjaXJjbGVkZGFzaCI6IuKKnSIsIkNpcmNsZURvdCI6IuKKmSIsImNpcmNsZWRSIjoiwq4iLCJjaXJjbGVkUyI6IuKTiCIsIkNpcmNsZU1pbnVzIjoi4oqWIiwiQ2lyY2xlUGx1cyI6IuKKlSIsIkNpcmNsZVRpbWVzIjoi4oqXIiwiY2lyIjoi4peLIiwiY2lyRSI6IuKngyIsImNpcmUiOiLiiZciLCJjaXJmbmludCI6IuKokCIsImNpcm1pZCI6IuKrryIsImNpcnNjaXIiOiLip4IiLCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLIiLCJDbG9zZUN1cmx5RG91YmxlUXVvdGUiOiLigJ0iLCJDbG9zZUN1cmx5UXVvdGUiOiLigJkiLCJjbHVicyI6IuKZoyIsImNsdWJzdWl0Ijoi4pmjIiwiY29sb24iOiI6IiwiQ29sb24iOiLiiLciLCJDb2xvbmUiOiLiqbQiLCJjb2xvbmUiOiLiiZQiLCJjb2xvbmVxIjoi4omUIiwiY29tbWEiOiIsIiwiY29tbWF0IjoiQCIsImNvbXAiOiLiiIEiLCJjb21wZm4iOiLiiJgiLCJjb21wbGVtZW50Ijoi4oiBIiwiY29tcGxleGVzIjoi4oSCIiwiY29uZyI6IuKJhSIsImNvbmdkb3QiOiLiqa0iLCJDb25ncnVlbnQiOiLiiaEiLCJjb25pbnQiOiLiiK4iLCJDb25pbnQiOiLiiK8iLCJDb250b3VySW50ZWdyYWwiOiLiiK4iLCJjb3BmIjoi8J2VlCIsIkNvcGYiOiLihIIiLCJjb3Byb2QiOiLiiJAiLCJDb3Byb2R1Y3QiOiLiiJAiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjb3B5c3IiOiLihJciLCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oizIiwiY3JhcnIiOiLihrUiLCJjcm9zcyI6IuKclyIsIkNyb3NzIjoi4qivIiwiQ3NjciI6IvCdkp4iLCJjc2NyIjoi8J2SuCIsImNzdWIiOiLiq48iLCJjc3ViZSI6IuKrkSIsImNzdXAiOiLiq5AiLCJjc3VwZSI6IuKrkiIsImN0ZG90Ijoi4ouvIiwiY3VkYXJybCI6IuKkuCIsImN1ZGFycnIiOiLipLUiLCJjdWVwciI6IuKLniIsImN1ZXNjIjoi4oufIiwiY3VsYXJyIjoi4oa2IiwiY3VsYXJycCI6IuKkvSIsImN1cGJyY2FwIjoi4qmIIiwiY3VwY2FwIjoi4qmGIiwiQ3VwQ2FwIjoi4omNIiwiY3VwIjoi4oiqIiwiQ3VwIjoi4ouTIiwiY3VwY3VwIjoi4qmKIiwiY3VwZG90Ijoi4oqNIiwiY3Vwb3IiOiLiqYUiLCJjdXBzIjoi4oiq77iAIiwiY3VyYXJyIjoi4oa3IiwiY3VyYXJybSI6IuKkvCIsImN1cmx5ZXFwcmVjIjoi4oueIiwiY3VybHllcXN1Y2MiOiLii58iLCJjdXJseXZlZSI6IuKLjiIsImN1cmx5d2VkZ2UiOiLii48iLCJjdXJyZW4iOiLCpCIsImN1cnZlYXJyb3dsZWZ0Ijoi4oa2IiwiY3VydmVhcnJvd3JpZ2h0Ijoi4oa3IiwiY3V2ZWUiOiLii44iLCJjdXdlZCI6IuKLjyIsImN3Y29uaW50Ijoi4oiyIiwiY3dpbnQiOiLiiLEiLCJjeWxjdHkiOiLijK0iLCJkYWdnZXIiOiLigKAiLCJEYWdnZXIiOiLigKEiLCJkYWxldGgiOiLihLgiLCJkYXJyIjoi4oaTIiwiRGFyciI6IuKGoSIsImRBcnIiOiLih5MiLCJkYXNoIjoi4oCQIiwiRGFzaHYiOiLiq6QiLCJkYXNodiI6IuKKoyIsImRia2Fyb3ciOiLipI8iLCJkYmxhYyI6IsudIiwiRGNhcm9uIjoixI4iLCJkY2Fyb24iOiLEjyIsIkRjeSI6ItCUIiwiZGN5Ijoi0LQiLCJkZGFnZ2VyIjoi4oChIiwiZGRhcnIiOiLih4oiLCJERCI6IuKFhSIsImRkIjoi4oWGIiwiRERvdHJhaGQiOiLipJEiLCJkZG90c2VxIjoi4qm3IiwiZGVnIjoiwrAiLCJEZWwiOiLiiIciLCJEZWx0YSI6Is6UIiwiZGVsdGEiOiLOtCIsImRlbXB0eXYiOiLiprEiLCJkZmlzaHQiOiLipb8iLCJEZnIiOiLwnZSHIiwiZGZyIjoi8J2UoSIsImRIYXIiOiLipaUiLCJkaGFybCI6IuKHgyIsImRoYXJyIjoi4oeCIiwiRGlhY3JpdGljYWxBY3V0ZSI6IsK0IiwiRGlhY3JpdGljYWxEb3QiOiLLmSIsIkRpYWNyaXRpY2FsRG91YmxlQWN1dGUiOiLLnSIsIkRpYWNyaXRpY2FsR3JhdmUiOiJgIiwiRGlhY3JpdGljYWxUaWxkZSI6IsucIiwiZGlhbSI6IuKLhCIsImRpYW1vbmQiOiLii4QiLCJEaWFtb25kIjoi4ouEIiwiZGlhbW9uZHN1aXQiOiLimaYiLCJkaWFtcyI6IuKZpiIsImRpZSI6IsKoIiwiRGlmZmVyZW50aWFsRCI6IuKFhiIsImRpZ2FtbWEiOiLPnSIsImRpc2luIjoi4ouyIiwiZGl2Ijoiw7ciLCJkaXZpZGUiOiLDtyIsImRpdmlkZW9udGltZXMiOiLii4ciLCJkaXZvbngiOiLii4ciLCJESmN5Ijoi0IIiLCJkamN5Ijoi0ZIiLCJkbGNvcm4iOiLijJ4iLCJkbGNyb3AiOiLijI0iLCJkb2xsYXIiOiIkIiwiRG9wZiI6IvCdlLsiLCJkb3BmIjoi8J2VlSIsIkRvdCI6IsKoIiwiZG90Ijoiy5kiLCJEb3REb3QiOiLig5wiLCJkb3RlcSI6IuKJkCIsImRvdGVxZG90Ijoi4omRIiwiRG90RXF1YWwiOiLiiZAiLCJkb3RtaW51cyI6IuKIuCIsImRvdHBsdXMiOiLiiJQiLCJkb3RzcXVhcmUiOiLiiqEiLCJkb3VibGViYXJ3ZWRnZSI6IuKMhiIsIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbCI6IuKIryIsIkRvdWJsZURvdCI6IsKoIiwiRG91YmxlRG93bkFycm93Ijoi4oeTIiwiRG91YmxlTGVmdEFycm93Ijoi4oeQIiwiRG91YmxlTGVmdFJpZ2h0QXJyb3ciOiLih5QiLCJEb3VibGVMZWZ0VGVlIjoi4qukIiwiRG91YmxlTG9uZ0xlZnRBcnJvdyI6IuKfuCIsIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKfuiIsIkRvdWJsZUxvbmdSaWdodEFycm93Ijoi4p+5IiwiRG91YmxlUmlnaHRBcnJvdyI6IuKHkiIsIkRvdWJsZVJpZ2h0VGVlIjoi4oqoIiwiRG91YmxlVXBBcnJvdyI6IuKHkSIsIkRvdWJsZVVwRG93bkFycm93Ijoi4oeVIiwiRG91YmxlVmVydGljYWxCYXIiOiLiiKUiLCJEb3duQXJyb3dCYXIiOiLipJMiLCJkb3duYXJyb3ciOiLihpMiLCJEb3duQXJyb3ciOiLihpMiLCJEb3duYXJyb3ciOiLih5MiLCJEb3duQXJyb3dVcEFycm93Ijoi4oe1IiwiRG93bkJyZXZlIjoizJEiLCJkb3duZG93bmFycm93cyI6IuKHiiIsImRvd25oYXJwb29ubGVmdCI6IuKHgyIsImRvd25oYXJwb29ucmlnaHQiOiLih4IiLCJEb3duTGVmdFJpZ2h0VmVjdG9yIjoi4qWQIiwiRG93bkxlZnRUZWVWZWN0b3IiOiLipZ4iLCJEb3duTGVmdFZlY3RvckJhciI6IuKlliIsIkRvd25MZWZ0VmVjdG9yIjoi4oa9IiwiRG93blJpZ2h0VGVlVmVjdG9yIjoi4qWfIiwiRG93blJpZ2h0VmVjdG9yQmFyIjoi4qWXIiwiRG93blJpZ2h0VmVjdG9yIjoi4oeBIiwiRG93blRlZUFycm93Ijoi4oanIiwiRG93blRlZSI6IuKKpCIsImRyYmthcm93Ijoi4qSQIiwiZHJjb3JuIjoi4oyfIiwiZHJjcm9wIjoi4oyMIiwiRHNjciI6IvCdkp8iLCJkc2NyIjoi8J2SuSIsIkRTY3kiOiLQhSIsImRzY3kiOiLRlSIsImRzb2wiOiLip7YiLCJEc3Ryb2siOiLEkCIsImRzdHJvayI6IsSRIiwiZHRkb3QiOiLii7EiLCJkdHJpIjoi4pa/IiwiZHRyaWYiOiLilr4iLCJkdWFyciI6IuKHtSIsImR1aGFyIjoi4qWvIiwiZHdhbmdsZSI6IuKmpiIsIkRaY3kiOiLQjyIsImR6Y3kiOiLRnyIsImR6aWdyYXJyIjoi4p+/IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsImVhc3RlciI6IuKpriIsIkVjYXJvbiI6IsSaIiwiZWNhcm9uIjoixJsiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsImVjaXIiOiLiiZYiLCJlY29sb24iOiLiiZUiLCJFY3kiOiLQrSIsImVjeSI6ItGNIiwiZUREb3QiOiLiqbciLCJFZG90IjoixJYiLCJlZG90IjoixJciLCJlRG90Ijoi4omRIiwiZWUiOiLihYciLCJlZkRvdCI6IuKJkiIsIkVmciI6IvCdlIgiLCJlZnIiOiLwnZSiIiwiZWciOiLiqpoiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiZWdzIjoi4qqWIiwiZWdzZG90Ijoi4qqYIiwiZWwiOiLiqpkiLCJFbGVtZW50Ijoi4oiIIiwiZWxpbnRlcnMiOiLij6ciLCJlbGwiOiLihJMiLCJlbHMiOiLiqpUiLCJlbHNkb3QiOiLiqpciLCJFbWFjciI6IsSSIiwiZW1hY3IiOiLEkyIsImVtcHR5Ijoi4oiFIiwiZW1wdHlzZXQiOiLiiIUiLCJFbXB0eVNtYWxsU3F1YXJlIjoi4pe7IiwiZW1wdHl2Ijoi4oiFIiwiRW1wdHlWZXJ5U21hbGxTcXVhcmUiOiLilqsiLCJlbXNwMTMiOiLigIQiLCJlbXNwMTQiOiLigIUiLCJlbXNwIjoi4oCDIiwiRU5HIjoixYoiLCJlbmciOiLFiyIsImVuc3AiOiLigIIiLCJFb2dvbiI6IsSYIiwiZW9nb24iOiLEmSIsIkVvcGYiOiLwnZS8IiwiZW9wZiI6IvCdlZYiLCJlcGFyIjoi4ouVIiwiZXBhcnNsIjoi4qejIiwiZXBsdXMiOiLiqbEiLCJlcHNpIjoizrUiLCJFcHNpbG9uIjoizpUiLCJlcHNpbG9uIjoizrUiLCJlcHNpdiI6Is+1IiwiZXFjaXJjIjoi4omWIiwiZXFjb2xvbiI6IuKJlSIsImVxc2ltIjoi4omCIiwiZXFzbGFudGd0ciI6IuKqliIsImVxc2xhbnRsZXNzIjoi4qqVIiwiRXF1YWwiOiLiqbUiLCJlcXVhbHMiOiI9IiwiRXF1YWxUaWxkZSI6IuKJgiIsImVxdWVzdCI6IuKJnyIsIkVxdWlsaWJyaXVtIjoi4oeMIiwiZXF1aXYiOiLiiaEiLCJlcXVpdkREIjoi4qm4IiwiZXF2cGFyc2wiOiLip6UiLCJlcmFyciI6IuKlsSIsImVyRG90Ijoi4omTIiwiZXNjciI6IuKEryIsIkVzY3IiOiLihLAiLCJlc2RvdCI6IuKJkCIsIkVzaW0iOiLiqbMiLCJlc2ltIjoi4omCIiwiRXRhIjoizpciLCJldGEiOiLOtyIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJldXJvIjoi4oKsIiwiZXhjbCI6IiEiLCJleGlzdCI6IuKIgyIsIkV4aXN0cyI6IuKIgyIsImV4cGVjdGF0aW9uIjoi4oSwIiwiZXhwb25lbnRpYWxlIjoi4oWHIiwiRXhwb25lbnRpYWxFIjoi4oWHIiwiZmFsbGluZ2RvdHNlcSI6IuKJkiIsIkZjeSI6ItCkIiwiZmN5Ijoi0YQiLCJmZW1hbGUiOiLimYAiLCJmZmlsaWciOiLvrIMiLCJmZmxpZyI6Iu+sgCIsImZmbGxpZyI6Iu+shCIsIkZmciI6IvCdlIkiLCJmZnIiOiLwnZSjIiwiZmlsaWciOiLvrIEiLCJGaWxsZWRTbWFsbFNxdWFyZSI6IuKXvCIsIkZpbGxlZFZlcnlTbWFsbFNxdWFyZSI6IuKWqiIsImZqbGlnIjoiZmoiLCJmbGF0Ijoi4pmtIiwiZmxsaWciOiLvrIIiLCJmbHRucyI6IuKWsSIsImZub2YiOiLGkiIsIkZvcGYiOiLwnZS9IiwiZm9wZiI6IvCdlZciLCJmb3JhbGwiOiLiiIAiLCJGb3JBbGwiOiLiiIAiLCJmb3JrIjoi4ouUIiwiZm9ya3YiOiLiq5kiLCJGb3VyaWVydHJmIjoi4oSxIiwiZnBhcnRpbnQiOiLiqI0iLCJmcmFjMTIiOiLCvSIsImZyYWMxMyI6IuKFkyIsImZyYWMxNCI6IsK8IiwiZnJhYzE1Ijoi4oWVIiwiZnJhYzE2Ijoi4oWZIiwiZnJhYzE4Ijoi4oWbIiwiZnJhYzIzIjoi4oWUIiwiZnJhYzI1Ijoi4oWWIiwiZnJhYzM0Ijoiwr4iLCJmcmFjMzUiOiLihZciLCJmcmFjMzgiOiLihZwiLCJmcmFjNDUiOiLihZgiLCJmcmFjNTYiOiLihZoiLCJmcmFjNTgiOiLihZ0iLCJmcmFjNzgiOiLihZ4iLCJmcmFzbCI6IuKBhCIsImZyb3duIjoi4oyiIiwiZnNjciI6IvCdkrsiLCJGc2NyIjoi4oSxIiwiZ2FjdXRlIjoix7UiLCJHYW1tYSI6Is6TIiwiZ2FtbWEiOiLOsyIsIkdhbW1hZCI6Is+cIiwiZ2FtbWFkIjoiz50iLCJnYXAiOiLiqoYiLCJHYnJldmUiOiLEniIsImdicmV2ZSI6IsSfIiwiR2NlZGlsIjoixKIiLCJHY2lyYyI6IsScIiwiZ2NpcmMiOiLEnSIsIkdjeSI6ItCTIiwiZ2N5Ijoi0LMiLCJHZG90IjoixKAiLCJnZG90IjoixKEiLCJnZSI6IuKJpSIsImdFIjoi4omnIiwiZ0VsIjoi4qqMIiwiZ2VsIjoi4oubIiwiZ2VxIjoi4omlIiwiZ2VxcSI6IuKJpyIsImdlcXNsYW50Ijoi4qm+IiwiZ2VzY2MiOiLiqqkiLCJnZXMiOiLiqb4iLCJnZXNkb3QiOiLiqoAiLCJnZXNkb3RvIjoi4qqCIiwiZ2VzZG90b2wiOiLiqoQiLCJnZXNsIjoi4oub77iAIiwiZ2VzbGVzIjoi4qqUIiwiR2ZyIjoi8J2UiiIsImdmciI6IvCdlKQiLCJnZyI6IuKJqyIsIkdnIjoi4ouZIiwiZ2dnIjoi4ouZIiwiZ2ltZWwiOiLihLciLCJHSmN5Ijoi0IMiLCJnamN5Ijoi0ZMiLCJnbGEiOiLiqqUiLCJnbCI6IuKJtyIsImdsRSI6IuKqkiIsImdsaiI6IuKqpCIsImduYXAiOiLiqooiLCJnbmFwcHJveCI6IuKqiiIsImduZSI6IuKqiCIsImduRSI6IuKJqSIsImduZXEiOiLiqogiLCJnbmVxcSI6IuKJqSIsImduc2ltIjoi4ounIiwiR29wZiI6IvCdlL4iLCJnb3BmIjoi8J2VmCIsImdyYXZlIjoiYCIsIkdyZWF0ZXJFcXVhbCI6IuKJpSIsIkdyZWF0ZXJFcXVhbExlc3MiOiLii5siLCJHcmVhdGVyRnVsbEVxdWFsIjoi4omnIiwiR3JlYXRlckdyZWF0ZXIiOiLiqqIiLCJHcmVhdGVyTGVzcyI6IuKJtyIsIkdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+IiwiR3JlYXRlclRpbGRlIjoi4omzIiwiR3NjciI6IvCdkqIiLCJnc2NyIjoi4oSKIiwiZ3NpbSI6IuKJsyIsImdzaW1lIjoi4qqOIiwiZ3NpbWwiOiLiqpAiLCJndGNjIjoi4qqnIiwiZ3RjaXIiOiLiqboiLCJndCI6Ij4iLCJHVCI6Ij4iLCJHdCI6IuKJqyIsImd0ZG90Ijoi4ouXIiwiZ3RsUGFyIjoi4qaVIiwiZ3RxdWVzdCI6IuKpvCIsImd0cmFwcHJveCI6IuKqhiIsImd0cmFyciI6IuKluCIsImd0cmRvdCI6IuKLlyIsImd0cmVxbGVzcyI6IuKLmyIsImd0cmVxcWxlc3MiOiLiqowiLCJndHJsZXNzIjoi4om3IiwiZ3Ryc2ltIjoi4omzIiwiZ3ZlcnRuZXFxIjoi4omp77iAIiwiZ3ZuRSI6IuKJqe+4gCIsIkhhY2VrIjoiy4ciLCJoYWlyc3AiOiLigIoiLCJoYWxmIjoiwr0iLCJoYW1pbHQiOiLihIsiLCJIQVJEY3kiOiLQqiIsImhhcmRjeSI6ItGKIiwiaGFycmNpciI6IuKliCIsImhhcnIiOiLihpQiLCJoQXJyIjoi4oeUIiwiaGFycnciOiLihq0iLCJIYXQiOiJeIiwiaGJhciI6IuKEjyIsIkhjaXJjIjoixKQiLCJoY2lyYyI6IsSlIiwiaGVhcnRzIjoi4pmlIiwiaGVhcnRzdWl0Ijoi4pmlIiwiaGVsbGlwIjoi4oCmIiwiaGVyY29uIjoi4oq5IiwiaGZyIjoi8J2UpSIsIkhmciI6IuKEjCIsIkhpbGJlcnRTcGFjZSI6IuKEiyIsImhrc2Vhcm93Ijoi4qSlIiwiaGtzd2Fyb3ciOiLipKYiLCJob2FyciI6IuKHvyIsImhvbXRodCI6IuKIuyIsImhvb2tsZWZ0YXJyb3ciOiLihqkiLCJob29rcmlnaHRhcnJvdyI6IuKGqiIsImhvcGYiOiLwnZWZIiwiSG9wZiI6IuKEjSIsImhvcmJhciI6IuKAlSIsIkhvcml6b250YWxMaW5lIjoi4pSAIiwiaHNjciI6IvCdkr0iLCJIc2NyIjoi4oSLIiwiaHNsYXNoIjoi4oSPIiwiSHN0cm9rIjoixKYiLCJoc3Ryb2siOiLEpyIsIkh1bXBEb3duSHVtcCI6IuKJjiIsIkh1bXBFcXVhbCI6IuKJjyIsImh5YnVsbCI6IuKBgyIsImh5cGhlbiI6IuKAkCIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJpYyI6IuKBoyIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiSWN5Ijoi0JgiLCJpY3kiOiLQuCIsIklkb3QiOiLEsCIsIklFY3kiOiLQlSIsImllY3kiOiLQtSIsImlleGNsIjoiwqEiLCJpZmYiOiLih5QiLCJpZnIiOiLwnZSmIiwiSWZyIjoi4oSRIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlpIjoi4oWIIiwiaWlpaW50Ijoi4qiMIiwiaWlpbnQiOiLiiK0iLCJpaW5maW4iOiLip5wiLCJpaW90YSI6IuKEqSIsIklKbGlnIjoixLIiLCJpamxpZyI6IsSzIiwiSW1hY3IiOiLEqiIsImltYWNyIjoixKsiLCJpbWFnZSI6IuKEkSIsIkltYWdpbmFyeUkiOiLihYgiLCJpbWFnbGluZSI6IuKEkCIsImltYWdwYXJ0Ijoi4oSRIiwiaW1hdGgiOiLEsSIsIkltIjoi4oSRIiwiaW1vZiI6IuKKtyIsImltcGVkIjoixrUiLCJJbXBsaWVzIjoi4oeSIiwiaW5jYXJlIjoi4oSFIiwiaW4iOiLiiIgiLCJpbmZpbiI6IuKIniIsImluZmludGllIjoi4qedIiwiaW5vZG90IjoixLEiLCJpbnRjYWwiOiLiiroiLCJpbnQiOiLiiKsiLCJJbnQiOiLiiKwiLCJpbnRlZ2VycyI6IuKEpCIsIkludGVncmFsIjoi4oirIiwiaW50ZXJjYWwiOiLiiroiLCJJbnRlcnNlY3Rpb24iOiLii4IiLCJpbnRsYXJoayI6IuKolyIsImludHByb2QiOiLiqLwiLCJJbnZpc2libGVDb21tYSI6IuKBoyIsIkludmlzaWJsZVRpbWVzIjoi4oGiIiwiSU9jeSI6ItCBIiwiaW9jeSI6ItGRIiwiSW9nb24iOiLEriIsImlvZ29uIjoixK8iLCJJb3BmIjoi8J2VgCIsImlvcGYiOiLwnZWaIiwiSW90YSI6Is6ZIiwiaW90YSI6Is65IiwiaXByb2QiOiLiqLwiLCJpcXVlc3QiOiLCvyIsImlzY3IiOiLwnZK+IiwiSXNjciI6IuKEkCIsImlzaW4iOiLiiIgiLCJpc2luZG90Ijoi4ou1IiwiaXNpbkUiOiLii7kiLCJpc2lucyI6IuKLtCIsImlzaW5zdiI6IuKLsyIsImlzaW52Ijoi4oiIIiwiaXQiOiLigaIiLCJJdGlsZGUiOiLEqCIsIml0aWxkZSI6IsSpIiwiSXVrY3kiOiLQhiIsIml1a2N5Ijoi0ZYiLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJKY2lyYyI6IsS0IiwiamNpcmMiOiLEtSIsIkpjeSI6ItCZIiwiamN5Ijoi0LkiLCJKZnIiOiLwnZSNIiwiamZyIjoi8J2UpyIsImptYXRoIjoiyLciLCJKb3BmIjoi8J2VgSIsImpvcGYiOiLwnZWbIiwiSnNjciI6IvCdkqUiLCJqc2NyIjoi8J2SvyIsIkpzZXJjeSI6ItCIIiwianNlcmN5Ijoi0ZgiLCJKdWtjeSI6ItCEIiwianVrY3kiOiLRlCIsIkthcHBhIjoizpoiLCJrYXBwYSI6Is66Iiwia2FwcGF2Ijoiz7AiLCJLY2VkaWwiOiLEtiIsImtjZWRpbCI6IsS3IiwiS2N5Ijoi0JoiLCJrY3kiOiLQuiIsIktmciI6IvCdlI4iLCJrZnIiOiLwnZSoIiwia2dyZWVuIjoixLgiLCJLSGN5Ijoi0KUiLCJraGN5Ijoi0YUiLCJLSmN5Ijoi0IwiLCJramN5Ijoi0ZwiLCJLb3BmIjoi8J2VgiIsImtvcGYiOiLwnZWcIiwiS3NjciI6IvCdkqYiLCJrc2NyIjoi8J2TgCIsImxBYXJyIjoi4oeaIiwiTGFjdXRlIjoixLkiLCJsYWN1dGUiOiLEuiIsImxhZW1wdHl2Ijoi4qa0IiwibGFncmFuIjoi4oSSIiwiTGFtYmRhIjoizpsiLCJsYW1iZGEiOiLOuyIsImxhbmciOiLin6giLCJMYW5nIjoi4p+qIiwibGFuZ2QiOiLippEiLCJsYW5nbGUiOiLin6giLCJsYXAiOiLiqoUiLCJMYXBsYWNldHJmIjoi4oSSIiwibGFxdW8iOiLCqyIsImxhcnJiIjoi4oekIiwibGFycmJmcyI6IuKknyIsImxhcnIiOiLihpAiLCJMYXJyIjoi4oaeIiwibEFyciI6IuKHkCIsImxhcnJmcyI6IuKknSIsImxhcnJoayI6IuKGqSIsImxhcnJscCI6IuKGqyIsImxhcnJwbCI6IuKkuSIsImxhcnJzaW0iOiLipbMiLCJsYXJydGwiOiLihqIiLCJsYXRhaWwiOiLipJkiLCJsQXRhaWwiOiLipJsiLCJsYXQiOiLiqqsiLCJsYXRlIjoi4qqtIiwibGF0ZXMiOiLiqq3vuIAiLCJsYmFyciI6IuKkjCIsImxCYXJyIjoi4qSOIiwibGJicmsiOiLinbIiLCJsYnJhY2UiOiJ7IiwibGJyYWNrIjoiWyIsImxicmtlIjoi4qaLIiwibGJya3NsZCI6IuKmjyIsImxicmtzbHUiOiLipo0iLCJMY2Fyb24iOiLEvSIsImxjYXJvbiI6IsS+IiwiTGNlZGlsIjoixLsiLCJsY2VkaWwiOiLEvCIsImxjZWlsIjoi4oyIIiwibGN1YiI6InsiLCJMY3kiOiLQmyIsImxjeSI6ItC7IiwibGRjYSI6IuKktiIsImxkcXVvIjoi4oCcIiwibGRxdW9yIjoi4oCeIiwibGRyZGhhciI6IuKlpyIsImxkcnVzaGFyIjoi4qWLIiwibGRzaCI6IuKGsiIsImxlIjoi4omkIiwibEUiOiLiiaYiLCJMZWZ0QW5nbGVCcmFja2V0Ijoi4p+oIiwiTGVmdEFycm93QmFyIjoi4oekIiwibGVmdGFycm93Ijoi4oaQIiwiTGVmdEFycm93Ijoi4oaQIiwiTGVmdGFycm93Ijoi4oeQIiwiTGVmdEFycm93UmlnaHRBcnJvdyI6IuKHhiIsImxlZnRhcnJvd3RhaWwiOiLihqIiLCJMZWZ0Q2VpbGluZyI6IuKMiCIsIkxlZnREb3VibGVCcmFja2V0Ijoi4p+mIiwiTGVmdERvd25UZWVWZWN0b3IiOiLipaEiLCJMZWZ0RG93blZlY3RvckJhciI6IuKlmSIsIkxlZnREb3duVmVjdG9yIjoi4oeDIiwiTGVmdEZsb29yIjoi4oyKIiwibGVmdGhhcnBvb25kb3duIjoi4oa9IiwibGVmdGhhcnBvb251cCI6IuKGvCIsImxlZnRsZWZ0YXJyb3dzIjoi4oeHIiwibGVmdHJpZ2h0YXJyb3ciOiLihpQiLCJMZWZ0UmlnaHRBcnJvdyI6IuKGlCIsIkxlZnRyaWdodGFycm93Ijoi4oeUIiwibGVmdHJpZ2h0YXJyb3dzIjoi4oeGIiwibGVmdHJpZ2h0aGFycG9vbnMiOiLih4siLCJsZWZ0cmlnaHRzcXVpZ2Fycm93Ijoi4oatIiwiTGVmdFJpZ2h0VmVjdG9yIjoi4qWOIiwiTGVmdFRlZUFycm93Ijoi4oakIiwiTGVmdFRlZSI6IuKKoyIsIkxlZnRUZWVWZWN0b3IiOiLipZoiLCJsZWZ0dGhyZWV0aW1lcyI6IuKLiyIsIkxlZnRUcmlhbmdsZUJhciI6IuKnjyIsIkxlZnRUcmlhbmdsZSI6IuKKsiIsIkxlZnRUcmlhbmdsZUVxdWFsIjoi4oq0IiwiTGVmdFVwRG93blZlY3RvciI6IuKlkSIsIkxlZnRVcFRlZVZlY3RvciI6IuKloCIsIkxlZnRVcFZlY3RvckJhciI6IuKlmCIsIkxlZnRVcFZlY3RvciI6IuKGvyIsIkxlZnRWZWN0b3JCYXIiOiLipZIiLCJMZWZ0VmVjdG9yIjoi4oa8IiwibEVnIjoi4qqLIiwibGVnIjoi4ouaIiwibGVxIjoi4omkIiwibGVxcSI6IuKJpiIsImxlcXNsYW50Ijoi4qm9IiwibGVzY2MiOiLiqqgiLCJsZXMiOiLiqb0iLCJsZXNkb3QiOiLiqb8iLCJsZXNkb3RvIjoi4qqBIiwibGVzZG90b3IiOiLiqoMiLCJsZXNnIjoi4oua77iAIiwibGVzZ2VzIjoi4qqTIiwibGVzc2FwcHJveCI6IuKqhSIsImxlc3Nkb3QiOiLii5YiLCJsZXNzZXFndHIiOiLii5oiLCJsZXNzZXFxZ3RyIjoi4qqLIiwiTGVzc0VxdWFsR3JlYXRlciI6IuKLmiIsIkxlc3NGdWxsRXF1YWwiOiLiiaYiLCJMZXNzR3JlYXRlciI6IuKJtiIsImxlc3NndHIiOiLiibYiLCJMZXNzTGVzcyI6IuKqoSIsImxlc3NzaW0iOiLiibIiLCJMZXNzU2xhbnRFcXVhbCI6IuKpvSIsIkxlc3NUaWxkZSI6IuKJsiIsImxmaXNodCI6IuKlvCIsImxmbG9vciI6IuKMiiIsIkxmciI6IvCdlI8iLCJsZnIiOiLwnZSpIiwibGciOiLiibYiLCJsZ0UiOiLiqpEiLCJsSGFyIjoi4qWiIiwibGhhcmQiOiLihr0iLCJsaGFydSI6IuKGvCIsImxoYXJ1bCI6IuKlqiIsImxoYmxrIjoi4paEIiwiTEpjeSI6ItCJIiwibGpjeSI6ItGZIiwibGxhcnIiOiLih4ciLCJsbCI6IuKJqiIsIkxsIjoi4ouYIiwibGxjb3JuZXIiOiLijJ4iLCJMbGVmdGFycm93Ijoi4oeaIiwibGxoYXJkIjoi4qWrIiwibGx0cmkiOiLil7oiLCJMbWlkb3QiOiLEvyIsImxtaWRvdCI6IsWAIiwibG1vdXN0YWNoZSI6IuKOsCIsImxtb3VzdCI6IuKOsCIsImxuYXAiOiLiqokiLCJsbmFwcHJveCI6IuKqiSIsImxuZSI6IuKqhyIsImxuRSI6IuKJqCIsImxuZXEiOiLiqociLCJsbmVxcSI6IuKJqCIsImxuc2ltIjoi4oumIiwibG9hbmciOiLin6wiLCJsb2FyciI6IuKHvSIsImxvYnJrIjoi4p+mIiwibG9uZ2xlZnRhcnJvdyI6IuKftSIsIkxvbmdMZWZ0QXJyb3ciOiLin7UiLCJMb25nbGVmdGFycm93Ijoi4p+4IiwibG9uZ2xlZnRyaWdodGFycm93Ijoi4p+3IiwiTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+3IiwiTG9uZ2xlZnRyaWdodGFycm93Ijoi4p+6IiwibG9uZ21hcHN0byI6IuKfvCIsImxvbmdyaWdodGFycm93Ijoi4p+2IiwiTG9uZ1JpZ2h0QXJyb3ciOiLin7YiLCJMb25ncmlnaHRhcnJvdyI6IuKfuSIsImxvb3BhcnJvd2xlZnQiOiLihqsiLCJsb29wYXJyb3dyaWdodCI6IuKGrCIsImxvcGFyIjoi4qaFIiwiTG9wZiI6IvCdlYMiLCJsb3BmIjoi8J2VnSIsImxvcGx1cyI6IuKorSIsImxvdGltZXMiOiLiqLQiLCJsb3dhc3QiOiLiiJciLCJsb3diYXIiOiJfIiwiTG93ZXJMZWZ0QXJyb3ciOiLihpkiLCJMb3dlclJpZ2h0QXJyb3ciOiLihpgiLCJsb3oiOiLil4oiLCJsb3plbmdlIjoi4peKIiwibG96ZiI6IuKnqyIsImxwYXIiOiIoIiwibHBhcmx0Ijoi4qaTIiwibHJhcnIiOiLih4YiLCJscmNvcm5lciI6IuKMnyIsImxyaGFyIjoi4oeLIiwibHJoYXJkIjoi4qWtIiwibHJtIjoi4oCOIiwibHJ0cmkiOiLiir8iLCJsc2FxdW8iOiLigLkiLCJsc2NyIjoi8J2TgSIsIkxzY3IiOiLihJIiLCJsc2giOiLihrAiLCJMc2giOiLihrAiLCJsc2ltIjoi4omyIiwibHNpbWUiOiLiqo0iLCJsc2ltZyI6IuKqjyIsImxzcWIiOiJbIiwibHNxdW8iOiLigJgiLCJsc3F1b3IiOiLigJoiLCJMc3Ryb2siOiLFgSIsImxzdHJvayI6IsWCIiwibHRjYyI6IuKqpiIsImx0Y2lyIjoi4qm5IiwibHQiOiI8IiwiTFQiOiI8IiwiTHQiOiLiiaoiLCJsdGRvdCI6IuKLliIsImx0aHJlZSI6IuKLiyIsImx0aW1lcyI6IuKLiSIsImx0bGFyciI6IuKltiIsImx0cXVlc3QiOiLiqbsiLCJsdHJpIjoi4peDIiwibHRyaWUiOiLiirQiLCJsdHJpZiI6IuKXgiIsImx0clBhciI6IuKmliIsImx1cmRzaGFyIjoi4qWKIiwibHVydWhhciI6IuKlpiIsImx2ZXJ0bmVxcSI6IuKJqO+4gCIsImx2bkUiOiLiiajvuIAiLCJtYWNyIjoiwq8iLCJtYWxlIjoi4pmCIiwibWFsdCI6IuKcoCIsIm1hbHRlc2UiOiLinKAiLCJNYXAiOiLipIUiLCJtYXAiOiLihqYiLCJtYXBzdG8iOiLihqYiLCJtYXBzdG9kb3duIjoi4oanIiwibWFwc3RvbGVmdCI6IuKGpCIsIm1hcHN0b3VwIjoi4oalIiwibWFya2VyIjoi4pauIiwibWNvbW1hIjoi4qipIiwiTWN5Ijoi0JwiLCJtY3kiOiLQvCIsIm1kYXNoIjoi4oCUIiwibUREb3QiOiLiiLoiLCJtZWFzdXJlZGFuZ2xlIjoi4oihIiwiTWVkaXVtU3BhY2UiOiLigZ8iLCJNZWxsaW50cmYiOiLihLMiLCJNZnIiOiLwnZSQIiwibWZyIjoi8J2UqiIsIm1obyI6IuKEpyIsIm1pY3JvIjoiwrUiLCJtaWRhc3QiOiIqIiwibWlkY2lyIjoi4quwIiwibWlkIjoi4oijIiwibWlkZG90IjoiwrciLCJtaW51c2IiOiLiip8iLCJtaW51cyI6IuKIkiIsIm1pbnVzZCI6IuKIuCIsIm1pbnVzZHUiOiLiqKoiLCJNaW51c1BsdXMiOiLiiJMiLCJtbGNwIjoi4qubIiwibWxkciI6IuKApiIsIm1ucGx1cyI6IuKIkyIsIm1vZGVscyI6IuKKpyIsIk1vcGYiOiLwnZWEIiwibW9wZiI6IvCdlZ4iLCJtcCI6IuKIkyIsIm1zY3IiOiLwnZOCIiwiTXNjciI6IuKEsyIsIm1zdHBvcyI6IuKIviIsIk11IjoizpwiLCJtdSI6Is68IiwibXVsdGltYXAiOiLiirgiLCJtdW1hcCI6IuKKuCIsIm5hYmxhIjoi4oiHIiwiTmFjdXRlIjoixYMiLCJuYWN1dGUiOiLFhCIsIm5hbmciOiLiiKDig5IiLCJuYXAiOiLiiYkiLCJuYXBFIjoi4qmwzLgiLCJuYXBpZCI6IuKJi8y4IiwibmFwb3MiOiLFiSIsIm5hcHByb3giOiLiiYkiLCJuYXR1cmFsIjoi4pmuIiwibmF0dXJhbHMiOiLihJUiLCJuYXR1ciI6IuKZriIsIm5ic3AiOiLCoCIsIm5idW1wIjoi4omOzLgiLCJuYnVtcGUiOiLiiY/MuCIsIm5jYXAiOiLiqYMiLCJOY2Fyb24iOiLFhyIsIm5jYXJvbiI6IsWIIiwiTmNlZGlsIjoixYUiLCJuY2VkaWwiOiLFhiIsIm5jb25nIjoi4omHIiwibmNvbmdkb3QiOiLiqa3MuCIsIm5jdXAiOiLiqYIiLCJOY3kiOiLQnSIsIm5jeSI6ItC9IiwibmRhc2giOiLigJMiLCJuZWFyaGsiOiLipKQiLCJuZWFyciI6IuKGlyIsIm5lQXJyIjoi4oeXIiwibmVhcnJvdyI6IuKGlyIsIm5lIjoi4omgIiwibmVkb3QiOiLiiZDMuCIsIk5lZ2F0aXZlTWVkaXVtU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaWNrU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaW5TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZSI6IuKAiyIsIm5lcXVpdiI6IuKJoiIsIm5lc2VhciI6IuKkqCIsIm5lc2ltIjoi4omCzLgiLCJOZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKJqyIsIk5lc3RlZExlc3NMZXNzIjoi4omqIiwiTmV3TGluZSI6IlxcbiIsIm5leGlzdCI6IuKIhCIsIm5leGlzdHMiOiLiiIQiLCJOZnIiOiLwnZSRIiwibmZyIjoi8J2UqyIsIm5nRSI6IuKJp8y4IiwibmdlIjoi4omxIiwibmdlcSI6IuKJsSIsIm5nZXFxIjoi4omnzLgiLCJuZ2Vxc2xhbnQiOiLiqb7MuCIsIm5nZXMiOiLiqb7MuCIsIm5HZyI6IuKLmcy4IiwibmdzaW0iOiLiibUiLCJuR3QiOiLiiavig5IiLCJuZ3QiOiLiia8iLCJuZ3RyIjoi4omvIiwibkd0diI6IuKJq8y4IiwibmhhcnIiOiLihq4iLCJuaEFyciI6IuKHjiIsIm5ocGFyIjoi4quyIiwibmkiOiLiiIsiLCJuaXMiOiLii7wiLCJuaXNkIjoi4ou6Iiwibml2Ijoi4oiLIiwiTkpjeSI6ItCKIiwibmpjeSI6ItGaIiwibmxhcnIiOiLihpoiLCJubEFyciI6IuKHjSIsIm5sZHIiOiLigKUiLCJubEUiOiLiiabMuCIsIm5sZSI6IuKJsCIsIm5sZWZ0YXJyb3ciOiLihpoiLCJuTGVmdGFycm93Ijoi4oeNIiwibmxlZnRyaWdodGFycm93Ijoi4oauIiwibkxlZnRyaWdodGFycm93Ijoi4oeOIiwibmxlcSI6IuKJsCIsIm5sZXFxIjoi4ommzLgiLCJubGVxc2xhbnQiOiLiqb3MuCIsIm5sZXMiOiLiqb3MuCIsIm5sZXNzIjoi4omuIiwibkxsIjoi4ouYzLgiLCJubHNpbSI6IuKJtCIsIm5MdCI6IuKJquKDkiIsIm5sdCI6IuKJriIsIm5sdHJpIjoi4ouqIiwibmx0cmllIjoi4ousIiwibkx0diI6IuKJqsy4Iiwibm1pZCI6IuKIpCIsIk5vQnJlYWsiOiLigaAiLCJOb25CcmVha2luZ1NwYWNlIjoiwqAiLCJub3BmIjoi8J2VnyIsIk5vcGYiOiLihJUiLCJOb3QiOiLiq6wiLCJub3QiOiLCrCIsIk5vdENvbmdydWVudCI6IuKJoiIsIk5vdEN1cENhcCI6IuKJrSIsIk5vdERvdWJsZVZlcnRpY2FsQmFyIjoi4oimIiwiTm90RWxlbWVudCI6IuKIiSIsIk5vdEVxdWFsIjoi4omgIiwiTm90RXF1YWxUaWxkZSI6IuKJgsy4IiwiTm90RXhpc3RzIjoi4oiEIiwiTm90R3JlYXRlciI6IuKJryIsIk5vdEdyZWF0ZXJFcXVhbCI6IuKJsSIsIk5vdEdyZWF0ZXJGdWxsRXF1YWwiOiLiiafMuCIsIk5vdEdyZWF0ZXJHcmVhdGVyIjoi4omrzLgiLCJOb3RHcmVhdGVyTGVzcyI6IuKJuSIsIk5vdEdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+zLgiLCJOb3RHcmVhdGVyVGlsZGUiOiLiibUiLCJOb3RIdW1wRG93bkh1bXAiOiLiiY7MuCIsIk5vdEh1bXBFcXVhbCI6IuKJj8y4Iiwibm90aW4iOiLiiIkiLCJub3RpbmRvdCI6IuKLtcy4Iiwibm90aW5FIjoi4ou5zLgiLCJub3RpbnZhIjoi4oiJIiwibm90aW52YiI6IuKLtyIsIm5vdGludmMiOiLii7YiLCJOb3RMZWZ0VHJpYW5nbGVCYXIiOiLip4/MuCIsIk5vdExlZnRUcmlhbmdsZSI6IuKLqiIsIk5vdExlZnRUcmlhbmdsZUVxdWFsIjoi4ousIiwiTm90TGVzcyI6IuKJriIsIk5vdExlc3NFcXVhbCI6IuKJsCIsIk5vdExlc3NHcmVhdGVyIjoi4om4IiwiTm90TGVzc0xlc3MiOiLiiarMuCIsIk5vdExlc3NTbGFudEVxdWFsIjoi4qm9zLgiLCJOb3RMZXNzVGlsZGUiOiLiibQiLCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKqosy4IiwiTm90TmVzdGVkTGVzc0xlc3MiOiLiqqHMuCIsIm5vdG5pIjoi4oiMIiwibm90bml2YSI6IuKIjCIsIm5vdG5pdmIiOiLii74iLCJub3RuaXZjIjoi4ou9IiwiTm90UHJlY2VkZXMiOiLiioAiLCJOb3RQcmVjZWRlc0VxdWFsIjoi4qqvzLgiLCJOb3RQcmVjZWRlc1NsYW50RXF1YWwiOiLii6AiLCJOb3RSZXZlcnNlRWxlbWVudCI6IuKIjCIsIk5vdFJpZ2h0VHJpYW5nbGVCYXIiOiLip5DMuCIsIk5vdFJpZ2h0VHJpYW5nbGUiOiLii6siLCJOb3RSaWdodFRyaWFuZ2xlRXF1YWwiOiLii60iLCJOb3RTcXVhcmVTdWJzZXQiOiLiio/MuCIsIk5vdFNxdWFyZVN1YnNldEVxdWFsIjoi4ouiIiwiTm90U3F1YXJlU3VwZXJzZXQiOiLiipDMuCIsIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWwiOiLii6MiLCJOb3RTdWJzZXQiOiLiioLig5IiLCJOb3RTdWJzZXRFcXVhbCI6IuKKiCIsIk5vdFN1Y2NlZWRzIjoi4oqBIiwiTm90U3VjY2VlZHNFcXVhbCI6IuKqsMy4IiwiTm90U3VjY2VlZHNTbGFudEVxdWFsIjoi4ouhIiwiTm90U3VjY2VlZHNUaWxkZSI6IuKJv8y4IiwiTm90U3VwZXJzZXQiOiLiioPig5IiLCJOb3RTdXBlcnNldEVxdWFsIjoi4oqJIiwiTm90VGlsZGUiOiLiiYEiLCJOb3RUaWxkZUVxdWFsIjoi4omEIiwiTm90VGlsZGVGdWxsRXF1YWwiOiLiiYciLCJOb3RUaWxkZVRpbGRlIjoi4omJIiwiTm90VmVydGljYWxCYXIiOiLiiKQiLCJucGFyYWxsZWwiOiLiiKYiLCJucGFyIjoi4oimIiwibnBhcnNsIjoi4qu94oOlIiwibnBhcnQiOiLiiILMuCIsIm5wb2xpbnQiOiLiqJQiLCJucHIiOiLiioAiLCJucHJjdWUiOiLii6AiLCJucHJlYyI6IuKKgCIsIm5wcmVjZXEiOiLiqq/MuCIsIm5wcmUiOiLiqq/MuCIsIm5yYXJyYyI6IuKks8y4IiwibnJhcnIiOiLihpsiLCJuckFyciI6IuKHjyIsIm5yYXJydyI6IuKGncy4IiwibnJpZ2h0YXJyb3ciOiLihpsiLCJuUmlnaHRhcnJvdyI6IuKHjyIsIm5ydHJpIjoi4ourIiwibnJ0cmllIjoi4outIiwibnNjIjoi4oqBIiwibnNjY3VlIjoi4ouhIiwibnNjZSI6IuKqsMy4IiwiTnNjciI6IvCdkqkiLCJuc2NyIjoi8J2TgyIsIm5zaG9ydG1pZCI6IuKIpCIsIm5zaG9ydHBhcmFsbGVsIjoi4oimIiwibnNpbSI6IuKJgSIsIm5zaW1lIjoi4omEIiwibnNpbWVxIjoi4omEIiwibnNtaWQiOiLiiKQiLCJuc3BhciI6IuKIpiIsIm5zcXN1YmUiOiLii6IiLCJuc3FzdXBlIjoi4oujIiwibnN1YiI6IuKKhCIsIm5zdWJFIjoi4quFzLgiLCJuc3ViZSI6IuKKiCIsIm5zdWJzZXQiOiLiioLig5IiLCJuc3Vic2V0ZXEiOiLiiogiLCJuc3Vic2V0ZXFxIjoi4quFzLgiLCJuc3VjYyI6IuKKgSIsIm5zdWNjZXEiOiLiqrDMuCIsIm5zdXAiOiLiioUiLCJuc3VwRSI6IuKrhsy4IiwibnN1cGUiOiLiiokiLCJuc3Vwc2V0Ijoi4oqD4oOSIiwibnN1cHNldGVxIjoi4oqJIiwibnN1cHNldGVxcSI6IuKrhsy4IiwibnRnbCI6IuKJuSIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJudGxnIjoi4om4IiwibnRyaWFuZ2xlbGVmdCI6IuKLqiIsIm50cmlhbmdsZWxlZnRlcSI6IuKLrCIsIm50cmlhbmdsZXJpZ2h0Ijoi4ourIiwibnRyaWFuZ2xlcmlnaHRlcSI6IuKLrSIsIk51Ijoizp0iLCJudSI6Is69IiwibnVtIjoiIyIsIm51bWVybyI6IuKEliIsIm51bXNwIjoi4oCHIiwibnZhcCI6IuKJjeKDkiIsIm52ZGFzaCI6IuKKrCIsIm52RGFzaCI6IuKKrSIsIm5WZGFzaCI6IuKKriIsIm5WRGFzaCI6IuKKryIsIm52Z2UiOiLiiaXig5IiLCJudmd0IjoiPuKDkiIsIm52SGFyciI6IuKkhCIsIm52aW5maW4iOiLip54iLCJudmxBcnIiOiLipIIiLCJudmxlIjoi4omk4oOSIiwibnZsdCI6Ijzig5IiLCJudmx0cmllIjoi4oq04oOSIiwibnZyQXJyIjoi4qSDIiwibnZydHJpZSI6IuKKteKDkiIsIm52c2ltIjoi4oi84oOSIiwibndhcmhrIjoi4qSjIiwibndhcnIiOiLihpYiLCJud0FyciI6IuKHliIsIm53YXJyb3ciOiLihpYiLCJud25lYXIiOiLipKciLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwib2FzdCI6IuKKmyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0Iiwib2NpciI6IuKKmiIsIk9jeSI6ItCeIiwib2N5Ijoi0L4iLCJvZGFzaCI6IuKKnSIsIk9kYmxhYyI6IsWQIiwib2RibGFjIjoixZEiLCJvZGl2Ijoi4qi4Iiwib2RvdCI6IuKKmSIsIm9kc29sZCI6IuKmvCIsIk9FbGlnIjoixZIiLCJvZWxpZyI6IsWTIiwib2ZjaXIiOiLipr8iLCJPZnIiOiLwnZSSIiwib2ZyIjoi8J2UrCIsIm9nb24iOiLLmyIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvZ3QiOiLip4EiLCJvaGJhciI6IuKmtSIsIm9obSI6Is6pIiwib2ludCI6IuKIriIsIm9sYXJyIjoi4oa6Iiwib2xjaXIiOiLipr4iLCJvbGNyb3NzIjoi4qa7Iiwib2xpbmUiOiLigL4iLCJvbHQiOiLip4AiLCJPbWFjciI6IsWMIiwib21hY3IiOiLFjSIsIk9tZWdhIjoizqkiLCJvbWVnYSI6Is+JIiwiT21pY3JvbiI6Is6fIiwib21pY3JvbiI6Is6/Iiwib21pZCI6IuKmtiIsIm9taW51cyI6IuKKliIsIk9vcGYiOiLwnZWGIiwib29wZiI6IvCdlaAiLCJvcGFyIjoi4qa3IiwiT3BlbkN1cmx5RG91YmxlUXVvdGUiOiLigJwiLCJPcGVuQ3VybHlRdW90ZSI6IuKAmCIsIm9wZXJwIjoi4qa5Iiwib3BsdXMiOiLiipUiLCJvcmFyciI6IuKGuyIsIk9yIjoi4qmUIiwib3IiOiLiiKgiLCJvcmQiOiLiqZ0iLCJvcmRlciI6IuKEtCIsIm9yZGVyb2YiOiLihLQiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJvcmlnb2YiOiLiirYiLCJvcm9yIjoi4qmWIiwib3JzbG9wZSI6IuKplyIsIm9ydiI6IuKpmyIsIm9TIjoi4pOIIiwiT3NjciI6IvCdkqoiLCJvc2NyIjoi4oS0IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIm9zb2wiOiLiipgiLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1Iiwib3RpbWVzYXMiOiLiqLYiLCJPdGltZXMiOiLiqLciLCJvdGltZXMiOiLiipciLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJvdmJhciI6IuKMvSIsIk92ZXJCYXIiOiLigL4iLCJPdmVyQnJhY2UiOiLij54iLCJPdmVyQnJhY2tldCI6IuKOtCIsIk92ZXJQYXJlbnRoZXNpcyI6IuKPnCIsInBhcmEiOiLCtiIsInBhcmFsbGVsIjoi4oilIiwicGFyIjoi4oilIiwicGFyc2ltIjoi4quzIiwicGFyc2wiOiLiq70iLCJwYXJ0Ijoi4oiCIiwiUGFydGlhbEQiOiLiiIIiLCJQY3kiOiLQnyIsInBjeSI6ItC/IiwicGVyY250IjoiJSIsInBlcmlvZCI6Ii4iLCJwZXJtaWwiOiLigLAiLCJwZXJwIjoi4oqlIiwicGVydGVuayI6IuKAsSIsIlBmciI6IvCdlJMiLCJwZnIiOiLwnZStIiwiUGhpIjoizqYiLCJwaGkiOiLPhiIsInBoaXYiOiLPlSIsInBobW1hdCI6IuKEsyIsInBob25lIjoi4piOIiwiUGkiOiLOoCIsInBpIjoiz4AiLCJwaXRjaGZvcmsiOiLii5QiLCJwaXYiOiLPliIsInBsYW5jayI6IuKEjyIsInBsYW5ja2giOiLihI4iLCJwbGFua3YiOiLihI8iLCJwbHVzYWNpciI6IuKooyIsInBsdXNiIjoi4oqeIiwicGx1c2NpciI6IuKooiIsInBsdXMiOiIrIiwicGx1c2RvIjoi4oiUIiwicGx1c2R1Ijoi4qilIiwicGx1c2UiOiLiqbIiLCJQbHVzTWludXMiOiLCsSIsInBsdXNtbiI6IsKxIiwicGx1c3NpbSI6IuKopiIsInBsdXN0d28iOiLiqKciLCJwbSI6IsKxIiwiUG9pbmNhcmVwbGFuZSI6IuKEjCIsInBvaW50aW50Ijoi4qiVIiwicG9wZiI6IvCdlaEiLCJQb3BmIjoi4oSZIiwicG91bmQiOiLCoyIsInByYXAiOiLiqrciLCJQciI6IuKquyIsInByIjoi4om6IiwicHJjdWUiOiLiibwiLCJwcmVjYXBwcm94Ijoi4qq3IiwicHJlYyI6IuKJuiIsInByZWNjdXJseWVxIjoi4om8IiwiUHJlY2VkZXMiOiLiiboiLCJQcmVjZWRlc0VxdWFsIjoi4qqvIiwiUHJlY2VkZXNTbGFudEVxdWFsIjoi4om8IiwiUHJlY2VkZXNUaWxkZSI6IuKJviIsInByZWNlcSI6IuKqryIsInByZWNuYXBwcm94Ijoi4qq5IiwicHJlY25lcXEiOiLiqrUiLCJwcmVjbnNpbSI6IuKLqCIsInByZSI6IuKqryIsInByRSI6IuKqsyIsInByZWNzaW0iOiLiib4iLCJwcmltZSI6IuKAsiIsIlByaW1lIjoi4oCzIiwicHJpbWVzIjoi4oSZIiwicHJuYXAiOiLiqrkiLCJwcm5FIjoi4qq1IiwicHJuc2ltIjoi4ouoIiwicHJvZCI6IuKIjyIsIlByb2R1Y3QiOiLiiI8iLCJwcm9mYWxhciI6IuKMriIsInByb2ZsaW5lIjoi4oySIiwicHJvZnN1cmYiOiLijJMiLCJwcm9wIjoi4oidIiwiUHJvcG9ydGlvbmFsIjoi4oidIiwiUHJvcG9ydGlvbiI6IuKItyIsInByb3B0byI6IuKInSIsInByc2ltIjoi4om+IiwicHJ1cmVsIjoi4oqwIiwiUHNjciI6IvCdkqsiLCJwc2NyIjoi8J2ThSIsIlBzaSI6Is6oIiwicHNpIjoiz4giLCJwdW5jc3AiOiLigIgiLCJRZnIiOiLwnZSUIiwicWZyIjoi8J2UriIsInFpbnQiOiLiqIwiLCJxb3BmIjoi8J2VoiIsIlFvcGYiOiLihJoiLCJxcHJpbWUiOiLigZciLCJRc2NyIjoi8J2SrCIsInFzY3IiOiLwnZOGIiwicXVhdGVybmlvbnMiOiLihI0iLCJxdWF0aW50Ijoi4qiWIiwicXVlc3QiOiI/IiwicXVlc3RlcSI6IuKJnyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwickFhcnIiOiLih5siLCJyYWNlIjoi4oi9zLEiLCJSYWN1dGUiOiLFlCIsInJhY3V0ZSI6IsWVIiwicmFkaWMiOiLiiJoiLCJyYWVtcHR5diI6IuKmsyIsInJhbmciOiLin6kiLCJSYW5nIjoi4p+rIiwicmFuZ2QiOiLippIiLCJyYW5nZSI6IuKmpSIsInJhbmdsZSI6IuKfqSIsInJhcXVvIjoiwrsiLCJyYXJyYXAiOiLipbUiLCJyYXJyYiI6IuKHpSIsInJhcnJiZnMiOiLipKAiLCJyYXJyYyI6IuKksyIsInJhcnIiOiLihpIiLCJSYXJyIjoi4oagIiwickFyciI6IuKHkiIsInJhcnJmcyI6IuKkniIsInJhcnJoayI6IuKGqiIsInJhcnJscCI6IuKGrCIsInJhcnJwbCI6IuKlhSIsInJhcnJzaW0iOiLipbQiLCJSYXJydGwiOiLipJYiLCJyYXJydGwiOiLihqMiLCJyYXJydyI6IuKGnSIsInJhdGFpbCI6IuKkmiIsInJBdGFpbCI6IuKknCIsInJhdGlvIjoi4oi2IiwicmF0aW9uYWxzIjoi4oSaIiwicmJhcnIiOiLipI0iLCJyQmFyciI6IuKkjyIsIlJCYXJyIjoi4qSQIiwicmJicmsiOiLinbMiLCJyYnJhY2UiOiJ9IiwicmJyYWNrIjoiXSIsInJicmtlIjoi4qaMIiwicmJya3NsZCI6IuKmjiIsInJicmtzbHUiOiLippAiLCJSY2Fyb24iOiLFmCIsInJjYXJvbiI6IsWZIiwiUmNlZGlsIjoixZYiLCJyY2VkaWwiOiLFlyIsInJjZWlsIjoi4oyJIiwicmN1YiI6In0iLCJSY3kiOiLQoCIsInJjeSI6ItGAIiwicmRjYSI6IuKktyIsInJkbGRoYXIiOiLipakiLCJyZHF1byI6IuKAnSIsInJkcXVvciI6IuKAnSIsInJkc2giOiLihrMiLCJyZWFsIjoi4oScIiwicmVhbGluZSI6IuKEmyIsInJlYWxwYXJ0Ijoi4oScIiwicmVhbHMiOiLihJ0iLCJSZSI6IuKEnCIsInJlY3QiOiLilq0iLCJyZWciOiLCriIsIlJFRyI6IsKuIiwiUmV2ZXJzZUVsZW1lbnQiOiLiiIsiLCJSZXZlcnNlRXF1aWxpYnJpdW0iOiLih4siLCJSZXZlcnNlVXBFcXVpbGlicml1bSI6IuKlryIsInJmaXNodCI6IuKlvSIsInJmbG9vciI6IuKMiyIsInJmciI6IvCdlK8iLCJSZnIiOiLihJwiLCJySGFyIjoi4qWkIiwicmhhcmQiOiLih4EiLCJyaGFydSI6IuKHgCIsInJoYXJ1bCI6IuKlrCIsIlJobyI6Is6hIiwicmhvIjoiz4EiLCJyaG92Ijoiz7EiLCJSaWdodEFuZ2xlQnJhY2tldCI6IuKfqSIsIlJpZ2h0QXJyb3dCYXIiOiLih6UiLCJyaWdodGFycm93Ijoi4oaSIiwiUmlnaHRBcnJvdyI6IuKGkiIsIlJpZ2h0YXJyb3ciOiLih5IiLCJSaWdodEFycm93TGVmdEFycm93Ijoi4oeEIiwicmlnaHRhcnJvd3RhaWwiOiLihqMiLCJSaWdodENlaWxpbmciOiLijIkiLCJSaWdodERvdWJsZUJyYWNrZXQiOiLin6ciLCJSaWdodERvd25UZWVWZWN0b3IiOiLipZ0iLCJSaWdodERvd25WZWN0b3JCYXIiOiLipZUiLCJSaWdodERvd25WZWN0b3IiOiLih4IiLCJSaWdodEZsb29yIjoi4oyLIiwicmlnaHRoYXJwb29uZG93biI6IuKHgSIsInJpZ2h0aGFycG9vbnVwIjoi4oeAIiwicmlnaHRsZWZ0YXJyb3dzIjoi4oeEIiwicmlnaHRsZWZ0aGFycG9vbnMiOiLih4wiLCJyaWdodHJpZ2h0YXJyb3dzIjoi4oeJIiwicmlnaHRzcXVpZ2Fycm93Ijoi4oadIiwiUmlnaHRUZWVBcnJvdyI6IuKGpiIsIlJpZ2h0VGVlIjoi4oqiIiwiUmlnaHRUZWVWZWN0b3IiOiLipZsiLCJyaWdodHRocmVldGltZXMiOiLii4wiLCJSaWdodFRyaWFuZ2xlQmFyIjoi4qeQIiwiUmlnaHRUcmlhbmdsZSI6IuKKsyIsIlJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKKtSIsIlJpZ2h0VXBEb3duVmVjdG9yIjoi4qWPIiwiUmlnaHRVcFRlZVZlY3RvciI6IuKlnCIsIlJpZ2h0VXBWZWN0b3JCYXIiOiLipZQiLCJSaWdodFVwVmVjdG9yIjoi4oa+IiwiUmlnaHRWZWN0b3JCYXIiOiLipZMiLCJSaWdodFZlY3RvciI6IuKHgCIsInJpbmciOiLLmiIsInJpc2luZ2RvdHNlcSI6IuKJkyIsInJsYXJyIjoi4oeEIiwicmxoYXIiOiLih4wiLCJybG0iOiLigI8iLCJybW91c3RhY2hlIjoi4o6xIiwicm1vdXN0Ijoi4o6xIiwicm5taWQiOiLiq64iLCJyb2FuZyI6IuKfrSIsInJvYXJyIjoi4oe+Iiwicm9icmsiOiLin6ciLCJyb3BhciI6IuKmhiIsInJvcGYiOiLwnZWjIiwiUm9wZiI6IuKEnSIsInJvcGx1cyI6IuKoriIsInJvdGltZXMiOiLiqLUiLCJSb3VuZEltcGxpZXMiOiLipbAiLCJycGFyIjoiKSIsInJwYXJndCI6IuKmlCIsInJwcG9saW50Ijoi4qiSIiwicnJhcnIiOiLih4kiLCJScmlnaHRhcnJvdyI6IuKHmyIsInJzYXF1byI6IuKAuiIsInJzY3IiOiLwnZOHIiwiUnNjciI6IuKEmyIsInJzaCI6IuKGsSIsIlJzaCI6IuKGsSIsInJzcWIiOiJdIiwicnNxdW8iOiLigJkiLCJyc3F1b3IiOiLigJkiLCJydGhyZWUiOiLii4wiLCJydGltZXMiOiLii4oiLCJydHJpIjoi4pa5IiwicnRyaWUiOiLiirUiLCJydHJpZiI6IuKWuCIsInJ0cmlsdHJpIjoi4qeOIiwiUnVsZURlbGF5ZWQiOiLip7QiLCJydWx1aGFyIjoi4qWoIiwicngiOiLihJ4iLCJTYWN1dGUiOiLFmiIsInNhY3V0ZSI6IsWbIiwic2JxdW8iOiLigJoiLCJzY2FwIjoi4qq4IiwiU2Nhcm9uIjoixaAiLCJzY2Fyb24iOiLFoSIsIlNjIjoi4qq8Iiwic2MiOiLiibsiLCJzY2N1ZSI6IuKJvSIsInNjZSI6IuKqsCIsInNjRSI6IuKqtCIsIlNjZWRpbCI6IsWeIiwic2NlZGlsIjoixZ8iLCJTY2lyYyI6IsWcIiwic2NpcmMiOiLFnSIsInNjbmFwIjoi4qq6Iiwic2NuRSI6IuKqtiIsInNjbnNpbSI6IuKLqSIsInNjcG9saW50Ijoi4qiTIiwic2NzaW0iOiLiib8iLCJTY3kiOiLQoSIsInNjeSI6ItGBIiwic2RvdGIiOiLiiqEiLCJzZG90Ijoi4ouFIiwic2RvdGUiOiLiqaYiLCJzZWFyaGsiOiLipKUiLCJzZWFyciI6IuKGmCIsInNlQXJyIjoi4oeYIiwic2VhcnJvdyI6IuKGmCIsInNlY3QiOiLCpyIsInNlbWkiOiI7Iiwic2Vzd2FyIjoi4qSpIiwic2V0bWludXMiOiLiiJYiLCJzZXRtbiI6IuKIliIsInNleHQiOiLinLYiLCJTZnIiOiLwnZSWIiwic2ZyIjoi8J2UsCIsInNmcm93biI6IuKMoiIsInNoYXJwIjoi4pmvIiwiU0hDSGN5Ijoi0KkiLCJzaGNoY3kiOiLRiSIsIlNIY3kiOiLQqCIsInNoY3kiOiLRiCIsIlNob3J0RG93bkFycm93Ijoi4oaTIiwiU2hvcnRMZWZ0QXJyb3ciOiLihpAiLCJzaG9ydG1pZCI6IuKIoyIsInNob3J0cGFyYWxsZWwiOiLiiKUiLCJTaG9ydFJpZ2h0QXJyb3ciOiLihpIiLCJTaG9ydFVwQXJyb3ciOiLihpEiLCJzaHkiOiLCrSIsIlNpZ21hIjoizqMiLCJzaWdtYSI6Is+DIiwic2lnbWFmIjoiz4IiLCJzaWdtYXYiOiLPgiIsInNpbSI6IuKIvCIsInNpbWRvdCI6IuKpqiIsInNpbWUiOiLiiYMiLCJzaW1lcSI6IuKJgyIsInNpbWciOiLiqp4iLCJzaW1nRSI6IuKqoCIsInNpbWwiOiLiqp0iLCJzaW1sRSI6IuKqnyIsInNpbW5lIjoi4omGIiwic2ltcGx1cyI6IuKopCIsInNpbXJhcnIiOiLipbIiLCJzbGFyciI6IuKGkCIsIlNtYWxsQ2lyY2xlIjoi4oiYIiwic21hbGxzZXRtaW51cyI6IuKIliIsInNtYXNocCI6IuKosyIsInNtZXBhcnNsIjoi4qekIiwic21pZCI6IuKIoyIsInNtaWxlIjoi4oyjIiwic210Ijoi4qqqIiwic210ZSI6IuKqrCIsInNtdGVzIjoi4qqs77iAIiwiU09GVGN5Ijoi0KwiLCJzb2Z0Y3kiOiLRjCIsInNvbGJhciI6IuKMvyIsInNvbGIiOiLip4QiLCJzb2wiOiIvIiwiU29wZiI6IvCdlYoiLCJzb3BmIjoi8J2VpCIsInNwYWRlcyI6IuKZoCIsInNwYWRlc3VpdCI6IuKZoCIsInNwYXIiOiLiiKUiLCJzcWNhcCI6IuKKkyIsInNxY2FwcyI6IuKKk++4gCIsInNxY3VwIjoi4oqUIiwic3FjdXBzIjoi4oqU77iAIiwiU3FydCI6IuKImiIsInNxc3ViIjoi4oqPIiwic3FzdWJlIjoi4oqRIiwic3FzdWJzZXQiOiLiio8iLCJzcXN1YnNldGVxIjoi4oqRIiwic3FzdXAiOiLiipAiLCJzcXN1cGUiOiLiipIiLCJzcXN1cHNldCI6IuKKkCIsInNxc3Vwc2V0ZXEiOiLiipIiLCJzcXVhcmUiOiLilqEiLCJTcXVhcmUiOiLilqEiLCJTcXVhcmVJbnRlcnNlY3Rpb24iOiLiipMiLCJTcXVhcmVTdWJzZXQiOiLiio8iLCJTcXVhcmVTdWJzZXRFcXVhbCI6IuKKkSIsIlNxdWFyZVN1cGVyc2V0Ijoi4oqQIiwiU3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKKkiIsIlNxdWFyZVVuaW9uIjoi4oqUIiwic3F1YXJmIjoi4paqIiwic3F1Ijoi4pahIiwic3F1ZiI6IuKWqiIsInNyYXJyIjoi4oaSIiwiU3NjciI6IvCdkq4iLCJzc2NyIjoi8J2TiCIsInNzZXRtbiI6IuKIliIsInNzbWlsZSI6IuKMoyIsInNzdGFyZiI6IuKLhiIsIlN0YXIiOiLii4YiLCJzdGFyIjoi4piGIiwic3RhcmYiOiLimIUiLCJzdHJhaWdodGVwc2lsb24iOiLPtSIsInN0cmFpZ2h0cGhpIjoiz5UiLCJzdHJucyI6IsKvIiwic3ViIjoi4oqCIiwiU3ViIjoi4ouQIiwic3ViZG90Ijoi4qq9Iiwic3ViRSI6IuKrhSIsInN1YmUiOiLiioYiLCJzdWJlZG90Ijoi4quDIiwic3VibXVsdCI6IuKrgSIsInN1Ym5FIjoi4quLIiwic3VibmUiOiLiiooiLCJzdWJwbHVzIjoi4qq/Iiwic3VicmFyciI6IuKluSIsInN1YnNldCI6IuKKgiIsIlN1YnNldCI6IuKLkCIsInN1YnNldGVxIjoi4oqGIiwic3Vic2V0ZXFxIjoi4quFIiwiU3Vic2V0RXF1YWwiOiLiioYiLCJzdWJzZXRuZXEiOiLiiooiLCJzdWJzZXRuZXFxIjoi4quLIiwic3Vic2ltIjoi4quHIiwic3Vic3ViIjoi4quVIiwic3Vic3VwIjoi4quTIiwic3VjY2FwcHJveCI6IuKquCIsInN1Y2MiOiLiibsiLCJzdWNjY3VybHllcSI6IuKJvSIsIlN1Y2NlZWRzIjoi4om7IiwiU3VjY2VlZHNFcXVhbCI6IuKqsCIsIlN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKJvSIsIlN1Y2NlZWRzVGlsZGUiOiLiib8iLCJzdWNjZXEiOiLiqrAiLCJzdWNjbmFwcHJveCI6IuKquiIsInN1Y2NuZXFxIjoi4qq2Iiwic3VjY25zaW0iOiLii6kiLCJzdWNjc2ltIjoi4om/IiwiU3VjaFRoYXQiOiLiiIsiLCJzdW0iOiLiiJEiLCJTdW0iOiLiiJEiLCJzdW5nIjoi4pmqIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3VwIjoi4oqDIiwiU3VwIjoi4ouRIiwic3VwZG90Ijoi4qq+Iiwic3VwZHN1YiI6IuKrmCIsInN1cEUiOiLiq4YiLCJzdXBlIjoi4oqHIiwic3VwZWRvdCI6IuKrhCIsIlN1cGVyc2V0Ijoi4oqDIiwiU3VwZXJzZXRFcXVhbCI6IuKKhyIsInN1cGhzb2wiOiLin4kiLCJzdXBoc3ViIjoi4quXIiwic3VwbGFyciI6IuKluyIsInN1cG11bHQiOiLiq4IiLCJzdXBuRSI6IuKrjCIsInN1cG5lIjoi4oqLIiwic3VwcGx1cyI6IuKrgCIsInN1cHNldCI6IuKKgyIsIlN1cHNldCI6IuKLkSIsInN1cHNldGVxIjoi4oqHIiwic3Vwc2V0ZXFxIjoi4quGIiwic3Vwc2V0bmVxIjoi4oqLIiwic3Vwc2V0bmVxcSI6IuKrjCIsInN1cHNpbSI6IuKriCIsInN1cHN1YiI6IuKrlCIsInN1cHN1cCI6IuKrliIsInN3YXJoayI6IuKkpiIsInN3YXJyIjoi4oaZIiwic3dBcnIiOiLih5kiLCJzd2Fycm93Ijoi4oaZIiwic3dud2FyIjoi4qSqIiwic3psaWciOiLDnyIsIlRhYiI6IlxcdCIsInRhcmdldCI6IuKMliIsIlRhdSI6Is6kIiwidGF1Ijoiz4QiLCJ0YnJrIjoi4o60IiwiVGNhcm9uIjoixaQiLCJ0Y2Fyb24iOiLFpSIsIlRjZWRpbCI6IsWiIiwidGNlZGlsIjoixaMiLCJUY3kiOiLQoiIsInRjeSI6ItGCIiwidGRvdCI6IuKDmyIsInRlbHJlYyI6IuKMlSIsIlRmciI6IvCdlJciLCJ0ZnIiOiLwnZSxIiwidGhlcmU0Ijoi4oi0IiwidGhlcmVmb3JlIjoi4oi0IiwiVGhlcmVmb3JlIjoi4oi0IiwiVGhldGEiOiLOmCIsInRoZXRhIjoizrgiLCJ0aGV0YXN5bSI6Is+RIiwidGhldGF2Ijoiz5EiLCJ0aGlja2FwcHJveCI6IuKJiCIsInRoaWNrc2ltIjoi4oi8IiwiVGhpY2tTcGFjZSI6IuKBn+KAiiIsIlRoaW5TcGFjZSI6IuKAiSIsInRoaW5zcCI6IuKAiSIsInRoa2FwIjoi4omIIiwidGhrc2ltIjoi4oi8IiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aWxkZSI6IsucIiwiVGlsZGUiOiLiiLwiLCJUaWxkZUVxdWFsIjoi4omDIiwiVGlsZGVGdWxsRXF1YWwiOiLiiYUiLCJUaWxkZVRpbGRlIjoi4omIIiwidGltZXNiYXIiOiLiqLEiLCJ0aW1lc2IiOiLiiqAiLCJ0aW1lcyI6IsOXIiwidGltZXNkIjoi4qiwIiwidGludCI6IuKIrSIsInRvZWEiOiLipKgiLCJ0b3Bib3QiOiLijLYiLCJ0b3BjaXIiOiLiq7EiLCJ0b3AiOiLiiqQiLCJUb3BmIjoi8J2ViyIsInRvcGYiOiLwnZWlIiwidG9wZm9yayI6IuKrmiIsInRvc2EiOiLipKkiLCJ0cHJpbWUiOiLigLQiLCJ0cmFkZSI6IuKEoiIsIlRSQURFIjoi4oSiIiwidHJpYW5nbGUiOiLilrUiLCJ0cmlhbmdsZWRvd24iOiLilr8iLCJ0cmlhbmdsZWxlZnQiOiLil4MiLCJ0cmlhbmdsZWxlZnRlcSI6IuKKtCIsInRyaWFuZ2xlcSI6IuKJnCIsInRyaWFuZ2xlcmlnaHQiOiLilrkiLCJ0cmlhbmdsZXJpZ2h0ZXEiOiLiirUiLCJ0cmlkb3QiOiLil6wiLCJ0cmllIjoi4omcIiwidHJpbWludXMiOiLiqLoiLCJUcmlwbGVEb3QiOiLig5siLCJ0cmlwbHVzIjoi4qi5IiwidHJpc2IiOiLip40iLCJ0cml0aW1lIjoi4qi7IiwidHJwZXppdW0iOiLij6IiLCJUc2NyIjoi8J2SryIsInRzY3IiOiLwnZOJIiwiVFNjeSI6ItCmIiwidHNjeSI6ItGGIiwiVFNIY3kiOiLQiyIsInRzaGN5Ijoi0ZsiLCJUc3Ryb2siOiLFpiIsInRzdHJvayI6IsWnIiwidHdpeHQiOiLiiawiLCJ0d29oZWFkbGVmdGFycm93Ijoi4oaeIiwidHdvaGVhZHJpZ2h0YXJyb3ciOiLihqAiLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwidWFyciI6IuKGkSIsIlVhcnIiOiLihp8iLCJ1QXJyIjoi4oeRIiwiVWFycm9jaXIiOiLipYkiLCJVYnJjeSI6ItCOIiwidWJyY3kiOiLRniIsIlVicmV2ZSI6IsWsIiwidWJyZXZlIjoixa0iLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVjeSI6ItCjIiwidWN5Ijoi0YMiLCJ1ZGFyciI6IuKHhSIsIlVkYmxhYyI6IsWwIiwidWRibGFjIjoixbEiLCJ1ZGhhciI6IuKlriIsInVmaXNodCI6IuKlviIsIlVmciI6IvCdlJgiLCJ1ZnIiOiLwnZSyIiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVIYXIiOiLipaMiLCJ1aGFybCI6IuKGvyIsInVoYXJyIjoi4oa+IiwidWhibGsiOiLiloAiLCJ1bGNvcm4iOiLijJwiLCJ1bGNvcm5lciI6IuKMnCIsInVsY3JvcCI6IuKMjyIsInVsdHJpIjoi4pe4IiwiVW1hY3IiOiLFqiIsInVtYWNyIjoixasiLCJ1bWwiOiLCqCIsIlVuZGVyQmFyIjoiXyIsIlVuZGVyQnJhY2UiOiLij58iLCJVbmRlckJyYWNrZXQiOiLijrUiLCJVbmRlclBhcmVudGhlc2lzIjoi4o+dIiwiVW5pb24iOiLii4MiLCJVbmlvblBsdXMiOiLiio4iLCJVb2dvbiI6IsWyIiwidW9nb24iOiLFsyIsIlVvcGYiOiLwnZWMIiwidW9wZiI6IvCdlaYiLCJVcEFycm93QmFyIjoi4qSSIiwidXBhcnJvdyI6IuKGkSIsIlVwQXJyb3ciOiLihpEiLCJVcGFycm93Ijoi4oeRIiwiVXBBcnJvd0Rvd25BcnJvdyI6IuKHhSIsInVwZG93bmFycm93Ijoi4oaVIiwiVXBEb3duQXJyb3ciOiLihpUiLCJVcGRvd25hcnJvdyI6IuKHlSIsIlVwRXF1aWxpYnJpdW0iOiLipa4iLCJ1cGhhcnBvb25sZWZ0Ijoi4oa/IiwidXBoYXJwb29ucmlnaHQiOiLihr4iLCJ1cGx1cyI6IuKKjiIsIlVwcGVyTGVmdEFycm93Ijoi4oaWIiwiVXBwZXJSaWdodEFycm93Ijoi4oaXIiwidXBzaSI6Is+FIiwiVXBzaSI6Is+SIiwidXBzaWgiOiLPkiIsIlVwc2lsb24iOiLOpSIsInVwc2lsb24iOiLPhSIsIlVwVGVlQXJyb3ciOiLihqUiLCJVcFRlZSI6IuKKpSIsInVwdXBhcnJvd3MiOiLih4giLCJ1cmNvcm4iOiLijJ0iLCJ1cmNvcm5lciI6IuKMnSIsInVyY3JvcCI6IuKMjiIsIlVyaW5nIjoixa4iLCJ1cmluZyI6IsWvIiwidXJ0cmkiOiLil7kiLCJVc2NyIjoi8J2SsCIsInVzY3IiOiLwnZOKIiwidXRkb3QiOiLii7AiLCJVdGlsZGUiOiLFqCIsInV0aWxkZSI6IsWpIiwidXRyaSI6IuKWtSIsInV0cmlmIjoi4pa0IiwidXVhcnIiOiLih4giLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJ1d2FuZ2xlIjoi4qanIiwidmFuZ3J0Ijoi4qacIiwidmFyZXBzaWxvbiI6Is+1IiwidmFya2FwcGEiOiLPsCIsInZhcm5vdGhpbmciOiLiiIUiLCJ2YXJwaGkiOiLPlSIsInZhcnBpIjoiz5YiLCJ2YXJwcm9wdG8iOiLiiJ0iLCJ2YXJyIjoi4oaVIiwidkFyciI6IuKHlSIsInZhcnJobyI6Is+xIiwidmFyc2lnbWEiOiLPgiIsInZhcnN1YnNldG5lcSI6IuKKiu+4gCIsInZhcnN1YnNldG5lcXEiOiLiq4vvuIAiLCJ2YXJzdXBzZXRuZXEiOiLiiovvuIAiLCJ2YXJzdXBzZXRuZXFxIjoi4quM77iAIiwidmFydGhldGEiOiLPkSIsInZhcnRyaWFuZ2xlbGVmdCI6IuKKsiIsInZhcnRyaWFuZ2xlcmlnaHQiOiLiirMiLCJ2QmFyIjoi4quoIiwiVmJhciI6IuKrqyIsInZCYXJ2Ijoi4qupIiwiVmN5Ijoi0JIiLCJ2Y3kiOiLQsiIsInZkYXNoIjoi4oqiIiwidkRhc2giOiLiiqgiLCJWZGFzaCI6IuKKqSIsIlZEYXNoIjoi4oqrIiwiVmRhc2hsIjoi4qumIiwidmVlYmFyIjoi4oq7IiwidmVlIjoi4oioIiwiVmVlIjoi4ouBIiwidmVlZXEiOiLiiZoiLCJ2ZWxsaXAiOiLii64iLCJ2ZXJiYXIiOiJ8IiwiVmVyYmFyIjoi4oCWIiwidmVydCI6InwiLCJWZXJ0Ijoi4oCWIiwiVmVydGljYWxCYXIiOiLiiKMiLCJWZXJ0aWNhbExpbmUiOiJ8IiwiVmVydGljYWxTZXBhcmF0b3IiOiLinZgiLCJWZXJ0aWNhbFRpbGRlIjoi4omAIiwiVmVyeVRoaW5TcGFjZSI6IuKAiiIsIlZmciI6IvCdlJkiLCJ2ZnIiOiLwnZSzIiwidmx0cmkiOiLiirIiLCJ2bnN1YiI6IuKKguKDkiIsInZuc3VwIjoi4oqD4oOSIiwiVm9wZiI6IvCdlY0iLCJ2b3BmIjoi8J2VpyIsInZwcm9wIjoi4oidIiwidnJ0cmkiOiLiirMiLCJWc2NyIjoi8J2SsSIsInZzY3IiOiLwnZOLIiwidnN1Ym5FIjoi4quL77iAIiwidnN1Ym5lIjoi4oqK77iAIiwidnN1cG5FIjoi4quM77iAIiwidnN1cG5lIjoi4oqL77iAIiwiVnZkYXNoIjoi4oqqIiwidnppZ3phZyI6IuKmmiIsIldjaXJjIjoixbQiLCJ3Y2lyYyI6IsW1Iiwid2VkYmFyIjoi4qmfIiwid2VkZ2UiOiLiiKciLCJXZWRnZSI6IuKLgCIsIndlZGdlcSI6IuKJmSIsIndlaWVycCI6IuKEmCIsIldmciI6IvCdlJoiLCJ3ZnIiOiLwnZS0IiwiV29wZiI6IvCdlY4iLCJ3b3BmIjoi8J2VqCIsIndwIjoi4oSYIiwid3IiOiLiiYAiLCJ3cmVhdGgiOiLiiYAiLCJXc2NyIjoi8J2SsiIsIndzY3IiOiLwnZOMIiwieGNhcCI6IuKLgiIsInhjaXJjIjoi4pevIiwieGN1cCI6IuKLgyIsInhkdHJpIjoi4pa9IiwiWGZyIjoi8J2UmyIsInhmciI6IvCdlLUiLCJ4aGFyciI6IuKftyIsInhoQXJyIjoi4p+6IiwiWGkiOiLOniIsInhpIjoizr4iLCJ4bGFyciI6IuKftSIsInhsQXJyIjoi4p+4IiwieG1hcCI6IuKfvCIsInhuaXMiOiLii7siLCJ4b2RvdCI6IuKogCIsIlhvcGYiOiLwnZWPIiwieG9wZiI6IvCdlakiLCJ4b3BsdXMiOiLiqIEiLCJ4b3RpbWUiOiLiqIIiLCJ4cmFyciI6IuKftiIsInhyQXJyIjoi4p+5IiwiWHNjciI6IvCdkrMiLCJ4c2NyIjoi8J2TjSIsInhzcWN1cCI6IuKohiIsInh1cGx1cyI6IuKohCIsInh1dHJpIjoi4pazIiwieHZlZSI6IuKLgSIsInh3ZWRnZSI6IuKLgCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJZQWN5Ijoi0K8iLCJ5YWN5Ijoi0Y8iLCJZY2lyYyI6IsW2IiwieWNpcmMiOiLFtyIsIlljeSI6ItCrIiwieWN5Ijoi0YsiLCJ5ZW4iOiLCpSIsIllmciI6IvCdlJwiLCJ5ZnIiOiLwnZS2IiwiWUljeSI6ItCHIiwieWljeSI6ItGXIiwiWW9wZiI6IvCdlZAiLCJ5b3BmIjoi8J2VqiIsIllzY3IiOiLwnZK0IiwieXNjciI6IvCdk44iLCJZVWN5Ijoi0K4iLCJ5dWN5Ijoi0Y4iLCJ5dW1sIjoiw78iLCJZdW1sIjoixbgiLCJaYWN1dGUiOiLFuSIsInphY3V0ZSI6IsW6IiwiWmNhcm9uIjoixb0iLCJ6Y2Fyb24iOiLFviIsIlpjeSI6ItCXIiwiemN5Ijoi0LciLCJaZG90IjoixbsiLCJ6ZG90IjoixbwiLCJ6ZWV0cmYiOiLihKgiLCJaZXJvV2lkdGhTcGFjZSI6IuKAiyIsIlpldGEiOiLOliIsInpldGEiOiLOtiIsInpmciI6IvCdlLciLCJaZnIiOiLihKgiLCJaSGN5Ijoi0JYiLCJ6aGN5Ijoi0LYiLCJ6aWdyYXJyIjoi4oedIiwiem9wZiI6IvCdlasiLCJab3BmIjoi4oSkIiwiWnNjciI6IvCdkrUiLCJ6c2NyIjoi8J2TjyIsInp3aiI6IuKAjSIsInp3bmoiOiLigIwifScpfSxmdW5jdGlvbihkKXtkLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJicnZiYXIiOiLCpiIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJjZWRpbCI6IsK4IiwiY2VudCI6IsKiIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY3VycmVuIjoiwqQiLCJkZWciOiLCsCIsImRpdmlkZSI6IsO3IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJmcmFjMTIiOiLCvSIsImZyYWMxNCI6IsK8IiwiZnJhYzM0Ijoiwr4iLCJndCI6Ij4iLCJHVCI6Ij4iLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJpZXhjbCI6IsKhIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlxdWVzdCI6IsK/IiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwibGFxdW8iOiLCqyIsImx0IjoiPCIsIkxUIjoiPCIsIm1hY3IiOiLCryIsIm1pY3JvIjoiwrUiLCJtaWRkb3QiOiLCtyIsIm5ic3AiOiLCoCIsIm5vdCI6IsKsIiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4IiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsInBhcmEiOiLCtiIsInBsdXNtbiI6IsKxIiwicG91bmQiOiLCoyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwicmFxdW8iOiLCuyIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJzZWN0IjoiwqciLCJzaHkiOiLCrSIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN6bGlnIjoiw58iLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbWVzIjoiw5ciLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidW1sIjoiwqgiLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwieWVuIjoiwqUiLCJ5dW1sIjoiw78ifScpfSxmdW5jdGlvbihkKXtkLmV4cG9ydHM9SlNPTi5wYXJzZShgeyJhbXAiOiImIiwiYXBvcyI6IiciLCJndCI6Ij4iLCJsdCI6IjwiLCJxdW90IjoiXFwiIn1gKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihsKXtyZXR1cm4gbCYmbC5fX2VzTW9kdWxlP2w6e2RlZmF1bHQ6bH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj1yKHQoMjY1KSk7ZnVuY3Rpb24gcyhsKXtpZihsPj01NTI5NiYmbDw9NTczNDN8fGw+MTExNDExMSlyZXR1cm4i77+9IjtsIGluIG4uZGVmYXVsdCYmKGw9bi5kZWZhdWx0W2xdKTt2YXIgYz0iIjtyZXR1cm4gbD42NTUzNSYmKGwtPTY1NTM2LGMrPVN0cmluZy5mcm9tQ2hhckNvZGUobD4+PjEwJjEwMjN8NTUyOTYpLGw9NTYzMjB8bCYxMDIzKSxjKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGwpLGN9ZS5kZWZhdWx0PXN9LGZ1bmN0aW9uKGQpe2QuZXhwb3J0cz1KU09OLnBhcnNlKCd7IjAiOjY1NTMzLCIxMjgiOjgzNjQsIjEzMCI6ODIxOCwiMTMxIjo0MDIsIjEzMiI6ODIyMiwiMTMzIjo4MjMwLCIxMzQiOjgyMjQsIjEzNSI6ODIyNSwiMTM2Ijo3MTAsIjEzNyI6ODI0MCwiMTM4IjozNTIsIjEzOSI6ODI0OSwiMTQwIjozMzgsIjE0MiI6MzgxLCIxNDUiOjgyMTYsIjE0NiI6ODIxNywiMTQ3Ijo4MjIwLCIxNDgiOjgyMjEsIjE0OSI6ODIyNiwiMTUwIjo4MjExLCIxNTEiOjgyMTIsIjE1MiI6NzMyLCIxNTMiOjg0ODIsIjE1NCI6MzUzLCIxNTUiOjgyNTAsIjE1NiI6MzM5LCIxNTgiOjM4MiwiMTU5IjozNzZ9Jyl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oUCl7cmV0dXJuIFAmJlAuX19lc01vZHVsZT9QOntkZWZhdWx0OlB9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lc2NhcGU9ZS5lbmNvZGVIVE1MPWUuZW5jb2RlWE1MPXZvaWQgMDt2YXIgbj1yKHQoMjYzKSkscz14KG4uZGVmYXVsdCksbD1nKHMpO2UuZW5jb2RlWE1MPVQocyxsKTt2YXIgYz1yKHQoMjYxKSksbz14KGMuZGVmYXVsdCksZj1nKG8pO2UuZW5jb2RlSFRNTD1UKG8sZik7ZnVuY3Rpb24geChQKXtyZXR1cm4gT2JqZWN0LmtleXMoUCkuc29ydCgpLnJlZHVjZShmdW5jdGlvbihpLHUpe3JldHVybiBpW1BbdV1dPSImIit1KyI7IixpfSx7fSl9ZnVuY3Rpb24gZyhQKXtmb3IodmFyIGk9W10sdT1bXSxhPTAsaD1PYmplY3Qua2V5cyhQKTthPGgubGVuZ3RoO2ErKyl7dmFyIGI9aFthXTtiLmxlbmd0aD09PTE/aS5wdXNoKCJcXCIrYik6dS5wdXNoKGIpfWkuc29ydCgpO2Zvcih2YXIgRT0wO0U8aS5sZW5ndGgtMTtFKyspe2Zvcih2YXIgQT1FO0E8aS5sZW5ndGgtMSYmaVtBXS5jaGFyQ29kZUF0KDEpKzE9PT1pW0ErMV0uY2hhckNvZGVBdCgxKTspQSs9MTt2YXIgTD0xK0EtRTtMPDN8fGkuc3BsaWNlKEUsTCxpW0VdKyItIitpW0FdKX1yZXR1cm4gdS51bnNoaWZ0KCJbIitpLmpvaW4oIiIpKyJdIiksbmV3IFJlZ0V4cCh1LmpvaW4oInwiKSwiZyIpfXZhciB5PS8oPzpbXHg4MC1cdUQ3RkZcdUUwMDAtXHVGRkZGXXxbXHVEODAwLVx1REJGRl1bXHVEQzAwLVx1REZGRl18W1x1RDgwMC1cdURCRkZdKD8hW1x1REMwMC1cdURGRkZdKXwoPzpbXlx1RDgwMC1cdURCRkZdfF4pW1x1REMwMC1cdURGRkZdKS9nO2Z1bmN0aW9uIG0oUCl7cmV0dXJuIiYjeCIrUC5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSsiOyJ9ZnVuY3Rpb24gVChQLGkpe3JldHVybiBmdW5jdGlvbih1KXtyZXR1cm4gdS5yZXBsYWNlKGksZnVuY3Rpb24oYSl7cmV0dXJuIFBbYV19KS5yZXBsYWNlKHksbSl9fXZhciBPPWcocyk7ZnVuY3Rpb24gdihQKXtyZXR1cm4gUC5yZXBsYWNlKE8sbSkucmVwbGFjZSh5LG0pfWUuZXNjYXBlPXZ9LGZ1bmN0aW9uKGQpe2QuZXhwb3J0cz1KU09OLnBhcnNlKCd7ImVsZW1lbnROYW1lcyI6eyJhbHRnbHlwaCI6ImFsdEdseXBoIiwiYWx0Z2x5cGhkZWYiOiJhbHRHbHlwaERlZiIsImFsdGdseXBoaXRlbSI6ImFsdEdseXBoSXRlbSIsImFuaW1hdGVjb2xvciI6ImFuaW1hdGVDb2xvciIsImFuaW1hdGVtb3Rpb24iOiJhbmltYXRlTW90aW9uIiwiYW5pbWF0ZXRyYW5zZm9ybSI6ImFuaW1hdGVUcmFuc2Zvcm0iLCJjbGlwcGF0aCI6ImNsaXBQYXRoIiwiZmVibGVuZCI6ImZlQmxlbmQiLCJmZWNvbG9ybWF0cml4IjoiZmVDb2xvck1hdHJpeCIsImZlY29tcG9uZW50dHJhbnNmZXIiOiJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVjb21wb3NpdGUiOiJmZUNvbXBvc2l0ZSIsImZlY29udm9sdmVtYXRyaXgiOiJmZUNvbnZvbHZlTWF0cml4IiwiZmVkaWZmdXNlbGlnaHRpbmciOiJmZURpZmZ1c2VMaWdodGluZyIsImZlZGlzcGxhY2VtZW50bWFwIjoiZmVEaXNwbGFjZW1lbnRNYXAiLCJmZWRpc3RhbnRsaWdodCI6ImZlRGlzdGFudExpZ2h0IiwiZmVkcm9wc2hhZG93IjoiZmVEcm9wU2hhZG93IiwiZmVmbG9vZCI6ImZlRmxvb2QiLCJmZWZ1bmNhIjoiZmVGdW5jQSIsImZlZnVuY2IiOiJmZUZ1bmNCIiwiZmVmdW5jZyI6ImZlRnVuY0ciLCJmZWZ1bmNyIjoiZmVGdW5jUiIsImZlZ2F1c3NpYW5ibHVyIjoiZmVHYXVzc2lhbkJsdXIiLCJmZWltYWdlIjoiZmVJbWFnZSIsImZlbWVyZ2UiOiJmZU1lcmdlIiwiZmVtZXJnZW5vZGUiOiJmZU1lcmdlTm9kZSIsImZlbW9ycGhvbG9neSI6ImZlTW9ycGhvbG9neSIsImZlb2Zmc2V0IjoiZmVPZmZzZXQiLCJmZXBvaW50bGlnaHQiOiJmZVBvaW50TGlnaHQiLCJmZXNwZWN1bGFybGlnaHRpbmciOiJmZVNwZWN1bGFyTGlnaHRpbmciLCJmZXNwb3RsaWdodCI6ImZlU3BvdExpZ2h0IiwiZmV0aWxlIjoiZmVUaWxlIiwiZmV0dXJidWxlbmNlIjoiZmVUdXJidWxlbmNlIiwiZm9yZWlnbm9iamVjdCI6ImZvcmVpZ25PYmplY3QiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwibGluZWFyZ3JhZGllbnQiOiJsaW5lYXJHcmFkaWVudCIsInJhZGlhbGdyYWRpZW50IjoicmFkaWFsR3JhZGllbnQiLCJ0ZXh0cGF0aCI6InRleHRQYXRoIn0sImF0dHJpYnV0ZU5hbWVzIjp7ImRlZmluaXRpb251cmwiOiJkZWZpbml0aW9uVVJMIiwiYXR0cmlidXRlbmFtZSI6ImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGV0eXBlIjoiYXR0cmlidXRlVHlwZSIsImJhc2VmcmVxdWVuY3kiOiJiYXNlRnJlcXVlbmN5IiwiYmFzZXByb2ZpbGUiOiJiYXNlUHJvZmlsZSIsImNhbGNtb2RlIjoiY2FsY01vZGUiLCJjbGlwcGF0aHVuaXRzIjoiY2xpcFBhdGhVbml0cyIsImRpZmZ1c2Vjb25zdGFudCI6ImRpZmZ1c2VDb25zdGFudCIsImVkZ2Vtb2RlIjoiZWRnZU1vZGUiLCJmaWx0ZXJ1bml0cyI6ImZpbHRlclVuaXRzIiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImdyYWRpZW50dHJhbnNmb3JtIjoiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIjoiZ3JhZGllbnRVbml0cyIsImtlcm5lbG1hdHJpeCI6Imtlcm5lbE1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiOiJrZXJuZWxVbml0TGVuZ3RoIiwia2V5cG9pbnRzIjoia2V5UG9pbnRzIiwia2V5c3BsaW5lcyI6ImtleVNwbGluZXMiLCJrZXl0aW1lcyI6ImtleVRpbWVzIiwibGVuZ3RoYWRqdXN0IjoibGVuZ3RoQWRqdXN0IiwibGltaXRpbmdjb25lYW5nbGUiOiJsaW1pdGluZ0NvbmVBbmdsZSIsIm1hcmtlcmhlaWdodCI6Im1hcmtlckhlaWdodCIsIm1hcmtlcnVuaXRzIjoibWFya2VyVW5pdHMiLCJtYXJrZXJ3aWR0aCI6Im1hcmtlcldpZHRoIiwibWFza2NvbnRlbnR1bml0cyI6Im1hc2tDb250ZW50VW5pdHMiLCJtYXNrdW5pdHMiOiJtYXNrVW5pdHMiLCJudW1vY3RhdmVzIjoibnVtT2N0YXZlcyIsInBhdGhsZW5ndGgiOiJwYXRoTGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyI6InBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIjoicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm51bml0cyI6InBhdHRlcm5Vbml0cyIsInBvaW50c2F0eCI6InBvaW50c0F0WCIsInBvaW50c2F0eSI6InBvaW50c0F0WSIsInBvaW50c2F0eiI6InBvaW50c0F0WiIsInByZXNlcnZlYWxwaGEiOiJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyI6InByZXNlcnZlQXNwZWN0UmF0aW8iLCJwcmltaXRpdmV1bml0cyI6InByaW1pdGl2ZVVuaXRzIiwicmVmeCI6InJlZlgiLCJyZWZ5IjoicmVmWSIsInJlcGVhdGNvdW50IjoicmVwZWF0Q291bnQiLCJyZXBlYXRkdXIiOiJyZXBlYXREdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiOiJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIjoicmVxdWlyZWRGZWF0dXJlcyIsInNwZWN1bGFyY29uc3RhbnQiOiJzcGVjdWxhckNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCI6InNwZWN1bGFyRXhwb25lbnQiLCJzcHJlYWRtZXRob2QiOiJzcHJlYWRNZXRob2QiLCJzdGFydG9mZnNldCI6InN0YXJ0T2Zmc2V0Iiwic3RkZGV2aWF0aW9uIjoic3RkRGV2aWF0aW9uIiwic3RpdGNodGlsZXMiOiJzdGl0Y2hUaWxlcyIsInN1cmZhY2VzY2FsZSI6InN1cmZhY2VTY2FsZSIsInN5c3RlbWxhbmd1YWdlIjoic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyI6InRhYmxlVmFsdWVzIiwidGFyZ2V0eCI6InRhcmdldFgiLCJ0YXJnZXR5IjoidGFyZ2V0WSIsInRleHRsZW5ndGgiOiJ0ZXh0TGVuZ3RoIiwidmlld2JveCI6InZpZXdCb3giLCJ2aWV3dGFyZ2V0Ijoidmlld1RhcmdldCIsInhjaGFubmVsc2VsZWN0b3IiOiJ4Q2hhbm5lbFNlbGVjdG9yIiwieWNoYW5uZWxzZWxlY3RvciI6InlDaGFubmVsU2VsZWN0b3IiLCJ6b29tYW5kcGFuIjoiem9vbUFuZFBhbiJ9fScpfSxmdW5jdGlvbihkLGUpe3ZhciB0PWUuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24obil7cmV0dXJuIG4uY2hpbGRyZW59LHI9ZS5nZXRQYXJlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIG4ucGFyZW50fTtlLmdldFNpYmxpbmdzPWZ1bmN0aW9uKG4pe3ZhciBzPXIobik7cmV0dXJuIHM/dChzKTpbbl19LGUuZ2V0QXR0cmlidXRlVmFsdWU9ZnVuY3Rpb24obixzKXtyZXR1cm4gbi5hdHRyaWJzJiZuLmF0dHJpYnNbc119LGUuaGFzQXR0cmliPWZ1bmN0aW9uKG4scyl7cmV0dXJuISFuLmF0dHJpYnMmJmhhc093blByb3BlcnR5LmNhbGwobi5hdHRyaWJzLHMpfSxlLmdldE5hbWU9ZnVuY3Rpb24obil7cmV0dXJuIG4ubmFtZX19LGZ1bmN0aW9uKGQsZSl7ZS5yZW1vdmVFbGVtZW50PWZ1bmN0aW9uKHQpe2lmKHQucHJldiYmKHQucHJldi5uZXh0PXQubmV4dCksdC5uZXh0JiYodC5uZXh0LnByZXY9dC5wcmV2KSx0LnBhcmVudCl7dmFyIHI9dC5wYXJlbnQuY2hpbGRyZW47ci5zcGxpY2Uoci5sYXN0SW5kZXhPZih0KSwxKX19LGUucmVwbGFjZUVsZW1lbnQ9ZnVuY3Rpb24odCxyKXt2YXIgbj1yLnByZXY9dC5wcmV2O24mJihuLm5leHQ9cik7dmFyIHM9ci5uZXh0PXQubmV4dDtzJiYocy5wcmV2PXIpO3ZhciBsPXIucGFyZW50PXQucGFyZW50O2lmKGwpe3ZhciBjPWwuY2hpbGRyZW47Y1tjLmxhc3RJbmRleE9mKHQpXT1yfX0sZS5hcHBlbmRDaGlsZD1mdW5jdGlvbih0LHIpe2lmKHIucGFyZW50PXQsdC5jaGlsZHJlbi5wdXNoKHIpIT09MSl7dmFyIG49dC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aC0yXTtuLm5leHQ9cixyLnByZXY9bixyLm5leHQ9bnVsbH19LGUuYXBwZW5kPWZ1bmN0aW9uKHQscil7dmFyIG49dC5wYXJlbnQscz10Lm5leHQ7aWYoci5uZXh0PXMsci5wcmV2PXQsdC5uZXh0PXIsci5wYXJlbnQ9bixzKXtpZihzLnByZXY9cixuKXt2YXIgbD1uLmNoaWxkcmVuO2wuc3BsaWNlKGwubGFzdEluZGV4T2YocyksMCxyKX19ZWxzZSBuJiZuLmNoaWxkcmVuLnB1c2gocil9LGUucHJlcGVuZD1mdW5jdGlvbih0LHIpe3ZhciBuPXQucGFyZW50O2lmKG4pe3ZhciBzPW4uY2hpbGRyZW47cy5zcGxpY2Uocy5sYXN0SW5kZXhPZih0KSwwLHIpfXQucHJldiYmKHQucHJldi5uZXh0PXIpLHIucGFyZW50PW4sci5wcmV2PXQucHJldixyLm5leHQ9dCx0LnByZXY9cn19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDI1NikuaXNUYWc7ZC5leHBvcnRzPXtmaWx0ZXI6bixmaW5kOnMsZmluZE9uZUNoaWxkOmwsZmluZE9uZTpjLGV4aXN0c09uZTpvLGZpbmRBbGw6Zn07ZnVuY3Rpb24gbih4LGcseSxtKXtyZXR1cm4gQXJyYXkuaXNBcnJheShnKXx8KGc9W2ddKSwodHlwZW9mIG0hPSJudW1iZXIifHwhaXNGaW5pdGUobSkpJiYobT0xLzApLHMoeCxnLHkhPT0hMSxtKX1mdW5jdGlvbiBzKHgsZyx5LG0pe2Zvcih2YXIgVD1bXSxPLHY9MCxQPWcubGVuZ3RoO3Y8UCYmISh4KGdbdl0pJiYoVC5wdXNoKGdbdl0pLC0tbTw9MCl8fChPPWdbdl0uY2hpbGRyZW4seSYmTyYmTy5sZW5ndGg+MCYmKE89cyh4LE8seSxtKSxUPVQuY29uY2F0KE8pLG0tPU8ubGVuZ3RoLG08PTApKSk7disrKTtyZXR1cm4gVH1mdW5jdGlvbiBsKHgsZyl7Zm9yKHZhciB5PTAsbT1nLmxlbmd0aDt5PG07eSsrKWlmKHgoZ1t5XSkpcmV0dXJuIGdbeV07cmV0dXJuIG51bGx9ZnVuY3Rpb24gYyh4LGcpe2Zvcih2YXIgeT1udWxsLG09MCxUPWcubGVuZ3RoO208VCYmIXk7bSsrKWlmKHIoZ1ttXSkpeChnW21dKT95PWdbbV06Z1ttXS5jaGlsZHJlbi5sZW5ndGg+MCYmKHk9Yyh4LGdbbV0uY2hpbGRyZW4pKTtlbHNlIGNvbnRpbnVlO3JldHVybiB5fWZ1bmN0aW9uIG8oeCxnKXtmb3IodmFyIHk9MCxtPWcubGVuZ3RoO3k8bTt5KyspaWYocihnW3ldKSYmKHgoZ1t5XSl8fGdbeV0uY2hpbGRyZW4ubGVuZ3RoPjAmJm8oeCxnW3ldLmNoaWxkcmVuKSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZih4LGcpe2Zvcih2YXIgeT1bXSxtPWcuc2xpY2UoKTttLmxlbmd0aDspe3ZhciBUPW0uc2hpZnQoKTtyKFQpJiYoVC5jaGlsZHJlbiYmVC5jaGlsZHJlbi5sZW5ndGg+MCYmbS51bnNoaWZ0LmFwcGx5KG0sVC5jaGlsZHJlbikseChUKSYmeS5wdXNoKFQpKX1yZXR1cm4geX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDI1Niksbj1lLmlzVGFnPXIuaXNUYWc7ZS50ZXN0RWxlbWVudD1mdW5jdGlvbihvLGYpe2Zvcih2YXIgeCBpbiBvKWlmKG8uaGFzT3duUHJvcGVydHkoeCkpe2lmKHg9PT0idGFnX25hbWUiKXtpZighbihmKXx8IW8udGFnX25hbWUoZi5uYW1lKSlyZXR1cm4hMX1lbHNlIGlmKHg9PT0idGFnX3R5cGUiKXtpZighby50YWdfdHlwZShmLnR5cGUpKXJldHVybiExfWVsc2UgaWYoeD09PSJ0YWdfY29udGFpbnMiKXtpZihuKGYpfHwhby50YWdfY29udGFpbnMoZi5kYXRhKSlyZXR1cm4hMX1lbHNlIGlmKCFmLmF0dHJpYnN8fCFvW3hdKGYuYXR0cmlic1t4XSkpcmV0dXJuITF9cmV0dXJuITB9O3ZhciBzPXt0YWdfbmFtZTpmdW5jdGlvbihvKXtyZXR1cm4gdHlwZW9mIG89PSJmdW5jdGlvbiI/ZnVuY3Rpb24oZil7cmV0dXJuIG4oZikmJm8oZi5uYW1lKX06bz09PSIqIj9uOmZ1bmN0aW9uKGYpe3JldHVybiBuKGYpJiZmLm5hbWU9PT1vfX0sdGFnX3R5cGU6ZnVuY3Rpb24obyl7cmV0dXJuIHR5cGVvZiBvPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGYpe3JldHVybiBvKGYudHlwZSl9OmZ1bmN0aW9uKGYpe3JldHVybiBmLnR5cGU9PT1vfX0sdGFnX2NvbnRhaW5zOmZ1bmN0aW9uKG8pe3JldHVybiB0eXBlb2Ygbz09ImZ1bmN0aW9uIj9mdW5jdGlvbihmKXtyZXR1cm4hbihmKSYmbyhmLmRhdGEpfTpmdW5jdGlvbihmKXtyZXR1cm4hbihmKSYmZi5kYXRhPT09b319fTtmdW5jdGlvbiBsKG8sZil7cmV0dXJuIHR5cGVvZiBmPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKHgpe3JldHVybiB4LmF0dHJpYnMmJmYoeC5hdHRyaWJzW29dKX06ZnVuY3Rpb24oeCl7cmV0dXJuIHguYXR0cmlicyYmeC5hdHRyaWJzW29dPT09Zn19ZnVuY3Rpb24gYyhvLGYpe3JldHVybiBmdW5jdGlvbih4KXtyZXR1cm4gbyh4KXx8Zih4KX19ZS5nZXRFbGVtZW50cz1mdW5jdGlvbihvLGYseCxnKXt2YXIgeT1PYmplY3Qua2V5cyhvKS5tYXAoZnVuY3Rpb24obSl7dmFyIFQ9b1ttXTtyZXR1cm4gbSBpbiBzP3NbbV0oVCk6bChtLFQpfSk7cmV0dXJuIHkubGVuZ3RoPT09MD9bXTp0aGlzLmZpbHRlcih5LnJlZHVjZShjKSxmLHgsZyl9LGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24obyxmLHgpe3JldHVybiBBcnJheS5pc0FycmF5KGYpfHwoZj1bZl0pLHRoaXMuZmluZE9uZShsKCJpZCIsbyksZix4IT09ITEpfSxlLmdldEVsZW1lbnRzQnlUYWdOYW1lPWZ1bmN0aW9uKG8sZix4LGcpe3JldHVybiB0aGlzLmZpbHRlcihzLnRhZ19uYW1lKG8pLGYseCxnKX0sZS5nZXRFbGVtZW50c0J5VGFnVHlwZT1mdW5jdGlvbihvLGYseCxnKXtyZXR1cm4gdGhpcy5maWx0ZXIocy50YWdfdHlwZShvKSxmLHgsZyl9fSxmdW5jdGlvbihkLGUpe2UucmVtb3ZlU3Vic2V0cz1mdW5jdGlvbihuKXtmb3IodmFyIHM9bi5sZW5ndGgsbCxjLG87LS1zPi0xOyl7Zm9yKGw9Yz1uW3NdLG5bc109bnVsbCxvPSEwO2M7KXtpZihuLmluZGV4T2YoYyk+LTEpe289ITEsbi5zcGxpY2UocywxKTticmVha31jPWMucGFyZW50fW8mJihuW3NdPWwpfXJldHVybiBufTt2YXIgdD17RElTQ09OTkVDVEVEOjEsUFJFQ0VESU5HOjIsRk9MTE9XSU5HOjQsQ09OVEFJTlM6OCxDT05UQUlORURfQlk6MTZ9LHI9ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj1mdW5jdGlvbihuLHMpe3ZhciBsPVtdLGM9W10sbyxmLHgsZyx5LG07aWYobj09PXMpcmV0dXJuIDA7Zm9yKG89bjtvOylsLnVuc2hpZnQobyksbz1vLnBhcmVudDtmb3Iobz1zO287KWMudW5zaGlmdChvKSxvPW8ucGFyZW50O2ZvcihtPTA7bFttXT09PWNbbV07KW0rKztyZXR1cm4gbT09PTA/dC5ESVNDT05ORUNURUQ6KGY9bFttLTFdLHg9Zi5jaGlsZHJlbixnPWxbbV0seT1jW21dLHguaW5kZXhPZihnKT54LmluZGV4T2YoeSk/Zj09PXM/dC5GT0xMT1dJTkd8dC5DT05UQUlORURfQlk6dC5GT0xMT1dJTkc6Zj09PW4/dC5QUkVDRURJTkd8dC5DT05UQUlOUzp0LlBSRUNFRElORyl9O2UudW5pcXVlU29ydD1mdW5jdGlvbihuKXt2YXIgcz1uLmxlbmd0aCxsLGM7Zm9yKG49bi5zbGljZSgpOy0tcz4tMTspbD1uW3NdLGM9bi5pbmRleE9mKGwpLGM+LTEmJmM8cyYmbi5zcGxpY2UocywxKTtyZXR1cm4gbi5zb3J0KGZ1bmN0aW9uKG8sZil7dmFyIHg9cihvLGYpO3JldHVybiB4JnQuUFJFQ0VESU5HPy0xOngmdC5GT0xMT1dJTkc/MTowfSksbn19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPXt0cnVlRnVuYzpmdW5jdGlvbigpe3JldHVybiEwfSxmYWxzZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMX19fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXk7dmFyIHI9dCgyNzUpLnBhcnNlLG49dCgyNzMpLHM9dCgyNzgpLGw9dCgyNzkpLGM9dCgyODApLG89dCgyODIpLGY9bi50cnVlRnVuYyx4PW4uZmFsc2VGdW5jLGc9by5maWx0ZXJzO2Z1bmN0aW9uIHkoUyxJLEQpe3ZhciBSPVQoUyxJLEQpO3JldHVybiBtKFIsSSl9ZnVuY3Rpb24gbShTLEkpe3ZhciBEPUkuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oQyl7cmV0dXJuIEQuaXNUYWcoQykmJlMoQyl9fWZ1bmN0aW9uIFQoUyxJLEQpe3ZhciBSPXIoUyxJKTtyZXR1cm4gaChSLEksRCl9ZnVuY3Rpb24gTyhTKXtyZXR1cm4gUy50eXBlPT09InBzZXVkbyImJihTLm5hbWU9PT0ic2NvcGUifHxBcnJheS5pc0FycmF5KFMuZGF0YSkmJlMuZGF0YS5zb21lKGZ1bmN0aW9uKEkpe3JldHVybiBJLnNvbWUoTyl9KSl9dmFyIHY9e3R5cGU6ImRlc2NlbmRhbnQifSxQPXt0eXBlOiJfZmxleGlibGVEZXNjZW5kYW50In0saT17dHlwZToicHNldWRvIixuYW1lOiJzY29wZSJ9LHU9e307ZnVuY3Rpb24gYShTLEksRCl7dmFyIFI9SS5hZGFwdGVyLEM9ISFEJiYhIUQubGVuZ3RoJiZELmV2ZXJ5KGZ1bmN0aW9uKGope3JldHVybiBqPT09dXx8ISFSLmdldFBhcmVudChqKX0pO1MuZm9yRWFjaChmdW5jdGlvbihqKXtpZighKGoubGVuZ3RoPjAmJmIoalswXSkmJmpbMF0udHlwZSE9PSJkZXNjZW5kYW50IikpaWYoQyYmIShBcnJheS5pc0FycmF5KGopP2ouc29tZShPKTpPKGopKSlqLnVuc2hpZnQodik7ZWxzZSByZXR1cm47ai51bnNoaWZ0KGkpfSl9ZnVuY3Rpb24gaChTLEksRCl7Uz1TLmZpbHRlcihmdW5jdGlvbigkKXtyZXR1cm4gJC5sZW5ndGg+MH0pLFMuZm9yRWFjaChzKTt2YXIgUj1BcnJheS5pc0FycmF5KEQpO0Q9SSYmSS5jb250ZXh0fHxELEQmJiFSJiYoRD1bRF0pLGEoUyxJLEQpO3ZhciBDPSExLGo9Uy5tYXAoZnVuY3Rpb24oJCl7aWYoJFswXSYmJFsxXSYmJFswXS5uYW1lPT09InNjb3BlIil7dmFyIEg9JFsxXS50eXBlO1ImJkg9PT0iZGVzY2VuZGFudCI/JFsxXT1QOihIPT09ImFkamFjZW50Inx8SD09PSJzaWJsaW5nIikmJihDPSEwKX1yZXR1cm4gRSgkLEksRCl9KS5yZWR1Y2UoQSx4KTtyZXR1cm4gai5zaG91bGRUZXN0TmV4dFNpYmxpbmdzPUMsan1mdW5jdGlvbiBiKFMpe3JldHVybiBsW1MudHlwZV08MH1mdW5jdGlvbiBFKFMsSSxEKXtyZXR1cm4gUy5yZWR1Y2UoZnVuY3Rpb24oUixDKXtpZihSPT09eClyZXR1cm4gUjtpZighKEMudHlwZSBpbiBjKSl0aHJvdyBuZXcgRXJyb3IoIlJ1bGUgdHlwZSAiK0MudHlwZSsiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgY3NzLXNlbGVjdCIpO3JldHVybiBjW0MudHlwZV0oUixDLEksRCl9LEkmJkkucm9vdEZ1bmN8fGYpfWZ1bmN0aW9uIEEoUyxJKXtyZXR1cm4gST09PXh8fFM9PT1mP1M6Uz09PXh8fEk9PT1mP0k6ZnVuY3Rpb24oUil7cmV0dXJuIFMoUil8fEkoUil9fWZ1bmN0aW9uIEwoUyl7cmV0dXJuIFMuc29tZShiKX1nLm5vdD1mdW5jdGlvbihTLEksRCxSKXt2YXIgQz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCksYWRhcHRlcjpELmFkYXB0ZXJ9O2lmKEMuc3RyaWN0JiYoSS5sZW5ndGg+MXx8SS5zb21lKEwpKSl0aHJvdyBuZXcgRXJyb3IoImNvbXBsZXggc2VsZWN0b3JzIGluIDpub3QgYXJlbid0IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUiKTt2YXIgaj1oKEksQyxSKTtyZXR1cm4gaj09PXg/UzpqPT09Zj94OmZ1bmN0aW9uKEgpe3JldHVybiFqKEgpJiZTKEgpfX0sZy5oYXM9ZnVuY3Rpb24oUyxJLEQpe3ZhciBSPUQuYWRhcHRlcixDPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxhZGFwdGVyOlJ9LGo9SS5zb21lKEwpP1t1XTpudWxsLCQ9aChJLEMsaik7cmV0dXJuICQ9PT14P3g6JD09PWY/ZnVuY3Rpb24oSil7cmV0dXJuIFIuZ2V0Q2hpbGRyZW4oSikuc29tZShSLmlzVGFnKSYmUyhKKX06KCQ9bSgkLEQpLGo/ZnVuY3Rpb24oSil7cmV0dXJuIFMoSikmJihqWzBdPUosUi5leGlzdHNPbmUoJCxSLmdldENoaWxkcmVuKEopKSl9OmZ1bmN0aW9uKEope3JldHVybiBTKEopJiZSLmV4aXN0c09uZSgkLFIuZ2V0Q2hpbGRyZW4oSikpfSl9LGcubWF0Y2hlcz1mdW5jdGlvbihTLEksRCxSKXt2YXIgQz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCkscm9vdEZ1bmM6UyxhZGFwdGVyOkQuYWRhcHRlcn07cmV0dXJuIGgoSSxDLFIpfSx5LmNvbXBpbGVUb2tlbj1oLHkuY29tcGlsZVVuc2FmZT1ULHkuUHNldWRvcz1vfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGMsbyxmLHgpe3g9PT12b2lkIDAmJih4PWYpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLHgse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG9bZl19fSl9OmZ1bmN0aW9uKGMsbyxmLHgpe3g9PT12b2lkIDAmJih4PWYpLGNbeF09b1tmXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGMsbyl7Zm9yKHZhciBmIGluIGMpZiE9PSJkZWZhdWx0IiYmIW8uaGFzT3duUHJvcGVydHkoZikmJnIobyxjLGYpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksbih0KDI3NiksZSk7dmFyIHM9dCgyNzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJwYXJzZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdH19KTt2YXIgbD10KDI3Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInN0cmluZ2lmeSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH19KX0sZnVuY3Rpb24oZCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9Tzt2YXIgcj0vXlteXFxdPyg/OlxcKD86W1xkYS1mXXsxLDZ9XHM/fC4pfFtcd1wtXHUwMGIwLVx1RkZGRl0pKy8sbj0vXFwoW1xkYS1mXXsxLDZ9XHM/fChccyl8LikvZ2kscz0vXlxzKigoPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSspXHMqKD86KFxTPyk9XHMqKD86KFsnIl0pKFteXSo/KVwzfCgjPyg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKil8KXwpXHMqKGkpP1xdLyxsPXt1bmRlZmluZWQ6ImV4aXN0cyIsIiI6ImVxdWFscyIsIn4iOiJlbGVtZW50IiwiXiI6InN0YXJ0IiwkOiJlbmQiLCIqIjoiYW55IiwiISI6Im5vdCIsInwiOiJoeXBoZW4ifSxjPXsiPiI6ImNoaWxkIiwiPCI6InBhcmVudCIsIn4iOiJzaWJsaW5nIiwiKyI6ImFkamFjZW50In0sbz17IiMiOlsiaWQiLCJlcXVhbHMiXSwiLiI6WyJjbGFzcyIsImVsZW1lbnQiXX0sZj1uZXcgU2V0KFsiaGFzIiwibm90IiwibWF0Y2hlcyJdKSx4PW5ldyBTZXQoWyJjb250YWlucyIsImljb250YWlucyJdKSxnPW5ldyBTZXQoWyciJywiJyJdKTtmdW5jdGlvbiB5KGksdSxhKXt2YXIgaD1wYXJzZUludCh1LDE2KS02NTUzNjtyZXR1cm4gaCE9PWh8fGE/dTpoPDA/U3RyaW5nLmZyb21DaGFyQ29kZShoKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKGg+PjEwfDU1Mjk2LGgmMTAyM3w1NjMyMCl9ZnVuY3Rpb24gbShpKXtyZXR1cm4gaS5yZXBsYWNlKG4seSl9ZnVuY3Rpb24gVChpKXtyZXR1cm4gaT09PSIgInx8aT09PWAKYHx8aT09PSIJInx8aT09PSJcZiJ8fGk9PT0iXHIifWZ1bmN0aW9uIE8oaSx1KXt2YXIgYT1bXTtpZihpPXYoYSwiIitpLHUpLGkhPT0iIil0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBzZWxlY3RvcjogIitpKTtyZXR1cm4gYX1mdW5jdGlvbiB2KGksdSxhKXt2YXIgaD1bXSxiPSExO2Z1bmN0aW9uIEUoKXt2YXIgWj11Lm1hdGNoKHIpO2lmKCFaKXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbmFtZSwgZm91bmQgIit1KTt2YXIgdHQ9WlswXTtyZXR1cm4gdT11LnN1YnN0cih0dC5sZW5ndGgpLG0odHQpfWZ1bmN0aW9uIEEoWil7Zm9yKDtUKHUuY2hhckF0KFopKTspWisrO3U9dS5zdWJzdHIoWil9ZnVuY3Rpb24gTChaKXtmb3IodmFyIHR0PTA7dS5jaGFyQXQoLS1aKT09PSJcXCI7KXR0Kys7cmV0dXJuKHR0JjEpPT09MX1mb3IoQSgwKTt1IT09IiI7KXt2YXIgUz11LmNoYXJBdCgwKTtpZihUKFMpKWI9ITAsQSgxKTtlbHNlIGlmKFMgaW4gYyloLnB1c2goe3R5cGU6Y1tTXX0pLGI9ITEsQSgxKTtlbHNlIGlmKFM9PT0iLCIpe2lmKGgubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO2kucHVzaChoKSxoPVtdLGI9ITEsQSgxKX1lbHNlIGlmKGImJihoLmxlbmd0aD4wJiZoLnB1c2goe3R5cGU6ImRlc2NlbmRhbnQifSksYj0hMSksUz09PSIqIil1PXUuc3Vic3RyKDEpLGgucHVzaCh7dHlwZToidW5pdmVyc2FsIn0pO2Vsc2UgaWYoUyBpbiBvKXt2YXIgST1vW1NdLEQ9SVswXSxSPUlbMV07dT11LnN1YnN0cigxKSxoLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpELGFjdGlvbjpSLHZhbHVlOkUoKSxpZ25vcmVDYXNlOiExfSl9ZWxzZSBpZihTPT09IlsiKXt1PXUuc3Vic3RyKDEpO3ZhciBDPXUubWF0Y2gocyk7aWYoIUMpdGhyb3cgbmV3IEVycm9yKCJNYWxmb3JtZWQgYXR0cmlidXRlIHNlbGVjdG9yOiAiK3UpO3U9dS5zdWJzdHIoQ1swXS5sZW5ndGgpO3ZhciBqPW0oQ1sxXSk7KCFhfHwoImxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzImluIGE/YS5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lczohYS54bWxNb2RlKSkmJihqPWoudG9Mb3dlckNhc2UoKSksaC5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6aixhY3Rpb246bFtDWzJdXSx2YWx1ZTptKENbNF18fENbNV18fCIiKSxpZ25vcmVDYXNlOiEhQ1s2XX0pfWVsc2UgaWYoUz09PSI6Iil7aWYodS5jaGFyQXQoMSk9PT0iOiIpe3U9dS5zdWJzdHIoMiksaC5wdXNoKHt0eXBlOiJwc2V1ZG8tZWxlbWVudCIsbmFtZTpFKCkudG9Mb3dlckNhc2UoKX0pO2NvbnRpbnVlfXU9dS5zdWJzdHIoMSk7dmFyICQ9RSgpLnRvTG93ZXJDYXNlKCksQz1udWxsO2lmKHUuY2hhckF0KDApPT09IigiKWlmKGYuaGFzKCQpKXt2YXIgSD11LmNoYXJBdCgxKSxKPWcuaGFzKEgpO2lmKHU9dS5zdWJzdHIoSj8yOjEpLEM9W10sdT12KEMsdSxhKSxKKXtpZih1LmNoYXJBdCgwKSE9PUgpdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgcXVvdGVzIGluIDoiKyQpO3U9dS5zdWJzdHIoMSl9aWYodS5jaGFyQXQoMCkhPT0iKSIpdGhyb3cgbmV3IEVycm9yKCJNaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMgaW4gOiIrJCsiICgiK3UrIikiKTt1PXUuc3Vic3RyKDEpfWVsc2V7Zm9yKHZhciBxPTEsRj0xO0Y+MCYmcTx1Lmxlbmd0aDtxKyspdS5jaGFyQXQocSk9PT0iKCImJiFMKHEpP0YrKzp1LmNoYXJBdChxKT09PSIpIiYmIUwocSkmJkYtLTtpZihGKXRocm93IG5ldyBFcnJvcigiUGFyZW50aGVzaXMgbm90IG1hdGNoZWQiKTtpZihDPXUuc3Vic3RyKDEscS0yKSx1PXUuc3Vic3RyKHEpLHguaGFzKCQpKXt2YXIgSD1DLmNoYXJBdCgwKTtIPT09Qy5zbGljZSgtMSkmJmcuaGFzKEgpJiYoQz1DLnNsaWNlKDEsLTEpKSxDPW0oQyl9fWgucHVzaCh7dHlwZToicHNldWRvIixuYW1lOiQsZGF0YTpDfSl9ZWxzZSBpZihyLnRlc3QodSkpe3ZhciBHPUUoKTsoIWF8fCgibG93ZXJDYXNlVGFncyJpbiBhP2EubG93ZXJDYXNlVGFnczohYS54bWxNb2RlKSkmJihHPUcudG9Mb3dlckNhc2UoKSksaC5wdXNoKHt0eXBlOiJ0YWciLG5hbWU6R30pfWVsc2UgcmV0dXJuIGgubGVuZ3RoJiZoW2gubGVuZ3RoLTFdLnR5cGU9PT0iZGVzY2VuZGFudCImJmgucG9wKCksUChpLGgpLHV9cmV0dXJuIFAoaSxoKSx1fWZ1bmN0aW9uIFAoaSx1KXtpZihpLmxlbmd0aD4wJiZ1Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtpLnB1c2godSl9fSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXtlcXVhbHM6IiIsZWxlbWVudDoifiIsc3RhcnQ6Il4iLGVuZDoiJCIsYW55OiIqIixub3Q6IiEiLGh5cGhlbjoifCJ9O2Z1bmN0aW9uIG4obyl7cmV0dXJuIG8ubWFwKHMpLmpvaW4oIiwgIil9ZS5kZWZhdWx0PW47ZnVuY3Rpb24gcyhvKXtyZXR1cm4gby5tYXAobCkuam9pbigiIil9ZnVuY3Rpb24gbChvKXtzd2l0Y2goby50eXBlKXtjYXNlImNoaWxkIjpyZXR1cm4iID4gIjtjYXNlInBhcmVudCI6cmV0dXJuIiA8ICI7Y2FzZSJzaWJsaW5nIjpyZXR1cm4iIH4gIjtjYXNlImFkamFjZW50IjpyZXR1cm4iICsgIjtjYXNlImRlc2NlbmRhbnQiOnJldHVybiIgIjtjYXNlInVuaXZlcnNhbCI6cmV0dXJuIioiO2Nhc2UidGFnIjpyZXR1cm4gby5uYW1lO2Nhc2UicHNldWRvLWVsZW1lbnQiOnJldHVybiI6OiIrby5uYW1lO2Nhc2UicHNldWRvIjpyZXR1cm4gby5kYXRhPT09bnVsbD8iOiIrby5uYW1lOnR5cGVvZiBvLmRhdGE9PSJzdHJpbmciPyI6IitvLm5hbWUrIigiK28uZGF0YSsiKSI6IjoiK28ubmFtZSsiKCIrbihvLmRhdGEpKyIpIjtjYXNlImF0dHJpYnV0ZSI6cmV0dXJuIG8uYWN0aW9uPT09ImV4aXN0cyI/IlsiK28ubmFtZSsiXSI6by5uYW1lPT09ImlkIiYmby5hY3Rpb249PT0iZXF1YWxzIiYmIW8uaWdub3JlQ2FzZT8iIyIrby52YWx1ZTpvLm5hbWU9PT0iY2xhc3MiJiZvLmFjdGlvbj09PSJlbGVtZW50IiYmIW8uaWdub3JlQ2FzZT8iLiIrby52YWx1ZToiWyIrby5uYW1lK3Jbby5hY3Rpb25dKyI9JyIrby52YWx1ZSsiJyIrKG8uaWdub3JlQ2FzZT8iaSI6IiIpKyJdIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5rbm93biB0eXBlIil9fWZ1bmN0aW9uIGMobyl7cmV0dXJuIG99fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXM7dmFyIHI9dCgyNzkpLG49e19fcHJvdG9fXzpudWxsLGV4aXN0czoxMCxlcXVhbHM6OCxub3Q6NyxzdGFydDo2LGVuZDo2LGFueTo1LGh5cGhlbjo0LGVsZW1lbnQ6NH07ZnVuY3Rpb24gcyhjKXtmb3IodmFyIG89Yy5tYXAobCksZj0xO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgeD1vW2ZdO2lmKCEoeDwwKSlmb3IodmFyIGc9Zi0xO2c+PTAmJng8b1tnXTtnLS0pe3ZhciB5PWNbZysxXTtjW2crMV09Y1tnXSxjW2ddPXksb1tnKzFdPW9bZ10sb1tnXT14fX19ZnVuY3Rpb24gbChjKXt2YXIgbz1yW2MudHlwZV07aWYobz09PXIuYXR0cmlidXRlKW89bltjLmFjdGlvbl0sbz09PW4uZXF1YWxzJiZjLm5hbWU9PT0iaWQiJiYobz05KSxjLmlnbm9yZUNhc2UmJihvPj49MSk7ZWxzZSBpZihvPT09ci5wc2V1ZG8paWYoIWMuZGF0YSlvPTM7ZWxzZSBpZihjLm5hbWU9PT0iaGFzInx8Yy5uYW1lPT09ImNvbnRhaW5zIilvPTA7ZWxzZSBpZihjLm5hbWU9PT0ibWF0Y2hlcyJ8fGMubmFtZT09PSJub3QiKXtvPTA7Zm9yKHZhciBmPTA7ZjxjLmRhdGEubGVuZ3RoO2YrKylpZihjLmRhdGFbZl0ubGVuZ3RoPT09MSl7dmFyIHg9bChjLmRhdGFbZl1bMF0pO2lmKHg9PT0wKXtvPTA7YnJlYWt9eD5vJiYobz14KX1jLmRhdGEubGVuZ3RoPjEmJm8+MCYmKG8tPTEpfWVsc2Ugbz0xO3JldHVybiBvfX0sZnVuY3Rpb24oZCl7ZC5leHBvcnRzPUpTT04ucGFyc2UoJ3sidW5pdmVyc2FsIjo1MCwidGFnIjozMCwiYXR0cmlidXRlIjoxLCJwc2V1ZG8iOjAsImRlc2NlbmRhbnQiOi0xLCJjaGlsZCI6LTEsInBhcmVudCI6LTEsInNpYmxpbmciOi0xLCJhZGphY2VudCI6LTF9Jyl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDI4MSksbj10KDI4Mik7ZC5leHBvcnRzPXtfX3Byb3RvX186bnVsbCxhdHRyaWJ1dGU6ci5jb21waWxlLHBzZXVkbzpuLmNvbXBpbGUsdGFnOmZ1bmN0aW9uKHMsbCxjKXt2YXIgbz1sLm5hbWUsZj1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiBmLmdldE5hbWUoZyk9PT1vJiZzKGcpfX0sZGVzY2VuZGFudDpmdW5jdGlvbihzLGwsYyl7dmFyIG89dHlwZW9mIFdlYWtTZXQ8InUiP25ldyBXZWFrU2V0Om51bGwsZj1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGcpe2Zvcih2YXIgeT0hMTsheSYmKGc9Zi5nZXRQYXJlbnQoZykpOykoIW98fCFvLmhhcyhnKSkmJih5PXMoZyksIXkmJm8mJm8uYWRkKGcpKTtyZXR1cm4geX19LF9mbGV4aWJsZURlc2NlbmRhbnQ6ZnVuY3Rpb24ocyxsLGMpe3ZhciBvPWMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oeCl7Zm9yKHZhciBnPXMoeCk7IWcmJih4PW8uZ2V0UGFyZW50KHgpKTspZz1zKHgpO3JldHVybiBnfX0scGFyZW50OmZ1bmN0aW9uKHMsbCxjKXtpZihjJiZjLnN0cmljdCl0aHJvdyBuZXcgRXJyb3IoIlBhcmVudCBzZWxlY3RvciBpc24ndCBwYXJ0IG9mIENTUzMiKTt2YXIgbz1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiBvLmdldENoaWxkcmVuKGcpLnNvbWUoZil9O2Z1bmN0aW9uIGYoeCl7cmV0dXJuIG8uaXNUYWcoeCkmJnMoeCl9fSxjaGlsZDpmdW5jdGlvbihzLGwsYyl7dmFyIG89Yy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih4KXt2YXIgZz1vLmdldFBhcmVudCh4KTtyZXR1cm4hIWcmJnMoZyl9fSxzaWJsaW5nOmZ1bmN0aW9uKHMsbCxjKXt2YXIgbz1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHgpe2Zvcih2YXIgZz1vLmdldFNpYmxpbmdzKHgpLHk9MDt5PGcubGVuZ3RoO3krKylpZihvLmlzVGFnKGdbeV0pKXtpZihnW3ldPT09eClicmVhaztpZihzKGdbeV0pKXJldHVybiEwfXJldHVybiExfX0sYWRqYWNlbnQ6ZnVuY3Rpb24ocyxsLGMpe3ZhciBvPWMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oeCl7Zm9yKHZhciBnPW8uZ2V0U2libGluZ3MoeCkseSxtPTA7bTxnLmxlbmd0aDttKyspaWYoby5pc1RhZyhnW21dKSl7aWYoZ1ttXT09PXgpYnJlYWs7eT1nW21dfXJldHVybiEheSYmcyh5KX19LHVuaXZlcnNhbDpmdW5jdGlvbihzKXtyZXR1cm4gc319fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgyNzMpLmZhbHNlRnVuYyxuPS9bLVtcXXt9KCkqKz8uLFxcXiR8I1xzXS9nLHM9e19fcHJvdG9fXzpudWxsLGVxdWFsczpmdW5jdGlvbihsLGMsbyl7dmFyIGY9Yy5uYW1lLHg9Yy52YWx1ZSxnPW8uYWRhcHRlcjtyZXR1cm4gYy5pZ25vcmVDYXNlPyh4PXgudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihtKXt2YXIgVD1nLmdldEF0dHJpYnV0ZVZhbHVlKG0sZik7cmV0dXJuIFQhPW51bGwmJlQudG9Mb3dlckNhc2UoKT09PXgmJmwobSl9KTpmdW5jdGlvbihtKXtyZXR1cm4gZy5nZXRBdHRyaWJ1dGVWYWx1ZShtLGYpPT09eCYmbChtKX19LGh5cGhlbjpmdW5jdGlvbihsLGMsbyl7dmFyIGY9Yy5uYW1lLHg9Yy52YWx1ZSxnPXgubGVuZ3RoLHk9by5hZGFwdGVyO3JldHVybiBjLmlnbm9yZUNhc2U/KHg9eC50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKFQpe3ZhciBPPXkuZ2V0QXR0cmlidXRlVmFsdWUoVCxmKTtyZXR1cm4gTyE9bnVsbCYmKE8ubGVuZ3RoPT09Z3x8Ty5jaGFyQXQoZyk9PT0iLSIpJiZPLnN1YnN0cigwLGcpLnRvTG93ZXJDYXNlKCk9PT14JiZsKFQpfSk6ZnVuY3Rpb24oVCl7dmFyIE89eS5nZXRBdHRyaWJ1dGVWYWx1ZShULGYpO3JldHVybiBPIT1udWxsJiZPLnN1YnN0cigwLGcpPT09eCYmKE8ubGVuZ3RoPT09Z3x8Ty5jaGFyQXQoZyk9PT0iLSIpJiZsKFQpfX0sZWxlbWVudDpmdW5jdGlvbihsLGMsbyl7dmFyIGY9Yy5uYW1lLHg9Yy52YWx1ZSxnPW8uYWRhcHRlcjtpZigvXHMvLnRlc3QoeCkpcmV0dXJuIHI7eD14LnJlcGxhY2UobiwiXFwkJiIpO3ZhciB5PSIoPzpefFxccykiK3grIig/OiR8XFxzKSIsbT1jLmlnbm9yZUNhc2U/ImkiOiIiLFQ9bmV3IFJlZ0V4cCh5LG0pO3JldHVybiBmdW5jdGlvbih2KXt2YXIgUD1nLmdldEF0dHJpYnV0ZVZhbHVlKHYsZik7cmV0dXJuIFAhPW51bGwmJlQudGVzdChQKSYmbCh2KX19LGV4aXN0czpmdW5jdGlvbihsLGMsbyl7dmFyIGY9Yy5uYW1lLHg9by5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih5KXtyZXR1cm4geC5oYXNBdHRyaWIoeSxmKSYmbCh5KX19LHN0YXJ0OmZ1bmN0aW9uKGwsYyxvKXt2YXIgZj1jLm5hbWUseD1jLnZhbHVlLGc9eC5sZW5ndGgseT1vLmFkYXB0ZXI7cmV0dXJuIGc9PT0wP3I6Yy5pZ25vcmVDYXNlPyh4PXgudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihUKXt2YXIgTz15LmdldEF0dHJpYnV0ZVZhbHVlKFQsZik7cmV0dXJuIE8hPW51bGwmJk8uc3Vic3RyKDAsZykudG9Mb3dlckNhc2UoKT09PXgmJmwoVCl9KTpmdW5jdGlvbihUKXt2YXIgTz15LmdldEF0dHJpYnV0ZVZhbHVlKFQsZik7cmV0dXJuIE8hPW51bGwmJk8uc3Vic3RyKDAsZyk9PT14JiZsKFQpfX0sZW5kOmZ1bmN0aW9uKGwsYyxvKXt2YXIgZj1jLm5hbWUseD1jLnZhbHVlLGc9LXgubGVuZ3RoLHk9by5hZGFwdGVyO3JldHVybiBnPT09MD9yOmMuaWdub3JlQ2FzZT8oeD14LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oVCl7dmFyIE89eS5nZXRBdHRyaWJ1dGVWYWx1ZShULGYpO3JldHVybiBPIT1udWxsJiZPLnN1YnN0cihnKS50b0xvd2VyQ2FzZSgpPT09eCYmbChUKX0pOmZ1bmN0aW9uKFQpe3ZhciBPPXkuZ2V0QXR0cmlidXRlVmFsdWUoVCxmKTtyZXR1cm4gTyE9bnVsbCYmTy5zdWJzdHIoZyk9PT14JiZsKFQpfX0sYW55OmZ1bmN0aW9uKGwsYyxvKXt2YXIgZj1jLm5hbWUseD1jLnZhbHVlLGc9by5hZGFwdGVyO2lmKHg9PT0iIilyZXR1cm4gcjtpZihjLmlnbm9yZUNhc2Upe3ZhciB5PW5ldyBSZWdFeHAoeC5yZXBsYWNlKG4sIlxcJCYiKSwiaSIpO3JldHVybiBmdW5jdGlvbihUKXt2YXIgTz1nLmdldEF0dHJpYnV0ZVZhbHVlKFQsZik7cmV0dXJuIE8hPW51bGwmJnkudGVzdChPKSYmbChUKX19cmV0dXJuIGZ1bmN0aW9uKFQpe3ZhciBPPWcuZ2V0QXR0cmlidXRlVmFsdWUoVCxmKTtyZXR1cm4gTyE9bnVsbCYmTy5pbmRleE9mKHgpPj0wJiZsKFQpfX0sbm90OmZ1bmN0aW9uKGwsYyxvKXt2YXIgZj1jLm5hbWUseD1jLnZhbHVlLGc9by5hZGFwdGVyO3JldHVybiB4PT09IiI/ZnVuY3Rpb24obSl7cmV0dXJuISFnLmdldEF0dHJpYnV0ZVZhbHVlKG0sZikmJmwobSl9OmMuaWdub3JlQ2FzZT8oeD14LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24obSl7dmFyIFQ9Zy5nZXRBdHRyaWJ1dGVWYWx1ZShtLGYpO3JldHVybiBUIT1udWxsJiZULnRvTG93ZXJDYXNlKCkhPT14JiZsKG0pfSk6ZnVuY3Rpb24obSl7cmV0dXJuIGcuZ2V0QXR0cmlidXRlVmFsdWUobSxmKSE9PXgmJmwobSl9fX07ZC5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKGwsYyxvKXtpZihvJiZvLnN0cmljdCYmKGMuaWdub3JlQ2FzZXx8Yy5hY3Rpb249PT0ibm90IikpdGhyb3cgbmV3IEVycm9yKCJVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgc2VsZWN0b3IiKTtyZXR1cm4gc1tjLmFjdGlvbl0obCxjLG8pfSxydWxlczpzfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMjgzKSxuPXQoMjczKSxzPXQoMjgxKSxsPW4udHJ1ZUZ1bmMsYz1uLmZhbHNlRnVuYyxvPXMucnVsZXMuZXF1YWxzO2Z1bmN0aW9uIGYoUCxpKXt2YXIgdT17bmFtZTpQLHZhbHVlOml9O3JldHVybiBmdW5jdGlvbihoLGIsRSl7cmV0dXJuIG8oaCx1LEUpfX1mdW5jdGlvbiB4KFAsaSl7cmV0dXJuIGZ1bmN0aW9uKHUpe3JldHVybiEhaS5nZXRQYXJlbnQodSkmJlAodSl9fXZhciBnPXtjb250YWluczpmdW5jdGlvbihQLGksdSl7dmFyIGE9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gUChiKSYmYS5nZXRUZXh0KGIpLmluZGV4T2YoaSk+PTB9fSxpY29udGFpbnM6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPWkudG9Mb3dlckNhc2UoKSxoPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oRSl7cmV0dXJuIFAoRSkmJmguZ2V0VGV4dChFKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoYSk+PTB9fSwibnRoLWNoaWxkIjpmdW5jdGlvbihQLGksdSl7dmFyIGE9cihpKSxoPXUuYWRhcHRlcjtyZXR1cm4gYT09PWM/YTphPT09bD94KFAsaCk6ZnVuY3Rpb24oRSl7Zm9yKHZhciBBPWguZ2V0U2libGluZ3MoRSksTD0wLFM9MDtMPEEubGVuZ3RoO0wrKylpZihoLmlzVGFnKEFbTF0pKXtpZihBW0xdPT09RSlicmVhaztTKyt9cmV0dXJuIGEoUykmJlAoRSl9fSwibnRoLWxhc3QtY2hpbGQiOmZ1bmN0aW9uKFAsaSx1KXt2YXIgYT1yKGkpLGg9dS5hZGFwdGVyO3JldHVybiBhPT09Yz9hOmE9PT1sP3goUCxoKTpmdW5jdGlvbihFKXtmb3IodmFyIEE9aC5nZXRTaWJsaW5ncyhFKSxMPTAsUz1BLmxlbmd0aC0xO1M+PTA7Uy0tKWlmKGguaXNUYWcoQVtTXSkpe2lmKEFbU109PT1FKWJyZWFrO0wrK31yZXR1cm4gYShMKSYmUChFKX19LCJudGgtb2YtdHlwZSI6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXIoaSksaD11LmFkYXB0ZXI7cmV0dXJuIGE9PT1jP2E6YT09PWw/eChQLGgpOmZ1bmN0aW9uKEUpe2Zvcih2YXIgQT1oLmdldFNpYmxpbmdzKEUpLEw9MCxTPTA7UzxBLmxlbmd0aDtTKyspaWYoaC5pc1RhZyhBW1NdKSl7aWYoQVtTXT09PUUpYnJlYWs7aC5nZXROYW1lKEFbU10pPT09aC5nZXROYW1lKEUpJiZMKyt9cmV0dXJuIGEoTCkmJlAoRSl9fSwibnRoLWxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXIoaSksaD11LmFkYXB0ZXI7cmV0dXJuIGE9PT1jP2E6YT09PWw/eChQLGgpOmZ1bmN0aW9uKEUpe2Zvcih2YXIgQT1oLmdldFNpYmxpbmdzKEUpLEw9MCxTPUEubGVuZ3RoLTE7Uz49MDtTLS0paWYoaC5pc1RhZyhBW1NdKSl7aWYoQVtTXT09PUUpYnJlYWs7aC5nZXROYW1lKEFbU10pPT09aC5nZXROYW1lKEUpJiZMKyt9cmV0dXJuIGEoTCkmJlAoRSl9fSxyb290OmZ1bmN0aW9uKFAsaSx1KXt2YXIgYT11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGgpe3JldHVybiFhLmdldFBhcmVudChoKSYmUChoKX19LHNjb3BlOmZ1bmN0aW9uKFAsaSx1LGEpe3ZhciBoPXUuYWRhcHRlcjtpZighYXx8YS5sZW5ndGg9PT0wKXJldHVybiBnLnJvb3QoUCxpLHUpO2Z1bmN0aW9uIGIoRSxBKXtyZXR1cm4gdHlwZW9mIGguZXF1YWxzPT0iZnVuY3Rpb24iP2guZXF1YWxzKEUsQSk6RT09PUF9cmV0dXJuIGEubGVuZ3RoPT09MT9mdW5jdGlvbihFKXtyZXR1cm4gYihhWzBdLEUpJiZQKEUpfTpmdW5jdGlvbihFKXtyZXR1cm4gYS5pbmRleE9mKEUpPj0wJiZQKEUpfX0sY2hlY2tib3g6ZigidHlwZSIsImNoZWNrYm94IiksZmlsZTpmKCJ0eXBlIiwiZmlsZSIpLHBhc3N3b3JkOmYoInR5cGUiLCJwYXNzd29yZCIpLHJhZGlvOmYoInR5cGUiLCJyYWRpbyIpLHJlc2V0OmYoInR5cGUiLCJyZXNldCIpLGltYWdlOmYoInR5cGUiLCJpbWFnZSIpLHN1Ym1pdDpmKCJ0eXBlIiwic3VibWl0IiksaG92ZXI6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXUuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGEuaXNIb3ZlcmVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGIpe3JldHVybiBQKGIpJiZhLmlzSG92ZXJlZChiKX06Y30sdmlzaXRlZDpmdW5jdGlvbihQLGksdSl7dmFyIGE9dS5hZGFwdGVyO3JldHVybiB0eXBlb2YgYS5pc1Zpc2l0ZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYil7cmV0dXJuIFAoYikmJmEuaXNWaXNpdGVkKGIpfTpjfSxhY3RpdmU6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXUuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGEuaXNBY3RpdmU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYil7cmV0dXJuIFAoYikmJmEuaXNBY3RpdmUoYil9OmN9fTtmdW5jdGlvbiB5KFAsaSl7Zm9yKHZhciB1PTA7UCYmdTxQLmxlbmd0aDt1KyspaWYoaS5pc1RhZyhQW3VdKSlyZXR1cm4gUFt1XX12YXIgbT17ZW1wdHk6ZnVuY3Rpb24oUCxpKXtyZXR1cm4haS5nZXRDaGlsZHJlbihQKS5zb21lKGZ1bmN0aW9uKHUpe3JldHVybiBpLmlzVGFnKHUpfHx1LnR5cGU9PT0idGV4dCJ9KX0sImZpcnN0LWNoaWxkIjpmdW5jdGlvbihQLGkpe3JldHVybiB5KGkuZ2V0U2libGluZ3MoUCksaSk9PT1QfSwibGFzdC1jaGlsZCI6ZnVuY3Rpb24oUCxpKXtmb3IodmFyIHU9aS5nZXRTaWJsaW5ncyhQKSxhPXUubGVuZ3RoLTE7YT49MDthLS0pe2lmKHVbYV09PT1QKXJldHVybiEwO2lmKGkuaXNUYWcodVthXSkpYnJlYWt9cmV0dXJuITF9LCJmaXJzdC1vZi10eXBlIjpmdW5jdGlvbihQLGkpe2Zvcih2YXIgdT1pLmdldFNpYmxpbmdzKFApLGE9MDthPHUubGVuZ3RoO2ErKylpZihpLmlzVGFnKHVbYV0pKXtpZih1W2FdPT09UClyZXR1cm4hMDtpZihpLmdldE5hbWUodVthXSk9PT1pLmdldE5hbWUoUCkpYnJlYWt9cmV0dXJuITF9LCJsYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKFAsaSl7Zm9yKHZhciB1PWkuZ2V0U2libGluZ3MoUCksYT11Lmxlbmd0aC0xO2E+PTA7YS0tKWlmKGkuaXNUYWcodVthXSkpe2lmKHVbYV09PT1QKXJldHVybiEwO2lmKGkuZ2V0TmFtZSh1W2FdKT09PWkuZ2V0TmFtZShQKSlicmVha31yZXR1cm4hMX0sIm9ubHktb2YtdHlwZSI6ZnVuY3Rpb24oUCxpKXtmb3IodmFyIHU9aS5nZXRTaWJsaW5ncyhQKSxhPTAsaD11Lmxlbmd0aDthPGg7YSsrKWlmKGkuaXNUYWcodVthXSkpe2lmKHVbYV09PT1QKWNvbnRpbnVlO2lmKGkuZ2V0TmFtZSh1W2FdKT09PWkuZ2V0TmFtZShQKSlyZXR1cm4hMX1yZXR1cm4hMH0sIm9ubHktY2hpbGQiOmZ1bmN0aW9uKFAsaSl7Zm9yKHZhciB1PWkuZ2V0U2libGluZ3MoUCksYT0wO2E8dS5sZW5ndGg7YSsrKWlmKGkuaXNUYWcodVthXSkmJnVbYV0hPT1QKXJldHVybiExO3JldHVybiEwfSxsaW5rOmZ1bmN0aW9uKFAsaSl7cmV0dXJuIGkuaGFzQXR0cmliKFAsImhyZWYiKX0sc2VsZWN0ZWQ6ZnVuY3Rpb24oUCxpKXtpZihpLmhhc0F0dHJpYihQLCJzZWxlY3RlZCIpKXJldHVybiEwO2lmKGkuZ2V0TmFtZShQKSE9PSJvcHRpb24iKXJldHVybiExO3ZhciB1PWkuZ2V0UGFyZW50KFApO2lmKCF1fHxpLmdldE5hbWUodSkhPT0ic2VsZWN0Inx8aS5oYXNBdHRyaWIodSwibXVsdGlwbGUiKSlyZXR1cm4hMTtmb3IodmFyIGE9aS5nZXRDaGlsZHJlbih1KSxoPSExLGI9MDtiPGEubGVuZ3RoO2IrKylpZihpLmlzVGFnKGFbYl0pKWlmKGFbYl09PT1QKWg9ITA7ZWxzZSBpZihoKXtpZihpLmhhc0F0dHJpYihhW2JdLCJzZWxlY3RlZCIpKXJldHVybiExfWVsc2UgcmV0dXJuITE7cmV0dXJuIGh9LGRpc2FibGVkOmZ1bmN0aW9uKFAsaSl7cmV0dXJuIGkuaGFzQXR0cmliKFAsImRpc2FibGVkIil9LGVuYWJsZWQ6ZnVuY3Rpb24oUCxpKXtyZXR1cm4haS5oYXNBdHRyaWIoUCwiZGlzYWJsZWQiKX0sY2hlY2tlZDpmdW5jdGlvbihQLGkpe3JldHVybiBpLmhhc0F0dHJpYihQLCJjaGVja2VkIil8fG0uc2VsZWN0ZWQoUCxpKX0scmVxdWlyZWQ6ZnVuY3Rpb24oUCxpKXtyZXR1cm4gaS5oYXNBdHRyaWIoUCwicmVxdWlyZWQiKX0sb3B0aW9uYWw6ZnVuY3Rpb24oUCxpKXtyZXR1cm4haS5oYXNBdHRyaWIoUCwicmVxdWlyZWQiKX0scGFyZW50OmZ1bmN0aW9uKFAsaSl7cmV0dXJuIW0uZW1wdHkoUCxpKX0saGVhZGVyOlQoWyJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiXSksYnV0dG9uOmZ1bmN0aW9uKFAsaSl7dmFyIHU9aS5nZXROYW1lKFApO3JldHVybiB1PT09ImJ1dHRvbiJ8fHU9PT0iaW5wdXQiJiZpLmdldEF0dHJpYnV0ZVZhbHVlKFAsInR5cGUiKT09PSJidXR0b24ifSxpbnB1dDpUKFsiaW5wdXQiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsImJ1dHRvbiJdKSx0ZXh0OmZ1bmN0aW9uKFAsaSl7dmFyIHU7cmV0dXJuIGkuZ2V0TmFtZShQKT09PSJpbnB1dCImJighKHU9aS5nZXRBdHRyaWJ1dGVWYWx1ZShQLCJ0eXBlIikpfHx1LnRvTG93ZXJDYXNlKCk9PT0idGV4dCIpfX07ZnVuY3Rpb24gVChQKXtpZih0eXBlb2YgU2V0PCJ1Iil7dmFyIGk9bmV3IFNldChQKTtyZXR1cm4gZnVuY3Rpb24odSxhKXtyZXR1cm4gaS5oYXMoYS5nZXROYW1lKHUpKX19cmV0dXJuIGZ1bmN0aW9uKHUsYSl7cmV0dXJuIFAuaW5kZXhPZihhLmdldE5hbWUodSkpPj0wfX1mdW5jdGlvbiBPKFAsaSx1KXtpZih1PT09bnVsbCl7aWYoUC5sZW5ndGg+MiYmaSE9PSJzY29wZSIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIraSsiIHJlcXVpcmVzIGFuIGFyZ3VtZW50Iil9ZWxzZSBpZihQLmxlbmd0aD09PTIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIraSsiIGRvZXNuJ3QgaGF2ZSBhbnkgYXJndW1lbnRzIil9dmFyIHY9L14oPzooPzpudGh8bGFzdHxmaXJzdHxvbmx5KS0oPzpjaGlsZHxvZi10eXBlKXxyb290fGVtcHR5fCg/OmVufGRpcylhYmxlZHxjaGVja2VkfG5vdCkkLztkLmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24oUCxpLHUsYSl7dmFyIGg9aS5uYW1lLGI9aS5kYXRhLEU9dS5hZGFwdGVyO2lmKHUmJnUuc3RyaWN0JiYhdi50ZXN0KGgpKXRocm93IG5ldyBFcnJvcigiOiIraCsiIGlzbid0IHBhcnQgb2YgQ1NTMyIpO2lmKHR5cGVvZiBnW2hdPT0iZnVuY3Rpb24iKXJldHVybiBnW2hdKFAsYix1LGEpO2lmKHR5cGVvZiBtW2hdPT0iZnVuY3Rpb24iKXt2YXIgQT1tW2hdO3JldHVybiBPKEEsaCxiKSxBPT09Yz9BOlA9PT1sP2Z1bmN0aW9uKFMpe3JldHVybiBBKFMsRSxiKX06ZnVuY3Rpb24oUyl7cmV0dXJuIEEoUyxFLGIpJiZQKFMpfX1lbHNlIHRocm93IG5ldyBFcnJvcigidW5tYXRjaGVkIHBzZXVkby1jbGFzcyA6IitoKX0sZmlsdGVyczpnLHBzZXVkb3M6bX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDI4NCksbj10KDI4NSk7ZC5leHBvcnRzPWZ1bmN0aW9uKGwpe3JldHVybiBuKHIobCkpfSxkLmV4cG9ydHMucGFyc2U9cixkLmV4cG9ydHMuY29tcGlsZT1ufSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1yO3ZhciB0PS9eKFsrXC1dP1xkKm4pP1xzKig/OihbK1wtXT8pXHMqKFxkKykpPyQvO2Z1bmN0aW9uIHIobil7aWYobj1uLnRyaW0oKS50b0xvd2VyQ2FzZSgpLG49PT0iZXZlbiIpcmV0dXJuWzIsMF07aWYobj09PSJvZGQiKXJldHVyblsyLDFdO3ZhciBzPW4ubWF0Y2godCk7aWYoIXMpdGhyb3cgbmV3IFN5bnRheEVycm9yKCJuLXRoIHJ1bGUgY291bGRuJ3QgYmUgcGFyc2VkICgnIituKyInKSIpO3ZhciBsO3JldHVybiBzWzFdPyhsPXBhcnNlSW50KHNbMV0sMTApLGlzTmFOKGwpJiYoc1sxXS5jaGFyQXQoMCk9PT0iLSI/bD0tMTpsPTEpKTpsPTAsW2wsc1szXT9wYXJzZUludCgoc1syXXx8IiIpK3NbM10sMTApOjBdfX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz1sO3ZhciByPXQoMjczKSxuPXIudHJ1ZUZ1bmMscz1yLmZhbHNlRnVuYztmdW5jdGlvbiBsKGMpe3ZhciBvPWNbMF0sZj1jWzFdLTE7aWYoZjwwJiZvPD0wKXJldHVybiBzO2lmKG89PT0tMSlyZXR1cm4gZnVuY3Rpb24oZyl7cmV0dXJuIGc8PWZ9O2lmKG89PT0wKXJldHVybiBmdW5jdGlvbihnKXtyZXR1cm4gZz09PWZ9O2lmKG89PT0xKXJldHVybiBmPDA/bjpmdW5jdGlvbihnKXtyZXR1cm4gZz49Zn07dmFyIHg9ZiVvO3JldHVybiB4PDAmJih4Kz1vKSxvPjE/ZnVuY3Rpb24oZyl7cmV0dXJuIGc+PWYmJmclbz09PXh9OihvKj0tMSxmdW5jdGlvbihnKXtyZXR1cm4gZzw9ZiYmZyVvPT09eH0pfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciByPXQoMTIpLG49dCg3NCkscz10KDEpLGw9dCg2OCksYz10KDI1MCksbz10KDIxMyksZj10KDIxOCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHgoRSxBKXtpZihFPT1udWxsKXJldHVybnt9O3ZhciBMPWcoRSxBKSxTLEk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhFKTtmb3IoST0wO0k8RC5sZW5ndGg7SSsrKVM9RFtJXSwhKEEuaW5kZXhPZihTKT49MCkmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChFLFMpJiYoTFtTXT1FW1NdKX1yZXR1cm4gTH1mdW5jdGlvbiBnKEUsQSl7aWYoRT09bnVsbClyZXR1cm57fTt2YXIgTD17fSxTPU9iamVjdC5rZXlzKEUpLEksRDtmb3IoRD0wO0Q8Uy5sZW5ndGg7RCsrKUk9U1tEXSwhKEEuaW5kZXhPZihJKT49MCkmJihMW0ldPUVbSV0pO3JldHVybiBMfWNvbnN0IHk9e2FudGlhbGlhczohMCxhdXRvUmVuZGVyOiEwLGFscGhhOiEwfSxtPVN5bWJvbCgiYXV0b1JlbmRlciIpLFQ9U3ltYm9sKCJyZW5kZXJlciIpLE89U3ltYm9sKCJ0aW1lbGluZSIpLHY9U3ltYm9sKCJwcmVwYXJlUmVuZGVyIiksUD1TeW1ib2woInRpY2tSZW5kZXIiKSxpPVN5bWJvbCgicGFzcyIpLHU9U3ltYm9sKCJmYm8iKSxhPVN5bWJvbCgidGlja2VycyIpLGg9U3ltYm9sKCJsYXllclRyYW5zZm9ybUludmVydCIpO2NsYXNzIGIgZXh0ZW5kcyBjLmRlZmF1bHR7Y29uc3RydWN0b3IoQT17fSl7aWYoc3VwZXIoKSwhQS5jYW52YXMpe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OlJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEM9ci5FTlYuY3JlYXRlQ2FudmFzKEQsUix7b2Zmc2NyZWVuOiEhQS5vZmZzY3JlZW4saWQ6QS5pZCxleHRyYTpBLmV4dHJhfSk7Qy5zdHlsZSYmKEMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIiksQy5kYXRhc2V0JiYoQy5kYXRhc2V0LmxheWVySWQ9QS5pZCksQy5jb250ZXh0VHlwZSYmKEEuY29udGV4dFR5cGU9Qy5jb250ZXh0VHlwZSksQS5jYW52YXM9Q31jb25zdCBMPUEuY2FudmFzLFM9T2JqZWN0LmFzc2lnbih7fSx5LEEpO3RoaXNbbV09Uy5hdXRvUmVuZGVyLGRlbGV0ZSBBLmF1dG9SZW5kZXI7Y29uc3QgST1TLlJlbmRlcmVyfHxyLlJlbmRlcmVyO3RoaXNbVF09bmV3IEkoTCxTKSx0aGlzLm9wdGlvbnM9QSx0aGlzLmlkPUEuaWQsdGhpc1tpXT1bXSx0aGlzLnNldFJlc29sdXRpb24oTCksdGhpcy5jYW52YXM9TCx0aGlzW09dPW5ldyBuLlRpbWVsaW5lLHRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGwsdGhpc1toXT1udWxsfWdldCBhdXRvUmVuZGVyKCl7cmV0dXJuIHRoaXNbbV19Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucz90aGlzLnBhcmVudC5vcHRpb25zLmRpc3BsYXlSYXRpbzoxfWdldCBoZWlnaHQoKXtjb25zdHtoZWlnaHQ6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEEvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGdsKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcj90aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuZ2w6bnVsbH1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpc31nZXQgb2Zmc2NyZWVuKCl7cmV0dXJuISF0aGlzLm9wdGlvbnMub2Zmc2NyZWVufHx0aGlzLmNhbnZhcy5fb2Zmc2NyZWVufWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbaV19Z2V0IHByZXBhcmVSZW5kZXIoKXtyZXR1cm4gdGhpc1t2XT90aGlzW3ZdOlByb21pc2UucmVzb2x2ZSgpfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzW1RdfWdldCByZW5kZXJPZmZzZXQoKXtpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucyl7Y29uc3R7bGVmdDpBLHRvcDpMfT10aGlzLnBhcmVudC5vcHRpb25zO3JldHVybltBLExdfXJldHVyblt0aGlzLm9wdGlvbnMubGVmdHwwLHRoaXMub3B0aW9ucy50b3B8MF19Z2V0IHRpbWVsaW5lKCl7cmV0dXJuIHRoaXNbT119Z2V0IHdpZHRoKCl7Y29uc3R7d2lkdGg6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEEvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3R7eDpBLHk6TH09dGhpcy5hdHRyaWJ1dGVzO3JldHVyblsxLDAsMCwxLEEsTF19Z2V0IGxheWVyVHJhbnNmb3JtSW52ZXJ0KCl7aWYodGhpc1toXSlyZXR1cm4gdGhpc1toXTtjb25zdCBBPXRoaXMudHJhbnNmb3JtTWF0cml4O3JldHVybiBBWzBdPT09MSYmQVsxXT09PTAmJkFbMl09PT0wJiZBWzNdPT09MSYmQVs0XT09PTAmJkFbNV09PT0wP251bGw6KHRoaXNbaF09cy5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEpLHRoaXNbaF0pfWZvcmNlQ29udGV4dExvc3MoKXtjb25zdCBBPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcjtpZihBKXtjb25zdCBMPUEuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9sb3NlX2NvbnRleHQiKTtpZihMKXJldHVybiBMLmxvc2VDb250ZXh0KCksITB9cmV0dXJuITF9YWRkUGFzcyh7dmVydGV4OkEsZnJhZ21lbnQ6TCxvcHRpb25zOlMsdW5pZm9ybXM6SX09e30pe2lmKHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcil7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpcy5nZXRSZXNvbHV0aW9uKCksQz10aGlzLnJlbmRlcmVyLmNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6QSxmcmFnbWVudDpMLG9wdGlvbnM6U30pLGo9bmV3IHIuRmlndXJlMkQ7ai5yZWN0KDAsMCxEL3RoaXMuZGlzcGxheVJhdGlvLFIvdGhpcy5kaXNwbGF5UmF0aW8pO2NvbnN0ICQ9bmV3IHIuTWVzaDJEKGopO3JldHVybiAkLnNldFVuaWZvcm1zKEkpLCQuc2V0UHJvZ3JhbShDKSx0aGlzW2ldLnB1c2goJCksdGhpcy5mb3JjZVVwZGF0ZSgpLCR9cmV0dXJuIG51bGx9ZGVsZXRlVGV4dHVyZShBKXtyZXR1cm4gT2JqZWN0KGYuZGVsZXRlVGV4dHVyZSkoQSx0aGlzLnJlbmRlcmVyKX1kaXNwYXRjaFBvaW50ZXJFdmVudChBKXtjb25zdCBMPUEudHlwZTtpZihMPT09Im1vdXNlZG93biJ8fEw9PT0ibW91c2V1cCJ8fEw9PT0ibW91c2Vtb3ZlIil7Y29uc3QgQz10aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldDtpZihDKXtpZihDLmxheWVyPT09dGhpcylyZXR1cm4gQy5kaXNwYXRjaEV2ZW50KEEpLCEwO3RoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGx9fWxldCBTLEk7Y29uc3QgRD10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O2lmKEQpe1M9QS54LEk9QS55O2NvbnN0IEM9RCxqPUNbMF0qUytDWzJdKkkrQ1s0XSwkPUNbMV0qUytDWzNdKkkrQ1s1XTtkZWxldGUgQS54LGRlbGV0ZSBBLnksZGVsZXRlIEEubGF5ZXJYLGRlbGV0ZSBBLmxheWVyWSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhBLHtsYXllclg6e3ZhbHVlOmosY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOiQsY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpqLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6JCxjb25maWd1cmFibGU6ITB9fSl9Y29uc3QgUj1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChBKTtyZXR1cm4gRCYmT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQSx7bGF5ZXJYOnt2YWx1ZTpTLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpJLGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6Uyxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOkksY29uZmlndXJhYmxlOiEwfX0pLFJ9Zm9yY2VVcGRhdGUoKXtpZighdGhpc1t2XSlpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuaGFzT2Zmc2NyZWVuQ2FudmFzKXt0aGlzLnBhcmVudC5mb3JjZVVwZGF0ZSgpO2xldCBBPW51bGw7Y29uc3QgTD1uZXcgUHJvbWlzZShTPT57QT1TfSk7TC5fcmVzb2x2ZT1BLHRoaXNbdl09TH1lbHNle2xldCBBPW51bGwsTD1udWxsO2NvbnN0IFM9bmV3IFByb21pc2UoST0+e0E9SSx0aGlzW21dJiYoTD1PYmplY3QobC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIFMuX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfSk7Uy5fcmVzb2x2ZT1BLFMuX3JlcXVlc3RJRD1MLHRoaXNbdl09U319Z2V0RkJPKCl7Y29uc3QgQT10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIse3dpZHRoOkwsaGVpZ2h0OlN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBBJiYoIXRoaXNbdV18fHRoaXNbdV0ud2lkdGghPT1MfHx0aGlzW3VdLmhlaWdodCE9PVMpPyh0aGlzW3VdPXt3aWR0aDpMLGhlaWdodDpTLHRhcmdldDpBLmNyZWF0ZUZCTygpLGJ1ZmZlcjpBLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSx0aGlzW3VdKTp0aGlzW3VdP3RoaXNbdV06bnVsbH11cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBBPXRoaXMucmVuZGVyZXIsTD1BLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxBLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtBLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PUw7Y29uc3QgUz1zLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO0Euc2V0R2xvYmFsVHJhbnNmb3JtKC4uLnMubWF0MmQubXVsdGlwbHkoUyxMLHRoaXMudHJhbnNmb3JtTWF0cml4KSl9fW9uUHJvcGVydHlDaGFuZ2UoQSxMLFMpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoQSxMLFMpLEE9PT0iekluZGV4IiYmKHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleD1MKSxBPT09InRyYW5zZm9ybSJ8fEE9PT0idHJhbnNsYXRlInx8QT09PSJyb3RhdGUifHxBPT09InNjYWxlInx8QT09PSJza2V3Iil7Y29uc3QgST10aGlzW2hdO2lmKHRoaXNbaF09bnVsbCx0aGlzLnVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpLEkmJiF0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBEPXRoaXMucmVuZGVyZXIsUj1ELl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxELmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtELnNldEdsb2JhbFRyYW5zZm9ybSguLi5SKX19fV9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKXt0aGlzW3ZdJiYodGhpc1t2XS5fcmVxdWVzdElEJiZPYmplY3QobC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1t2XS5fcmVxdWVzdElEKSx0aGlzW3ZdLl9yZXNvbHZlKCksZGVsZXRlIHRoaXNbdl0pfXJlbmRlcih7Y2xlYXI6QT0hMH09e30pe2NvbnN0IEw9dGhpc1tpXS5sZW5ndGg/dGhpcy5nZXRGQk8oKTpudWxsO0wmJnRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5iaW5kRkJPKEwudGFyZ2V0KSxBJiZ0aGlzW1RdLmNsZWFyKCk7Y29uc3QgUz10aGlzLmRyYXcoKTtpZihTJiZTLmxlbmd0aCYmKHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhTKSx0aGlzLmNhbnZhcy5kcmF3JiZ0aGlzLmNhbnZhcy5kcmF3KCkpLEwpe2NvbnN0IEk9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLEQ9dGhpc1tpXS5sZW5ndGgse3dpZHRoOlIsaGVpZ2h0OkN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLGo9WzAsMCxSL3RoaXMuZGlzcGxheVJhdGlvLEMvdGhpcy5kaXNwbGF5UmF0aW9dO3RoaXNbaV0uZm9yRWFjaCgoJCxIKT0+eyQuYmxlbmQ9ITAsJC5zZXRUZXh0dXJlKEwudGFyZ2V0LnRleHR1cmUse3JlY3Q6an0pLEg9PT1ELTE/SS5iaW5kRkJPKG51bGwpOihMLnN3YXAoKSxJLmJpbmRGQk8oTC50YXJnZXQpKSx0aGlzW1RdLmNsZWFyKCksdGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKFskXSl9KX10aGlzLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpBLGhlaWdodDpMfSl7Y29uc3QgUz10aGlzLnJlbmRlcmVyLEk9Uy5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8Uy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgsRD1JWzRdLFI9SVs1XSxDPUlbMF0se3dpZHRoOmosaGVpZ2h0OiR9PXRoaXMuZ2V0UmVzb2x1dGlvbigpOyhqIT09QXx8JCE9PUwpJiYoc3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6QSxoZWlnaHQ6TH0pLHRoaXMuY2FudmFzJiYodGhpcy5jYW52YXMud2lkdGg9QSx0aGlzLmNhbnZhcy5oZWlnaHQ9TCxTLnVwZGF0ZVJlc29sdXRpb24mJlMudXBkYXRlUmVzb2x1dGlvbigpKSx0aGlzLmF0dHJpYnV0ZXMuc2l6ZT1bQSxMXSx0aGlzW2ldLmxlbmd0aCYmdGhpc1tpXS5mb3JFYWNoKEY9Pntjb25zdCBHPW5ldyByLkZpZ3VyZTJEO0cucmVjdCgwLDAsQS90aGlzLmRpc3BsYXlSYXRpbyxML3RoaXMuZGlzcGxheVJhdGlvKSxGLmNvbnRvdXJzPUcuY29udG91cnN9KSk7Y29uc3RbSCxKXT10aGlzLnJlbmRlck9mZnNldCxxPXRoaXMuZGlzcGxheVJhdGlvOyhEIT09SHx8UiE9PUp8fEMhPT1xKSYmKFMuc2V0R2xvYmFsVHJhbnNmb3JtKHEsMCwwLHEsSCxKKSxTLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PW51bGwsdGhpc1toXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksdGhpcy5mb3JjZVVwZGF0ZSgpKX10aWNrKEE9bnVsbCxMPXt9KXtsZXR7ZHVyYXRpb246Uz0xLzB9PUwsST14KEwsWyJkdXJhdGlvbiJdKTtjb25zdCBEPXRoaXMudGltZWxpbmUuZm9yayhJKSxSPXRoaXM7dGhpc1thXT10aGlzW2FdfHxbXSx0aGlzW2FdLnB1c2goe2hhbmRsZXI6QSxkdXJhdGlvbjpTfSk7Y29uc3QgQz0oKT0+e2xldCBqPW51bGwsJD1udWxsO2NvbnN0IEg9KCk9Pntjb25zdCBKPXRoaXNbYV0ubWFwKCh7aGFuZGxlcjpxLGR1cmF0aW9uOkZ9KT0+e2NvbnN0IEc9TWF0aC5taW4oMSxELmN1cnJlbnRUaW1lL0YpO3JldHVybnt2YWx1ZTpxP3EoRC5jdXJyZW50VGltZSxHKTpudWxsLHA6R319KTtSW1BdfHwoUltQXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57UlttXSYmUi5yZW5kZXIoKSxkZWxldGUgUltQXTtmb3IobGV0IHE9Si5sZW5ndGgtMTtxPj0wO3EtLSl7Y29uc3R7dmFsdWU6RixwOkd9PUpbcV07KEY9PT0hMXx8Rz49MSkmJnRoaXNbYV0uc3BsaWNlKHEsMSl9dGhpc1thXS5sZW5ndGg+MCYmQygpfSkpfTtpZih0aGlzW3ZdJiZ0aGlzW3ZdLl90eXBlIT09InRpY2tlciImJihPYmplY3QobC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1t2XS5fcmVxdWVzdElEKSxkZWxldGUgdGhpc1t2XSksIXRoaXNbdl0pe2NvbnN0IEo9bmV3IFByb21pc2UocT0+e2o9cSwkPU9iamVjdChsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoSCl9KTtKLl9yZXNvbHZlPWosSi5fcmVxdWVzdElEPSQsSi5fdHlwZT0idGlja2VyIix0aGlzW3ZdPUp9fTtDKCl9dG9HbG9iYWxQb3MoQSxMKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBqPXRoaXMudHJhbnNmb3JtTWF0cml4O0E9alswXSpBK2pbMl0qTCtqWzRdLEw9alsxXSpBK2pbM10qTCtqWzVdfWNvbnN0e3dpZHRoOlMsaGVpZ2h0Okl9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEQ9dGhpcy5yZW5kZXJPZmZzZXQsUj1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtBPUEqUlswXS9TK0RbMF0sTD1MKlJbMV0vSStEWzFdO2NvbnN0IEM9dGhpcy5kaXNwbGF5UmF0aW87cmV0dXJuIEEqPUMsTCo9QyxbQSxMXX10b0xvY2FsUG9zKEEsTCl7Y29uc3R7d2lkdGg6UyxoZWlnaHQ6SX09dGhpcy5nZXRSZXNvbHV0aW9uKCksRD10aGlzLnJlbmRlck9mZnNldCxSPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO0E9QSpTL1JbMF0tRFswXSxMPUwqSS9SWzFdLURbMV07Y29uc3QgQz10aGlzLmRpc3BsYXlSYXRpbztBLz1DLEwvPUM7Y29uc3Qgaj10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O3JldHVybiBqJiYoQT1qWzBdKkEralsyXSpMK2pbNF0sTD1qWzFdKkEralszXSpMK2pbNV0pLFtBLExdfX1vLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsImxheWVyIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDIyNCksbj10KDI4OCkscz10KDIxMyksbD10KDI1MiksYz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhQLGkpe2lmKFA9PW51bGwpcmV0dXJue307dmFyIHU9ZihQLGkpLGEsaDtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgYj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFApO2ZvcihoPTA7aDxiLmxlbmd0aDtoKyspYT1iW2hdLCEoaS5pbmRleE9mKGEpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFAsYSkmJih1W2FdPVBbYV0pfXJldHVybiB1fWZ1bmN0aW9uIGYoUCxpKXtpZihQPT1udWxsKXJldHVybnt9O3ZhciB1PXt9LGE9T2JqZWN0LmtleXMoUCksaCxiO2ZvcihiPTA7YjxhLmxlbmd0aDtiKyspaD1hW2JdLCEoaS5pbmRleE9mKGgpPj0wKSYmKHVbaF09UFtoXSk7cmV0dXJuIHV9ZnVuY3Rpb24geChQLGksdSl7cmV0dXJuIGkgaW4gUD9PYmplY3QuZGVmaW5lUHJvcGVydHkoUCxpLHt2YWx1ZTp1LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6UFtpXT11LFB9Y29uc3QgZz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLHk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbT1TeW1ib2woInJvb3QiKSxUPVN5bWJvbCgidGFzayIpO2Z1bmN0aW9uIE8oUCxpPSEwKXtjb25zdCB1PVBbbV07aWYodSYmdS5jaGlsZHJlblswXSl7Y29uc3QgYT1QLnN2ZyxoPVAubGF5ZXI/UC5sYXllci5kaXNwbGF5UmF0aW86MTtpZighYS5oYXNBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSl7bGV0IEE9YS5nZXRBdHRyaWJ1dGUoIndpZHRoIik7QT1BP09iamVjdChjLnNpemVUb1BpeGVsKShBKTozMDA7bGV0IEw9YS5nZXRBdHRyaWJ1dGUoImhlaWdodCIpO0w9TD9PYmplY3QoYy5zaXplVG9QaXhlbCkoTCk6MTUwLGEuaGFzQXR0cmlidXRlKCJ2aWV3Qm94Iil8fGEuc2V0QXR0cmlidXRlKCJ2aWV3Qm94IixgMCAwICR7TWF0aC5yb3VuZChBKX0gJHtNYXRoLnJvdW5kKEwpfWApLGEuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIixBKSxhLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiLEwpfWxldCBiPVAuYXR0cmlidXRlcy53aWR0aHx8TnVtYmVyKGEuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpLEU9UC5hdHRyaWJ1dGVzLmhlaWdodHx8TnVtYmVyKGEuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIpKTtpZihiKj1oLEUqPWgsaSYmUC5hdHRyaWJ1dGVzLmZsZXhpYmxlKXtjb25zdCBBPVAuYXR0cmlidXRlcy5zY2FsZVswXTtpZihiKj1BLEUqPUEsYS5zZXRBdHRyaWJ1dGUoIndpZHRoIixiKSxhLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixFKSxiJiZFJiZQLnRleHR1cmVJbWFnZSl7Y29uc3QgTD1QLnRleHR1cmVJbWFnZS53aWR0aCxTPVAudGV4dHVyZUltYWdlLmhlaWdodCxJPVAuY2xpZW50U2l6ZTtQLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9WzAsMCxNYXRoLnJvdW5kKElbMF0qTC9iKSxNYXRoLnJvdW5kKElbMV0qUy9FKV19fWVsc2UgUFtUXXx8KGEuc2V0QXR0cmlidXRlKCJ3aWR0aCIsYiksYS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsRSksUFtUXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57ZGVsZXRlIFBbVF07Y29uc3QgQT11LmlubmVySFRNTCxMPW5ldyBCbG9iKFtBXSx7dHlwZToiaW1hZ2Uvc3ZnK3htbCJ9KSxTPVVSTC5jcmVhdGVPYmplY3RVUkwoTCksST1uZXcgSW1hZ2U7SS5vbmxvYWQ9ZnVuY3Rpb24oKXtJLndpZHRoJiZJLmhlaWdodD8oUC5hdHRyaWJ1dGVzW3ldKCJ0ZXh0dXJlIixJKSxQLmF0dHJpYnV0ZXMuZmxleGlibGUmJihQLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9bnVsbCkpOlAuYXR0cmlidXRlc1t5XSgidGV4dHVyZSIsbnVsbCl9LEkuc3JjPVN9KSl9fWNsYXNzIHYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoaT17fSl7dHlwZW9mIGk9PSJzdHJpbmciJiYoaT17c3ZnVGV4dDppfSk7bGV0e3N2Z1RleHQ6dX09aSxhPW8oaSxbInN2Z1RleHQiXSk7aWYoc3VwZXIoYSksdGhpc1ttXT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSx1KXt0aGlzW21dLmlubmVySFRNTD11O2NvbnN0IGg9dGhpc1ttXS5jaGlsZHJlblswXTtoP2guc2V0QXR0cmlidXRlKCJ4bWxucyIsZyk6KGZldGNoKHUpLnRoZW4oYj0+Yi50ZXh0KCkpLnRoZW4oYj0+e3RoaXNbbV0uaW5uZXJIVE1MPWIsKCF0aGlzLm9ic2VydmVyfHx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUpJiZPKHRoaXMpfSksdT1udWxsKX1pZighdSl7Y29uc3QgaD1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZywic3ZnIik7aC5zZXRBdHRyaWJ1dGUoInhtbG5zIixnKSx0aGlzW21dLmFwcGVuZENoaWxkKGgpfWlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPT0iZnVuY3Rpb24iKXtjb25zdCBoPW5ldyBNdXRhdGlvbk9ic2VydmVyKGI9PntPKHRoaXMsITEpfSk7aC5vYnNlcnZlKHRoaXNbbV0se2F0dHJpYnV0ZXM6ITAsc3VidHJlZTohMCxjaGFyYWN0ZXJEYXRhOiEwLGNoaWxkTGlzdDohMH0pLHRoaXMub2JzZXJ2ZXI9aH19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgY2hpbGROb2Rlcygpe3JldHVyblt0aGlzLnN2Z119Z2V0IHN2Zygpe3JldHVybiB0aGlzW21dP3RoaXNbbV0uY2hpbGRyZW5bMF06bnVsbH1zZXRSZXNvbHV0aW9uKHt3aWR0aDppLGhlaWdodDp1fSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6aSxoZWlnaHQ6dX0pLE8odGhpcyl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoaSl7Y29uc3QgdT1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChpKTtpZih1JiZ0aGlzLmF0dHJpYnV0ZXMucGFzc0V2ZW50cyYmdHlwZW9mIE1vdXNlRXZlbnQ9PSJmdW5jdGlvbiIpe2NvbnN0e3g6YSx5Omh9PWk7bGV0W2IsRV09dGhpcy5nZXRPZmZzZXRQb3NpdGlvbihhLGgpO2NvbnN0IEE9aS5vcmlnaW5hbEV2ZW50LEw9dGhpcy5hdHRyaWJ1dGVzLmFuY2hvcixTPXRoaXMuY2xpZW50U2l6ZTtiPShiK0xbMF0qU1swXSkvMixFPShFK0xbMV0qU1sxXSkvMjtjb25zdCBJPWkudHlwZTtpZihJPT09QS50eXBlKXtsZXQgRD1udWxsO2lmKEEgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KUQ9bmV3IE1vdXNlRXZlbnQoSSx7c2NyZWVuWDpiLHNjcmVlblk6RSxjbGllbnRYOmIsY2xpZW50WTpFLGJ1YmJsZXM6QS5idWJibGVzLGJ1dHRvbjpBLmJ1dHRvbixidXR0b25zOkEuYnV0dG9ucyxjYW5jZWxCdWJibGU6QS5jYW5jZWxCdWJibGUsY2FuY2VsYWJsZTpBLmNhbmNlbGFibGUsY3VycmVudFRhcmdldDpBLmN1cnJlbnRUYXJnZXQsZnJvbUVsZW1lbnQ6QS5mcm9tRWxlbWVudCxyZWxhdGVkVGFyZ2V0OkEucmVsYXRlZFRhcmdldCxyZXR1cm5WYWx1ZTpBLnJldHVyblZhbHVlLHNyY0VsZW1lbnQ6QS5zcmNFbGVtZW50LHRhcmdldDpBLnRhcmdldCx0b0VsZW1lbnQ6QS50b0VsZW1lbnQsd2hpY2g6QS53aXRjaH0pO2Vsc2UgaWYoQSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpe2xldCBSPW51bGw7Y29uc3QgQz1BLmNoYW5nZWRUb3VjaGVzfHxbQV07Zm9yKGxldCBqPTA7ajxDLmxlbmd0aDtqKyspe2NvbnN0ICQ9Q1tqXTtpZihpLmlkZW50aWZpZXI9PT0kLmlkZW50aWZpZXIpe1I9JDticmVha319aWYoUil7Y29uc3Qgaj1uZXcgVG91Y2goe2lkZW50aWZpZXI6Ui5pZGVudGlmaWVyLHRhcmdldDpSLnRhcmdldCxjbGllbnRYOmIsY2xpZW50WTpFLHNjcmVlblg6YixzY3JlZW5ZOkUscGFnZVg6YixwYWdlWTpFLHJhZGl1c1g6Ui5yYWRpdXNYLHJhZGl1c1k6Ui5yYWRpdXNZLHJvdGF0aW9uQW5nbGU6Ui5yb3RhdGlvbkFuZ2xlLGZvcmNlOlIuZm9yY2V9KTtEPW5ldyBUb3VjaEV2ZW50KEkse2NhbmNlbGFibGU6QS5jYW5jZWxhYmxlLGJ1YmJsZXM6QS5idWJibGVzLGNvbXBvc2VkOkEuY29tcG9zZWQsdG91Y2hlczpbal0sdGFyZ2V0VG91Y2hlczpbal0sY2hhbmdlZFRvdWNoZXM6W2pdfSl9fWVsc2UgRD1BO0QmJnRoaXMuc3ZnLmRpc3BhdGNoRXZlbnQoRCl9fXJldHVybiB1fWdldEVsZW1lbnRCeUlkKGkpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yKShgIyR7aX1gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUoaSl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtpfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUoaSl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtpfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShpKXtyZXR1cm4gT2JqZWN0KGwucXVlcnlTZWxlY3RvckFsbCkoaSx0aGlzKX1xdWVyeVNlbGVjdG9yKGkpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yKShpLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoaSl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKGksdGhpcyl9b25Qcm9wZXJ0eUNoYW5nZShpLHUsYSl7c3VwZXIub25Qcm9wZXJ0eUNoYW5nZShpLHUsYSksaT09PSJmbGV4aWJsZSImJk8odGhpcyksdGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYoaT09PSJ3aWR0aCJ8fGk9PT0iaGVpZ2h0Inx8aT09PSJzY2FsZSJ8fGk9PT0idHJhbnNmb3JtIikmJk8odGhpcyl9fXgodiwiQXR0ciIsbi5kZWZhdWx0KSxzLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHYsInNwcml0ZXN2ZyIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBuPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iik7Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW2xdKHtwYXNzRXZlbnRzOiExLGZsZXhpYmxlOiExfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tuXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe31nZXQgcGFzc0V2ZW50cygpe3JldHVybiB0aGlzW25dKCJwYXNzRXZlbnRzIil9c2V0IHBhc3NFdmVudHMoZil7cmV0dXJuIHRoaXNbc10oInBhc3NFdmVudHMiLGYpfWdldCBmbGV4aWJsZSgpe3JldHVybiB0aGlzW25dKCJmbGV4aWJsZSIpfXNldCBmbGV4aWJsZShmKXtyZXR1cm4gdGhpc1tzXSgiZmxleGlibGUiLGYpfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oZix4KXt2YXIgZz1PYmplY3Qua2V5cyhmKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgeT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGYpO3gmJih5PXkuZmlsdGVyKGZ1bmN0aW9uKG0pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGYsbSkuZW51bWVyYWJsZX0pKSxnLnB1c2guYXBwbHkoZyx5KX1yZXR1cm4gZ31mdW5jdGlvbiBzKGYpe2Zvcih2YXIgeD0xO3g8YXJndW1lbnRzLmxlbmd0aDt4Kyspe3ZhciBnPWFyZ3VtZW50c1t4XSE9bnVsbD9hcmd1bWVudHNbeF06e307eCUyP24oT2JqZWN0KGcpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHkpe2woZix5LGdbeV0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhnKSk6bihPYmplY3QoZykpLmZvckVhY2goZnVuY3Rpb24oeSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGYseSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGcseSkpfSl9cmV0dXJuIGZ9ZnVuY3Rpb24gbChmLHgsZyl7cmV0dXJuIHggaW4gZj9PYmplY3QuZGVmaW5lUHJvcGVydHkoZix4LHt2YWx1ZTpnLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Zlt4XT1nLGZ9Y29uc3QgYz1TeW1ib2woImluaXRlZCIpO2xldCBvPW51bGw7dHlwZW9mIFdvcmtlcj09ImZ1bmN0aW9uIiYmKG89Y2xhc3MgZXh0ZW5kcyBXb3JrZXJ7Y29uc3RydWN0b3IoZil7aWYoZi53b3JrZXI9PT0hMCYmKGYud29ya2VyPWAuLyR7Zi5pZH0ud29ya2VyLmpzYCksc3VwZXIoZi53b3JrZXIpLHRoaXMub3B0aW9ucz1mLCFmLmNhbnZhcyl7Y29uc3R7d2lkdGg6eCxoZWlnaHQ6Z309dGhpcy5nZXRSZXNvbHV0aW9uKCkseT1yLkVOVi5jcmVhdGVDYW52YXMoeCxnLHtvZmZzY3JlZW46ITF9KTt5LnN0eWxlJiYoeS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSx5LmRhdGFzZXQmJih5LmRhdGFzZXQubGF5ZXJJZD1mLmlkKSxmLmNhbnZhcz15fXRoaXMuY2FudmFzPWYuY2FudmFzfWdldCBpZCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaWR9c2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6eH0pe2lmKHRoaXNbY10pdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToicmVzb2x1dGlvbl9jaGFuZ2UiLHdpZHRoOmYsaGVpZ2h0Onh9KTtlbHNle3RoaXMuY2FudmFzLndpZHRoPWYsdGhpcy5jYW52YXMuaGVpZ2h0PXg7Y29uc3QgZz10aGlzLm9wdGlvbnMseT1nLmNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpLG09cyh7fSxnKTtkZWxldGUgbS5jb250YWluZXIsbS5jYW52YXM9eSx0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJjcmVhdGUiLG9wdGlvbnM6bX0sW3ldKSx0aGlzW2NdPSEwfX1nZXRSZXNvbHV0aW9uKCl7aWYodGhpcy5jYW52YXMpe2NvbnN0e3dpZHRoOmYsaGVpZ2h0Onh9PXRoaXMuY2FudmFzO3JldHVybnt3aWR0aDpmLGhlaWdodDp4fX1yZXR1cm57d2lkdGg6MzAwLGhlaWdodDoxNTB9fXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1jb25uZWN0KGYseCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOmYsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOngsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9ZGlzY29ubmVjdCgpe2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXJ9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoZil7dGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiZXZlbnQiLGV2ZW50OntjYW5jZWxCdWJibGU6Zi5jYW5jZWxCdWJibGUsYnViYmxlczpmLmJ1YmJsZXMsZGV0YWlsOmYuZGV0YWlsLGlkZW50aWZpZXI6Zi5pZGVudGlmaWVyLGxheWVyWDpmLmxheWVyWCxsYXllclk6Zi5sYXllclksb3JpZ2luYWxYOmYub3JpZ2luYWxYLG9yaWdpbmFsWTpmLm9yaWdpbmFsWSx0eXBlOmYudHlwZSx4OmYueCx5OmYueX19KX19KSxlLmRlZmF1bHQ9b30sZnVuY3Rpb24oZCxlLHQpe3QucihlKSwoZnVuY3Rpb24ocil7dC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KTt2YXIgbj10KDEyKSxzPXQoNjgpLGw9dCg3MCksYz10KDI4Niksbz10KDI4OSksZj10KDI1MCkseD10KDI5MSksZz10KDIxNCkseT10KDIxOCksbT10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFQ9U3ltYm9sKCJlbnRlcmVkVGFyZ2V0cyIpO2Z1bmN0aW9uIE8oRSl7cmV0dXJuIEUuaWQ9RS5pZHx8YF9sYXllciR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwxMil9YCxFLmRhdGFzZXR8fChFLmRhdGFzZXQ9e30pLEUuZGF0YXNldC5sYXllcklkPUUuaWQsRS5jb25uZWN0PShBLEwpPT57RS5wYXJlbnQ9QSxPYmplY3QuZGVmaW5lUHJvcGVydHkoRSwiek9yZGVyIix7dmFsdWU6TCx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX0sRS5kaXNjb25uZWN0PUE9PntkZWxldGUgRS56T3JkZXJ9LEUuY2FudmFzPUUsRS5nZXRSZXNvbHV0aW9uPSgpPT4oe3dpZHRoOjAsaGVpZ2h0OjB9KSxFLnNldFJlc29sdXRpb249KCk9PiExLEUub3B0aW9ucz17aGFuZGxlRXZlbnQ6ITF9LEV9ZnVuY3Rpb24gdihFLEEpe2NvbnN0IEw9RS5jaGlsZHJlbjtsZXQgUz1udWxsO2ZvcihsZXQgST0wO0k8TC5sZW5ndGg7SSsrKXtjb25zdCBEPUxbSV07aWYoKEE9PT1EfHxTIT1udWxsKSYmKFM9RCksUyYmUyE9PUEmJiFTLm9mZnNjcmVlbilyZXR1cm4gUy5jYW52YXN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gUChFLEEpe2NvbnN0W0wsU109RS5yZW5kZXJPZmZzZXQse3dpZHRoOkksaGVpZ2h0OkR9PUUuZ2V0UmVzb2x1dGlvbigpLFI9RS5kaXNwbGF5UmF0aW87RS5yZW5kZXJlci5kcmF3SW1hZ2UoQS5jYW52YXMsLUwvUiwtUy9SLEkvUixEL1IpfWNvbnN0IGk9e307ZnVuY3Rpb24gdShFKXtjb25zdCBBPVsibW91c2Vkb3duIiwibW91c2V1cCIsIm1vdXNlbW92ZSIsIm1vdXNld2hlZWwiLCJ3aGVlbCIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoY2FuY2VsIiwiY2xpY2siLCJkYmxjbGljayIsImxvbmdwcmVzcyIsInRhcCIsImNvbnRleHRtZW51Il0sTD1FLmNvbnRhaW5lcjtMLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLFM9Pntjb25zdCBJPUVbVF07aWYoSS5zaXplKXtjb25zdCBEPW5ldyBnLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTtELnNldE9yaWdpbmFsRXZlbnQoUyksWy4uLkldLmZvckVhY2goUj0+e1IuZGlzcGF0Y2hFdmVudChEKX0pLEVbVF0uY2xlYXIoKX19LHtwYXNzaXZlOiEwfSksQS5mb3JFYWNoKFM9PntMLmFkZEV2ZW50TGlzdGVuZXIoUyxJPT57Y29uc3R7bGVmdDpELHRvcDpSLGRpc3BsYXlSYXRpbzpDfT1FLm9wdGlvbnMsaj1FLm9yZGVyZWRDaGlsZHJlbjtPYmplY3QoeC5kZWZhdWx0KShJLHtvZmZzZXRMZWZ0OkQsb2Zmc2V0VG9wOlIsZGlzcGxheVJhdGlvOkN9KS5mb3JFYWNoKEg9Pntjb25zdCBKPUguaWRlbnRpZmllcjtpZihILnR5cGU9PT0idG91Y2htb3ZlInx8SC50eXBlPT09InRvdWNoZW5kIil7Y29uc3QgRj1pW0pdO0YmJkYuZGlzcGF0Y2hFdmVudChIKSxILnR5cGU9PT0idG91Y2hlbmQiJiZkZWxldGUgaVtKXX1lbHNle2ZvcihsZXQgRj1qLmxlbmd0aC0xO0Y+PTA7Ri0tKXtjb25zdCBHPWpbRl07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe2lmKEcuZGlzcGF0Y2hQb2ludGVyRXZlbnQoSCkmJkgudGFyZ2V0IT09RylicmVhaztILmNhbmNlbEJ1YmJsZT0hMX19aWYoSC50YXJnZXQ9PT1qWzBdKWZvcihsZXQgRj1qLmxlbmd0aC0xO0Y+PTA7Ri0tKXtjb25zdCBHPWpbRl07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe0gudGFyZ2V0PUc7YnJlYWt9fX1jb25zdCBxPUgudGFyZ2V0O2lmKEgudHlwZT09PSJ0b3VjaHN0YXJ0IiYmKGlbSl09SC50YXJnZXQpLEgudHlwZT09PSJtb3VzZW1vdmUiKXtjb25zdCBGPUVbVF07bGV0IEc7aWYocSl7Y29uc3QgZXQ9cS5hbmNlc3RvcnN8fFtdO0c9bmV3IFNldChbcSwuLi5ldF0pfWVsc2UgRz1uZXcgU2V0O2NvbnN0IFo9T2JqZWN0LmVudHJpZXMoSSk7aWYoIUYuaGFzKHEpJiZxKXtjb25zdCBldD1uZXcgZy5kZWZhdWx0KCJtb3VzZWVudGVyIik7ZXQuc2V0T3JpZ2luYWxFdmVudChJKSxaLmZvckVhY2goKFtrLGh0XSk9PntldFtrXT1odH0pLEYuYWRkKHEpLHEuZGlzcGF0Y2hFdmVudChldCk7Y29uc3QgaXQ9cS5hbmNlc3RvcnM7aXQmJml0LmZvckVhY2goaz0+e2sgaW5zdGFuY2VvZiBsLmRlZmF1bHQmJiFGLmhhcyhrKSYmKEYuYWRkKGspLGsuZGlzcGF0Y2hFdmVudChldCkpfSl9Y29uc3QgdHQ9bmV3IGcuZGVmYXVsdCgibW91c2VsZWF2ZSIpO3R0LnNldE9yaWdpbmFsRXZlbnQoSSksWi5mb3JFYWNoKChbZXQsaXRdKT0+e3R0W2V0XT1pdH0pLFsuLi5GXS5mb3JFYWNoKGV0PT57Ry5oYXMoZXQpfHwoRi5kZWxldGUoZXQpLGV0LmRpc3BhdGNoRXZlbnQodHQpKX0pfX0pfSx7cGFzc2l2ZTpTIT09ImNvbnRleHRtZW51In0pfSl9ZnVuY3Rpb24gYShFLEEpe2lmKEEmJkEuc3R5bGUpe2xldHt3aWR0aDpMLGhlaWdodDpTLG1vZGU6SSxjb250YWluZXI6RH09RTtjb25zdHtjbGllbnRXaWR0aDpSLGNsaWVudEhlaWdodDpDfT1EO0w9THx8UixTPVN8fEMsST09PSJzdGF0aWMiPyhBLnN0eWxlLndpZHRoPWAke0x9cHhgLEEuc3R5bGUuaGVpZ2h0PWAke1N9cHhgKTooQS5zdHlsZS50b3A9IjAiLEEuc3R5bGUubGVmdD0iMCIsQS5zdHlsZS53aWR0aD1gJHtSfXB4YCxBLnN0eWxlLmhlaWdodD1gJHtDfXB4YCxBLnN0eWxlLnRyYW5zZm9ybT0iIixBLnN0eWxlLndlYmtpdFRyYW5zZm9ybT0iIil9fWNvbnN0IGg9U3ltYm9sKCJvZmZzY3JlZW5MYXllckNvdW50Iik7Y2xhc3MgYiBleHRlbmRzIGYuZGVmYXVsdHtjb25zdHJ1Y3RvcihBPXt9KXtpZihzdXBlcigpLCFBLmNvbnRhaW5lcilpZih0eXBlb2Ygbi5FTlYuQ29udGFpbmVyPT0iZnVuY3Rpb24iKUEuY29udGFpbmVyPW5ldyBuLkVOVi5Db250YWluZXIoQS53aWR0aHx8MzAwLEEuaGVpZ2h0fHwxNTApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJObyBjb250YWluZXIgc3BlY2lmaWVkLiIpO2lmKHRoaXMuY29udGFpbmVyPUEuY29udGFpbmVyLHRoaXMuY29udGFpbmVyLnN0eWxlJiYodGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3d8fCh0aGlzLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIiksdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb258fCh0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiKSksdGhpcy5vcHRpb25zPUEsQS5kaXNwbGF5UmF0aW89QS5kaXNwbGF5UmF0aW98fDEsQS5tb2RlPUEubW9kZXx8InNjYWxlIixBLmxlZnQ9MCxBLnRvcD0wLEEuYXV0b1Jlc2l6ZT1BLmF1dG9SZXNpemUhPT0hMSxBLmF1dG9SZXNpemUpe2xldCBMO2lmKHR5cGVvZiBnbG9iYWxUaGlzPCJ1Ij9MPWdsb2JhbFRoaXM6TD10eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6cixMLmFkZEV2ZW50TGlzdGVuZXIpe2NvbnN0IFM9dGhpcztMLmFkZEV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsZnVuY3Rpb24gSSgpe3R5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmNvbnRhaW5zKFMuY29udGFpbmVyKT9TLnJlc2l6ZSgpOkwucmVtb3ZlRXZlbnRMaXN0ZW5lcigicmVzaXplIixJKX0pfX10aGlzW1RdPW5ldyBTZXQsdGhpcy5zZXRSZXNvbHV0aW9uKEEpLHUodGhpcyksdGhpc1toXT0wfWdldCBoYXNPZmZzY3JlZW5DYW52YXMoKXtyZXR1cm4gdGhpc1toXT4wfXNldCBkaXNwbGF5UmF0aW8oQSl7dGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpbyE9PUEmJih0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvPUEsdGhpcy5yZXNpemUoKSl9Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvfXNldCBoZWlnaHQoQSl7dGhpcy5vcHRpb25zLmhlaWdodCE9PUEmJih0aGlzLm9wdGlvbnMuaGVpZ2h0PUEsdGhpcy5yZXNpemUoKSl9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaGVpZ2h0fXNldCBtb2RlKEEpe3RoaXMub3B0aW9ucy5tb2RlIT09QSYmKHRoaXMub3B0aW9ucy5tb2RlPUEsdGhpcy5yZXNpemUoKSl9Z2V0IG1vZGUoKXtyZXR1cm4gdGhpcy5vcHRpb25zLm1vZGV9c2V0IHdpZHRoKEEpe3RoaXMub3B0aW9ucy53aWR0aCE9PUEmJih0aGlzLm9wdGlvbnMud2lkdGg9QSx0aGlzLnJlc2l6ZSgpKX1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy5vcHRpb25zLndpZHRofWFwcGVuZENoaWxkKEEpeyEoQSBpbnN0YW5jZW9mIGMuZGVmYXVsdCkmJiEoQSBpbnN0YW5jZW9mIG8uZGVmYXVsdCkmJk8oQSk7Y29uc3QgTD1zdXBlci5hcHBlbmRDaGlsZChBKSxTPUEuY2FudmFzO3JldHVybiBBLm9mZnNjcmVlbj90aGlzW2hdKys6dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoUyksYSh0aGlzLm9wdGlvbnMsUyksQS5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxMfWZvcmNlVXBkYXRlKCl7dGhpcy5oYXNPZmZzY3JlZW5DYW52YXMmJiF0aGlzLl9yZXF1ZXN0SUQmJih0aGlzLl9yZXF1ZXN0SUQ9T2JqZWN0KHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSgoKT0+e2RlbGV0ZSB0aGlzLl9yZXF1ZXN0SUQsdGhpcy5yZW5kZXIoKX0pKX1pbnNlcnRCZWZvcmUoQSxMKXshKEEgaW5zdGFuY2VvZiBjLmRlZmF1bHQpJiYhKEEgaW5zdGFuY2VvZiBvLmRlZmF1bHQpJiZPKEEpO2NvbnN0IFM9c3VwZXIuaW5zZXJ0QmVmb3JlKEEsTCksST1BLmNhbnZhcztpZighQS5vZmZzY3JlZW4pe2NvbnN0IEQ9dih0aGlzLEEpO3RoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShJLEQpfXJldHVybiBhKHRoaXMub3B0aW9ucyxJKSxBLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLFN9bGF5ZXIoQT0iZGVmYXVsdCIsTD17fSl7TD1PYmplY3QuYXNzaWduKHt9LHRoaXMub3B0aW9ucyxMKSxMLmlkPUE7Y29uc3QgUz10aGlzLm9yZGVyZWRDaGlsZHJlbjtmb3IobGV0IFI9MDtSPFMubGVuZ3RoO1IrKylpZihTW1JdLmlkPT09QSlyZXR1cm4gU1tSXTtjb25zdCBJPUwud29ya2VyO2xldCBEO3JldHVybiBJP0Q9bmV3IG8uZGVmYXVsdChMKTpEPW5ldyBjLmRlZmF1bHQoTCksdGhpcy5hcHBlbmRDaGlsZChEKSxEfWFzeW5jIHByZWxvYWQoLi4uQSl7Y29uc3QgTD1bXSxTPVtdLEk9W107Zm9yKGxldCBEPTA7RDxBLmxlbmd0aDtEKyspe2NvbnN0IFI9QVtEXTtsZXQgQztpZih0eXBlb2YgUj09InN0cmluZyIpQz1PYmplY3QoeS5sb2FkVGV4dHVyZSkoUik7ZWxzZSBpZihBcnJheS5pc0FycmF5KFIpKUM9T2JqZWN0KHkubG9hZEZyYW1lcykoLi4uUik7ZWxzZXtjb25zdHtpZDpqLHNyYzokfT1SO0M9T2JqZWN0KHkubG9hZFRleHR1cmUpKCQsail9QyBpbnN0YW5jZW9mIFByb21pc2V8fChDPVByb21pc2UucmVzb2x2ZShDKSksUy5wdXNoKEMudGhlbihqPT57TC5wdXNoKGopLElbRF09ajtjb25zdCAkPW5ldyBnLmRlZmF1bHQoe3R5cGU6InByZWxvYWQiLGRldGFpbDp7Y3VycmVudDpqLGxvYWRlZDpMLHJlc291cmNlczpBfX0pO3RoaXMuZGlzcGF0Y2hFdmVudCgkKX0pKX1yZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoUyksSX1yZW1vdmVDaGlsZChBKXtjb25zdCBMPXN1cGVyLnJlbW92ZUNoaWxkKEEpO2lmKEwpe0EuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCYmQS5fcHJlcGFyZVJlbmRlckZpbmlzaGVkKCk7Y29uc3QgUz1BLmNhbnZhcztTJiZTLnJlbW92ZSYmUy5yZW1vdmUoKSxBLm9mZnNjcmVlbiYmdGhpc1toXS0tfXJldHVybiBMfXJlbmRlcigpe2NvbnN0IEE9dGhpcy5vcmRlcmVkQ2hpbGRyZW47bGV0IEw9bnVsbDtjb25zdCBTPVtdO2ZvcihsZXQgST0wO0k8QS5sZW5ndGg7SSsrKXtjb25zdCBEPUFbSV0sUj1TLmxlbmd0aD4wO2lmKEQgaW5zdGFuY2VvZiBjLmRlZmF1bHQmJiFELm9mZnNjcmVlbilpZighRC5hdXRvUmVuZGVyKVImJihjb25zb2xlLndhcm4oIlNvbWUgb2Zmc2NyZWVuIGNhbnZhcyB3aWxsIG5vdCBiZSByZW5kZXJlZC4iKSxTLmxlbmd0aD0wKTtlbHNlIGlmKEw9RCxSKXtELnJlbmRlcmVyLmNsZWFyKCk7Zm9yKGxldCBDPTA7QzxTLmxlbmd0aDtDKyspe2NvbnN0IGo9U1tDXTtqLnJlbmRlcigpLFAoRCxqKX1TLmxlbmd0aD0wLEQucmVuZGVyKHtjbGVhcjohMX0pfWVsc2UgRC5wcmVwYXJlUmVuZGVyJiZELnJlbmRlcigpO2Vsc2UgRC5vZmZzY3JlZW4/TD8oRC5wcmVwYXJlUmVuZGVyJiZELnJlbmRlcigpLFAoTCxEKSk6Uy5wdXNoKEQpOkQgaW5zdGFuY2VvZiBvLmRlZmF1bHQmJlImJihjb25zb2xlLndhcm4oIlNvbWUgb2Zmc2NyZWVuIGNhbnZhcyB3aWxsIG5vdCBiZSByZW5kZXJlZC4iKSxTLmxlbmd0aD0wKX19cmVwbGFjZUNoaWxkKEEsTCl7Y29uc3QgUz1zdXBlci5yZXBsYWNlQ2hpbGQoQSxMKTtMLmNhbnZhcy5yZW1vdmUmJkwuY2FudmFzLnJlbW92ZSgpLEwub2Zmc2NyZWVuJiZ0aGlzW2hdLS07Y29uc3QgST1BLmNhbnZhcztpZighQS5vZmZzY3JlZW4pe2NvbnN0IEQ9dih0aGlzLEEpO3RoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShJLEQpfXJldHVybiBhKHRoaXMub3B0aW9ucyxJKSxBLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLFN9cmVzaXplKCl7Y29uc3QgQT10aGlzLm9wdGlvbnM7dGhpcy5jaGlsZHJlbi5mb3JFYWNoKEw9PnthKEEsTC5jYW52YXMpfSksdGhpcy5zZXRSZXNvbHV0aW9uKEEpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzaXplIn0pfXNldFJlc29sdXRpb24oe3dpZHRoOkEsaGVpZ2h0Okx9PXt9KXtjb25zdCBTPXRoaXMuY29udGFpbmVyLHtjbGllbnRXaWR0aDpJLGNsaWVudEhlaWdodDpEfT1TOyhBPT1udWxsfHxMPT1udWxsKSYmKEE9QT8/SSxMPUw/P0QpO2NvbnN0e21vZGU6UixkaXNwbGF5UmF0aW86Q309dGhpcy5vcHRpb25zO2lmKEEqPUMsTCo9Qyx0aGlzLm9wdGlvbnMubGVmdD0wLHRoaXMub3B0aW9ucy50b3A9MCxSPT09InN0aWNreUhlaWdodCJ8fFI9PT0ic3RpY2t5TGVmdCJ8fFI9PT0ic3RpY2t5UmlnaHQiKXtjb25zdCBqPUE7QT1JKkwvRCxSPT09InN0aWNreUhlaWdodCImJih0aGlzLm9wdGlvbnMubGVmdD0uNSooQS1qKSksUj09PSJzdGlja3lSaWdodCImJih0aGlzLm9wdGlvbnMubGVmdD1BLWopfWVsc2UgaWYoUj09PSJzdGlja3lXaWR0aCJ8fFI9PT0ic3RpY2t5VG9wInx8Uj09PSJzdGlja3lCb3R0b20iKXtjb25zdCBqPUw7TD1EKkEvSSxSPT09InN0aWNreVdpZHRoIiYmKHRoaXMub3B0aW9ucy50b3A9LjUqKEwtaikpLFI9PT0ic3RpY2t5Qm90dG9tIiYmKHRoaXMub3B0aW9ucy50b3A9TC1qKX1zdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpBLGhlaWdodDpMfSl9c25hcHNob3Qoe29mZnNjcmVlbjpBPSExLGxheWVyczpMfT17fSl7Y29uc3QgUz1BPyJzbmFwc2hvdE9mZlNjcmVlbkNhbnZhcyI6InNuYXBzaG90Q2FudmFzIix7d2lkdGg6SSxoZWlnaHQ6RH09dGhpcy5nZXRSZXNvbHV0aW9uKCk7dGhpc1tTXT10aGlzW1NdfHxuLkVOVi5jcmVhdGVDYW52YXMoSSxELHtvZmZzY3JlZW46QX0pO2NvbnN0IFI9dGhpc1tTXS5nZXRDb250ZXh0KCIyZCIpO0w9THx8dGhpcy5vcmRlcmVkQ2hpbGRyZW4sdGhpc1tTXS53aWR0aD1JLHRoaXNbU10uaGVpZ2h0PUQ7Zm9yKGxldCBDPTA7QzxMLmxlbmd0aDtDKyspe2NvbnN0IGo9TFtDXTtpZighai5vcHRpb25zLmlnbm9yZVNuYXBzaG90KXtqLnJlbmRlciYmai5yZW5kZXIoKTtjb25zdCAkPWouY2FudmFzOyQmJiQhPT1qJiZSLmRyYXdJbWFnZSgkLDAsMCxJLEQpfX1yZXR1cm4gdGhpc1tTXX19dHlwZW9mIGRvY3VtZW50PCJ1IiYmKGIucHJvdG90eXBlLmxheWVyM2Q9ZnVuY3Rpb24oRSxBPXt9KXtjb25zdCBMPUEudXJsfHwiaHR0cHM6Ly91bnBrZy5jb20vc3ByaXRlLWV4dGVuZC0zZC9kaXN0L3Nwcml0ZS1leHRlbmQtM2QubWluLmpzIjtyZXR1cm4gbmV3IFByb21pc2UoKFMsSSk9Pntjb25zdCBEPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpO0QuYXN5bmM9ITEsRC5zcmM9TCxELm9ubG9hZD0oKT0+e3RyeXtTKHRoaXMubGF5ZXIzZChFLEEpKX1jYXRjaChSKXtJKFIpfX0sZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKEQpfSl9KSxtLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsInNjZW5lIil9KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIHI9dCgyMTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHMse29mZnNldFRvcDpsPTAsb2Zmc2V0TGVmdDpjPTAsZGlzcGxheVJhdGlvOm89MX09e30pe2xldCBmLHg7Y29uc3QgZz1bXSx7bGVmdDp5LHRvcDptLHdpZHRoOlQsaGVpZ2h0Ok99PXMudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHY9cy50YXJnZXQud2lkdGgsUD1zLnRhcmdldC5oZWlnaHQsaT1zLmNoYW5nZWRUb3VjaGVzfHxbc107Zm9yKGxldCBhPTA7YTxpLmxlbmd0aDthKyspe2NvbnN0IGg9aVthXSxiPWguaWRlbnRpZmllcix7Y2xpZW50WDpFLGNsaWVudFk6QX09aDtFIT1udWxsJiZBIT1udWxsJiZnLnB1c2goe3g6TWF0aC5yb3VuZCgoRXwwKS15KSx5Ok1hdGgucm91bmQoKEF8MCktbSksaWRlbnRpZmllcjpifSl9Zy5sZW5ndGg8PTAmJmcucHVzaCh7eDpmLHk6eH0pO2NvbnN0IHU9W107cmV0dXJuIGcuZm9yRWFjaChhPT57YS54IT1udWxsJiZhLnkhPW51bGwmJihmPShhLngqdi9ULWMpL28seD0oYS55KlAvTy1sKS9vKTtjb25zdCBoPW5ldyByLmRlZmF1bHQocyk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaCx7bGF5ZXJYOnt2YWx1ZTpmLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTp4LGNvbmZpZ3VyYWJsZTohMH0sb3JpZ2luYWxYOnt2YWx1ZTphLnh9LG9yaWdpbmFsWTp7dmFsdWU6YS55fSx4Ont2YWx1ZTpmLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6eCxjb25maWd1cmFibGU6ITB9LGlkZW50aWZpZXI6e3ZhbHVlOmEuaWRlbnRpZmllcn19KSx1LnB1c2goaCl9KSx1fX1dKTtEdC52ZXJzaW9uLER0LkFyYyxEdC5CbG9jayxEdC5DbG91ZCxEdC5Db2xvcjtjb25zdCB1bj1EdC5FbGxpcHNlO0R0LkdyYWRpZW50O2NvbnN0IGVlPUR0Lkdyb3VwLFNoPUR0LkxhYmVsO0R0LkxheWVyLER0LkxheWVyV29ya2VyLER0Lk5vZGUsRHQuUGFyYWxsZWw7Y29uc3Qgc2U9RHQuUGF0aCxxdD1EdC5Qb2x5bGluZSxycj1EdC5SZWN0O0R0LlJlZ3VsYXIsRHQuUmluZztjb25zdCBNaD1EdC5TY2VuZTtEdC5TcHJpdGUsRHQuU3ByaXRlU3ZnLER0LlN0YXIsRHQuVHJpYW5nbGUsRHQuaGVscGVycyxEdC5jcmVhdGVFbGVtZW50LER0LmlzU3ByaXRlTm9kZSxEdC5yZWdpc3Rlck5vZGUsRHQucmVxdWVzdEFuaW1hdGlvbkZyYW1lLER0LmNhbmNlbEFuaW1hdGlvbkZyYW1lLER0LkVOVjtmdW5jdGlvbiBnZShkLGU9ITApe2NvbnN0IHQ9ZC5sZW5ndGg7aWYodDwyKXJldHVybiIiO2xldCByPWRbMF0sbj1kWzFdO2lmKHQ9PT0yKXJldHVybmBNJHtoZShyKX1MJHtoZShuKX1gO2xldCBzPSIiO2ZvcihsZXQgbD0yLGM9dC0xO2w8YztsKyspcj1kW2xdLG49ZFtsKzFdLHMrPWRlKHIsbik7cmV0dXJuIGU/YE0ke2RlKGRbMF0sZFsxXSl9USR7aGUoZFsxXSl9JHtkZShkWzFdLGRbMl0pfVQke3N9JHtkZShkW3QtMV0sZFswXSl9JHtkZShkWzBdLGRbMV0pfVpgOmBNJHtoZShkWzBdKX1RJHtoZShkWzFdKX0ke2RlKGRbMV0sZFsyXSl9JHtkLmxlbmd0aD4zPyJUIjoiIn0ke3N9TCR7aGUoZFt0LTFdKX1gfXZhciBucj17ZXhwb3J0czp7fX07bnIuZXhwb3J0cyxmdW5jdGlvbihkKXt2YXIgZT1mdW5jdGlvbigpe3ZhciB0PVN0cmluZy5mcm9tQ2hhckNvZGUscj0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0iLG49IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky0kIixzPXt9O2Z1bmN0aW9uIGwobyxmKXtpZighc1tvXSl7c1tvXT17fTtmb3IodmFyIHg9MDt4PG8ubGVuZ3RoO3grKylzW29dW28uY2hhckF0KHgpXT14fXJldHVybiBzW29dW2ZdfXZhciBjPXtjb21wcmVzc1RvQmFzZTY0OmZ1bmN0aW9uKG8pe2lmKG89PW51bGwpcmV0dXJuIiI7dmFyIGY9Yy5fY29tcHJlc3Mobyw2LGZ1bmN0aW9uKHgpe3JldHVybiByLmNoYXJBdCh4KX0pO3N3aXRjaChmLmxlbmd0aCU0KXtkZWZhdWx0OmNhc2UgMDpyZXR1cm4gZjtjYXNlIDE6cmV0dXJuIGYrIj09PSI7Y2FzZSAyOnJldHVybiBmKyI9PSI7Y2FzZSAzOnJldHVybiBmKyI9In19LGRlY29tcHJlc3NGcm9tQmFzZTY0OmZ1bmN0aW9uKG8pe3JldHVybiBvPT1udWxsPyIiOm89PSIiP251bGw6Yy5fZGVjb21wcmVzcyhvLmxlbmd0aCwzMixmdW5jdGlvbihmKXtyZXR1cm4gbChyLG8uY2hhckF0KGYpKX0pfSxjb21wcmVzc1RvVVRGMTY6ZnVuY3Rpb24obyl7cmV0dXJuIG89PW51bGw/IiI6Yy5fY29tcHJlc3MobywxNSxmdW5jdGlvbihmKXtyZXR1cm4gdChmKzMyKX0pKyIgIn0sZGVjb21wcmVzc0Zyb21VVEYxNjpmdW5jdGlvbihvKXtyZXR1cm4gbz09bnVsbD8iIjpvPT0iIj9udWxsOmMuX2RlY29tcHJlc3Moby5sZW5ndGgsMTYzODQsZnVuY3Rpb24oZil7cmV0dXJuIG8uY2hhckNvZGVBdChmKS0zMn0pfSxjb21wcmVzc1RvVWludDhBcnJheTpmdW5jdGlvbihvKXtmb3IodmFyIGY9Yy5jb21wcmVzcyhvKSx4PW5ldyBVaW50OEFycmF5KGYubGVuZ3RoKjIpLGc9MCx5PWYubGVuZ3RoO2c8eTtnKyspe3ZhciBtPWYuY2hhckNvZGVBdChnKTt4W2cqMl09bT4+PjgseFtnKjIrMV09bSUyNTZ9cmV0dXJuIHh9LGRlY29tcHJlc3NGcm9tVWludDhBcnJheTpmdW5jdGlvbihvKXtpZihvPT1udWxsKXJldHVybiBjLmRlY29tcHJlc3Mobyk7Zm9yKHZhciBmPW5ldyBBcnJheShvLmxlbmd0aC8yKSx4PTAsZz1mLmxlbmd0aDt4PGc7eCsrKWZbeF09b1t4KjJdKjI1NitvW3gqMisxXTt2YXIgeT1bXTtyZXR1cm4gZi5mb3JFYWNoKGZ1bmN0aW9uKG0pe3kucHVzaCh0KG0pKX0pLGMuZGVjb21wcmVzcyh5LmpvaW4oIiIpKX0sY29tcHJlc3NUb0VuY29kZWRVUklDb21wb25lbnQ6ZnVuY3Rpb24obyl7cmV0dXJuIG89PW51bGw/IiI6Yy5fY29tcHJlc3Mobyw2LGZ1bmN0aW9uKGYpe3JldHVybiBuLmNoYXJBdChmKX0pfSxkZWNvbXByZXNzRnJvbUVuY29kZWRVUklDb21wb25lbnQ6ZnVuY3Rpb24obyl7cmV0dXJuIG89PW51bGw/IiI6bz09IiI/bnVsbDoobz1vLnJlcGxhY2UoLyAvZywiKyIpLGMuX2RlY29tcHJlc3Moby5sZW5ndGgsMzIsZnVuY3Rpb24oZil7cmV0dXJuIGwobixvLmNoYXJBdChmKSl9KSl9LGNvbXByZXNzOmZ1bmN0aW9uKG8pe3JldHVybiBjLl9jb21wcmVzcyhvLDE2LGZ1bmN0aW9uKGYpe3JldHVybiB0KGYpfSl9LF9jb21wcmVzczpmdW5jdGlvbihvLGYseCl7aWYobz09bnVsbClyZXR1cm4iIjt2YXIgZyx5LG09e30sVD17fSxPPSIiLHY9IiIsUD0iIixpPTIsdT0zLGE9MixoPVtdLGI9MCxFPTAsQTtmb3IoQT0wO0E8by5sZW5ndGg7QSs9MSlpZihPPW8uY2hhckF0KEEpLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtLE8pfHwobVtPXT11KyssVFtPXT0hMCksdj1QK08sT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sdikpUD12O2Vsc2V7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFQsUCkpe2lmKFAuY2hhckNvZGVBdCgwKTwyNTYpe2ZvcihnPTA7ZzxhO2crKyliPWI8PDEsRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrO2Zvcih5PVAuY2hhckNvZGVBdCgwKSxnPTA7Zzw4O2crKyliPWI8PDF8eSYxLEU9PWYtMT8oRT0wLGgucHVzaCh4KGIpKSxiPTApOkUrKyx5PXk+PjF9ZWxzZXtmb3IoeT0xLGc9MDtnPGE7ZysrKWI9Yjw8MXx5LEU9PWYtMT8oRT0wLGgucHVzaCh4KGIpKSxiPTApOkUrKyx5PTA7Zm9yKHk9UC5jaGFyQ29kZUF0KDApLGc9MDtnPDE2O2crKyliPWI8PDF8eSYxLEU9PWYtMT8oRT0wLGgucHVzaCh4KGIpKSxiPTApOkUrKyx5PXk+PjF9aS0tLGk9PTAmJihpPU1hdGgucG93KDIsYSksYSsrKSxkZWxldGUgVFtQXX1lbHNlIGZvcih5PW1bUF0sZz0wO2c8YTtnKyspYj1iPDwxfHkmMSxFPT1mLTE/KEU9MCxoLnB1c2goeChiKSksYj0wKTpFKysseT15Pj4xO2ktLSxpPT0wJiYoaT1NYXRoLnBvdygyLGEpLGErKyksbVt2XT11KyssUD1TdHJpbmcoTyl9aWYoUCE9PSIiKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoVCxQKSl7aWYoUC5jaGFyQ29kZUF0KDApPDI1Nil7Zm9yKGc9MDtnPGE7ZysrKWI9Yjw8MSxFPT1mLTE/KEU9MCxoLnB1c2goeChiKSksYj0wKTpFKys7Zm9yKHk9UC5jaGFyQ29kZUF0KDApLGc9MDtnPDg7ZysrKWI9Yjw8MXx5JjEsRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrLHk9eT4+MX1lbHNle2Zvcih5PTEsZz0wO2c8YTtnKyspYj1iPDwxfHksRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrLHk9MDtmb3IoeT1QLmNoYXJDb2RlQXQoMCksZz0wO2c8MTY7ZysrKWI9Yjw8MXx5JjEsRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrLHk9eT4+MX1pLS0saT09MCYmKGk9TWF0aC5wb3coMixhKSxhKyspLGRlbGV0ZSBUW1BdfWVsc2UgZm9yKHk9bVtQXSxnPTA7ZzxhO2crKyliPWI8PDF8eSYxLEU9PWYtMT8oRT0wLGgucHVzaCh4KGIpKSxiPTApOkUrKyx5PXk+PjE7aS0tLGk9PTAmJihpPU1hdGgucG93KDIsYSksYSsrKX1mb3IoeT0yLGc9MDtnPGE7ZysrKWI9Yjw8MXx5JjEsRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrLHk9eT4+MTtmb3IoOzspaWYoYj1iPDwxLEU9PWYtMSl7aC5wdXNoKHgoYikpO2JyZWFrfWVsc2UgRSsrO3JldHVybiBoLmpvaW4oIiIpfSxkZWNvbXByZXNzOmZ1bmN0aW9uKG8pe3JldHVybiBvPT1udWxsPyIiOm89PSIiP251bGw6Yy5fZGVjb21wcmVzcyhvLmxlbmd0aCwzMjc2OCxmdW5jdGlvbihmKXtyZXR1cm4gby5jaGFyQ29kZUF0KGYpfSl9LF9kZWNvbXByZXNzOmZ1bmN0aW9uKG8sZix4KXt2YXIgZz1bXSx5PTQsbT00LFQ9MyxPPSIiLHY9W10sUCxpLHUsYSxoLGIsRSxBPXt2YWw6eCgwKSxwb3NpdGlvbjpmLGluZGV4OjF9O2ZvcihQPTA7UDwzO1ArPTEpZ1tQXT1QO2Zvcih1PTAsaD1NYXRoLnBvdygyLDIpLGI9MTtiIT1oOylhPUEudmFsJkEucG9zaXRpb24sQS5wb3NpdGlvbj4+PTEsQS5wb3NpdGlvbj09MCYmKEEucG9zaXRpb249ZixBLnZhbD14KEEuaW5kZXgrKykpLHV8PShhPjA/MTowKSpiLGI8PD0xO3N3aXRjaCh1KXtjYXNlIDA6Zm9yKHU9MCxoPU1hdGgucG93KDIsOCksYj0xO2IhPWg7KWE9QS52YWwmQS5wb3NpdGlvbixBLnBvc2l0aW9uPj49MSxBLnBvc2l0aW9uPT0wJiYoQS5wb3NpdGlvbj1mLEEudmFsPXgoQS5pbmRleCsrKSksdXw9KGE+MD8xOjApKmIsYjw8PTE7RT10KHUpO2JyZWFrO2Nhc2UgMTpmb3IodT0wLGg9TWF0aC5wb3coMiwxNiksYj0xO2IhPWg7KWE9QS52YWwmQS5wb3NpdGlvbixBLnBvc2l0aW9uPj49MSxBLnBvc2l0aW9uPT0wJiYoQS5wb3NpdGlvbj1mLEEudmFsPXgoQS5pbmRleCsrKSksdXw9KGE+MD8xOjApKmIsYjw8PTE7RT10KHUpO2JyZWFrO2Nhc2UgMjpyZXR1cm4iIn1mb3IoZ1szXT1FLGk9RSx2LnB1c2goRSk7Oyl7aWYoQS5pbmRleD5vKXJldHVybiIiO2Zvcih1PTAsaD1NYXRoLnBvdygyLFQpLGI9MTtiIT1oOylhPUEudmFsJkEucG9zaXRpb24sQS5wb3NpdGlvbj4+PTEsQS5wb3NpdGlvbj09MCYmKEEucG9zaXRpb249ZixBLnZhbD14KEEuaW5kZXgrKykpLHV8PShhPjA/MTowKSpiLGI8PD0xO3N3aXRjaChFPXUpe2Nhc2UgMDpmb3IodT0wLGg9TWF0aC5wb3coMiw4KSxiPTE7YiE9aDspYT1BLnZhbCZBLnBvc2l0aW9uLEEucG9zaXRpb24+Pj0xLEEucG9zaXRpb249PTAmJihBLnBvc2l0aW9uPWYsQS52YWw9eChBLmluZGV4KyspKSx1fD0oYT4wPzE6MCkqYixiPDw9MTtnW20rK109dCh1KSxFPW0tMSx5LS07YnJlYWs7Y2FzZSAxOmZvcih1PTAsaD1NYXRoLnBvdygyLDE2KSxiPTE7YiE9aDspYT1BLnZhbCZBLnBvc2l0aW9uLEEucG9zaXRpb24+Pj0xLEEucG9zaXRpb249PTAmJihBLnBvc2l0aW9uPWYsQS52YWw9eChBLmluZGV4KyspKSx1fD0oYT4wPzE6MCkqYixiPDw9MTtnW20rK109dCh1KSxFPW0tMSx5LS07YnJlYWs7Y2FzZSAyOnJldHVybiB2LmpvaW4oIiIpfWlmKHk9PTAmJih5PU1hdGgucG93KDIsVCksVCsrKSxnW0VdKU89Z1tFXTtlbHNlIGlmKEU9PT1tKU89aStpLmNoYXJBdCgwKTtlbHNlIHJldHVybiBudWxsO3YucHVzaChPKSxnW20rK109aStPLmNoYXJBdCgwKSx5LS0saT1PLHk9PTAmJih5PU1hdGgucG93KDIsVCksVCsrKX19fTtyZXR1cm4gY30oKTtkIT1udWxsP2QuZXhwb3J0cz1lOnR5cGVvZiBhbmd1bGFyPCJ1IiYmYW5ndWxhciE9bnVsbCYmYW5ndWxhci5tb2R1bGUoIkxaU3RyaW5nIixbXSkuZmFjdG9yeSgiTFpTdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIGV9KX0obnIpO3ZhciBmbj1uci5leHBvcnRzO2Z1bmN0aW9uIEJlKGQpe3JldHVybiBKU09OLnBhcnNlKGZuLmRlY29tcHJlc3MoZCkpfWZ1bmN0aW9uIGt0KGQpe3JldHVybiBmbi5jb21wcmVzcyhKU09OLnN0cmluZ2lmeShkKSl9Y2xhc3MgaG4gZXh0ZW5kcyBndHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6S3QuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZ0LlBlbmNpbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiTUFYX1JFUEVBUiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInVuaVRoaWNrbmVzcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjZW50ZXJQb3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbMCwwXX0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnVuaVRoaWNrbmVzcz10aGlzLk1BWF9SRVBFQVIvdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MvMTAsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tYmluZUNvbnN1bWUoKXt2YXIgbDtjb25zdCBlPShsPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6bC50b1N0cmluZygpLHQ9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCEwKSxyPXtuYW1lOmV9O2xldCBuO2NvbnN0IHM9dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyO3JldHVybiB0Lmxlbmd0aCYmKG49dGhpcy5kcmF3KHthdHRyczpyLHRhc2tzOnQscmVwbGFjZUlkOmUsbGF5ZXI6cyxpc0NsZWFyQWxsOiEwfSkpLHtyZWN0Om4sdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbH19c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlKXt2YXIgTztjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzQ2xlYXJBbGw6bixpc1N1YldvcmtlcjpzfT1lO2lmKCgoTz10Lm9wKT09bnVsbD92b2lkIDA6Ty5sZW5ndGgpPT09MClyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHt3b3JrSWQ6bH09dCx7dGFza3M6YyxlZmZlY3RzOm8sY29uc3VtZUluZGV4OmZ9PXRoaXMudHJhbnNmb3JtRGF0YSh0LCExKTt0aGlzLnN5bmNJbmRleD1NYXRoLm1pbih0aGlzLnN5bmNJbmRleCxmLE1hdGgubWF4KDAsdGhpcy50bXBQb2ludHMubGVuZ3RoLTIpKTtjb25zdCB4PXtuYW1lOmw9PW51bGw/dm9pZCAwOmwudG9TdHJpbmcoKX07bGV0IGcseT0hMTtjb25zdCBtPXRoaXMuc3luY0luZGV4O2lmKHRoaXMuc3luY1RpbWVzdGFtcD09PTAmJih0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKSksYy5sZW5ndGgmJihjWzBdLnRhc2tJZC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWUmJih5PSEwLHRoaXMuc3luY1RpbWVzdGFtcD1jWzBdLnRhc2tJZCx0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLHMpKXtjb25zdCB2PXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyO2c9dGhpcy5kcmF3KHthdHRyczp4LHRhc2tzOmMsZWZmZWN0czpvLGxheWVyOnYsaXNDbGVhckFsbDpufSl9aWYocylyZXR1cm4gZj4xMCYmdGhpcy50bXBQb2ludHMuc3BsaWNlKDAsZi0xMCkse3JlY3Q6Zyx0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsfTtjb25zdCBUPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZShtKS5mb3JFYWNoKHY9PntULnB1c2godi54LHYueSx0aGlzLmNvbXB1dFJhZGl1cyh2LnosdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MpKX0pLHtyZWN0OmcsdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6eT9sOnZvaWQgMCxvcDp5P1Q6dm9pZCAwLGluZGV4Onk/bSozOnZvaWQgMH19Y29uc3VtZUFsbChlKXt2YXIgZix4O2lmKGUuZGF0YSl7Y29uc3R7b3A6Zyx3b3JrU3RhdGU6eX09ZS5kYXRhO2chPW51bGwmJmcubGVuZ3RoJiZ5PT09SXQuRG9uZSYmdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09enQuU3Ryb2tlJiZ0aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShnKX1jb25zdCB0PShmPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Zi50b1N0cmluZygpO2lmKCF0KXJldHVybnt0eXBlOnV0Lk5vbmV9O2NvbnN0IHI9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCEwKSxuPXtuYW1lOnR9O2xldCBzO2NvbnN0IGw9dGhpcy5mdWxsTGF5ZXI7ci5sZW5ndGgmJihzPXRoaXMuZHJhdyh7YXR0cnM6bix0YXNrczpyLHJlcGxhY2VJZDp0LGxheWVyOmwsaXNDbGVhckFsbDohMX0pKTtjb25zdCBjPVtdO3RoaXMudG1wUG9pbnRzLm1hcChnPT57Yy5wdXNoKGcueCxnLnksdGhpcy5jb21wdXRSYWRpdXMoZy56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx0aGlzLnN5bmNUaW1lc3RhbXA9MCxkZWxldGUgdGhpcy53b3JrT3B0aW9ucy5zeW5jVW5pdFRpbWU7Y29uc3Qgbz1rdChjKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyh0LHtyZWN0OnMsb3A6YyxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cyYmZ3QuZ2V0Q2VudGVyUG9zKHMsbCl9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnQsb3BzOm8sdXBkYXRlTm9kZU9wdDp7cG9zOnRoaXMuY2VudGVyUG9zLHVzZUFuaW1hdGlvbjohMH0sb3B0OnRoaXMud29ya09wdGlvbnMsdW5kb1RpY2tlcklkOih4PWUuZGF0YSk9PW51bGw/dm9pZCAwOngudW5kb1RpY2tlcklkfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHg7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOnIscmVwbGFjZUlkOm4saXNDbGVhckFsbDpzfT1lO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgZz0wO2c8dC5sZW5ndGg7Zys9Myl7Y29uc3QgeT1uZXcgT3QodFtnXSx0W2crMV0sdFtnKzJdKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg+MCl7Y29uc3QgbT10aGlzLnRtcFBvaW50c1t0aGlzLnRtcFBvaW50cy5sZW5ndGgtMV0sVD1fLlN1Yih5LG0pLnVuaSgpO3kuc2V0dihUKX10aGlzLnRtcFBvaW50cy5wdXNoKHkpfWNvbnN0IGw9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCExKSxjPSh4PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6eC50b1N0cmluZygpLG89e25hbWU6Y307bGV0IGY7aWYoYyYmbC5sZW5ndGgpe2NvbnN0IGc9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7Zj10aGlzLmRyYXcoe2F0dHJzOm8sdGFza3M6bCxyZXBsYWNlSWQ6bixsYXllcjpnLGlzQ2xlYXJBbGw6c30pLHRoaXMudk5vZGVzLnNldEluZm8oYyx7cmVjdDpmLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmYmJmd0LmdldENlbnRlclBvcyhmLGcpfSl9cmV0dXJuIGZ9dHJhbnNmb3JtRGF0YUFsbChlPSEwKXtyZXR1cm4gdGhpcy5nZXRUYXNrUG9pbnRzKHRoaXMudG1wUG9pbnRzLGUmJnRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzfHx2b2lkIDApfWRyYXcoZSl7dmFyIGE7Y29uc3R7YXR0cnM6dCx0YXNrczpyLHJlcGxhY2VJZDpuLGVmZmVjdHM6cyxsYXllcjpsLGlzQ2xlYXJBbGw6Y309ZSx7c3Ryb2tlQ29sb3I6byxzdHJva2VUeXBlOmYsdGhpY2tuZXNzOngsekluZGV4Omcsc2NhbGU6eSxyb3RhdGU6bSx0cmFuc2xhdGU6VH09dGhpcy53b3JrT3B0aW9ucztjJiZsLnJlbW92ZUFsbENoaWxkcmVuKCksbiYmKHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKG4rIiIpLm1hcChoPT5oLnJlbW92ZSgpKSwoYT10aGlzLmRyYXdMYXllcik9PW51bGx8fGEuZ2V0RWxlbWVudHNCeU5hbWUobisiIikubWFwKGg9PmgucmVtb3ZlKCkpKSxzIT1udWxsJiZzLnNpemUmJihzLmZvckVhY2goaD0+e3ZhciBiOyhiPWwuZ2V0RWxlbWVudEJ5SWQoaCsiIikpPT1udWxsfHxiLnJlbW92ZSgpfSkscy5jbGVhcigpKTtsZXQgTztjb25zdCB2PVtdLFA9bC53b3JsZFBvc2l0aW9uLGk9bC53b3JsZFNjYWxpbmc7Zm9yKGxldCBoPTA7aDxyLmxlbmd0aDtoKyspe2NvbnN0e3BvczpiLHBvaW50czpFLHRhc2tJZDpBfT1yW2hdO3QuaWQ9QS50b1N0cmluZygpO2NvbnN0e3BzOkwscmVjdDpTfT10aGlzLmNvbXB1dERyYXdQb2ludHMoRSk7bGV0IEk7Y29uc3QgRD1FLmxlbmd0aD09PTE7Zj09PXp0LlN0cm9rZXx8RD9JPWdlKEwsITApOkk9Z2UoTCwhMSk7Y29uc3QgUj17cG9zOmIsZDpJLGZpbGxDb2xvcjpmPT09enQuU3Ryb2tlfHxEP286dm9pZCAwLGxpbmVEYXNoOmY9PT16dC5Eb3R0ZWQmJiFEP1sxLHgqMl06Zj09PXp0LkxvbmdEb3R0ZWQmJiFEP1t4LHgqMl06dm9pZCAwLHN0cm9rZUNvbG9yOm8sbGluZUNhcDpmPT09enQuU3Ryb2tlfHxEP3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDpmPT09enQuU3Ryb2tlfHxEPzA6eH07Tz1idChPLHt4Ok1hdGguZmxvb3IoKFMueCtiWzBdKSppWzBdK1BbMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcigoUy55K2JbMV0pKmlbMV0rUFsxXS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKFMudyppWzBdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihTLmgqaVsxXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKX0pLHYucHVzaChSKX15JiYodC5zY2FsZT15KSxtJiYodC5yb3RhdGU9bSksVCYmKHQudHJhbnNsYXRlPVQpO2NvbnN0IHU9bmV3IGVlO2lmKE8pe3RoaXMuY2VudGVyUG9zPWd0LmdldENlbnRlclBvcyhPLGwpLHUuYXR0cih7Li4udCxub3JtYWxpemU6ITAsaWQ6dC5uYW1lLGFuY2hvcjpbLjUsLjVdLGJnY29sb3I6Zj09PXp0LlN0cm9rZT9vOnZvaWQgMCxwb3M6dGhpcy5jZW50ZXJQb3Msc2l6ZTpbKE8udy0yKmd0LlNhZmVCb3JkZXJQYWRkaW5nKS9pWzBdLChPLmgtMipndC5TYWZlQm9yZGVyUGFkZGluZykvaVsxXV0sekluZGV4Omd9KTtjb25zdCBoPXYubWFwKGI9PihiLnBvcz1bYi5wb3NbMF0tdGhpcy5jZW50ZXJQb3NbMF0sYi5wb3NbMV0tdGhpcy5jZW50ZXJQb3NbMV1dLG5ldyBzZShiKSkpO3UuYXBwZW5kKC4uLmgpLGY9PT16dC5TdHJva2UmJnUuc2VhbCgpLGwuYXBwZW5kKHUpfWlmKHl8fG18fFQpe2NvbnN0IGg9dT09bnVsbD92b2lkIDA6dS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihoKXJldHVybnt4Ok1hdGguZmxvb3IoaC54LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaC55LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaC53aWR0aCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaC5oZWlnaHQrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybiBPfWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PXp0LlN0cm9rZXx8ZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0U3Ryb2tlKGUpOnRoaXMuY29tcHV0Tm9tYWwoZSl9Y29tcHV0Tm9tYWwoZSl7bGV0IHQ9dGhpcy53b3JrT3B0aW9ucy50aGlja25lc3M7Y29uc3Qgcj1lLm1hcChuPT4odD1NYXRoLm1heCh0LG4ucmFkaXVzKSxuLnBvaW50KSk7cmV0dXJue3BzOnIscmVjdDpOdChyLHQpfX1jb21wdXRTdHJva2UoZSl7cmV0dXJuIGUubGVuZ3RoPT09MT90aGlzLmNvbXB1dERvdFN0cm9rZShlWzBdKTp0aGlzLmNvbXB1dExpbmVTdHJva2UoZSl9Y29tcHV0TGluZVN0cm9rZShlKXtjb25zdCB0PVtdLHI9W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDtvKyspe2NvbnN0e3BvaW50OmYscmFkaXVzOnh9PWVbb107bGV0IGc9Zi52O289PT0wJiZlLmxlbmd0aD4xJiYoZz1lW28rMV0ucG9pbnQudik7Y29uc3QgeT1fLlBlcihnKS5tdWwoeCk7dC5wdXNoKE90LlN1YihmLHkpKSxyLnB1c2goT3QuQWRkKGYseSkpfWNvbnN0IG49ZVtlLmxlbmd0aC0xXSxzPU90LkdldFNlbWljaXJjbGVTdHJva2Uobi5wb2ludCx0W3QubGVuZ3RoLTFdLC0xLDgpLGw9T3QuR2V0U2VtaWNpcmNsZVN0cm9rZShlWzBdLnBvaW50LHJbMF0sLTEsOCksYz10LmNvbmNhdChzLHIucmV2ZXJzZSgpLGwpO3JldHVybntwczpjLHJlY3Q6TnQoYyl9fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpyfT1lLG49e3g6dC54LXIseTp0Lnktcix3OnIqMixoOnIqMn07cmV0dXJue3BzOk90LkdldERvdFN0cm9rZSh0LHIsOCkscmVjdDpufX10cmFuc2Zvcm1EYXRhKGUsdCl7Y29uc3R7b3A6cix3b3JrU3RhdGU6bn09ZTtsZXQgcz10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSxsPVtdO2lmKHIhPW51bGwmJnIubGVuZ3RoJiZuKXtjb25zdHtzdHJva2VUeXBlOmMsdGhpY2tuZXNzOm99PXRoaXMud29ya09wdGlvbnMsZj1uZXcgU2V0O3M9Yz09PXp0LlN0cm9rZT90aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUocixvLGYpOnRoaXMudXBkYXRlVGVtcFBvaW50cyhyLG8sZik7Y29uc3QgeD10P3RoaXMudG1wUG9pbnRzOnRoaXMudG1wUG9pbnRzLnNsaWNlKHMpO3JldHVybiBsPXRoaXMuZ2V0VGFza1BvaW50cyh4LG8pLHt0YXNrczpsLGVmZmVjdHM6Zixjb25zdW1lSW5kZXg6c319cmV0dXJue3Rhc2tzOmwsY29uc3VtZUluZGV4OnN9fWNvbXB1dFJhZGl1cyhlLHQpe3JldHVybiBlKi4wMyp0K3QqLjV9Z2V0TWluWihlLHQpe3JldHVybigodHx8TWF0aC5tYXgoMSxNYXRoLmZsb29yKGUqLjMpKSktZSouNSkqMTAwL2UvM31nZXRUYXNrUG9pbnRzKGUsdCl7dmFyIHg7Y29uc3Qgcj1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IG49MCxzPWVbMF0ueCxsPWVbMF0ueSxjPVtzLGxdLG89W10sZj1lWzBdLnQ7Zm9yKDtuPGUubGVuZ3RoOyl7Y29uc3QgZz1lW25dLHk9Zy54LXMsbT1nLnktbCxUPWcueixPPXQ/dGhpcy5jb21wdXRSYWRpdXMoVCx0KTpUO2lmKG8ucHVzaCh7cG9pbnQ6bmV3IE90KHksbSxULGVbbl0udikscmFkaXVzOk99KSxuPjAmJm48ZS5sZW5ndGgtMSl7Y29uc3Qgdj1lW25dLmdldEFuZ2xlQnlQb2ludHMoZVtuLTFdLGVbbisxXSk7aWYodjw5MHx8dj4yNzApe2NvbnN0IFA9KHg9by5wb3AoKSk9PW51bGw/dm9pZCAwOngucG9pbnQuY2xvbmUoKTtQJiZyLnB1c2goe3Rhc2tJZDpmLHBvczpjLHBvaW50czpbLi4ubyx7cG9pbnQ6UCxyYWRpdXM6T31dfSkscz1lW25dLngsbD1lW25dLnksYz1bcyxsXTtjb25zdCBpPWcueC1zLHU9Zy55LWw7bz1be3BvaW50Om5ldyBPdChpLHUsVCkscmFkaXVzOk99XSxmPURhdGUubm93KCl9fW4rK31yZXR1cm4gci5wdXNoKHt0YXNrSWQ6Zixwb3M6Yyxwb2ludHM6b30pLHJ9dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShlLHQscil7Y29uc3Qgbj1EYXRlLm5vdygpLHM9dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBsPXM7Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDtvKz0yKXtsPU1hdGgubWluKGwscyk7Y29uc3QgZj10aGlzLnRtcFBvaW50cy5sZW5ndGgseD1uZXcgT3QoZVtvXSxlW28rMV0pO2lmKGY9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKHgpO2NvbnRpbnVlfWNvbnN0IGc9Zi0xLHk9dGhpcy50bXBQb2ludHNbZ10sbT1fLlN1Yih4LHkpLnVuaSgpO2lmKHguaXNOZWFyKHksdCkpe2lmKHkuejx0aGlzLk1BWF9SRVBFQVIpe2lmKHkuc2V0eihNYXRoLm1pbih5LnorMSx0aGlzLk1BWF9SRVBFQVIpKSxsPU1hdGgubWluKGwsZyksZj4xKXtsZXQgdj1mLTE7Zm9yKDt2PjA7KXtjb25zdCBQPXRoaXMudG1wUG9pbnRzW3ZdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzW3YtMV0pLGk9TWF0aC5tYXgodGhpcy50bXBQb2ludHNbdl0uei10aGlzLnVuaVRoaWNrbmVzcypQLDApO2lmKHRoaXMudG1wUG9pbnRzW3YtMV0uej49aSlicmVhazt0aGlzLnRtcFBvaW50c1t2LTFdLnNldHooaSksbD1NYXRoLm1pbihsLHYtMSksdi0tfX19ZWxzZSBsPTEvMDtjb250aW51ZX14LnNldHYobSk7Y29uc3QgVD14LmRpc3RhbmNlKHkpLE89TWF0aC5tYXgoeS56LXRoaXMudW5pVGhpY2tuZXNzKlQsMCk7Zj4xJiZfLkVxdWFscyhtLHkudiwuMDIpJiYoTz4wfHx5Lno8PTApJiYociYmeS50JiZyLmFkZCh5LnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGw9TWF0aC5taW4oZyxsKSkseC5zZXR6KE8pLHRoaXMudG1wUG9pbnRzLnB1c2goeCl9aWYobD09PTEvMClyZXR1cm4gdGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBjPXM7aWYobD09PXMpe2M9TWF0aC5tYXgoYy0xLDApO2NvbnN0IG89dGhpcy50bXBQb2ludHNbY10udDtvJiYocj09bnVsbHx8ci5hZGQobykpfWVsc2V7bGV0IG89cy0xO2ZvcihjPWw7bz49MDspe2NvbnN0IGY9dGhpcy50bXBQb2ludHNbb10udDtpZihmJiYocj09bnVsbHx8ci5hZGQoZiksbzw9bCkpe2M9byxvPS0xO2JyZWFrfW8tLX19cmV0dXJuIHRoaXMudG1wUG9pbnRzW2NdLnNldFQobiksY311cGRhdGVUZW1wUG9pbnRzKGUsdCxyKXt2YXIgbztjb25zdCBuPURhdGUubm93KCkscz10aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGw9cztmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrPTIpe2NvbnN0IHg9dGhpcy50bXBQb2ludHMubGVuZ3RoLGc9bmV3IE90KGVbZl0sZVtmKzFdKTtpZih4PT09MCl7dGhpcy50bXBQb2ludHMucHVzaChnKTtjb250aW51ZX1jb25zdCB5PXgtMSxtPXRoaXMudG1wUG9pbnRzW3ldLFQ9Xy5TdWIoZyxtKS51bmkoKTtpZihnLmlzTmVhcihtLHQvMikpe2w9TWF0aC5taW4oeSxsKTtjb250aW51ZX1fLkVxdWFscyhULG0udiwuMDIpJiYociYmbS50JiZyLmFkZChtLnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGw9TWF0aC5taW4oeSxsKSksZy5zZXR2KFQpLHRoaXMudG1wUG9pbnRzLnB1c2goZyl9bGV0IGM9cztpZihsPT09cyl7Yz1NYXRoLm1heChjLTEsMCk7Y29uc3QgZj10aGlzLnRtcFBvaW50c1tjXS50O2YmJihyPT1udWxsfHxyLmFkZChmKSl9ZWxzZXtsZXQgZj1NYXRoLm1pbihzLTEsbCk7Zm9yKGM9bDtmPj0wOyl7Y29uc3QgeD0obz10aGlzLnRtcFBvaW50c1tmXSk9PW51bGw/dm9pZCAwOm8udDtpZih4JiYocj09bnVsbHx8ci5hZGQoeCksZjw9bCkpe2M9ZixmPS0xO2JyZWFrfWYtLX19cmV0dXJuIHRoaXMudG1wUG9pbnRzW2NdLnNldFQobiksY311cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlV2hlbkRvbmUoZSl7Y29uc3R7dGhpY2tuZXNzOnR9PXRoaXMud29ya09wdGlvbnMscj1lLmxlbmd0aCxuPXRoaXMuZ2V0TWluWih0KTtmb3IobGV0IHM9MDtzPHI7cys9Mil7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5sZW5ndGgsYz1uZXcgT3QoZVtzXSxlW3MrMV0pO2lmKGw9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKGMpO2NvbnRpbnVlfWNvbnN0IG89bC0xLGY9dGhpcy50bXBQb2ludHNbb10seD1fLlN1YihjLGYpLnVuaSgpLGc9Yy5kaXN0YW5jZShmKTtpZihsPjEmJmYuej09PW4pYnJlYWs7aWYoYy5pc05lYXIoZix0LzIpKXtpZihyPDMmJmYuejx0aGlzLk1BWF9SRVBFQVImJihmLnNldHooTWF0aC5taW4oZi56KzEsdGhpcy5NQVhfUkVQRUFSKSksbD4xKSl7bGV0IG09bC0xO2Zvcig7bT4wOyl7Y29uc3QgVD10aGlzLnRtcFBvaW50c1ttXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1ttLTFdKSxPPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW21dLnotdGhpcy51bmlUaGlja25lc3MqVCwtdC80KTtpZih0aGlzLnRtcFBvaW50c1ttLTFdLno+PU8pYnJlYWs7dGhpcy50bXBQb2ludHNbbS0xXS5zZXR6KE8pLG0tLX19Y29udGludWV9Yy5zZXR2KHgpO2NvbnN0IHk9TWF0aC5tYXgoZi56LXRoaXMudW5pVGhpY2tuZXNzKmcsbik7bD4xJiZfLkVxdWFscyh4LGYudiwuMDIpJiZmLno8PTAmJnRoaXMudG1wUG9pbnRzLnBvcCgpLGMuc2V0eih5KSx0aGlzLnRtcFBvaW50cy5wdXNoKGMpfX1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgYztjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOnN9PXIsbD1uLmdldCh0Lm5hbWUpO3JldHVybiBzJiYodC50YWdOYW1lPT09IkdST1VQIj9OZSh0KT90LnNldEF0dHJpYnV0ZSgiYmdjb2xvciIscyk6dC5jaGlsZHJlbi5mb3JFYWNoKG89PntvLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHMpLG8uZ2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiKSYmby5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIscyl9KToodC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixzKSx0LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixzKSksKGM9bD09bnVsbD92b2lkIDA6bC5vcHQpIT1udWxsJiZjLnN0cm9rZUNvbG9yJiYobC5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJm4uc2V0SW5mbyh0Lm5hbWUsbCksZ3QudXBkYXRlTm9kZU9wdChlKX1zdGF0aWMgZ2V0UmVjdEZyb21MYXllcihlLHQpe2NvbnN0IHI9ZS5nZXRFbGVtZW50c0J5TmFtZSh0KVswXTtpZihyKXtjb25zdCBuPXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihuLngtZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihuLnktZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihuLndpZHRoK2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihuLmhlaWdodCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKX19fX1jbGFzcyBkbiBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5MYXNlclBlbn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5ub25lfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY0luZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb25zdW1lSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7fXNldFdvcmtPcHRpb25zKGUpe3N1cGVyLnNldFdvcmtPcHRpb25zKGUpLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbnN1bWUoZSl7Y29uc3R7ZGF0YTp0LGlzU3ViV29ya2VyOnJ9PWUse3dvcmtJZDpuLG9wOnN9PXQ7aWYoKHM9PW51bGw/dm9pZCAwOnMubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy51cGRhdGVUZW1wUG9pbnRzKHN8fFtdKSx0aGlzLmNvbnN1bWVJbmRleD50aGlzLnRtcFBvaW50cy5sZW5ndGgtNClyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHtzdHJva2VDb2xvcjpsLHRoaWNrbmVzczpjLHN0cm9rZVR5cGU6b309dGhpcy53b3JrT3B0aW9ucyxmPU50KHRoaXMudG1wUG9pbnRzLGMpO2xldCB4PSExO2NvbnN0IGc9dGhpcy5zeW5jSW5kZXgseT10aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLmNvbnN1bWVJbmRleCk7dGhpcy5jb25zdW1lSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoLTEsdGhpcy5zeW5jVGltZXN0YW1wPT09MCYmKHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpKTtjb25zdCBtPXtuYW1lOm49PW51bGw/dm9pZCAwOm4udG9TdHJpbmcoKSxvcGFjaXR5OjEsbGluZURhc2g6bz09PXp0LkRvdHRlZD9bMSxjKjJdOm89PT16dC5Mb25nRG90dGVkP1tjLGMqMl06dm9pZCAwLHN0cm9rZUNvbG9yOmwsbGluZUNhcDoicm91bmQiLGxpbmVXaWR0aDpjLGFuY2hvcjpbLjUsLjVdfSxUPXRoaXMuZ2V0VGFza1BvaW50cyh5KTtpZihULmxlbmd0aCl7Y29uc3Qgdj1EYXRlLm5vdygpO3YtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYoeD0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9dix0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLHImJnRoaXMuZHJhdyh7YXR0cnM6bSx0YXNrczpULGlzRG90OiExLGxheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcn0pfWNvbnN0IE89W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKGcpLmZvckVhY2godj0+e08ucHVzaCh2Lngsdi55KX0pLHtyZWN0Ont4OmYueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OmYueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OmYudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpmLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfSx0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDp4P246dm9pZCAwLG9wOng/Tzp2b2lkIDAsaW5kZXg6eD9nKjI6dm9pZCAwfX1jb25zdW1lQWxsKCl7dmFyIG47Y29uc3QgZT0obj10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOm4udG9TdHJpbmcoKTtsZXQgdDtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGgtMT50aGlzLmNvbnN1bWVJbmRleCl7bGV0IHM9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO2NvbnN0IGw9cy5sZW5ndGg9PT0xLHtzdHJva2VDb2xvcjpjLHRoaWNrbmVzczpvLHN0cm9rZVR5cGU6Zn09dGhpcy53b3JrT3B0aW9ucztpZihsKXtjb25zdCB5PXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDpzWzBdLHJhZGl1czpvLzJ9KTtzPXkucHMsdD15LnJlY3R9ZWxzZSB0PU50KHRoaXMudG1wUG9pbnRzLG8pO2NvbnN0IHg9e25hbWU6ZT09bnVsbD92b2lkIDA6ZS50b1N0cmluZygpLGZpbGxDb2xvcjpsP2M6dm9pZCAwLG9wYWNpdHk6MSxsaW5lRGFzaDpmPT09enQuRG90dGVkJiYhbD9bMSxvKjJdOmY9PT16dC5Mb25nRG90dGVkJiYhbD9bbyxvKjJdOnZvaWQgMCxzdHJva2VDb2xvcjpjLGxpbmVDYXA6bD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6bD8wOm8sYW5jaG9yOlsuNSwuNV19LGc9dGhpcy5nZXRUYXNrUG9pbnRzKHMpO2cubGVuZ3RoJiZ0aGlzLmRyYXcoe2F0dHJzOngsdGFza3M6Zyxpc0RvdDpsLGxheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcn0pfWNvbnN0IHI9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuc3luY0luZGV4KS5mb3JFYWNoKHM9PntyLnB1c2gocy54LHMueSl9KSx7cmVjdDp0JiZ7eDp0LngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTp0LnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzp0LncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6dC5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX0sdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6ZSxvcDpyLGluZGV4OnRoaXMuc3luY0luZGV4KjJ9fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jSW5kZXg9MH1jb25zdW1lU2VydmljZShlKXt2YXIgVDtjb25zdHtvcDp0LHJlcGxhY2VJZDpyLGlzRnVsbFdvcms6bn09ZSx7c3Ryb2tlQ29sb3I6cyx0aGlja25lc3M6bCxzdHJva2VUeXBlOmN9PXRoaXMud29ya09wdGlvbnM7aWYoIXQubGVuZ3RoKXtjb25zdCBPPU50KHRoaXMudG1wUG9pbnRzLGwpO3JldHVybnt4Ok8ueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5Ok8ueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3Ok8udyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpPLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb25zdCBvPU1hdGgubWF4KDAsdGhpcy50bXBQb2ludHMubGVuZ3RoLTEpO3RoaXMudXBkYXRlVGVtcFBvaW50cyh0fHxbXSk7bGV0IGYseD10aGlzLnRtcFBvaW50cy5zbGljZShvKTtjb25zdCBnPXgubGVuZ3RoPT09MTtpZihnKXtjb25zdCBPPXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDp4WzBdLHJhZGl1czpsLzJ9KTt4PU8ucHMsZj1PLnJlY3R9ZWxzZSBmPU50KHRoaXMudG1wUG9pbnRzLGwpO2NvbnN0IHk9e25hbWU6KFQ9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpULnRvU3RyaW5nKCksZmlsbENvbG9yOmc/czp2b2lkIDAsb3BhY2l0eToxLGxpbmVEYXNoOmM9PT16dC5Eb3R0ZWQmJiFnP1sxLGwqMl06Yz09PXp0LkxvbmdEb3R0ZWQmJiFnP1tsLGwqMl06dm9pZCAwLHN0cm9rZUNvbG9yOnMsbGluZUNhcDpnP3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDpnPzA6bCxhbmNob3I6Wy41LC41XX0sbT10aGlzLmdldFRhc2tQb2ludHMoeCk7aWYobS5sZW5ndGgpe2NvbnN0IE89bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7dGhpcy5kcmF3KHthdHRyczp5LHRhc2tzOm0saXNEb3Q6ZyxyZXBsYWNlSWQ6cixsYXllcjpPfSl9cmV0dXJue3g6Zi54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6Zi55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6Zi53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOmYuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpyfT1lLG49e3g6dC54LXIseTp0Lnktcix3OnIqMixoOnIqMn07cmV0dXJue3BzOk90LkdldERvdFN0cm9rZSh0LHIsOCkscmVjdDpufX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9dGhpcy50bXBQb2ludHMubGVuZ3RoO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cis9Mil7aWYodCl7Y29uc3Qgbj10aGlzLnRtcFBvaW50cy5zbGljZSgtMSlbMF07biYmbi54PT09ZVtyXSYmbi55PT09ZVtyKzFdJiZ0aGlzLnRtcFBvaW50cy5wb3AoKX10aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdChlW3JdLGVbcisxXSkpfX1hc3luYyBkcmF3KGUpe2NvbnN0e2F0dHJzOnQsdGFza3M6cixpc0RvdDpuLGxheWVyOnN9PWUse2R1cmF0aW9uOmx9PXRoaXMud29ya09wdGlvbnM7Zm9yKGNvbnN0IGMgb2Ygcil7Y29uc3Qgbz1uZXcgc2Use3BvczpmLHBvaW50czp4fT1jO2xldCBnO24/Zz1nZSh4LCEwKTpnPWdlKHgsITEpLG8uYXR0cih7Li4udCxwb3M6ZixkOmd9KTtjb25zdHt2ZXJ0ZXg6eSxmcmFnbWVudDptfT10aGlzLndvcmtPcHRpb25zO2lmKHkmJm0pe2NvbnN0IFQ9cy5yZW5kZXJlci5jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6eSxmcmFnbWVudDptfSkse3dpZHRoOk8saGVpZ2h0OnZ9PXMuZ2V0UmVzb2x1dGlvbigpO28uc2V0VW5pZm9ybXMoe3VfdGltZTowLHVfcmVzb2x1dGlvbjpbTyx2XX0pLG8uc2V0UHJvZ3JhbShUKX1zLmFwcGVuZENoaWxkKG8pLG8udHJhbnNpdGlvbihsKS5hdHRyKHtzY2FsZTpuP1suMSwuMV06WzEsMV0sbGluZVdpZHRoOm4/MDoxfSkudGhlbigoKT0+e28ucmVtb3ZlKCl9KX19Z2V0VGFza1BvaW50cyhlKXt2YXIgbztjb25zdCB0PVtdO2lmKGUubGVuZ3RoPT09MClyZXR1cm5bXTtsZXQgcj0wLG49ZVswXS54LHM9ZVswXS55LGw9W24sc10sYz1bXTtmb3IoO3I8ZS5sZW5ndGg7KXtjb25zdCBmPWVbcl0seD1mLngtbixnPWYueS1zO2lmKGMucHVzaChuZXcgT3QoeCxnKSkscj4wJiZyPGUubGVuZ3RoLTEpe2NvbnN0IHk9ZVtyXS5nZXRBbmdsZUJ5UG9pbnRzKGVbci0xXSxlW3IrMV0pO2lmKHk8OTB8fHk+MjcwKXtjb25zdCBtPShvPWMucG9wKCkpPT1udWxsP3ZvaWQgMDpvLmNsb25lKCk7bSYmdC5wdXNoKHtwb3M6bCxwb2ludHM6Wy4uLmMsbV19KSxuPWVbcl0ueCxzPWVbcl0ueSxsPVtuLHNdO2NvbnN0IFQ9Zi54LW4sTz1mLnktcztjPVtuZXcgT3QoVCxPKV19fXIrK31yZXR1cm4gdC5wdXNoKHtwb3M6bCxwb2ludHM6Y30pLHR9cmVtb3ZlTG9jYWwoKXt9cmVtb3ZlU2VydmljZShlKXtsZXQgdDtjb25zdCByPVtdO3JldHVybiB0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5mb3JFYWNoKG49PntpZihuLm5hbWU9PT1lKXtjb25zdCBzPW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dD1idCh0LHt4OnMueCx5OnMueSx3OnMud2lkdGgsaDpzLmhlaWdodH0pLHIucHVzaChuKX19KSxyLmxlbmd0aCYmci5mb3JFYWNoKG49Pm4ucmVtb3ZlKCkpLHR9fXZhciBUaD1XZTtXZS5wb2x5bGluZT1XZSxXZS5wb2x5Z29uPUVoO2Z1bmN0aW9uIFdlKGQsZSx0KXt2YXIgcj1kLmxlbmd0aCxuPW1lKGRbMF0sZSkscz1bXSxsLGMsbyxmLHg7Zm9yKHR8fCh0PVtdKSxsPTE7bDxyO2wrKyl7Zm9yKGM9ZFtsLTFdLG89ZFtsXSxmPXg9bWUobyxlKTs7KWlmKG58Zil7aWYobiZmKWJyZWFrO24/KGM9aXIoYyxvLG4sZSksbj1tZShjLGUpKToobz1pcihjLG8sZixlKSxmPW1lKG8sZSkpfWVsc2V7cy5wdXNoKGMpLGYhPT14PyhzLnB1c2gobyksbDxyLTEmJih0LnB1c2gocykscz1bXSkpOmw9PT1yLTEmJnMucHVzaChvKTticmVha31uPXh9cmV0dXJuIHMubGVuZ3RoJiZ0LnB1c2gocyksdH1mdW5jdGlvbiBFaChkLGUpe3ZhciB0LHIsbixzLGwsYyxvO2ZvcihyPTE7cjw9ODtyKj0yKXtmb3IodD1bXSxuPWRbZC5sZW5ndGgtMV0scz0hKG1lKG4sZSkmciksbD0wO2w8ZC5sZW5ndGg7bCsrKWM9ZFtsXSxvPSEobWUoYyxlKSZyKSxvIT09cyYmdC5wdXNoKGlyKG4sYyxyLGUpKSxvJiZ0LnB1c2goYyksbj1jLHM9bztpZihkPXQsIWQubGVuZ3RoKWJyZWFrfXJldHVybiB0fWZ1bmN0aW9uIGlyKGQsZSx0LHIpe3JldHVybiB0Jjg/W2RbMF0rKGVbMF0tZFswXSkqKHJbM10tZFsxXSkvKGVbMV0tZFsxXSksclszXV06dCY0P1tkWzBdKyhlWzBdLWRbMF0pKihyWzFdLWRbMV0pLyhlWzFdLWRbMV0pLHJbMV1dOnQmMj9bclsyXSxkWzFdKyhlWzFdLWRbMV0pKihyWzJdLWRbMF0pLyhlWzBdLWRbMF0pXTp0JjE/W3JbMF0sZFsxXSsoZVsxXS1kWzFdKSooclswXS1kWzBdKS8oZVswXS1kWzBdKV06bnVsbH1mdW5jdGlvbiBtZShkLGUpe3ZhciB0PTA7cmV0dXJuIGRbMF08ZVswXT90fD0xOmRbMF0+ZVsyXSYmKHR8PTIpLGRbMV08ZVsxXT90fD00OmRbMV0+ZVszXSYmKHR8PTgpLHR9dmFyIEFoPXBlKFRoKTtjbGFzcyBYdCBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5ub25lfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZ0LkVyYXNlcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFBvc2l0aW9uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmxkU2NhbGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVyYXNlclBvbHlsaW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMud29ybGRQb3NpdGlvbj10aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uLHRoaXMud29ybGRTY2FsaW5nPXRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ31jb21iaW5lQ29uc3VtZSgpe31jb25zdW1lU2VydmljZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKX1jcmVhdGVFcmFzZXJSZWN0KGUpe2NvbnN0IHQ9ZVswXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0scj1lWzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSx7d2lkdGg6bixoZWlnaHQ6c309WHQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdO3RoaXMuZXJhc2VyUmVjdD17eDp0LW4qLjUseTpyLXMqLjUsdzpuLGg6c30sdGhpcy5lcmFzZXJQb2x5bGluZT1bdGhpcy5lcmFzZXJSZWN0LngsdGhpcy5lcmFzZXJSZWN0LnksdGhpcy5lcmFzZXJSZWN0LngrdGhpcy5lcmFzZXJSZWN0LncsdGhpcy5lcmFzZXJSZWN0LnkrdGhpcy5lcmFzZXJSZWN0LmhdfWNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKXtjb25zdCBlPXRoaXMudG1wUG9pbnRzLnNsaWNlKC0yKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT00KXtjb25zdCB0PW5ldyBfKHRoaXMudG1wUG9pbnRzWzBdLHRoaXMudG1wUG9pbnRzWzFdKSxyPW5ldyBfKHRoaXMudG1wUG9pbnRzWzJdLHRoaXMudG1wUG9pbnRzWzNdKSxuPV8uU3ViKHIsdCkudW5pKCkscz1fLkRpc3QodCxyKSx7d2lkdGg6bCxoZWlnaHQ6Y309WHQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdLG89TWF0aC5taW4obCxjKSxmPU1hdGgucm91bmQocy9vKTtpZihmPjEpe2NvbnN0IHg9W107Zm9yKGxldCBnPTA7ZzxmO2crKyl7Y29uc3QgeT1fLk11bChuLGcqbyk7eC5wdXNoKHRoaXMudG1wUG9pbnRzWzBdK3kueCx0aGlzLnRtcFBvaW50c1sxXSt5LnkpfXJldHVybiB4LmNvbmNhdChlKX19cmV0dXJuIGV9aXNOZWFyKGUsdCl7Y29uc3Qgcj1uZXcgXyhlWzBdLGVbMV0pLG49bmV3IF8odFswXSx0WzFdKSx7d2lkdGg6cyxoZWlnaHQ6bH09WHQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdO3JldHVybiBfLkRpc3QocixuKTxNYXRoLmh5cG90KHMsbCkqLjV9Y3V0UG9seWxpbmUoZSx0KXtsZXQgcj1bdF0sbj0wO2Zvcig7bjxlLmxlbmd0aDspe2NvbnN0IGM9ZVtuXTtpZihjLmxlbmd0aDwyKWJyZWFrO3I9cyhyLGMpLG4rK31yZXR1cm4gcjtmdW5jdGlvbiBzKGMsbyl7Y29uc3QgZj1jO2ZvcihsZXQgeD0wO3g8Yy5sZW5ndGg7eCsrKXtjb25zdCBnPWNbeF0seT1nLmZpbmRJbmRleCgobSxUKT0+VDxnLmxlbmd0aC0xP2woW20sZ1tUKzFdXSxbb1swXSxvWzFdXSk6ITEpO2lmKHkhPT0tMSYmeT4tMSl7Y29uc3QgbT1bXSxUPWcuc2xpY2UoMCx5KzEpO2lmKF8uRXF1YWxzKGdbeV0sb1swXSl8fFQucHVzaChvWzBdLmNsb25lKCkuc2V0eihnW3ldLnopKSxULmxlbmd0aD4xJiZtLnB1c2goVCkseStvLmxlbmd0aC0xPGcubGVuZ3RoLTEpe2NvbnN0IE89eStvLmxlbmd0aC0xLHY9Zy5zbGljZShPKSxQPW9bby5sZW5ndGgtMV07Xy5FcXVhbHMoZ1tPXSxQKXx8di51bnNoaWZ0KFAuY2xvbmUoKS5zZXR6KGdbT10ueikpLHYubGVuZ3RoPjEmJm0ucHVzaCh2KX1yZXR1cm4gZi5zcGxpY2UoeCwxLC4uLm0pLGZ9fXJldHVybiBmfWZ1bmN0aW9uIGwoYyxvKXtjb25zdCBmPV8uU3ViKGNbMV0sY1swXSkseD1fLlN1YihvWzFdLG9bMF0pLGc9Xy5TdWIob1swXSxjWzBdKTtyZXR1cm4gTWF0aC5hYnMoXy5DcHIoZix4KSk8LjEmJk1hdGguYWJzKF8uQ3ByKGYsZykpPC4xfX1pc1NhbWVQb2ludChlLHQpe3JldHVybiBlWzBdPT09dFswXSYmZVsxXT09PXRbMV19dHJhbnNsYXRlSW50ZXJzZWN0KGUpe2NvbnN0IHQ9W107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IG49ZVtyXS5maWx0ZXIoKGMsbyxmKT0+IShvPjAmJnRoaXMuaXNTYW1lUG9pbnQoYyxmW28tMV0pKSkscz1bXTtsZXQgbD0wO2Zvcig7bDxuLmxlbmd0aDspe2NvbnN0IGM9bltsXSxvPW5ldyBfKGNbMF0sY1sxXSk7cy5wdXNoKG8pLGwrK310LnB1c2gocyl9cmV0dXJuIHR9aXNMaW5lRXJhc2VyKGUsdCl7cmV0dXJuIShlPT09dnQuUGVuY2lsJiYhdCl9cmVtb3ZlKGUpe2NvbnN0e2N1ck5vZGVNYXA6dCxyZW1vdmVJZHM6cixuZXdXb3JrRGF0YXM6bn09ZSx7aXNMaW5lOnN9PXRoaXMud29ya09wdGlvbnM7bGV0IGw7Zm9yKGNvbnN0W2Msb11vZiB0LmVudHJpZXMoKSlpZihvLnJlY3QmJnRoaXMuZXJhc2VyUmVjdCYmdGhpcy5lcmFzZXJQb2x5bGluZSYmeGUodGhpcy5lcmFzZXJSZWN0LG8ucmVjdCkpe2NvbnN0e29wOmYsdG9vbHNUeXBlOnh9PW8sZz10aGlzLmlzTGluZUVyYXNlcih4LHMpLHk9W10sbT1bXTtmb3IobGV0IE89MDtPPGYubGVuZ3RoO08rPTMpe2NvbnN0IHY9bmV3IF8oZltPXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0sZltPKzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSxmW08rMl0pO20ucHVzaCh2KSx5LnB1c2gobmV3IE90KHYueCx2LnkpKX1jb25zdCBUPXkubGVuZ3RoJiZOdCh5KXx8by5yZWN0O2lmKHhlKFQsdGhpcy5lcmFzZXJSZWN0KSl7aWYobS5sZW5ndGg+MSl7Y29uc3QgTz1BaC5wb2x5bGluZShtLm1hcCh2PT52LlhZKSx0aGlzLmVyYXNlclBvbHlsaW5lKTtpZihPLmxlbmd0aCYmKHIuYWRkKG8ubmFtZSksIWcpKXtjb25zdCB2PXRoaXMudHJhbnNsYXRlSW50ZXJzZWN0KE8pLFA9dGhpcy5jdXRQb2x5bGluZSh2LG0pO2ZvcihsZXQgaT0wO2k8UC5sZW5ndGg7aSsrKXtjb25zdCB1PWAke2N9X3NfJHtpfWAsYT1bXTtQW2ldLmZvckVhY2goaD0+e2EucHVzaCgoaC54LXRoaXMud29ybGRQb3NpdGlvblswXSkvdGhpcy53b3JsZFNjYWxpbmdbMF0sKGgueS10aGlzLndvcmxkUG9zaXRpb25bMV0pL3RoaXMud29ybGRTY2FsaW5nWzFdLGgueil9KSxvLm9wdCYmby50b29sc1R5cGUmJnRoaXMudk5vZGVzJiYodGhpcy52Tm9kZXMuc2V0SW5mbyh1LHtyZWN0OlQsb3A6YSxvcHQ6by5vcHQsY2FuUm90YXRlOm8uY2FuUm90YXRlLHNjYWxlVHlwZTpvLnNjYWxlVHlwZSx0b29sc1R5cGU6by50b29sc1R5cGV9KSxuLnNldCh1LHt3b3JrSWQ6dSxvcDphLG9wdDpvLm9wdCx0b29sc1R5cGU6by50b29sc1R5cGV9KSl9fX1lbHNlIHIuYWRkKG8ubmFtZSk7bD1idChsLFQpfX1yZXR1cm4gci5mb3JFYWNoKGM9Pnt2YXIgbztyZXR1cm4obz10aGlzLnZOb2Rlcyk9PW51bGw/dm9pZCAwOm8uZGVsZXRlKGMpfSksbCYmKGwueC09Z3QuU2FmZUJvcmRlclBhZGRpbmcsbC55LT1ndC5TYWZlQm9yZGVyUGFkZGluZyxsLncrPWd0LlNhZmVCb3JkZXJQYWRkaW5nKjIsbC5oKz1ndC5TYWZlQm9yZGVyUGFkZGluZyoyKSxsfWNvbnN1bWUoZSl7Y29uc3R7b3A6dH09ZS5kYXRhO2lmKCF0fHx0Lmxlbmd0aD09PTApcmV0dXJue3R5cGU6dXQuTm9uZX07Y29uc3Qgcj10aGlzLnRtcFBvaW50cy5sZW5ndGg7aWYocj4xJiZ0aGlzLmlzTmVhcihbdFswXSx0WzFdXSxbdGhpcy50bXBQb2ludHNbci0yXSx0aGlzLnRtcFBvaW50c1tyLTFdXSkpcmV0dXJue3R5cGU6dXQuTm9uZX07cj09PTQmJih0aGlzLnRtcFBvaW50cy5zaGlmdCgpLHRoaXMudG1wUG9pbnRzLnNoaWZ0KCkpLHRoaXMudG1wUG9pbnRzLnB1c2godFswXSx0WzFdKTtjb25zdCBuPXRoaXMuY29tcHV0UmVjdENlbnRlclBvaW50cygpO2xldCBzO2NvbnN0IGw9bmV3IFNldCxjPW5ldyBNYXA7dGhpcy52Tm9kZXMuc2V0VGFyZ2V0KCk7Zm9yKGxldCBvPTA7bzxuLmxlbmd0aC0xO28rPTIpe3RoaXMuY3JlYXRlRXJhc2VyUmVjdChuLnNsaWNlKG8sbysyKSk7Y29uc3QgZj10aGlzLnJlbW92ZSh7Y3VyTm9kZU1hcDp0aGlzLnZOb2Rlcy5nZXRMYXN0VGFyZ2V0KCkscmVtb3ZlSWRzOmwsbmV3V29ya0RhdGFzOmN9KTtzPWJ0KHMsZil9aWYodGhpcy52Tm9kZXMuZGVsZXRlTGFzdFRhcmdldCgpLHMmJmwuc2l6ZSl7Zm9yKGNvbnN0IG8gb2YgYy5rZXlzKCkpbC5oYXMobykmJmMuZGVsZXRlKG8pO3JldHVybnt0eXBlOnV0LlJlbW92ZU5vZGUsZGF0YVR5cGU6UHQuTG9jYWwscmVjdDpzLHJlbW92ZUlkczpbLi4ubF0sbmV3V29ya0RhdGFzOmN9fXJldHVybnt0eXBlOnV0Lk5vbmV9fWNvbnN1bWVBbGwoZSl7cmV0dXJuIHRoaXMuY29uc3VtZShlKX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoWHQsImVyYXNlclNpemVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6T2JqZWN0LmZyZWV6ZShbT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MTgsaGVpZ2h0OjI2fSksT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MjYsaGVpZ2h0OjM0fSksT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MzQsaGVpZ2h0OjUwfSldKX0pO2NvbnN0IENoPSIrKyIsUmg9InNlbGVjdG9yIixJaD0iYWxsIjtjbGFzcyBSdCBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5TZWxlY3Rvcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VsZWN0b3JDb2xvciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzdHJva2VDb2xvciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmaWxsQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkU2VsZWN0UmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5UZXh0RWRpdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkt0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0ZXh0T3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0fWNvbXB1dFNlbGVjdG9yKCl7Y29uc3QgZT1OdCh0aGlzLnRtcFBvaW50cykse3JlY3RSYW5nZTp0LG5vZGVSYW5nZTpyfT10aGlzLnZOb2Rlcy5nZXRSZWN0SW50ZXJzZWN0UmFuZ2UoZSk7cmV0dXJue3NlbGVjdElkczpbLi4uci5rZXlzKCldLGludGVyc2VjdFJlY3Q6dCxzdWJOb2RlTWFwOnJ9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGgscj1lLmxlbmd0aDtpZihyPjEpe2NvbnN0IG49bmV3IE90KGVbci0yXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSxlW3ItMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0pO3Q9PT0yP3RoaXMudG1wUG9pbnRzLnNwbGljZSgxLDEsbik6dGhpcy50bXBQb2ludHMucHVzaChuKX19ZHJhd1NlbGVjdG9yKGUpe2NvbnN0e2RyYXdSZWN0OnQsc3ViTm9kZU1hcDpyLHNlbGVjdG9ySWQ6bixsYXllcjpzLGlzU2VydmljZTpsfT1lLGM9bmV3IGVlKHtwb3M6W3QueCx0LnldLGFuY2hvcjpbMCwwXSxzaXplOlt0LncsdC5oXSxpZDpuLG5hbWU6UnQuc2VsZWN0b3JJZCx6SW5kZXg6MWUzfSksbz1bXTtpZihsKXtjb25zdCBmPW5ldyBycih7bm9ybWFsaXplOiEwLHBvczpbdC53LzIsdC5oLzJdLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOnRoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3Isd2lkdGg6dC53LGhlaWdodDp0LmgsbmFtZTpSdC5zZWxlY3RvckJvcmRlcklkfSk7by5wdXNoKGYpfXIuZm9yRWFjaCgoZix4KT0+e2NvbnN0IGc9W2YucmVjdC54K2YucmVjdC53LzItdC54LGYucmVjdC55K2YucmVjdC5oLzItdC55XSx5PW5ldyBycih7bm9ybWFsaXplOiEwLHBvczpnLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOnIuc2l6ZT4xP3RoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3I6dm9pZCAwLHdpZHRoOmYucmVjdC53LGhlaWdodDpmLnJlY3QuaCxpZDpgc2VsZWN0b3ItJHt4fWAsbmFtZTpgc2VsZWN0b3ItJHt4fWB9KTtvLnB1c2goeSl9KSxvJiZjLmFwcGVuZCguLi5vKSwocz09bnVsbD92b2lkIDA6cy5wYXJlbnQpLmFwcGVuZENoaWxkKGMpfWRyYXcoZSx0LHIsbj0hMSl7dmFyIGMsbztjb25zdHtpbnRlcnNlY3RSZWN0OnMsc3ViTm9kZU1hcDpsfT1yOyhvPShjPXQucGFyZW50KT09bnVsbD92b2lkIDA6Yy5nZXRFbGVtZW50QnlJZChlKSk9PW51bGx8fG8ucmVtb3ZlKCkscyYmdGhpcy5kcmF3U2VsZWN0b3Ioe2RyYXdSZWN0OnMsc3ViTm9kZU1hcDpsLHNlbGVjdG9ySWQ6ZSxsYXllcjp0LGlzU2VydmljZTpufSl9Z2V0U2VsZWN0ZW9ySW5mbyhlKXt0aGlzLnNjYWxlVHlwZT1LdC5hbGwsdGhpcy5jYW5Sb3RhdGU9ITE7Zm9yKGNvbnN0IHQgb2YgZS52YWx1ZXMoKSl7Y29uc3R7b3B0OnIsY2FuUm90YXRlOm4sc2NhbGVUeXBlOnMsdG9vbHNUeXBlOmx9PXQ7dGhpcy5zZWxlY3RvckNvbG9yPXRoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3IsdGhpcy5zdHJva2VDb2xvcj1yLnN0cm9rZUNvbG9yLHIuZmlsbENvbG9yJiYodGhpcy5maWxsQ29sb3I9ci5maWxsQ29sb3IpLHIudGV4dE9wdCYmKHRoaXMudGV4dE9wdD1yLnRleHRPcHQpLGw9PT12dC5UZXh0JiYodGhpcy50ZXh0T3B0PXIpLGUuc2l6ZT09PTE/KHRoaXMudGV4dE9wdCYmKHRoaXMuY2FuVGV4dEVkaXQ9ITApLHRoaXMuY2FuUm90YXRlPW4sdGhpcy5zY2FsZVR5cGU9cyk6cz09PUt0Lm5vbmUmJih0aGlzLnNjYWxlVHlwZT1zKX19Z2V0Q2hpbGRyZW5Qb2ludHMoKXt2YXIgZTtpZih0aGlzLnNjYWxlVHlwZT09PUt0LmJvdGgmJnRoaXMuc2VsZWN0SWRzKXtjb25zdCB0PXRoaXMuc2VsZWN0SWRzWzBdLHI9KGU9dGhpcy52Tm9kZXMuZ2V0KHQpKT09bnVsbD92b2lkIDA6ZS5vcDtpZihyKXtjb25zdCBuPVtdO2ZvcihsZXQgcz0wO3M8ci5sZW5ndGg7cys9MyluLnB1c2goW3Jbc10scltzKzFdXSk7cmV0dXJuIG59fX1jb25zdW1lKGUpe2NvbnN0e29wOnQsd29ya1N0YXRlOnJ9PWUuZGF0YTtsZXQgbj10aGlzLm9sZFNlbGVjdFJlY3Q7aWYocj09PUl0LlN0YXJ0JiYobj10aGlzLmJhY2tUb0Z1bGxMYXllcigpKSwhKHQhPW51bGwmJnQubGVuZ3RoKXx8IXRoaXMudk5vZGVzLmN1ck5vZGVNYXAuc2l6ZSlyZXR1cm57dHlwZTp1dC5Ob25lfTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModCk7Y29uc3Qgcz10aGlzLmNvbXB1dFNlbGVjdG9yKCk7aWYodGhpcy5zZWxlY3RJZHMmJmhoKHRoaXMuc2VsZWN0SWRzLHMuc2VsZWN0SWRzKSlyZXR1cm57dHlwZTp1dC5Ob25lfTt0aGlzLnNlbGVjdElkcz1zLnNlbGVjdElkcztjb25zdCBsPXMuaW50ZXJzZWN0UmVjdDt0aGlzLmRyYXcoUnQuc2VsZWN0b3JJZCx0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIscyksdGhpcy5nZXRTZWxlY3Rlb3JJbmZvKHMuc3ViTm9kZU1hcCksdGhpcy5vbGRTZWxlY3RSZWN0PWw7Y29uc3QgYz10aGlzLmdldENoaWxkcmVuUG9pbnRzKCk7cmV0dXJue3R5cGU6dXQuU2VsZWN0LGRhdGFUeXBlOlB0LkxvY2FsLHJlY3Q6YnQobCxuKSxzZWxlY3RJZHM6cy5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMsc2VsZWN0UmVjdDpsLHNlbGVjdG9yQ29sb3I6dGhpcy5zZWxlY3RvckNvbG9yLHN0cm9rZUNvbG9yOnRoaXMuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLHRleHRPcHQ6dGhpcy50ZXh0T3B0LGNhblRleHRFZGl0OnRoaXMuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSx3aWxsU3luY1NlcnZpY2U6ITAscG9pbnRzOmN9fWNvbnN1bWVBbGwoKXt2YXIgZTtpZigoZT10aGlzLnNlbGVjdElkcykhPW51bGwmJmUubGVuZ3RoJiZ0aGlzLnNlYWxUb0RyYXdMYXllcih0aGlzLnNlbGVjdElkcyksdGhpcy5vbGRTZWxlY3RSZWN0KXtjb25zdCB0PXRoaXMuZ2V0Q2hpbGRyZW5Qb2ludHMoKTtyZXR1cm57dHlwZTp1dC5TZWxlY3QsZGF0YVR5cGU6UHQuTG9jYWwscmVjdDp0aGlzLm9sZFNlbGVjdFJlY3Qsc2VsZWN0SWRzOnRoaXMuc2VsZWN0SWRzLG9wdDp0aGlzLndvcmtPcHRpb25zLHNlbGVjdFJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LHN0cm9rZUNvbG9yOnRoaXMuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLHRleHRPcHQ6dGhpcy50ZXh0T3B0LGNhblRleHRFZGl0OnRoaXMuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSx3aWxsU3luY1NlcnZpY2U6ITEscG9pbnRzOnR9fXJldHVybnt0eXBlOnV0Lk5vbmV9fWNvbnN1bWVTZXJ2aWNlKCl7fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9Y2xlYXJTZWxlY3REYXRhKCl7dGhpcy5zZWxlY3RJZHM9dm9pZCAwLHRoaXMub2xkU2VsZWN0UmVjdD12b2lkIDB9YmFja1RvRnVsbExheWVyKGUpe3ZhciBzLGw7bGV0IHQ7Y29uc3Qgcj1bXSxuPVtdO2Zvcihjb25zdCBjIG9mKChzPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6cy5jaGlsZHJlbil8fFtdKWlmKCEoZSE9bnVsbCYmZS5sZW5ndGgmJiFlLmluY2x1ZGVzKGMuaWQpKSYmYy5pZCE9PVJ0LnNlbGVjdG9ySWQpe2NvbnN0IG89Yy5jbG9uZU5vZGUoITApO05lKGMpJiZvLnNlYWwoKSx0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShjLm5hbWUpLmxlbmd0aHx8ci5wdXNoKG8pLG4ucHVzaChjKTtjb25zdCBmPShsPXRoaXMudk5vZGVzLmdldChjLm5hbWUpKT09bnVsbD92b2lkIDA6bC5yZWN0O2YmJih0PWJ0KHQsZikpfXJldHVybiBuLmZvckVhY2goYz0+Yy5yZW1vdmUoKSksci5sZW5ndGgmJnRoaXMuZnVsbExheWVyLmFwcGVuZCguLi5yKSx0fXNlYWxUb0RyYXdMYXllcihlKXt2YXIgbjtjb25zdCB0PVtdLHI9W107ZS5mb3JFYWNoKHM9Pnt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShzLnRvU3RyaW5nKCkpLmZvckVhY2gobD0+e3ZhciBvO2NvbnN0IGM9bC5jbG9uZU5vZGUoITApO05lKGwpJiZjLnNlYWwoKSwobz10aGlzLmRyYXdMYXllcikhPW51bGwmJm8uZ2V0RWxlbWVudHNCeU5hbWUobC5uYW1lKS5sZW5ndGh8fHQucHVzaChjKSxyLnB1c2gobCl9KX0pLHIuZm9yRWFjaChzPT5zLnJlbW92ZSgpKSx0JiYoKG49dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxuLmFwcGVuZCguLi50KSl9Z2V0U2VsZWN0b3JSZWN0KGUsdCl7dmFyIGw7bGV0IHI7Y29uc3Qgbj0obD1lLnBhcmVudCk9PW51bGw/dm9pZCAwOmwuZ2V0RWxlbWVudEJ5SWQodCkscz1uPT1udWxsP3ZvaWQgMDpuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiBzJiYocj1idChyLHt4Ok1hdGguZmxvb3Iocy54KSx5Ok1hdGguZmxvb3Iocy55KSx3Ok1hdGgucm91bmQocy53aWR0aCksaDpNYXRoLnJvdW5kKHMuaGVpZ2h0KX0pKSxyfWlzQ2FuRmlsbENvbG9yKGUpe3JldHVybiBlPT09dnQuRWxsaXBzZXx8ZT09PXZ0LlRyaWFuZ2xlfHxlPT09dnQuUmVjdGFuZ2xlfHxlPT09dnQuUG9seWdvbnx8ZT09PXZ0LlN0YXJ8fGU9PT12dC5TcGVlY2hCYWxsb29ufXVwZGF0ZVNlbGVjdG9yKGUpe2NvbnN0e3VwZGF0ZVNlbGVjdG9yT3B0OnQsc2VsZWN0SWRzOnIsdk5vZGVzOm4sd2lsbFNlcmlhbGl6ZURhdGE6cyx3b3JrZXI6bH09ZSxjPXRoaXMuZHJhd0xheWVyO2lmKCFjKXJldHVybjtsZXQgbztjb25zdCBmPW5ldyBNYXAse2JveDp4LHdvcmtTdGF0ZTpnLGFuZ2xlOnksdHJhbnNsYXRlOm19PXQ7bGV0IFQ9WzAsMF0sTz1bMSwxXSx2PVswLDBdLFA7aWYoeHx8bXx8ZXIoeSkpe2lmKGc9PT1JdC5TdGFydClyZXR1cm4gbi5zZXRUYXJnZXQoKSx7dHlwZTp1dC5TZWxlY3QsZGF0YVR5cGU6UHQuTG9jYWwsc2VsZWN0UmVjdDp0aGlzLm9sZFNlbGVjdFJlY3QscmVjdDp0aGlzLm9sZFNlbGVjdFJlY3R9O2lmKFA9bi5nZXRMYXN0VGFyZ2V0KCksUCYmeCl7bGV0IHU7cj09bnVsbHx8ci5mb3JFYWNoKGE9Pntjb25zdCBoPVA9PW51bGw/dm9pZCAwOlAuZ2V0KGEpO3U9YnQodSxoPT1udWxsP3ZvaWQgMDpoLnJlY3QpfSksdSYmKE89W3gudy91LncseC5oL3UuaF0sVD1beC54K3gudy8yLSh1LngrdS53LzIpLHgueSt4LmgvMi0odS55K3UuaC8yKV0sdj1bdS54K3Uudy8yLHUueSt1LmgvMl0pfX1yPT1udWxsfHxyLmZvckVhY2godT0+e2NvbnN0IGE9bi5nZXQodSk7aWYoYSl7Y29uc3R7dG9vbHNUeXBlOmh9PWE7bGV0IGI9KGM9PW51bGw/dm9pZCAwOmMuZ2V0RWxlbWVudHNCeU5hbWUodSkpWzBdO2lmKGIpe2NvbnN0IEU9ey4uLnR9O2xldCBBO2lmKGgpe2lmKFAmJihBPVAuZ2V0KHUpLEEmJngpKXtFLmJveFNjYWxlPU87Y29uc3QgUz1bQS5yZWN0LngrQS5yZWN0LncvMixBLnJlY3QueStBLnJlY3QuaC8yXSxJPVtTWzBdLXZbMF0sU1sxXS12WzFdXTtFLmJveFRyYW5zbGF0ZT1bSVswXSooT1swXS0xKStUWzBdLElbMV0qKE9bMV0tMSkrVFsxXV19Y29uc3QgTD1QbihoKTtpZihMPT1udWxsfHxMLnVwZGF0ZU5vZGVPcHQoe25vZGU6YixvcHQ6RSx2Tm9kZXM6bix3aWxsU2VyaWFsaXplRGF0YTpzLHRhcmdldE5vZGU6QX0pLGEmJmwmJihzJiYoRS5hbmdsZXx8RS50cmFuc2xhdGUpfHxFLmJveCYmRS53b3JrU3RhdGUhPT1JdC5TdGFydHx8RS5wb2ludE1hcCYmRS5wb2ludE1hcC5oYXModSkpKXtjb25zdCBTPWwuY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNUeXBlOmgsdG9vbHNPcHQ6YS5vcHR9KTtTPT1udWxsfHxTLnNldFdvcmtJZCh1KTtjb25zdCBJPVM9PW51bGw/dm9pZCAwOlMuY29uc3VtZVNlcnZpY2Uoe29wOmEub3AsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6dSxpc0NsZWFyQWxsOiExfSk7SSYmKGEucmVjdD1JLG4uc2V0SW5mbyh1LGEpKSxiPShjPT1udWxsP3ZvaWQgMDpjLmdldEVsZW1lbnRzQnlOYW1lKHUpKVswXX1hJiYoZi5zZXQodSxhKSxvPWJ0KG8sYS5yZWN0KSl9fX19LHRoaXMpLFAmJmc9PT1JdC5Eb25lJiZuLmRlbGV0ZUxhc3RUYXJnZXQoKSx0aGlzLmRyYXcoUnQuc2VsZWN0b3JJZCxjLHtzZWxlY3RJZHM6cnx8W10sc3ViTm9kZU1hcDpmLGludGVyc2VjdFJlY3Q6b30pO2NvbnN0IGk9YnQodGhpcy5vbGRTZWxlY3RSZWN0LG8pO3JldHVybiB0aGlzLm9sZFNlbGVjdFJlY3Q9byx7dHlwZTp1dC5TZWxlY3QsZGF0YVR5cGU6UHQuTG9jYWwsc2VsZWN0UmVjdDpvLHJlY3Q6aX19Ymx1clNlbGVjdG9yKCl7Y29uc3QgZT10aGlzLmJhY2tUb0Z1bGxMYXllcigpO3JldHVybnt0eXBlOnV0LlNlbGVjdCxkYXRhVHlwZTpQdC5Mb2NhbCxyZWN0OmUsc2VsZWN0SWRzOltdLHdpbGxTeW5jU2VydmljZTohMH19Z2V0UmlnaHRTZXJ2aWNlSWQoZSl7cmV0dXJuIGUucmVwbGFjZSgiKysiLCItIil9c2VsZWN0U2VydmljZU5vZGUoZSx0LHIpe2NvbnN0e3NlbGVjdElkczpufT10LHM9dGhpcy5nZXRSaWdodFNlcnZpY2VJZChlKSxsPXRoaXMuZ2V0U2VsZWN0b3JSZWN0KHRoaXMuZnVsbExheWVyLHMpO2xldCBjO2NvbnN0IG89bmV3IE1hcDtyZXR1cm4gbj09bnVsbHx8bi5mb3JFYWNoKGY9Pntjb25zdCB4PXRoaXMudk5vZGVzLmdldChmKSxnPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGYpWzBdO3gmJmcmJihjPWJ0KGMseC5yZWN0KSxvLnNldChmLHgpKX0pLHRoaXMuZHJhdyhzLHRoaXMuZnVsbExheWVyLHtpbnRlcnNlY3RSZWN0OmMsc2VsZWN0SWRzOm58fFtdLHN1Yk5vZGVNYXA6b30sciksYnQoYyxsKX1yZVJlbmRlclNlbGVjdG9yKCl7dmFyIHI7bGV0IGU7Y29uc3QgdD1uZXcgTWFwO3JldHVybihyPXRoaXMuc2VsZWN0SWRzKT09bnVsbHx8ci5mb3JFYWNoKG49Pntjb25zdCBzPXRoaXMudk5vZGVzLmdldChuKTtzJiYoZT1idChlLHMucmVjdCksdC5zZXQobixzKSl9LHRoaXMpLHRoaXMuZHJhdyhSdC5zZWxlY3RvcklkLHRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7aW50ZXJzZWN0UmVjdDplLHN1Yk5vZGVNYXA6dCxzZWxlY3RJZHM6dGhpcy5zZWxlY3RJZHN8fFtdfSksdGhpcy5nZXRTZWxlY3Rlb3JJbmZvKHQpLHRoaXMub2xkU2VsZWN0UmVjdD1lLGV9dXBkYXRlU2VsZWN0SWRzKGUpe3ZhciBsLGM7bGV0IHQ7Y29uc3Qgcj0obD10aGlzLnNlbGVjdElkcyk9PW51bGw/dm9pZCAwOmwuZmlsdGVyKG89PiFlLmluY2x1ZGVzKG8pKSxuPWUuZmlsdGVyKG89Pnt2YXIgZjtyZXR1cm4hKChmPXRoaXMuc2VsZWN0SWRzKSE9bnVsbCYmZi5pbmNsdWRlcyhvKSl9KTtpZihyIT1udWxsJiZyLmxlbmd0aCYmKHQ9dGhpcy5iYWNrVG9GdWxsTGF5ZXIocikpLG4ubGVuZ3RoKXt0aGlzLnNlYWxUb0RyYXdMYXllcihuKTtmb3IoY29uc3QgbyBvZiBuKXtjb25zdCBmPShjPXRoaXMudk5vZGVzLmdldChvKSk9PW51bGw/dm9pZCAwOmMucmVjdDtmJiYodD1idCh0LGYpKX19dGhpcy5zZWxlY3RJZHM9ZTtjb25zdCBzPXRoaXMucmVSZW5kZXJTZWxlY3RvcigpO3JldHVybntiZ1JlY3Q6dCxzZWxlY3RSZWN0OnN9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoUnQsInNlbGVjdG9ySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpSaH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdCwic2VsZWN0b3JCb3JkZXJJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiJzZWxlY3Rvci1ib3JkZXIifSk7Y2xhc3MgZ24gZXh0ZW5kcyBndHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6S3QuYm90aH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5BcnJvd30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFycm93VGlwV2lkdGgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLmFycm93VGlwV2lkdGg9dGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MqNCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciBtO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxzPShtPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6bS50b1N0cmluZygpO2lmKCFzKXJldHVybnt0eXBlOnV0Lk5vbmV9O2NvbnN0e29wOmwsd29ya1N0YXRlOmN9PXQsbz1sPT1udWxsP3ZvaWQgMDpsLmxlbmd0aDtpZighb3x8bzwyKXJldHVybnt0eXBlOnV0Lk5vbmV9O2xldCBmO2lmKGM9PT1JdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyBPdChsWzBdLGxbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhsKSwhZilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZighbil7Y29uc3QgVD1EYXRlLm5vdygpO3JldHVybiBULXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVQse3R5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnMsb3A6dGhpcy50bXBQb2ludHMubWFwKE89PlsuLi5PLlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6dXQuTm9uZX19Y29uc3QgeD1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixnPXRoaXMuZHJhdyh7d29ya0lkOnMsbGF5ZXI6eH0pLHk9YnQoZyx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9Zyx7cmVjdDp5LHR5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnN9fWNvbnN1bWVBbGwoZSl7dmFyIG87Y29uc3R7ZGF0YTp0fT1lLHI9KG89dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpvLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMuZnVsbExheWVyLHM9dGhpcy5kcmF3KHt3b3JrSWQ6cixsYXllcjpufSk7dGhpcy5vbGRSZWN0PXM7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksYz1rdChsKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0OnMsb3A6bCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjZW50ZXJQb3M6Z3QuZ2V0Q2VudGVyUG9zKHMsbil9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnIsb3BzOmMsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBQO2NvbnN0e3dvcmtJZDp0LGxheWVyOnJ9PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKGk9PmkucmVtb3ZlKCkpLChQPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8UC5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoaT0+aS5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6bix0aGlja25lc3M6cyx6SW5kZXg6bCxzY2FsZTpjLHJvdGF0ZTpvLHRyYW5zbGF0ZTpmfT10aGlzLndvcmtPcHRpb25zLHg9ci53b3JsZFBvc2l0aW9uLGc9ci53b3JsZFNjYWxpbmcse3BvaW50czp5LHJlY3Q6bX09dGhpcy5jb21wdXREcmF3UG9pbnRzKHMpLE89e3BvczpbbS54K20udy8yLG0ueSttLmgvMl0sbmFtZTp0LGlkOnQsY2xvc2U6ITAscG9pbnRzOnksZmlsbENvbG9yOm4sc3Ryb2tlQ29sb3I6bixsaW5lV2lkdGg6MCxub3JtYWxpemU6ITAsekluZGV4Omx9O2MmJihPLnNjYWxlPWMpLG8mJihPLnJvdGF0ZT1vKSxmJiYoTy50cmFuc2xhdGU9Zik7Y29uc3Qgdj1uZXcgcXQoTyk7aWYoci5hcHBlbmQodiksY3x8b3x8Zil7Y29uc3QgaT12LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaS54LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaS55LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaS53aWR0aCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaS5oZWlnaHQrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybnt4Ok1hdGguZmxvb3IobS54KmdbMF0reFswXS1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKG0ueSpnWzFdK3hbMV0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihtLncqZ1swXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IobS5oKmdbMV0rMipndC5TYWZlQm9yZGVyUGFkZGluZyl9fWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMudG1wUG9pbnRzWzFdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzWzBdKT50aGlzLmFycm93VGlwV2lkdGg/dGhpcy5jb21wdXRGdWxsQXJyb3dQb2ludHMoZSk6dGhpcy5jb21wdXRUcmlhbmdsZVBvaW50cygpfWNvbXB1dEZ1bGxBcnJvd1BvaW50cyhlKXtjb25zdCB0PV8uU3ViKHRoaXMudG1wUG9pbnRzWzFdLHRoaXMudG1wUG9pbnRzWzBdKS51bmkoKSxyPV8uUGVyKHQpLm11bChlLzIpLG49T3QuU3ViKHRoaXMudG1wUG9pbnRzWzBdLHIpLHM9T3QuQWRkKHRoaXMudG1wUG9pbnRzWzBdLHIpLGw9Xy5NdWwodCx0aGlzLmFycm93VGlwV2lkdGgpLGM9Xy5TdWIodGhpcy50bXBQb2ludHNbMV0sbCksbz1PdC5TdWIoYyxyKSxmPU90LkFkZChjLHIpLHg9Xy5QZXIodCkubXVsKGUqMS41KSxnPU90LlN1YihjLHgpLHk9T3QuQWRkKGMseCksbT1bbixvLGcsdGhpcy50bXBQb2ludHNbMV0seSxmLHNdO3JldHVybntwb2ludHM6bS5tYXAoVD0+T3QuU3ViKFQsdGhpcy50bXBQb2ludHNbMF0pLlhZKS5mbGF0KDEpLHJlY3Q6TnQobSksaXNUcmlhbmdsZTohMSxwb3M6dGhpcy50bXBQb2ludHNbMF0uWFl9fWNvbXB1dFRyaWFuZ2xlUG9pbnRzKCl7Y29uc3QgZT1fLlN1Yih0aGlzLnRtcFBvaW50c1sxXSx0aGlzLnRtcFBvaW50c1swXSkudW5pKCksdD10aGlzLnRtcFBvaW50c1sxXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1swXSkscj1fLlBlcihlKS5tdWwoTWF0aC5mbG9vcih0KjMvOCkpLG49T3QuU3ViKHRoaXMudG1wUG9pbnRzWzBdLHIpLHM9T3QuQWRkKHRoaXMudG1wUG9pbnRzWzBdLHIpLGw9W24sdGhpcy50bXBQb2ludHNbMV0sc107cmV0dXJue3BvaW50czpsLm1hcChjPT5PdC5TdWIoYyx0aGlzLnRtcFBvaW50c1swXSkuWFkpLmZsYXQoMSkscmVjdDpOdChsKSxpc1RyaWFuZ2xlOiEwLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IE90KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOnN9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixzKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgYztjb25zdHtvcDp0LGlzRnVsbFdvcms6cn09ZSxuPShjPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Yy50b1N0cmluZygpO2lmKCFuKXJldHVybjt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rPTMpdGhpcy50bXBQb2ludHMucHVzaChuZXcgT3QodFtvXSx0W28rMV0sdFtvKzJdKSk7Y29uc3Qgcz1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixsPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6c30pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNlbnRlclBvczpndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgYztjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOnN9PXIsbD1uLmdldCh0Lm5hbWUpO3JldHVybiBzJiYodC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixzKSx0LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixzKSwoYz1sPT1udWxsP3ZvaWQgMDpsLm9wdCkhPW51bGwmJmMuc3Ryb2tlQ29sb3ImJihsLm9wdC5zdHJva2VDb2xvcj1zKSxsJiZuLnNldEluZm8odC5uYW1lLGwpKSxndC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBtbiBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dnQuRWxsaXBzZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgbTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUscz0obT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm0udG9TdHJpbmcoKTtpZighcylyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHtvcDpsLHdvcmtTdGF0ZTpjfT10LG89bD09bnVsbD92b2lkIDA6bC5sZW5ndGg7aWYoIW98fG88MilyZXR1cm57dHlwZTp1dC5Ob25lfTtsZXQgZjtpZihjPT09SXQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgT3QobFswXSxsWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMobCksIWYpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYoIW4pe2NvbnN0IFQ9RGF0ZS5ub3coKTtyZXR1cm4gVC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1ULHt0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDpzLG9wOnRoaXMudG1wUG9pbnRzLm1hcChPPT5bLi4uTy5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOnV0Lk5vbmV9fWNvbnN0IHg9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsZz10aGlzLmRyYXcoe3dvcmtJZDpzLGxheWVyOngsaXNEcmF3aW5nOiEwfSkseT1idChnLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1nLHtyZWN0OnksdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6c319Y29uc3VtZUFsbChlKXt2YXIgbztjb25zdHtkYXRhOnR9PWUscj0obz10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm8udG9TdHJpbmcoKTtpZighcilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTp1dC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbcl19O2NvbnN0IG49dGhpcy5mdWxsTGF5ZXIscz10aGlzLmRyYXcoe3dvcmtJZDpyLGxheWVyOm4saXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PXM7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksYz1rdChsKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0OnMsb3A6bCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjZW50ZXJQb3M6cyYmZ3QuZ2V0Q2VudGVyUG9zKHMsbil9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnIsb3BzOmMsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBhO2NvbnN0e3dvcmtJZDp0LGxheWVyOnIsaXNEcmF3aW5nOm59PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKGg9PmgucmVtb3ZlKCkpLChhPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8YS5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoaD0+aC5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bCx0aGlja25lc3M6Yyx6SW5kZXg6byxzY2FsZTpmLHJvdGF0ZTp4LHRyYW5zbGF0ZTpnfT10aGlzLndvcmtPcHRpb25zLHk9ci53b3JsZFBvc2l0aW9uLG09ci53b3JsZFNjYWxpbmcse3JhZGl1czpULHJlY3Q6Tyxwb3M6dn09dGhpcy5jb21wdXREcmF3UG9pbnRzKGMpLFA9e3Bvczp2LG5hbWU6dCxpZDp0LHJhZGl1czpULGxpbmVXaWR0aDpjLGZpbGxDb2xvcjpsIT09InRyYW5zcGFyZW50IiYmbHx8dm9pZCAwLHN0cm9rZUNvbG9yOnMsbm9ybWFsaXplOiEwLHpJbmRleDpvfSxpPXt4Ok1hdGguZmxvb3IoTy54Km1bMF0reVswXS1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKE8ueSptWzFdK3lbMV0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihPLncqbVswXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IoTy5oKm1bMV0rMipndC5TYWZlQm9yZGVyUGFkZGluZyl9O2lmKG4pe2NvbnN0e25hbWU6aCxpZDpiLHpJbmRleDpFLHN0cm9rZUNvbG9yOkF9PVAsTD1ndC5nZXRDZW50ZXJQb3MoaSxyKSxTPW5ldyBlZSh7bmFtZTpoLGlkOmIsekluZGV4OkUscG9zOkwsYW5jaG9yOlsuNSwuNV0sc2l6ZTpbaS53LGkuaF19KSxJPW5ldyB1bih7Li4uUCxwb3M6WzAsMF19KSxEPW5ldyBzZSh7ZDoiTS00LDBINE0wLC00VjQiLG5vcm1hbGl6ZTohMCxwb3M6WzAsMF0sc3Ryb2tlQ29sb3I6QSxsaW5lV2lkdGg6MSxzY2FsZTpbMS9tWzBdLDEvbVsxXV19KTtyZXR1cm4gUy5hcHBlbmQoSSxEKSxyLmFwcGVuZChTKSxpfWYmJihQLnNjYWxlPWYpLHgmJihQLnJvdGF0ZT14KSxnJiYoUC50cmFuc2xhdGU9Zyk7Y29uc3QgdT1uZXcgdW4oUCk7aWYoci5hcHBlbmQodSkseHx8Znx8Zyl7Y29uc3QgaD11LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaC54LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaC55LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaC53aWR0aCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaC5oZWlnaHQrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybiBpfWNvbXB1dERyYXdQb2ludHMoZSl7Y29uc3QgdD1OdCh0aGlzLnRtcFBvaW50cykscj1OdCh0aGlzLnRtcFBvaW50cyxlKSxuPVtNYXRoLmZsb29yKHQueCt0LncvMiksTWF0aC5mbG9vcih0LnkrdC5oLzIpXTtyZXR1cm57cmVjdDpyLHBvczpuLHJhZGl1czpbTWF0aC5mbG9vcih0LncvMiksTWF0aC5mbG9vcih0LmgvMildfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMikscj1uZXcgT3QodFswXSx0WzFdKSxuPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6c309dGhpcy53b3JrT3B0aW9ucztpZihuLmlzTmVhcihyLHMpKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNlbnRlclBvczpndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZix4O2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bH09cixjPW4uZ2V0KHQubmFtZSk7bGV0IG89dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKG89dC5jaGlsZHJlblswXSkscyYmKG8uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscyksKGY9Yz09bnVsbD92b2lkIDA6Yy5vcHQpIT1udWxsJiZmLnN0cm9rZUNvbG9yJiYoYy5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJihsPT09InRyYW5zcGFyZW50Ij9vLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOm8uc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGwpLCh4PWM9PW51bGw/dm9pZCAwOmMub3B0KSE9bnVsbCYmeC5maWxsQ29sb3ImJihjLm9wdC5maWxsQ29sb3I9bCkpLGMmJm4uc2V0SW5mbyh0Lm5hbWUsYyksZ3QudXBkYXRlTm9kZU9wdChlKX19dmFyIExoPXJlLERoPXRlLHdoPSJbb2JqZWN0IEJvb2xlYW5dIjtmdW5jdGlvbiBOaChkKXtyZXR1cm4gZD09PSEwfHxkPT09ITF8fERoKGQpJiZMaChkKT09d2h9dmFyIGpoPU5oLHZlPXBlKGpoKTtjbGFzcyB2biBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dnQuUmVjdGFuZ2xlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH10cmFuc2Zvcm1EYXRhKCl7Y29uc3QgZT1OdCh0aGlzLnRtcFBvaW50cyk7cmV0dXJuW1tlLngsZS55LDBdLFtlLngrZS53LGUueSwwXSxbZS54K2UudyxlLnkrZS5oLDBdLFtlLngsZS55K2UuaCwwXV19Y29tcHV0RHJhd1BvaW50cyhlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxyPVtdO2Zvcihjb25zdCBsIG9mIGUpci5wdXNoKG5ldyBfKC4uLmwpKTtjb25zdCBuPU50KHIsdCkscz1bbi54K24udy8yLG4ueStuLmgvMl07cmV0dXJue3JlY3Q6bixwb3M6cyxwb2ludHM6ci5tYXAobD0+bC5YWSkuZmxhdCgxKX19Y29uc3VtZShlKXt2YXIgVDtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUscz0oVD10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOlQudG9TdHJpbmcoKTtpZighcylyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHtvcDpsLHdvcmtTdGF0ZTpjfT10LG89bD09bnVsbD92b2lkIDA6bC5sZW5ndGg7aWYoIW98fG88MilyZXR1cm57dHlwZTp1dC5Ob25lfTtsZXQgZjtpZihjPT09SXQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgT3QobFswXSxsWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMobCksIWYpcmV0dXJue3R5cGU6dXQuTm9uZX07Y29uc3QgeD10aGlzLnRyYW5zZm9ybURhdGEoKTtpZighbil7Y29uc3QgTz1EYXRlLm5vdygpO3JldHVybiBPLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPU8se3R5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnMsb3A6eC5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6dXQuTm9uZX19Y29uc3QgZz1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix5PXRoaXMuZHJhdyh7cHM6eCx3b3JrSWQ6cyxsYXllcjpnLGlzRHJhd2luZzohMH0pLG09YnQoeSx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9eSx7cmVjdDptLHR5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnN9fWNvbnN1bWVBbGwoZSl7dmFyIGY7Y29uc3R7ZGF0YTp0fT1lLHI9KGY9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMudHJhbnNmb3JtRGF0YSgpLHM9dGhpcy5mdWxsTGF5ZXIsbD10aGlzLmRyYXcoe3BzOm4sd29ya0lkOnIsbGF5ZXI6cyxpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9bDtjb25zdCBjPW4uZmxhdCgxKSxvPWt0KGMpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6bCxvcDpjLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpsJiZndC5nZXRDZW50ZXJQb3MobCxzKX0pLHtyZWN0OmwsdHlwZTp1dC5GdWxsV29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6cixvcHM6byxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIEE7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cixpc0RyYXdpbmc6bixwczpzLHJlcGxhY2VJZDpsfT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGx8fHQpLm1hcChMPT5MLnJlbW92ZSgpKSwoQT10aGlzLmRyYXdMYXllcik9PW51bGx8fEEuZ2V0RWxlbWVudHNCeU5hbWUobHx8dCkubWFwKEw9PkwucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOmMsZmlsbENvbG9yOm8sdGhpY2tuZXNzOmYsekluZGV4Ongsc2NhbGU6Zyxyb3RhdGU6eSx0cmFuc2xhdGU6bSx0ZXh0T3B0OlR9PXRoaXMud29ya09wdGlvbnMsTz1yLndvcmxkUG9zaXRpb24sdj1yLndvcmxkU2NhbGluZyx7cG9pbnRzOlAscmVjdDppLHBvczp1fT10aGlzLmNvbXB1dERyYXdQb2ludHMocyksYT17Y2xvc2U6ITAsbm9ybWFsaXplOiEwLHBvaW50czpQLGxpbmVXaWR0aDpmLGZpbGxDb2xvcjpvIT09InRyYW5zcGFyZW50IiYmb3x8dm9pZCAwLHN0cm9rZUNvbG9yOmMsbGluZUpvaW46InJvdW5kIn0saD17eDpNYXRoLmZsb29yKGkueCp2WzBdK09bMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihpLnkqdlsxXStPWzFdLWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaS53KnZbMF0rMipndC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKGkuaCp2WzBdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcpfSxiPW5ldyBlZSh7bmFtZTp0LGlkOnQsekluZGV4OngscG9zOnUsYW5jaG9yOlsuNSwuNV0sc2l6ZTpbaS53LGkuaF0sc2NhbGU6Zyxyb3RhdGU6eSx0cmFuc2xhdGU6bX0pLEU9bmV3IHF0KHsuLi5hLHBvczpbMCwwXX0pO2lmKGIuYXBwZW5kQ2hpbGQoRSksbil7Y29uc3QgTD1uZXcgc2Uoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOmMsbGluZVdpZHRoOjEsc2NhbGU6WzEvdlswXSwxL3ZbMV1dfSk7Yi5hcHBlbmRDaGlsZChMKX1pZihyLmFwcGVuZChiKSxnfHx5fHxtKXtjb25zdCBMPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihMLngtZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihMLnktZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihMLndpZHRoKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmhlaWdodCsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKX19cmV0dXJuIGh9dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IE90KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOnN9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixzKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgZjtjb25zdHtvcDp0LGlzRnVsbFdvcms6cixyZXBsYWNlSWQ6bn09ZSxzPShmPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Zi50b1N0cmluZygpO2lmKCFzKXJldHVybjtjb25zdCBsPVtdO2ZvcihsZXQgeD0wO3g8dC5sZW5ndGg7eCs9MylsLnB1c2goW3RbeF0sdFt4KzFdLHRbeCsyXV0pO2NvbnN0IGM9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsbz10aGlzLmRyYXcoe3BzOmwsd29ya0lkOnMsbGF5ZXI6Yyxpc0RyYXdpbmc6ITEscmVwbGFjZUlkOm59KTtyZXR1cm4gdGhpcy5vbGRSZWN0PW8sdGhpcy52Tm9kZXMuc2V0SW5mbyhzLHtyZWN0Om8sb3A6dCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6byYmZ3QuZ2V0Q2VudGVyUG9zKG8sYyl9KSxvfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7dmFyIHYsUDtjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOnMsZmlsbENvbG9yOmwsZm9udENvbG9yOmMsZm9udEJnQ29sb3I6byxib2xkOmYsaXRhbGljOngsbGluZVRocm91Z2g6Zyx1bmRlcmxpbmU6eSxmb250U2l6ZTptfT1yLFQ9bi5nZXQodC5uYW1lKTtsZXQgTz10O2lmKHQudGFnTmFtZT09PSJHUk9VUCImJihPPXQuY2hpbGRyZW5bMF0pLHMmJihPLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHMpLCh2PVQ9PW51bGw/dm9pZCAwOlQub3B0KSE9bnVsbCYmdi5zdHJva2VDb2xvciYmKFQub3B0LnN0cm9rZUNvbG9yPXMpKSxsJiYobD09PSJ0cmFuc3BhcmVudCI/Ty5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsInJnYmEoMCwwLDAsMCkiKTpPLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixsKSwoUD1UPT1udWxsP3ZvaWQgMDpULm9wdCkhPW51bGwmJlAuZmlsbENvbG9yJiYoVC5vcHQuZmlsbENvbG9yPWwpKSxUIT1udWxsJiZULm9wdC50ZXh0T3B0KXtjb25zdCBpPVQub3B0LnRleHRPcHQ7YyYmaS5mb250Q29sb3ImJihpLmZvbnRDb2xvcj1jKSxvJiZpLmZvbnRCZ0NvbG9yJiYoaS5mb250QmdDb2xvcj1vKSxmJiYoaS5ib2xkPWYpLHgmJihpLml0YWxpYz14KSx2ZShnKSYmKGkubGluZVRocm91Z2g9ZyksdmUoeSkmJihpLnVuZGVybGluZT15KSxtJiYoaS5mb250U2l6ZT1tKX1yZXR1cm4gVCYmbi5zZXRJbmZvKHQubmFtZSxUKSxndC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBwbiBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dnQuU3Rhcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgbTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUscz0obT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm0udG9TdHJpbmcoKTtpZighcylyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHtvcDpsLHdvcmtTdGF0ZTpjfT10LG89bD09bnVsbD92b2lkIDA6bC5sZW5ndGg7aWYoIW98fG88MilyZXR1cm57dHlwZTp1dC5Ob25lfTtsZXQgZjtpZihjPT09SXQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgT3QobFswXSxsWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMobCksIWYpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYoIW4pe2NvbnN0IFQ9RGF0ZS5ub3coKTtyZXR1cm4gVC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1ULHt0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDpzLG9wOnRoaXMudG1wUG9pbnRzLm1hcChPPT5bLi4uTy5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOnV0Lk5vbmV9fWNvbnN0IHg9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsZz10aGlzLmRyYXcoe3dvcmtJZDpzLGxheWVyOngsaXNEcmF3aW5nOiEwfSkseT1idChnLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1nLHtyZWN0OnksdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6c319Y29uc3VtZUFsbChlKXt2YXIgbztjb25zdHtkYXRhOnR9PWUscj0obz10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm8udG9TdHJpbmcoKTtpZighcilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTp1dC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbcl19O2NvbnN0IG49dGhpcy5mdWxsTGF5ZXIscz10aGlzLmRyYXcoe3dvcmtJZDpyLGxheWVyOm4saXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PXM7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksYz1rdChsKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0OnMsb3A6bCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cyYmZ3QuZ2V0Q2VudGVyUG9zKHMsbil9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnIsb3BzOmMsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBFO2NvbnN0e3dvcmtJZDp0LGxheWVyOnIsaXNEcmF3aW5nOm59PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKEE9PkEucmVtb3ZlKCkpLChFPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8RS5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoQT0+QS5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bCx0aGlja25lc3M6Yyx6SW5kZXg6byx2ZXJ0aWNlczpmLGlubmVyVmVydGljZVN0ZXA6eCxpbm5lclJhdGlvOmcsc2NhbGU6eSxyb3RhdGU6bSx0cmFuc2xhdGU6VH09dGhpcy53b3JrT3B0aW9ucyxPPXIud29ybGRQb3NpdGlvbix2PXIud29ybGRTY2FsaW5nLHtyZWN0OlAscG9zOmkscG9pbnRzOnV9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhjLGYseCxnKSxhPXtwb3M6aSxjbG9zZTohMCxuYW1lOnQsaWQ6dCxwb2ludHM6dSxsaW5lV2lkdGg6YyxmaWxsQ29sb3I6bCE9PSJ0cmFuc3BhcmVudCImJmx8fHZvaWQgMCxzdHJva2VDb2xvcjpzLGNsYXNzTmFtZTpgJHtpWzBdfSwke2lbMV19YCxub3JtYWxpemU6ITAsekluZGV4Om8sbGluZUpvaW46InJvdW5kIn0saD17eDpNYXRoLmZsb29yKFAueCp2WzBdK09bMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcqdlswXSkseTpNYXRoLmZsb29yKFAueSp2WzFdK09bMV0tZ3QuU2FmZUJvcmRlclBhZGRpbmcqdlsxXSksdzpNYXRoLmZsb29yKFAudyp2WzBdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcqdlswXSksaDpNYXRoLmZsb29yKFAuaCp2WzFdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcqdlsxXSl9O2lmKG4pe2NvbnN0e25hbWU6QSxpZDpMLHpJbmRleDpTLHN0cm9rZUNvbG9yOkl9PWEsRD1bKGgueCtoLncvMi1PWzBdKS92WzBdLChoLnkraC5oLzItT1sxXSkvdlsxXV0sUj1uZXcgZWUoe25hbWU6QSxpZDpMLHpJbmRleDpTLHBvczpELGFuY2hvcjpbLjUsLjVdLHNpemU6W2gudyxoLmhdfSksQz1uZXcgcXQoey4uLmEscG9zOlswLDBdfSksaj1uZXcgc2Uoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOkksbGluZVdpZHRoOjEsc2NhbGU6WzEvdlswXSwxL3ZbMV1dfSk7cmV0dXJuIFIuYXBwZW5kKEMsaiksci5hcHBlbmQoUiksaH15JiYoYS5zY2FsZT15KSxtJiYoYS5yb3RhdGU9bSksVCYmKGEudHJhbnNsYXRlPVQpO2NvbnN0IGI9bmV3IHF0KGEpO2lmKHIuYXBwZW5kKGIpLHl8fG18fFQpe2NvbnN0IEE9Yi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKEEueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEEueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEEud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKEEuaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gaH1jb21wdXREcmF3UG9pbnRzKGUsdCxyLG4pe2NvbnN0IHM9TnQodGhpcy50bXBQb2ludHMpLGw9W01hdGguZmxvb3Iocy54K3Mudy8yKSxNYXRoLmZsb29yKHMueStzLmgvMildLGM9bG4ocy53LHMuaCksbz1NYXRoLmZsb29yKE1hdGgubWluKHMudyxzLmgpLzIpLGY9bipvLHg9W10sZz0yKk1hdGguUEkvdDtmb3IobGV0IG09MDttPHQ7bSsrKXtjb25zdCBUPW0qZy0uNSpNYXRoLlBJO2xldCBPLHY7bSVyPT09MT8oTz1mKmNbMF0qTWF0aC5jb3MoVCksdj1mKmNbMV0qTWF0aC5zaW4oVCkpOihPPW8qY1swXSpNYXRoLmNvcyhUKSx2PW8qY1sxXSpNYXRoLnNpbihUKSx4LnB1c2goTyx2KSkseC5wdXNoKE8sdil9cmV0dXJue3JlY3Q6TnQodGhpcy50bXBQb2ludHMsZSkscG9zOmwscG9pbnRzOnh9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyBPdCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpzfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIscyl8fE90LlN1YihuLHIpLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpsJiZndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZix4O2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bH09cixjPW4uZ2V0KHQubmFtZSk7bGV0IG89dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKG89dC5jaGlsZHJlblswXSkscyYmKG8uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscyksKGY9Yz09bnVsbD92b2lkIDA6Yy5vcHQpIT1udWxsJiZmLnN0cm9rZUNvbG9yJiYoYy5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJihsPT09InRyYW5zcGFyZW50Ij9vLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOm8uc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGwpLCh4PWM9PW51bGw/dm9pZCAwOmMub3B0KSE9bnVsbCYmeC5maWxsQ29sb3ImJihjLm9wdC5maWxsQ29sb3I9bCkpLGMmJm4uc2V0SW5mbyh0Lm5hbWUsYyksZ3QudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgeW4gZXh0ZW5kcyBndHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6S3QuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZ0LlBvbHlnb259KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfWNvbnN1bWUoZSl7dmFyIG07Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6cixpc1N1YldvcmtlcjpufT1lLHM9KG09dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDptLnRvU3RyaW5nKCk7aWYoIXMpcmV0dXJue3R5cGU6dXQuTm9uZX07Y29uc3R7b3A6bCx3b3JrU3RhdGU6Y309dCxvPWw9PW51bGw/dm9pZCAwOmwubGVuZ3RoO2lmKCFvfHxvPDIpcmV0dXJue3R5cGU6dXQuTm9uZX07bGV0IGY7aWYoYz09PUl0LlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IE90KGxbMF0sbFsxXSldLGY9ITEpOmY9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGwpLCFmKXJldHVybnt0eXBlOnV0Lk5vbmV9O2lmKCFuKXtjb25zdCBUPURhdGUubm93KCk7cmV0dXJuIFQtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lPyh0aGlzLnN5bmNUaW1lc3RhbXA9VCx7dHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6cyxvcDp0aGlzLnRtcFBvaW50cy5tYXAoTz0+Wy4uLk8uWFksMF0pLmZsYXQoMSksaXNTeW5jOiEwLGluZGV4OjB9KTp7dHlwZTp1dC5Ob25lfX1jb25zdCB4PXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGc9dGhpcy5kcmF3KHt3b3JrSWQ6cyxsYXllcjp4LGlzRHJhd2luZzohMH0pLHk9YnQoZyx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9Zyx7cmVjdDp5LHR5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnN9fWNvbnN1bWVBbGwoZSl7dmFyIG87Y29uc3R7ZGF0YTp0fT1lLHI9KG89dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpvLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMuZnVsbExheWVyLHM9dGhpcy5kcmF3KHt3b3JrSWQ6cixsYXllcjpuLGlzRHJhd2luZzohMX0pO3RoaXMub2xkUmVjdD1zO2NvbnN0IGw9dGhpcy50bXBQb2ludHMubWFwKGY9PlsuLi5mLlhZLDBdKS5mbGF0KDEpLGM9a3QobCk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8ocix7cmVjdDpzLG9wOmwsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOnMmJmd0LmdldENlbnRlclBvcyhzLG4pfSkse3JlY3Q6cyx0eXBlOnV0LkZ1bGxXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDpyLG9wczpjLGlzU3luYzohMH19ZHJhdyhlKXt2YXIgaDtjb25zdHt3b3JrSWQ6dCxsYXllcjpyLGlzRHJhd2luZzpufT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChiPT5iLnJlbW92ZSgpKSwoaD10aGlzLmRyYXdMYXllcik9PW51bGx8fGguZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKGI9PmIucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOnMsZmlsbENvbG9yOmwsdGhpY2tuZXNzOmMsekluZGV4Om8sdmVydGljZXM6ZixzY2FsZTp4LHJvdGF0ZTpnLHRyYW5zbGF0ZTp5fT10aGlzLndvcmtPcHRpb25zLG09ci53b3JsZFBvc2l0aW9uLFQ9ci53b3JsZFNjYWxpbmcse3JlY3Q6Tyxwb3M6dixwb2ludHM6UH09dGhpcy5jb21wdXREcmF3UG9pbnRzKGMsZiksaT17cG9zOnYsY2xvc2U6ITAsbmFtZTp0LGlkOnQscG9pbnRzOlAsbGluZVdpZHRoOmMsZmlsbENvbG9yOmwhPT0idHJhbnNwYXJlbnQiJiZsfHx2b2lkIDAsc3Ryb2tlQ29sb3I6cyxub3JtYWxpemU6ITAsekluZGV4Om8sbGluZUpvaW46InJvdW5kIn0sdT17eDpNYXRoLmZsb29yKE8ueCpUWzBdK21bMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcqVFswXSkseTpNYXRoLmZsb29yKE8ueSpUWzFdK21bMV0tZ3QuU2FmZUJvcmRlclBhZGRpbmcqVFsxXSksdzpNYXRoLmZsb29yKE8udypUWzBdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcqVFswXSksaDpNYXRoLmZsb29yKE8uaCpUWzFdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcqVFsxXSl9O2lmKG4pe2NvbnN0e25hbWU6YixpZDpFLHpJbmRleDpBLHN0cm9rZUNvbG9yOkx9PWksUz1bKHUueCt1LncvMi1tWzBdKS9UWzBdLCh1LnkrdS5oLzItbVsxXSkvVFsxXV0sST1uZXcgZWUoe25hbWU6YixpZDpFLHpJbmRleDpBLHBvczpTLGFuY2hvcjpbLjUsLjVdLHNpemU6W3Uudyx1LmhdfSksRD1uZXcgcXQoey4uLmkscG9zOlswLDBdfSksUj1uZXcgc2Uoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOkwsbGluZVdpZHRoOjEsc2NhbGU6WzEvVFswXSwxL1RbMV1dfSk7cmV0dXJuIEkuYXBwZW5kKEQsUiksci5hcHBlbmQoSSksdX14JiYoaS5zY2FsZT14KSxnJiYoaS5yb3RhdGU9ZykseSYmKGkudHJhbnNsYXRlPXkpO2NvbnN0IGE9bmV3IHF0KGkpO2lmKHIuYXBwZW5kKGEpLHh8fGd8fHkpe2NvbnN0IGI9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKGIueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKGIueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKGIud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKGIuaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gdX1jb21wdXREcmF3UG9pbnRzKGUsdCl7Y29uc3Qgcj1OdCh0aGlzLnRtcFBvaW50cyksbj1bTWF0aC5mbG9vcihyLngrci53LzIpLE1hdGguZmxvb3Ioci55K3IuaC8yKV0scz1sbihyLncsci5oKSxsPU1hdGguZmxvb3IoTWF0aC5taW4oci53LHIuaCkvMiksYz1bXSxvPTIqTWF0aC5QSS90O2ZvcihsZXQgeD0wO3g8dDt4Kyspe2NvbnN0IGc9eCpvLS41Kk1hdGguUEkseT1sKnNbMF0qTWF0aC5jb3MoZyksbT1sKnNbMV0qTWF0aC5zaW4oZyk7Yy5wdXNoKHksbSl9cmV0dXJue3JlY3Q6TnQodGhpcy50bXBQb2ludHMsZSkscG9zOm4scG9pbnRzOmN9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyBPdCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpzfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIscyl8fE90LlN1YihuLHIpLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpsJiZndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZix4O2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bH09cixjPW4uZ2V0KHQubmFtZSk7bGV0IG89dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKG89dC5jaGlsZHJlblswXSkscyYmKG8uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscyksKGY9Yz09bnVsbD92b2lkIDA6Yy5vcHQpIT1udWxsJiZmLnN0cm9rZUNvbG9yJiYoYy5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJihsPT09InRyYW5zcGFyZW50Ij9vLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOm8uc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGwpLCh4PWM9PW51bGw/dm9pZCAwOmMub3B0KSE9bnVsbCYmeC5maWxsQ29sb3ImJihjLm9wdC5maWxsQ29sb3I9bCkpLGMmJm4uc2V0SW5mbyh0Lm5hbWUsYyksZ3QudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgSnR7c3RhdGljIGJlemllcihlLHQpe2NvbnN0IHI9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKz00KXtjb25zdCBzPXRbbl0sbD10W24rMV0sYz10W24rMl0sbz10W24rM107cyYmbCYmYyYmbz9yLnB1c2goLi4uSnQuZ2V0QmV6aWVyUG9pbnRzKGUscyxsLGMsbykpOnMmJmwmJmM/ci5wdXNoKC4uLkp0LmdldEJlemllclBvaW50cyhlLHMsbCxjKSk6cyYmbD9yLnB1c2goLi4uSnQuZ2V0QmV6aWVyUG9pbnRzKGUscyxsKSk6cyYmci5wdXNoKHMpfXJldHVybiByfXN0YXRpYyBnZXRCZXppZXJQb2ludHMoZT0xMCx0LHIsbixzKXtsZXQgbD1udWxsO2NvbnN0IGM9W107IW4mJiFzP2w9SnQub25lQmV6aWVyOm4mJiFzP2w9SnQudHdvQmV6aWVyOm4mJnMmJihsPUp0LnRocmVlQmV6aWVyKTtmb3IobGV0IG89MDtvPGU7bysrKWwmJmMucHVzaChsKG8vZSx0LHIsbixzKSk7cmV0dXJuIHM/Yy5wdXNoKHMpOm4mJmMucHVzaChuKSxjfXN0YXRpYyBvbmVCZXppZXIoZSx0LHIpe2NvbnN0IG49dC54KyhyLngtdC54KSplLHM9dC55KyhyLnktdC55KSplO3JldHVybiBuZXcgXyhuLHMpfXN0YXRpYyB0d29CZXppZXIoZSx0LHIsbil7Y29uc3Qgcz0oMS1lKSooMS1lKSp0LngrMiplKigxLWUpKnIueCtlKmUqbi54LGw9KDEtZSkqKDEtZSkqdC55KzIqZSooMS1lKSpyLnkrZSplKm4ueTtyZXR1cm4gbmV3IF8ocyxsKX1zdGF0aWMgdGhyZWVCZXppZXIoZSx0LHIsbixzKXtjb25zdCBsPXQueCooMS1lKSooMS1lKSooMS1lKSszKnIueCplKigxLWUpKigxLWUpKzMqbi54KmUqZSooMS1lKStzLngqZSplKmUsYz10LnkqKDEtZSkqKDEtZSkqKDEtZSkrMypyLnkqZSooMS1lKSooMS1lKSszKm4ueSplKmUqKDEtZSkrcy55KmUqZSplO3JldHVybiBuZXcgXyhsLGMpfX1jbGFzcyB4biBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dnQuU3BlZWNoQmFsbG9vbn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJyYXRpbyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOi44fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciBtO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxzPShtPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6bS50b1N0cmluZygpO2lmKCFzKXJldHVybnt0eXBlOnV0Lk5vbmV9O2NvbnN0e29wOmwsd29ya1N0YXRlOmN9PXQsbz1sPT1udWxsP3ZvaWQgMDpsLmxlbmd0aDtpZighb3x8bzwyKXJldHVybnt0eXBlOnV0Lk5vbmV9O2xldCBmO2lmKGM9PT1JdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyBPdChsWzBdLGxbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhsKSwhZilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZighbil7Y29uc3QgVD1EYXRlLm5vdygpO3JldHVybiBULXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVQse3R5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnMsb3A6dGhpcy50bXBQb2ludHMubWFwKE89PlsuLi5PLlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6dXQuTm9uZX19Y29uc3QgeD1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixnPXRoaXMuZHJhdyh7d29ya0lkOnMsbGF5ZXI6eCxpc0RyYXdpbmc6ITB9KSx5PWJ0KGcsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWcse3JlY3Q6eSx0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDpzfX1jb25zdW1lQWxsKGUpe3ZhciBvO2NvbnN0e2RhdGE6dH09ZSxyPShvPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6by50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOnV0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOnV0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixzPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bixpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9cztjb25zdCBsPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxjPWt0KGwpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6cyxvcDpsLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpzJiZndC5nZXRDZW50ZXJQb3MocyxuKX0pLHtyZWN0OnMsdHlwZTp1dC5GdWxsV29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6cixvcHM6Yyxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGE7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoaD0+aC5yZW1vdmUoKSksKGE9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxhLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChoPT5oLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjpuLGZpbGxDb2xvcjpzLHRoaWNrbmVzczpsLHpJbmRleDpjLHBsYWNlbWVudDpvLHNjYWxlOmYscm90YXRlOngsdHJhbnNsYXRlOmd9PXRoaXMud29ya09wdGlvbnMseT1yLndvcmxkUG9zaXRpb24sbT1yLndvcmxkU2NhbGluZyx7cmVjdDpULHBvczpPLHBvaW50czp2fT10aGlzLmNvbXB1dERyYXdQb2ludHMobCxvKSxQPXtwb3M6TyxuYW1lOnQsaWQ6dCxwb2ludHM6di5tYXAoaD0+aC5YWSksbGluZVdpZHRoOmwsZmlsbENvbG9yOnMhPT0idHJhbnNwYXJlbnQiJiZzfHx2b2lkIDAsc3Ryb2tlQ29sb3I6bixub3JtYWxpemU6ITAsY2xhc3NOYW1lOmAke09bMF19LCR7T1sxXX1gLHpJbmRleDpjLGxpbmVKb2luOiJyb3VuZCIsY2xvc2U6ITB9LGk9e3g6TWF0aC5mbG9vcihULngqbVswXSt5WzBdLWd0LlNhZmVCb3JkZXJQYWRkaW5nKm1bMF0pLHk6TWF0aC5mbG9vcihULnkqbVsxXSt5WzFdLWd0LlNhZmVCb3JkZXJQYWRkaW5nKm1bMV0pLHc6TWF0aC5mbG9vcihULncqbVswXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKm1bMF0pLGg6TWF0aC5mbG9vcihULmgqbVsxXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKm1bMV0pfTtmJiYoUC5zY2FsZT1mKSx4JiYoUC5yb3RhdGU9eCksZyYmKFAudHJhbnNsYXRlPWcpO2NvbnN0IHU9bmV3IHF0KFApO2lmKHIuYXBwZW5kKHUpLGZ8fHh8fGcpe2NvbnN0IGg9dS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKGgueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKGgueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKGgud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKGguaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gaX10cmFuc2Zvcm1Db250cm9sUG9pbnRzKGUpe2NvbnN0IHQ9TnQodGhpcy50bXBQb2ludHMpO3N3aXRjaChlKXtjYXNlImJvdHRvbSI6Y2FzZSJib3R0b21MZWZ0IjpjYXNlImJvdHRvbVJpZ2h0Ijp7Y29uc3Qgcj10LnkrdC5oKnRoaXMucmF0aW87cmV0dXJuW25ldyBfKHQueCx0LnksMCksbmV3IF8odC54K3Qudyx0LnksMCksbmV3IF8odC54K3QudyxyLDApLG5ldyBfKHQueCxyLDApXX1jYXNlInRvcCI6Y2FzZSJ0b3BMZWZ0IjpjYXNlInRvcFJpZ2h0Ijp7Y29uc3Qgcj10LnkrdC5oKigxLXRoaXMucmF0aW8pO3JldHVybltuZXcgXyh0LngsciwwKSxuZXcgXyh0LngrdC53LHIsMCksbmV3IF8odC54K3Qudyx0LnkrdC5oLDApLG5ldyBfKHQueCx0LnkrdC5oLDApXX1jYXNlImxlZnQiOmNhc2UibGVmdEJvdHRvbSI6Y2FzZSJsZWZ0VG9wIjp7Y29uc3Qgcj10LngrdC53KigxLXRoaXMucmF0aW8pO3JldHVybltuZXcgXyhyLHQueSwwKSxuZXcgXyh0LngrdC53LHQueSwwKSxuZXcgXyh0LngrdC53LHQueSt0LmgsMCksbmV3IF8ocix0LnkrdC5oLDApXX1jYXNlInJpZ2h0IjpjYXNlInJpZ2h0Qm90dG9tIjpjYXNlInJpZ2h0VG9wIjp7Y29uc3Qgcj10LngrdC53KnRoaXMucmF0aW87cmV0dXJuW25ldyBfKHQueCx0LnksMCksbmV3IF8ocix0LnksMCksbmV3IF8ocix0LnkrdC5oLDApLG5ldyBfKHQueCx0LnkrdC5oLDApXX19fWNvbXB1dERyYXdQb2ludHMoZSx0KXtjb25zdCByPU50KHRoaXMudG1wUG9pbnRzKSxuPXRoaXMudHJhbnNmb3JtQ29udHJvbFBvaW50cyh0KSxzPU1hdGguZmxvb3Ioci53Ki4xKSxsPU1hdGguZmxvb3Ioci5oKi4xKSxjPVtdLG89Xy5BZGQoblswXSxuZXcgXygwLGwsMCkpLGY9Xy5BZGQoblswXSxuZXcgXyhzLDAsMCkpLHg9SnQuZ2V0QmV6aWVyUG9pbnRzKDEwLG8sblswXSxmKSxnPV8uU3ViKG5bMV0sbmV3IF8ocywwLDApKSx5PV8uQWRkKG5bMV0sbmV3IF8oMCxsLDApKSxtPUp0LmdldEJlemllclBvaW50cygxMCxnLG5bMV0seSksVD1fLlN1YihuWzJdLG5ldyBfKDAsbCwwKSksTz1fLlN1YihuWzJdLG5ldyBfKHMsMCwwKSksdj1KdC5nZXRCZXppZXJQb2ludHMoMTAsVCxuWzJdLE8pLFA9Xy5BZGQoblszXSxuZXcgXyhzLDAsMCkpLGk9Xy5TdWIoblszXSxuZXcgXygwLGwsMCkpLHU9SnQuZ2V0QmV6aWVyUG9pbnRzKDEwLFAsblszXSxpKSxhPXMqKDEtdGhpcy5yYXRpbykqMTAsaD1sKigxLXRoaXMucmF0aW8pKjEwO3N3aXRjaCh0KXtjYXNlImJvdHRvbSI6e2NvbnN0IEE9Xy5TdWIoblsyXSxuZXcgXyhzKjUtYS8yLDAsMCkpLEw9Xy5TdWIoblsyXSxuZXcgXyhzKjUsLWgsMCkpLFM9Xy5TdWIoblsyXSxuZXcgXyhzKjUrYS8yLDAsMCkpO2MucHVzaChMLFMsLi4udSwuLi54LC4uLm0sLi4udixBKTticmVha31jYXNlImJvdHRvbVJpZ2h0Ijp7Y29uc3QgQT1fLlN1YihuWzJdLG5ldyBfKHMqMS4xLDAsMCkpLEw9Xy5TdWIoblsyXSxuZXcgXyhzKjEuMSthLzIsLWgsMCkpLFM9Xy5TdWIoblsyXSxuZXcgXyhzKjEuMSthLDAsMCkpO2MucHVzaChMLFMsLi4udSwuLi54LC4uLm0sLi4udixBKTticmVha31jYXNlImJvdHRvbUxlZnQiOntjb25zdCBBPV8uQWRkKG5bM10sbmV3IF8ocyoxLjErYSwwLDApKSxMPV8uQWRkKG5bM10sbmV3IF8ocyoxLjErYS8yLGgsMCkpLFM9Xy5BZGQoblszXSxuZXcgXyhzKjEuMSwwLDApKTtjLnB1c2goTCxTLC4uLnUsLi4ueCwuLi5tLC4uLnYsQSk7YnJlYWt9Y2FzZSJ0b3AiOntjb25zdCBBPV8uU3ViKG5bMV0sbmV3IF8ocyo1LWEvMiwwLDApKSxMPV8uU3ViKG5bMV0sbmV3IF8ocyo1LGgsMCkpLFM9Xy5TdWIoblsxXSxuZXcgXyhzKjUrYS8yLDAsMCkpO2MucHVzaChMLEEsLi4ubSwuLi52LC4uLnUsLi4ueCxTKTticmVha31jYXNlInRvcFJpZ2h0Ijp7Y29uc3QgQT1fLlN1YihuWzFdLG5ldyBfKHMqMS4xLDAsMCkpLEw9Xy5TdWIoblsxXSxuZXcgXyhzKjEuMSthLzIsaCwwKSksUz1fLlN1YihuWzFdLG5ldyBfKHMqMS4xK2EsMCwwKSk7Yy5wdXNoKEwsQSwuLi5tLC4uLnYsLi4udSwuLi54LFMpO2JyZWFrfWNhc2UidG9wTGVmdCI6e2NvbnN0IEE9Xy5BZGQoblswXSxuZXcgXyhzKjEuMSthLDAsMCkpLEw9Xy5BZGQoblswXSxuZXcgXyhzKjEuMSthLzIsLWgsMCkpLFM9Xy5BZGQoblswXSxuZXcgXyhzKjEuMSwwLDApKTtjLnB1c2goTCxBLC4uLm0sLi4udiwuLi51LC4uLngsUyk7YnJlYWt9Y2FzZSJsZWZ0Ijp7Y29uc3QgQT1fLkFkZChuWzBdLG5ldyBfKDAsbCo1LWgvMiwwKSksTD1fLkFkZChuWzBdLG5ldyBfKC1hLGwqNSwwKSksUz1fLkFkZChuWzBdLG5ldyBfKDAsbCo1K2gvMiwwKSk7Yy5wdXNoKEwsQSwuLi54LC4uLm0sLi4udiwuLi51LFMpO2JyZWFrfWNhc2UibGVmdFRvcCI6e2NvbnN0IEE9Xy5BZGQoblswXSxuZXcgXygwLGwqMS4xLDApKSxMPV8uQWRkKG5bMF0sbmV3IF8oLWEsbCoxLjEraC8yLDApKSxTPV8uQWRkKG5bMF0sbmV3IF8oMCxsKjEuMStoLDApKTtjLnB1c2goTCxBLC4uLngsLi4ubSwuLi52LC4uLnUsUyk7YnJlYWt9Y2FzZSJsZWZ0Qm90dG9tIjp7Y29uc3QgQT1fLlN1YihuWzNdLG5ldyBfKDAsbCoxLjEraCwwKSksTD1fLlN1YihuWzNdLG5ldyBfKGEsbCoxLjEraC8yLDApKSxTPV8uU3ViKG5bM10sbmV3IF8oMCxsKjEuMSwwKSk7Yy5wdXNoKEwsQSwuLi54LC4uLm0sLi4udiwuLi51LFMpO2JyZWFrfWNhc2UicmlnaHQiOntjb25zdCBBPV8uQWRkKG5bMV0sbmV3IF8oMCxsKjUtaC8yLDApKSxMPV8uQWRkKG5bMV0sbmV3IF8oYSxsKjUsMCkpLFM9Xy5BZGQoblsxXSxuZXcgXygwLGwqNStoLzIsMCkpO2MucHVzaChMLFMsLi4udiwuLi51LC4uLngsLi4ubSxBKTticmVha31jYXNlInJpZ2h0VG9wIjp7Y29uc3QgQT1fLkFkZChuWzFdLG5ldyBfKDAsbCoxLjEsMCkpLEw9Xy5BZGQoblsxXSxuZXcgXyhhLGwqMS4xK2gvMiwwKSksUz1fLkFkZChuWzFdLG5ldyBfKDAsbCoxLjEraCwwKSk7Yy5wdXNoKEwsUywuLi52LC4uLnUsLi4ueCwuLi5tLEEpO2JyZWFrfWNhc2UicmlnaHRCb3R0b20iOntjb25zdCBBPV8uU3ViKG5bMl0sbmV3IF8oMCxsKjEuMStoLDApKSxMPV8uU3ViKG5bMl0sbmV3IF8oLWEsbCoxLjEraC8yLDApKSxTPV8uU3ViKG5bMl0sbmV3IF8oMCxsKjEuMSwwKSk7Yy5wdXNoKEwsUywuLi52LC4uLnUsLi4ueCwuLi5tLEEpO2JyZWFrfX1jb25zdCBiPU50KHRoaXMudG1wUG9pbnRzLGUpLEU9W01hdGguZmxvb3IoYi54K2Iudy8yKSxNYXRoLmZsb29yKGIueStiLmgvMildO3JldHVybntyZWN0OmIscG9zOkUscG9pbnRzOmN9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyBPdCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpzfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIscyl8fE90LlN1YihuLHIpLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpsJiZndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZix4O2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bH09cixjPW4uZ2V0KHQubmFtZSk7bGV0IG89dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKG89dC5jaGlsZHJlblswXSkscyYmKG8uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscyksKGY9Yz09bnVsbD92b2lkIDA6Yy5vcHQpIT1udWxsJiZmLnN0cm9rZUNvbG9yJiYoYy5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJihsPT09InRyYW5zcGFyZW50Ij9vLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOm8uc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGwpLCh4PWM9PW51bGw/dm9pZCAwOmMub3B0KSE9bnVsbCYmeC5maWxsQ29sb3ImJihjLm9wdC5maWxsQ29sb3I9bCkpLGMmJm4uc2V0SW5mbyh0Lm5hbWUsYyksZ3QudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgT24gZXh0ZW5kcyBndHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6S3QuYm90aH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5TdHJhaWdodH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN0cmFpZ2h0VGlwV2lkdGgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN0cmFpZ2h0VGlwV2lkdGg9dGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MvMix0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciBtO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxzPShtPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6bS50b1N0cmluZygpO2lmKCFzKXJldHVybnt0eXBlOnV0Lk5vbmV9O2NvbnN0e29wOmwsd29ya1N0YXRlOmN9PXQsbz1sPT1udWxsP3ZvaWQgMDpsLmxlbmd0aDtpZighb3x8bzwyKXJldHVybnt0eXBlOnV0Lk5vbmV9O2xldCBmO2lmKGM9PT1JdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyBPdChsWzBdLGxbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhsKSwhZilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZighbil7Y29uc3QgVD1EYXRlLm5vdygpO3JldHVybiBULXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVQse3R5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnMsb3A6dGhpcy50bXBQb2ludHMubWFwKE89PlsuLi5PLlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6dXQuTm9uZX19Y29uc3QgeD1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixnPXRoaXMuZHJhdyh7d29ya0lkOnMsbGF5ZXI6eH0pLHk9YnQoZyx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9Zyx7cmVjdDp5LHR5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnN9fWNvbnN1bWVBbGwoZSl7dmFyIG87Y29uc3R7ZGF0YTp0fT1lLHI9KG89dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpvLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMuZnVsbExheWVyLHM9dGhpcy5kcmF3KHt3b3JrSWQ6cixsYXllcjpufSk7dGhpcy5vbGRSZWN0PXM7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksYz1rdChsKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0OnMsb3A6bCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cyYmZ3QuZ2V0Q2VudGVyUG9zKHMsbil9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnIsb3BzOmMsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBpO2NvbnN0e3dvcmtJZDp0LGxheWVyOnJ9PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKHU9PnUucmVtb3ZlKCkpLChpPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8aS5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAodT0+dS5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6bix0aGlja25lc3M6cyx6SW5kZXg6bCxzY2FsZTpjLHJvdGF0ZTpvLHRyYW5zbGF0ZTpmfT10aGlzLndvcmtPcHRpb25zLHg9ci53b3JsZFBvc2l0aW9uLGc9ci53b3JsZFNjYWxpbmcse2Q6eSxyZWN0Om19PXRoaXMuY29tcHV0RHJhd1BvaW50cyhzKSxUPVttLngrbS53LzIsbS55K20uaC8yXSxPPXtwb3M6VCxuYW1lOnQsaWQ6dCxkOnksZmlsbENvbG9yOm4sc3Ryb2tlQ29sb3I6bixsaW5lV2lkdGg6MCxjbGFzc05hbWU6YCR7VFswXX0sJHtUWzFdfWAsbm9ybWFsaXplOiEwLHpJbmRleDpsfTtjJiYoTy5zY2FsZT1jKSxvJiYoTy5yb3RhdGU9byksZiYmKE8udHJhbnNsYXRlPWYpO2NvbnN0IHY9bmV3IHNlKE8pO2lmKHIuYXBwZW5kKHYpLG98fGN8fGYpe2NvbnN0IHU9di5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKHUueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKHUueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHUud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKHUuaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm57eDpNYXRoLmZsb29yKG0ueCpnWzBdK3hbMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihtLnkqZ1sxXSt4WzFdLWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IobS53KmdbMF0rMipndC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKG0uaCpnWzFdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcpfX1jb21wdXREcmF3UG9pbnRzKGUpe3JldHVybiB0aGlzLnRtcFBvaW50c1sxXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1swXSk+dGhpcy5zdHJhaWdodFRpcFdpZHRoP3RoaXMuY29tcHV0RnVsbFBvaW50cyhlKTp0aGlzLmNvbXB1dERvdFBvaW50cyhlKX1jb21wdXRGdWxsUG9pbnRzKGUpe2NvbnN0IHQ9Xy5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHI9Xy5QZXIodCkubXVsKGUvMiksbj1PdC5TdWIodGhpcy50bXBQb2ludHNbMF0scikscz1PdC5BZGQodGhpcy50bXBQb2ludHNbMF0sciksbD1PdC5TdWIodGhpcy50bXBQb2ludHNbMV0sciksYz1PdC5BZGQodGhpcy50bXBQb2ludHNbMV0sciksbz1PdC5HZXRTZW1pY2lyY2xlU3Ryb2tlKHRoaXMudG1wUG9pbnRzWzFdLGwsLTEsOCksZj1PdC5HZXRTZW1pY2lyY2xlU3Ryb2tlKHRoaXMudG1wUG9pbnRzWzBdLHMsLTEsOCkseD1bbixsLC4uLm8sYyxzLC4uLmZdO3JldHVybntkOmdlKHgsITApLHJlY3Q6TnQoeCksaXNEb3Q6ITEscG9zOnRoaXMudG1wUG9pbnRzWzBdLlhZfX1jb21wdXREb3RQb2ludHMoZSl7Y29uc3QgdD1PdC5HZXREb3RTdHJva2UodGhpcy50bXBQb2ludHNbMF0sZS8yLDgpO3JldHVybntkOmdlKHQsITApLHJlY3Q6TnQodCksaXNEb3Q6ITAscG9zOnRoaXMudG1wUG9pbnRzWzBdLlhZfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMikscj1uZXcgT3QodFswXSx0WzFdKSxuPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6c309dGhpcy53b3JrT3B0aW9ucztpZihuLmlzTmVhcihyLHMpKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1sLHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDpsLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmwmJmd0LmdldENlbnRlclBvcyhsLHMpfSksbH1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBjO2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6c309cixsPW4uZ2V0KHQubmFtZSk7cmV0dXJuIHMmJih0LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHMpLHQuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLHMpLChjPWw9PW51bGw/dm9pZCAwOmwub3B0KSE9bnVsbCYmYy5zdHJva2VDb2xvciYmKGwub3B0LnN0cm9rZUNvbG9yPXMpKSxsJiZuLnNldEluZm8odC5uYW1lLGwpLGd0LnVwZGF0ZU5vZGVPcHQoZSl9fWNsYXNzIE9lIGV4dGVuZHMgZ3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkt0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5UZXh0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHR9Y29uc3VtZSgpe3JldHVybnt0eXBlOnV0Lk5vbmV9fWNvbnN1bWVBbGwoKXtyZXR1cm57dHlwZTp1dC5Ob25lfX1kcmF3KGUpe3ZhciBtO2NvbnN0e3dvcmtJZDp0LGxheWVyOnIsaXNEcmF3TGFiZWw6bn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoVD0+VC5yZW1vdmUoKSksKG09dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxtLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChUPT5ULnJlbW92ZSgpKTtjb25zdHtib3hTaXplOnMsYm94UG9pbnQ6bH09dGhpcy53b3JrT3B0aW9ucyxjPXIud29ybGRQb3NpdGlvbixvPXIud29ybGRTY2FsaW5nO2lmKCFsfHwhcylyZXR1cm47Y29uc3QgZj1uZXcgZWUoe25hbWU6dCxpZDp0LHBvczpbbFswXStzWzBdLzIsbFsxXStzWzFdLzJdLGFuY2hvcjpbLjUsLjVdLHNpemU6c30pLHg9e3g6bFswXSx5OmxbMV0sdzpzWzBdLGg6c1sxXX0sZz1uZXcgcnIoe25vcm1hbGl6ZTohMCxwb3M6WzAsMF0sc2l6ZTpzfSkseT1uJiZPZS5jcmVhdGVMYWJlbHModGhpcy53b3JrT3B0aW9ucyxyKXx8W107cmV0dXJuIGYuYXBwZW5kKC4uLnksZyksci5hcHBlbmQoZikse3g6TWF0aC5mbG9vcih4Lngqb1swXStjWzBdKSx5Ok1hdGguZmxvb3IoeC55Km9bMV0rY1sxXSksdzpNYXRoLmZsb29yKHgudypvWzBdKSxoOk1hdGguZmxvb3IoeC5oKm9bMV0pfX1jb25zdW1lU2VydmljZShlKXt2YXIgbyxmO2NvbnN0IHQ9KG89dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpvLnRvU3RyaW5nKCk7aWYoIXQpcmV0dXJuO2NvbnN0e2lzRnVsbFdvcms6cixyZXBsYWNlSWQ6bixpc0RyYXdMYWJlbDpzfT1lO3RoaXMub2xkUmVjdD1uJiYoKGY9dGhpcy52Tm9kZXMuZ2V0KG4pKT09bnVsbD92b2lkIDA6Zi5yZWN0KXx8dm9pZCAwO2NvbnN0IGw9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsYz10aGlzLmRyYXcoe3dvcmtJZDp0LGxheWVyOmwsaXNEcmF3TGFiZWw6c30pO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHQse3JlY3Q6YyxvcDpbXSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6YyYmZ3QuZ2V0Q2VudGVyUG9zKGMsbCl9KSxjfXVwZGF0YU9wdFNlcnZpY2UoZSl7aWYoIXRoaXMud29ya0lkKXJldHVybjtjb25zdCB0PXRoaXMud29ya0lkLnRvU3RyaW5nKCkse2ZvbnRDb2xvcjpyLGZvbnRCZ0NvbG9yOm4sYm9sZDpzLGl0YWxpYzpsLGxpbmVUaHJvdWdoOmMsdW5kZXJsaW5lOm99PWUsZj10aGlzLnZOb2Rlcy5nZXQodCk7aWYoIWYpcmV0dXJuO3ImJihmLm9wdC5mb250Q29sb3I9ciksbiYmKGYub3B0LmZvbnRCZ0NvbG9yPW4pLHMmJihmLm9wdC5ib2xkPXMpLGwmJihmLm9wdC5pdGFsaWM9bCksdmUoYykmJihmLm9wdC5saW5lVGhyb3VnaD1jKSx2ZShvKSYmKGYub3B0LnVuZGVybGluZT1vKSxuJiYoZi5vcHQuZm9udEJnQ29sb3I9biksdGhpcy5vbGRSZWN0PWYucmVjdDtjb25zdCB4PXRoaXMuZHJhdyh7d29ya0lkOnQsbGF5ZXI6dGhpcy5mdWxsTGF5ZXIsaXNEcmF3TGFiZWw6ITF9KTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyh0LHtyZWN0Ongsb3A6W10sb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOngmJmd0LmdldENlbnRlclBvcyh4LHRoaXMuZnVsbExheWVyKX0pLHh9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgZ2V0Rm9udFdpZHRoKGUpe2NvbnN0e2N0eDp0LG9wdDpyLHRleHQ6bn09ZSx7Ym9sZDpzLGl0YWxpYzpsLGZvbnRTaXplOmMsZm9udEZhbWlseTpvfT1yO3JldHVybiB0LmZvbnQ9YCR7c30gJHtsfSAke2N9cHggJHtvfWAsdC5tZWFzdXJlVGV4dChuKS53aWR0aH1zdGF0aWMgY3JlYXRlTGFiZWxzKGUsdCl7Y29uc3Qgcj1bXSxuPWUudGV4dC5zcGxpdCgiLCIpLHM9bi5sZW5ndGg7Zm9yKGxldCBsPTA7bDxzO2wrKyl7Y29uc3QgYz1uW2xdLHtmb250U2l6ZTpvLGxpbmVIZWlnaHQ6Zixib2xkOngsdGV4dEFsaWduOmcsaXRhbGljOnksYm94U2l6ZTptLGZvbnRGYW1pbHk6VCx2ZXJ0aWNhbEFsaWduOk8sZm9udENvbG9yOnYsdW5kZXJsaW5lOlAsbGluZVRocm91Z2g6aX09ZSx1PWZ8fG8qMS4yLGE9dCYmdC5wYXJlbnQuY2FudmFzLmdldENvbnRleHQoIjJkIiksaD1hJiZPZS5nZXRGb250V2lkdGgoe3RleHQ6YyxvcHQ6ZSxjdHg6YSx3b3JsZFNjYWxpbmc6dC53b3JsZFNjYWxpbmd9KTtpZihoKXtjb25zdCBiPXthbmNob3I6WzAsLjVdLHRleHQ6Yyxmb250U2l6ZTpvLGxpbmVIZWlnaHQ6dSxmb250RmFtaWx5OlQsZm9udFdlaWdodDp4LGZpbGxDb2xvcjp2LHRleHRBbGlnbjpnLGZvbnRTdHlsZTp5LG5hbWU6bC50b1N0cmluZygpLGNsYXNzTmFtZToibGFiZWwifSxFPVswLDBdO2lmKE89PT0ibWlkZGxlIil7Y29uc3QgTD0ocy0xKS8yO0VbMV09KGwtTCkqdX1nPT09ImxlZnQiJiYoRVswXT1tJiYtbVswXS8yKzV8fDApLGIucG9zPUU7Y29uc3QgQT1uZXcgU2goYik7aWYoci5wdXNoKEEpLFApe2NvbnN0IEw9e25vcm1hbGl6ZTohMSxwb3M6W2IucG9zWzBdLGIucG9zWzFdK28vMl0sbGluZVdpZHRoOjIscG9pbnRzOlswLDAsaCwwXSxzdHJva2VDb2xvcjp2LG5hbWU6YCR7bH1fdW5kZXJsaW5lYCxjbGFzc05hbWU6InVuZGVybGluZSJ9LFM9bmV3IHF0KEwpO3IucHVzaChTKX1pZihpKXtjb25zdCBMPXtub3JtYWxpemU6ITEscG9zOmIucG9zLGxpbmVXaWR0aDoyLHBvaW50czpbMCwwLGgsMF0sc3Ryb2tlQ29sb3I6dixuYW1lOmAke2x9X2xpbmVUaHJvdWdoYCxjbGFzc05hbWU6ImxpbmVUaHJvdWdoIn0sUz1uZXcgcXQoTCk7ci5wdXNoKFMpfX19cmV0dXJuIHJ9c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpuLHRhcmdldE5vZGU6c309ZSx7Zm9udEJnQ29sb3I6bCxmb250Q29sb3I6Yyx0cmFuc2xhdGU6byxib3g6Zixib3hTY2FsZTp4LGJveFRyYW5zbGF0ZTpnLHdvcmtTdGF0ZTp5LGJvbGQ6bSxpdGFsaWM6VCxsaW5lVGhyb3VnaDpPLHVuZGVybGluZTp2LGZvbnRTaXplOlB9PXIsaT1zJiZZdChzKXx8bi5nZXQodC5uYW1lKTtpZighaSlyZXR1cm47Y29uc3QgdT10LnBhcmVudDtpZighdSlyZXR1cm47Y29uc3QgYT1pLm9wdDtpZihhLndvcmtTdGF0ZT15LGMmJmEuZm9udENvbG9yJiYoYS5mb250Q29sb3I9YyksbCYmYS5mb250QmdDb2xvciYmKGEuZm9udEJnQ29sb3I9bCksbSYmKGEuYm9sZD1tKSxUJiYoYS5pdGFsaWM9VCksdmUoTykmJihhLmxpbmVUaHJvdWdoPU8pLHZlKHYpJiYoYS51bmRlcmxpbmU9diksUCl7Y29uc3R7Ym94U2l6ZTpofT1hLGI9UC9hLmZvbnRTaXplLEU9aCYmW2hbMF0qYixoWzFdKmJdO0UmJihhLmJveFNpemU9RSxhLmZvbnRTaXplPVAsaS5yZWN0PXt4OmkucmVjdC54LHk6aS5yZWN0LnksdzpFWzBdLGg6RVsxXX0pfWlmKGYmJmcmJngpe2NvbnN0e2JveFNpemU6aCxmb250U2l6ZTpifT1hLEU9aS5yZWN0LEE9YW4oZ2goRSx4KSxnKTthLmJveFBvaW50PUEmJlsoQS54LXUud29ybGRQb3NpdGlvblswXSkvdS53b3JsZFNjYWxpbmdbMF0sKEEueS11LndvcmxkUG9zaXRpb25bMV0pL3Uud29ybGRTY2FsaW5nWzFdXSxhLmJveFNpemU9aCYmW2hbMF0qeFswXSxoWzFdKnhbMV1dLGEuZm9udFNpemU9YiYmYip4WzBdfWVsc2UgbyYmYS5ib3hQb2ludCYmKGEuYm94UG9pbnQ9W2EuYm94UG9pbnRbMF0rb1swXSxhLmJveFBvaW50WzFdK29bMV1dLGkuY2VudGVyUG9zPVtpLmNlbnRlclBvc1swXStvWzBdLGkuY2VudGVyUG9zWzFdK29bMV1dLGkucmVjdD17eDppLnJlY3QueCtvWzBdLHk6aS5yZWN0Lnkrb1sxXSx3OmkucmVjdC53LGg6aS5yZWN0Lmh9KTtyZXR1cm4gaSYmbi5zZXRJbmZvKHQubmFtZSxpKSxpPT1udWxsP3ZvaWQgMDppLnJlY3R9c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCByPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYocil7Y29uc3Qgbj1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3Iobi54KSx5Ok1hdGguZmxvb3Iobi55KSx3Ok1hdGguZmxvb3Iobi53aWR0aCksaDpNYXRoLmZsb29yKG4uaGVpZ2h0KX19fX1mdW5jdGlvbiBQbihkKXtzd2l0Y2goZCl7Y2FzZSB2dC5BcnJvdzpyZXR1cm4gZ247Y2FzZSB2dC5QZW5jaWw6cmV0dXJuIGhuO2Nhc2UgdnQuU3RyYWlnaHQ6cmV0dXJuIE9uO2Nhc2UgdnQuRWxsaXBzZTpyZXR1cm4gbW47Y2FzZSB2dC5Qb2x5Z29uOmNhc2UgdnQuVHJpYW5nbGU6cmV0dXJuIHluO2Nhc2UgdnQuU3RhcjpjYXNlIHZ0LlJob21idXM6cmV0dXJuIHBuO2Nhc2UgdnQuUmVjdGFuZ2xlOnJldHVybiB2bjtjYXNlIHZ0LlNwZWVjaEJhbGxvb246cmV0dXJuIHhuO2Nhc2UgdnQuVGV4dDpyZXR1cm4gT2U7Y2FzZSB2dC5MYXNlclBlbjpyZXR1cm4gZG47Y2FzZSB2dC5FcmFzZXI6cmV0dXJuIFh0O2Nhc2UgdnQuU2VsZWN0b3I6cmV0dXJuIFJ0fX1mdW5jdGlvbiBibihkKXtjb25zdHt0b29sc1R5cGU6ZSwuLi50fT1kO3N3aXRjaChlKXtjYXNlIHZ0LkFycm93OnJldHVybiBuZXcgZ24odCk7Y2FzZSB2dC5QZW5jaWw6cmV0dXJuIG5ldyBobih0KTtjYXNlIHZ0LlN0cmFpZ2h0OnJldHVybiBuZXcgT24odCk7Y2FzZSB2dC5FbGxpcHNlOnJldHVybiBuZXcgbW4odCk7Y2FzZSB2dC5Qb2x5Z29uOmNhc2UgdnQuVHJpYW5nbGU6cmV0dXJuIG5ldyB5bih0KTtjYXNlIHZ0LlN0YXI6Y2FzZSB2dC5SaG9tYnVzOnJldHVybiBuZXcgcG4odCk7Y2FzZSB2dC5SZWN0YW5nbGU6cmV0dXJuIG5ldyB2bih0KTtjYXNlIHZ0LlNwZWVjaEJhbGxvb246cmV0dXJuIG5ldyB4bih0KTtjYXNlIHZ0LlRleHQ6cmV0dXJuIG5ldyBPZSh0KTtjYXNlIHZ0Lkxhc2VyUGVuOnJldHVybiBuZXcgZG4odCk7Y2FzZSB2dC5FcmFzZXI6cmV0dXJuIG5ldyBYdCh0KTtjYXNlIHZ0LlNlbGVjdG9yOnJldHVybiBuZXcgUnQodCk7ZGVmYXVsdDpyZXR1cm59fWNsYXNzIEJoIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuWkluZGV4QWN0aXZlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm59PWU7aWYodD09PXV0LlVwZGF0ZU5vZGUmJnI9PT1QdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBjLG8sZix4LGc7Y29uc3R7d29ya0lkOnQsaXNBY3RpdmVaSW5kZXg6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm59PWU7aWYodCE9PVJ0LnNlbGVjdG9ySWQpcmV0dXJuO2NvbnN0IHM9KGM9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpjLndvcmtTaGFwZXMuZ2V0KFJ0LnNlbGVjdG9ySWQpO2lmKCFzKXJldHVybjtjb25zdCBsPXMub2xkU2VsZWN0UmVjdDtpZihyJiZsJiZ0aGlzLmxvY2FsV29yayl7Y29uc3QgeT1uZXcgU2V0O2lmKHRoaXMubG9jYWxXb3JrLnZOb2Rlcy5jdXJOb2RlTWFwLmZvckVhY2goKG0sVCk9Pnt4ZShsLG0ucmVjdCkmJnkuYWRkKFQpfSkseS5zaXplKXtjb25zdCBtPVtdO3kuZm9yRWFjaChUPT57dmFyIE87KE89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxPLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShUKS5mb3JFYWNoKHY9Pnt2YXIgaSx1O2NvbnN0IFA9di5jbG9uZU5vZGUoITApO05lKHYpJiZQLnNlYWwoKSwodT0oaT10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOmkuZHJhd0xheWVyKSE9bnVsbCYmdS5nZXRFbGVtZW50c0J5TmFtZShUKS5sZW5ndGh8fG0ucHVzaChQKX0pfSksbS5sZW5ndGgmJigobz10aGlzLmxvY2FsV29yay5kcmF3TGF5ZXIpPT1udWxsfHxvLmFwcGVuZCguLi5tKSl9fWVsc2UoeD0oZj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOmYuZHJhd0xheWVyKT09bnVsbHx8eC5jaGlsZHJlbi5maWx0ZXIoeT0+e3ZhciBtO3JldHVybiEoKG09cy5zZWxlY3RJZHMpIT1udWxsJiZtLmluY2x1ZGVzKHkubmFtZSkpfSkuZm9yRWFjaCh5PT55LnJlbW92ZSgpKTtuJiYoKGc9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxnLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmwsZHJhd0NhbnZhczp4dC5TZWxlY3RvcixjbGVhckNhbnZhczp4dC5TZWxlY3Rvcixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMubG9jYWxXb3JrLnZpZXdJZH1dLHNwOlt7dHlwZTp1dC5TZWxlY3Qsc2VsZWN0SWRzOnMuc2VsZWN0SWRzLG9wdDpzLmdldFdvcmtPcHRpb25zKCksc2VsZWN0UmVjdDpsLHN0cm9rZUNvbG9yOnMuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOnMuZmlsbENvbG9yLHdpbGxTeW5jU2VydmljZTohMSxpc1N5bmM6ITB9XX0pKX19Y2xhc3MgV2ggZXh0ZW5kcyBRdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5Db3B5Tm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT11dC5GdWxsV29yayYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIHI7Y29uc3R7d29ya0lkOnR9PWU7dCYmKChyPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8ci5jb25zdW1lRnVsbChlKSl9fWNsYXNzIEZoIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0Q29sb3JOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOnN9PWU7aWYodD09PXV0LlVwZGF0ZU5vZGUmJnI9PT1QdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkscyYmc2V0VGltZW91dCgoKT0+e3ZhciBsOyhsPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8bC5fcG9zdCh7c3A6W3t0eXBlOnV0Lk5vbmUsdW5kb1RpY2tlcklkOnN9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIG87Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKG89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxvLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfSkpfX1jbGFzcyBVaCBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0LlpJbmRleE5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bn09ZTtpZih0PT09dXQuVXBkYXRlTm9kZSYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGM7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKGM9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxjLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsfSkpfX1jbGFzcyB6aCBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0LlRyYW5zbGF0ZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6c309ZTtpZih0PT09dXQuVXBkYXRlTm9kZSYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxzJiZzZXRUaW1lb3V0KCgpPT57dmFyIGw7KGw9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxsLl9wb3N0KHtzcDpbe3R5cGU6dXQuTm9uZSx1bmRvVGlja2VySWQ6c31dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgZjtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpzLHdpbGxTZXJpYWxpemVEYXRhOmwsdGV4dFVwZGF0ZUZvcldva2VyOmMsZW1pdEV2ZW50VHlwZTpvfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKGY9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxmLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLGlzU3luYzohMCx0ZXh0VXBkYXRlRm9yV29rZXI6YyxlbWl0RXZlbnRUeXBlOm99KSl9fWNsYXNzICRoIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuRGVsZXRlTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT11dC5SZW1vdmVOb2RlKXtpZihyPT09UHQuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwO2lmKHI9PT1QdC5TZXJ2aWNlJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpLCEwfX1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7aWYoIXRoaXMubG9jYWxXb3JrKXJldHVybjtjb25zdHtyZW1vdmVJZHM6dCx3aWxsUmVmcmVzaDpyLHdpbGxTeW5jU2VydmljZTpuLHZpZXdJZDpzfT1lO2lmKCEodCE9bnVsbCYmdC5sZW5ndGgpKXJldHVybjtsZXQgbDtjb25zdCBjPVtdLG89W10sZj1bXTtmb3IoY29uc3QgeCBvZiB0KXtpZih4PT09UnQuc2VsZWN0b3JJZCl7Y29uc3QgeT10aGlzLmxvY2FsV29yay53b3JrU2hhcGVzLmdldChSdC5zZWxlY3RvcklkKSxtPXkuc2VsZWN0SWRzJiZbLi4ueS5zZWxlY3RJZHNdfHxbXTtmb3IoY29uc3QgTyBvZiBtKXtpZih0aGlzLmxvY2FsV29yay52Tm9kZXMuZ2V0KE8pKXtjb25zdCBQPXRoaXMuY29tbWFuZERlbGV0ZVRleHQoTyk7UCYmYy5wdXNoKFApfWw9YnQobCx0aGlzLmxvY2FsV29yay5yZW1vdmVOb2RlKE8pKSxmLnB1c2goTyl9Y29uc3QgVD15PT1udWxsP3ZvaWQgMDp5LnVwZGF0ZVNlbGVjdElkcyhbXSk7bD1idChsLFQuYmdSZWN0KSx0aGlzLmxvY2FsV29yay5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShSdC5zZWxlY3RvcklkKSx0aGlzLmxvY2FsV29yay53b3JrU2hhcGVzLmRlbGV0ZShSdC5zZWxlY3RvcklkKSxjLnB1c2goe3R5cGU6dXQuU2VsZWN0LHNlbGVjdElkczpbXSx3aWxsU3luY1NlcnZpY2U6bn0pO2NvbnRpbnVlfWNvbnN0IGc9dGhpcy5jb21tYW5kRGVsZXRlVGV4dCh4KTtnJiZjLnB1c2goZyksbD1idChsLHRoaXMubG9jYWxXb3JrLnJlbW92ZU5vZGUoeCkpLGYucHVzaCh4KX1uJiZjLnB1c2goe3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6Zix1bmRvVGlja2VySWQ6ZS51bmRvVGlja2VySWR9KSxsJiZyJiZvLnB1c2goe3JlY3Q6bCxkcmF3Q2FudmFzOnh0LkJnLGNsZWFyQ2FudmFzOnh0LkJnLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCx2aWV3SWQ6c30pLChvLmxlbmd0aHx8Yy5sZW5ndGgpJiZ0aGlzLmxvY2FsV29yay5fcG9zdCh7cmVuZGVyOm8sc3A6Y30pfWNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpe3RoaXMuc2VydmljZVdvcmsmJnRoaXMuc2VydmljZVdvcmsucmVtb3ZlU2VsZWN0V29yayhlKX1jb21tYW5kRGVsZXRlVGV4dChlKXt2YXIgcjtjb25zdCB0PShyPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6ci52Tm9kZXMuZ2V0KGUpO2lmKHQmJnQudG9vbHNUeXBlPT09dnQuVGV4dClyZXR1cm57dHlwZTp1dC5UZXh0VXBkYXRlLHRvb2xzVHlwZTp2dC5UZXh0LHdvcmtJZDplLGRhdGFUeXBlOlB0LkxvY2FsfX19Y2xhc3MgR2ggZXh0ZW5kcyBRdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5TY2FsZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6c309ZTtpZih0PT09dXQuVXBkYXRlTm9kZSYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxzJiZzZXRUaW1lb3V0KCgpPT57dmFyIGw7KGw9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxsLl9wb3N0KHtzcDpbe3R5cGU6dXQuTm9uZSx1bmRvVGlja2VySWQ6c31dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgbztjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpzLHdpbGxTZXJpYWxpemVEYXRhOmwsdGV4dFVwZGF0ZUZvcldva2VyOmN9PWU7dD09PVJ0LnNlbGVjdG9ySWQmJnImJigobz10aGlzLmxvY2FsV29yayk9PW51bGx8fG8udXBkYXRlU2VsZWN0b3Ioe3VwZGF0ZVNlbGVjdG9yT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpzLGVtaXRFdmVudFR5cGU6dGhpcy5lbWl0RXZlbnRUeXBlLHdpbGxTZXJpYWxpemVEYXRhOmwsaXNTeW5jOiEwLHRleHRVcGRhdGVGb3JXb2tlcjpjfSkpfX1jbGFzcyBLaCBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0LlJvdGF0ZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6c309ZTtpZih0PT09dXQuVXBkYXRlTm9kZSYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxzJiZzZXRUaW1lb3V0KCgpPT57dmFyIGw7KGw9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxsLl9wb3N0KHtzcDpbe3R5cGU6dXQuTm9uZSx1bmRvVGlja2VySWQ6c31dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgbztjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpzLHdpbGxTZXJpYWxpemVEYXRhOmwsZW1pdEV2ZW50VHlwZTpjfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKG89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxvLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLGVtaXRFdmVudFR5cGU6Yyxpc1N5bmM6ITB9KSl9fWNsYXNzIEhoIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0Rm9udFN0eWxlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOnN9PWU7aWYodD09PXV0LlVwZGF0ZU5vZGUmJnI9PT1QdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkscyYmc2V0VGltZW91dCgoKT0+e3ZhciBsOyhsPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8bC5fcG9zdCh7c3A6W3t0eXBlOnV0Lk5vbmUsdW5kb1RpY2tlcklkOnN9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIG87Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKG89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxvLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfSkpfX1jbGFzcyBWaCBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0LlNldFBvaW50fSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOnN9PWU7aWYodD09PXV0LlVwZGF0ZU5vZGUmJnI9PT1QdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkscyYmc2V0VGltZW91dCgoKT0+e3ZhciBsOyhsPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8bC5fcG9zdCh7c3A6W3t0eXBlOnV0Lk5vbmUsdW5kb1RpY2tlcklkOnN9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIG87Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKG89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxvLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyxlbWl0RXZlbnRUeXBlOnRoaXMuZW1pdEV2ZW50VHlwZSx3aWxsU2VyaWFsaXplRGF0YTpsLGlzU3luYzohMCx0ZXh0VXBkYXRlRm9yV29rZXI6Y30pKX19Y2xhc3MgWWh7Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImJ1aWxkZXJzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMuYnVpbGRlcnM9bmV3IE1hcChlLm1hcCh0PT5bdCx0aGlzLmJ1aWxkKHQpXSkpfWJ1aWxkKGUpe3N3aXRjaChlKXtjYXNlIEN0LlRyYW5zbGF0ZU5vZGU6cmV0dXJuIG5ldyB6aDtjYXNlIEN0LlpJbmRleE5vZGU6cmV0dXJuIG5ldyBVaDtjYXNlIEN0LlpJbmRleEFjdGl2ZTpyZXR1cm4gbmV3IEJoO2Nhc2UgQ3QuQ29weU5vZGU6cmV0dXJuIG5ldyBXaDtjYXNlIEN0LlNldENvbG9yTm9kZTpyZXR1cm4gbmV3IEZoO2Nhc2UgQ3QuRGVsZXRlTm9kZTpyZXR1cm4gbmV3ICRoO2Nhc2UgQ3QuU2NhbGVOb2RlOnJldHVybiBuZXcgR2g7Y2FzZSBDdC5Sb3RhdGVOb2RlOnJldHVybiBuZXcgS2g7Y2FzZSBDdC5TZXRGb250U3R5bGU6cmV0dXJuIG5ldyBIaDtjYXNlIEN0LlNldFBvaW50OnJldHVybiBuZXcgVmh9fXJlZ2lzdGVyRm9yV29ya2VyKGUsdCl7cmV0dXJuIHRoaXMuYnVpbGRlcnMuZm9yRWFjaChyPT57ciYmci5yZWdpc3RlckZvcldvcmtlcihlLHQpfSksdGhpc31jb25zdW1lRm9yV29ya2VyKGUpe2Zvcihjb25zdCB0IG9mIHRoaXMuYnVpbGRlcnMudmFsdWVzKCkpaWYodCE9bnVsbCYmdC5jb25zdW1lKGUpKXJldHVybiEwO3JldHVybiExfX1jbGFzcyBYaHtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NlbmUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NlbmVQYXRoIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidGFyZ2V0Tm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksdGhpcy52aWV3SWQ9ZSx0aGlzLnNjZW5lPXR9aW5pdChlLHQpe3RoaXMuZnVsbExheWVyPWUsdGhpcy5kcmF3TGF5ZXI9dH1nZXQoZSl7cmV0dXJuIHRoaXMuY3VyTm9kZU1hcC5nZXQoZSl9aGFzUmVuZGVyTm9kZXMoKXtsZXQgZT0hMTtmb3IoY29uc3QgdCBvZiB0aGlzLmN1ck5vZGVNYXAudmFsdWVzKCkpY24odC50b29sc1R5cGUpJiYoZT0hMCk7cmV0dXJuIGV9aGFzKGUpe3RoaXMuY3VyTm9kZU1hcC5oYXMoZSl9c2V0SW5mbyhlLHQpe2NvbnN0IHI9dGhpcy5jdXJOb2RlTWFwLmdldChlKXx8e25hbWU6ZSxyZWN0OnQucmVjdH07dC5yZWN0JiYoci5yZWN0PVl0KHQucmVjdCkpLHQub3AmJihyLm9wPVl0KHQub3ApKSx0LmNhblJvdGF0ZSYmKHIuY2FuUm90YXRlPXQuY2FuUm90YXRlKSx0LnNjYWxlVHlwZSYmKHIuc2NhbGVUeXBlPXQuc2NhbGVUeXBlKSx0Lm9wdCYmKHIub3B0PVl0KHQub3B0KSksdC50b29sc1R5cGUmJihyLnRvb2xzVHlwZT10LnRvb2xzVHlwZSksdC5jZW50ZXJQb3MmJihyLmNlbnRlclBvcz1ZdCh0LmNlbnRlclBvcykpLHIucmVjdD90aGlzLmN1ck5vZGVNYXAuc2V0KGUscik6dGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShlKX1kZWxldGUoZSl7dGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShlKX1jbGVhcigpe3RoaXMuY3VyTm9kZU1hcC5jbGVhcigpLHRoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGg9MH1nZXRSZWN0SW50ZXJzZWN0UmFuZ2UoZSl7bGV0IHQ7Y29uc3Qgcj1uZXcgTWFwO3JldHVybiB0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaCgobixzKT0+e3hlKGUsbi5yZWN0KSYmKHQ9YnQodCxuLnJlY3QpLHIuc2V0KHMsbikpfSkse3JlY3RSYW5nZTp0LG5vZGVSYW5nZTpyfX1nZXROb2RlUmVjdEZvcm1TaGFwZShlLHQpe2NvbnN0IHI9UG4odC50b29sc1R5cGUpO2xldCBuPXRoaXMuZnVsbExheWVyJiYocj09bnVsbD92b2lkIDA6ci5nZXRSZWN0RnJvbUxheWVyKHRoaXMuZnVsbExheWVyLGUpKTtyZXR1cm4hbiYmdGhpcy5kcmF3TGF5ZXImJihuPXI9PW51bGw/dm9pZCAwOnIuZ2V0UmVjdEZyb21MYXllcih0aGlzLmRyYXdMYXllcixlKSksbn11cGRhdGVOb2Rlc1JlY3QoKXt0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaCgoZSx0KT0+e2NvbnN0IHI9dGhpcy5nZXROb2RlUmVjdEZvcm1TaGFwZSh0LGUpO3I/KGUucmVjdD1yLHRoaXMuY3VyTm9kZU1hcC5zZXQodCxlKSk6dGhpcy5jdXJOb2RlTWFwLmRlbGV0ZSh0KX0pfWNvbWJpbmVJbnRlcnNlY3RSZWN0KGUpe2xldCB0PWU7cmV0dXJuIHRoaXMuY3VyTm9kZU1hcC5mb3JFYWNoKHI9Pnt4ZSh0LHIucmVjdCkmJih0PWJ0KHQsci5yZWN0KSl9KSx0fXNldFRhcmdldCgpe3JldHVybiB0aGlzLnRhcmdldE5vZGVNYXAucHVzaChZdCh0aGlzLmN1ck5vZGVNYXApKSx0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoLTF9Z2V0TGFzdFRhcmdldCgpe3JldHVybiB0aGlzLnRhcmdldE5vZGVNYXBbdGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aC0xXX1kZWxldGVMYXN0VGFyZ2V0KCl7dGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aD10aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoLTF9Z2V0VGFyZ2V0KGUpe3JldHVybiB0aGlzLnRhcmdldE5vZGVNYXBbZV19ZGVsZXRlVGFyZ2V0KGUpe3RoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGg9ZX19Y2xhc3MgU257Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidmlld0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Tm9kZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHByIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW1lcmFPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NlbmUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLnZpZXdJZD1lLHRoaXMub3B0PXQsdGhpcy5kcHI9dC5kcHIsdGhpcy5zY2VuZT10aGlzLmNyZWF0ZVNjZW5lKHQub2Zmc2NyZWVuQ2FudmFzT3B0KSx0aGlzLmZ1bGxMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJmdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZTp0aGlzLnZpZXdJZD09PSJtYWluVmlldyI/NmUzOjNlM30pLHRoaXMudk5vZGVzPW5ldyBYaChlLHRoaXMuc2NlbmUpfW9uKGUpe2NvbnN0e21zZ1R5cGU6dCx0b29sc1R5cGU6cixvcHQ6bix3b3JrSWQ6cyx3b3JrU3RhdGU6bCxkYXRhVHlwZTpjfT1lO3N3aXRjaCh0KXtjYXNlIHV0LkRlc3Ryb3k6dGhpcy5kZXN0cm95KCk7YnJlYWs7Y2FzZSB1dC5DbGVhcjp0aGlzLmNsZWFyQWxsKCk7YnJlYWs7Y2FzZSB1dC5VcGRhdGVUb29sczppZihyJiZuKXtjb25zdCBvPXt0b29sc1R5cGU6cix0b29sc09wdDpufTt0aGlzLmxvY2FsV29yay5zZXRUb29sc09wdChvKX1icmVhaztjYXNlIHV0LkNyZWF0ZVdvcms6cyYmbiYmKCF0aGlzLmxvY2FsV29yay5nZXRUbXBXb3JrU2hhcGVOb2RlKCkmJnImJnRoaXMuc2V0VG9vbHNPcHQoe3Rvb2xzVHlwZTpyLHRvb2xzT3B0Om59KSx0aGlzLnNldFdvcmtPcHQoe3dvcmtJZDpzLHRvb2xzT3B0Om59KSk7YnJlYWs7Y2FzZSB1dC5EcmF3V29yazpsPT09SXQuRG9uZSYmYz09PVB0LkxvY2FsP3RoaXMuY29uc3VtZURyYXdBbGwoYyxlKTp0aGlzLmNvbnN1bWVEcmF3KGMsZSk7YnJlYWt9fXVwZGF0ZVNjZW5lKGUpe3RoaXMuc2NlbmUuYXR0cih7Li4uZX0pO2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWU7dGhpcy5zY2VuZS5jb250YWluZXIud2lkdGg9dCx0aGlzLnNjZW5lLmNvbnRhaW5lci5oZWlnaHQ9cix0aGlzLnNjZW5lLndpZHRoPXQsdGhpcy5zY2VuZS5oZWlnaHQ9cix0aGlzLnVwZGF0ZUxheWVyKHt3aWR0aDp0LGhlaWdodDpyfSl9dXBkYXRlTGF5ZXIoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZTt0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLmZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHIpLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuZHJhd0xheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsciksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJzaXplIixbdCxyXSksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllciYmKHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixyKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSl9Y3JlYXRlU2NlbmUoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZSxuPW5ldyBPZmZzY3JlZW5DYW52YXModCxyKTtyZXR1cm4gbmV3IE1oKHtjb250YWluZXI6bixkaXNwbGF5UmF0aW86dGhpcy5kcHIsZGVwdGg6ITEsZGVzeW5jaHJvbml6ZWQ6ITAsLi4uZX0pfWNyZWF0ZUxheWVyKGUsdCxyKXtjb25zdHt3aWR0aDpuLGhlaWdodDpzfT1yLGw9YG9mZnNjcmVlbi0ke2V9YCxjPXQubGF5ZXIobCxyKSxvPW5ldyBlZSh7YW5jaG9yOlsuNSwuNV0scG9zOltuKi41LHMqLjVdLHNpemU6W24sc10sbmFtZToidmlld3BvcnQiLGlkOmV9KTtyZXR1cm4gYy5hcHBlbmQobyksb31jbGVhckFsbCgpe3ZhciBlO3RoaXMuZnVsbExheWVyJiYodGhpcy5mdWxsTGF5ZXIucGFyZW50LmNoaWxkcmVuLmZvckVhY2godD0+e3QubmFtZSE9PSJ2aWV3cG9ydCImJnQucmVtb3ZlKCl9KSx0aGlzLmZ1bGxMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpKSx0aGlzLmRyYXdMYXllciYmKHRoaXMuZHJhd0xheWVyLnBhcmVudC5jaGlsZHJlbi5mb3JFYWNoKHQ9Pnt0Lm5hbWUhPT0idmlld3BvcnQiJiZ0LnJlbW92ZSgpfSksdGhpcy5kcmF3TGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSksdGhpcy5sb2NhbFdvcmsuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKSwoZT10aGlzLnNlcnZpY2VXb3JrKT09bnVsbHx8ZS5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpfXNldFRvb2xzT3B0KGUpe3RoaXMubG9jYWxXb3JrLnNldFRvb2xzT3B0KGUpfXNldFdvcmtPcHQoZSl7Y29uc3R7d29ya0lkOnQsdG9vbHNPcHQ6cn09ZTt0JiZyJiZ0aGlzLmxvY2FsV29yay5zZXRXb3JrT3B0aW9ucyh0LHIpfWRlc3Ryb3koKXt2YXIgZTt0aGlzLnZOb2Rlcy5jbGVhcigpLHRoaXMuc2NlbmUucmVtb3ZlKCksdGhpcy5mdWxsTGF5ZXIucmVtb3ZlKCksdGhpcy5sb2NhbFdvcmsuZGVzdHJveSgpLChlPXRoaXMuc2VydmljZVdvcmspPT1udWxsfHxlLmRlc3Ryb3koKX19Y2xhc3MgTW57Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZpZXdJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Tm9kZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBXb3JrU2hhcGVOb2RlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcE9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVTdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZWZmZWN0V29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdDb3VudCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSx0aGlzLnZpZXdJZD1lLnZpZXdJZCx0aGlzLnZOb2Rlcz1lLnZOb2Rlcyx0aGlzLmZ1bGxMYXllcj1lLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcj1lLmRyYXdMYXllcix0aGlzLl9wb3N0PWUucG9zdH1kZXN0cm95KCl7dGhpcy53b3JrU2hhcGVTdGF0ZS5jbGVhcigpLHRoaXMud29ya1NoYXBlcy5jbGVhcigpfWdldFdvcmtTaGFwZShlKXtyZXR1cm4gdGhpcy53b3JrU2hhcGVzLmdldChlKX1nZXRUbXBXb3JrU2hhcGVOb2RlKCl7cmV0dXJuIHRoaXMudG1wV29ya1NoYXBlTm9kZX1zZXRUbXBXb3JrSWQoZSl7aWYoZSYmdGhpcy50bXBXb3JrU2hhcGVOb2RlKXt0aGlzLnRtcFdvcmtTaGFwZU5vZGUuc2V0V29ya0lkKGUpLHRoaXMud29ya1NoYXBlcy5zZXQoZSx0aGlzLnRtcFdvcmtTaGFwZU5vZGUpLHRoaXMudG1wT3B0JiZ0aGlzLnNldFRvb2xzT3B0KHRoaXMudG1wT3B0KTtyZXR1cm59fXNldFRtcFdvcmtPcHRpb25zKGUpe3ZhciB0Oyh0PXRoaXMudG1wV29ya1NoYXBlTm9kZSk9PW51bGx8fHQuc2V0V29ya09wdGlvbnMoZSl9c2V0V29ya09wdGlvbnMoZSx0KXt2YXIgbjt0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfHx0aGlzLnNldFRtcFdvcmtJZChlKSwobj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbHx8bi5zZXRXb3JrT3B0aW9ucyh0KX1jcmVhdGVXb3JrU2hhcGVOb2RlKGUpe3JldHVybiBibih7Li4uZSx2Tm9kZXM6dGhpcy52Tm9kZXMsZnVsbExheWVyOnRoaXMuZnVsbExheWVyLGRyYXdMYXllcjp0aGlzLmRyYXdMYXllcn0pfXNldFRvb2xzT3B0KGUpe3ZhciB0LHI7KCh0PXRoaXMudG1wT3B0KT09bnVsbD92b2lkIDA6dC50b29sc1R5cGUpIT09ZS50b29sc1R5cGUmJihyPXRoaXMudG1wT3B0KSE9bnVsbCYmci50b29sc1R5cGUmJnRoaXMuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKSx0aGlzLnRtcE9wdD1lLHRoaXMudG1wV29ya1NoYXBlTm9kZT10aGlzLmNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl9Y2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoZSl7dmFyIHQ7KHQ9dGhpcy5nZXRXb3JrU2hhcGUoZSkpPT1udWxsfHx0LmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlKSx0aGlzLndvcmtTaGFwZVN0YXRlLmRlbGV0ZShlKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKGU9PmUuY2xlYXJUbXBQb2ludHMoKSksdGhpcy53b3JrU2hhcGVzLmNsZWFyKCksdGhpcy53b3JrU2hhcGVTdGF0ZS5jbGVhcigpfXNldEZ1bGxXb3JrKGUpe2NvbnN0e3dvcmtJZDp0LG9wdDpyLHRvb2xzVHlwZTpufT1lO2lmKHQmJnImJm4pe2NvbnN0IHM9dCYmdGhpcy53b3JrU2hhcGVzLmdldCh0KXx8dGhpcy5jcmVhdGVXb3JrU2hhcGVOb2RlKHt0b29sc09wdDpyLHRvb2xzVHlwZTpufSk7cmV0dXJuIHM/KHMuc2V0V29ya0lkKHQpLHRoaXMud29ya1NoYXBlcy5zZXQodCxzKSxzKTp2b2lkIDB9fX12YXIgSmg9VnQsWmg9ZnVuY3Rpb24oKXtyZXR1cm4gSmguRGF0ZS5ub3coKX0sUWg9Wmgsa2g9L1xzLztmdW5jdGlvbiBxaChkKXtmb3IodmFyIGU9ZC5sZW5ndGg7ZS0tJiZraC50ZXN0KGQuY2hhckF0KGUpKTspO3JldHVybiBlfXZhciBfaD1xaCx0ZD1faCxlZD0vXlxzKy87ZnVuY3Rpb24gcmQoZCl7cmV0dXJuIGQmJmQuc2xpY2UoMCx0ZChkKSsxKS5yZXBsYWNlKGVkLCIiKX12YXIgbmQ9cmQsaWQ9cmUsc2Q9dGUsb2Q9IltvYmplY3QgU3ltYm9sXSI7ZnVuY3Rpb24gYWQoZCl7cmV0dXJuIHR5cGVvZiBkPT0ic3ltYm9sInx8c2QoZCkmJmlkKGQpPT1vZH12YXIgbGQ9YWQsY2Q9bmQsVG49X3QsdWQ9bGQsRW49TmFOLGZkPS9eWy0rXTB4WzAtOWEtZl0rJC9pLGhkPS9eMGJbMDFdKyQvaSxkZD0vXjBvWzAtN10rJC9pLGdkPXBhcnNlSW50O2Z1bmN0aW9uIG1kKGQpe2lmKHR5cGVvZiBkPT0ibnVtYmVyIilyZXR1cm4gZDtpZih1ZChkKSlyZXR1cm4gRW47aWYoVG4oZCkpe3ZhciBlPXR5cGVvZiBkLnZhbHVlT2Y9PSJmdW5jdGlvbiI/ZC52YWx1ZU9mKCk6ZDtkPVRuKGUpP2UrIiI6ZX1pZih0eXBlb2YgZCE9InN0cmluZyIpcmV0dXJuIGQ9PT0wP2Q6K2Q7ZD1jZChkKTt2YXIgdD1oZC50ZXN0KGQpO3JldHVybiB0fHxkZC50ZXN0KGQpP2dkKGQuc2xpY2UoMiksdD8yOjgpOmZkLnRlc3QoZCk/RW46K2R9dmFyIHZkPW1kLHBkPV90LHNyPVFoLEFuPXZkLHlkPSJFeHBlY3RlZCBhIGZ1bmN0aW9uIix4ZD1NYXRoLm1heCxPZD1NYXRoLm1pbjtmdW5jdGlvbiBQZChkLGUsdCl7dmFyIHIsbixzLGwsYyxvLGY9MCx4PSExLGc9ITEseT0hMDtpZih0eXBlb2YgZCE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgVHlwZUVycm9yKHlkKTtlPUFuKGUpfHwwLHBkKHQpJiYoeD0hIXQubGVhZGluZyxnPSJtYXhXYWl0ImluIHQscz1nP3hkKEFuKHQubWF4V2FpdCl8fDAsZSk6cyx5PSJ0cmFpbGluZyJpbiB0PyEhdC50cmFpbGluZzp5KTtmdW5jdGlvbiBtKGIpe3ZhciBFPXIsQT1uO3JldHVybiByPW49dm9pZCAwLGY9YixsPWQuYXBwbHkoQSxFKSxsfWZ1bmN0aW9uIFQoYil7cmV0dXJuIGY9YixjPXNldFRpbWVvdXQoUCxlKSx4P20oYik6bH1mdW5jdGlvbiBPKGIpe3ZhciBFPWItbyxBPWItZixMPWUtRTtyZXR1cm4gZz9PZChMLHMtQSk6TH1mdW5jdGlvbiB2KGIpe3ZhciBFPWItbyxBPWItZjtyZXR1cm4gbz09PXZvaWQgMHx8RT49ZXx8RTwwfHxnJiZBPj1zfWZ1bmN0aW9uIFAoKXt2YXIgYj1zcigpO2lmKHYoYikpcmV0dXJuIGkoYik7Yz1zZXRUaW1lb3V0KFAsTyhiKSl9ZnVuY3Rpb24gaShiKXtyZXR1cm4gYz12b2lkIDAseSYmcj9tKGIpOihyPW49dm9pZCAwLGwpfWZ1bmN0aW9uIHUoKXtjIT09dm9pZCAwJiZjbGVhclRpbWVvdXQoYyksZj0wLHI9bz1uPWM9dm9pZCAwfWZ1bmN0aW9uIGEoKXtyZXR1cm4gYz09PXZvaWQgMD9sOmkoc3IoKSl9ZnVuY3Rpb24gaCgpe3ZhciBiPXNyKCksRT12KGIpO2lmKHI9YXJndW1lbnRzLG49dGhpcyxvPWIsRSl7aWYoYz09PXZvaWQgMClyZXR1cm4gVChvKTtpZihnKXJldHVybiBjbGVhclRpbWVvdXQoYyksYz1zZXRUaW1lb3V0KFAsZSksbShvKX1yZXR1cm4gYz09PXZvaWQgMCYmKGM9c2V0VGltZW91dChQLGUpKSxsfXJldHVybiBoLmNhbmNlbD11LGguZmx1c2g9YSxofXZhciBiZD1QZCxTZD1iZCxNZD1fdCxUZD0iRXhwZWN0ZWQgYSBmdW5jdGlvbiI7ZnVuY3Rpb24gRWQoZCxlLHQpe3ZhciByPSEwLG49ITA7aWYodHlwZW9mIGQhPSJmdW5jdGlvbiIpdGhyb3cgbmV3IFR5cGVFcnJvcihUZCk7cmV0dXJuIE1kKHQpJiYocj0ibGVhZGluZyJpbiB0PyEhdC5sZWFkaW5nOnIsbj0idHJhaWxpbmciaW4gdD8hIXQudHJhaWxpbmc6biksU2QoZCxlLHtsZWFkaW5nOnIsbWF4V2FpdDplLHRyYWlsaW5nOm59KX12YXIgQWQ9RWQsQ249cGUoQWQpO2NsYXNzIENkIGV4dGVuZHMgTW57Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVVbml0VGltZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjYwMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb21iaW5lVGltZXJJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlZmZlY3RTZWxlY3ROb2RlRGF0YSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFcmFzZXJXb3JrcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFcmFzZXJSZW1vdmVOb2RlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFZmZlY3RXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q24odD0+e3RoaXMudk5vZGVzLmN1ck5vZGVNYXAuc2l6ZSYmKHRoaXMudk5vZGVzLnVwZGF0ZU5vZGVzUmVjdCgpLHRoaXMucmVSZW5kZXJTZWxlY3RvcigpKSx0JiZ0KCl9LDEwMCx7bGVhZGluZzohMX0pfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImJhdGNoRXJhc2VyQ29tYmluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkNuKCgpPT57Y29uc3QgdD10aGlzLnVwZGF0ZUJhdGNoRXJhc2VyQ29tYmluZU5vZGUodGhpcy5iYXRjaEVyYXNlcldvcmtzLHRoaXMuYmF0Y2hFcmFzZXJSZW1vdmVOb2Rlcyk7dGhpcy5iYXRjaEVyYXNlcldvcmtzLmNsZWFyKCksdGhpcy5iYXRjaEVyYXNlclJlbW92ZU5vZGVzLmNsZWFyKCksdC5sZW5ndGgmJnRoaXMuX3Bvc3Qoe3JlbmRlcjp0fSl9LDEwMCx7bGVhZGluZzohMX0pfSl9Y29uc3VtZURyYXcoZSx0KXtjb25zdHtvcDpyLHdvcmtJZDpufT1lO2lmKHIhPW51bGwmJnIubGVuZ3RoJiZuKXtjb25zdCBzPXRoaXMud29ya1NoYXBlcy5nZXQobik7aWYoIXMpcmV0dXJuO2NvbnN0IGw9cy50b29sc1R5cGU7aWYobD09PXZ0Lkxhc2VyUGVuKXJldHVybjtjb25zdCBjPXMuY29uc3VtZSh7ZGF0YTplLGlzRnVsbFdvcms6ITB9KTtzd2l0Y2gobCl7Y2FzZSB2dC5TZWxlY3RvcjpjLnR5cGU9PT11dC5TZWxlY3QmJihjLnNlbGVjdElkcyYmdC5ydW5SZXZlcnNlU2VsZWN0V29yayhjLnNlbGVjdElkcyksdGhpcy5kcmF3U2VsZWN0b3IoYywhMCkpO2JyZWFrO2Nhc2UgdnQuRXJhc2VyOmMhPW51bGwmJmMucmVjdCYmdGhpcy5kcmF3RXJhc2VyKGMpO2JyZWFrO2Nhc2UgdnQuQXJyb3c6Y2FzZSB2dC5TdHJhaWdodDpjYXNlIHZ0LkVsbGlwc2U6Y2FzZSB2dC5SZWN0YW5nbGU6Y2FzZSB2dC5TdGFyOmNhc2UgdnQuUG9seWdvbjpjYXNlIHZ0LlNwZWVjaEJhbGxvb246YyYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3UGVuY2lsKGMpKTticmVhaztjYXNlIHZ0LlBlbmNpbDp0aGlzLmNvbWJpbmVUaW1lcklkfHwodGhpcy5jb21iaW5lVGltZXJJZD1zZXRUaW1lb3V0KCgpPT57dGhpcy5jb21iaW5lVGltZXJJZD12b2lkIDAsdGhpcy5kcmF3UGVuY2lsQ29tYmluZShuKX0sTWF0aC5mbG9vcihzLmdldFdvcmtPcHRpb25zKCkuc3luY1VuaXRUaW1lfHx0aGlzLmNvbWJpbmVVbml0VGltZS8yKSkpLGMmJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd1BlbmNpbChjKSk7YnJlYWt9fX1jb25zdW1lRHJhd0FsbChlLHQpe3ZhciBzO3RoaXMuY29tYmluZVRpbWVySWQmJihjbGVhclRpbWVvdXQodGhpcy5jb21iaW5lVGltZXJJZCksdGhpcy5jb21iaW5lVGltZXJJZD12b2lkIDApO2NvbnN0e3dvcmtJZDpyLHVuZG9UaWNrZXJJZDpufT1lO2lmKHIpe24mJnNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3R5cGU6dXQuTm9uZSx1bmRvVGlja2VySWQ6bn1dfSl9LDApO2NvbnN0IGw9dGhpcy53b3JrU2hhcGVzLmdldChyKTtpZighbClyZXR1cm47Y29uc3QgYz1sLnRvb2xzVHlwZTtpZihjPT09dnQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IG89bC5jb25zdW1lQWxsKHtkYXRhOmV9KSxmPXRoaXMud29ya1NoYXBlU3RhdGUuZ2V0KHIpO3N3aXRjaChjKXtjYXNlIHZ0LlNlbGVjdG9yOm8uc2VsZWN0SWRzJiZ0LnJ1blJldmVyc2VTZWxlY3RXb3JrKG8uc2VsZWN0SWRzKSx0aGlzLmRyYXdTZWxlY3RvcihvLCExKSwocz1sLnNlbGVjdElkcykhPW51bGwmJnMubGVuZ3RoP2wuY2xlYXJUbXBQb2ludHMoKTp0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHIpO2JyZWFrO2Nhc2UgdnQuRXJhc2VyOm8hPW51bGwmJm8ucmVjdCYmdGhpcy5kcmF3RXJhc2VyKG8pLGwuY2xlYXJUbXBQb2ludHMoKTticmVhaztjYXNlIHZ0LkFycm93OmNhc2UgdnQuU3RyYWlnaHQ6Y2FzZSB2dC5FbGxpcHNlOmNhc2UgdnQuUmVjdGFuZ2xlOmNhc2UgdnQuU3RhcjpjYXNlIHZ0LlBvbHlnb246Y2FzZSB2dC5TcGVlY2hCYWxsb29uOnRoaXMuZHJhd1BlbmNpbEZ1bGwobyxsLmdldFdvcmtPcHRpb25zKCksZiksdGhpcy5kcmF3Q291bnQ9MCx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHIpO2JyZWFrO2Nhc2UgdnQuUGVuY2lsOm8hPW51bGwmJm8ucmVjdCYmKHRoaXMuZHJhd1BlbmNpbEZ1bGwobyxsLmdldFdvcmtPcHRpb25zKCksZiksdGhpcy5kcmF3Q291bnQ9MCksdGhpcy5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShyKTticmVha319fWNvbnN1bWVGdWxsKGUpe3ZhciBzLGw7Y29uc3QgdD10aGlzLnNldEZ1bGxXb3JrKGUpLHI9ZS5vcHMmJkJlKGUub3BzKSxuPShzPWUud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKG4mJnQpe2NvbnN0IGM9KGw9dGhpcy52Tm9kZXMuZ2V0KG4pKT09bnVsbD92b2lkIDA6bC5yZWN0O2xldCBvPXQuY29uc3VtZVNlcnZpY2Uoe29wOnIsaXNGdWxsV29yazohMCxyZXBsYWNlSWQ6bn0pO2NvbnN0IGY9KGU9PW51bGw/dm9pZCAwOmUudXBkYXRlTm9kZU9wdCkmJnQudXBkYXRhT3B0U2VydmljZShlLnVwZGF0ZU5vZGVPcHQpO2lmKG89YnQobyxmKSxvJiZlLndpbGxSZWZyZXNoKXtjb25zdCB4PVtdO2MmJngucHVzaCh7cmVjdDpvLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSx4LnB1c2goe3JlY3Q6byxkcmF3Q2FudmFzOnh0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSk7Y29uc3QgZz17cmVuZGVyOngsc3A6ZS53aWxsU3luY1NlcnZpY2UmJlt7b3B0OmUub3B0LHRvb2xzVHlwZTplLnRvb2xzVHlwZSx0eXBlOnV0LkZ1bGxXb3JrLHdvcmtJZDplLndvcmtJZCxvcHM6ZS5vcHMsdXBkYXRlTm9kZU9wdDplLnVwZGF0ZU5vZGVPcHQsdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkLHZpZXdJZDp0aGlzLnZpZXdJZH1dfHx2b2lkIDB9O3RoaXMuX3Bvc3QoZyl9ZS53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoZS53b3JrSWQpfX1yZW1vdmVXb3JrKGUpe2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO2lmKHIpe2NvbnN0IG49dGhpcy5yZW1vdmVOb2RlKHIpO24mJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6bixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eHQuQmcsZHJhd0NhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pfX1yZW1vdmVOb2RlKGUpe3ZhciBuO3RoaXMud29ya1NoYXBlcy5oYXMoZSkmJnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoZSk7bGV0IHQ7Y29uc3Qgcj10aGlzLnZOb2Rlcy5nZXQoZSk7cmV0dXJuIHImJih0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5jb25jYXQoKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5nZXRFbGVtZW50c0J5TmFtZShlKSl8fFtdKS5mb3JFYWNoKHM9PntzLnJlbW92ZSgpfSksdD1idCh0LHIucmVjdCksdGhpcy52Tm9kZXMuZGVsZXRlKGUpKSx0fWNoZWNrVGV4dEFjdGl2ZShlKXt2YXIgcjtjb25zdHtvcDp0fT1lO2lmKHQhPW51bGwmJnQubGVuZ3RoKXtsZXQgbjtmb3IoY29uc3QgcyBvZiB0aGlzLnZOb2Rlcy5jdXJOb2RlTWFwLnZhbHVlcygpKXtjb25zdHtyZWN0OmwsbmFtZTpjLHRvb2xzVHlwZTpvfT1zLGY9dFswXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx4PXRbMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV07aWYobz09PXZ0LlRleHQmJnBoKFtmLHhdLGwpKXtuPWM7YnJlYWt9fWlmKG4pe2NvbnN0IHM9dGhpcy53b3JrU2hhcGVzLmdldChSdC5zZWxlY3RvcklkKTtzJiYoKHI9cy5zZWxlY3RJZHMpIT1udWxsJiZyLmluY2x1ZGVzKG4pKSYmdGhpcy5ibHVyU2VsZWN0b3IoKSx0aGlzLl9wb3N0KHtzcDpbe3R5cGU6dXQuR2V0VGV4dEFjdGl2ZSx0b29sc1R5cGU6dnQuVGV4dCx3b3JrSWQ6bn1dfSl9fX1jb2xsb2N0RWZmZWN0U2VsZWN0V29yayhlKXtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoUnQuc2VsZWN0b3JJZCkse3dvcmtJZDpyfT1lO2lmKHQmJnImJnQuc2VsZWN0SWRzJiZ0LnNlbGVjdElkcy5pbmNsdWRlcyhyLnRvU3RyaW5nKCkpKXt0aGlzLmVmZmVjdFNlbGVjdE5vZGVEYXRhLmFkZChlKSxzZXRUaW1lb3V0KCgpPT57dmFyIG47dGhpcy5ydW5FZmZlY3RTZWxlY3RXb3JrKCksKG49dGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YSk9PW51bGx8fG4uY2xlYXIoKX0sMCk7cmV0dXJufXJldHVybiBlfXVwZGF0ZVNlbGVjdG9yKGUpe3ZhciB2O2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldChSdC5zZWxlY3RvcklkKTtpZighKCh2PXQ9PW51bGw/dm9pZCAwOnQuc2VsZWN0SWRzKSE9bnVsbCYmdi5sZW5ndGgpKXJldHVybjtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLGVtaXRFdmVudFR5cGU6Yyxpc1N5bmM6byx0ZXh0VXBkYXRlRm9yV29rZXI6Zn09ZSx4PXIud29ya1N0YXRlLGc9dD09bnVsbD92b2lkIDA6dC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cixzZWxlY3RJZHM6dC5zZWxlY3RJZHMsdk5vZGVzOnRoaXMudk5vZGVzLHdpbGxTZXJpYWxpemVEYXRhOmwsd29ya2VyOnRoaXN9KSx5PWc9PW51bGw/dm9pZCAwOmcuc2VsZWN0UmVjdCxtPW5ldyBNYXA7aWYodC5zZWxlY3RJZHMuZm9yRWFjaChQPT57Y29uc3QgaT10aGlzLnZOb2Rlcy5nZXQoUCk7aWYoaSl7Y29uc3R7dG9vbHNUeXBlOnUsb3A6YSxvcHQ6aH09aTttLnNldChQLHtvcHQ6aCx0b29sc1R5cGU6dSxvcHM6KGE9PW51bGw/dm9pZCAwOmEubGVuZ3RoKSYma3QoYSl8fHZvaWQgMH0pfX0pLGM9PT1DdC5UcmFuc2xhdGVOb2RlJiZ4PT09SXQuU3RhcnQpcmV0dXJuO2NvbnN0IFQ9W10sTz1bXTtpZihuKXtULnB1c2goe2lzQ2xlYXJBbGw6ITAsaXNGdWxsV29yazohMSxjbGVhckNhbnZhczp4dC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBQPXtyZWN0OnksaXNGdWxsV29yazohMSxkcmF3Q2FudmFzOnh0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLnZpZXdJZH07ci50cmFuc2xhdGUmJmM9PT1DdC5UcmFuc2xhdGVOb2RlJiZ4PT09SXQuRG9pbmcmJihQLnRyYW5zbGF0ZT1yLnRyYW5zbGF0ZSksVC5wdXNoKFApfWlmKHMpe2lmKGwpe2lmKGM9PT1DdC5Sb3RhdGVOb2RlJiZ4PT09SXQuRG9uZSYmTy5wdXNoKHt0eXBlOnV0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LHdpbGxTeW5jU2VydmljZTohMCxpc1N5bmM6byxwb2ludHM6dC5nZXRDaGlsZHJlblBvaW50cygpfSksYz09PUN0LlNjYWxlTm9kZSYmeD09PUl0LkRvbmUmJk8ucHVzaCh7dHlwZTp1dC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eSx3aWxsU3luY1NlcnZpY2U6ITEsaXNTeW5jOm8scG9pbnRzOnQuZ2V0Q2hpbGRyZW5Qb2ludHMoKX0pLGM9PT1DdC5UcmFuc2xhdGVOb2RlJiZ4PT09SXQuRG9uZSl7Y29uc3QgUD10LmdldENoaWxkcmVuUG9pbnRzKCk7UCYmTy5wdXNoKHt0eXBlOnV0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LHdpbGxTeW5jU2VydmljZTohMSxpc1N5bmM6byxwb2ludHM6UH0pfX1lbHNlIHIuZm9udFNpemUmJk8ucHVzaCh7dHlwZTp1dC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eSx3aWxsU3luY1NlcnZpY2U6ITAsaXNTeW5jOm8scG9pbnRzOnQuZ2V0Q2hpbGRyZW5Qb2ludHMoKX0pLHIucG9pbnRNYXAmJk8ucHVzaCh7dHlwZTp1dC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eSx3aWxsU3luY1NlcnZpY2U6ITEsaXNTeW5jOm8scG9pbnRzOnQuZ2V0Q2hpbGRyZW5Qb2ludHMoKX0pLGM9PT1DdC5TY2FsZU5vZGUmJng9PT1JdC5TdGFydCYmTy5wdXNoKHt0eXBlOnV0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LGNhbnZhc1dpZHRoOnRoaXMuZnVsbExheWVyLnBhcmVudC53aWR0aCxjYW52YXNIZWlnaHQ6dGhpcy5mdWxsTGF5ZXIucGFyZW50LmhlaWdodCx3aWxsU3luY1NlcnZpY2U6ITEscG9pbnRzOnQuZ2V0Q2hpbGRyZW5Qb2ludHMoKX0pO2Zvcihjb25zdFtQLGldb2YgbS5lbnRyaWVzKCkpZiYmaS50b29sc1R5cGU9PT12dC5UZXh0P08ucHVzaCh7Li4uaSx3b3JrSWQ6UCx0eXBlOnV0LlRleHRVcGRhdGUsZGF0YVR5cGU6UHQuTG9jYWx9KTpPLnB1c2goey4uLmksd29ya0lkOlAsdHlwZTp1dC5VcGRhdGVOb2RlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX0saXNTeW5jOm99KX0oVC5sZW5ndGh8fE8ubGVuZ3RoKSYmdGhpcy5fcG9zdCh7cmVuZGVyOlQsc3A6T30pfWJsdXJTZWxlY3RvcihlKXt2YXIgbjtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoUnQuc2VsZWN0b3JJZCkscj10PT1udWxsP3ZvaWQgMDp0LmJsdXJTZWxlY3RvcigpO2lmKHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoUnQuc2VsZWN0b3JJZCksKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5wYXJlbnQpLmNoaWxkcmVuLmZvckVhY2gocz0+e3MubmFtZT09PVJ0LnNlbGVjdG9ySWQmJnMucmVtb3ZlKCl9KSxyKXtjb25zdCBzPVtyXTtlIT1udWxsJiZlLnVuZG9UaWNrZXJJZCYmcy5wdXNoKHt0eXBlOnV0LlNlbGVjdCxzZWxlY3RJZHM6W10sdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkfSksdGhpcy5fcG9zdCh7cmVuZGVyOihyPT1udWxsP3ZvaWQgMDpyLnJlY3QpJiZbe3JlY3Q6ci5yZWN0LGRyYXdDYW52YXM6eHQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOnN9KX19cnVuRWZmZWN0V29yayhlKXt0aGlzLmJhdGNoRWZmZWN0V29yayhlKX1yZVJlbmRlclNlbGVjdG9yKCl7dmFyIHQ7Y29uc3QgZT10aGlzLndvcmtTaGFwZXMuZ2V0KFJ0LnNlbGVjdG9ySWQpO2lmKCh0PWU9PW51bGw/dm9pZCAwOmUuc2VsZWN0SWRzKSE9bnVsbCYmdC5sZW5ndGgmJnRoaXMuZHJhd0xheWVyKXtjb25zdCByPWUucmVSZW5kZXJTZWxlY3RvcigpO3ImJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6cixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6eHQuU2VsZWN0b3IsZHJhd0NhbnZhczp4dC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpbe3R5cGU6dXQuU2VsZWN0LHNlbGVjdElkczplLnNlbGVjdElkcyxzZWxlY3RSZWN0OnIsd2lsbFN5bmNTZXJ2aWNlOiExLHZpZXdJZDp0aGlzLnZpZXdJZCxwb2ludHM6ZS5nZXRDaGlsZHJlblBvaW50cygpfV19KX19dXBkYXRlRnVsbFNlbGVjdFdvcmsoZSl7dmFyIG4scyxsLGMsbyxmLHg7Y29uc3QgdD10aGlzLndvcmtTaGFwZXMuZ2V0KFJ0LnNlbGVjdG9ySWQpLHtzZWxlY3RJZHM6cn09ZTtpZighKHIhPW51bGwmJnIubGVuZ3RoKSl7dGhpcy5ibHVyU2VsZWN0b3IoZSk7cmV0dXJufWlmKCF0KXt0aGlzLnNldEZ1bGxXb3JrKGUpLHRoaXMudXBkYXRlRnVsbFNlbGVjdFdvcmsoZSk7cmV0dXJufWlmKHQmJihyIT1udWxsJiZyLmxlbmd0aCkpe2NvbnN0e2JnUmVjdDpnLHNlbGVjdFJlY3Q6eX09dC51cGRhdGVTZWxlY3RJZHMociksbT17cmVuZGVyOltdLHNwOltdfTtnJiYoKG49bS5yZW5kZXIpPT1udWxsfHxuLnB1c2goe3JlY3Q6Zyxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eHQuQmcsZHJhd0NhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSksKHM9bS5yZW5kZXIpPT1udWxsfHxzLnB1c2goe3JlY3Q6Z3x8eSxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6eHQuU2VsZWN0b3IsZHJhd0NhbnZhczp4dC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9KSwoeD1tLnNwKT09bnVsbHx8eC5wdXNoKHsuLi5lLHNlbGVjdG9yQ29sb3I6KGw9ZS5vcHQpPT1udWxsP3ZvaWQgMDpsLnN0cm9rZUNvbG9yLHN0cm9rZUNvbG9yOihjPWUub3B0KT09bnVsbD92b2lkIDA6Yy5zdHJva2VDb2xvcixmaWxsQ29sb3I6KG89ZS5vcHQpPT1udWxsP3ZvaWQgMDpvLmZpbGxDb2xvcix0ZXh0T3B0OihmPWUub3B0KT09bnVsbD92b2lkIDA6Zi50ZXh0T3B0LGNhblRleHRFZGl0OnQuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnQuY2FuUm90YXRlLHNjYWxlVHlwZTp0LnNjYWxlVHlwZSx0eXBlOnV0LlNlbGVjdCxzZWxlY3RSZWN0Omd8fHksd2lsbFN5bmNTZXJ2aWNlOiExLHBvaW50czp0LmdldENoaWxkcmVuUG9pbnRzKCl9KSx0aGlzLl9wb3N0KG0pfX1kZXN0cm95KCl7c3VwZXIuZGVzdHJveSgpLHRoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEuY2xlYXIoKSx0aGlzLmJhdGNoRXJhc2VyV29ya3MuY2xlYXIoKSx0aGlzLmJhdGNoRXJhc2VyUmVtb3ZlTm9kZXMuY2xlYXIoKX1kcmF3UGVuY2lsQ29tYmluZShlKXt2YXIgcixuO2NvbnN0IHQ9KHI9dGhpcy53b3JrU2hhcGVzLmdldChlKSk9PW51bGw/dm9pZCAwOnIuY29tYmluZUNvbnN1bWUoKTtpZih0KXtjb25zdCBzPXtyZW5kZXI6W10sZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50fTsobj1zLnJlbmRlcik9PW51bGx8fG4ucHVzaCh7cmVjdDp0PT1udWxsP3ZvaWQgMDp0LnJlY3QsaXNDbGVhcjohMCxkcmF3Q2FudmFzOnh0LkZsb2F0LGNsZWFyQ2FudmFzOnh0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSksdGhpcy5fcG9zdChzKX19ZHJhd1NlbGVjdG9yKGUsdCl7dmFyIG4scyxsO2NvbnN0IHI9e3JlbmRlcjpbXSxzcDpbZV19OyhuPWUuc2VsZWN0SWRzKSE9bnVsbCYmbi5sZW5ndGgmJiF0JiYoKHM9ci5yZW5kZXIpPT1udWxsfHxzLnB1c2goe3JlY3Q6ZS5zZWxlY3RSZWN0LGRyYXdDYW52YXM6eHQuU2VsZWN0b3IsaXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5TZWxlY3Rvcixpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0se3JlY3Q6ZS5yZWN0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9LHtyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnh0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSksdCYmKChsPXIucmVuZGVyKT09bnVsbHx8bC5wdXNoKHtyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnh0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9LHtyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnh0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSksdGhpcy5fcG9zdChyKX1hc3luYyBkcmF3RXJhc2VyKGUpe3ZhciByLG47Y29uc3QgdD1bXTtpZigocj1lLm5ld1dvcmtEYXRhcykhPW51bGwmJnIuc2l6ZSl7Zm9yKGNvbnN0IHMgb2YgZS5uZXdXb3JrRGF0YXMudmFsdWVzKCkpe2NvbnN0IGw9cy53b3JrSWQudG9TdHJpbmcoKTt0aGlzLmJhdGNoRXJhc2VyV29ya3MuYWRkKGwpLHQucHVzaCh7dHlwZTp1dC5GdWxsV29yayx3b3JrSWQ6bCxvcHM6a3Qocy5vcCksb3B0OnMub3B0LHRvb2xzVHlwZTpzLnRvb2xzVHlwZSx1cGRhdGVOb2RlT3B0Ont1c2VBbmltYXRpb246ITF9fSl9ZGVsZXRlIGUubmV3V29ya0RhdGFzfShuPWUucmVtb3ZlSWRzKT09bnVsbHx8bi5mb3JFYWNoKHM9Pnt0aGlzLmJhdGNoRXJhc2VyUmVtb3ZlTm9kZXMuYWRkKHMpfSksdC5wdXNoKGUpLHRoaXMuX3Bvc3Qoe3NwOnR9KSx0aGlzLmJhdGNoRXJhc2VyQ29tYmluZSgpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd1BlbmNpbEZ1bGwoZSx0LHIpe3ZhciBzO2NvbnN0IG49e2RyYXdDb3VudDoxLzAscmVuZGVyOlt7cmVjdDplLnJlY3QsZHJhd0NhbnZhczp4dC5CZyxpc0NsZWFyOihyPT1udWxsP3ZvaWQgMDpyLndpbGxDbGVhcil8fCh0PT1udWxsP3ZvaWQgMDp0LmlzT3BhY2l0eSksY2xlYXJDYW52YXM6eHQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpbZV19OyhzPW4ucmVuZGVyKT09bnVsbHx8cy5wdXNoKHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnh0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSksdGhpcy5fcG9zdChuKX11cGRhdGVCYXRjaEVyYXNlckNvbWJpbmVOb2RlKGUsdCl7Y29uc3Qgcj1bXTtsZXQgbjtmb3IoY29uc3QgcyBvZiB0LmtleXMoKSl0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShzKS5mb3JFYWNoKGw9Pntjb25zdCBjPWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bj1idChuLHt4OmMueC1YdC5TYWZlQm9yZGVyUGFkZGluZyx5OmMueS1YdC5TYWZlQm9yZGVyUGFkZGluZyx3OmMud2lkdGgrWHQuU2FmZUJvcmRlclBhZGRpbmcsaDpjLmhlaWdodCtYdC5TYWZlQm9yZGVyUGFkZGluZ30pLGwucmVtb3ZlKCl9KTtyZXR1cm4gZS5mb3JFYWNoKHM9Pntjb25zdCBsPXRoaXMudk5vZGVzLmdldChzKTtpZihsKWlmKHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHMpWzBdKW49YnQobixsLnJlY3QpO2Vsc2V7Y29uc3Qgbz10aGlzLnNldEZ1bGxXb3JrKHsuLi5sLHdvcmtJZDpzfSksZj1vJiZvLmNvbnN1bWVTZXJ2aWNlKHtvcDpsLm9wLGlzRnVsbFdvcms6ITB9KTtmJiYobC5yZWN0PWYsbj1idChuLGYpKX19KSxuJiZyLnB1c2goe3JlY3Q6bixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eHQuQmcsZHJhd0NhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSxyfXJ1bkVmZmVjdFNlbGVjdFdvcmsoKXt2YXIgZTtmb3IoY29uc3QgdCBvZiB0aGlzLmVmZmVjdFNlbGVjdE5vZGVEYXRhLnZhbHVlcygpKXtjb25zdCByPXRoaXMuc2V0RnVsbFdvcmsodCksbj10Lm9wcyYmQmUodC5vcHMpO3ImJihyLmNvbnN1bWVTZXJ2aWNlKHtvcDpuLGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihlPXIuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDplLnRvU3RyaW5nKCl9KSx0IT1udWxsJiZ0LnVwZGF0ZU5vZGVPcHQmJnIudXBkYXRhT3B0U2VydmljZSh0LnVwZGF0ZU5vZGVPcHQpLHQud29ya0lkJiZ0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQud29ya0lkKSl9dGhpcy5yZVJlbmRlclNlbGVjdG9yKCl9fWNsYXNzIFJke2NvbnN0cnVjdG9yKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VsZWN0b3JXb3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgU2V0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJ1bkVmZmVjdElkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm5vQW5pbWF0aW9uUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy52aWV3SWQ9ZS52aWV3SWQsdGhpcy52Tm9kZXM9ZS52Tm9kZXMsdGhpcy5mdWxsTGF5ZXI9ZS5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXI9ZS5kcmF3TGF5ZXIsdGhpcy5wb3N0PWUucG9zdH1kZXN0cm95KCl7dGhpcy53b3JrU2hhcGVzLmNsZWFyKCksdGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5jbGVhcigpfWNvbnN1bWVEcmF3KGUpe3RoaXMuYWN0aXZlV29ya1NoYXBlKGUpLHRoaXMucnVuQW5pbWF0aW9uKCl9Y29uc3VtZUZ1bGwoZSl7dGhpcy5hY3RpdmVXb3JrU2hhcGUoZSksdGhpcy5ydW5BbmltYXRpb24oKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKChlLHQpPT57ZS50b29sc1R5cGU9PT12dC5MYXNlclBlbj9zZXRUaW1lb3V0KCgpPT57dGhpcy53b3JrU2hhcGVzLmRlbGV0ZSh0KX0sMmUzKTp0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQpfSl9cnVuU2VsZWN0V29yayhlKXt0aGlzLmFjdGl2ZVNlbGVjdG9yU2hhcGUoZSk7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7ciYmdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKHIpLHRoaXMucnVuRWZmZWN0KCl9c2V0Tm9kZUtleShlLHQscil7cmV0dXJuIGUudG9vbHNUeXBlPXQsZS5ub2RlPWJuKHt0b29sc1R5cGU6dCx0b29sc09wdDpyLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZHJhd0xheWVyfSksZX1ydW5SZXZlcnNlU2VsZWN0V29yayhlKXtlLmZvckVhY2godD0+e3RoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmZvckVhY2goKHIsbik9Pnt2YXIgcztpZigocz1yLnNlbGVjdElkcykhPW51bGwmJnMubGVuZ3RoKXtjb25zdCBsPXIuc2VsZWN0SWRzLmluZGV4T2YodCk7bD4tMSYmKHIuc2VsZWN0SWRzLnNwbGljZShsLDEpLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChuKSl9fSl9KSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5zaXplJiZ0aGlzLnJ1bkVmZmVjdCgpfXJlbW92ZVdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7aWYocil7Y29uc3Qgbj10aGlzLndvcmtTaGFwZXMuZ2V0KHIpO2lmKG4pe3RoaXMud29ya1NoYXBlcy5kZWxldGUociksdGhpcy5yZW1vdmVOb2RlKHIsZSxuPT1udWxsP3ZvaWQgMDpuLnRvdGFsUmVjdCwhMSk7cmV0dXJufXRoaXMucmVtb3ZlTm9kZShyLGUpfX1yZW1vdmVTZWxlY3RXb3JrKGUpe2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO3ImJih0aGlzLmFjdGl2ZVNlbGVjdG9yU2hhcGUoZSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKHIpKSx0aGlzLnJ1bkVmZmVjdCgpfXJlbW92ZU5vZGUoZSx0LHIsbj0hMCl7dmFyIGY7Y29uc3Qgcz10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5jb25jYXQodGhpcy5kcmF3TGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkpO2UuaW5kZXhPZihSdC5zZWxlY3RvcklkKT4tMSYmdGhpcy5yZW1vdmVTZWxlY3RXb3JrKHQpO2NvbnN0IGw9W107bGV0IGM9cjtjb25zdCBvPShmPXRoaXMudk5vZGVzLmdldChlKSk9PW51bGw/dm9pZCAwOmYucmVjdDtvJiYoYz1idChvLGMpKSxzLmZvckVhY2goeD0+e2wucHVzaCh4KX0pLGwubGVuZ3RoJiZsLmZvckVhY2goeD0+eC5yZW1vdmUoKSksYyYmKHRoaXMucG9zdCh7cmVuZGVyOlt7cmVjdDpmZShjKSxpc0NsZWFyOiEwLGlzRnVsbFdvcms6bixjbGVhckNhbnZhczpuP3h0LkJnOnh0LkZsb2F0LGRyYXdDYW52YXM6bj94dC5CZzp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pLHRoaXMudk5vZGVzLmRlbGV0ZShlKSl9YWN0aXZlV29ya1NoYXBlKGUpe3ZhciB5LG0sVCxPO2NvbnN0e3dvcmtJZDp0LG9wdDpyLHRvb2xzVHlwZTpuLHR5cGU6cyx1cGRhdGVOb2RlT3B0Omwsb3BzOmMsb3A6byx1c2VBbmltYXRpb246Zn09ZTtpZighdClyZXR1cm47Y29uc3QgeD10LnRvU3RyaW5nKCk7aWYoISgoeT10aGlzLndvcmtTaGFwZXMpIT1udWxsJiZ5Lmhhcyh4KSkpe2xldCB2PXt0b29sc1R5cGU6bixhbmltYXRpb25Xb3JrRGF0YTpvfHxbXSxhbmltYXRpb25JbmRleDowLHR5cGU6cyx1cGRhdGVOb2RlT3B0Omwsb3BzOmMsdXNlQW5pbWF0aW9uOnR5cGVvZiBmPCJ1Ij9mOnR5cGVvZihsPT1udWxsP3ZvaWQgMDpsLnVzZUFuaW1hdGlvbik8InUiP2w9PW51bGw/dm9pZCAwOmwudXNlQW5pbWF0aW9uOiEwLG9sZFJlY3Q6KG09dGhpcy52Tm9kZXMuZ2V0KHgpKT09bnVsbD92b2lkIDA6bS5yZWN0LGlzRGlmZjohMX07biYmciYmKHY9dGhpcy5zZXROb2RlS2V5KHYsbixyKSksKFQ9dGhpcy53b3JrU2hhcGVzKT09bnVsbHx8VC5zZXQoeCx2KX1jb25zdCBnPShPPXRoaXMud29ya1NoYXBlcyk9PW51bGw/dm9pZCAwOk8uZ2V0KHgpO3MmJihnLnR5cGU9cyksYyYmKGcuYW5pbWF0aW9uV29ya0RhdGE9QmUoYyksZy5vcHM9YyksbCYmKGcudXBkYXRlTm9kZU9wdD1sKSxvJiYoZy5pc0RpZmY9dGhpcy5oYXNEaWZmRGF0YShnLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxvLGcudG9vbHNUeXBlKSxnLmFuaW1hdGlvbldvcmtEYXRhPW8pLGcubm9kZSYmZy5ub2RlLmdldFdvcmtJZCgpIT09eCYmZy5ub2RlLnNldFdvcmtJZCh4KSxnLnRvb2xzVHlwZSE9PW4mJm4mJnImJnRoaXMuc2V0Tm9kZUtleShnLG4scil9aGFzRGlmZkRhdGEoZSx0LHIpe2NvbnN0IG49ZS5sZW5ndGg7aWYodC5sZW5ndGg8bilyZXR1cm4hMDtzd2l0Y2gocil7Y2FzZSB2dC5QZW5jaWw6e2ZvcihsZXQgcz0wO3M8bjtzKz0zKWlmKHRbc10hPT1lW3NdfHx0W3MrMV0hPT1lW3MrMV0pcmV0dXJuITA7YnJlYWt9Y2FzZSB2dC5MYXNlclBlbjp7Zm9yKGxldCBzPTA7czxuO3MrPTIpaWYodFtzXSE9PWVbc118fHRbcysxXSE9PWVbcysxXSlyZXR1cm4hMDticmVha319cmV0dXJuITF9YW5pbWF0aW9uRHJhdygpe3ZhciBvLGYseCxnLHk7dGhpcy5hbmltYXRpb25JZD12b2lkIDA7bGV0IGU9ITE7Y29uc3QgdD1uZXcgTWFwLHI9W10sbj1bXSxzPVtdLGw9W107dGhpcy53b3JrU2hhcGVzLmZvckVhY2goKG0sVCk9Pnt2YXIgTyx2LFAsaSx1LGEsaCxiLEUsQSxMLFMsSSxELFIsQyxqLCQsSCxKLHEsRixHO3N3aXRjaChtLnRvb2xzVHlwZSl7Y2FzZSB2dC5UZXh0OntpZihtLm5vZGUpe2NvbnN0IFo9bS5vbGRSZWN0LHR0PShPPW0ubm9kZSk9PW51bGw/dm9pZCAwOk8uY29uc3VtZVNlcnZpY2Uoe29wOm0uYW5pbWF0aW9uV29ya0RhdGF8fFtdLGlzRnVsbFdvcms6ITB9KTt0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5mb3JFYWNoKChldCxpdCk9Pnt2YXIgazsoaz1ldC5zZWxlY3RJZHMpIT1udWxsJiZrLmluY2x1ZGVzKFQpJiYodGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKGl0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxaKSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCx0dCksdGhpcy5ydW5FZmZlY3QoKSl9KSwodj1tLm5vZGUpPT1udWxsfHx2LmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShUKX1icmVha31jYXNlIHZ0LkFycm93OmNhc2UgdnQuU3RyYWlnaHQ6Y2FzZSB2dC5SZWN0YW5nbGU6Y2FzZSB2dC5FbGxpcHNlOmNhc2UgdnQuU3RhcjpjYXNlIHZ0LlBvbHlnb246Y2FzZSB2dC5TcGVlY2hCYWxsb29uOntjb25zdCBaPSEhbS5vcHM7aWYoKFA9bS5hbmltYXRpb25Xb3JrRGF0YSkhPW51bGwmJlAubGVuZ3RoKXtjb25zdCB0dD1tLm9sZFJlY3QsZXQ9bS5ub2RlLm9sZFJlY3Q7dHQmJnMucHVzaCh7cmVjdDp0dCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnh0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLGV0JiZsLnB1c2goe3JlY3Q6ZXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBpdD0oaT1tLm5vZGUpPT1udWxsP3ZvaWQgMDppLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhLGlzRnVsbFdvcms6Wn0pO3Quc2V0KFQse3dvcmtTdGF0ZTp0dD9tLm9wcz9JdC5Eb25lOkl0LkRvaW5nOkl0LlN0YXJ0LG9wOm0uYW5pbWF0aW9uV29ya0RhdGEuZmlsdGVyKChrLGh0KT0+e2lmKGh0JTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpfSksWj8odGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgoayxodCk9Pnt2YXIgZnQ7KGZ0PWsuc2VsZWN0SWRzKSE9bnVsbCYmZnQuaW5jbHVkZXMoVCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaHQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHR0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxldCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9YnQodGhpcy5ub0FuaW1hdGlvblJlY3QsaXQpLHRoaXMucnVuRWZmZWN0KCkpfSksKHU9bS5ub2RlKT09bnVsbHx8dS5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoVCksci5wdXNoKHtyZWN0Oml0LGRyYXdDYW52YXM6eHQuQmcsaXNGdWxsV29yazpaLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHQuc2V0KFQse3dvcmtTdGF0ZTpJdC5Eb25lLG9wOm0uYW5pbWF0aW9uV29ya0RhdGEuZmlsdGVyKChrLGh0KT0+e2lmKGh0JTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpfSkpOm4ucHVzaCh7cmVjdDppdCxkcmF3Q2FudmFzOnh0LkZsb2F0LGlzRnVsbFdvcms6Wix2aWV3SWQ6dGhpcy52aWV3SWR9KSxtLmFuaW1hdGlvbldvcmtEYXRhLmxlbmd0aD0wfWJyZWFrfWNhc2UgdnQuUGVuY2lsOntpZighbS51c2VBbmltYXRpb24mJm0ub3BzKXtsZXQgWj0oYT1tLm5vZGUpPT1udWxsP3ZvaWQgMDphLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDpUfSk7Y29uc3QgdHQ9KGg9bS5ub2RlKT09bnVsbD92b2lkIDA6aC51cGRhdGFPcHRTZXJ2aWNlKG0udXBkYXRlTm9kZU9wdCk7Wj1idChaLHR0KSxzLnB1c2goe3JlY3Q6YnQobS5vbGRSZWN0LFopLGNsZWFyQ2FudmFzOnh0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHIucHVzaCh7cmVjdDpidChtLm9sZFJlY3QsWiksZHJhd0NhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSx0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5mb3JFYWNoKChldCxpdCk9Pnt2YXIgazsoaz1ldC5zZWxlY3RJZHMpIT1udWxsJiZrLmluY2x1ZGVzKFQpJiYodGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKGl0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxaKSx0aGlzLnJ1bkVmZmVjdCgpKX0pLChiPW0ubm9kZSk9PW51bGx8fGIuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKFQpfWVsc2UgaWYobS51c2VBbmltYXRpb24pe2NvbnN0IHR0PXRoaXMuY29tcHV0TmV4dEFuaW1hdGlvbkluZGV4KG0sMyksZXQ9bS5pc0RpZmY/MDpNYXRoLm1heCgwLChtLmFuaW1hdGlvbkluZGV4fHwwKS0zKSxpdD0obS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKGV0LHR0KTtpZihtLmlzRGVsKW0uaXNEZWwmJigoQz1tLm5vZGUpPT1udWxsfHxDLmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShUKSk7ZWxzZXtpZigobS5hbmltYXRpb25JbmRleHx8MCk8dHR8fG0uaXNEaWZmKXtjb25zdCBrPShBPW0ubm9kZSk9PW51bGw/dm9pZCAwOkEuY29uc3VtZVNlcnZpY2Uoe29wOml0LGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihFPW0ubm9kZS5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOkUudG9TdHJpbmcoKX0pO2lmKG4ucHVzaCh7cmVjdDprLGRyYXdDYW52YXM6eHQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksbS5hbmltYXRpb25JbmRleD10dCxtLmlzRGlmZiYmKG0uaXNEaWZmPSExKSxpdC5sZW5ndGgpe2NvbnN0IGh0PWl0LmZpbHRlcigoZnQsQik9PntpZihCJTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpO3Quc2V0KFQse3dvcmtTdGF0ZTpldD09PTA/SXQuU3RhcnQ6dHQ9PT0oKEw9bS5hbmltYXRpb25Xb3JrRGF0YSk9PW51bGw/dm9pZCAwOkwubGVuZ3RoKT9JdC5Eb25lOkl0LkRvaW5nLG9wOmh0fSl9fWVsc2UgaWYobS5vcHMpe2NvbnN0IGs9KEk9bS5ub2RlKT09bnVsbD92b2lkIDA6SS5jb25zdW1lU2VydmljZSh7b3A6bS5hbmltYXRpb25Xb3JrRGF0YXx8W10saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KFM9bS5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6Uy50b1N0cmluZygpfSk7bS5pc0RlbD0hMCxsLnB1c2goe3JlY3Q6ayxjbGVhckNhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSwoRD1tLm5vZGUpIT1udWxsJiZELmdldFdvcmtPcHRpb25zKCkuaXNPcGFjaXR5JiZzLnB1c2goe3JlY3Q6ayxjbGVhckNhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSxyLnB1c2goe3JlY3Q6ayxkcmF3Q2FudmFzOnh0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMudk5vZGVzLnNldEluZm8oVCx7b3A6bS5hbmltYXRpb25Xb3JrRGF0YSxvcHQ6KFI9bS5ub2RlKT09bnVsbD92b2lkIDA6Ui5nZXRXb3JrT3B0aW9ucygpLHRvb2xzVHlwZTptLnRvb2xzVHlwZSxyZWN0Omt9KSx0LnNldChULHt3b3JrU3RhdGU6SXQuRG9uZSxvcDppdC5maWx0ZXIoKGh0LGZ0KT0+e2lmKGZ0JTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpfSl9ZT0hMH1icmVha31icmVha31jYXNlIHZ0Lkxhc2VyUGVuOntjb25zdCB0dD10aGlzLmNvbXB1dE5leHRBbmltYXRpb25JbmRleChtLDIpLGV0PU1hdGgubWF4KDAsKG0uYW5pbWF0aW9uSW5kZXh8fDApLTIpLGl0PShtLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkuc2xpY2UoZXQsdHQpO2lmKG0uaXNEZWwpe2lmKG0uaXNEZWwpe2NvbnN0IGs9KEY9bS5ub2RlKT09bnVsbD92b2lkIDA6Ri5jb25zdW1lU2VydmljZSh7b3A6W10saXNGdWxsV29yazohMX0pO20udG90YWxSZWN0PWJ0KG0udG90YWxSZWN0LGspLGwucHVzaCh7cmVjdDptLnRvdGFsUmVjdCxjbGVhckNhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxuLnB1c2goe3JlY3Q6bS50b3RhbFJlY3QsZHJhd0NhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSwoRz1tLm5vZGUpPT1udWxsfHxHLmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShUKX19ZWxzZXtpZigobS5hbmltYXRpb25JbmRleHx8MCk8dHQpe2NvbnN0IGs9KCQ9bS5ub2RlKT09bnVsbD92b2lkIDA6JC5jb25zdW1lU2VydmljZSh7b3A6aXQsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6KGo9bS5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6ai50b1N0cmluZygpfSk7bS50b3RhbFJlY3Q9YnQobS50b3RhbFJlY3QsayksbS50aW1lciYmKGNsZWFyVGltZW91dChtLnRpbWVyKSxtLnRpbWVyPXZvaWQgMCksbS5hbmltYXRpb25JbmRleD10dCxpdC5sZW5ndGgmJnQuc2V0KFQse3dvcmtTdGF0ZTpldD09PTA/SXQuU3RhcnQ6dHQ9PT0oKEg9bS5hbmltYXRpb25Xb3JrRGF0YSk9PW51bGw/dm9pZCAwOkgubGVuZ3RoKT9JdC5Eb25lOkl0LkRvaW5nLG9wOml0LnNsaWNlKC0yKX0pfWVsc2V7bS50aW1lcnx8KG0udGltZXI9c2V0VGltZW91dCgoKT0+e20udGltZXI9dm9pZCAwLG0uaXNEZWw9ITAsdGhpcy5ydW5BbmltYXRpb24oKX0sKChKPW0ubm9kZSk9PW51bGw/dm9pZCAwOkouZ2V0V29ya09wdGlvbnMoKSkuZHVyYXRpb24qMWUzKzEwMCksdC5zZXQoVCx7d29ya1N0YXRlOkl0LkRvbmUsb3A6W119KSk7Y29uc3Qgaz0ocT1tLm5vZGUpPT1udWxsP3ZvaWQgMDpxLmNvbnN1bWVTZXJ2aWNlKHtvcDpbXSxpc0Z1bGxXb3JrOiExfSk7bS50b3RhbFJlY3Q9YnQobS50b3RhbFJlY3Qsayl9bC5wdXNoKHtyZWN0Om0udG90YWxSZWN0LGNsZWFyQ2FudmFzOnh0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLG4ucHVzaCh7cmVjdDptLnRvdGFsUmVjdCxkcmF3Q2FudmFzOnh0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLGU9ITB9YnJlYWt9fX0pLGUmJnRoaXMucnVuQW5pbWF0aW9uKCk7Y29uc3QgYz17cmVuZGVyOltdfTtpZihzLmxlbmd0aCl7Y29uc3QgbT1zLnJlZHVjZSgoVCxPKT0+KE8ucmVjdCYmTy5jbGVhckNhbnZhcz09PXh0LkJnJiYoVC5yZWN0PWJ0KFQucmVjdCxPLnJlY3QpKSxUKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KTttLnJlY3QmJihtLnJlY3Q9bS5yZWN0JiZmZShtLnJlY3QpLChvPWMucmVuZGVyKT09bnVsbHx8by5wdXNoKG0pKX1pZihsLmxlbmd0aCl7Y29uc3QgbT1sLnJlZHVjZSgoVCxPKT0+KE8ucmVjdCYmTy5jbGVhckNhbnZhcz09PXh0LkZsb2F0JiYoVC5yZWN0PWJ0KFQucmVjdCxPLnJlY3QpKSxUKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTttLnJlY3QmJihtLnJlY3Q9bS5yZWN0JiZmZShtLnJlY3QpLChmPWMucmVuZGVyKT09bnVsbHx8Zi5wdXNoKG0pKX1pZihyLmxlbmd0aCl7Y29uc3QgbT1yLnJlZHVjZSgoVCxPKT0+KE8ucmVjdCYmTy5kcmF3Q2FudmFzPT09eHQuQmcmJihULnJlY3Q9YnQoVC5yZWN0LE8ucmVjdCkpLFQpLHtpc0Z1bGxXb3JrOiEwLGRyYXdDYW52YXM6eHQuQmcsdmlld0lkOnRoaXMudmlld0lkfSk7bS5yZWN0JiYobS5yZWN0PW0ucmVjdCYmZmUobS5yZWN0KSwoeD1jLnJlbmRlcik9PW51bGx8fHgucHVzaChtKSl9aWYobi5sZW5ndGgpe2NvbnN0IG09bi5yZWR1Y2UoKFQsTyk9PihPLnJlY3QmJk8uZHJhd0NhbnZhcz09PXh0LkZsb2F0JiYoVC5yZWN0PWJ0KFQucmVjdCxPLnJlY3QpKSxUKSx7aXNGdWxsV29yazohMSxkcmF3Q2FudmFzOnh0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pO20ucmVjdCYmKG0ucmVjdD1tLnJlY3QmJmZlKG0ucmVjdCksKGc9Yy5yZW5kZXIpPT1udWxsfHxnLnB1c2gobSkpfXQuc2l6ZSYmKGMuc3A9W10sdC5mb3JFYWNoKChtLFQpPT57dmFyIE87KE89Yy5zcCk9PW51bGx8fE8ucHVzaCh7dHlwZTp1dC5DdXJzb3IsdWlkOlQuc3BsaXQoQ2gpWzBdLG9wOm0ub3Asd29ya1N0YXRlOm0ud29ya1N0YXRlLHZpZXdJZDp0aGlzLnZpZXdJZH0pfSkpLCh5PWMucmVuZGVyKSE9bnVsbCYmeS5sZW5ndGgmJnRoaXMucG9zdChjKX1ydW5BbmltYXRpb24oKXt0aGlzLmFuaW1hdGlvbklkfHwodGhpcy5hbmltYXRpb25JZD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EcmF3LmJpbmQodGhpcykpKX1jb21wdXROZXh0QW5pbWF0aW9uSW5kZXgoZSx0KXt2YXIgbjtjb25zdCByPU1hdGguZmxvb3IoKGUuYW5pbWF0aW9uV29ya0RhdGF8fFtdKS5zbGljZShlLmFuaW1hdGlvbkluZGV4KS5sZW5ndGgqMzIvdC8oKChuPWUubm9kZSk9PW51bGw/dm9pZCAwOm4uc3luY1VuaXRUaW1lKXx8MWUzKSkqdDtyZXR1cm4gTWF0aC5taW4oKGUuYW5pbWF0aW9uSW5kZXh8fDApKyhyfHx0KSwoZS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLmxlbmd0aCl9cnVuRWZmZWN0KCl7dGhpcy5ydW5FZmZlY3RJZHx8KHRoaXMucnVuRWZmZWN0SWQ9c2V0VGltZW91dCh0aGlzLmVmZmVjdFJ1blNlbGVjdG9yLmJpbmQodGhpcyksMCkpfWVmZmVjdFJ1blNlbGVjdG9yKCl7dGhpcy5ydW5FZmZlY3RJZD12b2lkIDA7bGV0IGU9dGhpcy5ub0FuaW1hdGlvblJlY3Q7dGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuZm9yRWFjaCh0PT57dmFyIHMsbDtjb25zdCByPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmdldCh0KSxuPXImJnIuc2VsZWN0SWRzJiYoKHM9ci5ub2RlKT09bnVsbD92b2lkIDA6cy5zZWxlY3RTZXJ2aWNlTm9kZSh0LHIsITApKTtlPWJ0KGUsbiksKGw9cj09bnVsbD92b2lkIDA6ci5zZWxlY3RJZHMpIT1udWxsJiZsLmxlbmd0aHx8dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZGVsZXRlKHQpfSksZSYmdGhpcy5wb3N0KHtyZW5kZXI6W3tyZWN0OmZlKGUpLGRyYXdDYW52YXM6eHQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuY2xlYXIoKSx0aGlzLm5vQW5pbWF0aW9uUmVjdD12b2lkIDB9YWN0aXZlU2VsZWN0b3JTaGFwZShlKXt2YXIgZix4LGc7Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOm4sdHlwZTpzLHNlbGVjdElkczpsfT1lO2lmKCF0KXJldHVybjtjb25zdCBjPXQudG9TdHJpbmcoKTtpZighKChmPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzKSE9bnVsbCYmZi5oYXMoYykpKXtsZXQgeT17dG9vbHNUeXBlOm4sc2VsZWN0SWRzOmwsdHlwZTpzLG9wdDpyfTtuJiZyJiYoeT10aGlzLnNldE5vZGVLZXkoeSxuLHIpKSwoeD10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGx8fHguc2V0KGMseSl9Y29uc3Qgbz0oZz10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGw/dm9pZCAwOmcuZ2V0KGMpO3MmJihvLnR5cGU9cyksby5ub2RlJiZvLm5vZGUuZ2V0V29ya0lkKCkhPT1jJiZvLm5vZGUuc2V0V29ya0lkKGMpLG8uc2VsZWN0SWRzPWx8fFtdfX1jbGFzcyBJZCBleHRlbmRzIE1ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25Xb3JrUmVjdHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVEcmF3VGltZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2xvc2VBbmltYXRpb25UaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTEwMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJydW5MYXNlclBlblN0ZXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSl9cnVuRnVsbFdvcmsoZSx0KXt2YXIgcztjb25zdCByPXRoaXMuc2V0RnVsbFdvcmsoZSksbj1lLm9wcyYmQmUoZS5vcHMpO2lmKHIpe2NvbnN0IGw9ci5jb25zdW1lU2VydmljZSh7b3A6bixpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDoocz1yLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpLGlzRHJhd0xhYmVsOnR9KSxjPShlPT1udWxsP3ZvaWQgMDplLnVwZGF0ZU5vZGVPcHQpJiZyLnVwZGF0YU9wdFNlcnZpY2UoZS51cGRhdGVOb2RlT3B0KTtyZXR1cm4gZS53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoZS53b3JrSWQpLGN8fGx9fXJ1blNlbGVjdFdvcmsoZSl7dmFyIHI7Y29uc3QgdD10aGlzLnNldEZ1bGxXb3JrKGUpO3QmJigocj1lLnNlbGVjdElkcykhPW51bGwmJnIubGVuZ3RoKSYmZS53b3JrSWQmJnQuc2VsZWN0U2VydmljZU5vZGUoZS53b3JrSWQudG9TdHJpbmcoKSx7c2VsZWN0SWRzOmUuc2VsZWN0SWRzfSwhMSl9Y29uc3VtZURyYXcoZSl7dmFyIG47Y29uc3R7b3A6dCx3b3JrSWQ6cn09ZTtpZih0IT1udWxsJiZ0Lmxlbmd0aCYmcil7Y29uc3Qgcz10aGlzLndvcmtTaGFwZXMuZ2V0KHIpO2lmKCFzKXJldHVybjtjb25zdCBsPXMudG9vbHNUeXBlLGM9cy5jb25zdW1lKHtkYXRhOmUsaXNGdWxsV29yazohMSxpc0NsZWFyQWxsOiEwLGlzU3ViV29ya2VyOiEwfSk7c3dpdGNoKGwpe2Nhc2UgdnQuTGFzZXJQZW46YyE9bnVsbCYmYy5yZWN0JiYoKG49dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxuLnNldChyLHtyZXM6YyxjYW5EZWw6ITEsaXNSZWN0OiEwfSkpLHRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oKTticmVhaztjYXNlIHZ0LkFycm93OmNhc2UgdnQuU3RyYWlnaHQ6Y2FzZSB2dC5FbGxpcHNlOmNhc2UgdnQuUmVjdGFuZ2xlOmNhc2UgdnQuU3RhcjpjYXNlIHZ0LlBvbHlnb246Y2FzZSB2dC5TcGVlY2hCYWxsb29uOmMmJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd0Fycm93KGMpKTticmVhaztjYXNlIHZ0LlBlbmNpbDpjJiYodGhpcy5kcmF3Q291bnQrKyx0aGlzLmRyYXdQZW5jaWwoYykpO2JyZWFrfX19Y29uc3VtZURyYXdBbGwoZSl7dmFyIHIsbjtjb25zdHt3b3JrSWQ6dH09ZTtpZih0KXtjb25zdCBzPXRoaXMud29ya1NoYXBlcy5nZXQodCk7aWYoIXMpcmV0dXJuO3N3aXRjaChzLnRvb2xzVHlwZSl7Y2FzZSB2dC5MYXNlclBlbjppZih0aGlzLmFuaW1hdGlvbklkKXtjb25zdCBjPXMuY29uc3VtZUFsbCh7ZGF0YTplfSk7YyE9bnVsbCYmYy5vcCYmYyE9bnVsbCYmYy5yZWN0JiYoKHI9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxyLnNldCh0LHtyZXM6YyxjYW5EZWw6ITEsaXNSZWN0OiEwfSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbihjKSk7Y29uc3Qgbz0obj1zLmdldFdvcmtPcHRpb25zKCkpPT1udWxsP3ZvaWQgMDpuLmR1cmF0aW9uO3RoaXMuY2xvc2VBbmltYXRpb25UaW1lPW8/byoxZTMrMTAwOnRoaXMuY2xvc2VBbmltYXRpb25UaW1lLHNldFRpbWVvdXQoKCk9Pnt2YXIgeDt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0LnRvU3RyaW5nKCkpLm1hcChnPT5nLnJlbW92ZSgpKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2NvbnN0IGY9KHg9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsP3ZvaWQgMDp4LmdldCh0KTtmJiYoZi5jYW5EZWw9ITApLHNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3JlbW92ZUlkczpbdC50b1N0cmluZygpXSx0eXBlOnV0LlJlbW92ZU5vZGV9XX0pfSxzLmdldFdvcmtPcHRpb25zKCkuc3luY1VuaXRUaW1lfHx0aGlzLmNsb3NlQW5pbWF0aW9uVGltZSl9LHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKX1icmVhaztjYXNlIHZ0LkFycm93OmNhc2UgdnQuU3RyYWlnaHQ6Y2FzZSB2dC5FbGxpcHNlOmNhc2UgdnQuUGVuY2lsOmNhc2UgdnQuUmVjdGFuZ2xlOmNhc2UgdnQuU3RhcjpjYXNlIHZ0LlBvbHlnb246Y2FzZSB2dC5TcGVlY2hCYWxsb29uOnRoaXMuZHJhd0NvdW50PTAsdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2JyZWFrfX19dXBkYXRlTGFiZWxzKGUsdCl7ZS5jaGlsZHJlbi5mb3JFYWNoKHI9PntpZihyLnRhZ05hbWU9PT0iTEFCRUwiKXtjb25zdCBuPXIubmFtZSx7d2lkdGg6c309ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxbbF09ZS53b3JsZFNjYWxpbmcse3VuZGVybGluZTpjLGxpbmVUaHJvdWdoOm99PXQub3B0O2MmJmUuZ2V0RWxlbWVudHNCeU5hbWUoYCR7bn1fdW5kZXJsaW5lYClbMF0uYXR0cih7cG9pbnRzOlswLDAscy9sLDBdfSksbyYmZS5nZXRFbGVtZW50c0J5TmFtZShgJHtufV9saW5lVGhyb3VnaGApWzBdLmF0dHIoe3BvaW50czpbMCwwLHMvbCwwXX0pfX0pfXJ1bkxhc2VyUGVuQW5pbWF0aW9uKGUpe3RoaXMuYW5pbWF0aW9uSWR8fCh0aGlzLmFuaW1hdGlvbklkPXJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e3ZhciBuLHM7aWYodGhpcy5hbmltYXRpb25JZD12b2lkIDAsdGhpcy5ydW5MYXNlclBlblN0ZXArKyx0aGlzLnJ1bkxhc2VyUGVuU3RlcD4xKXt0aGlzLnJ1bkxhc2VyUGVuU3RlcD0wLHRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oZSk7cmV0dXJufWxldCB0O2NvbnN0IHI9W107KG49dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxuLmZvckVhY2goKGwsYyxvKT0+e2wuaXNSZWN0JiYodD1idCh0LGwucmVzLnJlY3QpKSxsLnJlcy53b3JrSWQmJnIucHVzaChsLnJlcyksdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoYy50b1N0cmluZygpKS5sZW5ndGg/bC5pc1JlY3Q9ITA6bC5pc1JlY3Q9ITEsbC5jYW5EZWwmJm8uZGVsZXRlKGMpfSksKHM9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpIT1udWxsJiZzLnNpemUmJnRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oKSx0JiYoZSYmci5wdXNoKGUpLHRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6dCxkcmF3Q2FudmFzOnh0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpyfSkpfSkpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHJlbmRlcjpbe3JlY3Q6ZT09bnVsbD92b2lkIDA6ZS5yZWN0LGRyYXdDYW52YXM6eHQuRmxvYXQsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd0Fycm93KGUpe3RoaXMuX3Bvc3Qoe2RyYXdDb3VudDp0aGlzLmRyYXdDb3VudCxyZW5kZXI6W3tyZWN0OmU9PW51bGw/dm9pZCAwOmUucmVjdCxkcmF3Q2FudmFzOnh0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pfX12YXIgUGU7KGZ1bmN0aW9uKGQpe2QuRnVsbD0iZnVsbCIsZC5TdWI9InN1YiJ9KShQZXx8KFBlPXt9KSk7Y2xhc3MgTGR7Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3NlbGYiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrVGhyZWFkTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMuX3NlbGY9ZSx0aGlzLnR5cGU9dCx0aGlzLnJlZ2lzdGVyKCl9aW5pdChlKXtjb25zdHt2aWV3SWQ6dCxkcHI6cixvZmZzY3JlZW5DYW52YXNPcHQ6bixsYXllck9wdDpzfT1lO2lmKCFyfHwhbnx8IXMpcmV0dXJuO2xldCBsO3RoaXMudHlwZT09PVBlLkZ1bGwmJihsPW5ldyBEZCh0LHtkcHI6cixvZmZzY3JlZW5DYW52YXNPcHQ6bixsYXllck9wdDpzfSx0aGlzLnBvc3QuYmluZCh0aGlzKSkpLHRoaXMudHlwZT09PVBlLlN1YiYmKGw9bmV3IHdkKHQse2RwcjpyLG9mZnNjcmVlbkNhbnZhc09wdDpuLGxheWVyT3B0OnN9LHRoaXMucG9zdC5iaW5kKHRoaXMpKSksbCYmZS5jYW1lcmFPcHQmJmwuc2V0Q2FtZXJhT3B0KGUuY2FtZXJhT3B0KSxsJiZ0aGlzLndvcmtUaHJlYWRNYXAuc2V0KHQsbCl9cmVnaXN0ZXIoKXtvbm1lc3NhZ2U9ZT0+e2NvbnN0IHQ9ZS5kYXRhO2lmKHQpZm9yKGNvbnN0IHIgb2YgdC52YWx1ZXMoKSl7Y29uc3R7bXNnVHlwZTpuLHZpZXdJZDpzLHRhc2tzcXVldWU6bCxtYWluVGFza3NxdWV1ZUNvdW50OmN9PXI7aWYobj09PXV0LkluaXQpe3RoaXMuaW5pdChyKTtjb250aW51ZX1pZihuPT09dXQuVGFza3NRdWV1ZSYmKGwhPW51bGwmJmwuc2l6ZSkmJmMpe3RoaXMud29ya1RocmVhZE1hcC5mb3JFYWNoKChmLHgpPT57Y29uc3QgZz1sLmdldCh4KTtnJiZmLm9uKGcpLHRoaXMucG9zdCh7d29ya2VyVGFza3NxdWV1ZUNvdW50OmN9KX0pO2NvbnRpbnVlfWlmKHM9PT1JaCl7dGhpcy53b3JrVGhyZWFkTWFwLmZvckVhY2goZj0+e2Yub24ociksbj09PXV0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUocyl9KTtjb250aW51ZX1jb25zdCBvPXRoaXMud29ya1RocmVhZE1hcC5nZXQocyk7byYmKG8ub24ociksbj09PXV0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUocykpfX19cG9zdChlLHQpe3Q/dGhpcy5fc2VsZi5wb3N0TWVzc2FnZShlLHQpOnRoaXMuX3NlbGYucG9zdE1lc3NhZ2UoZSl9fWNsYXNzIERkIGV4dGVuZHMgU257Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKGUsdCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJtZXRob2RCdWlsZGVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuX3Bvc3Q9cix0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJkcmF3TGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZToxZTN9KTtjb25zdCBuPXt2aWV3SWQ6dGhpcy52aWV3SWQsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXIscG9zdDp0aGlzLnBvc3QuYmluZCh0aGlzKX07dGhpcy5sb2NhbFdvcms9bmV3IENkKG4pLHRoaXMuc2VydmljZVdvcms9bmV3IFJkKG4pLHRoaXMubWV0aG9kQnVpbGRlcj1uZXcgWWgoW0N0LkNvcHlOb2RlLEN0LlNldENvbG9yTm9kZSxDdC5EZWxldGVOb2RlLEN0LlJvdGF0ZU5vZGUsQ3QuU2NhbGVOb2RlLEN0LlRyYW5zbGF0ZU5vZGUsQ3QuWkluZGV4QWN0aXZlLEN0LlpJbmRleE5vZGUsQ3QuU2V0Rm9udFN0eWxlLEN0LlNldFBvaW50XSkucmVnaXN0ZXJGb3JXb3JrZXIodGhpcy5sb2NhbFdvcmssdGhpcy5zZXJ2aWNlV29yayksdGhpcy52Tm9kZXMuaW5pdCh0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcil9YXN5bmMgcG9zdChlLHQpe3ZhciBjLG8sZjtjb25zdCByPWUucmVuZGVyLG49W107bGV0IHM9dDtpZihyIT1udWxsJiZyLmxlbmd0aCl7Zm9yKGNvbnN0IHggb2Ygcil7aWYoeC5pc0NsZWFyQWxsJiYoeC5yZWN0PXRoaXMuZ2V0U2NlbmVSZWN0KCkseC5pc0NsZWFyPSEwLGRlbGV0ZSB4LmlzQ2xlYXJBbGwpLHguaXNEcmF3QWxsJiYoeC5yZWN0PXRoaXMuZ2V0U2NlbmVSZWN0KCksZGVsZXRlIHguaXNEcmF3QWxsKSx4LmRyYXdDYW52YXMpe2NvbnN0IGc9eC5pc0Z1bGxXb3JrP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyOyhnPT1udWxsP3ZvaWQgMDpnLnBhcmVudCkucmVuZGVyKCl9aWYoeC5yZWN0KXt4LmNsZWFyQ2FudmFzPT09eC5kcmF3Q2FudmFzJiZ4LmRyYXdDYW52YXM9PT14dC5CZyYmKHgucmVjdD10aGlzLmNoZWNrUmlnaHRSZWN0Qm91bmRpbmdCb3goeC5yZWN0KSk7Y29uc3QgZz14LnJlY3Q7aWYoeC5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChZdCh4LnJlY3QpKSx4LmRyYXdDYW52YXMseHQuU2VsZWN0b3IsIXgucmVjdCljb250aW51ZTtpZih4LmRyYXdDYW52YXM9PT14dC5TZWxlY3Rvcil7Y29uc3QgeT0oYz1lLnNwKT09bnVsbD92b2lkIDA6Yy5maW5kKG09Pm0udHlwZT09PXV0LlNlbGVjdCk7eSYmKHkucmVjdD14LnJlY3QpLHgub2Zmc2V0PXt4OngucmVjdC54LWcueCx5OngucmVjdC55LWcueX19aWYoeC5kcmF3Q2FudmFzKXtjb25zdCB5PWF3YWl0IHRoaXMuZ2V0UmVjdEltYWdlQml0bWFwKHgucmVjdCwhIXguaXNGdWxsV29yayk7eC5pbWFnZUJpdG1hcD15LHN8fChzPVtdKSxzLnB1c2goeSl9bi5wdXNoKHgpfX1lLnJlbmRlcj1ufWNvbnN0IGw9KG89ZS5zcCk9PW51bGw/dm9pZCAwOm8uZmlsdGVyKHg9PngudHlwZSE9PXV0Lk5vbmV8fE9iamVjdC5rZXlzKHgpLmZpbHRlcihnPT5nPT09InR5cGUiKS5sZW5ndGgpO2lmKGwhPW51bGwmJmwubGVuZ3RoJiYoZS5zcD1sLm1hcCh4PT4oey4uLngsdmlld0lkOnRoaXMudmlld0lkfSkpKSwoZS5kcmF3Q291bnR8fGUud29ya2VyVGFza3NxdWV1ZUNvdW50fHwoZj1lLnNwKSE9bnVsbCYmZi5sZW5ndGh8fG4hPW51bGwmJm4ubGVuZ3RoKSYmKHRoaXMuX3Bvc3QoZSxzKSxzIT1udWxsJiZzLmxlbmd0aCkpZm9yKGNvbnN0IHggb2Ygcyl4IGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAmJnguY2xvc2UoKX1vbihlKXtpZih0aGlzLm1ldGhvZEJ1aWxkZXIuY29uc3VtZUZvcldvcmtlcihlKSlyZXR1cm47Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsd29ya0lkOm59PWU7c3dpdGNoKHQpe2Nhc2UgdXQuVXBkYXRlQ2FtZXJhOnRoaXMudXBkYXRlQ2FtZXJhKGUpO2JyZWFrO2Nhc2UgdXQuU2VsZWN0OnI9PT1QdC5TZXJ2aWNlJiYobj09PVJ0LnNlbGVjdG9ySWQ/dGhpcy5sb2NhbFdvcmsudXBkYXRlRnVsbFNlbGVjdFdvcmsoZSk6dGhpcy5zZXJ2aWNlV29yay5ydW5TZWxlY3RXb3JrKGUpKTticmVhaztjYXNlIHV0LlVwZGF0ZU5vZGU6Y2FzZSB1dC5GdWxsV29yazp0aGlzLmNvbnN1bWVGdWxsKHIsZSk7YnJlYWs7Y2FzZSB1dC5SZW1vdmVOb2RlOnRoaXMucmVtb3ZlTm9kZShlKTticmVhaztjYXNlIHV0LkdldFRleHRBY3RpdmU6dGhpcy5jaGVja1RleHRBY3RpdmUoZSk7YnJlYWt9c3VwZXIub24oZSl9cmVtb3ZlTm9kZShlKXtjb25zdHtkYXRhVHlwZTp0LHdvcmtJZDpyfT1lO3I9PT1SdC5zZWxlY3RvcklkJiZ0aGlzLmxvY2FsV29yay5ibHVyU2VsZWN0b3IoZSksdD09PVB0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsucmVtb3ZlV29yayhlKSx0PT09UHQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLnJlbW92ZVdvcmsoZSl9Y2hlY2tUZXh0QWN0aXZlKGUpe2NvbnN0e2RhdGFUeXBlOnR9PWU7dD09PVB0LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jaGVja1RleHRBY3RpdmUoZSl9Y2xlYXJBbGwoKXt0aGlzLnZOb2Rlcy5jbGVhcigpLHN1cGVyLmNsZWFyQWxsKCksdGhpcy5wb3N0KHtyZW5kZXI6W3tpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnh0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSx7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp4dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOlt7dHlwZTp1dC5DbGVhcn1dfSl9c2V0Q2FtZXJhT3B0KGUpe3RoaXMuY2FtZXJhT3B0PWU7Y29uc3R7c2NhbGU6dCxjZW50ZXJYOnIsY2VudGVyWTpuLHdpZHRoOnMsaGVpZ2h0Omx9PWU7KHMhPT10aGlzLnNjZW5lLndpZHRofHxsIT09dGhpcy5zY2VuZS5oZWlnaHQpJiZ0aGlzLnVwZGF0ZVNjZW5lKHt3aWR0aDpzLGhlaWdodDpsfSksdGhpcy5mdWxsTGF5ZXImJih0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNjYWxlIixbdCx0XSksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstciwtbl0pKSx0aGlzLmRyYXdMYXllciYmKHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFt0LHRdKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1yLC1uXSkpfWdldE9mZnNjcmVlbihlKXtyZXR1cm4oZT90aGlzLmZ1bGxMYXllci5wYXJlbnQ6dGhpcy5kcmF3TGF5ZXIucGFyZW50KS5jYW52YXN9Y29uc3VtZUZ1bGwoZSx0KXtlPT09UHQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVGdWxsKHQpO2NvbnN0IHI9dGhpcy5sb2NhbFdvcmsuY29sbG9jdEVmZmVjdFNlbGVjdFdvcmsodCk7ciYmZT09PVB0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZUZ1bGwocil9Y29uc3VtZURyYXcoZSx0KXtlPT09UHQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3KHQsdGhpcy5zZXJ2aWNlV29yayksZT09PVB0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZURyYXcodCl9Y29uc3VtZURyYXdBbGwoZSx0KXtlPT09UHQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3QWxsKHQsdGhpcy5zZXJ2aWNlV29yayl9dXBkYXRlQ2FtZXJhKGUpe2NvbnN0IHQ9W10se2NhbWVyYU9wdDpyfT1lO3ImJih0aGlzLnNldENhbWVyYU9wdChyKSx0aGlzLmxvY2FsV29yay53b3JrU2hhcGVzLmZvckVhY2goKG4scyk9Pnsobi50b29sc1R5cGU9PT12dC5QZW5jaWx8fG4udG9vbHNUeXBlPT09dnQuQXJyb3d8fG4udG9vbHNUeXBlPT09dnQuU3RyYWlnaHR8fG4udG9vbHNUeXBlPT09dnQuRWxsaXBzZXx8bi50b29sc1R5cGU9PT12dC5SZWN0YW5nbGV8fG4udG9vbHNUeXBlPT09dnQuU3Rhcnx8bi50b29sc1R5cGU9PT12dC5Qb2x5Z29ufHxuLnRvb2xzVHlwZT09PXZ0LlNwZWVjaEJhbGxvb258fG4udG9vbHNUeXBlPT09dnQuVGV4dCkmJnRoaXMubG9jYWxXb3JrLndvcmtTaGFwZVN0YXRlLnNldChzLHt3aWxsQ2xlYXI6ITB9KX0pLHRoaXMubG9jYWxXb3JrLnJ1bkVmZmVjdFdvcmsoKCk9PntpZih0aGlzLnNlcnZpY2VXb3JrLnNlbGVjdG9yV29ya1NoYXBlcy5zaXplKWZvcihjb25zdFtuLHNdb2YgdGhpcy5zZXJ2aWNlV29yay5zZWxlY3RvcldvcmtTaGFwZXMuZW50cmllcygpKXRoaXMuc2VydmljZVdvcmsucnVuU2VsZWN0V29yayh7d29ya0lkOm4sc2VsZWN0SWRzOnMuc2VsZWN0SWRzLG1zZ1R5cGU6dXQuU2VsZWN0LGRhdGFUeXBlOlB0LlNlcnZpY2Usdmlld0lkOnRoaXMudmlld0lkfSk7aWYodGhpcy52Tm9kZXMuaGFzUmVuZGVyTm9kZXMoKSl7bGV0IG47dC5wdXNoKHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnh0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSx7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp4dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2Zvcihjb25zdCBzIG9mIHRoaXMudk5vZGVzLmN1ck5vZGVNYXAudmFsdWVzKCkpY24ocy50b29sc1R5cGUpJiYobj1idChuLHMucmVjdCkpO24mJnQucHVzaCh7cmVjdDpmaChuLDEwMCksZHJhd0NhbnZhczp4dC5CZyxpc0NsZWFyOiExLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSl9dC5sZW5ndGgmJnRoaXMucG9zdCh7cmVuZGVyOnR9KX0pKX1nZXRSZWN0SW1hZ2VCaXRtYXAoZSx0KXtjb25zdCByPWUueCp0aGlzLmRwcixuPWUueSp0aGlzLmRwcixzPWUudyp0aGlzLmRwcixsPWUuaCp0aGlzLmRwcjtyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAodGhpcy5nZXRPZmZzY3JlZW4odCkscixuLHMsbCl9c2FmYXJpRml4UmVjdChlKXtpZihlLncrZS54PD0wfHxlLmgrZS55PD0wfHxlLnc8PTB8fGUuaDw9MClyZXR1cm47Y29uc3QgdD17eDowLHk6MCx3OnRoaXMuc2NlbmUud2lkdGgsaDp0aGlzLnNjZW5lLmhlaWdodH07aWYoZS54PDA/ZS53K2UueDx0aGlzLnNjZW5lLndpZHRoJiYodC53PWUudytlLngpOmUudytlLng+MCYmKHQueD1lLngsdC53PXRoaXMuc2NlbmUud2lkdGgtZS54KSxlLnk8MD9lLmgrZS55PHRoaXMuc2NlbmUuaGVpZ2h0JiYodC5oPWUuaCtlLnkpOmUuaCtlLnk+MCYmKHQueT1lLnksdC5oPXRoaXMuc2NlbmUuaGVpZ2h0LWUueSksISh0Lnc8PTB8fHQuaDw9MCkpcmV0dXJuIHR9Z2V0U2NlbmVSZWN0KCl7Y29uc3R7d2lkdGg6ZSxoZWlnaHQ6dH09dGhpcy5zY2VuZTtyZXR1cm57eDowLHk6MCx3OmUsaDp0fX1jaGVja1JpZ2h0UmVjdEJvdW5kaW5nQm94KGUpe3JldHVybiB0aGlzLnZOb2Rlcy5jb21iaW5lSW50ZXJzZWN0UmVjdChlKX19Y2xhc3Mgd2QgZXh0ZW5kcyBTbntjb25zdHJ1Y3RvcihlLHQscil7c3VwZXIoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3Bvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNuYXBzaG90RnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlcnZpY2VXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuX3Bvc3Q9cjtjb25zdCBuPXt2aWV3SWQ6dGhpcy52aWV3SWQsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXIscG9zdDp0aGlzLnBvc3QuYmluZCh0aGlzKX07dGhpcy5sb2NhbFdvcms9bmV3IElkKG4pLHRoaXMudk5vZGVzLmluaXQodGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpfWFzeW5jIHBvc3QoZSx0KXt2YXIgYyxvO2NvbnN0IHI9ZS5yZW5kZXIsbj1bXTtsZXQgcz10O2lmKHIhPW51bGwmJnIubGVuZ3RoKXtmb3IoY29uc3QgZiBvZiByKWlmKGYuZHJhd0NhbnZhcyYmdGhpcy5mdWxsTGF5ZXIucGFyZW50LnJlbmRlcigpLGYucmVjdCl7aWYoZi5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChZdChmLnJlY3QpKSwhZi5yZWN0KWNvbnRpbnVlO2lmKGYuZHJhd0NhbnZhcyl7Y29uc3QgeD1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcChmLnJlY3QsISFmLmlzRnVsbFdvcmspO2YuaW1hZ2VCaXRtYXA9eCxzfHwocz1bXSkscy5wdXNoKHgpfW4ucHVzaChmKX1lLnJlbmRlcj1ufWNvbnN0IGw9KGM9ZS5zcCk9PW51bGw/dm9pZCAwOmMuZmlsdGVyKGY9PmYudHlwZSE9PXV0Lk5vbmV8fE9iamVjdC5rZXlzKGYpLmZpbHRlcih4PT54PT09InR5cGUiKS5sZW5ndGgpO2lmKGwhPW51bGwmJmwubGVuZ3RoJiYoZS5zcD1sLm1hcChmPT4oey4uLmYsdmlld0lkOnRoaXMudmlld0lkfSkpKSwoKG89ZS5zcCkhPW51bGwmJm8ubGVuZ3RofHxlLmRyYXdDb3VudHx8biE9bnVsbCYmbi5sZW5ndGgpJiYodGhpcy5fcG9zdChlLHMpLHMhPW51bGwmJnMubGVuZ3RoKSlmb3IoY29uc3QgZiBvZiBzKWYgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCYmZi5jbG9zZSgpfW9uKGUpe2NvbnN0e21zZ1R5cGU6dH09ZTtzd2l0Y2godCl7Y2FzZSB1dC5VcGRhdGVDYW1lcmE6dGhpcy51cGRhdGVDYW1lcmEoZSk7YnJlYWs7Y2FzZSB1dC5TbmFwc2hvdDp0aGlzLnNuYXBzaG90RnVsbExheWVyPXRoaXMuY3JlYXRlTGF5ZXIoInNuYXBzaG90RnVsbExheWVyIix0aGlzLnNjZW5lLHsuLi50aGlzLm9wdC5sYXllck9wdCxidWZmZXJTaXplOnRoaXMudmlld0lkPT09Im1haW5WaWV3Ij82ZTM6M2UzfSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllciYmdGhpcy5nZXRTbmFwc2hvdChlKS50aGVuKCgpPT57dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj12b2lkIDB9KTticmVhaztjYXNlIHV0LkJvdW5kaW5nQm94OnRoaXMuc25hcHNob3RGdWxsTGF5ZXI9dGhpcy5jcmVhdGVMYXllcigic25hcHNob3RGdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnRoaXMub3B0LmxheWVyT3B0LGJ1ZmZlclNpemU6dGhpcy52aWV3SWQ9PT0ibWFpblZpZXciPzZlMzozZTN9KSx0aGlzLnNuYXBzaG90RnVsbExheWVyJiZ0aGlzLmdldEJvdW5kaW5nUmVjdChlKS50aGVuKCgpPT57dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj12b2lkIDB9KTticmVha31zdXBlci5vbihlKX1nZXRPZmZzY3JlZW4oZSl7dmFyIHQ7cmV0dXJuKHQ9KGUmJnRoaXMuc25hcHNob3RGdWxsTGF5ZXJ8fHRoaXMuZnVsbExheWVyKS5wYXJlbnQpPT1udWxsP3ZvaWQgMDp0LmNhbnZhc31jb25zdW1lRHJhdyhlLHQpe2U9PT1QdC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXcodCl9Y29uc3VtZURyYXdBbGwoZSx0KXt0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhd0FsbCh0KX1nZXRSZWN0SW1hZ2VCaXRtYXAoZSx0PSExLHIpe2NvbnN0IG49ZS54KnRoaXMuZHByLHM9ZS55KnRoaXMuZHByLGw9ZS53KnRoaXMuZHByLGM9ZS5oKnRoaXMuZHByO3JldHVybiBjcmVhdGVJbWFnZUJpdG1hcCh0aGlzLmdldE9mZnNjcmVlbih0KSxuLHMsbCxjLHIpfXNhZmFyaUZpeFJlY3QoZSl7aWYoZS53K2UueDw9MHx8ZS5oK2UueTw9MHx8ZS53PD0wfHxlLmg8PTApcmV0dXJuO2NvbnN0IHQ9e3g6MCx5OjAsdzp0aGlzLnNjZW5lLndpZHRoLGg6dGhpcy5zY2VuZS5oZWlnaHR9O2lmKGUueDwwP2UudytlLng8dGhpcy5zY2VuZS53aWR0aCYmKHQudz1lLncrZS54KTplLncrZS54PjAmJih0Lng9ZS54LHQudz10aGlzLnNjZW5lLndpZHRoLWUueCksZS55PDA/ZS5oK2UueTx0aGlzLnNjZW5lLmhlaWdodCYmKHQuaD1lLmgrZS55KTplLmgrZS55PjAmJih0Lnk9ZS55LHQuaD10aGlzLnNjZW5lLmhlaWdodC1lLnkpLCEodC53PD0wfHx0Lmg8PTApKXJldHVybiB0fXVwZGF0ZUNhbWVyYShlKXtjb25zdHtjYW1lcmFPcHQ6dH09ZTt0JiZ0aGlzLnNldENhbWVyYU9wdCh0KX1zZXRDYW1lcmFPcHQoZSx0KXt0aGlzLmNhbWVyYU9wdD1lO2NvbnN0e3NjYWxlOnIsY2VudGVyWDpuLGNlbnRlclk6cyx3aWR0aDpsLGhlaWdodDpjfT1lOyhsIT09dGhpcy5zY2VuZS53aWR0aHx8YyE9PXRoaXMuc2NlbmUuaGVpZ2h0KSYmdGhpcy51cGRhdGVTY2VuZSh7d2lkdGg6bCxoZWlnaHQ6Y30pLHQ/KHQuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3Iscl0pLHQuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstbiwtc10pKToodGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3Iscl0pLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLW4sLXNdKSl9YXN5bmMgZ2V0U25hcHNob3QoZSl7Y29uc3R7c2NlbmVQYXRoOnQsc2NlbmVzOnIsY2FtZXJhT3B0Om4sdzpzLGg6bH09ZTtpZih0JiZyJiZuJiZ0aGlzLnNuYXBzaG90RnVsbExheWVyKXtjb25zdCBjPVl0KHRoaXMuY2FtZXJhT3B0KTt0aGlzLnNldENhbWVyYU9wdChuLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIpLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLnNuYXBzaG90RnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj10aGlzLmZ1bGxMYXllcjtsZXQgbztjb25zdCBmPW5ldyBNYXA7Zm9yKGNvbnN0W2cseV1vZiBPYmplY3QuZW50cmllcyhyKSlpZih5IT1udWxsJiZ5LnR5cGUpc3dpdGNoKHk9PW51bGw/dm9pZCAwOnkudHlwZSl7Y2FzZSB1dC5VcGRhdGVOb2RlOmNhc2UgdXQuRnVsbFdvcms6e2NvbnN0e3Rvb2xzVHlwZTptLG9wdDpUfT15O209PT12dC5UZXh0JiZUJiYoVC5saW5lVGhyb3VnaHx8VC51bmRlcmxpbmUpJiZmLnNldChnLHkpO2NvbnN0IE89dGhpcy5sb2NhbFdvcmsucnVuRnVsbFdvcmsoey4uLnksd29ya0lkOmcsbXNnVHlwZTp1dC5GdWxsV29yayxkYXRhVHlwZTpQdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0sbT09PXZ0LlRleHQpO289YnQobyxPKTticmVha319dGhpcy5sb2NhbFdvcmsuZnVsbExheWVyPXRoaXMuZnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj12b2lkIDA7bGV0IHg7cyYmbCYmKHg9e3Jlc2l6ZVdpZHRoOnMscmVzaXplSGVpZ2h0Omx9KSxhd2FpdCBuZXcgUHJvbWlzZShnPT57c2V0VGltZW91dChnLDUwMCl9KSx0aGlzLndpbGxSZW5kZXJTcGVjaWFsTGFiZWwoZiksYXdhaXQgdGhpcy5nZXRTbmFwc2hvdFJlbmRlcih7c2NlbmVQYXRoOnQsY3VyQ2FtZXJhT3B0OmMsb3B0aW9uczp4LHdpbGxSZW5kZXJNYXA6Zn0pfX13aWxsUmVuZGVyU3BlY2lhbExhYmVsKGUpe3ZhciB0O2Zvcihjb25zdFtyLG5db2YgZS5lbnRyaWVzKCkpe2NvbnN0IHM9KHQ9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcik9PW51bGw/dm9pZCAwOnQuZ2V0RWxlbWVudHNCeU5hbWUocilbMF07cyYmbi5vcHQmJnRoaXMubG9jYWxXb3JrLnVwZGF0ZUxhYmVscyhzLG4pfX1hc3luYyBnZXRTbmFwc2hvdFJlbmRlcihlKXt2YXIgbCxjO2NvbnN0e3NjZW5lUGF0aDp0LGN1ckNhbWVyYU9wdDpyLG9wdGlvbnM6bn09ZTsoKGw9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcik9PW51bGw/dm9pZCAwOmwucGFyZW50KS5yZW5kZXIoKTtjb25zdCBzPWF3YWl0IHRoaXMuZ2V0UmVjdEltYWdlQml0bWFwKHt4OjAseTowLHc6dGhpcy5zY2VuZS53aWR0aCxoOnRoaXMuc2NlbmUuaGVpZ2h0fSwhMCxuKTtzJiYoYXdhaXQgdGhpcy5wb3N0KHtzcDpbe3R5cGU6dXQuU25hcHNob3Qsc2NlbmVQYXRoOnQsaW1hZ2VCaXRtYXA6c31dfSxbc10pLHMuY2xvc2UoKSwoYz10aGlzLnNuYXBzaG90RnVsbExheWVyKT09bnVsbHx8Yy5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuc2V0Q2FtZXJhT3B0KHIsdGhpcy5mdWxsTGF5ZXIpKX1hc3luYyBnZXRCb3VuZGluZ1JlY3QoZSl7Y29uc3R7c2NlbmVQYXRoOnQsc2NlbmVzOnIsY2FtZXJhT3B0Om59PWU7aWYodCYmciYmbiYmdGhpcy5zbmFwc2hvdEZ1bGxMYXllcil7Y29uc3Qgcz1ZdCh0aGlzLmNhbWVyYU9wdCk7dGhpcy5zZXRDYW1lcmFPcHQobix0aGlzLnNuYXBzaG90RnVsbExheWVyKSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dGhpcy5kcmF3TGF5ZXI7bGV0IGw7Zm9yKGNvbnN0W2Msb11vZiBPYmplY3QuZW50cmllcyhyKSlpZihvIT1udWxsJiZvLnR5cGUpc3dpdGNoKG89PW51bGw/dm9pZCAwOm8udHlwZSl7Y2FzZSB1dC5VcGRhdGVOb2RlOmNhc2UgdXQuRnVsbFdvcms6e2NvbnN0IGY9dGhpcy5sb2NhbFdvcmsucnVuRnVsbFdvcmsoey4uLm8sd29ya0lkOmMsbXNnVHlwZTp1dC5GdWxsV29yayxkYXRhVHlwZTpQdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2w9YnQobCxmKTticmVha319bCYmYXdhaXQgdGhpcy5wb3N0KHtzcDpbe3R5cGU6dXQuQm91bmRpbmdCb3gsc2NlbmVQYXRoOnQscmVjdDpsfV19KSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5mdWxsTGF5ZXIsdGhpcy5sb2NhbFdvcmsuZHJhd0xheWVyPXZvaWQgMCx0aGlzLnNuYXBzaG90RnVsbExheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5zZXRDYW1lcmFPcHQocyx0aGlzLmZ1bGxMYXllcil9fX1jb25zdCBOZD1zZWxmO25ldyBMZChOZCxQZS5GdWxsKX0pKCk7Cg==", Ss = typeof window < "u" && window.Blob && new Blob([atob(Wt)], { type: "text/javascript;charset=utf-8" });
function Io(b) {
  let d;
  try {
    if (d = Ss && (window.URL || window.webkitURL).createObjectURL(Ss), !d)
      throw "";
    const l = new Worker(d, {
      name: b == null ? void 0 : b.name
    });
    return l.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(d);
    }), l;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + Wt,
      {
        name: b == null ? void 0 : b.name
      }
    );
  } finally {
    d && (window.URL || window.webkitURL).revokeObjectURL(d);
  }
}
const ut = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBNZT10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIHBlKGQpe3JldHVybiBkJiZkLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLCJkZWZhdWx0Iik/ZC5kZWZhdWx0OmR9ZnVuY3Rpb24gTG4oKXt0aGlzLl9fZGF0YV9fPVtdLHRoaXMuc2l6ZT0wfXZhciBEbj1MbjtmdW5jdGlvbiB3bihkLGUpe3JldHVybiBkPT09ZXx8ZCE9PWQmJmUhPT1lfXZhciBvcj13bixObj1vcjtmdW5jdGlvbiBqbihkLGUpe2Zvcih2YXIgdD1kLmxlbmd0aDt0LS07KWlmKE5uKGRbdF1bMF0sZSkpcmV0dXJuIHQ7cmV0dXJuLTF9dmFyIFRlPWpuLEJuPVRlLFduPUFycmF5LnByb3RvdHlwZSxGbj1Xbi5zcGxpY2U7ZnVuY3Rpb24gVW4oZCl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PUJuKGUsZCk7aWYodDwwKXJldHVybiExO3ZhciByPWUubGVuZ3RoLTE7cmV0dXJuIHQ9PXI/ZS5wb3AoKTpGbi5jYWxsKGUsdCwxKSwtLXRoaXMuc2l6ZSwhMH12YXIgem49VW4sJG49VGU7ZnVuY3Rpb24gR24oZCl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PSRuKGUsZCk7cmV0dXJuIHQ8MD92b2lkIDA6ZVt0XVsxXX12YXIgS249R24sSG49VGU7ZnVuY3Rpb24gVm4oZCl7cmV0dXJuIEhuKHRoaXMuX19kYXRhX18sZCk+LTF9dmFyIFluPVZuLFhuPVRlO2Z1bmN0aW9uIEpuKGQsZSl7dmFyIHQ9dGhpcy5fX2RhdGFfXyxyPVhuKHQsZCk7cmV0dXJuIHI8MD8oKyt0aGlzLnNpemUsdC5wdXNoKFtkLGVdKSk6dFtyXVsxXT1lLHRoaXN9dmFyIFpuPUpuLFFuPURuLGtuPXpuLHFuPUtuLF9uPVluLHRpPVpuO2Z1bmN0aW9uIG9lKGQpe3ZhciBlPS0xLHQ9ZD09bnVsbD8wOmQubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj1kW2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fW9lLnByb3RvdHlwZS5jbGVhcj1RbixvZS5wcm90b3R5cGUuZGVsZXRlPWtuLG9lLnByb3RvdHlwZS5nZXQ9cW4sb2UucHJvdG90eXBlLmhhcz1fbixvZS5wcm90b3R5cGUuc2V0PXRpO3ZhciBFZT1vZSxlaT1FZTtmdW5jdGlvbiByaSgpe3RoaXMuX19kYXRhX189bmV3IGVpLHRoaXMuc2l6ZT0wfXZhciBuaT1yaTtmdW5jdGlvbiBpaShkKXt2YXIgZT10aGlzLl9fZGF0YV9fLHQ9ZS5kZWxldGUoZCk7cmV0dXJuIHRoaXMuc2l6ZT1lLnNpemUsdH12YXIgc2k9aWk7ZnVuY3Rpb24gb2koZCl7cmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGQpfXZhciBhaT1vaTtmdW5jdGlvbiBsaShkKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoZCl9dmFyIGNpPWxpLHVpPXR5cGVvZiBNZT09Im9iamVjdCImJk1lJiZNZS5PYmplY3Q9PT1PYmplY3QmJk1lLGFyPXVpLGZpPWFyLGhpPXR5cGVvZiBzZWxmPT0ib2JqZWN0IiYmc2VsZiYmc2VsZi5PYmplY3Q9PT1PYmplY3QmJnNlbGYsZGk9Zml8fGhpfHxGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpLFZ0PWRpLGdpPVZ0LG1pPWdpLlN5bWJvbCxGZT1taSxscj1GZSxjcj1PYmplY3QucHJvdG90eXBlLHZpPWNyLmhhc093blByb3BlcnR5LHBpPWNyLnRvU3RyaW5nLHllPWxyP2xyLnRvU3RyaW5nVGFnOnZvaWQgMDtmdW5jdGlvbiB5aShkKXt2YXIgZT12aS5jYWxsKGQseWUpLHQ9ZFt5ZV07dHJ5e2RbeWVdPXZvaWQgMDt2YXIgcj0hMH1jYXRjaHt9dmFyIG49cGkuY2FsbChkKTtyZXR1cm4gciYmKGU/ZFt5ZV09dDpkZWxldGUgZFt5ZV0pLG59dmFyIHhpPXlpLE9pPU9iamVjdC5wcm90b3R5cGUsUGk9T2kudG9TdHJpbmc7ZnVuY3Rpb24gYmkoZCl7cmV0dXJuIFBpLmNhbGwoZCl9dmFyIFNpPWJpLHVyPUZlLE1pPXhpLFRpPVNpLEVpPSJbb2JqZWN0IE51bGxdIixBaT0iW29iamVjdCBVbmRlZmluZWRdIixmcj11cj91ci50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24gQ2koZCl7cmV0dXJuIGQ9PW51bGw/ZD09PXZvaWQgMD9BaTpFaTpmciYmZnIgaW4gT2JqZWN0KGQpP01pKGQpOlRpKGQpfXZhciByZT1DaTtmdW5jdGlvbiBSaShkKXt2YXIgZT10eXBlb2YgZDtyZXR1cm4gZCE9bnVsbCYmKGU9PSJvYmplY3QifHxlPT0iZnVuY3Rpb24iKX12YXIgX3Q9UmksSWk9cmUsTGk9X3QsRGk9IltvYmplY3QgQXN5bmNGdW5jdGlvbl0iLHdpPSJbb2JqZWN0IEZ1bmN0aW9uXSIsTmk9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixqaT0iW29iamVjdCBQcm94eV0iO2Z1bmN0aW9uIEJpKGQpe2lmKCFMaShkKSlyZXR1cm4hMTt2YXIgZT1JaShkKTtyZXR1cm4gZT09d2l8fGU9PU5pfHxlPT1EaXx8ZT09aml9dmFyIGhyPUJpLFdpPVZ0LEZpPVdpWyJfX2NvcmUtanNfc2hhcmVkX18iXSxVaT1GaSxVZT1VaSxkcj1mdW5jdGlvbigpe3ZhciBkPS9bXi5dKyQvLmV4ZWMoVWUmJlVlLmtleXMmJlVlLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gZD8iU3ltYm9sKHNyYylfMS4iK2Q6IiJ9KCk7ZnVuY3Rpb24gemkoZCl7cmV0dXJuISFkciYmZHIgaW4gZH12YXIgJGk9emksR2k9RnVuY3Rpb24ucHJvdG90eXBlLEtpPUdpLnRvU3RyaW5nO2Z1bmN0aW9uIEhpKGQpe2lmKGQhPW51bGwpe3RyeXtyZXR1cm4gS2kuY2FsbChkKX1jYXRjaHt9dHJ5e3JldHVybiBkKyIifWNhdGNoe319cmV0dXJuIiJ9dmFyIGdyPUhpLFZpPWhyLFlpPSRpLFhpPV90LEppPWdyLFppPS9bXFxeJC4qKz8oKVtcXXt9fF0vZyxRaT0vXlxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXF0kLyxraT1GdW5jdGlvbi5wcm90b3R5cGUscWk9T2JqZWN0LnByb3RvdHlwZSxfaT1raS50b1N0cmluZyx0cz1xaS5oYXNPd25Qcm9wZXJ0eSxlcz1SZWdFeHAoIl4iK19pLmNhbGwodHMpLnJlcGxhY2UoWmksIlxcJCYiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcKCl8IGZvciAuKz8oPz1cXFxdKS9nLCIkMS4qPyIpKyIkIik7ZnVuY3Rpb24gcnMoZCl7aWYoIVhpKGQpfHxZaShkKSlyZXR1cm4hMTt2YXIgZT1WaShkKT9lczpRaTtyZXR1cm4gZS50ZXN0KEppKGQpKX12YXIgbnM9cnM7ZnVuY3Rpb24gaXMoZCxlKXtyZXR1cm4gZD09bnVsbD92b2lkIDA6ZFtlXX12YXIgc3M9aXMsb3M9bnMsYXM9c3M7ZnVuY3Rpb24gbHMoZCxlKXt2YXIgdD1hcyhkLGUpO3JldHVybiBvcyh0KT90OnZvaWQgMH12YXIgbmU9bHMsY3M9bmUsdXM9VnQsZnM9Y3ModXMsIk1hcCIpLHplPWZzLGhzPW5lLGRzPWhzKE9iamVjdCwiY3JlYXRlIiksQWU9ZHMsbXI9QWU7ZnVuY3Rpb24gZ3MoKXt0aGlzLl9fZGF0YV9fPW1yP21yKG51bGwpOnt9LHRoaXMuc2l6ZT0wfXZhciBtcz1ncztmdW5jdGlvbiB2cyhkKXt2YXIgZT10aGlzLmhhcyhkKSYmZGVsZXRlIHRoaXMuX19kYXRhX19bZF07cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX12YXIgcHM9dnMseXM9QWUseHM9Il9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18iLE9zPU9iamVjdC5wcm90b3R5cGUsUHM9T3MuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gYnMoZCl7dmFyIGU9dGhpcy5fX2RhdGFfXztpZih5cyl7dmFyIHQ9ZVtkXTtyZXR1cm4gdD09PXhzP3ZvaWQgMDp0fXJldHVybiBQcy5jYWxsKGUsZCk/ZVtkXTp2b2lkIDB9dmFyIFNzPWJzLE1zPUFlLFRzPU9iamVjdC5wcm90b3R5cGUsRXM9VHMuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gQXMoZCl7dmFyIGU9dGhpcy5fX2RhdGFfXztyZXR1cm4gTXM/ZVtkXSE9PXZvaWQgMDpFcy5jYWxsKGUsZCl9dmFyIENzPUFzLFJzPUFlLElzPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIjtmdW5jdGlvbiBMcyhkLGUpe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXMoZCk/MDoxLHRbZF09UnMmJmU9PT12b2lkIDA/SXM6ZSx0aGlzfXZhciBEcz1Mcyx3cz1tcyxOcz1wcyxqcz1TcyxCcz1DcyxXcz1EcztmdW5jdGlvbiBhZShkKXt2YXIgZT0tMSx0PWQ9PW51bGw/MDpkLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9ZFtlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1hZS5wcm90b3R5cGUuY2xlYXI9d3MsYWUucHJvdG90eXBlLmRlbGV0ZT1OcyxhZS5wcm90b3R5cGUuZ2V0PWpzLGFlLnByb3RvdHlwZS5oYXM9QnMsYWUucHJvdG90eXBlLnNldD1Xczt2YXIgRnM9YWUsdnI9RnMsVXM9RWUsenM9emU7ZnVuY3Rpb24gJHMoKXt0aGlzLnNpemU9MCx0aGlzLl9fZGF0YV9fPXtoYXNoOm5ldyB2cixtYXA6bmV3KHpzfHxVcyksc3RyaW5nOm5ldyB2cn19dmFyIEdzPSRzO2Z1bmN0aW9uIEtzKGQpe3ZhciBlPXR5cGVvZiBkO3JldHVybiBlPT0ic3RyaW5nInx8ZT09Im51bWJlciJ8fGU9PSJzeW1ib2wifHxlPT0iYm9vbGVhbiI/ZCE9PSJfX3Byb3RvX18iOmQ9PT1udWxsfXZhciBIcz1LcyxWcz1IcztmdW5jdGlvbiBZcyhkLGUpe3ZhciB0PWQuX19kYXRhX187cmV0dXJuIFZzKGUpP3RbdHlwZW9mIGU9PSJzdHJpbmciPyJzdHJpbmciOiJoYXNoIl06dC5tYXB9dmFyIENlPVlzLFhzPUNlO2Z1bmN0aW9uIEpzKGQpe3ZhciBlPVhzKHRoaXMsZCkuZGVsZXRlKGQpO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIFpzPUpzLFFzPUNlO2Z1bmN0aW9uIGtzKGQpe3JldHVybiBRcyh0aGlzLGQpLmdldChkKX12YXIgcXM9a3MsX3M9Q2U7ZnVuY3Rpb24gdG8oZCl7cmV0dXJuIF9zKHRoaXMsZCkuaGFzKGQpfXZhciBlbz10byxybz1DZTtmdW5jdGlvbiBubyhkLGUpe3ZhciB0PXJvKHRoaXMsZCkscj10LnNpemU7cmV0dXJuIHQuc2V0KGQsZSksdGhpcy5zaXplKz10LnNpemU9PXI/MDoxLHRoaXN9dmFyIGlvPW5vLHNvPUdzLG9vPVpzLGFvPXFzLGxvPWVvLGNvPWlvO2Z1bmN0aW9uIGxlKGQpe3ZhciBlPS0xLHQ9ZD09bnVsbD8wOmQubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj1kW2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fWxlLnByb3RvdHlwZS5jbGVhcj1zbyxsZS5wcm90b3R5cGUuZGVsZXRlPW9vLGxlLnByb3RvdHlwZS5nZXQ9YW8sbGUucHJvdG90eXBlLmhhcz1sbyxsZS5wcm90b3R5cGUuc2V0PWNvO3ZhciB1bz1sZSxmbz1FZSxobz16ZSxnbz11byxtbz0yMDA7ZnVuY3Rpb24gdm8oZCxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO2lmKHQgaW5zdGFuY2VvZiBmbyl7dmFyIHI9dC5fX2RhdGFfXztpZighaG98fHIubGVuZ3RoPG1vLTEpcmV0dXJuIHIucHVzaChbZCxlXSksdGhpcy5zaXplPSsrdC5zaXplLHRoaXM7dD10aGlzLl9fZGF0YV9fPW5ldyBnbyhyKX1yZXR1cm4gdC5zZXQoZCxlKSx0aGlzLnNpemU9dC5zaXplLHRoaXN9dmFyIHBvPXZvLHlvPUVlLHhvPW5pLE9vPXNpLFBvPWFpLGJvPWNpLFNvPXBvO2Z1bmN0aW9uIGNlKGQpe3ZhciBlPXRoaXMuX19kYXRhX189bmV3IHlvKGQpO3RoaXMuc2l6ZT1lLnNpemV9Y2UucHJvdG90eXBlLmNsZWFyPXhvLGNlLnByb3RvdHlwZS5kZWxldGU9T28sY2UucHJvdG90eXBlLmdldD1QbyxjZS5wcm90b3R5cGUuaGFzPWJvLGNlLnByb3RvdHlwZS5zZXQ9U287dmFyIE1vPWNlO2Z1bmN0aW9uIFRvKGQsZSl7Zm9yKHZhciB0PS0xLHI9ZD09bnVsbD8wOmQubGVuZ3RoOysrdDxyJiZlKGRbdF0sdCxkKSE9PSExOyk7cmV0dXJuIGR9dmFyIEVvPVRvLEFvPW5lLENvPWZ1bmN0aW9uKCl7dHJ5e3ZhciBkPUFvKE9iamVjdCwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gZCh7fSwiIix7fSksZH1jYXRjaHt9fSgpLFJvPUNvLHByPVJvO2Z1bmN0aW9uIElvKGQsZSx0KXtlPT0iX19wcm90b19fIiYmcHI/cHIoZCxlLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0LHdyaXRhYmxlOiEwfSk6ZFtlXT10fXZhciB5cj1JbyxMbz15cixEbz1vcix3bz1PYmplY3QucHJvdG90eXBlLE5vPXdvLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIGpvKGQsZSx0KXt2YXIgcj1kW2VdOyghKE5vLmNhbGwoZCxlKSYmRG8ocix0KSl8fHQ9PT12b2lkIDAmJiEoZSBpbiBkKSkmJkxvKGQsZSx0KX12YXIgeHI9am8sQm89eHIsV289eXI7ZnVuY3Rpb24gRm8oZCxlLHQscil7dmFyIG49IXQ7dHx8KHQ9e30pO2Zvcih2YXIgcz0tMSxsPWUubGVuZ3RoOysrczxsOyl7dmFyIGM9ZVtzXSxvPXI/cih0W2NdLGRbY10sYyx0LGQpOnZvaWQgMDtvPT09dm9pZCAwJiYobz1kW2NdKSxuP1dvKHQsYyxvKTpCbyh0LGMsbyl9cmV0dXJuIHR9dmFyIFJlPUZvO2Z1bmN0aW9uIFVvKGQsZSl7Zm9yKHZhciB0PS0xLHI9QXJyYXkoZCk7Kyt0PGQ7KXJbdF09ZSh0KTtyZXR1cm4gcn12YXIgem89VW87ZnVuY3Rpb24gJG8oZCl7cmV0dXJuIGQhPW51bGwmJnR5cGVvZiBkPT0ib2JqZWN0In12YXIgdGU9JG8sR289cmUsS289dGUsSG89IltvYmplY3QgQXJndW1lbnRzXSI7ZnVuY3Rpb24gVm8oZCl7cmV0dXJuIEtvKGQpJiZHbyhkKT09SG99dmFyIFlvPVZvLE9yPVlvLFhvPXRlLFByPU9iamVjdC5wcm90b3R5cGUsSm89UHIuaGFzT3duUHJvcGVydHksWm89UHIucHJvcGVydHlJc0VudW1lcmFibGUsUW89T3IoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT9PcjpmdW5jdGlvbihkKXtyZXR1cm4gWG8oZCkmJkpvLmNhbGwoZCwiY2FsbGVlIikmJiFaby5jYWxsKGQsImNhbGxlZSIpfSxrbz1Rbyxxbz1BcnJheS5pc0FycmF5LCRlPXFvLEllPXtleHBvcnRzOnt9fTtmdW5jdGlvbiBfbygpe3JldHVybiExfXZhciB0YT1fbztJZS5leHBvcnRzLGZ1bmN0aW9uKGQsZSl7dmFyIHQ9VnQscj10YSxuPWUmJiFlLm5vZGVUeXBlJiZlLHM9biYmITAmJmQmJiFkLm5vZGVUeXBlJiZkLGw9cyYmcy5leHBvcnRzPT09bixjPWw/dC5CdWZmZXI6dm9pZCAwLG89Yz9jLmlzQnVmZmVyOnZvaWQgMCxmPW98fHI7ZC5leHBvcnRzPWZ9KEllLEllLmV4cG9ydHMpO3ZhciBicj1JZS5leHBvcnRzLGVhPTkwMDcxOTkyNTQ3NDA5OTEscmE9L14oPzowfFsxLTldXGQqKSQvO2Z1bmN0aW9uIG5hKGQsZSl7dmFyIHQ9dHlwZW9mIGQ7cmV0dXJuIGU9ZT8/ZWEsISFlJiYodD09Im51bWJlciJ8fHQhPSJzeW1ib2wiJiZyYS50ZXN0KGQpKSYmZD4tMSYmZCUxPT0wJiZkPGV9dmFyIGlhPW5hLHNhPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24gb2EoZCl7cmV0dXJuIHR5cGVvZiBkPT0ibnVtYmVyIiYmZD4tMSYmZCUxPT0wJiZkPD1zYX12YXIgU3I9b2EsYWE9cmUsbGE9U3IsY2E9dGUsdWE9IltvYmplY3QgQXJndW1lbnRzXSIsZmE9IltvYmplY3QgQXJyYXldIixoYT0iW29iamVjdCBCb29sZWFuXSIsZGE9IltvYmplY3QgRGF0ZV0iLGdhPSJbb2JqZWN0IEVycm9yXSIsbWE9IltvYmplY3QgRnVuY3Rpb25dIix2YT0iW29iamVjdCBNYXBdIixwYT0iW29iamVjdCBOdW1iZXJdIix5YT0iW29iamVjdCBPYmplY3RdIix4YT0iW29iamVjdCBSZWdFeHBdIixPYT0iW29iamVjdCBTZXRdIixQYT0iW29iamVjdCBTdHJpbmddIixiYT0iW29iamVjdCBXZWFrTWFwXSIsU2E9IltvYmplY3QgQXJyYXlCdWZmZXJdIixNYT0iW29iamVjdCBEYXRhVmlld10iLFRhPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLEVhPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLEFhPSJbb2JqZWN0IEludDhBcnJheV0iLENhPSJbb2JqZWN0IEludDE2QXJyYXldIixSYT0iW29iamVjdCBJbnQzMkFycmF5XSIsSWE9IltvYmplY3QgVWludDhBcnJheV0iLExhPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsRGE9IltvYmplY3QgVWludDE2QXJyYXldIix3YT0iW29iamVjdCBVaW50MzJBcnJheV0iLGp0PXt9O2p0W1RhXT1qdFtFYV09anRbQWFdPWp0W0NhXT1qdFtSYV09anRbSWFdPWp0W0xhXT1qdFtEYV09anRbd2FdPSEwLGp0W3VhXT1qdFtmYV09anRbU2FdPWp0W2hhXT1qdFtNYV09anRbZGFdPWp0W2dhXT1qdFttYV09anRbdmFdPWp0W3BhXT1qdFt5YV09anRbeGFdPWp0W09hXT1qdFtQYV09anRbYmFdPSExO2Z1bmN0aW9uIE5hKGQpe3JldHVybiBjYShkKSYmbGEoZC5sZW5ndGgpJiYhIWp0W2FhKGQpXX12YXIgamE9TmE7ZnVuY3Rpb24gQmEoZCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBkKGUpfX12YXIgR2U9QmEsTGU9e2V4cG9ydHM6e319O0xlLmV4cG9ydHMsZnVuY3Rpb24oZCxlKXt2YXIgdD1hcixyPWUmJiFlLm5vZGVUeXBlJiZlLG49ciYmITAmJmQmJiFkLm5vZGVUeXBlJiZkLHM9biYmbi5leHBvcnRzPT09cixsPXMmJnQucHJvY2VzcyxjPWZ1bmN0aW9uKCl7dHJ5e3ZhciBvPW4mJm4ucmVxdWlyZSYmbi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7cmV0dXJuIG98fGwmJmwuYmluZGluZyYmbC5iaW5kaW5nKCJ1dGlsIil9Y2F0Y2h7fX0oKTtkLmV4cG9ydHM9Y30oTGUsTGUuZXhwb3J0cyk7dmFyIEtlPUxlLmV4cG9ydHMsV2E9amEsRmE9R2UsTXI9S2UsVHI9TXImJk1yLmlzVHlwZWRBcnJheSxVYT1Ucj9GYShUcik6V2EsemE9VWEsJGE9em8sR2E9a28sS2E9JGUsSGE9YnIsVmE9aWEsWWE9emEsWGE9T2JqZWN0LnByb3RvdHlwZSxKYT1YYS5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBaYShkLGUpe3ZhciB0PUthKGQpLHI9IXQmJkdhKGQpLG49IXQmJiFyJiZIYShkKSxzPSF0JiYhciYmIW4mJllhKGQpLGw9dHx8cnx8bnx8cyxjPWw/JGEoZC5sZW5ndGgsU3RyaW5nKTpbXSxvPWMubGVuZ3RoO2Zvcih2YXIgZiBpbiBkKShlfHxKYS5jYWxsKGQsZikpJiYhKGwmJihmPT0ibGVuZ3RoInx8biYmKGY9PSJvZmZzZXQifHxmPT0icGFyZW50Iil8fHMmJihmPT0iYnVmZmVyInx8Zj09ImJ5dGVMZW5ndGgifHxmPT0iYnl0ZU9mZnNldCIpfHxWYShmLG8pKSkmJmMucHVzaChmKTtyZXR1cm4gY312YXIgRXI9WmEsUWE9T2JqZWN0LnByb3RvdHlwZTtmdW5jdGlvbiBrYShkKXt2YXIgZT1kJiZkLmNvbnN0cnVjdG9yLHQ9dHlwZW9mIGU9PSJmdW5jdGlvbiImJmUucHJvdG90eXBlfHxRYTtyZXR1cm4gZD09PXR9dmFyIEhlPWthO2Z1bmN0aW9uIHFhKGQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBkKGUodCkpfX12YXIgQXI9cWEsX2E9QXIsdGw9X2EoT2JqZWN0LmtleXMsT2JqZWN0KSxlbD10bCxybD1IZSxubD1lbCxpbD1PYmplY3QucHJvdG90eXBlLHNsPWlsLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIG9sKGQpe2lmKCFybChkKSlyZXR1cm4gbmwoZCk7dmFyIGU9W107Zm9yKHZhciB0IGluIE9iamVjdChkKSlzbC5jYWxsKGQsdCkmJnQhPSJjb25zdHJ1Y3RvciImJmUucHVzaCh0KTtyZXR1cm4gZX12YXIgYWw9b2wsbGw9aHIsY2w9U3I7ZnVuY3Rpb24gdWwoZCl7cmV0dXJuIGQhPW51bGwmJmNsKGQubGVuZ3RoKSYmIWxsKGQpfXZhciBDcj11bCxmbD1FcixobD1hbCxkbD1DcjtmdW5jdGlvbiBnbChkKXtyZXR1cm4gZGwoZCk/ZmwoZCk6aGwoZCl9dmFyIFZlPWdsLG1sPVJlLHZsPVZlO2Z1bmN0aW9uIHBsKGQsZSl7cmV0dXJuIGQmJm1sKGUsdmwoZSksZCl9dmFyIHlsPXBsO2Z1bmN0aW9uIHhsKGQpe3ZhciBlPVtdO2lmKGQhPW51bGwpZm9yKHZhciB0IGluIE9iamVjdChkKSllLnB1c2godCk7cmV0dXJuIGV9dmFyIE9sPXhsLFBsPV90LGJsPUhlLFNsPU9sLE1sPU9iamVjdC5wcm90b3R5cGUsVGw9TWwuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gRWwoZCl7aWYoIVBsKGQpKXJldHVybiBTbChkKTt2YXIgZT1ibChkKSx0PVtdO2Zvcih2YXIgciBpbiBkKXI9PSJjb25zdHJ1Y3RvciImJihlfHwhVGwuY2FsbChkLHIpKXx8dC5wdXNoKHIpO3JldHVybiB0fXZhciBBbD1FbCxDbD1FcixSbD1BbCxJbD1DcjtmdW5jdGlvbiBMbChkKXtyZXR1cm4gSWwoZCk/Q2woZCwhMCk6UmwoZCl9dmFyIFllPUxsLERsPVJlLHdsPVllO2Z1bmN0aW9uIE5sKGQsZSl7cmV0dXJuIGQmJkRsKGUsd2woZSksZCl9dmFyIGpsPU5sLERlPXtleHBvcnRzOnt9fTtEZS5leHBvcnRzLGZ1bmN0aW9uKGQsZSl7dmFyIHQ9VnQscj1lJiYhZS5ub2RlVHlwZSYmZSxuPXImJiEwJiZkJiYhZC5ub2RlVHlwZSYmZCxzPW4mJm4uZXhwb3J0cz09PXIsbD1zP3QuQnVmZmVyOnZvaWQgMCxjPWw/bC5hbGxvY1Vuc2FmZTp2b2lkIDA7ZnVuY3Rpb24gbyhmLHgpe2lmKHgpcmV0dXJuIGYuc2xpY2UoKTt2YXIgZz1mLmxlbmd0aCx5PWM/YyhnKTpuZXcgZi5jb25zdHJ1Y3RvcihnKTtyZXR1cm4gZi5jb3B5KHkpLHl9ZC5leHBvcnRzPW99KERlLERlLmV4cG9ydHMpO3ZhciBCbD1EZS5leHBvcnRzO2Z1bmN0aW9uIFdsKGQsZSl7dmFyIHQ9LTEscj1kLmxlbmd0aDtmb3IoZXx8KGU9QXJyYXkocikpOysrdDxyOyllW3RdPWRbdF07cmV0dXJuIGV9dmFyIEZsPVdsO2Z1bmN0aW9uIFVsKGQsZSl7Zm9yKHZhciB0PS0xLHI9ZD09bnVsbD8wOmQubGVuZ3RoLG49MCxzPVtdOysrdDxyOyl7dmFyIGw9ZFt0XTtlKGwsdCxkKSYmKHNbbisrXT1sKX1yZXR1cm4gc312YXIgemw9VWw7ZnVuY3Rpb24gJGwoKXtyZXR1cm5bXX12YXIgUnI9JGwsR2w9emwsS2w9UnIsSGw9T2JqZWN0LnByb3RvdHlwZSxWbD1IbC5wcm9wZXJ0eUlzRW51bWVyYWJsZSxJcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFlsPUlyP2Z1bmN0aW9uKGQpe3JldHVybiBkPT1udWxsP1tdOihkPU9iamVjdChkKSxHbChJcihkKSxmdW5jdGlvbihlKXtyZXR1cm4gVmwuY2FsbChkLGUpfSkpfTpLbCxYZT1ZbCxYbD1SZSxKbD1YZTtmdW5jdGlvbiBabChkLGUpe3JldHVybiBYbChkLEpsKGQpLGUpfXZhciBRbD1abDtmdW5jdGlvbiBrbChkLGUpe2Zvcih2YXIgdD0tMSxyPWUubGVuZ3RoLG49ZC5sZW5ndGg7Kyt0PHI7KWRbbit0XT1lW3RdO3JldHVybiBkfXZhciBMcj1rbCxxbD1BcixfbD1xbChPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KSxEcj1fbCx0Yz1McixlYz1EcixyYz1YZSxuYz1ScixpYz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLHNjPWljP2Z1bmN0aW9uKGQpe2Zvcih2YXIgZT1bXTtkOyl0YyhlLHJjKGQpKSxkPWVjKGQpO3JldHVybiBlfTpuYyx3cj1zYyxvYz1SZSxhYz13cjtmdW5jdGlvbiBsYyhkLGUpe3JldHVybiBvYyhkLGFjKGQpLGUpfXZhciBjYz1sYyx1Yz1McixmYz0kZTtmdW5jdGlvbiBoYyhkLGUsdCl7dmFyIHI9ZShkKTtyZXR1cm4gZmMoZCk/cjp1YyhyLHQoZCkpfXZhciBOcj1oYyxkYz1OcixnYz1YZSxtYz1WZTtmdW5jdGlvbiB2YyhkKXtyZXR1cm4gZGMoZCxtYyxnYyl9dmFyIHBjPXZjLHljPU5yLHhjPXdyLE9jPVllO2Z1bmN0aW9uIFBjKGQpe3JldHVybiB5YyhkLE9jLHhjKX12YXIgYmM9UGMsU2M9bmUsTWM9VnQsVGM9U2MoTWMsIkRhdGFWaWV3IiksRWM9VGMsQWM9bmUsQ2M9VnQsUmM9QWMoQ2MsIlByb21pc2UiKSxJYz1SYyxMYz1uZSxEYz1WdCx3Yz1MYyhEYywiU2V0IiksTmM9d2MsamM9bmUsQmM9VnQsV2M9amMoQmMsIldlYWtNYXAiKSxGYz1XYyxKZT1FYyxaZT16ZSxRZT1JYyxrZT1OYyxxZT1GYyxqcj1yZSx1ZT1ncixCcj0iW29iamVjdCBNYXBdIixVYz0iW29iamVjdCBPYmplY3RdIixXcj0iW29iamVjdCBQcm9taXNlXSIsRnI9IltvYmplY3QgU2V0XSIsVXI9IltvYmplY3QgV2Vha01hcF0iLHpyPSJbb2JqZWN0IERhdGFWaWV3XSIsemM9dWUoSmUpLCRjPXVlKFplKSxHYz11ZShRZSksS2M9dWUoa2UpLEhjPXVlKHFlKSxpZT1qcjsoSmUmJmllKG5ldyBKZShuZXcgQXJyYXlCdWZmZXIoMSkpKSE9enJ8fFplJiZpZShuZXcgWmUpIT1Ccnx8UWUmJmllKFFlLnJlc29sdmUoKSkhPVdyfHxrZSYmaWUobmV3IGtlKSE9RnJ8fHFlJiZpZShuZXcgcWUpIT1VcikmJihpZT1mdW5jdGlvbihkKXt2YXIgZT1qcihkKSx0PWU9PVVjP2QuY29uc3RydWN0b3I6dm9pZCAwLHI9dD91ZSh0KToiIjtpZihyKXN3aXRjaChyKXtjYXNlIHpjOnJldHVybiB6cjtjYXNlICRjOnJldHVybiBCcjtjYXNlIEdjOnJldHVybiBXcjtjYXNlIEtjOnJldHVybiBGcjtjYXNlIEhjOnJldHVybiBVcn1yZXR1cm4gZX0pO3ZhciBfZT1pZSxWYz1PYmplY3QucHJvdG90eXBlLFljPVZjLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIFhjKGQpe3ZhciBlPWQubGVuZ3RoLHQ9bmV3IGQuY29uc3RydWN0b3IoZSk7cmV0dXJuIGUmJnR5cGVvZiBkWzBdPT0ic3RyaW5nIiYmWWMuY2FsbChkLCJpbmRleCIpJiYodC5pbmRleD1kLmluZGV4LHQuaW5wdXQ9ZC5pbnB1dCksdH12YXIgSmM9WGMsWmM9VnQsUWM9WmMuVWludDhBcnJheSxrYz1RYywkcj1rYztmdW5jdGlvbiBxYyhkKXt2YXIgZT1uZXcgZC5jb25zdHJ1Y3RvcihkLmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgJHIoZSkuc2V0KG5ldyAkcihkKSksZX12YXIgdHI9cWMsX2M9dHI7ZnVuY3Rpb24gdHUoZCxlKXt2YXIgdD1lP19jKGQuYnVmZmVyKTpkLmJ1ZmZlcjtyZXR1cm4gbmV3IGQuY29uc3RydWN0b3IodCxkLmJ5dGVPZmZzZXQsZC5ieXRlTGVuZ3RoKX12YXIgZXU9dHUscnU9L1x3KiQvO2Z1bmN0aW9uIG51KGQpe3ZhciBlPW5ldyBkLmNvbnN0cnVjdG9yKGQuc291cmNlLHJ1LmV4ZWMoZCkpO3JldHVybiBlLmxhc3RJbmRleD1kLmxhc3RJbmRleCxlfXZhciBpdT1udSxHcj1GZSxLcj1Hcj9Hci5wcm90b3R5cGU6dm9pZCAwLEhyPUtyP0tyLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIHN1KGQpe3JldHVybiBIcj9PYmplY3QoSHIuY2FsbChkKSk6e319dmFyIG91PXN1LGF1PXRyO2Z1bmN0aW9uIGx1KGQsZSl7dmFyIHQ9ZT9hdShkLmJ1ZmZlcik6ZC5idWZmZXI7cmV0dXJuIG5ldyBkLmNvbnN0cnVjdG9yKHQsZC5ieXRlT2Zmc2V0LGQubGVuZ3RoKX12YXIgY3U9bHUsdXU9dHIsZnU9ZXUsaHU9aXUsZHU9b3UsZ3U9Y3UsbXU9IltvYmplY3QgQm9vbGVhbl0iLHZ1PSJbb2JqZWN0IERhdGVdIixwdT0iW29iamVjdCBNYXBdIix5dT0iW29iamVjdCBOdW1iZXJdIix4dT0iW29iamVjdCBSZWdFeHBdIixPdT0iW29iamVjdCBTZXRdIixQdT0iW29iamVjdCBTdHJpbmddIixidT0iW29iamVjdCBTeW1ib2xdIixTdT0iW29iamVjdCBBcnJheUJ1ZmZlcl0iLE11PSJbb2JqZWN0IERhdGFWaWV3XSIsVHU9IltvYmplY3QgRmxvYXQzMkFycmF5XSIsRXU9IltvYmplY3QgRmxvYXQ2NEFycmF5XSIsQXU9IltvYmplY3QgSW50OEFycmF5XSIsQ3U9IltvYmplY3QgSW50MTZBcnJheV0iLFJ1PSJbb2JqZWN0IEludDMyQXJyYXldIixJdT0iW29iamVjdCBVaW50OEFycmF5XSIsTHU9IltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIixEdT0iW29iamVjdCBVaW50MTZBcnJheV0iLHd1PSJbb2JqZWN0IFVpbnQzMkFycmF5XSI7ZnVuY3Rpb24gTnUoZCxlLHQpe3ZhciByPWQuY29uc3RydWN0b3I7c3dpdGNoKGUpe2Nhc2UgU3U6cmV0dXJuIHV1KGQpO2Nhc2UgbXU6Y2FzZSB2dTpyZXR1cm4gbmV3IHIoK2QpO2Nhc2UgTXU6cmV0dXJuIGZ1KGQsdCk7Y2FzZSBUdTpjYXNlIEV1OmNhc2UgQXU6Y2FzZSBDdTpjYXNlIFJ1OmNhc2UgSXU6Y2FzZSBMdTpjYXNlIER1OmNhc2Ugd3U6cmV0dXJuIGd1KGQsdCk7Y2FzZSBwdTpyZXR1cm4gbmV3IHI7Y2FzZSB5dTpjYXNlIFB1OnJldHVybiBuZXcgcihkKTtjYXNlIHh1OnJldHVybiBodShkKTtjYXNlIE91OnJldHVybiBuZXcgcjtjYXNlIGJ1OnJldHVybiBkdShkKX19dmFyIGp1PU51LEJ1PV90LFZyPU9iamVjdC5jcmVhdGUsV3U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKCl7fXJldHVybiBmdW5jdGlvbihlKXtpZighQnUoZSkpcmV0dXJue307aWYoVnIpcmV0dXJuIFZyKGUpO2QucHJvdG90eXBlPWU7dmFyIHQ9bmV3IGQ7cmV0dXJuIGQucHJvdG90eXBlPXZvaWQgMCx0fX0oKSxGdT1XdSxVdT1GdSx6dT1EciwkdT1IZTtmdW5jdGlvbiBHdShkKXtyZXR1cm4gdHlwZW9mIGQuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiEkdShkKT9VdSh6dShkKSk6e319dmFyIEt1PUd1LEh1PV9lLFZ1PXRlLFl1PSJbb2JqZWN0IE1hcF0iO2Z1bmN0aW9uIFh1KGQpe3JldHVybiBWdShkKSYmSHUoZCk9PVl1fXZhciBKdT1YdSxadT1KdSxRdT1HZSxZcj1LZSxYcj1ZciYmWXIuaXNNYXAsa3U9WHI/UXUoWHIpOlp1LHF1PWt1LF91PV9lLHRmPXRlLGVmPSJbb2JqZWN0IFNldF0iO2Z1bmN0aW9uIHJmKGQpe3JldHVybiB0ZihkKSYmX3UoZCk9PWVmfXZhciBuZj1yZixzZj1uZixvZj1HZSxKcj1LZSxacj1KciYmSnIuaXNTZXQsYWY9WnI/b2YoWnIpOnNmLGxmPWFmLGNmPU1vLHVmPUVvLGZmPXhyLGhmPXlsLGRmPWpsLGdmPUJsLG1mPUZsLHZmPVFsLHBmPWNjLHlmPXBjLHhmPWJjLE9mPV9lLFBmPUpjLGJmPWp1LFNmPUt1LE1mPSRlLFRmPWJyLEVmPXF1LEFmPV90LENmPWxmLFJmPVZlLElmPVllLExmPTEsRGY9Mix3Zj00LFFyPSJbb2JqZWN0IEFyZ3VtZW50c10iLE5mPSJbb2JqZWN0IEFycmF5XSIsamY9IltvYmplY3QgQm9vbGVhbl0iLEJmPSJbb2JqZWN0IERhdGVdIixXZj0iW29iamVjdCBFcnJvcl0iLGtyPSJbb2JqZWN0IEZ1bmN0aW9uXSIsRmY9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixVZj0iW29iamVjdCBNYXBdIix6Zj0iW29iamVjdCBOdW1iZXJdIixxcj0iW29iamVjdCBPYmplY3RdIiwkZj0iW29iamVjdCBSZWdFeHBdIixHZj0iW29iamVjdCBTZXRdIixLZj0iW29iamVjdCBTdHJpbmddIixIZj0iW29iamVjdCBTeW1ib2xdIixWZj0iW29iamVjdCBXZWFrTWFwXSIsWWY9IltvYmplY3QgQXJyYXlCdWZmZXJdIixYZj0iW29iamVjdCBEYXRhVmlld10iLEpmPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLFpmPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFFmPSJbb2JqZWN0IEludDhBcnJheV0iLGtmPSJbb2JqZWN0IEludDE2QXJyYXldIixxZj0iW29iamVjdCBJbnQzMkFycmF5XSIsX2Y9IltvYmplY3QgVWludDhBcnJheV0iLHRoPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsZWg9IltvYmplY3QgVWludDE2QXJyYXldIixyaD0iW29iamVjdCBVaW50MzJBcnJheV0iLHd0PXt9O3d0W1FyXT13dFtOZl09d3RbWWZdPXd0W1hmXT13dFtqZl09d3RbQmZdPXd0W0pmXT13dFtaZl09d3RbUWZdPXd0W2tmXT13dFtxZl09d3RbVWZdPXd0W3pmXT13dFtxcl09d3RbJGZdPXd0W0dmXT13dFtLZl09d3RbSGZdPXd0W19mXT13dFt0aF09d3RbZWhdPXd0W3JoXT0hMCx3dFtXZl09d3Rba3JdPXd0W1ZmXT0hMTtmdW5jdGlvbiB3ZShkLGUsdCxyLG4scyl7dmFyIGwsYz1lJkxmLG89ZSZEZixmPWUmd2Y7aWYodCYmKGw9bj90KGQscixuLHMpOnQoZCkpLGwhPT12b2lkIDApcmV0dXJuIGw7aWYoIUFmKGQpKXJldHVybiBkO3ZhciB4PU1mKGQpO2lmKHgpe2lmKGw9UGYoZCksIWMpcmV0dXJuIG1mKGQsbCl9ZWxzZXt2YXIgZz1PZihkKSx5PWc9PWtyfHxnPT1GZjtpZihUZihkKSlyZXR1cm4gZ2YoZCxjKTtpZihnPT1xcnx8Zz09UXJ8fHkmJiFuKXtpZihsPW98fHk/e306U2YoZCksIWMpcmV0dXJuIG8/cGYoZCxkZihsLGQpKTp2ZihkLGhmKGwsZCkpfWVsc2V7aWYoIXd0W2ddKXJldHVybiBuP2Q6e307bD1iZihkLGcsYyl9fXN8fChzPW5ldyBjZik7dmFyIG09cy5nZXQoZCk7aWYobSlyZXR1cm4gbTtzLnNldChkLGwpLENmKGQpP2QuZm9yRWFjaChmdW5jdGlvbih2KXtsLmFkZCh3ZSh2LGUsdCx2LGQscykpfSk6RWYoZCkmJmQuZm9yRWFjaChmdW5jdGlvbih2LFApe2wuc2V0KFAsd2UodixlLHQsUCxkLHMpKX0pO3ZhciBUPWY/bz94Zjp5ZjpvP0lmOlJmLE89eD92b2lkIDA6VChkKTtyZXR1cm4gdWYoT3x8ZCxmdW5jdGlvbih2LFApe08mJihQPXYsdj1kW1BdKSxmZihsLFAsd2UodixlLHQsUCxkLHMpKX0pLGx9dmFyIG5oPXdlLGloPW5oLHNoPTEsb2g9NDtmdW5jdGlvbiBhaChkKXtyZXR1cm4gaWgoZCxzaHxvaCl9dmFyIGxoPWFoLFl0PXBlKGxoKSxfcjsoZnVuY3Rpb24oZCl7ZFtkLnBlZGRpbmc9MF09InBlZGRpbmciLGRbZC5tb3VudGVkPTFdPSJtb3VudGVkIixkW2QudXBkYXRlPTJdPSJ1cGRhdGUiLGRbZC51bm1vdW50ZWQ9M109InVubW91bnRlZCJ9KShfcnx8KF9yPXt9KSk7dmFyIHp0OyhmdW5jdGlvbihkKXtkW2QuTm9ybWFsPTBdPSJOb3JtYWwiLGRbZC5TdHJva2U9MV09IlN0cm9rZSIsZFtkLkRvdHRlZD0yXT0iRG90dGVkIixkW2QuTG9uZ0RvdHRlZD0zXT0iTG9uZ0RvdHRlZCJ9KSh6dHx8KHp0PXt9KSk7dmFyIHRuOyhmdW5jdGlvbihkKXtkLlRyaWFuZ2xlPSJ0cmlhbmdsZSIsZC5SaG9tYnVzPSJyaG9tYnVzIixkLlBlbnRhZ3JhbT0icGVudGFncmFtIixkLlNwZWVjaEJhbGxvb249InNwZWVjaEJhbGxvb24iLGQuU3Rhcj0ic3RhciIsZC5Qb2x5Z29uPSJwb2x5Z29uIn0pKHRufHwodG49e30pKTt2YXIgQ3Q7KGZ1bmN0aW9uKGQpe2QuTm9uZT0iTm9uZSIsZC5TaG93RmxvYXRCYXI9IlNob3dGbG9hdEJhciIsZC5aSW5kZXhGbG9hdEJhcj0iWkluZGV4RmxvYXRCYXIiLGQuRGVsZXRlTm9kZT0iRGVsZXRlTm9kZSIsZC5Db3B5Tm9kZT0iQ29weU5vZGUiLGQuWkluZGV4QWN0aXZlPSJaSW5kZXhBY3RpdmUiLGQuWkluZGV4Tm9kZT0iWkluZGV4Tm9kZSIsZC5Sb3RhdGVOb2RlPSJSb3RhdGVOb2RlIixkLlNldENvbG9yTm9kZT0iU2V0Q29sb3JOb2RlIixkLlRyYW5zbGF0ZU5vZGU9IlRyYW5zbGF0ZU5vZGUiLGQuU2NhbGVOb2RlPSJTY2FsZU5vZGUiLGQuT3JpZ2luYWxFdmVudD0iT3JpZ2luYWxFdmVudCIsZC5DcmVhdGVTY2VuZT0iQ3JlYXRlU2NlbmUiLGQuQWN0aXZlQ3Vyc29yPSJBY3RpdmVDdXJzb3IiLGQuTW92ZUN1cnNvcj0iTW92ZUN1cnNvciIsZC5Db21tYW5kRWRpdG9yPSJDb21tYW5kRWRpdG9yIixkLlNldEVkaXRvckRhdGE9IlNldEVkaXRvckRhdGEiLGQuU2V0Rm9udFN0eWxlPSJTZXRGb250U3R5bGUiLGQuU2V0UG9pbnQ9IlNldFBvaW50In0pKEN0fHwoQ3Q9e30pKTt2YXIgZW47KGZ1bmN0aW9uKGQpe2QuRGlzcGxheVN0YXRlPSJEaXNwbGF5U3RhdGUiLGQuRmxvYXRCYXI9IkZsb2F0QmFyIixkLkNhbnZhc1NlbGVjdG9yPSJDYW52YXNTZWxlY3RvciIsZC5NYWluRW5naW5lPSJNYWluRW5naW5lIixkLkRpc3BsYXlDb250YWluZXI9IkRpc3BsYXlDb250YWluZXIiLGQuQ3Vyc29yPSJDdXJzb3IiLGQuVGV4dEVkaXRvcj0iVGV4dEVkaXRvciIsZC5CaW5kTWFpblZpZXc9IkJpbmRNYWluVmlldyIsZC5Nb3VudE1haW5WaWV3PSJNb3VudE1haW5WaWV3IixkLk1vdW50QXBwVmlldz0iTW91bnRBcHBWaWV3In0pKGVufHwoZW49e30pKTt2YXIgcm47KGZ1bmN0aW9uKGQpe2RbZC5NYWluVmlldz0wXT0iTWFpblZpZXciLGRbZC5QbHVnaW49MV09IlBsdWdpbiIsZFtkLkJvdGg9Ml09IkJvdGgifSkocm58fChybj17fSkpO3ZhciB2dDsoZnVuY3Rpb24oZCl7ZFtkLlBlbmNpbD0xXT0iUGVuY2lsIixkW2QuRXJhc2VyPTJdPSJFcmFzZXIiLGRbZC5TZWxlY3Rvcj0zXT0iU2VsZWN0b3IiLGRbZC5DbGlja2VyPTRdPSJDbGlja2VyIixkW2QuQXJyb3c9NV09IkFycm93IixkW2QuSGFuZD02XT0iSGFuZCIsZFtkLkxhc2VyUGVuPTddPSJMYXNlclBlbiIsZFtkLlRleHQ9OF09IlRleHQiLGRbZC5TdHJhaWdodD05XT0iU3RyYWlnaHQiLGRbZC5SZWN0YW5nbGU9MTBdPSJSZWN0YW5nbGUiLGRbZC5FbGxpcHNlPTExXT0iRWxsaXBzZSIsZFtkLlN0YXI9MTJdPSJTdGFyIixkW2QuVHJpYW5nbGU9MTNdPSJUcmlhbmdsZSIsZFtkLlJob21idXM9MTRdPSJSaG9tYnVzIixkW2QuUG9seWdvbj0xNV09IlBvbHlnb24iLGRbZC5TcGVlY2hCYWxsb29uPTE2XT0iU3BlZWNoQmFsbG9vbiJ9KSh2dHx8KHZ0PXt9KSk7dmFyIFB0OyhmdW5jdGlvbihkKXtkW2QuTG9jYWw9MV09IkxvY2FsIixkW2QuU2VydmljZT0yXT0iU2VydmljZSIsZFtkLldvcmtlcj0zXT0iV29ya2VyIn0pKFB0fHwoUHQ9e30pKTt2YXIgSXQ7KGZ1bmN0aW9uKGQpe2RbZC5QZW5kaW5nPTBdPSJQZW5kaW5nIixkW2QuU3RhcnQ9MV09IlN0YXJ0IixkW2QuRG9pbmc9Ml09IkRvaW5nIixkW2QuRG9uZT0zXT0iRG9uZSIsZFtkLkZyZWV6ZT00XT0iRnJlZXplIixkW2QuVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KShJdHx8KEl0PXt9KSk7dmFyIHV0OyhmdW5jdGlvbihkKXtkW2QuSW5pdD0wXT0iSW5pdCIsZFtkLlVwZGF0ZUNhbWVyYT0xXT0iVXBkYXRlQ2FtZXJhIixkW2QuVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixkW2QuQ3JlYXRlV29yaz0zXT0iQ3JlYXRlV29yayIsZFtkLkRyYXdXb3JrPTRdPSJEcmF3V29yayIsZFtkLkZ1bGxXb3JrPTVdPSJGdWxsV29yayIsZFtkLlVwZGF0ZU5vZGU9Nl09IlVwZGF0ZU5vZGUiLGRbZC5SZW1vdmVOb2RlPTddPSJSZW1vdmVOb2RlIixkW2QuQ2xlYXI9OF09IkNsZWFyIixkW2QuU2VsZWN0PTldPSJTZWxlY3QiLGRbZC5EZXN0cm95PTEwXT0iRGVzdHJveSIsZFtkLk5vbmU9MTFdPSJOb25lIixkW2QuU25hcHNob3Q9MTJdPSJTbmFwc2hvdCIsZFtkLkJvdW5kaW5nQm94PTEzXT0iQm91bmRpbmdCb3giLGRbZC5DdXJzb3I9MTRdPSJDdXJzb3IiLGRbZC5UZXh0VXBkYXRlPTE1XT0iVGV4dFVwZGF0ZSIsZFtkLkdldFRleHRBY3RpdmU9MTZdPSJHZXRUZXh0QWN0aXZlIixkW2QuVGFza3NRdWV1ZT0xN109IlRhc2tzUXVldWUifSkodXR8fCh1dD17fSkpO3ZhciBubjsoZnVuY3Rpb24oZCl7ZC5XZWJnbDI9IndlYmdsMiIsZC5XZWJnbD0id2ViZ2wiLGQuQ2FudmFzMmQ9IjJkIn0pKG5ufHwobm49e30pKTt2YXIgeHQ7KGZ1bmN0aW9uKGQpe2RbZC5GbG9hdD0xXT0iRmxvYXQiLGRbZC5CZz0yXT0iQmciLGRbZC5TZWxlY3Rvcj0zXT0iU2VsZWN0b3IiLGRbZC5Ob25lPTRdPSJOb25lIn0pKHh0fHwoeHQ9e30pKTt2YXIgc247KGZ1bmN0aW9uKGQpe2RbZC5DdXJzb3I9MV09IkN1cnNvciIsZFtkLlRleHRDcmVhdGU9Ml09IlRleHRDcmVhdGUifSkoc258fChzbj17fSkpO3ZhciBvbjsoZnVuY3Rpb24oZCl7ZFtkLlRvcD0xXT0iVG9wIixkW2QuQm90dG9tPTJdPSJCb3R0b20ifSkob258fChvbj17fSkpO3ZhciBLdDsoZnVuY3Rpb24oZCl7ZFtkLm5vbmU9MV09Im5vbmUiLGRbZC5hbGw9Ml09ImFsbCIsZFtkLmJvdGg9M109ImJvdGgifSkoS3R8fChLdD17fSkpO2NsYXNzIFF0e2NvbnN0cnVjdG9yKCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pfXJlZ2lzdGVyRm9yV29ya2VyKGUsdCl7cmV0dXJuIHRoaXMubG9jYWxXb3JrPWUsdGhpcy5zZXJ2aWNlV29yaz10LHRoaXN9fWNvbnN0IGNoPXtsaW5lYXI6ZD0+ZCxlYXNlSW5RdWFkOmQ9PmQqZCxlYXNlT3V0UXVhZDpkPT5kKigyLWQpLGVhc2VJbk91dFF1YWQ6ZD0+ZDwuNT8yKmQqZDotMSsoNC0yKmQpKmQsZWFzZUluQ3ViaWM6ZD0+ZCpkKmQsZWFzZU91dEN1YmljOmQ9Pi0tZCpkKmQrMSxlYXNlSW5PdXRDdWJpYzpkPT5kPC41PzQqZCpkKmQ6KGQtMSkqKDIqZC0yKSooMipkLTIpKzEsZWFzZUluUXVhcnQ6ZD0+ZCpkKmQqZCxlYXNlT3V0UXVhcnQ6ZD0+MS0gLS1kKmQqZCpkLGVhc2VJbk91dFF1YXJ0OmQ9PmQ8LjU/OCpkKmQqZCpkOjEtOCotLWQqZCpkKmQsZWFzZUluUXVpbnQ6ZD0+ZCpkKmQqZCpkLGVhc2VPdXRRdWludDpkPT4xKy0tZCpkKmQqZCpkLGVhc2VJbk91dFF1aW50OmQ9PmQ8LjU/MTYqZCpkKmQqZCpkOjErMTYqLS1kKmQqZCpkKmQsZWFzZUluU2luZTpkPT4xLU1hdGguY29zKGQqTWF0aC5QSS8yKSxlYXNlT3V0U2luZTpkPT5NYXRoLnNpbihkKk1hdGguUEkvMiksZWFzZUluT3V0U2luZTpkPT4tKE1hdGguY29zKE1hdGguUEkqZCktMSkvMixlYXNlSW5FeHBvOmQ9PmQ8PTA/MDpNYXRoLnBvdygyLDEwKmQtMTApLGVhc2VPdXRFeHBvOmQ9PmQ+PTE/MToxLU1hdGgucG93KDIsLTEwKmQpLGVhc2VJbk91dEV4cG86ZD0+ZDw9MD8wOmQ+PTE/MTpkPC41P01hdGgucG93KDIsMjAqZC0xMCkvMjooMi1NYXRoLnBvdygyLC0yMCpkKzEwKSkvMn07Y2xhc3MgX3tjb25zdHJ1Y3RvcihlPTAsdD0wLHI9MSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyfSl9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldHooZSl7cmV0dXJuIHRoaXMuej1lLHRoaXN9c2V0WFkoZT10aGlzLngsdD10aGlzLnkpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxyPXRoaXMueil7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9c2V0VG8oe3g6ZT0wLHk6dD0wLHo6cj0xfSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1yLHRoaXN9cm90KGUpe2lmKGU9PT0wKXJldHVybiB0aGlzO2NvbnN0e3g6dCx5OnJ9PXRoaXMsbj1NYXRoLnNpbihlKSxzPU1hdGguY29zKGUpO3JldHVybiB0aGlzLng9dCpzLXIqbix0aGlzLnk9dCpuK3Iqcyx0aGlzfXJvdFdpdGgoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztjb25zdCByPXRoaXMueC1lLngsbj10aGlzLnktZS55LHM9TWF0aC5zaW4odCksbD1NYXRoLmNvcyh0KTtyZXR1cm4gdGhpcy54PWUueCsocipsLW4qcyksdGhpcy55PWUueSsocipzK24qbCksdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpyfT10aGlzO3JldHVybiBuZXcgXyhlLHQscil9c3ViKGUpe3JldHVybiB0aGlzLngtPWUueCx0aGlzLnktPWUueSx0aGlzfXN1YlhZKGUsdCl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPXQsdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpc31hZGQoZSl7cmV0dXJuIHRoaXMueCs9ZS54LHRoaXMueSs9ZS55LHRoaXN9YWRkWFkoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9dCx0aGlzfWFkZFNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9ZSx0aGlzfWNsYW1wKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsZSksdGhpcy55PU1hdGgubWF4KHRoaXMueSxlKSx0IT09dm9pZCAwJiYodGhpcy54PU1hdGgubWluKHRoaXMueCx0KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQpKSx0aGlzfWRpdihlKXtyZXR1cm4gdGhpcy54Lz1lLHRoaXMueS89ZSx0aGlzfWRpdlYoZSl7cmV0dXJuIHRoaXMueC89ZS54LHRoaXMueS89ZS55LHRoaXN9bXVsKGUpe3JldHVybiB0aGlzLngqPWUsdGhpcy55Kj1lLHRoaXN9bXVsVihlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpc31hYnMoKXtyZXR1cm4gdGhpcy54PU1hdGguYWJzKHRoaXMueCksdGhpcy55PU1hdGguYWJzKHRoaXMueSksdGhpc31udWRnZShlLHQpe2NvbnN0IHI9Xy5UYW4oZSx0aGlzKTtyZXR1cm4gdGhpcy5hZGQoci5tdWwodCkpfW5lZygpe3JldHVybiB0aGlzLngqPS0xLHRoaXMueSo9LTEsdGhpc31jcm9zcyhlKXtyZXR1cm4gdGhpcy54PXRoaXMueSplLnotdGhpcy56KmUueSx0aGlzLnk9dGhpcy56KmUueC10aGlzLngqZS56LHRoaXN9ZHByKGUpe3JldHVybiBfLkRwcih0aGlzLGUpfWNwcihlKXtyZXR1cm4gXy5DcHIodGhpcyxlKX1sZW4yKCl7cmV0dXJuIF8uTGVuMih0aGlzKX1sZW4oKXtyZXR1cm4gXy5MZW4odGhpcyl9cHJ5KGUpe3JldHVybiBfLlByeSh0aGlzLGUpfXBlcigpe2NvbnN0e3g6ZSx5OnR9PXRoaXM7cmV0dXJuIHRoaXMueD10LHRoaXMueT0tZSx0aGlzfXVuaSgpe3JldHVybiBfLlVuaSh0aGlzKX10YW4oZSl7cmV0dXJuIF8uVGFuKHRoaXMsZSl9ZGlzdChlKXtyZXR1cm4gXy5EaXN0KHRoaXMsZSl9ZGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCl7cmV0dXJuIF8uRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCx0aGlzKX1zbG9wZShlKXtyZXR1cm4gXy5TbG9wZSh0aGlzLGUpfXNuYXBUb0dyaWQoZSl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueC9lKSplLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueS9lKSplLHRoaXN9YW5nbGUoZSl7cmV0dXJuIF8uQW5nbGUodGhpcyxlKX10b0FuZ2xlKCl7cmV0dXJuIF8uVG9BbmdsZSh0aGlzKX1scnAoZSx0KXtyZXR1cm4gdGhpcy54PXRoaXMueCsoZS54LXRoaXMueCkqdCx0aGlzLnk9dGhpcy55KyhlLnktdGhpcy55KSp0LHRoaXN9ZXF1YWxzKGUsdCl7cmV0dXJuIF8uRXF1YWxzKHRoaXMsZSx0KX1lcXVhbHNYWShlLHQpe3JldHVybiBfLkVxdWFsc1hZKHRoaXMsZSx0KX1ub3JtKCl7Y29uc3QgZT10aGlzLmxlbigpO3JldHVybiB0aGlzLng9ZT09PTA/MDp0aGlzLngvZSx0aGlzLnk9ZT09PTA/MDp0aGlzLnkvZSx0aGlzfXRvRml4ZWQoKXtyZXR1cm4gXy5Ub0ZpeGVkKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuIF8uVG9TdHJpbmcoXy5Ub0ZpeGVkKHRoaXMpKX10b0pzb24oKXtyZXR1cm4gXy5Ub0pzb24odGhpcyl9dG9BcnJheSgpe3JldHVybiBfLlRvQXJyYXkodGhpcyl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgXyhlLngrdC54LGUueSt0LnkpfXN0YXRpYyBBZGRYWShlLHQscil7cmV0dXJuIG5ldyBfKGUueCt0LGUueStyKX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBfKGUueC10LngsZS55LXQueSl9c3RhdGljIFN1YlhZKGUsdCxyKXtyZXR1cm4gbmV3IF8oZS54LXQsZS55LXIpfXN0YXRpYyBBZGRTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IF8oZS54K3QsZS55K3QpfXN0YXRpYyBTdWJTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IF8oZS54LXQsZS55LXQpfXN0YXRpYyBEaXYoZSx0KXtyZXR1cm4gbmV3IF8oZS54L3QsZS55L3QpfXN0YXRpYyBNdWwoZSx0KXtyZXR1cm4gbmV3IF8oZS54KnQsZS55KnQpfXN0YXRpYyBEaXZWKGUsdCl7cmV0dXJuIG5ldyBfKGUueC90LngsZS55L3QueSl9c3RhdGljIE11bFYoZSx0KXtyZXR1cm4gbmV3IF8oZS54KnQueCxlLnkqdC55KX1zdGF0aWMgTmVnKGUpe3JldHVybiBuZXcgXygtZS54LC1lLnkpfXN0YXRpYyBQZXIoZSl7cmV0dXJuIG5ldyBfKGUueSwtZS54KX1zdGF0aWMgRGlzdDIoZSx0KXtyZXR1cm4gXy5TdWIoZSx0KS5sZW4yKCl9c3RhdGljIEFicyhlKXtyZXR1cm4gbmV3IF8oTWF0aC5hYnMoZS54KSxNYXRoLmFicyhlLnkpKX1zdGF0aWMgRGlzdChlLHQpe3JldHVybiBNYXRoLmh5cG90KGUueS10LnksZS54LXQueCl9c3RhdGljIERwcihlLHQpe3JldHVybiBlLngqdC54K2UueSp0Lnl9c3RhdGljIENyb3NzKGUsdCl7cmV0dXJuIG5ldyBfKGUueSp0LnotZS56KnQueSxlLnoqdC54LWUueCp0LnopfXN0YXRpYyBDcHIoZSx0KXtyZXR1cm4gZS54KnQueS10LngqZS55fXN0YXRpYyBMZW4yKGUpe3JldHVybiBlLngqZS54K2UueSplLnl9c3RhdGljIExlbihlKXtyZXR1cm4gTWF0aC5oeXBvdChlLngsZS55KX1zdGF0aWMgUHJ5KGUsdCl7cmV0dXJuIF8uRHByKGUsdCkvXy5MZW4odCl9c3RhdGljIFVuaShlKXtyZXR1cm4gXy5EaXYoZSxfLkxlbihlKSl9c3RhdGljIFRhbihlLHQpe3JldHVybiBfLlVuaShfLlN1YihlLHQpKX1zdGF0aWMgTWluKGUsdCl7cmV0dXJuIG5ldyBfKE1hdGgubWluKGUueCx0LngpLE1hdGgubWluKGUueSx0LnkpKX1zdGF0aWMgTWF4KGUsdCl7cmV0dXJuIG5ldyBfKE1hdGgubWF4KGUueCx0LngpLE1hdGgubWF4KGUueSx0LnkpKX1zdGF0aWMgRnJvbShlKXtyZXR1cm4gbmV3IF8oKS5hZGQoZSl9c3RhdGljIEZyb21BcnJheShlKXtyZXR1cm4gbmV3IF8oZVswXSxlWzFdKX1zdGF0aWMgUm90KGUsdD0wKXtjb25zdCByPU1hdGguc2luKHQpLG49TWF0aC5jb3ModCk7cmV0dXJuIG5ldyBfKGUueCpuLWUueSpyLGUueCpyK2UueSpuKX1zdGF0aWMgUm90V2l0aChlLHQscil7Y29uc3Qgbj1lLngtdC54LHM9ZS55LXQueSxsPU1hdGguc2luKHIpLGM9TWF0aC5jb3Mocik7cmV0dXJuIG5ldyBfKHQueCsobipjLXMqbCksdC55KyhuKmwrcypjKSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQscil7cmV0dXJuIF8uTXVsKHQsXy5TdWIocixlKS5wcnkodCkpLmFkZChlKX1zdGF0aWMgTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQscixuPSEwKXtjb25zdCBzPV8uVGFuKHQsZSksbD1fLkFkZChlLF8uTXVsKHMsXy5TdWIocixlKS5wcnkocykpKTtpZihuKXtpZihsLng8TWF0aC5taW4oZS54LHQueCkpcmV0dXJuIF8uQ2FzdChlLng8dC54P2U6dCk7aWYobC54Pk1hdGgubWF4KGUueCx0LngpKXJldHVybiBfLkNhc3QoZS54PnQueD9lOnQpO2lmKGwueTxNYXRoLm1pbihlLnksdC55KSlyZXR1cm4gXy5DYXN0KGUueTx0Lnk/ZTp0KTtpZihsLnk+TWF0aC5tYXgoZS55LHQueSkpcmV0dXJuIF8uQ2FzdChlLnk+dC55P2U6dCl9cmV0dXJuIGx9c3RhdGljIERpc3RhbmNlVG9MaW5lVGhyb3VnaFBvaW50KGUsdCxyKXtyZXR1cm4gXy5EaXN0KHIsXy5OZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LHIpKX1zdGF0aWMgRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCxyLG49ITApe3JldHVybiBfLkRpc3QocixfLk5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoZSx0LHIsbikpfXN0YXRpYyBTbmFwKGUsdD0xKXtyZXR1cm4gbmV3IF8oTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX1zdGF0aWMgQ2FzdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIF8/ZTpfLkZyb20oZSl9c3RhdGljIFNsb3BlKGUsdCl7cmV0dXJuIGUueD09PXQueT9OYU46KGUueS10LnkpLyhlLngtdC54KX1zdGF0aWMgQW5nbGUoZSx0KXtyZXR1cm4gTWF0aC5hdGFuMih0LnktZS55LHQueC1lLngpfXN0YXRpYyBMcnAoZSx0LHIpe3JldHVybiBfLlN1Yih0LGUpLm11bChyKS5hZGQoZSl9c3RhdGljIE1lZChlLHQpe3JldHVybiBuZXcgXygoZS54K3QueCkvMiwoZS55K3QueSkvMil9c3RhdGljIEVxdWFscyhlLHQscj0xZS00KXtyZXR1cm4gTWF0aC5hYnMoZS54LXQueCk8ciYmTWF0aC5hYnMoZS55LXQueSk8cn1zdGF0aWMgRXF1YWxzWFkoZSx0LHIpe3JldHVybiBlLng9PT10JiZlLnk9PT1yfXN0YXRpYyBFcXVhbHNYWVooZSx0LHI9MWUtNCl7cmV0dXJuIF8uRXF1YWxzKGUsdCxyKSYmTWF0aC5hYnMoKGUuenx8MCktKHQuenx8MCkpPHJ9c3RhdGljIENsb2Nrd2lzZShlLHQscil7cmV0dXJuKHIueC1lLngpKih0LnktZS55KS0odC54LWUueCkqKHIueS1lLnkpPDB9c3RhdGljIFJlc2NhbGUoZSx0KXtjb25zdCByPV8uTGVuKGUpO3JldHVybiBuZXcgXyh0KmUueC9yLHQqZS55L3IpfXN0YXRpYyBTY2FsZVdpdGhPcmlnaW4oZSx0LHIpe3JldHVybiBfLlN1YihlLHIpLm11bCh0KS5hZGQocil9c3RhdGljIFNjYWxlV09yaWdpbihlLHQscil7cmV0dXJuIF8uU3ViKGUscikubXVsVih0KS5hZGQocil9c3RhdGljIFRvRml4ZWQoZSx0PTIpe3JldHVybiBuZXcgXygrZS54LnRvRml4ZWQodCksK2UueS50b0ZpeGVkKHQpLCtlLnoudG9GaXhlZCh0KSl9c3RhdGljIE51ZGdlKGUsdCxyKXtyZXR1cm4gXy5BZGQoZSxfLlRhbih0LGUpLm11bChyKSl9c3RhdGljIFRvU3RyaW5nKGUpe3JldHVybmAke2UueH0sICR7ZS55fWB9c3RhdGljIFRvQW5nbGUoZSl7bGV0IHQ9TWF0aC5hdGFuMihlLnksZS54KTtyZXR1cm4gdDwwJiYodCs9TWF0aC5QSSoyKSx0fXN0YXRpYyBGcm9tQW5nbGUoZSx0PTEpe3JldHVybiBuZXcgXyhNYXRoLmNvcyhlKSp0LE1hdGguc2luKGUpKnQpfXN0YXRpYyBUb0FycmF5KGUpe3JldHVybltlLngsZS55LGUuel19c3RhdGljIFRvSnNvbihlKXtjb25zdHt4OnQseTpyLHo6bn09ZTtyZXR1cm57eDp0LHk6cix6Om59fXN0YXRpYyBBdmVyYWdlKGUpe2NvbnN0IHQ9ZS5sZW5ndGgscj1uZXcgXygwLDApO2ZvcihsZXQgbj0wO248dDtuKyspci5hZGQoZVtuXSk7cmV0dXJuIHIuZGl2KHQpfXN0YXRpYyBDbGFtcChlLHQscil7cmV0dXJuIHI9PT12b2lkIDA/bmV3IF8oTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkpKTpuZXcgXyhNYXRoLm1pbihNYXRoLm1heChlLngsdCksciksTWF0aC5taW4oTWF0aC5tYXgoZS55LHQpLHIpKX1zdGF0aWMgUG9pbnRzQmV0d2VlbihlLHQscj02KXtjb25zdCBuPVtdO2ZvcihsZXQgcz0wO3M8cjtzKyspe2NvbnN0IGw9Y2guZWFzZUluUXVhZChzLyhyLTEpKSxjPV8uTHJwKGUsdCxsKTtjLno9TWF0aC5taW4oMSwuNStNYXRoLmFicyguNS11aChsKSkqLjY1KSxuLnB1c2goYyl9cmV0dXJuIG59c3RhdGljIFNuYXBUb0dyaWQoZSx0PTgpe3JldHVybiBuZXcgXyhNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfX1jb25zdCB1aD1kPT5kPC41PzIqZCpkOi0xKyg0LTIqZCkqZDtjbGFzcyBPdCBleHRlbmRzIF97Y29uc3RydWN0b3IoZT0wLHQ9MCxyPTAsbj17eDowLHk6MH0scz0wLGw9MCl7c3VwZXIoZSx0LHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6cn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6c30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bH0pfWdldCB0aW1lc3RhbXAoKXtyZXR1cm4gdGhpcy50fWdldCBwcmVzc3VyZSgpe3JldHVybiB0aGlzLnp9Z2V0IGFuZ2xlTnVtKCl7cmV0dXJuIHRoaXMuYX1nZXQgWFkoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0QShlKXt0aGlzLmE9ZX1zZXRUKGUpe3RoaXMudD1lfXNldHYoZSl7cmV0dXJuIHRoaXMudj17eDplLngseTplLnl9LHRoaXN9c2V0KGU9dGhpcy54LHQ9dGhpcy55LHI9dGhpcy56LG49dGhpcy52LHM9dGhpcy50LGw9dGhpcy5hKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PXIsdGhpcy52PW4sdGhpcy50PXMsdGhpcy5hPWwsdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpyLHY6bix0OnMsYTpsfT10aGlzLGM9e3g6bi54LHk6bi55fTtyZXR1cm4gbmV3IE90KGUsdCxyLGMscyxsKX1kaXN0YW5jZShlKXtyZXR1cm4gT3QuR2V0RGlzdGFuY2UodGhpcyxlKX1pc05lYXIoZSx0KXtyZXR1cm4gT3QuSXNOZWFyKHRoaXMsZSx0KX1nZXRBbmdsZUJ5UG9pbnRzKGUsdCl7cmV0dXJuIE90LkdldEFuZ2xlQnlQb2ludHMoZSx0aGlzLHQpfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IE90KGUueC10LngsZS55LXQueSl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgT3QoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgR2V0RGlzdGFuY2UoZSx0KXtyZXR1cm4gT3QuTGVuKGUuY2xvbmUoKS5zdWIodCkpfXN0YXRpYyBHZXRBbmdsZUJ5UG9pbnRzKGUsdCxyKXtjb25zdCBuPXQueC1lLngscz1yLngtdC54LGw9dC55LWUueSxjPXIueS10Lnk7bGV0IG89MDtjb25zdCBmPU1hdGguc3FydChuKm4rbCpsKSx4PU1hdGguc3FydChzKnMrYypjKTtpZihmJiZ4KXtjb25zdCBnPW4qcytsKmM7bz1NYXRoLmFjb3MoZy8oZip4KSksbz1vL01hdGguUEkqMTgwO2xldCB5PW4qYy1sKnM7eT15PjA/MTotMSxvPTE4MCt5Km99cmV0dXJuIG99c3RhdGljIElzTmVhcihlLHQscil7cmV0dXJuIE90LkxlbihlLmNsb25lKCkuc3ViKHQpKTxyfXN0YXRpYyBSb3RXaXRoKGUsdCxyLG49Mil7Y29uc3Qgcz1lLngtdC54LGw9ZS55LXQueSxjPU1hdGguc2luKHIpLG89TWF0aC5jb3MociksZj1NYXRoLnBvdygxMCxuKSx4PU1hdGguZmxvb3IoKHQueCsocypvLWwqYykpKmYpL2YsZz1NYXRoLmZsb29yKCh0LnkrKHMqYytsKm8pKSpmKS9mO3JldHVybiBuZXcgT3QoeCxnKX1zdGF0aWMgR2V0RG90U3Ryb2tlKGUsdCxyPTE2KXtjb25zdCBuPW5ldyBfKDEsMSkscz1NYXRoLlBJKy4wMDEsbD1PdC5BZGQoZSxPdC5TdWIoZSxuKS51bmkoKS5wZXIoKS5tdWwoLXQpKSxjPVtdO2ZvcihsZXQgbz0xL3IsZj1vO2Y8PTE7Zis9byljLnB1c2goT3QuUm90V2l0aChsLGUscyoyKmYpKTtyZXR1cm4gY31zdGF0aWMgR2V0U2VtaWNpcmNsZVN0cm9rZShlLHQscj0tMSxuPTgpe2NvbnN0IHM9ciooTWF0aC5QSSsuMDAxKSxsPVtdO2ZvcihsZXQgYz0xL24sbz1jO288PTE7bys9YylsLnB1c2goT3QuUm90V2l0aCh0LGUscypvKSk7cmV0dXJuIGx9fWZ1bmN0aW9uIGZoKGQsZSl7cmV0dXJue3g6ZC54LWUseTpkLnktZSx3OmQudytlKjIsaDpkLmgrZSoyfX1mdW5jdGlvbiBidChkLGUpe2lmKGQmJmUpe2NvbnN0IHQ9TWF0aC5taW4oZC54LGUueCkscj1NYXRoLm1pbihkLnksZS55KSxuPU1hdGgubWF4KGQueCtkLncsZS54K2Uudykscz1NYXRoLm1heChkLnkrZC5oLGUueStlLmgpLGw9bi10LGM9cy1yO3JldHVybnt4OnQseTpyLHc6bCxoOmN9fXJldHVybiBlfHxkfWZ1bmN0aW9uIE50KGQsZT0wKXtjb25zdCB0PXt4OjAseTowLHc6MCxoOjB9O2xldCByPTEvMCxuPTEvMCxzPS0xLzAsbD0tMS8wO3JldHVybiBkLmZvckVhY2goYz0+e2NvbnN0W28sZl09Yy5YWTtyPU1hdGgubWluKHIsby1lKSxuPU1hdGgubWluKG4sZi1lKSxzPU1hdGgubWF4KHMsbytlKSxsPU1hdGgubWF4KGwsZitlKX0pLHQueD1yLHQueT1uLHQudz1zLXIsdC5oPWwtbix0fWZ1bmN0aW9uIHhlKGQsZSl7cmV0dXJuIShkLngrZC53PGUueHx8ZC54PmUueCtlLnd8fGQueStkLmg8ZS55fHxkLnk+ZS55K2UuaCl9ZnVuY3Rpb24gaGgoZCxlKXtyZXR1cm4gZC5sZW5ndGg9PT1lLmxlbmd0aCYmZC5zb3J0KCkudG9TdHJpbmcoKT09PWUuc29ydCgpLnRvU3RyaW5nKCl9ZnVuY3Rpb24gZmUoZCxlPTEwKXtyZXR1cm57eDpNYXRoLmZsb29yKGQueC1lKSx5Ok1hdGguZmxvb3IoZC55LWUpLHc6TWF0aC5mbG9vcihkLncrZSoyKSxoOk1hdGguZmxvb3IoZC5oK2UqMil9fWZ1bmN0aW9uIGFuKGQsZSl7cmV0dXJue3g6ZC54K2VbMF0seTpkLnkrZVsxXSx3OmQudyxoOmQuaH19ZnVuY3Rpb24gZGgoZCxlKXtjb25zdCB0PW5ldyBfKGQueCxkLnkpLHI9bmV3IF8oZC54K2QudyxkLnkpLG49bmV3IF8oZC54K2QudyxkLnkrZC5oKSxzPW5ldyBfKGQueCxkLnkrZC5oKSxsPW5ldyBfKGQueCtkLncvMixkLnkrZC5oLzIpLGM9TWF0aC5QSSplLzE4MCxvPV8uUm90V2l0aCh0LGwsYyksZj1fLlJvdFdpdGgocixsLGMpLHg9Xy5Sb3RXaXRoKG4sbCxjKSxnPV8uUm90V2l0aChzLGwsYyk7cmV0dXJuIE50KFtvLGYseCxnXSl9ZnVuY3Rpb24gZ2goZCxlKXtjb25zdCB0PW5ldyBfKGQueCxkLnkpLHI9bmV3IF8oZC54K2QudyxkLnkpLG49bmV3IF8oZC54K2QudyxkLnkrZC5oKSxzPW5ldyBfKGQueCxkLnkrZC5oKSxsPW5ldyBfKGQueCtkLncvMixkLnkrZC5oLzIpLGM9bmV3IF8oZVswXSxlWzFdKSxvPV8uU2NhbGVXT3JpZ2luKHQsYyxsKSxmPV8uU2NhbGVXT3JpZ2luKHIsYyxsKSx4PV8uU2NhbGVXT3JpZ2luKG4sYyxsKSxnPV8uU2NhbGVXT3JpZ2luKHMsYyxsKTtyZXR1cm4gTnQoW28sZix4LGddKX1mdW5jdGlvbiBtaChkLGUsdCl7Y29uc3Qgcj1uZXcgXyhlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248ZC5sZW5ndGg7bis9Myl7Y29uc3Qgcz1uZXcgXyhkW25dLGRbbisxXSksbD1NYXRoLlBJKnQvMTgwLGM9Xy5Sb3RXaXRoKHMscixsKTtkW25dPWMueCxkW24rMV09Yy55fX1mdW5jdGlvbiB2aChkLGUsdCl7Y29uc3Qgcj1uZXcgXyhlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248ZC5sZW5ndGg7bis9Myl7Y29uc3Qgcz1uZXcgXyhkW25dLGRbbisxXSksbD1uZXcgXyh0WzBdLHRbMV0pO2lmKG48ZC5sZW5ndGgtMyl7Y29uc3Qgbz1uZXcgXyhkW24rM10sZFtuKzRdKSxmPV8uVGFuKG8scykucGVyKCkubXVsKGRbbisyXSkubXVsVihsKS5sZW4oKTtkW24rMl09Zn1lbHNlIGlmKG49PT1kLmxlbmd0aC0zKXtjb25zdCBvPW5ldyBfKGRbbi0zXSxkW24tMl0pLGY9Xy5UYW4ocyxvKS5wZXIoKS5tdWwoZFtuKzJdKS5tdWxWKGwpLmxlbigpO2RbbisyXT1mfWNvbnN0IGM9Xy5TY2FsZVdPcmlnaW4ocyxsLHIpO2Rbbl09Yy54LGRbbisxXT1jLnl9fWZ1bmN0aW9uIHBoKGQsZSl7cmV0dXJuIGRbMF0+PWUueCYmZFswXTw9ZS54K2UudyYmZFsxXT49ZS55JiZkWzFdPD1lLnkrZS5ofWZ1bmN0aW9uIGxuKGQsZSl7Y29uc3QgdD1kPD1lPzE6ZC9lLHI9ZTw9ZD8xOmUvZDtyZXR1cm5bdCxyXX1jb25zdCBOZT1kPT57aWYoZC50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgZT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGQpLmZpbmQodD0+dC50b1N0cmluZygpPT09IlN5bWJvbChzZWFsZWQpIik7aWYoZSYmZFtlXSlyZXR1cm4hMH1yZXR1cm4hMX0sY249ZD0+ZCE9PXZ0LlRleHQ7ZnVuY3Rpb24gaGUoZCl7cmV0dXJuYCR7amUoZC54KX0sJHtqZShkLnkpfSBgfWZ1bmN0aW9uIGRlKGQsZSl7cmV0dXJuYCR7amUoKGQueCtlLngpLzIpfSwke2plKChkLnkrZS55KS8yKX0gYH1mdW5jdGlvbiBqZShkKXtyZXR1cm4rZC50b0ZpeGVkKDQpfXZhciB5aD1yZSx4aD10ZSxPaD0iW29iamVjdCBOdW1iZXJdIjtmdW5jdGlvbiBQaChkKXtyZXR1cm4gdHlwZW9mIGQ9PSJudW1iZXIifHx4aChkKSYmeWgoZCk9PU9ofXZhciBiaD1QaCxlcj1wZShiaCk7Y2xhc3MgZ3R7Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNVbml0VGltZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjFlM30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Tm9kZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KTtjb25zdHt2Tm9kZXM6dCxmdWxsTGF5ZXI6cixkcmF3TGF5ZXI6bn09ZTt0aGlzLnZOb2Rlcz10LHRoaXMuZnVsbExheWVyPXIsdGhpcy5kcmF3TGF5ZXI9bn1zZXRXb3JrSWQoZSl7dGhpcy53b3JrSWQ9ZX1nZXRXb3JrSWQoKXtyZXR1cm4gdGhpcy53b3JrSWR9Z2V0V29ya09wdGlvbnMoKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9uc31zZXRXb3JrT3B0aW9ucyhlKXt0aGlzLndvcmtPcHRpb25zPWUsdGhpcy5zeW5jVW5pdFRpbWU9ZS5zeW5jVW5pdFRpbWV8fHRoaXMuc3luY1VuaXRUaW1lfXVwZGF0YU9wdFNlcnZpY2UoZSl7dmFyIG47bGV0IHQ7Y29uc3Qgcj0obj10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOm4udG9TdHJpbmcoKTtpZihyJiZlKXtjb25zdCBzPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHIpfHx0aGlzLmRyYXdMYXllciYmdGhpcy5kcmF3TGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUocil8fFtdO2lmKHMubGVuZ3RoIT09MSlyZXR1cm47Y29uc3QgbD1zWzBdLHtwb3M6Yyx6SW5kZXg6byxzY2FsZTpmLGFuZ2xlOngsdHJhbnNsYXRlOmd9PWUseT17fTt0eXBlb2Ygbz09Im51bWJlciImJih5LnpJbmRleD1vKSxjJiYoeS5wb3M9W2NbMF0sY1sxXV0pLGYmJih5LnNjYWxlPWYpLHgmJih5LnJvdGF0ZT14KSxnJiYoeS50cmFuc2xhdGU9ZyksbC5hdHRyKHkpO2NvbnN0IG09bD09bnVsbD92b2lkIDA6bC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4gbSYmKHQ9YnQodCx7eDpNYXRoLmZsb29yKG0ueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKG0ueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKG0ud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKG0uaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfSkpLHRoaXMudk5vZGVzLnNldEluZm8ocix7cmVjdDp0LGNlbnRlclBvczpjfSksdH19c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpuLHdpbGxTZXJpYWxpemVEYXRhOnMsdGFyZ2V0Tm9kZTpsfT1lLHt6SW5kZXg6Yyx0cmFuc2xhdGU6byxhbmdsZTpmLGJveDp4LGJveFNjYWxlOmcsYm94VHJhbnNsYXRlOnkscG9pbnRNYXA6bX09cjtsZXQgVDtjb25zdCBPPWwmJll0KGwpfHxuLmdldCh0Lm5hbWUpO2lmKCFPKXJldHVybjtjJiYodC5zZXRBdHRyaWJ1dGUoInpJbmRleCIsYyksTy5vcHQuekluZGV4PWMpO2NvbnN0IHY9dC5wYXJlbnQ7aWYodil7aWYoeCYmeSYmZyl7Y29uc3R7cmVjdDpQfT1PLGk9W107Zm9yKGxldCBJPTA7STxPLm9wLmxlbmd0aDtJKz0zKWkucHVzaChuZXcgT3QoTy5vcFtJXSxPLm9wW0krMV0sTy5vcFtJKzJdKSk7Y29uc3QgdT1OdChpKSxhPVt1Lncqdi53b3JsZFNjYWxpbmdbMF0sdS5oKnYud29ybGRTY2FsaW5nWzBdXSxoPVtQLnctYVswXSxQLmgtYVsxXV0sYj1bKFAudypnWzBdLWhbMF0pL2FbMF0sKFAuaCpnWzFdLWhbMV0pL2FbMV1dLEU9W3lbMF0vdi53b3JsZFNjYWxpbmdbMF0seVsxXS92LndvcmxkU2NhbGluZ1sxXV0sQT1PLm9wLm1hcCgoSSxEKT0+e2NvbnN0IFI9RCUzO3JldHVybiBSPT09MD9JK0VbMF06Uj09PTE/SStFWzFdOkl9KSxMPVtPLmNlbnRlclBvc1swXStFWzBdLE8uY2VudGVyUG9zWzFdK0VbMV1dO3ZoKEEsTCxiKTtjb25zdCBTPVtdO2ZvcihsZXQgST0wO0k8QS5sZW5ndGg7SSs9MylTLnB1c2gobmV3IE90KEFbSV0sQVtJKzFdLEFbSSsyXSkpO08ub3A9QSxPLmNlbnRlclBvcz1MfWVsc2UgaWYobyl7Y29uc3QgUD1bb1swXS92LndvcmxkU2NhbGluZ1swXSxvWzFdL3Yud29ybGRTY2FsaW5nWzFdXTt0LnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixQKSxPLm9wdC50cmFuc2xhdGU9UCxsJiYoVD1hbihPLnJlY3QsbyksTy5yZWN0PVQpfWVsc2UgZXIoZikmJih0LnNldEF0dHJpYnV0ZSgicm90YXRlIixmKSxPLm9wdC5yb3RhdGU9ZixsJiYoVD1kaChPLnJlY3QsZiksTy5yZWN0PVQpKTtpZihtKXtjb25zdCBQPW0uZ2V0KHQubmFtZSk7aWYoUClmb3IobGV0IGk9MCx1PTA7aTxPLm9wLmxlbmd0aDtpKz0zLHUrKylPLm9wW2ldPVBbdV1bMF0sTy5vcFtpKzFdPVBbdV1bMV19aWYocyl7aWYobyl7Y29uc3QgUD1bb1swXS92LndvcmxkU2NhbGluZ1swXSxvWzFdL3Yud29ybGRTY2FsaW5nWzFdXSxpPU8ub3AubWFwKCh1LGEpPT57Y29uc3QgaD1hJTM7cmV0dXJuIGg9PT0wP3UrUFswXTpoPT09MT91K1BbMV06dX0pO08ub3A9aSxPLmNlbnRlclBvcz1bTy5jZW50ZXJQb3NbMF0rUFswXSxPLmNlbnRlclBvc1sxXStQWzFdXSxPIT1udWxsJiZPLm9wdCYmKE8ub3B0LnRyYW5zbGF0ZT12b2lkIDApfWVsc2UgaWYoZXIoZikpe2NvbnN0IFA9Ty5vcDttaChQLE8uY2VudGVyUG9zLGYpLE8ub3A9UCxPIT1udWxsJiZPLm9wdCYmKE8ub3B0LnJvdGF0ZT12b2lkIDApfX1PJiZuLnNldEluZm8odC5uYW1lLE8pfX1zdGF0aWMgZ2V0Q2VudGVyUG9zKGUsdCl7Y29uc3R7d29ybGRQb3NpdGlvbjpyLHdvcmxkU2NhbGluZzpufT10O3JldHVyblsoZS54K2Uudy8yLXJbMF0pL25bMF0sKGUueStlLmgvMi1yWzFdKS9uWzFdXX1zdGF0aWMgZ2V0UmVjdEZyb21MYXllcihlLHQpe2NvbnN0IHI9ZS5nZXRFbGVtZW50c0J5TmFtZSh0KVswXTtpZihyKXtjb25zdCBuPXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihuLngtZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihuLnktZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihuLndpZHRoK2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihuLmhlaWdodCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKX19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZ3QsIlNhZmVCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KTt2YXIgRHQ9ZnVuY3Rpb24oZCl7dmFyIGU9e307ZnVuY3Rpb24gdChyKXtpZihlW3JdKXJldHVybiBlW3JdLmV4cG9ydHM7dmFyIG49ZVtyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGRbcl0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsdCksbi5sPSEwLG4uZXhwb3J0c31yZXR1cm4gdC5tPWQsdC5jPWUsdC5kPWZ1bmN0aW9uKHIsbixzKXt0Lm8ocixuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsbix7ZW51bWVyYWJsZTohMCxnZXQ6c30pfSx0LnI9ZnVuY3Rpb24ocil7dHlwZW9mIFN5bWJvbDwidSImJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZToiTW9kdWxlIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX0sdC50PWZ1bmN0aW9uKHIsbil7aWYobiYxJiYocj10KHIpKSxuJjh8fG4mNCYmdHlwZW9mIHI9PSJvYmplY3QiJiZyJiZyLl9fZXNNb2R1bGUpcmV0dXJuIHI7dmFyIHM9T2JqZWN0LmNyZWF0ZShudWxsKTtpZih0LnIocyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnJ9KSxuJjImJnR5cGVvZiByIT0ic3RyaW5nIilmb3IodmFyIGwgaW4gcil0LmQocyxsLChmdW5jdGlvbihjKXtyZXR1cm4gcltjXX0pLmJpbmQobnVsbCxsKSk7cmV0dXJuIHN9LHQubj1mdW5jdGlvbihyKXt2YXIgbj1yJiZyLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiByfTtyZXR1cm4gdC5kKG4sImEiLG4pLG59LHQubz1mdW5jdGlvbihyLG4pe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixuKX0sdC5wPSIvanMvIix0KHQucz0wKX0oW2Z1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsInZlcnNpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwiaGVscGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJjcmVhdGVFbGVtZW50IixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImlzU3ByaXRlTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyZWdpc3Rlck5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KTt2YXIgcj10KDEyKTt0LmQoZSwiRU5WIixmdW5jdGlvbigpe3JldHVybiByLkVOVn0pO3ZhciBuPXQoNjgpO3QuZChlLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIG4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBuLmNhbmNlbEFuaW1hdGlvbkZyYW1lfSk7dmFyIHM9dCg3MCk7dC5kKGUsIk5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdH0pO3ZhciBsPXQoMjE3KTt0LmQoZSwiQ2xvdWQiLGZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH0pO3ZhciBjPXQoMjE5KTt0LmQoZSwiQmxvY2siLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pO3ZhciBvPXQoMjI0KTt0LmQoZSwiU3ByaXRlIixmdW5jdGlvbigpe3JldHVybiBvLmRlZmF1bHR9KTt2YXIgZj10KDIyNik7dC5kKGUsIlBhdGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pO3ZhciB4PXQoMjI5KTt0LmQoZSwiUmVjdCIsZnVuY3Rpb24oKXtyZXR1cm4geC5kZWZhdWx0fSk7dmFyIGc9dCgyMzEpO3QuZChlLCJUcmlhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fSk7dmFyIHk9dCgyMzYpO3QuZChlLCJQYXJhbGxlbCIsZnVuY3Rpb24oKXtyZXR1cm4geS5kZWZhdWx0fSk7dmFyIG09dCgyMzgpO3QuZChlLCJSZWd1bGFyIixmdW5jdGlvbigpe3JldHVybiBtLmRlZmF1bHR9KTt2YXIgVD10KDI0MCk7dC5kKGUsIlN0YXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFQuZGVmYXVsdH0pO3ZhciBPPXQoMjQyKTt0LmQoZSwiRWxsaXBzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTy5kZWZhdWx0fSk7dmFyIHY9dCgyNDQpO3QuZChlLCJBcmMiLGZ1bmN0aW9uKCl7cmV0dXJuIHYuZGVmYXVsdH0pO3ZhciBQPXQoMjQ2KTt0LmQoZSwiUmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gUC5kZWZhdWx0fSk7dmFyIGk9dCgyMzIpO3QuZChlLCJQb2x5bGluZSIsZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0fSk7dmFyIHU9dCgyNDgpO3QuZChlLCJMYWJlbCIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIGE9dCgyNTApO3QuZChlLCJHcm91cCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5kZWZhdWx0fSk7dmFyIGg9dCgyODYpO3QuZChlLCJMYXllciIsZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWZhdWx0fSk7dmFyIGI9dCgyODcpO3QuZChlLCJTcHJpdGVTdmciLGZ1bmN0aW9uKCl7cmV0dXJuIGIuZGVmYXVsdH0pO3ZhciBFPXQoMjg5KTt0LmQoZSwiTGF5ZXJXb3JrZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEUuZGVmYXVsdH0pO3ZhciBBPXQoMjkwKTt0LmQoZSwiU2NlbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIEEuZGVmYXVsdH0pO3ZhciBMPXQoMjEzKSxTPXQoMjIxKTt0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIFMuQ29sb3J9KSx0LmQoZSwiR3JhZGllbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIFMuR3JhZGllbnR9KTt2YXIgST10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgRD1MLmRlZmF1bHQuY3JlYXRlRWxlbWVudCxSPUwuZGVmYXVsdC5pc1Nwcml0ZU5vZGUsQz1MLmRlZmF1bHQucmVnaXN0ZXJOb2RlLGo9e3BhcnNlQ29sb3I6Uy5wYXJzZUNvbG9yLHNpemVUb1BpeGVsOkkuc2l6ZVRvUGl4ZWwsdG9BcnJheTpJLnRvQXJyYXksdG9TdHJpbmc6SS50b1N0cmluZyx0b051bWJlcjpJLnRvTnVtYmVyfTtsZXQgJDskPSIzLjguMyI7Y29uc3QgSD0kfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpO3ZhciByPXQoMik7dC5kKGUsImdsTWF0cml4IixmdW5jdGlvbigpe3JldHVybiByfSk7dmFyIG49dCgzKTt0LmQoZSwibWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciBzPXQoNCk7dC5kKGUsIm1hdDJkIixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIGw9dCg1KTt0LmQoZSwibWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciBjPXQoNik7dC5kKGUsIm1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgbz10KDcpO3QuZChlLCJxdWF0IixmdW5jdGlvbigpe3JldHVybiBvfSk7dmFyIGY9dCgxMCk7dC5kKGUsInF1YXQyIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHg9dCgxMSk7dC5kKGUsInZlYzIiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgZz10KDgpO3QuZChlLCJ2ZWMzIixmdW5jdGlvbigpe3JldHVybiBnfSk7dmFyIHk9dCg5KTt0LmQoZSwidmVjNCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJFUFNJTE9OIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsIkFSUkFZX1RZUEUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiUkFORE9NIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInNldE1hdHJpeEFycmF5VHlwZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJ0b1JhZGlhbiIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj0xZS02LG49dHlwZW9mIEZsb2F0MzJBcnJheTwidSI/RmxvYXQzMkFycmF5OkFycmF5LHM9TWF0aC5yYW5kb207ZnVuY3Rpb24gbCh4KXtuPXh9dmFyIGM9TWF0aC5QSS8xODA7ZnVuY3Rpb24gbyh4KXtyZXR1cm4geCpjfWZ1bmN0aW9uIGYoeCxnKXtyZXR1cm4gTWF0aC5hYnMoeC1nKTw9cipNYXRoLm1heCgxLE1hdGguYWJzKHgpLE1hdGguYWJzKGcpKX1NYXRoLmh5cG90fHwoTWF0aC5oeXBvdD1mdW5jdGlvbigpe2Zvcih2YXIgeD0wLGc9YXJndW1lbnRzLmxlbmd0aDtnLS07KXgrPWFyZ3VtZW50c1tnXSphcmd1bWVudHNbZ107cmV0dXJuIE1hdGguc3FydCh4KX0pfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJMRFUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBSfSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBuKCl7dmFyIEM9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihDWzFdPTAsQ1syXT0wKSxDWzBdPTEsQ1szXT0xLEN9ZnVuY3Rpb24gcyhDKXt2YXIgaj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBqWzBdPUNbMF0salsxXT1DWzFdLGpbMl09Q1syXSxqWzNdPUNbM10san1mdW5jdGlvbiBsKEMsail7cmV0dXJuIENbMF09alswXSxDWzFdPWpbMV0sQ1syXT1qWzJdLENbM109alszXSxDfWZ1bmN0aW9uIGMoQyl7cmV0dXJuIENbMF09MSxDWzFdPTAsQ1syXT0wLENbM109MSxDfWZ1bmN0aW9uIG8oQyxqLCQsSCl7dmFyIEo9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gSlswXT1DLEpbMV09aixKWzJdPSQsSlszXT1ILEp9ZnVuY3Rpb24gZihDLGosJCxILEope3JldHVybiBDWzBdPWosQ1sxXT0kLENbMl09SCxDWzNdPUosQ31mdW5jdGlvbiB4KEMsail7aWYoQz09PWope3ZhciAkPWpbMV07Q1sxXT1qWzJdLENbMl09JH1lbHNlIENbMF09alswXSxDWzFdPWpbMl0sQ1syXT1qWzFdLENbM109alszXTtyZXR1cm4gQ31mdW5jdGlvbiBnKEMsail7dmFyICQ9alswXSxIPWpbMV0sSj1qWzJdLHE9alszXSxGPSQqcS1KKkg7cmV0dXJuIEY/KEY9MS9GLENbMF09cSpGLENbMV09LUgqRixDWzJdPS1KKkYsQ1szXT0kKkYsQyk6bnVsbH1mdW5jdGlvbiB5KEMsail7dmFyICQ9alswXTtyZXR1cm4gQ1swXT1qWzNdLENbMV09LWpbMV0sQ1syXT0talsyXSxDWzNdPSQsQ31mdW5jdGlvbiBtKEMpe3JldHVybiBDWzBdKkNbM10tQ1syXSpDWzFdfWZ1bmN0aW9uIFQoQyxqLCQpe3ZhciBIPWpbMF0sSj1qWzFdLHE9alsyXSxGPWpbM10sRz0kWzBdLFo9JFsxXSx0dD0kWzJdLGV0PSRbM107cmV0dXJuIENbMF09SCpHK3EqWixDWzFdPUoqRytGKlosQ1syXT1IKnR0K3EqZXQsQ1szXT1KKnR0K0YqZXQsQ31mdW5jdGlvbiBPKEMsaiwkKXt2YXIgSD1qWzBdLEo9alsxXSxxPWpbMl0sRj1qWzNdLEc9TWF0aC5zaW4oJCksWj1NYXRoLmNvcygkKTtyZXR1cm4gQ1swXT1IKlorcSpHLENbMV09SipaK0YqRyxDWzJdPUgqLUcrcSpaLENbM109SiotRytGKlosQ31mdW5jdGlvbiB2KEMsaiwkKXt2YXIgSD1qWzBdLEo9alsxXSxxPWpbMl0sRj1qWzNdLEc9JFswXSxaPSRbMV07cmV0dXJuIENbMF09SCpHLENbMV09SipHLENbMl09cSpaLENbM109RipaLEN9ZnVuY3Rpb24gUChDLGope3ZhciAkPU1hdGguc2luKGopLEg9TWF0aC5jb3Moaik7cmV0dXJuIENbMF09SCxDWzFdPSQsQ1syXT0tJCxDWzNdPUgsQ31mdW5jdGlvbiBpKEMsail7cmV0dXJuIENbMF09alswXSxDWzFdPTAsQ1syXT0wLENbM109alsxXSxDfWZ1bmN0aW9uIHUoQyl7cmV0dXJuIm1hdDIoIitDWzBdKyIsICIrQ1sxXSsiLCAiK0NbMl0rIiwgIitDWzNdKyIpIn1mdW5jdGlvbiBhKEMpe3JldHVybiBNYXRoLmh5cG90KENbMF0sQ1sxXSxDWzJdLENbM10pfWZ1bmN0aW9uIGgoQyxqLCQsSCl7cmV0dXJuIENbMl09SFsyXS9IWzBdLCRbMF09SFswXSwkWzFdPUhbMV0sJFszXT1IWzNdLUNbMl0qJFsxXSxbQyxqLCRdfWZ1bmN0aW9uIGIoQyxqLCQpe3JldHVybiBDWzBdPWpbMF0rJFswXSxDWzFdPWpbMV0rJFsxXSxDWzJdPWpbMl0rJFsyXSxDWzNdPWpbM10rJFszXSxDfWZ1bmN0aW9uIEUoQyxqLCQpe3JldHVybiBDWzBdPWpbMF0tJFswXSxDWzFdPWpbMV0tJFsxXSxDWzJdPWpbMl0tJFsyXSxDWzNdPWpbM10tJFszXSxDfWZ1bmN0aW9uIEEoQyxqKXtyZXR1cm4gQ1swXT09PWpbMF0mJkNbMV09PT1qWzFdJiZDWzJdPT09alsyXSYmQ1szXT09PWpbM119ZnVuY3Rpb24gTChDLGope3ZhciAkPUNbMF0sSD1DWzFdLEo9Q1syXSxxPUNbM10sRj1qWzBdLEc9alsxXSxaPWpbMl0sdHQ9alszXTtyZXR1cm4gTWF0aC5hYnMoJC1GKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoJCksTWF0aC5hYnMoRikpJiZNYXRoLmFicyhILUcpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhIKSxNYXRoLmFicyhHKSkmJk1hdGguYWJzKEotWik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEopLE1hdGguYWJzKFopKSYmTWF0aC5hYnMocS10dCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHEpLE1hdGguYWJzKHR0KSl9ZnVuY3Rpb24gUyhDLGosJCl7cmV0dXJuIENbMF09alswXSokLENbMV09alsxXSokLENbMl09alsyXSokLENbM109alszXSokLEN9ZnVuY3Rpb24gSShDLGosJCxIKXtyZXR1cm4gQ1swXT1qWzBdKyRbMF0qSCxDWzFdPWpbMV0rJFsxXSpILENbMl09alsyXSskWzJdKkgsQ1szXT1qWzNdKyRbM10qSCxDfXZhciBEPVQsUj1FfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBSPW5ldyByLkFSUkFZX1RZUEUoNik7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoUlsxXT0wLFJbMl09MCxSWzRdPTAsUls1XT0wKSxSWzBdPTEsUlszXT0xLFJ9ZnVuY3Rpb24gcyhSKXt2YXIgQz1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiBDWzBdPVJbMF0sQ1sxXT1SWzFdLENbMl09UlsyXSxDWzNdPVJbM10sQ1s0XT1SWzRdLENbNV09Uls1XSxDfWZ1bmN0aW9uIGwoUixDKXtyZXR1cm4gUlswXT1DWzBdLFJbMV09Q1sxXSxSWzJdPUNbMl0sUlszXT1DWzNdLFJbNF09Q1s0XSxSWzVdPUNbNV0sUn1mdW5jdGlvbiBjKFIpe3JldHVybiBSWzBdPTEsUlsxXT0wLFJbMl09MCxSWzNdPTEsUls0XT0wLFJbNV09MCxSfWZ1bmN0aW9uIG8oUixDLGosJCxILEope3ZhciBxPW5ldyByLkFSUkFZX1RZUEUoNik7cmV0dXJuIHFbMF09UixxWzFdPUMscVsyXT1qLHFbM109JCxxWzRdPUgscVs1XT1KLHF9ZnVuY3Rpb24gZihSLEMsaiwkLEgsSixxKXtyZXR1cm4gUlswXT1DLFJbMV09aixSWzJdPSQsUlszXT1ILFJbNF09SixSWzVdPXEsUn1mdW5jdGlvbiB4KFIsQyl7dmFyIGo9Q1swXSwkPUNbMV0sSD1DWzJdLEo9Q1szXSxxPUNbNF0sRj1DWzVdLEc9aipKLSQqSDtyZXR1cm4gRz8oRz0xL0csUlswXT1KKkcsUlsxXT0tJCpHLFJbMl09LUgqRyxSWzNdPWoqRyxSWzRdPShIKkYtSipxKSpHLFJbNV09KCQqcS1qKkYpKkcsUik6bnVsbH1mdW5jdGlvbiBnKFIpe3JldHVybiBSWzBdKlJbM10tUlsxXSpSWzJdfWZ1bmN0aW9uIHkoUixDLGope3ZhciAkPUNbMF0sSD1DWzFdLEo9Q1syXSxxPUNbM10sRj1DWzRdLEc9Q1s1XSxaPWpbMF0sdHQ9alsxXSxldD1qWzJdLGl0PWpbM10saz1qWzRdLGh0PWpbNV07cmV0dXJuIFJbMF09JCpaK0oqdHQsUlsxXT1IKlorcSp0dCxSWzJdPSQqZXQrSippdCxSWzNdPUgqZXQrcSppdCxSWzRdPSQqaytKKmh0K0YsUls1XT1IKmsrcSpodCtHLFJ9ZnVuY3Rpb24gbShSLEMsail7dmFyICQ9Q1swXSxIPUNbMV0sSj1DWzJdLHE9Q1szXSxGPUNbNF0sRz1DWzVdLFo9TWF0aC5zaW4oaiksdHQ9TWF0aC5jb3Moaik7cmV0dXJuIFJbMF09JCp0dCtKKlosUlsxXT1IKnR0K3EqWixSWzJdPSQqLVorSip0dCxSWzNdPUgqLVorcSp0dCxSWzRdPUYsUls1XT1HLFJ9ZnVuY3Rpb24gVChSLEMsail7dmFyICQ9Q1swXSxIPUNbMV0sSj1DWzJdLHE9Q1szXSxGPUNbNF0sRz1DWzVdLFo9alswXSx0dD1qWzFdO3JldHVybiBSWzBdPSQqWixSWzFdPUgqWixSWzJdPUoqdHQsUlszXT1xKnR0LFJbNF09RixSWzVdPUcsUn1mdW5jdGlvbiBPKFIsQyxqKXt2YXIgJD1DWzBdLEg9Q1sxXSxKPUNbMl0scT1DWzNdLEY9Q1s0XSxHPUNbNV0sWj1qWzBdLHR0PWpbMV07cmV0dXJuIFJbMF09JCxSWzFdPUgsUlsyXT1KLFJbM109cSxSWzRdPSQqWitKKnR0K0YsUls1XT1IKlorcSp0dCtHLFJ9ZnVuY3Rpb24gdihSLEMpe3ZhciBqPU1hdGguc2luKEMpLCQ9TWF0aC5jb3MoQyk7cmV0dXJuIFJbMF09JCxSWzFdPWosUlsyXT0taixSWzNdPSQsUls0XT0wLFJbNV09MCxSfWZ1bmN0aW9uIFAoUixDKXtyZXR1cm4gUlswXT1DWzBdLFJbMV09MCxSWzJdPTAsUlszXT1DWzFdLFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiBpKFIsQyl7cmV0dXJuIFJbMF09MSxSWzFdPTAsUlsyXT0wLFJbM109MSxSWzRdPUNbMF0sUls1XT1DWzFdLFJ9ZnVuY3Rpb24gdShSKXtyZXR1cm4ibWF0MmQoIitSWzBdKyIsICIrUlsxXSsiLCAiK1JbMl0rIiwgIitSWzNdKyIsICIrUls0XSsiLCAiK1JbNV0rIikifWZ1bmN0aW9uIGEoUil7cmV0dXJuIE1hdGguaHlwb3QoUlswXSxSWzFdLFJbMl0sUlszXSxSWzRdLFJbNV0sMSl9ZnVuY3Rpb24gaChSLEMsail7cmV0dXJuIFJbMF09Q1swXStqWzBdLFJbMV09Q1sxXStqWzFdLFJbMl09Q1syXStqWzJdLFJbM109Q1szXStqWzNdLFJbNF09Q1s0XStqWzRdLFJbNV09Q1s1XStqWzVdLFJ9ZnVuY3Rpb24gYihSLEMsail7cmV0dXJuIFJbMF09Q1swXS1qWzBdLFJbMV09Q1sxXS1qWzFdLFJbMl09Q1syXS1qWzJdLFJbM109Q1szXS1qWzNdLFJbNF09Q1s0XS1qWzRdLFJbNV09Q1s1XS1qWzVdLFJ9ZnVuY3Rpb24gRShSLEMsail7cmV0dXJuIFJbMF09Q1swXSpqLFJbMV09Q1sxXSpqLFJbMl09Q1syXSpqLFJbM109Q1szXSpqLFJbNF09Q1s0XSpqLFJbNV09Q1s1XSpqLFJ9ZnVuY3Rpb24gQShSLEMsaiwkKXtyZXR1cm4gUlswXT1DWzBdK2pbMF0qJCxSWzFdPUNbMV0ralsxXSokLFJbMl09Q1syXStqWzJdKiQsUlszXT1DWzNdK2pbM10qJCxSWzRdPUNbNF0rals0XSokLFJbNV09Q1s1XStqWzVdKiQsUn1mdW5jdGlvbiBMKFIsQyl7cmV0dXJuIFJbMF09PT1DWzBdJiZSWzFdPT09Q1sxXSYmUlsyXT09PUNbMl0mJlJbM109PT1DWzNdJiZSWzRdPT09Q1s0XSYmUls1XT09PUNbNV19ZnVuY3Rpb24gUyhSLEMpe3ZhciBqPVJbMF0sJD1SWzFdLEg9UlsyXSxKPVJbM10scT1SWzRdLEY9Uls1XSxHPUNbMF0sWj1DWzFdLHR0PUNbMl0sZXQ9Q1szXSxpdD1DWzRdLGs9Q1s1XTtyZXR1cm4gTWF0aC5hYnMoai1HKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaiksTWF0aC5hYnMoRykpJiZNYXRoLmFicygkLVopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKEgtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhIKSxNYXRoLmFicyh0dCkpJiZNYXRoLmFicyhKLWV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMoZXQpKSYmTWF0aC5hYnMocS1pdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHEpLE1hdGguYWJzKGl0KSkmJk1hdGguYWJzKEYtayk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEYpLE1hdGguYWJzKGspKX12YXIgST15LEQ9Yn0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJmcm9tTWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZnJvbVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibm9ybWFsRnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwicHJvamVjdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuICR9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgRj1uZXcgci5BUlJBWV9UWVBFKDkpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKEZbMV09MCxGWzJdPTAsRlszXT0wLEZbNV09MCxGWzZdPTAsRls3XT0wKSxGWzBdPTEsRls0XT0xLEZbOF09MSxGfWZ1bmN0aW9uIHMoRixHKXtyZXR1cm4gRlswXT1HWzBdLEZbMV09R1sxXSxGWzJdPUdbMl0sRlszXT1HWzRdLEZbNF09R1s1XSxGWzVdPUdbNl0sRls2XT1HWzhdLEZbN109R1s5XSxGWzhdPUdbMTBdLEZ9ZnVuY3Rpb24gbChGKXt2YXIgRz1uZXcgci5BUlJBWV9UWVBFKDkpO3JldHVybiBHWzBdPUZbMF0sR1sxXT1GWzFdLEdbMl09RlsyXSxHWzNdPUZbM10sR1s0XT1GWzRdLEdbNV09Rls1XSxHWzZdPUZbNl0sR1s3XT1GWzddLEdbOF09Rls4XSxHfWZ1bmN0aW9uIGMoRixHKXtyZXR1cm4gRlswXT1HWzBdLEZbMV09R1sxXSxGWzJdPUdbMl0sRlszXT1HWzNdLEZbNF09R1s0XSxGWzVdPUdbNV0sRls2XT1HWzZdLEZbN109R1s3XSxGWzhdPUdbOF0sRn1mdW5jdGlvbiBvKEYsRyxaLHR0LGV0LGl0LGssaHQsZnQpe3ZhciBCPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIEJbMF09RixCWzFdPUcsQlsyXT1aLEJbM109dHQsQls0XT1ldCxCWzVdPWl0LEJbNl09ayxCWzddPWh0LEJbOF09ZnQsQn1mdW5jdGlvbiBmKEYsRyxaLHR0LGV0LGl0LGssaHQsZnQsQil7cmV0dXJuIEZbMF09RyxGWzFdPVosRlsyXT10dCxGWzNdPWV0LEZbNF09aXQsRls1XT1rLEZbNl09aHQsRls3XT1mdCxGWzhdPUIsRn1mdW5jdGlvbiB4KEYpe3JldHVybiBGWzBdPTEsRlsxXT0wLEZbMl09MCxGWzNdPTAsRls0XT0xLEZbNV09MCxGWzZdPTAsRls3XT0wLEZbOF09MSxGfWZ1bmN0aW9uIGcoRixHKXtpZihGPT09Ryl7dmFyIFo9R1sxXSx0dD1HWzJdLGV0PUdbNV07RlsxXT1HWzNdLEZbMl09R1s2XSxGWzNdPVosRls1XT1HWzddLEZbNl09dHQsRls3XT1ldH1lbHNlIEZbMF09R1swXSxGWzFdPUdbM10sRlsyXT1HWzZdLEZbM109R1sxXSxGWzRdPUdbNF0sRls1XT1HWzddLEZbNl09R1syXSxGWzddPUdbNV0sRls4XT1HWzhdO3JldHVybiBGfWZ1bmN0aW9uIHkoRixHKXt2YXIgWj1HWzBdLHR0PUdbMV0sZXQ9R1syXSxpdD1HWzNdLGs9R1s0XSxodD1HWzVdLGZ0PUdbNl0sQj1HWzddLFc9R1s4XSxWPVcqay1odCpCLFg9LVcqaXQraHQqZnQsTj1CKml0LWsqZnQsej1aKlYrdHQqWCtldCpOO3JldHVybiB6Pyh6PTEveixGWzBdPVYqeixGWzFdPSgtVyp0dCtldCpCKSp6LEZbMl09KGh0KnR0LWV0KmspKnosRlszXT1YKnosRls0XT0oVypaLWV0KmZ0KSp6LEZbNV09KC1odCpaK2V0Kml0KSp6LEZbNl09Tip6LEZbN109KC1CKlordHQqZnQpKnosRls4XT0oaypaLXR0Kml0KSp6LEYpOm51bGx9ZnVuY3Rpb24gbShGLEcpe3ZhciBaPUdbMF0sdHQ9R1sxXSxldD1HWzJdLGl0PUdbM10saz1HWzRdLGh0PUdbNV0sZnQ9R1s2XSxCPUdbN10sVz1HWzhdO3JldHVybiBGWzBdPWsqVy1odCpCLEZbMV09ZXQqQi10dCpXLEZbMl09dHQqaHQtZXQqayxGWzNdPWh0KmZ0LWl0KlcsRls0XT1aKlctZXQqZnQsRls1XT1ldCppdC1aKmh0LEZbNl09aXQqQi1rKmZ0LEZbN109dHQqZnQtWipCLEZbOF09WiprLXR0Kml0LEZ9ZnVuY3Rpb24gVChGKXt2YXIgRz1GWzBdLFo9RlsxXSx0dD1GWzJdLGV0PUZbM10saXQ9Rls0XSxrPUZbNV0saHQ9Rls2XSxmdD1GWzddLEI9Rls4XTtyZXR1cm4gRyooQippdC1rKmZ0KStaKigtQipldCtrKmh0KSt0dCooZnQqZXQtaXQqaHQpfWZ1bmN0aW9uIE8oRixHLFope3ZhciB0dD1HWzBdLGV0PUdbMV0saXQ9R1syXSxrPUdbM10saHQ9R1s0XSxmdD1HWzVdLEI9R1s2XSxXPUdbN10sVj1HWzhdLFg9WlswXSxOPVpbMV0sej1aWzJdLHA9WlszXSxNPVpbNF0sdz1aWzVdLFU9Wls2XSxLPVpbN10sWT1aWzhdO3JldHVybiBGWzBdPVgqdHQrTiprK3oqQixGWzFdPVgqZXQrTipodCt6KlcsRlsyXT1YKml0K04qZnQreipWLEZbM109cCp0dCtNKmsrdypCLEZbNF09cCpldCtNKmh0K3cqVyxGWzVdPXAqaXQrTSpmdCt3KlYsRls2XT1VKnR0K0sqaytZKkIsRls3XT1VKmV0K0sqaHQrWSpXLEZbOF09VSppdCtLKmZ0K1kqVixGfWZ1bmN0aW9uIHYoRixHLFope3ZhciB0dD1HWzBdLGV0PUdbMV0saXQ9R1syXSxrPUdbM10saHQ9R1s0XSxmdD1HWzVdLEI9R1s2XSxXPUdbN10sVj1HWzhdLFg9WlswXSxOPVpbMV07cmV0dXJuIEZbMF09dHQsRlsxXT1ldCxGWzJdPWl0LEZbM109ayxGWzRdPWh0LEZbNV09ZnQsRls2XT1YKnR0K04qaytCLEZbN109WCpldCtOKmh0K1csRls4XT1YKml0K04qZnQrVixGfWZ1bmN0aW9uIFAoRixHLFope3ZhciB0dD1HWzBdLGV0PUdbMV0saXQ9R1syXSxrPUdbM10saHQ9R1s0XSxmdD1HWzVdLEI9R1s2XSxXPUdbN10sVj1HWzhdLFg9TWF0aC5zaW4oWiksTj1NYXRoLmNvcyhaKTtyZXR1cm4gRlswXT1OKnR0K1gqayxGWzFdPU4qZXQrWCpodCxGWzJdPU4qaXQrWCpmdCxGWzNdPU4qay1YKnR0LEZbNF09TipodC1YKmV0LEZbNV09TipmdC1YKml0LEZbNl09QixGWzddPVcsRls4XT1WLEZ9ZnVuY3Rpb24gaShGLEcsWil7dmFyIHR0PVpbMF0sZXQ9WlsxXTtyZXR1cm4gRlswXT10dCpHWzBdLEZbMV09dHQqR1sxXSxGWzJdPXR0KkdbMl0sRlszXT1ldCpHWzNdLEZbNF09ZXQqR1s0XSxGWzVdPWV0KkdbNV0sRls2XT1HWzZdLEZbN109R1s3XSxGWzhdPUdbOF0sRn1mdW5jdGlvbiB1KEYsRyl7cmV0dXJuIEZbMF09MSxGWzFdPTAsRlsyXT0wLEZbM109MCxGWzRdPTEsRls1XT0wLEZbNl09R1swXSxGWzddPUdbMV0sRls4XT0xLEZ9ZnVuY3Rpb24gYShGLEcpe3ZhciBaPU1hdGguc2luKEcpLHR0PU1hdGguY29zKEcpO3JldHVybiBGWzBdPXR0LEZbMV09WixGWzJdPTAsRlszXT0tWixGWzRdPXR0LEZbNV09MCxGWzZdPTAsRls3XT0wLEZbOF09MSxGfWZ1bmN0aW9uIGgoRixHKXtyZXR1cm4gRlswXT1HWzBdLEZbMV09MCxGWzJdPTAsRlszXT0wLEZbNF09R1sxXSxGWzVdPTAsRls2XT0wLEZbN109MCxGWzhdPTEsRn1mdW5jdGlvbiBiKEYsRyl7cmV0dXJuIEZbMF09R1swXSxGWzFdPUdbMV0sRlsyXT0wLEZbM109R1syXSxGWzRdPUdbM10sRls1XT0wLEZbNl09R1s0XSxGWzddPUdbNV0sRls4XT0xLEZ9ZnVuY3Rpb24gRShGLEcpe3ZhciBaPUdbMF0sdHQ9R1sxXSxldD1HWzJdLGl0PUdbM10saz1aK1osaHQ9dHQrdHQsZnQ9ZXQrZXQsQj1aKmssVz10dCprLFY9dHQqaHQsWD1ldCprLE49ZXQqaHQsej1ldCpmdCxwPWl0KmssTT1pdCpodCx3PWl0KmZ0O3JldHVybiBGWzBdPTEtVi16LEZbM109Vy13LEZbNl09WCtNLEZbMV09Vyt3LEZbNF09MS1CLXosRls3XT1OLXAsRlsyXT1YLU0sRls1XT1OK3AsRls4XT0xLUItVixGfWZ1bmN0aW9uIEEoRixHKXt2YXIgWj1HWzBdLHR0PUdbMV0sZXQ9R1syXSxpdD1HWzNdLGs9R1s0XSxodD1HWzVdLGZ0PUdbNl0sQj1HWzddLFc9R1s4XSxWPUdbOV0sWD1HWzEwXSxOPUdbMTFdLHo9R1sxMl0scD1HWzEzXSxNPUdbMTRdLHc9R1sxNV0sVT1aKmh0LXR0KmssSz1aKmZ0LWV0KmssWT1aKkItaXQqayxRPXR0KmZ0LWV0Kmh0LHJ0PXR0KkItaXQqaHQsbnQ9ZXQqQi1pdCpmdCxhdD1XKnAtVip6LGN0PVcqTS1YKnosb3Q9Vyp3LU4qeixzdD1WKk0tWCpwLGx0PVYqdy1OKnAsbXQ9WCp3LU4qTSxwdD1VKm10LUsqbHQrWSpzdCtRKm90LXJ0KmN0K250KmF0O3JldHVybiBwdD8ocHQ9MS9wdCxGWzBdPShodCptdC1mdCpsdCtCKnN0KSpwdCxGWzFdPShmdCpvdC1rKm10LUIqY3QpKnB0LEZbMl09KGsqbHQtaHQqb3QrQiphdCkqcHQsRlszXT0oZXQqbHQtdHQqbXQtaXQqc3QpKnB0LEZbNF09KFoqbXQtZXQqb3QraXQqY3QpKnB0LEZbNV09KHR0Km90LVoqbHQtaXQqYXQpKnB0LEZbNl09KHAqbnQtTSpydCt3KlEpKnB0LEZbN109KE0qWS16Km50LXcqSykqcHQsRls4XT0oeipydC1wKlkrdypVKSpwdCxGKTpudWxsfWZ1bmN0aW9uIEwoRixHLFope3JldHVybiBGWzBdPTIvRyxGWzFdPTAsRlsyXT0wLEZbM109MCxGWzRdPS0yL1osRls1XT0wLEZbNl09LTEsRls3XT0xLEZbOF09MSxGfWZ1bmN0aW9uIFMoRil7cmV0dXJuIm1hdDMoIitGWzBdKyIsICIrRlsxXSsiLCAiK0ZbMl0rIiwgIitGWzNdKyIsICIrRls0XSsiLCAiK0ZbNV0rIiwgIitGWzZdKyIsICIrRls3XSsiLCAiK0ZbOF0rIikifWZ1bmN0aW9uIEkoRil7cmV0dXJuIE1hdGguaHlwb3QoRlswXSxGWzFdLEZbMl0sRlszXSxGWzRdLEZbNV0sRls2XSxGWzddLEZbOF0pfWZ1bmN0aW9uIEQoRixHLFope3JldHVybiBGWzBdPUdbMF0rWlswXSxGWzFdPUdbMV0rWlsxXSxGWzJdPUdbMl0rWlsyXSxGWzNdPUdbM10rWlszXSxGWzRdPUdbNF0rWls0XSxGWzVdPUdbNV0rWls1XSxGWzZdPUdbNl0rWls2XSxGWzddPUdbN10rWls3XSxGWzhdPUdbOF0rWls4XSxGfWZ1bmN0aW9uIFIoRixHLFope3JldHVybiBGWzBdPUdbMF0tWlswXSxGWzFdPUdbMV0tWlsxXSxGWzJdPUdbMl0tWlsyXSxGWzNdPUdbM10tWlszXSxGWzRdPUdbNF0tWls0XSxGWzVdPUdbNV0tWls1XSxGWzZdPUdbNl0tWls2XSxGWzddPUdbN10tWls3XSxGWzhdPUdbOF0tWls4XSxGfWZ1bmN0aW9uIEMoRixHLFope3JldHVybiBGWzBdPUdbMF0qWixGWzFdPUdbMV0qWixGWzJdPUdbMl0qWixGWzNdPUdbM10qWixGWzRdPUdbNF0qWixGWzVdPUdbNV0qWixGWzZdPUdbNl0qWixGWzddPUdbN10qWixGWzhdPUdbOF0qWixGfWZ1bmN0aW9uIGooRixHLFosdHQpe3JldHVybiBGWzBdPUdbMF0rWlswXSp0dCxGWzFdPUdbMV0rWlsxXSp0dCxGWzJdPUdbMl0rWlsyXSp0dCxGWzNdPUdbM10rWlszXSp0dCxGWzRdPUdbNF0rWls0XSp0dCxGWzVdPUdbNV0rWls1XSp0dCxGWzZdPUdbNl0rWls2XSp0dCxGWzddPUdbN10rWls3XSp0dCxGWzhdPUdbOF0rWls4XSp0dCxGfWZ1bmN0aW9uICQoRixHKXtyZXR1cm4gRlswXT09PUdbMF0mJkZbMV09PT1HWzFdJiZGWzJdPT09R1syXSYmRlszXT09PUdbM10mJkZbNF09PT1HWzRdJiZGWzVdPT09R1s1XSYmRls2XT09PUdbNl0mJkZbN109PT1HWzddJiZGWzhdPT09R1s4XX1mdW5jdGlvbiBIKEYsRyl7dmFyIFo9RlswXSx0dD1GWzFdLGV0PUZbMl0saXQ9RlszXSxrPUZbNF0saHQ9Rls1XSxmdD1GWzZdLEI9Rls3XSxXPUZbOF0sVj1HWzBdLFg9R1sxXSxOPUdbMl0sej1HWzNdLHA9R1s0XSxNPUdbNV0sdz1HWzZdLFU9R1s3XSxLPUdbOF07cmV0dXJuIE1hdGguYWJzKFotVik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFopLE1hdGguYWJzKFYpKSYmTWF0aC5hYnModHQtWCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHR0KSxNYXRoLmFicyhYKSkmJk1hdGguYWJzKGV0LU4pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhldCksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhpdC16KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaXQpLE1hdGguYWJzKHopKSYmTWF0aC5hYnMoay1wKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoayksTWF0aC5hYnMocCkpJiZNYXRoLmFicyhodC1NKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaHQpLE1hdGguYWJzKE0pKSYmTWF0aC5hYnMoZnQtdyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGZ0KSxNYXRoLmFicyh3KSkmJk1hdGguYWJzKEItVSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEIpLE1hdGguYWJzKFUpKSYmTWF0aC5hYnMoVy1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVyksTWF0aC5hYnMoSykpfXZhciBKPU8scT1SfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImZyb21YUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZnJvbVlSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJmcm9tWlJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImZyb21RdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJnZXRTY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImdldFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuICR9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJmcnVzdHVtIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInBlcnNwZWN0aXZlIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsInBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3IixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsIm9ydGhvIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImxvb2tBdCIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwidGFyZ2V0VG8iLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gaXR9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBOfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gen0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBwPW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzZdPTAscFs3XT0wLHBbOF09MCxwWzldPTAscFsxMV09MCxwWzEyXT0wLHBbMTNdPTAscFsxNF09MCkscFswXT0xLHBbNV09MSxwWzEwXT0xLHBbMTVdPTEscH1mdW5jdGlvbiBzKHApe3ZhciBNPW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiBNWzBdPXBbMF0sTVsxXT1wWzFdLE1bMl09cFsyXSxNWzNdPXBbM10sTVs0XT1wWzRdLE1bNV09cFs1XSxNWzZdPXBbNl0sTVs3XT1wWzddLE1bOF09cFs4XSxNWzldPXBbOV0sTVsxMF09cFsxMF0sTVsxMV09cFsxMV0sTVsxMl09cFsxMl0sTVsxM109cFsxM10sTVsxNF09cFsxNF0sTVsxNV09cFsxNV0sTX1mdW5jdGlvbiBsKHAsTSl7cmV0dXJuIHBbMF09TVswXSxwWzFdPU1bMV0scFsyXT1NWzJdLHBbM109TVszXSxwWzRdPU1bNF0scFs1XT1NWzVdLHBbNl09TVs2XSxwWzddPU1bN10scFs4XT1NWzhdLHBbOV09TVs5XSxwWzEwXT1NWzEwXSxwWzExXT1NWzExXSxwWzEyXT1NWzEyXSxwWzEzXT1NWzEzXSxwWzE0XT1NWzE0XSxwWzE1XT1NWzE1XSxwfWZ1bmN0aW9uIGMocCxNLHcsVSxLLFksUSxydCxudCxhdCxjdCxvdCxzdCxsdCxtdCxwdCl7dmFyIGR0PW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiBkdFswXT1wLGR0WzFdPU0sZHRbMl09dyxkdFszXT1VLGR0WzRdPUssZHRbNV09WSxkdFs2XT1RLGR0WzddPXJ0LGR0WzhdPW50LGR0WzldPWF0LGR0WzEwXT1jdCxkdFsxMV09b3QsZHRbMTJdPXN0LGR0WzEzXT1sdCxkdFsxNF09bXQsZHRbMTVdPXB0LGR0fWZ1bmN0aW9uIG8ocCxNLHcsVSxLLFksUSxydCxudCxhdCxjdCxvdCxzdCxsdCxtdCxwdCxkdCl7cmV0dXJuIHBbMF09TSxwWzFdPXcscFsyXT1VLHBbM109SyxwWzRdPVkscFs1XT1RLHBbNl09cnQscFs3XT1udCxwWzhdPWF0LHBbOV09Y3QscFsxMF09b3QscFsxMV09c3QscFsxMl09bHQscFsxM109bXQscFsxNF09cHQscFsxNV09ZHQscH1mdW5jdGlvbiBmKHApe3JldHVybiBwWzBdPTEscFsxXT0wLHBbMl09MCxwWzNdPTAscFs0XT0wLHBbNV09MSxwWzZdPTAscFs3XT0wLHBbOF09MCxwWzldPTAscFsxMF09MSxwWzExXT0wLHBbMTJdPTAscFsxM109MCxwWzE0XT0wLHBbMTVdPTEscH1mdW5jdGlvbiB4KHAsTSl7aWYocD09PU0pe3ZhciB3PU1bMV0sVT1NWzJdLEs9TVszXSxZPU1bNl0sUT1NWzddLHJ0PU1bMTFdO3BbMV09TVs0XSxwWzJdPU1bOF0scFszXT1NWzEyXSxwWzRdPXcscFs2XT1NWzldLHBbN109TVsxM10scFs4XT1VLHBbOV09WSxwWzExXT1NWzE0XSxwWzEyXT1LLHBbMTNdPVEscFsxNF09cnR9ZWxzZSBwWzBdPU1bMF0scFsxXT1NWzRdLHBbMl09TVs4XSxwWzNdPU1bMTJdLHBbNF09TVsxXSxwWzVdPU1bNV0scFs2XT1NWzldLHBbN109TVsxM10scFs4XT1NWzJdLHBbOV09TVs2XSxwWzEwXT1NWzEwXSxwWzExXT1NWzE0XSxwWzEyXT1NWzNdLHBbMTNdPU1bN10scFsxNF09TVsxMV0scFsxNV09TVsxNV07cmV0dXJuIHB9ZnVuY3Rpb24gZyhwLE0pe3ZhciB3PU1bMF0sVT1NWzFdLEs9TVsyXSxZPU1bM10sUT1NWzRdLHJ0PU1bNV0sbnQ9TVs2XSxhdD1NWzddLGN0PU1bOF0sb3Q9TVs5XSxzdD1NWzEwXSxsdD1NWzExXSxtdD1NWzEyXSxwdD1NWzEzXSxkdD1NWzE0XSx5dD1NWzE1XSxBdD13KnJ0LVUqUSxTdD13Km50LUsqUSxNdD13KmF0LVkqUSxUdD1VKm50LUsqcnQsRXQ9VSphdC1ZKnJ0LFV0PUsqYXQtWSpudCxCdD1jdCpwdC1vdCptdCxXdD1jdCpkdC1zdCptdCxGdD1jdCp5dC1sdCptdCwkdD1vdCpkdC1zdCpwdCxHdD1vdCp5dC1sdCpwdCxIdD1zdCp5dC1sdCpkdCxMdD1BdCpIdC1TdCpHdCtNdCokdCtUdCpGdC1FdCpXdCtVdCpCdDtyZXR1cm4gTHQ/KEx0PTEvTHQscFswXT0ocnQqSHQtbnQqR3QrYXQqJHQpKkx0LHBbMV09KEsqR3QtVSpIdC1ZKiR0KSpMdCxwWzJdPShwdCpVdC1kdCpFdCt5dCpUdCkqTHQscFszXT0oc3QqRXQtb3QqVXQtbHQqVHQpKkx0LHBbNF09KG50KkZ0LVEqSHQtYXQqV3QpKkx0LHBbNV09KHcqSHQtSypGdCtZKld0KSpMdCxwWzZdPShkdCpNdC1tdCpVdC15dCpTdCkqTHQscFs3XT0oY3QqVXQtc3QqTXQrbHQqU3QpKkx0LHBbOF09KFEqR3QtcnQqRnQrYXQqQnQpKkx0LHBbOV09KFUqRnQtdypHdC1ZKkJ0KSpMdCxwWzEwXT0obXQqRXQtcHQqTXQreXQqQXQpKkx0LHBbMTFdPShvdCpNdC1jdCpFdC1sdCpBdCkqTHQscFsxMl09KHJ0Kld0LVEqJHQtbnQqQnQpKkx0LHBbMTNdPSh3KiR0LVUqV3QrSypCdCkqTHQscFsxNF09KHB0KlN0LW10KlR0LWR0KkF0KSpMdCxwWzE1XT0oY3QqVHQtb3QqU3Qrc3QqQXQpKkx0LHApOm51bGx9ZnVuY3Rpb24geShwLE0pe3ZhciB3PU1bMF0sVT1NWzFdLEs9TVsyXSxZPU1bM10sUT1NWzRdLHJ0PU1bNV0sbnQ9TVs2XSxhdD1NWzddLGN0PU1bOF0sb3Q9TVs5XSxzdD1NWzEwXSxsdD1NWzExXSxtdD1NWzEyXSxwdD1NWzEzXSxkdD1NWzE0XSx5dD1NWzE1XTtyZXR1cm4gcFswXT1ydCooc3QqeXQtbHQqZHQpLW90KihudCp5dC1hdCpkdCkrcHQqKG50Kmx0LWF0KnN0KSxwWzFdPS0oVSooc3QqeXQtbHQqZHQpLW90KihLKnl0LVkqZHQpK3B0KihLKmx0LVkqc3QpKSxwWzJdPVUqKG50Knl0LWF0KmR0KS1ydCooSyp5dC1ZKmR0KStwdCooSyphdC1ZKm50KSxwWzNdPS0oVSoobnQqbHQtYXQqc3QpLXJ0KihLKmx0LVkqc3QpK290KihLKmF0LVkqbnQpKSxwWzRdPS0oUSooc3QqeXQtbHQqZHQpLWN0KihudCp5dC1hdCpkdCkrbXQqKG50Kmx0LWF0KnN0KSkscFs1XT13KihzdCp5dC1sdCpkdCktY3QqKEsqeXQtWSpkdCkrbXQqKEsqbHQtWSpzdCkscFs2XT0tKHcqKG50Knl0LWF0KmR0KS1RKihLKnl0LVkqZHQpK210KihLKmF0LVkqbnQpKSxwWzddPXcqKG50Kmx0LWF0KnN0KS1RKihLKmx0LVkqc3QpK2N0KihLKmF0LVkqbnQpLHBbOF09USoob3QqeXQtbHQqcHQpLWN0KihydCp5dC1hdCpwdCkrbXQqKHJ0Kmx0LWF0Km90KSxwWzldPS0odyoob3QqeXQtbHQqcHQpLWN0KihVKnl0LVkqcHQpK210KihVKmx0LVkqb3QpKSxwWzEwXT13KihydCp5dC1hdCpwdCktUSooVSp5dC1ZKnB0KSttdCooVSphdC1ZKnJ0KSxwWzExXT0tKHcqKHJ0Kmx0LWF0Km90KS1RKihVKmx0LVkqb3QpK2N0KihVKmF0LVkqcnQpKSxwWzEyXT0tKFEqKG90KmR0LXN0KnB0KS1jdCoocnQqZHQtbnQqcHQpK210KihydCpzdC1udCpvdCkpLHBbMTNdPXcqKG90KmR0LXN0KnB0KS1jdCooVSpkdC1LKnB0KSttdCooVSpzdC1LKm90KSxwWzE0XT0tKHcqKHJ0KmR0LW50KnB0KS1RKihVKmR0LUsqcHQpK210KihVKm50LUsqcnQpKSxwWzE1XT13KihydCpzdC1udCpvdCktUSooVSpzdC1LKm90KStjdCooVSpudC1LKnJ0KSxwfWZ1bmN0aW9uIG0ocCl7dmFyIE09cFswXSx3PXBbMV0sVT1wWzJdLEs9cFszXSxZPXBbNF0sUT1wWzVdLHJ0PXBbNl0sbnQ9cFs3XSxhdD1wWzhdLGN0PXBbOV0sb3Q9cFsxMF0sc3Q9cFsxMV0sbHQ9cFsxMl0sbXQ9cFsxM10scHQ9cFsxNF0sZHQ9cFsxNV0seXQ9TSpRLXcqWSxBdD1NKnJ0LVUqWSxTdD1NKm50LUsqWSxNdD13KnJ0LVUqUSxUdD13Km50LUsqUSxFdD1VKm50LUsqcnQsVXQ9YXQqbXQtY3QqbHQsQnQ9YXQqcHQtb3QqbHQsV3Q9YXQqZHQtc3QqbHQsRnQ9Y3QqcHQtb3QqbXQsJHQ9Y3QqZHQtc3QqbXQsR3Q9b3QqZHQtc3QqcHQ7cmV0dXJuIHl0Kkd0LUF0KiR0K1N0KkZ0K010Kld0LVR0KkJ0K0V0KlV0fWZ1bmN0aW9uIFQocCxNLHcpe3ZhciBVPU1bMF0sSz1NWzFdLFk9TVsyXSxRPU1bM10scnQ9TVs0XSxudD1NWzVdLGF0PU1bNl0sY3Q9TVs3XSxvdD1NWzhdLHN0PU1bOV0sbHQ9TVsxMF0sbXQ9TVsxMV0scHQ9TVsxMl0sZHQ9TVsxM10seXQ9TVsxNF0sQXQ9TVsxNV0sU3Q9d1swXSxNdD13WzFdLFR0PXdbMl0sRXQ9d1szXTtyZXR1cm4gcFswXT1TdCpVK010KnJ0K1R0Km90K0V0KnB0LHBbMV09U3QqSytNdCpudCtUdCpzdCtFdCpkdCxwWzJdPVN0KlkrTXQqYXQrVHQqbHQrRXQqeXQscFszXT1TdCpRK010KmN0K1R0Km10K0V0KkF0LFN0PXdbNF0sTXQ9d1s1XSxUdD13WzZdLEV0PXdbN10scFs0XT1TdCpVK010KnJ0K1R0Km90K0V0KnB0LHBbNV09U3QqSytNdCpudCtUdCpzdCtFdCpkdCxwWzZdPVN0KlkrTXQqYXQrVHQqbHQrRXQqeXQscFs3XT1TdCpRK010KmN0K1R0Km10K0V0KkF0LFN0PXdbOF0sTXQ9d1s5XSxUdD13WzEwXSxFdD13WzExXSxwWzhdPVN0KlUrTXQqcnQrVHQqb3QrRXQqcHQscFs5XT1TdCpLK010Km50K1R0KnN0K0V0KmR0LHBbMTBdPVN0KlkrTXQqYXQrVHQqbHQrRXQqeXQscFsxMV09U3QqUStNdCpjdCtUdCptdCtFdCpBdCxTdD13WzEyXSxNdD13WzEzXSxUdD13WzE0XSxFdD13WzE1XSxwWzEyXT1TdCpVK010KnJ0K1R0Km90K0V0KnB0LHBbMTNdPVN0KksrTXQqbnQrVHQqc3QrRXQqZHQscFsxNF09U3QqWStNdCphdCtUdCpsdCtFdCp5dCxwWzE1XT1TdCpRK010KmN0K1R0Km10K0V0KkF0LHB9ZnVuY3Rpb24gTyhwLE0sdyl7dmFyIFU9d1swXSxLPXdbMV0sWT13WzJdLFEscnQsbnQsYXQsY3Qsb3Qsc3QsbHQsbXQscHQsZHQseXQ7cmV0dXJuIE09PT1wPyhwWzEyXT1NWzBdKlUrTVs0XSpLK01bOF0qWStNWzEyXSxwWzEzXT1NWzFdKlUrTVs1XSpLK01bOV0qWStNWzEzXSxwWzE0XT1NWzJdKlUrTVs2XSpLK01bMTBdKlkrTVsxNF0scFsxNV09TVszXSpVK01bN10qSytNWzExXSpZK01bMTVdKTooUT1NWzBdLHJ0PU1bMV0sbnQ9TVsyXSxhdD1NWzNdLGN0PU1bNF0sb3Q9TVs1XSxzdD1NWzZdLGx0PU1bN10sbXQ9TVs4XSxwdD1NWzldLGR0PU1bMTBdLHl0PU1bMTFdLHBbMF09USxwWzFdPXJ0LHBbMl09bnQscFszXT1hdCxwWzRdPWN0LHBbNV09b3QscFs2XT1zdCxwWzddPWx0LHBbOF09bXQscFs5XT1wdCxwWzEwXT1kdCxwWzExXT15dCxwWzEyXT1RKlUrY3QqSyttdCpZK01bMTJdLHBbMTNdPXJ0KlUrb3QqSytwdCpZK01bMTNdLHBbMTRdPW50KlUrc3QqSytkdCpZK01bMTRdLHBbMTVdPWF0KlUrbHQqSyt5dCpZK01bMTVdKSxwfWZ1bmN0aW9uIHYocCxNLHcpe3ZhciBVPXdbMF0sSz13WzFdLFk9d1syXTtyZXR1cm4gcFswXT1NWzBdKlUscFsxXT1NWzFdKlUscFsyXT1NWzJdKlUscFszXT1NWzNdKlUscFs0XT1NWzRdKksscFs1XT1NWzVdKksscFs2XT1NWzZdKksscFs3XT1NWzddKksscFs4XT1NWzhdKlkscFs5XT1NWzldKlkscFsxMF09TVsxMF0qWSxwWzExXT1NWzExXSpZLHBbMTJdPU1bMTJdLHBbMTNdPU1bMTNdLHBbMTRdPU1bMTRdLHBbMTVdPU1bMTVdLHB9ZnVuY3Rpb24gUChwLE0sdyxVKXt2YXIgSz1VWzBdLFk9VVsxXSxRPVVbMl0scnQ9TWF0aC5oeXBvdChLLFksUSksbnQsYXQsY3Qsb3Qsc3QsbHQsbXQscHQsZHQseXQsQXQsU3QsTXQsVHQsRXQsVXQsQnQsV3QsRnQsJHQsR3QsSHQsTHQsWnQ7cmV0dXJuIHJ0PHIuRVBTSUxPTj9udWxsOihydD0xL3J0LEsqPXJ0LFkqPXJ0LFEqPXJ0LG50PU1hdGguc2luKHcpLGF0PU1hdGguY29zKHcpLGN0PTEtYXQsb3Q9TVswXSxzdD1NWzFdLGx0PU1bMl0sbXQ9TVszXSxwdD1NWzRdLGR0PU1bNV0seXQ9TVs2XSxBdD1NWzddLFN0PU1bOF0sTXQ9TVs5XSxUdD1NWzEwXSxFdD1NWzExXSxVdD1LKksqY3QrYXQsQnQ9WSpLKmN0K1EqbnQsV3Q9USpLKmN0LVkqbnQsRnQ9SypZKmN0LVEqbnQsJHQ9WSpZKmN0K2F0LEd0PVEqWSpjdCtLKm50LEh0PUsqUSpjdCtZKm50LEx0PVkqUSpjdC1LKm50LFp0PVEqUSpjdCthdCxwWzBdPW90KlV0K3B0KkJ0K1N0Kld0LHBbMV09c3QqVXQrZHQqQnQrTXQqV3QscFsyXT1sdCpVdCt5dCpCdCtUdCpXdCxwWzNdPW10KlV0K0F0KkJ0K0V0Kld0LHBbNF09b3QqRnQrcHQqJHQrU3QqR3QscFs1XT1zdCpGdCtkdCokdCtNdCpHdCxwWzZdPWx0KkZ0K3l0KiR0K1R0Kkd0LHBbN109bXQqRnQrQXQqJHQrRXQqR3QscFs4XT1vdCpIdCtwdCpMdCtTdCpadCxwWzldPXN0Kkh0K2R0Kkx0K010Klp0LHBbMTBdPWx0Kkh0K3l0Kkx0K1R0Klp0LHBbMTFdPW10Kkh0K0F0Kkx0K0V0Klp0LE0hPT1wJiYocFsxMl09TVsxMl0scFsxM109TVsxM10scFsxNF09TVsxNF0scFsxNV09TVsxNV0pLHApfWZ1bmN0aW9uIGkocCxNLHcpe3ZhciBVPU1hdGguc2luKHcpLEs9TWF0aC5jb3ModyksWT1NWzRdLFE9TVs1XSxydD1NWzZdLG50PU1bN10sYXQ9TVs4XSxjdD1NWzldLG90PU1bMTBdLHN0PU1bMTFdO3JldHVybiBNIT09cCYmKHBbMF09TVswXSxwWzFdPU1bMV0scFsyXT1NWzJdLHBbM109TVszXSxwWzEyXT1NWzEyXSxwWzEzXT1NWzEzXSxwWzE0XT1NWzE0XSxwWzE1XT1NWzE1XSkscFs0XT1ZKksrYXQqVSxwWzVdPVEqSytjdCpVLHBbNl09cnQqSytvdCpVLHBbN109bnQqSytzdCpVLHBbOF09YXQqSy1ZKlUscFs5XT1jdCpLLVEqVSxwWzEwXT1vdCpLLXJ0KlUscFsxMV09c3QqSy1udCpVLHB9ZnVuY3Rpb24gdShwLE0sdyl7dmFyIFU9TWF0aC5zaW4odyksSz1NYXRoLmNvcyh3KSxZPU1bMF0sUT1NWzFdLHJ0PU1bMl0sbnQ9TVszXSxhdD1NWzhdLGN0PU1bOV0sb3Q9TVsxMF0sc3Q9TVsxMV07cmV0dXJuIE0hPT1wJiYocFs0XT1NWzRdLHBbNV09TVs1XSxwWzZdPU1bNl0scFs3XT1NWzddLHBbMTJdPU1bMTJdLHBbMTNdPU1bMTNdLHBbMTRdPU1bMTRdLHBbMTVdPU1bMTVdKSxwWzBdPVkqSy1hdCpVLHBbMV09USpLLWN0KlUscFsyXT1ydCpLLW90KlUscFszXT1udCpLLXN0KlUscFs4XT1ZKlUrYXQqSyxwWzldPVEqVStjdCpLLHBbMTBdPXJ0KlUrb3QqSyxwWzExXT1udCpVK3N0KksscH1mdW5jdGlvbiBhKHAsTSx3KXt2YXIgVT1NYXRoLnNpbih3KSxLPU1hdGguY29zKHcpLFk9TVswXSxRPU1bMV0scnQ9TVsyXSxudD1NWzNdLGF0PU1bNF0sY3Q9TVs1XSxvdD1NWzZdLHN0PU1bN107cmV0dXJuIE0hPT1wJiYocFs4XT1NWzhdLHBbOV09TVs5XSxwWzEwXT1NWzEwXSxwWzExXT1NWzExXSxwWzEyXT1NWzEyXSxwWzEzXT1NWzEzXSxwWzE0XT1NWzE0XSxwWzE1XT1NWzE1XSkscFswXT1ZKksrYXQqVSxwWzFdPVEqSytjdCpVLHBbMl09cnQqSytvdCpVLHBbM109bnQqSytzdCpVLHBbNF09YXQqSy1ZKlUscFs1XT1jdCpLLVEqVSxwWzZdPW90KkstcnQqVSxwWzddPXN0KkstbnQqVSxwfWZ1bmN0aW9uIGgocCxNKXtyZXR1cm4gcFswXT0xLHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzVdPTEscFs2XT0wLHBbN109MCxwWzhdPTAscFs5XT0wLHBbMTBdPTEscFsxMV09MCxwWzEyXT1NWzBdLHBbMTNdPU1bMV0scFsxNF09TVsyXSxwWzE1XT0xLHB9ZnVuY3Rpb24gYihwLE0pe3JldHVybiBwWzBdPU1bMF0scFsxXT0wLHBbMl09MCxwWzNdPTAscFs0XT0wLHBbNV09TVsxXSxwWzZdPTAscFs3XT0wLHBbOF09MCxwWzldPTAscFsxMF09TVsyXSxwWzExXT0wLHBbMTJdPTAscFsxM109MCxwWzE0XT0wLHBbMTVdPTEscH1mdW5jdGlvbiBFKHAsTSx3KXt2YXIgVT13WzBdLEs9d1sxXSxZPXdbMl0sUT1NYXRoLmh5cG90KFUsSyxZKSxydCxudCxhdDtyZXR1cm4gUTxyLkVQU0lMT04/bnVsbDooUT0xL1EsVSo9USxLKj1RLFkqPVEscnQ9TWF0aC5zaW4oTSksbnQ9TWF0aC5jb3MoTSksYXQ9MS1udCxwWzBdPVUqVSphdCtudCxwWzFdPUsqVSphdCtZKnJ0LHBbMl09WSpVKmF0LUsqcnQscFszXT0wLHBbNF09VSpLKmF0LVkqcnQscFs1XT1LKksqYXQrbnQscFs2XT1ZKksqYXQrVSpydCxwWzddPTAscFs4XT1VKlkqYXQrSypydCxwWzldPUsqWSphdC1VKnJ0LHBbMTBdPVkqWSphdCtudCxwWzExXT0wLHBbMTJdPTAscFsxM109MCxwWzE0XT0wLHBbMTVdPTEscCl9ZnVuY3Rpb24gQShwLE0pe3ZhciB3PU1hdGguc2luKE0pLFU9TWF0aC5jb3MoTSk7cmV0dXJuIHBbMF09MSxwWzFdPTAscFsyXT0wLHBbM109MCxwWzRdPTAscFs1XT1VLHBbNl09dyxwWzddPTAscFs4XT0wLHBbOV09LXcscFsxMF09VSxwWzExXT0wLHBbMTJdPTAscFsxM109MCxwWzE0XT0wLHBbMTVdPTEscH1mdW5jdGlvbiBMKHAsTSl7dmFyIHc9TWF0aC5zaW4oTSksVT1NYXRoLmNvcyhNKTtyZXR1cm4gcFswXT1VLHBbMV09MCxwWzJdPS13LHBbM109MCxwWzRdPTAscFs1XT0xLHBbNl09MCxwWzddPTAscFs4XT13LHBbOV09MCxwWzEwXT1VLHBbMTFdPTAscFsxMl09MCxwWzEzXT0wLHBbMTRdPTAscFsxNV09MSxwfWZ1bmN0aW9uIFMocCxNKXt2YXIgdz1NYXRoLnNpbihNKSxVPU1hdGguY29zKE0pO3JldHVybiBwWzBdPVUscFsxXT13LHBbMl09MCxwWzNdPTAscFs0XT0tdyxwWzVdPVUscFs2XT0wLHBbN109MCxwWzhdPTAscFs5XT0wLHBbMTBdPTEscFsxMV09MCxwWzEyXT0wLHBbMTNdPTAscFsxNF09MCxwWzE1XT0xLHB9ZnVuY3Rpb24gSShwLE0sdyl7dmFyIFU9TVswXSxLPU1bMV0sWT1NWzJdLFE9TVszXSxydD1VK1UsbnQ9SytLLGF0PVkrWSxjdD1VKnJ0LG90PVUqbnQsc3Q9VSphdCxsdD1LKm50LG10PUsqYXQscHQ9WSphdCxkdD1RKnJ0LHl0PVEqbnQsQXQ9USphdDtyZXR1cm4gcFswXT0xLShsdCtwdCkscFsxXT1vdCtBdCxwWzJdPXN0LXl0LHBbM109MCxwWzRdPW90LUF0LHBbNV09MS0oY3QrcHQpLHBbNl09bXQrZHQscFs3XT0wLHBbOF09c3QreXQscFs5XT1tdC1kdCxwWzEwXT0xLShjdCtsdCkscFsxMV09MCxwWzEyXT13WzBdLHBbMTNdPXdbMV0scFsxNF09d1syXSxwWzE1XT0xLHB9ZnVuY3Rpb24gRChwLE0pe3ZhciB3PW5ldyByLkFSUkFZX1RZUEUoMyksVT0tTVswXSxLPS1NWzFdLFk9LU1bMl0sUT1NWzNdLHJ0PU1bNF0sbnQ9TVs1XSxhdD1NWzZdLGN0PU1bN10sb3Q9VSpVK0sqSytZKlkrUSpRO3JldHVybiBvdD4wPyh3WzBdPShydCpRK2N0KlUrbnQqWS1hdCpLKSoyL290LHdbMV09KG50KlErY3QqSythdCpVLXJ0KlkpKjIvb3Qsd1syXT0oYXQqUStjdCpZK3J0KkstbnQqVSkqMi9vdCk6KHdbMF09KHJ0KlErY3QqVStudCpZLWF0KkspKjIsd1sxXT0obnQqUStjdCpLK2F0KlUtcnQqWSkqMix3WzJdPShhdCpRK2N0KlkrcnQqSy1udCpVKSoyKSxJKHAsTSx3KSxwfWZ1bmN0aW9uIFIocCxNKXtyZXR1cm4gcFswXT1NWzEyXSxwWzFdPU1bMTNdLHBbMl09TVsxNF0scH1mdW5jdGlvbiBDKHAsTSl7dmFyIHc9TVswXSxVPU1bMV0sSz1NWzJdLFk9TVs0XSxRPU1bNV0scnQ9TVs2XSxudD1NWzhdLGF0PU1bOV0sY3Q9TVsxMF07cmV0dXJuIHBbMF09TWF0aC5oeXBvdCh3LFUsSykscFsxXT1NYXRoLmh5cG90KFksUSxydCkscFsyXT1NYXRoLmh5cG90KG50LGF0LGN0KSxwfWZ1bmN0aW9uIGoocCxNKXt2YXIgdz1uZXcgci5BUlJBWV9UWVBFKDMpO0ModyxNKTt2YXIgVT0xL3dbMF0sSz0xL3dbMV0sWT0xL3dbMl0sUT1NWzBdKlUscnQ9TVsxXSpLLG50PU1bMl0qWSxhdD1NWzRdKlUsY3Q9TVs1XSpLLG90PU1bNl0qWSxzdD1NWzhdKlUsbHQ9TVs5XSpLLG10PU1bMTBdKlkscHQ9UStjdCttdCxkdD0wO3JldHVybiBwdD4wPyhkdD1NYXRoLnNxcnQocHQrMSkqMixwWzNdPS4yNSpkdCxwWzBdPShvdC1sdCkvZHQscFsxXT0oc3QtbnQpL2R0LHBbMl09KHJ0LWF0KS9kdCk6UT5jdCYmUT5tdD8oZHQ9TWF0aC5zcXJ0KDErUS1jdC1tdCkqMixwWzNdPShvdC1sdCkvZHQscFswXT0uMjUqZHQscFsxXT0ocnQrYXQpL2R0LHBbMl09KHN0K250KS9kdCk6Y3Q+bXQ/KGR0PU1hdGguc3FydCgxK2N0LVEtbXQpKjIscFszXT0oc3QtbnQpL2R0LHBbMF09KHJ0K2F0KS9kdCxwWzFdPS4yNSpkdCxwWzJdPShvdCtsdCkvZHQpOihkdD1NYXRoLnNxcnQoMSttdC1RLWN0KSoyLHBbM109KHJ0LWF0KS9kdCxwWzBdPShzdCtudCkvZHQscFsxXT0ob3QrbHQpL2R0LHBbMl09LjI1KmR0KSxwfWZ1bmN0aW9uICQocCxNLHcsVSl7dmFyIEs9TVswXSxZPU1bMV0sUT1NWzJdLHJ0PU1bM10sbnQ9SytLLGF0PVkrWSxjdD1RK1Esb3Q9SypudCxzdD1LKmF0LGx0PUsqY3QsbXQ9WSphdCxwdD1ZKmN0LGR0PVEqY3QseXQ9cnQqbnQsQXQ9cnQqYXQsU3Q9cnQqY3QsTXQ9VVswXSxUdD1VWzFdLEV0PVVbMl07cmV0dXJuIHBbMF09KDEtKG10K2R0KSkqTXQscFsxXT0oc3QrU3QpKk10LHBbMl09KGx0LUF0KSpNdCxwWzNdPTAscFs0XT0oc3QtU3QpKlR0LHBbNV09KDEtKG90K2R0KSkqVHQscFs2XT0ocHQreXQpKlR0LHBbN109MCxwWzhdPShsdCtBdCkqRXQscFs5XT0ocHQteXQpKkV0LHBbMTBdPSgxLShvdCttdCkpKkV0LHBbMTFdPTAscFsxMl09d1swXSxwWzEzXT13WzFdLHBbMTRdPXdbMl0scFsxNV09MSxwfWZ1bmN0aW9uIEgocCxNLHcsVSxLKXt2YXIgWT1NWzBdLFE9TVsxXSxydD1NWzJdLG50PU1bM10sYXQ9WStZLGN0PVErUSxvdD1ydCtydCxzdD1ZKmF0LGx0PVkqY3QsbXQ9WSpvdCxwdD1RKmN0LGR0PVEqb3QseXQ9cnQqb3QsQXQ9bnQqYXQsU3Q9bnQqY3QsTXQ9bnQqb3QsVHQ9VVswXSxFdD1VWzFdLFV0PVVbMl0sQnQ9S1swXSxXdD1LWzFdLEZ0PUtbMl0sJHQ9KDEtKHB0K3l0KSkqVHQsR3Q9KGx0K010KSpUdCxIdD0obXQtU3QpKlR0LEx0PShsdC1NdCkqRXQsWnQ9KDEtKHN0K3l0KSkqRXQsYmU9KGR0K0F0KSpFdCxTZT0obXQrU3QpKlV0LFJuPShkdC1BdCkqVXQsSW49KDEtKHN0K3B0KSkqVXQ7cmV0dXJuIHBbMF09JHQscFsxXT1HdCxwWzJdPUh0LHBbM109MCxwWzRdPUx0LHBbNV09WnQscFs2XT1iZSxwWzddPTAscFs4XT1TZSxwWzldPVJuLHBbMTBdPUluLHBbMTFdPTAscFsxMl09d1swXStCdC0oJHQqQnQrTHQqV3QrU2UqRnQpLHBbMTNdPXdbMV0rV3QtKEd0KkJ0K1p0Kld0K1JuKkZ0KSxwWzE0XT13WzJdK0Z0LShIdCpCdCtiZSpXdCtJbipGdCkscFsxNV09MSxwfWZ1bmN0aW9uIEoocCxNKXt2YXIgdz1NWzBdLFU9TVsxXSxLPU1bMl0sWT1NWzNdLFE9dyt3LHJ0PVUrVSxudD1LK0ssYXQ9dypRLGN0PVUqUSxvdD1VKnJ0LHN0PUsqUSxsdD1LKnJ0LG10PUsqbnQscHQ9WSpRLGR0PVkqcnQseXQ9WSpudDtyZXR1cm4gcFswXT0xLW90LW10LHBbMV09Y3QreXQscFsyXT1zdC1kdCxwWzNdPTAscFs0XT1jdC15dCxwWzVdPTEtYXQtbXQscFs2XT1sdCtwdCxwWzddPTAscFs4XT1zdCtkdCxwWzldPWx0LXB0LHBbMTBdPTEtYXQtb3QscFsxMV09MCxwWzEyXT0wLHBbMTNdPTAscFsxNF09MCxwWzE1XT0xLHB9ZnVuY3Rpb24gcShwLE0sdyxVLEssWSxRKXt2YXIgcnQ9MS8ody1NKSxudD0xLyhLLVUpLGF0PTEvKFktUSk7cmV0dXJuIHBbMF09WSoyKnJ0LHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzVdPVkqMipudCxwWzZdPTAscFs3XT0wLHBbOF09KHcrTSkqcnQscFs5XT0oSytVKSpudCxwWzEwXT0oUStZKSphdCxwWzExXT0tMSxwWzEyXT0wLHBbMTNdPTAscFsxNF09USpZKjIqYXQscFsxNV09MCxwfWZ1bmN0aW9uIEYocCxNLHcsVSxLKXt2YXIgWT0xL01hdGgudGFuKE0vMiksUTtyZXR1cm4gcFswXT1ZL3cscFsxXT0wLHBbMl09MCxwWzNdPTAscFs0XT0wLHBbNV09WSxwWzZdPTAscFs3XT0wLHBbOF09MCxwWzldPTAscFsxMV09LTEscFsxMl09MCxwWzEzXT0wLHBbMTVdPTAsSyE9bnVsbCYmSyE9PTEvMD8oUT0xLyhVLUspLHBbMTBdPShLK1UpKlEscFsxNF09MipLKlUqUSk6KHBbMTBdPS0xLHBbMTRdPS0yKlUpLHB9ZnVuY3Rpb24gRyhwLE0sdyxVKXt2YXIgSz1NYXRoLnRhbihNLnVwRGVncmVlcypNYXRoLlBJLzE4MCksWT1NYXRoLnRhbihNLmRvd25EZWdyZWVzKk1hdGguUEkvMTgwKSxRPU1hdGgudGFuKE0ubGVmdERlZ3JlZXMqTWF0aC5QSS8xODApLHJ0PU1hdGgudGFuKE0ucmlnaHREZWdyZWVzKk1hdGguUEkvMTgwKSxudD0yLyhRK3J0KSxhdD0yLyhLK1kpO3JldHVybiBwWzBdPW50LHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzVdPWF0LHBbNl09MCxwWzddPTAscFs4XT0tKChRLXJ0KSpudCouNSkscFs5XT0oSy1ZKSphdCouNSxwWzEwXT1VLyh3LVUpLHBbMTFdPS0xLHBbMTJdPTAscFsxM109MCxwWzE0XT1VKncvKHctVSkscFsxNV09MCxwfWZ1bmN0aW9uIFoocCxNLHcsVSxLLFksUSl7dmFyIHJ0PTEvKE0tdyksbnQ9MS8oVS1LKSxhdD0xLyhZLVEpO3JldHVybiBwWzBdPS0yKnJ0LHBbMV09MCxwWzJdPTAscFszXT0wLHBbNF09MCxwWzVdPS0yKm50LHBbNl09MCxwWzddPTAscFs4XT0wLHBbOV09MCxwWzEwXT0yKmF0LHBbMTFdPTAscFsxMl09KE0rdykqcnQscFsxM109KEsrVSkqbnQscFsxNF09KFErWSkqYXQscFsxNV09MSxwfWZ1bmN0aW9uIHR0KHAsTSx3LFUpe3ZhciBLLFksUSxydCxudCxhdCxjdCxvdCxzdCxsdCxtdD1NWzBdLHB0PU1bMV0sZHQ9TVsyXSx5dD1VWzBdLEF0PVVbMV0sU3Q9VVsyXSxNdD13WzBdLFR0PXdbMV0sRXQ9d1syXTtyZXR1cm4gTWF0aC5hYnMobXQtTXQpPHIuRVBTSUxPTiYmTWF0aC5hYnMocHQtVHQpPHIuRVBTSUxPTiYmTWF0aC5hYnMoZHQtRXQpPHIuRVBTSUxPTj9mKHApOihjdD1tdC1NdCxvdD1wdC1UdCxzdD1kdC1FdCxsdD0xL01hdGguaHlwb3QoY3Qsb3Qsc3QpLGN0Kj1sdCxvdCo9bHQsc3QqPWx0LEs9QXQqc3QtU3Qqb3QsWT1TdCpjdC15dCpzdCxRPXl0Km90LUF0KmN0LGx0PU1hdGguaHlwb3QoSyxZLFEpLGx0PyhsdD0xL2x0LEsqPWx0LFkqPWx0LFEqPWx0KTooSz0wLFk9MCxRPTApLHJ0PW90KlEtc3QqWSxudD1zdCpLLWN0KlEsYXQ9Y3QqWS1vdCpLLGx0PU1hdGguaHlwb3QocnQsbnQsYXQpLGx0PyhsdD0xL2x0LHJ0Kj1sdCxudCo9bHQsYXQqPWx0KToocnQ9MCxudD0wLGF0PTApLHBbMF09SyxwWzFdPXJ0LHBbMl09Y3QscFszXT0wLHBbNF09WSxwWzVdPW50LHBbNl09b3QscFs3XT0wLHBbOF09USxwWzldPWF0LHBbMTBdPXN0LHBbMTFdPTAscFsxMl09LShLKm10K1kqcHQrUSpkdCkscFsxM109LShydCptdCtudCpwdCthdCpkdCkscFsxNF09LShjdCptdCtvdCpwdCtzdCpkdCkscFsxNV09MSxwKX1mdW5jdGlvbiBldChwLE0sdyxVKXt2YXIgSz1NWzBdLFk9TVsxXSxRPU1bMl0scnQ9VVswXSxudD1VWzFdLGF0PVVbMl0sY3Q9Sy13WzBdLG90PVktd1sxXSxzdD1RLXdbMl0sbHQ9Y3QqY3Qrb3Qqb3Qrc3Qqc3Q7bHQ+MCYmKGx0PTEvTWF0aC5zcXJ0KGx0KSxjdCo9bHQsb3QqPWx0LHN0Kj1sdCk7dmFyIG10PW50KnN0LWF0Km90LHB0PWF0KmN0LXJ0KnN0LGR0PXJ0Km90LW50KmN0O3JldHVybiBsdD1tdCptdCtwdCpwdCtkdCpkdCxsdD4wJiYobHQ9MS9NYXRoLnNxcnQobHQpLG10Kj1sdCxwdCo9bHQsZHQqPWx0KSxwWzBdPW10LHBbMV09cHQscFsyXT1kdCxwWzNdPTAscFs0XT1vdCpkdC1zdCpwdCxwWzVdPXN0Km10LWN0KmR0LHBbNl09Y3QqcHQtb3QqbXQscFs3XT0wLHBbOF09Y3QscFs5XT1vdCxwWzEwXT1zdCxwWzExXT0wLHBbMTJdPUsscFsxM109WSxwWzE0XT1RLHBbMTVdPTEscH1mdW5jdGlvbiBpdChwKXtyZXR1cm4ibWF0NCgiK3BbMF0rIiwgIitwWzFdKyIsICIrcFsyXSsiLCAiK3BbM10rIiwgIitwWzRdKyIsICIrcFs1XSsiLCAiK3BbNl0rIiwgIitwWzddKyIsICIrcFs4XSsiLCAiK3BbOV0rIiwgIitwWzEwXSsiLCAiK3BbMTFdKyIsICIrcFsxMl0rIiwgIitwWzEzXSsiLCAiK3BbMTRdKyIsICIrcFsxNV0rIikifWZ1bmN0aW9uIGsocCl7cmV0dXJuIE1hdGguaHlwb3QocFswXSxwWzFdLHBbMl0scFszXSxwWzRdLHBbNV0scFs2XSxwWzddLHBbOF0scFs5XSxwWzEwXSxwWzExXSxwWzEyXSxwWzEzXSxwWzE0XSxwWzE1XSl9ZnVuY3Rpb24gaHQocCxNLHcpe3JldHVybiBwWzBdPU1bMF0rd1swXSxwWzFdPU1bMV0rd1sxXSxwWzJdPU1bMl0rd1syXSxwWzNdPU1bM10rd1szXSxwWzRdPU1bNF0rd1s0XSxwWzVdPU1bNV0rd1s1XSxwWzZdPU1bNl0rd1s2XSxwWzddPU1bN10rd1s3XSxwWzhdPU1bOF0rd1s4XSxwWzldPU1bOV0rd1s5XSxwWzEwXT1NWzEwXSt3WzEwXSxwWzExXT1NWzExXSt3WzExXSxwWzEyXT1NWzEyXSt3WzEyXSxwWzEzXT1NWzEzXSt3WzEzXSxwWzE0XT1NWzE0XSt3WzE0XSxwWzE1XT1NWzE1XSt3WzE1XSxwfWZ1bmN0aW9uIGZ0KHAsTSx3KXtyZXR1cm4gcFswXT1NWzBdLXdbMF0scFsxXT1NWzFdLXdbMV0scFsyXT1NWzJdLXdbMl0scFszXT1NWzNdLXdbM10scFs0XT1NWzRdLXdbNF0scFs1XT1NWzVdLXdbNV0scFs2XT1NWzZdLXdbNl0scFs3XT1NWzddLXdbN10scFs4XT1NWzhdLXdbOF0scFs5XT1NWzldLXdbOV0scFsxMF09TVsxMF0td1sxMF0scFsxMV09TVsxMV0td1sxMV0scFsxMl09TVsxMl0td1sxMl0scFsxM109TVsxM10td1sxM10scFsxNF09TVsxNF0td1sxNF0scFsxNV09TVsxNV0td1sxNV0scH1mdW5jdGlvbiBCKHAsTSx3KXtyZXR1cm4gcFswXT1NWzBdKncscFsxXT1NWzFdKncscFsyXT1NWzJdKncscFszXT1NWzNdKncscFs0XT1NWzRdKncscFs1XT1NWzVdKncscFs2XT1NWzZdKncscFs3XT1NWzddKncscFs4XT1NWzhdKncscFs5XT1NWzldKncscFsxMF09TVsxMF0qdyxwWzExXT1NWzExXSp3LHBbMTJdPU1bMTJdKncscFsxM109TVsxM10qdyxwWzE0XT1NWzE0XSp3LHBbMTVdPU1bMTVdKncscH1mdW5jdGlvbiBXKHAsTSx3LFUpe3JldHVybiBwWzBdPU1bMF0rd1swXSpVLHBbMV09TVsxXSt3WzFdKlUscFsyXT1NWzJdK3dbMl0qVSxwWzNdPU1bM10rd1szXSpVLHBbNF09TVs0XSt3WzRdKlUscFs1XT1NWzVdK3dbNV0qVSxwWzZdPU1bNl0rd1s2XSpVLHBbN109TVs3XSt3WzddKlUscFs4XT1NWzhdK3dbOF0qVSxwWzldPU1bOV0rd1s5XSpVLHBbMTBdPU1bMTBdK3dbMTBdKlUscFsxMV09TVsxMV0rd1sxMV0qVSxwWzEyXT1NWzEyXSt3WzEyXSpVLHBbMTNdPU1bMTNdK3dbMTNdKlUscFsxNF09TVsxNF0rd1sxNF0qVSxwWzE1XT1NWzE1XSt3WzE1XSpVLHB9ZnVuY3Rpb24gVihwLE0pe3JldHVybiBwWzBdPT09TVswXSYmcFsxXT09PU1bMV0mJnBbMl09PT1NWzJdJiZwWzNdPT09TVszXSYmcFs0XT09PU1bNF0mJnBbNV09PT1NWzVdJiZwWzZdPT09TVs2XSYmcFs3XT09PU1bN10mJnBbOF09PT1NWzhdJiZwWzldPT09TVs5XSYmcFsxMF09PT1NWzEwXSYmcFsxMV09PT1NWzExXSYmcFsxMl09PT1NWzEyXSYmcFsxM109PT1NWzEzXSYmcFsxNF09PT1NWzE0XSYmcFsxNV09PT1NWzE1XX1mdW5jdGlvbiBYKHAsTSl7dmFyIHc9cFswXSxVPXBbMV0sSz1wWzJdLFk9cFszXSxRPXBbNF0scnQ9cFs1XSxudD1wWzZdLGF0PXBbN10sY3Q9cFs4XSxvdD1wWzldLHN0PXBbMTBdLGx0PXBbMTFdLG10PXBbMTJdLHB0PXBbMTNdLGR0PXBbMTRdLHl0PXBbMTVdLEF0PU1bMF0sU3Q9TVsxXSxNdD1NWzJdLFR0PU1bM10sRXQ9TVs0XSxVdD1NWzVdLEJ0PU1bNl0sV3Q9TVs3XSxGdD1NWzhdLCR0PU1bOV0sR3Q9TVsxMF0sSHQ9TVsxMV0sTHQ9TVsxMl0sWnQ9TVsxM10sYmU9TVsxNF0sU2U9TVsxNV07cmV0dXJuIE1hdGguYWJzKHctQXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhBdCkpJiZNYXRoLmFicyhVLVN0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoU3QpKSYmTWF0aC5hYnMoSy1NdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEspLE1hdGguYWJzKE10KSkmJk1hdGguYWJzKFktVHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhZKSxNYXRoLmFicyhUdCkpJiZNYXRoLmFicyhRLUV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoUSksTWF0aC5hYnMoRXQpKSYmTWF0aC5hYnMocnQtVXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhydCksTWF0aC5hYnMoVXQpKSYmTWF0aC5hYnMobnQtQnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhudCksTWF0aC5hYnMoQnQpKSYmTWF0aC5hYnMoYXQtV3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhdCksTWF0aC5hYnMoV3QpKSYmTWF0aC5hYnMoY3QtRnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhjdCksTWF0aC5hYnMoRnQpKSYmTWF0aC5hYnMob3QtJHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhvdCksTWF0aC5hYnMoJHQpKSYmTWF0aC5hYnMoc3QtR3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhzdCksTWF0aC5hYnMoR3QpKSYmTWF0aC5hYnMobHQtSHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhsdCksTWF0aC5hYnMoSHQpKSYmTWF0aC5hYnMobXQtTHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhtdCksTWF0aC5hYnMoTHQpKSYmTWF0aC5hYnMocHQtWnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhwdCksTWF0aC5hYnMoWnQpKSYmTWF0aC5hYnMoZHQtYmUpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhkdCksTWF0aC5hYnMoYmUpKSYmTWF0aC5hYnMoeXQtU2UpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh5dCksTWF0aC5hYnMoU2UpKX12YXIgTj1ULHo9ZnR9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzZXRBeGlzQW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZ2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImdldEFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImNhbGN1bGF0ZVciLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZXhwIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImxuIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInBvdyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzbGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJmcm9tTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJmcm9tRXVsZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBpdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwicm90YXRpb25UbyIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3FsZXJwIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJzZXRBeGVzIixmdW5jdGlvbigpe3JldHVybiBCfSk7dmFyIHI9dCgyKSxuPXQoNSkscz10KDgpLGw9dCg5KTtmdW5jdGlvbiBjKCl7dmFyIFc9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihXWzBdPTAsV1sxXT0wLFdbMl09MCksV1szXT0xLFd9ZnVuY3Rpb24gbyhXKXtyZXR1cm4gV1swXT0wLFdbMV09MCxXWzJdPTAsV1szXT0xLFd9ZnVuY3Rpb24gZihXLFYsWCl7WD1YKi41O3ZhciBOPU1hdGguc2luKFgpO3JldHVybiBXWzBdPU4qVlswXSxXWzFdPU4qVlsxXSxXWzJdPU4qVlsyXSxXWzNdPU1hdGguY29zKFgpLFd9ZnVuY3Rpb24geChXLFYpe3ZhciBYPU1hdGguYWNvcyhWWzNdKSoyLE49TWF0aC5zaW4oWC8yKTtyZXR1cm4gTj5yLkVQU0lMT04/KFdbMF09VlswXS9OLFdbMV09VlsxXS9OLFdbMl09VlsyXS9OKTooV1swXT0xLFdbMV09MCxXWzJdPTApLFh9ZnVuY3Rpb24gZyhXLFYpe3ZhciBYPUooVyxWKTtyZXR1cm4gTWF0aC5hY29zKDIqWCpYLTEpfWZ1bmN0aW9uIHkoVyxWLFgpe3ZhciBOPVZbMF0sej1WWzFdLHA9VlsyXSxNPVZbM10sdz1YWzBdLFU9WFsxXSxLPVhbMl0sWT1YWzNdO3JldHVybiBXWzBdPU4qWStNKncreipLLXAqVSxXWzFdPXoqWStNKlUrcCp3LU4qSyxXWzJdPXAqWStNKksrTipVLXoqdyxXWzNdPU0qWS1OKncteipVLXAqSyxXfWZ1bmN0aW9uIG0oVyxWLFgpe1gqPS41O3ZhciBOPVZbMF0sej1WWzFdLHA9VlsyXSxNPVZbM10sdz1NYXRoLnNpbihYKSxVPU1hdGguY29zKFgpO3JldHVybiBXWzBdPU4qVStNKncsV1sxXT16KlUrcCp3LFdbMl09cCpVLXoqdyxXWzNdPU0qVS1OKncsV31mdW5jdGlvbiBUKFcsVixYKXtYKj0uNTt2YXIgTj1WWzBdLHo9VlsxXSxwPVZbMl0sTT1WWzNdLHc9TWF0aC5zaW4oWCksVT1NYXRoLmNvcyhYKTtyZXR1cm4gV1swXT1OKlUtcCp3LFdbMV09eipVK00qdyxXWzJdPXAqVStOKncsV1szXT1NKlUteip3LFd9ZnVuY3Rpb24gTyhXLFYsWCl7WCo9LjU7dmFyIE49VlswXSx6PVZbMV0scD1WWzJdLE09VlszXSx3PU1hdGguc2luKFgpLFU9TWF0aC5jb3MoWCk7cmV0dXJuIFdbMF09TipVK3oqdyxXWzFdPXoqVS1OKncsV1syXT1wKlUrTSp3LFdbM109TSpVLXAqdyxXfWZ1bmN0aW9uIHYoVyxWKXt2YXIgWD1WWzBdLE49VlsxXSx6PVZbMl07cmV0dXJuIFdbMF09WCxXWzFdPU4sV1syXT16LFdbM109TWF0aC5zcXJ0KE1hdGguYWJzKDEtWCpYLU4qTi16KnopKSxXfWZ1bmN0aW9uIFAoVyxWKXt2YXIgWD1WWzBdLE49VlsxXSx6PVZbMl0scD1WWzNdLE09TWF0aC5zcXJ0KFgqWCtOKk4reip6KSx3PU1hdGguZXhwKHApLFU9TT4wP3cqTWF0aC5zaW4oTSkvTTowO3JldHVybiBXWzBdPVgqVSxXWzFdPU4qVSxXWzJdPXoqVSxXWzNdPXcqTWF0aC5jb3MoTSksV31mdW5jdGlvbiBpKFcsVil7dmFyIFg9VlswXSxOPVZbMV0sej1WWzJdLHA9VlszXSxNPU1hdGguc3FydChYKlgrTipOK3oqeiksdz1NPjA/TWF0aC5hdGFuMihNLHApL006MDtyZXR1cm4gV1swXT1YKncsV1sxXT1OKncsV1syXT16KncsV1szXT0uNSpNYXRoLmxvZyhYKlgrTipOK3oqeitwKnApLFd9ZnVuY3Rpb24gdShXLFYsWCl7cmV0dXJuIGkoVyxWKSxIKFcsVyxYKSxQKFcsVyksV31mdW5jdGlvbiBhKFcsVixYLE4pe3ZhciB6PVZbMF0scD1WWzFdLE09VlsyXSx3PVZbM10sVT1YWzBdLEs9WFsxXSxZPVhbMl0sUT1YWzNdLHJ0LG50LGF0LGN0LG90O3JldHVybiBudD16KlUrcCpLK00qWSt3KlEsbnQ8MCYmKG50PS1udCxVPS1VLEs9LUssWT0tWSxRPS1RKSwxLW50PnIuRVBTSUxPTj8ocnQ9TWF0aC5hY29zKG50KSxhdD1NYXRoLnNpbihydCksY3Q9TWF0aC5zaW4oKDEtTikqcnQpL2F0LG90PU1hdGguc2luKE4qcnQpL2F0KTooY3Q9MS1OLG90PU4pLFdbMF09Y3QqeitvdCpVLFdbMV09Y3QqcCtvdCpLLFdbMl09Y3QqTStvdCpZLFdbM109Y3QqdytvdCpRLFd9ZnVuY3Rpb24gaChXKXt2YXIgVj1yLlJBTkRPTSgpLFg9ci5SQU5ET00oKSxOPXIuUkFORE9NKCksej1NYXRoLnNxcnQoMS1WKSxwPU1hdGguc3FydChWKTtyZXR1cm4gV1swXT16Kk1hdGguc2luKDIqTWF0aC5QSSpYKSxXWzFdPXoqTWF0aC5jb3MoMipNYXRoLlBJKlgpLFdbMl09cCpNYXRoLnNpbigyKk1hdGguUEkqTiksV1szXT1wKk1hdGguY29zKDIqTWF0aC5QSSpOKSxXfWZ1bmN0aW9uIGIoVyxWKXt2YXIgWD1WWzBdLE49VlsxXSx6PVZbMl0scD1WWzNdLE09WCpYK04qTit6KnorcCpwLHc9TT8xL006MDtyZXR1cm4gV1swXT0tWCp3LFdbMV09LU4qdyxXWzJdPS16KncsV1szXT1wKncsV31mdW5jdGlvbiBFKFcsVil7cmV0dXJuIFdbMF09LVZbMF0sV1sxXT0tVlsxXSxXWzJdPS1WWzJdLFdbM109VlszXSxXfWZ1bmN0aW9uIEEoVyxWKXt2YXIgWD1WWzBdK1ZbNF0rVls4XSxOO2lmKFg+MClOPU1hdGguc3FydChYKzEpLFdbM109LjUqTixOPS41L04sV1swXT0oVls1XS1WWzddKSpOLFdbMV09KFZbNl0tVlsyXSkqTixXWzJdPShWWzFdLVZbM10pKk47ZWxzZXt2YXIgej0wO1ZbNF0+VlswXSYmKHo9MSksVls4XT5WW3oqMyt6XSYmKHo9Mik7dmFyIHA9KHorMSklMyxNPSh6KzIpJTM7Tj1NYXRoLnNxcnQoVlt6KjMrel0tVltwKjMrcF0tVltNKjMrTV0rMSksV1t6XT0uNSpOLE49LjUvTixXWzNdPShWW3AqMytNXS1WW00qMytwXSkqTixXW3BdPShWW3AqMyt6XStWW3oqMytwXSkqTixXW01dPShWW00qMyt6XStWW3oqMytNXSkqTn1yZXR1cm4gV31mdW5jdGlvbiBMKFcsVixYLE4pe3ZhciB6PS41Kk1hdGguUEkvMTgwO1YqPXosWCo9eixOKj16O3ZhciBwPU1hdGguc2luKFYpLE09TWF0aC5jb3MoViksdz1NYXRoLnNpbihYKSxVPU1hdGguY29zKFgpLEs9TWF0aC5zaW4oTiksWT1NYXRoLmNvcyhOKTtyZXR1cm4gV1swXT1wKlUqWS1NKncqSyxXWzFdPU0qdypZK3AqVSpLLFdbMl09TSpVKkstcCp3KlksV1szXT1NKlUqWStwKncqSyxXfWZ1bmN0aW9uIFMoVyl7cmV0dXJuInF1YXQoIitXWzBdKyIsICIrV1sxXSsiLCAiK1dbMl0rIiwgIitXWzNdKyIpIn12YXIgST1sLmNsb25lLEQ9bC5mcm9tVmFsdWVzLFI9bC5jb3B5LEM9bC5zZXQsaj1sLmFkZCwkPXksSD1sLnNjYWxlLEo9bC5kb3QscT1sLmxlcnAsRj1sLmxlbmd0aCxHPUYsWj1sLnNxdWFyZWRMZW5ndGgsdHQ9WixldD1sLm5vcm1hbGl6ZSxpdD1sLmV4YWN0RXF1YWxzLGs9bC5lcXVhbHMsaHQ9ZnVuY3Rpb24oKXt2YXIgVz1zLmNyZWF0ZSgpLFY9cy5mcm9tVmFsdWVzKDEsMCwwKSxYPXMuZnJvbVZhbHVlcygwLDEsMCk7cmV0dXJuIGZ1bmN0aW9uKE4seixwKXt2YXIgTT1zLmRvdCh6LHApO3JldHVybiBNPC0uOTk5OTk5PyhzLmNyb3NzKFcsVix6KSxzLmxlbihXKTwxZS02JiZzLmNyb3NzKFcsWCx6KSxzLm5vcm1hbGl6ZShXLFcpLGYoTixXLE1hdGguUEkpLE4pOk0+Ljk5OTk5OT8oTlswXT0wLE5bMV09MCxOWzJdPTAsTlszXT0xLE4pOihzLmNyb3NzKFcseixwKSxOWzBdPVdbMF0sTlsxXT1XWzFdLE5bMl09V1syXSxOWzNdPTErTSxldChOLE4pKX19KCksZnQ9ZnVuY3Rpb24oKXt2YXIgVz1jKCksVj1jKCk7cmV0dXJuIGZ1bmN0aW9uKFgsTix6LHAsTSx3KXtyZXR1cm4gYShXLE4sTSx3KSxhKFYseixwLHcpLGEoWCxXLFYsMip3KigxLXcpKSxYfX0oKSxCPWZ1bmN0aW9uKCl7dmFyIFc9bi5jcmVhdGUoKTtyZXR1cm4gZnVuY3Rpb24oVixYLE4seil7cmV0dXJuIFdbMF09TlswXSxXWzNdPU5bMV0sV1s2XT1OWzJdLFdbMV09elswXSxXWzRdPXpbMV0sV1s3XT16WzJdLFdbMl09LVhbMF0sV1s1XT0tWFsxXSxXWzhdPS1YWzJdLGV0KFYsQShWLFcpKX19KCl9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiaGVybWl0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJiZXppZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBldH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGl0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiB6fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgTT1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKE1bMF09MCxNWzFdPTAsTVsyXT0wKSxNfWZ1bmN0aW9uIHMoTSl7dmFyIHc9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gd1swXT1NWzBdLHdbMV09TVsxXSx3WzJdPU1bMl0sd31mdW5jdGlvbiBsKE0pe3ZhciB3PU1bMF0sVT1NWzFdLEs9TVsyXTtyZXR1cm4gTWF0aC5oeXBvdCh3LFUsSyl9ZnVuY3Rpb24gYyhNLHcsVSl7dmFyIEs9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gS1swXT1NLEtbMV09dyxLWzJdPVUsS31mdW5jdGlvbiBvKE0sdyl7cmV0dXJuIE1bMF09d1swXSxNWzFdPXdbMV0sTVsyXT13WzJdLE19ZnVuY3Rpb24gZihNLHcsVSxLKXtyZXR1cm4gTVswXT13LE1bMV09VSxNWzJdPUssTX1mdW5jdGlvbiB4KE0sdyxVKXtyZXR1cm4gTVswXT13WzBdK1VbMF0sTVsxXT13WzFdK1VbMV0sTVsyXT13WzJdK1VbMl0sTX1mdW5jdGlvbiBnKE0sdyxVKXtyZXR1cm4gTVswXT13WzBdLVVbMF0sTVsxXT13WzFdLVVbMV0sTVsyXT13WzJdLVVbMl0sTX1mdW5jdGlvbiB5KE0sdyxVKXtyZXR1cm4gTVswXT13WzBdKlVbMF0sTVsxXT13WzFdKlVbMV0sTVsyXT13WzJdKlVbMl0sTX1mdW5jdGlvbiBtKE0sdyxVKXtyZXR1cm4gTVswXT13WzBdL1VbMF0sTVsxXT13WzFdL1VbMV0sTVsyXT13WzJdL1VbMl0sTX1mdW5jdGlvbiBUKE0sdyl7cmV0dXJuIE1bMF09TWF0aC5jZWlsKHdbMF0pLE1bMV09TWF0aC5jZWlsKHdbMV0pLE1bMl09TWF0aC5jZWlsKHdbMl0pLE19ZnVuY3Rpb24gTyhNLHcpe3JldHVybiBNWzBdPU1hdGguZmxvb3Iod1swXSksTVsxXT1NYXRoLmZsb29yKHdbMV0pLE1bMl09TWF0aC5mbG9vcih3WzJdKSxNfWZ1bmN0aW9uIHYoTSx3LFUpe3JldHVybiBNWzBdPU1hdGgubWluKHdbMF0sVVswXSksTVsxXT1NYXRoLm1pbih3WzFdLFVbMV0pLE1bMl09TWF0aC5taW4od1syXSxVWzJdKSxNfWZ1bmN0aW9uIFAoTSx3LFUpe3JldHVybiBNWzBdPU1hdGgubWF4KHdbMF0sVVswXSksTVsxXT1NYXRoLm1heCh3WzFdLFVbMV0pLE1bMl09TWF0aC5tYXgod1syXSxVWzJdKSxNfWZ1bmN0aW9uIGkoTSx3KXtyZXR1cm4gTVswXT1NYXRoLnJvdW5kKHdbMF0pLE1bMV09TWF0aC5yb3VuZCh3WzFdKSxNWzJdPU1hdGgucm91bmQod1syXSksTX1mdW5jdGlvbiB1KE0sdyxVKXtyZXR1cm4gTVswXT13WzBdKlUsTVsxXT13WzFdKlUsTVsyXT13WzJdKlUsTX1mdW5jdGlvbiBhKE0sdyxVLEspe3JldHVybiBNWzBdPXdbMF0rVVswXSpLLE1bMV09d1sxXStVWzFdKkssTVsyXT13WzJdK1VbMl0qSyxNfWZ1bmN0aW9uIGgoTSx3KXt2YXIgVT13WzBdLU1bMF0sSz13WzFdLU1bMV0sWT13WzJdLU1bMl07cmV0dXJuIE1hdGguaHlwb3QoVSxLLFkpfWZ1bmN0aW9uIGIoTSx3KXt2YXIgVT13WzBdLU1bMF0sSz13WzFdLU1bMV0sWT13WzJdLU1bMl07cmV0dXJuIFUqVStLKksrWSpZfWZ1bmN0aW9uIEUoTSl7dmFyIHc9TVswXSxVPU1bMV0sSz1NWzJdO3JldHVybiB3KncrVSpVK0sqS31mdW5jdGlvbiBBKE0sdyl7cmV0dXJuIE1bMF09LXdbMF0sTVsxXT0td1sxXSxNWzJdPS13WzJdLE19ZnVuY3Rpb24gTChNLHcpe3JldHVybiBNWzBdPTEvd1swXSxNWzFdPTEvd1sxXSxNWzJdPTEvd1syXSxNfWZ1bmN0aW9uIFMoTSx3KXt2YXIgVT13WzBdLEs9d1sxXSxZPXdbMl0sUT1VKlUrSypLK1kqWTtyZXR1cm4gUT4wJiYoUT0xL01hdGguc3FydChRKSksTVswXT13WzBdKlEsTVsxXT13WzFdKlEsTVsyXT13WzJdKlEsTX1mdW5jdGlvbiBJKE0sdyl7cmV0dXJuIE1bMF0qd1swXStNWzFdKndbMV0rTVsyXSp3WzJdfWZ1bmN0aW9uIEQoTSx3LFUpe3ZhciBLPXdbMF0sWT13WzFdLFE9d1syXSxydD1VWzBdLG50PVVbMV0sYXQ9VVsyXTtyZXR1cm4gTVswXT1ZKmF0LVEqbnQsTVsxXT1RKnJ0LUsqYXQsTVsyXT1LKm50LVkqcnQsTX1mdW5jdGlvbiBSKE0sdyxVLEspe3ZhciBZPXdbMF0sUT13WzFdLHJ0PXdbMl07cmV0dXJuIE1bMF09WStLKihVWzBdLVkpLE1bMV09UStLKihVWzFdLVEpLE1bMl09cnQrSyooVVsyXS1ydCksTX1mdW5jdGlvbiBDKE0sdyxVLEssWSxRKXt2YXIgcnQ9USpRLG50PXJ0KigyKlEtMykrMSxhdD1ydCooUS0yKStRLGN0PXJ0KihRLTEpLG90PXJ0KigzLTIqUSk7cmV0dXJuIE1bMF09d1swXSpudCtVWzBdKmF0K0tbMF0qY3QrWVswXSpvdCxNWzFdPXdbMV0qbnQrVVsxXSphdCtLWzFdKmN0K1lbMV0qb3QsTVsyXT13WzJdKm50K1VbMl0qYXQrS1syXSpjdCtZWzJdKm90LE19ZnVuY3Rpb24gaihNLHcsVSxLLFksUSl7dmFyIHJ0PTEtUSxudD1ydCpydCxhdD1RKlEsY3Q9bnQqcnQsb3Q9MypRKm50LHN0PTMqYXQqcnQsbHQ9YXQqUTtyZXR1cm4gTVswXT13WzBdKmN0K1VbMF0qb3QrS1swXSpzdCtZWzBdKmx0LE1bMV09d1sxXSpjdCtVWzFdKm90K0tbMV0qc3QrWVsxXSpsdCxNWzJdPXdbMl0qY3QrVVsyXSpvdCtLWzJdKnN0K1lbMl0qbHQsTX1mdW5jdGlvbiAkKE0sdyl7dz13fHwxO3ZhciBVPXIuUkFORE9NKCkqMipNYXRoLlBJLEs9ci5SQU5ET00oKSoyLTEsWT1NYXRoLnNxcnQoMS1LKkspKnc7cmV0dXJuIE1bMF09TWF0aC5jb3MoVSkqWSxNWzFdPU1hdGguc2luKFUpKlksTVsyXT1LKncsTX1mdW5jdGlvbiBIKE0sdyxVKXt2YXIgSz13WzBdLFk9d1sxXSxRPXdbMl0scnQ9VVszXSpLK1VbN10qWStVWzExXSpRK1VbMTVdO3JldHVybiBydD1ydHx8MSxNWzBdPShVWzBdKksrVVs0XSpZK1VbOF0qUStVWzEyXSkvcnQsTVsxXT0oVVsxXSpLK1VbNV0qWStVWzldKlErVVsxM10pL3J0LE1bMl09KFVbMl0qSytVWzZdKlkrVVsxMF0qUStVWzE0XSkvcnQsTX1mdW5jdGlvbiBKKE0sdyxVKXt2YXIgSz13WzBdLFk9d1sxXSxRPXdbMl07cmV0dXJuIE1bMF09SypVWzBdK1kqVVszXStRKlVbNl0sTVsxXT1LKlVbMV0rWSpVWzRdK1EqVVs3XSxNWzJdPUsqVVsyXStZKlVbNV0rUSpVWzhdLE19ZnVuY3Rpb24gcShNLHcsVSl7dmFyIEs9VVswXSxZPVVbMV0sUT1VWzJdLHJ0PVVbM10sbnQ9d1swXSxhdD13WzFdLGN0PXdbMl0sb3Q9WSpjdC1RKmF0LHN0PVEqbnQtSypjdCxsdD1LKmF0LVkqbnQsbXQ9WSpsdC1RKnN0LHB0PVEqb3QtSypsdCxkdD1LKnN0LVkqb3QseXQ9cnQqMjtyZXR1cm4gb3QqPXl0LHN0Kj15dCxsdCo9eXQsbXQqPTIscHQqPTIsZHQqPTIsTVswXT1udCtvdCttdCxNWzFdPWF0K3N0K3B0LE1bMl09Y3QrbHQrZHQsTX1mdW5jdGlvbiBGKE0sdyxVLEspe3ZhciBZPVtdLFE9W107cmV0dXJuIFlbMF09d1swXS1VWzBdLFlbMV09d1sxXS1VWzFdLFlbMl09d1syXS1VWzJdLFFbMF09WVswXSxRWzFdPVlbMV0qTWF0aC5jb3MoSyktWVsyXSpNYXRoLnNpbihLKSxRWzJdPVlbMV0qTWF0aC5zaW4oSykrWVsyXSpNYXRoLmNvcyhLKSxNWzBdPVFbMF0rVVswXSxNWzFdPVFbMV0rVVsxXSxNWzJdPVFbMl0rVVsyXSxNfWZ1bmN0aW9uIEcoTSx3LFUsSyl7dmFyIFk9W10sUT1bXTtyZXR1cm4gWVswXT13WzBdLVVbMF0sWVsxXT13WzFdLVVbMV0sWVsyXT13WzJdLVVbMl0sUVswXT1ZWzJdKk1hdGguc2luKEspK1lbMF0qTWF0aC5jb3MoSyksUVsxXT1ZWzFdLFFbMl09WVsyXSpNYXRoLmNvcyhLKS1ZWzBdKk1hdGguc2luKEspLE1bMF09UVswXStVWzBdLE1bMV09UVsxXStVWzFdLE1bMl09UVsyXStVWzJdLE19ZnVuY3Rpb24gWihNLHcsVSxLKXt2YXIgWT1bXSxRPVtdO3JldHVybiBZWzBdPXdbMF0tVVswXSxZWzFdPXdbMV0tVVsxXSxZWzJdPXdbMl0tVVsyXSxRWzBdPVlbMF0qTWF0aC5jb3MoSyktWVsxXSpNYXRoLnNpbihLKSxRWzFdPVlbMF0qTWF0aC5zaW4oSykrWVsxXSpNYXRoLmNvcyhLKSxRWzJdPVlbMl0sTVswXT1RWzBdK1VbMF0sTVsxXT1RWzFdK1VbMV0sTVsyXT1RWzJdK1VbMl0sTX1mdW5jdGlvbiB0dChNLHcpe3ZhciBVPU1bMF0sSz1NWzFdLFk9TVsyXSxRPXdbMF0scnQ9d1sxXSxudD13WzJdLGF0PU1hdGguc3FydChVKlUrSypLK1kqWSksY3Q9TWF0aC5zcXJ0KFEqUStydCpydCtudCpudCksb3Q9YXQqY3Qsc3Q9b3QmJkkoTSx3KS9vdDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KHN0LC0xKSwxKSl9ZnVuY3Rpb24gZXQoTSl7cmV0dXJuIE1bMF09MCxNWzFdPTAsTVsyXT0wLE19ZnVuY3Rpb24gaXQoTSl7cmV0dXJuInZlYzMoIitNWzBdKyIsICIrTVsxXSsiLCAiK01bMl0rIikifWZ1bmN0aW9uIGsoTSx3KXtyZXR1cm4gTVswXT09PXdbMF0mJk1bMV09PT13WzFdJiZNWzJdPT09d1syXX1mdW5jdGlvbiBodChNLHcpe3ZhciBVPU1bMF0sSz1NWzFdLFk9TVsyXSxRPXdbMF0scnQ9d1sxXSxudD13WzJdO3JldHVybiBNYXRoLmFicyhVLVEpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhVKSxNYXRoLmFicyhRKSkmJk1hdGguYWJzKEstcnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhZLW50KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWSksTWF0aC5hYnMobnQpKX12YXIgZnQ9ZyxCPXksVz1tLFY9aCxYPWIsTj1sLHo9RSxwPWZ1bmN0aW9uKCl7dmFyIE09bigpO3JldHVybiBmdW5jdGlvbih3LFUsSyxZLFEscnQpe3ZhciBudCxhdDtmb3IoVXx8KFU9MyksS3x8KEs9MCksWT9hdD1NYXRoLm1pbihZKlUrSyx3Lmxlbmd0aCk6YXQ9dy5sZW5ndGgsbnQ9SztudDxhdDtudCs9VSlNWzBdPXdbbnRdLE1bMV09d1tudCsxXSxNWzJdPXdbbnQrMl0sUShNLE0scnQpLHdbbnRdPU1bMF0sd1tudCsxXT1NWzFdLHdbbnQrMl09TVsyXTtyZXR1cm4gd319KCl9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJkaXZpZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY2VpbCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJmbG9vciIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJtaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwibWF4IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInJvdW5kIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNxdWFyZWREaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwidHJhbnNmb3JtUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGl0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBuKCl7dmFyIEI9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTApLEJ9ZnVuY3Rpb24gcyhCKXt2YXIgVz1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBXWzBdPUJbMF0sV1sxXT1CWzFdLFdbMl09QlsyXSxXWzNdPUJbM10sV31mdW5jdGlvbiBsKEIsVyxWLFgpe3ZhciBOPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIE5bMF09QixOWzFdPVcsTlsyXT1WLE5bM109WCxOfWZ1bmN0aW9uIGMoQixXKXtyZXR1cm4gQlswXT1XWzBdLEJbMV09V1sxXSxCWzJdPVdbMl0sQlszXT1XWzNdLEJ9ZnVuY3Rpb24gbyhCLFcsVixYLE4pe3JldHVybiBCWzBdPVcsQlsxXT1WLEJbMl09WCxCWzNdPU4sQn1mdW5jdGlvbiBmKEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdK1ZbMF0sQlsxXT1XWzFdK1ZbMV0sQlsyXT1XWzJdK1ZbMl0sQlszXT1XWzNdK1ZbM10sQn1mdW5jdGlvbiB4KEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdLVZbMF0sQlsxXT1XWzFdLVZbMV0sQlsyXT1XWzJdLVZbMl0sQlszXT1XWzNdLVZbM10sQn1mdW5jdGlvbiBnKEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdKlZbMF0sQlsxXT1XWzFdKlZbMV0sQlsyXT1XWzJdKlZbMl0sQlszXT1XWzNdKlZbM10sQn1mdW5jdGlvbiB5KEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdL1ZbMF0sQlsxXT1XWzFdL1ZbMV0sQlsyXT1XWzJdL1ZbMl0sQlszXT1XWzNdL1ZbM10sQn1mdW5jdGlvbiBtKEIsVyl7cmV0dXJuIEJbMF09TWF0aC5jZWlsKFdbMF0pLEJbMV09TWF0aC5jZWlsKFdbMV0pLEJbMl09TWF0aC5jZWlsKFdbMl0pLEJbM109TWF0aC5jZWlsKFdbM10pLEJ9ZnVuY3Rpb24gVChCLFcpe3JldHVybiBCWzBdPU1hdGguZmxvb3IoV1swXSksQlsxXT1NYXRoLmZsb29yKFdbMV0pLEJbMl09TWF0aC5mbG9vcihXWzJdKSxCWzNdPU1hdGguZmxvb3IoV1szXSksQn1mdW5jdGlvbiBPKEIsVyxWKXtyZXR1cm4gQlswXT1NYXRoLm1pbihXWzBdLFZbMF0pLEJbMV09TWF0aC5taW4oV1sxXSxWWzFdKSxCWzJdPU1hdGgubWluKFdbMl0sVlsyXSksQlszXT1NYXRoLm1pbihXWzNdLFZbM10pLEJ9ZnVuY3Rpb24gdihCLFcsVil7cmV0dXJuIEJbMF09TWF0aC5tYXgoV1swXSxWWzBdKSxCWzFdPU1hdGgubWF4KFdbMV0sVlsxXSksQlsyXT1NYXRoLm1heChXWzJdLFZbMl0pLEJbM109TWF0aC5tYXgoV1szXSxWWzNdKSxCfWZ1bmN0aW9uIFAoQixXKXtyZXR1cm4gQlswXT1NYXRoLnJvdW5kKFdbMF0pLEJbMV09TWF0aC5yb3VuZChXWzFdKSxCWzJdPU1hdGgucm91bmQoV1syXSksQlszXT1NYXRoLnJvdW5kKFdbM10pLEJ9ZnVuY3Rpb24gaShCLFcsVil7cmV0dXJuIEJbMF09V1swXSpWLEJbMV09V1sxXSpWLEJbMl09V1syXSpWLEJbM109V1szXSpWLEJ9ZnVuY3Rpb24gdShCLFcsVixYKXtyZXR1cm4gQlswXT1XWzBdK1ZbMF0qWCxCWzFdPVdbMV0rVlsxXSpYLEJbMl09V1syXStWWzJdKlgsQlszXT1XWzNdK1ZbM10qWCxCfWZ1bmN0aW9uIGEoQixXKXt2YXIgVj1XWzBdLUJbMF0sWD1XWzFdLUJbMV0sTj1XWzJdLUJbMl0sej1XWzNdLUJbM107cmV0dXJuIE1hdGguaHlwb3QoVixYLE4seil9ZnVuY3Rpb24gaChCLFcpe3ZhciBWPVdbMF0tQlswXSxYPVdbMV0tQlsxXSxOPVdbMl0tQlsyXSx6PVdbM10tQlszXTtyZXR1cm4gVipWK1gqWCtOKk4reip6fWZ1bmN0aW9uIGIoQil7dmFyIFc9QlswXSxWPUJbMV0sWD1CWzJdLE49QlszXTtyZXR1cm4gTWF0aC5oeXBvdChXLFYsWCxOKX1mdW5jdGlvbiBFKEIpe3ZhciBXPUJbMF0sVj1CWzFdLFg9QlsyXSxOPUJbM107cmV0dXJuIFcqVytWKlYrWCpYK04qTn1mdW5jdGlvbiBBKEIsVyl7cmV0dXJuIEJbMF09LVdbMF0sQlsxXT0tV1sxXSxCWzJdPS1XWzJdLEJbM109LVdbM10sQn1mdW5jdGlvbiBMKEIsVyl7cmV0dXJuIEJbMF09MS9XWzBdLEJbMV09MS9XWzFdLEJbMl09MS9XWzJdLEJbM109MS9XWzNdLEJ9ZnVuY3Rpb24gUyhCLFcpe3ZhciBWPVdbMF0sWD1XWzFdLE49V1syXSx6PVdbM10scD1WKlYrWCpYK04qTit6Kno7cmV0dXJuIHA+MCYmKHA9MS9NYXRoLnNxcnQocCkpLEJbMF09VipwLEJbMV09WCpwLEJbMl09TipwLEJbM109eipwLEJ9ZnVuY3Rpb24gSShCLFcpe3JldHVybiBCWzBdKldbMF0rQlsxXSpXWzFdK0JbMl0qV1syXStCWzNdKldbM119ZnVuY3Rpb24gRChCLFcsVixYKXt2YXIgTj1WWzBdKlhbMV0tVlsxXSpYWzBdLHo9VlswXSpYWzJdLVZbMl0qWFswXSxwPVZbMF0qWFszXS1WWzNdKlhbMF0sTT1WWzFdKlhbMl0tVlsyXSpYWzFdLHc9VlsxXSpYWzNdLVZbM10qWFsxXSxVPVZbMl0qWFszXS1WWzNdKlhbMl0sSz1XWzBdLFk9V1sxXSxRPVdbMl0scnQ9V1szXTtyZXR1cm4gQlswXT1ZKlUtUSp3K3J0Kk0sQlsxXT0tKEsqVSkrUSpwLXJ0KnosQlsyXT1LKnctWSpwK3J0Kk4sQlszXT0tKEsqTSkrWSp6LVEqTixCfWZ1bmN0aW9uIFIoQixXLFYsWCl7dmFyIE49V1swXSx6PVdbMV0scD1XWzJdLE09V1szXTtyZXR1cm4gQlswXT1OK1gqKFZbMF0tTiksQlsxXT16K1gqKFZbMV0teiksQlsyXT1wK1gqKFZbMl0tcCksQlszXT1NK1gqKFZbM10tTSksQn1mdW5jdGlvbiBDKEIsVyl7Vz1XfHwxO3ZhciBWLFgsTix6LHAsTTtkbyBWPXIuUkFORE9NKCkqMi0xLFg9ci5SQU5ET00oKSoyLTEscD1WKlYrWCpYO3doaWxlKHA+PTEpO2RvIE49ci5SQU5ET00oKSoyLTEsej1yLlJBTkRPTSgpKjItMSxNPU4qTit6Kno7d2hpbGUoTT49MSk7dmFyIHc9TWF0aC5zcXJ0KCgxLXApL00pO3JldHVybiBCWzBdPVcqVixCWzFdPVcqWCxCWzJdPVcqTip3LEJbM109Vyp6KncsQn1mdW5jdGlvbiBqKEIsVyxWKXt2YXIgWD1XWzBdLE49V1sxXSx6PVdbMl0scD1XWzNdO3JldHVybiBCWzBdPVZbMF0qWCtWWzRdKk4rVls4XSp6K1ZbMTJdKnAsQlsxXT1WWzFdKlgrVls1XSpOK1ZbOV0qeitWWzEzXSpwLEJbMl09VlsyXSpYK1ZbNl0qTitWWzEwXSp6K1ZbMTRdKnAsQlszXT1WWzNdKlgrVls3XSpOK1ZbMTFdKnorVlsxNV0qcCxCfWZ1bmN0aW9uICQoQixXLFYpe3ZhciBYPVdbMF0sTj1XWzFdLHo9V1syXSxwPVZbMF0sTT1WWzFdLHc9VlsyXSxVPVZbM10sSz1VKlgrTSp6LXcqTixZPVUqTit3KlgtcCp6LFE9VSp6K3AqTi1NKlgscnQ9LXAqWC1NKk4tdyp6O3JldHVybiBCWzBdPUsqVStydCotcCtZKi13LVEqLU0sQlsxXT1ZKlUrcnQqLU0rUSotcC1LKi13LEJbMl09USpVK3J0Ki13K0sqLU0tWSotcCxCWzNdPVdbM10sQn1mdW5jdGlvbiBIKEIpe3JldHVybiBCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTAsQn1mdW5jdGlvbiBKKEIpe3JldHVybiJ2ZWM0KCIrQlswXSsiLCAiK0JbMV0rIiwgIitCWzJdKyIsICIrQlszXSsiKSJ9ZnVuY3Rpb24gcShCLFcpe3JldHVybiBCWzBdPT09V1swXSYmQlsxXT09PVdbMV0mJkJbMl09PT1XWzJdJiZCWzNdPT09V1szXX1mdW5jdGlvbiBGKEIsVyl7dmFyIFY9QlswXSxYPUJbMV0sTj1CWzJdLHo9QlszXSxwPVdbMF0sTT1XWzFdLHc9V1syXSxVPVdbM107cmV0dXJuIE1hdGguYWJzKFYtcCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKHApKSYmTWF0aC5hYnMoWC1NKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMoTSkpJiZNYXRoLmFicyhOLXcpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhOKSxNYXRoLmFicyh3KSkmJk1hdGguYWJzKHotVSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKFUpKX12YXIgRz14LFo9Zyx0dD15LGV0PWEsaXQ9aCxrPWIsaHQ9RSxmdD1mdW5jdGlvbigpe3ZhciBCPW4oKTtyZXR1cm4gZnVuY3Rpb24oVyxWLFgsTix6LHApe3ZhciBNLHc7Zm9yKFZ8fChWPTQpLFh8fChYPTApLE4/dz1NYXRoLm1pbihOKlYrWCxXLmxlbmd0aCk6dz1XLmxlbmd0aCxNPVg7TTx3O00rPVYpQlswXT1XW01dLEJbMV09V1tNKzFdLEJbMl09V1tNKzJdLEJbM109V1tNKzNdLHooQixCLHApLFdbTV09QlswXSxXW00rMV09QlsxXSxXW00rMl09QlsyXSxXW00rM109QlszXTtyZXR1cm4gV319KCl9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZ2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJnZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInNldFJlYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0RHVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwicm90YXRlQnlRdWF0QXBwZW5kIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInJvdGF0ZUJ5UXVhdFByZXBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwicm90YXRlQXJvdW5kQXhpcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaXR9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSk7dmFyIHI9dCgyKSxuPXQoNykscz10KDYpO2Z1bmN0aW9uIGwoKXt2YXIgQj1uZXcgci5BUlJBWV9UWVBFKDgpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKEJbMF09MCxCWzFdPTAsQlsyXT0wLEJbNF09MCxCWzVdPTAsQls2XT0wLEJbN109MCksQlszXT0xLEJ9ZnVuY3Rpb24gYyhCKXt2YXIgVz1uZXcgci5BUlJBWV9UWVBFKDgpO3JldHVybiBXWzBdPUJbMF0sV1sxXT1CWzFdLFdbMl09QlsyXSxXWzNdPUJbM10sV1s0XT1CWzRdLFdbNV09Qls1XSxXWzZdPUJbNl0sV1s3XT1CWzddLFd9ZnVuY3Rpb24gbyhCLFcsVixYLE4seixwLE0pe3ZhciB3PW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIHdbMF09Qix3WzFdPVcsd1syXT1WLHdbM109WCx3WzRdPU4sd1s1XT16LHdbNl09cCx3WzddPU0sd31mdW5jdGlvbiBmKEIsVyxWLFgsTix6LHApe3ZhciBNPW5ldyByLkFSUkFZX1RZUEUoOCk7TVswXT1CLE1bMV09VyxNWzJdPVYsTVszXT1YO3ZhciB3PU4qLjUsVT16Ki41LEs9cCouNTtyZXR1cm4gTVs0XT13KlgrVSpWLUsqVyxNWzVdPVUqWCtLKkItdypWLE1bNl09SypYK3cqVy1VKkIsTVs3XT0tdypCLVUqVy1LKlYsTX1mdW5jdGlvbiB4KEIsVyxWKXt2YXIgWD1WWzBdKi41LE49VlsxXSouNSx6PVZbMl0qLjUscD1XWzBdLE09V1sxXSx3PVdbMl0sVT1XWzNdO3JldHVybiBCWzBdPXAsQlsxXT1NLEJbMl09dyxCWzNdPVUsQls0XT1YKlUrTip3LXoqTSxCWzVdPU4qVSt6KnAtWCp3LEJbNl09eipVK1gqTS1OKnAsQls3XT0tWCpwLU4qTS16KncsQn1mdW5jdGlvbiBnKEIsVyl7cmV0dXJuIEJbMF09MCxCWzFdPTAsQlsyXT0wLEJbM109MSxCWzRdPVdbMF0qLjUsQls1XT1XWzFdKi41LEJbNl09V1syXSouNSxCWzddPTAsQn1mdW5jdGlvbiB5KEIsVyl7cmV0dXJuIEJbMF09V1swXSxCWzFdPVdbMV0sQlsyXT1XWzJdLEJbM109V1szXSxCWzRdPTAsQls1XT0wLEJbNl09MCxCWzddPTAsQn1mdW5jdGlvbiBtKEIsVyl7dmFyIFY9bi5jcmVhdGUoKTtzLmdldFJvdGF0aW9uKFYsVyk7dmFyIFg9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gcy5nZXRUcmFuc2xhdGlvbihYLFcpLHgoQixWLFgpLEJ9ZnVuY3Rpb24gVChCLFcpe3JldHVybiBCWzBdPVdbMF0sQlsxXT1XWzFdLEJbMl09V1syXSxCWzNdPVdbM10sQls0XT1XWzRdLEJbNV09V1s1XSxCWzZdPVdbNl0sQls3XT1XWzddLEJ9ZnVuY3Rpb24gTyhCKXtyZXR1cm4gQlswXT0wLEJbMV09MCxCWzJdPTAsQlszXT0xLEJbNF09MCxCWzVdPTAsQls2XT0wLEJbN109MCxCfWZ1bmN0aW9uIHYoQixXLFYsWCxOLHoscCxNLHcpe3JldHVybiBCWzBdPVcsQlsxXT1WLEJbMl09WCxCWzNdPU4sQls0XT16LEJbNV09cCxCWzZdPU0sQls3XT13LEJ9dmFyIFA9bi5jb3B5O2Z1bmN0aW9uIGkoQixXKXtyZXR1cm4gQlswXT1XWzRdLEJbMV09V1s1XSxCWzJdPVdbNl0sQlszXT1XWzddLEJ9dmFyIHU9bi5jb3B5O2Z1bmN0aW9uIGEoQixXKXtyZXR1cm4gQls0XT1XWzBdLEJbNV09V1sxXSxCWzZdPVdbMl0sQls3XT1XWzNdLEJ9ZnVuY3Rpb24gaChCLFcpe3ZhciBWPVdbNF0sWD1XWzVdLE49V1s2XSx6PVdbN10scD0tV1swXSxNPS1XWzFdLHc9LVdbMl0sVT1XWzNdO3JldHVybiBCWzBdPShWKlUreipwK1gqdy1OKk0pKjIsQlsxXT0oWCpVK3oqTStOKnAtVip3KSoyLEJbMl09KE4qVSt6KncrVipNLVgqcCkqMixCfWZ1bmN0aW9uIGIoQixXLFYpe3ZhciBYPVdbMF0sTj1XWzFdLHo9V1syXSxwPVdbM10sTT1WWzBdKi41LHc9VlsxXSouNSxVPVZbMl0qLjUsSz1XWzRdLFk9V1s1XSxRPVdbNl0scnQ9V1s3XTtyZXR1cm4gQlswXT1YLEJbMV09TixCWzJdPXosQlszXT1wLEJbNF09cCpNK04qVS16KncrSyxCWzVdPXAqdyt6Kk0tWCpVK1ksQls2XT1wKlUrWCp3LU4qTStRLEJbN109LVgqTS1OKncteipVK3J0LEJ9ZnVuY3Rpb24gRShCLFcsVil7dmFyIFg9LVdbMF0sTj0tV1sxXSx6PS1XWzJdLHA9V1szXSxNPVdbNF0sdz1XWzVdLFU9V1s2XSxLPVdbN10sWT1NKnArSypYK3cqei1VKk4sUT13KnArSypOK1UqWC1NKnoscnQ9VSpwK0sqeitNKk4tdypYLG50PUsqcC1NKlgtdypOLVUqejtyZXR1cm4gbi5yb3RhdGVYKEIsVyxWKSxYPUJbMF0sTj1CWzFdLHo9QlsyXSxwPUJbM10sQls0XT1ZKnArbnQqWCtRKnotcnQqTixCWzVdPVEqcCtudCpOK3J0KlgtWSp6LEJbNl09cnQqcCtudCp6K1kqTi1RKlgsQls3XT1udCpwLVkqWC1RKk4tcnQqeixCfWZ1bmN0aW9uIEEoQixXLFYpe3ZhciBYPS1XWzBdLE49LVdbMV0sej0tV1syXSxwPVdbM10sTT1XWzRdLHc9V1s1XSxVPVdbNl0sSz1XWzddLFk9TSpwK0sqWCt3KnotVSpOLFE9dypwK0sqTitVKlgtTSp6LHJ0PVUqcCtLKnorTSpOLXcqWCxudD1LKnAtTSpYLXcqTi1VKno7cmV0dXJuIG4ucm90YXRlWShCLFcsViksWD1CWzBdLE49QlsxXSx6PUJbMl0scD1CWzNdLEJbNF09WSpwK250KlgrUSp6LXJ0Kk4sQls1XT1RKnArbnQqTitydCpYLVkqeixCWzZdPXJ0KnArbnQqeitZKk4tUSpYLEJbN109bnQqcC1ZKlgtUSpOLXJ0KnosQn1mdW5jdGlvbiBMKEIsVyxWKXt2YXIgWD0tV1swXSxOPS1XWzFdLHo9LVdbMl0scD1XWzNdLE09V1s0XSx3PVdbNV0sVT1XWzZdLEs9V1s3XSxZPU0qcCtLKlgrdyp6LVUqTixRPXcqcCtLKk4rVSpYLU0qeixydD1VKnArSyp6K00qTi13KlgsbnQ9SypwLU0qWC13Kk4tVSp6O3JldHVybiBuLnJvdGF0ZVooQixXLFYpLFg9QlswXSxOPUJbMV0sej1CWzJdLHA9QlszXSxCWzRdPVkqcCtudCpYK1Eqei1ydCpOLEJbNV09USpwK250Kk4rcnQqWC1ZKnosQls2XT1ydCpwK250KnorWSpOLVEqWCxCWzddPW50KnAtWSpYLVEqTi1ydCp6LEJ9ZnVuY3Rpb24gUyhCLFcsVil7dmFyIFg9VlswXSxOPVZbMV0sej1WWzJdLHA9VlszXSxNPVdbMF0sdz1XWzFdLFU9V1syXSxLPVdbM107cmV0dXJuIEJbMF09TSpwK0sqWCt3KnotVSpOLEJbMV09dypwK0sqTitVKlgtTSp6LEJbMl09VSpwK0sqeitNKk4tdypYLEJbM109SypwLU0qWC13Kk4tVSp6LE09V1s0XSx3PVdbNV0sVT1XWzZdLEs9V1s3XSxCWzRdPU0qcCtLKlgrdyp6LVUqTixCWzVdPXcqcCtLKk4rVSpYLU0qeixCWzZdPVUqcCtLKnorTSpOLXcqWCxCWzddPUsqcC1NKlgtdypOLVUqeixCfWZ1bmN0aW9uIEkoQixXLFYpe3ZhciBYPVdbMF0sTj1XWzFdLHo9V1syXSxwPVdbM10sTT1WWzBdLHc9VlsxXSxVPVZbMl0sSz1WWzNdO3JldHVybiBCWzBdPVgqSytwKk0rTipVLXoqdyxCWzFdPU4qSytwKncreipNLVgqVSxCWzJdPXoqSytwKlUrWCp3LU4qTSxCWzNdPXAqSy1YKk0tTip3LXoqVSxNPVZbNF0sdz1WWzVdLFU9Vls2XSxLPVZbN10sQls0XT1YKksrcCpNK04qVS16KncsQls1XT1OKksrcCp3K3oqTS1YKlUsQls2XT16KksrcCpVK1gqdy1OKk0sQls3XT1wKkstWCpNLU4qdy16KlUsQn1mdW5jdGlvbiBEKEIsVyxWLFgpe2lmKE1hdGguYWJzKFgpPHIuRVBTSUxPTilyZXR1cm4gVChCLFcpO3ZhciBOPU1hdGguaHlwb3QoVlswXSxWWzFdLFZbMl0pO1g9WCouNTt2YXIgej1NYXRoLnNpbihYKSxwPXoqVlswXS9OLE09eipWWzFdL04sdz16KlZbMl0vTixVPU1hdGguY29zKFgpLEs9V1swXSxZPVdbMV0sUT1XWzJdLHJ0PVdbM107QlswXT1LKlUrcnQqcCtZKnctUSpNLEJbMV09WSpVK3J0Kk0rUSpwLUsqdyxCWzJdPVEqVStydCp3K0sqTS1ZKnAsQlszXT1ydCpVLUsqcC1ZKk0tUSp3O3ZhciBudD1XWzRdLGF0PVdbNV0sY3Q9V1s2XSxvdD1XWzddO3JldHVybiBCWzRdPW50KlUrb3QqcCthdCp3LWN0Kk0sQls1XT1hdCpVK290Kk0rY3QqcC1udCp3LEJbNl09Y3QqVStvdCp3K250Kk0tYXQqcCxCWzddPW90KlUtbnQqcC1hdCpNLWN0KncsQn1mdW5jdGlvbiBSKEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdK1ZbMF0sQlsxXT1XWzFdK1ZbMV0sQlsyXT1XWzJdK1ZbMl0sQlszXT1XWzNdK1ZbM10sQls0XT1XWzRdK1ZbNF0sQls1XT1XWzVdK1ZbNV0sQls2XT1XWzZdK1ZbNl0sQls3XT1XWzddK1ZbN10sQn1mdW5jdGlvbiBDKEIsVyxWKXt2YXIgWD1XWzBdLE49V1sxXSx6PVdbMl0scD1XWzNdLE09Vls0XSx3PVZbNV0sVT1WWzZdLEs9Vls3XSxZPVdbNF0sUT1XWzVdLHJ0PVdbNl0sbnQ9V1s3XSxhdD1WWzBdLGN0PVZbMV0sb3Q9VlsyXSxzdD1WWzNdO3JldHVybiBCWzBdPVgqc3QrcCphdCtOKm90LXoqY3QsQlsxXT1OKnN0K3AqY3QreiphdC1YKm90LEJbMl09eipzdCtwKm90K1gqY3QtTiphdCxCWzNdPXAqc3QtWCphdC1OKmN0LXoqb3QsQls0XT1YKksrcCpNK04qVS16KncrWSpzdCtudCphdCtRKm90LXJ0KmN0LEJbNV09TipLK3Aqdyt6Kk0tWCpVK1Eqc3QrbnQqY3QrcnQqYXQtWSpvdCxCWzZdPXoqSytwKlUrWCp3LU4qTStydCpzdCtudCpvdCtZKmN0LVEqYXQsQls3XT1wKkstWCpNLU4qdy16KlUrbnQqc3QtWSphdC1RKmN0LXJ0Km90LEJ9dmFyIGo9QztmdW5jdGlvbiAkKEIsVyxWKXtyZXR1cm4gQlswXT1XWzBdKlYsQlsxXT1XWzFdKlYsQlsyXT1XWzJdKlYsQlszXT1XWzNdKlYsQls0XT1XWzRdKlYsQls1XT1XWzVdKlYsQls2XT1XWzZdKlYsQls3XT1XWzddKlYsQn12YXIgSD1uLmRvdDtmdW5jdGlvbiBKKEIsVyxWLFgpe3ZhciBOPTEtWDtyZXR1cm4gSChXLFYpPDAmJihYPS1YKSxCWzBdPVdbMF0qTitWWzBdKlgsQlsxXT1XWzFdKk4rVlsxXSpYLEJbMl09V1syXSpOK1ZbMl0qWCxCWzNdPVdbM10qTitWWzNdKlgsQls0XT1XWzRdKk4rVls0XSpYLEJbNV09V1s1XSpOK1ZbNV0qWCxCWzZdPVdbNl0qTitWWzZdKlgsQls3XT1XWzddKk4rVls3XSpYLEJ9ZnVuY3Rpb24gcShCLFcpe3ZhciBWPXR0KFcpO3JldHVybiBCWzBdPS1XWzBdL1YsQlsxXT0tV1sxXS9WLEJbMl09LVdbMl0vVixCWzNdPVdbM10vVixCWzRdPS1XWzRdL1YsQls1XT0tV1s1XS9WLEJbNl09LVdbNl0vVixCWzddPVdbN10vVixCfWZ1bmN0aW9uIEYoQixXKXtyZXR1cm4gQlswXT0tV1swXSxCWzFdPS1XWzFdLEJbMl09LVdbMl0sQlszXT1XWzNdLEJbNF09LVdbNF0sQls1XT0tV1s1XSxCWzZdPS1XWzZdLEJbN109V1s3XSxCfXZhciBHPW4ubGVuZ3RoLFo9Ryx0dD1uLnNxdWFyZWRMZW5ndGgsZXQ9dHQ7ZnVuY3Rpb24gaXQoQixXKXt2YXIgVj10dChXKTtpZihWPjApe1Y9TWF0aC5zcXJ0KFYpO3ZhciBYPVdbMF0vVixOPVdbMV0vVix6PVdbMl0vVixwPVdbM10vVixNPVdbNF0sdz1XWzVdLFU9V1s2XSxLPVdbN10sWT1YKk0rTip3K3oqVStwKks7QlswXT1YLEJbMV09TixCWzJdPXosQlszXT1wLEJbNF09KE0tWCpZKS9WLEJbNV09KHctTipZKS9WLEJbNl09KFUteipZKS9WLEJbN109KEstcCpZKS9WfXJldHVybiBCfWZ1bmN0aW9uIGsoQil7cmV0dXJuInF1YXQyKCIrQlswXSsiLCAiK0JbMV0rIiwgIitCWzJdKyIsICIrQlszXSsiLCAiK0JbNF0rIiwgIitCWzVdKyIsICIrQls2XSsiLCAiK0JbN10rIikifWZ1bmN0aW9uIGh0KEIsVyl7cmV0dXJuIEJbMF09PT1XWzBdJiZCWzFdPT09V1sxXSYmQlsyXT09PVdbMl0mJkJbM109PT1XWzNdJiZCWzRdPT09V1s0XSYmQls1XT09PVdbNV0mJkJbNl09PT1XWzZdJiZCWzddPT09V1s3XX1mdW5jdGlvbiBmdChCLFcpe3ZhciBWPUJbMF0sWD1CWzFdLE49QlsyXSx6PUJbM10scD1CWzRdLE09Qls1XSx3PUJbNl0sVT1CWzddLEs9V1swXSxZPVdbMV0sUT1XWzJdLHJ0PVdbM10sbnQ9V1s0XSxhdD1XWzVdLGN0PVdbNl0sb3Q9V1s3XTtyZXR1cm4gTWF0aC5hYnMoVi1LKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoViksTWF0aC5hYnMoSykpJiZNYXRoLmFicyhYLVkpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhYKSxNYXRoLmFicyhZKSkmJk1hdGguYWJzKE4tUSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKFEpKSYmTWF0aC5hYnMoei1ydCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKHJ0KSkmJk1hdGguYWJzKHAtbnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhwKSxNYXRoLmFicyhudCkpJiZNYXRoLmFicyhNLWF0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTSksTWF0aC5hYnMoYXQpKSYmTWF0aC5hYnMody1jdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHcpLE1hdGguYWJzKGN0KSkmJk1hdGguYWJzKFUtb3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhVKSxNYXRoLmFicyhvdCkpfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwidHJhbnNmb3JtTWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQzIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gaXR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKE5bMF09MCxOWzFdPTApLE59ZnVuY3Rpb24gcyhOKXt2YXIgej1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiB6WzBdPU5bMF0selsxXT1OWzFdLHp9ZnVuY3Rpb24gbChOLHope3ZhciBwPW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIHBbMF09TixwWzFdPXoscH1mdW5jdGlvbiBjKE4seil7cmV0dXJuIE5bMF09elswXSxOWzFdPXpbMV0sTn1mdW5jdGlvbiBvKE4seixwKXtyZXR1cm4gTlswXT16LE5bMV09cCxOfWZ1bmN0aW9uIGYoTix6LHApe3JldHVybiBOWzBdPXpbMF0rcFswXSxOWzFdPXpbMV0rcFsxXSxOfWZ1bmN0aW9uIHgoTix6LHApe3JldHVybiBOWzBdPXpbMF0tcFswXSxOWzFdPXpbMV0tcFsxXSxOfWZ1bmN0aW9uIGcoTix6LHApe3JldHVybiBOWzBdPXpbMF0qcFswXSxOWzFdPXpbMV0qcFsxXSxOfWZ1bmN0aW9uIHkoTix6LHApe3JldHVybiBOWzBdPXpbMF0vcFswXSxOWzFdPXpbMV0vcFsxXSxOfWZ1bmN0aW9uIG0oTix6KXtyZXR1cm4gTlswXT1NYXRoLmNlaWwoelswXSksTlsxXT1NYXRoLmNlaWwoelsxXSksTn1mdW5jdGlvbiBUKE4seil7cmV0dXJuIE5bMF09TWF0aC5mbG9vcih6WzBdKSxOWzFdPU1hdGguZmxvb3IoelsxXSksTn1mdW5jdGlvbiBPKE4seixwKXtyZXR1cm4gTlswXT1NYXRoLm1pbih6WzBdLHBbMF0pLE5bMV09TWF0aC5taW4oelsxXSxwWzFdKSxOfWZ1bmN0aW9uIHYoTix6LHApe3JldHVybiBOWzBdPU1hdGgubWF4KHpbMF0scFswXSksTlsxXT1NYXRoLm1heCh6WzFdLHBbMV0pLE59ZnVuY3Rpb24gUChOLHope3JldHVybiBOWzBdPU1hdGgucm91bmQoelswXSksTlsxXT1NYXRoLnJvdW5kKHpbMV0pLE59ZnVuY3Rpb24gaShOLHoscCl7cmV0dXJuIE5bMF09elswXSpwLE5bMV09elsxXSpwLE59ZnVuY3Rpb24gdShOLHoscCxNKXtyZXR1cm4gTlswXT16WzBdK3BbMF0qTSxOWzFdPXpbMV0rcFsxXSpNLE59ZnVuY3Rpb24gYShOLHope3ZhciBwPXpbMF0tTlswXSxNPXpbMV0tTlsxXTtyZXR1cm4gTWF0aC5oeXBvdChwLE0pfWZ1bmN0aW9uIGgoTix6KXt2YXIgcD16WzBdLU5bMF0sTT16WzFdLU5bMV07cmV0dXJuIHAqcCtNKk19ZnVuY3Rpb24gYihOKXt2YXIgej1OWzBdLHA9TlsxXTtyZXR1cm4gTWF0aC5oeXBvdCh6LHApfWZ1bmN0aW9uIEUoTil7dmFyIHo9TlswXSxwPU5bMV07cmV0dXJuIHoqeitwKnB9ZnVuY3Rpb24gQShOLHope3JldHVybiBOWzBdPS16WzBdLE5bMV09LXpbMV0sTn1mdW5jdGlvbiBMKE4seil7cmV0dXJuIE5bMF09MS96WzBdLE5bMV09MS96WzFdLE59ZnVuY3Rpb24gUyhOLHope3ZhciBwPXpbMF0sTT16WzFdLHc9cCpwK00qTTtyZXR1cm4gdz4wJiYodz0xL01hdGguc3FydCh3KSksTlswXT16WzBdKncsTlsxXT16WzFdKncsTn1mdW5jdGlvbiBJKE4seil7cmV0dXJuIE5bMF0qelswXStOWzFdKnpbMV19ZnVuY3Rpb24gRChOLHoscCl7dmFyIE09elswXSpwWzFdLXpbMV0qcFswXTtyZXR1cm4gTlswXT1OWzFdPTAsTlsyXT1NLE59ZnVuY3Rpb24gUihOLHoscCxNKXt2YXIgdz16WzBdLFU9elsxXTtyZXR1cm4gTlswXT13K00qKHBbMF0tdyksTlsxXT1VK00qKHBbMV0tVSksTn1mdW5jdGlvbiBDKE4seil7ej16fHwxO3ZhciBwPXIuUkFORE9NKCkqMipNYXRoLlBJO3JldHVybiBOWzBdPU1hdGguY29zKHApKnosTlsxXT1NYXRoLnNpbihwKSp6LE59ZnVuY3Rpb24gaihOLHoscCl7dmFyIE09elswXSx3PXpbMV07cmV0dXJuIE5bMF09cFswXSpNK3BbMl0qdyxOWzFdPXBbMV0qTStwWzNdKncsTn1mdW5jdGlvbiAkKE4seixwKXt2YXIgTT16WzBdLHc9elsxXTtyZXR1cm4gTlswXT1wWzBdKk0rcFsyXSp3K3BbNF0sTlsxXT1wWzFdKk0rcFszXSp3K3BbNV0sTn1mdW5jdGlvbiBIKE4seixwKXt2YXIgTT16WzBdLHc9elsxXTtyZXR1cm4gTlswXT1wWzBdKk0rcFszXSp3K3BbNl0sTlsxXT1wWzFdKk0rcFs0XSp3K3BbN10sTn1mdW5jdGlvbiBKKE4seixwKXt2YXIgTT16WzBdLHc9elsxXTtyZXR1cm4gTlswXT1wWzBdKk0rcFs0XSp3K3BbMTJdLE5bMV09cFsxXSpNK3BbNV0qdytwWzEzXSxOfWZ1bmN0aW9uIHEoTix6LHAsTSl7dmFyIHc9elswXS1wWzBdLFU9elsxXS1wWzFdLEs9TWF0aC5zaW4oTSksWT1NYXRoLmNvcyhNKTtyZXR1cm4gTlswXT13KlktVSpLK3BbMF0sTlsxXT13KksrVSpZK3BbMV0sTn1mdW5jdGlvbiBGKE4seil7dmFyIHA9TlswXSxNPU5bMV0sdz16WzBdLFU9elsxXSxLPU1hdGguc3FydChwKnArTSpNKSpNYXRoLnNxcnQodyp3K1UqVSksWT1LJiYocCp3K00qVSkvSztyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KFksLTEpLDEpKX1mdW5jdGlvbiBHKE4pe3JldHVybiBOWzBdPTAsTlsxXT0wLE59ZnVuY3Rpb24gWihOKXtyZXR1cm4idmVjMigiK05bMF0rIiwgIitOWzFdKyIpIn1mdW5jdGlvbiB0dChOLHope3JldHVybiBOWzBdPT09elswXSYmTlsxXT09PXpbMV19ZnVuY3Rpb24gZXQoTix6KXt2YXIgcD1OWzBdLE09TlsxXSx3PXpbMF0sVT16WzFdO3JldHVybiBNYXRoLmFicyhwLXcpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhwKSxNYXRoLmFicyh3KSkmJk1hdGguYWJzKE0tVSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE0pLE1hdGguYWJzKFUpKX12YXIgaXQ9YixrPXgsaHQ9ZyxmdD15LEI9YSxXPWgsVj1FLFg9ZnVuY3Rpb24oKXt2YXIgTj1uKCk7cmV0dXJuIGZ1bmN0aW9uKHoscCxNLHcsVSxLKXt2YXIgWSxRO2ZvcihwfHwocD0yKSxNfHwoTT0wKSx3P1E9TWF0aC5taW4odypwK00sei5sZW5ndGgpOlE9ei5sZW5ndGgsWT1NO1k8UTtZKz1wKU5bMF09eltZXSxOWzFdPXpbWSsxXSxVKE4sTixLKSx6W1ldPU5bMF0seltZKzFdPU5bMV07cmV0dXJuIHp9fSgpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpO3ZhciByPXQoMTMpO3QuZChlLCJSZW5kZXJlciIsZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0fSk7dmFyIG49dCg0MCk7dC5kKGUsIkZpZ3VyZTJEIixmdW5jdGlvbigpe3JldHVybiBuLmRlZmF1bHR9KTt2YXIgcz10KDU2KTt0LmQoZSwiTWVzaDJEIixmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHR9KTt2YXIgbD10KDI5KTt0LmQoZSwiTWVzaENsb3VkIixmdW5jdGlvbigpe3JldHVybiBsLmRlZmF1bHR9KTt2YXIgYz10KDIzKTt0LmQoZSwicGFyc2VGb250IixmdW5jdGlvbigpe3JldHVybiBjLmRlZmF1bHR9KTt2YXIgbz10KDMxKTt0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gby5kZWZhdWx0fSk7dmFyIGY9dCgyMSk7dC5kKGUsIkVOViIsZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWZhdWx0fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBMfSk7dmFyIHI9dCgxNCksbj10KDEpLHM9dCgyMCksbD10KDI3KSxjPXQoMjUpLG89dCg0MCksZj10KDU2KSx4PXQoMjkpLGc9dCg1OSkseT10KDIxKSxtPXQoNjMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPXthdXRvVXBkYXRlOiExLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMSxidWZmZXJTaXplOjE1MDB9LE89YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKdm9pZCBtYWluKCkgewogIGdsX1BvaW50U2l6ZSA9IDEuMDsKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsgICAgCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOyAgICAgICAgICAgICAgCn0KYCx2PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U2FtcGxlcjsKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3RleFNhbXBsZXIsIHZUZXh0dXJlQ29vcmQueHkpOwp9CmAsUD1TeW1ib2woImdsUmVuZGVyZXIiKSxpPVN5bWJvbCgiY2FudmFzUmVuZGVyZXIiKSx1PVN5bWJvbCgib3B0aW9ucyIpLGE9U3ltYm9sKCJnbG9iYWxUcmFuc2Zvcm0iKSxoPVN5bWJvbCgiYXBwbHlHbG9iYWxUcmFuc2Zvcm0iKSxiPVN5bWJvbCgiY2FudmFzIik7ZnVuY3Rpb24gRShTKXtjb25zdCBJPVMuZ2wsRD1TLmZibztEJiZJLmJpbmRGcmFtZWJ1ZmZlcihJLkZSQU1FQlVGRkVSLEQpLFMuX2RyYXcoKSxEJiZJLmJpbmRGcmFtZWJ1ZmZlcihJLkZSQU1FQlVGRkVSLG51bGwpfWZ1bmN0aW9uIEEoUyxJLEQsUil7Y29uc3QgQz1TLmNyZWF0ZVRleHR1cmUoSS5jYW52YXMpLGo9W1tbMCwwXSxbRCwwXSxbRCxSXSxbMCxSXSxbMCwwXV1dO2ouY2xvc2VkPSEwO2NvbnN0ICQ9bmV3IGYuZGVmYXVsdCh7Y29udG91cnM6an0pOyQuc2V0VGV4dHVyZShDKSxTLnNldE1lc2hEYXRhKFskLm1lc2hEYXRhXSksRShTKSxDLmRlbGV0ZSgpLEkuY2xlYXJSZWN0KDAsMCxELFIpLGRlbGV0ZSBJLl9maWx0ZXJ9Y2xhc3MgTHtjb25zdHJ1Y3RvcihJLEQ9e30pe2xldCBSPUQuY29udGV4dFR5cGU7aWYoUnx8KHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0PT0iZnVuY3Rpb24iP1I9IndlYmdsMiI6dHlwZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dD09ImZ1bmN0aW9uIj9SPSJ3ZWJnbCI6Uj0iMmQiKSwhSS5nZXRDb250ZXh0KXtjb25zdCBDPUk7ST17Z2V0Q29udGV4dCgpe3JldHVybiBDfSx3aWR0aDpELndpZHRoLGhlaWdodDpELmhlaWdodH0sQy5jYW52YXM9SSxSPSIyZCJ9aWYodGhpc1tiXT1JLFIhPT0id2ViZ2wiJiZSIT09IndlYmdsMiImJlIhPT0iMmQiKXRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb250ZXh0IHR5cGUgJHtSfWApO2lmKEQuY29udGV4dFR5cGU9Uix0aGlzW3VdPU9iamVjdC5hc3NpZ24oe30sVCxEKSxSPT09IndlYmdsInx8Uj09PSJ3ZWJnbDIiKXtSPT09IndlYmdsMiImJih0aGlzW3VdLndlYmdsMj0hMCk7Y29uc3QgQz1uZXcgci5kZWZhdWx0KEksdGhpc1t1XSk7Uj09PSJ3ZWJnbDIiJiYhQy5pc1dlYkdMMiYmKEQuY29udGV4dFR5cGU9IndlYmdsIiksT2JqZWN0KG0uY3JlYXRlU2hhZGVycykoQyksT2JqZWN0KG0uYXBwbHlTaGFkZXIpKEMpLE9iamVjdChtLmNyZWF0ZUNsb3VkU2hhZGVycykoQyk7Y29uc3Qgaj1DLmdsO2ouY2xlYXJDb2xvcigwLDAsMCwwKSxqLmJsZW5kRnVuY1NlcGFyYXRlKGouU1JDX0FMUEhBLGouT05FX01JTlVTX1NSQ19BTFBIQSxqLk9ORSxqLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXNbUF09Q31lbHNlIHRoaXNbaV09bmV3IHMuZGVmYXVsdChJLHRoaXNbdV0pO3RoaXNbYV09WzEsMCwwLDAsMSwwLDAsMCwxXSx0aGlzLnVwZGF0ZVJlc29sdXRpb24oKX1nZXQgY2FudmFzKCl7cmV0dXJuIHRoaXNbYl19Z2V0IGNhbnZhc1JlbmRlcmVyKCl7cmV0dXJuIHRoaXNbaV19Z2V0IGdsUmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tQXX1nZXQgaXNXZWJHTDIoKXtyZXR1cm4gdGhpc1tQXSYmdGhpc1tQXS5pc1dlYkdMMn1nZXQgb3B0aW9ucygpe3JldHVybiB0aGlzW3VdfWdldCBnbG9iYWxUcmFuc2Zvcm1NYXRyaXgoKXtjb25zdCBJPXRoaXNbYV07cmV0dXJuW0lbMF0sSVsxXSxJWzNdLElbNF0sSVs2XSxJWzddXX1nZXQgdmlld01hdHJpeCgpe3JldHVybiB0aGlzW2FdfVtoXSgpe2NvbnN0IEk9dGhpc1tQXXx8dGhpc1tpXTtpZih0aGlzW1BdKXtjb25zdHt3aWR0aDpELGhlaWdodDpSfT10aGlzLmNhbnZhcztJLnVuaWZvcm1zLnZpZXdNYXRyaXg9dGhpcy52aWV3TWF0cml4LEkudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeD10aGlzLnByb2plY3Rpb25NYXRyaXgsSS51bmlmb3Jtcy51X3Jlc29sdXRpb249W0QsUl19fXVwZGF0ZVJlc29sdXRpb24oKXtjb25zdHt3aWR0aDpJLGhlaWdodDpEfT10aGlzLmNhbnZhcyxSPVsxLDAsMCwwLDEsMCwtSS8yLC1ELzIsMV0sQz1bMi9JLDAsMCwwLC0yL0QsMCwwLDAsMV0saj1uLm1hdDMubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEMsUik7dGhpcy5wcm9qZWN0aW9uTWF0cml4PWosdGhpc1tQXSYmdGhpc1tQXS5nbC52aWV3cG9ydCgwLDAsSSxEKX1jcmVhdGVUZXh0dXJlKEksRCl7cmV0dXJuKHRoaXNbUF18fHRoaXNbaV0pLmNyZWF0ZVRleHR1cmUoSSxEKX1sb2FkVGV4dHVyZShJLHt1c2VJbWFnZUJpdG1hcDpEPSExfT17fSl7cmV0dXJuKHRoaXNbUF18fHRoaXNbaV0pLmxvYWRUZXh0dXJlKEkse3VzZUltYWdlQml0bWFwOkR9KX1jcmVhdGVUZXh0KEkse2ZvbnQ6RD0iMTZweCBhcmlhbCIsZmlsbENvbG9yOlI9bnVsbCxzdHJva2VDb2xvcjpDPW51bGwsc3Ryb2tlV2lkdGg6aj0xfT17fSl7aWYodGhpc1tQXSl7Y29uc3QgJD15LmRlZmF1bHQuY3JlYXRlVGV4dChJLHtmb250OkQsZmlsbENvbG9yOlIsc3Ryb2tlQ29sb3I6QyxzdHJva2VXaWR0aDpqfSk7cmV0dXJue2ltYWdlOnRoaXMuY3JlYXRlVGV4dHVyZSgkLmltYWdlKSxyZWN0OiQucmVjdH19cmV0dXJue19pbWc6e2ZvbnQ6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpDLHN0cm9rZVdpZHRoOmosdGV4dDpJfX19Y3JlYXRlUHJvZ3JhbSh7dmVydGV4OkksZnJhZ21lbnQ6RCxvcHRpb25zOlJ9PXt9KXtpZih0aGlzW1BdKXtjb25zdCBDPXRoaXNbUF0uY29tcGlsZVN5bmMoRCxJKTtyZXR1cm4gQy5fYXR0cmliT3B0cz1SLEN9dGhyb3cgbmV3IEVycm9yKCJDb250ZXh0IDJEIGNhbm5vdCBjcmVhdGUgd2ViZ2wgcHJvZ3JhbS4iKX1jcmVhdGVQYXNzUHJvZ3JhbSh7dmVydGV4Okk9TyxmcmFnbWVudDpEPXYsb3B0aW9uczpSfT17fSl7cmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbSh7dmVydGV4OkksZnJhZ21lbnQ6RCxvcHRpb25zOlJ9KX11c2VQcm9ncmFtKEksRD17fSl7aWYodGhpc1tQXSl7Y29uc3QgUj1PYmplY3QuYXNzaWduKHt9LEkuX2F0dHJpYk9wdHMsRCk7cmV0dXJuIHRoaXNbUF0udXNlUHJvZ3JhbShJLFIpfXRocm93IG5ldyBFcnJvcigiQ29udGV4dCAyRCBjYW5ub3QgdXNlIHdlYmdsIHByb2dyYW0uIil9ZGVsZXRlVGV4dHVyZShJKXtyZXR1cm4odGhpc1tQXXx8dGhpc1tpXSkuZGVsZXRlVGV4dHVyZShJKX1jbGVhciguLi5JKXtpZih0aGlzW1BdKXtjb25zdCBEPXRoaXNbUF0uZ2w7RC5jbGVhcihELkNPTE9SX0JVRkZFUl9CSVQpfWVsc2UgdGhpc1tpXS5jbGVhciguLi5JKX1kcmF3TWVzaENsb3VkKEkse2NsZWFyOkQ9ITEscHJvZ3JhbTpSPW51bGx9PXt9KXtjb25zdCBDPXRoaXNbUF18fHRoaXNbaV0saj1SfHxJLnByb2dyYW07aWYodGhpc1tQXSl7Y29uc3QgJD1DLmdsO2lmKEQmJiQuY2xlYXIoJC5DT0xPUl9CVUZGRVJfQklUKSxqKUMucHJvZ3JhbSE9PWomJnRoaXMudXNlUHJvZ3JhbShqLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZmlsbENsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9zdHJva2VDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZnJhbWVJbmRleDp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiExfX0pO2Vsc2V7Y29uc3QgSD1JLm1lc2gubWVzaERhdGEsSj0hIUgudW5pZm9ybXMudV90ZXhTYW1wbGVyLHE9ISFILnVuaWZvcm1zLnVfZmlsdGVyRmxhZyxGPSEhSC51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLEc9SS5oYXNDbG91ZENvbG9yLFo9SS5oYXNDbG91ZEZpbHRlcix0dD0hIUgudW5pZm9ybXMudV9jbGlwU2FtcGxlcjtPYmplY3QobS5hcHBseUNsb3VkU2hhZGVyKShDLHtoYXNUZXh0dXJlOkosaGFzRmlsdGVyOnEsaGFzR3JhZGllbnQ6RixoYXNDbG91ZENvbG9yOkcsaGFzQ2xvdWRGaWx0ZXI6WixoYXNDbGlwUGF0aDp0dH0pfXRoaXNbaF0oKSxDLnNldE1lc2hEYXRhKFtJLm1lc2hEYXRhXSksSS5iZWZvcmVSZW5kZXImJkkuYmVmb3JlUmVuZGVyKCQsSSksRShDKSxJLmFmdGVyUmVuZGVyJiZJLmFmdGVyUmVuZGVyKCQsSSl9ZWxzZSBDLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksQy5kcmF3TWVzaENsb3VkKEkse2NsZWFyOkQsaG9vazohMX0pfWRyYXdNZXNoZXMoSSx7Y2xlYXI6RD0hMSxwcm9ncmFtOlI9bnVsbH09e30pe2NvbnN0IEM9dGhpc1tQXXx8dGhpc1tpXTtpZih0aGlzW1BdKXtjb25zdCBqPUMuZmJvLCQ9T2JqZWN0KGwuZGVmYXVsdCkodGhpcyxJLFI9PW51bGwpLEg9Qy5nbDtEJiZILmNsZWFyKEguQ09MT1JfQlVGRkVSX0JJVCk7Y29uc3QgSj0hT2JqZWN0KGcuaXNVbml0VHJhbnNmb3JtKSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCk7dGhpcy5fZHJhd0NhbGxzPTA7Zm9yKGNvbnN0IHEgb2YgJCl7dGhpcy5fZHJhd0NhbGxzKys7Y29uc3QgRj1SfHxxLnByb2dyYW07aWYocSBpbnN0YW5jZW9mIHguZGVmYXVsdCl0aGlzLmRyYXdNZXNoQ2xvdWQocSx7Y2xlYXI6RCxwcm9ncmFtOkZ9KTtlbHNle2NvbnN0e3dpZHRoOkcsaGVpZ2h0Olp9PXRoaXMuY2FudmFzO2lmKHEuYmVmb3JlUmVuZGVyJiZxLmJlZm9yZVJlbmRlcihILHEpLHEucGFzcy5sZW5ndGgmJigoIXRoaXMuZmJvfHx0aGlzLmZiby53aWR0aCE9PUd8fHRoaXMuZmJvLmhlaWdodCE9PVopJiYodGhpcy5mYm89e3dpZHRoOkcsaGVpZ2h0OlosdGFyZ2V0OkMuY3JlYXRlRkJPKCksYnVmZmVyOkMuY3JlYXRlRkJPKCksc3dhcCgpe1t0aGlzLnRhcmdldCx0aGlzLmJ1ZmZlcl09W3RoaXMuYnVmZmVyLHRoaXMudGFyZ2V0XX19KSxDLmJpbmRGQk8odGhpcy5mYm8udGFyZ2V0KSksIUYmJnEuZmlsdGVyQ2FudmFzKXtPYmplY3QobS5hcHBseVNoYWRlcikoQyx7aGFzVGV4dHVyZTohMH0pO2xldCB0dD10aGlzLmZpbHRlckNvbnRleHQ7dHR8fCh0dD15LmRlZmF1bHQuY3JlYXRlQ2FudmFzKEcsWikuZ2V0Q29udGV4dCgiMmQiKSx0aGlzLmZpbHRlckNvbnRleHQ9dHQpO2NvbnN0IGV0PUlbcS5wYWNrSW5kZXhdLGl0PWV0LmZpbHRlcixrPUlbcS5wYWNrSW5kZXgrMV0saHQ9SVtxLnBhY2tJbmRleC0xXTsoIWh0fHwhaHQuZmlsdGVyQ2FudmFzfHxodC5maWx0ZXIhPT1pdCkmJigha3x8IWsuZmlsdGVyQ2FudmFzfHxrLmZpbHRlciE9PWl0KT8oSj8odHQuc2F2ZSgpLE9iamVjdChjLmRyYXdNZXNoMkQpKGV0LHR0LCExKSx0dC5yZXN0b3JlKCksT2JqZWN0KGMuYXBwbHlGaWx0ZXIpKHR0LGl0KSk6T2JqZWN0KGMuZHJhd01lc2gyRCkoZXQsdHQsITApLHRoaXNbaF0oKSxBKEMsdHQsRyxaKSk6KEomJnR0LnNhdmUoKSxPYmplY3QoYy5kcmF3TWVzaDJEKShldCx0dCwhMSksSiYmdHQucmVzdG9yZSgpLCgha3x8IWsuZmlsdGVyQ2FudmFzfHxldC5maWx0ZXIhPT1rLmZpbHRlcikmJihPYmplY3QoYy5hcHBseUZpbHRlcikodHQsaXQpLHRoaXNbaF0oKSxBKEMsdHQsRyxaKSkpfWVsc2V7aWYoRilDLnByb2dyYW0hPT1GJiZ0aGlzLnVzZVByb2dyYW0oRix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pO2Vsc2V7Y29uc3QgdHQ9ISFxLnVuaWZvcm1zLnVfdGV4U2FtcGxlcixldD0hIXEudW5pZm9ybXMudV9maWx0ZXJGbGFnLGl0PSEhcS51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLGs9ISFxLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KG0uYXBwbHlTaGFkZXIpKEMse2hhc1RleHR1cmU6dHQsaGFzRmlsdGVyOmV0LGhhc0dyYWRpZW50Oml0LGhhc0NsaXBQYXRoOmt9KX1xLmZpbHRlckNhbnZhcyYmY29uc29sZS53YXJuKCJVc2VyIHByb2dyYW0gaWdub3JlZCBzb21lIGZpbHRlciBlZmZlY3RzLiIpLHRoaXNbaF0oKSxDLnNldE1lc2hEYXRhKFtxXSksRShDKX1pZihxLnBhc3MubGVuZ3RoKXtjb25zdCB0dD1xLnBhc3MubGVuZ3RoO3EucGFzcy5mb3JFYWNoKChldCxpdCk9PntldC5ibGVuZD1xLmVuYWJsZUJsZW5kLGV0LnNldFRleHR1cmUoQy5mYm8udGV4dHVyZSksaXQ9PT10dC0xP0MuYmluZEZCTyhqKToodGhpcy5mYm8uc3dhcCgpLEMuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSxldC5wcm9ncmFtP0MudXNlUHJvZ3JhbShldC5wcm9ncmFtKToodGhpcy5kZWZhdWx0UGFzc1Byb2dyYW09dGhpcy5kZWZhdWx0UGFzc1Byb2dyYW18fHRoaXMuY3JlYXRlUGFzc1Byb2dyYW0oKSxDLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0UGFzc1Byb2dyYW0pKSxDLnNldE1lc2hEYXRhKFtldC5tZXNoRGF0YV0pLEguY2xlYXIoSC5DT0xPUl9CVUZGRVJfQklUKSxFKEMpfSl9cS5hZnRlclJlbmRlciYmcS5hZnRlclJlbmRlcihILHEpfX19ZWxzZSBDLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksQy5kcmF3TWVzaGVzKEkse2NsZWFyOkR9KX1kcmF3SW1hZ2UoSSwuLi5EKXtjb25zdCBSPUQubGVuZ3RoO2lmKFI8Mil0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiAzIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHtELmxlbmd0aCsxfSBwcmVzZW50LmApO2lmKFIhPT0yJiZSIT09NCYmUiE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ2RyYXdJbWFnZScgb24gJ1JlbmRlcmVyJzogVmFsaWQgYXJpdGllcyBhcmU6IFszLCA1LCA5XSwgYnV0ICR7RC5sZW5ndGgrMX0gYXJndW1lbnRzIHByb3ZpZGVkLmApO2xldCBDPW51bGwsaj1udWxsO1I9PT0yP0M9W0RbMF0sRFsxXSxJLndpZHRoLEkuaGVpZ2h0XTpSPT09ND9DPUQ6Uj09PTgmJihqPUQuc2xpY2UoMCw0KSxDPUQuc2xpY2UoNCkpO2NvbnN0ICQ9dGhpcy5jcmVhdGVUZXh0dXJlKEkpLHt3aWR0aDpILGhlaWdodDpKfT10aGlzLmNhbnZhcyxxPW5ldyBvLmRlZmF1bHQ7cS5yZWN0KENbMF0sQ1sxXSxILEopO2NvbnN0IEY9bmV3IGYuZGVmYXVsdChxLHt3aWR0aDpILGhlaWdodDpKfSk7Ri5zZXRUZXh0dXJlKCQse3JlY3Q6QyxzcmNSZWN0Omp9KSx0aGlzLmRyYXdNZXNoZXMoW0ZdKSx0aGlzLmRlbGV0ZVRleHR1cmUoJCl9c2V0R2xvYmFsVHJhbnNmb3JtKC4uLkkpe3JldHVybiB0aGlzW2FdPVtJWzBdLElbMV0sMCxJWzJdLElbM10sMCxJWzRdLElbNV0sMV0sdGhpc31nbG9iYWxUcmFuc2Zvcm0oLi4uSSl7Y29uc3QgRD10aGlzW2FdO3JldHVybiB0aGlzW2FdPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksRCxJKSx0aGlzfWdsb2JhbFRyYW5zbGF0ZShJLEQpe2xldCBSPW4ubWF0My5jcmVhdGUoKTtyZXR1cm4gUj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxSLFtJLERdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5SKX1nbG9iYWxSb3RhdGUoSSxbRCxSXT1bMCwwXSl7bGV0IEM9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBDPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEMsW0QsUl0pLEM9bi5tYXQzLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxJKSxDPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEMsWy1ELC1SXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQyl9Z2xvYmFsU2NhbGUoSSxEPUksW1IsQ109WzAsMF0pe2xldCBqPW4ubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtSLENdKSxqPW4ubWF0My5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixbSSxEXSksaj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstUiwtQ10pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfWdsb2JhbFNrZXcoSSxEPUksW1IsQ109WzAsMF0pe2xldCBqPW4ubWF0My5jcmVhdGUoKTtyZXR1cm4gaj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFtSLENdKSxqPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksaixuLm1hdDMuZnJvbVZhbHVlcygxLE1hdGgudGFuKEQpLE1hdGgudGFuKEkpLDEsMCwwKSksaj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxqLFstUiwtQ10pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLmopfXRyYW5zZm9ybVBvaW50KEksRCxSKXtsZXQgQz10aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtSJiYoQz1uLm1hdDMubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEMsUikpO2NvbnN0IGo9SSpDWzBdK0QqQ1syXStDWzRdLCQ9SSpDWzFdK0QqQ1szXStDWzVdO3JldHVybltqLCRdfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSk7dmFyIHI9dCgxNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1yLmRlZmF1bHR9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgcj10KDE2KSxuPXQoMTcpLHM9dCgxOCksbD10KDE5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYyhULE8sdil7cmV0dXJuIE8gaW4gVD9PYmplY3QuZGVmaW5lUHJvcGVydHkoVCxPLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6VFtPXT12LFR9Y29uc3Qgbz17fTtmdW5jdGlvbiBmKFQsTz0zKXtjb25zdCB2PVtdLFA9VC5sZW5ndGg7Zm9yKGxldCBpPTA7aTxQO2krKylpJU88MiYmdi5wdXNoKC41KihUW2ldKzEpKTtyZXR1cm4gdn1mdW5jdGlvbiB4KFQsTyl7Y29uc3Qgdj1PLl9idWZmZXJzO09iamVjdC52YWx1ZXModikuZm9yRWFjaChQPT57VC5kZWxldGVCdWZmZXIoUCl9KSxPLl9idWZmZXJzPXt9fWZ1bmN0aW9uIGcoVCxPLHYpe3JldHVybiBULmFjdGl2ZVRleHR1cmUoVC5URVhUVVJFMCt2KSxBcnJheS5pc0FycmF5KE8uX2ltZyk/VC5iaW5kVGV4dHVyZShULlRFWFRVUkVfQ1VCRV9NQVAsTyk6VC5iaW5kVGV4dHVyZShULlRFWFRVUkVfMkQsTyksT31jb25zdCB5PXtpbnQ6IjFpIixpdmVjMjoiMmkiLGl2ZWMzOiIzaSIsaXZlYzQ6IjRpIixmbG9hdDoiMWYiLHZlYzI6IjJmIix2ZWMzOiIzZiIsdmVjNDoiNGYiLG1hdDI6Ik1hdHJpeDJmdiIsbWF0MzoiTWF0cml4M2Z2IixtYXQ0OiJNYXRyaXg0ZnYiLHNhbXBsZXIxRDoic2FtcGxlcjFEIixzYW1wbGVyMkQ6InNhbXBsZXIyRCIsc2FtcGxlcjNEOiJzYW1wbGVyM0QiLHNhbXBsZXJDdWJlOiJzYW1wbGVyQ3ViZSIsc2FtcGxlcjFEU2hhZG93OiJzYW1wbGVyMURTaGFkb3ciLHNhbXBsZXIyRFNoYWRvdzoic2FtcGxlcjJEU2hhZG93IixzYW1wbGVyMkRSZWN0OiJzYW1wbGVyMkRSZWN0IixzYW1wbGVyMkRSZWN0U2hhZG93OiJzYW1wbGVyMkRSZWN0U2hhZG93In07Y2xhc3MgbXtzdGF0aWMgYWRkTGlicyhPPXt9KXtPYmplY3QuYXNzaWduKG8sTyl9c3RhdGljIEZMT0FUKE8sdil7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShPLEZsb2F0MzJBcnJheSx2KX1zdGF0aWMgVU5TSUdORURfQllURShPLHYpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoTyxVaW50OEFycmF5LHYpfXN0YXRpYyBVTlNJR05FRF9TSE9SVChPLHYpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoTyxVaW50MTZBcnJheSx2KX1zdGF0aWMgQllURShPLHYpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoTyxJbnQ4QXJyYXksdil9c3RhdGljIFNIT1JUKE8sdil7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShPLEludDE2QXJyYXksdil9Y29uc3RydWN0b3IoTyx2PXt9KXt0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSxtLmRlZmF1bHRPcHRpb25zLHYpLHRoaXMuY2FudmFzPU87bGV0IFA7dGhpcy5vcHRpb25zLndlYmdsMiYmKFA9Ty5nZXRDb250ZXh0KCJ3ZWJnbDIiLHRoaXMub3B0aW9ucykpLFA9PW51bGwmJihQPU9iamVjdChyLnNldHVwV2ViR0wpKE8sdGhpcy5vcHRpb25zKSx0aGlzLmFpYV9leHQ9UC5nZXRFeHRlbnNpb24oIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKSksdGhpcy5nbD1QLFAudmlld3BvcnQoMCwwLE8ud2lkdGgsTy5oZWlnaHQpLFAuY2xlYXJDb2xvcigwLDAsMCwwKSxQLmJsZW5kRnVuY1NlcGFyYXRlKFAuU1JDX0FMUEhBLFAuT05FX01JTlVTX1NSQ19BTFBIQSxQLk9ORSxQLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXMucHJvZ3JhbXM9W10sdGhpcy5fZXZlbnRzPXt9fWdldCBwcm9ncmFtKCl7Y29uc3QgTz10aGlzLmdsO3JldHVybiBPLmdldFBhcmFtZXRlcihPLkNVUlJFTlRfUFJPR1JBTSl9X2RlY2xhcmVVbmlmb3JtKE8sdixQPSIxZiIpe2NvbnN0IGk9dGhpcy5nbCx1PWkuZ2V0VW5pZm9ybUxvY2F0aW9uKE8sdik7bGV0IGE7Y29uc3QgaD10aGlzO2lmKC9ec2FtcGxlci8udGVzdChQKSl7Y29uc3QgYj1PLl9zYW1wbGVyTWFwLEU9Ty5fYmluZFRleHR1cmVzO09iamVjdC5kZWZpbmVQcm9wZXJ0eShPLnVuaWZvcm1zLHYse2dldCgpe3JldHVybiBhfSxzZXQoQSl7YT1BO2NvbnN0IEw9Ylt2XSE9bnVsbD9iW3ZdOkUubGVuZ3RoO0VbTF09QSxnKGksQSxMKSxiW3ZdfHwoYlt2XT1MLGkudW5pZm9ybTFpKHUsTCkpLGgub3B0aW9ucy5hdXRvVXBkYXRlJiZoLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfWVsc2V7Y29uc3QgYj1QLmluZGV4T2YoIk1hdHJpeCIpPT09MCxFPSFiJiYvdiQvLnRlc3QoUCksQT1pW2B1bmlmb3JtJHtQfWBdLmJpbmQoaSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE8udW5pZm9ybXMsdix7Z2V0KCl7cmV0dXJuIGF9LHNldChMKXthPUwsdHlwZW9mIEw9PSJudW1iZXIiJiYoTD1bTF0pLGI/QSh1LCExLEwpOkU/QSh1LEwpOkEodSwuLi5MKSxoLm9wdGlvbnMuYXV0b1VwZGF0ZSYmaC51cGRhdGUoKX0sY29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITB9KX19X2RyYXcoKXtjb25zdCBPPXRoaXMucHJvZ3JhbTtPLm1lc2hEYXRhLmZvckVhY2goKHYsUCk9Pntjb25zdHtwb3NpdGlvbnM6aSxjZWxsczp1LGluc3RhbmNlQ291bnQ6YSxjZWxsc0NvdW50OmgsYXR0cmlidXRlczpiLHVuaWZvcm1zOkUsdGV4dHVyZUNvb3JkOkEsZW5hYmxlQmxlbmQ6TH09dixTPXRoaXMuZ2w7bGV0IEk9di5tb2RlIT1udWxsP3YubW9kZTpTLlRSSUFOR0xFUzt0eXBlb2YgST09InN0cmluZyImJihJPVNbSV0pLEw/Uy5lbmFibGUoUy5CTEVORCk6Uy5kaXNhYmxlKFMuQkxFTkQpLFMuYmluZEJ1ZmZlcihTLkFSUkFZX0JVRkZFUixPLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKSxTLmJ1ZmZlckRhdGEoUy5BUlJBWV9CVUZGRVIsaSxTLlNUQVRJQ19EUkFXKSx1JiYoUy5iaW5kQnVmZmVyKFMuRUxFTUVOVF9BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy5jZWxsc0J1ZmZlciksUy5idWZmZXJEYXRhKFMuRUxFTUVOVF9BUlJBWV9CVUZGRVIsdSxTLlNUQVRJQ19EUkFXKSk7Y29uc3QgRD1bXTtiJiZPYmplY3QudmFsdWVzKGIpLmZvckVhY2goKHtuYW1lOkMsZGF0YTpqLGRpdmlzb3I6JH0pPT57aWYoUy5iaW5kQnVmZmVyKFMuQVJSQVlfQlVGRkVSLE8uX2J1ZmZlcnNbQ10pLFMuYnVmZmVyRGF0YShTLkFSUkFZX0JVRkZFUixqLFMuU1RBVElDX0RSQVcpLCQhPW51bGwpe2NvbnN0IEg9Uy5nZXRBdHRyaWJMb2NhdGlvbihPLEMpO0g+PTAmJihTLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEgpLEQucHVzaChIKSxTLnZlcnRleEF0dHJpYkRpdmlzb3I/Uy52ZXJ0ZXhBdHRyaWJEaXZpc29yKEgsJCk6dGhpcy5haWFfZXh0JiZ0aGlzLmFpYV9leHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKEgsJCkpfX0pLEUmJk9iamVjdC5lbnRyaWVzKEUpLmZvckVhY2goKFtDLGpdKT0+e3RoaXMudW5pZm9ybXNbQ109an0pO2xldCBSO2lmKCF1KXtjb25zdCBDPU8uX2RpbWVuc2lvbjtSPWkubGVuZ3RoL0N9aWYoTy5fZW5hYmxlVGV4dHVyZXMmJk8uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpe2NvbnN0IEM9QXx8ZihpLE8uX2RpbWVuc2lvbik7Uy5iaW5kQnVmZmVyKFMuQVJSQVlfQlVGRkVSLE8uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpLFMuYnVmZmVyRGF0YShTLkFSUkFZX0JVRkZFUixtLkZMT0FUKEMpLFMuU1RBVElDX0RSQVcpfWEhPW51bGw/KHU/Uy5kcmF3RWxlbWVudHNJbnN0YW5jZWQ/Uy5kcmF3RWxlbWVudHNJbnN0YW5jZWQoSSxoLFMuVU5TSUdORURfU0hPUlQsMCxhKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShJLGgsUy5VTlNJR05FRF9TSE9SVCwwLGEpOlMuZHJhd0FycmF5c0luc3RhbmNlZD9TLmRyYXdBcnJheXNJbnN0YW5jZWQoSSwwLFIsYSk6dGhpcy5haWFfZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShJLDAsUixhKSxELmZvckVhY2goQz0+e1MudmVydGV4QXR0cmliRGl2aXNvcj9TLnZlcnRleEF0dHJpYkRpdmlzb3IoQyxudWxsKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoQyxudWxsKX0pKTp1P1MuZHJhd0VsZW1lbnRzKEksaCxTLlVOU0lHTkVEX1NIT1JULDApOlMuZHJhd0FycmF5cyhJLDAsUil9KX1nZXQgaXNXZWJHTDIoKXtyZXR1cm4gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ8InUiJiZ0aGlzLmdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH1nZXQgZW5hYmxlVGV4dHVyZXMoKXtyZXR1cm4gdGhpcy5wcm9ncmFtJiZ0aGlzLnByb2dyYW0uX2VuYWJsZVRleHR1cmVzfWdldCB1bmlmb3Jtcygpe2NvbnN0IE89dGhpcy5wcm9ncmFtO2lmKCFPfHwhTy51bmlmb3Jtcyl0aHJvdyBFcnJvcigiTm8gYXZhbGlhYmxlIHByb2dyYW0uIik7cmV0dXJuIE8udW5pZm9ybXN9ZGVsZXRlUHJvZ3JhbShPKXtjb25zdCB2PXRoaXMuZ2w7dGhpcy5wcm9ncmFtPT09TyYmKHRoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKSx2LnVzZVByb2dyYW0obnVsbCkpO2NvbnN0IFA9dGhpcy5wcm9ncmFtcy5pbmRleE9mKE8pO1A+PTAmJnRoaXMucHJvZ3JhbXMuc3BsaWNlKFAsMSkseCh2LE8pLHYuZGVsZXRlUHJvZ3JhbShPKX1zZXRNZXNoRGF0YShPKXtBcnJheS5pc0FycmF5KE8pfHwoTz1bT10pO2NvbnN0IHY9dGhpcy5wcm9ncmFtO3YubWVzaERhdGE9Ty5tYXAoKHttb2RlOlAscG9zaXRpb25zOmksaW5zdGFuY2VDb3VudDp1LGNlbGxzOmEsY2VsbHNDb3VudDpoLGF0dHJpYnV0ZXM6Yix1bmlmb3JtczpFLHRleHR1cmVDb29yZDpBLGVuYWJsZUJsZW5kOkx9KT0+e2NvbnN0IFM9e3Bvc2l0aW9uczptLkZMT0FUKGkpLHVuaWZvcm1zOkUsZW5hYmxlQmxlbmQ6ISFMLHRleHR1cmVDb29yZDptLkZMT0FUKEEpfTtpZihhJiYoUy5jZWxscz1tLlVTSE9SVChhKSxTLmNlbGxzQ291bnQ9aHx8Uy5jZWxscy5sZW5ndGgpLFAhPW51bGwmJihTLm1vZGU9UCksdSE9bnVsbCl7aWYoIXRoaXMuaXNXZWJHTDImJiF0aGlzLmFpYV9leHQpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgdXNlIGluc3RhbmNlQ291bnQgaW4gdGhpcyByZW5kZXJpbmcgY29udGV4dCwgdXNlIHdlYmdsMiBjb250ZXh0IGluc3RlYWQuIik7Uy5pbnN0YW5jZUNvdW50PXV9aWYoYil7Y29uc3QgST17fTtPYmplY3QuZW50cmllcyhiKS5mb3JFYWNoKChbRCxSXSk9PntpZighdi5fYXR0cmlidXRlW0RdKXYuX2F0dHJpYnV0ZVtEXT0iaWdub3JlZCI7ZWxzZSBpZih2Ll9hdHRyaWJ1dGVbRF0hPT0iaWdub3JlZCIpe2NvbnN0e25hbWU6Qyx0eXBlOmp9PXYuX2F0dHJpYnV0ZVtEXTtsZXQgJD1SLmRhdGF8fFI7aWYoQXJyYXkuaXNBcnJheSgkKSYmKCQ9bVtqXSgkKSksSVtEXT17bmFtZTpDLGRhdGE6JH0sUi5kaXZpc29yIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgZGl2aXNvciBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtJW0RdLmRpdmlzb3I9Ui5kaXZpc29yfX19KSxTLmF0dHJpYnV0ZXM9SX1yZXR1cm4gU30pLHRoaXMub3B0aW9ucy5hdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZSgpfWNyZWF0ZVByb2dyYW0oTyx2KXtjb25zdCBQPS9eXHMqdW5pZm9ybVxzK3NhbXBsZXIvbWcudGVzdChPKTtPPT1udWxsJiYoTz1zLmRlZmF1bHQpLHY9PW51bGwmJih2PVA/bC5kZWZhdWx0Om4uZGVmYXVsdCk7Y29uc3QgaT10aGlzLmdsLHU9T2JqZWN0KHIuY3JlYXRlUHJvZ3JhbSkoaSx2LE8pO3Uuc2hhZGVyVGV4dD17dmVydGV4U2hhZGVyOnYsZnJhZ21lbnRTaGFkZXI6T30sdS5fYnVmZmVycz17fSx1Ll9hdHRyaWJ1dGU9e30sdS51bmlmb3Jtcz17fSx1Ll9zYW1wbGVyTWFwPXt9LHUuX2JpbmRUZXh0dXJlcz1bXTtjb25zdCBhPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb259YCwiaW0iKTtsZXQgaD12Lm1hdGNoKGEpO2gmJih1Ll9kaW1lbnNpb249TnVtYmVyKGhbMV0pKTtjb25zdCBiPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkfWAsImltIik7aD12Lm1hdGNoKGIpLGgmJih1Ll90ZXhDb29yZFNpemU9TnVtYmVyKGhbMV0pKTtjb25zdCBFPS9eXHMqKD86YXR0cmlidXRlfGluKSAoXHcrPykoXGQqKSAoXHcrKS9naW07aWYoaD12Lm1hdGNoKEUpLGgpZm9yKGxldCBTPTA7UzxoLmxlbmd0aDtTKyspe2NvbnN0IEk9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2ltLEQ9aFtTXS5tYXRjaChJKTtpZihEJiZEWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uJiZEWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCl7bGV0WyxSLEMsal09RDtSPT09Im1hdCImJihDKio9MiksdS5fYnVmZmVyc1tqXT1pLmNyZWF0ZUJ1ZmZlcigpLHUuX2F0dHJpYnV0ZVtqXT17bmFtZTpqLHR5cGU6UixzaXplOk51bWJlcihDKXx8MX19fWNvbnN0IEE9L15ccyp1bmlmb3JtXHMrKFx3KylccysoXHcrKShcW1xkK1xdKT8vbWc7aD12Lm1hdGNoKEEpfHxbXSxoPWguY29uY2F0KE8ubWF0Y2goQSl8fFtdKSxoLmZvckVhY2goUz0+e2NvbnN0IEk9Uy5tYXRjaCgvXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy8pO2xldFtELFIsQ109SS5zbGljZSgxKTtEPXlbRF0sQz0hIUMsRC5pbmRleE9mKCJNYXRyaXgiKSE9PTAmJkMmJihEKz0idiIpLHRoaXMuX2RlY2xhcmVVbmlmb3JtKHUsUixEKX0pLHUuX2J1ZmZlcnMudmVydGljZXNCdWZmZXI9aS5jcmVhdGVCdWZmZXIoKSx1Ll9idWZmZXJzLmNlbGxzQnVmZmVyPWkuY3JlYXRlQnVmZmVyKCk7Y29uc3QgTD1pLmdldEF0dHJpYkxvY2F0aW9uKHUsdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7cmV0dXJuIHUuX2VuYWJsZVRleHR1cmVzPUw+PTAsdS5fZW5hYmxlVGV4dHVyZXMmJih1Ll9idWZmZXJzLnRleENvb3JkQnVmZmVyPWkuY3JlYXRlQnVmZmVyKCkpLHRoaXMucHJvZ3JhbXMucHVzaCh1KSx1fXVzZVByb2dyYW0oTyx2PXt9KXt0aGlzLnN0YXJ0UmVuZGVyPSExLHRoaXMuX3JlbmRlckZyYW1lSUQmJihjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUlEKSxkZWxldGUgdGhpcy5fcmVuZGVyRnJhbWVJRCk7Y29uc3QgUD10aGlzLmdsO1AudXNlUHJvZ3JhbShPKTtjb25zdCBpPU8uX2RpbWVuc2lvbjtQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcik7Y29uc3QgdT1QLmdldEF0dHJpYkxvY2F0aW9uKE8sdGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uKTtpZihQLnZlcnRleEF0dHJpYlBvaW50ZXIodSxpLFAuRkxPQVQsITEsMCwwKSxQLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHUpLE8uX2VuYWJsZVRleHR1cmVzKXtQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcik7Y29uc3QgYT1QLmdldEF0dHJpYkxvY2F0aW9uKE8sdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7UC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGEsTy5fdGV4Q29vcmRTaXplfHwyLFAuRkxPQVQsITEsMCwwKSxQLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGEpfWlmKE9iamVjdC5lbnRyaWVzKE8uX2F0dHJpYnV0ZSkuZm9yRWFjaCgoW2EsaF0pPT57aWYoaCE9PSJpZ25vcmVkIil7Y29uc3QgYj1oLnNpemUsRT12W2FdfHx7fSxBPSEhRS5ub3JtYWxpemU7bGV0IEw9RS50eXBlfHwiRkxPQVQiO2NvbnN0IFM9RS5rZXl8fGE7TD09PSJVQllURSImJihMPSJVTlNJR05FRF9CWVRFIiksTD09PSJVU0hPUlQiJiYoTD0iVU5TSUdORURfU0hPUlQiKSxoLnR5cGU9TCxTJiZTIT09YSYmKE8uX2F0dHJpYnV0ZVtTXT1oKSxQLmJpbmRCdWZmZXIoUC5BUlJBWV9CVUZGRVIsTy5fYnVmZmVyc1thXSk7Y29uc3QgST1QLmdldEF0dHJpYkxvY2F0aW9uKE8sYSk7ST49MCYmKFAudmVydGV4QXR0cmliUG9pbnRlcihJLGIsUFtMXSxBLDAsMCksUC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShJKSl9fSksIU8ubWVzaERhdGEpe2NvbnN0IGE9W1stMSwtMSwwLDFdLnNsaWNlKDAsaSksWzEsLTEsMCwxXS5zbGljZSgwLGkpLFsxLDEsMCwxXS5zbGljZSgwLGkpLFstMSwxLDAsMV0uc2xpY2UoMCxpKV0saD1bWzAsMSwzXSxbMywxLDJdXTt0aGlzLnNldE1lc2hEYXRhKHtwb3NpdGlvbnM6YSxjZWxsczpofSl9cmV0dXJuIE99Y29tcGlsZVN5bmMoTyx2KXtPPU98fHMuZGVmYXVsdDtjb25zdCBQPXt9O2Z1bmN0aW9uIGkoYil7Yj1iLnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEU9W10sQT1iLm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoQSl7Zm9yKGxldCBMPTA7TDxBLmxlbmd0aDtMKyspe2NvbnN0IEk9QVtMXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoSSl7Y29uc3QgRD1JWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBSPUlbMV07aWYoUj09PSJncmFwaCImJihSPSJncmFwaGljcyIpLFBbUl0pRS5wdXNoKGAvKiBpbmNsdWRlZCAke1J9ICovYCk7ZWxzZSBpZihQW1JdPSEwLEQ9PT0ibGliIil7Y29uc3QgQz1pKG9bUl0pO0UucHVzaChDKX1lbHNlIGlmKEQ9PT0ibGluayIpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCBleHRlcm5hbCBsaW5rcyBzeW5jaHJvbm91c2x5LiBVc2UgY29tcGlsZSBpbnN0ZWFkIG9mIGNvbXBpbGVTeW5jLiIpfX1FLmZvckVhY2goTD0+e2I9Yi5yZXBsYWNlKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tLEwpfSl9cmV0dXJuIGJ9Y29uc3QgdT1pKE8pLGE9dj9pKHYpOm51bGw7cmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbSh1LGEpfWFzeW5jIGNvbXBpbGUoTyx2KXtPPU98fHMuZGVmYXVsdDtjb25zdCBQPXt9O2FzeW5jIGZ1bmN0aW9uIGkoYil7Yj1iLnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEU9W10sQT1iLm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoQSl7Zm9yKGxldCBMPTA7TDxBLmxlbmd0aDtMKyspe2NvbnN0IEk9QVtMXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoSSl7Y29uc3QgRD1JWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBSPUlbMV07aWYoUj09PSJncmFwaCImJihSPSJncmFwaGljcyIpLFBbUl0pRS5wdXNoKGAvKiBpbmNsdWRlZCAke1J9ICovYCk7ZWxzZSBpZihQW1JdPSEwLEQ9PT0ibGliIil7Y29uc3QgQz1hd2FpdCBpKG9bUl0pO0UucHVzaChDKX1lbHNlIGlmKEQ9PT0ibGluayIpe2xldCBDPWF3YWl0IG0uZmV0Y2hTaGFkZXIoUik7Qz1hd2FpdCBpKEMpLEUucHVzaChDKX19fUUuZm9yRWFjaChMPT57Yj1iLnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sTCl9KX1yZXR1cm4gYn1jb25zdCB1PWF3YWl0IGkoTyksYT12P2F3YWl0IGkodik6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKHUsYSl9YXN5bmMgbG9hZChPLHY9bnVsbCl7cmV0dXJuIE89YXdhaXQgbS5mZXRjaFNoYWRlcihPKSx2JiYodj1hd2FpdCBtLmZldGNoU2hhZGVyKHYpKSx0aGlzLmNvbXBpbGUoTyx2KX1jcmVhdGVUZXh0dXJlKE89bnVsbCx7d3JhcFM6dj10aGlzLmdsLkNMQU1QX1RPX0VER0Usd3JhcFQ6UD10aGlzLmdsLkNMQU1QX1RPX0VER0UsbWluRmlsdGVyOmk9dGhpcy5nbC5MSU5FQVIsbWFnRmlsdGVyOnU9dGhpcy5nbC5MSU5FQVJ9PXt9KXtjb25zdCBhPXRoaXMuZ2wsaD1BcnJheS5pc0FycmF5KE8pP2EuVEVYVFVSRV9DVUJFX01BUDphLlRFWFRVUkVfMkQ7dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHM9dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHN8fGEuZ2V0UGFyYW1ldGVyKGEuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLGEuYWN0aXZlVGV4dHVyZShhLlRFWFRVUkUwK3RoaXMuX21heF90ZXh0dXJlX2ltYWdlX3VuaXRzLTEpO2NvbnN0IGI9YS5jcmVhdGVUZXh0dXJlKCk7YS5iaW5kVGV4dHVyZShoLGIpLGEucGl4ZWxTdG9yZWkoYS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCEwKTtjb25zdHt3aWR0aDpFLGhlaWdodDpBfT10aGlzLmNhbnZhcztpZihPKWlmKGg9PT1hLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBMPTA7TDw2O0wrKylhLnRleEltYWdlMkQoYS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grTCwwLGEuUkdCQSxhLlJHQkEsYS5VTlNJR05FRF9CWVRFLE9bTF0pO2Vsc2UgYS50ZXhJbWFnZTJEKGgsMCxhLlJHQkEsYS5SR0JBLGEuVU5TSUdORURfQllURSxPKTtlbHNlIGlmKGg9PT1hLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBMPTA7TDw2O0wrKyl0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grTCwwLGEuUkdCQSxFLEEsMCxhLlJHQkEsYS5VTlNJR05FRF9CWVRFLG51bGwpO2Vsc2UgYS50ZXhJbWFnZTJEKGgsMCxhLlJHQkEsRSxBLDAsYS5SR0JBLGEuVU5TSUdORURfQllURSxudWxsKTtyZXR1cm4gYS50ZXhQYXJhbWV0ZXJpKGgsYS5URVhUVVJFX01JTl9GSUxURVIsaSksYS50ZXhQYXJhbWV0ZXJpKGgsYS5URVhUVVJFX01BR19GSUxURVIsdSksYS50ZXhQYXJhbWV0ZXJpKGgsYS5URVhUVVJFX1dSQVBfUyx2KSxhLnRleFBhcmFtZXRlcmkoaCxhLlRFWFRVUkVfV1JBUF9ULFApLGg9PT1hLlRFWFRVUkVfQ1VCRV9NQVAmJihPLndpZHRoPU9bMF0ud2lkdGgsTy5oZWlnaHQ9T1swXS5oZWlnaHQpLGEuYmluZFRleHR1cmUoaCxudWxsKSxiLl9pbWc9T3x8e3dpZHRoOkUsaGVpZ2h0OkF9LGIuZGVsZXRlPSgpPT57dGhpcy5kZWxldGVUZXh0dXJlKGIpfSxifWRlbGV0ZVRleHR1cmUoTyl7Y29uc3Qgdj1PLl9pbWc7dGhpcy5nbC5kZWxldGVUZXh0dXJlKE8pLHR5cGVvZiB2LmNsb3NlPT0iZnVuY3Rpb24iJiZ2LmNsb3NlKCl9YXN5bmMgbG9hZFRleHR1cmUoTyx7dXNlSW1hZ2VCaXRtYXA6dj0hMH09e30pe2NvbnN0IFA9YXdhaXQgbS5sb2FkSW1hZ2UoTyx7dXNlSW1hZ2VCaXRtYXA6dn0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoUCl9Y3JlYXRlRkJPKHtjb2xvcjpPPTEsYmxlbmQ6dj0hMSxkZXB0aDpQPXRoaXMub3B0aW9ucy5kZXB0aCE9PSExLHN0ZW5jaWw6aT0hIXRoaXMub3B0aW9ucy5zdGVuY2lsfT17fSl7Y29uc3QgdT10aGlzLmdsLGE9dS5jcmVhdGVGcmFtZWJ1ZmZlcigpO3UuYmluZEZyYW1lYnVmZmVyKHUuRlJBTUVCVUZGRVIsYSk7Y29uc3QgaD1bXTtmb3IobGV0IEE9MDtBPE87QSsrKXtjb25zdCBMPXRoaXMuY3JlYXRlVGV4dHVyZSgpO3UuZnJhbWVidWZmZXJUZXh0dXJlMkQodS5GUkFNRUJVRkZFUix1LkNPTE9SX0FUVEFDSE1FTlQwK0EsdS5URVhUVVJFXzJELEwsMCksaC5wdXNoKEwpfWEudGV4dHVyZXM9aCxhLnRleHR1cmU9aFswXSxhLmJsZW5kPXY7Y29uc3R7d2lkdGg6YixoZWlnaHQ6RX09dGhpcy5jYW52YXM7cmV0dXJuIFAmJiFpJiYoYS5kZXB0aEJ1ZmZlcj11LmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLHUuYmluZFJlbmRlcmJ1ZmZlcih1LlJFTkRFUkJVRkZFUixhLmRlcHRoQnVmZmVyKSx1LnJlbmRlcmJ1ZmZlclN0b3JhZ2UodS5SRU5ERVJCVUZGRVIsdS5ERVBUSF9DT01QT05FTlQxNixiLEUpLHUuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIodS5GUkFNRUJVRkZFUix1LkRFUFRIX0FUVEFDSE1FTlQsdS5SRU5ERVJCVUZGRVIsYS5kZXB0aEJ1ZmZlcikpLGkmJiFQJiYoYS5zdGVuY2lsQnVmZmVyPXUuY3JlYXRlUmVuZGVyYnVmZmVyKCksdS5iaW5kUmVuZGVyYnVmZmVyKHUuUkVOREVSQlVGRkVSLGEuc3RlbmNpbEJ1ZmZlciksdS5yZW5kZXJidWZmZXJTdG9yYWdlKHUuUkVOREVSQlVGRkVSLHUuU1RFTkNJTF9JTkRFWDgsYixFKSx1LmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHUuRlJBTUVCVUZGRVIsdS5TVEVOQ0lMX0FUVEFDSE1FTlQsdS5SRU5ERVJCVUZGRVIsYS5zdGVuY2lsQnVmZmVyKSksUCYmaSYmKGEuZGVwdGhTdGVuY2lsQnVmZmVyPXUuY3JlYXRlUmVuZGVyYnVmZmVyKCksdS5iaW5kUmVuZGVyYnVmZmVyKHUuUkVOREVSQlVGRkVSLGEuZGVwdGhTdGVuY2lsQnVmZmVyKSx1LnJlbmRlcmJ1ZmZlclN0b3JhZ2UodS5SRU5ERVJCVUZGRVIsdS5ERVBUSF9TVEVOQ0lMLGIsRSksdS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih1LkZSQU1FQlVGRkVSLHUuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULHUuUkVOREVSQlVGRkVSLGEuZGVwdGhTdGVuY2lsQnVmZmVyKSksdS5iaW5kRnJhbWVidWZmZXIodS5GUkFNRUJVRkZFUixudWxsKSxhfWJpbmRGQk8oTz1udWxsKXt0aGlzLmZibz1PfXJlbmRlcih7Y2xlYXJCdWZmZXI6Tz0hMH09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITA7Y29uc3Qgdj10aGlzLmdsO2xldCBQPXRoaXMucHJvZ3JhbTtQfHwoUD10aGlzLmNyZWF0ZVByb2dyYW0oKSx0aGlzLnVzZVByb2dyYW0oUCkpLHRoaXMuZmJvJiZ2LmJpbmRGcmFtZWJ1ZmZlcih2LkZSQU1FQlVGRkVSLHRoaXMuZmJvKTtjb25zdCBpPXRoaXMub3B0aW9ucy5kZXB0aDtpJiZ2LmVuYWJsZSh2LkRFUFRIX1RFU1QpLHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUfChpP3RoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVDowKXwodGhpcy5vcHRpb25zLnN0ZW5jaWw/dGhpcy5nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ6MCkpO2NvbnN0IHU9dGhpcy5fcmVuZGVyRnJhbWVJRDt0aGlzLl9kcmF3KCksdGhpcy5mYm8mJnYuYmluZEZyYW1lYnVmZmVyKHYuRlJBTUVCVUZGRVIsbnVsbCksdGhpcy5fcmVuZGVyRnJhbWVJRD09PXUmJih0aGlzLl9yZW5kZXJGcmFtZUlEPW51bGwpfXVwZGF0ZSgpe3RoaXMuc3RhcnRSZW5kZXImJnRoaXMuX3JlbmRlckZyYW1lSUQ9PW51bGwmJih0aGlzLl9yZW5kZXJGcmFtZUlEPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKSl9fWMobSwiZGVmYXVsdE9wdGlvbnMiLHtwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITAsYXV0b1VwZGF0ZTohMCx2ZXJ0ZXhQb3NpdGlvbjoiYV92ZXJ0ZXhQb3NpdGlvbiIsdmVydGV4VGV4dHVyZUNvb3JkOiJhX3ZlcnRleFRleHR1cmVDb29yZCIsd2ViZ2wyOiExfSksYyhtLCJVQllURSIsbS5VTlNJR05FRF9CWVRFKSxjKG0sIlVTSE9SVCIsbS5VTlNJR05FRF9TSE9SVCksYyhtLCJmZXRjaFNoYWRlciIsci5mZXRjaFNoYWRlciksYyhtLCJsb2FkSW1hZ2UiLHIubG9hZEltYWdlKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwic2V0dXBXZWJHTCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjcmVhdGVQcm9ncmFtIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInBvaW50c1RvQnVmZmVyIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImxvYWRJbWFnZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJmZXRjaFNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGcseSl7Y29uc3QgbT1bIndlYmdsIiwiZXhwZXJpbWVudGFsLXdlYmdsIiwid2Via2l0LTNkIiwibW96LXdlYmdsIl07bGV0IFQ9bnVsbDtmb3IobGV0IE89MDtPPG0ubGVuZ3RoOysrTyl7dHJ5e1Q9Zy5nZXRDb250ZXh0KG1bT10seSl9Y2F0Y2h7fWlmKFQpYnJlYWt9cmV0dXJuIFR9ZnVuY3Rpb24gbihnLHkpe2NvbnN0IG09cihnLHkpO2lmKCFtKXRocm93IG5ldyBFcnJvcigiU29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgV2ViR0wuIik7cmV0dXJuIG19ZnVuY3Rpb24gcyhnLHksbSl7Y29uc3QgVD1nLmNyZWF0ZVNoYWRlcihnLlZFUlRFWF9TSEFERVIpO2lmKGcuc2hhZGVyU291cmNlKFQseSksZy5jb21waWxlU2hhZGVyKFQpLCFnLmdldFNoYWRlclBhcmFtZXRlcihULGcuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBQPWBWZXJ0ZXggc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2cuZ2V0U2hhZGVySW5mb0xvZyhUKX1gO3Rocm93IG5ldyBFcnJvcihQKX1jb25zdCBPPWcuY3JlYXRlU2hhZGVyKGcuRlJBR01FTlRfU0hBREVSKTtpZihnLnNoYWRlclNvdXJjZShPLG0pLGcuY29tcGlsZVNoYWRlcihPKSwhZy5nZXRTaGFkZXJQYXJhbWV0ZXIoTyxnLkNPTVBJTEVfU1RBVFVTKSl7Y29uc3QgUD1gRnJhZ21lbnQgc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2cuZ2V0U2hhZGVySW5mb0xvZyhPKX1gO3Rocm93IG5ldyBFcnJvcihQKX1jb25zdCB2PWcuY3JlYXRlUHJvZ3JhbSgpO2lmKGcuYXR0YWNoU2hhZGVyKHYsVCksZy5hdHRhY2hTaGFkZXIodixPKSxnLmxpbmtQcm9ncmFtKHYpLCFnLmdldFByb2dyYW1QYXJhbWV0ZXIodixnLkxJTktfU1RBVFVTKSl7Y29uc3QgUD1gU2hhZGVyIHByb2dyYW0gZmFpbGVkIHRvIGxpbmsuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zy5nZXRQcm9ncmFtSW5mb0xvZyh2KX1gO3Rocm93IG5ldyBFcnJvcihQKX1yZXR1cm4gZy5kZWxldGVTaGFkZXIoVCksZy5kZWxldGVTaGFkZXIoTyksdn1mdW5jdGlvbiBsKGcseT1GbG9hdDMyQXJyYXksbT1udWxsKXtpZihtJiYhKG0gaW5zdGFuY2VvZiB5KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJXcm9uZyBidWZmZXIgdHlwZS4iKTtpZihnPT1udWxsfHxnIGluc3RhbmNlb2YgeSlyZXR1cm4gZztpZihnWzBdPT1udWxsfHxnWzBdLmxlbmd0aD09bnVsbClyZXR1cm4gbT8obS5zZXQoZywwKSxtKTpuZXcgeShnKTtjb25zdCBUPWdbMF0ubGVuZ3RoLE89Zy5sZW5ndGg7bXx8KG09bmV3IHkoVCpPKSk7bGV0IHY9MDtmb3IobGV0IFA9MDtQPE87UCsrKWZvcihsZXQgaT0wO2k8VDtpKyspbVt2KytdPWdbUF1baV07cmV0dXJuIG19Y29uc3QgYz17fTtmdW5jdGlvbiBvKGcse3VzZUltYWdlQml0bWFwOnk9ITAsYWxpYXM6bT1udWxsfT17fSl7aWYoIWNbZ10pe2lmKHR5cGVvZiBJbWFnZT09ImZ1bmN0aW9uIil7Y29uc3QgVD1uZXcgSW1hZ2U7dHlwZW9mIGc9PSJzdHJpbmciJiYhKHR5cGVvZiBsb2NhdGlvbj09Im9iamVjdCImJi9eZmlsZTovLnRlc3QobG9jYXRpb24uaHJlZikpJiYhL15kYXRhOi8udGVzdChnKSYmKFQuY3Jvc3NPcmlnaW49ImFub255bW91cyIpLGNbZ109bmV3IFByb21pc2UoTz0+e1Qub25sb2FkPWZ1bmN0aW9uKCl7eSYmdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwPT0iZnVuY3Rpb24iP2NyZWF0ZUltYWdlQml0bWFwKFQse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4odj0+e2NbZ109dixtJiYoY1ttXT12KSxPKHYpfSk6KGNbZ109VCxtJiYoY1ttXT1UKSxPKFQpKX0sVC5zcmM9Z30pLG0mJihjW21dPWNbZ10pfWVsc2UgaWYodHlwZW9mIGZldGNoPT0iZnVuY3Rpb24iKXJldHVybiBmZXRjaChnLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkudGhlbihUPT5ULmJsb2IoKSkudGhlbihUPT5jcmVhdGVJbWFnZUJpdG1hcChULHtpbWFnZU9yaWVudGF0aW9uOiJmbGlwWSJ9KS50aGVuKE89PihjW2ddPU8sbSYmKGNbbV09TyksTykpKX1yZXR1cm4gY1tnXX1jb25zdCBmPXt9O2FzeW5jIGZ1bmN0aW9uIHgoZyl7aWYoZltnXSlyZXR1cm4gZltnXTtjb25zdCB5PWF3YWl0IGZldGNoKGcpO2lmKHkuc3RhdHVzPj0yMDAmJnkuc3RhdHVzPDMwMCl7Y29uc3QgbT1hd2FpdCB5LnRleHQoKTtyZXR1cm4gZltnXT1tLG19dGhyb3cgbmV3IEVycm9yKCJTaGFkZXIgbG9hZGVkIGVycm9yLiIpfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gdmVjNChhX3ZlcnRleFBvc2l0aW9uLCAxKTsKfWB9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWAjaWZkZWYgR0xfRVMKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4xKTsKfWB9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjNCBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gYV92ZXJ0ZXhQb3NpdGlvbjsKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7Cn1gfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMSksbj10KDI1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcz1TeW1ib2woInRyYW5zZm9ybSIpO2NsYXNzIGx7Y29uc3RydWN0b3IobyxmKXt0aGlzLmNvbnRleHQ9by5nZXRDb250ZXh0KCIyZCIpLHRoaXMub3B0aW9ucz1mLHRoaXNbc109WzEsMCwwLDEsMCwwXX1jcmVhdGVUZXh0dXJlKG8pe3JldHVybntfaW1nOm99fWFzeW5jIGxvYWRUZXh0dXJlKG8pe2NvbnN0IGY9YXdhaXQgci5kZWZhdWx0LmxvYWRJbWFnZShvLHt1c2VJbWFnZUJpdG1hcDohMX0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoZil9ZGVsZXRlVGV4dHVyZShvKXtyZXR1cm4gb31jbGVhcihvLGYseCxnKXtjb25zdCB5PXRoaXMuY29udGV4dDtvPW98fDAsZj1mfHwwLHg9eHx8eS5jYW52YXMud2lkdGgtbyxnPWd8fHkuY2FudmFzLmhlaWdodC1mLHkuY2xlYXJSZWN0KG8sZix4LGcpfWRyYXdNZXNoQ2xvdWQobyx7Y2xlYXI6Zj0hMX09e30pe2NvbnN0IHg9W107Zm9yKGxldCBnPTA7ZzxvLmFtb3VudDtnKyspe2NvbnN0IHk9by5nZXRUcmFuc2Zvcm0oZyk7bGV0IG09by5nZXRUZXh0dXJlRnJhbWUoZyk7bSYmKG09bS5faW1nKTtjb25zdCBUPW8uZ2V0RmlsdGVyKGcpLHtmaWxsOk8sc3Ryb2tlOnZ9PW8uZ2V0Q2xvdWRSR0JBKGcpO3gucHVzaCh7bWVzaDpvLm1lc2gsX2Nsb3VkT3B0aW9uczpbTyx2LG0seSxUXX0pfW8uYmVmb3JlUmVuZGVyJiZvLmJlZm9yZVJlbmRlcih0aGlzLmNvbnRleHQsbyksdGhpcy5kcmF3TWVzaGVzKHgse2NsZWFyOmYsaG9vazohMX0pLG8uYWZ0ZXJSZW5kZXImJm8uYWZ0ZXJSZW5kZXIodGhpcy5jb250ZXh0LG8pfWRyYXdNZXNoZXMobyx7Y2xlYXI6Zj0hMSxob29rOng9ITB9PXt9KXtjb25zdCBnPXRoaXMuY29udGV4dDtmJiZnLmNsZWFyUmVjdCgwLDAsZy5jYW52YXMud2lkdGgsZy5jYW52YXMuaGVpZ2h0KTtsZXQgeT1udWxsO2NvbnN0e3dpZHRoOm0saGVpZ2h0OlR9PWcuY2FudmFzLE89by5sZW5ndGg7by5mb3JFYWNoKCh2LFApPT57bGV0IGksdSxhLGgsYjt4JiZ2LmJlZm9yZVJlbmRlciYmdi5iZWZvcmVSZW5kZXIoZyx2KSx2Ll9jbG91ZE9wdGlvbnMmJihbaSx1LGEsaCxiXT12Ll9jbG91ZE9wdGlvbnMsdj12Lm1lc2gpO2xldCBFPXYuZmlsdGVyO2lmKGImJihFPUU/YCR7RX0gJHtifWA6YiksRSYmIXRoaXMuZmlsdGVyQnVmZmVyJiZ0aGlzLmZpbHRlckJ1ZmZlciE9PSExKXtjb25zdCBBPXIuZGVmYXVsdC5jcmVhdGVDYW52YXMobSxUKTtBP3RoaXMuZmlsdGVyQnVmZmVyPUEuZ2V0Q29udGV4dCgiMmQiKTp0aGlzLmZpbHRlckJ1ZmZlcj0hMX15JiZ5IT09RSYmKE9iamVjdChuLmFwcGx5RmlsdGVyKSh0aGlzLmZpbHRlckJ1ZmZlcix5KSxnLmRyYXdJbWFnZSh0aGlzLmZpbHRlckJ1ZmZlci5jYW52YXMsMCwwLG0sVCksdGhpcy5maWx0ZXJCdWZmZXIuY2xlYXJSZWN0KDAsMCxtLFQpLHk9bnVsbCksRSYmdGhpcy5maWx0ZXJCdWZmZXI/KHRoaXMuZmlsdGVyQnVmZmVyLnNhdmUoKSx0aGlzLmZpbHRlckJ1ZmZlci50cmFuc2Zvcm0oLi4udGhpc1tzXSksT2JqZWN0KG4uZHJhd01lc2gyRCkodix0aGlzLmZpbHRlckJ1ZmZlciwhMSxpLHUsYSxoKSx0aGlzLmZpbHRlckJ1ZmZlci5yZXN0b3JlKCksUD09PU8tMT8oT2JqZWN0KG4uYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLEUpLGcuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAsbSxUKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLG0sVCkpOnk9RSk6KGcuc2F2ZSgpLGcudHJhbnNmb3JtKC4uLnRoaXNbc10pLE9iamVjdChuLmRyYXdNZXNoMkQpKHYsZywhMSxpLHUsYSxoKSxnLnJlc3RvcmUoKSkseCYmdi5hZnRlclJlbmRlciYmdi5hZnRlclJlbmRlcihnLHYpfSl9c2V0VHJhbnNmb3JtKG8pe3RoaXNbc109b319fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLChmdW5jdGlvbihyKXt2YXIgbj10KDE0KSxzPXQoMjMpLGw9dCgyNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9e307ZnVuY3Rpb24gbyhtLFQpe2NvbnN0e3N0eWxlOk8sdmFyaWFudDp2LHdlaWdodDpQLHN0cmV0Y2g6aSxzaXplOnUscHhMaW5lSGVpZ2h0OmEsZmFtaWx5Omh9PW07cmV0dXJuIGk9PT0ibm9ybWFsIj9gJHtPfSAke3Z9ICR7UH0gJHt1KlR9cHgvJHthKlR9cHggJHtofWA6YCR7T30gJHt2fSAke1B9ICR7aX0gJHt1KlR9cHgvJHthKlR9cHggJHtofWB9ZnVuY3Rpb24gZihtLHtmb250OlQsZmlsbENvbG9yOk8sc3Ryb2tlQ29sb3I6dixzdHJva2VXaWR0aDpQLHJhdGlvOmk9MSx0ZXh0Q2FudmFzOnUsY2FjaGFibGU6YT0hMX0pe2xldCBoO2lmKGEpe2g9W20sVCxTdHJpbmcoTyksU3RyaW5nKHYpLFN0cmluZyhQKV0uam9pbigiIyMjIik7Y29uc3QgJD1jW2hdO2lmKCQpcmV0dXJuICR9dXx8KHU9ZygxLDEpKTtjb25zdCBiPXUuZ2V0Q29udGV4dCgiMmQiKTtiLnNhdmUoKSxiLmZvbnQ9VDtsZXR7d2lkdGg6RX09Yi5tZWFzdXJlVGV4dChtKTtiLnJlc3RvcmUoKTtjb25zdCBBPU9iamVjdChzLmRlZmF1bHQpKFQpLEw9TWF0aC5tYXgoQS5weExpbmVIZWlnaHQsQS5weEhlaWdodCoxLjEzKTsvaXRhbGljfG9ibGlxdWUvLnRlc3QoVCkmJihFKz1MKk1hdGgudGFuKDE1Kk1hdGguUEkvMTgwKSksIU8mJiF2JiYoTz0iIzAwMCIpO2NvbnN0IFM9Yi5jYW52YXMsST1NYXRoLmNlaWwoRSksRD1NYXRoLmNlaWwoTCk7Uy53aWR0aD1NYXRoLnJvdW5kKEkqaSksUy5oZWlnaHQ9TWF0aC5yb3VuZChEKmkpLGIuc2F2ZSgpLGIuZm9udD1vKEEsaSksYi50ZXh0QWxpZ249ImNlbnRlciIsYi50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgUj1TLmhlaWdodCouNStBLnB4SGVpZ2h0Ki4wNSppLEM9Uy53aWR0aCouNTtpZihPKXtpZihBcnJheS5pc0FycmF5KE8pKU89T2JqZWN0KGwuZGVmYXVsdCkoTyk7ZWxzZSBpZihPLnZlY3Rvcil7bGV0ICQ7Y29uc3R7dmVjdG9yOkgsY29sb3JzOkp9PU87SC5sZW5ndGg9PT02PyQ9Yi5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5IKTokPWIuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSCksSi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6Rn0pPT57JC5hZGRDb2xvclN0b3AocSxGKX0pLE89JH1iLmZpbGxTdHlsZT1PLGIuZmlsbFRleHQobSxDLFIpfWlmKHYpe2lmKGIubGluZVdpZHRoPVAqaSxBcnJheS5pc0FycmF5KHYpKXY9T2JqZWN0KGwuZGVmYXVsdCkodik7ZWxzZSBpZih2LnZlY3Rvcil7bGV0ICQ7Y29uc3R7dmVjdG9yOkgsY29sb3JzOkp9PXY7SC5sZW5ndGg9PT02PyQ9Yi5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5IKTokPWIuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSCksSi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6Rn0pPT57JC5hZGRDb2xvclN0b3AocSxGKX0pLHY9JH1iLnN0cm9rZVN0eWxlPXYsYi5zdHJva2VUZXh0KG0sQyxSKX1iLnJlc3RvcmUoKTtjb25zdCBqPXtpbWFnZTp1LHJlY3Q6WzAsMCxJLERdfTtyZXR1cm4gYSYmKGNbaF09aiksan1sZXQgeD0hMTtpZih0eXBlb2YgbmF2aWdhdG9yPT0ib2JqZWN0IiYmdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQ9PSJzdHJpbmciKXtjb25zdCBtPW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvY2hyb21lXC8oXGQrKS8pO20mJih4PU51bWJlcihtWzFdKTw3MCl9ZnVuY3Rpb24gZyhtLFQsTz17fSl7Y29uc3Qgdj1PLm9mZnNjcmVlbnx8IXgmJk8ub2Zmc2NyZWVuIT09ITE7bGV0IFA7cmV0dXJuIHR5cGVvZiByPCJ1IiYmdHlwZW9mIHIuY3JlYXRlQ2FudmFzPT0iZnVuY3Rpb24iP1A9ci5jcmVhdGVDYW52YXMobSxULE8pOnYmJnR5cGVvZiBPZmZzY3JlZW5DYW52YXM9PSJmdW5jdGlvbiI/UD1uZXcgT2Zmc2NyZWVuQ2FudmFzKG0sVCk6KFA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIiksUC53aWR0aD1tLFAuaGVpZ2h0PVQpLFB9Y29uc3QgeT17Y3JlYXRlQ2FudmFzOmcsY3JlYXRlVGV4dDpmLGxvYWRJbWFnZTpuLmRlZmF1bHQubG9hZEltYWdlfTtlLmRlZmF1bHQ9eX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGQsZSl7dmFyIHQ7dD1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXt0PXR8fG5ldyBGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpfWNhdGNoe3R5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiYodD13aW5kb3cpfWQuZXhwb3J0cz10fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBPfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIodixQKXtpZih0eXBlb2Ygdj09InN0cmluZyIpe2NvbnN0IGE9di50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSkkLyk7YT92PXtzaXplOnBhcnNlRmxvYXQoYVsxXSksdW5pdDphWzJdfTp2PXtzaXplOnBhcnNlSW50KHYsMTApLHVuaXQ6InB4In19bGV0e3NpemU6aSx1bml0OnV9PXY7aWYodT09PSJwdCIpaS89Ljc1O2Vsc2UgaWYodT09PSJwYyIpaSo9MTY7ZWxzZSBpZih1PT09ImluIilpKj05NjtlbHNlIGlmKHU9PT0iY20iKWkqPTk2LzIuNTQ7ZWxzZSBpZih1PT09Im1tIilpKj05Ni8yNS40O2Vsc2UgaWYodT09PSJlbSJ8fHU9PT0icmVtInx8dT09PSJleCIpe2lmKCFQJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgYT1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7UD1yKGEsMTYpfWkqPVAsdT09PSJleCImJihpLz0yKX1lbHNlIGlmKHU9PT0icSIpaSo9OTYvMjUuNC80O2Vsc2UgaWYodT09PSJ2dyJ8fHU9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBhPXU9PT0idnciP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2kqPWEvMTAwfX1lbHNlIGlmKCh1PT09InZtYXgifHx1PT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgYT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsaD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3U9PT0idm1heCI/aSo9TWF0aC5tYXgoYSxoKS8xMDA6aSo9TWF0aC5taW4oYSxoKS8xMDB9cmV0dXJuIGl9Y29uc3Qgbj0iYm9sZHxib2xkZXJ8bGlnaHRlcnxbMS05XTAwIixzPSJpdGFsaWN8b2JsaXF1ZSIsbD0ic21hbGwtY2FwcyIsYz0idWx0cmEtY29uZGVuc2VkfGV4dHJhLWNvbmRlbnNlZHxjb25kZW5zZWR8c2VtaS1jb25kZW5zZWR8c2VtaS1leHBhbmRlZHxleHBhbmRlZHxleHRyYS1leHBhbmRlZHx1bHRyYS1leHBhbmRlZCIsbz0icHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWlufCUiLGY9YCcoW14nXSspJ3wiKFteIl0rKSJ8KFtcXHctXXxb5LiALem+pV0pK2AseD1uZXcgUmVnRXhwKGAoJHtufSkgK2AsImkiKSxnPW5ldyBSZWdFeHAoYCgke3N9KSArYCwiaSIpLHk9bmV3IFJlZ0V4cChgKCR7bH0pICtgLCJpIiksbT1uZXcgUmVnRXhwKGAoJHtjfSkgK2AsImkiKSxUPW5ldyBSZWdFeHAoIihbXFxkXFwuXSspKCIrbysiKSg/OlxcLyhbXFxkXFwuXSspKCIrbysiKSk/ICooKD86IitmKyIpKCAqLCAqKD86IitmKyIpKSopIik7ZnVuY3Rpb24gTyh2LFApe2NvbnN0IGk9VC5leGVjKHYpO2lmKCFpKXJldHVybjtjb25zdCB1PXBhcnNlRmxvYXQoaVszXSksYT17d2VpZ2h0OiJub3JtYWwiLHN0eWxlOiJub3JtYWwiLHN0cmV0Y2g6Im5vcm1hbCIsdmFyaWFudDoibm9ybWFsIixzaXplOnBhcnNlRmxvYXQoaVsxXSksdW5pdDppWzJdLGxpbmVIZWlnaHQ6TnVtYmVyLmlzRmluaXRlKHUpP3U6dm9pZCAwLGxpbmVIZWlnaHRVbml0OmlbNF0sZmFtaWx5OmlbNV0ucmVwbGFjZSgvICosICovZywiLCIpfSxoPXYuc3Vic3RyaW5nKDAsaS5pbmRleCksYj14LmV4ZWMoaCksRT1nLmV4ZWMoaCksQT15LmV4ZWMoaCksTD1tLmV4ZWMoaCk7cmV0dXJuIGImJihhLndlaWdodD1iWzFdKSxFJiYoYS5zdHlsZT1FWzFdKSxBJiYoYS52YXJpYW50PUFbMV0pLEwmJihhLnN0cmV0Y2g9TFsxXSksYS5weEhlaWdodD1yKHtzaXplOmEuc2l6ZSx1bml0OmEudW5pdH0sUCksYS5weExpbmVIZWlnaHQ9cih7c2l6ZTphLmxpbmVIZWlnaHR8fGEuc2l6ZSx1bml0OmEubGluZUhlaWdodFVuaXR8fGEudW5pdH0sUCksYX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihuKXtyZXR1cm5gcmdiYSgke24ubWFwKChzLGwpPT5sPDM/TWF0aC5yb3VuZChzKjI1NSk6cykuam9pbigpfSlgfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiYXBwbHlGaWx0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZHJhd01lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMSksbj10KDI0KSxzPXQoMjMpLGw9dCgyNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGMoeCxnKXtjb25zdCB5PXguY2FudmFzO3guc2F2ZSgpLHguZmlsdGVyPWcseC5kcmF3SW1hZ2UoeSwwLDAseS53aWR0aCx5LmhlaWdodCkseC5yZXN0b3JlKCl9ZnVuY3Rpb24gbyh4LGcpe2NvbnN0IHk9L3JnYmFcKChcZCspLChcZCspLChcZCspLChcZCspXCkvO3g9eC5tYXRjaCh5KS5zbGljZSgxLDUpLm1hcChOdW1iZXIpLGc9Zy5tYXRjaCh5KS5zbGljZSgxLDUpLm1hcChOdW1iZXIpO2NvbnN0IG09W10sVD1nWzNdO2ZvcihsZXQgTz0wO088NDtPKyspbVtPXT1PYmplY3QobC5taXgpKHhbT10sZ1tPXSxUKTtyZXR1cm5gcmdiYSgke20uam9pbigpfSlgfWZ1bmN0aW9uIGYoeCxnLHk9ITAsbT1udWxsLFQ9bnVsbCxPPW51bGwsdj1udWxsKXtnLnNhdmUoKTtsZXQgUD0hMSxpPSExO2lmKGcuZ2xvYmFsQWxwaGE9eC5nZXRPcGFjaXR5KCkseC5fdXBkYXRlTWF0cml4JiZ4LnRyYW5zZm9ybVNjYWxlL3guY29udG91cnMuc2NhbGU+MS41JiZ4LmFjY3VyYXRlKHgudHJhbnNmb3JtU2NhbGUpLHgubGluZVdpZHRoKXtsZXQgaD14LmdyYWRpZW50JiZ4LmdyYWRpZW50LnN0cm9rZTtpZihoKXtjb25zdHt2ZWN0b3I6Yixjb2xvcnM6RX09aDtpZihiLmxlbmd0aD09PTYpaD1nLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLmIpO2Vsc2UgaWYoYi5sZW5ndGg9PT00KWg9Zy5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5iKTtlbHNlIGlmKGIubGVuZ3RoPT09MyloPWcuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5iKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtFLmZvckVhY2goKHtvZmZzZXQ6QSxjb2xvcjpMfSk9PntsZXQgUz1PYmplY3Qobi5kZWZhdWx0KShMKTtUJiYoUz1vKFMsVCkpLGguYWRkQ29sb3JTdG9wKEEsUyl9KSxnLnN0cm9rZVN0eWxlPWgsUD0hMH1lbHNlIHguc3Ryb2tlU3R5bGUmJihUP2cuc3Ryb2tlU3R5bGU9byh4LnN0cm9rZVN0eWxlLFQpOmcuc3Ryb2tlU3R5bGU9eC5zdHJva2VTdHlsZSxQPSEwKX1QJiYoZy5saW5lV2lkdGg9eC5saW5lV2lkdGgsZy5saW5lSm9pbj14LmxpbmVKb2luLGcubGluZUNhcD14LmxpbmVDYXAsZy5taXRlckxpbWl0PXgubWl0ZXJMaW1pdCx4LmxpbmVEYXNoJiYoZy5zZXRMaW5lRGFzaCh4LmxpbmVEYXNoKSx4LmxpbmVEYXNoT2Zmc2V0JiYoZy5saW5lRGFzaE9mZnNldD14LmxpbmVEYXNoT2Zmc2V0KSkpO2xldCB1PXguZ3JhZGllbnQmJnguZ3JhZGllbnQuZmlsbDtpZih1KXtjb25zdHt2ZWN0b3I6aCxjb2xvcnM6Yn09dTtpZihoLmxlbmd0aD09PTYpdT1nLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLmgpO2Vsc2UgaWYoaC5sZW5ndGg9PT00KXU9Zy5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5oKTtlbHNlIGlmKGgubGVuZ3RoPT09Myl1PWcuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5oKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtiLmZvckVhY2goKHtvZmZzZXQ6RSxjb2xvcjpBfSk9PntsZXQgTD1PYmplY3Qobi5kZWZhdWx0KShBKTtUJiYoTD1vKEwsVCkpLHUuYWRkQ29sb3JTdG9wKEUsTCl9KSxnLmZpbGxTdHlsZT11LGk9ITB9ZWxzZSB4LmZpbGxTdHlsZSYmKG0/Zy5maWxsU3R5bGU9byh4LmZpbGxTdHlsZSxtKTpnLmZpbGxTdHlsZT14LmZpbGxTdHlsZSxpPSEwKTtpZih2JiZnLnRyYW5zZm9ybSguLi52KSxnLnRyYW5zZm9ybSguLi54LnRyYW5zZm9ybU1hdHJpeCkseC5jbGlwUGF0aCl7Y29uc3QgaD14LmNsaXBQYXRoLGI9bmV3IFBhdGgyRChoKTtnLmNsaXAoYil9Y29uc3QgYT14LmNvbnRvdXJzLmxlbmd0aDtpZih4LmNvbnRvdXJzLmZvckVhY2goKGgsYik9Pntjb25zdCBFPWgubGVuZ3RoLEE9RT4xJiZyLnZlYzIuZXF1YWxzKGhbMF0saFtFLTFdKSxMPWI9PT1hLTEmJngudGV4dHVyZTtpZihoJiZFPjApe2lmKGl8fFB8fEwpe2cuYmVnaW5QYXRoKCksZy5tb3ZlVG8oLi4uaFswXSk7Zm9yKGxldCBTPTE7UzxFO1MrKylTPT09RS0xJiZBP2cuY2xvc2VQYXRoKCk6Zy5saW5lVG8oLi4uaFtTXSl9aWYoaSYmZy5maWxsKHguZmlsbFJ1bGUpLEwpe2cuc2F2ZSgpLGcuY2xpcCgpO2xldHtpbWFnZTpTLG9wdGlvbnM6SX09eC50ZXh0dXJlO2lmKE8mJihTPU8pLEkucmVwZWF0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCBpbWFnZSByZXBlYXQgeWV0LiIpLFMuZm9udCl7SS5zY2FsZSYmY29uc29sZS53YXJuKCJDb250ZXh0IDJEIG5vdCBzdXBwb3J0ZWQgdGV4dCBzY2FsZSB5ZXQuIiksSS5zcmNSZWN0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNyY1JlY3QgeWV0LiIpO2xldHtmb250OkQsZmlsbENvbG9yOlIsc3Ryb2tlQ29sb3I6QyxzdHJva2VXaWR0aDpqLHRleHQ6JH09UzshUiYmIUMmJihSPSIjMDAwIiksQXJyYXkuaXNBcnJheShSKSYmKFI9T2JqZWN0KG4uZGVmYXVsdCkoUikpLEFycmF5LmlzQXJyYXkoQykmJihDPU9iamVjdChuLmRlZmF1bHQpKEMpKSxnLmZvbnQ9RDtjb25zdHt3aWR0aDpIfT1nLm1lYXN1cmVUZXh0KCQpLEo9T2JqZWN0KHMuZGVmYXVsdCkoRCkscT1NYXRoLm1heChKLnB4TGluZUhlaWdodCxKLnB4SGVpZ2h0KjEuMTMpO2cudGV4dEFsaWduPSJjZW50ZXIiLGcudGV4dEJhc2VsaW5lPSJtaWRkbGUiO2NvbnN0IEY9SS5yZWN0LEc9RlswXStxKi41K0oucHhIZWlnaHQqLjA2LFo9RlsxXStIKi41O0ZbMl0hPW51bGwmJmcuc2NhbGUoRlsyXS9ILEZbM10vcSksUiYmKGcuZmlsbFN0eWxlPVIsZy5maWxsVGV4dCgkLFosRykpLEMmJihnLmxpbmVXaWR0aD1qLGcuc3Ryb2tlU3R5bGU9QyxnLnN0cm9rZVRleHQoJCxaLEcpKX1lbHNle2xldCBEPUkucmVjdDtjb25zdCBSPUkuc3JjUmVjdDtJLnNjYWxlJiYoRD1bMCwwLGcuY2FudmFzLndpZHRoLGcuY2FudmFzLmhlaWdodF0pLEkucm90YXRlZCYmRCYmKEQ9Wy1EWzFdLERbMF0sRFszXSxEWzJdXSksUiYmKEQ9RHx8WzAsMCxSWzJdLFJbM11dKSxJLnJvdGF0ZWQmJihnLnRyYW5zbGF0ZSgwLEQ/RFsyXTpTLndpZHRoKSxnLnJvdGF0ZSgtLjUqTWF0aC5QSSkpLFI/Zy5kcmF3SW1hZ2UoUywuLi5SLC4uLkQpOkQ/Zy5kcmF3SW1hZ2UoUywuLi5EKTpnLmRyYXdJbWFnZShTLDAsMCl9Zy5yZXN0b3JlKCl9UCYmZy5zdHJva2UoKX19KSxnLnJlc3RvcmUoKSx5KXtjb25zdCBoPXguZmlsdGVyO2gmJmMoZyxoKX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjbGFtcCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJtaXgiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwidHJhbnNmb3JtUG9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihsLGMsbyl7cmV0dXJuIGM+byYmKFtjLG9dPVtvLGNdKSxsPGM/YzpsPm8/bzpsfWZ1bmN0aW9uIG4obCxjLG8pe3JldHVybiBsKigxLW8pK2Mqb31mdW5jdGlvbiBzKGwsYyl7Y29uc3RbbyxmXT1sO3JldHVybltvKmNbMF0rZipjWzJdK2NbNF0sbypjWzFdK2YqY1szXStjWzVdXX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KTt2YXIgcj10KDI4KSxuPXQoMjkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBzKGYseCxnKXtjb25zdCB5PWYudW5pZm9ybXN8fHt9LG09eC51bmlmb3Jtc3x8e307aWYoeS51X3RleFNhbXBsZXImJm0udV90ZXhTYW1wbGVyJiZ5LnVfdGV4U2FtcGxlciE9PW0udV90ZXhTYW1wbGVyKXJldHVybiExO2NvbnN0IFQ9T2JqZWN0LmtleXMoeSksTz1PYmplY3Qua2V5cyhtKSx2PVQuaW5kZXhPZigidV90ZXhTYW1wbGVyIiksUD1PLmluZGV4T2YoInVfdGV4U2FtcGxlciIpO2lmKHY+PTAmJlQuc3BsaWNlKHYsMSksUD49MCYmTy5zcGxpY2UoUCwxKSxULmxlbmd0aCE9PU8ubGVuZ3RoKXJldHVybiExO2NvbnN0IGk9VC5ldmVyeSh1PT57Y29uc3QgYT15W3VdLGg9bVt1XTtpZihhPT09aClyZXR1cm4hMDtpZihhLmxlbmd0aCYmaC5sZW5ndGgmJmEubGVuZ3RoPT09aC5sZW5ndGgpe2ZvcihsZXQgYj0wO2I8YS5sZW5ndGg7YisrKWlmKGFbYl0hPT1oW2JdKXJldHVybiExO3JldHVybiEwfXJldHVybiExfSk7aWYoaSl7aWYoeS51X3RleFNhbXBsZXImJiFtLnVfdGV4U2FtcGxlcil4LnNldFRleHR1cmUoeS51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pO2Vsc2UgaWYoIXkudV90ZXhTYW1wbGVyJiZtLnVfdGV4U2FtcGxlcilmb3IobGV0IHU9MDt1PGcubGVuZ3RoO3UrKylnW3VdLnNldFRleHR1cmUobS51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pfXJldHVybiBpfWNvbnN0IGw9e307ZnVuY3Rpb24gYyhmLHgpe2lmKGYubGVuZ3RoKXtjb25zdCBnPU9iamVjdChyLmRlZmF1bHQpKGYsbCk7cmV0dXJuIGcuZW5hYmxlQmxlbmQ9eCxmWzBdLmZpbHRlckNhbnZhcyYmKGcuZmlsdGVyQ2FudmFzPSEwKSxnLnBhY2tJbmRleD1mWzBdLnBhY2tJbmRleCxnLnBhY2tMZW5ndGg9Zi5sZW5ndGgsZy5iZWZvcmVSZW5kZXI9ZlswXS5iZWZvcmVSZW5kZXIsZy5wYXNzPWZbMF0ucGFzcyxnLmFmdGVyUmVuZGVyPWZbZi5sZW5ndGgtMV0uYWZ0ZXJSZW5kZXIsZi5sZW5ndGg9MCxnfX1mdW5jdGlvbipvKGYseCxnPSExKXtjb25zdCB5PVtdLG09Zi5vcHRpb25zLmJ1ZmZlclNpemU7bGV0IFQ9MCxPPSExO2ZvcihsZXQgdj0wO3Y8eC5sZW5ndGg7disrKXtjb25zdCBQPXhbdl07aWYoUCBpbnN0YW5jZW9mIG4uZGVmYXVsdCl5Lmxlbmd0aCYmKHlpZWxkIGMoeSxPKSksVD0wLE89ITEseWllbGQgUDtlbHNle2NvbnN0IGk9UC5tZXNoRGF0YTtpZihpLmNsaXBQYXRoJiYhaS51bmlmb3Jtcy51X2NsaXBTYW1wbGVyKXtjb25zdCBhPWYuY3JlYXRlVGV4dHVyZShpLmNsaXBQYXRoKTtpLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI9YX1sZXQgdT0wO2lmKCghZ3x8IVAuY2FuSWdub3JlKCkpJiZpJiZpLnBvc2l0aW9ucy5sZW5ndGgpe1AucGFja0luZGV4PXY7Y29uc3QgYT1QLmZpbHRlckNhbnZhcztpZih1PWkucG9zaXRpb25zLmxlbmd0aCxhfHxUK3U+bSl5Lmxlbmd0aCYmKHlpZWxkIGMoeSxPKSksVD0wLE89ITE7ZWxzZSBpZihUKXtjb25zdCBoPXlbeS5sZW5ndGgtMV07aCYmKGguZmlsdGVyQ2FudmFzfHxoLmFmdGVyUmVuZGVyfHxQLmJlZm9yZVJlbmRlcnx8aC5wYXNzLmxlbmd0aHx8UC5wYXNzLmxlbmd0aHx8aC5wcm9ncmFtIT09UC5wcm9ncmFtfHwhcyhoLFAseSkpJiYoeWllbGQgYyh5LE8pLFQ9MCxPPSExKX15LnB1c2goUCksTz1PfHxQLmVuYWJsZUJsZW5kLFQrPXV9dj09PXgubGVuZ3RoLTEmJnkubGVuZ3RoJiYoeWllbGQgYyh5LE8pKX19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPXtVTlNJR05FRF9CWVRFOlVpbnQ4QXJyYXksVU5TSUdORURfU0hPUlQ6VWludDE2QXJyYXksQllURTpJbnQ4QXJyYXksU0hPUlQ6SW50MTZBcnJheSxGTE9BVDpGbG9hdDMyQXJyYXl9O2Z1bmN0aW9uIG4obCxjKXtsZXQgbz0wLGY9MCx4PTAsZz0wLHk9MCxtPTAsVD0wO2NvbnN0IE89bFswXS5wcm9ncmFtO2ZvcihsZXQgdj0wO3Y8bC5sZW5ndGg7disrKXtjb25zdCBQPWxbdl0ubWVzaERhdGE7aWYoUCl7VCs9UC5wb3NpdGlvbnMubGVuZ3RoO2NvbnN0IGk9UC5wb3NpdGlvbnNbMF0ubGVuZ3RoO28rPVAucG9zaXRpb25zLmxlbmd0aCppLGYrPVAuY2VsbHMubGVuZ3RoKjMsbSs9UC5hdHRyaWJ1dGVzLmFfY29sb3IubGVuZ3RoKjQ7Y29uc3QgdT1QLnRleHR1cmVDb29yZDt1JiYoeCs9dS5sZW5ndGgqdVswXS5sZW5ndGgpO2NvbnN0IGE9UC5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDthJiYoZys9YS5sZW5ndGgqNCk7Y29uc3QgaD1QLmF0dHJpYnV0ZXMuYV9jbGlwVVY7aCYmKHkrPWgubGVuZ3RoKjIpfX1pZigoIWMucG9zaXRpb25zfHxjLnBvc2l0aW9ucy5sZW5ndGg8bykmJihjLnBvc2l0aW9ucz1uZXcgRmxvYXQzMkFycmF5KG8pKSwoIWMuY2VsbHN8fGMuY2VsbHMubGVuZ3RoPGYpJiYoYy5jZWxscz1uZXcgVWludDE2QXJyYXkoZikpLHgmJighYy50ZXh0dXJlQ29vcmR8fGMudGV4dHVyZUNvb3JkLmxlbmd0aDx4KSYmKGMudGV4dHVyZUNvb3JkPW5ldyBGbG9hdDMyQXJyYXkoeCkpLCghYy5hX2NvbG9yfHxjLmFfY29sb3IubGVuZ3RoPG0pJiYoYy5hX2NvbG9yPW5ldyBVaW50OEFycmF5KG0pKSxnJiYoIWMuYV9zb3VyY2VSZWN0fHxjLmFfc291cmNlUmVjdC5sZW5ndGg8ZykmJihjLmFfc291cmNlUmVjdD1uZXcgRmxvYXQzMkFycmF5KGcpKSx5JiYoIWMuYV9jbGlwVVZ8fGMuYV9jbGlwVVYubGVuZ3RoPHkpJiYoYy5hX2NsaXBVVj1uZXcgRmxvYXQzMkFycmF5KHkpKSxPKXtjb25zdCB2PU9iamVjdC5lbnRyaWVzKE8uX2F0dHJpYnV0ZSksUD1PLl9hdHRyaWJPcHRzfHx7fTtmb3IobGV0IGk9MDtpPHYubGVuZ3RoO2krKyl7Y29uc3RbdSxhXT12W2ldO2lmKHUhPT0iYV9jb2xvciImJnUhPT0iYV9zb3VyY2VSZWN0IiYmYSE9PSJpZ25vcmVkIil7Y29uc3QgaD1QW3VdP1BbdV0udHlwZToiRkxPQVQiLGI9cltoXSxFPWEuc2l6ZSpUOyghY1t1XXx8Y1t1XS5sZW5ndGg8RSkmJihjW3VdPW5ldyBiKEUpKX19fXJldHVybiBjfWZ1bmN0aW9uIHMobCxjKXtsZXQgbz1bXSxmPVtdLHg9W10sZz1bXSx5PVtdLG09W10sVD0wLE89MDtjb25zdCB2PWxbMF0/bFswXS51bmlmb3Jtc3x8e306e30sUD1sWzBdP2xbMF0ucHJvZ3JhbTpudWxsO2MmJihuKGwsYyksZj1jLmNlbGxzLG89Yy5wb3NpdGlvbnMseD1jLnRleHR1cmVDb29yZCxnPWMuYV9jb2xvcix5PWMuYV9zb3VyY2VSZWN0LG09Yy5hX2NsaXBVVik7bGV0IGk9ITEsdT0hMTtjb25zdCBhPXt9O2ZvcihsZXQgYj0wO2I8bC5sZW5ndGg7YisrKXtsZXQgRT1sW2JdO2lmKEUpe2lmKEUubWVzaERhdGEmJihFPUUubWVzaERhdGEpLGMpe2NvbnN0IEw9RS5wb3NpdGlvbnM7Zm9yKGxldCBTPTA7UzxMLmxlbmd0aDtTKyspe2NvbnN0IEk9TFtTXSxEPTMqKFQrUyk7Zm9yKGxldCBSPTA7UjxJLmxlbmd0aDtSKyspb1tEK1JdPUlbUl19fWVsc2Ugby5wdXNoKC4uLkUucG9zaXRpb25zKTtjb25zdCBBPUUuY2VsbHM7Zm9yKGxldCBMPTA7TDxBLmxlbmd0aDtMKyspe2NvbnN0IFM9QVtMXTtpZihjKXtjb25zdCBJPTMqKE8rTCk7ZltJXT1TWzBdK1QsZltJKzFdPVNbMV0rVCxmW0krMl09U1syXStUfWVsc2UgZi5wdXNoKFtTWzBdK1QsU1sxXStULFNbMl0rVF0pfWlmKGMpe2NvbnN0IEw9RS5hdHRyaWJ1dGVzLmFfY29sb3I7Zm9yKGxldCBTPTA7UzxMLmxlbmd0aDtTKyspe2NvbnN0IEk9TFtTXSxEPTQqKFQrUyk7Z1tEXT1JWzBdLGdbRCsxXT1JWzFdLGdbRCsyXT1JWzJdLGdbRCszXT1JWzNdfX1lbHNlIGcucHVzaCguLi5FLmF0dHJpYnV0ZXMuYV9jb2xvcik7aWYoRS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdClpZihpPSEwLGMpe2NvbnN0IEw9RS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDtmb3IobGV0IFM9MDtTPEwubGVuZ3RoO1MrKyl7Y29uc3QgST1MW1NdLEQ9NCooVCtTKTt5W0RdPUlbMF0seVtEKzFdPUlbMV0seVtEKzJdPUlbMl0seVtEKzNdPUlbM119fWVsc2UgeS5wdXNoKC4uLkUuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3QpO2lmKEUuYXR0cmlidXRlcy5hX2NsaXBVVilpZih1PSEwLGMpe2NvbnN0IEw9RS5hdHRyaWJ1dGVzLmFfY2xpcFVWO2ZvcihsZXQgUz0wO1M8TC5sZW5ndGg7UysrKXtjb25zdCBJPUxbU10sRD0yKihUK1MpO21bRF09SVswXSxtW0QrMV09SVsxXX19ZWxzZSBtLnB1c2goLi4uRS5hdHRyaWJ1dGVzLmFfY2xpcFVWKTtpZihFLnRleHR1cmVDb29yZClpZihjKXtjb25zdCBMPUUudGV4dHVyZUNvb3JkO2ZvcihsZXQgUz0wO1M8TC5sZW5ndGg7UysrKXtjb25zdCBJPUxbU10sRD0zKihUK1MpO2ZvcihsZXQgUj0wO1I8SS5sZW5ndGg7UisrKXhbRCtSXT1JW1JdfX1lbHNlIHgucHVzaCguLi5FLnRleHR1cmVDb29yZCk7aWYoUCl7Y29uc3QgTD1PYmplY3QuZW50cmllcyhQLl9hdHRyaWJ1dGUpO2ZvcihsZXQgUz0wO1M8TC5sZW5ndGg7UysrKXtjb25zdFtJLERdPUxbU107aWYoSSE9PSJhX2NvbG9yIiYmSSE9PSJhX3NvdXJjZVJlY3QiJiZEIT09Imlnbm9yZWQiKWlmKGFbSV09W10sYyl7YVtJXT1jW0ldO2NvbnN0IFI9RS5hdHRyaWJ1dGVzW0ldLEM9UlswXS5sZW5ndGg7Zm9yKGxldCBqPTA7ajxSLmxlbmd0aDtqKyspe2NvbnN0ICQ9UltqXSxIPUMqKFQraik7Zm9yKGxldCBKPTA7SjwkLmxlbmd0aDtKKyspYVtJXVtIK0pdPSRbSl19fWVsc2UgYVtJXS5wdXNoKC4uLkUuYXR0cmlidXRlc1tJXSl9fVQrPUUucG9zaXRpb25zLmxlbmd0aCxPKz1FLmNlbGxzLmxlbmd0aH19YS5hX2NvbG9yPWcsaSYmeSYmeS5sZW5ndGg+MCYmKGEuYV9zb3VyY2VSZWN0PXkpO2NvbnN0IGg9e3Bvc2l0aW9uczpvLGNlbGxzOmYsYXR0cmlidXRlczphLHVuaWZvcm1zOnYsY2VsbHNDb3VudDpPKjMscHJvZ3JhbTpQfTtyZXR1cm4geCYmeC5sZW5ndGgmJihoLnRleHR1cmVDb29yZD14KSx1JiZtLmxlbmd0aD4wJiYoYS5hX2NsaXBVVj1tKSxofX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKTt2YXIgcj10KDEpLG49dCgzMCkscz10KDI2KSxsPXQoMzEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBjKGEsaCl7dmFyIGI9T2JqZWN0LmtleXMoYSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEU9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhhKTtoJiYoRT1FLmZpbHRlcihmdW5jdGlvbihBKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLEEpLmVudW1lcmFibGV9KSksYi5wdXNoLmFwcGx5KGIsRSl9cmV0dXJuIGJ9ZnVuY3Rpb24gbyhhKXtmb3IodmFyIGg9MTtoPGFyZ3VtZW50cy5sZW5ndGg7aCsrKXt2YXIgYj1hcmd1bWVudHNbaF0hPW51bGw/YXJndW1lbnRzW2hdOnt9O2glMj9jKE9iamVjdChiKSwhMCkuZm9yRWFjaChmdW5jdGlvbihFKXtmKGEsRSxiW0VdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGEsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYikpOmMoT2JqZWN0KGIpKS5mb3JFYWNoKGZ1bmN0aW9uKEUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLEUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiLEUpKX0pfXJldHVybiBhfWZ1bmN0aW9uIGYoYSxoLGIpe3JldHVybiBoIGluIGE/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsaCx7dmFsdWU6YixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmFbaF09YixhfWNvbnN0IHg9U3ltYm9sKCJtZXNoIiksZz1TeW1ib2woImNvdW50IikseT1TeW1ib2woImJsZW5kIiksbT1TeW1ib2woImZpbHRlciIpLFQ9U3ltYm9sKCJ0ZXh0dXJlcyIpLE89U3ltYm9sKCJ0ZXh0dXJlT3B0aW9ucyIpLHY9U3ltYm9sKCJjbG91ZENvbG9yIiksUD1TeW1ib2woImNsb3VkRmlsdGVyIiksaT1TeW1ib2woImJ1ZmZlciIpO2Z1bmN0aW9uIHUoYSxoPW51bGwpe2NvbnN0IGI9bmV3IEZsb2F0MzJBcnJheSgzKmEpLEU9bmV3IEZsb2F0MzJBcnJheSgzKmEpLEE9bmV3IEZsb2F0MzJBcnJheSg0KmEpLEw9bmV3IEZsb2F0MzJBcnJheSg0KmEpLFM9bmV3IEZsb2F0MzJBcnJheSg0KmEpLEk9bmV3IEZsb2F0MzJBcnJheSg0KmEpLEQ9bmV3IEZsb2F0MzJBcnJheSg0KmEpLFI9bmV3IFVpbnQ4QXJyYXkoYSksQz1uZXcgVWludDhBcnJheSg0KmEpLGo9bmV3IFVpbnQ4QXJyYXkoNCphKTtyZXR1cm4gaCYmKGIuc2V0KGgudHJhbnNmb3JtMCwwKSxFLnNldChoLnRyYW5zZm9ybTEsMCksQS5zZXQoaC5jb2xvcjAsMCksTC5zZXQoaC5jb2xvcjEsMCksUy5zZXQoaC5jb2xvcjIsMCksSS5zZXQoaC5jb2xvcjMsMCksRC5zZXQoaC5jb2xvcjQsMCksUi5zZXQoaC5mcmFtZUluZGV4LDApLEMuc2V0KGguZmlsbENvbG9yLDApLGouc2V0KGguc3Ryb2tlQ29sb3IsMCkpLHtidWZmZXJTaXplOmEsdHJhbnNmb3JtMDpiLHRyYW5zZm9ybTE6RSxjb2xvcjA6QSxjb2xvcjE6TCxjb2xvcjI6Uyxjb2xvcjM6SSxjb2xvcjQ6RCxmcmFtZUluZGV4OlIsZmlsbENvbG9yOkMsc3Ryb2tlQ29sb3I6an19ZS5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKGEsaD0xLHtidWZmZXI6Yj0xZTN9PXt9KXtiPU1hdGgubWF4KGIsaCksdGhpc1tnXT1oLHRoaXNbeF09YSx0aGlzW2ldPXUoYiksdGhpc1tUXT1bXSx0aGlzW21dPVtdLHRoaXNbdl09ITEsdGhpc1tQXT0hMSx0aGlzW3ldPSExLHRoaXMuaW5pdEJ1ZmZlcigpfWluaXRCdWZmZXIoYT0wKXtjb25zdCBoPXRoaXNbZ107Zm9yKGxldCBiPWE7YjxoO2IrKyl0aGlzW2ldLnRyYW5zZm9ybTAuc2V0KFsxLDAsMF0sYiozKSx0aGlzW2ldLnRyYW5zZm9ybTEuc2V0KFswLDEsMF0sYiozKSx0aGlzW2ldLmZyYW1lSW5kZXguc2V0KFstMV0sYiksdGhpc1tpXS5maWxsQ29sb3Iuc2V0KFswLDAsMCwwXSxiKjQpLHRoaXNbaV0uc3Ryb2tlQ29sb3Iuc2V0KFswLDAsMCwwXSxiKjQpLHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0oYixudWxsKX1nZXQgYnVmZmVyU2l6ZSgpe3JldHVybiB0aGlzW2ldLmJ1ZmZlclNpemV9Z2V0IG1lc2goKXtyZXR1cm4gdGhpc1t4XX1zZXQgbWVzaChhKXt0aGlzW3hdPWEsdGhpc1tUXSYmdGhpcy5zZXRUZXh0dXJlRnJhbWVzKHRoaXNbVF0sdGhpc1tPXSl9Z2V0IGhhc0Nsb3VkQ29sb3IoKXtyZXR1cm4gdGhpc1t2XX1nZXQgaGFzQ2xvdWRGaWx0ZXIoKXtyZXR1cm4gdGhpc1tQXX1fZ2V0RmlsdGVyKGEpe3JldHVybiB0aGlzW21dW2FdPXRoaXNbbV1bYV18fFtdLHRoaXNbbV1bYV19Z2V0RmlsdGVyKGEpe3JldHVybiB0aGlzLl9nZXRGaWx0ZXIoYSkuam9pbigiICIpfWdldCBlbmFibGVCbGVuZCgpe3JldHVybiB0aGlzW3hdLmVuYWJsZUJsZW5kfHx0aGlzW3ldfWNhbklnbm9yZSgpe3JldHVybiB0aGlzW3hdLmNhbklnbm9yZSgpfWRlbGV0ZShhKXtpZihhPj10aGlzW2ddfHxhPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Y29uc3R7dHJhbnNmb3JtMDpoLHRyYW5zZm9ybTE6Yixjb2xvcjA6RSxjb2xvcjE6QSxjb2xvcjI6TCxjb2xvcjM6Uyxjb2xvcjQ6SSxmcmFtZUluZGV4OkQsZmlsbENvbG9yOlIsc3Ryb2tlQ29sb3I6Q309dGhpc1tpXTtoLnNldChoLnN1YmFycmF5KDMqKGErMSkpLDMqYSksYi5zZXQoYi5zdWJhcnJheSgzKihhKzEpKSwzKmEpLEUuc2V0KEUuc3ViYXJyYXkoNCooYSsxKSksNCphKSxBLnNldChBLnN1YmFycmF5KDQqKGErMSkpLDQqYSksTC5zZXQoTC5zdWJhcnJheSg0KihhKzEpKSw0KmEpLFMuc2V0KFMuc3ViYXJyYXkoNCooYSsxKSksNCphKSxJLnNldChJLnN1YmFycmF5KDQqKGErMSkpLDQqYSksRC5zZXQoRC5zdWJhcnJheShhKzEpLGEpLFIuc2V0KFIuc3ViYXJyYXkoNCooYSsxKSksNCphKSxDLnNldChDLnN1YmFycmF5KDQqKGErMSkpLDQqYSk7Zm9yKGNvbnN0IGogaW4gdGhpc1ttXSlqPT09YT9kZWxldGUgdGhpc1ttXVtqXTpqPmEmJih0aGlzW21dW2otMV09dGhpc1ttXVtqXSxkZWxldGUgdGhpc1ttXVtqXSk7dGhpc1tnXS0tfXNldENvbG9yVHJhbnNmb3JtKGEsaCl7aWYoYT49dGhpc1tnXXx8YTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2EqPTQ7Y29uc3R7Y29sb3IwOmIsY29sb3IxOkUsY29sb3IyOkEsY29sb3IzOkwsY29sb3I0OlN9PXRoaXNbaV07cmV0dXJuIGghPW51bGw/KGIuc2V0KFtoWzBdLGhbNV0saFsxMF0saFsxNV1dLGEpLEUuc2V0KFtoWzFdLGhbNl0saFsxMV0saFsxNl1dLGEpLEEuc2V0KFtoWzJdLGhbN10saFsxMl0saFsxN11dLGEpLEwuc2V0KFtoWzNdLGhbOF0saFsxM10saFsxOF1dLGEpLFMuc2V0KFtoWzRdLGhbOV0saFsxNF0saFsxOV1dLGEpLHRoaXNbeV09dGhpc1t5XXx8aFsxOF08MSx0aGlzW1BdPSEwKTooYi5zZXQoWzEsMCwwLDBdLGEpLEUuc2V0KFswLDEsMCwwXSxhKSxBLnNldChbMCwwLDEsMF0sYSksTC5zZXQoWzAsMCwwLDFdLGEpLFMuc2V0KFswLDAsMCwwXSxhKSksdGhpc31nZXRDb2xvclRyYW5zZm9ybShhKXtpZihhPj10aGlzW2ddfHxhPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7YSo9NDtjb25zdHtjb2xvcjA6aCxjb2xvcjE6Yixjb2xvcjI6RSxjb2xvcjM6QSxjb2xvcjQ6TH09dGhpc1tpXTtyZXR1cm5baFthXSxiW2FdLEVbYV0sQVthXSxMW2FdLGhbYSsxXSxiW2ErMV0sRVthKzFdLEFbYSsxXSxMW2ErMV0saFthKzJdLGJbYSsyXSxFW2ErMl0sQVthKzJdLExbYSsyXSxoW2ErM10sYlthKzNdLEVbYSszXSxBW2ErM10sTFthKzNdXX10cmFuc2Zvcm1Db2xvcihhLGgpe2xldCBiPXRoaXMuZ2V0Q29sb3JUcmFuc2Zvcm0oYSk7cmV0dXJuIGI9T2JqZWN0KG4ubXVsdGlwbHkpKGIsaCksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShhLGIpLHRoaXN9c2V0RmlsbENvbG9yKGEsaCl7aWYoYT49dGhpc1tnXXx8YTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBoPT0ic3RyaW5nIiYmKGg9T2JqZWN0KGwuZGVmYXVsdCkoaCkpLGhbM10+MCYmKHRoaXNbdl09ITApLHRoaXNbaV0uZmlsbENvbG9yLnNldChoLm1hcChiPT5NYXRoLnJvdW5kKDI1NSpiKSksNCphKX1zZXRTdHJva2VDb2xvcihhLGgpe2lmKGE+PXRoaXNbZ118fGE8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTt0eXBlb2YgaD09InN0cmluZyImJihoPU9iamVjdChsLmRlZmF1bHQpKGgpKSxoWzNdPjAmJih0aGlzW3ZdPSEwKSx0aGlzW2ldLnN0cm9rZUNvbG9yLnNldChoLm1hcChiPT5NYXRoLnJvdW5kKDI1NSpiKSksNCphKX1nZXRDbG91ZFJHQkEoYSl7aWYoYT49dGhpc1tnXXx8YTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2EqPTQ7Y29uc3R7ZmlsbENvbG9yOmgsc3Ryb2tlQ29sb3I6Yn09dGhpc1tpXSxFPVtoW2FdLGhbYSsxXSxoW2ErMl0saFthKzNdXSxBPVtiW2FdLGJbYSsxXSxiW2ErMl0sYlthKzNdXTtyZXR1cm4gRVszXS89MjU1LEFbM10vPTI1NSx7ZmlsbDpgcmdiYSgke0Uuam9pbigpfSlgLHN0cm9rZTpgcmdiYSgke0Euam9pbigpfSlgfX1ncmF5c2NhbGUoYSxoKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGEsT2JqZWN0KG4uZ3JheXNjYWxlKShoKSksdGhpcy5fZ2V0RmlsdGVyKGEpLnB1c2goYGdyYXlzY2FsZSgkezEwMCpofSUpYCl9YnJpZ2h0bmVzcyhhLGgpe3RoaXMudHJhbnNmb3JtQ29sb3IoYSxPYmplY3Qobi5icmlnaHRuZXNzKShoKSksdGhpcy5fZ2V0RmlsdGVyKGEpLnB1c2goYGJyaWdodG5lc3MoJHsxMDAqaH0lKWApfXNhdHVyYXRlKGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLnNhdHVyYXRlKShoKSksdGhpcy5fZ2V0RmlsdGVyKGEpLnB1c2goYHNhdHVyYXRlKCR7MTAwKmh9JSlgKX1jb250cmFzdChhLGgpe3RoaXMudHJhbnNmb3JtQ29sb3IoYSxPYmplY3Qobi5jb250cmFzdCkoaCkpLHRoaXMuX2dldEZpbHRlcihhKS5wdXNoKGBjb250cmFzdCgkezEwMCpofSUpYCl9aW52ZXJ0KGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLmludmVydCkoaCkpLHRoaXMuX2dldEZpbHRlcihhKS5wdXNoKGBpbnZlcnQoJHsxMDAqaH0lKWApfXNlcGlhKGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLnNlcGlhKShoKSksdGhpcy5fZ2V0RmlsdGVyKGEpLnB1c2goYHNlcGlhKCR7MTAwKmh9JSlgKX1vcGFjaXR5KGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLm9wYWNpdHkpKGgpKSx0aGlzLl9nZXRGaWx0ZXIoYSkucHVzaChgb3BhY2l0eSgkezEwMCpofSUpYCl9aHVlUm90YXRlKGEsaCl7dGhpcy50cmFuc2Zvcm1Db2xvcihhLE9iamVjdChuLmh1ZVJvdGF0ZSkoaCkpLHRoaXMuX2dldEZpbHRlcihhKS5wdXNoKGBodWUtcm90YXRlKCR7aH1kZWcpYCl9c2V0VHJhbnNmb3JtKGEsaCl7aWYoYT49dGhpc1tnXXx8YTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2EqPTMsaD09bnVsbCYmKGg9WzEsMCwwLDEsMCwwXSk7Y29uc3R7dHJhbnNmb3JtMDpiLHRyYW5zZm9ybTE6RX09dGhpc1tpXTtyZXR1cm4gYi5zZXQoW2hbMF0saFsyXSxoWzRdXSxhKSxFLnNldChbaFsxXSxoWzNdLGhbNV1dLGEpLHRoaXN9Z2V0VHJhbnNmb3JtKGEpe2lmKGE+PXRoaXNbZ118fGE8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTthKj0zO2NvbnN0e3RyYW5zZm9ybTA6aCx0cmFuc2Zvcm0xOmJ9PXRoaXNbaV07cmV0dXJuW2hbYV0sYlthXSxoW2ErMV0sYlthKzFdLGhbYSsyXSxiW2ErMl1dfWdldFRleHR1cmVGcmFtZShhKXtyZXR1cm4gdGhpc1tUXVt0aGlzW2ldLmZyYW1lSW5kZXhbYV1dfXNldFRleHR1cmVGcmFtZXMoYT1bXSxoPXt9KXtpZihhLmxlbmd0aD4xMil0aHJvdyBuZXcgRXJyb3IoIk1heCBmcmFtZXMgZXhjZWVkLiBBbGxvdyAxMiBmcmFtZXMuIik7YS5sZW5ndGgmJnRoaXNbeF0uc2V0VGV4dHVyZShhWzBdLGgpLHRoaXNbVF09YSx0aGlzW09dPWh9c2V0RnJhbWVJbmRleChhLGgpe2lmKGE+PXRoaXNbZ118fGE8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdCBiPXRoaXNbVF0ubGVuZ3RoO2lmKGI8PTApdGhyb3cgbmV3IEVycm9yKCJObyBmcmFtZXMiKTt0aGlzW2ldLmZyYW1lSW5kZXhbYV09aCVifWdldCBhbW91bnQoKXtyZXR1cm4gdGhpc1tnXX1zZXQgYW1vdW50KGEpe2NvbnN0IGg9dGhpc1tnXTthIT09aCYmKGE+dGhpc1tpXS5idWZmZXJTaXplJiYodGhpc1tpXT11KE1hdGgubWF4KGEsdGhpc1tpXS5idWZmZXJTaXplKzFlMyksdGhpc1tpXSkpLHRoaXNbZ109YSxhPmgmJnRoaXMuaW5pdEJ1ZmZlcihoKSl9Z2V0IG1lc2hEYXRhKCl7Y29uc3R7YXR0cmlidXRlczphLGNlbGxzOmgscG9zaXRpb25zOmIsdGV4dHVyZUNvb3JkOkUsdW5pZm9ybXM6QX09dGhpc1t4XS5tZXNoRGF0YSxMPXRoaXNbVF0sUz17YXR0cmlidXRlczpvKHt9LGEpLGNlbGxzOmgscG9zaXRpb25zOmIsdGV4dHVyZUNvb3JkOkUsdW5pZm9ybXM6byh7fSxBKSxpbnN0YW5jZUNvdW50OnRoaXNbZ10sZW5hYmxlQmxlbmQ6dGhpcy5lbmFibGVCbGVuZH07TC5sZW5ndGgmJkwuZm9yRWFjaCgoRyxaKT0+e1MudW5pZm9ybXNbYHVfdGV4RnJhbWUke1p9YF09R30pO2NvbnN0e3RyYW5zZm9ybTA6SSx0cmFuc2Zvcm0xOkQsY29sb3IwOlIsY29sb3IxOkMsY29sb3IyOmosY29sb3IzOiQsY29sb3I0OkgsZmlsbENvbG9yOkosc3Ryb2tlQ29sb3I6cSxmcmFtZUluZGV4OkZ9PXRoaXNbaV07cmV0dXJuIHRoaXNbeF0udW5pZm9ybXMudV90ZXhTYW1wbGVyJiYoUy5hdHRyaWJ1dGVzLmFfZnJhbWVJbmRleD17ZGF0YTpGLGRpdmlzb3I6MX0pLFMuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTA9e2RhdGE6SSxkaXZpc29yOjF9LFMuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTE9e2RhdGE6RCxkaXZpc29yOjF9LFMuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQwPXtkYXRhOlIsZGl2aXNvcjoxfSxTLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMT17ZGF0YTpDLGRpdmlzb3I6MX0sUy5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDI9e2RhdGE6aixkaXZpc29yOjF9LFMuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQzPXtkYXRhOiQsZGl2aXNvcjoxfSxTLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkND17ZGF0YTpILGRpdmlzb3I6MX0sdGhpcy5oYXNDbG91ZENvbG9yJiYoUy5hdHRyaWJ1dGVzLmFfZmlsbENsb3VkQ29sb3I9e2RhdGE6SixkaXZpc29yOjF9LFMuYXR0cmlidXRlcy5hX3N0cm9rZUNsb3VkQ29sb3I9e2RhdGE6cSxkaXZpc29yOjF9KSxTfXNldFByb2dyYW0oYSl7dGhpc1t4XS5zZXRQcm9ncmFtKGEpfWdldCBwcm9ncmFtKCl7cmV0dXJuIHRoaXNbeF0ucHJvZ3JhbX10cmFuc2Zvcm0oYSxoKXtjb25zdCBiPXRoaXMuZ2V0VHJhbnNmb3JtKGEpO3JldHVybiBoPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLGIsaCksdGhpcy5zZXRUcmFuc2Zvcm0oYSxoKSx0aGlzfXRyYW5zbGF0ZShhLFtoLGJdKXtsZXQgRT1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBFPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxFLFtoLGJdKSx0aGlzLnRyYW5zZm9ybShhLEUpfXJvdGF0ZShhLGgsW2IsRV09WzAsMF0pe2xldCBBPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEE9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEsW2IsRV0pLEE9ci5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEsaCksQT1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQSxbLWIsLUVdKSx0aGlzLnRyYW5zZm9ybShhLEEpfXNjYWxlKGEsW2gsYj1oXSxbRSxBXT1bMCwwXSl7bGV0IEw9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxbRSxBXSksTD1yLm1hdDJkLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFtoLGJdKSxMPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFstRSwtQV0pLHRoaXMudHJhbnNmb3JtKGEsTCl9c2tldyhhLFtoLGI9aF0sW0UsQV09WzAsMF0pe2xldCBMPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEw9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEwsW0UsQV0pLEw9ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxyLm1hdDJkLmZyb21WYWx1ZXMoMSxNYXRoLnRhbihiKSxNYXRoLnRhbihoKSwxLDAsMCkpLEw9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEwsWy1FLC1BXSksdGhpcy50cmFuc2Zvcm0oYSxMKX1pc1BvaW50Q29sbGlzaW9uKGEsW2gsYl0sRT0iYm90aCIpe2NvbnN0IEE9dGhpcy5nZXRUcmFuc2Zvcm0oYSksTD1PYmplY3Qocy50cmFuc2Zvcm1Qb2ludCkoW2gsYl0sci5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEpKTtyZXR1cm4gdGhpc1t4XS5pc1BvaW50Q29sbGlzaW9uKC4uLkwsRSl9aXNQb2ludEluRmlsbChhLFtoLGJdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGEsW2gsYl0sImZpbGwiKX1pc1BvaW50SW5TdHJva2UoYSxbaCxiXSl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihhLFtoLGJdLCJzdHJva2UiKX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJncmF5c2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiYnJpZ2h0bmVzcyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzYXR1cmF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJjb250cmFzdCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwic2VwaWEiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwib3BhY2l0eSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJodWVSb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihtLFQpe2NvbnN0IE89W10sdj1tWzBdLFA9bVsxXSxpPW1bMl0sdT1tWzNdLGE9bVs0XSxoPW1bNV0sYj1tWzZdLEU9bVs3XSxBPW1bOF0sTD1tWzldLFM9bVsxMF0sST1tWzExXSxEPW1bMTJdLFI9bVsxM10sQz1tWzE0XSxqPW1bMTVdLCQ9bVsxNl0sSD1tWzE3XSxKPW1bMThdLHE9bVsxOV07bGV0IEY9VFswXSxHPVRbMV0sWj1UWzJdLHR0PVRbM10sZXQ9VFs0XTtyZXR1cm4gT1swXT1GKnYrRypoK1oqUyt0dCpqLE9bMV09RipQK0cqYitaKkkrdHQqJCxPWzJdPUYqaStHKkUrWipEK3R0KkgsT1szXT1GKnUrRypBK1oqUit0dCpKLE9bNF09RiphK0cqTCtaKkMrdHQqcStldCxGPVRbNV0sRz1UWzZdLFo9VFs3XSx0dD1UWzhdLGV0PVRbOV0sT1s1XT1GKnYrRypoK1oqUyt0dCpqLE9bNl09RipQK0cqYitaKkkrdHQqJCxPWzddPUYqaStHKkUrWipEK3R0KkgsT1s4XT1GKnUrRypBK1oqUit0dCpKLE9bOV09RiphK0cqTCtaKkMrdHQqcStldCxGPVRbMTBdLEc9VFsxMV0sWj1UWzEyXSx0dD1UWzEzXSxldD1UWzE0XSxPWzEwXT1GKnYrRypoK1oqUyt0dCpqLE9bMTFdPUYqUCtHKmIrWipJK3R0KiQsT1sxMl09RippK0cqRStaKkQrdHQqSCxPWzEzXT1GKnUrRypBK1oqUit0dCpKLE9bMTRdPUYqYStHKkwrWipDK3R0KnErZXQsRj1UWzE1XSxHPVRbMTZdLFo9VFsxN10sdHQ9VFsxOF0sZXQ9VFsxOV0sT1sxNV09Rip2K0cqaCtaKlMrdHQqaixPWzE2XT1GKlArRypiK1oqSSt0dCokLE9bMTddPUYqaStHKkUrWipEK3R0KkgsT1sxOF09Rip1K0cqQStaKlIrdHQqSixPWzE5XT1GKmErRypMK1oqQyt0dCpxK2V0LE99ZnVuY3Rpb24gcyhtKXttPU9iamVjdChyLmNsYW1wKSgwLDEsbSk7Y29uc3QgVD0uMjEyNiptLE89LjcxNTIqbSx2PS4wNzIyKm07cmV0dXJuW1QrMS1tLE8sdiwwLDAsVCxPKzEtbSx2LDAsMCxULE8sdisxLW0sMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gbChtKXtyZXR1cm5bbSwwLDAsMCwwLDAsbSwwLDAsMCwwLDAsbSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBjKG0pe2NvbnN0IFQ9LjIxMjYqKDEtbSksTz0uNzE1MiooMS1tKSx2PS4wNzIyKigxLW0pO3JldHVybltUK20sTyx2LDAsMCxULE8rbSx2LDAsMCxULE8sdittLDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIG8obSl7Y29uc3QgVD0uNSooMS1tKTtyZXR1cm5bbSwwLDAsMCxULDAsbSwwLDAsVCwwLDAsbSwwLFQsMCwwLDAsMSwwXX1mdW5jdGlvbiBmKG0pe2NvbnN0IFQ9MS0yKm07cmV0dXJuW1QsMCwwLDAsbSwwLFQsMCwwLG0sMCwwLFQsMCxtLDAsMCwwLDEsMF19ZnVuY3Rpb24geChtKXtyZXR1cm5bMS0uNjA3Km0sLjc2OSptLC4xODkqbSwwLDAsLjM0OSptLDEtLjMxNCptLC4xNjgqbSwwLDAsLjI3MiptLC41MzQqbSwxLS44NjkqbSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBnKG0pe3JldHVyblsxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCxtLDBdfWZ1bmN0aW9uIHkobSl7Y29uc3QgVD1tLzE4MCpNYXRoLlBJLE89TWF0aC5jb3MoVCksdj1NYXRoLnNpbihUKSxQPS4yMTI2LGk9LjcxNTIsdT0uMDcyMjtyZXR1cm5bUCtPKigxLVApK3YqLVAsaStPKi1pK3YqLWksdStPKi11K3YqKDEtdSksMCwwLFArTyotUCt2Ki4xNDMsaStPKigxLWkpK3YqLjE0LHUrTyotdSt2Ki0uMjgzLDAsMCxQK08qLVArdiotKDEtUCksaStPKi1pK3YqaSx1K08qKDEtdSkrdip1LDAsMCwwLDAsMCwxLDBdfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciByPXQoMzIpLG49dC5uKHIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBzKGwpe2NvbnN0IGM9bigpKGwpO2lmKCFjfHwhYy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5bY1swXS8yNTUsY1sxXS8yNTUsY1syXS8yNTUsY1szXV19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgzMyksbj10KDM3KSxzPXQoMzkpO2QuZXhwb3J0cz1mdW5jdGlvbihjKXt2YXIgbyxmPXIoYyk7cmV0dXJuIGYuc3BhY2U/KG89QXJyYXkoMyksb1swXT1zKGYudmFsdWVzWzBdLDAsMjU1KSxvWzFdPXMoZi52YWx1ZXNbMV0sMCwyNTUpLG9bMl09cyhmLnZhbHVlc1syXSwwLDI1NSksZi5zcGFjZVswXT09PSJoIiYmKG89bi5yZ2IobykpLG8ucHVzaChzKGYuYWxwaGEsMCwxKSksbyk6W119fSxmdW5jdGlvbihkLGUsdCl7KGZ1bmN0aW9uKHIpe3ZhciBuPXQoMzQpLHM9dCgzNSksbD10KDM2KTtkLmV4cG9ydHM9bzt2YXIgYz17cmVkOjAsb3JhbmdlOjYwLHllbGxvdzoxMjAsZ3JlZW46MTgwLGJsdWU6MjQwLHB1cnBsZTozMDB9O2Z1bmN0aW9uIG8oZil7dmFyIHgsZz1bXSx5PTEsbTtpZih0eXBlb2YgZj09InN0cmluZyIpaWYobltmXSlnPW5bZl0uc2xpY2UoKSxtPSJyZ2IiO2Vsc2UgaWYoZj09PSJ0cmFuc3BhcmVudCIpeT0wLG09InJnYiIsZz1bMCwwLDBdO2Vsc2UgaWYoL14jW0EtRmEtZjAtOV0rJC8udGVzdChmKSl7dmFyIFQ9Zi5zbGljZSgxKSxPPVQubGVuZ3RoLHY9Tzw9NDt5PTEsdj8oZz1bcGFyc2VJbnQoVFswXStUWzBdLDE2KSxwYXJzZUludChUWzFdK1RbMV0sMTYpLHBhcnNlSW50KFRbMl0rVFsyXSwxNildLE89PT00JiYoeT1wYXJzZUludChUWzNdK1RbM10sMTYpLzI1NSkpOihnPVtwYXJzZUludChUWzBdK1RbMV0sMTYpLHBhcnNlSW50KFRbMl0rVFszXSwxNikscGFyc2VJbnQoVFs0XStUWzVdLDE2KV0sTz09PTgmJih5PXBhcnNlSW50KFRbNl0rVFs3XSwxNikvMjU1KSksZ1swXXx8KGdbMF09MCksZ1sxXXx8KGdbMV09MCksZ1syXXx8KGdbMl09MCksbT0icmdiIn1lbHNlIGlmKHg9L14oKD86cmdifGhzW2x2Yl18aHdifGNteWs/fHh5W3p5XXxncmF5fGxhYnxsY2h1P3Y/fFtseV11dnxsbXMpYT8pXHMqXCgoW15cKV0qKVwpLy5leGVjKGYpKXt2YXIgUD14WzFdLGk9UD09PSJyZ2IiLFQ9UC5yZXBsYWNlKC9hJC8sIiIpO209VDt2YXIgTz1UPT09ImNteWsiPzQ6VD09PSJncmF5Ij8xOjM7Zz14WzJdLnRyaW0oKS5zcGxpdCgvXHMqLFxzKi8pLm1hcChmdW5jdGlvbihiLEUpe2lmKC8lJC8udGVzdChiKSlyZXR1cm4gRT09PU8/cGFyc2VGbG9hdChiKS8xMDA6VD09PSJyZ2IiP3BhcnNlRmxvYXQoYikqMjU1LzEwMDpwYXJzZUZsb2F0KGIpO2lmKFRbRV09PT0iaCIpe2lmKC9kZWckLy50ZXN0KGIpKXJldHVybiBwYXJzZUZsb2F0KGIpO2lmKGNbYl0hPT12b2lkIDApcmV0dXJuIGNbYl19cmV0dXJuIHBhcnNlRmxvYXQoYil9KSxQPT09VCYmZy5wdXNoKDEpLHk9aXx8Z1tPXT09PXZvaWQgMD8xOmdbT10sZz1nLnNsaWNlKDAsTyl9ZWxzZSBmLmxlbmd0aD4xMCYmL1swLTldKD86XHN8XC8pLy50ZXN0KGYpJiYoZz1mLm1hdGNoKC8oWzAtOV0rKS9nKS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIHBhcnNlRmxvYXQoYSl9KSxtPWYubWF0Y2goLyhbYS16XSkvaWcpLmpvaW4oIiIpLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoIWlzTmFOKGYpKW09InJnYiIsZz1bZj4+PjE2LChmJjY1MjgwKT4+PjgsZiYyNTVdO2Vsc2UgaWYocyhmKSl7dmFyIHU9bChmLnIsZi5yZWQsZi5SLG51bGwpO3UhPT1udWxsPyhtPSJyZ2IiLGc9W3UsbChmLmcsZi5ncmVlbixmLkcpLGwoZi5iLGYuYmx1ZSxmLkIpXSk6KG09ImhzbCIsZz1bbChmLmgsZi5odWUsZi5IKSxsKGYucyxmLnNhdHVyYXRpb24sZi5TKSxsKGYubCxmLmxpZ2h0bmVzcyxmLkwsZi5iLGYuYnJpZ2h0bmVzcyldKSx5PWwoZi5hLGYuYWxwaGEsZi5vcGFjaXR5LDEpLGYub3BhY2l0eSE9bnVsbCYmKHkvPTEwMCl9ZWxzZShBcnJheS5pc0FycmF5KGYpfHxyLkFycmF5QnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcmJkFycmF5QnVmZmVyLmlzVmlldyhmKSkmJihnPVtmWzBdLGZbMV0sZlsyXV0sbT0icmdiIix5PWYubGVuZ3RoPT09ND9mWzNdOjEpO3JldHVybntzcGFjZTptLHZhbHVlczpnLGFscGhhOnl9fX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9e2FsaWNlYmx1ZTpbMjQwLDI0OCwyNTVdLGFudGlxdWV3aGl0ZTpbMjUwLDIzNSwyMTVdLGFxdWE6WzAsMjU1LDI1NV0sYXF1YW1hcmluZTpbMTI3LDI1NSwyMTJdLGF6dXJlOlsyNDAsMjU1LDI1NV0sYmVpZ2U6WzI0NSwyNDUsMjIwXSxiaXNxdWU6WzI1NSwyMjgsMTk2XSxibGFjazpbMCwwLDBdLGJsYW5jaGVkYWxtb25kOlsyNTUsMjM1LDIwNV0sYmx1ZTpbMCwwLDI1NV0sYmx1ZXZpb2xldDpbMTM4LDQzLDIyNl0sYnJvd246WzE2NSw0Miw0Ml0sYnVybHl3b29kOlsyMjIsMTg0LDEzNV0sY2FkZXRibHVlOls5NSwxNTgsMTYwXSxjaGFydHJldXNlOlsxMjcsMjU1LDBdLGNob2NvbGF0ZTpbMjEwLDEwNSwzMF0sY29yYWw6WzI1NSwxMjcsODBdLGNvcm5mbG93ZXJibHVlOlsxMDAsMTQ5LDIzN10sY29ybnNpbGs6WzI1NSwyNDgsMjIwXSxjcmltc29uOlsyMjAsMjAsNjBdLGN5YW46WzAsMjU1LDI1NV0sZGFya2JsdWU6WzAsMCwxMzldLGRhcmtjeWFuOlswLDEzOSwxMzldLGRhcmtnb2xkZW5yb2Q6WzE4NCwxMzQsMTFdLGRhcmtncmF5OlsxNjksMTY5LDE2OV0sZGFya2dyZWVuOlswLDEwMCwwXSxkYXJrZ3JleTpbMTY5LDE2OSwxNjldLGRhcmtraGFraTpbMTg5LDE4MywxMDddLGRhcmttYWdlbnRhOlsxMzksMCwxMzldLGRhcmtvbGl2ZWdyZWVuOls4NSwxMDcsNDddLGRhcmtvcmFuZ2U6WzI1NSwxNDAsMF0sZGFya29yY2hpZDpbMTUzLDUwLDIwNF0sZGFya3JlZDpbMTM5LDAsMF0sZGFya3NhbG1vbjpbMjMzLDE1MCwxMjJdLGRhcmtzZWFncmVlbjpbMTQzLDE4OCwxNDNdLGRhcmtzbGF0ZWJsdWU6WzcyLDYxLDEzOV0sZGFya3NsYXRlZ3JheTpbNDcsNzksNzldLGRhcmtzbGF0ZWdyZXk6WzQ3LDc5LDc5XSxkYXJrdHVycXVvaXNlOlswLDIwNiwyMDldLGRhcmt2aW9sZXQ6WzE0OCwwLDIxMV0sZGVlcHBpbms6WzI1NSwyMCwxNDddLGRlZXBza3libHVlOlswLDE5MSwyNTVdLGRpbWdyYXk6WzEwNSwxMDUsMTA1XSxkaW1ncmV5OlsxMDUsMTA1LDEwNV0sZG9kZ2VyYmx1ZTpbMzAsMTQ0LDI1NV0sZmlyZWJyaWNrOlsxNzgsMzQsMzRdLGZsb3JhbHdoaXRlOlsyNTUsMjUwLDI0MF0sZm9yZXN0Z3JlZW46WzM0LDEzOSwzNF0sZnVjaHNpYTpbMjU1LDAsMjU1XSxnYWluc2Jvcm86WzIyMCwyMjAsMjIwXSxnaG9zdHdoaXRlOlsyNDgsMjQ4LDI1NV0sZ29sZDpbMjU1LDIxNSwwXSxnb2xkZW5yb2Q6WzIxOCwxNjUsMzJdLGdyYXk6WzEyOCwxMjgsMTI4XSxncmVlbjpbMCwxMjgsMF0sZ3JlZW55ZWxsb3c6WzE3MywyNTUsNDddLGdyZXk6WzEyOCwxMjgsMTI4XSxob25leWRldzpbMjQwLDI1NSwyNDBdLGhvdHBpbms6WzI1NSwxMDUsMTgwXSxpbmRpYW5yZWQ6WzIwNSw5Miw5Ml0saW5kaWdvOls3NSwwLDEzMF0saXZvcnk6WzI1NSwyNTUsMjQwXSxraGFraTpbMjQwLDIzMCwxNDBdLGxhdmVuZGVyOlsyMzAsMjMwLDI1MF0sbGF2ZW5kZXJibHVzaDpbMjU1LDI0MCwyNDVdLGxhd25ncmVlbjpbMTI0LDI1MiwwXSxsZW1vbmNoaWZmb246WzI1NSwyNTAsMjA1XSxsaWdodGJsdWU6WzE3MywyMTYsMjMwXSxsaWdodGNvcmFsOlsyNDAsMTI4LDEyOF0sbGlnaHRjeWFuOlsyMjQsMjU1LDI1NV0sbGlnaHRnb2xkZW5yb2R5ZWxsb3c6WzI1MCwyNTAsMjEwXSxsaWdodGdyYXk6WzIxMSwyMTEsMjExXSxsaWdodGdyZWVuOlsxNDQsMjM4LDE0NF0sbGlnaHRncmV5OlsyMTEsMjExLDIxMV0sbGlnaHRwaW5rOlsyNTUsMTgyLDE5M10sbGlnaHRzYWxtb246WzI1NSwxNjAsMTIyXSxsaWdodHNlYWdyZWVuOlszMiwxNzgsMTcwXSxsaWdodHNreWJsdWU6WzEzNSwyMDYsMjUwXSxsaWdodHNsYXRlZ3JheTpbMTE5LDEzNiwxNTNdLGxpZ2h0c2xhdGVncmV5OlsxMTksMTM2LDE1M10sbGlnaHRzdGVlbGJsdWU6WzE3NiwxOTYsMjIyXSxsaWdodHllbGxvdzpbMjU1LDI1NSwyMjRdLGxpbWU6WzAsMjU1LDBdLGxpbWVncmVlbjpbNTAsMjA1LDUwXSxsaW5lbjpbMjUwLDI0MCwyMzBdLG1hZ2VudGE6WzI1NSwwLDI1NV0sbWFyb29uOlsxMjgsMCwwXSxtZWRpdW1hcXVhbWFyaW5lOlsxMDIsMjA1LDE3MF0sbWVkaXVtYmx1ZTpbMCwwLDIwNV0sbWVkaXVtb3JjaGlkOlsxODYsODUsMjExXSxtZWRpdW1wdXJwbGU6WzE0NywxMTIsMjE5XSxtZWRpdW1zZWFncmVlbjpbNjAsMTc5LDExM10sbWVkaXVtc2xhdGVibHVlOlsxMjMsMTA0LDIzOF0sbWVkaXVtc3ByaW5nZ3JlZW46WzAsMjUwLDE1NF0sbWVkaXVtdHVycXVvaXNlOls3MiwyMDksMjA0XSxtZWRpdW12aW9sZXRyZWQ6WzE5OSwyMSwxMzNdLG1pZG5pZ2h0Ymx1ZTpbMjUsMjUsMTEyXSxtaW50Y3JlYW06WzI0NSwyNTUsMjUwXSxtaXN0eXJvc2U6WzI1NSwyMjgsMjI1XSxtb2NjYXNpbjpbMjU1LDIyOCwxODFdLG5hdmFqb3doaXRlOlsyNTUsMjIyLDE3M10sbmF2eTpbMCwwLDEyOF0sb2xkbGFjZTpbMjUzLDI0NSwyMzBdLG9saXZlOlsxMjgsMTI4LDBdLG9saXZlZHJhYjpbMTA3LDE0MiwzNV0sb3JhbmdlOlsyNTUsMTY1LDBdLG9yYW5nZXJlZDpbMjU1LDY5LDBdLG9yY2hpZDpbMjE4LDExMiwyMTRdLHBhbGVnb2xkZW5yb2Q6WzIzOCwyMzIsMTcwXSxwYWxlZ3JlZW46WzE1MiwyNTEsMTUyXSxwYWxldHVycXVvaXNlOlsxNzUsMjM4LDIzOF0scGFsZXZpb2xldHJlZDpbMjE5LDExMiwxNDddLHBhcGF5YXdoaXA6WzI1NSwyMzksMjEzXSxwZWFjaHB1ZmY6WzI1NSwyMTgsMTg1XSxwZXJ1OlsyMDUsMTMzLDYzXSxwaW5rOlsyNTUsMTkyLDIwM10scGx1bTpbMjIxLDE2MCwyMjFdLHBvd2RlcmJsdWU6WzE3NiwyMjQsMjMwXSxwdXJwbGU6WzEyOCwwLDEyOF0scmViZWNjYXB1cnBsZTpbMTAyLDUxLDE1M10scmVkOlsyNTUsMCwwXSxyb3N5YnJvd246WzE4OCwxNDMsMTQzXSxyb3lhbGJsdWU6WzY1LDEwNSwyMjVdLHNhZGRsZWJyb3duOlsxMzksNjksMTldLHNhbG1vbjpbMjUwLDEyOCwxMTRdLHNhbmR5YnJvd246WzI0NCwxNjQsOTZdLHNlYWdyZWVuOls0NiwxMzksODddLHNlYXNoZWxsOlsyNTUsMjQ1LDIzOF0sc2llbm5hOlsxNjAsODIsNDVdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLHNreWJsdWU6WzEzNSwyMDYsMjM1XSxzbGF0ZWJsdWU6WzEwNiw5MCwyMDVdLHNsYXRlZ3JheTpbMTEyLDEyOCwxNDRdLHNsYXRlZ3JleTpbMTEyLDEyOCwxNDRdLHNub3c6WzI1NSwyNTAsMjUwXSxzcHJpbmdncmVlbjpbMCwyNTUsMTI3XSxzdGVlbGJsdWU6WzcwLDEzMCwxODBdLHRhbjpbMjEwLDE4MCwxNDBdLHRlYWw6WzAsMTI4LDEyOF0sdGhpc3RsZTpbMjE2LDE5MSwyMTZdLHRvbWF0bzpbMjU1LDk5LDcxXSx0dXJxdW9pc2U6WzY0LDIyNCwyMDhdLHZpb2xldDpbMjM4LDEzMCwyMzhdLHdoZWF0OlsyNDUsMjIyLDE3OV0sd2hpdGU6WzI1NSwyNTUsMjU1XSx3aGl0ZXNtb2tlOlsyNDUsMjQ1LDI0NV0seWVsbG93OlsyNTUsMjU1LDBdLHllbGxvd2dyZWVuOlsxNTQsMjA1LDUwXX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO2QuZXhwb3J0cz1mdW5jdGlvbihuKXt2YXIgcztyZXR1cm4gci5jYWxsKG4pPT09IltvYmplY3QgT2JqZWN0XSImJihzPU9iamVjdC5nZXRQcm90b3R5cGVPZihuKSxzPT09bnVsbHx8cz09PU9iamVjdC5nZXRQcm90b3R5cGVPZih7fSkpfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWlmKGFyZ3VtZW50c1t0XSE9PXZvaWQgMClyZXR1cm4gYXJndW1lbnRzW3RdfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMzgpO2QuZXhwb3J0cz17bmFtZToiaHNsIixtaW46WzAsMCwwXSxtYXg6WzM2MCwxMDAsMTAwXSxjaGFubmVsOlsiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyJdLGFsaWFzOlsiSFNMIl0scmdiOmZ1bmN0aW9uKG4pe3ZhciBzPW5bMF0vMzYwLGw9blsxXS8xMDAsYz1uWzJdLzEwMCxvLGYseCxnLHk7aWYobD09PTApcmV0dXJuIHk9YyoyNTUsW3kseSx5XTtjPC41P2Y9YyooMStsKTpmPWMrbC1jKmwsbz0yKmMtZixnPVswLDAsMF07Zm9yKHZhciBtPTA7bTwzO20rKyl4PXMrMS8zKi0obS0xKSx4PDA/eCsrOng+MSYmeC0tLDYqeDwxP3k9bysoZi1vKSo2Kng6Mip4PDE/eT1mOjMqeDwyP3k9bysoZi1vKSooMi8zLXgpKjY6eT1vLGdbbV09eSoyNTU7cmV0dXJuIGd9fSxyLmhzbD1mdW5jdGlvbihuKXt2YXIgcz1uWzBdLzI1NSxsPW5bMV0vMjU1LGM9blsyXS8yNTUsbz1NYXRoLm1pbihzLGwsYyksZj1NYXRoLm1heChzLGwsYykseD1mLW8sZyx5LG07cmV0dXJuIGY9PT1vP2c9MDpzPT09Zj9nPShsLWMpL3g6bD09PWY/Zz0yKyhjLXMpL3g6Yz09PWYmJihnPTQrKHMtbCkveCksZz1NYXRoLm1pbihnKjYwLDM2MCksZzwwJiYoZys9MzYwKSxtPShvK2YpLzIsZj09PW8/eT0wOm08PS41P3k9eC8oZitvKTp5PXgvKDItZi1vKSxbZyx5KjEwMCxtKjEwMF19fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXtuYW1lOiJyZ2IiLG1pbjpbMCwwLDBdLG1heDpbMjU1LDI1NSwyNTVdLGNoYW5uZWw6WyJyZWQiLCJncmVlbiIsImJsdWUiXSxhbGlhczpbIlJHQiJdfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9dDtmdW5jdGlvbiB0KHIsbixzKXtyZXR1cm4gbjxzP3I8bj9uOnI+cz9zOnI6cjxzP3M6cj5uP246cn19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDQxKSxuPXQubihyKSxzPXQoNDIpLGw9dC5uKHMpLGM9dCg0Myksbz10Lm4oYyksZj10KDQ0KSx4PXQoNDYpLGc9dC5uKHgpLHk9dCg1MyksbT10KDU1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgVD1TeW1ib2woImNvbnRvdXJzIiksTz1TeW1ib2woInBhdGgiKSx2PVN5bWJvbCgic2ltcGxpZnkiKSxQPVN5bWJvbCgic2NhbGUiKSxpPTIqTWF0aC5QSTtjbGFzcyB1e2NvbnN0cnVjdG9yKGg9e30pe3R5cGVvZiBoPT0ic3RyaW5nIiYmKGg9e3BhdGg6aH0pLGgucGF0aD90aGlzW09dPW4oKShoLnBhdGgpOnRoaXNbT109W10sdGhpc1tUXT1udWxsLHRoaXNbdl09aC5zaW1wbGlmeSE9bnVsbD9oLnNpbXBsaWZ5OjAsdGhpc1tQXT1oLnNjYWxlIT1udWxsP2guc2NhbGU6Mn1nZXQgY29udG91cnMoKXtsZXQgaD1udWxsO2lmKCF0aGlzW1RdJiZ0aGlzW09dKXtjb25zdCBiPU9iamVjdChmLmRlZmF1bHQpKG8oKSh0aGlzW09dKSk7dGhpc1tUXT1nKCkoYix0aGlzW1BdLHRoaXNbdl0pLHRoaXNbVF0ucGF0aD1iLHRoaXNbVF0uc2ltcGxpZnk9dGhpc1t2XSx0aGlzW1RdLnNjYWxlPXRoaXNbUF19cmV0dXJuIHRoaXNbVF0mJihoPXRoaXNbVF0ubWFwKGI9PlsuLi5iXSksaC5wYXRoPXRoaXNbVF0ucGF0aCxoLnNpbXBsaWZ5PXRoaXNbVF0uc2ltcGxpZnksaC5zY2FsZT10aGlzW1RdLnNjYWxlKSxofWdldCBwYXRoKCl7cmV0dXJuIHRoaXNbT119Z2V0IHNpbXBsaWZ5KCl7cmV0dXJuIHRoaXNbdl19Z2V0IGJvdW5kaW5nQm94KCl7Y29uc3QgaD10aGlzLmNvbnRvdXJzO2lmKGgmJmgubGVuZ3RoKXtjb25zdCBiPWgucmVkdWNlKChFLEEpPT5bLi4uRSwuLi5BXSk7cmV0dXJuIGwoKShiKX1yZXR1cm5bWzAsMF0sWzAsMF1dfWdldCBib3VuZGluZ0NlbnRlcigpe2NvbnN0IGg9dGhpcy5ib3VuZGluZ0JveDtyZXR1cm4gaD9bLjUqKGhbMF1bMF0raFsxXVswXSksLjUqKGhbMF1bMV0raFsxXVsxXSldOlswLDBdfW5vcm1hbGl6ZShoPTAsYj0wKXtjb25zdCBFPU9iamVjdChmLmRlZmF1bHQpKG8oKSh0aGlzW09dKSkubWFwKChbQSwuLi5MXSk9Pntjb25zdCBTPVtBXTtmb3IobGV0IEk9MDtJPEwubGVuZ3RoO0krPTIpe2NvbnN0IEQ9TFtJXS1oLFI9TFtJKzFdLWI7Uy5wdXNoKEQsUil9cmV0dXJuIFN9KTtyZXR1cm4gdGhpcy5iZWdpblBhdGgoKSx0aGlzW09dLnB1c2goLi4uRSksdGhpc31nZXRQb2ludEF0TGVuZ3RoKGgpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh5LmdldFBvaW50QXRMZW5ndGgpKHRoaXNbVF0saCk6bnVsbH1nZXRUb3RhbExlbmd0aCgpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdCh5LmdldFRvdGFsTGVuZ3RoKSh0aGlzW1RdKTowfWFkZFBhdGgoaCl7dGhpc1tUXT1udWxsLHR5cGVvZiBoPT0ic3RyaW5nIiYmKGg9bigpKGgpKSx0aGlzW09dLnB1c2goLi4uaCl9YmVnaW5QYXRoKCl7dGhpc1tPXT1bXSx0aGlzW1RdPW51bGx9Y2xlYXIoKXt0aGlzLmJlZ2luUGF0aCgpfWVsbGlwc2UoaCxiLEUsQSxMLFMsSSxEPTApe2lmKFMrPUwsSSs9TCxFPD0wfHxBPD0wfHxJPT09UylyZXR1cm47STxTJiYoST1TK2krKEktUyklaSksSS1TPmkmJihJPVMraSk7Y29uc3QgUj1JLVM7Uj49aSYmKEktPS4wMDEpO2xldCBDPXRoaXNbT10ubGVuZ3RoPjAmJlI8aT8iTCI6Ik0iO2NvbnN0IGo9T2JqZWN0KG0uZ2V0UG9pbnQpKGgsYixFLEEsUyksJD1PYmplY3QobS5nZXRQb2ludCkoaCxiLEUsQSxJKSxIPSshRDtsZXQgSj1SPk1hdGguUEk/MTowO0QmJihKPTEtSiksQys9ai5qb2luKCIgIiksQys9YEEke0V9ICR7QX0gMCAke0p9ICR7SH0gJHskLmpvaW4oIiAiKX1gLFI+PWkmJihDKz0iWiIpLHRoaXMuYWRkUGF0aChDKX1hcmMoaCxiLEUsQSxMLFM9MCl7cmV0dXJuIHRoaXMuZWxsaXBzZShoLGIsRSxFLDAsQSxMLFMpfWFyY1RvKGgsYixFLEEsTCxTLEkpe3RoaXNbVF09bnVsbCx0aGlzW09dLnB1c2goWyJBIixoLGIsRSxBLEwsUyxJXSl9bW92ZVRvKGgsYil7dGhpc1tUXT1udWxsLHRoaXNbT10ucHVzaChbIk0iLGgsYl0pfWxpbmVUbyhoLGIpe3RoaXNbVF09bnVsbCx0aGlzW09dLnB1c2goWyJMIixoLGJdKX1iZXppZXJDdXJ2ZVRvKGgsYixFLEEsTCxTKXt0aGlzW1RdPW51bGwsdGhpc1tPXS5wdXNoKFsiQyIsaCxiLEUsQSxMLFNdKX1xdWFkcmF0aWNDdXJ2ZVRvKGgsYixFLEEpe3RoaXNbVF09bnVsbCx0aGlzW09dLnB1c2goWyJRIixoLGIsRSxBXSl9cmVjdChoLGIsRSxBKXtjb25zdCBMPWBNJHtofSAke2J9TCR7aCtFfSAke2J9TCR7aCtFfSAke2IrQX1MJHtofSAke2IrQX1aYDt0aGlzLmFkZFBhdGgoTCl9Y2xvc2VQYXRoKCl7dGhpc1tUXT1udWxsO2xldCBoPVtdO2NvbnN0IGI9dGhpc1tPXS5sZW5ndGg7Yj4wJiYoaD10aGlzW09dW2ItMV0pLGhbMF0hPT0iWiImJmhbMF0hPT0ieiImJnRoaXNbT10ucHVzaChbIloiXSl9fX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9bjt2YXIgdD17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxyPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gbihjKXt2YXIgbz1bXTtyZXR1cm4gYy5yZXBsYWNlKHIsZnVuY3Rpb24oZix4LGcpe3ZhciB5PXgudG9Mb3dlckNhc2UoKTtmb3IoZz1sKGcpLHk9PSJtIiYmZy5sZW5ndGg+MiYmKG8ucHVzaChbeF0uY29uY2F0KGcuc3BsaWNlKDAsMikpKSx5PSJsIix4PXg9PSJtIj8ibCI6IkwiKTs7KXtpZihnLmxlbmd0aD09dFt5XSlyZXR1cm4gZy51bnNoaWZ0KHgpLG8ucHVzaChnKTtpZihnLmxlbmd0aDx0W3ldKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO28ucHVzaChbeF0uY29uY2F0KGcuc3BsaWNlKDAsdFt5XSkpKX19KSxvfXZhciBzPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIGwoYyl7dmFyIG89Yy5tYXRjaChzKTtyZXR1cm4gbz9vLm1hcChOdW1iZXIpOltdfX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz1yO2Z1bmN0aW9uIHIobil7dmFyIHM9bi5sZW5ndGg7aWYocz09PTApcmV0dXJuW1tdLFtdXTtmb3IodmFyIGw9blswXS5sZW5ndGgsYz1uWzBdLnNsaWNlKCksbz1uWzBdLnNsaWNlKCksZj0xO2Y8czsrK2YpZm9yKHZhciB4PW5bZl0sZz0wO2c8bDsrK2cpe3ZhciB5PXhbZ107Y1tnXT1NYXRoLm1pbihjW2ddLHkpLG9bZ109TWF0aC5tYXgob1tnXSx5KX1yZXR1cm5bYyxvXX19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPXQ7ZnVuY3Rpb24gdChyKXt2YXIgbj0wLHM9MCxsPTAsYz0wO3JldHVybiByLm1hcChmdW5jdGlvbihvKXtvPW8uc2xpY2UoKTt2YXIgZj1vWzBdLHg9Zi50b1VwcGVyQ2FzZSgpO2lmKGYhPXgpc3dpdGNoKG9bMF09eCxmKXtjYXNlImEiOm9bNl0rPWwsb1s3XSs9YzticmVhaztjYXNlInYiOm9bMV0rPWM7YnJlYWs7Y2FzZSJoIjpvWzFdKz1sO2JyZWFrO2RlZmF1bHQ6Zm9yKHZhciBnPTE7ZzxvLmxlbmd0aDspb1tnKytdKz1sLG9bZysrXSs9Y31zd2l0Y2goeCl7Y2FzZSJaIjpsPW4sYz1zO2JyZWFrO2Nhc2UiSCI6bD1vWzFdO2JyZWFrO2Nhc2UiViI6Yz1vWzFdO2JyZWFrO2Nhc2UiTSI6bD1uPW9bMV0sYz1zPW9bMl07YnJlYWs7ZGVmYXVsdDpsPW9bby5sZW5ndGgtMl0sYz1vW28ubGVuZ3RoLTFdfXJldHVybiBvfSl9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIHI9dCg0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oYyl7Zm9yKHZhciBvLGY9W10seD0wLGc9MCx5PTAsbT0wLFQ9bnVsbCxPPW51bGwsdj0wLFA9MCxpPTAsdT1jLmxlbmd0aDtpPHU7aSsrKXt2YXIgYT1jW2ldLGg9YVswXTtzd2l0Y2goaCl7Y2FzZSJNIjp5PWFbMV0sbT1hWzJdO2JyZWFrO2Nhc2UiQSI6dmFyIGI9T2JqZWN0KHIuZGVmYXVsdCkodixQLGFbNl0sYVs3XSxhWzRdLGFbNV0sYVsxXSxhWzJdLGFbM10pO2lmKCFiLmxlbmd0aCljb250aW51ZTtiPWIubWFwKEk9Pntjb25zdFtELFIsQyxqLCQsSCxKLHFdPUk7cmV0dXJue3gxOkMseTE6aix4MjokLHkyOkgseDpKLHk6cX19KTtmb3IodmFyIEU9MCxBO0U8Yi5sZW5ndGg7RSsrKUE9YltFXSxhPVsiQyIsQS54MSxBLnkxLEEueDIsQS55MixBLngsQS55XSxFPGIubGVuZ3RoLTEmJmYucHVzaChhKTticmVhaztjYXNlIlMiOnZhciBMPXYsUz1QOyhvPT0iQyJ8fG89PSJTIikmJihMKz1MLXgsUys9Uy1nKSxhPVsiQyIsTCxTLGFbMV0sYVsyXSxhWzNdLGFbNF1dO2JyZWFrO2Nhc2UiVCI6bz09IlEifHxvPT0iVCI/KFQ9dioyLVQsTz1QKjItTyk6KFQ9dixPPVApLGE9bCh2LFAsVCxPLGFbMV0sYVsyXSk7YnJlYWs7Y2FzZSJRIjpUPWFbMV0sTz1hWzJdLGE9bCh2LFAsYVsxXSxhWzJdLGFbM10sYVs0XSk7YnJlYWs7Y2FzZSJMIjphPXModixQLGFbMV0sYVsyXSk7YnJlYWs7Y2FzZSJIIjphPXModixQLGFbMV0sUCk7YnJlYWs7Y2FzZSJWIjphPXModixQLHYsYVsxXSk7YnJlYWs7Y2FzZSJaIjphPXModixQLHksbSk7YnJlYWt9bz1oLHY9YVthLmxlbmd0aC0yXSxQPWFbYS5sZW5ndGgtMV0sYS5sZW5ndGg+ND8oeD1hW2EubGVuZ3RoLTRdLGc9YVthLmxlbmd0aC0zXSk6KHg9dixnPVApLGYucHVzaChhKX1yZXR1cm4gZn1mdW5jdGlvbiBzKGMsbyxmLHgpe3JldHVyblsiQyIsYyxvLGYseCxmLHhdfWZ1bmN0aW9uIGwoYyxvLGYseCxnLHkpe3JldHVyblsiQyIsYy8zKzIvMypmLG8vMysyLzMqeCxnLzMrMi8zKmYseS8zKzIvMyp4LGcseV19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIG4obyxmLHgsZyl7Y29uc3QgeT1vKmctZip4PDA/LTE6MTtsZXQgbT1vKngrZipnO3JldHVybiBtPjEmJihtPTEpLG08LTEmJihtPS0xKSx5Kk1hdGguYWNvcyhtKX1mdW5jdGlvbiBzKG8sZix4LGcseSxtLFQsTyx2LFApe2NvbnN0IGk9UCooby14KS8yK3YqKGYtZykvMix1PS12KihvLXgpLzIrUCooZi1nKS8yLGE9VCpULGg9TypPLGI9aSppLEU9dSp1O2xldCBBPWEqaC1hKkUtaCpiO0E8MCYmKEE9MCksQS89YSpFK2gqYixBPU1hdGguc3FydChBKSooeT09PW0/LTE6MSk7Y29uc3QgTD1BKlQvTyp1LFM9QSotTy9UKmksST1QKkwtdipTKyhvK3gpLzIsRD12KkwrUCpTKyhmK2cpLzIsUj0oaS1MKS9ULEM9KHUtUykvTyxqPSgtaS1MKS9ULCQ9KC11LVMpL08sSD1uKDEsMCxSLEMpO2xldCBKPW4oUixDLGosJCk7cmV0dXJuIG09PT0wJiZKPjAmJihKLT1yKSxtPT09MSYmSjwwJiYoSis9ciksW0ksRCxILEpdfWZ1bmN0aW9uIGwobyxmKXtjb25zdCB4PTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihmLzQpLGc9TWF0aC5jb3MobykseT1NYXRoLnNpbihvKSxtPU1hdGguY29zKG8rZiksVD1NYXRoLnNpbihvK2YpO3JldHVybltnLHksZy15KngseStnKngsbStUKngsVC1tKngsbSxUXX1mdW5jdGlvbiBjKG8sZix4LGcseSxtLFQsTyx2KXtjb25zdCBQPU1hdGguc2luKHYqci8zNjApLGk9TWF0aC5jb3ModipyLzM2MCksdT1pKihvLXgpLzIrUCooZi1nKS8yLGE9LVAqKG8teCkvMitpKihmLWcpLzI7aWYodT09PTAmJmE9PT0wKXJldHVybltdO2lmKFQ9PT0wfHxPPT09MClyZXR1cm5bXTtUPU1hdGguYWJzKFQpLE89TWF0aC5hYnMoTyk7Y29uc3QgaD11KnUvKFQqVCkrYSphLyhPKk8pO2g+MSYmKFQqPU1hdGguc3FydChoKSxPKj1NYXRoLnNxcnQoaCkpO2NvbnN0IGI9cyhvLGYseCxnLHksbSxULE8sUCxpKSxFPVtdO2xldCBBPWJbMl0sTD1iWzNdO2NvbnN0IFM9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKEwpLyhyLzQpKSwxKTtMLz1TO2ZvcihsZXQgST0wO0k8UztJKyspRS5wdXNoKGwoQSxMKSksQSs9TDtyZXR1cm4gRS5tYXAoST0+e2ZvcihsZXQgRD0wO0Q8SS5sZW5ndGg7RCs9Mil7bGV0IFI9SVtEKzBdLEM9SVtEKzFdO1IqPVQsQyo9Tztjb25zdCBqPWkqUi1QKkMsJD1QKlIraSpDO0lbRCswXT1qK2JbMF0sSVtEKzFdPSQrYlsxXX1yZXR1cm4gSX0pfX0sZnVuY3Rpb24oZCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj10KDQ3KSx7Y29weTpufT10KDQ5KSxzPXQoNTApO2Z1bmN0aW9uIGwoZyx5LG0pe3JldHVybiBnWzBdPXksZ1sxXT1tLGd9dmFyIGM9WzAsMF0sbz1bMCwwXSxmPVswLDBdO2Z1bmN0aW9uIHgoZyx5LG0sVCl7cihtLGwoYyxUWzFdLFRbMl0pLGwobyxUWzNdLFRbNF0pLGwoZixUWzVdLFRbNl0pLHksZyl9ZC5leHBvcnRzPWZ1bmN0aW9uKHksbSxUKXt2YXIgTz1bXSx2PVtdLFA9WzAsMF07cmV0dXJuIHkuZm9yRWFjaChmdW5jdGlvbihpLHUsYSl7aWYoaVswXT09PSJNIiluKFAsaS5zbGljZSgxKSksdi5sZW5ndGg+MCYmKE8ucHVzaCh2KSx2PVtdKTtlbHNlIGlmKGlbMF09PT0iQyIpeCh2LG0sUCxpKSxsKFAsaVs1XSxpWzZdKTtlbHNlIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCB0eXBlIGluIFNWRzogIitpWzBdKX0pLHYubGVuZ3RoPjAmJk8ucHVzaCh2KSxPLm1hcChmdW5jdGlvbihpKXtyZXR1cm4gcyhpLFR8fDApfSl9fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXQoNDgpKCl9LGZ1bmN0aW9uKGQsZSl7ZnVuY3Rpb24gdChuKXtyZXR1cm5bblswXSxuWzFdXX1mdW5jdGlvbiByKG4scyl7cmV0dXJuW24sc119ZC5leHBvcnRzPWZ1bmN0aW9uKHMpe3M9c3x8e307dmFyIGw9dHlwZW9mIHMucmVjdXJzaW9uPT0ibnVtYmVyIj9zLnJlY3Vyc2lvbjo4LGM9dHlwZW9mIHMuZXBzaWxvbj09Im51bWJlciI/cy5lcHNpbG9uOjExOTIwOTI5ZS0xNCxvPXR5cGVvZiBzLnBhdGhFcHNpbG9uPT0ibnVtYmVyIj9zLnBhdGhFcHNpbG9uOjEsZj10eXBlb2Ygcy5hbmdsZUVwc2lsb249PSJudW1iZXIiP3MuYW5nbGVFcHNpbG9uOi4wMSx4PXMuYW5nbGVUb2xlcmFuY2V8fDAsZz1zLmN1c3BMaW1pdHx8MDtyZXR1cm4gZnVuY3Rpb24oTyx2LFAsaSx1LGEpe2F8fChhPVtdKSx1PXR5cGVvZiB1PT0ibnVtYmVyIj91OjE7dmFyIGg9by91O3JldHVybiBoKj1oLHkoTyx2LFAsaSxhLGgpLGF9O2Z1bmN0aW9uIHkoVCxPLHYsUCxpLHUpe2kucHVzaCh0KFQpKTt2YXIgYT1UWzBdLGg9VFsxXSxiPU9bMF0sRT1PWzFdLEE9dlswXSxMPXZbMV0sUz1QWzBdLEk9UFsxXTttKGEsaCxiLEUsQSxMLFMsSSxpLHUsMCksaS5wdXNoKHQoUCkpfWZ1bmN0aW9uIG0oVCxPLHYsUCxpLHUsYSxoLGIsRSxBKXtpZighKEE+bCkpe3ZhciBMPU1hdGguUEksUz0oVCt2KS8yLEk9KE8rUCkvMixEPSh2K2kpLzIsUj0oUCt1KS8yLEM9KGkrYSkvMixqPSh1K2gpLzIsJD0oUytEKS8yLEg9KEkrUikvMixKPShEK0MpLzIscT0oUitqKS8yLEY9KCQrSikvMixHPShIK3EpLzI7aWYoQT4wKXt2YXIgWj1hLVQsdHQ9aC1PLGV0PU1hdGguYWJzKCh2LWEpKnR0LShQLWgpKlopLGl0PU1hdGguYWJzKChpLWEpKnR0LSh1LWgpKlopLGssaHQ7aWYoZXQ+YyYmaXQ+Yyl7aWYoKGV0K2l0KSooZXQraXQpPD1FKihaKlordHQqdHQpKXtpZih4PGYpe2IucHVzaChyKEYsRykpO3JldHVybn12YXIgZnQ9TWF0aC5hdGFuMih1LVAsaS12KTtpZihrPU1hdGguYWJzKGZ0LU1hdGguYXRhbjIoUC1PLHYtVCkpLGh0PU1hdGguYWJzKE1hdGguYXRhbjIoaC11LGEtaSktZnQpLGs+PUwmJihrPTIqTC1rKSxodD49TCYmKGh0PTIqTC1odCksaytodDx4KXtiLnB1c2gocihGLEcpKTtyZXR1cm59aWYoZyE9PTApe2lmKGs+Zyl7Yi5wdXNoKHIodixQKSk7cmV0dXJufWlmKGh0Pmcpe2IucHVzaChyKGksdSkpO3JldHVybn19fX1lbHNlIGlmKGV0PmMpe2lmKGV0KmV0PD1FKihaKlordHQqdHQpKXtpZih4PGYpe2IucHVzaChyKEYsRykpO3JldHVybn1pZihrPU1hdGguYWJzKE1hdGguYXRhbjIodS1QLGktdiktTWF0aC5hdGFuMihQLU8sdi1UKSksaz49TCYmKGs9MipMLWspLGs8eCl7Yi5wdXNoKHIodixQKSksYi5wdXNoKHIoaSx1KSk7cmV0dXJufWlmKGchPT0wJiZrPmcpe2IucHVzaChyKHYsUCkpO3JldHVybn19fWVsc2UgaWYoaXQ+Yyl7aWYoaXQqaXQ8PUUqKFoqWit0dCp0dCkpe2lmKHg8Zil7Yi5wdXNoKHIoRixHKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihoLXUsYS1pKS1NYXRoLmF0YW4yKHUtUCxpLXYpKSxrPj1MJiYoaz0yKkwtayksazx4KXtiLnB1c2gocih2LFApKSxiLnB1c2gocihpLHUpKTtyZXR1cm59aWYoZyE9PTAmJms+Zyl7Yi5wdXNoKHIoaSx1KSk7cmV0dXJufX19ZWxzZSBpZihaPUYtKFQrYSkvMix0dD1HLShPK2gpLzIsWipaK3R0KnR0PD1FKXtiLnB1c2gocihGLEcpKTtyZXR1cm59fW0oVCxPLFMsSSwkLEgsRixHLGIsRSxBKzEpLG0oRixHLEoscSxDLGosYSxoLGIsRSxBKzEpfX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY29tcHV0ZU1pdGVyIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsIm5vcm1hbCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJkaXJlY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTt2YXIgcj10KDEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHUpe3JldHVyblt1WzBdLHVbMV1dfWZ1bmN0aW9uIHMoKXtyZXR1cm5bMCwwXX1jb25zdCBsPXIudmVjMi5jb3B5LGM9ci52ZWMyLnNjYWxlQW5kQWRkLG89ci52ZWMyLmRvdCxmPXIudmVjMi5yb3RhdGUseD1yLnZlYzIuY3Jvc3MsZz1yLnZlYzIuc3ViLHk9ci52ZWMyLmFkZCxtPXIudmVjMi5ub3JtYWxpemUsVD1yLnZlYzIuc2V0LE89cygpO2Z1bmN0aW9uIHYodSxhLGgsYixFKXt5KHUsaCxiKSxtKHUsdSksVChhLC11WzFdLHVbMF0pLFQoTywtaFsxXSxoWzBdKTtjb25zdCBBPUUvbyhhLE8pO3JldHVybiBNYXRoLmFicyhBKX1mdW5jdGlvbiBQKHUsYSl7cmV0dXJuIFQodSwtYVsxXSxhWzBdKSx1fWZ1bmN0aW9uIGkodSxhLGgpe3JldHVybiBnKHUsYSxoKSxtKHUsdSksdX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDUxKSxuPXQoNTIpO2QuZXhwb3J0cz1mdW5jdGlvbihsLGMpe3JldHVybiBsPXIobCxjKSxsPW4obCxjKSxsfSxkLmV4cG9ydHMucmFkaWFsRGlzdGFuY2U9cixkLmV4cG9ydHMuZG91Z2xhc1BldWNrZXI9bn0sZnVuY3Rpb24oZCxlKXtmdW5jdGlvbiB0KHIsbil7dmFyIHM9clswXS1uWzBdLGw9clsxXS1uWzFdO3JldHVybiBzKnMrbCpsfWQuZXhwb3J0cz1mdW5jdGlvbihuLHMpe2lmKG4ubGVuZ3RoPD0xKXJldHVybiBuO3M9dHlwZW9mIHM9PSJudW1iZXIiP3M6MTtmb3IodmFyIGw9cypzLGM9blswXSxvPVtjXSxmLHg9MSxnPW4ubGVuZ3RoO3g8Zzt4KyspZj1uW3hdLHQoZixjKT5sJiYoby5wdXNoKGYpLGM9Zik7cmV0dXJuIGMhPT1mJiZvLnB1c2goZiksb319LGZ1bmN0aW9uKGQsZSl7ZnVuY3Rpb24gdChuLHMsbCl7dmFyIGM9c1swXSxvPXNbMV0sZj1sWzBdLWMseD1sWzFdLW87aWYoZiE9PTB8fHghPT0wKXt2YXIgZz0oKG5bMF0tYykqZisoblsxXS1vKSp4KS8oZipmK3gqeCk7Zz4xPyhjPWxbMF0sbz1sWzFdKTpnPjAmJihjKz1mKmcsbys9eCpnKX1yZXR1cm4gZj1uWzBdLWMseD1uWzFdLW8sZipmK3gqeH1mdW5jdGlvbiByKG4scyxsLGMsbyl7Zm9yKHZhciBmPWMseCxnPXMrMTtnPGw7ZysrKXt2YXIgeT10KG5bZ10sbltzXSxuW2xdKTt5PmYmJih4PWcsZj15KX1mPmMmJih4LXM+MSYmcihuLHMseCxjLG8pLG8ucHVzaChuW3hdKSxsLXg+MSYmcihuLHgsbCxjLG8pKX1kLmV4cG9ydHM9ZnVuY3Rpb24ocyxsKXtpZihzLmxlbmd0aDw9MSlyZXR1cm4gcztsPXR5cGVvZiBsPT0ibnVtYmVyIj9sOjE7dmFyIGM9bCpsLG89cy5sZW5ndGgtMSxmPVtzWzBdXTtyZXR1cm4gcihzLDAsbyxjLGYpLGYucHVzaChzW29dKSxmfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZ2V0VG90YWxMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZ2V0UG9pbnRBdExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJnZXREYXNoQ29udG91cnMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDU0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihvKXtpZihvLnRvdGFsTGVuZ3RoIT1udWxsKXJldHVybiBvLnRvdGFsTGVuZ3RoO2xldCBmPTA7cmV0dXJuIG8uZm9yRWFjaCh4PT57bGV0IGc9eFswXTtmb3IobGV0IHk9MTt5PHgubGVuZ3RoO3krKyl7Y29uc3QgbT14W3ldO2YrPU9iamVjdChyLmRpc3RhbmNlKShnLG0pLGc9bX19KSxvLnRvdGFsTGVuZ3RoPWYsZn1mdW5jdGlvbiBzKG8sZix4PSEwKXtpZihmPU51bWJlcihmKSwhTnVtYmVyLmlzRmluaXRlKGYpKXRocm93IG5ldyBUeXBlRXJyb3IoIkZhaWxlZCB0byBleGVjdXRlICdnZXRQb2ludEF0TGVuZ3RoJyBvbiBmaWd1cmU6IFRoZSBwcm92aWRlZCBmbG9hdCB2YWx1ZSBpcyBub24tZmluaXRlLiIpO2lmKGY8PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiTGVuZ3RoIG11c3QgPiAwIik7Y29uc3QgZz1uKG8pO2lmKGY+PWcpe2NvbnN0IG09b1tvLmxlbmd0aC0xXSxUPW1bbS5sZW5ndGgtMl0sTz1tW20ubGVuZ3RoLTFdLHY9TWF0aC5hdGFuMihPWzFdLVRbMV0sT1swXS1UWzBdKTtyZXR1cm57Y3VycmVudDpvLm1hcChQPT5bLi4uUF0pLHBvaW50Ont4Ok9bMF0seTpPWzFdLGFuZ2xlOnZ9fX1jb25zdCB5PVtdO2ZvcihsZXQgbT0wO208by5sZW5ndGg7bSsrKXt5W21dPVtdO2NvbnN0IFQ9b1ttXTtsZXQgTz1UWzBdO2ZvcihsZXQgdj0xO3Y8VC5sZW5ndGg7disrKXtjb25zdCBQPVRbdl0saT1PYmplY3Qoci5kaXN0YW5jZSkoTyxQKTtpZihmPGkpe2NvbnN0IHU9Zi9pLGE9TWF0aC5hdGFuMihQWzFdLU9bMV0sUFswXS1PWzBdKSxoPXt4Ok9bMF0qKDEtdSkrUFswXSp1LHk6T1sxXSooMS11KStQWzFdKnUsYW5nbGU6YX07aWYoeVttXS5wdXNoKE8pLGY+MCYmeVttXS5wdXNoKFtoLngsaC55XSksIXgpcmV0dXJue2N1cnJlbnQ6eSxwb2ludDpofTtjb25zdCBiPVtdLEU9bTtmb3IoO208by5sZW5ndGg7bSsrKXtmb3IoYlttLUVdPVtdLG09PT1FJiZiWzBdLnB1c2goW2gueCxoLnldKTt2PFQubGVuZ3RoO3YrKyliW20tRV0ucHVzaChUW3ZdKTt2PTB9cmV0dXJue2N1cnJlbnQ6eSxwb2ludDpoLHJlc3Q6Yn19Zi09aSx5W21dLnB1c2goTyksTz1QfX19ZnVuY3Rpb24gbChvLGYpe2lmKGY9TnVtYmVyKGYpLCFOdW1iZXIuaXNGaW5pdGUoZikpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoby5sZW5ndGg8PTApcmV0dXJue3g6MCx5OjAsYW5nbGU6MH07aWYoZjw9MCl7Y29uc3QgeD1vWzBdWzBdLGc9b1swXVsxXSx5PU1hdGguYXRhbjIoZ1sxXS14WzFdLGdbMF0teFswXSk7cmV0dXJue3g6eFswXSx5OnhbMV0sYW5nbGU6eX19cmV0dXJuIHMobyxmLCExKS5wb2ludH1mdW5jdGlvbiBjKG8sZix4KXtsZXQgZz0wLHk9ZlswXSxtPW87Y29uc3QgVD1bXSxPPWYubGVuZ3RoO2lmKHg+MCl7ZG8geC09ZltnJU9dLGcrKzt3aGlsZSh4PjApO3g8MCYmKHk9LXgsZy0tKX1lbHNlIGlmKHg8MCl7Zz0tMTtkbyB4Kz1mW2clTytPLTFdLGctLTt3aGlsZSh4PDApO3g+PTAmJihnKysseT1mW2clTytPLTFdLXgpfWRve2NvbnN0IHY9cyhtLHkpO209di5yZXN0LCsrZyUyJiZULnB1c2goLi4udi5jdXJyZW50KTtsZXQgUD1nJU87UDwwJiYoUCs9TykseT1mW1BdfXdoaWxlKG0pO3JldHVybiBUfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBufSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoW3MsbCxjXSxvLGYseCl7cmV0dXJuIHM9cyoyL28tMSxsPTEtbCoyL2YsTnVtYmVyLmlzRmluaXRlKHgpPyhjPWMqMi94LTEsW3MsbCxjXSk6W3MsbF19ZnVuY3Rpb24gbihbcyxsLGM9MF0sW28sZix4PTBdKXtyZXR1cm4gTWF0aC5oeXBvdChvLXMsZi1sLHgtYyl9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRQb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPU1hdGguUEkqMjtmdW5jdGlvbiBuKHMsbCxjLG8sZil7ZiU9cixmPDAmJihmKz1yKTtjb25zdCB4PU1hdGgudGFuKGYpO2lmKE1hdGguYWJzKHgpPDFlNSl7Y29uc3QgZz1sLXgqcyx5PTEvYyoqMit4KioyL28qKjI7bGV0IG09LTE7KGY8PU1hdGguUEkvMnx8Zj4zKk1hdGguUEkvMikmJihtPTEpO2NvbnN0IFQ9bSpNYXRoLnNxcnQoMS95KStzLE89eCpUK2c7cmV0dXJuW1QsT119cmV0dXJuIGY8TWF0aC5QST9bcyxsK29dOltzLGwtb119fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBWfSk7dmFyIHI9dCgxKSxuPXQoNDIpLHM9dC5uKG4pLGw9dCg1NyksYz10KDI4KSxvPXQoMjQpLGY9dCgzMCkseD10KDU5KSxnPXQoNTMpLHk9dCg2MCksbT10Lm4oeSksVD10KDQ2KSxPPXQubihUKSx2PXQoMzEpLFA9dCg0MCksaT10KDIxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShYLE4pe2lmKFg9PW51bGwpcmV0dXJue307dmFyIHo9YShYLE4pLHAsTTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgdz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFgpO2ZvcihNPTA7TTx3Lmxlbmd0aDtNKyspcD13W01dLCEoTi5pbmRleE9mKHApPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFgscCkmJih6W3BdPVhbcF0pfXJldHVybiB6fWZ1bmN0aW9uIGEoWCxOKXtpZihYPT1udWxsKXJldHVybnt9O3ZhciB6PXt9LHA9T2JqZWN0LmtleXMoWCksTSx3O2Zvcih3PTA7dzxwLmxlbmd0aDt3KyspTT1wW3ddLCEoTi5pbmRleE9mKE0pPj0wKSYmKHpbTV09WFtNXSk7cmV0dXJuIHp9Y29uc3QgaD1TeW1ib2woIm1lc2giKSxiPVN5bWJvbCgiY29udG91cnMiKSxFPVN5bWJvbCgic3Ryb2tlIiksQT1TeW1ib2woImZpbGwiKSxMPVN5bWJvbCgic3Ryb2tlQ29sb3IiKSxTPVN5bWJvbCgiZmlsbENvbG9yIiksST1TeW1ib2woInRyYW5zZm9ybSIpLEQ9U3ltYm9sKCJpbnZlcnRUcmFuc2Zvcm0iKSxSPVN5bWJvbCgidW5pZm9ybXMiKSxDPVN5bWJvbCgidGV4T3B0aW9ucyIpLGo9U3ltYm9sKCJibGVuZCIpLCQ9U3ltYm9sKCJhcHBseVRleHR1cmUiKSxIPVN5bWJvbCgiYXBwbHlUcmFuc2Zvcm0iKSxKPVN5bWJvbCgiYXBwbHlHcmFkaWVudFRyYW5zZm9ybSIpLHE9U3ltYm9sKCJhcHBseVByb2dyYW0iKSxGPVN5bWJvbCgiZ3JhZGllbnQiKSxHPVN5bWJvbCgiZmlsdGVyIiksWj1TeW1ib2woIm9wYWNpdHkiKSx0dD1TeW1ib2woInByb2dyYW0iKSxldD1TeW1ib2woImF0dHJpYnV0ZXMiKSxpdD1TeW1ib2woInBhc3MiKSxrPVN5bWJvbCgiY2xpcENvbnRleHQiKSxodD1TeW1ib2woImFwcGx5Q2xpcFBhdGgiKTtmdW5jdGlvbiBmdChYLE4pe2NvbnN0W3oscF09W1hbMV1bMF0tWFswXVswXSxYWzFdWzFdLVhbMF1bMV1dLE09W107Zm9yKGxldCB3PTA7dzxOLmxlbmd0aDt3Kyspe2NvbnN0IFU9Tlt3XSxLPVsoVVswXS1YWzBdWzBdKS96LDEtKFVbMV0tWFswXVsxXSkvcF07TS5wdXNoKEspfXJldHVybiBNfWZ1bmN0aW9uIEIoW1gsTl0sW3oscCxNLHddLHtzY2FsZTpVfSl7cmV0dXJuIFV8fChYLz1NLE49MS1OL3csWC09eixOKz1wKSxbWCxOLDBdfWZ1bmN0aW9uIFcoWCxOLHope2NvbnN0IHA9TygpKFgsTix6KTtyZXR1cm4gcC5wYXRoPVgscC5zaW1wbGlmeT16LHAuc2NhbGU9TixwfWNsYXNzIFZ7Y29uc3RydWN0b3IoTil7dGhpc1tFXT1udWxsLHRoaXNbQV09bnVsbCx0aGlzW0ldPVsxLDAsMCwxLDAsMF0sdGhpc1taXT0xLHRoaXNbUl09e30sdGhpc1tHXT1bXSx0aGlzW2pdPW51bGwsdGhpc1tDXT17fSx0aGlzLmNvbnRvdXJzPU4uY29udG91cnMsdGhpc1t0dF09bnVsbCx0aGlzW2V0XT17fSx0aGlzW2l0XT1bXX1nZXQgY29udG91cnMoKXtyZXR1cm4gdGhpc1tiXX1zZXQgY29udG91cnMoTil7dGhpc1toXT1udWxsLHRoaXNbYl09Tjtjb25zdCB6PU4uc2NhbGU7dGhpcy50cmFuc2Zvcm1TY2FsZS96PjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKX1zZXRQcm9ncmFtKE4pe3RoaXNbdHRdPU4sdGhpc1toXSYmdGhpc1txXShOKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW3R0XX1zZXRBdHRyaWJ1dGUoTix6KXt6PT1udWxsP2RlbGV0ZSB0aGlzW2V0XVtOXTp0aGlzW2V0XVtOXT16fWdldE9wYWNpdHkoKXtyZXR1cm4gdGhpc1taXX1zZXRPcGFjaXR5KE4pe2lmKE48MHx8Tj4xKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgb3BhY2l0eSB2YWx1ZS4iKTt0aGlzW2hdJiZ0aGlzW2hdLnBvc2l0aW9ucy5mb3JFYWNoKHo9Pnt6WzJdPTEvelsyXT4wP046LU59KSx0aGlzW1pdPU59c2V0Q2xpcFBhdGgoTil7dGhpcy5jbGlwUGF0aD1OLHRoaXNbUl0udV9jbGlwU2FtcGxlciYmdGhpc1tSXS51X2NsaXBTYW1wbGVyLmRlbGV0ZSgpLHRoaXMuc2V0VW5pZm9ybXMoe3VfY2xpcFNhbXBsZXI6bnVsbH0pLHRoaXNbaF0mJmRlbGV0ZSB0aGlzW2hdLmF0dHJpYnV0ZXMuYV9jbGlwVVYsTiYmdGhpc1toXSYmdGhpc1todF0oKX1baHRdKCl7aWYodGhpcy5jbGlwUGF0aCl7dGhpc1trXXx8KHRoaXNba109aS5kZWZhdWx0LmNyZWF0ZUNhbnZhcygxLDEpKTtjb25zdFtbTix6XSxbcCxNXV09dGhpcy5ib3VuZGluZ0JveDtwJiZNJiYodGhpc1trXS53aWR0aD1wLU4sdGhpc1trXS5oZWlnaHQ9TS16KTtjb25zdCB3PXRoaXNba10uZ2V0Q29udGV4dCgiMmQiKSxVPW5ldyBQYXRoMkQodGhpcy5jbGlwUGF0aCk7dy5jbGVhclJlY3QoMCwwLHRoaXNba10ud2lkdGgsdGhpc1trXS5oZWlnaHQpLHcuc2F2ZSgpLHcudHJhbnNsYXRlKC1OLC16KSx3LmZpbGxTdHlsZT0id2hpdGUiLHcuZmlsbChVKSx3LnJlc3RvcmUoKSx0aGlzW2hdLmNsaXBQYXRoPXRoaXNba107Y29uc3QgSz1mdCh0aGlzLmJvdW5kaW5nQm94LHRoaXNbaF0ucG9zaXRpb24wKTt0aGlzW2hdLmF0dHJpYnV0ZXMuYV9jbGlwVVY9S319Z2V0UG9pbnRBdExlbmd0aChOKXtyZXR1cm4gT2JqZWN0KGcuZ2V0UG9pbnRBdExlbmd0aCkodGhpc1tiXSxOKX1nZXRUb3RhbExlbmd0aCgpe3JldHVybiBPYmplY3QoZy5nZXRUb3RhbExlbmd0aCkodGhpc1tiXSl9Z2V0IGJsZW5kKCl7cmV0dXJuIHRoaXNbal09PW51bGw/ImF1dG8iOnRoaXNbal19c2V0IGJsZW5kKE4pe3RoaXNbal09Tix0aGlzW2hdJiYodGhpc1toXS5lbmFibGVCbGVuZD10aGlzLmVuYWJsZUJsZW5kKX1nZXQgYm91bmRpbmdCb3goKXtpZih0aGlzW2hdJiZ0aGlzW2hdLmJvdW5kaW5nQm94KXJldHVybiB0aGlzW2hdLmJvdW5kaW5nQm94O2NvbnN0IE49dGhpcy5tZXNoRGF0YTtpZihOKXtjb25zdCB6PU4ucG9zaXRpb24wO2lmKHoubGVuZ3RoKU4uYm91bmRpbmdCb3g9cygpKHopO2Vsc2UgcmV0dXJuW1swLDBdLFswLDBdXTtyZXR1cm4gTi5ib3VuZGluZ0JveH1yZXR1cm5bWzAsMF0sWzAsMF1dfWdldCBib3VuZGluZ0NlbnRlcigpe2NvbnN0IE49dGhpcy5ib3VuZGluZ0JveDtyZXR1cm4gTj9bLjUqKE5bMF1bMF0rTlsxXVswXSksLjUqKE5bMF1bMV0rTlsxXVsxXSldOlswLDBdfWdldCBmaWxsUnVsZSgpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ucnVsZToibm9uemVybyJ9Z2V0IGxpbmVXaWR0aCgpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ubGluZVdpZHRoOjB9Z2V0IGxpbmVDYXAoKXtyZXR1cm4gdGhpc1tFXT90aGlzW0VdLmxpbmVDYXA6IiJ9Z2V0IGxpbmVKb2luKCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5saW5lSm9pbjoiIn1nZXQgbWl0ZXJMaW1pdCgpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ubWl0ZXJMaW1pdDowfWdldCBzdHJva2VTdHlsZSgpe3JldHVybiB0aGlzW0xdJiZ0aGlzW0xdWzNdIT09MD9PYmplY3Qoby5kZWZhdWx0KSh0aGlzW0xdKToiIn1nZXQgbGluZURhc2goKXtyZXR1cm4gdGhpc1tFXT90aGlzW0VdLmxpbmVEYXNoOm51bGx9Z2V0IGxpbmVEYXNoT2Zmc2V0KCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5saW5lRGFzaE9mZnNldDowfWdldCBmaWxsU3R5bGUoKXtyZXR1cm4gdGhpc1tTXSYmdGhpc1tTXVszXSE9PTA/T2JqZWN0KG8uZGVmYXVsdCkodGhpc1tTXSk6IiJ9Z2V0IGdyYWRpZW50KCl7cmV0dXJuIHRoaXNbRl19Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tSXS51X3RleFNhbXBsZXI/e2ltYWdlOnRoaXNbUl0udV90ZXhTYW1wbGVyLl9pbWcsb3B0aW9uczp0aGlzW0NdfTpudWxsfWdldCBlbmFibGVCbGVuZCgpe3JldHVybiB0aGlzW2pdPT09ITB8fHRoaXNbal09PT0hMT90aGlzW2pdOnRoaXNbWl08MXx8dGhpc1tMXSE9bnVsbCYmdGhpc1tMXVszXTwxfHx0aGlzW1NdIT1udWxsJiZ0aGlzW1NdWzNdPDF8fHRoaXNbUl0udV9jb2xvck1hdHJpeCE9bnVsbCYmdGhpc1tSXS51X2NvbG9yTWF0cml4WzE4XTwxfHx0aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IhPW51bGx8fHRoaXMuYmVmb3JlUmVuZGVyfHx0aGlzLmFmdGVyUmVuZGVyfWdldCBmaWx0ZXJDYW52YXMoKXtyZXR1cm4vYmx1cnxkcm9wLXNoYWRvd3x1cmwvLnRlc3QodGhpcy5maWx0ZXIpfWdldCBmaWx0ZXIoKXtyZXR1cm4gdGhpc1tHXS5qb2luKCIgIil9Z2V0IHRyYW5zZm9ybU1hdHJpeCgpe3JldHVybiB0aGlzW0ldfWdldCBpbnZlcnRNYXRyaXgoKXtpZighdGhpc1tEXSl7Y29uc3QgTj1yLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpc1tJXSk7dGhpc1tEXT1OfXJldHVybiB0aGlzW0RdfWdldCB0cmFuc2Zvcm1TY2FsZSgpe2NvbnN0IE49dGhpc1tJXTtyZXR1cm4gTWF0aC5tYXgoTWF0aC5oeXBvdChOWzBdLE5bMV0pLE1hdGguaHlwb3QoTlsyXSxOWzNdKSl9Z2V0IHVuaWZvcm1zKCl7cmV0dXJuIHRoaXNbUl19Z2V0IHBhc3MoKXtyZXR1cm4gdGhpc1tpdF19W3FdKE4pe2NvbnN0IHo9dGhpc1tldF0scD10aGlzW2hdLnBvc2l0aW9uMCxNPU9iamVjdC5lbnRyaWVzKE4uX2F0dHJpYnV0ZSk7Zm9yKGxldCB3PTA7dzxNLmxlbmd0aDt3Kyspe2NvbnN0W1UsS109TVt3XTtpZihVIT09ImFfY29sb3IiJiZVIT09ImFfc291cmNlUmVjdCImJkshPT0iaWdub3JlZCIpe2NvbnN0IFk9eltVXTtpZihVPT09InV2IiYmIVkpe2NvbnN0IFE9dGhpc1toXS5ib3VuZGluZ0JveHx8cygpKHApO3RoaXNbaF0uYXR0cmlidXRlc1tVXT1mdChRLHApfWVsc2V7dGhpc1toXS5hdHRyaWJ1dGVzW1VdPVtdO2ZvcihsZXQgUT0wO1E8cC5sZW5ndGg7USsrKXtjb25zdCBydD1wW1FdO3RoaXNbaF0uYXR0cmlidXRlc1tVXS5wdXNoKFk/WShydCx3LHApOkFycmF5KEsuc2l6ZSkuZmlsbCgwKSl9fX19fWdldCBtZXNoRGF0YSgpe2lmKHRoaXMuX3VwZGF0ZU1hdHJpeCYmdGhpcy50cmFuc2Zvcm1TY2FsZS90aGlzLmNvbnRvdXJzLnNjYWxlPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKSwhdGhpc1toXSl7IXRoaXNbQV0mJiF0aGlzW0VdJiZ0aGlzLnNldEZpbGwoKTtjb25zdCBOPXRoaXNbYl0sej17fTtpZihOJiZOLmxlbmd0aCl7aWYodGhpc1tBXSl0cnl7Y29uc3Qgdz1tKCkoTix0aGlzW0FdKTt3LnBvc2l0aW9ucz13LnBvc2l0aW9ucy5tYXAoVT0+KFUucHVzaCh0aGlzW1pdKSxVKSksdy5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDp3LnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbU10ubWFwKFU9Pk1hdGgucm91bmQoMjU1KlUpKSl9LHouZmlsbD13fWNhdGNoe31pZih0aGlzW0VdKXtjb25zdCB3PXRoaXNbRV0ubGluZURhc2g7bGV0IFU9TjtpZih3KXtjb25zdCBZPXRoaXNbRV0ubGluZURhc2hPZmZzZXQ7VT1PYmplY3QoZy5nZXREYXNoQ29udG91cnMpKE4sdyxZKX1jb25zdCBLPVUubWFwKChZLFEpPT57Y29uc3QgcnQ9WS5sZW5ndGg+MSYmci52ZWMyLmVxdWFscyhZWzBdLFlbWS5sZW5ndGgtMV0pLG50PXRoaXNbRV0uYnVpbGQoWSxydCk7cmV0dXJuIG0oKShbbnRdKX0pO0suZm9yRWFjaChZPT57WS5wb3NpdGlvbnM9WS5wb3NpdGlvbnMubWFwKFE9PihRLnB1c2goLXRoaXNbWl0pLFEpKSxZLmF0dHJpYnV0ZXM9e2FfY29sb3I6QXJyYXkuZnJvbSh7bGVuZ3RoOlkucG9zaXRpb25zLmxlbmd0aH0pLm1hcCgoKT0+dGhpc1tMXS5tYXAoUT0+TWF0aC5yb3VuZCgyNTUqUSkpKX19KSx6LnN0cm9rZT1PYmplY3QoYy5kZWZhdWx0KShLKX19Y29uc3QgcD1PYmplY3QoYy5kZWZhdWx0KShbei5maWxsLHouc3Ryb2tlXSk7cC5maWxsUG9pbnRDb3VudD16LmZpbGw/ei5maWxsLnBvc2l0aW9ucy5sZW5ndGg6MCxwLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQscC5wb3NpdGlvbjA9cC5wb3NpdGlvbnMubWFwKChbdyxVLEtdKT0+W3csVSxLXSkscC51bmlmb3Jtcz10aGlzW1JdLHRoaXNbaF09cCx0aGlzW1JdLnVfdGV4U2FtcGxlciYmdGhpc1skXShwLHRoaXNbQ10pO2NvbnN0IE09dGhpc1tJXTtPYmplY3QoeC5pc1VuaXRUcmFuc2Zvcm0pKE0pfHwodGhpc1tIXShwLE0pLHRoaXNbUl0udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1tKXSgpKSx0aGlzLmNsaXBQYXRoJiZ0aGlzW2h0XSgpLHRoaXNbdHRdJiZ0aGlzW3FdKHRoaXNbdHRdKX1yZXR1cm4gdGhpcy5fdXBkYXRlTWF0cml4JiYodGhpc1toXS5tYXRyaXg9dGhpc1tJXSx0aGlzW0hdKHRoaXNbaF0sdGhpc1tJXSksdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW0pdKCkpLHRoaXNbaF19W0hdKE4seil7Y29uc3R7cG9zaXRpb25zOnAscG9zaXRpb24wOk19PU47Zm9yKGxldCB3PTA7dzxwLmxlbmd0aDt3Kyspe2NvbnN0W1UsS109TVt3XSxZPXBbd107WVswXT1VKnpbMF0rSyp6WzJdK3pbNF0sWVsxXT1VKnpbMV0rSyp6WzNdK3pbNV19dGhpcy5fdXBkYXRlTWF0cml4PSExfVtKXSgpe2NvbnN0IE49dGhpc1tJXSx6PVsuLi50aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcl07aWYoeil7Y29uc3RbcCxNLCx3LFVdPXo7elswXT1wKk5bMF0rTSpOWzJdK05bNF0selsxXT1wKk5bMV0rTSpOWzNdK05bNV0selszXT13Kk5bMF0rVSpOWzJdK05bNF0sels0XT13Kk5bMV0rVSpOWzNdK05bNV0sdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPXp9fVskXShOLHope2Z1bmN0aW9uIHAoUSxydCl7cmV0dXJuIFE9PW51bGwmJnJ0PT1udWxsPyEwOlE9PW51bGx8fHJ0PT1udWxsPyExOlFbMF09PT1ydFswXSYmUVsxXT09PXJ0WzFdJiZRWzJdPT09cnRbMl0mJlFbM109PT1ydFszXX1jb25zdCBNPXRoaXNbUl0udV90ZXhTYW1wbGVyO2lmKCFNKXJldHVybjtjb25zdHt3aWR0aDp3LGhlaWdodDpVfT1NLl9pbWcsSz16LnNyY1JlY3Q7bGV0IFk9ei5yZWN0fHxbMCwwXTtpZih6LnJvdGF0ZWQmJihZPVstWVsxXSxZWzBdLFlbM10sWVsyXV0pLFlbMl09PW51bGwmJihZWzJdPUs/S1syXTp3KSxZWzNdPT1udWxsJiYoWVszXT1LP0tbM106VSksei5oaWRkZW4pTi50ZXh0dXJlQ29vcmQ9Ti5wb3NpdGlvbnMubWFwKCgpPT5bLTEsLTEsLTFdKTtlbHNlIGlmKCFOLnRleHR1cmVDb29yZHx8IXAodGhpc1tDXS5yZWN0LHoucmVjdCl8fHRoaXNbQ10uaGlkZGVuIT09ei5oaWRkZW58fHRoaXNbQ10ucm90YXRlZCE9PXoucm90YXRlZCl7bGV0IFE9bnVsbDt6LnJvdGF0ZWQmJihRPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxyLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLC41Kk1hdGguUEkpLFE9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFEsWzAsLVlbMl1dKSksTi50ZXh0dXJlQ29vcmQ9Ti5wb3NpdGlvbjAubWFwKChbcnQsbnQsYXRdKT0+e2lmKDEvYXQ+MCl7aWYoei5yb3RhdGVkKXtjb25zdCBvdD1ydCpRWzBdK250KlFbMl0rUVs0XSxzdD1ydCpRWzFdK250KlFbM10rUVs1XTtbcnQsbnRdPVtvdCxzdF19Y29uc3QgY3Q9QihbcnQsbnRdLFtZWzBdL1lbMl0sWVsxXS9ZWzNdLFlbMl0sWVszXV0seik7cmV0dXJuIHoucmVwZWF0JiYoY3RbMl09MSksY3R9cmV0dXJuWy0xLC0xLC0xXX0pfWlmKEspe2NvbnN0IFE9W0tbMF0vdyxLWzFdL1UsS1syXS93LEtbM10vVV07Ti5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1OLnBvc2l0aW9ucy5tYXAoKCk9PlsuLi5RXSl9ZWxzZSBOLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0PU4ucG9zaXRpb25zLm1hcCgoKT0+WzAsMCwwLDBdKX1hY2N1cmF0ZShOKXtpZighdGhpcy5jb250b3VycylyZXR1cm47aWYodGhpcy5jb250b3Vycy5wYXRoKXtjb25zdCBwPXRoaXMuY29udG91cnMuc2ltcGxpZnksTT1XKHRoaXMuY29udG91cnMucGF0aCwyKk4scCk7dGhpc1toXT1udWxsLHRoaXNbYl09TX19Y2FuSWdub3JlKCl7Y29uc3QgTj10aGlzW0VdPT1udWxsfHx0aGlzW0VdLmxpbmVXaWR0aD09PTB8fHRoaXNbTF1bM109PT0wLHo9dGhpc1tBXT09bnVsbHx8dGhpc1tTXVszXT09PTAscD10aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3I9PW51bGwsTT10aGlzW1JdLnVfdGV4U2FtcGxlcj09bnVsbDtyZXR1cm4gdGhpc1taXT09PTB8fHRoaXNbdHRdPT1udWxsJiZOJiZ6JiZwJiZNJiYhdGhpcy5iZWZvcmVSZW5kZXImJiF0aGlzLmFmdGVyUmVuZGVyfXNldFN0cm9rZSh7dGhpY2tuZXNzOk49MSxjYXA6ej0iYnV0dCIsam9pbjpwPSJtaXRlciIsbWl0ZXJMaW1pdDpNPTEwLGNvbG9yOnc9WzAsMCwwLDBdLGxpbmVEYXNoOlU9bnVsbCxsaW5lRGFzaE9mZnNldDpLPTAscm91bmRTZWdtZW50czpZPTIwfT17fSl7cmV0dXJuIHRoaXNbaF09bnVsbCx0aGlzW0VdPW5ldyBsLmRlZmF1bHQoe2xpbmVXaWR0aDpOLGxpbmVDYXA6eixsaW5lSm9pbjpwLG1pdGVyTGltaXQ6TSxyb3VuZFNlZ21lbnRzOll9KSx0eXBlb2Ygdz09InN0cmluZyImJih3PU9iamVjdCh2LmRlZmF1bHQpKHcpKSx0aGlzW0xdPXcsdGhpc1tFXS5saW5lRGFzaD1VLHRoaXNbRV0ubGluZURhc2hPZmZzZXQ9Syx0aGlzfXNldEZpbGwoe3J1bGU6Tj10aGlzLmZpbGxSdWxlLGNvbG9yOno9WzAsMCwwLDBdfT17fSl7cmV0dXJuIHRoaXNbaF09bnVsbCx0aGlzW0FdPXtydWxlOk59LHR5cGVvZiB6PT0ic3RyaW5nIiYmKHo9T2JqZWN0KHYuZGVmYXVsdCkoeikpLHRoaXNbU109eix0aGlzfXNldFRleHR1cmUoTix6PXt9KXtpZihOJiZOLmltYWdlKXtjb25zdHtpbWFnZTpwLHJlY3Q6TX09TjtpZihOPXAsei5yZWN0KWZvcihsZXQgdz0wO3c8ei5yZWN0Lmxlbmd0aDt3KyspTVt3XT16LnJlY3Rbd107ei5yZWN0PU19cmV0dXJuIHRoaXNbQV18fHRoaXMuc2V0RmlsbCgpLHRoaXMuc2V0VW5pZm9ybXMoe3VfdGV4U2FtcGxlcjpOfSksdGhpc1toXSYmdGhpc1skXSh0aGlzW2hdLHopLHRoaXNbQ109eix0aGlzfXNldENpcmN1bGFyR3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczp6LHR5cGU6cD0iZmlsbCJ9PXt9KXtpZihOLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6eix0eXBlOnB9KX1zZXRMaW5lYXJHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOnosdHlwZTpwPSJmaWxsIn09e30pe2lmKE4ubGVuZ3RoIT09NCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVhckdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczp6LHR5cGU6cH0pfXNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6eix0eXBlOnA9ImZpbGwifT17fSl7aWYoTi5sZW5ndGghPT02KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcmFkaWFsR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOnosdHlwZTpwfSl9c2V0R3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczp6LHR5cGU6cD0iZmlsbCJ9PXt9KXt6PXoubWFwKCh7b2Zmc2V0OlUsY29sb3I6S30pPT4odHlwZW9mIEs9PSJzdHJpbmciJiYoSz1PYmplY3Qodi5kZWZhdWx0KShLKSkse29mZnNldDpVLGNvbG9yOkt9KSksdGhpc1tGXT10aGlzW0ZdfHx7fSx0aGlzW0ZdW3BdPXt2ZWN0b3I6Tixjb2xvcnM6en0sei5zb3J0KChVLEspPT5VLm9mZnNldC1LLm9mZnNldCk7Y29uc3QgTT1bXTt6LmZvckVhY2goKHtvZmZzZXQ6VSxjb2xvcjpLfSk9PntNLnB1c2goVSwuLi5LKX0pO2xldCB3O2lmKE4ubGVuZ3RoPT09ND93PVtOWzBdLE5bMV0sMCxOWzJdLE5bM10sMF06dz1bLi4uTl0sTS5sZW5ndGg8NDAmJk0ucHVzaCgtMSksTS5sZW5ndGg+NDApdGhyb3cgbmV3IEVycm9yKCJUb28gbWFueSBjb2xvcnMsIHNob3VsZCBiZSBsZXNzIHRoYW4gOCBjb2xvcnMiKTtyZXR1cm4gdGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3I9dyx0aGlzW1JdLnVfY29sb3JTdGVwcz1NLHA9PT0iZmlsbCI/dGhpc1tSXS51X2dyYWRpZW50VHlwZT0xOnRoaXNbUl0udV9ncmFkaWVudFR5cGU9MCx0aGlzW0pdKCksdGhpc31zZXRVbmlmb3JtcyhOPXt9KXtyZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzW1JdLE4pLHRoaXN9c2V0VHJhbnNmb3JtKC4uLk4pe2NvbnN0IHo9dGhpc1tJXTtyZXR1cm4gci5tYXQyZC5lcXVhbHMoTix6KXx8KHRoaXNbSV09TixkZWxldGUgdGhpc1tEXSx0aGlzLl91cGRhdGVNYXRyaXg9ITApLHRoaXN9dHJhbnNmb3JtKC4uLk4pe2NvbnN0IHo9dGhpc1tJXTtyZXR1cm4gdGhpc1tJXT1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx6LE4pLGRlbGV0ZSB0aGlzW0RdLHRoaXMuX3VwZGF0ZU1hdHJpeD0hMCx0aGlzfXRyYW5zbGF0ZShOLHope2xldCBwPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIHA9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHAsW04sel0pLHRoaXMudHJhbnNmb3JtKC4uLnApfXJvdGF0ZShOLFt6LHBdPVswLDBdKXtsZXQgTT1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBNPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxNLFt6LHBdKSxNPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxNLE4pLE09ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE0sWy16LC1wXSksdGhpcy50cmFuc2Zvcm0oLi4uTSl9c2NhbGUoTix6PU4sW3AsTV09WzAsMF0pe2xldCB3PXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIHc9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsW3AsTV0pLHc9ci5tYXQyZC5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCksdyxbTix6XSksdz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksdyxbLXAsLU1dKSx0aGlzLnRyYW5zZm9ybSguLi53KX1za2V3KE4sej1OLFtwLE1dPVswLDBdKXtsZXQgdz1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiB3PXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx3LFtwLE1dKSx3PXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oeiksTWF0aC50YW4oTiksMSwwLDApKSx3PXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx3LFstcCwtTV0pLHRoaXMudHJhbnNmb3JtKC4uLncpfWNsZWFyRmlsdGVyKCl7cmV0dXJuIHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0obnVsbCksdGhpc1tHXS5sZW5ndGg9MCx0aGlzfXNldENvbG9yVHJhbnNmb3JtKC4uLk4pe3JldHVybiBOWzBdPT09bnVsbD90aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MCx1X2NvbG9yTWF0cml4OjB9KTp0aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MSx1X2NvbG9yTWF0cml4Ok59KSx0aGlzfXRyYW5zZm9ybUNvbG9yKC4uLk4pe2xldCB6PXRoaXMudW5pZm9ybXMudV9jb2xvck1hdHJpeDtyZXR1cm4gej96PU9iamVjdChmLm11bHRpcGx5KSh6LE4pOno9Tix0aGlzLnNldENvbG9yVHJhbnNmb3JtKC4uLnopLHRoaXN9Ymx1cihOKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBibHVyKCR7Tn1weClgKSx0aGlzfWJyaWdodG5lc3MoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBicmlnaHRuZXNzKCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLmJyaWdodG5lc3MpKE4pKX1jb250cmFzdChOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYGNvbnRyYXN0KCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLmNvbnRyYXN0KShOKSl9ZHJvcFNoYWRvdyhOLHoscD0wLE09WzAsMCwwLDFdKXtyZXR1cm4gQXJyYXkuaXNBcnJheShNKSYmKE09T2JqZWN0KG8uZGVmYXVsdCkoTSkpLHRoaXNbR10ucHVzaChgZHJvcC1zaGFkb3coJHtOfXB4ICR7en1weCAke3B9cHggJHtNfSlgKSx0aGlzfWdyYXlzY2FsZShOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYGdyYXlzY2FsZSgkezEwMCpOfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5ncmF5c2NhbGUpKE4pKX1odWVSb3RhdGUoTj0wKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBodWUtcm90YXRlKCR7Tn1kZWcpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5odWVSb3RhdGUpKE4pKX1pbnZlcnQoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBpbnZlcnQoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuaW52ZXJ0KShOKSl9b3BhY2l0eShOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYG9wYWNpdHkoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYub3BhY2l0eSkoTikpfXNhdHVyYXRlKE49MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgc2F0dXJhdGUoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuc2F0dXJhdGUpKE4pKX1zZXBpYShOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYHNlcGlhKCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLnNlcGlhKShOKSl9dXJsKE4pe3JldHVybiB0aGlzW0ddLnB1c2goYHVybCgke059KWApLHRoaXN9aXNQb2ludENvbGxpc2lvbihOLHoscD0iYm90aCIpe2NvbnN0IE09dGhpcy5tZXNoRGF0YSx7cG9zaXRpb25zOncsY2VsbHM6VX09TSxLPXRoaXMuaW52ZXJ0TWF0cml4LFk9S1swXSpOK0tbMl0qeitLWzRdLFE9S1sxXSpOK0tbM10qeitLWzVdLHJ0PXRoaXMuYm91bmRpbmdCb3g7aWYoWTxydFswXVswXXx8WT5ydFsxXVswXXx8UTxydFswXVsxXXx8UT5ydFsxXVsxXSlyZXR1cm4hMTtmdW5jdGlvbiBudChbYXQsY3RdLFtvdCxzdF0sW2x0LG10XSl7Y29uc3QgcHQ9bHQtb3QsZHQ9bXQtc3QseXQ9KChhdC1vdCkqcHQrKGN0LXN0KSpkdCkvKHB0KioyK2R0KioyKTtyZXR1cm4geXQ+PTAmJnl0PD0xfWZvcihsZXQgYXQ9MDthdDxVLmxlbmd0aDthdCsrKXtjb25zdCBjdD1VW2F0XTtpZihwPT09ImZpbGwiJiZjdFswXT49TS5maWxsUG9pbnRDb3VudClicmVhaztpZihwPT09InN0cm9rZSImJmN0WzBdPE0uZmlsbFBvaW50Q291bnQpY29udGludWU7Y29uc3RbW290LHN0XSxbbHQsbXRdLFtwdCxkdF1dPWN0Lm1hcChNdD0+d1tNdF0pLHl0PU1hdGguc2lnbigoTi1vdCkqKG10LXN0KS0obHQtb3QpKih6LXN0KSk7aWYoeXQ9PT0wJiZudChbTix6XSxbb3Qsc3RdLFtsdCxtdF0pKXJldHVybiEwO2NvbnN0IEF0PU1hdGguc2lnbigoTi1sdCkqKGR0LW10KS0ocHQtbHQpKih6LW10KSk7aWYoQXQ9PT0wJiZudChbTix6XSxbbHQsbXRdLFtwdCxkdF0pKXJldHVybiEwO2NvbnN0IFN0PU1hdGguc2lnbigoTi1wdCkqKHN0LWR0KS0ob3QtcHQpKih6LWR0KSk7aWYoU3Q9PT0wJiZudChbTix6XSxbcHQsZHRdLFtvdCxzdF0pfHx5dD09PTEmJkF0PT09MSYmU3Q9PT0xfHx5dD09PS0xJiZBdD09PS0xJiZTdD09PS0xKXJldHVybiEwfXJldHVybiExfWlzUG9pbnRJbkZpbGwoTix6KXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKE4seiwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShOLHope3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oTix6LCJzdHJva2UiKX1hZGRQYXNzKE4sej17fSl7bGV0e3dpZHRoOnAsaGVpZ2h0Ok19PXosdz11KHosWyJ3aWR0aCIsImhlaWdodCJdKTtjb25zdCBVPW5ldyBQLmRlZmF1bHQ7VS5yZWN0KDAsMCxwLE0pO2NvbnN0IEs9bmV3IFYoVSx7d2lkdGg6cCxoZWlnaHQ6TX0pO0suc2V0VW5pZm9ybXModyksSy5zZXRQcm9ncmFtKE4pLHRoaXNbaXRdLnB1c2goSyl9fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKTt2YXIgcj10KDU4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuU3Ryb2tlfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJTdHJva2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDQ5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj1PYmplY3Qoci5jcmVhdGUpKCkscz1PYmplY3Qoci5jcmVhdGUpKCksbD1PYmplY3Qoci5jcmVhdGUpKCksYz1PYmplY3Qoci5jcmVhdGUpKCksbz1PYmplY3Qoci5jcmVhdGUpKCksZj0xZTIwO2NsYXNzIHh7Y29uc3RydWN0b3Ioe2xpbmVXaWR0aDpPPTEsbGluZUpvaW46dj0ibWl0ZXIiLG1pdGVyTGltaXQ6UD0xMCxsaW5lQ2FwOmk9ImJ1dHQiLHJvdW5kU2VnbWVudHM6dT0yMH09e30pe3RoaXMubGluZVdpZHRoPU8sdGhpcy5saW5lSm9pbj12LHRoaXMubWl0ZXJMaW1pdD1QLHRoaXMubGluZUNhcD1pLHRoaXMucm91bmRTZWdtZW50cz11LHRoaXMuX25vcm1hbD1udWxsfWJ1aWxkKE8sdj0hMSl7bGV0IFA9Ty5sZW5ndGg7aWYoTz1bLi4uT10sUDwyKXJldHVybiBPO3YmJigoT1swXVswXSE9PU9bUC0xXVswXXx8T1swXVsxXSE9PU9bUC0xXVsxXSkmJk8ucHVzaChbLi4uT1swXV0pLE8ucHVzaChbLi4uT1sxXV0pKSxQPU8ubGVuZ3RoLHRoaXMuX25vcm1hbD1udWxsO2NvbnN0IGk9e2xlZnQ6W10scmlnaHQ6W119LHU9dGhpcy5saW5lV2lkdGgvMixhPXRoaXMubGluZUNhcDtpZighdiYmYT09PSJzcXVhcmUiKXtPYmplY3Qoci5kaXJlY3Rpb24pKHMsT1swXSxPWzFdKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkoT1swXSxPWzBdLHMsdSk7Y29uc3QgYj1PLmxlbmd0aC0xO09iamVjdChyLmRpcmVjdGlvbikocyxPW2JdLE9bYi0xXSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKE9bYl0sT1tiXSxzLHUpfWZvcihsZXQgYj0xO2I8UDtiKyspe2NvbnN0IEU9T1tiLTFdLEE9T1tiXSxMPU9bYisxXTt0aGlzLl9zZWcoaSxFLEEsTCx1LHYpfXJldHVybiF2JiZhPT09InJvdW5kIiYmbShpLHRoaXMucm91bmRTZWdtZW50cyksWy4uLmkubGVmdCwuLi5pLnJpZ2h0LnJldmVyc2UoKV19X3NlZyhPLHYsUCxpLHUsYSl7Y29uc3QgaD10aGlzLmxpbmVKb2luPT09ImJldmVsIixiPXRoaXMubGluZUpvaW49PT0icm91bmQiO2lmKE9iamVjdChyLmRpcmVjdGlvbikocyxQLHYpLHRoaXMuX25vcm1hbHx8KHRoaXMuX25vcm1hbD1PYmplY3Qoci5jcmVhdGUpKCksT2JqZWN0KHIubm9ybWFsKSh0aGlzLl9ub3JtYWwscykpLE8ubGVmdC5sZW5ndGh8fHkoTyx2LHRoaXMuX25vcm1hbCx1KSwhaSlPYmplY3Qoci5ub3JtYWwpKHRoaXMuX25vcm1hbCxzKSxhP3koTyx2LHRoaXMuX25vcm1hbCx1KTp5KE8sUCx0aGlzLl9ub3JtYWwsdSk7ZWxzZXtPYmplY3Qoci5kaXJlY3Rpb24pKGwsaSxQKTtsZXQgRT1PYmplY3Qoci5jb21wdXRlTWl0ZXIpKGMsbyxzLGwsdSk7RT1NYXRoLm1pbihFLGYpO2NvbnN0IEE9T2JqZWN0KHIuZG90KShjLHRoaXMuX25vcm1hbCk8MD8tMToxO2xldCBMPWh8fGI7aWYoIUwmJnRoaXMubGluZUpvaW49PT0ibWl0ZXIiJiZFL3U+dGhpcy5taXRlckxpbWl0JiYoTD0hMCksTCl7T2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4sUCx0aGlzLl9ub3JtYWwsLXUqQSksZyhPLG4sQSk7bGV0IFM9MS8wO3YmJihTPU1hdGgubWluKFMsTWF0aC5oeXBvdChQWzBdLXZbMF0sUFsxXS12WzFdKSkpLGkmJihTPU1hdGgubWluKFMsTWF0aC5oeXBvdChpWzBdLVBbMF0saVsxXS1QWzFdKSkpO2NvbnN0IEk9TWF0aC5tYXgodSxNYXRoLm1pbihFLFMpKTtpZihPYmplY3Qoci5zY2FsZUFuZEFkZCkobixQLG8sSSpBKSxnKE8sbiwtQSksaSlpZihPYmplY3Qoci5ub3JtYWwpKG4sbCksT2JqZWN0KHIuY29weSkodGhpcy5fbm9ybWFsLG4pLE9iamVjdChyLnNjYWxlQW5kQWRkKShuLFAsbiwtdSpBKSxiKXtjb25zdCBEPU9iamVjdChyLmNsb25lKShuKSxSPUE+MD9PLmxlZnRbTy5sZWZ0Lmxlbmd0aC0xXTpPLnJpZ2h0W08ucmlnaHQubGVuZ3RoLTFdLEM9T2JqZWN0KHIuY2xvbmUpKFApLGo9T2JqZWN0KHIuc3ViKShPYmplY3Qoci5jcmVhdGUpKCksUixDKSwkPU9iamVjdChyLnN1YikoT2JqZWN0KHIuY3JlYXRlKSgpLEQsQyksSD1NYXRoLlBJL3RoaXMucm91bmRTZWdtZW50cztmb3IobGV0IEo9MDtKPHRoaXMucm91bmRTZWdtZW50cyYmKE9iamVjdChyLnJvdGF0ZSkoaixqLFswLDBdLEEqSCksTWF0aC5zaWduKE9iamVjdChyLmNyb3NzKShuLGosJClbMl0pPT09QSk7SisrKU9iamVjdChyLmFkZCkobixqLEMpLGcoTyxuLEEpO2coTyxELEEpfWVsc2UgZyhPLG4sQSl9ZWxzZSB5KE8sUCxvLEUpLE9iamVjdChyLmNvcHkpKHRoaXMuX25vcm1hbCxvKX19fWZ1bmN0aW9uIGcoVCxPLHYpe3Y+MD9ULmxlZnQucHVzaChPYmplY3Qoci5jbG9uZSkoTykpOlQucmlnaHQucHVzaChPYmplY3Qoci5jbG9uZSkoTykpfWZ1bmN0aW9uIHkoVCxPLHYsUCxpPS0xKXtPYmplY3Qoci5zY2FsZUFuZEFkZCkobixPLHYsLVApLGcoVCxuLC1pKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkobixPLHYsUCksZyhULG4saSl9ZnVuY3Rpb24gbSh7bGVmdDpULHJpZ2h0Ok99LHYpe2NvbnN0IFA9T2JqZWN0KHIuY3JlYXRlKSgpLGk9T2JqZWN0KHIuY3JlYXRlKSgpO2xldCB1PVRbMF0sYT1PWzBdLGg9Wy41Kih1WzBdK2FbMF0pLC41Kih1WzFdK2FbMV0pXTtPYmplY3Qoci5zdWIpKGksdSxoKTtmb3IobGV0IGI9MTtiPD12O2IrKyl7Y29uc3QgRT0tMSpNYXRoLlBJKmIvdjtPYmplY3Qoci5yb3RhdGUpKFAsaSxbMCwwXSxFKSxPYmplY3Qoci5hZGQpKG4saCxQKSxULnVuc2hpZnQoT2JqZWN0KHIuY2xvbmUpKG4pKX11PU9bTy5sZW5ndGgtMV0sYT1UW1QubGVuZ3RoLTFdLGg9Wy41Kih1WzBdK2FbMF0pLC41Kih1WzFdK2FbMV0pXSxPYmplY3Qoci5zdWIpKGksdSxoKTtmb3IobGV0IGI9MTtiPD12O2IrKyl7Y29uc3QgRT0tMSpNYXRoLlBJKmIvdjtPYmplY3Qoci5yb3RhdGUpKFAsaSxbMCwwXSxFKSxPYmplY3Qoci5hZGQpKG4saCxQKSxPLnB1c2goT2JqZWN0KHIuY2xvbmUpKG4pKX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJpc1VuaXRUcmFuc2Zvcm0iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihuKXtyZXR1cm4gblswXT09PTEmJm5bMV09PT0wJiZuWzJdPT09MCYmblszXT09PTEmJm5bNF09PT0wJiZuWzVdPT09MH19LGZ1bmN0aW9uKGQsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9dCg2MSksbj10KDYyKTtkLmV4cG9ydHM9ZnVuY3Rpb24ocyxsKXtpZihsPWx8fHt9LHM9cy5maWx0ZXIoZnVuY3Rpb24odil7cmV0dXJuIHYubGVuZ3RoPjJ9KSxzLmxlbmd0aD09PTApcmV0dXJue3Bvc2l0aW9uczpbXSxjZWxsczpbXX07dHlwZW9mIGwudmVydGV4U2l6ZSE9Im51bWJlciImJihsLnZlcnRleFNpemU9c1swXVswXS5sZW5ndGgpLHM9cy5tYXAoZnVuY3Rpb24odil7cmV0dXJuIHYucmVkdWNlKGZ1bmN0aW9uKFAsaSl7cmV0dXJuIFAuY29uY2F0KGkpfSl9KTtjb25zdCBjPWwucnVsZT09PSJldmVub2RkIj9yLldJTkRJTkdfT0REOnIuV0lORElOR19OT05aRVJPO2Zvcih2YXIgbz1yLnRlc3NlbGF0ZShuKHtjb250b3VyczpzLHdpbmRpbmdSdWxlOmMsZWxlbWVudFR5cGU6ci5QT0xZR09OUyxwb2x5U2l6ZTozLHZlcnRleFNpemU6Mn0sbCkpLGY9W10seD0wO3g8by52ZXJ0aWNlcy5sZW5ndGg7eCs9bC52ZXJ0ZXhTaXplKXt2YXIgZz1vLnZlcnRpY2VzLnNsaWNlKHgseCtsLnZlcnRleFNpemUpO2YucHVzaChnKX12YXIgeT1bXTtmb3IoeD0wO3g8by5lbGVtZW50cy5sZW5ndGg7eCs9Myl7dmFyIG09by5lbGVtZW50c1t4XSxUPW8uZWxlbWVudHNbeCsxXSxPPW8uZWxlbWVudHNbeCsyXTt5LnB1c2goW20sVCxPXSl9cmV0dXJue3Bvc2l0aW9uczpmLGNlbGxzOnl9fX0sZnVuY3Rpb24oZCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgcj17fSxuPXt9O2QuZXhwb3J0cz1yLHIuV0lORElOR19PREQ9MCxyLldJTkRJTkdfTk9OWkVSTz0xLHIuV0lORElOR19QT1NJVElWRT0yLHIuV0lORElOR19ORUdBVElWRT0zLHIuV0lORElOR19BQlNfR0VRX1RXTz00LHIuUE9MWUdPTlM9MCxyLkNPTk5FQ1RFRF9QT0xZR09OUz0xLHIuQk9VTkRBUllfQ09OVE9VUlM9MixyLnRlc3NlbGF0ZT1mdW5jdGlvbihpKXtmb3IodmFyIHU9aS5kZWJ1Z3x8ITEsYT1uZXcgUCxoPTA7aDxpLmNvbnRvdXJzLmxlbmd0aDtoKyspYS5hZGRDb250b3VyKGkudmVydGV4U2l6ZXx8MixpLmNvbnRvdXJzW2hdKTtyZXR1cm4gYS50ZXNzZWxhdGUoaS53aW5kaW5nUnVsZXx8ci5XSU5ESU5HX09ERCxpLmVsZW1lbnRUeXBlfHxyLlBPTFlHT05TLGkucG9seVNpemV8fDMsaS52ZXJ0ZXhTaXplfHwyLGkubm9ybWFsfHxbMCwwLDFdKSx7dmVydGljZXM6YS52ZXJ0aWNlcyx2ZXJ0ZXhJbmRpY2VzOmEudmVydGV4SW5kaWNlcyx2ZXJ0ZXhDb3VudDphLnZlcnRleENvdW50LGVsZW1lbnRzOmEuZWxlbWVudHMsZWxlbWVudENvdW50OmEuZWxlbWVudENvdW50LG1lc2g6dT9hLm1lc2g6dm9pZCAwfX07dmFyIHM9ZnVuY3Rpb24oaSl7aWYoIWkpdGhyb3ciQXNzZXJ0aW9uIEZhaWxlZCEifTtmdW5jdGlvbiBsKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLmNvb3Jkcz1bMCwwLDBdLHRoaXMucz0wLHRoaXMudD0wLHRoaXMucHFIYW5kbGU9MCx0aGlzLm49MCx0aGlzLmlkeD0wfWZ1bmN0aW9uIGMoKXt0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbCx0aGlzLmFuRWRnZT1udWxsLHRoaXMudHJhaWw9bnVsbCx0aGlzLm49MCx0aGlzLm1hcmtlZD0hMSx0aGlzLmluc2lkZT0hMX1mdW5jdGlvbiBvKGkpe3RoaXMubmV4dD1udWxsLHRoaXMuU3ltPW51bGwsdGhpcy5PbmV4dD1udWxsLHRoaXMuTG5leHQ9bnVsbCx0aGlzLk9yZz1udWxsLHRoaXMuTGZhY2U9bnVsbCx0aGlzLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMud2luZGluZz0wLHRoaXMuc2lkZT1pfW8ucHJvdG90eXBlPXtnZXQgUmZhY2UoKXtyZXR1cm4gdGhpcy5TeW0uTGZhY2V9LHNldCBSZmFjZShpKXt0aGlzLlN5bS5MZmFjZT1pfSxnZXQgRHN0KCl7cmV0dXJuIHRoaXMuU3ltLk9yZ30sc2V0IERzdChpKXt0aGlzLlN5bS5Pcmc9aX0sZ2V0IE9wcmV2KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0fSxzZXQgT3ByZXYoaSl7dGhpcy5TeW0uTG5leHQ9aX0sZ2V0IExwcmV2KCl7cmV0dXJuIHRoaXMuT25leHQuU3ltfSxzZXQgTHByZXYoaSl7dGhpcy5PbmV4dC5TeW09aX0sZ2V0IERwcmV2KCl7cmV0dXJuIHRoaXMuTG5leHQuU3ltfSxzZXQgRHByZXYoaSl7dGhpcy5MbmV4dC5TeW09aX0sZ2V0IFJwcmV2KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0fSxzZXQgUnByZXYoaSl7dGhpcy5TeW0uT25leHQ9aX0sZ2V0IERuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0LlN5bX0sc2V0IERuZXh0KGkpe3RoaXMuU3ltLk9uZXh0LlN5bT1pfSxnZXQgUm5leHQoKXtyZXR1cm4gdGhpcy5TeW0uTG5leHQuU3ltfSxzZXQgUm5leHQoaSl7dGhpcy5TeW0uTG5leHQuU3ltPWl9fTtmdW5jdGlvbiBmKCl7dmFyIGk9bmV3IGwsdT1uZXcgYyxhPW5ldyBvKDApLGg9bmV3IG8oMSk7aS5uZXh0PWkucHJldj1pLGkuYW5FZGdlPW51bGwsdS5uZXh0PXUucHJldj11LHUuYW5FZGdlPW51bGwsdS50cmFpbD1udWxsLHUubWFya2VkPSExLHUuaW5zaWRlPSExLGEubmV4dD1hLGEuU3ltPWgsYS5PbmV4dD1udWxsLGEuTG5leHQ9bnVsbCxhLk9yZz1udWxsLGEuTGZhY2U9bnVsbCxhLndpbmRpbmc9MCxhLmFjdGl2ZVJlZ2lvbj1udWxsLGgubmV4dD1oLGguU3ltPWEsaC5PbmV4dD1udWxsLGguTG5leHQ9bnVsbCxoLk9yZz1udWxsLGguTGZhY2U9bnVsbCxoLndpbmRpbmc9MCxoLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMudkhlYWQ9aSx0aGlzLmZIZWFkPXUsdGhpcy5lSGVhZD1hLHRoaXMuZUhlYWRTeW09aH1mLnByb3RvdHlwZT17bWFrZUVkZ2VfOmZ1bmN0aW9uKGkpe3ZhciB1PW5ldyBvKDApLGE9bmV3IG8oMSk7aS5TeW0uc2lkZTxpLnNpZGUmJihpPWkuU3ltKTt2YXIgaD1pLlN5bS5uZXh0O3JldHVybiBhLm5leHQ9aCxoLlN5bS5uZXh0PXUsdS5uZXh0PWksaS5TeW0ubmV4dD1hLHUuU3ltPWEsdS5PbmV4dD11LHUuTG5leHQ9YSx1Lk9yZz1udWxsLHUuTGZhY2U9bnVsbCx1LndpbmRpbmc9MCx1LmFjdGl2ZVJlZ2lvbj1udWxsLGEuU3ltPXUsYS5PbmV4dD1hLGEuTG5leHQ9dSxhLk9yZz1udWxsLGEuTGZhY2U9bnVsbCxhLndpbmRpbmc9MCxhLmFjdGl2ZVJlZ2lvbj1udWxsLHV9LHNwbGljZV86ZnVuY3Rpb24oaSx1KXt2YXIgYT1pLk9uZXh0LGg9dS5PbmV4dDthLlN5bS5MbmV4dD11LGguU3ltLkxuZXh0PWksaS5PbmV4dD1oLHUuT25leHQ9YX0sbWFrZVZlcnRleF86ZnVuY3Rpb24oaSx1LGEpe3ZhciBoPWk7cyhoIT09bnVsbCk7dmFyIGI9YS5wcmV2O2gucHJldj1iLGIubmV4dD1oLGgubmV4dD1hLGEucHJldj1oLGguYW5FZGdlPXU7dmFyIEU9dTtkbyBFLk9yZz1oLEU9RS5PbmV4dDt3aGlsZShFIT09dSl9LG1ha2VGYWNlXzpmdW5jdGlvbihpLHUsYSl7dmFyIGg9aTtzKGghPT1udWxsKTt2YXIgYj1hLnByZXY7aC5wcmV2PWIsYi5uZXh0PWgsaC5uZXh0PWEsYS5wcmV2PWgsaC5hbkVkZ2U9dSxoLnRyYWlsPW51bGwsaC5tYXJrZWQ9ITEsaC5pbnNpZGU9YS5pbnNpZGU7dmFyIEU9dTtkbyBFLkxmYWNlPWgsRT1FLkxuZXh0O3doaWxlKEUhPT11KX0sa2lsbEVkZ2VfOmZ1bmN0aW9uKGkpe2kuU3ltLnNpZGU8aS5zaWRlJiYoaT1pLlN5bSk7dmFyIHU9aS5uZXh0LGE9aS5TeW0ubmV4dDt1LlN5bS5uZXh0PWEsYS5TeW0ubmV4dD11fSxraWxsVmVydGV4XzpmdW5jdGlvbihpLHUpe3ZhciBhPWkuYW5FZGdlLGg9YTtkbyBoLk9yZz11LGg9aC5PbmV4dDt3aGlsZShoIT09YSk7dmFyIGI9aS5wcmV2LEU9aS5uZXh0O0UucHJldj1iLGIubmV4dD1FfSxraWxsRmFjZV86ZnVuY3Rpb24oaSx1KXt2YXIgYT1pLmFuRWRnZSxoPWE7ZG8gaC5MZmFjZT11LGg9aC5MbmV4dDt3aGlsZShoIT09YSk7dmFyIGI9aS5wcmV2LEU9aS5uZXh0O0UucHJldj1iLGIubmV4dD1FfSxtYWtlRWRnZTpmdW5jdGlvbigpe3ZhciBpPW5ldyBsLHU9bmV3IGwsYT1uZXcgYyxoPXRoaXMubWFrZUVkZ2VfKHRoaXMuZUhlYWQpO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKGksaCx0aGlzLnZIZWFkKSx0aGlzLm1ha2VWZXJ0ZXhfKHUsaC5TeW0sdGhpcy52SGVhZCksdGhpcy5tYWtlRmFjZV8oYSxoLHRoaXMuZkhlYWQpLGh9LHNwbGljZTpmdW5jdGlvbihpLHUpe3ZhciBhPSExLGg9ITE7aWYoaSE9PXUpe2lmKHUuT3JnIT09aS5PcmcmJihoPSEwLHRoaXMua2lsbFZlcnRleF8odS5PcmcsaS5PcmcpKSx1LkxmYWNlIT09aS5MZmFjZSYmKGE9ITAsdGhpcy5raWxsRmFjZV8odS5MZmFjZSxpLkxmYWNlKSksdGhpcy5zcGxpY2VfKHUsaSksIWgpe3ZhciBiPW5ldyBsO3RoaXMubWFrZVZlcnRleF8oYix1LGkuT3JnKSxpLk9yZy5hbkVkZ2U9aX1pZighYSl7dmFyIEU9bmV3IGM7dGhpcy5tYWtlRmFjZV8oRSx1LGkuTGZhY2UpLGkuTGZhY2UuYW5FZGdlPWl9fX0sZGVsZXRlOmZ1bmN0aW9uKGkpe3ZhciB1PWkuU3ltLGE9ITE7aWYoaS5MZmFjZSE9PWkuUmZhY2UmJihhPSEwLHRoaXMua2lsbEZhY2VfKGkuTGZhY2UsaS5SZmFjZSkpLGkuT25leHQ9PT1pKXRoaXMua2lsbFZlcnRleF8oaS5PcmcsbnVsbCk7ZWxzZSBpZihpLlJmYWNlLmFuRWRnZT1pLk9wcmV2LGkuT3JnLmFuRWRnZT1pLk9uZXh0LHRoaXMuc3BsaWNlXyhpLGkuT3ByZXYpLCFhKXt2YXIgaD1uZXcgYzt0aGlzLm1ha2VGYWNlXyhoLGksaS5MZmFjZSl9dS5PbmV4dD09PXU/KHRoaXMua2lsbFZlcnRleF8odS5PcmcsbnVsbCksdGhpcy5raWxsRmFjZV8odS5MZmFjZSxudWxsKSk6KGkuTGZhY2UuYW5FZGdlPXUuT3ByZXYsdS5PcmcuYW5FZGdlPXUuT25leHQsdGhpcy5zcGxpY2VfKHUsdS5PcHJldikpLHRoaXMua2lsbEVkZ2VfKGkpfSxhZGRFZGdlVmVydGV4OmZ1bmN0aW9uKGkpe3ZhciB1PXRoaXMubWFrZUVkZ2VfKGkpLGE9dS5TeW07dGhpcy5zcGxpY2VfKHUsaS5MbmV4dCksdS5Pcmc9aS5Ec3Q7dmFyIGg9bmV3IGw7cmV0dXJuIHRoaXMubWFrZVZlcnRleF8oaCxhLHUuT3JnKSx1LkxmYWNlPWEuTGZhY2U9aS5MZmFjZSx1fSxzcGxpdEVkZ2U6ZnVuY3Rpb24oaSx1KXt2YXIgYT10aGlzLmFkZEVkZ2VWZXJ0ZXgoaSksaD1hLlN5bTtyZXR1cm4gdGhpcy5zcGxpY2VfKGkuU3ltLGkuU3ltLk9wcmV2KSx0aGlzLnNwbGljZV8oaS5TeW0saCksaS5Ec3Q9aC5PcmcsaC5Ec3QuYW5FZGdlPWguU3ltLGguUmZhY2U9aS5SZmFjZSxoLndpbmRpbmc9aS53aW5kaW5nLGguU3ltLndpbmRpbmc9aS5TeW0ud2luZGluZyxofSxjb25uZWN0OmZ1bmN0aW9uKGksdSl7dmFyIGE9ITEsaD10aGlzLm1ha2VFZGdlXyhpKSxiPWguU3ltO2lmKHUuTGZhY2UhPT1pLkxmYWNlJiYoYT0hMCx0aGlzLmtpbGxGYWNlXyh1LkxmYWNlLGkuTGZhY2UpKSx0aGlzLnNwbGljZV8oaCxpLkxuZXh0KSx0aGlzLnNwbGljZV8oYix1KSxoLk9yZz1pLkRzdCxiLk9yZz11Lk9yZyxoLkxmYWNlPWIuTGZhY2U9aS5MZmFjZSxpLkxmYWNlLmFuRWRnZT1iLCFhKXt2YXIgRT1uZXcgYzt0aGlzLm1ha2VGYWNlXyhFLGgsaS5MZmFjZSl9cmV0dXJuIGh9LHphcEZhY2U6ZnVuY3Rpb24oaSl7dmFyIHU9aS5hbkVkZ2UsYSxoLGIsRSxBO2g9dS5MbmV4dDtkbyBhPWgsaD1hLkxuZXh0LGEuTGZhY2U9bnVsbCxhLlJmYWNlPT09bnVsbCYmKGEuT25leHQ9PT1hP3RoaXMua2lsbFZlcnRleF8oYS5PcmcsbnVsbCk6KGEuT3JnLmFuRWRnZT1hLk9uZXh0LHRoaXMuc3BsaWNlXyhhLGEuT3ByZXYpKSxiPWEuU3ltLGIuT25leHQ9PT1iP3RoaXMua2lsbFZlcnRleF8oYi5PcmcsbnVsbCk6KGIuT3JnLmFuRWRnZT1iLk9uZXh0LHRoaXMuc3BsaWNlXyhiLGIuT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhhKSk7d2hpbGUoYSE9dSk7RT1pLnByZXYsQT1pLm5leHQsQS5wcmV2PUUsRS5uZXh0PUF9LGNvdW50RmFjZVZlcnRzXzpmdW5jdGlvbihpKXt2YXIgdT1pLmFuRWRnZSxhPTA7ZG8gYSsrLHU9dS5MbmV4dDt3aGlsZSh1IT09aS5hbkVkZ2UpO3JldHVybiBhfSxtZXJnZUNvbnZleEZhY2VzOmZ1bmN0aW9uKGkpe3ZhciB1LGEsaCxiLEUsQSxMO2Zvcih1PXRoaXMuZkhlYWQubmV4dDt1IT09dGhpcy5mSGVhZDt1PXUubmV4dClpZih1Lmluc2lkZSlmb3IoYT11LmFuRWRnZSxFPWEuT3JnO2g9YS5MbmV4dCxiPWEuU3ltLGImJmIuTGZhY2UmJmIuTGZhY2UuaW5zaWRlJiYoQT10aGlzLmNvdW50RmFjZVZlcnRzXyh1KSxMPXRoaXMuY291bnRGYWNlVmVydHNfKGIuTGZhY2UpLEErTC0yPD1pJiZuLnZlcnRDQ1coYS5McHJldi5PcmcsYS5PcmcsYi5MbmV4dC5MbmV4dC5PcmcpJiZuLnZlcnRDQ1coYi5McHJldi5PcmcsYi5PcmcsYS5MbmV4dC5MbmV4dC5PcmcpJiYoaD1iLkxuZXh0LHRoaXMuZGVsZXRlKGIpLGE9bnVsbCxiPW51bGwpKSwhKGEmJmEuTG5leHQuT3JnPT09RSk7KWE9aDtyZXR1cm4hMH0sY2hlY2s6ZnVuY3Rpb24oKXt2YXIgaT10aGlzLmZIZWFkLHU9dGhpcy52SGVhZCxhPXRoaXMuZUhlYWQsaCxiLEUsQSxMLFM7Zm9yKGI9aSxiPWk7KGg9Yi5uZXh0KSE9PWk7Yj1oKXtzKGgucHJldj09PWIpLEw9aC5hbkVkZ2U7ZG8gcyhMLlN5bSE9PUwpLHMoTC5TeW0uU3ltPT09TCkscyhMLkxuZXh0Lk9uZXh0LlN5bT09PUwpLHMoTC5PbmV4dC5TeW0uTG5leHQ9PT1MKSxzKEwuTGZhY2U9PT1oKSxMPUwuTG5leHQ7d2hpbGUoTCE9PWguYW5FZGdlKX1mb3IocyhoLnByZXY9PT1iJiZoLmFuRWRnZT09PW51bGwpLEE9dSxBPXU7KEU9QS5uZXh0KSE9PXU7QT1FKXtzKEUucHJldj09PUEpLEw9RS5hbkVkZ2U7ZG8gcyhMLlN5bSE9PUwpLHMoTC5TeW0uU3ltPT09TCkscyhMLkxuZXh0Lk9uZXh0LlN5bT09PUwpLHMoTC5PbmV4dC5TeW0uTG5leHQ9PT1MKSxzKEwuT3JnPT09RSksTD1MLk9uZXh0O3doaWxlKEwhPT1FLmFuRWRnZSl9Zm9yKHMoRS5wcmV2PT09QSYmRS5hbkVkZ2U9PT1udWxsKSxTPWEsUz1hOyhMPVMubmV4dCkhPT1hO1M9TClzKEwuU3ltLm5leHQ9PT1TLlN5bSkscyhMLlN5bSE9PUwpLHMoTC5TeW0uU3ltPT09TCkscyhMLk9yZyE9PW51bGwpLHMoTC5Ec3QhPT1udWxsKSxzKEwuTG5leHQuT25leHQuU3ltPT09TCkscyhMLk9uZXh0LlN5bS5MbmV4dD09PUwpO3MoTC5TeW0ubmV4dD09PVMuU3ltJiZMLlN5bT09PXRoaXMuZUhlYWRTeW0mJkwuU3ltLlN5bT09PUwmJkwuT3JnPT09bnVsbCYmTC5Ec3Q9PT1udWxsJiZMLkxmYWNlPT09bnVsbCYmTC5SZmFjZT09PW51bGwpfX0sbi52ZXJ0RXE9ZnVuY3Rpb24oaSx1KXtyZXR1cm4gaS5zPT09dS5zJiZpLnQ9PT11LnR9LG4udmVydExlcT1mdW5jdGlvbihpLHUpe3JldHVybiBpLnM8dS5zfHxpLnM9PT11LnMmJmkudDw9dS50fSxuLnRyYW5zTGVxPWZ1bmN0aW9uKGksdSl7cmV0dXJuIGkudDx1LnR8fGkudD09PXUudCYmaS5zPD11LnN9LG4uZWRnZUdvZXNMZWZ0PWZ1bmN0aW9uKGkpe3JldHVybiBuLnZlcnRMZXEoaS5Ec3QsaS5PcmcpfSxuLmVkZ2VHb2VzUmlnaHQ9ZnVuY3Rpb24oaSl7cmV0dXJuIG4udmVydExlcShpLk9yZyxpLkRzdCl9LG4udmVydEwxZGlzdD1mdW5jdGlvbihpLHUpe3JldHVybiBNYXRoLmFicyhpLnMtdS5zKStNYXRoLmFicyhpLnQtdS50KX0sbi5lZGdlRXZhbD1mdW5jdGlvbihpLHUsYSl7cyhuLnZlcnRMZXEoaSx1KSYmbi52ZXJ0TGVxKHUsYSkpO3ZhciBoPXUucy1pLnMsYj1hLnMtdS5zO3JldHVybiBoK2I+MD9oPGI/dS50LWkudCsoaS50LWEudCkqKGgvKGgrYikpOnUudC1hLnQrKGEudC1pLnQpKihiLyhoK2IpKTowfSxuLmVkZ2VTaWduPWZ1bmN0aW9uKGksdSxhKXtzKG4udmVydExlcShpLHUpJiZuLnZlcnRMZXEodSxhKSk7dmFyIGg9dS5zLWkucyxiPWEucy11LnM7cmV0dXJuIGgrYj4wPyh1LnQtYS50KSpoKyh1LnQtaS50KSpiOjB9LG4udHJhbnNFdmFsPWZ1bmN0aW9uKGksdSxhKXtzKG4udHJhbnNMZXEoaSx1KSYmbi50cmFuc0xlcSh1LGEpKTt2YXIgaD11LnQtaS50LGI9YS50LXUudDtyZXR1cm4gaCtiPjA/aDxiP3Uucy1pLnMrKGkucy1hLnMpKihoLyhoK2IpKTp1LnMtYS5zKyhhLnMtaS5zKSooYi8oaCtiKSk6MH0sbi50cmFuc1NpZ249ZnVuY3Rpb24oaSx1LGEpe3Mobi50cmFuc0xlcShpLHUpJiZuLnRyYW5zTGVxKHUsYSkpO3ZhciBoPXUudC1pLnQsYj1hLnQtdS50O3JldHVybiBoK2I+MD8odS5zLWEucykqaCsodS5zLWkucykqYjowfSxuLnZlcnRDQ1c9ZnVuY3Rpb24oaSx1LGEpe3JldHVybiBpLnMqKHUudC1hLnQpK3UucyooYS50LWkudCkrYS5zKihpLnQtdS50KT49MH0sbi5pbnRlcnBvbGF0ZT1mdW5jdGlvbihpLHUsYSxoKXtyZXR1cm4gaT1pPDA/MDppLGE9YTwwPzA6YSxpPD1hP2E9PT0wPyh1K2gpLzI6dSsoaC11KSooaS8oaSthKSk6aCsodS1oKSooYS8oaSthKSl9LG4uaW50ZXJzZWN0PWZ1bmN0aW9uKGksdSxhLGgsYil7dmFyIEUsQSxMO24udmVydExlcShpLHUpfHwoTD1pLGk9dSx1PUwpLG4udmVydExlcShhLGgpfHwoTD1hLGE9aCxoPUwpLG4udmVydExlcShpLGEpfHwoTD1pLGk9YSxhPUwsTD11LHU9aCxoPUwpLG4udmVydExlcShhLHUpP24udmVydExlcSh1LGgpPyhFPW4uZWRnZUV2YWwoaSxhLHUpLEE9bi5lZGdlRXZhbChhLHUsaCksRStBPDAmJihFPS1FLEE9LUEpLGIucz1uLmludGVycG9sYXRlKEUsYS5zLEEsdS5zKSk6KEU9bi5lZGdlU2lnbihpLGEsdSksQT0tbi5lZGdlU2lnbihpLGgsdSksRStBPDAmJihFPS1FLEE9LUEpLGIucz1uLmludGVycG9sYXRlKEUsYS5zLEEsaC5zKSk6Yi5zPShhLnMrdS5zKS8yLG4udHJhbnNMZXEoaSx1KXx8KEw9aSxpPXUsdT1MKSxuLnRyYW5zTGVxKGEsaCl8fChMPWEsYT1oLGg9TCksbi50cmFuc0xlcShpLGEpfHwoTD1pLGk9YSxhPUwsTD11LHU9aCxoPUwpLG4udHJhbnNMZXEoYSx1KT9uLnRyYW5zTGVxKHUsaCk/KEU9bi50cmFuc0V2YWwoaSxhLHUpLEE9bi50cmFuc0V2YWwoYSx1LGgpLEUrQTwwJiYoRT0tRSxBPS1BKSxiLnQ9bi5pbnRlcnBvbGF0ZShFLGEudCxBLHUudCkpOihFPW4udHJhbnNTaWduKGksYSx1KSxBPS1uLnRyYW5zU2lnbihpLGgsdSksRStBPDAmJihFPS1FLEE9LUEpLGIudD1uLmludGVycG9sYXRlKEUsYS50LEEsaC50KSk6Yi50PShhLnQrdS50KS8yfTtmdW5jdGlvbiB4KCl7dGhpcy5rZXk9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbH1mdW5jdGlvbiBnKGksdSl7dGhpcy5oZWFkPW5ldyB4LHRoaXMuaGVhZC5uZXh0PXRoaXMuaGVhZCx0aGlzLmhlYWQucHJldj10aGlzLmhlYWQsdGhpcy5mcmFtZT1pLHRoaXMubGVxPXV9Zy5wcm90b3R5cGU9e21pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQubmV4dH0sbWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5wcmV2fSxpbnNlcnQ6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCxpKX0sc2VhcmNoOmZ1bmN0aW9uKGkpe3ZhciB1PXRoaXMuaGVhZDtkbyB1PXUubmV4dDt3aGlsZSh1LmtleSE9PW51bGwmJiF0aGlzLmxlcSh0aGlzLmZyYW1lLGksdS5rZXkpKTtyZXR1cm4gdX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGksdSl7ZG8gaT1pLnByZXY7d2hpbGUoaS5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxpLmtleSx1KSk7dmFyIGE9bmV3IHg7cmV0dXJuIGEua2V5PXUsYS5uZXh0PWkubmV4dCxpLm5leHQucHJldj1hLGEucHJldj1pLGkubmV4dD1hLGF9LGRlbGV0ZTpmdW5jdGlvbihpKXtpLm5leHQucHJldj1pLnByZXYsaS5wcmV2Lm5leHQ9aS5uZXh0fX07ZnVuY3Rpb24geSgpe3RoaXMuaGFuZGxlPW51bGx9ZnVuY3Rpb24gbSgpe3RoaXMua2V5PW51bGwsdGhpcy5ub2RlPW51bGx9ZnVuY3Rpb24gVChpLHUpe3RoaXMuc2l6ZT0wLHRoaXMubWF4PWksdGhpcy5ub2Rlcz1bXSx0aGlzLm5vZGVzLmxlbmd0aD1pKzE7dmFyIGE7Zm9yKGE9MDthPHRoaXMubm9kZXMubGVuZ3RoO2ErKyl0aGlzLm5vZGVzW2FdPW5ldyB5O2Zvcih0aGlzLmhhbmRsZXM9W10sdGhpcy5oYW5kbGVzLmxlbmd0aD1pKzEsYT0wO2E8dGhpcy5oYW5kbGVzLmxlbmd0aDthKyspdGhpcy5oYW5kbGVzW2FdPW5ldyBtO3RoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5mcmVlTGlzdD0wLHRoaXMubGVxPXUsdGhpcy5ub2Rlc1sxXS5oYW5kbGU9MSx0aGlzLmhhbmRsZXNbMV0ua2V5PW51bGx9VC5wcm90b3R5cGU9e2Zsb2F0RG93bl86ZnVuY3Rpb24oaSl7dmFyIHU9dGhpcy5ub2RlcyxhPXRoaXMuaGFuZGxlcyxoLGIsRTtmb3IoaD11W2ldLmhhbmRsZTs7KXtpZihFPWk8PDEsRTx0aGlzLnNpemUmJnRoaXMubGVxKGFbdVtFKzFdLmhhbmRsZV0ua2V5LGFbdVtFXS5oYW5kbGVdLmtleSkmJisrRSxzKEU8PXRoaXMubWF4KSxiPXVbRV0uaGFuZGxlLEU+dGhpcy5zaXplfHx0aGlzLmxlcShhW2hdLmtleSxhW2JdLmtleSkpe3VbaV0uaGFuZGxlPWgsYVtoXS5ub2RlPWk7YnJlYWt9dVtpXS5oYW5kbGU9YixhW2JdLm5vZGU9aSxpPUV9fSxmbG9hdFVwXzpmdW5jdGlvbihpKXt2YXIgdT10aGlzLm5vZGVzLGE9dGhpcy5oYW5kbGVzLGgsYixFO2ZvcihoPXVbaV0uaGFuZGxlOzspe2lmKEU9aT4+MSxiPXVbRV0uaGFuZGxlLEU9PT0wfHx0aGlzLmxlcShhW2JdLmtleSxhW2hdLmtleSkpe3VbaV0uaGFuZGxlPWgsYVtoXS5ub2RlPWk7YnJlYWt9dVtpXS5oYW5kbGU9YixhW2JdLm5vZGU9aSxpPUV9fSxpbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciBpPXRoaXMuc2l6ZTtpPj0xOy0taSl0aGlzLmZsb2F0RG93bl8oaSk7dGhpcy5pbml0aWFsaXplZD0hMH0sbWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFuZGxlc1t0aGlzLm5vZGVzWzFdLmhhbmRsZV0ua2V5fSxpbnNlcnQ6ZnVuY3Rpb24oaSl7dmFyIHUsYTtpZih1PSsrdGhpcy5zaXplLHUqMj50aGlzLm1heCl7dGhpcy5tYXgqPTI7dmFyIGgsYjtmb3IoYj10aGlzLm5vZGVzLmxlbmd0aCx0aGlzLm5vZGVzLmxlbmd0aD10aGlzLm1heCsxLGg9YjtoPHRoaXMubm9kZXMubGVuZ3RoO2grKyl0aGlzLm5vZGVzW2hdPW5ldyB5O2ZvcihiPXRoaXMuaGFuZGxlcy5sZW5ndGgsdGhpcy5oYW5kbGVzLmxlbmd0aD10aGlzLm1heCsxLGg9YjtoPHRoaXMuaGFuZGxlcy5sZW5ndGg7aCsrKXRoaXMuaGFuZGxlc1toXT1uZXcgbX1yZXR1cm4gdGhpcy5mcmVlTGlzdD09PTA/YT11OihhPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD10aGlzLmhhbmRsZXNbYV0ubm9kZSksdGhpcy5ub2Rlc1t1XS5oYW5kbGU9YSx0aGlzLmhhbmRsZXNbYV0ubm9kZT11LHRoaXMuaGFuZGxlc1thXS5rZXk9aSx0aGlzLmluaXRpYWxpemVkJiZ0aGlzLmZsb2F0VXBfKHUpLGF9LGV4dHJhY3RNaW46ZnVuY3Rpb24oKXt2YXIgaT10aGlzLm5vZGVzLHU9dGhpcy5oYW5kbGVzLGE9aVsxXS5oYW5kbGUsaD11W2FdLmtleTtyZXR1cm4gdGhpcy5zaXplPjAmJihpWzFdLmhhbmRsZT1pW3RoaXMuc2l6ZV0uaGFuZGxlLHVbaVsxXS5oYW5kbGVdLm5vZGU9MSx1W2FdLmtleT1udWxsLHVbYV0ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9YSwtLXRoaXMuc2l6ZSx0aGlzLnNpemU+MCYmdGhpcy5mbG9hdERvd25fKDEpKSxofSxkZWxldGU6ZnVuY3Rpb24oaSl7dmFyIHU9dGhpcy5ub2RlcyxhPXRoaXMuaGFuZGxlcyxoO3MoaT49MSYmaTw9dGhpcy5tYXgmJmFbaV0ua2V5IT09bnVsbCksaD1hW2ldLm5vZGUsdVtoXS5oYW5kbGU9dVt0aGlzLnNpemVdLmhhbmRsZSxhW3VbaF0uaGFuZGxlXS5ub2RlPWgsLS10aGlzLnNpemUsaDw9dGhpcy5zaXplJiYoaDw9MXx8dGhpcy5sZXEoYVt1W2g+PjFdLmhhbmRsZV0ua2V5LGFbdVtoXS5oYW5kbGVdLmtleSk/dGhpcy5mbG9hdERvd25fKGgpOnRoaXMuZmxvYXRVcF8oaCkpLGFbaV0ua2V5PW51bGwsYVtpXS5ub2RlPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD1pfX07ZnVuY3Rpb24gTygpe3RoaXMuZVVwPW51bGwsdGhpcy5ub2RlVXA9bnVsbCx0aGlzLndpbmRpbmdOdW1iZXI9MCx0aGlzLmluc2lkZT0hMSx0aGlzLnNlbnRpbmVsPSExLHRoaXMuZGlydHk9ITEsdGhpcy5maXhVcHBlckVkZ2U9ITF9dmFyIHY9e307di5yZWdpb25CZWxvdz1mdW5jdGlvbihpKXtyZXR1cm4gaS5ub2RlVXAucHJldi5rZXl9LHYucmVnaW9uQWJvdmU9ZnVuY3Rpb24oaSl7cmV0dXJuIGkubm9kZVVwLm5leHQua2V5fSx2LmRlYnVnRXZlbnQ9ZnVuY3Rpb24oaSl7fSx2LmFkZFdpbmRpbmc9ZnVuY3Rpb24oaSx1KXtpLndpbmRpbmcrPXUud2luZGluZyxpLlN5bS53aW5kaW5nKz11LlN5bS53aW5kaW5nfSx2LmVkZ2VMZXE9ZnVuY3Rpb24oaSx1LGEpe3ZhciBoPWkuZXZlbnQsQSxMLGI9dS5lVXAsRT1hLmVVcDtpZihiLkRzdD09PWgpcmV0dXJuIEUuRHN0PT09aD9uLnZlcnRMZXEoYi5PcmcsRS5PcmcpP24uZWRnZVNpZ24oRS5Ec3QsYi5PcmcsRS5PcmcpPD0wOm4uZWRnZVNpZ24oYi5Ec3QsRS5PcmcsYi5PcmcpPj0wOm4uZWRnZVNpZ24oRS5Ec3QsaCxFLk9yZyk8PTA7aWYoRS5Ec3Q9PT1oKXJldHVybiBuLmVkZ2VTaWduKGIuRHN0LGgsYi5PcmcpPj0wO3ZhciBBPW4uZWRnZUV2YWwoYi5Ec3QsaCxiLk9yZyksTD1uLmVkZ2VFdmFsKEUuRHN0LGgsRS5PcmcpO3JldHVybiBBPj1MfSx2LmRlbGV0ZVJlZ2lvbj1mdW5jdGlvbihpLHUpe3UuZml4VXBwZXJFZGdlJiZzKHUuZVVwLndpbmRpbmc9PT0wKSx1LmVVcC5hY3RpdmVSZWdpb249bnVsbCxpLmRpY3QuZGVsZXRlKHUubm9kZVVwKX0sdi5maXhVcHBlckVkZ2U9ZnVuY3Rpb24oaSx1LGEpe3ModS5maXhVcHBlckVkZ2UpLGkubWVzaC5kZWxldGUodS5lVXApLHUuZml4VXBwZXJFZGdlPSExLHUuZVVwPWEsYS5hY3RpdmVSZWdpb249dX0sdi50b3BMZWZ0UmVnaW9uPWZ1bmN0aW9uKGksdSl7dmFyIGE9dS5lVXAuT3JnLGg7ZG8gdT12LnJlZ2lvbkFib3ZlKHUpO3doaWxlKHUuZVVwLk9yZz09PWEpO2lmKHUuZml4VXBwZXJFZGdlKXtpZihoPWkubWVzaC5jb25uZWN0KHYucmVnaW9uQmVsb3codSkuZVVwLlN5bSx1LmVVcC5MbmV4dCksaD09PW51bGwpcmV0dXJuIG51bGw7di5maXhVcHBlckVkZ2UoaSx1LGgpLHU9di5yZWdpb25BYm92ZSh1KX1yZXR1cm4gdX0sdi50b3BSaWdodFJlZ2lvbj1mdW5jdGlvbihpKXt2YXIgdT1pLmVVcC5Ec3Q7ZG8gaT12LnJlZ2lvbkFib3ZlKGkpO3doaWxlKGkuZVVwLkRzdD09PXUpO3JldHVybiBpfSx2LmFkZFJlZ2lvbkJlbG93PWZ1bmN0aW9uKGksdSxhKXt2YXIgaD1uZXcgTztyZXR1cm4gaC5lVXA9YSxoLm5vZGVVcD1pLmRpY3QuaW5zZXJ0QmVmb3JlKHUubm9kZVVwLGgpLGguZml4VXBwZXJFZGdlPSExLGguc2VudGluZWw9ITEsaC5kaXJ0eT0hMSxhLmFjdGl2ZVJlZ2lvbj1oLGh9LHYuaXNXaW5kaW5nSW5zaWRlPWZ1bmN0aW9uKGksdSl7c3dpdGNoKGkud2luZGluZ1J1bGUpe2Nhc2Ugci5XSU5ESU5HX09ERDpyZXR1cm4odSYxKSE9PTA7Y2FzZSByLldJTkRJTkdfTk9OWkVSTzpyZXR1cm4gdSE9PTA7Y2FzZSByLldJTkRJTkdfUE9TSVRJVkU6cmV0dXJuIHU+MDtjYXNlIHIuV0lORElOR19ORUdBVElWRTpyZXR1cm4gdTwwO2Nhc2Ugci5XSU5ESU5HX0FCU19HRVFfVFdPOnJldHVybiB1Pj0yfHx1PD0tMn1yZXR1cm4gcyghMSksITF9LHYuY29tcHV0ZVdpbmRpbmc9ZnVuY3Rpb24oaSx1KXt1LndpbmRpbmdOdW1iZXI9di5yZWdpb25BYm92ZSh1KS53aW5kaW5nTnVtYmVyK3UuZVVwLndpbmRpbmcsdS5pbnNpZGU9di5pc1dpbmRpbmdJbnNpZGUoaSx1LndpbmRpbmdOdW1iZXIpfSx2LmZpbmlzaFJlZ2lvbj1mdW5jdGlvbihpLHUpe3ZhciBhPXUuZVVwLGg9YS5MZmFjZTtoLmluc2lkZT11Lmluc2lkZSxoLmFuRWRnZT1hLHYuZGVsZXRlUmVnaW9uKGksdSl9LHYuZmluaXNoTGVmdFJlZ2lvbnM9ZnVuY3Rpb24oaSx1LGEpe2Zvcih2YXIgaCxBLGI9bnVsbCxFPXUsQT11LmVVcDtFIT09YTspe2lmKEUuZml4VXBwZXJFZGdlPSExLGI9di5yZWdpb25CZWxvdyhFKSxoPWIuZVVwLGguT3JnIT1BLk9yZyl7aWYoIWIuZml4VXBwZXJFZGdlKXt2LmZpbmlzaFJlZ2lvbihpLEUpO2JyZWFrfWg9aS5tZXNoLmNvbm5lY3QoQS5McHJldixoLlN5bSksdi5maXhVcHBlckVkZ2UoaSxiLGgpfUEuT25leHQhPT1oJiYoaS5tZXNoLnNwbGljZShoLk9wcmV2LGgpLGkubWVzaC5zcGxpY2UoQSxoKSksdi5maW5pc2hSZWdpb24oaSxFKSxBPWIuZVVwLEU9Yn1yZXR1cm4gQX0sdi5hZGRSaWdodEVkZ2VzPWZ1bmN0aW9uKGksdSxhLGgsYixFKXt2YXIgQSxMLFMsSSxEPSEwO1M9YTtkbyBzKG4udmVydExlcShTLk9yZyxTLkRzdCkpLHYuYWRkUmVnaW9uQmVsb3coaSx1LFMuU3ltKSxTPVMuT25leHQ7d2hpbGUoUyE9PWgpO2ZvcihiPT09bnVsbCYmKGI9di5yZWdpb25CZWxvdyh1KS5lVXAuUnByZXYpLEw9dSxJPWI7QT12LnJlZ2lvbkJlbG93KEwpLFM9QS5lVXAuU3ltLFMuT3JnPT09SS5Pcmc7KVMuT25leHQhPT1JJiYoaS5tZXNoLnNwbGljZShTLk9wcmV2LFMpLGkubWVzaC5zcGxpY2UoSS5PcHJldixTKSksQS53aW5kaW5nTnVtYmVyPUwud2luZGluZ051bWJlci1TLndpbmRpbmcsQS5pbnNpZGU9di5pc1dpbmRpbmdJbnNpZGUoaSxBLndpbmRpbmdOdW1iZXIpLEwuZGlydHk9ITAsIUQmJnYuY2hlY2tGb3JSaWdodFNwbGljZShpLEwpJiYodi5hZGRXaW5kaW5nKFMsSSksdi5kZWxldGVSZWdpb24oaSxMKSxpLm1lc2guZGVsZXRlKEkpKSxEPSExLEw9QSxJPVM7TC5kaXJ0eT0hMCxzKEwud2luZGluZ051bWJlci1TLndpbmRpbmc9PT1BLndpbmRpbmdOdW1iZXIpLEUmJnYud2Fsa0RpcnR5UmVnaW9ucyhpLEwpfSx2LnNwbGljZU1lcmdlVmVydGljZXM9ZnVuY3Rpb24oaSx1LGEpe2kubWVzaC5zcGxpY2UodSxhKX0sdi52ZXJ0ZXhXZWlnaHRzPWZ1bmN0aW9uKGksdSxhKXt2YXIgaD1uLnZlcnRMMWRpc3QodSxpKSxiPW4udmVydEwxZGlzdChhLGkpLEU9LjUqYi8oaCtiKSxBPS41KmgvKGgrYik7aS5jb29yZHNbMF0rPUUqdS5jb29yZHNbMF0rQSphLmNvb3Jkc1swXSxpLmNvb3Jkc1sxXSs9RSp1LmNvb3Jkc1sxXStBKmEuY29vcmRzWzFdLGkuY29vcmRzWzJdKz1FKnUuY29vcmRzWzJdK0EqYS5jb29yZHNbMl19LHYuZ2V0SW50ZXJzZWN0RGF0YT1mdW5jdGlvbihpLHUsYSxoLGIsRSl7dS5jb29yZHNbMF09dS5jb29yZHNbMV09dS5jb29yZHNbMl09MCx1LmlkeD0tMSx2LnZlcnRleFdlaWdodHModSxhLGgpLHYudmVydGV4V2VpZ2h0cyh1LGIsRSl9LHYuY2hlY2tGb3JSaWdodFNwbGljZT1mdW5jdGlvbihpLHUpe3ZhciBhPXYucmVnaW9uQmVsb3codSksaD11LmVVcCxiPWEuZVVwO2lmKG4udmVydExlcShoLk9yZyxiLk9yZykpe2lmKG4uZWRnZVNpZ24oYi5Ec3QsaC5PcmcsYi5PcmcpPjApcmV0dXJuITE7bi52ZXJ0RXEoaC5PcmcsYi5PcmcpP2guT3JnIT09Yi5PcmcmJihpLnBxLmRlbGV0ZShoLk9yZy5wcUhhbmRsZSksdi5zcGxpY2VNZXJnZVZlcnRpY2VzKGksYi5PcHJldixoKSk6KGkubWVzaC5zcGxpdEVkZ2UoYi5TeW0pLGkubWVzaC5zcGxpY2UoaCxiLk9wcmV2KSx1LmRpcnR5PWEuZGlydHk9ITApfWVsc2V7aWYobi5lZGdlU2lnbihoLkRzdCxiLk9yZyxoLk9yZyk8MClyZXR1cm4hMTt2LnJlZ2lvbkFib3ZlKHUpLmRpcnR5PXUuZGlydHk9ITAsaS5tZXNoLnNwbGl0RWRnZShoLlN5bSksaS5tZXNoLnNwbGljZShiLk9wcmV2LGgpfXJldHVybiEwfSx2LmNoZWNrRm9yTGVmdFNwbGljZT1mdW5jdGlvbihpLHUpe3ZhciBhPXYucmVnaW9uQmVsb3codSksaD11LmVVcCxiPWEuZVVwLEU7aWYocyghbi52ZXJ0RXEoaC5Ec3QsYi5Ec3QpKSxuLnZlcnRMZXEoaC5Ec3QsYi5Ec3QpKXtpZihuLmVkZ2VTaWduKGguRHN0LGIuRHN0LGguT3JnKTwwKXJldHVybiExO3YucmVnaW9uQWJvdmUodSkuZGlydHk9dS5kaXJ0eT0hMCxFPWkubWVzaC5zcGxpdEVkZ2UoaCksaS5tZXNoLnNwbGljZShiLlN5bSxFKSxFLkxmYWNlLmluc2lkZT11Lmluc2lkZX1lbHNle2lmKG4uZWRnZVNpZ24oYi5Ec3QsaC5Ec3QsYi5PcmcpPjApcmV0dXJuITE7dS5kaXJ0eT1hLmRpcnR5PSEwLEU9aS5tZXNoLnNwbGl0RWRnZShiKSxpLm1lc2guc3BsaWNlKGguTG5leHQsYi5TeW0pLEUuUmZhY2UuaW5zaWRlPXUuaW5zaWRlfXJldHVybiEwfSx2LmNoZWNrRm9ySW50ZXJzZWN0PWZ1bmN0aW9uKGksdSl7dmFyIGE9di5yZWdpb25CZWxvdyh1KSxoPXUuZVVwLGI9YS5lVXAsRT1oLk9yZyxBPWIuT3JnLEw9aC5Ec3QsUz1iLkRzdCxJLEQsUj1uZXcgbCxDLGo7aWYocyghbi52ZXJ0RXEoUyxMKSkscyhuLmVkZ2VTaWduKEwsaS5ldmVudCxFKTw9MCkscyhuLmVkZ2VTaWduKFMsaS5ldmVudCxBKT49MCkscyhFIT09aS5ldmVudCYmQSE9PWkuZXZlbnQpLHMoIXUuZml4VXBwZXJFZGdlJiYhYS5maXhVcHBlckVkZ2UpLEU9PT1BfHwoST1NYXRoLm1pbihFLnQsTC50KSxEPU1hdGgubWF4KEEudCxTLnQpLEk+RCkpcmV0dXJuITE7aWYobi52ZXJ0TGVxKEUsQSkpe2lmKG4uZWRnZVNpZ24oUyxFLEEpPjApcmV0dXJuITF9ZWxzZSBpZihuLmVkZ2VTaWduKEwsQSxFKTwwKXJldHVybiExO3JldHVybiB2LmRlYnVnRXZlbnQoaSksbi5pbnRlcnNlY3QoTCxFLFMsQSxSKSxzKE1hdGgubWluKEUudCxMLnQpPD1SLnQpLHMoUi50PD1NYXRoLm1heChBLnQsUy50KSkscyhNYXRoLm1pbihTLnMsTC5zKTw9Ui5zKSxzKFIuczw9TWF0aC5tYXgoQS5zLEUucykpLG4udmVydExlcShSLGkuZXZlbnQpJiYoUi5zPWkuZXZlbnQucyxSLnQ9aS5ldmVudC50KSxDPW4udmVydExlcShFLEEpP0U6QSxuLnZlcnRMZXEoQyxSKSYmKFIucz1DLnMsUi50PUMudCksbi52ZXJ0RXEoUixFKXx8bi52ZXJ0RXEoUixBKT8odi5jaGVja0ZvclJpZ2h0U3BsaWNlKGksdSksITEpOiFuLnZlcnRFcShMLGkuZXZlbnQpJiZuLmVkZ2VTaWduKEwsaS5ldmVudCxSKT49MHx8IW4udmVydEVxKFMsaS5ldmVudCkmJm4uZWRnZVNpZ24oUyxpLmV2ZW50LFIpPD0wP1M9PT1pLmV2ZW50PyhpLm1lc2guc3BsaXRFZGdlKGguU3ltKSxpLm1lc2guc3BsaWNlKGIuU3ltLGgpLHU9di50b3BMZWZ0UmVnaW9uKGksdSksaD12LnJlZ2lvbkJlbG93KHUpLmVVcCx2LmZpbmlzaExlZnRSZWdpb25zKGksdi5yZWdpb25CZWxvdyh1KSxhKSx2LmFkZFJpZ2h0RWRnZXMoaSx1LGguT3ByZXYsaCxoLCEwKSwhMCk6TD09PWkuZXZlbnQ/KGkubWVzaC5zcGxpdEVkZ2UoYi5TeW0pLGkubWVzaC5zcGxpY2UoaC5MbmV4dCxiLk9wcmV2KSxhPXUsdT12LnRvcFJpZ2h0UmVnaW9uKHUpLGo9di5yZWdpb25CZWxvdyh1KS5lVXAuUnByZXYsYS5lVXA9Yi5PcHJldixiPXYuZmluaXNoTGVmdFJlZ2lvbnMoaSxhLG51bGwpLHYuYWRkUmlnaHRFZGdlcyhpLHUsYi5PbmV4dCxoLlJwcmV2LGosITApLCEwKToobi5lZGdlU2lnbihMLGkuZXZlbnQsUik+PTAmJih2LnJlZ2lvbkFib3ZlKHUpLmRpcnR5PXUuZGlydHk9ITAsaS5tZXNoLnNwbGl0RWRnZShoLlN5bSksaC5Pcmcucz1pLmV2ZW50LnMsaC5PcmcudD1pLmV2ZW50LnQpLG4uZWRnZVNpZ24oUyxpLmV2ZW50LFIpPD0wJiYodS5kaXJ0eT1hLmRpcnR5PSEwLGkubWVzaC5zcGxpdEVkZ2UoYi5TeW0pLGIuT3JnLnM9aS5ldmVudC5zLGIuT3JnLnQ9aS5ldmVudC50KSwhMSk6KGkubWVzaC5zcGxpdEVkZ2UoaC5TeW0pLGkubWVzaC5zcGxpdEVkZ2UoYi5TeW0pLGkubWVzaC5zcGxpY2UoYi5PcHJldixoKSxoLk9yZy5zPVIucyxoLk9yZy50PVIudCxoLk9yZy5wcUhhbmRsZT1pLnBxLmluc2VydChoLk9yZyksdi5nZXRJbnRlcnNlY3REYXRhKGksaC5PcmcsRSxMLEEsUyksdi5yZWdpb25BYm92ZSh1KS5kaXJ0eT11LmRpcnR5PWEuZGlydHk9ITAsITEpfSx2LndhbGtEaXJ0eVJlZ2lvbnM9ZnVuY3Rpb24oaSx1KXtmb3IodmFyIGE9di5yZWdpb25CZWxvdyh1KSxoLGI7Oyl7Zm9yKDthLmRpcnR5Oyl1PWEsYT12LnJlZ2lvbkJlbG93KGEpO2lmKCF1LmRpcnR5JiYoYT11LHU9di5yZWdpb25BYm92ZSh1KSx1PT09bnVsbHx8IXUuZGlydHkpKXJldHVybjtpZih1LmRpcnR5PSExLGg9dS5lVXAsYj1hLmVVcCxoLkRzdCE9PWIuRHN0JiZ2LmNoZWNrRm9yTGVmdFNwbGljZShpLHUpJiYoYS5maXhVcHBlckVkZ2U/KHYuZGVsZXRlUmVnaW9uKGksYSksaS5tZXNoLmRlbGV0ZShiKSxhPXYucmVnaW9uQmVsb3codSksYj1hLmVVcCk6dS5maXhVcHBlckVkZ2UmJih2LmRlbGV0ZVJlZ2lvbihpLHUpLGkubWVzaC5kZWxldGUoaCksdT12LnJlZ2lvbkFib3ZlKGEpLGg9dS5lVXApKSxoLk9yZyE9PWIuT3JnKWlmKGguRHN0IT09Yi5Ec3QmJiF1LmZpeFVwcGVyRWRnZSYmIWEuZml4VXBwZXJFZGdlJiYoaC5Ec3Q9PT1pLmV2ZW50fHxiLkRzdD09PWkuZXZlbnQpKXtpZih2LmNoZWNrRm9ySW50ZXJzZWN0KGksdSkpcmV0dXJufWVsc2Ugdi5jaGVja0ZvclJpZ2h0U3BsaWNlKGksdSk7aC5Pcmc9PT1iLk9yZyYmaC5Ec3Q9PT1iLkRzdCYmKHYuYWRkV2luZGluZyhiLGgpLHYuZGVsZXRlUmVnaW9uKGksdSksaS5tZXNoLmRlbGV0ZShoKSx1PXYucmVnaW9uQWJvdmUoYSkpfX0sdi5jb25uZWN0UmlnaHRWZXJ0ZXg9ZnVuY3Rpb24oaSx1LGEpe3ZhciBoLGI9YS5PbmV4dCxFPXYucmVnaW9uQmVsb3codSksQT11LmVVcCxMPUUuZVVwLFM9ITE7aWYoQS5Ec3QhPT1MLkRzdCYmdi5jaGVja0ZvckludGVyc2VjdChpLHUpLG4udmVydEVxKEEuT3JnLGkuZXZlbnQpJiYoaS5tZXNoLnNwbGljZShiLk9wcmV2LEEpLHU9di50b3BMZWZ0UmVnaW9uKGksdSksYj12LnJlZ2lvbkJlbG93KHUpLmVVcCx2LmZpbmlzaExlZnRSZWdpb25zKGksdi5yZWdpb25CZWxvdyh1KSxFKSxTPSEwKSxuLnZlcnRFcShMLk9yZyxpLmV2ZW50KSYmKGkubWVzaC5zcGxpY2UoYSxMLk9wcmV2KSxhPXYuZmluaXNoTGVmdFJlZ2lvbnMoaSxFLG51bGwpLFM9ITApLFMpe3YuYWRkUmlnaHRFZGdlcyhpLHUsYS5PbmV4dCxiLGIsITApO3JldHVybn1uLnZlcnRMZXEoTC5PcmcsQS5PcmcpP2g9TC5PcHJldjpoPUEsaD1pLm1lc2guY29ubmVjdChhLkxwcmV2LGgpLHYuYWRkUmlnaHRFZGdlcyhpLHUsaCxoLk9uZXh0LGguT25leHQsITEpLGguU3ltLmFjdGl2ZVJlZ2lvbi5maXhVcHBlckVkZ2U9ITAsdi53YWxrRGlydHlSZWdpb25zKGksdSl9LHYuY29ubmVjdExlZnREZWdlbmVyYXRlPWZ1bmN0aW9uKGksdSxhKXt2YXIgaCxiLEUsQSxMO2lmKGg9dS5lVXAsbi52ZXJ0RXEoaC5PcmcsYSkpe3MoITEpLHYuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhpLGgsYS5hbkVkZ2UpO3JldHVybn1pZighbi52ZXJ0RXEoaC5Ec3QsYSkpe2kubWVzaC5zcGxpdEVkZ2UoaC5TeW0pLHUuZml4VXBwZXJFZGdlJiYoaS5tZXNoLmRlbGV0ZShoLk9uZXh0KSx1LmZpeFVwcGVyRWRnZT0hMSksaS5tZXNoLnNwbGljZShhLmFuRWRnZSxoKSx2LnN3ZWVwRXZlbnQoaSxhKTtyZXR1cm59cyghMSksdT12LnRvcFJpZ2h0UmVnaW9uKHUpLEw9di5yZWdpb25CZWxvdyh1KSxFPUwuZVVwLlN5bSxiPUE9RS5PbmV4dCxMLmZpeFVwcGVyRWRnZSYmKHMoYiE9PUUpLHYuZGVsZXRlUmVnaW9uKGksTCksaS5tZXNoLmRlbGV0ZShFKSxFPWIuT3ByZXYpLGkubWVzaC5zcGxpY2UoYS5hbkVkZ2UsRSksbi5lZGdlR29lc0xlZnQoYil8fChiPW51bGwpLHYuYWRkUmlnaHRFZGdlcyhpLHUsRS5PbmV4dCxBLGIsITApfSx2LmNvbm5lY3RMZWZ0VmVydGV4PWZ1bmN0aW9uKGksdSl7dmFyIGEsaCxiLEUsQSxMLFM9bmV3IE87aWYoUy5lVXA9dS5hbkVkZ2UuU3ltLGE9aS5kaWN0LnNlYXJjaChTKS5rZXksaD12LnJlZ2lvbkJlbG93KGEpLCEhaCl7aWYoRT1hLmVVcCxBPWguZVVwLG4uZWRnZVNpZ24oRS5Ec3QsdSxFLk9yZyk9PT0wKXt2LmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZShpLGEsdSk7cmV0dXJufWlmKGI9bi52ZXJ0TGVxKEEuRHN0LEUuRHN0KT9hOmgsYS5pbnNpZGV8fGIuZml4VXBwZXJFZGdlKXtpZihiPT09YSlMPWkubWVzaC5jb25uZWN0KHUuYW5FZGdlLlN5bSxFLkxuZXh0KTtlbHNle3ZhciBJPWkubWVzaC5jb25uZWN0KEEuRG5leHQsdS5hbkVkZ2UpO0w9SS5TeW19Yi5maXhVcHBlckVkZ2U/di5maXhVcHBlckVkZ2UoaSxiLEwpOnYuY29tcHV0ZVdpbmRpbmcoaSx2LmFkZFJlZ2lvbkJlbG93KGksYSxMKSksdi5zd2VlcEV2ZW50KGksdSl9ZWxzZSB2LmFkZFJpZ2h0RWRnZXMoaSxhLHUuYW5FZGdlLHUuYW5FZGdlLG51bGwsITApfX0sdi5zd2VlcEV2ZW50PWZ1bmN0aW9uKGksdSl7aS5ldmVudD11LHYuZGVidWdFdmVudChpKTtmb3IodmFyIGE9dS5hbkVkZ2U7YS5hY3RpdmVSZWdpb249PT1udWxsOylpZihhPWEuT25leHQsYT09PXUuYW5FZGdlKXt2LmNvbm5lY3RMZWZ0VmVydGV4KGksdSk7cmV0dXJufXZhciBoPXYudG9wTGVmdFJlZ2lvbihpLGEuYWN0aXZlUmVnaW9uKTtzKGghPT1udWxsKTt2YXIgYj12LnJlZ2lvbkJlbG93KGgpLEU9Yi5lVXAsQT12LmZpbmlzaExlZnRSZWdpb25zKGksYixudWxsKTtBLk9uZXh0PT09RT92LmNvbm5lY3RSaWdodFZlcnRleChpLGgsQSk6di5hZGRSaWdodEVkZ2VzKGksaCxBLk9uZXh0LEUsRSwhMCl9LHYuYWRkU2VudGluZWw9ZnVuY3Rpb24oaSx1LGEsaCl7dmFyIGI9bmV3IE8sRT1pLm1lc2gubWFrZUVkZ2UoKTtFLk9yZy5zPWEsRS5PcmcudD1oLEUuRHN0LnM9dSxFLkRzdC50PWgsaS5ldmVudD1FLkRzdCxiLmVVcD1FLGIud2luZGluZ051bWJlcj0wLGIuaW5zaWRlPSExLGIuZml4VXBwZXJFZGdlPSExLGIuc2VudGluZWw9ITAsYi5kaXJ0eT0hMSxiLm5vZGVVcD1pLmRpY3QuaW5zZXJ0KGIpfSx2LmluaXRFZGdlRGljdD1mdW5jdGlvbihpKXtpLmRpY3Q9bmV3IGcoaSx2LmVkZ2VMZXEpO3ZhciB1PWkuYm1heFswXS1pLmJtaW5bMF0sYT1pLmJtYXhbMV0taS5ibWluWzFdLGg9aS5ibWluWzBdLXUsYj1pLmJtYXhbMF0rdSxFPWkuYm1pblsxXS1hLEE9aS5ibWF4WzFdK2E7di5hZGRTZW50aW5lbChpLGgsYixFKSx2LmFkZFNlbnRpbmVsKGksaCxiLEEpfSx2LmRvbmVFZGdlRGljdD1mdW5jdGlvbihpKXtmb3IodmFyIHUsYT0wOyh1PWkuZGljdC5taW4oKS5rZXkpIT09bnVsbDspdS5zZW50aW5lbHx8KHModS5maXhVcHBlckVkZ2UpLHMoKythPT09MSkpLHModS53aW5kaW5nTnVtYmVyPT09MCksdi5kZWxldGVSZWdpb24oaSx1KX0sdi5yZW1vdmVEZWdlbmVyYXRlRWRnZXM9ZnVuY3Rpb24oaSl7dmFyIHUsYSxoLGI9aS5tZXNoLmVIZWFkO2Zvcih1PWIubmV4dDt1IT09Yjt1PWEpYT11Lm5leHQsaD11LkxuZXh0LG4udmVydEVxKHUuT3JnLHUuRHN0KSYmdS5MbmV4dC5MbmV4dCE9PXUmJih2LnNwbGljZU1lcmdlVmVydGljZXMoaSxoLHUpLGkubWVzaC5kZWxldGUodSksdT1oLGg9dS5MbmV4dCksaC5MbmV4dD09PXUmJihoIT09dSYmKChoPT09YXx8aD09PWEuU3ltKSYmKGE9YS5uZXh0KSxpLm1lc2guZGVsZXRlKGgpKSwodT09PWF8fHU9PT1hLlN5bSkmJihhPWEubmV4dCksaS5tZXNoLmRlbGV0ZSh1KSl9LHYuaW5pdFByaW9yaXR5UT1mdW5jdGlvbihpKXt2YXIgdSxhLGgsYj0wO2ZvcihoPWkubWVzaC52SGVhZCxhPWgubmV4dDthIT09aDthPWEubmV4dCliKys7Zm9yKGIrPTgsdT1pLnBxPW5ldyBUKGIsbi52ZXJ0TGVxKSxoPWkubWVzaC52SGVhZCxhPWgubmV4dDthIT09aDthPWEubmV4dClhLnBxSGFuZGxlPXUuaW5zZXJ0KGEpO3JldHVybiBhIT09aD8hMToodS5pbml0KCksITApfSx2LmRvbmVQcmlvcml0eVE9ZnVuY3Rpb24oaSl7aS5wcT1udWxsfSx2LnJlbW92ZURlZ2VuZXJhdGVGYWNlcz1mdW5jdGlvbihpLHUpe3ZhciBhLGgsYjtmb3IoYT11LmZIZWFkLm5leHQ7YSE9PXUuZkhlYWQ7YT1oKWg9YS5uZXh0LGI9YS5hbkVkZ2UscyhiLkxuZXh0IT09YiksYi5MbmV4dC5MbmV4dD09PWImJih2LmFkZFdpbmRpbmcoYi5PbmV4dCxiKSxpLm1lc2guZGVsZXRlKGIpKTtyZXR1cm4hMH0sdi5jb21wdXRlSW50ZXJpb3I9ZnVuY3Rpb24oaSl7dmFyIHUsYTtpZih2LnJlbW92ZURlZ2VuZXJhdGVFZGdlcyhpKSwhdi5pbml0UHJpb3JpdHlRKGkpKXJldHVybiExO2Zvcih2LmluaXRFZGdlRGljdChpKTsodT1pLnBxLmV4dHJhY3RNaW4oKSkhPT1udWxsOyl7Zm9yKDthPWkucHEubWluKCksIShhPT09bnVsbHx8IW4udmVydEVxKGEsdSkpOylhPWkucHEuZXh0cmFjdE1pbigpLHYuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhpLHUuYW5FZGdlLGEuYW5FZGdlKTt2LnN3ZWVwRXZlbnQoaSx1KX1yZXR1cm4gaS5ldmVudD1pLmRpY3QubWluKCkua2V5LmVVcC5Pcmcsdi5kZWJ1Z0V2ZW50KGkpLHYuZG9uZUVkZ2VEaWN0KGkpLHYuZG9uZVByaW9yaXR5UShpKSx2LnJlbW92ZURlZ2VuZXJhdGVGYWNlcyhpLGkubWVzaCk/KGkubWVzaC5jaGVjaygpLCEwKTohMX07ZnVuY3Rpb24gUCgpe3RoaXMubWVzaD1udWxsLHRoaXMubm9ybWFsPVswLDAsMF0sdGhpcy5zVW5pdD1bMCwwLDBdLHRoaXMudFVuaXQ9WzAsMCwwXSx0aGlzLmJtaW49WzAsMF0sdGhpcy5ibWF4PVswLDBdLHRoaXMud2luZGluZ1J1bGU9ci5XSU5ESU5HX09ERCx0aGlzLmRpY3Q9bnVsbCx0aGlzLnBxPW51bGwsdGhpcy5ldmVudD1udWxsLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhDb3VudD0wLHRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50Q291bnQ9MH1QLnByb3RvdHlwZT17ZG90XzpmdW5jdGlvbihpLHUpe3JldHVybiBpWzBdKnVbMF0raVsxXSp1WzFdK2lbMl0qdVsyXX0sbm9ybWFsaXplXzpmdW5jdGlvbihpKXt2YXIgdT1pWzBdKmlbMF0raVsxXSppWzFdK2lbMl0qaVsyXTtzKHU+MCksdT1NYXRoLnNxcnQodSksaVswXS89dSxpWzFdLz11LGlbMl0vPXV9LGxvbmdBeGlzXzpmdW5jdGlvbihpKXt2YXIgdT0wO3JldHVybiBNYXRoLmFicyhpWzFdKT5NYXRoLmFicyhpWzBdKSYmKHU9MSksTWF0aC5hYnMoaVsyXSk+TWF0aC5hYnMoaVt1XSkmJih1PTIpLHV9LGNvbXB1dGVOb3JtYWxfOmZ1bmN0aW9uKGkpe3ZhciB1LGEsaCxiLEUsQSxMPVswLDAsMF0sUz1bMCwwLDBdLEk9WzAsMCwwXSxEPVswLDAsMF0sUj1bMCwwLDBdLEM9W251bGwsbnVsbCxudWxsXSxqPVtudWxsLG51bGwsbnVsbF0sJD10aGlzLm1lc2gudkhlYWQsSDtmb3IodT0kLm5leHQsSD0wO0g8MzsrK0gpYj11LmNvb3Jkc1tIXSxTW0hdPWIsaltIXT11LExbSF09YixDW0hdPXU7Zm9yKHU9JC5uZXh0O3UhPT0kO3U9dS5uZXh0KWZvcihIPTA7SDwzOysrSCliPXUuY29vcmRzW0hdLGI8U1tIXSYmKFNbSF09YixqW0hdPXUpLGI+TFtIXSYmKExbSF09YixDW0hdPXUpO2lmKEg9MCxMWzFdLVNbMV0+TFswXS1TWzBdJiYoSD0xKSxMWzJdLVNbMl0+TFtIXS1TW0hdJiYoSD0yKSxTW0hdPj1MW0hdKXtpWzBdPTAsaVsxXT0wLGlbMl09MTtyZXR1cm59Zm9yKEE9MCxhPWpbSF0saD1DW0hdLElbMF09YS5jb29yZHNbMF0taC5jb29yZHNbMF0sSVsxXT1hLmNvb3Jkc1sxXS1oLmNvb3Jkc1sxXSxJWzJdPWEuY29vcmRzWzJdLWguY29vcmRzWzJdLHU9JC5uZXh0O3UhPT0kO3U9dS5uZXh0KURbMF09dS5jb29yZHNbMF0taC5jb29yZHNbMF0sRFsxXT11LmNvb3Jkc1sxXS1oLmNvb3Jkc1sxXSxEWzJdPXUuY29vcmRzWzJdLWguY29vcmRzWzJdLFJbMF09SVsxXSpEWzJdLUlbMl0qRFsxXSxSWzFdPUlbMl0qRFswXS1JWzBdKkRbMl0sUlsyXT1JWzBdKkRbMV0tSVsxXSpEWzBdLEU9UlswXSpSWzBdK1JbMV0qUlsxXStSWzJdKlJbMl0sRT5BJiYoQT1FLGlbMF09UlswXSxpWzFdPVJbMV0saVsyXT1SWzJdKTtBPD0wJiYoaVswXT1pWzFdPWlbMl09MCxpW3RoaXMubG9uZ0F4aXNfKEkpXT0xKX0sY2hlY2tPcmllbnRhdGlvbl86ZnVuY3Rpb24oKXt2YXIgaSx1LGE9dGhpcy5tZXNoLmZIZWFkLGgsYj10aGlzLm1lc2gudkhlYWQsRTtmb3IoaT0wLHU9YS5uZXh0O3UhPT1hO3U9dS5uZXh0KWlmKEU9dS5hbkVkZ2UsIShFLndpbmRpbmc8PTApKWRvIGkrPShFLk9yZy5zLUUuRHN0LnMpKihFLk9yZy50K0UuRHN0LnQpLEU9RS5MbmV4dDt3aGlsZShFIT09dS5hbkVkZ2UpO2lmKGk8MCl7Zm9yKGg9Yi5uZXh0O2ghPT1iO2g9aC5uZXh0KWgudD0taC50O3RoaXMudFVuaXRbMF09LXRoaXMudFVuaXRbMF0sdGhpcy50VW5pdFsxXT0tdGhpcy50VW5pdFsxXSx0aGlzLnRVbml0WzJdPS10aGlzLnRVbml0WzJdfX0scHJvamVjdFBvbHlnb25fOmZ1bmN0aW9uKCl7dmFyIGksdT10aGlzLm1lc2gudkhlYWQsYT1bMCwwLDBdLGgsYixFLEEsTD0hMTtmb3IoYVswXT10aGlzLm5vcm1hbFswXSxhWzFdPXRoaXMubm9ybWFsWzFdLGFbMl09dGhpcy5ub3JtYWxbMl0sYVswXT09PTAmJmFbMV09PT0wJiZhWzJdPT09MCYmKHRoaXMuY29tcHV0ZU5vcm1hbF8oYSksTD0hMCksaD10aGlzLnNVbml0LGI9dGhpcy50VW5pdCxFPXRoaXMubG9uZ0F4aXNfKGEpLGhbRV09MCxoWyhFKzEpJTNdPTEsaFsoRSsyKSUzXT0wLGJbRV09MCxiWyhFKzEpJTNdPTAsYlsoRSsyKSUzXT1hW0VdPjA/MTotMSxpPXUubmV4dDtpIT09dTtpPWkubmV4dClpLnM9dGhpcy5kb3RfKGkuY29vcmRzLGgpLGkudD10aGlzLmRvdF8oaS5jb29yZHMsYik7Zm9yKEwmJnRoaXMuY2hlY2tPcmllbnRhdGlvbl8oKSxBPSEwLGk9dS5uZXh0O2khPT11O2k9aS5uZXh0KUE/KHRoaXMuYm1pblswXT10aGlzLmJtYXhbMF09aS5zLHRoaXMuYm1pblsxXT10aGlzLmJtYXhbMV09aS50LEE9ITEpOihpLnM8dGhpcy5ibWluWzBdJiYodGhpcy5ibWluWzBdPWkucyksaS5zPnRoaXMuYm1heFswXSYmKHRoaXMuYm1heFswXT1pLnMpLGkudDx0aGlzLmJtaW5bMV0mJih0aGlzLmJtaW5bMV09aS50KSxpLnQ+dGhpcy5ibWF4WzFdJiYodGhpcy5ibWF4WzFdPWkudCkpfSxhZGRXaW5kaW5nXzpmdW5jdGlvbihpLHUpe2kud2luZGluZys9dS53aW5kaW5nLGkuU3ltLndpbmRpbmcrPXUuU3ltLndpbmRpbmd9LHRlc3NlbGxhdGVNb25vUmVnaW9uXzpmdW5jdGlvbihpLHUpe3ZhciBhLGg7Zm9yKGE9dS5hbkVkZ2UscyhhLkxuZXh0IT09YSYmYS5MbmV4dC5MbmV4dCE9PWEpO24udmVydExlcShhLkRzdCxhLk9yZyk7YT1hLkxwcmV2KTtmb3IoO24udmVydExlcShhLk9yZyxhLkRzdCk7YT1hLkxuZXh0KTtmb3IoaD1hLkxwcmV2O2EuTG5leHQhPT1oOylpZihuLnZlcnRMZXEoYS5Ec3QsaC5PcmcpKXtmb3IoO2guTG5leHQhPT1hJiYobi5lZGdlR29lc0xlZnQoaC5MbmV4dCl8fG4uZWRnZVNpZ24oaC5PcmcsaC5Ec3QsaC5MbmV4dC5Ec3QpPD0wKTspe3ZhciBiPWkuY29ubmVjdChoLkxuZXh0LGgpO2g9Yi5TeW19aD1oLkxwcmV2fWVsc2V7Zm9yKDtoLkxuZXh0IT09YSYmKG4uZWRnZUdvZXNSaWdodChhLkxwcmV2KXx8bi5lZGdlU2lnbihhLkRzdCxhLk9yZyxhLkxwcmV2Lk9yZyk+PTApOyl7dmFyIGI9aS5jb25uZWN0KGEsYS5McHJldik7YT1iLlN5bX1hPWEuTG5leHR9Zm9yKHMoaC5MbmV4dCE9PWEpO2guTG5leHQuTG5leHQhPT1hOyl7dmFyIGI9aS5jb25uZWN0KGguTG5leHQsaCk7aD1iLlN5bX1yZXR1cm4hMH0sdGVzc2VsbGF0ZUludGVyaW9yXzpmdW5jdGlvbihpKXt2YXIgdSxhO2Zvcih1PWkuZkhlYWQubmV4dDt1IT09aS5mSGVhZDt1PWEpaWYoYT11Lm5leHQsdS5pbnNpZGUmJiF0aGlzLnRlc3NlbGxhdGVNb25vUmVnaW9uXyhpLHUpKXJldHVybiExO3JldHVybiEwfSxkaXNjYXJkRXh0ZXJpb3JfOmZ1bmN0aW9uKGkpe3ZhciB1LGE7Zm9yKHU9aS5mSGVhZC5uZXh0O3UhPT1pLmZIZWFkO3U9YSlhPXUubmV4dCx1Lmluc2lkZXx8aS56YXBGYWNlKHUpfSxzZXRXaW5kaW5nTnVtYmVyXzpmdW5jdGlvbihpLHUsYSl7dmFyIGgsYjtmb3IoaD1pLmVIZWFkLm5leHQ7aCE9PWkuZUhlYWQ7aD1iKWI9aC5uZXh0LGguUmZhY2UuaW5zaWRlIT09aC5MZmFjZS5pbnNpZGU/aC53aW5kaW5nPWguTGZhY2UuaW5zaWRlP3U6LXU6YT9pLmRlbGV0ZShoKTpoLndpbmRpbmc9MH0sZ2V0TmVpZ2hib3VyRmFjZV86ZnVuY3Rpb24oaSl7cmV0dXJuIWkuUmZhY2V8fCFpLlJmYWNlLmluc2lkZT8tMTppLlJmYWNlLm59LG91dHB1dFBvbHltZXNoXzpmdW5jdGlvbihpLHUsYSxoKXt2YXIgYixFLEEsTD0wLFM9MCxJLEQ7Zm9yKGE+MyYmaS5tZXJnZUNvbnZleEZhY2VzKGEpLGI9aS52SGVhZC5uZXh0O2IhPT1pLnZIZWFkO2I9Yi5uZXh0KWIubj0tMTtmb3IoRT1pLmZIZWFkLm5leHQ7RSE9PWkuZkhlYWQ7RT1FLm5leHQpaWYoRS5uPS0xLCEhRS5pbnNpZGUpe0E9RS5hbkVkZ2UsST0wO2RvIGI9QS5PcmcsYi5uPT09LTEmJihiLm49UyxTKyspLEkrKyxBPUEuTG5leHQ7d2hpbGUoQSE9PUUuYW5FZGdlKTtzKEk8PWEpLEUubj1MLCsrTH1mb3IodGhpcy5lbGVtZW50Q291bnQ9TCx1PT09ci5DT05ORUNURURfUE9MWUdPTlMmJihMKj0yKSx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPUwqYSx0aGlzLnZlcnRleENvdW50PVMsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD1TKmgsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9UyxiPWkudkhlYWQubmV4dDtiIT09aS52SGVhZDtiPWIubmV4dClpZihiLm4hPT0tMSl7dmFyIFI9Yi5uKmg7dGhpcy52ZXJ0aWNlc1tSKzBdPWIuY29vcmRzWzBdLHRoaXMudmVydGljZXNbUisxXT1iLmNvb3Jkc1sxXSxoPjImJih0aGlzLnZlcnRpY2VzW1IrMl09Yi5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tiLm5dPWIuaWR4fXZhciBDPTA7Zm9yKEU9aS5mSGVhZC5uZXh0O0UhPT1pLmZIZWFkO0U9RS5uZXh0KWlmKEUuaW5zaWRlKXtBPUUuYW5FZGdlLEk9MDtkbyBiPUEuT3JnLHRoaXMuZWxlbWVudHNbQysrXT1iLm4sSSsrLEE9QS5MbmV4dDt3aGlsZShBIT09RS5hbkVkZ2UpO2ZvcihEPUk7RDxhOysrRCl0aGlzLmVsZW1lbnRzW0MrK109LTE7aWYodT09PXIuQ09OTkVDVEVEX1BPTFlHT05TKXtBPUUuYW5FZGdlO2RvIHRoaXMuZWxlbWVudHNbQysrXT10aGlzLmdldE5laWdoYm91ckZhY2VfKEEpLEE9QS5MbmV4dDt3aGlsZShBIT09RS5hbkVkZ2UpO2ZvcihEPUk7RDxhOysrRCl0aGlzLmVsZW1lbnRzW0MrK109LTF9fX0sb3V0cHV0Q29udG91cnNfOmZ1bmN0aW9uKGksdSl7dmFyIGEsaCxiLEU9MCxBPTA7Zm9yKHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRDb3VudD0wLGE9aS5mSGVhZC5uZXh0O2EhPT1pLmZIZWFkO2E9YS5uZXh0KWlmKGEuaW5zaWRlKXtiPWg9YS5hbkVkZ2U7ZG8gdGhpcy52ZXJ0ZXhDb3VudCsrLGg9aC5MbmV4dDt3aGlsZShoIT09Yik7dGhpcy5lbGVtZW50Q291bnQrK310aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPXRoaXMuZWxlbWVudENvdW50KjIsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD10aGlzLnZlcnRleENvdW50KnUsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudDt2YXIgTD0wLFM9MCxJPTA7Zm9yKEU9MCxhPWkuZkhlYWQubmV4dDthIT09aS5mSGVhZDthPWEubmV4dClpZihhLmluc2lkZSl7QT0wLGI9aD1hLmFuRWRnZTtkbyB0aGlzLnZlcnRpY2VzW0wrK109aC5PcmcuY29vcmRzWzBdLHRoaXMudmVydGljZXNbTCsrXT1oLk9yZy5jb29yZHNbMV0sdT4yJiYodGhpcy52ZXJ0aWNlc1tMKytdPWguT3JnLmNvb3Jkc1syXSksdGhpcy52ZXJ0ZXhJbmRpY2VzW1MrK109aC5PcmcuaWR4LEErKyxoPWguTG5leHQ7d2hpbGUoaCE9PWIpO3RoaXMuZWxlbWVudHNbSSsrXT1FLHRoaXMuZWxlbWVudHNbSSsrXT1BLEUrPUF9fSxhZGRDb250b3VyOmZ1bmN0aW9uKGksdSl7dmFyIGEsaDtmb3IodGhpcy5tZXNoPT09bnVsbCYmKHRoaXMubWVzaD1uZXcgZiksaTwyJiYoaT0yKSxpPjMmJihpPTMpLGE9bnVsbCxoPTA7aDx1Lmxlbmd0aDtoKz1pKWE9PT1udWxsPyhhPXRoaXMubWVzaC5tYWtlRWRnZSgpLHRoaXMubWVzaC5zcGxpY2UoYSxhLlN5bSkpOih0aGlzLm1lc2guc3BsaXRFZGdlKGEpLGE9YS5MbmV4dCksYS5PcmcuY29vcmRzWzBdPXVbaCswXSxhLk9yZy5jb29yZHNbMV09dVtoKzFdLGk+Mj9hLk9yZy5jb29yZHNbMl09dVtoKzJdOmEuT3JnLmNvb3Jkc1syXT0wLGEuT3JnLmlkeD10aGlzLnZlcnRleEluZGV4Q291bnRlcisrLGEud2luZGluZz0xLGEuU3ltLndpbmRpbmc9LTF9LHRlc3NlbGF0ZTpmdW5jdGlvbihpLHUsYSxoLGIpe2lmKHRoaXMudmVydGljZXM9W10sdGhpcy5lbGVtZW50cz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXI9MCxiJiYodGhpcy5ub3JtYWxbMF09YlswXSx0aGlzLm5vcm1hbFsxXT1iWzFdLHRoaXMubm9ybWFsWzJdPWJbMl0pLHRoaXMud2luZGluZ1J1bGU9aSxoPDImJihoPTIpLGg+MyYmKGg9MyksIXRoaXMubWVzaClyZXR1cm4hMTt0aGlzLnByb2plY3RQb2x5Z29uXygpLHYuY29tcHV0ZUludGVyaW9yKHRoaXMpO3ZhciBFPXRoaXMubWVzaDtyZXR1cm4gdT09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5zZXRXaW5kaW5nTnVtYmVyXyhFLDEsITApOnRoaXMudGVzc2VsbGF0ZUludGVyaW9yXyhFKSxFLmNoZWNrKCksdT09PXIuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5vdXRwdXRDb250b3Vyc18oRSxoKTp0aGlzLm91dHB1dFBvbHltZXNoXyhFLHUsYSxoKSwhMH19fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1yO3ZhciB0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gcigpe2Zvcih2YXIgbj17fSxzPTA7czxhcmd1bWVudHMubGVuZ3RoO3MrKyl7dmFyIGw9YXJndW1lbnRzW3NdO2Zvcih2YXIgYyBpbiBsKXQuY2FsbChsLGMpJiYobltjXT1sW2NdKX1yZXR1cm4gbn19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZVNoYWRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiYXBwbHlTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY3JlYXRlQ2xvdWRTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImFwcGx5Q2xvdWRTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDY0KSxuPXQoNjUpLHM9dCg2NiksbD10KDY3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYz1TeW1ib2woInNoYWRlcnMiKTtmdW5jdGlvbiBvKG0pe21bY109W107Zm9yKGxldCBUPTA7VDwxNjtUKyspe2NvbnN0IE89W10sdj0hIShUJjEpLFA9ISEoVCYyKSxpPSEhKFQmNCksdT0hIShUJjgpO3YmJk8ucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxQJiZPLnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxpJiZPLnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLHUmJk8ucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3QgYT1gJHtPLmpvaW4oYApgKX0KYCxoPVtdO3YmJmgucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpLHUmJmgucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV9jbGlwU2FtcGxlcjsiKSxtW2NdW1RdPVthK2guam9pbihgCmApK24uZGVmYXVsdCxhK3IuZGVmYXVsdF19fWZ1bmN0aW9uIGYobSx7aGFzVGV4dHVyZTpUPSExLGhhc0ZpbHRlcjpPPSExLGhhc0dyYWRpZW50OnY9ITEsaGFzQ2xpcFBhdGg6UD0hMX09e30pe2NvbnN0IGk9VHxPPDwxfHY8PDJ8UDw8MztsZXQgdT1tW2NdW2ldO0FycmF5LmlzQXJyYXkodSkmJih1PW0uY3JlYXRlUHJvZ3JhbSguLi51KSxtW2NdW2ldPXUpLG0ucHJvZ3JhbSE9PXUmJm0udXNlUHJvZ3JhbSh1LHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSl9Y29uc3QgeD1bXTtmdW5jdGlvbiBnKG0pe2ZvcihsZXQgVD0wO1Q8NjQ7VCsrKXtjb25zdCBPPVtdLHY9ISEoVCYxKSxQPSEhKFQmMiksaT0hIShUJjQpLHU9ISEoVCY4KSxhPSEhKFQmMTYpLGg9ISEoVCYzMik7diYmTy5wdXNoKCIjZGVmaW5lIFRFWFRVUkUgMSIpLFAmJk8ucHVzaCgiI2RlZmluZSBGSUxURVIgMSIpLGkmJk8ucHVzaCgiI2RlZmluZSBHUkFESUVOVCAxIiksdSYmTy5wdXNoKCIjZGVmaW5lIENMT1VEQ09MT1IgMSIpLGEmJk8ucHVzaCgiI2RlZmluZSBDTE9VREZJTFRFUiAxIiksaCYmTy5wdXNoKCIjZGVmaW5lIENMSVBQQVRIIDEiKTtjb25zdCBiPWAke08uam9pbihgCmApfQpgLEU9W107aWYodil7RS5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7Iik7Zm9yKGxldCBBPTA7QTwxMjtBKyspRS5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleEZyYW1lJHtBfTtgKX1oJiZFLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IikseFtUXT1bYitFLmpvaW4oYApgKStsLmRlZmF1bHQsYitzLmRlZmF1bHRdfX1mdW5jdGlvbiB5KG0se2hhc1RleHR1cmU6VD0hMSxoYXNGaWx0ZXI6Tz0hMSxoYXNHcmFkaWVudDp2PSExLGhhc0Nsb3VkQ29sb3I6UD0hMSxoYXNDbG91ZEZpbHRlcjppPSExLGhhc0NsaXBQYXRoOnU9ITF9PXt9KXtjb25zdCBhPVR8Tzw8MXx2PDwyfFA8PDN8aTw8NHx1PDw1O2xldCBoPXhbYV07QXJyYXkuaXNBcnJheShoKSYmKGg9bS5jcmVhdGVQcm9ncmFtKC4uLmgpLHhbYV09aCksbS5wcm9ncmFtIT09aCYmbS51c2VQcm9ncmFtKGgse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSl9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKI2lmZGVmIFRFWFRVUkUKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsKCiNpZmRlZiBHUkFESUVOVAogIHZlYzMgdmcxID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclswXSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsxXSwgMS4wKTsKICB2ZWMzIHZnMiA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbM10sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNF0sIDEuMCk7CiAgZmxvYXQgaCA9IHVfcmVzb2x1dGlvbi55OwogIHZnMS55ID0gaCAtIHZnMS55OwogIHZnMi55ID0gaCAtIHZnMi55OwogIHZHcmFkaWVudFZlY3RvcjEgPSB2ZWMzKHZnMS54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsyXSk7CiAgdkdyYWRpZW50VmVjdG9yMiA9IHZlYzModmcyLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzVdKTsKI2VuZGlmCiAgCiAgZmxhZ0JhY2tncm91bmQgPSBhX3ZlcnRleFBvc2l0aW9uLno7CiAgdkNvbG9yID0gYV9jb2xvcjsKCiNpZmRlZiBURVhUVVJFCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCn1gfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp1bmlmb3JtIGludCB1X2ZpbHRlckZsYWc7CnVuaWZvcm0gZmxvYXQgdV9jb2xvck1hdHJpeFsyMF07CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKLy8gdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgojaWZkZWYgRklMVEVSCnZvaWQgdHJhbnNmb3JtQ29sb3IoaW5vdXQgdmVjNCBjb2xvciwgaW4gZmxvYXQgY29sb3JNYXRyaXhbMjBdKSB7CiAgZmxvYXQgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgYSA9IGNvbG9yLmE7CiAgY29sb3JbMF0gPSBjb2xvck1hdHJpeFswXSAqIHIgKyBjb2xvck1hdHJpeFsxXSAqIGcgKyBjb2xvck1hdHJpeFsyXSAqIGIgKyBjb2xvck1hdHJpeFszXSAqIGEgKyBjb2xvck1hdHJpeFs0XTsKICBjb2xvclsxXSA9IGNvbG9yTWF0cml4WzVdICogciArIGNvbG9yTWF0cml4WzZdICogZyArIGNvbG9yTWF0cml4WzddICogYiArIGNvbG9yTWF0cml4WzhdICogYSArIGNvbG9yTWF0cml4WzldOwogIGNvbG9yWzJdID0gY29sb3JNYXRyaXhbMTBdICogciArIGNvbG9yTWF0cml4WzExXSAqIGcgKyBjb2xvck1hdHJpeFsxMl0gKiBiICsgY29sb3JNYXRyaXhbMTNdICogYSArIGNvbG9yTWF0cml4WzE0XTsKICBjb2xvclszXSA9IGNvbG9yTWF0cml4WzE1XSAqIHIgKyBjb2xvck1hdHJpeFsxNl0gKiBnICsgY29sb3JNYXRyaXhbMTddICogYiArIGNvbG9yTWF0cml4WzE4XSAqIGEgKyBjb2xvck1hdHJpeFsxOV07Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgIHRleENvbG9yLmEgKj0gb3BhY2l0eTsKICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgIH0KICAgICAgLy8gY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY2xhbXAoY29sb3IuYSAvIG1heCgwLjAwMDEsIHRleENvbG9yLmEpLCAwLjAsIDEuMCkpOwogICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIGZsb2F0IGNsaXAgPSB0ZXh0dXJlMkQodV9jbGlwU2FtcGxlciwgdkNsaXBVVikucjsKICBjb2xvciAqPSBjbGlwOwojZW5kaWYKCiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7Cn1gfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0wOwphdHRyaWJ1dGUgdmVjMyBhX3RyYW5zZm9ybTE7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIGZsb2F0IGFfZnJhbWVJbmRleDsKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4OwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQwOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQxOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQyOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQzOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQ0Owp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgQ0xPVURDT0xPUgphdHRyaWJ1dGUgdmVjNCBhX2ZpbGxDbG91ZENvbG9yOwphdHRyaWJ1dGUgdmVjNCBhX3N0cm9rZUNsb3VkQ29sb3I7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwojZW5kaWYKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CgogIG1hdDMgbW9kZWxNYXRyaXggPSBtYXQzKAogICAgYV90cmFuc2Zvcm0wLngsIGFfdHJhbnNmb3JtMS54LCAwLCAKICAgIGFfdHJhbnNmb3JtMC55LCBhX3RyYW5zZm9ybTEueSwgMCwKICAgIGFfdHJhbnNmb3JtMC56LCBhX3RyYW5zZm9ybTEueiwgMQogICk7CgogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwoKI2lmZGVmIENMT1VEQ09MT1IKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdkNvbG9yID0gbWl4KGFfY29sb3IsIGFfZmlsbENsb3VkQ29sb3IsIGFfZmlsbENsb3VkQ29sb3IuYSk7CiAgfSBlbHNlIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IsIGFfc3Ryb2tlQ2xvdWRDb2xvci5hKTsKICB9CiNlbHNlCiAgdkNvbG9yID0gYV9jb2xvcjsKI2VuZGlmCgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICBmcmFtZUluZGV4ID0gYV9mcmFtZUluZGV4OwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKICBjb2xvckNsb3VkMCA9IGFfY29sb3JDbG91ZDA7CiAgY29sb3JDbG91ZDEgPSBhX2NvbG9yQ2xvdWQxOwogIGNvbG9yQ2xvdWQyID0gYV9jb2xvckNsb3VkMjsKICBjb2xvckNsb3VkMyA9IGFfY29sb3JDbG91ZDM7CiAgY29sb3JDbG91ZDQgPSBhX2NvbG9yQ2xvdWQ0OwojZW5kaWYKfWB9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CgojaWZkZWYgVEVYVFVSRQp2YXJ5aW5nIGZsb2F0IGZyYW1lSW5kZXg7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JTdGVwc1s0MF07CnVuaWZvcm0gaW50IHVfZ3JhZGllbnRUeXBlOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CgojaWZkZWYgQ0xPVURGSUxURVIKdm9pZCBidWlsZENsb3VkQ29sb3IoaW5vdXQgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF0pIHsKICBjb2xvckNsb3VkTWF0cml4WzBdID0gY29sb3JDbG91ZDBbMF07CiAgY29sb3JDbG91ZE1hdHJpeFsxXSA9IGNvbG9yQ2xvdWQxWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMl0gPSBjb2xvckNsb3VkMlswXTsKICBjb2xvckNsb3VkTWF0cml4WzNdID0gY29sb3JDbG91ZDNbMF07CiAgY29sb3JDbG91ZE1hdHJpeFs0XSA9IGNvbG9yQ2xvdWQ0WzBdOwoKICBjb2xvckNsb3VkTWF0cml4WzVdID0gY29sb3JDbG91ZDBbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs2XSA9IGNvbG9yQ2xvdWQxWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbN10gPSBjb2xvckNsb3VkMlsxXTsKICBjb2xvckNsb3VkTWF0cml4WzhdID0gY29sb3JDbG91ZDNbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs5XSA9IGNvbG9yQ2xvdWQ0WzFdOwoKICBjb2xvckNsb3VkTWF0cml4WzEwXSA9IGNvbG9yQ2xvdWQwWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTFdID0gY29sb3JDbG91ZDFbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxMl0gPSBjb2xvckNsb3VkMlsyXTsKICBjb2xvckNsb3VkTWF0cml4WzEzXSA9IGNvbG9yQ2xvdWQzWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTRdID0gY29sb3JDbG91ZDRbMl07CgogIGNvbG9yQ2xvdWRNYXRyaXhbMTVdID0gY29sb3JDbG91ZDBbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxNl0gPSBjb2xvckNsb3VkMVszXTsKICBjb2xvckNsb3VkTWF0cml4WzE3XSA9IGNvbG9yQ2xvdWQyWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMThdID0gY29sb3JDbG91ZDNbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxOV0gPSBjb2xvckNsb3VkNFszXTsKfQojZW5kaWYKCnZvaWQgbWFpbigpIHsKICB2ZWM0IGNvbG9yID0gdkNvbG9yOwogIGZsb2F0IG9wYWNpdHkgPSBhYnMoZmxhZ0JhY2tncm91bmQpOwoKI2lmZGVmIEdSQURJRU5UCiAgaWYodV9ncmFkaWVudFR5cGUgPiAwICYmIGZsYWdCYWNrZ3JvdW5kID4gMC4wIHx8IHVfZ3JhZGllbnRUeXBlID09IDAgJiYgZmxhZ0JhY2tncm91bmQgPD0gMC4wKSB7CiAgICBncmFkaWVudChjb2xvciwgdkdyYWRpZW50VmVjdG9yMSwgdkdyYWRpZW50VmVjdG9yMiwgdV9jb2xvclN0ZXBzKTsKICB9CiNlbmRpZgoKICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICBjb2xvci5hICo9IG9wYWNpdHk7CiAgfQoKI2lmZGVmIFRFWFRVUkUKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdmVjMyB0ZXhDb29yZCA9IHZUZXh0dXJlQ29vcmQ7CgogICAgaWYodGV4Q29vcmQueiA9PSAxLjApIHsKICAgICAgdGV4Q29vcmQgPSBmcmFjdCh0ZXhDb29yZCk7CiAgICB9CgogICAgaWYodGV4Q29vcmQueCA8PSAxLjAgJiYgdGV4Q29vcmQueCA+PSAwLjAKICAgICAgJiYgdGV4Q29vcmQueSA8PSAxLjAgJiYgdGV4Q29vcmQueSA+PSAwLjApIHsKICAgICAgaWYodlNvdXJjZVJlY3QueiA+IDAuMCkgewogICAgICAgIHRleENvb3JkLnggPSB2U291cmNlUmVjdC54ICsgdGV4Q29vcmQueCAqIHZTb3VyY2VSZWN0Lno7CiAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtICh2U291cmNlUmVjdC55ICsgKDEuMCAtIHRleENvb3JkLnkpICogdlNvdXJjZVJlY3Qudyk7CiAgICAgIH0KICAgICAgaWYoZnJhbWVJbmRleCA8IDAuMCkgewogICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgICAgY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbnQgaW5kZXggPSBpbnQoZmxvb3IoY2xhbXAoMC4wLCAxMS4wLCBmcmFtZUluZGV4KSkpOwogICAgICAgIHZlYzQgdGV4Q29sb3I7CiAgICAgICAgaWYoaW5kZXggPT0gMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAyKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMiwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMykgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTMsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDQpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU0LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA1KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTYsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDcpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU3LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA4KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lOCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTksIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEwKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgICAgfQogICAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgICAgLy8gY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjb2xvci5hKTsKICAgICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICAgIH0KICAgIH0KICB9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgogIGlmKHVfZmlsdGVyRmxhZyA+IDApIHsKICAgIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCB1X2NvbG9yTWF0cml4KTsKICB9CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF07CiAgYnVpbGRDbG91ZENvbG9yKGNvbG9yQ2xvdWRNYXRyaXgpOwogIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCBjb2xvckNsb3VkTWF0cml4KTsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSwoZnVuY3Rpb24ocixuKXt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBjfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHMoKXtpZih0eXBlb2YgcGVyZm9ybWFuY2U8InUiJiZwZXJmb3JtYW5jZS5ub3cpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKHR5cGVvZiByPCJ1IiYmci5ocnRpbWUpe2NvbnN0W28sZl09ci5ocnRpbWUoKTtyZXR1cm4gbyoxZTMrZioxZS02fXJldHVybiBEYXRlLm5vdz9EYXRlLm5vdygpOm5ldyBEYXRlKCkuZ2V0VGltZSgpfWxldCBsLGM7dHlwZW9mIG48InUiJiZ0eXBlb2Ygbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9PSJmdW5jdGlvbiI/KGw9bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsYz1uLmNhbmNlbEFuaW1hdGlvbkZyYW1lKToobD1mdW5jdGlvbihvKXtyZXR1cm4gc2V0VGltZW91dCgoKT0+e28ocygpKX0sMTYpfSxjPWZ1bmN0aW9uKG8pe3JldHVybiBjbGVhclRpbWVvdXQobyl9KX0pLmNhbGwodGhpcyx0KDY5KSx0KDIyKSl9LGZ1bmN0aW9uKGQsZSl7dmFyIHQ9ZC5leHBvcnRzPXt9LHIsbjtmdW5jdGlvbiBzKCl7dGhyb3cgbmV3IEVycm9yKCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9ZnVuY3Rpb24gbCgpe3Rocm93IG5ldyBFcnJvcigiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9KGZ1bmN0aW9uKCl7dHJ5e3R5cGVvZiBzZXRUaW1lb3V0PT0iZnVuY3Rpb24iP3I9c2V0VGltZW91dDpyPXN9Y2F0Y2h7cj1zfXRyeXt0eXBlb2YgY2xlYXJUaW1lb3V0PT0iZnVuY3Rpb24iP249Y2xlYXJUaW1lb3V0Om49bH1jYXRjaHtuPWx9fSkoKTtmdW5jdGlvbiBjKFApe2lmKHI9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KFAsMCk7aWYoKHI9PT1zfHwhcikmJnNldFRpbWVvdXQpcmV0dXJuIHI9c2V0VGltZW91dCxzZXRUaW1lb3V0KFAsMCk7dHJ5e3JldHVybiByKFAsMCl9Y2F0Y2h7dHJ5e3JldHVybiByLmNhbGwobnVsbCxQLDApfWNhdGNoe3JldHVybiByLmNhbGwodGhpcyxQLDApfX19ZnVuY3Rpb24gbyhQKXtpZihuPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQoUCk7aWYoKG49PT1sfHwhbikmJmNsZWFyVGltZW91dClyZXR1cm4gbj1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KFApO3RyeXtyZXR1cm4gbihQKX1jYXRjaHt0cnl7cmV0dXJuIG4uY2FsbChudWxsLFApfWNhdGNoe3JldHVybiBuLmNhbGwodGhpcyxQKX19fXZhciBmPVtdLHg9ITEsZyx5PS0xO2Z1bmN0aW9uIG0oKXsheHx8IWd8fCh4PSExLGcubGVuZ3RoP2Y9Zy5jb25jYXQoZik6eT0tMSxmLmxlbmd0aCYmVCgpKX1mdW5jdGlvbiBUKCl7aWYoIXgpe3ZhciBQPWMobSk7eD0hMDtmb3IodmFyIGk9Zi5sZW5ndGg7aTspe2ZvcihnPWYsZj1bXTsrK3k8aTspZyYmZ1t5XS5ydW4oKTt5PS0xLGk9Zi5sZW5ndGh9Zz1udWxsLHg9ITEsbyhQKX19dC5uZXh0VGljaz1mdW5jdGlvbihQKXt2YXIgaT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciB1PTE7dTxhcmd1bWVudHMubGVuZ3RoO3UrKylpW3UtMV09YXJndW1lbnRzW3VdO2YucHVzaChuZXcgTyhQLGkpKSxmLmxlbmd0aD09PTEmJiF4JiZjKFQpfTtmdW5jdGlvbiBPKFAsaSl7dGhpcy5mdW49UCx0aGlzLmFycmF5PWl9Ty5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0sdC50aXRsZT0iYnJvd3NlciIsdC5icm93c2VyPSEwLHQuZW52PXt9LHQuYXJndj1bXSx0LnZlcnNpb249IiIsdC52ZXJzaW9ucz17fTtmdW5jdGlvbiB2KCl7fXQub249dix0LmFkZExpc3RlbmVyPXYsdC5vbmNlPXYsdC5vZmY9dix0LnJlbW92ZUxpc3RlbmVyPXYsdC5yZW1vdmVBbGxMaXN0ZW5lcnM9dix0LmVtaXQ9dix0LnByZXBlbmRMaXN0ZW5lcj12LHQucHJlcGVuZE9uY2VMaXN0ZW5lcj12LHQubGlzdGVuZXJzPWZ1bmN0aW9uKFApe3JldHVybltdfSx0LmJpbmRpbmc9ZnVuY3Rpb24oUCl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCIpfSx0LmN3ZD1mdW5jdGlvbigpe3JldHVybiIvIn0sdC5jaGRpcj1mdW5jdGlvbihQKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCIpfSx0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBBfSk7dmFyIHI9dCgxKSxuPXQoNzEpLHM9dCg3MyksbD10KDIxMyksYz10KDIxNCksbz10KDIxNSksZj10KDIxNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHgoTCxTKXt2YXIgST1PYmplY3Qua2V5cyhMKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKEwpO1MmJihEPUQuZmlsdGVyKGZ1bmN0aW9uKFIpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEwsUikuZW51bWVyYWJsZX0pKSxJLnB1c2guYXBwbHkoSSxEKX1yZXR1cm4gSX1mdW5jdGlvbiBnKEwpe2Zvcih2YXIgUz0xO1M8YXJndW1lbnRzLmxlbmd0aDtTKyspe3ZhciBJPWFyZ3VtZW50c1tTXSE9bnVsbD9hcmd1bWVudHNbU106e307UyUyP3goT2JqZWN0KEkpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEQpe3koTCxELElbRF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhJKSk6eChPYmplY3QoSSkpLmZvckVhY2goZnVuY3Rpb24oRCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KEwsRCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEksRCkpfSl9cmV0dXJuIEx9ZnVuY3Rpb24geShMLFMsSSl7cmV0dXJuIFMgaW4gTD9PYmplY3QuZGVmaW5lUHJvcGVydHkoTCxTLHt2YWx1ZTpJLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6TFtTXT1JLEx9Y29uc3QgbT1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxUPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxPPVN5bWJvbCgicmVzb2x1dGlvbiIpLHY9U3ltYm9sKCJhbmltYXRpb25zIiksUD1TeW1ib2woImV2ZW50TGlzdGVuZXJzIiksaT1TeW1ib2woImNhcHR1cmVFdmVudExpc3RlbmVycyIpLHU9U3ltYm9sKCJmaWx0ZXJzIiksYT1TeW1ib2woImRpc3BsYXkiKSxoPVN5bWJvbCgicHJvZ3JhbSIpLGI9U3ltYm9sKCJzaGFkZXJBdHRycyIpLEU9U3ltYm9sKCJ1bmlmb3JtcyIpO2NsYXNzIEF7Y29uc3RydWN0b3IoUz17fSl7dGhpcy5hdHRyaWJ1dGVzPW5ldyB0aGlzLmNvbnN0cnVjdG9yLkF0dHIodGhpcyksdGhpc1tPXT17d2lkdGg6MzAwLGhlaWdodDoxNTB9LE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLFMpLHRoaXNbdl09bmV3IFNldCx0aGlzW1BdPXt9LHRoaXNbaV09e319Z2V0IGFuY2VzdG9ycygpe2xldCBTPXRoaXMucGFyZW50O2NvbnN0IEk9W107Zm9yKDtTOylJLnB1c2goUyksUz1TLnBhcmVudDtyZXR1cm4gSX1nZXQgYW5pbWF0aW9ucygpe3JldHVybiB0aGlzW3ZdfWdldCBmaWx0ZXJzKCl7cmV0dXJuIHRoaXNbdV18fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5maWx0ZXJzfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hMX1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQubGF5ZXI6bnVsbH1nZXQgbG9jYWxNYXRyaXgoKXtjb25zdCBTPXRoaXMudHJhbnNmb3JtTWF0cml4LHt4OkkseTpEfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIFNbNF0rPUksU1s1XSs9RCxTfWdldCBvcGFjaXR5KCl7bGV0IFM9dGhpcy5hdHRyaWJ1dGVzLm9wYWNpdHk7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcGFjaXR5IT1udWxsJiYoUyo9dGhpcy5wYXJlbnQub3BhY2l0eSksU31nZXQgcGFyZW50Tm9kZSgpe3JldHVybiB0aGlzLnBhcmVudH1nZXQgbmV4dFNpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KDEpfWdldCBwcmV2aW91c1NpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KC0xKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW2hdfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5yZW5kZXJlcjpudWxsfWdldCByZW5kZXJNYXRyaXgoKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXgpcmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeDtsZXQgUz10aGlzLmxvY2FsTWF0cml4O2NvbnN0IEk9dGhpcy5wYXJlbnQ7aWYoSSl7Y29uc3QgRD1JLl9fY2FjaGVSZW5kZXJNYXRyaXh8fEkucmVuZGVyTWF0cml4O0QmJihTPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsUykpfXJldHVybiBTfWdldCB3b3JsZFNjYWxpbmcoKXtjb25zdCBTPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltNYXRoLmh5cG90KFNbMF0sU1sxXSksTWF0aC5oeXBvdChTWzJdLFNbM10pXX1nZXQgd29ybGRSb3RhdGlvbigpe2NvbnN0IFM9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuIE1hdGguYXRhbjIoU1sxXSxTWzNdKX1nZXQgd29ybGRQb3NpdGlvbigpe2NvbnN0IFM9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuW1NbNF0sU1s1XV19Z2V0IHVuaWZvcm1zKCl7cmV0dXJuIHRoaXNbRV19Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuY2xhc3NOYW1lfXNldCBjbGFzc05hbWUoUyl7dGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZT1TfWdldCBpZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuaWR9c2V0IGlkKFMpe3RoaXMuYXR0cmlidXRlcy5pZD1TfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5uYW1lfXNldCBuYW1lKFMpe3RoaXMuYXR0cmlidXRlcy5uYW1lPVN9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuekluZGV4fXNldCB6SW5kZXgoUyl7dGhpcy5hdHRyaWJ1dGVzLnpJbmRleD1TfWdldCBtZXNoKCl7cmV0dXJuIG51bGx9Z2V0IHNoYWRlckF0dHJzKCl7cmV0dXJuIHRoaXNbYl18fHt9fWFjdGl2YXRlQW5pbWF0aW9ucygpe2NvbnN0IFM9dGhpcy5sYXllcjtpZihTKXtjb25zdCBJPXRoaXNbdl07SS5mb3JFYWNoKFI9PntSLmJhc2VUaW1lbGluZT1TLnRpbWVsaW5lLFIucGxheSgpLFIuZmluaXNoZWQudGhlbigoKT0+e0kuZGVsZXRlKFIpfSl9KTtjb25zdCBEPXRoaXMuY2hpbGRyZW47RCYmRC5mb3JFYWNoKFI9PntSLmFjdGl2YXRlQW5pbWF0aW9ucyYmUi5hY3RpdmF0ZUFuaW1hdGlvbnMoKX0pfX1hZGRFdmVudExpc3RlbmVyKFMsSSxEPXt9KXtTPT09Im1vdXNld2hlZWwiJiYoUz0id2hlZWwiKSx0eXBlb2YgRD09ImJvb2xlYW4iJiYoRD17Y2FwdHVyZTpEfSk7Y29uc3R7Y2FwdHVyZTpSLG9uY2U6Q309RCxqPVI/aTpQO3JldHVybiB0aGlzW2pdW1NdPXRoaXNbal1bU118fFtdLHRoaXNbal1bU10ucHVzaCh7bGlzdGVuZXI6SSxvbmNlOkN9KSx0aGlzfWFuaW1hdGUoUyxJKXtjb25zdCBEPW5ldyBzLmRlZmF1bHQodGhpcyxTLEkpO3JldHVybiB0aGlzLmVmZmVjdHMmJkQuYXBwbHlFZmZlY3RzKHRoaXMuZWZmZWN0cyksdGhpcy5sYXllciYmKEQuYmFzZVRpbWVsaW5lPXRoaXMubGF5ZXIudGltZWxpbmUsRC5wbGF5KCksRC5maW5pc2hlZC50aGVuKCgpPT57dGhpc1t2XS5kZWxldGUoRCl9KSksdGhpc1t2XS5hZGQoRCksRH1hdHRyKC4uLlMpe2lmKFMubGVuZ3RoPT09MClyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW1RdO2lmKFMubGVuZ3RoPjEpe2xldFtJLERdPVM7cmV0dXJuIHR5cGVvZiBEPT0iZnVuY3Rpb24iJiYoRD1EKHRoaXMuYXR0cihJKSkpLHRoaXMuc2V0QXR0cmlidXRlKEksRCksdGhpc31yZXR1cm4gdHlwZW9mIFNbMF09PSJzdHJpbmciP3RoaXMuZ2V0QXR0cmlidXRlKFNbMF0pOihPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxTWzBdKSx0aGlzKX1jbG9uZU5vZGUoKXtjb25zdCBTPW5ldyB0aGlzLmNvbnN0cnVjdG9yLEk9dGhpcy5hdHRyaWJ1dGVzW21dO3JldHVybiBTLmF0dHIoSSksU31jb25uZWN0KFMsSSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOlMsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkksd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksUy50aW1lbGluZSYmdGhpcy5hY3RpdmF0ZUFuaW1hdGlvbnMoKSx0aGlzLnNldFJlc29sdXRpb24oUy5nZXRSZXNvbHV0aW9uKCkpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImFwcGVuZCIsZGV0YWlsOntwYXJlbnQ6Uyx6T3JkZXI6SX19KX1jb250YWlucyhTKXtmb3IoO1MmJnRoaXMhPT1TOylTPVMucGFyZW50O3JldHVybiEhU31kZWFjdGl2YXRlQW5pbWF0aW9ucygpe3RoaXNbdl0uZm9yRWFjaChJPT5JLmNhbmNlbCgpKTtjb25zdCBTPXRoaXMuY2hpbGRyZW47UyYmUy5mb3JFYWNoKEk9PntJLmRlYWN0aXZhdGVBbmltYXRpb25zJiZJLmRlYWN0aXZhdGVBbmltYXRpb25zKCl9KX1kaXNjb25uZWN0KCl7Y29uc3R7cGFyZW50OlMsek9yZGVyOkl9PXRoaXM7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcix0aGlzLmRlYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZW1vdmUiLGRldGFpbDp7cGFyZW50OlMsek9yZGVyOkl9fSksUyYmUy5mb3JjZVVwZGF0ZSgpfWRpc3BhdGNoRXZlbnQoUyl7UyBpbnN0YW5jZW9mIGMuZGVmYXVsdHx8KFM9bmV3IGMuZGVmYXVsdChTKSksUy50YXJnZXQ9dGhpcztsZXQgST1TLnR5cGU7ST09PSJtb3VzZXdoZWVsIiYmKEk9IndoZWVsIik7Y29uc3QgRD1bdGhpc107bGV0IFI9dGhpcy5wYXJlbnQ7Zm9yKDtTLmJ1YmJsZXMmJlI7KUQucHVzaChSKSxSPVIucGFyZW50O2ZvcihsZXQgQz1ELmxlbmd0aC0xO0M+PTA7Qy0tKXtjb25zdCBqPURbQ10sJD1qW2ldJiZqW2ldW0ldO2lmKCQmJiQubGVuZ3RoJiYoUy5jdXJyZW50VGFyZ2V0PWosJC5mb3JFYWNoKCh7bGlzdGVuZXI6SCxvbmNlOkp9KT0+e0guY2FsbCh0aGlzLFMpLEomJkQucmVtb3ZlRXZlbnRMaXN0ZW5lcihIKX0pLGRlbGV0ZSBTLmN1cnJlbnRUYXJnZXQpLCFTLmJ1YmJsZXMmJlMuY2FuY2VsQnViYmxlKWJyZWFrfWlmKCFTLmNhbmNlbEJ1YmJsZSlmb3IobGV0IEM9MDtDPEQubGVuZ3RoO0MrKyl7Y29uc3Qgaj1EW0NdLCQ9altQXSYmaltQXVtJXTtpZigkJiYkLmxlbmd0aCYmKFMuY3VycmVudFRhcmdldD1qLCQuZm9yRWFjaCgoe2xpc3RlbmVyOkgsb25jZTpKfSk9PntILmNhbGwodGhpcyxTKSxKJiZELnJlbW92ZUV2ZW50TGlzdGVuZXIoSCl9KSxkZWxldGUgUy5jdXJyZW50VGFyZ2V0KSwhUy5idWJibGVzfHxTLmNhbmNlbEJ1YmJsZSlicmVha319ZGlzcGF0Y2hQb2ludGVyRXZlbnQoUyl7Y29uc3R7bGF5ZXJYOkksbGF5ZXJZOkR9PVM7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihJLEQpPyh0aGlzLmRpc3BhdGNoRXZlbnQoUyksITApOiExfWRyYXcoUz1bXSl7Y29uc3QgST10aGlzLm1lc2g7aWYoSSl7aWYoT2JqZWN0KG8uYXBwbHlGaWx0ZXJzKShJLHRoaXMuZmlsdGVycyksUy5wdXNoKEkpLHRoaXNbaF0pe0kuc2V0UHJvZ3JhbSh0aGlzW2hdKTtjb25zdCBEPXRoaXNbYl07RCYmT2JqZWN0LmVudHJpZXMoRCkuZm9yRWFjaCgoW0Msal0pPT57SS5zZXRBdHRyaWJ1dGUoQyxqKX0pO2NvbnN0IFI9dGhpc1tFXTtpZih0aGlzW0VdKXtjb25zdCBDPXt9O09iamVjdC5lbnRyaWVzKFIpLmZvckVhY2goKFtqLCRdKT0+e3R5cGVvZiAkPT0iZnVuY3Rpb24iJiYoJD0kKHRoaXMsaikpLENbal09JH0pLEkuc2V0VW5pZm9ybXMoQyl9fU9iamVjdChmLmRlZmF1bHQpKHRoaXMsSSl9cmV0dXJuIFN9Zm9yY2VVcGRhdGUoKXt0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKX1nZXRBdHRyaWJ1dGUoUyl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tTXX1nZXRMaXN0ZW5lcnMoUyx7Y2FwdHVyZTpJPSExfT17fSl7cmV0dXJuWy4uLnRoaXNbST9pOlBdW1NdfHxbXV19Z2V0Tm9kZU5lYXJCeShTPTEpe2lmKCF0aGlzLnBhcmVudClyZXR1cm4gbnVsbDtpZihTPT09MClyZXR1cm4gdGhpcztjb25zdCBJPXRoaXMucGFyZW50LmNoaWxkcmVuLEQ9SS5pbmRleE9mKHRoaXMpO3JldHVybiBJW0QrU119Z2V0V29ybGRQb3NpdGlvbihTLEkpe2NvbnN0IEQ9dGhpcy5yZW5kZXJNYXRyaXgsUj1TKkRbMF0rSSpEWzJdK0RbNF0sQz1TKkRbMV0rSSpEWzNdK0RbNV07cmV0dXJuW1IsQ119Z2V0T2Zmc2V0UG9zaXRpb24oUyxJKXtjb25zdCBEPXIubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLnJlbmRlck1hdHJpeCksUj1TKkRbMF0rSSpEWzJdK0RbNF0sQz1TKkRbMV0rSSpEWzNdK0RbNV07cmV0dXJuW1IsQ119Z2V0UmVzb2x1dGlvbigpe3JldHVybiBnKHt9LHRoaXNbT10pfWlzUG9pbnRDb2xsaXNpb24oUyxJKXtpZighdGhpcy5tZXNoKXJldHVybiExO2NvbnN0IEQ9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoRD09PSJub25lInx8RCE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IFI9ImJvdGgiO3JldHVybiBEPT09InZpc2libGVGaWxsIiYmKFI9ImZpbGwiKSxEPT09InZpc2libGVTdHJva2UiJiYoUj0ic3Ryb2tlIiksdGhpcy5tZXNoLmlzUG9pbnRDb2xsaXNpb24oUyxJLFIpfW9uUHJvcGVydHlDaGFuZ2UoUyxJLEQpe1MhPT0iaWQiJiZTIT09Im5hbWUiJiZTIT09ImNsYXNzTmFtZSImJlMhPT0icG9pbnRlckV2ZW50cyImJlMhPT0icGFzc0V2ZW50cyImJnRoaXMuZm9yY2VVcGRhdGUoKSxTPT09ImZpbHRlciImJih0aGlzW3VdPU9iamVjdChvLnBhcnNlRmlsdGVyU3RyaW5nKShJKSksUz09PSJ6SW5kZXgiJiZ0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVvcmRlcigpfXNldEF0dHJpYnV0ZShTLEkpe1M9PT0iYXR0cnMiJiZ0aGlzLmF0dHIoSSksdGhpcy5hdHRyaWJ1dGVzW1NdPUl9c2V0TW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmKHRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PXRoaXMpfXNldFByb2dyYW0oUyl7dGhpc1toXT1TLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRTaGFkZXJBdHRyaWJ1dGUoUyxJKXt0aGlzW2JdPXRoaXNbYl18fHt9LHRoaXNbYl1bU109SSx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0VW5pZm9ybXMoUyl7dGhpc1tFXT10aGlzW0VdfHx7fSxPYmplY3QuYXNzaWduKHRoaXNbRV0sUyksdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFJlc29sdXRpb24oe3dpZHRoOlMsaGVpZ2h0Okl9KXtjb25zdHt3aWR0aDpELGhlaWdodDpSfT10aGlzW09dOyhEIT09U3x8UiE9PUkpJiYodGhpc1tPXT17d2lkdGg6UyxoZWlnaHQ6SX0sdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzb2x1dGlvbmNoYW5nZSIsZGV0YWlsOnt3aWR0aDpTLGhlaWdodDpJfX0pKX1zaG93KCl7dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSImJih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT10aGlzW2FdfHwiIil9aGlkZSgpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiJiYodGhpc1thXT10aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSx0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT0ibm9uZSIpfXJlbGVhc2VNb3VzZUNhcHR1cmUoKXt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD09PXRoaXMmJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsKX1yZW1vdmUoKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlbW92ZUNoaWxkPyh0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSwhMCk6ITF9cmVtb3ZlQWxsTGlzdGVuZXJzKFMsST17fSl7dHlwZW9mIEk9PSJib29sZWFuIiYmKEk9e2NhcHR1cmU6SX0pO2NvbnN0IFI9SS5jYXB0dXJlP2k6UDtyZXR1cm4gdGhpc1tSXVtTXSYmKHRoaXNbUl1bU109W10pLHRoaXN9cmVtb3ZlQXR0cmlidXRlKFMpe3RoaXMuc2V0QXR0cmlidXRlKFMsbnVsbCl9cmVtb3ZlRXZlbnRMaXN0ZW5lcihTLEksRD17fSl7dHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0IEM9RC5jYXB0dXJlP2k6UDtpZih0aGlzW0NdW1NdKXtjb25zdCBqPXRoaXNbQ11bU107aWYoailmb3IobGV0ICQ9MDskPGoubGVuZ3RoOyQrKyl7Y29uc3R7bGlzdGVuZXI6SH09alskXTtpZihIPT09SSl7dGhpc1tDXVtTXS5zcGxpY2UoJCwxKTticmVha319fXJldHVybiB0aGlzfXRyYW5zaXRpb24oUyxJPSJsaW5lYXIiKXtjb25zdCBEPXRoaXMsUj1TeW1ib2woImFuaW1hdGlvbiIpO0k9SXx8ImxpbmVhciI7bGV0IEM9MDtyZXR1cm4gdHlwZW9mIFM9PSJvYmplY3QiJiYoQz1TLmRlbGF5fHwwLFM9Uy5kdXJhdGlvbikse1tSXTpudWxsLGNhbmNlbChqPSExKXtjb25zdCAkPXRoaXNbUl07JCYmJC5jYW5jZWwoail9LGVuZCgpe2NvbnN0IGo9dGhpc1tSXTtqJiYoai5wbGF5U3RhdGU9PT0icnVubmluZyJ8fGoucGxheVN0YXRlPT09InBlbmRpbmciKSYmai5maW5pc2goKX0scmV2ZXJzZSgpe2NvbnN0IGo9dGhpc1tSXTtpZihqKWlmKGoucGxheVN0YXRlPT09InJ1bm5pbmcifHxqLnBsYXlTdGF0ZT09PSJwZW5kaW5nIilqLnBsYXliYWNrUmF0ZT0tai5wbGF5YmFja1JhdGU7ZWxzZXtjb25zdCAkPWoudGltaW5nLmRpcmVjdGlvbjtqLnRpbWluZy5kaXJlY3Rpb249JD09PSJyZXZlcnNlIj8ibm9ybWFsIjoicmV2ZXJzZSIsai5wbGF5KCl9cmV0dXJuIGouZmluaXNoZWR9LGF0dHIoaiwkKXtyZXR1cm4gdGhpcy5lbmQoKSx0eXBlb2Ygaj09InN0cmluZyImJihqPXtbal06JH0pLE9iamVjdC5lbnRyaWVzKGopLmZvckVhY2goKFtILEpdKT0+e3R5cGVvZiBKPT0iZnVuY3Rpb24iJiYoaltIXT1KKEQuYXR0cihIKSkpfSksdGhpc1tSXT1ELmFuaW1hdGUoW2pdLHtkdXJhdGlvbjpTKjFlMyxkZWxheTpDKjFlMyxmaWxsOiJmb3J3YXJkcyIsZWFzaW5nOkl9KSx0aGlzW1JdLmZpbmlzaGVkfX19dXBkYXRlQ29udG91cnMoKXt9fXkoQSwiQXR0ciIsbi5kZWZhdWx0KSxsLmRlZmF1bHQucmVnaXN0ZXJOb2RlKEEsIm5vZGUiKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pO3ZhciByPXQoMSksbj10KDEyKSxzPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx4PVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxnPVN5bWJvbC5mb3IoInNwcml0ZWpzX2NoYW5nZWRBdHRycyIpLHk9U3ltYm9sKCJzdWJqZWN0IiksbT1TeW1ib2woImF0dHIiKSxUPVN5bWJvbCgiZGVmYXVsdCIpLE89U3ltYm9sKCJhbGlhcyIpO2Z1bmN0aW9uIHYoTCxbUyxJXSl7bGV0IEQ9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtyZXR1cm5bLi4uTF0uZm9yRWFjaCgoW1IsQ10pPT57aWYoKFN8fEkpJiYoRD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRCxbUyxJXSkpLFI9PT0ibWF0cml4IilEPXIubWF0MmQubXVsdGlwbHkoRCxELEMpO2Vsc2UgaWYoUj09PSJvZmZzZXRUcmFuc2xhdGUiKURbNF0rPUNbMF0sRFs1XSs9Q1sxXTtlbHNlIGlmKFI9PT0ib2Zmc2V0Um90YXRlIilEPXIubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELEMpO2Vsc2UgaWYoUj09PSJza2V3Iil7Y29uc3RbaiwkXT1DO0Q9ci5tYXQyZC5tdWx0aXBseShELEQsci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oJCksTWF0aC50YW4oaiksMSwwLDApKX1lbHNlIHIubWF0MmRbUl0oRCxELEMpOyhTfHxJKSYmKEQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsWy1TLC1JXSkpfSksRH1jb25zdCBQPVN5bWJvbCgidHJhbnNmb3JtTWF0cml4IiksaT1TeW1ib2woInRyYW5zZm9ybXMiKSx1PVN5bWJvbCgiY2hhbmdlZEF0dHJzIiksYT1TeW1ib2woImxhc3RDaGFuZ2VkQXR0ciIpLGg9U3ltYm9sKCJvZmZzZXRGaWd1cmUiKTtmdW5jdGlvbiBiKEwsUyxJKXtjb25zdCBEPUxbbV1bU107aWYoTFtvXShTLEksITEpfHxMW2FdIT09Uyl7Y29uc3QgQz1MW2ldO0MuaGFzKFMpJiZDLmRlbGV0ZShTKSxJJiYoUz09PSJyb3RhdGUiJiYoST1NYXRoLlBJKkkvMTgwKSxTPT09InNjYWxlIiYmKEk9SS5tYXAoaj0+TWF0aC5hYnMoaik+MWUtNT9qOjEvaj4wPzFlLTU6LTFlLTUpKSxDLnNldChTLEkpKSxMW1BdPW51bGwsTFt5XS5vblByb3BlcnR5Q2hhbmdlKFMsSSxELEwpfX1mdW5jdGlvbiBFKEwpe2NvbnN0IFM9TFtoXSxJPUwub2Zmc2V0RGlzdGFuY2UqUy5nZXRUb3RhbExlbmd0aCgpLEQ9Uy5nZXRQb2ludEF0TGVuZ3RoKEkpO2lmKEQpe2NvbnN0IFI9TFtpXTtsZXQgQz1MLm9mZnNldFJvdGF0ZTtDPT09ImF1dG8iP0M9RC5hbmdsZTpDPT09InJldmVyc2UiP0M9TWF0aC5QSStELmFuZ2xlOkM9TWF0aC5QSSpDLzE4MCxSLnNldCgib2Zmc2V0Um90YXRlIixDKSxSLnNldCgib2Zmc2V0VHJhbnNsYXRlIixbRC54LEQueV0pLExbUF09bnVsbH19Y2xhc3MgQXtzdGF0aWMgc2V0RGVmYXVsdChTLC4uLkkpe3JldHVybiBTW2xdKC4uLkkpfXN0YXRpYyBkZWNsYXJlQWxpYXMoUywuLi5JKXtyZXR1cm4gU1tjXSguLi5JKX1zdGF0aWMgc2V0QXR0cmlidXRlKFMsLi4uSSl7cmV0dXJuIFNbb10oLi4uSSl9c3RhdGljIGdldEF0dHJpYnV0ZShTLC4uLkkpe3JldHVybiBTW2ZdKC4uLkkpfXN0YXRpYyBnZXRBdHRyaWJ1dGVzKFMpe3JldHVybiBTW3hdfXN0YXRpYyBnZXRDaGFuZ2VkQXR0cmlidXRlcyhTKXtyZXR1cm4gU1tnXX1jb25zdHJ1Y3RvcihTKXt0aGlzW3ldPVMsdGhpc1ttXT17fSx0aGlzW1BdPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCksdGhpc1tpXT1uZXcgTWFwLHRoaXNbVF09e30sdGhpc1tPXT1bXSxPYmplY3QuZGVmaW5lUHJvcGVydHkoUywidHJhbnNmb3JtTWF0cml4Iix7Z2V0OigpPT4odGhpc1tQXXx8KHRoaXNbUF09dih0aGlzW2ldLHRoaXMudHJhbnNmb3JtT3JpZ2luKSksWy4uLnRoaXNbUF1dKX0pLHRoaXNbbF0oe2lkOiIiLG5hbWU6IiIsY2xhc3NOYW1lOiIiLHg6MCx5OjAsdHJhbnNmb3JtT3JpZ2luOlswLDBdLHRyYW5zZm9ybToiIix0cmFuc2xhdGU6WzAsMF0scm90YXRlOjAsc2NhbGU6WzEsMV0sc2tldzpbMCwwXSxvcGFjaXR5OjEsekluZGV4OjAsb2Zmc2V0UGF0aDp2b2lkIDAsb2Zmc2V0RGlzdGFuY2U6MCxvZmZzZXRSb3RhdGU6ImF1dG8iLHBvaW50ZXJFdmVudHM6InZpc2libGUiLGZpbHRlcjoibm9uZSIsZGlzcGxheToiIn0pLHRoaXNbY10oImNsYXNzIiwicG9zIiksdGhpc1t1XT1uZXcgU2V0LHRoaXNbaF09bmV3IG4uRmlndXJlMkQoe3NjYWxlOjUsc2ltcGxpZnk6MH0pfWdldFtnXSgpe2NvbnN0IFM9e307cmV0dXJuWy4uLnRoaXNbdV1dLmZvckVhY2goST0+e1NbSV09dGhpc1ttXVtJXX0pLFN9Z2V0W3hdKCl7Y29uc3QgUz1PYmplY3QuYXNzaWduKHt9LHRoaXNbbV0pO2ZvcihsZXQgST0wO0k8dGhpc1tPXS5sZW5ndGg7SSsrKXtjb25zdCBEPXRoaXNbT11bSV07U1tEXT10aGlzW0RdfXJldHVybiBTfVtsXShTKXtPYmplY3QuYXNzaWduKHRoaXNbVF0sUyksT2JqZWN0LmFzc2lnbih0aGlzW21dLFMpfVtjXSguLi5TKXt0aGlzW09dLnB1c2goLi4uUyl9W29dKFMsSSxEPSEwKXtjb25zdCBSPXRoaXNbbV1bU10sQz10aGlzW3ldO3JldHVybiBJPT1udWxsJiYoST10aGlzW1RdW1NdKSxPYmplY3Qocy5jb21wYXJlVmFsdWUpKFIsSSk/ITE6KHRoaXNbbV1bU109SSx0aGlzW3VdLmhhcyhTKSYmdGhpc1t1XS5kZWxldGUoUyksdGhpc1t1XS5hZGQoUyksdGhpc1thXT1TLEQmJkMub25Qcm9wZXJ0eUNoYW5nZShTLEksUix0aGlzKSwhMCl9W2ZdKFMpe3JldHVybiB0aGlzW21dW1NdfXNldCBpZChTKXt0aGlzW29dKCJpZCIsUyl9Z2V0IGlkKCl7cmV0dXJuIHRoaXNbZl0oImlkIil9c2V0IG5hbWUoUyl7dGhpc1tvXSgibmFtZSIsUyl9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1tmXSgibmFtZSIpfXNldCBjbGFzc05hbWUoUyl7dGhpc1tvXSgiY2xhc3NOYW1lIixTKX1nZXQgY2xhc3NOYW1lKCl7cmV0dXJuIHRoaXNbZl0oImNsYXNzTmFtZSIpfXNldCBjbGFzcyhTKXt0aGlzLmNsYXNzTmFtZT1TfWdldCBjbGFzcygpe3JldHVybiB0aGlzLmNsYXNzTmFtZX1nZXQgeCgpe3JldHVybiB0aGlzW2ZdKCJ4Iil9c2V0IHgoUyl7dGhpc1tvXSgieCIsT2JqZWN0KHMudG9OdW1iZXIpKFMpKX1nZXQgeSgpe3JldHVybiB0aGlzW2ZdKCJ5Iil9c2V0IHkoUyl7dGhpc1tvXSgieSIsT2JqZWN0KHMudG9OdW1iZXIpKFMpKX1nZXQgcG9zKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldCBwb3MoUyl7Uz1PYmplY3Qocy50b0FycmF5KShTKSxBcnJheS5pc0FycmF5KFMpfHwoUz1bUyxTXSksdGhpcy54PVNbMF0sdGhpcy55PVNbMV19Z2V0IHRyYW5zZm9ybSgpe3JldHVybiB0aGlzW2ZdKCJ0cmFuc2Zvcm0iKX1zZXQgdHJhbnNmb3JtKFMpe2xldCBJPW51bGw7aWYoQXJyYXkuaXNBcnJheShTKSYmKEk9UyxTPWBtYXRyaXgoJHtTLm1hcChzLnRvTnVtYmVyKS5qb2luKCl9KWApLHR5cGVvZiBTPT0ic3RyaW5nIilTPVMucmVwbGFjZSgvXHMqLFxzKi9nLCIsIik7ZWxzZSBpZihTIT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpO2NvbnN0IEQ9dGhpc1ttXS50cmFuc2Zvcm07aWYodGhpc1tvXSgidHJhbnNmb3JtIixTLCExKSl7Y29uc3QgUj10aGlzW2ldO2lmKFIuaGFzKCJtYXRyaXgiKSYmUi5kZWxldGUoIm1hdHJpeCIpLEkpUi5zZXQoIm1hdHJpeCIsSSk7ZWxzZSBpZihTKXtjb25zdCBDPVMubWF0Y2goLyhtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoW14oKV0rXCkvZyk7aWYoQyl7bGV0IGo9ci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtmb3IobGV0ICQ9MDskPEMubGVuZ3RoOyQrKyl7Y29uc3QgSj1DWyRdLm1hdGNoKC9eKG1hdHJpeHx0cmFuc2xhdGV8cm90YXRlfHNjYWxlfHNrZXcpXCgoW14oKV0rKVwpLyk7aWYoSil7bGV0WyxxLEZdPUo7cT09PSJyb3RhdGUiP0Y9TWF0aC5QSSpwYXJzZUZsb2F0KEYpLzE4MDpGPUYudHJpbSgpLnNwbGl0KC9bXHMsXSsvKS5tYXAoRz0+T2JqZWN0KHMudG9OdW1iZXIpKEcpKSxxPT09Im1hdHJpeCI/aj1yLm1hdDJkLm11bHRpcGx5KGosaixGKTpxPT09InNrZXciP2o9ci5tYXQyZC5tdWx0aXBseShqLGosci5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRlsxXSksTWF0aC50YW4oRlswXSksMSwwLDApKTpyLm1hdDJkW3FdKGosaixGKSxSLnNldCgibWF0cml4IixqKX19fWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB0cmFuc2Zvcm0gdmFsdWUuIil9dGhpc1tQXT1udWxsLHRoaXNbeV0ub25Qcm9wZXJ0eUNoYW5nZSgidHJhbnNmb3JtIixTLEQsdGhpcyl9fWdldCB0cmFuc2Zvcm1PcmlnaW4oKXtyZXR1cm4gdGhpc1tmXSgidHJhbnNmb3JtT3JpZ2luIil9c2V0IHRyYW5zZm9ybU9yaWdpbihTKXtTPU9iamVjdChzLnRvQXJyYXkpKFMsITApLFMhPW51bGwmJiFBcnJheS5pc0FycmF5KFMpJiYoUz1bUyxTXSksdGhpc1tvXSgidHJhbnNmb3JtT3JpZ2luIixTKSYmKHRoaXNbUF09bnVsbCl9Z2V0IHJvdGF0ZSgpe3JldHVybiB0aGlzW2ZdKCJyb3RhdGUiKX1zZXQgcm90YXRlKFMpe2IodGhpcywicm90YXRlIixTKX1nZXQgdHJhbnNsYXRlKCl7cmV0dXJuIHRoaXNbZl0oInRyYW5zbGF0ZSIpfXNldCB0cmFuc2xhdGUoUyl7Uz1PYmplY3Qocy50b0FycmF5KShTLCEwKSxTIT1udWxsJiYhQXJyYXkuaXNBcnJheShTKSYmKFM9W1MsU10pLGIodGhpcywidHJhbnNsYXRlIixTKX1nZXQgc2NhbGUoKXtyZXR1cm4gdGhpc1tmXSgic2NhbGUiKX1zZXQgc2NhbGUoUyl7Uz1PYmplY3Qocy50b0FycmF5KShTLCEwKSxTIT1udWxsJiYhQXJyYXkuaXNBcnJheShTKSYmKFM9W1MsU10pLGIodGhpcywic2NhbGUiLFMpfWdldCBza2V3KCl7cmV0dXJuIHRoaXNbZl0oInNrZXciKX1zZXQgc2tldyhTKXtTPU9iamVjdChzLnRvQXJyYXkpKFMsITApLFMhPW51bGwmJiFBcnJheS5pc0FycmF5KFMpJiYoUz1bUyxTXSksYih0aGlzLCJza2V3IixTKX1nZXQgb3BhY2l0eSgpe3JldHVybiB0aGlzW2ZdKCJvcGFjaXR5Iil9c2V0IG9wYWNpdHkoUyl7UyE9bnVsbCYmKFM9TnVtYmVyKFMpKSx0aGlzW29dKCJvcGFjaXR5IixTKX1nZXQgekluZGV4KCl7cmV0dXJuIHRoaXNbZl0oInpJbmRleCIpfXNldCB6SW5kZXgoUyl7UyE9bnVsbCYmKFM9TnVtYmVyKFMpKSx0aGlzW29dKCJ6SW5kZXgiLFMpfWdldCBvZmZzZXRQYXRoKCl7cmV0dXJuIHRoaXNbZl0oIm9mZnNldFBhdGgiKX1zZXQgb2Zmc2V0UGF0aChTKXt0aGlzW29dKCJvZmZzZXRQYXRoIixTKSYmKHRoaXNbaF0uYmVnaW5QYXRoKCksUyE9bnVsbCYmdGhpc1toXS5hZGRQYXRoKFMpLEUodGhpcykpfWdldCBvZmZzZXREaXN0YW5jZSgpe3JldHVybiB0aGlzW2ZdKCJvZmZzZXREaXN0YW5jZSIpfXNldCBvZmZzZXREaXN0YW5jZShTKXt0aGlzW29dKCJvZmZzZXREaXN0YW5jZSIsT2JqZWN0KHMudG9OdW1iZXIpKFMpKSYmRSh0aGlzKX1nZXQgb2Zmc2V0Um90YXRlKCl7cmV0dXJuIHRoaXNbZl0oIm9mZnNldFJvdGF0ZSIpfXNldCBvZmZzZXRSb3RhdGUoUyl7dGhpc1tvXSgib2Zmc2V0Um90YXRlIixTKSxFKHRoaXMpfWdldCBwb2ludGVyRXZlbnRzKCl7cmV0dXJuIHRoaXNbZl0oInBvaW50ZXJFdmVudHMiKX1zZXQgcG9pbnRlckV2ZW50cyhTKXtpZihTIT1udWxsJiZTIT09Im5vbmUiJiZTIT09InZpc2libGUiJiZTIT09InZpc2libGVGaWxsIiYmUyE9PSJ2aXNpYmxlU3Ryb2tlIiYmUyE9PSJhbGwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcG9pbnRlckV2ZW50cyB0eXBlLiIpO3RoaXNbb10oInBvaW50ZXJFdmVudHMiLFMpfWdldCBmaWx0ZXIoKXtyZXR1cm4gdGhpc1tmXSgiZmlsdGVyIil9c2V0IGZpbHRlcihTKXt0aGlzW29dKCJmaWx0ZXIiLFMpfWdldCBkaXNwbGF5KCl7cmV0dXJuIHRoaXNbZl0oImRpc3BsYXkiKX1zZXQgZGlzcGxheShTKXt0aGlzW29dKCJkaXNwbGF5IixTKX1zZXQgb2Zmc2V0KFMpe319fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJzaXplVG9QaXhlbCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJ0b051bWJlciIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJ0b0FycmF5IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNvbXBhcmVWYWx1ZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG8sZil7Y29uc3QgeD1vLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLyk7eD9vPXtzaXplOnBhcnNlRmxvYXQoeFsxXSksdW5pdDp4WzJdfTpvPXtzaXplOnBhcnNlRmxvYXQobyksdW5pdDoicHgifTtsZXR7c2l6ZTpnLHVuaXQ6eX09bztpZih5PT09InB0IilnLz0uNzU7ZWxzZSBpZih5PT09InBjIilnKj0xNjtlbHNlIGlmKHk9PT0iaW4iKWcqPTk2O2Vsc2UgaWYoeT09PSJjbSIpZyo9OTYvMi41NDtlbHNlIGlmKHk9PT0ibW0iKWcqPTk2LzI1LjQ7ZWxzZSBpZih5PT09ImVtInx8eT09PSJyZW0ifHx5PT09ImV4Iil7aWYoIWYmJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBtPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTttP2Y9cihtLDE2KTpmPTE2fWcqPWYseT09PSJleCImJihnLz0yKX1lbHNlIGlmKHk9PT0icSIpZyo9OTYvMjUuNC80O2Vsc2UgaWYoeT09PSJ2dyJ8fHk9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBtPXk9PT0idnciP3dpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2cqPW0vMTAwfX1lbHNlIGlmKCh5PT09InZtYXgifHx5PT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgbT13aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFQ9d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3k9PT0idm1heCI/Zyo9TWF0aC5tYXgobSxUKS8xMDA6Zyo9TWF0aC5taW4obSxUKS8xMDB9cmV0dXJuIGd9ZnVuY3Rpb24gbihvKXtyZXR1cm4gbz09bnVsbD9vOlN0cmluZyhvKX1mdW5jdGlvbiBzKG8pe2lmKG89PW51bGwpcmV0dXJuIG87aWYodHlwZW9mIG89PSJzdHJpbmciJiYobz1yKG8pKSwhTnVtYmVyLmlzRmluaXRlKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmFsdWUiKTtyZXR1cm4gb31mdW5jdGlvbiBsKG8sZj0hMSl7cmV0dXJuIG89PT0iIj9udWxsOih0eXBlb2Ygbz09InN0cmluZyImJihvPW8uc3BsaXQoL1tccyxdKy9nKSksQXJyYXkuaXNBcnJheShvKSYmKGYmJihvPW8ubWFwKHMpKSxvLmxlbmd0aD09PTEpP29bMF06byl9ZnVuY3Rpb24gYyhvLGYpe2lmKEFycmF5LmlzQXJyYXkobykmJkFycmF5LmlzQXJyYXkoZikpe2lmKG8ubGVuZ3RoIT09Zi5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB4PTA7eDxvLmxlbmd0aDt4KyspaWYob1t4XSE9PWZbeF0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIG89PW51bGwmJmY9PW51bGx8fG89PT1mfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pO3ZhciByPXQoNzQpLG49dCgzMikscz10Lm4obiksbD10KDY4KSxjPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKCl7cmV0dXJuIG89T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24obSl7Zm9yKHZhciBUPTE7VDxhcmd1bWVudHMubGVuZ3RoO1QrKyl7dmFyIE89YXJndW1lbnRzW1RdO2Zvcih2YXIgdiBpbiBPKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChPLHYpJiYobVt2XT1PW3ZdKX1yZXR1cm4gbX0sby5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gZihtKXtpZih0eXBlb2YgbT09InN0cmluZyIpe2lmKG09bS50cmltKCksL15bMC05Ll0rJSQvLnRlc3QobSkpcmV0dXJuIHBhcnNlRmxvYXQobSkvMTAwO2lmKC9eKFtcZC5dKykocHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWluKSQvLnRlc3QobSkpcmV0dXJuIE9iamVjdChjLnNpemVUb1BpeGVsKShtKX1yZXR1cm4gbX1mdW5jdGlvbiB4KG0sVCxPLHYsUCl7cmV0dXJuIHR5cGVvZiBtPT0ic3RyaW5nIiYmKG09cygpKG0pKSx0eXBlb2YgVD09InN0cmluZyImJihUPXMoKShUKSksci5FZmZlY3RzLmRlZmF1bHQobSxULE8sdixQKX1mdW5jdGlvbiBnKG0sVCxPLHYsUCl7cmV0dXJuIHIuRWZmZWN0cy5kZWZhdWx0KG0sVCxPLHYsUCl9ci5FZmZlY3RzLmRlZmF1bHQ9ZnVuY3Rpb24obSxULE8sdixQKXtyZXR1cm4gQXJyYXkuaXNBcnJheShtKSYmQXJyYXkuaXNBcnJheShUKT9tLm1hcCgoaSx1KT0+aSsoTy12KS8oUC12KSooVFt1XS1pKSk6dHlwZW9mIG09PSJudW1iZXIiJiZ0eXBlb2YgVD09Im51bWJlciI/bSsoTy12KS8oUC12KSooVC1tKTpPLXY+UC1PP1Q6bX0sci5FZmZlY3RzLmZpbGxDb2xvcj14LHIuRWZmZWN0cy5zdHJva2VDb2xvcj14LHIuRWZmZWN0cy5iZ2NvbG9yPXgsci5FZmZlY3RzLmJvcmRlckNvbG9yPXgsci5FZmZlY3RzLnRleHQ9ZztjbGFzcyB5IGV4dGVuZHMgci5BbmltYXRvcntjb25zdHJ1Y3RvcihULE8sdil7Y29uc3QgUD1ULmF0dHIoKTtPYmplY3QuZW50cmllcyhQKS5mb3JFYWNoKChbaSx1XSk9PntQW2ldPXIuRWZmZWN0c1tpXT91OmYodSl9KSxPPU8ubWFwKGk9PntsZXQgdT1vKHt9LGkpO2NvbnN0IGE9e307cmV0dXJuIE9iamVjdC5lbnRyaWVzKHUpLmZvckVhY2goKFtoLGJdKT0+e2FbaF09ci5FZmZlY3RzW2hdP2I6ZihiKX0pLGF9KSxzdXBlcihQLE8sdiksdGhpcy50YXJnZXQ9VCx0aGlzLnNldHRlcj1mdW5jdGlvbihpLHUpe3UuYXR0cihpKX19Z2V0IHBsYXlTdGF0ZSgpe3JldHVybiB0aGlzLnRhcmdldC5wYXJlbnQ/c3VwZXIucGxheVN0YXRlOiJpZGxlIn1nZXQgZmluaXNoZWQoKXtyZXR1cm4gc3VwZXIuZmluaXNoZWQudGhlbigoKT0+e2NvbnN0IFQ9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoTz0+e2Z1bmN0aW9uIHYoKXtULnNldHRlcihULmZyYW1lLFQudGFyZ2V0KTtjb25zdCBQPVQucGxheVN0YXRlO1A9PT0iZmluaXNoZWQifHxQPT09ImlkbGUiPyhPYmplY3QobC5jYW5jZWxBbmltYXRpb25GcmFtZSkoVC5yZXF1ZXN0SWQpLE8oKSk6T2JqZWN0KGwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSh2KX12KCl9KX0pfWZpbmlzaCgpe3N1cGVyLmZpbmlzaCgpLE9iamVjdChsLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzLnJlcXVlc3RJZCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCl9cGxheSgpe2lmKCF0aGlzLnRhcmdldC5wYXJlbnR8fHRoaXMucGxheVN0YXRlPT09InJ1bm5pbmciKXJldHVybjtzdXBlci5wbGF5KCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCk7Y29uc3QgVD10aGlzO3RoaXMucmVhZHkudGhlbigoKT0+e1Quc2V0dGVyKFQuZnJhbWUsVC50YXJnZXQpLFQucmVxdWVzdElkPU9iamVjdChsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoZnVuY3Rpb24gTygpe2NvbnN0IHY9VC50YXJnZXQ7aWYodHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMmJnYubGF5ZXImJnYubGF5ZXIuY2FudmFzJiYhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHYubGF5ZXIuY2FudmFzKSl7VC5jYW5jZWwoKTtyZXR1cm59Y29uc3QgUD1ULnBsYXlTdGF0ZTtULnNldHRlcihULmZyYW1lLFQudGFyZ2V0KSxQIT09ImlkbGUiJiYoUD09PSJydW5uaW5nIj9ULnJlcXVlc3RJZD1PYmplY3QobC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKE8pOihQPT09InBhdXNlZCJ8fFA9PT0icGVuZGluZyImJlQudGltZWxpbmUuY3VycmVudFRpbWU8MCkmJlQucmVhZHkudGhlbigoKT0+e1Quc2V0dGVyKFQuZnJhbWUsVC50YXJnZXQpLFQucmVxdWVzdElkPU9iamVjdChsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoTyl9KSl9KX0pfWNhbmNlbChUPSExKXtPYmplY3QobC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLFQ/KHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpLHN1cGVyLmNhbmNlbCgpKTooc3VwZXIuY2FuY2VsKCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCkpfX19LGZ1bmN0aW9uKGQsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5UaW1lbGluZT1lLkVmZmVjdHM9ZS5FYXNpbmdzPWUuQW5pbWF0b3I9dm9pZCAwO3ZhciByPXQoNzUpLG49eChyKSxzPXQoMTg3KSxsPXgocyksYz10KDE4OCksbz10KDE5MCksZj14KG8pO2Z1bmN0aW9uIHgoZyl7cmV0dXJuIGcmJmcuX19lc01vZHVsZT9nOntkZWZhdWx0Omd9fWUuQW5pbWF0b3I9Zi5kZWZhdWx0LGUuRWFzaW5ncz1jLkVhc2luZ3MsZS5FZmZlY3RzPWwuZGVmYXVsdCxlLlRpbWVsaW5lPW4uZGVmYXVsdH0sZnVuY3Rpb24oZCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxuPWkocikscz10KDEzMyksbD1pKHMpLGM9dCgxNDEpLG89aShjKSxmPXQoMTY0KSx4PWkoZiksZz10KDE3MCkseT1pKGcpLG09dCgxNzEpLFQ9aShtKSxPPXQoMTc1KSx2PWkoTyksUD10KDE4Nik7ZnVuY3Rpb24gaShEKXtyZXR1cm4gRCYmRC5fX2VzTW9kdWxlP0Q6e2RlZmF1bHQ6RH19dmFyIHU9KDAsUC5jcmVhdGVOb3dUaW1lKSgpLGE9e29yaWdpblRpbWU6MCxwbGF5YmFja1JhdGU6MX0saD0oMCx2LmRlZmF1bHQpKCJ0aW1lTWFyayIpLGI9KDAsdi5kZWZhdWx0KSgicGxheWJhY2tSYXRlIiksRT0oMCx2LmRlZmF1bHQpKCJ0aW1lcnMiKSxBPSgwLHYuZGVmYXVsdCkoIm9yaWdpblRpbWUiKSxMPSgwLHYuZGVmYXVsdCkoInNldFRpbWVyIiksUz0oMCx2LmRlZmF1bHQpKCJwYXJlbnQiKSxJPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gRChSLEMpeygwLHkuZGVmYXVsdCkodGhpcyxEKSxSIGluc3RhbmNlb2YgRCYmKEM9UixSPXt9KSxSPSgwLHguZGVmYXVsdCkoe30sYSxSKSxDJiYodGhpc1tTXT1DKTt2YXIgaj1SLm5vd3RpbWV8fHU7aWYoQylPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBDLmN1cnJlbnRUaW1lfX0pO2Vsc2V7dmFyICQ9aigpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJnbG9iYWxUaW1lIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGooKS0kfX0pfXRoaXNbaF09W3tnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6LVIub3JpZ2luVGltZSxlbnRyb3B5Oi1SLm9yaWdpblRpbWUscGxheWJhY2tSYXRlOlIucGxheWJhY2tSYXRlLGdsb2JhbEVudHJvcHk6MH1dLHRoaXNbU10mJih0aGlzW2hdWzBdLmdsb2JhbEVudHJvcHk9dGhpc1tTXS5lbnRyb3B5KSx0aGlzW0FdPVIub3JpZ2luVGltZSx0aGlzW2JdPVIucGxheWJhY2tSYXRlLHRoaXNbRV09bmV3IG8uZGVmYXVsdH1yZXR1cm4oMCxULmRlZmF1bHQpKEQsW3trZXk6Im1hcmtUaW1lIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBDPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxqPUMudGltZSwkPWo9PT12b2lkIDA/dGhpcy5jdXJyZW50VGltZTpqLEg9Qy5lbnRyb3B5LEo9SD09PXZvaWQgMD90aGlzLmVudHJvcHk6SCxxPUMucGxheWJhY2tSYXRlLEY9cT09PXZvaWQgMD90aGlzLnBsYXliYWNrUmF0ZTpxLEc9e2dsb2JhbFRpbWU6dGhpcy5nbG9iYWxUaW1lLGxvY2FsVGltZTokLGVudHJvcHk6SixwbGF5YmFja1JhdGU6RixnbG9iYWxFbnRyb3B5OnRoaXMuZ2xvYmFsRW50cm9weX07dGhpc1toXS5wdXNoKEcpfX0se2tleToiZm9yayIsdmFsdWU6ZnVuY3Rpb24oQyl7cmV0dXJuIG5ldyBEKEMsdGhpcyl9fSx7a2V5OiJzZWVrR2xvYmFsVGltZSIsdmFsdWU6ZnVuY3Rpb24oQyl7dmFyIGo9dGhpcy5zZWVrVGltZU1hcmsoQyksJD10aGlzW2hdW2pdLEg9JC5lbnRyb3B5LEo9JC5wbGF5YmFja1JhdGUscT0kLmdsb2JhbFRpbWU7cmV0dXJuIHErKEMtSCkvTWF0aC5hYnMoSil9fSx7a2V5OiJzZWVrTG9jYWxUaW1lIix2YWx1ZTpmdW5jdGlvbihDKXt2YXIgaj10aGlzLnNlZWtUaW1lTWFyayhDKSwkPXRoaXNbaF1bal0sSD0kLmxvY2FsVGltZSxKPSQuZW50cm9weSxxPSQucGxheWJhY2tSYXRlO3JldHVybiBxPjA/SCsoQy1KKTpILShDLUopfX0se2tleToic2Vla1RpbWVNYXJrIix2YWx1ZTpmdW5jdGlvbihDKXt2YXIgaj10aGlzW2hdLCQ9MCxIPWoubGVuZ3RoLTE7aWYoQzw9alskXS5lbnRyb3B5KXJldHVybiAkO2lmKEM+PWpbSF0uZW50cm9weSlyZXR1cm4gSDtmb3IodmFyIEo9TWF0aC5mbG9vcigoJCtIKS8yKTtKPiQmJko8SDspe2lmKEM9PT1qW0pdLmVudHJvcHkpcmV0dXJuIEo7QzxqW0pdLmVudHJvcHk/SD1KOkM+altKXS5lbnRyb3B5JiYoJD1KKSxKPU1hdGguZmxvb3IoKCQrSCkvMil9cmV0dXJuICR9fSx7a2V5OiJ1cGRhdGVUaW1lcnMiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEM9dGhpcyxqPVtdLmNvbmNhdCgoMCxsLmRlZmF1bHQpKHRoaXNbRV0pKTtqLmZvckVhY2goZnVuY3Rpb24oJCl7dmFyIEg9KDAsbi5kZWZhdWx0KSgkLDIpLEo9SFswXSxxPUhbMV07Q1tMXShxLmhhbmRsZXIscS50aW1lLEopfSl9fSx7a2V5OiJjbGVhclRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKFIpe2Z1bmN0aW9uIEMoail7cmV0dXJuIFIuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBDLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIFIudG9TdHJpbmcoKX0sQ30oZnVuY3Rpb24oUil7dmFyIEM9dGhpc1tFXS5nZXQoUik7QyYmQy50aW1lcklEIT1udWxsJiYodGhpc1tTXT90aGlzW1NdLmNsZWFyVGltZW91dChDLnRpbWVySUQpOmNsZWFyVGltZW91dChDLnRpbWVySUQpKSx0aGlzW0VdLmRlbGV0ZShSKX0pfSx7a2V5OiJjbGVhckludGVydmFsIix2YWx1ZTpmdW5jdGlvbihDKXtyZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoQyl9fSx7a2V5OiJjbGVhciIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgQz10aGlzLGo9dGhpc1tFXTtbXS5jb25jYXQoKDAsbC5kZWZhdWx0KShqLmtleXMoKSkpLmZvckVhY2goZnVuY3Rpb24oJCl7Qy5jbGVhclRpbWVvdXQoJCl9KX19LHtrZXk6InNldFRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKEMpe3ZhciBqPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7ZGVsYXk6MH07cmV0dXJuIHRoaXNbTF0oQyxqKX19LHtrZXk6InNldEludGVydmFsIix2YWx1ZTpmdW5jdGlvbihDKXt2YXIgaj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9LCQ9dGhpcyxIPXRoaXNbTF0oZnVuY3Rpb24gSigpeyRbTF0oSixqLEgpLEMoKX0saik7cmV0dXJuIEh9fSx7a2V5OkwsdmFsdWU6ZnVuY3Rpb24oQyxqKXt2YXIgJD10aGlzLEg9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOigwLHYuZGVmYXVsdCkoInRpbWVySUQiKTtqPSgwLFAuZm9ybWF0RGVsYXkpKGopO3ZhciBKPXRoaXNbRV0uZ2V0KEgpLHE9dm9pZCAwLEY9bnVsbCxHPXZvaWQgMCxaPXZvaWQgMDtKPyh0aGlzLmNsZWFyVGltZW91dChIKSxqLmlzRW50cm9weT9xPShqLmRlbGF5LSh0aGlzLmVudHJvcHktSi5zdGFydEVudHJvcHkpKS9NYXRoLmFicyh0aGlzLnBsYXliYWNrUmF0ZSk6cT0oai5kZWxheS0odGhpcy5jdXJyZW50VGltZS1KLnN0YXJ0VGltZSkpL3RoaXMucGxheWJhY2tSYXRlLEc9Si5zdGFydFRpbWUsWj1KLnN0YXJ0RW50cm9weSk6KHE9ai5kZWxheS8oai5pc0VudHJvcHk/TWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnRoaXMucGxheWJhY2tSYXRlKSxHPXRoaXMuY3VycmVudFRpbWUsWj10aGlzLmVudHJvcHkpO3ZhciB0dD10aGlzW1NdLGV0PXR0P3R0LnNldFRpbWVvdXQuYmluZCh0dCk6c2V0VGltZW91dCxpdD1qLmhlYWRpbmc7cmV0dXJuIXR0JiZpdD09PSExJiZxPDAmJihxPTEvMCksKGlzRmluaXRlKHEpfHx0dCkmJihxPU1hdGguY2VpbChxKSxldCE9PXNldFRpbWVvdXQmJihxPXtkZWxheTpxLGhlYWRpbmc6aXR9KSxGPWV0KGZ1bmN0aW9uKCl7JFtFXS5kZWxldGUoSCksQygpfSxxKSksdGhpc1tFXS5zZXQoSCx7dGltZXJJRDpGLGhhbmRsZXI6Qyx0aW1lOmosc3RhcnRUaW1lOkcsc3RhcnRFbnRyb3B5Olp9KSxIfX0se2tleToicGFyZW50IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tTXX19LHtrZXk6Imxhc3RUaW1lTWFyayIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbaF1bdGhpc1toXS5sZW5ndGgtMV19fSx7a2V5OiJjdXJyZW50VGltZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEM9dGhpcy5sYXN0VGltZU1hcmssaj1DLmxvY2FsVGltZSwkPUMuZ2xvYmFsVGltZTtyZXR1cm4gaisodGhpcy5nbG9iYWxUaW1lLSQpKnRoaXMucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oQyl7dmFyIGo9dGhpcywkPXRoaXMuY3VycmVudFRpbWUsSD1DLEo9dGhpc1tFXTt0aGlzLm1hcmtUaW1lKHt0aW1lOkN9KSxbXS5jb25jYXQoKDAsbC5kZWZhdWx0KShKKSkuZm9yRWFjaChmdW5jdGlvbihxKXt2YXIgRj0oMCxuLmRlZmF1bHQpKHEsMiksRz1GWzBdLFo9RlsxXTtpZihKLmhhcyhHKSl7dmFyIHR0PVoudGltZSxldD10dC5pc0VudHJvcHksaXQ9dHQuZGVsYXksaz10dC5oZWFkaW5nLGh0PVouaGFuZGxlcixmdD1aLnN0YXJ0VGltZTtpZihldClpdD09PTAmJihodCgpLGouY2xlYXJUaW1lb3V0KEcpKTtlbHNle3ZhciBCPWZ0K2l0OyhpdD09PTB8fGshPT0hMSYmKEgtJCkqaXQ8PTB8fCQ8PUImJkI8PUh8fCQ+PUImJkI+PUgpJiYoaHQoKSxqLmNsZWFyVGltZW91dChHKSl9fX0pLHRoaXMudXBkYXRlVGltZXJzKCl9fSx7a2V5OiJlbnRyb3B5IixnZXQ6ZnVuY3Rpb24oKXt2YXIgQz10aGlzLmxhc3RUaW1lTWFyayxqPUMuZW50cm9weSwkPUMuZ2xvYmFsRW50cm9weTtyZXR1cm4gaitNYXRoLmFicygodGhpcy5nbG9iYWxFbnRyb3B5LSQpKnRoaXMucGxheWJhY2tSYXRlKX0sc2V0OmZ1bmN0aW9uKEMpe2lmKHRoaXMuZW50cm9weT5DKXt2YXIgaj10aGlzLnNlZWtUaW1lTWFyayhDKTt0aGlzW2hdLmxlbmd0aD1qKzF9dGhpcy5tYXJrVGltZSh7ZW50cm9weTpDfSksdGhpcy51cGRhdGVUaW1lcnMoKX19LHtrZXk6Imdsb2JhbEVudHJvcHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1NdP3RoaXNbU10uZW50cm9weTp0aGlzLmdsb2JhbFRpbWV9fSx7a2V5OiJwbGF5YmFja1JhdGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2JdfSxzZXQ6ZnVuY3Rpb24oQyl7QyE9PXRoaXMucGxheWJhY2tSYXRlJiYodGhpcy5tYXJrVGltZSh7cGxheWJhY2tSYXRlOkN9KSx0aGlzW2JdPUMsdGhpcy51cGRhdGVUaW1lcnMoKSl9fSx7a2V5OiJwYXVzZWQiLGdldDpmdW5jdGlvbigpe2lmKHRoaXMucGxheWJhY2tSYXRlPT09MClyZXR1cm4hMDtmb3IodmFyIEM9dGhpcy5wYXJlbnQ7Qzspe2lmKEMucGxheWJhY2tSYXRlPT09MClyZXR1cm4hMDtDPUMucGFyZW50fXJldHVybiExfX1dKSxEfSgpO2UuZGVmYXVsdD1JfSxmdW5jdGlvbihkLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPXQoNzcpLG49YyhyKSxzPXQoMTI5KSxsPWMocyk7ZnVuY3Rpb24gYyhvKXtyZXR1cm4gbyYmby5fX2VzTW9kdWxlP286e2RlZmF1bHQ6b319ZS5kZWZhdWx0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbyhmLHgpe3ZhciBnPVtdLHk9ITAsbT0hMSxUPXZvaWQgMDt0cnl7Zm9yKHZhciBPPSgwLGwuZGVmYXVsdCkoZiksdjshKHk9KHY9Ty5uZXh0KCkpLmRvbmUpJiYoZy5wdXNoKHYudmFsdWUpLCEoeCYmZy5sZW5ndGg9PT14KSk7eT0hMCk7fWNhdGNoKFApe209ITAsVD1QfWZpbmFsbHl7dHJ5eyF5JiZPLnJldHVybiYmTy5yZXR1cm4oKX1maW5hbGx5e2lmKG0pdGhyb3cgVH19cmV0dXJuIGd9cmV0dXJuIGZ1bmN0aW9uKGYseCl7aWYoQXJyYXkuaXNBcnJheShmKSlyZXR1cm4gZjtpZigoMCxuLmRlZmF1bHQpKE9iamVjdChmKSkpcmV0dXJuIG8oZix4KTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpfSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXtkZWZhdWx0OnQoNzgpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihkLGUsdCl7dCg3OSksdCgxMjUpLGQuZXhwb3J0cz10KDEyNyl9LGZ1bmN0aW9uKGQsZSx0KXt0KDgwKTtmb3IodmFyIHI9dCg5MSksbj10KDk1KSxzPXQoODMpLGw9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLGM9IkNTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCxNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LFNWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LFRleHRUcmFja0xpc3QsVG91Y2hMaXN0Ii5zcGxpdCgiLCIpLG89MDtvPGMubGVuZ3RoO28rKyl7dmFyIGY9Y1tvXSx4PXJbZl0sZz14JiZ4LnByb3RvdHlwZTtnJiYhZ1tsXSYmbihnLGwsZiksc1tmXT1zLkFycmF5fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoODEpLG49dCg4Mikscz10KDgzKSxsPXQoODQpO2QuZXhwb3J0cz10KDg4KShBcnJheSwiQXJyYXkiLGZ1bmN0aW9uKGMsbyl7dGhpcy5fdD1sKGMpLHRoaXMuX2k9MCx0aGlzLl9rPW99LGZ1bmN0aW9uKCl7dmFyIGM9dGhpcy5fdCxvPXRoaXMuX2ssZj10aGlzLl9pKys7cmV0dXJuIWN8fGY+PWMubGVuZ3RoPyh0aGlzLl90PXZvaWQgMCxuKDEpKTpvPT0ia2V5cyI/bigwLGYpOm89PSJ2YWx1ZXMiP24oMCxjW2ZdKTpuKDAsW2YsY1tmXV0pfSwidmFsdWVzIikscy5Bcmd1bWVudHM9cy5BcnJheSxyKCJrZXlzIikscigidmFsdWVzIikscigiZW50cmllcyIpfSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1mdW5jdGlvbigpe319LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQscil7cmV0dXJue3ZhbHVlOnIsZG9uZTohIXR9fX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9e319LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDg1KSxuPXQoODcpO2QuZXhwb3J0cz1mdW5jdGlvbihzKXtyZXR1cm4gcihuKHMpKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDg2KTtkLmV4cG9ydHM9T2JqZWN0KCJ6IikucHJvcGVydHlJc0VudW1lcmFibGUoMCk/T2JqZWN0OmZ1bmN0aW9uKG4pe3JldHVybiByKG4pPT0iU3RyaW5nIj9uLnNwbGl0KCIiKTpPYmplY3Qobil9fSxmdW5jdGlvbihkLGUpe3ZhciB0PXt9LnRvU3RyaW5nO2QuZXhwb3J0cz1mdW5jdGlvbihyKXtyZXR1cm4gdC5jYWxsKHIpLnNsaWNlKDgsLTEpfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodD09bnVsbCl0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNhbGwgbWV0aG9kIG9uICAiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoODkpLG49dCg5MCkscz10KDEwNiksbD10KDk1KSxjPXQoODMpLG89dCgxMDcpLGY9dCgxMjEpLHg9dCgxMjMpLGc9dCgxMjIpKCJpdGVyYXRvciIpLHk9IShbXS5rZXlzJiYibmV4dCJpbltdLmtleXMoKSksbT0iQEBpdGVyYXRvciIsVD0ia2V5cyIsTz0idmFsdWVzIix2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2QuZXhwb3J0cz1mdW5jdGlvbihQLGksdSxhLGgsYixFKXtvKHUsaSxhKTt2YXIgQT1mdW5jdGlvbihGKXtpZigheSYmRiBpbiBEKXJldHVybiBEW0ZdO3N3aXRjaChGKXtjYXNlIFQ6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB1KHRoaXMsRil9O2Nhc2UgTzpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHUodGhpcyxGKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB1KHRoaXMsRil9fSxMPWkrIiBJdGVyYXRvciIsUz1oPT1PLEk9ITEsRD1QLnByb3RvdHlwZSxSPURbZ118fERbbV18fGgmJkRbaF0sQz1SfHxBKGgpLGo9aD9TP0EoImVudHJpZXMiKTpDOnZvaWQgMCwkPWk9PSJBcnJheSImJkQuZW50cmllc3x8UixILEoscTtpZigkJiYocT14KCQuY2FsbChuZXcgUCkpLHEhPT1PYmplY3QucHJvdG90eXBlJiZxLm5leHQmJihmKHEsTCwhMCksIXImJnR5cGVvZiBxW2ddIT0iZnVuY3Rpb24iJiZsKHEsZyx2KSkpLFMmJlImJlIubmFtZSE9PU8mJihJPSEwLEM9ZnVuY3Rpb24oKXtyZXR1cm4gUi5jYWxsKHRoaXMpfSksKCFyfHxFKSYmKHl8fEl8fCFEW2ddKSYmbChELGcsQyksY1tpXT1DLGNbTF09dixoKWlmKEg9e3ZhbHVlczpTP0M6QShPKSxrZXlzOmI/QzpBKFQpLGVudHJpZXM6an0sRSlmb3IoSiBpbiBIKUogaW4gRHx8cyhELEosSFtKXSk7ZWxzZSBuKG4uUCtuLkYqKHl8fEkpLGksSCk7cmV0dXJuIEh9fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz0hMH0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTEpLG49dCg5Mikscz10KDkzKSxsPXQoOTUpLGM9dCgxMDUpLG89InByb3RvdHlwZSIsZj1mdW5jdGlvbih4LGcseSl7dmFyIG09eCZmLkYsVD14JmYuRyxPPXgmZi5TLHY9eCZmLlAsUD14JmYuQixpPXgmZi5XLHU9VD9uOm5bZ118fChuW2ddPXt9KSxhPXVbb10saD1UP3I6Tz9yW2ddOihyW2ddfHx7fSlbb10sYixFLEE7VCYmKHk9Zyk7Zm9yKGIgaW4geSlFPSFtJiZoJiZoW2JdIT09dm9pZCAwLCEoRSYmYyh1LGIpKSYmKEE9RT9oW2JdOnlbYl0sdVtiXT1UJiZ0eXBlb2YgaFtiXSE9ImZ1bmN0aW9uIj95W2JdOlAmJkU/cyhBLHIpOmkmJmhbYl09PUE/ZnVuY3Rpb24oTCl7dmFyIFM9ZnVuY3Rpb24oSSxELFIpe2lmKHRoaXMgaW5zdGFuY2VvZiBMKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgTDtjYXNlIDE6cmV0dXJuIG5ldyBMKEkpO2Nhc2UgMjpyZXR1cm4gbmV3IEwoSSxEKX1yZXR1cm4gbmV3IEwoSSxELFIpfXJldHVybiBMLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIFNbb109TFtvXSxTfShBKTp2JiZ0eXBlb2YgQT09ImZ1bmN0aW9uIj9zKEZ1bmN0aW9uLmNhbGwsQSk6QSx2JiYoKHUudmlydHVhbHx8KHUudmlydHVhbD17fSkpW2JdPUEseCZmLlImJmEmJiFhW2JdJiZsKGEsYixBKSkpfTtmLkY9MSxmLkc9MixmLlM9NCxmLlA9OCxmLkI9MTYsZi5XPTMyLGYuVT02NCxmLlI9MTI4LGQuZXhwb3J0cz1mfSxmdW5jdGlvbihkLGUpe3ZhciB0PWQuZXhwb3J0cz10eXBlb2Ygd2luZG93PCJ1IiYmd2luZG93Lk1hdGg9PU1hdGg/d2luZG93OnR5cGVvZiBzZWxmPCJ1IiYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oInJldHVybiB0aGlzIikoKTt0eXBlb2YgX19nPT0ibnVtYmVyIiYmKF9fZz10KX0sZnVuY3Rpb24oZCxlKXt2YXIgdD1kLmV4cG9ydHM9e3ZlcnNpb246IjIuNi4xMSJ9O3R5cGVvZiBfX2U9PSJudW1iZXIiJiYoX19lPXQpfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5NCk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4scyxsKXtpZihyKG4pLHM9PT12b2lkIDApcmV0dXJuIG47c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIG4uY2FsbChzLGMpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKGMsbyl7cmV0dXJuIG4uY2FsbChzLGMsbyl9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24oYyxvLGYpe3JldHVybiBuLmNhbGwocyxjLG8sZil9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuLmFwcGx5KHMsYXJndW1lbnRzKX19fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0eXBlb2YgdCE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IodCsiIGlzIG5vdCBhIGZ1bmN0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTYpLG49dCgxMDQpO2QuZXhwb3J0cz10KDEwMCk/ZnVuY3Rpb24ocyxsLGMpe3JldHVybiByLmYocyxsLG4oMSxjKSl9OmZ1bmN0aW9uKHMsbCxjKXtyZXR1cm4gc1tsXT1jLHN9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5Nyksbj10KDk5KSxzPXQoMTAzKSxsPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTtlLmY9dCgxMDApP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihvLGYseCl7aWYocihvKSxmPXMoZiwhMCkscih4KSxuKXRyeXtyZXR1cm4gbChvLGYseCl9Y2F0Y2h7fWlmKCJnZXQiaW4geHx8InNldCJpbiB4KXRocm93IFR5cGVFcnJvcigiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhIik7cmV0dXJuInZhbHVlImluIHgmJihvW2ZdPXgudmFsdWUpLG99fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5OCk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4pe2lmKCFyKG4pKXRocm93IFR5cGVFcnJvcihuKyIgaXMgbm90IGFuIG9iamVjdCEiKTtyZXR1cm4gbn19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im9iamVjdCI/dCE9PW51bGw6dHlwZW9mIHQ9PSJmdW5jdGlvbiJ9fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPSF0KDEwMCkmJiF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQoMTAyKSgiZGl2IiksImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaHtyZXR1cm4hMH19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5OCksbj10KDkxKS5kb2N1bWVudCxzPXIobikmJnIobi5jcmVhdGVFbGVtZW50KTtkLmV4cG9ydHM9ZnVuY3Rpb24obCl7cmV0dXJuIHM/bi5jcmVhdGVFbGVtZW50KGwpOnt9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTgpO2QuZXhwb3J0cz1mdW5jdGlvbihuLHMpe2lmKCFyKG4pKXJldHVybiBuO3ZhciBsLGM7aWYocyYmdHlwZW9mKGw9bi50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFyKGM9bC5jYWxsKG4pKXx8dHlwZW9mKGw9bi52YWx1ZU9mKT09ImZ1bmN0aW9uIiYmIXIoYz1sLmNhbGwobikpfHwhcyYmdHlwZW9mKGw9bi50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFyKGM9bC5jYWxsKG4pKSlyZXR1cm4gYzt0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9ZnVuY3Rpb24odCxyKXtyZXR1cm57ZW51bWVyYWJsZTohKHQmMSksY29uZmlndXJhYmxlOiEodCYyKSx3cml0YWJsZTohKHQmNCksdmFsdWU6cn19fSxmdW5jdGlvbihkLGUpe3ZhciB0PXt9Lmhhc093blByb3BlcnR5O2QuZXhwb3J0cz1mdW5jdGlvbihyLG4pe3JldHVybiB0LmNhbGwocixuKX19LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9dCg5NSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDEwOCksbj10KDEwNCkscz10KDEyMSksbD17fTt0KDk1KShsLHQoMTIyKSgiaXRlcmF0b3IiKSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSksZC5leHBvcnRzPWZ1bmN0aW9uKGMsbyxmKXtjLnByb3RvdHlwZT1yKGwse25leHQ6bigxLGYpfSkscyhjLG8rIiBJdGVyYXRvciIpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTcpLG49dCgxMDkpLHM9dCgxMTkpLGw9dCgxMTYpKCJJRV9QUk9UTyIpLGM9ZnVuY3Rpb24oKXt9LG89InByb3RvdHlwZSIsZj1mdW5jdGlvbigpe3ZhciB4PXQoMTAyKSgiaWZyYW1lIiksZz1zLmxlbmd0aCx5PSI8IixtPSI+IixUO2Zvcih4LnN0eWxlLmRpc3BsYXk9Im5vbmUiLHQoMTIwKS5hcHBlbmRDaGlsZCh4KSx4LnNyYz0iamF2YXNjcmlwdDoiLFQ9eC5jb250ZW50V2luZG93LmRvY3VtZW50LFQub3BlbigpLFQud3JpdGUoeSsic2NyaXB0IittKyJkb2N1bWVudC5GPU9iamVjdCIreSsiL3NjcmlwdCIrbSksVC5jbG9zZSgpLGY9VC5GO2ctLTspZGVsZXRlIGZbb11bc1tnXV07cmV0dXJuIGYoKX07ZC5leHBvcnRzPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKGcseSl7dmFyIG07cmV0dXJuIGchPT1udWxsPyhjW29dPXIoZyksbT1uZXcgYyxjW29dPW51bGwsbVtsXT1nKTptPWYoKSx5PT09dm9pZCAwP206bihtLHkpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTYpLG49dCg5Nykscz10KDExMCk7ZC5leHBvcnRzPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbihjLG8pe24oYyk7Zm9yKHZhciBmPXMobykseD1mLmxlbmd0aCxnPTAseTt4Pmc7KXIuZihjLHk9ZltnKytdLG9beV0pO3JldHVybiBjfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTExKSxuPXQoMTE5KTtkLmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKGwpe3JldHVybiByKGwsbil9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMDUpLG49dCg4NCkscz10KDExMikoITEpLGw9dCgxMTYpKCJJRV9QUk9UTyIpO2QuZXhwb3J0cz1mdW5jdGlvbihjLG8pe3ZhciBmPW4oYykseD0wLGc9W10seTtmb3IoeSBpbiBmKXkhPWwmJnIoZix5KSYmZy5wdXNoKHkpO2Zvcig7by5sZW5ndGg+eDspcihmLHk9b1t4KytdKSYmKH5zKGcseSl8fGcucHVzaCh5KSk7cmV0dXJuIGd9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4NCksbj10KDExMykscz10KDExNSk7ZC5leHBvcnRzPWZ1bmN0aW9uKGwpe3JldHVybiBmdW5jdGlvbihjLG8sZil7dmFyIHg9cihjKSxnPW4oeC5sZW5ndGgpLHk9cyhmLGcpLG07aWYobCYmbyE9byl7Zm9yKDtnPnk7KWlmKG09eFt5KytdLG0hPW0pcmV0dXJuITB9ZWxzZSBmb3IoO2c+eTt5KyspaWYoKGx8fHkgaW4geCkmJnhbeV09PT1vKXJldHVybiBsfHx5fHwwO3JldHVybiFsJiYtMX19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTQpLG49TWF0aC5taW47ZC5leHBvcnRzPWZ1bmN0aW9uKHMpe3JldHVybiBzPjA/bihyKHMpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbihkLGUpe3ZhciB0PU1hdGguY2VpbCxyPU1hdGguZmxvb3I7ZC5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiBpc05hTihuPStuKT8wOihuPjA/cjp0KShuKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDExNCksbj1NYXRoLm1heCxzPU1hdGgubWluO2QuZXhwb3J0cz1mdW5jdGlvbihsLGMpe3JldHVybiBsPXIobCksbDwwP24obCtjLDApOnMobCxjKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDExNykoImtleXMiKSxuPXQoMTE4KTtkLmV4cG9ydHM9ZnVuY3Rpb24ocyl7cmV0dXJuIHJbc118fChyW3NdPW4ocykpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTIpLG49dCg5MSkscz0iX19jb3JlLWpzX3NoYXJlZF9fIixsPW5bc118fChuW3NdPXt9KTsoZC5leHBvcnRzPWZ1bmN0aW9uKGMsbyl7cmV0dXJuIGxbY118fChsW2NdPW8hPT12b2lkIDA/bzp7fSl9KSgidmVyc2lvbnMiLFtdKS5wdXNoKHt2ZXJzaW9uOnIudmVyc2lvbixtb2RlOnQoODkpPyJwdXJlIjoiZ2xvYmFsIixjb3B5cmlnaHQ6IsKpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSkifSl9LGZ1bmN0aW9uKGQsZSl7dmFyIHQ9MCxyPU1hdGgucmFuZG9tKCk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiJTeW1ib2woIi5jb25jYXQobj09PXZvaWQgMD8iIjpuLCIpXyIsKCsrdCtyKS50b1N0cmluZygzNikpfX0sZnVuY3Rpb24oZCxlKXtkLmV4cG9ydHM9ImNvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZiIuc3BsaXQoIiwiKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTEpLmRvY3VtZW50O2QuZXhwb3J0cz1yJiZyLmRvY3VtZW50RWxlbWVudH0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTYpLmYsbj10KDEwNSkscz10KDEyMikoInRvU3RyaW5nVGFnIik7ZC5leHBvcnRzPWZ1bmN0aW9uKGwsYyxvKXtsJiYhbihsPW8/bDpsLnByb3RvdHlwZSxzKSYmcihsLHMse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpjfSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTcpKCJ3a3MiKSxuPXQoMTE4KSxzPXQoOTEpLlN5bWJvbCxsPXR5cGVvZiBzPT0iZnVuY3Rpb24iLGM9ZC5leHBvcnRzPWZ1bmN0aW9uKG8pe3JldHVybiByW29dfHwocltvXT1sJiZzW29dfHwobD9zOm4pKCJTeW1ib2wuIitvKSl9O2Muc3RvcmU9cn0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTA1KSxuPXQoMTI0KSxzPXQoMTE2KSgiSUVfUFJPVE8iKSxsPU9iamVjdC5wcm90b3R5cGU7ZC5leHBvcnRzPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oYyl7cmV0dXJuIGM9bihjKSxyKGMscyk/Y1tzXTp0eXBlb2YgYy5jb25zdHJ1Y3Rvcj09ImZ1bmN0aW9uIiYmYyBpbnN0YW5jZW9mIGMuY29uc3RydWN0b3I/Yy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6YyBpbnN0YW5jZW9mIE9iamVjdD9sOm51bGx9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4Nyk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiBPYmplY3QocihuKSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMjYpKCEwKTt0KDg4KShTdHJpbmcsIlN0cmluZyIsZnVuY3Rpb24obil7dGhpcy5fdD1TdHJpbmcobiksdGhpcy5faT0wfSxmdW5jdGlvbigpe3ZhciBuPXRoaXMuX3Qscz10aGlzLl9pLGw7cmV0dXJuIHM+PW4ubGVuZ3RoP3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06KGw9cihuLHMpLHRoaXMuX2krPWwubGVuZ3RoLHt2YWx1ZTpsLGRvbmU6ITF9KX0pfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTQpLG49dCg4Nyk7ZC5leHBvcnRzPWZ1bmN0aW9uKHMpe3JldHVybiBmdW5jdGlvbihsLGMpe3ZhciBvPVN0cmluZyhuKGwpKSxmPXIoYykseD1vLmxlbmd0aCxnLHk7cmV0dXJuIGY8MHx8Zj49eD9zPyIiOnZvaWQgMDooZz1vLmNoYXJDb2RlQXQoZiksZzw1NTI5Nnx8Zz41NjMxOXx8ZisxPT09eHx8KHk9by5jaGFyQ29kZUF0KGYrMSkpPDU2MzIwfHx5PjU3MzQzP3M/by5jaGFyQXQoZik6ZzpzP28uc2xpY2UoZixmKzIpOihnLTU1Mjk2PDwxMCkrKHktNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMjgpLG49dCgxMjIpKCJpdGVyYXRvciIpLHM9dCg4Myk7ZC5leHBvcnRzPXQoOTIpLmlzSXRlcmFibGU9ZnVuY3Rpb24obCl7dmFyIGM9T2JqZWN0KGwpO3JldHVybiBjW25dIT09dm9pZCAwfHwiQEBpdGVyYXRvciJpbiBjfHxzLmhhc093blByb3BlcnR5KHIoYykpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoODYpLG49dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLHM9cihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpPT0iQXJndW1lbnRzIixsPWZ1bmN0aW9uKGMsbyl7dHJ5e3JldHVybiBjW29dfWNhdGNoe319O2QuZXhwb3J0cz1mdW5jdGlvbihjKXt2YXIgbyxmLHg7cmV0dXJuIGM9PT12b2lkIDA/IlVuZGVmaW5lZCI6Yz09PW51bGw/Ik51bGwiOnR5cGVvZihmPWwobz1PYmplY3QoYyksbikpPT0ic3RyaW5nIj9mOnM/cihvKTooeD1yKG8pKT09Ik9iamVjdCImJnR5cGVvZiBvLmNhbGxlZT09ImZ1bmN0aW9uIj8iQXJndW1lbnRzIjp4fX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDEzMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDc5KSx0KDEyNSksZC5leHBvcnRzPXQoMTMxKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTcpLG49dCgxMzIpO2QuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvcj1mdW5jdGlvbihzKXt2YXIgbD1uKHMpO2lmKHR5cGVvZiBsIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihzKyIgaXMgbm90IGl0ZXJhYmxlISIpO3JldHVybiByKGwuY2FsbChzKSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMjgpLG49dCgxMjIpKCJpdGVyYXRvciIpLHM9dCg4Myk7ZC5leHBvcnRzPXQoOTIpLmdldEl0ZXJhdG9yTWV0aG9kPWZ1bmN0aW9uKGwpe2lmKGwhPW51bGwpcmV0dXJuIGxbbl18fGxbIkBAaXRlcmF0b3IiXXx8c1tyKGwpXX19LGZ1bmN0aW9uKGQsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIHI9dCgxMzQpLG49cyhyKTtmdW5jdGlvbiBzKGwpe3JldHVybiBsJiZsLl9fZXNNb2R1bGU/bDp7ZGVmYXVsdDpsfX1lLmRlZmF1bHQ9ZnVuY3Rpb24obCl7aWYoQXJyYXkuaXNBcnJheShsKSl7Zm9yKHZhciBjPTAsbz1BcnJheShsLmxlbmd0aCk7YzxsLmxlbmd0aDtjKyspb1tjXT1sW2NdO3JldHVybiBvfWVsc2UgcmV0dXJuKDAsbi5kZWZhdWx0KShsKX19LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihkLGUsdCl7dCgxMjUpLHQoMTM2KSxkLmV4cG9ydHM9dCg5MikuQXJyYXkuZnJvbX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTMpLG49dCg5MCkscz10KDEyNCksbD10KDEzNyksYz10KDEzOCksbz10KDExMyksZj10KDEzOSkseD10KDEzMik7bihuLlMrbi5GKiF0KDE0MCkoZnVuY3Rpb24oZyl7QXJyYXkuZnJvbShnKX0pLCJBcnJheSIse2Zyb206ZnVuY3Rpb24oeSl7dmFyIG09cyh5KSxUPXR5cGVvZiB0aGlzPT0iZnVuY3Rpb24iP3RoaXM6QXJyYXksTz1hcmd1bWVudHMubGVuZ3RoLHY9Tz4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsUD12IT09dm9pZCAwLGk9MCx1PXgobSksYSxoLGIsRTtpZihQJiYodj1yKHYsTz4yP2FyZ3VtZW50c1syXTp2b2lkIDAsMikpLHUhPW51bGwmJiEoVD09QXJyYXkmJmModSkpKWZvcihFPXUuY2FsbChtKSxoPW5ldyBUOyEoYj1FLm5leHQoKSkuZG9uZTtpKyspZihoLGksUD9sKEUsdixbYi52YWx1ZSxpXSwhMCk6Yi52YWx1ZSk7ZWxzZSBmb3IoYT1vKG0ubGVuZ3RoKSxoPW5ldyBUKGEpO2E+aTtpKyspZihoLGksUD92KG1baV0saSk6bVtpXSk7cmV0dXJuIGgubGVuZ3RoPWksaH19KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTcpO2QuZXhwb3J0cz1mdW5jdGlvbihuLHMsbCxjKXt0cnl7cmV0dXJuIGM/cyhyKGwpWzBdLGxbMV0pOnMobCl9Y2F0Y2goZil7dmFyIG89bi5yZXR1cm47dGhyb3cgbyE9PXZvaWQgMCYmcihvLmNhbGwobikpLGZ9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoODMpLG49dCgxMjIpKCJpdGVyYXRvciIpLHM9QXJyYXkucHJvdG90eXBlO2QuZXhwb3J0cz1mdW5jdGlvbihsKXtyZXR1cm4gbCE9PXZvaWQgMCYmKHIuQXJyYXk9PT1sfHxzW25dPT09bCl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5Niksbj10KDEwNCk7ZC5leHBvcnRzPWZ1bmN0aW9uKHMsbCxjKXtsIGluIHM/ci5mKHMsbCxuKDAsYykpOnNbbF09Y319LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDEyMikoIml0ZXJhdG9yIiksbj0hMTt0cnl7dmFyIHM9WzddW3JdKCk7cy5yZXR1cm49ZnVuY3Rpb24oKXtuPSEwfSxBcnJheS5mcm9tKHMsZnVuY3Rpb24oKXt0aHJvdyAyfSl9Y2F0Y2h7fWQuZXhwb3J0cz1mdW5jdGlvbihsLGMpe2lmKCFjJiYhbilyZXR1cm4hMTt2YXIgbz0hMTt0cnl7dmFyIGY9WzddLHg9ZltyXSgpO3gubmV4dD1mdW5jdGlvbigpe3JldHVybntkb25lOm89ITB9fSxmW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHh9LGwoZil9Y2F0Y2h7fXJldHVybiBvfX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDE0MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTQ0KSx0KDE1NyksdCgxNjApLHQoMTYyKSxkLmV4cG9ydHM9dCg5MikuTWFwfSxmdW5jdGlvbihkLGUpe30sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTQ1KSxuPXQoMTUxKSxzPSJNYXAiO2QuZXhwb3J0cz10KDE1MikocyxmdW5jdGlvbihsKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKX19LHtnZXQ6ZnVuY3Rpb24oYyl7dmFyIG89ci5nZXRFbnRyeShuKHRoaXMscyksYyk7cmV0dXJuIG8mJm8udn0sc2V0OmZ1bmN0aW9uKGMsbyl7cmV0dXJuIHIuZGVmKG4odGhpcyxzKSxjPT09MD8wOmMsbyl9fSxyLCEwKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTYpLmYsbj10KDEwOCkscz10KDE0NiksbD10KDkzKSxjPXQoMTQ3KSxvPXQoMTQ4KSxmPXQoODgpLHg9dCg4MiksZz10KDE0OSkseT10KDEwMCksbT10KDE1MCkuZmFzdEtleSxUPXQoMTUxKSxPPXk/Il9zIjoic2l6ZSIsdj1mdW5jdGlvbihQLGkpe3ZhciB1PW0oaSksYTtpZih1IT09IkYiKXJldHVybiBQLl9pW3VdO2ZvcihhPVAuX2Y7YTthPWEubilpZihhLms9PWkpcmV0dXJuIGF9O2QuZXhwb3J0cz17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24oUCxpLHUsYSl7dmFyIGg9UChmdW5jdGlvbihiLEUpe2MoYixoLGksIl9pIiksYi5fdD1pLGIuX2k9bihudWxsKSxiLl9mPXZvaWQgMCxiLl9sPXZvaWQgMCxiW09dPTAsRSE9bnVsbCYmbyhFLHUsYlthXSxiKX0pO3JldHVybiBzKGgucHJvdG90eXBlLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgRT1UKHRoaXMsaSksQT1FLl9pLEw9RS5fZjtMO0w9TC5uKUwucj0hMCxMLnAmJihMLnA9TC5wLm49dm9pZCAwKSxkZWxldGUgQVtMLmldO0UuX2Y9RS5fbD12b2lkIDAsRVtPXT0wfSxkZWxldGU6ZnVuY3Rpb24oYil7dmFyIEU9VCh0aGlzLGkpLEE9dihFLGIpO2lmKEEpe3ZhciBMPUEubixTPUEucDtkZWxldGUgRS5faVtBLmldLEEucj0hMCxTJiYoUy5uPUwpLEwmJihMLnA9UyksRS5fZj09QSYmKEUuX2Y9TCksRS5fbD09QSYmKEUuX2w9UyksRVtPXS0tfXJldHVybiEhQX0sZm9yRWFjaDpmdW5jdGlvbihFKXtUKHRoaXMsaSk7Zm9yKHZhciBBPWwoRSxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKSxMO0w9TD9MLm46dGhpcy5fZjspZm9yKEEoTC52LEwuayx0aGlzKTtMJiZMLnI7KUw9TC5wfSxoYXM6ZnVuY3Rpb24oRSl7cmV0dXJuISF2KFQodGhpcyxpKSxFKX19KSx5JiZyKGgucHJvdG90eXBlLCJzaXplIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFQodGhpcyxpKVtPXX19KSxofSxkZWY6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXYoUCxpKSxoLGI7cmV0dXJuIGE/YS52PXU6KFAuX2w9YT17aTpiPW0oaSwhMCksazppLHY6dSxwOmg9UC5fbCxuOnZvaWQgMCxyOiExfSxQLl9mfHwoUC5fZj1hKSxoJiYoaC5uPWEpLFBbT10rKyxiIT09IkYiJiYoUC5faVtiXT1hKSksUH0sZ2V0RW50cnk6dixzZXRTdHJvbmc6ZnVuY3Rpb24oUCxpLHUpe2YoUCxpLGZ1bmN0aW9uKGEsaCl7dGhpcy5fdD1UKGEsaSksdGhpcy5faz1oLHRoaXMuX2w9dm9pZCAwfSxmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLGg9YS5fayxiPWEuX2w7YiYmYi5yOyliPWIucDtyZXR1cm4hYS5fdHx8IShhLl9sPWI9Yj9iLm46YS5fdC5fZik/KGEuX3Q9dm9pZCAwLHgoMSkpOmg9PSJrZXlzIj94KDAsYi5rKTpoPT0idmFsdWVzIj94KDAsYi52KTp4KDAsW2IuayxiLnZdKX0sdT8iZW50cmllcyI6InZhbHVlcyIsIXUsITApLGcoaSl9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTUpO2QuZXhwb3J0cz1mdW5jdGlvbihuLHMsbCl7Zm9yKHZhciBjIGluIHMpbCYmbltjXT9uW2NdPXNbY106cihuLGMsc1tjXSk7cmV0dXJuIG59fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1mdW5jdGlvbih0LHIsbixzKXtpZighKHQgaW5zdGFuY2VvZiByKXx8cyE9PXZvaWQgMCYmcyBpbiB0KXRocm93IFR5cGVFcnJvcihuKyI6IGluY29ycmVjdCBpbnZvY2F0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24oZCxnLHQpe3ZhciByPXQoOTMpLG49dCgxMzcpLHM9dCgxMzgpLGw9dCg5NyksYz10KDExMyksbz10KDEzMiksZj17fSx4PXt9LGc9ZC5leHBvcnRzPWZ1bmN0aW9uKHksbSxULE8sdil7dmFyIFA9dj9mdW5jdGlvbigpe3JldHVybiB5fTpvKHkpLGk9cihULE8sbT8yOjEpLHU9MCxhLGgsYixFO2lmKHR5cGVvZiBQIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcih5KyIgaXMgbm90IGl0ZXJhYmxlISIpO2lmKHMoUCkpe2ZvcihhPWMoeS5sZW5ndGgpO2E+dTt1KyspaWYoRT1tP2kobChoPXlbdV0pWzBdLGhbMV0pOmkoeVt1XSksRT09PWZ8fEU9PT14KXJldHVybiBFfWVsc2UgZm9yKGI9UC5jYWxsKHkpOyEoaD1iLm5leHQoKSkuZG9uZTspaWYoRT1uKGIsaSxoLnZhbHVlLG0pLEU9PT1mfHxFPT09eClyZXR1cm4gRX07Zy5CUkVBSz1mLGcuUkVUVVJOPXh9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkxKSxuPXQoOTIpLHM9dCg5NiksbD10KDEwMCksYz10KDEyMikoInNwZWNpZXMiKTtkLmV4cG9ydHM9ZnVuY3Rpb24obyl7dmFyIGY9dHlwZW9mIG5bb109PSJmdW5jdGlvbiI/bltvXTpyW29dO2wmJmYmJiFmW2NdJiZzLmYoZixjLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9fSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTgpKCJtZXRhIiksbj10KDk4KSxzPXQoMTA1KSxsPXQoOTYpLmYsYz0wLG89T2JqZWN0LmlzRXh0ZW5zaWJsZXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZj0hdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIG8oT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSx4PWZ1bmN0aW9uKE8pe2woTyxyLHt2YWx1ZTp7aToiTyIrICsrYyx3Ont9fX0pfSxnPWZ1bmN0aW9uKE8sdil7aWYoIW4oTykpcmV0dXJuIHR5cGVvZiBPPT0ic3ltYm9sIj9POih0eXBlb2YgTz09InN0cmluZyI/IlMiOiJQIikrTztpZighcyhPLHIpKXtpZighbyhPKSlyZXR1cm4iRiI7aWYoIXYpcmV0dXJuIkUiO3goTyl9cmV0dXJuIE9bcl0uaX0seT1mdW5jdGlvbihPLHYpe2lmKCFzKE8scikpe2lmKCFvKE8pKXJldHVybiEwO2lmKCF2KXJldHVybiExO3goTyl9cmV0dXJuIE9bcl0ud30sbT1mdW5jdGlvbihPKXtyZXR1cm4gZiYmVC5ORUVEJiZvKE8pJiYhcyhPLHIpJiZ4KE8pLE99LFQ9ZC5leHBvcnRzPXtLRVk6cixORUVEOiExLGZhc3RLZXk6ZyxnZXRXZWFrOnksb25GcmVlemU6bX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDk4KTtkLmV4cG9ydHM9ZnVuY3Rpb24obixzKXtpZighcihuKXx8bi5fdCE9PXMpdGhyb3cgVHlwZUVycm9yKCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICIrcysiIHJlcXVpcmVkISIpO3JldHVybiBufX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTEpLG49dCg5MCkscz10KDE1MCksbD10KDEwMSksYz10KDk1KSxvPXQoMTQ2KSxmPXQoMTQ4KSx4PXQoMTQ3KSxnPXQoOTgpLHk9dCgxMjEpLG09dCg5NikuZixUPXQoMTUzKSgwKSxPPXQoMTAwKTtkLmV4cG9ydHM9ZnVuY3Rpb24odixQLGksdSxhLGgpe3ZhciBiPXJbdl0sRT1iLEE9YT8ic2V0IjoiYWRkIixMPUUmJkUucHJvdG90eXBlLFM9e307cmV0dXJuIU98fHR5cGVvZiBFIT0iZnVuY3Rpb24ifHwhKGh8fEwuZm9yRWFjaCYmIWwoZnVuY3Rpb24oKXtuZXcgRSgpLmVudHJpZXMoKS5uZXh0KCl9KSk/KEU9dS5nZXRDb25zdHJ1Y3RvcihQLHYsYSxBKSxvKEUucHJvdG90eXBlLGkpLHMuTkVFRD0hMCk6KEU9UChmdW5jdGlvbihJLEQpe3goSSxFLHYsIl9jIiksSS5fYz1uZXcgYixEIT1udWxsJiZmKEQsYSxJW0FdLEkpfSksVCgiYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OIi5zcGxpdCgiLCIpLGZ1bmN0aW9uKEkpe3ZhciBEPUk9PSJhZGQifHxJPT0ic2V0IjtJIGluIEwmJiEoaCYmST09ImNsZWFyIikmJmMoRS5wcm90b3R5cGUsSSxmdW5jdGlvbihSLEMpe2lmKHgodGhpcyxFLEkpLCFEJiZoJiYhZyhSKSlyZXR1cm4gST09ImdldCI/dm9pZCAwOiExO3ZhciBqPXRoaXMuX2NbSV0oUj09PTA/MDpSLEMpO3JldHVybiBEP3RoaXM6an0pfSksaHx8bShFLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jLnNpemV9fSkpLHkoRSx2KSxTW3ZdPUUsbihuLkcrbi5XK24uRixTKSxofHx1LnNldFN0cm9uZyhFLHYsYSksRX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkzKSxuPXQoODUpLHM9dCgxMjQpLGw9dCgxMTMpLGM9dCgxNTQpO2QuZXhwb3J0cz1mdW5jdGlvbihvLGYpe3ZhciB4PW89PTEsZz1vPT0yLHk9bz09MyxtPW89PTQsVD1vPT02LE89bz09NXx8VCx2PWZ8fGM7cmV0dXJuIGZ1bmN0aW9uKFAsaSx1KXtmb3IodmFyIGE9cyhQKSxoPW4oYSksYj1yKGksdSwzKSxFPWwoaC5sZW5ndGgpLEE9MCxMPXg/dihQLEUpOmc/dihQLDApOnZvaWQgMCxTLEk7RT5BO0ErKylpZigoT3x8QSBpbiBoKSYmKFM9aFtBXSxJPWIoUyxBLGEpLG8pKXtpZih4KUxbQV09STtlbHNlIGlmKEkpc3dpdGNoKG8pe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIFM7Y2FzZSA2OnJldHVybiBBO2Nhc2UgMjpMLnB1c2goUyl9ZWxzZSBpZihtKXJldHVybiExfXJldHVybiBUPy0xOnl8fG0/bTpMfX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDE1NSk7ZC5leHBvcnRzPWZ1bmN0aW9uKG4scyl7cmV0dXJuIG5ldyhyKG4pKShzKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDk4KSxuPXQoMTU2KSxzPXQoMTIyKSgic3BlY2llcyIpO2QuZXhwb3J0cz1mdW5jdGlvbihsKXt2YXIgYztyZXR1cm4gbihsKSYmKGM9bC5jb25zdHJ1Y3Rvcix0eXBlb2YgYz09ImZ1bmN0aW9uIiYmKGM9PT1BcnJheXx8bihjLnByb3RvdHlwZSkpJiYoYz12b2lkIDApLHIoYykmJihjPWNbc10sYz09PW51bGwmJihjPXZvaWQgMCkpKSxjPT09dm9pZCAwP0FycmF5OmN9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4Nik7ZC5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHMpe3JldHVybiByKHMpPT0iQXJyYXkifX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTApO3Ioci5QK3IuUiwiTWFwIix7dG9KU09OOnQoMTU4KSgiTWFwIil9KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTI4KSxuPXQoMTU5KTtkLmV4cG9ydHM9ZnVuY3Rpb24ocyl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYocih0aGlzKSE9cyl0aHJvdyBUeXBlRXJyb3IocysiI3RvSlNPTiBpc24ndCBnZW5lcmljIik7cmV0dXJuIG4odGhpcyl9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTQ4KTtkLmV4cG9ydHM9ZnVuY3Rpb24obixzKXt2YXIgbD1bXTtyZXR1cm4gcihuLCExLGwucHVzaCxsLHMpLGx9fSxmdW5jdGlvbihkLGUsdCl7dCgxNjEpKCJNYXAiKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTApO2QuZXhwb3J0cz1mdW5jdGlvbihuKXtyKHIuUyxuLHtvZjpmdW5jdGlvbigpe2Zvcih2YXIgbD1hcmd1bWVudHMubGVuZ3RoLGM9bmV3IEFycmF5KGwpO2wtLTspY1tsXT1hcmd1bWVudHNbbF07cmV0dXJuIG5ldyB0aGlzKGMpfX0pfX0sZnVuY3Rpb24oZCxlLHQpe3QoMTYzKSgiTWFwIil9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKSxuPXQoOTQpLHM9dCg5MyksbD10KDE0OCk7ZC5leHBvcnRzPWZ1bmN0aW9uKGMpe3Ioci5TLGMse2Zyb206ZnVuY3Rpb24oZil7dmFyIHg9YXJndW1lbnRzWzFdLGcseSxtLFQ7cmV0dXJuIG4odGhpcyksZz14IT09dm9pZCAwLGcmJm4oeCksZj09bnVsbD9uZXcgdGhpczooeT1bXSxnPyhtPTAsVD1zKHgsYXJndW1lbnRzWzJdLDIpLGwoZiwhMSxmdW5jdGlvbihPKXt5LnB1c2goVChPLG0rKykpfSkpOmwoZiwhMSx5LnB1c2gseSksbmV3IHRoaXMoeSkpfX0pfX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDE2NSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDE2NiksZC5leHBvcnRzPXQoOTIpLk9iamVjdC5hc3NpZ259LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKTtyKHIuUytyLkYsIk9iamVjdCIse2Fzc2lnbjp0KDE2Nyl9KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTAwKSxuPXQoMTEwKSxzPXQoMTY4KSxsPXQoMTY5KSxjPXQoMTI0KSxvPXQoODUpLGY9T2JqZWN0LmFzc2lnbjtkLmV4cG9ydHM9IWZ8fHQoMTAxKShmdW5jdGlvbigpe3ZhciB4PXt9LGc9e30seT1TeW1ib2woKSxtPSJhYmNkZWZnaGlqa2xtbm9wcXJzdCI7cmV0dXJuIHhbeV09NyxtLnNwbGl0KCIiKS5mb3JFYWNoKGZ1bmN0aW9uKFQpe2dbVF09VH0pLGYoe30seClbeV0hPTd8fE9iamVjdC5rZXlzKGYoe30sZykpLmpvaW4oIiIpIT1tfSk/ZnVuY3Rpb24oZyx5KXtmb3IodmFyIG09YyhnKSxUPWFyZ3VtZW50cy5sZW5ndGgsTz0xLHY9cy5mLFA9bC5mO1Q+TzspZm9yKHZhciBpPW8oYXJndW1lbnRzW08rK10pLHU9dj9uKGkpLmNvbmNhdCh2KGkpKTpuKGkpLGE9dS5sZW5ndGgsaD0wLGI7YT5oOyliPXVbaCsrXSwoIXJ8fFAuY2FsbChpLGIpKSYmKG1bYl09aVtiXSk7cmV0dXJuIG19OmZ9LGZ1bmN0aW9uKGQsZSl7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LGZ1bmN0aW9uKGQsZSl7ZS5mPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlfSxmdW5jdGlvbihkLGUsdCl7ZS5fX2VzTW9kdWxlPSEwLGUuZGVmYXVsdD1mdW5jdGlvbihyLG4pe2lmKCEociBpbnN0YW5jZW9mIG4pKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfX0sZnVuY3Rpb24oZCxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgcj10KDE3Miksbj1zKHIpO2Z1bmN0aW9uIHMobCl7cmV0dXJuIGwmJmwuX19lc01vZHVsZT9sOntkZWZhdWx0Omx9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGwoYyxvKXtmb3IodmFyIGY9MDtmPG8ubGVuZ3RoO2YrKyl7dmFyIHg9b1tmXTt4LmVudW1lcmFibGU9eC5lbnVtZXJhYmxlfHwhMSx4LmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4geCYmKHgud3JpdGFibGU9ITApLCgwLG4uZGVmYXVsdCkoYyx4LmtleSx4KX19cmV0dXJuIGZ1bmN0aW9uKGMsbyxmKXtyZXR1cm4gbyYmbChjLnByb3RvdHlwZSxvKSxmJiZsKGMsZiksY319KCl9LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNzMpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihkLGUsdCl7dCgxNzQpO3ZhciByPXQoOTIpLk9iamVjdDtkLmV4cG9ydHM9ZnVuY3Rpb24ocyxsLGMpe3JldHVybiByLmRlZmluZVByb3BlcnR5KHMsbCxjKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKTtyKHIuUytyLkYqIXQoMTAwKSwiT2JqZWN0Iix7ZGVmaW5lUHJvcGVydHk6dCg5NikuZn0pfSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXtkZWZhdWx0OnQoMTc2KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oZCxlLHQpe3QoMTc3KSx0KDE0MyksdCgxODQpLHQoMTg1KSxkLmV4cG9ydHM9dCg5MikuU3ltYm9sfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5MSksbj10KDEwNSkscz10KDEwMCksbD10KDkwKSxjPXQoMTA2KSxvPXQoMTUwKS5LRVksZj10KDEwMSkseD10KDExNyksZz10KDEyMSkseT10KDExOCksbT10KDEyMiksVD10KDE3OCksTz10KDE3OSksdj10KDE4MCksUD10KDE1NiksaT10KDk3KSx1PXQoOTgpLGE9dCgxMjQpLGg9dCg4NCksYj10KDEwMyksRT10KDEwNCksQT10KDEwOCksTD10KDE4MSksUz10KDE4MyksST10KDE2OCksRD10KDk2KSxSPXQoMTEwKSxDPVMuZixqPUQuZiwkPUwuZixIPXIuU3ltYm9sLEo9ci5KU09OLHE9SiYmSi5zdHJpbmdpZnksRj0icHJvdG90eXBlIixHPW0oIl9oaWRkZW4iKSxaPW0oInRvUHJpbWl0aXZlIiksdHQ9e30ucHJvcGVydHlJc0VudW1lcmFibGUsZXQ9eCgic3ltYm9sLXJlZ2lzdHJ5IiksaXQ9eCgic3ltYm9scyIpLGs9eCgib3Atc3ltYm9scyIpLGh0PU9iamVjdFtGXSxmdD10eXBlb2YgSD09ImZ1bmN0aW9uIiYmISFJLmYsQj1yLlFPYmplY3QsVz0hQnx8IUJbRl18fCFCW0ZdLmZpbmRDaGlsZCxWPXMmJmYoZnVuY3Rpb24oKXtyZXR1cm4gQShqKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGoodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hIT03fSk/ZnVuY3Rpb24ob3Qsc3QsbHQpe3ZhciBtdD1DKGh0LHN0KTttdCYmZGVsZXRlIGh0W3N0XSxqKG90LHN0LGx0KSxtdCYmb3QhPT1odCYmaihodCxzdCxtdCl9OmosWD1mdW5jdGlvbihvdCl7dmFyIHN0PWl0W290XT1BKEhbRl0pO3JldHVybiBzdC5faz1vdCxzdH0sTj1mdCYmdHlwZW9mIEguaXRlcmF0b3I9PSJzeW1ib2wiP2Z1bmN0aW9uKG90KXtyZXR1cm4gdHlwZW9mIG90PT0ic3ltYm9sIn06ZnVuY3Rpb24ob3Qpe3JldHVybiBvdCBpbnN0YW5jZW9mIEh9LHo9ZnVuY3Rpb24oc3QsbHQsbXQpe3JldHVybiBzdD09PWh0JiZ6KGssbHQsbXQpLGkoc3QpLGx0PWIobHQsITApLGkobXQpLG4oaXQsbHQpPyhtdC5lbnVtZXJhYmxlPyhuKHN0LEcpJiZzdFtHXVtsdF0mJihzdFtHXVtsdF09ITEpLG10PUEobXQse2VudW1lcmFibGU6RSgwLCExKX0pKToobihzdCxHKXx8aihzdCxHLEUoMSx7fSkpLHN0W0ddW2x0XT0hMCksVihzdCxsdCxtdCkpOmooc3QsbHQsbXQpfSxwPWZ1bmN0aW9uKHN0LGx0KXtpKHN0KTtmb3IodmFyIG10PXYobHQ9aChsdCkpLHB0PTAsZHQ9bXQubGVuZ3RoLHl0O2R0PnB0Oyl6KHN0LHl0PW10W3B0KytdLGx0W3l0XSk7cmV0dXJuIHN0fSxNPWZ1bmN0aW9uKHN0LGx0KXtyZXR1cm4gbHQ9PT12b2lkIDA/QShzdCk6cChBKHN0KSxsdCl9LHc9ZnVuY3Rpb24oc3Qpe3ZhciBsdD10dC5jYWxsKHRoaXMsc3Q9YihzdCwhMCkpO3JldHVybiB0aGlzPT09aHQmJm4oaXQsc3QpJiYhbihrLHN0KT8hMTpsdHx8IW4odGhpcyxzdCl8fCFuKGl0LHN0KXx8bih0aGlzLEcpJiZ0aGlzW0ddW3N0XT9sdDohMH0sVT1mdW5jdGlvbihzdCxsdCl7aWYoc3Q9aChzdCksbHQ9YihsdCwhMCksIShzdD09PWh0JiZuKGl0LGx0KSYmIW4oayxsdCkpKXt2YXIgbXQ9QyhzdCxsdCk7cmV0dXJuIG10JiZuKGl0LGx0KSYmIShuKHN0LEcpJiZzdFtHXVtsdF0pJiYobXQuZW51bWVyYWJsZT0hMCksbXR9fSxLPWZ1bmN0aW9uKHN0KXtmb3IodmFyIGx0PSQoaChzdCkpLG10PVtdLHB0PTAsZHQ7bHQubGVuZ3RoPnB0OykhbihpdCxkdD1sdFtwdCsrXSkmJmR0IT1HJiZkdCE9byYmbXQucHVzaChkdCk7cmV0dXJuIG10fSxZPWZ1bmN0aW9uKHN0KXtmb3IodmFyIGx0PXN0PT09aHQsbXQ9JChsdD9rOmgoc3QpKSxwdD1bXSxkdD0wLHl0O210Lmxlbmd0aD5kdDspbihpdCx5dD1tdFtkdCsrXSkmJighbHR8fG4oaHQseXQpKSYmcHQucHVzaChpdFt5dF0pO3JldHVybiBwdH07ZnR8fChIPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIEgpdGhyb3cgVHlwZUVycm9yKCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhIik7dmFyIHN0PXkoYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApLGx0PWZ1bmN0aW9uKG10KXt0aGlzPT09aHQmJmx0LmNhbGwoayxtdCksbih0aGlzLEcpJiZuKHRoaXNbR10sc3QpJiYodGhpc1tHXVtzdF09ITEpLFYodGhpcyxzdCxFKDEsbXQpKX07cmV0dXJuIHMmJlcmJlYoaHQsc3Qse2NvbmZpZ3VyYWJsZTohMCxzZXQ6bHR9KSxYKHN0KX0sYyhIW0ZdLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa30pLFMuZj1VLEQuZj16LHQoMTgyKS5mPUwuZj1LLHQoMTY5KS5mPXcsSS5mPVkscyYmIXQoODkpJiZjKGh0LCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsdywhMCksVC5mPWZ1bmN0aW9uKG90KXtyZXR1cm4gWChtKG90KSl9KSxsKGwuRytsLlcrbC5GKiFmdCx7U3ltYm9sOkh9KTtmb3IodmFyIFE9Imhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzIi5zcGxpdCgiLCIpLHJ0PTA7US5sZW5ndGg+cnQ7KW0oUVtydCsrXSk7Zm9yKHZhciBudD1SKG0uc3RvcmUpLGF0PTA7bnQubGVuZ3RoPmF0OylPKG50W2F0KytdKTtsKGwuUytsLkYqIWZ0LCJTeW1ib2wiLHtmb3I6ZnVuY3Rpb24ob3Qpe3JldHVybiBuKGV0LG90Kz0iIik/ZXRbb3RdOmV0W290XT1IKG90KX0sa2V5Rm9yOmZ1bmN0aW9uKHN0KXtpZighTihzdCkpdGhyb3cgVHlwZUVycm9yKHN0KyIgaXMgbm90IGEgc3ltYm9sISIpO2Zvcih2YXIgbHQgaW4gZXQpaWYoZXRbbHRdPT09c3QpcmV0dXJuIGx0fSx1c2VTZXR0ZXI6ZnVuY3Rpb24oKXtXPSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXtXPSExfX0pLGwobC5TK2wuRiohZnQsIk9iamVjdCIse2NyZWF0ZTpNLGRlZmluZVByb3BlcnR5OnosZGVmaW5lUHJvcGVydGllczpwLGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpVLGdldE93blByb3BlcnR5TmFtZXM6SyxnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6WX0pO3ZhciBjdD1mKGZ1bmN0aW9uKCl7SS5mKDEpfSk7bChsLlMrbC5GKmN0LCJPYmplY3QiLHtnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ZnVuY3Rpb24oc3Qpe3JldHVybiBJLmYoYShzdCkpfX0pLEomJmwobC5TK2wuRiooIWZ0fHxmKGZ1bmN0aW9uKCl7dmFyIG90PUgoKTtyZXR1cm4gcShbb3RdKSE9IltudWxsXSJ8fHEoe2E6b3R9KSE9Int9Inx8cShPYmplY3Qob3QpKSE9Int9In0pKSwiSlNPTiIse3N0cmluZ2lmeTpmdW5jdGlvbihzdCl7Zm9yKHZhciBsdD1bc3RdLG10PTEscHQsZHQ7YXJndW1lbnRzLmxlbmd0aD5tdDspbHQucHVzaChhcmd1bWVudHNbbXQrK10pO2lmKGR0PXB0PWx0WzFdLCEoIXUocHQpJiZzdD09PXZvaWQgMHx8TihzdCkpKXJldHVybiBQKHB0KXx8KHB0PWZ1bmN0aW9uKHl0LEF0KXtpZih0eXBlb2YgZHQ9PSJmdW5jdGlvbiImJihBdD1kdC5jYWxsKHRoaXMseXQsQXQpKSwhTihBdCkpcmV0dXJuIEF0fSksbHRbMV09cHQscS5hcHBseShKLGx0KX19KSxIW0ZdW1pdfHx0KDk1KShIW0ZdLFosSFtGXS52YWx1ZU9mKSxnKEgsIlN5bWJvbCIpLGcoTWF0aCwiTWF0aCIsITApLGcoci5KU09OLCJKU09OIiwhMCl9LGZ1bmN0aW9uKGQsZSx0KXtlLmY9dCgxMjIpfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5MSksbj10KDkyKSxzPXQoODkpLGw9dCgxNzgpLGM9dCg5NikuZjtkLmV4cG9ydHM9ZnVuY3Rpb24obyl7dmFyIGY9bi5TeW1ib2x8fChuLlN5bWJvbD1zP3t9OnIuU3ltYm9sfHx7fSk7by5jaGFyQXQoMCkhPSJfIiYmIShvIGluIGYpJiZjKGYsbyx7dmFsdWU6bC5mKG8pfSl9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMTApLG49dCgxNjgpLHM9dCgxNjkpO2QuZXhwb3J0cz1mdW5jdGlvbihsKXt2YXIgYz1yKGwpLG89bi5mO2lmKG8pZm9yKHZhciBmPW8obCkseD1zLmYsZz0wLHk7Zi5sZW5ndGg+ZzspeC5jYWxsKGwseT1mW2crK10pJiZjLnB1c2goeSk7cmV0dXJuIGN9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4NCksbj10KDE4MikuZixzPXt9LnRvU3RyaW5nLGw9dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXSxjPWZ1bmN0aW9uKG8pe3RyeXtyZXR1cm4gbihvKX1jYXRjaHtyZXR1cm4gbC5zbGljZSgpfX07ZC5leHBvcnRzLmY9ZnVuY3Rpb24oZil7cmV0dXJuIGwmJnMuY2FsbChmKT09IltvYmplY3QgV2luZG93XSI/YyhmKTpuKHIoZikpfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMTExKSxuPXQoMTE5KS5jb25jYXQoImxlbmd0aCIsInByb3RvdHlwZSIpO2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc3x8ZnVuY3Rpb24obCl7cmV0dXJuIHIobCxuKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDE2OSksbj10KDEwNCkscz10KDg0KSxsPXQoMTAzKSxjPXQoMTA1KSxvPXQoOTkpLGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtlLmY9dCgxMDApP2Y6ZnVuY3Rpb24oZyx5KXtpZihnPXMoZykseT1sKHksITApLG8pdHJ5e3JldHVybiBmKGcseSl9Y2F0Y2h7fWlmKGMoZyx5KSlyZXR1cm4gbighci5mLmNhbGwoZyx5KSxnW3ldKX19LGZ1bmN0aW9uKGQsZSx0KXt0KDE3OSkoImFzeW5jSXRlcmF0b3IiKX0sZnVuY3Rpb24oZCxlLHQpe3QoMTc5KSgib2JzZXJ2YWJsZSIpfSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuY3JlYXRlTm93VGltZT1yLGUuZm9ybWF0RGVsYXk9bjtmdW5jdGlvbiByKCl7dmFyIHM9bnVsbDtyZXR1cm4gRGF0ZS5ub3c/cz1EYXRlLm5vdzpzPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpfSxzfWZ1bmN0aW9uIG4ocyl7cmV0dXJuIHR5cGVvZiBzPT0ibnVtYmVyIj9zPXtkZWxheTpzfToiZW50cm9weSJpbiBzJiYocz17ZGVsYXk6cy5lbnRyb3B5LGlzRW50cm9weTohMH0pLHN9fSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD17ZGVmYXVsdDpmdW5jdGlvbihuLHMsbCxjLG8pe3JldHVybiB0eXBlb2Ygbj09Im51bWJlciImJnR5cGVvZiBzPT0ibnVtYmVyIj9uKyhsLWMpLyhvLWMpKihzLW4pOmwtYz5vLWw/czpufX19LGZ1bmN0aW9uKGQsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5wYXJzZUVhc2luZz1lLkVhc2luZ3M9dm9pZCAwO3ZhciByPXQoNzYpLG49ZihyKSxzPXQoMTMzKSxsPWYocyksYz10KDE0MSksbz1mKGMpO2Z1bmN0aW9uIGYoUCl7cmV0dXJuIFAmJlAuX19lc01vZHVsZT9QOntkZWZhdWx0OlB9fXZhciB4PXQoMTg5KSxnPW5ldyBvLmRlZmF1bHQ7ZnVuY3Rpb24geSgpe2Zvcih2YXIgUD1hcmd1bWVudHMubGVuZ3RoLGk9QXJyYXkoUCksdT0wO3U8UDt1KyspaVt1XT1hcmd1bWVudHNbdV07dmFyIGE9Zy5nZXQoaSk7cmV0dXJuIGF8fChhPXguYXBwbHkodm9pZCAwLGkpLGcuc2V0KGksYSksYSl9ZnVuY3Rpb24gbShQKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06ImVuZCI7cmV0dXJuIGZ1bmN0aW9uKHUsYSl7Zm9yKHZhciBoPTE7aDxhLmxlbmd0aDtoKyspe3ZhciBiPWFbaF0ub2Zmc2V0O2lmKHU8PWIpe3ZhciBFPWFbaC0xXS5vZmZzZXQsQT1iLEw9KHUtRSkvKEEtRSksUz0xL1AsST1ML1M7cmV0dXJuIGk9PT0iZW5kIj9JPU1hdGguZmxvb3IoSSk6ST1NYXRoLmNlaWwoSSksUypJKihBLUUpK0V9fXJldHVybiAwfX1mdW5jdGlvbiBUKFApe3ZhciBpPS9eY3ViaWMtYmV6aWVyXCgoLiopXCkvLHU9UC5tYXRjaChpKTtpZih1KXt2YXIgYT11WzFdLnRyaW0oKTtyZXR1cm4gYT1hLnNwbGl0KCIsIikubWFwKGZ1bmN0aW9uKFMpe3JldHVybiBwYXJzZUZsb2F0KFMudHJpbSgpKX0pLHkuYXBwbHkodm9pZCAwLCgwLGwuZGVmYXVsdCkoYSkpfWlmKGk9L15zdGVwc1woKC4qKVwpLyx1PVAubWF0Y2goaSksdSl7dmFyIGg9dVsxXS50cmltKCk7aD1oLnNwbGl0KCIsIikubWFwKGZ1bmN0aW9uKFMpe3JldHVybiBTLnRyaW0oKX0pO3ZhciBiPWgsRT0oMCxuLmRlZmF1bHQpKGIsMiksQT1FWzBdLEw9RVsxXTtyZXR1cm4gbShwYXJzZUludChBLDEwKSxMKX1yZXR1cm4gUH12YXIgTz17bGluZWFyOmZ1bmN0aW9uKGkpe3JldHVybiBpfSxlYXNlOnkoLjI1LC4xLC4yNSwxKSwiZWFzZS1pbiI6eSguNDIsMCwxLDEpLCJlYXNlLW91dCI6eSgwLDAsLjU4LDEpLCJlYXNlLWluLW91dCI6eSguNDIsMCwuNTgsMSksInN0ZXAtc3RhcnQiOm0oMSwic3RhcnQiKSwic3RlcC1lbmQiOm0oMSwiZW5kIil9O2Z1bmN0aW9uIHYoUCl7cmV0dXJuIHR5cGVvZiBQPT0ic3RyaW5nIj9PW1BdP1A9T1tQXTpQPVQoUCk6UC50eXBlPT09ImN1YmljLWJlemllciI/UD15LmFwcGx5KHZvaWQgMCwoMCxsLmRlZmF1bHQpKFAudmFsdWUpKTpQLnR5cGU9PT0ic3RlcHMiJiYoUD1tKFAuc3RlcCxQLnBvcykpLFB9ZS5FYXNpbmdzPU8sZS5wYXJzZUVhc2luZz12fSxmdW5jdGlvbihkLGUpe3ZhciB0PTQscj0uMDAxLG49MWUtNyxzPTEwLGw9MTEsYz0xLyhsLTEpLG89dHlwZW9mIEZsb2F0MzJBcnJheT09ImZ1bmN0aW9uIjtmdW5jdGlvbiBmKFAsaSl7cmV0dXJuIDEtMyppKzMqUH1mdW5jdGlvbiB4KFAsaSl7cmV0dXJuIDMqaS02KlB9ZnVuY3Rpb24gZyhQKXtyZXR1cm4gMypQfWZ1bmN0aW9uIHkoUCxpLHUpe3JldHVybigoZihpLHUpKlAreChpLHUpKSpQK2coaSkpKlB9ZnVuY3Rpb24gbShQLGksdSl7cmV0dXJuIDMqZihpLHUpKlAqUCsyKngoaSx1KSpQK2coaSl9ZnVuY3Rpb24gVChQLGksdSxhLGgpe3ZhciBiLEUsQT0wO2RvIEU9aSsodS1pKS8yLGI9eShFLGEsaCktUCxiPjA/dT1FOmk9RTt3aGlsZShNYXRoLmFicyhiKT5uJiYrK0E8cyk7cmV0dXJuIEV9ZnVuY3Rpb24gTyhQLGksdSxhKXtmb3IodmFyIGg9MDtoPHQ7KytoKXt2YXIgYj1tKGksdSxhKTtpZihiPT09MClyZXR1cm4gaTt2YXIgRT15KGksdSxhKS1QO2ktPUUvYn1yZXR1cm4gaX1mdW5jdGlvbiB2KFApe3JldHVybiBQfWQuZXhwb3J0cz1mdW5jdGlvbihpLHUsYSxoKXtpZighKDA8PWkmJmk8PTEmJjA8PWEmJmE8PTEpKXRocm93IG5ldyBFcnJvcigiYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlIik7aWYoaT09PXUmJmE9PT1oKXJldHVybiB2O2Zvcih2YXIgYj1vP25ldyBGbG9hdDMyQXJyYXkobCk6bmV3IEFycmF5KGwpLEU9MDtFPGw7KytFKWJbRV09eShFKmMsaSxhKTtmdW5jdGlvbiBBKEwpe2Zvcih2YXIgUz0wLEk9MSxEPWwtMTtJIT09RCYmYltJXTw9TDsrK0kpUys9YzstLUk7dmFyIFI9KEwtYltJXSkvKGJbSSsxXS1iW0ldKSxDPVMrUipjLGo9bShDLGksYSk7cmV0dXJuIGo+PXI/TyhMLEMsaSxhKTpqPT09MD9DOlQoTCxTLFMrYyxpLGEpfXJldHVybiBmdW5jdGlvbihTKXtyZXR1cm4gUz09PTA/MDpTPT09MT8xOnkoQShTKSx1LGgpfX19LGZ1bmN0aW9uKGQsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9dCgxOTEpLG49dShyKSxzPXQoMjA0KSxsPXUocyksYz10KDE2NCksbz11KGMpLGY9dCgxNzApLHg9dShmKSxnPXQoMTcxKSx5PXUoZyksbT10KDE3NSksVD11KG0pLE89dCg3NSksdj11KE8pLFA9dCgyMDgpLGk9dCgxODgpO2Z1bmN0aW9uIHUoail7cmV0dXJuIGomJmouX19lc01vZHVsZT9qOntkZWZhdWx0Omp9fXZhciBhPSgwLFQuZGVmYXVsdCkoInRpbWluZyIpLGg9KDAsVC5kZWZhdWx0KSgia2V5ZnJhbWVzIiksYj0oMCxULmRlZmF1bHQpKCJpbml0U3RhdGUiKSxFPSgwLFQuZGVmYXVsdCkoInJlYWR5RGVmZXIiKSxBPSgwLFQuZGVmYXVsdCkoImZpbmlzaGVkRGVmZXIiKSxMPSgwLFQuZGVmYXVsdCkoImVmZmVjdHMiKSxTPSgwLFQuZGVmYXVsdCkoImFjdGl2ZVJlYWR5VGltZXIiKSxJPSgwLFQuZGVmYXVsdCkoImFjdGl2ZUZpbmlzaFRpbWVyIiksRD0oMCxULmRlZmF1bHQpKCJyZW1vdmVEZWZlciIpLFI9e2RlbGF5OjAsZW5kRGVsYXk6MCxmaWxsOiJhdXRvIixpdGVyYXRpb25zOjEscGxheWJhY2tSYXRlOjEsZGlyZWN0aW9uOiJub3JtYWwiLGVhc2luZzoibGluZWFyIixlZmZlY3Q6bnVsbH0sQz1mdW5jdGlvbigpe2Z1bmN0aW9uIGooJCxILEope3ZhciBxPXRoaXM7aWYoKDAseC5kZWZhdWx0KSh0aGlzLGopLEFycmF5LmlzQXJyYXkoJCkpe3ZhciBGPVskWzBdLCQsSF07JD1GWzBdLEg9RlsxXSxKPUZbMl19dHlwZW9mIEo9PSJudW1iZXIiJiYoSj17ZHVyYXRpb246Sn0pLHRoaXNbYV09KDAsby5kZWZhdWx0KSh7fSxSLEopLHRoaXNbYV0uZWFzaW5nPSgwLGkucGFyc2VFYXNpbmcpKHRoaXNbYV0uZWFzaW5nKSx0aGlzW2hdPSgwLFAuY2FsY3VsYXRlRnJhbWVzT2Zmc2V0KShIKTt2YXIgRz10aGlzW2hdW3RoaXNbaF0ubGVuZ3RoLTFdO3RoaXNbYl09e30sKDAsbC5kZWZhdWx0KShHKS5mb3JFYWNoKGZ1bmN0aW9uKFope09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgkLFopJiZaIT09ImVhc2luZyImJlohPT0ib2Zmc2V0IiYmKHFbYl1bWl09JFtaXSl9KSx0aGlzW2hdPXRoaXNbaF0ubWFwKGZ1bmN0aW9uKFope3JldHVybigwLG8uZGVmYXVsdCkoe30scVtiXSxaKX0pLHRoaXNbaF1bMF0ub2Zmc2V0IT09MCYmdGhpc1toXS51bnNoaWZ0KCgwLG8uZGVmYXVsdCkoe30sdGhpc1tiXSx7b2Zmc2V0OjB9KSksRy5vZmZzZXQ8MSYmdGhpc1toXS5wdXNoKCgwLG8uZGVmYXVsdCkoe30sRyx7b2Zmc2V0OjF9KSksdGhpc1tMXT17fSx0aGlzLnRpbWVsaW5lPW51bGx9cmV0dXJuKDAseS5kZWZhdWx0KShqLFt7a2V5OiJwYXVzZSIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT0wfX0se2tleTpTLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEg9dGhpczt0aGlzW0VdJiYhdGhpc1tFXS50aW1lcklEJiYodGhpcy50aW1lbGluZS5jdXJyZW50VGltZTwwP3RoaXNbRV0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIW0VdLnJlc29sdmUoKSxkZWxldGUgSFtFXX0se2RlbGF5Oi10aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lLGhlYWRpbmc6ITF9KTp0aGlzW0VdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SFtFXS5yZXNvbHZlKCksZGVsZXRlIEhbRV19LHtkZWxheTowLGlzRW50cm9weTohMH0pKX19LHtrZXk6SSx2YWx1ZTpmdW5jdGlvbigpe3ZhciBIPXRoaXMsSj10aGlzW2FdLHE9Si5kdXJhdGlvbixGPUouaXRlcmF0aW9ucyxHPUouZW5kRGVsYXksWj1NYXRoLmNlaWwocSpGK0ctdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSkrMTt0aGlzW0FdJiYhdGhpc1tBXS50aW1lcklEJiYodGhpc1tBXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbQV0ucmVzb2x2ZSgpLEhbRF0oRSksSFtEXShBKX0se2RlbGF5OlosaGVhZGluZzohMX0pLHRoaXNbQV0ucmV2ZXJzZVRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SFtBXS5yZXNvbHZlKCksSFtEXShFKSxIW0RdKEEpLEgudGltZWxpbmU9bnVsbH0se2RlbGF5Oi10aGlzW2FdLmRlbGF5LTEsaGVhZGluZzohMX0pKX19LHtrZXk6InBsYXkiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5wbGF5U3RhdGU9PT0iZmluaXNoZWQiJiZ0aGlzLmNhbmNlbCgpLHRoaXMucGxheVN0YXRlPT09ImlkbGUiKXtpZih0aGlzLnBsYXliYWNrUmF0ZTw9MClyZXR1cm47dmFyIEg9dGhpc1thXSxKPUguZGVsYXkscT1ILnBsYXliYWNrUmF0ZSxGPUgudGltZWxpbmU7dGhpcy50aW1lbGluZT1uZXcgdi5kZWZhdWx0KHtvcmlnaW5UaW1lOkoscGxheWJhY2tSYXRlOnF9LEYpLHRoaXNbU10oKSx0aGlzW0ldKCl9ZWxzZSB0aGlzLnBsYXlTdGF0ZT09PSJwYXVzZWQiJiYodGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9dGhpcy5wbGF5YmFja1JhdGUsdGhpc1tTXSgpKX19LHtrZXk6RCx2YWx1ZTpmdW5jdGlvbihIKXt2YXIgSj10aGlzW0hdLHE9dGhpcy50aW1lbGluZTtKJiZxJiYocS5jbGVhclRpbWVvdXQoSi50aW1lcklEKSxKLnJldmVyc2VUaW1lcklEJiZxLmNsZWFyVGltZW91dChKLnJldmVyc2VUaW1lcklEKSksZGVsZXRlIHRoaXNbSF19fSx7a2V5OiJjYW5jZWwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpc1tEXShFKSx0aGlzW0RdKEEpLHRoaXMudGltZWxpbmU9bnVsbH19LHtrZXk6ImZpbmlzaCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnRpbWVsaW5lJiYodGhpcy50aW1lbGluZS5jdXJyZW50VGltZT0xLzAvdGhpcy5wbGF5YmFja1JhdGUpLHRoaXNbRF0oRSksdGhpc1tEXShBKX19LHtrZXk6ImFwcGx5RWZmZWN0cyIsdmFsdWU6ZnVuY3Rpb24oSCl7cmV0dXJuKDAsby5kZWZhdWx0KSh0aGlzW0xdLEgpfX0se2tleToicGxheWJhY2tSYXRlIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1thXS5wbGF5YmFja1JhdGV9LHNldDpmdW5jdGlvbihIKXt0aGlzLnRpbWVsaW5lJiYodGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9SCksdGhpc1thXS5wbGF5YmFja1JhdGU9SH19LHtrZXk6InBsYXlTdGF0ZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEg9dGhpcy50aW1lbGluZSxKPXRoaXNbYV0scT1KLml0ZXJhdGlvbnMsRj1KLmR1cmF0aW9uLEc9Si5lbmREZWxheSxaPSJydW5uaW5nIjtpZihIPT1udWxsKVo9ImlkbGUiO2Vsc2UgaWYoSC5wYXVzZWQpWj0icGF1c2VkIjtlbHNlIGlmKEguY3VycmVudFRpbWU8MClaPSJwZW5kaW5nIjtlbHNle3ZhciB0dD1ILmN1cnJlbnRUaW1lLXEqRjt0dD4wJiZ0dDxHP1o9InBlbmRpbmciOnR0Pj1HJiYoWj0iZmluaXNoZWQiKX1yZXR1cm4gWn19LHtrZXk6InByb2dyZXNzIixnZXQ6ZnVuY3Rpb24oKXtpZighdGhpcy50aW1lbGluZSlyZXR1cm4gMDt2YXIgSD10aGlzW2FdLEo9SC5kdXJhdGlvbixxPUguaXRlcmF0aW9ucyxGPXRoaXMudGltZWxpbmUsRz10aGlzLnBsYXlTdGF0ZSxaPXZvaWQgMDtpZihHPT09ImlkbGUiKVo9MDtlbHNlIGlmKEc9PT0icGF1c2VkIiYmRi5jdXJyZW50VGltZTwwKVo9MDtlbHNlIGlmKEc9PT0icGVuZGluZyIpaWYoRi5jdXJyZW50VGltZTwwKVo9MDtlbHNle3ZhciB0dD1GLnNlZWtMb2NhbFRpbWUocSpKKTtaPSgwLFAucGVyaW9kaWNpdHkpKHR0LEopWzFdL0p9ZWxzZShHPT09InJ1bm5pbmcifHxHPT09InBhdXNlZCIpJiYoWj0oMCxQLnBlcmlvZGljaXR5KShGLmN1cnJlbnRUaW1lLEopWzFdL0opO3JldHVybiBHPT09ImZpbmlzaGVkIiYmKFo9KDAsUC5wZXJpb2RpY2l0eSkocSwxKVsxXSksWn19LHtrZXk6ImZyYW1lIixnZXQ6ZnVuY3Rpb24oKXt2YXIgSD10aGlzLnBsYXlTdGF0ZSxKPXRoaXNbYl0scT10aGlzW2FdLmZpbGw7aWYoSD09PSJpZGxlIilyZXR1cm4gSjt2YXIgRj10aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lLEc9dGhpc1toXS5zbGljZSgwKSxaPSgwLFAuZ2V0UHJvZ3Jlc3MpKHRoaXMudGltZWxpbmUsdGhpc1thXSx0aGlzLnByb2dyZXNzKSx0dD1aLnAsZXQ9Wi5pbnZlcnRlZCxpdD1KO3JldHVybiBGPDAmJkg9PT0icGVuZGluZyI/KHE9PT0iYmFja3dhcmRzInx8cT09PSJib3RoIikmJihpdD1ldD9HW0cubGVuZ3RoLTFdOkdbMF0pOihIIT09InBlbmRpbmciJiZIIT09ImZpbmlzaGVkInx8cT09PSJmb3J3YXJkcyJ8fHE9PT0iYm90aCIpJiYoaXQ9KDAsUC5nZXRDdXJyZW50RnJhbWUpKHRoaXNbYV0sRyx0aGlzW0xdLHR0KSksaXR9fSx7a2V5OiJ0aW1pbmciLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2FdfX0se2tleToiZWZmZWN0cyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbTF19fSx7a2V5OiJiYXNlVGltZWxpbmUiLHNldDpmdW5jdGlvbihIKXt0aGlzW2FdLnRpbWVsaW5lPUh9LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2FdLnRpbWVsaW5lfX0se2tleToicmVhZHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ucHJvbWlzZTp0aGlzLnRpbWVsaW5lJiZ0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPj0wJiZ0aGlzLnBsYXlTdGF0ZSE9PSJwYXVzZWQiP24uZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbRV09KDAsUC5kZWZlcikoKSx0aGlzLnRpbWVsaW5lJiZ0aGlzW1NdKCksdGhpc1tFXT90aGlzW0VdLnByb21pc2U6bi5kZWZhdWx0LnJlc29sdmUoKSl9fSx7a2V5OiJmaW5pc2hlZCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIj9uLmRlZmF1bHQucmVzb2x2ZSgpOih0aGlzW0FdfHwodGhpc1tBXT0oMCxQLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbSV0oKSksdGhpc1tBXS5wcm9taXNlKX19XSksan0oKTtlLmRlZmF1bHQ9Q30sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDE5MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTkzKSx0KDIwMiksdCgyMDMpLGQuZXhwb3J0cz10KDkyKS5Qcm9taXNlfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg4OSksbj10KDkxKSxzPXQoOTMpLGw9dCgxMjgpLGM9dCg5MCksbz10KDk4KSxmPXQoOTQpLHg9dCgxNDcpLGc9dCgxNDgpLHk9dCgxOTQpLG09dCgxOTUpLnNldCxUPXQoMTk3KSgpLE89dCgxOTgpLHY9dCgxOTkpLFA9dCgyMDApLGk9dCgyMDEpLHU9IlByb21pc2UiLGE9bi5UeXBlRXJyb3IsaD1uLnByb2Nlc3MsYj1oJiZoLnZlcnNpb25zLEU9YiYmYi52OHx8IiIsQT1uW3VdLEw9bChoKT09InByb2Nlc3MiLFM9ZnVuY3Rpb24oKXt9LEksRCxSLEMsaj1EPU8uZiwkPSEhZnVuY3Rpb24oKXt0cnl7dmFyIGV0PUEucmVzb2x2ZSgxKSxpdD0oZXQuY29uc3RydWN0b3I9e30pW3QoMTIyKSgic3BlY2llcyIpXT1mdW5jdGlvbihrKXtrKFMsUyl9O3JldHVybihMfHx0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50PT0iZnVuY3Rpb24iKSYmZXQudGhlbihTKWluc3RhbmNlb2YgaXQmJkUuaW5kZXhPZigiNi42IikhPT0wJiZQLmluZGV4T2YoIkNocm9tZS82NiIpPT09LTF9Y2F0Y2h7fX0oKSxIPWZ1bmN0aW9uKGV0KXt2YXIgaXQ7cmV0dXJuIG8oZXQpJiZ0eXBlb2YoaXQ9ZXQudGhlbik9PSJmdW5jdGlvbiI/aXQ6ITF9LEo9ZnVuY3Rpb24oZXQsaXQpe2lmKCFldC5fbil7ZXQuX249ITA7dmFyIGs9ZXQuX2M7VChmdW5jdGlvbigpe2Zvcih2YXIgaHQ9ZXQuX3YsZnQ9ZXQuX3M9PTEsQj0wLFc9ZnVuY3Rpb24oVil7dmFyIFg9ZnQ/Vi5vazpWLmZhaWwsTj1WLnJlc29sdmUsej1WLnJlamVjdCxwPVYuZG9tYWluLE0sdyxVO3RyeXtYPyhmdHx8KGV0Ll9oPT0yJiZHKGV0KSxldC5faD0xKSxYPT09ITA/TT1odDoocCYmcC5lbnRlcigpLE09WChodCkscCYmKHAuZXhpdCgpLFU9ITApKSxNPT09Vi5wcm9taXNlP3ooYSgiUHJvbWlzZS1jaGFpbiBjeWNsZSIpKToodz1IKE0pKT93LmNhbGwoTSxOLHopOk4oTSkpOnooaHQpfWNhdGNoKEspe3AmJiFVJiZwLmV4aXQoKSx6KEspfX07ay5sZW5ndGg+QjspVyhrW0IrK10pO2V0Ll9jPVtdLGV0Ll9uPSExLGl0JiYhZXQuX2gmJnEoZXQpfSl9fSxxPWZ1bmN0aW9uKGV0KXttLmNhbGwobixmdW5jdGlvbigpe3ZhciBpdD1ldC5fdixrPUYoZXQpLGh0LGZ0LEI7aWYoayYmKGh0PXYoZnVuY3Rpb24oKXtMP2guZW1pdCgidW5oYW5kbGVkUmVqZWN0aW9uIixpdCxldCk6KGZ0PW4ub251bmhhbmRsZWRyZWplY3Rpb24pP2Z0KHtwcm9taXNlOmV0LHJlYXNvbjppdH0pOihCPW4uY29uc29sZSkmJkIuZXJyb3ImJkIuZXJyb3IoIlVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbiIsaXQpfSksZXQuX2g9THx8RihldCk/MjoxKSxldC5fYT12b2lkIDAsayYmaHQuZSl0aHJvdyBodC52fSl9LEY9ZnVuY3Rpb24oZXQpe3JldHVybiBldC5faCE9PTEmJihldC5fYXx8ZXQuX2MpLmxlbmd0aD09PTB9LEc9ZnVuY3Rpb24oZXQpe20uY2FsbChuLGZ1bmN0aW9uKCl7dmFyIGl0O0w/aC5lbWl0KCJyZWplY3Rpb25IYW5kbGVkIixldCk6KGl0PW4ub25yZWplY3Rpb25oYW5kbGVkKSYmaXQoe3Byb21pc2U6ZXQscmVhc29uOmV0Ll92fSl9KX0sWj1mdW5jdGlvbihldCl7dmFyIGl0PXRoaXM7aXQuX2R8fChpdC5fZD0hMCxpdD1pdC5fd3x8aXQsaXQuX3Y9ZXQsaXQuX3M9MixpdC5fYXx8KGl0Ll9hPWl0Ll9jLnNsaWNlKCkpLEooaXQsITApKX0sdHQ9ZnVuY3Rpb24oZXQpe3ZhciBpdD10aGlzLGs7aWYoIWl0Ll9kKXtpdC5fZD0hMCxpdD1pdC5fd3x8aXQ7dHJ5e2lmKGl0PT09ZXQpdGhyb3cgYSgiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGYiKTsoaz1IKGV0KSk/VChmdW5jdGlvbigpe3ZhciBodD17X3c6aXQsX2Q6ITF9O3RyeXtrLmNhbGwoZXQscyh0dCxodCwxKSxzKFosaHQsMSkpfWNhdGNoKGZ0KXtaLmNhbGwoaHQsZnQpfX0pOihpdC5fdj1ldCxpdC5fcz0xLEooaXQsITEpKX1jYXRjaChodCl7Wi5jYWxsKHtfdzppdCxfZDohMX0saHQpfX19OyR8fChBPWZ1bmN0aW9uKGl0KXt4KHRoaXMsQSx1LCJfaCIpLGYoaXQpLEkuY2FsbCh0aGlzKTt0cnl7aXQocyh0dCx0aGlzLDEpLHMoWix0aGlzLDEpKX1jYXRjaChrKXtaLmNhbGwodGhpcyxrKX19LEk9ZnVuY3Rpb24oaXQpe3RoaXMuX2M9W10sdGhpcy5fYT12b2lkIDAsdGhpcy5fcz0wLHRoaXMuX2Q9ITEsdGhpcy5fdj12b2lkIDAsdGhpcy5faD0wLHRoaXMuX249ITF9LEkucHJvdG90eXBlPXQoMTQ2KShBLnByb3RvdHlwZSx7dGhlbjpmdW5jdGlvbihpdCxrKXt2YXIgaHQ9aih5KHRoaXMsQSkpO3JldHVybiBodC5vaz10eXBlb2YgaXQ9PSJmdW5jdGlvbiI/aXQ6ITAsaHQuZmFpbD10eXBlb2Ygaz09ImZ1bmN0aW9uIiYmayxodC5kb21haW49TD9oLmRvbWFpbjp2b2lkIDAsdGhpcy5fYy5wdXNoKGh0KSx0aGlzLl9hJiZ0aGlzLl9hLnB1c2goaHQpLHRoaXMuX3MmJkoodGhpcywhMSksaHQucHJvbWlzZX0sY2F0Y2g6ZnVuY3Rpb24oZXQpe3JldHVybiB0aGlzLnRoZW4odm9pZCAwLGV0KX19KSxSPWZ1bmN0aW9uKCl7dmFyIGV0PW5ldyBJO3RoaXMucHJvbWlzZT1ldCx0aGlzLnJlc29sdmU9cyh0dCxldCwxKSx0aGlzLnJlamVjdD1zKFosZXQsMSl9LE8uZj1qPWZ1bmN0aW9uKGV0KXtyZXR1cm4gZXQ9PT1BfHxldD09PUM/bmV3IFIoZXQpOkQoZXQpfSksYyhjLkcrYy5XK2MuRiohJCx7UHJvbWlzZTpBfSksdCgxMjEpKEEsdSksdCgxNDkpKHUpLEM9dCg5MilbdV0sYyhjLlMrYy5GKiEkLHUse3JlamVjdDpmdW5jdGlvbihpdCl7dmFyIGs9aih0aGlzKSxodD1rLnJlamVjdDtyZXR1cm4gaHQoaXQpLGsucHJvbWlzZX19KSxjKGMuUytjLkYqKHJ8fCEkKSx1LHtyZXNvbHZlOmZ1bmN0aW9uKGl0KXtyZXR1cm4gaShyJiZ0aGlzPT09Qz9BOnRoaXMsaXQpfX0pLGMoYy5TK2MuRiohKCQmJnQoMTQwKShmdW5jdGlvbihldCl7QS5hbGwoZXQpLmNhdGNoKFMpfSkpLHUse2FsbDpmdW5jdGlvbihpdCl7dmFyIGs9dGhpcyxodD1qKGspLGZ0PWh0LnJlc29sdmUsQj1odC5yZWplY3QsVz12KGZ1bmN0aW9uKCl7dmFyIFY9W10sWD0wLE49MTtnKGl0LCExLGZ1bmN0aW9uKHope3ZhciBwPVgrKyxNPSExO1YucHVzaCh2b2lkIDApLE4rKyxrLnJlc29sdmUoeikudGhlbihmdW5jdGlvbih3KXtNfHwoTT0hMCxWW3BdPXcsLS1OfHxmdChWKSl9LEIpfSksLS1OfHxmdChWKX0pO3JldHVybiBXLmUmJkIoVy52KSxodC5wcm9taXNlfSxyYWNlOmZ1bmN0aW9uKGl0KXt2YXIgaz10aGlzLGh0PWooayksZnQ9aHQucmVqZWN0LEI9dihmdW5jdGlvbigpe2coaXQsITEsZnVuY3Rpb24oVyl7ay5yZXNvbHZlKFcpLnRoZW4oaHQucmVzb2x2ZSxmdCl9KX0pO3JldHVybiBCLmUmJmZ0KEIudiksaHQucHJvbWlzZX19KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoOTcpLG49dCg5NCkscz10KDEyMikoInNwZWNpZXMiKTtkLmV4cG9ydHM9ZnVuY3Rpb24obCxjKXt2YXIgbz1yKGwpLmNvbnN0cnVjdG9yLGY7cmV0dXJuIG89PT12b2lkIDB8fChmPXIobylbc10pPT1udWxsP2M6bihmKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkzKSxuPXQoMTk2KSxzPXQoMTIwKSxsPXQoMTAyKSxjPXQoOTEpLG89Yy5wcm9jZXNzLGY9Yy5zZXRJbW1lZGlhdGUseD1jLmNsZWFySW1tZWRpYXRlLGc9Yy5NZXNzYWdlQ2hhbm5lbCx5PWMuRGlzcGF0Y2gsbT0wLFQ9e30sTz0ib25yZWFkeXN0YXRlY2hhbmdlIix2LFAsaSx1PWZ1bmN0aW9uKCl7dmFyIGg9K3RoaXM7aWYoVC5oYXNPd25Qcm9wZXJ0eShoKSl7dmFyIGI9VFtoXTtkZWxldGUgVFtoXSxiKCl9fSxhPWZ1bmN0aW9uKGgpe3UuY2FsbChoLmRhdGEpfTsoIWZ8fCF4KSYmKGY9ZnVuY3Rpb24oYil7Zm9yKHZhciBFPVtdLEE9MTthcmd1bWVudHMubGVuZ3RoPkE7KUUucHVzaChhcmd1bWVudHNbQSsrXSk7cmV0dXJuIFRbKyttXT1mdW5jdGlvbigpe24odHlwZW9mIGI9PSJmdW5jdGlvbiI/YjpGdW5jdGlvbihiKSxFKX0sdihtKSxtfSx4PWZ1bmN0aW9uKGIpe2RlbGV0ZSBUW2JdfSx0KDg2KShvKT09InByb2Nlc3MiP3Y9ZnVuY3Rpb24oaCl7by5uZXh0VGljayhyKHUsaCwxKSl9OnkmJnkubm93P3Y9ZnVuY3Rpb24oaCl7eS5ub3cocih1LGgsMSkpfTpnPyhQPW5ldyBnLGk9UC5wb3J0MixQLnBvcnQxLm9ubWVzc2FnZT1hLHY9cihpLnBvc3RNZXNzYWdlLGksMSkpOmMuYWRkRXZlbnRMaXN0ZW5lciYmdHlwZW9mIHBvc3RNZXNzYWdlPT0iZnVuY3Rpb24iJiYhYy5pbXBvcnRTY3JpcHRzPyh2PWZ1bmN0aW9uKGgpe2MucG9zdE1lc3NhZ2UoaCsiIiwiKiIpfSxjLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGEsITEpKTpPIGluIGwoInNjcmlwdCIpP3Y9ZnVuY3Rpb24oaCl7cy5hcHBlbmRDaGlsZChsKCJzY3JpcHQiKSlbT109ZnVuY3Rpb24oKXtzLnJlbW92ZUNoaWxkKHRoaXMpLHUuY2FsbChoKX19OnY9ZnVuY3Rpb24oaCl7c2V0VGltZW91dChyKHUsaCwxKSwwKX0pLGQuZXhwb3J0cz17c2V0OmYsY2xlYXI6eH19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQscixuKXt2YXIgcz1uPT09dm9pZCAwO3N3aXRjaChyLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBzP3QoKTp0LmNhbGwobik7Y2FzZSAxOnJldHVybiBzP3QoclswXSk6dC5jYWxsKG4sclswXSk7Y2FzZSAyOnJldHVybiBzP3QoclswXSxyWzFdKTp0LmNhbGwobixyWzBdLHJbMV0pO2Nhc2UgMzpyZXR1cm4gcz90KHJbMF0sclsxXSxyWzJdKTp0LmNhbGwobixyWzBdLHJbMV0sclsyXSk7Y2FzZSA0OnJldHVybiBzP3QoclswXSxyWzFdLHJbMl0sclszXSk6dC5jYWxsKG4sclswXSxyWzFdLHJbMl0sclszXSl9cmV0dXJuIHQuYXBwbHkobixyKX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkxKSxuPXQoMTk1KS5zZXQscz1yLk11dGF0aW9uT2JzZXJ2ZXJ8fHIuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixsPXIucHJvY2VzcyxjPXIuUHJvbWlzZSxvPXQoODYpKGwpPT0icHJvY2VzcyI7ZC5leHBvcnRzPWZ1bmN0aW9uKCl7dmFyIGYseCxnLHk9ZnVuY3Rpb24oKXt2YXIgdixQO2ZvcihvJiYodj1sLmRvbWFpbikmJnYuZXhpdCgpO2Y7KXtQPWYuZm4sZj1mLm5leHQ7dHJ5e1AoKX1jYXRjaChpKXt0aHJvdyBmP2coKTp4PXZvaWQgMCxpfX14PXZvaWQgMCx2JiZ2LmVudGVyKCl9O2lmKG8pZz1mdW5jdGlvbigpe2wubmV4dFRpY2soeSl9O2Vsc2UgaWYocyYmIShyLm5hdmlnYXRvciYmci5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpe3ZhciBtPSEwLFQ9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIiIpO25ldyBzKHkpLm9ic2VydmUoVCx7Y2hhcmFjdGVyRGF0YTohMH0pLGc9ZnVuY3Rpb24oKXtULmRhdGE9bT0hbX19ZWxzZSBpZihjJiZjLnJlc29sdmUpe3ZhciBPPWMucmVzb2x2ZSh2b2lkIDApO2c9ZnVuY3Rpb24oKXtPLnRoZW4oeSl9fWVsc2UgZz1mdW5jdGlvbigpe24uY2FsbChyLHkpfTtyZXR1cm4gZnVuY3Rpb24odil7dmFyIFA9e2ZuOnYsbmV4dDp2b2lkIDB9O3gmJih4Lm5leHQ9UCksZnx8KGY9UCxnKCkpLHg9UH19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5NCk7ZnVuY3Rpb24gbihzKXt2YXIgbCxjO3RoaXMucHJvbWlzZT1uZXcgcyhmdW5jdGlvbihvLGYpe2lmKGwhPT12b2lkIDB8fGMhPT12b2lkIDApdGhyb3cgVHlwZUVycm9yKCJCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvciIpO2w9byxjPWZ9KSx0aGlzLnJlc29sdmU9cihsKSx0aGlzLnJlamVjdD1yKGMpfWQuZXhwb3J0cy5mPWZ1bmN0aW9uKHMpe3JldHVybiBuZXcgbihzKX19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm57ZTohMSx2OnQoKX19Y2F0Y2gocil7cmV0dXJue2U6ITAsdjpyfX19fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5MSksbj1yLm5hdmlnYXRvcjtkLmV4cG9ydHM9biYmbi51c2VyQWdlbnR8fCIifSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5Nyksbj10KDk4KSxzPXQoMTk4KTtkLmV4cG9ydHM9ZnVuY3Rpb24obCxjKXtpZihyKGwpLG4oYykmJmMuY29uc3RydWN0b3I9PT1sKXJldHVybiBjO3ZhciBvPXMuZihsKSxmPW8ucmVzb2x2ZTtyZXR1cm4gZihjKSxvLnByb21pc2V9fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCg5MCksbj10KDkyKSxzPXQoOTEpLGw9dCgxOTQpLGM9dCgyMDEpO3Ioci5QK3IuUiwiUHJvbWlzZSIse2ZpbmFsbHk6ZnVuY3Rpb24obyl7dmFyIGY9bCh0aGlzLG4uUHJvbWlzZXx8cy5Qcm9taXNlKSx4PXR5cGVvZiBvPT0iZnVuY3Rpb24iO3JldHVybiB0aGlzLnRoZW4oeD9mdW5jdGlvbihnKXtyZXR1cm4gYyhmLG8oKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBnfSl9Om8seD9mdW5jdGlvbihnKXtyZXR1cm4gYyhmLG8oKSkudGhlbihmdW5jdGlvbigpe3Rocm93IGd9KX06byl9fSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKSxuPXQoMTk4KSxzPXQoMTk5KTtyKHIuUywiUHJvbWlzZSIse3RyeTpmdW5jdGlvbihsKXt2YXIgYz1uLmYodGhpcyksbz1zKGwpO3JldHVybihvLmU/Yy5yZWplY3Q6Yy5yZXNvbHZlKShvLnYpLGMucHJvbWlzZX19KX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz17ZGVmYXVsdDp0KDIwNSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGQsZSx0KXt0KDIwNiksZC5leHBvcnRzPXQoOTIpLk9iamVjdC5rZXlzfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgxMjQpLG49dCgxMTApO3QoMjA3KSgia2V5cyIsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24obCl7cmV0dXJuIG4ocihsKSl9fSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKSxuPXQoOTIpLHM9dCgxMDEpO2QuZXhwb3J0cz1mdW5jdGlvbihsLGMpe3ZhciBvPShuLk9iamVjdHx8e30pW2xdfHxPYmplY3RbbF0sZj17fTtmW2xdPWMobykscihyLlMrci5GKnMoZnVuY3Rpb24oKXtvKDEpfSksIk9iamVjdCIsZil9fSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXQoNzYpLG49VChyKSxzPXQoMjA5KSxsPVQocyksYz10KDE2NCksbz1UKGMpLGY9dCgxOTEpLHg9VChmKTtlLmRlZmVyPU8sZS5wZXJpb2RpY2l0eT12LGUuY2FsY3VsYXRlRnJhbWVzT2Zmc2V0PVAsZS5nZXRQcm9ncmVzcz1pLGUuZ2V0Q3VycmVudEZyYW1lPWE7dmFyIGc9dCgxODgpLHk9dCgxODcpLG09VCh5KTtmdW5jdGlvbiBUKGgpe3JldHVybiBoJiZoLl9fZXNNb2R1bGU/aDp7ZGVmYXVsdDpofX1mdW5jdGlvbiBPKCl7dmFyIGg9e307cmV0dXJuIGgucHJvbWlzZT1uZXcgeC5kZWZhdWx0KGZ1bmN0aW9uKGIsRSl7aC5yZXNvbHZlPWIsaC5yZWplY3Q9RX0pLGh9ZnVuY3Rpb24gdihoLGIpe3ZhciBFPU1hdGguZmxvb3IoaC9iKSxBPWgtRSpiO3JldHVybiBBPT09MCYmRT4wJiYoQT1iLEUtLSksW0UsQV19ZnVuY3Rpb24gUChoKXtoPWguc2xpY2UoMCk7dmFyIGI9aFswXSxFPWhbaC5sZW5ndGgtMV07RS5vZmZzZXQ9RS5vZmZzZXR8fDEsYi5vZmZzZXQ9Yi5vZmZzZXR8fDA7Zm9yKHZhciBBPTAsTD0tMSxTPTA7UzxoLmxlbmd0aDtTKyspe3ZhciBJPWhbU107aWYoSS5vZmZzZXQhPW51bGwpe3ZhciBEPVMtTDtpZihEPjEpZm9yKHZhciBSPShJLm9mZnNldC1BKS9ELEM9MDtDPEQtMTtDKyspaFtMK0MrMV0ub2Zmc2V0PUErUiooQysxKTtBPUkub2Zmc2V0LEw9U31pZihJLmVhc2luZyE9bnVsbCYmKEkuZWFzaW5nPSgwLGcucGFyc2VFYXNpbmcpKEkuZWFzaW5nKSksUz4wKXt2YXIgaj1oW1NdLmVhc2luZyE9bnVsbDtoW1NdPSgwLG8uZGVmYXVsdCkoe30saFtTLTFdLGhbU10pLGp8fGRlbGV0ZSBoW1NdLmVhc2luZ319cmV0dXJuIGh9ZnVuY3Rpb24gaShoLGIsRSl7dmFyIEE9aC5jdXJyZW50VGltZSxMPWIuZGlyZWN0aW9uLFM9Yi5kdXJhdGlvbixJPSExO2lmKEw9PT0icmV2ZXJzZSIpRT0xLUUsST0hMDtlbHNlIGlmKEw9PT0iYWx0ZXJuYXRlInx8TD09PSJhbHRlcm5hdGUtcmV2ZXJzZSIpe3ZhciBEPU1hdGguZmxvb3IoQS9TKTtFPT09MSYmRC0tLEQlMl5MPT09ImFsdGVybmF0ZS1yZXZlcnNlIiYmKEU9MS1FLEk9ITApfXJldHVybntwOkUsaW52ZXJ0ZWQ6SX19ZnVuY3Rpb24gdShoLGIsRSxBKXt2YXIgTD17fTtyZXR1cm4oMCxsLmRlZmF1bHQpKGIpLmZvckVhY2goZnVuY3Rpb24oUyl7dmFyIEk9KDAsbi5kZWZhdWx0KShTLDIpLEQ9SVswXSxSPUlbMV07aWYoRCE9PSJvZmZzZXQiJiZEIT09ImVhc2luZyIpe3ZhciBDPUVbRF18fEUuZGVmYXVsdCxqPUMoaFtEXSxSLEEsaC5vZmZzZXQsYi5vZmZzZXQpO2ohPW51bGwmJihMW0RdPWopfX0pLEx9ZnVuY3Rpb24gYShoLGIsRSxBKXt2YXIgTD1oLmVhc2luZyxTPWguZWZmZWN0O1N8fChFPSgwLG8uZGVmYXVsdCkoe30sbS5kZWZhdWx0LEUpKTt2YXIgST17fTtBPUwoQSxiKTtmb3IodmFyIEQ9MTtEPGIubGVuZ3RoO0QrKyl7dmFyIFI9YltEXSxDPVIub2Zmc2V0O2lmKEM+PUF8fEQ9PT1iLmxlbmd0aC0xKXt2YXIgaj1iW0QtMV0sJD1qLm9mZnNldCxIPWouZWFzaW5nLEo9QTtpZihIKXt2YXIgcT1DLSQ7Sj1IKChBLSQpL3EpKnErJH1TP0k9UyhqLFIsSiwkLEMpOkk9dShqLFIsRSxKKTticmVha319cmV0dXJuIEl9fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXtkZWZhdWx0OnQoMjEwKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oZCxlLHQpe3QoMjExKSxkLmV4cG9ydHM9dCg5MikuT2JqZWN0LmVudHJpZXN9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDkwKSxuPXQoMjEyKSghMCk7cihyLlMsIk9iamVjdCIse2VudHJpZXM6ZnVuY3Rpb24obCl7cmV0dXJuIG4obCl9fSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDEwMCksbj10KDExMCkscz10KDg0KSxsPXQoMTY5KS5mO2QuZXhwb3J0cz1mdW5jdGlvbihjKXtyZXR1cm4gZnVuY3Rpb24obyl7Zm9yKHZhciBmPXMobykseD1uKGYpLGc9eC5sZW5ndGgseT0wLG09W10sVDtnPnk7KVQ9eFt5KytdLCghcnx8bC5jYWxsKGYsVCkpJiZtLnB1c2goYz9bVCxmW1RdXTpmW1RdKTtyZXR1cm4gbX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPW5ldyBNYXA7ZnVuY3Rpb24gbihsLGM9e30sbz1bXSl7bD1sLnRvTG93ZXJDYXNlKCk7Y29uc3QgZj1yLmdldChsKTtpZighZil0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG5vZGU6ICR7bH1gKTtjb25zdCB4PW5ldyBmKGMpO3JldHVybiBvLmZvckVhY2goZz0+e3guYXBwZW5kQ2hpbGQoZyl9KSx4fWNvbnN0IHM9e3JlZ2lzdGVyTm9kZShsLGMsbz0xMDApe2lmKGM9Yy50b0xvd2VyQ2FzZSgpLHIuaGFzKGMpKXRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCByZWdpc3Rlck5vZGUsICR7Y30gaGFzIGJlZW4gdGFrZW4uYCk7ci5zZXQoYyxsKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsLnByb3RvdHlwZSx7bm9kZVR5cGU6e3ZhbHVlOm99LHRhZ05hbWU6e3ZhbHVlOmMudG9VcHBlckNhc2UoKX0sbm9kZU5hbWU6e3ZhbHVlOmN9LG93bmVyRG9jdW1lbnQ6e3ZhbHVlOnN9LG5hbWVzcGFjZVVSSTp7dmFsdWU6YGh0dHA6Ly9zcHJpdGVqcy5jb20vJHtjfWB9fSl9LGNyZWF0ZUVsZW1lbnQ6bixjcmVhdGVFbGVtZW50TlMobCxjKXtyZXR1cm4gbihjKX0saXNTcHJpdGVOb2RlKGwpe3JldHVybiByLmhhcyhsLnRvTG93ZXJDYXNlKCkpfX07ZS5kZWZhdWx0PXN9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcj1TeW1ib2woInR5cGUiKSxuPVN5bWJvbCgiYnViYmxlcyIpLHM9U3ltYm9sKCJvcmlnaW5hbEV2ZW50IiksbD1TeW1ib2woImRldGFpbCIpO2NsYXNzIGN7Y29uc3RydWN0b3IoZix7YnViYmxlczp4PW51bGx9PXt9KXtpZih0eXBlb2YgZj09InN0cmluZyI/KHRoaXNbcl09Zix0aGlzW25dPSEheCk6KHRoaXNbcl09Zi50eXBlLHRoaXNbc109Zix0aGlzW25dPXghPW51bGw/ISF4OiEhZi5idWJibGVzLGYuZGV0YWlsJiYodGhpc1tsXT1mLmRldGFpbCkpLCF0aGlzW3JdKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZXZlbnQgdHlwZS4iKTt0aGlzLmNhbmNlbEJ1YmJsZT0hMX1zZXRPcmlnaW5hbEV2ZW50KGYpe3RoaXNbc109Zn1nZXQgb3JpZ2luYWxFdmVudCgpe3JldHVybiB0aGlzW3NdfWdldCB0eXBlKCl7cmV0dXJuIHRoaXNbcl19Z2V0IGJ1YmJsZXMoKXtyZXR1cm4gdGhpc1tuXX1nZXQgZGV0YWlsKCl7cmV0dXJuIHRoaXNbbF19c3RvcFByb3BhZ2F0aW9uKCl7dGhpcy5jYW5jZWxCdWJibGU9ITB9fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwicGFyc2VGaWx0ZXJTdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiYXBwbHlGaWx0ZXJzIixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIHI9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4obCl7aWYobD1sLnRyaW0oKSwhbHx8bD09PSJub25lIilyZXR1cm4gbnVsbDtjb25zdCBjPS9eKD86KHVybHxibHVyfGJyaWdodG5lc3N8Y29udHJhc3R8ZHJvcC1zaGFkb3d8Z3JheXNjYWxlfGh1ZS1yb3RhdGV8aW52ZXJ0fG9wYWNpdHl8c2F0dXJhdGV8c2VwaWEpXCgoW14oKV0qKD86XCguKlwpKSpbXigpXSopXCkpKyQvaSxvPWwubWF0Y2goLyg/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSs/L2lnKSxmPVtdO3JldHVybiBvJiZvLmZvckVhY2goeD0+e2NvbnN0IGc9eC5tYXRjaChjKTtpZighZyl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGZpdGxlciBzdHJpbmcuIik7bGV0Wyx5LG1dPWc7eT15LnRvTG93ZXJDYXNlKCksbT1tLnRyaW0oKS5tYXRjaCgvKFteKCApXSt8KFteKCApXStcKC4qXCkpKSg/PVxzfCQpL2cpLm1hcCgoVCxPKT0+e2xldCB2O3JldHVybiB5PT09InVybCJ8fHk9PT0iZHJvcC1zaGFkb3ciJiZPPT09Mz92PVQ6dj1PYmplY3Qoci50b051bWJlcikoVCksLyUkLy50ZXN0KFQpJiYodi89MTAwKSx2fSksZi5wdXNoKHt0eXBlOnksYXJnczptfSl9KSxmfWZ1bmN0aW9uIHMobCxjKXtsLmNsZWFyRmlsdGVyKCksYyYmYy5mb3JFYWNoKCh7dHlwZTpvLGFyZ3M6Zn0pPT57bGV0IHg9bzt4PT09ImRyb3Atc2hhZG93Ij94PSJkcm9wU2hhZG93Ijp4PT09Imh1ZS1yb3RhdGUiJiYoeD0iaHVlUm90YXRlIiksbFt4XSguLi5mKX0pfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG4scyl7aWYoIXMpcmV0dXJuO2NvbnN0IGw9bi5nZXRMaXN0ZW5lcnMoImJlZm9yZXJlbmRlciIpLGM9bi5nZXRMaXN0ZW5lcnMoImFmdGVycmVuZGVyIik7bC5sZW5ndGgmJiFzLmJlZm9yZVJlbmRlcj9zLmJlZm9yZVJlbmRlcj1vPT57bi5kaXNwYXRjaEV2ZW50KHt0eXBlOiJiZWZvcmVyZW5kZXIiLGRldGFpbDp7Y29udGV4dDpvfX0pfTpsLmxlbmd0aHx8KHMuYmVmb3JlUmVuZGVyPW51bGwpLGMubGVuZ3RoJiYhcy5hZnRlclJlbmRlcj9zLmFmdGVyUmVuZGVyPW89PntuLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImFmdGVycmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6b319KX06Yy5sZW5ndGh8fChzLmFmdGVyUmVuZGVyPW51bGwpfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMTIpLG49dCgyMTgpLHM9dCg3MCksbD10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9U3ltYm9sKCJhbW91bnQiKSxvPVN5bWJvbCgibWVzaENsb3VkIik7Y2xhc3MgZiBleHRlbmRzIHMuZGVmYXVsdHtjb25zdHJ1Y3RvcihnLHk9MSl7c3VwZXIoKSx0aGlzLm1lc2hOb2RlPWcsZy5jb25uZWN0KHRoaXMpLHRoaXNbY109eSx0aGlzW29dPW51bGx9Z2V0IG1lc2hDbG91ZCgpe2NvbnN0IGc9dGhpcy5tZXNoTm9kZSx5PXRoaXNbY107cmV0dXJuIXRoaXNbb10mJmcubWVzaCYmKHRoaXNbb109bmV3IHIuTWVzaENsb3VkKGcubWVzaCx5KSksdGhpc1tvXX1nZXQgaXNWaXNpYmxlKCl7cmV0dXJuISF0aGlzLm1lc2hOb2RlJiZ0aGlzLm1lc2hOb2RlLmlzVmlzaWJsZX1nZXQgYW1vdW50KCl7cmV0dXJuIHRoaXNbY119c2V0IGFtb3VudChnKXt0aGlzW2NdPWcsdGhpc1tvXSYmKHRoaXNbb10uYW1vdW50PWcpfWJyaWdodG5lc3MoZyx5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmJyaWdodG5lc3MoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWNvbnRyYXN0KGcseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5jb250cmFzdChnLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9ZGVsZXRlKGcpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuZGVsZXRlKGcpLHRoaXNbY10tLSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRyYXcoZz1bXSl7aWYoc3VwZXIuZHJhdyhnKSx0aGlzLm1lc2hDbG91ZCl7aWYodGhpcy5wcm9ncmFtKXt0aGlzLm1lc2hDbG91ZC5zZXRQcm9ncmFtKHRoaXMucHJvZ3JhbSk7Y29uc3QgeT10aGlzLnNoYWRlckF0dHJzO3kmJk9iamVjdC5lbnRyaWVzKHkpLmZvckVhY2goKFtULE9dKT0+e3RoaXMubWVzaENsb3VkLm1lc2guc2V0QXR0cmlidXRlKFQsTyl9KTtjb25zdCBtPXRoaXMudW5pZm9ybXM7aWYodGhpcy51bmlmb3Jtcyl7Y29uc3QgVD17fTtPYmplY3QuZW50cmllcyhtKS5mb3JFYWNoKChbTyx2XSk9Pnt0eXBlb2Ygdj09ImZ1bmN0aW9uIiYmKHY9dih0aGlzLE8pKSxUW09dPXZ9KSx0aGlzLm1lc2hDbG91ZC5tZXNoLnNldFVuaWZvcm1zKFQpfX10aGlzLm1lc2hOb2RlLnRleHR1cmVJbWFnZSYmT2JqZWN0KG4uZHJhd1RleHR1cmUpKHRoaXMubWVzaE5vZGUsdGhpcy5tZXNoTm9kZS5tZXNoKSxnLnB1c2godGhpcy5tZXNoQ2xvdWQpfXJldHVybiBnfWdldFRyYW5zZm9ybShnKXtpZih0aGlzLm1lc2hDbG91ZClyZXR1cm4gdGhpcy5tZXNoQ2xvdWQuZ2V0VHJhbnNmb3JtKGcpfWdyYXlzY2FsZShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuZ3JheXNjYWxlKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1odWVSb3RhdGUoZyx5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmh1ZVJvdGF0ZShnLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9aW52ZXJ0KGcseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5pbnZlcnQoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWlzUG9pbnRDb2xsaXNpb24oZyx5KXtpZighdGhpcy5tZXNoQ2xvdWQpcmV0dXJuITE7Y29uc3QgbT10aGlzLmF0dHJpYnV0ZXMucG9pbnRlckV2ZW50cztpZihtPT09Im5vbmUifHxtIT09ImFsbCImJiF0aGlzLmlzVmlzaWJsZSlyZXR1cm4hMTtsZXQgVD0iYm90aCI7bT09PSJ2aXNpYmxlRmlsbCImJihUPSJmaWxsIiksbT09PSJ2aXNpYmxlU3Ryb2tlIiYmKFQ9InN0cm9rZSIpO2ZvcihsZXQgTz0wO088dGhpc1tjXTtPKyspaWYoIXRoaXMubWVzaENsb3VkLmlzUG9pbnRDb2xsaXNpb24oTyxbZyx5XSxUKSlyZXR1cm4hMTtyZXR1cm4hMH1zZXRPcGFjaXR5KGcseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5vcGFjaXR5KGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1yb3RhdGUoZyx5LFttLFRdPVswLDBdKXtjb25zdCBPPU1hdGguUEkqeS8xODA7aWYodGhpcy5tZXNoQ2xvdWQpe2NvbnN0e3g6dix5OlB9PXRoaXMubWVzaE5vZGUuYXR0cmlidXRlczt0aGlzLm1lc2hDbG91ZC5yb3RhdGUoZyxPLFttK3YsVCtQXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX1zYXR1cmF0ZShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2F0dXJhdGUoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNjYWxlKGcsW3ksbT15XSxbVCxPXT1bMCwwXSl7aWYodGhpcy5tZXNoQ2xvdWQpe2NvbnN0e3g6dix5OlB9PXRoaXMubWVzaE5vZGUuYXR0cmlidXRlcyxpPTFlLTU7TWF0aC5hYnMoeSk8aSYmKHk9MS95PjA/aTotaSksTWF0aC5hYnMobSk8aSYmKG09MS9tPjA/aTotaSksdGhpcy5tZXNoQ2xvdWQuc2NhbGUoZyxbeSxtXSxbVCt2LE8rUF0pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2V0Q29sb3JUcmFuc2Zvcm0oZyx5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldENvbG9yVHJhbnNmb3JtKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRGaWxsQ29sb3IoZyx5KXt0aGlzLm1lc2hDbG91ZCYmKEFycmF5LmlzQXJyYXkoeSkmJih5PVsuLi55XSx5WzBdLz0yNTUseVsxXS89MjU1LHlbMl0vPTI1NSksdGhpcy5tZXNoQ2xvdWQuc2V0RmlsbENvbG9yKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXBpYShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2VwaWEoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNldFJlc29sdXRpb24oe3dpZHRoOmcsaGVpZ2h0Onl9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpnLGhlaWdodDp5fSksdGhpcy5tZXNoTm9kZS5zZXRSZXNvbHV0aW9uKHt3aWR0aDpnLGhlaWdodDp5fSl9c2V0U3Ryb2tlQ29sb3IoZyx5KXt0aGlzLm1lc2hDbG91ZCYmKEFycmF5LmlzQXJyYXkoeSkmJih5PVsuLi55XSx5WzBdLz0yNTUseVsxXS89MjU1LHlbMl0vPTI1NSksdGhpcy5tZXNoQ2xvdWQuc2V0U3Ryb2tlQ29sb3IoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNldFRyYW5zZm9ybShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2V0VHJhbnNmb3JtKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1za2V3KGcsW3ksbT15XSxbVCxPXT1bMCwwXSl7aWYodGhpcy5tZXNoQ2xvdWQpe2NvbnN0e3g6dix5OlB9PXRoaXMubWVzaE5vZGUuYXR0cmlidXRlczt0aGlzLm1lc2hDbG91ZC5za2V3KGcsW3ksbV0sW1QrdixPK1BdKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXRyYW5zZm9ybShnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQudHJhbnNmb3JtKGcseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2Zvcm1Db2xvcihnLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQudHJhbnNmb3JtQ29sb3IoZyx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRyYW5zbGF0ZShnLFt5LG1dKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zbGF0ZShnLFt5LG1dKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXVwZGF0ZU1lc2goKXt0aGlzW29dJiYodGhpc1tvXS5tZXNoPXRoaXMubWVzaE5vZGUubWVzaCx0aGlzLmZvcmNlVXBkYXRlKCkpfX1sLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGYsImNsb3VkIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImxvYWRUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImFwcGx5VGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJjcmVhdGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImRlbGV0ZVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZHJhd1RleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwibG9hZEZyYW1lcyIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pO3ZhciByPXQoMTIpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9e307ZnVuY3Rpb24gbChULE8pe2lmKHNbVF0pcmV0dXJuIHNbVF07Y29uc3Qgdj1yLkVOVi5sb2FkSW1hZ2UoVCx7YWxpYXM6Tyx1c2VJbWFnZUJpdG1hcDohMX0pO3JldHVybiB2Pz9UfWFzeW5jIGZ1bmN0aW9uIGMoVCxPLHYpe2xldCBQPU87aWYodHlwZW9mIE89PSJzdHJpbmciJiYoUD1sKE8pKSxQJiZ0eXBlb2YgUC50aGVuPT0iZnVuY3Rpb24iJiYoUD1hd2FpdCBQKSxPPT09VC5hdHRyaWJ1dGVzLnRleHR1cmUpe1AmJlAuaW1hZ2UmJihQLnNvdXJjZVJlY3QmJihULmF0dHJpYnV0ZXMuc291cmNlUmVjdD1QLnNvdXJjZVJlY3QpLFQudGV4dHVyZUltYWdlUm90YXRlZD0hIVAucm90YXRlZCxQPVAuaW1hZ2UpO2NvbnN0e3dpZHRoOmksaGVpZ2h0OnUsdGV4dHVyZVJlY3Q6YX09VC5hdHRyaWJ1dGVzLGg9VC50ZXh0dXJlSW1hZ2U7VC50ZXh0dXJlSW1hZ2U9UCx2JiZoIT09UCYmIWEmJihpPT1udWxsfHx1PT1udWxsKSYmVC51cGRhdGVDb250b3VycygpLFQuZm9yY2VVcGRhdGUoKX1yZXR1cm4gUH1jb25zdCBvPVN5bWJvbCgidGV4dHVyZU1hcCIpO2Z1bmN0aW9uIGYoVCxPKXtpZihPW29dPU9bb118fG5ldyBNYXAsT1tvXS5oYXMoVCkpcmV0dXJuIE9bb10uZ2V0KFQpO2NvbnN0IHY9Ty5jcmVhdGVUZXh0dXJlKFQpO3JldHVybiEvXmJsb2I6Ly50ZXN0KFQuc3JjKSYmdHlwZW9mIFQuZ2V0Q29udGV4dCE9ImZ1bmN0aW9uIiYmT1tvXS5zZXQoVCx2KSx2fWZ1bmN0aW9uIHgoVCxPKXtpZihPW29dJiZPW29dLmhhcyhUKSl7Y29uc3Qgdj1PW29dLmdldChUKTtyZXR1cm4gTy5kZWxldGVUZXh0dXJlKHYpLE9bb10uZGVsZXRlKFQpLCEwfXJldHVybiExfWNvbnN0IGc9U3ltYm9sKCJ0ZXh0dXJlQ29udGV4dCIpO2Z1bmN0aW9uIHkoVCxPKXtjb25zdCB2PVQudGV4dHVyZUltYWdlIGluc3RhbmNlb2YgU3RyaW5nP1N0cmluZyhULnRleHR1cmVJbWFnZSk6VC50ZXh0dXJlSW1hZ2UsUD1ULnRleHR1cmVJbWFnZVJvdGF0ZWQsaT1PLnRleHR1cmUsdT1ULnJlbmRlcmVyO2lmKHYpe2NvbnN0IGE9VC5vcmlnaW5hbENvbnRlbnRSZWN0O2xldCBoPVQuYXR0cmlidXRlcy50ZXh0dXJlUmVjdDtjb25zdCBiPVQuYXR0cmlidXRlcy50ZXh0dXJlUmVwZWF0LEU9VC5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYoIWl8fFRbZ10mJlRbZ10hPT11fHxpLmltYWdlIT09dnx8aS5vcHRpb25zLnJlcGVhdCE9PWJ8fCFPYmplY3Qobi5jb21wYXJlVmFsdWUpKGkub3B0aW9ucy5yZWN0LGgpfHwhT2JqZWN0KG4uY29tcGFyZVZhbHVlKShpLm9wdGlvbnMuc3JjUmVjdCxFKSl7Y29uc3QgQT1mKHYsdSk7aD8oaFswXSs9YVswXSxoWzFdKz1hWzFdKTpoPWE7bGV0IEw9bnVsbDtpJiYhdVtvXS5oYXMoaS5pbWFnZSkmJighaS5vcHRpb25zfHwhaS5vcHRpb25zLmhpZGRlbikmJihMPU8udW5pZm9ybXMudV90ZXhTYW1wbGVyKSxPLnNldFRleHR1cmUoQSx7cmVjdDpoLHJlcGVhdDpiLHNyY1JlY3Q6RSxyb3RhdGVkOlB9KSxMJiZMLmRlbGV0ZSYmTC5kZWxldGUoKSxUW2ddPXV9fWVsc2UgaWYoaSl7bGV0IGE9bnVsbDshdVtvXS5oYXMoaS5pbWFnZSkmJighaS5vcHRpb25zfHwhaS5vcHRpb25zLmhpZGRlbikmJihhPU8udW5pZm9ybXMudV90ZXhTYW1wbGVyKSxPLnNldFRleHR1cmUobnVsbCksYSYmYS5kZWxldGUmJmEuZGVsZXRlKCl9fWFzeW5jIGZ1bmN0aW9uIG0oVCxPKXt0eXBlb2YgTz09InN0cmluZyImJihPPWF3YWl0KGF3YWl0IGZldGNoKE8se21ldGhvZDoiR0VUIixtb2RlOiJjb3JzIixjYWNoZToiZGVmYXVsdCJ9KSkuanNvbigpKTtjb25zdCB2PWF3YWl0IGwoVCksUD1PLmZyYW1lcztyZXR1cm4gT2JqZWN0LmVudHJpZXMoUCkuZm9yRWFjaCgoW2ksdV0pPT57Y29uc3R7eDphLHk6aCx3OmIsaDpFfT11LmZyYW1lO2xldCBBPVthLGgsYixFXTtjb25zdCBMPXUucm90YXRlZDtMJiYoQT1bQVswXSxBWzFdLEFbM10sQVsyXV0pLHNbaV09e2ltYWdlOnYsc291cmNlUmVjdDpBLHJvdGF0ZWQ6TH19KSx2fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pO3ZhciByPXQoMSksbj10KDEyKSxzPXQoNzApLGw9dCgyMjApLGM9dCgyMjEpLG89dCgyMjIpLGY9dCgyMTMpLHg9dCgyMjMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKFQsTyx2KXtyZXR1cm4gTyBpbiBUP09iamVjdC5kZWZpbmVQcm9wZXJ0eShULE8se3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpUW09dPXYsVH1jb25zdCB5PVN5bWJvbCgibWVzaCIpO2NsYXNzIG0gZXh0ZW5kcyBzLmRlZmF1bHR7Y29uc3RydWN0b3IoTz17fSl7c3VwZXIoTyl9Z2V0IGJvcmRlclNpemUoKXtjb25zdHtwYWRkaW5nVG9wOk8scGFkZGluZ1JpZ2h0OnYscGFkZGluZ0JvdHRvbTpQLHBhZGRpbmdMZWZ0OmksYm9yZGVyV2lkdGg6dX09dGhpcy5hdHRyaWJ1dGVzLFthLGhdPXRoaXMuY29udGVudFNpemU7cmV0dXJuW2krYSt2K3UsTytoK1ArdV19Z2V0IGNsaWVudFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOk8scGFkZGluZ1JpZ2h0OnYscGFkZGluZ0JvdHRvbTpQLHBhZGRpbmdMZWZ0Oml9PXRoaXMuYXR0cmlidXRlcyxbdSxhXT10aGlzLmNvbnRlbnRTaXplO3JldHVybltpK3UrdixPK2ErUF19Z2V0IGNvbnRlbnRTaXplKCl7bGV0e3dpZHRoOk8saGVpZ2h0OnYsYm94U2l6aW5nOlAscGFkZGluZ1RvcDppLHBhZGRpbmdSaWdodDp1LHBhZGRpbmdCb3R0b206YSxwYWRkaW5nTGVmdDpofT10aGlzLmF0dHJpYnV0ZXM7aWYoTz1PfHwwLHY9dnx8MCxQPT09ImJvcmRlci1ib3giKXtjb25zdCBiPTIqdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoO08tPWIrdStoLHYtPWIraSthLE89TWF0aC5tYXgoMCxPKSx2PU1hdGgubWF4KDAsdil9cmV0dXJuW08sdl19Z2V0IGhhc0JvcmRlcigpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg+MH1nZXQgaXNWaXNpYmxlKCl7Y29uc3RbTyx2XT10aGlzLmJvcmRlclNpemU7cmV0dXJuIE8+MCYmdj4wfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgTz10aGlzLmNsaWVudEJveDtpZihPKXtsZXQgdj10aGlzW3ldO2lmKHYpdi5ib3ghPT1PJiYodi5jb250b3Vycz1PLmNvbnRvdXJzLHYuYm94PU8pO2Vsc2V7dj1uZXcgbi5NZXNoMkQoTyksdi5ib3g9Tztjb25zdCBpPXRoaXMuYXR0cmlidXRlcy5iZ2NvbG9yO2lmKE9iamVjdChjLnNldEZpbGxDb2xvcikodix7Y29sb3I6aX0pLHRoaXMuaGFzQm9yZGVyKXtjb25zdHtib3JkZXJDb2xvcjphLGJvcmRlcldpZHRoOmgsYm9yZGVyRGFzaDpiLGJvcmRlckRhc2hPZmZzZXQ6RX09dGhpcy5hdHRyaWJ1dGVzO09iamVjdChjLnNldFN0cm9rZUNvbG9yKSh2LHtjb2xvcjphLGxpbmVXaWR0aDpoLGxpbmVEYXNoOmIsbGluZURhc2hPZmZzZXQ6RX0pfXRoaXNbeV09djtjb25zdCB1PXRoaXMuYXR0cmlidXRlcy5jbGlwUGF0aDt1JiZ0aGlzW3ldLnNldENsaXBQYXRoKHUpfWNvbnN0IFA9dGhpcy5vcGFjaXR5O3JldHVybiB2LmdldE9wYWNpdHkoKSE9PVAmJnYuc2V0T3BhY2l0eShQKSx2LnNldFRyYW5zZm9ybSguLi50aGlzLnJlbmRlck1hdHJpeCksdn1yZXR1cm4gbnVsbH1nZXQgb2Zmc2V0U2l6ZSgpe2NvbnN0e3BhZGRpbmdUb3A6TyxwYWRkaW5nUmlnaHQ6dixwYWRkaW5nQm90dG9tOlAscGFkZGluZ0xlZnQ6aSxib3JkZXJXaWR0aDp1fT10aGlzLmF0dHJpYnV0ZXMsW2EsaF09dGhpcy5jb250ZW50U2l6ZSxiPTIqdTtyZXR1cm5baSthK3YrYixPK2grUCtiXX1nZXQgb3JpZ2luYWxDbGllbnRSZWN0KCl7aWYodGhpcy5tZXNoKXtjb25zdCBPPXRoaXMubWVzaC5ib3VuZGluZ0JveDtyZXR1cm5bT1swXVswXSxPWzBdWzFdLE9bMV1bMF0tT1swXVswXSxPWzFdWzFdLU9bMF1bMV1dfXJldHVyblswLDAsMCwwXX1nZXQgb3JpZ2luYWxDb250ZW50UmVjdCgpe2NvbnN0W08sdixQLGldPXRoaXMub3JpZ2luYWxDbGllbnRSZWN0LHU9dGhpcy5hdHRyaWJ1dGVzLnBhZGRpbmc7cmV0dXJuW08rdVswXSx2K3VbMV0sUC11WzBdLXVbMl0saS11WzFdLXVbM11dfWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCBPPXRoaXMucmVuZGVyTWF0cml4O3RoaXMubGF5ZXImJnRoaXMubGF5ZXIubGF5ZXJUcmFuc2Zvcm1JbnZlcnQmJihPPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXMubGF5ZXIudHJhbnNmb3JtTWF0cml4LE8pKTtsZXQgdj1udWxsO2lmKHRoaXMubWVzaCl7dj1bLi4udGhpcy5tZXNoLmJvdW5kaW5nQm94XTtjb25zdCBQPXRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDtQJiYodlswXT1bdlswXVswXS1QLHZbMF1bMV0tUF0sdlsxXT1bdlsxXVswXStQLHZbMV1bMV0rUF0pfXJldHVybiBPYmplY3QoeC5kZWZhdWx0KSh2LE8pfW9uUHJvcGVydHlDaGFuZ2UoTyx2LFApe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoTyx2LFApLChPPT09ImFuY2hvclgifHxPPT09ImFuY2hvclkifHxPPT09ImJveFNpemluZyJ8fE89PT0id2lkdGgifHxPPT09ImhlaWdodCJ8fE89PT0iYm9yZGVyV2lkdGgifHxPPT09InBhZGRpbmdMZWZ0Inx8Tz09PSJwYWRkaW5nUmlnaHQifHxPPT09InBhZGRpbmdUb3AifHxPPT09InBhZGRpbmdCb3R0b20ifHwvXmJvcmRlcihUb3BMZWZ0fFRvcFJpZ2h0fEJvdHRvbVJpZ2h0fEJvdHRvbUxlZnQpUmFkaXVzJC8udGVzdChPKSkmJnRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzW3ldJiZPPT09ImNsaXBQYXRoIiYmdGhpc1t5XS5zZXRDbGlwUGF0aCh2KSx0aGlzW3ldJiZPPT09ImJnY29sb3IiJiZPYmplY3QoYy5zZXRGaWxsQ29sb3IpKHRoaXNbeV0se2NvbG9yOnZ9KSx0aGlzW3ldJiYoTz09PSJib3JkZXJDb2xvciJ8fE89PT0iYm9yZGVyV2lkdGgifHxPPT09ImJvcmRlckRhc2gifHxPPT09ImJvcmRlckRhc2hPZmZzZXQiKSl7Y29uc3R7Ym9yZGVyQ29sb3I6aSxib3JkZXJXaWR0aDp1LGJvcmRlckRhc2g6YSxib3JkZXJEYXNoT2Zmc2V0Omh9PXRoaXMuYXR0cmlidXRlcztPYmplY3QoYy5zZXRTdHJva2VDb2xvcikodGhpc1t5XSx7Y29sb3I6aSxsaW5lV2lkdGg6dSxsaW5lRGFzaDp1P2E6MCxsaW5lRGFzaE9mZnNldDpofSl9fXVwZGF0ZUNvbnRvdXJzKCl7Y29uc3R7YW5jaG9yWDpPLGFuY2hvclk6dixib3JkZXJXaWR0aDpQLGJvcmRlclJhZGl1czppfT10aGlzLmF0dHJpYnV0ZXMsW3UsYV09dGhpcy5ib3JkZXJTaXplLGg9dGhpcy5vZmZzZXRTaXplLGI9LjUqUCxFPS1PKmhbMF0rYixBPS12KmhbMV0rYjt0aGlzLmNsaWVudEJveD1uZXcgbi5GaWd1cmUyRCxPYmplY3Qoby5jcmVhdGVSYWRpdXNCb3gpKHRoaXMuY2xpZW50Qm94LFtFLEEsdSxhXSxpKX19ZyhtLCJBdHRyIixsLmRlZmF1bHQpLGYuZGVmYXVsdC5yZWdpc3Rlck5vZGUobSwiYmxvY2siKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pO3ZhciByPXQoNzEpLG49dCg3Mikscz10KDIyMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2NsYXNzIHggZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tvXSh7YW5jaG9yWDowLGFuY2hvclk6MCx3aWR0aDp2b2lkIDAsaGVpZ2h0OnZvaWQgMCxib3JkZXJXaWR0aDowLGJvcmRlckNvbG9yOiJyZ2JhKDAsMCwwLDEpIixib3JkZXJEYXNoOnZvaWQgMCxib3JkZXJEYXNoT2Zmc2V0OjAsYm9yZGVyVG9wTGVmdFJhZGl1czpbMCwwXSxib3JkZXJUb3BSaWdodFJhZGl1czpbMCwwXSxib3JkZXJCb3R0b21SaWdodFJhZGl1czpbMCwwXSxib3JkZXJCb3R0b21MZWZ0UmFkaXVzOlswLDBdLGJnY29sb3I6InJnYmEoMCwwLDAsMCkiLHBhZGRpbmdUb3A6MCxwYWRkaW5nUmlnaHQ6MCxwYWRkaW5nQm90dG9tOjAscGFkZGluZ0xlZnQ6MCxib3hTaXppbmc6ImNvbnRlbnQtYm94IixjbGlwUGF0aDp2b2lkIDB9KSx0aGlzW2ZdKCJhbmNob3IiLCJzaXplIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwicGFkZGluZyIpfWdldCBhbmNob3JYKCl7cmV0dXJuIHRoaXNbY10oImFuY2hvclgiKX1zZXQgYW5jaG9yWCh5KXt0aGlzW2xdKCJhbmNob3JYIixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCBhbmNob3JZKCl7cmV0dXJuIHRoaXNbY10oImFuY2hvclkiKX1zZXQgYW5jaG9yWSh5KXt0aGlzW2xdKCJhbmNob3JZIixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCBhbmNob3IoKXtyZXR1cm5bdGhpcy5hbmNob3JYLHRoaXMuYW5jaG9yWV19c2V0IGFuY2hvcih5KXt5PU9iamVjdChuLnRvQXJyYXkpKHkpLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzLmFuY2hvclg9eVswXSx0aGlzLmFuY2hvclk9eVsxXX1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpc1tjXSgid2lkdGgiKX1zZXQgd2lkdGgoeSl7dGhpc1tsXSgid2lkdGgiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzW2NdKCJoZWlnaHQiKX1zZXQgaGVpZ2h0KHkpe3RoaXNbbF0oImhlaWdodCIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgc2l6ZSgpe3JldHVyblt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XX1zZXQgc2l6ZSh5KXt5PU9iamVjdChuLnRvQXJyYXkpKHkpLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzLndpZHRoPXlbMF0sdGhpcy5oZWlnaHQ9eVsxXX1nZXQgYm9yZGVyV2lkdGgoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyV2lkdGgiKX1zZXQgYm9yZGVyV2lkdGgoeSl7dGhpc1tsXSgiYm9yZGVyV2lkdGgiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IGJvcmRlckNvbG9yKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlckNvbG9yIil9c2V0IGJvcmRlckNvbG9yKHkpe3RoaXNbbF0oImJvcmRlckNvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKSh5KSl9Z2V0IGJvcmRlcigpe3JldHVyblt0aGlzLmJvcmRlcldpZHRoLHRoaXMuYm9yZGVyQ29sb3JdfXNldCBib3JkZXIoeSl7eT1PYmplY3Qobi50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beV0pLHRoaXMuYm9yZGVyV2lkdGg9eVswXSx5WzFdIT1udWxsJiYodGhpcy5ib3JkZXJDb2xvcj15WzFdKX1nZXQgYm9yZGVyRGFzaCgpe3JldHVybiB0aGlzW2NdKCJib3JkZXJEYXNoIil9c2V0IGJvcmRlckRhc2goeSl7eT1PYmplY3Qobi50b0FycmF5KSh5LCEwKSx5IT1udWxsJiYhQXJyYXkuaXNBcnJheSh5KSYmKHk9W3ldKSx0aGlzW2xdKCJib3JkZXJEYXNoIix5P3kubWFwKG4udG9OdW1iZXIpOm51bGwpfWdldCBib3JkZXJEYXNoT2Zmc2V0KCl7cmV0dXJuIHRoaXNbY10oImJvcmRlckRhc2hPZmZzZXQiKX1zZXQgYm9yZGVyRGFzaE9mZnNldCh5KXt0aGlzW2xdKCJib3JkZXJEYXNoT2Zmc2V0IixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCBib3JkZXJUb3BMZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlclRvcExlZnRSYWRpdXMiKX1zZXQgYm9yZGVyVG9wTGVmdFJhZGl1cyh5KXt5PU9iamVjdChuLnRvQXJyYXkpKHksITApLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5LHldKSx0aGlzW2xdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIix5Lm1hcChuLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclRvcFJpZ2h0UmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlclRvcFJpZ2h0UmFkaXVzIil9c2V0IGJvcmRlclRvcFJpZ2h0UmFkaXVzKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXNbbF0oImJvcmRlclRvcFJpZ2h0UmFkaXVzIix5Lm1hcChuLnRvTnVtYmVyKSl9Z2V0IGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzIil9c2V0IGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXNbbF0oImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzIix5Lm1hcChuLnRvTnVtYmVyKSl9Z2V0IGJvcmRlckJvdHRvbUxlZnRSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXNbbF0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiLHkubWFwKG4udG9OdW1iZXIpKX1nZXQgYm9yZGVyUmFkaXVzKCl7cmV0dXJuWy4uLnRoaXMuYm9yZGVyVG9wTGVmdFJhZGl1cywuLi50aGlzLmJvcmRlclRvcFJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMsLi4udGhpcy5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzXX1zZXQgYm9yZGVyUmFkaXVzKHkpe2lmKHk9T2JqZWN0KG4udG9BcnJheSkoeSksIUFycmF5LmlzQXJyYXkoeSkpeT1BcnJheSg4KS5maWxsKHkpO2Vsc2UgaWYoeS5sZW5ndGg9PT0yKXk9W3lbMF0seVsxXSx5WzBdLHlbMV0seVswXSx5WzFdLHlbMF0seVsxXV07ZWxzZSBpZih5Lmxlbmd0aD09PTQpeT1beVswXSx5WzFdLHlbMl0seVszXSx5WzBdLHlbMV0seVsyXSx5WzNdXTtlbHNlIGlmKHkubGVuZ3RoPT09Nil5PVt5WzBdLHlbMV0seVsyXSx5WzNdLHlbNF0seVs1XSx5WzJdLHlbM11dO2Vsc2UgaWYoeS5sZW5ndGghPT04KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYm9yZGVyUmFkaXVzIHZhbHVlLiIpO3RoaXMuYm9yZGVyVG9wTGVmdFJhZGl1cz1beVswXSx5WzFdXSx0aGlzLmJvcmRlclRvcFJpZ2h0UmFkaXVzPVt5WzJdLHlbM11dLHRoaXMuYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM9W3lbNF0seVs1XV0sdGhpcy5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzPVt5WzZdLHlbN11dfWdldCBiZ2NvbG9yKCl7cmV0dXJuIHRoaXNbY10oImJnY29sb3IiKX1zZXQgYmdjb2xvcih5KXt0aGlzW2xdKCJiZ2NvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKSh5KSl9Z2V0IHBhZGRpbmdUb3AoKXtyZXR1cm4gdGhpc1tjXSgicGFkZGluZ1RvcCIpfXNldCBwYWRkaW5nVG9wKHkpe3RoaXNbbF0oInBhZGRpbmdUb3AiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IHBhZGRpbmdSaWdodCgpe3JldHVybiB0aGlzW2NdKCJwYWRkaW5nUmlnaHQiKX1zZXQgcGFkZGluZ1JpZ2h0KHkpe3RoaXNbbF0oInBhZGRpbmdSaWdodCIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgcGFkZGluZ0JvdHRvbSgpe3JldHVybiB0aGlzW2NdKCJwYWRkaW5nQm90dG9tIil9c2V0IHBhZGRpbmdCb3R0b20oeSl7dGhpc1tsXSgicGFkZGluZ0JvdHRvbSIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgcGFkZGluZ0xlZnQoKXtyZXR1cm4gdGhpc1tjXSgicGFkZGluZ0xlZnQiKX1zZXQgcGFkZGluZ0xlZnQoeSl7dGhpc1tsXSgicGFkZGluZ0xlZnQiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IHBhZGRpbmcoKXtyZXR1cm5bdGhpcy5wYWRkaW5nVG9wLHRoaXMucGFkZGluZ1JpZ2h0LHRoaXMucGFkZGluZ0JvdHRvbSx0aGlzLnBhZGRpbmdMZWZ0XX1zZXQgcGFkZGluZyh5KXt5PU9iamVjdChuLnRvQXJyYXkpKHkpLEFycmF5LmlzQXJyYXkoeSk/eS5sZW5ndGg9PT0yP3k9W3lbMF0seVsxXSx5WzBdLHlbMV1dOnkubGVuZ3RoPT09MyYmKHk9W3lbMF0seVsxXSx5WzJdLHlbMV1dKTp5PVt5LHkseSx5XSx0aGlzLnBhZGRpbmdUb3A9eVswXSx0aGlzLnBhZGRpbmdSaWdodD15WzFdLHRoaXMucGFkZGluZ0JvdHRvbT15WzJdLHRoaXMucGFkZGluZ0xlZnQ9eVszXX1nZXQgY2xpcFBhdGgoKXtyZXR1cm4gdGhpc1tjXSgiY2xpcFBhdGgiKX1zZXQgY2xpcFBhdGgoeSl7dGhpc1tsXSgiY2xpcFBhdGgiLHkpfWdldCBib3hTaXppbmcoKXtyZXR1cm4gdGhpc1tjXSgiYm94U2l6aW5nIil9c2V0IGJveFNpemluZyh5KXtpZih5IT1udWxsJiZ5IT09ImJvcmRlci1ib3giJiZ5IT09ImNvbnRlbnQtYm94Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJveFNpemluZyB0eXBlLiIpO3RoaXNbbF0oImJveFNpemluZyIseSl9fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiR3JhZGllbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiaXNUcmFuc3BhcmVudCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJwYXJzZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInNldEZpbGxDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzZXRTdHJva2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciByPXQoMzIpLG49dC5uKHIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjbGFzcyBze2NvbnN0cnVjdG9yKHt2ZWN0b3I6bSxjb2xvcnM6VH0pe2lmKCFBcnJheS5pc0FycmF5KG0pfHxtLmxlbmd0aCE9PTQmJm0ubGVuZ3RoIT09NiYmbS5sZW5ndGghPT0zKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZ3JhZGllbnQiKTt0aGlzLnZlY3Rvcj1tLHRoaXMuY29sb3JzPVQubWFwKCh7b2Zmc2V0Ok8sY29sb3I6dn0pPT4oe29mZnNldDpPLGNvbG9yOmModil9KSl9dG9TdHJpbmcoKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoe3ZlY3Rvcjp0aGlzLnZlY3Rvcixjb2xvcnM6dGhpcy5jb2xvcnN9KX19ZnVuY3Rpb24gbCh5KXtyZXR1cm4geSBpbnN0YW5jZW9mIHM/ITE6eT09bnVsbD8hMDpuKCkoeSlbM109PT0wfWZ1bmN0aW9uIGMoeSl7aWYoeT09bnVsbHx8KHl8fCh5PSJ0cmFuc3BhcmVudCIpLHkgaW5zdGFuY2VvZiBzKSlyZXR1cm4geTtjb25zdCBtPW4oKSh5KTtpZighbXx8IW0ubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY29sb3IgdmFsdWUuIik7cmV0dXJuYHJnYmEoJHttLmpvaW4oKX0pYH1mdW5jdGlvbiBvKHksbSxUKXtjb25zdCBPPXkuYm91bmRpbmdCb3hbMF07aWYoVC52ZWN0b3Ipe2xldHt2ZWN0b3I6dixjb2xvcnM6UH09VDt2Lmxlbmd0aD09PTQ/KHY9W3ZbMF0rT1swXSx2WzFdK09bMV0sdlsyXStPWzBdLHZbM10rT1sxXV0seS5zZXRMaW5lYXJHcmFkaWVudCh7dmVjdG9yOnYsY29sb3JzOlAsdHlwZTptfSkpOnYubGVuZ3RoPT09Mz8odj1bdlswXStPWzBdLHZbMV0rT1sxXSx2WzJdXSx5LnNldENpcmN1bGFyR3JhZGllbnQoe3ZlY3Rvcjp2LGNvbG9yczpQLHR5cGU6bX0pKToodj1bdlswXStPWzBdLHZbMV0rT1sxXSx2WzJdLHZbM10rT1swXSx2WzRdK09bMV0sdls1XV0seS5zZXRSYWRpYWxHcmFkaWVudCh7dmVjdG9yOnYsY29sb3JzOlAsdHlwZTptfSkpfWVsc2UgeS5ncmFkaWVudCYmeS5ncmFkaWVudFttXSYmKGRlbGV0ZSB5LmdyYWRpZW50W21dLGRlbGV0ZSB5LnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IpfWZ1bmN0aW9uIGYoeSx7Y29sb3I6bSxydWxlOlQ9Im5vbnplcm8ifSl7cmV0dXJuIG8oeSwiZmlsbCIsbSksbS52ZWN0b3J8fHkuc2V0RmlsbCh7Y29sb3I6bSxydWxlOlR9KSx5fWZ1bmN0aW9uIHgoeSx7Y29sb3I6bSxsaW5lV2lkdGg6VCxsaW5lQ2FwOk8sbGluZUpvaW46dixsaW5lRGFzaDpQLGxpbmVEYXNoT2Zmc2V0OmksbWl0ZXJMaW1pdDp1LHJvdW5kU2VnbWVudHM6YX0pe28oeSwic3Ryb2tlIixtKSxtLnZlY3RvciYmKG09WzAsMCwwLDFdKSx5LnNldFN0cm9rZSh7Y29sb3I6bSx0aGlja25lc3M6VCxjYXA6Tyxqb2luOnYsbWl0ZXJMaW1pdDp1LGxpbmVEYXNoOlAsbGluZURhc2hPZmZzZXQ6aSxyb3VuZFNlZ21lbnRzOmF9KX1jbGFzcyBnIGV4dGVuZHMgQXJyYXl7Y29uc3RydWN0b3IobT0wLFQ9MCxPPTAsdj0wKXtyZXR1cm4gQXJyYXkuaXNBcnJheShtKSYmKFttLFQsTyx2XT1tKSx0eXBlb2YgbT09InN0cmluZyImJihbbSxULE8sdl09bigpKG0pLG0vPTI1NSxULz0yNTUsTy89MjU1KSxzdXBlcihtLFQsTyx2KSx0aGlzfWdldCByKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1swXSoyNTUpfXNldCByKG0pe3RoaXNbMF09bS8yNTV9Z2V0IGcoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzFdKjI1NSl9c2V0IGcobSl7dGhpc1sxXT1tLzI1NX1nZXQgYigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMl0qMjU1KX1zZXQgYihtKXt0aGlzWzJdPW0vMjU1fWdldCBhKCl7cmV0dXJuIHRoaXNbM119c2V0IGEobSl7dGhpc1szXT1tfWdldCBoZXgoKXtjb25zdCBtPWAwJHt0aGlzLnIudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLFQ9YDAke3RoaXMuZy50b1N0cmluZygxNil9YC5zbGljZSgtMiksTz1gMCR7dGhpcy5iLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKTtsZXQgdjtyZXR1cm4gdGhpcy5hPDEmJih2PU1hdGgucm91bmQodGhpc1szXSoyNTUpLHY9YDAke3YudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpKSxgIyR7bX0ke1R9JHtPfSR7dnx8IiJ9YH1nZXQgcmdiYSgpe3JldHVybmByZ2JhKCR7dGhpcy5yfSwke3RoaXMuZ30sJHt0aGlzLmJ9LCR7dGhpcy5hfSlgfWZyb21Db2xvcihtKXtyZXR1cm4gdHlwZW9mIG09PSJzdHJpbmciJiYobT1uKCkobSksbVswXS89MjU1LG1bMV0vPTI1NSxtWzJdLz0yNTUpLHRoaXNbMF09bVswXSx0aGlzWzFdPW1bMV0sdGhpc1syXT1tWzJdLHRoaXNbM109bVszXSx0aGlzfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZVJhZGl1c0JveCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKHMsbCxjLG8sZix4PSJsZWZ0VG9wIil7Y29uc3QgZz0uNTUyMjg0OCx5PW8vMipnLG09Zi8yKmcsVD1sK28sTz1jK2Ysdj1sK28vMixQPWMrZi8yO3g9PT0ibGVmdFRvcCI/KHMubW92ZVRvKGwsUCkscy5iZXppZXJDdXJ2ZVRvKGwsUC1tLHYteSxjLHYsYykpOng9PT0icmlnaHRUb3AiP3MuYmV6aWVyQ3VydmVUbyh2K3ksYyxULFAtbSxULFApOng9PT0icmlnaHRCb3R0b20iP3MuYmV6aWVyQ3VydmVUbyhULFArbSx2K3ksTyx2LE8pOng9PT0ibGVmdEJvdHRvbSImJnMuYmV6aWVyQ3VydmVUbyh2LXksTyxsLFArbSxsLFApfWZ1bmN0aW9uIG4ocyxbbCxjLG8sZl0seCl7aWYoIXh8fEFycmF5LmlzQXJyYXkoeCkmJnguZXZlcnkoZz0+Zz09PTApKXMuYmVnaW5QYXRoKCkscy5yZWN0KGwsYyxvLGYpO2Vsc2V7dHlwZW9mIHg9PSJudW1iZXIiJiYoeD1BcnJheSg4KS5maWxsKHgpKTtjb25zdFtnLHksbSxULE8sdixQLGldPXgubWFwKCh1LGEpPT5hJTI/TWF0aC5taW4odSxmLzIpOk1hdGgubWluKHUsby8yKSk7cy5iZWdpblBhdGgoKSxzLm1vdmVUbyhsLGMreSkscihzLGwsYyxnKjIseSoyLCJsZWZ0VG9wIikscy5saW5lVG8obCtvLW0sYykscihzLGwrby1tKjIsYyxtKjIsVCoyLCJyaWdodFRvcCIpLHMubGluZVRvKGwrbyxjK2YtdikscihzLGwrby1PKjIsYytmLXYqMixPKjIsdioyLCJyaWdodEJvdHRvbSIpLHMubGluZVRvKGwrUCxjK2YpLHIocyxsLGMrZi1pKjIsUCoyLGkqMiwibGVmdEJvdHRvbSIpLHMuY2xvc2VQYXRoKCl9cmV0dXJuIHN9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KSxlLmRlZmF1bHQ9ZnVuY3Rpb24ocixuKXtpZighcilyZXR1cm57eDowLHk6MCx3aWR0aDowLGhlaWdodDowLGxlZnQ6MCx0b3A6MCxyaWdodDowLGJvdHRvbTowfTtjb25zdFtbcyxsXSxbYyxvXV09cixmPXMqblswXStsKm5bMl0rbls0XSx4PXMqblsxXStsKm5bM10rbls1XSxnPWMqblswXStsKm5bMl0rbls0XSx5PWMqblsxXStsKm5bM10rbls1XSxtPWMqblswXStvKm5bMl0rbls0XSxUPWMqblsxXStvKm5bM10rbls1XSxPPXMqblswXStvKm5bMl0rbls0XSx2PXMqblsxXStvKm5bM10rbls1XSxQPU1hdGgubWluKGYsZyxtLE8pLGk9TWF0aC5taW4oeCx5LFQsdiksdT1NYXRoLm1heChmLGcsbSxPKSxhPU1hdGgubWF4KHgseSxULHYpO3JldHVybnt4OlAseTppLHdpZHRoOnUtUCxoZWlnaHQ6YS1pLGxlZnQ6UCx0b3A6aSxyaWdodDp1LGJvdHRvbTphfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDIxOCksbj10KDIxOSkscz10KDIyNSksbD10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGMoeCxnLHkpe3JldHVybiBnIGluIHg/T2JqZWN0LmRlZmluZVByb3BlcnR5KHgsZyx7dmFsdWU6eSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnhbZ109eSx4fWNvbnN0IG89U3ltYm9sKCJ0ZXh0dXJlVGFzayIpO2NsYXNzIGYgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoZz17fSl7dHlwZW9mIGc9PSJzdHJpbmciJiYoZz17dGV4dHVyZTpnfSksc3VwZXIoZyl9Z2V0IGNvbnRlbnRTaXplKCl7bGV0W2cseV09c3VwZXIuY29udGVudFNpemU7Y29uc3R7d2lkdGg6bSxoZWlnaHQ6VH09dGhpcy5hdHRyaWJ1dGVzO2lmKG09PW51bGx8fFQ9PW51bGwpe2NvbnN0IE89dGhpcy50ZXh0dXJlSW1hZ2Usdj10aGlzLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3QsUD10aGlzLmF0dHJpYnV0ZXMuc291cmNlUmVjdDtpZih2KW09PW51bGwmJihnPXZbMF0rdlsyXSksVD09bnVsbCYmKHk9dlsxXSt2WzNdKTtlbHNlIGlmKFApe2NvbnN0IGk9dGhpcy5sYXllcj90aGlzLmxheWVyLmRpc3BsYXlSYXRpbzoxO209PW51bGwmJihnPVBbMl0vaSksVD09bnVsbCYmKHk9UFszXS9pKX1lbHNlIGlmKE8pe2NvbnN0IGk9dGhpcy5sYXllcj90aGlzLmxheWVyLmRpc3BsYXlSYXRpbzoxO209PW51bGwmJihnPU8ud2lkdGgvaSksVD09bnVsbCYmKHk9Ty5oZWlnaHQvaSl9fXJldHVybltnLHldfWdldCB0ZXh0dXJlSW1hZ2VSZWFkeSgpe3JldHVybiB0aGlzW29dfHxQcm9taXNlLnJlc29sdmUoKX1kcmF3KGc9W10pe3N1cGVyLmRyYXcoZyk7Y29uc3QgeT10aGlzLm1lc2g7cmV0dXJuIHkmJk9iamVjdChyLmRyYXdUZXh0dXJlKSh0aGlzLHkpLGd9b25Qcm9wZXJ0eUNoYW5nZShnLHksbSl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShnLHksbSksZz09PSJ0ZXh0dXJlIiYmKHRoaXNbb109T2JqZWN0KHIuYXBwbHlUZXh0dXJlKSh0aGlzLHksITApKSxnPT09InRleHR1cmVSZWN0Iil7Y29uc3R7d2lkdGg6VCxoZWlnaHQ6T309dGhpcy5hdHRyaWJ1dGVzOyhUPT1udWxsfHxPPT1udWxsKSYmdGhpcy51cGRhdGVDb250b3VycygpfX19YyhmLCJBdHRyIixzLmRlZmF1bHQpLGwuZGVmYXVsdC5yZWdpc3Rlck5vZGUoZiwic3ByaXRlIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtjbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbbl0oe3RleHR1cmU6dm9pZCAwLHRleHR1cmVSZWN0OnZvaWQgMCx0ZXh0dXJlUmVwZWF0OiExLHNvdXJjZVJlY3Q6dm9pZCAwfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tsXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe3RoaXNbc10oInRleHR1cmUiLGYpfWdldCB0ZXh0dXJlUmVjdCgpe3JldHVybiB0aGlzW2xdKCJ0ZXh0dXJlUmVjdCIpfXNldCB0ZXh0dXJlUmVjdChmKXt0aGlzW3NdKCJ0ZXh0dXJlUmVjdCIsZil9Z2V0IHNvdXJjZVJlY3QoKXtyZXR1cm4gdGhpc1tsXSgic291cmNlUmVjdCIpfXNldCBzb3VyY2VSZWN0KGYpe3RoaXNbc10oInNvdXJjZVJlY3QiLGYpfWdldCB0ZXh0dXJlUmVwZWF0KCl7cmV0dXJuIHRoaXNbbF0oInRleHR1cmVSZXBlYXQiKX1zZXQgdGV4dHVyZVJlcGVhdChmKXt0aGlzW3NdKCJ0ZXh0dXJlUmVwZWF0IiwhIWYpfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgcj10KDEyKSxuPXQoMjI3KSxzPXQubihuKSxsPXQoNzApLGM9dCgyMjgpLG89dCgyMjEpLGY9dCgyMTgpLHg9dCgyMTMpLGc9dCgyMjMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB5KE8sdixQKXtyZXR1cm4gdiBpbiBPP09iamVjdC5kZWZpbmVQcm9wZXJ0eShPLHYse3ZhbHVlOlAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpPW3ZdPVAsT31jb25zdCBtPVN5bWJvbCgibWVzaCIpO2NsYXNzIFQgZXh0ZW5kcyBsLmRlZmF1bHR7Y29uc3RydWN0b3Iodj17fSl7dHlwZW9mIHY9PSJzdHJpbmciJiYodj17ZDp2fSksc3VwZXIodiksdGhpcy5lZmZlY3RzPXtkKFAsaSx1LGEsaCl7Y29uc3QgYj0odS1hKS8oaC1hKTtpZihiPD0wKXJldHVybiBQO2lmKGI+PTEpcmV0dXJuIGk7Y29uc3QgRT1zLmEuX3ByZXByb2Nlc3Npbmcocy5hLnBhdGgyc2hhcGVzKFApLHMuYS5wYXRoMnNoYXBlcyhpKSksQT1zLmEuX2xlcnAoLi4uRSxiKVswXTtyZXR1cm4gQS5yZWR1Y2UoKFMsSSk9PmAke1N9JHtJLnNsaWNlKDIpLmpvaW4oIiAiKX0gYCxgTSR7QVswXVswXX0gJHtBWzBdWzFdfUNgKS50cmltKCl9fX1nZXQgaXNWaXNpYmxlKCl7cmV0dXJuISF0aGlzLmR9Z2V0IG1lc2goKXtpZih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT09PSJub25lIilyZXR1cm4gbnVsbDtjb25zdCB2PXRoaXMucGF0aDtpZih2KXtsZXQgUD10aGlzW21dO2lmKFApUC5wYXRoIT09diYmKFAuY29udG91cnM9di5jb250b3VycyxQLnBhdGg9dik7ZWxzZXtQPW5ldyByLk1lc2gyRCh0aGlzLnBhdGgpLFAucGF0aD12O2NvbnN0IHU9dGhpcy5hdHRyaWJ1dGVzLmZpbGxDb2xvcixhPXRoaXMuYXR0cmlidXRlcy5maWxsUnVsZTt1JiZPYmplY3Qoby5zZXRGaWxsQ29sb3IpKFAse2NvbG9yOnUscnVsZTphfSk7Y29uc3QgaD10aGlzLmF0dHJpYnV0ZXMubGluZVdpZHRoLGI9dGhpcy5hdHRyaWJ1dGVzLnN0cm9rZUNvbG9yO2lmKGImJmg+MCl7Y29uc3R7bGluZUNhcDpBLGxpbmVKb2luOkwsbWl0ZXJMaW1pdDpTLGxpbmVEYXNoOkksbGluZURhc2hPZmZzZXQ6RCxyb3VuZFNlZ21lbnRzOlJ9PXRoaXMuYXR0cmlidXRlcztPYmplY3Qoby5zZXRTdHJva2VDb2xvcikoUCx7Y29sb3I6YixsaW5lV2lkdGg6aCxsaW5lQ2FwOkEsbGluZUpvaW46TCxtaXRlckxpbWl0OlMsbGluZURhc2g6SSxsaW5lRGFzaE9mZnNldDpELHJvdW5kU2VnbWVudHM6Un0pfXRoaXNbbV09UDtjb25zdCBFPXRoaXMuYXR0cmlidXRlcy5jbGlwUGF0aDtFJiZ0aGlzW21dLnNldENsaXBQYXRoKEUpfWNvbnN0IGk9dGhpcy5vcGFjaXR5O3JldHVybiBQLmdldE9wYWNpdHkoKSE9PWkmJlAuc2V0T3BhY2l0eShpKSxQLnNldFRyYW5zZm9ybSguLi50aGlzLnJlbmRlck1hdHJpeCksUH1yZXR1cm4gbnVsbH1nZXQgb3JpZ2luYWxDb250ZW50UmVjdCgpe2lmKHRoaXMucGF0aCl7Y29uc3Qgdj10aGlzLnBhdGguYm91bmRpbmdCb3g7cmV0dXJuW3ZbMF1bMF0sdlswXVsxXSx2WzFdWzBdLXZbMF1bMF0sdlsxXVsxXS12WzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3Qgdj10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW3ZbMF1bMF0sdlswXVsxXSx2WzFdWzBdLXZbMF1bMF0sdlsxXVsxXS12WzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ2xpZW50Q2VudGVyKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guYm91bmRpbmdDZW50ZXI6WzAsMF19c2V0IGQodil7dGhpcy5hdHRyaWJ1dGVzLmQ9dn1nZXQgZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuZH1kcmF3KHY9W10pe3N1cGVyLmRyYXcodik7Y29uc3QgUD10aGlzLm1lc2g7cmV0dXJuIFAmJk9iamVjdChmLmRyYXdUZXh0dXJlKSh0aGlzLFApLHZ9Z2V0Qm91bmRpbmdDbGllbnRSZWN0KCl7bGV0IHY9bnVsbDtyZXR1cm4gdGhpcy5tZXNoJiYodj10aGlzLm1lc2guYm91bmRpbmdCb3gpLE9iamVjdChnLmRlZmF1bHQpKHYsdGhpcy5yZW5kZXJNYXRyaXgpfWdldFBhdGhMZW5ndGgoKXtyZXR1cm4gdGhpcy5tZXNoP3RoaXMubWVzaC5nZXRUb3RhbExlbmd0aCgpOjB9Z2V0UG9pbnRBdExlbmd0aCh2KXtpZih0aGlzLm1lc2gpe2NvbnN0IFA9dGhpcy5tZXNoLmdldFBvaW50QXRMZW5ndGgodik7aWYoUClyZXR1cm5bUC54LFAueV19cmV0dXJuWzAsMF19b25Qcm9wZXJ0eUNoYW5nZSh2LFAsaSl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZSh2LFAsaSksKHY9PT0iZCJ8fHY9PT0ibm9ybWFsaXplIikmJnRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzW21dJiYodj09PSJmaWxsQ29sb3IifHx2PT09ImZpbGxSdWxlIikpe2NvbnN0e2ZpbGxDb2xvcjp1LGZpbGxSdWxlOmF9PXRoaXMuYXR0cmlidXRlcztPYmplY3Qoby5zZXRGaWxsQ29sb3IpKHRoaXNbbV0se2NvbG9yOnUscnVsZTphfSl9aWYodGhpc1ttXSYmKHY9PT0ic3Ryb2tlQ29sb3IifHx2PT09ImxpbmVXaWR0aCJ8fHY9PT0ibGluZUNhcCJ8fHY9PT0ibGluZUpvaW4ifHx2PT09ImxpbmVEYXNoInx8dj09PSJsaW5lRGFzaE9mZnNldCJ8fHY9PT0icm91bmRTZWdtZW50cyIpKXtjb25zdHtzdHJva2VDb2xvcjp1LGxpbmVXaWR0aDphfT10aGlzLmF0dHJpYnV0ZXM7aWYodSYmYT4wKXtjb25zdHtsaW5lQ2FwOmgsbGluZUpvaW46YixsaW5lRGFzaDpFLGxpbmVEYXNoT2Zmc2V0OkEsbWl0ZXJMaW1pdDpMLHJvdW5kU2VnbWVudHM6U309dGhpcy5hdHRyaWJ1dGVzO09iamVjdChvLnNldFN0cm9rZUNvbG9yKSh0aGlzW21dLHtjb2xvcjp1LGxpbmVDYXA6aCxsaW5lSm9pbjpiLGxpbmVXaWR0aDphLGxpbmVEYXNoOkUsbGluZURhc2hPZmZzZXQ6QSxtaXRlckxpbWl0Okwscm91bmRTZWdtZW50czpTfSl9fXRoaXNbbV0mJnY9PT0iY2xpcFBhdGgiJiZ0aGlzW21dLnNldENsaXBQYXRoKFApLHY9PT0idGV4dHVyZSImJk9iamVjdChmLmFwcGx5VGV4dHVyZSkodGhpcyxQKX11cGRhdGVDb250b3Vycygpe3RoaXMucGF0aD1uZXcgci5GaWd1cmUyRCx0aGlzLnBhdGguYWRkUGF0aCh0aGlzLmF0dHJpYnV0ZXMuZCksdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbGl6ZSYmdGhpcy5wYXRoLm5vcm1hbGl6ZSguLi50aGlzLnBhdGguYm91bmRpbmdDZW50ZXIpfX15KFQsIkF0dHIiLGMuZGVmYXVsdCkseC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShULCJwYXRoIil9LGZ1bmN0aW9uKGQsZSx0KXsoZnVuY3Rpb24ocixuKXtkLmV4cG9ydHM9bigpfSkodGhpcyxmdW5jdGlvbigpe3ZhciByPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gSShELFIpe3ZhciBDPVtdLGo9ITAsJD0hMSxIPXZvaWQgMDt0cnl7Zm9yKHZhciBKPURbU3ltYm9sLml0ZXJhdG9yXSgpLHE7IShqPShxPUoubmV4dCgpKS5kb25lKSYmKEMucHVzaChxLnZhbHVlKSwhKFImJkMubGVuZ3RoPT09UikpO2o9ITApO31jYXRjaChGKXskPSEwLEg9Rn1maW5hbGx5e3RyeXshaiYmSi5yZXR1cm4mJkoucmV0dXJuKCl9ZmluYWxseXtpZigkKXRocm93IEh9fXJldHVybiBDfXJldHVybiBmdW5jdGlvbihELFIpe2lmKEFycmF5LmlzQXJyYXkoRCkpcmV0dXJuIEQ7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChEKSlyZXR1cm4gSShELFIpO3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UiKX19KCksbj1NYXRoLlBJKjIscz1mdW5jdGlvbihELFIsQyxqLCQsSCxKKXt2YXIgcT1ELngsRj1ELnk7cSo9UixGKj1DO3ZhciBHPWoqcS0kKkYsWj0kKnEraipGO3JldHVybnt4OkcrSCx5OlorSn19LGw9ZnVuY3Rpb24oRCxSKXt2YXIgQz0xLjMzMzMzMzMzMzMzMzMzMzMqTWF0aC50YW4oUi80KSxqPU1hdGguY29zKEQpLCQ9TWF0aC5zaW4oRCksSD1NYXRoLmNvcyhEK1IpLEo9TWF0aC5zaW4oRCtSKTtyZXR1cm5be3g6ai0kKkMseTokK2oqQ30se3g6SCtKKkMseTpKLUgqQ30se3g6SCx5Okp9XX0sYz1mdW5jdGlvbihELFIsQyxqKXt2YXIgJD1EKmotUipDPDA/LTE6MSxIPU1hdGguc3FydChEKkQrUipSKSxKPU1hdGguc3FydChEKkQrUipSKSxxPUQqQytSKmosRj1xLyhIKkopO3JldHVybiBGPjEmJihGPTEpLEY8LTEmJihGPS0xKSwkKk1hdGguYWNvcyhGKX0sbz1mdW5jdGlvbihELFIsQyxqLCQsSCxKLHEsRixHLFosdHQpe3ZhciBldD1NYXRoLnBvdygkLDIpLGl0PU1hdGgucG93KEgsMiksaz1NYXRoLnBvdyhaLDIpLGh0PU1hdGgucG93KHR0LDIpLGZ0PWV0Kml0LWV0Kmh0LWl0Kms7ZnQ8MCYmKGZ0PTApLGZ0Lz1ldCpodCtpdCprLGZ0PU1hdGguc3FydChmdCkqKEo9PT1xPy0xOjEpO3ZhciBCPWZ0KiQvSCp0dCxXPWZ0Ki1ILyQqWixWPUcqQi1GKlcrKEQrQykvMixYPUYqQitHKlcrKFIraikvMixOPShaLUIpLyQsej0odHQtVykvSCxwPSgtWi1CKS8kLE09KC10dC1XKS9ILHc9YygxLDAsTix6KSxVPWMoTix6LHAsTSk7cmV0dXJuIHE9PT0wJiZVPjAmJihVLT1uKSxxPT09MSYmVTwwJiYoVSs9biksW1YsWCx3LFVdfSxmPWZ1bmN0aW9uKEQpe3ZhciBSPUQucHgsQz1ELnB5LGo9RC5jeCwkPUQuY3ksSD1ELnJ4LEo9RC5yeSxxPUQueEF4aXNSb3RhdGlvbixGPXE9PT12b2lkIDA/MDpxLEc9RC5sYXJnZUFyY0ZsYWcsWj1HPT09dm9pZCAwPzA6Ryx0dD1ELnN3ZWVwRmxhZyxldD10dD09PXZvaWQgMD8wOnR0LGl0PVtdO2lmKEg9PT0wfHxKPT09MClyZXR1cm5bXTt2YXIgaz1NYXRoLnNpbihGKm4vMzYwKSxodD1NYXRoLmNvcyhGKm4vMzYwKSxmdD1odCooUi1qKS8yK2sqKEMtJCkvMixCPS1rKihSLWopLzIraHQqKEMtJCkvMjtpZihmdD09PTAmJkI9PT0wKXJldHVybltdO0g9TWF0aC5hYnMoSCksSj1NYXRoLmFicyhKKTt2YXIgVz1NYXRoLnBvdyhmdCwyKS9NYXRoLnBvdyhILDIpK01hdGgucG93KEIsMikvTWF0aC5wb3coSiwyKTtXPjEmJihIKj1NYXRoLnNxcnQoVyksSio9TWF0aC5zcXJ0KFcpKTt2YXIgVj1vKFIsQyxqLCQsSCxKLFosZXQsayxodCxmdCxCKSxYPXIoViw0KSxOPVhbMF0sej1YWzFdLHA9WFsyXSxNPVhbM10sdz1NYXRoLm1heChNYXRoLmNlaWwoTWF0aC5hYnMoTSkvKG4vNCkpLDEpO00vPXc7Zm9yKHZhciBVPTA7VTx3O1UrKylpdC5wdXNoKGwocCxNKSkscCs9TTtyZXR1cm4gaXQubWFwKGZ1bmN0aW9uKEspe3ZhciBZPXMoS1swXSxILEosaHQsayxOLHopLFE9WS54LHJ0PVkueSxudD1zKEtbMV0sSCxKLGh0LGssTix6KSxhdD1udC54LGN0PW50Lnksb3Q9cyhLWzJdLEgsSixodCxrLE4seiksc3Q9b3QueCxsdD1vdC55O3JldHVybnt4MTpRLHkxOnJ0LHgyOmF0LHkyOmN0LHg6c3QseTpsdH19KX0seD17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxnPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24geShJKXt2YXIgRD1bXTtyZXR1cm4gSS5yZXBsYWNlKGcsZnVuY3Rpb24oUixDLGope3ZhciAkPUMudG9Mb3dlckNhc2UoKTtmb3Ioaj1UKGopLCQ9PSJtIiYmai5sZW5ndGg+MiYmKEQucHVzaChbQ10uY29uY2F0KGouc3BsaWNlKDAsMikpKSwkPSJsIixDPUM9PSJtIj8ibCI6IkwiKTs7KXtpZihqLmxlbmd0aD09eFskXSlyZXR1cm4gai51bnNoaWZ0KEMpLEQucHVzaChqKTtpZihqLmxlbmd0aDx4WyRdKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO0QucHVzaChbQ10uY29uY2F0KGouc3BsaWNlKDAseFskXSkpKX19KSxEfXZhciBtPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIFQoSSl7dmFyIEQ9SS5tYXRjaChtKTtyZXR1cm4gRD9ELm1hcChOdW1iZXIpOltdfWZ1bmN0aW9uIE8oSSl7dmFyIEQ9SVswXVswXSxSPUlbMF1bMV0sQz1ELGo9UjtyZXR1cm4gSS5mb3JFYWNoKGZ1bmN0aW9uKCQpe3ZhciBIPSRbMF0sSj0kWzJdLHE9JFs0XSxGPSRbNl0sRz0kWzFdLFo9JFszXSx0dD0kWzVdLGV0PSRbN107RD1NYXRoLm1pbihELEgsSixxLEYpLFI9TWF0aC5taW4oUixHLFosdHQsZXQpLEM9TWF0aC5tYXgoQyxILEoscSxGKSxqPU1hdGgubWF4KGosRyxaLHR0LGV0KX0pLFtELFIsQyxqXX1mdW5jdGlvbiB2KEksRCl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhJWzBdLURbMF0sMikrTWF0aC5wb3coSVsxXS1EWzFdLDIpKStNYXRoLnNxcnQoTWF0aC5wb3coSVsyXS1EWzJdLDIpK01hdGgucG93KElbM10tRFszXSwyKSl9ZnVuY3Rpb24gUChJLEQpe3ZhciBSPUlbMF0sQz1JWzJdLGo9SVs0XSwkPUlbNl0sSD1JWzFdLEo9SVszXSxxPUlbNV0sRj1JWzddLEc9RFswXSxaPURbMl0sdHQ9RFs0XSxldD1EWzZdLGl0PURbMV0saz1EWzNdLGh0PURbNV0sZnQ9RFs3XTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KEctUiwyKStNYXRoLnBvdyhpdC1ILDIpKStNYXRoLnNxcnQoTWF0aC5wb3coWi1DLDIpK01hdGgucG93KGstSiwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KHR0LWosMikrTWF0aC5wb3coaHQtcSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KGV0LSQsMikrTWF0aC5wb3coZnQtRiwyKSl9ZnVuY3Rpb24gaShJLEQpe3ZhciBSPWEoSS5sZW5ndGgpLEM9W107Ui5mb3JFYWNoKGZ1bmN0aW9uKCQpe3ZhciBIPTAsSj0wOyQuZm9yRWFjaChmdW5jdGlvbihxKXtIKz1QKElbcV0sRFtKKytdKX0pLEMucHVzaCh7aW5kZXg6JCxkaXN0YW5jZTpIfSl9KSxDLnNvcnQoZnVuY3Rpb24oJCxIKXtyZXR1cm4gJC5kaXN0YW5jZS1ILmRpc3RhbmNlfSk7dmFyIGo9W107cmV0dXJuIENbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbigkKXtqLnB1c2goSVskXSl9KSxqfWZ1bmN0aW9uIHUoSSxEKXt2YXIgUj1oKEkubGVuZ3RoKSxDPVtdO1IuZm9yRWFjaChmdW5jdGlvbigkKXt2YXIgSD0wOyQuZm9yRWFjaChmdW5jdGlvbihKKXtIKz12KE8oSVtKXSksTyhEW0pdKSl9KSxDLnB1c2goe2luZGV4OiQsZGlzdGFuY2U6SH0pfSksQy5zb3J0KGZ1bmN0aW9uKCQsSCl7cmV0dXJuICQuZGlzdGFuY2UtSC5kaXN0YW5jZX0pO3ZhciBqPVtdO3JldHVybiBDWzBdLmluZGV4LmZvckVhY2goZnVuY3Rpb24oJCl7ai5wdXNoKElbJF0pfSksan1mdW5jdGlvbiBhKEkpe2Zvcih2YXIgRD1bXSxSPTA7UjxJO1IrKyl7Zm9yKHZhciBDPVtdLGo9MDtqPEk7aisrKXt2YXIgJD1qK1I7JD5JLTEmJigkLT1JKSxDWyRdPWp9RC5wdXNoKEMpfXJldHVybiBEfWZ1bmN0aW9uIGgoSSl7Zm9yKHZhciBEPVtdLFI9MDtSPEk7UisrKUQucHVzaChSKTtyZXR1cm4gYihEKX1mdW5jdGlvbiBiKEkpe3ZhciBEPVtdLFI9W107ZnVuY3Rpb24gQyhqKXt2YXIgJCxIO2ZvcigkPTA7JDxqLmxlbmd0aDskKyspSD1qLnNwbGljZSgkLDEpWzBdLFIucHVzaChIKSxqLmxlbmd0aD09MCYmRC5wdXNoKFIuc2xpY2UoKSksQyhqKSxqLnNwbGljZSgkLDAsSCksUi5wb3AoKTtyZXR1cm4gRH1yZXR1cm4gQyhJKX12YXIgRT17fTtFLnBhcnNlcj15LEUubGVycEN1cnZlPWZ1bmN0aW9uKEksRCxSKXtyZXR1cm4gRS5sZXJwUG9pbnRzKElbMF0sSVsxXSxEWzBdLERbMV0sUikuY29uY2F0KEUubGVycFBvaW50cyhJWzJdLElbM10sRFsyXSxEWzNdLFIpKS5jb25jYXQoRS5sZXJwUG9pbnRzKElbNF0sSVs1XSxEWzRdLERbNV0sUikpLmNvbmNhdChFLmxlcnBQb2ludHMoSVs2XSxJWzddLERbNl0sRFs3XSxSKSl9LEUubGVycFBvaW50cz1mdW5jdGlvbihJLEQsUixDLGope3JldHVybltJKyhSLUkpKmosRCsoQy1EKSpqXX0sRS5xMmI9ZnVuY3Rpb24oSSxELFIsQyxqLCQpe3JldHVybltJLEQsKEkrMipSKS8zLChEKzIqQykvMywoaisyKlIpLzMsKCQrMipDKS8zLGosJF19LEUucGF0aDJzaGFwZXM9ZnVuY3Rpb24oSSl7Zm9yKHZhciBEPUUucGFyc2VyKEkpLFI9MCxDPTAsaj0wLCQ9RC5sZW5ndGgsSD1bXSxKPW51bGwscT12b2lkIDAsRj12b2lkIDAsRz12b2lkIDAsWj12b2lkIDAsdHQ9dm9pZCAwLGV0PXZvaWQgMCxpdD12b2lkIDA7ajwkO2orKyl7dmFyIGs9RFtqXSxodD1rWzBdLGZ0PURbai0xXTtzd2l0Y2goaHQpe2Nhc2UibSI6dHQ9SC5sZW5ndGgsSFt0dF09W10sSj1IW3R0XSxSPVIra1sxXSxDPUMra1syXTticmVhaztjYXNlIk0iOnR0PUgubGVuZ3RoLEhbdHRdPVtdLEo9SFt0dF0sUj1rWzFdLEM9a1syXTticmVhaztjYXNlImwiOkoucHVzaChbUixDLFIsQyxSLEMsUitrWzFdLEMra1syXV0pLFIrPWtbMV0sQys9a1syXTticmVhaztjYXNlIkwiOkoucHVzaChbUixDLGtbMV0sa1syXSxrWzFdLGtbMl0sa1sxXSxrWzJdXSksUj1rWzFdLEM9a1syXTticmVhaztjYXNlImgiOkoucHVzaChbUixDLFIsQyxSLEMsUitrWzFdLENdKSxSKz1rWzFdO2JyZWFrO2Nhc2UiSCI6Si5wdXNoKFtSLEMsa1sxXSxDLGtbMV0sQyxrWzFdLENdKSxSPWtbMV07YnJlYWs7Y2FzZSJ2IjpKLnB1c2goW1IsQyxSLEMsUixDLFIsQytrWzFdXSksQys9a1sxXTticmVhaztjYXNlIlYiOkoucHVzaChbUixDLFIsa1sxXSxSLGtbMV0sUixrWzFdXSksQz1rWzFdO2JyZWFrO2Nhc2UiQyI6Si5wdXNoKFtSLEMsa1sxXSxrWzJdLGtbM10sa1s0XSxrWzVdLGtbNl1dKSxSPWtbNV0sQz1rWzZdO2JyZWFrO2Nhc2UiUyI6ZnRbMF09PT0iQyJ8fGZ0WzBdPT09ImMiP0oucHVzaChbUixDLFIrZnRbNV0tZnRbM10sQytmdFs2XS1mdFs0XSxrWzFdLGtbMl0sa1szXSxrWzRdXSk6KGZ0WzBdPT09IlMifHxmdFswXT09PSJzIikmJkoucHVzaChbUixDLFIrZnRbM10tZnRbMV0sQytmdFs0XS1mdFsyXSxrWzFdLGtbMl0sa1szXSxrWzRdXSksUj1rWzNdLEM9a1s0XTticmVhaztjYXNlImMiOkoucHVzaChbUixDLFIra1sxXSxDK2tbMl0sUitrWzNdLEMra1s0XSxSK2tbNV0sQytrWzZdXSksUj1SK2tbNV0sQz1DK2tbNl07YnJlYWs7Y2FzZSJzIjpmdFswXT09PSJDInx8ZnRbMF09PT0iYyI/Si5wdXNoKFtSLEMsUitmdFs1XS1mdFszXSxDK2Z0WzZdLWZ0WzRdLFIra1sxXSxDK2tbMl0sUitrWzNdLEMra1s0XV0pOihmdFswXT09PSJTInx8ZnRbMF09PT0icyIpJiZKLnB1c2goW1IsQyxSK2Z0WzNdLWZ0WzFdLEMrZnRbNF0tZnRbMl0sUitrWzFdLEMra1syXSxSK2tbM10sQytrWzRdXSksUj1SK2tbM10sQz1DK2tbNF07YnJlYWs7Y2FzZSJhIjpldD1mKHtyeDprWzFdLHJ5OmtbMl0scHg6UixweTpDLHhBeGlzUm90YXRpb246a1szXSxsYXJnZUFyY0ZsYWc6a1s0XSxzd2VlcEZsYWc6a1s1XSxjeDpSK2tbNl0sY3k6QytrWzddfSksaXQ9ZXRbZXQubGVuZ3RoLTFdLGV0LmZvckVhY2goZnVuY3Rpb24oQixXKXtXPT09MD9KLnB1c2goW1IsQyxCLngxLEIueTEsQi54MixCLnkyLEIueCxCLnldKTpKLnB1c2goW2V0W1ctMV0ueCxldFtXLTFdLnksQi54MSxCLnkxLEIueDIsQi55MixCLngsQi55XSl9KSxSPWl0LngsQz1pdC55O2JyZWFrO2Nhc2UiQSI6ZXQ9Zih7cng6a1sxXSxyeTprWzJdLHB4OlIscHk6Qyx4QXhpc1JvdGF0aW9uOmtbM10sbGFyZ2VBcmNGbGFnOmtbNF0sc3dlZXBGbGFnOmtbNV0sY3g6a1s2XSxjeTprWzddfSksaXQ9ZXRbZXQubGVuZ3RoLTFdLGV0LmZvckVhY2goZnVuY3Rpb24oQixXKXtXPT09MD9KLnB1c2goW1IsQyxCLngxLEIueTEsQi54MixCLnkyLEIueCxCLnldKTpKLnB1c2goW2V0W1ctMV0ueCxldFtXLTFdLnksQi54MSxCLnkxLEIueDIsQi55MixCLngsQi55XSl9KSxSPWl0LngsQz1pdC55O2JyZWFrO2Nhc2UiUSI6Si5wdXNoKEUucTJiKFIsQyxrWzFdLGtbMl0sa1szXSxrWzRdKSksUj1rWzNdLEM9a1s0XTticmVhaztjYXNlInEiOkoucHVzaChFLnEyYihSLEMsUitrWzFdLEMra1syXSxrWzNdK1Isa1s0XStDKSksUis9a1szXSxDKz1rWzRdO2JyZWFrO2Nhc2UiVCI6ZnRbMF09PT0iUSJ8fGZ0WzBdPT09InEiPyhHPVIrZnRbM10tZnRbMV0sWj1DK2Z0WzRdLWZ0WzJdLEoucHVzaChFLnEyYihSLEMsRyxaLGtbMV0sa1syXSkpKTooZnRbMF09PT0iVCJ8fGZ0WzBdPT09InQiKSYmKEoucHVzaChFLnEyYihSLEMsUitSLUcsQytDLVosa1sxXSxrWzJdKSksRz1SK1ItRyxaPUMrQy1aKSxSPWtbMV0sQz1rWzJdO2JyZWFrO2Nhc2UidCI6ZnRbMF09PT0iUSJ8fGZ0WzBdPT09InEiPyhHPVIrZnRbM10tZnRbMV0sWj1DK2Z0WzRdLWZ0WzJdLEoucHVzaChFLnEyYihSLEMsRyxaLFIra1sxXSxDK2tbMl0pKSk6KGZ0WzBdPT09IlQifHxmdFswXT09PSJ0IikmJihKLnB1c2goRS5xMmIoUixDLFIrUi1HLEMrQy1aLFIra1sxXSxDK2tbMl0pKSxHPVIrUi1HLFo9QytDLVopLFIrPWtbMV0sQys9a1syXTticmVhaztjYXNlIloiOnE9SlswXVswXSxGPUpbMF1bMV0sSi5wdXNoKFtSLEMscSxGLHEsRixxLEZdKTticmVhaztjYXNlInoiOnE9SlswXVswXSxGPUpbMF1bMV0sSi5wdXNoKFtSLEMscSxGLHEsRixxLEZdKTticmVha319cmV0dXJuIEh9LEUuX3VwQ3VydmVzPWZ1bmN0aW9uKEksRCl7Zm9yKHZhciBSPTAsQz0wLGo9SS5sZW5ndGg7UjxEO1IrKylJLnB1c2goSVtDXS5zbGljZSgwKSksQysrLEM+ai0xJiYoQy09ail9O2Z1bmN0aW9uIEEoSSxELFIsQyxqLCQsSCxKLHEpe3JldHVybntsZWZ0OkwoSSxELFIsQyxqLCQsSCxKLHEpLHJpZ2h0OkwoSCxKLGosJCxSLEMsSSxELDEtcSwhMCl9fWZ1bmN0aW9uIEwoSSxELFIsQyxqLCQsSCxKLHEsRil7dmFyIEc9KFItSSkqcStJLFo9KEMtRCkqcStELHR0PShqLVIpKnErUixldD0oJC1DKSpxK0MsaXQ9KEgtaikqcStqLGs9KEotJCkqcSskLGh0PSh0dC1HKSpxK0csZnQ9KGV0LVopKnErWixCPShpdC10dCkqcSt0dCxXPShrLWV0KSpxK2V0LFY9KEItaHQpKnEraHQsWD0oVy1mdCkqcStmdDtyZXR1cm4gRj9bVixYLGh0LGZ0LEcsWixJLERdOltJLEQsRyxaLGh0LGZ0LFYsWF19RS5fc3BsaXRDdXJ2ZXM9ZnVuY3Rpb24oSSxEKXtmb3IodmFyIFI9MCxDPTA7UjxEO1IrKyl7dmFyIGo9SVtDXSwkPUEoalswXSxqWzFdLGpbMl0salszXSxqWzRdLGpbNV0sals2XSxqWzddLC41KTtJLnNwbGljZShDLDEpLEkuc3BsaWNlKEMsMCwkLmxlZnQsJC5yaWdodCksQys9MixDPj1JLmxlbmd0aC0xJiYoQz0wKX19O2Z1bmN0aW9uIFMoSSxEKXtmb3IodmFyIFI9ZnVuY3Rpb24oJCl7dmFyIEg9SVtJLmxlbmd0aC0xXSxKPVtdO0guZm9yRWFjaChmdW5jdGlvbihxKXtKLnB1c2gocS5zbGljZSgwKSl9KSxJLnB1c2goSil9LEM9MDtDPEQ7QysrKVIoKX1yZXR1cm4gRS5sZXJwPWZ1bmN0aW9uKEksRCxSKXtyZXR1cm4gRS5fbGVycChFLnBhdGgyc2hhcGVzKEkpLEUucGF0aDJzaGFwZXMoRCksUil9LEUuTUlNX0NVUlZFU19DT1VOVD0xMDAsRS5fcHJlcHJvY2Vzc2luZz1mdW5jdGlvbihJLEQpe3ZhciBSPUkubGVuZ3RoLEM9RC5sZW5ndGgsaj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEkpKSwkPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoRCkpO3JldHVybiBSPkM/UygkLFItQyk6UjxDJiZTKGosQy1SKSxqPXUoaiwkKSxqLmZvckVhY2goZnVuY3Rpb24oSCxKKXt2YXIgcT1ILmxlbmd0aCxGPSRbSl0ubGVuZ3RoO3E+Rj9xPEUuTUlNX0NVUlZFU19DT1VOVD8oRS5fc3BsaXRDdXJ2ZXMoSCxFLk1JTV9DVVJWRVNfQ09VTlQtcSksRS5fc3BsaXRDdXJ2ZXMoJFtKXSxFLk1JTV9DVVJWRVNfQ09VTlQtRikpOkUuX3NwbGl0Q3VydmVzKCRbSl0scS1GKTpxPEYmJihGPEUuTUlNX0NVUlZFU19DT1VOVD8oRS5fc3BsaXRDdXJ2ZXMoSCxFLk1JTV9DVVJWRVNfQ09VTlQtcSksRS5fc3BsaXRDdXJ2ZXMoJFtKXSxFLk1JTV9DVVJWRVNfQ09VTlQtRikpOkUuX3NwbGl0Q3VydmVzKEgsRi1xKSl9KSxqLmZvckVhY2goZnVuY3Rpb24oSCxKKXtqW0pdPWkoSCwkW0pdKX0pLFtqLCRdfSxFLl9sZXJwPWZ1bmN0aW9uKEksRCxSKXt2YXIgQz1bXTtyZXR1cm4gSS5mb3JFYWNoKGZ1bmN0aW9uKGosJCl7dmFyIEg9W107ai5mb3JFYWNoKGZ1bmN0aW9uKEoscSl7SC5wdXNoKEUubGVycEN1cnZlKEosRFskXVtxXSxSKSl9KSxDLnB1c2goSCl9KSxDfSxFLmFuaW1hdGU9ZnVuY3Rpb24oSSl7dmFyIEQ9RS5wYXRoMnNoYXBlcyhJLmZyb20pLFI9RS5wYXRoMnNoYXBlcyhJLnRvKSxDPUUuX3ByZXByb2Nlc3NpbmcoRCxSKSxqPW5ldyBEYXRlLCQ9SS5lbmR8fGZ1bmN0aW9uKCl7fSxIPUkucHJvZ3Jlc3N8fGZ1bmN0aW9uKCl7fSxKPUkuYmVnaW58fGZ1bmN0aW9uKCl7fSxxPUkuZWFzaW5nfHxmdW5jdGlvbihldCl7cmV0dXJuIGV0fSxGPW51bGwsRz1udWxsLFo9SS50aW1lO0ooRCk7dmFyIHR0PWZ1bmN0aW9uIGV0KCl7dmFyIGl0PW5ldyBEYXRlLWo7aWYoaXQ+PVope0c9UixIKEcsMSksJChHKSxjYW5jZWxBbmltYXRpb25GcmFtZShGKTtyZXR1cm59dmFyIGs9cShpdC9aKTtHPUUuX2xlcnAoQ1swXSxDWzFdLGspLEgoRyxrKSxGPXJlcXVlc3RBbmltYXRpb25GcmFtZShldCl9O3R0KCl9LEV9KX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoNzEpLG49dCgyMjEpLHM9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtjbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGcpe3N1cGVyKGcpLHRoaXNbbF0oe2Q6IiIsbm9ybWFsaXplOiExLGZpbGxDb2xvcjp2b2lkIDAsZmlsbFJ1bGU6Im5vbnplcm8iLHN0cm9rZUNvbG9yOnZvaWQgMCxsaW5lV2lkdGg6MSxsaW5lSm9pbjoibWl0ZXIiLGxpbmVDYXA6ImJ1dHQiLHJvdW5kU2VnbWVudHM6MjAsbGluZURhc2g6dm9pZCAwLGxpbmVEYXNoT2Zmc2V0OjAsbWl0ZXJMaW1pdDoxMCx0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMCxjbGlwUGF0aDp2b2lkIDB9KX1nZXQgZCgpe3JldHVybiB0aGlzW29dKCJkIil9c2V0IGQoZyl7dGhpc1tjXSgiZCIsZyl9Z2V0IG5vcm1hbGl6ZSgpe3JldHVybiB0aGlzW29dKCJub3JtYWxpemUiKX1zZXQgbm9ybWFsaXplKGcpe3RoaXNbY10oIm5vcm1hbGl6ZSIsISFnKX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbb10oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IoZyl7dGhpc1tjXSgiZmlsbENvbG9yIixPYmplY3Qobi5wYXJzZUNvbG9yKShnKSl9Z2V0IGZpbGxSdWxlKCl7cmV0dXJuIHRoaXNbb10oImZpbGxSdWxlIil9c2V0IGZpbGxSdWxlKGcpe2lmKGchPW51bGwmJmchPT0ibm9uemVybyImJmchPT0iZXZlbm9kZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaWxsIHJ1bGUuIik7dGhpc1tjXSgiZmlsbFJ1bGUiLGcpfWdldCBzdHJva2VDb2xvcigpe3JldHVybiB0aGlzW29dKCJzdHJva2VDb2xvciIpfXNldCBzdHJva2VDb2xvcihnKXt0aGlzW2NdKCJzdHJva2VDb2xvciIsT2JqZWN0KG4ucGFyc2VDb2xvcikoZykpfWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tvXSgibGluZVdpZHRoIil9c2V0IGxpbmVXaWR0aChnKXt0aGlzW2NdKCJsaW5lV2lkdGgiLE9iamVjdChzLnRvTnVtYmVyKShnKSl9Z2V0IGxpbmVKb2luKCl7cmV0dXJuIHRoaXNbb10oImxpbmVKb2luIil9c2V0IGxpbmVKb2luKGcpe2lmKGchPW51bGwmJmchPT0ibWl0ZXIiJiZnIT09ImJldmVsIiYmZyE9PSJyb3VuZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lSm9pbiB0eXBlLiIpO3RoaXNbY10oImxpbmVKb2luIixnKX1nZXQgbGluZUNhcCgpe3JldHVybiB0aGlzW29dKCJsaW5lQ2FwIil9c2V0IGxpbmVDYXAoZyl7aWYoZyE9bnVsbCYmZyE9PSJidXR0IiYmZyE9PSJzcXVhcmUiJiZnIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVDYXAgdHlwZS4iKTt0aGlzW2NdKCJsaW5lQ2FwIixnKX1nZXQgbGluZURhc2goKXtyZXR1cm4gdGhpc1tvXSgibGluZURhc2giKX1zZXQgbGluZURhc2goZyl7Zz1PYmplY3Qocy50b0FycmF5KShnLCEwKSxnIT1udWxsJiYhQXJyYXkuaXNBcnJheShnKSYmKGc9W2ddKSx0aGlzW2NdKCJsaW5lRGFzaCIsZz9nLm1hcChzLnRvTnVtYmVyKTpudWxsKX1nZXQgbGluZURhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1tvXSgibGluZURhc2hPZmZzZXQiKX1zZXQgbGluZURhc2hPZmZzZXQoZyl7dGhpc1tjXSgibGluZURhc2hPZmZzZXQiLE9iamVjdChzLnRvTnVtYmVyKShnKSl9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tvXSgibWl0ZXJMaW1pdCIpfXNldCBtaXRlckxpbWl0KGcpe3RoaXNbY10oIm1pdGVyTGltaXQiLE9iamVjdChzLnRvTnVtYmVyKShnKSl9Z2V0IHJvdW5kU2VnbWVudHMoKXtyZXR1cm4gdGhpc1tvXSgicm91bmRTZWdtZW50cyIpfXNldCByb3VuZFNlZ21lbnRzKGcpe3RoaXNbY10oInJvdW5kU2VnbWVudHMiLGcpfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbb10oInRleHR1cmUiKX1zZXQgdGV4dHVyZShnKXt0aGlzW2NdKCJ0ZXh0dXJlIixnKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1tvXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoZyl7dGhpc1tjXSgidGV4dHVyZVJlY3QiLGcpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbb10oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChnKXt0aGlzW2NdKCJzb3VyY2VSZWN0IixnKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW29dKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoZyl7dGhpc1tjXSgidGV4dHVyZVJlcGVhdCIsISFnKX1nZXQgY2xpcFBhdGgoKXtyZXR1cm4gdGhpc1tvXSgiY2xpcFBhdGgiKX1zZXQgY2xpcFBhdGgoZyl7dGhpc1tjXSgiY2xpcFBhdGgiLGcpfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIyNiksbj10KDIxMykscz10KDIzMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwobyxmLHgpe3JldHVybiBmIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sZix7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bZl09eCxvfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3dpZHRoOmYsaGVpZ2h0Onh9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gZj4wJiZ4PjAmJnN1cGVyLmlzVmlzaWJsZX19bChjLCJBdHRyIixzLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywicmVjdCIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIHI9dCgyMjgpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIGYoZyl7Y29uc3R7d2lkdGg6eSxoZWlnaHQ6bX09ZztyZXR1cm5gTTAgMEwke3l9IDBMJHt5fSAke219TDAgJHttfVpgfWNsYXNzIHggZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tzXSh7d2lkdGg6MCxoZWlnaHQ6MH0pLHRoaXNbb10oInNpemUiKX1nZXQgZCgpe3JldHVybiB0aGlzW2NdKCJkIil9c2V0IGQoeSl7fWdldCB3aWR0aCgpe3JldHVybiB0aGlzW2NdKCJ3aWR0aCIpfXNldCB3aWR0aCh5KXtpZih5PU9iamVjdChuLnRvTnVtYmVyKSh5KSx0aGlzW2xdKCJ3aWR0aCIseSkpe2NvbnN0IG09Zih0aGlzKTt0aGlzW2xdKCJkIixtKX19Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzW2NdKCJoZWlnaHQiKX1zZXQgaGVpZ2h0KHkpe2lmKHk9T2JqZWN0KG4udG9OdW1iZXIpKHkpLHRoaXNbbF0oImhlaWdodCIseSkpe2NvbnN0IG09Zih0aGlzKTt0aGlzW2xdKCJkIixtKX19Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUoeSl7eT1PYmplY3Qobi50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpcy53aWR0aD15WzBdLHRoaXMuaGVpZ2h0PXlbMV19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxzPXQoMjM1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChvLGYseCl7cmV0dXJuIGYgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxmLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tmXT14LG99Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6Zn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmWzBdPjAmJmZbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX1sKGMsIkF0dHIiLHMuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJ0cmlhbmdsZSIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLHM9dCgyMzMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKG8sZix4KXtyZXR1cm4gZiBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGYse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2ZdPXgsb31jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtwb2ludHM6Zn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmLmxlbmd0aD4wJiZzdXBlci5pc1Zpc2libGV9fWwoYywiQXR0ciIscy5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInBvbHlsaW5lIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDIyOCksbj10KDcyKSxzPXQoMjM0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGY9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24geCh5KXtjb25zdHtwb2ludHM6bSxzbW9vdGg6VCxzbW9vdGhSYW5nZTpPLGNsb3NlOnZ9PXksUD1bXTtmb3IobGV0IHU9MDt1PG0ubGVuZ3RoO3UrPTIpUC5wdXNoKFttW3VdLG1bdSsxXV0pO2xldCBpPSIiO3JldHVybiBUP2k9T2JqZWN0KHMubWFrZVNtb290aEN1cnZlTGluZSkoUCxPKTpQLmxlbmd0aCYmKGk9YE0ke1AubWFwKHU9PnUuam9pbigiICIpKS5qb2luKCJMIil9YCksaSYmdiYmKGkrPSJaIiksaX1jbGFzcyBnIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKG0pe3N1cGVyKG0pLHRoaXNbbF0oe3BvaW50czpbXSxzbW9vdGg6ITEsc21vb3RoUmFuZ2U6WzBdLGNsb3NlVHlwZToibm9uZSJ9KSx0aGlzW2ZdKCJjbG9zZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbb10oImQiKX1zZXQgZChtKXt9Z2V0IGNsb3NlKCl7cmV0dXJuIHRoaXMuY2xvc2VUeXBlIT09Im5vbmUifXNldCBjbG9zZShtKXttPW0/Im5vcm1hbCI6Im5vbmUiLHRoaXMuY2xvc2VUeXBlPW19Z2V0IGNsb3NlVHlwZSgpe3JldHVybiB0aGlzW29dKCJjbG9zZVR5cGUiKX1zZXQgY2xvc2VUeXBlKG0pe2lmKG0hPW51bGwmJm0hPT0ibm9uZSImJm0hPT0ibm9ybWFsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNsb3NlVHlwZSB0eXBlLiIpO2lmKHRoaXNbY10oImNsb3NlVHlwZSIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IHNtb290aCgpe3JldHVybiB0aGlzW29dKCJzbW9vdGgiKX1zZXQgc21vb3RoKG0pe2lmKHRoaXNbY10oInNtb290aCIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IHNtb290aFJhbmdlKCl7cmV0dXJuIHRoaXNbb10oInNtb290aFJhbmdlIil9c2V0IHNtb290aFJhbmdlKG0pe2lmKG0mJiFBcnJheS5pc0FycmF5KG0pJiYobT1bbV0pLHRoaXNbY10oInNtb290aFJhbmdlIixtKSYmdGhpcy5zbW9vdGgpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IHBvaW50cygpe3JldHVybiB0aGlzW29dKCJwb2ludHMiKX1zZXQgcG9pbnRzKG0pe2lmKG09T2JqZWN0KG4udG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKSYmKG09bS5yZWR1Y2UoKFQsTyk9PkFycmF5LmlzQXJyYXkoTyk/Wy4uLlQsLi4uTy5tYXAodj0+T2JqZWN0KG4udG9OdW1iZXIpKHYpKV06Wy4uLlQsT2JqZWN0KG4udG9OdW1iZXIpKE8pXSxbXSkpLHRoaXNbY10oInBvaW50cyIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwibWFrZVNtb290aEN1cnZlTGluZSIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG4scz1bMF0pe2Z1bmN0aW9uIGwoZix4PS4xNjgsZz0uMTY4KXtsZXQgeSxtLFQsTztpZigobltmXS54PT09bltmKzFdLnh8fG5bZl0ueT09PW5bZisxXS55KSYmKHg9MCxnPTApLGY8MT8oeT1uWzBdLngrKG5bMV0ueC1uWzBdLngpKngsbT1uWzBdLnkrKG5bMV0ueS1uWzBdLnkpKngpOih5PW5bZl0ueCsobltmKzFdLngtbltmLTFdLngpKngsbT1uW2ZdLnkrKG5bZisxXS55LW5bZi0xXS55KSp4KSxmPm4ubGVuZ3RoLTMpe2NvbnN0IHY9bi5sZW5ndGgtMTtUPW5bdl0ueC0oblt2XS54LW5bdi0xXS54KSpnLE89blt2XS55LShuW3ZdLnktblt2LTFdLnkpKmd9ZWxzZSBUPW5bZisxXS54LShuW2YrMl0ueC1uW2ZdLngpKmcsTz1uW2YrMV0ueS0obltmKzJdLnktbltmXS55KSpnO3JldHVyblt7eDp5LHk6bX0se3g6VCx5Ok99XX1uPW4ubWFwKChbZix4XSk9Pih7eDpmLHk6eH0pKTtsZXQgYz0iIixvPTA7cmV0dXJuIG4uZm9yRWFjaCgoZix4KT0+e2lmKHg9PT0wKWMrPWBNJHtmLnh9ICR7Zi55fWA7ZWxzZXtmb3IoO3g+c1tvXTspbysrO2lmKG8lMil7Y29uc3RbZyx5XT1sKHgtMSk7Yys9YEMke1tnLngsZy55LHkueCx5LnksZi54LGYueV0uam9pbigiICIpfWB9ZWxzZSBjKz1gTCR7Zi54fSAke2YueX1gfX0pLGN9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHgpe2NvbnN0W2cseV09eC5zaWRlcztsZXQgbT14LmFuZ2xlJTM2MDtyZXR1cm4gbTwwJiYobSs9MzYwKSxtPU1hdGguUEkqbS8xODAsWzAsMCxnLDAseSpNYXRoLmNvcyhtKSx5Kk1hdGguc2luKG0pXX1jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGcpe3N1cGVyKGcpLHRoaXNbc10oe3NpZGVzOlswLDBdLGFuZ2xlOjYwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZyl7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW2NdKCJzaWRlcyIpfXNldCBzaWRlcyhnKXtpZihnPU9iamVjdChuLnRvQXJyYXkpKGcsITApLGchPW51bGwmJiFBcnJheS5pc0FycmF5KGcpJiYoZz1bZyxnXSksdGhpc1tsXSgic2lkZXMiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW2NdKCJhbmdsZSIpfXNldCBhbmdsZShnKXtpZihnPU9iamVjdChuLnRvTnVtYmVyKShnKSx0aGlzW2xdKCJhbmdsZSIsZykpe2NvbnN0IHk9byh0aGlzKTtzdXBlci5wb2ludHM9eX19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxzPXQoMjM3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChvLGYseCl7cmV0dXJuIGYgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxmLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tmXT14LG99Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6Zn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmWzBdPjAmJmZbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX1sKGMsIkF0dHIiLHMuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJwYXJhbGxlbCIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHgpe2NvbnN0W2cseV09eC5zaWRlcztsZXQgbT14LmFuZ2xlJTM2MDttPDAmJihtKz0zNjApLG09TWF0aC5QSSptLzE4MDtjb25zdCBUPXkqTWF0aC5jb3MobSksTz15Kk1hdGguc2luKG0pO3JldHVyblswLDAsZywwLFQrZyxPLFQsT119Y2xhc3MgZiBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihnKXtzdXBlcihnKSx0aGlzW3NdKHtzaWRlczpbMCwwXSxhbmdsZTo5MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGcpe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1tjXSgic2lkZXMiKX1zZXQgc2lkZXMoZyl7aWYoZz1PYmplY3Qobi50b0FycmF5KShnLCEwKSxnIT1udWxsJiYhQXJyYXkuaXNBcnJheShnKSYmKGc9W2csZ10pLHRoaXNbbF0oInNpZGVzIixnKSl7Y29uc3QgeT1vKHRoaXMpO3N1cGVyLnBvaW50cz15fX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1tjXSgiYW5nbGUiKX1zZXQgYW5nbGUoZyl7aWYoZz1PYmplY3Qobi50b051bWJlcikoZyksdGhpc1tsXSgiYW5nbGUiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIzMiksbj10KDIxMykscz10KDIzOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwobyxmLHgpe3JldHVybiBmIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sZix7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bZl09eCxvfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7fWwoYywiQXR0ciIscy5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInJlZ3VsYXIiKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMjMzKSxuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBzPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gbyh4KXtjb25zdHtlZGdlczpnLHJhZGl1czp5LG9mZnNldEFuZ2xlOm19PXgsVD1NYXRoLlBJKm0vMTgwLS41Kk1hdGguUEk7aWYoZzwzfHx5PD0wKXJldHVybltdO2NvbnN0IE89W107Zm9yKGxldCB2PTA7djxnO3YrKyl7Y29uc3QgUD12KjIqTWF0aC5QSS9nK1QsaT15Kk1hdGguY29zKFApLHU9eSpNYXRoLnNpbihQKTtPLnB1c2goaSx1KX1yZXR1cm4gT31jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGcpe3N1cGVyKGcpLHRoaXNbc10oe2VkZ2VzOjMscmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGcpe31nZXQgZWRnZXMoKXtyZXR1cm4gdGhpc1tjXSgiZWRnZXMiKX1zZXQgZWRnZXMoZyl7aWYoZz1PYmplY3Qobi50b051bWJlcikoZyksdGhpc1tsXSgiZWRnZXMiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCByYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgicmFkaXVzIil9c2V0IHJhZGl1cyhnKXtpZihnPU9iamVjdChuLnRvTnVtYmVyKShnKSx0aGlzW2xdKCJyYWRpdXMiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW2NdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShnKXtpZihnPU9iamVjdChuLnRvTnVtYmVyKShnKSx0aGlzW2xdKCJvZmZzZXRBbmdsZSIsZykpe2NvbnN0IHk9byh0aGlzKTtzdXBlci5wb2ludHM9eX19fX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxzPXQoMjQxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChvLGYseCl7cmV0dXJuIGYgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxmLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tmXT14LG99Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHt9bChjLCJBdHRyIixzLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywic3RhciIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHgpe2NvbnN0e2FuZ2xlczpnLGlubmVyUmFkaXVzOnksb3V0ZXJSYWRpdXM6bSxvZmZzZXRBbmdsZTpUfT14LE89TWF0aC5QSSpULzE4MC0uNSpNYXRoLlBJO2lmKGc8M3x8eTw9MHx8bTw9MClyZXR1cm5bXTtjb25zdCB2PVtdO2ZvcihsZXQgUD0wO1A8ZyoyO1ArKyl7Y29uc3QgaT1QKk1hdGguUEkvZytPLHU9UCUyP3k6bSxhPXUqTWF0aC5jb3MoaSksaD11Kk1hdGguc2luKGkpO3YucHVzaChhLGgpfXJldHVybiB2fWNsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZyl7c3VwZXIoZyksdGhpc1tzXSh7YW5nbGVzOjUsaW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhnKXt9Z2V0IGFuZ2xlcygpe3JldHVybiB0aGlzW2NdKCJhbmdsZXMiKX1zZXQgYW5nbGVzKGcpe2lmKGc9T2JqZWN0KG4udG9OdW1iZXIpKGcpLHRoaXNbbF0oImFuZ2xlcyIsZykpe2NvbnN0IHk9byh0aGlzKTtzdXBlci5wb2ludHM9eX19Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKGcpe2lmKGc9T2JqZWN0KG4udG9OdW1iZXIpKGcpLHRoaXNbbF0oImlubmVyUmFkaXVzIixnKSl7Y29uc3QgeT1vKHRoaXMpO3N1cGVyLnBvaW50cz15fX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoZyl7aWYoZz1PYmplY3Qobi50b051bWJlcikoZyksdGhpc1tsXSgib3V0ZXJSYWRpdXMiLGcpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKGcpe2c9T2JqZWN0KG4udG9BcnJheSkoZywhMCksQXJyYXkuaXNBcnJheShnKXx8KGc9W2csZ10pLHRoaXMuaW5uZXJSYWRpdXM9Z1swXSx0aGlzLm91dGVyUmFkaXVzPWdbMV19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbY10oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGcpe2lmKGc9T2JqZWN0KG4udG9OdW1iZXIpKGcpLHRoaXNbbF0oIm9mZnNldEFuZ2xlIixnKSl7Y29uc3QgeT1vKHRoaXMpO3N1cGVyLnBvaW50cz15fX19fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLHM9dCgyNDMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKG8sZix4KXtyZXR1cm4gZiBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGYse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2ZdPXgsb31jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtyYWRpdXNYOmYscmFkaXVzWTp4LHN0YXJ0QW5nbGU6ZyxlbmRBbmdsZTp5fT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGY+MCYmeD4wJiZnIT09eSYmc3VwZXIuaXNWaXNpYmxlfX1sKGMsIkF0dHIiLHMuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJlbGxpcHNlIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxzPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB4KHkpe2NvbnN0e3JhZGl1c1g6bSxyYWRpdXNZOlQsc3RhcnRBbmdsZTpPLGVuZEFuZ2xlOnYsZGlyZWN0aW9uOlAsY2xvc2VUeXBlOml9PXksdT1QPT09ImFuaXRjbG9ja3dpc2UiLGE9bmV3IHIuRmlndXJlMkQ7cmV0dXJuIGk9PT0ic2VjdG9yIiYmYS5tb3ZlVG8oMCwwKSxhLmVsbGlwc2UoMCwwLG0sVCwwLE1hdGguUEkqTy8xODAsTWF0aC5QSSp2LzE4MCx1KSxpIT09Im5vbmUiJiZhLmNsb3NlUGF0aCgpLGEucGF0aC5yZWR1Y2UoKEUsQSk9PkUrQS5qb2luKCIgIiksIiIpfWNsYXNzIGcgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IobSl7c3VwZXIobSksdGhpc1tsXSh7cmFkaXVzWDowLHJhZGl1c1k6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwLGRpcmVjdGlvbjoiY2xvY2t3aXNlIixjbG9zZVR5cGU6Im5vbmUifSksdGhpc1tmXSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW29dKCJkIil9c2V0IGQobSl7fWdldCByYWRpdXNYKCl7cmV0dXJuIHRoaXNbb10oInJhZGl1c1giKX1zZXQgcmFkaXVzWChtKXtpZihtPU9iamVjdChzLnRvTnVtYmVyKShtKSx0aGlzW2NdKCJyYWRpdXNYIixtKSl7Y29uc3QgVD14KHRoaXMpO3RoaXNbY10oImQiLFQpfX1nZXQgcmFkaXVzWSgpe3JldHVybiB0aGlzW29dKCJyYWRpdXNZIil9c2V0IHJhZGl1c1kobSl7aWYobT1PYmplY3Qocy50b051bWJlcikobSksdGhpc1tjXSgicmFkaXVzWSIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLnJhZGl1c1gsdGhpcy5yYWRpdXNZXX1zZXQgcmFkaXVzKG0pe209T2JqZWN0KHMudG9BcnJheSkobSwhMCksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMucmFkaXVzWD1tWzBdLHRoaXMucmFkaXVzWT1tWzFdfWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKG0pe209T2JqZWN0KHMudG9BcnJheSkobSksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMuc3RhcnRBbmdsZT1tWzBdLHRoaXMuZW5kQW5nbGU9bVsxXX1nZXQgZGlyZWN0aW9uKCl7cmV0dXJuIHRoaXNbb10oImRpcmVjdGlvbiIpfXNldCBkaXJlY3Rpb24obSl7aWYobSE9bnVsbCYmbSE9PSJjbG9ja3dpc2UiJiZtIT09ImFudGljbG9ja3dpc2UiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZGlyZWN0aW9uIHR5cGUuIik7dGhpc1tjXSgiZGlyZWN0aW9uIixtKX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW29dKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUobSl7aWYobT1PYmplY3Qocy50b051bWJlcikobSksdGhpc1tjXSgic3RhcnRBbmdsZSIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbb10oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKG0pe2lmKG09T2JqZWN0KHMudG9OdW1iZXIpKG0pLHRoaXNbY10oImVuZEFuZ2xlIixtKSl7Y29uc3QgVD14KHRoaXMpO3RoaXNbY10oImQiLFQpfX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbb10oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUobSl7aWYobSE9bnVsbCYmbSE9PSJub25lIiYmbSE9PSJzZWN0b3IiJiZtIT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW2NdKCJjbG9zZVR5cGUiLG0pKXtjb25zdCBUPXgodGhpcyk7dGhpc1tjXSgiZCIsVCl9fX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDI0Miksbj10KDIxMykscz10KDI0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwobyxmLHgpe3JldHVybiBmIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sZix7dmFsdWU6eCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bZl09eCxvfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7fWwoYywiQXR0ciIscy5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsImFyYyIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIHI9dCgyNDMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIHMgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IHJhZGl1cygpe3JldHVybiBzdXBlci5yYWRpdXNYfXNldCByYWRpdXMoYyl7Yz1PYmplY3Qobi50b051bWJlcikoYyksc3VwZXIucmFkaXVzWD1jLHN1cGVyLnJhZGl1c1k9Y319fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLHM9dCgyNDcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKG8sZix4KXtyZXR1cm4gZiBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGYse3ZhbHVlOngsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2ZdPXgsb31jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtpbm5lclJhZGl1czpmLG91dGVyUmFkaXVzOngsc3RhcnRBbmdsZTpnLGVuZEFuZ2xlOnl9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4oZj4wfHx4PjApJiZnIT09eSYmc3VwZXIuaXNWaXNpYmxlfX1sKGMsIkF0dHIiLHMuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJyaW5nIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxzPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB4KHkpe2xldHtpbm5lclJhZGl1czptLG91dGVyUmFkaXVzOlQsc3RhcnRBbmdsZTpPLGVuZEFuZ2xlOnZ9PXk7Y29uc3QgUD1uZXcgci5GaWd1cmUyRDtpZihPPU1hdGguUEkqTy8xODAsdj1NYXRoLlBJKnYvMTgwLG0+VCYmKFttLFRdPVtULG1dKSxtPD0wJiZQLm1vdmVUbygwLDApLFAuYXJjKDAsMCxULE8sdiwhMSksbT4wKXtjb25zdCBhPU1hdGguUEkqMjt2PE8mJih2PU8rYSsodi1PKSVhKSx2LU8+PWEmJih2PU8rYS0xZS02KSxQLmFyYygwLDAsbSx2LE8sITApfXJldHVybiBQLmNsb3NlUGF0aCgpLFAucGF0aC5yZWR1Y2UoKGEsaCk9PmEraC5qb2luKCIgIiksIiIpfWNsYXNzIGcgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IobSl7c3VwZXIobSksdGhpc1tsXSh7aW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjB9KSx0aGlzW2ZdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbb10oImQiKX1zZXQgZChtKXt9Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbb10oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKG0pe2lmKG09T2JqZWN0KHMudG9OdW1iZXIpKG0pLHRoaXNbY10oImlubmVyUmFkaXVzIixtKSl7Y29uc3QgVD14KHRoaXMpO3RoaXNbY10oImQiLFQpfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tvXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMobSl7aWYobT1PYmplY3Qocy50b051bWJlcikobSksdGhpc1tjXSgib3V0ZXJSYWRpdXMiLG0pKXtjb25zdCBUPXgodGhpcyk7dGhpc1tjXSgiZCIsVCl9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKG0pe209T2JqZWN0KHMudG9BcnJheSkobSwhMCksQXJyYXkuaXNBcnJheShtKXx8KG09W20sbV0pLHRoaXMuaW5uZXJSYWRpdXM9bVswXSx0aGlzLm91dGVyUmFkaXVzPW1bMV19Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1tvXSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKG0pe2lmKG09T2JqZWN0KHMudG9OdW1iZXIpKG0pLHRoaXNbY10oInN0YXJ0QW5nbGUiLG0pKXtjb25zdCBUPXgodGhpcyk7dGhpc1tjXSgiZCIsVCl9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW29dKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZShtKXtpZihtPU9iamVjdChzLnRvTnVtYmVyKShtKSx0aGlzW2NdKCJlbmRBbmdsZSIsbSkpe2NvbnN0IFQ9eCh0aGlzKTt0aGlzW2NdKCJkIixUKX19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUobSl7bT1PYmplY3Qocy50b0FycmF5KShtKSxBcnJheS5pc0FycmF5KG0pfHwobT1bbSxtXSksdGhpcy5zdGFydEFuZ2xlPW1bMF0sdGhpcy5lbmRBbmdsZT1tWzFdfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgcj10KDEyKSxuPXQoMjE4KSxzPXQoMjE5KSxsPXQoMjQ5KSxjPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhPLHYsUCl7cmV0dXJuIHYgaW4gTz9PYmplY3QuZGVmaW5lUHJvcGVydHkoTyx2LHt2YWx1ZTpQLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6T1t2XT1QLE99Y29uc3QgZj1TeW1ib2woInRleHRJbWFnZSIpLHg9U3ltYm9sKCJ0ZXh0SW1hZ2VUYXNrIiksZz1TeW1ib2woInRleHR1cmVDb250ZXh0IikseT1TeW1ib2woInVwZGF0ZVRleHR1cmVSZWN0IiksbT1TeW1ib2woInRleHRDYW52YXMiKTtjbGFzcyBUIGV4dGVuZHMgcy5kZWZhdWx0e2NvbnN0cnVjdG9yKHY9e30pe3R5cGVvZiB2PT0ic3RyaW5nIiYmKHY9e3RleHQ6dn0pLHN1cGVyKHYpfWdldCBjb250ZW50U2l6ZSgpe2xldFt2LFBdPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOmksaGVpZ2h0OnV9PXRoaXMuYXR0cmlidXRlcztpZihpPT1udWxsfHx1PT1udWxsKXtjb25zdCBhPXRoaXNbZl07YSYmKGk9PW51bGwmJih2PWEucmVjdFsyXSksdT09bnVsbCYmKFA9YS5yZWN0WzNdKSl9cmV0dXJuW3YsUF19Z2V0IHRleHQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHQodil7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9dn1nZXQgdGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHRDb250ZW50KHYpe3RoaXMuYXR0cmlidXRlcy50ZXh0PXZ9Z2V0IHRleHRJbWFnZSgpe3JldHVybiB0aGlzW2ZdfHx7fX1nZXQgdGV4dEltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1t4XXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyh2KXtzdXBlci5kcmF3KHYpO2NvbnN0IFA9dGhpcy5tZXNoO2lmKFApe2NvbnN0IGk9dGhpc1tmXTtpZihpKXtsZXQgdT1QLnRleHR1cmU7aWYoIXV8fHRoaXNbZ10mJnRoaXNbZ10hPT10aGlzLnJlbmRlcmVyfHxpLm5lZWRzVXBkYXRlPyhpLm5lZWRzVXBkYXRlPSExLE9iamVjdChuLmRlbGV0ZVRleHR1cmUpKGkuaW1hZ2UsdGhpcy5yZW5kZXJlciksdT1PYmplY3Qobi5jcmVhdGVUZXh0dXJlKShpLmltYWdlLHRoaXMucmVuZGVyZXIpLHRoaXNbeV09ITApOnU9UC51bmlmb3Jtcy51X3RleFNhbXBsZXIsdGhpc1t5XSl7Y29uc3RbYSxoXT1pLnJlY3Quc2xpY2UoMiksW2IsRV09dGhpcy5jb250ZW50U2l6ZSxBPXRoaXMuYXR0cmlidXRlcy50ZXh0QWxpZ24sTD10aGlzLmF0dHJpYnV0ZXMudmVydGljYWxBbGlnbjtsZXQgUz0wO0E9PT0iY2VudGVyIj9TPShiLWEpLzI6KEE9PT0icmlnaHQifHxBPT09ImVuZCIpJiYoUz1iLWEpO2NvbnN0IEk9dGhpcy5hdHRyaWJ1dGVzLmZvbnRTaXplLEQ9dGhpcy5hdHRyaWJ1dGVzLmxpbmVIZWlnaHQ7bGV0IFI9MDtMPT09InRvcCI/Uj0oSS1EKS8yOkw9PT0iYm90dG9tIiYmKFI9KEQtSSkvMik7Y29uc3R7cGFkZGluZ0xlZnQ6QyxwYWRkaW5nVG9wOmp9PXRoaXMuYXR0cmlidXRlcyx7Ym9yZGVyV2lkdGg6JH09dGhpcy5hdHRyaWJ1dGVzO1MrPUMrJCxSKz1qKyQ7Y29uc3R7YW5jaG9yWDpILGFuY2hvclk6Sn09dGhpcy5hdHRyaWJ1dGVzO1MtPXRoaXMub2Zmc2V0U2l6ZVswXSpILFItPXRoaXMub2Zmc2V0U2l6ZVsxXSpKLFAuc2V0VGV4dHVyZSh1LHtyZWN0OltTLFIsYSxoXX0pLHRoaXNbeV09ITEsdGhpc1tnXT10aGlzLnJlbmRlcmVyfX19cmV0dXJuIHZ9b25Qcm9wZXJ0eUNoYW5nZSh2LFAsaSl7dj09PSJ0ZXh0Inx8dj09PSJmb250U2l6ZSJ8fHY9PT0iZm9udEZhbWlseSJ8fHY9PT0iZm9udFN0eWxlInx8dj09PSJmb250VmFyaWFudCJ8fHY9PT0iZm9udFdlaWdodCJ8fHY9PT0iZm9udFN0cmV0Y2gifHx2PT09ImxpbmVIZWlnaHQifHx2PT09InN0cm9rZUNvbG9yInx8dj09PSJmaWxsQ29sb3IifHx2PT09InN0cm9rZVdpZHRoIj90aGlzLnVwZGF0ZVRleHQoKTooKHY9PT0idGV4dEFsaWduInx8dj09PSJ2ZXJ0aWNhbEFsaWduIikmJih0aGlzW3ldPSEwKSxzdXBlci5vblByb3BlcnR5Q2hhbmdlKHYsUCxpKSl9dXBkYXRlQ29udG91cnMoKXtzdXBlci51cGRhdGVDb250b3VycygpLHRoaXNbeV09ITB9dXBkYXRlVGV4dCgpe3RoaXNbeF18fCh0aGlzW3hdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzW3hdPW51bGw7Y29uc3R7dGV4dDp2LGZvbnQ6UCxmaWxsQ29sb3I6aSxzdHJva2VDb2xvcjp1LHN0cm9rZVdpZHRoOmF9PXRoaXMuYXR0cmlidXRlcyxoPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtyZXR1cm4gdGhpc1ttXT10aGlzW21dfHxyLkVOVi5jcmVhdGVDYW52YXMoMSwxKSx0aGlzW2ZdPXIuRU5WLmNyZWF0ZVRleHQodix7Zm9udDpQLGZpbGxDb2xvcjppLHN0cm9rZUNvbG9yOnUsc3Ryb2tlV2lkdGg6YSxwYXJzZUZvbnQ6ci5wYXJzZUZvbnQscmF0aW86aCx0ZXh0Q2FudmFzOnRoaXNbbV19KSx0aGlzW2ZdLm5lZWRzVXBkYXRlPSEwLHRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpc1tmXX0pKX19byhULCJBdHRyIixsLmRlZmF1bHQpLGMuZGVmYXVsdC5yZWdpc3Rlck5vZGUoVCwibGFiZWwiKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciByPXQoMTIpLG49dCg3Mikscz10KDIyMSksbD10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx4PVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2NsYXNzIGcgZXh0ZW5kcyBsLmRlZmF1bHR7Y29uc3RydWN0b3IobSl7c3VwZXIobSksdGhpc1tjXSh7dGV4dDoiIixmb250U2l6ZToxNixmb250RmFtaWx5OiJIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZiIsZm9udFN0eWxlOiJub3JtYWwiLGZvbnRWYXJpYW50OiJub3JtYWwiLGZvbnRXZWlnaHQ6Im5vcm1hbCIsZm9udFN0cmV0Y2g6Im5vcm1hbCIsbGluZUhlaWdodDoiIix0ZXh0QWxpZ246ImxlZnQiLHN0cm9rZUNvbG9yOnZvaWQgMCxzdHJva2VXaWR0aDoxLGZpbGxDb2xvcjp2b2lkIDAsdmVydGljYWxBbGlnbjoibWlkZGxlIn0pLHRoaXNbeF0oImZvbnQiKX1nZXQgdGV4dCgpe3JldHVybiB0aGlzW2ZdKCJ0ZXh0Iil8fCIgIn1zZXQgdGV4dChtKXt0aGlzW29dKCJ0ZXh0IixtKX1nZXQgZm9udFNpemUoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFNpemUiKX1zZXQgZm9udFNpemUobSl7dGhpc1tvXSgiZm9udFNpemUiLE9iamVjdChuLnRvTnVtYmVyKShtKSl9Z2V0IGZvbnRGYW1pbHkoKXtyZXR1cm4gdGhpc1tmXSgiZm9udEZhbWlseSIpfXNldCBmb250RmFtaWx5KG0pe3RoaXNbb10oImZvbnRGYW1pbHkiLG0pfWdldCBmb250U3R5bGUoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFN0eWxlIil9c2V0IGZvbnRTdHlsZShtKXt0aGlzW29dKCJmb250U3R5bGUiLG0pfWdldCBmb250VmFyaWFudCgpe3JldHVybiB0aGlzW2ZdKCJmb250VmFyaWFudCIpfXNldCBmb250VmFyaWFudChtKXt0aGlzW29dKCJmb250VmFyaWFudCIsbSl9Z2V0IGZvbnRXZWlnaHQoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFdlaWdodCIpfXNldCBmb250V2VpZ2h0KG0pe3RoaXNbb10oImZvbnRXZWlnaHQiLG0pfWdldCBmb250U3RyZXRjaCgpe3JldHVybiB0aGlzW2ZdKCJmb250U3RyZXRjaCIpfXNldCBmb250U3RyZXRjaChtKXt0aGlzW29dKCJmb250U3RyZXRjaCIsbSl9Z2V0IGxpbmVIZWlnaHQoKXtyZXR1cm4gdGhpc1tmXSgibGluZUhlaWdodCIpfHx0aGlzLmZvbnRTaXplfXNldCBsaW5lSGVpZ2h0KG0pe3RoaXNbb10oImxpbmVIZWlnaHQiLE9iamVjdChuLnRvTnVtYmVyKShtKSl9Z2V0IHRleHRBbGlnbigpe3JldHVybiB0aGlzW2ZdKCJ0ZXh0QWxpZ24iKX1zZXQgdGV4dEFsaWduKG0pe3RoaXNbb10oInRleHRBbGlnbiIsbSl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbZl0oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKG0pe3RoaXNbb10oInN0cm9rZUNvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKShtKSl9Z2V0IHN0cm9rZVdpZHRoKCl7cmV0dXJuIHRoaXNbZl0oInN0cm9rZVdpZHRoIil9c2V0IHN0cm9rZVdpZHRoKG0pe3RoaXNbb10oInN0cm9rZVdpZHRoIixPYmplY3Qobi50b051bWJlcikobSkpfWdldCB2ZXJ0aWNhbEFsaWduKCl7cmV0dXJuIHRoaXNbZl0oInZlcnRpY2FsQWxpZ24iKX1zZXQgdmVydGljYWxBbGlnbihtKXt0aGlzW29dKCJ2ZXJ0aWNhbEFsaWduIixtKX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbZl0oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IobSl7dGhpc1tvXSgiZmlsbENvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKShtKSl9Z2V0IGZvbnQoKXtjb25zdHtmb250U3R5bGU6bSxmb250VmFyaWFudDpULGZvbnRXZWlnaHQ6Tyxmb250U3RyZXRjaDp2LGZvbnRTaXplOlAsbGluZUhlaWdodDppLGZvbnRGYW1pbHk6dX09dGhpcztyZXR1cm5gJHttfSAke1R9ICR7T30gJHt2fSAke1B9cHgvJHtpfXB4ICR7dX1gfXNldCBmb250KG0pe2lmKG09PW51bGwpdGhpcy5mb250U3R5bGU9bnVsbCx0aGlzLmZvbnRWYXJpYW50PW51bGwsdGhpcy5mb250V2VpZ2h0PW51bGwsdGhpcy5mb250U3RyZXRjaD1udWxsLHRoaXMuZm9udFNpemU9bnVsbCx0aGlzLmxpbmVIZWlnaHQ9bnVsbCx0aGlzLmZvbnRGYW1pbHk9bnVsbDtlbHNle2NvbnN0IFQ9T2JqZWN0KHIucGFyc2VGb250KShtKTt0aGlzLmZvbnRTdHlsZT1ULnN0eWxlLHRoaXMuZm9udFZhcmlhbnQ9VC52YXJpYW50LHRoaXMuZm9udFdlaWdodD1ULndlaWdodCx0aGlzLmZvbnRTdHJldGNoPVQuc3RyZXRjaCx0aGlzLmZvbnRTaXplPU9iamVjdChuLnRvTnVtYmVyKShgJHtULnNpemV9JHtULnVuaXR9YCksVC5saW5lSGVpZ2h0JiYodGhpcy5saW5lSGVpZ2h0PVQucHhMaW5lSGVpZ2h0KSx0aGlzLmZvbnRGYW1pbHk9VC5mYW1pbHl9fX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgcj10KDEyKSxuPXQoMjE5KSxzPXQoMjUxKSxsPXQoMjEzKSxjPXQoMjUyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhULE8sdil7cmV0dXJuIE8gaW4gVD9PYmplY3QuZGVmaW5lUHJvcGVydHkoVCxPLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6VFtPXT12LFR9Y29uc3QgZj1TeW1ib2woInpPcmRlciIpLHg9U3ltYm9sKCJvcmRlcmVkIiksZz1TeW1ib2woImNoaWxkcmVuIikseT1TeW1ib2woInNlYWxlZCIpO2NsYXNzIG0gZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoTz17fSl7c3VwZXIoTyksdGhpc1tnXT1bXSx0aGlzW3hdPW51bGwsdGhpc1tmXT0wfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuIHRoaXNbZ119Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXNbZ119Z2V0IG9yZGVyZWRDaGlsZHJlbigpe3JldHVybiB0aGlzW3hdfHwodGhpc1t4XT1bLi4udGhpc1tnXV0sdGhpc1t4XS5zb3J0KChPLHYpPT5PLnpJbmRleC12LnpJbmRleHx8Ty56T3JkZXItdi56T3JkZXIpKSx0aGlzW3hdfWFwcGVuZCguLi5PKXtyZXR1cm4gTy5tYXAodj0+dGhpcy5hcHBlbmRDaGlsZCh2KSl9YXBwZW5kQ2hpbGQoTyl7cmV0dXJuIE8ucmVtb3ZlKCksdGhpc1tnXS5wdXNoKE8pLE8uY29ubmVjdCh0aGlzLHRoaXNbZl0rKyksdGhpc1t4XSYmKHRoaXNbeF0ubGVuZ3RoJiZPLnpJbmRleDx0aGlzW3hdW3RoaXNbeF0ubGVuZ3RoLTFdLnpJbmRleD90aGlzLnJlb3JkZXIoKTp0aGlzW3hdLnB1c2goTykpLE99Y2xvbmVOb2RlKE89ITEpe2NvbnN0IHY9c3VwZXIuY2xvbmVOb2RlKCk7cmV0dXJuIE8mJnRoaXNbZ10uZm9yRWFjaChQPT57Y29uc3QgaT1QLmNsb25lTm9kZShPKTt2LmFwcGVuZENoaWxkKGkpfSksdn1kaXNwYXRjaFBvaW50ZXJFdmVudChPKXtjb25zdCB2PXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgUD12Lmxlbmd0aC0xO1A+PTA7UC0tKWlmKHZbUF0uZGlzcGF0Y2hQb2ludGVyRXZlbnQoTykpcmV0dXJuITA7cmV0dXJuIHN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KE8pfWRyYXcoTz1bXSl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PXRoaXMucmVuZGVyTWF0cml4LHN1cGVyLmRyYXcoTyksIXRoaXNbeV0mJnRoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiKXtjb25zdCB2PXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgUD0wO1A8di5sZW5ndGg7UCsrKXZbUF0uZHJhdyhPKX1yZXR1cm4gdGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PW51bGwsT31nZXRFbGVtZW50QnlJZChPKXtyZXR1cm4gT2JqZWN0KGMucXVlcnlTZWxlY3RvcikoYCMke099YCx0aGlzKX1nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKE8pe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yQWxsKShgLiR7T31gLHRoaXMpfWdldEVsZW1lbnRzQnlOYW1lKE8pe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yQWxsKShgW25hbWU9IiR7T30iXWAsdGhpcyl9Z2V0RWxlbWVudHNCeVRhZ05hbWUoTyl7cmV0dXJuIE9iamVjdChjLnF1ZXJ5U2VsZWN0b3JBbGwpKE8sdGhpcyl9aW5zZXJ0QmVmb3JlKE8sdil7aWYodj09bnVsbClyZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChPKTtPLnJlbW92ZSgpO2NvbnN0IFA9dGhpc1tnXS5pbmRleE9mKHYpO2lmKFA8MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7Y29uc3QgaT12LnpPcmRlcjtmb3IobGV0IHU9UDt1PHRoaXNbZ10ubGVuZ3RoO3UrKyl7Y29uc3QgYT10aGlzW2ddW3VdLnpPcmRlcixoPXRoaXNbZ11bdV07ZGVsZXRlIGguek9yZGVyLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLCJ6T3JkZXIiLHt2YWx1ZTphKzEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9aWYodGhpc1tnXS5zcGxpY2UoUCwwLE8pLE8uY29ubmVjdCh0aGlzLGkpLHRoaXNbeF0paWYoTy56SW5kZXghPT12LnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IHU9dGhpc1t4XS5pbmRleE9mKHYpO3RoaXNbeF0uc3BsaWNlKHUsMCxPKX1yZXR1cm4gT31xdWVyeVNlbGVjdG9yKE8pe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yKShPLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoTyl7cmV0dXJuIE9iamVjdChjLnF1ZXJ5U2VsZWN0b3JBbGwpKE8sdGhpcyl9cmVwbGFjZUNoaWxkKE8sdil7Ty5yZW1vdmUoKTtjb25zdCBQPXRoaXNbZ10uaW5kZXhPZih2KTtpZihQPDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2lmKHRoaXNbZ11bUF09TyxPLmNvbm5lY3QodGhpcyx2LnpPcmRlciksdGhpc1t4XSlpZihPLnpJbmRleCE9PXYuekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3QgaT10aGlzW3hdLmluZGV4T2Yodik7dGhpc1t4XVtpXT1PfXJldHVybiB2LmRpc2Nvbm5lY3QodGhpcyksT31yZW1vdmVBbGxDaGlsZHJlbigpe2NvbnN0IE89dGhpc1tnXTtmb3IobGV0IHY9Ty5sZW5ndGgtMTt2Pj0wO3YtLSlPW3ZdLnJlbW92ZSgpfXJlbW92ZUNoaWxkKE8pe2NvbnN0IHY9dGhpc1tnXS5pbmRleE9mKE8pO2lmKHY+PTApe2lmKHRoaXNbZ10uc3BsaWNlKHYsMSksdGhpc1t4XSl7Y29uc3QgUD10aGlzW3hdLmluZGV4T2YoTyk7dGhpc1t4XS5zcGxpY2UoUCwxKX1yZXR1cm4gTy5kaXNjb25uZWN0KHRoaXMpLE99cmV0dXJuIG51bGx9cmVvcmRlcigpe3RoaXNbeF09bnVsbH1zZWFsKCl7ZnVuY3Rpb24gTyh1LGEpe2NvbnN0IGg9W107Zm9yKGxldCBiPTA7Yjx1Lmxlbmd0aDtiKyspe2NvbnN0IEU9Wy4uLnVbYl1dO2ZvcihsZXQgQT0xO0E8RS5sZW5ndGg7QSs9Mil7Y29uc3QgTD1FW0FdLFM9RVtBKzFdO0VbQV09TCphWzBdK1MqYVsyXSthWzRdLEVbQSsxXT1MKmFbMV0rUyphWzNdK2FbNV19aC5wdXNoKEUpfXJldHVybiBofWNvbnN0IHY9dGhpcy5vcmRlcmVkQ2hpbGRyZW4sUD1uZXcgci5GaWd1cmUyRCxpPXRoaXMubG9jYWxNYXRyaXg7Zm9yKGxldCB1PTA7dTx2Lmxlbmd0aDt1Kyspe2xldCBhPXZbdV07aWYoYSBpbnN0YW5jZW9mIG0mJihhPWEuc2VhbCgpKSxhLmNsaWVudEJveCl7bGV0IGg9YS5jbGllbnRCb3guY29udG91cnMucGF0aDtoPU8oaCxhLmxvY2FsTWF0cml4KSxQLmFkZFBhdGgoaCl9aWYoYS5wYXRoKXtsZXQgaD1hLnBhdGguY29udG91cnMucGF0aDtoPU8oaCxhLmxvY2FsTWF0cml4KSxQLmFkZFBhdGgoaCl9fXJldHVybiB0aGlzW3ldPSEwLHRoaXMuY2xpZW50Qm94PVAse2NsaWVudEJveDpQLGxvY2FsTWF0cml4Oml9fXNldFJlc29sdXRpb24oe3dpZHRoOk8saGVpZ2h0OnZ9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpPLGhlaWdodDp2fSksdGhpc1tnXS5mb3JFYWNoKFA9PntQLnNldFJlc29sdXRpb24oe3dpZHRoOk8saGVpZ2h0OnZ9KX0pfXVwZGF0ZUNvbnRvdXJzKCl7dGhpc1t5XXx8c3VwZXIudXBkYXRlQ29udG91cnMoKX19byhtLCJBdHRyIixzLmRlZmF1bHQpLGwuZGVmYXVsdC5yZWdpc3Rlck5vZGUobSwiZ3JvdXAiKX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciByPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgbiBleHRlbmRzIHIuZGVmYXVsdHt9fSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJxdWVyeVNlbGVjdG9yQWxsIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInF1ZXJ5U2VsZWN0b3IiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiaXNNYXRjaGVkIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImNvbXBpbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgcj10KDIyMSksbj10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9dCgyNTMpO2Z1bmN0aW9uIGwodil7cmV0dXJuIHYubm9kZVR5cGU9PT0xfHxuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKHYubm9kZU5hbWUpfWZ1bmN0aW9uIGModil7cmV0dXJuIEFycmF5LmZyb20odi5jaGlsZE5vZGVzfHxbXSl9ZnVuY3Rpb24gbyh2KXtyZXR1cm4gbi5kZWZhdWx0LmlzU3ByaXRlTm9kZSh2Lm5vZGVOYW1lKT92LnBhcmVudHx8di5jYW52YXN8fHYuY29udGFpbmVyOnYucGFyZW50RWxlbWVudH1mdW5jdGlvbiBmKHYpe2xldCBQPXYubGVuZ3RoLGksdSxhO2Zvcig7LS1QPi0xOyl7Zm9yKGk9dT12W1BdLHZbUF09bnVsbCxhPSEwO3U7KXtpZih2LmluZGV4T2YodSk+LTEpe2E9ITEsdi5zcGxpY2UoUCwxKTticmVha311PW8odSl9YSYmKHZbUF09aSl9cmV0dXJuIHZ9Y29uc3QgeD17aXNUYWc6bCxleGlzdHNPbmUodixQKXtyZXR1cm4gUC5zb21lKGk9PmwoaSk/dihpKXx8eC5leGlzdHNPbmUodixjKGkpKTohMSl9LGdldFNpYmxpbmdzKHYpe2NvbnN0IFA9byh2KTtyZXR1cm4gUCYmYyhQKX0sZ2V0Q2hpbGRyZW46YyxnZXRQYXJlbnQ6byxnZXRBdHRyaWJ1dGVWYWx1ZSh2LFApe2lmKHYubm9kZVR5cGU9PT0xJiZQPT09ImNsYXNzInx8UD09PSJpZCIpcmV0dXJuIHZbUF07aWYodGhpcy5oYXNBdHRyaWIodixQKSl7bGV0IGk9di5hdHRyaWJ1dGVzW1BdO3JldHVybiBBcnJheS5pc0FycmF5KGkpJiYoaT1gWyR7aS5qb2luKCl9XWApLFN0cmluZyhpKX19LGhhc0F0dHJpYih2LFApe3JldHVybiB2LmF0dHJpYnV0ZXNbUF0hPW51bGx9LHJlbW92ZVN1YnNldHM6ZixnZXROYW1lKHYpe3JldHVybiB2LnRhZ05hbWU/di50YWdOYW1lLnRvTG93ZXJDYXNlKCk6bnVsbH0sZmluZE9uZTpmdW5jdGlvbiB2KFAsaSl7bGV0IHU9bnVsbDtmb3IobGV0IGE9MCxoPWkubGVuZ3RoO2E8aCYmIXU7YSsrKWlmKFAoaVthXSkpdT1pW2FdO2Vsc2V7Y29uc3QgYj1jKGlbYV0pO2ImJmIubGVuZ3RoPjAmJih1PXYoUCxiKSl9cmV0dXJuIHV9LGZpbmRBbGw6ZnVuY3Rpb24gdihQLGkpe2xldCB1PVtdO2ZvcihsZXQgYT0wLGg9aS5sZW5ndGg7YTxoO2ErKyl7aWYoIWwoaVthXSkpY29udGludWU7UChpW2FdKSYmdS5wdXNoKGlbYV0pO2NvbnN0IGI9YyhpW2FdKTtiJiYodT11LmNvbmNhdCh2KFAsYikpKX1yZXR1cm4gdX0sZ2V0VGV4dDpmdW5jdGlvbiB2KFApe3JldHVybiBBcnJheS5pc0FycmF5KFApP1AubWFwKHYpLmpvaW4oIiIpOmwoUCk/dihjKFApKTpQLm5vZGVUeXBlPT09Mz9QLm5vZGVWYWx1ZTpuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKFAubm9kZU5hbWUpP1AudGV4dDoiIn19O2Z1bmN0aW9uIGcodil7aWYodHlwZW9mIHYhPSJzdHJpbmciKXJldHVybiB2O2xldCBQPXYubWF0Y2goL1xbKGJnY29sb3J8ZmlsbENvbG9yfHN0cm9rZUNvbG9yfGNvbG9yKVxzKj1ccypbJyJdP1x3K1snIl0/XF0vZyk7cmV0dXJuIFAmJihQPVAubWFwKGk9Pntjb25zdCB1PWkuc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxhPU9iamVjdChyLnBhcnNlQ29sb3IpKHVbMV0ucmVwbGFjZSgvWyciXS9nLCIiKSk7cmV0dXJuW2ksYFske3VbMF19PSIke2F9Il1gXX0pLFAuZm9yRWFjaCgoW2ksdV0pPT57dj12LnJlcGxhY2UoaSx1KX0pKSxQPXYubWF0Y2goL1xbXHcrXHMqPVxzKlsnIl1cWy4rP1xdWyciXVxdL2cpLFAmJihQPVAubWFwKGk9Pntjb25zdCB1PWkuc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxhPXVbMV0uc2xpY2UoMiwtMikuc3BsaXQoLywvZykubWFwKGg9PmgudHJpbSgpKTtyZXR1cm5baSxgWyR7dVswXX09Ilske2F9XSJdYF19KSxQLmZvckVhY2goKFtpLHVdKT0+e3Y9di5yZXBsYWNlKGksdSl9KSksdn1mdW5jdGlvbiB5KHYsUCl7cmV0dXJuIHMuc2VsZWN0QWxsKGcodiksUCx7YWRhcHRlcjp4fSl9ZnVuY3Rpb24gbSh2LFApe3JldHVybiBzLnNlbGVjdE9uZShnKHYpLFAse2FkYXB0ZXI6eH0pfWZ1bmN0aW9uIFQodixQKXtyZXR1cm4gcy5pcyh2LGcoUCkse2FkYXB0ZXI6eH0pfWZ1bmN0aW9uIE8odil7cmV0dXJuIHMuY29tcGlsZShnKHYpLHthZGFwdGVyOnh9KX19LGZ1bmN0aW9uKGQsZSx0KXtkLmV4cG9ydHM9Tzt2YXIgcj10KDI1NCksbj10KDI3MykuZmFsc2VGdW5jLHM9dCgyNzQpO2Z1bmN0aW9uIGwodil7cmV0dXJuIGZ1bmN0aW9uKGksdSxhKXtyZXR1cm4gdT11fHx7fSx1LmFkYXB0ZXI9dS5hZGFwdGVyfHxyLHYoaSx1LGEpfX12YXIgYz1sKHMpLG89bChzLmNvbXBpbGVVbnNhZmUpO2Z1bmN0aW9uIGYodil7cmV0dXJuIGZ1bmN0aW9uKGksdSxhKXtyZXR1cm4gYT1hfHx7fSxhLmFkYXB0ZXI9YS5hZGFwdGVyfHxyLHR5cGVvZiBpIT0iZnVuY3Rpb24iJiYoaT1vKGksYSx1KSksaS5zaG91bGRUZXN0TmV4dFNpYmxpbmdzJiYodT1nKGEmJmEuY29udGV4dHx8dSxhLmFkYXB0ZXIpKSxBcnJheS5pc0FycmF5KHUpP3U9YS5hZGFwdGVyLnJlbW92ZVN1YnNldHModSk6dT1hLmFkYXB0ZXIuZ2V0Q2hpbGRyZW4odSksdihpLHUsYSl9fWZ1bmN0aW9uIHgodixQKXt2YXIgaT1QLmdldFNpYmxpbmdzKHYpO2lmKCFBcnJheS5pc0FycmF5KGkpKXJldHVybltdO2ZvcihpPWkuc2xpY2UoMCk7aS5zaGlmdCgpIT09djspO3JldHVybiBpfWZ1bmN0aW9uIGcodixQKXtBcnJheS5pc0FycmF5KHYpfHwodj1bdl0pO2Zvcih2YXIgaT12LnNsaWNlKDApLHU9MCxhPXYubGVuZ3RoO3U8YTt1Kyspe3ZhciBoPXgoaVt1XSxQKTtpLnB1c2guYXBwbHkoaSxoKX1yZXR1cm4gaX12YXIgeT1mKGZ1bmN0aW9uKFAsaSx1KXtyZXR1cm4gUD09PW58fCFpfHxpLmxlbmd0aD09PTA/W106dS5hZGFwdGVyLmZpbmRBbGwoUCxpKX0pLG09ZihmdW5jdGlvbihQLGksdSl7cmV0dXJuIFA9PT1ufHwhaXx8aS5sZW5ndGg9PT0wP251bGw6dS5hZGFwdGVyLmZpbmRPbmUoUCxpKX0pO2Z1bmN0aW9uIFQodixQLGkpe3JldHVybiBpPWl8fHt9LGkuYWRhcHRlcj1pLmFkYXB0ZXJ8fHIsKHR5cGVvZiBQPT0iZnVuY3Rpb24iP1A6YyhQLGkpKSh2KX1mdW5jdGlvbiBPKHYsUCxpKXtyZXR1cm4geSh2LFAsaSl9Ty5jb21waWxlPWMsTy5maWx0ZXJzPXMuUHNldWRvcy5maWx0ZXJzLE8ucHNldWRvcz1zLlBzZXVkb3MucHNldWRvcyxPLnNlbGVjdEFsbD15LE8uc2VsZWN0T25lPW0sTy5pcz1ULE8ucGFyc2U9YyxPLml0ZXJhdGU9eSxPLl9jb21waWxlVW5zYWZlPW8sTy5fY29tcGlsZVRva2VuPXMuY29tcGlsZVRva2VufSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9ZC5leHBvcnRzO1t0KDI1NSksdCgyNjgpLHQoMjY5KSx0KDI3MCksdCgyNzEpLHQoMjcyKV0uZm9yRWFjaChmdW5jdGlvbihuKXtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKHMpe3Jbc109bltzXS5iaW5kKHIpfSl9KX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMjU2KSxuPXQoMjU3KSxzPXIuaXNUYWc7ZC5leHBvcnRzPXtnZXRJbm5lckhUTUw6bCxnZXRPdXRlckhUTUw6bixnZXRUZXh0OmN9O2Z1bmN0aW9uIGwobyxmKXtyZXR1cm4gby5jaGlsZHJlbj9vLmNoaWxkcmVuLm1hcChmdW5jdGlvbih4KXtyZXR1cm4gbih4LGYpfSkuam9pbigiIik6IiJ9ZnVuY3Rpb24gYyhvKXtyZXR1cm4gQXJyYXkuaXNBcnJheShvKT9vLm1hcChjKS5qb2luKCIiKTpzKG8pP28ubmFtZT09PSJiciI/YApgOmMoby5jaGlsZHJlbik6by50eXBlPT09ci5DREFUQT9jKG8uY2hpbGRyZW4pOm8udHlwZT09PXIuVGV4dD9vLmRhdGE6IiJ9fSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz17VGV4dDoidGV4dCIsRGlyZWN0aXZlOiJkaXJlY3RpdmUiLENvbW1lbnQ6ImNvbW1lbnQiLFNjcmlwdDoic2NyaXB0IixTdHlsZToic3R5bGUiLFRhZzoidGFnIixDREFUQToiY2RhdGEiLERvY3R5cGU6ImRvY3R5cGUiLGlzVGFnOmZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGU9PT0idGFnInx8dC50eXBlPT09InNjcmlwdCJ8fHQudHlwZT09PSJzdHlsZSJ9fX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMjU4KSxuPXQoMjU5KSxzPXQoMjY3KTtzLmVsZW1lbnROYW1lcy5fX3Byb3RvX189bnVsbCxzLmF0dHJpYnV0ZU5hbWVzLl9fcHJvdG9fXz1udWxsO3ZhciBsPXtfX3Byb3RvX186bnVsbCxzdHlsZTohMCxzY3JpcHQ6ITAseG1wOiEwLGlmcmFtZTohMCxub2VtYmVkOiEwLG5vZnJhbWVzOiEwLHBsYWludGV4dDohMCxub3NjcmlwdDohMH07ZnVuY3Rpb24gYyh2LFApe2lmKHYpe3ZhciBpPSIiLHU7Zm9yKHZhciBhIGluIHYpdT12W2FdLGkmJihpKz0iICIpLFAueG1sTW9kZT09PSJmb3JlaWduIiYmKGE9cy5hdHRyaWJ1dGVOYW1lc1thXXx8YSksaSs9YSwodSE9PW51bGwmJnUhPT0iInx8UC54bWxNb2RlKSYmKGkrPSc9IicrKFAuZGVjb2RlRW50aXRpZXM/bi5lbmNvZGVYTUwodSk6dS5yZXBsYWNlKC9cIi9nLCImcXVvdDsiKSkrJyInKTtyZXR1cm4gaX19dmFyIG89e19fcHJvdG9fXzpudWxsLGFyZWE6ITAsYmFzZTohMCxiYXNlZm9udDohMCxicjohMCxjb2w6ITAsY29tbWFuZDohMCxlbWJlZDohMCxmcmFtZTohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsaXNpbmRleDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9LGY9ZC5leHBvcnRzPWZ1bmN0aW9uKHYsUCl7IUFycmF5LmlzQXJyYXkodikmJiF2LmNoZWVyaW8mJih2PVt2XSksUD1QfHx7fTtmb3IodmFyIGk9IiIsdT0wO3U8di5sZW5ndGg7dSsrKXt2YXIgYT12W3VdO2EudHlwZT09PSJyb290Ij9pKz1mKGEuY2hpbGRyZW4sUCk6ci5pc1RhZyhhKT9pKz1nKGEsUCk6YS50eXBlPT09ci5EaXJlY3RpdmU/aSs9eShhKTphLnR5cGU9PT1yLkNvbW1lbnQ/aSs9TyhhKTphLnR5cGU9PT1yLkNEQVRBP2krPVQoYSk6aSs9bShhLFApfXJldHVybiBpfSx4PVsibWkiLCJtbyIsIm1uIiwibXMiLCJtdGV4dCIsImFubm90YXRpb24teG1sIiwiZm9yZWlnbk9iamVjdCIsImRlc2MiLCJ0aXRsZSJdO2Z1bmN0aW9uIGcodixQKXtQLnhtbE1vZGU9PT0iZm9yZWlnbiImJih2Lm5hbWU9cy5lbGVtZW50TmFtZXNbdi5uYW1lXXx8di5uYW1lLHYucGFyZW50JiZ4LmluZGV4T2Yodi5wYXJlbnQubmFtZSk+PTAmJihQPU9iamVjdC5hc3NpZ24oe30sUCx7eG1sTW9kZTohMX0pKSksIVAueG1sTW9kZSYmWyJzdmciLCJtYXRoIl0uaW5kZXhPZih2Lm5hbWUpPj0wJiYoUD1PYmplY3QuYXNzaWduKHt9LFAse3htbE1vZGU6ImZvcmVpZ24ifSkpO3ZhciBpPSI8Iit2Lm5hbWUsdT1jKHYuYXR0cmlicyxQKTtyZXR1cm4gdSYmKGkrPSIgIit1KSxQLnhtbE1vZGUmJighdi5jaGlsZHJlbnx8di5jaGlsZHJlbi5sZW5ndGg9PT0wKT9pKz0iLz4iOihpKz0iPiIsdi5jaGlsZHJlbiYmKGkrPWYodi5jaGlsZHJlbixQKSksKCFvW3YubmFtZV18fFAueG1sTW9kZSkmJihpKz0iPC8iK3YubmFtZSsiPiIpKSxpfWZ1bmN0aW9uIHkodil7cmV0dXJuIjwiK3YuZGF0YSsiPiJ9ZnVuY3Rpb24gbSh2LFApe3ZhciBpPXYuZGF0YXx8IiI7cmV0dXJuIFAuZGVjb2RlRW50aXRpZXMmJiEodi5wYXJlbnQmJnYucGFyZW50Lm5hbWUgaW4gbCkmJihpPW4uZW5jb2RlWE1MKGkpKSxpfWZ1bmN0aW9uIFQodil7cmV0dXJuIjwhW0NEQVRBWyIrdi5jaGlsZHJlblswXS5kYXRhKyJdXT4ifWZ1bmN0aW9uIE8odil7cmV0dXJuIjwhLS0iK3YuZGF0YSsiLS0+In19LGZ1bmN0aW9uKGQsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gcihuKXtyZXR1cm4gbi50eXBlPT09InRhZyJ8fG4udHlwZT09PSJzY3JpcHQifHxuLnR5cGU9PT0ic3R5bGUifWUuaXNUYWc9cixlLlRleHQ9InRleHQiLGUuRGlyZWN0aXZlPSJkaXJlY3RpdmUiLGUuQ29tbWVudD0iY29tbWVudCIsZS5TY3JpcHQ9InNjcmlwdCIsZS5TdHlsZT0ic3R5bGUiLGUuVGFnPSJ0YWciLGUuQ0RBVEE9ImNkYXRhIixlLkRvY3R5cGU9ImRvY3R5cGUifSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZW5jb2RlPWUuZGVjb2RlU3RyaWN0PWUuZGVjb2RlPXZvaWQgMDt2YXIgcj10KDI2MCksbj10KDI2Nik7ZnVuY3Rpb24gcyh4LGcpe3JldHVybighZ3x8Zzw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUwpKHgpfWUuZGVjb2RlPXM7ZnVuY3Rpb24gbCh4LGcpe3JldHVybighZ3x8Zzw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUxTdHJpY3QpKHgpfWUuZGVjb2RlU3RyaWN0PWw7ZnVuY3Rpb24gYyh4LGcpe3JldHVybighZ3x8Zzw9MD9uLmVuY29kZVhNTDpuLmVuY29kZUhUTUwpKHgpfWUuZW5jb2RlPWM7dmFyIG89dCgyNjYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLmVuY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZXNjYXBlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5lc2NhcGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5jb2RlSFRNTH19KTt2YXIgZj10KDI2MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNVN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVYTUx9fSl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZyl7cmV0dXJuIGcmJmcuX19lc01vZHVsZT9nOntkZWZhdWx0Omd9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWNvZGVIVE1MPWUuZGVjb2RlSFRNTFN0cmljdD1lLmRlY29kZVhNTD12b2lkIDA7dmFyIG49cih0KDI2MSkpLHM9cih0KDI2MikpLGw9cih0KDI2MykpLGM9cih0KDI2NCkpO2UuZGVjb2RlWE1MPW8obC5kZWZhdWx0KSxlLmRlY29kZUhUTUxTdHJpY3Q9byhuLmRlZmF1bHQpO2Z1bmN0aW9uIG8oZyl7dmFyIHk9T2JqZWN0LmtleXMoZykuam9pbigifCIpLG09eChnKTt5Kz0ifCNbeFhdW1xcZGEtZkEtRl0rfCNcXGQrIjt2YXIgVD1uZXcgUmVnRXhwKCImKD86Iit5KyIpOyIsImciKTtyZXR1cm4gZnVuY3Rpb24oTyl7cmV0dXJuIFN0cmluZyhPKS5yZXBsYWNlKFQsbSl9fXZhciBmPWZ1bmN0aW9uKGcseSl7cmV0dXJuIGc8eT8xOi0xfTtlLmRlY29kZUhUTUw9ZnVuY3Rpb24oKXtmb3IodmFyIGc9T2JqZWN0LmtleXMocy5kZWZhdWx0KS5zb3J0KGYpLHk9T2JqZWN0LmtleXMobi5kZWZhdWx0KS5zb3J0KGYpLG09MCxUPTA7bTx5Lmxlbmd0aDttKyspZ1tUXT09PXlbbV0/KHlbbV0rPSI7PyIsVCsrKTp5W21dKz0iOyI7dmFyIE89bmV3IFJlZ0V4cCgiJig/OiIreS5qb2luKCJ8IikrInwjW3hYXVtcXGRhLWZBLUZdKzs/fCNcXGQrOz8pIiwiZyIpLHY9eChuLmRlZmF1bHQpO2Z1bmN0aW9uIFAoaSl7cmV0dXJuIGkuc3Vic3RyKC0xKSE9PSI7IiYmKGkrPSI7IiksdihpKX1yZXR1cm4gZnVuY3Rpb24oaSl7cmV0dXJuIFN0cmluZyhpKS5yZXBsYWNlKE8sUCl9fSgpO2Z1bmN0aW9uIHgoZyl7cmV0dXJuIGZ1bmN0aW9uKG0pe2lmKG0uY2hhckF0KDEpPT09IiMiKXt2YXIgVD1tLmNoYXJBdCgyKTtyZXR1cm4gVD09PSJYInx8VD09PSJ4Ij9jLmRlZmF1bHQocGFyc2VJbnQobS5zdWJzdHIoMyksMTYpKTpjLmRlZmF1bHQocGFyc2VJbnQobS5zdWJzdHIoMiksMTApKX1yZXR1cm4gZ1ttLnNsaWNlKDEsLTEpXX19fSxmdW5jdGlvbihkKXtkLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWJyZXZlIjoixIIiLCJhYnJldmUiOiLEgyIsImFjIjoi4oi+IiwiYWNkIjoi4oi/IiwiYWNFIjoi4oi+zLMiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBY3kiOiLQkCIsImFjeSI6ItCwIiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJhZiI6IuKBoSIsIkFmciI6IvCdlIQiLCJhZnIiOiLwnZSeIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFsZWZzeW0iOiLihLUiLCJhbGVwaCI6IuKEtSIsIkFscGhhIjoizpEiLCJhbHBoYSI6Is6xIiwiQW1hY3IiOiLEgCIsImFtYWNyIjoixIEiLCJhbWFsZyI6IuKovyIsImFtcCI6IiYiLCJBTVAiOiImIiwiYW5kYW5kIjoi4qmVIiwiQW5kIjoi4qmTIiwiYW5kIjoi4oinIiwiYW5kZCI6IuKpnCIsImFuZHNsb3BlIjoi4qmYIiwiYW5kdiI6IuKpmiIsImFuZyI6IuKIoCIsImFuZ2UiOiLipqQiLCJhbmdsZSI6IuKIoCIsImFuZ21zZGFhIjoi4qaoIiwiYW5nbXNkYWIiOiLipqkiLCJhbmdtc2RhYyI6IuKmqiIsImFuZ21zZGFkIjoi4qarIiwiYW5nbXNkYWUiOiLipqwiLCJhbmdtc2RhZiI6IuKmrSIsImFuZ21zZGFnIjoi4qauIiwiYW5nbXNkYWgiOiLipq8iLCJhbmdtc2QiOiLiiKEiLCJhbmdydCI6IuKInyIsImFuZ3J0dmIiOiLiir4iLCJhbmdydHZiZCI6IuKmnSIsImFuZ3NwaCI6IuKIoiIsImFuZ3N0Ijoiw4UiLCJhbmd6YXJyIjoi4o28IiwiQW9nb24iOiLEhCIsImFvZ29uIjoixIUiLCJBb3BmIjoi8J2UuCIsImFvcGYiOiLwnZWSIiwiYXBhY2lyIjoi4qmvIiwiYXAiOiLiiYgiLCJhcEUiOiLiqbAiLCJhcGUiOiLiiYoiLCJhcGlkIjoi4omLIiwiYXBvcyI6IlwnIiwiQXBwbHlGdW5jdGlvbiI6IuKBoSIsImFwcHJveCI6IuKJiCIsImFwcHJveGVxIjoi4omKIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBc2NyIjoi8J2SnCIsImFzY3IiOiLwnZK2IiwiQXNzaWduIjoi4omUIiwiYXN0IjoiKiIsImFzeW1wIjoi4omIIiwiYXN5bXBlcSI6IuKJjSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJhd2NvbmludCI6IuKIsyIsImF3aW50Ijoi4qiRIiwiYmFja2NvbmciOiLiiYwiLCJiYWNrZXBzaWxvbiI6Is+2IiwiYmFja3ByaW1lIjoi4oC1IiwiYmFja3NpbSI6IuKIvSIsImJhY2tzaW1lcSI6IuKLjSIsIkJhY2tzbGFzaCI6IuKIliIsIkJhcnYiOiLiq6ciLCJiYXJ2ZWUiOiLiir0iLCJiYXJ3ZWQiOiLijIUiLCJCYXJ3ZWQiOiLijIYiLCJiYXJ3ZWRnZSI6IuKMhSIsImJicmsiOiLijrUiLCJiYnJrdGJyayI6IuKOtiIsImJjb25nIjoi4omMIiwiQmN5Ijoi0JEiLCJiY3kiOiLQsSIsImJkcXVvIjoi4oCeIiwiYmVjYXVzIjoi4oi1IiwiYmVjYXVzZSI6IuKItSIsIkJlY2F1c2UiOiLiiLUiLCJiZW1wdHl2Ijoi4qawIiwiYmVwc2kiOiLPtiIsImJlcm5vdSI6IuKErCIsIkJlcm5vdWxsaXMiOiLihKwiLCJCZXRhIjoizpIiLCJiZXRhIjoizrIiLCJiZXRoIjoi4oS2IiwiYmV0d2VlbiI6IuKJrCIsIkJmciI6IvCdlIUiLCJiZnIiOiLwnZSfIiwiYmlnY2FwIjoi4ouCIiwiYmlnY2lyYyI6IuKXryIsImJpZ2N1cCI6IuKLgyIsImJpZ29kb3QiOiLiqIAiLCJiaWdvcGx1cyI6IuKogSIsImJpZ290aW1lcyI6IuKogiIsImJpZ3NxY3VwIjoi4qiGIiwiYmlnc3RhciI6IuKYhSIsImJpZ3RyaWFuZ2xlZG93biI6IuKWvSIsImJpZ3RyaWFuZ2xldXAiOiLilrMiLCJiaWd1cGx1cyI6IuKohCIsImJpZ3ZlZSI6IuKLgSIsImJpZ3dlZGdlIjoi4ouAIiwiYmthcm93Ijoi4qSNIiwiYmxhY2tsb3plbmdlIjoi4qerIiwiYmxhY2tzcXVhcmUiOiLilqoiLCJibGFja3RyaWFuZ2xlIjoi4pa0IiwiYmxhY2t0cmlhbmdsZWRvd24iOiLilr4iLCJibGFja3RyaWFuZ2xlbGVmdCI6IuKXgiIsImJsYWNrdHJpYW5nbGVyaWdodCI6IuKWuCIsImJsYW5rIjoi4pCjIiwiYmxrMTIiOiLilpIiLCJibGsxNCI6IuKWkSIsImJsazM0Ijoi4paTIiwiYmxvY2siOiLilogiLCJibmUiOiI94oOlIiwiYm5lcXVpdiI6IuKJoeKDpSIsImJOb3QiOiLiq60iLCJibm90Ijoi4oyQIiwiQm9wZiI6IvCdlLkiLCJib3BmIjoi8J2VkyIsImJvdCI6IuKKpSIsImJvdHRvbSI6IuKKpSIsImJvd3RpZSI6IuKLiCIsImJveGJveCI6IuKniSIsImJveGRsIjoi4pSQIiwiYm94ZEwiOiLilZUiLCJib3hEbCI6IuKVliIsImJveERMIjoi4pWXIiwiYm94ZHIiOiLilIwiLCJib3hkUiI6IuKVkiIsImJveERyIjoi4pWTIiwiYm94RFIiOiLilZQiLCJib3hoIjoi4pSAIiwiYm94SCI6IuKVkCIsImJveGhkIjoi4pSsIiwiYm94SGQiOiLilaQiLCJib3hoRCI6IuKVpSIsImJveEhEIjoi4pWmIiwiYm94aHUiOiLilLQiLCJib3hIdSI6IuKVpyIsImJveGhVIjoi4pWoIiwiYm94SFUiOiLilakiLCJib3htaW51cyI6IuKKnyIsImJveHBsdXMiOiLiip4iLCJib3h0aW1lcyI6IuKKoCIsImJveHVsIjoi4pSYIiwiYm94dUwiOiLilZsiLCJib3hVbCI6IuKVnCIsImJveFVMIjoi4pWdIiwiYm94dXIiOiLilJQiLCJib3h1UiI6IuKVmCIsImJveFVyIjoi4pWZIiwiYm94VVIiOiLilZoiLCJib3h2Ijoi4pSCIiwiYm94ViI6IuKVkSIsImJveHZoIjoi4pS8IiwiYm94dkgiOiLilaoiLCJib3hWaCI6IuKVqyIsImJveFZIIjoi4pWsIiwiYm94dmwiOiLilKQiLCJib3h2TCI6IuKVoSIsImJveFZsIjoi4pWiIiwiYm94VkwiOiLilaMiLCJib3h2ciI6IuKUnCIsImJveHZSIjoi4pWeIiwiYm94VnIiOiLilZ8iLCJib3hWUiI6IuKVoCIsImJwcmltZSI6IuKAtSIsImJyZXZlIjoiy5giLCJCcmV2ZSI6IsuYIiwiYnJ2YmFyIjoiwqYiLCJic2NyIjoi8J2StyIsIkJzY3IiOiLihKwiLCJic2VtaSI6IuKBjyIsImJzaW0iOiLiiL0iLCJic2ltZSI6IuKLjSIsImJzb2xiIjoi4qeFIiwiYnNvbCI6IlxcXFwiLCJic29saHN1YiI6IuKfiCIsImJ1bGwiOiLigKIiLCJidWxsZXQiOiLigKIiLCJidW1wIjoi4omOIiwiYnVtcEUiOiLiqq4iLCJidW1wZSI6IuKJjyIsIkJ1bXBlcSI6IuKJjiIsImJ1bXBlcSI6IuKJjyIsIkNhY3V0ZSI6IsSGIiwiY2FjdXRlIjoixIciLCJjYXBhbmQiOiLiqYQiLCJjYXBicmN1cCI6IuKpiSIsImNhcGNhcCI6IuKpiyIsImNhcCI6IuKIqSIsIkNhcCI6IuKLkiIsImNhcGN1cCI6IuKphyIsImNhcGRvdCI6IuKpgCIsIkNhcGl0YWxEaWZmZXJlbnRpYWxEIjoi4oWFIiwiY2FwcyI6IuKIqe+4gCIsImNhcmV0Ijoi4oGBIiwiY2Fyb24iOiLLhyIsIkNheWxleXMiOiLihK0iLCJjY2FwcyI6IuKpjSIsIkNjYXJvbiI6IsSMIiwiY2Nhcm9uIjoixI0iLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiQ2NpcmMiOiLEiCIsImNjaXJjIjoixIkiLCJDY29uaW50Ijoi4oiwIiwiY2N1cHMiOiLiqYwiLCJjY3Vwc3NtIjoi4qmQIiwiQ2RvdCI6IsSKIiwiY2RvdCI6IsSLIiwiY2VkaWwiOiLCuCIsIkNlZGlsbGEiOiLCuCIsImNlbXB0eXYiOiLiprIiLCJjZW50IjoiwqIiLCJjZW50ZXJkb3QiOiLCtyIsIkNlbnRlckRvdCI6IsK3IiwiY2ZyIjoi8J2UoCIsIkNmciI6IuKErSIsIkNIY3kiOiLQpyIsImNoY3kiOiLRhyIsImNoZWNrIjoi4pyTIiwiY2hlY2ttYXJrIjoi4pyTIiwiQ2hpIjoizqciLCJjaGkiOiLPhyIsImNpcmMiOiLLhiIsImNpcmNlcSI6IuKJlyIsImNpcmNsZWFycm93bGVmdCI6IuKGuiIsImNpcmNsZWFycm93cmlnaHQiOiLihrsiLCJjaXJjbGVkYXN0Ijoi4oqbIiwiY2lyY2xlZGNpcmMiOiLiipoiLCJjaXJjbGVkZGFzaCI6IuKKnSIsIkNpcmNsZURvdCI6IuKKmSIsImNpcmNsZWRSIjoiwq4iLCJjaXJjbGVkUyI6IuKTiCIsIkNpcmNsZU1pbnVzIjoi4oqWIiwiQ2lyY2xlUGx1cyI6IuKKlSIsIkNpcmNsZVRpbWVzIjoi4oqXIiwiY2lyIjoi4peLIiwiY2lyRSI6IuKngyIsImNpcmUiOiLiiZciLCJjaXJmbmludCI6IuKokCIsImNpcm1pZCI6IuKrryIsImNpcnNjaXIiOiLip4IiLCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLIiLCJDbG9zZUN1cmx5RG91YmxlUXVvdGUiOiLigJ0iLCJDbG9zZUN1cmx5UXVvdGUiOiLigJkiLCJjbHVicyI6IuKZoyIsImNsdWJzdWl0Ijoi4pmjIiwiY29sb24iOiI6IiwiQ29sb24iOiLiiLciLCJDb2xvbmUiOiLiqbQiLCJjb2xvbmUiOiLiiZQiLCJjb2xvbmVxIjoi4omUIiwiY29tbWEiOiIsIiwiY29tbWF0IjoiQCIsImNvbXAiOiLiiIEiLCJjb21wZm4iOiLiiJgiLCJjb21wbGVtZW50Ijoi4oiBIiwiY29tcGxleGVzIjoi4oSCIiwiY29uZyI6IuKJhSIsImNvbmdkb3QiOiLiqa0iLCJDb25ncnVlbnQiOiLiiaEiLCJjb25pbnQiOiLiiK4iLCJDb25pbnQiOiLiiK8iLCJDb250b3VySW50ZWdyYWwiOiLiiK4iLCJjb3BmIjoi8J2VlCIsIkNvcGYiOiLihIIiLCJjb3Byb2QiOiLiiJAiLCJDb3Byb2R1Y3QiOiLiiJAiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjb3B5c3IiOiLihJciLCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oizIiwiY3JhcnIiOiLihrUiLCJjcm9zcyI6IuKclyIsIkNyb3NzIjoi4qivIiwiQ3NjciI6IvCdkp4iLCJjc2NyIjoi8J2SuCIsImNzdWIiOiLiq48iLCJjc3ViZSI6IuKrkSIsImNzdXAiOiLiq5AiLCJjc3VwZSI6IuKrkiIsImN0ZG90Ijoi4ouvIiwiY3VkYXJybCI6IuKkuCIsImN1ZGFycnIiOiLipLUiLCJjdWVwciI6IuKLniIsImN1ZXNjIjoi4oufIiwiY3VsYXJyIjoi4oa2IiwiY3VsYXJycCI6IuKkvSIsImN1cGJyY2FwIjoi4qmIIiwiY3VwY2FwIjoi4qmGIiwiQ3VwQ2FwIjoi4omNIiwiY3VwIjoi4oiqIiwiQ3VwIjoi4ouTIiwiY3VwY3VwIjoi4qmKIiwiY3VwZG90Ijoi4oqNIiwiY3Vwb3IiOiLiqYUiLCJjdXBzIjoi4oiq77iAIiwiY3VyYXJyIjoi4oa3IiwiY3VyYXJybSI6IuKkvCIsImN1cmx5ZXFwcmVjIjoi4oueIiwiY3VybHllcXN1Y2MiOiLii58iLCJjdXJseXZlZSI6IuKLjiIsImN1cmx5d2VkZ2UiOiLii48iLCJjdXJyZW4iOiLCpCIsImN1cnZlYXJyb3dsZWZ0Ijoi4oa2IiwiY3VydmVhcnJvd3JpZ2h0Ijoi4oa3IiwiY3V2ZWUiOiLii44iLCJjdXdlZCI6IuKLjyIsImN3Y29uaW50Ijoi4oiyIiwiY3dpbnQiOiLiiLEiLCJjeWxjdHkiOiLijK0iLCJkYWdnZXIiOiLigKAiLCJEYWdnZXIiOiLigKEiLCJkYWxldGgiOiLihLgiLCJkYXJyIjoi4oaTIiwiRGFyciI6IuKGoSIsImRBcnIiOiLih5MiLCJkYXNoIjoi4oCQIiwiRGFzaHYiOiLiq6QiLCJkYXNodiI6IuKKoyIsImRia2Fyb3ciOiLipI8iLCJkYmxhYyI6IsudIiwiRGNhcm9uIjoixI4iLCJkY2Fyb24iOiLEjyIsIkRjeSI6ItCUIiwiZGN5Ijoi0LQiLCJkZGFnZ2VyIjoi4oChIiwiZGRhcnIiOiLih4oiLCJERCI6IuKFhSIsImRkIjoi4oWGIiwiRERvdHJhaGQiOiLipJEiLCJkZG90c2VxIjoi4qm3IiwiZGVnIjoiwrAiLCJEZWwiOiLiiIciLCJEZWx0YSI6Is6UIiwiZGVsdGEiOiLOtCIsImRlbXB0eXYiOiLiprEiLCJkZmlzaHQiOiLipb8iLCJEZnIiOiLwnZSHIiwiZGZyIjoi8J2UoSIsImRIYXIiOiLipaUiLCJkaGFybCI6IuKHgyIsImRoYXJyIjoi4oeCIiwiRGlhY3JpdGljYWxBY3V0ZSI6IsK0IiwiRGlhY3JpdGljYWxEb3QiOiLLmSIsIkRpYWNyaXRpY2FsRG91YmxlQWN1dGUiOiLLnSIsIkRpYWNyaXRpY2FsR3JhdmUiOiJgIiwiRGlhY3JpdGljYWxUaWxkZSI6IsucIiwiZGlhbSI6IuKLhCIsImRpYW1vbmQiOiLii4QiLCJEaWFtb25kIjoi4ouEIiwiZGlhbW9uZHN1aXQiOiLimaYiLCJkaWFtcyI6IuKZpiIsImRpZSI6IsKoIiwiRGlmZmVyZW50aWFsRCI6IuKFhiIsImRpZ2FtbWEiOiLPnSIsImRpc2luIjoi4ouyIiwiZGl2Ijoiw7ciLCJkaXZpZGUiOiLDtyIsImRpdmlkZW9udGltZXMiOiLii4ciLCJkaXZvbngiOiLii4ciLCJESmN5Ijoi0IIiLCJkamN5Ijoi0ZIiLCJkbGNvcm4iOiLijJ4iLCJkbGNyb3AiOiLijI0iLCJkb2xsYXIiOiIkIiwiRG9wZiI6IvCdlLsiLCJkb3BmIjoi8J2VlSIsIkRvdCI6IsKoIiwiZG90Ijoiy5kiLCJEb3REb3QiOiLig5wiLCJkb3RlcSI6IuKJkCIsImRvdGVxZG90Ijoi4omRIiwiRG90RXF1YWwiOiLiiZAiLCJkb3RtaW51cyI6IuKIuCIsImRvdHBsdXMiOiLiiJQiLCJkb3RzcXVhcmUiOiLiiqEiLCJkb3VibGViYXJ3ZWRnZSI6IuKMhiIsIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbCI6IuKIryIsIkRvdWJsZURvdCI6IsKoIiwiRG91YmxlRG93bkFycm93Ijoi4oeTIiwiRG91YmxlTGVmdEFycm93Ijoi4oeQIiwiRG91YmxlTGVmdFJpZ2h0QXJyb3ciOiLih5QiLCJEb3VibGVMZWZ0VGVlIjoi4qukIiwiRG91YmxlTG9uZ0xlZnRBcnJvdyI6IuKfuCIsIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKfuiIsIkRvdWJsZUxvbmdSaWdodEFycm93Ijoi4p+5IiwiRG91YmxlUmlnaHRBcnJvdyI6IuKHkiIsIkRvdWJsZVJpZ2h0VGVlIjoi4oqoIiwiRG91YmxlVXBBcnJvdyI6IuKHkSIsIkRvdWJsZVVwRG93bkFycm93Ijoi4oeVIiwiRG91YmxlVmVydGljYWxCYXIiOiLiiKUiLCJEb3duQXJyb3dCYXIiOiLipJMiLCJkb3duYXJyb3ciOiLihpMiLCJEb3duQXJyb3ciOiLihpMiLCJEb3duYXJyb3ciOiLih5MiLCJEb3duQXJyb3dVcEFycm93Ijoi4oe1IiwiRG93bkJyZXZlIjoizJEiLCJkb3duZG93bmFycm93cyI6IuKHiiIsImRvd25oYXJwb29ubGVmdCI6IuKHgyIsImRvd25oYXJwb29ucmlnaHQiOiLih4IiLCJEb3duTGVmdFJpZ2h0VmVjdG9yIjoi4qWQIiwiRG93bkxlZnRUZWVWZWN0b3IiOiLipZ4iLCJEb3duTGVmdFZlY3RvckJhciI6IuKlliIsIkRvd25MZWZ0VmVjdG9yIjoi4oa9IiwiRG93blJpZ2h0VGVlVmVjdG9yIjoi4qWfIiwiRG93blJpZ2h0VmVjdG9yQmFyIjoi4qWXIiwiRG93blJpZ2h0VmVjdG9yIjoi4oeBIiwiRG93blRlZUFycm93Ijoi4oanIiwiRG93blRlZSI6IuKKpCIsImRyYmthcm93Ijoi4qSQIiwiZHJjb3JuIjoi4oyfIiwiZHJjcm9wIjoi4oyMIiwiRHNjciI6IvCdkp8iLCJkc2NyIjoi8J2SuSIsIkRTY3kiOiLQhSIsImRzY3kiOiLRlSIsImRzb2wiOiLip7YiLCJEc3Ryb2siOiLEkCIsImRzdHJvayI6IsSRIiwiZHRkb3QiOiLii7EiLCJkdHJpIjoi4pa/IiwiZHRyaWYiOiLilr4iLCJkdWFyciI6IuKHtSIsImR1aGFyIjoi4qWvIiwiZHdhbmdsZSI6IuKmpiIsIkRaY3kiOiLQjyIsImR6Y3kiOiLRnyIsImR6aWdyYXJyIjoi4p+/IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsImVhc3RlciI6IuKpriIsIkVjYXJvbiI6IsSaIiwiZWNhcm9uIjoixJsiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsImVjaXIiOiLiiZYiLCJlY29sb24iOiLiiZUiLCJFY3kiOiLQrSIsImVjeSI6ItGNIiwiZUREb3QiOiLiqbciLCJFZG90IjoixJYiLCJlZG90IjoixJciLCJlRG90Ijoi4omRIiwiZWUiOiLihYciLCJlZkRvdCI6IuKJkiIsIkVmciI6IvCdlIgiLCJlZnIiOiLwnZSiIiwiZWciOiLiqpoiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiZWdzIjoi4qqWIiwiZWdzZG90Ijoi4qqYIiwiZWwiOiLiqpkiLCJFbGVtZW50Ijoi4oiIIiwiZWxpbnRlcnMiOiLij6ciLCJlbGwiOiLihJMiLCJlbHMiOiLiqpUiLCJlbHNkb3QiOiLiqpciLCJFbWFjciI6IsSSIiwiZW1hY3IiOiLEkyIsImVtcHR5Ijoi4oiFIiwiZW1wdHlzZXQiOiLiiIUiLCJFbXB0eVNtYWxsU3F1YXJlIjoi4pe7IiwiZW1wdHl2Ijoi4oiFIiwiRW1wdHlWZXJ5U21hbGxTcXVhcmUiOiLilqsiLCJlbXNwMTMiOiLigIQiLCJlbXNwMTQiOiLigIUiLCJlbXNwIjoi4oCDIiwiRU5HIjoixYoiLCJlbmciOiLFiyIsImVuc3AiOiLigIIiLCJFb2dvbiI6IsSYIiwiZW9nb24iOiLEmSIsIkVvcGYiOiLwnZS8IiwiZW9wZiI6IvCdlZYiLCJlcGFyIjoi4ouVIiwiZXBhcnNsIjoi4qejIiwiZXBsdXMiOiLiqbEiLCJlcHNpIjoizrUiLCJFcHNpbG9uIjoizpUiLCJlcHNpbG9uIjoizrUiLCJlcHNpdiI6Is+1IiwiZXFjaXJjIjoi4omWIiwiZXFjb2xvbiI6IuKJlSIsImVxc2ltIjoi4omCIiwiZXFzbGFudGd0ciI6IuKqliIsImVxc2xhbnRsZXNzIjoi4qqVIiwiRXF1YWwiOiLiqbUiLCJlcXVhbHMiOiI9IiwiRXF1YWxUaWxkZSI6IuKJgiIsImVxdWVzdCI6IuKJnyIsIkVxdWlsaWJyaXVtIjoi4oeMIiwiZXF1aXYiOiLiiaEiLCJlcXVpdkREIjoi4qm4IiwiZXF2cGFyc2wiOiLip6UiLCJlcmFyciI6IuKlsSIsImVyRG90Ijoi4omTIiwiZXNjciI6IuKEryIsIkVzY3IiOiLihLAiLCJlc2RvdCI6IuKJkCIsIkVzaW0iOiLiqbMiLCJlc2ltIjoi4omCIiwiRXRhIjoizpciLCJldGEiOiLOtyIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJldXJvIjoi4oKsIiwiZXhjbCI6IiEiLCJleGlzdCI6IuKIgyIsIkV4aXN0cyI6IuKIgyIsImV4cGVjdGF0aW9uIjoi4oSwIiwiZXhwb25lbnRpYWxlIjoi4oWHIiwiRXhwb25lbnRpYWxFIjoi4oWHIiwiZmFsbGluZ2RvdHNlcSI6IuKJkiIsIkZjeSI6ItCkIiwiZmN5Ijoi0YQiLCJmZW1hbGUiOiLimYAiLCJmZmlsaWciOiLvrIMiLCJmZmxpZyI6Iu+sgCIsImZmbGxpZyI6Iu+shCIsIkZmciI6IvCdlIkiLCJmZnIiOiLwnZSjIiwiZmlsaWciOiLvrIEiLCJGaWxsZWRTbWFsbFNxdWFyZSI6IuKXvCIsIkZpbGxlZFZlcnlTbWFsbFNxdWFyZSI6IuKWqiIsImZqbGlnIjoiZmoiLCJmbGF0Ijoi4pmtIiwiZmxsaWciOiLvrIIiLCJmbHRucyI6IuKWsSIsImZub2YiOiLGkiIsIkZvcGYiOiLwnZS9IiwiZm9wZiI6IvCdlZciLCJmb3JhbGwiOiLiiIAiLCJGb3JBbGwiOiLiiIAiLCJmb3JrIjoi4ouUIiwiZm9ya3YiOiLiq5kiLCJGb3VyaWVydHJmIjoi4oSxIiwiZnBhcnRpbnQiOiLiqI0iLCJmcmFjMTIiOiLCvSIsImZyYWMxMyI6IuKFkyIsImZyYWMxNCI6IsK8IiwiZnJhYzE1Ijoi4oWVIiwiZnJhYzE2Ijoi4oWZIiwiZnJhYzE4Ijoi4oWbIiwiZnJhYzIzIjoi4oWUIiwiZnJhYzI1Ijoi4oWWIiwiZnJhYzM0Ijoiwr4iLCJmcmFjMzUiOiLihZciLCJmcmFjMzgiOiLihZwiLCJmcmFjNDUiOiLihZgiLCJmcmFjNTYiOiLihZoiLCJmcmFjNTgiOiLihZ0iLCJmcmFjNzgiOiLihZ4iLCJmcmFzbCI6IuKBhCIsImZyb3duIjoi4oyiIiwiZnNjciI6IvCdkrsiLCJGc2NyIjoi4oSxIiwiZ2FjdXRlIjoix7UiLCJHYW1tYSI6Is6TIiwiZ2FtbWEiOiLOsyIsIkdhbW1hZCI6Is+cIiwiZ2FtbWFkIjoiz50iLCJnYXAiOiLiqoYiLCJHYnJldmUiOiLEniIsImdicmV2ZSI6IsSfIiwiR2NlZGlsIjoixKIiLCJHY2lyYyI6IsScIiwiZ2NpcmMiOiLEnSIsIkdjeSI6ItCTIiwiZ2N5Ijoi0LMiLCJHZG90IjoixKAiLCJnZG90IjoixKEiLCJnZSI6IuKJpSIsImdFIjoi4omnIiwiZ0VsIjoi4qqMIiwiZ2VsIjoi4oubIiwiZ2VxIjoi4omlIiwiZ2VxcSI6IuKJpyIsImdlcXNsYW50Ijoi4qm+IiwiZ2VzY2MiOiLiqqkiLCJnZXMiOiLiqb4iLCJnZXNkb3QiOiLiqoAiLCJnZXNkb3RvIjoi4qqCIiwiZ2VzZG90b2wiOiLiqoQiLCJnZXNsIjoi4oub77iAIiwiZ2VzbGVzIjoi4qqUIiwiR2ZyIjoi8J2UiiIsImdmciI6IvCdlKQiLCJnZyI6IuKJqyIsIkdnIjoi4ouZIiwiZ2dnIjoi4ouZIiwiZ2ltZWwiOiLihLciLCJHSmN5Ijoi0IMiLCJnamN5Ijoi0ZMiLCJnbGEiOiLiqqUiLCJnbCI6IuKJtyIsImdsRSI6IuKqkiIsImdsaiI6IuKqpCIsImduYXAiOiLiqooiLCJnbmFwcHJveCI6IuKqiiIsImduZSI6IuKqiCIsImduRSI6IuKJqSIsImduZXEiOiLiqogiLCJnbmVxcSI6IuKJqSIsImduc2ltIjoi4ounIiwiR29wZiI6IvCdlL4iLCJnb3BmIjoi8J2VmCIsImdyYXZlIjoiYCIsIkdyZWF0ZXJFcXVhbCI6IuKJpSIsIkdyZWF0ZXJFcXVhbExlc3MiOiLii5siLCJHcmVhdGVyRnVsbEVxdWFsIjoi4omnIiwiR3JlYXRlckdyZWF0ZXIiOiLiqqIiLCJHcmVhdGVyTGVzcyI6IuKJtyIsIkdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+IiwiR3JlYXRlclRpbGRlIjoi4omzIiwiR3NjciI6IvCdkqIiLCJnc2NyIjoi4oSKIiwiZ3NpbSI6IuKJsyIsImdzaW1lIjoi4qqOIiwiZ3NpbWwiOiLiqpAiLCJndGNjIjoi4qqnIiwiZ3RjaXIiOiLiqboiLCJndCI6Ij4iLCJHVCI6Ij4iLCJHdCI6IuKJqyIsImd0ZG90Ijoi4ouXIiwiZ3RsUGFyIjoi4qaVIiwiZ3RxdWVzdCI6IuKpvCIsImd0cmFwcHJveCI6IuKqhiIsImd0cmFyciI6IuKluCIsImd0cmRvdCI6IuKLlyIsImd0cmVxbGVzcyI6IuKLmyIsImd0cmVxcWxlc3MiOiLiqowiLCJndHJsZXNzIjoi4om3IiwiZ3Ryc2ltIjoi4omzIiwiZ3ZlcnRuZXFxIjoi4omp77iAIiwiZ3ZuRSI6IuKJqe+4gCIsIkhhY2VrIjoiy4ciLCJoYWlyc3AiOiLigIoiLCJoYWxmIjoiwr0iLCJoYW1pbHQiOiLihIsiLCJIQVJEY3kiOiLQqiIsImhhcmRjeSI6ItGKIiwiaGFycmNpciI6IuKliCIsImhhcnIiOiLihpQiLCJoQXJyIjoi4oeUIiwiaGFycnciOiLihq0iLCJIYXQiOiJeIiwiaGJhciI6IuKEjyIsIkhjaXJjIjoixKQiLCJoY2lyYyI6IsSlIiwiaGVhcnRzIjoi4pmlIiwiaGVhcnRzdWl0Ijoi4pmlIiwiaGVsbGlwIjoi4oCmIiwiaGVyY29uIjoi4oq5IiwiaGZyIjoi8J2UpSIsIkhmciI6IuKEjCIsIkhpbGJlcnRTcGFjZSI6IuKEiyIsImhrc2Vhcm93Ijoi4qSlIiwiaGtzd2Fyb3ciOiLipKYiLCJob2FyciI6IuKHvyIsImhvbXRodCI6IuKIuyIsImhvb2tsZWZ0YXJyb3ciOiLihqkiLCJob29rcmlnaHRhcnJvdyI6IuKGqiIsImhvcGYiOiLwnZWZIiwiSG9wZiI6IuKEjSIsImhvcmJhciI6IuKAlSIsIkhvcml6b250YWxMaW5lIjoi4pSAIiwiaHNjciI6IvCdkr0iLCJIc2NyIjoi4oSLIiwiaHNsYXNoIjoi4oSPIiwiSHN0cm9rIjoixKYiLCJoc3Ryb2siOiLEpyIsIkh1bXBEb3duSHVtcCI6IuKJjiIsIkh1bXBFcXVhbCI6IuKJjyIsImh5YnVsbCI6IuKBgyIsImh5cGhlbiI6IuKAkCIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJpYyI6IuKBoyIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiSWN5Ijoi0JgiLCJpY3kiOiLQuCIsIklkb3QiOiLEsCIsIklFY3kiOiLQlSIsImllY3kiOiLQtSIsImlleGNsIjoiwqEiLCJpZmYiOiLih5QiLCJpZnIiOiLwnZSmIiwiSWZyIjoi4oSRIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlpIjoi4oWIIiwiaWlpaW50Ijoi4qiMIiwiaWlpbnQiOiLiiK0iLCJpaW5maW4iOiLip5wiLCJpaW90YSI6IuKEqSIsIklKbGlnIjoixLIiLCJpamxpZyI6IsSzIiwiSW1hY3IiOiLEqiIsImltYWNyIjoixKsiLCJpbWFnZSI6IuKEkSIsIkltYWdpbmFyeUkiOiLihYgiLCJpbWFnbGluZSI6IuKEkCIsImltYWdwYXJ0Ijoi4oSRIiwiaW1hdGgiOiLEsSIsIkltIjoi4oSRIiwiaW1vZiI6IuKKtyIsImltcGVkIjoixrUiLCJJbXBsaWVzIjoi4oeSIiwiaW5jYXJlIjoi4oSFIiwiaW4iOiLiiIgiLCJpbmZpbiI6IuKIniIsImluZmludGllIjoi4qedIiwiaW5vZG90IjoixLEiLCJpbnRjYWwiOiLiiroiLCJpbnQiOiLiiKsiLCJJbnQiOiLiiKwiLCJpbnRlZ2VycyI6IuKEpCIsIkludGVncmFsIjoi4oirIiwiaW50ZXJjYWwiOiLiiroiLCJJbnRlcnNlY3Rpb24iOiLii4IiLCJpbnRsYXJoayI6IuKolyIsImludHByb2QiOiLiqLwiLCJJbnZpc2libGVDb21tYSI6IuKBoyIsIkludmlzaWJsZVRpbWVzIjoi4oGiIiwiSU9jeSI6ItCBIiwiaW9jeSI6ItGRIiwiSW9nb24iOiLEriIsImlvZ29uIjoixK8iLCJJb3BmIjoi8J2VgCIsImlvcGYiOiLwnZWaIiwiSW90YSI6Is6ZIiwiaW90YSI6Is65IiwiaXByb2QiOiLiqLwiLCJpcXVlc3QiOiLCvyIsImlzY3IiOiLwnZK+IiwiSXNjciI6IuKEkCIsImlzaW4iOiLiiIgiLCJpc2luZG90Ijoi4ou1IiwiaXNpbkUiOiLii7kiLCJpc2lucyI6IuKLtCIsImlzaW5zdiI6IuKLsyIsImlzaW52Ijoi4oiIIiwiaXQiOiLigaIiLCJJdGlsZGUiOiLEqCIsIml0aWxkZSI6IsSpIiwiSXVrY3kiOiLQhiIsIml1a2N5Ijoi0ZYiLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJKY2lyYyI6IsS0IiwiamNpcmMiOiLEtSIsIkpjeSI6ItCZIiwiamN5Ijoi0LkiLCJKZnIiOiLwnZSNIiwiamZyIjoi8J2UpyIsImptYXRoIjoiyLciLCJKb3BmIjoi8J2VgSIsImpvcGYiOiLwnZWbIiwiSnNjciI6IvCdkqUiLCJqc2NyIjoi8J2SvyIsIkpzZXJjeSI6ItCIIiwianNlcmN5Ijoi0ZgiLCJKdWtjeSI6ItCEIiwianVrY3kiOiLRlCIsIkthcHBhIjoizpoiLCJrYXBwYSI6Is66Iiwia2FwcGF2Ijoiz7AiLCJLY2VkaWwiOiLEtiIsImtjZWRpbCI6IsS3IiwiS2N5Ijoi0JoiLCJrY3kiOiLQuiIsIktmciI6IvCdlI4iLCJrZnIiOiLwnZSoIiwia2dyZWVuIjoixLgiLCJLSGN5Ijoi0KUiLCJraGN5Ijoi0YUiLCJLSmN5Ijoi0IwiLCJramN5Ijoi0ZwiLCJLb3BmIjoi8J2VgiIsImtvcGYiOiLwnZWcIiwiS3NjciI6IvCdkqYiLCJrc2NyIjoi8J2TgCIsImxBYXJyIjoi4oeaIiwiTGFjdXRlIjoixLkiLCJsYWN1dGUiOiLEuiIsImxhZW1wdHl2Ijoi4qa0IiwibGFncmFuIjoi4oSSIiwiTGFtYmRhIjoizpsiLCJsYW1iZGEiOiLOuyIsImxhbmciOiLin6giLCJMYW5nIjoi4p+qIiwibGFuZ2QiOiLippEiLCJsYW5nbGUiOiLin6giLCJsYXAiOiLiqoUiLCJMYXBsYWNldHJmIjoi4oSSIiwibGFxdW8iOiLCqyIsImxhcnJiIjoi4oekIiwibGFycmJmcyI6IuKknyIsImxhcnIiOiLihpAiLCJMYXJyIjoi4oaeIiwibEFyciI6IuKHkCIsImxhcnJmcyI6IuKknSIsImxhcnJoayI6IuKGqSIsImxhcnJscCI6IuKGqyIsImxhcnJwbCI6IuKkuSIsImxhcnJzaW0iOiLipbMiLCJsYXJydGwiOiLihqIiLCJsYXRhaWwiOiLipJkiLCJsQXRhaWwiOiLipJsiLCJsYXQiOiLiqqsiLCJsYXRlIjoi4qqtIiwibGF0ZXMiOiLiqq3vuIAiLCJsYmFyciI6IuKkjCIsImxCYXJyIjoi4qSOIiwibGJicmsiOiLinbIiLCJsYnJhY2UiOiJ7IiwibGJyYWNrIjoiWyIsImxicmtlIjoi4qaLIiwibGJya3NsZCI6IuKmjyIsImxicmtzbHUiOiLipo0iLCJMY2Fyb24iOiLEvSIsImxjYXJvbiI6IsS+IiwiTGNlZGlsIjoixLsiLCJsY2VkaWwiOiLEvCIsImxjZWlsIjoi4oyIIiwibGN1YiI6InsiLCJMY3kiOiLQmyIsImxjeSI6ItC7IiwibGRjYSI6IuKktiIsImxkcXVvIjoi4oCcIiwibGRxdW9yIjoi4oCeIiwibGRyZGhhciI6IuKlpyIsImxkcnVzaGFyIjoi4qWLIiwibGRzaCI6IuKGsiIsImxlIjoi4omkIiwibEUiOiLiiaYiLCJMZWZ0QW5nbGVCcmFja2V0Ijoi4p+oIiwiTGVmdEFycm93QmFyIjoi4oekIiwibGVmdGFycm93Ijoi4oaQIiwiTGVmdEFycm93Ijoi4oaQIiwiTGVmdGFycm93Ijoi4oeQIiwiTGVmdEFycm93UmlnaHRBcnJvdyI6IuKHhiIsImxlZnRhcnJvd3RhaWwiOiLihqIiLCJMZWZ0Q2VpbGluZyI6IuKMiCIsIkxlZnREb3VibGVCcmFja2V0Ijoi4p+mIiwiTGVmdERvd25UZWVWZWN0b3IiOiLipaEiLCJMZWZ0RG93blZlY3RvckJhciI6IuKlmSIsIkxlZnREb3duVmVjdG9yIjoi4oeDIiwiTGVmdEZsb29yIjoi4oyKIiwibGVmdGhhcnBvb25kb3duIjoi4oa9IiwibGVmdGhhcnBvb251cCI6IuKGvCIsImxlZnRsZWZ0YXJyb3dzIjoi4oeHIiwibGVmdHJpZ2h0YXJyb3ciOiLihpQiLCJMZWZ0UmlnaHRBcnJvdyI6IuKGlCIsIkxlZnRyaWdodGFycm93Ijoi4oeUIiwibGVmdHJpZ2h0YXJyb3dzIjoi4oeGIiwibGVmdHJpZ2h0aGFycG9vbnMiOiLih4siLCJsZWZ0cmlnaHRzcXVpZ2Fycm93Ijoi4oatIiwiTGVmdFJpZ2h0VmVjdG9yIjoi4qWOIiwiTGVmdFRlZUFycm93Ijoi4oakIiwiTGVmdFRlZSI6IuKKoyIsIkxlZnRUZWVWZWN0b3IiOiLipZoiLCJsZWZ0dGhyZWV0aW1lcyI6IuKLiyIsIkxlZnRUcmlhbmdsZUJhciI6IuKnjyIsIkxlZnRUcmlhbmdsZSI6IuKKsiIsIkxlZnRUcmlhbmdsZUVxdWFsIjoi4oq0IiwiTGVmdFVwRG93blZlY3RvciI6IuKlkSIsIkxlZnRVcFRlZVZlY3RvciI6IuKloCIsIkxlZnRVcFZlY3RvckJhciI6IuKlmCIsIkxlZnRVcFZlY3RvciI6IuKGvyIsIkxlZnRWZWN0b3JCYXIiOiLipZIiLCJMZWZ0VmVjdG9yIjoi4oa8IiwibEVnIjoi4qqLIiwibGVnIjoi4ouaIiwibGVxIjoi4omkIiwibGVxcSI6IuKJpiIsImxlcXNsYW50Ijoi4qm9IiwibGVzY2MiOiLiqqgiLCJsZXMiOiLiqb0iLCJsZXNkb3QiOiLiqb8iLCJsZXNkb3RvIjoi4qqBIiwibGVzZG90b3IiOiLiqoMiLCJsZXNnIjoi4oua77iAIiwibGVzZ2VzIjoi4qqTIiwibGVzc2FwcHJveCI6IuKqhSIsImxlc3Nkb3QiOiLii5YiLCJsZXNzZXFndHIiOiLii5oiLCJsZXNzZXFxZ3RyIjoi4qqLIiwiTGVzc0VxdWFsR3JlYXRlciI6IuKLmiIsIkxlc3NGdWxsRXF1YWwiOiLiiaYiLCJMZXNzR3JlYXRlciI6IuKJtiIsImxlc3NndHIiOiLiibYiLCJMZXNzTGVzcyI6IuKqoSIsImxlc3NzaW0iOiLiibIiLCJMZXNzU2xhbnRFcXVhbCI6IuKpvSIsIkxlc3NUaWxkZSI6IuKJsiIsImxmaXNodCI6IuKlvCIsImxmbG9vciI6IuKMiiIsIkxmciI6IvCdlI8iLCJsZnIiOiLwnZSpIiwibGciOiLiibYiLCJsZ0UiOiLiqpEiLCJsSGFyIjoi4qWiIiwibGhhcmQiOiLihr0iLCJsaGFydSI6IuKGvCIsImxoYXJ1bCI6IuKlqiIsImxoYmxrIjoi4paEIiwiTEpjeSI6ItCJIiwibGpjeSI6ItGZIiwibGxhcnIiOiLih4ciLCJsbCI6IuKJqiIsIkxsIjoi4ouYIiwibGxjb3JuZXIiOiLijJ4iLCJMbGVmdGFycm93Ijoi4oeaIiwibGxoYXJkIjoi4qWrIiwibGx0cmkiOiLil7oiLCJMbWlkb3QiOiLEvyIsImxtaWRvdCI6IsWAIiwibG1vdXN0YWNoZSI6IuKOsCIsImxtb3VzdCI6IuKOsCIsImxuYXAiOiLiqokiLCJsbmFwcHJveCI6IuKqiSIsImxuZSI6IuKqhyIsImxuRSI6IuKJqCIsImxuZXEiOiLiqociLCJsbmVxcSI6IuKJqCIsImxuc2ltIjoi4oumIiwibG9hbmciOiLin6wiLCJsb2FyciI6IuKHvSIsImxvYnJrIjoi4p+mIiwibG9uZ2xlZnRhcnJvdyI6IuKftSIsIkxvbmdMZWZ0QXJyb3ciOiLin7UiLCJMb25nbGVmdGFycm93Ijoi4p+4IiwibG9uZ2xlZnRyaWdodGFycm93Ijoi4p+3IiwiTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+3IiwiTG9uZ2xlZnRyaWdodGFycm93Ijoi4p+6IiwibG9uZ21hcHN0byI6IuKfvCIsImxvbmdyaWdodGFycm93Ijoi4p+2IiwiTG9uZ1JpZ2h0QXJyb3ciOiLin7YiLCJMb25ncmlnaHRhcnJvdyI6IuKfuSIsImxvb3BhcnJvd2xlZnQiOiLihqsiLCJsb29wYXJyb3dyaWdodCI6IuKGrCIsImxvcGFyIjoi4qaFIiwiTG9wZiI6IvCdlYMiLCJsb3BmIjoi8J2VnSIsImxvcGx1cyI6IuKorSIsImxvdGltZXMiOiLiqLQiLCJsb3dhc3QiOiLiiJciLCJsb3diYXIiOiJfIiwiTG93ZXJMZWZ0QXJyb3ciOiLihpkiLCJMb3dlclJpZ2h0QXJyb3ciOiLihpgiLCJsb3oiOiLil4oiLCJsb3plbmdlIjoi4peKIiwibG96ZiI6IuKnqyIsImxwYXIiOiIoIiwibHBhcmx0Ijoi4qaTIiwibHJhcnIiOiLih4YiLCJscmNvcm5lciI6IuKMnyIsImxyaGFyIjoi4oeLIiwibHJoYXJkIjoi4qWtIiwibHJtIjoi4oCOIiwibHJ0cmkiOiLiir8iLCJsc2FxdW8iOiLigLkiLCJsc2NyIjoi8J2TgSIsIkxzY3IiOiLihJIiLCJsc2giOiLihrAiLCJMc2giOiLihrAiLCJsc2ltIjoi4omyIiwibHNpbWUiOiLiqo0iLCJsc2ltZyI6IuKqjyIsImxzcWIiOiJbIiwibHNxdW8iOiLigJgiLCJsc3F1b3IiOiLigJoiLCJMc3Ryb2siOiLFgSIsImxzdHJvayI6IsWCIiwibHRjYyI6IuKqpiIsImx0Y2lyIjoi4qm5IiwibHQiOiI8IiwiTFQiOiI8IiwiTHQiOiLiiaoiLCJsdGRvdCI6IuKLliIsImx0aHJlZSI6IuKLiyIsImx0aW1lcyI6IuKLiSIsImx0bGFyciI6IuKltiIsImx0cXVlc3QiOiLiqbsiLCJsdHJpIjoi4peDIiwibHRyaWUiOiLiirQiLCJsdHJpZiI6IuKXgiIsImx0clBhciI6IuKmliIsImx1cmRzaGFyIjoi4qWKIiwibHVydWhhciI6IuKlpiIsImx2ZXJ0bmVxcSI6IuKJqO+4gCIsImx2bkUiOiLiiajvuIAiLCJtYWNyIjoiwq8iLCJtYWxlIjoi4pmCIiwibWFsdCI6IuKcoCIsIm1hbHRlc2UiOiLinKAiLCJNYXAiOiLipIUiLCJtYXAiOiLihqYiLCJtYXBzdG8iOiLihqYiLCJtYXBzdG9kb3duIjoi4oanIiwibWFwc3RvbGVmdCI6IuKGpCIsIm1hcHN0b3VwIjoi4oalIiwibWFya2VyIjoi4pauIiwibWNvbW1hIjoi4qipIiwiTWN5Ijoi0JwiLCJtY3kiOiLQvCIsIm1kYXNoIjoi4oCUIiwibUREb3QiOiLiiLoiLCJtZWFzdXJlZGFuZ2xlIjoi4oihIiwiTWVkaXVtU3BhY2UiOiLigZ8iLCJNZWxsaW50cmYiOiLihLMiLCJNZnIiOiLwnZSQIiwibWZyIjoi8J2UqiIsIm1obyI6IuKEpyIsIm1pY3JvIjoiwrUiLCJtaWRhc3QiOiIqIiwibWlkY2lyIjoi4quwIiwibWlkIjoi4oijIiwibWlkZG90IjoiwrciLCJtaW51c2IiOiLiip8iLCJtaW51cyI6IuKIkiIsIm1pbnVzZCI6IuKIuCIsIm1pbnVzZHUiOiLiqKoiLCJNaW51c1BsdXMiOiLiiJMiLCJtbGNwIjoi4qubIiwibWxkciI6IuKApiIsIm1ucGx1cyI6IuKIkyIsIm1vZGVscyI6IuKKpyIsIk1vcGYiOiLwnZWEIiwibW9wZiI6IvCdlZ4iLCJtcCI6IuKIkyIsIm1zY3IiOiLwnZOCIiwiTXNjciI6IuKEsyIsIm1zdHBvcyI6IuKIviIsIk11IjoizpwiLCJtdSI6Is68IiwibXVsdGltYXAiOiLiirgiLCJtdW1hcCI6IuKKuCIsIm5hYmxhIjoi4oiHIiwiTmFjdXRlIjoixYMiLCJuYWN1dGUiOiLFhCIsIm5hbmciOiLiiKDig5IiLCJuYXAiOiLiiYkiLCJuYXBFIjoi4qmwzLgiLCJuYXBpZCI6IuKJi8y4IiwibmFwb3MiOiLFiSIsIm5hcHByb3giOiLiiYkiLCJuYXR1cmFsIjoi4pmuIiwibmF0dXJhbHMiOiLihJUiLCJuYXR1ciI6IuKZriIsIm5ic3AiOiLCoCIsIm5idW1wIjoi4omOzLgiLCJuYnVtcGUiOiLiiY/MuCIsIm5jYXAiOiLiqYMiLCJOY2Fyb24iOiLFhyIsIm5jYXJvbiI6IsWIIiwiTmNlZGlsIjoixYUiLCJuY2VkaWwiOiLFhiIsIm5jb25nIjoi4omHIiwibmNvbmdkb3QiOiLiqa3MuCIsIm5jdXAiOiLiqYIiLCJOY3kiOiLQnSIsIm5jeSI6ItC9IiwibmRhc2giOiLigJMiLCJuZWFyaGsiOiLipKQiLCJuZWFyciI6IuKGlyIsIm5lQXJyIjoi4oeXIiwibmVhcnJvdyI6IuKGlyIsIm5lIjoi4omgIiwibmVkb3QiOiLiiZDMuCIsIk5lZ2F0aXZlTWVkaXVtU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaWNrU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaW5TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZSI6IuKAiyIsIm5lcXVpdiI6IuKJoiIsIm5lc2VhciI6IuKkqCIsIm5lc2ltIjoi4omCzLgiLCJOZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKJqyIsIk5lc3RlZExlc3NMZXNzIjoi4omqIiwiTmV3TGluZSI6IlxcbiIsIm5leGlzdCI6IuKIhCIsIm5leGlzdHMiOiLiiIQiLCJOZnIiOiLwnZSRIiwibmZyIjoi8J2UqyIsIm5nRSI6IuKJp8y4IiwibmdlIjoi4omxIiwibmdlcSI6IuKJsSIsIm5nZXFxIjoi4omnzLgiLCJuZ2Vxc2xhbnQiOiLiqb7MuCIsIm5nZXMiOiLiqb7MuCIsIm5HZyI6IuKLmcy4IiwibmdzaW0iOiLiibUiLCJuR3QiOiLiiavig5IiLCJuZ3QiOiLiia8iLCJuZ3RyIjoi4omvIiwibkd0diI6IuKJq8y4IiwibmhhcnIiOiLihq4iLCJuaEFyciI6IuKHjiIsIm5ocGFyIjoi4quyIiwibmkiOiLiiIsiLCJuaXMiOiLii7wiLCJuaXNkIjoi4ou6Iiwibml2Ijoi4oiLIiwiTkpjeSI6ItCKIiwibmpjeSI6ItGaIiwibmxhcnIiOiLihpoiLCJubEFyciI6IuKHjSIsIm5sZHIiOiLigKUiLCJubEUiOiLiiabMuCIsIm5sZSI6IuKJsCIsIm5sZWZ0YXJyb3ciOiLihpoiLCJuTGVmdGFycm93Ijoi4oeNIiwibmxlZnRyaWdodGFycm93Ijoi4oauIiwibkxlZnRyaWdodGFycm93Ijoi4oeOIiwibmxlcSI6IuKJsCIsIm5sZXFxIjoi4ommzLgiLCJubGVxc2xhbnQiOiLiqb3MuCIsIm5sZXMiOiLiqb3MuCIsIm5sZXNzIjoi4omuIiwibkxsIjoi4ouYzLgiLCJubHNpbSI6IuKJtCIsIm5MdCI6IuKJquKDkiIsIm5sdCI6IuKJriIsIm5sdHJpIjoi4ouqIiwibmx0cmllIjoi4ousIiwibkx0diI6IuKJqsy4Iiwibm1pZCI6IuKIpCIsIk5vQnJlYWsiOiLigaAiLCJOb25CcmVha2luZ1NwYWNlIjoiwqAiLCJub3BmIjoi8J2VnyIsIk5vcGYiOiLihJUiLCJOb3QiOiLiq6wiLCJub3QiOiLCrCIsIk5vdENvbmdydWVudCI6IuKJoiIsIk5vdEN1cENhcCI6IuKJrSIsIk5vdERvdWJsZVZlcnRpY2FsQmFyIjoi4oimIiwiTm90RWxlbWVudCI6IuKIiSIsIk5vdEVxdWFsIjoi4omgIiwiTm90RXF1YWxUaWxkZSI6IuKJgsy4IiwiTm90RXhpc3RzIjoi4oiEIiwiTm90R3JlYXRlciI6IuKJryIsIk5vdEdyZWF0ZXJFcXVhbCI6IuKJsSIsIk5vdEdyZWF0ZXJGdWxsRXF1YWwiOiLiiafMuCIsIk5vdEdyZWF0ZXJHcmVhdGVyIjoi4omrzLgiLCJOb3RHcmVhdGVyTGVzcyI6IuKJuSIsIk5vdEdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+zLgiLCJOb3RHcmVhdGVyVGlsZGUiOiLiibUiLCJOb3RIdW1wRG93bkh1bXAiOiLiiY7MuCIsIk5vdEh1bXBFcXVhbCI6IuKJj8y4Iiwibm90aW4iOiLiiIkiLCJub3RpbmRvdCI6IuKLtcy4Iiwibm90aW5FIjoi4ou5zLgiLCJub3RpbnZhIjoi4oiJIiwibm90aW52YiI6IuKLtyIsIm5vdGludmMiOiLii7YiLCJOb3RMZWZ0VHJpYW5nbGVCYXIiOiLip4/MuCIsIk5vdExlZnRUcmlhbmdsZSI6IuKLqiIsIk5vdExlZnRUcmlhbmdsZUVxdWFsIjoi4ousIiwiTm90TGVzcyI6IuKJriIsIk5vdExlc3NFcXVhbCI6IuKJsCIsIk5vdExlc3NHcmVhdGVyIjoi4om4IiwiTm90TGVzc0xlc3MiOiLiiarMuCIsIk5vdExlc3NTbGFudEVxdWFsIjoi4qm9zLgiLCJOb3RMZXNzVGlsZGUiOiLiibQiLCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKqosy4IiwiTm90TmVzdGVkTGVzc0xlc3MiOiLiqqHMuCIsIm5vdG5pIjoi4oiMIiwibm90bml2YSI6IuKIjCIsIm5vdG5pdmIiOiLii74iLCJub3RuaXZjIjoi4ou9IiwiTm90UHJlY2VkZXMiOiLiioAiLCJOb3RQcmVjZWRlc0VxdWFsIjoi4qqvzLgiLCJOb3RQcmVjZWRlc1NsYW50RXF1YWwiOiLii6AiLCJOb3RSZXZlcnNlRWxlbWVudCI6IuKIjCIsIk5vdFJpZ2h0VHJpYW5nbGVCYXIiOiLip5DMuCIsIk5vdFJpZ2h0VHJpYW5nbGUiOiLii6siLCJOb3RSaWdodFRyaWFuZ2xlRXF1YWwiOiLii60iLCJOb3RTcXVhcmVTdWJzZXQiOiLiio/MuCIsIk5vdFNxdWFyZVN1YnNldEVxdWFsIjoi4ouiIiwiTm90U3F1YXJlU3VwZXJzZXQiOiLiipDMuCIsIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWwiOiLii6MiLCJOb3RTdWJzZXQiOiLiioLig5IiLCJOb3RTdWJzZXRFcXVhbCI6IuKKiCIsIk5vdFN1Y2NlZWRzIjoi4oqBIiwiTm90U3VjY2VlZHNFcXVhbCI6IuKqsMy4IiwiTm90U3VjY2VlZHNTbGFudEVxdWFsIjoi4ouhIiwiTm90U3VjY2VlZHNUaWxkZSI6IuKJv8y4IiwiTm90U3VwZXJzZXQiOiLiioPig5IiLCJOb3RTdXBlcnNldEVxdWFsIjoi4oqJIiwiTm90VGlsZGUiOiLiiYEiLCJOb3RUaWxkZUVxdWFsIjoi4omEIiwiTm90VGlsZGVGdWxsRXF1YWwiOiLiiYciLCJOb3RUaWxkZVRpbGRlIjoi4omJIiwiTm90VmVydGljYWxCYXIiOiLiiKQiLCJucGFyYWxsZWwiOiLiiKYiLCJucGFyIjoi4oimIiwibnBhcnNsIjoi4qu94oOlIiwibnBhcnQiOiLiiILMuCIsIm5wb2xpbnQiOiLiqJQiLCJucHIiOiLiioAiLCJucHJjdWUiOiLii6AiLCJucHJlYyI6IuKKgCIsIm5wcmVjZXEiOiLiqq/MuCIsIm5wcmUiOiLiqq/MuCIsIm5yYXJyYyI6IuKks8y4IiwibnJhcnIiOiLihpsiLCJuckFyciI6IuKHjyIsIm5yYXJydyI6IuKGncy4IiwibnJpZ2h0YXJyb3ciOiLihpsiLCJuUmlnaHRhcnJvdyI6IuKHjyIsIm5ydHJpIjoi4ourIiwibnJ0cmllIjoi4outIiwibnNjIjoi4oqBIiwibnNjY3VlIjoi4ouhIiwibnNjZSI6IuKqsMy4IiwiTnNjciI6IvCdkqkiLCJuc2NyIjoi8J2TgyIsIm5zaG9ydG1pZCI6IuKIpCIsIm5zaG9ydHBhcmFsbGVsIjoi4oimIiwibnNpbSI6IuKJgSIsIm5zaW1lIjoi4omEIiwibnNpbWVxIjoi4omEIiwibnNtaWQiOiLiiKQiLCJuc3BhciI6IuKIpiIsIm5zcXN1YmUiOiLii6IiLCJuc3FzdXBlIjoi4oujIiwibnN1YiI6IuKKhCIsIm5zdWJFIjoi4quFzLgiLCJuc3ViZSI6IuKKiCIsIm5zdWJzZXQiOiLiioLig5IiLCJuc3Vic2V0ZXEiOiLiiogiLCJuc3Vic2V0ZXFxIjoi4quFzLgiLCJuc3VjYyI6IuKKgSIsIm5zdWNjZXEiOiLiqrDMuCIsIm5zdXAiOiLiioUiLCJuc3VwRSI6IuKrhsy4IiwibnN1cGUiOiLiiokiLCJuc3Vwc2V0Ijoi4oqD4oOSIiwibnN1cHNldGVxIjoi4oqJIiwibnN1cHNldGVxcSI6IuKrhsy4IiwibnRnbCI6IuKJuSIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJudGxnIjoi4om4IiwibnRyaWFuZ2xlbGVmdCI6IuKLqiIsIm50cmlhbmdsZWxlZnRlcSI6IuKLrCIsIm50cmlhbmdsZXJpZ2h0Ijoi4ourIiwibnRyaWFuZ2xlcmlnaHRlcSI6IuKLrSIsIk51Ijoizp0iLCJudSI6Is69IiwibnVtIjoiIyIsIm51bWVybyI6IuKEliIsIm51bXNwIjoi4oCHIiwibnZhcCI6IuKJjeKDkiIsIm52ZGFzaCI6IuKKrCIsIm52RGFzaCI6IuKKrSIsIm5WZGFzaCI6IuKKriIsIm5WRGFzaCI6IuKKryIsIm52Z2UiOiLiiaXig5IiLCJudmd0IjoiPuKDkiIsIm52SGFyciI6IuKkhCIsIm52aW5maW4iOiLip54iLCJudmxBcnIiOiLipIIiLCJudmxlIjoi4omk4oOSIiwibnZsdCI6Ijzig5IiLCJudmx0cmllIjoi4oq04oOSIiwibnZyQXJyIjoi4qSDIiwibnZydHJpZSI6IuKKteKDkiIsIm52c2ltIjoi4oi84oOSIiwibndhcmhrIjoi4qSjIiwibndhcnIiOiLihpYiLCJud0FyciI6IuKHliIsIm53YXJyb3ciOiLihpYiLCJud25lYXIiOiLipKciLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwib2FzdCI6IuKKmyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0Iiwib2NpciI6IuKKmiIsIk9jeSI6ItCeIiwib2N5Ijoi0L4iLCJvZGFzaCI6IuKKnSIsIk9kYmxhYyI6IsWQIiwib2RibGFjIjoixZEiLCJvZGl2Ijoi4qi4Iiwib2RvdCI6IuKKmSIsIm9kc29sZCI6IuKmvCIsIk9FbGlnIjoixZIiLCJvZWxpZyI6IsWTIiwib2ZjaXIiOiLipr8iLCJPZnIiOiLwnZSSIiwib2ZyIjoi8J2UrCIsIm9nb24iOiLLmyIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvZ3QiOiLip4EiLCJvaGJhciI6IuKmtSIsIm9obSI6Is6pIiwib2ludCI6IuKIriIsIm9sYXJyIjoi4oa6Iiwib2xjaXIiOiLipr4iLCJvbGNyb3NzIjoi4qa7Iiwib2xpbmUiOiLigL4iLCJvbHQiOiLip4AiLCJPbWFjciI6IsWMIiwib21hY3IiOiLFjSIsIk9tZWdhIjoizqkiLCJvbWVnYSI6Is+JIiwiT21pY3JvbiI6Is6fIiwib21pY3JvbiI6Is6/Iiwib21pZCI6IuKmtiIsIm9taW51cyI6IuKKliIsIk9vcGYiOiLwnZWGIiwib29wZiI6IvCdlaAiLCJvcGFyIjoi4qa3IiwiT3BlbkN1cmx5RG91YmxlUXVvdGUiOiLigJwiLCJPcGVuQ3VybHlRdW90ZSI6IuKAmCIsIm9wZXJwIjoi4qa5Iiwib3BsdXMiOiLiipUiLCJvcmFyciI6IuKGuyIsIk9yIjoi4qmUIiwib3IiOiLiiKgiLCJvcmQiOiLiqZ0iLCJvcmRlciI6IuKEtCIsIm9yZGVyb2YiOiLihLQiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJvcmlnb2YiOiLiirYiLCJvcm9yIjoi4qmWIiwib3JzbG9wZSI6IuKplyIsIm9ydiI6IuKpmyIsIm9TIjoi4pOIIiwiT3NjciI6IvCdkqoiLCJvc2NyIjoi4oS0IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIm9zb2wiOiLiipgiLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1Iiwib3RpbWVzYXMiOiLiqLYiLCJPdGltZXMiOiLiqLciLCJvdGltZXMiOiLiipciLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJvdmJhciI6IuKMvSIsIk92ZXJCYXIiOiLigL4iLCJPdmVyQnJhY2UiOiLij54iLCJPdmVyQnJhY2tldCI6IuKOtCIsIk92ZXJQYXJlbnRoZXNpcyI6IuKPnCIsInBhcmEiOiLCtiIsInBhcmFsbGVsIjoi4oilIiwicGFyIjoi4oilIiwicGFyc2ltIjoi4quzIiwicGFyc2wiOiLiq70iLCJwYXJ0Ijoi4oiCIiwiUGFydGlhbEQiOiLiiIIiLCJQY3kiOiLQnyIsInBjeSI6ItC/IiwicGVyY250IjoiJSIsInBlcmlvZCI6Ii4iLCJwZXJtaWwiOiLigLAiLCJwZXJwIjoi4oqlIiwicGVydGVuayI6IuKAsSIsIlBmciI6IvCdlJMiLCJwZnIiOiLwnZStIiwiUGhpIjoizqYiLCJwaGkiOiLPhiIsInBoaXYiOiLPlSIsInBobW1hdCI6IuKEsyIsInBob25lIjoi4piOIiwiUGkiOiLOoCIsInBpIjoiz4AiLCJwaXRjaGZvcmsiOiLii5QiLCJwaXYiOiLPliIsInBsYW5jayI6IuKEjyIsInBsYW5ja2giOiLihI4iLCJwbGFua3YiOiLihI8iLCJwbHVzYWNpciI6IuKooyIsInBsdXNiIjoi4oqeIiwicGx1c2NpciI6IuKooiIsInBsdXMiOiIrIiwicGx1c2RvIjoi4oiUIiwicGx1c2R1Ijoi4qilIiwicGx1c2UiOiLiqbIiLCJQbHVzTWludXMiOiLCsSIsInBsdXNtbiI6IsKxIiwicGx1c3NpbSI6IuKopiIsInBsdXN0d28iOiLiqKciLCJwbSI6IsKxIiwiUG9pbmNhcmVwbGFuZSI6IuKEjCIsInBvaW50aW50Ijoi4qiVIiwicG9wZiI6IvCdlaEiLCJQb3BmIjoi4oSZIiwicG91bmQiOiLCoyIsInByYXAiOiLiqrciLCJQciI6IuKquyIsInByIjoi4om6IiwicHJjdWUiOiLiibwiLCJwcmVjYXBwcm94Ijoi4qq3IiwicHJlYyI6IuKJuiIsInByZWNjdXJseWVxIjoi4om8IiwiUHJlY2VkZXMiOiLiiboiLCJQcmVjZWRlc0VxdWFsIjoi4qqvIiwiUHJlY2VkZXNTbGFudEVxdWFsIjoi4om8IiwiUHJlY2VkZXNUaWxkZSI6IuKJviIsInByZWNlcSI6IuKqryIsInByZWNuYXBwcm94Ijoi4qq5IiwicHJlY25lcXEiOiLiqrUiLCJwcmVjbnNpbSI6IuKLqCIsInByZSI6IuKqryIsInByRSI6IuKqsyIsInByZWNzaW0iOiLiib4iLCJwcmltZSI6IuKAsiIsIlByaW1lIjoi4oCzIiwicHJpbWVzIjoi4oSZIiwicHJuYXAiOiLiqrkiLCJwcm5FIjoi4qq1IiwicHJuc2ltIjoi4ouoIiwicHJvZCI6IuKIjyIsIlByb2R1Y3QiOiLiiI8iLCJwcm9mYWxhciI6IuKMriIsInByb2ZsaW5lIjoi4oySIiwicHJvZnN1cmYiOiLijJMiLCJwcm9wIjoi4oidIiwiUHJvcG9ydGlvbmFsIjoi4oidIiwiUHJvcG9ydGlvbiI6IuKItyIsInByb3B0byI6IuKInSIsInByc2ltIjoi4om+IiwicHJ1cmVsIjoi4oqwIiwiUHNjciI6IvCdkqsiLCJwc2NyIjoi8J2ThSIsIlBzaSI6Is6oIiwicHNpIjoiz4giLCJwdW5jc3AiOiLigIgiLCJRZnIiOiLwnZSUIiwicWZyIjoi8J2UriIsInFpbnQiOiLiqIwiLCJxb3BmIjoi8J2VoiIsIlFvcGYiOiLihJoiLCJxcHJpbWUiOiLigZciLCJRc2NyIjoi8J2SrCIsInFzY3IiOiLwnZOGIiwicXVhdGVybmlvbnMiOiLihI0iLCJxdWF0aW50Ijoi4qiWIiwicXVlc3QiOiI/IiwicXVlc3RlcSI6IuKJnyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwickFhcnIiOiLih5siLCJyYWNlIjoi4oi9zLEiLCJSYWN1dGUiOiLFlCIsInJhY3V0ZSI6IsWVIiwicmFkaWMiOiLiiJoiLCJyYWVtcHR5diI6IuKmsyIsInJhbmciOiLin6kiLCJSYW5nIjoi4p+rIiwicmFuZ2QiOiLippIiLCJyYW5nZSI6IuKmpSIsInJhbmdsZSI6IuKfqSIsInJhcXVvIjoiwrsiLCJyYXJyYXAiOiLipbUiLCJyYXJyYiI6IuKHpSIsInJhcnJiZnMiOiLipKAiLCJyYXJyYyI6IuKksyIsInJhcnIiOiLihpIiLCJSYXJyIjoi4oagIiwickFyciI6IuKHkiIsInJhcnJmcyI6IuKkniIsInJhcnJoayI6IuKGqiIsInJhcnJscCI6IuKGrCIsInJhcnJwbCI6IuKlhSIsInJhcnJzaW0iOiLipbQiLCJSYXJydGwiOiLipJYiLCJyYXJydGwiOiLihqMiLCJyYXJydyI6IuKGnSIsInJhdGFpbCI6IuKkmiIsInJBdGFpbCI6IuKknCIsInJhdGlvIjoi4oi2IiwicmF0aW9uYWxzIjoi4oSaIiwicmJhcnIiOiLipI0iLCJyQmFyciI6IuKkjyIsIlJCYXJyIjoi4qSQIiwicmJicmsiOiLinbMiLCJyYnJhY2UiOiJ9IiwicmJyYWNrIjoiXSIsInJicmtlIjoi4qaMIiwicmJya3NsZCI6IuKmjiIsInJicmtzbHUiOiLippAiLCJSY2Fyb24iOiLFmCIsInJjYXJvbiI6IsWZIiwiUmNlZGlsIjoixZYiLCJyY2VkaWwiOiLFlyIsInJjZWlsIjoi4oyJIiwicmN1YiI6In0iLCJSY3kiOiLQoCIsInJjeSI6ItGAIiwicmRjYSI6IuKktyIsInJkbGRoYXIiOiLipakiLCJyZHF1byI6IuKAnSIsInJkcXVvciI6IuKAnSIsInJkc2giOiLihrMiLCJyZWFsIjoi4oScIiwicmVhbGluZSI6IuKEmyIsInJlYWxwYXJ0Ijoi4oScIiwicmVhbHMiOiLihJ0iLCJSZSI6IuKEnCIsInJlY3QiOiLilq0iLCJyZWciOiLCriIsIlJFRyI6IsKuIiwiUmV2ZXJzZUVsZW1lbnQiOiLiiIsiLCJSZXZlcnNlRXF1aWxpYnJpdW0iOiLih4siLCJSZXZlcnNlVXBFcXVpbGlicml1bSI6IuKlryIsInJmaXNodCI6IuKlvSIsInJmbG9vciI6IuKMiyIsInJmciI6IvCdlK8iLCJSZnIiOiLihJwiLCJySGFyIjoi4qWkIiwicmhhcmQiOiLih4EiLCJyaGFydSI6IuKHgCIsInJoYXJ1bCI6IuKlrCIsIlJobyI6Is6hIiwicmhvIjoiz4EiLCJyaG92Ijoiz7EiLCJSaWdodEFuZ2xlQnJhY2tldCI6IuKfqSIsIlJpZ2h0QXJyb3dCYXIiOiLih6UiLCJyaWdodGFycm93Ijoi4oaSIiwiUmlnaHRBcnJvdyI6IuKGkiIsIlJpZ2h0YXJyb3ciOiLih5IiLCJSaWdodEFycm93TGVmdEFycm93Ijoi4oeEIiwicmlnaHRhcnJvd3RhaWwiOiLihqMiLCJSaWdodENlaWxpbmciOiLijIkiLCJSaWdodERvdWJsZUJyYWNrZXQiOiLin6ciLCJSaWdodERvd25UZWVWZWN0b3IiOiLipZ0iLCJSaWdodERvd25WZWN0b3JCYXIiOiLipZUiLCJSaWdodERvd25WZWN0b3IiOiLih4IiLCJSaWdodEZsb29yIjoi4oyLIiwicmlnaHRoYXJwb29uZG93biI6IuKHgSIsInJpZ2h0aGFycG9vbnVwIjoi4oeAIiwicmlnaHRsZWZ0YXJyb3dzIjoi4oeEIiwicmlnaHRsZWZ0aGFycG9vbnMiOiLih4wiLCJyaWdodHJpZ2h0YXJyb3dzIjoi4oeJIiwicmlnaHRzcXVpZ2Fycm93Ijoi4oadIiwiUmlnaHRUZWVBcnJvdyI6IuKGpiIsIlJpZ2h0VGVlIjoi4oqiIiwiUmlnaHRUZWVWZWN0b3IiOiLipZsiLCJyaWdodHRocmVldGltZXMiOiLii4wiLCJSaWdodFRyaWFuZ2xlQmFyIjoi4qeQIiwiUmlnaHRUcmlhbmdsZSI6IuKKsyIsIlJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKKtSIsIlJpZ2h0VXBEb3duVmVjdG9yIjoi4qWPIiwiUmlnaHRVcFRlZVZlY3RvciI6IuKlnCIsIlJpZ2h0VXBWZWN0b3JCYXIiOiLipZQiLCJSaWdodFVwVmVjdG9yIjoi4oa+IiwiUmlnaHRWZWN0b3JCYXIiOiLipZMiLCJSaWdodFZlY3RvciI6IuKHgCIsInJpbmciOiLLmiIsInJpc2luZ2RvdHNlcSI6IuKJkyIsInJsYXJyIjoi4oeEIiwicmxoYXIiOiLih4wiLCJybG0iOiLigI8iLCJybW91c3RhY2hlIjoi4o6xIiwicm1vdXN0Ijoi4o6xIiwicm5taWQiOiLiq64iLCJyb2FuZyI6IuKfrSIsInJvYXJyIjoi4oe+Iiwicm9icmsiOiLin6ciLCJyb3BhciI6IuKmhiIsInJvcGYiOiLwnZWjIiwiUm9wZiI6IuKEnSIsInJvcGx1cyI6IuKoriIsInJvdGltZXMiOiLiqLUiLCJSb3VuZEltcGxpZXMiOiLipbAiLCJycGFyIjoiKSIsInJwYXJndCI6IuKmlCIsInJwcG9saW50Ijoi4qiSIiwicnJhcnIiOiLih4kiLCJScmlnaHRhcnJvdyI6IuKHmyIsInJzYXF1byI6IuKAuiIsInJzY3IiOiLwnZOHIiwiUnNjciI6IuKEmyIsInJzaCI6IuKGsSIsIlJzaCI6IuKGsSIsInJzcWIiOiJdIiwicnNxdW8iOiLigJkiLCJyc3F1b3IiOiLigJkiLCJydGhyZWUiOiLii4wiLCJydGltZXMiOiLii4oiLCJydHJpIjoi4pa5IiwicnRyaWUiOiLiirUiLCJydHJpZiI6IuKWuCIsInJ0cmlsdHJpIjoi4qeOIiwiUnVsZURlbGF5ZWQiOiLip7QiLCJydWx1aGFyIjoi4qWoIiwicngiOiLihJ4iLCJTYWN1dGUiOiLFmiIsInNhY3V0ZSI6IsWbIiwic2JxdW8iOiLigJoiLCJzY2FwIjoi4qq4IiwiU2Nhcm9uIjoixaAiLCJzY2Fyb24iOiLFoSIsIlNjIjoi4qq8Iiwic2MiOiLiibsiLCJzY2N1ZSI6IuKJvSIsInNjZSI6IuKqsCIsInNjRSI6IuKqtCIsIlNjZWRpbCI6IsWeIiwic2NlZGlsIjoixZ8iLCJTY2lyYyI6IsWcIiwic2NpcmMiOiLFnSIsInNjbmFwIjoi4qq6Iiwic2NuRSI6IuKqtiIsInNjbnNpbSI6IuKLqSIsInNjcG9saW50Ijoi4qiTIiwic2NzaW0iOiLiib8iLCJTY3kiOiLQoSIsInNjeSI6ItGBIiwic2RvdGIiOiLiiqEiLCJzZG90Ijoi4ouFIiwic2RvdGUiOiLiqaYiLCJzZWFyaGsiOiLipKUiLCJzZWFyciI6IuKGmCIsInNlQXJyIjoi4oeYIiwic2VhcnJvdyI6IuKGmCIsInNlY3QiOiLCpyIsInNlbWkiOiI7Iiwic2Vzd2FyIjoi4qSpIiwic2V0bWludXMiOiLiiJYiLCJzZXRtbiI6IuKIliIsInNleHQiOiLinLYiLCJTZnIiOiLwnZSWIiwic2ZyIjoi8J2UsCIsInNmcm93biI6IuKMoiIsInNoYXJwIjoi4pmvIiwiU0hDSGN5Ijoi0KkiLCJzaGNoY3kiOiLRiSIsIlNIY3kiOiLQqCIsInNoY3kiOiLRiCIsIlNob3J0RG93bkFycm93Ijoi4oaTIiwiU2hvcnRMZWZ0QXJyb3ciOiLihpAiLCJzaG9ydG1pZCI6IuKIoyIsInNob3J0cGFyYWxsZWwiOiLiiKUiLCJTaG9ydFJpZ2h0QXJyb3ciOiLihpIiLCJTaG9ydFVwQXJyb3ciOiLihpEiLCJzaHkiOiLCrSIsIlNpZ21hIjoizqMiLCJzaWdtYSI6Is+DIiwic2lnbWFmIjoiz4IiLCJzaWdtYXYiOiLPgiIsInNpbSI6IuKIvCIsInNpbWRvdCI6IuKpqiIsInNpbWUiOiLiiYMiLCJzaW1lcSI6IuKJgyIsInNpbWciOiLiqp4iLCJzaW1nRSI6IuKqoCIsInNpbWwiOiLiqp0iLCJzaW1sRSI6IuKqnyIsInNpbW5lIjoi4omGIiwic2ltcGx1cyI6IuKopCIsInNpbXJhcnIiOiLipbIiLCJzbGFyciI6IuKGkCIsIlNtYWxsQ2lyY2xlIjoi4oiYIiwic21hbGxzZXRtaW51cyI6IuKIliIsInNtYXNocCI6IuKosyIsInNtZXBhcnNsIjoi4qekIiwic21pZCI6IuKIoyIsInNtaWxlIjoi4oyjIiwic210Ijoi4qqqIiwic210ZSI6IuKqrCIsInNtdGVzIjoi4qqs77iAIiwiU09GVGN5Ijoi0KwiLCJzb2Z0Y3kiOiLRjCIsInNvbGJhciI6IuKMvyIsInNvbGIiOiLip4QiLCJzb2wiOiIvIiwiU29wZiI6IvCdlYoiLCJzb3BmIjoi8J2VpCIsInNwYWRlcyI6IuKZoCIsInNwYWRlc3VpdCI6IuKZoCIsInNwYXIiOiLiiKUiLCJzcWNhcCI6IuKKkyIsInNxY2FwcyI6IuKKk++4gCIsInNxY3VwIjoi4oqUIiwic3FjdXBzIjoi4oqU77iAIiwiU3FydCI6IuKImiIsInNxc3ViIjoi4oqPIiwic3FzdWJlIjoi4oqRIiwic3FzdWJzZXQiOiLiio8iLCJzcXN1YnNldGVxIjoi4oqRIiwic3FzdXAiOiLiipAiLCJzcXN1cGUiOiLiipIiLCJzcXN1cHNldCI6IuKKkCIsInNxc3Vwc2V0ZXEiOiLiipIiLCJzcXVhcmUiOiLilqEiLCJTcXVhcmUiOiLilqEiLCJTcXVhcmVJbnRlcnNlY3Rpb24iOiLiipMiLCJTcXVhcmVTdWJzZXQiOiLiio8iLCJTcXVhcmVTdWJzZXRFcXVhbCI6IuKKkSIsIlNxdWFyZVN1cGVyc2V0Ijoi4oqQIiwiU3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKKkiIsIlNxdWFyZVVuaW9uIjoi4oqUIiwic3F1YXJmIjoi4paqIiwic3F1Ijoi4pahIiwic3F1ZiI6IuKWqiIsInNyYXJyIjoi4oaSIiwiU3NjciI6IvCdkq4iLCJzc2NyIjoi8J2TiCIsInNzZXRtbiI6IuKIliIsInNzbWlsZSI6IuKMoyIsInNzdGFyZiI6IuKLhiIsIlN0YXIiOiLii4YiLCJzdGFyIjoi4piGIiwic3RhcmYiOiLimIUiLCJzdHJhaWdodGVwc2lsb24iOiLPtSIsInN0cmFpZ2h0cGhpIjoiz5UiLCJzdHJucyI6IsKvIiwic3ViIjoi4oqCIiwiU3ViIjoi4ouQIiwic3ViZG90Ijoi4qq9Iiwic3ViRSI6IuKrhSIsInN1YmUiOiLiioYiLCJzdWJlZG90Ijoi4quDIiwic3VibXVsdCI6IuKrgSIsInN1Ym5FIjoi4quLIiwic3VibmUiOiLiiooiLCJzdWJwbHVzIjoi4qq/Iiwic3VicmFyciI6IuKluSIsInN1YnNldCI6IuKKgiIsIlN1YnNldCI6IuKLkCIsInN1YnNldGVxIjoi4oqGIiwic3Vic2V0ZXFxIjoi4quFIiwiU3Vic2V0RXF1YWwiOiLiioYiLCJzdWJzZXRuZXEiOiLiiooiLCJzdWJzZXRuZXFxIjoi4quLIiwic3Vic2ltIjoi4quHIiwic3Vic3ViIjoi4quVIiwic3Vic3VwIjoi4quTIiwic3VjY2FwcHJveCI6IuKquCIsInN1Y2MiOiLiibsiLCJzdWNjY3VybHllcSI6IuKJvSIsIlN1Y2NlZWRzIjoi4om7IiwiU3VjY2VlZHNFcXVhbCI6IuKqsCIsIlN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKJvSIsIlN1Y2NlZWRzVGlsZGUiOiLiib8iLCJzdWNjZXEiOiLiqrAiLCJzdWNjbmFwcHJveCI6IuKquiIsInN1Y2NuZXFxIjoi4qq2Iiwic3VjY25zaW0iOiLii6kiLCJzdWNjc2ltIjoi4om/IiwiU3VjaFRoYXQiOiLiiIsiLCJzdW0iOiLiiJEiLCJTdW0iOiLiiJEiLCJzdW5nIjoi4pmqIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3VwIjoi4oqDIiwiU3VwIjoi4ouRIiwic3VwZG90Ijoi4qq+Iiwic3VwZHN1YiI6IuKrmCIsInN1cEUiOiLiq4YiLCJzdXBlIjoi4oqHIiwic3VwZWRvdCI6IuKrhCIsIlN1cGVyc2V0Ijoi4oqDIiwiU3VwZXJzZXRFcXVhbCI6IuKKhyIsInN1cGhzb2wiOiLin4kiLCJzdXBoc3ViIjoi4quXIiwic3VwbGFyciI6IuKluyIsInN1cG11bHQiOiLiq4IiLCJzdXBuRSI6IuKrjCIsInN1cG5lIjoi4oqLIiwic3VwcGx1cyI6IuKrgCIsInN1cHNldCI6IuKKgyIsIlN1cHNldCI6IuKLkSIsInN1cHNldGVxIjoi4oqHIiwic3Vwc2V0ZXFxIjoi4quGIiwic3Vwc2V0bmVxIjoi4oqLIiwic3Vwc2V0bmVxcSI6IuKrjCIsInN1cHNpbSI6IuKriCIsInN1cHN1YiI6IuKrlCIsInN1cHN1cCI6IuKrliIsInN3YXJoayI6IuKkpiIsInN3YXJyIjoi4oaZIiwic3dBcnIiOiLih5kiLCJzd2Fycm93Ijoi4oaZIiwic3dud2FyIjoi4qSqIiwic3psaWciOiLDnyIsIlRhYiI6IlxcdCIsInRhcmdldCI6IuKMliIsIlRhdSI6Is6kIiwidGF1Ijoiz4QiLCJ0YnJrIjoi4o60IiwiVGNhcm9uIjoixaQiLCJ0Y2Fyb24iOiLFpSIsIlRjZWRpbCI6IsWiIiwidGNlZGlsIjoixaMiLCJUY3kiOiLQoiIsInRjeSI6ItGCIiwidGRvdCI6IuKDmyIsInRlbHJlYyI6IuKMlSIsIlRmciI6IvCdlJciLCJ0ZnIiOiLwnZSxIiwidGhlcmU0Ijoi4oi0IiwidGhlcmVmb3JlIjoi4oi0IiwiVGhlcmVmb3JlIjoi4oi0IiwiVGhldGEiOiLOmCIsInRoZXRhIjoizrgiLCJ0aGV0YXN5bSI6Is+RIiwidGhldGF2Ijoiz5EiLCJ0aGlja2FwcHJveCI6IuKJiCIsInRoaWNrc2ltIjoi4oi8IiwiVGhpY2tTcGFjZSI6IuKBn+KAiiIsIlRoaW5TcGFjZSI6IuKAiSIsInRoaW5zcCI6IuKAiSIsInRoa2FwIjoi4omIIiwidGhrc2ltIjoi4oi8IiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aWxkZSI6IsucIiwiVGlsZGUiOiLiiLwiLCJUaWxkZUVxdWFsIjoi4omDIiwiVGlsZGVGdWxsRXF1YWwiOiLiiYUiLCJUaWxkZVRpbGRlIjoi4omIIiwidGltZXNiYXIiOiLiqLEiLCJ0aW1lc2IiOiLiiqAiLCJ0aW1lcyI6IsOXIiwidGltZXNkIjoi4qiwIiwidGludCI6IuKIrSIsInRvZWEiOiLipKgiLCJ0b3Bib3QiOiLijLYiLCJ0b3BjaXIiOiLiq7EiLCJ0b3AiOiLiiqQiLCJUb3BmIjoi8J2ViyIsInRvcGYiOiLwnZWlIiwidG9wZm9yayI6IuKrmiIsInRvc2EiOiLipKkiLCJ0cHJpbWUiOiLigLQiLCJ0cmFkZSI6IuKEoiIsIlRSQURFIjoi4oSiIiwidHJpYW5nbGUiOiLilrUiLCJ0cmlhbmdsZWRvd24iOiLilr8iLCJ0cmlhbmdsZWxlZnQiOiLil4MiLCJ0cmlhbmdsZWxlZnRlcSI6IuKKtCIsInRyaWFuZ2xlcSI6IuKJnCIsInRyaWFuZ2xlcmlnaHQiOiLilrkiLCJ0cmlhbmdsZXJpZ2h0ZXEiOiLiirUiLCJ0cmlkb3QiOiLil6wiLCJ0cmllIjoi4omcIiwidHJpbWludXMiOiLiqLoiLCJUcmlwbGVEb3QiOiLig5siLCJ0cmlwbHVzIjoi4qi5IiwidHJpc2IiOiLip40iLCJ0cml0aW1lIjoi4qi7IiwidHJwZXppdW0iOiLij6IiLCJUc2NyIjoi8J2SryIsInRzY3IiOiLwnZOJIiwiVFNjeSI6ItCmIiwidHNjeSI6ItGGIiwiVFNIY3kiOiLQiyIsInRzaGN5Ijoi0ZsiLCJUc3Ryb2siOiLFpiIsInRzdHJvayI6IsWnIiwidHdpeHQiOiLiiawiLCJ0d29oZWFkbGVmdGFycm93Ijoi4oaeIiwidHdvaGVhZHJpZ2h0YXJyb3ciOiLihqAiLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwidWFyciI6IuKGkSIsIlVhcnIiOiLihp8iLCJ1QXJyIjoi4oeRIiwiVWFycm9jaXIiOiLipYkiLCJVYnJjeSI6ItCOIiwidWJyY3kiOiLRniIsIlVicmV2ZSI6IsWsIiwidWJyZXZlIjoixa0iLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVjeSI6ItCjIiwidWN5Ijoi0YMiLCJ1ZGFyciI6IuKHhSIsIlVkYmxhYyI6IsWwIiwidWRibGFjIjoixbEiLCJ1ZGhhciI6IuKlriIsInVmaXNodCI6IuKlviIsIlVmciI6IvCdlJgiLCJ1ZnIiOiLwnZSyIiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVIYXIiOiLipaMiLCJ1aGFybCI6IuKGvyIsInVoYXJyIjoi4oa+IiwidWhibGsiOiLiloAiLCJ1bGNvcm4iOiLijJwiLCJ1bGNvcm5lciI6IuKMnCIsInVsY3JvcCI6IuKMjyIsInVsdHJpIjoi4pe4IiwiVW1hY3IiOiLFqiIsInVtYWNyIjoixasiLCJ1bWwiOiLCqCIsIlVuZGVyQmFyIjoiXyIsIlVuZGVyQnJhY2UiOiLij58iLCJVbmRlckJyYWNrZXQiOiLijrUiLCJVbmRlclBhcmVudGhlc2lzIjoi4o+dIiwiVW5pb24iOiLii4MiLCJVbmlvblBsdXMiOiLiio4iLCJVb2dvbiI6IsWyIiwidW9nb24iOiLFsyIsIlVvcGYiOiLwnZWMIiwidW9wZiI6IvCdlaYiLCJVcEFycm93QmFyIjoi4qSSIiwidXBhcnJvdyI6IuKGkSIsIlVwQXJyb3ciOiLihpEiLCJVcGFycm93Ijoi4oeRIiwiVXBBcnJvd0Rvd25BcnJvdyI6IuKHhSIsInVwZG93bmFycm93Ijoi4oaVIiwiVXBEb3duQXJyb3ciOiLihpUiLCJVcGRvd25hcnJvdyI6IuKHlSIsIlVwRXF1aWxpYnJpdW0iOiLipa4iLCJ1cGhhcnBvb25sZWZ0Ijoi4oa/IiwidXBoYXJwb29ucmlnaHQiOiLihr4iLCJ1cGx1cyI6IuKKjiIsIlVwcGVyTGVmdEFycm93Ijoi4oaWIiwiVXBwZXJSaWdodEFycm93Ijoi4oaXIiwidXBzaSI6Is+FIiwiVXBzaSI6Is+SIiwidXBzaWgiOiLPkiIsIlVwc2lsb24iOiLOpSIsInVwc2lsb24iOiLPhSIsIlVwVGVlQXJyb3ciOiLihqUiLCJVcFRlZSI6IuKKpSIsInVwdXBhcnJvd3MiOiLih4giLCJ1cmNvcm4iOiLijJ0iLCJ1cmNvcm5lciI6IuKMnSIsInVyY3JvcCI6IuKMjiIsIlVyaW5nIjoixa4iLCJ1cmluZyI6IsWvIiwidXJ0cmkiOiLil7kiLCJVc2NyIjoi8J2SsCIsInVzY3IiOiLwnZOKIiwidXRkb3QiOiLii7AiLCJVdGlsZGUiOiLFqCIsInV0aWxkZSI6IsWpIiwidXRyaSI6IuKWtSIsInV0cmlmIjoi4pa0IiwidXVhcnIiOiLih4giLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJ1d2FuZ2xlIjoi4qanIiwidmFuZ3J0Ijoi4qacIiwidmFyZXBzaWxvbiI6Is+1IiwidmFya2FwcGEiOiLPsCIsInZhcm5vdGhpbmciOiLiiIUiLCJ2YXJwaGkiOiLPlSIsInZhcnBpIjoiz5YiLCJ2YXJwcm9wdG8iOiLiiJ0iLCJ2YXJyIjoi4oaVIiwidkFyciI6IuKHlSIsInZhcnJobyI6Is+xIiwidmFyc2lnbWEiOiLPgiIsInZhcnN1YnNldG5lcSI6IuKKiu+4gCIsInZhcnN1YnNldG5lcXEiOiLiq4vvuIAiLCJ2YXJzdXBzZXRuZXEiOiLiiovvuIAiLCJ2YXJzdXBzZXRuZXFxIjoi4quM77iAIiwidmFydGhldGEiOiLPkSIsInZhcnRyaWFuZ2xlbGVmdCI6IuKKsiIsInZhcnRyaWFuZ2xlcmlnaHQiOiLiirMiLCJ2QmFyIjoi4quoIiwiVmJhciI6IuKrqyIsInZCYXJ2Ijoi4qupIiwiVmN5Ijoi0JIiLCJ2Y3kiOiLQsiIsInZkYXNoIjoi4oqiIiwidkRhc2giOiLiiqgiLCJWZGFzaCI6IuKKqSIsIlZEYXNoIjoi4oqrIiwiVmRhc2hsIjoi4qumIiwidmVlYmFyIjoi4oq7IiwidmVlIjoi4oioIiwiVmVlIjoi4ouBIiwidmVlZXEiOiLiiZoiLCJ2ZWxsaXAiOiLii64iLCJ2ZXJiYXIiOiJ8IiwiVmVyYmFyIjoi4oCWIiwidmVydCI6InwiLCJWZXJ0Ijoi4oCWIiwiVmVydGljYWxCYXIiOiLiiKMiLCJWZXJ0aWNhbExpbmUiOiJ8IiwiVmVydGljYWxTZXBhcmF0b3IiOiLinZgiLCJWZXJ0aWNhbFRpbGRlIjoi4omAIiwiVmVyeVRoaW5TcGFjZSI6IuKAiiIsIlZmciI6IvCdlJkiLCJ2ZnIiOiLwnZSzIiwidmx0cmkiOiLiirIiLCJ2bnN1YiI6IuKKguKDkiIsInZuc3VwIjoi4oqD4oOSIiwiVm9wZiI6IvCdlY0iLCJ2b3BmIjoi8J2VpyIsInZwcm9wIjoi4oidIiwidnJ0cmkiOiLiirMiLCJWc2NyIjoi8J2SsSIsInZzY3IiOiLwnZOLIiwidnN1Ym5FIjoi4quL77iAIiwidnN1Ym5lIjoi4oqK77iAIiwidnN1cG5FIjoi4quM77iAIiwidnN1cG5lIjoi4oqL77iAIiwiVnZkYXNoIjoi4oqqIiwidnppZ3phZyI6IuKmmiIsIldjaXJjIjoixbQiLCJ3Y2lyYyI6IsW1Iiwid2VkYmFyIjoi4qmfIiwid2VkZ2UiOiLiiKciLCJXZWRnZSI6IuKLgCIsIndlZGdlcSI6IuKJmSIsIndlaWVycCI6IuKEmCIsIldmciI6IvCdlJoiLCJ3ZnIiOiLwnZS0IiwiV29wZiI6IvCdlY4iLCJ3b3BmIjoi8J2VqCIsIndwIjoi4oSYIiwid3IiOiLiiYAiLCJ3cmVhdGgiOiLiiYAiLCJXc2NyIjoi8J2SsiIsIndzY3IiOiLwnZOMIiwieGNhcCI6IuKLgiIsInhjaXJjIjoi4pevIiwieGN1cCI6IuKLgyIsInhkdHJpIjoi4pa9IiwiWGZyIjoi8J2UmyIsInhmciI6IvCdlLUiLCJ4aGFyciI6IuKftyIsInhoQXJyIjoi4p+6IiwiWGkiOiLOniIsInhpIjoizr4iLCJ4bGFyciI6IuKftSIsInhsQXJyIjoi4p+4IiwieG1hcCI6IuKfvCIsInhuaXMiOiLii7siLCJ4b2RvdCI6IuKogCIsIlhvcGYiOiLwnZWPIiwieG9wZiI6IvCdlakiLCJ4b3BsdXMiOiLiqIEiLCJ4b3RpbWUiOiLiqIIiLCJ4cmFyciI6IuKftiIsInhyQXJyIjoi4p+5IiwiWHNjciI6IvCdkrMiLCJ4c2NyIjoi8J2TjSIsInhzcWN1cCI6IuKohiIsInh1cGx1cyI6IuKohCIsInh1dHJpIjoi4pazIiwieHZlZSI6IuKLgSIsInh3ZWRnZSI6IuKLgCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJZQWN5Ijoi0K8iLCJ5YWN5Ijoi0Y8iLCJZY2lyYyI6IsW2IiwieWNpcmMiOiLFtyIsIlljeSI6ItCrIiwieWN5Ijoi0YsiLCJ5ZW4iOiLCpSIsIllmciI6IvCdlJwiLCJ5ZnIiOiLwnZS2IiwiWUljeSI6ItCHIiwieWljeSI6ItGXIiwiWW9wZiI6IvCdlZAiLCJ5b3BmIjoi8J2VqiIsIllzY3IiOiLwnZK0IiwieXNjciI6IvCdk44iLCJZVWN5Ijoi0K4iLCJ5dWN5Ijoi0Y4iLCJ5dW1sIjoiw78iLCJZdW1sIjoixbgiLCJaYWN1dGUiOiLFuSIsInphY3V0ZSI6IsW6IiwiWmNhcm9uIjoixb0iLCJ6Y2Fyb24iOiLFviIsIlpjeSI6ItCXIiwiemN5Ijoi0LciLCJaZG90IjoixbsiLCJ6ZG90IjoixbwiLCJ6ZWV0cmYiOiLihKgiLCJaZXJvV2lkdGhTcGFjZSI6IuKAiyIsIlpldGEiOiLOliIsInpldGEiOiLOtiIsInpmciI6IvCdlLciLCJaZnIiOiLihKgiLCJaSGN5Ijoi0JYiLCJ6aGN5Ijoi0LYiLCJ6aWdyYXJyIjoi4oedIiwiem9wZiI6IvCdlasiLCJab3BmIjoi4oSkIiwiWnNjciI6IvCdkrUiLCJ6c2NyIjoi8J2TjyIsInp3aiI6IuKAjSIsInp3bmoiOiLigIwifScpfSxmdW5jdGlvbihkKXtkLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJicnZiYXIiOiLCpiIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJjZWRpbCI6IsK4IiwiY2VudCI6IsKiIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY3VycmVuIjoiwqQiLCJkZWciOiLCsCIsImRpdmlkZSI6IsO3IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJmcmFjMTIiOiLCvSIsImZyYWMxNCI6IsK8IiwiZnJhYzM0Ijoiwr4iLCJndCI6Ij4iLCJHVCI6Ij4iLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJpZXhjbCI6IsKhIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlxdWVzdCI6IsK/IiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwibGFxdW8iOiLCqyIsImx0IjoiPCIsIkxUIjoiPCIsIm1hY3IiOiLCryIsIm1pY3JvIjoiwrUiLCJtaWRkb3QiOiLCtyIsIm5ic3AiOiLCoCIsIm5vdCI6IsKsIiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4IiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsInBhcmEiOiLCtiIsInBsdXNtbiI6IsKxIiwicG91bmQiOiLCoyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwicmFxdW8iOiLCuyIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJzZWN0IjoiwqciLCJzaHkiOiLCrSIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN6bGlnIjoiw58iLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbWVzIjoiw5ciLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidW1sIjoiwqgiLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwieWVuIjoiwqUiLCJ5dW1sIjoiw78ifScpfSxmdW5jdGlvbihkKXtkLmV4cG9ydHM9SlNPTi5wYXJzZShgeyJhbXAiOiImIiwiYXBvcyI6IiciLCJndCI6Ij4iLCJsdCI6IjwiLCJxdW90IjoiXFwiIn1gKX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihsKXtyZXR1cm4gbCYmbC5fX2VzTW9kdWxlP2w6e2RlZmF1bHQ6bH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj1yKHQoMjY1KSk7ZnVuY3Rpb24gcyhsKXtpZihsPj01NTI5NiYmbDw9NTczNDN8fGw+MTExNDExMSlyZXR1cm4i77+9IjtsIGluIG4uZGVmYXVsdCYmKGw9bi5kZWZhdWx0W2xdKTt2YXIgYz0iIjtyZXR1cm4gbD42NTUzNSYmKGwtPTY1NTM2LGMrPVN0cmluZy5mcm9tQ2hhckNvZGUobD4+PjEwJjEwMjN8NTUyOTYpLGw9NTYzMjB8bCYxMDIzKSxjKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGwpLGN9ZS5kZWZhdWx0PXN9LGZ1bmN0aW9uKGQpe2QuZXhwb3J0cz1KU09OLnBhcnNlKCd7IjAiOjY1NTMzLCIxMjgiOjgzNjQsIjEzMCI6ODIxOCwiMTMxIjo0MDIsIjEzMiI6ODIyMiwiMTMzIjo4MjMwLCIxMzQiOjgyMjQsIjEzNSI6ODIyNSwiMTM2Ijo3MTAsIjEzNyI6ODI0MCwiMTM4IjozNTIsIjEzOSI6ODI0OSwiMTQwIjozMzgsIjE0MiI6MzgxLCIxNDUiOjgyMTYsIjE0NiI6ODIxNywiMTQ3Ijo4MjIwLCIxNDgiOjgyMjEsIjE0OSI6ODIyNiwiMTUwIjo4MjExLCIxNTEiOjgyMTIsIjE1MiI6NzMyLCIxNTMiOjg0ODIsIjE1NCI6MzUzLCIxNTUiOjgyNTAsIjE1NiI6MzM5LCIxNTgiOjM4MiwiMTU5IjozNzZ9Jyl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oUCl7cmV0dXJuIFAmJlAuX19lc01vZHVsZT9QOntkZWZhdWx0OlB9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lc2NhcGU9ZS5lbmNvZGVIVE1MPWUuZW5jb2RlWE1MPXZvaWQgMDt2YXIgbj1yKHQoMjYzKSkscz14KG4uZGVmYXVsdCksbD1nKHMpO2UuZW5jb2RlWE1MPVQocyxsKTt2YXIgYz1yKHQoMjYxKSksbz14KGMuZGVmYXVsdCksZj1nKG8pO2UuZW5jb2RlSFRNTD1UKG8sZik7ZnVuY3Rpb24geChQKXtyZXR1cm4gT2JqZWN0LmtleXMoUCkuc29ydCgpLnJlZHVjZShmdW5jdGlvbihpLHUpe3JldHVybiBpW1BbdV1dPSImIit1KyI7IixpfSx7fSl9ZnVuY3Rpb24gZyhQKXtmb3IodmFyIGk9W10sdT1bXSxhPTAsaD1PYmplY3Qua2V5cyhQKTthPGgubGVuZ3RoO2ErKyl7dmFyIGI9aFthXTtiLmxlbmd0aD09PTE/aS5wdXNoKCJcXCIrYik6dS5wdXNoKGIpfWkuc29ydCgpO2Zvcih2YXIgRT0wO0U8aS5sZW5ndGgtMTtFKyspe2Zvcih2YXIgQT1FO0E8aS5sZW5ndGgtMSYmaVtBXS5jaGFyQ29kZUF0KDEpKzE9PT1pW0ErMV0uY2hhckNvZGVBdCgxKTspQSs9MTt2YXIgTD0xK0EtRTtMPDN8fGkuc3BsaWNlKEUsTCxpW0VdKyItIitpW0FdKX1yZXR1cm4gdS51bnNoaWZ0KCJbIitpLmpvaW4oIiIpKyJdIiksbmV3IFJlZ0V4cCh1LmpvaW4oInwiKSwiZyIpfXZhciB5PS8oPzpbXHg4MC1cdUQ3RkZcdUUwMDAtXHVGRkZGXXxbXHVEODAwLVx1REJGRl1bXHVEQzAwLVx1REZGRl18W1x1RDgwMC1cdURCRkZdKD8hW1x1REMwMC1cdURGRkZdKXwoPzpbXlx1RDgwMC1cdURCRkZdfF4pW1x1REMwMC1cdURGRkZdKS9nO2Z1bmN0aW9uIG0oUCl7cmV0dXJuIiYjeCIrUC5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSsiOyJ9ZnVuY3Rpb24gVChQLGkpe3JldHVybiBmdW5jdGlvbih1KXtyZXR1cm4gdS5yZXBsYWNlKGksZnVuY3Rpb24oYSl7cmV0dXJuIFBbYV19KS5yZXBsYWNlKHksbSl9fXZhciBPPWcocyk7ZnVuY3Rpb24gdihQKXtyZXR1cm4gUC5yZXBsYWNlKE8sbSkucmVwbGFjZSh5LG0pfWUuZXNjYXBlPXZ9LGZ1bmN0aW9uKGQpe2QuZXhwb3J0cz1KU09OLnBhcnNlKCd7ImVsZW1lbnROYW1lcyI6eyJhbHRnbHlwaCI6ImFsdEdseXBoIiwiYWx0Z2x5cGhkZWYiOiJhbHRHbHlwaERlZiIsImFsdGdseXBoaXRlbSI6ImFsdEdseXBoSXRlbSIsImFuaW1hdGVjb2xvciI6ImFuaW1hdGVDb2xvciIsImFuaW1hdGVtb3Rpb24iOiJhbmltYXRlTW90aW9uIiwiYW5pbWF0ZXRyYW5zZm9ybSI6ImFuaW1hdGVUcmFuc2Zvcm0iLCJjbGlwcGF0aCI6ImNsaXBQYXRoIiwiZmVibGVuZCI6ImZlQmxlbmQiLCJmZWNvbG9ybWF0cml4IjoiZmVDb2xvck1hdHJpeCIsImZlY29tcG9uZW50dHJhbnNmZXIiOiJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVjb21wb3NpdGUiOiJmZUNvbXBvc2l0ZSIsImZlY29udm9sdmVtYXRyaXgiOiJmZUNvbnZvbHZlTWF0cml4IiwiZmVkaWZmdXNlbGlnaHRpbmciOiJmZURpZmZ1c2VMaWdodGluZyIsImZlZGlzcGxhY2VtZW50bWFwIjoiZmVEaXNwbGFjZW1lbnRNYXAiLCJmZWRpc3RhbnRsaWdodCI6ImZlRGlzdGFudExpZ2h0IiwiZmVkcm9wc2hhZG93IjoiZmVEcm9wU2hhZG93IiwiZmVmbG9vZCI6ImZlRmxvb2QiLCJmZWZ1bmNhIjoiZmVGdW5jQSIsImZlZnVuY2IiOiJmZUZ1bmNCIiwiZmVmdW5jZyI6ImZlRnVuY0ciLCJmZWZ1bmNyIjoiZmVGdW5jUiIsImZlZ2F1c3NpYW5ibHVyIjoiZmVHYXVzc2lhbkJsdXIiLCJmZWltYWdlIjoiZmVJbWFnZSIsImZlbWVyZ2UiOiJmZU1lcmdlIiwiZmVtZXJnZW5vZGUiOiJmZU1lcmdlTm9kZSIsImZlbW9ycGhvbG9neSI6ImZlTW9ycGhvbG9neSIsImZlb2Zmc2V0IjoiZmVPZmZzZXQiLCJmZXBvaW50bGlnaHQiOiJmZVBvaW50TGlnaHQiLCJmZXNwZWN1bGFybGlnaHRpbmciOiJmZVNwZWN1bGFyTGlnaHRpbmciLCJmZXNwb3RsaWdodCI6ImZlU3BvdExpZ2h0IiwiZmV0aWxlIjoiZmVUaWxlIiwiZmV0dXJidWxlbmNlIjoiZmVUdXJidWxlbmNlIiwiZm9yZWlnbm9iamVjdCI6ImZvcmVpZ25PYmplY3QiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwibGluZWFyZ3JhZGllbnQiOiJsaW5lYXJHcmFkaWVudCIsInJhZGlhbGdyYWRpZW50IjoicmFkaWFsR3JhZGllbnQiLCJ0ZXh0cGF0aCI6InRleHRQYXRoIn0sImF0dHJpYnV0ZU5hbWVzIjp7ImRlZmluaXRpb251cmwiOiJkZWZpbml0aW9uVVJMIiwiYXR0cmlidXRlbmFtZSI6ImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGV0eXBlIjoiYXR0cmlidXRlVHlwZSIsImJhc2VmcmVxdWVuY3kiOiJiYXNlRnJlcXVlbmN5IiwiYmFzZXByb2ZpbGUiOiJiYXNlUHJvZmlsZSIsImNhbGNtb2RlIjoiY2FsY01vZGUiLCJjbGlwcGF0aHVuaXRzIjoiY2xpcFBhdGhVbml0cyIsImRpZmZ1c2Vjb25zdGFudCI6ImRpZmZ1c2VDb25zdGFudCIsImVkZ2Vtb2RlIjoiZWRnZU1vZGUiLCJmaWx0ZXJ1bml0cyI6ImZpbHRlclVuaXRzIiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImdyYWRpZW50dHJhbnNmb3JtIjoiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIjoiZ3JhZGllbnRVbml0cyIsImtlcm5lbG1hdHJpeCI6Imtlcm5lbE1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiOiJrZXJuZWxVbml0TGVuZ3RoIiwia2V5cG9pbnRzIjoia2V5UG9pbnRzIiwia2V5c3BsaW5lcyI6ImtleVNwbGluZXMiLCJrZXl0aW1lcyI6ImtleVRpbWVzIiwibGVuZ3RoYWRqdXN0IjoibGVuZ3RoQWRqdXN0IiwibGltaXRpbmdjb25lYW5nbGUiOiJsaW1pdGluZ0NvbmVBbmdsZSIsIm1hcmtlcmhlaWdodCI6Im1hcmtlckhlaWdodCIsIm1hcmtlcnVuaXRzIjoibWFya2VyVW5pdHMiLCJtYXJrZXJ3aWR0aCI6Im1hcmtlcldpZHRoIiwibWFza2NvbnRlbnR1bml0cyI6Im1hc2tDb250ZW50VW5pdHMiLCJtYXNrdW5pdHMiOiJtYXNrVW5pdHMiLCJudW1vY3RhdmVzIjoibnVtT2N0YXZlcyIsInBhdGhsZW5ndGgiOiJwYXRoTGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyI6InBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIjoicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm51bml0cyI6InBhdHRlcm5Vbml0cyIsInBvaW50c2F0eCI6InBvaW50c0F0WCIsInBvaW50c2F0eSI6InBvaW50c0F0WSIsInBvaW50c2F0eiI6InBvaW50c0F0WiIsInByZXNlcnZlYWxwaGEiOiJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyI6InByZXNlcnZlQXNwZWN0UmF0aW8iLCJwcmltaXRpdmV1bml0cyI6InByaW1pdGl2ZVVuaXRzIiwicmVmeCI6InJlZlgiLCJyZWZ5IjoicmVmWSIsInJlcGVhdGNvdW50IjoicmVwZWF0Q291bnQiLCJyZXBlYXRkdXIiOiJyZXBlYXREdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiOiJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIjoicmVxdWlyZWRGZWF0dXJlcyIsInNwZWN1bGFyY29uc3RhbnQiOiJzcGVjdWxhckNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCI6InNwZWN1bGFyRXhwb25lbnQiLCJzcHJlYWRtZXRob2QiOiJzcHJlYWRNZXRob2QiLCJzdGFydG9mZnNldCI6InN0YXJ0T2Zmc2V0Iiwic3RkZGV2aWF0aW9uIjoic3RkRGV2aWF0aW9uIiwic3RpdGNodGlsZXMiOiJzdGl0Y2hUaWxlcyIsInN1cmZhY2VzY2FsZSI6InN1cmZhY2VTY2FsZSIsInN5c3RlbWxhbmd1YWdlIjoic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyI6InRhYmxlVmFsdWVzIiwidGFyZ2V0eCI6InRhcmdldFgiLCJ0YXJnZXR5IjoidGFyZ2V0WSIsInRleHRsZW5ndGgiOiJ0ZXh0TGVuZ3RoIiwidmlld2JveCI6InZpZXdCb3giLCJ2aWV3dGFyZ2V0Ijoidmlld1RhcmdldCIsInhjaGFubmVsc2VsZWN0b3IiOiJ4Q2hhbm5lbFNlbGVjdG9yIiwieWNoYW5uZWxzZWxlY3RvciI6InlDaGFubmVsU2VsZWN0b3IiLCJ6b29tYW5kcGFuIjoiem9vbUFuZFBhbiJ9fScpfSxmdW5jdGlvbihkLGUpe3ZhciB0PWUuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24obil7cmV0dXJuIG4uY2hpbGRyZW59LHI9ZS5nZXRQYXJlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIG4ucGFyZW50fTtlLmdldFNpYmxpbmdzPWZ1bmN0aW9uKG4pe3ZhciBzPXIobik7cmV0dXJuIHM/dChzKTpbbl19LGUuZ2V0QXR0cmlidXRlVmFsdWU9ZnVuY3Rpb24obixzKXtyZXR1cm4gbi5hdHRyaWJzJiZuLmF0dHJpYnNbc119LGUuaGFzQXR0cmliPWZ1bmN0aW9uKG4scyl7cmV0dXJuISFuLmF0dHJpYnMmJmhhc093blByb3BlcnR5LmNhbGwobi5hdHRyaWJzLHMpfSxlLmdldE5hbWU9ZnVuY3Rpb24obil7cmV0dXJuIG4ubmFtZX19LGZ1bmN0aW9uKGQsZSl7ZS5yZW1vdmVFbGVtZW50PWZ1bmN0aW9uKHQpe2lmKHQucHJldiYmKHQucHJldi5uZXh0PXQubmV4dCksdC5uZXh0JiYodC5uZXh0LnByZXY9dC5wcmV2KSx0LnBhcmVudCl7dmFyIHI9dC5wYXJlbnQuY2hpbGRyZW47ci5zcGxpY2Uoci5sYXN0SW5kZXhPZih0KSwxKX19LGUucmVwbGFjZUVsZW1lbnQ9ZnVuY3Rpb24odCxyKXt2YXIgbj1yLnByZXY9dC5wcmV2O24mJihuLm5leHQ9cik7dmFyIHM9ci5uZXh0PXQubmV4dDtzJiYocy5wcmV2PXIpO3ZhciBsPXIucGFyZW50PXQucGFyZW50O2lmKGwpe3ZhciBjPWwuY2hpbGRyZW47Y1tjLmxhc3RJbmRleE9mKHQpXT1yfX0sZS5hcHBlbmRDaGlsZD1mdW5jdGlvbih0LHIpe2lmKHIucGFyZW50PXQsdC5jaGlsZHJlbi5wdXNoKHIpIT09MSl7dmFyIG49dC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aC0yXTtuLm5leHQ9cixyLnByZXY9bixyLm5leHQ9bnVsbH19LGUuYXBwZW5kPWZ1bmN0aW9uKHQscil7dmFyIG49dC5wYXJlbnQscz10Lm5leHQ7aWYoci5uZXh0PXMsci5wcmV2PXQsdC5uZXh0PXIsci5wYXJlbnQ9bixzKXtpZihzLnByZXY9cixuKXt2YXIgbD1uLmNoaWxkcmVuO2wuc3BsaWNlKGwubGFzdEluZGV4T2YocyksMCxyKX19ZWxzZSBuJiZuLmNoaWxkcmVuLnB1c2gocil9LGUucHJlcGVuZD1mdW5jdGlvbih0LHIpe3ZhciBuPXQucGFyZW50O2lmKG4pe3ZhciBzPW4uY2hpbGRyZW47cy5zcGxpY2Uocy5sYXN0SW5kZXhPZih0KSwwLHIpfXQucHJldiYmKHQucHJldi5uZXh0PXIpLHIucGFyZW50PW4sci5wcmV2PXQucHJldixyLm5leHQ9dCx0LnByZXY9cn19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDI1NikuaXNUYWc7ZC5leHBvcnRzPXtmaWx0ZXI6bixmaW5kOnMsZmluZE9uZUNoaWxkOmwsZmluZE9uZTpjLGV4aXN0c09uZTpvLGZpbmRBbGw6Zn07ZnVuY3Rpb24gbih4LGcseSxtKXtyZXR1cm4gQXJyYXkuaXNBcnJheShnKXx8KGc9W2ddKSwodHlwZW9mIG0hPSJudW1iZXIifHwhaXNGaW5pdGUobSkpJiYobT0xLzApLHMoeCxnLHkhPT0hMSxtKX1mdW5jdGlvbiBzKHgsZyx5LG0pe2Zvcih2YXIgVD1bXSxPLHY9MCxQPWcubGVuZ3RoO3Y8UCYmISh4KGdbdl0pJiYoVC5wdXNoKGdbdl0pLC0tbTw9MCl8fChPPWdbdl0uY2hpbGRyZW4seSYmTyYmTy5sZW5ndGg+MCYmKE89cyh4LE8seSxtKSxUPVQuY29uY2F0KE8pLG0tPU8ubGVuZ3RoLG08PTApKSk7disrKTtyZXR1cm4gVH1mdW5jdGlvbiBsKHgsZyl7Zm9yKHZhciB5PTAsbT1nLmxlbmd0aDt5PG07eSsrKWlmKHgoZ1t5XSkpcmV0dXJuIGdbeV07cmV0dXJuIG51bGx9ZnVuY3Rpb24gYyh4LGcpe2Zvcih2YXIgeT1udWxsLG09MCxUPWcubGVuZ3RoO208VCYmIXk7bSsrKWlmKHIoZ1ttXSkpeChnW21dKT95PWdbbV06Z1ttXS5jaGlsZHJlbi5sZW5ndGg+MCYmKHk9Yyh4LGdbbV0uY2hpbGRyZW4pKTtlbHNlIGNvbnRpbnVlO3JldHVybiB5fWZ1bmN0aW9uIG8oeCxnKXtmb3IodmFyIHk9MCxtPWcubGVuZ3RoO3k8bTt5KyspaWYocihnW3ldKSYmKHgoZ1t5XSl8fGdbeV0uY2hpbGRyZW4ubGVuZ3RoPjAmJm8oeCxnW3ldLmNoaWxkcmVuKSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZih4LGcpe2Zvcih2YXIgeT1bXSxtPWcuc2xpY2UoKTttLmxlbmd0aDspe3ZhciBUPW0uc2hpZnQoKTtyKFQpJiYoVC5jaGlsZHJlbiYmVC5jaGlsZHJlbi5sZW5ndGg+MCYmbS51bnNoaWZ0LmFwcGx5KG0sVC5jaGlsZHJlbikseChUKSYmeS5wdXNoKFQpKX1yZXR1cm4geX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDI1Niksbj1lLmlzVGFnPXIuaXNUYWc7ZS50ZXN0RWxlbWVudD1mdW5jdGlvbihvLGYpe2Zvcih2YXIgeCBpbiBvKWlmKG8uaGFzT3duUHJvcGVydHkoeCkpe2lmKHg9PT0idGFnX25hbWUiKXtpZighbihmKXx8IW8udGFnX25hbWUoZi5uYW1lKSlyZXR1cm4hMX1lbHNlIGlmKHg9PT0idGFnX3R5cGUiKXtpZighby50YWdfdHlwZShmLnR5cGUpKXJldHVybiExfWVsc2UgaWYoeD09PSJ0YWdfY29udGFpbnMiKXtpZihuKGYpfHwhby50YWdfY29udGFpbnMoZi5kYXRhKSlyZXR1cm4hMX1lbHNlIGlmKCFmLmF0dHJpYnN8fCFvW3hdKGYuYXR0cmlic1t4XSkpcmV0dXJuITF9cmV0dXJuITB9O3ZhciBzPXt0YWdfbmFtZTpmdW5jdGlvbihvKXtyZXR1cm4gdHlwZW9mIG89PSJmdW5jdGlvbiI/ZnVuY3Rpb24oZil7cmV0dXJuIG4oZikmJm8oZi5uYW1lKX06bz09PSIqIj9uOmZ1bmN0aW9uKGYpe3JldHVybiBuKGYpJiZmLm5hbWU9PT1vfX0sdGFnX3R5cGU6ZnVuY3Rpb24obyl7cmV0dXJuIHR5cGVvZiBvPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGYpe3JldHVybiBvKGYudHlwZSl9OmZ1bmN0aW9uKGYpe3JldHVybiBmLnR5cGU9PT1vfX0sdGFnX2NvbnRhaW5zOmZ1bmN0aW9uKG8pe3JldHVybiB0eXBlb2Ygbz09ImZ1bmN0aW9uIj9mdW5jdGlvbihmKXtyZXR1cm4hbihmKSYmbyhmLmRhdGEpfTpmdW5jdGlvbihmKXtyZXR1cm4hbihmKSYmZi5kYXRhPT09b319fTtmdW5jdGlvbiBsKG8sZil7cmV0dXJuIHR5cGVvZiBmPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKHgpe3JldHVybiB4LmF0dHJpYnMmJmYoeC5hdHRyaWJzW29dKX06ZnVuY3Rpb24oeCl7cmV0dXJuIHguYXR0cmlicyYmeC5hdHRyaWJzW29dPT09Zn19ZnVuY3Rpb24gYyhvLGYpe3JldHVybiBmdW5jdGlvbih4KXtyZXR1cm4gbyh4KXx8Zih4KX19ZS5nZXRFbGVtZW50cz1mdW5jdGlvbihvLGYseCxnKXt2YXIgeT1PYmplY3Qua2V5cyhvKS5tYXAoZnVuY3Rpb24obSl7dmFyIFQ9b1ttXTtyZXR1cm4gbSBpbiBzP3NbbV0oVCk6bChtLFQpfSk7cmV0dXJuIHkubGVuZ3RoPT09MD9bXTp0aGlzLmZpbHRlcih5LnJlZHVjZShjKSxmLHgsZyl9LGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24obyxmLHgpe3JldHVybiBBcnJheS5pc0FycmF5KGYpfHwoZj1bZl0pLHRoaXMuZmluZE9uZShsKCJpZCIsbyksZix4IT09ITEpfSxlLmdldEVsZW1lbnRzQnlUYWdOYW1lPWZ1bmN0aW9uKG8sZix4LGcpe3JldHVybiB0aGlzLmZpbHRlcihzLnRhZ19uYW1lKG8pLGYseCxnKX0sZS5nZXRFbGVtZW50c0J5VGFnVHlwZT1mdW5jdGlvbihvLGYseCxnKXtyZXR1cm4gdGhpcy5maWx0ZXIocy50YWdfdHlwZShvKSxmLHgsZyl9fSxmdW5jdGlvbihkLGUpe2UucmVtb3ZlU3Vic2V0cz1mdW5jdGlvbihuKXtmb3IodmFyIHM9bi5sZW5ndGgsbCxjLG87LS1zPi0xOyl7Zm9yKGw9Yz1uW3NdLG5bc109bnVsbCxvPSEwO2M7KXtpZihuLmluZGV4T2YoYyk+LTEpe289ITEsbi5zcGxpY2UocywxKTticmVha31jPWMucGFyZW50fW8mJihuW3NdPWwpfXJldHVybiBufTt2YXIgdD17RElTQ09OTkVDVEVEOjEsUFJFQ0VESU5HOjIsRk9MTE9XSU5HOjQsQ09OVEFJTlM6OCxDT05UQUlORURfQlk6MTZ9LHI9ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj1mdW5jdGlvbihuLHMpe3ZhciBsPVtdLGM9W10sbyxmLHgsZyx5LG07aWYobj09PXMpcmV0dXJuIDA7Zm9yKG89bjtvOylsLnVuc2hpZnQobyksbz1vLnBhcmVudDtmb3Iobz1zO287KWMudW5zaGlmdChvKSxvPW8ucGFyZW50O2ZvcihtPTA7bFttXT09PWNbbV07KW0rKztyZXR1cm4gbT09PTA/dC5ESVNDT05ORUNURUQ6KGY9bFttLTFdLHg9Zi5jaGlsZHJlbixnPWxbbV0seT1jW21dLHguaW5kZXhPZihnKT54LmluZGV4T2YoeSk/Zj09PXM/dC5GT0xMT1dJTkd8dC5DT05UQUlORURfQlk6dC5GT0xMT1dJTkc6Zj09PW4/dC5QUkVDRURJTkd8dC5DT05UQUlOUzp0LlBSRUNFRElORyl9O2UudW5pcXVlU29ydD1mdW5jdGlvbihuKXt2YXIgcz1uLmxlbmd0aCxsLGM7Zm9yKG49bi5zbGljZSgpOy0tcz4tMTspbD1uW3NdLGM9bi5pbmRleE9mKGwpLGM+LTEmJmM8cyYmbi5zcGxpY2UocywxKTtyZXR1cm4gbi5zb3J0KGZ1bmN0aW9uKG8sZil7dmFyIHg9cihvLGYpO3JldHVybiB4JnQuUFJFQ0VESU5HPy0xOngmdC5GT0xMT1dJTkc/MTowfSksbn19LGZ1bmN0aW9uKGQsZSl7ZC5leHBvcnRzPXt0cnVlRnVuYzpmdW5jdGlvbigpe3JldHVybiEwfSxmYWxzZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMX19fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXk7dmFyIHI9dCgyNzUpLnBhcnNlLG49dCgyNzMpLHM9dCgyNzgpLGw9dCgyNzkpLGM9dCgyODApLG89dCgyODIpLGY9bi50cnVlRnVuYyx4PW4uZmFsc2VGdW5jLGc9by5maWx0ZXJzO2Z1bmN0aW9uIHkoUyxJLEQpe3ZhciBSPVQoUyxJLEQpO3JldHVybiBtKFIsSSl9ZnVuY3Rpb24gbShTLEkpe3ZhciBEPUkuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oQyl7cmV0dXJuIEQuaXNUYWcoQykmJlMoQyl9fWZ1bmN0aW9uIFQoUyxJLEQpe3ZhciBSPXIoUyxJKTtyZXR1cm4gaChSLEksRCl9ZnVuY3Rpb24gTyhTKXtyZXR1cm4gUy50eXBlPT09InBzZXVkbyImJihTLm5hbWU9PT0ic2NvcGUifHxBcnJheS5pc0FycmF5KFMuZGF0YSkmJlMuZGF0YS5zb21lKGZ1bmN0aW9uKEkpe3JldHVybiBJLnNvbWUoTyl9KSl9dmFyIHY9e3R5cGU6ImRlc2NlbmRhbnQifSxQPXt0eXBlOiJfZmxleGlibGVEZXNjZW5kYW50In0saT17dHlwZToicHNldWRvIixuYW1lOiJzY29wZSJ9LHU9e307ZnVuY3Rpb24gYShTLEksRCl7dmFyIFI9SS5hZGFwdGVyLEM9ISFEJiYhIUQubGVuZ3RoJiZELmV2ZXJ5KGZ1bmN0aW9uKGope3JldHVybiBqPT09dXx8ISFSLmdldFBhcmVudChqKX0pO1MuZm9yRWFjaChmdW5jdGlvbihqKXtpZighKGoubGVuZ3RoPjAmJmIoalswXSkmJmpbMF0udHlwZSE9PSJkZXNjZW5kYW50IikpaWYoQyYmIShBcnJheS5pc0FycmF5KGopP2ouc29tZShPKTpPKGopKSlqLnVuc2hpZnQodik7ZWxzZSByZXR1cm47ai51bnNoaWZ0KGkpfSl9ZnVuY3Rpb24gaChTLEksRCl7Uz1TLmZpbHRlcihmdW5jdGlvbigkKXtyZXR1cm4gJC5sZW5ndGg+MH0pLFMuZm9yRWFjaChzKTt2YXIgUj1BcnJheS5pc0FycmF5KEQpO0Q9SSYmSS5jb250ZXh0fHxELEQmJiFSJiYoRD1bRF0pLGEoUyxJLEQpO3ZhciBDPSExLGo9Uy5tYXAoZnVuY3Rpb24oJCl7aWYoJFswXSYmJFsxXSYmJFswXS5uYW1lPT09InNjb3BlIil7dmFyIEg9JFsxXS50eXBlO1ImJkg9PT0iZGVzY2VuZGFudCI/JFsxXT1QOihIPT09ImFkamFjZW50Inx8SD09PSJzaWJsaW5nIikmJihDPSEwKX1yZXR1cm4gRSgkLEksRCl9KS5yZWR1Y2UoQSx4KTtyZXR1cm4gai5zaG91bGRUZXN0TmV4dFNpYmxpbmdzPUMsan1mdW5jdGlvbiBiKFMpe3JldHVybiBsW1MudHlwZV08MH1mdW5jdGlvbiBFKFMsSSxEKXtyZXR1cm4gUy5yZWR1Y2UoZnVuY3Rpb24oUixDKXtpZihSPT09eClyZXR1cm4gUjtpZighKEMudHlwZSBpbiBjKSl0aHJvdyBuZXcgRXJyb3IoIlJ1bGUgdHlwZSAiK0MudHlwZSsiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgY3NzLXNlbGVjdCIpO3JldHVybiBjW0MudHlwZV0oUixDLEksRCl9LEkmJkkucm9vdEZ1bmN8fGYpfWZ1bmN0aW9uIEEoUyxJKXtyZXR1cm4gST09PXh8fFM9PT1mP1M6Uz09PXh8fEk9PT1mP0k6ZnVuY3Rpb24oUil7cmV0dXJuIFMoUil8fEkoUil9fWZ1bmN0aW9uIEwoUyl7cmV0dXJuIFMuc29tZShiKX1nLm5vdD1mdW5jdGlvbihTLEksRCxSKXt2YXIgQz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCksYWRhcHRlcjpELmFkYXB0ZXJ9O2lmKEMuc3RyaWN0JiYoSS5sZW5ndGg+MXx8SS5zb21lKEwpKSl0aHJvdyBuZXcgRXJyb3IoImNvbXBsZXggc2VsZWN0b3JzIGluIDpub3QgYXJlbid0IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUiKTt2YXIgaj1oKEksQyxSKTtyZXR1cm4gaj09PXg/UzpqPT09Zj94OmZ1bmN0aW9uKEgpe3JldHVybiFqKEgpJiZTKEgpfX0sZy5oYXM9ZnVuY3Rpb24oUyxJLEQpe3ZhciBSPUQuYWRhcHRlcixDPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxhZGFwdGVyOlJ9LGo9SS5zb21lKEwpP1t1XTpudWxsLCQ9aChJLEMsaik7cmV0dXJuICQ9PT14P3g6JD09PWY/ZnVuY3Rpb24oSil7cmV0dXJuIFIuZ2V0Q2hpbGRyZW4oSikuc29tZShSLmlzVGFnKSYmUyhKKX06KCQ9bSgkLEQpLGo/ZnVuY3Rpb24oSil7cmV0dXJuIFMoSikmJihqWzBdPUosUi5leGlzdHNPbmUoJCxSLmdldENoaWxkcmVuKEopKSl9OmZ1bmN0aW9uKEope3JldHVybiBTKEopJiZSLmV4aXN0c09uZSgkLFIuZ2V0Q2hpbGRyZW4oSikpfSl9LGcubWF0Y2hlcz1mdW5jdGlvbihTLEksRCxSKXt2YXIgQz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCkscm9vdEZ1bmM6UyxhZGFwdGVyOkQuYWRhcHRlcn07cmV0dXJuIGgoSSxDLFIpfSx5LmNvbXBpbGVUb2tlbj1oLHkuY29tcGlsZVVuc2FmZT1ULHkuUHNldWRvcz1vfSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGMsbyxmLHgpe3g9PT12b2lkIDAmJih4PWYpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLHgse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG9bZl19fSl9OmZ1bmN0aW9uKGMsbyxmLHgpe3g9PT12b2lkIDAmJih4PWYpLGNbeF09b1tmXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGMsbyl7Zm9yKHZhciBmIGluIGMpZiE9PSJkZWZhdWx0IiYmIW8uaGFzT3duUHJvcGVydHkoZikmJnIobyxjLGYpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksbih0KDI3NiksZSk7dmFyIHM9dCgyNzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJwYXJzZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdH19KTt2YXIgbD10KDI3Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInN0cmluZ2lmeSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH19KX0sZnVuY3Rpb24oZCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9Tzt2YXIgcj0vXlteXFxdPyg/OlxcKD86W1xkYS1mXXsxLDZ9XHM/fC4pfFtcd1wtXHUwMGIwLVx1RkZGRl0pKy8sbj0vXFwoW1xkYS1mXXsxLDZ9XHM/fChccyl8LikvZ2kscz0vXlxzKigoPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSspXHMqKD86KFxTPyk9XHMqKD86KFsnIl0pKFteXSo/KVwzfCgjPyg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKil8KXwpXHMqKGkpP1xdLyxsPXt1bmRlZmluZWQ6ImV4aXN0cyIsIiI6ImVxdWFscyIsIn4iOiJlbGVtZW50IiwiXiI6InN0YXJ0IiwkOiJlbmQiLCIqIjoiYW55IiwiISI6Im5vdCIsInwiOiJoeXBoZW4ifSxjPXsiPiI6ImNoaWxkIiwiPCI6InBhcmVudCIsIn4iOiJzaWJsaW5nIiwiKyI6ImFkamFjZW50In0sbz17IiMiOlsiaWQiLCJlcXVhbHMiXSwiLiI6WyJjbGFzcyIsImVsZW1lbnQiXX0sZj1uZXcgU2V0KFsiaGFzIiwibm90IiwibWF0Y2hlcyJdKSx4PW5ldyBTZXQoWyJjb250YWlucyIsImljb250YWlucyJdKSxnPW5ldyBTZXQoWyciJywiJyJdKTtmdW5jdGlvbiB5KGksdSxhKXt2YXIgaD1wYXJzZUludCh1LDE2KS02NTUzNjtyZXR1cm4gaCE9PWh8fGE/dTpoPDA/U3RyaW5nLmZyb21DaGFyQ29kZShoKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKGg+PjEwfDU1Mjk2LGgmMTAyM3w1NjMyMCl9ZnVuY3Rpb24gbShpKXtyZXR1cm4gaS5yZXBsYWNlKG4seSl9ZnVuY3Rpb24gVChpKXtyZXR1cm4gaT09PSIgInx8aT09PWAKYHx8aT09PSIJInx8aT09PSJcZiJ8fGk9PT0iXHIifWZ1bmN0aW9uIE8oaSx1KXt2YXIgYT1bXTtpZihpPXYoYSwiIitpLHUpLGkhPT0iIil0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBzZWxlY3RvcjogIitpKTtyZXR1cm4gYX1mdW5jdGlvbiB2KGksdSxhKXt2YXIgaD1bXSxiPSExO2Z1bmN0aW9uIEUoKXt2YXIgWj11Lm1hdGNoKHIpO2lmKCFaKXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbmFtZSwgZm91bmQgIit1KTt2YXIgdHQ9WlswXTtyZXR1cm4gdT11LnN1YnN0cih0dC5sZW5ndGgpLG0odHQpfWZ1bmN0aW9uIEEoWil7Zm9yKDtUKHUuY2hhckF0KFopKTspWisrO3U9dS5zdWJzdHIoWil9ZnVuY3Rpb24gTChaKXtmb3IodmFyIHR0PTA7dS5jaGFyQXQoLS1aKT09PSJcXCI7KXR0Kys7cmV0dXJuKHR0JjEpPT09MX1mb3IoQSgwKTt1IT09IiI7KXt2YXIgUz11LmNoYXJBdCgwKTtpZihUKFMpKWI9ITAsQSgxKTtlbHNlIGlmKFMgaW4gYyloLnB1c2goe3R5cGU6Y1tTXX0pLGI9ITEsQSgxKTtlbHNlIGlmKFM9PT0iLCIpe2lmKGgubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO2kucHVzaChoKSxoPVtdLGI9ITEsQSgxKX1lbHNlIGlmKGImJihoLmxlbmd0aD4wJiZoLnB1c2goe3R5cGU6ImRlc2NlbmRhbnQifSksYj0hMSksUz09PSIqIil1PXUuc3Vic3RyKDEpLGgucHVzaCh7dHlwZToidW5pdmVyc2FsIn0pO2Vsc2UgaWYoUyBpbiBvKXt2YXIgST1vW1NdLEQ9SVswXSxSPUlbMV07dT11LnN1YnN0cigxKSxoLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpELGFjdGlvbjpSLHZhbHVlOkUoKSxpZ25vcmVDYXNlOiExfSl9ZWxzZSBpZihTPT09IlsiKXt1PXUuc3Vic3RyKDEpO3ZhciBDPXUubWF0Y2gocyk7aWYoIUMpdGhyb3cgbmV3IEVycm9yKCJNYWxmb3JtZWQgYXR0cmlidXRlIHNlbGVjdG9yOiAiK3UpO3U9dS5zdWJzdHIoQ1swXS5sZW5ndGgpO3ZhciBqPW0oQ1sxXSk7KCFhfHwoImxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzImluIGE/YS5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lczohYS54bWxNb2RlKSkmJihqPWoudG9Mb3dlckNhc2UoKSksaC5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6aixhY3Rpb246bFtDWzJdXSx2YWx1ZTptKENbNF18fENbNV18fCIiKSxpZ25vcmVDYXNlOiEhQ1s2XX0pfWVsc2UgaWYoUz09PSI6Iil7aWYodS5jaGFyQXQoMSk9PT0iOiIpe3U9dS5zdWJzdHIoMiksaC5wdXNoKHt0eXBlOiJwc2V1ZG8tZWxlbWVudCIsbmFtZTpFKCkudG9Mb3dlckNhc2UoKX0pO2NvbnRpbnVlfXU9dS5zdWJzdHIoMSk7dmFyICQ9RSgpLnRvTG93ZXJDYXNlKCksQz1udWxsO2lmKHUuY2hhckF0KDApPT09IigiKWlmKGYuaGFzKCQpKXt2YXIgSD11LmNoYXJBdCgxKSxKPWcuaGFzKEgpO2lmKHU9dS5zdWJzdHIoSj8yOjEpLEM9W10sdT12KEMsdSxhKSxKKXtpZih1LmNoYXJBdCgwKSE9PUgpdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgcXVvdGVzIGluIDoiKyQpO3U9dS5zdWJzdHIoMSl9aWYodS5jaGFyQXQoMCkhPT0iKSIpdGhyb3cgbmV3IEVycm9yKCJNaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMgaW4gOiIrJCsiICgiK3UrIikiKTt1PXUuc3Vic3RyKDEpfWVsc2V7Zm9yKHZhciBxPTEsRj0xO0Y+MCYmcTx1Lmxlbmd0aDtxKyspdS5jaGFyQXQocSk9PT0iKCImJiFMKHEpP0YrKzp1LmNoYXJBdChxKT09PSIpIiYmIUwocSkmJkYtLTtpZihGKXRocm93IG5ldyBFcnJvcigiUGFyZW50aGVzaXMgbm90IG1hdGNoZWQiKTtpZihDPXUuc3Vic3RyKDEscS0yKSx1PXUuc3Vic3RyKHEpLHguaGFzKCQpKXt2YXIgSD1DLmNoYXJBdCgwKTtIPT09Qy5zbGljZSgtMSkmJmcuaGFzKEgpJiYoQz1DLnNsaWNlKDEsLTEpKSxDPW0oQyl9fWgucHVzaCh7dHlwZToicHNldWRvIixuYW1lOiQsZGF0YTpDfSl9ZWxzZSBpZihyLnRlc3QodSkpe3ZhciBHPUUoKTsoIWF8fCgibG93ZXJDYXNlVGFncyJpbiBhP2EubG93ZXJDYXNlVGFnczohYS54bWxNb2RlKSkmJihHPUcudG9Mb3dlckNhc2UoKSksaC5wdXNoKHt0eXBlOiJ0YWciLG5hbWU6R30pfWVsc2UgcmV0dXJuIGgubGVuZ3RoJiZoW2gubGVuZ3RoLTFdLnR5cGU9PT0iZGVzY2VuZGFudCImJmgucG9wKCksUChpLGgpLHV9cmV0dXJuIFAoaSxoKSx1fWZ1bmN0aW9uIFAoaSx1KXtpZihpLmxlbmd0aD4wJiZ1Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtpLnB1c2godSl9fSxmdW5jdGlvbihkLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXtlcXVhbHM6IiIsZWxlbWVudDoifiIsc3RhcnQ6Il4iLGVuZDoiJCIsYW55OiIqIixub3Q6IiEiLGh5cGhlbjoifCJ9O2Z1bmN0aW9uIG4obyl7cmV0dXJuIG8ubWFwKHMpLmpvaW4oIiwgIil9ZS5kZWZhdWx0PW47ZnVuY3Rpb24gcyhvKXtyZXR1cm4gby5tYXAobCkuam9pbigiIil9ZnVuY3Rpb24gbChvKXtzd2l0Y2goby50eXBlKXtjYXNlImNoaWxkIjpyZXR1cm4iID4gIjtjYXNlInBhcmVudCI6cmV0dXJuIiA8ICI7Y2FzZSJzaWJsaW5nIjpyZXR1cm4iIH4gIjtjYXNlImFkamFjZW50IjpyZXR1cm4iICsgIjtjYXNlImRlc2NlbmRhbnQiOnJldHVybiIgIjtjYXNlInVuaXZlcnNhbCI6cmV0dXJuIioiO2Nhc2UidGFnIjpyZXR1cm4gby5uYW1lO2Nhc2UicHNldWRvLWVsZW1lbnQiOnJldHVybiI6OiIrby5uYW1lO2Nhc2UicHNldWRvIjpyZXR1cm4gby5kYXRhPT09bnVsbD8iOiIrby5uYW1lOnR5cGVvZiBvLmRhdGE9PSJzdHJpbmciPyI6IitvLm5hbWUrIigiK28uZGF0YSsiKSI6IjoiK28ubmFtZSsiKCIrbihvLmRhdGEpKyIpIjtjYXNlImF0dHJpYnV0ZSI6cmV0dXJuIG8uYWN0aW9uPT09ImV4aXN0cyI/IlsiK28ubmFtZSsiXSI6by5uYW1lPT09ImlkIiYmby5hY3Rpb249PT0iZXF1YWxzIiYmIW8uaWdub3JlQ2FzZT8iIyIrby52YWx1ZTpvLm5hbWU9PT0iY2xhc3MiJiZvLmFjdGlvbj09PSJlbGVtZW50IiYmIW8uaWdub3JlQ2FzZT8iLiIrby52YWx1ZToiWyIrby5uYW1lK3Jbby5hY3Rpb25dKyI9JyIrby52YWx1ZSsiJyIrKG8uaWdub3JlQ2FzZT8iaSI6IiIpKyJdIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5rbm93biB0eXBlIil9fWZ1bmN0aW9uIGMobyl7cmV0dXJuIG99fSxmdW5jdGlvbihkLGUsdCl7ZC5leHBvcnRzPXM7dmFyIHI9dCgyNzkpLG49e19fcHJvdG9fXzpudWxsLGV4aXN0czoxMCxlcXVhbHM6OCxub3Q6NyxzdGFydDo2LGVuZDo2LGFueTo1LGh5cGhlbjo0LGVsZW1lbnQ6NH07ZnVuY3Rpb24gcyhjKXtmb3IodmFyIG89Yy5tYXAobCksZj0xO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgeD1vW2ZdO2lmKCEoeDwwKSlmb3IodmFyIGc9Zi0xO2c+PTAmJng8b1tnXTtnLS0pe3ZhciB5PWNbZysxXTtjW2crMV09Y1tnXSxjW2ddPXksb1tnKzFdPW9bZ10sb1tnXT14fX19ZnVuY3Rpb24gbChjKXt2YXIgbz1yW2MudHlwZV07aWYobz09PXIuYXR0cmlidXRlKW89bltjLmFjdGlvbl0sbz09PW4uZXF1YWxzJiZjLm5hbWU9PT0iaWQiJiYobz05KSxjLmlnbm9yZUNhc2UmJihvPj49MSk7ZWxzZSBpZihvPT09ci5wc2V1ZG8paWYoIWMuZGF0YSlvPTM7ZWxzZSBpZihjLm5hbWU9PT0iaGFzInx8Yy5uYW1lPT09ImNvbnRhaW5zIilvPTA7ZWxzZSBpZihjLm5hbWU9PT0ibWF0Y2hlcyJ8fGMubmFtZT09PSJub3QiKXtvPTA7Zm9yKHZhciBmPTA7ZjxjLmRhdGEubGVuZ3RoO2YrKylpZihjLmRhdGFbZl0ubGVuZ3RoPT09MSl7dmFyIHg9bChjLmRhdGFbZl1bMF0pO2lmKHg9PT0wKXtvPTA7YnJlYWt9eD5vJiYobz14KX1jLmRhdGEubGVuZ3RoPjEmJm8+MCYmKG8tPTEpfWVsc2Ugbz0xO3JldHVybiBvfX0sZnVuY3Rpb24oZCl7ZC5leHBvcnRzPUpTT04ucGFyc2UoJ3sidW5pdmVyc2FsIjo1MCwidGFnIjozMCwiYXR0cmlidXRlIjoxLCJwc2V1ZG8iOjAsImRlc2NlbmRhbnQiOi0xLCJjaGlsZCI6LTEsInBhcmVudCI6LTEsInNpYmxpbmciOi0xLCJhZGphY2VudCI6LTF9Jyl9LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDI4MSksbj10KDI4Mik7ZC5leHBvcnRzPXtfX3Byb3RvX186bnVsbCxhdHRyaWJ1dGU6ci5jb21waWxlLHBzZXVkbzpuLmNvbXBpbGUsdGFnOmZ1bmN0aW9uKHMsbCxjKXt2YXIgbz1sLm5hbWUsZj1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiBmLmdldE5hbWUoZyk9PT1vJiZzKGcpfX0sZGVzY2VuZGFudDpmdW5jdGlvbihzLGwsYyl7dmFyIG89dHlwZW9mIFdlYWtTZXQ8InUiP25ldyBXZWFrU2V0Om51bGwsZj1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGcpe2Zvcih2YXIgeT0hMTsheSYmKGc9Zi5nZXRQYXJlbnQoZykpOykoIW98fCFvLmhhcyhnKSkmJih5PXMoZyksIXkmJm8mJm8uYWRkKGcpKTtyZXR1cm4geX19LF9mbGV4aWJsZURlc2NlbmRhbnQ6ZnVuY3Rpb24ocyxsLGMpe3ZhciBvPWMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oeCl7Zm9yKHZhciBnPXMoeCk7IWcmJih4PW8uZ2V0UGFyZW50KHgpKTspZz1zKHgpO3JldHVybiBnfX0scGFyZW50OmZ1bmN0aW9uKHMsbCxjKXtpZihjJiZjLnN0cmljdCl0aHJvdyBuZXcgRXJyb3IoIlBhcmVudCBzZWxlY3RvciBpc24ndCBwYXJ0IG9mIENTUzMiKTt2YXIgbz1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiBvLmdldENoaWxkcmVuKGcpLnNvbWUoZil9O2Z1bmN0aW9uIGYoeCl7cmV0dXJuIG8uaXNUYWcoeCkmJnMoeCl9fSxjaGlsZDpmdW5jdGlvbihzLGwsYyl7dmFyIG89Yy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih4KXt2YXIgZz1vLmdldFBhcmVudCh4KTtyZXR1cm4hIWcmJnMoZyl9fSxzaWJsaW5nOmZ1bmN0aW9uKHMsbCxjKXt2YXIgbz1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHgpe2Zvcih2YXIgZz1vLmdldFNpYmxpbmdzKHgpLHk9MDt5PGcubGVuZ3RoO3krKylpZihvLmlzVGFnKGdbeV0pKXtpZihnW3ldPT09eClicmVhaztpZihzKGdbeV0pKXJldHVybiEwfXJldHVybiExfX0sYWRqYWNlbnQ6ZnVuY3Rpb24ocyxsLGMpe3ZhciBvPWMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oeCl7Zm9yKHZhciBnPW8uZ2V0U2libGluZ3MoeCkseSxtPTA7bTxnLmxlbmd0aDttKyspaWYoby5pc1RhZyhnW21dKSl7aWYoZ1ttXT09PXgpYnJlYWs7eT1nW21dfXJldHVybiEheSYmcyh5KX19LHVuaXZlcnNhbDpmdW5jdGlvbihzKXtyZXR1cm4gc319fSxmdW5jdGlvbihkLGUsdCl7dmFyIHI9dCgyNzMpLmZhbHNlRnVuYyxuPS9bLVtcXXt9KCkqKz8uLFxcXiR8I1xzXS9nLHM9e19fcHJvdG9fXzpudWxsLGVxdWFsczpmdW5jdGlvbihsLGMsbyl7dmFyIGY9Yy5uYW1lLHg9Yy52YWx1ZSxnPW8uYWRhcHRlcjtyZXR1cm4gYy5pZ25vcmVDYXNlPyh4PXgudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihtKXt2YXIgVD1nLmdldEF0dHJpYnV0ZVZhbHVlKG0sZik7cmV0dXJuIFQhPW51bGwmJlQudG9Mb3dlckNhc2UoKT09PXgmJmwobSl9KTpmdW5jdGlvbihtKXtyZXR1cm4gZy5nZXRBdHRyaWJ1dGVWYWx1ZShtLGYpPT09eCYmbChtKX19LGh5cGhlbjpmdW5jdGlvbihsLGMsbyl7dmFyIGY9Yy5uYW1lLHg9Yy52YWx1ZSxnPXgubGVuZ3RoLHk9by5hZGFwdGVyO3JldHVybiBjLmlnbm9yZUNhc2U/KHg9eC50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKFQpe3ZhciBPPXkuZ2V0QXR0cmlidXRlVmFsdWUoVCxmKTtyZXR1cm4gTyE9bnVsbCYmKE8ubGVuZ3RoPT09Z3x8Ty5jaGFyQXQoZyk9PT0iLSIpJiZPLnN1YnN0cigwLGcpLnRvTG93ZXJDYXNlKCk9PT14JiZsKFQpfSk6ZnVuY3Rpb24oVCl7dmFyIE89eS5nZXRBdHRyaWJ1dGVWYWx1ZShULGYpO3JldHVybiBPIT1udWxsJiZPLnN1YnN0cigwLGcpPT09eCYmKE8ubGVuZ3RoPT09Z3x8Ty5jaGFyQXQoZyk9PT0iLSIpJiZsKFQpfX0sZWxlbWVudDpmdW5jdGlvbihsLGMsbyl7dmFyIGY9Yy5uYW1lLHg9Yy52YWx1ZSxnPW8uYWRhcHRlcjtpZigvXHMvLnRlc3QoeCkpcmV0dXJuIHI7eD14LnJlcGxhY2UobiwiXFwkJiIpO3ZhciB5PSIoPzpefFxccykiK3grIig/OiR8XFxzKSIsbT1jLmlnbm9yZUNhc2U/ImkiOiIiLFQ9bmV3IFJlZ0V4cCh5LG0pO3JldHVybiBmdW5jdGlvbih2KXt2YXIgUD1nLmdldEF0dHJpYnV0ZVZhbHVlKHYsZik7cmV0dXJuIFAhPW51bGwmJlQudGVzdChQKSYmbCh2KX19LGV4aXN0czpmdW5jdGlvbihsLGMsbyl7dmFyIGY9Yy5uYW1lLHg9by5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih5KXtyZXR1cm4geC5oYXNBdHRyaWIoeSxmKSYmbCh5KX19LHN0YXJ0OmZ1bmN0aW9uKGwsYyxvKXt2YXIgZj1jLm5hbWUseD1jLnZhbHVlLGc9eC5sZW5ndGgseT1vLmFkYXB0ZXI7cmV0dXJuIGc9PT0wP3I6Yy5pZ25vcmVDYXNlPyh4PXgudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihUKXt2YXIgTz15LmdldEF0dHJpYnV0ZVZhbHVlKFQsZik7cmV0dXJuIE8hPW51bGwmJk8uc3Vic3RyKDAsZykudG9Mb3dlckNhc2UoKT09PXgmJmwoVCl9KTpmdW5jdGlvbihUKXt2YXIgTz15LmdldEF0dHJpYnV0ZVZhbHVlKFQsZik7cmV0dXJuIE8hPW51bGwmJk8uc3Vic3RyKDAsZyk9PT14JiZsKFQpfX0sZW5kOmZ1bmN0aW9uKGwsYyxvKXt2YXIgZj1jLm5hbWUseD1jLnZhbHVlLGc9LXgubGVuZ3RoLHk9by5hZGFwdGVyO3JldHVybiBnPT09MD9yOmMuaWdub3JlQ2FzZT8oeD14LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oVCl7dmFyIE89eS5nZXRBdHRyaWJ1dGVWYWx1ZShULGYpO3JldHVybiBPIT1udWxsJiZPLnN1YnN0cihnKS50b0xvd2VyQ2FzZSgpPT09eCYmbChUKX0pOmZ1bmN0aW9uKFQpe3ZhciBPPXkuZ2V0QXR0cmlidXRlVmFsdWUoVCxmKTtyZXR1cm4gTyE9bnVsbCYmTy5zdWJzdHIoZyk9PT14JiZsKFQpfX0sYW55OmZ1bmN0aW9uKGwsYyxvKXt2YXIgZj1jLm5hbWUseD1jLnZhbHVlLGc9by5hZGFwdGVyO2lmKHg9PT0iIilyZXR1cm4gcjtpZihjLmlnbm9yZUNhc2Upe3ZhciB5PW5ldyBSZWdFeHAoeC5yZXBsYWNlKG4sIlxcJCYiKSwiaSIpO3JldHVybiBmdW5jdGlvbihUKXt2YXIgTz1nLmdldEF0dHJpYnV0ZVZhbHVlKFQsZik7cmV0dXJuIE8hPW51bGwmJnkudGVzdChPKSYmbChUKX19cmV0dXJuIGZ1bmN0aW9uKFQpe3ZhciBPPWcuZ2V0QXR0cmlidXRlVmFsdWUoVCxmKTtyZXR1cm4gTyE9bnVsbCYmTy5pbmRleE9mKHgpPj0wJiZsKFQpfX0sbm90OmZ1bmN0aW9uKGwsYyxvKXt2YXIgZj1jLm5hbWUseD1jLnZhbHVlLGc9by5hZGFwdGVyO3JldHVybiB4PT09IiI/ZnVuY3Rpb24obSl7cmV0dXJuISFnLmdldEF0dHJpYnV0ZVZhbHVlKG0sZikmJmwobSl9OmMuaWdub3JlQ2FzZT8oeD14LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24obSl7dmFyIFQ9Zy5nZXRBdHRyaWJ1dGVWYWx1ZShtLGYpO3JldHVybiBUIT1udWxsJiZULnRvTG93ZXJDYXNlKCkhPT14JiZsKG0pfSk6ZnVuY3Rpb24obSl7cmV0dXJuIGcuZ2V0QXR0cmlidXRlVmFsdWUobSxmKSE9PXgmJmwobSl9fX07ZC5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKGwsYyxvKXtpZihvJiZvLnN0cmljdCYmKGMuaWdub3JlQ2FzZXx8Yy5hY3Rpb249PT0ibm90IikpdGhyb3cgbmV3IEVycm9yKCJVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgc2VsZWN0b3IiKTtyZXR1cm4gc1tjLmFjdGlvbl0obCxjLG8pfSxydWxlczpzfX0sZnVuY3Rpb24oZCxlLHQpe3ZhciByPXQoMjgzKSxuPXQoMjczKSxzPXQoMjgxKSxsPW4udHJ1ZUZ1bmMsYz1uLmZhbHNlRnVuYyxvPXMucnVsZXMuZXF1YWxzO2Z1bmN0aW9uIGYoUCxpKXt2YXIgdT17bmFtZTpQLHZhbHVlOml9O3JldHVybiBmdW5jdGlvbihoLGIsRSl7cmV0dXJuIG8oaCx1LEUpfX1mdW5jdGlvbiB4KFAsaSl7cmV0dXJuIGZ1bmN0aW9uKHUpe3JldHVybiEhaS5nZXRQYXJlbnQodSkmJlAodSl9fXZhciBnPXtjb250YWluczpmdW5jdGlvbihQLGksdSl7dmFyIGE9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gUChiKSYmYS5nZXRUZXh0KGIpLmluZGV4T2YoaSk+PTB9fSxpY29udGFpbnM6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPWkudG9Mb3dlckNhc2UoKSxoPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oRSl7cmV0dXJuIFAoRSkmJmguZ2V0VGV4dChFKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoYSk+PTB9fSwibnRoLWNoaWxkIjpmdW5jdGlvbihQLGksdSl7dmFyIGE9cihpKSxoPXUuYWRhcHRlcjtyZXR1cm4gYT09PWM/YTphPT09bD94KFAsaCk6ZnVuY3Rpb24oRSl7Zm9yKHZhciBBPWguZ2V0U2libGluZ3MoRSksTD0wLFM9MDtMPEEubGVuZ3RoO0wrKylpZihoLmlzVGFnKEFbTF0pKXtpZihBW0xdPT09RSlicmVhaztTKyt9cmV0dXJuIGEoUykmJlAoRSl9fSwibnRoLWxhc3QtY2hpbGQiOmZ1bmN0aW9uKFAsaSx1KXt2YXIgYT1yKGkpLGg9dS5hZGFwdGVyO3JldHVybiBhPT09Yz9hOmE9PT1sP3goUCxoKTpmdW5jdGlvbihFKXtmb3IodmFyIEE9aC5nZXRTaWJsaW5ncyhFKSxMPTAsUz1BLmxlbmd0aC0xO1M+PTA7Uy0tKWlmKGguaXNUYWcoQVtTXSkpe2lmKEFbU109PT1FKWJyZWFrO0wrK31yZXR1cm4gYShMKSYmUChFKX19LCJudGgtb2YtdHlwZSI6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXIoaSksaD11LmFkYXB0ZXI7cmV0dXJuIGE9PT1jP2E6YT09PWw/eChQLGgpOmZ1bmN0aW9uKEUpe2Zvcih2YXIgQT1oLmdldFNpYmxpbmdzKEUpLEw9MCxTPTA7UzxBLmxlbmd0aDtTKyspaWYoaC5pc1RhZyhBW1NdKSl7aWYoQVtTXT09PUUpYnJlYWs7aC5nZXROYW1lKEFbU10pPT09aC5nZXROYW1lKEUpJiZMKyt9cmV0dXJuIGEoTCkmJlAoRSl9fSwibnRoLWxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXIoaSksaD11LmFkYXB0ZXI7cmV0dXJuIGE9PT1jP2E6YT09PWw/eChQLGgpOmZ1bmN0aW9uKEUpe2Zvcih2YXIgQT1oLmdldFNpYmxpbmdzKEUpLEw9MCxTPUEubGVuZ3RoLTE7Uz49MDtTLS0paWYoaC5pc1RhZyhBW1NdKSl7aWYoQVtTXT09PUUpYnJlYWs7aC5nZXROYW1lKEFbU10pPT09aC5nZXROYW1lKEUpJiZMKyt9cmV0dXJuIGEoTCkmJlAoRSl9fSxyb290OmZ1bmN0aW9uKFAsaSx1KXt2YXIgYT11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGgpe3JldHVybiFhLmdldFBhcmVudChoKSYmUChoKX19LHNjb3BlOmZ1bmN0aW9uKFAsaSx1LGEpe3ZhciBoPXUuYWRhcHRlcjtpZighYXx8YS5sZW5ndGg9PT0wKXJldHVybiBnLnJvb3QoUCxpLHUpO2Z1bmN0aW9uIGIoRSxBKXtyZXR1cm4gdHlwZW9mIGguZXF1YWxzPT0iZnVuY3Rpb24iP2guZXF1YWxzKEUsQSk6RT09PUF9cmV0dXJuIGEubGVuZ3RoPT09MT9mdW5jdGlvbihFKXtyZXR1cm4gYihhWzBdLEUpJiZQKEUpfTpmdW5jdGlvbihFKXtyZXR1cm4gYS5pbmRleE9mKEUpPj0wJiZQKEUpfX0sY2hlY2tib3g6ZigidHlwZSIsImNoZWNrYm94IiksZmlsZTpmKCJ0eXBlIiwiZmlsZSIpLHBhc3N3b3JkOmYoInR5cGUiLCJwYXNzd29yZCIpLHJhZGlvOmYoInR5cGUiLCJyYWRpbyIpLHJlc2V0OmYoInR5cGUiLCJyZXNldCIpLGltYWdlOmYoInR5cGUiLCJpbWFnZSIpLHN1Ym1pdDpmKCJ0eXBlIiwic3VibWl0IiksaG92ZXI6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXUuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGEuaXNIb3ZlcmVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGIpe3JldHVybiBQKGIpJiZhLmlzSG92ZXJlZChiKX06Y30sdmlzaXRlZDpmdW5jdGlvbihQLGksdSl7dmFyIGE9dS5hZGFwdGVyO3JldHVybiB0eXBlb2YgYS5pc1Zpc2l0ZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYil7cmV0dXJuIFAoYikmJmEuaXNWaXNpdGVkKGIpfTpjfSxhY3RpdmU6ZnVuY3Rpb24oUCxpLHUpe3ZhciBhPXUuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGEuaXNBY3RpdmU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYil7cmV0dXJuIFAoYikmJmEuaXNBY3RpdmUoYil9OmN9fTtmdW5jdGlvbiB5KFAsaSl7Zm9yKHZhciB1PTA7UCYmdTxQLmxlbmd0aDt1KyspaWYoaS5pc1RhZyhQW3VdKSlyZXR1cm4gUFt1XX12YXIgbT17ZW1wdHk6ZnVuY3Rpb24oUCxpKXtyZXR1cm4haS5nZXRDaGlsZHJlbihQKS5zb21lKGZ1bmN0aW9uKHUpe3JldHVybiBpLmlzVGFnKHUpfHx1LnR5cGU9PT0idGV4dCJ9KX0sImZpcnN0LWNoaWxkIjpmdW5jdGlvbihQLGkpe3JldHVybiB5KGkuZ2V0U2libGluZ3MoUCksaSk9PT1QfSwibGFzdC1jaGlsZCI6ZnVuY3Rpb24oUCxpKXtmb3IodmFyIHU9aS5nZXRTaWJsaW5ncyhQKSxhPXUubGVuZ3RoLTE7YT49MDthLS0pe2lmKHVbYV09PT1QKXJldHVybiEwO2lmKGkuaXNUYWcodVthXSkpYnJlYWt9cmV0dXJuITF9LCJmaXJzdC1vZi10eXBlIjpmdW5jdGlvbihQLGkpe2Zvcih2YXIgdT1pLmdldFNpYmxpbmdzKFApLGE9MDthPHUubGVuZ3RoO2ErKylpZihpLmlzVGFnKHVbYV0pKXtpZih1W2FdPT09UClyZXR1cm4hMDtpZihpLmdldE5hbWUodVthXSk9PT1pLmdldE5hbWUoUCkpYnJlYWt9cmV0dXJuITF9LCJsYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKFAsaSl7Zm9yKHZhciB1PWkuZ2V0U2libGluZ3MoUCksYT11Lmxlbmd0aC0xO2E+PTA7YS0tKWlmKGkuaXNUYWcodVthXSkpe2lmKHVbYV09PT1QKXJldHVybiEwO2lmKGkuZ2V0TmFtZSh1W2FdKT09PWkuZ2V0TmFtZShQKSlicmVha31yZXR1cm4hMX0sIm9ubHktb2YtdHlwZSI6ZnVuY3Rpb24oUCxpKXtmb3IodmFyIHU9aS5nZXRTaWJsaW5ncyhQKSxhPTAsaD11Lmxlbmd0aDthPGg7YSsrKWlmKGkuaXNUYWcodVthXSkpe2lmKHVbYV09PT1QKWNvbnRpbnVlO2lmKGkuZ2V0TmFtZSh1W2FdKT09PWkuZ2V0TmFtZShQKSlyZXR1cm4hMX1yZXR1cm4hMH0sIm9ubHktY2hpbGQiOmZ1bmN0aW9uKFAsaSl7Zm9yKHZhciB1PWkuZ2V0U2libGluZ3MoUCksYT0wO2E8dS5sZW5ndGg7YSsrKWlmKGkuaXNUYWcodVthXSkmJnVbYV0hPT1QKXJldHVybiExO3JldHVybiEwfSxsaW5rOmZ1bmN0aW9uKFAsaSl7cmV0dXJuIGkuaGFzQXR0cmliKFAsImhyZWYiKX0sc2VsZWN0ZWQ6ZnVuY3Rpb24oUCxpKXtpZihpLmhhc0F0dHJpYihQLCJzZWxlY3RlZCIpKXJldHVybiEwO2lmKGkuZ2V0TmFtZShQKSE9PSJvcHRpb24iKXJldHVybiExO3ZhciB1PWkuZ2V0UGFyZW50KFApO2lmKCF1fHxpLmdldE5hbWUodSkhPT0ic2VsZWN0Inx8aS5oYXNBdHRyaWIodSwibXVsdGlwbGUiKSlyZXR1cm4hMTtmb3IodmFyIGE9aS5nZXRDaGlsZHJlbih1KSxoPSExLGI9MDtiPGEubGVuZ3RoO2IrKylpZihpLmlzVGFnKGFbYl0pKWlmKGFbYl09PT1QKWg9ITA7ZWxzZSBpZihoKXtpZihpLmhhc0F0dHJpYihhW2JdLCJzZWxlY3RlZCIpKXJldHVybiExfWVsc2UgcmV0dXJuITE7cmV0dXJuIGh9LGRpc2FibGVkOmZ1bmN0aW9uKFAsaSl7cmV0dXJuIGkuaGFzQXR0cmliKFAsImRpc2FibGVkIil9LGVuYWJsZWQ6ZnVuY3Rpb24oUCxpKXtyZXR1cm4haS5oYXNBdHRyaWIoUCwiZGlzYWJsZWQiKX0sY2hlY2tlZDpmdW5jdGlvbihQLGkpe3JldHVybiBpLmhhc0F0dHJpYihQLCJjaGVja2VkIil8fG0uc2VsZWN0ZWQoUCxpKX0scmVxdWlyZWQ6ZnVuY3Rpb24oUCxpKXtyZXR1cm4gaS5oYXNBdHRyaWIoUCwicmVxdWlyZWQiKX0sb3B0aW9uYWw6ZnVuY3Rpb24oUCxpKXtyZXR1cm4haS5oYXNBdHRyaWIoUCwicmVxdWlyZWQiKX0scGFyZW50OmZ1bmN0aW9uKFAsaSl7cmV0dXJuIW0uZW1wdHkoUCxpKX0saGVhZGVyOlQoWyJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiXSksYnV0dG9uOmZ1bmN0aW9uKFAsaSl7dmFyIHU9aS5nZXROYW1lKFApO3JldHVybiB1PT09ImJ1dHRvbiJ8fHU9PT0iaW5wdXQiJiZpLmdldEF0dHJpYnV0ZVZhbHVlKFAsInR5cGUiKT09PSJidXR0b24ifSxpbnB1dDpUKFsiaW5wdXQiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsImJ1dHRvbiJdKSx0ZXh0OmZ1bmN0aW9uKFAsaSl7dmFyIHU7cmV0dXJuIGkuZ2V0TmFtZShQKT09PSJpbnB1dCImJighKHU9aS5nZXRBdHRyaWJ1dGVWYWx1ZShQLCJ0eXBlIikpfHx1LnRvTG93ZXJDYXNlKCk9PT0idGV4dCIpfX07ZnVuY3Rpb24gVChQKXtpZih0eXBlb2YgU2V0PCJ1Iil7dmFyIGk9bmV3IFNldChQKTtyZXR1cm4gZnVuY3Rpb24odSxhKXtyZXR1cm4gaS5oYXMoYS5nZXROYW1lKHUpKX19cmV0dXJuIGZ1bmN0aW9uKHUsYSl7cmV0dXJuIFAuaW5kZXhPZihhLmdldE5hbWUodSkpPj0wfX1mdW5jdGlvbiBPKFAsaSx1KXtpZih1PT09bnVsbCl7aWYoUC5sZW5ndGg+MiYmaSE9PSJzY29wZSIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIraSsiIHJlcXVpcmVzIGFuIGFyZ3VtZW50Iil9ZWxzZSBpZihQLmxlbmd0aD09PTIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIraSsiIGRvZXNuJ3QgaGF2ZSBhbnkgYXJndW1lbnRzIil9dmFyIHY9L14oPzooPzpudGh8bGFzdHxmaXJzdHxvbmx5KS0oPzpjaGlsZHxvZi10eXBlKXxyb290fGVtcHR5fCg/OmVufGRpcylhYmxlZHxjaGVja2VkfG5vdCkkLztkLmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24oUCxpLHUsYSl7dmFyIGg9aS5uYW1lLGI9aS5kYXRhLEU9dS5hZGFwdGVyO2lmKHUmJnUuc3RyaWN0JiYhdi50ZXN0KGgpKXRocm93IG5ldyBFcnJvcigiOiIraCsiIGlzbid0IHBhcnQgb2YgQ1NTMyIpO2lmKHR5cGVvZiBnW2hdPT0iZnVuY3Rpb24iKXJldHVybiBnW2hdKFAsYix1LGEpO2lmKHR5cGVvZiBtW2hdPT0iZnVuY3Rpb24iKXt2YXIgQT1tW2hdO3JldHVybiBPKEEsaCxiKSxBPT09Yz9BOlA9PT1sP2Z1bmN0aW9uKFMpe3JldHVybiBBKFMsRSxiKX06ZnVuY3Rpb24oUyl7cmV0dXJuIEEoUyxFLGIpJiZQKFMpfX1lbHNlIHRocm93IG5ldyBFcnJvcigidW5tYXRjaGVkIHBzZXVkby1jbGFzcyA6IitoKX0sZmlsdGVyczpnLHBzZXVkb3M6bX19LGZ1bmN0aW9uKGQsZSx0KXt2YXIgcj10KDI4NCksbj10KDI4NSk7ZC5leHBvcnRzPWZ1bmN0aW9uKGwpe3JldHVybiBuKHIobCkpfSxkLmV4cG9ydHMucGFyc2U9cixkLmV4cG9ydHMuY29tcGlsZT1ufSxmdW5jdGlvbihkLGUpe2QuZXhwb3J0cz1yO3ZhciB0PS9eKFsrXC1dP1xkKm4pP1xzKig/OihbK1wtXT8pXHMqKFxkKykpPyQvO2Z1bmN0aW9uIHIobil7aWYobj1uLnRyaW0oKS50b0xvd2VyQ2FzZSgpLG49PT0iZXZlbiIpcmV0dXJuWzIsMF07aWYobj09PSJvZGQiKXJldHVyblsyLDFdO3ZhciBzPW4ubWF0Y2godCk7aWYoIXMpdGhyb3cgbmV3IFN5bnRheEVycm9yKCJuLXRoIHJ1bGUgY291bGRuJ3QgYmUgcGFyc2VkICgnIituKyInKSIpO3ZhciBsO3JldHVybiBzWzFdPyhsPXBhcnNlSW50KHNbMV0sMTApLGlzTmFOKGwpJiYoc1sxXS5jaGFyQXQoMCk9PT0iLSI/bD0tMTpsPTEpKTpsPTAsW2wsc1szXT9wYXJzZUludCgoc1syXXx8IiIpK3NbM10sMTApOjBdfX0sZnVuY3Rpb24oZCxlLHQpe2QuZXhwb3J0cz1sO3ZhciByPXQoMjczKSxuPXIudHJ1ZUZ1bmMscz1yLmZhbHNlRnVuYztmdW5jdGlvbiBsKGMpe3ZhciBvPWNbMF0sZj1jWzFdLTE7aWYoZjwwJiZvPD0wKXJldHVybiBzO2lmKG89PT0tMSlyZXR1cm4gZnVuY3Rpb24oZyl7cmV0dXJuIGc8PWZ9O2lmKG89PT0wKXJldHVybiBmdW5jdGlvbihnKXtyZXR1cm4gZz09PWZ9O2lmKG89PT0xKXJldHVybiBmPDA/bjpmdW5jdGlvbihnKXtyZXR1cm4gZz49Zn07dmFyIHg9ZiVvO3JldHVybiB4PDAmJih4Kz1vKSxvPjE/ZnVuY3Rpb24oZyl7cmV0dXJuIGc+PWYmJmclbz09PXh9OihvKj0tMSxmdW5jdGlvbihnKXtyZXR1cm4gZzw9ZiYmZyVvPT09eH0pfX0sZnVuY3Rpb24oZCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciByPXQoMTIpLG49dCg3NCkscz10KDEpLGw9dCg2OCksYz10KDI1MCksbz10KDIxMyksZj10KDIxOCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHgoRSxBKXtpZihFPT1udWxsKXJldHVybnt9O3ZhciBMPWcoRSxBKSxTLEk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhFKTtmb3IoST0wO0k8RC5sZW5ndGg7SSsrKVM9RFtJXSwhKEEuaW5kZXhPZihTKT49MCkmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChFLFMpJiYoTFtTXT1FW1NdKX1yZXR1cm4gTH1mdW5jdGlvbiBnKEUsQSl7aWYoRT09bnVsbClyZXR1cm57fTt2YXIgTD17fSxTPU9iamVjdC5rZXlzKEUpLEksRDtmb3IoRD0wO0Q8Uy5sZW5ndGg7RCsrKUk9U1tEXSwhKEEuaW5kZXhPZihJKT49MCkmJihMW0ldPUVbSV0pO3JldHVybiBMfWNvbnN0IHk9e2FudGlhbGlhczohMCxhdXRvUmVuZGVyOiEwLGFscGhhOiEwfSxtPVN5bWJvbCgiYXV0b1JlbmRlciIpLFQ9U3ltYm9sKCJyZW5kZXJlciIpLE89U3ltYm9sKCJ0aW1lbGluZSIpLHY9U3ltYm9sKCJwcmVwYXJlUmVuZGVyIiksUD1TeW1ib2woInRpY2tSZW5kZXIiKSxpPVN5bWJvbCgicGFzcyIpLHU9U3ltYm9sKCJmYm8iKSxhPVN5bWJvbCgidGlja2VycyIpLGg9U3ltYm9sKCJsYXllclRyYW5zZm9ybUludmVydCIpO2NsYXNzIGIgZXh0ZW5kcyBjLmRlZmF1bHR7Y29uc3RydWN0b3IoQT17fSl7aWYoc3VwZXIoKSwhQS5jYW52YXMpe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OlJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEM9ci5FTlYuY3JlYXRlQ2FudmFzKEQsUix7b2Zmc2NyZWVuOiEhQS5vZmZzY3JlZW4saWQ6QS5pZCxleHRyYTpBLmV4dHJhfSk7Qy5zdHlsZSYmKEMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIiksQy5kYXRhc2V0JiYoQy5kYXRhc2V0LmxheWVySWQ9QS5pZCksQy5jb250ZXh0VHlwZSYmKEEuY29udGV4dFR5cGU9Qy5jb250ZXh0VHlwZSksQS5jYW52YXM9Q31jb25zdCBMPUEuY2FudmFzLFM9T2JqZWN0LmFzc2lnbih7fSx5LEEpO3RoaXNbbV09Uy5hdXRvUmVuZGVyLGRlbGV0ZSBBLmF1dG9SZW5kZXI7Y29uc3QgST1TLlJlbmRlcmVyfHxyLlJlbmRlcmVyO3RoaXNbVF09bmV3IEkoTCxTKSx0aGlzLm9wdGlvbnM9QSx0aGlzLmlkPUEuaWQsdGhpc1tpXT1bXSx0aGlzLnNldFJlc29sdXRpb24oTCksdGhpcy5jYW52YXM9TCx0aGlzW09dPW5ldyBuLlRpbWVsaW5lLHRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGwsdGhpc1toXT1udWxsfWdldCBhdXRvUmVuZGVyKCl7cmV0dXJuIHRoaXNbbV19Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucz90aGlzLnBhcmVudC5vcHRpb25zLmRpc3BsYXlSYXRpbzoxfWdldCBoZWlnaHQoKXtjb25zdHtoZWlnaHQ6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEEvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGdsKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcj90aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuZ2w6bnVsbH1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpc31nZXQgb2Zmc2NyZWVuKCl7cmV0dXJuISF0aGlzLm9wdGlvbnMub2Zmc2NyZWVufHx0aGlzLmNhbnZhcy5fb2Zmc2NyZWVufWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbaV19Z2V0IHByZXBhcmVSZW5kZXIoKXtyZXR1cm4gdGhpc1t2XT90aGlzW3ZdOlByb21pc2UucmVzb2x2ZSgpfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzW1RdfWdldCByZW5kZXJPZmZzZXQoKXtpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucyl7Y29uc3R7bGVmdDpBLHRvcDpMfT10aGlzLnBhcmVudC5vcHRpb25zO3JldHVybltBLExdfXJldHVyblt0aGlzLm9wdGlvbnMubGVmdHwwLHRoaXMub3B0aW9ucy50b3B8MF19Z2V0IHRpbWVsaW5lKCl7cmV0dXJuIHRoaXNbT119Z2V0IHdpZHRoKCl7Y29uc3R7d2lkdGg6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEEvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3R7eDpBLHk6TH09dGhpcy5hdHRyaWJ1dGVzO3JldHVyblsxLDAsMCwxLEEsTF19Z2V0IGxheWVyVHJhbnNmb3JtSW52ZXJ0KCl7aWYodGhpc1toXSlyZXR1cm4gdGhpc1toXTtjb25zdCBBPXRoaXMudHJhbnNmb3JtTWF0cml4O3JldHVybiBBWzBdPT09MSYmQVsxXT09PTAmJkFbMl09PT0wJiZBWzNdPT09MSYmQVs0XT09PTAmJkFbNV09PT0wP251bGw6KHRoaXNbaF09cy5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEpLHRoaXNbaF0pfWZvcmNlQ29udGV4dExvc3MoKXtjb25zdCBBPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcjtpZihBKXtjb25zdCBMPUEuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9sb3NlX2NvbnRleHQiKTtpZihMKXJldHVybiBMLmxvc2VDb250ZXh0KCksITB9cmV0dXJuITF9YWRkUGFzcyh7dmVydGV4OkEsZnJhZ21lbnQ6TCxvcHRpb25zOlMsdW5pZm9ybXM6SX09e30pe2lmKHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcil7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpcy5nZXRSZXNvbHV0aW9uKCksQz10aGlzLnJlbmRlcmVyLmNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6QSxmcmFnbWVudDpMLG9wdGlvbnM6U30pLGo9bmV3IHIuRmlndXJlMkQ7ai5yZWN0KDAsMCxEL3RoaXMuZGlzcGxheVJhdGlvLFIvdGhpcy5kaXNwbGF5UmF0aW8pO2NvbnN0ICQ9bmV3IHIuTWVzaDJEKGopO3JldHVybiAkLnNldFVuaWZvcm1zKEkpLCQuc2V0UHJvZ3JhbShDKSx0aGlzW2ldLnB1c2goJCksdGhpcy5mb3JjZVVwZGF0ZSgpLCR9cmV0dXJuIG51bGx9ZGVsZXRlVGV4dHVyZShBKXtyZXR1cm4gT2JqZWN0KGYuZGVsZXRlVGV4dHVyZSkoQSx0aGlzLnJlbmRlcmVyKX1kaXNwYXRjaFBvaW50ZXJFdmVudChBKXtjb25zdCBMPUEudHlwZTtpZihMPT09Im1vdXNlZG93biJ8fEw9PT0ibW91c2V1cCJ8fEw9PT0ibW91c2Vtb3ZlIil7Y29uc3QgQz10aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldDtpZihDKXtpZihDLmxheWVyPT09dGhpcylyZXR1cm4gQy5kaXNwYXRjaEV2ZW50KEEpLCEwO3RoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGx9fWxldCBTLEk7Y29uc3QgRD10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O2lmKEQpe1M9QS54LEk9QS55O2NvbnN0IEM9RCxqPUNbMF0qUytDWzJdKkkrQ1s0XSwkPUNbMV0qUytDWzNdKkkrQ1s1XTtkZWxldGUgQS54LGRlbGV0ZSBBLnksZGVsZXRlIEEubGF5ZXJYLGRlbGV0ZSBBLmxheWVyWSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhBLHtsYXllclg6e3ZhbHVlOmosY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOiQsY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpqLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6JCxjb25maWd1cmFibGU6ITB9fSl9Y29uc3QgUj1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChBKTtyZXR1cm4gRCYmT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQSx7bGF5ZXJYOnt2YWx1ZTpTLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpJLGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6Uyxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOkksY29uZmlndXJhYmxlOiEwfX0pLFJ9Zm9yY2VVcGRhdGUoKXtpZighdGhpc1t2XSlpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuaGFzT2Zmc2NyZWVuQ2FudmFzKXt0aGlzLnBhcmVudC5mb3JjZVVwZGF0ZSgpO2xldCBBPW51bGw7Y29uc3QgTD1uZXcgUHJvbWlzZShTPT57QT1TfSk7TC5fcmVzb2x2ZT1BLHRoaXNbdl09TH1lbHNle2xldCBBPW51bGwsTD1udWxsO2NvbnN0IFM9bmV3IFByb21pc2UoST0+e0E9SSx0aGlzW21dJiYoTD1PYmplY3QobC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIFMuX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfSk7Uy5fcmVzb2x2ZT1BLFMuX3JlcXVlc3RJRD1MLHRoaXNbdl09U319Z2V0RkJPKCl7Y29uc3QgQT10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIse3dpZHRoOkwsaGVpZ2h0OlN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBBJiYoIXRoaXNbdV18fHRoaXNbdV0ud2lkdGghPT1MfHx0aGlzW3VdLmhlaWdodCE9PVMpPyh0aGlzW3VdPXt3aWR0aDpMLGhlaWdodDpTLHRhcmdldDpBLmNyZWF0ZUZCTygpLGJ1ZmZlcjpBLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSx0aGlzW3VdKTp0aGlzW3VdP3RoaXNbdV06bnVsbH11cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBBPXRoaXMucmVuZGVyZXIsTD1BLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxBLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtBLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PUw7Y29uc3QgUz1zLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO0Euc2V0R2xvYmFsVHJhbnNmb3JtKC4uLnMubWF0MmQubXVsdGlwbHkoUyxMLHRoaXMudHJhbnNmb3JtTWF0cml4KSl9fW9uUHJvcGVydHlDaGFuZ2UoQSxMLFMpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoQSxMLFMpLEE9PT0iekluZGV4IiYmKHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleD1MKSxBPT09InRyYW5zZm9ybSJ8fEE9PT0idHJhbnNsYXRlInx8QT09PSJyb3RhdGUifHxBPT09InNjYWxlInx8QT09PSJza2V3Iil7Y29uc3QgST10aGlzW2hdO2lmKHRoaXNbaF09bnVsbCx0aGlzLnVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpLEkmJiF0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBEPXRoaXMucmVuZGVyZXIsUj1ELl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxELmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtELnNldEdsb2JhbFRyYW5zZm9ybSguLi5SKX19fV9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKXt0aGlzW3ZdJiYodGhpc1t2XS5fcmVxdWVzdElEJiZPYmplY3QobC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1t2XS5fcmVxdWVzdElEKSx0aGlzW3ZdLl9yZXNvbHZlKCksZGVsZXRlIHRoaXNbdl0pfXJlbmRlcih7Y2xlYXI6QT0hMH09e30pe2NvbnN0IEw9dGhpc1tpXS5sZW5ndGg/dGhpcy5nZXRGQk8oKTpudWxsO0wmJnRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5iaW5kRkJPKEwudGFyZ2V0KSxBJiZ0aGlzW1RdLmNsZWFyKCk7Y29uc3QgUz10aGlzLmRyYXcoKTtpZihTJiZTLmxlbmd0aCYmKHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhTKSx0aGlzLmNhbnZhcy5kcmF3JiZ0aGlzLmNhbnZhcy5kcmF3KCkpLEwpe2NvbnN0IEk9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLEQ9dGhpc1tpXS5sZW5ndGgse3dpZHRoOlIsaGVpZ2h0OkN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLGo9WzAsMCxSL3RoaXMuZGlzcGxheVJhdGlvLEMvdGhpcy5kaXNwbGF5UmF0aW9dO3RoaXNbaV0uZm9yRWFjaCgoJCxIKT0+eyQuYmxlbmQ9ITAsJC5zZXRUZXh0dXJlKEwudGFyZ2V0LnRleHR1cmUse3JlY3Q6an0pLEg9PT1ELTE/SS5iaW5kRkJPKG51bGwpOihMLnN3YXAoKSxJLmJpbmRGQk8oTC50YXJnZXQpKSx0aGlzW1RdLmNsZWFyKCksdGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKFskXSl9KX10aGlzLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpBLGhlaWdodDpMfSl7Y29uc3QgUz10aGlzLnJlbmRlcmVyLEk9Uy5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8Uy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgsRD1JWzRdLFI9SVs1XSxDPUlbMF0se3dpZHRoOmosaGVpZ2h0OiR9PXRoaXMuZ2V0UmVzb2x1dGlvbigpOyhqIT09QXx8JCE9PUwpJiYoc3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6QSxoZWlnaHQ6TH0pLHRoaXMuY2FudmFzJiYodGhpcy5jYW52YXMud2lkdGg9QSx0aGlzLmNhbnZhcy5oZWlnaHQ9TCxTLnVwZGF0ZVJlc29sdXRpb24mJlMudXBkYXRlUmVzb2x1dGlvbigpKSx0aGlzLmF0dHJpYnV0ZXMuc2l6ZT1bQSxMXSx0aGlzW2ldLmxlbmd0aCYmdGhpc1tpXS5mb3JFYWNoKEY9Pntjb25zdCBHPW5ldyByLkZpZ3VyZTJEO0cucmVjdCgwLDAsQS90aGlzLmRpc3BsYXlSYXRpbyxML3RoaXMuZGlzcGxheVJhdGlvKSxGLmNvbnRvdXJzPUcuY29udG91cnN9KSk7Y29uc3RbSCxKXT10aGlzLnJlbmRlck9mZnNldCxxPXRoaXMuZGlzcGxheVJhdGlvOyhEIT09SHx8UiE9PUp8fEMhPT1xKSYmKFMuc2V0R2xvYmFsVHJhbnNmb3JtKHEsMCwwLHEsSCxKKSxTLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PW51bGwsdGhpc1toXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksdGhpcy5mb3JjZVVwZGF0ZSgpKX10aWNrKEE9bnVsbCxMPXt9KXtsZXR7ZHVyYXRpb246Uz0xLzB9PUwsST14KEwsWyJkdXJhdGlvbiJdKTtjb25zdCBEPXRoaXMudGltZWxpbmUuZm9yayhJKSxSPXRoaXM7dGhpc1thXT10aGlzW2FdfHxbXSx0aGlzW2FdLnB1c2goe2hhbmRsZXI6QSxkdXJhdGlvbjpTfSk7Y29uc3QgQz0oKT0+e2xldCBqPW51bGwsJD1udWxsO2NvbnN0IEg9KCk9Pntjb25zdCBKPXRoaXNbYV0ubWFwKCh7aGFuZGxlcjpxLGR1cmF0aW9uOkZ9KT0+e2NvbnN0IEc9TWF0aC5taW4oMSxELmN1cnJlbnRUaW1lL0YpO3JldHVybnt2YWx1ZTpxP3EoRC5jdXJyZW50VGltZSxHKTpudWxsLHA6R319KTtSW1BdfHwoUltQXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57UlttXSYmUi5yZW5kZXIoKSxkZWxldGUgUltQXTtmb3IobGV0IHE9Si5sZW5ndGgtMTtxPj0wO3EtLSl7Y29uc3R7dmFsdWU6RixwOkd9PUpbcV07KEY9PT0hMXx8Rz49MSkmJnRoaXNbYV0uc3BsaWNlKHEsMSl9dGhpc1thXS5sZW5ndGg+MCYmQygpfSkpfTtpZih0aGlzW3ZdJiZ0aGlzW3ZdLl90eXBlIT09InRpY2tlciImJihPYmplY3QobC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1t2XS5fcmVxdWVzdElEKSxkZWxldGUgdGhpc1t2XSksIXRoaXNbdl0pe2NvbnN0IEo9bmV3IFByb21pc2UocT0+e2o9cSwkPU9iamVjdChsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoSCl9KTtKLl9yZXNvbHZlPWosSi5fcmVxdWVzdElEPSQsSi5fdHlwZT0idGlja2VyIix0aGlzW3ZdPUp9fTtDKCl9dG9HbG9iYWxQb3MoQSxMKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBqPXRoaXMudHJhbnNmb3JtTWF0cml4O0E9alswXSpBK2pbMl0qTCtqWzRdLEw9alsxXSpBK2pbM10qTCtqWzVdfWNvbnN0e3dpZHRoOlMsaGVpZ2h0Okl9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEQ9dGhpcy5yZW5kZXJPZmZzZXQsUj1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtBPUEqUlswXS9TK0RbMF0sTD1MKlJbMV0vSStEWzFdO2NvbnN0IEM9dGhpcy5kaXNwbGF5UmF0aW87cmV0dXJuIEEqPUMsTCo9QyxbQSxMXX10b0xvY2FsUG9zKEEsTCl7Y29uc3R7d2lkdGg6UyxoZWlnaHQ6SX09dGhpcy5nZXRSZXNvbHV0aW9uKCksRD10aGlzLnJlbmRlck9mZnNldCxSPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO0E9QSpTL1JbMF0tRFswXSxMPUwqSS9SWzFdLURbMV07Y29uc3QgQz10aGlzLmRpc3BsYXlSYXRpbztBLz1DLEwvPUM7Y29uc3Qgaj10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O3JldHVybiBqJiYoQT1qWzBdKkEralsyXSpMK2pbNF0sTD1qWzFdKkEralszXSpMK2pbNV0pLFtBLExdfX1vLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsImxheWVyIil9LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDIyNCksbj10KDI4OCkscz10KDIxMyksbD10KDI1MiksYz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhQLGkpe2lmKFA9PW51bGwpcmV0dXJue307dmFyIHU9ZihQLGkpLGEsaDtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgYj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFApO2ZvcihoPTA7aDxiLmxlbmd0aDtoKyspYT1iW2hdLCEoaS5pbmRleE9mKGEpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFAsYSkmJih1W2FdPVBbYV0pfXJldHVybiB1fWZ1bmN0aW9uIGYoUCxpKXtpZihQPT1udWxsKXJldHVybnt9O3ZhciB1PXt9LGE9T2JqZWN0LmtleXMoUCksaCxiO2ZvcihiPTA7YjxhLmxlbmd0aDtiKyspaD1hW2JdLCEoaS5pbmRleE9mKGgpPj0wKSYmKHVbaF09UFtoXSk7cmV0dXJuIHV9ZnVuY3Rpb24geChQLGksdSl7cmV0dXJuIGkgaW4gUD9PYmplY3QuZGVmaW5lUHJvcGVydHkoUCxpLHt2YWx1ZTp1LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6UFtpXT11LFB9Y29uc3QgZz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLHk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbT1TeW1ib2woInJvb3QiKSxUPVN5bWJvbCgidGFzayIpO2Z1bmN0aW9uIE8oUCxpPSEwKXtjb25zdCB1PVBbbV07aWYodSYmdS5jaGlsZHJlblswXSl7Y29uc3QgYT1QLnN2ZyxoPVAubGF5ZXI/UC5sYXllci5kaXNwbGF5UmF0aW86MTtpZighYS5oYXNBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSl7bGV0IEE9YS5nZXRBdHRyaWJ1dGUoIndpZHRoIik7QT1BP09iamVjdChjLnNpemVUb1BpeGVsKShBKTozMDA7bGV0IEw9YS5nZXRBdHRyaWJ1dGUoImhlaWdodCIpO0w9TD9PYmplY3QoYy5zaXplVG9QaXhlbCkoTCk6MTUwLGEuaGFzQXR0cmlidXRlKCJ2aWV3Qm94Iil8fGEuc2V0QXR0cmlidXRlKCJ2aWV3Qm94IixgMCAwICR7TWF0aC5yb3VuZChBKX0gJHtNYXRoLnJvdW5kKEwpfWApLGEuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIixBKSxhLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiLEwpfWxldCBiPVAuYXR0cmlidXRlcy53aWR0aHx8TnVtYmVyKGEuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpLEU9UC5hdHRyaWJ1dGVzLmhlaWdodHx8TnVtYmVyKGEuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIpKTtpZihiKj1oLEUqPWgsaSYmUC5hdHRyaWJ1dGVzLmZsZXhpYmxlKXtjb25zdCBBPVAuYXR0cmlidXRlcy5zY2FsZVswXTtpZihiKj1BLEUqPUEsYS5zZXRBdHRyaWJ1dGUoIndpZHRoIixiKSxhLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixFKSxiJiZFJiZQLnRleHR1cmVJbWFnZSl7Y29uc3QgTD1QLnRleHR1cmVJbWFnZS53aWR0aCxTPVAudGV4dHVyZUltYWdlLmhlaWdodCxJPVAuY2xpZW50U2l6ZTtQLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9WzAsMCxNYXRoLnJvdW5kKElbMF0qTC9iKSxNYXRoLnJvdW5kKElbMV0qUy9FKV19fWVsc2UgUFtUXXx8KGEuc2V0QXR0cmlidXRlKCJ3aWR0aCIsYiksYS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsRSksUFtUXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57ZGVsZXRlIFBbVF07Y29uc3QgQT11LmlubmVySFRNTCxMPW5ldyBCbG9iKFtBXSx7dHlwZToiaW1hZ2Uvc3ZnK3htbCJ9KSxTPVVSTC5jcmVhdGVPYmplY3RVUkwoTCksST1uZXcgSW1hZ2U7SS5vbmxvYWQ9ZnVuY3Rpb24oKXtJLndpZHRoJiZJLmhlaWdodD8oUC5hdHRyaWJ1dGVzW3ldKCJ0ZXh0dXJlIixJKSxQLmF0dHJpYnV0ZXMuZmxleGlibGUmJihQLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9bnVsbCkpOlAuYXR0cmlidXRlc1t5XSgidGV4dHVyZSIsbnVsbCl9LEkuc3JjPVN9KSl9fWNsYXNzIHYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoaT17fSl7dHlwZW9mIGk9PSJzdHJpbmciJiYoaT17c3ZnVGV4dDppfSk7bGV0e3N2Z1RleHQ6dX09aSxhPW8oaSxbInN2Z1RleHQiXSk7aWYoc3VwZXIoYSksdGhpc1ttXT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSx1KXt0aGlzW21dLmlubmVySFRNTD11O2NvbnN0IGg9dGhpc1ttXS5jaGlsZHJlblswXTtoP2guc2V0QXR0cmlidXRlKCJ4bWxucyIsZyk6KGZldGNoKHUpLnRoZW4oYj0+Yi50ZXh0KCkpLnRoZW4oYj0+e3RoaXNbbV0uaW5uZXJIVE1MPWIsKCF0aGlzLm9ic2VydmVyfHx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUpJiZPKHRoaXMpfSksdT1udWxsKX1pZighdSl7Y29uc3QgaD1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZywic3ZnIik7aC5zZXRBdHRyaWJ1dGUoInhtbG5zIixnKSx0aGlzW21dLmFwcGVuZENoaWxkKGgpfWlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPT0iZnVuY3Rpb24iKXtjb25zdCBoPW5ldyBNdXRhdGlvbk9ic2VydmVyKGI9PntPKHRoaXMsITEpfSk7aC5vYnNlcnZlKHRoaXNbbV0se2F0dHJpYnV0ZXM6ITAsc3VidHJlZTohMCxjaGFyYWN0ZXJEYXRhOiEwLGNoaWxkTGlzdDohMH0pLHRoaXMub2JzZXJ2ZXI9aH19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgY2hpbGROb2Rlcygpe3JldHVyblt0aGlzLnN2Z119Z2V0IHN2Zygpe3JldHVybiB0aGlzW21dP3RoaXNbbV0uY2hpbGRyZW5bMF06bnVsbH1zZXRSZXNvbHV0aW9uKHt3aWR0aDppLGhlaWdodDp1fSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6aSxoZWlnaHQ6dX0pLE8odGhpcyl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoaSl7Y29uc3QgdT1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChpKTtpZih1JiZ0aGlzLmF0dHJpYnV0ZXMucGFzc0V2ZW50cyYmdHlwZW9mIE1vdXNlRXZlbnQ9PSJmdW5jdGlvbiIpe2NvbnN0e3g6YSx5Omh9PWk7bGV0W2IsRV09dGhpcy5nZXRPZmZzZXRQb3NpdGlvbihhLGgpO2NvbnN0IEE9aS5vcmlnaW5hbEV2ZW50LEw9dGhpcy5hdHRyaWJ1dGVzLmFuY2hvcixTPXRoaXMuY2xpZW50U2l6ZTtiPShiK0xbMF0qU1swXSkvMixFPShFK0xbMV0qU1sxXSkvMjtjb25zdCBJPWkudHlwZTtpZihJPT09QS50eXBlKXtsZXQgRD1udWxsO2lmKEEgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KUQ9bmV3IE1vdXNlRXZlbnQoSSx7c2NyZWVuWDpiLHNjcmVlblk6RSxjbGllbnRYOmIsY2xpZW50WTpFLGJ1YmJsZXM6QS5idWJibGVzLGJ1dHRvbjpBLmJ1dHRvbixidXR0b25zOkEuYnV0dG9ucyxjYW5jZWxCdWJibGU6QS5jYW5jZWxCdWJibGUsY2FuY2VsYWJsZTpBLmNhbmNlbGFibGUsY3VycmVudFRhcmdldDpBLmN1cnJlbnRUYXJnZXQsZnJvbUVsZW1lbnQ6QS5mcm9tRWxlbWVudCxyZWxhdGVkVGFyZ2V0OkEucmVsYXRlZFRhcmdldCxyZXR1cm5WYWx1ZTpBLnJldHVyblZhbHVlLHNyY0VsZW1lbnQ6QS5zcmNFbGVtZW50LHRhcmdldDpBLnRhcmdldCx0b0VsZW1lbnQ6QS50b0VsZW1lbnQsd2hpY2g6QS53aXRjaH0pO2Vsc2UgaWYoQSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpe2xldCBSPW51bGw7Y29uc3QgQz1BLmNoYW5nZWRUb3VjaGVzfHxbQV07Zm9yKGxldCBqPTA7ajxDLmxlbmd0aDtqKyspe2NvbnN0ICQ9Q1tqXTtpZihpLmlkZW50aWZpZXI9PT0kLmlkZW50aWZpZXIpe1I9JDticmVha319aWYoUil7Y29uc3Qgaj1uZXcgVG91Y2goe2lkZW50aWZpZXI6Ui5pZGVudGlmaWVyLHRhcmdldDpSLnRhcmdldCxjbGllbnRYOmIsY2xpZW50WTpFLHNjcmVlblg6YixzY3JlZW5ZOkUscGFnZVg6YixwYWdlWTpFLHJhZGl1c1g6Ui5yYWRpdXNYLHJhZGl1c1k6Ui5yYWRpdXNZLHJvdGF0aW9uQW5nbGU6Ui5yb3RhdGlvbkFuZ2xlLGZvcmNlOlIuZm9yY2V9KTtEPW5ldyBUb3VjaEV2ZW50KEkse2NhbmNlbGFibGU6QS5jYW5jZWxhYmxlLGJ1YmJsZXM6QS5idWJibGVzLGNvbXBvc2VkOkEuY29tcG9zZWQsdG91Y2hlczpbal0sdGFyZ2V0VG91Y2hlczpbal0sY2hhbmdlZFRvdWNoZXM6W2pdfSl9fWVsc2UgRD1BO0QmJnRoaXMuc3ZnLmRpc3BhdGNoRXZlbnQoRCl9fXJldHVybiB1fWdldEVsZW1lbnRCeUlkKGkpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yKShgIyR7aX1gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUoaSl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtpfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUoaSl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtpfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShpKXtyZXR1cm4gT2JqZWN0KGwucXVlcnlTZWxlY3RvckFsbCkoaSx0aGlzKX1xdWVyeVNlbGVjdG9yKGkpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yKShpLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoaSl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKGksdGhpcyl9b25Qcm9wZXJ0eUNoYW5nZShpLHUsYSl7c3VwZXIub25Qcm9wZXJ0eUNoYW5nZShpLHUsYSksaT09PSJmbGV4aWJsZSImJk8odGhpcyksdGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYoaT09PSJ3aWR0aCJ8fGk9PT0iaGVpZ2h0Inx8aT09PSJzY2FsZSJ8fGk9PT0idHJhbnNmb3JtIikmJk8odGhpcyl9fXgodiwiQXR0ciIsbi5kZWZhdWx0KSxzLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHYsInNwcml0ZXN2ZyIpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBuPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iik7Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW2xdKHtwYXNzRXZlbnRzOiExLGZsZXhpYmxlOiExfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tuXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe31nZXQgcGFzc0V2ZW50cygpe3JldHVybiB0aGlzW25dKCJwYXNzRXZlbnRzIil9c2V0IHBhc3NFdmVudHMoZil7cmV0dXJuIHRoaXNbc10oInBhc3NFdmVudHMiLGYpfWdldCBmbGV4aWJsZSgpe3JldHVybiB0aGlzW25dKCJmbGV4aWJsZSIpfXNldCBmbGV4aWJsZShmKXtyZXR1cm4gdGhpc1tzXSgiZmxleGlibGUiLGYpfX19LGZ1bmN0aW9uKGQsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oZix4KXt2YXIgZz1PYmplY3Qua2V5cyhmKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgeT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGYpO3gmJih5PXkuZmlsdGVyKGZ1bmN0aW9uKG0pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGYsbSkuZW51bWVyYWJsZX0pKSxnLnB1c2guYXBwbHkoZyx5KX1yZXR1cm4gZ31mdW5jdGlvbiBzKGYpe2Zvcih2YXIgeD0xO3g8YXJndW1lbnRzLmxlbmd0aDt4Kyspe3ZhciBnPWFyZ3VtZW50c1t4XSE9bnVsbD9hcmd1bWVudHNbeF06e307eCUyP24oT2JqZWN0KGcpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHkpe2woZix5LGdbeV0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhnKSk6bihPYmplY3QoZykpLmZvckVhY2goZnVuY3Rpb24oeSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGYseSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGcseSkpfSl9cmV0dXJuIGZ9ZnVuY3Rpb24gbChmLHgsZyl7cmV0dXJuIHggaW4gZj9PYmplY3QuZGVmaW5lUHJvcGVydHkoZix4LHt2YWx1ZTpnLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Zlt4XT1nLGZ9Y29uc3QgYz1TeW1ib2woImluaXRlZCIpO2xldCBvPW51bGw7dHlwZW9mIFdvcmtlcj09ImZ1bmN0aW9uIiYmKG89Y2xhc3MgZXh0ZW5kcyBXb3JrZXJ7Y29uc3RydWN0b3IoZil7aWYoZi53b3JrZXI9PT0hMCYmKGYud29ya2VyPWAuLyR7Zi5pZH0ud29ya2VyLmpzYCksc3VwZXIoZi53b3JrZXIpLHRoaXMub3B0aW9ucz1mLCFmLmNhbnZhcyl7Y29uc3R7d2lkdGg6eCxoZWlnaHQ6Z309dGhpcy5nZXRSZXNvbHV0aW9uKCkseT1yLkVOVi5jcmVhdGVDYW52YXMoeCxnLHtvZmZzY3JlZW46ITF9KTt5LnN0eWxlJiYoeS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSx5LmRhdGFzZXQmJih5LmRhdGFzZXQubGF5ZXJJZD1mLmlkKSxmLmNhbnZhcz15fXRoaXMuY2FudmFzPWYuY2FudmFzfWdldCBpZCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaWR9c2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6eH0pe2lmKHRoaXNbY10pdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToicmVzb2x1dGlvbl9jaGFuZ2UiLHdpZHRoOmYsaGVpZ2h0Onh9KTtlbHNle3RoaXMuY2FudmFzLndpZHRoPWYsdGhpcy5jYW52YXMuaGVpZ2h0PXg7Y29uc3QgZz10aGlzLm9wdGlvbnMseT1nLmNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpLG09cyh7fSxnKTtkZWxldGUgbS5jb250YWluZXIsbS5jYW52YXM9eSx0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJjcmVhdGUiLG9wdGlvbnM6bX0sW3ldKSx0aGlzW2NdPSEwfX1nZXRSZXNvbHV0aW9uKCl7aWYodGhpcy5jYW52YXMpe2NvbnN0e3dpZHRoOmYsaGVpZ2h0Onh9PXRoaXMuY2FudmFzO3JldHVybnt3aWR0aDpmLGhlaWdodDp4fX1yZXR1cm57d2lkdGg6MzAwLGhlaWdodDoxNTB9fXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1jb25uZWN0KGYseCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOmYsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOngsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9ZGlzY29ubmVjdCgpe2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXJ9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoZil7dGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiZXZlbnQiLGV2ZW50OntjYW5jZWxCdWJibGU6Zi5jYW5jZWxCdWJibGUsYnViYmxlczpmLmJ1YmJsZXMsZGV0YWlsOmYuZGV0YWlsLGlkZW50aWZpZXI6Zi5pZGVudGlmaWVyLGxheWVyWDpmLmxheWVyWCxsYXllclk6Zi5sYXllclksb3JpZ2luYWxYOmYub3JpZ2luYWxYLG9yaWdpbmFsWTpmLm9yaWdpbmFsWSx0eXBlOmYudHlwZSx4OmYueCx5OmYueX19KX19KSxlLmRlZmF1bHQ9b30sZnVuY3Rpb24oZCxlLHQpe3QucihlKSwoZnVuY3Rpb24ocil7dC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KTt2YXIgbj10KDEyKSxzPXQoNjgpLGw9dCg3MCksYz10KDI4Niksbz10KDI4OSksZj10KDI1MCkseD10KDI5MSksZz10KDIxNCkseT10KDIxOCksbT10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFQ9U3ltYm9sKCJlbnRlcmVkVGFyZ2V0cyIpO2Z1bmN0aW9uIE8oRSl7cmV0dXJuIEUuaWQ9RS5pZHx8YF9sYXllciR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwxMil9YCxFLmRhdGFzZXR8fChFLmRhdGFzZXQ9e30pLEUuZGF0YXNldC5sYXllcklkPUUuaWQsRS5jb25uZWN0PShBLEwpPT57RS5wYXJlbnQ9QSxPYmplY3QuZGVmaW5lUHJvcGVydHkoRSwiek9yZGVyIix7dmFsdWU6TCx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX0sRS5kaXNjb25uZWN0PUE9PntkZWxldGUgRS56T3JkZXJ9LEUuY2FudmFzPUUsRS5nZXRSZXNvbHV0aW9uPSgpPT4oe3dpZHRoOjAsaGVpZ2h0OjB9KSxFLnNldFJlc29sdXRpb249KCk9PiExLEUub3B0aW9ucz17aGFuZGxlRXZlbnQ6ITF9LEV9ZnVuY3Rpb24gdihFLEEpe2NvbnN0IEw9RS5jaGlsZHJlbjtsZXQgUz1udWxsO2ZvcihsZXQgST0wO0k8TC5sZW5ndGg7SSsrKXtjb25zdCBEPUxbSV07aWYoKEE9PT1EfHxTIT1udWxsKSYmKFM9RCksUyYmUyE9PUEmJiFTLm9mZnNjcmVlbilyZXR1cm4gUy5jYW52YXN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gUChFLEEpe2NvbnN0W0wsU109RS5yZW5kZXJPZmZzZXQse3dpZHRoOkksaGVpZ2h0OkR9PUUuZ2V0UmVzb2x1dGlvbigpLFI9RS5kaXNwbGF5UmF0aW87RS5yZW5kZXJlci5kcmF3SW1hZ2UoQS5jYW52YXMsLUwvUiwtUy9SLEkvUixEL1IpfWNvbnN0IGk9e307ZnVuY3Rpb24gdShFKXtjb25zdCBBPVsibW91c2Vkb3duIiwibW91c2V1cCIsIm1vdXNlbW92ZSIsIm1vdXNld2hlZWwiLCJ3aGVlbCIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoY2FuY2VsIiwiY2xpY2siLCJkYmxjbGljayIsImxvbmdwcmVzcyIsInRhcCIsImNvbnRleHRtZW51Il0sTD1FLmNvbnRhaW5lcjtMLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLFM9Pntjb25zdCBJPUVbVF07aWYoSS5zaXplKXtjb25zdCBEPW5ldyBnLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTtELnNldE9yaWdpbmFsRXZlbnQoUyksWy4uLkldLmZvckVhY2goUj0+e1IuZGlzcGF0Y2hFdmVudChEKX0pLEVbVF0uY2xlYXIoKX19LHtwYXNzaXZlOiEwfSksQS5mb3JFYWNoKFM9PntMLmFkZEV2ZW50TGlzdGVuZXIoUyxJPT57Y29uc3R7bGVmdDpELHRvcDpSLGRpc3BsYXlSYXRpbzpDfT1FLm9wdGlvbnMsaj1FLm9yZGVyZWRDaGlsZHJlbjtPYmplY3QoeC5kZWZhdWx0KShJLHtvZmZzZXRMZWZ0OkQsb2Zmc2V0VG9wOlIsZGlzcGxheVJhdGlvOkN9KS5mb3JFYWNoKEg9Pntjb25zdCBKPUguaWRlbnRpZmllcjtpZihILnR5cGU9PT0idG91Y2htb3ZlInx8SC50eXBlPT09InRvdWNoZW5kIil7Y29uc3QgRj1pW0pdO0YmJkYuZGlzcGF0Y2hFdmVudChIKSxILnR5cGU9PT0idG91Y2hlbmQiJiZkZWxldGUgaVtKXX1lbHNle2ZvcihsZXQgRj1qLmxlbmd0aC0xO0Y+PTA7Ri0tKXtjb25zdCBHPWpbRl07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe2lmKEcuZGlzcGF0Y2hQb2ludGVyRXZlbnQoSCkmJkgudGFyZ2V0IT09RylicmVhaztILmNhbmNlbEJ1YmJsZT0hMX19aWYoSC50YXJnZXQ9PT1qWzBdKWZvcihsZXQgRj1qLmxlbmd0aC0xO0Y+PTA7Ri0tKXtjb25zdCBHPWpbRl07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe0gudGFyZ2V0PUc7YnJlYWt9fX1jb25zdCBxPUgudGFyZ2V0O2lmKEgudHlwZT09PSJ0b3VjaHN0YXJ0IiYmKGlbSl09SC50YXJnZXQpLEgudHlwZT09PSJtb3VzZW1vdmUiKXtjb25zdCBGPUVbVF07bGV0IEc7aWYocSl7Y29uc3QgZXQ9cS5hbmNlc3RvcnN8fFtdO0c9bmV3IFNldChbcSwuLi5ldF0pfWVsc2UgRz1uZXcgU2V0O2NvbnN0IFo9T2JqZWN0LmVudHJpZXMoSSk7aWYoIUYuaGFzKHEpJiZxKXtjb25zdCBldD1uZXcgZy5kZWZhdWx0KCJtb3VzZWVudGVyIik7ZXQuc2V0T3JpZ2luYWxFdmVudChJKSxaLmZvckVhY2goKFtrLGh0XSk9PntldFtrXT1odH0pLEYuYWRkKHEpLHEuZGlzcGF0Y2hFdmVudChldCk7Y29uc3QgaXQ9cS5hbmNlc3RvcnM7aXQmJml0LmZvckVhY2goaz0+e2sgaW5zdGFuY2VvZiBsLmRlZmF1bHQmJiFGLmhhcyhrKSYmKEYuYWRkKGspLGsuZGlzcGF0Y2hFdmVudChldCkpfSl9Y29uc3QgdHQ9bmV3IGcuZGVmYXVsdCgibW91c2VsZWF2ZSIpO3R0LnNldE9yaWdpbmFsRXZlbnQoSSksWi5mb3JFYWNoKChbZXQsaXRdKT0+e3R0W2V0XT1pdH0pLFsuLi5GXS5mb3JFYWNoKGV0PT57Ry5oYXMoZXQpfHwoRi5kZWxldGUoZXQpLGV0LmRpc3BhdGNoRXZlbnQodHQpKX0pfX0pfSx7cGFzc2l2ZTpTIT09ImNvbnRleHRtZW51In0pfSl9ZnVuY3Rpb24gYShFLEEpe2lmKEEmJkEuc3R5bGUpe2xldHt3aWR0aDpMLGhlaWdodDpTLG1vZGU6SSxjb250YWluZXI6RH09RTtjb25zdHtjbGllbnRXaWR0aDpSLGNsaWVudEhlaWdodDpDfT1EO0w9THx8UixTPVN8fEMsST09PSJzdGF0aWMiPyhBLnN0eWxlLndpZHRoPWAke0x9cHhgLEEuc3R5bGUuaGVpZ2h0PWAke1N9cHhgKTooQS5zdHlsZS50b3A9IjAiLEEuc3R5bGUubGVmdD0iMCIsQS5zdHlsZS53aWR0aD1gJHtSfXB4YCxBLnN0eWxlLmhlaWdodD1gJHtDfXB4YCxBLnN0eWxlLnRyYW5zZm9ybT0iIixBLnN0eWxlLndlYmtpdFRyYW5zZm9ybT0iIil9fWNvbnN0IGg9U3ltYm9sKCJvZmZzY3JlZW5MYXllckNvdW50Iik7Y2xhc3MgYiBleHRlbmRzIGYuZGVmYXVsdHtjb25zdHJ1Y3RvcihBPXt9KXtpZihzdXBlcigpLCFBLmNvbnRhaW5lcilpZih0eXBlb2Ygbi5FTlYuQ29udGFpbmVyPT0iZnVuY3Rpb24iKUEuY29udGFpbmVyPW5ldyBuLkVOVi5Db250YWluZXIoQS53aWR0aHx8MzAwLEEuaGVpZ2h0fHwxNTApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJObyBjb250YWluZXIgc3BlY2lmaWVkLiIpO2lmKHRoaXMuY29udGFpbmVyPUEuY29udGFpbmVyLHRoaXMuY29udGFpbmVyLnN0eWxlJiYodGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3d8fCh0aGlzLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIiksdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb258fCh0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiKSksdGhpcy5vcHRpb25zPUEsQS5kaXNwbGF5UmF0aW89QS5kaXNwbGF5UmF0aW98fDEsQS5tb2RlPUEubW9kZXx8InNjYWxlIixBLmxlZnQ9MCxBLnRvcD0wLEEuYXV0b1Jlc2l6ZT1BLmF1dG9SZXNpemUhPT0hMSxBLmF1dG9SZXNpemUpe2xldCBMO2lmKHR5cGVvZiBnbG9iYWxUaGlzPCJ1Ij9MPWdsb2JhbFRoaXM6TD10eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6cixMLmFkZEV2ZW50TGlzdGVuZXIpe2NvbnN0IFM9dGhpcztMLmFkZEV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsZnVuY3Rpb24gSSgpe3R5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmNvbnRhaW5zKFMuY29udGFpbmVyKT9TLnJlc2l6ZSgpOkwucmVtb3ZlRXZlbnRMaXN0ZW5lcigicmVzaXplIixJKX0pfX10aGlzW1RdPW5ldyBTZXQsdGhpcy5zZXRSZXNvbHV0aW9uKEEpLHUodGhpcyksdGhpc1toXT0wfWdldCBoYXNPZmZzY3JlZW5DYW52YXMoKXtyZXR1cm4gdGhpc1toXT4wfXNldCBkaXNwbGF5UmF0aW8oQSl7dGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpbyE9PUEmJih0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvPUEsdGhpcy5yZXNpemUoKSl9Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvfXNldCBoZWlnaHQoQSl7dGhpcy5vcHRpb25zLmhlaWdodCE9PUEmJih0aGlzLm9wdGlvbnMuaGVpZ2h0PUEsdGhpcy5yZXNpemUoKSl9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaGVpZ2h0fXNldCBtb2RlKEEpe3RoaXMub3B0aW9ucy5tb2RlIT09QSYmKHRoaXMub3B0aW9ucy5tb2RlPUEsdGhpcy5yZXNpemUoKSl9Z2V0IG1vZGUoKXtyZXR1cm4gdGhpcy5vcHRpb25zLm1vZGV9c2V0IHdpZHRoKEEpe3RoaXMub3B0aW9ucy53aWR0aCE9PUEmJih0aGlzLm9wdGlvbnMud2lkdGg9QSx0aGlzLnJlc2l6ZSgpKX1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy5vcHRpb25zLndpZHRofWFwcGVuZENoaWxkKEEpeyEoQSBpbnN0YW5jZW9mIGMuZGVmYXVsdCkmJiEoQSBpbnN0YW5jZW9mIG8uZGVmYXVsdCkmJk8oQSk7Y29uc3QgTD1zdXBlci5hcHBlbmRDaGlsZChBKSxTPUEuY2FudmFzO3JldHVybiBBLm9mZnNjcmVlbj90aGlzW2hdKys6dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoUyksYSh0aGlzLm9wdGlvbnMsUyksQS5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxMfWZvcmNlVXBkYXRlKCl7dGhpcy5oYXNPZmZzY3JlZW5DYW52YXMmJiF0aGlzLl9yZXF1ZXN0SUQmJih0aGlzLl9yZXF1ZXN0SUQ9T2JqZWN0KHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSgoKT0+e2RlbGV0ZSB0aGlzLl9yZXF1ZXN0SUQsdGhpcy5yZW5kZXIoKX0pKX1pbnNlcnRCZWZvcmUoQSxMKXshKEEgaW5zdGFuY2VvZiBjLmRlZmF1bHQpJiYhKEEgaW5zdGFuY2VvZiBvLmRlZmF1bHQpJiZPKEEpO2NvbnN0IFM9c3VwZXIuaW5zZXJ0QmVmb3JlKEEsTCksST1BLmNhbnZhcztpZighQS5vZmZzY3JlZW4pe2NvbnN0IEQ9dih0aGlzLEEpO3RoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShJLEQpfXJldHVybiBhKHRoaXMub3B0aW9ucyxJKSxBLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLFN9bGF5ZXIoQT0iZGVmYXVsdCIsTD17fSl7TD1PYmplY3QuYXNzaWduKHt9LHRoaXMub3B0aW9ucyxMKSxMLmlkPUE7Y29uc3QgUz10aGlzLm9yZGVyZWRDaGlsZHJlbjtmb3IobGV0IFI9MDtSPFMubGVuZ3RoO1IrKylpZihTW1JdLmlkPT09QSlyZXR1cm4gU1tSXTtjb25zdCBJPUwud29ya2VyO2xldCBEO3JldHVybiBJP0Q9bmV3IG8uZGVmYXVsdChMKTpEPW5ldyBjLmRlZmF1bHQoTCksdGhpcy5hcHBlbmRDaGlsZChEKSxEfWFzeW5jIHByZWxvYWQoLi4uQSl7Y29uc3QgTD1bXSxTPVtdLEk9W107Zm9yKGxldCBEPTA7RDxBLmxlbmd0aDtEKyspe2NvbnN0IFI9QVtEXTtsZXQgQztpZih0eXBlb2YgUj09InN0cmluZyIpQz1PYmplY3QoeS5sb2FkVGV4dHVyZSkoUik7ZWxzZSBpZihBcnJheS5pc0FycmF5KFIpKUM9T2JqZWN0KHkubG9hZEZyYW1lcykoLi4uUik7ZWxzZXtjb25zdHtpZDpqLHNyYzokfT1SO0M9T2JqZWN0KHkubG9hZFRleHR1cmUpKCQsail9QyBpbnN0YW5jZW9mIFByb21pc2V8fChDPVByb21pc2UucmVzb2x2ZShDKSksUy5wdXNoKEMudGhlbihqPT57TC5wdXNoKGopLElbRF09ajtjb25zdCAkPW5ldyBnLmRlZmF1bHQoe3R5cGU6InByZWxvYWQiLGRldGFpbDp7Y3VycmVudDpqLGxvYWRlZDpMLHJlc291cmNlczpBfX0pO3RoaXMuZGlzcGF0Y2hFdmVudCgkKX0pKX1yZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoUyksSX1yZW1vdmVDaGlsZChBKXtjb25zdCBMPXN1cGVyLnJlbW92ZUNoaWxkKEEpO2lmKEwpe0EuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCYmQS5fcHJlcGFyZVJlbmRlckZpbmlzaGVkKCk7Y29uc3QgUz1BLmNhbnZhcztTJiZTLnJlbW92ZSYmUy5yZW1vdmUoKSxBLm9mZnNjcmVlbiYmdGhpc1toXS0tfXJldHVybiBMfXJlbmRlcigpe2NvbnN0IEE9dGhpcy5vcmRlcmVkQ2hpbGRyZW47bGV0IEw9bnVsbDtjb25zdCBTPVtdO2ZvcihsZXQgST0wO0k8QS5sZW5ndGg7SSsrKXtjb25zdCBEPUFbSV0sUj1TLmxlbmd0aD4wO2lmKEQgaW5zdGFuY2VvZiBjLmRlZmF1bHQmJiFELm9mZnNjcmVlbilpZighRC5hdXRvUmVuZGVyKVImJihjb25zb2xlLndhcm4oIlNvbWUgb2Zmc2NyZWVuIGNhbnZhcyB3aWxsIG5vdCBiZSByZW5kZXJlZC4iKSxTLmxlbmd0aD0wKTtlbHNlIGlmKEw9RCxSKXtELnJlbmRlcmVyLmNsZWFyKCk7Zm9yKGxldCBDPTA7QzxTLmxlbmd0aDtDKyspe2NvbnN0IGo9U1tDXTtqLnJlbmRlcigpLFAoRCxqKX1TLmxlbmd0aD0wLEQucmVuZGVyKHtjbGVhcjohMX0pfWVsc2UgRC5wcmVwYXJlUmVuZGVyJiZELnJlbmRlcigpO2Vsc2UgRC5vZmZzY3JlZW4/TD8oRC5wcmVwYXJlUmVuZGVyJiZELnJlbmRlcigpLFAoTCxEKSk6Uy5wdXNoKEQpOkQgaW5zdGFuY2VvZiBvLmRlZmF1bHQmJlImJihjb25zb2xlLndhcm4oIlNvbWUgb2Zmc2NyZWVuIGNhbnZhcyB3aWxsIG5vdCBiZSByZW5kZXJlZC4iKSxTLmxlbmd0aD0wKX19cmVwbGFjZUNoaWxkKEEsTCl7Y29uc3QgUz1zdXBlci5yZXBsYWNlQ2hpbGQoQSxMKTtMLmNhbnZhcy5yZW1vdmUmJkwuY2FudmFzLnJlbW92ZSgpLEwub2Zmc2NyZWVuJiZ0aGlzW2hdLS07Y29uc3QgST1BLmNhbnZhcztpZighQS5vZmZzY3JlZW4pe2NvbnN0IEQ9dih0aGlzLEEpO3RoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShJLEQpfXJldHVybiBhKHRoaXMub3B0aW9ucyxJKSxBLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLFN9cmVzaXplKCl7Y29uc3QgQT10aGlzLm9wdGlvbnM7dGhpcy5jaGlsZHJlbi5mb3JFYWNoKEw9PnthKEEsTC5jYW52YXMpfSksdGhpcy5zZXRSZXNvbHV0aW9uKEEpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzaXplIn0pfXNldFJlc29sdXRpb24oe3dpZHRoOkEsaGVpZ2h0Okx9PXt9KXtjb25zdCBTPXRoaXMuY29udGFpbmVyLHtjbGllbnRXaWR0aDpJLGNsaWVudEhlaWdodDpEfT1TOyhBPT1udWxsfHxMPT1udWxsKSYmKEE9QT8/SSxMPUw/P0QpO2NvbnN0e21vZGU6UixkaXNwbGF5UmF0aW86Q309dGhpcy5vcHRpb25zO2lmKEEqPUMsTCo9Qyx0aGlzLm9wdGlvbnMubGVmdD0wLHRoaXMub3B0aW9ucy50b3A9MCxSPT09InN0aWNreUhlaWdodCJ8fFI9PT0ic3RpY2t5TGVmdCJ8fFI9PT0ic3RpY2t5UmlnaHQiKXtjb25zdCBqPUE7QT1JKkwvRCxSPT09InN0aWNreUhlaWdodCImJih0aGlzLm9wdGlvbnMubGVmdD0uNSooQS1qKSksUj09PSJzdGlja3lSaWdodCImJih0aGlzLm9wdGlvbnMubGVmdD1BLWopfWVsc2UgaWYoUj09PSJzdGlja3lXaWR0aCJ8fFI9PT0ic3RpY2t5VG9wInx8Uj09PSJzdGlja3lCb3R0b20iKXtjb25zdCBqPUw7TD1EKkEvSSxSPT09InN0aWNreVdpZHRoIiYmKHRoaXMub3B0aW9ucy50b3A9LjUqKEwtaikpLFI9PT0ic3RpY2t5Qm90dG9tIiYmKHRoaXMub3B0aW9ucy50b3A9TC1qKX1zdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpBLGhlaWdodDpMfSl9c25hcHNob3Qoe29mZnNjcmVlbjpBPSExLGxheWVyczpMfT17fSl7Y29uc3QgUz1BPyJzbmFwc2hvdE9mZlNjcmVlbkNhbnZhcyI6InNuYXBzaG90Q2FudmFzIix7d2lkdGg6SSxoZWlnaHQ6RH09dGhpcy5nZXRSZXNvbHV0aW9uKCk7dGhpc1tTXT10aGlzW1NdfHxuLkVOVi5jcmVhdGVDYW52YXMoSSxELHtvZmZzY3JlZW46QX0pO2NvbnN0IFI9dGhpc1tTXS5nZXRDb250ZXh0KCIyZCIpO0w9THx8dGhpcy5vcmRlcmVkQ2hpbGRyZW4sdGhpc1tTXS53aWR0aD1JLHRoaXNbU10uaGVpZ2h0PUQ7Zm9yKGxldCBDPTA7QzxMLmxlbmd0aDtDKyspe2NvbnN0IGo9TFtDXTtpZighai5vcHRpb25zLmlnbm9yZVNuYXBzaG90KXtqLnJlbmRlciYmai5yZW5kZXIoKTtjb25zdCAkPWouY2FudmFzOyQmJiQhPT1qJiZSLmRyYXdJbWFnZSgkLDAsMCxJLEQpfX1yZXR1cm4gdGhpc1tTXX19dHlwZW9mIGRvY3VtZW50PCJ1IiYmKGIucHJvdG90eXBlLmxheWVyM2Q9ZnVuY3Rpb24oRSxBPXt9KXtjb25zdCBMPUEudXJsfHwiaHR0cHM6Ly91bnBrZy5jb20vc3ByaXRlLWV4dGVuZC0zZC9kaXN0L3Nwcml0ZS1leHRlbmQtM2QubWluLmpzIjtyZXR1cm4gbmV3IFByb21pc2UoKFMsSSk9Pntjb25zdCBEPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpO0QuYXN5bmM9ITEsRC5zcmM9TCxELm9ubG9hZD0oKT0+e3RyeXtTKHRoaXMubGF5ZXIzZChFLEEpKX1jYXRjaChSKXtJKFIpfX0sZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKEQpfSl9KSxtLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsInNjZW5lIil9KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihkLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIHI9dCgyMTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHMse29mZnNldFRvcDpsPTAsb2Zmc2V0TGVmdDpjPTAsZGlzcGxheVJhdGlvOm89MX09e30pe2xldCBmLHg7Y29uc3QgZz1bXSx7bGVmdDp5LHRvcDptLHdpZHRoOlQsaGVpZ2h0Ok99PXMudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHY9cy50YXJnZXQud2lkdGgsUD1zLnRhcmdldC5oZWlnaHQsaT1zLmNoYW5nZWRUb3VjaGVzfHxbc107Zm9yKGxldCBhPTA7YTxpLmxlbmd0aDthKyspe2NvbnN0IGg9aVthXSxiPWguaWRlbnRpZmllcix7Y2xpZW50WDpFLGNsaWVudFk6QX09aDtFIT1udWxsJiZBIT1udWxsJiZnLnB1c2goe3g6TWF0aC5yb3VuZCgoRXwwKS15KSx5Ok1hdGgucm91bmQoKEF8MCktbSksaWRlbnRpZmllcjpifSl9Zy5sZW5ndGg8PTAmJmcucHVzaCh7eDpmLHk6eH0pO2NvbnN0IHU9W107cmV0dXJuIGcuZm9yRWFjaChhPT57YS54IT1udWxsJiZhLnkhPW51bGwmJihmPShhLngqdi9ULWMpL28seD0oYS55KlAvTy1sKS9vKTtjb25zdCBoPW5ldyByLmRlZmF1bHQocyk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaCx7bGF5ZXJYOnt2YWx1ZTpmLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTp4LGNvbmZpZ3VyYWJsZTohMH0sb3JpZ2luYWxYOnt2YWx1ZTphLnh9LG9yaWdpbmFsWTp7dmFsdWU6YS55fSx4Ont2YWx1ZTpmLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6eCxjb25maWd1cmFibGU6ITB9LGlkZW50aWZpZXI6e3ZhbHVlOmEuaWRlbnRpZmllcn19KSx1LnB1c2goaCl9KSx1fX1dKTtEdC52ZXJzaW9uLER0LkFyYyxEdC5CbG9jayxEdC5DbG91ZCxEdC5Db2xvcjtjb25zdCB1bj1EdC5FbGxpcHNlO0R0LkdyYWRpZW50O2NvbnN0IGVlPUR0Lkdyb3VwLFNoPUR0LkxhYmVsO0R0LkxheWVyLER0LkxheWVyV29ya2VyLER0Lk5vZGUsRHQuUGFyYWxsZWw7Y29uc3Qgc2U9RHQuUGF0aCxxdD1EdC5Qb2x5bGluZSxycj1EdC5SZWN0O0R0LlJlZ3VsYXIsRHQuUmluZztjb25zdCBNaD1EdC5TY2VuZTtEdC5TcHJpdGUsRHQuU3ByaXRlU3ZnLER0LlN0YXIsRHQuVHJpYW5nbGUsRHQuaGVscGVycyxEdC5jcmVhdGVFbGVtZW50LER0LmlzU3ByaXRlTm9kZSxEdC5yZWdpc3Rlck5vZGUsRHQucmVxdWVzdEFuaW1hdGlvbkZyYW1lLER0LmNhbmNlbEFuaW1hdGlvbkZyYW1lLER0LkVOVjtmdW5jdGlvbiBnZShkLGU9ITApe2NvbnN0IHQ9ZC5sZW5ndGg7aWYodDwyKXJldHVybiIiO2xldCByPWRbMF0sbj1kWzFdO2lmKHQ9PT0yKXJldHVybmBNJHtoZShyKX1MJHtoZShuKX1gO2xldCBzPSIiO2ZvcihsZXQgbD0yLGM9dC0xO2w8YztsKyspcj1kW2xdLG49ZFtsKzFdLHMrPWRlKHIsbik7cmV0dXJuIGU/YE0ke2RlKGRbMF0sZFsxXSl9USR7aGUoZFsxXSl9JHtkZShkWzFdLGRbMl0pfVQke3N9JHtkZShkW3QtMV0sZFswXSl9JHtkZShkWzBdLGRbMV0pfVpgOmBNJHtoZShkWzBdKX1RJHtoZShkWzFdKX0ke2RlKGRbMV0sZFsyXSl9JHtkLmxlbmd0aD4zPyJUIjoiIn0ke3N9TCR7aGUoZFt0LTFdKX1gfXZhciBucj17ZXhwb3J0czp7fX07bnIuZXhwb3J0cyxmdW5jdGlvbihkKXt2YXIgZT1mdW5jdGlvbigpe3ZhciB0PVN0cmluZy5mcm9tQ2hhckNvZGUscj0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0iLG49IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky0kIixzPXt9O2Z1bmN0aW9uIGwobyxmKXtpZighc1tvXSl7c1tvXT17fTtmb3IodmFyIHg9MDt4PG8ubGVuZ3RoO3grKylzW29dW28uY2hhckF0KHgpXT14fXJldHVybiBzW29dW2ZdfXZhciBjPXtjb21wcmVzc1RvQmFzZTY0OmZ1bmN0aW9uKG8pe2lmKG89PW51bGwpcmV0dXJuIiI7dmFyIGY9Yy5fY29tcHJlc3Mobyw2LGZ1bmN0aW9uKHgpe3JldHVybiByLmNoYXJBdCh4KX0pO3N3aXRjaChmLmxlbmd0aCU0KXtkZWZhdWx0OmNhc2UgMDpyZXR1cm4gZjtjYXNlIDE6cmV0dXJuIGYrIj09PSI7Y2FzZSAyOnJldHVybiBmKyI9PSI7Y2FzZSAzOnJldHVybiBmKyI9In19LGRlY29tcHJlc3NGcm9tQmFzZTY0OmZ1bmN0aW9uKG8pe3JldHVybiBvPT1udWxsPyIiOm89PSIiP251bGw6Yy5fZGVjb21wcmVzcyhvLmxlbmd0aCwzMixmdW5jdGlvbihmKXtyZXR1cm4gbChyLG8uY2hhckF0KGYpKX0pfSxjb21wcmVzc1RvVVRGMTY6ZnVuY3Rpb24obyl7cmV0dXJuIG89PW51bGw/IiI6Yy5fY29tcHJlc3MobywxNSxmdW5jdGlvbihmKXtyZXR1cm4gdChmKzMyKX0pKyIgIn0sZGVjb21wcmVzc0Zyb21VVEYxNjpmdW5jdGlvbihvKXtyZXR1cm4gbz09bnVsbD8iIjpvPT0iIj9udWxsOmMuX2RlY29tcHJlc3Moby5sZW5ndGgsMTYzODQsZnVuY3Rpb24oZil7cmV0dXJuIG8uY2hhckNvZGVBdChmKS0zMn0pfSxjb21wcmVzc1RvVWludDhBcnJheTpmdW5jdGlvbihvKXtmb3IodmFyIGY9Yy5jb21wcmVzcyhvKSx4PW5ldyBVaW50OEFycmF5KGYubGVuZ3RoKjIpLGc9MCx5PWYubGVuZ3RoO2c8eTtnKyspe3ZhciBtPWYuY2hhckNvZGVBdChnKTt4W2cqMl09bT4+PjgseFtnKjIrMV09bSUyNTZ9cmV0dXJuIHh9LGRlY29tcHJlc3NGcm9tVWludDhBcnJheTpmdW5jdGlvbihvKXtpZihvPT1udWxsKXJldHVybiBjLmRlY29tcHJlc3Mobyk7Zm9yKHZhciBmPW5ldyBBcnJheShvLmxlbmd0aC8yKSx4PTAsZz1mLmxlbmd0aDt4PGc7eCsrKWZbeF09b1t4KjJdKjI1NitvW3gqMisxXTt2YXIgeT1bXTtyZXR1cm4gZi5mb3JFYWNoKGZ1bmN0aW9uKG0pe3kucHVzaCh0KG0pKX0pLGMuZGVjb21wcmVzcyh5LmpvaW4oIiIpKX0sY29tcHJlc3NUb0VuY29kZWRVUklDb21wb25lbnQ6ZnVuY3Rpb24obyl7cmV0dXJuIG89PW51bGw/IiI6Yy5fY29tcHJlc3Mobyw2LGZ1bmN0aW9uKGYpe3JldHVybiBuLmNoYXJBdChmKX0pfSxkZWNvbXByZXNzRnJvbUVuY29kZWRVUklDb21wb25lbnQ6ZnVuY3Rpb24obyl7cmV0dXJuIG89PW51bGw/IiI6bz09IiI/bnVsbDoobz1vLnJlcGxhY2UoLyAvZywiKyIpLGMuX2RlY29tcHJlc3Moby5sZW5ndGgsMzIsZnVuY3Rpb24oZil7cmV0dXJuIGwobixvLmNoYXJBdChmKSl9KSl9LGNvbXByZXNzOmZ1bmN0aW9uKG8pe3JldHVybiBjLl9jb21wcmVzcyhvLDE2LGZ1bmN0aW9uKGYpe3JldHVybiB0KGYpfSl9LF9jb21wcmVzczpmdW5jdGlvbihvLGYseCl7aWYobz09bnVsbClyZXR1cm4iIjt2YXIgZyx5LG09e30sVD17fSxPPSIiLHY9IiIsUD0iIixpPTIsdT0zLGE9MixoPVtdLGI9MCxFPTAsQTtmb3IoQT0wO0E8by5sZW5ndGg7QSs9MSlpZihPPW8uY2hhckF0KEEpLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtLE8pfHwobVtPXT11KyssVFtPXT0hMCksdj1QK08sT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sdikpUD12O2Vsc2V7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFQsUCkpe2lmKFAuY2hhckNvZGVBdCgwKTwyNTYpe2ZvcihnPTA7ZzxhO2crKyliPWI8PDEsRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrO2Zvcih5PVAuY2hhckNvZGVBdCgwKSxnPTA7Zzw4O2crKyliPWI8PDF8eSYxLEU9PWYtMT8oRT0wLGgucHVzaCh4KGIpKSxiPTApOkUrKyx5PXk+PjF9ZWxzZXtmb3IoeT0xLGc9MDtnPGE7ZysrKWI9Yjw8MXx5LEU9PWYtMT8oRT0wLGgucHVzaCh4KGIpKSxiPTApOkUrKyx5PTA7Zm9yKHk9UC5jaGFyQ29kZUF0KDApLGc9MDtnPDE2O2crKyliPWI8PDF8eSYxLEU9PWYtMT8oRT0wLGgucHVzaCh4KGIpKSxiPTApOkUrKyx5PXk+PjF9aS0tLGk9PTAmJihpPU1hdGgucG93KDIsYSksYSsrKSxkZWxldGUgVFtQXX1lbHNlIGZvcih5PW1bUF0sZz0wO2c8YTtnKyspYj1iPDwxfHkmMSxFPT1mLTE/KEU9MCxoLnB1c2goeChiKSksYj0wKTpFKysseT15Pj4xO2ktLSxpPT0wJiYoaT1NYXRoLnBvdygyLGEpLGErKyksbVt2XT11KyssUD1TdHJpbmcoTyl9aWYoUCE9PSIiKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoVCxQKSl7aWYoUC5jaGFyQ29kZUF0KDApPDI1Nil7Zm9yKGc9MDtnPGE7ZysrKWI9Yjw8MSxFPT1mLTE/KEU9MCxoLnB1c2goeChiKSksYj0wKTpFKys7Zm9yKHk9UC5jaGFyQ29kZUF0KDApLGc9MDtnPDg7ZysrKWI9Yjw8MXx5JjEsRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrLHk9eT4+MX1lbHNle2Zvcih5PTEsZz0wO2c8YTtnKyspYj1iPDwxfHksRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrLHk9MDtmb3IoeT1QLmNoYXJDb2RlQXQoMCksZz0wO2c8MTY7ZysrKWI9Yjw8MXx5JjEsRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrLHk9eT4+MX1pLS0saT09MCYmKGk9TWF0aC5wb3coMixhKSxhKyspLGRlbGV0ZSBUW1BdfWVsc2UgZm9yKHk9bVtQXSxnPTA7ZzxhO2crKyliPWI8PDF8eSYxLEU9PWYtMT8oRT0wLGgucHVzaCh4KGIpKSxiPTApOkUrKyx5PXk+PjE7aS0tLGk9PTAmJihpPU1hdGgucG93KDIsYSksYSsrKX1mb3IoeT0yLGc9MDtnPGE7ZysrKWI9Yjw8MXx5JjEsRT09Zi0xPyhFPTAsaC5wdXNoKHgoYikpLGI9MCk6RSsrLHk9eT4+MTtmb3IoOzspaWYoYj1iPDwxLEU9PWYtMSl7aC5wdXNoKHgoYikpO2JyZWFrfWVsc2UgRSsrO3JldHVybiBoLmpvaW4oIiIpfSxkZWNvbXByZXNzOmZ1bmN0aW9uKG8pe3JldHVybiBvPT1udWxsPyIiOm89PSIiP251bGw6Yy5fZGVjb21wcmVzcyhvLmxlbmd0aCwzMjc2OCxmdW5jdGlvbihmKXtyZXR1cm4gby5jaGFyQ29kZUF0KGYpfSl9LF9kZWNvbXByZXNzOmZ1bmN0aW9uKG8sZix4KXt2YXIgZz1bXSx5PTQsbT00LFQ9MyxPPSIiLHY9W10sUCxpLHUsYSxoLGIsRSxBPXt2YWw6eCgwKSxwb3NpdGlvbjpmLGluZGV4OjF9O2ZvcihQPTA7UDwzO1ArPTEpZ1tQXT1QO2Zvcih1PTAsaD1NYXRoLnBvdygyLDIpLGI9MTtiIT1oOylhPUEudmFsJkEucG9zaXRpb24sQS5wb3NpdGlvbj4+PTEsQS5wb3NpdGlvbj09MCYmKEEucG9zaXRpb249ZixBLnZhbD14KEEuaW5kZXgrKykpLHV8PShhPjA/MTowKSpiLGI8PD0xO3N3aXRjaCh1KXtjYXNlIDA6Zm9yKHU9MCxoPU1hdGgucG93KDIsOCksYj0xO2IhPWg7KWE9QS52YWwmQS5wb3NpdGlvbixBLnBvc2l0aW9uPj49MSxBLnBvc2l0aW9uPT0wJiYoQS5wb3NpdGlvbj1mLEEudmFsPXgoQS5pbmRleCsrKSksdXw9KGE+MD8xOjApKmIsYjw8PTE7RT10KHUpO2JyZWFrO2Nhc2UgMTpmb3IodT0wLGg9TWF0aC5wb3coMiwxNiksYj0xO2IhPWg7KWE9QS52YWwmQS5wb3NpdGlvbixBLnBvc2l0aW9uPj49MSxBLnBvc2l0aW9uPT0wJiYoQS5wb3NpdGlvbj1mLEEudmFsPXgoQS5pbmRleCsrKSksdXw9KGE+MD8xOjApKmIsYjw8PTE7RT10KHUpO2JyZWFrO2Nhc2UgMjpyZXR1cm4iIn1mb3IoZ1szXT1FLGk9RSx2LnB1c2goRSk7Oyl7aWYoQS5pbmRleD5vKXJldHVybiIiO2Zvcih1PTAsaD1NYXRoLnBvdygyLFQpLGI9MTtiIT1oOylhPUEudmFsJkEucG9zaXRpb24sQS5wb3NpdGlvbj4+PTEsQS5wb3NpdGlvbj09MCYmKEEucG9zaXRpb249ZixBLnZhbD14KEEuaW5kZXgrKykpLHV8PShhPjA/MTowKSpiLGI8PD0xO3N3aXRjaChFPXUpe2Nhc2UgMDpmb3IodT0wLGg9TWF0aC5wb3coMiw4KSxiPTE7YiE9aDspYT1BLnZhbCZBLnBvc2l0aW9uLEEucG9zaXRpb24+Pj0xLEEucG9zaXRpb249PTAmJihBLnBvc2l0aW9uPWYsQS52YWw9eChBLmluZGV4KyspKSx1fD0oYT4wPzE6MCkqYixiPDw9MTtnW20rK109dCh1KSxFPW0tMSx5LS07YnJlYWs7Y2FzZSAxOmZvcih1PTAsaD1NYXRoLnBvdygyLDE2KSxiPTE7YiE9aDspYT1BLnZhbCZBLnBvc2l0aW9uLEEucG9zaXRpb24+Pj0xLEEucG9zaXRpb249PTAmJihBLnBvc2l0aW9uPWYsQS52YWw9eChBLmluZGV4KyspKSx1fD0oYT4wPzE6MCkqYixiPDw9MTtnW20rK109dCh1KSxFPW0tMSx5LS07YnJlYWs7Y2FzZSAyOnJldHVybiB2LmpvaW4oIiIpfWlmKHk9PTAmJih5PU1hdGgucG93KDIsVCksVCsrKSxnW0VdKU89Z1tFXTtlbHNlIGlmKEU9PT1tKU89aStpLmNoYXJBdCgwKTtlbHNlIHJldHVybiBudWxsO3YucHVzaChPKSxnW20rK109aStPLmNoYXJBdCgwKSx5LS0saT1PLHk9PTAmJih5PU1hdGgucG93KDIsVCksVCsrKX19fTtyZXR1cm4gY30oKTtkIT1udWxsP2QuZXhwb3J0cz1lOnR5cGVvZiBhbmd1bGFyPCJ1IiYmYW5ndWxhciE9bnVsbCYmYW5ndWxhci5tb2R1bGUoIkxaU3RyaW5nIixbXSkuZmFjdG9yeSgiTFpTdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIGV9KX0obnIpO3ZhciBmbj1uci5leHBvcnRzO2Z1bmN0aW9uIEJlKGQpe3JldHVybiBKU09OLnBhcnNlKGZuLmRlY29tcHJlc3MoZCkpfWZ1bmN0aW9uIGt0KGQpe3JldHVybiBmbi5jb21wcmVzcyhKU09OLnN0cmluZ2lmeShkKSl9Y2xhc3MgaG4gZXh0ZW5kcyBndHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6S3QuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZ0LlBlbmNpbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiTUFYX1JFUEVBUiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInVuaVRoaWNrbmVzcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjZW50ZXJQb3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbMCwwXX0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnVuaVRoaWNrbmVzcz10aGlzLk1BWF9SRVBFQVIvdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MvMTAsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tYmluZUNvbnN1bWUoKXt2YXIgbDtjb25zdCBlPShsPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6bC50b1N0cmluZygpLHQ9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCEwKSxyPXtuYW1lOmV9O2xldCBuO2NvbnN0IHM9dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyO3JldHVybiB0Lmxlbmd0aCYmKG49dGhpcy5kcmF3KHthdHRyczpyLHRhc2tzOnQscmVwbGFjZUlkOmUsbGF5ZXI6cyxpc0NsZWFyQWxsOiEwfSkpLHtyZWN0Om4sdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbH19c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlKXt2YXIgTztjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzQ2xlYXJBbGw6bixpc1N1YldvcmtlcjpzfT1lO2lmKCgoTz10Lm9wKT09bnVsbD92b2lkIDA6Ty5sZW5ndGgpPT09MClyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHt3b3JrSWQ6bH09dCx7dGFza3M6YyxlZmZlY3RzOm8sY29uc3VtZUluZGV4OmZ9PXRoaXMudHJhbnNmb3JtRGF0YSh0LCExKTt0aGlzLnN5bmNJbmRleD1NYXRoLm1pbih0aGlzLnN5bmNJbmRleCxmLE1hdGgubWF4KDAsdGhpcy50bXBQb2ludHMubGVuZ3RoLTIpKTtjb25zdCB4PXtuYW1lOmw9PW51bGw/dm9pZCAwOmwudG9TdHJpbmcoKX07bGV0IGcseT0hMTtjb25zdCBtPXRoaXMuc3luY0luZGV4O2lmKHRoaXMuc3luY1RpbWVzdGFtcD09PTAmJih0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKSksYy5sZW5ndGgmJihjWzBdLnRhc2tJZC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWUmJih5PSEwLHRoaXMuc3luY1RpbWVzdGFtcD1jWzBdLnRhc2tJZCx0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLHMpKXtjb25zdCB2PXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyO2c9dGhpcy5kcmF3KHthdHRyczp4LHRhc2tzOmMsZWZmZWN0czpvLGxheWVyOnYsaXNDbGVhckFsbDpufSl9aWYocylyZXR1cm4gZj4xMCYmdGhpcy50bXBQb2ludHMuc3BsaWNlKDAsZi0xMCkse3JlY3Q6Zyx0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsfTtjb25zdCBUPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZShtKS5mb3JFYWNoKHY9PntULnB1c2godi54LHYueSx0aGlzLmNvbXB1dFJhZGl1cyh2LnosdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MpKX0pLHtyZWN0OmcsdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6eT9sOnZvaWQgMCxvcDp5P1Q6dm9pZCAwLGluZGV4Onk/bSozOnZvaWQgMH19Y29uc3VtZUFsbChlKXt2YXIgZix4O2lmKGUuZGF0YSl7Y29uc3R7b3A6Zyx3b3JrU3RhdGU6eX09ZS5kYXRhO2chPW51bGwmJmcubGVuZ3RoJiZ5PT09SXQuRG9uZSYmdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09enQuU3Ryb2tlJiZ0aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShnKX1jb25zdCB0PShmPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Zi50b1N0cmluZygpO2lmKCF0KXJldHVybnt0eXBlOnV0Lk5vbmV9O2NvbnN0IHI9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCEwKSxuPXtuYW1lOnR9O2xldCBzO2NvbnN0IGw9dGhpcy5mdWxsTGF5ZXI7ci5sZW5ndGgmJihzPXRoaXMuZHJhdyh7YXR0cnM6bix0YXNrczpyLHJlcGxhY2VJZDp0LGxheWVyOmwsaXNDbGVhckFsbDohMX0pKTtjb25zdCBjPVtdO3RoaXMudG1wUG9pbnRzLm1hcChnPT57Yy5wdXNoKGcueCxnLnksdGhpcy5jb21wdXRSYWRpdXMoZy56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx0aGlzLnN5bmNUaW1lc3RhbXA9MCxkZWxldGUgdGhpcy53b3JrT3B0aW9ucy5zeW5jVW5pdFRpbWU7Y29uc3Qgbz1rdChjKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyh0LHtyZWN0OnMsb3A6YyxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cyYmZ3QuZ2V0Q2VudGVyUG9zKHMsbCl9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnQsb3BzOm8sdXBkYXRlTm9kZU9wdDp7cG9zOnRoaXMuY2VudGVyUG9zLHVzZUFuaW1hdGlvbjohMH0sb3B0OnRoaXMud29ya09wdGlvbnMsdW5kb1RpY2tlcklkOih4PWUuZGF0YSk9PW51bGw/dm9pZCAwOngudW5kb1RpY2tlcklkfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHg7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOnIscmVwbGFjZUlkOm4saXNDbGVhckFsbDpzfT1lO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgZz0wO2c8dC5sZW5ndGg7Zys9Myl7Y29uc3QgeT1uZXcgT3QodFtnXSx0W2crMV0sdFtnKzJdKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg+MCl7Y29uc3QgbT10aGlzLnRtcFBvaW50c1t0aGlzLnRtcFBvaW50cy5sZW5ndGgtMV0sVD1fLlN1Yih5LG0pLnVuaSgpO3kuc2V0dihUKX10aGlzLnRtcFBvaW50cy5wdXNoKHkpfWNvbnN0IGw9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCExKSxjPSh4PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6eC50b1N0cmluZygpLG89e25hbWU6Y307bGV0IGY7aWYoYyYmbC5sZW5ndGgpe2NvbnN0IGc9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7Zj10aGlzLmRyYXcoe2F0dHJzOm8sdGFza3M6bCxyZXBsYWNlSWQ6bixsYXllcjpnLGlzQ2xlYXJBbGw6c30pLHRoaXMudk5vZGVzLnNldEluZm8oYyx7cmVjdDpmLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmYmJmd0LmdldENlbnRlclBvcyhmLGcpfSl9cmV0dXJuIGZ9dHJhbnNmb3JtRGF0YUFsbChlPSEwKXtyZXR1cm4gdGhpcy5nZXRUYXNrUG9pbnRzKHRoaXMudG1wUG9pbnRzLGUmJnRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzfHx2b2lkIDApfWRyYXcoZSl7dmFyIGE7Y29uc3R7YXR0cnM6dCx0YXNrczpyLHJlcGxhY2VJZDpuLGVmZmVjdHM6cyxsYXllcjpsLGlzQ2xlYXJBbGw6Y309ZSx7c3Ryb2tlQ29sb3I6byxzdHJva2VUeXBlOmYsdGhpY2tuZXNzOngsekluZGV4Omcsc2NhbGU6eSxyb3RhdGU6bSx0cmFuc2xhdGU6VH09dGhpcy53b3JrT3B0aW9ucztjJiZsLnJlbW92ZUFsbENoaWxkcmVuKCksbiYmKHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKG4rIiIpLm1hcChoPT5oLnJlbW92ZSgpKSwoYT10aGlzLmRyYXdMYXllcik9PW51bGx8fGEuZ2V0RWxlbWVudHNCeU5hbWUobisiIikubWFwKGg9PmgucmVtb3ZlKCkpKSxzIT1udWxsJiZzLnNpemUmJihzLmZvckVhY2goaD0+e3ZhciBiOyhiPWwuZ2V0RWxlbWVudEJ5SWQoaCsiIikpPT1udWxsfHxiLnJlbW92ZSgpfSkscy5jbGVhcigpKTtsZXQgTztjb25zdCB2PVtdLFA9bC53b3JsZFBvc2l0aW9uLGk9bC53b3JsZFNjYWxpbmc7Zm9yKGxldCBoPTA7aDxyLmxlbmd0aDtoKyspe2NvbnN0e3BvczpiLHBvaW50czpFLHRhc2tJZDpBfT1yW2hdO3QuaWQ9QS50b1N0cmluZygpO2NvbnN0e3BzOkwscmVjdDpTfT10aGlzLmNvbXB1dERyYXdQb2ludHMoRSk7bGV0IEk7Y29uc3QgRD1FLmxlbmd0aD09PTE7Zj09PXp0LlN0cm9rZXx8RD9JPWdlKEwsITApOkk9Z2UoTCwhMSk7Y29uc3QgUj17cG9zOmIsZDpJLGZpbGxDb2xvcjpmPT09enQuU3Ryb2tlfHxEP286dm9pZCAwLGxpbmVEYXNoOmY9PT16dC5Eb3R0ZWQmJiFEP1sxLHgqMl06Zj09PXp0LkxvbmdEb3R0ZWQmJiFEP1t4LHgqMl06dm9pZCAwLHN0cm9rZUNvbG9yOm8sbGluZUNhcDpmPT09enQuU3Ryb2tlfHxEP3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDpmPT09enQuU3Ryb2tlfHxEPzA6eH07Tz1idChPLHt4Ok1hdGguZmxvb3IoKFMueCtiWzBdKSppWzBdK1BbMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcigoUy55K2JbMV0pKmlbMV0rUFsxXS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKFMudyppWzBdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihTLmgqaVsxXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKX0pLHYucHVzaChSKX15JiYodC5zY2FsZT15KSxtJiYodC5yb3RhdGU9bSksVCYmKHQudHJhbnNsYXRlPVQpO2NvbnN0IHU9bmV3IGVlO2lmKE8pe3RoaXMuY2VudGVyUG9zPWd0LmdldENlbnRlclBvcyhPLGwpLHUuYXR0cih7Li4udCxub3JtYWxpemU6ITAsaWQ6dC5uYW1lLGFuY2hvcjpbLjUsLjVdLGJnY29sb3I6Zj09PXp0LlN0cm9rZT9vOnZvaWQgMCxwb3M6dGhpcy5jZW50ZXJQb3Msc2l6ZTpbKE8udy0yKmd0LlNhZmVCb3JkZXJQYWRkaW5nKS9pWzBdLChPLmgtMipndC5TYWZlQm9yZGVyUGFkZGluZykvaVsxXV0sekluZGV4Omd9KTtjb25zdCBoPXYubWFwKGI9PihiLnBvcz1bYi5wb3NbMF0tdGhpcy5jZW50ZXJQb3NbMF0sYi5wb3NbMV0tdGhpcy5jZW50ZXJQb3NbMV1dLG5ldyBzZShiKSkpO3UuYXBwZW5kKC4uLmgpLGY9PT16dC5TdHJva2UmJnUuc2VhbCgpLGwuYXBwZW5kKHUpfWlmKHl8fG18fFQpe2NvbnN0IGg9dT09bnVsbD92b2lkIDA6dS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihoKXJldHVybnt4Ok1hdGguZmxvb3IoaC54LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaC55LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaC53aWR0aCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaC5oZWlnaHQrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybiBPfWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PXp0LlN0cm9rZXx8ZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0U3Ryb2tlKGUpOnRoaXMuY29tcHV0Tm9tYWwoZSl9Y29tcHV0Tm9tYWwoZSl7bGV0IHQ9dGhpcy53b3JrT3B0aW9ucy50aGlja25lc3M7Y29uc3Qgcj1lLm1hcChuPT4odD1NYXRoLm1heCh0LG4ucmFkaXVzKSxuLnBvaW50KSk7cmV0dXJue3BzOnIscmVjdDpOdChyLHQpfX1jb21wdXRTdHJva2UoZSl7cmV0dXJuIGUubGVuZ3RoPT09MT90aGlzLmNvbXB1dERvdFN0cm9rZShlWzBdKTp0aGlzLmNvbXB1dExpbmVTdHJva2UoZSl9Y29tcHV0TGluZVN0cm9rZShlKXtjb25zdCB0PVtdLHI9W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDtvKyspe2NvbnN0e3BvaW50OmYscmFkaXVzOnh9PWVbb107bGV0IGc9Zi52O289PT0wJiZlLmxlbmd0aD4xJiYoZz1lW28rMV0ucG9pbnQudik7Y29uc3QgeT1fLlBlcihnKS5tdWwoeCk7dC5wdXNoKE90LlN1YihmLHkpKSxyLnB1c2goT3QuQWRkKGYseSkpfWNvbnN0IG49ZVtlLmxlbmd0aC0xXSxzPU90LkdldFNlbWljaXJjbGVTdHJva2Uobi5wb2ludCx0W3QubGVuZ3RoLTFdLC0xLDgpLGw9T3QuR2V0U2VtaWNpcmNsZVN0cm9rZShlWzBdLnBvaW50LHJbMF0sLTEsOCksYz10LmNvbmNhdChzLHIucmV2ZXJzZSgpLGwpO3JldHVybntwczpjLHJlY3Q6TnQoYyl9fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpyfT1lLG49e3g6dC54LXIseTp0Lnktcix3OnIqMixoOnIqMn07cmV0dXJue3BzOk90LkdldERvdFN0cm9rZSh0LHIsOCkscmVjdDpufX10cmFuc2Zvcm1EYXRhKGUsdCl7Y29uc3R7b3A6cix3b3JrU3RhdGU6bn09ZTtsZXQgcz10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSxsPVtdO2lmKHIhPW51bGwmJnIubGVuZ3RoJiZuKXtjb25zdHtzdHJva2VUeXBlOmMsdGhpY2tuZXNzOm99PXRoaXMud29ya09wdGlvbnMsZj1uZXcgU2V0O3M9Yz09PXp0LlN0cm9rZT90aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUocixvLGYpOnRoaXMudXBkYXRlVGVtcFBvaW50cyhyLG8sZik7Y29uc3QgeD10P3RoaXMudG1wUG9pbnRzOnRoaXMudG1wUG9pbnRzLnNsaWNlKHMpO3JldHVybiBsPXRoaXMuZ2V0VGFza1BvaW50cyh4LG8pLHt0YXNrczpsLGVmZmVjdHM6Zixjb25zdW1lSW5kZXg6c319cmV0dXJue3Rhc2tzOmwsY29uc3VtZUluZGV4OnN9fWNvbXB1dFJhZGl1cyhlLHQpe3JldHVybiBlKi4wMyp0K3QqLjV9Z2V0TWluWihlLHQpe3JldHVybigodHx8TWF0aC5tYXgoMSxNYXRoLmZsb29yKGUqLjMpKSktZSouNSkqMTAwL2UvM31nZXRUYXNrUG9pbnRzKGUsdCl7dmFyIHg7Y29uc3Qgcj1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IG49MCxzPWVbMF0ueCxsPWVbMF0ueSxjPVtzLGxdLG89W10sZj1lWzBdLnQ7Zm9yKDtuPGUubGVuZ3RoOyl7Y29uc3QgZz1lW25dLHk9Zy54LXMsbT1nLnktbCxUPWcueixPPXQ/dGhpcy5jb21wdXRSYWRpdXMoVCx0KTpUO2lmKG8ucHVzaCh7cG9pbnQ6bmV3IE90KHksbSxULGVbbl0udikscmFkaXVzOk99KSxuPjAmJm48ZS5sZW5ndGgtMSl7Y29uc3Qgdj1lW25dLmdldEFuZ2xlQnlQb2ludHMoZVtuLTFdLGVbbisxXSk7aWYodjw5MHx8dj4yNzApe2NvbnN0IFA9KHg9by5wb3AoKSk9PW51bGw/dm9pZCAwOngucG9pbnQuY2xvbmUoKTtQJiZyLnB1c2goe3Rhc2tJZDpmLHBvczpjLHBvaW50czpbLi4ubyx7cG9pbnQ6UCxyYWRpdXM6T31dfSkscz1lW25dLngsbD1lW25dLnksYz1bcyxsXTtjb25zdCBpPWcueC1zLHU9Zy55LWw7bz1be3BvaW50Om5ldyBPdChpLHUsVCkscmFkaXVzOk99XSxmPURhdGUubm93KCl9fW4rK31yZXR1cm4gci5wdXNoKHt0YXNrSWQ6Zixwb3M6Yyxwb2ludHM6b30pLHJ9dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShlLHQscil7Y29uc3Qgbj1EYXRlLm5vdygpLHM9dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBsPXM7Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDtvKz0yKXtsPU1hdGgubWluKGwscyk7Y29uc3QgZj10aGlzLnRtcFBvaW50cy5sZW5ndGgseD1uZXcgT3QoZVtvXSxlW28rMV0pO2lmKGY9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKHgpO2NvbnRpbnVlfWNvbnN0IGc9Zi0xLHk9dGhpcy50bXBQb2ludHNbZ10sbT1fLlN1Yih4LHkpLnVuaSgpO2lmKHguaXNOZWFyKHksdCkpe2lmKHkuejx0aGlzLk1BWF9SRVBFQVIpe2lmKHkuc2V0eihNYXRoLm1pbih5LnorMSx0aGlzLk1BWF9SRVBFQVIpKSxsPU1hdGgubWluKGwsZyksZj4xKXtsZXQgdj1mLTE7Zm9yKDt2PjA7KXtjb25zdCBQPXRoaXMudG1wUG9pbnRzW3ZdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzW3YtMV0pLGk9TWF0aC5tYXgodGhpcy50bXBQb2ludHNbdl0uei10aGlzLnVuaVRoaWNrbmVzcypQLDApO2lmKHRoaXMudG1wUG9pbnRzW3YtMV0uej49aSlicmVhazt0aGlzLnRtcFBvaW50c1t2LTFdLnNldHooaSksbD1NYXRoLm1pbihsLHYtMSksdi0tfX19ZWxzZSBsPTEvMDtjb250aW51ZX14LnNldHYobSk7Y29uc3QgVD14LmRpc3RhbmNlKHkpLE89TWF0aC5tYXgoeS56LXRoaXMudW5pVGhpY2tuZXNzKlQsMCk7Zj4xJiZfLkVxdWFscyhtLHkudiwuMDIpJiYoTz4wfHx5Lno8PTApJiYociYmeS50JiZyLmFkZCh5LnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGw9TWF0aC5taW4oZyxsKSkseC5zZXR6KE8pLHRoaXMudG1wUG9pbnRzLnB1c2goeCl9aWYobD09PTEvMClyZXR1cm4gdGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBjPXM7aWYobD09PXMpe2M9TWF0aC5tYXgoYy0xLDApO2NvbnN0IG89dGhpcy50bXBQb2ludHNbY10udDtvJiYocj09bnVsbHx8ci5hZGQobykpfWVsc2V7bGV0IG89cy0xO2ZvcihjPWw7bz49MDspe2NvbnN0IGY9dGhpcy50bXBQb2ludHNbb10udDtpZihmJiYocj09bnVsbHx8ci5hZGQoZiksbzw9bCkpe2M9byxvPS0xO2JyZWFrfW8tLX19cmV0dXJuIHRoaXMudG1wUG9pbnRzW2NdLnNldFQobiksY311cGRhdGVUZW1wUG9pbnRzKGUsdCxyKXt2YXIgbztjb25zdCBuPURhdGUubm93KCkscz10aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGw9cztmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrPTIpe2NvbnN0IHg9dGhpcy50bXBQb2ludHMubGVuZ3RoLGc9bmV3IE90KGVbZl0sZVtmKzFdKTtpZih4PT09MCl7dGhpcy50bXBQb2ludHMucHVzaChnKTtjb250aW51ZX1jb25zdCB5PXgtMSxtPXRoaXMudG1wUG9pbnRzW3ldLFQ9Xy5TdWIoZyxtKS51bmkoKTtpZihnLmlzTmVhcihtLHQvMikpe2w9TWF0aC5taW4oeSxsKTtjb250aW51ZX1fLkVxdWFscyhULG0udiwuMDIpJiYociYmbS50JiZyLmFkZChtLnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGw9TWF0aC5taW4oeSxsKSksZy5zZXR2KFQpLHRoaXMudG1wUG9pbnRzLnB1c2goZyl9bGV0IGM9cztpZihsPT09cyl7Yz1NYXRoLm1heChjLTEsMCk7Y29uc3QgZj10aGlzLnRtcFBvaW50c1tjXS50O2YmJihyPT1udWxsfHxyLmFkZChmKSl9ZWxzZXtsZXQgZj1NYXRoLm1pbihzLTEsbCk7Zm9yKGM9bDtmPj0wOyl7Y29uc3QgeD0obz10aGlzLnRtcFBvaW50c1tmXSk9PW51bGw/dm9pZCAwOm8udDtpZih4JiYocj09bnVsbHx8ci5hZGQoeCksZjw9bCkpe2M9ZixmPS0xO2JyZWFrfWYtLX19cmV0dXJuIHRoaXMudG1wUG9pbnRzW2NdLnNldFQobiksY311cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlV2hlbkRvbmUoZSl7Y29uc3R7dGhpY2tuZXNzOnR9PXRoaXMud29ya09wdGlvbnMscj1lLmxlbmd0aCxuPXRoaXMuZ2V0TWluWih0KTtmb3IobGV0IHM9MDtzPHI7cys9Mil7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5sZW5ndGgsYz1uZXcgT3QoZVtzXSxlW3MrMV0pO2lmKGw9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKGMpO2NvbnRpbnVlfWNvbnN0IG89bC0xLGY9dGhpcy50bXBQb2ludHNbb10seD1fLlN1YihjLGYpLnVuaSgpLGc9Yy5kaXN0YW5jZShmKTtpZihsPjEmJmYuej09PW4pYnJlYWs7aWYoYy5pc05lYXIoZix0LzIpKXtpZihyPDMmJmYuejx0aGlzLk1BWF9SRVBFQVImJihmLnNldHooTWF0aC5taW4oZi56KzEsdGhpcy5NQVhfUkVQRUFSKSksbD4xKSl7bGV0IG09bC0xO2Zvcig7bT4wOyl7Y29uc3QgVD10aGlzLnRtcFBvaW50c1ttXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1ttLTFdKSxPPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW21dLnotdGhpcy51bmlUaGlja25lc3MqVCwtdC80KTtpZih0aGlzLnRtcFBvaW50c1ttLTFdLno+PU8pYnJlYWs7dGhpcy50bXBQb2ludHNbbS0xXS5zZXR6KE8pLG0tLX19Y29udGludWV9Yy5zZXR2KHgpO2NvbnN0IHk9TWF0aC5tYXgoZi56LXRoaXMudW5pVGhpY2tuZXNzKmcsbik7bD4xJiZfLkVxdWFscyh4LGYudiwuMDIpJiZmLno8PTAmJnRoaXMudG1wUG9pbnRzLnBvcCgpLGMuc2V0eih5KSx0aGlzLnRtcFBvaW50cy5wdXNoKGMpfX1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgYztjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOnN9PXIsbD1uLmdldCh0Lm5hbWUpO3JldHVybiBzJiYodC50YWdOYW1lPT09IkdST1VQIj9OZSh0KT90LnNldEF0dHJpYnV0ZSgiYmdjb2xvciIscyk6dC5jaGlsZHJlbi5mb3JFYWNoKG89PntvLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHMpLG8uZ2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiKSYmby5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIscyl9KToodC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixzKSx0LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixzKSksKGM9bD09bnVsbD92b2lkIDA6bC5vcHQpIT1udWxsJiZjLnN0cm9rZUNvbG9yJiYobC5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJm4uc2V0SW5mbyh0Lm5hbWUsbCksZ3QudXBkYXRlTm9kZU9wdChlKX1zdGF0aWMgZ2V0UmVjdEZyb21MYXllcihlLHQpe2NvbnN0IHI9ZS5nZXRFbGVtZW50c0J5TmFtZSh0KVswXTtpZihyKXtjb25zdCBuPXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihuLngtZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihuLnktZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihuLndpZHRoK2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihuLmhlaWdodCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKX19fX1jbGFzcyBkbiBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5MYXNlclBlbn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5ub25lfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY0luZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb25zdW1lSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7fXNldFdvcmtPcHRpb25zKGUpe3N1cGVyLnNldFdvcmtPcHRpb25zKGUpLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbnN1bWUoZSl7Y29uc3R7ZGF0YTp0LGlzU3ViV29ya2VyOnJ9PWUse3dvcmtJZDpuLG9wOnN9PXQ7aWYoKHM9PW51bGw/dm9pZCAwOnMubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy51cGRhdGVUZW1wUG9pbnRzKHN8fFtdKSx0aGlzLmNvbnN1bWVJbmRleD50aGlzLnRtcFBvaW50cy5sZW5ndGgtNClyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHtzdHJva2VDb2xvcjpsLHRoaWNrbmVzczpjLHN0cm9rZVR5cGU6b309dGhpcy53b3JrT3B0aW9ucyxmPU50KHRoaXMudG1wUG9pbnRzLGMpO2xldCB4PSExO2NvbnN0IGc9dGhpcy5zeW5jSW5kZXgseT10aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLmNvbnN1bWVJbmRleCk7dGhpcy5jb25zdW1lSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoLTEsdGhpcy5zeW5jVGltZXN0YW1wPT09MCYmKHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpKTtjb25zdCBtPXtuYW1lOm49PW51bGw/dm9pZCAwOm4udG9TdHJpbmcoKSxvcGFjaXR5OjEsbGluZURhc2g6bz09PXp0LkRvdHRlZD9bMSxjKjJdOm89PT16dC5Mb25nRG90dGVkP1tjLGMqMl06dm9pZCAwLHN0cm9rZUNvbG9yOmwsbGluZUNhcDoicm91bmQiLGxpbmVXaWR0aDpjLGFuY2hvcjpbLjUsLjVdfSxUPXRoaXMuZ2V0VGFza1BvaW50cyh5KTtpZihULmxlbmd0aCl7Y29uc3Qgdj1EYXRlLm5vdygpO3YtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYoeD0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9dix0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLHImJnRoaXMuZHJhdyh7YXR0cnM6bSx0YXNrczpULGlzRG90OiExLGxheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcn0pfWNvbnN0IE89W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKGcpLmZvckVhY2godj0+e08ucHVzaCh2Lngsdi55KX0pLHtyZWN0Ont4OmYueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OmYueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OmYudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpmLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfSx0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDp4P246dm9pZCAwLG9wOng/Tzp2b2lkIDAsaW5kZXg6eD9nKjI6dm9pZCAwfX1jb25zdW1lQWxsKCl7dmFyIG47Y29uc3QgZT0obj10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOm4udG9TdHJpbmcoKTtsZXQgdDtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGgtMT50aGlzLmNvbnN1bWVJbmRleCl7bGV0IHM9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO2NvbnN0IGw9cy5sZW5ndGg9PT0xLHtzdHJva2VDb2xvcjpjLHRoaWNrbmVzczpvLHN0cm9rZVR5cGU6Zn09dGhpcy53b3JrT3B0aW9ucztpZihsKXtjb25zdCB5PXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDpzWzBdLHJhZGl1czpvLzJ9KTtzPXkucHMsdD15LnJlY3R9ZWxzZSB0PU50KHRoaXMudG1wUG9pbnRzLG8pO2NvbnN0IHg9e25hbWU6ZT09bnVsbD92b2lkIDA6ZS50b1N0cmluZygpLGZpbGxDb2xvcjpsP2M6dm9pZCAwLG9wYWNpdHk6MSxsaW5lRGFzaDpmPT09enQuRG90dGVkJiYhbD9bMSxvKjJdOmY9PT16dC5Mb25nRG90dGVkJiYhbD9bbyxvKjJdOnZvaWQgMCxzdHJva2VDb2xvcjpjLGxpbmVDYXA6bD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6bD8wOm8sYW5jaG9yOlsuNSwuNV19LGc9dGhpcy5nZXRUYXNrUG9pbnRzKHMpO2cubGVuZ3RoJiZ0aGlzLmRyYXcoe2F0dHJzOngsdGFza3M6Zyxpc0RvdDpsLGxheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcn0pfWNvbnN0IHI9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuc3luY0luZGV4KS5mb3JFYWNoKHM9PntyLnB1c2gocy54LHMueSl9KSx7cmVjdDp0JiZ7eDp0LngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTp0LnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzp0LncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6dC5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX0sdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6ZSxvcDpyLGluZGV4OnRoaXMuc3luY0luZGV4KjJ9fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jSW5kZXg9MH1jb25zdW1lU2VydmljZShlKXt2YXIgVDtjb25zdHtvcDp0LHJlcGxhY2VJZDpyLGlzRnVsbFdvcms6bn09ZSx7c3Ryb2tlQ29sb3I6cyx0aGlja25lc3M6bCxzdHJva2VUeXBlOmN9PXRoaXMud29ya09wdGlvbnM7aWYoIXQubGVuZ3RoKXtjb25zdCBPPU50KHRoaXMudG1wUG9pbnRzLGwpO3JldHVybnt4Ok8ueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5Ok8ueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3Ok8udyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpPLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb25zdCBvPU1hdGgubWF4KDAsdGhpcy50bXBQb2ludHMubGVuZ3RoLTEpO3RoaXMudXBkYXRlVGVtcFBvaW50cyh0fHxbXSk7bGV0IGYseD10aGlzLnRtcFBvaW50cy5zbGljZShvKTtjb25zdCBnPXgubGVuZ3RoPT09MTtpZihnKXtjb25zdCBPPXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDp4WzBdLHJhZGl1czpsLzJ9KTt4PU8ucHMsZj1PLnJlY3R9ZWxzZSBmPU50KHRoaXMudG1wUG9pbnRzLGwpO2NvbnN0IHk9e25hbWU6KFQ9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpULnRvU3RyaW5nKCksZmlsbENvbG9yOmc/czp2b2lkIDAsb3BhY2l0eToxLGxpbmVEYXNoOmM9PT16dC5Eb3R0ZWQmJiFnP1sxLGwqMl06Yz09PXp0LkxvbmdEb3R0ZWQmJiFnP1tsLGwqMl06dm9pZCAwLHN0cm9rZUNvbG9yOnMsbGluZUNhcDpnP3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDpnPzA6bCxhbmNob3I6Wy41LC41XX0sbT10aGlzLmdldFRhc2tQb2ludHMoeCk7aWYobS5sZW5ndGgpe2NvbnN0IE89bj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7dGhpcy5kcmF3KHthdHRyczp5LHRhc2tzOm0saXNEb3Q6ZyxyZXBsYWNlSWQ6cixsYXllcjpPfSl9cmV0dXJue3g6Zi54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6Zi55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6Zi53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOmYuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpyfT1lLG49e3g6dC54LXIseTp0Lnktcix3OnIqMixoOnIqMn07cmV0dXJue3BzOk90LkdldERvdFN0cm9rZSh0LHIsOCkscmVjdDpufX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9dGhpcy50bXBQb2ludHMubGVuZ3RoO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cis9Mil7aWYodCl7Y29uc3Qgbj10aGlzLnRtcFBvaW50cy5zbGljZSgtMSlbMF07biYmbi54PT09ZVtyXSYmbi55PT09ZVtyKzFdJiZ0aGlzLnRtcFBvaW50cy5wb3AoKX10aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdChlW3JdLGVbcisxXSkpfX1hc3luYyBkcmF3KGUpe2NvbnN0e2F0dHJzOnQsdGFza3M6cixpc0RvdDpuLGxheWVyOnN9PWUse2R1cmF0aW9uOmx9PXRoaXMud29ya09wdGlvbnM7Zm9yKGNvbnN0IGMgb2Ygcil7Y29uc3Qgbz1uZXcgc2Use3BvczpmLHBvaW50czp4fT1jO2xldCBnO24/Zz1nZSh4LCEwKTpnPWdlKHgsITEpLG8uYXR0cih7Li4udCxwb3M6ZixkOmd9KTtjb25zdHt2ZXJ0ZXg6eSxmcmFnbWVudDptfT10aGlzLndvcmtPcHRpb25zO2lmKHkmJm0pe2NvbnN0IFQ9cy5yZW5kZXJlci5jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6eSxmcmFnbWVudDptfSkse3dpZHRoOk8saGVpZ2h0OnZ9PXMuZ2V0UmVzb2x1dGlvbigpO28uc2V0VW5pZm9ybXMoe3VfdGltZTowLHVfcmVzb2x1dGlvbjpbTyx2XX0pLG8uc2V0UHJvZ3JhbShUKX1zLmFwcGVuZENoaWxkKG8pLG8udHJhbnNpdGlvbihsKS5hdHRyKHtzY2FsZTpuP1suMSwuMV06WzEsMV0sbGluZVdpZHRoOm4/MDoxfSkudGhlbigoKT0+e28ucmVtb3ZlKCl9KX19Z2V0VGFza1BvaW50cyhlKXt2YXIgbztjb25zdCB0PVtdO2lmKGUubGVuZ3RoPT09MClyZXR1cm5bXTtsZXQgcj0wLG49ZVswXS54LHM9ZVswXS55LGw9W24sc10sYz1bXTtmb3IoO3I8ZS5sZW5ndGg7KXtjb25zdCBmPWVbcl0seD1mLngtbixnPWYueS1zO2lmKGMucHVzaChuZXcgT3QoeCxnKSkscj4wJiZyPGUubGVuZ3RoLTEpe2NvbnN0IHk9ZVtyXS5nZXRBbmdsZUJ5UG9pbnRzKGVbci0xXSxlW3IrMV0pO2lmKHk8OTB8fHk+MjcwKXtjb25zdCBtPShvPWMucG9wKCkpPT1udWxsP3ZvaWQgMDpvLmNsb25lKCk7bSYmdC5wdXNoKHtwb3M6bCxwb2ludHM6Wy4uLmMsbV19KSxuPWVbcl0ueCxzPWVbcl0ueSxsPVtuLHNdO2NvbnN0IFQ9Zi54LW4sTz1mLnktcztjPVtuZXcgT3QoVCxPKV19fXIrK31yZXR1cm4gdC5wdXNoKHtwb3M6bCxwb2ludHM6Y30pLHR9cmVtb3ZlTG9jYWwoKXt9cmVtb3ZlU2VydmljZShlKXtsZXQgdDtjb25zdCByPVtdO3JldHVybiB0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5mb3JFYWNoKG49PntpZihuLm5hbWU9PT1lKXtjb25zdCBzPW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dD1idCh0LHt4OnMueCx5OnMueSx3OnMud2lkdGgsaDpzLmhlaWdodH0pLHIucHVzaChuKX19KSxyLmxlbmd0aCYmci5mb3JFYWNoKG49Pm4ucmVtb3ZlKCkpLHR9fXZhciBUaD1XZTtXZS5wb2x5bGluZT1XZSxXZS5wb2x5Z29uPUVoO2Z1bmN0aW9uIFdlKGQsZSx0KXt2YXIgcj1kLmxlbmd0aCxuPW1lKGRbMF0sZSkscz1bXSxsLGMsbyxmLHg7Zm9yKHR8fCh0PVtdKSxsPTE7bDxyO2wrKyl7Zm9yKGM9ZFtsLTFdLG89ZFtsXSxmPXg9bWUobyxlKTs7KWlmKG58Zil7aWYobiZmKWJyZWFrO24/KGM9aXIoYyxvLG4sZSksbj1tZShjLGUpKToobz1pcihjLG8sZixlKSxmPW1lKG8sZSkpfWVsc2V7cy5wdXNoKGMpLGYhPT14PyhzLnB1c2gobyksbDxyLTEmJih0LnB1c2gocykscz1bXSkpOmw9PT1yLTEmJnMucHVzaChvKTticmVha31uPXh9cmV0dXJuIHMubGVuZ3RoJiZ0LnB1c2gocyksdH1mdW5jdGlvbiBFaChkLGUpe3ZhciB0LHIsbixzLGwsYyxvO2ZvcihyPTE7cjw9ODtyKj0yKXtmb3IodD1bXSxuPWRbZC5sZW5ndGgtMV0scz0hKG1lKG4sZSkmciksbD0wO2w8ZC5sZW5ndGg7bCsrKWM9ZFtsXSxvPSEobWUoYyxlKSZyKSxvIT09cyYmdC5wdXNoKGlyKG4sYyxyLGUpKSxvJiZ0LnB1c2goYyksbj1jLHM9bztpZihkPXQsIWQubGVuZ3RoKWJyZWFrfXJldHVybiB0fWZ1bmN0aW9uIGlyKGQsZSx0LHIpe3JldHVybiB0Jjg/W2RbMF0rKGVbMF0tZFswXSkqKHJbM10tZFsxXSkvKGVbMV0tZFsxXSksclszXV06dCY0P1tkWzBdKyhlWzBdLWRbMF0pKihyWzFdLWRbMV0pLyhlWzFdLWRbMV0pLHJbMV1dOnQmMj9bclsyXSxkWzFdKyhlWzFdLWRbMV0pKihyWzJdLWRbMF0pLyhlWzBdLWRbMF0pXTp0JjE/W3JbMF0sZFsxXSsoZVsxXS1kWzFdKSooclswXS1kWzBdKS8oZVswXS1kWzBdKV06bnVsbH1mdW5jdGlvbiBtZShkLGUpe3ZhciB0PTA7cmV0dXJuIGRbMF08ZVswXT90fD0xOmRbMF0+ZVsyXSYmKHR8PTIpLGRbMV08ZVsxXT90fD00OmRbMV0+ZVszXSYmKHR8PTgpLHR9dmFyIEFoPXBlKFRoKTtjbGFzcyBYdCBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5ub25lfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZ0LkVyYXNlcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFBvc2l0aW9uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmxkU2NhbGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVyYXNlclBvbHlsaW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMud29ybGRQb3NpdGlvbj10aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uLHRoaXMud29ybGRTY2FsaW5nPXRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ31jb21iaW5lQ29uc3VtZSgpe31jb25zdW1lU2VydmljZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKX1jcmVhdGVFcmFzZXJSZWN0KGUpe2NvbnN0IHQ9ZVswXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0scj1lWzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSx7d2lkdGg6bixoZWlnaHQ6c309WHQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdO3RoaXMuZXJhc2VyUmVjdD17eDp0LW4qLjUseTpyLXMqLjUsdzpuLGg6c30sdGhpcy5lcmFzZXJQb2x5bGluZT1bdGhpcy5lcmFzZXJSZWN0LngsdGhpcy5lcmFzZXJSZWN0LnksdGhpcy5lcmFzZXJSZWN0LngrdGhpcy5lcmFzZXJSZWN0LncsdGhpcy5lcmFzZXJSZWN0LnkrdGhpcy5lcmFzZXJSZWN0LmhdfWNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKXtjb25zdCBlPXRoaXMudG1wUG9pbnRzLnNsaWNlKC0yKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT00KXtjb25zdCB0PW5ldyBfKHRoaXMudG1wUG9pbnRzWzBdLHRoaXMudG1wUG9pbnRzWzFdKSxyPW5ldyBfKHRoaXMudG1wUG9pbnRzWzJdLHRoaXMudG1wUG9pbnRzWzNdKSxuPV8uU3ViKHIsdCkudW5pKCkscz1fLkRpc3QodCxyKSx7d2lkdGg6bCxoZWlnaHQ6Y309WHQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdLG89TWF0aC5taW4obCxjKSxmPU1hdGgucm91bmQocy9vKTtpZihmPjEpe2NvbnN0IHg9W107Zm9yKGxldCBnPTA7ZzxmO2crKyl7Y29uc3QgeT1fLk11bChuLGcqbyk7eC5wdXNoKHRoaXMudG1wUG9pbnRzWzBdK3kueCx0aGlzLnRtcFBvaW50c1sxXSt5LnkpfXJldHVybiB4LmNvbmNhdChlKX19cmV0dXJuIGV9aXNOZWFyKGUsdCl7Y29uc3Qgcj1uZXcgXyhlWzBdLGVbMV0pLG49bmV3IF8odFswXSx0WzFdKSx7d2lkdGg6cyxoZWlnaHQ6bH09WHQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdO3JldHVybiBfLkRpc3QocixuKTxNYXRoLmh5cG90KHMsbCkqLjV9Y3V0UG9seWxpbmUoZSx0KXtsZXQgcj1bdF0sbj0wO2Zvcig7bjxlLmxlbmd0aDspe2NvbnN0IGM9ZVtuXTtpZihjLmxlbmd0aDwyKWJyZWFrO3I9cyhyLGMpLG4rK31yZXR1cm4gcjtmdW5jdGlvbiBzKGMsbyl7Y29uc3QgZj1jO2ZvcihsZXQgeD0wO3g8Yy5sZW5ndGg7eCsrKXtjb25zdCBnPWNbeF0seT1nLmZpbmRJbmRleCgobSxUKT0+VDxnLmxlbmd0aC0xP2woW20sZ1tUKzFdXSxbb1swXSxvWzFdXSk6ITEpO2lmKHkhPT0tMSYmeT4tMSl7Y29uc3QgbT1bXSxUPWcuc2xpY2UoMCx5KzEpO2lmKF8uRXF1YWxzKGdbeV0sb1swXSl8fFQucHVzaChvWzBdLmNsb25lKCkuc2V0eihnW3ldLnopKSxULmxlbmd0aD4xJiZtLnB1c2goVCkseStvLmxlbmd0aC0xPGcubGVuZ3RoLTEpe2NvbnN0IE89eStvLmxlbmd0aC0xLHY9Zy5zbGljZShPKSxQPW9bby5sZW5ndGgtMV07Xy5FcXVhbHMoZ1tPXSxQKXx8di51bnNoaWZ0KFAuY2xvbmUoKS5zZXR6KGdbT10ueikpLHYubGVuZ3RoPjEmJm0ucHVzaCh2KX1yZXR1cm4gZi5zcGxpY2UoeCwxLC4uLm0pLGZ9fXJldHVybiBmfWZ1bmN0aW9uIGwoYyxvKXtjb25zdCBmPV8uU3ViKGNbMV0sY1swXSkseD1fLlN1YihvWzFdLG9bMF0pLGc9Xy5TdWIob1swXSxjWzBdKTtyZXR1cm4gTWF0aC5hYnMoXy5DcHIoZix4KSk8LjEmJk1hdGguYWJzKF8uQ3ByKGYsZykpPC4xfX1pc1NhbWVQb2ludChlLHQpe3JldHVybiBlWzBdPT09dFswXSYmZVsxXT09PXRbMV19dHJhbnNsYXRlSW50ZXJzZWN0KGUpe2NvbnN0IHQ9W107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IG49ZVtyXS5maWx0ZXIoKGMsbyxmKT0+IShvPjAmJnRoaXMuaXNTYW1lUG9pbnQoYyxmW28tMV0pKSkscz1bXTtsZXQgbD0wO2Zvcig7bDxuLmxlbmd0aDspe2NvbnN0IGM9bltsXSxvPW5ldyBfKGNbMF0sY1sxXSk7cy5wdXNoKG8pLGwrK310LnB1c2gocyl9cmV0dXJuIHR9aXNMaW5lRXJhc2VyKGUsdCl7cmV0dXJuIShlPT09dnQuUGVuY2lsJiYhdCl9cmVtb3ZlKGUpe2NvbnN0e2N1ck5vZGVNYXA6dCxyZW1vdmVJZHM6cixuZXdXb3JrRGF0YXM6bn09ZSx7aXNMaW5lOnN9PXRoaXMud29ya09wdGlvbnM7bGV0IGw7Zm9yKGNvbnN0W2Msb11vZiB0LmVudHJpZXMoKSlpZihvLnJlY3QmJnRoaXMuZXJhc2VyUmVjdCYmdGhpcy5lcmFzZXJQb2x5bGluZSYmeGUodGhpcy5lcmFzZXJSZWN0LG8ucmVjdCkpe2NvbnN0e29wOmYsdG9vbHNUeXBlOnh9PW8sZz10aGlzLmlzTGluZUVyYXNlcih4LHMpLHk9W10sbT1bXTtmb3IobGV0IE89MDtPPGYubGVuZ3RoO08rPTMpe2NvbnN0IHY9bmV3IF8oZltPXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0sZltPKzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSxmW08rMl0pO20ucHVzaCh2KSx5LnB1c2gobmV3IE90KHYueCx2LnkpKX1jb25zdCBUPXkubGVuZ3RoJiZOdCh5KXx8by5yZWN0O2lmKHhlKFQsdGhpcy5lcmFzZXJSZWN0KSl7aWYobS5sZW5ndGg+MSl7Y29uc3QgTz1BaC5wb2x5bGluZShtLm1hcCh2PT52LlhZKSx0aGlzLmVyYXNlclBvbHlsaW5lKTtpZihPLmxlbmd0aCYmKHIuYWRkKG8ubmFtZSksIWcpKXtjb25zdCB2PXRoaXMudHJhbnNsYXRlSW50ZXJzZWN0KE8pLFA9dGhpcy5jdXRQb2x5bGluZSh2LG0pO2ZvcihsZXQgaT0wO2k8UC5sZW5ndGg7aSsrKXtjb25zdCB1PWAke2N9X3NfJHtpfWAsYT1bXTtQW2ldLmZvckVhY2goaD0+e2EucHVzaCgoaC54LXRoaXMud29ybGRQb3NpdGlvblswXSkvdGhpcy53b3JsZFNjYWxpbmdbMF0sKGgueS10aGlzLndvcmxkUG9zaXRpb25bMV0pL3RoaXMud29ybGRTY2FsaW5nWzFdLGgueil9KSxvLm9wdCYmby50b29sc1R5cGUmJnRoaXMudk5vZGVzJiYodGhpcy52Tm9kZXMuc2V0SW5mbyh1LHtyZWN0OlQsb3A6YSxvcHQ6by5vcHQsY2FuUm90YXRlOm8uY2FuUm90YXRlLHNjYWxlVHlwZTpvLnNjYWxlVHlwZSx0b29sc1R5cGU6by50b29sc1R5cGV9KSxuLnNldCh1LHt3b3JrSWQ6dSxvcDphLG9wdDpvLm9wdCx0b29sc1R5cGU6by50b29sc1R5cGV9KSl9fX1lbHNlIHIuYWRkKG8ubmFtZSk7bD1idChsLFQpfX1yZXR1cm4gci5mb3JFYWNoKGM9Pnt2YXIgbztyZXR1cm4obz10aGlzLnZOb2Rlcyk9PW51bGw/dm9pZCAwOm8uZGVsZXRlKGMpfSksbCYmKGwueC09Z3QuU2FmZUJvcmRlclBhZGRpbmcsbC55LT1ndC5TYWZlQm9yZGVyUGFkZGluZyxsLncrPWd0LlNhZmVCb3JkZXJQYWRkaW5nKjIsbC5oKz1ndC5TYWZlQm9yZGVyUGFkZGluZyoyKSxsfWNvbnN1bWUoZSl7Y29uc3R7b3A6dH09ZS5kYXRhO2lmKCF0fHx0Lmxlbmd0aD09PTApcmV0dXJue3R5cGU6dXQuTm9uZX07Y29uc3Qgcj10aGlzLnRtcFBvaW50cy5sZW5ndGg7aWYocj4xJiZ0aGlzLmlzTmVhcihbdFswXSx0WzFdXSxbdGhpcy50bXBQb2ludHNbci0yXSx0aGlzLnRtcFBvaW50c1tyLTFdXSkpcmV0dXJue3R5cGU6dXQuTm9uZX07cj09PTQmJih0aGlzLnRtcFBvaW50cy5zaGlmdCgpLHRoaXMudG1wUG9pbnRzLnNoaWZ0KCkpLHRoaXMudG1wUG9pbnRzLnB1c2godFswXSx0WzFdKTtjb25zdCBuPXRoaXMuY29tcHV0UmVjdENlbnRlclBvaW50cygpO2xldCBzO2NvbnN0IGw9bmV3IFNldCxjPW5ldyBNYXA7dGhpcy52Tm9kZXMuc2V0VGFyZ2V0KCk7Zm9yKGxldCBvPTA7bzxuLmxlbmd0aC0xO28rPTIpe3RoaXMuY3JlYXRlRXJhc2VyUmVjdChuLnNsaWNlKG8sbysyKSk7Y29uc3QgZj10aGlzLnJlbW92ZSh7Y3VyTm9kZU1hcDp0aGlzLnZOb2Rlcy5nZXRMYXN0VGFyZ2V0KCkscmVtb3ZlSWRzOmwsbmV3V29ya0RhdGFzOmN9KTtzPWJ0KHMsZil9aWYodGhpcy52Tm9kZXMuZGVsZXRlTGFzdFRhcmdldCgpLHMmJmwuc2l6ZSl7Zm9yKGNvbnN0IG8gb2YgYy5rZXlzKCkpbC5oYXMobykmJmMuZGVsZXRlKG8pO3JldHVybnt0eXBlOnV0LlJlbW92ZU5vZGUsZGF0YVR5cGU6UHQuTG9jYWwscmVjdDpzLHJlbW92ZUlkczpbLi4ubF0sbmV3V29ya0RhdGFzOmN9fXJldHVybnt0eXBlOnV0Lk5vbmV9fWNvbnN1bWVBbGwoZSl7cmV0dXJuIHRoaXMuY29uc3VtZShlKX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoWHQsImVyYXNlclNpemVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6T2JqZWN0LmZyZWV6ZShbT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MTgsaGVpZ2h0OjI2fSksT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MjYsaGVpZ2h0OjM0fSksT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MzQsaGVpZ2h0OjUwfSldKX0pO2NvbnN0IENoPSIrKyIsUmg9InNlbGVjdG9yIixJaD0iYWxsIjtjbGFzcyBSdCBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5TZWxlY3Rvcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VsZWN0b3JDb2xvciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzdHJva2VDb2xvciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmaWxsQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkU2VsZWN0UmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5UZXh0RWRpdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkt0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0ZXh0T3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0fWNvbXB1dFNlbGVjdG9yKCl7Y29uc3QgZT1OdCh0aGlzLnRtcFBvaW50cykse3JlY3RSYW5nZTp0LG5vZGVSYW5nZTpyfT10aGlzLnZOb2Rlcy5nZXRSZWN0SW50ZXJzZWN0UmFuZ2UoZSk7cmV0dXJue3NlbGVjdElkczpbLi4uci5rZXlzKCldLGludGVyc2VjdFJlY3Q6dCxzdWJOb2RlTWFwOnJ9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGgscj1lLmxlbmd0aDtpZihyPjEpe2NvbnN0IG49bmV3IE90KGVbci0yXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSxlW3ItMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0pO3Q9PT0yP3RoaXMudG1wUG9pbnRzLnNwbGljZSgxLDEsbik6dGhpcy50bXBQb2ludHMucHVzaChuKX19ZHJhd1NlbGVjdG9yKGUpe2NvbnN0e2RyYXdSZWN0OnQsc3ViTm9kZU1hcDpyLHNlbGVjdG9ySWQ6bixsYXllcjpzLGlzU2VydmljZTpsfT1lLGM9bmV3IGVlKHtwb3M6W3QueCx0LnldLGFuY2hvcjpbMCwwXSxzaXplOlt0LncsdC5oXSxpZDpuLG5hbWU6UnQuc2VsZWN0b3JJZCx6SW5kZXg6MWUzfSksbz1bXTtpZihsKXtjb25zdCBmPW5ldyBycih7bm9ybWFsaXplOiEwLHBvczpbdC53LzIsdC5oLzJdLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOnRoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3Isd2lkdGg6dC53LGhlaWdodDp0LmgsbmFtZTpSdC5zZWxlY3RvckJvcmRlcklkfSk7by5wdXNoKGYpfXIuZm9yRWFjaCgoZix4KT0+e2NvbnN0IGc9W2YucmVjdC54K2YucmVjdC53LzItdC54LGYucmVjdC55K2YucmVjdC5oLzItdC55XSx5PW5ldyBycih7bm9ybWFsaXplOiEwLHBvczpnLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOnIuc2l6ZT4xP3RoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3I6dm9pZCAwLHdpZHRoOmYucmVjdC53LGhlaWdodDpmLnJlY3QuaCxpZDpgc2VsZWN0b3ItJHt4fWAsbmFtZTpgc2VsZWN0b3ItJHt4fWB9KTtvLnB1c2goeSl9KSxvJiZjLmFwcGVuZCguLi5vKSwocz09bnVsbD92b2lkIDA6cy5wYXJlbnQpLmFwcGVuZENoaWxkKGMpfWRyYXcoZSx0LHIsbj0hMSl7dmFyIGMsbztjb25zdHtpbnRlcnNlY3RSZWN0OnMsc3ViTm9kZU1hcDpsfT1yOyhvPShjPXQucGFyZW50KT09bnVsbD92b2lkIDA6Yy5nZXRFbGVtZW50QnlJZChlKSk9PW51bGx8fG8ucmVtb3ZlKCkscyYmdGhpcy5kcmF3U2VsZWN0b3Ioe2RyYXdSZWN0OnMsc3ViTm9kZU1hcDpsLHNlbGVjdG9ySWQ6ZSxsYXllcjp0LGlzU2VydmljZTpufSl9Z2V0U2VsZWN0ZW9ySW5mbyhlKXt0aGlzLnNjYWxlVHlwZT1LdC5hbGwsdGhpcy5jYW5Sb3RhdGU9ITE7Zm9yKGNvbnN0IHQgb2YgZS52YWx1ZXMoKSl7Y29uc3R7b3B0OnIsY2FuUm90YXRlOm4sc2NhbGVUeXBlOnMsdG9vbHNUeXBlOmx9PXQ7dGhpcy5zZWxlY3RvckNvbG9yPXRoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3IsdGhpcy5zdHJva2VDb2xvcj1yLnN0cm9rZUNvbG9yLHIuZmlsbENvbG9yJiYodGhpcy5maWxsQ29sb3I9ci5maWxsQ29sb3IpLHIudGV4dE9wdCYmKHRoaXMudGV4dE9wdD1yLnRleHRPcHQpLGw9PT12dC5UZXh0JiYodGhpcy50ZXh0T3B0PXIpLGUuc2l6ZT09PTE/KHRoaXMudGV4dE9wdCYmKHRoaXMuY2FuVGV4dEVkaXQ9ITApLHRoaXMuY2FuUm90YXRlPW4sdGhpcy5zY2FsZVR5cGU9cyk6cz09PUt0Lm5vbmUmJih0aGlzLnNjYWxlVHlwZT1zKX19Z2V0Q2hpbGRyZW5Qb2ludHMoKXt2YXIgZTtpZih0aGlzLnNjYWxlVHlwZT09PUt0LmJvdGgmJnRoaXMuc2VsZWN0SWRzKXtjb25zdCB0PXRoaXMuc2VsZWN0SWRzWzBdLHI9KGU9dGhpcy52Tm9kZXMuZ2V0KHQpKT09bnVsbD92b2lkIDA6ZS5vcDtpZihyKXtjb25zdCBuPVtdO2ZvcihsZXQgcz0wO3M8ci5sZW5ndGg7cys9MyluLnB1c2goW3Jbc10scltzKzFdXSk7cmV0dXJuIG59fX1jb25zdW1lKGUpe2NvbnN0e29wOnQsd29ya1N0YXRlOnJ9PWUuZGF0YTtsZXQgbj10aGlzLm9sZFNlbGVjdFJlY3Q7aWYocj09PUl0LlN0YXJ0JiYobj10aGlzLmJhY2tUb0Z1bGxMYXllcigpKSwhKHQhPW51bGwmJnQubGVuZ3RoKXx8IXRoaXMudk5vZGVzLmN1ck5vZGVNYXAuc2l6ZSlyZXR1cm57dHlwZTp1dC5Ob25lfTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModCk7Y29uc3Qgcz10aGlzLmNvbXB1dFNlbGVjdG9yKCk7aWYodGhpcy5zZWxlY3RJZHMmJmhoKHRoaXMuc2VsZWN0SWRzLHMuc2VsZWN0SWRzKSlyZXR1cm57dHlwZTp1dC5Ob25lfTt0aGlzLnNlbGVjdElkcz1zLnNlbGVjdElkcztjb25zdCBsPXMuaW50ZXJzZWN0UmVjdDt0aGlzLmRyYXcoUnQuc2VsZWN0b3JJZCx0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIscyksdGhpcy5nZXRTZWxlY3Rlb3JJbmZvKHMuc3ViTm9kZU1hcCksdGhpcy5vbGRTZWxlY3RSZWN0PWw7Y29uc3QgYz10aGlzLmdldENoaWxkcmVuUG9pbnRzKCk7cmV0dXJue3R5cGU6dXQuU2VsZWN0LGRhdGFUeXBlOlB0LkxvY2FsLHJlY3Q6YnQobCxuKSxzZWxlY3RJZHM6cy5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMsc2VsZWN0UmVjdDpsLHNlbGVjdG9yQ29sb3I6dGhpcy5zZWxlY3RvckNvbG9yLHN0cm9rZUNvbG9yOnRoaXMuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLHRleHRPcHQ6dGhpcy50ZXh0T3B0LGNhblRleHRFZGl0OnRoaXMuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSx3aWxsU3luY1NlcnZpY2U6ITAscG9pbnRzOmN9fWNvbnN1bWVBbGwoKXt2YXIgZTtpZigoZT10aGlzLnNlbGVjdElkcykhPW51bGwmJmUubGVuZ3RoJiZ0aGlzLnNlYWxUb0RyYXdMYXllcih0aGlzLnNlbGVjdElkcyksdGhpcy5vbGRTZWxlY3RSZWN0KXtjb25zdCB0PXRoaXMuZ2V0Q2hpbGRyZW5Qb2ludHMoKTtyZXR1cm57dHlwZTp1dC5TZWxlY3QsZGF0YVR5cGU6UHQuTG9jYWwscmVjdDp0aGlzLm9sZFNlbGVjdFJlY3Qsc2VsZWN0SWRzOnRoaXMuc2VsZWN0SWRzLG9wdDp0aGlzLndvcmtPcHRpb25zLHNlbGVjdFJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LHN0cm9rZUNvbG9yOnRoaXMuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLHRleHRPcHQ6dGhpcy50ZXh0T3B0LGNhblRleHRFZGl0OnRoaXMuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSx3aWxsU3luY1NlcnZpY2U6ITEscG9pbnRzOnR9fXJldHVybnt0eXBlOnV0Lk5vbmV9fWNvbnN1bWVTZXJ2aWNlKCl7fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9Y2xlYXJTZWxlY3REYXRhKCl7dGhpcy5zZWxlY3RJZHM9dm9pZCAwLHRoaXMub2xkU2VsZWN0UmVjdD12b2lkIDB9YmFja1RvRnVsbExheWVyKGUpe3ZhciBzLGw7bGV0IHQ7Y29uc3Qgcj1bXSxuPVtdO2Zvcihjb25zdCBjIG9mKChzPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6cy5jaGlsZHJlbil8fFtdKWlmKCEoZSE9bnVsbCYmZS5sZW5ndGgmJiFlLmluY2x1ZGVzKGMuaWQpKSYmYy5pZCE9PVJ0LnNlbGVjdG9ySWQpe2NvbnN0IG89Yy5jbG9uZU5vZGUoITApO05lKGMpJiZvLnNlYWwoKSx0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShjLm5hbWUpLmxlbmd0aHx8ci5wdXNoKG8pLG4ucHVzaChjKTtjb25zdCBmPShsPXRoaXMudk5vZGVzLmdldChjLm5hbWUpKT09bnVsbD92b2lkIDA6bC5yZWN0O2YmJih0PWJ0KHQsZikpfXJldHVybiBuLmZvckVhY2goYz0+Yy5yZW1vdmUoKSksci5sZW5ndGgmJnRoaXMuZnVsbExheWVyLmFwcGVuZCguLi5yKSx0fXNlYWxUb0RyYXdMYXllcihlKXt2YXIgbjtjb25zdCB0PVtdLHI9W107ZS5mb3JFYWNoKHM9Pnt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShzLnRvU3RyaW5nKCkpLmZvckVhY2gobD0+e3ZhciBvO2NvbnN0IGM9bC5jbG9uZU5vZGUoITApO05lKGwpJiZjLnNlYWwoKSwobz10aGlzLmRyYXdMYXllcikhPW51bGwmJm8uZ2V0RWxlbWVudHNCeU5hbWUobC5uYW1lKS5sZW5ndGh8fHQucHVzaChjKSxyLnB1c2gobCl9KX0pLHIuZm9yRWFjaChzPT5zLnJlbW92ZSgpKSx0JiYoKG49dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxuLmFwcGVuZCguLi50KSl9Z2V0U2VsZWN0b3JSZWN0KGUsdCl7dmFyIGw7bGV0IHI7Y29uc3Qgbj0obD1lLnBhcmVudCk9PW51bGw/dm9pZCAwOmwuZ2V0RWxlbWVudEJ5SWQodCkscz1uPT1udWxsP3ZvaWQgMDpuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiBzJiYocj1idChyLHt4Ok1hdGguZmxvb3Iocy54KSx5Ok1hdGguZmxvb3Iocy55KSx3Ok1hdGgucm91bmQocy53aWR0aCksaDpNYXRoLnJvdW5kKHMuaGVpZ2h0KX0pKSxyfWlzQ2FuRmlsbENvbG9yKGUpe3JldHVybiBlPT09dnQuRWxsaXBzZXx8ZT09PXZ0LlRyaWFuZ2xlfHxlPT09dnQuUmVjdGFuZ2xlfHxlPT09dnQuUG9seWdvbnx8ZT09PXZ0LlN0YXJ8fGU9PT12dC5TcGVlY2hCYWxsb29ufXVwZGF0ZVNlbGVjdG9yKGUpe2NvbnN0e3VwZGF0ZVNlbGVjdG9yT3B0OnQsc2VsZWN0SWRzOnIsdk5vZGVzOm4sd2lsbFNlcmlhbGl6ZURhdGE6cyx3b3JrZXI6bH09ZSxjPXRoaXMuZHJhd0xheWVyO2lmKCFjKXJldHVybjtsZXQgbztjb25zdCBmPW5ldyBNYXAse2JveDp4LHdvcmtTdGF0ZTpnLGFuZ2xlOnksdHJhbnNsYXRlOm19PXQ7bGV0IFQ9WzAsMF0sTz1bMSwxXSx2PVswLDBdLFA7aWYoeHx8bXx8ZXIoeSkpe2lmKGc9PT1JdC5TdGFydClyZXR1cm4gbi5zZXRUYXJnZXQoKSx7dHlwZTp1dC5TZWxlY3QsZGF0YVR5cGU6UHQuTG9jYWwsc2VsZWN0UmVjdDp0aGlzLm9sZFNlbGVjdFJlY3QscmVjdDp0aGlzLm9sZFNlbGVjdFJlY3R9O2lmKFA9bi5nZXRMYXN0VGFyZ2V0KCksUCYmeCl7bGV0IHU7cj09bnVsbHx8ci5mb3JFYWNoKGE9Pntjb25zdCBoPVA9PW51bGw/dm9pZCAwOlAuZ2V0KGEpO3U9YnQodSxoPT1udWxsP3ZvaWQgMDpoLnJlY3QpfSksdSYmKE89W3gudy91LncseC5oL3UuaF0sVD1beC54K3gudy8yLSh1LngrdS53LzIpLHgueSt4LmgvMi0odS55K3UuaC8yKV0sdj1bdS54K3Uudy8yLHUueSt1LmgvMl0pfX1yPT1udWxsfHxyLmZvckVhY2godT0+e2NvbnN0IGE9bi5nZXQodSk7aWYoYSl7Y29uc3R7dG9vbHNUeXBlOmh9PWE7bGV0IGI9KGM9PW51bGw/dm9pZCAwOmMuZ2V0RWxlbWVudHNCeU5hbWUodSkpWzBdO2lmKGIpe2NvbnN0IEU9ey4uLnR9O2xldCBBO2lmKGgpe2lmKFAmJihBPVAuZ2V0KHUpLEEmJngpKXtFLmJveFNjYWxlPU87Y29uc3QgUz1bQS5yZWN0LngrQS5yZWN0LncvMixBLnJlY3QueStBLnJlY3QuaC8yXSxJPVtTWzBdLXZbMF0sU1sxXS12WzFdXTtFLmJveFRyYW5zbGF0ZT1bSVswXSooT1swXS0xKStUWzBdLElbMV0qKE9bMV0tMSkrVFsxXV19Y29uc3QgTD1QbihoKTtpZihMPT1udWxsfHxMLnVwZGF0ZU5vZGVPcHQoe25vZGU6YixvcHQ6RSx2Tm9kZXM6bix3aWxsU2VyaWFsaXplRGF0YTpzLHRhcmdldE5vZGU6QX0pLGEmJmwmJihzJiYoRS5hbmdsZXx8RS50cmFuc2xhdGUpfHxFLmJveCYmRS53b3JrU3RhdGUhPT1JdC5TdGFydHx8RS5wb2ludE1hcCYmRS5wb2ludE1hcC5oYXModSkpKXtjb25zdCBTPWwuY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNUeXBlOmgsdG9vbHNPcHQ6YS5vcHR9KTtTPT1udWxsfHxTLnNldFdvcmtJZCh1KTtjb25zdCBJPVM9PW51bGw/dm9pZCAwOlMuY29uc3VtZVNlcnZpY2Uoe29wOmEub3AsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6dSxpc0NsZWFyQWxsOiExfSk7SSYmKGEucmVjdD1JLG4uc2V0SW5mbyh1LGEpKSxiPShjPT1udWxsP3ZvaWQgMDpjLmdldEVsZW1lbnRzQnlOYW1lKHUpKVswXX1hJiYoZi5zZXQodSxhKSxvPWJ0KG8sYS5yZWN0KSl9fX19LHRoaXMpLFAmJmc9PT1JdC5Eb25lJiZuLmRlbGV0ZUxhc3RUYXJnZXQoKSx0aGlzLmRyYXcoUnQuc2VsZWN0b3JJZCxjLHtzZWxlY3RJZHM6cnx8W10sc3ViTm9kZU1hcDpmLGludGVyc2VjdFJlY3Q6b30pO2NvbnN0IGk9YnQodGhpcy5vbGRTZWxlY3RSZWN0LG8pO3JldHVybiB0aGlzLm9sZFNlbGVjdFJlY3Q9byx7dHlwZTp1dC5TZWxlY3QsZGF0YVR5cGU6UHQuTG9jYWwsc2VsZWN0UmVjdDpvLHJlY3Q6aX19Ymx1clNlbGVjdG9yKCl7Y29uc3QgZT10aGlzLmJhY2tUb0Z1bGxMYXllcigpO3JldHVybnt0eXBlOnV0LlNlbGVjdCxkYXRhVHlwZTpQdC5Mb2NhbCxyZWN0OmUsc2VsZWN0SWRzOltdLHdpbGxTeW5jU2VydmljZTohMH19Z2V0UmlnaHRTZXJ2aWNlSWQoZSl7cmV0dXJuIGUucmVwbGFjZSgiKysiLCItIil9c2VsZWN0U2VydmljZU5vZGUoZSx0LHIpe2NvbnN0e3NlbGVjdElkczpufT10LHM9dGhpcy5nZXRSaWdodFNlcnZpY2VJZChlKSxsPXRoaXMuZ2V0U2VsZWN0b3JSZWN0KHRoaXMuZnVsbExheWVyLHMpO2xldCBjO2NvbnN0IG89bmV3IE1hcDtyZXR1cm4gbj09bnVsbHx8bi5mb3JFYWNoKGY9Pntjb25zdCB4PXRoaXMudk5vZGVzLmdldChmKSxnPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGYpWzBdO3gmJmcmJihjPWJ0KGMseC5yZWN0KSxvLnNldChmLHgpKX0pLHRoaXMuZHJhdyhzLHRoaXMuZnVsbExheWVyLHtpbnRlcnNlY3RSZWN0OmMsc2VsZWN0SWRzOm58fFtdLHN1Yk5vZGVNYXA6b30sciksYnQoYyxsKX1yZVJlbmRlclNlbGVjdG9yKCl7dmFyIHI7bGV0IGU7Y29uc3QgdD1uZXcgTWFwO3JldHVybihyPXRoaXMuc2VsZWN0SWRzKT09bnVsbHx8ci5mb3JFYWNoKG49Pntjb25zdCBzPXRoaXMudk5vZGVzLmdldChuKTtzJiYoZT1idChlLHMucmVjdCksdC5zZXQobixzKSl9LHRoaXMpLHRoaXMuZHJhdyhSdC5zZWxlY3RvcklkLHRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7aW50ZXJzZWN0UmVjdDplLHN1Yk5vZGVNYXA6dCxzZWxlY3RJZHM6dGhpcy5zZWxlY3RJZHN8fFtdfSksdGhpcy5nZXRTZWxlY3Rlb3JJbmZvKHQpLHRoaXMub2xkU2VsZWN0UmVjdD1lLGV9dXBkYXRlU2VsZWN0SWRzKGUpe3ZhciBsLGM7bGV0IHQ7Y29uc3Qgcj0obD10aGlzLnNlbGVjdElkcyk9PW51bGw/dm9pZCAwOmwuZmlsdGVyKG89PiFlLmluY2x1ZGVzKG8pKSxuPWUuZmlsdGVyKG89Pnt2YXIgZjtyZXR1cm4hKChmPXRoaXMuc2VsZWN0SWRzKSE9bnVsbCYmZi5pbmNsdWRlcyhvKSl9KTtpZihyIT1udWxsJiZyLmxlbmd0aCYmKHQ9dGhpcy5iYWNrVG9GdWxsTGF5ZXIocikpLG4ubGVuZ3RoKXt0aGlzLnNlYWxUb0RyYXdMYXllcihuKTtmb3IoY29uc3QgbyBvZiBuKXtjb25zdCBmPShjPXRoaXMudk5vZGVzLmdldChvKSk9PW51bGw/dm9pZCAwOmMucmVjdDtmJiYodD1idCh0LGYpKX19dGhpcy5zZWxlY3RJZHM9ZTtjb25zdCBzPXRoaXMucmVSZW5kZXJTZWxlY3RvcigpO3JldHVybntiZ1JlY3Q6dCxzZWxlY3RSZWN0OnN9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoUnQsInNlbGVjdG9ySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpSaH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdCwic2VsZWN0b3JCb3JkZXJJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiJzZWxlY3Rvci1ib3JkZXIifSk7Y2xhc3MgZ24gZXh0ZW5kcyBndHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6S3QuYm90aH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5BcnJvd30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFycm93VGlwV2lkdGgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLmFycm93VGlwV2lkdGg9dGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MqNCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciBtO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxzPShtPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6bS50b1N0cmluZygpO2lmKCFzKXJldHVybnt0eXBlOnV0Lk5vbmV9O2NvbnN0e29wOmwsd29ya1N0YXRlOmN9PXQsbz1sPT1udWxsP3ZvaWQgMDpsLmxlbmd0aDtpZighb3x8bzwyKXJldHVybnt0eXBlOnV0Lk5vbmV9O2xldCBmO2lmKGM9PT1JdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyBPdChsWzBdLGxbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhsKSwhZilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZighbil7Y29uc3QgVD1EYXRlLm5vdygpO3JldHVybiBULXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVQse3R5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnMsb3A6dGhpcy50bXBQb2ludHMubWFwKE89PlsuLi5PLlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6dXQuTm9uZX19Y29uc3QgeD1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixnPXRoaXMuZHJhdyh7d29ya0lkOnMsbGF5ZXI6eH0pLHk9YnQoZyx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9Zyx7cmVjdDp5LHR5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnN9fWNvbnN1bWVBbGwoZSl7dmFyIG87Y29uc3R7ZGF0YTp0fT1lLHI9KG89dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpvLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMuZnVsbExheWVyLHM9dGhpcy5kcmF3KHt3b3JrSWQ6cixsYXllcjpufSk7dGhpcy5vbGRSZWN0PXM7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksYz1rdChsKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0OnMsb3A6bCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjZW50ZXJQb3M6Z3QuZ2V0Q2VudGVyUG9zKHMsbil9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnIsb3BzOmMsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBQO2NvbnN0e3dvcmtJZDp0LGxheWVyOnJ9PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKGk9PmkucmVtb3ZlKCkpLChQPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8UC5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoaT0+aS5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6bix0aGlja25lc3M6cyx6SW5kZXg6bCxzY2FsZTpjLHJvdGF0ZTpvLHRyYW5zbGF0ZTpmfT10aGlzLndvcmtPcHRpb25zLHg9ci53b3JsZFBvc2l0aW9uLGc9ci53b3JsZFNjYWxpbmcse3BvaW50czp5LHJlY3Q6bX09dGhpcy5jb21wdXREcmF3UG9pbnRzKHMpLE89e3BvczpbbS54K20udy8yLG0ueSttLmgvMl0sbmFtZTp0LGlkOnQsY2xvc2U6ITAscG9pbnRzOnksZmlsbENvbG9yOm4sc3Ryb2tlQ29sb3I6bixsaW5lV2lkdGg6MCxub3JtYWxpemU6ITAsekluZGV4Omx9O2MmJihPLnNjYWxlPWMpLG8mJihPLnJvdGF0ZT1vKSxmJiYoTy50cmFuc2xhdGU9Zik7Y29uc3Qgdj1uZXcgcXQoTyk7aWYoci5hcHBlbmQodiksY3x8b3x8Zil7Y29uc3QgaT12LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaS54LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaS55LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaS53aWR0aCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaS5oZWlnaHQrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybnt4Ok1hdGguZmxvb3IobS54KmdbMF0reFswXS1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKG0ueSpnWzFdK3hbMV0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihtLncqZ1swXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IobS5oKmdbMV0rMipndC5TYWZlQm9yZGVyUGFkZGluZyl9fWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMudG1wUG9pbnRzWzFdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzWzBdKT50aGlzLmFycm93VGlwV2lkdGg/dGhpcy5jb21wdXRGdWxsQXJyb3dQb2ludHMoZSk6dGhpcy5jb21wdXRUcmlhbmdsZVBvaW50cygpfWNvbXB1dEZ1bGxBcnJvd1BvaW50cyhlKXtjb25zdCB0PV8uU3ViKHRoaXMudG1wUG9pbnRzWzFdLHRoaXMudG1wUG9pbnRzWzBdKS51bmkoKSxyPV8uUGVyKHQpLm11bChlLzIpLG49T3QuU3ViKHRoaXMudG1wUG9pbnRzWzBdLHIpLHM9T3QuQWRkKHRoaXMudG1wUG9pbnRzWzBdLHIpLGw9Xy5NdWwodCx0aGlzLmFycm93VGlwV2lkdGgpLGM9Xy5TdWIodGhpcy50bXBQb2ludHNbMV0sbCksbz1PdC5TdWIoYyxyKSxmPU90LkFkZChjLHIpLHg9Xy5QZXIodCkubXVsKGUqMS41KSxnPU90LlN1YihjLHgpLHk9T3QuQWRkKGMseCksbT1bbixvLGcsdGhpcy50bXBQb2ludHNbMV0seSxmLHNdO3JldHVybntwb2ludHM6bS5tYXAoVD0+T3QuU3ViKFQsdGhpcy50bXBQb2ludHNbMF0pLlhZKS5mbGF0KDEpLHJlY3Q6TnQobSksaXNUcmlhbmdsZTohMSxwb3M6dGhpcy50bXBQb2ludHNbMF0uWFl9fWNvbXB1dFRyaWFuZ2xlUG9pbnRzKCl7Y29uc3QgZT1fLlN1Yih0aGlzLnRtcFBvaW50c1sxXSx0aGlzLnRtcFBvaW50c1swXSkudW5pKCksdD10aGlzLnRtcFBvaW50c1sxXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1swXSkscj1fLlBlcihlKS5tdWwoTWF0aC5mbG9vcih0KjMvOCkpLG49T3QuU3ViKHRoaXMudG1wUG9pbnRzWzBdLHIpLHM9T3QuQWRkKHRoaXMudG1wUG9pbnRzWzBdLHIpLGw9W24sdGhpcy50bXBQb2ludHNbMV0sc107cmV0dXJue3BvaW50czpsLm1hcChjPT5PdC5TdWIoYyx0aGlzLnRtcFBvaW50c1swXSkuWFkpLmZsYXQoMSkscmVjdDpOdChsKSxpc1RyaWFuZ2xlOiEwLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IE90KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOnN9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixzKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgYztjb25zdHtvcDp0LGlzRnVsbFdvcms6cn09ZSxuPShjPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Yy50b1N0cmluZygpO2lmKCFuKXJldHVybjt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rPTMpdGhpcy50bXBQb2ludHMucHVzaChuZXcgT3QodFtvXSx0W28rMV0sdFtvKzJdKSk7Y29uc3Qgcz1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixsPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6c30pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNlbnRlclBvczpndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgYztjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOnN9PXIsbD1uLmdldCh0Lm5hbWUpO3JldHVybiBzJiYodC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixzKSx0LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixzKSwoYz1sPT1udWxsP3ZvaWQgMDpsLm9wdCkhPW51bGwmJmMuc3Ryb2tlQ29sb3ImJihsLm9wdC5zdHJva2VDb2xvcj1zKSxsJiZuLnNldEluZm8odC5uYW1lLGwpKSxndC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBtbiBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dnQuRWxsaXBzZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgbTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUscz0obT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm0udG9TdHJpbmcoKTtpZighcylyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHtvcDpsLHdvcmtTdGF0ZTpjfT10LG89bD09bnVsbD92b2lkIDA6bC5sZW5ndGg7aWYoIW98fG88MilyZXR1cm57dHlwZTp1dC5Ob25lfTtsZXQgZjtpZihjPT09SXQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgT3QobFswXSxsWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMobCksIWYpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYoIW4pe2NvbnN0IFQ9RGF0ZS5ub3coKTtyZXR1cm4gVC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1ULHt0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDpzLG9wOnRoaXMudG1wUG9pbnRzLm1hcChPPT5bLi4uTy5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOnV0Lk5vbmV9fWNvbnN0IHg9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsZz10aGlzLmRyYXcoe3dvcmtJZDpzLGxheWVyOngsaXNEcmF3aW5nOiEwfSkseT1idChnLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1nLHtyZWN0OnksdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6c319Y29uc3VtZUFsbChlKXt2YXIgbztjb25zdHtkYXRhOnR9PWUscj0obz10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm8udG9TdHJpbmcoKTtpZighcilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTp1dC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbcl19O2NvbnN0IG49dGhpcy5mdWxsTGF5ZXIscz10aGlzLmRyYXcoe3dvcmtJZDpyLGxheWVyOm4saXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PXM7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksYz1rdChsKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0OnMsb3A6bCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjZW50ZXJQb3M6cyYmZ3QuZ2V0Q2VudGVyUG9zKHMsbil9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnIsb3BzOmMsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBhO2NvbnN0e3dvcmtJZDp0LGxheWVyOnIsaXNEcmF3aW5nOm59PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKGg9PmgucmVtb3ZlKCkpLChhPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8YS5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoaD0+aC5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bCx0aGlja25lc3M6Yyx6SW5kZXg6byxzY2FsZTpmLHJvdGF0ZTp4LHRyYW5zbGF0ZTpnfT10aGlzLndvcmtPcHRpb25zLHk9ci53b3JsZFBvc2l0aW9uLG09ci53b3JsZFNjYWxpbmcse3JhZGl1czpULHJlY3Q6Tyxwb3M6dn09dGhpcy5jb21wdXREcmF3UG9pbnRzKGMpLFA9e3Bvczp2LG5hbWU6dCxpZDp0LHJhZGl1czpULGxpbmVXaWR0aDpjLGZpbGxDb2xvcjpsIT09InRyYW5zcGFyZW50IiYmbHx8dm9pZCAwLHN0cm9rZUNvbG9yOnMsbm9ybWFsaXplOiEwLHpJbmRleDpvfSxpPXt4Ok1hdGguZmxvb3IoTy54Km1bMF0reVswXS1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKE8ueSptWzFdK3lbMV0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihPLncqbVswXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IoTy5oKm1bMV0rMipndC5TYWZlQm9yZGVyUGFkZGluZyl9O2lmKG4pe2NvbnN0e25hbWU6aCxpZDpiLHpJbmRleDpFLHN0cm9rZUNvbG9yOkF9PVAsTD1ndC5nZXRDZW50ZXJQb3MoaSxyKSxTPW5ldyBlZSh7bmFtZTpoLGlkOmIsekluZGV4OkUscG9zOkwsYW5jaG9yOlsuNSwuNV0sc2l6ZTpbaS53LGkuaF19KSxJPW5ldyB1bih7Li4uUCxwb3M6WzAsMF19KSxEPW5ldyBzZSh7ZDoiTS00LDBINE0wLC00VjQiLG5vcm1hbGl6ZTohMCxwb3M6WzAsMF0sc3Ryb2tlQ29sb3I6QSxsaW5lV2lkdGg6MSxzY2FsZTpbMS9tWzBdLDEvbVsxXV19KTtyZXR1cm4gUy5hcHBlbmQoSSxEKSxyLmFwcGVuZChTKSxpfWYmJihQLnNjYWxlPWYpLHgmJihQLnJvdGF0ZT14KSxnJiYoUC50cmFuc2xhdGU9Zyk7Y29uc3QgdT1uZXcgdW4oUCk7aWYoci5hcHBlbmQodSkseHx8Znx8Zyl7Y29uc3QgaD11LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaC54LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaC55LWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaC53aWR0aCtndC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaC5oZWlnaHQrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybiBpfWNvbXB1dERyYXdQb2ludHMoZSl7Y29uc3QgdD1OdCh0aGlzLnRtcFBvaW50cykscj1OdCh0aGlzLnRtcFBvaW50cyxlKSxuPVtNYXRoLmZsb29yKHQueCt0LncvMiksTWF0aC5mbG9vcih0LnkrdC5oLzIpXTtyZXR1cm57cmVjdDpyLHBvczpuLHJhZGl1czpbTWF0aC5mbG9vcih0LncvMiksTWF0aC5mbG9vcih0LmgvMildfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMikscj1uZXcgT3QodFswXSx0WzFdKSxuPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6c309dGhpcy53b3JrT3B0aW9ucztpZihuLmlzTmVhcihyLHMpKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNlbnRlclBvczpndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZix4O2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bH09cixjPW4uZ2V0KHQubmFtZSk7bGV0IG89dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKG89dC5jaGlsZHJlblswXSkscyYmKG8uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscyksKGY9Yz09bnVsbD92b2lkIDA6Yy5vcHQpIT1udWxsJiZmLnN0cm9rZUNvbG9yJiYoYy5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJihsPT09InRyYW5zcGFyZW50Ij9vLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOm8uc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGwpLCh4PWM9PW51bGw/dm9pZCAwOmMub3B0KSE9bnVsbCYmeC5maWxsQ29sb3ImJihjLm9wdC5maWxsQ29sb3I9bCkpLGMmJm4uc2V0SW5mbyh0Lm5hbWUsYyksZ3QudXBkYXRlTm9kZU9wdChlKX19dmFyIExoPXJlLERoPXRlLHdoPSJbb2JqZWN0IEJvb2xlYW5dIjtmdW5jdGlvbiBOaChkKXtyZXR1cm4gZD09PSEwfHxkPT09ITF8fERoKGQpJiZMaChkKT09d2h9dmFyIGpoPU5oLHZlPXBlKGpoKTtjbGFzcyB2biBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dnQuUmVjdGFuZ2xlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH10cmFuc2Zvcm1EYXRhKCl7Y29uc3QgZT1OdCh0aGlzLnRtcFBvaW50cyk7cmV0dXJuW1tlLngsZS55LDBdLFtlLngrZS53LGUueSwwXSxbZS54K2UudyxlLnkrZS5oLDBdLFtlLngsZS55K2UuaCwwXV19Y29tcHV0RHJhd1BvaW50cyhlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxyPVtdO2Zvcihjb25zdCBsIG9mIGUpci5wdXNoKG5ldyBfKC4uLmwpKTtjb25zdCBuPU50KHIsdCkscz1bbi54K24udy8yLG4ueStuLmgvMl07cmV0dXJue3JlY3Q6bixwb3M6cyxwb2ludHM6ci5tYXAobD0+bC5YWSkuZmxhdCgxKX19Y29uc3VtZShlKXt2YXIgVDtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUscz0oVD10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOlQudG9TdHJpbmcoKTtpZighcylyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHtvcDpsLHdvcmtTdGF0ZTpjfT10LG89bD09bnVsbD92b2lkIDA6bC5sZW5ndGg7aWYoIW98fG88MilyZXR1cm57dHlwZTp1dC5Ob25lfTtsZXQgZjtpZihjPT09SXQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgT3QobFswXSxsWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMobCksIWYpcmV0dXJue3R5cGU6dXQuTm9uZX07Y29uc3QgeD10aGlzLnRyYW5zZm9ybURhdGEoKTtpZighbil7Y29uc3QgTz1EYXRlLm5vdygpO3JldHVybiBPLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPU8se3R5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnMsb3A6eC5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6dXQuTm9uZX19Y29uc3QgZz1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix5PXRoaXMuZHJhdyh7cHM6eCx3b3JrSWQ6cyxsYXllcjpnLGlzRHJhd2luZzohMH0pLG09YnQoeSx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9eSx7cmVjdDptLHR5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnN9fWNvbnN1bWVBbGwoZSl7dmFyIGY7Y29uc3R7ZGF0YTp0fT1lLHI9KGY9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMudHJhbnNmb3JtRGF0YSgpLHM9dGhpcy5mdWxsTGF5ZXIsbD10aGlzLmRyYXcoe3BzOm4sd29ya0lkOnIsbGF5ZXI6cyxpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9bDtjb25zdCBjPW4uZmxhdCgxKSxvPWt0KGMpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6bCxvcDpjLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpsJiZndC5nZXRDZW50ZXJQb3MobCxzKX0pLHtyZWN0OmwsdHlwZTp1dC5GdWxsV29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6cixvcHM6byxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIEE7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cixpc0RyYXdpbmc6bixwczpzLHJlcGxhY2VJZDpsfT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGx8fHQpLm1hcChMPT5MLnJlbW92ZSgpKSwoQT10aGlzLmRyYXdMYXllcik9PW51bGx8fEEuZ2V0RWxlbWVudHNCeU5hbWUobHx8dCkubWFwKEw9PkwucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOmMsZmlsbENvbG9yOm8sdGhpY2tuZXNzOmYsekluZGV4Ongsc2NhbGU6Zyxyb3RhdGU6eSx0cmFuc2xhdGU6bSx0ZXh0T3B0OlR9PXRoaXMud29ya09wdGlvbnMsTz1yLndvcmxkUG9zaXRpb24sdj1yLndvcmxkU2NhbGluZyx7cG9pbnRzOlAscmVjdDppLHBvczp1fT10aGlzLmNvbXB1dERyYXdQb2ludHMocyksYT17Y2xvc2U6ITAsbm9ybWFsaXplOiEwLHBvaW50czpQLGxpbmVXaWR0aDpmLGZpbGxDb2xvcjpvIT09InRyYW5zcGFyZW50IiYmb3x8dm9pZCAwLHN0cm9rZUNvbG9yOmMsbGluZUpvaW46InJvdW5kIn0saD17eDpNYXRoLmZsb29yKGkueCp2WzBdK09bMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihpLnkqdlsxXStPWzFdLWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaS53KnZbMF0rMipndC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKGkuaCp2WzBdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcpfSxiPW5ldyBlZSh7bmFtZTp0LGlkOnQsekluZGV4OngscG9zOnUsYW5jaG9yOlsuNSwuNV0sc2l6ZTpbaS53LGkuaF0sc2NhbGU6Zyxyb3RhdGU6eSx0cmFuc2xhdGU6bX0pLEU9bmV3IHF0KHsuLi5hLHBvczpbMCwwXX0pO2lmKGIuYXBwZW5kQ2hpbGQoRSksbil7Y29uc3QgTD1uZXcgc2Uoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOmMsbGluZVdpZHRoOjEsc2NhbGU6WzEvdlswXSwxL3ZbMV1dfSk7Yi5hcHBlbmRDaGlsZChMKX1pZihyLmFwcGVuZChiKSxnfHx5fHxtKXtjb25zdCBMPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihMLngtZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihMLnktZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihMLndpZHRoKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmhlaWdodCsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKX19cmV0dXJuIGh9dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IE90KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOnN9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixzKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgZjtjb25zdHtvcDp0LGlzRnVsbFdvcms6cixyZXBsYWNlSWQ6bn09ZSxzPShmPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Zi50b1N0cmluZygpO2lmKCFzKXJldHVybjtjb25zdCBsPVtdO2ZvcihsZXQgeD0wO3g8dC5sZW5ndGg7eCs9MylsLnB1c2goW3RbeF0sdFt4KzFdLHRbeCsyXV0pO2NvbnN0IGM9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsbz10aGlzLmRyYXcoe3BzOmwsd29ya0lkOnMsbGF5ZXI6Yyxpc0RyYXdpbmc6ITEscmVwbGFjZUlkOm59KTtyZXR1cm4gdGhpcy5vbGRSZWN0PW8sdGhpcy52Tm9kZXMuc2V0SW5mbyhzLHtyZWN0Om8sb3A6dCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6byYmZ3QuZ2V0Q2VudGVyUG9zKG8sYyl9KSxvfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7dmFyIHYsUDtjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOnMsZmlsbENvbG9yOmwsZm9udENvbG9yOmMsZm9udEJnQ29sb3I6byxib2xkOmYsaXRhbGljOngsbGluZVRocm91Z2g6Zyx1bmRlcmxpbmU6eSxmb250U2l6ZTptfT1yLFQ9bi5nZXQodC5uYW1lKTtsZXQgTz10O2lmKHQudGFnTmFtZT09PSJHUk9VUCImJihPPXQuY2hpbGRyZW5bMF0pLHMmJihPLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHMpLCh2PVQ9PW51bGw/dm9pZCAwOlQub3B0KSE9bnVsbCYmdi5zdHJva2VDb2xvciYmKFQub3B0LnN0cm9rZUNvbG9yPXMpKSxsJiYobD09PSJ0cmFuc3BhcmVudCI/Ty5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsInJnYmEoMCwwLDAsMCkiKTpPLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixsKSwoUD1UPT1udWxsP3ZvaWQgMDpULm9wdCkhPW51bGwmJlAuZmlsbENvbG9yJiYoVC5vcHQuZmlsbENvbG9yPWwpKSxUIT1udWxsJiZULm9wdC50ZXh0T3B0KXtjb25zdCBpPVQub3B0LnRleHRPcHQ7YyYmaS5mb250Q29sb3ImJihpLmZvbnRDb2xvcj1jKSxvJiZpLmZvbnRCZ0NvbG9yJiYoaS5mb250QmdDb2xvcj1vKSxmJiYoaS5ib2xkPWYpLHgmJihpLml0YWxpYz14KSx2ZShnKSYmKGkubGluZVRocm91Z2g9ZyksdmUoeSkmJihpLnVuZGVybGluZT15KSxtJiYoaS5mb250U2l6ZT1tKX1yZXR1cm4gVCYmbi5zZXRJbmZvKHQubmFtZSxUKSxndC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBwbiBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dnQuU3Rhcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgbTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUscz0obT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm0udG9TdHJpbmcoKTtpZighcylyZXR1cm57dHlwZTp1dC5Ob25lfTtjb25zdHtvcDpsLHdvcmtTdGF0ZTpjfT10LG89bD09bnVsbD92b2lkIDA6bC5sZW5ndGg7aWYoIW98fG88MilyZXR1cm57dHlwZTp1dC5Ob25lfTtsZXQgZjtpZihjPT09SXQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgT3QobFswXSxsWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMobCksIWYpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYoIW4pe2NvbnN0IFQ9RGF0ZS5ub3coKTtyZXR1cm4gVC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1ULHt0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDpzLG9wOnRoaXMudG1wUG9pbnRzLm1hcChPPT5bLi4uTy5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOnV0Lk5vbmV9fWNvbnN0IHg9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsZz10aGlzLmRyYXcoe3dvcmtJZDpzLGxheWVyOngsaXNEcmF3aW5nOiEwfSkseT1idChnLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1nLHtyZWN0OnksdHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6c319Y29uc3VtZUFsbChlKXt2YXIgbztjb25zdHtkYXRhOnR9PWUscj0obz10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOm8udG9TdHJpbmcoKTtpZighcilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTp1dC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbcl19O2NvbnN0IG49dGhpcy5mdWxsTGF5ZXIscz10aGlzLmRyYXcoe3dvcmtJZDpyLGxheWVyOm4saXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PXM7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksYz1rdChsKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0OnMsb3A6bCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cyYmZ3QuZ2V0Q2VudGVyUG9zKHMsbil9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnIsb3BzOmMsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBFO2NvbnN0e3dvcmtJZDp0LGxheWVyOnIsaXNEcmF3aW5nOm59PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKEE9PkEucmVtb3ZlKCkpLChFPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8RS5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoQT0+QS5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bCx0aGlja25lc3M6Yyx6SW5kZXg6byx2ZXJ0aWNlczpmLGlubmVyVmVydGljZVN0ZXA6eCxpbm5lclJhdGlvOmcsc2NhbGU6eSxyb3RhdGU6bSx0cmFuc2xhdGU6VH09dGhpcy53b3JrT3B0aW9ucyxPPXIud29ybGRQb3NpdGlvbix2PXIud29ybGRTY2FsaW5nLHtyZWN0OlAscG9zOmkscG9pbnRzOnV9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhjLGYseCxnKSxhPXtwb3M6aSxjbG9zZTohMCxuYW1lOnQsaWQ6dCxwb2ludHM6dSxsaW5lV2lkdGg6YyxmaWxsQ29sb3I6bCE9PSJ0cmFuc3BhcmVudCImJmx8fHZvaWQgMCxzdHJva2VDb2xvcjpzLGNsYXNzTmFtZTpgJHtpWzBdfSwke2lbMV19YCxub3JtYWxpemU6ITAsekluZGV4Om8sbGluZUpvaW46InJvdW5kIn0saD17eDpNYXRoLmZsb29yKFAueCp2WzBdK09bMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcqdlswXSkseTpNYXRoLmZsb29yKFAueSp2WzFdK09bMV0tZ3QuU2FmZUJvcmRlclBhZGRpbmcqdlsxXSksdzpNYXRoLmZsb29yKFAudyp2WzBdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcqdlswXSksaDpNYXRoLmZsb29yKFAuaCp2WzFdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcqdlsxXSl9O2lmKG4pe2NvbnN0e25hbWU6QSxpZDpMLHpJbmRleDpTLHN0cm9rZUNvbG9yOkl9PWEsRD1bKGgueCtoLncvMi1PWzBdKS92WzBdLChoLnkraC5oLzItT1sxXSkvdlsxXV0sUj1uZXcgZWUoe25hbWU6QSxpZDpMLHpJbmRleDpTLHBvczpELGFuY2hvcjpbLjUsLjVdLHNpemU6W2gudyxoLmhdfSksQz1uZXcgcXQoey4uLmEscG9zOlswLDBdfSksaj1uZXcgc2Uoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOkksbGluZVdpZHRoOjEsc2NhbGU6WzEvdlswXSwxL3ZbMV1dfSk7cmV0dXJuIFIuYXBwZW5kKEMsaiksci5hcHBlbmQoUiksaH15JiYoYS5zY2FsZT15KSxtJiYoYS5yb3RhdGU9bSksVCYmKGEudHJhbnNsYXRlPVQpO2NvbnN0IGI9bmV3IHF0KGEpO2lmKHIuYXBwZW5kKGIpLHl8fG18fFQpe2NvbnN0IEE9Yi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKEEueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEEueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEEud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKEEuaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gaH1jb21wdXREcmF3UG9pbnRzKGUsdCxyLG4pe2NvbnN0IHM9TnQodGhpcy50bXBQb2ludHMpLGw9W01hdGguZmxvb3Iocy54K3Mudy8yKSxNYXRoLmZsb29yKHMueStzLmgvMildLGM9bG4ocy53LHMuaCksbz1NYXRoLmZsb29yKE1hdGgubWluKHMudyxzLmgpLzIpLGY9bipvLHg9W10sZz0yKk1hdGguUEkvdDtmb3IobGV0IG09MDttPHQ7bSsrKXtjb25zdCBUPW0qZy0uNSpNYXRoLlBJO2xldCBPLHY7bSVyPT09MT8oTz1mKmNbMF0qTWF0aC5jb3MoVCksdj1mKmNbMV0qTWF0aC5zaW4oVCkpOihPPW8qY1swXSpNYXRoLmNvcyhUKSx2PW8qY1sxXSpNYXRoLnNpbihUKSx4LnB1c2goTyx2KSkseC5wdXNoKE8sdil9cmV0dXJue3JlY3Q6TnQodGhpcy50bXBQb2ludHMsZSkscG9zOmwscG9pbnRzOnh9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyBPdCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpzfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIscyl8fE90LlN1YihuLHIpLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpsJiZndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZix4O2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bH09cixjPW4uZ2V0KHQubmFtZSk7bGV0IG89dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKG89dC5jaGlsZHJlblswXSkscyYmKG8uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscyksKGY9Yz09bnVsbD92b2lkIDA6Yy5vcHQpIT1udWxsJiZmLnN0cm9rZUNvbG9yJiYoYy5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJihsPT09InRyYW5zcGFyZW50Ij9vLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOm8uc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGwpLCh4PWM9PW51bGw/dm9pZCAwOmMub3B0KSE9bnVsbCYmeC5maWxsQ29sb3ImJihjLm9wdC5maWxsQ29sb3I9bCkpLGMmJm4uc2V0SW5mbyh0Lm5hbWUsYyksZ3QudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgeW4gZXh0ZW5kcyBndHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6S3QuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZ0LlBvbHlnb259KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfWNvbnN1bWUoZSl7dmFyIG07Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6cixpc1N1YldvcmtlcjpufT1lLHM9KG09dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDptLnRvU3RyaW5nKCk7aWYoIXMpcmV0dXJue3R5cGU6dXQuTm9uZX07Y29uc3R7b3A6bCx3b3JrU3RhdGU6Y309dCxvPWw9PW51bGw/dm9pZCAwOmwubGVuZ3RoO2lmKCFvfHxvPDIpcmV0dXJue3R5cGU6dXQuTm9uZX07bGV0IGY7aWYoYz09PUl0LlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IE90KGxbMF0sbFsxXSldLGY9ITEpOmY9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGwpLCFmKXJldHVybnt0eXBlOnV0Lk5vbmV9O2lmKCFuKXtjb25zdCBUPURhdGUubm93KCk7cmV0dXJuIFQtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lPyh0aGlzLnN5bmNUaW1lc3RhbXA9VCx7dHlwZTp1dC5EcmF3V29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6cyxvcDp0aGlzLnRtcFBvaW50cy5tYXAoTz0+Wy4uLk8uWFksMF0pLmZsYXQoMSksaXNTeW5jOiEwLGluZGV4OjB9KTp7dHlwZTp1dC5Ob25lfX1jb25zdCB4PXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGc9dGhpcy5kcmF3KHt3b3JrSWQ6cyxsYXllcjp4LGlzRHJhd2luZzohMH0pLHk9YnQoZyx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9Zyx7cmVjdDp5LHR5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnN9fWNvbnN1bWVBbGwoZSl7dmFyIG87Y29uc3R7ZGF0YTp0fT1lLHI9KG89dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpvLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMuZnVsbExheWVyLHM9dGhpcy5kcmF3KHt3b3JrSWQ6cixsYXllcjpuLGlzRHJhd2luZzohMX0pO3RoaXMub2xkUmVjdD1zO2NvbnN0IGw9dGhpcy50bXBQb2ludHMubWFwKGY9PlsuLi5mLlhZLDBdKS5mbGF0KDEpLGM9a3QobCk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8ocix7cmVjdDpzLG9wOmwsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOnMmJmd0LmdldENlbnRlclBvcyhzLG4pfSkse3JlY3Q6cyx0eXBlOnV0LkZ1bGxXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDpyLG9wczpjLGlzU3luYzohMH19ZHJhdyhlKXt2YXIgaDtjb25zdHt3b3JrSWQ6dCxsYXllcjpyLGlzRHJhd2luZzpufT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChiPT5iLnJlbW92ZSgpKSwoaD10aGlzLmRyYXdMYXllcik9PW51bGx8fGguZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKGI9PmIucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOnMsZmlsbENvbG9yOmwsdGhpY2tuZXNzOmMsekluZGV4Om8sdmVydGljZXM6ZixzY2FsZTp4LHJvdGF0ZTpnLHRyYW5zbGF0ZTp5fT10aGlzLndvcmtPcHRpb25zLG09ci53b3JsZFBvc2l0aW9uLFQ9ci53b3JsZFNjYWxpbmcse3JlY3Q6Tyxwb3M6dixwb2ludHM6UH09dGhpcy5jb21wdXREcmF3UG9pbnRzKGMsZiksaT17cG9zOnYsY2xvc2U6ITAsbmFtZTp0LGlkOnQscG9pbnRzOlAsbGluZVdpZHRoOmMsZmlsbENvbG9yOmwhPT0idHJhbnNwYXJlbnQiJiZsfHx2b2lkIDAsc3Ryb2tlQ29sb3I6cyxub3JtYWxpemU6ITAsekluZGV4Om8sbGluZUpvaW46InJvdW5kIn0sdT17eDpNYXRoLmZsb29yKE8ueCpUWzBdK21bMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcqVFswXSkseTpNYXRoLmZsb29yKE8ueSpUWzFdK21bMV0tZ3QuU2FmZUJvcmRlclBhZGRpbmcqVFsxXSksdzpNYXRoLmZsb29yKE8udypUWzBdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcqVFswXSksaDpNYXRoLmZsb29yKE8uaCpUWzFdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcqVFsxXSl9O2lmKG4pe2NvbnN0e25hbWU6YixpZDpFLHpJbmRleDpBLHN0cm9rZUNvbG9yOkx9PWksUz1bKHUueCt1LncvMi1tWzBdKS9UWzBdLCh1LnkrdS5oLzItbVsxXSkvVFsxXV0sST1uZXcgZWUoe25hbWU6YixpZDpFLHpJbmRleDpBLHBvczpTLGFuY2hvcjpbLjUsLjVdLHNpemU6W3Uudyx1LmhdfSksRD1uZXcgcXQoey4uLmkscG9zOlswLDBdfSksUj1uZXcgc2Uoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOkwsbGluZVdpZHRoOjEsc2NhbGU6WzEvVFswXSwxL1RbMV1dfSk7cmV0dXJuIEkuYXBwZW5kKEQsUiksci5hcHBlbmQoSSksdX14JiYoaS5zY2FsZT14KSxnJiYoaS5yb3RhdGU9ZykseSYmKGkudHJhbnNsYXRlPXkpO2NvbnN0IGE9bmV3IHF0KGkpO2lmKHIuYXBwZW5kKGEpLHh8fGd8fHkpe2NvbnN0IGI9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKGIueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKGIueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKGIud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKGIuaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gdX1jb21wdXREcmF3UG9pbnRzKGUsdCl7Y29uc3Qgcj1OdCh0aGlzLnRtcFBvaW50cyksbj1bTWF0aC5mbG9vcihyLngrci53LzIpLE1hdGguZmxvb3Ioci55K3IuaC8yKV0scz1sbihyLncsci5oKSxsPU1hdGguZmxvb3IoTWF0aC5taW4oci53LHIuaCkvMiksYz1bXSxvPTIqTWF0aC5QSS90O2ZvcihsZXQgeD0wO3g8dDt4Kyspe2NvbnN0IGc9eCpvLS41Kk1hdGguUEkseT1sKnNbMF0qTWF0aC5jb3MoZyksbT1sKnNbMV0qTWF0aC5zaW4oZyk7Yy5wdXNoKHksbSl9cmV0dXJue3JlY3Q6TnQodGhpcy50bXBQb2ludHMsZSkscG9zOm4scG9pbnRzOmN9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyBPdCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpzfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIscyl8fE90LlN1YihuLHIpLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpsJiZndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZix4O2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bH09cixjPW4uZ2V0KHQubmFtZSk7bGV0IG89dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKG89dC5jaGlsZHJlblswXSkscyYmKG8uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscyksKGY9Yz09bnVsbD92b2lkIDA6Yy5vcHQpIT1udWxsJiZmLnN0cm9rZUNvbG9yJiYoYy5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJihsPT09InRyYW5zcGFyZW50Ij9vLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOm8uc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGwpLCh4PWM9PW51bGw/dm9pZCAwOmMub3B0KSE9bnVsbCYmeC5maWxsQ29sb3ImJihjLm9wdC5maWxsQ29sb3I9bCkpLGMmJm4uc2V0SW5mbyh0Lm5hbWUsYyksZ3QudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgSnR7c3RhdGljIGJlemllcihlLHQpe2NvbnN0IHI9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKz00KXtjb25zdCBzPXRbbl0sbD10W24rMV0sYz10W24rMl0sbz10W24rM107cyYmbCYmYyYmbz9yLnB1c2goLi4uSnQuZ2V0QmV6aWVyUG9pbnRzKGUscyxsLGMsbykpOnMmJmwmJmM/ci5wdXNoKC4uLkp0LmdldEJlemllclBvaW50cyhlLHMsbCxjKSk6cyYmbD9yLnB1c2goLi4uSnQuZ2V0QmV6aWVyUG9pbnRzKGUscyxsKSk6cyYmci5wdXNoKHMpfXJldHVybiByfXN0YXRpYyBnZXRCZXppZXJQb2ludHMoZT0xMCx0LHIsbixzKXtsZXQgbD1udWxsO2NvbnN0IGM9W107IW4mJiFzP2w9SnQub25lQmV6aWVyOm4mJiFzP2w9SnQudHdvQmV6aWVyOm4mJnMmJihsPUp0LnRocmVlQmV6aWVyKTtmb3IobGV0IG89MDtvPGU7bysrKWwmJmMucHVzaChsKG8vZSx0LHIsbixzKSk7cmV0dXJuIHM/Yy5wdXNoKHMpOm4mJmMucHVzaChuKSxjfXN0YXRpYyBvbmVCZXppZXIoZSx0LHIpe2NvbnN0IG49dC54KyhyLngtdC54KSplLHM9dC55KyhyLnktdC55KSplO3JldHVybiBuZXcgXyhuLHMpfXN0YXRpYyB0d29CZXppZXIoZSx0LHIsbil7Y29uc3Qgcz0oMS1lKSooMS1lKSp0LngrMiplKigxLWUpKnIueCtlKmUqbi54LGw9KDEtZSkqKDEtZSkqdC55KzIqZSooMS1lKSpyLnkrZSplKm4ueTtyZXR1cm4gbmV3IF8ocyxsKX1zdGF0aWMgdGhyZWVCZXppZXIoZSx0LHIsbixzKXtjb25zdCBsPXQueCooMS1lKSooMS1lKSooMS1lKSszKnIueCplKigxLWUpKigxLWUpKzMqbi54KmUqZSooMS1lKStzLngqZSplKmUsYz10LnkqKDEtZSkqKDEtZSkqKDEtZSkrMypyLnkqZSooMS1lKSooMS1lKSszKm4ueSplKmUqKDEtZSkrcy55KmUqZSplO3JldHVybiBuZXcgXyhsLGMpfX1jbGFzcyB4biBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpLdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dnQuU3BlZWNoQmFsbG9vbn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJyYXRpbyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOi44fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciBtO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxzPShtPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6bS50b1N0cmluZygpO2lmKCFzKXJldHVybnt0eXBlOnV0Lk5vbmV9O2NvbnN0e29wOmwsd29ya1N0YXRlOmN9PXQsbz1sPT1udWxsP3ZvaWQgMDpsLmxlbmd0aDtpZighb3x8bzwyKXJldHVybnt0eXBlOnV0Lk5vbmV9O2xldCBmO2lmKGM9PT1JdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyBPdChsWzBdLGxbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhsKSwhZilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZighbil7Y29uc3QgVD1EYXRlLm5vdygpO3JldHVybiBULXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVQse3R5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnMsb3A6dGhpcy50bXBQb2ludHMubWFwKE89PlsuLi5PLlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6dXQuTm9uZX19Y29uc3QgeD1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixnPXRoaXMuZHJhdyh7d29ya0lkOnMsbGF5ZXI6eCxpc0RyYXdpbmc6ITB9KSx5PWJ0KGcsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWcse3JlY3Q6eSx0eXBlOnV0LkRyYXdXb3JrLGRhdGFUeXBlOlB0LkxvY2FsLHdvcmtJZDpzfX1jb25zdW1lQWxsKGUpe3ZhciBvO2NvbnN0e2RhdGE6dH09ZSxyPShvPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6by50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOnV0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOnV0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixzPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bixpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9cztjb25zdCBsPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxjPWt0KGwpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6cyxvcDpsLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpzJiZndC5nZXRDZW50ZXJQb3MocyxuKX0pLHtyZWN0OnMsdHlwZTp1dC5GdWxsV29yayxkYXRhVHlwZTpQdC5Mb2NhbCx3b3JrSWQ6cixvcHM6Yyxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGE7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoaD0+aC5yZW1vdmUoKSksKGE9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxhLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChoPT5oLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjpuLGZpbGxDb2xvcjpzLHRoaWNrbmVzczpsLHpJbmRleDpjLHBsYWNlbWVudDpvLHNjYWxlOmYscm90YXRlOngsdHJhbnNsYXRlOmd9PXRoaXMud29ya09wdGlvbnMseT1yLndvcmxkUG9zaXRpb24sbT1yLndvcmxkU2NhbGluZyx7cmVjdDpULHBvczpPLHBvaW50czp2fT10aGlzLmNvbXB1dERyYXdQb2ludHMobCxvKSxQPXtwb3M6TyxuYW1lOnQsaWQ6dCxwb2ludHM6di5tYXAoaD0+aC5YWSksbGluZVdpZHRoOmwsZmlsbENvbG9yOnMhPT0idHJhbnNwYXJlbnQiJiZzfHx2b2lkIDAsc3Ryb2tlQ29sb3I6bixub3JtYWxpemU6ITAsY2xhc3NOYW1lOmAke09bMF19LCR7T1sxXX1gLHpJbmRleDpjLGxpbmVKb2luOiJyb3VuZCIsY2xvc2U6ITB9LGk9e3g6TWF0aC5mbG9vcihULngqbVswXSt5WzBdLWd0LlNhZmVCb3JkZXJQYWRkaW5nKm1bMF0pLHk6TWF0aC5mbG9vcihULnkqbVsxXSt5WzFdLWd0LlNhZmVCb3JkZXJQYWRkaW5nKm1bMV0pLHc6TWF0aC5mbG9vcihULncqbVswXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKm1bMF0pLGg6TWF0aC5mbG9vcihULmgqbVsxXSsyKmd0LlNhZmVCb3JkZXJQYWRkaW5nKm1bMV0pfTtmJiYoUC5zY2FsZT1mKSx4JiYoUC5yb3RhdGU9eCksZyYmKFAudHJhbnNsYXRlPWcpO2NvbnN0IHU9bmV3IHF0KFApO2lmKHIuYXBwZW5kKHUpLGZ8fHh8fGcpe2NvbnN0IGg9dS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKGgueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKGgueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKGgud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKGguaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gaX10cmFuc2Zvcm1Db250cm9sUG9pbnRzKGUpe2NvbnN0IHQ9TnQodGhpcy50bXBQb2ludHMpO3N3aXRjaChlKXtjYXNlImJvdHRvbSI6Y2FzZSJib3R0b21MZWZ0IjpjYXNlImJvdHRvbVJpZ2h0Ijp7Y29uc3Qgcj10LnkrdC5oKnRoaXMucmF0aW87cmV0dXJuW25ldyBfKHQueCx0LnksMCksbmV3IF8odC54K3Qudyx0LnksMCksbmV3IF8odC54K3QudyxyLDApLG5ldyBfKHQueCxyLDApXX1jYXNlInRvcCI6Y2FzZSJ0b3BMZWZ0IjpjYXNlInRvcFJpZ2h0Ijp7Y29uc3Qgcj10LnkrdC5oKigxLXRoaXMucmF0aW8pO3JldHVybltuZXcgXyh0LngsciwwKSxuZXcgXyh0LngrdC53LHIsMCksbmV3IF8odC54K3Qudyx0LnkrdC5oLDApLG5ldyBfKHQueCx0LnkrdC5oLDApXX1jYXNlImxlZnQiOmNhc2UibGVmdEJvdHRvbSI6Y2FzZSJsZWZ0VG9wIjp7Y29uc3Qgcj10LngrdC53KigxLXRoaXMucmF0aW8pO3JldHVybltuZXcgXyhyLHQueSwwKSxuZXcgXyh0LngrdC53LHQueSwwKSxuZXcgXyh0LngrdC53LHQueSt0LmgsMCksbmV3IF8ocix0LnkrdC5oLDApXX1jYXNlInJpZ2h0IjpjYXNlInJpZ2h0Qm90dG9tIjpjYXNlInJpZ2h0VG9wIjp7Y29uc3Qgcj10LngrdC53KnRoaXMucmF0aW87cmV0dXJuW25ldyBfKHQueCx0LnksMCksbmV3IF8ocix0LnksMCksbmV3IF8ocix0LnkrdC5oLDApLG5ldyBfKHQueCx0LnkrdC5oLDApXX19fWNvbXB1dERyYXdQb2ludHMoZSx0KXtjb25zdCByPU50KHRoaXMudG1wUG9pbnRzKSxuPXRoaXMudHJhbnNmb3JtQ29udHJvbFBvaW50cyh0KSxzPU1hdGguZmxvb3Ioci53Ki4xKSxsPU1hdGguZmxvb3Ioci5oKi4xKSxjPVtdLG89Xy5BZGQoblswXSxuZXcgXygwLGwsMCkpLGY9Xy5BZGQoblswXSxuZXcgXyhzLDAsMCkpLHg9SnQuZ2V0QmV6aWVyUG9pbnRzKDEwLG8sblswXSxmKSxnPV8uU3ViKG5bMV0sbmV3IF8ocywwLDApKSx5PV8uQWRkKG5bMV0sbmV3IF8oMCxsLDApKSxtPUp0LmdldEJlemllclBvaW50cygxMCxnLG5bMV0seSksVD1fLlN1YihuWzJdLG5ldyBfKDAsbCwwKSksTz1fLlN1YihuWzJdLG5ldyBfKHMsMCwwKSksdj1KdC5nZXRCZXppZXJQb2ludHMoMTAsVCxuWzJdLE8pLFA9Xy5BZGQoblszXSxuZXcgXyhzLDAsMCkpLGk9Xy5TdWIoblszXSxuZXcgXygwLGwsMCkpLHU9SnQuZ2V0QmV6aWVyUG9pbnRzKDEwLFAsblszXSxpKSxhPXMqKDEtdGhpcy5yYXRpbykqMTAsaD1sKigxLXRoaXMucmF0aW8pKjEwO3N3aXRjaCh0KXtjYXNlImJvdHRvbSI6e2NvbnN0IEE9Xy5TdWIoblsyXSxuZXcgXyhzKjUtYS8yLDAsMCkpLEw9Xy5TdWIoblsyXSxuZXcgXyhzKjUsLWgsMCkpLFM9Xy5TdWIoblsyXSxuZXcgXyhzKjUrYS8yLDAsMCkpO2MucHVzaChMLFMsLi4udSwuLi54LC4uLm0sLi4udixBKTticmVha31jYXNlImJvdHRvbVJpZ2h0Ijp7Y29uc3QgQT1fLlN1YihuWzJdLG5ldyBfKHMqMS4xLDAsMCkpLEw9Xy5TdWIoblsyXSxuZXcgXyhzKjEuMSthLzIsLWgsMCkpLFM9Xy5TdWIoblsyXSxuZXcgXyhzKjEuMSthLDAsMCkpO2MucHVzaChMLFMsLi4udSwuLi54LC4uLm0sLi4udixBKTticmVha31jYXNlImJvdHRvbUxlZnQiOntjb25zdCBBPV8uQWRkKG5bM10sbmV3IF8ocyoxLjErYSwwLDApKSxMPV8uQWRkKG5bM10sbmV3IF8ocyoxLjErYS8yLGgsMCkpLFM9Xy5BZGQoblszXSxuZXcgXyhzKjEuMSwwLDApKTtjLnB1c2goTCxTLC4uLnUsLi4ueCwuLi5tLC4uLnYsQSk7YnJlYWt9Y2FzZSJ0b3AiOntjb25zdCBBPV8uU3ViKG5bMV0sbmV3IF8ocyo1LWEvMiwwLDApKSxMPV8uU3ViKG5bMV0sbmV3IF8ocyo1LGgsMCkpLFM9Xy5TdWIoblsxXSxuZXcgXyhzKjUrYS8yLDAsMCkpO2MucHVzaChMLEEsLi4ubSwuLi52LC4uLnUsLi4ueCxTKTticmVha31jYXNlInRvcFJpZ2h0Ijp7Y29uc3QgQT1fLlN1YihuWzFdLG5ldyBfKHMqMS4xLDAsMCkpLEw9Xy5TdWIoblsxXSxuZXcgXyhzKjEuMSthLzIsaCwwKSksUz1fLlN1YihuWzFdLG5ldyBfKHMqMS4xK2EsMCwwKSk7Yy5wdXNoKEwsQSwuLi5tLC4uLnYsLi4udSwuLi54LFMpO2JyZWFrfWNhc2UidG9wTGVmdCI6e2NvbnN0IEE9Xy5BZGQoblswXSxuZXcgXyhzKjEuMSthLDAsMCkpLEw9Xy5BZGQoblswXSxuZXcgXyhzKjEuMSthLzIsLWgsMCkpLFM9Xy5BZGQoblswXSxuZXcgXyhzKjEuMSwwLDApKTtjLnB1c2goTCxBLC4uLm0sLi4udiwuLi51LC4uLngsUyk7YnJlYWt9Y2FzZSJsZWZ0Ijp7Y29uc3QgQT1fLkFkZChuWzBdLG5ldyBfKDAsbCo1LWgvMiwwKSksTD1fLkFkZChuWzBdLG5ldyBfKC1hLGwqNSwwKSksUz1fLkFkZChuWzBdLG5ldyBfKDAsbCo1K2gvMiwwKSk7Yy5wdXNoKEwsQSwuLi54LC4uLm0sLi4udiwuLi51LFMpO2JyZWFrfWNhc2UibGVmdFRvcCI6e2NvbnN0IEE9Xy5BZGQoblswXSxuZXcgXygwLGwqMS4xLDApKSxMPV8uQWRkKG5bMF0sbmV3IF8oLWEsbCoxLjEraC8yLDApKSxTPV8uQWRkKG5bMF0sbmV3IF8oMCxsKjEuMStoLDApKTtjLnB1c2goTCxBLC4uLngsLi4ubSwuLi52LC4uLnUsUyk7YnJlYWt9Y2FzZSJsZWZ0Qm90dG9tIjp7Y29uc3QgQT1fLlN1YihuWzNdLG5ldyBfKDAsbCoxLjEraCwwKSksTD1fLlN1YihuWzNdLG5ldyBfKGEsbCoxLjEraC8yLDApKSxTPV8uU3ViKG5bM10sbmV3IF8oMCxsKjEuMSwwKSk7Yy5wdXNoKEwsQSwuLi54LC4uLm0sLi4udiwuLi51LFMpO2JyZWFrfWNhc2UicmlnaHQiOntjb25zdCBBPV8uQWRkKG5bMV0sbmV3IF8oMCxsKjUtaC8yLDApKSxMPV8uQWRkKG5bMV0sbmV3IF8oYSxsKjUsMCkpLFM9Xy5BZGQoblsxXSxuZXcgXygwLGwqNStoLzIsMCkpO2MucHVzaChMLFMsLi4udiwuLi51LC4uLngsLi4ubSxBKTticmVha31jYXNlInJpZ2h0VG9wIjp7Y29uc3QgQT1fLkFkZChuWzFdLG5ldyBfKDAsbCoxLjEsMCkpLEw9Xy5BZGQoblsxXSxuZXcgXyhhLGwqMS4xK2gvMiwwKSksUz1fLkFkZChuWzFdLG5ldyBfKDAsbCoxLjEraCwwKSk7Yy5wdXNoKEwsUywuLi52LC4uLnUsLi4ueCwuLi5tLEEpO2JyZWFrfWNhc2UicmlnaHRCb3R0b20iOntjb25zdCBBPV8uU3ViKG5bMl0sbmV3IF8oMCxsKjEuMStoLDApKSxMPV8uU3ViKG5bMl0sbmV3IF8oLWEsbCoxLjEraC8yLDApKSxTPV8uU3ViKG5bMl0sbmV3IF8oMCxsKjEuMSwwKSk7Yy5wdXNoKEwsUywuLi52LC4uLnUsLi4ueCwuLi5tLEEpO2JyZWFrfX1jb25zdCBiPU50KHRoaXMudG1wUG9pbnRzLGUpLEU9W01hdGguZmxvb3IoYi54K2Iudy8yKSxNYXRoLmZsb29yKGIueStiLmgvMildO3JldHVybntyZWN0OmIscG9zOkUscG9pbnRzOmN9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyBPdCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczpzfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIscyl8fE90LlN1YihuLHIpLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6bCxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpsJiZndC5nZXRDZW50ZXJQb3MobCxzKX0pLGx9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgZix4O2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6cyxmaWxsQ29sb3I6bH09cixjPW4uZ2V0KHQubmFtZSk7bGV0IG89dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKG89dC5jaGlsZHJlblswXSkscyYmKG8uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscyksKGY9Yz09bnVsbD92b2lkIDA6Yy5vcHQpIT1udWxsJiZmLnN0cm9rZUNvbG9yJiYoYy5vcHQuc3Ryb2tlQ29sb3I9cykpLGwmJihsPT09InRyYW5zcGFyZW50Ij9vLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOm8uc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGwpLCh4PWM9PW51bGw/dm9pZCAwOmMub3B0KSE9bnVsbCYmeC5maWxsQ29sb3ImJihjLm9wdC5maWxsQ29sb3I9bCkpLGMmJm4uc2V0SW5mbyh0Lm5hbWUsYyksZ3QudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgT24gZXh0ZW5kcyBndHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6S3QuYm90aH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5TdHJhaWdodH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN0cmFpZ2h0VGlwV2lkdGgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN0cmFpZ2h0VGlwV2lkdGg9dGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MvMix0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciBtO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxzPShtPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6bS50b1N0cmluZygpO2lmKCFzKXJldHVybnt0eXBlOnV0Lk5vbmV9O2NvbnN0e29wOmwsd29ya1N0YXRlOmN9PXQsbz1sPT1udWxsP3ZvaWQgMDpsLmxlbmd0aDtpZighb3x8bzwyKXJldHVybnt0eXBlOnV0Lk5vbmV9O2xldCBmO2lmKGM9PT1JdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyBPdChsWzBdLGxbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhsKSwhZilyZXR1cm57dHlwZTp1dC5Ob25lfTtpZighbil7Y29uc3QgVD1EYXRlLm5vdygpO3JldHVybiBULXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVQse3R5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnMsb3A6dGhpcy50bXBQb2ludHMubWFwKE89PlsuLi5PLlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6dXQuTm9uZX19Y29uc3QgeD1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixnPXRoaXMuZHJhdyh7d29ya0lkOnMsbGF5ZXI6eH0pLHk9YnQoZyx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9Zyx7cmVjdDp5LHR5cGU6dXQuRHJhd1dvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnN9fWNvbnN1bWVBbGwoZSl7dmFyIG87Y29uc3R7ZGF0YTp0fT1lLHI9KG89dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpvLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6dXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMuZnVsbExheWVyLHM9dGhpcy5kcmF3KHt3b3JrSWQ6cixsYXllcjpufSk7dGhpcy5vbGRSZWN0PXM7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksYz1rdChsKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0OnMsb3A6bCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cyYmZ3QuZ2V0Q2VudGVyUG9zKHMsbil9KSx7cmVjdDpzLHR5cGU6dXQuRnVsbFdvcmssZGF0YVR5cGU6UHQuTG9jYWwsd29ya0lkOnIsb3BzOmMsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBpO2NvbnN0e3dvcmtJZDp0LGxheWVyOnJ9PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKHU9PnUucmVtb3ZlKCkpLChpPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8aS5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAodT0+dS5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6bix0aGlja25lc3M6cyx6SW5kZXg6bCxzY2FsZTpjLHJvdGF0ZTpvLHRyYW5zbGF0ZTpmfT10aGlzLndvcmtPcHRpb25zLHg9ci53b3JsZFBvc2l0aW9uLGc9ci53b3JsZFNjYWxpbmcse2Q6eSxyZWN0Om19PXRoaXMuY29tcHV0RHJhd1BvaW50cyhzKSxUPVttLngrbS53LzIsbS55K20uaC8yXSxPPXtwb3M6VCxuYW1lOnQsaWQ6dCxkOnksZmlsbENvbG9yOm4sc3Ryb2tlQ29sb3I6bixsaW5lV2lkdGg6MCxjbGFzc05hbWU6YCR7VFswXX0sJHtUWzFdfWAsbm9ybWFsaXplOiEwLHpJbmRleDpsfTtjJiYoTy5zY2FsZT1jKSxvJiYoTy5yb3RhdGU9byksZiYmKE8udHJhbnNsYXRlPWYpO2NvbnN0IHY9bmV3IHNlKE8pO2lmKHIuYXBwZW5kKHYpLG98fGN8fGYpe2NvbnN0IHU9di5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKHUueC1ndC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKHUueS1ndC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHUud2lkdGgrZ3QuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKHUuaGVpZ2h0K2d0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm57eDpNYXRoLmZsb29yKG0ueCpnWzBdK3hbMF0tZ3QuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihtLnkqZ1sxXSt4WzFdLWd0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IobS53KmdbMF0rMipndC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKG0uaCpnWzFdKzIqZ3QuU2FmZUJvcmRlclBhZGRpbmcpfX1jb21wdXREcmF3UG9pbnRzKGUpe3JldHVybiB0aGlzLnRtcFBvaW50c1sxXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1swXSk+dGhpcy5zdHJhaWdodFRpcFdpZHRoP3RoaXMuY29tcHV0RnVsbFBvaW50cyhlKTp0aGlzLmNvbXB1dERvdFBvaW50cyhlKX1jb21wdXRGdWxsUG9pbnRzKGUpe2NvbnN0IHQ9Xy5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHI9Xy5QZXIodCkubXVsKGUvMiksbj1PdC5TdWIodGhpcy50bXBQb2ludHNbMF0scikscz1PdC5BZGQodGhpcy50bXBQb2ludHNbMF0sciksbD1PdC5TdWIodGhpcy50bXBQb2ludHNbMV0sciksYz1PdC5BZGQodGhpcy50bXBQb2ludHNbMV0sciksbz1PdC5HZXRTZW1pY2lyY2xlU3Ryb2tlKHRoaXMudG1wUG9pbnRzWzFdLGwsLTEsOCksZj1PdC5HZXRTZW1pY2lyY2xlU3Ryb2tlKHRoaXMudG1wUG9pbnRzWzBdLHMsLTEsOCkseD1bbixsLC4uLm8sYyxzLC4uLmZdO3JldHVybntkOmdlKHgsITApLHJlY3Q6TnQoeCksaXNEb3Q6ITEscG9zOnRoaXMudG1wUG9pbnRzWzBdLlhZfX1jb21wdXREb3RQb2ludHMoZSl7Y29uc3QgdD1PdC5HZXREb3RTdHJva2UodGhpcy50bXBQb2ludHNbMF0sZS8yLDgpO3JldHVybntkOmdlKHQsITApLHJlY3Q6TnQodCksaXNEb3Q6ITAscG9zOnRoaXMudG1wUG9pbnRzWzBdLlhZfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMikscj1uZXcgT3QodFswXSx0WzFdKSxuPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6c309dGhpcy53b3JrT3B0aW9ucztpZihuLmlzTmVhcihyLHMpKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBjO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpjLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyBPdCh0W29dLHRbbysxXSx0W28rMl0pKTtjb25zdCBzPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjpzfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1sLHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDpsLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmwmJmd0LmdldENlbnRlclBvcyhsLHMpfSksbH1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBjO2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6c309cixsPW4uZ2V0KHQubmFtZSk7cmV0dXJuIHMmJih0LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHMpLHQuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLHMpLChjPWw9PW51bGw/dm9pZCAwOmwub3B0KSE9bnVsbCYmYy5zdHJva2VDb2xvciYmKGwub3B0LnN0cm9rZUNvbG9yPXMpKSxsJiZuLnNldEluZm8odC5uYW1lLGwpLGd0LnVwZGF0ZU5vZGVPcHQoZSl9fWNsYXNzIE9lIGV4dGVuZHMgZ3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkt0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2dC5UZXh0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHR9Y29uc3VtZSgpe3JldHVybnt0eXBlOnV0Lk5vbmV9fWNvbnN1bWVBbGwoKXtyZXR1cm57dHlwZTp1dC5Ob25lfX1kcmF3KGUpe3ZhciBtO2NvbnN0e3dvcmtJZDp0LGxheWVyOnIsaXNEcmF3TGFiZWw6bn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoVD0+VC5yZW1vdmUoKSksKG09dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxtLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChUPT5ULnJlbW92ZSgpKTtjb25zdHtib3hTaXplOnMsYm94UG9pbnQ6bH09dGhpcy53b3JrT3B0aW9ucyxjPXIud29ybGRQb3NpdGlvbixvPXIud29ybGRTY2FsaW5nO2lmKCFsfHwhcylyZXR1cm47Y29uc3QgZj1uZXcgZWUoe25hbWU6dCxpZDp0LHBvczpbbFswXStzWzBdLzIsbFsxXStzWzFdLzJdLGFuY2hvcjpbLjUsLjVdLHNpemU6c30pLHg9e3g6bFswXSx5OmxbMV0sdzpzWzBdLGg6c1sxXX0sZz1uZXcgcnIoe25vcm1hbGl6ZTohMCxwb3M6WzAsMF0sc2l6ZTpzfSkseT1uJiZPZS5jcmVhdGVMYWJlbHModGhpcy53b3JrT3B0aW9ucyxyKXx8W107cmV0dXJuIGYuYXBwZW5kKC4uLnksZyksci5hcHBlbmQoZikse3g6TWF0aC5mbG9vcih4Lngqb1swXStjWzBdKSx5Ok1hdGguZmxvb3IoeC55Km9bMV0rY1sxXSksdzpNYXRoLmZsb29yKHgudypvWzBdKSxoOk1hdGguZmxvb3IoeC5oKm9bMV0pfX1jb25zdW1lU2VydmljZShlKXt2YXIgbyxmO2NvbnN0IHQ9KG89dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpvLnRvU3RyaW5nKCk7aWYoIXQpcmV0dXJuO2NvbnN0e2lzRnVsbFdvcms6cixyZXBsYWNlSWQ6bixpc0RyYXdMYWJlbDpzfT1lO3RoaXMub2xkUmVjdD1uJiYoKGY9dGhpcy52Tm9kZXMuZ2V0KG4pKT09bnVsbD92b2lkIDA6Zi5yZWN0KXx8dm9pZCAwO2NvbnN0IGw9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsYz10aGlzLmRyYXcoe3dvcmtJZDp0LGxheWVyOmwsaXNEcmF3TGFiZWw6c30pO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHQse3JlY3Q6YyxvcDpbXSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6YyYmZ3QuZ2V0Q2VudGVyUG9zKGMsbCl9KSxjfXVwZGF0YU9wdFNlcnZpY2UoZSl7aWYoIXRoaXMud29ya0lkKXJldHVybjtjb25zdCB0PXRoaXMud29ya0lkLnRvU3RyaW5nKCkse2ZvbnRDb2xvcjpyLGZvbnRCZ0NvbG9yOm4sYm9sZDpzLGl0YWxpYzpsLGxpbmVUaHJvdWdoOmMsdW5kZXJsaW5lOm99PWUsZj10aGlzLnZOb2Rlcy5nZXQodCk7aWYoIWYpcmV0dXJuO3ImJihmLm9wdC5mb250Q29sb3I9ciksbiYmKGYub3B0LmZvbnRCZ0NvbG9yPW4pLHMmJihmLm9wdC5ib2xkPXMpLGwmJihmLm9wdC5pdGFsaWM9bCksdmUoYykmJihmLm9wdC5saW5lVGhyb3VnaD1jKSx2ZShvKSYmKGYub3B0LnVuZGVybGluZT1vKSxuJiYoZi5vcHQuZm9udEJnQ29sb3I9biksdGhpcy5vbGRSZWN0PWYucmVjdDtjb25zdCB4PXRoaXMuZHJhdyh7d29ya0lkOnQsbGF5ZXI6dGhpcy5mdWxsTGF5ZXIsaXNEcmF3TGFiZWw6ITF9KTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyh0LHtyZWN0Ongsb3A6W10sb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOngmJmd0LmdldENlbnRlclBvcyh4LHRoaXMuZnVsbExheWVyKX0pLHh9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgZ2V0Rm9udFdpZHRoKGUpe2NvbnN0e2N0eDp0LG9wdDpyLHRleHQ6bn09ZSx7Ym9sZDpzLGl0YWxpYzpsLGZvbnRTaXplOmMsZm9udEZhbWlseTpvfT1yO3JldHVybiB0LmZvbnQ9YCR7c30gJHtsfSAke2N9cHggJHtvfWAsdC5tZWFzdXJlVGV4dChuKS53aWR0aH1zdGF0aWMgY3JlYXRlTGFiZWxzKGUsdCl7Y29uc3Qgcj1bXSxuPWUudGV4dC5zcGxpdCgiLCIpLHM9bi5sZW5ndGg7Zm9yKGxldCBsPTA7bDxzO2wrKyl7Y29uc3QgYz1uW2xdLHtmb250U2l6ZTpvLGxpbmVIZWlnaHQ6Zixib2xkOngsdGV4dEFsaWduOmcsaXRhbGljOnksYm94U2l6ZTptLGZvbnRGYW1pbHk6VCx2ZXJ0aWNhbEFsaWduOk8sZm9udENvbG9yOnYsdW5kZXJsaW5lOlAsbGluZVRocm91Z2g6aX09ZSx1PWZ8fG8qMS4yLGE9dCYmdC5wYXJlbnQuY2FudmFzLmdldENvbnRleHQoIjJkIiksaD1hJiZPZS5nZXRGb250V2lkdGgoe3RleHQ6YyxvcHQ6ZSxjdHg6YSx3b3JsZFNjYWxpbmc6dC53b3JsZFNjYWxpbmd9KTtpZihoKXtjb25zdCBiPXthbmNob3I6WzAsLjVdLHRleHQ6Yyxmb250U2l6ZTpvLGxpbmVIZWlnaHQ6dSxmb250RmFtaWx5OlQsZm9udFdlaWdodDp4LGZpbGxDb2xvcjp2LHRleHRBbGlnbjpnLGZvbnRTdHlsZTp5LG5hbWU6bC50b1N0cmluZygpLGNsYXNzTmFtZToibGFiZWwifSxFPVswLDBdO2lmKE89PT0ibWlkZGxlIil7Y29uc3QgTD0ocy0xKS8yO0VbMV09KGwtTCkqdX1nPT09ImxlZnQiJiYoRVswXT1tJiYtbVswXS8yKzV8fDApLGIucG9zPUU7Y29uc3QgQT1uZXcgU2goYik7aWYoci5wdXNoKEEpLFApe2NvbnN0IEw9e25vcm1hbGl6ZTohMSxwb3M6W2IucG9zWzBdLGIucG9zWzFdK28vMl0sbGluZVdpZHRoOjIscG9pbnRzOlswLDAsaCwwXSxzdHJva2VDb2xvcjp2LG5hbWU6YCR7bH1fdW5kZXJsaW5lYCxjbGFzc05hbWU6InVuZGVybGluZSJ9LFM9bmV3IHF0KEwpO3IucHVzaChTKX1pZihpKXtjb25zdCBMPXtub3JtYWxpemU6ITEscG9zOmIucG9zLGxpbmVXaWR0aDoyLHBvaW50czpbMCwwLGgsMF0sc3Ryb2tlQ29sb3I6dixuYW1lOmAke2x9X2xpbmVUaHJvdWdoYCxjbGFzc05hbWU6ImxpbmVUaHJvdWdoIn0sUz1uZXcgcXQoTCk7ci5wdXNoKFMpfX19cmV0dXJuIHJ9c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpuLHRhcmdldE5vZGU6c309ZSx7Zm9udEJnQ29sb3I6bCxmb250Q29sb3I6Yyx0cmFuc2xhdGU6byxib3g6Zixib3hTY2FsZTp4LGJveFRyYW5zbGF0ZTpnLHdvcmtTdGF0ZTp5LGJvbGQ6bSxpdGFsaWM6VCxsaW5lVGhyb3VnaDpPLHVuZGVybGluZTp2LGZvbnRTaXplOlB9PXIsaT1zJiZZdChzKXx8bi5nZXQodC5uYW1lKTtpZighaSlyZXR1cm47Y29uc3QgdT10LnBhcmVudDtpZighdSlyZXR1cm47Y29uc3QgYT1pLm9wdDtpZihhLndvcmtTdGF0ZT15LGMmJmEuZm9udENvbG9yJiYoYS5mb250Q29sb3I9YyksbCYmYS5mb250QmdDb2xvciYmKGEuZm9udEJnQ29sb3I9bCksbSYmKGEuYm9sZD1tKSxUJiYoYS5pdGFsaWM9VCksdmUoTykmJihhLmxpbmVUaHJvdWdoPU8pLHZlKHYpJiYoYS51bmRlcmxpbmU9diksUCl7Y29uc3R7Ym94U2l6ZTpofT1hLGI9UC9hLmZvbnRTaXplLEU9aCYmW2hbMF0qYixoWzFdKmJdO0UmJihhLmJveFNpemU9RSxhLmZvbnRTaXplPVAsaS5yZWN0PXt4OmkucmVjdC54LHk6aS5yZWN0LnksdzpFWzBdLGg6RVsxXX0pfWlmKGYmJmcmJngpe2NvbnN0e2JveFNpemU6aCxmb250U2l6ZTpifT1hLEU9aS5yZWN0LEE9YW4oZ2goRSx4KSxnKTthLmJveFBvaW50PUEmJlsoQS54LXUud29ybGRQb3NpdGlvblswXSkvdS53b3JsZFNjYWxpbmdbMF0sKEEueS11LndvcmxkUG9zaXRpb25bMV0pL3Uud29ybGRTY2FsaW5nWzFdXSxhLmJveFNpemU9aCYmW2hbMF0qeFswXSxoWzFdKnhbMV1dLGEuZm9udFNpemU9YiYmYip4WzBdfWVsc2UgbyYmYS5ib3hQb2ludCYmKGEuYm94UG9pbnQ9W2EuYm94UG9pbnRbMF0rb1swXSxhLmJveFBvaW50WzFdK29bMV1dLGkuY2VudGVyUG9zPVtpLmNlbnRlclBvc1swXStvWzBdLGkuY2VudGVyUG9zWzFdK29bMV1dLGkucmVjdD17eDppLnJlY3QueCtvWzBdLHk6aS5yZWN0Lnkrb1sxXSx3OmkucmVjdC53LGg6aS5yZWN0Lmh9KTtyZXR1cm4gaSYmbi5zZXRJbmZvKHQubmFtZSxpKSxpPT1udWxsP3ZvaWQgMDppLnJlY3R9c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCByPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYocil7Y29uc3Qgbj1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3Iobi54KSx5Ok1hdGguZmxvb3Iobi55KSx3Ok1hdGguZmxvb3Iobi53aWR0aCksaDpNYXRoLmZsb29yKG4uaGVpZ2h0KX19fX1mdW5jdGlvbiBQbihkKXtzd2l0Y2goZCl7Y2FzZSB2dC5BcnJvdzpyZXR1cm4gZ247Y2FzZSB2dC5QZW5jaWw6cmV0dXJuIGhuO2Nhc2UgdnQuU3RyYWlnaHQ6cmV0dXJuIE9uO2Nhc2UgdnQuRWxsaXBzZTpyZXR1cm4gbW47Y2FzZSB2dC5Qb2x5Z29uOmNhc2UgdnQuVHJpYW5nbGU6cmV0dXJuIHluO2Nhc2UgdnQuU3RhcjpjYXNlIHZ0LlJob21idXM6cmV0dXJuIHBuO2Nhc2UgdnQuUmVjdGFuZ2xlOnJldHVybiB2bjtjYXNlIHZ0LlNwZWVjaEJhbGxvb246cmV0dXJuIHhuO2Nhc2UgdnQuVGV4dDpyZXR1cm4gT2U7Y2FzZSB2dC5MYXNlclBlbjpyZXR1cm4gZG47Y2FzZSB2dC5FcmFzZXI6cmV0dXJuIFh0O2Nhc2UgdnQuU2VsZWN0b3I6cmV0dXJuIFJ0fX1mdW5jdGlvbiBibihkKXtjb25zdHt0b29sc1R5cGU6ZSwuLi50fT1kO3N3aXRjaChlKXtjYXNlIHZ0LkFycm93OnJldHVybiBuZXcgZ24odCk7Y2FzZSB2dC5QZW5jaWw6cmV0dXJuIG5ldyBobih0KTtjYXNlIHZ0LlN0cmFpZ2h0OnJldHVybiBuZXcgT24odCk7Y2FzZSB2dC5FbGxpcHNlOnJldHVybiBuZXcgbW4odCk7Y2FzZSB2dC5Qb2x5Z29uOmNhc2UgdnQuVHJpYW5nbGU6cmV0dXJuIG5ldyB5bih0KTtjYXNlIHZ0LlN0YXI6Y2FzZSB2dC5SaG9tYnVzOnJldHVybiBuZXcgcG4odCk7Y2FzZSB2dC5SZWN0YW5nbGU6cmV0dXJuIG5ldyB2bih0KTtjYXNlIHZ0LlNwZWVjaEJhbGxvb246cmV0dXJuIG5ldyB4bih0KTtjYXNlIHZ0LlRleHQ6cmV0dXJuIG5ldyBPZSh0KTtjYXNlIHZ0Lkxhc2VyUGVuOnJldHVybiBuZXcgZG4odCk7Y2FzZSB2dC5FcmFzZXI6cmV0dXJuIG5ldyBYdCh0KTtjYXNlIHZ0LlNlbGVjdG9yOnJldHVybiBuZXcgUnQodCk7ZGVmYXVsdDpyZXR1cm59fWNsYXNzIEJoIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuWkluZGV4QWN0aXZlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm59PWU7aWYodD09PXV0LlVwZGF0ZU5vZGUmJnI9PT1QdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBjLG8sZix4LGc7Y29uc3R7d29ya0lkOnQsaXNBY3RpdmVaSW5kZXg6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm59PWU7aWYodCE9PVJ0LnNlbGVjdG9ySWQpcmV0dXJuO2NvbnN0IHM9KGM9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpjLndvcmtTaGFwZXMuZ2V0KFJ0LnNlbGVjdG9ySWQpO2lmKCFzKXJldHVybjtjb25zdCBsPXMub2xkU2VsZWN0UmVjdDtpZihyJiZsJiZ0aGlzLmxvY2FsV29yayl7Y29uc3QgeT1uZXcgU2V0O2lmKHRoaXMubG9jYWxXb3JrLnZOb2Rlcy5jdXJOb2RlTWFwLmZvckVhY2goKG0sVCk9Pnt4ZShsLG0ucmVjdCkmJnkuYWRkKFQpfSkseS5zaXplKXtjb25zdCBtPVtdO3kuZm9yRWFjaChUPT57dmFyIE87KE89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxPLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShUKS5mb3JFYWNoKHY9Pnt2YXIgaSx1O2NvbnN0IFA9di5jbG9uZU5vZGUoITApO05lKHYpJiZQLnNlYWwoKSwodT0oaT10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOmkuZHJhd0xheWVyKSE9bnVsbCYmdS5nZXRFbGVtZW50c0J5TmFtZShUKS5sZW5ndGh8fG0ucHVzaChQKX0pfSksbS5sZW5ndGgmJigobz10aGlzLmxvY2FsV29yay5kcmF3TGF5ZXIpPT1udWxsfHxvLmFwcGVuZCguLi5tKSl9fWVsc2UoeD0oZj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOmYuZHJhd0xheWVyKT09bnVsbHx8eC5jaGlsZHJlbi5maWx0ZXIoeT0+e3ZhciBtO3JldHVybiEoKG09cy5zZWxlY3RJZHMpIT1udWxsJiZtLmluY2x1ZGVzKHkubmFtZSkpfSkuZm9yRWFjaCh5PT55LnJlbW92ZSgpKTtuJiYoKGc9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxnLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmwsZHJhd0NhbnZhczp4dC5TZWxlY3RvcixjbGVhckNhbnZhczp4dC5TZWxlY3Rvcixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMubG9jYWxXb3JrLnZpZXdJZH1dLHNwOlt7dHlwZTp1dC5TZWxlY3Qsc2VsZWN0SWRzOnMuc2VsZWN0SWRzLG9wdDpzLmdldFdvcmtPcHRpb25zKCksc2VsZWN0UmVjdDpsLHN0cm9rZUNvbG9yOnMuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOnMuZmlsbENvbG9yLHdpbGxTeW5jU2VydmljZTohMSxpc1N5bmM6ITB9XX0pKX19Y2xhc3MgV2ggZXh0ZW5kcyBRdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5Db3B5Tm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT11dC5GdWxsV29yayYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIHI7Y29uc3R7d29ya0lkOnR9PWU7dCYmKChyPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8ci5jb25zdW1lRnVsbChlKSl9fWNsYXNzIEZoIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0Q29sb3JOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOnN9PWU7aWYodD09PXV0LlVwZGF0ZU5vZGUmJnI9PT1QdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkscyYmc2V0VGltZW91dCgoKT0+e3ZhciBsOyhsPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8bC5fcG9zdCh7c3A6W3t0eXBlOnV0Lk5vbmUsdW5kb1RpY2tlcklkOnN9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIG87Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKG89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxvLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfSkpfX1jbGFzcyBVaCBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0LlpJbmRleE5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bn09ZTtpZih0PT09dXQuVXBkYXRlTm9kZSYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGM7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKGM9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxjLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsfSkpfX1jbGFzcyB6aCBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0LlRyYW5zbGF0ZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6c309ZTtpZih0PT09dXQuVXBkYXRlTm9kZSYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxzJiZzZXRUaW1lb3V0KCgpPT57dmFyIGw7KGw9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxsLl9wb3N0KHtzcDpbe3R5cGU6dXQuTm9uZSx1bmRvVGlja2VySWQ6c31dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgZjtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpzLHdpbGxTZXJpYWxpemVEYXRhOmwsdGV4dFVwZGF0ZUZvcldva2VyOmMsZW1pdEV2ZW50VHlwZTpvfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKGY9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxmLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLGlzU3luYzohMCx0ZXh0VXBkYXRlRm9yV29rZXI6YyxlbWl0RXZlbnRUeXBlOm99KSl9fWNsYXNzICRoIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuRGVsZXRlTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT11dC5SZW1vdmVOb2RlKXtpZihyPT09UHQuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwO2lmKHI9PT1QdC5TZXJ2aWNlJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpLCEwfX1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7aWYoIXRoaXMubG9jYWxXb3JrKXJldHVybjtjb25zdHtyZW1vdmVJZHM6dCx3aWxsUmVmcmVzaDpyLHdpbGxTeW5jU2VydmljZTpuLHZpZXdJZDpzfT1lO2lmKCEodCE9bnVsbCYmdC5sZW5ndGgpKXJldHVybjtsZXQgbDtjb25zdCBjPVtdLG89W10sZj1bXTtmb3IoY29uc3QgeCBvZiB0KXtpZih4PT09UnQuc2VsZWN0b3JJZCl7Y29uc3QgeT10aGlzLmxvY2FsV29yay53b3JrU2hhcGVzLmdldChSdC5zZWxlY3RvcklkKSxtPXkuc2VsZWN0SWRzJiZbLi4ueS5zZWxlY3RJZHNdfHxbXTtmb3IoY29uc3QgTyBvZiBtKXtpZih0aGlzLmxvY2FsV29yay52Tm9kZXMuZ2V0KE8pKXtjb25zdCBQPXRoaXMuY29tbWFuZERlbGV0ZVRleHQoTyk7UCYmYy5wdXNoKFApfWw9YnQobCx0aGlzLmxvY2FsV29yay5yZW1vdmVOb2RlKE8pKSxmLnB1c2goTyl9Y29uc3QgVD15PT1udWxsP3ZvaWQgMDp5LnVwZGF0ZVNlbGVjdElkcyhbXSk7bD1idChsLFQuYmdSZWN0KSx0aGlzLmxvY2FsV29yay5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShSdC5zZWxlY3RvcklkKSx0aGlzLmxvY2FsV29yay53b3JrU2hhcGVzLmRlbGV0ZShSdC5zZWxlY3RvcklkKSxjLnB1c2goe3R5cGU6dXQuU2VsZWN0LHNlbGVjdElkczpbXSx3aWxsU3luY1NlcnZpY2U6bn0pO2NvbnRpbnVlfWNvbnN0IGc9dGhpcy5jb21tYW5kRGVsZXRlVGV4dCh4KTtnJiZjLnB1c2goZyksbD1idChsLHRoaXMubG9jYWxXb3JrLnJlbW92ZU5vZGUoeCkpLGYucHVzaCh4KX1uJiZjLnB1c2goe3R5cGU6dXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6Zix1bmRvVGlja2VySWQ6ZS51bmRvVGlja2VySWR9KSxsJiZyJiZvLnB1c2goe3JlY3Q6bCxkcmF3Q2FudmFzOnh0LkJnLGNsZWFyQ2FudmFzOnh0LkJnLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCx2aWV3SWQ6c30pLChvLmxlbmd0aHx8Yy5sZW5ndGgpJiZ0aGlzLmxvY2FsV29yay5fcG9zdCh7cmVuZGVyOm8sc3A6Y30pfWNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpe3RoaXMuc2VydmljZVdvcmsmJnRoaXMuc2VydmljZVdvcmsucmVtb3ZlU2VsZWN0V29yayhlKX1jb21tYW5kRGVsZXRlVGV4dChlKXt2YXIgcjtjb25zdCB0PShyPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6ci52Tm9kZXMuZ2V0KGUpO2lmKHQmJnQudG9vbHNUeXBlPT09dnQuVGV4dClyZXR1cm57dHlwZTp1dC5UZXh0VXBkYXRlLHRvb2xzVHlwZTp2dC5UZXh0LHdvcmtJZDplLGRhdGFUeXBlOlB0LkxvY2FsfX19Y2xhc3MgR2ggZXh0ZW5kcyBRdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5TY2FsZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6c309ZTtpZih0PT09dXQuVXBkYXRlTm9kZSYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxzJiZzZXRUaW1lb3V0KCgpPT57dmFyIGw7KGw9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxsLl9wb3N0KHtzcDpbe3R5cGU6dXQuTm9uZSx1bmRvVGlja2VySWQ6c31dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgbztjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpzLHdpbGxTZXJpYWxpemVEYXRhOmwsdGV4dFVwZGF0ZUZvcldva2VyOmN9PWU7dD09PVJ0LnNlbGVjdG9ySWQmJnImJigobz10aGlzLmxvY2FsV29yayk9PW51bGx8fG8udXBkYXRlU2VsZWN0b3Ioe3VwZGF0ZVNlbGVjdG9yT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpzLGVtaXRFdmVudFR5cGU6dGhpcy5lbWl0RXZlbnRUeXBlLHdpbGxTZXJpYWxpemVEYXRhOmwsaXNTeW5jOiEwLHRleHRVcGRhdGVGb3JXb2tlcjpjfSkpfX1jbGFzcyBLaCBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0LlJvdGF0ZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6c309ZTtpZih0PT09dXQuVXBkYXRlTm9kZSYmcj09PVB0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxzJiZzZXRUaW1lb3V0KCgpPT57dmFyIGw7KGw9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxsLl9wb3N0KHtzcDpbe3R5cGU6dXQuTm9uZSx1bmRvVGlja2VySWQ6c31dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgbztjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpzLHdpbGxTZXJpYWxpemVEYXRhOmwsZW1pdEV2ZW50VHlwZTpjfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKG89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxvLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLGVtaXRFdmVudFR5cGU6Yyxpc1N5bmM6ITB9KSl9fWNsYXNzIEhoIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0Rm9udFN0eWxlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOnN9PWU7aWYodD09PXV0LlVwZGF0ZU5vZGUmJnI9PT1QdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkscyYmc2V0VGltZW91dCgoKT0+e3ZhciBsOyhsPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8bC5fcG9zdCh7c3A6W3t0eXBlOnV0Lk5vbmUsdW5kb1RpY2tlcklkOnN9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIG87Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKG89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxvLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfSkpfX1jbGFzcyBWaCBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0LlNldFBvaW50fSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOnN9PWU7aWYodD09PXV0LlVwZGF0ZU5vZGUmJnI9PT1QdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkscyYmc2V0VGltZW91dCgoKT0+e3ZhciBsOyhsPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8bC5fcG9zdCh7c3A6W3t0eXBlOnV0Lk5vbmUsdW5kb1RpY2tlcklkOnN9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIG87Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLHRleHRVcGRhdGVGb3JXb2tlcjpjfT1lO3Q9PT1SdC5zZWxlY3RvcklkJiZyJiYoKG89dGhpcy5sb2NhbFdvcmspPT1udWxsfHxvLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyxlbWl0RXZlbnRUeXBlOnRoaXMuZW1pdEV2ZW50VHlwZSx3aWxsU2VyaWFsaXplRGF0YTpsLGlzU3luYzohMCx0ZXh0VXBkYXRlRm9yV29rZXI6Y30pKX19Y2xhc3MgWWh7Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImJ1aWxkZXJzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMuYnVpbGRlcnM9bmV3IE1hcChlLm1hcCh0PT5bdCx0aGlzLmJ1aWxkKHQpXSkpfWJ1aWxkKGUpe3N3aXRjaChlKXtjYXNlIEN0LlRyYW5zbGF0ZU5vZGU6cmV0dXJuIG5ldyB6aDtjYXNlIEN0LlpJbmRleE5vZGU6cmV0dXJuIG5ldyBVaDtjYXNlIEN0LlpJbmRleEFjdGl2ZTpyZXR1cm4gbmV3IEJoO2Nhc2UgQ3QuQ29weU5vZGU6cmV0dXJuIG5ldyBXaDtjYXNlIEN0LlNldENvbG9yTm9kZTpyZXR1cm4gbmV3IEZoO2Nhc2UgQ3QuRGVsZXRlTm9kZTpyZXR1cm4gbmV3ICRoO2Nhc2UgQ3QuU2NhbGVOb2RlOnJldHVybiBuZXcgR2g7Y2FzZSBDdC5Sb3RhdGVOb2RlOnJldHVybiBuZXcgS2g7Y2FzZSBDdC5TZXRGb250U3R5bGU6cmV0dXJuIG5ldyBIaDtjYXNlIEN0LlNldFBvaW50OnJldHVybiBuZXcgVmh9fXJlZ2lzdGVyRm9yV29ya2VyKGUsdCl7cmV0dXJuIHRoaXMuYnVpbGRlcnMuZm9yRWFjaChyPT57ciYmci5yZWdpc3RlckZvcldvcmtlcihlLHQpfSksdGhpc31jb25zdW1lRm9yV29ya2VyKGUpe2Zvcihjb25zdCB0IG9mIHRoaXMuYnVpbGRlcnMudmFsdWVzKCkpaWYodCE9bnVsbCYmdC5jb25zdW1lKGUpKXJldHVybiEwO3JldHVybiExfX1jbGFzcyBYaHtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NlbmUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NlbmVQYXRoIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidGFyZ2V0Tm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksdGhpcy52aWV3SWQ9ZSx0aGlzLnNjZW5lPXR9aW5pdChlLHQpe3RoaXMuZnVsbExheWVyPWUsdGhpcy5kcmF3TGF5ZXI9dH1nZXQoZSl7cmV0dXJuIHRoaXMuY3VyTm9kZU1hcC5nZXQoZSl9aGFzUmVuZGVyTm9kZXMoKXtsZXQgZT0hMTtmb3IoY29uc3QgdCBvZiB0aGlzLmN1ck5vZGVNYXAudmFsdWVzKCkpY24odC50b29sc1R5cGUpJiYoZT0hMCk7cmV0dXJuIGV9aGFzKGUpe3RoaXMuY3VyTm9kZU1hcC5oYXMoZSl9c2V0SW5mbyhlLHQpe2NvbnN0IHI9dGhpcy5jdXJOb2RlTWFwLmdldChlKXx8e25hbWU6ZSxyZWN0OnQucmVjdH07dC5yZWN0JiYoci5yZWN0PVl0KHQucmVjdCkpLHQub3AmJihyLm9wPVl0KHQub3ApKSx0LmNhblJvdGF0ZSYmKHIuY2FuUm90YXRlPXQuY2FuUm90YXRlKSx0LnNjYWxlVHlwZSYmKHIuc2NhbGVUeXBlPXQuc2NhbGVUeXBlKSx0Lm9wdCYmKHIub3B0PVl0KHQub3B0KSksdC50b29sc1R5cGUmJihyLnRvb2xzVHlwZT10LnRvb2xzVHlwZSksdC5jZW50ZXJQb3MmJihyLmNlbnRlclBvcz1ZdCh0LmNlbnRlclBvcykpLHIucmVjdD90aGlzLmN1ck5vZGVNYXAuc2V0KGUscik6dGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShlKX1kZWxldGUoZSl7dGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShlKX1jbGVhcigpe3RoaXMuY3VyTm9kZU1hcC5jbGVhcigpLHRoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGg9MH1nZXRSZWN0SW50ZXJzZWN0UmFuZ2UoZSl7bGV0IHQ7Y29uc3Qgcj1uZXcgTWFwO3JldHVybiB0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaCgobixzKT0+e3hlKGUsbi5yZWN0KSYmKHQ9YnQodCxuLnJlY3QpLHIuc2V0KHMsbikpfSkse3JlY3RSYW5nZTp0LG5vZGVSYW5nZTpyfX1nZXROb2RlUmVjdEZvcm1TaGFwZShlLHQpe2NvbnN0IHI9UG4odC50b29sc1R5cGUpO2xldCBuPXRoaXMuZnVsbExheWVyJiYocj09bnVsbD92b2lkIDA6ci5nZXRSZWN0RnJvbUxheWVyKHRoaXMuZnVsbExheWVyLGUpKTtyZXR1cm4hbiYmdGhpcy5kcmF3TGF5ZXImJihuPXI9PW51bGw/dm9pZCAwOnIuZ2V0UmVjdEZyb21MYXllcih0aGlzLmRyYXdMYXllcixlKSksbn11cGRhdGVOb2Rlc1JlY3QoKXt0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaCgoZSx0KT0+e2NvbnN0IHI9dGhpcy5nZXROb2RlUmVjdEZvcm1TaGFwZSh0LGUpO3I/KGUucmVjdD1yLHRoaXMuY3VyTm9kZU1hcC5zZXQodCxlKSk6dGhpcy5jdXJOb2RlTWFwLmRlbGV0ZSh0KX0pfWNvbWJpbmVJbnRlcnNlY3RSZWN0KGUpe2xldCB0PWU7cmV0dXJuIHRoaXMuY3VyTm9kZU1hcC5mb3JFYWNoKHI9Pnt4ZSh0LHIucmVjdCkmJih0PWJ0KHQsci5yZWN0KSl9KSx0fXNldFRhcmdldCgpe3JldHVybiB0aGlzLnRhcmdldE5vZGVNYXAucHVzaChZdCh0aGlzLmN1ck5vZGVNYXApKSx0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoLTF9Z2V0TGFzdFRhcmdldCgpe3JldHVybiB0aGlzLnRhcmdldE5vZGVNYXBbdGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aC0xXX1kZWxldGVMYXN0VGFyZ2V0KCl7dGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aD10aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoLTF9Z2V0VGFyZ2V0KGUpe3JldHVybiB0aGlzLnRhcmdldE5vZGVNYXBbZV19ZGVsZXRlVGFyZ2V0KGUpe3RoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGg9ZX19Y2xhc3MgU257Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidmlld0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Tm9kZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHByIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW1lcmFPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NlbmUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLnZpZXdJZD1lLHRoaXMub3B0PXQsdGhpcy5kcHI9dC5kcHIsdGhpcy5zY2VuZT10aGlzLmNyZWF0ZVNjZW5lKHQub2Zmc2NyZWVuQ2FudmFzT3B0KSx0aGlzLmZ1bGxMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJmdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZTp0aGlzLnZpZXdJZD09PSJtYWluVmlldyI/NmUzOjNlM30pLHRoaXMudk5vZGVzPW5ldyBYaChlLHRoaXMuc2NlbmUpfW9uKGUpe2NvbnN0e21zZ1R5cGU6dCx0b29sc1R5cGU6cixvcHQ6bix3b3JrSWQ6cyx3b3JrU3RhdGU6bCxkYXRhVHlwZTpjfT1lO3N3aXRjaCh0KXtjYXNlIHV0LkRlc3Ryb3k6dGhpcy5kZXN0cm95KCk7YnJlYWs7Y2FzZSB1dC5DbGVhcjp0aGlzLmNsZWFyQWxsKCk7YnJlYWs7Y2FzZSB1dC5VcGRhdGVUb29sczppZihyJiZuKXtjb25zdCBvPXt0b29sc1R5cGU6cix0b29sc09wdDpufTt0aGlzLmxvY2FsV29yay5zZXRUb29sc09wdChvKX1icmVhaztjYXNlIHV0LkNyZWF0ZVdvcms6cyYmbiYmKCF0aGlzLmxvY2FsV29yay5nZXRUbXBXb3JrU2hhcGVOb2RlKCkmJnImJnRoaXMuc2V0VG9vbHNPcHQoe3Rvb2xzVHlwZTpyLHRvb2xzT3B0Om59KSx0aGlzLnNldFdvcmtPcHQoe3dvcmtJZDpzLHRvb2xzT3B0Om59KSk7YnJlYWs7Y2FzZSB1dC5EcmF3V29yazpsPT09SXQuRG9uZSYmYz09PVB0LkxvY2FsP3RoaXMuY29uc3VtZURyYXdBbGwoYyxlKTp0aGlzLmNvbnN1bWVEcmF3KGMsZSk7YnJlYWt9fXVwZGF0ZVNjZW5lKGUpe3RoaXMuc2NlbmUuYXR0cih7Li4uZX0pO2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWU7dGhpcy5zY2VuZS5jb250YWluZXIud2lkdGg9dCx0aGlzLnNjZW5lLmNvbnRhaW5lci5oZWlnaHQ9cix0aGlzLnNjZW5lLndpZHRoPXQsdGhpcy5zY2VuZS5oZWlnaHQ9cix0aGlzLnVwZGF0ZUxheWVyKHt3aWR0aDp0LGhlaWdodDpyfSl9dXBkYXRlTGF5ZXIoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZTt0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLmZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHIpLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuZHJhd0xheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsciksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJzaXplIixbdCxyXSksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllciYmKHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixyKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSl9Y3JlYXRlU2NlbmUoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZSxuPW5ldyBPZmZzY3JlZW5DYW52YXModCxyKTtyZXR1cm4gbmV3IE1oKHtjb250YWluZXI6bixkaXNwbGF5UmF0aW86dGhpcy5kcHIsZGVwdGg6ITEsZGVzeW5jaHJvbml6ZWQ6ITAsLi4uZX0pfWNyZWF0ZUxheWVyKGUsdCxyKXtjb25zdHt3aWR0aDpuLGhlaWdodDpzfT1yLGw9YG9mZnNjcmVlbi0ke2V9YCxjPXQubGF5ZXIobCxyKSxvPW5ldyBlZSh7YW5jaG9yOlsuNSwuNV0scG9zOltuKi41LHMqLjVdLHNpemU6W24sc10sbmFtZToidmlld3BvcnQiLGlkOmV9KTtyZXR1cm4gYy5hcHBlbmQobyksb31jbGVhckFsbCgpe3ZhciBlO3RoaXMuZnVsbExheWVyJiYodGhpcy5mdWxsTGF5ZXIucGFyZW50LmNoaWxkcmVuLmZvckVhY2godD0+e3QubmFtZSE9PSJ2aWV3cG9ydCImJnQucmVtb3ZlKCl9KSx0aGlzLmZ1bGxMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpKSx0aGlzLmRyYXdMYXllciYmKHRoaXMuZHJhd0xheWVyLnBhcmVudC5jaGlsZHJlbi5mb3JFYWNoKHQ9Pnt0Lm5hbWUhPT0idmlld3BvcnQiJiZ0LnJlbW92ZSgpfSksdGhpcy5kcmF3TGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSksdGhpcy5sb2NhbFdvcmsuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKSwoZT10aGlzLnNlcnZpY2VXb3JrKT09bnVsbHx8ZS5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpfXNldFRvb2xzT3B0KGUpe3RoaXMubG9jYWxXb3JrLnNldFRvb2xzT3B0KGUpfXNldFdvcmtPcHQoZSl7Y29uc3R7d29ya0lkOnQsdG9vbHNPcHQ6cn09ZTt0JiZyJiZ0aGlzLmxvY2FsV29yay5zZXRXb3JrT3B0aW9ucyh0LHIpfWRlc3Ryb3koKXt2YXIgZTt0aGlzLnZOb2Rlcy5jbGVhcigpLHRoaXMuc2NlbmUucmVtb3ZlKCksdGhpcy5mdWxsTGF5ZXIucmVtb3ZlKCksdGhpcy5sb2NhbFdvcmsuZGVzdHJveSgpLChlPXRoaXMuc2VydmljZVdvcmspPT1udWxsfHxlLmRlc3Ryb3koKX19Y2xhc3MgTW57Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZpZXdJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Tm9kZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBXb3JrU2hhcGVOb2RlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcE9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVTdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZWZmZWN0V29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdDb3VudCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSx0aGlzLnZpZXdJZD1lLnZpZXdJZCx0aGlzLnZOb2Rlcz1lLnZOb2Rlcyx0aGlzLmZ1bGxMYXllcj1lLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcj1lLmRyYXdMYXllcix0aGlzLl9wb3N0PWUucG9zdH1kZXN0cm95KCl7dGhpcy53b3JrU2hhcGVTdGF0ZS5jbGVhcigpLHRoaXMud29ya1NoYXBlcy5jbGVhcigpfWdldFdvcmtTaGFwZShlKXtyZXR1cm4gdGhpcy53b3JrU2hhcGVzLmdldChlKX1nZXRUbXBXb3JrU2hhcGVOb2RlKCl7cmV0dXJuIHRoaXMudG1wV29ya1NoYXBlTm9kZX1zZXRUbXBXb3JrSWQoZSl7aWYoZSYmdGhpcy50bXBXb3JrU2hhcGVOb2RlKXt0aGlzLnRtcFdvcmtTaGFwZU5vZGUuc2V0V29ya0lkKGUpLHRoaXMud29ya1NoYXBlcy5zZXQoZSx0aGlzLnRtcFdvcmtTaGFwZU5vZGUpLHRoaXMudG1wT3B0JiZ0aGlzLnNldFRvb2xzT3B0KHRoaXMudG1wT3B0KTtyZXR1cm59fXNldFRtcFdvcmtPcHRpb25zKGUpe3ZhciB0Oyh0PXRoaXMudG1wV29ya1NoYXBlTm9kZSk9PW51bGx8fHQuc2V0V29ya09wdGlvbnMoZSl9c2V0V29ya09wdGlvbnMoZSx0KXt2YXIgbjt0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfHx0aGlzLnNldFRtcFdvcmtJZChlKSwobj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbHx8bi5zZXRXb3JrT3B0aW9ucyh0KX1jcmVhdGVXb3JrU2hhcGVOb2RlKGUpe3JldHVybiBibih7Li4uZSx2Tm9kZXM6dGhpcy52Tm9kZXMsZnVsbExheWVyOnRoaXMuZnVsbExheWVyLGRyYXdMYXllcjp0aGlzLmRyYXdMYXllcn0pfXNldFRvb2xzT3B0KGUpe3ZhciB0LHI7KCh0PXRoaXMudG1wT3B0KT09bnVsbD92b2lkIDA6dC50b29sc1R5cGUpIT09ZS50b29sc1R5cGUmJihyPXRoaXMudG1wT3B0KSE9bnVsbCYmci50b29sc1R5cGUmJnRoaXMuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKSx0aGlzLnRtcE9wdD1lLHRoaXMudG1wV29ya1NoYXBlTm9kZT10aGlzLmNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl9Y2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoZSl7dmFyIHQ7KHQ9dGhpcy5nZXRXb3JrU2hhcGUoZSkpPT1udWxsfHx0LmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlKSx0aGlzLndvcmtTaGFwZVN0YXRlLmRlbGV0ZShlKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKGU9PmUuY2xlYXJUbXBQb2ludHMoKSksdGhpcy53b3JrU2hhcGVzLmNsZWFyKCksdGhpcy53b3JrU2hhcGVTdGF0ZS5jbGVhcigpfXNldEZ1bGxXb3JrKGUpe2NvbnN0e3dvcmtJZDp0LG9wdDpyLHRvb2xzVHlwZTpufT1lO2lmKHQmJnImJm4pe2NvbnN0IHM9dCYmdGhpcy53b3JrU2hhcGVzLmdldCh0KXx8dGhpcy5jcmVhdGVXb3JrU2hhcGVOb2RlKHt0b29sc09wdDpyLHRvb2xzVHlwZTpufSk7cmV0dXJuIHM/KHMuc2V0V29ya0lkKHQpLHRoaXMud29ya1NoYXBlcy5zZXQodCxzKSxzKTp2b2lkIDB9fX12YXIgSmg9VnQsWmg9ZnVuY3Rpb24oKXtyZXR1cm4gSmguRGF0ZS5ub3coKX0sUWg9Wmgsa2g9L1xzLztmdW5jdGlvbiBxaChkKXtmb3IodmFyIGU9ZC5sZW5ndGg7ZS0tJiZraC50ZXN0KGQuY2hhckF0KGUpKTspO3JldHVybiBlfXZhciBfaD1xaCx0ZD1faCxlZD0vXlxzKy87ZnVuY3Rpb24gcmQoZCl7cmV0dXJuIGQmJmQuc2xpY2UoMCx0ZChkKSsxKS5yZXBsYWNlKGVkLCIiKX12YXIgbmQ9cmQsaWQ9cmUsc2Q9dGUsb2Q9IltvYmplY3QgU3ltYm9sXSI7ZnVuY3Rpb24gYWQoZCl7cmV0dXJuIHR5cGVvZiBkPT0ic3ltYm9sInx8c2QoZCkmJmlkKGQpPT1vZH12YXIgbGQ9YWQsY2Q9bmQsVG49X3QsdWQ9bGQsRW49TmFOLGZkPS9eWy0rXTB4WzAtOWEtZl0rJC9pLGhkPS9eMGJbMDFdKyQvaSxkZD0vXjBvWzAtN10rJC9pLGdkPXBhcnNlSW50O2Z1bmN0aW9uIG1kKGQpe2lmKHR5cGVvZiBkPT0ibnVtYmVyIilyZXR1cm4gZDtpZih1ZChkKSlyZXR1cm4gRW47aWYoVG4oZCkpe3ZhciBlPXR5cGVvZiBkLnZhbHVlT2Y9PSJmdW5jdGlvbiI/ZC52YWx1ZU9mKCk6ZDtkPVRuKGUpP2UrIiI6ZX1pZih0eXBlb2YgZCE9InN0cmluZyIpcmV0dXJuIGQ9PT0wP2Q6K2Q7ZD1jZChkKTt2YXIgdD1oZC50ZXN0KGQpO3JldHVybiB0fHxkZC50ZXN0KGQpP2dkKGQuc2xpY2UoMiksdD8yOjgpOmZkLnRlc3QoZCk/RW46K2R9dmFyIHZkPW1kLHBkPV90LHNyPVFoLEFuPXZkLHlkPSJFeHBlY3RlZCBhIGZ1bmN0aW9uIix4ZD1NYXRoLm1heCxPZD1NYXRoLm1pbjtmdW5jdGlvbiBQZChkLGUsdCl7dmFyIHIsbixzLGwsYyxvLGY9MCx4PSExLGc9ITEseT0hMDtpZih0eXBlb2YgZCE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgVHlwZUVycm9yKHlkKTtlPUFuKGUpfHwwLHBkKHQpJiYoeD0hIXQubGVhZGluZyxnPSJtYXhXYWl0ImluIHQscz1nP3hkKEFuKHQubWF4V2FpdCl8fDAsZSk6cyx5PSJ0cmFpbGluZyJpbiB0PyEhdC50cmFpbGluZzp5KTtmdW5jdGlvbiBtKGIpe3ZhciBFPXIsQT1uO3JldHVybiByPW49dm9pZCAwLGY9YixsPWQuYXBwbHkoQSxFKSxsfWZ1bmN0aW9uIFQoYil7cmV0dXJuIGY9YixjPXNldFRpbWVvdXQoUCxlKSx4P20oYik6bH1mdW5jdGlvbiBPKGIpe3ZhciBFPWItbyxBPWItZixMPWUtRTtyZXR1cm4gZz9PZChMLHMtQSk6TH1mdW5jdGlvbiB2KGIpe3ZhciBFPWItbyxBPWItZjtyZXR1cm4gbz09PXZvaWQgMHx8RT49ZXx8RTwwfHxnJiZBPj1zfWZ1bmN0aW9uIFAoKXt2YXIgYj1zcigpO2lmKHYoYikpcmV0dXJuIGkoYik7Yz1zZXRUaW1lb3V0KFAsTyhiKSl9ZnVuY3Rpb24gaShiKXtyZXR1cm4gYz12b2lkIDAseSYmcj9tKGIpOihyPW49dm9pZCAwLGwpfWZ1bmN0aW9uIHUoKXtjIT09dm9pZCAwJiZjbGVhclRpbWVvdXQoYyksZj0wLHI9bz1uPWM9dm9pZCAwfWZ1bmN0aW9uIGEoKXtyZXR1cm4gYz09PXZvaWQgMD9sOmkoc3IoKSl9ZnVuY3Rpb24gaCgpe3ZhciBiPXNyKCksRT12KGIpO2lmKHI9YXJndW1lbnRzLG49dGhpcyxvPWIsRSl7aWYoYz09PXZvaWQgMClyZXR1cm4gVChvKTtpZihnKXJldHVybiBjbGVhclRpbWVvdXQoYyksYz1zZXRUaW1lb3V0KFAsZSksbShvKX1yZXR1cm4gYz09PXZvaWQgMCYmKGM9c2V0VGltZW91dChQLGUpKSxsfXJldHVybiBoLmNhbmNlbD11LGguZmx1c2g9YSxofXZhciBiZD1QZCxTZD1iZCxNZD1fdCxUZD0iRXhwZWN0ZWQgYSBmdW5jdGlvbiI7ZnVuY3Rpb24gRWQoZCxlLHQpe3ZhciByPSEwLG49ITA7aWYodHlwZW9mIGQhPSJmdW5jdGlvbiIpdGhyb3cgbmV3IFR5cGVFcnJvcihUZCk7cmV0dXJuIE1kKHQpJiYocj0ibGVhZGluZyJpbiB0PyEhdC5sZWFkaW5nOnIsbj0idHJhaWxpbmciaW4gdD8hIXQudHJhaWxpbmc6biksU2QoZCxlLHtsZWFkaW5nOnIsbWF4V2FpdDplLHRyYWlsaW5nOm59KX12YXIgQWQ9RWQsQ249cGUoQWQpO2NsYXNzIENkIGV4dGVuZHMgTW57Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVVbml0VGltZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjYwMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb21iaW5lVGltZXJJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlZmZlY3RTZWxlY3ROb2RlRGF0YSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFcmFzZXJXb3JrcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFcmFzZXJSZW1vdmVOb2RlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFZmZlY3RXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q24odD0+e3RoaXMudk5vZGVzLmN1ck5vZGVNYXAuc2l6ZSYmKHRoaXMudk5vZGVzLnVwZGF0ZU5vZGVzUmVjdCgpLHRoaXMucmVSZW5kZXJTZWxlY3RvcigpKSx0JiZ0KCl9LDEwMCx7bGVhZGluZzohMX0pfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImJhdGNoRXJhc2VyQ29tYmluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkNuKCgpPT57Y29uc3QgdD10aGlzLnVwZGF0ZUJhdGNoRXJhc2VyQ29tYmluZU5vZGUodGhpcy5iYXRjaEVyYXNlcldvcmtzLHRoaXMuYmF0Y2hFcmFzZXJSZW1vdmVOb2Rlcyk7dGhpcy5iYXRjaEVyYXNlcldvcmtzLmNsZWFyKCksdGhpcy5iYXRjaEVyYXNlclJlbW92ZU5vZGVzLmNsZWFyKCksdC5sZW5ndGgmJnRoaXMuX3Bvc3Qoe3JlbmRlcjp0fSl9LDEwMCx7bGVhZGluZzohMX0pfSl9Y29uc3VtZURyYXcoZSx0KXtjb25zdHtvcDpyLHdvcmtJZDpufT1lO2lmKHIhPW51bGwmJnIubGVuZ3RoJiZuKXtjb25zdCBzPXRoaXMud29ya1NoYXBlcy5nZXQobik7aWYoIXMpcmV0dXJuO2NvbnN0IGw9cy50b29sc1R5cGU7aWYobD09PXZ0Lkxhc2VyUGVuKXJldHVybjtjb25zdCBjPXMuY29uc3VtZSh7ZGF0YTplLGlzRnVsbFdvcms6ITB9KTtzd2l0Y2gobCl7Y2FzZSB2dC5TZWxlY3RvcjpjLnR5cGU9PT11dC5TZWxlY3QmJihjLnNlbGVjdElkcyYmdC5ydW5SZXZlcnNlU2VsZWN0V29yayhjLnNlbGVjdElkcyksdGhpcy5kcmF3U2VsZWN0b3IoYywhMCkpO2JyZWFrO2Nhc2UgdnQuRXJhc2VyOmMhPW51bGwmJmMucmVjdCYmdGhpcy5kcmF3RXJhc2VyKGMpO2JyZWFrO2Nhc2UgdnQuQXJyb3c6Y2FzZSB2dC5TdHJhaWdodDpjYXNlIHZ0LkVsbGlwc2U6Y2FzZSB2dC5SZWN0YW5nbGU6Y2FzZSB2dC5TdGFyOmNhc2UgdnQuUG9seWdvbjpjYXNlIHZ0LlNwZWVjaEJhbGxvb246YyYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3UGVuY2lsKGMpKTticmVhaztjYXNlIHZ0LlBlbmNpbDp0aGlzLmNvbWJpbmVUaW1lcklkfHwodGhpcy5jb21iaW5lVGltZXJJZD1zZXRUaW1lb3V0KCgpPT57dGhpcy5jb21iaW5lVGltZXJJZD12b2lkIDAsdGhpcy5kcmF3UGVuY2lsQ29tYmluZShuKX0sTWF0aC5mbG9vcihzLmdldFdvcmtPcHRpb25zKCkuc3luY1VuaXRUaW1lfHx0aGlzLmNvbWJpbmVVbml0VGltZS8yKSkpLGMmJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd1BlbmNpbChjKSk7YnJlYWt9fX1jb25zdW1lRHJhd0FsbChlLHQpe3ZhciBzO3RoaXMuY29tYmluZVRpbWVySWQmJihjbGVhclRpbWVvdXQodGhpcy5jb21iaW5lVGltZXJJZCksdGhpcy5jb21iaW5lVGltZXJJZD12b2lkIDApO2NvbnN0e3dvcmtJZDpyLHVuZG9UaWNrZXJJZDpufT1lO2lmKHIpe24mJnNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3R5cGU6dXQuTm9uZSx1bmRvVGlja2VySWQ6bn1dfSl9LDApO2NvbnN0IGw9dGhpcy53b3JrU2hhcGVzLmdldChyKTtpZighbClyZXR1cm47Y29uc3QgYz1sLnRvb2xzVHlwZTtpZihjPT09dnQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IG89bC5jb25zdW1lQWxsKHtkYXRhOmV9KSxmPXRoaXMud29ya1NoYXBlU3RhdGUuZ2V0KHIpO3N3aXRjaChjKXtjYXNlIHZ0LlNlbGVjdG9yOm8uc2VsZWN0SWRzJiZ0LnJ1blJldmVyc2VTZWxlY3RXb3JrKG8uc2VsZWN0SWRzKSx0aGlzLmRyYXdTZWxlY3RvcihvLCExKSwocz1sLnNlbGVjdElkcykhPW51bGwmJnMubGVuZ3RoP2wuY2xlYXJUbXBQb2ludHMoKTp0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHIpO2JyZWFrO2Nhc2UgdnQuRXJhc2VyOm8hPW51bGwmJm8ucmVjdCYmdGhpcy5kcmF3RXJhc2VyKG8pLGwuY2xlYXJUbXBQb2ludHMoKTticmVhaztjYXNlIHZ0LkFycm93OmNhc2UgdnQuU3RyYWlnaHQ6Y2FzZSB2dC5FbGxpcHNlOmNhc2UgdnQuUmVjdGFuZ2xlOmNhc2UgdnQuU3RhcjpjYXNlIHZ0LlBvbHlnb246Y2FzZSB2dC5TcGVlY2hCYWxsb29uOnRoaXMuZHJhd1BlbmNpbEZ1bGwobyxsLmdldFdvcmtPcHRpb25zKCksZiksdGhpcy5kcmF3Q291bnQ9MCx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHIpO2JyZWFrO2Nhc2UgdnQuUGVuY2lsOm8hPW51bGwmJm8ucmVjdCYmKHRoaXMuZHJhd1BlbmNpbEZ1bGwobyxsLmdldFdvcmtPcHRpb25zKCksZiksdGhpcy5kcmF3Q291bnQ9MCksdGhpcy5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShyKTticmVha319fWNvbnN1bWVGdWxsKGUpe3ZhciBzLGw7Y29uc3QgdD10aGlzLnNldEZ1bGxXb3JrKGUpLHI9ZS5vcHMmJkJlKGUub3BzKSxuPShzPWUud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKG4mJnQpe2NvbnN0IGM9KGw9dGhpcy52Tm9kZXMuZ2V0KG4pKT09bnVsbD92b2lkIDA6bC5yZWN0O2xldCBvPXQuY29uc3VtZVNlcnZpY2Uoe29wOnIsaXNGdWxsV29yazohMCxyZXBsYWNlSWQ6bn0pO2NvbnN0IGY9KGU9PW51bGw/dm9pZCAwOmUudXBkYXRlTm9kZU9wdCkmJnQudXBkYXRhT3B0U2VydmljZShlLnVwZGF0ZU5vZGVPcHQpO2lmKG89YnQobyxmKSxvJiZlLndpbGxSZWZyZXNoKXtjb25zdCB4PVtdO2MmJngucHVzaCh7cmVjdDpvLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSx4LnB1c2goe3JlY3Q6byxkcmF3Q2FudmFzOnh0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSk7Y29uc3QgZz17cmVuZGVyOngsc3A6ZS53aWxsU3luY1NlcnZpY2UmJlt7b3B0OmUub3B0LHRvb2xzVHlwZTplLnRvb2xzVHlwZSx0eXBlOnV0LkZ1bGxXb3JrLHdvcmtJZDplLndvcmtJZCxvcHM6ZS5vcHMsdXBkYXRlTm9kZU9wdDplLnVwZGF0ZU5vZGVPcHQsdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkLHZpZXdJZDp0aGlzLnZpZXdJZH1dfHx2b2lkIDB9O3RoaXMuX3Bvc3QoZyl9ZS53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoZS53b3JrSWQpfX1yZW1vdmVXb3JrKGUpe2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO2lmKHIpe2NvbnN0IG49dGhpcy5yZW1vdmVOb2RlKHIpO24mJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6bixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eHQuQmcsZHJhd0NhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pfX1yZW1vdmVOb2RlKGUpe3ZhciBuO3RoaXMud29ya1NoYXBlcy5oYXMoZSkmJnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoZSk7bGV0IHQ7Y29uc3Qgcj10aGlzLnZOb2Rlcy5nZXQoZSk7cmV0dXJuIHImJih0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5jb25jYXQoKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5nZXRFbGVtZW50c0J5TmFtZShlKSl8fFtdKS5mb3JFYWNoKHM9PntzLnJlbW92ZSgpfSksdD1idCh0LHIucmVjdCksdGhpcy52Tm9kZXMuZGVsZXRlKGUpKSx0fWNoZWNrVGV4dEFjdGl2ZShlKXt2YXIgcjtjb25zdHtvcDp0fT1lO2lmKHQhPW51bGwmJnQubGVuZ3RoKXtsZXQgbjtmb3IoY29uc3QgcyBvZiB0aGlzLnZOb2Rlcy5jdXJOb2RlTWFwLnZhbHVlcygpKXtjb25zdHtyZWN0OmwsbmFtZTpjLHRvb2xzVHlwZTpvfT1zLGY9dFswXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx4PXRbMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV07aWYobz09PXZ0LlRleHQmJnBoKFtmLHhdLGwpKXtuPWM7YnJlYWt9fWlmKG4pe2NvbnN0IHM9dGhpcy53b3JrU2hhcGVzLmdldChSdC5zZWxlY3RvcklkKTtzJiYoKHI9cy5zZWxlY3RJZHMpIT1udWxsJiZyLmluY2x1ZGVzKG4pKSYmdGhpcy5ibHVyU2VsZWN0b3IoKSx0aGlzLl9wb3N0KHtzcDpbe3R5cGU6dXQuR2V0VGV4dEFjdGl2ZSx0b29sc1R5cGU6dnQuVGV4dCx3b3JrSWQ6bn1dfSl9fX1jb2xsb2N0RWZmZWN0U2VsZWN0V29yayhlKXtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoUnQuc2VsZWN0b3JJZCkse3dvcmtJZDpyfT1lO2lmKHQmJnImJnQuc2VsZWN0SWRzJiZ0LnNlbGVjdElkcy5pbmNsdWRlcyhyLnRvU3RyaW5nKCkpKXt0aGlzLmVmZmVjdFNlbGVjdE5vZGVEYXRhLmFkZChlKSxzZXRUaW1lb3V0KCgpPT57dmFyIG47dGhpcy5ydW5FZmZlY3RTZWxlY3RXb3JrKCksKG49dGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YSk9PW51bGx8fG4uY2xlYXIoKX0sMCk7cmV0dXJufXJldHVybiBlfXVwZGF0ZVNlbGVjdG9yKGUpe3ZhciB2O2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldChSdC5zZWxlY3RvcklkKTtpZighKCh2PXQ9PW51bGw/dm9pZCAwOnQuc2VsZWN0SWRzKSE9bnVsbCYmdi5sZW5ndGgpKXJldHVybjtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpsLGVtaXRFdmVudFR5cGU6Yyxpc1N5bmM6byx0ZXh0VXBkYXRlRm9yV29rZXI6Zn09ZSx4PXIud29ya1N0YXRlLGc9dD09bnVsbD92b2lkIDA6dC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cixzZWxlY3RJZHM6dC5zZWxlY3RJZHMsdk5vZGVzOnRoaXMudk5vZGVzLHdpbGxTZXJpYWxpemVEYXRhOmwsd29ya2VyOnRoaXN9KSx5PWc9PW51bGw/dm9pZCAwOmcuc2VsZWN0UmVjdCxtPW5ldyBNYXA7aWYodC5zZWxlY3RJZHMuZm9yRWFjaChQPT57Y29uc3QgaT10aGlzLnZOb2Rlcy5nZXQoUCk7aWYoaSl7Y29uc3R7dG9vbHNUeXBlOnUsb3A6YSxvcHQ6aH09aTttLnNldChQLHtvcHQ6aCx0b29sc1R5cGU6dSxvcHM6KGE9PW51bGw/dm9pZCAwOmEubGVuZ3RoKSYma3QoYSl8fHZvaWQgMH0pfX0pLGM9PT1DdC5UcmFuc2xhdGVOb2RlJiZ4PT09SXQuU3RhcnQpcmV0dXJuO2NvbnN0IFQ9W10sTz1bXTtpZihuKXtULnB1c2goe2lzQ2xlYXJBbGw6ITAsaXNGdWxsV29yazohMSxjbGVhckNhbnZhczp4dC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBQPXtyZWN0OnksaXNGdWxsV29yazohMSxkcmF3Q2FudmFzOnh0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLnZpZXdJZH07ci50cmFuc2xhdGUmJmM9PT1DdC5UcmFuc2xhdGVOb2RlJiZ4PT09SXQuRG9pbmcmJihQLnRyYW5zbGF0ZT1yLnRyYW5zbGF0ZSksVC5wdXNoKFApfWlmKHMpe2lmKGwpe2lmKGM9PT1DdC5Sb3RhdGVOb2RlJiZ4PT09SXQuRG9uZSYmTy5wdXNoKHt0eXBlOnV0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LHdpbGxTeW5jU2VydmljZTohMCxpc1N5bmM6byxwb2ludHM6dC5nZXRDaGlsZHJlblBvaW50cygpfSksYz09PUN0LlNjYWxlTm9kZSYmeD09PUl0LkRvbmUmJk8ucHVzaCh7dHlwZTp1dC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eSx3aWxsU3luY1NlcnZpY2U6ITEsaXNTeW5jOm8scG9pbnRzOnQuZ2V0Q2hpbGRyZW5Qb2ludHMoKX0pLGM9PT1DdC5UcmFuc2xhdGVOb2RlJiZ4PT09SXQuRG9uZSl7Y29uc3QgUD10LmdldENoaWxkcmVuUG9pbnRzKCk7UCYmTy5wdXNoKHt0eXBlOnV0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LHdpbGxTeW5jU2VydmljZTohMSxpc1N5bmM6byxwb2ludHM6UH0pfX1lbHNlIHIuZm9udFNpemUmJk8ucHVzaCh7dHlwZTp1dC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eSx3aWxsU3luY1NlcnZpY2U6ITAsaXNTeW5jOm8scG9pbnRzOnQuZ2V0Q2hpbGRyZW5Qb2ludHMoKX0pLHIucG9pbnRNYXAmJk8ucHVzaCh7dHlwZTp1dC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eSx3aWxsU3luY1NlcnZpY2U6ITEsaXNTeW5jOm8scG9pbnRzOnQuZ2V0Q2hpbGRyZW5Qb2ludHMoKX0pLGM9PT1DdC5TY2FsZU5vZGUmJng9PT1JdC5TdGFydCYmTy5wdXNoKHt0eXBlOnV0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LGNhbnZhc1dpZHRoOnRoaXMuZnVsbExheWVyLnBhcmVudC53aWR0aCxjYW52YXNIZWlnaHQ6dGhpcy5mdWxsTGF5ZXIucGFyZW50LmhlaWdodCx3aWxsU3luY1NlcnZpY2U6ITEscG9pbnRzOnQuZ2V0Q2hpbGRyZW5Qb2ludHMoKX0pO2Zvcihjb25zdFtQLGldb2YgbS5lbnRyaWVzKCkpZiYmaS50b29sc1R5cGU9PT12dC5UZXh0P08ucHVzaCh7Li4uaSx3b3JrSWQ6UCx0eXBlOnV0LlRleHRVcGRhdGUsZGF0YVR5cGU6UHQuTG9jYWx9KTpPLnB1c2goey4uLmksd29ya0lkOlAsdHlwZTp1dC5VcGRhdGVOb2RlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX0saXNTeW5jOm99KX0oVC5sZW5ndGh8fE8ubGVuZ3RoKSYmdGhpcy5fcG9zdCh7cmVuZGVyOlQsc3A6T30pfWJsdXJTZWxlY3RvcihlKXt2YXIgbjtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoUnQuc2VsZWN0b3JJZCkscj10PT1udWxsP3ZvaWQgMDp0LmJsdXJTZWxlY3RvcigpO2lmKHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoUnQuc2VsZWN0b3JJZCksKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5wYXJlbnQpLmNoaWxkcmVuLmZvckVhY2gocz0+e3MubmFtZT09PVJ0LnNlbGVjdG9ySWQmJnMucmVtb3ZlKCl9KSxyKXtjb25zdCBzPVtyXTtlIT1udWxsJiZlLnVuZG9UaWNrZXJJZCYmcy5wdXNoKHt0eXBlOnV0LlNlbGVjdCxzZWxlY3RJZHM6W10sdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkfSksdGhpcy5fcG9zdCh7cmVuZGVyOihyPT1udWxsP3ZvaWQgMDpyLnJlY3QpJiZbe3JlY3Q6ci5yZWN0LGRyYXdDYW52YXM6eHQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOnN9KX19cnVuRWZmZWN0V29yayhlKXt0aGlzLmJhdGNoRWZmZWN0V29yayhlKX1yZVJlbmRlclNlbGVjdG9yKCl7dmFyIHQ7Y29uc3QgZT10aGlzLndvcmtTaGFwZXMuZ2V0KFJ0LnNlbGVjdG9ySWQpO2lmKCh0PWU9PW51bGw/dm9pZCAwOmUuc2VsZWN0SWRzKSE9bnVsbCYmdC5sZW5ndGgmJnRoaXMuZHJhd0xheWVyKXtjb25zdCByPWUucmVSZW5kZXJTZWxlY3RvcigpO3ImJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6cixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6eHQuU2VsZWN0b3IsZHJhd0NhbnZhczp4dC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpbe3R5cGU6dXQuU2VsZWN0LHNlbGVjdElkczplLnNlbGVjdElkcyxzZWxlY3RSZWN0OnIsd2lsbFN5bmNTZXJ2aWNlOiExLHZpZXdJZDp0aGlzLnZpZXdJZCxwb2ludHM6ZS5nZXRDaGlsZHJlblBvaW50cygpfV19KX19dXBkYXRlRnVsbFNlbGVjdFdvcmsoZSl7dmFyIG4scyxsLGMsbyxmLHg7Y29uc3QgdD10aGlzLndvcmtTaGFwZXMuZ2V0KFJ0LnNlbGVjdG9ySWQpLHtzZWxlY3RJZHM6cn09ZTtpZighKHIhPW51bGwmJnIubGVuZ3RoKSl7dGhpcy5ibHVyU2VsZWN0b3IoZSk7cmV0dXJufWlmKCF0KXt0aGlzLnNldEZ1bGxXb3JrKGUpLHRoaXMudXBkYXRlRnVsbFNlbGVjdFdvcmsoZSk7cmV0dXJufWlmKHQmJihyIT1udWxsJiZyLmxlbmd0aCkpe2NvbnN0e2JnUmVjdDpnLHNlbGVjdFJlY3Q6eX09dC51cGRhdGVTZWxlY3RJZHMociksbT17cmVuZGVyOltdLHNwOltdfTtnJiYoKG49bS5yZW5kZXIpPT1udWxsfHxuLnB1c2goe3JlY3Q6Zyxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eHQuQmcsZHJhd0NhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSksKHM9bS5yZW5kZXIpPT1udWxsfHxzLnB1c2goe3JlY3Q6Z3x8eSxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6eHQuU2VsZWN0b3IsZHJhd0NhbnZhczp4dC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9KSwoeD1tLnNwKT09bnVsbHx8eC5wdXNoKHsuLi5lLHNlbGVjdG9yQ29sb3I6KGw9ZS5vcHQpPT1udWxsP3ZvaWQgMDpsLnN0cm9rZUNvbG9yLHN0cm9rZUNvbG9yOihjPWUub3B0KT09bnVsbD92b2lkIDA6Yy5zdHJva2VDb2xvcixmaWxsQ29sb3I6KG89ZS5vcHQpPT1udWxsP3ZvaWQgMDpvLmZpbGxDb2xvcix0ZXh0T3B0OihmPWUub3B0KT09bnVsbD92b2lkIDA6Zi50ZXh0T3B0LGNhblRleHRFZGl0OnQuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnQuY2FuUm90YXRlLHNjYWxlVHlwZTp0LnNjYWxlVHlwZSx0eXBlOnV0LlNlbGVjdCxzZWxlY3RSZWN0Omd8fHksd2lsbFN5bmNTZXJ2aWNlOiExLHBvaW50czp0LmdldENoaWxkcmVuUG9pbnRzKCl9KSx0aGlzLl9wb3N0KG0pfX1kZXN0cm95KCl7c3VwZXIuZGVzdHJveSgpLHRoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEuY2xlYXIoKSx0aGlzLmJhdGNoRXJhc2VyV29ya3MuY2xlYXIoKSx0aGlzLmJhdGNoRXJhc2VyUmVtb3ZlTm9kZXMuY2xlYXIoKX1kcmF3UGVuY2lsQ29tYmluZShlKXt2YXIgcixuO2NvbnN0IHQ9KHI9dGhpcy53b3JrU2hhcGVzLmdldChlKSk9PW51bGw/dm9pZCAwOnIuY29tYmluZUNvbnN1bWUoKTtpZih0KXtjb25zdCBzPXtyZW5kZXI6W10sZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50fTsobj1zLnJlbmRlcik9PW51bGx8fG4ucHVzaCh7cmVjdDp0PT1udWxsP3ZvaWQgMDp0LnJlY3QsaXNDbGVhcjohMCxkcmF3Q2FudmFzOnh0LkZsb2F0LGNsZWFyQ2FudmFzOnh0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSksdGhpcy5fcG9zdChzKX19ZHJhd1NlbGVjdG9yKGUsdCl7dmFyIG4scyxsO2NvbnN0IHI9e3JlbmRlcjpbXSxzcDpbZV19OyhuPWUuc2VsZWN0SWRzKSE9bnVsbCYmbi5sZW5ndGgmJiF0JiYoKHM9ci5yZW5kZXIpPT1udWxsfHxzLnB1c2goe3JlY3Q6ZS5zZWxlY3RSZWN0LGRyYXdDYW52YXM6eHQuU2VsZWN0b3IsaXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5TZWxlY3Rvcixpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0se3JlY3Q6ZS5yZWN0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9LHtyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnh0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSksdCYmKChsPXIucmVuZGVyKT09bnVsbHx8bC5wdXNoKHtyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnh0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9LHtyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnh0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSksdGhpcy5fcG9zdChyKX1hc3luYyBkcmF3RXJhc2VyKGUpe3ZhciByLG47Y29uc3QgdD1bXTtpZigocj1lLm5ld1dvcmtEYXRhcykhPW51bGwmJnIuc2l6ZSl7Zm9yKGNvbnN0IHMgb2YgZS5uZXdXb3JrRGF0YXMudmFsdWVzKCkpe2NvbnN0IGw9cy53b3JrSWQudG9TdHJpbmcoKTt0aGlzLmJhdGNoRXJhc2VyV29ya3MuYWRkKGwpLHQucHVzaCh7dHlwZTp1dC5GdWxsV29yayx3b3JrSWQ6bCxvcHM6a3Qocy5vcCksb3B0OnMub3B0LHRvb2xzVHlwZTpzLnRvb2xzVHlwZSx1cGRhdGVOb2RlT3B0Ont1c2VBbmltYXRpb246ITF9fSl9ZGVsZXRlIGUubmV3V29ya0RhdGFzfShuPWUucmVtb3ZlSWRzKT09bnVsbHx8bi5mb3JFYWNoKHM9Pnt0aGlzLmJhdGNoRXJhc2VyUmVtb3ZlTm9kZXMuYWRkKHMpfSksdC5wdXNoKGUpLHRoaXMuX3Bvc3Qoe3NwOnR9KSx0aGlzLmJhdGNoRXJhc2VyQ29tYmluZSgpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd1BlbmNpbEZ1bGwoZSx0LHIpe3ZhciBzO2NvbnN0IG49e2RyYXdDb3VudDoxLzAscmVuZGVyOlt7cmVjdDplLnJlY3QsZHJhd0NhbnZhczp4dC5CZyxpc0NsZWFyOihyPT1udWxsP3ZvaWQgMDpyLndpbGxDbGVhcil8fCh0PT1udWxsP3ZvaWQgMDp0LmlzT3BhY2l0eSksY2xlYXJDYW52YXM6eHQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpbZV19OyhzPW4ucmVuZGVyKT09bnVsbHx8cy5wdXNoKHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnh0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSksdGhpcy5fcG9zdChuKX11cGRhdGVCYXRjaEVyYXNlckNvbWJpbmVOb2RlKGUsdCl7Y29uc3Qgcj1bXTtsZXQgbjtmb3IoY29uc3QgcyBvZiB0LmtleXMoKSl0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShzKS5mb3JFYWNoKGw9Pntjb25zdCBjPWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bj1idChuLHt4OmMueC1YdC5TYWZlQm9yZGVyUGFkZGluZyx5OmMueS1YdC5TYWZlQm9yZGVyUGFkZGluZyx3OmMud2lkdGgrWHQuU2FmZUJvcmRlclBhZGRpbmcsaDpjLmhlaWdodCtYdC5TYWZlQm9yZGVyUGFkZGluZ30pLGwucmVtb3ZlKCl9KTtyZXR1cm4gZS5mb3JFYWNoKHM9Pntjb25zdCBsPXRoaXMudk5vZGVzLmdldChzKTtpZihsKWlmKHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHMpWzBdKW49YnQobixsLnJlY3QpO2Vsc2V7Y29uc3Qgbz10aGlzLnNldEZ1bGxXb3JrKHsuLi5sLHdvcmtJZDpzfSksZj1vJiZvLmNvbnN1bWVTZXJ2aWNlKHtvcDpsLm9wLGlzRnVsbFdvcms6ITB9KTtmJiYobC5yZWN0PWYsbj1idChuLGYpKX19KSxuJiZyLnB1c2goe3JlY3Q6bixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eHQuQmcsZHJhd0NhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSxyfXJ1bkVmZmVjdFNlbGVjdFdvcmsoKXt2YXIgZTtmb3IoY29uc3QgdCBvZiB0aGlzLmVmZmVjdFNlbGVjdE5vZGVEYXRhLnZhbHVlcygpKXtjb25zdCByPXRoaXMuc2V0RnVsbFdvcmsodCksbj10Lm9wcyYmQmUodC5vcHMpO3ImJihyLmNvbnN1bWVTZXJ2aWNlKHtvcDpuLGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihlPXIuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDplLnRvU3RyaW5nKCl9KSx0IT1udWxsJiZ0LnVwZGF0ZU5vZGVPcHQmJnIudXBkYXRhT3B0U2VydmljZSh0LnVwZGF0ZU5vZGVPcHQpLHQud29ya0lkJiZ0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQud29ya0lkKSl9dGhpcy5yZVJlbmRlclNlbGVjdG9yKCl9fWNsYXNzIFJke2NvbnN0cnVjdG9yKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VsZWN0b3JXb3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgU2V0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJ1bkVmZmVjdElkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm5vQW5pbWF0aW9uUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy52aWV3SWQ9ZS52aWV3SWQsdGhpcy52Tm9kZXM9ZS52Tm9kZXMsdGhpcy5mdWxsTGF5ZXI9ZS5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXI9ZS5kcmF3TGF5ZXIsdGhpcy5wb3N0PWUucG9zdH1kZXN0cm95KCl7dGhpcy53b3JrU2hhcGVzLmNsZWFyKCksdGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5jbGVhcigpfWNvbnN1bWVEcmF3KGUpe3RoaXMuYWN0aXZlV29ya1NoYXBlKGUpLHRoaXMucnVuQW5pbWF0aW9uKCl9Y29uc3VtZUZ1bGwoZSl7dGhpcy5hY3RpdmVXb3JrU2hhcGUoZSksdGhpcy5ydW5BbmltYXRpb24oKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKChlLHQpPT57ZS50b29sc1R5cGU9PT12dC5MYXNlclBlbj9zZXRUaW1lb3V0KCgpPT57dGhpcy53b3JrU2hhcGVzLmRlbGV0ZSh0KX0sMmUzKTp0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQpfSl9cnVuU2VsZWN0V29yayhlKXt0aGlzLmFjdGl2ZVNlbGVjdG9yU2hhcGUoZSk7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7ciYmdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKHIpLHRoaXMucnVuRWZmZWN0KCl9c2V0Tm9kZUtleShlLHQscil7cmV0dXJuIGUudG9vbHNUeXBlPXQsZS5ub2RlPWJuKHt0b29sc1R5cGU6dCx0b29sc09wdDpyLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZHJhd0xheWVyfSksZX1ydW5SZXZlcnNlU2VsZWN0V29yayhlKXtlLmZvckVhY2godD0+e3RoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmZvckVhY2goKHIsbik9Pnt2YXIgcztpZigocz1yLnNlbGVjdElkcykhPW51bGwmJnMubGVuZ3RoKXtjb25zdCBsPXIuc2VsZWN0SWRzLmluZGV4T2YodCk7bD4tMSYmKHIuc2VsZWN0SWRzLnNwbGljZShsLDEpLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChuKSl9fSl9KSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5zaXplJiZ0aGlzLnJ1bkVmZmVjdCgpfXJlbW92ZVdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7aWYocil7Y29uc3Qgbj10aGlzLndvcmtTaGFwZXMuZ2V0KHIpO2lmKG4pe3RoaXMud29ya1NoYXBlcy5kZWxldGUociksdGhpcy5yZW1vdmVOb2RlKHIsZSxuPT1udWxsP3ZvaWQgMDpuLnRvdGFsUmVjdCwhMSk7cmV0dXJufXRoaXMucmVtb3ZlTm9kZShyLGUpfX1yZW1vdmVTZWxlY3RXb3JrKGUpe2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO3ImJih0aGlzLmFjdGl2ZVNlbGVjdG9yU2hhcGUoZSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKHIpKSx0aGlzLnJ1bkVmZmVjdCgpfXJlbW92ZU5vZGUoZSx0LHIsbj0hMCl7dmFyIGY7Y29uc3Qgcz10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5jb25jYXQodGhpcy5kcmF3TGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkpO2UuaW5kZXhPZihSdC5zZWxlY3RvcklkKT4tMSYmdGhpcy5yZW1vdmVTZWxlY3RXb3JrKHQpO2NvbnN0IGw9W107bGV0IGM9cjtjb25zdCBvPShmPXRoaXMudk5vZGVzLmdldChlKSk9PW51bGw/dm9pZCAwOmYucmVjdDtvJiYoYz1idChvLGMpKSxzLmZvckVhY2goeD0+e2wucHVzaCh4KX0pLGwubGVuZ3RoJiZsLmZvckVhY2goeD0+eC5yZW1vdmUoKSksYyYmKHRoaXMucG9zdCh7cmVuZGVyOlt7cmVjdDpmZShjKSxpc0NsZWFyOiEwLGlzRnVsbFdvcms6bixjbGVhckNhbnZhczpuP3h0LkJnOnh0LkZsb2F0LGRyYXdDYW52YXM6bj94dC5CZzp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pLHRoaXMudk5vZGVzLmRlbGV0ZShlKSl9YWN0aXZlV29ya1NoYXBlKGUpe3ZhciB5LG0sVCxPO2NvbnN0e3dvcmtJZDp0LG9wdDpyLHRvb2xzVHlwZTpuLHR5cGU6cyx1cGRhdGVOb2RlT3B0Omwsb3BzOmMsb3A6byx1c2VBbmltYXRpb246Zn09ZTtpZighdClyZXR1cm47Y29uc3QgeD10LnRvU3RyaW5nKCk7aWYoISgoeT10aGlzLndvcmtTaGFwZXMpIT1udWxsJiZ5Lmhhcyh4KSkpe2xldCB2PXt0b29sc1R5cGU6bixhbmltYXRpb25Xb3JrRGF0YTpvfHxbXSxhbmltYXRpb25JbmRleDowLHR5cGU6cyx1cGRhdGVOb2RlT3B0Omwsb3BzOmMsdXNlQW5pbWF0aW9uOnR5cGVvZiBmPCJ1Ij9mOnR5cGVvZihsPT1udWxsP3ZvaWQgMDpsLnVzZUFuaW1hdGlvbik8InUiP2w9PW51bGw/dm9pZCAwOmwudXNlQW5pbWF0aW9uOiEwLG9sZFJlY3Q6KG09dGhpcy52Tm9kZXMuZ2V0KHgpKT09bnVsbD92b2lkIDA6bS5yZWN0LGlzRGlmZjohMX07biYmciYmKHY9dGhpcy5zZXROb2RlS2V5KHYsbixyKSksKFQ9dGhpcy53b3JrU2hhcGVzKT09bnVsbHx8VC5zZXQoeCx2KX1jb25zdCBnPShPPXRoaXMud29ya1NoYXBlcyk9PW51bGw/dm9pZCAwOk8uZ2V0KHgpO3MmJihnLnR5cGU9cyksYyYmKGcuYW5pbWF0aW9uV29ya0RhdGE9QmUoYyksZy5vcHM9YyksbCYmKGcudXBkYXRlTm9kZU9wdD1sKSxvJiYoZy5pc0RpZmY9dGhpcy5oYXNEaWZmRGF0YShnLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxvLGcudG9vbHNUeXBlKSxnLmFuaW1hdGlvbldvcmtEYXRhPW8pLGcubm9kZSYmZy5ub2RlLmdldFdvcmtJZCgpIT09eCYmZy5ub2RlLnNldFdvcmtJZCh4KSxnLnRvb2xzVHlwZSE9PW4mJm4mJnImJnRoaXMuc2V0Tm9kZUtleShnLG4scil9aGFzRGlmZkRhdGEoZSx0LHIpe2NvbnN0IG49ZS5sZW5ndGg7aWYodC5sZW5ndGg8bilyZXR1cm4hMDtzd2l0Y2gocil7Y2FzZSB2dC5QZW5jaWw6e2ZvcihsZXQgcz0wO3M8bjtzKz0zKWlmKHRbc10hPT1lW3NdfHx0W3MrMV0hPT1lW3MrMV0pcmV0dXJuITA7YnJlYWt9Y2FzZSB2dC5MYXNlclBlbjp7Zm9yKGxldCBzPTA7czxuO3MrPTIpaWYodFtzXSE9PWVbc118fHRbcysxXSE9PWVbcysxXSlyZXR1cm4hMDticmVha319cmV0dXJuITF9YW5pbWF0aW9uRHJhdygpe3ZhciBvLGYseCxnLHk7dGhpcy5hbmltYXRpb25JZD12b2lkIDA7bGV0IGU9ITE7Y29uc3QgdD1uZXcgTWFwLHI9W10sbj1bXSxzPVtdLGw9W107dGhpcy53b3JrU2hhcGVzLmZvckVhY2goKG0sVCk9Pnt2YXIgTyx2LFAsaSx1LGEsaCxiLEUsQSxMLFMsSSxELFIsQyxqLCQsSCxKLHEsRixHO3N3aXRjaChtLnRvb2xzVHlwZSl7Y2FzZSB2dC5UZXh0OntpZihtLm5vZGUpe2NvbnN0IFo9bS5vbGRSZWN0LHR0PShPPW0ubm9kZSk9PW51bGw/dm9pZCAwOk8uY29uc3VtZVNlcnZpY2Uoe29wOm0uYW5pbWF0aW9uV29ya0RhdGF8fFtdLGlzRnVsbFdvcms6ITB9KTt0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5mb3JFYWNoKChldCxpdCk9Pnt2YXIgazsoaz1ldC5zZWxlY3RJZHMpIT1udWxsJiZrLmluY2x1ZGVzKFQpJiYodGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKGl0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxaKSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCx0dCksdGhpcy5ydW5FZmZlY3QoKSl9KSwodj1tLm5vZGUpPT1udWxsfHx2LmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShUKX1icmVha31jYXNlIHZ0LkFycm93OmNhc2UgdnQuU3RyYWlnaHQ6Y2FzZSB2dC5SZWN0YW5nbGU6Y2FzZSB2dC5FbGxpcHNlOmNhc2UgdnQuU3RhcjpjYXNlIHZ0LlBvbHlnb246Y2FzZSB2dC5TcGVlY2hCYWxsb29uOntjb25zdCBaPSEhbS5vcHM7aWYoKFA9bS5hbmltYXRpb25Xb3JrRGF0YSkhPW51bGwmJlAubGVuZ3RoKXtjb25zdCB0dD1tLm9sZFJlY3QsZXQ9bS5ub2RlLm9sZFJlY3Q7dHQmJnMucHVzaCh7cmVjdDp0dCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnh0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLGV0JiZsLnB1c2goe3JlY3Q6ZXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBpdD0oaT1tLm5vZGUpPT1udWxsP3ZvaWQgMDppLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhLGlzRnVsbFdvcms6Wn0pO3Quc2V0KFQse3dvcmtTdGF0ZTp0dD9tLm9wcz9JdC5Eb25lOkl0LkRvaW5nOkl0LlN0YXJ0LG9wOm0uYW5pbWF0aW9uV29ya0RhdGEuZmlsdGVyKChrLGh0KT0+e2lmKGh0JTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpfSksWj8odGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgoayxodCk9Pnt2YXIgZnQ7KGZ0PWsuc2VsZWN0SWRzKSE9bnVsbCYmZnQuaW5jbHVkZXMoVCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaHQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHR0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxldCksdGhpcy5ub0FuaW1hdGlvblJlY3Q9YnQodGhpcy5ub0FuaW1hdGlvblJlY3QsaXQpLHRoaXMucnVuRWZmZWN0KCkpfSksKHU9bS5ub2RlKT09bnVsbHx8dS5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoVCksci5wdXNoKHtyZWN0Oml0LGRyYXdDYW52YXM6eHQuQmcsaXNGdWxsV29yazpaLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHQuc2V0KFQse3dvcmtTdGF0ZTpJdC5Eb25lLG9wOm0uYW5pbWF0aW9uV29ya0RhdGEuZmlsdGVyKChrLGh0KT0+e2lmKGh0JTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpfSkpOm4ucHVzaCh7cmVjdDppdCxkcmF3Q2FudmFzOnh0LkZsb2F0LGlzRnVsbFdvcms6Wix2aWV3SWQ6dGhpcy52aWV3SWR9KSxtLmFuaW1hdGlvbldvcmtEYXRhLmxlbmd0aD0wfWJyZWFrfWNhc2UgdnQuUGVuY2lsOntpZighbS51c2VBbmltYXRpb24mJm0ub3BzKXtsZXQgWj0oYT1tLm5vZGUpPT1udWxsP3ZvaWQgMDphLmNvbnN1bWVTZXJ2aWNlKHtvcDptLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDpUfSk7Y29uc3QgdHQ9KGg9bS5ub2RlKT09bnVsbD92b2lkIDA6aC51cGRhdGFPcHRTZXJ2aWNlKG0udXBkYXRlTm9kZU9wdCk7Wj1idChaLHR0KSxzLnB1c2goe3JlY3Q6YnQobS5vbGRSZWN0LFopLGNsZWFyQ2FudmFzOnh0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHIucHVzaCh7cmVjdDpidChtLm9sZFJlY3QsWiksZHJhd0NhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSx0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5mb3JFYWNoKChldCxpdCk9Pnt2YXIgazsoaz1ldC5zZWxlY3RJZHMpIT1udWxsJiZrLmluY2x1ZGVzKFQpJiYodGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKGl0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxaKSx0aGlzLnJ1bkVmZmVjdCgpKX0pLChiPW0ubm9kZSk9PW51bGx8fGIuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKFQpfWVsc2UgaWYobS51c2VBbmltYXRpb24pe2NvbnN0IHR0PXRoaXMuY29tcHV0TmV4dEFuaW1hdGlvbkluZGV4KG0sMyksZXQ9bS5pc0RpZmY/MDpNYXRoLm1heCgwLChtLmFuaW1hdGlvbkluZGV4fHwwKS0zKSxpdD0obS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKGV0LHR0KTtpZihtLmlzRGVsKW0uaXNEZWwmJigoQz1tLm5vZGUpPT1udWxsfHxDLmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShUKSk7ZWxzZXtpZigobS5hbmltYXRpb25JbmRleHx8MCk8dHR8fG0uaXNEaWZmKXtjb25zdCBrPShBPW0ubm9kZSk9PW51bGw/dm9pZCAwOkEuY29uc3VtZVNlcnZpY2Uoe29wOml0LGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihFPW0ubm9kZS5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOkUudG9TdHJpbmcoKX0pO2lmKG4ucHVzaCh7cmVjdDprLGRyYXdDYW52YXM6eHQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksbS5hbmltYXRpb25JbmRleD10dCxtLmlzRGlmZiYmKG0uaXNEaWZmPSExKSxpdC5sZW5ndGgpe2NvbnN0IGh0PWl0LmZpbHRlcigoZnQsQik9PntpZihCJTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpO3Quc2V0KFQse3dvcmtTdGF0ZTpldD09PTA/SXQuU3RhcnQ6dHQ9PT0oKEw9bS5hbmltYXRpb25Xb3JrRGF0YSk9PW51bGw/dm9pZCAwOkwubGVuZ3RoKT9JdC5Eb25lOkl0LkRvaW5nLG9wOmh0fSl9fWVsc2UgaWYobS5vcHMpe2NvbnN0IGs9KEk9bS5ub2RlKT09bnVsbD92b2lkIDA6SS5jb25zdW1lU2VydmljZSh7b3A6bS5hbmltYXRpb25Xb3JrRGF0YXx8W10saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KFM9bS5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6Uy50b1N0cmluZygpfSk7bS5pc0RlbD0hMCxsLnB1c2goe3JlY3Q6ayxjbGVhckNhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSwoRD1tLm5vZGUpIT1udWxsJiZELmdldFdvcmtPcHRpb25zKCkuaXNPcGFjaXR5JiZzLnB1c2goe3JlY3Q6ayxjbGVhckNhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSxyLnB1c2goe3JlY3Q6ayxkcmF3Q2FudmFzOnh0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMudk5vZGVzLnNldEluZm8oVCx7b3A6bS5hbmltYXRpb25Xb3JrRGF0YSxvcHQ6KFI9bS5ub2RlKT09bnVsbD92b2lkIDA6Ui5nZXRXb3JrT3B0aW9ucygpLHRvb2xzVHlwZTptLnRvb2xzVHlwZSxyZWN0Omt9KSx0LnNldChULHt3b3JrU3RhdGU6SXQuRG9uZSxvcDppdC5maWx0ZXIoKGh0LGZ0KT0+e2lmKGZ0JTMhPT0yKXJldHVybiEwfSkuc2xpY2UoLTIpfSl9ZT0hMH1icmVha31icmVha31jYXNlIHZ0Lkxhc2VyUGVuOntjb25zdCB0dD10aGlzLmNvbXB1dE5leHRBbmltYXRpb25JbmRleChtLDIpLGV0PU1hdGgubWF4KDAsKG0uYW5pbWF0aW9uSW5kZXh8fDApLTIpLGl0PShtLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkuc2xpY2UoZXQsdHQpO2lmKG0uaXNEZWwpe2lmKG0uaXNEZWwpe2NvbnN0IGs9KEY9bS5ub2RlKT09bnVsbD92b2lkIDA6Ri5jb25zdW1lU2VydmljZSh7b3A6W10saXNGdWxsV29yazohMX0pO20udG90YWxSZWN0PWJ0KG0udG90YWxSZWN0LGspLGwucHVzaCh7cmVjdDptLnRvdGFsUmVjdCxjbGVhckNhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxuLnB1c2goe3JlY3Q6bS50b3RhbFJlY3QsZHJhd0NhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSwoRz1tLm5vZGUpPT1udWxsfHxHLmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShUKX19ZWxzZXtpZigobS5hbmltYXRpb25JbmRleHx8MCk8dHQpe2NvbnN0IGs9KCQ9bS5ub2RlKT09bnVsbD92b2lkIDA6JC5jb25zdW1lU2VydmljZSh7b3A6aXQsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6KGo9bS5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6ai50b1N0cmluZygpfSk7bS50b3RhbFJlY3Q9YnQobS50b3RhbFJlY3QsayksbS50aW1lciYmKGNsZWFyVGltZW91dChtLnRpbWVyKSxtLnRpbWVyPXZvaWQgMCksbS5hbmltYXRpb25JbmRleD10dCxpdC5sZW5ndGgmJnQuc2V0KFQse3dvcmtTdGF0ZTpldD09PTA/SXQuU3RhcnQ6dHQ9PT0oKEg9bS5hbmltYXRpb25Xb3JrRGF0YSk9PW51bGw/dm9pZCAwOkgubGVuZ3RoKT9JdC5Eb25lOkl0LkRvaW5nLG9wOml0LnNsaWNlKC0yKX0pfWVsc2V7bS50aW1lcnx8KG0udGltZXI9c2V0VGltZW91dCgoKT0+e20udGltZXI9dm9pZCAwLG0uaXNEZWw9ITAsdGhpcy5ydW5BbmltYXRpb24oKX0sKChKPW0ubm9kZSk9PW51bGw/dm9pZCAwOkouZ2V0V29ya09wdGlvbnMoKSkuZHVyYXRpb24qMWUzKzEwMCksdC5zZXQoVCx7d29ya1N0YXRlOkl0LkRvbmUsb3A6W119KSk7Y29uc3Qgaz0ocT1tLm5vZGUpPT1udWxsP3ZvaWQgMDpxLmNvbnN1bWVTZXJ2aWNlKHtvcDpbXSxpc0Z1bGxXb3JrOiExfSk7bS50b3RhbFJlY3Q9YnQobS50b3RhbFJlY3Qsayl9bC5wdXNoKHtyZWN0Om0udG90YWxSZWN0LGNsZWFyQ2FudmFzOnh0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLG4ucHVzaCh7cmVjdDptLnRvdGFsUmVjdCxkcmF3Q2FudmFzOnh0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLGU9ITB9YnJlYWt9fX0pLGUmJnRoaXMucnVuQW5pbWF0aW9uKCk7Y29uc3QgYz17cmVuZGVyOltdfTtpZihzLmxlbmd0aCl7Y29uc3QgbT1zLnJlZHVjZSgoVCxPKT0+KE8ucmVjdCYmTy5jbGVhckNhbnZhcz09PXh0LkJnJiYoVC5yZWN0PWJ0KFQucmVjdCxPLnJlY3QpKSxUKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KTttLnJlY3QmJihtLnJlY3Q9bS5yZWN0JiZmZShtLnJlY3QpLChvPWMucmVuZGVyKT09bnVsbHx8by5wdXNoKG0pKX1pZihsLmxlbmd0aCl7Y29uc3QgbT1sLnJlZHVjZSgoVCxPKT0+KE8ucmVjdCYmTy5jbGVhckNhbnZhcz09PXh0LkZsb2F0JiYoVC5yZWN0PWJ0KFQucmVjdCxPLnJlY3QpKSxUKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTttLnJlY3QmJihtLnJlY3Q9bS5yZWN0JiZmZShtLnJlY3QpLChmPWMucmVuZGVyKT09bnVsbHx8Zi5wdXNoKG0pKX1pZihyLmxlbmd0aCl7Y29uc3QgbT1yLnJlZHVjZSgoVCxPKT0+KE8ucmVjdCYmTy5kcmF3Q2FudmFzPT09eHQuQmcmJihULnJlY3Q9YnQoVC5yZWN0LE8ucmVjdCkpLFQpLHtpc0Z1bGxXb3JrOiEwLGRyYXdDYW52YXM6eHQuQmcsdmlld0lkOnRoaXMudmlld0lkfSk7bS5yZWN0JiYobS5yZWN0PW0ucmVjdCYmZmUobS5yZWN0KSwoeD1jLnJlbmRlcik9PW51bGx8fHgucHVzaChtKSl9aWYobi5sZW5ndGgpe2NvbnN0IG09bi5yZWR1Y2UoKFQsTyk9PihPLnJlY3QmJk8uZHJhd0NhbnZhcz09PXh0LkZsb2F0JiYoVC5yZWN0PWJ0KFQucmVjdCxPLnJlY3QpKSxUKSx7aXNGdWxsV29yazohMSxkcmF3Q2FudmFzOnh0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH0pO20ucmVjdCYmKG0ucmVjdD1tLnJlY3QmJmZlKG0ucmVjdCksKGc9Yy5yZW5kZXIpPT1udWxsfHxnLnB1c2gobSkpfXQuc2l6ZSYmKGMuc3A9W10sdC5mb3JFYWNoKChtLFQpPT57dmFyIE87KE89Yy5zcCk9PW51bGx8fE8ucHVzaCh7dHlwZTp1dC5DdXJzb3IsdWlkOlQuc3BsaXQoQ2gpWzBdLG9wOm0ub3Asd29ya1N0YXRlOm0ud29ya1N0YXRlLHZpZXdJZDp0aGlzLnZpZXdJZH0pfSkpLCh5PWMucmVuZGVyKSE9bnVsbCYmeS5sZW5ndGgmJnRoaXMucG9zdChjKX1ydW5BbmltYXRpb24oKXt0aGlzLmFuaW1hdGlvbklkfHwodGhpcy5hbmltYXRpb25JZD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EcmF3LmJpbmQodGhpcykpKX1jb21wdXROZXh0QW5pbWF0aW9uSW5kZXgoZSx0KXt2YXIgbjtjb25zdCByPU1hdGguZmxvb3IoKGUuYW5pbWF0aW9uV29ya0RhdGF8fFtdKS5zbGljZShlLmFuaW1hdGlvbkluZGV4KS5sZW5ndGgqMzIvdC8oKChuPWUubm9kZSk9PW51bGw/dm9pZCAwOm4uc3luY1VuaXRUaW1lKXx8MWUzKSkqdDtyZXR1cm4gTWF0aC5taW4oKGUuYW5pbWF0aW9uSW5kZXh8fDApKyhyfHx0KSwoZS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLmxlbmd0aCl9cnVuRWZmZWN0KCl7dGhpcy5ydW5FZmZlY3RJZHx8KHRoaXMucnVuRWZmZWN0SWQ9c2V0VGltZW91dCh0aGlzLmVmZmVjdFJ1blNlbGVjdG9yLmJpbmQodGhpcyksMCkpfWVmZmVjdFJ1blNlbGVjdG9yKCl7dGhpcy5ydW5FZmZlY3RJZD12b2lkIDA7bGV0IGU9dGhpcy5ub0FuaW1hdGlvblJlY3Q7dGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuZm9yRWFjaCh0PT57dmFyIHMsbDtjb25zdCByPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmdldCh0KSxuPXImJnIuc2VsZWN0SWRzJiYoKHM9ci5ub2RlKT09bnVsbD92b2lkIDA6cy5zZWxlY3RTZXJ2aWNlTm9kZSh0LHIsITApKTtlPWJ0KGUsbiksKGw9cj09bnVsbD92b2lkIDA6ci5zZWxlY3RJZHMpIT1udWxsJiZsLmxlbmd0aHx8dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZGVsZXRlKHQpfSksZSYmdGhpcy5wb3N0KHtyZW5kZXI6W3tyZWN0OmZlKGUpLGRyYXdDYW52YXM6eHQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczp4dC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuY2xlYXIoKSx0aGlzLm5vQW5pbWF0aW9uUmVjdD12b2lkIDB9YWN0aXZlU2VsZWN0b3JTaGFwZShlKXt2YXIgZix4LGc7Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOm4sdHlwZTpzLHNlbGVjdElkczpsfT1lO2lmKCF0KXJldHVybjtjb25zdCBjPXQudG9TdHJpbmcoKTtpZighKChmPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzKSE9bnVsbCYmZi5oYXMoYykpKXtsZXQgeT17dG9vbHNUeXBlOm4sc2VsZWN0SWRzOmwsdHlwZTpzLG9wdDpyfTtuJiZyJiYoeT10aGlzLnNldE5vZGVLZXkoeSxuLHIpKSwoeD10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGx8fHguc2V0KGMseSl9Y29uc3Qgbz0oZz10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGw/dm9pZCAwOmcuZ2V0KGMpO3MmJihvLnR5cGU9cyksby5ub2RlJiZvLm5vZGUuZ2V0V29ya0lkKCkhPT1jJiZvLm5vZGUuc2V0V29ya0lkKGMpLG8uc2VsZWN0SWRzPWx8fFtdfX1jbGFzcyBJZCBleHRlbmRzIE1ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25Xb3JrUmVjdHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVEcmF3VGltZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2xvc2VBbmltYXRpb25UaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTEwMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJydW5MYXNlclBlblN0ZXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSl9cnVuRnVsbFdvcmsoZSx0KXt2YXIgcztjb25zdCByPXRoaXMuc2V0RnVsbFdvcmsoZSksbj1lLm9wcyYmQmUoZS5vcHMpO2lmKHIpe2NvbnN0IGw9ci5jb25zdW1lU2VydmljZSh7b3A6bixpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDoocz1yLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpLGlzRHJhd0xhYmVsOnR9KSxjPShlPT1udWxsP3ZvaWQgMDplLnVwZGF0ZU5vZGVPcHQpJiZyLnVwZGF0YU9wdFNlcnZpY2UoZS51cGRhdGVOb2RlT3B0KTtyZXR1cm4gZS53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoZS53b3JrSWQpLGN8fGx9fXJ1blNlbGVjdFdvcmsoZSl7dmFyIHI7Y29uc3QgdD10aGlzLnNldEZ1bGxXb3JrKGUpO3QmJigocj1lLnNlbGVjdElkcykhPW51bGwmJnIubGVuZ3RoKSYmZS53b3JrSWQmJnQuc2VsZWN0U2VydmljZU5vZGUoZS53b3JrSWQudG9TdHJpbmcoKSx7c2VsZWN0SWRzOmUuc2VsZWN0SWRzfSwhMSl9Y29uc3VtZURyYXcoZSl7dmFyIG47Y29uc3R7b3A6dCx3b3JrSWQ6cn09ZTtpZih0IT1udWxsJiZ0Lmxlbmd0aCYmcil7Y29uc3Qgcz10aGlzLndvcmtTaGFwZXMuZ2V0KHIpO2lmKCFzKXJldHVybjtjb25zdCBsPXMudG9vbHNUeXBlLGM9cy5jb25zdW1lKHtkYXRhOmUsaXNGdWxsV29yazohMSxpc0NsZWFyQWxsOiEwLGlzU3ViV29ya2VyOiEwfSk7c3dpdGNoKGwpe2Nhc2UgdnQuTGFzZXJQZW46YyE9bnVsbCYmYy5yZWN0JiYoKG49dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxuLnNldChyLHtyZXM6YyxjYW5EZWw6ITEsaXNSZWN0OiEwfSkpLHRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oKTticmVhaztjYXNlIHZ0LkFycm93OmNhc2UgdnQuU3RyYWlnaHQ6Y2FzZSB2dC5FbGxpcHNlOmNhc2UgdnQuUmVjdGFuZ2xlOmNhc2UgdnQuU3RhcjpjYXNlIHZ0LlBvbHlnb246Y2FzZSB2dC5TcGVlY2hCYWxsb29uOmMmJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd0Fycm93KGMpKTticmVhaztjYXNlIHZ0LlBlbmNpbDpjJiYodGhpcy5kcmF3Q291bnQrKyx0aGlzLmRyYXdQZW5jaWwoYykpO2JyZWFrfX19Y29uc3VtZURyYXdBbGwoZSl7dmFyIHIsbjtjb25zdHt3b3JrSWQ6dH09ZTtpZih0KXtjb25zdCBzPXRoaXMud29ya1NoYXBlcy5nZXQodCk7aWYoIXMpcmV0dXJuO3N3aXRjaChzLnRvb2xzVHlwZSl7Y2FzZSB2dC5MYXNlclBlbjppZih0aGlzLmFuaW1hdGlvbklkKXtjb25zdCBjPXMuY29uc3VtZUFsbCh7ZGF0YTplfSk7YyE9bnVsbCYmYy5vcCYmYyE9bnVsbCYmYy5yZWN0JiYoKHI9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxyLnNldCh0LHtyZXM6YyxjYW5EZWw6ITEsaXNSZWN0OiEwfSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbihjKSk7Y29uc3Qgbz0obj1zLmdldFdvcmtPcHRpb25zKCkpPT1udWxsP3ZvaWQgMDpuLmR1cmF0aW9uO3RoaXMuY2xvc2VBbmltYXRpb25UaW1lPW8/byoxZTMrMTAwOnRoaXMuY2xvc2VBbmltYXRpb25UaW1lLHNldFRpbWVvdXQoKCk9Pnt2YXIgeDt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0LnRvU3RyaW5nKCkpLm1hcChnPT5nLnJlbW92ZSgpKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2NvbnN0IGY9KHg9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsP3ZvaWQgMDp4LmdldCh0KTtmJiYoZi5jYW5EZWw9ITApLHNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3JlbW92ZUlkczpbdC50b1N0cmluZygpXSx0eXBlOnV0LlJlbW92ZU5vZGV9XX0pfSxzLmdldFdvcmtPcHRpb25zKCkuc3luY1VuaXRUaW1lfHx0aGlzLmNsb3NlQW5pbWF0aW9uVGltZSl9LHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKX1icmVhaztjYXNlIHZ0LkFycm93OmNhc2UgdnQuU3RyYWlnaHQ6Y2FzZSB2dC5FbGxpcHNlOmNhc2UgdnQuUGVuY2lsOmNhc2UgdnQuUmVjdGFuZ2xlOmNhc2UgdnQuU3RhcjpjYXNlIHZ0LlBvbHlnb246Y2FzZSB2dC5TcGVlY2hCYWxsb29uOnRoaXMuZHJhd0NvdW50PTAsdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpO2JyZWFrfX19dXBkYXRlTGFiZWxzKGUsdCl7ZS5jaGlsZHJlbi5mb3JFYWNoKHI9PntpZihyLnRhZ05hbWU9PT0iTEFCRUwiKXtjb25zdCBuPXIubmFtZSx7d2lkdGg6c309ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxbbF09ZS53b3JsZFNjYWxpbmcse3VuZGVybGluZTpjLGxpbmVUaHJvdWdoOm99PXQub3B0O2MmJmUuZ2V0RWxlbWVudHNCeU5hbWUoYCR7bn1fdW5kZXJsaW5lYClbMF0uYXR0cih7cG9pbnRzOlswLDAscy9sLDBdfSksbyYmZS5nZXRFbGVtZW50c0J5TmFtZShgJHtufV9saW5lVGhyb3VnaGApWzBdLmF0dHIoe3BvaW50czpbMCwwLHMvbCwwXX0pfX0pfXJ1bkxhc2VyUGVuQW5pbWF0aW9uKGUpe3RoaXMuYW5pbWF0aW9uSWR8fCh0aGlzLmFuaW1hdGlvbklkPXJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e3ZhciBuLHM7aWYodGhpcy5hbmltYXRpb25JZD12b2lkIDAsdGhpcy5ydW5MYXNlclBlblN0ZXArKyx0aGlzLnJ1bkxhc2VyUGVuU3RlcD4xKXt0aGlzLnJ1bkxhc2VyUGVuU3RlcD0wLHRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oZSk7cmV0dXJufWxldCB0O2NvbnN0IHI9W107KG49dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpPT1udWxsfHxuLmZvckVhY2goKGwsYyxvKT0+e2wuaXNSZWN0JiYodD1idCh0LGwucmVzLnJlY3QpKSxsLnJlcy53b3JrSWQmJnIucHVzaChsLnJlcyksdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoYy50b1N0cmluZygpKS5sZW5ndGg/bC5pc1JlY3Q9ITA6bC5pc1JlY3Q9ITEsbC5jYW5EZWwmJm8uZGVsZXRlKGMpfSksKHM9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpIT1udWxsJiZzLnNpemUmJnRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oKSx0JiYoZSYmci5wdXNoKGUpLHRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6dCxkcmF3Q2FudmFzOnh0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpyfSkpfSkpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHJlbmRlcjpbe3JlY3Q6ZT09bnVsbD92b2lkIDA6ZS5yZWN0LGRyYXdDYW52YXM6eHQuRmxvYXQsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd0Fycm93KGUpe3RoaXMuX3Bvc3Qoe2RyYXdDb3VudDp0aGlzLmRyYXdDb3VudCxyZW5kZXI6W3tyZWN0OmU9PW51bGw/dm9pZCAwOmUucmVjdCxkcmF3Q2FudmFzOnh0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eHQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pfX12YXIgUGU7KGZ1bmN0aW9uKGQpe2QuRnVsbD0iZnVsbCIsZC5TdWI9InN1YiJ9KShQZXx8KFBlPXt9KSk7Y2xhc3MgTGR7Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3NlbGYiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrVGhyZWFkTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMuX3NlbGY9ZSx0aGlzLnR5cGU9dCx0aGlzLnJlZ2lzdGVyKCl9aW5pdChlKXtjb25zdHt2aWV3SWQ6dCxkcHI6cixvZmZzY3JlZW5DYW52YXNPcHQ6bixsYXllck9wdDpzfT1lO2lmKCFyfHwhbnx8IXMpcmV0dXJuO2xldCBsO3RoaXMudHlwZT09PVBlLkZ1bGwmJihsPW5ldyBEZCh0LHtkcHI6cixvZmZzY3JlZW5DYW52YXNPcHQ6bixsYXllck9wdDpzfSx0aGlzLnBvc3QuYmluZCh0aGlzKSkpLHRoaXMudHlwZT09PVBlLlN1YiYmKGw9bmV3IHdkKHQse2RwcjpyLG9mZnNjcmVlbkNhbnZhc09wdDpuLGxheWVyT3B0OnN9LHRoaXMucG9zdC5iaW5kKHRoaXMpKSksbCYmZS5jYW1lcmFPcHQmJmwuc2V0Q2FtZXJhT3B0KGUuY2FtZXJhT3B0KSxsJiZ0aGlzLndvcmtUaHJlYWRNYXAuc2V0KHQsbCl9cmVnaXN0ZXIoKXtvbm1lc3NhZ2U9ZT0+e2NvbnN0IHQ9ZS5kYXRhO2lmKHQpZm9yKGNvbnN0IHIgb2YgdC52YWx1ZXMoKSl7Y29uc3R7bXNnVHlwZTpuLHZpZXdJZDpzLHRhc2tzcXVldWU6bCxtYWluVGFza3NxdWV1ZUNvdW50OmN9PXI7aWYobj09PXV0LkluaXQpe3RoaXMuaW5pdChyKTtjb250aW51ZX1pZihuPT09dXQuVGFza3NRdWV1ZSYmKGwhPW51bGwmJmwuc2l6ZSkmJmMpe3RoaXMud29ya1RocmVhZE1hcC5mb3JFYWNoKChmLHgpPT57Y29uc3QgZz1sLmdldCh4KTtnJiZmLm9uKGcpLHRoaXMucG9zdCh7d29ya2VyVGFza3NxdWV1ZUNvdW50OmN9KX0pO2NvbnRpbnVlfWlmKHM9PT1JaCl7dGhpcy53b3JrVGhyZWFkTWFwLmZvckVhY2goZj0+e2Yub24ociksbj09PXV0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUocyl9KTtjb250aW51ZX1jb25zdCBvPXRoaXMud29ya1RocmVhZE1hcC5nZXQocyk7byYmKG8ub24ociksbj09PXV0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUocykpfX19cG9zdChlLHQpe3Q/dGhpcy5fc2VsZi5wb3N0TWVzc2FnZShlLHQpOnRoaXMuX3NlbGYucG9zdE1lc3NhZ2UoZSl9fWNsYXNzIERkIGV4dGVuZHMgU257Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKGUsdCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJtZXRob2RCdWlsZGVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuX3Bvc3Q9cix0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJkcmF3TGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZToxZTN9KTtjb25zdCBuPXt2aWV3SWQ6dGhpcy52aWV3SWQsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXIscG9zdDp0aGlzLnBvc3QuYmluZCh0aGlzKX07dGhpcy5sb2NhbFdvcms9bmV3IENkKG4pLHRoaXMuc2VydmljZVdvcms9bmV3IFJkKG4pLHRoaXMubWV0aG9kQnVpbGRlcj1uZXcgWWgoW0N0LkNvcHlOb2RlLEN0LlNldENvbG9yTm9kZSxDdC5EZWxldGVOb2RlLEN0LlJvdGF0ZU5vZGUsQ3QuU2NhbGVOb2RlLEN0LlRyYW5zbGF0ZU5vZGUsQ3QuWkluZGV4QWN0aXZlLEN0LlpJbmRleE5vZGUsQ3QuU2V0Rm9udFN0eWxlLEN0LlNldFBvaW50XSkucmVnaXN0ZXJGb3JXb3JrZXIodGhpcy5sb2NhbFdvcmssdGhpcy5zZXJ2aWNlV29yayksdGhpcy52Tm9kZXMuaW5pdCh0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcil9YXN5bmMgcG9zdChlLHQpe3ZhciBjLG8sZjtjb25zdCByPWUucmVuZGVyLG49W107bGV0IHM9dDtpZihyIT1udWxsJiZyLmxlbmd0aCl7Zm9yKGNvbnN0IHggb2Ygcil7aWYoeC5pc0NsZWFyQWxsJiYoeC5yZWN0PXRoaXMuZ2V0U2NlbmVSZWN0KCkseC5pc0NsZWFyPSEwLGRlbGV0ZSB4LmlzQ2xlYXJBbGwpLHguaXNEcmF3QWxsJiYoeC5yZWN0PXRoaXMuZ2V0U2NlbmVSZWN0KCksZGVsZXRlIHguaXNEcmF3QWxsKSx4LmRyYXdDYW52YXMpe2NvbnN0IGc9eC5pc0Z1bGxXb3JrP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyOyhnPT1udWxsP3ZvaWQgMDpnLnBhcmVudCkucmVuZGVyKCl9aWYoeC5yZWN0KXt4LmNsZWFyQ2FudmFzPT09eC5kcmF3Q2FudmFzJiZ4LmRyYXdDYW52YXM9PT14dC5CZyYmKHgucmVjdD10aGlzLmNoZWNrUmlnaHRSZWN0Qm91bmRpbmdCb3goeC5yZWN0KSk7Y29uc3QgZz14LnJlY3Q7aWYoeC5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChZdCh4LnJlY3QpKSx4LmRyYXdDYW52YXMseHQuU2VsZWN0b3IsIXgucmVjdCljb250aW51ZTtpZih4LmRyYXdDYW52YXM9PT14dC5TZWxlY3Rvcil7Y29uc3QgeT0oYz1lLnNwKT09bnVsbD92b2lkIDA6Yy5maW5kKG09Pm0udHlwZT09PXV0LlNlbGVjdCk7eSYmKHkucmVjdD14LnJlY3QpLHgub2Zmc2V0PXt4OngucmVjdC54LWcueCx5OngucmVjdC55LWcueX19aWYoeC5kcmF3Q2FudmFzKXtjb25zdCB5PWF3YWl0IHRoaXMuZ2V0UmVjdEltYWdlQml0bWFwKHgucmVjdCwhIXguaXNGdWxsV29yayk7eC5pbWFnZUJpdG1hcD15LHN8fChzPVtdKSxzLnB1c2goeSl9bi5wdXNoKHgpfX1lLnJlbmRlcj1ufWNvbnN0IGw9KG89ZS5zcCk9PW51bGw/dm9pZCAwOm8uZmlsdGVyKHg9PngudHlwZSE9PXV0Lk5vbmV8fE9iamVjdC5rZXlzKHgpLmZpbHRlcihnPT5nPT09InR5cGUiKS5sZW5ndGgpO2lmKGwhPW51bGwmJmwubGVuZ3RoJiYoZS5zcD1sLm1hcCh4PT4oey4uLngsdmlld0lkOnRoaXMudmlld0lkfSkpKSwoZS5kcmF3Q291bnR8fGUud29ya2VyVGFza3NxdWV1ZUNvdW50fHwoZj1lLnNwKSE9bnVsbCYmZi5sZW5ndGh8fG4hPW51bGwmJm4ubGVuZ3RoKSYmKHRoaXMuX3Bvc3QoZSxzKSxzIT1udWxsJiZzLmxlbmd0aCkpZm9yKGNvbnN0IHggb2Ygcyl4IGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAmJnguY2xvc2UoKX1vbihlKXtpZih0aGlzLm1ldGhvZEJ1aWxkZXIuY29uc3VtZUZvcldvcmtlcihlKSlyZXR1cm47Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsd29ya0lkOm59PWU7c3dpdGNoKHQpe2Nhc2UgdXQuVXBkYXRlQ2FtZXJhOnRoaXMudXBkYXRlQ2FtZXJhKGUpO2JyZWFrO2Nhc2UgdXQuU2VsZWN0OnI9PT1QdC5TZXJ2aWNlJiYobj09PVJ0LnNlbGVjdG9ySWQ/dGhpcy5sb2NhbFdvcmsudXBkYXRlRnVsbFNlbGVjdFdvcmsoZSk6dGhpcy5zZXJ2aWNlV29yay5ydW5TZWxlY3RXb3JrKGUpKTticmVhaztjYXNlIHV0LlVwZGF0ZU5vZGU6Y2FzZSB1dC5GdWxsV29yazp0aGlzLmNvbnN1bWVGdWxsKHIsZSk7YnJlYWs7Y2FzZSB1dC5SZW1vdmVOb2RlOnRoaXMucmVtb3ZlTm9kZShlKTticmVhaztjYXNlIHV0LkdldFRleHRBY3RpdmU6dGhpcy5jaGVja1RleHRBY3RpdmUoZSk7YnJlYWt9c3VwZXIub24oZSl9cmVtb3ZlTm9kZShlKXtjb25zdHtkYXRhVHlwZTp0LHdvcmtJZDpyfT1lO3I9PT1SdC5zZWxlY3RvcklkJiZ0aGlzLmxvY2FsV29yay5ibHVyU2VsZWN0b3IoZSksdD09PVB0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsucmVtb3ZlV29yayhlKSx0PT09UHQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLnJlbW92ZVdvcmsoZSl9Y2hlY2tUZXh0QWN0aXZlKGUpe2NvbnN0e2RhdGFUeXBlOnR9PWU7dD09PVB0LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jaGVja1RleHRBY3RpdmUoZSl9Y2xlYXJBbGwoKXt0aGlzLnZOb2Rlcy5jbGVhcigpLHN1cGVyLmNsZWFyQWxsKCksdGhpcy5wb3N0KHtyZW5kZXI6W3tpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnh0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSx7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp4dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOlt7dHlwZTp1dC5DbGVhcn1dfSl9c2V0Q2FtZXJhT3B0KGUpe3RoaXMuY2FtZXJhT3B0PWU7Y29uc3R7c2NhbGU6dCxjZW50ZXJYOnIsY2VudGVyWTpuLHdpZHRoOnMsaGVpZ2h0Omx9PWU7KHMhPT10aGlzLnNjZW5lLndpZHRofHxsIT09dGhpcy5zY2VuZS5oZWlnaHQpJiZ0aGlzLnVwZGF0ZVNjZW5lKHt3aWR0aDpzLGhlaWdodDpsfSksdGhpcy5mdWxsTGF5ZXImJih0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNjYWxlIixbdCx0XSksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstciwtbl0pKSx0aGlzLmRyYXdMYXllciYmKHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFt0LHRdKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1yLC1uXSkpfWdldE9mZnNjcmVlbihlKXtyZXR1cm4oZT90aGlzLmZ1bGxMYXllci5wYXJlbnQ6dGhpcy5kcmF3TGF5ZXIucGFyZW50KS5jYW52YXN9Y29uc3VtZUZ1bGwoZSx0KXtlPT09UHQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVGdWxsKHQpO2NvbnN0IHI9dGhpcy5sb2NhbFdvcmsuY29sbG9jdEVmZmVjdFNlbGVjdFdvcmsodCk7ciYmZT09PVB0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZUZ1bGwocil9Y29uc3VtZURyYXcoZSx0KXtlPT09UHQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3KHQsdGhpcy5zZXJ2aWNlV29yayksZT09PVB0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZURyYXcodCl9Y29uc3VtZURyYXdBbGwoZSx0KXtlPT09UHQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3QWxsKHQsdGhpcy5zZXJ2aWNlV29yayl9dXBkYXRlQ2FtZXJhKGUpe2NvbnN0IHQ9W10se2NhbWVyYU9wdDpyfT1lO3ImJih0aGlzLnNldENhbWVyYU9wdChyKSx0aGlzLmxvY2FsV29yay53b3JrU2hhcGVzLmZvckVhY2goKG4scyk9Pnsobi50b29sc1R5cGU9PT12dC5QZW5jaWx8fG4udG9vbHNUeXBlPT09dnQuQXJyb3d8fG4udG9vbHNUeXBlPT09dnQuU3RyYWlnaHR8fG4udG9vbHNUeXBlPT09dnQuRWxsaXBzZXx8bi50b29sc1R5cGU9PT12dC5SZWN0YW5nbGV8fG4udG9vbHNUeXBlPT09dnQuU3Rhcnx8bi50b29sc1R5cGU9PT12dC5Qb2x5Z29ufHxuLnRvb2xzVHlwZT09PXZ0LlNwZWVjaEJhbGxvb258fG4udG9vbHNUeXBlPT09dnQuVGV4dCkmJnRoaXMubG9jYWxXb3JrLndvcmtTaGFwZVN0YXRlLnNldChzLHt3aWxsQ2xlYXI6ITB9KX0pLHRoaXMubG9jYWxXb3JrLnJ1bkVmZmVjdFdvcmsoKCk9PntpZih0aGlzLnNlcnZpY2VXb3JrLnNlbGVjdG9yV29ya1NoYXBlcy5zaXplKWZvcihjb25zdFtuLHNdb2YgdGhpcy5zZXJ2aWNlV29yay5zZWxlY3RvcldvcmtTaGFwZXMuZW50cmllcygpKXRoaXMuc2VydmljZVdvcmsucnVuU2VsZWN0V29yayh7d29ya0lkOm4sc2VsZWN0SWRzOnMuc2VsZWN0SWRzLG1zZ1R5cGU6dXQuU2VsZWN0LGRhdGFUeXBlOlB0LlNlcnZpY2Usdmlld0lkOnRoaXMudmlld0lkfSk7aWYodGhpcy52Tm9kZXMuaGFzUmVuZGVyTm9kZXMoKSl7bGV0IG47dC5wdXNoKHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnh0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSx7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp4dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2Zvcihjb25zdCBzIG9mIHRoaXMudk5vZGVzLmN1ck5vZGVNYXAudmFsdWVzKCkpY24ocy50b29sc1R5cGUpJiYobj1idChuLHMucmVjdCkpO24mJnQucHVzaCh7cmVjdDpmaChuLDEwMCksZHJhd0NhbnZhczp4dC5CZyxpc0NsZWFyOiExLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSl9dC5sZW5ndGgmJnRoaXMucG9zdCh7cmVuZGVyOnR9KX0pKX1nZXRSZWN0SW1hZ2VCaXRtYXAoZSx0KXtjb25zdCByPWUueCp0aGlzLmRwcixuPWUueSp0aGlzLmRwcixzPWUudyp0aGlzLmRwcixsPWUuaCp0aGlzLmRwcjtyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAodGhpcy5nZXRPZmZzY3JlZW4odCkscixuLHMsbCl9c2FmYXJpRml4UmVjdChlKXtpZihlLncrZS54PD0wfHxlLmgrZS55PD0wfHxlLnc8PTB8fGUuaDw9MClyZXR1cm47Y29uc3QgdD17eDowLHk6MCx3OnRoaXMuc2NlbmUud2lkdGgsaDp0aGlzLnNjZW5lLmhlaWdodH07aWYoZS54PDA/ZS53K2UueDx0aGlzLnNjZW5lLndpZHRoJiYodC53PWUudytlLngpOmUudytlLng+MCYmKHQueD1lLngsdC53PXRoaXMuc2NlbmUud2lkdGgtZS54KSxlLnk8MD9lLmgrZS55PHRoaXMuc2NlbmUuaGVpZ2h0JiYodC5oPWUuaCtlLnkpOmUuaCtlLnk+MCYmKHQueT1lLnksdC5oPXRoaXMuc2NlbmUuaGVpZ2h0LWUueSksISh0Lnc8PTB8fHQuaDw9MCkpcmV0dXJuIHR9Z2V0U2NlbmVSZWN0KCl7Y29uc3R7d2lkdGg6ZSxoZWlnaHQ6dH09dGhpcy5zY2VuZTtyZXR1cm57eDowLHk6MCx3OmUsaDp0fX1jaGVja1JpZ2h0UmVjdEJvdW5kaW5nQm94KGUpe3JldHVybiB0aGlzLnZOb2Rlcy5jb21iaW5lSW50ZXJzZWN0UmVjdChlKX19Y2xhc3Mgd2QgZXh0ZW5kcyBTbntjb25zdHJ1Y3RvcihlLHQscil7c3VwZXIoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3Bvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNuYXBzaG90RnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlcnZpY2VXb3JrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuX3Bvc3Q9cjtjb25zdCBuPXt2aWV3SWQ6dGhpcy52aWV3SWQsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXIscG9zdDp0aGlzLnBvc3QuYmluZCh0aGlzKX07dGhpcy5sb2NhbFdvcms9bmV3IElkKG4pLHRoaXMudk5vZGVzLmluaXQodGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpfWFzeW5jIHBvc3QoZSx0KXt2YXIgYyxvO2NvbnN0IHI9ZS5yZW5kZXIsbj1bXTtsZXQgcz10O2lmKHIhPW51bGwmJnIubGVuZ3RoKXtmb3IoY29uc3QgZiBvZiByKWlmKGYuZHJhd0NhbnZhcyYmdGhpcy5mdWxsTGF5ZXIucGFyZW50LnJlbmRlcigpLGYucmVjdCl7aWYoZi5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChZdChmLnJlY3QpKSwhZi5yZWN0KWNvbnRpbnVlO2lmKGYuZHJhd0NhbnZhcyl7Y29uc3QgeD1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcChmLnJlY3QsISFmLmlzRnVsbFdvcmspO2YuaW1hZ2VCaXRtYXA9eCxzfHwocz1bXSkscy5wdXNoKHgpfW4ucHVzaChmKX1lLnJlbmRlcj1ufWNvbnN0IGw9KGM9ZS5zcCk9PW51bGw/dm9pZCAwOmMuZmlsdGVyKGY9PmYudHlwZSE9PXV0Lk5vbmV8fE9iamVjdC5rZXlzKGYpLmZpbHRlcih4PT54PT09InR5cGUiKS5sZW5ndGgpO2lmKGwhPW51bGwmJmwubGVuZ3RoJiYoZS5zcD1sLm1hcChmPT4oey4uLmYsdmlld0lkOnRoaXMudmlld0lkfSkpKSwoKG89ZS5zcCkhPW51bGwmJm8ubGVuZ3RofHxlLmRyYXdDb3VudHx8biE9bnVsbCYmbi5sZW5ndGgpJiYodGhpcy5fcG9zdChlLHMpLHMhPW51bGwmJnMubGVuZ3RoKSlmb3IoY29uc3QgZiBvZiBzKWYgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCYmZi5jbG9zZSgpfW9uKGUpe2NvbnN0e21zZ1R5cGU6dH09ZTtzd2l0Y2godCl7Y2FzZSB1dC5VcGRhdGVDYW1lcmE6dGhpcy51cGRhdGVDYW1lcmEoZSk7YnJlYWs7Y2FzZSB1dC5TbmFwc2hvdDp0aGlzLnNuYXBzaG90RnVsbExheWVyPXRoaXMuY3JlYXRlTGF5ZXIoInNuYXBzaG90RnVsbExheWVyIix0aGlzLnNjZW5lLHsuLi50aGlzLm9wdC5sYXllck9wdCxidWZmZXJTaXplOnRoaXMudmlld0lkPT09Im1haW5WaWV3Ij82ZTM6M2UzfSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllciYmdGhpcy5nZXRTbmFwc2hvdChlKS50aGVuKCgpPT57dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj12b2lkIDB9KTticmVhaztjYXNlIHV0LkJvdW5kaW5nQm94OnRoaXMuc25hcHNob3RGdWxsTGF5ZXI9dGhpcy5jcmVhdGVMYXllcigic25hcHNob3RGdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnRoaXMub3B0LmxheWVyT3B0LGJ1ZmZlclNpemU6dGhpcy52aWV3SWQ9PT0ibWFpblZpZXciPzZlMzozZTN9KSx0aGlzLnNuYXBzaG90RnVsbExheWVyJiZ0aGlzLmdldEJvdW5kaW5nUmVjdChlKS50aGVuKCgpPT57dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj12b2lkIDB9KTticmVha31zdXBlci5vbihlKX1nZXRPZmZzY3JlZW4oZSl7dmFyIHQ7cmV0dXJuKHQ9KGUmJnRoaXMuc25hcHNob3RGdWxsTGF5ZXJ8fHRoaXMuZnVsbExheWVyKS5wYXJlbnQpPT1udWxsP3ZvaWQgMDp0LmNhbnZhc31jb25zdW1lRHJhdyhlLHQpe2U9PT1QdC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXcodCl9Y29uc3VtZURyYXdBbGwoZSx0KXt0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhd0FsbCh0KX1nZXRSZWN0SW1hZ2VCaXRtYXAoZSx0PSExLHIpe2NvbnN0IG49ZS54KnRoaXMuZHByLHM9ZS55KnRoaXMuZHByLGw9ZS53KnRoaXMuZHByLGM9ZS5oKnRoaXMuZHByO3JldHVybiBjcmVhdGVJbWFnZUJpdG1hcCh0aGlzLmdldE9mZnNjcmVlbih0KSxuLHMsbCxjLHIpfXNhZmFyaUZpeFJlY3QoZSl7aWYoZS53K2UueDw9MHx8ZS5oK2UueTw9MHx8ZS53PD0wfHxlLmg8PTApcmV0dXJuO2NvbnN0IHQ9e3g6MCx5OjAsdzp0aGlzLnNjZW5lLndpZHRoLGg6dGhpcy5zY2VuZS5oZWlnaHR9O2lmKGUueDwwP2UudytlLng8dGhpcy5zY2VuZS53aWR0aCYmKHQudz1lLncrZS54KTplLncrZS54PjAmJih0Lng9ZS54LHQudz10aGlzLnNjZW5lLndpZHRoLWUueCksZS55PDA/ZS5oK2UueTx0aGlzLnNjZW5lLmhlaWdodCYmKHQuaD1lLmgrZS55KTplLmgrZS55PjAmJih0Lnk9ZS55LHQuaD10aGlzLnNjZW5lLmhlaWdodC1lLnkpLCEodC53PD0wfHx0Lmg8PTApKXJldHVybiB0fXVwZGF0ZUNhbWVyYShlKXtjb25zdHtjYW1lcmFPcHQ6dH09ZTt0JiZ0aGlzLnNldENhbWVyYU9wdCh0KX1zZXRDYW1lcmFPcHQoZSx0KXt0aGlzLmNhbWVyYU9wdD1lO2NvbnN0e3NjYWxlOnIsY2VudGVyWDpuLGNlbnRlclk6cyx3aWR0aDpsLGhlaWdodDpjfT1lOyhsIT09dGhpcy5zY2VuZS53aWR0aHx8YyE9PXRoaXMuc2NlbmUuaGVpZ2h0KSYmdGhpcy51cGRhdGVTY2VuZSh7d2lkdGg6bCxoZWlnaHQ6Y30pLHQ/KHQuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3Iscl0pLHQuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstbiwtc10pKToodGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3Iscl0pLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLW4sLXNdKSl9YXN5bmMgZ2V0U25hcHNob3QoZSl7Y29uc3R7c2NlbmVQYXRoOnQsc2NlbmVzOnIsY2FtZXJhT3B0Om4sdzpzLGg6bH09ZTtpZih0JiZyJiZuJiZ0aGlzLnNuYXBzaG90RnVsbExheWVyKXtjb25zdCBjPVl0KHRoaXMuY2FtZXJhT3B0KTt0aGlzLnNldENhbWVyYU9wdChuLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIpLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLnNuYXBzaG90RnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj10aGlzLmZ1bGxMYXllcjtsZXQgbztjb25zdCBmPW5ldyBNYXA7Zm9yKGNvbnN0W2cseV1vZiBPYmplY3QuZW50cmllcyhyKSlpZih5IT1udWxsJiZ5LnR5cGUpc3dpdGNoKHk9PW51bGw/dm9pZCAwOnkudHlwZSl7Y2FzZSB1dC5VcGRhdGVOb2RlOmNhc2UgdXQuRnVsbFdvcms6e2NvbnN0e3Rvb2xzVHlwZTptLG9wdDpUfT15O209PT12dC5UZXh0JiZUJiYoVC5saW5lVGhyb3VnaHx8VC51bmRlcmxpbmUpJiZmLnNldChnLHkpO2NvbnN0IE89dGhpcy5sb2NhbFdvcmsucnVuRnVsbFdvcmsoey4uLnksd29ya0lkOmcsbXNnVHlwZTp1dC5GdWxsV29yayxkYXRhVHlwZTpQdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0sbT09PXZ0LlRleHQpO289YnQobyxPKTticmVha319dGhpcy5sb2NhbFdvcmsuZnVsbExheWVyPXRoaXMuZnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj12b2lkIDA7bGV0IHg7cyYmbCYmKHg9e3Jlc2l6ZVdpZHRoOnMscmVzaXplSGVpZ2h0Omx9KSxhd2FpdCBuZXcgUHJvbWlzZShnPT57c2V0VGltZW91dChnLDUwMCl9KSx0aGlzLndpbGxSZW5kZXJTcGVjaWFsTGFiZWwoZiksYXdhaXQgdGhpcy5nZXRTbmFwc2hvdFJlbmRlcih7c2NlbmVQYXRoOnQsY3VyQ2FtZXJhT3B0OmMsb3B0aW9uczp4LHdpbGxSZW5kZXJNYXA6Zn0pfX13aWxsUmVuZGVyU3BlY2lhbExhYmVsKGUpe3ZhciB0O2Zvcihjb25zdFtyLG5db2YgZS5lbnRyaWVzKCkpe2NvbnN0IHM9KHQ9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcik9PW51bGw/dm9pZCAwOnQuZ2V0RWxlbWVudHNCeU5hbWUocilbMF07cyYmbi5vcHQmJnRoaXMubG9jYWxXb3JrLnVwZGF0ZUxhYmVscyhzLG4pfX1hc3luYyBnZXRTbmFwc2hvdFJlbmRlcihlKXt2YXIgbCxjO2NvbnN0e3NjZW5lUGF0aDp0LGN1ckNhbWVyYU9wdDpyLG9wdGlvbnM6bn09ZTsoKGw9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcik9PW51bGw/dm9pZCAwOmwucGFyZW50KS5yZW5kZXIoKTtjb25zdCBzPWF3YWl0IHRoaXMuZ2V0UmVjdEltYWdlQml0bWFwKHt4OjAseTowLHc6dGhpcy5zY2VuZS53aWR0aCxoOnRoaXMuc2NlbmUuaGVpZ2h0fSwhMCxuKTtzJiYoYXdhaXQgdGhpcy5wb3N0KHtzcDpbe3R5cGU6dXQuU25hcHNob3Qsc2NlbmVQYXRoOnQsaW1hZ2VCaXRtYXA6c31dfSxbc10pLHMuY2xvc2UoKSwoYz10aGlzLnNuYXBzaG90RnVsbExheWVyKT09bnVsbHx8Yy5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuc2V0Q2FtZXJhT3B0KHIsdGhpcy5mdWxsTGF5ZXIpKX1hc3luYyBnZXRCb3VuZGluZ1JlY3QoZSl7Y29uc3R7c2NlbmVQYXRoOnQsc2NlbmVzOnIsY2FtZXJhT3B0Om59PWU7aWYodCYmciYmbiYmdGhpcy5zbmFwc2hvdEZ1bGxMYXllcil7Y29uc3Qgcz1ZdCh0aGlzLmNhbWVyYU9wdCk7dGhpcy5zZXRDYW1lcmFPcHQobix0aGlzLnNuYXBzaG90RnVsbExheWVyKSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dGhpcy5kcmF3TGF5ZXI7bGV0IGw7Zm9yKGNvbnN0W2Msb11vZiBPYmplY3QuZW50cmllcyhyKSlpZihvIT1udWxsJiZvLnR5cGUpc3dpdGNoKG89PW51bGw/dm9pZCAwOm8udHlwZSl7Y2FzZSB1dC5VcGRhdGVOb2RlOmNhc2UgdXQuRnVsbFdvcms6e2NvbnN0IGY9dGhpcy5sb2NhbFdvcmsucnVuRnVsbFdvcmsoey4uLm8sd29ya0lkOmMsbXNnVHlwZTp1dC5GdWxsV29yayxkYXRhVHlwZTpQdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2w9YnQobCxmKTticmVha319bCYmYXdhaXQgdGhpcy5wb3N0KHtzcDpbe3R5cGU6dXQuQm91bmRpbmdCb3gsc2NlbmVQYXRoOnQscmVjdDpsfV19KSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5mdWxsTGF5ZXIsdGhpcy5sb2NhbFdvcmsuZHJhd0xheWVyPXZvaWQgMCx0aGlzLnNuYXBzaG90RnVsbExheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5zZXRDYW1lcmFPcHQocyx0aGlzLmZ1bGxMYXllcil9fX1jb25zdCBOZD1zZWxmO25ldyBMZChOZCxQZS5TdWIpfSkoKTsK", Ks = typeof window < "u" && window.Blob && new Blob([atob(ut)], { type: "text/javascript;charset=utf-8" });
function Yo(b) {
  let d;
  try {
    if (d = Ks && (window.URL || window.webkitURL).createObjectURL(Ks), !d)
      throw "";
    const l = new Worker(d, {
      name: b == null ? void 0 : b.name
    });
    return l.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(d);
    }), l;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + ut,
      {
        name: b == null ? void 0 : b.name
      }
    );
  } finally {
    d && (window.URL || window.webkitURL).revokeObjectURL(d);
  }
}
class od {
  constructor() {
    Object.defineProperty(this, "emtType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  static dispatch(d, l, i) {
    var s;
    (s = td.InternalMsgEmitter) == null || s.emit([d, l], i);
  }
  get serviceColloctor() {
    return this.control.collector;
  }
  registerForMainEngine(d, l) {
    return this.emtType = d, this.control = l, this.mainEngine = l.worker, this.mainEngine.internalMsgEmitter.on([this.emtType, this.emitEventType], this.collect.bind(this)), this;
  }
  destroy() {
    this.emtType && this.mainEngine && this.mainEngine.internalMsgEmitter.off([this.emtType, this.emitEventType], this.collect.bind(this));
  }
  collectForLocalWorker(d) {
    var l, i;
    for (const s of d)
      (l = this.mainEngine) == null || l.taskBatchData.add(s);
    (i = this.mainEngine) == null || i.runAnimation();
  }
  collectForServiceWorker(d) {
    Hd(() => {
      d.forEach((l) => {
        var c, m, n;
        (c = this.serviceColloctor) == null || c.dispatch(l);
        const { viewId: i, undoTickerId: s } = l;
        s && i && ((n = (m = this.mainEngine) == null ? void 0 : m.internalMsgEmitter) == null || n.emit("undoTickerEnd", s, i));
      });
    }, this.mainEngine.maxLastSyncTime);
  }
}
class xo extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.ZIndexActive
    });
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workId: l, isActive: i, viewId: s } = d, c = this.control.viewContainerManager.getView(s);
    if (!(c != null && c.displayer))
      return;
    const m = [], n = [];
    l === Il && m.push({
      workId: l,
      msgType: yl.UpdateNode,
      dataType: Jl.Local,
      isActiveZIndex: i,
      emitEventType: this.emitEventType,
      willRefreshSelector: !0,
      willSyncService: !1,
      viewId: s
    }), m.length && this.collectForLocalWorker(m), n.length && this.collectForServiceWorker(n);
  }
}
class ro extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.CopyNode
    });
  }
  collect(d) {
    var p, r, V, W, y, t;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, viewId: i } = d, s = this.control.viewContainerManager.getView(i);
    if (!(s != null && s.displayer))
      return;
    const c = s.focusScenePath, m = [...l], n = (p = this.serviceColloctor) == null ? void 0 : p.storage, X = [], G = [], L = Math.floor(Math.random() * 30 + 1);
    let o = [L, L];
    const h = Date.now();
    for (; m.length; ) {
      const e = m.pop();
      if (!e)
        continue;
      const Z = e.toString(), a = this.serviceColloctor.isLocalId(Z), x = a ? this.serviceColloctor.transformKey(e) : Z;
      let K = Z;
      !a && this.serviceColloctor.isOwn(K) && (K = this.serviceColloctor.getLocalId(K));
      const C = Al(n[i][c][x]);
      if (C && K === Il) {
        if (C.selectIds) {
          const T = (r = s.displayer.canvasBgRef.current) == null ? void 0 : r.getBoundingClientRect(), I = (W = (V = s.displayer) == null ? void 0 : V.floatBarCanvasRef.current) == null ? void 0 : W.getBoundingClientRect(), J = T && [T.x + T.width / 2, T.y + T.height / 2], F = I && [I.x + I.width / 2, I.y + I.height / 2], R = ((y = s.cameraOpt) == null ? void 0 : y.scale) || 1;
          o = J && F && [(J[0] - F[0] + L) / R, (J[1] - F[1] + L) / R] || [L / R, L / R], m.push(...C.selectIds);
        }
        continue;
      }
      if (C && C.toolsType === Gl.Text && C.opt && C.opt.workState && C.opt.workState !== ul.Done) {
        const T = s.cameraOpt, I = T && [T.centerX, T.centerY], J = C.opt, F = J.boxPoint && J.boxSize && [J.boxPoint[0] + J.boxSize[0] / 2, J.boxPoint[1] + J.boxSize[1] / 2], R = (T == null ? void 0 : T.scale) || 1;
        o = I && F && [I[0] - F[0] + L, I[1] - F[1] + L] || [L / R, L / R];
      }
      if (C) {
        const T = Date.now(), I = (a ? e : this.serviceColloctor.getLocalId(e.toString())) + "-" + T, J = { useAnimation: !1 };
        if (C.toolsType === Gl.Text && C.opt) {
          const F = C.opt;
          if (F && F.boxPoint && F.text) {
            F.workState = ul.Done;
            const R = F.boxPoint;
            F.boxPoint = [R[0] + o[0], R[1] + o[1]], F.workState = ul.Done;
            const S = this.control.viewContainerManager.transformToOriginPoint(F.boxPoint, i);
            this.control.textEditorManager.createTextForMasterController({
              workId: Date.now().toString(),
              x: S[0],
              y: S[1],
              opt: F,
              scale: ((t = s.cameraOpt) == null ? void 0 : t.scale) || 1,
              type: ed.Text,
              isActive: !1,
              viewId: i,
              scenePath: c
            });
          }
          continue;
        }
        if (C.ops) {
          const F = Rt(C.ops).map((S, N) => {
            const Q = N % 3;
            return Q === 0 ? S + o[0] : Q === 1 ? S + o[1] : S;
          }), R = St(F);
          C.ops = R, G.push({
            ...C,
            updateNodeOpt: J,
            type: yl.FullWork,
            workId: I,
            undoTickerId: h,
            viewId: i,
            scenePath: c
          }), X.push({
            ...C,
            updateNodeOpt: J,
            workId: I,
            msgType: yl.FullWork,
            dataType: Jl.Local,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0,
            viewId: i
          });
        }
      }
    }
    this.mainEngine.internalMsgEmitter.emit("undoTickerStart", h, i), X.length && this.collectForLocalWorker(X), G.length && this.collectForServiceWorker(G);
  }
}
function ei(b, d, l) {
  return "#" + ((b << 16) + (d << 8) + l).toString(16).padStart(6, "0");
}
function ql(b, d = 1) {
  return "rgba(" + parseInt("0x" + b.slice(1, 3)) + "," + parseInt("0x" + b.slice(3, 5)) + "," + parseInt("0x" + b.slice(5, 7)) + "," + d + ")";
}
function Od(b, d, l, i = 1) {
  return `rgba(${b},${d},${l},${i})`;
}
function zi(b) {
  const d = b.split(","), l = parseInt(d[0].split("(")[1]), i = parseInt(d[1]), s = parseInt(d[2]), c = Number(d[3].split(")")[0]);
  return [ei(l, i, s), c];
}
function Cs(b) {
  const d = b.split(","), l = parseInt(d[0].split("(")[1]), i = parseInt(d[1]), s = parseInt(d[2]), c = Number(d[3].split(")")[0]);
  return [l, i, s, c];
}
class Ro extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.SetColorNode
    });
  }
  setTextColor(d, l, i, s) {
    const { fontColor: c, fontBgColor: m } = i;
    l.opt && (c && (l.opt.fontColor = c), m && (l.opt.fontColor = m), this.control.textEditorManager.updateTextForMasterController({
      workId: d,
      opt: l.opt,
      viewId: s
    }));
  }
  collect(d) {
    var r, V;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, strokeColor: i, fillColor: s, fontColor: c, fontBgColor: m, viewId: n } = d, X = this.control.viewContainerManager.getView(n);
    if (!(X != null && X.displayer))
      return;
    const G = X.focusScenePath, L = [...l], o = this.serviceColloctor.storage, h = [], p = Date.now();
    for (; L.length; ) {
      const W = L.pop();
      if (!W)
        continue;
      const y = W.toString(), t = this.serviceColloctor.isLocalId(y), e = t ? this.serviceColloctor.transformKey(W) : y;
      let Z = y;
      !t && this.serviceColloctor.isOwn(Z) && (Z = this.serviceColloctor.getLocalId(Z));
      const a = o[n][G][e] || void 0;
      if (a) {
        const x = a.updateNodeOpt || {};
        if (c || m) {
          if (c) {
            x.fontColor = c;
            const [C, T, I, J] = Cs(c);
            (r = this.control.room) == null || r.setMemberState({ textColor: [C, T, I], textOpacity: J });
          }
          if (m) {
            x.fontBgColor = m;
            const [C, T, I, J] = Cs(m);
            (V = this.control.room) == null || V.setMemberState({ textBgColor: [C, T, I], textOpacity: J });
          }
          if (a.toolsType === Gl.Text && a.opt) {
            this.setTextColor(Z, Al(a), x, n);
            continue;
          }
        }
        i && (x.strokeColor = i), s && (x.fillColor = s);
        const K = {
          workId: Z,
          msgType: yl.UpdateNode,
          dataType: Jl.Local,
          updateNodeOpt: x,
          emitEventType: this.emitEventType,
          willRefresh: !0,
          willRefreshSelector: !0,
          willSyncService: !0,
          textUpdateForWoker: !0,
          undoTickerId: p,
          viewId: n
        };
        h.push(K);
      }
    }
    this.mainEngine.internalMsgEmitter.emit("undoTickerStart", p, n), h.length && this.collectForLocalWorker(h);
  }
}
class So extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.ZIndexNode
    }), Object.defineProperty(this, "min", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "max", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  get minZIndex() {
    return this.min;
  }
  get maxZIndex() {
    return this.max;
  }
  set maxZIndex(d) {
    this.max = d;
  }
  set minZIndex(d) {
    this.min = d;
  }
  addMaxLayer() {
    this.max = this.max + 1;
  }
  addMinLayer() {
    this.min = this.min - 1;
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, layer: i, viewId: s } = d, c = this.control.viewContainerManager.getView(s);
    if (!(c != null && c.displayer))
      return;
    const m = c.focusScenePath, n = [...l], X = this.serviceColloctor.storage, G = [], L = [];
    for (; n.length; ) {
      const h = n.pop();
      if (!h)
        continue;
      const p = h.toString(), r = this.serviceColloctor.isLocalId(p), V = r ? this.serviceColloctor.transformKey(h) : p;
      let W = p;
      !r && this.serviceColloctor.isOwn(W) && (W = this.serviceColloctor.getLocalId(W));
      const y = Al(X[s][m][V]);
      let t;
      if (y && W === Il) {
        if (y.selectIds) {
          L.push(...y.selectIds), L.sort((x, K) => {
            var I, J, F, R;
            const C = ((J = (I = X[o(x, this.serviceColloctor)]) == null ? void 0 : I.opt) == null ? void 0 : J.zIndex) || 0, T = ((R = (F = X[o(x, this.serviceColloctor)]) == null ? void 0 : F.opt) == null ? void 0 : R.zIndex) || 0;
            return C > T ? 1 : x < K ? -1 : 0;
          });
          const e = y.updateNodeOpt || {};
          e.zIndexLayer = i;
          const Z = {
            workId: h,
            msgType: yl.UpdateNode,
            dataType: Jl.Local,
            updateNodeOpt: e,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0,
            viewId: s
          }, a = /* @__PURE__ */ new Map();
          i === Rd.Top ? (this.addMaxLayer(), t = this.max) : (this.addMinLayer(), t = this.min), L.forEach((x) => {
            var I, J, F;
            const K = (I = this.serviceColloctor) == null ? void 0 : I.isLocalId(x);
            let C = K && ((J = this.serviceColloctor) == null ? void 0 : J.transformKey(x)) || x;
            const T = X[s][m][C];
            !K && ((F = this.serviceColloctor) != null && F.isOwn(C)) && (C = this.serviceColloctor.getLocalId(C)), e.zIndex = t, T != null && T.opt && (T.opt.zIndex = t), T != null && T.opt && a.set(C, {
              updateNodeOpt: T.updateNodeOpt,
              opt: T.opt
            });
          }), Z.selectStore = a, Z.willSerializeData = !0, G.push(Z);
        }
        continue;
      }
    }
    G.length && this.collectForLocalWorker(G);
    function o(h, p) {
      return p.isLocalId(h) && p.transformKey(h) || h;
    }
  }
}
class Ko extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.TranslateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(d) {
    var V, W, y, t;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, position: i, workState: s, viewId: c } = d, m = this.control.viewContainerManager.getView(c);
    if (!(m != null && m.displayer))
      return;
    const n = m.focusScenePath, X = [...l], G = (V = this.serviceColloctor) == null ? void 0 : V.storage, L = [], o = (W = m.displayer.canvasBgRef.current) == null ? void 0 : W.getBoundingClientRect(), h = (t = (y = m.displayer) == null ? void 0 : y.floatBarCanvasRef.current) == null ? void 0 : t.getBoundingClientRect();
    let p = !1;
    const r = s === ul.Start && Date.now() || void 0;
    for (r && (this.undoTickerId = r, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", r, c)), o && h && this.oldRect && (this.oldRect.x < o.x && h.x > this.oldRect.x || this.oldRect.y < o.y && h.y > this.oldRect.y || this.oldRect.x + this.oldRect.width > o.x + o.width && h.x < this.oldRect.x || this.oldRect.y + this.oldRect.height > o.y + o.height && h.y < this.oldRect.y) && (p = !0), h && (this.oldRect = h); X.length; ) {
      const e = X.pop();
      if (!e)
        continue;
      const Z = e.toString(), a = this.serviceColloctor.isLocalId(Z), x = a && this.serviceColloctor.transformKey(e) || Z;
      let K = Z;
      !a && this.serviceColloctor.isOwn(K) && (K = this.serviceColloctor.getLocalId(K));
      const C = G[c][n][x];
      if (C && K === Il) {
        if (C.selectIds && (s === ul.Start && (this.cachePosition = i), this.cachePosition)) {
          const T = C.updateNodeOpt || {};
          T.translate = [i.x - this.cachePosition.x, i.y - this.cachePosition.y], T.workState = s;
          const I = {
            workId: e,
            msgType: yl.UpdateNode,
            dataType: Jl.Local,
            updateNodeOpt: T,
            emitEventType: this.emitEventType,
            willRefreshSelector: p,
            willSyncService: !0,
            textUpdateForWoker: !1,
            viewId: c
          };
          s === ul.Done && (I.willRefreshSelector = !0, I.textUpdateForWoker = !0, I.willSerializeData = !0, I.undoTickerId = this.undoTickerId, this.cachePosition = void 0), L.push(I);
        }
        continue;
      }
    }
    L.length && this.collectForLocalWorker(L);
  }
}
class Co extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.DeleteNode
    });
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, viewId: i } = d, s = this.control.viewContainerManager.getView(i);
    if (!(s != null && s.displayer))
      return;
    const c = s.focusScenePath, m = this.serviceColloctor.storage, n = [...l], X = [], G = [], L = Date.now();
    for (; n.length; ) {
      const o = n.pop();
      if (!o)
        continue;
      const h = o.toString(), p = this.serviceColloctor.isLocalId(h), r = p ? this.serviceColloctor.transformKey(o) : h, V = m[i][c][r];
      if (V) {
        let W = h;
        if (!p && this.serviceColloctor.isOwn(W) && (W = this.serviceColloctor.getLocalId(W)), V.toolsType === Gl.Text) {
          this.control.textEditorManager.delete(W, !0, !0);
          continue;
        }
        G.push(W);
      }
    }
    X.push({
      msgType: yl.RemoveNode,
      emitEventType: hl.DeleteNode,
      removeIds: G,
      dataType: Jl.Local,
      willSyncService: !0,
      willRefresh: !0,
      undoTickerId: L,
      viewId: i
    }), this.mainEngine.internalMsgEmitter.emit("undoTickerStart", L, i), X.length && this.collectForLocalWorker(X);
  }
}
class Jo extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.ScaleNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(d) {
    var p;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, box: i, workState: s, viewId: c } = d, m = this.control.viewContainerManager.getView(c);
    if (!(m != null && m.displayer))
      return;
    const n = m.focusScenePath, X = [...l], G = (p = this.serviceColloctor) == null ? void 0 : p.storage, L = [], o = [], h = s === ul.Start && Date.now() || void 0;
    for (h && (this.undoTickerId = h, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", h, c)); X.length; ) {
      const r = X.pop();
      if (!r)
        continue;
      const V = r.toString(), W = this.serviceColloctor.isLocalId(V), y = W && this.serviceColloctor.transformKey(r) || V;
      let t = V;
      !W && this.serviceColloctor.isOwn(t) && (t = this.serviceColloctor.getLocalId(t));
      const e = G[c][n][y];
      if (e && t === Il && e.selectIds) {
        o.push(...e.selectIds);
        const Z = e.updateNodeOpt || {};
        Z.box = i, Z.workState = s;
        const a = {
          workId: r,
          msgType: yl.UpdateNode,
          dataType: Jl.Local,
          updateNodeOpt: Z,
          emitEventType: this.emitEventType,
          willRefreshSelector: !0,
          willSyncService: !0,
          textUpdateForWoker: !0,
          viewId: c
        };
        s === ul.Done && (a.willSerializeData = !0, a.undoTickerId = this.undoTickerId), L.push(a);
        continue;
      }
    }
    L.length && this.collectForLocalWorker(L);
  }
}
class To extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.RotateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cacheOriginRotate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  collect(d) {
    var h, p, r, V, W;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, angle: i, workState: s, viewId: c } = d, m = this.control.viewContainerManager.getView(c);
    if (!(m != null && m.displayer))
      return;
    const n = m.focusScenePath, X = [...l], G = (h = this.serviceColloctor) == null ? void 0 : h.storage, L = [], o = s === ul.Start && Date.now() || void 0;
    for (o && (this.undoTickerId = o, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", o, c)); X.length; ) {
      const y = X.pop();
      if (!y)
        continue;
      const t = y.toString(), e = this.serviceColloctor.isLocalId(t), Z = e && this.serviceColloctor.transformKey(y) || t;
      let a = t;
      !e && this.serviceColloctor.isOwn(a) && (a = this.serviceColloctor.getLocalId(a));
      const x = G[c][n][Z];
      if (x && a === Il) {
        if (((p = x.selectIds) == null ? void 0 : p.length) === 1) {
          const K = x.selectIds[0];
          if (s === ul.Start) {
            const J = ((r = this.serviceColloctor) == null ? void 0 : r.isLocalId(K)) && ((V = this.serviceColloctor) == null ? void 0 : V.transformKey(K)) || K, F = G[c][n][J];
            this.cacheOriginRotate = ((W = F == null ? void 0 : F.opt) == null ? void 0 : W.rotate) || 0;
          }
          const C = x.updateNodeOpt || {};
          C.angle = (i + this.cacheOriginRotate) % 360, C.workState = s;
          const T = {
            workId: y,
            msgType: yl.UpdateNode,
            dataType: Jl.Local,
            updateNodeOpt: C,
            emitEventType: this.emitEventType,
            willRefreshSelector: !1,
            willSyncService: !0,
            viewId: c
          };
          s === ul.Done && (T.willRefreshSelector = !0, T.willSerializeData = !0, T.undoTickerId = this.undoTickerId, this.cacheOriginRotate = 0), L.push(T);
        }
        continue;
      }
    }
    L.length && this.collectForLocalWorker(L);
  }
}
function Fo(b) {
  switch (b) {
    case Gl.Text:
      return ed.Text;
    case Gl.SpeechBalloon:
    case Gl.Star:
    case Gl.Ellipse:
    case Gl.Rectangle:
    case Gl.Triangle:
    case Gl.Rhombus:
    case Gl.Polygon:
      return ed.Shape;
  }
}
class No extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.SetFontStyle
    });
  }
  setTextStyle(d, l, i, s) {
    const { bold: c, underline: m, lineThrough: n, italic: X, fontSize: G } = i;
    if (l.toolsType) {
      const L = Fo(l.toolsType);
      L === ed.Text && (l.opt && (c && (l.opt.bold = c), Fd(m) && (l.opt.underline = m), Fd(n) && (l.opt.lineThrough = n), X && (l.opt.italic = X), G && (l.opt.fontSize = G)), this.control.textEditorManager.updateTextForMasterController({
        workId: d,
        opt: l.opt,
        viewId: s
      })), ed.Shape;
    }
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, bold: i, italic: s, lineThrough: c, underline: m, viewId: n, fontSize: X } = d, G = this.control.viewContainerManager.getView(n);
    if (!(G != null && G.displayer))
      return;
    const L = G.focusScenePath, o = [...l], h = this.serviceColloctor.storage, p = [], r = Date.now();
    for (; o.length; ) {
      const V = o.pop();
      if (!V)
        continue;
      const W = V.toString(), y = this.serviceColloctor.isLocalId(W), t = y ? this.serviceColloctor.transformKey(V) : W;
      let e = W;
      !y && this.serviceColloctor.isOwn(e) && (e = this.serviceColloctor.getLocalId(e));
      const Z = h[n][L][t] || void 0;
      if (Z) {
        const a = Z.updateNodeOpt || {};
        if (i && (a.bold = i), s && (a.italic = s), Fd(c) && (a.lineThrough = c), Fd(m) && (a.underline = m), X && (a.fontSize = X), Z.toolsType === Gl.Text && Z.opt) {
          this.setTextStyle(e, Al(Z), a, n);
          continue;
        }
        const x = {
          workId: e,
          msgType: yl.UpdateNode,
          dataType: Jl.Local,
          updateNodeOpt: a,
          emitEventType: this.emitEventType,
          willRefresh: !0,
          willRefreshSelector: !0,
          willSyncService: !0,
          textUpdateForWoker: !0,
          undoTickerId: r,
          viewId: n
        };
        p.push(x);
      }
    }
    this.mainEngine.internalMsgEmitter.emit("undoTickerStart", r, n), p.length && this.collectForLocalWorker(p);
  }
}
class Ho extends od {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: hl.SetPoint
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(d) {
    var y;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workId: l, pointMap: i, workState: s, viewId: c } = d, m = this.control.viewContainerManager.getView(c);
    if (!(m != null && m.displayer))
      return;
    const n = m.focusScenePath, X = (y = this.serviceColloctor) == null ? void 0 : y.storage, G = [], L = s === ul.Start && Date.now() || void 0;
    L && (this.undoTickerId = L, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", L, c));
    const o = l;
    if (!o)
      return;
    const h = o.toString(), p = this.serviceColloctor.isLocalId(h), r = p && this.serviceColloctor.transformKey(o) || h;
    let V = h;
    !p && this.serviceColloctor.isOwn(V) && (V = this.serviceColloctor.getLocalId(V));
    const W = X[c][n][r];
    if (W && V === Il && W.selectIds) {
      const t = W.updateNodeOpt || {};
      t.pointMap = i, t.workState = s;
      const e = {
        workId: o,
        msgType: yl.UpdateNode,
        dataType: Jl.Local,
        updateNodeOpt: t,
        emitEventType: this.emitEventType,
        willRefreshSelector: !0,
        willSyncService: !0,
        viewId: c
      };
      s === ul.Done && (e.undoTickerId = this.undoTickerId), G.push(e);
    }
    G.length && this.collectForLocalWorker(G);
  }
}
class Cl {
  constructor(d) {
    Object.defineProperty(this, "builders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), this.builders = new Map(d.map((l) => [l, this.build(l)]));
  }
  build(d) {
    switch (d) {
      case hl.TranslateNode:
        return new Ko();
      case hl.ZIndexNode:
        return new So();
      case hl.ZIndexActive:
        return new xo();
      case hl.CopyNode:
        return new ro();
      case hl.SetColorNode:
        return new Ro();
      case hl.DeleteNode:
        return new Co();
      case hl.ScaleNode:
        return new Jo();
      case hl.RotateNode:
        return new To();
      case hl.SetFontStyle:
        return new No();
      case hl.SetPoint:
        return new Ho();
    }
  }
  getBuilder(d) {
    return this.builders.get(d);
  }
  registerForMainEngine(d, l) {
    return this.builders.forEach((i) => {
      i && i.registerForMainEngine(d, l);
    }), this;
  }
  destroy() {
    this.builders.forEach((d) => {
      d && d.destroy();
    });
  }
  static emitMethod(d, l, i) {
    od.dispatch(d, l, i);
  }
}
class go {
  constructor() {
    Object.defineProperty(this, "maxLastSyncTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 500
    });
  }
  /** 设置当前选中的工具配置数据 */
  setCurrentToolsData(d) {
    this.currentToolsData = d;
  }
  /** 设置当前绘制任务数据 */
  setCurrentLocalWorkData(d) {
    this.currentLocalWorkData = d;
  }
  /** 获取当前激活的工作任务id */
  getWorkId() {
    return this.currentLocalWorkData.workId;
  }
}
class zo extends go {
  constructor(d) {
    var s, c;
    super(), Object.defineProperty(this, "isActive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "currentToolsData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "currentLocalWorkData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localPointsBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "taskBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "fullWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "methodBuilder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "zIndexNodeMethod", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorkerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "wokerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "maxDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "cacheDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "reRenders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "tasksqueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "useTasksqueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "useTasksClockId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mianTasksqueueCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workerTasksqueueCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "snapshotMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "boundingRectMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "clearAllResolve", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localEventTimerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { control: l, internalMsgEmitter: i } = d;
    this.control = l, this.maxLastSyncTime = (((c = (s = this.control.pluginOptions) == null ? void 0 : s.syncOpt) == null ? void 0 : c.interval) || this.maxLastSyncTime) * 0.5, this.internalMsgEmitter = i, this.currentLocalWorkData = { workState: ul.Pending };
  }
  get viewContainerManager() {
    return this.control.viewContainerManager;
  }
  get collector() {
    return this.control.collector;
  }
  get isRunSubWork() {
    const { toolsType: d } = this.currentToolsData;
    return d === Gl.Pencil || d === Gl.LaserPen || d === Gl.Arrow || d === Gl.Straight || d === Gl.Ellipse || d === Gl.Rectangle || d === Gl.Star || d === Gl.Polygon || d === Gl.SpeechBalloon;
  }
  get isCanDrawWork() {
    const { toolsType: d } = this.currentToolsData;
    return d === Gl.Pencil || d === Gl.LaserPen || d === Gl.Arrow || d === Gl.Straight || d === Gl.Ellipse || d === Gl.Rectangle || d === Gl.Star || d === Gl.Polygon || d === Gl.SpeechBalloon;
  }
  get isUseZIndex() {
    const { toolsType: d } = this.currentToolsData;
    return d === Gl.Pencil || d === Gl.Arrow || d === Gl.Straight || d === Gl.Ellipse || d === Gl.Rectangle || d === Gl.Star || d === Gl.Polygon || d === Gl.SpeechBalloon || d === Gl.Text;
  }
  get isCanRecordUndoRedo() {
    const { toolsType: d } = this.currentToolsData;
    return d === Gl.Pencil || d === Gl.Selector || d === Gl.Eraser || d === Gl.Arrow || d === Gl.Straight || d === Gl.Ellipse || d === Gl.Rectangle || d === Gl.Star || d === Gl.Polygon || d === Gl.SpeechBalloon;
  }
  init() {
    this.on(), this.internalMsgEmitterListener(), this.isActive = !0;
  }
  on() {
    this.fullWorker = new Io(), this.subWorker = new Yo(), this.fullWorker.onmessage = (d) => {
      if (d.data) {
        const { render: l, sp: i, drawCount: s, workerTasksqueueCount: c } = d.data;
        if (c && (this.workerTasksqueueCount = c), i != null && i.length && this.collectorSyncData(i), !s && (l != null && l.length)) {
          this.viewContainerManager.render(l);
          return;
        }
        s && (this.wokerDrawCount = s, this.wokerDrawCount < 1 / 0 ? this.maxDrawCount = Math.max(this.maxDrawCount, this.wokerDrawCount) : this.maxDrawCount = 0, l != null && l.length && (this.viewContainerManager.render(l), this.wokerDrawCount < this.subWorkerDrawCount && (this.reRenders.forEach((m) => {
          m.isUnClose = !1;
        }), this.viewContainerManager.render(this.reRenders), this.reRenders.length = 0)));
      }
    }, this.subWorker.onmessage = (d) => {
      if (d.data) {
        const { render: l, drawCount: i, sp: s } = d.data;
        if (s != null && s.length && this.collectorSyncData(s), !i && (l != null && l.length)) {
          this.viewContainerManager.render(l);
          return;
        }
        i && (this.subWorkerDrawCount = i, this.wokerDrawCount < 1 / 0 && (this.maxDrawCount = Math.max(this.maxDrawCount, this.subWorkerDrawCount)), l != null && l.length && (this.subWorkerDrawCount > this.wokerDrawCount && (l.forEach((c) => c.isUnClose = !0), this.reRenders.push(...l)), this.wokerDrawCount < 1 / 0 && this.viewContainerManager.render(l)));
      }
    };
  }
  collectorSyncData(d) {
    var i, s;
    let l = !1;
    for (const c of d) {
      const { type: m, selectIds: n, opt: X, selectRect: G, strokeColor: L, fillColor: o, willSyncService: h, isSync: p, undoTickerId: r, imageBitmap: V, canvasHeight: W, canvasWidth: y, rect: t, op: e, canTextEdit: Z, points: a, selectorColor: x, canRotate: K, scaleType: C, textOpt: T, toolsType: I, workId: J, viewId: F, scenePath: R, dataType: S } = c;
      if (!F) {
        console.error("collectorSyncData", c);
        return;
      }
      switch (m) {
        case yl.Select: {
          const N = n != null && n.length ? { ...G, selectIds: n, canvasHeight: W, canvasWidth: y, points: a } : void 0;
          if (N && (X != null && X.strokeColor) && (N.selectorColor = X.strokeColor), N && x && (N.selectorColor = x), N && L && (N.strokeColor = L), N && (X != null && X.fillColor) && (N.fillColor = X.fillColor), N && o && (N.fillColor = o), N && K && (N.canRotate = K), N && C && (N.scaleType = C), N && Z && (N.canTextEdit = Z), N && T && (N.textOpt = T), F && this.viewContainerManager.showFloatBar(F, !!N, N), h) {
            const Q = this.viewContainerManager.getCurScenePath(F);
            (i = this.collector) == null || i.dispatch({ type: m, selectIds: n, opt: X, isSync: p, viewId: F, scenePath: Q });
          }
          break;
        }
        case yl.Snapshot:
          if (V && R) {
            const N = this.snapshotMap.get(R);
            N && N(V);
          }
          break;
        case yl.BoundingBox:
          if (t && R) {
            const N = this.boundingRectMap.get(R);
            N && N(t);
          }
          break;
        case yl.Cursor:
          e && this.control.cursor.collectServiceCursor({ ...c });
          break;
        case yl.Clear:
          F && this.viewContainerManager.showFloatBar(F, !1), F && this.clearAllResolve && this.clearAllResolve(F);
          break;
        case yl.TextUpdate:
          if (I === Gl.Text && J && F) {
            const N = this.viewContainerManager.transformToOriginPoint((X == null ? void 0 : X.boxPoint) || [0, 0], F), Q = (X == null ? void 0 : X.boxSize) || [0, 0], P = (s = this.viewContainerManager.getView(F)) == null ? void 0 : s.cameraOpt;
            X ? this.control.textEditorManager.updateTextForWorker({
              x: N[0],
              y: N[1],
              w: Q[0],
              h: Q[1],
              scale: (P == null ? void 0 : P.scale) || 1,
              workId: J,
              opt: X,
              dataType: S,
              viewId: F
            }) : this.control.textEditorManager.delete(J, !1, !1);
          }
          break;
        case yl.GetTextActive:
          I === Gl.Text && J && F && this.control.textEditorManager.updateTextForWorker({
            workId: J,
            isActive: !0,
            viewId: F,
            dataType: Jl.Local
          });
          break;
        default:
          l = !0;
          break;
      }
      !l && r && this.internalMsgEmitter.emit("undoTickerEnd", r, F);
    }
    l && Hd(() => {
      this.collectorAsyncData(d);
    }, this.maxLastSyncTime);
  }
  collectorAsyncData(d) {
    var l, i, s, c;
    for (const m of d) {
      const { type: n, op: X, workId: G, index: L, removeIds: o, ops: h, opt: p, updateNodeOpt: r, toolsType: V, isSync: W, undoTickerId: y, viewId: t } = m;
      if (!t) {
        console.error("collectorAsyncData", m);
        return;
      }
      switch (n) {
        case yl.DrawWork: {
          const e = this.viewContainerManager.getCurScenePath(t);
          (l = this.collector) == null || l.dispatch({
            type: n,
            op: X,
            workId: G,
            index: L,
            isSync: W,
            viewId: t,
            scenePath: e
          });
          break;
        }
        case yl.FullWork: {
          const e = this.viewContainerManager.getCurScenePath(t);
          (i = this.collector) == null || i.dispatch({
            type: n,
            ops: h,
            workId: G,
            updateNodeOpt: r,
            opt: p,
            toolsType: V,
            isSync: W,
            viewId: t,
            scenePath: e
          });
          break;
        }
        case yl.UpdateNode: {
          const e = this.viewContainerManager.getCurScenePath(t);
          (s = this.collector) == null || s.dispatch({ type: n, updateNodeOpt: r, workId: G, opt: p, ops: h, op: X, isSync: W, viewId: t, scenePath: e });
          break;
        }
        case yl.RemoveNode: {
          const e = this.viewContainerManager.getCurScenePath(t);
          o && this.control.textEditorManager.deleteBatch(o, !1, !1), (c = this.collector) == null || c.dispatch({ type: n, removeIds: o, isSync: W, viewId: t, scenePath: e });
          break;
        }
      }
      y && this.internalMsgEmitter.emit("undoTickerEnd", y, t);
    }
  }
  setCurrentToolsData(d) {
    var c, m, n, X;
    const l = d.toolsType, i = ((c = this.currentToolsData) == null ? void 0 : c.toolsType) !== d.toolsType;
    super.setCurrentToolsData(d);
    const s = (m = this.viewContainerManager) == null ? void 0 : m.getAllViews();
    if (s != null && s.length) {
      if (this.taskBatchData.add({
        msgType: yl.UpdateTools,
        dataType: Jl.Local,
        toolsType: l,
        opt: { ...d.toolsOpt, syncUnitTime: this.maxLastSyncTime },
        isRunSubWork: this.isRunSubWork,
        viewId: rt
      }), (n = this.viewContainerManager) != null && n.focuedView) {
        const { id: G, focusScenePath: L } = this.viewContainerManager.focuedView;
        i && G && L && ((X = this.collector) != null && X.hasSelector(G, L) && this.blurSelector(G, L), this.control.textEditorManager.activeId && this.control.textEditorManager.checkEmptyTextBlur());
      }
      this.runAnimation();
    }
  }
  setCurrentLocalWorkData(d, l = yl.None) {
    super.setCurrentLocalWorkData(d);
    const { workState: i, workId: s, toolsOpt: c } = d;
    if (i !== ul.Unwritable && l !== yl.None && this.viewContainerManager.focuedView) {
      const { id: m } = this.viewContainerManager.focuedView;
      if (m) {
        const n = this.currentToolsData.toolsType;
        this.taskBatchData.add({
          msgType: l,
          workId: s,
          toolsType: n,
          opt: { ...this.currentToolsData.toolsOpt, ...c, syncUnitTime: this.maxLastSyncTime },
          dataType: Jl.Local,
          isRunSubWork: this.isRunSubWork,
          viewId: m
        }), this.runAnimation();
      }
    }
  }
  createViewWorker(d, l) {
    const { offscreenCanvasOpt: i, layerOpt: s, dpr: c, cameraOpt: m } = l;
    this.taskBatchData.add({
      msgType: yl.Init,
      dataType: Jl.Local,
      viewId: d,
      offscreenCanvasOpt: i,
      layerOpt: s,
      dpr: c,
      cameraOpt: m,
      isRunSubWork: !0
    }), this.runAnimation();
  }
  destroyViewWorker(d) {
    var l;
    this.taskBatchData.add({
      msgType: yl.Destroy,
      dataType: Jl.Local,
      viewId: d,
      isRunSubWork: !0
    }), this.runAnimation(), (l = this.collector) == null || l.dispatch({
      type: yl.Clear,
      viewId: d
    });
  }
  onServiceDerive(d, l) {
    var L, o, h;
    const { newValue: i, oldValue: s, viewId: c, scenePath: m } = l, n = Al(i) || {}, X = d;
    let G = n.type;
    if (!(!i && s && (G = yl.RemoveNode, s.toolsType === Gl.LaserPen))) {
      if (G && X) {
        const p = n;
        if (p.workId = (L = this.collector) != null && L.isOwn(X) ? (o = this.collector) == null ? void 0 : o.getLocalId(X) : X, p.msgType = G, p.dataType = Jl.Service, p.viewId = c, p.scenePath = m, p.selectIds && (p.selectIds = p.selectIds.map((r) => {
          var V, W;
          return (V = this.collector) != null && V.isOwn(r) ? (W = this.collector) == null ? void 0 : W.getLocalId(r) : r;
        })), p && p.toolsType === Gl.Text || (s == null ? void 0 : s.toolsType) === Gl.Text) {
          this.control.textEditorManager.onServiceDerive(p);
          return;
        }
        this.taskBatchData.add(p);
      }
      if (this.runAnimation(), this.zIndexNodeMethod) {
        let p, r;
        l.newValue && ((h = l.newValue.opt) != null && h.zIndex) && (r = Math.max(r || 0, l.newValue.opt.zIndex), p = Math.min(p || 1 / 0, l.newValue.opt.zIndex)), r && (this.zIndexNodeMethod.maxZIndex = r), p && (this.zIndexNodeMethod.minZIndex = p);
      }
    }
  }
  pullServiceData(d, l) {
    var s, c, m, n, X, G;
    const i = ((s = this.collector) == null ? void 0 : s.storage[d]) && ((c = this.collector) == null ? void 0 : c.storage[d][l]) || void 0;
    if (i) {
      let L, o;
      const h = Object.keys(i);
      for (const p of h) {
        const r = (m = i[p]) == null ? void 0 : m.type;
        if (r && p) {
          const V = Al(i[p]);
          if (V.workId = (n = this.collector) != null && n.isOwn(p) ? (X = this.collector) == null ? void 0 : X.getLocalId(p) : p, V.msgType = r, V.dataType = Jl.Service, V.viewId = d, V.scenePath = l, V.useAnimation = !1, V.selectIds && (V.selectIds = V.selectIds.map((W) => {
            var y, t;
            return (y = this.collector) != null && y.isOwn(W) ? (t = this.collector) == null ? void 0 : t.getLocalId(W) : W;
          })), V.toolsType === Gl.Text) {
            this.control.textEditorManager.onServiceDerive(V);
            continue;
          }
          this.taskBatchData.add(V), (G = V.opt) != null && G.zIndex && (o = Math.max(o || 0, V.opt.zIndex), L = Math.min(L || 1 / 0, V.opt.zIndex));
        }
        this.internalMsgEmitter.emit("excludeIds", h);
      }
      this.runAnimation(), this.zIndexNodeMethod && (o && (this.zIndexNodeMethod.maxZIndex = o), L && (this.zIndexNodeMethod.minZIndex = L));
    }
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  consume() {
    this.animationId = void 0;
    const d = this.currentLocalWorkData.workState;
    let l = !1;
    if (!this.localEventTimerId && (d !== ul.Pending && this.localPointsBatchData.length && (this.wokerDrawCount !== 1 / 0 && this.wokerDrawCount <= this.subWorkerDrawCount && this.cacheDrawCount < this.maxDrawCount && (l = !0), this.maxDrawCount || (l = !0), l && this.viewContainerManager.focuedViewId && (this.taskBatchData.add({
      op: this.localPointsBatchData.map((i) => i),
      workState: d,
      workId: this.currentLocalWorkData.workId,
      dataType: Jl.Local,
      msgType: yl.DrawWork,
      isRunSubWork: this.isRunSubWork,
      undoTickerId: d === ul.Done && this.undoTickerId || void 0,
      viewId: this.viewContainerManager.focuedViewId,
      scenePath: this.viewContainerManager.focuedViewId && this.viewContainerManager.getCurScenePath(this.viewContainerManager.focuedViewId)
    }), this.localPointsBatchData.length = 0, this.cacheDrawCount = this.maxDrawCount)), this.taskBatchData.size)) {
      this.post(this.taskBatchData);
      for (const i of this.taskBatchData.values())
        if (i.msgType === yl.TasksQueue) {
          this.tasksqueue.clear();
          break;
        }
      this.taskBatchData.clear(), this.undoTickerId && d === ul.Done && (this.undoTickerId = void 0);
    }
    this.tasksqueue.size && this.consumeQueue(), (this.tasksqueue.size || this.taskBatchData.size || this.localPointsBatchData.length) && (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  unabled() {
    this.setCurrentLocalWorkData({ workState: ul.Freeze, workId: void 0 });
  }
  abled() {
    this.setCurrentLocalWorkData({ workState: ul.Pending, workId: void 0 });
  }
  post(d) {
    this.fullWorker.postMessage(d);
    const l = /* @__PURE__ */ new Set();
    for (const i of d.values()) {
      const s = i.msgType;
      (s === yl.Init || s === yl.Clear || s === yl.Destroy || s === yl.UpdateCamera || i.isRunSubWork) && l.add(i);
    }
    l.size && this.subWorker.postMessage(l);
  }
  destroy() {
    this.unabled(), this.taskBatchData.clear(), this.localPointsBatchData.length = 0, this.fullWorker.terminate(), this.subWorker.terminate(), this.isActive = !1;
  }
  updateNode(d, l, i, s) {
    this.taskBatchData.add({
      msgType: yl.UpdateNode,
      workId: d,
      updateNodeOpt: l,
      viewId: i,
      scenePath: s,
      dataType: Jl.Local
    }), this.runAnimation();
  }
  updateCamera(d, l) {
    this.useTasksqueue || (this.useTasksqueue = !0, this.mianTasksqueueCount = 1, this.workerTasksqueueCount = 1), this.useTasksqueue && (this.tasksqueue.set(d, {
      msgType: yl.UpdateCamera,
      dataType: Jl.Local,
      cameraOpt: l,
      isRunSubWork: !0,
      viewId: d
    }), this.control.textEditorManager.onCameraChange(l, d), this.runAnimation(), this.useTasksClockId && clearTimeout(this.useTasksClockId), this.useTasksClockId = setTimeout(() => {
      this.useTasksClockId = void 0, this.tasksqueue.clear(), this.useTasksqueue = !1, this.mianTasksqueueCount = void 0, this.workerTasksqueueCount = void 0;
    }, this.maxLastSyncTime));
  }
  consumeQueue() {
    this.mianTasksqueueCount && this.workerTasksqueueCount && this.mianTasksqueueCount === this.workerTasksqueueCount && (this.mianTasksqueueCount++, this.taskBatchData.add({
      msgType: yl.TasksQueue,
      dataType: Jl.Local,
      isRunSubWork: !0,
      mainTasksqueueCount: this.mianTasksqueueCount,
      tasksqueue: this.tasksqueue,
      viewId: ""
    }));
  }
  async clearViewScenePath(d, l) {
    var i;
    if (this.control.textEditorManager.clear(d, l), this.taskBatchData.add({
      dataType: Jl.Local,
      msgType: yl.Clear,
      viewId: d
    }), this.runAnimation(), !l) {
      const s = this.viewContainerManager.getCurScenePath(d);
      (i = this.collector) == null || i.dispatch({
        type: yl.Clear,
        viewId: d,
        scenePath: s
      });
    }
    this.zIndexNodeMethod && (this.zIndexNodeMethod.maxZIndex = 0, this.zIndexNodeMethod.minZIndex = 0), this.localPointsBatchData.length = 0, await new Promise((s) => {
      this.clearAllResolve = s;
    }).then(() => {
      this.clearAllResolve = void 0;
    });
  }
  internalMsgEmitterListener() {
    var d;
    this.methodBuilder = new Cl([
      hl.CopyNode,
      hl.SetColorNode,
      hl.DeleteNode,
      hl.RotateNode,
      hl.ScaleNode,
      hl.TranslateNode,
      hl.ZIndexActive,
      hl.ZIndexNode,
      hl.RotateNode,
      hl.SetFontStyle,
      hl.SetPoint
    ]).registerForMainEngine(Sl.MainEngine, this.control), this.zIndexNodeMethod = (d = this.methodBuilder) == null ? void 0 : d.getBuilder(hl.ZIndexNode);
  }
  originalEventLintener(d, l, i) {
    switch (d) {
      case ul.Start:
        this.onLocalEventStart(l, i);
        break;
      case ul.Doing:
        i === this.viewContainerManager.focuedViewId && this.onLocalEventDoing(l);
        break;
      case ul.Done:
        i === this.viewContainerManager.focuedViewId && this.onLocalEventEnd(l);
        break;
    }
  }
  setZIndex() {
    const d = Al(this.currentToolsData.toolsOpt);
    return this.zIndexNodeMethod && this.isUseZIndex && (this.zIndexNodeMethod.addMaxLayer(), d.zIndex = this.zIndexNodeMethod.maxZIndex), d;
  }
  onLocalEventEnd(d) {
    const l = this.currentLocalWorkData.workState;
    if (!(l === ul.Freeze || l === ul.Unwritable) && this.viewContainerManager.focuedView) {
      const { id: i, focusScenePath: s, cameraOpt: c } = this.viewContainerManager.focuedView;
      if (l === ul.Start || l === ul.Doing) {
        const m = this.viewContainerManager.transformToScenePoint(d, i);
        this.pushPoint(m), this.localEventTimerId = setTimeout(() => {
          this.localEventTimerId = void 0, this.setCurrentLocalWorkData({ ...this.currentLocalWorkData, workState: ul.Done }), this.runAnimation();
        }, 0), this.currentToolsData.toolsType === Gl.Selector && this.viewContainerManager.activeFloatBar(i);
      } else if (this.currentToolsData.toolsType === Gl.Text) {
        const m = this.viewContainerManager.transformToScenePoint(d, i);
        if (this.localPointsBatchData[0] === m[0] && this.localPointsBatchData[1] === m[1]) {
          const n = this.currentToolsData.toolsOpt;
          n.workState = ul.Doing, n.boxPoint = m, n.boxSize = [n.fontSize, n.fontSize], this.control.textEditorManager.createTextForMasterController({
            workId: Date.now().toString(),
            x: d[0],
            y: d[1],
            scale: (c == null ? void 0 : c.scale) || 1,
            opt: n,
            type: ed.Text,
            isActive: !0,
            viewId: i,
            scenePath: s
          });
        }
        this.localPointsBatchData.length = 0;
      }
    }
  }
  onLocalEventDoing(d) {
    let l = this.currentLocalWorkData.workState;
    if (l === ul.Freeze || l === ul.Unwritable)
      return;
    const i = this.viewContainerManager.focuedViewId;
    if (i && (l === ul.Start && (l = ul.Doing, this.setCurrentLocalWorkData({ ...this.currentLocalWorkData, workState: l })), l === ul.Doing || this.localEventTimerId)) {
      const s = this.viewContainerManager.transformToScenePoint(d, i);
      this.pushPoint(s), this.localEventTimerId || this.runAnimation();
    }
  }
  onLocalEventStart(d, l) {
    var n;
    const { workState: i } = this.currentLocalWorkData;
    if (i === ul.Freeze || i === ul.Unwritable || !l)
      return;
    this.viewContainerManager.focuedViewId !== l && this.viewContainerManager.setFocuedViewId(l);
    const s = this.viewContainerManager.transformToScenePoint(d, l);
    if (this.pushPoint(s), this.currentToolsData.toolsType === Gl.Text)
      return;
    this.control.textEditorManager.checkEmptyTextBlur();
    const c = this.currentToolsData.toolsType === Gl.Selector ? Il : Date.now(), m = this.setZIndex();
    if (this.setCurrentLocalWorkData({
      workId: c,
      workState: ul.Start,
      toolsOpt: m
    }, yl.CreateWork), this.maxDrawCount = 0, this.cacheDrawCount = 0, this.wokerDrawCount = 0, this.subWorkerDrawCount = 0, this.reRenders.length = 0, this.isCanRecordUndoRedo && (this.currentToolsData.toolsType === Gl.Selector ? this.undoTickerId = Date.now() : this.undoTickerId = c, this.internalMsgEmitter.emit("undoTickerStart", this.undoTickerId, l)), this.isCanDrawWork) {
      const X = this.viewContainerManager.getCurScenePath(l);
      (n = this.collector) == null || n.dispatch({
        type: yl.CreateWork,
        workId: c,
        toolsType: this.currentToolsData.toolsType,
        opt: this.currentToolsData.toolsOpt,
        viewId: l,
        scenePath: X
      }), X && this.blurSelector(l, X);
    } else
      this.currentToolsData.toolsType === Gl.Selector && this.viewContainerManager.unActiveFloatBar(l);
    this.consume();
  }
  pushPoint(d) {
    this.localPointsBatchData.push(d[0], d[1]);
  }
  sendCursorEvent(d, l) {
    if (this.currentLocalWorkData.workState === ul.Freeze || this.currentLocalWorkData.workState === ul.Unwritable)
      return;
    let i = [void 0, void 0];
    this.currentToolsData && (this.isCanDrawWork || this.currentToolsData.toolsType === Gl.Text) && this.currentLocalWorkData.workState !== ul.Start && this.currentLocalWorkData.workState !== ul.Doing && (i = d), this.control.cursor.sendEvent(i, l);
  }
  blurSelector(d, l, i) {
    var s;
    (s = this.collector) != null && s.hasSelector(d, l) && (this.taskBatchData.add({
      workId: Il,
      selectIds: [],
      msgType: yl.Select,
      dataType: Jl.Service,
      viewId: d,
      scenePath: l,
      undoTickerId: i
    }), this.runAnimation());
  }
  getBoundingRect(d) {
    var i, s;
    if (!((i = this.boundingRectMap) == null ? void 0 : i.get(d))) {
      const c = (s = this.collector) == null ? void 0 : s.getScenePathData(d);
      if (!c)
        return;
      if (Object.keys(c).forEach((m) => {
        var n;
        ((n = this.collector) == null ? void 0 : n.getLocalId(m)) === Il && delete c[m];
      }), Object.keys(c).length && this.viewContainerManager.mainView && this.viewContainerManager.mainView.cameraOpt) {
        const m = {
          msgType: yl.BoundingBox,
          dataType: Jl.Local,
          scenePath: d,
          scenes: c,
          cameraOpt: { ...this.viewContainerManager.mainView.cameraOpt },
          isRunSubWork: !0,
          viewId: this.viewContainerManager.mainView.id
        };
        return this.taskBatchData.add(m), this.runAnimation(), new Promise((n) => {
          this.boundingRectMap.set(d, n);
        }).then((n) => (this.boundingRectMap.delete(d), n));
      }
    }
  }
  getSnapshot(d, l, i, s) {
    var m, n, X, G, L;
    if (!((m = this.snapshotMap) == null ? void 0 : m.get(d))) {
      const o = (n = this.collector) == null ? void 0 : n.getViewIdBySecenPath(d);
      if (!o)
        return;
      const h = (X = this.collector) == null ? void 0 : X.getStorageData(o, d);
      if (!h)
        return;
      if (Object.keys(h).forEach((p) => {
        var r;
        ((r = this.collector) == null ? void 0 : r.getLocalId(p)) === Il && delete h[p];
      }), Object.keys(h).length) {
        const p = this.viewContainerManager.getView(o) || this.viewContainerManager.focuedView;
        if (!p)
          return;
        const r = l || ((G = p.cameraOpt) == null ? void 0 : G.width), V = i || ((L = p.cameraOpt) == null ? void 0 : L.height), W = {
          msgType: yl.Snapshot,
          dataType: Jl.Local,
          scenePath: d,
          scenes: h,
          w: r,
          h: V,
          cameraOpt: s && {
            ...s,
            width: r,
            height: V
          } || p.cameraOpt,
          isRunSubWork: !0,
          viewId: o
        };
        return this.taskBatchData.add(W), this.runAnimation(), new Promise((y) => {
          this.snapshotMap.set(d, y);
        }).then((y) => (this.snapshotMap.delete(d), y));
      }
    }
  }
}
var Mo = ad, ko = function() {
  return Mo.Date.now();
}, vo = ko, Uo = /\s/;
function Qo(b) {
  for (var d = b.length; d-- && Uo.test(b.charAt(d)); )
    ;
  return d;
}
var wo = Qo, Po = wo, fo = /^\s+/;
function Eo(b) {
  return b && b.slice(0, Po(b) + 1).replace(fo, "");
}
var Bo = Eo, jo = Jd, Oo = Ld, Do = "[object Symbol]";
function Ao(b) {
  return typeof b == "symbol" || Oo(b) && jo(b) == Do;
}
var qo = Ao, $o = Bo, Js = xd, _o = qo, Ts = NaN, lG = /^[-+]0x[0-9a-f]+$/i, dG = /^0b[01]+$/i, iG = /^0o[0-7]+$/i, sG = parseInt;
function tG(b) {
  if (typeof b == "number")
    return b;
  if (_o(b))
    return Ts;
  if (Js(b)) {
    var d = typeof b.valueOf == "function" ? b.valueOf() : b;
    b = Js(d) ? d + "" : d;
  }
  if (typeof b != "string")
    return b === 0 ? b : +b;
  b = $o(b);
  var l = dG.test(b);
  return l || iG.test(b) ? sG(b.slice(2), l ? 2 : 8) : lG.test(b) ? Ts : +b;
}
var cG = tG, bG = xd, Wi = vo, Fs = cG, ZG = "Expected a function", mG = Math.max, nG = Math.min;
function XG(b, d, l) {
  var i, s, c, m, n, X, G = 0, L = !1, o = !1, h = !0;
  if (typeof b != "function")
    throw new TypeError(ZG);
  d = Fs(d) || 0, bG(l) && (L = !!l.leading, o = "maxWait" in l, c = o ? mG(Fs(l.maxWait) || 0, d) : c, h = "trailing" in l ? !!l.trailing : h);
  function p(x) {
    var K = i, C = s;
    return i = s = void 0, G = x, m = b.apply(C, K), m;
  }
  function r(x) {
    return G = x, n = setTimeout(y, d), L ? p(x) : m;
  }
  function V(x) {
    var K = x - X, C = x - G, T = d - K;
    return o ? nG(T, c - C) : T;
  }
  function W(x) {
    var K = x - X, C = x - G;
    return X === void 0 || K >= d || K < 0 || o && C >= c;
  }
  function y() {
    var x = Wi();
    if (W(x))
      return t(x);
    n = setTimeout(y, V(x));
  }
  function t(x) {
    return n = void 0, h && i ? p(x) : (i = s = void 0, m);
  }
  function e() {
    n !== void 0 && clearTimeout(n), G = 0, i = X = s = n = void 0;
  }
  function Z() {
    return n === void 0 ? m : t(Wi());
  }
  function a() {
    var x = Wi(), K = W(x);
    if (i = arguments, s = this, X = x, K) {
      if (n === void 0)
        return r(X);
      if (o)
        return clearTimeout(n), n = setTimeout(y, d), p(X);
    }
    return n === void 0 && (n = setTimeout(y, d)), m;
  }
  return a.cancel = e, a.flush = Z, a;
}
var ht = XG;
const eG = /* @__PURE__ */ Cd(ht);
var aG = ht, oG = xd, GG = "Expected a function";
function WG(b, d, l) {
  var i = !0, s = !0;
  if (typeof b != "function")
    throw new TypeError(GG);
  return oG(l) && (i = "leading" in l ? !!l.leading : i, s = "trailing" in l ? !!l.trailing : s), aG(b, d, {
    leading: i,
    maxWait: d,
    trailing: s
  });
}
var uG = WG;
const El = /* @__PURE__ */ Cd(uG);
class td {
  constructor(d) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "play", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomMember", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cursor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textEditorManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (m, n) => {
        var L;
        const X = (L = this.viewContainerManager.getView(n)) == null ? void 0 : L.focusScenePath;
        X && this.worker.blurSelector(n, X);
        const G = m;
        G && this.viewContainerManager.setViewScenePath(n, G);
      }
    }), Object.defineProperty(this, "onRoomMembersChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (m) => {
        this.roomMember.setRoomMembers(Ms(m));
      }
    }), Object.defineProperty(this, "onMemberChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: El((m) => {
        if (!this.room || !this.worker)
          return;
        const n = this.getToolsKey(m), X = this.getToolsOpt(n, m);
        this.worker.setCurrentToolsData(X), this.effectViewContainer(n);
      }, 100, { leading: !1 })
    }), Object.defineProperty(this, "internalSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (m, n) => {
        var X;
        (X = this.worker) == null || X.clearViewScenePath(m, !0).then(() => {
          var G;
          (G = this.worker) == null || G.pullServiceData(m, n);
        });
      }
    }), Object.defineProperty(this, "internalCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (m, n) => {
        var X;
        (X = this.worker) == null || X.updateCamera(m, n);
      }
    });
    const { displayer: l, plugin: i, options: s } = d;
    this.plugin = i, this.room = Gd(l) ? l : void 0, this.play = vs(l) ? l : void 0, this.pluginOptions = s, this.roomMember = new po();
    const c = {
      control: this,
      internalMsgEmitter: td.InternalMsgEmitter
    };
    this.cursor = new Lo(c), this.textEditorManager = new yo(c), this.worker = new zo(c);
  }
  bindPlugin(d) {
    var l, i;
    this.plugin = d, this.collector && this.collector.removeStorageStateListener(), this.collector = new pd(d, (i = (l = this.pluginOptions) == null ? void 0 : l.syncOpt) == null ? void 0 : i.interval), this.cursor.activeCollector(), this.activePlugin();
  }
  /** 销毁 */
  destroy() {
    var d, l, i, s, c;
    this.roomMember.destroy(), (d = this.collector) == null || d.destroy(), (l = this.worker) == null || l.destroy(), (i = this.viewContainerManager) == null || i.destroy(), (s = this.cursor) == null || s.destroy(), (c = this.textEditorManager) == null || c.destory();
  }
  /** 清空当前获焦路径下的所有内容 */
  cleanCurrentScene() {
    const d = Date.now(), l = this.viewContainerManager.focuedViewId;
    l && (td.InternalMsgEmitter.emit("undoTickerStart", d, l), this.worker.clearViewScenePath(l).then(() => {
      td.InternalMsgEmitter.emit("undoTickerEnd", d, l);
    }));
  }
  /** 监听读写状态变更 */
  onWritableChange(d) {
    var l, i;
    d ? (i = this.worker) == null || i.abled() : (l = this.worker) == null || l.unabled();
  }
  /** 获取当前工具key */
  getToolsKey(d) {
    switch (d.currentApplianceName) {
      case zl.text:
        return Gl.Text;
      case zl.pencil:
        if (d.useNewPencil)
          return Gl.Pencil;
        if (d.useLaserPen)
          return Gl.LaserPen;
        break;
      case zl.eraser:
      case zl.pencilEraser:
        return Gl.Eraser;
      case zl.selector:
        return Gl.Selector;
      case zl.arrow:
        return Gl.Arrow;
      case zl.straight:
        return Gl.Straight;
      case zl.ellipse:
        return Gl.Ellipse;
      case zl.rectangle:
        return Gl.Rectangle;
      case zl.shape:
        if (d.shapeType === nd.Pentagram || d.shapeType === nd.Star)
          return Gl.Star;
        if (d.shapeType === nd.Polygon || d.shapeType === nd.Triangle || d.shapeType === nd.Rhombus)
          return Gl.Polygon;
        if (d.shapeType === nd.SpeechBalloon)
          return Gl.SpeechBalloon;
        break;
    }
    return Gl.Clicker;
  }
  /** 获取当前工具默认配置 */
  getToolsOpt(d, l) {
    const i = l.currentApplianceName, s = {
      strokeColor: Od(l.strokeColor[0], l.strokeColor[1], l.strokeColor[2], l.strokeOpacity || 1),
      thickness: l.strokeWidth,
      isOpacity: (l == null ? void 0 : l.strokeOpacity) && l.strokeOpacity < 1 || (l == null ? void 0 : l.fillOpacity) && l.fillOpacity < 1 || (l == null ? void 0 : l.textOpacity) && l.textOpacity < 1 || (l == null ? void 0 : l.textBgOpacity) && l.textBgOpacity < 1 || !1
    };
    switch (d) {
      case Gl.Text:
        s.fontFamily = window.getComputedStyle(document.documentElement).getPropertyValue("font-family"), s.fontSize = (l == null ? void 0 : l.textSize) || Number(window.getComputedStyle(document.body).fontSize), s.textAlign = (l == null ? void 0 : l.textAlign) || "left", s.verticalAlign = (l == null ? void 0 : l.verticalAlign) || "middle", s.fontColor = (l == null ? void 0 : l.textColor) && Od(l.textColor[0], l.textColor[1], l.textColor[2], l.textOpacity || 1) || s.strokeColor || "rgba(0,0,0,1)", s.fontBgColor = Array.isArray(l == null ? void 0 : l.textBgColor) && Od(l.textBgColor[0], l.textBgColor[1], l.textBgColor[2], l.textBgOpacity || 1) || "transparent", s.bold = (l == null ? void 0 : l.bold) && "bold" || void 0, s.italic = (l == null ? void 0 : l.italic) && "italic" || void 0, s.underline = (l == null ? void 0 : l.underline) || void 0, s.lineThrough = (l == null ? void 0 : l.lineThrough) || void 0, s.text = "", s.strokeColor = void 0;
        break;
      case Gl.Pencil:
        s.strokeType = (l == null ? void 0 : l.strokeType) || Ad.Normal;
        break;
      case Gl.Eraser:
        s.thickness = Math.min(3, Math.max(1, Math.floor(l.pencilEraserSize || 1))) - 1, s.isLine = i === zl.eraser && !0;
        break;
      case Gl.LaserPen:
        s.duration = (l == null ? void 0 : l.duration) || 1, s.strokeType = (l == null ? void 0 : l.strokeType) || Ad.Normal;
        break;
      case Gl.Ellipse:
      case Gl.Rectangle:
      case Gl.Star:
      case Gl.Polygon:
      case Gl.SpeechBalloon:
        d === Gl.Star && (l.shapeType === nd.Pentagram ? (s.vertices = 10, s.innerVerticeStep = 2, s.innerRatio = 0.4) : l != null && l.vertices && (l != null && l.innerVerticeStep) && (l != null && l.innerRatio) && (s.vertices = l.vertices, s.innerVerticeStep = l.innerVerticeStep, s.innerRatio = l.innerRatio)), d === Gl.Polygon && (l.shapeType === nd.Triangle ? s.vertices = 3 : l.shapeType === nd.Rhombus ? s.vertices = 4 : l.vertices && (s.vertices = l.vertices)), s.fillColor = (l == null ? void 0 : l.fillColor) && Od(l.fillColor[0], l.fillColor[1], l.fillColor[2], l == null ? void 0 : l.fillOpacity) || "transparent", d === Gl.SpeechBalloon && (s.placement = l.placement || "bottomLeft");
        break;
    }
    return {
      toolsType: d,
      toolsOpt: s
    };
  }
  /** 激活当前view容器*/
  effectViewContainer(d) {
    var l, i, s, c, m;
    switch (d) {
      case Gl.Text:
      case Gl.Pencil:
      case Gl.LaserPen:
      case Gl.Arrow:
      case Gl.Straight:
      case Gl.Rectangle:
      case Gl.Ellipse:
      case Gl.Star:
      case Gl.Polygon:
      case Gl.SpeechBalloon:
        this.room.disableDeviceInputs = !0, (l = this.worker) == null || l.abled(), setTimeout(() => {
          this.viewContainerManager.getAllViews().forEach((X) => {
            X != null && X.displayer && X.displayer.bindToolsClass();
          });
        }, 0);
        break;
      case Gl.Eraser:
      case Gl.Selector:
        this.room.disableDeviceInputs = !1, (i = this.cursor) == null || i.unable(), (s = this.worker) == null || s.abled();
        break;
      default:
        this.room.disableDeviceInputs = !1, (c = this.worker) == null || c.unabled(), (m = this.cursor) == null || m.unable();
        break;
    }
  }
  /** 异步获取指定路径下绘制内容的区域大小 */
  async getBoundingRect(d) {
    var i;
    const l = await ((i = this.worker) == null ? void 0 : i.getBoundingRect(d));
    if (l)
      return {
        width: l.w,
        height: l.h,
        originX: l.x,
        originY: l.y
      };
  }
  /** 异步获取指定路径下的的快照并绘制到指定的画布上 */
  async screenshotToCanvas(d, l, i, s, c) {
    const m = await this.worker.getSnapshot(l, i, s, c);
    m && (d.drawImage(m, 0, 0), m.close());
  }
  /** 异步获取指定路径下的缩略图 */
  async scenePreview(d, l) {
    var m, n, X, G;
    const i = (m = this.collector) == null ? void 0 : m.getViewIdBySecenPath(d);
    if (!i)
      return;
    const s = this.viewContainerManager.getView(i);
    if (!s || !((n = s.cameraOpt) != null && n.width) || !((X = s.cameraOpt) != null && X.height))
      return;
    const c = await ((G = this.worker) == null ? void 0 : G.getSnapshot(d));
    if (c && this.worker) {
      const L = document.createElement("canvas"), o = L.getContext("2d"), { width: h, height: p } = s.cameraOpt;
      L.width = h, L.height = p, o && (o.drawImage(c, 0, 0), l.src = L.toDataURL(), l.onload = () => {
        L.remove();
      }, l.onerror = () => {
        L.remove(), l.remove();
      }), c.close();
    }
  }
}
Object.defineProperty(td, "InternalMsgEmitter", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: new zs()
});
var hG = Gt, VG = 4;
function pG(b) {
  return hG(b, VG);
}
var yG = pG;
const Ns = /* @__PURE__ */ Cd(yG);
var fd;
(function(b) {
  b[b.sdk = 1] = "sdk", b[b.plugin = 2] = "plugin", b[b.both = 3] = "both";
})(fd || (fd = {}));
var Id;
(function(b) {
  b[b.Draw = 1] = "Draw", b[b.Delete = 2] = "Delete", b[b.Update = 3] = "Update";
})(Id || (Id = {}));
class Kd {
  constructor(d) {
    Object.defineProperty(this, "emitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new zs()
    }), Object.defineProperty(this, "undoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "redoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "isTicking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scenePath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tickStartStorerCache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "undoTickerEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: eG((c, m, n) => {
        var X, G;
        if (c === this.undoTickerId && n === this.scenePath && m === this.viewId && this.tickStartStorerCache) {
          const L = ((X = this.collector) == null ? void 0 : X.storage[m]) && ((G = this.collector) == null ? void 0 : G.storage[m][n]) || {}, o = this.diffFun(this.tickStartStorerCache, new Map(Object.entries(L)));
          o.size && (this.undoStack.push({
            id: c,
            type: fd.plugin,
            data: o,
            scenePath: n
          }), this.undoStack.length > Kd.MaxStackLength && this.undoStack.shift(), this.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length)), this.redoStack.length && (this.redoStack.length = 0, this.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length));
        }
        this.isTicking = !1, this.scenePath = void 0, this.tickStartStorerCache = void 0, this.undoTickerId = void 0, this.excludeIds.clear();
      }, Kd.waitTime)
    });
    const { control: l, internalMsgEmitter: i, viewId: s } = d;
    this.control = l, this.emitter = i, this.undoStack = [], this.redoStack = [], this.room = l.room, this.worker = l.worker, this.isTicking = !1, this.viewId = s;
  }
  get collector() {
    return this.control.collector;
  }
  addExcludeIds(d) {
    if (this.isTicking)
      for (const l of d)
        this.excludeIds.add(l);
  }
  undoTickerStart(d, l) {
    var s, c;
    this.isTicking = !0, this.excludeIds.clear(), this.undoTickerId = d, this.scenePath = l;
    const i = ((s = this.collector) == null ? void 0 : s.storage[this.viewId]) && ((c = this.collector) == null ? void 0 : c.storage[this.viewId][l]) || {};
    this.tickStartStorerCache = new Map(Object.entries(Al(i)));
  }
  undo(d) {
    let l = this.undoStack.length - 1;
    for (; l >= 0; ) {
      if (this.undoStack[l].scenePath === d) {
        const m = this.undoStack[l];
        m && (this.redoStack.push(m), m.type === fd.plugin && m.data && this.refreshPlugin(m)), this.undoStack.splice(l, 1);
        break;
      }
      l--;
    }
    const i = this.undoStack.filter((c) => c.scenePath === d).length, s = this.redoStack.filter((c) => c.scenePath === d).length;
    return this.emitter.emit("onCanUndoStepsUpdate", i), this.emitter.emit("onCanRedoStepsUpdate", s), i;
  }
  redo(d) {
    let l = this.redoStack.length - 1;
    for (; l > 0; ) {
      if (this.redoStack[l].scenePath === d) {
        const m = this.redoStack[l];
        m && (this.undoStack.push(m), m.type === fd.plugin && m.data && this.refreshPlugin(m, !0)), this.redoStack.splice(l, 1);
        break;
      }
      l--;
    }
    const i = this.undoStack.filter((c) => c.scenePath === d).length, s = this.redoStack.filter((c) => c.scenePath === d).length;
    return this.emitter.emit("onCanUndoStepsUpdate", i), this.emitter.emit("onCanRedoStepsUpdate", s), s;
  }
  clear() {
    this.clearUndo(), this.clearRedo();
  }
  clearUndo() {
    this.undoStack.length = 0, this.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length);
  }
  clearRedo() {
    this.redoStack.length = 0, this.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length);
  }
  canUndo() {
    return !!this.undoStack.length;
  }
  canRedo() {
    return !!this.redoStack.length;
  }
  diffFun(d, l) {
    const i = /* @__PURE__ */ new Set(), s = d.keys(), c = l.keys();
    for (const m of s) {
      if (this.excludeIds.has(m))
        continue;
      const n = d.get(m), X = l.get(m);
      if (n && X) {
        if (ld(X, n))
          continue;
        i.add({
          dataType: Id.Update,
          key: m,
          data: [n, X]
        });
        continue;
      }
      n && i.add({
        dataType: Id.Delete,
        key: m,
        data: n
      });
    }
    for (const m of c) {
      const n = l.get(m);
      n && !d.has(m) && i.add({
        dataType: Id.Draw,
        key: m,
        data: n
      });
    }
    return i;
  }
  isDrawEffectiveScene(d, l) {
    const { key: i } = d;
    return !l.includes(i);
  }
  isDeleteEffectiveScene(d, l, i) {
    var m;
    const { key: s } = d;
    if (!l.includes(s))
      return !1;
    const c = l.filter((n) => {
      var X, G;
      return ((X = this.collector) == null ? void 0 : X.getLocalId(n)) === Il && !((G = this.collector) != null && G.isOwn(n));
    }).map((n) => {
      var X;
      return (X = this.collector) == null ? void 0 : X.storage[this.viewId][i][n];
    });
    for (const n of c)
      if ((m = n == null ? void 0 : n.selectIds) != null && m.includes(s))
        return !1;
    return !0;
  }
  isOldEffectiveScene(d, l, i) {
    var m;
    const { key: s } = d;
    if (!l.includes(s))
      return !1;
    const c = l.filter((n) => {
      var X, G;
      return ((X = this.collector) == null ? void 0 : X.getLocalId(n)) === Il && !((G = this.collector) != null && G.isOwn(n));
    }).map((n) => {
      var X;
      return (X = this.collector) == null ? void 0 : X.storage[this.viewId][i][n];
    });
    for (const n of c)
      if ((m = n == null ? void 0 : n.selectIds) != null && m.includes(s))
        return !1;
    return !0;
  }
  isNewEffectiveScene(d, l) {
    const { key: i } = d;
    return !!l.includes(i);
  }
  refreshPlugin(d, l = !1) {
    var m, n, X, G, L, o, h, p, r, V, W, y, t, e, Z, a, x, K, C, T, I;
    let i;
    const { scenePath: s } = d, c = d.data;
    if (!(!c || !this.collector))
      for (const J of c.values()) {
        const { dataType: F, data: R, key: S } = J, N = Object.keys(this.collector.storage[this.viewId][s]);
        switch (F) {
          case Id.Draw:
            if (i = l ? this.isDrawEffectiveScene(J, N) : this.isDeleteEffectiveScene(J, N, s), i)
              if (l && !Array.isArray(R)) {
                if ((m = R.updateNodeOpt) != null && m.useAnimation && (R.updateNodeOpt.useAnimation = !1), ((n = this.collector) == null ? void 0 : n.getLocalId(S)) === Il && ((X = this.collector) != null && X.isOwn(J.key))) {
                  const Q = R.selectIds;
                  if (Q) {
                    const P = N.filter((D) => {
                      var z, w;
                      return ((z = this.collector) == null ? void 0 : z.getLocalId(D)) === Il && !((w = this.collector) != null && w.isOwn(D));
                    }).map((D) => {
                      var z;
                      return (z = this.collector) == null ? void 0 : z.storage[this.viewId][s][D];
                    });
                    let j = !1;
                    for (const D of P)
                      for (let z = 0; z < Q.length; z++)
                        (G = D == null ? void 0 : D.selectIds) != null && G.includes(Q[z]) && (delete Q[z], j = !0);
                    j && (R.selectIds = Q.filter((D) => !!D));
                  }
                }
                (L = this.collector) == null || L.updateValue(J.key, R, { isAfterUpdate: !0, viewId: this.viewId, scenePath: s });
              } else
                !l && !Array.isArray(J.data) && ((o = this.collector) == null || o.updateValue(J.key, void 0, { isAfterUpdate: !0, viewId: this.viewId, scenePath: s }));
            break;
          case Id.Delete:
            if (i = l ? this.isDeleteEffectiveScene(J, N, s) : this.isDrawEffectiveScene(J, N), i) {
              if (l && !Array.isArray(R))
                (h = this.collector) == null || h.updateValue(S, void 0, { isAfterUpdate: !0, viewId: this.viewId, scenePath: s });
              else if (!l && !Array.isArray(R)) {
                if ((p = R.updateNodeOpt) != null && p.useAnimation && (R.updateNodeOpt.useAnimation = !1), ((r = this.collector) == null ? void 0 : r.getLocalId(J.key)) === Il && ((V = this.collector) != null && V.isOwn(J.key))) {
                  const Q = R.selectIds;
                  if (Q) {
                    const P = N.filter((D) => {
                      var z, w;
                      return ((z = this.collector) == null ? void 0 : z.getLocalId(D)) === Il && !((w = this.collector) != null && w.isOwn(D));
                    }).map((D) => {
                      var z;
                      return (z = this.collector) == null ? void 0 : z.storage[this.viewId][s][D];
                    });
                    let j = !1;
                    for (const D of P)
                      for (let z = 0; z < Q.length; z++)
                        (W = D == null ? void 0 : D.selectIds) != null && W.includes(Q[z]) && (delete Q[z], j = !0);
                    j && (R.selectIds = Q.filter((D) => !!D));
                  }
                }
                (y = this.collector) == null || y.updateValue(J.key, J.data, { isAfterUpdate: !0, viewId: this.viewId, scenePath: s });
              }
            }
            break;
          case Id.Update:
            if (i = l ? this.isNewEffectiveScene(J, N) : this.isOldEffectiveScene(J, N, s), i) {
              if (l && Array.isArray(R) && R.length === 2) {
                const Q = R[1];
                if ((t = Q.updateNodeOpt) != null && t.useAnimation && (Q.updateNodeOpt.useAnimation = !1), ((e = this.collector) == null ? void 0 : e.getLocalId(J.key)) === Il && ((Z = this.collector) != null && Z.isOwn(J.key))) {
                  const P = Q.selectIds;
                  if (P) {
                    const j = N.filter((z) => {
                      var w, A;
                      return ((w = this.collector) == null ? void 0 : w.getLocalId(z)) === Il && !((A = this.collector) != null && A.isOwn(z));
                    }).map((z) => {
                      var w;
                      return (w = this.collector) == null ? void 0 : w.storage[this.viewId][s][z];
                    });
                    let D = !1;
                    for (const z of j)
                      for (let w = 0; w < P.length; w++)
                        z != null && z.selectIds && ((a = z.selectIds) != null && a.includes(P[w])) && (delete P[w], D = !0);
                    D && (Q.selectIds = P.filter((z) => !!z));
                  }
                }
                (x = this.collector) == null || x.updateValue(S, Q, { isAfterUpdate: !0, viewId: this.viewId, scenePath: s });
              } else if (!l && Array.isArray(R) && R.length === 2) {
                const Q = R[0];
                if ((K = Q.updateNodeOpt) != null && K.useAnimation && (Q.updateNodeOpt.useAnimation = !1), ((C = this.collector) == null ? void 0 : C.getLocalId(J.key)) === Il && ((T = this.collector) != null && T.isOwn(J.key))) {
                  const P = Q.selectIds;
                  if (P) {
                    const j = N.filter((z) => {
                      var w, A;
                      return ((w = this.collector) == null ? void 0 : w.getLocalId(z)) === Il && !((A = this.collector) != null && A.isOwn(z));
                    }).map((z) => {
                      var w;
                      return (w = this.collector) == null ? void 0 : w.storage[this.viewId][s][z];
                    });
                    let D = !1;
                    for (const z of j)
                      for (let w = 0; w < P.length; w++)
                        z != null && z.selectIds && z.selectIds.includes(P[w]) && (delete P[w], D = !0);
                    D && (Q.selectIds = P.filter((z) => !!z));
                  }
                }
                (I = this.collector) == null || I.updateValue(J.key, Q, { isAfterUpdate: !0, viewId: this.viewId, scenePath: s });
              }
            }
            break;
        }
      }
  }
}
Object.defineProperty(Kd, "MaxStackLength", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 20
});
Object.defineProperty(Kd, "waitTime", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 100
});
class Ed {
  constructor(d) {
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "appViews", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
    const { control: l, internalMsgEmitter: i } = d;
    this.control = l, this.internalMsgEmitter = i, this.internalMsgEmitter.on("undoTickerStart", this.undoTickerStart.bind(this)), this.internalMsgEmitter.on("undoTickerEnd", this.undoTickerEnd.bind(this)), this.internalMsgEmitter.on("excludeIds", this.addExcludeIds.bind(this));
  }
  undoTickerStart(d, l) {
    const i = this.getView(l);
    i && i.displayer && i.focusScenePath && i.displayer.commiter.undoTickerStart(d, i.focusScenePath);
  }
  undoTickerEnd(d, l) {
    const i = this.getView(l);
    i && i.displayer && i.focusScenePath && i.displayer.commiter.undoTickerEnd(d, l, i.focusScenePath);
  }
  addExcludeIds(d, l) {
    const i = this.getView(l);
    i && i.displayer && i.focusScenePath && i.displayer.commiter.addExcludeIds(d);
  }
  undo() {
    const d = this.focuedView;
    let l = 0;
    if (d) {
      const i = d.focusScenePath;
      l = d.displayer.commiter.undo(i) || 0;
    }
    return l;
  }
  redo() {
    const d = this.focuedView;
    let l = 0;
    if (d) {
      const i = d.focusScenePath;
      l = d.displayer.commiter.redo(i) || 0;
    }
    return l;
  }
  validator(d, l, i) {
    const s = Ns(d[l]), c = Ns(i);
    if (l === "focusScenePath" && i && !ld(s, c) && this.control.internalSceneChange(d.id, c), l === "cameraOpt" && !ld(s, c)) {
      if (c.width !== (s == null ? void 0 : s.width) || c.height !== (s == null ? void 0 : s.height)) {
        const m = this.getView(l);
        m == null || m.displayer.updateSize();
      }
      this.control.internalCameraChange(d.id, c);
    }
  }
  destroyAppView(d) {
    const l = this.appViews.get(d);
    l && (this.control.textEditorManager.clear(d), l.displayer.destroy(), this.appViews.delete(d));
  }
  createMianView(d) {
    this.mainView = new Proxy(d, {
      set: (l, i, s) => (this.control.worker.isActive && this.validator(l, i, s), l[i] = s, !0)
    });
  }
  createAppView(d) {
    const l = d.id, i = new Proxy(d, {
      set: (s, c, m) => (this.control.worker.isActive && this.validator(s, c, m), s[c] = m, !0)
    });
    this.appViews.set(l, i);
  }
  isAppView(d) {
    return d !== bd.viewId && this.appViews.has(d);
  }
  getView(d) {
    var l;
    return d === bd.viewId ? this.mainView : (l = this.appViews) == null ? void 0 : l.get(d);
  }
  getCurScenePath(d) {
    const l = this.getView(d);
    if (l)
      return l.focusScenePath;
  }
  getAllViews() {
    return [this.mainView, ...this.appViews.values()];
  }
  setViewScenePath(d, l) {
    var i;
    if (d === bd.viewId && this.mainView)
      this.mainView.focusScenePath = l;
    else {
      const s = d && ((i = this.appViews) == null ? void 0 : i.get(d)) || void 0;
      s && (s.focusScenePath = l);
    }
  }
  setViewData(d, l) {
    var i;
    if (d === bd.viewId && this.mainView)
      this.mainView.viewData = l;
    else {
      const s = d && ((i = this.appViews) == null ? void 0 : i.get(d)) || void 0;
      s && (s.viewData = l);
    }
  }
  setFocuedViewId(d) {
    var l;
    this.focuedViewId = d, d === bd.viewId ? this.focuedView = this.mainView : this.focuedView = d && ((l = this.appViews) == null ? void 0 : l.get(d)) || void 0, this.control.cursor.onFocusViewChange();
  }
  setViewFocusScenePath(d, l) {
    var s;
    let i;
    d === bd.viewId ? i = this.mainView : i = (s = this.appViews) == null ? void 0 : s.get(d), i && (i.focusScenePath = l);
  }
  /** 销毁 */
  destroy() {
    var d;
    this.internalMsgEmitter.removeAllListeners("undoTickerStart"), this.internalMsgEmitter.removeAllListeners("undoTickerEnd"), this.internalMsgEmitter.removeAllListeners("excludeIds"), (d = this.mainView) == null || d.displayer.destroy(), this.appViews.forEach((l) => {
      l.displayer.destroy();
    });
  }
  /** 是否绘制浮动选框 */
  showFloatBar(d, l, i) {
    const s = this.getView(d), c = s == null ? void 0 : s.displayer.vDom;
    c && c.showFloatBar(l, i);
  }
  /** 激活浮动选框 */
  activeFloatBar(d) {
    var i;
    const l = (i = this.getView(d)) == null ? void 0 : i.displayer;
    l != null && l.vDom && l.vDom.setFloatZIndex(2);
  }
  /** 销毁浮动选框 */
  unActiveFloatBar(d) {
    const l = this.getView(d), i = l == null ? void 0 : l.displayer.vDom;
    i && i.setFloatZIndex(-1);
  }
  /** 激活刷新指针 */
  setActiveCursor(d, l) {
    const i = this.getView(d), s = i == null ? void 0 : i.displayer.vDom;
    s && s.setActiveCursor(l);
  }
  /** 激活刷新文字编辑器 */
  setActiveTextEditor(d, l) {
    const i = this.getView(d), s = i == null ? void 0 : i.displayer.vDom;
    s && s.setActiveTextEditor(l);
  }
}
Object.defineProperty(Ed, "defaultCameraOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    centerX: 0,
    centerY: 0,
    scale: 1
  }
});
Object.defineProperty(Ed, "defaultScreenCanvasOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    autoRender: !1,
    contextType: qd.Canvas2d
  }
});
Object.defineProperty(Ed, "defaultLayerOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    offscreen: !0,
    handleEvent: !1,
    depth: !1
  }
});
class LG {
  constructor(d, l, i) {
    Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "commiter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cacheCursorPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        if (c.button === 0 && this.viewId) {
          const m = this.getPoint(c);
          this.cachePoint = m, m && this.control.worker.originalEventLintener(ul.Start, m, this.viewId);
        }
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        if (this.viewId) {
          const m = this.getPoint(c);
          this.cachePoint = m, m && this.control.worker.originalEventLintener(ul.Doing, m, this.viewId);
        }
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        if (c.button === 0 && this.viewId) {
          const m = this.getPoint(c) || this.cachePoint;
          m && this.control.worker.originalEventLintener(ul.Done, m, this.viewId), this.cachePoint = void 0;
        }
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        if (this.viewId) {
          const m = this.getPoint(c);
          this.cachePoint = m, m && this.control.worker.originalEventLintener(ul.Start, m, this.viewId);
        }
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: El((c) => {
        if (this.viewId) {
          const m = this.getPoint(c);
          this.cachePoint = m, m && this.control.worker.originalEventLintener(ul.Doing, m, this.viewId);
        }
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        if (this.viewId) {
          const m = this.getPoint(c) || this.cachePoint;
          m && this.control.worker.originalEventLintener(ul.Done, m, this.viewId), this.cachePoint = void 0;
        }
      }
    }), Object.defineProperty(this, "cursorMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: El((c) => {
        const m = this.getPoint(c);
        this.cacheCursorPoint && ld(m, this.cacheCursorPoint) || !this.viewId || (this.cacheCursorPoint = m, m && this.control.worker.sendCursorEvent(m, this.viewId));
      }, 30, { leading: !1 })
    }), Object.defineProperty(this, "cursorMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: El(() => {
        this.viewId && (this.cacheCursorPoint = [void 0, void 0], this.control.worker.sendCursorEvent(this.cacheCursorPoint, this.viewId));
      }, 30, { leading: !1 })
    }), this.viewId = d, this.control = l, this.internalMsgEmitter = i;
    const s = {
      control: this.control,
      internalMsgEmitter: this.internalMsgEmitter,
      viewId: this.viewId
    };
    this.commiter = new Kd(s);
  }
  bindToolsClass() {
    var l, i;
    const d = (i = (l = this.control.worker) == null ? void 0 : l.currentToolsData) == null ? void 0 : i.toolsType;
    this.eventTragetElement && d && (this.eventTragetElement.className = `netless-whiteboard ${d === Gl.Text ? "cursor-text" : d === Gl.Pencil || d === Gl.LaserPen ? "cursor-pencil" : "cursor-arrow"}`);
  }
  mountView() {
    this.setCanvassStyle(), this.control.viewContainerManager.mountView(this.viewId);
  }
  reflashContainerOffset() {
    this.eventTragetElement && (this.containerOffset = this.getContainerOffset(this.eventTragetElement, { x: 0, y: 0 }));
  }
  updateSize() {
    this.setCanvassStyle(), this.reflashContainerOffset();
  }
  setViewId(d) {
    this.viewId = d;
  }
  destroy() {
    this.eventTragetElement && this.removeDisplayerEvent(this.eventTragetElement);
  }
  getPoint(d) {
    if (d instanceof TouchEvent) {
      const l = d.targetTouches[0] || d.changedTouches[0];
      if (l)
        return [l.pageX - this.containerOffset.x, l.pageY - this.containerOffset.y];
    }
    if ($l(d.pageX) && $l(d.pageY))
      return [d.pageX - this.containerOffset.x, d.pageY - this.containerOffset.y];
  }
  getTranslate(d) {
    const i = (d.style.WebkitTransform || getComputedStyle(d, "").getPropertyValue("-webkit-transform") || d.style.transform || getComputedStyle(d, "").getPropertyValue("transform")).match(/-?[0-9]+\.?[0-9]*/g), s = i && parseInt(i[0]) || 0, c = i && parseInt(i[1]) || 0;
    return [s, c];
  }
  getContainerOffset(d, l) {
    var c;
    const i = this.getTranslate(d);
    let s = {
      x: l.x + d.offsetLeft + i[0],
      y: l.y + d.offsetTop + i[1]
    };
    return (c = d.offsetParent) != null && c.nodeName && d.offsetParent.nodeName !== "BODY" && (s = this.getContainerOffset(d.offsetParent, s)), s;
  }
  bindDisplayerEvent(d) {
    d.addEventListener("mousedown", this.mousedown, !1), d.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("mouseleave", this.mouseup, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1), d.addEventListener("mousemove", this.cursorMouseMove, !1), d.addEventListener("mouseleave", this.cursorMouseLeave, !1);
  }
  removeDisplayerEvent(d) {
    d.removeEventListener("mousedown", this.mousedown), d.removeEventListener("touchstart", this.touchstart), window.removeEventListener("mouseleave", this.mouseup), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend), d.addEventListener("mousemove", this.cursorMouseMove), d.addEventListener("mouseleave", this.cursorMouseLeave);
  }
}
class bd {
  constructor(d, l) {
    Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mainView"
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "commiter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cacheCursorPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (s.button === 0) {
          this.reflashContainerOffset();
          const c = this.getPoint(s);
          this.cachePoint = c, c && this.control.worker.originalEventLintener(ul.Start, c, this.viewId);
        }
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const c = this.getPoint(s);
        this.cachePoint = c, c && this.control.worker.originalEventLintener(ul.Doing, c, this.viewId);
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (s.button === 0) {
          const c = this.getPoint(s) || this.cachePoint;
          c && this.control.worker.originalEventLintener(ul.Done, c, this.viewId), this.cachePoint = void 0;
        }
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.reflashContainerOffset();
        const c = this.getPoint(s);
        this.cachePoint = c, c && this.control.worker.originalEventLintener(ul.Start, c, this.viewId);
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: El((s) => {
        const c = this.getPoint(s);
        this.cachePoint = c, c && this.control.worker.originalEventLintener(ul.Doing, c, this.viewId);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const c = this.getPoint(s) || this.cachePoint;
        c && this.control.worker.originalEventLintener(ul.Done, c, this.viewId), this.cachePoint = void 0;
      }
    }), Object.defineProperty(this, "cursorMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: El((s) => {
        const c = this.getPoint(s);
        this.cacheCursorPoint && ld(c, this.cacheCursorPoint) || (this.cacheCursorPoint = c, c && this.control.worker.sendCursorEvent(c, this.viewId));
      }, 30, { leading: !1 })
    }), Object.defineProperty(this, "cursorMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: El(() => {
        this.cacheCursorPoint = [void 0, void 0], this.control.worker.sendCursorEvent(this.cacheCursorPoint, this.viewId);
      }, 30, { leading: !1 })
    }), this.control = d, this.internalMsgEmitter = l;
    const i = {
      control: this.control,
      internalMsgEmitter: this.internalMsgEmitter,
      viewId: this.viewId
    };
    this.commiter = new Kd(i);
  }
  bindToolsClass() {
    var l, i;
    const d = (i = (l = this.control.worker) == null ? void 0 : l.currentToolsData) == null ? void 0 : i.toolsType;
    this.eventTragetElement && d && (this.eventTragetElement.className = `netless-whiteboard ${d === Gl.Text ? "cursor-text" : d === Gl.Pencil || d === Gl.LaserPen ? "cursor-pencil" : "cursor-arrow"}`);
  }
  mountView() {
    this.setCanvassStyle(), this.control.viewContainerManager.mountView(this.viewId);
  }
  updateSize() {
    this.setCanvassStyle();
  }
  reflashContainerOffset() {
    this.eventTragetElement && (this.containerOffset = this.getContainerOffset(this.eventTragetElement, { x: 0, y: 0 }));
  }
  destroy() {
    this.eventTragetElement && this.removeDisplayerEvent(this.eventTragetElement), this.vDom = void 0;
  }
  getPoint(d) {
    if (d instanceof TouchEvent) {
      const l = d.targetTouches[0] || d.changedTouches[0];
      if (l)
        return [l.pageX - this.containerOffset.x, l.pageY - this.containerOffset.y];
    }
    if ($l(d.pageX) && $l(d.pageY))
      return [d.pageX - this.containerOffset.x, d.pageY - this.containerOffset.y];
  }
  getTranslate(d) {
    const i = (d.style.WebkitTransform || getComputedStyle(d, "").getPropertyValue("-webkit-transform") || d.style.transform || getComputedStyle(d, "").getPropertyValue("transform")).match(/-?[0-9]+\.?[0-9]*/g), s = i && parseInt(i[0]) || 0, c = i && parseInt(i[1]) || 0;
    return [s, c];
  }
  getContainerOffset(d, l) {
    var c;
    const i = this.getTranslate(d);
    let s = {
      x: l.x + d.offsetLeft + i[0],
      y: l.y + d.offsetTop + i[1]
    };
    return (c = d.offsetParent) != null && c.nodeName && d.offsetParent.nodeName !== "BODY" && (s = this.getContainerOffset(d.offsetParent, s)), s;
  }
  bindDisplayerEvent(d) {
    d.addEventListener("mousedown", this.mousedown, !1), d.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("mouseleave", this.mouseup, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1), d.addEventListener("mousemove", this.cursorMouseMove, !1), d.addEventListener("mouseleave", this.cursorMouseLeave, !1);
  }
  removeDisplayerEvent(d) {
    d.removeEventListener("mousedown", this.mousedown), d.removeEventListener("touchstart", this.touchstart), window.removeEventListener("mouseleave", this.mouseup), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend), d.addEventListener("mousemove", this.cursorMouseMove), d.addEventListener("mouseleave", this.cursorMouseLeave);
  }
}
Object.defineProperty(bd, "viewId", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "mainView"
});
const IG = "index-module__Container__nLsM3", YG = "index-module__CanvasBox__j2Xe-", xG = "index-module__FloatCanvas__d1YR7", rG = "index-module__FloatBar__cm-EL", RG = "index-module__RotateBtn__HSSkf", SG = "index-module__ResizeBtn__yjvda", KG = "index-module__CursorBox__2UHvI", CG = "index-module__TextEditorContainer__Qm8KC", JG = "index-module__ResizeTowBox__HOllX", Vd = {
  Container: IG,
  CanvasBox: YG,
  FloatCanvas: xG,
  FloatBar: rG,
  RotateBtn: RG,
  ResizeBtn: SG,
  CursorBox: KG,
  TextEditorContainer: CG,
  ResizeTowBox: JG
}, TG = {
  delete: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDZ2NmEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2aDBtMS0yYTIgMiAwIDAgMSAyLTJoMmEyIDIgMCAwIDEgMiAyaDBNMyA0aDEwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  duplicate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0xMSAySDZhMSAxIDAgMCAwLTEgMXY4YTEgMSAwIDAgMCAxIDFoNmExIDEgMCAwIDAgMS0xVjRoMGwtMi0yeiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTExIDJ2MWExIDEgMCAwIDAgMSAxaDFsLTItMnoiLz48cGF0aCBkPSJNOSAxNEg0YTEgMSAwIDAgMS0xLTFWNWgwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9zdmc+",
  "layer-pressed": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzMzODFGRiIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  layer: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  rotate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTEzIDZhNiA2IDAgMSAxLTMuNzA5IDEuMjgzIi8+PHBhdGggZD0ibTEzIDYgMS40MTQgMi40NUwxMyA2bDIuNDUtMS40MTQiLz48L2c+PC9zdmc+",
  "rotation-button": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  rotation: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBmaWxsPSIjRkZGIiBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  "font-colors-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "font-colors": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "to-bottom": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDEwdjhtMCAwLTItMm0yIDIgMi0ybS00IDZoMTJtLTYtNGg2bS02LTRoNm0tNi00aDYiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  "to-top": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDIydi04bTAgMC0yIDJtMi0yIDIgMm0tNC02aDEybS02IDRoNm0tNiA0aDZtLTYgNGg2IiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  "bold-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQuNSAySDhhMi41IDIuNSAwIDAgMSAwIDVINS41aDBtLTEgMGg0YTMgMyAwIDAgMSAwIDZoLTQgMG0wIDFWMiIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  bold: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQuNSAySDhhMi41IDIuNSAwIDAgMSAwIDVINS41aDBtLTEgMGg0YTMgMyAwIDAgMSAwIDZoLTQgMG0wIDFWMiIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "underline-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDJ2NWE0IDQgMCAxIDEtOCAwVjJoME0zIDE0aDEwIiBzdHJva2U9IiMzMzgxRkYiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  underline: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDJ2NWE0IDQgMCAxIDEtOCAwVjJoME0zIDE0aDEwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  "line-through-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQgOGg4bS0xLTNhMyAzIDAgMCAwLTMtM2gtLjkzOEEyLjY0IDIuNjQgMCAwIDAgNC41IDRhMi41NyAyLjU3IDAgMCAwIDEuMzQ0IDIuOTIybDQuMzEyIDIuMTU2QTIuNTcgMi41NyAwIDAgMSAxMS41IDEyYTIuNjQgMi42NCAwIDAgMS0yLjU2MiAySDdhMyAzIDAgMCAxLTMtM2gwIiBzdHJva2U9IiMzMzgxRkYiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  "line-through": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQgOGg4bS0xLTNhMyAzIDAgMCAwLTMtM2gtLjkzOEEyLjY0IDIuNjQgMCAwIDAgNC41IDRhMi41NyAyLjU3IDAgMCAwIDEuMzQ0IDIuOTIybDQuMzEyIDIuMTU2QTIuNTcgMi41NyAwIDAgMSAxMS41IDEyYTIuNjQgMi42NCAwIDAgMS0yLjU2MiAySDdhMyAzIDAgMCAxLTMtM2gwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  "italic-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcgMTQgOSAyTTUgMTRoNE03IDJoNCIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  italic: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcgMTQgOSAyTTUgMTRoNE03IDJoNCIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4="
};
function Zd(b) {
  return TG[b];
}
const FG = (b) => {
  const { workIds: d, maranger: l } = b;
  return nl.createElement(
    "div",
    { className: "button normal-button", onClick: (i) => {
      i.preventDefault(), i.stopPropagation(), Cl.emitMethod(Sl.MainEngine, hl.DeleteNode, { workIds: d || [Il], viewId: l.viewId });
    }, onTouchEnd: (i) => {
      i.stopPropagation(), Cl.emitMethod(Sl.MainEngine, hl.DeleteNode, { workIds: d || [Il], viewId: l.viewId });
    } },
    nl.createElement("img", { alt: "icon", src: Zd("delete") })
  );
}, NG = (b) => {
  const { workIds: d, viewId: l } = b;
  return nl.createElement(
    "div",
    { className: "button normal-button", onClick: (i) => {
      i.preventDefault(), i.stopPropagation(), Cl.emitMethod(Sl.MainEngine, hl.CopyNode, { workIds: d || [Il], viewId: l });
    }, onTouchEnd: (i) => {
      i.stopPropagation(), Cl.emitMethod(Sl.MainEngine, hl.CopyNode, { workIds: d || [Il], viewId: l });
    } },
    nl.createElement("img", { alt: "icon", src: Zd("duplicate") })
  );
}, Hs = (b) => {
  const { icon: d, onClickHandler: l, onTouchEndHandler: i } = b;
  return nl.createElement(
    "div",
    { className: "button normal-button", onClick: l, onTouchEnd: i },
    nl.createElement("img", { src: Zd(d) })
  );
}, HG = (b) => {
  const { open: d, setOpen: l } = b, { floatBarData: i, maranger: s, position: c } = id(dd), [m, n] = Hl([]), X = kl(() => d ? nl.createElement(
    "div",
    { className: "image-layer-menu", style: c && c.y < 80 ? {
      top: "inherit",
      bottom: "50px"
    } : void 0 },
    nl.createElement(Hs, { icon: "to-top", onClickHandler: (o) => {
      o.preventDefault(), o.stopPropagation(), Cl.emitMethod(Sl.MainEngine, hl.ZIndexNode, { workIds: [Il], layer: Rd.Top, viewId: s == null ? void 0 : s.viewId });
    }, onTouchEndHandler: (o) => {
      o.stopPropagation(), Cl.emitMethod(Sl.MainEngine, hl.ZIndexNode, { workIds: [Il], layer: Rd.Top, viewId: s == null ? void 0 : s.viewId });
    } }),
    nl.createElement(Hs, { icon: "to-bottom", onClickHandler: (o) => {
      o.preventDefault(), o.stopPropagation(), Cl.emitMethod(Sl.MainEngine, hl.ZIndexNode, { workIds: [Il], layer: Rd.Bottom, viewId: s == null ? void 0 : s.viewId });
    }, onTouchEndHandler: (o) => {
      o.stopPropagation(), Cl.emitMethod(Sl.MainEngine, hl.ZIndexNode, { workIds: [Il], layer: Rd.Bottom, viewId: s == null ? void 0 : s.viewId });
    } })
  ) : null, [d, c]), G = (o) => {
    o.preventDefault(), o.stopPropagation(), o.nativeEvent.stopImmediatePropagation();
    const h = !d;
    l(h), h && Cl.emitMethod(Sl.MainEngine, hl.ZIndexActive, { workId: Il, isActive: h });
  }, L = (o) => {
    o.stopPropagation(), o.nativeEvent.stopImmediatePropagation();
    const h = !d;
    l(h), Cl.emitMethod(Sl.MainEngine, hl.ZIndexActive, { workId: Il, isActive: h });
  };
  return _l(() => {
    ld(i == null ? void 0 : i.selectIds, m) || i != null && i.selectIds && !ld(i == null ? void 0 : i.selectIds, m) && (n(i == null ? void 0 : i.selectIds), l(!1));
  }, [d, i, m, l]), _l(() => () => {
    d && Cl.emitMethod(Sl.MainEngine, hl.ZIndexActive, { workId: Il, isActive: !1 });
  }, [d]), nl.createElement(
    "div",
    { className: `button normal-button ${d && "active"}`, onClick: G, onTouchEnd: L },
    X,
    nl.createElement("img", { alt: "icon", src: Zd(d ? "layer-pressed" : "layer") })
  );
}, gG = (b) => {
  const { activeColor: d, onClickHandler: l, onTouchEndHandler: i } = b;
  return nl.createElement(
    "div",
    { className: `font-color-button ${d === "transparent" ? "active" : ""}`, onClick: l, onTouchEnd: i },
    nl.createElement("div", { className: "circle none" })
  );
}, Mi = (b) => {
  const { color: d, activeColor: l, onClickHandler: i, onTouchEndHandler: s } = b;
  return nl.createElement(
    "div",
    { className: `font-color-button ${d === l ? "active" : ""}`, onClick: i, onTouchEnd: s },
    nl.createElement("div", { className: "circle", style: { backgroundColor: ql(d, 1) } })
  );
}, ki = (b) => {
  const { opacity: d, activeColor: l, setCurOpacity: i } = b, [s, c] = Hl({ x: 108, y: 0 });
  if (_l(() => {
    c({ x: d * 100 + 8, y: 0 });
  }, []), !l)
    return null;
  const m = El((G, L) => {
    G.preventDefault(), G.stopPropagation(), L.x !== (s == null ? void 0 : s.x) && c({ x: L.x, y: 0 });
    const o = Math.min(Math.max(L.x - 8, 0), 100) / 100;
    d !== o && i(o, l, ul.Doing);
  }, 100, { leading: !1 }), n = (G) => {
    G.preventDefault(), G.stopPropagation(), i(d, l, ul.Start);
  }, X = El((G, L) => {
    G.preventDefault(), G.stopPropagation(), L.x !== (s == null ? void 0 : s.x) && c({ x: L.x, y: 0 });
    const o = Math.min(Math.max(L.x - 8, 0), 100) / 100;
    i(o, l, ul.Done);
  }, 100, { leading: !1 });
  return nl.createElement(
    "div",
    { className: "font-color-opacity", style: { marginLeft: "10px" } },
    nl.createElement("div", { className: "range-color", style: {
      background: `linear-gradient(to right, ${ql(l, 0)}, ${ql(l, 1)})`
    } }),
    nl.createElement(
      "div",
      { className: "range-opacity" },
      nl.createElement(
        ii,
        { bounds: "parent", axis: "x", position: s, onDrag: m, onStart: n, onStop: X },
        nl.createElement("div", { className: "circle", style: {
          backgroundColor: ql(l, d)
        } })
      )
    )
  );
}, zG = (b) => {
  const { open: d, setOpen: l } = b, { floatBarData: i, floatBarColors: s, maranger: c, position: m, setFloatBarData: n } = id(dd), [X, G] = Hl(), [L, o] = Hl(1);
  _l(() => {
    if (i != null && i.strokeColor) {
      const [V, W] = zi(i.strokeColor);
      G(V), o(W);
    }
  }, [i]);
  const h = kl(() => nl.createElement(ki, { key: "strokeColors", opacity: L, activeColor: X, setCurOpacity: (V, W, y) => {
    y === ul.Start && (c != null && c.control.room) && (c.control.room.disableDeviceInputs = !0), y === ul.Done && (c != null && c.control.room) && (c.control.room.disableDeviceInputs = !1), o(V);
    const t = ql(W, V);
    i != null && i.strokeColor && (i.strokeColor = t, n({ strokeColor: t })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: [Il], strokeColor: t, workState: y, viewId: c == null ? void 0 : c.viewId });
  } }), [L, X, c == null ? void 0 : c.control.room, c == null ? void 0 : c.viewId, i, n]), p = kl(() => d ? nl.createElement(
    "div",
    { className: "font-colors-menu", style: m && m.y < 80 ? {
      top: "inherit",
      bottom: "50px"
    } : void 0, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    } },
    s.concat().map((V, W) => {
      const y = ei(...V);
      return nl.createElement(Mi, { key: W, color: y, activeColor: X, onTouchEndHandler: (t) => {
        t.stopPropagation(), G(y);
        const e = ql(y, L);
        i != null && i.strokeColor && (i.strokeColor = e, n({ strokeColor: e })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: [Il], strokeColor: e, viewId: c == null ? void 0 : c.viewId });
      }, onClickHandler: (t) => {
        t.preventDefault(), t.stopPropagation(), G(y);
        const e = ql(y, L);
        i != null && i.strokeColor && (i.strokeColor = e, n({ strokeColor: e })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: [Il], strokeColor: e, viewId: c == null ? void 0 : c.viewId });
      } });
    }),
    h
  ) : null, [d, m, s, h, X, L, i, c == null ? void 0 : c.viewId, n]), r = kl(() => X ? nl.createElement(
    "div",
    { className: "color-bar-ring", style: { backgroundColor: ql(X, L) } },
    nl.createElement("div", { className: "circle" })
  ) : null, [X, L]);
  return nl.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${d && "active"}`, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    } },
    r,
    p
  );
}, MG = (b) => {
  const { open: d, setOpen: l } = b, { floatBarData: i, floatBarColors: s, maranger: c, position: m, setFloatBarData: n } = id(dd), [X, G] = Hl(), [L, o] = Hl(1);
  _l(() => {
    if (i != null && i.fillColor) {
      const [V, W] = (i == null ? void 0 : i.fillColor) === "transparent" && ["transparent", 0] || zi(i.fillColor);
      G(V), o(W);
    }
  }, [i]);
  const h = kl(() => X && X !== "transparent" ? nl.createElement(ki, { key: "fillColors", opacity: L || 0, activeColor: X, setCurOpacity: (V, W, y) => {
    y === ul.Start && (c != null && c.control.room) && (c.control.room.disableDeviceInputs = !0), y === ul.Done && (c != null && c.control.room) && (c.control.room.disableDeviceInputs = !1), o(V);
    const t = ql(W, V);
    i != null && i.fillColor && (i.fillColor = t, n({ fillColor: t })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: [Il], fillColor: X && ql(W, V), workState: y, viewId: c == null ? void 0 : c.viewId });
  } }) : null, [X, L, c == null ? void 0 : c.control.room, c == null ? void 0 : c.viewId, i, n]), p = kl(() => d ? nl.createElement(
    "div",
    { className: "font-colors-menu", style: m && m.y < 80 ? {
      top: "inherit",
      bottom: "50px"
    } : void 0, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    } },
    nl.createElement(gG, { activeColor: X, onTouchEndHandler: (V) => {
      V.stopPropagation(), G("transparent");
      const W = "transparent";
      i != null && i.fillColor && (i.fillColor = W, n({ fillColor: W })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: [Il], fillColor: W, viewId: c == null ? void 0 : c.viewId });
    }, onClickHandler: (V) => {
      V.preventDefault(), V.stopPropagation(), G("transparent");
      const W = "transparent";
      i != null && i.fillColor && (i.fillColor = W, n({ fillColor: W })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: [Il], fillColor: W, viewId: c == null ? void 0 : c.viewId });
    } }),
    s.map((V, W) => {
      const y = ei(...V);
      return nl.createElement(Mi, { key: W, color: y, activeColor: X, onTouchEndHandler: (t) => {
        t.stopPropagation(), G(y);
        const e = ql(y, L);
        i != null && i.fillColor && (i.fillColor = e, n({ fillColor: e })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: [Il], fillColor: e, viewId: c == null ? void 0 : c.viewId });
      }, onClickHandler: (t) => {
        t.preventDefault(), t.stopPropagation(), G(y);
        const e = ql(y, L);
        i != null && i.fillColor && (i.fillColor = e, n({ fillColor: e })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: [Il], fillColor: e, viewId: c == null ? void 0 : c.viewId });
      } });
    }),
    h
  ) : null, [d, m, X, s, h, i, c == null ? void 0 : c.viewId, n, L]), r = kl(() => {
    const V = X && X !== "transparent" && ql(X, L) || "transparent";
    return nl.createElement(
      "div",
      { className: "color-bar-fill" },
      nl.createElement("div", { className: "circle", style: { backgroundColor: V } })
    );
  }, [X, L]);
  return nl.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${d && "active"}`, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    } },
    r,
    p
  );
}, kG = (b) => {
  const { open: d, setOpen: l, textOpt: i, workIds: s } = b, { floatBarColors: c, maranger: m, position: n, setFloatBarData: X, floatBarData: G } = id(dd), [L, o] = Hl(), [h, p] = Hl(1);
  _l(() => {
    if (i != null && i.fontColor) {
      const [y, t] = (i == null ? void 0 : i.fontColor) === "transparent" && ["transparent", 0] || zi(i.fontColor);
      o(y), p(t);
    }
  }, [i == null ? void 0 : i.fontColor]);
  const r = kl(() => L && L !== "transparent" ? nl.createElement(ki, { key: "fontColors", opacity: h, activeColor: L, setCurOpacity: (y, t, e) => {
    e === ul.Start && (m != null && m.control.room) && (m.control.room.disableDeviceInputs = !0), e === ul.Done && (m != null && m.control.room) && (m.control.room.disableDeviceInputs = !1), p(y);
    const Z = ql(t, y);
    G != null && G.textOpt && (G.textOpt.fontColor = Z, X({ textOpt: G.textOpt })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, {
      workIds: s || [Il],
      fontColor: L && Z,
      workState: e,
      viewId: m == null ? void 0 : m.viewId
    });
  } }) : null, [L, h, m == null ? void 0 : m.control.room, m == null ? void 0 : m.viewId, G == null ? void 0 : G.textOpt, s, X]), V = kl(() => d ? nl.createElement(
    "div",
    { className: "font-colors-menu", style: n && n.y < 80 ? {
      top: "inherit",
      bottom: "50px"
    } : void 0, onTouchEnd: (y) => {
      y.stopPropagation(), y.nativeEvent.stopImmediatePropagation();
    }, onClick: (y) => {
      y.preventDefault(), y.stopPropagation(), y.nativeEvent.stopImmediatePropagation();
    } },
    c.map((y, t) => {
      const e = ei(...y);
      return nl.createElement(Mi, { key: t, color: e, activeColor: L, onTouchEndHandler: (Z) => {
        Z.stopPropagation(), o(e);
        const a = ql(e, h);
        G != null && G.textOpt && (G.textOpt.fontColor = a, X({ textOpt: G.textOpt })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: s || [Il], fontColor: a, viewId: m == null ? void 0 : m.viewId });
      }, onClickHandler: (Z) => {
        Z.preventDefault(), Z.stopPropagation(), o(e);
        const a = ql(e, h);
        G != null && G.textOpt && (G.textOpt.fontColor = a, X({ textOpt: G.textOpt })), Cl.emitMethod(Sl.MainEngine, hl.SetColorNode, { workIds: s || [Il], fontColor: a, viewId: m == null ? void 0 : m.viewId });
      } });
    }),
    r
  ) : null, [d, n, c, r, L, h, G == null ? void 0 : G.textOpt, s, m == null ? void 0 : m.viewId, X]), W = kl(() => {
    const y = L && L !== "transparent" && ql(L, h) || "transparent";
    return nl.createElement(
      "div",
      { className: "color-bar" },
      nl.createElement("div", { className: "color-bar-color", style: { backgroundColor: y } })
    );
  }, [L, h]);
  return nl.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${d && "active"}`, onTouchEnd: (y) => {
      y.stopPropagation(), y.nativeEvent.stopImmediatePropagation(), l(!d);
    }, onClick: (y) => {
      y.preventDefault(), y.stopPropagation(), y.nativeEvent.stopImmediatePropagation(), l(!d);
    } },
    nl.createElement("img", { alt: "icon", src: Zd("font-colors") }),
    W,
    V
  );
}, vG = (b) => {
  const { bold: d, setBold: l, workIds: i, viewId: s } = b, c = (m) => {
    const n = d === "bold" ? "normal" : "bold";
    m == null || m.preventDefault(), m == null || m.stopPropagation(), l(n), Cl.emitMethod(Sl.MainEngine, hl.SetFontStyle, { workIds: i, viewId: s, bold: n });
  };
  return nl.createElement(
    "div",
    { className: "font-style-button", onClick: c, onTouchEnd: c },
    nl.createElement("img", { alt: "icon", src: Zd(d === "bold" ? "bold-active" : "bold") })
  );
}, UG = (b) => {
  const { underline: d, setUnderline: l, workIds: i, viewId: s } = b, c = (m) => {
    const n = !d;
    m == null || m.preventDefault(), m == null || m.stopPropagation(), l(n), Cl.emitMethod(Sl.MainEngine, hl.SetFontStyle, { workIds: i, viewId: s, underline: n });
  };
  return nl.createElement(
    "div",
    { className: "font-style-button", onClick: c, onTouchEnd: c },
    nl.createElement("img", { alt: "icon", src: Zd(d ? "underline-active" : "underline") })
  );
}, QG = (b) => {
  const { lineThrough: d, setLineThrough: l, workIds: i, viewId: s } = b, c = (m) => {
    const n = !d;
    m == null || m.preventDefault(), m == null || m.stopPropagation(), l(n), Cl.emitMethod(Sl.MainEngine, hl.SetFontStyle, { workIds: i, viewId: s, lineThrough: n });
  };
  return nl.createElement(
    "div",
    { className: "font-style-button", onClick: c, onTouchEnd: c },
    nl.createElement("img", { alt: "icon", src: Zd(d ? "line-through-active" : "line-through") })
  );
}, wG = (b) => {
  const { italic: d, setItalic: l, workIds: i, viewId: s } = b, c = (m) => {
    const n = d === "italic" ? "normal" : "italic";
    m == null || m.preventDefault(), m == null || m.stopPropagation(), l(n), Cl.emitMethod(Sl.MainEngine, hl.SetFontStyle, { workIds: i, viewId: s, italic: n });
  };
  return nl.createElement(
    "div",
    { className: "font-style-button", onClick: c, onTouchEnd: c },
    nl.createElement("img", { alt: "icon", src: Zd(d === "italic" ? "italic-active" : "italic") })
  );
}, PG = (b) => {
  const { open: d, setOpen: l, textOpt: i, workIds: s } = b, { position: c, maranger: m } = id(dd), [n, X] = Hl("normal"), [G, L] = Hl("normal"), [o, h] = Hl(!1), [p, r] = Hl(!1);
  _l(() => {
    i != null && i.bold && X(i.bold), Fd(i == null ? void 0 : i.underline) && h(i.underline), Fd(i == null ? void 0 : i.lineThrough) && r(i.lineThrough), i != null && i.italic && L(i.italic);
  }, [i]);
  const V = kl(() => d ? nl.createElement(
    "div",
    { className: "font-style-menu", style: c && c.y < 80 ? {
      top: "inherit",
      bottom: "50px"
    } : void 0, onTouchEnd: (W) => {
      W.stopPropagation(), W.nativeEvent.stopImmediatePropagation();
    }, onClick: (W) => {
      W.preventDefault(), W.stopPropagation(), W.nativeEvent.stopImmediatePropagation();
    } },
    nl.createElement(vG, { workIds: s || [Il], bold: n, setBold: X, viewId: m == null ? void 0 : m.viewId }),
    nl.createElement(UG, { workIds: s || [Il], underline: o, setUnderline: h, viewId: m == null ? void 0 : m.viewId }),
    nl.createElement(QG, { workIds: s || [Il], lineThrough: p, setLineThrough: r, viewId: m == null ? void 0 : m.viewId }),
    nl.createElement(wG, { workIds: s || [Il], italic: G, setItalic: L, viewId: m == null ? void 0 : m.viewId })
  ) : null, [d, c, s, n, m == null ? void 0 : m.viewId, o, p, G]);
  return nl.createElement(
    "div",
    { className: `button normal-button ${d && "active"}`, onTouchEnd: (W) => {
      W.stopPropagation(), W.nativeEvent.stopImmediatePropagation(), l(!d);
    }, onClick: (W) => {
      W.preventDefault(), W.stopPropagation(), W.nativeEvent.stopImmediatePropagation(), l(!d);
    } },
    nl.createElement("img", { alt: "icon", src: Zd("bold") }),
    V
  );
}, cd = Object.freeze([
  12,
  14,
  18,
  24,
  36,
  48,
  64,
  80,
  144,
  288
]), fG = (b) => {
  const { position: d, onClickHandler: l } = b;
  return nl.createElement("div", { className: "font-size-menu", style: d && d.y < 80 ? {
    top: "inherit",
    bottom: "50px"
  } : void 0, onTouchEnd: (i) => {
    i.stopPropagation(), i.nativeEvent.stopImmediatePropagation();
  }, onClick: (i) => {
    i.preventDefault(), i.stopPropagation(), i.nativeEvent.stopImmediatePropagation();
  } }, cd.map((i) => nl.createElement("div", { className: "font-size-btn", key: i, onClick: () => {
    l(i);
  }, onTouchEnd: () => {
    l(i);
  } }, i)));
}, EG = (b) => {
  const d = Yi(null), { open: l, setOpen: i, textOpt: s, workIds: c } = b, { position: m, maranger: n } = id(dd), [X, G] = Hl(0), L = cd.length - 1;
  _l(() => {
    s != null && s.fontSize && (G(s.fontSize), d.current && (d.current.value = s.fontSize.toString()));
  }, [s == null ? void 0 : s.fontSize]), _l(() => {
    X && X !== (s == null ? void 0 : s.fontSize) && X >= cd[0] && X <= cd[L] && (d.current && (d.current.value = X.toString()), Cl.emitMethod(Sl.MainEngine, hl.SetFontStyle, {
      workIds: c || [Il],
      fontSize: X,
      viewId: n == null ? void 0 : n.viewId
    }));
  }, [n == null ? void 0 : n.viewId, X, s == null ? void 0 : s.fontSize, c]);
  const o = (r) => {
    var V;
    G(r), i(!1), (V = d.current) == null || V.blur();
  }, h = kl(() => l ? nl.createElement(fG, { onClickHandler: o, position: m }) : null, [l, o, m]), p = (r) => {
    r > cd[L] && (r = cd[L]), r < cd[0] && (r = cd[0]), G(r);
  };
  return nl.createElement(
    "div",
    { className: "button normal-button font-size-barBtn", style: { width: 50 }, onTouchEnd: (r) => {
      r.stopPropagation(), r.nativeEvent.stopImmediatePropagation();
    }, onClick: (r) => {
      r.preventDefault(), r.stopPropagation(), r.nativeEvent.stopImmediatePropagation();
    } },
    nl.createElement("input", { className: "font-size-input", ref: d, onTouchEnd: () => {
      d.current && d.current.focus();
    }, onClick: () => {
      i(!0), d.current && d.current.focus();
    }, onKeyDown: (r) => {
      if (r.key === "Backspace") {
        const V = window.getSelection(), W = V == null ? void 0 : V.getRangeAt(0);
        if (W != null && W.collapsed)
          return r.preventDefault(), document.execCommand("delete", !1), !1;
      }
    }, onKeyUp: () => {
      if (d.current) {
        const r = d.current.value, V = parseInt(r);
        isNaN(V) ? d.current.value = "0" : d.current.value = V.toString();
      }
    }, onChange: (r) => {
      const V = r.target.value, W = parseInt(V);
      W && G(W);
    } }),
    nl.createElement(
      "div",
      { className: "font-size-btns" },
      nl.createElement("div", { className: "font-size-add", onClick: () => {
        p(X + cd[0]);
      }, onTouchEnd: () => {
        p(X + cd[0]);
      } }),
      nl.createElement("div", { className: "font-size-cut", onClick: () => {
        p(X - cd[0]);
      }, onTouchEnd: () => {
        p(X - cd[0]);
      } })
    ),
    h
  );
};
var Pl;
(function(b) {
  b[b.none = 0] = "none", b[b.Layer = 1] = "Layer", b[b.StrokeColor = 2] = "StrokeColor", b[b.FillColor = 3] = "FillColor", b[b.TextColor = 4] = "TextColor", b[b.TextBgColor = 5] = "TextBgColor", b[b.FontStyle = 6] = "FontStyle", b[b.FontSize = 7] = "FontSize";
})(Pl || (Pl = {}));
const Vt = nl.memo((b) => {
  const { textOpt: d, workIds: l, noLayer: i, position: s } = b, { floatBarData: c, maranger: m } = id(dd), [n, X] = nl.useState(Pl.none), G = kl(() => c != null && c.fillColor ? nl.createElement(MG, { open: n === Pl.FillColor, setOpen: (V) => {
    X(V === !0 ? Pl.FillColor : Pl.none);
  } }) : null, [c == null ? void 0 : c.fillColor, n]), L = kl(() => c != null && c.strokeColor ? nl.createElement(zG, { open: n === Pl.StrokeColor, setOpen: (V) => {
    X(V === !0 ? Pl.StrokeColor : Pl.none);
  } }) : null, [c == null ? void 0 : c.strokeColor, n]), o = kl(() => d != null && d.fontColor && (m != null && m.viewId) ? nl.createElement(kG, { open: n === Pl.TextColor, setOpen: (V) => {
    X(V === !0 ? Pl.TextColor : Pl.none);
  }, textOpt: d, workIds: l }) : null, [d, n, l, m]), h = kl(() => d && (m != null && m.viewId) ? nl.createElement(PG, { open: n === Pl.FontStyle, setOpen: (V) => {
    X(V === !0 ? Pl.FontStyle : Pl.none);
  }, textOpt: d, workIds: l }) : null, [d, n, l, m]), p = kl(() => d && (m != null && m.viewId) ? nl.createElement(EG, { open: n === Pl.FontSize, setOpen: (V) => {
    X(V === !0 ? Pl.FontSize : Pl.none);
  }, textOpt: d, workIds: l }) : null, [d, n, l, m]), r = kl(() => i ? null : nl.createElement(HG, { open: n === Pl.Layer, setOpen: (V) => {
    X(V === !0 ? Pl.Layer : Pl.none);
  } }), [i, n]);
  return nl.createElement(
    "div",
    { className: "bezier-pencil-plugin-floatbtns", style: s && s.y < 80 ? {
      bottom: "-120px"
    } : void 0 },
    m && nl.createElement(FG, { workIds: l, maranger: m }),
    r,
    !!(m != null && m.viewId) && nl.createElement(NG, { workIds: l, viewId: m.viewId }),
    p,
    h,
    o,
    L,
    G
  );
}), BG = (b) => {
  const { data: d } = b, { opt: l, scale: i, translate: s, x: c, y: m } = d, n = `scale(${i || 1}) ${s && "translate(" + s[0] + "px," + s[1] + "px)" || ""}`, { fontSize: X, fontFamily: G, underline: L, fontColor: o, lineThrough: h, textAlign: p, strokeColor: r, lineHeight: V, workState: W, bold: y, italic: t } = l, e = X, Z = V || e * 1.2, a = {
    fontSize: `${e}px`,
    lineHeight: `${Z}px`,
    color: o,
    borderColor: r,
    minHeight: `${Z}px`
  };
  G && (a.fontFamily = `${G}`), (h || L) && (a.textDecoration = `${h && "line-through" || ""}${L && " underline" || ""}`), y && (a.fontWeight = `${y}`), t && (a.fontStyle = `${t}`), p && (a.textAlign = `${p}`);
  let x = "";
  return l != null && l.text && (x = l.text.split(",").reduce((C, T, I) => {
    const J = T === "" ? "<br/>" : T;
    return I === 0 ? J : `${C}<div>${J}</div>`;
  }, "")), nl.createElement(
    "div",
    { className: "editor-box", style: {
      left: `${c}px`,
      top: `${m}px`,
      transform: n,
      transformOrigin: "left top",
      pointerEvents: "none"
    } },
    nl.createElement("div", { className: `editor ${W !== ul.Start && W !== ul.Doing ? "readOnly" : ""}`, style: a, dangerouslySetInnerHTML: { __html: x } })
  );
}, jG = nl.memo((b) => {
  const { data: d, position: l, workId: i, selectIds: s } = b, [c, m] = Hl([0, 0]), { opt: n, scale: X, translate: G, x: L, y: o } = d;
  _l(() => {
    $l(L) && $l(o) && m([L - ((l == null ? void 0 : l.x) || 0), o - ((l == null ? void 0 : l.y) || 0)]);
  }, [L, o, s, i]);
  const h = `scale(${X || 1}) ${G && "translate(" + G[0] + "px," + G[1] + "px)" || ""}`, { fontSize: p, fontFamily: r, underline: V, fontColor: W, lineThrough: y, textAlign: t, strokeColor: e, lineHeight: Z, bold: a, italic: x } = n, K = p, C = Z || K * 1.2, T = {
    fontSize: `${K}px`,
    lineHeight: `${C}px`,
    color: W,
    borderColor: e,
    minHeight: `${C}px`
  };
  r && (T.fontFamily = `${r}`), (y || V) && (T.textDecoration = `${y && "line-through" || ""}${V && " underline" || ""}`), t && (T.textAlign = `${t}`), a && (T.fontWeight = `${a}`), x && (T.fontStyle = `${x}`);
  let I = "";
  return n != null && n.text && (I = n.text.split(",").reduce((F, R, S) => {
    const N = R === "" ? "<br/>" : R;
    return S === 0 ? N : `${F}<div>${N}</div>`;
  }, "")), nl.createElement(
    "div",
    { className: "editor-box", style: {
      left: `${c[0]}px`,
      top: `${c[1]}px`,
      transform: h,
      transformOrigin: "left top"
    } },
    nl.createElement("div", { className: "editor readOnly", style: T, dangerouslySetInnerHTML: { __html: I } })
  );
}), OG = (b) => {
  const { data: d, workId: l, isSelect: i, handleKeyUp: s, handleFocus: c, updateOptInfo: m } = b, { opt: n, scale: X, translate: G, x: L, y: o } = d, [h, p] = Hl(""), r = Yi(null);
  _l(() => {
    let N = "";
    n != null && n.text && (N = n.text.split(",").reduce((P, j, D) => {
      const z = j === "" ? "<br/>" : j;
      return D === 0 ? z : `${P}<div>${z}</div>`;
    }, "")), p(N), Promise.resolve().then(() => {
      r.current && r.current.click();
    });
  }, []), _l(() => {
    var N, Q;
    (N = r.current) != null && N.offsetWidth && ((Q = r.current) != null && Q.offsetHeight) && m({
      activeTextId: l,
      update: {
        boxSize: [r.current.offsetWidth, r.current.offsetHeight],
        workState: ul.Doing
      }
    });
  });
  const V = `scale(${X || 1}) ${G && "translate(" + G[0] + "px," + G[1] + "px)" || ""}`, { fontSize: W, fontFamily: y, underline: t, fontColor: e, lineThrough: Z, textAlign: a, strokeColor: x, lineHeight: K, bold: C, italic: T } = n, I = W, J = K || I * 1.2, F = {
    fontSize: `${I}px`,
    lineHeight: `${J}px`,
    color: e,
    borderColor: x,
    minHeight: `${J}px`
  };
  y && (F.fontFamily = `${y}`), (Z || t) && (F.textDecoration = `${Z && "line-through" || ""} ${t && " underline" || ""}`), a && (F.textAlign = `${a}`), C && (F.fontWeight = `${C}`), T && (F.fontStyle = `${T}`);
  function R() {
    var N;
    if (r.current) {
      r.current.focus();
      const Q = window == null ? void 0 : window.getSelection(), P = r.current.lastChild;
      if (Q && P) {
        const j = document.createRange(), D = ((N = P.textContent) == null ? void 0 : N.length) || 0;
        (P == null ? void 0 : P.nodeName) === "#text" ? j.setStart(P, D) : j.setStart(P, D && 1 || 0), j.collapse(!0), Q.removeAllRanges(), Q.addRange(j);
      }
    }
  }
  function S(N) {
    if (N.key === "Backspace") {
      const Q = window.getSelection(), P = Q == null ? void 0 : Q.getRangeAt(0);
      if (P != null && P.collapsed)
        return N.preventDefault(), document.execCommand("delete", !1), !1;
    }
    return !1;
  }
  return nl.createElement(
    "div",
    { className: "editor-box", style: {
      left: `${L}px`,
      top: `${o}px`,
      transform: V,
      transformOrigin: "left top",
      zIndex: 2,
      pointerEvents: "auto"
    }, onKeyDown: (N) => (N.stopPropagation(), !0), onMouseMove: (N) => (N.stopPropagation(), N.preventDefault(), !0) },
    !i && nl.createElement(Vt, { textOpt: n, workIds: [l], noLayer: !0, position: { x: L, y: o } }),
    nl.createElement("div", { contentEditable: !0, className: "editor", ref: r, style: F, dangerouslySetInnerHTML: { __html: h }, onKeyDown: S, onKeyUp: s, onClick: R, onTouchEnd: R, onFocus: c })
  );
};
class pt extends nl.Component {
  constructor(d) {
    super(d);
  }
  getInnerText(d) {
    const l = [];
    for (const i of d.childNodes)
      if (i.nodeName === "#text") {
        const s = i.textContent.replace(/\n/, "");
        l.push(s);
      } else {
        const s = i.innerText.replace(/\n/, "");
        l.push(s);
      }
    return l;
  }
  updateOptInfo(d) {
    var m, n;
    const { activeTextId: l, update: i, syncData: s } = d, c = l && Al(((m = this.props.manager.control.textEditorManager) == null ? void 0 : m.get(l)) || ((n = this.props.editors) == null ? void 0 : n.get(l)));
    c && c.opt && (c.opt = {
      ...c.opt,
      ...i
    }, s && (c.canSync = s.canSync, c.canWorker = s.canWorker), this.props.manager.control.textEditorManager.updateForLocalEditor(l, c));
  }
  get editorUI() {
    var d;
    if ((d = this.props.editors) != null && d.size) {
      const l = [];
      return this.props.editors.forEach((i, s) => {
        if (this.props.selectIds.includes(s) && !(this.props.activeTextId == s)) {
          const m = nl.createElement(jG, { key: s, data: i, workId: s, isSelect: !0, position: this.props.position, selectIds: this.props.selectIds });
          l.push(m);
        }
      }), l;
    }
    return null;
  }
  render() {
    return nl.createElement("div", { ref: this.props.textRef }, this.editorUI);
  }
}
class DG extends pt {
  constructor(d) {
    super(d);
  }
  handleKeyUp(d) {
    const l = this.getInnerText(d.nativeEvent.target), i = this.props.activeTextId;
    i && this.updateOptInfo({
      activeTextId: i,
      update: {
        text: l.toString(),
        boxSize: [d.nativeEvent.target.offsetWidth, d.nativeEvent.target.offsetHeight],
        workState: ul.Doing
      },
      syncData: {
        canSync: !0,
        canWorker: !0
      }
    });
  }
  handleFocus(d) {
    const l = this.props.activeTextId;
    l && this.updateOptInfo({
      activeTextId: l,
      update: {
        boxSize: [d.nativeEvent.target.offsetWidth, d.nativeEvent.target.offsetHeight],
        workState: ul.Doing
      },
      syncData: {
        canSync: !0,
        canWorker: !0
      }
    });
  }
  get editorUI() {
    var d;
    if ((d = this.props.editors) != null && d.size) {
      const l = [];
      return this.props.editors.forEach((i, s) => {
        if (!(this.props.selectIds.includes(s) && this.props.activeTextId !== s)) {
          const n = this.props.activeTextId == s && i.dataType === Jl.Local ? nl.createElement(OG, { key: s, data: i, workId: s, handleFocus: this.handleFocus.bind(this), handleKeyUp: this.handleKeyUp.bind(this), updateOptInfo: this.updateOptInfo.bind(this) }) : nl.createElement(BG, { key: s, data: i, workId: s });
          l.push(n);
        }
      }), l;
    }
    return null;
  }
  render() {
    return nl.createElement("div", { className: `${this.props.className}` }, this.editorUI);
  }
}
const AG = () => {
  const { floatBarData: b } = id(dd);
  return nl.createElement(
    "div",
    { className: "bezier-pencil-plugin-hightlight-box", style: { borderColor: b == null ? void 0 : b.selectorColor } },
    nl.createElement("div", { className: "point LT nwse-resize", style: { backgroundColor: b == null ? void 0 : b.selectorColor } }),
    nl.createElement("div", { className: "point LC ew-resize", style: { backgroundColor: b == null ? void 0 : b.selectorColor } }),
    nl.createElement("div", { className: "point LB nesw-resize", style: { backgroundColor: b == null ? void 0 : b.selectorColor } }),
    nl.createElement("div", { className: "point TC ns-resize", style: { backgroundColor: b == null ? void 0 : b.selectorColor } }),
    nl.createElement("div", { className: "point RT nesw-resize", style: { backgroundColor: b == null ? void 0 : b.selectorColor } }),
    nl.createElement("div", { className: "point RC ew-resize", style: { backgroundColor: b == null ? void 0 : b.selectorColor } }),
    nl.createElement("div", { className: "point RB nwse-resize", style: { backgroundColor: b == null ? void 0 : b.selectorColor } }),
    nl.createElement("div", { className: "point BC ns-resize", style: { backgroundColor: b == null ? void 0 : b.selectorColor } })
  );
}, qG = () => {
  const { floatBarData: b } = id(dd);
  return nl.createElement("div", { className: "bezier-pencil-plugin-hightlight-box", style: { borderColor: b == null ? void 0 : b.selectorColor } });
}, $G = nl.forwardRef((b, d) => {
  const { floatBarData: l, zIndex: i, position: s, angle: c, operationType: m, setPosition: n, setOperationType: X, maranger: G } = id(dd), { className: L, editors: o, activeTextId: h } = b, p = Yi(null), [r, V] = Hl(ul.Pending), [W, y] = Hl(), t = (T) => {
    T.preventDefault(), T.stopPropagation(), X(hl.TranslateNode), V(ul.Start), y(s), G != null && G.control.room && (G.control.room.disableDeviceInputs = !0), Cl.emitMethod(Sl.MainEngine, hl.TranslateNode, { workIds: [Il], position: s, workState: ul.Start, viewId: G == null ? void 0 : G.viewId });
  }, e = El((T, I) => {
    T.preventDefault(), T.stopPropagation();
    const J = { x: I.x, y: I.y };
    n(J), X(hl.None), V(ul.Done), G != null && G.control.room && (G.control.room.disableDeviceInputs = !1), Cl.emitMethod(Sl.MainEngine, hl.TranslateNode, { workIds: [Il], position: J, workState: ul.Done, viewId: G == null ? void 0 : G.viewId });
  }, 100, { leading: !1 }), Z = El((T, I) => {
    T.preventDefault(), T.stopPropagation();
    const J = { x: I.x, y: I.y };
    (I.x !== (s == null ? void 0 : s.x) || I.y !== (s == null ? void 0 : s.y)) && (n(J), V(ul.Doing), Cl.emitMethod(Sl.MainEngine, hl.TranslateNode, { workIds: [Il], position: J, workState: ul.Doing, viewId: G == null ? void 0 : G.viewId }));
  }, 100, { leading: !1 }), a = kl(() => m === hl.None ? nl.createElement(Vt, { textOpt: l == null ? void 0 : l.textOpt, position: s }) : null, [m, l, s]), x = kl(() => (l == null ? void 0 : l.scaleType) !== Nd.all || m === hl.RotateNode ? null : nl.createElement(AG, null), [l, m]), K = kl(() => (l == null ? void 0 : l.scaleType) !== Nd.both || m === hl.RotateNode ? null : nl.createElement(qG, null), [l, m]), C = kl(() => {
    const T = (l == null ? void 0 : l.selectIds) || [];
    return o && G && T ? nl.createElement(pt, { manager: G, textRef: p, selectIds: T, position: s, activeTextId: h, editors: o }) : null;
  }, [l == null ? void 0 : l.selectIds, o, G, h]);
  return nl.createElement(
    ii,
    { position: s, onStart: t, onDrag: Z, onStop: e, handle: "canvas" },
    nl.createElement(
      "div",
      { className: `${L}`, style: l ? {
        width: l.w,
        height: l.h,
        zIndex: i,
        pointerEvents: i < 2 ? "none" : "auto"
      } : void 0, onClick: El((T) => {
        if (T.stopPropagation(), T.preventDefault(), G && (o != null && o.size) && p.current && ld(W, s)) {
          const I = G.getPoint(T.nativeEvent);
          I && G.control.textEditorManager.computeTextActive(I, G.viewId);
        }
        return !1;
      }, 100, { leading: !1 }), onTouchEndCapture: El((T) => {
        if (T.stopPropagation(), T.preventDefault(), G && (o != null && o.size) && p.current && r !== ul.Doing) {
          const I = G.getPoint(T.nativeEvent);
          I && G.control.textEditorManager.computeTextActive(I, G.viewId);
        }
        return !1;
      }, 100, { leading: !1 }) },
      a,
      nl.createElement(
        "div",
        { className: "bezier-pencil-plugin-floatCanvas-box", style: {
          width: "100%",
          height: "100%",
          transform: `rotate(${c}deg)`
        } },
        nl.createElement("canvas", { ref: d, className: "bezier-pencil-plugin-floatCanvas" })
      ),
      x,
      K,
      C
    )
  );
}), _G = (b) => {
  const { className: d } = b, { floatBarData: l, angle: i, setAngle: s, position: c, setOperationType: m, maranger: n } = id(dd), [X, G] = Hl(!1), [L, o] = Hl(new Ml()), [h, p] = Hl(new Ml());
  _l(() => {
    if (l) {
      const y = Math.floor(l.w / 2), t = Math.floor(-l.h / 2);
      p(new Ml(y, t)), o(new Ml());
    }
  }, [l, c]);
  const r = (y, t) => {
    y.preventDefault(), y.stopPropagation(), G(!0);
    const e = Math.round(Ml.GetAngleByPoints(L, h, new Ml(t.x, t.y))) || 0;
    s(e), m(hl.RotateNode), n != null && n.control.room && (n.control.room.disableDeviceInputs = !0), Cl.emitMethod(Sl.MainEngine, hl.RotateNode, { workIds: [Il], angle: e, workState: ul.Start, viewId: n == null ? void 0 : n.viewId });
  }, V = El((y, t) => {
    y.preventDefault(), y.stopPropagation(), G(!1);
    const e = Math.round(Ml.GetAngleByPoints(L, h, new Ml(t.x, t.y))) || 0;
    s(e), m(hl.None), n != null && n.control.room && (n.control.room.disableDeviceInputs = !1), Cl.emitMethod(Sl.MainEngine, hl.RotateNode, { workIds: [Il], angle: e, workState: ul.Done, viewId: n == null ? void 0 : n.viewId });
  }, 100, { leading: !1 }), W = El((y, t) => {
    y.preventDefault(), y.stopPropagation(), G(!0);
    const e = Math.round(Ml.GetAngleByPoints(L, h, new Ml(t.x, t.y))) || 0;
    s(e), m(hl.RotateNode), Cl.emitMethod(Sl.MainEngine, hl.RotateNode, { workIds: [Il], angle: e, workState: ul.Doing, viewId: n == null ? void 0 : n.viewId });
  }, 100, { leading: !1 });
  return nl.createElement(
    ii,
    { handle: ".bezier-pencil-plugin-rotate-mouse-pointer", onStart: r, onDrag: W, onStop: V },
    nl.createElement(
      "div",
      { className: `${d}`, style: c && l ? {
        left: c.x - 30,
        top: c.y + l.h + 20
      } : void 0 },
      !X && nl.createElement(
        "div",
        { className: "bezier-pencil-plugin-rotate-btn", style: { backgroundColor: l == null ? void 0 : l.selectorColor } },
        nl.createElement("img", { alt: "icon", src: Zd("rotation-button") })
      ),
      nl.createElement(
        "div",
        { className: `bezier-pencil-plugin-rotate-mouse-pointer ${X ? "active" : ""}` },
        nl.createElement("img", { alt: "icon", src: Zd("rotation") }),
        nl.createElement(
          "div",
          { className: "angle-icon" },
          i,
          "°"
        )
      )
    )
  );
}, lW = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAYAAADFeBvrAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYISURBVHgB7ZpNSCtXFIBPEuvz+dMGpYUKD/sWFX+Qti6kK7Hqpm6e9q0rIoIUFUShPLV10VZx4+JZqa9v20LBhdq9fyBUCtKNPH8qYl2IOw3G38Rkek4y15y5uTOZJDOWggcOSSYzN/ebc+45554JwIM8iBCPyTEP+86T4vyMfsRN4b+nQTKIJp0vzuGvlpID7os8EQNEIBD4oKio6Bm9DwaDv/v9/n/076JgbtWUYPchwrW8qD7UnOvr6wFNkpubm+/wu7f0c7y6mrnlvQufxB0Iau7V1dX3BDA/P6/V1dVpzc3N2uLiIofK1c8VYHys/wRKBUN3/hGHqaysNOjc3FwMis6hc0FtLTHuvYLxCCZgci8uLn4wg5Gh6Fy8Jk+/NkcCAlAAuUkoW4g0B+d5tLS05O/r67O8eGxsDNra2uDy8nKsoKCAwCIQDxQa0yTxgrvCYXyTk5Ml+Orf2dlJeeHIyAigFSE/P38ELfUNqNdSkjgF5FF89jL1TU1NlQwODl5gZPujp6cHWltbUw7Koc7Pz8mkZpHPFeFrJuZeqLnoMoPoZqe0JjDP/IZgnyLUG/o8NDRkuo5Ua2pjY6MC4oFCFf1cA0oKzRSOp6enRfTaGh0d/QxBt+1CUVgnOTs7+xrHfQzGyOcKkK3QTJMnQffZ6e/v/xwttmsHqqmpKXbdycnJCxy7ABLh3FEgVZ6hZJhnFZoFFMF0d3c/w7v+dyookXBnZ2c/xvHfhriVcvXfdBRItsxjnOhYqjwjoAimq6vrCysoGofk+Ph4Esd/F/UdiFtJAGUd2DygTpp5dmBUUJ2dnc9VUALm8PDwJY7/BPU9VD8k3M4RC6kskxZMKigKIMLN9vf3p3H8DyWgfEhEOwOQD9IXOTz7EObbwsLC4YWFBRgeHrY9ECXYo6MjaGlpKWlsbPxkYGDgRW1tbSEWquVlZWXBzc3Nl1VVVa8hXiXc6ioqBqGaPDk7AACJTRZ3NS9lcUp86cJwoSQ7Pj4Op6enfxUXF3/V0NCQv7q6GsCvwrqGUG/01xAD4+VQTOxaSF43d5bBOisrGBJRCtXX17+/trb268rKSgASFgmz97KFkmo6OztWuVyPweiWGc4WRkhFRQVEIpHg8vJyQAIQVlLBROVxvBYQHsXnO8tk62ZcyN0wecLBwcEvYHSzEPscBqOLCRhLC4n9uqaA8UAWAcAKhtbQ3t7eTHl5+Y9gtAp3twhT056CDMQ7MRzIFTeTYKb1yYYVQFH9VdzsqNmYKpfTJBDX3Ixgdnd3XyHMT2AMALJlBBSPaMpNngrIsTyTCgaj288YDGakictrxizvKFNOjgSSBLS+vv6UYHDb7DgMVgsChjTEgCIKGG4ZU+EWkgNBzN1qamq+pAMTExPgFMzW1tZrhHkFyWE5KxgSszx0527RaDRmOSpRshEOU11dPQPG8CwHARHJlMnTSrwSRFIlfXt7m3V5ngJGuJtqzaQtZkFBVNJezN5ZAdmwjKo2k9tVtrcI3OXk4tPgcg7ChCDZ1URgMOu72Xa5VFHOkymQhWVU60YVmjN6wiC7k6p+S1syCACOwJBYFaexV+yhBekNPsMBO6KAEeE4BMaCU67RsoYhSbXgaT//ht709vZCaWmp6YkEbLFmVJWzas04+iBL7EKpm0J7duqu0B7+CTUpNJuyvb1NCfMj1CqI9wLKUOlOUMeG+gGFkHii4HizUF4z/KFUrPsJ8WbEIyx7nnZ0dDynME6BAuce09iFHo+GrnmGltltb2//E4wVAN82y7vOjKOZXSBhJdHNiT3TYWD8OY2PTUJkdd7MkJMnT5wZVQF2RFX6yBMUdzPMvvfqxz3sXHF+GNT9ANXit/10O1sgHkZvdQAOKvs9B5L7ARELGAAXLSTvM8QExTE+YbHe+HURhZp1aRyF4CJXClbbWwGketgkW9VsY+YaiBCVhfgE+XvxRwgZSM4jUVCDZFQ9pytmXR8hUTB2gnidx4XffVWydN0yQjwmx/jkAZJBrIBI5J7ZvQGZWUgVSuU/EqmOAzicKNMVu816DdRWUV1/7xAP8n+SfwF3Du3NF2sYhwAAAABJRU5ErkJggg==", dW = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='40px'%20height='40px'%20viewBox='0%200%2040%2040'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3c!--%20Generator:%20Sketch%2060.1%20(88133)%20-%20https://sketch.com%20--%3e%3ctitle%3eshape-cursor%3c/title%3e%3cdesc%3eCreated%20with%20Sketch.%3c/desc%3e%3cdefs%3e%3cpath%20d='M20,21.5%20C20.2454599,21.5%2020.4496084,21.6768752%2020.4919443,21.9101244%20L20.5,22%20L20.5,27%20C20.5,27.2761424%2020.2761424,27.5%2020,27.5%20C19.7545401,27.5%2019.5503916,27.3231248%2019.5080557,27.0898756%20L19.5,27%20L19.5,22%20C19.5,21.7238576%2019.7238576,21.5%2020,21.5%20Z%20M27,19.5%20C27.2761424,19.5%2027.5,19.7238576%2027.5,20%20C27.5,20.2454599%2027.3231248,20.4496084%2027.0898756,20.4919443%20L27,20.5%20L22,20.5%20C21.7238576,20.5%2021.5,20.2761424%2021.5,20%20C21.5,19.7545401%2021.6768752,19.5503916%2021.9101244,19.5080557%20L22,19.5%20L27,19.5%20Z%20M18,19.5%20C18.2761424,19.5%2018.5,19.7238576%2018.5,20%20C18.5,20.2454599%2018.3231248,20.4496084%2018.0898756,20.4919443%20L18,20.5%20L13,20.5%20C12.7238576,20.5%2012.5,20.2761424%2012.5,20%20C12.5,19.7545401%2012.6768752,19.5503916%2012.9101244,19.5080557%20L13,19.5%20L18,19.5%20Z%20M20,12.5%20C20.2454599,12.5%2020.4496084,12.6768752%2020.4919443,12.9101244%20L20.5,13%20L20.5,18%20C20.5,18.2761424%2020.2761424,18.5%2020,18.5%20C19.7545401,18.5%2019.5503916,18.3231248%2019.5080557,18.0898756%20L19.5,18%20L19.5,13%20C19.5,12.7238576%2019.7238576,12.5%2020,12.5%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-64.6%25'%20y='-59.5%25'%20width='229.3%25'%20height='246.1%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeMorphology%20radius='1'%20operator='dilate'%20in='SourceAlpha'%20result='shadowSpreadOuter1'%3e%3c/feMorphology%3e%3cfeOffset%20dx='0'%20dy='2'%20in='shadowSpreadOuter1'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='3'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeComposite%20in='shadowBlurOuter1'%20in2='SourceAlpha'%20operator='out'%20result='shadowBlurOuter1'%3e%3c/feComposite%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.16%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-4'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='Whiteboard-Guidelines'%20transform='translate(-344.000000,%20-751.000000)'%3e%3cg%20id='shape-cursor'%20transform='translate(344.000000,%20751.000000)'%3e%3crect%20id='矩形备份-44'%20fill='%23FFFFFF'%20opacity='0.01'%20x='0'%20y='0'%20width='40'%20height='40'%20rx='2'%3e%3c/rect%3e%3cg%20id='形状结合'%20fill-rule='nonzero'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cpath%20stroke='%23FFFFFF'%20stroke-width='1'%20d='M20,21%20C20.4854103,21%2020.898085,21.3479993%2020.9899479,21.8654877%20L21,22%20L21,27%20C21,27.5522847%2020.5522847,28%2020,28%20C19.5145897,28%2019.101915,27.6520007%2019.0100521,27.1345123%20L19,27%20L19,22%20C19,21.4477153%2019.4477153,21%2020,21%20Z%20M27,19%20C27.5522847,19%2028,19.4477153%2028,20%20C28,20.4854103%2027.6520007,20.898085%2027.1345123,20.9899479%20L27,21%20L22,21%20C21.4477153,21%2021,20.5522847%2021,20%20C21,19.5145897%2021.3479993,19.101915%2021.8654877,19.0100521%20L22,19%20L27,19%20Z%20M18,19%20C18.5522847,19%2019,19.4477153%2019,20%20C19,20.4854103%2018.6520007,20.898085%2018.1345123,20.9899479%20L18,21%20L13,21%20C12.4477153,21%2012,20.5522847%2012,20%20C12,19.5145897%2012.3479993,19.101915%2012.8654877,19.0100521%20L13,19%20L18,19%20Z%20M20,12%20C20.4854103,12%2020.898085,12.3479993%2020.9899479,12.8654877%20L21,13%20L21,18%20C21,18.5522847%2020.5522847,19%2020,19%20C19.5145897,19%2019.101915,18.6520007%2019.0100521,18.1345123%20L19,18%20L19,13%20C19,12.4477153%2019.4477153,12%2020,12%20Z'%20fill='%23212324'%20fill-rule='evenodd'%3e%3c/path%3e%3c/g%3e%3crect%20id='矩形'%20fill='%23FFFFFF'%20x='18.5'%20y='17'%20width='3'%20height='6'%3e%3c/rect%3e%3crect%20id='矩形'%20fill='%23FFFFFF'%20x='17'%20y='18.5'%20width='6'%20height='3'%3e%3c/rect%3e%3cpath%20d='M20,21.5%20C20.2454599,21.5%2020.4496084,21.6768752%2020.4919443,21.9101244%20L20.5,22%20L20.5,27%20C20.5,27.2761424%2020.2761424,27.5%2020,27.5%20C19.7545401,27.5%2019.5503916,27.3231248%2019.5080557,27.0898756%20L19.5,27%20L19.5,22%20C19.5,21.7238576%2019.7238576,21.5%2020,21.5%20Z%20M27,19.5%20C27.2761424,19.5%2027.5,19.7238576%2027.5,20%20C27.5,20.2454599%2027.3231248,20.4496084%2027.0898756,20.4919443%20L27,20.5%20L22,20.5%20C21.7238576,20.5%2021.5,20.2761424%2021.5,20%20C21.5,19.7545401%2021.6768752,19.5503916%2021.9101244,19.5080557%20L22,19.5%20L27,19.5%20Z%20M18,19.5%20C18.2761424,19.5%2018.5,19.7238576%2018.5,20%20C18.5,20.2454599%2018.3231248,20.4496084%2018.0898756,20.4919443%20L18,20.5%20L13,20.5%20C12.7238576,20.5%2012.5,20.2761424%2012.5,20%20C12.5,19.7545401%2012.6768752,19.5503916%2012.9101244,19.5080557%20L13,19.5%20L18,19.5%20Z%20M20,12.5%20C20.2454599,12.5%2020.4496084,12.6768752%2020.4919443,12.9101244%20L20.5,13%20L20.5,18%20C20.5,18.2761424%2020.2761424,18.5%2020,18.5%20C19.7545401,18.5%2019.5503916,18.3231248%2019.5080557,18.0898756%20L19.5,18%20L19.5,13%20C19.5,12.7238576%2019.7238576,12.5%2020,12.5%20Z'%20id='形状结合'%20fill='%23212324'%20fill-rule='nonzero'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", iW = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='47px'%20height='40px'%20viewBox='0%200%2047%2040'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3c!--%20Generator:%20Sketch%2060.1%20(88133)%20-%20https://sketch.com%20--%3e%3ctitle%3etext-cursor%3c/title%3e%3cdesc%3eCreated%20with%20Sketch.%3c/desc%3e%3cdefs%3e%3cpath%20d='M16,26.5%20C15.7238576,26.5%2015.5,26.2761424%2015.5,26%20C15.5,25.7545401%2015.6768752,25.5503916%2015.9101244,25.5080557%20L16,25.5%20L19.5,25.5%20L19.5,14.5%20L16,14.5%20C15.7238576,14.5%2015.5,14.2761424%2015.5,14%20C15.5,13.7545401%2015.6768752,13.5503916%2015.9101244,13.5080557%20L16,13.5%20L24,13.5%20C24.2761424,13.5%2024.5,13.7238576%2024.5,14%20C24.5,14.2454599%2024.3231248,14.4496084%2024.0898756,14.4919443%20L24,14.5%20L20.5,14.5%20L20.5,25.5%20L24,25.5%20C24.2761424,25.5%2024.5,25.7238576%2024.5,26%20C24.5,26.2454599%2024.3231248,26.4496084%2024.0898756,26.4919443%20L24,26.5%20L16,26.5%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-284.0%25'%20y='-81.5%25'%20width='668.1%25'%20height='293.9%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeMorphology%20radius='1'%20operator='dilate'%20in='SourceAlpha'%20result='shadowSpreadOuter1'%3e%3c/feMorphology%3e%3cfeOffset%20dx='0'%20dy='2'%20in='shadowSpreadOuter1'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='3'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeComposite%20in='shadowBlurOuter1'%20in2='SourceAlpha'%20operator='out'%20result='shadowBlurOuter1'%3e%3c/feComposite%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.16%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-4'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='Whiteboard-Guidelines'%20transform='translate(-388.000000,%20-672.000000)'%3e%3cg%20id='text-cursor'%20transform='translate(392.000000,%20672.000000)'%3e%3crect%20id='矩形备份-40'%20fill='%23FFFFFF'%20opacity='0.01'%20x='0'%20y='0'%20width='40'%20height='40'%20rx='2'%3e%3c/rect%3e%3cg%20id='形状结合'%20fill-rule='nonzero'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cpath%20stroke='%23FFFFFF'%20stroke-width='1'%20d='M19,25%20L19,15%20L16,15%20C15.4477153,15%2015,14.5522847%2015,14%20C15,13.5145897%2015.3479993,13.101915%2015.8654877,13.0100521%20L16,13%20L24,13%20C24.5522847,13%2025,13.4477153%2025,14%20C25,14.4854103%2024.6520007,14.898085%2024.1345123,14.9899479%20L24,15%20L21,15%20L21,25%20L24,25%20C24.5522847,25%2025,25.4477153%2025,26%20C25,26.4854103%2024.6520007,26.898085%2024.1345123,26.9899479%20L24,27%20L16,27%20C15.4477153,27%2015,26.5522847%2015,26%20C15,25.5145897%2015.3479993,25.101915%2015.8654877,25.0100521%20L16,25%20L19,25%20Z'%20fill='%23212324'%20fill-rule='evenodd'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
class sW extends vl.Component {
  constructor(d) {
    super(d), Object.defineProperty(this, "renderAvatar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        var s;
        const i = `rgb(${l.memberState.strokeColor[0]}, ${l.memberState.strokeColor[1]}, ${l.memberState.strokeColor[2]})`;
        if (this.detectAvatar(l)) {
          const c = this.detectCursorName(l);
          return vl.createElement("img", { className: "cursor-selector-avatar", style: {
            width: c ? 19 : 28,
            height: c ? 19 : 28,
            position: c ? "initial" : "absolute",
            borderColor: c ? "white" : i,
            marginRight: c ? 4 : 0
          }, src: (s = l.payload) == null ? void 0 : s.avatar, alt: "avatar" });
        } else
          return null;
      }
    }), Object.defineProperty(this, "getOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        const i = this.getCursorName(l), s = this.detectAvatar(l);
        return i === void 0 && s === void 0 ? 0 : 1;
      }
    }), Object.defineProperty(this, "getCursorName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        if (l.payload && l.payload.cursorName)
          return l.payload.cursorName;
      }
    }), Object.defineProperty(this, "getThemeClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => l.payload && l.payload.theme ? "cursor-inner-mellow" : "cursor-inner"
    }), Object.defineProperty(this, "getCursorBackgroundColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        const i = this.detectCursorName(l);
        return l.payload && l.payload.cursorBackgroundColor ? l.payload.cursorBackgroundColor : i ? `rgb(${l.memberState.strokeColor[0]}, ${l.memberState.strokeColor[1]}, ${l.memberState.strokeColor[2]})` : void 0;
      }
    }), Object.defineProperty(this, "getCursorTextColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => l.payload && l.payload.cursorTextColor ? l.payload.cursorTextColor : "#FFFFFF"
    }), Object.defineProperty(this, "getCursorTagBackgroundColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => l.payload && l.payload.cursorTagBackgroundColor ? l.payload.cursorTagBackgroundColor : this.getCursorBackgroundColor(l)
    }), Object.defineProperty(this, "detectCursorName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => !!(l.payload && l.payload.cursorName)
    }), Object.defineProperty(this, "detectAvatar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => !!(l.payload && l.payload.avatar)
    }), Object.defineProperty(this, "renderTag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        if (l.payload && l.payload.cursorTagName)
          return vl.createElement("span", { className: "cursor-tag-name", style: { backgroundColor: this.getCursorTagBackgroundColor(l) } }, l.payload.cursorTagName);
      }
    });
  }
  render() {
    const { roomMember: d } = this.props, l = this.getCursorName(d);
    switch (d.memberState.currentApplianceName) {
      case zl.pencil:
        return vl.createElement(
          "div",
          { className: "cursor-box" },
          vl.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -90%)", marginLeft: "10px" } },
            vl.createElement(
              "div",
              { className: "cursor-name" },
              vl.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(d),
                  backgroundColor: this.getCursorBackgroundColor(d),
                  color: this.getCursorTextColor(d)
                }, className: this.getThemeClass(d) },
                this.renderAvatar(d),
                l,
                this.renderTag(d)
              )
            ),
            vl.createElement(
              "div",
              null,
              vl.createElement("img", { className: "cursor-pencil-image", src: lW, alt: "pencilCursor" })
            )
          )
        );
      case zl.text:
        return vl.createElement(
          "div",
          { className: "cursor-box" },
          vl.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -65%)", marginLeft: "0px" } },
            vl.createElement(
              "div",
              { className: "cursor-name" },
              vl.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(d),
                  backgroundColor: this.getCursorBackgroundColor(d),
                  color: this.getCursorTextColor(d)
                }, className: this.getThemeClass(d) },
                this.renderAvatar(d),
                l,
                this.renderTag(d)
              )
            ),
            vl.createElement(
              "div",
              null,
              vl.createElement("img", { className: "cursor-arrow-image", src: iW, alt: "textCursor" })
            )
          )
        );
      case zl.rectangle:
      case zl.arrow:
      case zl.straight:
      case zl.shape:
      case zl.ellipse:
        return vl.createElement(
          "div",
          { className: "cursor-box" },
          vl.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -65%)", marginLeft: "0px" } },
            vl.createElement(
              "div",
              { className: "cursor-name" },
              vl.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(d),
                  backgroundColor: this.getCursorBackgroundColor(d),
                  color: this.getCursorTextColor(d)
                }, className: this.getThemeClass(d) },
                this.renderAvatar(d),
                l,
                this.renderTag(d)
              )
            ),
            vl.createElement(
              "div",
              null,
              vl.createElement("img", { className: "cursor-arrow-image", src: dW, alt: "shapeCursor" })
            )
          )
        );
      default:
        return null;
    }
  }
}
const tW = (b) => {
  const { className: d, info: l } = b, { roomMember: i, ...s } = l || {};
  return vl.createElement("div", { className: `${d}`, style: s ? {
    transform: `translate(${s.x}px, ${s.y}px)`
  } : { display: "none" } }, i && vl.createElement(sW, { roomMember: i }));
}, cW = (b) => {
  const { className: d } = b, [l, i] = Hl({ x: 0, y: 0, h: 0, w: 0 }), { floatBarData: s, setSize: c, position: m, setPosition: n, maranger: X } = id(dd);
  _l(() => {
    s && i({ x: s.x, y: s.y, w: s.w, h: s.h });
  }, []);
  const G = (h) => {
    if (h.preventDefault(), h.stopPropagation(), s != null && s.w && (s != null && s.h)) {
      const p = {
        x: (m == null ? void 0 : m.x) || 0,
        y: (m == null ? void 0 : m.y) || 0,
        w: s.w,
        h: s.h
      };
      c({ width: p.w, height: p.h, workState: ul.Start }), i(p), X != null && X.control.room && (X.control.room.disableDeviceInputs = !0), Cl.emitMethod(Sl.MainEngine, hl.ScaleNode, { workIds: [Il], box: p, workState: ul.Start, viewId: X == null ? void 0 : X.viewId });
    }
  }, L = El((h, p, r, V) => {
    h.preventDefault(), h.stopPropagation();
    const W = {
      x: l.x,
      y: l.y,
      w: l.w,
      h: l.h
    };
    switch (W.w += V.width, W.h += V.height, p) {
      case "bottomLeft":
      case "left":
        W.x -= V.width;
        break;
      case "topLeft":
        W.x -= V.width, W.y -= V.height;
        break;
      case "top":
      case "topRight":
        W.y -= V.height;
        break;
    }
    (V.width !== 0 || V.height !== 0) && (c({ width: W.w, height: W.h, workState: ul.Doing }), n({ x: W.x, y: W.y }), Cl.emitMethod(Sl.MainEngine, hl.ScaleNode, { workIds: [Il], box: W, workState: ul.Doing, viewId: X == null ? void 0 : X.viewId }));
  }, 100, { leading: !1 }), o = El((h, p, r, V) => {
    h.preventDefault(), h.stopPropagation();
    const W = {
      x: l.x,
      y: l.y,
      w: l.w,
      h: l.h
    };
    switch (W.w += V.width, W.h += V.height, p) {
      case "bottomLeft":
      case "left":
        W.x -= V.width;
        break;
      case "topLeft":
        W.x -= V.width, W.y -= V.height;
        break;
      case "top":
      case "topRight":
        W.y -= V.height;
        break;
    }
    c({ width: W.w, height: W.h, workState: ul.Done }), n({ x: W.x, y: W.y }), X != null && X.control.room && (X.control.room.disableDeviceInputs = !1), Cl.emitMethod(Sl.MainEngine, hl.ScaleNode, { workIds: [Il], box: W, workState: ul.Done, viewId: X == null ? void 0 : X.viewId });
  }, 100, { leading: !1 });
  return nl.createElement(Yt, { className: `${d}`, boundsByDirection: !0, size: {
    width: (s == null ? void 0 : s.w) || 0,
    height: (s == null ? void 0 : s.h) || 0
  }, style: {
    position: "absolute",
    pointerEvents: "auto",
    left: m == null ? void 0 : m.x,
    top: m == null ? void 0 : m.y
  }, onResizeStart: G, onResize: L, onResizeStop: o });
}, gs = (b) => {
  const { id: d, pos: l, pointMap: i, type: s } = b, { setOperationType: c, maranger: m, floatBarData: n } = id(dd), [X, G] = Hl({ x: 0, y: 0 }), [L, o] = Hl(ul.Pending);
  _l(() => {
    (L === ul.Pending || L === ul.Done) && G(l);
  }, [l, L]);
  const h = (V) => {
    V.preventDefault(), V.stopPropagation(), c(hl.SetPoint), o(ul.Start), m != null && m.control.room && (m.control.room.disableDeviceInputs = !0), Cl.emitMethod(Sl.MainEngine, hl.SetPoint, { workId: Il, pointMap: i, workState: ul.Start, viewId: m == null ? void 0 : m.viewId });
  }, p = El((V, W) => {
    if (V.preventDefault(), V.stopPropagation(), c(hl.SetPoint), o(ul.Doing), W.x !== (X == null ? void 0 : X.x) || W.y !== (X == null ? void 0 : X.y)) {
      const y = i.get(d);
      y && s === "start" && (m != null && m.control.viewContainerManager) ? y[0] = m.control.viewContainerManager.transformToScenePoint([W.x, W.y], m.viewId) : y && s === "end" && (m != null && m.control.viewContainerManager) && (y[1] = m.control.viewContainerManager.transformToScenePoint([W.x, W.y], m.viewId)), Cl.emitMethod(Sl.MainEngine, hl.SetPoint, { workId: Il, pointMap: i, workState: ul.Doing, viewId: m == null ? void 0 : m.viewId });
    }
  }, 50, { leading: !1 }), r = El((V, W) => {
    if (V.preventDefault(), V.stopPropagation(), c(hl.None), o(ul.Done), W.x !== (X == null ? void 0 : X.x) || W.y !== (X == null ? void 0 : X.y)) {
      G(W);
      const y = i.get(d);
      y && s === "start" && (m != null && m.control.viewContainerManager) ? y[0] = m.control.viewContainerManager.transformToScenePoint([W.x, W.y], m.viewId) : y && s === "end" && (m != null && m.control.viewContainerManager) && (y[1] = m.control.viewContainerManager.transformToScenePoint([W.x, W.y], m.viewId)), Cl.emitMethod(Sl.MainEngine, hl.SetPoint, { workId: Il, pointMap: i, workState: ul.Done, viewId: m == null ? void 0 : m.viewId });
    }
  }, 100, { leading: !1 });
  return nl.createElement(
    ii,
    { position: X, onStart: h, onDrag: p, onStop: r },
    nl.createElement(
      "div",
      { className: "bezier-pencil-plugin-point-draggable-btn" },
      nl.createElement("div", { className: "bezier-pencil-plugin-point-draggable-btn-inner", style: {
        borderColor: n == null ? void 0 : n.selectorColor
      } })
    )
  );
}, bW = (b) => {
  const { className: d } = b, { floatBarData: l, maranger: i } = id(dd), [s, c] = Hl(), [m, n] = Hl(), [X, G] = Hl(/* @__PURE__ */ new Map());
  _l(() => {
    const h = [];
    if (i && (l != null && l.points)) {
      const p = i.viewId;
      if (i.control.viewContainerManager.getView(p))
        for (const V of l.points) {
          const W = i.control.viewContainerManager.transformToOriginPoint(V, p);
          h.push(W);
        }
      l != null && l.selectIds && l.selectIds.length === 1 && (X.set(l.selectIds[0], l.points), G(X));
    }
    h[0] && c({ x: h[0][0], y: h[0][1] }), h[1] && n({ x: h[1][0], y: h[1][1] });
  }, [i, l == null ? void 0 : l.points, l == null ? void 0 : l.selectIds, X]);
  const L = kl(() => s && (l != null && l.selectIds) ? nl.createElement(gs, { pos: s, type: "start", id: l.selectIds[0], pointMap: X }) : null, [s, l == null ? void 0 : l.selectIds, X]), o = kl(() => m && (l != null && l.selectIds) ? nl.createElement(gs, { pos: m, type: "end", id: l.selectIds[0], pointMap: X }) : null, [m, l == null ? void 0 : l.selectIds, X]);
  return nl.createElement(
    "div",
    { className: `${d}` },
    L,
    o
  );
}, dd = nl.createContext({
  maranger: void 0,
  floatBarColors: [],
  floatBarData: void 0,
  zIndex: -1,
  dpr: 1,
  position: void 0,
  angle: 0,
  operationType: hl.None,
  scale: [1, 1],
  setPosition: () => {
  },
  setSize: () => {
  },
  setAngle: () => {
  },
  setOperationType: () => {
  },
  setFloatBarData: () => {
  }
});
class vi extends nl.Component {
  constructor(d) {
    var l, i;
    super(d), Object.defineProperty(this, "setPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.setState({ position: s });
      }
    }), Object.defineProperty(this, "setAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.setState({ angle: s });
      }
    }), Object.defineProperty(this, "setOperationType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.setState({ operationType: s });
      }
    }), this.state = {
      floatBarData: void 0,
      showFloatBar: !1,
      zIndex: -1,
      dpr: 1,
      position: void 0,
      angle: 0,
      operationType: hl.None,
      cursorInfo: void 0,
      scale: [1, 1],
      editors: (l = this.props.maranger.control.textEditorManager) == null ? void 0 : l.editors,
      activeTextId: (i = this.props.maranger.control.textEditorManager) == null ? void 0 : i.activeId
    };
  }
  componentDidMount() {
    this.props.maranger.vDom = this, this.props.maranger.mountView(), this.setState({ dpr: this.props.maranger.dpr });
  }
  componentWillUnmount() {
  }
  showFloatBar(d, l) {
    const i = d && l && { ...this.state.floatBarData, ...l } || void 0;
    this.setState({
      showFloatBar: d,
      floatBarData: i,
      position: i && { x: i.x, y: i.y },
      angle: 0
    }), i && this.props.refs.floatBarCanvasRef.current && (i.canvasHeight && i.canvasWidth ? (this.props.refs.floatBarCanvasRef.current.width = i.canvasWidth * this.state.dpr, this.props.refs.floatBarCanvasRef.current.height = i.canvasHeight * this.state.dpr, this.props.refs.floatBarCanvasRef.current.style.width = i.canvasWidth + "px", this.props.refs.floatBarCanvasRef.current.style.height = i.canvasHeight + "px") : (this.props.refs.floatBarCanvasRef.current.width = i.w * this.state.dpr, this.props.refs.floatBarCanvasRef.current.height = i.h * this.state.dpr, this.props.refs.floatBarCanvasRef.current.style.width = "100%", this.props.refs.floatBarCanvasRef.current.style.height = "100%"));
  }
  setActiveTextEditor(d) {
    const l = Al(this.props.maranger.control.textEditorManager.filterEditor(this.props.maranger.viewId));
    this.setState({
      activeTextId: d,
      editors: l
    });
  }
  setActiveCursor(d) {
    this.setState({ cursorInfo: d });
  }
  setSize(d) {
    d.workState === ul.Done ? this.state.floatBarData && this.setState({
      floatBarData: { ...this.state.floatBarData, w: d.width, h: d.height },
      scale: [1, 1],
      operationType: hl.None
    }) : this.state.floatBarData && this.setState({
      floatBarData: { ...this.state.floatBarData, w: d.width, h: d.height },
      scale: [1, 1],
      operationType: hl.ScaleNode
    });
  }
  setFloatZIndex(d) {
    this.setState({ zIndex: d });
  }
  setFloatBarData(d) {
    this.state.floatBarData && this.setState({
      floatBarData: { ...this.state.floatBarData, ...d }
    });
  }
  render() {
    var d, l, i, s, c, m, n, X, G, L;
    return nl.createElement(
      nl.Fragment,
      null,
      nl.createElement(
        "div",
        { className: Vd.Container, onMouseDown: (o) => {
          o.preventDefault(), o.stopPropagation();
        }, onTouchStart: (o) => {
          o.stopPropagation();
        }, onMouseMove: (o) => {
          this.props.maranger.cursorMouseMove(o);
        } },
        nl.createElement(
          "div",
          { className: Vd.CanvasBox },
          nl.createElement("canvas", { className: Vd.FloatCanvas, ref: this.props.refs.canvasFloatRef }),
          nl.createElement("canvas", { ref: this.props.refs.canvasBgRef })
        ),
        nl.createElement(
          dd.Provider,
          { value: {
            maranger: this.props.maranger,
            floatBarColors: ((i = (l = (d = this.props.maranger.control) == null ? void 0 : d.room) == null ? void 0 : l.floatBarOptions) == null ? void 0 : i.colors) || [],
            floatBarData: this.state.floatBarData,
            zIndex: this.state.zIndex,
            dpr: this.state.dpr,
            position: this.state.position,
            angle: this.state.angle,
            operationType: this.state.operationType,
            scale: this.state.scale,
            setPosition: this.setPosition.bind(this),
            setSize: this.setSize.bind(this),
            setAngle: this.setAngle.bind(this),
            setOperationType: this.setOperationType.bind(this),
            setFloatBarData: this.setFloatBarData.bind(this)
          } },
          this.state.showFloatBar && nl.createElement($G, { className: Vd.FloatBar, ref: this.props.refs.floatBarCanvasRef, editors: this.state.editors, activeTextId: this.state.activeTextId }),
          ((s = this.state.editors) == null ? void 0 : s.size) && nl.createElement(DG, { className: Vd.TextEditorContainer, manager: this.props.maranger, selectIds: ((c = this.state.floatBarData) == null ? void 0 : c.selectIds) || [], editors: this.state.editors, activeTextId: this.state.activeTextId }),
          ((m = this.state.floatBarData) == null ? void 0 : m.canRotate) && ((X = (n = this.state.floatBarData) == null ? void 0 : n.selectIds) == null ? void 0 : X.length) === 1 && (this.state.operationType === hl.None || this.state.operationType === hl.RotateNode) && nl.createElement(_G, { className: Vd.RotateBtn }),
          ((G = this.state.floatBarData) == null ? void 0 : G.scaleType) === Nd.all && this.state.showFloatBar && (this.state.operationType === hl.None || this.state.operationType === hl.ScaleNode) && nl.createElement(cW, { className: Vd.ResizeBtn }),
          ((L = this.state.floatBarData) == null ? void 0 : L.scaleType) === Nd.both && this.state.showFloatBar && (this.state.operationType === hl.None || this.state.operationType === hl.SetPoint) && nl.createElement(bW, { className: Vd.ResizeTowBox })
        ),
        this.state.cursorInfo && this.state.cursorInfo.roomMember && (nl.createElement(tW, { key: this.state.cursorInfo.roomMember.memberId, className: Vd.CursorBox, info: this.state.cursorInfo }) || null)
      )
    );
  }
}
class ZW extends bd {
  constructor(d, l) {
    super(d, l), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "vDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mainView"
    }), Object.defineProperty(this, "eventTragetElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    });
  }
  setCanvassStyle() {
    if (this.eventTragetElement) {
      const d = this.eventTragetElement.offsetWidth, l = this.eventTragetElement.offsetHeight;
      d && l && this.canvasBgRef.current && this.canvasFloatRef.current && (this.dpr = gi(this.canvasBgRef.current.getContext("2d")), this.width = d, this.height = l, this.canvasBgRef.current.style.width = `${d}px`, this.canvasBgRef.current.style.height = `${l}px`, this.canvasFloatRef.current.style.width = `${d}px`, this.canvasFloatRef.current.style.height = `${l}px`, this.canvasFloatRef.current.width = d * this.dpr, this.canvasFloatRef.current.height = l * this.dpr, this.canvasBgRef.current.width = d * this.dpr, this.canvasBgRef.current.height = l * this.dpr);
    }
  }
  createMainViewDisplayer(d) {
    return this.vDom || (this.containerOffset = this.getContainerOffset(d, this.containerOffset), this.eventTragetElement = d.parentElement.children[0], d.innerHTML = "", xi.render(nl.createElement(vi, { viewId: this.viewId, maranger: this, refs: {
      canvasFloatRef: this.canvasFloatRef,
      canvasBgRef: this.canvasBgRef,
      floatBarRef: this.floatBarRef,
      floatBarCanvasRef: this.floatBarCanvasRef
    } }), d), this.control.room && this.bindDisplayerEvent(this.eventTragetElement)), this;
  }
}
class Yd extends Ed {
  constructor(d) {
    super(d), Object.defineProperty(this, "focuedViewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "focuedView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.control = d.control;
  }
  bindMainView() {
    if (!this.control.divMainView)
      return;
    const d = new ZW(this.control, td.InternalMsgEmitter);
    this.focuedViewId = bd.viewId;
    const { width: l, height: i, dpr: s } = d, c = {
      dpr: s,
      originalPoint: [l / 2, i / 2],
      offscreenCanvasOpt: {
        ...Yd.defaultScreenCanvasOpt,
        width: l,
        height: i
      },
      layerOpt: {
        ...Yd.defaultLayerOpt,
        width: l,
        height: i
      },
      cameraOpt: {
        ...Yd.defaultCameraOpt,
        width: l,
        height: i
      }
    }, m = this.control.room && this.control.room.mainView || this.control.play && this.control.play.mainView;
    if (console.log("ContainerManager - bindMainView", m), m) {
      const { scale: n, ...X } = m.camera;
      c.cameraOpt = {
        ...c.cameraOpt,
        ...X,
        scale: n === 1 / 0 ? 1 : n
      }, this.createMianView({
        id: bd.viewId,
        displayer: d,
        focusScenePath: m.focusScenePath || m.scenePath,
        cameraOpt: c.cameraOpt,
        viewData: m
      }), this.focuedView = this.mainView, d.createMainViewDisplayer(this.control.divMainView);
    }
  }
  mountView(d) {
    var i;
    const l = this.getView(d);
    if (l) {
      const { width: s, height: c, dpr: m } = l.displayer, n = {
        dpr: m,
        originalPoint: [s / 2, c / 2],
        offscreenCanvasOpt: {
          ...Yd.defaultScreenCanvasOpt,
          width: s,
          height: c
        },
        layerOpt: {
          ...Yd.defaultLayerOpt,
          width: s,
          height: c
        },
        cameraOpt: {
          ...Yd.defaultCameraOpt,
          width: s,
          height: c
        }
      };
      if (l.viewData) {
        const { scale: X, ...G } = l.viewData.camera;
        n.cameraOpt = {
          ...n.cameraOpt,
          ...G,
          scale: X === 1 / 0 ? 1 : X
        };
      }
      this.control.worker.isActive || this.control.activeWorker(), (i = this.control.worker) == null || i.createViewWorker(d, n), l.focusScenePath && this.control.collector && this.control.worker.pullServiceData(d, l.focusScenePath);
    }
  }
  setFocuedViewCameraOpt(d) {
    this.focuedView && (this.focuedView.cameraOpt = d);
  }
  transformToOriginPoint(d, l) {
    const i = this.getView(l);
    if (i != null && i.viewData) {
      const s = i.viewData.convertToPointOnScreen(d[0], d[1]);
      return [s.x, s.y];
    }
    return d;
  }
  transformToScenePoint(d, l) {
    const i = this.getView(l);
    if (i != null && i.viewData) {
      const s = i.viewData.convertToPointInWorld({ x: d[0], y: d[1] });
      return [s.x, s.y];
    }
    return d;
  }
  render(d) {
    var l, i, s, c, m, n, X, G, L;
    for (const o of d) {
      const { rect: h, imageBitmap: p, isClear: r, isUnClose: V, drawCanvas: W, clearCanvas: y, offset: t, viewId: e } = o, Z = (l = this.getView(e)) == null ? void 0 : l.displayer;
      if (Z && h) {
        const { dpr: a, canvasBgRef: x, canvasFloatRef: K, floatBarCanvasRef: C } = Z, T = h.w * a, I = h.h * a, J = h.x * a, F = h.y * a;
        if (r)
          if (y === ud.Selector)
            (s = (i = C.current) == null ? void 0 : i.getContext("2d")) == null || s.clearRect(0, 0, T, I);
          else {
            const R = y === ud.Float ? (c = K.current) == null ? void 0 : c.getContext("2d") : (m = x.current) == null ? void 0 : m.getContext("2d");
            R == null || R.clearRect(J, F, T, I);
          }
        if (W && p)
          if (W === ud.Selector) {
            const R = ((t == null ? void 0 : t.x) || 0) * a, S = ((t == null ? void 0 : t.y) || 0) * a;
            (X = (n = C.current) == null ? void 0 : n.getContext("2d")) == null || X.drawImage(p, 0, 0, T, I, R, S, T, I);
          } else {
            const R = W === ud.Float ? (G = K.current) == null ? void 0 : G.getContext("2d") : (L = x.current) == null ? void 0 : L.getContext("2d");
            R == null || R.drawImage(p, 0, 0, T, I, J, F, T, I);
          }
        if (V)
          return;
        p == null || p.close();
      }
    }
  }
}
class hd extends td {
  constructor(d) {
    super(d), Object.defineProperty(this, "viewContainerManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "divMainView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: El((i) => {
        this.viewContainerManager.setFocuedViewCameraOpt(i);
      }, 20, { leading: !1 })
    });
    const l = {
      control: this,
      internalMsgEmitter: hd.InternalMsgEmitter
    };
    this.viewContainerManager = new Yd(l);
  }
  init() {
    hd.InternalMsgEmitter.on(Sl.BindMainView, (d) => {
      this.divMainView = d, this.plugin && !this.viewContainerManager.mainView && this.viewContainerManager.bindMainView();
    });
  }
  activePlugin() {
    this.plugin && this.divMainView && !this.viewContainerManager.mainView && this.viewContainerManager.bindMainView(), this.collector && (this.collector.addStorageStateListener((d) => {
      var l, i;
      if ((l = this.collector) != null && l.storage && Object.keys(this.collector.storage).length === 0) {
        (i = this.worker) == null || i.clearViewScenePath("mainView", !0);
        return;
      }
      if (d) {
        const s = /* @__PURE__ */ new Map();
        Object.keys(d).forEach((c) => {
          var n;
          const m = d[c];
          if (m) {
            const X = m.viewId, G = s.get(X) || /* @__PURE__ */ new Set();
            G.add(c), s.set(X, G), (n = this.worker) == null || n.onServiceDerive(c, m);
          }
        });
        for (const [c, m] of s.entries())
          hd.InternalMsgEmitter.emit("excludeIds", [...m], c);
      }
    }), this.room && (this.roomMember.onUidChangeHook((d) => {
      var l, i, s, c;
      if ((l = this.collector) != null && l.serviceStorage) {
        const m = [];
        this.viewContainerManager.getAllViews().forEach((n) => {
          var X, G, L;
          if (n && n.focusScenePath && ((X = this.collector) != null && X.serviceStorage[n.id]) && ((G = this.collector) != null && G.serviceStorage[n.id][n.focusScenePath])) {
            const o = Object.keys((L = this.collector) == null ? void 0 : L.serviceStorage[n.id][n.focusScenePath]).filter((h) => {
              var p;
              return (p = this.collector) == null ? void 0 : p.isSelector(h);
            }).map((h) => ({ viewId: n.id, scenePath: n.focusScenePath, key: h }));
            o.length && m.push(...o);
          }
        }), m.forEach(({ key: n, viewId: X, scenePath: G }) => {
          var o, h;
          const L = (o = this.collector) == null ? void 0 : o.getUidFromKey(n);
          L && !d.online.includes(L) && ((h = this.collector) == null || h.updateValue(n, void 0, { isAfterUpdate: !0, viewId: X, scenePath: G }));
        });
      }
      (s = (i = this.cursor) == null ? void 0 : i.eventCollector) != null && s.serviceStorage && Object.keys((c = this.cursor) == null ? void 0 : c.eventCollector.serviceStorage).forEach((n) => {
        var X, G;
        d.online.includes(n) || (G = (X = this.cursor) == null ? void 0 : X.eventCollector) == null || G.clearValue(n);
      });
    }), this.worker.isActive && this.viewContainerManager.getAllViews().forEach((d) => {
      d && d.focusScenePath && this.worker.pullServiceData(d.id, d.focusScenePath);
    })));
  }
  activeWorker() {
    this.worker.init();
  }
}
class Pd extends nl.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "mainViewRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    Pd.emiter || (Pd.emiter = hd.InternalMsgEmitter), Pd.emiter.emit(Sl.BindMainView, this.mainViewRef);
  }
  componentWillUnmount() {
    Pd.emiter.emit(Sl.DisplayState, hi.unmounted);
  }
  render() {
    return nl.createElement(
      nl.Fragment,
      null,
      this.props.children,
      nl.createElement("div", { className: "teaching-aids-plugin-main-view-displayer", ref: (d) => this.mainViewRef = d })
    );
  }
}
class ui extends bd {
  constructor(d, l) {
    super(d, l), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "vDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "eventTragetElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    });
  }
  setCanvassStyle() {
    if (this.eventTragetElement) {
      const d = this.eventTragetElement.offsetWidth || this.width, l = this.eventTragetElement.offsetHeight || this.height;
      d && l && this.canvasBgRef.current && this.canvasFloatRef.current && (this.dpr = gi(this.canvasBgRef.current.getContext("2d")), this.width = d, this.height = l, this.canvasBgRef.current.style.width = `${d}px`, this.canvasBgRef.current.style.height = `${l}px`, this.canvasFloatRef.current.style.width = `${d}px`, this.canvasFloatRef.current.style.height = `${l}px`, this.canvasFloatRef.current.width = d * this.dpr, this.canvasFloatRef.current.height = l * this.dpr, this.canvasBgRef.current.width = d * this.dpr, this.canvasBgRef.current.height = l * this.dpr);
    }
  }
  destroy() {
    if (super.destroy(), this.eventTragetElement) {
      const d = this.eventTragetElement.parentElement;
      if (d) {
        const l = d.querySelectorAll(".teaching-aids-plugin-main-view-displayer");
        for (const i of l)
          i.remove();
      }
    }
  }
  createMainViewDisplayer(d) {
    const l = document.createElement("div");
    return l.className = "teaching-aids-plugin-main-view-displayer", d.appendChild(l), this.eventTragetElement = d.children[0], this.containerOffset = this.getContainerOffset(this.eventTragetElement, this.containerOffset), this.bindToolsClass(), xi.render(nl.createElement(vi, { viewId: this.viewId, maranger: this, refs: {
      canvasFloatRef: this.canvasFloatRef,
      canvasBgRef: this.canvasBgRef,
      floatBarRef: this.floatBarRef,
      floatBarCanvasRef: this.floatBarCanvasRef
    } }), l), this.control.room && this.bindDisplayerEvent(this.eventTragetElement), this;
  }
}
class mW extends LG {
  constructor(d, l, i) {
    super(d, l, i), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "vDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "eventTragetElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: nl.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    });
  }
  setCanvassStyle() {
    if (this.eventTragetElement && this.canvasBgRef.current) {
      this.dpr = gi(this.canvasBgRef.current.getContext("2d"));
      const d = this.eventTragetElement.offsetWidth || this.width, l = this.eventTragetElement.offsetHeight || this.height;
      d && l && this.canvasFloatRef.current && (this.width = d, this.height = l, this.canvasBgRef.current.style.width = `${d}px`, this.canvasBgRef.current.style.height = `${l}px`, this.canvasFloatRef.current.style.width = `${d}px`, this.canvasFloatRef.current.style.height = `${l}px`, this.canvasFloatRef.current.width = d * this.dpr, this.canvasFloatRef.current.height = l * this.dpr, this.canvasBgRef.current.width = d * this.dpr, this.canvasBgRef.current.height = l * this.dpr);
    }
  }
  createAppViewDisplayer(d, l) {
    const i = document.createElement("div");
    return i.className = "teaching-aids-plugin-app-view-displayer", l.appendChild(i), this.eventTragetElement = l.children[0], this.containerOffset = this.getContainerOffset(this.eventTragetElement, this.containerOffset), this.bindToolsClass(), xi.render(nl.createElement(vi, { viewId: d, maranger: this, refs: {
      canvasFloatRef: this.canvasFloatRef,
      canvasBgRef: this.canvasBgRef,
      floatBarRef: this.floatBarRef,
      floatBarCanvasRef: this.floatBarCanvasRef
    } }), i), this.control.room && this.bindDisplayerEvent(this.eventTragetElement), this;
  }
}
class Xd extends Ed {
  constructor(d) {
    super(d), Object.defineProperty(this, "focuedViewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "focuedView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkScaleTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onMainViewMounted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        console.log("onMainViewMounted", l);
        const i = l.divElement;
        if (!i || !l.focusScenePath || !(l.focusScenePath || l.scenePath))
          return;
        const c = new ui(this.control, td.InternalMsgEmitter), m = l.size.width || c.width, n = l.size.height || c.height, G = {
          dpr: c.dpr,
          originalPoint: [m / 2, n / 2],
          offscreenCanvasOpt: {
            ...Xd.defaultScreenCanvasOpt,
            width: m,
            height: n
          },
          layerOpt: {
            ...Xd.defaultLayerOpt,
            width: m,
            height: n
          },
          cameraOpt: {
            ...Xd.defaultCameraOpt,
            width: m,
            height: n
          }
        }, { scale: L, ...o } = l.camera;
        if (G.cameraOpt = {
          ...G.cameraOpt,
          ...o,
          scale: L === 1 / 0 ? 1 : L
        }, this.focuedViewId = ui.viewId, this.mainView && this.mainView.displayer) {
          this.mainView.displayer.destroy();
          const h = i.getElementsByClassName("teaching-aids-plugin-main-view-displayer");
          for (const p of h)
            p.remove();
          this.mainView = void 0;
        }
        this.createMianView({
          id: ui.viewId,
          container: i,
          displayer: c,
          focusScenePath: l.focusScenePath,
          cameraOpt: G.cameraOpt,
          viewData: l
        }), this.focuedView = this.mainView, c.createMainViewDisplayer(i), l.callbacks.on("onSizeUpdated", this.onMainViewSizeUpdated), l.callbacks.on("onCameraUpdated", this.onMainViewCameraUpdated);
      }
    }), Object.defineProperty(this, "onMainViewSizeUpdated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async () => {
        Promise.resolve().then(() => {
          if (this.mainView && this.mainView.viewData) {
            const l = this.mainView.viewData.size, i = this.mainView.cameraOpt;
            i && (this.mainView.displayer.updateSize(), this.mainView.cameraOpt = { ...i, ...l });
          }
        });
      }
    }), Object.defineProperty(this, "onMainViewCameraUpdated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async () => {
        Promise.resolve().then(() => {
          if (this.mainView && this.mainView.viewData) {
            const l = this.mainView.viewData.camera, i = this.mainView.cameraOpt;
            if (i) {
              const s = l.scale === 1 / 0 ? 1 : l.scale, c = l.centerX || 0, m = l.centerY || 0;
              this.mainView.cameraOpt = { ...i, scale: s, centerX: c, centerY: m }, this.checkScaleTimer && l.scale == 1 / 0 && (clearTimeout(this.checkScaleTimer), this.checkScaleTimer = void 0), !this.checkScaleTimer && l.scale === 1 / 0 && this.mainView.viewData && this.mainView.viewData.camera.scale === 1 / 0 && (this.checkScaleTimer = setTimeout(() => {
                var n, X;
                (X = (n = this.mainView) == null ? void 0 : n.viewData) == null || X.moveCamera({ scale: s, centerX: c, centerY: m, animationMode: "immediately" }), this.checkScaleTimer = void 0;
              }, 500));
            }
          }
        });
      }
    }), Object.defineProperty(this, "onAppViewMounted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        const { appId: i, view: s } = l, c = s.divElement;
        if (!c || !s.focusScenePath)
          return;
        const m = new mW(i, this.control, td.InternalMsgEmitter), n = s.size.width || m.width, X = s.size.height || m.height, L = {
          dpr: m.dpr,
          originalPoint: [n / 2, X / 2],
          offscreenCanvasOpt: {
            ...Xd.defaultScreenCanvasOpt,
            width: n,
            height: X
          },
          layerOpt: {
            ...Xd.defaultLayerOpt,
            width: n,
            height: X
          },
          cameraOpt: {
            ...Xd.defaultCameraOpt,
            ...s.camera,
            width: n,
            height: X
          }
        };
        this.createAppView({
          id: i,
          container: c,
          displayer: m,
          cameraOpt: L.cameraOpt,
          focusScenePath: s.focusScenePath,
          viewData: s
        }), m.createAppViewDisplayer(i, c), s.callbacks.on("onSizeUpdated", this.onAppViewSizeUpdated.bind(this, i)), s.callbacks.on("onCameraUpdated", this.onAppViewCameraUpdated.bind(this, i));
      }
    }), Object.defineProperty(this, "onAppViewSizeUpdated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (l) => {
        Promise.resolve().then(() => {
          const i = this.appViews.get(l);
          if (i && i.viewData) {
            const s = i.viewData.size, c = i.cameraOpt;
            c && (i.displayer.updateSize(), i.cameraOpt = { ...c, ...s });
          }
        });
      }
    }), Object.defineProperty(this, "onAppViewCameraUpdated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (l) => {
        Promise.resolve().then(() => {
          const i = this.appViews.get(l);
          if (i && i.viewData) {
            const s = i.viewData.camera, c = i.cameraOpt;
            if (c) {
              const m = s.scale === 1 / 0 ? 1 : s.scale, n = s.centerX || 0, X = s.centerY || 0;
              i.cameraOpt = { ...c, scale: m, centerX: n, centerY: X };
            }
          }
        });
      }
    }), this.control = d.control;
  }
  mountView(d) {
    var i, s;
    const l = this.getView(d);
    if (l) {
      const { width: c, height: m, dpr: n } = l.displayer, X = {
        dpr: n,
        originalPoint: [c / 2, m / 2],
        offscreenCanvasOpt: {
          ...Xd.defaultScreenCanvasOpt,
          width: c,
          height: m
        },
        layerOpt: {
          ...Xd.defaultLayerOpt,
          width: c,
          height: m
        },
        cameraOpt: {
          ...Xd.defaultCameraOpt,
          width: c,
          height: m
        }
      };
      if (l.viewData) {
        const { scale: G, ...L } = l.viewData.camera;
        X.cameraOpt = {
          ...X.cameraOpt,
          ...L,
          scale: G === 1 / 0 ? 1 : G
        };
      }
      d === ((i = this.mainView) == null ? void 0 : i.id) && this.control.activeWorker(), (s = this.control.worker) == null || s.createViewWorker(d, X), l.focusScenePath && this.control.collector && this.control.worker.pullServiceData(d, l.focusScenePath);
    }
  }
  setFocuedViewCameraOpt(d) {
    this.focuedView && (this.focuedView.cameraOpt = d);
  }
  listenerWindowManager(d) {
    d.emitter.on("boxStateChange", (l) => {
      l !== "minimized" && setTimeout(() => {
        this.appViews.forEach((i) => {
          i.displayer.reflashContainerOffset();
        });
      }, 100);
    }), d.emitter.on("focusedChange", (l) => {
      const i = l || bd.viewId;
      if (this.focuedViewId !== i) {
        const s = this.getView(i);
        s && (s.displayer.reflashContainerOffset(), this.setFocuedViewId(i));
      }
    }), d.emitter.on("mainViewScenePathChange", (l) => {
      this.mainView && (this.mainView.focusScenePath = l);
    }), d.emitter.on("onMainViewMounted", this.onMainViewMounted), d.emitter.on("onAppViewMounted", this.onAppViewMounted), d.emitter.on("onAppSetup", (l) => {
      const i = this.appViews.get(l);
      i && i.displayer && i.displayer.reflashContainerOffset();
    }), d.emitter.on("onBoxMove", (l) => {
      const i = this.getView(l.appId);
      i && i.displayer.reflashContainerOffset();
    }), d.emitter.on("onBoxResize", (l) => {
      const i = this.getView(l.appId);
      i && i.displayer.reflashContainerOffset();
    }), d.emitter.on("onBoxFocus", (l) => {
      const i = this.getView(l.appId);
      i && i.displayer.reflashContainerOffset();
    }), d.emitter.on("onBoxClose", (l) => {
      this.appViews.get(l.appId) && (this.destroyAppView(l.appId), this.control.worker.destroyViewWorker(l.appId));
    }), d.emitter.on("onBoxStateChange", (l) => {
      const i = this.getView(l.appId);
      i && i.displayer.reflashContainerOffset();
    }), d.emitter.on("onAppScenePathChange", (l) => {
      const { appId: i, view: s } = l, c = this.getView(i);
      if (c) {
        const m = s.focusScenePath;
        m && (c.focusScenePath = m);
      }
    });
  }
  transformToOriginPoint(d, l) {
    const i = this.getView(l);
    if (i != null && i.viewData) {
      const s = i.viewData.convertToPointOnScreen(d[0], d[1]);
      return [s.x, s.y];
    }
    return d;
  }
  transformToScenePoint(d, l) {
    const i = this.getView(l);
    if (i != null && i.viewData) {
      const s = i.viewData.convertToPointInWorld({ x: d[0], y: d[1] });
      return [s.x, s.y];
    }
    return d;
  }
  render(d) {
    var l, i, s, c, m, n, X, G, L;
    for (const o of d) {
      const { rect: h, imageBitmap: p, isClear: r, isUnClose: V, drawCanvas: W, clearCanvas: y, offset: t, viewId: e } = o, Z = (l = this.getView(e)) == null ? void 0 : l.displayer;
      if (Z && h) {
        const { dpr: a, canvasBgRef: x, canvasFloatRef: K, floatBarCanvasRef: C } = Z, T = h.w * a, I = h.h * a, J = h.x * a, F = h.y * a;
        if (r)
          if (y === ud.Selector)
            (s = (i = C.current) == null ? void 0 : i.getContext("2d")) == null || s.clearRect(0, 0, T, I);
          else {
            const R = y === ud.Float ? (c = K.current) == null ? void 0 : c.getContext("2d") : (m = x.current) == null ? void 0 : m.getContext("2d");
            R == null || R.clearRect(J, F, T, I);
          }
        if (W && p)
          if (W === ud.Selector) {
            const R = ((t == null ? void 0 : t.x) || 0) * a, S = ((t == null ? void 0 : t.y) || 0) * a;
            (X = (n = C.current) == null ? void 0 : n.getContext("2d")) == null || X.drawImage(p, 0, 0, T, I, R, S, T, I);
          } else {
            const R = W === ud.Float ? (G = K.current) == null ? void 0 : G.getContext("2d") : (L = x.current) == null ? void 0 : L.getContext("2d");
            R == null || R.drawImage(p, 0, 0, T, I, J, F, T, I);
          }
        if (V)
          return;
        p == null || p.close();
      }
    }
  }
}
class nW extends td {
  constructor(d) {
    super(d), Object.defineProperty(this, "windowManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewContainerManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const l = {
      control: this,
      internalMsgEmitter: td.InternalMsgEmitter
    };
    this.viewContainerManager = new Xd(l);
  }
  init() {
  }
  destroy() {
    var d, l, i, s;
    this.roomMember.destroy(), (d = this.collector) == null || d.destroy(), (l = this.worker) == null || l.destroy(), (i = this.viewContainerManager) == null || i.destroy(), (s = this.cursor) == null || s.destroy();
  }
  activePlugin() {
    this.collector && (this.collector.addStorageStateListener((d) => {
      var l, i;
      if ((l = this.collector) != null && l.storage && Object.keys(this.collector.storage).length === 0) {
        (i = this.worker) == null || i.clearViewScenePath("mainView", !0);
        return;
      }
      d && (Object.keys(d).forEach((s) => {
        var m;
        const c = d[s];
        c && ((m = this.worker) == null || m.onServiceDerive(s, c));
      }), td.InternalMsgEmitter.emit("excludeIds", Object.keys(d)));
    }), this.room && this.roomMember.onUidChangeHook((d) => {
      var l, i, s, c;
      if ((l = this.collector) != null && l.serviceStorage) {
        const m = [];
        this.viewContainerManager.getAllViews().forEach((n) => {
          var X;
          if (n && n.focusScenePath && ((X = this.collector) != null && X.serviceStorage[n.id]) && this.collector.serviceStorage[n.id][n.focusScenePath]) {
            const G = Object.keys(this.collector.serviceStorage[n.id][n.focusScenePath]).filter((L) => {
              var o;
              return (o = this.collector) == null ? void 0 : o.isSelector(L);
            }).map((L) => ({ viewId: n.id, scenePath: n.focusScenePath, key: L }));
            G.length && m.push(...G);
          }
        }), m.forEach(({ key: n, viewId: X, scenePath: G }) => {
          var o, h;
          const L = (o = this.collector) == null ? void 0 : o.getUidFromKey(n);
          L && !d.online.includes(L) && ((h = this.collector) == null || h.updateValue(n, void 0, { isAfterUpdate: !0, viewId: X, scenePath: G }));
        });
      }
      (s = (i = this.cursor) == null ? void 0 : i.eventCollector) != null && s.serviceStorage && Object.keys((c = this.cursor) == null ? void 0 : c.eventCollector.serviceStorage).forEach((n) => {
        var X, G;
        d.online.includes(n) || (G = (X = this.cursor) == null ? void 0 : X.eventCollector) == null || G.clearValue(n);
      });
    }), this.worker.isActive && this.viewContainerManager.getAllViews().forEach((d) => {
      d && d.focusScenePath && this.worker.pullServiceData(d.id, d.focusScenePath);
    }));
  }
  activeWorker() {
    this.worker.init();
  }
  setWindowManager(d) {
    var l, i, s, c;
    this.windowManager = d, (l = this.windowManager) != null && l.mainView && this.viewContainerManager.onMainViewMounted(this.windowManager.mainView), (c = (s = (i = this.windowManager.appManager) == null ? void 0 : i.viewManager) == null ? void 0 : s.views) != null && c.size && this.windowManager.appManager.viewManager.views.forEach((m, n) => {
      this.viewContainerManager.onAppViewMounted({ appId: n, view: m });
    }), this.viewContainerManager.listenerWindowManager(this.windowManager);
  }
}
class Ll extends yt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "onPhaseChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (d) => {
        d === wi.Disconnected && (this.displayer.callbacks.off(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.off("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.off("onPhaseChanged", this.onPhaseChanged), console.log("[TeachingAidsPlugin plugin] Disconnected"), this.destroy()), d === wi.Reconnecting && (console.log("[TeachingAidsPlugin plugin] Reconnecting"), this.init(this.displayer));
      }
    }), Object.defineProperty(this, "updateRoomWritable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        var d;
        (d = Ll.currentManager) == null || d.onWritableChange(this.displayer.isWritable);
      }
    }), Object.defineProperty(this, "roomStateChangeListener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (d) => {
        var l, i;
        Ll.currentManager instanceof hd && (d.cameraState && Ll.currentManager.onCameraChange(d.cameraState), d.sceneState && Ll.currentManager.onSceneChange(d.sceneState.scenePath, "mainView")), !(Gd(this.displayer) && !this.displayer.isWritable) && (d.memberState && ((l = Ll.currentManager) == null || l.onMemberChange(d.memberState)), d != null && d.roomMembers && ((i = Ll.currentManager) == null || i.onRoomMembersChange(d.roomMembers)));
      }
    });
  }
  static async getInstance(d, l) {
    const i = d instanceof xt;
    Ll.windowManager = i && d || void 0, l != null && l.logger && (Ll.logger = l.logger), l != null && l.options && (Ll.options = l.options), l != null && l.cursorAdapter && (Ll.cursorAdapter = l.cursorAdapter, Ll.effectInstance());
    const s = i ? d.displayer : d;
    let c = s.getInvisiblePlugin(Ll.kind);
    s && Ll.createCurrentManager(s, Ll.options, c, Ll.windowManager), !c && Gd(s) && (c = await Ll.createTeachingAidsPlugin(s, Ll.kind)), c && Ll.currentManager && (Ll.currentManager.bindPlugin(c), c.init(s));
    const m = {
      plugin: c,
      displayer: s,
      windowManager: i && d || void 0,
      getBoundingRectAsync: async function(n) {
        var L;
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] getBoundingRect");
        const X = (this.windowManager && this.windowManager.mainView || this.displayer).getBoundingRect(n), G = await ((L = Ll.currentManager) == null ? void 0 : L.getBoundingRect(n));
        return Vo(X, G);
      },
      screenshotToCanvasAsync: async function(n, X, G, L, o, h) {
        var V;
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] screenshotToCanvasAsync");
        const p = document.createElement("canvas"), r = p.getContext("2d");
        p.width = G * (h || 1), p.height = L * (h || 1), r && ((this.windowManager && this.windowManager.mainView || this.displayer).screenshotToCanvas(r, X, G, L, o, h), n.drawImage(p, 0, 0, G * (h || 1), L * (h || 1), 0, 0, G, L), p.remove()), Ll.currentManager && await ((V = Ll.currentManager) == null ? void 0 : V.screenshotToCanvas(n, X, G, L, o));
      },
      scenePreviewAsync: async function(n, X, G, L, o) {
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] scenePreview"), (this.windowManager && this.windowManager.mainView || this.displayer).scenePreview(n, X, G, L, o);
        const h = document.createElement("img");
        h.style.position = "absolute", h.style.top = "0px", h.style.left = "0px", h.style.width = "100%", h.style.height = "100%", h.style.pointerEvents = "none", X.append(h), getComputedStyle(X).position || (X.style.position = "relative"), Ll.currentManager && await Ll.currentManager.scenePreview(n, h);
      },
      callbacksOn: function(n, X) {
        Ll.logger.info(`[TeachingAidsSinglePlugin plugin] callbacks ${n}`), (n === "onCanUndoStepsUpdate" || n === "onCanRedoStepsUpdate") && Gd(this.displayer) && this.displayer.isWritable ? hd.InternalMsgEmitter.on(n, X) : this.displayer.callbacks.on(n, X);
      },
      callbacksOnce: function(n, X) {
        Ll.logger.info(`[TeachingAidsSinglePlugin plugin] callbacks ${n}`), (n === "onCanUndoStepsUpdate" || n === "onCanRedoStepsUpdate") && Gd(this.displayer) && this.displayer.isWritable ? hd.InternalMsgEmitter.on(n, X) : this.displayer.callbacks.on(n, X);
      },
      callbacksOff: function(n, X) {
        Ll.logger.info(`[TeachingAidsSinglePlugin plugin] callbacks ${n}`), (n === "onCanUndoStepsUpdate" || n === "onCanRedoStepsUpdate") && Gd(this.displayer) && this.displayer.isWritable ? hd.InternalMsgEmitter.off(n, X) : this.displayer.callbacks.off(n, X);
      },
      undo: function() {
        return Ll.logger.info("[TeachingAidsSinglePlugin plugin] undo"), Ll.currentManager && Gd(this.displayer) && !this.displayer.disableSerialization ? Ll.currentManager.viewContainerManager.undo() : 0;
      },
      redo: function() {
        return Ll.logger.info("[TeachingAidsSinglePlugin plugin] redo"), Ll.currentManager && Gd(this.displayer) && !this.displayer.disableSerialization ? Ll.currentManager.viewContainerManager.redo() : 0;
      },
      cleanCurrentScene: function(n) {
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] cleanCurrentScene"), Ll.currentManager && Gd(this.displayer) && this.displayer.isWritable && (Ll.currentManager.cleanCurrentScene(), this.displayer.cleanCurrentScene(n));
      }
    };
    return {
      ...m,
      callbacks: {
        on: m.callbacksOn.bind(m),
        once: m.callbacksOnce.bind(m),
        off: m.callbacksOff.bind(m),
        forwardTo: m.displayer.callbacks.forwardTo
      }
    };
  }
  static onCreate(d) {
    console.log("onCreate", d, Ll.options, Ll.windowManager), d && Ll.currentManager && (Ll.currentManager.bindPlugin(d), d.init(d.displayer));
  }
  static async createTeachingAidsPlugin(d, l) {
    await d.createInvisiblePlugin(Ll, {});
    let i = d.getInvisiblePlugin(l);
    return i || (i = await Ll.createTeachingAidsPlugin(d, l)), i;
  }
  // static onDestroy(plugin: TeachingAidsPlugin) {}
  /**
   * 房间实例化时，将当前实例对displayer外部API的添加内部处理逻辑;
   * @param displayer
   */
  static effectInstance() {
    if (Ll.cursorAdapter) {
      if (Ll.options && Ll.windowManager) {
        Ll.logger.warn("[TeachingAidsPlugin plugin] cursorAdapter is Invalid configuration data in MultiView");
        return;
      }
      const d = Ll.cursorAdapter.onAddedCursor;
      Ll.cursorAdapter.onAddedCursor = function(l) {
        l.onCursorMemberChanged = (i) => {
          try {
            i.appliance === zl.pencil || i.appliance === zl.shape || i.appliance === zl.text || i.appliance === zl.arrow || i.appliance === zl.straight || i.appliance === zl.rectangle || i.appliance === zl.ellipse ? l != null && l.divElement && (l.divElement.style.display = "none") : l != null && l.divElement && (l.divElement.style.display = "block");
          } catch {
          }
        }, d.call(Ll.cursorAdapter, l);
      };
    }
  }
  get isReplay() {
    return vs(this.displayer);
  }
  get callbackName() {
    return this.isReplay ? "onPlayerStateChanged" : "onRoomStateChanged";
  }
  init(d) {
    var l;
    if (Gd(d)) {
      const i = d.state;
      i != null && i.memberState && ((l = Ll.currentManager) == null || l.onMemberChange(i.memberState));
    }
    this.displayer.callbacks.on(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.on("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.on("onPhaseChanged", this.onPhaseChanged);
  }
  destroy() {
    var d;
    (d = Ll.currentManager) == null || d.destroy(), Ll.currentManager = void 0, Ll.windowManager = void 0, Ll.cursorAdapter = void 0;
  }
}
Object.defineProperty(Ll, "kind", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "teaching-aids-plugin"
});
Object.defineProperty(Ll, "logger", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    info: console.log,
    warn: console.warn,
    error: console.error
  }
});
Object.defineProperty(Ll, "options", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    syncOpt: {
      interval: 300
    },
    canvasOpt: {
      contextType: qd.Canvas2d
    }
  }
});
Object.defineProperty(Ll, "createCurrentManager", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: (b, d, l, i) => {
    Ll.currentManager && Ll.currentManager.destroy();
    let s;
    const c = {
      plugin: l,
      displayer: b,
      options: d
    };
    d && i ? (s = new nW(c), Ll.logger.info("[TeachingAidsPlugin plugin] refresh TeachingAidsMultiManager object"), s.setWindowManager(i)) : (s = new hd(c), s.init(), Ll.logger.info("[TeachingAidsPlugin plugin] refresh TeachingAidsSingleManager object")), Ll.currentManager = s;
  }
});
export {
  qd as ECanvasContextType,
  Ll as TeachingAidsPlugin,
  Pd as TeachingAidsSigleWrapper
};
