import * as Ul from "react";
import il, { useContext as _l, useState as Fl, useMemo as Nl, useEffect as Ql, useRef as Nd, useCallback as Rs } from "react";
import Qt from "eventemitter2";
import { toJS as wt, autorun as Pt, ApplianceNames as Tl, isRoom as cd, isPlayer as ft, InvisiblePlugin as Ss } from "white-web-sdk";
import { decompress as Ks, compress as Cs } from "lz-string";
import "lineclip";
import { cloneDeep as Bi } from "lodash";
import Ci from "react-dom";
import Bd from "react-draggable";
import { Resizable as Js } from "re-resizable";
import { WindowManager as Ns } from "@netless/window-manager";
var Ii;
(function(m) {
  m[m.pedding = 0] = "pedding", m[m.mounted = 1] = "mounted", m[m.update = 2] = "update", m[m.unmounted = 3] = "unmounted";
})(Ii || (Ii = {}));
var di;
(function(m) {
  m[m.Normal = 0] = "Normal", m[m.Stroke = 1] = "Stroke", m[m.Dotted = 2] = "Dotted", m[m.LongDotted = 3] = "LongDotted";
})(di || (di = {}));
var Gd;
(function(m) {
  m.Triangle = "triangle", m.Rhombus = "rhombus", m.Pentagram = "pentagram", m.SpeechBalloon = "speechBalloon", m.Star = "star", m.Polygon = "polygon";
})(Gd || (Gd = {}));
var ul;
(function(m) {
  m.None = "None", m.ShowFloatBar = "ShowFloatBar", m.ZIndexFloatBar = "ZIndexFloatBar", m.DeleteNode = "DeleteNode", m.CopyNode = "CopyNode", m.ZIndexActive = "ZIndexActive", m.ZIndexNode = "ZIndexNode", m.RotateNode = "RotateNode", m.SetColorNode = "SetColorNode", m.TranslateNode = "TranslateNode", m.ScaleNode = "ScaleNode", m.OriginalEvent = "OriginalEvent", m.CreateScene = "CreateScene", m.ActiveCursor = "ActiveCursor", m.MoveCursor = "MoveCursor", m.CommandEditor = "CommandEditor", m.SetEditorData = "SetEditorData", m.SetFontStyle = "SetFontStyle", m.SetPoint = "SetPoint", m.SetLock = "SetLock", m.SetShapeOpt = "SetShapeOpt";
})(ul || (ul = {}));
var Yl;
(function(m) {
  m.DisplayState = "DisplayState", m.FloatBar = "FloatBar", m.CanvasSelector = "CanvasSelector", m.MainEngine = "MainEngine", m.DisplayContainer = "DisplayContainer", m.Cursor = "Cursor", m.TextEditor = "TextEditor", m.BindMainView = "BindMainView", m.MountMainView = "MountMainView", m.MountAppView = "MountAppView";
})(Yl || (Yl = {}));
var Oi;
(function(m) {
  m[m.MainView = 0] = "MainView", m[m.Plugin = 1] = "Plugin", m[m.Both = 2] = "Both";
})(Oi || (Oi = {}));
const Vd = "++", Il = "selector", Ts = "all";
class jt {
  constructor(d) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.plugin = d, this.uid = d.displayer.uid;
  }
  getNamespaceData() {
    var d;
    return wt((d = this.plugin) == null ? void 0 : d.attributes[this.namespace]) || {};
  }
  getUidFromKey(d) {
    return d.split(Vd).length === 2 && d.split(Vd)[0] || this.uid;
  }
  isLocalId(d) {
    return d.split(Vd).length === 1;
  }
  getLocalId(d) {
    return d.split(Vd)[1];
  }
  isSelector(d) {
    return this.getLocalId(d) === Il;
  }
}
var bl;
(function(m) {
  m[m.Pencil = 1] = "Pencil", m[m.Eraser = 2] = "Eraser", m[m.Selector = 3] = "Selector", m[m.Clicker = 4] = "Clicker", m[m.Arrow = 5] = "Arrow", m[m.Hand = 6] = "Hand", m[m.LaserPen = 7] = "LaserPen", m[m.Text = 8] = "Text", m[m.Straight = 9] = "Straight", m[m.Rectangle = 10] = "Rectangle", m[m.Ellipse = 11] = "Ellipse", m[m.Star = 12] = "Star", m[m.Triangle = 13] = "Triangle", m[m.Rhombus = 14] = "Rhombus", m[m.Polygon = 15] = "Polygon", m[m.SpeechBalloon = 16] = "SpeechBalloon", m[m.Image = 17] = "Image";
})(bl || (bl = {}));
var Jl;
(function(m) {
  m[m.Local = 1] = "Local", m[m.Service = 2] = "Service", m[m.Worker = 3] = "Worker";
})(Jl || (Jl = {}));
var hl;
(function(m) {
  m[m.Pending = 0] = "Pending", m[m.Start = 1] = "Start", m[m.Doing = 2] = "Doing", m[m.Done = 3] = "Done", m[m.Freeze = 4] = "Freeze", m[m.Unwritable = 5] = "Unwritable";
})(hl || (hl = {}));
var Vl;
(function(m) {
  m[m.None = 0] = "None", m[m.Init = 1] = "Init", m[m.UpdateCamera = 2] = "UpdateCamera", m[m.UpdateTools = 3] = "UpdateTools", m[m.CreateWork = 4] = "CreateWork", m[m.DrawWork = 5] = "DrawWork", m[m.FullWork = 6] = "FullWork", m[m.UpdateNode = 7] = "UpdateNode", m[m.RemoveNode = 8] = "RemoveNode", m[m.Clear = 9] = "Clear", m[m.Select = 10] = "Select", m[m.Destroy = 11] = "Destroy", m[m.Snapshot = 12] = "Snapshot", m[m.BoundingBox = 13] = "BoundingBox", m[m.Cursor = 14] = "Cursor", m[m.TextUpdate = 15] = "TextUpdate", m[m.GetTextActive = 16] = "GetTextActive", m[m.TasksQueue = 17] = "TasksQueue", m[m.CursorHover = 18] = "CursorHover";
})(Vl || (Vl = {}));
var ii;
(function(m) {
  m.Webgl2 = "webgl2", m.Webgl = "webgl", m.Canvas2d = "2d";
})(ii || (ii = {}));
var pd;
(function(m) {
  m[m.Float = 1] = "Float", m[m.Bg = 2] = "Bg", m[m.Selector = 3] = "Selector", m[m.None = 4] = "None";
})(pd || (pd = {}));
var Jd;
(function(m) {
  m[m.Cursor = 1] = "Cursor", m[m.TextCreate = 2] = "TextCreate";
})(Jd || (Jd = {}));
var Cd;
(function(m) {
  m[m.Top = 1] = "Top", m[m.Bottom = 2] = "Bottom";
})(Cd || (Cd = {}));
var Zd;
(function(m) {
  m[m.none = 1] = "none", m[m.all = 2] = "all", m[m.both = 3] = "both", m[m.proportional = 4] = "proportional";
})(Zd || (Zd = {}));
function Fs(m) {
  return JSON.parse(Ks(m));
}
function Hs(m) {
  return Cs(JSON.stringify(m));
}
const nd = Object.keys;
var Dd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Td(m) {
  return m && m.__esModule && Object.prototype.hasOwnProperty.call(m, "default") ? m.default : m;
}
function Ms() {
  this.__data__ = [], this.size = 0;
}
var zs = Ms;
function gs(m, d) {
  return m === d || m !== m && d !== d;
}
var Ji = gs, ks = Ji;
function vs(m, d) {
  for (var l = m.length; l--; )
    if (ks(m[l][0], d))
      return l;
  return -1;
}
var mi = vs, Us = mi, Qs = Array.prototype, ws = Qs.splice;
function Ps(m) {
  var d = this.__data__, l = Us(d, m);
  if (l < 0)
    return !1;
  var i = d.length - 1;
  return l == i ? d.pop() : ws.call(d, l, 1), --this.size, !0;
}
var fs = Ps, js = mi;
function Es(m) {
  var d = this.__data__, l = js(d, m);
  return l < 0 ? void 0 : d[l][1];
}
var Bs = Es, Os = mi;
function Ds(m) {
  return Os(this.__data__, m) > -1;
}
var As = Ds, qs = mi;
function $s(m, d) {
  var l = this.__data__, i = qs(l, m);
  return i < 0 ? (++this.size, l.push([m, d])) : l[i][1] = d, this;
}
var _s = $s, lc = zs, dc = fs, ic = Bs, tc = As, sc = _s;
function kd(m) {
  var d = -1, l = m == null ? 0 : m.length;
  for (this.clear(); ++d < l; ) {
    var i = m[d];
    this.set(i[0], i[1]);
  }
}
kd.prototype.clear = lc;
kd.prototype.delete = dc;
kd.prototype.get = ic;
kd.prototype.has = tc;
kd.prototype.set = sc;
var ni = kd, cc = ni;
function bc() {
  this.__data__ = new cc(), this.size = 0;
}
var Zc = bc;
function mc(m) {
  var d = this.__data__, l = d.delete(m);
  return this.size = d.size, l;
}
var nc = mc;
function ec(m) {
  return this.__data__.get(m);
}
var oc = ec;
function ac(m) {
  return this.__data__.has(m);
}
var Xc = ac, Gc = typeof Dd == "object" && Dd && Dd.Object === Object && Dd, Et = Gc, Wc = Et, uc = typeof self == "object" && self && self.Object === Object && self, hc = Wc || uc || Function("return this")(), ud = hc, Vc = ud, pc = Vc.Symbol, ei = pc, Di = ei, Bt = Object.prototype, yc = Bt.hasOwnProperty, Lc = Bt.toString, jd = Di ? Di.toStringTag : void 0;
function Ic(m) {
  var d = yc.call(m, jd), l = m[jd];
  try {
    m[jd] = void 0;
    var i = !0;
  } catch {
  }
  var t = Lc.call(m);
  return i && (d ? m[jd] = l : delete m[jd]), t;
}
var Yc = Ic, xc = Object.prototype, rc = xc.toString;
function Rc(m) {
  return rc.call(m);
}
var Sc = Rc, Ai = ei, Kc = Yc, Cc = Sc, Jc = "[object Null]", Nc = "[object Undefined]", qi = Ai ? Ai.toStringTag : void 0;
function Tc(m) {
  return m == null ? m === void 0 ? Nc : Jc : qi && qi in Object(m) ? Kc(m) : Cc(m);
}
var Fd = Tc;
function Fc(m) {
  var d = typeof m;
  return m != null && (d == "object" || d == "function");
}
var Sd = Fc, Hc = Fd, Mc = Sd, zc = "[object AsyncFunction]", gc = "[object Function]", kc = "[object GeneratorFunction]", vc = "[object Proxy]";
function Uc(m) {
  if (!Mc(m))
    return !1;
  var d = Hc(m);
  return d == gc || d == kc || d == zc || d == vc;
}
var Ot = Uc, Qc = ud, wc = Qc["__core-js_shared__"], Pc = wc, hi = Pc, $i = function() {
  var m = /[^.]+$/.exec(hi && hi.keys && hi.keys.IE_PROTO || "");
  return m ? "Symbol(src)_1." + m : "";
}();
function fc(m) {
  return !!$i && $i in m;
}
var jc = fc, Ec = Function.prototype, Bc = Ec.toString;
function Oc(m) {
  if (m != null) {
    try {
      return Bc.call(m);
    } catch {
    }
    try {
      return m + "";
    } catch {
    }
  }
  return "";
}
var Dt = Oc, Dc = Ot, Ac = jc, qc = Sd, $c = Dt, _c = /[\\^$.*+?()[\]{}|]/g, lb = /^\[object .+?Constructor\]$/, db = Function.prototype, ib = Object.prototype, tb = db.toString, sb = ib.hasOwnProperty, cb = RegExp(
  "^" + tb.call(sb).replace(_c, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function bb(m) {
  if (!qc(m) || Ac(m))
    return !1;
  var d = Dc(m) ? cb : lb;
  return d.test($c(m));
}
var Zb = bb;
function mb(m, d) {
  return m == null ? void 0 : m[d];
}
var nb = mb, eb = Zb, ob = nb;
function ab(m, d) {
  var l = ob(m, d);
  return eb(l) ? l : void 0;
}
var Hd = ab, Xb = Hd, Gb = ud, Wb = Xb(Gb, "Map"), Ni = Wb, ub = Hd, hb = ub(Object, "create"), oi = hb, _i = oi;
function Vb() {
  this.__data__ = _i ? _i(null) : {}, this.size = 0;
}
var pb = Vb;
function yb(m) {
  var d = this.has(m) && delete this.__data__[m];
  return this.size -= d ? 1 : 0, d;
}
var Lb = yb, Ib = oi, Yb = "__lodash_hash_undefined__", xb = Object.prototype, rb = xb.hasOwnProperty;
function Rb(m) {
  var d = this.__data__;
  if (Ib) {
    var l = d[m];
    return l === Yb ? void 0 : l;
  }
  return rb.call(d, m) ? d[m] : void 0;
}
var Sb = Rb, Kb = oi, Cb = Object.prototype, Jb = Cb.hasOwnProperty;
function Nb(m) {
  var d = this.__data__;
  return Kb ? d[m] !== void 0 : Jb.call(d, m);
}
var Tb = Nb, Fb = oi, Hb = "__lodash_hash_undefined__";
function Mb(m, d) {
  var l = this.__data__;
  return this.size += this.has(m) ? 0 : 1, l[m] = Fb && d === void 0 ? Hb : d, this;
}
var zb = Mb, gb = pb, kb = Lb, vb = Sb, Ub = Tb, Qb = zb;
function vd(m) {
  var d = -1, l = m == null ? 0 : m.length;
  for (this.clear(); ++d < l; ) {
    var i = m[d];
    this.set(i[0], i[1]);
  }
}
vd.prototype.clear = gb;
vd.prototype.delete = kb;
vd.prototype.get = vb;
vd.prototype.has = Ub;
vd.prototype.set = Qb;
var wb = vd, lt = wb, Pb = ni, fb = Ni;
function jb() {
  this.size = 0, this.__data__ = {
    hash: new lt(),
    map: new (fb || Pb)(),
    string: new lt()
  };
}
var Eb = jb;
function Bb(m) {
  var d = typeof m;
  return d == "string" || d == "number" || d == "symbol" || d == "boolean" ? m !== "__proto__" : m === null;
}
var Ob = Bb, Db = Ob;
function Ab(m, d) {
  var l = m.__data__;
  return Db(d) ? l[typeof d == "string" ? "string" : "hash"] : l.map;
}
var ai = Ab, qb = ai;
function $b(m) {
  var d = qb(this, m).delete(m);
  return this.size -= d ? 1 : 0, d;
}
var _b = $b, lZ = ai;
function dZ(m) {
  return lZ(this, m).get(m);
}
var iZ = dZ, tZ = ai;
function sZ(m) {
  return tZ(this, m).has(m);
}
var cZ = sZ, bZ = ai;
function ZZ(m, d) {
  var l = bZ(this, m), i = l.size;
  return l.set(m, d), this.size += l.size == i ? 0 : 1, this;
}
var mZ = ZZ, nZ = Eb, eZ = _b, oZ = iZ, aZ = cZ, XZ = mZ;
function Ud(m) {
  var d = -1, l = m == null ? 0 : m.length;
  for (this.clear(); ++d < l; ) {
    var i = m[d];
    this.set(i[0], i[1]);
  }
}
Ud.prototype.clear = nZ;
Ud.prototype.delete = eZ;
Ud.prototype.get = oZ;
Ud.prototype.has = aZ;
Ud.prototype.set = XZ;
var At = Ud, GZ = ni, WZ = Ni, uZ = At, hZ = 200;
function VZ(m, d) {
  var l = this.__data__;
  if (l instanceof GZ) {
    var i = l.__data__;
    if (!WZ || i.length < hZ - 1)
      return i.push([m, d]), this.size = ++l.size, this;
    l = this.__data__ = new uZ(i);
  }
  return l.set(m, d), this.size = l.size, this;
}
var pZ = VZ, yZ = ni, LZ = Zc, IZ = nc, YZ = oc, xZ = Xc, rZ = pZ;
function Qd(m) {
  var d = this.__data__ = new yZ(m);
  this.size = d.size;
}
Qd.prototype.clear = LZ;
Qd.prototype.delete = IZ;
Qd.prototype.get = YZ;
Qd.prototype.has = xZ;
Qd.prototype.set = rZ;
var qt = Qd, RZ = "__lodash_hash_undefined__";
function SZ(m) {
  return this.__data__.set(m, RZ), this;
}
var KZ = SZ;
function CZ(m) {
  return this.__data__.has(m);
}
var JZ = CZ, NZ = At, TZ = KZ, FZ = JZ;
function ti(m) {
  var d = -1, l = m == null ? 0 : m.length;
  for (this.__data__ = new NZ(); ++d < l; )
    this.add(m[d]);
}
ti.prototype.add = ti.prototype.push = TZ;
ti.prototype.has = FZ;
var HZ = ti;
function MZ(m, d) {
  for (var l = -1, i = m == null ? 0 : m.length; ++l < i; )
    if (d(m[l], l, m))
      return !0;
  return !1;
}
var zZ = MZ;
function gZ(m, d) {
  return m.has(d);
}
var kZ = gZ, vZ = HZ, UZ = zZ, QZ = kZ, wZ = 1, PZ = 2;
function fZ(m, d, l, i, t, s) {
  var b = l & wZ, Z = m.length, o = d.length;
  if (Z != o && !(b && o > Z))
    return !1;
  var G = s.get(m), y = s.get(d);
  if (G && y)
    return G == d && y == m;
  var X = -1, W = !0, h = l & PZ ? new vZ() : void 0;
  for (s.set(m, d), s.set(d, m); ++X < Z; ) {
    var r = m[X], L = d[X];
    if (i)
      var u = b ? i(L, r, X, d, m, s) : i(r, L, X, m, d, s);
    if (u !== void 0) {
      if (u)
        continue;
      W = !1;
      break;
    }
    if (h) {
      if (!UZ(d, function(V, c) {
        if (!QZ(h, c) && (r === V || t(r, V, l, i, s)))
          return h.push(c);
      })) {
        W = !1;
        break;
      }
    } else if (!(r === L || t(r, L, l, i, s))) {
      W = !1;
      break;
    }
  }
  return s.delete(m), s.delete(d), W;
}
var $t = fZ, jZ = ud, EZ = jZ.Uint8Array, _t = EZ;
function BZ(m) {
  var d = -1, l = Array(m.size);
  return m.forEach(function(i, t) {
    l[++d] = [t, i];
  }), l;
}
var OZ = BZ;
function DZ(m) {
  var d = -1, l = Array(m.size);
  return m.forEach(function(i) {
    l[++d] = i;
  }), l;
}
var AZ = DZ, dt = ei, it = _t, qZ = Ji, $Z = $t, _Z = OZ, lm = AZ, dm = 1, im = 2, tm = "[object Boolean]", sm = "[object Date]", cm = "[object Error]", bm = "[object Map]", Zm = "[object Number]", mm = "[object RegExp]", nm = "[object Set]", em = "[object String]", om = "[object Symbol]", am = "[object ArrayBuffer]", Xm = "[object DataView]", tt = dt ? dt.prototype : void 0, Vi = tt ? tt.valueOf : void 0;
function Gm(m, d, l, i, t, s, b) {
  switch (l) {
    case Xm:
      if (m.byteLength != d.byteLength || m.byteOffset != d.byteOffset)
        return !1;
      m = m.buffer, d = d.buffer;
    case am:
      return !(m.byteLength != d.byteLength || !s(new it(m), new it(d)));
    case tm:
    case sm:
    case Zm:
      return qZ(+m, +d);
    case cm:
      return m.name == d.name && m.message == d.message;
    case mm:
    case em:
      return m == d + "";
    case bm:
      var Z = _Z;
    case nm:
      var o = i & dm;
      if (Z || (Z = lm), m.size != d.size && !o)
        return !1;
      var G = b.get(m);
      if (G)
        return G == d;
      i |= im, b.set(m, d);
      var y = $Z(Z(m), Z(d), i, t, s, b);
      return b.delete(m), y;
    case om:
      if (Vi)
        return Vi.call(m) == Vi.call(d);
  }
  return !1;
}
var Wm = Gm;
function um(m, d) {
  for (var l = -1, i = d.length, t = m.length; ++l < i; )
    m[t + l] = d[l];
  return m;
}
var ls = um, hm = Array.isArray, Xi = hm, Vm = ls, pm = Xi;
function ym(m, d, l) {
  var i = d(m);
  return pm(m) ? i : Vm(i, l(m));
}
var ds = ym;
function Lm(m, d) {
  for (var l = -1, i = m == null ? 0 : m.length, t = 0, s = []; ++l < i; ) {
    var b = m[l];
    d(b, l, m) && (s[t++] = b);
  }
  return s;
}
var Im = Lm;
function Ym() {
  return [];
}
var is = Ym, xm = Im, rm = is, Rm = Object.prototype, Sm = Rm.propertyIsEnumerable, st = Object.getOwnPropertySymbols, Km = st ? function(m) {
  return m == null ? [] : (m = Object(m), xm(st(m), function(d) {
    return Sm.call(m, d);
  }));
} : rm, Ti = Km;
function Cm(m, d) {
  for (var l = -1, i = Array(m); ++l < m; )
    i[l] = d(l);
  return i;
}
var Jm = Cm;
function Nm(m) {
  return m != null && typeof m == "object";
}
var xd = Nm, Tm = Fd, Fm = xd, Hm = "[object Arguments]";
function Mm(m) {
  return Fm(m) && Tm(m) == Hm;
}
var zm = Mm, ct = zm, gm = xd, ts = Object.prototype, km = ts.hasOwnProperty, vm = ts.propertyIsEnumerable, Um = ct(/* @__PURE__ */ function() {
  return arguments;
}()) ? ct : function(m) {
  return gm(m) && km.call(m, "callee") && !vm.call(m, "callee");
}, Qm = Um, si = { exports: {} };
function wm() {
  return !1;
}
var Pm = wm;
si.exports;
(function(m, d) {
  var l = ud, i = Pm, t = d && !d.nodeType && d, s = t && !0 && m && !m.nodeType && m, b = s && s.exports === t, Z = b ? l.Buffer : void 0, o = Z ? Z.isBuffer : void 0, G = o || i;
  m.exports = G;
})(si, si.exports);
var Fi = si.exports, fm = 9007199254740991, jm = /^(?:0|[1-9]\d*)$/;
function Em(m, d) {
  var l = typeof m;
  return d = d ?? fm, !!d && (l == "number" || l != "symbol" && jm.test(m)) && m > -1 && m % 1 == 0 && m < d;
}
var Bm = Em, Om = 9007199254740991;
function Dm(m) {
  return typeof m == "number" && m > -1 && m % 1 == 0 && m <= Om;
}
var ss = Dm, Am = Fd, qm = ss, $m = xd, _m = "[object Arguments]", l0 = "[object Array]", d0 = "[object Boolean]", i0 = "[object Date]", t0 = "[object Error]", s0 = "[object Function]", c0 = "[object Map]", b0 = "[object Number]", Z0 = "[object Object]", m0 = "[object RegExp]", n0 = "[object Set]", e0 = "[object String]", o0 = "[object WeakMap]", a0 = "[object ArrayBuffer]", X0 = "[object DataView]", G0 = "[object Float32Array]", W0 = "[object Float64Array]", u0 = "[object Int8Array]", h0 = "[object Int16Array]", V0 = "[object Int32Array]", p0 = "[object Uint8Array]", y0 = "[object Uint8ClampedArray]", L0 = "[object Uint16Array]", I0 = "[object Uint32Array]", gl = {};
gl[G0] = gl[W0] = gl[u0] = gl[h0] = gl[V0] = gl[p0] = gl[y0] = gl[L0] = gl[I0] = !0;
gl[_m] = gl[l0] = gl[a0] = gl[d0] = gl[X0] = gl[i0] = gl[t0] = gl[s0] = gl[c0] = gl[b0] = gl[Z0] = gl[m0] = gl[n0] = gl[e0] = gl[o0] = !1;
function Y0(m) {
  return $m(m) && qm(m.length) && !!gl[Am(m)];
}
var x0 = Y0;
function r0(m) {
  return function(d) {
    return m(d);
  };
}
var Hi = r0, ci = { exports: {} };
ci.exports;
(function(m, d) {
  var l = Et, i = d && !d.nodeType && d, t = i && !0 && m && !m.nodeType && m, s = t && t.exports === i, b = s && l.process, Z = function() {
    try {
      var o = t && t.require && t.require("util").types;
      return o || b && b.binding && b.binding("util");
    } catch {
    }
  }();
  m.exports = Z;
})(ci, ci.exports);
var Mi = ci.exports, R0 = x0, S0 = Hi, bt = Mi, Zt = bt && bt.isTypedArray, K0 = Zt ? S0(Zt) : R0, cs = K0, C0 = Jm, J0 = Qm, N0 = Xi, T0 = Fi, F0 = Bm, H0 = cs, M0 = Object.prototype, z0 = M0.hasOwnProperty;
function g0(m, d) {
  var l = N0(m), i = !l && J0(m), t = !l && !i && T0(m), s = !l && !i && !t && H0(m), b = l || i || t || s, Z = b ? C0(m.length, String) : [], o = Z.length;
  for (var G in m)
    (d || z0.call(m, G)) && !(b && // Safari 9 has enumerable `arguments.length` in strict mode.
    (G == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    t && (G == "offset" || G == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (G == "buffer" || G == "byteLength" || G == "byteOffset") || // Skip index properties.
    F0(G, o))) && Z.push(G);
  return Z;
}
var bs = g0, k0 = Object.prototype;
function v0(m) {
  var d = m && m.constructor, l = typeof d == "function" && d.prototype || k0;
  return m === l;
}
var zi = v0;
function U0(m, d) {
  return function(l) {
    return m(d(l));
  };
}
var Zs = U0, Q0 = Zs, w0 = Q0(Object.keys, Object), P0 = w0, f0 = zi, j0 = P0, E0 = Object.prototype, B0 = E0.hasOwnProperty;
function O0(m) {
  if (!f0(m))
    return j0(m);
  var d = [];
  for (var l in Object(m))
    B0.call(m, l) && l != "constructor" && d.push(l);
  return d;
}
var D0 = O0, A0 = Ot, q0 = ss;
function $0(m) {
  return m != null && q0(m.length) && !A0(m);
}
var ms = $0, _0 = bs, ln = D0, dn = ms;
function tn(m) {
  return dn(m) ? _0(m) : ln(m);
}
var gi = tn, sn = ds, cn = Ti, bn = gi;
function Zn(m) {
  return sn(m, bn, cn);
}
var ns = Zn, mt = ns, mn = 1, nn = Object.prototype, en = nn.hasOwnProperty;
function on(m, d, l, i, t, s) {
  var b = l & mn, Z = mt(m), o = Z.length, G = mt(d), y = G.length;
  if (o != y && !b)
    return !1;
  for (var X = o; X--; ) {
    var W = Z[X];
    if (!(b ? W in d : en.call(d, W)))
      return !1;
  }
  var h = s.get(m), r = s.get(d);
  if (h && r)
    return h == d && r == m;
  var L = !0;
  s.set(m, d), s.set(d, m);
  for (var u = b; ++X < o; ) {
    W = Z[X];
    var V = m[W], c = d[W];
    if (i)
      var n = b ? i(c, V, W, d, m, s) : i(V, c, W, m, d, s);
    if (!(n === void 0 ? V === c || t(V, c, l, i, s) : n)) {
      L = !1;
      break;
    }
    u || (u = W == "constructor");
  }
  if (L && !u) {
    var e = m.constructor, a = d.constructor;
    e != a && "constructor" in m && "constructor" in d && !(typeof e == "function" && e instanceof e && typeof a == "function" && a instanceof a) && (L = !1);
  }
  return s.delete(m), s.delete(d), L;
}
var an = on, Xn = Hd, Gn = ud, Wn = Xn(Gn, "DataView"), un = Wn, hn = Hd, Vn = ud, pn = hn(Vn, "Promise"), yn = pn, Ln = Hd, In = ud, Yn = Ln(In, "Set"), xn = Yn, rn = Hd, Rn = ud, Sn = rn(Rn, "WeakMap"), Kn = Sn, Yi = un, xi = Ni, ri = yn, Ri = xn, Si = Kn, es = Fd, wd = Dt, nt = "[object Map]", Cn = "[object Object]", et = "[object Promise]", ot = "[object Set]", at = "[object WeakMap]", Xt = "[object DataView]", Jn = wd(Yi), Nn = wd(xi), Tn = wd(ri), Fn = wd(Ri), Hn = wd(Si), Kd = es;
(Yi && Kd(new Yi(new ArrayBuffer(1))) != Xt || xi && Kd(new xi()) != nt || ri && Kd(ri.resolve()) != et || Ri && Kd(new Ri()) != ot || Si && Kd(new Si()) != at) && (Kd = function(m) {
  var d = es(m), l = d == Cn ? m.constructor : void 0, i = l ? wd(l) : "";
  if (i)
    switch (i) {
      case Jn:
        return Xt;
      case Nn:
        return nt;
      case Tn:
        return et;
      case Fn:
        return ot;
      case Hn:
        return at;
    }
  return d;
});
var Gi = Kd, pi = qt, Mn = $t, zn = Wm, gn = an, Gt = Gi, Wt = Xi, ut = Fi, kn = cs, vn = 1, ht = "[object Arguments]", Vt = "[object Array]", Ad = "[object Object]", Un = Object.prototype, pt = Un.hasOwnProperty;
function Qn(m, d, l, i, t, s) {
  var b = Wt(m), Z = Wt(d), o = b ? Vt : Gt(m), G = Z ? Vt : Gt(d);
  o = o == ht ? Ad : o, G = G == ht ? Ad : G;
  var y = o == Ad, X = G == Ad, W = o == G;
  if (W && ut(m)) {
    if (!ut(d))
      return !1;
    b = !0, y = !1;
  }
  if (W && !y)
    return s || (s = new pi()), b || kn(m) ? Mn(m, d, l, i, t, s) : zn(m, d, o, l, i, t, s);
  if (!(l & vn)) {
    var h = y && pt.call(m, "__wrapped__"), r = X && pt.call(d, "__wrapped__");
    if (h || r) {
      var L = h ? m.value() : m, u = r ? d.value() : d;
      return s || (s = new pi()), t(L, u, l, i, s);
    }
  }
  return W ? (s || (s = new pi()), gn(m, d, l, i, t, s)) : !1;
}
var wn = Qn, Pn = wn, yt = xd;
function os(m, d, l, i, t) {
  return m === d ? !0 : m == null || d == null || !yt(m) && !yt(d) ? m !== m && d !== d : Pn(m, d, l, i, os, t);
}
var fn = os, jn = fn;
function En(m, d) {
  return jn(m, d);
}
var Bn = En;
const dd = /* @__PURE__ */ Td(Bn);
function On(m, d) {
  for (var l = -1, i = m == null ? 0 : m.length; ++l < i && d(m[l], l, m) !== !1; )
    ;
  return m;
}
var Dn = On, An = Hd, qn = function() {
  try {
    var m = An(Object, "defineProperty");
    return m({}, "", {}), m;
  } catch {
  }
}(), $n = qn, Lt = $n;
function _n(m, d, l) {
  d == "__proto__" && Lt ? Lt(m, d, {
    configurable: !0,
    enumerable: !0,
    value: l,
    writable: !0
  }) : m[d] = l;
}
var as = _n, le = as, de = Ji, ie = Object.prototype, te = ie.hasOwnProperty;
function se(m, d, l) {
  var i = m[d];
  (!(te.call(m, d) && de(i, l)) || l === void 0 && !(d in m)) && le(m, d, l);
}
var Xs = se, ce = Xs, be = as;
function Ze(m, d, l, i) {
  var t = !l;
  l || (l = {});
  for (var s = -1, b = d.length; ++s < b; ) {
    var Z = d[s], o = i ? i(l[Z], m[Z], Z, l, m) : void 0;
    o === void 0 && (o = m[Z]), t ? be(l, Z, o) : ce(l, Z, o);
  }
  return l;
}
var Wi = Ze, me = Wi, ne = gi;
function ee(m, d) {
  return m && me(d, ne(d), m);
}
var oe = ee;
function ae(m) {
  var d = [];
  if (m != null)
    for (var l in Object(m))
      d.push(l);
  return d;
}
var Xe = ae, Ge = Sd, We = zi, ue = Xe, he = Object.prototype, Ve = he.hasOwnProperty;
function pe(m) {
  if (!Ge(m))
    return ue(m);
  var d = We(m), l = [];
  for (var i in m)
    i == "constructor" && (d || !Ve.call(m, i)) || l.push(i);
  return l;
}
var ye = pe, Le = bs, Ie = ye, Ye = ms;
function xe(m) {
  return Ye(m) ? Le(m, !0) : Ie(m);
}
var ki = xe, re = Wi, Re = ki;
function Se(m, d) {
  return m && re(d, Re(d), m);
}
var Ke = Se, bi = { exports: {} };
bi.exports;
(function(m, d) {
  var l = ud, i = d && !d.nodeType && d, t = i && !0 && m && !m.nodeType && m, s = t && t.exports === i, b = s ? l.Buffer : void 0, Z = b ? b.allocUnsafe : void 0;
  function o(G, y) {
    if (y)
      return G.slice();
    var X = G.length, W = Z ? Z(X) : new G.constructor(X);
    return G.copy(W), W;
  }
  m.exports = o;
})(bi, bi.exports);
var Ce = bi.exports;
function Je(m, d) {
  var l = -1, i = m.length;
  for (d || (d = Array(i)); ++l < i; )
    d[l] = m[l];
  return d;
}
var Ne = Je, Te = Wi, Fe = Ti;
function He(m, d) {
  return Te(m, Fe(m), d);
}
var Me = He, ze = Zs, ge = ze(Object.getPrototypeOf, Object), Gs = ge, ke = ls, ve = Gs, Ue = Ti, Qe = is, we = Object.getOwnPropertySymbols, Pe = we ? function(m) {
  for (var d = []; m; )
    ke(d, Ue(m)), m = ve(m);
  return d;
} : Qe, Ws = Pe, fe = Wi, je = Ws;
function Ee(m, d) {
  return fe(m, je(m), d);
}
var Be = Ee, Oe = ds, De = Ws, Ae = ki;
function qe(m) {
  return Oe(m, Ae, De);
}
var $e = qe, _e = Object.prototype, lo = _e.hasOwnProperty;
function io(m) {
  var d = m.length, l = new m.constructor(d);
  return d && typeof m[0] == "string" && lo.call(m, "index") && (l.index = m.index, l.input = m.input), l;
}
var to = io, It = _t;
function so(m) {
  var d = new m.constructor(m.byteLength);
  return new It(d).set(new It(m)), d;
}
var vi = so, co = vi;
function bo(m, d) {
  var l = d ? co(m.buffer) : m.buffer;
  return new m.constructor(l, m.byteOffset, m.byteLength);
}
var Zo = bo, mo = /\w*$/;
function no(m) {
  var d = new m.constructor(m.source, mo.exec(m));
  return d.lastIndex = m.lastIndex, d;
}
var eo = no, Yt = ei, xt = Yt ? Yt.prototype : void 0, rt = xt ? xt.valueOf : void 0;
function oo(m) {
  return rt ? Object(rt.call(m)) : {};
}
var ao = oo, Xo = vi;
function Go(m, d) {
  var l = d ? Xo(m.buffer) : m.buffer;
  return new m.constructor(l, m.byteOffset, m.length);
}
var Wo = Go, uo = vi, ho = Zo, Vo = eo, po = ao, yo = Wo, Lo = "[object Boolean]", Io = "[object Date]", Yo = "[object Map]", xo = "[object Number]", ro = "[object RegExp]", Ro = "[object Set]", So = "[object String]", Ko = "[object Symbol]", Co = "[object ArrayBuffer]", Jo = "[object DataView]", No = "[object Float32Array]", To = "[object Float64Array]", Fo = "[object Int8Array]", Ho = "[object Int16Array]", Mo = "[object Int32Array]", zo = "[object Uint8Array]", go = "[object Uint8ClampedArray]", ko = "[object Uint16Array]", vo = "[object Uint32Array]";
function Uo(m, d, l) {
  var i = m.constructor;
  switch (d) {
    case Co:
      return uo(m);
    case Lo:
    case Io:
      return new i(+m);
    case Jo:
      return ho(m, l);
    case No:
    case To:
    case Fo:
    case Ho:
    case Mo:
    case zo:
    case go:
    case ko:
    case vo:
      return yo(m, l);
    case Yo:
      return new i();
    case xo:
    case So:
      return new i(m);
    case ro:
      return Vo(m);
    case Ro:
      return new i();
    case Ko:
      return po(m);
  }
}
var Qo = Uo, wo = Sd, Rt = Object.create, Po = /* @__PURE__ */ function() {
  function m() {
  }
  return function(d) {
    if (!wo(d))
      return {};
    if (Rt)
      return Rt(d);
    m.prototype = d;
    var l = new m();
    return m.prototype = void 0, l;
  };
}(), fo = Po, jo = fo, Eo = Gs, Bo = zi;
function Oo(m) {
  return typeof m.constructor == "function" && !Bo(m) ? jo(Eo(m)) : {};
}
var Do = Oo, Ao = Gi, qo = xd, $o = "[object Map]";
function _o(m) {
  return qo(m) && Ao(m) == $o;
}
var la = _o, da = la, ia = Hi, St = Mi, Kt = St && St.isMap, ta = Kt ? ia(Kt) : da, sa = ta, ca = Gi, ba = xd, Za = "[object Set]";
function ma(m) {
  return ba(m) && ca(m) == Za;
}
var na = ma, ea = na, oa = Hi, Ct = Mi, Jt = Ct && Ct.isSet, aa = Jt ? oa(Jt) : ea, Xa = aa, Ga = qt, Wa = Dn, ua = Xs, ha = oe, Va = Ke, pa = Ce, ya = Ne, La = Me, Ia = Be, Ya = ns, xa = $e, ra = Gi, Ra = to, Sa = Qo, Ka = Do, Ca = Xi, Ja = Fi, Na = sa, Ta = Sd, Fa = Xa, Ha = gi, Ma = ki, za = 1, ga = 2, ka = 4, us = "[object Arguments]", va = "[object Array]", Ua = "[object Boolean]", Qa = "[object Date]", wa = "[object Error]", hs = "[object Function]", Pa = "[object GeneratorFunction]", fa = "[object Map]", ja = "[object Number]", Vs = "[object Object]", Ea = "[object RegExp]", Ba = "[object Set]", Oa = "[object String]", Da = "[object Symbol]", Aa = "[object WeakMap]", qa = "[object ArrayBuffer]", $a = "[object DataView]", _a = "[object Float32Array]", lX = "[object Float64Array]", dX = "[object Int8Array]", iX = "[object Int16Array]", tX = "[object Int32Array]", sX = "[object Uint8Array]", cX = "[object Uint8ClampedArray]", bX = "[object Uint16Array]", ZX = "[object Uint32Array]", zl = {};
zl[us] = zl[va] = zl[qa] = zl[$a] = zl[Ua] = zl[Qa] = zl[_a] = zl[lX] = zl[dX] = zl[iX] = zl[tX] = zl[fa] = zl[ja] = zl[Vs] = zl[Ea] = zl[Ba] = zl[Oa] = zl[Da] = zl[sX] = zl[cX] = zl[bX] = zl[ZX] = !0;
zl[wa] = zl[hs] = zl[Aa] = !1;
function li(m, d, l, i, t, s) {
  var b, Z = d & za, o = d & ga, G = d & ka;
  if (l && (b = t ? l(m, i, t, s) : l(m)), b !== void 0)
    return b;
  if (!Ta(m))
    return m;
  var y = Ca(m);
  if (y) {
    if (b = Ra(m), !Z)
      return ya(m, b);
  } else {
    var X = ra(m), W = X == hs || X == Pa;
    if (Ja(m))
      return pa(m, Z);
    if (X == Vs || X == us || W && !t) {
      if (b = o || W ? {} : Ka(m), !Z)
        return o ? Ia(m, Va(b, m)) : La(m, ha(b, m));
    } else {
      if (!zl[X])
        return t ? m : {};
      b = Sa(m, X, Z);
    }
  }
  s || (s = new Ga());
  var h = s.get(m);
  if (h)
    return h;
  s.set(m, b), Fa(m) ? m.forEach(function(u) {
    b.add(li(u, d, l, u, m, s));
  }) : Na(m) && m.forEach(function(u, V) {
    b.set(V, li(u, d, l, V, m, s));
  });
  var r = G ? o ? xa : Ya : o ? Ma : Ha, L = y ? void 0 : r(m);
  return Wa(L || m, function(u, V) {
    L && (V = u, u = m[V]), ua(b, V, li(u, d, l, V, m, s));
  }), b;
}
var ps = li, mX = ps, nX = 1, eX = 4;
function oX(m) {
  return mX(m, nX | eX);
}
var aX = oX;
const El = /* @__PURE__ */ Td(aX), XX = {
  linear: (m) => m,
  easeInQuad: (m) => m * m,
  easeOutQuad: (m) => m * (2 - m),
  easeInOutQuad: (m) => m < 0.5 ? 2 * m * m : -1 + (4 - 2 * m) * m,
  easeInCubic: (m) => m * m * m,
  easeOutCubic: (m) => --m * m * m + 1,
  easeInOutCubic: (m) => m < 0.5 ? 4 * m * m * m : (m - 1) * (2 * m - 2) * (2 * m - 2) + 1,
  easeInQuart: (m) => m * m * m * m,
  easeOutQuart: (m) => 1 - --m * m * m * m,
  easeInOutQuart: (m) => m < 0.5 ? 8 * m * m * m * m : 1 - 8 * --m * m * m * m,
  easeInQuint: (m) => m * m * m * m * m,
  easeOutQuint: (m) => 1 + --m * m * m * m * m,
  easeInOutQuint: (m) => m < 0.5 ? 16 * m * m * m * m * m : 1 + 16 * --m * m * m * m * m,
  easeInSine: (m) => 1 - Math.cos(m * Math.PI / 2),
  easeOutSine: (m) => Math.sin(m * Math.PI / 2),
  easeInOutSine: (m) => -(Math.cos(Math.PI * m) - 1) / 2,
  easeInExpo: (m) => m <= 0 ? 0 : Math.pow(2, 10 * m - 10),
  easeOutExpo: (m) => m >= 1 ? 1 : 1 - Math.pow(2, -10 * m),
  easeInOutExpo: (m) => m <= 0 ? 0 : m >= 1 ? 1 : m < 0.5 ? Math.pow(2, 20 * m - 10) / 2 : (2 - Math.pow(2, -20 * m + 10)) / 2
};
class pl {
  constructor(d = 0, l = 0, i = 1) {
    Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    });
  }
  get XY() {
    return [this.x, this.y];
  }
  setz(d) {
    return this.z = d, this;
  }
  setXY(d = this.x, l = this.y) {
    return this.x = d, this.y = l, this;
  }
  set(d = this.x, l = this.y, i = this.z) {
    return this.x = d, this.y = l, this.z = i, this;
  }
  setTo({ x: d = 0, y: l = 0, z: i = 1 }) {
    return this.x = d, this.y = l, this.z = i, this;
  }
  rot(d) {
    if (d === 0)
      return this;
    const { x: l, y: i } = this, t = Math.sin(d), s = Math.cos(d);
    return this.x = l * s - i * t, this.y = l * t + i * s, this;
  }
  rotWith(d, l) {
    if (l === 0)
      return this;
    const i = this.x - d.x, t = this.y - d.y, s = Math.sin(l), b = Math.cos(l);
    return this.x = d.x + (i * b - t * s), this.y = d.y + (i * s + t * b), this;
  }
  clone() {
    const { x: d, y: l, z: i } = this;
    return new pl(d, l, i);
  }
  sub(d) {
    return this.x -= d.x, this.y -= d.y, this;
  }
  subXY(d, l) {
    return this.x -= d, this.y -= l, this;
  }
  subScalar(d) {
    return this.x -= d, this.y -= d, this;
  }
  add(d) {
    return this.x += d.x, this.y += d.y, this;
  }
  addXY(d, l) {
    return this.x += d, this.y += l, this;
  }
  addScalar(d) {
    return this.x += d, this.y += d, this;
  }
  clamp(d, l) {
    return this.x = Math.max(this.x, d), this.y = Math.max(this.y, d), l !== void 0 && (this.x = Math.min(this.x, l), this.y = Math.min(this.y, l)), this;
  }
  div(d) {
    return this.x /= d, this.y /= d, this;
  }
  divV(d) {
    return this.x /= d.x, this.y /= d.y, this;
  }
  mul(d) {
    return this.x *= d, this.y *= d, this;
  }
  mulV(d) {
    return this.x *= d.x, this.y *= d.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(d, l) {
    const i = pl.Tan(d, this);
    return this.add(i.mul(l));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(d) {
    return this.x = this.y * d.z - this.z * d.y, this.y = this.z * d.x - this.x * d.z, this;
  }
  dpr(d) {
    return pl.Dpr(this, d);
  }
  cpr(d) {
    return pl.Cpr(this, d);
  }
  len2() {
    return pl.Len2(this);
  }
  len() {
    return pl.Len(this);
  }
  pry(d) {
    return pl.Pry(this, d);
  }
  per() {
    const { x: d, y: l } = this;
    return this.x = l, this.y = -d, this;
  }
  uni() {
    return pl.Uni(this);
  }
  tan(d) {
    return pl.Tan(this, d);
  }
  dist(d) {
    return pl.Dist(this, d);
  }
  distanceToLineSegment(d, l) {
    return pl.DistanceToLineSegment(d, l, this);
  }
  slope(d) {
    return pl.Slope(this, d);
  }
  snapToGrid(d) {
    return this.x = Math.round(this.x / d) * d, this.y = Math.round(this.y / d) * d, this;
  }
  angle(d) {
    return pl.Angle(this, d);
  }
  toAngle() {
    return pl.ToAngle(this);
  }
  lrp(d, l) {
    return this.x = this.x + (d.x - this.x) * l, this.y = this.y + (d.y - this.y) * l, this;
  }
  equals(d, l) {
    return pl.Equals(this, d, l);
  }
  equalsXY(d, l) {
    return pl.EqualsXY(this, d, l);
  }
  norm() {
    const d = this.len();
    return this.x = d === 0 ? 0 : this.x / d, this.y = d === 0 ? 0 : this.y / d, this;
  }
  toFixed() {
    return pl.ToFixed(this);
  }
  toString() {
    return pl.ToString(pl.ToFixed(this));
  }
  toJson() {
    return pl.ToJson(this);
  }
  toArray() {
    return pl.ToArray(this);
  }
  static Add(d, l) {
    return new pl(d.x + l.x, d.y + l.y);
  }
  static AddXY(d, l, i) {
    return new pl(d.x + l, d.y + i);
  }
  static Sub(d, l) {
    return new pl(d.x - l.x, d.y - l.y);
  }
  static SubXY(d, l, i) {
    return new pl(d.x - l, d.y - i);
  }
  static AddScalar(d, l) {
    return new pl(d.x + l, d.y + l);
  }
  static SubScalar(d, l) {
    return new pl(d.x - l, d.y - l);
  }
  static Div(d, l) {
    return new pl(d.x / l, d.y / l);
  }
  static Mul(d, l) {
    return new pl(d.x * l, d.y * l);
  }
  static DivV(d, l) {
    return new pl(d.x / l.x, d.y / l.y);
  }
  static MulV(d, l) {
    return new pl(d.x * l.x, d.y * l.y);
  }
  static Neg(d) {
    return new pl(-d.x, -d.y);
  }
  static Per(d) {
    return new pl(d.y, -d.x);
  }
  static Dist2(d, l) {
    return pl.Sub(d, l).len2();
  }
  static Abs(d) {
    return new pl(Math.abs(d.x), Math.abs(d.y));
  }
  static Dist(d, l) {
    return Math.hypot(d.y - l.y, d.x - l.x);
  }
  static Dpr(d, l) {
    return d.x * l.x + d.y * l.y;
  }
  static Cross(d, l) {
    return new pl(
      d.y * l.z - d.z * l.y,
      d.z * l.x - d.x * l.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  static Cpr(d, l) {
    return d.x * l.y - l.x * d.y;
  }
  static Len2(d) {
    return d.x * d.x + d.y * d.y;
  }
  static Len(d) {
    return Math.hypot(d.x, d.y);
  }
  static Pry(d, l) {
    return pl.Dpr(d, l) / pl.Len(l);
  }
  static Uni(d) {
    return pl.Div(d, pl.Len(d));
  }
  static Tan(d, l) {
    return pl.Uni(pl.Sub(d, l));
  }
  static Min(d, l) {
    return new pl(Math.min(d.x, l.x), Math.min(d.y, l.y));
  }
  static Max(d, l) {
    return new pl(Math.max(d.x, l.x), Math.max(d.y, l.y));
  }
  static From(d) {
    return new pl().add(d);
  }
  static FromArray(d) {
    return new pl(d[0], d[1]);
  }
  static Rot(d, l = 0) {
    const i = Math.sin(l), t = Math.cos(l);
    return new pl(d.x * t - d.y * i, d.x * i + d.y * t);
  }
  static RotWith(d, l, i) {
    const t = d.x - l.x, s = d.y - l.y, b = Math.sin(i), Z = Math.cos(i);
    return new pl(l.x + (t * Z - s * b), l.y + (t * b + s * Z));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(d, l, i) {
    return pl.Mul(l, pl.Sub(i, d).pry(l)).add(d);
  }
  static NearestPointOnLineSegment(d, l, i, t = !0) {
    const s = pl.Tan(l, d), b = pl.Add(d, pl.Mul(s, pl.Sub(i, d).pry(s)));
    if (t) {
      if (b.x < Math.min(d.x, l.x))
        return pl.Cast(d.x < l.x ? d : l);
      if (b.x > Math.max(d.x, l.x))
        return pl.Cast(d.x > l.x ? d : l);
      if (b.y < Math.min(d.y, l.y))
        return pl.Cast(d.y < l.y ? d : l);
      if (b.y > Math.max(d.y, l.y))
        return pl.Cast(d.y > l.y ? d : l);
    }
    return b;
  }
  static DistanceToLineThroughPoint(d, l, i) {
    return pl.Dist(i, pl.NearestPointOnLineThroughPoint(d, l, i));
  }
  static DistanceToLineSegment(d, l, i, t = !0) {
    return pl.Dist(i, pl.NearestPointOnLineSegment(d, l, i, t));
  }
  static Snap(d, l = 1) {
    return new pl(Math.round(d.x / l) * l, Math.round(d.y / l) * l);
  }
  static Cast(d) {
    return d instanceof pl ? d : pl.From(d);
  }
  static Slope(d, l) {
    return d.x === l.y ? NaN : (d.y - l.y) / (d.x - l.x);
  }
  static Angle(d, l) {
    return Math.atan2(l.y - d.y, l.x - d.x);
  }
  static Lrp(d, l, i) {
    return pl.Sub(l, d).mul(i).add(d);
  }
  static Med(d, l) {
    return new pl((d.x + l.x) / 2, (d.y + l.y) / 2);
  }
  static Equals(d, l, i = 1e-4) {
    return Math.abs(d.x - l.x) < i && Math.abs(d.y - l.y) < i;
  }
  static EqualsXY(d, l, i) {
    return d.x === l && d.y === i;
  }
  static EqualsXYZ(d, l, i = 1e-4) {
    return pl.Equals(d, l, i) && Math.abs((d.z || 0) - (l.z || 0)) < i;
  }
  static Clockwise(d, l, i) {
    return (i.x - d.x) * (l.y - d.y) - (l.x - d.x) * (i.y - d.y) < 0;
  }
  static Rescale(d, l) {
    const i = pl.Len(d);
    return new pl(l * d.x / i, l * d.y / i);
  }
  static ScaleWithOrigin(d, l, i) {
    return pl.Sub(d, i).mul(l).add(i);
  }
  static ScaleWOrigin(d, l, i) {
    return pl.Sub(d, i).mulV(l).add(i);
  }
  static ToFixed(d, l = 2) {
    return new pl(+d.x.toFixed(l), +d.y.toFixed(l), +d.z.toFixed(l));
  }
  static Nudge(d, l, i) {
    return pl.Add(d, pl.Tan(l, d).mul(i));
  }
  static ToString(d) {
    return `${d.x}, ${d.y}`;
  }
  static ToAngle(d) {
    let l = Math.atan2(d.y, d.x);
    return l < 0 && (l += Math.PI * 2), l;
  }
  static FromAngle(d, l = 1) {
    return new pl(Math.cos(d) * l, Math.sin(d) * l);
  }
  static ToArray(d) {
    return [d.x, d.y, d.z];
  }
  static ToJson(d) {
    const { x: l, y: i, z: t } = d;
    return { x: l, y: i, z: t };
  }
  static Average(d) {
    const l = d.length, i = new pl(0, 0);
    for (let t = 0; t < l; t++)
      i.add(d[t]);
    return i.div(l);
  }
  static Clamp(d, l, i) {
    return i === void 0 ? new pl(Math.min(Math.max(d.x, l)), Math.min(Math.max(d.y, l))) : new pl(Math.min(Math.max(d.x, l), i), Math.min(Math.max(d.y, l), i));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(d, l, i = 6) {
    const t = [];
    for (let s = 0; s < i; s++) {
      const b = XX.easeInQuad(s / (i - 1)), Z = pl.Lrp(d, l, b);
      Z.z = Math.min(1, 0.5 + Math.abs(0.5 - GX(b)) * 0.65), t.push(Z);
    }
    return t;
  }
  static SnapToGrid(d, l = 8) {
    return new pl(Math.round(d.x / l) * l, Math.round(d.y / l) * l);
  }
}
const GX = (m) => m < 0.5 ? 2 * m * m : -1 + (4 - 2 * m) * m;
class vl extends pl {
  constructor(d = 0, l = 0, i = 0, t = { x: 0, y: 0 }, s = 0, b = 0) {
    super(d, l, i), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "v", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "t", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: b
    });
  }
  get timestamp() {
    return this.t;
  }
  get pressure() {
    return this.z;
  }
  get angleNum() {
    return this.a;
  }
  get XY() {
    return [this.x, this.y];
  }
  setA(d) {
    this.a = d;
  }
  setT(d) {
    this.t = d;
  }
  setv(d) {
    return this.v = { x: d.x, y: d.y }, this;
  }
  set(d = this.x, l = this.y, i = this.z, t = this.v, s = this.t, b = this.a) {
    return this.x = d, this.y = l, this.z = i, this.v = t, this.t = s, this.a = b, this;
  }
  clone() {
    const { x: d, y: l, z: i, v: t, t: s, a: b } = this, Z = { x: t.x, y: t.y };
    return new vl(d, l, i, Z, s, b);
  }
  distance(d) {
    return vl.GetDistance(this, d);
  }
  isNear(d, l) {
    return vl.IsNear(this, d, l);
  }
  getAngleByPoints(d, l) {
    return vl.GetAngleByPoints(d, this, l);
  }
  static Sub(d, l) {
    return new vl(d.x - l.x, d.y - l.y);
  }
  static Add(d, l) {
    return new vl(d.x + l.x, d.y + l.y);
  }
  static GetDistance(d, l) {
    return vl.Len(d.clone().sub(l));
  }
  static GetAngleByPoints(d, l, i) {
    const t = l.x - d.x, s = i.x - l.x, b = l.y - d.y, Z = i.y - l.y;
    let o = 0;
    const G = Math.sqrt(t * t + b * b), y = Math.sqrt(s * s + Z * Z);
    if (G && y) {
      const X = t * s + b * Z;
      o = Math.acos(X / (G * y)), o = o / Math.PI * 180;
      let W = t * Z - b * s;
      W = W > 0 ? 1 : -1, o = 180 + W * o;
    }
    return o;
  }
  static IsNear(d, l, i) {
    return vl.Len(d.clone().sub(l)) < i;
  }
  static RotWith(d, l, i, t = 2) {
    const s = d.x - l.x, b = d.y - l.y, Z = Math.sin(i), o = Math.cos(i), G = Math.pow(10, t), y = Math.floor((l.x + (s * o - b * Z)) * G) / G, X = Math.floor((l.y + (s * Z + b * o)) * G) / G;
    return new vl(y, X);
  }
  /**
   * 根据圆心和半径，获取圆上的等份点
   * @param o 圆心
   * @param radius 半径
   * @param average 均分数
   * @returns
   */
  static GetDotStroke(d, l, i = 16) {
    const t = new pl(1, 1), s = Math.PI + 1e-3, b = vl.Add(d, vl.Sub(d, t).uni().per().mul(-l)), Z = [];
    for (let o = 1 / i, G = o; G <= 1; G += o)
      Z.push(vl.RotWith(b, d, s * 2 * G));
    return Z;
  }
  /**
   * 根据圆心和圆上的起始点，获取半圆上的等份点
   * @param o 圆心
   * @param p 圆弧起始点
   * @param radian 1，逆时针180度 -1，顺时针
   * @param average 均分数
   * @returns
   */
  static GetSemicircleStroke(d, l, i = -1, t = 8) {
    const s = i * (Math.PI + 1e-3), b = [];
    for (let Z = 1 / t, o = Z; o <= 1; o += Z)
      b.push(vl.RotWith(l, d, s * o));
    return b;
  }
}
var WX = Fd, uX = xd, hX = "[object Number]";
function VX(m) {
  return typeof m == "number" || uX(m) && WX(m) == hX;
}
var pX = VX;
const td = /* @__PURE__ */ Td(pX);
var Ml = (
  /******/
  function(m) {
    var d = {};
    function l(i) {
      if (d[i])
        return d[i].exports;
      var t = d[i] = {
        /******/
        i,
        /******/
        l: !1,
        /******/
        exports: {}
        /******/
      };
      return m[i].call(t.exports, t, t.exports, l), t.l = !0, t.exports;
    }
    return l.m = m, l.c = d, l.d = function(i, t, s) {
      l.o(i, t) || Object.defineProperty(i, t, { enumerable: !0, get: s });
    }, l.r = function(i) {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
    }, l.t = function(i, t) {
      if (t & 1 && (i = l(i)), t & 8 || t & 4 && typeof i == "object" && i && i.__esModule)
        return i;
      var s = /* @__PURE__ */ Object.create(null);
      if (l.r(s), Object.defineProperty(s, "default", { enumerable: !0, value: i }), t & 2 && typeof i != "string")
        for (var b in i)
          l.d(s, b, (function(Z) {
            return i[Z];
          }).bind(null, b));
      return s;
    }, l.n = function(i) {
      var t = i && i.__esModule ? (
        /******/
        function() {
          return i.default;
        }
      ) : (
        /******/
        function() {
          return i;
        }
      );
      return l.d(t, "a", t), t;
    }, l.o = function(i, t) {
      return Object.prototype.hasOwnProperty.call(i, t);
    }, l.p = "/js/", l(l.s = 0);
  }([
    /* 0 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "version", function() {
        return P;
      }), l.d(d, "helpers", function() {
        return H;
      }), l.d(d, "createElement", function() {
        return T;
      }), l.d(d, "isSpriteNode", function() {
        return K;
      }), l.d(d, "registerNode", function() {
        return S;
      });
      var i = l(12);
      l.d(d, "ENV", function() {
        return i.ENV;
      });
      var t = l(68);
      l.d(d, "requestAnimationFrame", function() {
        return t.requestAnimationFrame;
      }), l.d(d, "cancelAnimationFrame", function() {
        return t.cancelAnimationFrame;
      });
      var s = l(70);
      l.d(d, "Node", function() {
        return s.default;
      });
      var b = l(217);
      l.d(d, "Cloud", function() {
        return b.default;
      });
      var Z = l(219);
      l.d(d, "Block", function() {
        return Z.default;
      });
      var o = l(224);
      l.d(d, "Sprite", function() {
        return o.default;
      });
      var G = l(226);
      l.d(d, "Path", function() {
        return G.default;
      });
      var y = l(229);
      l.d(d, "Rect", function() {
        return y.default;
      });
      var X = l(231);
      l.d(d, "Triangle", function() {
        return X.default;
      });
      var W = l(236);
      l.d(d, "Parallel", function() {
        return W.default;
      });
      var h = l(238);
      l.d(d, "Regular", function() {
        return h.default;
      });
      var r = l(240);
      l.d(d, "Star", function() {
        return r.default;
      });
      var L = l(242);
      l.d(d, "Ellipse", function() {
        return L.default;
      });
      var u = l(244);
      l.d(d, "Arc", function() {
        return u.default;
      });
      var V = l(246);
      l.d(d, "Ring", function() {
        return V.default;
      });
      var c = l(232);
      l.d(d, "Polyline", function() {
        return c.default;
      });
      var n = l(248);
      l.d(d, "Label", function() {
        return n.default;
      });
      var e = l(250);
      l.d(d, "Group", function() {
        return e.default;
      });
      var a = l(286);
      l.d(d, "Layer", function() {
        return a.default;
      });
      var Y = l(287);
      l.d(d, "SpriteSvg", function() {
        return Y.default;
      });
      var R = l(289);
      l.d(d, "LayerWorker", function() {
        return R.default;
      });
      var C = l(290);
      l.d(d, "Scene", function() {
        return C.default;
      });
      var N = l(213), I = l(221);
      l.d(d, "Color", function() {
        return I.Color;
      }), l.d(d, "Gradient", function() {
        return I.Gradient;
      });
      var J = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const T = N.default.createElement, K = N.default.isSpriteNode, S = N.default.registerNode, H = {
        parseColor: I.parseColor,
        sizeToPixel: J.sizeToPixel,
        toArray: J.toArray,
        toString: J.toString,
        toNumber: J.toNumber
      };
      let w;
      w = "3.8.3";
      const P = w;
    },
    /* 1 */
    /***/
    function(m, d, l) {
      l.r(d);
      var i = l(2);
      l.d(d, "glMatrix", function() {
        return i;
      });
      var t = l(3);
      l.d(d, "mat2", function() {
        return t;
      });
      var s = l(4);
      l.d(d, "mat2d", function() {
        return s;
      });
      var b = l(5);
      l.d(d, "mat3", function() {
        return b;
      });
      var Z = l(6);
      l.d(d, "mat4", function() {
        return Z;
      });
      var o = l(7);
      l.d(d, "quat", function() {
        return o;
      });
      var G = l(10);
      l.d(d, "quat2", function() {
        return G;
      });
      var y = l(11);
      l.d(d, "vec2", function() {
        return y;
      });
      var X = l(8);
      l.d(d, "vec3", function() {
        return X;
      });
      var W = l(9);
      l.d(d, "vec4", function() {
        return W;
      });
    },
    /* 2 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "EPSILON", function() {
        return i;
      }), l.d(d, "ARRAY_TYPE", function() {
        return t;
      }), l.d(d, "RANDOM", function() {
        return s;
      }), l.d(d, "setMatrixArrayType", function() {
        return b;
      }), l.d(d, "toRadian", function() {
        return o;
      }), l.d(d, "equals", function() {
        return G;
      });
      var i = 1e-6, t = typeof Float32Array < "u" ? Float32Array : Array, s = Math.random;
      function b(y) {
        t = y;
      }
      var Z = Math.PI / 180;
      function o(y) {
        return y * Z;
      }
      function G(y, X) {
        return Math.abs(y - X) <= i * Math.max(1, Math.abs(y), Math.abs(X));
      }
      Math.hypot || (Math.hypot = function() {
        for (var y = 0, X = arguments.length; X--; )
          y += arguments[X] * arguments[X];
        return Math.sqrt(y);
      });
    },
    /* 3 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return t;
      }), l.d(d, "clone", function() {
        return s;
      }), l.d(d, "copy", function() {
        return b;
      }), l.d(d, "identity", function() {
        return Z;
      }), l.d(d, "fromValues", function() {
        return o;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "transpose", function() {
        return y;
      }), l.d(d, "invert", function() {
        return X;
      }), l.d(d, "adjoint", function() {
        return W;
      }), l.d(d, "determinant", function() {
        return h;
      }), l.d(d, "multiply", function() {
        return r;
      }), l.d(d, "rotate", function() {
        return L;
      }), l.d(d, "scale", function() {
        return u;
      }), l.d(d, "fromRotation", function() {
        return V;
      }), l.d(d, "fromScaling", function() {
        return c;
      }), l.d(d, "str", function() {
        return n;
      }), l.d(d, "frob", function() {
        return e;
      }), l.d(d, "LDU", function() {
        return a;
      }), l.d(d, "add", function() {
        return Y;
      }), l.d(d, "subtract", function() {
        return R;
      }), l.d(d, "exactEquals", function() {
        return C;
      }), l.d(d, "equals", function() {
        return N;
      }), l.d(d, "multiplyScalar", function() {
        return I;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return J;
      }), l.d(d, "mul", function() {
        return T;
      }), l.d(d, "sub", function() {
        return K;
      });
      var i = l(2);
      function t() {
        var S = new i.ARRAY_TYPE(4);
        return i.ARRAY_TYPE != Float32Array && (S[1] = 0, S[2] = 0), S[0] = 1, S[3] = 1, S;
      }
      function s(S) {
        var H = new i.ARRAY_TYPE(4);
        return H[0] = S[0], H[1] = S[1], H[2] = S[2], H[3] = S[3], H;
      }
      function b(S, H) {
        return S[0] = H[0], S[1] = H[1], S[2] = H[2], S[3] = H[3], S;
      }
      function Z(S) {
        return S[0] = 1, S[1] = 0, S[2] = 0, S[3] = 1, S;
      }
      function o(S, H, w, P) {
        var B = new i.ARRAY_TYPE(4);
        return B[0] = S, B[1] = H, B[2] = w, B[3] = P, B;
      }
      function G(S, H, w, P, B) {
        return S[0] = H, S[1] = w, S[2] = P, S[3] = B, S;
      }
      function y(S, H) {
        if (S === H) {
          var w = H[1];
          S[1] = H[2], S[2] = w;
        } else
          S[0] = H[0], S[1] = H[2], S[2] = H[1], S[3] = H[3];
        return S;
      }
      function X(S, H) {
        var w = H[0], P = H[1], B = H[2], D = H[3], z = w * D - B * P;
        return z ? (z = 1 / z, S[0] = D * z, S[1] = -P * z, S[2] = -B * z, S[3] = w * z, S) : null;
      }
      function W(S, H) {
        var w = H[0];
        return S[0] = H[3], S[1] = -H[1], S[2] = -H[2], S[3] = w, S;
      }
      function h(S) {
        return S[0] * S[3] - S[2] * S[1];
      }
      function r(S, H, w) {
        var P = H[0], B = H[1], D = H[2], z = H[3], U = w[0], O = w[1], ll = w[2], _ = w[3];
        return S[0] = P * U + D * O, S[1] = B * U + z * O, S[2] = P * ll + D * _, S[3] = B * ll + z * _, S;
      }
      function L(S, H, w) {
        var P = H[0], B = H[1], D = H[2], z = H[3], U = Math.sin(w), O = Math.cos(w);
        return S[0] = P * O + D * U, S[1] = B * O + z * U, S[2] = P * -U + D * O, S[3] = B * -U + z * O, S;
      }
      function u(S, H, w) {
        var P = H[0], B = H[1], D = H[2], z = H[3], U = w[0], O = w[1];
        return S[0] = P * U, S[1] = B * U, S[2] = D * O, S[3] = z * O, S;
      }
      function V(S, H) {
        var w = Math.sin(H), P = Math.cos(H);
        return S[0] = P, S[1] = w, S[2] = -w, S[3] = P, S;
      }
      function c(S, H) {
        return S[0] = H[0], S[1] = 0, S[2] = 0, S[3] = H[1], S;
      }
      function n(S) {
        return "mat2(" + S[0] + ", " + S[1] + ", " + S[2] + ", " + S[3] + ")";
      }
      function e(S) {
        return Math.hypot(S[0], S[1], S[2], S[3]);
      }
      function a(S, H, w, P) {
        return S[2] = P[2] / P[0], w[0] = P[0], w[1] = P[1], w[3] = P[3] - S[2] * w[1], [S, H, w];
      }
      function Y(S, H, w) {
        return S[0] = H[0] + w[0], S[1] = H[1] + w[1], S[2] = H[2] + w[2], S[3] = H[3] + w[3], S;
      }
      function R(S, H, w) {
        return S[0] = H[0] - w[0], S[1] = H[1] - w[1], S[2] = H[2] - w[2], S[3] = H[3] - w[3], S;
      }
      function C(S, H) {
        return S[0] === H[0] && S[1] === H[1] && S[2] === H[2] && S[3] === H[3];
      }
      function N(S, H) {
        var w = S[0], P = S[1], B = S[2], D = S[3], z = H[0], U = H[1], O = H[2], ll = H[3];
        return Math.abs(w - z) <= i.EPSILON * Math.max(1, Math.abs(w), Math.abs(z)) && Math.abs(P - U) <= i.EPSILON * Math.max(1, Math.abs(P), Math.abs(U)) && Math.abs(B - O) <= i.EPSILON * Math.max(1, Math.abs(B), Math.abs(O)) && Math.abs(D - ll) <= i.EPSILON * Math.max(1, Math.abs(D), Math.abs(ll));
      }
      function I(S, H, w) {
        return S[0] = H[0] * w, S[1] = H[1] * w, S[2] = H[2] * w, S[3] = H[3] * w, S;
      }
      function J(S, H, w, P) {
        return S[0] = H[0] + w[0] * P, S[1] = H[1] + w[1] * P, S[2] = H[2] + w[2] * P, S[3] = H[3] + w[3] * P, S;
      }
      var T = r, K = R;
    },
    /* 4 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return t;
      }), l.d(d, "clone", function() {
        return s;
      }), l.d(d, "copy", function() {
        return b;
      }), l.d(d, "identity", function() {
        return Z;
      }), l.d(d, "fromValues", function() {
        return o;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "invert", function() {
        return y;
      }), l.d(d, "determinant", function() {
        return X;
      }), l.d(d, "multiply", function() {
        return W;
      }), l.d(d, "rotate", function() {
        return h;
      }), l.d(d, "scale", function() {
        return r;
      }), l.d(d, "translate", function() {
        return L;
      }), l.d(d, "fromRotation", function() {
        return u;
      }), l.d(d, "fromScaling", function() {
        return V;
      }), l.d(d, "fromTranslation", function() {
        return c;
      }), l.d(d, "str", function() {
        return n;
      }), l.d(d, "frob", function() {
        return e;
      }), l.d(d, "add", function() {
        return a;
      }), l.d(d, "subtract", function() {
        return Y;
      }), l.d(d, "multiplyScalar", function() {
        return R;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return C;
      }), l.d(d, "exactEquals", function() {
        return N;
      }), l.d(d, "equals", function() {
        return I;
      }), l.d(d, "mul", function() {
        return J;
      }), l.d(d, "sub", function() {
        return T;
      });
      var i = l(2);
      function t() {
        var K = new i.ARRAY_TYPE(6);
        return i.ARRAY_TYPE != Float32Array && (K[1] = 0, K[2] = 0, K[4] = 0, K[5] = 0), K[0] = 1, K[3] = 1, K;
      }
      function s(K) {
        var S = new i.ARRAY_TYPE(6);
        return S[0] = K[0], S[1] = K[1], S[2] = K[2], S[3] = K[3], S[4] = K[4], S[5] = K[5], S;
      }
      function b(K, S) {
        return K[0] = S[0], K[1] = S[1], K[2] = S[2], K[3] = S[3], K[4] = S[4], K[5] = S[5], K;
      }
      function Z(K) {
        return K[0] = 1, K[1] = 0, K[2] = 0, K[3] = 1, K[4] = 0, K[5] = 0, K;
      }
      function o(K, S, H, w, P, B) {
        var D = new i.ARRAY_TYPE(6);
        return D[0] = K, D[1] = S, D[2] = H, D[3] = w, D[4] = P, D[5] = B, D;
      }
      function G(K, S, H, w, P, B, D) {
        return K[0] = S, K[1] = H, K[2] = w, K[3] = P, K[4] = B, K[5] = D, K;
      }
      function y(K, S) {
        var H = S[0], w = S[1], P = S[2], B = S[3], D = S[4], z = S[5], U = H * B - w * P;
        return U ? (U = 1 / U, K[0] = B * U, K[1] = -w * U, K[2] = -P * U, K[3] = H * U, K[4] = (P * z - B * D) * U, K[5] = (w * D - H * z) * U, K) : null;
      }
      function X(K) {
        return K[0] * K[3] - K[1] * K[2];
      }
      function W(K, S, H) {
        var w = S[0], P = S[1], B = S[2], D = S[3], z = S[4], U = S[5], O = H[0], ll = H[1], _ = H[2], Zl = H[3], $ = H[4], ol = H[5];
        return K[0] = w * O + B * ll, K[1] = P * O + D * ll, K[2] = w * _ + B * Zl, K[3] = P * _ + D * Zl, K[4] = w * $ + B * ol + z, K[5] = P * $ + D * ol + U, K;
      }
      function h(K, S, H) {
        var w = S[0], P = S[1], B = S[2], D = S[3], z = S[4], U = S[5], O = Math.sin(H), ll = Math.cos(H);
        return K[0] = w * ll + B * O, K[1] = P * ll + D * O, K[2] = w * -O + B * ll, K[3] = P * -O + D * ll, K[4] = z, K[5] = U, K;
      }
      function r(K, S, H) {
        var w = S[0], P = S[1], B = S[2], D = S[3], z = S[4], U = S[5], O = H[0], ll = H[1];
        return K[0] = w * O, K[1] = P * O, K[2] = B * ll, K[3] = D * ll, K[4] = z, K[5] = U, K;
      }
      function L(K, S, H) {
        var w = S[0], P = S[1], B = S[2], D = S[3], z = S[4], U = S[5], O = H[0], ll = H[1];
        return K[0] = w, K[1] = P, K[2] = B, K[3] = D, K[4] = w * O + B * ll + z, K[5] = P * O + D * ll + U, K;
      }
      function u(K, S) {
        var H = Math.sin(S), w = Math.cos(S);
        return K[0] = w, K[1] = H, K[2] = -H, K[3] = w, K[4] = 0, K[5] = 0, K;
      }
      function V(K, S) {
        return K[0] = S[0], K[1] = 0, K[2] = 0, K[3] = S[1], K[4] = 0, K[5] = 0, K;
      }
      function c(K, S) {
        return K[0] = 1, K[1] = 0, K[2] = 0, K[3] = 1, K[4] = S[0], K[5] = S[1], K;
      }
      function n(K) {
        return "mat2d(" + K[0] + ", " + K[1] + ", " + K[2] + ", " + K[3] + ", " + K[4] + ", " + K[5] + ")";
      }
      function e(K) {
        return Math.hypot(K[0], K[1], K[2], K[3], K[4], K[5], 1);
      }
      function a(K, S, H) {
        return K[0] = S[0] + H[0], K[1] = S[1] + H[1], K[2] = S[2] + H[2], K[3] = S[3] + H[3], K[4] = S[4] + H[4], K[5] = S[5] + H[5], K;
      }
      function Y(K, S, H) {
        return K[0] = S[0] - H[0], K[1] = S[1] - H[1], K[2] = S[2] - H[2], K[3] = S[3] - H[3], K[4] = S[4] - H[4], K[5] = S[5] - H[5], K;
      }
      function R(K, S, H) {
        return K[0] = S[0] * H, K[1] = S[1] * H, K[2] = S[2] * H, K[3] = S[3] * H, K[4] = S[4] * H, K[5] = S[5] * H, K;
      }
      function C(K, S, H, w) {
        return K[0] = S[0] + H[0] * w, K[1] = S[1] + H[1] * w, K[2] = S[2] + H[2] * w, K[3] = S[3] + H[3] * w, K[4] = S[4] + H[4] * w, K[5] = S[5] + H[5] * w, K;
      }
      function N(K, S) {
        return K[0] === S[0] && K[1] === S[1] && K[2] === S[2] && K[3] === S[3] && K[4] === S[4] && K[5] === S[5];
      }
      function I(K, S) {
        var H = K[0], w = K[1], P = K[2], B = K[3], D = K[4], z = K[5], U = S[0], O = S[1], ll = S[2], _ = S[3], Zl = S[4], $ = S[5];
        return Math.abs(H - U) <= i.EPSILON * Math.max(1, Math.abs(H), Math.abs(U)) && Math.abs(w - O) <= i.EPSILON * Math.max(1, Math.abs(w), Math.abs(O)) && Math.abs(P - ll) <= i.EPSILON * Math.max(1, Math.abs(P), Math.abs(ll)) && Math.abs(B - _) <= i.EPSILON * Math.max(1, Math.abs(B), Math.abs(_)) && Math.abs(D - Zl) <= i.EPSILON * Math.max(1, Math.abs(D), Math.abs(Zl)) && Math.abs(z - $) <= i.EPSILON * Math.max(1, Math.abs(z), Math.abs($));
      }
      var J = W, T = Y;
    },
    /* 5 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return t;
      }), l.d(d, "fromMat4", function() {
        return s;
      }), l.d(d, "clone", function() {
        return b;
      }), l.d(d, "copy", function() {
        return Z;
      }), l.d(d, "fromValues", function() {
        return o;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "identity", function() {
        return y;
      }), l.d(d, "transpose", function() {
        return X;
      }), l.d(d, "invert", function() {
        return W;
      }), l.d(d, "adjoint", function() {
        return h;
      }), l.d(d, "determinant", function() {
        return r;
      }), l.d(d, "multiply", function() {
        return L;
      }), l.d(d, "translate", function() {
        return u;
      }), l.d(d, "rotate", function() {
        return V;
      }), l.d(d, "scale", function() {
        return c;
      }), l.d(d, "fromTranslation", function() {
        return n;
      }), l.d(d, "fromRotation", function() {
        return e;
      }), l.d(d, "fromScaling", function() {
        return a;
      }), l.d(d, "fromMat2d", function() {
        return Y;
      }), l.d(d, "fromQuat", function() {
        return R;
      }), l.d(d, "normalFromMat4", function() {
        return C;
      }), l.d(d, "projection", function() {
        return N;
      }), l.d(d, "str", function() {
        return I;
      }), l.d(d, "frob", function() {
        return J;
      }), l.d(d, "add", function() {
        return T;
      }), l.d(d, "subtract", function() {
        return K;
      }), l.d(d, "multiplyScalar", function() {
        return S;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return H;
      }), l.d(d, "exactEquals", function() {
        return w;
      }), l.d(d, "equals", function() {
        return P;
      }), l.d(d, "mul", function() {
        return B;
      }), l.d(d, "sub", function() {
        return D;
      });
      var i = l(2);
      function t() {
        var z = new i.ARRAY_TYPE(9);
        return i.ARRAY_TYPE != Float32Array && (z[1] = 0, z[2] = 0, z[3] = 0, z[5] = 0, z[6] = 0, z[7] = 0), z[0] = 1, z[4] = 1, z[8] = 1, z;
      }
      function s(z, U) {
        return z[0] = U[0], z[1] = U[1], z[2] = U[2], z[3] = U[4], z[4] = U[5], z[5] = U[6], z[6] = U[8], z[7] = U[9], z[8] = U[10], z;
      }
      function b(z) {
        var U = new i.ARRAY_TYPE(9);
        return U[0] = z[0], U[1] = z[1], U[2] = z[2], U[3] = z[3], U[4] = z[4], U[5] = z[5], U[6] = z[6], U[7] = z[7], U[8] = z[8], U;
      }
      function Z(z, U) {
        return z[0] = U[0], z[1] = U[1], z[2] = U[2], z[3] = U[3], z[4] = U[4], z[5] = U[5], z[6] = U[6], z[7] = U[7], z[8] = U[8], z;
      }
      function o(z, U, O, ll, _, Zl, $, ol, al) {
        var g = new i.ARRAY_TYPE(9);
        return g[0] = z, g[1] = U, g[2] = O, g[3] = ll, g[4] = _, g[5] = Zl, g[6] = $, g[7] = ol, g[8] = al, g;
      }
      function G(z, U, O, ll, _, Zl, $, ol, al, g) {
        return z[0] = U, z[1] = O, z[2] = ll, z[3] = _, z[4] = Zl, z[5] = $, z[6] = ol, z[7] = al, z[8] = g, z;
      }
      function y(z) {
        return z[0] = 1, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = 1, z[5] = 0, z[6] = 0, z[7] = 0, z[8] = 1, z;
      }
      function X(z, U) {
        if (z === U) {
          var O = U[1], ll = U[2], _ = U[5];
          z[1] = U[3], z[2] = U[6], z[3] = O, z[5] = U[7], z[6] = ll, z[7] = _;
        } else
          z[0] = U[0], z[1] = U[3], z[2] = U[6], z[3] = U[1], z[4] = U[4], z[5] = U[7], z[6] = U[2], z[7] = U[5], z[8] = U[8];
        return z;
      }
      function W(z, U) {
        var O = U[0], ll = U[1], _ = U[2], Zl = U[3], $ = U[4], ol = U[5], al = U[6], g = U[7], k = U[8], j = k * $ - ol * g, A = -k * Zl + ol * al, M = g * Zl - $ * al, Q = O * j + ll * A + _ * M;
        return Q ? (Q = 1 / Q, z[0] = j * Q, z[1] = (-k * ll + _ * g) * Q, z[2] = (ol * ll - _ * $) * Q, z[3] = A * Q, z[4] = (k * O - _ * al) * Q, z[5] = (-ol * O + _ * Zl) * Q, z[6] = M * Q, z[7] = (-g * O + ll * al) * Q, z[8] = ($ * O - ll * Zl) * Q, z) : null;
      }
      function h(z, U) {
        var O = U[0], ll = U[1], _ = U[2], Zl = U[3], $ = U[4], ol = U[5], al = U[6], g = U[7], k = U[8];
        return z[0] = $ * k - ol * g, z[1] = _ * g - ll * k, z[2] = ll * ol - _ * $, z[3] = ol * al - Zl * k, z[4] = O * k - _ * al, z[5] = _ * Zl - O * ol, z[6] = Zl * g - $ * al, z[7] = ll * al - O * g, z[8] = O * $ - ll * Zl, z;
      }
      function r(z) {
        var U = z[0], O = z[1], ll = z[2], _ = z[3], Zl = z[4], $ = z[5], ol = z[6], al = z[7], g = z[8];
        return U * (g * Zl - $ * al) + O * (-g * _ + $ * ol) + ll * (al * _ - Zl * ol);
      }
      function L(z, U, O) {
        var ll = U[0], _ = U[1], Zl = U[2], $ = U[3], ol = U[4], al = U[5], g = U[6], k = U[7], j = U[8], A = O[0], M = O[1], Q = O[2], p = O[3], x = O[4], F = O[5], v = O[6], f = O[7], E = O[8];
        return z[0] = A * ll + M * $ + Q * g, z[1] = A * _ + M * ol + Q * k, z[2] = A * Zl + M * al + Q * j, z[3] = p * ll + x * $ + F * g, z[4] = p * _ + x * ol + F * k, z[5] = p * Zl + x * al + F * j, z[6] = v * ll + f * $ + E * g, z[7] = v * _ + f * ol + E * k, z[8] = v * Zl + f * al + E * j, z;
      }
      function u(z, U, O) {
        var ll = U[0], _ = U[1], Zl = U[2], $ = U[3], ol = U[4], al = U[5], g = U[6], k = U[7], j = U[8], A = O[0], M = O[1];
        return z[0] = ll, z[1] = _, z[2] = Zl, z[3] = $, z[4] = ol, z[5] = al, z[6] = A * ll + M * $ + g, z[7] = A * _ + M * ol + k, z[8] = A * Zl + M * al + j, z;
      }
      function V(z, U, O) {
        var ll = U[0], _ = U[1], Zl = U[2], $ = U[3], ol = U[4], al = U[5], g = U[6], k = U[7], j = U[8], A = Math.sin(O), M = Math.cos(O);
        return z[0] = M * ll + A * $, z[1] = M * _ + A * ol, z[2] = M * Zl + A * al, z[3] = M * $ - A * ll, z[4] = M * ol - A * _, z[5] = M * al - A * Zl, z[6] = g, z[7] = k, z[8] = j, z;
      }
      function c(z, U, O) {
        var ll = O[0], _ = O[1];
        return z[0] = ll * U[0], z[1] = ll * U[1], z[2] = ll * U[2], z[3] = _ * U[3], z[4] = _ * U[4], z[5] = _ * U[5], z[6] = U[6], z[7] = U[7], z[8] = U[8], z;
      }
      function n(z, U) {
        return z[0] = 1, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = 1, z[5] = 0, z[6] = U[0], z[7] = U[1], z[8] = 1, z;
      }
      function e(z, U) {
        var O = Math.sin(U), ll = Math.cos(U);
        return z[0] = ll, z[1] = O, z[2] = 0, z[3] = -O, z[4] = ll, z[5] = 0, z[6] = 0, z[7] = 0, z[8] = 1, z;
      }
      function a(z, U) {
        return z[0] = U[0], z[1] = 0, z[2] = 0, z[3] = 0, z[4] = U[1], z[5] = 0, z[6] = 0, z[7] = 0, z[8] = 1, z;
      }
      function Y(z, U) {
        return z[0] = U[0], z[1] = U[1], z[2] = 0, z[3] = U[2], z[4] = U[3], z[5] = 0, z[6] = U[4], z[7] = U[5], z[8] = 1, z;
      }
      function R(z, U) {
        var O = U[0], ll = U[1], _ = U[2], Zl = U[3], $ = O + O, ol = ll + ll, al = _ + _, g = O * $, k = ll * $, j = ll * ol, A = _ * $, M = _ * ol, Q = _ * al, p = Zl * $, x = Zl * ol, F = Zl * al;
        return z[0] = 1 - j - Q, z[3] = k - F, z[6] = A + x, z[1] = k + F, z[4] = 1 - g - Q, z[7] = M - p, z[2] = A - x, z[5] = M + p, z[8] = 1 - g - j, z;
      }
      function C(z, U) {
        var O = U[0], ll = U[1], _ = U[2], Zl = U[3], $ = U[4], ol = U[5], al = U[6], g = U[7], k = U[8], j = U[9], A = U[10], M = U[11], Q = U[12], p = U[13], x = U[14], F = U[15], v = O * ol - ll * $, f = O * al - _ * $, E = O * g - Zl * $, q = ll * al - _ * ol, dl = ll * g - Zl * ol, tl = _ * g - Zl * al, ml = k * p - j * Q, el = k * x - A * Q, cl = k * F - M * Q, sl = j * x - A * p, nl = j * F - M * p, Gl = A * F - M * x, Wl = v * Gl - f * nl + E * sl + q * cl - dl * el + tl * ml;
        return Wl ? (Wl = 1 / Wl, z[0] = (ol * Gl - al * nl + g * sl) * Wl, z[1] = (al * cl - $ * Gl - g * el) * Wl, z[2] = ($ * nl - ol * cl + g * ml) * Wl, z[3] = (_ * nl - ll * Gl - Zl * sl) * Wl, z[4] = (O * Gl - _ * cl + Zl * el) * Wl, z[5] = (ll * cl - O * nl - Zl * ml) * Wl, z[6] = (p * tl - x * dl + F * q) * Wl, z[7] = (x * E - Q * tl - F * f) * Wl, z[8] = (Q * dl - p * E + F * v) * Wl, z) : null;
      }
      function N(z, U, O) {
        return z[0] = 2 / U, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = -2 / O, z[5] = 0, z[6] = -1, z[7] = 1, z[8] = 1, z;
      }
      function I(z) {
        return "mat3(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ", " + z[4] + ", " + z[5] + ", " + z[6] + ", " + z[7] + ", " + z[8] + ")";
      }
      function J(z) {
        return Math.hypot(z[0], z[1], z[2], z[3], z[4], z[5], z[6], z[7], z[8]);
      }
      function T(z, U, O) {
        return z[0] = U[0] + O[0], z[1] = U[1] + O[1], z[2] = U[2] + O[2], z[3] = U[3] + O[3], z[4] = U[4] + O[4], z[5] = U[5] + O[5], z[6] = U[6] + O[6], z[7] = U[7] + O[7], z[8] = U[8] + O[8], z;
      }
      function K(z, U, O) {
        return z[0] = U[0] - O[0], z[1] = U[1] - O[1], z[2] = U[2] - O[2], z[3] = U[3] - O[3], z[4] = U[4] - O[4], z[5] = U[5] - O[5], z[6] = U[6] - O[6], z[7] = U[7] - O[7], z[8] = U[8] - O[8], z;
      }
      function S(z, U, O) {
        return z[0] = U[0] * O, z[1] = U[1] * O, z[2] = U[2] * O, z[3] = U[3] * O, z[4] = U[4] * O, z[5] = U[5] * O, z[6] = U[6] * O, z[7] = U[7] * O, z[8] = U[8] * O, z;
      }
      function H(z, U, O, ll) {
        return z[0] = U[0] + O[0] * ll, z[1] = U[1] + O[1] * ll, z[2] = U[2] + O[2] * ll, z[3] = U[3] + O[3] * ll, z[4] = U[4] + O[4] * ll, z[5] = U[5] + O[5] * ll, z[6] = U[6] + O[6] * ll, z[7] = U[7] + O[7] * ll, z[8] = U[8] + O[8] * ll, z;
      }
      function w(z, U) {
        return z[0] === U[0] && z[1] === U[1] && z[2] === U[2] && z[3] === U[3] && z[4] === U[4] && z[5] === U[5] && z[6] === U[6] && z[7] === U[7] && z[8] === U[8];
      }
      function P(z, U) {
        var O = z[0], ll = z[1], _ = z[2], Zl = z[3], $ = z[4], ol = z[5], al = z[6], g = z[7], k = z[8], j = U[0], A = U[1], M = U[2], Q = U[3], p = U[4], x = U[5], F = U[6], v = U[7], f = U[8];
        return Math.abs(O - j) <= i.EPSILON * Math.max(1, Math.abs(O), Math.abs(j)) && Math.abs(ll - A) <= i.EPSILON * Math.max(1, Math.abs(ll), Math.abs(A)) && Math.abs(_ - M) <= i.EPSILON * Math.max(1, Math.abs(_), Math.abs(M)) && Math.abs(Zl - Q) <= i.EPSILON * Math.max(1, Math.abs(Zl), Math.abs(Q)) && Math.abs($ - p) <= i.EPSILON * Math.max(1, Math.abs($), Math.abs(p)) && Math.abs(ol - x) <= i.EPSILON * Math.max(1, Math.abs(ol), Math.abs(x)) && Math.abs(al - F) <= i.EPSILON * Math.max(1, Math.abs(al), Math.abs(F)) && Math.abs(g - v) <= i.EPSILON * Math.max(1, Math.abs(g), Math.abs(v)) && Math.abs(k - f) <= i.EPSILON * Math.max(1, Math.abs(k), Math.abs(f));
      }
      var B = L, D = K;
    },
    /* 6 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return t;
      }), l.d(d, "clone", function() {
        return s;
      }), l.d(d, "copy", function() {
        return b;
      }), l.d(d, "fromValues", function() {
        return Z;
      }), l.d(d, "set", function() {
        return o;
      }), l.d(d, "identity", function() {
        return G;
      }), l.d(d, "transpose", function() {
        return y;
      }), l.d(d, "invert", function() {
        return X;
      }), l.d(d, "adjoint", function() {
        return W;
      }), l.d(d, "determinant", function() {
        return h;
      }), l.d(d, "multiply", function() {
        return r;
      }), l.d(d, "translate", function() {
        return L;
      }), l.d(d, "scale", function() {
        return u;
      }), l.d(d, "rotate", function() {
        return V;
      }), l.d(d, "rotateX", function() {
        return c;
      }), l.d(d, "rotateY", function() {
        return n;
      }), l.d(d, "rotateZ", function() {
        return e;
      }), l.d(d, "fromTranslation", function() {
        return a;
      }), l.d(d, "fromScaling", function() {
        return Y;
      }), l.d(d, "fromRotation", function() {
        return R;
      }), l.d(d, "fromXRotation", function() {
        return C;
      }), l.d(d, "fromYRotation", function() {
        return N;
      }), l.d(d, "fromZRotation", function() {
        return I;
      }), l.d(d, "fromRotationTranslation", function() {
        return J;
      }), l.d(d, "fromQuat2", function() {
        return T;
      }), l.d(d, "getTranslation", function() {
        return K;
      }), l.d(d, "getScaling", function() {
        return S;
      }), l.d(d, "getRotation", function() {
        return H;
      }), l.d(d, "fromRotationTranslationScale", function() {
        return w;
      }), l.d(d, "fromRotationTranslationScaleOrigin", function() {
        return P;
      }), l.d(d, "fromQuat", function() {
        return B;
      }), l.d(d, "frustum", function() {
        return D;
      }), l.d(d, "perspective", function() {
        return z;
      }), l.d(d, "perspectiveFromFieldOfView", function() {
        return U;
      }), l.d(d, "ortho", function() {
        return O;
      }), l.d(d, "lookAt", function() {
        return ll;
      }), l.d(d, "targetTo", function() {
        return _;
      }), l.d(d, "str", function() {
        return Zl;
      }), l.d(d, "frob", function() {
        return $;
      }), l.d(d, "add", function() {
        return ol;
      }), l.d(d, "subtract", function() {
        return al;
      }), l.d(d, "multiplyScalar", function() {
        return g;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return k;
      }), l.d(d, "exactEquals", function() {
        return j;
      }), l.d(d, "equals", function() {
        return A;
      }), l.d(d, "mul", function() {
        return M;
      }), l.d(d, "sub", function() {
        return Q;
      });
      var i = l(2);
      function t() {
        var p = new i.ARRAY_TYPE(16);
        return i.ARRAY_TYPE != Float32Array && (p[1] = 0, p[2] = 0, p[3] = 0, p[4] = 0, p[6] = 0, p[7] = 0, p[8] = 0, p[9] = 0, p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0), p[0] = 1, p[5] = 1, p[10] = 1, p[15] = 1, p;
      }
      function s(p) {
        var x = new i.ARRAY_TYPE(16);
        return x[0] = p[0], x[1] = p[1], x[2] = p[2], x[3] = p[3], x[4] = p[4], x[5] = p[5], x[6] = p[6], x[7] = p[7], x[8] = p[8], x[9] = p[9], x[10] = p[10], x[11] = p[11], x[12] = p[12], x[13] = p[13], x[14] = p[14], x[15] = p[15], x;
      }
      function b(p, x) {
        return p[0] = x[0], p[1] = x[1], p[2] = x[2], p[3] = x[3], p[4] = x[4], p[5] = x[5], p[6] = x[6], p[7] = x[7], p[8] = x[8], p[9] = x[9], p[10] = x[10], p[11] = x[11], p[12] = x[12], p[13] = x[13], p[14] = x[14], p[15] = x[15], p;
      }
      function Z(p, x, F, v, f, E, q, dl, tl, ml, el, cl, sl, nl, Gl, Wl) {
        var Xl = new i.ARRAY_TYPE(16);
        return Xl[0] = p, Xl[1] = x, Xl[2] = F, Xl[3] = v, Xl[4] = f, Xl[5] = E, Xl[6] = q, Xl[7] = dl, Xl[8] = tl, Xl[9] = ml, Xl[10] = el, Xl[11] = cl, Xl[12] = sl, Xl[13] = nl, Xl[14] = Gl, Xl[15] = Wl, Xl;
      }
      function o(p, x, F, v, f, E, q, dl, tl, ml, el, cl, sl, nl, Gl, Wl, Xl) {
        return p[0] = x, p[1] = F, p[2] = v, p[3] = f, p[4] = E, p[5] = q, p[6] = dl, p[7] = tl, p[8] = ml, p[9] = el, p[10] = cl, p[11] = sl, p[12] = nl, p[13] = Gl, p[14] = Wl, p[15] = Xl, p;
      }
      function G(p) {
        return p[0] = 1, p[1] = 0, p[2] = 0, p[3] = 0, p[4] = 0, p[5] = 1, p[6] = 0, p[7] = 0, p[8] = 0, p[9] = 0, p[10] = 1, p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0, p[15] = 1, p;
      }
      function y(p, x) {
        if (p === x) {
          var F = x[1], v = x[2], f = x[3], E = x[6], q = x[7], dl = x[11];
          p[1] = x[4], p[2] = x[8], p[3] = x[12], p[4] = F, p[6] = x[9], p[7] = x[13], p[8] = v, p[9] = E, p[11] = x[14], p[12] = f, p[13] = q, p[14] = dl;
        } else
          p[0] = x[0], p[1] = x[4], p[2] = x[8], p[3] = x[12], p[4] = x[1], p[5] = x[5], p[6] = x[9], p[7] = x[13], p[8] = x[2], p[9] = x[6], p[10] = x[10], p[11] = x[14], p[12] = x[3], p[13] = x[7], p[14] = x[11], p[15] = x[15];
        return p;
      }
      function X(p, x) {
        var F = x[0], v = x[1], f = x[2], E = x[3], q = x[4], dl = x[5], tl = x[6], ml = x[7], el = x[8], cl = x[9], sl = x[10], nl = x[11], Gl = x[12], Wl = x[13], Xl = x[14], yl = x[15], Cl = F * dl - v * q, rl = F * tl - f * q, Rl = F * ml - E * q, Sl = v * tl - f * dl, Kl = v * ml - E * dl, Bl = f * ml - E * tl, Pl = el * Wl - cl * Gl, fl = el * Xl - sl * Gl, jl = el * yl - nl * Gl, Ol = cl * Xl - sl * Wl, Dl = cl * yl - nl * Wl, ld = sl * yl - nl * Xl, Hl = Cl * ld - rl * Dl + Rl * Ol + Sl * jl - Kl * fl + Bl * Pl;
        return Hl ? (Hl = 1 / Hl, p[0] = (dl * ld - tl * Dl + ml * Ol) * Hl, p[1] = (f * Dl - v * ld - E * Ol) * Hl, p[2] = (Wl * Bl - Xl * Kl + yl * Sl) * Hl, p[3] = (sl * Kl - cl * Bl - nl * Sl) * Hl, p[4] = (tl * jl - q * ld - ml * fl) * Hl, p[5] = (F * ld - f * jl + E * fl) * Hl, p[6] = (Xl * Rl - Gl * Bl - yl * rl) * Hl, p[7] = (el * Bl - sl * Rl + nl * rl) * Hl, p[8] = (q * Dl - dl * jl + ml * Pl) * Hl, p[9] = (v * jl - F * Dl - E * Pl) * Hl, p[10] = (Gl * Kl - Wl * Rl + yl * Cl) * Hl, p[11] = (cl * Rl - el * Kl - nl * Cl) * Hl, p[12] = (dl * fl - q * Ol - tl * Pl) * Hl, p[13] = (F * Ol - v * fl + f * Pl) * Hl, p[14] = (Wl * rl - Gl * Sl - Xl * Cl) * Hl, p[15] = (el * Sl - cl * rl + sl * Cl) * Hl, p) : null;
      }
      function W(p, x) {
        var F = x[0], v = x[1], f = x[2], E = x[3], q = x[4], dl = x[5], tl = x[6], ml = x[7], el = x[8], cl = x[9], sl = x[10], nl = x[11], Gl = x[12], Wl = x[13], Xl = x[14], yl = x[15];
        return p[0] = dl * (sl * yl - nl * Xl) - cl * (tl * yl - ml * Xl) + Wl * (tl * nl - ml * sl), p[1] = -(v * (sl * yl - nl * Xl) - cl * (f * yl - E * Xl) + Wl * (f * nl - E * sl)), p[2] = v * (tl * yl - ml * Xl) - dl * (f * yl - E * Xl) + Wl * (f * ml - E * tl), p[3] = -(v * (tl * nl - ml * sl) - dl * (f * nl - E * sl) + cl * (f * ml - E * tl)), p[4] = -(q * (sl * yl - nl * Xl) - el * (tl * yl - ml * Xl) + Gl * (tl * nl - ml * sl)), p[5] = F * (sl * yl - nl * Xl) - el * (f * yl - E * Xl) + Gl * (f * nl - E * sl), p[6] = -(F * (tl * yl - ml * Xl) - q * (f * yl - E * Xl) + Gl * (f * ml - E * tl)), p[7] = F * (tl * nl - ml * sl) - q * (f * nl - E * sl) + el * (f * ml - E * tl), p[8] = q * (cl * yl - nl * Wl) - el * (dl * yl - ml * Wl) + Gl * (dl * nl - ml * cl), p[9] = -(F * (cl * yl - nl * Wl) - el * (v * yl - E * Wl) + Gl * (v * nl - E * cl)), p[10] = F * (dl * yl - ml * Wl) - q * (v * yl - E * Wl) + Gl * (v * ml - E * dl), p[11] = -(F * (dl * nl - ml * cl) - q * (v * nl - E * cl) + el * (v * ml - E * dl)), p[12] = -(q * (cl * Xl - sl * Wl) - el * (dl * Xl - tl * Wl) + Gl * (dl * sl - tl * cl)), p[13] = F * (cl * Xl - sl * Wl) - el * (v * Xl - f * Wl) + Gl * (v * sl - f * cl), p[14] = -(F * (dl * Xl - tl * Wl) - q * (v * Xl - f * Wl) + Gl * (v * tl - f * dl)), p[15] = F * (dl * sl - tl * cl) - q * (v * sl - f * cl) + el * (v * tl - f * dl), p;
      }
      function h(p) {
        var x = p[0], F = p[1], v = p[2], f = p[3], E = p[4], q = p[5], dl = p[6], tl = p[7], ml = p[8], el = p[9], cl = p[10], sl = p[11], nl = p[12], Gl = p[13], Wl = p[14], Xl = p[15], yl = x * q - F * E, Cl = x * dl - v * E, rl = x * tl - f * E, Rl = F * dl - v * q, Sl = F * tl - f * q, Kl = v * tl - f * dl, Bl = ml * Gl - el * nl, Pl = ml * Wl - cl * nl, fl = ml * Xl - sl * nl, jl = el * Wl - cl * Gl, Ol = el * Xl - sl * Gl, Dl = cl * Xl - sl * Wl;
        return yl * Dl - Cl * Ol + rl * jl + Rl * fl - Sl * Pl + Kl * Bl;
      }
      function r(p, x, F) {
        var v = x[0], f = x[1], E = x[2], q = x[3], dl = x[4], tl = x[5], ml = x[6], el = x[7], cl = x[8], sl = x[9], nl = x[10], Gl = x[11], Wl = x[12], Xl = x[13], yl = x[14], Cl = x[15], rl = F[0], Rl = F[1], Sl = F[2], Kl = F[3];
        return p[0] = rl * v + Rl * dl + Sl * cl + Kl * Wl, p[1] = rl * f + Rl * tl + Sl * sl + Kl * Xl, p[2] = rl * E + Rl * ml + Sl * nl + Kl * yl, p[3] = rl * q + Rl * el + Sl * Gl + Kl * Cl, rl = F[4], Rl = F[5], Sl = F[6], Kl = F[7], p[4] = rl * v + Rl * dl + Sl * cl + Kl * Wl, p[5] = rl * f + Rl * tl + Sl * sl + Kl * Xl, p[6] = rl * E + Rl * ml + Sl * nl + Kl * yl, p[7] = rl * q + Rl * el + Sl * Gl + Kl * Cl, rl = F[8], Rl = F[9], Sl = F[10], Kl = F[11], p[8] = rl * v + Rl * dl + Sl * cl + Kl * Wl, p[9] = rl * f + Rl * tl + Sl * sl + Kl * Xl, p[10] = rl * E + Rl * ml + Sl * nl + Kl * yl, p[11] = rl * q + Rl * el + Sl * Gl + Kl * Cl, rl = F[12], Rl = F[13], Sl = F[14], Kl = F[15], p[12] = rl * v + Rl * dl + Sl * cl + Kl * Wl, p[13] = rl * f + Rl * tl + Sl * sl + Kl * Xl, p[14] = rl * E + Rl * ml + Sl * nl + Kl * yl, p[15] = rl * q + Rl * el + Sl * Gl + Kl * Cl, p;
      }
      function L(p, x, F) {
        var v = F[0], f = F[1], E = F[2], q, dl, tl, ml, el, cl, sl, nl, Gl, Wl, Xl, yl;
        return x === p ? (p[12] = x[0] * v + x[4] * f + x[8] * E + x[12], p[13] = x[1] * v + x[5] * f + x[9] * E + x[13], p[14] = x[2] * v + x[6] * f + x[10] * E + x[14], p[15] = x[3] * v + x[7] * f + x[11] * E + x[15]) : (q = x[0], dl = x[1], tl = x[2], ml = x[3], el = x[4], cl = x[5], sl = x[6], nl = x[7], Gl = x[8], Wl = x[9], Xl = x[10], yl = x[11], p[0] = q, p[1] = dl, p[2] = tl, p[3] = ml, p[4] = el, p[5] = cl, p[6] = sl, p[7] = nl, p[8] = Gl, p[9] = Wl, p[10] = Xl, p[11] = yl, p[12] = q * v + el * f + Gl * E + x[12], p[13] = dl * v + cl * f + Wl * E + x[13], p[14] = tl * v + sl * f + Xl * E + x[14], p[15] = ml * v + nl * f + yl * E + x[15]), p;
      }
      function u(p, x, F) {
        var v = F[0], f = F[1], E = F[2];
        return p[0] = x[0] * v, p[1] = x[1] * v, p[2] = x[2] * v, p[3] = x[3] * v, p[4] = x[4] * f, p[5] = x[5] * f, p[6] = x[6] * f, p[7] = x[7] * f, p[8] = x[8] * E, p[9] = x[9] * E, p[10] = x[10] * E, p[11] = x[11] * E, p[12] = x[12], p[13] = x[13], p[14] = x[14], p[15] = x[15], p;
      }
      function V(p, x, F, v) {
        var f = v[0], E = v[1], q = v[2], dl = Math.hypot(f, E, q), tl, ml, el, cl, sl, nl, Gl, Wl, Xl, yl, Cl, rl, Rl, Sl, Kl, Bl, Pl, fl, jl, Ol, Dl, ld, Hl, Xd;
        return dl < i.EPSILON ? null : (dl = 1 / dl, f *= dl, E *= dl, q *= dl, tl = Math.sin(F), ml = Math.cos(F), el = 1 - ml, cl = x[0], sl = x[1], nl = x[2], Gl = x[3], Wl = x[4], Xl = x[5], yl = x[6], Cl = x[7], rl = x[8], Rl = x[9], Sl = x[10], Kl = x[11], Bl = f * f * el + ml, Pl = E * f * el + q * tl, fl = q * f * el - E * tl, jl = f * E * el - q * tl, Ol = E * E * el + ml, Dl = q * E * el + f * tl, ld = f * q * el + E * tl, Hl = E * q * el - f * tl, Xd = q * q * el + ml, p[0] = cl * Bl + Wl * Pl + rl * fl, p[1] = sl * Bl + Xl * Pl + Rl * fl, p[2] = nl * Bl + yl * Pl + Sl * fl, p[3] = Gl * Bl + Cl * Pl + Kl * fl, p[4] = cl * jl + Wl * Ol + rl * Dl, p[5] = sl * jl + Xl * Ol + Rl * Dl, p[6] = nl * jl + yl * Ol + Sl * Dl, p[7] = Gl * jl + Cl * Ol + Kl * Dl, p[8] = cl * ld + Wl * Hl + rl * Xd, p[9] = sl * ld + Xl * Hl + Rl * Xd, p[10] = nl * ld + yl * Hl + Sl * Xd, p[11] = Gl * ld + Cl * Hl + Kl * Xd, x !== p && (p[12] = x[12], p[13] = x[13], p[14] = x[14], p[15] = x[15]), p);
      }
      function c(p, x, F) {
        var v = Math.sin(F), f = Math.cos(F), E = x[4], q = x[5], dl = x[6], tl = x[7], ml = x[8], el = x[9], cl = x[10], sl = x[11];
        return x !== p && (p[0] = x[0], p[1] = x[1], p[2] = x[2], p[3] = x[3], p[12] = x[12], p[13] = x[13], p[14] = x[14], p[15] = x[15]), p[4] = E * f + ml * v, p[5] = q * f + el * v, p[6] = dl * f + cl * v, p[7] = tl * f + sl * v, p[8] = ml * f - E * v, p[9] = el * f - q * v, p[10] = cl * f - dl * v, p[11] = sl * f - tl * v, p;
      }
      function n(p, x, F) {
        var v = Math.sin(F), f = Math.cos(F), E = x[0], q = x[1], dl = x[2], tl = x[3], ml = x[8], el = x[9], cl = x[10], sl = x[11];
        return x !== p && (p[4] = x[4], p[5] = x[5], p[6] = x[6], p[7] = x[7], p[12] = x[12], p[13] = x[13], p[14] = x[14], p[15] = x[15]), p[0] = E * f - ml * v, p[1] = q * f - el * v, p[2] = dl * f - cl * v, p[3] = tl * f - sl * v, p[8] = E * v + ml * f, p[9] = q * v + el * f, p[10] = dl * v + cl * f, p[11] = tl * v + sl * f, p;
      }
      function e(p, x, F) {
        var v = Math.sin(F), f = Math.cos(F), E = x[0], q = x[1], dl = x[2], tl = x[3], ml = x[4], el = x[5], cl = x[6], sl = x[7];
        return x !== p && (p[8] = x[8], p[9] = x[9], p[10] = x[10], p[11] = x[11], p[12] = x[12], p[13] = x[13], p[14] = x[14], p[15] = x[15]), p[0] = E * f + ml * v, p[1] = q * f + el * v, p[2] = dl * f + cl * v, p[3] = tl * f + sl * v, p[4] = ml * f - E * v, p[5] = el * f - q * v, p[6] = cl * f - dl * v, p[7] = sl * f - tl * v, p;
      }
      function a(p, x) {
        return p[0] = 1, p[1] = 0, p[2] = 0, p[3] = 0, p[4] = 0, p[5] = 1, p[6] = 0, p[7] = 0, p[8] = 0, p[9] = 0, p[10] = 1, p[11] = 0, p[12] = x[0], p[13] = x[1], p[14] = x[2], p[15] = 1, p;
      }
      function Y(p, x) {
        return p[0] = x[0], p[1] = 0, p[2] = 0, p[3] = 0, p[4] = 0, p[5] = x[1], p[6] = 0, p[7] = 0, p[8] = 0, p[9] = 0, p[10] = x[2], p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0, p[15] = 1, p;
      }
      function R(p, x, F) {
        var v = F[0], f = F[1], E = F[2], q = Math.hypot(v, f, E), dl, tl, ml;
        return q < i.EPSILON ? null : (q = 1 / q, v *= q, f *= q, E *= q, dl = Math.sin(x), tl = Math.cos(x), ml = 1 - tl, p[0] = v * v * ml + tl, p[1] = f * v * ml + E * dl, p[2] = E * v * ml - f * dl, p[3] = 0, p[4] = v * f * ml - E * dl, p[5] = f * f * ml + tl, p[6] = E * f * ml + v * dl, p[7] = 0, p[8] = v * E * ml + f * dl, p[9] = f * E * ml - v * dl, p[10] = E * E * ml + tl, p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0, p[15] = 1, p);
      }
      function C(p, x) {
        var F = Math.sin(x), v = Math.cos(x);
        return p[0] = 1, p[1] = 0, p[2] = 0, p[3] = 0, p[4] = 0, p[5] = v, p[6] = F, p[7] = 0, p[8] = 0, p[9] = -F, p[10] = v, p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0, p[15] = 1, p;
      }
      function N(p, x) {
        var F = Math.sin(x), v = Math.cos(x);
        return p[0] = v, p[1] = 0, p[2] = -F, p[3] = 0, p[4] = 0, p[5] = 1, p[6] = 0, p[7] = 0, p[8] = F, p[9] = 0, p[10] = v, p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0, p[15] = 1, p;
      }
      function I(p, x) {
        var F = Math.sin(x), v = Math.cos(x);
        return p[0] = v, p[1] = F, p[2] = 0, p[3] = 0, p[4] = -F, p[5] = v, p[6] = 0, p[7] = 0, p[8] = 0, p[9] = 0, p[10] = 1, p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0, p[15] = 1, p;
      }
      function J(p, x, F) {
        var v = x[0], f = x[1], E = x[2], q = x[3], dl = v + v, tl = f + f, ml = E + E, el = v * dl, cl = v * tl, sl = v * ml, nl = f * tl, Gl = f * ml, Wl = E * ml, Xl = q * dl, yl = q * tl, Cl = q * ml;
        return p[0] = 1 - (nl + Wl), p[1] = cl + Cl, p[2] = sl - yl, p[3] = 0, p[4] = cl - Cl, p[5] = 1 - (el + Wl), p[6] = Gl + Xl, p[7] = 0, p[8] = sl + yl, p[9] = Gl - Xl, p[10] = 1 - (el + nl), p[11] = 0, p[12] = F[0], p[13] = F[1], p[14] = F[2], p[15] = 1, p;
      }
      function T(p, x) {
        var F = new i.ARRAY_TYPE(3), v = -x[0], f = -x[1], E = -x[2], q = x[3], dl = x[4], tl = x[5], ml = x[6], el = x[7], cl = v * v + f * f + E * E + q * q;
        return cl > 0 ? (F[0] = (dl * q + el * v + tl * E - ml * f) * 2 / cl, F[1] = (tl * q + el * f + ml * v - dl * E) * 2 / cl, F[2] = (ml * q + el * E + dl * f - tl * v) * 2 / cl) : (F[0] = (dl * q + el * v + tl * E - ml * f) * 2, F[1] = (tl * q + el * f + ml * v - dl * E) * 2, F[2] = (ml * q + el * E + dl * f - tl * v) * 2), J(p, x, F), p;
      }
      function K(p, x) {
        return p[0] = x[12], p[1] = x[13], p[2] = x[14], p;
      }
      function S(p, x) {
        var F = x[0], v = x[1], f = x[2], E = x[4], q = x[5], dl = x[6], tl = x[8], ml = x[9], el = x[10];
        return p[0] = Math.hypot(F, v, f), p[1] = Math.hypot(E, q, dl), p[2] = Math.hypot(tl, ml, el), p;
      }
      function H(p, x) {
        var F = new i.ARRAY_TYPE(3);
        S(F, x);
        var v = 1 / F[0], f = 1 / F[1], E = 1 / F[2], q = x[0] * v, dl = x[1] * f, tl = x[2] * E, ml = x[4] * v, el = x[5] * f, cl = x[6] * E, sl = x[8] * v, nl = x[9] * f, Gl = x[10] * E, Wl = q + el + Gl, Xl = 0;
        return Wl > 0 ? (Xl = Math.sqrt(Wl + 1) * 2, p[3] = 0.25 * Xl, p[0] = (cl - nl) / Xl, p[1] = (sl - tl) / Xl, p[2] = (dl - ml) / Xl) : q > el && q > Gl ? (Xl = Math.sqrt(1 + q - el - Gl) * 2, p[3] = (cl - nl) / Xl, p[0] = 0.25 * Xl, p[1] = (dl + ml) / Xl, p[2] = (sl + tl) / Xl) : el > Gl ? (Xl = Math.sqrt(1 + el - q - Gl) * 2, p[3] = (sl - tl) / Xl, p[0] = (dl + ml) / Xl, p[1] = 0.25 * Xl, p[2] = (cl + nl) / Xl) : (Xl = Math.sqrt(1 + Gl - q - el) * 2, p[3] = (dl - ml) / Xl, p[0] = (sl + tl) / Xl, p[1] = (cl + nl) / Xl, p[2] = 0.25 * Xl), p;
      }
      function w(p, x, F, v) {
        var f = x[0], E = x[1], q = x[2], dl = x[3], tl = f + f, ml = E + E, el = q + q, cl = f * tl, sl = f * ml, nl = f * el, Gl = E * ml, Wl = E * el, Xl = q * el, yl = dl * tl, Cl = dl * ml, rl = dl * el, Rl = v[0], Sl = v[1], Kl = v[2];
        return p[0] = (1 - (Gl + Xl)) * Rl, p[1] = (sl + rl) * Rl, p[2] = (nl - Cl) * Rl, p[3] = 0, p[4] = (sl - rl) * Sl, p[5] = (1 - (cl + Xl)) * Sl, p[6] = (Wl + yl) * Sl, p[7] = 0, p[8] = (nl + Cl) * Kl, p[9] = (Wl - yl) * Kl, p[10] = (1 - (cl + Gl)) * Kl, p[11] = 0, p[12] = F[0], p[13] = F[1], p[14] = F[2], p[15] = 1, p;
      }
      function P(p, x, F, v, f) {
        var E = x[0], q = x[1], dl = x[2], tl = x[3], ml = E + E, el = q + q, cl = dl + dl, sl = E * ml, nl = E * el, Gl = E * cl, Wl = q * el, Xl = q * cl, yl = dl * cl, Cl = tl * ml, rl = tl * el, Rl = tl * cl, Sl = v[0], Kl = v[1], Bl = v[2], Pl = f[0], fl = f[1], jl = f[2], Ol = (1 - (Wl + yl)) * Sl, Dl = (nl + Rl) * Sl, ld = (Gl - rl) * Sl, Hl = (nl - Rl) * Kl, Xd = (1 - (sl + yl)) * Kl, Pd = (Xl + Cl) * Kl, fd = (Gl + rl) * Bl, ji = (Xl - Cl) * Bl, Ei = (1 - (sl + Wl)) * Bl;
        return p[0] = Ol, p[1] = Dl, p[2] = ld, p[3] = 0, p[4] = Hl, p[5] = Xd, p[6] = Pd, p[7] = 0, p[8] = fd, p[9] = ji, p[10] = Ei, p[11] = 0, p[12] = F[0] + Pl - (Ol * Pl + Hl * fl + fd * jl), p[13] = F[1] + fl - (Dl * Pl + Xd * fl + ji * jl), p[14] = F[2] + jl - (ld * Pl + Pd * fl + Ei * jl), p[15] = 1, p;
      }
      function B(p, x) {
        var F = x[0], v = x[1], f = x[2], E = x[3], q = F + F, dl = v + v, tl = f + f, ml = F * q, el = v * q, cl = v * dl, sl = f * q, nl = f * dl, Gl = f * tl, Wl = E * q, Xl = E * dl, yl = E * tl;
        return p[0] = 1 - cl - Gl, p[1] = el + yl, p[2] = sl - Xl, p[3] = 0, p[4] = el - yl, p[5] = 1 - ml - Gl, p[6] = nl + Wl, p[7] = 0, p[8] = sl + Xl, p[9] = nl - Wl, p[10] = 1 - ml - cl, p[11] = 0, p[12] = 0, p[13] = 0, p[14] = 0, p[15] = 1, p;
      }
      function D(p, x, F, v, f, E, q) {
        var dl = 1 / (F - x), tl = 1 / (f - v), ml = 1 / (E - q);
        return p[0] = E * 2 * dl, p[1] = 0, p[2] = 0, p[3] = 0, p[4] = 0, p[5] = E * 2 * tl, p[6] = 0, p[7] = 0, p[8] = (F + x) * dl, p[9] = (f + v) * tl, p[10] = (q + E) * ml, p[11] = -1, p[12] = 0, p[13] = 0, p[14] = q * E * 2 * ml, p[15] = 0, p;
      }
      function z(p, x, F, v, f) {
        var E = 1 / Math.tan(x / 2), q;
        return p[0] = E / F, p[1] = 0, p[2] = 0, p[3] = 0, p[4] = 0, p[5] = E, p[6] = 0, p[7] = 0, p[8] = 0, p[9] = 0, p[11] = -1, p[12] = 0, p[13] = 0, p[15] = 0, f != null && f !== 1 / 0 ? (q = 1 / (v - f), p[10] = (f + v) * q, p[14] = 2 * f * v * q) : (p[10] = -1, p[14] = -2 * v), p;
      }
      function U(p, x, F, v) {
        var f = Math.tan(x.upDegrees * Math.PI / 180), E = Math.tan(x.downDegrees * Math.PI / 180), q = Math.tan(x.leftDegrees * Math.PI / 180), dl = Math.tan(x.rightDegrees * Math.PI / 180), tl = 2 / (q + dl), ml = 2 / (f + E);
        return p[0] = tl, p[1] = 0, p[2] = 0, p[3] = 0, p[4] = 0, p[5] = ml, p[6] = 0, p[7] = 0, p[8] = -((q - dl) * tl * 0.5), p[9] = (f - E) * ml * 0.5, p[10] = v / (F - v), p[11] = -1, p[12] = 0, p[13] = 0, p[14] = v * F / (F - v), p[15] = 0, p;
      }
      function O(p, x, F, v, f, E, q) {
        var dl = 1 / (x - F), tl = 1 / (v - f), ml = 1 / (E - q);
        return p[0] = -2 * dl, p[1] = 0, p[2] = 0, p[3] = 0, p[4] = 0, p[5] = -2 * tl, p[6] = 0, p[7] = 0, p[8] = 0, p[9] = 0, p[10] = 2 * ml, p[11] = 0, p[12] = (x + F) * dl, p[13] = (f + v) * tl, p[14] = (q + E) * ml, p[15] = 1, p;
      }
      function ll(p, x, F, v) {
        var f, E, q, dl, tl, ml, el, cl, sl, nl, Gl = x[0], Wl = x[1], Xl = x[2], yl = v[0], Cl = v[1], rl = v[2], Rl = F[0], Sl = F[1], Kl = F[2];
        return Math.abs(Gl - Rl) < i.EPSILON && Math.abs(Wl - Sl) < i.EPSILON && Math.abs(Xl - Kl) < i.EPSILON ? G(p) : (el = Gl - Rl, cl = Wl - Sl, sl = Xl - Kl, nl = 1 / Math.hypot(el, cl, sl), el *= nl, cl *= nl, sl *= nl, f = Cl * sl - rl * cl, E = rl * el - yl * sl, q = yl * cl - Cl * el, nl = Math.hypot(f, E, q), nl ? (nl = 1 / nl, f *= nl, E *= nl, q *= nl) : (f = 0, E = 0, q = 0), dl = cl * q - sl * E, tl = sl * f - el * q, ml = el * E - cl * f, nl = Math.hypot(dl, tl, ml), nl ? (nl = 1 / nl, dl *= nl, tl *= nl, ml *= nl) : (dl = 0, tl = 0, ml = 0), p[0] = f, p[1] = dl, p[2] = el, p[3] = 0, p[4] = E, p[5] = tl, p[6] = cl, p[7] = 0, p[8] = q, p[9] = ml, p[10] = sl, p[11] = 0, p[12] = -(f * Gl + E * Wl + q * Xl), p[13] = -(dl * Gl + tl * Wl + ml * Xl), p[14] = -(el * Gl + cl * Wl + sl * Xl), p[15] = 1, p);
      }
      function _(p, x, F, v) {
        var f = x[0], E = x[1], q = x[2], dl = v[0], tl = v[1], ml = v[2], el = f - F[0], cl = E - F[1], sl = q - F[2], nl = el * el + cl * cl + sl * sl;
        nl > 0 && (nl = 1 / Math.sqrt(nl), el *= nl, cl *= nl, sl *= nl);
        var Gl = tl * sl - ml * cl, Wl = ml * el - dl * sl, Xl = dl * cl - tl * el;
        return nl = Gl * Gl + Wl * Wl + Xl * Xl, nl > 0 && (nl = 1 / Math.sqrt(nl), Gl *= nl, Wl *= nl, Xl *= nl), p[0] = Gl, p[1] = Wl, p[2] = Xl, p[3] = 0, p[4] = cl * Xl - sl * Wl, p[5] = sl * Gl - el * Xl, p[6] = el * Wl - cl * Gl, p[7] = 0, p[8] = el, p[9] = cl, p[10] = sl, p[11] = 0, p[12] = f, p[13] = E, p[14] = q, p[15] = 1, p;
      }
      function Zl(p) {
        return "mat4(" + p[0] + ", " + p[1] + ", " + p[2] + ", " + p[3] + ", " + p[4] + ", " + p[5] + ", " + p[6] + ", " + p[7] + ", " + p[8] + ", " + p[9] + ", " + p[10] + ", " + p[11] + ", " + p[12] + ", " + p[13] + ", " + p[14] + ", " + p[15] + ")";
      }
      function $(p) {
        return Math.hypot(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
      }
      function ol(p, x, F) {
        return p[0] = x[0] + F[0], p[1] = x[1] + F[1], p[2] = x[2] + F[2], p[3] = x[3] + F[3], p[4] = x[4] + F[4], p[5] = x[5] + F[5], p[6] = x[6] + F[6], p[7] = x[7] + F[7], p[8] = x[8] + F[8], p[9] = x[9] + F[9], p[10] = x[10] + F[10], p[11] = x[11] + F[11], p[12] = x[12] + F[12], p[13] = x[13] + F[13], p[14] = x[14] + F[14], p[15] = x[15] + F[15], p;
      }
      function al(p, x, F) {
        return p[0] = x[0] - F[0], p[1] = x[1] - F[1], p[2] = x[2] - F[2], p[3] = x[3] - F[3], p[4] = x[4] - F[4], p[5] = x[5] - F[5], p[6] = x[6] - F[6], p[7] = x[7] - F[7], p[8] = x[8] - F[8], p[9] = x[9] - F[9], p[10] = x[10] - F[10], p[11] = x[11] - F[11], p[12] = x[12] - F[12], p[13] = x[13] - F[13], p[14] = x[14] - F[14], p[15] = x[15] - F[15], p;
      }
      function g(p, x, F) {
        return p[0] = x[0] * F, p[1] = x[1] * F, p[2] = x[2] * F, p[3] = x[3] * F, p[4] = x[4] * F, p[5] = x[5] * F, p[6] = x[6] * F, p[7] = x[7] * F, p[8] = x[8] * F, p[9] = x[9] * F, p[10] = x[10] * F, p[11] = x[11] * F, p[12] = x[12] * F, p[13] = x[13] * F, p[14] = x[14] * F, p[15] = x[15] * F, p;
      }
      function k(p, x, F, v) {
        return p[0] = x[0] + F[0] * v, p[1] = x[1] + F[1] * v, p[2] = x[2] + F[2] * v, p[3] = x[3] + F[3] * v, p[4] = x[4] + F[4] * v, p[5] = x[5] + F[5] * v, p[6] = x[6] + F[6] * v, p[7] = x[7] + F[7] * v, p[8] = x[8] + F[8] * v, p[9] = x[9] + F[9] * v, p[10] = x[10] + F[10] * v, p[11] = x[11] + F[11] * v, p[12] = x[12] + F[12] * v, p[13] = x[13] + F[13] * v, p[14] = x[14] + F[14] * v, p[15] = x[15] + F[15] * v, p;
      }
      function j(p, x) {
        return p[0] === x[0] && p[1] === x[1] && p[2] === x[2] && p[3] === x[3] && p[4] === x[4] && p[5] === x[5] && p[6] === x[6] && p[7] === x[7] && p[8] === x[8] && p[9] === x[9] && p[10] === x[10] && p[11] === x[11] && p[12] === x[12] && p[13] === x[13] && p[14] === x[14] && p[15] === x[15];
      }
      function A(p, x) {
        var F = p[0], v = p[1], f = p[2], E = p[3], q = p[4], dl = p[5], tl = p[6], ml = p[7], el = p[8], cl = p[9], sl = p[10], nl = p[11], Gl = p[12], Wl = p[13], Xl = p[14], yl = p[15], Cl = x[0], rl = x[1], Rl = x[2], Sl = x[3], Kl = x[4], Bl = x[5], Pl = x[6], fl = x[7], jl = x[8], Ol = x[9], Dl = x[10], ld = x[11], Hl = x[12], Xd = x[13], Pd = x[14], fd = x[15];
        return Math.abs(F - Cl) <= i.EPSILON * Math.max(1, Math.abs(F), Math.abs(Cl)) && Math.abs(v - rl) <= i.EPSILON * Math.max(1, Math.abs(v), Math.abs(rl)) && Math.abs(f - Rl) <= i.EPSILON * Math.max(1, Math.abs(f), Math.abs(Rl)) && Math.abs(E - Sl) <= i.EPSILON * Math.max(1, Math.abs(E), Math.abs(Sl)) && Math.abs(q - Kl) <= i.EPSILON * Math.max(1, Math.abs(q), Math.abs(Kl)) && Math.abs(dl - Bl) <= i.EPSILON * Math.max(1, Math.abs(dl), Math.abs(Bl)) && Math.abs(tl - Pl) <= i.EPSILON * Math.max(1, Math.abs(tl), Math.abs(Pl)) && Math.abs(ml - fl) <= i.EPSILON * Math.max(1, Math.abs(ml), Math.abs(fl)) && Math.abs(el - jl) <= i.EPSILON * Math.max(1, Math.abs(el), Math.abs(jl)) && Math.abs(cl - Ol) <= i.EPSILON * Math.max(1, Math.abs(cl), Math.abs(Ol)) && Math.abs(sl - Dl) <= i.EPSILON * Math.max(1, Math.abs(sl), Math.abs(Dl)) && Math.abs(nl - ld) <= i.EPSILON * Math.max(1, Math.abs(nl), Math.abs(ld)) && Math.abs(Gl - Hl) <= i.EPSILON * Math.max(1, Math.abs(Gl), Math.abs(Hl)) && Math.abs(Wl - Xd) <= i.EPSILON * Math.max(1, Math.abs(Wl), Math.abs(Xd)) && Math.abs(Xl - Pd) <= i.EPSILON * Math.max(1, Math.abs(Xl), Math.abs(Pd)) && Math.abs(yl - fd) <= i.EPSILON * Math.max(1, Math.abs(yl), Math.abs(fd));
      }
      var M = r, Q = al;
    },
    /* 7 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return Z;
      }), l.d(d, "identity", function() {
        return o;
      }), l.d(d, "setAxisAngle", function() {
        return G;
      }), l.d(d, "getAxisAngle", function() {
        return y;
      }), l.d(d, "getAngle", function() {
        return X;
      }), l.d(d, "multiply", function() {
        return W;
      }), l.d(d, "rotateX", function() {
        return h;
      }), l.d(d, "rotateY", function() {
        return r;
      }), l.d(d, "rotateZ", function() {
        return L;
      }), l.d(d, "calculateW", function() {
        return u;
      }), l.d(d, "exp", function() {
        return V;
      }), l.d(d, "ln", function() {
        return c;
      }), l.d(d, "pow", function() {
        return n;
      }), l.d(d, "slerp", function() {
        return e;
      }), l.d(d, "random", function() {
        return a;
      }), l.d(d, "invert", function() {
        return Y;
      }), l.d(d, "conjugate", function() {
        return R;
      }), l.d(d, "fromMat3", function() {
        return C;
      }), l.d(d, "fromEuler", function() {
        return N;
      }), l.d(d, "str", function() {
        return I;
      }), l.d(d, "clone", function() {
        return J;
      }), l.d(d, "fromValues", function() {
        return T;
      }), l.d(d, "copy", function() {
        return K;
      }), l.d(d, "set", function() {
        return S;
      }), l.d(d, "add", function() {
        return H;
      }), l.d(d, "mul", function() {
        return w;
      }), l.d(d, "scale", function() {
        return P;
      }), l.d(d, "dot", function() {
        return B;
      }), l.d(d, "lerp", function() {
        return D;
      }), l.d(d, "length", function() {
        return z;
      }), l.d(d, "len", function() {
        return U;
      }), l.d(d, "squaredLength", function() {
        return O;
      }), l.d(d, "sqrLen", function() {
        return ll;
      }), l.d(d, "normalize", function() {
        return _;
      }), l.d(d, "exactEquals", function() {
        return Zl;
      }), l.d(d, "equals", function() {
        return $;
      }), l.d(d, "rotationTo", function() {
        return ol;
      }), l.d(d, "sqlerp", function() {
        return al;
      }), l.d(d, "setAxes", function() {
        return g;
      });
      var i = l(2), t = l(5), s = l(8), b = l(9);
      function Z() {
        var k = new i.ARRAY_TYPE(4);
        return i.ARRAY_TYPE != Float32Array && (k[0] = 0, k[1] = 0, k[2] = 0), k[3] = 1, k;
      }
      function o(k) {
        return k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 1, k;
      }
      function G(k, j, A) {
        A = A * 0.5;
        var M = Math.sin(A);
        return k[0] = M * j[0], k[1] = M * j[1], k[2] = M * j[2], k[3] = Math.cos(A), k;
      }
      function y(k, j) {
        var A = Math.acos(j[3]) * 2, M = Math.sin(A / 2);
        return M > i.EPSILON ? (k[0] = j[0] / M, k[1] = j[1] / M, k[2] = j[2] / M) : (k[0] = 1, k[1] = 0, k[2] = 0), A;
      }
      function X(k, j) {
        var A = B(k, j);
        return Math.acos(2 * A * A - 1);
      }
      function W(k, j, A) {
        var M = j[0], Q = j[1], p = j[2], x = j[3], F = A[0], v = A[1], f = A[2], E = A[3];
        return k[0] = M * E + x * F + Q * f - p * v, k[1] = Q * E + x * v + p * F - M * f, k[2] = p * E + x * f + M * v - Q * F, k[3] = x * E - M * F - Q * v - p * f, k;
      }
      function h(k, j, A) {
        A *= 0.5;
        var M = j[0], Q = j[1], p = j[2], x = j[3], F = Math.sin(A), v = Math.cos(A);
        return k[0] = M * v + x * F, k[1] = Q * v + p * F, k[2] = p * v - Q * F, k[3] = x * v - M * F, k;
      }
      function r(k, j, A) {
        A *= 0.5;
        var M = j[0], Q = j[1], p = j[2], x = j[3], F = Math.sin(A), v = Math.cos(A);
        return k[0] = M * v - p * F, k[1] = Q * v + x * F, k[2] = p * v + M * F, k[3] = x * v - Q * F, k;
      }
      function L(k, j, A) {
        A *= 0.5;
        var M = j[0], Q = j[1], p = j[2], x = j[3], F = Math.sin(A), v = Math.cos(A);
        return k[0] = M * v + Q * F, k[1] = Q * v - M * F, k[2] = p * v + x * F, k[3] = x * v - p * F, k;
      }
      function u(k, j) {
        var A = j[0], M = j[1], Q = j[2];
        return k[0] = A, k[1] = M, k[2] = Q, k[3] = Math.sqrt(Math.abs(1 - A * A - M * M - Q * Q)), k;
      }
      function V(k, j) {
        var A = j[0], M = j[1], Q = j[2], p = j[3], x = Math.sqrt(A * A + M * M + Q * Q), F = Math.exp(p), v = x > 0 ? F * Math.sin(x) / x : 0;
        return k[0] = A * v, k[1] = M * v, k[2] = Q * v, k[3] = F * Math.cos(x), k;
      }
      function c(k, j) {
        var A = j[0], M = j[1], Q = j[2], p = j[3], x = Math.sqrt(A * A + M * M + Q * Q), F = x > 0 ? Math.atan2(x, p) / x : 0;
        return k[0] = A * F, k[1] = M * F, k[2] = Q * F, k[3] = 0.5 * Math.log(A * A + M * M + Q * Q + p * p), k;
      }
      function n(k, j, A) {
        return c(k, j), P(k, k, A), V(k, k), k;
      }
      function e(k, j, A, M) {
        var Q = j[0], p = j[1], x = j[2], F = j[3], v = A[0], f = A[1], E = A[2], q = A[3], dl, tl, ml, el, cl;
        return tl = Q * v + p * f + x * E + F * q, tl < 0 && (tl = -tl, v = -v, f = -f, E = -E, q = -q), 1 - tl > i.EPSILON ? (dl = Math.acos(tl), ml = Math.sin(dl), el = Math.sin((1 - M) * dl) / ml, cl = Math.sin(M * dl) / ml) : (el = 1 - M, cl = M), k[0] = el * Q + cl * v, k[1] = el * p + cl * f, k[2] = el * x + cl * E, k[3] = el * F + cl * q, k;
      }
      function a(k) {
        var j = i.RANDOM(), A = i.RANDOM(), M = i.RANDOM(), Q = Math.sqrt(1 - j), p = Math.sqrt(j);
        return k[0] = Q * Math.sin(2 * Math.PI * A), k[1] = Q * Math.cos(2 * Math.PI * A), k[2] = p * Math.sin(2 * Math.PI * M), k[3] = p * Math.cos(2 * Math.PI * M), k;
      }
      function Y(k, j) {
        var A = j[0], M = j[1], Q = j[2], p = j[3], x = A * A + M * M + Q * Q + p * p, F = x ? 1 / x : 0;
        return k[0] = -A * F, k[1] = -M * F, k[2] = -Q * F, k[3] = p * F, k;
      }
      function R(k, j) {
        return k[0] = -j[0], k[1] = -j[1], k[2] = -j[2], k[3] = j[3], k;
      }
      function C(k, j) {
        var A = j[0] + j[4] + j[8], M;
        if (A > 0)
          M = Math.sqrt(A + 1), k[3] = 0.5 * M, M = 0.5 / M, k[0] = (j[5] - j[7]) * M, k[1] = (j[6] - j[2]) * M, k[2] = (j[1] - j[3]) * M;
        else {
          var Q = 0;
          j[4] > j[0] && (Q = 1), j[8] > j[Q * 3 + Q] && (Q = 2);
          var p = (Q + 1) % 3, x = (Q + 2) % 3;
          M = Math.sqrt(j[Q * 3 + Q] - j[p * 3 + p] - j[x * 3 + x] + 1), k[Q] = 0.5 * M, M = 0.5 / M, k[3] = (j[p * 3 + x] - j[x * 3 + p]) * M, k[p] = (j[p * 3 + Q] + j[Q * 3 + p]) * M, k[x] = (j[x * 3 + Q] + j[Q * 3 + x]) * M;
        }
        return k;
      }
      function N(k, j, A, M) {
        var Q = 0.5 * Math.PI / 180;
        j *= Q, A *= Q, M *= Q;
        var p = Math.sin(j), x = Math.cos(j), F = Math.sin(A), v = Math.cos(A), f = Math.sin(M), E = Math.cos(M);
        return k[0] = p * v * E - x * F * f, k[1] = x * F * E + p * v * f, k[2] = x * v * f - p * F * E, k[3] = x * v * E + p * F * f, k;
      }
      function I(k) {
        return "quat(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ")";
      }
      var J = b.clone, T = b.fromValues, K = b.copy, S = b.set, H = b.add, w = W, P = b.scale, B = b.dot, D = b.lerp, z = b.length, U = z, O = b.squaredLength, ll = O, _ = b.normalize, Zl = b.exactEquals, $ = b.equals, ol = function() {
        var k = s.create(), j = s.fromValues(1, 0, 0), A = s.fromValues(0, 1, 0);
        return function(M, Q, p) {
          var x = s.dot(Q, p);
          return x < -0.999999 ? (s.cross(k, j, Q), s.len(k) < 1e-6 && s.cross(k, A, Q), s.normalize(k, k), G(M, k, Math.PI), M) : x > 0.999999 ? (M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 1, M) : (s.cross(k, Q, p), M[0] = k[0], M[1] = k[1], M[2] = k[2], M[3] = 1 + x, _(M, M));
        };
      }(), al = function() {
        var k = Z(), j = Z();
        return function(A, M, Q, p, x, F) {
          return e(k, M, x, F), e(j, Q, p, F), e(A, k, j, 2 * F * (1 - F)), A;
        };
      }(), g = function() {
        var k = t.create();
        return function(j, A, M, Q) {
          return k[0] = M[0], k[3] = M[1], k[6] = M[2], k[1] = Q[0], k[4] = Q[1], k[7] = Q[2], k[2] = -A[0], k[5] = -A[1], k[8] = -A[2], _(j, C(j, k));
        };
      }();
    },
    /* 8 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return t;
      }), l.d(d, "clone", function() {
        return s;
      }), l.d(d, "length", function() {
        return b;
      }), l.d(d, "fromValues", function() {
        return Z;
      }), l.d(d, "copy", function() {
        return o;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "add", function() {
        return y;
      }), l.d(d, "subtract", function() {
        return X;
      }), l.d(d, "multiply", function() {
        return W;
      }), l.d(d, "divide", function() {
        return h;
      }), l.d(d, "ceil", function() {
        return r;
      }), l.d(d, "floor", function() {
        return L;
      }), l.d(d, "min", function() {
        return u;
      }), l.d(d, "max", function() {
        return V;
      }), l.d(d, "round", function() {
        return c;
      }), l.d(d, "scale", function() {
        return n;
      }), l.d(d, "scaleAndAdd", function() {
        return e;
      }), l.d(d, "distance", function() {
        return a;
      }), l.d(d, "squaredDistance", function() {
        return Y;
      }), l.d(d, "squaredLength", function() {
        return R;
      }), l.d(d, "negate", function() {
        return C;
      }), l.d(d, "inverse", function() {
        return N;
      }), l.d(d, "normalize", function() {
        return I;
      }), l.d(d, "dot", function() {
        return J;
      }), l.d(d, "cross", function() {
        return T;
      }), l.d(d, "lerp", function() {
        return K;
      }), l.d(d, "hermite", function() {
        return S;
      }), l.d(d, "bezier", function() {
        return H;
      }), l.d(d, "random", function() {
        return w;
      }), l.d(d, "transformMat4", function() {
        return P;
      }), l.d(d, "transformMat3", function() {
        return B;
      }), l.d(d, "transformQuat", function() {
        return D;
      }), l.d(d, "rotateX", function() {
        return z;
      }), l.d(d, "rotateY", function() {
        return U;
      }), l.d(d, "rotateZ", function() {
        return O;
      }), l.d(d, "angle", function() {
        return ll;
      }), l.d(d, "zero", function() {
        return _;
      }), l.d(d, "str", function() {
        return Zl;
      }), l.d(d, "exactEquals", function() {
        return $;
      }), l.d(d, "equals", function() {
        return ol;
      }), l.d(d, "sub", function() {
        return al;
      }), l.d(d, "mul", function() {
        return g;
      }), l.d(d, "div", function() {
        return k;
      }), l.d(d, "dist", function() {
        return j;
      }), l.d(d, "sqrDist", function() {
        return A;
      }), l.d(d, "len", function() {
        return M;
      }), l.d(d, "sqrLen", function() {
        return Q;
      }), l.d(d, "forEach", function() {
        return p;
      });
      var i = l(2);
      function t() {
        var x = new i.ARRAY_TYPE(3);
        return i.ARRAY_TYPE != Float32Array && (x[0] = 0, x[1] = 0, x[2] = 0), x;
      }
      function s(x) {
        var F = new i.ARRAY_TYPE(3);
        return F[0] = x[0], F[1] = x[1], F[2] = x[2], F;
      }
      function b(x) {
        var F = x[0], v = x[1], f = x[2];
        return Math.hypot(F, v, f);
      }
      function Z(x, F, v) {
        var f = new i.ARRAY_TYPE(3);
        return f[0] = x, f[1] = F, f[2] = v, f;
      }
      function o(x, F) {
        return x[0] = F[0], x[1] = F[1], x[2] = F[2], x;
      }
      function G(x, F, v, f) {
        return x[0] = F, x[1] = v, x[2] = f, x;
      }
      function y(x, F, v) {
        return x[0] = F[0] + v[0], x[1] = F[1] + v[1], x[2] = F[2] + v[2], x;
      }
      function X(x, F, v) {
        return x[0] = F[0] - v[0], x[1] = F[1] - v[1], x[2] = F[2] - v[2], x;
      }
      function W(x, F, v) {
        return x[0] = F[0] * v[0], x[1] = F[1] * v[1], x[2] = F[2] * v[2], x;
      }
      function h(x, F, v) {
        return x[0] = F[0] / v[0], x[1] = F[1] / v[1], x[2] = F[2] / v[2], x;
      }
      function r(x, F) {
        return x[0] = Math.ceil(F[0]), x[1] = Math.ceil(F[1]), x[2] = Math.ceil(F[2]), x;
      }
      function L(x, F) {
        return x[0] = Math.floor(F[0]), x[1] = Math.floor(F[1]), x[2] = Math.floor(F[2]), x;
      }
      function u(x, F, v) {
        return x[0] = Math.min(F[0], v[0]), x[1] = Math.min(F[1], v[1]), x[2] = Math.min(F[2], v[2]), x;
      }
      function V(x, F, v) {
        return x[0] = Math.max(F[0], v[0]), x[1] = Math.max(F[1], v[1]), x[2] = Math.max(F[2], v[2]), x;
      }
      function c(x, F) {
        return x[0] = Math.round(F[0]), x[1] = Math.round(F[1]), x[2] = Math.round(F[2]), x;
      }
      function n(x, F, v) {
        return x[0] = F[0] * v, x[1] = F[1] * v, x[2] = F[2] * v, x;
      }
      function e(x, F, v, f) {
        return x[0] = F[0] + v[0] * f, x[1] = F[1] + v[1] * f, x[2] = F[2] + v[2] * f, x;
      }
      function a(x, F) {
        var v = F[0] - x[0], f = F[1] - x[1], E = F[2] - x[2];
        return Math.hypot(v, f, E);
      }
      function Y(x, F) {
        var v = F[0] - x[0], f = F[1] - x[1], E = F[2] - x[2];
        return v * v + f * f + E * E;
      }
      function R(x) {
        var F = x[0], v = x[1], f = x[2];
        return F * F + v * v + f * f;
      }
      function C(x, F) {
        return x[0] = -F[0], x[1] = -F[1], x[2] = -F[2], x;
      }
      function N(x, F) {
        return x[0] = 1 / F[0], x[1] = 1 / F[1], x[2] = 1 / F[2], x;
      }
      function I(x, F) {
        var v = F[0], f = F[1], E = F[2], q = v * v + f * f + E * E;
        return q > 0 && (q = 1 / Math.sqrt(q)), x[0] = F[0] * q, x[1] = F[1] * q, x[2] = F[2] * q, x;
      }
      function J(x, F) {
        return x[0] * F[0] + x[1] * F[1] + x[2] * F[2];
      }
      function T(x, F, v) {
        var f = F[0], E = F[1], q = F[2], dl = v[0], tl = v[1], ml = v[2];
        return x[0] = E * ml - q * tl, x[1] = q * dl - f * ml, x[2] = f * tl - E * dl, x;
      }
      function K(x, F, v, f) {
        var E = F[0], q = F[1], dl = F[2];
        return x[0] = E + f * (v[0] - E), x[1] = q + f * (v[1] - q), x[2] = dl + f * (v[2] - dl), x;
      }
      function S(x, F, v, f, E, q) {
        var dl = q * q, tl = dl * (2 * q - 3) + 1, ml = dl * (q - 2) + q, el = dl * (q - 1), cl = dl * (3 - 2 * q);
        return x[0] = F[0] * tl + v[0] * ml + f[0] * el + E[0] * cl, x[1] = F[1] * tl + v[1] * ml + f[1] * el + E[1] * cl, x[2] = F[2] * tl + v[2] * ml + f[2] * el + E[2] * cl, x;
      }
      function H(x, F, v, f, E, q) {
        var dl = 1 - q, tl = dl * dl, ml = q * q, el = tl * dl, cl = 3 * q * tl, sl = 3 * ml * dl, nl = ml * q;
        return x[0] = F[0] * el + v[0] * cl + f[0] * sl + E[0] * nl, x[1] = F[1] * el + v[1] * cl + f[1] * sl + E[1] * nl, x[2] = F[2] * el + v[2] * cl + f[2] * sl + E[2] * nl, x;
      }
      function w(x, F) {
        F = F || 1;
        var v = i.RANDOM() * 2 * Math.PI, f = i.RANDOM() * 2 - 1, E = Math.sqrt(1 - f * f) * F;
        return x[0] = Math.cos(v) * E, x[1] = Math.sin(v) * E, x[2] = f * F, x;
      }
      function P(x, F, v) {
        var f = F[0], E = F[1], q = F[2], dl = v[3] * f + v[7] * E + v[11] * q + v[15];
        return dl = dl || 1, x[0] = (v[0] * f + v[4] * E + v[8] * q + v[12]) / dl, x[1] = (v[1] * f + v[5] * E + v[9] * q + v[13]) / dl, x[2] = (v[2] * f + v[6] * E + v[10] * q + v[14]) / dl, x;
      }
      function B(x, F, v) {
        var f = F[0], E = F[1], q = F[2];
        return x[0] = f * v[0] + E * v[3] + q * v[6], x[1] = f * v[1] + E * v[4] + q * v[7], x[2] = f * v[2] + E * v[5] + q * v[8], x;
      }
      function D(x, F, v) {
        var f = v[0], E = v[1], q = v[2], dl = v[3], tl = F[0], ml = F[1], el = F[2], cl = E * el - q * ml, sl = q * tl - f * el, nl = f * ml - E * tl, Gl = E * nl - q * sl, Wl = q * cl - f * nl, Xl = f * sl - E * cl, yl = dl * 2;
        return cl *= yl, sl *= yl, nl *= yl, Gl *= 2, Wl *= 2, Xl *= 2, x[0] = tl + cl + Gl, x[1] = ml + sl + Wl, x[2] = el + nl + Xl, x;
      }
      function z(x, F, v, f) {
        var E = [], q = [];
        return E[0] = F[0] - v[0], E[1] = F[1] - v[1], E[2] = F[2] - v[2], q[0] = E[0], q[1] = E[1] * Math.cos(f) - E[2] * Math.sin(f), q[2] = E[1] * Math.sin(f) + E[2] * Math.cos(f), x[0] = q[0] + v[0], x[1] = q[1] + v[1], x[2] = q[2] + v[2], x;
      }
      function U(x, F, v, f) {
        var E = [], q = [];
        return E[0] = F[0] - v[0], E[1] = F[1] - v[1], E[2] = F[2] - v[2], q[0] = E[2] * Math.sin(f) + E[0] * Math.cos(f), q[1] = E[1], q[2] = E[2] * Math.cos(f) - E[0] * Math.sin(f), x[0] = q[0] + v[0], x[1] = q[1] + v[1], x[2] = q[2] + v[2], x;
      }
      function O(x, F, v, f) {
        var E = [], q = [];
        return E[0] = F[0] - v[0], E[1] = F[1] - v[1], E[2] = F[2] - v[2], q[0] = E[0] * Math.cos(f) - E[1] * Math.sin(f), q[1] = E[0] * Math.sin(f) + E[1] * Math.cos(f), q[2] = E[2], x[0] = q[0] + v[0], x[1] = q[1] + v[1], x[2] = q[2] + v[2], x;
      }
      function ll(x, F) {
        var v = x[0], f = x[1], E = x[2], q = F[0], dl = F[1], tl = F[2], ml = Math.sqrt(v * v + f * f + E * E), el = Math.sqrt(q * q + dl * dl + tl * tl), cl = ml * el, sl = cl && J(x, F) / cl;
        return Math.acos(Math.min(Math.max(sl, -1), 1));
      }
      function _(x) {
        return x[0] = 0, x[1] = 0, x[2] = 0, x;
      }
      function Zl(x) {
        return "vec3(" + x[0] + ", " + x[1] + ", " + x[2] + ")";
      }
      function $(x, F) {
        return x[0] === F[0] && x[1] === F[1] && x[2] === F[2];
      }
      function ol(x, F) {
        var v = x[0], f = x[1], E = x[2], q = F[0], dl = F[1], tl = F[2];
        return Math.abs(v - q) <= i.EPSILON * Math.max(1, Math.abs(v), Math.abs(q)) && Math.abs(f - dl) <= i.EPSILON * Math.max(1, Math.abs(f), Math.abs(dl)) && Math.abs(E - tl) <= i.EPSILON * Math.max(1, Math.abs(E), Math.abs(tl));
      }
      var al = X, g = W, k = h, j = a, A = Y, M = b, Q = R, p = function() {
        var x = t();
        return function(F, v, f, E, q, dl) {
          var tl, ml;
          for (v || (v = 3), f || (f = 0), E ? ml = Math.min(E * v + f, F.length) : ml = F.length, tl = f; tl < ml; tl += v)
            x[0] = F[tl], x[1] = F[tl + 1], x[2] = F[tl + 2], q(x, x, dl), F[tl] = x[0], F[tl + 1] = x[1], F[tl + 2] = x[2];
          return F;
        };
      }();
    },
    /* 9 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return t;
      }), l.d(d, "clone", function() {
        return s;
      }), l.d(d, "fromValues", function() {
        return b;
      }), l.d(d, "copy", function() {
        return Z;
      }), l.d(d, "set", function() {
        return o;
      }), l.d(d, "add", function() {
        return G;
      }), l.d(d, "subtract", function() {
        return y;
      }), l.d(d, "multiply", function() {
        return X;
      }), l.d(d, "divide", function() {
        return W;
      }), l.d(d, "ceil", function() {
        return h;
      }), l.d(d, "floor", function() {
        return r;
      }), l.d(d, "min", function() {
        return L;
      }), l.d(d, "max", function() {
        return u;
      }), l.d(d, "round", function() {
        return V;
      }), l.d(d, "scale", function() {
        return c;
      }), l.d(d, "scaleAndAdd", function() {
        return n;
      }), l.d(d, "distance", function() {
        return e;
      }), l.d(d, "squaredDistance", function() {
        return a;
      }), l.d(d, "length", function() {
        return Y;
      }), l.d(d, "squaredLength", function() {
        return R;
      }), l.d(d, "negate", function() {
        return C;
      }), l.d(d, "inverse", function() {
        return N;
      }), l.d(d, "normalize", function() {
        return I;
      }), l.d(d, "dot", function() {
        return J;
      }), l.d(d, "cross", function() {
        return T;
      }), l.d(d, "lerp", function() {
        return K;
      }), l.d(d, "random", function() {
        return S;
      }), l.d(d, "transformMat4", function() {
        return H;
      }), l.d(d, "transformQuat", function() {
        return w;
      }), l.d(d, "zero", function() {
        return P;
      }), l.d(d, "str", function() {
        return B;
      }), l.d(d, "exactEquals", function() {
        return D;
      }), l.d(d, "equals", function() {
        return z;
      }), l.d(d, "sub", function() {
        return U;
      }), l.d(d, "mul", function() {
        return O;
      }), l.d(d, "div", function() {
        return ll;
      }), l.d(d, "dist", function() {
        return _;
      }), l.d(d, "sqrDist", function() {
        return Zl;
      }), l.d(d, "len", function() {
        return $;
      }), l.d(d, "sqrLen", function() {
        return ol;
      }), l.d(d, "forEach", function() {
        return al;
      });
      var i = l(2);
      function t() {
        var g = new i.ARRAY_TYPE(4);
        return i.ARRAY_TYPE != Float32Array && (g[0] = 0, g[1] = 0, g[2] = 0, g[3] = 0), g;
      }
      function s(g) {
        var k = new i.ARRAY_TYPE(4);
        return k[0] = g[0], k[1] = g[1], k[2] = g[2], k[3] = g[3], k;
      }
      function b(g, k, j, A) {
        var M = new i.ARRAY_TYPE(4);
        return M[0] = g, M[1] = k, M[2] = j, M[3] = A, M;
      }
      function Z(g, k) {
        return g[0] = k[0], g[1] = k[1], g[2] = k[2], g[3] = k[3], g;
      }
      function o(g, k, j, A, M) {
        return g[0] = k, g[1] = j, g[2] = A, g[3] = M, g;
      }
      function G(g, k, j) {
        return g[0] = k[0] + j[0], g[1] = k[1] + j[1], g[2] = k[2] + j[2], g[3] = k[3] + j[3], g;
      }
      function y(g, k, j) {
        return g[0] = k[0] - j[0], g[1] = k[1] - j[1], g[2] = k[2] - j[2], g[3] = k[3] - j[3], g;
      }
      function X(g, k, j) {
        return g[0] = k[0] * j[0], g[1] = k[1] * j[1], g[2] = k[2] * j[2], g[3] = k[3] * j[3], g;
      }
      function W(g, k, j) {
        return g[0] = k[0] / j[0], g[1] = k[1] / j[1], g[2] = k[2] / j[2], g[3] = k[3] / j[3], g;
      }
      function h(g, k) {
        return g[0] = Math.ceil(k[0]), g[1] = Math.ceil(k[1]), g[2] = Math.ceil(k[2]), g[3] = Math.ceil(k[3]), g;
      }
      function r(g, k) {
        return g[0] = Math.floor(k[0]), g[1] = Math.floor(k[1]), g[2] = Math.floor(k[2]), g[3] = Math.floor(k[3]), g;
      }
      function L(g, k, j) {
        return g[0] = Math.min(k[0], j[0]), g[1] = Math.min(k[1], j[1]), g[2] = Math.min(k[2], j[2]), g[3] = Math.min(k[3], j[3]), g;
      }
      function u(g, k, j) {
        return g[0] = Math.max(k[0], j[0]), g[1] = Math.max(k[1], j[1]), g[2] = Math.max(k[2], j[2]), g[3] = Math.max(k[3], j[3]), g;
      }
      function V(g, k) {
        return g[0] = Math.round(k[0]), g[1] = Math.round(k[1]), g[2] = Math.round(k[2]), g[3] = Math.round(k[3]), g;
      }
      function c(g, k, j) {
        return g[0] = k[0] * j, g[1] = k[1] * j, g[2] = k[2] * j, g[3] = k[3] * j, g;
      }
      function n(g, k, j, A) {
        return g[0] = k[0] + j[0] * A, g[1] = k[1] + j[1] * A, g[2] = k[2] + j[2] * A, g[3] = k[3] + j[3] * A, g;
      }
      function e(g, k) {
        var j = k[0] - g[0], A = k[1] - g[1], M = k[2] - g[2], Q = k[3] - g[3];
        return Math.hypot(j, A, M, Q);
      }
      function a(g, k) {
        var j = k[0] - g[0], A = k[1] - g[1], M = k[2] - g[2], Q = k[3] - g[3];
        return j * j + A * A + M * M + Q * Q;
      }
      function Y(g) {
        var k = g[0], j = g[1], A = g[2], M = g[3];
        return Math.hypot(k, j, A, M);
      }
      function R(g) {
        var k = g[0], j = g[1], A = g[2], M = g[3];
        return k * k + j * j + A * A + M * M;
      }
      function C(g, k) {
        return g[0] = -k[0], g[1] = -k[1], g[2] = -k[2], g[3] = -k[3], g;
      }
      function N(g, k) {
        return g[0] = 1 / k[0], g[1] = 1 / k[1], g[2] = 1 / k[2], g[3] = 1 / k[3], g;
      }
      function I(g, k) {
        var j = k[0], A = k[1], M = k[2], Q = k[3], p = j * j + A * A + M * M + Q * Q;
        return p > 0 && (p = 1 / Math.sqrt(p)), g[0] = j * p, g[1] = A * p, g[2] = M * p, g[3] = Q * p, g;
      }
      function J(g, k) {
        return g[0] * k[0] + g[1] * k[1] + g[2] * k[2] + g[3] * k[3];
      }
      function T(g, k, j, A) {
        var M = j[0] * A[1] - j[1] * A[0], Q = j[0] * A[2] - j[2] * A[0], p = j[0] * A[3] - j[3] * A[0], x = j[1] * A[2] - j[2] * A[1], F = j[1] * A[3] - j[3] * A[1], v = j[2] * A[3] - j[3] * A[2], f = k[0], E = k[1], q = k[2], dl = k[3];
        return g[0] = E * v - q * F + dl * x, g[1] = -(f * v) + q * p - dl * Q, g[2] = f * F - E * p + dl * M, g[3] = -(f * x) + E * Q - q * M, g;
      }
      function K(g, k, j, A) {
        var M = k[0], Q = k[1], p = k[2], x = k[3];
        return g[0] = M + A * (j[0] - M), g[1] = Q + A * (j[1] - Q), g[2] = p + A * (j[2] - p), g[3] = x + A * (j[3] - x), g;
      }
      function S(g, k) {
        k = k || 1;
        var j, A, M, Q, p, x;
        do
          j = i.RANDOM() * 2 - 1, A = i.RANDOM() * 2 - 1, p = j * j + A * A;
        while (p >= 1);
        do
          M = i.RANDOM() * 2 - 1, Q = i.RANDOM() * 2 - 1, x = M * M + Q * Q;
        while (x >= 1);
        var F = Math.sqrt((1 - p) / x);
        return g[0] = k * j, g[1] = k * A, g[2] = k * M * F, g[3] = k * Q * F, g;
      }
      function H(g, k, j) {
        var A = k[0], M = k[1], Q = k[2], p = k[3];
        return g[0] = j[0] * A + j[4] * M + j[8] * Q + j[12] * p, g[1] = j[1] * A + j[5] * M + j[9] * Q + j[13] * p, g[2] = j[2] * A + j[6] * M + j[10] * Q + j[14] * p, g[3] = j[3] * A + j[7] * M + j[11] * Q + j[15] * p, g;
      }
      function w(g, k, j) {
        var A = k[0], M = k[1], Q = k[2], p = j[0], x = j[1], F = j[2], v = j[3], f = v * A + x * Q - F * M, E = v * M + F * A - p * Q, q = v * Q + p * M - x * A, dl = -p * A - x * M - F * Q;
        return g[0] = f * v + dl * -p + E * -F - q * -x, g[1] = E * v + dl * -x + q * -p - f * -F, g[2] = q * v + dl * -F + f * -x - E * -p, g[3] = k[3], g;
      }
      function P(g) {
        return g[0] = 0, g[1] = 0, g[2] = 0, g[3] = 0, g;
      }
      function B(g) {
        return "vec4(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ")";
      }
      function D(g, k) {
        return g[0] === k[0] && g[1] === k[1] && g[2] === k[2] && g[3] === k[3];
      }
      function z(g, k) {
        var j = g[0], A = g[1], M = g[2], Q = g[3], p = k[0], x = k[1], F = k[2], v = k[3];
        return Math.abs(j - p) <= i.EPSILON * Math.max(1, Math.abs(j), Math.abs(p)) && Math.abs(A - x) <= i.EPSILON * Math.max(1, Math.abs(A), Math.abs(x)) && Math.abs(M - F) <= i.EPSILON * Math.max(1, Math.abs(M), Math.abs(F)) && Math.abs(Q - v) <= i.EPSILON * Math.max(1, Math.abs(Q), Math.abs(v));
      }
      var U = y, O = X, ll = W, _ = e, Zl = a, $ = Y, ol = R, al = function() {
        var g = t();
        return function(k, j, A, M, Q, p) {
          var x, F;
          for (j || (j = 4), A || (A = 0), M ? F = Math.min(M * j + A, k.length) : F = k.length, x = A; x < F; x += j)
            g[0] = k[x], g[1] = k[x + 1], g[2] = k[x + 2], g[3] = k[x + 3], Q(g, g, p), k[x] = g[0], k[x + 1] = g[1], k[x + 2] = g[2], k[x + 3] = g[3];
          return k;
        };
      }();
    },
    /* 10 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return b;
      }), l.d(d, "clone", function() {
        return Z;
      }), l.d(d, "fromValues", function() {
        return o;
      }), l.d(d, "fromRotationTranslationValues", function() {
        return G;
      }), l.d(d, "fromRotationTranslation", function() {
        return y;
      }), l.d(d, "fromTranslation", function() {
        return X;
      }), l.d(d, "fromRotation", function() {
        return W;
      }), l.d(d, "fromMat4", function() {
        return h;
      }), l.d(d, "copy", function() {
        return r;
      }), l.d(d, "identity", function() {
        return L;
      }), l.d(d, "set", function() {
        return u;
      }), l.d(d, "getReal", function() {
        return V;
      }), l.d(d, "getDual", function() {
        return c;
      }), l.d(d, "setReal", function() {
        return n;
      }), l.d(d, "setDual", function() {
        return e;
      }), l.d(d, "getTranslation", function() {
        return a;
      }), l.d(d, "translate", function() {
        return Y;
      }), l.d(d, "rotateX", function() {
        return R;
      }), l.d(d, "rotateY", function() {
        return C;
      }), l.d(d, "rotateZ", function() {
        return N;
      }), l.d(d, "rotateByQuatAppend", function() {
        return I;
      }), l.d(d, "rotateByQuatPrepend", function() {
        return J;
      }), l.d(d, "rotateAroundAxis", function() {
        return T;
      }), l.d(d, "add", function() {
        return K;
      }), l.d(d, "multiply", function() {
        return S;
      }), l.d(d, "mul", function() {
        return H;
      }), l.d(d, "scale", function() {
        return w;
      }), l.d(d, "dot", function() {
        return P;
      }), l.d(d, "lerp", function() {
        return B;
      }), l.d(d, "invert", function() {
        return D;
      }), l.d(d, "conjugate", function() {
        return z;
      }), l.d(d, "length", function() {
        return U;
      }), l.d(d, "len", function() {
        return O;
      }), l.d(d, "squaredLength", function() {
        return ll;
      }), l.d(d, "sqrLen", function() {
        return _;
      }), l.d(d, "normalize", function() {
        return Zl;
      }), l.d(d, "str", function() {
        return $;
      }), l.d(d, "exactEquals", function() {
        return ol;
      }), l.d(d, "equals", function() {
        return al;
      });
      var i = l(2), t = l(7), s = l(6);
      function b() {
        var g = new i.ARRAY_TYPE(8);
        return i.ARRAY_TYPE != Float32Array && (g[0] = 0, g[1] = 0, g[2] = 0, g[4] = 0, g[5] = 0, g[6] = 0, g[7] = 0), g[3] = 1, g;
      }
      function Z(g) {
        var k = new i.ARRAY_TYPE(8);
        return k[0] = g[0], k[1] = g[1], k[2] = g[2], k[3] = g[3], k[4] = g[4], k[5] = g[5], k[6] = g[6], k[7] = g[7], k;
      }
      function o(g, k, j, A, M, Q, p, x) {
        var F = new i.ARRAY_TYPE(8);
        return F[0] = g, F[1] = k, F[2] = j, F[3] = A, F[4] = M, F[5] = Q, F[6] = p, F[7] = x, F;
      }
      function G(g, k, j, A, M, Q, p) {
        var x = new i.ARRAY_TYPE(8);
        x[0] = g, x[1] = k, x[2] = j, x[3] = A;
        var F = M * 0.5, v = Q * 0.5, f = p * 0.5;
        return x[4] = F * A + v * j - f * k, x[5] = v * A + f * g - F * j, x[6] = f * A + F * k - v * g, x[7] = -F * g - v * k - f * j, x;
      }
      function y(g, k, j) {
        var A = j[0] * 0.5, M = j[1] * 0.5, Q = j[2] * 0.5, p = k[0], x = k[1], F = k[2], v = k[3];
        return g[0] = p, g[1] = x, g[2] = F, g[3] = v, g[4] = A * v + M * F - Q * x, g[5] = M * v + Q * p - A * F, g[6] = Q * v + A * x - M * p, g[7] = -A * p - M * x - Q * F, g;
      }
      function X(g, k) {
        return g[0] = 0, g[1] = 0, g[2] = 0, g[3] = 1, g[4] = k[0] * 0.5, g[5] = k[1] * 0.5, g[6] = k[2] * 0.5, g[7] = 0, g;
      }
      function W(g, k) {
        return g[0] = k[0], g[1] = k[1], g[2] = k[2], g[3] = k[3], g[4] = 0, g[5] = 0, g[6] = 0, g[7] = 0, g;
      }
      function h(g, k) {
        var j = t.create();
        s.getRotation(j, k);
        var A = new i.ARRAY_TYPE(3);
        return s.getTranslation(A, k), y(g, j, A), g;
      }
      function r(g, k) {
        return g[0] = k[0], g[1] = k[1], g[2] = k[2], g[3] = k[3], g[4] = k[4], g[5] = k[5], g[6] = k[6], g[7] = k[7], g;
      }
      function L(g) {
        return g[0] = 0, g[1] = 0, g[2] = 0, g[3] = 1, g[4] = 0, g[5] = 0, g[6] = 0, g[7] = 0, g;
      }
      function u(g, k, j, A, M, Q, p, x, F) {
        return g[0] = k, g[1] = j, g[2] = A, g[3] = M, g[4] = Q, g[5] = p, g[6] = x, g[7] = F, g;
      }
      var V = t.copy;
      function c(g, k) {
        return g[0] = k[4], g[1] = k[5], g[2] = k[6], g[3] = k[7], g;
      }
      var n = t.copy;
      function e(g, k) {
        return g[4] = k[0], g[5] = k[1], g[6] = k[2], g[7] = k[3], g;
      }
      function a(g, k) {
        var j = k[4], A = k[5], M = k[6], Q = k[7], p = -k[0], x = -k[1], F = -k[2], v = k[3];
        return g[0] = (j * v + Q * p + A * F - M * x) * 2, g[1] = (A * v + Q * x + M * p - j * F) * 2, g[2] = (M * v + Q * F + j * x - A * p) * 2, g;
      }
      function Y(g, k, j) {
        var A = k[0], M = k[1], Q = k[2], p = k[3], x = j[0] * 0.5, F = j[1] * 0.5, v = j[2] * 0.5, f = k[4], E = k[5], q = k[6], dl = k[7];
        return g[0] = A, g[1] = M, g[2] = Q, g[3] = p, g[4] = p * x + M * v - Q * F + f, g[5] = p * F + Q * x - A * v + E, g[6] = p * v + A * F - M * x + q, g[7] = -A * x - M * F - Q * v + dl, g;
      }
      function R(g, k, j) {
        var A = -k[0], M = -k[1], Q = -k[2], p = k[3], x = k[4], F = k[5], v = k[6], f = k[7], E = x * p + f * A + F * Q - v * M, q = F * p + f * M + v * A - x * Q, dl = v * p + f * Q + x * M - F * A, tl = f * p - x * A - F * M - v * Q;
        return t.rotateX(g, k, j), A = g[0], M = g[1], Q = g[2], p = g[3], g[4] = E * p + tl * A + q * Q - dl * M, g[5] = q * p + tl * M + dl * A - E * Q, g[6] = dl * p + tl * Q + E * M - q * A, g[7] = tl * p - E * A - q * M - dl * Q, g;
      }
      function C(g, k, j) {
        var A = -k[0], M = -k[1], Q = -k[2], p = k[3], x = k[4], F = k[5], v = k[6], f = k[7], E = x * p + f * A + F * Q - v * M, q = F * p + f * M + v * A - x * Q, dl = v * p + f * Q + x * M - F * A, tl = f * p - x * A - F * M - v * Q;
        return t.rotateY(g, k, j), A = g[0], M = g[1], Q = g[2], p = g[3], g[4] = E * p + tl * A + q * Q - dl * M, g[5] = q * p + tl * M + dl * A - E * Q, g[6] = dl * p + tl * Q + E * M - q * A, g[7] = tl * p - E * A - q * M - dl * Q, g;
      }
      function N(g, k, j) {
        var A = -k[0], M = -k[1], Q = -k[2], p = k[3], x = k[4], F = k[5], v = k[6], f = k[7], E = x * p + f * A + F * Q - v * M, q = F * p + f * M + v * A - x * Q, dl = v * p + f * Q + x * M - F * A, tl = f * p - x * A - F * M - v * Q;
        return t.rotateZ(g, k, j), A = g[0], M = g[1], Q = g[2], p = g[3], g[4] = E * p + tl * A + q * Q - dl * M, g[5] = q * p + tl * M + dl * A - E * Q, g[6] = dl * p + tl * Q + E * M - q * A, g[7] = tl * p - E * A - q * M - dl * Q, g;
      }
      function I(g, k, j) {
        var A = j[0], M = j[1], Q = j[2], p = j[3], x = k[0], F = k[1], v = k[2], f = k[3];
        return g[0] = x * p + f * A + F * Q - v * M, g[1] = F * p + f * M + v * A - x * Q, g[2] = v * p + f * Q + x * M - F * A, g[3] = f * p - x * A - F * M - v * Q, x = k[4], F = k[5], v = k[6], f = k[7], g[4] = x * p + f * A + F * Q - v * M, g[5] = F * p + f * M + v * A - x * Q, g[6] = v * p + f * Q + x * M - F * A, g[7] = f * p - x * A - F * M - v * Q, g;
      }
      function J(g, k, j) {
        var A = k[0], M = k[1], Q = k[2], p = k[3], x = j[0], F = j[1], v = j[2], f = j[3];
        return g[0] = A * f + p * x + M * v - Q * F, g[1] = M * f + p * F + Q * x - A * v, g[2] = Q * f + p * v + A * F - M * x, g[3] = p * f - A * x - M * F - Q * v, x = j[4], F = j[5], v = j[6], f = j[7], g[4] = A * f + p * x + M * v - Q * F, g[5] = M * f + p * F + Q * x - A * v, g[6] = Q * f + p * v + A * F - M * x, g[7] = p * f - A * x - M * F - Q * v, g;
      }
      function T(g, k, j, A) {
        if (Math.abs(A) < i.EPSILON)
          return r(g, k);
        var M = Math.hypot(j[0], j[1], j[2]);
        A = A * 0.5;
        var Q = Math.sin(A), p = Q * j[0] / M, x = Q * j[1] / M, F = Q * j[2] / M, v = Math.cos(A), f = k[0], E = k[1], q = k[2], dl = k[3];
        g[0] = f * v + dl * p + E * F - q * x, g[1] = E * v + dl * x + q * p - f * F, g[2] = q * v + dl * F + f * x - E * p, g[3] = dl * v - f * p - E * x - q * F;
        var tl = k[4], ml = k[5], el = k[6], cl = k[7];
        return g[4] = tl * v + cl * p + ml * F - el * x, g[5] = ml * v + cl * x + el * p - tl * F, g[6] = el * v + cl * F + tl * x - ml * p, g[7] = cl * v - tl * p - ml * x - el * F, g;
      }
      function K(g, k, j) {
        return g[0] = k[0] + j[0], g[1] = k[1] + j[1], g[2] = k[2] + j[2], g[3] = k[3] + j[3], g[4] = k[4] + j[4], g[5] = k[5] + j[5], g[6] = k[6] + j[6], g[7] = k[7] + j[7], g;
      }
      function S(g, k, j) {
        var A = k[0], M = k[1], Q = k[2], p = k[3], x = j[4], F = j[5], v = j[6], f = j[7], E = k[4], q = k[5], dl = k[6], tl = k[7], ml = j[0], el = j[1], cl = j[2], sl = j[3];
        return g[0] = A * sl + p * ml + M * cl - Q * el, g[1] = M * sl + p * el + Q * ml - A * cl, g[2] = Q * sl + p * cl + A * el - M * ml, g[3] = p * sl - A * ml - M * el - Q * cl, g[4] = A * f + p * x + M * v - Q * F + E * sl + tl * ml + q * cl - dl * el, g[5] = M * f + p * F + Q * x - A * v + q * sl + tl * el + dl * ml - E * cl, g[6] = Q * f + p * v + A * F - M * x + dl * sl + tl * cl + E * el - q * ml, g[7] = p * f - A * x - M * F - Q * v + tl * sl - E * ml - q * el - dl * cl, g;
      }
      var H = S;
      function w(g, k, j) {
        return g[0] = k[0] * j, g[1] = k[1] * j, g[2] = k[2] * j, g[3] = k[3] * j, g[4] = k[4] * j, g[5] = k[5] * j, g[6] = k[6] * j, g[7] = k[7] * j, g;
      }
      var P = t.dot;
      function B(g, k, j, A) {
        var M = 1 - A;
        return P(k, j) < 0 && (A = -A), g[0] = k[0] * M + j[0] * A, g[1] = k[1] * M + j[1] * A, g[2] = k[2] * M + j[2] * A, g[3] = k[3] * M + j[3] * A, g[4] = k[4] * M + j[4] * A, g[5] = k[5] * M + j[5] * A, g[6] = k[6] * M + j[6] * A, g[7] = k[7] * M + j[7] * A, g;
      }
      function D(g, k) {
        var j = ll(k);
        return g[0] = -k[0] / j, g[1] = -k[1] / j, g[2] = -k[2] / j, g[3] = k[3] / j, g[4] = -k[4] / j, g[5] = -k[5] / j, g[6] = -k[6] / j, g[7] = k[7] / j, g;
      }
      function z(g, k) {
        return g[0] = -k[0], g[1] = -k[1], g[2] = -k[2], g[3] = k[3], g[4] = -k[4], g[5] = -k[5], g[6] = -k[6], g[7] = k[7], g;
      }
      var U = t.length, O = U, ll = t.squaredLength, _ = ll;
      function Zl(g, k) {
        var j = ll(k);
        if (j > 0) {
          j = Math.sqrt(j);
          var A = k[0] / j, M = k[1] / j, Q = k[2] / j, p = k[3] / j, x = k[4], F = k[5], v = k[6], f = k[7], E = A * x + M * F + Q * v + p * f;
          g[0] = A, g[1] = M, g[2] = Q, g[3] = p, g[4] = (x - A * E) / j, g[5] = (F - M * E) / j, g[6] = (v - Q * E) / j, g[7] = (f - p * E) / j;
        }
        return g;
      }
      function $(g) {
        return "quat2(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ", " + g[6] + ", " + g[7] + ")";
      }
      function ol(g, k) {
        return g[0] === k[0] && g[1] === k[1] && g[2] === k[2] && g[3] === k[3] && g[4] === k[4] && g[5] === k[5] && g[6] === k[6] && g[7] === k[7];
      }
      function al(g, k) {
        var j = g[0], A = g[1], M = g[2], Q = g[3], p = g[4], x = g[5], F = g[6], v = g[7], f = k[0], E = k[1], q = k[2], dl = k[3], tl = k[4], ml = k[5], el = k[6], cl = k[7];
        return Math.abs(j - f) <= i.EPSILON * Math.max(1, Math.abs(j), Math.abs(f)) && Math.abs(A - E) <= i.EPSILON * Math.max(1, Math.abs(A), Math.abs(E)) && Math.abs(M - q) <= i.EPSILON * Math.max(1, Math.abs(M), Math.abs(q)) && Math.abs(Q - dl) <= i.EPSILON * Math.max(1, Math.abs(Q), Math.abs(dl)) && Math.abs(p - tl) <= i.EPSILON * Math.max(1, Math.abs(p), Math.abs(tl)) && Math.abs(x - ml) <= i.EPSILON * Math.max(1, Math.abs(x), Math.abs(ml)) && Math.abs(F - el) <= i.EPSILON * Math.max(1, Math.abs(F), Math.abs(el)) && Math.abs(v - cl) <= i.EPSILON * Math.max(1, Math.abs(v), Math.abs(cl));
      }
    },
    /* 11 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return t;
      }), l.d(d, "clone", function() {
        return s;
      }), l.d(d, "fromValues", function() {
        return b;
      }), l.d(d, "copy", function() {
        return Z;
      }), l.d(d, "set", function() {
        return o;
      }), l.d(d, "add", function() {
        return G;
      }), l.d(d, "subtract", function() {
        return y;
      }), l.d(d, "multiply", function() {
        return X;
      }), l.d(d, "divide", function() {
        return W;
      }), l.d(d, "ceil", function() {
        return h;
      }), l.d(d, "floor", function() {
        return r;
      }), l.d(d, "min", function() {
        return L;
      }), l.d(d, "max", function() {
        return u;
      }), l.d(d, "round", function() {
        return V;
      }), l.d(d, "scale", function() {
        return c;
      }), l.d(d, "scaleAndAdd", function() {
        return n;
      }), l.d(d, "distance", function() {
        return e;
      }), l.d(d, "squaredDistance", function() {
        return a;
      }), l.d(d, "length", function() {
        return Y;
      }), l.d(d, "squaredLength", function() {
        return R;
      }), l.d(d, "negate", function() {
        return C;
      }), l.d(d, "inverse", function() {
        return N;
      }), l.d(d, "normalize", function() {
        return I;
      }), l.d(d, "dot", function() {
        return J;
      }), l.d(d, "cross", function() {
        return T;
      }), l.d(d, "lerp", function() {
        return K;
      }), l.d(d, "random", function() {
        return S;
      }), l.d(d, "transformMat2", function() {
        return H;
      }), l.d(d, "transformMat2d", function() {
        return w;
      }), l.d(d, "transformMat3", function() {
        return P;
      }), l.d(d, "transformMat4", function() {
        return B;
      }), l.d(d, "rotate", function() {
        return D;
      }), l.d(d, "angle", function() {
        return z;
      }), l.d(d, "zero", function() {
        return U;
      }), l.d(d, "str", function() {
        return O;
      }), l.d(d, "exactEquals", function() {
        return ll;
      }), l.d(d, "equals", function() {
        return _;
      }), l.d(d, "len", function() {
        return Zl;
      }), l.d(d, "sub", function() {
        return $;
      }), l.d(d, "mul", function() {
        return ol;
      }), l.d(d, "div", function() {
        return al;
      }), l.d(d, "dist", function() {
        return g;
      }), l.d(d, "sqrDist", function() {
        return k;
      }), l.d(d, "sqrLen", function() {
        return j;
      }), l.d(d, "forEach", function() {
        return A;
      });
      var i = l(2);
      function t() {
        var M = new i.ARRAY_TYPE(2);
        return i.ARRAY_TYPE != Float32Array && (M[0] = 0, M[1] = 0), M;
      }
      function s(M) {
        var Q = new i.ARRAY_TYPE(2);
        return Q[0] = M[0], Q[1] = M[1], Q;
      }
      function b(M, Q) {
        var p = new i.ARRAY_TYPE(2);
        return p[0] = M, p[1] = Q, p;
      }
      function Z(M, Q) {
        return M[0] = Q[0], M[1] = Q[1], M;
      }
      function o(M, Q, p) {
        return M[0] = Q, M[1] = p, M;
      }
      function G(M, Q, p) {
        return M[0] = Q[0] + p[0], M[1] = Q[1] + p[1], M;
      }
      function y(M, Q, p) {
        return M[0] = Q[0] - p[0], M[1] = Q[1] - p[1], M;
      }
      function X(M, Q, p) {
        return M[0] = Q[0] * p[0], M[1] = Q[1] * p[1], M;
      }
      function W(M, Q, p) {
        return M[0] = Q[0] / p[0], M[1] = Q[1] / p[1], M;
      }
      function h(M, Q) {
        return M[0] = Math.ceil(Q[0]), M[1] = Math.ceil(Q[1]), M;
      }
      function r(M, Q) {
        return M[0] = Math.floor(Q[0]), M[1] = Math.floor(Q[1]), M;
      }
      function L(M, Q, p) {
        return M[0] = Math.min(Q[0], p[0]), M[1] = Math.min(Q[1], p[1]), M;
      }
      function u(M, Q, p) {
        return M[0] = Math.max(Q[0], p[0]), M[1] = Math.max(Q[1], p[1]), M;
      }
      function V(M, Q) {
        return M[0] = Math.round(Q[0]), M[1] = Math.round(Q[1]), M;
      }
      function c(M, Q, p) {
        return M[0] = Q[0] * p, M[1] = Q[1] * p, M;
      }
      function n(M, Q, p, x) {
        return M[0] = Q[0] + p[0] * x, M[1] = Q[1] + p[1] * x, M;
      }
      function e(M, Q) {
        var p = Q[0] - M[0], x = Q[1] - M[1];
        return Math.hypot(p, x);
      }
      function a(M, Q) {
        var p = Q[0] - M[0], x = Q[1] - M[1];
        return p * p + x * x;
      }
      function Y(M) {
        var Q = M[0], p = M[1];
        return Math.hypot(Q, p);
      }
      function R(M) {
        var Q = M[0], p = M[1];
        return Q * Q + p * p;
      }
      function C(M, Q) {
        return M[0] = -Q[0], M[1] = -Q[1], M;
      }
      function N(M, Q) {
        return M[0] = 1 / Q[0], M[1] = 1 / Q[1], M;
      }
      function I(M, Q) {
        var p = Q[0], x = Q[1], F = p * p + x * x;
        return F > 0 && (F = 1 / Math.sqrt(F)), M[0] = Q[0] * F, M[1] = Q[1] * F, M;
      }
      function J(M, Q) {
        return M[0] * Q[0] + M[1] * Q[1];
      }
      function T(M, Q, p) {
        var x = Q[0] * p[1] - Q[1] * p[0];
        return M[0] = M[1] = 0, M[2] = x, M;
      }
      function K(M, Q, p, x) {
        var F = Q[0], v = Q[1];
        return M[0] = F + x * (p[0] - F), M[1] = v + x * (p[1] - v), M;
      }
      function S(M, Q) {
        Q = Q || 1;
        var p = i.RANDOM() * 2 * Math.PI;
        return M[0] = Math.cos(p) * Q, M[1] = Math.sin(p) * Q, M;
      }
      function H(M, Q, p) {
        var x = Q[0], F = Q[1];
        return M[0] = p[0] * x + p[2] * F, M[1] = p[1] * x + p[3] * F, M;
      }
      function w(M, Q, p) {
        var x = Q[0], F = Q[1];
        return M[0] = p[0] * x + p[2] * F + p[4], M[1] = p[1] * x + p[3] * F + p[5], M;
      }
      function P(M, Q, p) {
        var x = Q[0], F = Q[1];
        return M[0] = p[0] * x + p[3] * F + p[6], M[1] = p[1] * x + p[4] * F + p[7], M;
      }
      function B(M, Q, p) {
        var x = Q[0], F = Q[1];
        return M[0] = p[0] * x + p[4] * F + p[12], M[1] = p[1] * x + p[5] * F + p[13], M;
      }
      function D(M, Q, p, x) {
        var F = Q[0] - p[0], v = Q[1] - p[1], f = Math.sin(x), E = Math.cos(x);
        return M[0] = F * E - v * f + p[0], M[1] = F * f + v * E + p[1], M;
      }
      function z(M, Q) {
        var p = M[0], x = M[1], F = Q[0], v = Q[1], f = Math.sqrt(p * p + x * x) * Math.sqrt(F * F + v * v), E = f && (p * F + x * v) / f;
        return Math.acos(Math.min(Math.max(E, -1), 1));
      }
      function U(M) {
        return M[0] = 0, M[1] = 0, M;
      }
      function O(M) {
        return "vec2(" + M[0] + ", " + M[1] + ")";
      }
      function ll(M, Q) {
        return M[0] === Q[0] && M[1] === Q[1];
      }
      function _(M, Q) {
        var p = M[0], x = M[1], F = Q[0], v = Q[1];
        return Math.abs(p - F) <= i.EPSILON * Math.max(1, Math.abs(p), Math.abs(F)) && Math.abs(x - v) <= i.EPSILON * Math.max(1, Math.abs(x), Math.abs(v));
      }
      var Zl = Y, $ = y, ol = X, al = W, g = e, k = a, j = R, A = function() {
        var M = t();
        return function(Q, p, x, F, v, f) {
          var E, q;
          for (p || (p = 2), x || (x = 0), F ? q = Math.min(F * p + x, Q.length) : q = Q.length, E = x; E < q; E += p)
            M[0] = Q[E], M[1] = Q[E + 1], v(M, M, f), Q[E] = M[0], Q[E + 1] = M[1];
          return Q;
        };
      }();
    },
    /* 12 */
    /***/
    function(m, d, l) {
      l.r(d);
      var i = l(13);
      l.d(d, "Renderer", function() {
        return i.default;
      });
      var t = l(40);
      l.d(d, "Figure2D", function() {
        return t.default;
      });
      var s = l(56);
      l.d(d, "Mesh2D", function() {
        return s.default;
      });
      var b = l(29);
      l.d(d, "MeshCloud", function() {
        return b.default;
      });
      var Z = l(23);
      l.d(d, "parseFont", function() {
        return Z.default;
      });
      var o = l(31);
      l.d(d, "parseColor", function() {
        return o.default;
      });
      var G = l(21);
      l.d(d, "ENV", function() {
        return G.default;
      }), l(1).glMatrix.setMatrixArrayType(Array);
    },
    /* 13 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return N;
      });
      var i = l(14), t = l(1), s = l(20), b = l(27), Z = l(25), o = l(40), G = l(56), y = l(29), X = l(59), W = l(21), h = l(63);
      l(1).glMatrix.setMatrixArrayType(Array);
      const r = {
        autoUpdate: !1,
        // premultipliedAlpha: true,
        preserveDrawingBuffer: !1,
        // depth: false,
        // antialias: false,
        bufferSize: 1500
      }, L = `attribute vec3 a_vertexPosition;
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

void main() {
  gl_PointSize = 1.0;
  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);    
  vTextureCoord = a_vertexTextureCoord;              
}
`, u = `precision mediump float;
varying vec3 vTextureCoord;
uniform sampler2D u_texSampler;
void main() {
  gl_FragColor = texture2D(u_texSampler, vTextureCoord.xy);
}
`, V = Symbol("glRenderer"), c = Symbol("canvasRenderer"), n = Symbol("options"), e = Symbol("globalTransform"), a = Symbol("applyGlobalTransform"), Y = Symbol("canvas");
      function R(I) {
        const J = I.gl, T = I.fbo;
        T && J.bindFramebuffer(J.FRAMEBUFFER, T), I._draw(), T && J.bindFramebuffer(J.FRAMEBUFFER, null);
      }
      function C(I, J, T, K) {
        const S = I.createTexture(J.canvas), H = [[[0, 0], [T, 0], [T, K], [0, K], [0, 0]]];
        H.closed = !0;
        const w = new G.default({
          contours: H
        });
        w.setTexture(S), I.setMeshData([w.meshData]), R(I), S.delete(), J.clearRect(0, 0, T, K), delete J._filter;
      }
      class N {
        constructor(J, T = {}) {
          let K = T.contextType;
          if (K || (typeof WebGL2RenderingContext == "function" ? K = "webgl2" : typeof WebGLRenderingContext == "function" ? K = "webgl" : K = "2d"), !J.getContext) {
            const S = J;
            J = {
              getContext() {
                return S;
              },
              width: T.width,
              height: T.height
            }, S.canvas = J, K = "2d";
          }
          if (this[Y] = J, K !== "webgl" && K !== "webgl2" && K !== "2d")
            throw new Error(`Unknown context type ${K}`);
          if (T.contextType = K, this[n] = Object.assign({}, r, T), K === "webgl" || K === "webgl2") {
            K === "webgl2" && (this[n].webgl2 = !0);
            const S = new i.default(J, this[n]);
            K === "webgl2" && !S.isWebGL2 && (T.contextType = "webgl"), Object(h.createShaders)(S), Object(h.applyShader)(S), Object(h.createCloudShaders)(S);
            const H = S.gl;
            H.clearColor(0, 0, 0, 0), H.blendFuncSeparate(H.SRC_ALPHA, H.ONE_MINUS_SRC_ALPHA, H.ONE, H.ONE_MINUS_SRC_ALPHA), this[V] = S;
          } else
            this[c] = new s.default(J, this[n]);
          this[e] = [1, 0, 0, 0, 1, 0, 0, 0, 1], this.updateResolution();
        }
        get canvas() {
          return this[Y];
        }
        get canvasRenderer() {
          return this[c];
        }
        get glRenderer() {
          return this[V];
        }
        get isWebGL2() {
          return this[V] && this[V].isWebGL2;
        }
        get options() {
          return this[n];
        }
        get globalTransformMatrix() {
          const J = this[e];
          return [J[0], J[1], J[3], J[4], J[6], J[7]];
        }
        get viewMatrix() {
          return this[e];
        }
        [a]() {
          const J = this[V] || this[c];
          if (this[V]) {
            const {
              width: T,
              height: K
            } = this.canvas;
            J.uniforms.viewMatrix = this.viewMatrix, J.uniforms.projectionMatrix = this.projectionMatrix, J.uniforms.u_resolution = [T, K];
          }
        }
        updateResolution() {
          const {
            width: J,
            height: T
          } = this.canvas, K = [
            // translation
            1,
            0,
            0,
            0,
            1,
            0,
            -J / 2,
            -T / 2,
            1
          ], S = [
            // scale
            2 / J,
            0,
            0,
            0,
            -2 / T,
            0,
            0,
            0,
            1
          ], H = t.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, K);
          this.projectionMatrix = H, this[V] && this[V].gl.viewport(0, 0, J, T);
        }
        createTexture(J, T) {
          return (this[V] || this[c]).createTexture(J, T);
        }
        /* async */
        loadTexture(J, {
          useImageBitmap: T = !1
        } = {}) {
          return (this[V] || this[c]).loadTexture(J, {
            useImageBitmap: T
          });
        }
        createText(J, {
          font: T = "16px arial",
          fillColor: K = null,
          strokeColor: S = null,
          strokeWidth: H = 1
        } = {}) {
          if (this[V]) {
            const w = W.default.createText(J, {
              font: T,
              fillColor: K,
              strokeColor: S,
              strokeWidth: H
            });
            return {
              image: this.createTexture(w.image),
              rect: w.rect
            };
          }
          return {
            _img: {
              font: T,
              fillColor: K,
              strokeColor: S,
              strokeWidth: H,
              text: J
            }
          };
        }
        createProgram({
          vertex: J,
          fragment: T,
          options: K
        } = {}) {
          if (this[V]) {
            const S = this[V].compileSync(T, J);
            return S._attribOpts = K, S;
          }
          throw new Error("Context 2D cannot create webgl program.");
        }
        createPassProgram({
          vertex: J = L,
          fragment: T = u,
          options: K
        } = {}) {
          return this.createProgram({
            vertex: J,
            fragment: T,
            options: K
          });
        }
        useProgram(J, T = {}) {
          if (this[V]) {
            const K = Object.assign({}, J._attribOpts, T);
            return this[V].useProgram(J, K);
          }
          throw new Error("Context 2D cannot use webgl program.");
        }
        deleteTexture(J) {
          return (this[V] || this[c]).deleteTexture(J);
        }
        clear(...J) {
          if (this[V]) {
            const T = this[V].gl;
            T.clear(T.COLOR_BUFFER_BIT);
          } else
            this[c].clear(...J);
        }
        drawMeshCloud(J, {
          clear: T = !1,
          program: K = null
        } = {}) {
          const S = this[V] || this[c], H = K || J.program;
          if (this[V]) {
            const w = S.gl;
            if (T && w.clear(w.COLOR_BUFFER_BIT), H)
              S.program !== H && this.useProgram(H, {
                a_color: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_fillCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_strokeCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_frameIndex: {
                  type: "UNSIGNED_BYTE",
                  normalize: !1
                }
              });
            else {
              const P = J.mesh.meshData, B = !!P.uniforms.u_texSampler, D = !!P.uniforms.u_filterFlag, z = !!P.uniforms.u_radialGradientVector, U = J.hasCloudColor, O = J.hasCloudFilter, ll = !!P.uniforms.u_clipSampler;
              Object(h.applyCloudShader)(S, {
                hasTexture: B,
                hasFilter: D,
                hasGradient: z,
                hasCloudColor: U,
                hasCloudFilter: O,
                hasClipPath: ll
              });
            }
            this[a](), S.setMeshData([J.meshData]), J.beforeRender && J.beforeRender(w, J), R(S), J.afterRender && J.afterRender(w, J);
          } else
            S.setTransform(this.globalTransformMatrix), S.drawMeshCloud(J, {
              clear: T,
              hook: !1
            });
        }
        drawMeshes(J, {
          clear: T = !1,
          program: K = null
        } = {}) {
          const S = this[V] || this[c];
          if (this[V]) {
            const H = S.fbo, w = Object(b.default)(this, J, K == null), P = S.gl;
            T && P.clear(P.COLOR_BUFFER_BIT);
            const B = !Object(X.isUnitTransform)(this.globalTransformMatrix);
            this._drawCalls = 0;
            for (const D of w) {
              this._drawCalls++;
              const z = K || D.program;
              if (D instanceof y.default)
                this.drawMeshCloud(D, {
                  clear: T,
                  program: z
                });
              else {
                const {
                  width: U,
                  height: O
                } = this.canvas;
                if (D.beforeRender && D.beforeRender(P, D), D.pass.length && ((!this.fbo || this.fbo.width !== U || this.fbo.height !== O) && (this.fbo = {
                  width: U,
                  height: O,
                  target: S.createFBO(),
                  buffer: S.createFBO(),
                  swap() {
                    [this.target, this.buffer] = [this.buffer, this.target];
                  }
                }), S.bindFBO(this.fbo.target)), !z && D.filterCanvas) {
                  Object(h.applyShader)(S, {
                    hasTexture: !0
                  });
                  let ll = this.filterContext;
                  ll || (ll = W.default.createCanvas(U, O).getContext("2d"), this.filterContext = ll);
                  const _ = J[D.packIndex], Zl = _.filter, $ = J[D.packIndex + 1], ol = J[D.packIndex - 1];
                  (!ol || !ol.filterCanvas || ol.filter !== Zl) && (!$ || !$.filterCanvas || $.filter !== Zl) ? (B ? (ll.save(), Object(Z.drawMesh2D)(_, ll, !1), ll.restore(), Object(Z.applyFilter)(ll, Zl)) : Object(Z.drawMesh2D)(_, ll, !0), this[a](), C(S, ll, U, O)) : (B && ll.save(), Object(Z.drawMesh2D)(_, ll, !1), B && ll.restore(), (!$ || !$.filterCanvas || _.filter !== $.filter) && (Object(Z.applyFilter)(ll, Zl), this[a](), C(S, ll, U, O)));
                } else {
                  if (z)
                    S.program !== z && this.useProgram(z, {
                      a_color: {
                        type: "UNSIGNED_BYTE",
                        normalize: !0
                      }
                    });
                  else {
                    const ll = !!D.uniforms.u_texSampler, _ = !!D.uniforms.u_filterFlag, Zl = !!D.uniforms.u_radialGradientVector, $ = !!D.uniforms.u_clipSampler;
                    Object(h.applyShader)(S, {
                      hasTexture: ll,
                      hasFilter: _,
                      hasGradient: Zl,
                      hasClipPath: $
                    });
                  }
                  D.filterCanvas && console.warn("User program ignored some filter effects."), this[a](), S.setMeshData([D]), R(S);
                }
                if (D.pass.length) {
                  const ll = D.pass.length;
                  D.pass.forEach((_, Zl) => {
                    _.blend = D.enableBlend, _.setTexture(S.fbo.texture), Zl === ll - 1 ? S.bindFBO(H) : (this.fbo.swap(), S.bindFBO(this.fbo.target)), _.program ? S.useProgram(_.program) : (this.defaultPassProgram = this.defaultPassProgram || this.createPassProgram(), S.useProgram(this.defaultPassProgram)), S.setMeshData([_.meshData]), P.clear(P.COLOR_BUFFER_BIT), R(S);
                  });
                }
                D.afterRender && D.afterRender(P, D);
              }
            }
          } else
            S.setTransform(this.globalTransformMatrix), S.drawMeshes(J, {
              clear: T
            });
        }
        drawImage(J, ...T) {
          const K = T.length;
          if (K < 2)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': 3 arguments required, but only ${T.length + 1} present.`);
          if (K !== 2 && K !== 4 && K !== 8)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': Valid arities are: [3, 5, 9], but ${T.length + 1} arguments provided.`);
          let S = null, H = null;
          K === 2 ? S = [T[0], T[1], J.width, J.height] : K === 4 ? S = T : K === 8 && (H = T.slice(0, 4), S = T.slice(4));
          const w = this.createTexture(J), {
            width: P,
            height: B
          } = this.canvas, D = new o.default();
          D.rect(S[0], S[1], P, B);
          const z = new G.default(D, {
            width: P,
            height: B
          });
          z.setTexture(w, {
            rect: S,
            srcRect: H
          }), this.drawMeshes([z]), this.deleteTexture(w);
        }
        setGlobalTransform(...J) {
          return this[e] = [J[0], J[1], 0, J[2], J[3], 0, J[4], J[5], 1], this;
        }
        globalTransform(...J) {
          const T = this[e];
          return this[e] = t.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), T, J), this;
        }
        globalTranslate(J, T) {
          let K = t.mat3.create();
          return K = t.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), K, [J, T]), this.globalTransform(...K);
        }
        globalRotate(J, [T, K] = [0, 0]) {
          let S = t.mat3.create();
          return S = t.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, [T, K]), S = t.mat3.rotate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, J), S = t.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, [-T, -K]), this.globalTransform(...S);
        }
        globalScale(J, T = J, [K, S] = [0, 0]) {
          let H = t.mat3.create();
          return H = t.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [K, S]), H = t.mat3.scale(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [J, T]), H = t.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [-K, -S]), this.globalTransform(...H);
        }
        globalSkew(J, T = J, [K, S] = [0, 0]) {
          let H = t.mat3.create();
          return H = t.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [K, S]), H = t.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, t.mat3.fromValues(1, Math.tan(T), Math.tan(J), 1, 0, 0)), H = t.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [-K, -S]), this.globalTransform(...H);
        }
        transformPoint(J, T, K) {
          let S = this.globalTransformMatrix;
          K && (S = t.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), S, K));
          const H = J * S[0] + T * S[2] + S[4], w = J * S[1] + T * S[3] + S[5];
          return [H, w];
        }
      }
    },
    /* 14 */
    /***/
    function(m, d, l) {
      l.r(d);
      var i = l(15);
      l(1).glMatrix.setMatrixArrayType(Array), d.default = i.default;
    },
    /* 15 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return h;
      });
      var i = l(16), t = l(17), s = l(18), b = l(19);
      l(1).glMatrix.setMatrixArrayType(Array);
      function Z(r, L, u) {
        return L in r ? Object.defineProperty(r, L, { value: u, enumerable: !0, configurable: !0, writable: !0 }) : r[L] = u, r;
      }
      const o = {};
      function G(r, L = 3) {
        const u = [], V = r.length;
        for (let c = 0; c < V; c++)
          c % L < 2 && u.push(0.5 * (r[c] + 1));
        return u;
      }
      function y(r, L) {
        const u = L._buffers;
        Object.values(u).forEach((V) => {
          r.deleteBuffer(V);
        }), L._buffers = {};
      }
      function X(r, L, u) {
        return r.activeTexture(r.TEXTURE0 + u), Array.isArray(L._img) ? r.bindTexture(r.TEXTURE_CUBE_MAP, L) : r.bindTexture(r.TEXTURE_2D, L), L;
      }
      const W = {
        int: "1i",
        ivec2: "2i",
        ivec3: "3i",
        ivec4: "4i",
        float: "1f",
        vec2: "2f",
        vec3: "3f",
        vec4: "4f",
        mat2: "Matrix2fv",
        mat3: "Matrix3fv",
        mat4: "Matrix4fv",
        sampler1D: "sampler1D",
        sampler2D: "sampler2D",
        sampler3D: "sampler3D",
        samplerCube: "samplerCube",
        sampler1DShadow: "sampler1DShadow",
        sampler2DShadow: "sampler2DShadow",
        sampler2DRect: "sampler2DRect",
        sampler2DRectShadow: "sampler2DRectShadow"
      };
      class h {
        static addLibs(L = {}) {
          Object.assign(o, L);
        }
        static FLOAT(L, u) {
          return Object(i.pointsToBuffer)(L, Float32Array, u);
        }
        static UNSIGNED_BYTE(L, u) {
          return Object(i.pointsToBuffer)(L, Uint8Array, u);
        }
        static UNSIGNED_SHORT(L, u) {
          return Object(i.pointsToBuffer)(L, Uint16Array, u);
        }
        static BYTE(L, u) {
          return Object(i.pointsToBuffer)(L, Int8Array, u);
        }
        static SHORT(L, u) {
          return Object(i.pointsToBuffer)(L, Int16Array, u);
        }
        constructor(L, u = {}) {
          this.options = Object.assign({}, h.defaultOptions, u), this.canvas = L;
          let V;
          this.options.webgl2 && (V = L.getContext("webgl2", this.options)), V == null && (V = Object(i.setupWebGL)(L, this.options), this.aia_ext = V.getExtension("ANGLE_instanced_arrays")), this.gl = V, V.viewport(0, 0, L.width, L.height), V.clearColor(0, 0, 0, 0), V.blendFuncSeparate(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA, V.ONE, V.ONE_MINUS_SRC_ALPHA), this.programs = [], this._events = {};
        }
        get program() {
          const L = this.gl;
          return L.getParameter(L.CURRENT_PROGRAM);
        }
        // WebGLRenderingContext.uniform[1234][fi][v]()
        // WebGLRenderingContext.uniformMatrix[234]fv()
        _declareUniform(L, u, V = "1f") {
          const c = this.gl, n = c.getUniformLocation(L, u);
          let e;
          const a = this;
          if (/^sampler/.test(V)) {
            const Y = L._samplerMap, R = L._bindTextures;
            Object.defineProperty(L.uniforms, u, {
              get() {
                return e;
              },
              set(C) {
                e = C;
                const N = Y[u] != null ? Y[u] : R.length;
                R[N] = C, X(c, C, N), Y[u] || (Y[u] = N, c.uniform1i(n, N)), a.options.autoUpdate && a.update();
              },
              configurable: !1,
              enumerable: !0
            });
          } else {
            const Y = V.indexOf("Matrix") === 0, R = !Y && /v$/.test(V), C = c[`uniform${V}`].bind(c);
            Object.defineProperty(L.uniforms, u, {
              get() {
                return e;
              },
              set(N) {
                e = N, typeof N == "number" && (N = [N]), Y ? C(n, !1, N) : R ? C(n, N) : C(n, ...N), a.options.autoUpdate && a.update();
              },
              configurable: !1,
              enumerable: !0
            });
          }
        }
        _draw() {
          const L = this.program;
          L.meshData.forEach((u, V) => {
            const {
              positions: c,
              cells: n,
              instanceCount: e,
              cellsCount: a,
              attributes: Y,
              uniforms: R,
              textureCoord: C,
              enableBlend: N
            } = u, I = this.gl;
            let J = u.mode != null ? u.mode : I.TRIANGLES;
            typeof J == "string" && (J = I[J]), N ? I.enable(I.BLEND) : I.disable(I.BLEND), I.bindBuffer(I.ARRAY_BUFFER, L._buffers.verticesBuffer), I.bufferData(I.ARRAY_BUFFER, c, I.STATIC_DRAW), n && (I.bindBuffer(I.ELEMENT_ARRAY_BUFFER, L._buffers.cellsBuffer), I.bufferData(I.ELEMENT_ARRAY_BUFFER, n, I.STATIC_DRAW));
            const T = [];
            Y && Object.values(Y).forEach(({
              name: S,
              data: H,
              divisor: w
            }) => {
              if (I.bindBuffer(I.ARRAY_BUFFER, L._buffers[S]), I.bufferData(I.ARRAY_BUFFER, H, I.STATIC_DRAW), w != null) {
                const P = I.getAttribLocation(L, S);
                P >= 0 && (I.enableVertexAttribArray(P), T.push(P), I.vertexAttribDivisor ? I.vertexAttribDivisor(P, w) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(P, w));
              }
            }), R && Object.entries(R).forEach(([S, H]) => {
              this.uniforms[S] = H;
            });
            let K;
            if (!n) {
              const S = L._dimension;
              K = c.length / S;
            }
            if (L._enableTextures && L._buffers.texCoordBuffer) {
              const S = C || G(c, L._dimension);
              I.bindBuffer(I.ARRAY_BUFFER, L._buffers.texCoordBuffer), I.bufferData(I.ARRAY_BUFFER, h.FLOAT(S), I.STATIC_DRAW);
            }
            e != null ? (n ? I.drawElementsInstanced ? I.drawElementsInstanced(J, a, I.UNSIGNED_SHORT, 0, e) : this.aia_ext && this.aia_ext.drawElementsInstancedANGLE(J, a, I.UNSIGNED_SHORT, 0, e) : I.drawArraysInstanced ? I.drawArraysInstanced(J, 0, K, e) : this.aia_ext.drawArraysInstancedANGLE(J, 0, K, e), T.forEach((S) => {
              I.vertexAttribDivisor ? I.vertexAttribDivisor(S, null) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(S, null);
            })) : n ? I.drawElements(J, a, I.UNSIGNED_SHORT, 0) : I.drawArrays(J, 0, K);
          });
        }
        get isWebGL2() {
          return typeof WebGL2RenderingContext < "u" && this.gl instanceof WebGL2RenderingContext;
        }
        get enableTextures() {
          return this.program && this.program._enableTextures;
        }
        get uniforms() {
          const L = this.program;
          if (!L || !L.uniforms)
            throw Error("No avaliable program.");
          return L.uniforms;
        }
        deleteProgram(L) {
          const u = this.gl;
          this.program === L && (this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID), u.useProgram(null));
          const V = this.programs.indexOf(L);
          V >= 0 && this.programs.splice(V, 1), y(u, L), u.deleteProgram(L);
        }
        /**
          [{
            positions: ...
            cells: ...
            textureCoord: ...
            attributes: {name: {data:..., normalize: true}},
            uniforms: ...
          }]
         */
        setMeshData(L) {
          Array.isArray(L) || (L = [L]);
          const u = this.program;
          u.meshData = L.map(({
            mode: V,
            positions: c,
            instanceCount: n,
            cells: e,
            cellsCount: a,
            attributes: Y,
            uniforms: R,
            textureCoord: C,
            enableBlend: N
          }) => {
            const I = {
              positions: h.FLOAT(c),
              uniforms: R,
              enableBlend: !!N,
              textureCoord: h.FLOAT(C)
            };
            if (e && (I.cells = h.USHORT(e), I.cellsCount = a || I.cells.length), V != null && (I.mode = V), n != null) {
              if (!this.isWebGL2 && !this.aia_ext)
                throw new Error("Cannot use instanceCount in this rendering context, use webgl2 context instead.");
              I.instanceCount = n;
            }
            if (Y) {
              const J = {};
              Object.entries(Y).forEach(([T, K]) => {
                if (!u._attribute[T])
                  u._attribute[T] = "ignored";
                else if (u._attribute[T] !== "ignored") {
                  const {
                    name: S,
                    type: H
                  } = u._attribute[T];
                  let w = K.data || K;
                  if (Array.isArray(w) && (w = h[H](w)), J[T] = {
                    name: S,
                    data: w
                  }, K.divisor != null) {
                    if (!this.isWebGL2 && !this.aia_ext)
                      throw new Error("Cannot use divisor in this rendering context, use webgl2 context instead.");
                    J[T].divisor = K.divisor;
                  }
                }
              }), I.attributes = J;
            }
            return I;
          }), this.options.autoUpdate && this.update();
        }
        createProgram(L, u) {
          const V = /^\s*uniform\s+sampler/mg.test(L);
          L == null && (L = s.default), u == null && (u = V ? b.default : t.default);
          const c = this.gl, n = Object(i.createProgram)(c, u, L);
          n.shaderText = {
            vertexShader: u,
            fragmentShader: L
          }, n._buffers = {}, n._attribute = {}, n.uniforms = {}, n._samplerMap = {}, n._bindTextures = [];
          const e = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexPosition}`, "im");
          let a = u.match(e);
          a && (n._dimension = Number(a[1]));
          const Y = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexTextureCoord}`, "im");
          a = u.match(Y), a && (n._texCoordSize = Number(a[1]));
          const R = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/gim;
          if (a = u.match(R), a)
            for (let I = 0; I < a.length; I++) {
              const J = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/im, T = a[I].match(J);
              if (T && T[3] !== this.options.vertexPosition && T[3] !== this.options.vertexTextureCoord) {
                let [, K, S, H] = T;
                K === "mat" && (S **= 2), n._buffers[H] = c.createBuffer(), n._attribute[H] = {
                  name: H,
                  type: K,
                  size: Number(S) || 1
                };
              }
            }
          const C = /^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/mg;
          a = u.match(C) || [], a = a.concat(L.match(C) || []), a.forEach((I) => {
            const J = I.match(/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/);
            let [T, K, S] = J.slice(1);
            T = W[T], S = !!S, T.indexOf("Matrix") !== 0 && S && (T += "v"), this._declareUniform(n, K, T);
          }), n._buffers.verticesBuffer = c.createBuffer(), n._buffers.cellsBuffer = c.createBuffer();
          const N = c.getAttribLocation(n, this.options.vertexTextureCoord);
          return n._enableTextures = N >= 0, n._enableTextures && (n._buffers.texCoordBuffer = c.createBuffer()), this.programs.push(n), n;
        }
        useProgram(L, u = {}) {
          this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID);
          const V = this.gl;
          V.useProgram(L);
          const c = L._dimension;
          V.bindBuffer(V.ARRAY_BUFFER, L._buffers.verticesBuffer);
          const n = V.getAttribLocation(L, this.options.vertexPosition);
          if (V.vertexAttribPointer(n, c, V.FLOAT, !1, 0, 0), V.enableVertexAttribArray(n), L._enableTextures) {
            V.bindBuffer(V.ARRAY_BUFFER, L._buffers.texCoordBuffer);
            const e = V.getAttribLocation(L, this.options.vertexTextureCoord);
            V.vertexAttribPointer(e, L._texCoordSize || 2, V.FLOAT, !1, 0, 0), V.enableVertexAttribArray(e);
          }
          if (Object.entries(L._attribute).forEach(([e, a]) => {
            if (a !== "ignored") {
              const Y = a.size, R = u[e] || {}, C = !!R.normalize;
              let N = R.type || "FLOAT";
              const I = R.key || e;
              N === "UBYTE" && (N = "UNSIGNED_BYTE"), N === "USHORT" && (N = "UNSIGNED_SHORT"), a.type = N, I && I !== e && (L._attribute[I] = a), V.bindBuffer(V.ARRAY_BUFFER, L._buffers[e]);
              const J = V.getAttribLocation(L, e);
              J >= 0 && (V.vertexAttribPointer(J, Y, V[N], C, 0, 0), V.enableVertexAttribArray(J));
            }
          }), !L.meshData) {
            const e = [[-1, -1, 0, 1].slice(0, c), [1, -1, 0, 1].slice(0, c), [1, 1, 0, 1].slice(0, c), [-1, 1, 0, 1].slice(0, c)], a = [[0, 1, 3], [3, 1, 2]];
            this.setMeshData({
              positions: e,
              cells: a
            });
          }
          return L;
        }
        compileSync(L, u) {
          L = L || s.default;
          const V = {};
          function c(Y) {
            Y = Y.replace(/^\s*/mg, "");
            const R = [], C = Y.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let N = 0; N < C.length; N++) {
                const J = C[N].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const T = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let K = J[1];
                  if (K === "graph" && (K = "graphics"), V[K])
                    R.push(`/* included ${K} */`);
                  else if (V[K] = !0, T === "lib") {
                    const S = c(o[K]);
                    R.push(S);
                  } else if (T === "link")
                    throw new Error("Cannot load external links synchronously. Use compile instead of compileSync.");
                }
              }
              R.forEach((N) => {
                Y = Y.replace(/^#pragma\s+include\s+.*/m, N);
              });
            }
            return Y;
          }
          const n = c(L), e = u ? c(u) : null;
          return this.createProgram(n, e);
        }
        async compile(L, u) {
          L = L || s.default;
          const V = {};
          async function c(Y) {
            Y = Y.replace(/^\s*/mg, "");
            const R = [], C = Y.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let N = 0; N < C.length; N++) {
                const J = C[N].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const T = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let K = J[1];
                  if (K === "graph" && (K = "graphics"), V[K])
                    R.push(`/* included ${K} */`);
                  else if (V[K] = !0, T === "lib") {
                    const S = await c(o[K]);
                    R.push(S);
                  } else if (T === "link") {
                    let S = await h.fetchShader(K);
                    S = await c(S), R.push(S);
                  }
                }
              }
              R.forEach((N) => {
                Y = Y.replace(/^#pragma\s+include\s+.*/m, N);
              });
            }
            return Y;
          }
          const n = await c(L), e = u ? await c(u) : null;
          return this.createProgram(n, e);
        }
        async load(L, u = null) {
          return L = await h.fetchShader(L), u && (u = await h.fetchShader(u)), this.compile(L, u);
        }
        createTexture(L = null, {
          wrapS: u = this.gl.CLAMP_TO_EDGE,
          wrapT: V = this.gl.CLAMP_TO_EDGE,
          minFilter: c = this.gl.LINEAR,
          magFilter: n = this.gl.LINEAR
        } = {}) {
          const e = this.gl, a = Array.isArray(L) ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D;
          this._max_texture_image_units = this._max_texture_image_units || e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS), e.activeTexture(e.TEXTURE0 + this._max_texture_image_units - 1);
          const Y = e.createTexture();
          e.bindTexture(a, Y), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !0);
          const {
            width: R,
            height: C
          } = this.canvas;
          if (L)
            if (a === e.TEXTURE_CUBE_MAP)
              for (let N = 0; N < 6; N++)
                e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + N, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, L[N]);
            else
              e.texImage2D(a, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, L);
          else if (a === e.TEXTURE_CUBE_MAP)
            for (let N = 0; N < 6; N++)
              this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + N, 0, e.RGBA, R, C, 0, e.RGBA, e.UNSIGNED_BYTE, null);
          else
            e.texImage2D(a, 0, e.RGBA, R, C, 0, e.RGBA, e.UNSIGNED_BYTE, null);
          return e.texParameteri(a, e.TEXTURE_MIN_FILTER, c), e.texParameteri(a, e.TEXTURE_MAG_FILTER, n), e.texParameteri(a, e.TEXTURE_WRAP_S, u), e.texParameteri(a, e.TEXTURE_WRAP_T, V), a === e.TEXTURE_CUBE_MAP && (L.width = L[0].width, L.height = L[0].height), e.bindTexture(a, null), Y._img = L || {
            width: R,
            height: C
          }, Y.delete = () => {
            this.deleteTexture(Y);
          }, Y;
        }
        deleteTexture(L) {
          const u = L._img;
          this.gl.deleteTexture(L), typeof u.close == "function" && u.close();
        }
        async loadTexture(L, {
          useImageBitmap: u = !0
        } = {}) {
          const V = await h.loadImage(L, {
            useImageBitmap: u
          });
          return this.createTexture(V);
        }
        createFBO({
          color: L = 1,
          blend: u = !1,
          depth: V = this.options.depth !== !1,
          stencil: c = !!this.options.stencil
        } = {}) {
          const n = this.gl, e = n.createFramebuffer();
          n.bindFramebuffer(n.FRAMEBUFFER, e);
          const a = [];
          for (let C = 0; C < L; C++) {
            const N = this.createTexture();
            n.framebufferTexture2D(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + C,
              n.TEXTURE_2D,
              N,
              0
              /* level */
            ), a.push(N);
          }
          e.textures = a, e.texture = a[0], e.blend = u;
          const {
            width: Y,
            height: R
          } = this.canvas;
          return V && !c && (e.depthBuffer = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, e.depthBuffer), n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_COMPONENT16, Y, R), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e.depthBuffer)), c && !V && (e.stencilBuffer = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, e.stencilBuffer), n.renderbufferStorage(n.RENDERBUFFER, n.STENCIL_INDEX8, Y, R), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.STENCIL_ATTACHMENT, n.RENDERBUFFER, e.stencilBuffer)), V && c && (e.depthStencilBuffer = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, e.depthStencilBuffer), n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, Y, R), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, e.depthStencilBuffer)), n.bindFramebuffer(n.FRAMEBUFFER, null), e;
        }
        bindFBO(L = null) {
          this.fbo = L;
        }
        render({
          clearBuffer: L = !0
        } = {}) {
          this.startRender = !0;
          const u = this.gl;
          let V = this.program;
          V || (V = this.createProgram(), this.useProgram(V)), this.fbo && u.bindFramebuffer(u.FRAMEBUFFER, this.fbo);
          const c = this.options.depth;
          c && u.enable(u.DEPTH_TEST), this.gl.clear(this.gl.COLOR_BUFFER_BIT | (c ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.options.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));
          const n = this._renderFrameID;
          this._draw(), this.fbo && u.bindFramebuffer(u.FRAMEBUFFER, null), this._renderFrameID === n && (this._renderFrameID = null);
        }
        update() {
          this.startRender && this._renderFrameID == null && (this._renderFrameID = requestAnimationFrame(this.render.bind(this)));
        }
      }
      Z(h, "defaultOptions", {
        preserveDrawingBuffer: !0,
        autoUpdate: !0,
        vertexPosition: "a_vertexPosition",
        vertexTextureCoord: "a_vertexTextureCoord",
        webgl2: !1
      }), Z(h, "UBYTE", h.UNSIGNED_BYTE), Z(h, "USHORT", h.UNSIGNED_SHORT), Z(h, "fetchShader", i.fetchShader), Z(h, "loadImage", i.loadImage);
    },
    /* 16 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "setupWebGL", function() {
        return t;
      }), l.d(d, "createProgram", function() {
        return s;
      }), l.d(d, "pointsToBuffer", function() {
        return b;
      }), l.d(d, "loadImage", function() {
        return o;
      }), l.d(d, "fetchShader", function() {
        return y;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(X, W) {
        const h = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        let r = null;
        for (let L = 0; L < h.length; ++L) {
          try {
            r = X.getContext(h[L], W);
          } catch {
          }
          if (r)
            break;
        }
        return r;
      }
      function t(X, W) {
        const h = i(X, W);
        if (!h)
          throw new Error("Sorry, your browser doesn't support WebGL.");
        return h;
      }
      function s(X, W, h) {
        const r = X.createShader(X.VERTEX_SHADER);
        if (X.shaderSource(r, W), X.compileShader(r), !X.getShaderParameter(r, X.COMPILE_STATUS)) {
          const V = `Vertex shader failed to compile.  The error log is:${X.getShaderInfoLog(r)}`;
          throw new Error(V);
        }
        const L = X.createShader(X.FRAGMENT_SHADER);
        if (X.shaderSource(L, h), X.compileShader(L), !X.getShaderParameter(L, X.COMPILE_STATUS)) {
          const V = `Fragment shader failed to compile.  The error log is:${X.getShaderInfoLog(L)}`;
          throw new Error(V);
        }
        const u = X.createProgram();
        if (X.attachShader(u, r), X.attachShader(u, L), X.linkProgram(u), !X.getProgramParameter(u, X.LINK_STATUS)) {
          const V = `Shader program failed to link.  The error log is:${X.getProgramInfoLog(u)}`;
          throw new Error(V);
        }
        return X.deleteShader(r), X.deleteShader(L), u;
      }
      function b(X, W = Float32Array, h = null) {
        if (h && !(h instanceof W))
          throw new TypeError("Wrong buffer type.");
        if (X == null || X instanceof W)
          return X;
        if (X[0] == null || X[0].length == null)
          return h ? (h.set(X, 0), h) : new W(X);
        const r = X[0].length, L = X.length;
        h || (h = new W(r * L));
        let u = 0;
        for (let V = 0; V < L; V++)
          for (let c = 0; c < r; c++)
            h[u++] = X[V][c];
        return h;
      }
      const Z = {};
      function o(X, {
        useImageBitmap: W = !0,
        alias: h = null
      } = {}) {
        if (!Z[X]) {
          if (typeof Image == "function") {
            const r = new Image();
            typeof X == "string" && !(typeof location == "object" && /^file:/.test(location.href)) && !/^data:/.test(X) && (r.crossOrigin = "anonymous"), Z[X] = new Promise((L) => {
              r.onload = function() {
                W && typeof createImageBitmap == "function" ? createImageBitmap(r, {
                  imageOrientation: "flipY"
                }).then((u) => {
                  Z[X] = u, h && (Z[h] = u), L(u);
                }) : (Z[X] = r, h && (Z[h] = r), L(r));
              }, r.src = X;
            }), h && (Z[h] = Z[X]);
          } else if (typeof fetch == "function")
            return fetch(X, {
              method: "GET",
              mode: "cors",
              cache: "default"
            }).then((r) => r.blob()).then((r) => createImageBitmap(r, {
              imageOrientation: "flipY"
            }).then((L) => (Z[X] = L, h && (Z[h] = L), L)));
        }
        return Z[X];
      }
      const G = {};
      async function y(X) {
        if (G[X])
          return G[X];
        const W = await fetch(X);
        if (W.status >= 200 && W.status < 300) {
          const h = await W.text();
          return G[X] = h, h;
        }
        throw new Error("Shader loaded error.");
      }
    },
    /* 17 */
    /***/
    function(m, d, l) {
      l.r(d), d.default = `attribute vec3 a_vertexPosition;

void main() {
  gl_PointSize = 1.0;
  gl_Position = vec4(a_vertexPosition, 1);
}`;
    },
    /* 18 */
    /***/
    function(m, d, l) {
      l.r(d), d.default = `#ifdef GL_ES
precision mediump float;
#endif

void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
}`;
    },
    /* 19 */
    /***/
    function(m, d, l) {
      l.r(d), d.default = `attribute vec4 a_vertexPosition;
attribute vec2 a_vertexTextureCoord;
varying vec2 vTextureCoord;

void main() {
  gl_PointSize = 1.0;
  gl_Position = a_vertexPosition;
  vTextureCoord = a_vertexTextureCoord;
}`;
    },
    /* 20 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return b;
      });
      var i = l(21), t = l(25);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol("transform");
      class b {
        constructor(o, G) {
          this.context = o.getContext("2d"), this.options = G, this[s] = [1, 0, 0, 1, 0, 0];
        }
        createTexture(o) {
          return {
            _img: o
          };
        }
        async loadTexture(o) {
          const G = await i.default.loadImage(o, {
            useImageBitmap: !1
          });
          return this.createTexture(G);
        }
        deleteTexture(o) {
          return o;
        }
        clear(o, G, y, X) {
          const W = this.context;
          o = o || 0, G = G || 0, y = y || W.canvas.width - o, X = X || W.canvas.height - G, W.clearRect(o, G, y, X);
        }
        drawMeshCloud(o, {
          clear: G = !1
        } = {}) {
          const y = [];
          for (let X = 0; X < o.amount; X++) {
            const W = o.getTransform(X);
            let h = o.getTextureFrame(X);
            h && (h = h._img);
            const r = o.getFilter(X), {
              fill: L,
              stroke: u
            } = o.getCloudRGBA(X);
            y.push({
              mesh: o.mesh,
              _cloudOptions: [L, u, h, W, r]
            });
          }
          o.beforeRender && o.beforeRender(this.context, o), this.drawMeshes(y, {
            clear: G,
            hook: !1
          }), o.afterRender && o.afterRender(this.context, o);
        }
        drawMeshes(o, {
          clear: G = !1,
          hook: y = !0
        } = {}) {
          const X = this.context;
          G && X.clearRect(0, 0, X.canvas.width, X.canvas.height);
          let W = null;
          const {
            width: h,
            height: r
          } = X.canvas, L = o.length;
          o.forEach((u, V) => {
            let c, n, e, a, Y;
            y && u.beforeRender && u.beforeRender(X, u), u._cloudOptions && ([c, n, e, a, Y] = u._cloudOptions, u = u.mesh);
            let R = u.filter;
            if (Y && (R = R ? `${R} ${Y}` : Y), R && !this.filterBuffer && this.filterBuffer !== !1) {
              const C = i.default.createCanvas(h, r);
              C ? this.filterBuffer = C.getContext("2d") : this.filterBuffer = !1;
            }
            W && W !== R && (Object(t.applyFilter)(this.filterBuffer, W), X.drawImage(this.filterBuffer.canvas, 0, 0, h, r), this.filterBuffer.clearRect(0, 0, h, r), W = null), R && this.filterBuffer ? (this.filterBuffer.save(), this.filterBuffer.transform(...this[s]), Object(t.drawMesh2D)(u, this.filterBuffer, !1, c, n, e, a), this.filterBuffer.restore(), V === L - 1 ? (Object(t.applyFilter)(this.filterBuffer, R), X.drawImage(this.filterBuffer.canvas, 0, 0, h, r), this.filterBuffer.clearRect(0, 0, h, r)) : W = R) : (X.save(), X.transform(...this[s]), Object(t.drawMesh2D)(u, X, !1, c, n, e, a), X.restore()), y && u.afterRender && u.afterRender(X, u);
          });
        }
        setTransform(o) {
          this[s] = o;
        }
      }
    },
    /* 21 */
    /***/
    function(m, d, l) {
      l.r(d), (function(i) {
        var t = l(14), s = l(23), b = l(24);
        l(1).glMatrix.setMatrixArrayType(Array);
        const Z = {};
        function o(h, r) {
          const {
            style: L,
            variant: u,
            weight: V,
            stretch: c,
            size: n,
            pxLineHeight: e,
            family: a
          } = h;
          return c === "normal" ? `${L} ${u} ${V} ${n * r}px/${e * r}px ${a}` : `${L} ${u} ${V} ${c} ${n * r}px/${e * r}px ${a}`;
        }
        function G(h, {
          font: r,
          fillColor: L,
          strokeColor: u,
          strokeWidth: V,
          ratio: c = 1,
          textCanvas: n,
          cachable: e = !1
        }) {
          let a;
          if (e) {
            a = [h, r, String(L), String(u), String(V)].join("###");
            const w = Z[a];
            if (w)
              return w;
          }
          n || (n = X(1, 1));
          const Y = n.getContext("2d");
          Y.save(), Y.font = r;
          let {
            width: R
          } = Y.measureText(h);
          Y.restore();
          const C = Object(s.default)(r), N = Math.max(C.pxLineHeight, C.pxHeight * 1.13);
          /italic|oblique/.test(r) && (R += N * Math.tan(15 * Math.PI / 180)), !L && !u && (L = "#000");
          const I = Y.canvas, J = Math.ceil(R), T = Math.ceil(N);
          I.width = Math.round(J * c), I.height = Math.round(T * c), Y.save(), Y.font = o(C, c), Y.textAlign = "center", Y.textBaseline = "middle";
          const K = I.height * 0.5 + C.pxHeight * 0.05 * c, S = I.width * 0.5;
          if (L) {
            if (Array.isArray(L))
              L = Object(b.default)(L);
            else if (L.vector) {
              let w;
              const {
                vector: P,
                colors: B
              } = L;
              P.length === 6 ? w = Y.createRadialGradient(...P) : w = Y.createLinearGradient(...P), B.forEach(({
                offset: D,
                color: z
              }) => {
                w.addColorStop(D, z);
              }), L = w;
            }
            Y.fillStyle = L, Y.fillText(h, S, K);
          }
          if (u) {
            if (Y.lineWidth = V * c, Array.isArray(u))
              u = Object(b.default)(u);
            else if (u.vector) {
              let w;
              const {
                vector: P,
                colors: B
              } = u;
              P.length === 6 ? w = Y.createRadialGradient(...P) : w = Y.createLinearGradient(...P), B.forEach(({
                offset: D,
                color: z
              }) => {
                w.addColorStop(D, z);
              }), u = w;
            }
            Y.strokeStyle = u, Y.strokeText(h, S, K);
          }
          Y.restore();
          const H = {
            image: n,
            rect: [0, 0, J, T]
          };
          return e && (Z[a] = H), H;
        }
        let y = !1;
        if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
          const h = navigator.userAgent.toLowerCase().match(/chrome\/(\d+)/);
          h && (y = Number(h[1]) < 70);
        }
        function X(h, r, L = {}) {
          const u = L.offscreen || !y && L.offscreen !== !1;
          let V;
          return typeof i < "u" && typeof i.createCanvas == "function" ? V = i.createCanvas(h, r, L) : u && typeof OffscreenCanvas == "function" ? V = new OffscreenCanvas(h, r) : (V = document.createElement("canvas"), V.width = h, V.height = r), V;
        }
        const W = {
          createCanvas: X,
          createText: G,
          loadImage: t.default.loadImage
        };
        d.default = W;
      }).call(this, l(22));
    },
    /* 22 */
    /***/
    function(m, d) {
      var l;
      l = /* @__PURE__ */ function() {
        return this;
      }();
      try {
        l = l || new Function("return this")();
      } catch {
        typeof window == "object" && (l = window);
      }
      m.exports = l;
    },
    /* 23 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return L;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(u, V) {
        if (typeof u == "string") {
          const e = u.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%)$/);
          e ? u = {
            size: parseFloat(e[1]),
            unit: e[2]
          } : u = {
            size: parseInt(u, 10),
            unit: "px"
          };
        }
        let {
          size: c,
          unit: n
        } = u;
        if (n === "pt")
          c /= 0.75;
        else if (n === "pc")
          c *= 16;
        else if (n === "in")
          c *= 96;
        else if (n === "cm")
          c *= 96 / 2.54;
        else if (n === "mm")
          c *= 96 / 25.4;
        else if (n === "em" || n === "rem" || n === "ex") {
          if (!V && typeof getComputedStyle == "function" && typeof document < "u") {
            const e = getComputedStyle(document.documentElement).fontSize;
            V = i(e, 16);
          }
          c *= V, n === "ex" && (c /= 2);
        } else if (n === "q")
          c *= 96 / 25.4 / 4;
        else if (n === "vw" || n === "vh") {
          if (typeof document < "u") {
            const e = n === "vw" ? document.documentElement.clientWidth : document.documentElement.clientHeight;
            c *= e / 100;
          }
        } else if ((n === "vmax" || n === "vmin") && typeof document < "u") {
          const e = document.documentElement.clientWidth, a = document.documentElement.clientHeight;
          n === "vmax" ? c *= Math.max(e, a) / 100 : c *= Math.min(e, a) / 100;
        }
        return c;
      }
      const t = "bold|bolder|lighter|[1-9]00", s = "italic|oblique", b = "small-caps", Z = "ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded", o = "px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%", G = `'([^']+)'|"([^"]+)"|([\\w-]|[一-龥])+`, y = new RegExp(`(${t}) +`, "i"), X = new RegExp(`(${s}) +`, "i"), W = new RegExp(`(${b}) +`, "i"), h = new RegExp(`(${Z}) +`, "i"), r = new RegExp("([\\d\\.]+)(" + o + ")(?:\\/([\\d\\.]+)(" + o + "))? *((?:" + G + ")( *, *(?:" + G + "))*)");
      function L(u, V) {
        const c = r.exec(u);
        if (!c)
          return;
        const n = parseFloat(c[3]), e = {
          weight: "normal",
          style: "normal",
          stretch: "normal",
          variant: "normal",
          size: parseFloat(c[1]),
          unit: c[2],
          lineHeight: Number.isFinite(n) ? n : void 0,
          lineHeightUnit: c[4],
          family: c[5].replace(/ *, */g, ",")
        }, a = u.substring(0, c.index), Y = y.exec(a), R = X.exec(a), C = W.exec(a), N = h.exec(a);
        return Y && (e.weight = Y[1]), R && (e.style = R[1]), C && (e.variant = C[1]), N && (e.stretch = N[1]), e.pxHeight = i({
          size: e.size,
          unit: e.unit
        }, V), e.pxLineHeight = i({
          size: e.lineHeight || e.size,
          unit: e.lineHeightUnit || e.unit
        }, V), e;
      }
    },
    /* 24 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return i;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(t) {
        return `rgba(${t.map((s, b) => b < 3 ? Math.round(s * 255) : s).join()})`;
      }
    },
    /* 25 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "applyFilter", function() {
        return Z;
      }), l.d(d, "drawMesh2D", function() {
        return G;
      });
      var i = l(1), t = l(24), s = l(23), b = l(26);
      l(1).glMatrix.setMatrixArrayType(Array);
      function Z(y, X) {
        const W = y.canvas;
        y.save(), y.filter = X, y.drawImage(W, 0, 0, W.width, W.height), y.restore();
      }
      function o(y, X) {
        const W = /rgba\((\d+),(\d+),(\d+),(\d+)\)/;
        y = y.match(W).slice(1, 5).map(Number), X = X.match(W).slice(1, 5).map(Number);
        const h = [], r = X[3];
        for (let L = 0; L < 4; L++)
          h[L] = Object(b.mix)(y[L], X[L], r);
        return `rgba(${h.join()})`;
      }
      function G(y, X, W = !0, h = null, r = null, L = null, u = null) {
        X.save();
        let V = !1, c = !1;
        if (X.globalAlpha = y.getOpacity(), y._updateMatrix && y.transformScale / y.contours.scale > 1.5 && y.accurate(y.transformScale), y.lineWidth) {
          let a = y.gradient && y.gradient.stroke;
          if (a) {
            const {
              vector: Y,
              colors: R
            } = a;
            if (Y.length === 6)
              a = X.createRadialGradient(...Y);
            else if (Y.length === 4)
              a = X.createLinearGradient(...Y);
            else if (Y.length === 3)
              a = X.createCircularGradient(...Y);
            else
              throw new TypeError("Invalid vector dimension.");
            R.forEach(({
              offset: C,
              color: N
            }) => {
              let I = Object(t.default)(N);
              r && (I = o(I, r)), a.addColorStop(C, I);
            }), X.strokeStyle = a, V = !0;
          } else
            y.strokeStyle && (r ? X.strokeStyle = o(y.strokeStyle, r) : X.strokeStyle = y.strokeStyle, V = !0);
        }
        V && (X.lineWidth = y.lineWidth, X.lineJoin = y.lineJoin, X.lineCap = y.lineCap, X.miterLimit = y.miterLimit, y.lineDash && (X.setLineDash(y.lineDash), y.lineDashOffset && (X.lineDashOffset = y.lineDashOffset)));
        let n = y.gradient && y.gradient.fill;
        if (n) {
          const {
            vector: a,
            colors: Y
          } = n;
          if (a.length === 6)
            n = X.createRadialGradient(...a);
          else if (a.length === 4)
            n = X.createLinearGradient(...a);
          else if (a.length === 3)
            n = X.createCircularGradient(...a);
          else
            throw new TypeError("Invalid vector dimension.");
          Y.forEach(({
            offset: R,
            color: C
          }) => {
            let N = Object(t.default)(C);
            r && (N = o(N, r)), n.addColorStop(R, N);
          }), X.fillStyle = n, c = !0;
        } else
          y.fillStyle && (h ? X.fillStyle = o(y.fillStyle, h) : X.fillStyle = y.fillStyle, c = !0);
        if (u && X.transform(...u), X.transform(...y.transformMatrix), y.clipPath) {
          const a = y.clipPath, Y = new Path2D(a);
          X.clip(Y);
        }
        const e = y.contours.length;
        if (y.contours.forEach((a, Y) => {
          const R = a.length, C = R > 1 && i.vec2.equals(a[0], a[R - 1]), N = Y === e - 1 && y.texture;
          if (a && R > 0) {
            if (c || V || N) {
              X.beginPath(), X.moveTo(...a[0]);
              for (let I = 1; I < R; I++)
                I === R - 1 && C ? X.closePath() : X.lineTo(...a[I]);
            }
            if (c && X.fill(y.fillRule), N) {
              X.save(), X.clip();
              let {
                image: I,
                options: J
              } = y.texture;
              if (L && (I = L), J.repeat && console.warn("Context 2D not supported image repeat yet."), I.font) {
                J.scale && console.warn("Context 2D not supported text scale yet."), J.srcRect && console.warn("Context 2D not supported text srcRect yet.");
                let {
                  font: T,
                  fillColor: K,
                  strokeColor: S,
                  strokeWidth: H,
                  text: w
                } = I;
                !K && !S && (K = "#000"), Array.isArray(K) && (K = Object(t.default)(K)), Array.isArray(S) && (S = Object(t.default)(S)), X.font = T;
                const {
                  width: P
                } = X.measureText(w), B = Object(s.default)(T), D = Math.max(B.pxLineHeight, B.pxHeight * 1.13);
                X.textAlign = "center", X.textBaseline = "middle";
                const z = J.rect, U = z[0] + D * 0.5 + B.pxHeight * 0.06, O = z[1] + P * 0.5;
                z[2] != null && X.scale(z[2] / P, z[3] / D), K && (X.fillStyle = K, X.fillText(w, O, U)), S && (X.lineWidth = H, X.strokeStyle = S, X.strokeText(w, O, U));
              } else {
                let T = J.rect;
                const K = J.srcRect;
                J.scale && (T = [0, 0, X.canvas.width, X.canvas.height]), J.rotated && T && (T = [-T[1], T[0], T[3], T[2]]), K && (T = T || [0, 0, K[2], K[3]]), J.rotated && (X.translate(0, T ? T[2] : I.width), X.rotate(-0.5 * Math.PI)), K ? X.drawImage(I, ...K, ...T) : T ? X.drawImage(I, ...T) : X.drawImage(I, 0, 0);
              }
              X.restore();
            }
            V && X.stroke();
          }
        }), X.restore(), W) {
          const a = y.filter;
          a && Z(X, a);
        }
      }
    },
    /* 26 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "clamp", function() {
        return i;
      }), l.d(d, "mix", function() {
        return t;
      }), l.d(d, "transformPoint", function() {
        return s;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(b, Z, o) {
        return Z > o && ([Z, o] = [o, Z]), b < Z ? Z : b > o ? o : b;
      }
      function t(b, Z, o) {
        return b * (1 - o) + Z * o;
      }
      function s(b, Z) {
        const [o, G] = b;
        return [o * Z[0] + G * Z[2] + Z[4], o * Z[1] + G * Z[3] + Z[5]];
      }
    },
    /* 27 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return o;
      });
      var i = l(28), t = l(29);
      l(1).glMatrix.setMatrixArrayType(Array);
      function s(G, y, X) {
        const W = G.uniforms || {}, h = y.uniforms || {};
        if (W.u_texSampler && h.u_texSampler && W.u_texSampler !== h.u_texSampler)
          return !1;
        const r = Object.keys(W), L = Object.keys(h), u = r.indexOf("u_texSampler"), V = L.indexOf("u_texSampler");
        if (u >= 0 && r.splice(u, 1), V >= 0 && L.splice(V, 1), r.length !== L.length)
          return !1;
        const c = r.every((n) => {
          const e = W[n], a = h[n];
          if (e === a)
            return !0;
          if (e.length && a.length && e.length === a.length) {
            for (let Y = 0; Y < e.length; Y++)
              if (e[Y] !== a[Y])
                return !1;
            return !0;
          }
          return !1;
        });
        if (c) {
          if (W.u_texSampler && !h.u_texSampler)
            y.setTexture(W.u_texSampler, {
              hidden: !0
            });
          else if (!W.u_texSampler && h.u_texSampler)
            for (let n = 0; n < X.length; n++)
              X[n].setTexture(h.u_texSampler, {
                hidden: !0
              });
        }
        return c;
      }
      const b = {};
      function Z(G, y) {
        if (G.length) {
          const X = Object(i.default)(G, b);
          return X.enableBlend = y, G[0].filterCanvas && (X.filterCanvas = !0), X.packIndex = G[0].packIndex, X.packLength = G.length, X.beforeRender = G[0].beforeRender, X.pass = G[0].pass, X.afterRender = G[G.length - 1].afterRender, G.length = 0, X;
        }
      }
      function* o(G, y, X = !1) {
        const W = [], h = G.options.bufferSize;
        let r = 0, L = !1;
        for (let u = 0; u < y.length; u++) {
          const V = y[u];
          if (V instanceof t.default)
            W.length && (yield Z(W, L)), r = 0, L = !1, yield V;
          else {
            const c = V.meshData;
            if (c.clipPath && !c.uniforms.u_clipSampler) {
              const e = G.createTexture(c.clipPath);
              c.uniforms.u_clipSampler = e;
            }
            let n = 0;
            if ((!X || !V.canIgnore()) && c && c.positions.length) {
              V.packIndex = u;
              const e = V.filterCanvas;
              if (n = c.positions.length, e || r + n > h)
                W.length && (yield Z(W, L)), r = 0, L = !1;
              else if (r) {
                const a = W[W.length - 1];
                a && (a.filterCanvas || a.afterRender || V.beforeRender || a.pass.length || V.pass.length || a.program !== V.program || !s(a, V, W)) && (yield Z(W, L), r = 0, L = !1);
              }
              W.push(V), L = L || V.enableBlend, r += n;
            }
            u === y.length - 1 && W.length && (yield Z(W, L));
          }
        }
      }
    },
    /* 28 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return s;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const i = {
        UNSIGNED_BYTE: Uint8Array,
        UNSIGNED_SHORT: Uint16Array,
        BYTE: Int8Array,
        SHORT: Int16Array,
        FLOAT: Float32Array
      };
      function t(b, Z) {
        let o = 0, G = 0, y = 0, X = 0, W = 0, h = 0, r = 0;
        const L = b[0].program;
        for (let u = 0; u < b.length; u++) {
          const V = b[u].meshData;
          if (V) {
            r += V.positions.length;
            const c = V.positions[0].length;
            o += V.positions.length * c, G += V.cells.length * 3, h += V.attributes.a_color.length * 4;
            const n = V.textureCoord;
            n && (y += n.length * n[0].length);
            const e = V.attributes.a_sourceRect;
            e && (X += e.length * 4);
            const a = V.attributes.a_clipUV;
            a && (W += a.length * 2);
          }
        }
        if ((!Z.positions || Z.positions.length < o) && (Z.positions = new Float32Array(o)), (!Z.cells || Z.cells.length < G) && (Z.cells = new Uint16Array(G)), y && (!Z.textureCoord || Z.textureCoord.length < y) && (Z.textureCoord = new Float32Array(y)), (!Z.a_color || Z.a_color.length < h) && (Z.a_color = new Uint8Array(h)), X && (!Z.a_sourceRect || Z.a_sourceRect.length < X) && (Z.a_sourceRect = new Float32Array(X)), W && (!Z.a_clipUV || Z.a_clipUV.length < W) && (Z.a_clipUV = new Float32Array(W)), L) {
          const u = Object.entries(L._attribute), V = L._attribOpts || {};
          for (let c = 0; c < u.length; c++) {
            const [n, e] = u[c];
            if (n !== "a_color" && n !== "a_sourceRect" && e !== "ignored") {
              const a = V[n] ? V[n].type : "FLOAT", Y = i[a], R = e.size * r;
              (!Z[n] || Z[n].length < R) && (Z[n] = new Y(R));
            }
          }
        }
        return Z;
      }
      function s(b, Z) {
        let o = [], G = [], y = [], X = [], W = [], h = [], r = 0, L = 0;
        const u = b[0] ? b[0].uniforms || {} : {}, V = b[0] ? b[0].program : null;
        Z && (t(b, Z), G = Z.cells, o = Z.positions, y = Z.textureCoord, X = Z.a_color, W = Z.a_sourceRect, h = Z.a_clipUV);
        let c = !1, n = !1;
        const e = {};
        for (let Y = 0; Y < b.length; Y++) {
          let R = b[Y];
          if (R) {
            if (R.meshData && (R = R.meshData), Z) {
              const N = R.positions;
              for (let I = 0; I < N.length; I++) {
                const J = N[I], T = 3 * (r + I);
                for (let K = 0; K < J.length; K++)
                  o[T + K] = J[K];
              }
            } else
              o.push(...R.positions);
            const C = R.cells;
            for (let N = 0; N < C.length; N++) {
              const I = C[N];
              if (Z) {
                const J = 3 * (L + N);
                G[J] = I[0] + r, G[J + 1] = I[1] + r, G[J + 2] = I[2] + r;
              } else
                G.push([I[0] + r, I[1] + r, I[2] + r]);
            }
            if (Z) {
              const N = R.attributes.a_color;
              for (let I = 0; I < N.length; I++) {
                const J = N[I], T = 4 * (r + I);
                X[T] = J[0], X[T + 1] = J[1], X[T + 2] = J[2], X[T + 3] = J[3];
              }
            } else
              X.push(...R.attributes.a_color);
            if (R.attributes.a_sourceRect)
              if (c = !0, Z) {
                const N = R.attributes.a_sourceRect;
                for (let I = 0; I < N.length; I++) {
                  const J = N[I], T = 4 * (r + I);
                  W[T] = J[0], W[T + 1] = J[1], W[T + 2] = J[2], W[T + 3] = J[3];
                }
              } else
                W.push(...R.attributes.a_sourceRect);
            if (R.attributes.a_clipUV)
              if (n = !0, Z) {
                const N = R.attributes.a_clipUV;
                for (let I = 0; I < N.length; I++) {
                  const J = N[I], T = 2 * (r + I);
                  h[T] = J[0], h[T + 1] = J[1];
                }
              } else
                h.push(...R.attributes.a_clipUV);
            if (R.textureCoord)
              if (Z) {
                const N = R.textureCoord;
                for (let I = 0; I < N.length; I++) {
                  const J = N[I], T = 3 * (r + I);
                  for (let K = 0; K < J.length; K++)
                    y[T + K] = J[K];
                }
              } else
                y.push(...R.textureCoord);
            if (V) {
              const N = Object.entries(V._attribute);
              for (let I = 0; I < N.length; I++) {
                const [J, T] = N[I];
                if (J !== "a_color" && J !== "a_sourceRect" && T !== "ignored")
                  if (e[J] = [], Z) {
                    e[J] = Z[J];
                    const K = R.attributes[J], S = K[0].length;
                    for (let H = 0; H < K.length; H++) {
                      const w = K[H], P = S * (r + H);
                      for (let B = 0; B < w.length; B++)
                        e[J][P + B] = w[B];
                    }
                  } else
                    e[J].push(...R.attributes[J]);
              }
            }
            r += R.positions.length, L += R.cells.length;
          }
        }
        e.a_color = X, c && W && W.length > 0 && (e.a_sourceRect = W);
        const a = {
          positions: o,
          cells: G,
          attributes: e,
          uniforms: u,
          cellsCount: L * 3,
          program: V
        };
        return y && y.length && (a.textureCoord = y), n && h.length > 0 && (e.a_clipUV = h), a;
      }
    },
    /* 29 */
    /***/
    function(m, d, l) {
      l.r(d);
      var i = l(1), t = l(30), s = l(26), b = l(31);
      l(1).glMatrix.setMatrixArrayType(Array);
      function Z(e, a) {
        var Y = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var R = Object.getOwnPropertySymbols(e);
          a && (R = R.filter(function(C) {
            return Object.getOwnPropertyDescriptor(e, C).enumerable;
          })), Y.push.apply(Y, R);
        }
        return Y;
      }
      function o(e) {
        for (var a = 1; a < arguments.length; a++) {
          var Y = arguments[a] != null ? arguments[a] : {};
          a % 2 ? Z(Object(Y), !0).forEach(function(R) {
            G(e, R, Y[R]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(Y)) : Z(Object(Y)).forEach(function(R) {
            Object.defineProperty(e, R, Object.getOwnPropertyDescriptor(Y, R));
          });
        }
        return e;
      }
      function G(e, a, Y) {
        return a in e ? Object.defineProperty(e, a, { value: Y, enumerable: !0, configurable: !0, writable: !0 }) : e[a] = Y, e;
      }
      const y = Symbol("mesh"), X = Symbol("count"), W = Symbol("blend"), h = Symbol("filter"), r = Symbol("textures"), L = Symbol("textureOptions"), u = Symbol("cloudColor"), V = Symbol("cloudFilter"), c = Symbol("buffer");
      function n(e, a = null) {
        const Y = new Float32Array(3 * e), R = new Float32Array(3 * e), C = new Float32Array(4 * e), N = new Float32Array(4 * e), I = new Float32Array(4 * e), J = new Float32Array(4 * e), T = new Float32Array(4 * e), K = new Uint8Array(e), S = new Uint8Array(4 * e), H = new Uint8Array(4 * e);
        return a && (Y.set(a.transform0, 0), R.set(a.transform1, 0), C.set(a.color0, 0), N.set(a.color1, 0), I.set(a.color2, 0), J.set(a.color3, 0), T.set(a.color4, 0), K.set(a.frameIndex, 0), S.set(a.fillColor, 0), H.set(a.strokeColor, 0)), {
          bufferSize: e,
          transform0: Y,
          transform1: R,
          color0: C,
          color1: N,
          color2: I,
          color3: J,
          color4: T,
          frameIndex: K,
          fillColor: S,
          strokeColor: H
        };
      }
      d.default = class {
        constructor(e, a = 1, {
          buffer: Y = 1e3
        } = {}) {
          Y = Math.max(Y, a), this[X] = a, this[y] = e, this[c] = n(Y), this[r] = [], this[h] = [], this[u] = !1, this[V] = !1, this[W] = !1, this.initBuffer();
        }
        initBuffer(e = 0) {
          const a = this[X];
          for (let Y = e; Y < a; Y++)
            this[c].transform0.set([1, 0, 0], Y * 3), this[c].transform1.set([0, 1, 0], Y * 3), this[c].frameIndex.set([-1], Y), this[c].fillColor.set([0, 0, 0, 0], Y * 4), this[c].strokeColor.set([0, 0, 0, 0], Y * 4), this.setColorTransform(Y, null);
        }
        get bufferSize() {
          return this[c].bufferSize;
        }
        get mesh() {
          return this[y];
        }
        set mesh(e) {
          this[y] = e, this[r] && this.setTextureFrames(this[r], this[L]);
        }
        get hasCloudColor() {
          return this[u];
        }
        get hasCloudFilter() {
          return this[V];
        }
        _getFilter(e) {
          return this[h][e] = this[h][e] || [], this[h][e];
        }
        getFilter(e) {
          return this._getFilter(e).join(" ");
        }
        get enableBlend() {
          return this[y].enableBlend || this[W];
        }
        canIgnore() {
          return this[y].canIgnore();
        }
        delete(e) {
          if (e >= this[X] || e < 0)
            throw new Error("Out of range.");
          const {
            transform0: a,
            transform1: Y,
            color0: R,
            color1: C,
            color2: N,
            color3: I,
            color4: J,
            frameIndex: T,
            fillColor: K,
            strokeColor: S
          } = this[c];
          a.set(a.subarray(3 * (e + 1)), 3 * e), Y.set(Y.subarray(3 * (e + 1)), 3 * e), R.set(R.subarray(4 * (e + 1)), 4 * e), C.set(C.subarray(4 * (e + 1)), 4 * e), N.set(N.subarray(4 * (e + 1)), 4 * e), I.set(I.subarray(4 * (e + 1)), 4 * e), J.set(J.subarray(4 * (e + 1)), 4 * e), T.set(T.subarray(e + 1), e), K.set(K.subarray(4 * (e + 1)), 4 * e), S.set(S.subarray(4 * (e + 1)), 4 * e);
          for (const H in this[h])
            H === e ? delete this[h][H] : H > e && (this[h][H - 1] = this[h][H], delete this[h][H]);
          this[X]--;
        }
        setColorTransform(e, a) {
          if (e >= this[X] || e < 0)
            throw new Error("Out of range.");
          e *= 4;
          const {
            color0: Y,
            color1: R,
            color2: C,
            color3: N,
            color4: I
          } = this[c];
          return a != null ? (Y.set([a[0], a[5], a[10], a[15]], e), R.set([a[1], a[6], a[11], a[16]], e), C.set([a[2], a[7], a[12], a[17]], e), N.set([a[3], a[8], a[13], a[18]], e), I.set([a[4], a[9], a[14], a[19]], e), this[W] = this[W] || a[18] < 1, this[V] = !0) : (Y.set([1, 0, 0, 0], e), R.set([0, 1, 0, 0], e), C.set([0, 0, 1, 0], e), N.set([0, 0, 0, 1], e), I.set([0, 0, 0, 0], e)), this;
        }
        getColorTransform(e) {
          if (e >= this[X] || e < 0)
            throw new Error("Out of range.");
          e *= 4;
          const {
            color0: a,
            color1: Y,
            color2: R,
            color3: C,
            color4: N
          } = this[c];
          return [a[e], Y[e], R[e], C[e], N[e], a[e + 1], Y[e + 1], R[e + 1], C[e + 1], N[e + 1], a[e + 2], Y[e + 2], R[e + 2], C[e + 2], N[e + 2], a[e + 3], Y[e + 3], R[e + 3], C[e + 3], N[e + 3]];
        }
        transformColor(e, a) {
          let Y = this.getColorTransform(e);
          return Y = Object(t.multiply)(Y, a), this.setColorTransform(e, Y), this;
        }
        setFillColor(e, a) {
          if (e >= this[X] || e < 0)
            throw new Error("Out of range.");
          typeof a == "string" && (a = Object(b.default)(a)), a[3] > 0 && (this[u] = !0), this[c].fillColor.set(a.map((Y) => Math.round(255 * Y)), 4 * e);
        }
        setStrokeColor(e, a) {
          if (e >= this[X] || e < 0)
            throw new Error("Out of range.");
          typeof a == "string" && (a = Object(b.default)(a)), a[3] > 0 && (this[u] = !0), this[c].strokeColor.set(a.map((Y) => Math.round(255 * Y)), 4 * e);
        }
        getCloudRGBA(e) {
          if (e >= this[X] || e < 0)
            throw new Error("Out of range.");
          e *= 4;
          const {
            fillColor: a,
            strokeColor: Y
          } = this[c], R = [a[e], a[e + 1], a[e + 2], a[e + 3]], C = [Y[e], Y[e + 1], Y[e + 2], Y[e + 3]];
          return R[3] /= 255, C[3] /= 255, {
            fill: `rgba(${R.join()})`,
            stroke: `rgba(${C.join()})`
          };
        }
        grayscale(e, a) {
          this.transformColor(e, Object(t.grayscale)(a)), this._getFilter(e).push(`grayscale(${100 * a}%)`);
        }
        brightness(e, a) {
          this.transformColor(e, Object(t.brightness)(a)), this._getFilter(e).push(`brightness(${100 * a}%)`);
        }
        saturate(e, a) {
          this.transformColor(e, Object(t.saturate)(a)), this._getFilter(e).push(`saturate(${100 * a}%)`);
        }
        contrast(e, a) {
          this.transformColor(e, Object(t.contrast)(a)), this._getFilter(e).push(`contrast(${100 * a}%)`);
        }
        invert(e, a) {
          this.transformColor(e, Object(t.invert)(a)), this._getFilter(e).push(`invert(${100 * a}%)`);
        }
        sepia(e, a) {
          this.transformColor(e, Object(t.sepia)(a)), this._getFilter(e).push(`sepia(${100 * a}%)`);
        }
        opacity(e, a) {
          this.transformColor(e, Object(t.opacity)(a)), this._getFilter(e).push(`opacity(${100 * a}%)`);
        }
        hueRotate(e, a) {
          this.transformColor(e, Object(t.hueRotate)(a)), this._getFilter(e).push(`hue-rotate(${a}deg)`);
        }
        setTransform(e, a) {
          if (e >= this[X] || e < 0)
            throw new Error("Out of range.");
          e *= 3, a == null && (a = [1, 0, 0, 1, 0, 0]);
          const {
            transform0: Y,
            transform1: R
          } = this[c];
          return Y.set([a[0], a[2], a[4]], e), R.set([a[1], a[3], a[5]], e), this;
        }
        getTransform(e) {
          if (e >= this[X] || e < 0)
            throw new Error("Out of range.");
          e *= 3;
          const {
            transform0: a,
            transform1: Y
          } = this[c];
          return [a[e], Y[e], a[e + 1], Y[e + 1], a[e + 2], Y[e + 2]];
        }
        getTextureFrame(e) {
          return this[r][this[c].frameIndex[e]];
        }
        setTextureFrames(e = [], a = {}) {
          if (e.length > 12)
            throw new Error("Max frames exceed. Allow 12 frames.");
          e.length && this[y].setTexture(e[0], a), this[r] = e, this[L] = a;
        }
        setFrameIndex(e, a) {
          if (e >= this[X] || e < 0)
            throw new Error("Out of range.");
          const Y = this[r].length;
          if (Y <= 0)
            throw new Error("No frames");
          this[c].frameIndex[e] = a % Y;
        }
        get amount() {
          return this[X];
        }
        set amount(e) {
          const a = this[X];
          e !== a && (e > this[c].bufferSize && (this[c] = n(Math.max(e, this[c].bufferSize + 1e3), this[c])), this[X] = e, e > a && this.initBuffer(a));
        }
        get meshData() {
          const {
            attributes: e,
            cells: a,
            positions: Y,
            textureCoord: R,
            uniforms: C
          } = this[y].meshData, N = this[r], I = {
            attributes: o({}, e),
            cells: a,
            positions: Y,
            textureCoord: R,
            uniforms: o({}, C),
            instanceCount: this[X],
            enableBlend: this.enableBlend
          };
          N.length && N.forEach((U, O) => {
            I.uniforms[`u_texFrame${O}`] = U;
          });
          const {
            transform0: J,
            transform1: T,
            color0: K,
            color1: S,
            color2: H,
            color3: w,
            color4: P,
            fillColor: B,
            strokeColor: D,
            frameIndex: z
          } = this[c];
          return this[y].uniforms.u_texSampler && (I.attributes.a_frameIndex = {
            data: z,
            divisor: 1
          }), I.attributes.a_transform0 = {
            data: J,
            divisor: 1
          }, I.attributes.a_transform1 = {
            data: T,
            divisor: 1
          }, I.attributes.a_colorCloud0 = {
            data: K,
            divisor: 1
          }, I.attributes.a_colorCloud1 = {
            data: S,
            divisor: 1
          }, I.attributes.a_colorCloud2 = {
            data: H,
            divisor: 1
          }, I.attributes.a_colorCloud3 = {
            data: w,
            divisor: 1
          }, I.attributes.a_colorCloud4 = {
            data: P,
            divisor: 1
          }, this.hasCloudColor && (I.attributes.a_fillCloudColor = {
            data: B,
            divisor: 1
          }, I.attributes.a_strokeCloudColor = {
            data: D,
            divisor: 1
          }), I;
        }
        setProgram(e) {
          this[y].setProgram(e);
        }
        get program() {
          return this[y].program;
        }
        transform(e, a) {
          const Y = this.getTransform(e);
          return a = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), Y, a), this.setTransform(e, a), this;
        }
        translate(e, [a, Y]) {
          let R = i.mat2d.create();
          return R = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), R, [a, Y]), this.transform(e, R);
        }
        rotate(e, a, [Y, R] = [0, 0]) {
          let C = i.mat2d.create();
          return C = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [Y, R]), C = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), C, a), C = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [-Y, -R]), this.transform(e, C);
        }
        scale(e, [a, Y = a], [R, C] = [0, 0]) {
          let N = i.mat2d.create();
          return N = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [R, C]), N = i.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), N, [a, Y]), N = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [-R, -C]), this.transform(e, N);
        }
        skew(e, [a, Y = a], [R, C] = [0, 0]) {
          let N = i.mat2d.create();
          return N = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [R, C]), N = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), N, i.mat2d.fromValues(1, Math.tan(Y), Math.tan(a), 1, 0, 0)), N = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [-R, -C]), this.transform(e, N);
        }
        isPointCollision(e, [a, Y], R = "both") {
          const C = this.getTransform(e), N = Object(s.transformPoint)([a, Y], i.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C));
          return this[y].isPointCollision(...N, R);
        }
        isPointInFill(e, [a, Y]) {
          return this.isPointCollision(e, [a, Y], "fill");
        }
        isPointInStroke(e, [a, Y]) {
          return this.isPointCollision(e, [a, Y], "stroke");
        }
      };
    },
    /* 30 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "multiply", function() {
        return t;
      }), l.d(d, "grayscale", function() {
        return s;
      }), l.d(d, "brightness", function() {
        return b;
      }), l.d(d, "saturate", function() {
        return Z;
      }), l.d(d, "contrast", function() {
        return o;
      }), l.d(d, "invert", function() {
        return G;
      }), l.d(d, "sepia", function() {
        return y;
      }), l.d(d, "opacity", function() {
        return X;
      }), l.d(d, "hueRotate", function() {
        return W;
      });
      var i = l(26);
      l(1).glMatrix.setMatrixArrayType(Array);
      function t(h, r) {
        const L = [], u = h[0], V = h[1], c = h[2], n = h[3], e = h[4], a = h[5], Y = h[6], R = h[7], C = h[8], N = h[9], I = h[10], J = h[11], T = h[12], K = h[13], S = h[14], H = h[15], w = h[16], P = h[17], B = h[18], D = h[19];
        let z = r[0], U = r[1], O = r[2], ll = r[3], _ = r[4];
        return L[0] = z * u + U * a + O * I + ll * H, L[1] = z * V + U * Y + O * J + ll * w, L[2] = z * c + U * R + O * T + ll * P, L[3] = z * n + U * C + O * K + ll * B, L[4] = z * e + U * N + O * S + ll * D + _, z = r[5], U = r[6], O = r[7], ll = r[8], _ = r[9], L[5] = z * u + U * a + O * I + ll * H, L[6] = z * V + U * Y + O * J + ll * w, L[7] = z * c + U * R + O * T + ll * P, L[8] = z * n + U * C + O * K + ll * B, L[9] = z * e + U * N + O * S + ll * D + _, z = r[10], U = r[11], O = r[12], ll = r[13], _ = r[14], L[10] = z * u + U * a + O * I + ll * H, L[11] = z * V + U * Y + O * J + ll * w, L[12] = z * c + U * R + O * T + ll * P, L[13] = z * n + U * C + O * K + ll * B, L[14] = z * e + U * N + O * S + ll * D + _, z = r[15], U = r[16], O = r[17], ll = r[18], _ = r[19], L[15] = z * u + U * a + O * I + ll * H, L[16] = z * V + U * Y + O * J + ll * w, L[17] = z * c + U * R + O * T + ll * P, L[18] = z * n + U * C + O * K + ll * B, L[19] = z * e + U * N + O * S + ll * D + _, L;
      }
      function s(h) {
        h = Object(i.clamp)(0, 1, h);
        const r = 0.2126 * h, L = 0.7152 * h, u = 0.0722 * h;
        return [r + 1 - h, L, u, 0, 0, r, L + 1 - h, u, 0, 0, r, L, u + 1 - h, 0, 0, 0, 0, 0, 1, 0];
      }
      function b(h) {
        return [h, 0, 0, 0, 0, 0, h, 0, 0, 0, 0, 0, h, 0, 0, 0, 0, 0, 1, 0];
      }
      function Z(h) {
        const r = 0.2126 * (1 - h), L = 0.7152 * (1 - h), u = 0.0722 * (1 - h);
        return [r + h, L, u, 0, 0, r, L + h, u, 0, 0, r, L, u + h, 0, 0, 0, 0, 0, 1, 0];
      }
      function o(h) {
        const r = 0.5 * (1 - h);
        return [h, 0, 0, 0, r, 0, h, 0, 0, r, 0, 0, h, 0, r, 0, 0, 0, 1, 0];
      }
      function G(h) {
        const r = 1 - 2 * h;
        return [r, 0, 0, 0, h, 0, r, 0, 0, h, 0, 0, r, 0, h, 0, 0, 0, 1, 0];
      }
      function y(h) {
        return [1 - 0.607 * h, 0.769 * h, 0.189 * h, 0, 0, 0.349 * h, 1 - 0.314 * h, 0.168 * h, 0, 0, 0.272 * h, 0.534 * h, 1 - 0.869 * h, 0, 0, 0, 0, 0, 1, 0];
      }
      function X(h) {
        return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, h, 0];
      }
      function W(h) {
        const r = h / 180 * Math.PI, L = Math.cos(r), u = Math.sin(r), V = 0.2126, c = 0.7152, n = 0.0722;
        return [V + L * (1 - V) + u * -V, c + L * -c + u * -c, n + L * -n + u * (1 - n), 0, 0, V + L * -V + u * 0.143, c + L * (1 - c) + u * 0.14, n + L * -n + u * -0.283, 0, 0, V + L * -V + u * -(1 - V), c + L * -c + u * c, n + L * (1 - n) + u * n, 0, 0, 0, 0, 0, 1, 0];
      }
    },
    /* 31 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return s;
      });
      var i = l(32), t = /* @__PURE__ */ l.n(i);
      l(1).glMatrix.setMatrixArrayType(Array);
      function s(b) {
        const Z = t()(b);
        if (!Z || !Z.length)
          throw new TypeError("Invalid color value.");
        return [Z[0] / 255, Z[1] / 255, Z[2] / 255, Z[3]];
      }
    },
    /* 32 */
    /***/
    function(m, d, l) {
      var i = l(33), t = l(37), s = l(39);
      m.exports = function(Z) {
        var o, G = i(Z);
        return G.space ? (o = Array(3), o[0] = s(G.values[0], 0, 255), o[1] = s(G.values[1], 0, 255), o[2] = s(G.values[2], 0, 255), G.space[0] === "h" && (o = t.rgb(o)), o.push(s(G.alpha, 0, 1)), o) : [];
      };
    },
    /* 33 */
    /***/
    function(m, d, l) {
      (function(i) {
        var t = l(34), s = l(35), b = l(36);
        m.exports = o;
        var Z = {
          red: 0,
          orange: 60,
          yellow: 120,
          green: 180,
          blue: 240,
          purple: 300
        };
        function o(G) {
          var y, X = [], W = 1, h;
          if (typeof G == "string")
            if (t[G])
              X = t[G].slice(), h = "rgb";
            else if (G === "transparent")
              W = 0, h = "rgb", X = [0, 0, 0];
            else if (/^#[A-Fa-f0-9]+$/.test(G)) {
              var r = G.slice(1), L = r.length, u = L <= 4;
              W = 1, u ? (X = [
                parseInt(r[0] + r[0], 16),
                parseInt(r[1] + r[1], 16),
                parseInt(r[2] + r[2], 16)
              ], L === 4 && (W = parseInt(r[3] + r[3], 16) / 255)) : (X = [
                parseInt(r[0] + r[1], 16),
                parseInt(r[2] + r[3], 16),
                parseInt(r[4] + r[5], 16)
              ], L === 8 && (W = parseInt(r[6] + r[7], 16) / 255)), X[0] || (X[0] = 0), X[1] || (X[1] = 0), X[2] || (X[2] = 0), h = "rgb";
            } else if (y = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(G)) {
              var V = y[1], c = V === "rgb", r = V.replace(/a$/, "");
              h = r;
              var L = r === "cmyk" ? 4 : r === "gray" ? 1 : 3;
              X = y[2].trim().split(/\s*,\s*/).map(function(Y, R) {
                if (/%$/.test(Y))
                  return R === L ? parseFloat(Y) / 100 : r === "rgb" ? parseFloat(Y) * 255 / 100 : parseFloat(Y);
                if (r[R] === "h") {
                  if (/deg$/.test(Y))
                    return parseFloat(Y);
                  if (Z[Y] !== void 0)
                    return Z[Y];
                }
                return parseFloat(Y);
              }), V === r && X.push(1), W = c || X[L] === void 0 ? 1 : X[L], X = X.slice(0, L);
            } else
              G.length > 10 && /[0-9](?:\s|\/)/.test(G) && (X = G.match(/([0-9]+)/g).map(function(e) {
                return parseFloat(e);
              }), h = G.match(/([a-z])/ig).join("").toLowerCase());
          else if (!isNaN(G))
            h = "rgb", X = [G >>> 16, (G & 65280) >>> 8, G & 255];
          else if (s(G)) {
            var n = b(G.r, G.red, G.R, null);
            n !== null ? (h = "rgb", X = [
              n,
              b(G.g, G.green, G.G),
              b(G.b, G.blue, G.B)
            ]) : (h = "hsl", X = [
              b(G.h, G.hue, G.H),
              b(G.s, G.saturation, G.S),
              b(G.l, G.lightness, G.L, G.b, G.brightness)
            ]), W = b(G.a, G.alpha, G.opacity, 1), G.opacity != null && (W /= 100);
          } else
            (Array.isArray(G) || i.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(G)) && (X = [G[0], G[1], G[2]], h = "rgb", W = G.length === 4 ? G[3] : 1);
          return {
            space: h,
            values: X,
            alpha: W
          };
        }
      }).call(this, l(22));
    },
    /* 34 */
    /***/
    function(m, d, l) {
      m.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    },
    /* 35 */
    /***/
    function(m, d, l) {
      var i = Object.prototype.toString;
      m.exports = function(t) {
        var s;
        return i.call(t) === "[object Object]" && (s = Object.getPrototypeOf(t), s === null || s === Object.getPrototypeOf({}));
      };
    },
    /* 36 */
    /***/
    function(m, d) {
      m.exports = function() {
        for (var l = 0; l < arguments.length; l++)
          if (arguments[l] !== void 0)
            return arguments[l];
      };
    },
    /* 37 */
    /***/
    function(m, d, l) {
      var i = l(38);
      m.exports = {
        name: "hsl",
        min: [0, 0, 0],
        max: [360, 100, 100],
        channel: ["hue", "saturation", "lightness"],
        alias: ["HSL"],
        rgb: function(t) {
          var s = t[0] / 360, b = t[1] / 100, Z = t[2] / 100, o, G, y, X, W;
          if (b === 0)
            return W = Z * 255, [W, W, W];
          Z < 0.5 ? G = Z * (1 + b) : G = Z + b - Z * b, o = 2 * Z - G, X = [0, 0, 0];
          for (var h = 0; h < 3; h++)
            y = s + 1 / 3 * -(h - 1), y < 0 ? y++ : y > 1 && y--, 6 * y < 1 ? W = o + (G - o) * 6 * y : 2 * y < 1 ? W = G : 3 * y < 2 ? W = o + (G - o) * (2 / 3 - y) * 6 : W = o, X[h] = W * 255;
          return X;
        }
      }, i.hsl = function(t) {
        var s = t[0] / 255, b = t[1] / 255, Z = t[2] / 255, o = Math.min(s, b, Z), G = Math.max(s, b, Z), y = G - o, X, W, h;
        return G === o ? X = 0 : s === G ? X = (b - Z) / y : b === G ? X = 2 + (Z - s) / y : Z === G && (X = 4 + (s - b) / y), X = Math.min(X * 60, 360), X < 0 && (X += 360), h = (o + G) / 2, G === o ? W = 0 : h <= 0.5 ? W = y / (G + o) : W = y / (2 - G - o), [X, W * 100, h * 100];
      };
    },
    /* 38 */
    /***/
    function(m, d, l) {
      m.exports = {
        name: "rgb",
        min: [0, 0, 0],
        max: [255, 255, 255],
        channel: ["red", "green", "blue"],
        alias: ["RGB"]
      };
    },
    /* 39 */
    /***/
    function(m, d) {
      m.exports = l;
      function l(i, t, s) {
        return t < s ? i < t ? t : i > s ? s : i : i < s ? s : i > t ? t : i;
      }
    },
    /* 40 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var i = l(41), t = /* @__PURE__ */ l.n(i), s = l(42), b = /* @__PURE__ */ l.n(s), Z = l(43), o = /* @__PURE__ */ l.n(Z), G = l(44), y = l(46), X = /* @__PURE__ */ l.n(y), W = l(53), h = l(55);
      l(1).glMatrix.setMatrixArrayType(Array);
      const r = Symbol("contours"), L = Symbol("path"), u = Symbol("simplify"), V = Symbol("scale"), c = 2 * Math.PI;
      class n {
        constructor(a = {}) {
          typeof a == "string" && (a = {
            path: a
          }), a.path ? this[L] = t()(a.path) : this[L] = [], this[r] = null, this[u] = a.simplify != null ? a.simplify : 0, this[V] = a.scale != null ? a.scale : 2;
        }
        get contours() {
          let a = null;
          if (!this[r] && this[L]) {
            const Y = Object(G.default)(o()(this[L]));
            this[r] = X()(Y, this[V], this[u]), this[r].path = Y, this[r].simplify = this[u], this[r].scale = this[V];
          }
          return this[r] && (a = this[r].map((Y) => [...Y]), a.path = this[r].path, a.simplify = this[r].simplify, a.scale = this[r].scale), a;
        }
        get path() {
          return this[L];
        }
        get simplify() {
          return this[u];
        }
        get boundingBox() {
          const a = this.contours;
          if (a && a.length) {
            const Y = a.reduce((R, C) => [...R, ...C]);
            return b()(Y);
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const a = this.boundingBox;
          return a ? [0.5 * (a[0][0] + a[1][0]), 0.5 * (a[0][1] + a[1][1])] : [0, 0];
        }
        normalize(a = 0, Y = 0) {
          const R = Object(G.default)(o()(this[L])).map(([C, ...N]) => {
            const I = [C];
            for (let J = 0; J < N.length; J += 2) {
              const T = N[J] - a, K = N[J + 1] - Y;
              I.push(T, K);
            }
            return I;
          });
          return this.beginPath(), this[L].push(...R), this;
        }
        getPointAtLength(a) {
          return this.contours ? Object(W.getPointAtLength)(this[r], a) : null;
        }
        getTotalLength() {
          return this.contours ? Object(W.getTotalLength)(this[r]) : 0;
        }
        addPath(a) {
          this[r] = null, typeof a == "string" && (a = t()(a)), this[L].push(...a);
        }
        beginPath() {
          this[L] = [], this[r] = null;
        }
        clear() {
          this.beginPath();
        }
        ellipse(a, Y, R, C, N, I, J, T = 0) {
          if (I += N, J += N, R <= 0 || C <= 0 || J === I)
            return;
          J < I && (J = I + c + (J - I) % c), J - I > c && (J = I + c);
          const K = J - I;
          K >= c && (J -= 1e-3);
          let S = this[L].length > 0 && K < c ? "L" : "M";
          const H = Object(h.getPoint)(a, Y, R, C, I), w = Object(h.getPoint)(a, Y, R, C, J), P = +!T;
          let B = K > Math.PI ? 1 : 0;
          T && (B = 1 - B), S += H.join(" "), S += `A${R} ${C} 0 ${B} ${P} ${w.join(" ")}`, K >= c && (S += "Z"), this.addPath(S);
        }
        arc(a, Y, R, C, N, I = 0) {
          return this.ellipse(a, Y, R, R, 0, C, N, I);
        }
        arcTo(a, Y, R, C, N, I, J) {
          this[r] = null, this[L].push(["A", a, Y, R, C, N, I, J]);
        }
        moveTo(a, Y) {
          this[r] = null, this[L].push(["M", a, Y]);
        }
        lineTo(a, Y) {
          this[r] = null, this[L].push(["L", a, Y]);
        }
        bezierCurveTo(a, Y, R, C, N, I) {
          this[r] = null, this[L].push(["C", a, Y, R, C, N, I]);
        }
        quadraticCurveTo(a, Y, R, C) {
          this[r] = null, this[L].push(["Q", a, Y, R, C]);
        }
        rect(a, Y, R, C) {
          const N = `M${a} ${Y}L${a + R} ${Y}L${a + R} ${Y + C}L${a} ${Y + C}Z`;
          this.addPath(N);
        }
        closePath() {
          this[r] = null;
          let a = [];
          const Y = this[L].length;
          Y > 0 && (a = this[L][Y - 1]), a[0] !== "Z" && a[0] !== "z" && this[L].push(["Z"]);
        }
      }
    },
    /* 41 */
    /***/
    function(m, d) {
      m.exports = t;
      var l = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, i = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function t(Z) {
        var o = [];
        return Z.replace(i, function(G, y, X) {
          var W = y.toLowerCase();
          for (X = b(X), W == "m" && X.length > 2 && (o.push([y].concat(X.splice(0, 2))), W = "l", y = y == "m" ? "l" : "L"); ; ) {
            if (X.length == l[W])
              return X.unshift(y), o.push(X);
            if (X.length < l[W])
              throw new Error("malformed path data");
            o.push([y].concat(X.splice(0, l[W])));
          }
        }), o;
      }
      var s = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function b(Z) {
        var o = Z.match(s);
        return o ? o.map(Number) : [];
      }
    },
    /* 42 */
    /***/
    function(m, d, l) {
      m.exports = i;
      function i(t) {
        var s = t.length;
        if (s === 0)
          return [[], []];
        for (var b = t[0].length, Z = t[0].slice(), o = t[0].slice(), G = 1; G < s; ++G)
          for (var y = t[G], X = 0; X < b; ++X) {
            var W = y[X];
            Z[X] = Math.min(Z[X], W), o[X] = Math.max(o[X], W);
          }
        return [Z, o];
      }
    },
    /* 43 */
    /***/
    function(m, d) {
      m.exports = l;
      function l(i) {
        var t = 0, s = 0, b = 0, Z = 0;
        return i.map(function(o) {
          o = o.slice();
          var G = o[0], y = G.toUpperCase();
          if (G != y)
            switch (o[0] = y, G) {
              case "a":
                o[6] += b, o[7] += Z;
                break;
              case "v":
                o[1] += Z;
                break;
              case "h":
                o[1] += b;
                break;
              default:
                for (var X = 1; X < o.length; )
                  o[X++] += b, o[X++] += Z;
            }
          switch (y) {
            case "Z":
              b = t, Z = s;
              break;
            case "H":
              b = o[1];
              break;
            case "V":
              Z = o[1];
              break;
            case "M":
              b = t = o[1], Z = s = o[2];
              break;
            default:
              b = o[o.length - 2], Z = o[o.length - 1];
          }
          return o;
        });
      }
    },
    /* 44 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return t;
      });
      var i = l(45);
      l(1).glMatrix.setMatrixArrayType(Array);
      function t(Z) {
        for (var o, G = [], y = 0, X = 0, W = 0, h = 0, r = null, L = null, u = 0, V = 0, c = 0, n = Z.length; c < n; c++) {
          var e = Z[c], a = e[0];
          switch (a) {
            case "M":
              W = e[1], h = e[2];
              break;
            case "A":
              var Y = Object(i.default)(u, V, e[6], e[7], e[4], e[5], e[1], e[2], e[3]);
              if (!Y.length)
                continue;
              Y = Y.map((J) => {
                const [T, K, S, H, w, P, B, D] = J;
                return {
                  x1: S,
                  y1: H,
                  x2: w,
                  y2: P,
                  x: B,
                  y: D
                };
              });
              for (var R = 0, C; R < Y.length; R++)
                C = Y[R], e = ["C", C.x1, C.y1, C.x2, C.y2, C.x, C.y], R < Y.length - 1 && G.push(e);
              break;
            case "S":
              var N = u, I = V;
              (o == "C" || o == "S") && (N += N - y, I += I - X), e = ["C", N, I, e[1], e[2], e[3], e[4]];
              break;
            case "T":
              o == "Q" || o == "T" ? (r = u * 2 - r, L = V * 2 - L) : (r = u, L = V), e = b(u, V, r, L, e[1], e[2]);
              break;
            case "Q":
              r = e[1], L = e[2], e = b(u, V, e[1], e[2], e[3], e[4]);
              break;
            case "L":
              e = s(u, V, e[1], e[2]);
              break;
            case "H":
              e = s(u, V, e[1], V);
              break;
            case "V":
              e = s(u, V, u, e[1]);
              break;
            case "Z":
              e = s(u, V, W, h);
              break;
          }
          o = a, u = e[e.length - 2], V = e[e.length - 1], e.length > 4 ? (y = e[e.length - 4], X = e[e.length - 3]) : (y = u, X = V), G.push(e);
        }
        return G;
      }
      function s(Z, o, G, y) {
        return ["C", Z, o, G, y, G, y];
      }
      function b(Z, o, G, y, X, W) {
        return ["C", Z / 3 + 2 / 3 * G, o / 3 + 2 / 3 * y, X / 3 + 2 / 3 * G, W / 3 + 2 / 3 * y, X, W];
      }
    },
    /* 45 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const i = Math.PI * 2;
      function t(o, G, y, X) {
        const W = o * X - G * y < 0 ? -1 : 1;
        let h = o * y + G * X;
        return h > 1 && (h = 1), h < -1 && (h = -1), W * Math.acos(h);
      }
      function s(o, G, y, X, W, h, r, L, u, V) {
        const c = V * (o - y) / 2 + u * (G - X) / 2, n = -u * (o - y) / 2 + V * (G - X) / 2, e = r * r, a = L * L, Y = c * c, R = n * n;
        let C = e * a - e * R - a * Y;
        C < 0 && (C = 0), C /= e * R + a * Y, C = Math.sqrt(C) * (W === h ? -1 : 1);
        const N = C * r / L * n, I = C * -L / r * c, J = V * N - u * I + (o + y) / 2, T = u * N + V * I + (G + X) / 2, K = (c - N) / r, S = (n - I) / L, H = (-c - N) / r, w = (-n - I) / L, P = t(1, 0, K, S);
        let B = t(K, S, H, w);
        return h === 0 && B > 0 && (B -= i), h === 1 && B < 0 && (B += i), [J, T, P, B];
      }
      function b(o, G) {
        const y = 1.3333333333333333 * Math.tan(G / 4), X = Math.cos(o), W = Math.sin(o), h = Math.cos(o + G), r = Math.sin(o + G);
        return [X, W, X - W * y, W + X * y, h + r * y, r - h * y, h, r];
      }
      function Z(o, G, y, X, W, h, r, L, u) {
        const V = Math.sin(u * i / 360), c = Math.cos(u * i / 360), n = c * (o - y) / 2 + V * (G - X) / 2, e = -V * (o - y) / 2 + c * (G - X) / 2;
        if (n === 0 && e === 0)
          return [];
        if (r === 0 || L === 0)
          return [];
        r = Math.abs(r), L = Math.abs(L);
        const a = n * n / (r * r) + e * e / (L * L);
        a > 1 && (r *= Math.sqrt(a), L *= Math.sqrt(a));
        const Y = s(o, G, y, X, W, h, r, L, V, c), R = [];
        let C = Y[2], N = Y[3];
        const I = Math.max(Math.ceil(Math.abs(N) / (i / 4)), 1);
        N /= I;
        for (let J = 0; J < I; J++)
          R.push(b(C, N)), C += N;
        return R.map((J) => {
          for (let T = 0; T < J.length; T += 2) {
            let K = J[T + 0], S = J[T + 1];
            K *= r, S *= L;
            const H = c * K - V * S, w = V * K + c * S;
            J[T + 0] = H + Y[0], J[T + 1] = w + Y[1];
          }
          return J;
        });
      }
    },
    /* 46 */
    /***/
    function(m, d, l) {
      l(1).glMatrix.setMatrixArrayType(Array);
      var i = l(47), {
        copy: t
      } = l(49), s = l(50);
      function b(X, W, h) {
        return X[0] = W, X[1] = h, X;
      }
      var Z = [0, 0], o = [0, 0], G = [0, 0];
      function y(X, W, h, r) {
        i(h, b(Z, r[1], r[2]), b(o, r[3], r[4]), b(G, r[5], r[6]), W, X);
      }
      m.exports = function(W, h, r) {
        var L = [], u = [], V = [0, 0];
        return W.forEach(function(c, n, e) {
          if (c[0] === "M")
            t(V, c.slice(1)), u.length > 0 && (L.push(u), u = []);
          else if (c[0] === "C")
            y(u, h, V, c), b(V, c[5], c[6]);
          else
            throw new Error("illegal type in SVG: " + c[0]);
        }), u.length > 0 && L.push(u), L.map(function(c) {
          return s(c, r || 0);
        });
      };
    },
    /* 47 */
    /***/
    function(m, d, l) {
      m.exports = l(48)();
    },
    /* 48 */
    /***/
    function(m, d) {
      function l(t) {
        return [t[0], t[1]];
      }
      function i(t, s) {
        return [t, s];
      }
      m.exports = function(s) {
        s = s || {};
        var b = typeof s.recursion == "number" ? s.recursion : 8, Z = typeof s.epsilon == "number" ? s.epsilon : 11920929e-14, o = typeof s.pathEpsilon == "number" ? s.pathEpsilon : 1, G = typeof s.angleEpsilon == "number" ? s.angleEpsilon : 0.01, y = s.angleTolerance || 0, X = s.cuspLimit || 0;
        return function(L, u, V, c, n, e) {
          e || (e = []), n = typeof n == "number" ? n : 1;
          var a = o / n;
          return a *= a, W(L, u, V, c, e, a), e;
        };
        function W(r, L, u, V, c, n) {
          c.push(l(r));
          var e = r[0], a = r[1], Y = L[0], R = L[1], C = u[0], N = u[1], I = V[0], J = V[1];
          h(e, a, Y, R, C, N, I, J, c, n, 0), c.push(l(V));
        }
        function h(r, L, u, V, c, n, e, a, Y, R, C) {
          if (!(C > b)) {
            var N = Math.PI, I = (r + u) / 2, J = (L + V) / 2, T = (u + c) / 2, K = (V + n) / 2, S = (c + e) / 2, H = (n + a) / 2, w = (I + T) / 2, P = (J + K) / 2, B = (T + S) / 2, D = (K + H) / 2, z = (w + B) / 2, U = (P + D) / 2;
            if (C > 0) {
              var O = e - r, ll = a - L, _ = Math.abs((u - e) * ll - (V - a) * O), Zl = Math.abs((c - e) * ll - (n - a) * O), $, ol;
              if (_ > Z && Zl > Z) {
                if ((_ + Zl) * (_ + Zl) <= R * (O * O + ll * ll)) {
                  if (y < G) {
                    Y.push(i(z, U));
                    return;
                  }
                  var al = Math.atan2(n - V, c - u);
                  if ($ = Math.abs(al - Math.atan2(V - L, u - r)), ol = Math.abs(Math.atan2(a - n, e - c) - al), $ >= N && ($ = 2 * N - $), ol >= N && (ol = 2 * N - ol), $ + ol < y) {
                    Y.push(i(z, U));
                    return;
                  }
                  if (X !== 0) {
                    if ($ > X) {
                      Y.push(i(u, V));
                      return;
                    }
                    if (ol > X) {
                      Y.push(i(c, n));
                      return;
                    }
                  }
                }
              } else if (_ > Z) {
                if (_ * _ <= R * (O * O + ll * ll)) {
                  if (y < G) {
                    Y.push(i(z, U));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(n - V, c - u) - Math.atan2(V - L, u - r)), $ >= N && ($ = 2 * N - $), $ < y) {
                    Y.push(i(u, V)), Y.push(i(c, n));
                    return;
                  }
                  if (X !== 0 && $ > X) {
                    Y.push(i(u, V));
                    return;
                  }
                }
              } else if (Zl > Z) {
                if (Zl * Zl <= R * (O * O + ll * ll)) {
                  if (y < G) {
                    Y.push(i(z, U));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(a - n, e - c) - Math.atan2(n - V, c - u)), $ >= N && ($ = 2 * N - $), $ < y) {
                    Y.push(i(u, V)), Y.push(i(c, n));
                    return;
                  }
                  if (X !== 0 && $ > X) {
                    Y.push(i(c, n));
                    return;
                  }
                }
              } else if (O = z - (r + e) / 2, ll = U - (L + a) / 2, O * O + ll * ll <= R) {
                Y.push(i(z, U));
                return;
              }
            }
            h(r, L, I, J, w, P, z, U, Y, R, C + 1), h(z, U, B, D, S, H, e, a, Y, R, C + 1);
          }
        }
      };
    },
    /* 49 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "create", function() {
        return s;
      }), l.d(d, "clone", function() {
        return t;
      }), l.d(d, "copy", function() {
        return b;
      }), l.d(d, "scaleAndAdd", function() {
        return Z;
      }), l.d(d, "dot", function() {
        return o;
      }), l.d(d, "rotate", function() {
        return G;
      }), l.d(d, "cross", function() {
        return y;
      }), l.d(d, "sub", function() {
        return X;
      }), l.d(d, "add", function() {
        return W;
      }), l.d(d, "computeMiter", function() {
        return u;
      }), l.d(d, "normal", function() {
        return V;
      }), l.d(d, "direction", function() {
        return c;
      });
      var i = l(1);
      l(1).glMatrix.setMatrixArrayType(Array);
      function t(n) {
        return [n[0], n[1]];
      }
      function s() {
        return [0, 0];
      }
      const b = i.vec2.copy, Z = i.vec2.scaleAndAdd, o = i.vec2.dot, G = i.vec2.rotate, y = i.vec2.cross, X = i.vec2.sub, W = i.vec2.add, h = i.vec2.normalize, r = i.vec2.set, L = s();
      function u(n, e, a, Y, R) {
        W(n, a, Y), h(n, n), r(e, -n[1], n[0]), r(L, -a[1], a[0]);
        const C = R / o(e, L);
        return Math.abs(C);
      }
      function V(n, e) {
        return r(n, -e[1], e[0]), n;
      }
      function c(n, e, a) {
        return X(n, e, a), h(n, n), n;
      }
    },
    /* 50 */
    /***/
    function(m, d, l) {
      var i = l(51), t = l(52);
      m.exports = function(b, Z) {
        return b = i(b, Z), b = t(b, Z), b;
      }, m.exports.radialDistance = i, m.exports.douglasPeucker = t;
    },
    /* 51 */
    /***/
    function(m, d) {
      function l(i, t) {
        var s = i[0] - t[0], b = i[1] - t[1];
        return s * s + b * b;
      }
      m.exports = function(t, s) {
        if (t.length <= 1)
          return t;
        s = typeof s == "number" ? s : 1;
        for (var b = s * s, Z = t[0], o = [Z], G, y = 1, X = t.length; y < X; y++)
          G = t[y], l(G, Z) > b && (o.push(G), Z = G);
        return Z !== G && o.push(G), o;
      };
    },
    /* 52 */
    /***/
    function(m, d) {
      function l(t, s, b) {
        var Z = s[0], o = s[1], G = b[0] - Z, y = b[1] - o;
        if (G !== 0 || y !== 0) {
          var X = ((t[0] - Z) * G + (t[1] - o) * y) / (G * G + y * y);
          X > 1 ? (Z = b[0], o = b[1]) : X > 0 && (Z += G * X, o += y * X);
        }
        return G = t[0] - Z, y = t[1] - o, G * G + y * y;
      }
      function i(t, s, b, Z, o) {
        for (var G = Z, y, X = s + 1; X < b; X++) {
          var W = l(t[X], t[s], t[b]);
          W > G && (y = X, G = W);
        }
        G > Z && (y - s > 1 && i(t, s, y, Z, o), o.push(t[y]), b - y > 1 && i(t, y, b, Z, o));
      }
      m.exports = function(s, b) {
        if (s.length <= 1)
          return s;
        b = typeof b == "number" ? b : 1;
        var Z = b * b, o = s.length - 1, G = [s[0]];
        return i(s, 0, o, Z, G), G.push(s[o]), G;
      };
    },
    /* 53 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "getTotalLength", function() {
        return t;
      }), l.d(d, "getPointAtLength", function() {
        return b;
      }), l.d(d, "getDashContours", function() {
        return Z;
      });
      var i = l(54);
      l(1).glMatrix.setMatrixArrayType(Array);
      function t(o) {
        if (o.totalLength != null)
          return o.totalLength;
        let G = 0;
        return o.forEach((y) => {
          let X = y[0];
          for (let W = 1; W < y.length; W++) {
            const h = y[W];
            G += Object(i.distance)(X, h), X = h;
          }
        }), o.totalLength = G, G;
      }
      function s(o, G, y = !0) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (G <= 0)
          throw new TypeError("Length must > 0");
        const X = t(o);
        if (G >= X) {
          const h = o[o.length - 1], r = h[h.length - 2], L = h[h.length - 1], u = Math.atan2(L[1] - r[1], L[0] - r[0]);
          return {
            current: o.map((V) => [...V]),
            point: {
              x: L[0],
              y: L[1],
              angle: u
            }
          };
        }
        const W = [];
        for (let h = 0; h < o.length; h++) {
          W[h] = [];
          const r = o[h];
          let L = r[0];
          for (let u = 1; u < r.length; u++) {
            const V = r[u], c = Object(i.distance)(L, V);
            if (G < c) {
              const n = G / c, e = Math.atan2(V[1] - L[1], V[0] - L[0]), a = {
                x: L[0] * (1 - n) + V[0] * n,
                y: L[1] * (1 - n) + V[1] * n,
                angle: e
              };
              if (W[h].push(L), G > 0 && W[h].push([a.x, a.y]), !y)
                return {
                  current: W,
                  point: a
                };
              const Y = [], R = h;
              for (; h < o.length; h++) {
                for (Y[h - R] = [], h === R && Y[0].push([a.x, a.y]); u < r.length; u++)
                  Y[h - R].push(r[u]);
                u = 0;
              }
              return {
                current: W,
                point: a,
                rest: Y
              };
            }
            G -= c, W[h].push(L), L = V;
          }
        }
      }
      function b(o, G) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (o.length <= 0)
          return {
            x: 0,
            y: 0,
            angle: 0
          };
        if (G <= 0) {
          const y = o[0][0], X = o[0][1], W = Math.atan2(X[1] - y[1], X[0] - y[0]);
          return {
            x: y[0],
            y: y[1],
            angle: W
          };
        }
        return s(o, G, !1).point;
      }
      function Z(o, G, y) {
        let X = 0, W = G[0], h = o;
        const r = [], L = G.length;
        if (y > 0) {
          do
            y -= G[X % L], X++;
          while (y > 0);
          y < 0 && (W = -y, X--);
        } else if (y < 0) {
          X = -1;
          do
            y += G[X % L + L - 1], X--;
          while (y < 0);
          y >= 0 && (X++, W = G[X % L + L - 1] - y);
        }
        do {
          const u = s(h, W);
          h = u.rest, ++X % 2 && r.push(...u.current);
          let V = X % L;
          V < 0 && (V += L), W = G[V];
        } while (h);
        return r;
      }
    },
    /* 54 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "normalize", function() {
        return i;
      }), l.d(d, "distance", function() {
        return t;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i([s, b, Z], o, G, y) {
        return s = s * 2 / o - 1, b = 1 - b * 2 / G, Number.isFinite(y) ? (Z = Z * 2 / y - 1, [s, b, Z]) : [s, b];
      }
      function t([s, b, Z = 0], [o, G, y = 0]) {
        return Math.hypot(o - s, G - b, y - Z);
      }
    },
    /* 55 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "getPoint", function() {
        return t;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const i = Math.PI * 2;
      function t(s, b, Z, o, G) {
        G %= i, G < 0 && (G += i);
        const y = Math.tan(G);
        if (Math.abs(y) < 1e5) {
          const X = b - y * s, W = 1 / Z ** 2 + y ** 2 / o ** 2;
          let h = -1;
          (G <= Math.PI / 2 || G > 3 * Math.PI / 2) && (h = 1);
          const r = h * Math.sqrt(1 / W) + s, L = y * r + X;
          return [r, L];
        }
        return G < Math.PI ? [s, b + o] : [s, b - o];
      }
    },
    /* 56 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return j;
      });
      var i = l(1), t = l(42), s = /* @__PURE__ */ l.n(t), b = l(57), Z = l(28), o = l(24), G = l(30), y = l(59), X = l(53), W = l(60), h = /* @__PURE__ */ l.n(W), r = l(46), L = /* @__PURE__ */ l.n(r), u = l(31), V = l(40), c = l(21);
      l(1).glMatrix.setMatrixArrayType(Array);
      function n(A, M) {
        if (A == null)
          return {};
        var Q = e(A, M), p, x;
        if (Object.getOwnPropertySymbols) {
          var F = Object.getOwnPropertySymbols(A);
          for (x = 0; x < F.length; x++)
            p = F[x], !(M.indexOf(p) >= 0) && Object.prototype.propertyIsEnumerable.call(A, p) && (Q[p] = A[p]);
        }
        return Q;
      }
      function e(A, M) {
        if (A == null)
          return {};
        var Q = {}, p = Object.keys(A), x, F;
        for (F = 0; F < p.length; F++)
          x = p[F], !(M.indexOf(x) >= 0) && (Q[x] = A[x]);
        return Q;
      }
      const a = Symbol("mesh"), Y = Symbol("contours"), R = Symbol("stroke"), C = Symbol("fill"), N = Symbol("strokeColor"), I = Symbol("fillColor"), J = Symbol("transform"), T = Symbol("invertTransform"), K = Symbol("uniforms"), S = Symbol("texOptions"), H = Symbol("blend"), w = Symbol("applyTexture"), P = Symbol("applyTransform"), B = Symbol("applyGradientTransform"), D = Symbol("applyProgram"), z = Symbol("gradient"), U = Symbol("filter"), O = Symbol("opacity"), ll = Symbol("program"), _ = Symbol("attributes"), Zl = Symbol("pass"), $ = Symbol("clipContext"), ol = Symbol("applyClipPath");
      function al(A, M) {
        const [Q, p] = [A[1][0] - A[0][0], A[1][1] - A[0][1]], x = [];
        for (let F = 0; F < M.length; F++) {
          const v = M[F], f = [(v[0] - A[0][0]) / Q, 1 - (v[1] - A[0][1]) / p];
          x.push(f);
        }
        return x;
      }
      function g([A, M], [Q, p, x, F], {
        scale: v
      }) {
        return v || (A /= x, M = 1 - M / F, A -= Q, M += p), [A, M, 0];
      }
      function k(A, M, Q) {
        const p = L()(A, M, Q);
        return p.path = A, p.simplify = Q, p.scale = M, p;
      }
      class j {
        constructor(M) {
          this[R] = null, this[C] = null, this[J] = [1, 0, 0, 1, 0, 0], this[O] = 1, this[K] = {}, this[U] = [], this[H] = null, this[S] = {}, this.contours = M.contours, this[ll] = null, this[_] = {}, this[Zl] = [];
        }
        get contours() {
          return this[Y];
        }
        set contours(M) {
          this[a] = null, this[Y] = M;
          const Q = M.scale;
          this.transformScale / Q > 1.5 && this.accurate(this.transformScale);
        }
        setProgram(M) {
          this[ll] = M, this[a] && this[D](M);
        }
        get program() {
          return this[ll];
        }
        setAttribute(M, Q) {
          Q == null ? delete this[_][M] : this[_][M] = Q;
        }
        getOpacity() {
          return this[O];
        }
        setOpacity(M) {
          if (M < 0 || M > 1)
            throw new TypeError("Invalid opacity value.");
          this[a] && this[a].positions.forEach((Q) => {
            Q[2] = 1 / Q[2] > 0 ? M : -M;
          }), this[O] = M;
        }
        setClipPath(M) {
          this.clipPath = M, this[K].u_clipSampler && this[K].u_clipSampler.delete(), this.setUniforms({
            u_clipSampler: null
          }), this[a] && delete this[a].attributes.a_clipUV, M && this[a] && this[ol]();
        }
        [ol]() {
          if (this.clipPath) {
            this[$] || (this[$] = c.default.createCanvas(1, 1));
            const [[M, Q], [p, x]] = this.boundingBox;
            p && x && (this[$].width = p - M, this[$].height = x - Q);
            const F = this[$].getContext("2d"), v = new Path2D(this.clipPath);
            F.clearRect(0, 0, this[$].width, this[$].height), F.save(), F.translate(-M, -Q), F.fillStyle = "white", F.fill(v), F.restore(), this[a].clipPath = this[$];
            const f = al(this.boundingBox, this[a].position0);
            this[a].attributes.a_clipUV = f;
          }
        }
        getPointAtLength(M) {
          return Object(X.getPointAtLength)(this[Y], M);
        }
        getTotalLength() {
          return Object(X.getTotalLength)(this[Y]);
        }
        get blend() {
          return this[H] == null ? "auto" : this[H];
        }
        set blend(M) {
          this[H] = M, this[a] && (this[a].enableBlend = this.enableBlend);
        }
        get boundingBox() {
          if (this[a] && this[a].boundingBox)
            return this[a].boundingBox;
          const M = this.meshData;
          if (M) {
            const Q = M.position0;
            if (Q.length)
              M.boundingBox = s()(Q);
            else
              return [[0, 0], [0, 0]];
            return M.boundingBox;
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const M = this.boundingBox;
          return M ? [0.5 * (M[0][0] + M[1][0]), 0.5 * (M[0][1] + M[1][1])] : [0, 0];
        }
        get fillRule() {
          return this[C] ? this[C].rule : "nonzero";
        }
        get lineWidth() {
          return this[R] ? this[R].lineWidth : 0;
        }
        get lineCap() {
          return this[R] ? this[R].lineCap : "";
        }
        get lineJoin() {
          return this[R] ? this[R].lineJoin : "";
        }
        get miterLimit() {
          return this[R] ? this[R].miterLimit : 0;
        }
        get strokeStyle() {
          return this[N] && this[N][3] !== 0 ? Object(o.default)(this[N]) : "";
        }
        get lineDash() {
          return this[R] ? this[R].lineDash : null;
        }
        get lineDashOffset() {
          return this[R] ? this[R].lineDashOffset : 0;
        }
        get fillStyle() {
          return this[I] && this[I][3] !== 0 ? Object(o.default)(this[I]) : "";
        }
        get gradient() {
          return this[z];
        }
        get texture() {
          return this[K].u_texSampler ? {
            image: this[K].u_texSampler._img,
            options: this[S]
          } : null;
        }
        get enableBlend() {
          return this[H] === !0 || this[H] === !1 ? this[H] : this[O] < 1 || this[N] != null && this[N][3] < 1 || this[I] != null && this[I][3] < 1 || this[K].u_colorMatrix != null && this[K].u_colorMatrix[18] < 1 || this[K].u_radialGradientVector != null || this.beforeRender || this.afterRender;
        }
        get filterCanvas() {
          return /blur|drop-shadow|url/.test(this.filter);
        }
        get filter() {
          return this[U].join(" ");
        }
        get transformMatrix() {
          return this[J];
        }
        get invertMatrix() {
          if (!this[T]) {
            const M = i.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this[J]);
            this[T] = M;
          }
          return this[T];
        }
        get transformScale() {
          const M = this[J];
          return Math.max(Math.hypot(M[0], M[1]), Math.hypot(M[2], M[3]));
        }
        get uniforms() {
          return this[K];
        }
        get pass() {
          return this[Zl];
        }
        [D](M) {
          const Q = this[_], p = this[a].position0, x = Object.entries(M._attribute);
          for (let F = 0; F < x.length; F++) {
            const [v, f] = x[F];
            if (v !== "a_color" && v !== "a_sourceRect" && f !== "ignored") {
              const E = Q[v];
              if (v === "uv" && !E) {
                const q = this[a].boundingBox || s()(p);
                this[a].attributes[v] = al(q, p);
              } else {
                this[a].attributes[v] = [];
                for (let q = 0; q < p.length; q++) {
                  const dl = p[q];
                  this[a].attributes[v].push(E ? E(dl, F, p) : Array(f.size).fill(0));
                }
              }
            }
          }
        }
        // {stroke, fill}
        get meshData() {
          if (this._updateMatrix && this.transformScale / this.contours.scale > 1.5 && this.accurate(this.transformScale), !this[a]) {
            !this[C] && !this[R] && this.setFill();
            const M = this[Y], Q = {};
            if (M && M.length) {
              if (this[C])
                try {
                  const F = h()(M, this[C]);
                  F.positions = F.positions.map((v) => (v.push(this[O]), v)), F.attributes = {
                    a_color: Array.from({
                      length: F.positions.length
                    }).map(() => this[I].map((v) => Math.round(255 * v)))
                    // a_sourceRect: Array.from({length: mesh.positions.length}).map(() => [0, 0, 0, 0]),
                  }, Q.fill = F;
                } catch {
                }
              if (this[R]) {
                const F = this[R].lineDash;
                let v = M;
                if (F) {
                  const E = this[R].lineDashOffset;
                  v = Object(X.getDashContours)(M, F, E);
                }
                const f = v.map((E, q) => {
                  const dl = E.length > 1 && i.vec2.equals(E[0], E[E.length - 1]), tl = this[R].build(E, dl);
                  return h()([tl]);
                });
                f.forEach((E) => {
                  E.positions = E.positions.map((q) => (q.push(-this[O]), q)), E.attributes = {
                    a_color: Array.from({
                      length: E.positions.length
                    }).map(() => this[N].map((q) => Math.round(255 * q)))
                  };
                }), Q.stroke = Object(Z.default)(f);
              }
            }
            const p = Object(Z.default)([Q.fill, Q.stroke]);
            p.fillPointCount = Q.fill ? Q.fill.positions.length : 0, p.enableBlend = this.enableBlend, p.position0 = p.positions.map(([F, v, f]) => [F, v, f]), p.uniforms = this[K], this[a] = p, this[K].u_texSampler && this[w](p, this[S]);
            const x = this[J];
            Object(y.isUnitTransform)(x) || (this[P](p, x), this[K].u_radialGradientVector && this[B]()), this.clipPath && this[ol](), this[ll] && this[D](this[ll]);
          }
          return this._updateMatrix && (this[a].matrix = this[J], this[P](this[a], this[J]), this[K].u_radialGradientVector && this[B]()), this[a];
        }
        [P](M, Q) {
          const {
            positions: p,
            position0: x
          } = M;
          for (let F = 0; F < p.length; F++) {
            const [v, f] = x[F], E = p[F];
            E[0] = v * Q[0] + f * Q[2] + Q[4], E[1] = v * Q[1] + f * Q[3] + Q[5];
          }
          this._updateMatrix = !1;
        }
        [B]() {
          const M = this[J], Q = [...this._radialGradientVector];
          if (Q) {
            const [p, x, , F, v] = Q;
            Q[0] = p * M[0] + x * M[2] + M[4], Q[1] = p * M[1] + x * M[3] + M[5], Q[3] = F * M[0] + v * M[2] + M[4], Q[4] = F * M[1] + v * M[3] + M[5], this[K].u_radialGradientVector = Q;
          }
        }
        [w](M, Q) {
          function p(q, dl) {
            return q == null && dl == null ? !0 : q == null || dl == null ? !1 : q[0] === dl[0] && q[1] === dl[1] && q[2] === dl[2] && q[3] === dl[3];
          }
          const x = this[K].u_texSampler;
          if (!x)
            return;
          const {
            width: F,
            height: v
          } = x._img, f = Q.srcRect;
          let E = Q.rect || [0, 0];
          if (Q.rotated && (E = [-E[1], E[0], E[3], E[2]]), E[2] == null && (E[2] = f ? f[2] : F), E[3] == null && (E[3] = f ? f[3] : v), Q.hidden)
            M.textureCoord = M.positions.map(() => [-1, -1, -1]);
          else if (!M.textureCoord || !p(this[S].rect, Q.rect) || this[S].hidden !== Q.hidden || this[S].rotated !== Q.rotated) {
            let q = null;
            Q.rotated && (q = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), i.mat2d.fromValues(1, 0, 0, 1, 0, 0), 0.5 * Math.PI), q = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), q, [0, -E[2]])), M.textureCoord = M.position0.map(([dl, tl, ml]) => {
              if (1 / ml > 0) {
                if (Q.rotated) {
                  const cl = dl * q[0] + tl * q[2] + q[4], sl = dl * q[1] + tl * q[3] + q[5];
                  [dl, tl] = [cl, sl];
                }
                const el = g([dl, tl], [E[0] / E[2], E[1] / E[3], E[2], E[3]], Q);
                return Q.repeat && (el[2] = 1), el;
              }
              return [-1, -1, -1];
            });
          }
          if (f) {
            const q = [f[0] / F, f[1] / v, f[2] / F, f[3] / v];
            M.attributes.a_sourceRect = M.positions.map(() => [...q]);
          } else
            M.attributes.a_sourceRect = M.positions.map(() => [0, 0, 0, 0]);
        }
        accurate(M) {
          if (!this.contours)
            return;
          if (this.contours.path) {
            const p = this.contours.simplify, x = k(this.contours.path, 2 * M, p);
            this[a] = null, this[Y] = x;
          }
        }
        canIgnore() {
          const M = this[R] == null || this[R].lineWidth === 0 || this[N][3] === 0, Q = this[C] == null || this[I][3] === 0, p = this[K].u_radialGradientVector == null, x = this[K].u_texSampler == null;
          return this[O] === 0 || this[ll] == null && M && Q && p && x && !this.beforeRender && !this.afterRender;
        }
        // join: 'miter' or 'bevel'
        // cap: 'butt' or 'square'
        // lineDash: null
        // lineDashOffset: 0
        setStroke({
          thickness: M = 1,
          cap: Q = "butt",
          join: p = "miter",
          miterLimit: x = 10,
          color: F = [0, 0, 0, 0],
          lineDash: v = null,
          lineDashOffset: f = 0,
          roundSegments: E = 20
        } = {}) {
          return this[a] = null, this[R] = new b.default({
            lineWidth: M,
            lineCap: Q,
            lineJoin: p,
            miterLimit: x,
            roundSegments: E
          }), typeof F == "string" && (F = Object(u.default)(F)), this[N] = F, this[R].lineDash = v, this[R].lineDashOffset = f, this;
        }
        setFill({
          rule: M = this.fillRule,
          color: Q = [0, 0, 0, 0]
        } = {}) {
          return this[a] = null, this[C] = {
            rule: M
          }, typeof Q == "string" && (Q = Object(u.default)(Q)), this[I] = Q, this;
        }
        /**
          options: {
            scale: false,
            repeat: false,
            rotated: false,
            rect: [10, 10],
            srcRect: [...],
            hidden: false,
          }
         */
        setTexture(M, Q = {}) {
          if (M && M.image) {
            const {
              image: p,
              rect: x
            } = M;
            if (M = p, Q.rect)
              for (let F = 0; F < Q.rect.length; F++)
                x[F] = Q.rect[F];
            Q.rect = x;
          }
          return this[C] || this.setFill(), this.setUniforms({
            u_texSampler: M
          }), this[a] && this[w](this[a], Q), this[S] = Q, this;
        }
        setCircularGradient({
          vector: M,
          colors: Q,
          type: p = "fill"
        } = {}) {
          if (M.length !== 3)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: M,
            colors: Q,
            type: p
          });
        }
        setLinearGradient({
          vector: M,
          colors: Q,
          type: p = "fill"
        } = {}) {
          if (M.length !== 4)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: M,
            colors: Q,
            type: p
          });
        }
        setRadialGradient({
          vector: M,
          colors: Q,
          type: p = "fill"
        } = {}) {
          if (M.length !== 6)
            throw new TypeError("Invalid radialGradient.");
          this.setGradient({
            vector: M,
            colors: Q,
            type: p
          });
        }
        /**
          vector: [x0, y0, r0, x1, y1, r1],
          colors: [{offset:0, color}, {offset:1, color}, ...],
         */
        setGradient({
          vector: M,
          colors: Q,
          type: p = "fill"
        } = {}) {
          Q = Q.map(({
            offset: v,
            color: f
          }) => (typeof f == "string" && (f = Object(u.default)(f)), {
            offset: v,
            color: f
          })), this[z] = this[z] || {}, this[z][p] = {
            vector: M,
            colors: Q
          }, Q.sort((v, f) => v.offset - f.offset);
          const x = [];
          Q.forEach(({
            offset: v,
            color: f
          }) => {
            x.push(v, ...f);
          });
          let F;
          if (M.length === 4 ? F = [M[0], M[1], 0, M[2], M[3], 0] : F = [...M], x.length < 40 && x.push(-1), x.length > 40)
            throw new Error("Too many colors, should be less than 8 colors");
          return this._radialGradientVector = F, this[K].u_colorSteps = x, p === "fill" ? this[K].u_gradientType = 1 : this[K].u_gradientType = 0, this[B](), this;
        }
        setUniforms(M = {}) {
          return Object.assign(this[K], M), this;
        }
        setTransform(...M) {
          const Q = this[J];
          return i.mat2d.equals(M, Q) || (this[J] = M, delete this[T], this._updateMatrix = !0), this;
        }
        transform(...M) {
          const Q = this[J];
          return this[J] = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), Q, M), delete this[T], this._updateMatrix = !0, this;
        }
        translate(M, Q) {
          let p = i.mat2d.create();
          return p = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), p, [M, Q]), this.transform(...p);
        }
        rotate(M, [Q, p] = [0, 0]) {
          let x = i.mat2d.create();
          return x = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), x, [Q, p]), x = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), x, M), x = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), x, [-Q, -p]), this.transform(...x);
        }
        scale(M, Q = M, [p, x] = [0, 0]) {
          let F = i.mat2d.create();
          return F = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [p, x]), F = i.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), F, [M, Q]), F = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [-p, -x]), this.transform(...F);
        }
        skew(M, Q = M, [p, x] = [0, 0]) {
          let F = i.mat2d.create();
          return F = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [p, x]), F = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), F, i.mat2d.fromValues(1, Math.tan(Q), Math.tan(M), 1, 0, 0)), F = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [-p, -x]), this.transform(...F);
        }
        clearFilter() {
          return this.setColorTransform(null), this[U].length = 0, this;
        }
        setColorTransform(...M) {
          return M[0] === null ? this.setUniforms({
            u_filterFlag: 0,
            u_colorMatrix: 0
          }) : this.setUniforms({
            u_filterFlag: 1,
            u_colorMatrix: M
          }), this;
        }
        // apply linear color transform
        transformColor(...M) {
          let Q = this.uniforms.u_colorMatrix;
          return Q ? Q = Object(G.multiply)(Q, M) : Q = M, this.setColorTransform(...Q), this;
        }
        blur(M) {
          return this[U].push(`blur(${M}px)`), this;
        }
        brightness(M = 1) {
          return this[U].push(`brightness(${100 * M}%)`), this.transformColor(...Object(G.brightness)(M));
        }
        contrast(M = 1) {
          return this[U].push(`contrast(${100 * M}%)`), this.transformColor(...Object(G.contrast)(M));
        }
        dropShadow(M, Q, p = 0, x = [0, 0, 0, 1]) {
          return Array.isArray(x) && (x = Object(o.default)(x)), this[U].push(`drop-shadow(${M}px ${Q}px ${p}px ${x})`), this;
        }
        grayscale(M = 1) {
          return this[U].push(`grayscale(${100 * M}%)`), this.transformColor(...Object(G.grayscale)(M));
        }
        // https://github.com/phoboslab/WebGLImageFilter/blob/master/webgl-image-filter.js#L371
        hueRotate(M = 0) {
          return this[U].push(`hue-rotate(${M}deg)`), this.transformColor(...Object(G.hueRotate)(M));
        }
        invert(M = 1) {
          return this[U].push(`invert(${100 * M}%)`), this.transformColor(...Object(G.invert)(M));
        }
        opacity(M = 1) {
          return this[U].push(`opacity(${100 * M}%)`), this.transformColor(...Object(G.opacity)(M));
        }
        saturate(M = 1) {
          return this[U].push(`saturate(${100 * M}%)`), this.transformColor(...Object(G.saturate)(M));
        }
        sepia(M = 1) {
          return this[U].push(`sepia(${100 * M}%)`), this.transformColor(...Object(G.sepia)(M));
        }
        url(M) {
          return this[U].push(`url(${M})`), this;
        }
        isPointCollision(M, Q, p = "both") {
          const x = this.meshData, {
            positions: F,
            cells: v
          } = x, f = this.invertMatrix, E = f[0] * M + f[2] * Q + f[4], q = f[1] * M + f[3] * Q + f[5], dl = this.boundingBox;
          if (E < dl[0][0] || E > dl[1][0] || q < dl[0][1] || q > dl[1][1])
            return !1;
          function tl([ml, el], [cl, sl], [nl, Gl]) {
            const Wl = nl - cl, Xl = Gl - sl, yl = ((ml - cl) * Wl + (el - sl) * Xl) / (Wl ** 2 + Xl ** 2);
            return yl >= 0 && yl <= 1;
          }
          for (let ml = 0; ml < v.length; ml++) {
            const el = v[ml];
            if (p === "fill" && el[0] >= x.fillPointCount)
              break;
            if (p === "stroke" && el[0] < x.fillPointCount)
              continue;
            const [[cl, sl], [nl, Gl], [Wl, Xl]] = el.map((Rl) => F[Rl]), yl = Math.sign((M - cl) * (Gl - sl) - (nl - cl) * (Q - sl));
            if (yl === 0 && tl([M, Q], [cl, sl], [nl, Gl]))
              return !0;
            const Cl = Math.sign((M - nl) * (Xl - Gl) - (Wl - nl) * (Q - Gl));
            if (Cl === 0 && tl([M, Q], [nl, Gl], [Wl, Xl]))
              return !0;
            const rl = Math.sign((M - Wl) * (sl - Xl) - (cl - Wl) * (Q - Xl));
            if (rl === 0 && tl([M, Q], [Wl, Xl], [cl, sl]) || yl === 1 && Cl === 1 && rl === 1 || yl === -1 && Cl === -1 && rl === -1)
              return !0;
          }
          return !1;
        }
        isPointInFill(M, Q) {
          return this.isPointCollision(M, Q, "fill");
        }
        isPointInStroke(M, Q) {
          return this.isPointCollision(M, Q, "stroke");
        }
        addPass(M, Q = {}) {
          let {
            width: p,
            height: x
          } = Q, F = n(Q, ["width", "height"]);
          const v = new V.default();
          v.rect(0, 0, p, x);
          const f = new j(v, {
            width: p,
            height: x
          });
          f.setUniforms(F), f.setProgram(M), this[Zl].push(f);
        }
      }
    },
    /* 57 */
    /***/
    function(m, d, l) {
      l.r(d);
      var i = l(58);
      l(1).glMatrix.setMatrixArrayType(Array), d.default = i.Stroke;
    },
    /* 58 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "Stroke", function() {
        return y;
      });
      var i = l(49);
      l(1).glMatrix.setMatrixArrayType(Array);
      const t = Object(i.create)(), s = Object(i.create)(), b = Object(i.create)(), Z = Object(i.create)(), o = Object(i.create)(), G = 1e20;
      class y {
        constructor({
          lineWidth: L = 1,
          lineJoin: u = "miter",
          miterLimit: V = 10,
          lineCap: c = "butt",
          roundSegments: n = 20
        } = {}) {
          this.lineWidth = L, this.lineJoin = u, this.miterLimit = V, this.lineCap = c, this.roundSegments = n, this._normal = null;
        }
        build(L, u = !1) {
          let V = L.length;
          if (L = [...L], V < 2)
            return L;
          u && ((L[0][0] !== L[V - 1][0] || L[0][1] !== L[V - 1][1]) && L.push([...L[0]]), L.push([...L[1]])), V = L.length, this._normal = null;
          const c = {
            left: [],
            right: []
          }, n = this.lineWidth / 2, e = this.lineCap;
          if (!u && e === "square") {
            Object(i.direction)(s, L[0], L[1]), Object(i.scaleAndAdd)(L[0], L[0], s, n);
            const Y = L.length - 1;
            Object(i.direction)(s, L[Y], L[Y - 1]), Object(i.scaleAndAdd)(L[Y], L[Y], s, n);
          }
          for (let Y = 1; Y < V; Y++) {
            const R = L[Y - 1], C = L[Y], N = L[Y + 1];
            this._seg(c, R, C, N, n, u);
          }
          return !u && e === "round" && h(c, this.roundSegments), [...c.left, ...c.right.reverse()];
        }
        _seg(L, u, V, c, n, e) {
          const a = this.lineJoin === "bevel", Y = this.lineJoin === "round";
          if (Object(i.direction)(s, V, u), this._normal || (this._normal = Object(i.create)(), Object(i.normal)(this._normal, s)), L.left.length || W(L, u, this._normal, n), !c)
            Object(i.normal)(this._normal, s), e ? W(L, u, this._normal, n) : W(L, V, this._normal, n);
          else {
            Object(i.direction)(b, c, V);
            let R = Object(i.computeMiter)(Z, o, s, b, n);
            R = Math.min(R, G);
            const C = Object(i.dot)(Z, this._normal) < 0 ? -1 : 1;
            let N = a || Y;
            if (!N && this.lineJoin === "miter" && R / n > this.miterLimit && (N = !0), N) {
              Object(i.scaleAndAdd)(t, V, this._normal, -n * C), X(L, t, C);
              let I = 1 / 0;
              u && (I = Math.min(I, Math.hypot(V[0] - u[0], V[1] - u[1]))), c && (I = Math.min(I, Math.hypot(c[0] - V[0], c[1] - V[1])));
              const J = Math.max(n, Math.min(R, I));
              if (Object(i.scaleAndAdd)(t, V, o, J * C), X(L, t, -C), c)
                if (Object(i.normal)(t, b), Object(i.copy)(this._normal, t), Object(i.scaleAndAdd)(t, V, t, -n * C), Y) {
                  const T = Object(i.clone)(t), K = C > 0 ? L.left[L.left.length - 1] : L.right[L.right.length - 1], S = Object(i.clone)(V), H = Object(i.sub)(Object(i.create)(), K, S), w = Object(i.sub)(Object(i.create)(), T, S), P = Math.PI / this.roundSegments;
                  for (let B = 0; B < this.roundSegments && (Object(i.rotate)(H, H, [0, 0], C * P), Math.sign(Object(i.cross)(t, H, w)[2]) === C); B++)
                    Object(i.add)(t, H, S), X(L, t, C);
                  X(L, T, C);
                } else
                  X(L, t, C);
            } else
              W(L, V, o, R), Object(i.copy)(this._normal, o);
          }
        }
      }
      function X(r, L, u) {
        u > 0 ? r.left.push(Object(i.clone)(L)) : r.right.push(Object(i.clone)(L));
      }
      function W(r, L, u, V, c = -1) {
        Object(i.scaleAndAdd)(t, L, u, -V), X(r, t, -c), Object(i.scaleAndAdd)(t, L, u, V), X(r, t, c);
      }
      function h({
        left: r,
        right: L
      }, u) {
        const V = Object(i.create)(), c = Object(i.create)();
        let n = r[0], e = L[0], a = [0.5 * (n[0] + e[0]), 0.5 * (n[1] + e[1])];
        Object(i.sub)(c, n, a);
        for (let Y = 1; Y <= u; Y++) {
          const R = -1 * Math.PI * Y / u;
          Object(i.rotate)(V, c, [0, 0], R), Object(i.add)(t, a, V), r.unshift(Object(i.clone)(t));
        }
        n = L[L.length - 1], e = r[r.length - 1], a = [0.5 * (n[0] + e[0]), 0.5 * (n[1] + e[1])], Object(i.sub)(c, n, a);
        for (let Y = 1; Y <= u; Y++) {
          const R = -1 * Math.PI * Y / u;
          Object(i.rotate)(V, c, [0, 0], R), Object(i.add)(t, a, V), L.push(Object(i.clone)(t));
        }
      }
    },
    /* 59 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "isUnitTransform", function() {
        return i;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(t) {
        return t[0] === 1 && t[1] === 0 && t[2] === 0 && t[3] === 1 && t[4] === 0 && t[5] === 0;
      }
    },
    /* 60 */
    /***/
    function(m, d, l) {
      l(1).glMatrix.setMatrixArrayType(Array);
      var i = l(61), t = l(62);
      m.exports = function(s, b) {
        if (b = b || {}, s = s.filter(function(u) {
          return u.length > 2;
        }), s.length === 0)
          return {
            positions: [],
            cells: []
          };
        typeof b.vertexSize != "number" && (b.vertexSize = s[0][0].length), s = s.map(function(u) {
          return u.reduce(function(V, c) {
            return V.concat(c);
          });
        });
        const Z = b.rule === "evenodd" ? i.WINDING_ODD : i.WINDING_NONZERO;
        for (var o = i.tesselate(t({
          contours: s,
          windingRule: Z,
          elementType: i.POLYGONS,
          polySize: 3,
          vertexSize: 2
        }, b)), G = [], y = 0; y < o.vertices.length; y += b.vertexSize) {
          var X = o.vertices.slice(y, y + b.vertexSize);
          G.push(X);
        }
        var W = [];
        for (y = 0; y < o.elements.length; y += 3) {
          var h = o.elements[y], r = o.elements[y + 1], L = o.elements[y + 2];
          W.push([h, r, L]);
        }
        return {
          positions: G,
          cells: W
        };
      };
    },
    /* 61 */
    /***/
    function(m, d, l) {
      l(1).glMatrix.setMatrixArrayType(Array);
      var i = {}, t = {};
      m.exports = i, i.WINDING_ODD = 0, i.WINDING_NONZERO = 1, i.WINDING_POSITIVE = 2, i.WINDING_NEGATIVE = 3, i.WINDING_ABS_GEQ_TWO = 4, i.POLYGONS = 0, i.CONNECTED_POLYGONS = 1, i.BOUNDARY_CONTOURS = 2, i.tesselate = function(c) {
        for (var n = c.debug || !1, e = new V(), a = 0; a < c.contours.length; a++)
          e.addContour(c.vertexSize || 2, c.contours[a]);
        return e.tesselate(c.windingRule || i.WINDING_ODD, c.elementType || i.POLYGONS, c.polySize || 3, c.vertexSize || 2, c.normal || [0, 0, 1]), {
          vertices: e.vertices,
          vertexIndices: e.vertexIndices,
          vertexCount: e.vertexCount,
          elements: e.elements,
          elementCount: e.elementCount,
          mesh: n ? e.mesh : void 0
        };
      };
      var s = function(c) {
        if (!c)
          throw "Assertion Failed!";
      };
      function b() {
        this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
      }
      function Z() {
        this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1;
      }
      function o(c) {
        this.next = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Org = null, this.Lface = null, this.activeRegion = null, this.winding = 0, this.side = c;
      }
      o.prototype = {
        get Rface() {
          return this.Sym.Lface;
        },
        set Rface(c) {
          this.Sym.Lface = c;
        },
        get Dst() {
          return this.Sym.Org;
        },
        set Dst(c) {
          this.Sym.Org = c;
        },
        get Oprev() {
          return this.Sym.Lnext;
        },
        set Oprev(c) {
          this.Sym.Lnext = c;
        },
        get Lprev() {
          return this.Onext.Sym;
        },
        set Lprev(c) {
          this.Onext.Sym = c;
        },
        get Dprev() {
          return this.Lnext.Sym;
        },
        set Dprev(c) {
          this.Lnext.Sym = c;
        },
        get Rprev() {
          return this.Sym.Onext;
        },
        set Rprev(c) {
          this.Sym.Onext = c;
        },
        get Dnext() {
          return (
            /*this.Rprev*/
            this.Sym.Onext.Sym
          );
        },
        /* 3 pointers */
        set Dnext(c) {
          this.Sym.Onext.Sym = c;
        },
        /* 3 pointers */
        get Rnext() {
          return (
            /*this.Oprev*/
            this.Sym.Lnext.Sym
          );
        },
        /* 3 pointers */
        set Rnext(c) {
          this.Sym.Lnext.Sym = c;
        }
        /* 3 pointers */
      };
      function G() {
        var c = new b(), n = new Z(), e = new o(0), a = new o(1);
        c.next = c.prev = c, c.anEdge = null, n.next = n.prev = n, n.anEdge = null, n.trail = null, n.marked = !1, n.inside = !1, e.next = e, e.Sym = a, e.Onext = null, e.Lnext = null, e.Org = null, e.Lface = null, e.winding = 0, e.activeRegion = null, a.next = a, a.Sym = e, a.Onext = null, a.Lnext = null, a.Org = null, a.Lface = null, a.winding = 0, a.activeRegion = null, this.vHead = c, this.fHead = n, this.eHead = e, this.eHeadSym = a;
      }
      G.prototype = {
        /* MakeEdge creates a new pair of half-edges which form their own loop.
        * No vertex or face structures are allocated, but these must be assigned
        * before the current edge operation is completed.
        */
        //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
        makeEdge_: function(c) {
          var n = new o(0), e = new o(1);
          c.Sym.side < c.side && (c = c.Sym);
          var a = c.Sym.next;
          return e.next = a, a.Sym.next = n, n.next = c, c.Sym.next = e, n.Sym = e, n.Onext = n, n.Lnext = e, n.Org = null, n.Lface = null, n.winding = 0, n.activeRegion = null, e.Sym = n, e.Onext = e, e.Lnext = n, e.Org = null, e.Lface = null, e.winding = 0, e.activeRegion = null, n;
        },
        /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
        * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
        * a->Onext and b->Onext are exchanged.  This can have various effects
        * depending on whether a and b belong to different face or vertex rings.
        * For more explanation see tessMeshSplice() below.
        */
        // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
        splice_: function(c, n) {
          var e = c.Onext, a = n.Onext;
          e.Sym.Lnext = n, a.Sym.Lnext = c, c.Onext = a, n.Onext = e;
        },
        /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
        * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
        * a place to insert the new vertex in the global vertex list.  We insert
        * the new vertex *before* vNext so that algorithms which walk the vertex
        * list will not see the newly created vertices.
        */
        //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
        makeVertex_: function(c, n, e) {
          var a = c;
          s(a !== null);
          var Y = e.prev;
          a.prev = Y, Y.next = a, a.next = e, e.prev = a, a.anEdge = n;
          var R = n;
          do
            R.Org = a, R = R.Onext;
          while (R !== n);
        },
        /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
        * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
        * a place to insert the new face in the global face list.  We insert
        * the new face *before* fNext so that algorithms which walk the face
        * list will not see the newly created faces.
        */
        // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
        makeFace_: function(c, n, e) {
          var a = c;
          s(a !== null);
          var Y = e.prev;
          a.prev = Y, Y.next = a, a.next = e, e.prev = a, a.anEdge = n, a.trail = null, a.marked = !1, a.inside = e.inside;
          var R = n;
          do
            R.Lface = a, R = R.Lnext;
          while (R !== n);
        },
        /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
        * and removes from the global edge list.
        */
        //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
        killEdge_: function(c) {
          c.Sym.side < c.side && (c = c.Sym);
          var n = c.next, e = c.Sym.next;
          n.Sym.next = e, e.Sym.next = n;
        },
        /* KillVertex( vDel ) destroys a vertex and removes it from the global
        * vertex list.  It updates the vertex loop to point to a given new vertex.
        */
        //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
        killVertex_: function(c, n) {
          var e = c.anEdge, a = e;
          do
            a.Org = n, a = a.Onext;
          while (a !== e);
          var Y = c.prev, R = c.next;
          R.prev = Y, Y.next = R;
        },
        /* KillFace( fDel ) destroys a face and removes it from the global face
        * list.  It updates the face loop to point to a given new face.
        */
        //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
        killFace_: function(c, n) {
          var e = c.anEdge, a = e;
          do
            a.Lface = n, a = a.Lnext;
          while (a !== e);
          var Y = c.prev, R = c.next;
          R.prev = Y, Y.next = R;
        },
        /****************** Basic Edge Operations **********************/
        /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
        * The loop consists of the two new half-edges.
        */
        //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
        makeEdge: function() {
          var c = new b(), n = new b(), e = new Z(), a = this.makeEdge_(this.eHead);
          return this.makeVertex_(c, a, this.vHead), this.makeVertex_(n, a.Sym, this.vHead), this.makeFace_(e, a, this.fHead), a;
        },
        /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
        * mesh connectivity and topology.  It changes the mesh so that
        *	eOrg->Onext <- OLD( eDst->Onext )
        *	eDst->Onext <- OLD( eOrg->Onext )
        * where OLD(...) means the value before the meshSplice operation.
        *
        * This can have two effects on the vertex structure:
        *  - if eOrg->Org != eDst->Org, the two vertices are merged together
        *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
        * In both cases, eDst->Org is changed and eOrg->Org is untouched.
        *
        * Similarly (and independently) for the face structure,
        *  - if eOrg->Lface == eDst->Lface, one loop is split into two
        *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
        * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
        *
        * Some special cases:
        * If eDst == eOrg, the operation has no effect.
        * If eDst == eOrg->Lnext, the new face will have a single edge.
        * If eDst == eOrg->Lprev, the old face will have a single edge.
        * If eDst == eOrg->Onext, the new vertex will have a single edge.
        * If eDst == eOrg->Oprev, the old vertex will have a single edge.
        */
        //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
        splice: function(c, n) {
          var e = !1, a = !1;
          if (c !== n) {
            if (n.Org !== c.Org && (a = !0, this.killVertex_(n.Org, c.Org)), n.Lface !== c.Lface && (e = !0, this.killFace_(n.Lface, c.Lface)), this.splice_(n, c), !a) {
              var Y = new b();
              this.makeVertex_(Y, n, c.Org), c.Org.anEdge = c;
            }
            if (!e) {
              var R = new Z();
              this.makeFace_(R, n, c.Lface), c.Lface.anEdge = c;
            }
          }
        },
        /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
        * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
        * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
        * the newly created loop will contain eDel->Dst.  If the deletion of eDel
        * would create isolated vertices, those are deleted as well.
        *
        * This function could be implemented as two calls to tessMeshSplice
        * plus a few calls to memFree, but this would allocate and delete
        * unnecessary vertices and faces.
        */
        //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
        delete: function(c) {
          var n = c.Sym, e = !1;
          if (c.Lface !== c.Rface && (e = !0, this.killFace_(c.Lface, c.Rface)), c.Onext === c)
            this.killVertex_(c.Org, null);
          else if (c.Rface.anEdge = c.Oprev, c.Org.anEdge = c.Onext, this.splice_(c, c.Oprev), !e) {
            var a = new Z();
            this.makeFace_(a, c, c.Lface);
          }
          n.Onext === n ? (this.killVertex_(n.Org, null), this.killFace_(n.Lface, null)) : (c.Lface.anEdge = n.Oprev, n.Org.anEdge = n.Onext, this.splice_(n, n.Oprev)), this.killEdge_(c);
        },
        /******************** Other Edge Operations **********************/
        /* All these routines can be implemented with the basic edge
        * operations above.  They are provided for convenience and efficiency.
        */
        /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
        * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
        addEdgeVertex: function(c) {
          var n = this.makeEdge_(c), e = n.Sym;
          this.splice_(n, c.Lnext), n.Org = c.Dst;
          var a = new b();
          return this.makeVertex_(a, e, n.Org), n.Lface = e.Lface = c.Lface, n;
        },
        /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
        * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
        splitEdge: function(c, n) {
          var e = this.addEdgeVertex(c), a = e.Sym;
          return this.splice_(c.Sym, c.Sym.Oprev), this.splice_(c.Sym, a), c.Dst = a.Org, a.Dst.anEdge = a.Sym, a.Rface = c.Rface, a.winding = c.winding, a.Sym.winding = c.Sym.winding, a;
        },
        /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
        * to eDst->Org, and returns the corresponding half-edge eNew.
        * If eOrg->Lface == eDst->Lface, this splits one loop into two,
        * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
        * loops are merged into one, and the loop eDst->Lface is destroyed.
        *
        * If (eOrg == eDst), the new face will have only two edges.
        * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
        * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
        */
        // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
        connect: function(c, n) {
          var e = !1, a = this.makeEdge_(c), Y = a.Sym;
          if (n.Lface !== c.Lface && (e = !0, this.killFace_(n.Lface, c.Lface)), this.splice_(a, c.Lnext), this.splice_(Y, n), a.Org = c.Dst, Y.Org = n.Org, a.Lface = Y.Lface = c.Lface, c.Lface.anEdge = Y, !e) {
            var R = new Z();
            this.makeFace_(R, a, c.Lface);
          }
          return a;
        },
        /* tessMeshZapFace( fZap ) destroys a face and removes it from the
        * global face list.  All edges of fZap will have a NULL pointer as their
        * left face.  Any edges which also have a NULL pointer as their right face
        * are deleted entirely (along with any isolated vertices this produces).
        * An entire mesh can be deleted by zapping its faces, one at a time,
        * in any order.  Zapped faces cannot be used in further mesh operations!
        */
        zapFace: function(c) {
          var n = c.anEdge, e, a, Y, R, C;
          a = n.Lnext;
          do
            e = a, a = e.Lnext, e.Lface = null, e.Rface === null && (e.Onext === e ? this.killVertex_(e.Org, null) : (e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev)), Y = e.Sym, Y.Onext === Y ? this.killVertex_(Y.Org, null) : (Y.Org.anEdge = Y.Onext, this.splice_(Y, Y.Oprev)), this.killEdge_(e));
          while (e != n);
          R = c.prev, C = c.next, C.prev = R, R.next = C;
        },
        countFaceVerts_: function(c) {
          var n = c.anEdge, e = 0;
          do
            e++, n = n.Lnext;
          while (n !== c.anEdge);
          return e;
        },
        //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
        mergeConvexFaces: function(c) {
          var n, e, a, Y, R, C, N;
          for (n = this.fHead.next; n !== this.fHead; n = n.next)
            if (n.inside)
              for (e = n.anEdge, R = e.Org; a = e.Lnext, Y = e.Sym, Y && Y.Lface && Y.Lface.inside && (C = this.countFaceVerts_(n), N = this.countFaceVerts_(Y.Lface), C + N - 2 <= c && t.vertCCW(e.Lprev.Org, e.Org, Y.Lnext.Lnext.Org) && t.vertCCW(Y.Lprev.Org, Y.Org, e.Lnext.Lnext.Org) && (a = Y.Lnext, this.delete(Y), e = null, Y = null)), !(e && e.Lnext.Org === R); )
                e = a;
          return !0;
        },
        /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
        */
        check: function() {
          var c = this.fHead, n = this.vHead, e = this.eHead, a, Y, R, C, N, I;
          for (Y = c, Y = c; (a = Y.next) !== c; Y = a) {
            s(a.prev === Y), N = a.anEdge;
            do
              s(N.Sym !== N), s(N.Sym.Sym === N), s(N.Lnext.Onext.Sym === N), s(N.Onext.Sym.Lnext === N), s(N.Lface === a), N = N.Lnext;
            while (N !== a.anEdge);
          }
          for (s(a.prev === Y && a.anEdge === null), C = n, C = n; (R = C.next) !== n; C = R) {
            s(R.prev === C), N = R.anEdge;
            do
              s(N.Sym !== N), s(N.Sym.Sym === N), s(N.Lnext.Onext.Sym === N), s(N.Onext.Sym.Lnext === N), s(N.Org === R), N = N.Onext;
            while (N !== R.anEdge);
          }
          for (s(R.prev === C && R.anEdge === null), I = e, I = e; (N = I.next) !== e; I = N)
            s(N.Sym.next === I.Sym), s(N.Sym !== N), s(N.Sym.Sym === N), s(N.Org !== null), s(N.Dst !== null), s(N.Lnext.Onext.Sym === N), s(N.Onext.Sym.Lnext === N);
          s(N.Sym.next === I.Sym && N.Sym === this.eHeadSym && N.Sym.Sym === N && N.Org === null && N.Dst === null && N.Lface === null && N.Rface === null);
        }
      }, t.vertEq = function(c, n) {
        return c.s === n.s && c.t === n.t;
      }, t.vertLeq = function(c, n) {
        return c.s < n.s || c.s === n.s && c.t <= n.t;
      }, t.transLeq = function(c, n) {
        return c.t < n.t || c.t === n.t && c.s <= n.s;
      }, t.edgeGoesLeft = function(c) {
        return t.vertLeq(c.Dst, c.Org);
      }, t.edgeGoesRight = function(c) {
        return t.vertLeq(c.Org, c.Dst);
      }, t.vertL1dist = function(c, n) {
        return Math.abs(c.s - n.s) + Math.abs(c.t - n.t);
      }, t.edgeEval = function(c, n, e) {
        s(t.vertLeq(c, n) && t.vertLeq(n, e));
        var a = n.s - c.s, Y = e.s - n.s;
        return a + Y > 0 ? a < Y ? n.t - c.t + (c.t - e.t) * (a / (a + Y)) : n.t - e.t + (e.t - c.t) * (Y / (a + Y)) : 0;
      }, t.edgeSign = function(c, n, e) {
        s(t.vertLeq(c, n) && t.vertLeq(n, e));
        var a = n.s - c.s, Y = e.s - n.s;
        return a + Y > 0 ? (n.t - e.t) * a + (n.t - c.t) * Y : 0;
      }, t.transEval = function(c, n, e) {
        s(t.transLeq(c, n) && t.transLeq(n, e));
        var a = n.t - c.t, Y = e.t - n.t;
        return a + Y > 0 ? a < Y ? n.s - c.s + (c.s - e.s) * (a / (a + Y)) : n.s - e.s + (e.s - c.s) * (Y / (a + Y)) : 0;
      }, t.transSign = function(c, n, e) {
        s(t.transLeq(c, n) && t.transLeq(n, e));
        var a = n.t - c.t, Y = e.t - n.t;
        return a + Y > 0 ? (n.s - e.s) * a + (n.s - c.s) * Y : 0;
      }, t.vertCCW = function(c, n, e) {
        return c.s * (n.t - e.t) + n.s * (e.t - c.t) + e.s * (c.t - n.t) >= 0;
      }, t.interpolate = function(c, n, e, a) {
        return c = c < 0 ? 0 : c, e = e < 0 ? 0 : e, c <= e ? e === 0 ? (n + a) / 2 : n + (a - n) * (c / (c + e)) : a + (n - a) * (e / (c + e));
      }, t.intersect = function(c, n, e, a, Y) {
        var R, C, N;
        t.vertLeq(c, n) || (N = c, c = n, n = N), t.vertLeq(e, a) || (N = e, e = a, a = N), t.vertLeq(c, e) || (N = c, c = e, e = N, N = n, n = a, a = N), t.vertLeq(e, n) ? t.vertLeq(n, a) ? (R = t.edgeEval(c, e, n), C = t.edgeEval(e, n, a), R + C < 0 && (R = -R, C = -C), Y.s = t.interpolate(R, e.s, C, n.s)) : (R = t.edgeSign(c, e, n), C = -t.edgeSign(c, a, n), R + C < 0 && (R = -R, C = -C), Y.s = t.interpolate(R, e.s, C, a.s)) : Y.s = (e.s + n.s) / 2, t.transLeq(c, n) || (N = c, c = n, n = N), t.transLeq(e, a) || (N = e, e = a, a = N), t.transLeq(c, e) || (N = c, c = e, e = N, N = n, n = a, a = N), t.transLeq(e, n) ? t.transLeq(n, a) ? (R = t.transEval(c, e, n), C = t.transEval(e, n, a), R + C < 0 && (R = -R, C = -C), Y.t = t.interpolate(R, e.t, C, n.t)) : (R = t.transSign(c, e, n), C = -t.transSign(c, a, n), R + C < 0 && (R = -R, C = -C), Y.t = t.interpolate(R, e.t, C, a.t)) : Y.t = (e.t + n.t) / 2;
      };
      function y() {
        this.key = null, this.next = null, this.prev = null;
      }
      function X(c, n) {
        this.head = new y(), this.head.next = this.head, this.head.prev = this.head, this.frame = c, this.leq = n;
      }
      X.prototype = {
        min: function() {
          return this.head.next;
        },
        max: function() {
          return this.head.prev;
        },
        insert: function(c) {
          return this.insertBefore(this.head, c);
        },
        search: function(c) {
          var n = this.head;
          do
            n = n.next;
          while (n.key !== null && !this.leq(this.frame, c, n.key));
          return n;
        },
        insertBefore: function(c, n) {
          do
            c = c.prev;
          while (c.key !== null && !this.leq(this.frame, c.key, n));
          var e = new y();
          return e.key = n, e.next = c.next, c.next.prev = e, e.prev = c, c.next = e, e;
        },
        delete: function(c) {
          c.next.prev = c.prev, c.prev.next = c.next;
        }
      };
      function W() {
        this.handle = null;
      }
      function h() {
        this.key = null, this.node = null;
      }
      function r(c, n) {
        this.size = 0, this.max = c, this.nodes = [], this.nodes.length = c + 1;
        var e;
        for (e = 0; e < this.nodes.length; e++)
          this.nodes[e] = new W();
        for (this.handles = [], this.handles.length = c + 1, e = 0; e < this.handles.length; e++)
          this.handles[e] = new h();
        this.initialized = !1, this.freeList = 0, this.leq = n, this.nodes[1].handle = 1, this.handles[1].key = null;
      }
      r.prototype = {
        floatDown_: function(c) {
          var n = this.nodes, e = this.handles, a, Y, R;
          for (a = n[c].handle; ; ) {
            if (R = c << 1, R < this.size && this.leq(e[n[R + 1].handle].key, e[n[R].handle].key) && ++R, s(R <= this.max), Y = n[R].handle, R > this.size || this.leq(e[a].key, e[Y].key)) {
              n[c].handle = a, e[a].node = c;
              break;
            }
            n[c].handle = Y, e[Y].node = c, c = R;
          }
        },
        floatUp_: function(c) {
          var n = this.nodes, e = this.handles, a, Y, R;
          for (a = n[c].handle; ; ) {
            if (R = c >> 1, Y = n[R].handle, R === 0 || this.leq(e[Y].key, e[a].key)) {
              n[c].handle = a, e[a].node = c;
              break;
            }
            n[c].handle = Y, e[Y].node = c, c = R;
          }
        },
        init: function() {
          for (var c = this.size; c >= 1; --c)
            this.floatDown_(c);
          this.initialized = !0;
        },
        min: function() {
          return this.handles[this.nodes[1].handle].key;
        },
        /* really pqHeapInsert */
        /* returns INV_HANDLE iff out of memory */
        //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
        insert: function(c) {
          var n, e;
          if (n = ++this.size, n * 2 > this.max) {
            this.max *= 2;
            var a, Y;
            for (Y = this.nodes.length, this.nodes.length = this.max + 1, a = Y; a < this.nodes.length; a++)
              this.nodes[a] = new W();
            for (Y = this.handles.length, this.handles.length = this.max + 1, a = Y; a < this.handles.length; a++)
              this.handles[a] = new h();
          }
          return this.freeList === 0 ? e = n : (e = this.freeList, this.freeList = this.handles[e].node), this.nodes[n].handle = e, this.handles[e].node = n, this.handles[e].key = c, this.initialized && this.floatUp_(n), e;
        },
        //PQkey pqHeapExtractMin( PriorityQHeap *pq )
        extractMin: function() {
          var c = this.nodes, n = this.handles, e = c[1].handle, a = n[e].key;
          return this.size > 0 && (c[1].handle = c[this.size].handle, n[c[1].handle].node = 1, n[e].key = null, n[e].node = this.freeList, this.freeList = e, --this.size, this.size > 0 && this.floatDown_(1)), a;
        },
        delete: function(c) {
          var n = this.nodes, e = this.handles, a;
          s(c >= 1 && c <= this.max && e[c].key !== null), a = e[c].node, n[a].handle = n[this.size].handle, e[n[a].handle].node = a, --this.size, a <= this.size && (a <= 1 || this.leq(e[n[a >> 1].handle].key, e[n[a].handle].key) ? this.floatDown_(a) : this.floatUp_(a)), e[c].key = null, e[c].node = this.freeList, this.freeList = c;
        }
      };
      function L() {
        this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1;
      }
      var u = {};
      u.regionBelow = function(c) {
        return c.nodeUp.prev.key;
      }, u.regionAbove = function(c) {
        return c.nodeUp.next.key;
      }, u.debugEvent = function(c) {
      }, u.addWinding = function(c, n) {
        c.winding += n.winding, c.Sym.winding += n.Sym.winding;
      }, u.edgeLeq = function(c, n, e) {
        var a = c.event, C, N, Y = n.eUp, R = e.eUp;
        if (Y.Dst === a)
          return R.Dst === a ? t.vertLeq(Y.Org, R.Org) ? t.edgeSign(R.Dst, Y.Org, R.Org) <= 0 : t.edgeSign(Y.Dst, R.Org, Y.Org) >= 0 : t.edgeSign(R.Dst, a, R.Org) <= 0;
        if (R.Dst === a)
          return t.edgeSign(Y.Dst, a, Y.Org) >= 0;
        var C = t.edgeEval(Y.Dst, a, Y.Org), N = t.edgeEval(R.Dst, a, R.Org);
        return C >= N;
      }, u.deleteRegion = function(c, n) {
        n.fixUpperEdge && s(n.eUp.winding === 0), n.eUp.activeRegion = null, c.dict.delete(n.nodeUp);
      }, u.fixUpperEdge = function(c, n, e) {
        s(n.fixUpperEdge), c.mesh.delete(n.eUp), n.fixUpperEdge = !1, n.eUp = e, e.activeRegion = n;
      }, u.topLeftRegion = function(c, n) {
        var e = n.eUp.Org, a;
        do
          n = u.regionAbove(n);
        while (n.eUp.Org === e);
        if (n.fixUpperEdge) {
          if (a = c.mesh.connect(u.regionBelow(n).eUp.Sym, n.eUp.Lnext), a === null)
            return null;
          u.fixUpperEdge(c, n, a), n = u.regionAbove(n);
        }
        return n;
      }, u.topRightRegion = function(c) {
        var n = c.eUp.Dst;
        do
          c = u.regionAbove(c);
        while (c.eUp.Dst === n);
        return c;
      }, u.addRegionBelow = function(c, n, e) {
        var a = new L();
        return a.eUp = e, a.nodeUp = c.dict.insertBefore(n.nodeUp, a), a.fixUpperEdge = !1, a.sentinel = !1, a.dirty = !1, e.activeRegion = a, a;
      }, u.isWindingInside = function(c, n) {
        switch (c.windingRule) {
          case i.WINDING_ODD:
            return (n & 1) !== 0;
          case i.WINDING_NONZERO:
            return n !== 0;
          case i.WINDING_POSITIVE:
            return n > 0;
          case i.WINDING_NEGATIVE:
            return n < 0;
          case i.WINDING_ABS_GEQ_TWO:
            return n >= 2 || n <= -2;
        }
        return s(!1), !1;
      }, u.computeWinding = function(c, n) {
        n.windingNumber = u.regionAbove(n).windingNumber + n.eUp.winding, n.inside = u.isWindingInside(c, n.windingNumber);
      }, u.finishRegion = function(c, n) {
        var e = n.eUp, a = e.Lface;
        a.inside = n.inside, a.anEdge = e, u.deleteRegion(c, n);
      }, u.finishLeftRegions = function(c, n, e) {
        for (var a, C, Y = null, R = n, C = n.eUp; R !== e; ) {
          if (R.fixUpperEdge = !1, Y = u.regionBelow(R), a = Y.eUp, a.Org != C.Org) {
            if (!Y.fixUpperEdge) {
              u.finishRegion(c, R);
              break;
            }
            a = c.mesh.connect(C.Lprev, a.Sym), u.fixUpperEdge(c, Y, a);
          }
          C.Onext !== a && (c.mesh.splice(a.Oprev, a), c.mesh.splice(C, a)), u.finishRegion(c, R), C = Y.eUp, R = Y;
        }
        return C;
      }, u.addRightEdges = function(c, n, e, a, Y, R) {
        var C, N, I, J, T = !0;
        I = e;
        do
          s(t.vertLeq(I.Org, I.Dst)), u.addRegionBelow(c, n, I.Sym), I = I.Onext;
        while (I !== a);
        for (Y === null && (Y = u.regionBelow(n).eUp.Rprev), N = n, J = Y; C = u.regionBelow(N), I = C.eUp.Sym, I.Org === J.Org; )
          I.Onext !== J && (c.mesh.splice(I.Oprev, I), c.mesh.splice(J.Oprev, I)), C.windingNumber = N.windingNumber - I.winding, C.inside = u.isWindingInside(c, C.windingNumber), N.dirty = !0, !T && u.checkForRightSplice(c, N) && (u.addWinding(I, J), u.deleteRegion(c, N), c.mesh.delete(J)), T = !1, N = C, J = I;
        N.dirty = !0, s(N.windingNumber - I.winding === C.windingNumber), R && u.walkDirtyRegions(c, N);
      }, u.spliceMergeVertices = function(c, n, e) {
        c.mesh.splice(n, e);
      }, u.vertexWeights = function(c, n, e) {
        var a = t.vertL1dist(n, c), Y = t.vertL1dist(e, c), R = 0.5 * Y / (a + Y), C = 0.5 * a / (a + Y);
        c.coords[0] += R * n.coords[0] + C * e.coords[0], c.coords[1] += R * n.coords[1] + C * e.coords[1], c.coords[2] += R * n.coords[2] + C * e.coords[2];
      }, u.getIntersectData = function(c, n, e, a, Y, R) {
        n.coords[0] = n.coords[1] = n.coords[2] = 0, n.idx = -1, u.vertexWeights(n, e, a), u.vertexWeights(n, Y, R);
      }, u.checkForRightSplice = function(c, n) {
        var e = u.regionBelow(n), a = n.eUp, Y = e.eUp;
        if (t.vertLeq(a.Org, Y.Org)) {
          if (t.edgeSign(Y.Dst, a.Org, Y.Org) > 0)
            return !1;
          t.vertEq(a.Org, Y.Org) ? a.Org !== Y.Org && (c.pq.delete(a.Org.pqHandle), u.spliceMergeVertices(c, Y.Oprev, a)) : (c.mesh.splitEdge(Y.Sym), c.mesh.splice(a, Y.Oprev), n.dirty = e.dirty = !0);
        } else {
          if (t.edgeSign(a.Dst, Y.Org, a.Org) < 0)
            return !1;
          u.regionAbove(n).dirty = n.dirty = !0, c.mesh.splitEdge(a.Sym), c.mesh.splice(Y.Oprev, a);
        }
        return !0;
      }, u.checkForLeftSplice = function(c, n) {
        var e = u.regionBelow(n), a = n.eUp, Y = e.eUp, R;
        if (s(!t.vertEq(a.Dst, Y.Dst)), t.vertLeq(a.Dst, Y.Dst)) {
          if (t.edgeSign(a.Dst, Y.Dst, a.Org) < 0)
            return !1;
          u.regionAbove(n).dirty = n.dirty = !0, R = c.mesh.splitEdge(a), c.mesh.splice(Y.Sym, R), R.Lface.inside = n.inside;
        } else {
          if (t.edgeSign(Y.Dst, a.Dst, Y.Org) > 0)
            return !1;
          n.dirty = e.dirty = !0, R = c.mesh.splitEdge(Y), c.mesh.splice(a.Lnext, Y.Sym), R.Rface.inside = n.inside;
        }
        return !0;
      }, u.checkForIntersect = function(c, n) {
        var e = u.regionBelow(n), a = n.eUp, Y = e.eUp, R = a.Org, C = Y.Org, N = a.Dst, I = Y.Dst, J, T, K = new b(), S, H;
        if (s(!t.vertEq(I, N)), s(t.edgeSign(N, c.event, R) <= 0), s(t.edgeSign(I, c.event, C) >= 0), s(R !== c.event && C !== c.event), s(!n.fixUpperEdge && !e.fixUpperEdge), R === C || (J = Math.min(R.t, N.t), T = Math.max(C.t, I.t), J > T))
          return !1;
        if (t.vertLeq(R, C)) {
          if (t.edgeSign(I, R, C) > 0)
            return !1;
        } else if (t.edgeSign(N, C, R) < 0)
          return !1;
        return u.debugEvent(c), t.intersect(N, R, I, C, K), s(Math.min(R.t, N.t) <= K.t), s(K.t <= Math.max(C.t, I.t)), s(Math.min(I.s, N.s) <= K.s), s(K.s <= Math.max(C.s, R.s)), t.vertLeq(K, c.event) && (K.s = c.event.s, K.t = c.event.t), S = t.vertLeq(R, C) ? R : C, t.vertLeq(S, K) && (K.s = S.s, K.t = S.t), t.vertEq(K, R) || t.vertEq(K, C) ? (u.checkForRightSplice(c, n), !1) : !t.vertEq(N, c.event) && t.edgeSign(N, c.event, K) >= 0 || !t.vertEq(I, c.event) && t.edgeSign(I, c.event, K) <= 0 ? I === c.event ? (c.mesh.splitEdge(a.Sym), c.mesh.splice(Y.Sym, a), n = u.topLeftRegion(c, n), a = u.regionBelow(n).eUp, u.finishLeftRegions(c, u.regionBelow(n), e), u.addRightEdges(c, n, a.Oprev, a, a, !0), !0) : N === c.event ? (c.mesh.splitEdge(Y.Sym), c.mesh.splice(a.Lnext, Y.Oprev), e = n, n = u.topRightRegion(n), H = u.regionBelow(n).eUp.Rprev, e.eUp = Y.Oprev, Y = u.finishLeftRegions(c, e, null), u.addRightEdges(c, n, Y.Onext, a.Rprev, H, !0), !0) : (t.edgeSign(N, c.event, K) >= 0 && (u.regionAbove(n).dirty = n.dirty = !0, c.mesh.splitEdge(a.Sym), a.Org.s = c.event.s, a.Org.t = c.event.t), t.edgeSign(I, c.event, K) <= 0 && (n.dirty = e.dirty = !0, c.mesh.splitEdge(Y.Sym), Y.Org.s = c.event.s, Y.Org.t = c.event.t), !1) : (c.mesh.splitEdge(a.Sym), c.mesh.splitEdge(Y.Sym), c.mesh.splice(Y.Oprev, a), a.Org.s = K.s, a.Org.t = K.t, a.Org.pqHandle = c.pq.insert(a.Org), u.getIntersectData(c, a.Org, R, N, C, I), u.regionAbove(n).dirty = n.dirty = e.dirty = !0, !1);
      }, u.walkDirtyRegions = function(c, n) {
        for (var e = u.regionBelow(n), a, Y; ; ) {
          for (; e.dirty; )
            n = e, e = u.regionBelow(e);
          if (!n.dirty && (e = n, n = u.regionAbove(n), n === null || !n.dirty))
            return;
          if (n.dirty = !1, a = n.eUp, Y = e.eUp, a.Dst !== Y.Dst && u.checkForLeftSplice(c, n) && (e.fixUpperEdge ? (u.deleteRegion(c, e), c.mesh.delete(Y), e = u.regionBelow(n), Y = e.eUp) : n.fixUpperEdge && (u.deleteRegion(c, n), c.mesh.delete(a), n = u.regionAbove(e), a = n.eUp)), a.Org !== Y.Org)
            if (a.Dst !== Y.Dst && !n.fixUpperEdge && !e.fixUpperEdge && (a.Dst === c.event || Y.Dst === c.event)) {
              if (u.checkForIntersect(c, n))
                return;
            } else
              u.checkForRightSplice(c, n);
          a.Org === Y.Org && a.Dst === Y.Dst && (u.addWinding(Y, a), u.deleteRegion(c, n), c.mesh.delete(a), n = u.regionAbove(e));
        }
      }, u.connectRightVertex = function(c, n, e) {
        var a, Y = e.Onext, R = u.regionBelow(n), C = n.eUp, N = R.eUp, I = !1;
        if (C.Dst !== N.Dst && u.checkForIntersect(c, n), t.vertEq(C.Org, c.event) && (c.mesh.splice(Y.Oprev, C), n = u.topLeftRegion(c, n), Y = u.regionBelow(n).eUp, u.finishLeftRegions(c, u.regionBelow(n), R), I = !0), t.vertEq(N.Org, c.event) && (c.mesh.splice(e, N.Oprev), e = u.finishLeftRegions(c, R, null), I = !0), I) {
          u.addRightEdges(c, n, e.Onext, Y, Y, !0);
          return;
        }
        t.vertLeq(N.Org, C.Org) ? a = N.Oprev : a = C, a = c.mesh.connect(e.Lprev, a), u.addRightEdges(c, n, a, a.Onext, a.Onext, !1), a.Sym.activeRegion.fixUpperEdge = !0, u.walkDirtyRegions(c, n);
      }, u.connectLeftDegenerate = function(c, n, e) {
        var a, Y, R, C, N;
        if (a = n.eUp, t.vertEq(a.Org, e)) {
          s(
            !1
            /*TOLERANCE_NONZERO*/
          ), u.spliceMergeVertices(c, a, e.anEdge);
          return;
        }
        if (!t.vertEq(a.Dst, e)) {
          c.mesh.splitEdge(a.Sym), n.fixUpperEdge && (c.mesh.delete(a.Onext), n.fixUpperEdge = !1), c.mesh.splice(e.anEdge, a), u.sweepEvent(c, e);
          return;
        }
        s(
          !1
          /*TOLERANCE_NONZERO*/
        ), n = u.topRightRegion(n), N = u.regionBelow(n), R = N.eUp.Sym, Y = C = R.Onext, N.fixUpperEdge && (s(Y !== R), u.deleteRegion(c, N), c.mesh.delete(R), R = Y.Oprev), c.mesh.splice(e.anEdge, R), t.edgeGoesLeft(Y) || (Y = null), u.addRightEdges(c, n, R.Onext, C, Y, !0);
      }, u.connectLeftVertex = function(c, n) {
        var e, a, Y, R, C, N, I = new L();
        if (I.eUp = n.anEdge.Sym, e = c.dict.search(I).key, a = u.regionBelow(e), !!a) {
          if (R = e.eUp, C = a.eUp, t.edgeSign(R.Dst, n, R.Org) === 0) {
            u.connectLeftDegenerate(c, e, n);
            return;
          }
          if (Y = t.vertLeq(C.Dst, R.Dst) ? e : a, e.inside || Y.fixUpperEdge) {
            if (Y === e)
              N = c.mesh.connect(n.anEdge.Sym, R.Lnext);
            else {
              var J = c.mesh.connect(C.Dnext, n.anEdge);
              N = J.Sym;
            }
            Y.fixUpperEdge ? u.fixUpperEdge(c, Y, N) : u.computeWinding(c, u.addRegionBelow(c, e, N)), u.sweepEvent(c, n);
          } else
            u.addRightEdges(c, e, n.anEdge, n.anEdge, null, !0);
        }
      }, u.sweepEvent = function(c, n) {
        c.event = n, u.debugEvent(c);
        for (var e = n.anEdge; e.activeRegion === null; )
          if (e = e.Onext, e === n.anEdge) {
            u.connectLeftVertex(c, n);
            return;
          }
        var a = u.topLeftRegion(c, e.activeRegion);
        s(a !== null);
        var Y = u.regionBelow(a), R = Y.eUp, C = u.finishLeftRegions(c, Y, null);
        C.Onext === R ? u.connectRightVertex(c, a, C) : u.addRightEdges(c, a, C.Onext, R, R, !0);
      }, u.addSentinel = function(c, n, e, a) {
        var Y = new L(), R = c.mesh.makeEdge();
        R.Org.s = e, R.Org.t = a, R.Dst.s = n, R.Dst.t = a, c.event = R.Dst, Y.eUp = R, Y.windingNumber = 0, Y.inside = !1, Y.fixUpperEdge = !1, Y.sentinel = !0, Y.dirty = !1, Y.nodeUp = c.dict.insert(Y);
      }, u.initEdgeDict = function(c) {
        c.dict = new X(c, u.edgeLeq);
        var n = c.bmax[0] - c.bmin[0], e = c.bmax[1] - c.bmin[1], a = c.bmin[0] - n, Y = c.bmax[0] + n, R = c.bmin[1] - e, C = c.bmax[1] + e;
        u.addSentinel(c, a, Y, R), u.addSentinel(c, a, Y, C);
      }, u.doneEdgeDict = function(c) {
        for (var n, e = 0; (n = c.dict.min().key) !== null; )
          n.sentinel || (s(n.fixUpperEdge), s(++e === 1)), s(n.windingNumber === 0), u.deleteRegion(c, n);
      }, u.removeDegenerateEdges = function(c) {
        var n, e, a, Y = c.mesh.eHead;
        for (n = Y.next; n !== Y; n = e)
          e = n.next, a = n.Lnext, t.vertEq(n.Org, n.Dst) && n.Lnext.Lnext !== n && (u.spliceMergeVertices(c, a, n), c.mesh.delete(n), n = a, a = n.Lnext), a.Lnext === n && (a !== n && ((a === e || a === e.Sym) && (e = e.next), c.mesh.delete(a)), (n === e || n === e.Sym) && (e = e.next), c.mesh.delete(n));
      }, u.initPriorityQ = function(c) {
        var n, e, a, Y = 0;
        for (a = c.mesh.vHead, e = a.next; e !== a; e = e.next)
          Y++;
        for (Y += 8, n = c.pq = new r(Y, t.vertLeq), a = c.mesh.vHead, e = a.next; e !== a; e = e.next)
          e.pqHandle = n.insert(e);
        return e !== a ? !1 : (n.init(), !0);
      }, u.donePriorityQ = function(c) {
        c.pq = null;
      }, u.removeDegenerateFaces = function(c, n) {
        var e, a, Y;
        for (e = n.fHead.next; e !== n.fHead; e = a)
          a = e.next, Y = e.anEdge, s(Y.Lnext !== Y), Y.Lnext.Lnext === Y && (u.addWinding(Y.Onext, Y), c.mesh.delete(Y));
        return !0;
      }, u.computeInterior = function(c) {
        var n, e;
        if (u.removeDegenerateEdges(c), !u.initPriorityQ(c))
          return !1;
        for (u.initEdgeDict(c); (n = c.pq.extractMin()) !== null; ) {
          for (; e = c.pq.min(), !(e === null || !t.vertEq(e, n)); )
            e = c.pq.extractMin(), u.spliceMergeVertices(c, n.anEdge, e.anEdge);
          u.sweepEvent(c, n);
        }
        return c.event = c.dict.min().key.eUp.Org, u.debugEvent(c), u.doneEdgeDict(c), u.donePriorityQ(c), u.removeDegenerateFaces(c, c.mesh) ? (c.mesh.check(), !0) : !1;
      };
      function V() {
        this.mesh = null, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = i.WINDING_ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
      }
      V.prototype = {
        dot_: function(c, n) {
          return c[0] * n[0] + c[1] * n[1] + c[2] * n[2];
        },
        normalize_: function(c) {
          var n = c[0] * c[0] + c[1] * c[1] + c[2] * c[2];
          s(n > 0), n = Math.sqrt(n), c[0] /= n, c[1] /= n, c[2] /= n;
        },
        longAxis_: function(c) {
          var n = 0;
          return Math.abs(c[1]) > Math.abs(c[0]) && (n = 1), Math.abs(c[2]) > Math.abs(c[n]) && (n = 2), n;
        },
        computeNormal_: function(c) {
          var n, e, a, Y, R, C, N = [0, 0, 0], I = [0, 0, 0], J = [0, 0, 0], T = [0, 0, 0], K = [0, 0, 0], S = [null, null, null], H = [null, null, null], w = this.mesh.vHead, P;
          for (n = w.next, P = 0; P < 3; ++P)
            Y = n.coords[P], I[P] = Y, H[P] = n, N[P] = Y, S[P] = n;
          for (n = w.next; n !== w; n = n.next)
            for (P = 0; P < 3; ++P)
              Y = n.coords[P], Y < I[P] && (I[P] = Y, H[P] = n), Y > N[P] && (N[P] = Y, S[P] = n);
          if (P = 0, N[1] - I[1] > N[0] - I[0] && (P = 1), N[2] - I[2] > N[P] - I[P] && (P = 2), I[P] >= N[P]) {
            c[0] = 0, c[1] = 0, c[2] = 1;
            return;
          }
          for (C = 0, e = H[P], a = S[P], J[0] = e.coords[0] - a.coords[0], J[1] = e.coords[1] - a.coords[1], J[2] = e.coords[2] - a.coords[2], n = w.next; n !== w; n = n.next)
            T[0] = n.coords[0] - a.coords[0], T[1] = n.coords[1] - a.coords[1], T[2] = n.coords[2] - a.coords[2], K[0] = J[1] * T[2] - J[2] * T[1], K[1] = J[2] * T[0] - J[0] * T[2], K[2] = J[0] * T[1] - J[1] * T[0], R = K[0] * K[0] + K[1] * K[1] + K[2] * K[2], R > C && (C = R, c[0] = K[0], c[1] = K[1], c[2] = K[2]);
          C <= 0 && (c[0] = c[1] = c[2] = 0, c[this.longAxis_(J)] = 1);
        },
        checkOrientation_: function() {
          var c, n, e = this.mesh.fHead, a, Y = this.mesh.vHead, R;
          for (c = 0, n = e.next; n !== e; n = n.next)
            if (R = n.anEdge, !(R.winding <= 0))
              do
                c += (R.Org.s - R.Dst.s) * (R.Org.t + R.Dst.t), R = R.Lnext;
              while (R !== n.anEdge);
          if (c < 0) {
            for (a = Y.next; a !== Y; a = a.next)
              a.t = -a.t;
            this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
          }
        },
        /*	#ifdef FOR_TRITE_TEST_PROGRAM
          #include <stdlib.h>
          extern int RandomSweep;
          #define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
          #define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
          #else
          #if defined(SLANTED_SWEEP) */
        /* The "feature merging" is not intended to be complete.  There are
        * special cases where edges are nearly parallel to the sweep line
        * which are not implemented.  The algorithm should still behave
        * robustly (ie. produce a reasonable tesselation) in the presence
        * of such edges, however it may miss features which could have been
        * merged.  We could minimize this effect by choosing the sweep line
        * direction to be something unusual (ie. not parallel to one of the
        * coordinate axes).
        */
        /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
          #define S_UNIT_Y	(TESSreal)0.86052074622010633
          #else
          #define S_UNIT_X	(TESSreal)1.0
          #define S_UNIT_Y	(TESSreal)0.0
          #endif
          #endif*/
        /* Determine the polygon normal and project vertices onto the plane
        * of the polygon.
        */
        projectPolygon_: function() {
          var c, n = this.mesh.vHead, e = [0, 0, 0], a, Y, R, C, N = !1;
          for (e[0] = this.normal[0], e[1] = this.normal[1], e[2] = this.normal[2], e[0] === 0 && e[1] === 0 && e[2] === 0 && (this.computeNormal_(e), N = !0), a = this.sUnit, Y = this.tUnit, R = this.longAxis_(e), a[R] = 0, a[(R + 1) % 3] = 1, a[(R + 2) % 3] = 0, Y[R] = 0, Y[(R + 1) % 3] = 0, Y[(R + 2) % 3] = e[R] > 0 ? 1 : -1, c = n.next; c !== n; c = c.next)
            c.s = this.dot_(c.coords, a), c.t = this.dot_(c.coords, Y);
          for (N && this.checkOrientation_(), C = !0, c = n.next; c !== n; c = c.next)
            C ? (this.bmin[0] = this.bmax[0] = c.s, this.bmin[1] = this.bmax[1] = c.t, C = !1) : (c.s < this.bmin[0] && (this.bmin[0] = c.s), c.s > this.bmax[0] && (this.bmax[0] = c.s), c.t < this.bmin[1] && (this.bmin[1] = c.t), c.t > this.bmax[1] && (this.bmax[1] = c.t));
        },
        addWinding_: function(c, n) {
          c.winding += n.winding, c.Sym.winding += n.Sym.winding;
        },
        /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
        * (what else would it do??)  The region must consist of a single
        * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
        * case means that any vertical line intersects the interior of the
        * region in a single interval.  
        *
        * Tessellation consists of adding interior edges (actually pairs of
        * half-edges), to split the region into non-overlapping triangles.
        *
        * The basic idea is explained in Preparata and Shamos (which I don''t
        * have handy right now), although their implementation is more
        * complicated than this one.  The are two edge chains, an upper chain
        * and a lower chain.  We process all vertices from both chains in order,
        * from right to left.
        *
        * The algorithm ensures that the following invariant holds after each
        * vertex is processed: the untessellated region consists of two
        * chains, where one chain (say the upper) is a single edge, and
        * the other chain is concave.  The left vertex of the single edge
        * is always to the left of all vertices in the concave chain.
        *
        * Each step consists of adding the rightmost unprocessed vertex to one
        * of the two chains, and forming a fan of triangles from the rightmost
        * of two chain endpoints.  Determining whether we can add each triangle
        * to the fan is a simple orientation test.  By making the fan as large
        * as possible, we restore the invariant (check it yourself).
        */
        //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
        tessellateMonoRegion_: function(c, n) {
          var e, a;
          for (e = n.anEdge, s(e.Lnext !== e && e.Lnext.Lnext !== e); t.vertLeq(e.Dst, e.Org); e = e.Lprev)
            ;
          for (; t.vertLeq(e.Org, e.Dst); e = e.Lnext)
            ;
          for (a = e.Lprev; e.Lnext !== a; )
            if (t.vertLeq(e.Dst, a.Org)) {
              for (; a.Lnext !== e && (t.edgeGoesLeft(a.Lnext) || t.edgeSign(a.Org, a.Dst, a.Lnext.Dst) <= 0); ) {
                var Y = c.connect(a.Lnext, a);
                a = Y.Sym;
              }
              a = a.Lprev;
            } else {
              for (; a.Lnext !== e && (t.edgeGoesRight(e.Lprev) || t.edgeSign(e.Dst, e.Org, e.Lprev.Org) >= 0); ) {
                var Y = c.connect(e, e.Lprev);
                e = Y.Sym;
              }
              e = e.Lnext;
            }
          for (s(a.Lnext !== e); a.Lnext.Lnext !== e; ) {
            var Y = c.connect(a.Lnext, a);
            a = Y.Sym;
          }
          return !0;
        },
        /* tessMeshTessellateInterior( mesh ) tessellates each region of
        * the mesh which is marked "inside" the polygon.  Each such region
        * must be monotone.
        */
        //int tessMeshTessellateInterior( TESSmesh *mesh )
        tessellateInterior_: function(c) {
          var n, e;
          for (n = c.fHead.next; n !== c.fHead; n = e)
            if (e = n.next, n.inside && !this.tessellateMonoRegion_(c, n))
              return !1;
          return !0;
        },
        /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
        * which are not marked "inside" the polygon.  Since further mesh operations
        * on NULL faces are not allowed, the main purpose is to clean up the
        * mesh so that exterior loops are not represented in the data structure.
        */
        //void tessMeshDiscardExterior( TESSmesh *mesh )
        discardExterior_: function(c) {
          var n, e;
          for (n = c.fHead.next; n !== c.fHead; n = e)
            e = n.next, n.inside || c.zapFace(n);
        },
        /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
        * winding numbers on all edges so that regions marked "inside" the
        * polygon have a winding number of "value", and regions outside
        * have a winding number of 0.
        *
        * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
        * separate an interior region from an exterior one.
        */
        //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
        setWindingNumber_: function(c, n, e) {
          var a, Y;
          for (a = c.eHead.next; a !== c.eHead; a = Y)
            Y = a.next, a.Rface.inside !== a.Lface.inside ? a.winding = a.Lface.inside ? n : -n : e ? c.delete(a) : a.winding = 0;
        },
        getNeighbourFace_: function(c) {
          return !c.Rface || !c.Rface.inside ? -1 : c.Rface.n;
        },
        outputPolymesh_: function(c, n, e, a) {
          var Y, R, C, N = 0, I = 0, J, T;
          for (e > 3 && c.mergeConvexFaces(e), Y = c.vHead.next; Y !== c.vHead; Y = Y.next)
            Y.n = -1;
          for (R = c.fHead.next; R !== c.fHead; R = R.next)
            if (R.n = -1, !!R.inside) {
              C = R.anEdge, J = 0;
              do
                Y = C.Org, Y.n === -1 && (Y.n = I, I++), J++, C = C.Lnext;
              while (C !== R.anEdge);
              s(J <= e), R.n = N, ++N;
            }
          for (this.elementCount = N, n === i.CONNECTED_POLYGONS && (N *= 2), this.elements = [], this.elements.length = N * e, this.vertexCount = I, this.vertices = [], this.vertices.length = I * a, this.vertexIndices = [], this.vertexIndices.length = I, Y = c.vHead.next; Y !== c.vHead; Y = Y.next)
            if (Y.n !== -1) {
              var K = Y.n * a;
              this.vertices[K + 0] = Y.coords[0], this.vertices[K + 1] = Y.coords[1], a > 2 && (this.vertices[K + 2] = Y.coords[2]), this.vertexIndices[Y.n] = Y.idx;
            }
          var S = 0;
          for (R = c.fHead.next; R !== c.fHead; R = R.next)
            if (R.inside) {
              C = R.anEdge, J = 0;
              do
                Y = C.Org, this.elements[S++] = Y.n, J++, C = C.Lnext;
              while (C !== R.anEdge);
              for (T = J; T < e; ++T)
                this.elements[S++] = -1;
              if (n === i.CONNECTED_POLYGONS) {
                C = R.anEdge;
                do
                  this.elements[S++] = this.getNeighbourFace_(C), C = C.Lnext;
                while (C !== R.anEdge);
                for (T = J; T < e; ++T)
                  this.elements[S++] = -1;
              }
            }
        },
        //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
        outputContours_: function(c, n) {
          var e, a, Y, R = 0, C = 0;
          for (this.vertexCount = 0, this.elementCount = 0, e = c.fHead.next; e !== c.fHead; e = e.next)
            if (e.inside) {
              Y = a = e.anEdge;
              do
                this.vertexCount++, a = a.Lnext;
              while (a !== Y);
              this.elementCount++;
            }
          this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * n, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
          var N = 0, I = 0, J = 0;
          for (R = 0, e = c.fHead.next; e !== c.fHead; e = e.next)
            if (e.inside) {
              C = 0, Y = a = e.anEdge;
              do
                this.vertices[N++] = a.Org.coords[0], this.vertices[N++] = a.Org.coords[1], n > 2 && (this.vertices[N++] = a.Org.coords[2]), this.vertexIndices[I++] = a.Org.idx, C++, a = a.Lnext;
              while (a !== Y);
              this.elements[J++] = R, this.elements[J++] = C, R += C;
            }
        },
        addContour: function(c, n) {
          var e, a;
          for (this.mesh === null && (this.mesh = new G()), c < 2 && (c = 2), c > 3 && (c = 3), e = null, a = 0; a < n.length; a += c)
            e === null ? (e = this.mesh.makeEdge(), this.mesh.splice(e, e.Sym)) : (this.mesh.splitEdge(e), e = e.Lnext), e.Org.coords[0] = n[a + 0], e.Org.coords[1] = n[a + 1], c > 2 ? e.Org.coords[2] = n[a + 2] : e.Org.coords[2] = 0, e.Org.idx = this.vertexIndexCounter++, e.winding = 1, e.Sym.winding = -1;
        },
        //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
        tesselate: function(c, n, e, a, Y) {
          if (this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, Y && (this.normal[0] = Y[0], this.normal[1] = Y[1], this.normal[2] = Y[2]), this.windingRule = c, a < 2 && (a = 2), a > 3 && (a = 3), !this.mesh)
            return !1;
          this.projectPolygon_(), u.computeInterior(this);
          var R = this.mesh;
          return n === i.BOUNDARY_CONTOURS ? this.setWindingNumber_(R, 1, !0) : this.tessellateInterior_(R), R.check(), n === i.BOUNDARY_CONTOURS ? this.outputContours_(R, a) : this.outputPolymesh_(R, n, e, a), !0;
        }
      };
    },
    /* 62 */
    /***/
    function(m, d) {
      m.exports = i;
      var l = Object.prototype.hasOwnProperty;
      function i() {
        for (var t = {}, s = 0; s < arguments.length; s++) {
          var b = arguments[s];
          for (var Z in b)
            l.call(b, Z) && (t[Z] = b[Z]);
        }
        return t;
      }
    },
    /* 63 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "createShaders", function() {
        return o;
      }), l.d(d, "applyShader", function() {
        return G;
      }), l.d(d, "createCloudShaders", function() {
        return X;
      }), l.d(d, "applyCloudShader", function() {
        return W;
      });
      var i = l(64), t = l(65), s = l(66), b = l(67);
      l(1).glMatrix.setMatrixArrayType(Array);
      const Z = Symbol("shaders");
      function o(h) {
        h[Z] = [];
        for (let r = 0; r < 16; r++) {
          const L = [], u = !!(r & 1), V = !!(r & 2), c = !!(r & 4), n = !!(r & 8);
          u && L.push("#define TEXTURE 1"), V && L.push("#define FILTER 1"), c && L.push("#define GRADIENT 1"), n && L.push("#define CLIPPATH 1");
          const e = `${L.join(`
`)}
`, a = [];
          u && a.push("uniform sampler2D u_texSampler;"), n && a.push("uniform sampler2D u_clipSampler;"), h[Z][r] = [e + a.join(`
`) + t.default, e + i.default];
        }
      }
      function G(h, {
        hasTexture: r = !1,
        hasFilter: L = !1,
        hasGradient: u = !1,
        hasClipPath: V = !1
      } = {}) {
        const c = r | L << 1 | u << 2 | V << 3;
        let n = h[Z][c];
        Array.isArray(n) && (n = h.createProgram(...n), h[Z][c] = n), h.program !== n && h.useProgram(n, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          }
        });
      }
      const y = [];
      function X(h) {
        for (let r = 0; r < 64; r++) {
          const L = [], u = !!(r & 1), V = !!(r & 2), c = !!(r & 4), n = !!(r & 8), e = !!(r & 16), a = !!(r & 32);
          u && L.push("#define TEXTURE 1"), V && L.push("#define FILTER 1"), c && L.push("#define GRADIENT 1"), n && L.push("#define CLOUDCOLOR 1"), e && L.push("#define CLOUDFILTER 1"), a && L.push("#define CLIPPATH 1");
          const Y = `${L.join(`
`)}
`, R = [];
          if (u) {
            R.push("uniform sampler2D u_texSampler;");
            for (let C = 0; C < 12; C++)
              R.push(`uniform sampler2D u_texFrame${C};`);
          }
          a && R.push("uniform sampler2D u_clipSampler;"), y[r] = [Y + R.join(`
`) + b.default, Y + s.default];
        }
      }
      function W(h, {
        hasTexture: r = !1,
        hasFilter: L = !1,
        hasGradient: u = !1,
        hasCloudColor: V = !1,
        hasCloudFilter: c = !1,
        hasClipPath: n = !1
      } = {}) {
        const e = r | L << 1 | u << 2 | V << 3 | c << 4 | n << 5;
        let a = y[e];
        Array.isArray(a) && (a = h.createProgram(...a), y[e] = a), h.program !== a && h.useProgram(a, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_fillCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_strokeCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_frameIndex: {
            type: "UNSIGNED_BYTE",
            normalize: !1
          }
        });
      }
    },
    /* 64 */
    /***/
    function(m, d, l) {
      l.r(d), d.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;
  vColor = a_color;

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif
}`;
    },
    /* 65 */
    /***/
    function(m, d, l) {
      l.r(d), d.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;
// uniform float u_radialGradientVector[6];

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

#ifdef FILTER
void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      vec4 texColor = texture2D(u_texSampler, texCoord.xy);
      float alpha = texColor.a;
      if(opacity < 1.0) {
        texColor.a *= opacity;
        alpha *= mix(0.465, 1.0, opacity);
      }
      // color = mix(color, texColor, texColor.a);
      color.rgb = mix(color.rgb, texColor.rgb, alpha);
      // color.rgb = mix(texColor.rgb, color.rgb, color.a);
      color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
      color.a = texColor.a + (1.0 - texColor.a) * color.a;
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 66 */
    /***/
    function(m, d, l) {
      l.r(d), d.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
attribute vec3 a_transform0;
attribute vec3 a_transform1;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute float a_frameIndex;
varying float frameIndex;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef CLOUDFILTER
attribute vec4 a_colorCloud0;
attribute vec4 a_colorCloud1;
attribute vec4 a_colorCloud2;
attribute vec4 a_colorCloud3;
attribute vec4 a_colorCloud4;
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef CLOUDCOLOR
attribute vec4 a_fillCloudColor;
attribute vec4 a_strokeCloudColor;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  mat3 modelMatrix = mat3(
    a_transform0.x, a_transform1.x, 0, 
    a_transform0.y, a_transform1.y, 0,
    a_transform0.z, a_transform1.z, 1
  );

  vec3 pos = projectionMatrix * viewMatrix * modelMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;

#ifdef CLOUDCOLOR
  if(flagBackground > 0.0) {
    vColor = mix(a_color, a_fillCloudColor, a_fillCloudColor.a);
  } else {
    vColor = mix(a_color, a_strokeCloudColor, a_strokeCloudColor.a);
  }
#else
  vColor = a_color;
#endif

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  frameIndex = a_frameIndex;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif

#ifdef CLOUDFILTER
  colorCloud0 = a_colorCloud0;
  colorCloud1 = a_colorCloud1;
  colorCloud2 = a_colorCloud2;
  colorCloud3 = a_colorCloud3;
  colorCloud4 = a_colorCloud4;
#endif
}`;
    },
    /* 67 */
    /***/
    function(m, d, l) {
      l.r(d), d.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying float frameIndex;
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef CLOUDFILTER
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}

#ifdef CLOUDFILTER
void buildCloudColor(inout float colorCloudMatrix[20]) {
  colorCloudMatrix[0] = colorCloud0[0];
  colorCloudMatrix[1] = colorCloud1[0];
  colorCloudMatrix[2] = colorCloud2[0];
  colorCloudMatrix[3] = colorCloud3[0];
  colorCloudMatrix[4] = colorCloud4[0];

  colorCloudMatrix[5] = colorCloud0[1];
  colorCloudMatrix[6] = colorCloud1[1];
  colorCloudMatrix[7] = colorCloud2[1];
  colorCloudMatrix[8] = colorCloud3[1];
  colorCloudMatrix[9] = colorCloud4[1];

  colorCloudMatrix[10] = colorCloud0[2];
  colorCloudMatrix[11] = colorCloud1[2];
  colorCloudMatrix[12] = colorCloud2[2];
  colorCloudMatrix[13] = colorCloud3[2];
  colorCloudMatrix[14] = colorCloud4[2];

  colorCloudMatrix[15] = colorCloud0[3];
  colorCloudMatrix[16] = colorCloud1[3];
  colorCloudMatrix[17] = colorCloud2[3];
  colorCloudMatrix[18] = colorCloud3[3];
  colorCloudMatrix[19] = colorCloud4[3];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      if(frameIndex < 0.0) {
        vec4 texColor = texture2D(u_texSampler, texCoord.xy);
        color = mix(color, texColor, texColor.a);
      } else {
        int index = int(floor(clamp(0.0, 11.0, frameIndex)));
        vec4 texColor;
        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);
        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);
        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);
        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);
        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);
        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);
        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);
        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);
        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);
        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);
        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);
        else texColor = texture2D(u_texFrame11, texCoord.xy);
        float alpha = texColor.a;
        if(opacity < 1.0) {
          texColor.a *= opacity;
          alpha *= mix(0.465, 1.0, opacity);
        }
        // color = mix(color, texColor, texColor.a);
        color.rgb = mix(color.rgb, texColor.rgb, alpha);
        // color.rgb = mix(texColor.rgb, color.rgb, color.a);
        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
        color.a = texColor.a + (1.0 - texColor.a) * color.a;
      }
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLOUDFILTER
  float colorCloudMatrix[20];
  buildCloudColor(colorCloudMatrix);
  transformColor(color, colorCloudMatrix);
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 68 */
    /***/
    function(m, d, l) {
      l.r(d), (function(i, t) {
        l.d(d, "requestAnimationFrame", function() {
          return b;
        }), l.d(d, "cancelAnimationFrame", function() {
          return Z;
        }), l(1).glMatrix.setMatrixArrayType(Array);
        function s() {
          if (typeof performance < "u" && performance.now)
            return performance.now();
          if (typeof i < "u" && i.hrtime) {
            const [o, G] = i.hrtime();
            return o * 1e3 + G * 1e-6;
          }
          return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
        }
        let b, Z;
        typeof t < "u" && typeof t.requestAnimationFrame == "function" ? (b = t.requestAnimationFrame, Z = t.cancelAnimationFrame) : (b = function(o) {
          return setTimeout(() => {
            o(s());
          }, 16);
        }, Z = function(o) {
          return clearTimeout(o);
        });
      }).call(this, l(69), l(22));
    },
    /* 69 */
    /***/
    function(m, d) {
      var l = m.exports = {}, i, t;
      function s() {
        throw new Error("setTimeout has not been defined");
      }
      function b() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? i = setTimeout : i = s;
        } catch {
          i = s;
        }
        try {
          typeof clearTimeout == "function" ? t = clearTimeout : t = b;
        } catch {
          t = b;
        }
      })();
      function Z(V) {
        if (i === setTimeout)
          return setTimeout(V, 0);
        if ((i === s || !i) && setTimeout)
          return i = setTimeout, setTimeout(V, 0);
        try {
          return i(V, 0);
        } catch {
          try {
            return i.call(null, V, 0);
          } catch {
            return i.call(this, V, 0);
          }
        }
      }
      function o(V) {
        if (t === clearTimeout)
          return clearTimeout(V);
        if ((t === b || !t) && clearTimeout)
          return t = clearTimeout, clearTimeout(V);
        try {
          return t(V);
        } catch {
          try {
            return t.call(null, V);
          } catch {
            return t.call(this, V);
          }
        }
      }
      var G = [], y = !1, X, W = -1;
      function h() {
        !y || !X || (y = !1, X.length ? G = X.concat(G) : W = -1, G.length && r());
      }
      function r() {
        if (!y) {
          var V = Z(h);
          y = !0;
          for (var c = G.length; c; ) {
            for (X = G, G = []; ++W < c; )
              X && X[W].run();
            W = -1, c = G.length;
          }
          X = null, y = !1, o(V);
        }
      }
      l.nextTick = function(V) {
        var c = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n = 1; n < arguments.length; n++)
            c[n - 1] = arguments[n];
        G.push(new L(V, c)), G.length === 1 && !y && Z(r);
      };
      function L(V, c) {
        this.fun = V, this.array = c;
      }
      L.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, l.title = "browser", l.browser = !0, l.env = {}, l.argv = [], l.version = "", l.versions = {};
      function u() {
      }
      l.on = u, l.addListener = u, l.once = u, l.off = u, l.removeListener = u, l.removeAllListeners = u, l.emit = u, l.prependListener = u, l.prependOnceListener = u, l.listeners = function(V) {
        return [];
      }, l.binding = function(V) {
        throw new Error("process.binding is not supported");
      }, l.cwd = function() {
        return "/";
      }, l.chdir = function(V) {
        throw new Error("process.chdir is not supported");
      }, l.umask = function() {
        return 0;
      };
    },
    /* 70 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return C;
      });
      var i = l(1), t = l(71), s = l(73), b = l(213), Z = l(214), o = l(215), G = l(216);
      l(1).glMatrix.setMatrixArrayType(Array);
      function y(N, I) {
        var J = Object.keys(N);
        if (Object.getOwnPropertySymbols) {
          var T = Object.getOwnPropertySymbols(N);
          I && (T = T.filter(function(K) {
            return Object.getOwnPropertyDescriptor(N, K).enumerable;
          })), J.push.apply(J, T);
        }
        return J;
      }
      function X(N) {
        for (var I = 1; I < arguments.length; I++) {
          var J = arguments[I] != null ? arguments[I] : {};
          I % 2 ? y(Object(J), !0).forEach(function(T) {
            W(N, T, J[T]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(N, Object.getOwnPropertyDescriptors(J)) : y(Object(J)).forEach(function(T) {
            Object.defineProperty(N, T, Object.getOwnPropertyDescriptor(J, T));
          });
        }
        return N;
      }
      function W(N, I, J) {
        return I in N ? Object.defineProperty(N, I, { value: J, enumerable: !0, configurable: !0, writable: !0 }) : N[I] = J, N;
      }
      const h = Symbol.for("spritejs_changedAttrs"), r = Symbol.for("spritejs_attributes"), L = Symbol("resolution"), u = Symbol("animations"), V = Symbol("eventListeners"), c = Symbol("captureEventListeners"), n = Symbol("filters"), e = Symbol("display"), a = Symbol("program"), Y = Symbol("shaderAttrs"), R = Symbol("uniforms");
      class C {
        constructor(I = {}) {
          this.attributes = new this.constructor.Attr(this), this[L] = {
            width: 300,
            height: 150
          }, Object.assign(this.attributes, I), this[u] = /* @__PURE__ */ new Set(), this[V] = {}, this[c] = {};
        }
        get ancestors() {
          let I = this.parent;
          const J = [];
          for (; I; )
            J.push(I), I = I.parent;
          return J;
        }
        get animations() {
          return this[u];
        }
        get filters() {
          return this[n] || this.parent && this.parent.filters;
        }
        get isVisible() {
          return !1;
        }
        get layer() {
          return this.parent ? this.parent.layer : null;
        }
        get localMatrix() {
          const I = this.transformMatrix, {
            x: J,
            y: T
          } = this.attributes;
          return I[4] += J, I[5] += T, I;
        }
        get opacity() {
          let I = this.attributes.opacity;
          return this.parent && this.parent.opacity != null && (I *= this.parent.opacity), I;
        }
        get parentNode() {
          return this.parent;
        }
        get nextSibling() {
          return this.getNodeNearBy(1);
        }
        get previousSibling() {
          return this.getNodeNearBy(-1);
        }
        get program() {
          return this[a];
        }
        /* get parent defined by connect method */
        get renderer() {
          return this.parent ? this.parent.renderer : null;
        }
        get renderMatrix() {
          if (this.__cacheRenderMatrix)
            return this.__cacheRenderMatrix;
          let I = this.localMatrix;
          const J = this.parent;
          if (J) {
            const T = J.__cacheRenderMatrix || J.renderMatrix;
            T && (I = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), T, I));
          }
          return I;
        }
        get worldScaling() {
          const I = this.renderMatrix;
          return [Math.hypot(I[0], I[1]), Math.hypot(I[2], I[3])];
        }
        get worldRotation() {
          const I = this.renderMatrix;
          return Math.atan2(I[1], I[3]);
        }
        get worldPosition() {
          const I = this.renderMatrix;
          return [I[4], I[5]];
        }
        get uniforms() {
          return this[R];
        }
        /* get zOrder defined by connect method */
        /* attributes */
        get className() {
          return this.attributes.className;
        }
        set className(I) {
          this.attributes.className = I;
        }
        get id() {
          return this.attributes.id;
        }
        set id(I) {
          this.attributes.id = I;
        }
        get name() {
          return this.attributes.name;
        }
        set name(I) {
          this.attributes.name = I;
        }
        get zIndex() {
          return this.attributes.zIndex;
        }
        set zIndex(I) {
          this.attributes.zIndex = I;
        }
        get mesh() {
          return null;
        }
        get shaderAttrs() {
          return this[Y] || {};
        }
        activateAnimations() {
          const I = this.layer;
          if (I) {
            const J = this[u];
            J.forEach((K) => {
              K.baseTimeline = I.timeline, K.play(), K.finished.then(() => {
                J.delete(K);
              });
            });
            const T = this.children;
            T && T.forEach((K) => {
              K.activateAnimations && K.activateAnimations();
            });
          }
        }
        addEventListener(I, J, T = {}) {
          I === "mousewheel" && (I = "wheel"), typeof T == "boolean" && (T = {
            capture: T
          });
          const {
            capture: K,
            once: S
          } = T, H = K ? c : V;
          return this[H][I] = this[H][I] || [], this[H][I].push({
            listener: J,
            once: S
          }), this;
        }
        animate(I, J) {
          const T = new s.default(this, I, J);
          return this.effects && T.applyEffects(this.effects), this.layer && (T.baseTimeline = this.layer.timeline, T.play(), T.finished.then(() => {
            this[u].delete(T);
          })), this[u].add(T), T;
        }
        attr(...I) {
          if (I.length === 0)
            return this.attributes[r];
          if (I.length > 1) {
            let [J, T] = I;
            return typeof T == "function" && (T = T(this.attr(J))), this.setAttribute(J, T), this;
          }
          return typeof I[0] == "string" ? this.getAttribute(I[0]) : (Object.assign(this.attributes, I[0]), this);
        }
        cloneNode() {
          const I = new this.constructor(), J = this.attributes[h];
          return I.attr(J), I;
        }
        connect(I, J) {
          Object.defineProperty(this, "parent", {
            value: I,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: J,
            writable: !1,
            configurable: !0
          }), I.timeline && this.activateAnimations(), this.setResolution(I.getResolution()), this.forceUpdate(), this.dispatchEvent({
            type: "append",
            detail: {
              parent: I,
              zOrder: J
            }
          });
        }
        contains(I) {
          for (; I && this !== I; )
            I = I.parent;
          return !!I;
        }
        deactivateAnimations() {
          this[u].forEach((J) => J.cancel());
          const I = this.children;
          I && I.forEach((J) => {
            J.deactivateAnimations && J.deactivateAnimations();
          });
        }
        disconnect() {
          const {
            parent: I,
            zOrder: J
          } = this;
          delete this.parent, delete this.zOrder, this.deactivateAnimations(), this.dispatchEvent({
            type: "remove",
            detail: {
              parent: I,
              zOrder: J
            }
          }), I && I.forceUpdate();
        }
        dispatchEvent(I) {
          I instanceof Z.default || (I = new Z.default(I)), I.target = this;
          let J = I.type;
          J === "mousewheel" && (J = "wheel");
          const T = [this];
          let K = this.parent;
          for (; I.bubbles && K; )
            T.push(K), K = K.parent;
          for (let S = T.length - 1; S >= 0; S--) {
            const H = T[S], w = H[c] && H[c][J];
            if (w && w.length && (I.currentTarget = H, w.forEach(({
              listener: P,
              once: B
            }) => {
              P.call(this, I), B && T.removeEventListener(P);
            }), delete I.currentTarget), !I.bubbles && I.cancelBubble)
              break;
          }
          if (!I.cancelBubble)
            for (let S = 0; S < T.length; S++) {
              const H = T[S], w = H[V] && H[V][J];
              if (w && w.length && (I.currentTarget = H, w.forEach(({
                listener: P,
                once: B
              }) => {
                P.call(this, I), B && T.removeEventListener(P);
              }), delete I.currentTarget), !I.bubbles || I.cancelBubble)
                break;
            }
        }
        dispatchPointerEvent(I) {
          const {
            layerX: J,
            layerY: T
          } = I;
          return this.isPointCollision(J, T) ? (this.dispatchEvent(I), !0) : !1;
        }
        draw(I = []) {
          const J = this.mesh;
          if (J) {
            if (Object(o.applyFilters)(J, this.filters), I.push(J), this[a]) {
              J.setProgram(this[a]);
              const T = this[Y];
              T && Object.entries(T).forEach(([S, H]) => {
                J.setAttribute(S, H);
              });
              const K = this[R];
              if (this[R]) {
                const S = {};
                Object.entries(K).forEach(([H, w]) => {
                  typeof w == "function" && (w = w(this, H)), S[H] = w;
                }), J.setUniforms(S);
              }
            }
            Object(G.default)(this, J);
          }
          return I;
        }
        forceUpdate() {
          this.parent && this.parent.forceUpdate();
        }
        getAttribute(I) {
          return this.attributes[I];
        }
        getListeners(I, {
          capture: J = !1
        } = {}) {
          return [...this[J ? c : V][I] || []];
        }
        getNodeNearBy(I = 1) {
          if (!this.parent)
            return null;
          if (I === 0)
            return this;
          const J = this.parent.children, T = J.indexOf(this);
          return J[T + I];
        }
        getWorldPosition(I, J) {
          const T = this.renderMatrix, K = I * T[0] + J * T[2] + T[4], S = I * T[1] + J * T[3] + T[5];
          return [K, S];
        }
        getOffsetPosition(I, J) {
          const T = i.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this.renderMatrix), K = I * T[0] + J * T[2] + T[4], S = I * T[1] + J * T[3] + T[5];
          return [K, S];
        }
        getResolution() {
          return X({}, this[L]);
        }
        isPointCollision(I, J) {
          if (!this.mesh)
            return !1;
          const T = this.attributes.pointerEvents;
          if (T === "none" || T !== "all" && !this.isVisible)
            return !1;
          let K = "both";
          return T === "visibleFill" && (K = "fill"), T === "visibleStroke" && (K = "stroke"), this.mesh.isPointCollision(I, J, K);
        }
        onPropertyChange(I, J, T) {
          I !== "id" && I !== "name" && I !== "className" && I !== "pointerEvents" && I !== "passEvents" && this.forceUpdate(), I === "filter" && (this[n] = Object(o.parseFilterString)(J)), I === "zIndex" && this.parent && this.parent.reorder();
        }
        setAttribute(I, J) {
          I === "attrs" && this.attr(J), this.attributes[I] = J;
        }
        setMouseCapture() {
          this.layer && (this.layer.__mouseCapturedTarget = this);
        }
        // layer.renderer.createProgram(fragmentShader, vertexShader, attributeOptions)
        setProgram(I) {
          this[a] = I, this.forceUpdate();
        }
        setShaderAttribute(I, J) {
          this[Y] = this[Y] || {}, this[Y][I] = J, this.forceUpdate();
        }
        setUniforms(I) {
          this[R] = this[R] || {}, Object.assign(this[R], I), this.forceUpdate();
        }
        setResolution({
          width: I,
          height: J
        }) {
          const {
            width: T,
            height: K
          } = this[L];
          (T !== I || K !== J) && (this[L] = {
            width: I,
            height: J
          }, this.forceUpdate(), this.dispatchEvent({
            type: "resolutionchange",
            detail: {
              width: I,
              height: J
            }
          }));
        }
        show() {
          this.attributes.display === "none" && (this.attributes.display = this[e] || "");
        }
        hide() {
          this.attributes.display !== "none" && (this[e] = this.attributes.display, this.attributes.display = "none");
        }
        releaseMouseCapture() {
          this.layer && this.layer.__mouseCapturedTarget === this && (this.layer.__mouseCapturedTarget = null);
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        removeAllListeners(I, J = {}) {
          typeof J == "boolean" && (J = {
            capture: J
          });
          const K = J.capture ? c : V;
          return this[K][I] && (this[K][I] = []), this;
        }
        removeAttribute(I) {
          this.setAttribute(I, null);
        }
        removeEventListener(I, J, T = {}) {
          typeof T == "boolean" && (T = {
            capture: T
          });
          const S = T.capture ? c : V;
          if (this[S][I]) {
            const H = this[S][I];
            if (H)
              for (let w = 0; w < H.length; w++) {
                const {
                  listener: P
                } = H[w];
                if (P === J) {
                  this[S][I].splice(w, 1);
                  break;
                }
              }
          }
          return this;
        }
        transition(I, J = "linear") {
          const T = this, K = Symbol("animation");
          J = J || "linear";
          let S = 0;
          return typeof I == "object" && (S = I.delay || 0, I = I.duration), {
            [K]: null,
            cancel(H = !1) {
              const w = this[K];
              w && w.cancel(H);
            },
            end() {
              const H = this[K];
              H && (H.playState === "running" || H.playState === "pending") && H.finish();
            },
            reverse() {
              const H = this[K];
              if (H)
                if (H.playState === "running" || H.playState === "pending")
                  H.playbackRate = -H.playbackRate;
                else {
                  const w = H.timing.direction;
                  H.timing.direction = w === "reverse" ? "normal" : "reverse", H.play();
                }
              return H.finished;
            },
            attr(H, w) {
              return this.end(), typeof H == "string" && (H = {
                [H]: w
              }), Object.entries(H).forEach(([P, B]) => {
                typeof B == "function" && (H[P] = B(T.attr(P)));
              }), this[K] = T.animate([H], {
                duration: I * 1e3,
                delay: S * 1e3,
                fill: "forwards",
                easing: J
              }), this[K].finished;
            }
          };
        }
        updateContours() {
        }
      }
      W(C, "Attr", t.default), b.default.registerNode(C, "node");
    },
    /* 71 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return C;
      });
      var i = l(1), t = l(12), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const b = Symbol.for("spritejs_setAttributeDefault"), Z = Symbol.for("spritejs_declareAlias"), o = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), y = Symbol.for("spritejs_attributes"), X = Symbol.for("spritejs_changedAttrs"), W = Symbol("subject"), h = Symbol("attr"), r = Symbol("default"), L = Symbol("alias");
      function u(N, [I, J]) {
        let T = i.mat2d.fromValues(1, 0, 0, 1, 0, 0);
        return [...N].forEach(([K, S]) => {
          if ((I || J) && (T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [I, J])), K === "matrix")
            T = i.mat2d.multiply(T, T, S);
          else if (K === "offsetTranslate")
            T[4] += S[0], T[5] += S[1];
          else if (K === "offsetRotate")
            T = i.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), T, S);
          else if (K === "skew") {
            const [H, w] = S;
            T = i.mat2d.multiply(T, T, i.mat2d.fromValues(1, Math.tan(w), Math.tan(H), 1, 0, 0));
          } else
            i.mat2d[K](T, T, S);
          (I || J) && (T = i.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-I, -J]));
        }), T;
      }
      const V = Symbol("transformMatrix"), c = Symbol("transforms"), n = Symbol("changedAttrs"), e = Symbol("lastChangedAttr"), a = Symbol("offsetFigure");
      function Y(N, I, J) {
        const T = N[h][I];
        if (N[o](I, J, !1) || N[e] !== I) {
          const S = N[c];
          S.has(I) && S.delete(I), J && (I === "rotate" && (J = Math.PI * J / 180), I === "scale" && (J = J.map((H) => Math.abs(H) > 1e-5 ? H : 1 / H > 0 ? 1e-5 : -1e-5)), S.set(I, J)), N[V] = null, N[W].onPropertyChange(I, J, T, N);
        }
      }
      function R(N) {
        const I = N[a], J = N.offsetDistance * I.getTotalLength(), T = I.getPointAtLength(J);
        if (T) {
          const K = N[c];
          let S = N.offsetRotate;
          S === "auto" ? S = T.angle : S === "reverse" ? S = Math.PI + T.angle : S = Math.PI * S / 180, K.set("offsetRotate", S), K.set("offsetTranslate", [T.x, T.y]), N[V] = null;
        }
      }
      class C {
        static setDefault(I, ...J) {
          return I[b](...J);
        }
        static declareAlias(I, ...J) {
          return I[Z](...J);
        }
        static setAttribute(I, ...J) {
          return I[o](...J);
        }
        static getAttribute(I, ...J) {
          return I[G](...J);
        }
        static getAttributes(I) {
          return I[y];
        }
        static getChangedAttributes(I) {
          return I[X];
        }
        constructor(I) {
          this[W] = I, this[h] = {}, this[V] = i.mat2d.fromValues(1, 0, 0, 1, 0, 0), this[c] = /* @__PURE__ */ new Map(), this[r] = {}, this[L] = [], Object.defineProperty(I, "transformMatrix", {
            get: () => (this[V] || (this[V] = u(this[c], this.transformOrigin)), [...this[V]])
          }), this[b]({
            id: "",
            name: "",
            className: "",
            /* class */
            x: 0,
            y: 0,
            /* pos */
            transformOrigin: [0, 0],
            transform: "",
            translate: [0, 0],
            rotate: 0,
            scale: [1, 1],
            skew: [0, 0],
            opacity: 1,
            zIndex: 0,
            offsetPath: void 0,
            offsetDistance: 0,
            offsetRotate: "auto",
            pointerEvents: "visible",
            // none | visible | visibleFill | visibleStroke | all
            filter: "none",
            display: ""
          }), this[Z]("class", "pos"), this[n] = /* @__PURE__ */ new Set(), this[a] = new t.Figure2D({
            scale: 5,
            simplify: 0
          });
        }
        get [X]() {
          const I = {};
          return [...this[n]].forEach((J) => {
            I[J] = this[h][J];
          }), I;
        }
        get [y]() {
          const I = Object.assign({}, this[h]);
          for (let J = 0; J < this[L].length; J++) {
            const T = this[L][J];
            I[T] = this[T];
          }
          return I;
        }
        [b](I) {
          Object.assign(this[r], I), Object.assign(this[h], I);
        }
        [Z](...I) {
          this[L].push(...I);
        }
        [o](I, J, T = !0) {
          const K = this[h][I], S = this[W];
          return J == null && (J = this[r][I]), Object(s.compareValue)(K, J) ? !1 : (this[h][I] = J, this[n].has(I) && this[n].delete(I), this[n].add(I), this[e] = I, T && S.onPropertyChange(I, J, K, this), !0);
        }
        [G](I) {
          return this[h][I];
        }
        set id(I) {
          this[o]("id", I);
        }
        get id() {
          return this[G]("id");
        }
        set name(I) {
          this[o]("name", I);
        }
        get name() {
          return this[G]("name");
        }
        set className(I) {
          this[o]("className", I);
        }
        get className() {
          return this[G]("className");
        }
        set class(I) {
          this.className = I;
        }
        get class() {
          return this.className;
        }
        get x() {
          return this[G]("x");
        }
        set x(I) {
          this[o]("x", Object(s.toNumber)(I));
        }
        get y() {
          return this[G]("y");
        }
        set y(I) {
          this[o]("y", Object(s.toNumber)(I));
        }
        get pos() {
          return [this.x, this.y];
        }
        set pos(I) {
          I = Object(s.toArray)(I), Array.isArray(I) || (I = [I, I]), this.x = I[0], this.y = I[1];
        }
        get transform() {
          return this[G]("transform");
        }
        set transform(I) {
          let J = null;
          if (Array.isArray(I) && (J = I, I = `matrix(${I.map(s.toNumber).join()})`), typeof I == "string")
            I = I.replace(/\s*,\s*/g, ",");
          else if (I != null)
            throw new TypeError("Invalid transform value.");
          const T = this[h].transform;
          if (this[o]("transform", I, !1)) {
            const K = this[c];
            if (K.has("matrix") && K.delete("matrix"), J)
              K.set("matrix", J);
            else if (I) {
              const S = I.match(/(matrix|translate|rotate|scale|skew)\([^()]+\)/g);
              if (S) {
                let H = i.mat2d.fromValues(1, 0, 0, 1, 0, 0);
                for (let w = 0; w < S.length; w++) {
                  const B = S[w].match(/^(matrix|translate|rotate|scale|skew)\(([^()]+)\)/);
                  if (B) {
                    let [, D, z] = B;
                    D === "rotate" ? z = Math.PI * parseFloat(z) / 180 : z = z.trim().split(/[\s,]+/).map((U) => Object(s.toNumber)(U)), D === "matrix" ? H = i.mat2d.multiply(H, H, z) : D === "skew" ? H = i.mat2d.multiply(H, H, i.mat2d.fromValues(1, Math.tan(z[1]), Math.tan(z[0]), 1, 0, 0)) : i.mat2d[D](H, H, z), K.set("matrix", H);
                  }
                }
              } else
                throw new TypeError("Invalid transform value.");
            }
            this[V] = null, this[W].onPropertyChange("transform", I, T, this);
          }
        }
        get transformOrigin() {
          return this[G]("transformOrigin");
        }
        set transformOrigin(I) {
          I = Object(s.toArray)(I, !0), I != null && !Array.isArray(I) && (I = [I, I]), this[o]("transformOrigin", I) && (this[V] = null);
        }
        get rotate() {
          return this[G]("rotate");
        }
        set rotate(I) {
          Y(this, "rotate", I);
        }
        get translate() {
          return this[G]("translate");
        }
        set translate(I) {
          I = Object(s.toArray)(I, !0), I != null && !Array.isArray(I) && (I = [I, I]), Y(this, "translate", I);
        }
        get scale() {
          return this[G]("scale");
        }
        set scale(I) {
          I = Object(s.toArray)(I, !0), I != null && !Array.isArray(I) && (I = [I, I]), Y(this, "scale", I);
        }
        get skew() {
          return this[G]("skew");
        }
        set skew(I) {
          I = Object(s.toArray)(I, !0), I != null && !Array.isArray(I) && (I = [I, I]), Y(this, "skew", I);
        }
        get opacity() {
          return this[G]("opacity");
        }
        set opacity(I) {
          I != null && (I = Number(I)), this[o]("opacity", I);
        }
        get zIndex() {
          return this[G]("zIndex");
        }
        set zIndex(I) {
          I != null && (I = Number(I)), this[o]("zIndex", I);
        }
        get offsetPath() {
          return this[G]("offsetPath");
        }
        set offsetPath(I) {
          this[o]("offsetPath", I) && (this[a].beginPath(), I != null && this[a].addPath(I), R(this));
        }
        get offsetDistance() {
          return this[G]("offsetDistance");
        }
        set offsetDistance(I) {
          this[o]("offsetDistance", Object(s.toNumber)(I)) && R(this);
        }
        get offsetRotate() {
          return this[G]("offsetRotate");
        }
        set offsetRotate(I) {
          this[o]("offsetRotate", I), R(this);
        }
        get pointerEvents() {
          return this[G]("pointerEvents");
        }
        set pointerEvents(I) {
          if (I != null && I !== "none" && I !== "visible" && I !== "visibleFill" && I !== "visibleStroke" && I !== "all")
            throw new TypeError("Invalid pointerEvents type.");
          this[o]("pointerEvents", I);
        }
        get filter() {
          return this[G]("filter");
        }
        set filter(I) {
          this[o]("filter", I);
        }
        get display() {
          return this[G]("display");
        }
        set display(I) {
          this[o]("display", I);
        }
        /* istanbul ignore next */
        set offset(I) {
        }
      }
    },
    /* 72 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "sizeToPixel", function() {
        return i;
      }), l.d(d, "toString", function() {
        return t;
      }), l.d(d, "toNumber", function() {
        return s;
      }), l.d(d, "toArray", function() {
        return b;
      }), l.d(d, "compareValue", function() {
        return Z;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(o, G) {
        const y = o.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/);
        y ? o = {
          size: parseFloat(y[1]),
          unit: y[2]
        } : o = {
          size: parseFloat(o),
          unit: "px"
        };
        let {
          size: X,
          unit: W
        } = o;
        if (W === "pt")
          X /= 0.75;
        else if (W === "pc")
          X *= 16;
        else if (W === "in")
          X *= 96;
        else if (W === "cm")
          X *= 96 / 2.54;
        else if (W === "mm")
          X *= 96 / 25.4;
        else if (W === "em" || W === "rem" || W === "ex") {
          if (!G && typeof getComputedStyle == "function" && typeof document < "u") {
            const h = getComputedStyle(document.documentElement).fontSize;
            h ? G = i(h, 16) : G = 16;
          }
          X *= G, W === "ex" && (X /= 2);
        } else if (W === "q")
          X *= 96 / 25.4 / 4;
        else if (W === "vw" || W === "vh") {
          if (typeof document < "u") {
            const h = W === "vw" ? window.innerWidth || document.documentElement.clientWidth : window.innerHeight || document.documentElement.clientHeight;
            X *= h / 100;
          }
        } else if ((W === "vmax" || W === "vmin") && typeof document < "u") {
          const h = window.innerWidth || document.documentElement.clientWidth, r = window.innerHeight || document.documentElement.clientHeight;
          W === "vmax" ? X *= Math.max(h, r) / 100 : X *= Math.min(h, r) / 100;
        }
        return X;
      }
      function t(o) {
        return o == null ? o : String(o);
      }
      function s(o) {
        if (o == null)
          return o;
        if (typeof o == "string" && (o = i(o)), !Number.isFinite(o))
          throw new TypeError("Invalid value");
        return o;
      }
      function b(o, G = !1) {
        return o === "" ? null : (typeof o == "string" && (o = o.split(/[\s,]+/g)), Array.isArray(o) && (G && (o = o.map(s)), o.length === 1) ? o[0] : o);
      }
      function Z(o, G) {
        if (Array.isArray(o) && Array.isArray(G)) {
          if (o.length !== G.length)
            return !1;
          for (let y = 0; y < o.length; y++)
            if (o[y] !== G[y])
              return !1;
          return !0;
        }
        return o == null && G == null || o === G;
      }
    },
    /* 73 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return W;
      });
      var i = l(74), t = l(32), s = /* @__PURE__ */ l.n(t), b = l(68), Z = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      function o() {
        return o = Object.assign || function(h) {
          for (var r = 1; r < arguments.length; r++) {
            var L = arguments[r];
            for (var u in L)
              Object.prototype.hasOwnProperty.call(L, u) && (h[u] = L[u]);
          }
          return h;
        }, o.apply(this, arguments);
      }
      function G(h) {
        if (typeof h == "string") {
          if (h = h.trim(), /^[0-9.]+%$/.test(h))
            return parseFloat(h) / 100;
          if (/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/.test(h))
            return Object(Z.sizeToPixel)(h);
        }
        return h;
      }
      function y(h, r, L, u, V) {
        return typeof h == "string" && (h = s()(h)), typeof r == "string" && (r = s()(r)), i.Effects.default(h, r, L, u, V);
      }
      function X(h, r, L, u, V) {
        return i.Effects.default(h, r, L, u, V);
      }
      i.Effects.default = function(h, r, L, u, V) {
        return Array.isArray(h) && Array.isArray(r) ? h.map((c, n) => c + (L - u) / (V - u) * (r[n] - c)) : typeof h == "number" && typeof r == "number" ? h + (L - u) / (V - u) * (r - h) : L - u > V - L ? r : h;
      }, i.Effects.fillColor = y, i.Effects.strokeColor = y, i.Effects.bgcolor = y, i.Effects.borderColor = y, i.Effects.text = X;
      class W extends i.Animator {
        constructor(r, L, u) {
          const V = r.attr();
          Object.entries(V).forEach(([c, n]) => {
            V[c] = i.Effects[c] ? n : G(n);
          }), L = L.map((c) => {
            let n = o({}, c);
            const e = {};
            return Object.entries(n).forEach(([a, Y]) => {
              e[a] = i.Effects[a] ? Y : G(Y);
            }), e;
          }), super(V, L, u), this.target = r, this.setter = function(c, n) {
            n.attr(c);
          };
        }
        get playState() {
          return this.target.parent ? super.playState : "idle";
        }
        get finished() {
          return super.finished.then(() => {
            const r = this;
            return new Promise((L) => {
              function u() {
                r.setter(r.frame, r.target);
                const V = r.playState;
                V === "finished" || V === "idle" ? (Object(b.cancelAnimationFrame)(r.requestId), L()) : Object(b.requestAnimationFrame)(u);
              }
              u();
            });
          });
        }
        finish() {
          super.finish(), Object(b.cancelAnimationFrame)(this.requestId), this.setter(this.frame, this.target);
        }
        play() {
          if (!this.target.parent || this.playState === "running")
            return;
          super.play(), this.setter(this.frame, this.target);
          const r = this;
          this.ready.then(() => {
            r.setter(r.frame, r.target), r.requestId = Object(b.requestAnimationFrame)(function L() {
              const u = r.target;
              if (typeof document < "u" && document.documentElement && document.documentElement.contains && u.layer && u.layer.canvas && !document.documentElement.contains(u.layer.canvas)) {
                r.cancel();
                return;
              }
              const V = r.playState;
              r.setter(r.frame, r.target), V !== "idle" && (V === "running" ? r.requestId = Object(b.requestAnimationFrame)(L) : (V === "paused" || V === "pending" && r.timeline.currentTime < 0) && r.ready.then(() => {
                r.setter(r.frame, r.target), r.requestId = Object(b.requestAnimationFrame)(L);
              }));
            });
          });
        }
        cancel(r = !1) {
          Object(b.cancelAnimationFrame)(this.requestId), r ? (this.setter(this.frame, this.target), super.cancel()) : (super.cancel(), this.setter(this.frame, this.target));
        }
      }
    },
    /* 74 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.Timeline = d.Effects = d.Easings = d.Animator = void 0;
      var i = l(75), t = y(i), s = l(187), b = y(s), Z = l(188), o = l(190), G = y(o);
      function y(X) {
        return X && X.__esModule ? X : { default: X };
      }
      d.Animator = G.default, d.Easings = Z.Easings, d.Effects = b.default, d.Timeline = t.default;
    },
    /* 75 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      });
      var i = l(76), t = c(i), s = l(133), b = c(s), Z = l(141), o = c(Z), G = l(164), y = c(G), X = l(170), W = c(X), h = l(171), r = c(h), L = l(175), u = c(L), V = l(186);
      function c(T) {
        return T && T.__esModule ? T : { default: T };
      }
      var n = (0, V.createNowTime)(), e = {
        originTime: 0,
        playbackRate: 1
      }, a = (0, u.default)("timeMark"), Y = (0, u.default)("playbackRate"), R = (0, u.default)("timers"), C = (0, u.default)("originTime"), N = (0, u.default)("setTimer"), I = (0, u.default)("parent"), J = function() {
        function T(K, S) {
          (0, W.default)(this, T), K instanceof T && (S = K, K = {}), K = (0, y.default)({}, e, K), S && (this[I] = S);
          var H = K.nowtime || n;
          if (S)
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return S.currentTime;
              }
            });
          else {
            var w = H();
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return H() - w;
              }
            });
          }
          this[a] = [{
            globalTime: this.globalTime,
            localTime: -K.originTime,
            entropy: -K.originTime,
            playbackRate: K.playbackRate,
            globalEntropy: 0
          }], this[I] && (this[a][0].globalEntropy = this[I].entropy), this[C] = K.originTime, this[Y] = K.playbackRate, this[R] = new o.default();
        }
        return (0, r.default)(T, [{
          key: "markTime",
          value: function() {
            var S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, H = S.time, w = H === void 0 ? this.currentTime : H, P = S.entropy, B = P === void 0 ? this.entropy : P, D = S.playbackRate, z = D === void 0 ? this.playbackRate : D, U = {
              globalTime: this.globalTime,
              localTime: w,
              entropy: B,
              playbackRate: z,
              globalEntropy: this.globalEntropy
            };
            this[a].push(U);
          }
        }, {
          key: "fork",
          value: function(S) {
            return new T(S, this);
          }
        }, {
          key: "seekGlobalTime",
          value: function(S) {
            var H = this.seekTimeMark(S), w = this[a][H], P = w.entropy, B = w.playbackRate, D = w.globalTime;
            return D + (S - P) / Math.abs(B);
          }
        }, {
          key: "seekLocalTime",
          value: function(S) {
            var H = this.seekTimeMark(S), w = this[a][H], P = w.localTime, B = w.entropy, D = w.playbackRate;
            return D > 0 ? P + (S - B) : P - (S - B);
          }
        }, {
          key: "seekTimeMark",
          value: function(S) {
            var H = this[a], w = 0, P = H.length - 1;
            if (S <= H[w].entropy)
              return w;
            if (S >= H[P].entropy)
              return P;
            for (var B = Math.floor((w + P) / 2); B > w && B < P; ) {
              if (S === H[B].entropy)
                return B;
              S < H[B].entropy ? P = B : S > H[B].entropy && (w = B), B = Math.floor((w + P) / 2);
            }
            return w;
          }
        }, {
          key: "updateTimers",
          value: function() {
            var S = this, H = [].concat((0, b.default)(this[R]));
            H.forEach(function(w) {
              var P = (0, t.default)(w, 2), B = P[0], D = P[1];
              S[N](D.handler, D.time, B);
            });
          }
        }, {
          key: "clearTimeout",
          value: function(K) {
            function S(H) {
              return K.apply(this, arguments);
            }
            return S.toString = function() {
              return K.toString();
            }, S;
          }(function(K) {
            var S = this[R].get(K);
            S && S.timerID != null && (this[I] ? this[I].clearTimeout(S.timerID) : clearTimeout(S.timerID)), this[R].delete(K);
          })
        }, {
          key: "clearInterval",
          value: function(S) {
            return this.clearTimeout(S);
          }
        }, {
          key: "clear",
          value: function() {
            var S = this, H = this[R];
            [].concat((0, b.default)(H.keys())).forEach(function(w) {
              S.clearTimeout(w);
            });
          }
          /*
            setTimeout(func, {delay: 100, isEntropy: true})
            setTimeout(func, {entropy: 100})
            setTimeout(func, 100})
           */
        }, {
          key: "setTimeout",
          value: function(S) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 };
            return this[N](S, H);
          }
        }, {
          key: "setInterval",
          value: function(S) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 }, w = this, P = this[N](function B() {
              w[N](B, H, P), S();
            }, H);
            return P;
          }
        }, {
          key: N,
          value: function(S, H) {
            var w = this, P = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, u.default)("timerID");
            H = (0, V.formatDelay)(H);
            var B = this[R].get(P), D = void 0, z = null, U = void 0, O = void 0;
            B ? (this.clearTimeout(P), H.isEntropy ? D = (H.delay - (this.entropy - B.startEntropy)) / Math.abs(this.playbackRate) : D = (H.delay - (this.currentTime - B.startTime)) / this.playbackRate, U = B.startTime, O = B.startEntropy) : (D = H.delay / (H.isEntropy ? Math.abs(this.playbackRate) : this.playbackRate), U = this.currentTime, O = this.entropy);
            var ll = this[I], _ = ll ? ll.setTimeout.bind(ll) : setTimeout, Zl = H.heading;
            return !ll && Zl === !1 && D < 0 && (D = 1 / 0), (isFinite(D) || ll) && (D = Math.ceil(D), _ !== setTimeout && (D = { delay: D, heading: Zl }), z = _(function() {
              w[R].delete(P), S();
            }, D)), this[R].set(P, {
              timerID: z,
              handler: S,
              time: H,
              startTime: U,
              startEntropy: O
            }), P;
          }
        }, {
          key: "parent",
          get: function() {
            return this[I];
          }
        }, {
          key: "lastTimeMark",
          get: function() {
            return this[a][this[a].length - 1];
          }
        }, {
          key: "currentTime",
          get: function() {
            var S = this.lastTimeMark, H = S.localTime, w = S.globalTime;
            return H + (this.globalTime - w) * this.playbackRate;
          },
          set: function(S) {
            var H = this, w = this.currentTime, P = S, B = this[R];
            this.markTime({ time: S }), [].concat((0, b.default)(B)).forEach(function(D) {
              var z = (0, t.default)(D, 2), U = z[0], O = z[1];
              if (B.has(U)) {
                var ll = O.time, _ = ll.isEntropy, Zl = ll.delay, $ = ll.heading, ol = O.handler, al = O.startTime;
                if (_)
                  Zl === 0 && (ol(), H.clearTimeout(U));
                else {
                  var g = al + Zl;
                  (Zl === 0 || $ !== !1 && (P - w) * Zl <= 0 || w <= g && g <= P || w >= g && g >= P) && (ol(), H.clearTimeout(U));
                }
              }
            }), this.updateTimers();
          }
          // Both currentTime and entropy should be influenced by playbackRate.
          // If current playbackRate is negative, the currentTime should go backwards
          // while the entropy remain to go forwards.
          // Both of the initial values is set to -originTime
        }, {
          key: "entropy",
          get: function() {
            var S = this.lastTimeMark, H = S.entropy, w = S.globalEntropy;
            return H + Math.abs((this.globalEntropy - w) * this.playbackRate);
          },
          // get globalTime() {
          //   if(this[_parent]) {
          //     return this[_parent].currentTime;
          //   }
          //   return nowtime();
          // }
          // change entropy will NOT cause currentTime changing but may influence the pass
          // and the future of the timeline. (It may change the result of seek***Time)
          // While entropy is set, all the marks behind will be droped
          set: function(S) {
            if (this.entropy > S) {
              var H = this.seekTimeMark(S);
              this[a].length = H + 1;
            }
            this.markTime({ entropy: S }), this.updateTimers();
          }
        }, {
          key: "globalEntropy",
          get: function() {
            return this[I] ? this[I].entropy : this.globalTime;
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[Y];
          },
          set: function(S) {
            S !== this.playbackRate && (this.markTime({ playbackRate: S }), this[Y] = S, this.updateTimers());
          }
        }, {
          key: "paused",
          get: function() {
            if (this.playbackRate === 0)
              return !0;
            for (var S = this.parent; S; ) {
              if (S.playbackRate === 0)
                return !0;
              S = S.parent;
            }
            return !1;
          }
        }]), T;
      }();
      d.default = J;
    },
    /* 76 */
    /***/
    function(m, d, l) {
      d.__esModule = !0;
      var i = l(77), t = Z(i), s = l(129), b = Z(s);
      function Z(o) {
        return o && o.__esModule ? o : { default: o };
      }
      d.default = /* @__PURE__ */ function() {
        function o(G, y) {
          var X = [], W = !0, h = !1, r = void 0;
          try {
            for (var L = (0, b.default)(G), u; !(W = (u = L.next()).done) && (X.push(u.value), !(y && X.length === y)); W = !0)
              ;
          } catch (V) {
            h = !0, r = V;
          } finally {
            try {
              !W && L.return && L.return();
            } finally {
              if (h)
                throw r;
            }
          }
          return X;
        }
        return function(G, y) {
          if (Array.isArray(G))
            return G;
          if ((0, t.default)(Object(G)))
            return o(G, y);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }();
    },
    /* 77 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(78), __esModule: !0 };
    },
    /* 78 */
    /***/
    function(m, d, l) {
      l(79), l(125), m.exports = l(127);
    },
    /* 79 */
    /***/
    function(m, d, l) {
      l(80);
      for (var i = l(91), t = l(95), s = l(83), b = l(122)("toStringTag"), Z = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), o = 0; o < Z.length; o++) {
        var G = Z[o], y = i[G], X = y && y.prototype;
        X && !X[b] && t(X, b, G), s[G] = s.Array;
      }
    },
    /* 80 */
    /***/
    function(m, d, l) {
      var i = l(81), t = l(82), s = l(83), b = l(84);
      m.exports = l(88)(Array, "Array", function(Z, o) {
        this._t = b(Z), this._i = 0, this._k = o;
      }, function() {
        var Z = this._t, o = this._k, G = this._i++;
        return !Z || G >= Z.length ? (this._t = void 0, t(1)) : o == "keys" ? t(0, G) : o == "values" ? t(0, Z[G]) : t(0, [G, Z[G]]);
      }, "values"), s.Arguments = s.Array, i("keys"), i("values"), i("entries");
    },
    /* 81 */
    /***/
    function(m, d) {
      m.exports = function() {
      };
    },
    /* 82 */
    /***/
    function(m, d) {
      m.exports = function(l, i) {
        return { value: i, done: !!l };
      };
    },
    /* 83 */
    /***/
    function(m, d) {
      m.exports = {};
    },
    /* 84 */
    /***/
    function(m, d, l) {
      var i = l(85), t = l(87);
      m.exports = function(s) {
        return i(t(s));
      };
    },
    /* 85 */
    /***/
    function(m, d, l) {
      var i = l(86);
      m.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
        return i(t) == "String" ? t.split("") : Object(t);
      };
    },
    /* 86 */
    /***/
    function(m, d) {
      var l = {}.toString;
      m.exports = function(i) {
        return l.call(i).slice(8, -1);
      };
    },
    /* 87 */
    /***/
    function(m, d) {
      m.exports = function(l) {
        if (l == null)
          throw TypeError("Can't call method on  " + l);
        return l;
      };
    },
    /* 88 */
    /***/
    function(m, d, l) {
      var i = l(89), t = l(90), s = l(106), b = l(95), Z = l(83), o = l(107), G = l(121), y = l(123), X = l(122)("iterator"), W = !([].keys && "next" in [].keys()), h = "@@iterator", r = "keys", L = "values", u = function() {
        return this;
      };
      m.exports = function(V, c, n, e, a, Y, R) {
        o(n, c, e);
        var C = function(z) {
          if (!W && z in T)
            return T[z];
          switch (z) {
            case r:
              return function() {
                return new n(this, z);
              };
            case L:
              return function() {
                return new n(this, z);
              };
          }
          return function() {
            return new n(this, z);
          };
        }, N = c + " Iterator", I = a == L, J = !1, T = V.prototype, K = T[X] || T[h] || a && T[a], S = K || C(a), H = a ? I ? C("entries") : S : void 0, w = c == "Array" && T.entries || K, P, B, D;
        if (w && (D = y(w.call(new V())), D !== Object.prototype && D.next && (G(D, N, !0), !i && typeof D[X] != "function" && b(D, X, u))), I && K && K.name !== L && (J = !0, S = function() {
          return K.call(this);
        }), (!i || R) && (W || J || !T[X]) && b(T, X, S), Z[c] = S, Z[N] = u, a)
          if (P = {
            values: I ? S : C(L),
            keys: Y ? S : C(r),
            entries: H
          }, R)
            for (B in P)
              B in T || s(T, B, P[B]);
          else
            t(t.P + t.F * (W || J), c, P);
        return P;
      };
    },
    /* 89 */
    /***/
    function(m, d) {
      m.exports = !0;
    },
    /* 90 */
    /***/
    function(m, d, l) {
      var i = l(91), t = l(92), s = l(93), b = l(95), Z = l(105), o = "prototype", G = function(y, X, W) {
        var h = y & G.F, r = y & G.G, L = y & G.S, u = y & G.P, V = y & G.B, c = y & G.W, n = r ? t : t[X] || (t[X] = {}), e = n[o], a = r ? i : L ? i[X] : (i[X] || {})[o], Y, R, C;
        r && (W = X);
        for (Y in W)
          R = !h && a && a[Y] !== void 0, !(R && Z(n, Y)) && (C = R ? a[Y] : W[Y], n[Y] = r && typeof a[Y] != "function" ? W[Y] : V && R ? s(C, i) : c && a[Y] == C ? function(N) {
            var I = function(J, T, K) {
              if (this instanceof N) {
                switch (arguments.length) {
                  case 0:
                    return new N();
                  case 1:
                    return new N(J);
                  case 2:
                    return new N(J, T);
                }
                return new N(J, T, K);
              }
              return N.apply(this, arguments);
            };
            return I[o] = N[o], I;
          }(C) : u && typeof C == "function" ? s(Function.call, C) : C, u && ((n.virtual || (n.virtual = {}))[Y] = C, y & G.R && e && !e[Y] && b(e, Y, C)));
      };
      G.F = 1, G.G = 2, G.S = 4, G.P = 8, G.B = 16, G.W = 32, G.U = 64, G.R = 128, m.exports = G;
    },
    /* 91 */
    /***/
    function(m, d) {
      var l = m.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
      typeof __g == "number" && (__g = l);
    },
    /* 92 */
    /***/
    function(m, d) {
      var l = m.exports = { version: "2.6.11" };
      typeof __e == "number" && (__e = l);
    },
    /* 93 */
    /***/
    function(m, d, l) {
      var i = l(94);
      m.exports = function(t, s, b) {
        if (i(t), s === void 0)
          return t;
        switch (b) {
          case 1:
            return function(Z) {
              return t.call(s, Z);
            };
          case 2:
            return function(Z, o) {
              return t.call(s, Z, o);
            };
          case 3:
            return function(Z, o, G) {
              return t.call(s, Z, o, G);
            };
        }
        return function() {
          return t.apply(s, arguments);
        };
      };
    },
    /* 94 */
    /***/
    function(m, d) {
      m.exports = function(l) {
        if (typeof l != "function")
          throw TypeError(l + " is not a function!");
        return l;
      };
    },
    /* 95 */
    /***/
    function(m, d, l) {
      var i = l(96), t = l(104);
      m.exports = l(100) ? function(s, b, Z) {
        return i.f(s, b, t(1, Z));
      } : function(s, b, Z) {
        return s[b] = Z, s;
      };
    },
    /* 96 */
    /***/
    function(m, d, l) {
      var i = l(97), t = l(99), s = l(103), b = Object.defineProperty;
      d.f = l(100) ? Object.defineProperty : function(o, G, y) {
        if (i(o), G = s(G, !0), i(y), t)
          try {
            return b(o, G, y);
          } catch {
          }
        if ("get" in y || "set" in y)
          throw TypeError("Accessors not supported!");
        return "value" in y && (o[G] = y.value), o;
      };
    },
    /* 97 */
    /***/
    function(m, d, l) {
      var i = l(98);
      m.exports = function(t) {
        if (!i(t))
          throw TypeError(t + " is not an object!");
        return t;
      };
    },
    /* 98 */
    /***/
    function(m, d) {
      m.exports = function(l) {
        return typeof l == "object" ? l !== null : typeof l == "function";
      };
    },
    /* 99 */
    /***/
    function(m, d, l) {
      m.exports = !l(100) && !l(101)(function() {
        return Object.defineProperty(l(102)("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 100 */
    /***/
    function(m, d, l) {
      m.exports = !l(101)(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 101 */
    /***/
    function(m, d) {
      m.exports = function(l) {
        try {
          return !!l();
        } catch {
          return !0;
        }
      };
    },
    /* 102 */
    /***/
    function(m, d, l) {
      var i = l(98), t = l(91).document, s = i(t) && i(t.createElement);
      m.exports = function(b) {
        return s ? t.createElement(b) : {};
      };
    },
    /* 103 */
    /***/
    function(m, d, l) {
      var i = l(98);
      m.exports = function(t, s) {
        if (!i(t))
          return t;
        var b, Z;
        if (s && typeof (b = t.toString) == "function" && !i(Z = b.call(t)) || typeof (b = t.valueOf) == "function" && !i(Z = b.call(t)) || !s && typeof (b = t.toString) == "function" && !i(Z = b.call(t)))
          return Z;
        throw TypeError("Can't convert object to primitive value");
      };
    },
    /* 104 */
    /***/
    function(m, d) {
      m.exports = function(l, i) {
        return {
          enumerable: !(l & 1),
          configurable: !(l & 2),
          writable: !(l & 4),
          value: i
        };
      };
    },
    /* 105 */
    /***/
    function(m, d) {
      var l = {}.hasOwnProperty;
      m.exports = function(i, t) {
        return l.call(i, t);
      };
    },
    /* 106 */
    /***/
    function(m, d, l) {
      m.exports = l(95);
    },
    /* 107 */
    /***/
    function(m, d, l) {
      var i = l(108), t = l(104), s = l(121), b = {};
      l(95)(b, l(122)("iterator"), function() {
        return this;
      }), m.exports = function(Z, o, G) {
        Z.prototype = i(b, { next: t(1, G) }), s(Z, o + " Iterator");
      };
    },
    /* 108 */
    /***/
    function(m, d, l) {
      var i = l(97), t = l(109), s = l(119), b = l(116)("IE_PROTO"), Z = function() {
      }, o = "prototype", G = function() {
        var y = l(102)("iframe"), X = s.length, W = "<", h = ">", r;
        for (y.style.display = "none", l(120).appendChild(y), y.src = "javascript:", r = y.contentWindow.document, r.open(), r.write(W + "script" + h + "document.F=Object" + W + "/script" + h), r.close(), G = r.F; X--; )
          delete G[o][s[X]];
        return G();
      };
      m.exports = Object.create || function(X, W) {
        var h;
        return X !== null ? (Z[o] = i(X), h = new Z(), Z[o] = null, h[b] = X) : h = G(), W === void 0 ? h : t(h, W);
      };
    },
    /* 109 */
    /***/
    function(m, d, l) {
      var i = l(96), t = l(97), s = l(110);
      m.exports = l(100) ? Object.defineProperties : function(Z, o) {
        t(Z);
        for (var G = s(o), y = G.length, X = 0, W; y > X; )
          i.f(Z, W = G[X++], o[W]);
        return Z;
      };
    },
    /* 110 */
    /***/
    function(m, d, l) {
      var i = l(111), t = l(119);
      m.exports = Object.keys || function(b) {
        return i(b, t);
      };
    },
    /* 111 */
    /***/
    function(m, d, l) {
      var i = l(105), t = l(84), s = l(112)(!1), b = l(116)("IE_PROTO");
      m.exports = function(Z, o) {
        var G = t(Z), y = 0, X = [], W;
        for (W in G)
          W != b && i(G, W) && X.push(W);
        for (; o.length > y; )
          i(G, W = o[y++]) && (~s(X, W) || X.push(W));
        return X;
      };
    },
    /* 112 */
    /***/
    function(m, d, l) {
      var i = l(84), t = l(113), s = l(115);
      m.exports = function(b) {
        return function(Z, o, G) {
          var y = i(Z), X = t(y.length), W = s(G, X), h;
          if (b && o != o) {
            for (; X > W; )
              if (h = y[W++], h != h)
                return !0;
          } else
            for (; X > W; W++)
              if ((b || W in y) && y[W] === o)
                return b || W || 0;
          return !b && -1;
        };
      };
    },
    /* 113 */
    /***/
    function(m, d, l) {
      var i = l(114), t = Math.min;
      m.exports = function(s) {
        return s > 0 ? t(i(s), 9007199254740991) : 0;
      };
    },
    /* 114 */
    /***/
    function(m, d) {
      var l = Math.ceil, i = Math.floor;
      m.exports = function(t) {
        return isNaN(t = +t) ? 0 : (t > 0 ? i : l)(t);
      };
    },
    /* 115 */
    /***/
    function(m, d, l) {
      var i = l(114), t = Math.max, s = Math.min;
      m.exports = function(b, Z) {
        return b = i(b), b < 0 ? t(b + Z, 0) : s(b, Z);
      };
    },
    /* 116 */
    /***/
    function(m, d, l) {
      var i = l(117)("keys"), t = l(118);
      m.exports = function(s) {
        return i[s] || (i[s] = t(s));
      };
    },
    /* 117 */
    /***/
    function(m, d, l) {
      var i = l(92), t = l(91), s = "__core-js_shared__", b = t[s] || (t[s] = {});
      (m.exports = function(Z, o) {
        return b[Z] || (b[Z] = o !== void 0 ? o : {});
      })("versions", []).push({
        version: i.version,
        mode: l(89) ? "pure" : "global",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
      });
    },
    /* 118 */
    /***/
    function(m, d) {
      var l = 0, i = Math.random();
      m.exports = function(t) {
        return "Symbol(".concat(t === void 0 ? "" : t, ")_", (++l + i).toString(36));
      };
    },
    /* 119 */
    /***/
    function(m, d) {
      m.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    },
    /* 120 */
    /***/
    function(m, d, l) {
      var i = l(91).document;
      m.exports = i && i.documentElement;
    },
    /* 121 */
    /***/
    function(m, d, l) {
      var i = l(96).f, t = l(105), s = l(122)("toStringTag");
      m.exports = function(b, Z, o) {
        b && !t(b = o ? b : b.prototype, s) && i(b, s, { configurable: !0, value: Z });
      };
    },
    /* 122 */
    /***/
    function(m, d, l) {
      var i = l(117)("wks"), t = l(118), s = l(91).Symbol, b = typeof s == "function", Z = m.exports = function(o) {
        return i[o] || (i[o] = b && s[o] || (b ? s : t)("Symbol." + o));
      };
      Z.store = i;
    },
    /* 123 */
    /***/
    function(m, d, l) {
      var i = l(105), t = l(124), s = l(116)("IE_PROTO"), b = Object.prototype;
      m.exports = Object.getPrototypeOf || function(Z) {
        return Z = t(Z), i(Z, s) ? Z[s] : typeof Z.constructor == "function" && Z instanceof Z.constructor ? Z.constructor.prototype : Z instanceof Object ? b : null;
      };
    },
    /* 124 */
    /***/
    function(m, d, l) {
      var i = l(87);
      m.exports = function(t) {
        return Object(i(t));
      };
    },
    /* 125 */
    /***/
    function(m, d, l) {
      var i = l(126)(!0);
      l(88)(String, "String", function(t) {
        this._t = String(t), this._i = 0;
      }, function() {
        var t = this._t, s = this._i, b;
        return s >= t.length ? { value: void 0, done: !0 } : (b = i(t, s), this._i += b.length, { value: b, done: !1 });
      });
    },
    /* 126 */
    /***/
    function(m, d, l) {
      var i = l(114), t = l(87);
      m.exports = function(s) {
        return function(b, Z) {
          var o = String(t(b)), G = i(Z), y = o.length, X, W;
          return G < 0 || G >= y ? s ? "" : void 0 : (X = o.charCodeAt(G), X < 55296 || X > 56319 || G + 1 === y || (W = o.charCodeAt(G + 1)) < 56320 || W > 57343 ? s ? o.charAt(G) : X : s ? o.slice(G, G + 2) : (X - 55296 << 10) + (W - 56320) + 65536);
        };
      };
    },
    /* 127 */
    /***/
    function(m, d, l) {
      var i = l(128), t = l(122)("iterator"), s = l(83);
      m.exports = l(92).isIterable = function(b) {
        var Z = Object(b);
        return Z[t] !== void 0 || "@@iterator" in Z || s.hasOwnProperty(i(Z));
      };
    },
    /* 128 */
    /***/
    function(m, d, l) {
      var i = l(86), t = l(122)("toStringTag"), s = i(/* @__PURE__ */ function() {
        return arguments;
      }()) == "Arguments", b = function(Z, o) {
        try {
          return Z[o];
        } catch {
        }
      };
      m.exports = function(Z) {
        var o, G, y;
        return Z === void 0 ? "Undefined" : Z === null ? "Null" : typeof (G = b(o = Object(Z), t)) == "string" ? G : s ? i(o) : (y = i(o)) == "Object" && typeof o.callee == "function" ? "Arguments" : y;
      };
    },
    /* 129 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(130), __esModule: !0 };
    },
    /* 130 */
    /***/
    function(m, d, l) {
      l(79), l(125), m.exports = l(131);
    },
    /* 131 */
    /***/
    function(m, d, l) {
      var i = l(97), t = l(132);
      m.exports = l(92).getIterator = function(s) {
        var b = t(s);
        if (typeof b != "function")
          throw TypeError(s + " is not iterable!");
        return i(b.call(s));
      };
    },
    /* 132 */
    /***/
    function(m, d, l) {
      var i = l(128), t = l(122)("iterator"), s = l(83);
      m.exports = l(92).getIteratorMethod = function(b) {
        if (b != null)
          return b[t] || b["@@iterator"] || s[i(b)];
      };
    },
    /* 133 */
    /***/
    function(m, d, l) {
      d.__esModule = !0;
      var i = l(134), t = s(i);
      function s(b) {
        return b && b.__esModule ? b : { default: b };
      }
      d.default = function(b) {
        if (Array.isArray(b)) {
          for (var Z = 0, o = Array(b.length); Z < b.length; Z++)
            o[Z] = b[Z];
          return o;
        } else
          return (0, t.default)(b);
      };
    },
    /* 134 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(135), __esModule: !0 };
    },
    /* 135 */
    /***/
    function(m, d, l) {
      l(125), l(136), m.exports = l(92).Array.from;
    },
    /* 136 */
    /***/
    function(m, d, l) {
      var i = l(93), t = l(90), s = l(124), b = l(137), Z = l(138), o = l(113), G = l(139), y = l(132);
      t(t.S + t.F * !l(140)(function(X) {
        Array.from(X);
      }), "Array", {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function(W) {
          var h = s(W), r = typeof this == "function" ? this : Array, L = arguments.length, u = L > 1 ? arguments[1] : void 0, V = u !== void 0, c = 0, n = y(h), e, a, Y, R;
          if (V && (u = i(u, L > 2 ? arguments[2] : void 0, 2)), n != null && !(r == Array && Z(n)))
            for (R = n.call(h), a = new r(); !(Y = R.next()).done; c++)
              G(a, c, V ? b(R, u, [Y.value, c], !0) : Y.value);
          else
            for (e = o(h.length), a = new r(e); e > c; c++)
              G(a, c, V ? u(h[c], c) : h[c]);
          return a.length = c, a;
        }
      });
    },
    /* 137 */
    /***/
    function(m, d, l) {
      var i = l(97);
      m.exports = function(t, s, b, Z) {
        try {
          return Z ? s(i(b)[0], b[1]) : s(b);
        } catch (G) {
          var o = t.return;
          throw o !== void 0 && i(o.call(t)), G;
        }
      };
    },
    /* 138 */
    /***/
    function(m, d, l) {
      var i = l(83), t = l(122)("iterator"), s = Array.prototype;
      m.exports = function(b) {
        return b !== void 0 && (i.Array === b || s[t] === b);
      };
    },
    /* 139 */
    /***/
    function(m, d, l) {
      var i = l(96), t = l(104);
      m.exports = function(s, b, Z) {
        b in s ? i.f(s, b, t(0, Z)) : s[b] = Z;
      };
    },
    /* 140 */
    /***/
    function(m, d, l) {
      var i = l(122)("iterator"), t = !1;
      try {
        var s = [7][i]();
        s.return = function() {
          t = !0;
        }, Array.from(s, function() {
          throw 2;
        });
      } catch {
      }
      m.exports = function(b, Z) {
        if (!Z && !t)
          return !1;
        var o = !1;
        try {
          var G = [7], y = G[i]();
          y.next = function() {
            return { done: o = !0 };
          }, G[i] = function() {
            return y;
          }, b(G);
        } catch {
        }
        return o;
      };
    },
    /* 141 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(142), __esModule: !0 };
    },
    /* 142 */
    /***/
    function(m, d, l) {
      l(143), l(125), l(79), l(144), l(157), l(160), l(162), m.exports = l(92).Map;
    },
    /* 143 */
    /***/
    function(m, d) {
    },
    /* 144 */
    /***/
    function(m, d, l) {
      var i = l(145), t = l(151), s = "Map";
      m.exports = l(152)(s, function(b) {
        return function() {
          return b(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function(Z) {
          var o = i.getEntry(t(this, s), Z);
          return o && o.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function(Z, o) {
          return i.def(t(this, s), Z === 0 ? 0 : Z, o);
        }
      }, i, !0);
    },
    /* 145 */
    /***/
    function(m, d, l) {
      var i = l(96).f, t = l(108), s = l(146), b = l(93), Z = l(147), o = l(148), G = l(88), y = l(82), X = l(149), W = l(100), h = l(150).fastKey, r = l(151), L = W ? "_s" : "size", u = function(V, c) {
        var n = h(c), e;
        if (n !== "F")
          return V._i[n];
        for (e = V._f; e; e = e.n)
          if (e.k == c)
            return e;
      };
      m.exports = {
        getConstructor: function(V, c, n, e) {
          var a = V(function(Y, R) {
            Z(Y, a, c, "_i"), Y._t = c, Y._i = t(null), Y._f = void 0, Y._l = void 0, Y[L] = 0, R != null && o(R, n, Y[e], Y);
          });
          return s(a.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function() {
              for (var R = r(this, c), C = R._i, N = R._f; N; N = N.n)
                N.r = !0, N.p && (N.p = N.p.n = void 0), delete C[N.i];
              R._f = R._l = void 0, R[L] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            delete: function(Y) {
              var R = r(this, c), C = u(R, Y);
              if (C) {
                var N = C.n, I = C.p;
                delete R._i[C.i], C.r = !0, I && (I.n = N), N && (N.p = I), R._f == C && (R._f = N), R._l == C && (R._l = I), R[L]--;
              }
              return !!C;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function(R) {
              r(this, c);
              for (var C = b(R, arguments.length > 1 ? arguments[1] : void 0, 3), N; N = N ? N.n : this._f; )
                for (C(N.v, N.k, this); N && N.r; )
                  N = N.p;
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function(R) {
              return !!u(r(this, c), R);
            }
          }), W && i(a.prototype, "size", {
            get: function() {
              return r(this, c)[L];
            }
          }), a;
        },
        def: function(V, c, n) {
          var e = u(V, c), a, Y;
          return e ? e.v = n : (V._l = e = {
            i: Y = h(c, !0),
            // <- index
            k: c,
            // <- key
            v: n,
            // <- value
            p: a = V._l,
            // <- previous entry
            n: void 0,
            // <- next entry
            r: !1
            // <- removed
          }, V._f || (V._f = e), a && (a.n = e), V[L]++, Y !== "F" && (V._i[Y] = e)), V;
        },
        getEntry: u,
        setStrong: function(V, c, n) {
          G(V, c, function(e, a) {
            this._t = r(e, c), this._k = a, this._l = void 0;
          }, function() {
            for (var e = this, a = e._k, Y = e._l; Y && Y.r; )
              Y = Y.p;
            return !e._t || !(e._l = Y = Y ? Y.n : e._t._f) ? (e._t = void 0, y(1)) : a == "keys" ? y(0, Y.k) : a == "values" ? y(0, Y.v) : y(0, [Y.k, Y.v]);
          }, n ? "entries" : "values", !n, !0), X(c);
        }
      };
    },
    /* 146 */
    /***/
    function(m, d, l) {
      var i = l(95);
      m.exports = function(t, s, b) {
        for (var Z in s)
          b && t[Z] ? t[Z] = s[Z] : i(t, Z, s[Z]);
        return t;
      };
    },
    /* 147 */
    /***/
    function(m, d) {
      m.exports = function(l, i, t, s) {
        if (!(l instanceof i) || s !== void 0 && s in l)
          throw TypeError(t + ": incorrect invocation!");
        return l;
      };
    },
    /* 148 */
    /***/
    function(m, X, l) {
      var i = l(93), t = l(137), s = l(138), b = l(97), Z = l(113), o = l(132), G = {}, y = {}, X = m.exports = function(W, h, r, L, u) {
        var V = u ? function() {
          return W;
        } : o(W), c = i(r, L, h ? 2 : 1), n = 0, e, a, Y, R;
        if (typeof V != "function")
          throw TypeError(W + " is not iterable!");
        if (s(V)) {
          for (e = Z(W.length); e > n; n++)
            if (R = h ? c(b(a = W[n])[0], a[1]) : c(W[n]), R === G || R === y)
              return R;
        } else
          for (Y = V.call(W); !(a = Y.next()).done; )
            if (R = t(Y, c, a.value, h), R === G || R === y)
              return R;
      };
      X.BREAK = G, X.RETURN = y;
    },
    /* 149 */
    /***/
    function(m, d, l) {
      var i = l(91), t = l(92), s = l(96), b = l(100), Z = l(122)("species");
      m.exports = function(o) {
        var G = typeof t[o] == "function" ? t[o] : i[o];
        b && G && !G[Z] && s.f(G, Z, {
          configurable: !0,
          get: function() {
            return this;
          }
        });
      };
    },
    /* 150 */
    /***/
    function(m, d, l) {
      var i = l(118)("meta"), t = l(98), s = l(105), b = l(96).f, Z = 0, o = Object.isExtensible || function() {
        return !0;
      }, G = !l(101)(function() {
        return o(Object.preventExtensions({}));
      }), y = function(L) {
        b(L, i, { value: {
          i: "O" + ++Z,
          // object ID
          w: {}
          // weak collections IDs
        } });
      }, X = function(L, u) {
        if (!t(L))
          return typeof L == "symbol" ? L : (typeof L == "string" ? "S" : "P") + L;
        if (!s(L, i)) {
          if (!o(L))
            return "F";
          if (!u)
            return "E";
          y(L);
        }
        return L[i].i;
      }, W = function(L, u) {
        if (!s(L, i)) {
          if (!o(L))
            return !0;
          if (!u)
            return !1;
          y(L);
        }
        return L[i].w;
      }, h = function(L) {
        return G && r.NEED && o(L) && !s(L, i) && y(L), L;
      }, r = m.exports = {
        KEY: i,
        NEED: !1,
        fastKey: X,
        getWeak: W,
        onFreeze: h
      };
    },
    /* 151 */
    /***/
    function(m, d, l) {
      var i = l(98);
      m.exports = function(t, s) {
        if (!i(t) || t._t !== s)
          throw TypeError("Incompatible receiver, " + s + " required!");
        return t;
      };
    },
    /* 152 */
    /***/
    function(m, d, l) {
      var i = l(91), t = l(90), s = l(150), b = l(101), Z = l(95), o = l(146), G = l(148), y = l(147), X = l(98), W = l(121), h = l(96).f, r = l(153)(0), L = l(100);
      m.exports = function(u, V, c, n, e, a) {
        var Y = i[u], R = Y, C = e ? "set" : "add", N = R && R.prototype, I = {};
        return !L || typeof R != "function" || !(a || N.forEach && !b(function() {
          new R().entries().next();
        })) ? (R = n.getConstructor(V, u, e, C), o(R.prototype, c), s.NEED = !0) : (R = V(function(J, T) {
          y(J, R, u, "_c"), J._c = new Y(), T != null && G(T, e, J[C], J);
        }), r("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(J) {
          var T = J == "add" || J == "set";
          J in N && !(a && J == "clear") && Z(R.prototype, J, function(K, S) {
            if (y(this, R, J), !T && a && !X(K))
              return J == "get" ? void 0 : !1;
            var H = this._c[J](K === 0 ? 0 : K, S);
            return T ? this : H;
          });
        }), a || h(R.prototype, "size", {
          get: function() {
            return this._c.size;
          }
        })), W(R, u), I[u] = R, t(t.G + t.W + t.F, I), a || n.setStrong(R, u, e), R;
      };
    },
    /* 153 */
    /***/
    function(m, d, l) {
      var i = l(93), t = l(85), s = l(124), b = l(113), Z = l(154);
      m.exports = function(o, G) {
        var y = o == 1, X = o == 2, W = o == 3, h = o == 4, r = o == 6, L = o == 5 || r, u = G || Z;
        return function(V, c, n) {
          for (var e = s(V), a = t(e), Y = i(c, n, 3), R = b(a.length), C = 0, N = y ? u(V, R) : X ? u(V, 0) : void 0, I, J; R > C; C++)
            if ((L || C in a) && (I = a[C], J = Y(I, C, e), o)) {
              if (y)
                N[C] = J;
              else if (J)
                switch (o) {
                  case 3:
                    return !0;
                  case 5:
                    return I;
                  case 6:
                    return C;
                  case 2:
                    N.push(I);
                }
              else if (h)
                return !1;
            }
          return r ? -1 : W || h ? h : N;
        };
      };
    },
    /* 154 */
    /***/
    function(m, d, l) {
      var i = l(155);
      m.exports = function(t, s) {
        return new (i(t))(s);
      };
    },
    /* 155 */
    /***/
    function(m, d, l) {
      var i = l(98), t = l(156), s = l(122)("species");
      m.exports = function(b) {
        var Z;
        return t(b) && (Z = b.constructor, typeof Z == "function" && (Z === Array || t(Z.prototype)) && (Z = void 0), i(Z) && (Z = Z[s], Z === null && (Z = void 0))), Z === void 0 ? Array : Z;
      };
    },
    /* 156 */
    /***/
    function(m, d, l) {
      var i = l(86);
      m.exports = Array.isArray || function(s) {
        return i(s) == "Array";
      };
    },
    /* 157 */
    /***/
    function(m, d, l) {
      var i = l(90);
      i(i.P + i.R, "Map", { toJSON: l(158)("Map") });
    },
    /* 158 */
    /***/
    function(m, d, l) {
      var i = l(128), t = l(159);
      m.exports = function(s) {
        return function() {
          if (i(this) != s)
            throw TypeError(s + "#toJSON isn't generic");
          return t(this);
        };
      };
    },
    /* 159 */
    /***/
    function(m, d, l) {
      var i = l(148);
      m.exports = function(t, s) {
        var b = [];
        return i(t, !1, b.push, b, s), b;
      };
    },
    /* 160 */
    /***/
    function(m, d, l) {
      l(161)("Map");
    },
    /* 161 */
    /***/
    function(m, d, l) {
      var i = l(90);
      m.exports = function(t) {
        i(i.S, t, { of: function() {
          for (var b = arguments.length, Z = new Array(b); b--; )
            Z[b] = arguments[b];
          return new this(Z);
        } });
      };
    },
    /* 162 */
    /***/
    function(m, d, l) {
      l(163)("Map");
    },
    /* 163 */
    /***/
    function(m, d, l) {
      var i = l(90), t = l(94), s = l(93), b = l(148);
      m.exports = function(Z) {
        i(i.S, Z, { from: function(G) {
          var y = arguments[1], X, W, h, r;
          return t(this), X = y !== void 0, X && t(y), G == null ? new this() : (W = [], X ? (h = 0, r = s(y, arguments[2], 2), b(G, !1, function(L) {
            W.push(r(L, h++));
          })) : b(G, !1, W.push, W), new this(W));
        } });
      };
    },
    /* 164 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(165), __esModule: !0 };
    },
    /* 165 */
    /***/
    function(m, d, l) {
      l(166), m.exports = l(92).Object.assign;
    },
    /* 166 */
    /***/
    function(m, d, l) {
      var i = l(90);
      i(i.S + i.F, "Object", { assign: l(167) });
    },
    /* 167 */
    /***/
    function(m, d, l) {
      var i = l(100), t = l(110), s = l(168), b = l(169), Z = l(124), o = l(85), G = Object.assign;
      m.exports = !G || l(101)(function() {
        var y = {}, X = {}, W = Symbol(), h = "abcdefghijklmnopqrst";
        return y[W] = 7, h.split("").forEach(function(r) {
          X[r] = r;
        }), G({}, y)[W] != 7 || Object.keys(G({}, X)).join("") != h;
      }) ? function(X, W) {
        for (var h = Z(X), r = arguments.length, L = 1, u = s.f, V = b.f; r > L; )
          for (var c = o(arguments[L++]), n = u ? t(c).concat(u(c)) : t(c), e = n.length, a = 0, Y; e > a; )
            Y = n[a++], (!i || V.call(c, Y)) && (h[Y] = c[Y]);
        return h;
      } : G;
    },
    /* 168 */
    /***/
    function(m, d) {
      d.f = Object.getOwnPropertySymbols;
    },
    /* 169 */
    /***/
    function(m, d) {
      d.f = {}.propertyIsEnumerable;
    },
    /* 170 */
    /***/
    function(m, d, l) {
      d.__esModule = !0, d.default = function(i, t) {
        if (!(i instanceof t))
          throw new TypeError("Cannot call a class as a function");
      };
    },
    /* 171 */
    /***/
    function(m, d, l) {
      d.__esModule = !0;
      var i = l(172), t = s(i);
      function s(b) {
        return b && b.__esModule ? b : { default: b };
      }
      d.default = /* @__PURE__ */ function() {
        function b(Z, o) {
          for (var G = 0; G < o.length; G++) {
            var y = o[G];
            y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), (0, t.default)(Z, y.key, y);
          }
        }
        return function(Z, o, G) {
          return o && b(Z.prototype, o), G && b(Z, G), Z;
        };
      }();
    },
    /* 172 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(173), __esModule: !0 };
    },
    /* 173 */
    /***/
    function(m, d, l) {
      l(174);
      var i = l(92).Object;
      m.exports = function(s, b, Z) {
        return i.defineProperty(s, b, Z);
      };
    },
    /* 174 */
    /***/
    function(m, d, l) {
      var i = l(90);
      i(i.S + i.F * !l(100), "Object", { defineProperty: l(96).f });
    },
    /* 175 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(176), __esModule: !0 };
    },
    /* 176 */
    /***/
    function(m, d, l) {
      l(177), l(143), l(184), l(185), m.exports = l(92).Symbol;
    },
    /* 177 */
    /***/
    function(m, d, l) {
      var i = l(91), t = l(105), s = l(100), b = l(90), Z = l(106), o = l(150).KEY, G = l(101), y = l(117), X = l(121), W = l(118), h = l(122), r = l(178), L = l(179), u = l(180), V = l(156), c = l(97), n = l(98), e = l(124), a = l(84), Y = l(103), R = l(104), C = l(108), N = l(181), I = l(183), J = l(168), T = l(96), K = l(110), S = I.f, H = T.f, w = N.f, P = i.Symbol, B = i.JSON, D = B && B.stringify, z = "prototype", U = h("_hidden"), O = h("toPrimitive"), ll = {}.propertyIsEnumerable, _ = y("symbol-registry"), Zl = y("symbols"), $ = y("op-symbols"), ol = Object[z], al = typeof P == "function" && !!J.f, g = i.QObject, k = !g || !g[z] || !g[z].findChild, j = s && G(function() {
        return C(H({}, "a", {
          get: function() {
            return H(this, "a", { value: 7 }).a;
          }
        })).a != 7;
      }) ? function(cl, sl, nl) {
        var Gl = S(ol, sl);
        Gl && delete ol[sl], H(cl, sl, nl), Gl && cl !== ol && H(ol, sl, Gl);
      } : H, A = function(cl) {
        var sl = Zl[cl] = C(P[z]);
        return sl._k = cl, sl;
      }, M = al && typeof P.iterator == "symbol" ? function(cl) {
        return typeof cl == "symbol";
      } : function(cl) {
        return cl instanceof P;
      }, Q = function(sl, nl, Gl) {
        return sl === ol && Q($, nl, Gl), c(sl), nl = Y(nl, !0), c(Gl), t(Zl, nl) ? (Gl.enumerable ? (t(sl, U) && sl[U][nl] && (sl[U][nl] = !1), Gl = C(Gl, { enumerable: R(0, !1) })) : (t(sl, U) || H(sl, U, R(1, {})), sl[U][nl] = !0), j(sl, nl, Gl)) : H(sl, nl, Gl);
      }, p = function(sl, nl) {
        c(sl);
        for (var Gl = u(nl = a(nl)), Wl = 0, Xl = Gl.length, yl; Xl > Wl; )
          Q(sl, yl = Gl[Wl++], nl[yl]);
        return sl;
      }, x = function(sl, nl) {
        return nl === void 0 ? C(sl) : p(C(sl), nl);
      }, F = function(sl) {
        var nl = ll.call(this, sl = Y(sl, !0));
        return this === ol && t(Zl, sl) && !t($, sl) ? !1 : nl || !t(this, sl) || !t(Zl, sl) || t(this, U) && this[U][sl] ? nl : !0;
      }, v = function(sl, nl) {
        if (sl = a(sl), nl = Y(nl, !0), !(sl === ol && t(Zl, nl) && !t($, nl))) {
          var Gl = S(sl, nl);
          return Gl && t(Zl, nl) && !(t(sl, U) && sl[U][nl]) && (Gl.enumerable = !0), Gl;
        }
      }, f = function(sl) {
        for (var nl = w(a(sl)), Gl = [], Wl = 0, Xl; nl.length > Wl; )
          !t(Zl, Xl = nl[Wl++]) && Xl != U && Xl != o && Gl.push(Xl);
        return Gl;
      }, E = function(sl) {
        for (var nl = sl === ol, Gl = w(nl ? $ : a(sl)), Wl = [], Xl = 0, yl; Gl.length > Xl; )
          t(Zl, yl = Gl[Xl++]) && (!nl || t(ol, yl)) && Wl.push(Zl[yl]);
        return Wl;
      };
      al || (P = function() {
        if (this instanceof P)
          throw TypeError("Symbol is not a constructor!");
        var sl = W(arguments.length > 0 ? arguments[0] : void 0), nl = function(Gl) {
          this === ol && nl.call($, Gl), t(this, U) && t(this[U], sl) && (this[U][sl] = !1), j(this, sl, R(1, Gl));
        };
        return s && k && j(ol, sl, { configurable: !0, set: nl }), A(sl);
      }, Z(P[z], "toString", function() {
        return this._k;
      }), I.f = v, T.f = Q, l(182).f = N.f = f, l(169).f = F, J.f = E, s && !l(89) && Z(ol, "propertyIsEnumerable", F, !0), r.f = function(cl) {
        return A(h(cl));
      }), b(b.G + b.W + b.F * !al, { Symbol: P });
      for (var q = (
        // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
        "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(",")
      ), dl = 0; q.length > dl; )
        h(q[dl++]);
      for (var tl = K(h.store), ml = 0; tl.length > ml; )
        L(tl[ml++]);
      b(b.S + b.F * !al, "Symbol", {
        // 19.4.2.1 Symbol.for(key)
        for: function(cl) {
          return t(_, cl += "") ? _[cl] : _[cl] = P(cl);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function(sl) {
          if (!M(sl))
            throw TypeError(sl + " is not a symbol!");
          for (var nl in _)
            if (_[nl] === sl)
              return nl;
        },
        useSetter: function() {
          k = !0;
        },
        useSimple: function() {
          k = !1;
        }
      }), b(b.S + b.F * !al, "Object", {
        // 19.1.2.2 Object.create(O [, Properties])
        create: x,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: Q,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: p,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: v,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: f,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: E
      });
      var el = G(function() {
        J.f(1);
      });
      b(b.S + b.F * el, "Object", {
        getOwnPropertySymbols: function(sl) {
          return J.f(e(sl));
        }
      }), B && b(b.S + b.F * (!al || G(function() {
        var cl = P();
        return D([cl]) != "[null]" || D({ a: cl }) != "{}" || D(Object(cl)) != "{}";
      })), "JSON", {
        stringify: function(sl) {
          for (var nl = [sl], Gl = 1, Wl, Xl; arguments.length > Gl; )
            nl.push(arguments[Gl++]);
          if (Xl = Wl = nl[1], !(!n(Wl) && sl === void 0 || M(sl)))
            return V(Wl) || (Wl = function(yl, Cl) {
              if (typeof Xl == "function" && (Cl = Xl.call(this, yl, Cl)), !M(Cl))
                return Cl;
            }), nl[1] = Wl, D.apply(B, nl);
        }
      }), P[z][O] || l(95)(P[z], O, P[z].valueOf), X(P, "Symbol"), X(Math, "Math", !0), X(i.JSON, "JSON", !0);
    },
    /* 178 */
    /***/
    function(m, d, l) {
      d.f = l(122);
    },
    /* 179 */
    /***/
    function(m, d, l) {
      var i = l(91), t = l(92), s = l(89), b = l(178), Z = l(96).f;
      m.exports = function(o) {
        var G = t.Symbol || (t.Symbol = s ? {} : i.Symbol || {});
        o.charAt(0) != "_" && !(o in G) && Z(G, o, { value: b.f(o) });
      };
    },
    /* 180 */
    /***/
    function(m, d, l) {
      var i = l(110), t = l(168), s = l(169);
      m.exports = function(b) {
        var Z = i(b), o = t.f;
        if (o)
          for (var G = o(b), y = s.f, X = 0, W; G.length > X; )
            y.call(b, W = G[X++]) && Z.push(W);
        return Z;
      };
    },
    /* 181 */
    /***/
    function(m, d, l) {
      var i = l(84), t = l(182).f, s = {}.toString, b = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], Z = function(o) {
        try {
          return t(o);
        } catch {
          return b.slice();
        }
      };
      m.exports.f = function(G) {
        return b && s.call(G) == "[object Window]" ? Z(G) : t(i(G));
      };
    },
    /* 182 */
    /***/
    function(m, d, l) {
      var i = l(111), t = l(119).concat("length", "prototype");
      d.f = Object.getOwnPropertyNames || function(b) {
        return i(b, t);
      };
    },
    /* 183 */
    /***/
    function(m, d, l) {
      var i = l(169), t = l(104), s = l(84), b = l(103), Z = l(105), o = l(99), G = Object.getOwnPropertyDescriptor;
      d.f = l(100) ? G : function(X, W) {
        if (X = s(X), W = b(W, !0), o)
          try {
            return G(X, W);
          } catch {
          }
        if (Z(X, W))
          return t(!i.f.call(X, W), X[W]);
      };
    },
    /* 184 */
    /***/
    function(m, d, l) {
      l(179)("asyncIterator");
    },
    /* 185 */
    /***/
    function(m, d, l) {
      l(179)("observable");
    },
    /* 186 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.createNowTime = i, d.formatDelay = t;
      function i() {
        var s = null;
        return Date.now ? s = Date.now : s = function() {
          return (/* @__PURE__ */ new Date()).getTime();
        }, s;
      }
      function t(s) {
        return typeof s == "number" ? s = { delay: s } : "entropy" in s && (s = { delay: s.entropy, isEntropy: !0 }), s;
      }
    },
    /* 187 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.default = {
        // s - startFrame, e - endFrame
        default: function(t, s, b, Z, o) {
          return typeof t == "number" && typeof s == "number" ? t + (b - Z) / (o - Z) * (s - t) : b - Z > o - b ? s : t;
        }
      };
    },
    /* 188 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.parseEasing = d.Easings = void 0;
      var i = l(76), t = G(i), s = l(133), b = G(s), Z = l(141), o = G(Z);
      function G(V) {
        return V && V.__esModule ? V : { default: V };
      }
      var y = l(189), X = new o.default();
      function W() {
        for (var V = arguments.length, c = Array(V), n = 0; n < V; n++)
          c[n] = arguments[n];
        var e = X.get(c);
        return e || (e = y.apply(void 0, c), X.set(c, e), e);
      }
      function h(V) {
        var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "end";
        return function(n, e) {
          for (var a = 1; a < e.length; a++) {
            var Y = e[a].offset;
            if (n <= Y) {
              var R = e[a - 1].offset, C = Y, N = (n - R) / (C - R), I = 1 / V, J = N / I;
              return c === "end" ? J = Math.floor(J) : J = Math.ceil(J), I * J * (C - R) + R;
            }
          }
          return 0;
        };
      }
      function r(V) {
        var c = /^cubic-bezier\((.*)\)/, n = V.match(c);
        if (n) {
          var e = n[1].trim();
          return e = e.split(",").map(function(I) {
            return parseFloat(I.trim());
          }), W.apply(void 0, (0, b.default)(e));
        }
        if (c = /^steps\((.*)\)/, n = V.match(c), n) {
          var a = n[1].trim();
          a = a.split(",").map(function(I) {
            return I.trim();
          });
          var Y = a, R = (0, t.default)(Y, 2), C = R[0], N = R[1];
          return h(parseInt(C, 10), N);
        }
        return V;
      }
      var L = {
        linear: function(c) {
          return c;
        },
        ease: W(0.25, 0.1, 0.25, 1),
        "ease-in": W(0.42, 0, 1, 1),
        "ease-out": W(0, 0, 0.58, 1),
        "ease-in-out": W(0.42, 0, 0.58, 1),
        // 'step-start': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     ret = offset
        //     if(p < offset){
        //       break
        //     }
        //   }
        //   return ret
        // },
        // 'step-end': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     if(p < offset){
        //       break
        //     }
        //     ret = offset
        //   }
        //   return ret
        // }
        "step-start": h(1, "start"),
        "step-end": h(1, "end")
      };
      function u(V) {
        return typeof V == "string" ? L[V] ? V = L[V] : V = r(V) : V.type === "cubic-bezier" ? V = W.apply(void 0, (0, b.default)(V.value)) : V.type === "steps" && (V = h(V.step, V.pos)), V;
      }
      d.Easings = L, d.parseEasing = u;
    },
    /* 189 */
    /***/
    function(m, d) {
      var l = 4, i = 1e-3, t = 1e-7, s = 10, b = 11, Z = 1 / (b - 1), o = typeof Float32Array == "function";
      function G(V, c) {
        return 1 - 3 * c + 3 * V;
      }
      function y(V, c) {
        return 3 * c - 6 * V;
      }
      function X(V) {
        return 3 * V;
      }
      function W(V, c, n) {
        return ((G(c, n) * V + y(c, n)) * V + X(c)) * V;
      }
      function h(V, c, n) {
        return 3 * G(c, n) * V * V + 2 * y(c, n) * V + X(c);
      }
      function r(V, c, n, e, a) {
        var Y, R, C = 0;
        do
          R = c + (n - c) / 2, Y = W(R, e, a) - V, Y > 0 ? n = R : c = R;
        while (Math.abs(Y) > t && ++C < s);
        return R;
      }
      function L(V, c, n, e) {
        for (var a = 0; a < l; ++a) {
          var Y = h(c, n, e);
          if (Y === 0)
            return c;
          var R = W(c, n, e) - V;
          c -= R / Y;
        }
        return c;
      }
      function u(V) {
        return V;
      }
      m.exports = function(c, n, e, a) {
        if (!(0 <= c && c <= 1 && 0 <= e && e <= 1))
          throw new Error("bezier x values must be in [0, 1] range");
        if (c === n && e === a)
          return u;
        for (var Y = o ? new Float32Array(b) : new Array(b), R = 0; R < b; ++R)
          Y[R] = W(R * Z, c, e);
        function C(N) {
          for (var I = 0, J = 1, T = b - 1; J !== T && Y[J] <= N; ++J)
            I += Z;
          --J;
          var K = (N - Y[J]) / (Y[J + 1] - Y[J]), S = I + K * Z, H = h(S, c, e);
          return H >= i ? L(N, S, c, e) : H === 0 ? S : r(N, I, I + Z, c, e);
        }
        return function(I) {
          return I === 0 ? 0 : I === 1 ? 1 : W(C(I), n, a);
        };
      };
    },
    /* 190 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      });
      var i = l(191), t = n(i), s = l(204), b = n(s), Z = l(164), o = n(Z), G = l(170), y = n(G), X = l(171), W = n(X), h = l(175), r = n(h), L = l(75), u = n(L), V = l(208), c = l(188);
      function n(H) {
        return H && H.__esModule ? H : { default: H };
      }
      var e = (0, r.default)("timing"), a = (0, r.default)("keyframes"), Y = (0, r.default)("initState"), R = (0, r.default)("readyDefer"), C = (0, r.default)("finishedDefer"), N = (0, r.default)("effects"), I = (0, r.default)("activeReadyTimer"), J = (0, r.default)("activeFinishTimer"), T = (0, r.default)("removeDefer"), K = {
        delay: 0,
        endDelay: 0,
        fill: "auto",
        iterations: 1,
        playbackRate: 1,
        direction: "normal",
        easing: "linear",
        effect: null
      }, S = function() {
        function H(w, P, B) {
          var D = this;
          if ((0, y.default)(this, H), Array.isArray(w)) {
            var z = [w[0], w, P];
            w = z[0], P = z[1], B = z[2];
          }
          typeof B == "number" && (B = { duration: B }), this[e] = (0, o.default)({}, K, B), this[e].easing = (0, c.parseEasing)(this[e].easing), this[a] = (0, V.calculateFramesOffset)(P);
          var U = this[a][this[a].length - 1];
          this[Y] = {}, (0, b.default)(U).forEach(function(O) {
            Object.prototype.hasOwnProperty.call(w, O) && O !== "easing" && O !== "offset" && (D[Y][O] = w[O]);
          }), this[a] = this[a].map(function(O) {
            return (0, o.default)({}, D[Y], O);
          }), this[a][0].offset !== 0 && this[a].unshift((0, o.default)({}, this[Y], { offset: 0 })), U.offset < 1 && this[a].push((0, o.default)({}, U, { offset: 1 })), this[N] = {}, this.timeline = null;
        }
        return (0, W.default)(H, [{
          key: "pause",
          value: function() {
            this.timeline.playbackRate = 0;
          }
        }, {
          key: I,
          value: function() {
            var P = this;
            this[R] && !this[R].timerID && (this.timeline.currentTime < 0 ? this[R].timerID = this.timeline.setTimeout(function() {
              P[R].resolve(), delete P[R];
            }, { delay: -this.timeline.currentTime, heading: !1 }) : this[R].timerID = this.timeline.setTimeout(function() {
              P[R].resolve(), delete P[R];
            }, { delay: 0, isEntropy: !0 }));
          }
        }, {
          key: J,
          value: function() {
            var P = this, B = this[e], D = B.duration, z = B.iterations, U = B.endDelay, O = Math.ceil(D * z + U - this.timeline.currentTime) + 1;
            this[C] && !this[C].timerID && (this[C].timerID = this.timeline.setTimeout(function() {
              P[C].resolve(), P[T](R), P[T](C);
            }, { delay: O, heading: !1 }), this[C].reverseTimerID = this.timeline.setTimeout(function() {
              P[C].resolve(), P[T](R), P[T](C), P.timeline = null;
            }, { delay: -this[e].delay - 1, heading: !1 }));
          }
        }, {
          key: "play",
          value: function() {
            if (this.playState === "finished" && this.cancel(), this.playState === "idle") {
              if (this.playbackRate <= 0)
                return;
              var P = this[e], B = P.delay, D = P.playbackRate, z = P.timeline;
              this.timeline = new u.default({
                originTime: B,
                playbackRate: D
              }, z), this[I](), this[J]();
            } else
              this.playState === "paused" && (this.timeline.playbackRate = this.playbackRate, this[I]());
          }
        }, {
          key: T,
          value: function(P) {
            var B = this[P], D = this.timeline;
            B && D && (D.clearTimeout(B.timerID), B.reverseTimerID && D.clearTimeout(B.reverseTimerID)), delete this[P];
          }
        }, {
          key: "cancel",
          value: function() {
            this[T](R), this[T](C), this.timeline = null;
          }
        }, {
          key: "finish",
          value: function() {
            this.timeline && (this.timeline.currentTime = 1 / 0 / this.playbackRate), this[T](R), this[T](C);
          }
        }, {
          key: "applyEffects",
          value: function(P) {
            return (0, o.default)(this[N], P);
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[e].playbackRate;
          },
          set: function(P) {
            this.timeline && (this.timeline.playbackRate = P), this[e].playbackRate = P;
          }
        }, {
          key: "playState",
          get: function() {
            var P = this.timeline, B = this[e], D = B.iterations, z = B.duration, U = B.endDelay, O = "running";
            if (P == null)
              O = "idle";
            else if (P.paused)
              O = "paused";
            else if (P.currentTime < 0)
              O = "pending";
            else {
              var ll = P.currentTime - D * z;
              ll > 0 && ll < U ? O = "pending" : ll >= U && (O = "finished");
            }
            return O;
          }
        }, {
          key: "progress",
          get: function() {
            if (!this.timeline)
              return 0;
            var P = this[e], B = P.duration, D = P.iterations, z = this.timeline, U = this.playState, O = void 0;
            if (U === "idle")
              O = 0;
            else if (U === "paused" && z.currentTime < 0)
              O = 0;
            else if (U === "pending")
              if (z.currentTime < 0)
                O = 0;
              else {
                var ll = z.seekLocalTime(D * B);
                O = (0, V.periodicity)(ll, B)[1] / B;
              }
            else
              (U === "running" || U === "paused") && (O = (0, V.periodicity)(z.currentTime, B)[1] / B);
            return U === "finished" && (O = (0, V.periodicity)(D, 1)[1]), O;
          }
        }, {
          key: "frame",
          get: function() {
            var P = this.playState, B = this[Y], D = this[e].fill;
            if (P === "idle")
              return B;
            var z = this.timeline.currentTime, U = this[a].slice(0), O = (0, V.getProgress)(this.timeline, this[e], this.progress), ll = O.p, _ = O.inverted, Zl = B;
            return z < 0 && P === "pending" ? (D === "backwards" || D === "both") && (Zl = _ ? U[U.length - 1] : U[0]) : (P !== "pending" && P !== "finished" || D === "forwards" || D === "both") && (Zl = (0, V.getCurrentFrame)(this[e], U, this[N], ll)), Zl;
          }
        }, {
          key: "timing",
          get: function() {
            return this[e];
          }
        }, {
          key: "effects",
          get: function() {
            return this[N];
          }
        }, {
          key: "baseTimeline",
          set: function(P) {
            this[e].timeline = P;
          },
          get: function() {
            return this[e].timeline;
          }
        }, {
          key: "ready",
          get: function() {
            return this[R] ? this[R].promise : this.timeline && this.timeline.currentTime >= 0 && this.playState !== "paused" ? t.default.resolve() : (this[R] = (0, V.defer)(), this.timeline && this[I](), this[R] ? this[R].promise : t.default.resolve());
          }
        }, {
          key: "finished",
          get: function() {
            return this.playState === "finished" ? t.default.resolve() : (this[C] || (this[C] = (0, V.defer)(), this.timeline && this[J]()), this[C].promise);
          }
        }]), H;
      }();
      d.default = S;
    },
    /* 191 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(192), __esModule: !0 };
    },
    /* 192 */
    /***/
    function(m, d, l) {
      l(143), l(125), l(79), l(193), l(202), l(203), m.exports = l(92).Promise;
    },
    /* 193 */
    /***/
    function(m, d, l) {
      var i = l(89), t = l(91), s = l(93), b = l(128), Z = l(90), o = l(98), G = l(94), y = l(147), X = l(148), W = l(194), h = l(195).set, r = l(197)(), L = l(198), u = l(199), V = l(200), c = l(201), n = "Promise", e = t.TypeError, a = t.process, Y = a && a.versions, R = Y && Y.v8 || "", C = t[n], N = b(a) == "process", I = function() {
      }, J, T, K, S, H = T = L.f, w = !!function() {
        try {
          var _ = C.resolve(1), Zl = (_.constructor = {})[l(122)("species")] = function($) {
            $(I, I);
          };
          return (N || typeof PromiseRejectionEvent == "function") && _.then(I) instanceof Zl && R.indexOf("6.6") !== 0 && V.indexOf("Chrome/66") === -1;
        } catch {
        }
      }(), P = function(_) {
        var Zl;
        return o(_) && typeof (Zl = _.then) == "function" ? Zl : !1;
      }, B = function(_, Zl) {
        if (!_._n) {
          _._n = !0;
          var $ = _._c;
          r(function() {
            for (var ol = _._v, al = _._s == 1, g = 0, k = function(j) {
              var A = al ? j.ok : j.fail, M = j.resolve, Q = j.reject, p = j.domain, x, F, v;
              try {
                A ? (al || (_._h == 2 && U(_), _._h = 1), A === !0 ? x = ol : (p && p.enter(), x = A(ol), p && (p.exit(), v = !0)), x === j.promise ? Q(e("Promise-chain cycle")) : (F = P(x)) ? F.call(x, M, Q) : M(x)) : Q(ol);
              } catch (f) {
                p && !v && p.exit(), Q(f);
              }
            }; $.length > g; )
              k($[g++]);
            _._c = [], _._n = !1, Zl && !_._h && D(_);
          });
        }
      }, D = function(_) {
        h.call(t, function() {
          var Zl = _._v, $ = z(_), ol, al, g;
          if ($ && (ol = u(function() {
            N ? a.emit("unhandledRejection", Zl, _) : (al = t.onunhandledrejection) ? al({ promise: _, reason: Zl }) : (g = t.console) && g.error && g.error("Unhandled promise rejection", Zl);
          }), _._h = N || z(_) ? 2 : 1), _._a = void 0, $ && ol.e)
            throw ol.v;
        });
      }, z = function(_) {
        return _._h !== 1 && (_._a || _._c).length === 0;
      }, U = function(_) {
        h.call(t, function() {
          var Zl;
          N ? a.emit("rejectionHandled", _) : (Zl = t.onrejectionhandled) && Zl({ promise: _, reason: _._v });
        });
      }, O = function(_) {
        var Zl = this;
        Zl._d || (Zl._d = !0, Zl = Zl._w || Zl, Zl._v = _, Zl._s = 2, Zl._a || (Zl._a = Zl._c.slice()), B(Zl, !0));
      }, ll = function(_) {
        var Zl = this, $;
        if (!Zl._d) {
          Zl._d = !0, Zl = Zl._w || Zl;
          try {
            if (Zl === _)
              throw e("Promise can't be resolved itself");
            ($ = P(_)) ? r(function() {
              var ol = { _w: Zl, _d: !1 };
              try {
                $.call(_, s(ll, ol, 1), s(O, ol, 1));
              } catch (al) {
                O.call(ol, al);
              }
            }) : (Zl._v = _, Zl._s = 1, B(Zl, !1));
          } catch (ol) {
            O.call({ _w: Zl, _d: !1 }, ol);
          }
        }
      };
      w || (C = function(Zl) {
        y(this, C, n, "_h"), G(Zl), J.call(this);
        try {
          Zl(s(ll, this, 1), s(O, this, 1));
        } catch ($) {
          O.call(this, $);
        }
      }, J = function(Zl) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
      }, J.prototype = l(146)(C.prototype, {
        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function(Zl, $) {
          var ol = H(W(this, C));
          return ol.ok = typeof Zl == "function" ? Zl : !0, ol.fail = typeof $ == "function" && $, ol.domain = N ? a.domain : void 0, this._c.push(ol), this._a && this._a.push(ol), this._s && B(this, !1), ol.promise;
        },
        // 25.4.5.1 Promise.prototype.catch(onRejected)
        catch: function(_) {
          return this.then(void 0, _);
        }
      }), K = function() {
        var _ = new J();
        this.promise = _, this.resolve = s(ll, _, 1), this.reject = s(O, _, 1);
      }, L.f = H = function(_) {
        return _ === C || _ === S ? new K(_) : T(_);
      }), Z(Z.G + Z.W + Z.F * !w, { Promise: C }), l(121)(C, n), l(149)(n), S = l(92)[n], Z(Z.S + Z.F * !w, n, {
        // 25.4.4.5 Promise.reject(r)
        reject: function(Zl) {
          var $ = H(this), ol = $.reject;
          return ol(Zl), $.promise;
        }
      }), Z(Z.S + Z.F * (i || !w), n, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function(Zl) {
          return c(i && this === S ? C : this, Zl);
        }
      }), Z(Z.S + Z.F * !(w && l(140)(function(_) {
        C.all(_).catch(I);
      })), n, {
        // 25.4.4.1 Promise.all(iterable)
        all: function(Zl) {
          var $ = this, ol = H($), al = ol.resolve, g = ol.reject, k = u(function() {
            var j = [], A = 0, M = 1;
            X(Zl, !1, function(Q) {
              var p = A++, x = !1;
              j.push(void 0), M++, $.resolve(Q).then(function(F) {
                x || (x = !0, j[p] = F, --M || al(j));
              }, g);
            }), --M || al(j);
          });
          return k.e && g(k.v), ol.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function(Zl) {
          var $ = this, ol = H($), al = ol.reject, g = u(function() {
            X(Zl, !1, function(k) {
              $.resolve(k).then(ol.resolve, al);
            });
          });
          return g.e && al(g.v), ol.promise;
        }
      });
    },
    /* 194 */
    /***/
    function(m, d, l) {
      var i = l(97), t = l(94), s = l(122)("species");
      m.exports = function(b, Z) {
        var o = i(b).constructor, G;
        return o === void 0 || (G = i(o)[s]) == null ? Z : t(G);
      };
    },
    /* 195 */
    /***/
    function(m, d, l) {
      var i = l(93), t = l(196), s = l(120), b = l(102), Z = l(91), o = Z.process, G = Z.setImmediate, y = Z.clearImmediate, X = Z.MessageChannel, W = Z.Dispatch, h = 0, r = {}, L = "onreadystatechange", u, V, c, n = function() {
        var a = +this;
        if (r.hasOwnProperty(a)) {
          var Y = r[a];
          delete r[a], Y();
        }
      }, e = function(a) {
        n.call(a.data);
      };
      (!G || !y) && (G = function(Y) {
        for (var R = [], C = 1; arguments.length > C; )
          R.push(arguments[C++]);
        return r[++h] = function() {
          t(typeof Y == "function" ? Y : Function(Y), R);
        }, u(h), h;
      }, y = function(Y) {
        delete r[Y];
      }, l(86)(o) == "process" ? u = function(a) {
        o.nextTick(i(n, a, 1));
      } : W && W.now ? u = function(a) {
        W.now(i(n, a, 1));
      } : X ? (V = new X(), c = V.port2, V.port1.onmessage = e, u = i(c.postMessage, c, 1)) : Z.addEventListener && typeof postMessage == "function" && !Z.importScripts ? (u = function(a) {
        Z.postMessage(a + "", "*");
      }, Z.addEventListener("message", e, !1)) : L in b("script") ? u = function(a) {
        s.appendChild(b("script"))[L] = function() {
          s.removeChild(this), n.call(a);
        };
      } : u = function(a) {
        setTimeout(i(n, a, 1), 0);
      }), m.exports = {
        set: G,
        clear: y
      };
    },
    /* 196 */
    /***/
    function(m, d) {
      m.exports = function(l, i, t) {
        var s = t === void 0;
        switch (i.length) {
          case 0:
            return s ? l() : l.call(t);
          case 1:
            return s ? l(i[0]) : l.call(t, i[0]);
          case 2:
            return s ? l(i[0], i[1]) : l.call(t, i[0], i[1]);
          case 3:
            return s ? l(i[0], i[1], i[2]) : l.call(t, i[0], i[1], i[2]);
          case 4:
            return s ? l(i[0], i[1], i[2], i[3]) : l.call(t, i[0], i[1], i[2], i[3]);
        }
        return l.apply(t, i);
      };
    },
    /* 197 */
    /***/
    function(m, d, l) {
      var i = l(91), t = l(195).set, s = i.MutationObserver || i.WebKitMutationObserver, b = i.process, Z = i.Promise, o = l(86)(b) == "process";
      m.exports = function() {
        var G, y, X, W = function() {
          var u, V;
          for (o && (u = b.domain) && u.exit(); G; ) {
            V = G.fn, G = G.next;
            try {
              V();
            } catch (c) {
              throw G ? X() : y = void 0, c;
            }
          }
          y = void 0, u && u.enter();
        };
        if (o)
          X = function() {
            b.nextTick(W);
          };
        else if (s && !(i.navigator && i.navigator.standalone)) {
          var h = !0, r = document.createTextNode("");
          new s(W).observe(r, { characterData: !0 }), X = function() {
            r.data = h = !h;
          };
        } else if (Z && Z.resolve) {
          var L = Z.resolve(void 0);
          X = function() {
            L.then(W);
          };
        } else
          X = function() {
            t.call(i, W);
          };
        return function(u) {
          var V = { fn: u, next: void 0 };
          y && (y.next = V), G || (G = V, X()), y = V;
        };
      };
    },
    /* 198 */
    /***/
    function(m, d, l) {
      var i = l(94);
      function t(s) {
        var b, Z;
        this.promise = new s(function(o, G) {
          if (b !== void 0 || Z !== void 0)
            throw TypeError("Bad Promise constructor");
          b = o, Z = G;
        }), this.resolve = i(b), this.reject = i(Z);
      }
      m.exports.f = function(s) {
        return new t(s);
      };
    },
    /* 199 */
    /***/
    function(m, d) {
      m.exports = function(l) {
        try {
          return { e: !1, v: l() };
        } catch (i) {
          return { e: !0, v: i };
        }
      };
    },
    /* 200 */
    /***/
    function(m, d, l) {
      var i = l(91), t = i.navigator;
      m.exports = t && t.userAgent || "";
    },
    /* 201 */
    /***/
    function(m, d, l) {
      var i = l(97), t = l(98), s = l(198);
      m.exports = function(b, Z) {
        if (i(b), t(Z) && Z.constructor === b)
          return Z;
        var o = s.f(b), G = o.resolve;
        return G(Z), o.promise;
      };
    },
    /* 202 */
    /***/
    function(m, d, l) {
      var i = l(90), t = l(92), s = l(91), b = l(194), Z = l(201);
      i(i.P + i.R, "Promise", { finally: function(o) {
        var G = b(this, t.Promise || s.Promise), y = typeof o == "function";
        return this.then(
          y ? function(X) {
            return Z(G, o()).then(function() {
              return X;
            });
          } : o,
          y ? function(X) {
            return Z(G, o()).then(function() {
              throw X;
            });
          } : o
        );
      } });
    },
    /* 203 */
    /***/
    function(m, d, l) {
      var i = l(90), t = l(198), s = l(199);
      i(i.S, "Promise", { try: function(b) {
        var Z = t.f(this), o = s(b);
        return (o.e ? Z.reject : Z.resolve)(o.v), Z.promise;
      } });
    },
    /* 204 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(205), __esModule: !0 };
    },
    /* 205 */
    /***/
    function(m, d, l) {
      l(206), m.exports = l(92).Object.keys;
    },
    /* 206 */
    /***/
    function(m, d, l) {
      var i = l(124), t = l(110);
      l(207)("keys", function() {
        return function(b) {
          return t(i(b));
        };
      });
    },
    /* 207 */
    /***/
    function(m, d, l) {
      var i = l(90), t = l(92), s = l(101);
      m.exports = function(b, Z) {
        var o = (t.Object || {})[b] || Object[b], G = {};
        G[b] = Z(o), i(i.S + i.F * s(function() {
          o(1);
        }), "Object", G);
      };
    },
    /* 208 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      });
      var i = l(76), t = r(i), s = l(209), b = r(s), Z = l(164), o = r(Z), G = l(191), y = r(G);
      d.defer = L, d.periodicity = u, d.calculateFramesOffset = V, d.getProgress = c, d.getCurrentFrame = e;
      var X = l(188), W = l(187), h = r(W);
      function r(a) {
        return a && a.__esModule ? a : { default: a };
      }
      function L() {
        var a = {};
        return a.promise = new y.default(function(Y, R) {
          a.resolve = Y, a.reject = R;
        }), a;
      }
      function u(a, Y) {
        var R = Math.floor(a / Y), C = a - R * Y;
        return C === 0 && R > 0 && (C = Y, R--), [R, C];
      }
      function V(a) {
        a = a.slice(0);
        var Y = a[0], R = a[a.length - 1];
        R.offset = R.offset || 1, Y.offset = Y.offset || 0;
        for (var C = 0, N = -1, I = 0; I < a.length; I++) {
          var J = a[I];
          if (J.offset != null) {
            var T = I - N;
            if (T > 1)
              for (var K = (J.offset - C) / T, S = 0; S < T - 1; S++)
                a[N + S + 1].offset = C + K * (S + 1);
            C = J.offset, N = I;
          }
          if (J.easing != null && (J.easing = (0, X.parseEasing)(J.easing)), I > 0) {
            var H = a[I].easing != null;
            a[I] = (0, o.default)({}, a[I - 1], a[I]), H || delete a[I].easing;
          }
        }
        return a;
      }
      function c(a, Y, R) {
        var C = a.currentTime, N = Y.direction, I = Y.duration, J = !1;
        if (N === "reverse")
          R = 1 - R, J = !0;
        else if (N === "alternate" || N === "alternate-reverse") {
          var T = Math.floor(C / I);
          R === 1 && T--, T % 2 ^ N === "alternate-reverse" && (R = 1 - R, J = !0);
        }
        return { p: R, inverted: J };
      }
      function n(a, Y, R, C) {
        var N = {};
        return (0, b.default)(Y).forEach(function(I) {
          var J = (0, t.default)(I, 2), T = J[0], K = J[1];
          if (T !== "offset" && T !== "easing") {
            var S = R[T] || R.default, H = S(a[T], K, C, a.offset, Y.offset);
            H != null && (N[T] = H);
          }
        }), N;
      }
      function e(a, Y, R, C) {
        var N = a.easing, I = a.effect;
        I || (R = (0, o.default)({}, h.default, R));
        var J = {};
        C = N(C, Y);
        for (var T = 1; T < Y.length; T++) {
          var K = Y[T], S = K.offset;
          if (S >= C || T === Y.length - 1) {
            var H = Y[T - 1], w = H.offset, P = H.easing, B = C;
            if (P) {
              var D = S - w;
              B = P((C - w) / D) * D + w;
            }
            I ? J = I(H, K, B, w, S) : J = n(H, K, R, B);
            break;
          }
        }
        return J;
      }
    },
    /* 209 */
    /***/
    function(m, d, l) {
      m.exports = { default: l(210), __esModule: !0 };
    },
    /* 210 */
    /***/
    function(m, d, l) {
      l(211), m.exports = l(92).Object.entries;
    },
    /* 211 */
    /***/
    function(m, d, l) {
      var i = l(90), t = l(212)(!0);
      i(i.S, "Object", {
        entries: function(b) {
          return t(b);
        }
      });
    },
    /* 212 */
    /***/
    function(m, d, l) {
      var i = l(100), t = l(110), s = l(84), b = l(169).f;
      m.exports = function(Z) {
        return function(o) {
          for (var G = s(o), y = t(G), X = y.length, W = 0, h = [], r; X > W; )
            r = y[W++], (!i || b.call(G, r)) && h.push(Z ? [r, G[r]] : G[r]);
          return h;
        };
      };
    },
    /* 213 */
    /***/
    function(m, d, l) {
      l.r(d), l(1).glMatrix.setMatrixArrayType(Array);
      const i = /* @__PURE__ */ new Map();
      function t(b, Z = {}, o = []) {
        b = b.toLowerCase();
        const G = i.get(b);
        if (!G)
          throw new TypeError(`Invalid node: ${b}`);
        const y = new G(Z);
        return o.forEach((X) => {
          y.appendChild(X);
        }), y;
      }
      const s = {
        registerNode(b, Z, o = 100) {
          if (Z = Z.toLowerCase(), i.has(Z))
            throw new TypeError(`Cannot registerNode, ${Z} has been taken.`);
          i.set(Z, b), Object.defineProperties(b.prototype, {
            nodeType: {
              value: o
            },
            tagName: {
              value: Z.toUpperCase()
            },
            nodeName: {
              value: Z
            },
            ownerDocument: {
              value: s
            },
            namespaceURI: {
              value: `http://spritejs.com/${Z}`
            }
          });
        },
        createElement: t,
        createElementNS(b, Z) {
          return t(Z);
        },
        isSpriteNode(b) {
          return i.has(b.toLowerCase());
        }
      };
      d.default = s;
    },
    /* 214 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const i = Symbol("type"), t = Symbol("bubbles"), s = Symbol("originalEvent"), b = Symbol("detail");
      class Z {
        constructor(G, {
          bubbles: y = null
        } = {}) {
          if (typeof G == "string" ? (this[i] = G, this[t] = !!y) : (this[i] = G.type, this[s] = G, this[t] = y != null ? !!y : !!G.bubbles, G.detail && (this[b] = G.detail)), !this[i])
            throw new TypeError("Invalid event type.");
          this.cancelBubble = !1;
        }
        setOriginalEvent(G) {
          this[s] = G;
        }
        get originalEvent() {
          return this[s];
        }
        get type() {
          return this[i];
        }
        get bubbles() {
          return this[t];
        }
        get detail() {
          return this[b];
        }
        stopPropagation() {
          this.cancelBubble = !0;
        }
      }
    },
    /* 215 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "parseFilterString", function() {
        return t;
      }), l.d(d, "applyFilters", function() {
        return s;
      });
      var i = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      function t(b) {
        if (b = b.trim(), !b || b === "none")
          return null;
        const Z = /^(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+$/i, o = b.match(/(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+?/ig), G = [];
        return o && o.forEach((y) => {
          const X = y.match(Z);
          if (!X)
            throw new TypeError("Invalid fitler string.");
          let [, W, h] = X;
          W = W.toLowerCase(), h = h.trim().match(/([^( )]+|([^( )]+\(.*\)))(?=\s|$)/g).map((r, L) => {
            let u;
            return W === "url" || W === "drop-shadow" && L === 3 ? u = r : u = Object(i.toNumber)(r), /%$/.test(r) && (u /= 100), u;
          }), G.push({
            type: W,
            args: h
          });
        }), G;
      }
      function s(b, Z) {
        b.clearFilter(), Z && Z.forEach(({
          type: o,
          args: G
        }) => {
          let y = o;
          y === "drop-shadow" ? y = "dropShadow" : y === "hue-rotate" && (y = "hueRotate"), b[y](...G);
        });
      }
    },
    /* 216 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return i;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(t, s) {
        if (!s)
          return;
        const b = t.getListeners("beforerender"), Z = t.getListeners("afterrender");
        b.length && !s.beforeRender ? s.beforeRender = (o) => {
          t.dispatchEvent({
            type: "beforerender",
            detail: {
              context: o
            }
          });
        } : b.length || (s.beforeRender = null), Z.length && !s.afterRender ? s.afterRender = (o) => {
          t.dispatchEvent({
            type: "afterrender",
            detail: {
              context: o
            }
          });
        } : Z.length || (s.afterRender = null);
      }
    },
    /* 217 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(12), t = l(218), s = l(70), b = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      const Z = Symbol("amount"), o = Symbol("meshCloud");
      class G extends s.default {
        constructor(X, W = 1) {
          super(), this.meshNode = X, X.connect(this), this[Z] = W, this[o] = null;
        }
        get meshCloud() {
          const X = this.meshNode, W = this[Z];
          return !this[o] && X.mesh && (this[o] = new i.MeshCloud(X.mesh, W)), this[o];
        }
        /* override */
        get isVisible() {
          return !!this.meshNode && this.meshNode.isVisible;
        }
        get amount() {
          return this[Z];
        }
        set amount(X) {
          this[Z] = X, this[o] && (this[o].amount = X);
        }
        brightness(X, W) {
          this.meshCloud && (this.meshCloud.brightness(X, W), this.forceUpdate());
        }
        contrast(X, W) {
          this.meshCloud && (this.meshCloud.contrast(X, W), this.forceUpdate());
        }
        delete(X) {
          this.meshCloud && (this.meshCloud.delete(X), this[Z]--, this.forceUpdate());
        }
        /* override */
        draw(X = []) {
          if (super.draw(X), this.meshCloud) {
            if (this.program) {
              this.meshCloud.setProgram(this.program);
              const W = this.shaderAttrs;
              W && Object.entries(W).forEach(([r, L]) => {
                this.meshCloud.mesh.setAttribute(r, L);
              });
              const h = this.uniforms;
              if (this.uniforms) {
                const r = {};
                Object.entries(h).forEach(([L, u]) => {
                  typeof u == "function" && (u = u(this, L)), r[L] = u;
                }), this.meshCloud.mesh.setUniforms(r);
              }
            }
            this.meshNode.textureImage && Object(t.drawTexture)(this.meshNode, this.meshNode.mesh), X.push(this.meshCloud);
          }
          return X;
        }
        getTransform(X) {
          if (this.meshCloud)
            return this.meshCloud.getTransform(X);
        }
        grayscale(X, W) {
          this.meshCloud && (this.meshCloud.grayscale(X, W), this.forceUpdate());
        }
        hueRotate(X, W) {
          this.meshCloud && (this.meshCloud.hueRotate(X, W), this.forceUpdate());
        }
        invert(X, W) {
          this.meshCloud && (this.meshCloud.invert(X, W), this.forceUpdate());
        }
        /* override */
        isPointCollision(X, W) {
          if (!this.meshCloud)
            return !1;
          const h = this.attributes.pointerEvents;
          if (h === "none" || h !== "all" && !this.isVisible)
            return !1;
          let r = "both";
          h === "visibleFill" && (r = "fill"), h === "visibleStroke" && (r = "stroke");
          for (let L = 0; L < this[Z]; L++)
            if (!this.meshCloud.isPointCollision(L, [X, W], r))
              return !1;
          return !0;
        }
        setOpacity(X, W) {
          this.meshCloud && (this.meshCloud.opacity(X, W), this.forceUpdate());
        }
        rotate(X, W, [h, r] = [0, 0]) {
          const L = Math.PI * W / 180;
          if (this.meshCloud) {
            const {
              x: u,
              y: V
            } = this.meshNode.attributes;
            this.meshCloud.rotate(X, L, [h + u, r + V]), this.forceUpdate();
          }
        }
        saturate(X, W) {
          this.meshCloud && (this.meshCloud.saturate(X, W), this.forceUpdate());
        }
        scale(X, [W, h = W], [r, L] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: u,
              y: V
            } = this.meshNode.attributes, c = 1e-5;
            Math.abs(W) < c && (W = 1 / W > 0 ? c : -c), Math.abs(h) < c && (h = 1 / h > 0 ? c : -c), this.meshCloud.scale(X, [W, h], [r + u, L + V]), this.forceUpdate();
          }
        }
        setColorTransform(X, W) {
          this.meshCloud && (this.meshCloud.setColorTransform(X, W), this.forceUpdate());
        }
        setFillColor(X, W) {
          this.meshCloud && (Array.isArray(W) && (W = [...W], W[0] /= 255, W[1] /= 255, W[2] /= 255), this.meshCloud.setFillColor(X, W), this.forceUpdate());
        }
        sepia(X, W) {
          this.meshCloud && (this.meshCloud.sepia(X, W), this.forceUpdate());
        }
        /* override */
        setResolution({
          width: X,
          height: W
        }) {
          super.setResolution({
            width: X,
            height: W
          }), this.meshNode.setResolution({
            width: X,
            height: W
          });
        }
        setStrokeColor(X, W) {
          this.meshCloud && (Array.isArray(W) && (W = [...W], W[0] /= 255, W[1] /= 255, W[2] /= 255), this.meshCloud.setStrokeColor(X, W), this.forceUpdate());
        }
        setTransform(X, W) {
          this.meshCloud && (this.meshCloud.setTransform(X, W), this.forceUpdate());
        }
        skew(X, [W, h = W], [r, L] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: u,
              y: V
            } = this.meshNode.attributes;
            this.meshCloud.skew(X, [W, h], [r + u, L + V]), this.forceUpdate();
          }
        }
        transform(X, W) {
          this.meshCloud && (this.meshCloud.transform(X, W), this.forceUpdate());
        }
        transformColor(X, W) {
          this.meshCloud && (this.meshCloud.transformColor(X, W), this.forceUpdate());
        }
        translate(X, [W, h]) {
          this.meshCloud && (this.meshCloud.translate(X, [W, h]), this.forceUpdate());
        }
        updateMesh() {
          this[o] && (this[o].mesh = this.meshNode.mesh, this.forceUpdate());
        }
      }
      b.default.registerNode(G, "cloud");
    },
    /* 218 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "loadTexture", function() {
        return b;
      }), l.d(d, "applyTexture", function() {
        return Z;
      }), l.d(d, "createTexture", function() {
        return G;
      }), l.d(d, "deleteTexture", function() {
        return y;
      }), l.d(d, "drawTexture", function() {
        return W;
      }), l.d(d, "loadFrames", function() {
        return h;
      });
      var i = l(12), t = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = {};
      function b(r, L) {
        if (s[r])
          return s[r];
        const u = i.ENV.loadImage(r, {
          alias: L,
          useImageBitmap: !1
        });
        return u ?? r;
      }
      async function Z(r, L, u) {
        let V = L;
        if (typeof L == "string" && (V = b(L)), V && typeof V.then == "function" && (V = await V), L === r.attributes.texture) {
          V && V.image && (V.sourceRect && (r.attributes.sourceRect = V.sourceRect), r.textureImageRotated = !!V.rotated, V = V.image);
          const {
            width: c,
            height: n,
            textureRect: e
          } = r.attributes, a = r.textureImage;
          r.textureImage = V, u && a !== V && !e && (c == null || n == null) && r.updateContours(), r.forceUpdate();
        }
        return V;
      }
      const o = Symbol("textureMap");
      function G(r, L) {
        if (L[o] = L[o] || /* @__PURE__ */ new Map(), L[o].has(r))
          return L[o].get(r);
        const u = L.createTexture(r);
        return !/^blob:/.test(r.src) && typeof r.getContext != "function" && L[o].set(r, u), u;
      }
      function y(r, L) {
        if (L[o] && L[o].has(r)) {
          const u = L[o].get(r);
          return L.deleteTexture(u), L[o].delete(r), !0;
        }
        return !1;
      }
      const X = Symbol("textureContext");
      function W(r, L) {
        const u = r.textureImage instanceof String ? String(r.textureImage) : r.textureImage, V = r.textureImageRotated, c = L.texture, n = r.renderer;
        if (u) {
          const e = r.originalContentRect;
          let a = r.attributes.textureRect;
          const Y = r.attributes.textureRepeat, R = r.attributes.sourceRect;
          if (!c || r[X] && r[X] !== n || c.image !== u || c.options.repeat !== Y || !Object(t.compareValue)(c.options.rect, a) || !Object(t.compareValue)(c.options.srcRect, R)) {
            const C = G(u, n);
            a ? (a[0] += e[0], a[1] += e[1]) : a = e;
            let N = null;
            c && !n[o].has(c.image) && (!c.options || !c.options.hidden) && (N = L.uniforms.u_texSampler), L.setTexture(C, {
              rect: a,
              repeat: Y,
              srcRect: R,
              rotated: V
            }), N && N.delete && N.delete(), r[X] = n;
          }
        } else if (c) {
          let e = null;
          !n[o].has(c.image) && (!c.options || !c.options.hidden) && (e = L.uniforms.u_texSampler), L.setTexture(null), e && e.delete && e.delete();
        }
      }
      async function h(r, L) {
        typeof L == "string" && (L = await (await fetch(L, {
          method: "GET",
          mode: "cors",
          cache: "default"
        })).json());
        const u = await b(r), V = L.frames;
        return Object.entries(V).forEach(([c, n]) => {
          const {
            x: e,
            y: a,
            w: Y,
            h: R
          } = n.frame;
          let C = [e, a, Y, R];
          const N = n.rotated;
          N && (C = [C[0], C[1], C[3], C[2]]), s[c] = {
            image: u,
            sourceRect: C,
            rotated: N
          };
        }), u;
      }
    },
    /* 219 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return h;
      });
      var i = l(1), t = l(12), s = l(70), b = l(220), Z = l(221), o = l(222), G = l(213), y = l(223);
      l(1).glMatrix.setMatrixArrayType(Array);
      function X(r, L, u) {
        return L in r ? Object.defineProperty(r, L, { value: u, enumerable: !0, configurable: !0, writable: !0 }) : r[L] = u, r;
      }
      const W = Symbol("mesh");
      class h extends s.default {
        constructor(L = {}) {
          super(L);
        }
        get borderSize() {
          const {
            paddingTop: L,
            paddingRight: u,
            paddingBottom: V,
            paddingLeft: c,
            borderWidth: n
          } = this.attributes, [e, a] = this.contentSize;
          return [c + e + u + n, L + a + V + n];
        }
        // content + padding
        get clientSize() {
          const {
            paddingTop: L,
            paddingRight: u,
            paddingBottom: V,
            paddingLeft: c
          } = this.attributes, [n, e] = this.contentSize;
          return [c + n + u, L + e + V];
        }
        get contentSize() {
          let {
            width: L,
            height: u,
            boxSizing: V,
            paddingTop: c,
            paddingRight: n,
            paddingBottom: e,
            paddingLeft: a
          } = this.attributes;
          if (L = L || 0, u = u || 0, V === "border-box") {
            const Y = 2 * this.attributes.borderWidth;
            L -= Y + n + a, u -= Y + c + e, L = Math.max(0, L), u = Math.max(0, u);
          }
          return [L, u];
        }
        get hasBorder() {
          return this.attributes.borderWidth > 0;
        }
        /* override */
        get isVisible() {
          const [L, u] = this.borderSize;
          return L > 0 && u > 0;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const L = this.clientBox;
          if (L) {
            let u = this[W];
            if (u)
              u.box !== L && (u.contours = L.contours, u.box = L);
            else {
              u = new t.Mesh2D(L), u.box = L;
              const c = this.attributes.bgcolor;
              if (Object(Z.setFillColor)(u, {
                color: c
              }), this.hasBorder) {
                const {
                  borderColor: e,
                  borderWidth: a,
                  borderDash: Y,
                  borderDashOffset: R
                } = this.attributes;
                Object(Z.setStrokeColor)(u, {
                  color: e,
                  lineWidth: a,
                  lineDash: Y,
                  lineDashOffset: R
                });
              }
              this[W] = u;
              const n = this.attributes.clipPath;
              n && this[W].setClipPath(n);
            }
            const V = this.opacity;
            return u.getOpacity() !== V && u.setOpacity(V), u.setTransform(...this.renderMatrix), u;
          }
          return null;
        }
        // content + padding + border
        get offsetSize() {
          const {
            paddingTop: L,
            paddingRight: u,
            paddingBottom: V,
            paddingLeft: c,
            borderWidth: n
          } = this.attributes, [e, a] = this.contentSize, Y = 2 * n;
          return [c + e + u + Y, L + a + V + Y];
        }
        get originalClientRect() {
          if (this.mesh) {
            const L = this.mesh.boundingBox;
            return [L[0][0], L[0][1], L[1][0] - L[0][0], L[1][1] - L[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalContentRect() {
          const [L, u, V, c] = this.originalClientRect, n = this.attributes.padding;
          return [L + n[0], u + n[1], V - n[0] - n[2], c - n[1] - n[3]];
        }
        getBoundingClientRect() {
          let L = this.renderMatrix;
          this.layer && this.layer.layerTransformInvert && (L = i.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), this.layer.transformMatrix, L));
          let u = null;
          if (this.mesh) {
            u = [...this.mesh.boundingBox];
            const V = this.attributes.borderWidth;
            V && (u[0] = [u[0][0] - V, u[0][1] - V], u[1] = [u[1][0] + V, u[1][1] + V]);
          }
          return Object(y.default)(u, L);
        }
        // transformPoint(x, y) {
        //   const m = mat2d.invert(this.renderMatrix);
        //   const newX = x * m[0] + y * m[2] + m[4];
        //   const newY = x * m[1] + y * m[3] + m[5];
        //   return [newX, newY];
        // }
        /* override */
        onPropertyChange(L, u, V) {
          if (super.onPropertyChange(L, u, V), (L === "anchorX" || L === "anchorY" || L === "boxSizing" || L === "width" || L === "height" || L === "borderWidth" || L === "paddingLeft" || L === "paddingRight" || L === "paddingTop" || L === "paddingBottom" || /^border(TopLeft|TopRight|BottomRight|BottomLeft)Radius$/.test(L)) && this.updateContours(), this[W] && L === "clipPath" && this[W].setClipPath(u), this[W] && L === "bgcolor" && Object(Z.setFillColor)(this[W], {
            color: u
          }), this[W] && (L === "borderColor" || L === "borderWidth" || L === "borderDash" || L === "borderDashOffset")) {
            const {
              borderColor: c,
              borderWidth: n,
              borderDash: e,
              borderDashOffset: a
            } = this.attributes;
            Object(Z.setStrokeColor)(this[W], {
              color: c,
              lineWidth: n,
              lineDash: n ? e : 0,
              lineDashOffset: a
            });
          }
        }
        /* override */
        updateContours() {
          const {
            anchorX: L,
            anchorY: u,
            borderWidth: V,
            borderRadius: c
          } = this.attributes, [n, e] = this.borderSize, a = this.offsetSize, Y = 0.5 * V, R = -L * a[0] + Y, C = -u * a[1] + Y;
          this.clientBox = new t.Figure2D(), Object(o.createRadiusBox)(this.clientBox, [R, C, n, e], c);
        }
      }
      X(h, "Attr", b.default), G.default.registerNode(h, "block");
    },
    /* 220 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return y;
      });
      var i = l(71), t = l(72), s = l(221);
      l(1).glMatrix.setMatrixArrayType(Array);
      const b = Symbol.for("spritejs_setAttribute"), Z = Symbol.for("spritejs_getAttribute"), o = Symbol.for("spritejs_setAttributeDefault"), G = Symbol.for("spritejs_declareAlias");
      class y extends i.default {
        constructor(W) {
          super(W), this[o]({
            anchorX: 0,
            anchorY: 0,
            /* anchor */
            width: void 0,
            height: void 0,
            /* size */
            borderWidth: 0,
            borderColor: "rgba(0,0,0,1)",
            /* border */
            borderDash: void 0,
            borderDashOffset: 0,
            borderTopLeftRadius: [0, 0],
            borderTopRightRadius: [0, 0],
            borderBottomRightRadius: [0, 0],
            borderBottomLeftRadius: [0, 0],
            /* borderRadius */
            bgcolor: "rgba(0,0,0,0)",
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            /* padding */
            boxSizing: "content-box",
            clipPath: void 0
          }), this[G]("anchor", "size", "border", "borderRadius", "padding");
        }
        get anchorX() {
          return this[Z]("anchorX");
        }
        set anchorX(W) {
          this[b]("anchorX", Object(t.toNumber)(W));
        }
        get anchorY() {
          return this[Z]("anchorY");
        }
        set anchorY(W) {
          this[b]("anchorY", Object(t.toNumber)(W));
        }
        get anchor() {
          return [this.anchorX, this.anchorY];
        }
        set anchor(W) {
          W = Object(t.toArray)(W), Array.isArray(W) || (W = [W, W]), this.anchorX = W[0], this.anchorY = W[1];
        }
        get width() {
          return this[Z]("width");
        }
        set width(W) {
          this[b]("width", Object(t.toNumber)(W));
        }
        get height() {
          return this[Z]("height");
        }
        set height(W) {
          this[b]("height", Object(t.toNumber)(W));
        }
        get size() {
          return [this.width, this.height];
        }
        set size(W) {
          W = Object(t.toArray)(W), Array.isArray(W) || (W = [W, W]), this.width = W[0], this.height = W[1];
        }
        get borderWidth() {
          return this[Z]("borderWidth");
        }
        set borderWidth(W) {
          this[b]("borderWidth", Object(t.toNumber)(W));
        }
        get borderColor() {
          return this[Z]("borderColor");
        }
        set borderColor(W) {
          this[b]("borderColor", Object(s.parseColor)(W));
        }
        get border() {
          return [this.borderWidth, this.borderColor];
        }
        set border(W) {
          W = Object(t.toArray)(W), Array.isArray(W) || (W = [W]), this.borderWidth = W[0], W[1] != null && (this.borderColor = W[1]);
        }
        get borderDash() {
          return this[Z]("borderDash");
        }
        set borderDash(W) {
          W = Object(t.toArray)(W, !0), W != null && !Array.isArray(W) && (W = [W]), this[b]("borderDash", W ? W.map(t.toNumber) : null);
        }
        get borderDashOffset() {
          return this[Z]("borderDashOffset");
        }
        set borderDashOffset(W) {
          this[b]("borderDashOffset", Object(t.toNumber)(W));
        }
        get borderTopLeftRadius() {
          return this[Z]("borderTopLeftRadius");
        }
        set borderTopLeftRadius(W) {
          W = Object(t.toArray)(W, !0), Array.isArray(W) || (W = [W, W]), this[b]("borderTopLeftRadius", W.map(t.toNumber));
        }
        get borderTopRightRadius() {
          return this[Z]("borderTopRightRadius");
        }
        set borderTopRightRadius(W) {
          W = Object(t.toArray)(W, !0), Array.isArray(W) || (W = [W, W]), this[b]("borderTopRightRadius", W.map(t.toNumber));
        }
        get borderBottomRightRadius() {
          return this[Z]("borderBottomRightRadius");
        }
        set borderBottomRightRadius(W) {
          W = Object(t.toArray)(W, !0), Array.isArray(W) || (W = [W, W]), this[b]("borderBottomRightRadius", W.map(t.toNumber));
        }
        get borderBottomLeftRadius() {
          return this[Z]("borderBottomLeftRadius");
        }
        set borderBottomLeftRadius(W) {
          W = Object(t.toArray)(W, !0), Array.isArray(W) || (W = [W, W]), this[b]("borderBottomLeftRadius", W.map(t.toNumber));
        }
        get borderRadius() {
          return [...this.borderTopLeftRadius, ...this.borderTopRightRadius, ...this.borderBottomRightRadius, ...this.borderBottomLeftRadius];
        }
        set borderRadius(W) {
          if (W = Object(t.toArray)(W), !Array.isArray(W))
            W = Array(8).fill(W);
          else if (W.length === 2)
            W = [W[0], W[1], W[0], W[1], W[0], W[1], W[0], W[1]];
          else if (W.length === 4)
            W = [W[0], W[1], W[2], W[3], W[0], W[1], W[2], W[3]];
          else if (W.length === 6)
            W = [W[0], W[1], W[2], W[3], W[4], W[5], W[2], W[3]];
          else if (W.length !== 8)
            throw new TypeError("Invalid borderRadius value.");
          this.borderTopLeftRadius = [W[0], W[1]], this.borderTopRightRadius = [W[2], W[3]], this.borderBottomRightRadius = [W[4], W[5]], this.borderBottomLeftRadius = [W[6], W[7]];
        }
        get bgcolor() {
          return this[Z]("bgcolor");
        }
        set bgcolor(W) {
          this[b]("bgcolor", Object(s.parseColor)(W));
        }
        get paddingTop() {
          return this[Z]("paddingTop");
        }
        set paddingTop(W) {
          this[b]("paddingTop", Object(t.toNumber)(W));
        }
        get paddingRight() {
          return this[Z]("paddingRight");
        }
        set paddingRight(W) {
          this[b]("paddingRight", Object(t.toNumber)(W));
        }
        get paddingBottom() {
          return this[Z]("paddingBottom");
        }
        set paddingBottom(W) {
          this[b]("paddingBottom", Object(t.toNumber)(W));
        }
        get paddingLeft() {
          return this[Z]("paddingLeft");
        }
        set paddingLeft(W) {
          this[b]("paddingLeft", Object(t.toNumber)(W));
        }
        get padding() {
          return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
        }
        set padding(W) {
          W = Object(t.toArray)(W), Array.isArray(W) ? W.length === 2 ? W = [W[0], W[1], W[0], W[1]] : W.length === 3 && (W = [W[0], W[1], W[2], W[1]]) : W = [W, W, W, W], this.paddingTop = W[0], this.paddingRight = W[1], this.paddingBottom = W[2], this.paddingLeft = W[3];
        }
        get clipPath() {
          return this[Z]("clipPath");
        }
        set clipPath(W) {
          this[b]("clipPath", W);
        }
        get boxSizing() {
          return this[Z]("boxSizing");
        }
        set boxSizing(W) {
          if (W != null && W !== "border-box" && W !== "content-box")
            throw new TypeError("Invalid boxSizing type.");
          this[b]("boxSizing", W);
        }
      }
    },
    /* 221 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "Gradient", function() {
        return s;
      }), l.d(d, "isTransparent", function() {
        return b;
      }), l.d(d, "parseColor", function() {
        return Z;
      }), l.d(d, "setFillColor", function() {
        return G;
      }), l.d(d, "setStrokeColor", function() {
        return y;
      }), l.d(d, "Color", function() {
        return X;
      });
      var i = l(32), t = /* @__PURE__ */ l.n(i);
      l(1).glMatrix.setMatrixArrayType(Array);
      class s {
        constructor({
          vector: h,
          colors: r
        }) {
          if (!Array.isArray(h) || h.length !== 4 && h.length !== 6 && h.length !== 3)
            throw new TypeError("Invalid gradient");
          this.vector = h, this.colors = r.map(({
            offset: L,
            color: u
          }) => ({
            offset: L,
            color: Z(u)
          }));
        }
        toString() {
          return JSON.stringify({
            vector: this.vector,
            colors: this.colors
          });
        }
      }
      function b(W) {
        return W instanceof s ? !1 : W == null ? !0 : t()(W)[3] === 0;
      }
      function Z(W) {
        if (W == null || (W || (W = "transparent"), W instanceof s))
          return W;
        const h = t()(W);
        if (!h || !h.length)
          throw new TypeError("Invalid color value.");
        return `rgba(${h.join()})`;
      }
      function o(W, h, r) {
        const L = W.boundingBox[0];
        if (r.vector) {
          let {
            vector: u,
            colors: V
          } = r;
          u.length === 4 ? (u = [u[0] + L[0], u[1] + L[1], u[2] + L[0], u[3] + L[1]], W.setLinearGradient({
            vector: u,
            colors: V,
            type: h
          })) : u.length === 3 ? (u = [u[0] + L[0], u[1] + L[1], u[2]], W.setCircularGradient({
            vector: u,
            colors: V,
            type: h
          })) : (u = [u[0] + L[0], u[1] + L[1], u[2], u[3] + L[0], u[4] + L[1], u[5]], W.setRadialGradient({
            vector: u,
            colors: V,
            type: h
          }));
        } else
          W.gradient && W.gradient[h] && (delete W.gradient[h], delete W.uniforms.u_radialGradientVector);
      }
      function G(W, {
        color: h,
        rule: r = "nonzero"
      }) {
        return o(W, "fill", h), h.vector || W.setFill({
          color: h,
          rule: r
        }), W;
      }
      function y(W, {
        color: h,
        lineWidth: r,
        lineCap: L,
        lineJoin: u,
        lineDash: V,
        lineDashOffset: c,
        miterLimit: n,
        roundSegments: e
      }) {
        o(W, "stroke", h), h.vector && (h = [0, 0, 0, 1]), W.setStroke({
          color: h,
          thickness: r,
          cap: L,
          join: u,
          miterLimit: n,
          lineDash: V,
          lineDashOffset: c,
          roundSegments: e
        });
      }
      class X extends Array {
        constructor(h = 0, r = 0, L = 0, u = 0) {
          return Array.isArray(h) && ([h, r, L, u] = h), typeof h == "string" && ([h, r, L, u] = t()(h), h /= 255, r /= 255, L /= 255), super(h, r, L, u), this;
        }
        get r() {
          return Math.round(this[0] * 255);
        }
        set r(h) {
          this[0] = h / 255;
        }
        get g() {
          return Math.round(this[1] * 255);
        }
        set g(h) {
          this[1] = h / 255;
        }
        get b() {
          return Math.round(this[2] * 255);
        }
        set b(h) {
          this[2] = h / 255;
        }
        get a() {
          return this[3];
        }
        set a(h) {
          this[3] = h;
        }
        get hex() {
          const h = `0${this.r.toString(16)}`.slice(-2), r = `0${this.g.toString(16)}`.slice(-2), L = `0${this.b.toString(16)}`.slice(-2);
          let u;
          return this.a < 1 && (u = Math.round(this[3] * 255), u = `0${u.toString(16)}`.slice(-2)), `#${h}${r}${L}${u || ""}`;
        }
        get rgba() {
          return `rgba(${this.r},${this.g},${this.b},${this.a})`;
        }
        fromColor(h) {
          return typeof h == "string" && (h = t()(h), h[0] /= 255, h[1] /= 255, h[2] /= 255), this[0] = h[0], this[1] = h[1], this[2] = h[2], this[3] = h[3], this;
        }
      }
    },
    /* 222 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "createRadiusBox", function() {
        return t;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(s, b, Z, o, G, y = "leftTop") {
        const X = 0.5522848, W = o / 2 * X, h = G / 2 * X, r = b + o, L = Z + G, u = b + o / 2, V = Z + G / 2;
        y === "leftTop" ? (s.moveTo(b, V), s.bezierCurveTo(b, V - h, u - W, Z, u, Z)) : y === "rightTop" ? s.bezierCurveTo(u + W, Z, r, V - h, r, V) : y === "rightBottom" ? s.bezierCurveTo(r, V + h, u + W, L, u, L) : y === "leftBottom" && s.bezierCurveTo(u - W, L, b, V + h, b, V);
      }
      function t(s, [b, Z, o, G], y) {
        if (!y || Array.isArray(y) && y.every((X) => X === 0))
          s.beginPath(), s.rect(b, Z, o, G);
        else {
          typeof y == "number" && (y = Array(8).fill(y));
          const [X, W, h, r, L, u, V, c] = y.map((n, e) => e % 2 ? Math.min(n, G / 2) : Math.min(n, o / 2));
          s.beginPath(), s.moveTo(b, Z + W), i(s, b, Z, X * 2, W * 2, "leftTop"), s.lineTo(b + o - h, Z), i(s, b + o - h * 2, Z, h * 2, r * 2, "rightTop"), s.lineTo(b + o, Z + G - u), i(s, b + o - L * 2, Z + G - u * 2, L * 2, u * 2, "rightBottom"), s.lineTo(b + V, Z + G), i(s, b, Z + G - c * 2, V * 2, c * 2, "leftBottom"), s.closePath();
        }
        return s;
      }
    },
    /* 223 */
    /***/
    function(m, d, l) {
      l.r(d), l(1).glMatrix.setMatrixArrayType(Array), d.default = function(i, t) {
        if (!i)
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
        const [[s, b], [Z, o]] = i, G = s * t[0] + b * t[2] + t[4], y = s * t[1] + b * t[3] + t[5], X = Z * t[0] + b * t[2] + t[4], W = Z * t[1] + b * t[3] + t[5], h = Z * t[0] + o * t[2] + t[4], r = Z * t[1] + o * t[3] + t[5], L = s * t[0] + o * t[2] + t[4], u = s * t[1] + o * t[3] + t[5], V = Math.min(G, X, h, L), c = Math.min(y, W, r, u), n = Math.max(G, X, h, L), e = Math.max(y, W, r, u);
        return {
          x: V,
          y: c,
          width: n - V,
          height: e - c,
          left: V,
          top: c,
          right: n,
          bottom: e
        };
      };
    },
    /* 224 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(218), t = l(219), s = l(225), b = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      function Z(y, X, W) {
        return X in y ? Object.defineProperty(y, X, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : y[X] = W, y;
      }
      const o = Symbol("textureTask");
      class G extends t.default {
        constructor(X = {}) {
          typeof X == "string" && (X = {
            texture: X
          }), super(X);
        }
        /* override */
        get contentSize() {
          let [X, W] = super.contentSize;
          const {
            width: h,
            height: r
          } = this.attributes;
          if (h == null || r == null) {
            const L = this.textureImage, u = this.attributes.textureRect, V = this.attributes.sourceRect;
            if (u)
              h == null && (X = u[0] + u[2]), r == null && (W = u[1] + u[3]);
            else if (V) {
              const c = this.layer ? this.layer.displayRatio : 1;
              h == null && (X = V[2] / c), r == null && (W = V[3] / c);
            } else if (L) {
              const c = this.layer ? this.layer.displayRatio : 1;
              h == null && (X = L.width / c), r == null && (W = L.height / c);
            }
          }
          return [X, W];
        }
        get textureImageReady() {
          return this[o] || Promise.resolve();
        }
        /* override */
        draw(X = []) {
          super.draw(X);
          const W = this.mesh;
          return W && Object(i.drawTexture)(this, W), X;
        }
        /* override */
        onPropertyChange(X, W, h) {
          if (super.onPropertyChange(X, W, h), X === "texture" && (this[o] = Object(i.applyTexture)(this, W, !0)), X === "textureRect") {
            const {
              width: r,
              height: L
            } = this.attributes;
            (r == null || L == null) && this.updateContours();
          }
        }
      }
      Z(G, "Attr", s.default), b.default.registerNode(G, "sprite");
    },
    /* 225 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(220);
      l(1).glMatrix.setMatrixArrayType(Array);
      const t = Symbol.for("spritejs_setAttributeDefault"), s = Symbol.for("spritejs_setAttribute"), b = Symbol.for("spritejs_getAttribute");
      class Z extends i.default {
        constructor(G) {
          super(G), this[t]({
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0
          });
        }
        get texture() {
          return this[b]("texture");
        }
        set texture(G) {
          this[s]("texture", G);
        }
        get textureRect() {
          return this[b]("textureRect");
        }
        set textureRect(G) {
          this[s]("textureRect", G);
        }
        get sourceRect() {
          return this[b]("sourceRect");
        }
        set sourceRect(G) {
          this[s]("sourceRect", G);
        }
        get textureRepeat() {
          return this[b]("textureRepeat");
        }
        set textureRepeat(G) {
          this[s]("textureRepeat", !!G);
        }
      }
    },
    /* 226 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return r;
      });
      var i = l(12), t = l(227), s = /* @__PURE__ */ l.n(t), b = l(70), Z = l(228), o = l(221), G = l(218), y = l(213), X = l(223);
      l(1).glMatrix.setMatrixArrayType(Array);
      function W(L, u, V) {
        return u in L ? Object.defineProperty(L, u, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : L[u] = V, L;
      }
      const h = Symbol("mesh");
      class r extends b.default {
        constructor(u = {}) {
          typeof u == "string" && (u = {
            d: u
          }), super(u), this.effects = {
            d(V, c, n, e, a) {
              const Y = (n - e) / (a - e);
              if (Y <= 0)
                return V;
              if (Y >= 1)
                return c;
              const R = s.a._preprocessing(s.a.path2shapes(V), s.a.path2shapes(c)), C = s.a._lerp(...R, Y)[0];
              return C.reduce((I, J) => `${I}${J.slice(2).join(" ")} `, `M${C[0][0]} ${C[0][1]}C`).trim();
            }
          };
        }
        /* override */
        get isVisible() {
          return !!this.d;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const u = this.path;
          if (u) {
            let V = this[h];
            if (V)
              V.path !== u && (V.contours = u.contours, V.path = u);
            else {
              V = new i.Mesh2D(this.path), V.path = u;
              const n = this.attributes.fillColor, e = this.attributes.fillRule;
              n && Object(o.setFillColor)(V, {
                color: n,
                rule: e
              });
              const a = this.attributes.lineWidth, Y = this.attributes.strokeColor;
              if (Y && a > 0) {
                const {
                  lineCap: C,
                  lineJoin: N,
                  miterLimit: I,
                  lineDash: J,
                  lineDashOffset: T,
                  roundSegments: K
                } = this.attributes;
                Object(o.setStrokeColor)(V, {
                  color: Y,
                  lineWidth: a,
                  lineCap: C,
                  lineJoin: N,
                  miterLimit: I,
                  lineDash: J,
                  lineDashOffset: T,
                  roundSegments: K
                });
              }
              this[h] = V;
              const R = this.attributes.clipPath;
              R && this[h].setClipPath(R);
            }
            const c = this.opacity;
            return V.getOpacity() !== c && V.setOpacity(c), V.setTransform(...this.renderMatrix), V;
          }
          return null;
        }
        get originalContentRect() {
          if (this.path) {
            const u = this.path.boundingBox;
            return [u[0][0], u[0][1], u[1][0] - u[0][0], u[1][1] - u[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientRect() {
          if (this.mesh) {
            const u = this.mesh.boundingBox;
            return [u[0][0], u[0][1], u[1][0] - u[0][0], u[1][1] - u[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientCenter() {
          return this.mesh ? this.mesh.boundingCenter : [0, 0];
        }
        set d(u) {
          this.attributes.d = u;
        }
        get d() {
          return this.attributes.d;
        }
        /* override */
        draw(u = []) {
          super.draw(u);
          const V = this.mesh;
          return V && Object(G.drawTexture)(this, V), u;
        }
        getBoundingClientRect() {
          let u = null;
          return this.mesh && (u = this.mesh.boundingBox), Object(X.default)(u, this.renderMatrix);
        }
        getPathLength() {
          return this.mesh ? this.mesh.getTotalLength() : 0;
        }
        getPointAtLength(u) {
          if (this.mesh) {
            const V = this.mesh.getPointAtLength(u);
            if (V)
              return [V.x, V.y];
          }
          return [0, 0];
        }
        /* override */
        onPropertyChange(u, V, c) {
          if (super.onPropertyChange(u, V, c), (u === "d" || u === "normalize") && this.updateContours(), this[h] && (u === "fillColor" || u === "fillRule")) {
            const {
              fillColor: n,
              fillRule: e
            } = this.attributes;
            Object(o.setFillColor)(this[h], {
              color: n,
              rule: e
            });
          }
          if (this[h] && (u === "strokeColor" || u === "lineWidth" || u === "lineCap" || u === "lineJoin" || u === "lineDash" || u === "lineDashOffset" || u === "roundSegments")) {
            const {
              strokeColor: n,
              lineWidth: e
            } = this.attributes;
            if (n && e > 0) {
              const {
                lineCap: a,
                lineJoin: Y,
                lineDash: R,
                lineDashOffset: C,
                miterLimit: N,
                roundSegments: I
              } = this.attributes;
              Object(o.setStrokeColor)(this[h], {
                color: n,
                lineCap: a,
                lineJoin: Y,
                lineWidth: e,
                lineDash: R,
                lineDashOffset: C,
                miterLimit: N,
                roundSegments: I
              });
            }
          }
          this[h] && u === "clipPath" && this[h].setClipPath(V), u === "texture" && Object(G.applyTexture)(this, V);
        }
        /* override */
        updateContours() {
          this.path = new i.Figure2D(), this.path.addPath(this.attributes.d), this.attributes.normalize && this.path.normalize(...this.path.boundingCenter);
        }
      }
      W(r, "Attr", Z.default), y.default.registerNode(r, "path");
    },
    /* 227 */
    /***/
    function(m, d, l) {
      (function(i, t) {
        m.exports = t();
      })(this, function() {
        var i = /* @__PURE__ */ function() {
          function J(T, K) {
            var S = [], H = !0, w = !1, P = void 0;
            try {
              for (var B = T[Symbol.iterator](), D; !(H = (D = B.next()).done) && (S.push(D.value), !(K && S.length === K)); H = !0)
                ;
            } catch (z) {
              w = !0, P = z;
            } finally {
              try {
                !H && B.return && B.return();
              } finally {
                if (w)
                  throw P;
              }
            }
            return S;
          }
          return function(T, K) {
            if (Array.isArray(T))
              return T;
            if (Symbol.iterator in Object(T))
              return J(T, K);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), t = Math.PI * 2, s = function(T, K, S, H, w, P, B) {
          var D = T.x, z = T.y;
          D *= K, z *= S;
          var U = H * D - w * z, O = w * D + H * z;
          return {
            x: U + P,
            y: O + B
          };
        }, b = function(T, K) {
          var S = 1.3333333333333333 * Math.tan(K / 4), H = Math.cos(T), w = Math.sin(T), P = Math.cos(T + K), B = Math.sin(T + K);
          return [{
            x: H - w * S,
            y: w + H * S
          }, {
            x: P + B * S,
            y: B - P * S
          }, {
            x: P,
            y: B
          }];
        }, Z = function(T, K, S, H) {
          var w = T * H - K * S < 0 ? -1 : 1, P = Math.sqrt(T * T + K * K), B = Math.sqrt(T * T + K * K), D = T * S + K * H, z = D / (P * B);
          return z > 1 && (z = 1), z < -1 && (z = -1), w * Math.acos(z);
        }, o = function(T, K, S, H, w, P, B, D, z, U, O, ll) {
          var _ = Math.pow(w, 2), Zl = Math.pow(P, 2), $ = Math.pow(O, 2), ol = Math.pow(ll, 2), al = _ * Zl - _ * ol - Zl * $;
          al < 0 && (al = 0), al /= _ * ol + Zl * $, al = Math.sqrt(al) * (B === D ? -1 : 1);
          var g = al * w / P * ll, k = al * -P / w * O, j = U * g - z * k + (T + S) / 2, A = z * g + U * k + (K + H) / 2, M = (O - g) / w, Q = (ll - k) / P, p = (-O - g) / w, x = (-ll - k) / P, F = Z(1, 0, M, Q), v = Z(M, Q, p, x);
          return D === 0 && v > 0 && (v -= t), D === 1 && v < 0 && (v += t), [j, A, F, v];
        }, G = function(T) {
          var K = T.px, S = T.py, H = T.cx, w = T.cy, P = T.rx, B = T.ry, D = T.xAxisRotation, z = D === void 0 ? 0 : D, U = T.largeArcFlag, O = U === void 0 ? 0 : U, ll = T.sweepFlag, _ = ll === void 0 ? 0 : ll, Zl = [];
          if (P === 0 || B === 0)
            return [];
          var $ = Math.sin(z * t / 360), ol = Math.cos(z * t / 360), al = ol * (K - H) / 2 + $ * (S - w) / 2, g = -$ * (K - H) / 2 + ol * (S - w) / 2;
          if (al === 0 && g === 0)
            return [];
          P = Math.abs(P), B = Math.abs(B);
          var k = Math.pow(al, 2) / Math.pow(P, 2) + Math.pow(g, 2) / Math.pow(B, 2);
          k > 1 && (P *= Math.sqrt(k), B *= Math.sqrt(k));
          var j = o(K, S, H, w, P, B, O, _, $, ol, al, g), A = i(j, 4), M = A[0], Q = A[1], p = A[2], x = A[3], F = Math.max(Math.ceil(Math.abs(x) / (t / 4)), 1);
          x /= F;
          for (var v = 0; v < F; v++)
            Zl.push(b(p, x)), p += x;
          return Zl.map(function(f) {
            var E = s(f[0], P, B, ol, $, M, Q), q = E.x, dl = E.y, tl = s(f[1], P, B, ol, $, M, Q), ml = tl.x, el = tl.y, cl = s(f[2], P, B, ol, $, M, Q), sl = cl.x, nl = cl.y;
            return { x1: q, y1: dl, x2: ml, y2: el, x: sl, y: nl };
          });
        }, y = {
          a: 7,
          c: 6,
          h: 1,
          l: 2,
          m: 2,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          z: 0
          /**
           * segment pattern
           * @type {RegExp}
           */
        }, X = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function W(J) {
          var T = [];
          return J.replace(X, function(K, S, H) {
            var w = S.toLowerCase();
            for (H = r(H), w == "m" && H.length > 2 && (T.push([S].concat(H.splice(0, 2))), w = "l", S = S == "m" ? "l" : "L"); ; ) {
              if (H.length == y[w])
                return H.unshift(S), T.push(H);
              if (H.length < y[w])
                throw new Error("malformed path data");
              T.push([S].concat(H.splice(0, y[w])));
            }
          }), T;
        }
        var h = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function r(J) {
          var T = J.match(h);
          return T ? T.map(Number) : [];
        }
        function L(J) {
          var T = J[0][0], K = J[0][1], S = T, H = K;
          return J.forEach(function(w) {
            var P = w[0], B = w[2], D = w[4], z = w[6], U = w[1], O = w[3], ll = w[5], _ = w[7];
            T = Math.min(T, P, B, D, z), K = Math.min(K, U, O, ll, _), S = Math.max(S, P, B, D, z), H = Math.max(H, U, O, ll, _);
          }), [T, K, S, H];
        }
        function u(J, T) {
          return Math.sqrt(Math.pow(J[0] - T[0], 2) + Math.pow(J[1] - T[1], 2)) + Math.sqrt(Math.pow(J[2] - T[2], 2) + Math.pow(J[3] - T[3], 2));
        }
        function V(J, T) {
          var K = J[0], S = J[2], H = J[4], w = J[6], P = J[1], B = J[3], D = J[5], z = J[7], U = T[0], O = T[2], ll = T[4], _ = T[6], Zl = T[1], $ = T[3], ol = T[5], al = T[7];
          return Math.sqrt(Math.pow(U - K, 2) + Math.pow(Zl - P, 2)) + Math.sqrt(Math.pow(O - S, 2) + Math.pow($ - B, 2)) + Math.sqrt(Math.pow(ll - H, 2) + Math.pow(ol - D, 2)) + Math.sqrt(Math.pow(_ - w, 2) + Math.pow(al - z, 2));
        }
        function c(J, T) {
          var K = e(J.length), S = [];
          K.forEach(function(w) {
            var P = 0, B = 0;
            w.forEach(function(D) {
              P += V(J[D], T[B++]);
            }), S.push({ index: w, distance: P });
          }), S.sort(function(w, P) {
            return w.distance - P.distance;
          });
          var H = [];
          return S[0].index.forEach(function(w) {
            H.push(J[w]);
          }), H;
        }
        function n(J, T) {
          var K = a(J.length), S = [];
          K.forEach(function(w) {
            var P = 0;
            w.forEach(function(B) {
              P += u(L(J[B]), L(T[B]));
            }), S.push({ index: w, distance: P });
          }), S.sort(function(w, P) {
            return w.distance - P.distance;
          });
          var H = [];
          return S[0].index.forEach(function(w) {
            H.push(J[w]);
          }), H;
        }
        function e(J) {
          for (var T = [], K = 0; K < J; K++) {
            for (var S = [], H = 0; H < J; H++) {
              var w = H + K;
              w > J - 1 && (w -= J), S[w] = H;
            }
            T.push(S);
          }
          return T;
        }
        function a(J) {
          for (var T = [], K = 0; K < J; K++)
            T.push(K);
          return Y(T);
        }
        function Y(J) {
          var T = [], K = [];
          function S(H) {
            var w, P;
            for (w = 0; w < H.length; w++)
              P = H.splice(w, 1)[0], K.push(P), H.length == 0 && T.push(K.slice()), S(H), H.splice(w, 0, P), K.pop();
            return T;
          }
          return S(J);
        }
        var R = {};
        R.parser = W, R.lerpCurve = function(J, T, K) {
          return R.lerpPoints(J[0], J[1], T[0], T[1], K).concat(R.lerpPoints(J[2], J[3], T[2], T[3], K)).concat(R.lerpPoints(J[4], J[5], T[4], T[5], K)).concat(R.lerpPoints(J[6], J[7], T[6], T[7], K));
        }, R.lerpPoints = function(J, T, K, S, H) {
          return [J + (K - J) * H, T + (S - T) * H];
        }, R.q2b = function(J, T, K, S, H, w) {
          return [J, T, (J + 2 * K) / 3, (T + 2 * S) / 3, (H + 2 * K) / 3, (w + 2 * S) / 3, H, w];
        }, R.path2shapes = function(J) {
          for (var T = R.parser(J), K = 0, S = 0, H = 0, w = T.length, P = [], B = null, D = void 0, z = void 0, U = void 0, O = void 0, ll = void 0, _ = void 0, Zl = void 0; H < w; H++) {
            var $ = T[H], ol = $[0], al = T[H - 1];
            switch (ol) {
              case "m":
                ll = P.length, P[ll] = [], B = P[ll], K = K + $[1], S = S + $[2];
                break;
              case "M":
                ll = P.length, P[ll] = [], B = P[ll], K = $[1], S = $[2];
                break;
              case "l":
                B.push([K, S, K, S, K, S, K + $[1], S + $[2]]), K += $[1], S += $[2];
                break;
              case "L":
                B.push([K, S, $[1], $[2], $[1], $[2], $[1], $[2]]), K = $[1], S = $[2];
                break;
              case "h":
                B.push([K, S, K, S, K, S, K + $[1], S]), K += $[1];
                break;
              case "H":
                B.push([K, S, $[1], S, $[1], S, $[1], S]), K = $[1];
                break;
              case "v":
                B.push([K, S, K, S, K, S, K, S + $[1]]), S += $[1];
                break;
              case "V":
                B.push([K, S, K, $[1], K, $[1], K, $[1]]), S = $[1];
                break;
              case "C":
                B.push([K, S, $[1], $[2], $[3], $[4], $[5], $[6]]), K = $[5], S = $[6];
                break;
              case "S":
                al[0] === "C" || al[0] === "c" ? B.push([K, S, K + al[5] - al[3], S + al[6] - al[4], $[1], $[2], $[3], $[4]]) : (al[0] === "S" || al[0] === "s") && B.push([K, S, K + al[3] - al[1], S + al[4] - al[2], $[1], $[2], $[3], $[4]]), K = $[3], S = $[4];
                break;
              case "c":
                B.push([K, S, K + $[1], S + $[2], K + $[3], S + $[4], K + $[5], S + $[6]]), K = K + $[5], S = S + $[6];
                break;
              case "s":
                al[0] === "C" || al[0] === "c" ? B.push([K, S, K + al[5] - al[3], S + al[6] - al[4], K + $[1], S + $[2], K + $[3], S + $[4]]) : (al[0] === "S" || al[0] === "s") && B.push([K, S, K + al[3] - al[1], S + al[4] - al[2], K + $[1], S + $[2], K + $[3], S + $[4]]), K = K + $[3], S = S + $[4];
                break;
              case "a":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: K,
                  py: S,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: K + $[6],
                  cy: S + $[7]
                }), Zl = _[_.length - 1], _.forEach(function(g, k) {
                  k === 0 ? B.push([K, S, g.x1, g.y1, g.x2, g.y2, g.x, g.y]) : B.push([_[k - 1].x, _[k - 1].y, g.x1, g.y1, g.x2, g.y2, g.x, g.y]);
                }), K = Zl.x, S = Zl.y;
                break;
              case "A":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: K,
                  py: S,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: $[6],
                  cy: $[7]
                }), Zl = _[_.length - 1], _.forEach(function(g, k) {
                  k === 0 ? B.push([K, S, g.x1, g.y1, g.x2, g.y2, g.x, g.y]) : B.push([_[k - 1].x, _[k - 1].y, g.x1, g.y1, g.x2, g.y2, g.x, g.y]);
                }), K = Zl.x, S = Zl.y;
                break;
              case "Q":
                B.push(R.q2b(K, S, $[1], $[2], $[3], $[4])), K = $[3], S = $[4];
                break;
              case "q":
                B.push(R.q2b(K, S, K + $[1], S + $[2], $[3] + K, $[4] + S)), K += $[3], S += $[4];
                break;
              case "T":
                al[0] === "Q" || al[0] === "q" ? (U = K + al[3] - al[1], O = S + al[4] - al[2], B.push(R.q2b(K, S, U, O, $[1], $[2]))) : (al[0] === "T" || al[0] === "t") && (B.push(R.q2b(K, S, K + K - U, S + S - O, $[1], $[2])), U = K + K - U, O = S + S - O), K = $[1], S = $[2];
                break;
              case "t":
                al[0] === "Q" || al[0] === "q" ? (U = K + al[3] - al[1], O = S + al[4] - al[2], B.push(R.q2b(K, S, U, O, K + $[1], S + $[2]))) : (al[0] === "T" || al[0] === "t") && (B.push(R.q2b(K, S, K + K - U, S + S - O, K + $[1], S + $[2])), U = K + K - U, O = S + S - O), K += $[1], S += $[2];
                break;
              case "Z":
                D = B[0][0], z = B[0][1], B.push([K, S, D, z, D, z, D, z]);
                break;
              case "z":
                D = B[0][0], z = B[0][1], B.push([K, S, D, z, D, z, D, z]);
                break;
            }
          }
          return P;
        }, R._upCurves = function(J, T) {
          for (var K = 0, S = 0, H = J.length; K < T; K++)
            J.push(J[S].slice(0)), S++, S > H - 1 && (S -= H);
        };
        function C(J, T, K, S, H, w, P, B, D) {
          return {
            left: N(J, T, K, S, H, w, P, B, D),
            right: N(P, B, H, w, K, S, J, T, 1 - D, !0)
          };
        }
        function N(J, T, K, S, H, w, P, B, D, z) {
          var U = (K - J) * D + J, O = (S - T) * D + T, ll = (H - K) * D + K, _ = (w - S) * D + S, Zl = (P - H) * D + H, $ = (B - w) * D + w, ol = (ll - U) * D + U, al = (_ - O) * D + O, g = (Zl - ll) * D + ll, k = ($ - _) * D + _, j = (g - ol) * D + ol, A = (k - al) * D + al;
          return z ? [j, A, ol, al, U, O, J, T] : [J, T, U, O, ol, al, j, A];
        }
        R._splitCurves = function(J, T) {
          for (var K = 0, S = 0; K < T; K++) {
            var H = J[S], w = C(H[0], H[1], H[2], H[3], H[4], H[5], H[6], H[7], 0.5);
            J.splice(S, 1), J.splice(S, 0, w.left, w.right), S += 2, S >= J.length - 1 && (S = 0);
          }
        };
        function I(J, T) {
          for (var K = function(w) {
            var P = J[J.length - 1], B = [];
            P.forEach(function(D) {
              B.push(D.slice(0));
            }), J.push(B);
          }, S = 0; S < T; S++)
            K();
        }
        return R.lerp = function(J, T, K) {
          return R._lerp(R.path2shapes(J), R.path2shapes(T), K);
        }, R.MIM_CURVES_COUNT = 100, R._preprocessing = function(J, T) {
          var K = J.length, S = T.length, H = JSON.parse(JSON.stringify(J)), w = JSON.parse(JSON.stringify(T));
          return K > S ? I(w, K - S) : K < S && I(H, S - K), H = n(H, w), H.forEach(function(P, B) {
            var D = P.length, z = w[B].length;
            D > z ? D < R.MIM_CURVES_COUNT ? (R._splitCurves(P, R.MIM_CURVES_COUNT - D), R._splitCurves(w[B], R.MIM_CURVES_COUNT - z)) : R._splitCurves(w[B], D - z) : D < z && (z < R.MIM_CURVES_COUNT ? (R._splitCurves(P, R.MIM_CURVES_COUNT - D), R._splitCurves(w[B], R.MIM_CURVES_COUNT - z)) : R._splitCurves(P, z - D));
          }), H.forEach(function(P, B) {
            H[B] = c(P, w[B]);
          }), [H, w];
        }, R._lerp = function(J, T, K) {
          var S = [];
          return J.forEach(function(H, w) {
            var P = [];
            H.forEach(function(B, D) {
              P.push(R.lerpCurve(B, T[w][D], K));
            }), S.push(P);
          }), S;
        }, R.animate = function(J) {
          var T = R.path2shapes(J.from), K = R.path2shapes(J.to), S = R._preprocessing(T, K), H = /* @__PURE__ */ new Date(), w = J.end || function() {
          }, P = J.progress || function() {
          }, B = J.begin || function() {
          }, D = J.easing || function(_) {
            return _;
          }, z = null, U = null, O = J.time;
          B(T);
          var ll = function _() {
            var Zl = /* @__PURE__ */ new Date() - H;
            if (Zl >= O) {
              U = K, P(U, 1), w(U), cancelAnimationFrame(z);
              return;
            }
            var $ = D(Zl / O);
            U = R._lerp(S[0], S[1], $), P(U, $), z = requestAnimationFrame(_);
          };
          ll();
        }, R;
      });
    },
    /* 228 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(71), t = l(221), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const b = Symbol.for("spritejs_setAttributeDefault"), Z = Symbol.for("spritejs_setAttribute"), o = Symbol.for("spritejs_getAttribute");
      class G extends i.default {
        constructor(X) {
          super(X), this[b]({
            d: "",
            normalize: !1,
            fillColor: void 0,
            fillRule: "nonzero",
            strokeColor: void 0,
            lineWidth: 1,
            lineJoin: "miter",
            // 'miter' or 'bevel' or 'round'
            lineCap: "butt",
            // 'butt' or 'square' or 'round'
            roundSegments: 20,
            // default roundSegment if lineJoin or lineCap is round
            lineDash: void 0,
            lineDashOffset: 0,
            miterLimit: 10,
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0,
            clipPath: void 0
          });
        }
        get d() {
          return this[o]("d");
        }
        set d(X) {
          this[Z]("d", X);
        }
        get normalize() {
          return this[o]("normalize");
        }
        set normalize(X) {
          this[Z]("normalize", !!X);
        }
        get fillColor() {
          return this[o]("fillColor");
        }
        set fillColor(X) {
          this[Z]("fillColor", Object(t.parseColor)(X));
        }
        get fillRule() {
          return this[o]("fillRule");
        }
        set fillRule(X) {
          if (X != null && X !== "nonzero" && X !== "evenodd")
            throw new TypeError("Invalid fill rule.");
          this[Z]("fillRule", X);
        }
        get strokeColor() {
          return this[o]("strokeColor");
        }
        set strokeColor(X) {
          this[Z]("strokeColor", Object(t.parseColor)(X));
        }
        get lineWidth() {
          return this[o]("lineWidth");
        }
        set lineWidth(X) {
          this[Z]("lineWidth", Object(s.toNumber)(X));
        }
        get lineJoin() {
          return this[o]("lineJoin");
        }
        set lineJoin(X) {
          if (X != null && X !== "miter" && X !== "bevel" && X !== "round")
            throw new TypeError("Invalid lineJoin type.");
          this[Z]("lineJoin", X);
        }
        get lineCap() {
          return this[o]("lineCap");
        }
        set lineCap(X) {
          if (X != null && X !== "butt" && X !== "square" && X !== "round")
            throw new TypeError("Invalid lineCap type.");
          this[Z]("lineCap", X);
        }
        get lineDash() {
          return this[o]("lineDash");
        }
        set lineDash(X) {
          X = Object(s.toArray)(X, !0), X != null && !Array.isArray(X) && (X = [X]), this[Z]("lineDash", X ? X.map(s.toNumber) : null);
        }
        get lineDashOffset() {
          return this[o]("lineDashOffset");
        }
        set lineDashOffset(X) {
          this[Z]("lineDashOffset", Object(s.toNumber)(X));
        }
        get miterLimit() {
          return this[o]("miterLimit");
        }
        set miterLimit(X) {
          this[Z]("miterLimit", Object(s.toNumber)(X));
        }
        get roundSegments() {
          return this[o]("roundSegments");
        }
        set roundSegments(X) {
          this[Z]("roundSegments", X);
        }
        get texture() {
          return this[o]("texture");
        }
        set texture(X) {
          this[Z]("texture", X);
        }
        get textureRect() {
          return this[o]("textureRect");
        }
        set textureRect(X) {
          this[Z]("textureRect", X);
        }
        get sourceRect() {
          return this[o]("sourceRect");
        }
        set sourceRect(X) {
          this[Z]("sourceRect", X);
        }
        get textureRepeat() {
          return this[o]("textureRepeat");
        }
        set textureRepeat(X) {
          this[Z]("textureRepeat", !!X);
        }
        get clipPath() {
          return this[o]("clipPath");
        }
        set clipPath(X) {
          this[Z]("clipPath", X);
        }
      }
    },
    /* 229 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(226), t = l(213), s = l(230);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(o, G, y) {
        return G in o ? Object.defineProperty(o, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : o[G] = y, o;
      }
      class Z extends i.default {
        /* override */
        get isVisible() {
          const {
            width: G,
            height: y
          } = this.attributes;
          return G > 0 && y > 0 && super.isVisible;
        }
      }
      b(Z, "Attr", s.default), t.default.registerNode(Z, "rect");
    },
    /* 230 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return y;
      });
      var i = l(228), t = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol.for("spritejs_setAttributeDefault"), b = Symbol.for("spritejs_setAttribute"), Z = Symbol.for("spritejs_getAttribute"), o = Symbol.for("spritejs_declareAlias");
      function G(X) {
        const {
          width: W,
          height: h
        } = X;
        return `M0 0L${W} 0L${W} ${h}L0 ${h}Z`;
      }
      class y extends i.default {
        constructor(W) {
          super(W), this[s]({
            width: 0,
            height: 0
            /* size */
          }), this[o]("size");
        }
        // readonly
        get d() {
          return this[Z]("d");
        }
        set d(W) {
        }
        // eslint-disable-line no-empty-function
        get width() {
          return this[Z]("width");
        }
        set width(W) {
          if (W = Object(t.toNumber)(W), this[b]("width", W)) {
            const h = G(this);
            this[b]("d", h);
          }
        }
        get height() {
          return this[Z]("height");
        }
        set height(W) {
          if (W = Object(t.toNumber)(W), this[b]("height", W)) {
            const h = G(this);
            this[b]("d", h);
          }
        }
        get size() {
          return [this.width, this.height];
        }
        set size(W) {
          W = Object(t.toArray)(W), Array.isArray(W) || (W = [W, W]), this.width = W[0], this.height = W[1];
        }
      }
    },
    /* 231 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(232), t = l(213), s = l(235);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(o, G, y) {
        return G in o ? Object.defineProperty(o, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : o[G] = y, o;
      }
      class Z extends i.default {
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      b(Z, "Attr", s.default), t.default.registerNode(Z, "triangle");
    },
    /* 232 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(226), t = l(213), s = l(233);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(o, G, y) {
        return G in o ? Object.defineProperty(o, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : o[G] = y, o;
      }
      class Z extends i.default {
        /* override */
        get isVisible() {
          const {
            points: G
          } = this.attributes;
          return G.length > 0 && super.isVisible;
        }
      }
      b(Z, "Attr", s.default), t.default.registerNode(Z, "polyline");
    },
    /* 233 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return X;
      });
      var i = l(228), t = l(72), s = l(234);
      l(1).glMatrix.setMatrixArrayType(Array);
      const b = Symbol.for("spritejs_setAttributeDefault"), Z = Symbol.for("spritejs_setAttribute"), o = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(W) {
        const {
          points: h,
          smooth: r,
          smoothRange: L,
          close: u
        } = W, V = [];
        for (let n = 0; n < h.length; n += 2)
          V.push([h[n], h[n + 1]]);
        let c = "";
        return r ? c = Object(s.makeSmoothCurveLine)(V, L) : V.length && (c = `M${V.map((n) => n.join(" ")).join("L")}`), c && u && (c += "Z"), c;
      }
      class X extends i.default {
        constructor(h) {
          super(h), this[b]({
            points: [],
            smooth: !1,
            smoothRange: [0],
            closeType: "none"
            // none | normal
            /* close */
          }), this[G]("close");
        }
        // readonly
        get d() {
          return this[o]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get close() {
          return this.closeType !== "none";
        }
        set close(h) {
          h = h ? "normal" : "none", this.closeType = h;
        }
        get closeType() {
          return this[o]("closeType");
        }
        set closeType(h) {
          if (h != null && h !== "none" && h !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[Z]("closeType", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get smooth() {
          return this[o]("smooth");
        }
        set smooth(h) {
          if (this[Z]("smooth", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get smoothRange() {
          return this[o]("smoothRange");
        }
        set smoothRange(h) {
          if (h && !Array.isArray(h) && (h = [h]), this[Z]("smoothRange", h) && this.smooth) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get points() {
          return this[o]("points");
        }
        set points(h) {
          if (h = Object(t.toArray)(h), Array.isArray(h) && (h = h.reduce((r, L) => Array.isArray(L) ? [...r, ...L.map((u) => Object(t.toNumber)(u))] : [...r, Object(t.toNumber)(L)], [])), this[Z]("points", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
      }
    },
    /* 234 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "makeSmoothCurveLine", function() {
        return i;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function i(t, s = [0]) {
        function b(G, y = 0.168, X = 0.168) {
          let W, h, r, L;
          if ((t[G].x === t[G + 1].x || t[G].y === t[G + 1].y) && (y = 0, X = 0), G < 1 ? (W = t[0].x + (t[1].x - t[0].x) * y, h = t[0].y + (t[1].y - t[0].y) * y) : (W = t[G].x + (t[G + 1].x - t[G - 1].x) * y, h = t[G].y + (t[G + 1].y - t[G - 1].y) * y), G > t.length - 3) {
            const u = t.length - 1;
            r = t[u].x - (t[u].x - t[u - 1].x) * X, L = t[u].y - (t[u].y - t[u - 1].y) * X;
          } else
            r = t[G + 1].x - (t[G + 2].x - t[G].x) * X, L = t[G + 1].y - (t[G + 2].y - t[G].y) * X;
          return [{
            x: W,
            y: h
          }, {
            x: r,
            y: L
          }];
        }
        t = t.map(([G, y]) => ({
          x: G,
          y
        }));
        let Z = "", o = 0;
        return t.forEach((G, y) => {
          if (y === 0)
            Z += `M${G.x} ${G.y}`;
          else {
            for (; y > s[o]; )
              o++;
            if (o % 2) {
              const [X, W] = b(y - 1);
              Z += `C${[X.x, X.y, W.x, W.y, G.x, G.y].join(" ")}`;
            } else
              Z += `L${G.x} ${G.y}`;
          }
        }), Z;
      }
    },
    /* 235 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(233), t = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol.for("spritejs_setAttributeDefault"), b = Symbol.for("spritejs_setAttribute"), Z = Symbol.for("spritejs_getAttribute");
      function o(y) {
        const [X, W] = y.sides;
        let h = y.angle % 360;
        return h < 0 && (h += 360), h = Math.PI * h / 180, [0, 0, X, 0, W * Math.cos(h), W * Math.sin(h)];
      }
      class G extends i.default {
        constructor(X) {
          super(X), this[s]({
            sides: [0, 0],
            angle: 60,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(X) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[Z]("sides");
        }
        set sides(X) {
          if (X = Object(t.toArray)(X, !0), X != null && !Array.isArray(X) && (X = [X, X]), this[b]("sides", X)) {
            const W = o(this);
            super.points = W;
          }
        }
        get angle() {
          return this[Z]("angle");
        }
        set angle(X) {
          if (X = Object(t.toNumber)(X), this[b]("angle", X)) {
            const W = o(this);
            super.points = W;
          }
        }
      }
    },
    /* 236 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(232), t = l(213), s = l(237);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(o, G, y) {
        return G in o ? Object.defineProperty(o, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : o[G] = y, o;
      }
      class Z extends i.default {
        /* override */
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      b(Z, "Attr", s.default), t.default.registerNode(Z, "parallel");
    },
    /* 237 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(233), t = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol.for("spritejs_setAttributeDefault"), b = Symbol.for("spritejs_setAttribute"), Z = Symbol.for("spritejs_getAttribute");
      function o(y) {
        const [X, W] = y.sides;
        let h = y.angle % 360;
        h < 0 && (h += 360), h = Math.PI * h / 180;
        const r = W * Math.cos(h), L = W * Math.sin(h);
        return [0, 0, X, 0, r + X, L, r, L];
      }
      class G extends i.default {
        constructor(X) {
          super(X), this[s]({
            sides: [0, 0],
            angle: 90,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(X) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[Z]("sides");
        }
        set sides(X) {
          if (X = Object(t.toArray)(X, !0), X != null && !Array.isArray(X) && (X = [X, X]), this[b]("sides", X)) {
            const W = o(this);
            super.points = W;
          }
        }
        get angle() {
          return this[Z]("angle");
        }
        set angle(X) {
          if (X = Object(t.toNumber)(X), this[b]("angle", X)) {
            const W = o(this);
            super.points = W;
          }
        }
      }
    },
    /* 238 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(232), t = l(213), s = l(239);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(o, G, y) {
        return G in o ? Object.defineProperty(o, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : o[G] = y, o;
      }
      class Z extends i.default {
      }
      b(Z, "Attr", s.default), t.default.registerNode(Z, "regular");
    },
    /* 239 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(233), t = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol.for("spritejs_setAttributeDefault"), b = Symbol.for("spritejs_setAttribute"), Z = Symbol.for("spritejs_getAttribute");
      function o(y) {
        const {
          edges: X,
          radius: W,
          offsetAngle: h
        } = y, r = Math.PI * h / 180 - 0.5 * Math.PI;
        if (X < 3 || W <= 0)
          return [];
        const L = [];
        for (let u = 0; u < X; u++) {
          const V = u * 2 * Math.PI / X + r, c = W * Math.cos(V), n = W * Math.sin(V);
          L.push(c, n);
        }
        return L;
      }
      class G extends i.default {
        constructor(X) {
          super(X), this[s]({
            edges: 3,
            radius: 0,
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(X) {
        }
        // eslint-disable-line no-empty-function
        get edges() {
          return this[Z]("edges");
        }
        set edges(X) {
          if (X = Object(t.toNumber)(X), this[b]("edges", X)) {
            const W = o(this);
            super.points = W;
          }
        }
        get radius() {
          return this[Z]("radius");
        }
        set radius(X) {
          if (X = Object(t.toNumber)(X), this[b]("radius", X)) {
            const W = o(this);
            super.points = W;
          }
        }
        get offsetAngle() {
          return this[Z]("offsetAngle");
        }
        set offsetAngle(X) {
          if (X = Object(t.toNumber)(X), this[b]("offsetAngle", X)) {
            const W = o(this);
            super.points = W;
          }
        }
      }
    },
    /* 240 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(232), t = l(213), s = l(241);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(o, G, y) {
        return G in o ? Object.defineProperty(o, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : o[G] = y, o;
      }
      class Z extends i.default {
      }
      b(Z, "Attr", s.default), t.default.registerNode(Z, "star");
    },
    /* 241 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var i = l(233), t = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol.for("spritejs_setAttributeDefault"), b = Symbol.for("spritejs_setAttribute"), Z = Symbol.for("spritejs_getAttribute");
      function o(y) {
        const {
          angles: X,
          innerRadius: W,
          outerRadius: h,
          offsetAngle: r
        } = y, L = Math.PI * r / 180 - 0.5 * Math.PI;
        if (X < 3 || W <= 0 || h <= 0)
          return [];
        const u = [];
        for (let V = 0; V < X * 2; V++) {
          const c = V * Math.PI / X + L, n = V % 2 ? W : h, e = n * Math.cos(c), a = n * Math.sin(c);
          u.push(e, a);
        }
        return u;
      }
      class G extends i.default {
        constructor(X) {
          super(X), this[s]({
            angles: 5,
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(X) {
        }
        // eslint-disable-line no-empty-function
        get angles() {
          return this[Z]("angles");
        }
        set angles(X) {
          if (X = Object(t.toNumber)(X), this[b]("angles", X)) {
            const W = o(this);
            super.points = W;
          }
        }
        get innerRadius() {
          return this[Z]("innerRadius");
        }
        set innerRadius(X) {
          if (X = Object(t.toNumber)(X), this[b]("innerRadius", X)) {
            const W = o(this);
            super.points = W;
          }
        }
        get outerRadius() {
          return this[Z]("outerRadius");
        }
        set outerRadius(X) {
          if (X = Object(t.toNumber)(X), this[b]("outerRadius", X)) {
            const W = o(this);
            super.points = W;
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(X) {
          X = Object(t.toArray)(X, !0), Array.isArray(X) || (X = [X, X]), this.innerRadius = X[0], this.outerRadius = X[1];
        }
        get offsetAngle() {
          return this[Z]("offsetAngle");
        }
        set offsetAngle(X) {
          if (X = Object(t.toNumber)(X), this[b]("offsetAngle", X)) {
            const W = o(this);
            super.points = W;
          }
        }
      }
    },
    /* 242 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(226), t = l(213), s = l(243);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(o, G, y) {
        return G in o ? Object.defineProperty(o, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : o[G] = y, o;
      }
      class Z extends i.default {
        /* override */
        get isVisible() {
          const {
            radiusX: G,
            radiusY: y,
            startAngle: X,
            endAngle: W
          } = this.attributes;
          return G > 0 && y > 0 && X !== W && super.isVisible;
        }
      }
      b(Z, "Attr", s.default), t.default.registerNode(Z, "ellipse");
    },
    /* 243 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return X;
      });
      var i = l(12), t = l(228), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const b = Symbol.for("spritejs_setAttributeDefault"), Z = Symbol.for("spritejs_setAttribute"), o = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(W) {
        const {
          radiusX: h,
          radiusY: r,
          startAngle: L,
          endAngle: u,
          direction: V,
          closeType: c
        } = W, n = V === "anitclockwise", e = new i.Figure2D();
        return c === "sector" && e.moveTo(0, 0), e.ellipse(0, 0, h, r, 0, Math.PI * L / 180, Math.PI * u / 180, n), c !== "none" && e.closePath(), e.path.reduce((R, C) => R + C.join(" "), "");
      }
      class X extends t.default {
        constructor(h) {
          super(h), this[b]({
            radiusX: 0,
            radiusY: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360,
            /* angle */
            direction: "clockwise",
            // clockwise | anticlockwise
            closeType: "none"
            // none | sector | normal
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[o]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get radiusX() {
          return this[o]("radiusX");
        }
        set radiusX(h) {
          if (h = Object(s.toNumber)(h), this[Z]("radiusX", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get radiusY() {
          return this[o]("radiusY");
        }
        set radiusY(h) {
          if (h = Object(s.toNumber)(h), this[Z]("radiusY", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get radius() {
          return [this.radiusX, this.radiusY];
        }
        set radius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this.radiusX = h[0], this.radiusY = h[1];
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h, h]), this.startAngle = h[0], this.endAngle = h[1];
        }
        get direction() {
          return this[o]("direction");
        }
        set direction(h) {
          if (h != null && h !== "clockwise" && h !== "anticlockwise")
            throw new TypeError("Invalid direction type.");
          this[Z]("direction", h);
        }
        get startAngle() {
          return this[o]("startAngle");
        }
        set startAngle(h) {
          if (h = Object(s.toNumber)(h), this[Z]("startAngle", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get endAngle() {
          return this[o]("endAngle");
        }
        set endAngle(h) {
          if (h = Object(s.toNumber)(h), this[Z]("endAngle", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get closeType() {
          return this[o]("closeType");
        }
        set closeType(h) {
          if (h != null && h !== "none" && h !== "sector" && h !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[Z]("closeType", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
      }
    },
    /* 244 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(242), t = l(213), s = l(245);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(o, G, y) {
        return G in o ? Object.defineProperty(o, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : o[G] = y, o;
      }
      class Z extends i.default {
      }
      b(Z, "Attr", s.default), t.default.registerNode(Z, "arc");
    },
    /* 245 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return s;
      });
      var i = l(243), t = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      class s extends i.default {
        get radius() {
          return super.radiusX;
        }
        set radius(Z) {
          Z = Object(t.toNumber)(Z), super.radiusX = Z, super.radiusY = Z;
        }
      }
    },
    /* 246 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(226), t = l(213), s = l(247);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(o, G, y) {
        return G in o ? Object.defineProperty(o, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : o[G] = y, o;
      }
      class Z extends i.default {
        /* override */
        get isVisible() {
          const {
            innerRadius: G,
            outerRadius: y,
            startAngle: X,
            endAngle: W
          } = this.attributes;
          return (G > 0 || y > 0) && X !== W && super.isVisible;
        }
      }
      b(Z, "Attr", s.default), t.default.registerNode(Z, "ring");
    },
    /* 247 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return X;
      });
      var i = l(12), t = l(228), s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const b = Symbol.for("spritejs_setAttributeDefault"), Z = Symbol.for("spritejs_setAttribute"), o = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(W) {
        let {
          innerRadius: h,
          outerRadius: r,
          startAngle: L,
          endAngle: u
        } = W;
        const V = new i.Figure2D();
        if (L = Math.PI * L / 180, u = Math.PI * u / 180, h > r && ([h, r] = [r, h]), h <= 0 && V.moveTo(0, 0), V.arc(0, 0, r, L, u, !1), h > 0) {
          const e = Math.PI * 2;
          u < L && (u = L + e + (u - L) % e), u - L >= e && (u = L + e - 1e-6), V.arc(0, 0, h, u, L, !0);
        }
        return V.closePath(), V.path.reduce((e, a) => e + a.join(" "), "");
      }
      class X extends t.default {
        constructor(h) {
          super(h), this[b]({
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360
            /* angle */
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[o]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get innerRadius() {
          return this[o]("innerRadius");
        }
        set innerRadius(h) {
          if (h = Object(s.toNumber)(h), this[Z]("innerRadius", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get outerRadius() {
          return this[o]("outerRadius");
        }
        set outerRadius(h) {
          if (h = Object(s.toNumber)(h), this[Z]("outerRadius", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(h) {
          h = Object(s.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this.innerRadius = h[0], this.outerRadius = h[1];
        }
        get startAngle() {
          return this[o]("startAngle");
        }
        set startAngle(h) {
          if (h = Object(s.toNumber)(h), this[Z]("startAngle", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get endAngle() {
          return this[o]("endAngle");
        }
        set endAngle(h) {
          if (h = Object(s.toNumber)(h), this[Z]("endAngle", h)) {
            const r = y(this);
            this[Z]("d", r);
          }
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(h) {
          h = Object(s.toArray)(h), Array.isArray(h) || (h = [h, h]), this.startAngle = h[0], this.endAngle = h[1];
        }
      }
    },
    /* 248 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return r;
      });
      var i = l(12), t = l(218), s = l(219), b = l(249), Z = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      function o(L, u, V) {
        return u in L ? Object.defineProperty(L, u, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : L[u] = V, L;
      }
      const G = Symbol("textImage"), y = Symbol("textImageTask"), X = Symbol("textureContext"), W = Symbol("updateTextureRect"), h = Symbol("textCanvas");
      class r extends s.default {
        constructor(u = {}) {
          typeof u == "string" && (u = {
            text: u
          }), super(u);
        }
        /* override */
        get contentSize() {
          let [u, V] = super.contentSize;
          const {
            width: c,
            height: n
          } = this.attributes;
          if (c == null || n == null) {
            const e = this[G];
            e && (c == null && (u = e.rect[2]), n == null && (V = e.rect[3]));
          }
          return [u, V];
        }
        get text() {
          return this.attributes.text;
        }
        set text(u) {
          this.attributes.text = u;
        }
        get textContent() {
          return this.attributes.text;
        }
        set textContent(u) {
          this.attributes.text = u;
        }
        get textImage() {
          return this[G] || {};
        }
        get textImageReady() {
          return this[y] || Promise.resolve();
        }
        /* override */
        draw(u) {
          super.draw(u);
          const V = this.mesh;
          if (V) {
            const c = this[G];
            if (c) {
              let n = V.texture;
              if (!n || this[X] && this[X] !== this.renderer || c.needsUpdate ? (c.needsUpdate = !1, Object(t.deleteTexture)(c.image, this.renderer), n = Object(t.createTexture)(c.image, this.renderer), this[W] = !0) : n = V.uniforms.u_texSampler, this[W]) {
                const [e, a] = c.rect.slice(2), [Y, R] = this.contentSize, C = this.attributes.textAlign, N = this.attributes.verticalAlign;
                let I = 0;
                C === "center" ? I = (Y - e) / 2 : (C === "right" || C === "end") && (I = Y - e);
                const J = this.attributes.fontSize, T = this.attributes.lineHeight;
                let K = 0;
                N === "top" ? K = (J - T) / 2 : N === "bottom" && (K = (T - J) / 2);
                const {
                  paddingLeft: S,
                  paddingTop: H
                } = this.attributes, {
                  borderWidth: w
                } = this.attributes;
                I += S + w, K += H + w;
                const {
                  anchorX: P,
                  anchorY: B
                } = this.attributes;
                I -= this.offsetSize[0] * P, K -= this.offsetSize[1] * B, V.setTexture(n, {
                  rect: [I, K, e, a]
                }), this[W] = !1, this[X] = this.renderer;
              }
            }
          }
          return u;
        }
        /* override */
        onPropertyChange(u, V, c) {
          u === "text" || u === "fontSize" || u === "fontFamily" || u === "fontStyle" || u === "fontVariant" || u === "fontWeight" || u === "fontStretch" || u === "lineHeight" || u === "strokeColor" || u === "fillColor" || u === "strokeWidth" ? this.updateText() : ((u === "textAlign" || u === "verticalAlign") && (this[W] = !0), super.onPropertyChange(u, V, c));
        }
        /* override */
        updateContours() {
          super.updateContours(), this[W] = !0;
        }
        updateText() {
          this[y] || (this[y] = Promise.resolve().then(() => {
            this[y] = null;
            const {
              text: u,
              font: V,
              fillColor: c,
              strokeColor: n,
              strokeWidth: e
            } = this.attributes, a = this.layer ? this.layer.displayRatio : 1;
            return this[h] = this[h] || i.ENV.createCanvas(1, 1), this[G] = i.ENV.createText(u, {
              font: V,
              fillColor: c,
              strokeColor: n,
              strokeWidth: e,
              parseFont: i.parseFont,
              ratio: a,
              textCanvas: this[h]
            }), this[G].needsUpdate = !0, this.updateContours(), this.forceUpdate(), this[G];
          }));
        }
      }
      o(r, "Attr", b.default), Z.default.registerNode(r, "label");
    },
    /* 249 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return X;
      });
      var i = l(12), t = l(72), s = l(221), b = l(220);
      l(1).glMatrix.setMatrixArrayType(Array);
      const Z = Symbol.for("spritejs_setAttributeDefault"), o = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), y = Symbol.for("spritejs_declareAlias");
      class X extends b.default {
        constructor(h) {
          super(h), this[Z]({
            text: "",
            fontSize: 16,
            fontFamily: "Helvetica,Arial,sans-serif",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            fontStretch: "normal",
            lineHeight: "",
            /* font */
            textAlign: "left",
            strokeColor: void 0,
            strokeWidth: 1,
            fillColor: void 0,
            verticalAlign: "middle"
          }), this[y]("font");
        }
        get text() {
          return this[G]("text") || " ";
        }
        set text(h) {
          this[o]("text", h);
        }
        get fontSize() {
          return this[G]("fontSize");
        }
        set fontSize(h) {
          this[o]("fontSize", Object(t.toNumber)(h));
        }
        get fontFamily() {
          return this[G]("fontFamily");
        }
        set fontFamily(h) {
          this[o]("fontFamily", h);
        }
        get fontStyle() {
          return this[G]("fontStyle");
        }
        set fontStyle(h) {
          this[o]("fontStyle", h);
        }
        get fontVariant() {
          return this[G]("fontVariant");
        }
        set fontVariant(h) {
          this[o]("fontVariant", h);
        }
        get fontWeight() {
          return this[G]("fontWeight");
        }
        set fontWeight(h) {
          this[o]("fontWeight", h);
        }
        get fontStretch() {
          return this[G]("fontStretch");
        }
        set fontStretch(h) {
          this[o]("fontStretch", h);
        }
        get lineHeight() {
          return this[G]("lineHeight") || this.fontSize;
        }
        set lineHeight(h) {
          this[o]("lineHeight", Object(t.toNumber)(h));
        }
        get textAlign() {
          return this[G]("textAlign");
        }
        set textAlign(h) {
          this[o]("textAlign", h);
        }
        get strokeColor() {
          return this[G]("strokeColor");
        }
        set strokeColor(h) {
          this[o]("strokeColor", Object(s.parseColor)(h));
        }
        get strokeWidth() {
          return this[G]("strokeWidth");
        }
        set strokeWidth(h) {
          this[o]("strokeWidth", Object(t.toNumber)(h));
        }
        get verticalAlign() {
          return this[G]("verticalAlign");
        }
        set verticalAlign(h) {
          this[o]("verticalAlign", h);
        }
        get fillColor() {
          return this[G]("fillColor");
        }
        set fillColor(h) {
          this[o]("fillColor", Object(s.parseColor)(h));
        }
        get font() {
          const {
            fontStyle: h,
            fontVariant: r,
            fontWeight: L,
            fontStretch: u,
            fontSize: V,
            lineHeight: c,
            fontFamily: n
          } = this;
          return `${h} ${r} ${L} ${u} ${V}px/${c}px ${n}`;
        }
        set font(h) {
          if (h == null)
            this.fontStyle = null, this.fontVariant = null, this.fontWeight = null, this.fontStretch = null, this.fontSize = null, this.lineHeight = null, this.fontFamily = null;
          else {
            const r = Object(i.parseFont)(h);
            this.fontStyle = r.style, this.fontVariant = r.variant, this.fontWeight = r.weight, this.fontStretch = r.stretch, this.fontSize = Object(t.toNumber)(`${r.size}${r.unit}`), r.lineHeight && (this.lineHeight = r.pxLineHeight), this.fontFamily = r.family;
          }
        }
      }
    },
    /* 250 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return h;
      });
      var i = l(12), t = l(219), s = l(251), b = l(213), Z = l(252);
      l(1).glMatrix.setMatrixArrayType(Array);
      function o(r, L, u) {
        return L in r ? Object.defineProperty(r, L, { value: u, enumerable: !0, configurable: !0, writable: !0 }) : r[L] = u, r;
      }
      const G = Symbol("zOrder"), y = Symbol("ordered"), X = Symbol("children"), W = Symbol("sealed");
      class h extends t.default {
        constructor(L = {}) {
          super(L), this[X] = [], this[y] = null, this[G] = 0;
        }
        get childNodes() {
          return this[X];
        }
        get children() {
          return this[X];
        }
        get orderedChildren() {
          return this[y] || (this[y] = [...this[X]], this[y].sort((L, u) => L.zIndex - u.zIndex || L.zOrder - u.zOrder)), this[y];
        }
        append(...L) {
          return L.map((u) => this.appendChild(u));
        }
        appendChild(L) {
          return L.remove(), this[X].push(L), L.connect(this, this[G]++), this[y] && (this[y].length && L.zIndex < this[y][this[y].length - 1].zIndex ? this.reorder() : this[y].push(L)), L;
        }
        /* override */
        // get isVisible() {
        //   return this.attributes.opacity > 0 && this[_children].length > 0;
        // }
        /* override */
        cloneNode(L = !1) {
          const u = super.cloneNode();
          return L && this[X].forEach((V) => {
            const c = V.cloneNode(L);
            u.appendChild(c);
          }), u;
        }
        /* override */
        dispatchPointerEvent(L) {
          const u = this.orderedChildren;
          for (let V = u.length - 1; V >= 0; V--)
            if (u[V].dispatchPointerEvent(L))
              return !0;
          return super.dispatchPointerEvent(L);
        }
        /* override */
        draw(L = []) {
          if (this.__cacheRenderMatrix = this.renderMatrix, super.draw(L), !this[W] && this.attributes.display !== "none") {
            const u = this.orderedChildren;
            for (let V = 0; V < u.length; V++)
              u[V].draw(L);
          }
          return this.__cacheRenderMatrix = null, L;
        }
        getElementById(L) {
          return Object(Z.querySelector)(`#${L}`, this);
        }
        getElementsByClassName(L) {
          return Object(Z.querySelectorAll)(`.${L}`, this);
        }
        getElementsByName(L) {
          return Object(Z.querySelectorAll)(`[name="${L}"]`, this);
        }
        getElementsByTagName(L) {
          return Object(Z.querySelectorAll)(L, this);
        }
        insertBefore(L, u) {
          if (u == null)
            return this.appendChild(L);
          L.remove();
          const V = this[X].indexOf(u);
          if (V < 0)
            throw new Error("Invalid reference node.");
          const c = u.zOrder;
          for (let n = V; n < this[X].length; n++) {
            const e = this[X][n].zOrder, a = this[X][n];
            delete a.zOrder, Object.defineProperty(a, "zOrder", {
              value: e + 1,
              writable: !1,
              configurable: !0
            });
          }
          if (this[X].splice(V, 0, L), L.connect(this, c), this[y])
            if (L.zIndex !== u.zIndex)
              this.reorder();
            else {
              const n = this[y].indexOf(u);
              this[y].splice(n, 0, L);
            }
          return L;
        }
        querySelector(L) {
          return Object(Z.querySelector)(L, this);
        }
        querySelectorAll(L) {
          return Object(Z.querySelectorAll)(L, this);
        }
        replaceChild(L, u) {
          L.remove();
          const V = this[X].indexOf(u);
          if (V < 0)
            throw new Error("Invalid reference node.");
          if (this[X][V] = L, L.connect(this, u.zOrder), this[y])
            if (L.zIndex !== u.zIndex)
              this.reorder();
            else {
              const c = this[y].indexOf(u);
              this[y][c] = L;
            }
          return u.disconnect(this), L;
        }
        removeAllChildren() {
          const L = this[X];
          for (let u = L.length - 1; u >= 0; u--)
            L[u].remove();
        }
        removeChild(L) {
          const u = this[X].indexOf(L);
          if (u >= 0) {
            if (this[X].splice(u, 1), this[y]) {
              const V = this[y].indexOf(L);
              this[y].splice(V, 1);
            }
            return L.disconnect(this), L;
          }
          return null;
        }
        reorder() {
          this[y] = null;
        }
        seal() {
          function L(n, e) {
            const a = [];
            for (let Y = 0; Y < n.length; Y++) {
              const R = [...n[Y]];
              for (let C = 1; C < R.length; C += 2) {
                const N = R[C], I = R[C + 1];
                R[C] = N * e[0] + I * e[2] + e[4], R[C + 1] = N * e[1] + I * e[3] + e[5];
              }
              a.push(R);
            }
            return a;
          }
          const u = this.orderedChildren, V = new i.Figure2D(), c = this.localMatrix;
          for (let n = 0; n < u.length; n++) {
            let e = u[n];
            if (e instanceof h && (e = e.seal()), e.clientBox) {
              let a = e.clientBox.contours.path;
              a = L(a, e.localMatrix), V.addPath(a);
            }
            if (e.path) {
              let a = e.path.contours.path;
              a = L(a, e.localMatrix), V.addPath(a);
            }
          }
          return this[W] = !0, this.clientBox = V, {
            clientBox: V,
            localMatrix: c
          };
        }
        /* override */
        setResolution({
          width: L,
          height: u
        }) {
          super.setResolution({
            width: L,
            height: u
          }), this[X].forEach((V) => {
            V.setResolution({
              width: L,
              height: u
            });
          });
        }
        /* override */
        updateContours() {
          this[W] || super.updateContours();
        }
      }
      o(h, "Attr", s.default), b.default.registerNode(h, "group");
    },
    /* 251 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return t;
      });
      var i = l(220);
      l(1).glMatrix.setMatrixArrayType(Array);
      class t extends i.default {
        // constructor(subject) {
        //   super(subject);
        //   this[setDefault]({
        //     pointerEvents: 'all',
        //   });
        // }
      }
    },
    /* 252 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "querySelectorAll", function() {
        return W;
      }), l.d(d, "querySelector", function() {
        return h;
      }), l.d(d, "isMatched", function() {
        return r;
      }), l.d(d, "compile", function() {
        return L;
      });
      var i = l(221), t = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      const s = l(253);
      function b(u) {
        return u.nodeType === 1 || t.default.isSpriteNode(u.nodeName);
      }
      function Z(u) {
        return Array.from(u.childNodes || []);
      }
      function o(u) {
        return t.default.isSpriteNode(u.nodeName) ? u.parent || u.canvas || u.container : u.parentElement;
      }
      function G(u) {
        let V = u.length, c, n, e;
        for (; --V > -1; ) {
          for (c = n = u[V], u[V] = null, e = !0; n; ) {
            if (u.indexOf(n) > -1) {
              e = !1, u.splice(V, 1);
              break;
            }
            n = o(n);
          }
          e && (u[V] = c);
        }
        return u;
      }
      const y = {
        isTag: b,
        existsOne(u, V) {
          return V.some((c) => b(c) ? u(c) || y.existsOne(u, Z(c)) : !1);
        },
        getSiblings(u) {
          const V = o(u);
          return V && Z(V);
        },
        getChildren: Z,
        getParent: o,
        getAttributeValue(u, V) {
          if (u.nodeType === 1 && V === "class" || V === "id")
            return u[V];
          if (this.hasAttrib(u, V)) {
            let c = u.attributes[V];
            return Array.isArray(c) && (c = `[${c.join()}]`), String(c);
          }
        },
        hasAttrib(u, V) {
          return u.attributes[V] != null;
        },
        removeSubsets: G,
        getName(u) {
          return u.tagName ? u.tagName.toLowerCase() : null;
        },
        findOne: function u(V, c) {
          let n = null;
          for (let e = 0, a = c.length; e < a && !n; e++)
            if (V(c[e]))
              n = c[e];
            else {
              const Y = Z(c[e]);
              Y && Y.length > 0 && (n = u(V, Y));
            }
          return n;
        },
        findAll: function u(V, c) {
          let n = [];
          for (let e = 0, a = c.length; e < a; e++) {
            if (!b(c[e]))
              continue;
            V(c[e]) && n.push(c[e]);
            const Y = Z(c[e]);
            Y && (n = n.concat(u(V, Y)));
          }
          return n;
        },
        getText: function u(V) {
          return Array.isArray(V) ? V.map(u).join("") : b(V) ? u(Z(V)) : V.nodeType === 3 ? V.nodeValue : t.default.isSpriteNode(V.nodeName) ? V.text : "";
        }
      };
      function X(u) {
        if (typeof u != "string")
          return u;
        let V = u.match(/\[(bgcolor|fillColor|strokeColor|color)\s*=\s*['"]?\w+['"]?\]/g);
        return V && (V = V.map((c) => {
          const n = c.slice(1, -1).split("="), e = Object(i.parseColor)(n[1].replace(/['"]/g, ""));
          return [c, `[${n[0]}="${e}"]`];
        }), V.forEach(([c, n]) => {
          u = u.replace(c, n);
        })), V = u.match(/\[\w+\s*=\s*['"]\[.+?\]['"]\]/g), V && (V = V.map((c) => {
          const n = c.slice(1, -1).split("="), e = n[1].slice(2, -2).split(/,/g).map((a) => a.trim());
          return [c, `[${n[0]}="[${e}]"]`];
        }), V.forEach(([c, n]) => {
          u = u.replace(c, n);
        })), u;
      }
      function W(u, V) {
        return s.selectAll(X(u), V, {
          adapter: y
        });
      }
      function h(u, V) {
        return s.selectOne(X(u), V, {
          adapter: y
        });
      }
      function r(u, V) {
        return s.is(u, X(V), {
          adapter: y
        });
      }
      function L(u) {
        return s.compile(X(u), {
          adapter: y
        });
      }
    },
    /* 253 */
    /***/
    function(m, d, l) {
      m.exports = L;
      var i = l(254), t = l(273).falseFunc, s = l(274);
      function b(u) {
        return function(c, n, e) {
          return n = n || {}, n.adapter = n.adapter || i, u(c, n, e);
        };
      }
      var Z = b(s), o = b(s.compileUnsafe);
      function G(u) {
        return function(c, n, e) {
          return e = e || {}, e.adapter = e.adapter || i, typeof c != "function" && (c = o(c, e, n)), c.shouldTestNextSiblings && (n = X(e && e.context || n, e.adapter)), Array.isArray(n) ? n = e.adapter.removeSubsets(n) : n = e.adapter.getChildren(n), u(c, n, e);
        };
      }
      function y(u, V) {
        var c = V.getSiblings(u);
        if (!Array.isArray(c))
          return [];
        for (c = c.slice(0); c.shift() !== u; )
          ;
        return c;
      }
      function X(u, V) {
        Array.isArray(u) || (u = [u]);
        for (var c = u.slice(0), n = 0, e = u.length; n < e; n++) {
          var a = y(c[n], V);
          c.push.apply(c, a);
        }
        return c;
      }
      var W = G(function(V, c, n) {
        return V === t || !c || c.length === 0 ? [] : n.adapter.findAll(V, c);
      }), h = G(function(V, c, n) {
        return V === t || !c || c.length === 0 ? null : n.adapter.findOne(V, c);
      });
      function r(u, V, c) {
        return c = c || {}, c.adapter = c.adapter || i, (typeof V == "function" ? V : Z(V, c))(u);
      }
      function L(u, V, c) {
        return W(u, V, c);
      }
      L.compile = Z, L.filters = s.Pseudos.filters, L.pseudos = s.Pseudos.pseudos, L.selectAll = W, L.selectOne = h, L.is = r, L.parse = Z, L.iterate = W, L._compileUnsafe = o, L._compileToken = s.compileToken;
    },
    /* 254 */
    /***/
    function(m, d, l) {
      var i = m.exports;
      [
        l(255),
        l(268),
        l(269),
        l(270),
        l(271),
        l(272)
      ].forEach(function(t) {
        Object.keys(t).forEach(function(s) {
          i[s] = t[s].bind(i);
        });
      });
    },
    /* 255 */
    /***/
    function(m, d, l) {
      var i = l(256), t = l(257), s = i.isTag;
      m.exports = {
        getInnerHTML: b,
        getOuterHTML: t,
        getText: Z
      };
      function b(o, G) {
        return o.children ? o.children.map(function(y) {
          return t(y, G);
        }).join("") : "";
      }
      function Z(o) {
        return Array.isArray(o) ? o.map(Z).join("") : s(o) ? o.name === "br" ? `
` : Z(o.children) : o.type === i.CDATA ? Z(o.children) : o.type === i.Text ? o.data : "";
      }
    },
    /* 256 */
    /***/
    function(m, d) {
      m.exports = {
        Text: "text",
        //Text
        Directive: "directive",
        //<? ... ?>
        Comment: "comment",
        //<!-- ... -->
        Script: "script",
        //<script> tags
        Style: "style",
        //<style> tags
        Tag: "tag",
        //Any tag
        CDATA: "cdata",
        //<![CDATA[ ... ]]>
        Doctype: "doctype",
        isTag: function(l) {
          return l.type === "tag" || l.type === "script" || l.type === "style";
        }
      };
    },
    /* 257 */
    /***/
    function(m, d, l) {
      var i = l(258), t = l(259), s = l(267);
      s.elementNames.__proto__ = null, s.attributeNames.__proto__ = null;
      var b = {
        __proto__: null,
        style: !0,
        script: !0,
        xmp: !0,
        iframe: !0,
        noembed: !0,
        noframes: !0,
        plaintext: !0,
        noscript: !0
      };
      function Z(u, V) {
        if (u) {
          var c = "", n;
          for (var e in u)
            n = u[e], c && (c += " "), V.xmlMode === "foreign" && (e = s.attributeNames[e] || e), c += e, (n !== null && n !== "" || V.xmlMode) && (c += '="' + (V.decodeEntities ? t.encodeXML(n) : n.replace(/\"/g, "&quot;")) + '"');
          return c;
        }
      }
      var o = {
        __proto__: null,
        area: !0,
        base: !0,
        basefont: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        isindex: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, G = m.exports = function(u, V) {
        !Array.isArray(u) && !u.cheerio && (u = [u]), V = V || {};
        for (var c = "", n = 0; n < u.length; n++) {
          var e = u[n];
          e.type === "root" ? c += G(e.children, V) : i.isTag(e) ? c += X(e, V) : e.type === i.Directive ? c += W(e) : e.type === i.Comment ? c += L(e) : e.type === i.CDATA ? c += r(e) : c += h(e, V);
        }
        return c;
      }, y = [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ];
      function X(u, V) {
        V.xmlMode === "foreign" && (u.name = s.elementNames[u.name] || u.name, u.parent && y.indexOf(u.parent.name) >= 0 && (V = Object.assign({}, V, { xmlMode: !1 }))), !V.xmlMode && ["svg", "math"].indexOf(u.name) >= 0 && (V = Object.assign({}, V, { xmlMode: "foreign" }));
        var c = "<" + u.name, n = Z(u.attribs, V);
        return n && (c += " " + n), V.xmlMode && (!u.children || u.children.length === 0) ? c += "/>" : (c += ">", u.children && (c += G(u.children, V)), (!o[u.name] || V.xmlMode) && (c += "</" + u.name + ">")), c;
      }
      function W(u) {
        return "<" + u.data + ">";
      }
      function h(u, V) {
        var c = u.data || "";
        return V.decodeEntities && !(u.parent && u.parent.name in b) && (c = t.encodeXML(c)), c;
      }
      function r(u) {
        return "<![CDATA[" + u.children[0].data + "]]>";
      }
      function L(u) {
        return "<!--" + u.data + "-->";
      }
    },
    /* 258 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 });
      function i(t) {
        return t.type === "tag" || t.type === "script" || t.type === "style";
      }
      d.isTag = i, d.Text = "text", d.Directive = "directive", d.Comment = "comment", d.Script = "script", d.Style = "style", d.Tag = "tag", d.CDATA = "cdata", d.Doctype = "doctype";
    },
    /* 259 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 }), d.encode = d.decodeStrict = d.decode = void 0;
      var i = l(260), t = l(266);
      function s(y, X) {
        return (!X || X <= 0 ? i.decodeXML : i.decodeHTML)(y);
      }
      d.decode = s;
      function b(y, X) {
        return (!X || X <= 0 ? i.decodeXML : i.decodeHTMLStrict)(y);
      }
      d.decodeStrict = b;
      function Z(y, X) {
        return (!X || X <= 0 ? t.encodeXML : t.encodeHTML)(y);
      }
      d.encode = Z;
      var o = l(266);
      Object.defineProperty(d, "encodeXML", { enumerable: !0, get: function() {
        return o.encodeXML;
      } }), Object.defineProperty(d, "encodeHTML", { enumerable: !0, get: function() {
        return o.encodeHTML;
      } }), Object.defineProperty(d, "escape", { enumerable: !0, get: function() {
        return o.escape;
      } }), Object.defineProperty(d, "encodeHTML4", { enumerable: !0, get: function() {
        return o.encodeHTML;
      } }), Object.defineProperty(d, "encodeHTML5", { enumerable: !0, get: function() {
        return o.encodeHTML;
      } });
      var G = l(260);
      Object.defineProperty(d, "decodeXML", { enumerable: !0, get: function() {
        return G.decodeXML;
      } }), Object.defineProperty(d, "decodeHTML", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(d, "decodeHTMLStrict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(d, "decodeHTML4", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(d, "decodeHTML5", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(d, "decodeHTML4Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(d, "decodeHTML5Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(d, "decodeXMLStrict", { enumerable: !0, get: function() {
        return G.decodeXML;
      } });
    },
    /* 260 */
    /***/
    function(m, d, l) {
      var i = this && this.__importDefault || function(X) {
        return X && X.__esModule ? X : { default: X };
      };
      Object.defineProperty(d, "__esModule", { value: !0 }), d.decodeHTML = d.decodeHTMLStrict = d.decodeXML = void 0;
      var t = i(l(261)), s = i(l(262)), b = i(l(263)), Z = i(l(264));
      d.decodeXML = o(b.default), d.decodeHTMLStrict = o(t.default);
      function o(X) {
        var W = Object.keys(X).join("|"), h = y(X);
        W += "|#[xX][\\da-fA-F]+|#\\d+";
        var r = new RegExp("&(?:" + W + ");", "g");
        return function(L) {
          return String(L).replace(r, h);
        };
      }
      var G = function(X, W) {
        return X < W ? 1 : -1;
      };
      d.decodeHTML = function() {
        for (var X = Object.keys(s.default).sort(G), W = Object.keys(t.default).sort(G), h = 0, r = 0; h < W.length; h++)
          X[r] === W[h] ? (W[h] += ";?", r++) : W[h] += ";";
        var L = new RegExp("&(?:" + W.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), u = y(t.default);
        function V(c) {
          return c.substr(-1) !== ";" && (c += ";"), u(c);
        }
        return function(c) {
          return String(c).replace(L, V);
        };
      }();
      function y(X) {
        return function(h) {
          if (h.charAt(1) === "#") {
            var r = h.charAt(2);
            return r === "X" || r === "x" ? Z.default(parseInt(h.substr(3), 16)) : Z.default(parseInt(h.substr(2), 10));
          }
          return X[h.slice(1, -1)];
        };
      }
    },
    /* 261 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');
    },
    /* 262 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');
    },
    /* 263 */
    /***/
    function(m) {
      m.exports = JSON.parse(`{"amp":"&","apos":"'","gt":">","lt":"<","quot":"\\""}`);
    },
    /* 264 */
    /***/
    function(m, d, l) {
      var i = this && this.__importDefault || function(b) {
        return b && b.__esModule ? b : { default: b };
      };
      Object.defineProperty(d, "__esModule", { value: !0 });
      var t = i(l(265));
      function s(b) {
        if (b >= 55296 && b <= 57343 || b > 1114111)
          return "�";
        b in t.default && (b = t.default[b]);
        var Z = "";
        return b > 65535 && (b -= 65536, Z += String.fromCharCode(b >>> 10 & 1023 | 55296), b = 56320 | b & 1023), Z += String.fromCharCode(b), Z;
      }
      d.default = s;
    },
    /* 265 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');
    },
    /* 266 */
    /***/
    function(m, d, l) {
      var i = this && this.__importDefault || function(V) {
        return V && V.__esModule ? V : { default: V };
      };
      Object.defineProperty(d, "__esModule", { value: !0 }), d.escape = d.encodeHTML = d.encodeXML = void 0;
      var t = i(l(263)), s = y(t.default), b = X(s);
      d.encodeXML = r(s, b);
      var Z = i(l(261)), o = y(Z.default), G = X(o);
      d.encodeHTML = r(o, G);
      function y(V) {
        return Object.keys(V).sort().reduce(function(c, n) {
          return c[V[n]] = "&" + n + ";", c;
        }, {});
      }
      function X(V) {
        for (var c = [], n = [], e = 0, a = Object.keys(V); e < a.length; e++) {
          var Y = a[e];
          Y.length === 1 ? c.push("\\" + Y) : n.push(Y);
        }
        c.sort();
        for (var R = 0; R < c.length - 1; R++) {
          for (var C = R; C < c.length - 1 && c[C].charCodeAt(1) + 1 === c[C + 1].charCodeAt(1); )
            C += 1;
          var N = 1 + C - R;
          N < 3 || c.splice(R, N, c[R] + "-" + c[C]);
        }
        return n.unshift("[" + c.join("") + "]"), new RegExp(n.join("|"), "g");
      }
      var W = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
      function h(V) {
        return "&#x" + V.codePointAt(0).toString(16).toUpperCase() + ";";
      }
      function r(V, c) {
        return function(n) {
          return n.replace(c, function(e) {
            return V[e];
          }).replace(W, h);
        };
      }
      var L = X(s);
      function u(V) {
        return V.replace(L, h).replace(W, h);
      }
      d.escape = u;
    },
    /* 267 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}}');
    },
    /* 268 */
    /***/
    function(m, d) {
      var l = d.getChildren = function(t) {
        return t.children;
      }, i = d.getParent = function(t) {
        return t.parent;
      };
      d.getSiblings = function(t) {
        var s = i(t);
        return s ? l(s) : [t];
      }, d.getAttributeValue = function(t, s) {
        return t.attribs && t.attribs[s];
      }, d.hasAttrib = function(t, s) {
        return !!t.attribs && hasOwnProperty.call(t.attribs, s);
      }, d.getName = function(t) {
        return t.name;
      };
    },
    /* 269 */
    /***/
    function(m, d) {
      d.removeElement = function(l) {
        if (l.prev && (l.prev.next = l.next), l.next && (l.next.prev = l.prev), l.parent) {
          var i = l.parent.children;
          i.splice(i.lastIndexOf(l), 1);
        }
      }, d.replaceElement = function(l, i) {
        var t = i.prev = l.prev;
        t && (t.next = i);
        var s = i.next = l.next;
        s && (s.prev = i);
        var b = i.parent = l.parent;
        if (b) {
          var Z = b.children;
          Z[Z.lastIndexOf(l)] = i;
        }
      }, d.appendChild = function(l, i) {
        if (i.parent = l, l.children.push(i) !== 1) {
          var t = l.children[l.children.length - 2];
          t.next = i, i.prev = t, i.next = null;
        }
      }, d.append = function(l, i) {
        var t = l.parent, s = l.next;
        if (i.next = s, i.prev = l, l.next = i, i.parent = t, s) {
          if (s.prev = i, t) {
            var b = t.children;
            b.splice(b.lastIndexOf(s), 0, i);
          }
        } else
          t && t.children.push(i);
      }, d.prepend = function(l, i) {
        var t = l.parent;
        if (t) {
          var s = t.children;
          s.splice(s.lastIndexOf(l), 0, i);
        }
        l.prev && (l.prev.next = i), i.parent = t, i.prev = l.prev, i.next = l, l.prev = i;
      };
    },
    /* 270 */
    /***/
    function(m, d, l) {
      var i = l(256).isTag;
      m.exports = {
        filter: t,
        find: s,
        findOneChild: b,
        findOne: Z,
        existsOne: o,
        findAll: G
      };
      function t(y, X, W, h) {
        return Array.isArray(X) || (X = [X]), (typeof h != "number" || !isFinite(h)) && (h = 1 / 0), s(y, X, W !== !1, h);
      }
      function s(y, X, W, h) {
        for (var r = [], L, u = 0, V = X.length; u < V && !(y(X[u]) && (r.push(X[u]), --h <= 0) || (L = X[u].children, W && L && L.length > 0 && (L = s(y, L, W, h), r = r.concat(L), h -= L.length, h <= 0))); u++)
          ;
        return r;
      }
      function b(y, X) {
        for (var W = 0, h = X.length; W < h; W++)
          if (y(X[W]))
            return X[W];
        return null;
      }
      function Z(y, X) {
        for (var W = null, h = 0, r = X.length; h < r && !W; h++)
          if (i(X[h]))
            y(X[h]) ? W = X[h] : X[h].children.length > 0 && (W = Z(y, X[h].children));
          else
            continue;
        return W;
      }
      function o(y, X) {
        for (var W = 0, h = X.length; W < h; W++)
          if (i(X[W]) && (y(X[W]) || X[W].children.length > 0 && o(y, X[W].children)))
            return !0;
        return !1;
      }
      function G(y, X) {
        for (var W = [], h = X.slice(); h.length; ) {
          var r = h.shift();
          i(r) && (r.children && r.children.length > 0 && h.unshift.apply(h, r.children), y(r) && W.push(r));
        }
        return W;
      }
    },
    /* 271 */
    /***/
    function(m, d, l) {
      var i = l(256), t = d.isTag = i.isTag;
      d.testElement = function(o, G) {
        for (var y in o)
          if (o.hasOwnProperty(y)) {
            if (y === "tag_name") {
              if (!t(G) || !o.tag_name(G.name))
                return !1;
            } else if (y === "tag_type") {
              if (!o.tag_type(G.type))
                return !1;
            } else if (y === "tag_contains") {
              if (t(G) || !o.tag_contains(G.data))
                return !1;
            } else if (!G.attribs || !o[y](G.attribs[y]))
              return !1;
          }
        return !0;
      };
      var s = {
        tag_name: function(o) {
          return typeof o == "function" ? function(G) {
            return t(G) && o(G.name);
          } : o === "*" ? t : function(G) {
            return t(G) && G.name === o;
          };
        },
        tag_type: function(o) {
          return typeof o == "function" ? function(G) {
            return o(G.type);
          } : function(G) {
            return G.type === o;
          };
        },
        tag_contains: function(o) {
          return typeof o == "function" ? function(G) {
            return !t(G) && o(G.data);
          } : function(G) {
            return !t(G) && G.data === o;
          };
        }
      };
      function b(o, G) {
        return typeof G == "function" ? function(y) {
          return y.attribs && G(y.attribs[o]);
        } : function(y) {
          return y.attribs && y.attribs[o] === G;
        };
      }
      function Z(o, G) {
        return function(y) {
          return o(y) || G(y);
        };
      }
      d.getElements = function(o, G, y, X) {
        var W = Object.keys(o).map(function(h) {
          var r = o[h];
          return h in s ? s[h](r) : b(h, r);
        });
        return W.length === 0 ? [] : this.filter(
          W.reduce(Z),
          G,
          y,
          X
        );
      }, d.getElementById = function(o, G, y) {
        return Array.isArray(G) || (G = [G]), this.findOne(b("id", o), G, y !== !1);
      }, d.getElementsByTagName = function(o, G, y, X) {
        return this.filter(s.tag_name(o), G, y, X);
      }, d.getElementsByTagType = function(o, G, y, X) {
        return this.filter(s.tag_type(o), G, y, X);
      };
    },
    /* 272 */
    /***/
    function(m, d) {
      d.removeSubsets = function(t) {
        for (var s = t.length, b, Z, o; --s > -1; ) {
          for (b = Z = t[s], t[s] = null, o = !0; Z; ) {
            if (t.indexOf(Z) > -1) {
              o = !1, t.splice(s, 1);
              break;
            }
            Z = Z.parent;
          }
          o && (t[s] = b);
        }
        return t;
      };
      var l = {
        DISCONNECTED: 1,
        PRECEDING: 2,
        FOLLOWING: 4,
        CONTAINS: 8,
        CONTAINED_BY: 16
      }, i = d.compareDocumentPosition = function(t, s) {
        var b = [], Z = [], o, G, y, X, W, h;
        if (t === s)
          return 0;
        for (o = t; o; )
          b.unshift(o), o = o.parent;
        for (o = s; o; )
          Z.unshift(o), o = o.parent;
        for (h = 0; b[h] === Z[h]; )
          h++;
        return h === 0 ? l.DISCONNECTED : (G = b[h - 1], y = G.children, X = b[h], W = Z[h], y.indexOf(X) > y.indexOf(W) ? G === s ? l.FOLLOWING | l.CONTAINED_BY : l.FOLLOWING : G === t ? l.PRECEDING | l.CONTAINS : l.PRECEDING);
      };
      d.uniqueSort = function(t) {
        var s = t.length, b, Z;
        for (t = t.slice(); --s > -1; )
          b = t[s], Z = t.indexOf(b), Z > -1 && Z < s && t.splice(s, 1);
        return t.sort(function(o, G) {
          var y = i(o, G);
          return y & l.PRECEDING ? -1 : y & l.FOLLOWING ? 1 : 0;
        }), t;
      };
    },
    /* 273 */
    /***/
    function(m, d) {
      m.exports = {
        trueFunc: function() {
          return !0;
        },
        falseFunc: function() {
          return !1;
        }
      };
    },
    /* 274 */
    /***/
    function(m, d, l) {
      m.exports = W;
      var i = l(275).parse, t = l(273), s = l(278), b = l(279), Z = l(280), o = l(282), G = t.trueFunc, y = t.falseFunc, X = o.filters;
      function W(I, J, T) {
        var K = r(I, J, T);
        return h(K, J);
      }
      function h(I, J) {
        var T = J.adapter;
        return function(S) {
          return T.isTag(S) && I(S);
        };
      }
      function r(I, J, T) {
        var K = i(I, J);
        return a(K, J, T);
      }
      function L(I) {
        return I.type === "pseudo" && (I.name === "scope" || Array.isArray(I.data) && I.data.some(function(J) {
          return J.some(L);
        }));
      }
      var u = { type: "descendant" }, V = { type: "_flexibleDescendant" }, c = { type: "pseudo", name: "scope" }, n = {};
      function e(I, J, T) {
        var K = J.adapter, S = !!T && !!T.length && T.every(function(H) {
          return H === n || !!K.getParent(H);
        });
        I.forEach(function(H) {
          if (!(H.length > 0 && Y(H[0]) && H[0].type !== "descendant"))
            if (S && !(Array.isArray(H) ? H.some(L) : L(H)))
              H.unshift(u);
            else
              return;
          H.unshift(c);
        });
      }
      function a(I, J, T) {
        I = I.filter(function(w) {
          return w.length > 0;
        }), I.forEach(s);
        var K = Array.isArray(T);
        T = J && J.context || T, T && !K && (T = [T]), e(I, J, T);
        var S = !1, H = I.map(function(w) {
          if (w[0] && w[1] && w[0].name === "scope") {
            var P = w[1].type;
            K && P === "descendant" ? w[1] = V : (P === "adjacent" || P === "sibling") && (S = !0);
          }
          return R(w, J, T);
        }).reduce(C, y);
        return H.shouldTestNextSiblings = S, H;
      }
      function Y(I) {
        return b[I.type] < 0;
      }
      function R(I, J, T) {
        return I.reduce(function(K, S) {
          if (K === y)
            return K;
          if (!(S.type in Z))
            throw new Error("Rule type " + S.type + " is not supported by css-select");
          return Z[S.type](K, S, J, T);
        }, J && J.rootFunc || G);
      }
      function C(I, J) {
        return J === y || I === G ? I : I === y || J === G ? J : function(K) {
          return I(K) || J(K);
        };
      }
      function N(I) {
        return I.some(Y);
      }
      X.not = function(I, J, T, K) {
        var S = {
          xmlMode: !!(T && T.xmlMode),
          strict: !!(T && T.strict),
          adapter: T.adapter
        };
        if (S.strict && (J.length > 1 || J.some(N)))
          throw new Error("complex selectors in :not aren't allowed in strict mode");
        var H = a(J, S, K);
        return H === y ? I : H === G ? y : function(P) {
          return !H(P) && I(P);
        };
      }, X.has = function(I, J, T) {
        var K = T.adapter, S = {
          xmlMode: !!(T && T.xmlMode),
          strict: !!(T && T.strict),
          adapter: K
        }, H = J.some(N) ? [n] : null, w = a(J, S, H);
        return w === y ? y : w === G ? function(B) {
          return K.getChildren(B).some(K.isTag) && I(B);
        } : (w = h(w, T), H ? function(B) {
          return I(B) && (H[0] = B, K.existsOne(w, K.getChildren(B)));
        } : function(B) {
          return I(B) && K.existsOne(w, K.getChildren(B));
        });
      }, X.matches = function(I, J, T, K) {
        var S = {
          xmlMode: !!(T && T.xmlMode),
          strict: !!(T && T.strict),
          rootFunc: I,
          adapter: T.adapter
        };
        return a(J, S, K);
      }, W.compileToken = a, W.compileUnsafe = r, W.Pseudos = o;
    },
    /* 275 */
    /***/
    function(m, d, l) {
      var i = this && this.__createBinding || (Object.create ? function(Z, o, G, y) {
        y === void 0 && (y = G), Object.defineProperty(Z, y, { enumerable: !0, get: function() {
          return o[G];
        } });
      } : function(Z, o, G, y) {
        y === void 0 && (y = G), Z[y] = o[G];
      }), t = this && this.__exportStar || function(Z, o) {
        for (var G in Z)
          G !== "default" && !o.hasOwnProperty(G) && i(o, Z, G);
      };
      Object.defineProperty(d, "__esModule", { value: !0 }), t(l(276), d);
      var s = l(276);
      Object.defineProperty(d, "parse", { enumerable: !0, get: function() {
        return s.default;
      } });
      var b = l(277);
      Object.defineProperty(d, "stringify", { enumerable: !0, get: function() {
        return b.default;
      } });
    },
    /* 276 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 }), d.default = L;
      var i = /^[^\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, t = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, s = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/, b = {
        undefined: "exists",
        "": "equals",
        "~": "element",
        "^": "start",
        $: "end",
        "*": "any",
        "!": "not",
        "|": "hyphen"
      }, Z = {
        ">": "child",
        "<": "parent",
        "~": "sibling",
        "+": "adjacent"
      }, o = {
        "#": ["id", "equals"],
        ".": ["class", "element"]
      }, G = /* @__PURE__ */ new Set(["has", "not", "matches"]), y = /* @__PURE__ */ new Set(["contains", "icontains"]), X = /* @__PURE__ */ new Set(['"', "'"]);
      function W(c, n, e) {
        var a = parseInt(n, 16) - 65536;
        return a !== a || e ? n : a < 0 ? (
          // BMP codepoint
          String.fromCharCode(a + 65536)
        ) : (
          // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(a >> 10 | 55296, a & 1023 | 56320)
        );
      }
      function h(c) {
        return c.replace(t, W);
      }
      function r(c) {
        return c === " " || c === `
` || c === "	" || c === "\f" || c === "\r";
      }
      function L(c, n) {
        var e = [];
        if (c = u(e, "" + c, n), c !== "")
          throw new Error("Unmatched selector: " + c);
        return e;
      }
      function u(c, n, e) {
        var a = [], Y = !1;
        function R() {
          var O = n.match(i);
          if (!O)
            throw new Error("Expected name, found " + n);
          var ll = O[0];
          return n = n.substr(ll.length), h(ll);
        }
        function C(O) {
          for (; r(n.charAt(O)); )
            O++;
          n = n.substr(O);
        }
        function N(O) {
          for (var ll = 0; n.charAt(--O) === "\\"; )
            ll++;
          return (ll & 1) === 1;
        }
        for (C(0); n !== ""; ) {
          var I = n.charAt(0);
          if (r(I))
            Y = !0, C(1);
          else if (I in Z)
            a.push({ type: Z[I] }), Y = !1, C(1);
          else if (I === ",") {
            if (a.length === 0)
              throw new Error("Empty sub-selector");
            c.push(a), a = [], Y = !1, C(1);
          } else if (Y && (a.length > 0 && a.push({ type: "descendant" }), Y = !1), I === "*")
            n = n.substr(1), a.push({ type: "universal" });
          else if (I in o) {
            var J = o[I], T = J[0], K = J[1];
            n = n.substr(1), a.push({
              type: "attribute",
              name: T,
              action: K,
              value: R(),
              ignoreCase: !1
            });
          } else if (I === "[") {
            n = n.substr(1);
            var S = n.match(s);
            if (!S)
              throw new Error("Malformed attribute selector: " + n);
            n = n.substr(S[0].length);
            var H = h(S[1]);
            (!e || ("lowerCaseAttributeNames" in e ? e.lowerCaseAttributeNames : !e.xmlMode)) && (H = H.toLowerCase()), a.push({
              type: "attribute",
              name: H,
              action: b[S[2]],
              value: h(S[4] || S[5] || ""),
              ignoreCase: !!S[6]
            });
          } else if (I === ":") {
            if (n.charAt(1) === ":") {
              n = n.substr(2), a.push({
                type: "pseudo-element",
                name: R().toLowerCase()
              });
              continue;
            }
            n = n.substr(1);
            var w = R().toLowerCase(), S = null;
            if (n.charAt(0) === "(")
              if (G.has(w)) {
                var P = n.charAt(1), B = X.has(P);
                if (n = n.substr(B ? 2 : 1), S = [], n = u(S, n, e), B) {
                  if (n.charAt(0) !== P)
                    throw new Error("Unmatched quotes in :" + w);
                  n = n.substr(1);
                }
                if (n.charAt(0) !== ")")
                  throw new Error("Missing closing parenthesis in :" + w + " (" + n + ")");
                n = n.substr(1);
              } else {
                for (var D = 1, z = 1; z > 0 && D < n.length; D++)
                  n.charAt(D) === "(" && !N(D) ? z++ : n.charAt(D) === ")" && !N(D) && z--;
                if (z)
                  throw new Error("Parenthesis not matched");
                if (S = n.substr(1, D - 2), n = n.substr(D), y.has(w)) {
                  var P = S.charAt(0);
                  P === S.slice(-1) && X.has(P) && (S = S.slice(1, -1)), S = h(S);
                }
              }
            a.push({ type: "pseudo", name: w, data: S });
          } else if (i.test(n)) {
            var U = R();
            (!e || ("lowerCaseTags" in e ? e.lowerCaseTags : !e.xmlMode)) && (U = U.toLowerCase()), a.push({ type: "tag", name: U });
          } else
            return a.length && a[a.length - 1].type === "descendant" && a.pop(), V(c, a), n;
        }
        return V(c, a), n;
      }
      function V(c, n) {
        if (c.length > 0 && n.length === 0)
          throw new Error("Empty sub-selector");
        c.push(n);
      }
    },
    /* 277 */
    /***/
    function(m, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 });
      var i = {
        equals: "",
        element: "~",
        start: "^",
        end: "$",
        any: "*",
        not: "!",
        hyphen: "|"
      };
      function t(o) {
        return o.map(s).join(", ");
      }
      d.default = t;
      function s(o) {
        return o.map(b).join("");
      }
      function b(o) {
        switch (o.type) {
          case "child":
            return " > ";
          case "parent":
            return " < ";
          case "sibling":
            return " ~ ";
          case "adjacent":
            return " + ";
          case "descendant":
            return " ";
          case "universal":
            return "*";
          case "tag":
            return o.name;
          case "pseudo-element":
            return "::" + o.name;
          case "pseudo":
            return o.data === null ? ":" + o.name : typeof o.data == "string" ? ":" + o.name + "(" + o.data + ")" : ":" + o.name + "(" + t(o.data) + ")";
          case "attribute":
            return o.action === "exists" ? "[" + o.name + "]" : o.name === "id" && o.action === "equals" && !o.ignoreCase ? "#" + o.value : o.name === "class" && o.action === "element" && !o.ignoreCase ? "." + o.value : "[" + o.name + i[o.action] + "='" + o.value + "'" + (o.ignoreCase ? "i" : "") + "]";
          default:
            throw new Error("Unknown type");
        }
      }
      function Z(o) {
        return o;
      }
    },
    /* 278 */
    /***/
    function(m, d, l) {
      m.exports = s;
      var i = l(279), t = {
        __proto__: null,
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4
      };
      function s(Z) {
        for (var o = Z.map(b), G = 1; G < Z.length; G++) {
          var y = o[G];
          if (!(y < 0))
            for (var X = G - 1; X >= 0 && y < o[X]; X--) {
              var W = Z[X + 1];
              Z[X + 1] = Z[X], Z[X] = W, o[X + 1] = o[X], o[X] = y;
            }
        }
      }
      function b(Z) {
        var o = i[Z.type];
        if (o === i.attribute)
          o = t[Z.action], o === t.equals && Z.name === "id" && (o = 9), Z.ignoreCase && (o >>= 1);
        else if (o === i.pseudo)
          if (!Z.data)
            o = 3;
          else if (Z.name === "has" || Z.name === "contains")
            o = 0;
          else if (Z.name === "matches" || Z.name === "not") {
            o = 0;
            for (var G = 0; G < Z.data.length; G++)
              if (Z.data[G].length === 1) {
                var y = b(Z.data[G][0]);
                if (y === 0) {
                  o = 0;
                  break;
                }
                y > o && (o = y);
              }
            Z.data.length > 1 && o > 0 && (o -= 1);
          } else
            o = 1;
        return o;
      }
    },
    /* 279 */
    /***/
    function(m) {
      m.exports = JSON.parse('{"universal":50,"tag":30,"attribute":1,"pseudo":0,"descendant":-1,"child":-1,"parent":-1,"sibling":-1,"adjacent":-1}');
    },
    /* 280 */
    /***/
    function(m, d, l) {
      var i = l(281), t = l(282);
      m.exports = {
        __proto__: null,
        attribute: i.compile,
        pseudo: t.compile,
        //tags
        tag: function(s, b, Z) {
          var o = b.name, G = Z.adapter;
          return function(X) {
            return G.getName(X) === o && s(X);
          };
        },
        //traversal
        descendant: function(s, b, Z) {
          var o = typeof WeakSet < "u" ? /* @__PURE__ */ new WeakSet() : null, G = Z.adapter;
          return function(X) {
            for (var W = !1; !W && (X = G.getParent(X)); )
              (!o || !o.has(X)) && (W = s(X), !W && o && o.add(X));
            return W;
          };
        },
        _flexibleDescendant: function(s, b, Z) {
          var o = Z.adapter;
          return function(y) {
            for (var X = s(y); !X && (y = o.getParent(y)); )
              X = s(y);
            return X;
          };
        },
        parent: function(s, b, Z) {
          if (Z && Z.strict)
            throw new Error("Parent selector isn't part of CSS3");
          var o = Z.adapter;
          return function(X) {
            return o.getChildren(X).some(G);
          };
          function G(y) {
            return o.isTag(y) && s(y);
          }
        },
        child: function(s, b, Z) {
          var o = Z.adapter;
          return function(y) {
            var X = o.getParent(y);
            return !!X && s(X);
          };
        },
        sibling: function(s, b, Z) {
          var o = Z.adapter;
          return function(y) {
            for (var X = o.getSiblings(y), W = 0; W < X.length; W++)
              if (o.isTag(X[W])) {
                if (X[W] === y)
                  break;
                if (s(X[W]))
                  return !0;
              }
            return !1;
          };
        },
        adjacent: function(s, b, Z) {
          var o = Z.adapter;
          return function(y) {
            for (var X = o.getSiblings(y), W, h = 0; h < X.length; h++)
              if (o.isTag(X[h])) {
                if (X[h] === y)
                  break;
                W = X[h];
              }
            return !!W && s(W);
          };
        },
        universal: function(s) {
          return s;
        }
      };
    },
    /* 281 */
    /***/
    function(m, d, l) {
      var i = l(273).falseFunc, t = /[-[\]{}()*+?.,\\^$|#\s]/g, s = {
        __proto__: null,
        equals: function(b, Z, o) {
          var G = Z.name, y = Z.value, X = o.adapter;
          return Z.ignoreCase ? (y = y.toLowerCase(), function(h) {
            var r = X.getAttributeValue(h, G);
            return r != null && r.toLowerCase() === y && b(h);
          }) : function(h) {
            return X.getAttributeValue(h, G) === y && b(h);
          };
        },
        hyphen: function(b, Z, o) {
          var G = Z.name, y = Z.value, X = y.length, W = o.adapter;
          return Z.ignoreCase ? (y = y.toLowerCase(), function(r) {
            var L = W.getAttributeValue(r, G);
            return L != null && (L.length === X || L.charAt(X) === "-") && L.substr(0, X).toLowerCase() === y && b(r);
          }) : function(r) {
            var L = W.getAttributeValue(r, G);
            return L != null && L.substr(0, X) === y && (L.length === X || L.charAt(X) === "-") && b(r);
          };
        },
        element: function(b, Z, o) {
          var G = Z.name, y = Z.value, X = o.adapter;
          if (/\s/.test(y))
            return i;
          y = y.replace(t, "\\$&");
          var W = "(?:^|\\s)" + y + "(?:$|\\s)", h = Z.ignoreCase ? "i" : "", r = new RegExp(W, h);
          return function(u) {
            var V = X.getAttributeValue(u, G);
            return V != null && r.test(V) && b(u);
          };
        },
        exists: function(b, Z, o) {
          var G = Z.name, y = o.adapter;
          return function(W) {
            return y.hasAttrib(W, G) && b(W);
          };
        },
        start: function(b, Z, o) {
          var G = Z.name, y = Z.value, X = y.length, W = o.adapter;
          return X === 0 ? i : Z.ignoreCase ? (y = y.toLowerCase(), function(r) {
            var L = W.getAttributeValue(r, G);
            return L != null && L.substr(0, X).toLowerCase() === y && b(r);
          }) : function(r) {
            var L = W.getAttributeValue(r, G);
            return L != null && L.substr(0, X) === y && b(r);
          };
        },
        end: function(b, Z, o) {
          var G = Z.name, y = Z.value, X = -y.length, W = o.adapter;
          return X === 0 ? i : Z.ignoreCase ? (y = y.toLowerCase(), function(r) {
            var L = W.getAttributeValue(r, G);
            return L != null && L.substr(X).toLowerCase() === y && b(r);
          }) : function(r) {
            var L = W.getAttributeValue(r, G);
            return L != null && L.substr(X) === y && b(r);
          };
        },
        any: function(b, Z, o) {
          var G = Z.name, y = Z.value, X = o.adapter;
          if (y === "")
            return i;
          if (Z.ignoreCase) {
            var W = new RegExp(y.replace(t, "\\$&"), "i");
            return function(r) {
              var L = X.getAttributeValue(r, G);
              return L != null && W.test(L) && b(r);
            };
          }
          return function(r) {
            var L = X.getAttributeValue(r, G);
            return L != null && L.indexOf(y) >= 0 && b(r);
          };
        },
        not: function(b, Z, o) {
          var G = Z.name, y = Z.value, X = o.adapter;
          return y === "" ? function(h) {
            return !!X.getAttributeValue(h, G) && b(h);
          } : Z.ignoreCase ? (y = y.toLowerCase(), function(h) {
            var r = X.getAttributeValue(h, G);
            return r != null && r.toLowerCase() !== y && b(h);
          }) : function(h) {
            return X.getAttributeValue(h, G) !== y && b(h);
          };
        }
      };
      m.exports = {
        compile: function(b, Z, o) {
          if (o && o.strict && (Z.ignoreCase || Z.action === "not"))
            throw new Error("Unsupported attribute selector");
          return s[Z.action](b, Z, o);
        },
        rules: s
      };
    },
    /* 282 */
    /***/
    function(m, d, l) {
      var i = l(283), t = l(273), s = l(281), b = t.trueFunc, Z = t.falseFunc, o = s.rules.equals;
      function G(V, c) {
        var n = { name: V, value: c };
        return function(a, Y, R) {
          return o(a, n, R);
        };
      }
      function y(V, c) {
        return function(n) {
          return !!c.getParent(n) && V(n);
        };
      }
      var X = {
        contains: function(V, c, n) {
          var e = n.adapter;
          return function(Y) {
            return V(Y) && e.getText(Y).indexOf(c) >= 0;
          };
        },
        icontains: function(V, c, n) {
          var e = c.toLowerCase(), a = n.adapter;
          return function(R) {
            return V(R) && a.getText(R).toLowerCase().indexOf(e) >= 0;
          };
        },
        //location specific methods
        "nth-child": function(V, c, n) {
          var e = i(c), a = n.adapter;
          return e === Z ? e : e === b ? y(V, a) : function(R) {
            for (var C = a.getSiblings(R), N = 0, I = 0; N < C.length; N++)
              if (a.isTag(C[N])) {
                if (C[N] === R)
                  break;
                I++;
              }
            return e(I) && V(R);
          };
        },
        "nth-last-child": function(V, c, n) {
          var e = i(c), a = n.adapter;
          return e === Z ? e : e === b ? y(V, a) : function(R) {
            for (var C = a.getSiblings(R), N = 0, I = C.length - 1; I >= 0; I--)
              if (a.isTag(C[I])) {
                if (C[I] === R)
                  break;
                N++;
              }
            return e(N) && V(R);
          };
        },
        "nth-of-type": function(V, c, n) {
          var e = i(c), a = n.adapter;
          return e === Z ? e : e === b ? y(V, a) : function(R) {
            for (var C = a.getSiblings(R), N = 0, I = 0; I < C.length; I++)
              if (a.isTag(C[I])) {
                if (C[I] === R)
                  break;
                a.getName(C[I]) === a.getName(R) && N++;
              }
            return e(N) && V(R);
          };
        },
        "nth-last-of-type": function(V, c, n) {
          var e = i(c), a = n.adapter;
          return e === Z ? e : e === b ? y(V, a) : function(R) {
            for (var C = a.getSiblings(R), N = 0, I = C.length - 1; I >= 0; I--)
              if (a.isTag(C[I])) {
                if (C[I] === R)
                  break;
                a.getName(C[I]) === a.getName(R) && N++;
              }
            return e(N) && V(R);
          };
        },
        //TODO determine the actual root element
        root: function(V, c, n) {
          var e = n.adapter;
          return function(a) {
            return !e.getParent(a) && V(a);
          };
        },
        scope: function(V, c, n, e) {
          var a = n.adapter;
          if (!e || e.length === 0)
            return X.root(V, c, n);
          function Y(R, C) {
            return typeof a.equals == "function" ? a.equals(R, C) : R === C;
          }
          return e.length === 1 ? function(R) {
            return Y(e[0], R) && V(R);
          } : function(R) {
            return e.indexOf(R) >= 0 && V(R);
          };
        },
        //jQuery extensions (others follow as pseudos)
        checkbox: G("type", "checkbox"),
        file: G("type", "file"),
        password: G("type", "password"),
        radio: G("type", "radio"),
        reset: G("type", "reset"),
        image: G("type", "image"),
        submit: G("type", "submit"),
        //dynamic state pseudos. These depend on optional Adapter methods.
        hover: function(V, c, n) {
          var e = n.adapter;
          return typeof e.isHovered == "function" ? function(Y) {
            return V(Y) && e.isHovered(Y);
          } : Z;
        },
        visited: function(V, c, n) {
          var e = n.adapter;
          return typeof e.isVisited == "function" ? function(Y) {
            return V(Y) && e.isVisited(Y);
          } : Z;
        },
        active: function(V, c, n) {
          var e = n.adapter;
          return typeof e.isActive == "function" ? function(Y) {
            return V(Y) && e.isActive(Y);
          } : Z;
        }
      };
      function W(V, c) {
        for (var n = 0; V && n < V.length; n++)
          if (c.isTag(V[n]))
            return V[n];
      }
      var h = {
        empty: function(V, c) {
          return !c.getChildren(V).some(function(n) {
            return c.isTag(n) || n.type === "text";
          });
        },
        "first-child": function(V, c) {
          return W(c.getSiblings(V), c) === V;
        },
        "last-child": function(V, c) {
          for (var n = c.getSiblings(V), e = n.length - 1; e >= 0; e--) {
            if (n[e] === V)
              return !0;
            if (c.isTag(n[e]))
              break;
          }
          return !1;
        },
        "first-of-type": function(V, c) {
          for (var n = c.getSiblings(V), e = 0; e < n.length; e++)
            if (c.isTag(n[e])) {
              if (n[e] === V)
                return !0;
              if (c.getName(n[e]) === c.getName(V))
                break;
            }
          return !1;
        },
        "last-of-type": function(V, c) {
          for (var n = c.getSiblings(V), e = n.length - 1; e >= 0; e--)
            if (c.isTag(n[e])) {
              if (n[e] === V)
                return !0;
              if (c.getName(n[e]) === c.getName(V))
                break;
            }
          return !1;
        },
        "only-of-type": function(V, c) {
          for (var n = c.getSiblings(V), e = 0, a = n.length; e < a; e++)
            if (c.isTag(n[e])) {
              if (n[e] === V)
                continue;
              if (c.getName(n[e]) === c.getName(V))
                return !1;
            }
          return !0;
        },
        "only-child": function(V, c) {
          for (var n = c.getSiblings(V), e = 0; e < n.length; e++)
            if (c.isTag(n[e]) && n[e] !== V)
              return !1;
          return !0;
        },
        //:matches(a, area, link)[href]
        link: function(V, c) {
          return c.hasAttrib(V, "href");
        },
        //TODO: :any-link once the name is finalized (as an alias of :link)
        //forms
        //to consider: :target
        //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
        selected: function(V, c) {
          if (c.hasAttrib(V, "selected"))
            return !0;
          if (c.getName(V) !== "option")
            return !1;
          var n = c.getParent(V);
          if (!n || c.getName(n) !== "select" || c.hasAttrib(n, "multiple"))
            return !1;
          for (var e = c.getChildren(n), a = !1, Y = 0; Y < e.length; Y++)
            if (c.isTag(e[Y]))
              if (e[Y] === V)
                a = !0;
              else if (a) {
                if (c.hasAttrib(e[Y], "selected"))
                  return !1;
              } else
                return !1;
          return a;
        },
        //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        //:matches(
        //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
        //  optgroup[disabled] > option),
        // fieldset[disabled] * //TODO not child of first <legend>
        //)
        disabled: function(V, c) {
          return c.hasAttrib(V, "disabled");
        },
        enabled: function(V, c) {
          return !c.hasAttrib(V, "disabled");
        },
        //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
        checked: function(V, c) {
          return c.hasAttrib(V, "checked") || h.selected(V, c);
        },
        //:matches(input, select, textarea)[required]
        required: function(V, c) {
          return c.hasAttrib(V, "required");
        },
        //:matches(input, select, textarea):not([required])
        optional: function(V, c) {
          return !c.hasAttrib(V, "required");
        },
        //jQuery extensions
        //:not(:empty)
        parent: function(V, c) {
          return !h.empty(V, c);
        },
        //:matches(h1, h2, h3, h4, h5, h6)
        header: r(["h1", "h2", "h3", "h4", "h5", "h6"]),
        //:matches(button, input[type=button])
        button: function(V, c) {
          var n = c.getName(V);
          return n === "button" || n === "input" && c.getAttributeValue(V, "type") === "button";
        },
        //:matches(input, textarea, select, button)
        input: r(["input", "textarea", "select", "button"]),
        //input:matches(:not([type!='']), [type='text' i])
        text: function(V, c) {
          var n;
          return c.getName(V) === "input" && (!(n = c.getAttributeValue(V, "type")) || n.toLowerCase() === "text");
        }
      };
      function r(V) {
        if (typeof Set < "u") {
          var c = new Set(V);
          return function(n, e) {
            return c.has(e.getName(n));
          };
        }
        return function(n, e) {
          return V.indexOf(e.getName(n)) >= 0;
        };
      }
      function L(V, c, n) {
        if (n === null) {
          if (V.length > 2 && c !== "scope")
            throw new Error("pseudo-selector :" + c + " requires an argument");
        } else if (V.length === 2)
          throw new Error("pseudo-selector :" + c + " doesn't have any arguments");
      }
      var u = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
      m.exports = {
        compile: function(V, c, n, e) {
          var a = c.name, Y = c.data, R = n.adapter;
          if (n && n.strict && !u.test(a))
            throw new Error(":" + a + " isn't part of CSS3");
          if (typeof X[a] == "function")
            return X[a](V, Y, n, e);
          if (typeof h[a] == "function") {
            var C = h[a];
            return L(C, a, Y), C === Z ? C : V === b ? function(I) {
              return C(I, R, Y);
            } : function(I) {
              return C(I, R, Y) && V(I);
            };
          } else
            throw new Error("unmatched pseudo-class :" + a);
        },
        filters: X,
        pseudos: h
      };
    },
    /* 283 */
    /***/
    function(m, d, l) {
      var i = l(284), t = l(285);
      m.exports = function(b) {
        return t(i(b));
      }, m.exports.parse = i, m.exports.compile = t;
    },
    /* 284 */
    /***/
    function(m, d) {
      m.exports = i;
      var l = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
      function i(t) {
        if (t = t.trim().toLowerCase(), t === "even")
          return [2, 0];
        if (t === "odd")
          return [2, 1];
        var s = t.match(l);
        if (!s)
          throw new SyntaxError("n-th rule couldn't be parsed ('" + t + "')");
        var b;
        return s[1] ? (b = parseInt(s[1], 10), isNaN(b) && (s[1].charAt(0) === "-" ? b = -1 : b = 1)) : b = 0, [
          b,
          s[3] ? parseInt((s[2] || "") + s[3], 10) : 0
        ];
      }
    },
    /* 285 */
    /***/
    function(m, d, l) {
      m.exports = b;
      var i = l(273), t = i.trueFunc, s = i.falseFunc;
      function b(Z) {
        var o = Z[0], G = Z[1] - 1;
        if (G < 0 && o <= 0)
          return s;
        if (o === -1)
          return function(X) {
            return X <= G;
          };
        if (o === 0)
          return function(X) {
            return X === G;
          };
        if (o === 1)
          return G < 0 ? t : function(X) {
            return X >= G;
          };
        var y = G % o;
        return y < 0 && (y += o), o > 1 ? function(X) {
          return X >= G && X % o === y;
        } : (o *= -1, function(X) {
          return X <= G && X % o === y;
        });
      }
    },
    /* 286 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Y;
      });
      var i = l(12), t = l(74), s = l(1), b = l(68), Z = l(250), o = l(213), G = l(218);
      l(1).glMatrix.setMatrixArrayType(Array);
      function y(R, C) {
        if (R == null)
          return {};
        var N = X(R, C), I, J;
        if (Object.getOwnPropertySymbols) {
          var T = Object.getOwnPropertySymbols(R);
          for (J = 0; J < T.length; J++)
            I = T[J], !(C.indexOf(I) >= 0) && Object.prototype.propertyIsEnumerable.call(R, I) && (N[I] = R[I]);
        }
        return N;
      }
      function X(R, C) {
        if (R == null)
          return {};
        var N = {}, I = Object.keys(R), J, T;
        for (T = 0; T < I.length; T++)
          J = I[T], !(C.indexOf(J) >= 0) && (N[J] = R[J]);
        return N;
      }
      const W = {
        antialias: !0,
        autoRender: !0,
        alpha: !0
        // for wx-miniprogram
      }, h = Symbol("autoRender"), r = Symbol("renderer"), L = Symbol("timeline"), u = Symbol("prepareRender"), V = Symbol("tickRender"), c = Symbol("pass"), n = Symbol("fbo"), e = Symbol("tickers"), a = Symbol("layerTransformInvert");
      class Y extends Z.default {
        constructor(C = {}) {
          if (super(), !C.canvas) {
            const {
              width: T,
              height: K
            } = this.getResolution(), S = i.ENV.createCanvas(T, K, {
              offscreen: !!C.offscreen,
              id: C.id,
              extra: C.extra
            });
            S.style && (S.style.position = "absolute"), S.dataset && (S.dataset.layerId = C.id), S.contextType && (C.contextType = S.contextType), C.canvas = S;
          }
          const N = C.canvas, I = Object.assign({}, W, C);
          this[h] = I.autoRender, delete C.autoRender;
          const J = I.Renderer || i.Renderer;
          this[r] = new J(N, I), this.options = C, this.id = C.id, this[c] = [], this.setResolution(N), this.canvas = N, this[L] = new t.Timeline(), this.__mouseCapturedTarget = null, this[a] = null;
        }
        get autoRender() {
          return this[h];
        }
        get displayRatio() {
          return this.parent && this.parent.options ? this.parent.options.displayRatio : 1;
        }
        get height() {
          const {
            height: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get gl() {
          return this.renderer.glRenderer ? this.renderer.glRenderer.gl : null;
        }
        /* override */
        get layer() {
          return this;
        }
        get offscreen() {
          return !!this.options.offscreen || this.canvas._offscreen;
        }
        get pass() {
          return this[c];
        }
        get prepareRender() {
          return this[u] ? this[u] : Promise.resolve();
        }
        /* override */
        get renderer() {
          return this[r];
        }
        get renderOffset() {
          if (this.parent && this.parent.options) {
            const {
              left: C,
              top: N
            } = this.parent.options;
            return [C, N];
          }
          return [this.options.left | 0, this.options.top | 0];
        }
        get timeline() {
          return this[L];
        }
        get width() {
          const {
            width: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get localMatrix() {
          const {
            x: C,
            y: N
          } = this.attributes;
          return [1, 0, 0, 1, C, N];
        }
        get layerTransformInvert() {
          if (this[a])
            return this[a];
          const C = this.transformMatrix;
          return C[0] === 1 && C[1] === 0 && C[2] === 0 && C[3] === 1 && C[4] === 0 && C[5] === 0 ? null : (this[a] = s.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C), this[a]);
        }
        forceContextLoss() {
          const C = this.renderer.glRenderer;
          if (C) {
            const N = C.getExtension("WEBGL_lose_context");
            if (N)
              return N.loseContext(), !0;
          }
          return !1;
        }
        // isPointCollision(x, y) {
        //   return true;
        // }
        addPass({
          vertex: C,
          fragment: N,
          options: I,
          uniforms: J
        } = {}) {
          if (this.renderer.glRenderer) {
            const {
              width: T,
              height: K
            } = this.getResolution(), S = this.renderer.createPassProgram({
              vertex: C,
              fragment: N,
              options: I
            }), H = new i.Figure2D();
            H.rect(0, 0, T / this.displayRatio, K / this.displayRatio);
            const w = new i.Mesh2D(H);
            return w.setUniforms(J), w.setProgram(S), this[c].push(w), this.forceUpdate(), w;
          }
          return null;
        }
        // delete unused texture to release memory.
        deleteTexture(C) {
          return Object(G.deleteTexture)(C, this.renderer);
        }
        /* override */
        dispatchPointerEvent(C) {
          const N = C.type;
          if (N === "mousedown" || N === "mouseup" || N === "mousemove") {
            const S = this.__mouseCapturedTarget;
            if (S) {
              if (S.layer === this)
                return S.dispatchEvent(C), !0;
              this.__mouseCapturedTarget = null;
            }
          }
          let I, J;
          const T = this.layerTransformInvert;
          if (T) {
            I = C.x, J = C.y;
            const S = T, H = S[0] * I + S[2] * J + S[4], w = S[1] * I + S[3] * J + S[5];
            delete C.x, delete C.y, delete C.layerX, delete C.layerY, Object.defineProperties(C, {
              layerX: {
                value: H,
                configurable: !0
              },
              layerY: {
                value: w,
                configurable: !0
              },
              x: {
                value: H,
                configurable: !0
              },
              y: {
                value: w,
                configurable: !0
              }
            });
          }
          const K = super.dispatchPointerEvent(C);
          return T && Object.defineProperties(C, {
            layerX: {
              value: I,
              configurable: !0
            },
            layerY: {
              value: J,
              configurable: !0
            },
            x: {
              value: I,
              configurable: !0
            },
            y: {
              value: J,
              configurable: !0
            }
          }), K;
        }
        /* override */
        forceUpdate() {
          if (!this[u])
            if (this.parent && this.parent.hasOffscreenCanvas) {
              this.parent.forceUpdate();
              let C = null;
              const N = new Promise((I) => {
                C = I;
              });
              N._resolve = C, this[u] = N;
            } else {
              let C = null, N = null;
              const I = new Promise((J) => {
                C = J, this[h] && (N = Object(b.requestAnimationFrame)(() => {
                  delete I._requestID, this.render();
                }));
              });
              I._resolve = C, I._requestID = N, this[u] = I;
            }
        }
        getFBO() {
          const C = this.renderer.glRenderer, {
            width: N,
            height: I
          } = this.getResolution();
          return C && (!this[n] || this[n].width !== N || this[n].height !== I) ? (this[n] = {
            width: N,
            height: I,
            target: C.createFBO(),
            buffer: C.createFBO(),
            swap() {
              [this.target, this.buffer] = [this.buffer, this.target];
            }
          }, this[n]) : this[n] ? this[n] : null;
        }
        updateGlobalTransform() {
          if (this.layerTransformInvert) {
            const C = this.renderer, N = C.__globalTransformMatrix || C.globalTransformMatrix;
            C.__globalTransformMatrix = N;
            const I = s.mat2d.fromValues(1, 0, 0, 1, 0, 0);
            C.setGlobalTransform(...s.mat2d.multiply(I, N, this.transformMatrix));
          }
        }
        /* override */
        onPropertyChange(C, N, I) {
          if (super.onPropertyChange(C, N, I), C === "zIndex" && (this.canvas.style.zIndex = N), C === "transform" || C === "translate" || C === "rotate" || C === "scale" || C === "skew") {
            const J = this[a];
            if (this[a] = null, this.updateGlobalTransform(), J && !this.layerTransformInvert) {
              const T = this.renderer, K = T.__globalTransformMatrix || T.globalTransformMatrix;
              T.setGlobalTransform(...K);
            }
          }
        }
        _prepareRenderFinished() {
          this[u] && (this[u]._requestID && Object(b.cancelAnimationFrame)(this[u]._requestID), this[u]._resolve(), delete this[u]);
        }
        render({
          clear: C = !0
        } = {}) {
          const N = this[c].length ? this.getFBO() : null;
          N && this.renderer.glRenderer.bindFBO(N.target), C && this[r].clear();
          const I = this.draw();
          if (I && I.length && (this.renderer.drawMeshes(I), this.canvas.draw && this.canvas.draw()), N) {
            const J = this.renderer.glRenderer, T = this[c].length, {
              width: K,
              height: S
            } = this.getResolution(), H = [0, 0, K / this.displayRatio, S / this.displayRatio];
            this[c].forEach((w, P) => {
              w.blend = !0, w.setTexture(N.target.texture, {
                rect: H
              }), P === T - 1 ? J.bindFBO(null) : (N.swap(), J.bindFBO(N.target)), this[r].clear(), this.renderer.drawMeshes([w]);
            });
          }
          this._prepareRenderFinished();
        }
        /* override */
        setResolution({
          width: C,
          height: N
        }) {
          const I = this.renderer, J = I.__globalTransformMatrix || I.globalTransformMatrix, T = J[4], K = J[5], S = J[0], {
            width: H,
            height: w
          } = this.getResolution();
          (H !== C || w !== N) && (super.setResolution({
            width: C,
            height: N
          }), this.canvas && (this.canvas.width = C, this.canvas.height = N, I.updateResolution && I.updateResolution()), this.attributes.size = [C, N], this[c].length && this[c].forEach((z) => {
            const U = new i.Figure2D();
            U.rect(0, 0, C / this.displayRatio, N / this.displayRatio), z.contours = U.contours;
          }));
          const [P, B] = this.renderOffset, D = this.displayRatio;
          (T !== P || K !== B || S !== D) && (I.setGlobalTransform(D, 0, 0, D, P, B), I.__globalTransformMatrix = null, this[a] = null, this.updateGlobalTransform(), this.forceUpdate());
        }
        /**
         * tick(handler, {originTime = 0, playbackRate = 1.0, duration = Infinity})
         * @param {*} handler
         * @param {*} options
         */
        tick(C = null, N = {}) {
          let {
            duration: I = 1 / 0
          } = N, J = y(N, ["duration"]);
          const T = this.timeline.fork(J), K = this;
          this[e] = this[e] || [], this[e].push({
            handler: C,
            duration: I
          });
          const S = () => {
            let H = null, w = null;
            const P = () => {
              const B = this[e].map(({
                handler: D,
                duration: z
              }) => {
                const U = Math.min(1, T.currentTime / z);
                return {
                  value: D ? D(T.currentTime, U) : null,
                  p: U
                };
              });
              K[V] || (K[V] = Promise.resolve().then(() => {
                K[h] && K.render(), delete K[V];
                for (let D = B.length - 1; D >= 0; D--) {
                  const {
                    value: z,
                    p: U
                  } = B[D];
                  (z === !1 || U >= 1) && this[e].splice(D, 1);
                }
                this[e].length > 0 && S();
              }));
            };
            if (this[u] && this[u]._type !== "ticker" && (Object(b.cancelAnimationFrame)(this[u]._requestID), delete this[u]), !this[u]) {
              const B = new Promise((D) => {
                H = D, w = Object(b.requestAnimationFrame)(P);
              });
              B._resolve = H, B._requestID = w, B._type = "ticker", this[u] = B;
            }
          };
          S();
        }
        toGlobalPos(C, N) {
          if (this.layerTransformInvert) {
            const H = this.transformMatrix;
            C = H[0] * C + H[2] * N + H[4], N = H[1] * C + H[3] * N + H[5];
          }
          const {
            width: I,
            height: J
          } = this.getResolution(), T = this.renderOffset, K = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * K[0] / I + T[0], N = N * K[1] / J + T[1];
          const S = this.displayRatio;
          return C *= S, N *= S, [C, N];
        }
        toLocalPos(C, N) {
          const {
            width: I,
            height: J
          } = this.getResolution(), T = this.renderOffset, K = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * I / K[0] - T[0], N = N * J / K[1] - T[1];
          const S = this.displayRatio;
          C /= S, N /= S;
          const H = this.layerTransformInvert;
          return H && (C = H[0] * C + H[2] * N + H[4], N = H[1] * C + H[3] * N + H[5]), [C, N];
        }
      }
      o.default.registerNode(Y, "layer");
    },
    /* 287 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return u;
      });
      var i = l(224), t = l(288), s = l(213), b = l(252), Z = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      function o(V, c) {
        if (V == null)
          return {};
        var n = G(V, c), e, a;
        if (Object.getOwnPropertySymbols) {
          var Y = Object.getOwnPropertySymbols(V);
          for (a = 0; a < Y.length; a++)
            e = Y[a], !(c.indexOf(e) >= 0) && Object.prototype.propertyIsEnumerable.call(V, e) && (n[e] = V[e]);
        }
        return n;
      }
      function G(V, c) {
        if (V == null)
          return {};
        var n = {}, e = Object.keys(V), a, Y;
        for (Y = 0; Y < e.length; Y++)
          a = e[Y], !(c.indexOf(a) >= 0) && (n[a] = V[a]);
        return n;
      }
      function y(V, c, n) {
        return c in V ? Object.defineProperty(V, c, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : V[c] = n, V;
      }
      const X = "http://www.w3.org/2000/svg", W = Symbol.for("spritejs_setAttribute"), h = Symbol("root"), r = Symbol("task");
      function L(V, c = !0) {
        const n = V[h];
        if (n && n.children[0]) {
          const e = V.svg, a = V.layer ? V.layer.displayRatio : 1;
          if (!e.hasAttribute("data-original-width")) {
            let C = e.getAttribute("width");
            C = C ? Object(Z.sizeToPixel)(C) : 300;
            let N = e.getAttribute("height");
            N = N ? Object(Z.sizeToPixel)(N) : 150, e.hasAttribute("viewBox") || e.setAttribute("viewBox", `0 0 ${Math.round(C)} ${Math.round(N)}`), e.setAttribute("data-original-width", C), e.setAttribute("data-original-height", N);
          }
          let Y = V.attributes.width || Number(e.getAttribute("data-original-width")), R = V.attributes.height || Number(e.getAttribute("data-original-height"));
          if (Y *= a, R *= a, c && V.attributes.flexible) {
            const C = V.attributes.scale[0];
            if (Y *= C, R *= C, e.setAttribute("width", Y), e.setAttribute("height", R), Y && R && V.textureImage) {
              const N = V.textureImage.width, I = V.textureImage.height, J = V.clientSize;
              V.attributes.textureRect = [0, 0, Math.round(J[0] * N / Y), Math.round(J[1] * I / R)];
            }
          } else
            V[r] || (e.setAttribute("width", Y), e.setAttribute("height", R), V[r] = Promise.resolve().then(() => {
              delete V[r];
              const C = n.innerHTML, N = new Blob([C], {
                type: "image/svg+xml"
              }), I = URL.createObjectURL(N), J = new Image();
              J.onload = function() {
                J.width && J.height ? (V.attributes[W]("texture", J), V.attributes.flexible && (V.attributes.textureRect = null)) : V.attributes[W]("texture", null);
              }, J.src = I;
            }));
        }
      }
      class u extends i.default {
        constructor(c = {}) {
          typeof c == "string" && (c = {
            svgText: c
          });
          let {
            svgText: n
          } = c, e = o(c, ["svgText"]);
          if (super(e), this[h] = document.createElement("div"), n) {
            this[h].innerHTML = n;
            const a = this[h].children[0];
            a ? a.setAttribute("xmlns", X) : (fetch(n).then((Y) => Y.text()).then((Y) => {
              this[h].innerHTML = Y, (!this.observer || this.attributes.flexible) && L(this);
            }), n = null);
          }
          if (!n) {
            const a = document.createElementNS(X, "svg");
            a.setAttribute("xmlns", X), this[h].appendChild(a);
          }
          if (typeof MutationObserver == "function") {
            const a = new MutationObserver((Y) => {
              L(this, !1);
            });
            a.observe(this[h], {
              attributes: !0,
              subtree: !0,
              characterData: !0,
              childList: !0
            }), this.observer = a;
          }
        }
        get children() {
          return [this.svg];
        }
        get childNodes() {
          return [this.svg];
        }
        get svg() {
          return this[h] ? this[h].children[0] : null;
        }
        /* override */
        setResolution({
          width: c,
          height: n
        }) {
          super.setResolution({
            width: c,
            height: n
          }), L(this);
        }
        /* override */
        dispatchPointerEvent(c) {
          const n = super.dispatchPointerEvent(c);
          if (n && this.attributes.passEvents && typeof MouseEvent == "function") {
            const {
              x: e,
              y: a
            } = c;
            let [Y, R] = this.getOffsetPosition(e, a);
            const C = c.originalEvent, N = this.attributes.anchor, I = this.clientSize;
            Y = (Y + N[0] * I[0]) / 2, R = (R + N[1] * I[1]) / 2;
            const J = c.type;
            if (J === C.type) {
              let T = null;
              if (C instanceof MouseEvent)
                T = new MouseEvent(J, {
                  screenX: Y,
                  screenY: R,
                  clientX: Y,
                  clientY: R,
                  bubbles: C.bubbles,
                  button: C.button,
                  buttons: C.buttons,
                  cancelBubble: C.cancelBubble,
                  cancelable: C.cancelable,
                  currentTarget: C.currentTarget,
                  fromElement: C.fromElement,
                  relatedTarget: C.relatedTarget,
                  returnValue: C.returnValue,
                  srcElement: C.srcElement,
                  target: C.target,
                  toElement: C.toElement,
                  // view: originalEvent.view,
                  which: C.witch
                });
              else if (C instanceof TouchEvent) {
                let K = null;
                const S = C.changedTouches || [C];
                for (let H = 0; H < S.length; H++) {
                  const w = S[H];
                  if (c.identifier === w.identifier) {
                    K = w;
                    break;
                  }
                }
                if (K) {
                  const H = new Touch({
                    identifier: K.identifier,
                    target: K.target,
                    clientX: Y,
                    clientY: R,
                    screenX: Y,
                    screenY: R,
                    pageX: Y,
                    pageY: R,
                    radiusX: K.radiusX,
                    radiusY: K.radiusY,
                    rotationAngle: K.rotationAngle,
                    force: K.force
                  });
                  T = new TouchEvent(J, {
                    cancelable: C.cancelable,
                    bubbles: C.bubbles,
                    composed: C.composed,
                    touches: [H],
                    targetTouches: [H],
                    changedTouches: [H]
                  });
                }
              } else
                T = C;
              T && this.svg.dispatchEvent(T);
            }
          }
          return n;
        }
        getElementById(c) {
          return Object(b.querySelector)(`#${c}`, this);
        }
        getElementsByClassName(c) {
          return Object(b.querySelectorAll)(`.${c}`, this);
        }
        getElementsByName(c) {
          return Object(b.querySelectorAll)(`[name="${c}"]`, this);
        }
        getElementsByTagName(c) {
          return Object(b.querySelectorAll)(c, this);
        }
        querySelector(c) {
          return Object(b.querySelector)(c, this);
        }
        querySelectorAll(c) {
          return Object(b.querySelectorAll)(c, this);
        }
        /* override */
        onPropertyChange(c, n, e) {
          super.onPropertyChange(c, n, e), c === "flexible" && L(this), this.attributes.flexible && (c === "width" || c === "height" || c === "scale" || c === "transform") && L(this);
        }
      }
      y(u, "Attr", t.default), s.default.registerNode(u, "spritesvg");
    },
    /* 288 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return Z;
      });
      var i = l(225);
      l(1).glMatrix.setMatrixArrayType(Array);
      const t = Symbol.for("spritejs_getAttribute"), s = Symbol.for("spritejs_setAttribute"), b = Symbol.for("spritejs_setAttributeDefault");
      class Z extends i.default {
        constructor(G) {
          super(G), this[b]({
            passEvents: !1,
            flexible: !1
          });
        }
        // readonly
        get texture() {
          return this[t]("texture");
        }
        set texture(G) {
        }
        // eslint-disable-line no-empty-function
        get passEvents() {
          return this[t]("passEvents");
        }
        set passEvents(G) {
          return this[s]("passEvents", G);
        }
        get flexible() {
          return this[t]("flexible");
        }
        set flexible(G) {
          return this[s]("flexible", G);
        }
      }
    },
    /* 289 */
    /***/
    function(m, d, l) {
      l.r(d);
      var i = l(12);
      l(1).glMatrix.setMatrixArrayType(Array);
      function t(G, y) {
        var X = Object.keys(G);
        if (Object.getOwnPropertySymbols) {
          var W = Object.getOwnPropertySymbols(G);
          y && (W = W.filter(function(h) {
            return Object.getOwnPropertyDescriptor(G, h).enumerable;
          })), X.push.apply(X, W);
        }
        return X;
      }
      function s(G) {
        for (var y = 1; y < arguments.length; y++) {
          var X = arguments[y] != null ? arguments[y] : {};
          y % 2 ? t(Object(X), !0).forEach(function(W) {
            b(G, W, X[W]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(G, Object.getOwnPropertyDescriptors(X)) : t(Object(X)).forEach(function(W) {
            Object.defineProperty(G, W, Object.getOwnPropertyDescriptor(X, W));
          });
        }
        return G;
      }
      function b(G, y, X) {
        return y in G ? Object.defineProperty(G, y, { value: X, enumerable: !0, configurable: !0, writable: !0 }) : G[y] = X, G;
      }
      const Z = Symbol("inited");
      let o = null;
      typeof Worker == "function" && (o = class extends Worker {
        constructor(G) {
          if (G.worker === !0 && (G.worker = `./${G.id}.worker.js`), super(G.worker), this.options = G, !G.canvas) {
            const {
              width: y,
              height: X
            } = this.getResolution(), W = i.ENV.createCanvas(y, X, {
              offscreen: !1
            });
            W.style && (W.style.position = "absolute"), W.dataset && (W.dataset.layerId = G.id), G.canvas = W;
          }
          this.canvas = G.canvas;
        }
        get id() {
          return this.options.id;
        }
        setResolution({
          width: G,
          height: y
        }) {
          if (this[Z])
            this.postMessage({
              type: "resolution_change",
              width: G,
              height: y
            });
          else {
            this.canvas.width = G, this.canvas.height = y;
            const X = this.options, W = X.canvas.transferControlToOffscreen(), h = s({}, X);
            delete h.container, h.canvas = W, this.postMessage({
              type: "create",
              options: h
            }, [W]), this[Z] = !0;
          }
        }
        getResolution() {
          if (this.canvas) {
            const {
              width: G,
              height: y
            } = this.canvas;
            return {
              width: G,
              height: y
            };
          }
          return {
            width: 300,
            height: 150
          };
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        connect(G, y) {
          Object.defineProperty(this, "parent", {
            value: G,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: y,
            writable: !1,
            configurable: !0
          });
        }
        disconnect() {
          delete this.parent, delete this.zOrder;
        }
        dispatchPointerEvent(G) {
          this.postMessage({
            type: "event",
            event: {
              cancelBubble: G.cancelBubble,
              bubbles: G.bubbles,
              detail: G.detail,
              identifier: G.identifier,
              layerX: G.layerX,
              layerY: G.layerY,
              originalX: G.originalX,
              originalY: G.originalY,
              type: G.type,
              x: G.x,
              y: G.y
            }
          });
        }
      }), d.default = o;
    },
    /* 290 */
    /***/
    function(m, d, l) {
      l.r(d), (function(i) {
        l.d(d, "default", function() {
          return Y;
        });
        var t = l(12), s = l(68), b = l(70), Z = l(286), o = l(289), G = l(250), y = l(291), X = l(214), W = l(218), h = l(213);
        l(1).glMatrix.setMatrixArrayType(Array);
        const r = Symbol("enteredTargets");
        function L(R) {
          return R.id = R.id || `_layer${Math.random().toString(36).slice(2, 12)}`, R.dataset || (R.dataset = {}), R.dataset.layerId = R.id, R.connect = (C, N) => {
            R.parent = C, Object.defineProperty(R, "zOrder", {
              value: N,
              writable: !1,
              configurable: !0
            });
          }, R.disconnect = (C) => {
            delete R.zOrder;
          }, R.canvas = R, R.getResolution = () => ({
            width: 0,
            height: 0
          }), R.setResolution = () => !1, R.options = {
            handleEvent: !1
          }, R;
        }
        function u(R, C) {
          const N = R.children;
          let I = null;
          for (let J = 0; J < N.length; J++) {
            const T = N[J];
            if ((C === T || I != null) && (I = T), I && I !== C && !I.offscreen)
              return I.canvas;
          }
          return null;
        }
        function V(R, C) {
          const [N, I] = R.renderOffset, {
            width: J,
            height: T
          } = R.getResolution(), K = R.displayRatio;
          R.renderer.drawImage(C.canvas, -N / K, -I / K, J / K, T / K);
        }
        const c = {};
        function n(R) {
          const C = ["mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "touchstart", "touchend", "touchmove", "touchcancel", "click", "dblclick", "longpress", "tap", "contextmenu"], N = R.container;
          N.addEventListener("mouseleave", (I) => {
            const J = R[r];
            if (J.size) {
              const T = new X.default("mouseleave");
              T.setOriginalEvent(I), [...J].forEach((K) => {
                K.dispatchEvent(T);
              }), R[r].clear();
            }
          }, {
            passive: !0
          }), C.forEach((I) => {
            N.addEventListener(I, (J) => {
              const {
                left: T,
                top: K,
                displayRatio: S
              } = R.options, H = R.orderedChildren;
              Object(y.default)(J, {
                offsetLeft: T,
                offsetTop: K,
                displayRatio: S
              }).forEach((P) => {
                const B = P.identifier;
                if (P.type === "touchmove" || P.type === "touchend") {
                  const z = c[B];
                  z && z.dispatchEvent(P), P.type === "touchend" && delete c[B];
                } else {
                  for (let z = H.length - 1; z >= 0; z--) {
                    const U = H[z];
                    if (U.options.handleEvent !== !1) {
                      if (U.dispatchPointerEvent(P) && P.target !== U)
                        break;
                      P.cancelBubble = !1;
                    }
                  }
                  if (P.target === H[0])
                    for (let z = H.length - 1; z >= 0; z--) {
                      const U = H[z];
                      if (U.options.handleEvent !== !1) {
                        P.target = U;
                        break;
                      }
                    }
                }
                const D = P.target;
                if (P.type === "touchstart" && (c[B] = P.target), P.type === "mousemove") {
                  const z = R[r];
                  let U;
                  if (D) {
                    const _ = D.ancestors || [];
                    U = /* @__PURE__ */ new Set([D, ..._]);
                  } else
                    U = /* @__PURE__ */ new Set();
                  const O = Object.entries(J);
                  if (!z.has(D) && D) {
                    const _ = new X.default("mouseenter");
                    _.setOriginalEvent(J), O.forEach(([$, ol]) => {
                      _[$] = ol;
                    }), z.add(D), D.dispatchEvent(_);
                    const Zl = D.ancestors;
                    Zl && Zl.forEach(($) => {
                      $ instanceof b.default && !z.has($) && (z.add($), $.dispatchEvent(_));
                    });
                  }
                  const ll = new X.default("mouseleave");
                  ll.setOriginalEvent(J), O.forEach(([_, Zl]) => {
                    ll[_] = Zl;
                  }), [...z].forEach((_) => {
                    U.has(_) || (z.delete(_), _.dispatchEvent(ll));
                  });
                }
              });
            }, {
              passive: I !== "contextmenu"
            });
          });
        }
        function e(R, C) {
          if (C && C.style) {
            let {
              width: N,
              height: I,
              mode: J,
              container: T
            } = R;
            const {
              clientWidth: K,
              clientHeight: S
            } = T;
            N = N || K, I = I || S, J === "static" ? (C.style.width = `${N}px`, C.style.height = `${I}px`) : (C.style.top = "0", C.style.left = "0", C.style.width = `${K}px`, C.style.height = `${S}px`, C.style.transform = "", C.style.webkitTransform = "");
          }
        }
        const a = Symbol("offscreenLayerCount");
        class Y extends G.default {
          /**
            width
            height
            mode: 'static', 'scale', 'stickyWidth', 'stickyHeight', 'stickyTop', 'stickyBottom', 'stickyLeft', 'stickyRight'
           */
          constructor(C = {}) {
            if (super(), !C.container)
              if (typeof t.ENV.Container == "function")
                C.container = new t.ENV.Container(C.width || 300, C.height || 150);
              else
                throw new Error("No container specified.");
            if (this.container = C.container, this.container.style && (this.container.style.overflow || (this.container.style.overflow = "hidden"), this.container.style.position || (this.container.style.position = "relative")), this.options = C, C.displayRatio = C.displayRatio || 1, C.mode = C.mode || "scale", C.left = 0, C.top = 0, C.autoResize = C.autoResize !== !1, C.autoResize) {
              let N;
              if (typeof globalThis < "u" ? N = globalThis : N = typeof window < "u" ? window : i, N.addEventListener) {
                const I = this;
                N.addEventListener("resize", function J() {
                  typeof document < "u" && document.contains(I.container) ? I.resize() : N.removeEventListener("resize", J);
                });
              }
            }
            this[r] = /* @__PURE__ */ new Set(), this.setResolution(C), n(this), this[a] = 0;
          }
          get hasOffscreenCanvas() {
            return this[a] > 0;
          }
          set displayRatio(C) {
            this.options.displayRatio !== C && (this.options.displayRatio = C, this.resize());
          }
          get displayRatio() {
            return this.options.displayRatio;
          }
          set height(C) {
            this.options.height !== C && (this.options.height = C, this.resize());
          }
          get height() {
            return this.options.height;
          }
          set mode(C) {
            this.options.mode !== C && (this.options.mode = C, this.resize());
          }
          get mode() {
            return this.options.mode;
          }
          set width(C) {
            this.options.width !== C && (this.options.width = C, this.resize());
          }
          get width() {
            return this.options.width;
          }
          /* override */
          appendChild(C) {
            !(C instanceof Z.default) && !(C instanceof o.default) && L(C);
            const N = super.appendChild(C), I = C.canvas;
            return C.offscreen ? this[a]++ : this.container.appendChild(I), e(this.options, I), C.setResolution(this.getResolution()), N;
          }
          /* override */
          forceUpdate() {
            this.hasOffscreenCanvas && !this._requestID && (this._requestID = Object(s.requestAnimationFrame)(() => {
              delete this._requestID, this.render();
            }));
          }
          /* override */
          insertBefore(C, N) {
            !(C instanceof Z.default) && !(C instanceof o.default) && L(C);
            const I = super.insertBefore(C, N), J = C.canvas;
            if (!C.offscreen) {
              const T = u(this, C);
              this.container.insertBefore(J, T);
            }
            return e(this.options, J), C.setResolution(this.getResolution()), I;
          }
          layer(C = "default", N = {}) {
            N = Object.assign({}, this.options, N), N.id = C;
            const I = this.orderedChildren;
            for (let K = 0; K < I.length; K++)
              if (I[K].id === C)
                return I[K];
            const J = N.worker;
            let T;
            return J ? T = new o.default(N) : T = new Z.default(N), this.appendChild(T), T;
          }
          async preload(...C) {
            const N = [], I = [], J = [];
            for (let T = 0; T < C.length; T++) {
              const K = C[T];
              let S;
              if (typeof K == "string")
                S = Object(W.loadTexture)(K);
              else if (Array.isArray(K))
                S = Object(W.loadFrames)(...K);
              else {
                const {
                  id: H,
                  src: w
                } = K;
                S = Object(W.loadTexture)(w, H);
              }
              S instanceof Promise || (S = Promise.resolve(S)), I.push(S.then((H) => {
                N.push(H), J[T] = H;
                const w = new X.default({
                  type: "preload",
                  detail: {
                    current: H,
                    loaded: N,
                    resources: C
                  }
                });
                this.dispatchEvent(w);
              }));
            }
            return await Promise.all(I), J;
          }
          /* override */
          removeChild(C) {
            const N = super.removeChild(C);
            if (N) {
              C._prepareRenderFinished && C._prepareRenderFinished();
              const I = C.canvas;
              I && I.remove && I.remove(), C.offscreen && this[a]--;
            }
            return N;
          }
          // for offscreen mode rendering
          render() {
            const C = this.orderedChildren;
            let N = null;
            const I = [];
            for (let J = 0; J < C.length; J++) {
              const T = C[J], K = I.length > 0;
              if (T instanceof Z.default && !T.offscreen)
                if (!T.autoRender)
                  K && (console.warn("Some offscreen canvas will not be rendered."), I.length = 0);
                else if (N = T, K) {
                  T.renderer.clear();
                  for (let S = 0; S < I.length; S++) {
                    const H = I[S];
                    H.render(), V(T, H);
                  }
                  I.length = 0, T.render({
                    clear: !1
                  });
                } else
                  T.prepareRender && T.render();
              else
                T.offscreen ? N ? (T.prepareRender && T.render(), V(N, T)) : I.push(T) : T instanceof o.default && K && (console.warn("Some offscreen canvas will not be rendered."), I.length = 0);
            }
          }
          /* override */
          replaceChild(C, N) {
            const I = super.replaceChild(C, N);
            N.canvas.remove && N.canvas.remove(), N.offscreen && this[a]--;
            const J = C.canvas;
            if (!C.offscreen) {
              const T = u(this, C);
              this.container.insertBefore(J, T);
            }
            return e(this.options, J), C.setResolution(this.getResolution()), I;
          }
          resize() {
            const C = this.options;
            this.children.forEach((N) => {
              e(C, N.canvas);
            }), this.setResolution(C), this.dispatchEvent({
              type: "resize"
            });
          }
          /* override */
          setResolution({
            width: C,
            height: N
          } = {}) {
            const I = this.container, {
              clientWidth: J,
              clientHeight: T
            } = I;
            (C == null || N == null) && (C = C ?? J, N = N ?? T);
            const {
              mode: K,
              displayRatio: S
            } = this.options;
            if (C *= S, N *= S, this.options.left = 0, this.options.top = 0, K === "stickyHeight" || K === "stickyLeft" || K === "stickyRight") {
              const H = C;
              C = J * N / T, K === "stickyHeight" && (this.options.left = 0.5 * (C - H)), K === "stickyRight" && (this.options.left = C - H);
            } else if (K === "stickyWidth" || K === "stickyTop" || K === "stickyBottom") {
              const H = N;
              N = T * C / J, K === "stickyWidth" && (this.options.top = 0.5 * (N - H)), K === "stickyBottom" && (this.options.top = N - H);
            }
            super.setResolution({
              width: C,
              height: N
            });
          }
          snapshot({
            offscreen: C = !1,
            layers: N
          } = {}) {
            const I = C ? "snapshotOffScreenCanvas" : "snapshotCanvas", {
              width: J,
              height: T
            } = this.getResolution();
            this[I] = this[I] || t.ENV.createCanvas(J, T, {
              offscreen: C
            });
            const K = this[I].getContext("2d");
            N = N || this.orderedChildren, this[I].width = J, this[I].height = T;
            for (let S = 0; S < N.length; S++) {
              const H = N[S];
              if (!H.options.ignoreSnapshot) {
                H.render && H.render();
                const w = H.canvas;
                w && w !== H && K.drawImage(w, 0, 0, J, T);
              }
            }
            return this[I];
          }
        }
        typeof document < "u" && (Y.prototype.layer3d = function(R, C = {}) {
          const N = C.url || "https://unpkg.com/sprite-extend-3d/dist/sprite-extend-3d.min.js";
          return new Promise((I, J) => {
            const T = document.createElement("script");
            T.async = !1, T.src = N, T.onload = () => {
              try {
                I(this.layer3d(R, C));
              } catch (K) {
                J(K);
              }
            }, document.documentElement.appendChild(T);
          });
        }), h.default.registerNode(Y, "scene");
      }).call(this, l(22));
    },
    /* 291 */
    /***/
    function(m, d, l) {
      l.r(d), l.d(d, "default", function() {
        return t;
      });
      var i = l(214);
      l(1).glMatrix.setMatrixArrayType(Array);
      function t(s, {
        offsetTop: b = 0,
        offsetLeft: Z = 0,
        displayRatio: o = 1
      } = {}) {
        let G, y;
        const X = [], {
          left: W,
          top: h,
          width: r,
          height: L
        } = s.target.getBoundingClientRect(), u = s.target.width, V = s.target.height, c = s.changedTouches || [s];
        for (let e = 0; e < c.length; e++) {
          const a = c[e], Y = a.identifier, {
            clientX: R,
            clientY: C
          } = a;
          R != null && C != null && X.push({
            x: Math.round((R | 0) - W),
            y: Math.round((C | 0) - h),
            identifier: Y
          });
        }
        X.length <= 0 && X.push({
          x: G,
          y
        });
        const n = [];
        return X.forEach((e) => {
          e.x != null && e.y != null && (G = (e.x * u / r - Z) / o, y = (e.y * V / L - b) / o);
          const a = new i.default(s);
          Object.defineProperties(a, {
            layerX: {
              value: G,
              configurable: !0
            },
            layerY: {
              value: y,
              configurable: !0
            },
            originalX: {
              value: e.x
            },
            originalY: {
              value: e.y
            },
            x: {
              value: G,
              configurable: !0
            },
            y: {
              value: y,
              configurable: !0
            },
            identifier: {
              value: e.identifier
            }
          }), n.push(a);
        }), n;
      }
    }
    /******/
  ])
);
Ml.version;
Ml.Arc;
Ml.Block;
Ml.Cloud;
Ml.Color;
Ml.Ellipse;
Ml.Gradient;
Ml.Group;
Ml.Label;
Ml.Layer;
Ml.LayerWorker;
Ml.Node;
Ml.Parallel;
Ml.Path;
Ml.Polyline;
Ml.Rect;
Ml.Regular;
Ml.Ring;
Ml.Scene;
Ml.Sprite;
Ml.SpriteSvg;
Ml.Star;
Ml.Triangle;
Ml.helpers;
Ml.createElement;
Ml.isSpriteNode;
Ml.registerNode;
Ml.requestAnimationFrame;
Ml.cancelAnimationFrame;
Ml.ENV;
var yX = Fd, LX = xd, IX = "[object Boolean]";
function YX(m) {
  return m === !0 || m === !1 || LX(m) && yX(m) == IX;
}
var xX = YX;
const md = /* @__PURE__ */ Td(xX);
function rX(m, d) {
  if (m && d) {
    const l = Math.min(m.originX, d.originX), i = Math.min(m.originY, d.originY), t = Math.max(m.originX + m.width, d.originX + d.width), s = Math.max(m.originY + m.height, d.originY + d.height), b = t - l, Z = s - i;
    return { originX: l, originY: i, width: b, height: Z };
  }
  return d || m;
}
const gd = (m, d) => new Promise(function(l) {
  window.requestIdleCallback ? requestIdleCallback(() => {
    l(1);
  }, { timeout: d }) : setTimeout(() => {
    l(2);
  }, d);
}).then(function() {
  m();
}, () => {
  m();
}), Ui = (m) => {
  const d = m.webkitBackingStorePixelRatio || m.mozBackingStorePixelRatio || m.msBackingStorePixelRatio || m.oBackingStorePixelRatio || m.backingStorePixelRatio || 1;
  return Math.max(1, (window.devicePixelRatio || 1) / d);
};
class Ld extends jt {
  constructor(d, l) {
    super(d), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serviceStorage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncClockState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Ld.syncInterval = (l || Ld.syncInterval) * 0.5, this.namespace = Ld.namespace, this.serviceStorage = this.getNamespaceData(), this.storage = El(this.serviceStorage);
  }
  getViewIdBySecenPath(d) {
    const l = this.getNamespaceData();
    for (const [i, t] of Object.entries(l))
      for (const s of Object.keys(t))
        if (s === d)
          return i;
  }
  getScenePathData(d) {
    const l = this.getNamespaceData();
    for (const i of Object.values(l))
      for (const t of Object.keys(i))
        if (t === d)
          return El(i[t]);
  }
  getStorageData(d, l) {
    const i = this.getNamespaceData();
    return i[d] && El(i[d][l]) || void 0;
  }
  hasSelector(d, l) {
    const i = this.storage && this.storage[d] && this.storage[d][l];
    return !!(i && Object.keys(i).find((t) => this.isOwn(t) && this.getLocalId(t) === Il));
  }
  addStorageStateListener(d) {
    this.stateDisposer = Pt(async () => {
      const l = this.getNamespaceData(), i = this.diffFun(this.serviceStorage, l);
      this.serviceStorage = l;
      for (const [t, s] of Object.entries(i))
        if (s && s.newValue === void 0) {
          const { viewId: b, scenePath: Z } = s;
          b && Z && this.storage[b] && delete this.storage[b][Z][t];
        } else if (s && s.newValue) {
          const { viewId: b, scenePath: Z } = s;
          this.storage[b] || (this.storage[b] = {}), this.storage[b][Z] || (this.storage[b][Z] = {}), this.storage[b][Z][t] = El(s.newValue);
        }
      Object.keys(i).length > 0 && d(i);
    });
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  diffFun(d, l) {
    const i = nd(d), t = nd(l), s = {};
    for (const b of i) {
      if (dd(d[b], l[b]))
        continue;
      const Z = this.diffFunByscenePath(d[b] || {}, l[b] || {}, b);
      Object.assign(s, Z);
    }
    for (const b of t)
      if (!i.includes(b)) {
        const Z = this.diffFunByscenePath(d[b] || {}, l[b] || {}, b);
        Object.assign(s, Z);
      }
    return s;
  }
  diffFunByscenePath(d, l, i) {
    const t = nd(d), s = nd(l), b = {};
    for (const Z of t) {
      if (dd(d[Z], l[Z]))
        continue;
      const o = this.diffFunByKeys(d[Z] || {}, l[Z] || {}, Z, i);
      Object.assign(b, o);
    }
    for (const Z of s)
      if (!t.includes(Z)) {
        const o = this.diffFunByKeys(d[Z] || {}, l[Z] || {}, Z, i);
        Object.assign(b, o);
      }
    return b;
  }
  diffFunByKeys(d, l, i, t) {
    const s = nd(d), b = nd(l), Z = {};
    for (const o of s) {
      if (b.includes(o)) {
        if (dd(d[o], l[o]))
          continue;
        Z[o] = {
          oldValue: d[o],
          newValue: l[o],
          viewId: t,
          scenePath: i
        };
        continue;
      }
      Z[o] = {
        oldValue: d[o],
        newValue: void 0,
        viewId: t,
        scenePath: i
      };
    }
    for (const o of b)
      s.includes(o) || (Z[o] = {
        oldValue: void 0,
        newValue: l[o],
        viewId: t,
        scenePath: i
      });
    return Z;
  }
  transformKey(d) {
    return this.uid + Vd + d;
  }
  isOwn(d) {
    return d.split(Vd)[0] === this.uid;
  }
  dispatch(d) {
    const { type: l, workId: i, ops: t, index: s, opt: b, toolsType: Z, removeIds: o, updateNodeOpt: G, op: y, selectIds: X, isSync: W, scenePath: h, viewId: r } = d;
    if (r)
      switch (l) {
        case Vl.Clear:
          const L = {};
          h && this.storage[r] && this.storage[r][h] ? (delete this.storage[r][h], this.setState(L, { isSync: W, viewId: r, scenePath: h })) : this.storage[r] && (delete this.storage[r], this.setState(L, { isSync: W, viewId: r, scenePath: "" }));
          break;
        case Vl.CreateWork:
          if (h && i && Z && b) {
            const e = this.isLocalId(i.toString()) ? this.transformKey(i) : i;
            this.updateValue(e.toString(), {
              type: Vl.CreateWork,
              workId: i,
              toolsType: Z,
              opt: b
            }, { isSync: W, viewId: r, scenePath: h });
          }
          break;
        case Vl.DrawWork:
          if (h && i && typeof s == "number" && (y != null && y.length)) {
            const e = this.isLocalId(i.toString()) ? this.transformKey(i) : i, a = this.storage[r] && this.storage[r][h] && this.storage[r][h][e] || void 0, Y = s ? ((a == null ? void 0 : a.op) || []).slice(0, s).concat(y) : y || (a == null ? void 0 : a.op);
            a && Y && this.updateValue(e.toString(), {
              ...a,
              type: Vl.DrawWork,
              op: Y,
              index: s
            }, { isSync: W, viewId: r, scenePath: h });
          }
          break;
        case Vl.FullWork:
          if (h && i) {
            const e = this.isLocalId(i.toString()) ? this.transformKey(i) : i, a = this.storage[r] && this.storage[r][h] && this.storage[r][h][e] || void 0, Y = G || (a == null ? void 0 : a.updateNodeOpt), R = Z || (a == null ? void 0 : a.toolsType), C = b || (a == null ? void 0 : a.opt), N = t || (a == null ? void 0 : a.ops);
            R && C && this.updateValue(e.toString(), {
              type: Vl.FullWork,
              updateNodeOpt: Y,
              workId: e,
              toolsType: R,
              opt: C,
              ops: N
            }, { isSync: W, viewId: r, scenePath: h });
          }
          break;
        case Vl.RemoveNode:
          if (h && (o != null && o.length)) {
            const e = o.map((a) => this.isLocalId(a + "") ? this.transformKey(a) : a);
            this.storage[r] && this.storage[r][h] && Object.keys(this.storage[r][h]).map((a) => {
              e != null && e.includes(a) && this.updateValue(a, void 0, { isSync: W, viewId: r, scenePath: h });
            });
          }
          break;
        case Vl.UpdateNode:
          if (h && i && (G || t || b)) {
            const e = this.isLocalId(i.toString()) ? this.transformKey(i) : i, a = this.storage[r] && this.storage[r][h] && this.storage[r][h][e] || void 0;
            a && (a.updateNodeOpt = G, (t || y) && (a.ops = t, a.op = y), b && (a.opt = b), a.type = Vl.FullWork, this.updateValue(e.toString(), a, { isSync: W, viewId: r, scenePath: h }));
          }
          break;
        case Vl.Select:
          if (!h)
            return;
          let u;
          X != null && X.length && (u = X.map((e) => this.isLocalId(e + "") ? this.transformKey(e) : e));
          const V = this.transformKey(Il), c = this.storage[r] && this.storage[r][h] && this.storage[r][h][V] || void 0, n = b || (c == null ? void 0 : c.opt);
          u && this.checkOtherSelector(V, u, { isSync: W, viewId: r, scenePath: h }), this.updateValue(V, u && {
            type: Vl.Select,
            toolsType: bl.Selector,
            opt: n,
            selectIds: u
          }, { isSync: W, viewId: r, scenePath: h });
          break;
      }
  }
  checkOtherSelector(d, l, i) {
    const { viewId: t, scenePath: s } = i;
    for (const b of Object.keys(this.storage[t][s]))
      if (b !== d && this.getLocalId(b) === Il) {
        const Z = this.storage[t][s][b];
        if (Z && Z.selectIds) {
          const o = Z.selectIds.filter((G) => !l.includes(G));
          o.length > 0 && (Z.selectIds = o), this.updateValue(b, o.length && Z || void 0, i);
        }
      }
  }
  setState(d, l) {
    const { viewId: i, scenePath: t } = l, s = nd(d);
    for (let b = 0; b < s.length; b++) {
      const Z = s[b], o = d[Z];
      typeof o < "u" ? (this.storage[i] || (this.storage[i] = {}), this.storage[i][t] || (this.storage[i][t] = {}), this.storage[i][t][Z] = o) : delete this.storage[i][t][Z];
    }
    this.runSyncService(l);
  }
  updateValue(d, l, i) {
    const { viewId: t, scenePath: s } = i;
    l === void 0 ? delete this.storage[t][s][d] : (this.storage[t] || (this.storage[t] = {}), this.storage[t][s] || (this.storage[t][s] = {}), this.storage[t][s][d] = l), this.runSyncService(i);
  }
  runSyncService(d) {
    this.asyncClockState || (this.asyncClockState = !0, setTimeout(() => {
      d.isSync ? (this.asyncClockState = !1, this.syncSerivice(d.isAfterUpdate)) : gd(() => {
        this.asyncClockState = !1, this.syncSerivice(d.isAfterUpdate);
      }, Ld.syncInterval);
    }, d != null && d.isSync ? 0 : Ld.syncInterval));
  }
  syncSerivice(d = !1) {
    const l = nd(this.serviceStorage), i = nd(this.storage), t = /* @__PURE__ */ new Map();
    for (const s of l) {
      if (!i.includes(s)) {
        t.set(s, void 0);
        continue;
      }
      dd(this.serviceStorage[s], this.storage[s]) || this.syncViewData(s, d);
    }
    for (const s of i)
      l.includes(s) || t.set(s, this.storage[s]);
    if (t.size > 5)
      this.syncStorageView(this.storage, d);
    else
      for (const [s, b] of t.entries())
        this.syncUpdataView(s, b, d);
  }
  syncViewData(d, l = !1) {
    const i = nd(this.serviceStorage[d]), t = nd(this.storage[d]), s = /* @__PURE__ */ new Map();
    for (const b of i) {
      if (!t.includes(b)) {
        s.set(b, void 0);
        continue;
      }
      dd(this.serviceStorage[d][b], this.storage[d][b]) || this.syncScenePathData(d, b, l);
    }
    for (const b of t)
      i.includes(b) || s.set(b, this.storage[d][b]);
    if (s.size > 5)
      this.syncStorageScenePath(d, this.storage[d], l);
    else
      for (const [b, Z] of s.entries())
        this.syncUpdataScenePath(d, b, Z, l);
  }
  syncScenePathData(d, l, i = !1) {
    const t = nd(this.serviceStorage[d][l]), s = nd(this.storage[d][l]), b = /* @__PURE__ */ new Map();
    for (const Z of t) {
      if (!s.includes(Z)) {
        b.set(Z, void 0);
        continue;
      }
      dd(this.serviceStorage[d][l][Z], this.storage[d][l][Z]) || b.set(Z, this.storage[d][l][Z]);
    }
    for (const Z of s)
      t.includes(Z) || b.set(Z, this.storage[d][l][Z]);
    if (b.size > 5)
      this.syncStorageKey(d, l, this.storage[d][l], i);
    else
      for (const [Z, o] of b.entries())
        this.syncUpdataKey(d, l, Z, o, i);
  }
  syncUpdataView(d, l, i = !1) {
    var s;
    Object.keys(this.serviceStorage).length ? (i || (l === void 0 ? delete this.serviceStorage[d] : this.serviceStorage[d] = El(l)), (s = this.plugin) == null || s.updateAttributes([this.namespace, d], l)) : this.syncStorageView(this.storage, i);
  }
  syncStorageView(d, l = !1) {
    var i;
    l || d && (this.serviceStorage = El(d)), (i = this.plugin) == null || i.updateAttributes([this.namespace], d);
  }
  syncUpdataScenePath(d, l, i, t = !1) {
    var b;
    Object.keys(this.serviceStorage[d]).length ? (t || (i === void 0 ? delete this.serviceStorage[d][l] : this.serviceStorage[d][l] = i), (b = this.plugin) == null || b.updateAttributes([this.namespace, d, l], i)) : this.syncStorageScenePath(d, this.storage[d], t);
  }
  syncStorageScenePath(d, l, i = !1) {
    var t;
    i || l && (this.serviceStorage[d] = l), (t = this.plugin) == null || t.updateAttributes([this.namespace, d], l);
  }
  syncUpdataKey(d, l, i, t, s = !1) {
    var Z;
    Object.keys(this.serviceStorage[d][l]).length ? (s || (t === void 0 ? delete this.serviceStorage[d][l][i] : this.serviceStorage[d][l][i] = t), (Z = this.plugin) == null || Z.updateAttributes([this.namespace, d, l, i], t)) : this.syncStorageKey(d, l, this.storage[d][l], s);
  }
  syncStorageKey(d, l, i, t = !1) {
    var s;
    t || (this.serviceStorage[d][l] = i), (s = this.plugin) == null || s.updateAttributes([this.namespace, d, l], i);
  }
  keyTransformWorkId(d) {
    const l = d.split(Vd);
    return l.length === 2 ? l[1] : d;
  }
  destroy() {
    this.removeStorageStateListener(), this.serviceStorage = {}, this.storage = {};
  }
}
Object.defineProperty(Ld, "namespace", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PluginState"
});
Object.defineProperty(Ld, "syncInterval", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
class RX {
  constructor() {
    Object.defineProperty(this, "roomMembers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "onChangeHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    });
  }
  setRoomMembers(d) {
    this.executChangeUidHook(this.roomMembers, d), this.roomMembers = d;
  }
  executChangeUidHook(d, l) {
    const i = {
      online: l.map((t) => {
        var s;
        return ((s = t.payload) == null ? void 0 : s.uid) || t.session;
      }),
      offline: d.map((t) => {
        var s;
        return ((s = t.payload) == null ? void 0 : s.uid) || t.session;
      })
    };
    this.onChangeHooks.forEach((t) => t(i));
  }
  getRoomMember(d) {
    return this.roomMembers.find((l) => {
      var i;
      return ((i = l.payload) == null ? void 0 : i.uid) === d;
    });
  }
  isOnLine(d) {
    return !this.getRoomMember(d);
  }
  onUidChangeHook(d) {
    this.onChangeHooks.add(d);
  }
  destroy() {
    this.onChangeHooks.clear();
  }
}
var ad;
(function(m) {
  m[m.Text = 1] = "Text", m[m.Shape = 2] = "Shape";
})(ad || (ad = {}));
class ql {
  createProxy(d) {
    const l = new Proxy(d, {
      get(i, t, s) {
        const b = ql.interceptors.hasOwnProperty(t) ? ql.interceptors : i;
        return Reflect.get(b, t, s);
      }
    });
    return ql.proxyToRaw.set(l, d), l;
  }
}
Object.defineProperty(ql, "proxyToRaw", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /* @__PURE__ */ new WeakMap()
});
Object.defineProperty(ql, "interceptors", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    entries(...m) {
      return ql.proxyToRaw.get(this).entries(...m);
    },
    forEach(...m) {
      return ql.proxyToRaw.get(this).forEach(...m);
    },
    size() {
      return ql.proxyToRaw.get(this).size;
    },
    get(m) {
      return ql.proxyToRaw.get(this).get(m);
    },
    set(m, d) {
      return ql.proxyToRaw.get(this).set(m, d);
    },
    delete(m, d) {
      return ql.proxyToRaw.get(this).delete(m);
    },
    clear() {
      return ql.proxyToRaw.get(this).clear();
    }
  }
});
class SX {
  constructor(d) {
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "editors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "activeId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "proxyMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "taskqueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
    const { control: l, internalMsgEmitter: i } = d;
    this.control = l, this.internalMsgEmitter = i;
    const t = /* @__PURE__ */ new Map();
    this.proxyMap = new ql();
    const s = this, b = ql.interceptors.set;
    ql.interceptors.set = function(o, G) {
      return s.interceptors.set(o, G), b.call(this, o, G);
    };
    const Z = ql.interceptors.delete;
    ql.interceptors.delete = function(o, G) {
      return s.interceptors.delete(o, G), Z.call(this, o);
    }, this.editors = this.proxyMap.createProxy(t);
  }
  get collector() {
    return this.control.collector;
  }
  filterEditor(d) {
    const l = /* @__PURE__ */ new Map();
    return this.editors.forEach((i, t) => {
      i.viewId === d && l.set(t, i);
    }), l;
  }
  get interceptors() {
    return {
      set: (d, l) => {
        var h, r, L, u, V, c, n, e;
        if (!this.collector)
          return !0;
        const { viewId: i, scenePath: t, canSync: s, canWorker: b, type: Z, opt: o, dataType: G } = l;
        if (!b && !s)
          return !0;
        const X = ((h = this.collector) == null ? void 0 : h.isLocalId(d)) ? (r = this.collector) == null ? void 0 : r.transformKey(d) : d, W = ((L = this.collector) == null ? void 0 : L.storage[i]) && this.collector.storage[i][t] && this.collector.storage[i][t][X] || void 0;
        W ? W.toolsType === bl.Text && (b && (this.control.worker.queryTaskBatchData({
          workId: d,
          msgType: Vl.UpdateNode
        }).forEach((a) => {
          var Y;
          (Y = this.control.worker) == null || Y.taskBatchData.delete(a);
        }), (n = this.control.worker) == null || n.taskBatchData.add({
          workId: d,
          msgType: Vl.UpdateNode,
          dataType: G || Jl.Local,
          toolsType: bl.Text,
          opt: o,
          viewId: i,
          scenePath: t
          // willSyncService: canSync
        }), (e = this.control.worker) == null || e.runAnimation()), s && gd(() => {
          var a;
          (a = this.collector) == null || a.dispatch({
            type: Vl.UpdateNode,
            workId: d,
            toolsType: bl.Text,
            opt: o,
            viewId: i,
            scenePath: t
          });
        }, this.control.worker.maxLastSyncTime)) : Z === ad.Text && (s && ((u = this.collector) == null || u.dispatch({
          type: o.text && Vl.FullWork || Vl.CreateWork,
          workId: d,
          toolsType: bl.Text,
          opt: o,
          isSync: !0,
          viewId: i,
          scenePath: t
        })), b && ((V = this.control.worker) == null || V.taskBatchData.add({
          workId: d,
          msgType: o.text && Vl.FullWork || Vl.CreateWork,
          dataType: G || Jl.Local,
          toolsType: bl.Text,
          opt: o,
          viewId: i,
          scenePath: t
        }), (c = this.control.worker) == null || c.runAnimation()));
      },
      delete: (d) => {
        var Z, o;
        if (!this.collector)
          return !0;
        const l = this.editors.get(d);
        if (!l)
          return !0;
        const { viewId: i, scenePath: t, canSync: s, canWorker: b } = l;
        if (!b && !s)
          return !0;
        b && ((Z = this.control.worker) == null || Z.taskBatchData.add({
          workId: d,
          toolsType: bl.Text,
          msgType: Vl.RemoveNode,
          dataType: Jl.Local,
          viewId: i,
          scenePath: t
        }), (o = this.control.worker) == null || o.runAnimation()), s && gd(() => {
          var G;
          (G = this.collector) == null || G.dispatch({
            type: Vl.RemoveNode,
            removeIds: [d],
            toolsType: bl.Text,
            viewId: i,
            scenePath: t
          });
        }, this.control.worker.maxLastSyncTime);
      },
      clear() {
        return !0;
      }
    };
  }
  computeTextActive(d, l) {
    var s, b, Z, o;
    const i = (s = this.control.viewContainerManager) == null ? void 0 : s.transformToScenePoint(d, l), t = (b = this.control.viewContainerManager) == null ? void 0 : b.getCurScenePath(l);
    l && t && ((Z = this.control.worker) == null || Z.taskBatchData.add({
      msgType: Vl.GetTextActive,
      dataType: Jl.Local,
      op: i,
      viewId: l,
      scenePath: t
    }), (o = this.control.worker) == null || o.runAnimation());
  }
  checkEmptyTextBlur() {
    if (this.activeId) {
      const d = this.editors.get(this.activeId), l = (d == null ? void 0 : d.opt.text) && (d == null ? void 0 : d.opt.text.replace(/\s*,/g, "")), i = d == null ? void 0 : d.viewId;
      l ? this.unActive() : this.delete(this.activeId, !0, !0), this.undoTickerId && i && (this.internalMsgEmitter.emit("undoTickerEnd", this.undoTickerId, i, !0), this.undoTickerId = void 0);
    }
  }
  onCameraChange(d, l) {
    var i, t;
    for (const [s, b] of this.editors.entries())
      if (b.viewId === l) {
        const { boxPoint: Z, boxSize: o } = b.opt, G = Z && ((i = this.control.viewContainerManager) == null ? void 0 : i.transformToOriginPoint(Z, b.viewId)), y = (t = this.control.viewContainerManager) == null ? void 0 : t.getCurScenePath(l);
        if (y && l) {
          const X = {
            x: G && G[0] || 0,
            y: G && G[1] || 0,
            w: o && o[0] || 0,
            h: o && o[1] || 0,
            opt: b.opt,
            scale: d.scale,
            type: ad.Text,
            viewId: l,
            scenePath: y,
            canWorker: !1,
            canSync: !1
          };
          this.editors.set(s, X), this.control.viewContainerManager.setActiveTextEditor(l, this.activeId);
        }
      }
  }
  onServiceDerive(d) {
    var r, L;
    const { workId: l, opt: i, msgType: t, viewId: s, scenePath: b, dataType: Z } = d;
    if (!l || !s || !b)
      return;
    const o = l.toString();
    if (t === Vl.RemoveNode) {
      console.log("onServiceDerive-d", o), this.delete(o, !0, !0);
      return;
    }
    const { boxPoint: G, boxSize: y } = i, X = G && ((r = this.control.viewContainerManager) == null ? void 0 : r.transformToOriginPoint(G, s)), W = this.control.viewContainerManager.getView(s), h = {
      x: X && X[0] || 0,
      y: X && X[1] || 0,
      w: y && y[0] || 0,
      h: y && y[1] || 0,
      opt: i,
      type: ad.Text,
      canWorker: !0,
      canSync: !1,
      dataType: Z,
      // dataType: this.collector?.isLocalId(workIdStr) ? EDataType.Local : EDataType.Service,
      scale: ((L = W == null ? void 0 : W.cameraOpt) == null ? void 0 : L.scale) || 1,
      viewId: s,
      scenePath: b
    };
    this.editors.set(o, h), Z === Jl.Service && i.workState === hl.Done && this.activeId === o && (this.activeId = void 0), console.log("onServiceDerive---1", o, h.opt.text, h.opt.uid, this.activeId, Z), this.control.viewContainerManager.setActiveTextEditor(s, this.activeId);
  }
  updateForViewEdited(d, l) {
    var t;
    this.editors.set(d, l);
    const i = (t = this.taskqueue.get(d)) == null ? void 0 : t.resolve;
    i && i(l);
  }
  active(d) {
    var i;
    const l = this.editors.get(d);
    l && l.viewId && (l.opt.workState = hl.Start, l.opt.uid = (i = this.collector) == null ? void 0 : i.uid, this.activeId = d, l.canWorker = !0, l.canSync = !0, console.log("onServiceDerive---0", l.opt.uid), this.editors.set(d, l), this.control.viewContainerManager.setActiveTextEditor(l.viewId, this.activeId));
  }
  unActive() {
    const d = this.activeId && this.editors.get(this.activeId);
    d && d.viewId && this.activeId && (d.opt.workState = hl.Done, d.opt.uid = void 0, d.canWorker = !0, d.canSync = !0, this.editors.set(this.activeId, d), this.activeId = void 0, this.control.viewContainerManager.setActiveTextEditor(d.viewId, this.activeId));
  }
  createTextForMasterController(d, l) {
    var b;
    const { workId: i, isActive: t, ...s } = d;
    s.opt.zIndex = this.getMaxZIndex() + 1, s.opt.uid = (b = this.collector) == null ? void 0 : b.uid, l && (this.undoTickerId = l, this.internalMsgEmitter.emit("undoTickerStart", this.undoTickerId, s.viewId)), t && (this.activeId = i), s.dataType = Jl.Local, s.canWorker = !0, s.canSync = !0, this.editors.set(i, s), this.control.viewContainerManager.setActiveTextEditor(s.viewId, this.activeId);
  }
  updateTextForMasterController(d, l) {
    var b;
    const { workId: i, ...t } = d;
    l && (this.undoTickerId = l, this.internalMsgEmitter.emit("undoTickerStart", this.undoTickerId, t.viewId));
    const s = this.editors.get(i) || {};
    t.opt && (t.opt.uid = (b = this.collector) == null ? void 0 : b.uid), t.dataType = Jl.Local, this.editors.set(i, { ...s, ...t }), this.control.viewContainerManager.setActiveTextEditor(t.viewId, this.activeId);
  }
  async updateTextControllerWithEffectAsync(d, l) {
    var G;
    const { workId: i, ...t } = d;
    l && (this.undoTickerId = l, this.internalMsgEmitter.emit("undoTickerStart", this.undoTickerId, t.viewId));
    const s = this.editors.get(i) || {};
    if (t.opt && (t.opt.uid = (G = this.collector) == null ? void 0 : G.uid), t.dataType = Jl.Local, this.editors.set(i, { ...s, ...t }), this.control.viewContainerManager.setActiveTextEditor(t.viewId, this.activeId), this.taskqueue.has(i))
      return;
    const b = setTimeout(() => {
      var X;
      const y = (X = this.taskqueue.get(i)) == null ? void 0 : X.resolve;
      y && y(void 0);
    }, 20), Z = await new Promise((y) => {
      this.taskqueue.set(i, { resolve: y, clocker: b });
    }), o = this.taskqueue.get(i);
    return o && (o.clocker && clearTimeout(o.clocker), this.taskqueue.delete(i)), this.taskqueue.delete(i), Z;
  }
  updateTextForWorker(d, l) {
    const { workId: i, isActive: t, ...s } = d;
    l && (this.undoTickerId = l, this.internalMsgEmitter.emit("undoTickerStart", this.undoTickerId, s.viewId));
    const Z = { ...this.editors.get(i) || {}, ...s };
    if (t) {
      Z.canWorker = !1, Z.canSync = !1, this.editors.set(i, Z), this.active(i);
      return;
    }
    this.editors.set(i, Z), this.control.viewContainerManager.setActiveTextEditor(s.viewId, this.activeId);
  }
  get(d) {
    return this.editors.get(d);
  }
  delete(d, l, i) {
    const t = this.editors.get(d);
    if (t) {
      const s = t.viewId;
      t.canSync = l, t.canWorker = i, this.editors.delete(d), this.activeId === d && (this.activeId = void 0), this.control.viewContainerManager.setActiveTextEditor(s, this.activeId);
    }
  }
  deleteBatch(d, l, i) {
    const t = /* @__PURE__ */ new Set();
    for (const s of d) {
      const b = this.editors.get(s);
      if (b) {
        const Z = b.viewId;
        b.canSync = l, b.canWorker = i, this.editors.delete(s), this.activeId === s && (this.activeId = void 0), t.add(Z);
      }
    }
    for (const s of t)
      this.control.viewContainerManager.setActiveTextEditor(s, this.activeId);
  }
  clear(d, l) {
    this.editors.forEach((i, t) => {
      i.viewId === d && (l && (i.canSync = !1), i.canWorker = !1, this.editors.delete(t));
    }), this.activeId = void 0, this.control.viewContainerManager.setActiveTextEditor(d, this.activeId);
  }
  destory() {
    this.editors.clear(), this.activeId = void 0;
  }
  getMaxZIndex() {
    let d = 0;
    return this.editors.forEach((l) => {
      l.opt.zIndex && l.opt.zIndex > d && (d = l.opt.zIndex);
    }), d;
  }
}
class Id extends jt {
  constructor(d, l) {
    super(d), Object.defineProperty(this, "serviceStorage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncClockTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.namespace = Id.namespace, Id.syncInterval = (l || Id.syncInterval) * 0.5, this.serviceStorage = this.getNamespaceData(), this.storage = El(this.serviceStorage);
  }
  addStorageStateListener(d) {
    this.stateDisposer = Pt(async () => {
      const l = this.getNamespaceData(), i = this.getDiffMap(this.serviceStorage, l);
      this.serviceStorage = l, i.size && d(i);
    });
  }
  getDiffMap(d, l) {
    const i = /* @__PURE__ */ new Map();
    for (const [t, s] of Object.entries(l))
      t !== this.uid && (s && dd(d[t], s) || s && i.set(t, s));
    return i;
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  transformKey(d) {
    return this.uid + Vd + d;
  }
  isOwn(d) {
    return d === this.uid;
  }
  dispatch(d) {
    const { type: l, op: i, isSync: t, viewId: s } = d;
    switch (l) {
      case Jd.Cursor:
        i && this.pushValue(this.uid, {
          type: Jd.Cursor,
          op: i,
          viewId: s
        }, { isSync: t });
        break;
    }
  }
  pushValue(d, l, i) {
    var t;
    this.storage[d] || (this.storage[d] = []), (t = this.storage[d]) == null || t.push(l), this.runSyncService(i);
  }
  clearValue(d) {
    var i;
    this.storage[d] = void 0, Object.keys(this.serviceStorage).length && ((i = this.plugin) == null || i.updateAttributes([this.namespace, d], void 0));
  }
  runSyncService(d) {
    this.asyncClockTimer || (this.asyncClockTimer = setTimeout(() => {
      d != null && d.isSync ? (this.asyncClockTimer = void 0, this.syncSerivice()) : gd(() => {
        this.asyncClockTimer = void 0, this.syncSerivice();
      }, Id.syncInterval);
    }, d != null && d.isSync ? 0 : Id.syncInterval));
  }
  syncSerivice() {
    var l;
    Object.keys(this.serviceStorage).length ? Object.keys(this.storage).forEach((i) => {
      var t;
      (t = this.plugin) == null || t.updateAttributes([this.namespace, i], this.storage[i]);
    }) : (l = this.plugin) == null || l.updateAttributes(this.namespace, this.storage), this.storage = {};
  }
  destroy() {
    this.removeStorageStateListener(), this.storage = {}, this.serviceStorage = {};
  }
}
Object.defineProperty(Id, "syncInterval", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 100
});
Object.defineProperty(Id, "namespace", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PluginEvent"
});
var Nt;
(function(m) {
  m[m.Event = 0] = "Event", m[m.Storage = 1] = "Storage";
})(Nt || (Nt = {}));
class KX {
  constructor(d) {
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "eventCollector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomMember", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "removeTimerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncEndInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationPointWorkers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "animationDrawWorkers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
    const { control: l, internalMsgEmitter: i } = d;
    this.internalMsgEmitter = i, this.control = l, this.roomMember = l.roomMember;
  }
  activeCollector() {
    var d, l;
    this.control.plugin && (this.eventCollector = new Id(this.control.plugin, Math.min(((l = (d = this.control.pluginOptions) == null ? void 0 : d.syncOpt) == null ? void 0 : l.interval) || 100, 100)), this.eventCollector.addStorageStateListener((i) => {
      i.forEach((t, s) => {
        var b;
        if (((b = this.eventCollector) == null ? void 0 : b.uid) !== s) {
          const Z = /* @__PURE__ */ new Map();
          t == null || t.forEach((o) => {
            if (o && o.type === Jd.Cursor && o.op && o.viewId) {
              const G = [];
              for (let y = 0; y < o.op.length; y += 2) {
                const X = o.op[y], W = o.op[y + 1];
                if (td(X) && td(W)) {
                  const h = this.control.viewContainerManager.transformToOriginPoint([X, W], o.viewId);
                  G.push(h[0], h[1]);
                } else
                  G.push(X, W);
              }
              Z.set(o.viewId, G);
            }
          }), Z.size && (this.activePointWorkShape(s, Z), this.runAnimation());
        }
      });
    }));
  }
  onFocusViewChange() {
    const d = this.control.viewContainerManager.focuedViewId;
    for (const i of this.animationDrawWorkers.keys()) {
      const t = this.getUidAndviewId(i).uid, s = this.getUidAndviewId(i).viewId;
      s !== d && this.activeDrawWorkShape(t, [void 0, void 0], hl.Done, s);
    }
    const l = /* @__PURE__ */ new Map();
    for (const i of this.animationPointWorkers.keys()) {
      const t = this.getUidAndviewId(i).uid, s = this.getUidAndviewId(i).viewId;
      if (s !== d) {
        const b = l.get(t) || /* @__PURE__ */ new Map();
        b.set(s, [void 0, void 0]), l.set(t, b);
      }
    }
    if (l.size)
      for (const [i, t] of l.entries())
        this.activePointWorkShape(i, t);
    this.runAnimation();
  }
  activePointWorkShape(d, l) {
    var t;
    if (this.roomMember.getRoomMember(d))
      for (const [s, b] of l.entries()) {
        const Z = this.getKey(d, s);
        let o = !1;
        const G = this.control.viewContainerManager.getAllViews().map((X) => X == null ? void 0 : X.id);
        for (const X of G)
          if (X && X !== s) {
            const W = this.getKey(d, X), h = this.animationDrawWorkers.get(W);
            if ((h == null ? void 0 : h.workState) === hl.Start || (h == null ? void 0 : h.workState) === hl.Doing || !1) {
              o = !0;
              break;
            } else if (this.removeTimerId && (clearTimeout(this.removeTimerId), this.removeTimerId = void 0), h)
              this.activeDrawWorkShape(d, [void 0, void 0], hl.Done, X), this.runAnimation();
            else {
              const L = this.animationPointWorkers.get(W);
              if (L)
                L.animationWorkData = [void 0, void 0], L.animationIndex = 0, L.freeze = !1;
              else {
                const u = {
                  animationIndex: 0,
                  animationWorkData: [void 0, void 0],
                  freeze: !1
                };
                this.animationPointWorkers.set(W, u);
              }
            }
          }
        const y = this.animationPointWorkers.get(Z);
        if (b) {
          if (!y) {
            const X = {
              animationIndex: 0,
              animationWorkData: b,
              freeze: o
            };
            (t = this.animationPointWorkers) == null || t.set(Z, X);
            return;
          }
          y.animationWorkData = b, y.animationIndex = 0, y.freeze = o;
        }
      }
  }
  getKey(d, l) {
    return `${d}${Vd}${l}`;
  }
  getUidAndviewId(d) {
    const [l, i] = d.split(Vd);
    return { uid: l, viewId: i };
  }
  animationCursor() {
    this.animationId = void 0;
    const d = /* @__PURE__ */ new Map();
    this.animationPointWorkers.forEach((l, i) => {
      const { uid: t } = this.getUidAndviewId(i);
      if (l.freeze)
        return;
      const b = l.animationIndex, Z = this.roomMember.getRoomMember(t);
      if (Z) {
        l.animationWorkData.length - 1 > b && (l.animationIndex = b + 2);
        const o = l.animationWorkData[b], G = l.animationWorkData[b + 1];
        d.set(i, {
          x: o,
          y: G,
          roomMember: td(o) && td(G) && Z || void 0
        }), l.animationWorkData.length - 1 <= l.animationIndex && this.animationPointWorkers.delete(i);
      }
    }), this.animationDrawWorkers.forEach((l, i) => {
      const { uid: t } = this.getUidAndviewId(i), s = l.animationIndex, b = this.roomMember.getRoomMember(t);
      if (b) {
        l.animationWorkData.length - 1 > s && (l.animationIndex = s + 2);
        const Z = l.animationWorkData[s], o = l.animationWorkData[s + 1];
        d.set(i, {
          x: Z,
          y: o,
          roomMember: td(Z) && td(o) && b || void 0
        }), l.animationWorkData.length - 1 <= l.animationIndex && this.animationDrawWorkers.delete(i);
      }
    });
    for (const [l, i] of d.entries()) {
      const { viewId: t } = this.getUidAndviewId(l);
      this.control.viewContainerManager.setActiveCursor(t, i);
    }
    (this.animationPointWorkers.size || this.animationDrawWorkers.size) && this.runAnimation();
  }
  activeDrawWorkShape(d, l, i, t) {
    var o, G;
    if (!this.roomMember.getRoomMember(d))
      return;
    const b = this.getKey(d, t);
    if (i === hl.Start) {
      const y = this.animationPointWorkers.get(b);
      if (y)
        y.animationWorkData = [], y.animationIndex = 0, y.freeze = !0;
      else {
        const X = {
          animationIndex: 0,
          animationWorkData: [],
          freeze: !0
        };
        (o = this.animationDrawWorkers) == null || o.set(b, X);
      }
    } else if (i === hl.Done) {
      const y = this.animationPointWorkers.get(b);
      y && (y.freeze = !1);
    }
    const Z = this.animationDrawWorkers.get(b);
    if (l) {
      if (!Z) {
        const y = {
          animationIndex: 0,
          animationWorkData: l,
          workState: i
        };
        (G = this.animationDrawWorkers) == null || G.set(b, y);
        return;
      }
      Z.animationWorkData = l, Z.animationIndex = 0, Z.workState = i;
    }
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.animationCursor.bind(this)));
  }
  sendEvent(d, l) {
    var i;
    (i = this.eventCollector) == null || i.dispatch({
      type: Jd.Cursor,
      op: td(d[0]) && td(d[1]) && this.control.viewContainerManager.transformToScenePoint(d, l) || [void 0, void 0],
      viewId: l
    });
  }
  collectServiceCursor(d) {
    const { op: l, uid: i, workState: t, viewId: s } = d;
    if (i && l && t && s) {
      const b = this.control.viewContainerManager.focuedViewId;
      if (t === hl.Done) {
        if (s !== b) {
          this.activeDrawWorkShape(i, [void 0, void 0], t, s), this.runAnimation();
          return;
        }
        this.removeTimerId && (clearTimeout(this.removeTimerId), this.removeTimerId = void 0, this.asyncEndInfo && this.asyncEndInfo.viewId !== s && this.asyncEndInfo.uid === i && this.activeDrawWorkShape(i, [void 0, void 0], hl.Done, this.asyncEndInfo.viewId)), this.asyncEndInfo = { uid: i, viewId: s }, this.removeTimerId = setTimeout(() => {
          this.removeTimerId = void 0, this.activeDrawWorkShape(i, [void 0, void 0], hl.Done, s), this.runAnimation();
        }, 1e4);
      }
      if (td(l[0]) && td(l[1])) {
        const Z = this.control.viewContainerManager.transformToOriginPoint(l, s);
        this.activeDrawWorkShape(i, Z, t, s);
      }
      this.runAnimation();
    }
  }
  unabled() {
    var d;
    (d = this.eventCollector) == null || d.dispatch({
      type: Jd.Cursor,
      op: [void 0, void 0],
      viewId: this.control.viewContainerManager.focuedViewId
    });
  }
  destroy() {
    var d;
    (d = this.eventCollector) == null || d.destroy();
  }
}
const ys = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBFZT10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIGNlKHUpe3JldHVybiB1JiZ1Ll9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1LCJkZWZhdWx0Iik/dS5kZWZhdWx0OnV9ZnVuY3Rpb24gc2koKXt0aGlzLl9fZGF0YV9fPVtdLHRoaXMuc2l6ZT0wfXZhciBvaT1zaTtmdW5jdGlvbiBhaSh1LGUpe3JldHVybiB1PT09ZXx8dSE9PXUmJmUhPT1lfXZhciBWZT1haSxsaT1WZTtmdW5jdGlvbiBjaSh1LGUpe2Zvcih2YXIgdD11Lmxlbmd0aDt0LS07KWlmKGxpKHVbdF1bMF0sZSkpcmV0dXJuIHQ7cmV0dXJuLTF9dmFyIEFlPWNpLHVpPUFlLGZpPUFycmF5LnByb3RvdHlwZSxoaT1maS5zcGxpY2U7ZnVuY3Rpb24gZGkodSl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PXVpKGUsdSk7aWYodDwwKXJldHVybiExO3ZhciByPWUubGVuZ3RoLTE7cmV0dXJuIHQ9PXI/ZS5wb3AoKTpoaS5jYWxsKGUsdCwxKSwtLXRoaXMuc2l6ZSwhMH12YXIgZ2k9ZGkscGk9QWU7ZnVuY3Rpb24gbWkodSl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PXBpKGUsdSk7cmV0dXJuIHQ8MD92b2lkIDA6ZVt0XVsxXX12YXIgdmk9bWkseWk9QWU7ZnVuY3Rpb24gU2kodSl7cmV0dXJuIHlpKHRoaXMuX19kYXRhX18sdSk+LTF9dmFyIHhpPVNpLE9pPUFlO2Z1bmN0aW9uIGJpKHUsZSl7dmFyIHQ9dGhpcy5fX2RhdGFfXyxyPU9pKHQsdSk7cmV0dXJuIHI8MD8oKyt0aGlzLnNpemUsdC5wdXNoKFt1LGVdKSk6dFtyXVsxXT1lLHRoaXN9dmFyIFBpPWJpLFRpPW9pLE1pPWdpLEVpPXZpLEFpPXhpLENpPVBpO2Z1bmN0aW9uIHVlKHUpe3ZhciBlPS0xLHQ9dT09bnVsbD8wOnUubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj11W2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fXVlLnByb3RvdHlwZS5jbGVhcj1UaSx1ZS5wcm90b3R5cGUuZGVsZXRlPU1pLHVlLnByb3RvdHlwZS5nZXQ9RWksdWUucHJvdG90eXBlLmhhcz1BaSx1ZS5wcm90b3R5cGUuc2V0PUNpO3ZhciBDZT11ZSxSaT1DZTtmdW5jdGlvbiBJaSgpe3RoaXMuX19kYXRhX189bmV3IFJpLHRoaXMuc2l6ZT0wfXZhciBMaT1JaTtmdW5jdGlvbiBEaSh1KXt2YXIgZT10aGlzLl9fZGF0YV9fLHQ9ZS5kZWxldGUodSk7cmV0dXJuIHRoaXMuc2l6ZT1lLnNpemUsdH12YXIgd2k9RGk7ZnVuY3Rpb24gTmkodSl7cmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KHUpfXZhciBCaT1OaTtmdW5jdGlvbiBqaSh1KXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModSl9dmFyIFdpPWppLEZpPXR5cGVvZiBFZT09Im9iamVjdCImJkVlJiZFZS5PYmplY3Q9PT1PYmplY3QmJkVlLHByPUZpLFVpPXByLCRpPXR5cGVvZiBzZWxmPT0ib2JqZWN0IiYmc2VsZiYmc2VsZi5PYmplY3Q9PT1PYmplY3QmJnNlbGYsemk9VWl8fCRpfHxGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpLFp0PXppLEdpPVp0LEhpPUdpLlN5bWJvbCxSZT1IaSxtcj1SZSx2cj1PYmplY3QucHJvdG90eXBlLEtpPXZyLmhhc093blByb3BlcnR5LFZpPXZyLnRvU3RyaW5nLFNlPW1yP21yLnRvU3RyaW5nVGFnOnZvaWQgMDtmdW5jdGlvbiBZaSh1KXt2YXIgZT1LaS5jYWxsKHUsU2UpLHQ9dVtTZV07dHJ5e3VbU2VdPXZvaWQgMDt2YXIgcj0hMH1jYXRjaHt9dmFyIG49VmkuY2FsbCh1KTtyZXR1cm4gciYmKGU/dVtTZV09dDpkZWxldGUgdVtTZV0pLG59dmFyIFhpPVlpLFppPU9iamVjdC5wcm90b3R5cGUsSmk9WmkudG9TdHJpbmc7ZnVuY3Rpb24gUWkodSl7cmV0dXJuIEppLmNhbGwodSl9dmFyIGtpPVFpLHlyPVJlLHFpPVhpLF9pPWtpLHRzPSJbb2JqZWN0IE51bGxdIixlcz0iW29iamVjdCBVbmRlZmluZWRdIixTcj15cj95ci50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24gcnModSl7cmV0dXJuIHU9PW51bGw/dT09PXZvaWQgMD9lczp0czpTciYmU3IgaW4gT2JqZWN0KHUpP3FpKHUpOl9pKHUpfXZhciBpZT1ycztmdW5jdGlvbiBucyh1KXt2YXIgZT10eXBlb2YgdTtyZXR1cm4gdSE9bnVsbCYmKGU9PSJvYmplY3QifHxlPT0iZnVuY3Rpb24iKX12YXIgcmU9bnMsaXM9aWUsc3M9cmUsb3M9IltvYmplY3QgQXN5bmNGdW5jdGlvbl0iLGFzPSJbb2JqZWN0IEZ1bmN0aW9uXSIsbHM9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixjcz0iW29iamVjdCBQcm94eV0iO2Z1bmN0aW9uIHVzKHUpe2lmKCFzcyh1KSlyZXR1cm4hMTt2YXIgZT1pcyh1KTtyZXR1cm4gZT09YXN8fGU9PWxzfHxlPT1vc3x8ZT09Y3N9dmFyIHhyPXVzLGZzPVp0LGhzPWZzWyJfX2NvcmUtanNfc2hhcmVkX18iXSxkcz1ocyxZZT1kcyxPcj1mdW5jdGlvbigpe3ZhciB1PS9bXi5dKyQvLmV4ZWMoWWUmJlllLmtleXMmJlllLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gdT8iU3ltYm9sKHNyYylfMS4iK3U6IiJ9KCk7ZnVuY3Rpb24gZ3ModSl7cmV0dXJuISFPciYmT3IgaW4gdX12YXIgcHM9Z3MsbXM9RnVuY3Rpb24ucHJvdG90eXBlLHZzPW1zLnRvU3RyaW5nO2Z1bmN0aW9uIHlzKHUpe2lmKHUhPW51bGwpe3RyeXtyZXR1cm4gdnMuY2FsbCh1KX1jYXRjaHt9dHJ5e3JldHVybiB1KyIifWNhdGNoe319cmV0dXJuIiJ9dmFyIGJyPXlzLFNzPXhyLHhzPXBzLE9zPXJlLGJzPWJyLFBzPS9bXFxeJC4qKz8oKVtcXXt9fF0vZyxUcz0vXlxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXF0kLyxNcz1GdW5jdGlvbi5wcm90b3R5cGUsRXM9T2JqZWN0LnByb3RvdHlwZSxBcz1Ncy50b1N0cmluZyxDcz1Fcy5oYXNPd25Qcm9wZXJ0eSxScz1SZWdFeHAoIl4iK0FzLmNhbGwoQ3MpLnJlcGxhY2UoUHMsIlxcJCYiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcKCl8IGZvciAuKz8oPz1cXFxdKS9nLCIkMS4qPyIpKyIkIik7ZnVuY3Rpb24gSXModSl7aWYoIU9zKHUpfHx4cyh1KSlyZXR1cm4hMTt2YXIgZT1Tcyh1KT9SczpUcztyZXR1cm4gZS50ZXN0KGJzKHUpKX12YXIgTHM9SXM7ZnVuY3Rpb24gRHModSxlKXtyZXR1cm4gdT09bnVsbD92b2lkIDA6dVtlXX12YXIgd3M9RHMsTnM9THMsQnM9d3M7ZnVuY3Rpb24ganModSxlKXt2YXIgdD1Ccyh1LGUpO3JldHVybiBOcyh0KT90OnZvaWQgMH12YXIgc2U9anMsV3M9c2UsRnM9WnQsVXM9V3MoRnMsIk1hcCIpLFhlPVVzLCRzPXNlLHpzPSRzKE9iamVjdCwiY3JlYXRlIiksSWU9enMsUHI9SWU7ZnVuY3Rpb24gR3MoKXt0aGlzLl9fZGF0YV9fPVByP1ByKG51bGwpOnt9LHRoaXMuc2l6ZT0wfXZhciBIcz1HcztmdW5jdGlvbiBLcyh1KXt2YXIgZT10aGlzLmhhcyh1KSYmZGVsZXRlIHRoaXMuX19kYXRhX19bdV07cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX12YXIgVnM9S3MsWXM9SWUsWHM9Il9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18iLFpzPU9iamVjdC5wcm90b3R5cGUsSnM9WnMuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gUXModSl7dmFyIGU9dGhpcy5fX2RhdGFfXztpZihZcyl7dmFyIHQ9ZVt1XTtyZXR1cm4gdD09PVhzP3ZvaWQgMDp0fXJldHVybiBKcy5jYWxsKGUsdSk/ZVt1XTp2b2lkIDB9dmFyIGtzPVFzLHFzPUllLF9zPU9iamVjdC5wcm90b3R5cGUsdG89X3MuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gZW8odSl7dmFyIGU9dGhpcy5fX2RhdGFfXztyZXR1cm4gcXM/ZVt1XSE9PXZvaWQgMDp0by5jYWxsKGUsdSl9dmFyIHJvPWVvLG5vPUllLGlvPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIjtmdW5jdGlvbiBzbyh1LGUpe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXModSk/MDoxLHRbdV09bm8mJmU9PT12b2lkIDA/aW86ZSx0aGlzfXZhciBvbz1zbyxhbz1Icyxsbz1Wcyxjbz1rcyx1bz1ybyxmbz1vbztmdW5jdGlvbiBmZSh1KXt2YXIgZT0tMSx0PXU9PW51bGw/MDp1Lmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9dVtlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1mZS5wcm90b3R5cGUuY2xlYXI9YW8sZmUucHJvdG90eXBlLmRlbGV0ZT1sbyxmZS5wcm90b3R5cGUuZ2V0PWNvLGZlLnByb3RvdHlwZS5oYXM9dW8sZmUucHJvdG90eXBlLnNldD1mbzt2YXIgaG89ZmUsVHI9aG8sZ289Q2UscG89WGU7ZnVuY3Rpb24gbW8oKXt0aGlzLnNpemU9MCx0aGlzLl9fZGF0YV9fPXtoYXNoOm5ldyBUcixtYXA6bmV3KHBvfHxnbyksc3RyaW5nOm5ldyBUcn19dmFyIHZvPW1vO2Z1bmN0aW9uIHlvKHUpe3ZhciBlPXR5cGVvZiB1O3JldHVybiBlPT0ic3RyaW5nInx8ZT09Im51bWJlciJ8fGU9PSJzeW1ib2wifHxlPT0iYm9vbGVhbiI/dSE9PSJfX3Byb3RvX18iOnU9PT1udWxsfXZhciBTbz15byx4bz1TbztmdW5jdGlvbiBPbyh1LGUpe3ZhciB0PXUuX19kYXRhX187cmV0dXJuIHhvKGUpP3RbdHlwZW9mIGU9PSJzdHJpbmciPyJzdHJpbmciOiJoYXNoIl06dC5tYXB9dmFyIExlPU9vLGJvPUxlO2Z1bmN0aW9uIFBvKHUpe3ZhciBlPWJvKHRoaXMsdSkuZGVsZXRlKHUpO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIFRvPVBvLE1vPUxlO2Z1bmN0aW9uIEVvKHUpe3JldHVybiBNbyh0aGlzLHUpLmdldCh1KX12YXIgQW89RW8sQ289TGU7ZnVuY3Rpb24gUm8odSl7cmV0dXJuIENvKHRoaXMsdSkuaGFzKHUpfXZhciBJbz1SbyxMbz1MZTtmdW5jdGlvbiBEbyh1LGUpe3ZhciB0PUxvKHRoaXMsdSkscj10LnNpemU7cmV0dXJuIHQuc2V0KHUsZSksdGhpcy5zaXplKz10LnNpemU9PXI/MDoxLHRoaXN9dmFyIHdvPURvLE5vPXZvLEJvPVRvLGpvPUFvLFdvPUlvLEZvPXdvO2Z1bmN0aW9uIGhlKHUpe3ZhciBlPS0xLHQ9dT09bnVsbD8wOnUubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj11W2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fWhlLnByb3RvdHlwZS5jbGVhcj1ObyxoZS5wcm90b3R5cGUuZGVsZXRlPUJvLGhlLnByb3RvdHlwZS5nZXQ9am8saGUucHJvdG90eXBlLmhhcz1XbyxoZS5wcm90b3R5cGUuc2V0PUZvO3ZhciBNcj1oZSxVbz1DZSwkbz1YZSx6bz1NcixHbz0yMDA7ZnVuY3Rpb24gSG8odSxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO2lmKHQgaW5zdGFuY2VvZiBVbyl7dmFyIHI9dC5fX2RhdGFfXztpZighJG98fHIubGVuZ3RoPEdvLTEpcmV0dXJuIHIucHVzaChbdSxlXSksdGhpcy5zaXplPSsrdC5zaXplLHRoaXM7dD10aGlzLl9fZGF0YV9fPW5ldyB6byhyKX1yZXR1cm4gdC5zZXQodSxlKSx0aGlzLnNpemU9dC5zaXplLHRoaXN9dmFyIEtvPUhvLFZvPUNlLFlvPUxpLFhvPXdpLFpvPUJpLEpvPVdpLFFvPUtvO2Z1bmN0aW9uIGRlKHUpe3ZhciBlPXRoaXMuX19kYXRhX189bmV3IFZvKHUpO3RoaXMuc2l6ZT1lLnNpemV9ZGUucHJvdG90eXBlLmNsZWFyPVlvLGRlLnByb3RvdHlwZS5kZWxldGU9WG8sZGUucHJvdG90eXBlLmdldD1abyxkZS5wcm90b3R5cGUuaGFzPUpvLGRlLnByb3RvdHlwZS5zZXQ9UW87dmFyIEVyPWRlO2Z1bmN0aW9uIGtvKHUsZSl7Zm9yKHZhciB0PS0xLHI9dT09bnVsbD8wOnUubGVuZ3RoOysrdDxyJiZlKHVbdF0sdCx1KSE9PSExOyk7cmV0dXJuIHV9dmFyIHFvPWtvLF9vPXNlLHRhPWZ1bmN0aW9uKCl7dHJ5e3ZhciB1PV9vKE9iamVjdCwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gdSh7fSwiIix7fSksdX1jYXRjaHt9fSgpLGVhPXRhLEFyPWVhO2Z1bmN0aW9uIHJhKHUsZSx0KXtlPT0iX19wcm90b19fIiYmQXI/QXIodSxlLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0LHdyaXRhYmxlOiEwfSk6dVtlXT10fXZhciBDcj1yYSxuYT1DcixpYT1WZSxzYT1PYmplY3QucHJvdG90eXBlLG9hPXNhLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIGFhKHUsZSx0KXt2YXIgcj11W2VdOyghKG9hLmNhbGwodSxlKSYmaWEocix0KSl8fHQ9PT12b2lkIDAmJiEoZSBpbiB1KSkmJm5hKHUsZSx0KX12YXIgUnI9YWEsbGE9UnIsY2E9Q3I7ZnVuY3Rpb24gdWEodSxlLHQscil7dmFyIG49IXQ7dHx8KHQ9e30pO2Zvcih2YXIgaT0tMSxhPWUubGVuZ3RoOysraTxhOyl7dmFyIGw9ZVtpXSxzPXI/cih0W2xdLHVbbF0sbCx0LHUpOnZvaWQgMDtzPT09dm9pZCAwJiYocz11W2xdKSxuP2NhKHQsbCxzKTpsYSh0LGwscyl9cmV0dXJuIHR9dmFyIERlPXVhO2Z1bmN0aW9uIGZhKHUsZSl7Zm9yKHZhciB0PS0xLHI9QXJyYXkodSk7Kyt0PHU7KXJbdF09ZSh0KTtyZXR1cm4gcn12YXIgaGE9ZmE7ZnVuY3Rpb24gZGEodSl7cmV0dXJuIHUhPW51bGwmJnR5cGVvZiB1PT0ib2JqZWN0In12YXIgX3Q9ZGEsZ2E9aWUscGE9X3QsbWE9IltvYmplY3QgQXJndW1lbnRzXSI7ZnVuY3Rpb24gdmEodSl7cmV0dXJuIHBhKHUpJiZnYSh1KT09bWF9dmFyIHlhPXZhLElyPXlhLFNhPV90LExyPU9iamVjdC5wcm90b3R5cGUseGE9THIuaGFzT3duUHJvcGVydHksT2E9THIucHJvcGVydHlJc0VudW1lcmFibGUsYmE9SXIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT9JcjpmdW5jdGlvbih1KXtyZXR1cm4gU2EodSkmJnhhLmNhbGwodSwiY2FsbGVlIikmJiFPYS5jYWxsKHUsImNhbGxlZSIpfSxQYT1iYSxUYT1BcnJheS5pc0FycmF5LHdlPVRhLE5lPXtleHBvcnRzOnt9fTtmdW5jdGlvbiBNYSgpe3JldHVybiExfXZhciBFYT1NYTtOZS5leHBvcnRzLGZ1bmN0aW9uKHUsZSl7dmFyIHQ9WnQscj1FYSxuPWUmJiFlLm5vZGVUeXBlJiZlLGk9biYmITAmJnUmJiF1Lm5vZGVUeXBlJiZ1LGE9aSYmaS5leHBvcnRzPT09bixsPWE/dC5CdWZmZXI6dm9pZCAwLHM9bD9sLmlzQnVmZmVyOnZvaWQgMCxmPXN8fHI7dS5leHBvcnRzPWZ9KE5lLE5lLmV4cG9ydHMpO3ZhciBaZT1OZS5leHBvcnRzLEFhPTkwMDcxOTkyNTQ3NDA5OTEsQ2E9L14oPzowfFsxLTldXGQqKSQvO2Z1bmN0aW9uIFJhKHUsZSl7dmFyIHQ9dHlwZW9mIHU7cmV0dXJuIGU9ZT8/QWEsISFlJiYodD09Im51bWJlciJ8fHQhPSJzeW1ib2wiJiZDYS50ZXN0KHUpKSYmdT4tMSYmdSUxPT0wJiZ1PGV9dmFyIElhPVJhLExhPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24gRGEodSl7cmV0dXJuIHR5cGVvZiB1PT0ibnVtYmVyIiYmdT4tMSYmdSUxPT0wJiZ1PD1MYX12YXIgRHI9RGEsd2E9aWUsTmE9RHIsQmE9X3QsamE9IltvYmplY3QgQXJndW1lbnRzXSIsV2E9IltvYmplY3QgQXJyYXldIixGYT0iW29iamVjdCBCb29sZWFuXSIsVWE9IltvYmplY3QgRGF0ZV0iLCRhPSJbb2JqZWN0IEVycm9yXSIsemE9IltvYmplY3QgRnVuY3Rpb25dIixHYT0iW29iamVjdCBNYXBdIixIYT0iW29iamVjdCBOdW1iZXJdIixLYT0iW29iamVjdCBPYmplY3RdIixWYT0iW29iamVjdCBSZWdFeHBdIixZYT0iW29iamVjdCBTZXRdIixYYT0iW29iamVjdCBTdHJpbmddIixaYT0iW29iamVjdCBXZWFrTWFwXSIsSmE9IltvYmplY3QgQXJyYXlCdWZmZXJdIixRYT0iW29iamVjdCBEYXRhVmlld10iLGthPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLHFhPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLF9hPSJbb2JqZWN0IEludDhBcnJheV0iLHRsPSJbb2JqZWN0IEludDE2QXJyYXldIixlbD0iW29iamVjdCBJbnQzMkFycmF5XSIscmw9IltvYmplY3QgVWludDhBcnJheV0iLG5sPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsaWw9IltvYmplY3QgVWludDE2QXJyYXldIixzbD0iW29iamVjdCBVaW50MzJBcnJheV0iLEJ0PXt9O0J0W2thXT1CdFtxYV09QnRbX2FdPUJ0W3RsXT1CdFtlbF09QnRbcmxdPUJ0W25sXT1CdFtpbF09QnRbc2xdPSEwLEJ0W2phXT1CdFtXYV09QnRbSmFdPUJ0W0ZhXT1CdFtRYV09QnRbVWFdPUJ0WyRhXT1CdFt6YV09QnRbR2FdPUJ0W0hhXT1CdFtLYV09QnRbVmFdPUJ0W1lhXT1CdFtYYV09QnRbWmFdPSExO2Z1bmN0aW9uIG9sKHUpe3JldHVybiBCYSh1KSYmTmEodS5sZW5ndGgpJiYhIUJ0W3dhKHUpXX12YXIgYWw9b2w7ZnVuY3Rpb24gbGwodSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB1KGUpfX12YXIgSmU9bGwsQmU9e2V4cG9ydHM6e319O0JlLmV4cG9ydHMsZnVuY3Rpb24odSxlKXt2YXIgdD1wcixyPWUmJiFlLm5vZGVUeXBlJiZlLG49ciYmITAmJnUmJiF1Lm5vZGVUeXBlJiZ1LGk9biYmbi5leHBvcnRzPT09cixhPWkmJnQucHJvY2VzcyxsPWZ1bmN0aW9uKCl7dHJ5e3ZhciBzPW4mJm4ucmVxdWlyZSYmbi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7cmV0dXJuIHN8fGEmJmEuYmluZGluZyYmYS5iaW5kaW5nKCJ1dGlsIil9Y2F0Y2h7fX0oKTt1LmV4cG9ydHM9bH0oQmUsQmUuZXhwb3J0cyk7dmFyIFFlPUJlLmV4cG9ydHMsY2w9YWwsdWw9SmUsd3I9UWUsTnI9d3ImJndyLmlzVHlwZWRBcnJheSxmbD1Ocj91bChOcik6Y2wsQnI9ZmwsaGw9aGEsZGw9UGEsZ2w9d2UscGw9WmUsbWw9SWEsdmw9QnIseWw9T2JqZWN0LnByb3RvdHlwZSxTbD15bC5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiB4bCh1LGUpe3ZhciB0PWdsKHUpLHI9IXQmJmRsKHUpLG49IXQmJiFyJiZwbCh1KSxpPSF0JiYhciYmIW4mJnZsKHUpLGE9dHx8cnx8bnx8aSxsPWE/aGwodS5sZW5ndGgsU3RyaW5nKTpbXSxzPWwubGVuZ3RoO2Zvcih2YXIgZiBpbiB1KShlfHxTbC5jYWxsKHUsZikpJiYhKGEmJihmPT0ibGVuZ3RoInx8biYmKGY9PSJvZmZzZXQifHxmPT0icGFyZW50Iil8fGkmJihmPT0iYnVmZmVyInx8Zj09ImJ5dGVMZW5ndGgifHxmPT0iYnl0ZU9mZnNldCIpfHxtbChmLHMpKSkmJmwucHVzaChmKTtyZXR1cm4gbH12YXIganI9eGwsT2w9T2JqZWN0LnByb3RvdHlwZTtmdW5jdGlvbiBibCh1KXt2YXIgZT11JiZ1LmNvbnN0cnVjdG9yLHQ9dHlwZW9mIGU9PSJmdW5jdGlvbiImJmUucHJvdG90eXBlfHxPbDtyZXR1cm4gdT09PXR9dmFyIGtlPWJsO2Z1bmN0aW9uIFBsKHUsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiB1KGUodCkpfX12YXIgV3I9UGwsVGw9V3IsTWw9VGwoT2JqZWN0LmtleXMsT2JqZWN0KSxFbD1NbCxBbD1rZSxDbD1FbCxSbD1PYmplY3QucHJvdG90eXBlLElsPVJsLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIExsKHUpe2lmKCFBbCh1KSlyZXR1cm4gQ2wodSk7dmFyIGU9W107Zm9yKHZhciB0IGluIE9iamVjdCh1KSlJbC5jYWxsKHUsdCkmJnQhPSJjb25zdHJ1Y3RvciImJmUucHVzaCh0KTtyZXR1cm4gZX12YXIgRGw9TGwsd2w9eHIsTmw9RHI7ZnVuY3Rpb24gQmwodSl7cmV0dXJuIHUhPW51bGwmJk5sKHUubGVuZ3RoKSYmIXdsKHUpfXZhciBGcj1CbCxqbD1qcixXbD1EbCxGbD1GcjtmdW5jdGlvbiBVbCh1KXtyZXR1cm4gRmwodSk/amwodSk6V2wodSl9dmFyIHFlPVVsLCRsPURlLHpsPXFlO2Z1bmN0aW9uIEdsKHUsZSl7cmV0dXJuIHUmJiRsKGUsemwoZSksdSl9dmFyIEhsPUdsO2Z1bmN0aW9uIEtsKHUpe3ZhciBlPVtdO2lmKHUhPW51bGwpZm9yKHZhciB0IGluIE9iamVjdCh1KSllLnB1c2godCk7cmV0dXJuIGV9dmFyIFZsPUtsLFlsPXJlLFhsPWtlLFpsPVZsLEpsPU9iamVjdC5wcm90b3R5cGUsUWw9SmwuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24ga2wodSl7aWYoIVlsKHUpKXJldHVybiBabCh1KTt2YXIgZT1YbCh1KSx0PVtdO2Zvcih2YXIgciBpbiB1KXI9PSJjb25zdHJ1Y3RvciImJihlfHwhUWwuY2FsbCh1LHIpKXx8dC5wdXNoKHIpO3JldHVybiB0fXZhciBxbD1rbCxfbD1qcix0Yz1xbCxlYz1GcjtmdW5jdGlvbiByYyh1KXtyZXR1cm4gZWModSk/X2wodSwhMCk6dGModSl9dmFyIF9lPXJjLG5jPURlLGljPV9lO2Z1bmN0aW9uIHNjKHUsZSl7cmV0dXJuIHUmJm5jKGUsaWMoZSksdSl9dmFyIG9jPXNjLGplPXtleHBvcnRzOnt9fTtqZS5leHBvcnRzLGZ1bmN0aW9uKHUsZSl7dmFyIHQ9WnQscj1lJiYhZS5ub2RlVHlwZSYmZSxuPXImJiEwJiZ1JiYhdS5ub2RlVHlwZSYmdSxpPW4mJm4uZXhwb3J0cz09PXIsYT1pP3QuQnVmZmVyOnZvaWQgMCxsPWE/YS5hbGxvY1Vuc2FmZTp2b2lkIDA7ZnVuY3Rpb24gcyhmLHYpe2lmKHYpcmV0dXJuIGYuc2xpY2UoKTt2YXIgZD1mLmxlbmd0aCxwPWw/bChkKTpuZXcgZi5jb25zdHJ1Y3RvcihkKTtyZXR1cm4gZi5jb3B5KHApLHB9dS5leHBvcnRzPXN9KGplLGplLmV4cG9ydHMpO3ZhciBhYz1qZS5leHBvcnRzO2Z1bmN0aW9uIGxjKHUsZSl7dmFyIHQ9LTEscj11Lmxlbmd0aDtmb3IoZXx8KGU9QXJyYXkocikpOysrdDxyOyllW3RdPXVbdF07cmV0dXJuIGV9dmFyIGNjPWxjO2Z1bmN0aW9uIHVjKHUsZSl7Zm9yKHZhciB0PS0xLHI9dT09bnVsbD8wOnUubGVuZ3RoLG49MCxpPVtdOysrdDxyOyl7dmFyIGE9dVt0XTtlKGEsdCx1KSYmKGlbbisrXT1hKX1yZXR1cm4gaX12YXIgZmM9dWM7ZnVuY3Rpb24gaGMoKXtyZXR1cm5bXX12YXIgVXI9aGMsZGM9ZmMsZ2M9VXIscGM9T2JqZWN0LnByb3RvdHlwZSxtYz1wYy5wcm9wZXJ0eUlzRW51bWVyYWJsZSwkcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLHZjPSRyP2Z1bmN0aW9uKHUpe3JldHVybiB1PT1udWxsP1tdOih1PU9iamVjdCh1KSxkYygkcih1KSxmdW5jdGlvbihlKXtyZXR1cm4gbWMuY2FsbCh1LGUpfSkpfTpnYyx0cj12Yyx5Yz1EZSxTYz10cjtmdW5jdGlvbiB4Yyh1LGUpe3JldHVybiB5Yyh1LFNjKHUpLGUpfXZhciBPYz14YztmdW5jdGlvbiBiYyh1LGUpe2Zvcih2YXIgdD0tMSxyPWUubGVuZ3RoLG49dS5sZW5ndGg7Kyt0PHI7KXVbbit0XT1lW3RdO3JldHVybiB1fXZhciB6cj1iYyxQYz1XcixUYz1QYyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KSxHcj1UYyxNYz16cixFYz1HcixBYz10cixDYz1VcixSYz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLEljPVJjP2Z1bmN0aW9uKHUpe2Zvcih2YXIgZT1bXTt1OylNYyhlLEFjKHUpKSx1PUVjKHUpO3JldHVybiBlfTpDYyxIcj1JYyxMYz1EZSxEYz1IcjtmdW5jdGlvbiB3Yyh1LGUpe3JldHVybiBMYyh1LERjKHUpLGUpfXZhciBOYz13YyxCYz16cixqYz13ZTtmdW5jdGlvbiBXYyh1LGUsdCl7dmFyIHI9ZSh1KTtyZXR1cm4gamModSk/cjpCYyhyLHQodSkpfXZhciBLcj1XYyxGYz1LcixVYz10ciwkYz1xZTtmdW5jdGlvbiB6Yyh1KXtyZXR1cm4gRmModSwkYyxVYyl9dmFyIFZyPXpjLEdjPUtyLEhjPUhyLEtjPV9lO2Z1bmN0aW9uIFZjKHUpe3JldHVybiBHYyh1LEtjLEhjKX12YXIgWWM9VmMsWGM9c2UsWmM9WnQsSmM9WGMoWmMsIkRhdGFWaWV3IiksUWM9SmMsa2M9c2UscWM9WnQsX2M9a2MocWMsIlByb21pc2UiKSx0dT1fYyxldT1zZSxydT1adCxudT1ldShydSwiU2V0IiksaXU9bnUsc3U9c2Usb3U9WnQsYXU9c3Uob3UsIldlYWtNYXAiKSxsdT1hdSxlcj1RYyxycj1YZSxucj10dSxpcj1pdSxzcj1sdSxZcj1pZSxnZT1icixYcj0iW29iamVjdCBNYXBdIixjdT0iW29iamVjdCBPYmplY3RdIixacj0iW29iamVjdCBQcm9taXNlXSIsSnI9IltvYmplY3QgU2V0XSIsUXI9IltvYmplY3QgV2Vha01hcF0iLGtyPSJbb2JqZWN0IERhdGFWaWV3XSIsdXU9Z2UoZXIpLGZ1PWdlKHJyKSxodT1nZShuciksZHU9Z2UoaXIpLGd1PWdlKHNyKSxvZT1ZcjsoZXImJm9lKG5ldyBlcihuZXcgQXJyYXlCdWZmZXIoMSkpKSE9a3J8fHJyJiZvZShuZXcgcnIpIT1Ycnx8bnImJm9lKG5yLnJlc29sdmUoKSkhPVpyfHxpciYmb2UobmV3IGlyKSE9SnJ8fHNyJiZvZShuZXcgc3IpIT1RcikmJihvZT1mdW5jdGlvbih1KXt2YXIgZT1Zcih1KSx0PWU9PWN1P3UuY29uc3RydWN0b3I6dm9pZCAwLHI9dD9nZSh0KToiIjtpZihyKXN3aXRjaChyKXtjYXNlIHV1OnJldHVybiBrcjtjYXNlIGZ1OnJldHVybiBYcjtjYXNlIGh1OnJldHVybiBacjtjYXNlIGR1OnJldHVybiBKcjtjYXNlIGd1OnJldHVybiBRcn1yZXR1cm4gZX0pO3ZhciBXZT1vZSxwdT1PYmplY3QucHJvdG90eXBlLG11PXB1Lmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHZ1KHUpe3ZhciBlPXUubGVuZ3RoLHQ9bmV3IHUuY29uc3RydWN0b3IoZSk7cmV0dXJuIGUmJnR5cGVvZiB1WzBdPT0ic3RyaW5nIiYmbXUuY2FsbCh1LCJpbmRleCIpJiYodC5pbmRleD11LmluZGV4LHQuaW5wdXQ9dS5pbnB1dCksdH12YXIgeXU9dnUsU3U9WnQseHU9U3UuVWludDhBcnJheSxxcj14dSxfcj1xcjtmdW5jdGlvbiBPdSh1KXt2YXIgZT1uZXcgdS5jb25zdHJ1Y3Rvcih1LmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgX3IoZSkuc2V0KG5ldyBfcih1KSksZX12YXIgb3I9T3UsYnU9b3I7ZnVuY3Rpb24gUHUodSxlKXt2YXIgdD1lP2J1KHUuYnVmZmVyKTp1LmJ1ZmZlcjtyZXR1cm4gbmV3IHUuY29uc3RydWN0b3IodCx1LmJ5dGVPZmZzZXQsdS5ieXRlTGVuZ3RoKX12YXIgVHU9UHUsTXU9L1x3KiQvO2Z1bmN0aW9uIEV1KHUpe3ZhciBlPW5ldyB1LmNvbnN0cnVjdG9yKHUuc291cmNlLE11LmV4ZWModSkpO3JldHVybiBlLmxhc3RJbmRleD11Lmxhc3RJbmRleCxlfXZhciBBdT1FdSx0bj1SZSxlbj10bj90bi5wcm90b3R5cGU6dm9pZCAwLHJuPWVuP2VuLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIEN1KHUpe3JldHVybiBybj9PYmplY3Qocm4uY2FsbCh1KSk6e319dmFyIFJ1PUN1LEl1PW9yO2Z1bmN0aW9uIEx1KHUsZSl7dmFyIHQ9ZT9JdSh1LmJ1ZmZlcik6dS5idWZmZXI7cmV0dXJuIG5ldyB1LmNvbnN0cnVjdG9yKHQsdS5ieXRlT2Zmc2V0LHUubGVuZ3RoKX12YXIgRHU9THUsd3U9b3IsTnU9VHUsQnU9QXUsanU9UnUsV3U9RHUsRnU9IltvYmplY3QgQm9vbGVhbl0iLFV1PSJbb2JqZWN0IERhdGVdIiwkdT0iW29iamVjdCBNYXBdIix6dT0iW29iamVjdCBOdW1iZXJdIixHdT0iW29iamVjdCBSZWdFeHBdIixIdT0iW29iamVjdCBTZXRdIixLdT0iW29iamVjdCBTdHJpbmddIixWdT0iW29iamVjdCBTeW1ib2xdIixZdT0iW29iamVjdCBBcnJheUJ1ZmZlcl0iLFh1PSJbb2JqZWN0IERhdGFWaWV3XSIsWnU9IltvYmplY3QgRmxvYXQzMkFycmF5XSIsSnU9IltvYmplY3QgRmxvYXQ2NEFycmF5XSIsUXU9IltvYmplY3QgSW50OEFycmF5XSIsa3U9IltvYmplY3QgSW50MTZBcnJheV0iLHF1PSJbb2JqZWN0IEludDMyQXJyYXldIixfdT0iW29iamVjdCBVaW50OEFycmF5XSIsdGY9IltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIixlZj0iW29iamVjdCBVaW50MTZBcnJheV0iLHJmPSJbb2JqZWN0IFVpbnQzMkFycmF5XSI7ZnVuY3Rpb24gbmYodSxlLHQpe3ZhciByPXUuY29uc3RydWN0b3I7c3dpdGNoKGUpe2Nhc2UgWXU6cmV0dXJuIHd1KHUpO2Nhc2UgRnU6Y2FzZSBVdTpyZXR1cm4gbmV3IHIoK3UpO2Nhc2UgWHU6cmV0dXJuIE51KHUsdCk7Y2FzZSBadTpjYXNlIEp1OmNhc2UgUXU6Y2FzZSBrdTpjYXNlIHF1OmNhc2UgX3U6Y2FzZSB0ZjpjYXNlIGVmOmNhc2UgcmY6cmV0dXJuIFd1KHUsdCk7Y2FzZSAkdTpyZXR1cm4gbmV3IHI7Y2FzZSB6dTpjYXNlIEt1OnJldHVybiBuZXcgcih1KTtjYXNlIEd1OnJldHVybiBCdSh1KTtjYXNlIEh1OnJldHVybiBuZXcgcjtjYXNlIFZ1OnJldHVybiBqdSh1KX19dmFyIHNmPW5mLG9mPXJlLG5uPU9iamVjdC5jcmVhdGUsYWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB1KCl7fXJldHVybiBmdW5jdGlvbihlKXtpZighb2YoZSkpcmV0dXJue307aWYobm4pcmV0dXJuIG5uKGUpO3UucHJvdG90eXBlPWU7dmFyIHQ9bmV3IHU7cmV0dXJuIHUucHJvdG90eXBlPXZvaWQgMCx0fX0oKSxsZj1hZixjZj1sZix1Zj1HcixmZj1rZTtmdW5jdGlvbiBoZih1KXtyZXR1cm4gdHlwZW9mIHUuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiFmZih1KT9jZih1Zih1KSk6e319dmFyIGRmPWhmLGdmPVdlLHBmPV90LG1mPSJbb2JqZWN0IE1hcF0iO2Z1bmN0aW9uIHZmKHUpe3JldHVybiBwZih1KSYmZ2YodSk9PW1mfXZhciB5Zj12ZixTZj15Zix4Zj1KZSxzbj1RZSxvbj1zbiYmc24uaXNNYXAsT2Y9b24/eGYob24pOlNmLGJmPU9mLFBmPVdlLFRmPV90LE1mPSJbb2JqZWN0IFNldF0iO2Z1bmN0aW9uIEVmKHUpe3JldHVybiBUZih1KSYmUGYodSk9PU1mfXZhciBBZj1FZixDZj1BZixSZj1KZSxhbj1RZSxsbj1hbiYmYW4uaXNTZXQsSWY9bG4/UmYobG4pOkNmLExmPUlmLERmPUVyLHdmPXFvLE5mPVJyLEJmPUhsLGpmPW9jLFdmPWFjLEZmPWNjLFVmPU9jLCRmPU5jLHpmPVZyLEdmPVljLEhmPVdlLEtmPXl1LFZmPXNmLFlmPWRmLFhmPXdlLFpmPVplLEpmPWJmLFFmPXJlLGtmPUxmLHFmPXFlLF9mPV9lLHRoPTEsZWg9MixyaD00LGNuPSJbb2JqZWN0IEFyZ3VtZW50c10iLG5oPSJbb2JqZWN0IEFycmF5XSIsaWg9IltvYmplY3QgQm9vbGVhbl0iLHNoPSJbb2JqZWN0IERhdGVdIixvaD0iW29iamVjdCBFcnJvcl0iLHVuPSJbb2JqZWN0IEZ1bmN0aW9uXSIsYWg9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixsaD0iW29iamVjdCBNYXBdIixjaD0iW29iamVjdCBOdW1iZXJdIixmbj0iW29iamVjdCBPYmplY3RdIix1aD0iW29iamVjdCBSZWdFeHBdIixmaD0iW29iamVjdCBTZXRdIixoaD0iW29iamVjdCBTdHJpbmddIixkaD0iW29iamVjdCBTeW1ib2xdIixnaD0iW29iamVjdCBXZWFrTWFwXSIscGg9IltvYmplY3QgQXJyYXlCdWZmZXJdIixtaD0iW29iamVjdCBEYXRhVmlld10iLHZoPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLHloPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFNoPSJbb2JqZWN0IEludDhBcnJheV0iLHhoPSJbb2JqZWN0IEludDE2QXJyYXldIixPaD0iW29iamVjdCBJbnQzMkFycmF5XSIsYmg9IltvYmplY3QgVWludDhBcnJheV0iLFBoPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsVGg9IltvYmplY3QgVWludDE2QXJyYXldIixNaD0iW29iamVjdCBVaW50MzJBcnJheV0iLHd0PXt9O3d0W2NuXT13dFtuaF09d3RbcGhdPXd0W21oXT13dFtpaF09d3Rbc2hdPXd0W3ZoXT13dFt5aF09d3RbU2hdPXd0W3hoXT13dFtPaF09d3RbbGhdPXd0W2NoXT13dFtmbl09d3RbdWhdPXd0W2ZoXT13dFtoaF09d3RbZGhdPXd0W2JoXT13dFtQaF09d3RbVGhdPXd0W01oXT0hMCx3dFtvaF09d3RbdW5dPXd0W2doXT0hMTtmdW5jdGlvbiBGZSh1LGUsdCxyLG4saSl7dmFyIGEsbD1lJnRoLHM9ZSZlaCxmPWUmcmg7aWYodCYmKGE9bj90KHUscixuLGkpOnQodSkpLGEhPT12b2lkIDApcmV0dXJuIGE7aWYoIVFmKHUpKXJldHVybiB1O3ZhciB2PVhmKHUpO2lmKHYpe2lmKGE9S2YodSksIWwpcmV0dXJuIEZmKHUsYSl9ZWxzZXt2YXIgZD1IZih1KSxwPWQ9PXVufHxkPT1haDtpZihaZih1KSlyZXR1cm4gV2YodSxsKTtpZihkPT1mbnx8ZD09Y258fHAmJiFuKXtpZihhPXN8fHA/e306WWYodSksIWwpcmV0dXJuIHM/JGYodSxqZihhLHUpKTpVZih1LEJmKGEsdSkpfWVsc2V7aWYoIXd0W2RdKXJldHVybiBuP3U6e307YT1WZih1LGQsbCl9fWl8fChpPW5ldyBEZik7dmFyIHk9aS5nZXQodSk7aWYoeSlyZXR1cm4geTtpLnNldCh1LGEpLGtmKHUpP3UuZm9yRWFjaChmdW5jdGlvbihtKXthLmFkZChGZShtLGUsdCxtLHUsaSkpfSk6SmYodSkmJnUuZm9yRWFjaChmdW5jdGlvbihtLE8pe2Euc2V0KE8sRmUobSxlLHQsTyx1LGkpKX0pO3ZhciBQPWY/cz9HZjp6ZjpzP19mOnFmLHg9dj92b2lkIDA6UCh1KTtyZXR1cm4gd2YoeHx8dSxmdW5jdGlvbihtLE8pe3gmJihPPW0sbT11W09dKSxOZihhLE8sRmUobSxlLHQsTyx1LGkpKX0pLGF9dmFyIEVoPUZlLEFoPUVoLENoPTEsUmg9NDtmdW5jdGlvbiBJaCh1KXtyZXR1cm4gQWgodSxDaHxSaCl9dmFyIExoPUloLFl0PWNlKExoKSxobjsoZnVuY3Rpb24odSl7dVt1LnBlZGRpbmc9MF09InBlZGRpbmciLHVbdS5tb3VudGVkPTFdPSJtb3VudGVkIix1W3UudXBkYXRlPTJdPSJ1cGRhdGUiLHVbdS51bm1vdW50ZWQ9M109InVubW91bnRlZCJ9KShobnx8KGhuPXt9KSk7dmFyIHp0OyhmdW5jdGlvbih1KXt1W3UuTm9ybWFsPTBdPSJOb3JtYWwiLHVbdS5TdHJva2U9MV09IlN0cm9rZSIsdVt1LkRvdHRlZD0yXT0iRG90dGVkIix1W3UuTG9uZ0RvdHRlZD0zXT0iTG9uZ0RvdHRlZCJ9KSh6dHx8KHp0PXt9KSk7dmFyIGRuOyhmdW5jdGlvbih1KXt1LlRyaWFuZ2xlPSJ0cmlhbmdsZSIsdS5SaG9tYnVzPSJyaG9tYnVzIix1LlBlbnRhZ3JhbT0icGVudGFncmFtIix1LlNwZWVjaEJhbGxvb249InNwZWVjaEJhbGxvb24iLHUuU3Rhcj0ic3RhciIsdS5Qb2x5Z29uPSJwb2x5Z29uIn0pKGRufHwoZG49e30pKTt2YXIgQ3Q7KGZ1bmN0aW9uKHUpe3UuTm9uZT0iTm9uZSIsdS5TaG93RmxvYXRCYXI9IlNob3dGbG9hdEJhciIsdS5aSW5kZXhGbG9hdEJhcj0iWkluZGV4RmxvYXRCYXIiLHUuRGVsZXRlTm9kZT0iRGVsZXRlTm9kZSIsdS5Db3B5Tm9kZT0iQ29weU5vZGUiLHUuWkluZGV4QWN0aXZlPSJaSW5kZXhBY3RpdmUiLHUuWkluZGV4Tm9kZT0iWkluZGV4Tm9kZSIsdS5Sb3RhdGVOb2RlPSJSb3RhdGVOb2RlIix1LlNldENvbG9yTm9kZT0iU2V0Q29sb3JOb2RlIix1LlRyYW5zbGF0ZU5vZGU9IlRyYW5zbGF0ZU5vZGUiLHUuU2NhbGVOb2RlPSJTY2FsZU5vZGUiLHUuT3JpZ2luYWxFdmVudD0iT3JpZ2luYWxFdmVudCIsdS5DcmVhdGVTY2VuZT0iQ3JlYXRlU2NlbmUiLHUuQWN0aXZlQ3Vyc29yPSJBY3RpdmVDdXJzb3IiLHUuTW92ZUN1cnNvcj0iTW92ZUN1cnNvciIsdS5Db21tYW5kRWRpdG9yPSJDb21tYW5kRWRpdG9yIix1LlNldEVkaXRvckRhdGE9IlNldEVkaXRvckRhdGEiLHUuU2V0Rm9udFN0eWxlPSJTZXRGb250U3R5bGUiLHUuU2V0UG9pbnQ9IlNldFBvaW50Iix1LlNldExvY2s9IlNldExvY2siLHUuU2V0U2hhcGVPcHQ9IlNldFNoYXBlT3B0In0pKEN0fHwoQ3Q9e30pKTt2YXIgZ247KGZ1bmN0aW9uKHUpe3UuRGlzcGxheVN0YXRlPSJEaXNwbGF5U3RhdGUiLHUuRmxvYXRCYXI9IkZsb2F0QmFyIix1LkNhbnZhc1NlbGVjdG9yPSJDYW52YXNTZWxlY3RvciIsdS5NYWluRW5naW5lPSJNYWluRW5naW5lIix1LkRpc3BsYXlDb250YWluZXI9IkRpc3BsYXlDb250YWluZXIiLHUuQ3Vyc29yPSJDdXJzb3IiLHUuVGV4dEVkaXRvcj0iVGV4dEVkaXRvciIsdS5CaW5kTWFpblZpZXc9IkJpbmRNYWluVmlldyIsdS5Nb3VudE1haW5WaWV3PSJNb3VudE1haW5WaWV3Iix1Lk1vdW50QXBwVmlldz0iTW91bnRBcHBWaWV3In0pKGdufHwoZ249e30pKTt2YXIgcG47KGZ1bmN0aW9uKHUpe3VbdS5NYWluVmlldz0wXT0iTWFpblZpZXciLHVbdS5QbHVnaW49MV09IlBsdWdpbiIsdVt1LkJvdGg9Ml09IkJvdGgifSkocG58fChwbj17fSkpO3ZhciBkdDsoZnVuY3Rpb24odSl7dVt1LlBlbmNpbD0xXT0iUGVuY2lsIix1W3UuRXJhc2VyPTJdPSJFcmFzZXIiLHVbdS5TZWxlY3Rvcj0zXT0iU2VsZWN0b3IiLHVbdS5DbGlja2VyPTRdPSJDbGlja2VyIix1W3UuQXJyb3c9NV09IkFycm93Iix1W3UuSGFuZD02XT0iSGFuZCIsdVt1Lkxhc2VyUGVuPTddPSJMYXNlclBlbiIsdVt1LlRleHQ9OF09IlRleHQiLHVbdS5TdHJhaWdodD05XT0iU3RyYWlnaHQiLHVbdS5SZWN0YW5nbGU9MTBdPSJSZWN0YW5nbGUiLHVbdS5FbGxpcHNlPTExXT0iRWxsaXBzZSIsdVt1LlN0YXI9MTJdPSJTdGFyIix1W3UuVHJpYW5nbGU9MTNdPSJUcmlhbmdsZSIsdVt1LlJob21idXM9MTRdPSJSaG9tYnVzIix1W3UuUG9seWdvbj0xNV09IlBvbHlnb24iLHVbdS5TcGVlY2hCYWxsb29uPTE2XT0iU3BlZWNoQmFsbG9vbiIsdVt1LkltYWdlPTE3XT0iSW1hZ2UifSkoZHR8fChkdD17fSkpO3ZhciBPdDsoZnVuY3Rpb24odSl7dVt1LkxvY2FsPTFdPSJMb2NhbCIsdVt1LlNlcnZpY2U9Ml09IlNlcnZpY2UiLHVbdS5Xb3JrZXI9M109IldvcmtlciJ9KShPdHx8KE90PXt9KSk7dmFyIFJ0OyhmdW5jdGlvbih1KXt1W3UuUGVuZGluZz0wXT0iUGVuZGluZyIsdVt1LlN0YXJ0PTFdPSJTdGFydCIsdVt1LkRvaW5nPTJdPSJEb2luZyIsdVt1LkRvbmU9M109IkRvbmUiLHVbdS5GcmVlemU9NF09IkZyZWV6ZSIsdVt1LlVud3JpdGFibGU9NV09IlVud3JpdGFibGUifSkoUnR8fChSdD17fSkpO3ZhciBhdDsoZnVuY3Rpb24odSl7dVt1Lk5vbmU9MF09Ik5vbmUiLHVbdS5Jbml0PTFdPSJJbml0Iix1W3UuVXBkYXRlQ2FtZXJhPTJdPSJVcGRhdGVDYW1lcmEiLHVbdS5VcGRhdGVUb29scz0zXT0iVXBkYXRlVG9vbHMiLHVbdS5DcmVhdGVXb3JrPTRdPSJDcmVhdGVXb3JrIix1W3UuRHJhd1dvcms9NV09IkRyYXdXb3JrIix1W3UuRnVsbFdvcms9Nl09IkZ1bGxXb3JrIix1W3UuVXBkYXRlTm9kZT03XT0iVXBkYXRlTm9kZSIsdVt1LlJlbW92ZU5vZGU9OF09IlJlbW92ZU5vZGUiLHVbdS5DbGVhcj05XT0iQ2xlYXIiLHVbdS5TZWxlY3Q9MTBdPSJTZWxlY3QiLHVbdS5EZXN0cm95PTExXT0iRGVzdHJveSIsdVt1LlNuYXBzaG90PTEyXT0iU25hcHNob3QiLHVbdS5Cb3VuZGluZ0JveD0xM109IkJvdW5kaW5nQm94Iix1W3UuQ3Vyc29yPTE0XT0iQ3Vyc29yIix1W3UuVGV4dFVwZGF0ZT0xNV09IlRleHRVcGRhdGUiLHVbdS5HZXRUZXh0QWN0aXZlPTE2XT0iR2V0VGV4dEFjdGl2ZSIsdVt1LlRhc2tzUXVldWU9MTddPSJUYXNrc1F1ZXVlIix1W3UuQ3Vyc29ySG92ZXI9MThdPSJDdXJzb3JIb3ZlciJ9KShhdHx8KGF0PXt9KSk7dmFyIG1uOyhmdW5jdGlvbih1KXt1LldlYmdsMj0id2ViZ2wyIix1LldlYmdsPSJ3ZWJnbCIsdS5DYW52YXMyZD0iMmQifSkobW58fChtbj17fSkpO3ZhciB5dDsoZnVuY3Rpb24odSl7dVt1LkZsb2F0PTFdPSJGbG9hdCIsdVt1LkJnPTJdPSJCZyIsdVt1LlNlbGVjdG9yPTNdPSJTZWxlY3RvciIsdVt1Lk5vbmU9NF09Ik5vbmUifSkoeXR8fCh5dD17fSkpO3ZhciB2bjsoZnVuY3Rpb24odSl7dVt1LkN1cnNvcj0xXT0iQ3Vyc29yIix1W3UuVGV4dENyZWF0ZT0yXT0iVGV4dENyZWF0ZSJ9KSh2bnx8KHZuPXt9KSk7dmFyIHluOyhmdW5jdGlvbih1KXt1W3UuVG9wPTFdPSJUb3AiLHVbdS5Cb3R0b209Ml09IkJvdHRvbSJ9KSh5bnx8KHluPXt9KSk7dmFyIGp0OyhmdW5jdGlvbih1KXt1W3Uubm9uZT0xXT0ibm9uZSIsdVt1LmFsbD0yXT0iYWxsIix1W3UuYm90aD0zXT0iYm90aCIsdVt1LnByb3BvcnRpb25hbD00XT0icHJvcG9ydGlvbmFsIn0pKGp0fHwoanQ9e30pKTtjbGFzcyBYdHtjb25zdHJ1Y3Rvcigpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsb2NhbFdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VydmljZVdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NlbmUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KX1yZWdpc3RlckZvcldvcmtlcihlLHQscil7cmV0dXJuIHRoaXMubG9jYWxXb3JrPWUsdGhpcy5zZXJ2aWNlV29yaz10LHRoaXMuc2NlbmU9cix0aGlzfX1jb25zdCBEaD17bGluZWFyOnU9PnUsZWFzZUluUXVhZDp1PT51KnUsZWFzZU91dFF1YWQ6dT0+dSooMi11KSxlYXNlSW5PdXRRdWFkOnU9PnU8LjU/Mip1KnU6LTErKDQtMip1KSp1LGVhc2VJbkN1YmljOnU9PnUqdSp1LGVhc2VPdXRDdWJpYzp1PT4tLXUqdSp1KzEsZWFzZUluT3V0Q3ViaWM6dT0+dTwuNT80KnUqdSp1Oih1LTEpKigyKnUtMikqKDIqdS0yKSsxLGVhc2VJblF1YXJ0OnU9PnUqdSp1KnUsZWFzZU91dFF1YXJ0OnU9PjEtIC0tdSp1KnUqdSxlYXNlSW5PdXRRdWFydDp1PT51PC41PzgqdSp1KnUqdToxLTgqLS11KnUqdSp1LGVhc2VJblF1aW50OnU9PnUqdSp1KnUqdSxlYXNlT3V0UXVpbnQ6dT0+MSstLXUqdSp1KnUqdSxlYXNlSW5PdXRRdWludDp1PT51PC41PzE2KnUqdSp1KnUqdToxKzE2Ki0tdSp1KnUqdSp1LGVhc2VJblNpbmU6dT0+MS1NYXRoLmNvcyh1Kk1hdGguUEkvMiksZWFzZU91dFNpbmU6dT0+TWF0aC5zaW4odSpNYXRoLlBJLzIpLGVhc2VJbk91dFNpbmU6dT0+LShNYXRoLmNvcyhNYXRoLlBJKnUpLTEpLzIsZWFzZUluRXhwbzp1PT51PD0wPzA6TWF0aC5wb3coMiwxMCp1LTEwKSxlYXNlT3V0RXhwbzp1PT51Pj0xPzE6MS1NYXRoLnBvdygyLC0xMCp1KSxlYXNlSW5PdXRFeHBvOnU9PnU8PTA/MDp1Pj0xPzE6dTwuNT9NYXRoLnBvdygyLDIwKnUtMTApLzI6KDItTWF0aC5wb3coMiwtMjAqdSsxMCkpLzJ9O2NsYXNzIGV0e2NvbnN0cnVjdG9yKGU9MCx0PTAscj0xKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnJ9KX1nZXQgWFkoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0eihlKXtyZXR1cm4gdGhpcy56PWUsdGhpc31zZXRYWShlPXRoaXMueCx0PXRoaXMueSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXN9c2V0KGU9dGhpcy54LHQ9dGhpcy55LHI9dGhpcy56KXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PXIsdGhpc31zZXRUbyh7eDplPTAseTp0PTAsejpyPTF9KXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PXIsdGhpc31yb3QoZSl7aWYoZT09PTApcmV0dXJuIHRoaXM7Y29uc3R7eDp0LHk6cn09dGhpcyxuPU1hdGguc2luKGUpLGk9TWF0aC5jb3MoZSk7cmV0dXJuIHRoaXMueD10KmktcipuLHRoaXMueT10Km4rcippLHRoaXN9cm90V2l0aChlLHQpe2lmKHQ9PT0wKXJldHVybiB0aGlzO2NvbnN0IHI9dGhpcy54LWUueCxuPXRoaXMueS1lLnksaT1NYXRoLnNpbih0KSxhPU1hdGguY29zKHQpO3JldHVybiB0aGlzLng9ZS54KyhyKmEtbippKSx0aGlzLnk9ZS55KyhyKmkrbiphKSx0aGlzfWNsb25lKCl7Y29uc3R7eDplLHk6dCx6OnJ9PXRoaXM7cmV0dXJuIG5ldyBldChlLHQscil9c3ViKGUpe3JldHVybiB0aGlzLngtPWUueCx0aGlzLnktPWUueSx0aGlzfXN1YlhZKGUsdCl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPXQsdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpc31hZGQoZSl7cmV0dXJuIHRoaXMueCs9ZS54LHRoaXMueSs9ZS55LHRoaXN9YWRkWFkoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9dCx0aGlzfWFkZFNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9ZSx0aGlzfWNsYW1wKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsZSksdGhpcy55PU1hdGgubWF4KHRoaXMueSxlKSx0IT09dm9pZCAwJiYodGhpcy54PU1hdGgubWluKHRoaXMueCx0KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQpKSx0aGlzfWRpdihlKXtyZXR1cm4gdGhpcy54Lz1lLHRoaXMueS89ZSx0aGlzfWRpdlYoZSl7cmV0dXJuIHRoaXMueC89ZS54LHRoaXMueS89ZS55LHRoaXN9bXVsKGUpe3JldHVybiB0aGlzLngqPWUsdGhpcy55Kj1lLHRoaXN9bXVsVihlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpc31hYnMoKXtyZXR1cm4gdGhpcy54PU1hdGguYWJzKHRoaXMueCksdGhpcy55PU1hdGguYWJzKHRoaXMueSksdGhpc31udWRnZShlLHQpe2NvbnN0IHI9ZXQuVGFuKGUsdGhpcyk7cmV0dXJuIHRoaXMuYWRkKHIubXVsKHQpKX1uZWcoKXtyZXR1cm4gdGhpcy54Kj0tMSx0aGlzLnkqPS0xLHRoaXN9Y3Jvc3MoZSl7cmV0dXJuIHRoaXMueD10aGlzLnkqZS56LXRoaXMueiplLnksdGhpcy55PXRoaXMueiplLngtdGhpcy54KmUueix0aGlzfWRwcihlKXtyZXR1cm4gZXQuRHByKHRoaXMsZSl9Y3ByKGUpe3JldHVybiBldC5DcHIodGhpcyxlKX1sZW4yKCl7cmV0dXJuIGV0LkxlbjIodGhpcyl9bGVuKCl7cmV0dXJuIGV0Lkxlbih0aGlzKX1wcnkoZSl7cmV0dXJuIGV0LlByeSh0aGlzLGUpfXBlcigpe2NvbnN0e3g6ZSx5OnR9PXRoaXM7cmV0dXJuIHRoaXMueD10LHRoaXMueT0tZSx0aGlzfXVuaSgpe3JldHVybiBldC5VbmkodGhpcyl9dGFuKGUpe3JldHVybiBldC5UYW4odGhpcyxlKX1kaXN0KGUpe3JldHVybiBldC5EaXN0KHRoaXMsZSl9ZGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCl7cmV0dXJuIGV0LkRpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQsdGhpcyl9c2xvcGUoZSl7cmV0dXJuIGV0LlNsb3BlKHRoaXMsZSl9c25hcFRvR3JpZChlKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54L2UpKmUsdGhpcy55PU1hdGgucm91bmQodGhpcy55L2UpKmUsdGhpc31hbmdsZShlKXtyZXR1cm4gZXQuQW5nbGUodGhpcyxlKX10b0FuZ2xlKCl7cmV0dXJuIGV0LlRvQW5nbGUodGhpcyl9bHJwKGUsdCl7cmV0dXJuIHRoaXMueD10aGlzLngrKGUueC10aGlzLngpKnQsdGhpcy55PXRoaXMueSsoZS55LXRoaXMueSkqdCx0aGlzfWVxdWFscyhlLHQpe3JldHVybiBldC5FcXVhbHModGhpcyxlLHQpfWVxdWFsc1hZKGUsdCl7cmV0dXJuIGV0LkVxdWFsc1hZKHRoaXMsZSx0KX1ub3JtKCl7Y29uc3QgZT10aGlzLmxlbigpO3JldHVybiB0aGlzLng9ZT09PTA/MDp0aGlzLngvZSx0aGlzLnk9ZT09PTA/MDp0aGlzLnkvZSx0aGlzfXRvRml4ZWQoKXtyZXR1cm4gZXQuVG9GaXhlZCh0aGlzKX10b1N0cmluZygpe3JldHVybiBldC5Ub1N0cmluZyhldC5Ub0ZpeGVkKHRoaXMpKX10b0pzb24oKXtyZXR1cm4gZXQuVG9Kc29uKHRoaXMpfXRvQXJyYXkoKXtyZXR1cm4gZXQuVG9BcnJheSh0aGlzKX1zdGF0aWMgQWRkKGUsdCl7cmV0dXJuIG5ldyBldChlLngrdC54LGUueSt0LnkpfXN0YXRpYyBBZGRYWShlLHQscil7cmV0dXJuIG5ldyBldChlLngrdCxlLnkrcil9c3RhdGljIFN1YihlLHQpe3JldHVybiBuZXcgZXQoZS54LXQueCxlLnktdC55KX1zdGF0aWMgU3ViWFkoZSx0LHIpe3JldHVybiBuZXcgZXQoZS54LXQsZS55LXIpfXN0YXRpYyBBZGRTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IGV0KGUueCt0LGUueSt0KX1zdGF0aWMgU3ViU2NhbGFyKGUsdCl7cmV0dXJuIG5ldyBldChlLngtdCxlLnktdCl9c3RhdGljIERpdihlLHQpe3JldHVybiBuZXcgZXQoZS54L3QsZS55L3QpfXN0YXRpYyBNdWwoZSx0KXtyZXR1cm4gbmV3IGV0KGUueCp0LGUueSp0KX1zdGF0aWMgRGl2VihlLHQpe3JldHVybiBuZXcgZXQoZS54L3QueCxlLnkvdC55KX1zdGF0aWMgTXVsVihlLHQpe3JldHVybiBuZXcgZXQoZS54KnQueCxlLnkqdC55KX1zdGF0aWMgTmVnKGUpe3JldHVybiBuZXcgZXQoLWUueCwtZS55KX1zdGF0aWMgUGVyKGUpe3JldHVybiBuZXcgZXQoZS55LC1lLngpfXN0YXRpYyBEaXN0MihlLHQpe3JldHVybiBldC5TdWIoZSx0KS5sZW4yKCl9c3RhdGljIEFicyhlKXtyZXR1cm4gbmV3IGV0KE1hdGguYWJzKGUueCksTWF0aC5hYnMoZS55KSl9c3RhdGljIERpc3QoZSx0KXtyZXR1cm4gTWF0aC5oeXBvdChlLnktdC55LGUueC10LngpfXN0YXRpYyBEcHIoZSx0KXtyZXR1cm4gZS54KnQueCtlLnkqdC55fXN0YXRpYyBDcm9zcyhlLHQpe3JldHVybiBuZXcgZXQoZS55KnQuei1lLnoqdC55LGUueip0LngtZS54KnQueil9c3RhdGljIENwcihlLHQpe3JldHVybiBlLngqdC55LXQueCplLnl9c3RhdGljIExlbjIoZSl7cmV0dXJuIGUueCplLngrZS55KmUueX1zdGF0aWMgTGVuKGUpe3JldHVybiBNYXRoLmh5cG90KGUueCxlLnkpfXN0YXRpYyBQcnkoZSx0KXtyZXR1cm4gZXQuRHByKGUsdCkvZXQuTGVuKHQpfXN0YXRpYyBVbmkoZSl7cmV0dXJuIGV0LkRpdihlLGV0LkxlbihlKSl9c3RhdGljIFRhbihlLHQpe3JldHVybiBldC5VbmkoZXQuU3ViKGUsdCkpfXN0YXRpYyBNaW4oZSx0KXtyZXR1cm4gbmV3IGV0KE1hdGgubWluKGUueCx0LngpLE1hdGgubWluKGUueSx0LnkpKX1zdGF0aWMgTWF4KGUsdCl7cmV0dXJuIG5ldyBldChNYXRoLm1heChlLngsdC54KSxNYXRoLm1heChlLnksdC55KSl9c3RhdGljIEZyb20oZSl7cmV0dXJuIG5ldyBldCgpLmFkZChlKX1zdGF0aWMgRnJvbUFycmF5KGUpe3JldHVybiBuZXcgZXQoZVswXSxlWzFdKX1zdGF0aWMgUm90KGUsdD0wKXtjb25zdCByPU1hdGguc2luKHQpLG49TWF0aC5jb3ModCk7cmV0dXJuIG5ldyBldChlLngqbi1lLnkqcixlLngqcitlLnkqbil9c3RhdGljIFJvdFdpdGgoZSx0LHIpe2NvbnN0IG49ZS54LXQueCxpPWUueS10LnksYT1NYXRoLnNpbihyKSxsPU1hdGguY29zKHIpO3JldHVybiBuZXcgZXQodC54KyhuKmwtaSphKSx0LnkrKG4qYStpKmwpKX1zdGF0aWMgTmVhcmVzdFBvaW50T25MaW5lVGhyb3VnaFBvaW50KGUsdCxyKXtyZXR1cm4gZXQuTXVsKHQsZXQuU3ViKHIsZSkucHJ5KHQpKS5hZGQoZSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoZSx0LHIsbj0hMCl7Y29uc3QgaT1ldC5UYW4odCxlKSxhPWV0LkFkZChlLGV0Lk11bChpLGV0LlN1YihyLGUpLnByeShpKSkpO2lmKG4pe2lmKGEueDxNYXRoLm1pbihlLngsdC54KSlyZXR1cm4gZXQuQ2FzdChlLng8dC54P2U6dCk7aWYoYS54Pk1hdGgubWF4KGUueCx0LngpKXJldHVybiBldC5DYXN0KGUueD50Lng/ZTp0KTtpZihhLnk8TWF0aC5taW4oZS55LHQueSkpcmV0dXJuIGV0LkNhc3QoZS55PHQueT9lOnQpO2lmKGEueT5NYXRoLm1heChlLnksdC55KSlyZXR1cm4gZXQuQ2FzdChlLnk+dC55P2U6dCl9cmV0dXJuIGF9c3RhdGljIERpc3RhbmNlVG9MaW5lVGhyb3VnaFBvaW50KGUsdCxyKXtyZXR1cm4gZXQuRGlzdChyLGV0Lk5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQscikpfXN0YXRpYyBEaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0LHIsbj0hMCl7cmV0dXJuIGV0LkRpc3QocixldC5OZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGUsdCxyLG4pKX1zdGF0aWMgU25hcChlLHQ9MSl7cmV0dXJuIG5ldyBldChNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfXN0YXRpYyBDYXN0KGUpe3JldHVybiBlIGluc3RhbmNlb2YgZXQ/ZTpldC5Gcm9tKGUpfXN0YXRpYyBTbG9wZShlLHQpe3JldHVybiBlLng9PT10Lnk/TmFOOihlLnktdC55KS8oZS54LXQueCl9c3RhdGljIEFuZ2xlKGUsdCl7cmV0dXJuIE1hdGguYXRhbjIodC55LWUueSx0LngtZS54KX1zdGF0aWMgTHJwKGUsdCxyKXtyZXR1cm4gZXQuU3ViKHQsZSkubXVsKHIpLmFkZChlKX1zdGF0aWMgTWVkKGUsdCl7cmV0dXJuIG5ldyBldCgoZS54K3QueCkvMiwoZS55K3QueSkvMil9c3RhdGljIEVxdWFscyhlLHQscj0xZS00KXtyZXR1cm4gTWF0aC5hYnMoZS54LXQueCk8ciYmTWF0aC5hYnMoZS55LXQueSk8cn1zdGF0aWMgRXF1YWxzWFkoZSx0LHIpe3JldHVybiBlLng9PT10JiZlLnk9PT1yfXN0YXRpYyBFcXVhbHNYWVooZSx0LHI9MWUtNCl7cmV0dXJuIGV0LkVxdWFscyhlLHQscikmJk1hdGguYWJzKChlLnp8fDApLSh0Lnp8fDApKTxyfXN0YXRpYyBDbG9ja3dpc2UoZSx0LHIpe3JldHVybihyLngtZS54KSoodC55LWUueSktKHQueC1lLngpKihyLnktZS55KTwwfXN0YXRpYyBSZXNjYWxlKGUsdCl7Y29uc3Qgcj1ldC5MZW4oZSk7cmV0dXJuIG5ldyBldCh0KmUueC9yLHQqZS55L3IpfXN0YXRpYyBTY2FsZVdpdGhPcmlnaW4oZSx0LHIpe3JldHVybiBldC5TdWIoZSxyKS5tdWwodCkuYWRkKHIpfXN0YXRpYyBTY2FsZVdPcmlnaW4oZSx0LHIpe3JldHVybiBldC5TdWIoZSxyKS5tdWxWKHQpLmFkZChyKX1zdGF0aWMgVG9GaXhlZChlLHQ9Mil7cmV0dXJuIG5ldyBldCgrZS54LnRvRml4ZWQodCksK2UueS50b0ZpeGVkKHQpLCtlLnoudG9GaXhlZCh0KSl9c3RhdGljIE51ZGdlKGUsdCxyKXtyZXR1cm4gZXQuQWRkKGUsZXQuVGFuKHQsZSkubXVsKHIpKX1zdGF0aWMgVG9TdHJpbmcoZSl7cmV0dXJuYCR7ZS54fSwgJHtlLnl9YH1zdGF0aWMgVG9BbmdsZShlKXtsZXQgdD1NYXRoLmF0YW4yKGUueSxlLngpO3JldHVybiB0PDAmJih0Kz1NYXRoLlBJKjIpLHR9c3RhdGljIEZyb21BbmdsZShlLHQ9MSl7cmV0dXJuIG5ldyBldChNYXRoLmNvcyhlKSp0LE1hdGguc2luKGUpKnQpfXN0YXRpYyBUb0FycmF5KGUpe3JldHVybltlLngsZS55LGUuel19c3RhdGljIFRvSnNvbihlKXtjb25zdHt4OnQseTpyLHo6bn09ZTtyZXR1cm57eDp0LHk6cix6Om59fXN0YXRpYyBBdmVyYWdlKGUpe2NvbnN0IHQ9ZS5sZW5ndGgscj1uZXcgZXQoMCwwKTtmb3IobGV0IG49MDtuPHQ7bisrKXIuYWRkKGVbbl0pO3JldHVybiByLmRpdih0KX1zdGF0aWMgQ2xhbXAoZSx0LHIpe3JldHVybiByPT09dm9pZCAwP25ldyBldChNYXRoLm1pbihNYXRoLm1heChlLngsdCkpLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSkpOm5ldyBldChNYXRoLm1pbihNYXRoLm1heChlLngsdCksciksTWF0aC5taW4oTWF0aC5tYXgoZS55LHQpLHIpKX1zdGF0aWMgUG9pbnRzQmV0d2VlbihlLHQscj02KXtjb25zdCBuPVtdO2ZvcihsZXQgaT0wO2k8cjtpKyspe2NvbnN0IGE9RGguZWFzZUluUXVhZChpLyhyLTEpKSxsPWV0LkxycChlLHQsYSk7bC56PU1hdGgubWluKDEsLjUrTWF0aC5hYnMoLjUtd2goYSkpKi42NSksbi5wdXNoKGwpfXJldHVybiBufXN0YXRpYyBTbmFwVG9HcmlkKGUsdD04KXtyZXR1cm4gbmV3IGV0KE1hdGgucm91bmQoZS54L3QpKnQsTWF0aC5yb3VuZChlLnkvdCkqdCl9fWNvbnN0IHdoPXU9PnU8LjU/Mip1KnU6LTErKDQtMip1KSp1O2NsYXNzIHh0IGV4dGVuZHMgZXR7Y29uc3RydWN0b3IoZT0wLHQ9MCxyPTAsbj17eDowLHk6MH0saT0wLGE9MCl7c3VwZXIoZSx0LHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6cn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6aX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6YX0pfWdldCB0aW1lc3RhbXAoKXtyZXR1cm4gdGhpcy50fWdldCBwcmVzc3VyZSgpe3JldHVybiB0aGlzLnp9Z2V0IGFuZ2xlTnVtKCl7cmV0dXJuIHRoaXMuYX1nZXQgWFkoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0QShlKXt0aGlzLmE9ZX1zZXRUKGUpe3RoaXMudD1lfXNldHYoZSl7cmV0dXJuIHRoaXMudj17eDplLngseTplLnl9LHRoaXN9c2V0KGU9dGhpcy54LHQ9dGhpcy55LHI9dGhpcy56LG49dGhpcy52LGk9dGhpcy50LGE9dGhpcy5hKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PXIsdGhpcy52PW4sdGhpcy50PWksdGhpcy5hPWEsdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpyLHY6bix0OmksYX09dGhpcyxsPXt4Om4ueCx5Om4ueX07cmV0dXJuIG5ldyB4dChlLHQscixsLGksYSl9ZGlzdGFuY2UoZSl7cmV0dXJuIHh0LkdldERpc3RhbmNlKHRoaXMsZSl9aXNOZWFyKGUsdCl7cmV0dXJuIHh0LklzTmVhcih0aGlzLGUsdCl9Z2V0QW5nbGVCeVBvaW50cyhlLHQpe3JldHVybiB4dC5HZXRBbmdsZUJ5UG9pbnRzKGUsdGhpcyx0KX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyB4dChlLngtdC54LGUueS10LnkpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IHh0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEdldERpc3RhbmNlKGUsdCl7cmV0dXJuIHh0LkxlbihlLmNsb25lKCkuc3ViKHQpKX1zdGF0aWMgR2V0QW5nbGVCeVBvaW50cyhlLHQscil7Y29uc3Qgbj10LngtZS54LGk9ci54LXQueCxhPXQueS1lLnksbD1yLnktdC55O2xldCBzPTA7Y29uc3QgZj1NYXRoLnNxcnQobipuK2EqYSksdj1NYXRoLnNxcnQoaSppK2wqbCk7aWYoZiYmdil7Y29uc3QgZD1uKmkrYSpsO3M9TWF0aC5hY29zKGQvKGYqdikpLHM9cy9NYXRoLlBJKjE4MDtsZXQgcD1uKmwtYSppO3A9cD4wPzE6LTEscz0xODArcCpzfXJldHVybiBzfXN0YXRpYyBJc05lYXIoZSx0LHIpe3JldHVybiB4dC5MZW4oZS5jbG9uZSgpLnN1Yih0KSk8cn1zdGF0aWMgUm90V2l0aChlLHQscixuPTIpe2NvbnN0IGk9ZS54LXQueCxhPWUueS10LnksbD1NYXRoLnNpbihyKSxzPU1hdGguY29zKHIpLGY9TWF0aC5wb3coMTAsbiksdj1NYXRoLmZsb29yKCh0LngrKGkqcy1hKmwpKSpmKS9mLGQ9TWF0aC5mbG9vcigodC55KyhpKmwrYSpzKSkqZikvZjtyZXR1cm4gbmV3IHh0KHYsZCl9c3RhdGljIEdldERvdFN0cm9rZShlLHQscj0xNil7Y29uc3Qgbj1uZXcgZXQoMSwxKSxpPU1hdGguUEkrLjAwMSxhPXh0LkFkZChlLHh0LlN1YihlLG4pLnVuaSgpLnBlcigpLm11bCgtdCkpLGw9W107Zm9yKGxldCBzPTEvcixmPXM7Zjw9MTtmKz1zKWwucHVzaCh4dC5Sb3RXaXRoKGEsZSxpKjIqZikpO3JldHVybiBsfXN0YXRpYyBHZXRTZW1pY2lyY2xlU3Ryb2tlKGUsdCxyPS0xLG49OCl7Y29uc3QgaT1yKihNYXRoLlBJKy4wMDEpLGE9W107Zm9yKGxldCBsPTEvbixzPWw7czw9MTtzKz1sKWEucHVzaCh4dC5Sb3RXaXRoKHQsZSxpKnMpKTtyZXR1cm4gYX19ZnVuY3Rpb24gYnQodSxlKXtpZih1JiZlKXtjb25zdCB0PU1hdGgubWluKHUueCxlLngpLHI9TWF0aC5taW4odS55LGUueSksbj1NYXRoLm1heCh1LngrdS53LGUueCtlLncpLGk9TWF0aC5tYXgodS55K3UuaCxlLnkrZS5oKSxhPW4tdCxsPWktcjtyZXR1cm57eDp0LHk6cix3OmEsaDpsfX1yZXR1cm4gZXx8dX1mdW5jdGlvbiBOdCh1LGU9MCl7Y29uc3QgdD17eDowLHk6MCx3OjAsaDowfTtsZXQgcj0xLzAsbj0xLzAsaT0tMS8wLGE9LTEvMDtyZXR1cm4gdS5mb3JFYWNoKGw9Pntjb25zdFtzLGZdPWwuWFk7cj1NYXRoLm1pbihyLHMtZSksbj1NYXRoLm1pbihuLGYtZSksaT1NYXRoLm1heChpLHMrZSksYT1NYXRoLm1heChhLGYrZSl9KSx0Lng9cix0Lnk9bix0Lnc9aS1yLHQuaD1hLW4sdH1mdW5jdGlvbiB4ZSh1LGUpe3JldHVybiEodS54K3UudzxlLnh8fHUueD5lLngrZS53fHx1LnkrdS5oPGUueXx8dS55PmUueStlLmgpfWZ1bmN0aW9uIE5oKHUsZSl7cmV0dXJuIHUubGVuZ3RoPT09ZS5sZW5ndGgmJnUuc29ydCgpLnRvU3RyaW5nKCk9PT1lLnNvcnQoKS50b1N0cmluZygpfWZ1bmN0aW9uIFZ0KHUsZT0xMCl7cmV0dXJue3g6TWF0aC5mbG9vcih1LngtZSkseTpNYXRoLmZsb29yKHUueS1lKSx3Ok1hdGguZmxvb3IodS53K2UqMiksaDpNYXRoLmZsb29yKHUuaCtlKjIpfX1mdW5jdGlvbiBPZSh1LGUpe3JldHVybnt4OnUueCtlWzBdLHk6dS55K2VbMV0sdzp1LncsaDp1Lmh9fWZ1bmN0aW9uIFNuKHUsZSl7Y29uc3QgdD1uZXcgZXQodS54LHUueSkscj1uZXcgZXQodS54K3Uudyx1LnkpLG49bmV3IGV0KHUueCt1LncsdS55K3UuaCksaT1uZXcgZXQodS54LHUueSt1LmgpLGE9bmV3IGV0KHUueCt1LncvMix1LnkrdS5oLzIpLGw9TWF0aC5QSSplLzE4MCxzPWV0LlJvdFdpdGgodCxhLGwpLGY9ZXQuUm90V2l0aChyLGEsbCksdj1ldC5Sb3RXaXRoKG4sYSxsKSxkPWV0LlJvdFdpdGgoaSxhLGwpO3JldHVybiBOdChbcyxmLHYsZF0pfWZ1bmN0aW9uIHhuKHUsZSl7Y29uc3QgdD1uZXcgZXQodS54LHUueSkscj1uZXcgZXQodS54K3Uudyx1LnkpLG49bmV3IGV0KHUueCt1LncsdS55K3UuaCksaT1uZXcgZXQodS54LHUueSt1LmgpLGE9bmV3IGV0KHUueCt1LncvMix1LnkrdS5oLzIpLGw9bmV3IGV0KGVbMF0sZVsxXSkscz1ldC5TY2FsZVdPcmlnaW4odCxsLGEpLGY9ZXQuU2NhbGVXT3JpZ2luKHIsbCxhKSx2PWV0LlNjYWxlV09yaWdpbihuLGwsYSksZD1ldC5TY2FsZVdPcmlnaW4oaSxsLGEpO3JldHVybiBOdChbcyxmLHYsZF0pfWZ1bmN0aW9uIEJoKHUsZSx0KXtjb25zdCByPW5ldyBldChlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248dS5sZW5ndGg7bis9Myl7Y29uc3QgaT1uZXcgZXQodVtuXSx1W24rMV0pLGE9TWF0aC5QSSp0LzE4MCxsPWV0LlJvdFdpdGgoaSxyLGEpO3Vbbl09bC54LHVbbisxXT1sLnl9fWZ1bmN0aW9uIGpoKHUsZSx0KXtjb25zdCByPW5ldyBldChlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248dS5sZW5ndGg7bis9Myl7Y29uc3QgaT1uZXcgZXQodVtuXSx1W24rMV0pLGE9bmV3IGV0KHRbMF0sdFsxXSk7aWYobjx1Lmxlbmd0aC0zKXtjb25zdCBzPW5ldyBldCh1W24rM10sdVtuKzRdKSxmPWV0LlRhbihzLGkpLnBlcigpLm11bCh1W24rMl0pLm11bFYoYSkubGVuKCk7dVtuKzJdPWZ9ZWxzZSBpZihuPT09dS5sZW5ndGgtMyl7Y29uc3Qgcz1uZXcgZXQodVtuLTNdLHVbbi0yXSksZj1ldC5UYW4oaSxzKS5wZXIoKS5tdWwodVtuKzJdKS5tdWxWKGEpLmxlbigpO3VbbisyXT1mfWNvbnN0IGw9ZXQuU2NhbGVXT3JpZ2luKGksYSxyKTt1W25dPWwueCx1W24rMV09bC55fX1mdW5jdGlvbiBXaCh1LGUpe3JldHVybiB1WzBdPj1lLngmJnVbMF08PWUueCtlLncmJnVbMV0+PWUueSYmdVsxXTw9ZS55K2UuaH1mdW5jdGlvbiBPbih1LGUpe2NvbnN0IHQ9dTw9ZT8xOnUvZSxyPWU8PXU/MTplL3U7cmV0dXJuW3Qscl19Y29uc3QgVWU9dT0+e2lmKHUudGFnTmFtZT09PSJHUk9VUCIpe2NvbnN0IGU9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh1KS5maW5kKHQ9PnQudG9TdHJpbmcoKT09PSJTeW1ib2woc2VhbGVkKSIpO2lmKGUmJnVbZV0pcmV0dXJuITB9cmV0dXJuITF9LGJuPXU9PnUhPT1kdC5UZXh0O2Z1bmN0aW9uIHBlKHUpe3JldHVybmAkeyRlKHUueCl9LCR7JGUodS55KX0gYH1mdW5jdGlvbiBtZSh1LGUpe3JldHVybmAkeyRlKCh1LngrZS54KS8yKX0sJHskZSgodS55K2UueSkvMil9IGB9ZnVuY3Rpb24gJGUodSl7cmV0dXJuK3UudG9GaXhlZCg0KX12YXIgRmg9aWUsVWg9X3QsJGg9IltvYmplY3QgTnVtYmVyXSI7ZnVuY3Rpb24gemgodSl7cmV0dXJuIHR5cGVvZiB1PT0ibnVtYmVyInx8VWgodSkmJkZoKHUpPT0kaH12YXIgR2g9emgsbmU9Y2UoR2gpO2NsYXNzIHB0e2NvbnN0cnVjdG9yKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVW5pdFRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxZTN9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSk7Y29uc3R7dk5vZGVzOnQsZnVsbExheWVyOnIsZHJhd0xheWVyOm59PWU7dGhpcy52Tm9kZXM9dCx0aGlzLmZ1bGxMYXllcj1yLHRoaXMuZHJhd0xheWVyPW59c2V0V29ya0lkKGUpe3RoaXMud29ya0lkPWV9Z2V0V29ya0lkKCl7cmV0dXJuIHRoaXMud29ya0lkfWdldFdvcmtPcHRpb25zKCl7cmV0dXJuIHRoaXMud29ya09wdGlvbnN9c2V0V29ya09wdGlvbnMoZSl7dmFyIG47dGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1VuaXRUaW1lPWUuc3luY1VuaXRUaW1lfHx0aGlzLnN5bmNVbml0VGltZTtjb25zdCB0PShuPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6bi50b1N0cmluZygpLHI9dCYmdGhpcy52Tm9kZXMuZ2V0KHQpfHx2b2lkIDA7dCYmciYmKHIub3B0PWUsdGhpcy52Tm9kZXMuc2V0SW5mbyh0LHIpKX11cGRhdGFPcHRTZXJ2aWNlKGUpe3ZhciBuO2xldCB0O2NvbnN0IHI9KG49dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCk7aWYociYmZSl7Y29uc3QgaT10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShyKXx8dGhpcy5kcmF3TGF5ZXImJnRoaXMuZHJhd0xheWVyLmdldEVsZW1lbnRzQnlOYW1lKHIpfHxbXTtpZihpLmxlbmd0aCE9PTEpcmV0dXJuO2NvbnN0IGE9aVswXSx7cG9zOmwsekluZGV4OnMsc2NhbGU6ZixhbmdsZTp2LHRyYW5zbGF0ZTpkfT1lLHA9e307bmUocykmJihwLnpJbmRleD1zKSxsJiYocC5wb3M9W2xbMF0sbFsxXV0pLGYmJihwLnNjYWxlPWYpLHYmJihwLnJvdGF0ZT12KSxkJiYocC50cmFuc2xhdGU9ZCksYS5hdHRyKHApO2NvbnN0IHk9YT09bnVsbD92b2lkIDA6YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4geSYmKHQ9YnQodCx7eDpNYXRoLmZsb29yKHkueC1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKHkueS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHkud2lkdGgrcHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKHkuaGVpZ2h0K3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfSkpLHRoaXMudk5vZGVzLnNldEluZm8ocix7cmVjdDp0LGNlbnRlclBvczpsfSksdH19c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpuLHdpbGxTZXJpYWxpemVEYXRhOmksdGFyZ2V0Tm9kZTphfT1lLHt6SW5kZXg6bCx0cmFuc2xhdGU6cyxhbmdsZTpmLGJveDp2LGJveFNjYWxlOmQsYm94VHJhbnNsYXRlOnAscG9pbnRNYXA6eX09cjtsZXQgUDtjb25zdCB4PWEmJll0KGEpfHxuLmdldCh0Lm5hbWUpO2lmKCF4KXJldHVybjtuZShsKSYmKHQuc2V0QXR0cmlidXRlKCJ6SW5kZXgiLGwpLHgub3B0LnpJbmRleD1sKTtjb25zdCBtPXQucGFyZW50O2lmKG0pe2lmKHYmJnAmJmQpe2NvbnN0e3JlY3Q6T309eCxvPVtdO2ZvcihsZXQgST0wO0k8eC5vcC5sZW5ndGg7SSs9MylvLnB1c2gobmV3IHh0KHgub3BbSV0seC5vcFtJKzFdLHgub3BbSSsyXSkpO2NvbnN0IGg9TnQobyksYz1baC53Km0ud29ybGRTY2FsaW5nWzBdLGguaCptLndvcmxkU2NhbGluZ1swXV0sZz1bTy53LWNbMF0sTy5oLWNbMV1dLGI9WyhPLncqZFswXS1nWzBdKS9jWzBdLChPLmgqZFsxXS1nWzFdKS9jWzFdXSxFPVtwWzBdL20ud29ybGRTY2FsaW5nWzBdLHBbMV0vbS53b3JsZFNjYWxpbmdbMV1dLEE9eC5vcC5tYXAoKEksRCk9Pntjb25zdCBSPUQlMztyZXR1cm4gUj09PTA/SStFWzBdOlI9PT0xP0krRVsxXTpJfSksTD1beC5jZW50ZXJQb3NbMF0rRVswXSx4LmNlbnRlclBvc1sxXStFWzFdXTtqaChBLEwsYik7Y29uc3QgTT1bXTtmb3IobGV0IEk9MDtJPEEubGVuZ3RoO0krPTMpTS5wdXNoKG5ldyB4dChBW0ldLEFbSSsxXSxBW0krMl0pKTt4Lm9wPUEseC5jZW50ZXJQb3M9TH1lbHNlIGlmKHMpe2NvbnN0IE89W3NbMF0vbS53b3JsZFNjYWxpbmdbMF0sc1sxXS9tLndvcmxkU2NhbGluZ1sxXV07dC5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsTykseC5vcHQudHJhbnNsYXRlPU8sYSYmKFA9T2UoeC5yZWN0LHMpLHgucmVjdD1QKX1lbHNlIG5lKGYpJiYodC5zZXRBdHRyaWJ1dGUoInJvdGF0ZSIsZikseC5vcHQucm90YXRlPWYsYSYmKFA9U24oeC5yZWN0LGYpLHgucmVjdD1QKSk7aWYoeSl7Y29uc3QgTz15LmdldCh0Lm5hbWUpO2lmKE8pZm9yKGxldCBvPTAsaD0wO288eC5vcC5sZW5ndGg7bys9MyxoKyspeC5vcFtvXT1PW2hdWzBdLHgub3BbbysxXT1PW2hdWzFdfWlmKGkpe2lmKHMpe2NvbnN0IE89W3NbMF0vbS53b3JsZFNjYWxpbmdbMF0sc1sxXS9tLndvcmxkU2NhbGluZ1sxXV0sbz14Lm9wLm1hcCgoaCxjKT0+e2NvbnN0IGc9YyUzO3JldHVybiBnPT09MD9oK09bMF06Zz09PTE/aCtPWzFdOmh9KTt4Lm9wPW8seC5jZW50ZXJQb3M9W3guY2VudGVyUG9zWzBdK09bMF0seC5jZW50ZXJQb3NbMV0rT1sxXV0seCE9bnVsbCYmeC5vcHQmJih4Lm9wdC50cmFuc2xhdGU9dm9pZCAwKX1lbHNlIGlmKG5lKGYpKXtjb25zdCBPPXgub3A7QmgoTyx4LmNlbnRlclBvcyxmKSx4Lm9wPU8seCE9bnVsbCYmeC5vcHQmJih4Lm9wdC5yb3RhdGU9dm9pZCAwKX19eCYmbi5zZXRJbmZvKHQubmFtZSx4KX19c3RhdGljIGdldENlbnRlclBvcyhlLHQpe2NvbnN0e3dvcmxkUG9zaXRpb246cix3b3JsZFNjYWxpbmc6bn09dDtyZXR1cm5bKGUueCtlLncvMi1yWzBdKS9uWzBdLChlLnkrZS5oLzItclsxXSkvblsxXV19c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCByPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYocil7Y29uc3Qgbj1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3Iobi54LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3Iobi55LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3Iobi53aWR0aCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3Iobi5oZWlnaHQrcHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHB0LCJTYWZlQm9yZGVyUGFkZGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSk7dmFyIER0PWZ1bmN0aW9uKHUpe3ZhciBlPXt9O2Z1bmN0aW9uIHQocil7aWYoZVtyXSlyZXR1cm4gZVtyXS5leHBvcnRzO3ZhciBuPWVbcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiB1W3JdLmNhbGwobi5leHBvcnRzLG4sbi5leHBvcnRzLHQpLG4ubD0hMCxuLmV4cG9ydHN9cmV0dXJuIHQubT11LHQuYz1lLHQuZD1mdW5jdGlvbihyLG4saSl7dC5vKHIsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLG4se2VudW1lcmFibGU6ITAsZ2V0Oml9KX0sdC5yPWZ1bmN0aW9uKHIpe3R5cGVvZiBTeW1ib2w8InUiJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkociwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LHQudD1mdW5jdGlvbihyLG4pe2lmKG4mMSYmKHI9dChyKSksbiY4fHxuJjQmJnR5cGVvZiByPT0ib2JqZWN0IiYmciYmci5fX2VzTW9kdWxlKXJldHVybiByO3ZhciBpPU9iamVjdC5jcmVhdGUobnVsbCk7aWYodC5yKGkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCx2YWx1ZTpyfSksbiYyJiZ0eXBlb2YgciE9InN0cmluZyIpZm9yKHZhciBhIGluIHIpdC5kKGksYSwoZnVuY3Rpb24obCl7cmV0dXJuIHJbbF19KS5iaW5kKG51bGwsYSkpO3JldHVybiBpfSx0Lm49ZnVuY3Rpb24ocil7dmFyIG49ciYmci5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gcn07cmV0dXJuIHQuZChuLCJhIixuKSxufSx0Lm89ZnVuY3Rpb24ocixuKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsbil9LHQucD0iL2pzLyIsdCh0LnM9MCl9KFtmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJ2ZXJzaW9uIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsImhlbHBlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiY3JlYXRlRWxlbWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJpc1Nwcml0ZU5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicmVnaXN0ZXJOb2RlIixmdW5jdGlvbigpe3JldHVybiBDfSk7dmFyIHI9dCgxMik7dC5kKGUsIkVOViIsZnVuY3Rpb24oKXtyZXR1cm4gci5FTlZ9KTt2YXIgbj10KDY4KTt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBuLnJlcXVlc3RBbmltYXRpb25GcmFtZX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gbi5jYW5jZWxBbmltYXRpb25GcmFtZX0pO3ZhciBpPXQoNzApO3QuZChlLCJOb2RlIixmdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHR9KTt2YXIgYT10KDIxNyk7dC5kKGUsIkNsb3VkIixmdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHR9KTt2YXIgbD10KDIxOSk7dC5kKGUsIkJsb2NrIixmdW5jdGlvbigpe3JldHVybiBsLmRlZmF1bHR9KTt2YXIgcz10KDIyNCk7dC5kKGUsIlNwcml0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0fSk7dmFyIGY9dCgyMjYpO3QuZChlLCJQYXRoIixmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9KTt2YXIgdj10KDIyOSk7dC5kKGUsIlJlY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHYuZGVmYXVsdH0pO3ZhciBkPXQoMjMxKTt0LmQoZSwiVHJpYW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVmYXVsdH0pO3ZhciBwPXQoMjM2KTt0LmQoZSwiUGFyYWxsZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHAuZGVmYXVsdH0pO3ZhciB5PXQoMjM4KTt0LmQoZSwiUmVndWxhciIsZnVuY3Rpb24oKXtyZXR1cm4geS5kZWZhdWx0fSk7dmFyIFA9dCgyNDApO3QuZChlLCJTdGFyIixmdW5jdGlvbigpe3JldHVybiBQLmRlZmF1bHR9KTt2YXIgeD10KDI0Mik7dC5kKGUsIkVsbGlwc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHguZGVmYXVsdH0pO3ZhciBtPXQoMjQ0KTt0LmQoZSwiQXJjIixmdW5jdGlvbigpe3JldHVybiBtLmRlZmF1bHR9KTt2YXIgTz10KDI0Nik7dC5kKGUsIlJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIE8uZGVmYXVsdH0pO3ZhciBvPXQoMjMyKTt0LmQoZSwiUG9seWxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG8uZGVmYXVsdH0pO3ZhciBoPXQoMjQ4KTt0LmQoZSwiTGFiZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGguZGVmYXVsdH0pO3ZhciBjPXQoMjUwKTt0LmQoZSwiR3JvdXAiLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pO3ZhciBnPXQoMjg2KTt0LmQoZSwiTGF5ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGcuZGVmYXVsdH0pO3ZhciBiPXQoMjg3KTt0LmQoZSwiU3ByaXRlU3ZnIixmdW5jdGlvbigpe3JldHVybiBiLmRlZmF1bHR9KTt2YXIgRT10KDI4OSk7dC5kKGUsIkxheWVyV29ya2VyIixmdW5jdGlvbigpe3JldHVybiBFLmRlZmF1bHR9KTt2YXIgQT10KDI5MCk7dC5kKGUsIlNjZW5lIixmdW5jdGlvbigpe3JldHVybiBBLmRlZmF1bHR9KTt2YXIgTD10KDIxMyksTT10KDIyMSk7dC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBNLkNvbG9yfSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBNLkdyYWRpZW50fSk7dmFyIEk9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEQ9TC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQsUj1MLmRlZmF1bHQuaXNTcHJpdGVOb2RlLEM9TC5kZWZhdWx0LnJlZ2lzdGVyTm9kZSxCPXtwYXJzZUNvbG9yOk0ucGFyc2VDb2xvcixzaXplVG9QaXhlbDpJLnNpemVUb1BpeGVsLHRvQXJyYXk6SS50b0FycmF5LHRvU3RyaW5nOkkudG9TdHJpbmcsdG9OdW1iZXI6SS50b051bWJlcn07bGV0IHo7ej0iMy44LjMiO2NvbnN0IEs9en0sZnVuY3Rpb24odSxlLHQpe3QucihlKTt2YXIgcj10KDIpO3QuZChlLCJnbE1hdHJpeCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pO3ZhciBuPXQoMyk7dC5kKGUsIm1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgaT10KDQpO3QuZChlLCJtYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBhPXQoNSk7dC5kKGUsIm1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTt2YXIgbD10KDYpO3QuZChlLCJtYXQ0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHM9dCg3KTt0LmQoZSwicXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciBmPXQoMTApO3QuZChlLCJxdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciB2PXQoMTEpO3QuZChlLCJ2ZWMyIixmdW5jdGlvbigpe3JldHVybiB2fSk7dmFyIGQ9dCg4KTt0LmQoZSwidmVjMyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBwPXQoOSk7dC5kKGUsInZlYzQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiRVBTSUxPTiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJBUlJBWV9UWVBFIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsIlJBTkRPTSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzZXRNYXRyaXhBcnJheVR5cGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwidG9SYWRpYW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9MWUtNixuPXR5cGVvZiBGbG9hdDMyQXJyYXk8InUiP0Zsb2F0MzJBcnJheTpBcnJheSxpPU1hdGgucmFuZG9tO2Z1bmN0aW9uIGEodil7bj12fXZhciBsPU1hdGguUEkvMTgwO2Z1bmN0aW9uIHModil7cmV0dXJuIHYqbH1mdW5jdGlvbiBmKHYsZCl7cmV0dXJuIE1hdGguYWJzKHYtZCk8PXIqTWF0aC5tYXgoMSxNYXRoLmFicyh2KSxNYXRoLmFicyhkKSl9TWF0aC5oeXBvdHx8KE1hdGguaHlwb3Q9ZnVuY3Rpb24oKXtmb3IodmFyIHY9MCxkPWFyZ3VtZW50cy5sZW5ndGg7ZC0tOyl2Kz1hcmd1bWVudHNbZF0qYXJndW1lbnRzW2RdO3JldHVybiBNYXRoLnNxcnQodil9KX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiTERVIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBDPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoQ1sxXT0wLENbMl09MCksQ1swXT0xLENbM109MSxDfWZ1bmN0aW9uIGkoQyl7dmFyIEI9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gQlswXT1DWzBdLEJbMV09Q1sxXSxCWzJdPUNbMl0sQlszXT1DWzNdLEJ9ZnVuY3Rpb24gYShDLEIpe3JldHVybiBDWzBdPUJbMF0sQ1sxXT1CWzFdLENbMl09QlsyXSxDWzNdPUJbM10sQ31mdW5jdGlvbiBsKEMpe3JldHVybiBDWzBdPTEsQ1sxXT0wLENbMl09MCxDWzNdPTEsQ31mdW5jdGlvbiBzKEMsQix6LEspe3ZhciBRPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIFFbMF09QyxRWzFdPUIsUVsyXT16LFFbM109SyxRfWZ1bmN0aW9uIGYoQyxCLHosSyxRKXtyZXR1cm4gQ1swXT1CLENbMV09eixDWzJdPUssQ1szXT1RLEN9ZnVuY3Rpb24gdihDLEIpe2lmKEM9PT1CKXt2YXIgej1CWzFdO0NbMV09QlsyXSxDWzJdPXp9ZWxzZSBDWzBdPUJbMF0sQ1sxXT1CWzJdLENbMl09QlsxXSxDWzNdPUJbM107cmV0dXJuIEN9ZnVuY3Rpb24gZChDLEIpe3ZhciB6PUJbMF0sSz1CWzFdLFE9QlsyXSxfPUJbM10sRj16Kl8tUSpLO3JldHVybiBGPyhGPTEvRixDWzBdPV8qRixDWzFdPS1LKkYsQ1syXT0tUSpGLENbM109eipGLEMpOm51bGx9ZnVuY3Rpb24gcChDLEIpe3ZhciB6PUJbMF07cmV0dXJuIENbMF09QlszXSxDWzFdPS1CWzFdLENbMl09LUJbMl0sQ1szXT16LEN9ZnVuY3Rpb24geShDKXtyZXR1cm4gQ1swXSpDWzNdLUNbMl0qQ1sxXX1mdW5jdGlvbiBQKEMsQix6KXt2YXIgSz1CWzBdLFE9QlsxXSxfPUJbMl0sRj1CWzNdLEc9elswXSxYPXpbMV0sWj16WzJdLHR0PXpbM107cmV0dXJuIENbMF09SypHK18qWCxDWzFdPVEqRytGKlgsQ1syXT1LKlorXyp0dCxDWzNdPVEqWitGKnR0LEN9ZnVuY3Rpb24geChDLEIseil7dmFyIEs9QlswXSxRPUJbMV0sXz1CWzJdLEY9QlszXSxHPU1hdGguc2luKHopLFg9TWF0aC5jb3Moeik7cmV0dXJuIENbMF09SypYK18qRyxDWzFdPVEqWCtGKkcsQ1syXT1LKi1HK18qWCxDWzNdPVEqLUcrRipYLEN9ZnVuY3Rpb24gbShDLEIseil7dmFyIEs9QlswXSxRPUJbMV0sXz1CWzJdLEY9QlszXSxHPXpbMF0sWD16WzFdO3JldHVybiBDWzBdPUsqRyxDWzFdPVEqRyxDWzJdPV8qWCxDWzNdPUYqWCxDfWZ1bmN0aW9uIE8oQyxCKXt2YXIgej1NYXRoLnNpbihCKSxLPU1hdGguY29zKEIpO3JldHVybiBDWzBdPUssQ1sxXT16LENbMl09LXosQ1szXT1LLEN9ZnVuY3Rpb24gbyhDLEIpe3JldHVybiBDWzBdPUJbMF0sQ1sxXT0wLENbMl09MCxDWzNdPUJbMV0sQ31mdW5jdGlvbiBoKEMpe3JldHVybiJtYXQyKCIrQ1swXSsiLCAiK0NbMV0rIiwgIitDWzJdKyIsICIrQ1szXSsiKSJ9ZnVuY3Rpb24gYyhDKXtyZXR1cm4gTWF0aC5oeXBvdChDWzBdLENbMV0sQ1syXSxDWzNdKX1mdW5jdGlvbiBnKEMsQix6LEspe3JldHVybiBDWzJdPUtbMl0vS1swXSx6WzBdPUtbMF0selsxXT1LWzFdLHpbM109S1szXS1DWzJdKnpbMV0sW0MsQix6XX1mdW5jdGlvbiBiKEMsQix6KXtyZXR1cm4gQ1swXT1CWzBdK3pbMF0sQ1sxXT1CWzFdK3pbMV0sQ1syXT1CWzJdK3pbMl0sQ1szXT1CWzNdK3pbM10sQ31mdW5jdGlvbiBFKEMsQix6KXtyZXR1cm4gQ1swXT1CWzBdLXpbMF0sQ1sxXT1CWzFdLXpbMV0sQ1syXT1CWzJdLXpbMl0sQ1szXT1CWzNdLXpbM10sQ31mdW5jdGlvbiBBKEMsQil7cmV0dXJuIENbMF09PT1CWzBdJiZDWzFdPT09QlsxXSYmQ1syXT09PUJbMl0mJkNbM109PT1CWzNdfWZ1bmN0aW9uIEwoQyxCKXt2YXIgej1DWzBdLEs9Q1sxXSxRPUNbMl0sXz1DWzNdLEY9QlswXSxHPUJbMV0sWD1CWzJdLFo9QlszXTtyZXR1cm4gTWF0aC5hYnMoei1GKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeiksTWF0aC5hYnMoRikpJiZNYXRoLmFicyhLLUcpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhHKSkmJk1hdGguYWJzKFEtWCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFEpLE1hdGguYWJzKFgpKSYmTWF0aC5hYnMoXy1aKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMoWikpfWZ1bmN0aW9uIE0oQyxCLHope3JldHVybiBDWzBdPUJbMF0qeixDWzFdPUJbMV0qeixDWzJdPUJbMl0qeixDWzNdPUJbM10qeixDfWZ1bmN0aW9uIEkoQyxCLHosSyl7cmV0dXJuIENbMF09QlswXSt6WzBdKkssQ1sxXT1CWzFdK3pbMV0qSyxDWzJdPUJbMl0relsyXSpLLENbM109QlszXSt6WzNdKkssQ312YXIgRD1QLFI9RX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgUj1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFJbMV09MCxSWzJdPTAsUls0XT0wLFJbNV09MCksUlswXT0xLFJbM109MSxSfWZ1bmN0aW9uIGkoUil7dmFyIEM9bmV3IHIuQVJSQVlfVFlQRSg2KTtyZXR1cm4gQ1swXT1SWzBdLENbMV09UlsxXSxDWzJdPVJbMl0sQ1szXT1SWzNdLENbNF09Uls0XSxDWzVdPVJbNV0sQ31mdW5jdGlvbiBhKFIsQyl7cmV0dXJuIFJbMF09Q1swXSxSWzFdPUNbMV0sUlsyXT1DWzJdLFJbM109Q1szXSxSWzRdPUNbNF0sUls1XT1DWzVdLFJ9ZnVuY3Rpb24gbChSKXtyZXR1cm4gUlswXT0xLFJbMV09MCxSWzJdPTAsUlszXT0xLFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiBzKFIsQyxCLHosSyxRKXt2YXIgXz1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiBfWzBdPVIsX1sxXT1DLF9bMl09QixfWzNdPXosX1s0XT1LLF9bNV09USxffWZ1bmN0aW9uIGYoUixDLEIseixLLFEsXyl7cmV0dXJuIFJbMF09QyxSWzFdPUIsUlsyXT16LFJbM109SyxSWzRdPVEsUls1XT1fLFJ9ZnVuY3Rpb24gdihSLEMpe3ZhciBCPUNbMF0sej1DWzFdLEs9Q1syXSxRPUNbM10sXz1DWzRdLEY9Q1s1XSxHPUIqUS16Kks7cmV0dXJuIEc/KEc9MS9HLFJbMF09USpHLFJbMV09LXoqRyxSWzJdPS1LKkcsUlszXT1CKkcsUls0XT0oSypGLVEqXykqRyxSWzVdPSh6Kl8tQipGKSpHLFIpOm51bGx9ZnVuY3Rpb24gZChSKXtyZXR1cm4gUlswXSpSWzNdLVJbMV0qUlsyXX1mdW5jdGlvbiBwKFIsQyxCKXt2YXIgej1DWzBdLEs9Q1sxXSxRPUNbMl0sXz1DWzNdLEY9Q1s0XSxHPUNbNV0sWD1CWzBdLFo9QlsxXSx0dD1CWzJdLG50PUJbM10scT1CWzRdLGh0PUJbNV07cmV0dXJuIFJbMF09eipYK1EqWixSWzFdPUsqWCtfKlosUlsyXT16KnR0K1EqbnQsUlszXT1LKnR0K18qbnQsUls0XT16KnErUSpodCtGLFJbNV09SypxK18qaHQrRyxSfWZ1bmN0aW9uIHkoUixDLEIpe3ZhciB6PUNbMF0sSz1DWzFdLFE9Q1syXSxfPUNbM10sRj1DWzRdLEc9Q1s1XSxYPU1hdGguc2luKEIpLFo9TWF0aC5jb3MoQik7cmV0dXJuIFJbMF09eipaK1EqWCxSWzFdPUsqWitfKlgsUlsyXT16Ki1YK1EqWixSWzNdPUsqLVgrXypaLFJbNF09RixSWzVdPUcsUn1mdW5jdGlvbiBQKFIsQyxCKXt2YXIgej1DWzBdLEs9Q1sxXSxRPUNbMl0sXz1DWzNdLEY9Q1s0XSxHPUNbNV0sWD1CWzBdLFo9QlsxXTtyZXR1cm4gUlswXT16KlgsUlsxXT1LKlgsUlsyXT1RKlosUlszXT1fKlosUls0XT1GLFJbNV09RyxSfWZ1bmN0aW9uIHgoUixDLEIpe3ZhciB6PUNbMF0sSz1DWzFdLFE9Q1syXSxfPUNbM10sRj1DWzRdLEc9Q1s1XSxYPUJbMF0sWj1CWzFdO3JldHVybiBSWzBdPXosUlsxXT1LLFJbMl09USxSWzNdPV8sUls0XT16KlgrUSpaK0YsUls1XT1LKlgrXypaK0csUn1mdW5jdGlvbiBtKFIsQyl7dmFyIEI9TWF0aC5zaW4oQyksej1NYXRoLmNvcyhDKTtyZXR1cm4gUlswXT16LFJbMV09QixSWzJdPS1CLFJbM109eixSWzRdPTAsUls1XT0wLFJ9ZnVuY3Rpb24gTyhSLEMpe3JldHVybiBSWzBdPUNbMF0sUlsxXT0wLFJbMl09MCxSWzNdPUNbMV0sUls0XT0wLFJbNV09MCxSfWZ1bmN0aW9uIG8oUixDKXtyZXR1cm4gUlswXT0xLFJbMV09MCxSWzJdPTAsUlszXT0xLFJbNF09Q1swXSxSWzVdPUNbMV0sUn1mdW5jdGlvbiBoKFIpe3JldHVybiJtYXQyZCgiK1JbMF0rIiwgIitSWzFdKyIsICIrUlsyXSsiLCAiK1JbM10rIiwgIitSWzRdKyIsICIrUls1XSsiKSJ9ZnVuY3Rpb24gYyhSKXtyZXR1cm4gTWF0aC5oeXBvdChSWzBdLFJbMV0sUlsyXSxSWzNdLFJbNF0sUls1XSwxKX1mdW5jdGlvbiBnKFIsQyxCKXtyZXR1cm4gUlswXT1DWzBdK0JbMF0sUlsxXT1DWzFdK0JbMV0sUlsyXT1DWzJdK0JbMl0sUlszXT1DWzNdK0JbM10sUls0XT1DWzRdK0JbNF0sUls1XT1DWzVdK0JbNV0sUn1mdW5jdGlvbiBiKFIsQyxCKXtyZXR1cm4gUlswXT1DWzBdLUJbMF0sUlsxXT1DWzFdLUJbMV0sUlsyXT1DWzJdLUJbMl0sUlszXT1DWzNdLUJbM10sUls0XT1DWzRdLUJbNF0sUls1XT1DWzVdLUJbNV0sUn1mdW5jdGlvbiBFKFIsQyxCKXtyZXR1cm4gUlswXT1DWzBdKkIsUlsxXT1DWzFdKkIsUlsyXT1DWzJdKkIsUlszXT1DWzNdKkIsUls0XT1DWzRdKkIsUls1XT1DWzVdKkIsUn1mdW5jdGlvbiBBKFIsQyxCLHope3JldHVybiBSWzBdPUNbMF0rQlswXSp6LFJbMV09Q1sxXStCWzFdKnosUlsyXT1DWzJdK0JbMl0qeixSWzNdPUNbM10rQlszXSp6LFJbNF09Q1s0XStCWzRdKnosUls1XT1DWzVdK0JbNV0qeixSfWZ1bmN0aW9uIEwoUixDKXtyZXR1cm4gUlswXT09PUNbMF0mJlJbMV09PT1DWzFdJiZSWzJdPT09Q1syXSYmUlszXT09PUNbM10mJlJbNF09PT1DWzRdJiZSWzVdPT09Q1s1XX1mdW5jdGlvbiBNKFIsQyl7dmFyIEI9UlswXSx6PVJbMV0sSz1SWzJdLFE9UlszXSxfPVJbNF0sRj1SWzVdLEc9Q1swXSxYPUNbMV0sWj1DWzJdLHR0PUNbM10sbnQ9Q1s0XSxxPUNbNV07cmV0dXJuIE1hdGguYWJzKEItRyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEIpLE1hdGguYWJzKEcpKSYmTWF0aC5hYnMoei1YKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeiksTWF0aC5hYnMoWCkpJiZNYXRoLmFicyhLLVopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKFEtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhRKSxNYXRoLmFicyh0dCkpJiZNYXRoLmFicyhfLW50KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMobnQpKSYmTWF0aC5hYnMoRi1xKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoRiksTWF0aC5hYnMocSkpfXZhciBJPXAsRD1ifSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImZyb21NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJub3JtYWxGcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJwcm9qZWN0aW9uIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gen0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gX30pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBGPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoRlsxXT0wLEZbMl09MCxGWzNdPTAsRls1XT0wLEZbNl09MCxGWzddPTApLEZbMF09MSxGWzRdPTEsRls4XT0xLEZ9ZnVuY3Rpb24gaShGLEcpe3JldHVybiBGWzBdPUdbMF0sRlsxXT1HWzFdLEZbMl09R1syXSxGWzNdPUdbNF0sRls0XT1HWzVdLEZbNV09R1s2XSxGWzZdPUdbOF0sRls3XT1HWzldLEZbOF09R1sxMF0sRn1mdW5jdGlvbiBhKEYpe3ZhciBHPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIEdbMF09RlswXSxHWzFdPUZbMV0sR1syXT1GWzJdLEdbM109RlszXSxHWzRdPUZbNF0sR1s1XT1GWzVdLEdbNl09Rls2XSxHWzddPUZbN10sR1s4XT1GWzhdLEd9ZnVuY3Rpb24gbChGLEcpe3JldHVybiBGWzBdPUdbMF0sRlsxXT1HWzFdLEZbMl09R1syXSxGWzNdPUdbM10sRls0XT1HWzRdLEZbNV09R1s1XSxGWzZdPUdbNl0sRls3XT1HWzddLEZbOF09R1s4XSxGfWZ1bmN0aW9uIHMoRixHLFgsWix0dCxudCxxLGh0LHV0KXt2YXIgaj1uZXcgci5BUlJBWV9UWVBFKDkpO3JldHVybiBqWzBdPUYsalsxXT1HLGpbMl09WCxqWzNdPVosals0XT10dCxqWzVdPW50LGpbNl09cSxqWzddPWh0LGpbOF09dXQsan1mdW5jdGlvbiBmKEYsRyxYLFosdHQsbnQscSxodCx1dCxqKXtyZXR1cm4gRlswXT1HLEZbMV09WCxGWzJdPVosRlszXT10dCxGWzRdPW50LEZbNV09cSxGWzZdPWh0LEZbN109dXQsRls4XT1qLEZ9ZnVuY3Rpb24gdihGKXtyZXR1cm4gRlswXT0xLEZbMV09MCxGWzJdPTAsRlszXT0wLEZbNF09MSxGWzVdPTAsRls2XT0wLEZbN109MCxGWzhdPTEsRn1mdW5jdGlvbiBkKEYsRyl7aWYoRj09PUcpe3ZhciBYPUdbMV0sWj1HWzJdLHR0PUdbNV07RlsxXT1HWzNdLEZbMl09R1s2XSxGWzNdPVgsRls1XT1HWzddLEZbNl09WixGWzddPXR0fWVsc2UgRlswXT1HWzBdLEZbMV09R1szXSxGWzJdPUdbNl0sRlszXT1HWzFdLEZbNF09R1s0XSxGWzVdPUdbN10sRls2XT1HWzJdLEZbN109R1s1XSxGWzhdPUdbOF07cmV0dXJuIEZ9ZnVuY3Rpb24gcChGLEcpe3ZhciBYPUdbMF0sWj1HWzFdLHR0PUdbMl0sbnQ9R1szXSxxPUdbNF0saHQ9R1s1XSx1dD1HWzZdLGo9R1s3XSxXPUdbOF0sVj1XKnEtaHQqaixKPS1XKm50K2h0KnV0LE49aipudC1xKnV0LCQ9WCpWK1oqSit0dCpOO3JldHVybiAkPygkPTEvJCxGWzBdPVYqJCxGWzFdPSgtVypaK3R0KmopKiQsRlsyXT0oaHQqWi10dCpxKSokLEZbM109SiokLEZbNF09KFcqWC10dCp1dCkqJCxGWzVdPSgtaHQqWCt0dCpudCkqJCxGWzZdPU4qJCxGWzddPSgtaipYK1oqdXQpKiQsRls4XT0ocSpYLVoqbnQpKiQsRik6bnVsbH1mdW5jdGlvbiB5KEYsRyl7dmFyIFg9R1swXSxaPUdbMV0sdHQ9R1syXSxudD1HWzNdLHE9R1s0XSxodD1HWzVdLHV0PUdbNl0saj1HWzddLFc9R1s4XTtyZXR1cm4gRlswXT1xKlctaHQqaixGWzFdPXR0KmotWipXLEZbMl09WipodC10dCpxLEZbM109aHQqdXQtbnQqVyxGWzRdPVgqVy10dCp1dCxGWzVdPXR0Km50LVgqaHQsRls2XT1udCpqLXEqdXQsRls3XT1aKnV0LVgqaixGWzhdPVgqcS1aKm50LEZ9ZnVuY3Rpb24gUChGKXt2YXIgRz1GWzBdLFg9RlsxXSxaPUZbMl0sdHQ9RlszXSxudD1GWzRdLHE9Rls1XSxodD1GWzZdLHV0PUZbN10saj1GWzhdO3JldHVybiBHKihqKm50LXEqdXQpK1gqKC1qKnR0K3EqaHQpK1oqKHV0KnR0LW50Kmh0KX1mdW5jdGlvbiB4KEYsRyxYKXt2YXIgWj1HWzBdLHR0PUdbMV0sbnQ9R1syXSxxPUdbM10saHQ9R1s0XSx1dD1HWzVdLGo9R1s2XSxXPUdbN10sVj1HWzhdLEo9WFswXSxOPVhbMV0sJD1YWzJdLFM9WFszXSxUPVhbNF0sdz1YWzVdLFU9WFs2XSxIPVhbN10sWT1YWzhdO3JldHVybiBGWzBdPUoqWitOKnErJCpqLEZbMV09Sip0dCtOKmh0KyQqVyxGWzJdPUoqbnQrTip1dCskKlYsRlszXT1TKlorVCpxK3cqaixGWzRdPVMqdHQrVCpodCt3KlcsRls1XT1TKm50K1QqdXQrdypWLEZbNl09VSpaK0gqcStZKmosRls3XT1VKnR0K0gqaHQrWSpXLEZbOF09VSpudCtIKnV0K1kqVixGfWZ1bmN0aW9uIG0oRixHLFgpe3ZhciBaPUdbMF0sdHQ9R1sxXSxudD1HWzJdLHE9R1szXSxodD1HWzRdLHV0PUdbNV0saj1HWzZdLFc9R1s3XSxWPUdbOF0sSj1YWzBdLE49WFsxXTtyZXR1cm4gRlswXT1aLEZbMV09dHQsRlsyXT1udCxGWzNdPXEsRls0XT1odCxGWzVdPXV0LEZbNl09SipaK04qcStqLEZbN109Sip0dCtOKmh0K1csRls4XT1KKm50K04qdXQrVixGfWZ1bmN0aW9uIE8oRixHLFgpe3ZhciBaPUdbMF0sdHQ9R1sxXSxudD1HWzJdLHE9R1szXSxodD1HWzRdLHV0PUdbNV0saj1HWzZdLFc9R1s3XSxWPUdbOF0sSj1NYXRoLnNpbihYKSxOPU1hdGguY29zKFgpO3JldHVybiBGWzBdPU4qWitKKnEsRlsxXT1OKnR0K0oqaHQsRlsyXT1OKm50K0oqdXQsRlszXT1OKnEtSipaLEZbNF09TipodC1KKnR0LEZbNV09Tip1dC1KKm50LEZbNl09aixGWzddPVcsRls4XT1WLEZ9ZnVuY3Rpb24gbyhGLEcsWCl7dmFyIFo9WFswXSx0dD1YWzFdO3JldHVybiBGWzBdPVoqR1swXSxGWzFdPVoqR1sxXSxGWzJdPVoqR1syXSxGWzNdPXR0KkdbM10sRls0XT10dCpHWzRdLEZbNV09dHQqR1s1XSxGWzZdPUdbNl0sRls3XT1HWzddLEZbOF09R1s4XSxGfWZ1bmN0aW9uIGgoRixHKXtyZXR1cm4gRlswXT0xLEZbMV09MCxGWzJdPTAsRlszXT0wLEZbNF09MSxGWzVdPTAsRls2XT1HWzBdLEZbN109R1sxXSxGWzhdPTEsRn1mdW5jdGlvbiBjKEYsRyl7dmFyIFg9TWF0aC5zaW4oRyksWj1NYXRoLmNvcyhHKTtyZXR1cm4gRlswXT1aLEZbMV09WCxGWzJdPTAsRlszXT0tWCxGWzRdPVosRls1XT0wLEZbNl09MCxGWzddPTAsRls4XT0xLEZ9ZnVuY3Rpb24gZyhGLEcpe3JldHVybiBGWzBdPUdbMF0sRlsxXT0wLEZbMl09MCxGWzNdPTAsRls0XT1HWzFdLEZbNV09MCxGWzZdPTAsRls3XT0wLEZbOF09MSxGfWZ1bmN0aW9uIGIoRixHKXtyZXR1cm4gRlswXT1HWzBdLEZbMV09R1sxXSxGWzJdPTAsRlszXT1HWzJdLEZbNF09R1szXSxGWzVdPTAsRls2XT1HWzRdLEZbN109R1s1XSxGWzhdPTEsRn1mdW5jdGlvbiBFKEYsRyl7dmFyIFg9R1swXSxaPUdbMV0sdHQ9R1syXSxudD1HWzNdLHE9WCtYLGh0PVorWix1dD10dCt0dCxqPVgqcSxXPVoqcSxWPVoqaHQsSj10dCpxLE49dHQqaHQsJD10dCp1dCxTPW50KnEsVD1udCpodCx3PW50KnV0O3JldHVybiBGWzBdPTEtVi0kLEZbM109Vy13LEZbNl09SitULEZbMV09Vyt3LEZbNF09MS1qLSQsRls3XT1OLVMsRlsyXT1KLVQsRls1XT1OK1MsRls4XT0xLWotVixGfWZ1bmN0aW9uIEEoRixHKXt2YXIgWD1HWzBdLFo9R1sxXSx0dD1HWzJdLG50PUdbM10scT1HWzRdLGh0PUdbNV0sdXQ9R1s2XSxqPUdbN10sVz1HWzhdLFY9R1s5XSxKPUdbMTBdLE49R1sxMV0sJD1HWzEyXSxTPUdbMTNdLFQ9R1sxNF0sdz1HWzE1XSxVPVgqaHQtWipxLEg9WCp1dC10dCpxLFk9WCpqLW50KnEsaz1aKnV0LXR0Kmh0LHJ0PVoqai1udCpodCxpdD10dCpqLW50KnV0LGx0PVcqUy1WKiQsZnQ9VypULUoqJCxvdD1XKnctTiokLHN0PVYqVC1KKlMsY3Q9Vip3LU4qUyxtdD1KKnctTipULHZ0PVUqbXQtSCpjdCtZKnN0K2sqb3QtcnQqZnQraXQqbHQ7cmV0dXJuIHZ0Pyh2dD0xL3Z0LEZbMF09KGh0Km10LXV0KmN0K2oqc3QpKnZ0LEZbMV09KHV0Km90LXEqbXQtaipmdCkqdnQsRlsyXT0ocSpjdC1odCpvdCtqKmx0KSp2dCxGWzNdPSh0dCpjdC1aKm10LW50KnN0KSp2dCxGWzRdPShYKm10LXR0Km90K250KmZ0KSp2dCxGWzVdPShaKm90LVgqY3QtbnQqbHQpKnZ0LEZbNl09KFMqaXQtVCpydCt3KmspKnZ0LEZbN109KFQqWS0kKml0LXcqSCkqdnQsRls4XT0oJCpydC1TKlkrdypVKSp2dCxGKTpudWxsfWZ1bmN0aW9uIEwoRixHLFgpe3JldHVybiBGWzBdPTIvRyxGWzFdPTAsRlsyXT0wLEZbM109MCxGWzRdPS0yL1gsRls1XT0wLEZbNl09LTEsRls3XT0xLEZbOF09MSxGfWZ1bmN0aW9uIE0oRil7cmV0dXJuIm1hdDMoIitGWzBdKyIsICIrRlsxXSsiLCAiK0ZbMl0rIiwgIitGWzNdKyIsICIrRls0XSsiLCAiK0ZbNV0rIiwgIitGWzZdKyIsICIrRls3XSsiLCAiK0ZbOF0rIikifWZ1bmN0aW9uIEkoRil7cmV0dXJuIE1hdGguaHlwb3QoRlswXSxGWzFdLEZbMl0sRlszXSxGWzRdLEZbNV0sRls2XSxGWzddLEZbOF0pfWZ1bmN0aW9uIEQoRixHLFgpe3JldHVybiBGWzBdPUdbMF0rWFswXSxGWzFdPUdbMV0rWFsxXSxGWzJdPUdbMl0rWFsyXSxGWzNdPUdbM10rWFszXSxGWzRdPUdbNF0rWFs0XSxGWzVdPUdbNV0rWFs1XSxGWzZdPUdbNl0rWFs2XSxGWzddPUdbN10rWFs3XSxGWzhdPUdbOF0rWFs4XSxGfWZ1bmN0aW9uIFIoRixHLFgpe3JldHVybiBGWzBdPUdbMF0tWFswXSxGWzFdPUdbMV0tWFsxXSxGWzJdPUdbMl0tWFsyXSxGWzNdPUdbM10tWFszXSxGWzRdPUdbNF0tWFs0XSxGWzVdPUdbNV0tWFs1XSxGWzZdPUdbNl0tWFs2XSxGWzddPUdbN10tWFs3XSxGWzhdPUdbOF0tWFs4XSxGfWZ1bmN0aW9uIEMoRixHLFgpe3JldHVybiBGWzBdPUdbMF0qWCxGWzFdPUdbMV0qWCxGWzJdPUdbMl0qWCxGWzNdPUdbM10qWCxGWzRdPUdbNF0qWCxGWzVdPUdbNV0qWCxGWzZdPUdbNl0qWCxGWzddPUdbN10qWCxGWzhdPUdbOF0qWCxGfWZ1bmN0aW9uIEIoRixHLFgsWil7cmV0dXJuIEZbMF09R1swXStYWzBdKlosRlsxXT1HWzFdK1hbMV0qWixGWzJdPUdbMl0rWFsyXSpaLEZbM109R1szXStYWzNdKlosRls0XT1HWzRdK1hbNF0qWixGWzVdPUdbNV0rWFs1XSpaLEZbNl09R1s2XStYWzZdKlosRls3XT1HWzddK1hbN10qWixGWzhdPUdbOF0rWFs4XSpaLEZ9ZnVuY3Rpb24geihGLEcpe3JldHVybiBGWzBdPT09R1swXSYmRlsxXT09PUdbMV0mJkZbMl09PT1HWzJdJiZGWzNdPT09R1szXSYmRls0XT09PUdbNF0mJkZbNV09PT1HWzVdJiZGWzZdPT09R1s2XSYmRls3XT09PUdbN10mJkZbOF09PT1HWzhdfWZ1bmN0aW9uIEsoRixHKXt2YXIgWD1GWzBdLFo9RlsxXSx0dD1GWzJdLG50PUZbM10scT1GWzRdLGh0PUZbNV0sdXQ9Rls2XSxqPUZbN10sVz1GWzhdLFY9R1swXSxKPUdbMV0sTj1HWzJdLCQ9R1szXSxTPUdbNF0sVD1HWzVdLHc9R1s2XSxVPUdbN10sSD1HWzhdO3JldHVybiBNYXRoLmFicyhYLVYpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhYKSxNYXRoLmFicyhWKSkmJk1hdGguYWJzKFotSik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFopLE1hdGguYWJzKEopKSYmTWF0aC5hYnModHQtTik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHR0KSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKG50LSQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhudCksTWF0aC5hYnMoJCkpJiZNYXRoLmFicyhxLVMpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyhTKSkmJk1hdGguYWJzKGh0LVQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhodCksTWF0aC5hYnMoVCkpJiZNYXRoLmFicyh1dC13KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModXQpLE1hdGguYWJzKHcpKSYmTWF0aC5hYnMoai1VKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaiksTWF0aC5hYnMoVSkpJiZNYXRoLmFicyhXLUgpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhXKSxNYXRoLmFicyhIKSl9dmFyIFE9eCxfPVJ9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiZnJvbVhSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJmcm9tWVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImZyb21aUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiZnJvbVF1YXQyIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImdldFRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImdldFNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZ2V0Um90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gen0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsImZyb21RdWF0IixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImZydXN0dW0iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwicGVyc3BlY3RpdmUiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwicGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXciLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwib3J0aG8iLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSx0LmQoZSwibG9va0F0IixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInRhcmdldFRvIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIG50fSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gdXR9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuICR9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgUz1uZXcgci5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s2XT0wLFNbN109MCxTWzhdPTAsU1s5XT0wLFNbMTFdPTAsU1sxMl09MCxTWzEzXT0wLFNbMTRdPTApLFNbMF09MSxTWzVdPTEsU1sxMF09MSxTWzE1XT0xLFN9ZnVuY3Rpb24gaShTKXt2YXIgVD1uZXcgci5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gVFswXT1TWzBdLFRbMV09U1sxXSxUWzJdPVNbMl0sVFszXT1TWzNdLFRbNF09U1s0XSxUWzVdPVNbNV0sVFs2XT1TWzZdLFRbN109U1s3XSxUWzhdPVNbOF0sVFs5XT1TWzldLFRbMTBdPVNbMTBdLFRbMTFdPVNbMTFdLFRbMTJdPVNbMTJdLFRbMTNdPVNbMTNdLFRbMTRdPVNbMTRdLFRbMTVdPVNbMTVdLFR9ZnVuY3Rpb24gYShTLFQpe3JldHVybiBTWzBdPVRbMF0sU1sxXT1UWzFdLFNbMl09VFsyXSxTWzNdPVRbM10sU1s0XT1UWzRdLFNbNV09VFs1XSxTWzZdPVRbNl0sU1s3XT1UWzddLFNbOF09VFs4XSxTWzldPVRbOV0sU1sxMF09VFsxMF0sU1sxMV09VFsxMV0sU1sxMl09VFsxMl0sU1sxM109VFsxM10sU1sxNF09VFsxNF0sU1sxNV09VFsxNV0sU31mdW5jdGlvbiBsKFMsVCx3LFUsSCxZLGsscnQsaXQsbHQsZnQsb3Qsc3QsY3QsbXQsdnQpe3ZhciBndD1uZXcgci5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gZ3RbMF09UyxndFsxXT1ULGd0WzJdPXcsZ3RbM109VSxndFs0XT1ILGd0WzVdPVksZ3RbNl09ayxndFs3XT1ydCxndFs4XT1pdCxndFs5XT1sdCxndFsxMF09ZnQsZ3RbMTFdPW90LGd0WzEyXT1zdCxndFsxM109Y3QsZ3RbMTRdPW10LGd0WzE1XT12dCxndH1mdW5jdGlvbiBzKFMsVCx3LFUsSCxZLGsscnQsaXQsbHQsZnQsb3Qsc3QsY3QsbXQsdnQsZ3Qpe3JldHVybiBTWzBdPVQsU1sxXT13LFNbMl09VSxTWzNdPUgsU1s0XT1ZLFNbNV09ayxTWzZdPXJ0LFNbN109aXQsU1s4XT1sdCxTWzldPWZ0LFNbMTBdPW90LFNbMTFdPXN0LFNbMTJdPWN0LFNbMTNdPW10LFNbMTRdPXZ0LFNbMTVdPWd0LFN9ZnVuY3Rpb24gZihTKXtyZXR1cm4gU1swXT0xLFNbMV09MCxTWzJdPTAsU1szXT0wLFNbNF09MCxTWzVdPTEsU1s2XT0wLFNbN109MCxTWzhdPTAsU1s5XT0wLFNbMTBdPTEsU1sxMV09MCxTWzEyXT0wLFNbMTNdPTAsU1sxNF09MCxTWzE1XT0xLFN9ZnVuY3Rpb24gdihTLFQpe2lmKFM9PT1UKXt2YXIgdz1UWzFdLFU9VFsyXSxIPVRbM10sWT1UWzZdLGs9VFs3XSxydD1UWzExXTtTWzFdPVRbNF0sU1syXT1UWzhdLFNbM109VFsxMl0sU1s0XT13LFNbNl09VFs5XSxTWzddPVRbMTNdLFNbOF09VSxTWzldPVksU1sxMV09VFsxNF0sU1sxMl09SCxTWzEzXT1rLFNbMTRdPXJ0fWVsc2UgU1swXT1UWzBdLFNbMV09VFs0XSxTWzJdPVRbOF0sU1szXT1UWzEyXSxTWzRdPVRbMV0sU1s1XT1UWzVdLFNbNl09VFs5XSxTWzddPVRbMTNdLFNbOF09VFsyXSxTWzldPVRbNl0sU1sxMF09VFsxMF0sU1sxMV09VFsxNF0sU1sxMl09VFszXSxTWzEzXT1UWzddLFNbMTRdPVRbMTFdLFNbMTVdPVRbMTVdO3JldHVybiBTfWZ1bmN0aW9uIGQoUyxUKXt2YXIgdz1UWzBdLFU9VFsxXSxIPVRbMl0sWT1UWzNdLGs9VFs0XSxydD1UWzVdLGl0PVRbNl0sbHQ9VFs3XSxmdD1UWzhdLG90PVRbOV0sc3Q9VFsxMF0sY3Q9VFsxMV0sbXQ9VFsxMl0sdnQ9VFsxM10sZ3Q9VFsxNF0sU3Q9VFsxNV0sQXQ9dypydC1VKmssUHQ9dyppdC1IKmssVHQ9dypsdC1ZKmssTXQ9VSppdC1IKnJ0LEV0PVUqbHQtWSpydCwkdD1IKmx0LVkqaXQsV3Q9ZnQqdnQtb3QqbXQsRnQ9ZnQqZ3Qtc3QqbXQsVXQ9ZnQqU3QtY3QqbXQsR3Q9b3QqZ3Qtc3QqdnQsSHQ9b3QqU3QtY3QqdnQsS3Q9c3QqU3QtY3QqZ3QsTHQ9QXQqS3QtUHQqSHQrVHQqR3QrTXQqVXQtRXQqRnQrJHQqV3Q7cmV0dXJuIEx0PyhMdD0xL0x0LFNbMF09KHJ0Kkt0LWl0Kkh0K2x0Kkd0KSpMdCxTWzFdPShIKkh0LVUqS3QtWSpHdCkqTHQsU1syXT0odnQqJHQtZ3QqRXQrU3QqTXQpKkx0LFNbM109KHN0KkV0LW90KiR0LWN0Kk10KSpMdCxTWzRdPShpdCpVdC1rKkt0LWx0KkZ0KSpMdCxTWzVdPSh3Kkt0LUgqVXQrWSpGdCkqTHQsU1s2XT0oZ3QqVHQtbXQqJHQtU3QqUHQpKkx0LFNbN109KGZ0KiR0LXN0KlR0K2N0KlB0KSpMdCxTWzhdPShrKkh0LXJ0KlV0K2x0Kld0KSpMdCxTWzldPShVKlV0LXcqSHQtWSpXdCkqTHQsU1sxMF09KG10KkV0LXZ0KlR0K1N0KkF0KSpMdCxTWzExXT0ob3QqVHQtZnQqRXQtY3QqQXQpKkx0LFNbMTJdPShydCpGdC1rKkd0LWl0Kld0KSpMdCxTWzEzXT0odypHdC1VKkZ0K0gqV3QpKkx0LFNbMTRdPSh2dCpQdC1tdCpNdC1ndCpBdCkqTHQsU1sxNV09KGZ0Kk10LW90KlB0K3N0KkF0KSpMdCxTKTpudWxsfWZ1bmN0aW9uIHAoUyxUKXt2YXIgdz1UWzBdLFU9VFsxXSxIPVRbMl0sWT1UWzNdLGs9VFs0XSxydD1UWzVdLGl0PVRbNl0sbHQ9VFs3XSxmdD1UWzhdLG90PVRbOV0sc3Q9VFsxMF0sY3Q9VFsxMV0sbXQ9VFsxMl0sdnQ9VFsxM10sZ3Q9VFsxNF0sU3Q9VFsxNV07cmV0dXJuIFNbMF09cnQqKHN0KlN0LWN0Kmd0KS1vdCooaXQqU3QtbHQqZ3QpK3Z0KihpdCpjdC1sdCpzdCksU1sxXT0tKFUqKHN0KlN0LWN0Kmd0KS1vdCooSCpTdC1ZKmd0KSt2dCooSCpjdC1ZKnN0KSksU1syXT1VKihpdCpTdC1sdCpndCktcnQqKEgqU3QtWSpndCkrdnQqKEgqbHQtWSppdCksU1szXT0tKFUqKGl0KmN0LWx0KnN0KS1ydCooSCpjdC1ZKnN0KStvdCooSCpsdC1ZKml0KSksU1s0XT0tKGsqKHN0KlN0LWN0Kmd0KS1mdCooaXQqU3QtbHQqZ3QpK210KihpdCpjdC1sdCpzdCkpLFNbNV09dyooc3QqU3QtY3QqZ3QpLWZ0KihIKlN0LVkqZ3QpK210KihIKmN0LVkqc3QpLFNbNl09LSh3KihpdCpTdC1sdCpndCktayooSCpTdC1ZKmd0KSttdCooSCpsdC1ZKml0KSksU1s3XT13KihpdCpjdC1sdCpzdCktayooSCpjdC1ZKnN0KStmdCooSCpsdC1ZKml0KSxTWzhdPWsqKG90KlN0LWN0KnZ0KS1mdCoocnQqU3QtbHQqdnQpK210KihydCpjdC1sdCpvdCksU1s5XT0tKHcqKG90KlN0LWN0KnZ0KS1mdCooVSpTdC1ZKnZ0KSttdCooVSpjdC1ZKm90KSksU1sxMF09dyoocnQqU3QtbHQqdnQpLWsqKFUqU3QtWSp2dCkrbXQqKFUqbHQtWSpydCksU1sxMV09LSh3KihydCpjdC1sdCpvdCktayooVSpjdC1ZKm90KStmdCooVSpsdC1ZKnJ0KSksU1sxMl09LShrKihvdCpndC1zdCp2dCktZnQqKHJ0Kmd0LWl0KnZ0KSttdCoocnQqc3QtaXQqb3QpKSxTWzEzXT13KihvdCpndC1zdCp2dCktZnQqKFUqZ3QtSCp2dCkrbXQqKFUqc3QtSCpvdCksU1sxNF09LSh3KihydCpndC1pdCp2dCktayooVSpndC1IKnZ0KSttdCooVSppdC1IKnJ0KSksU1sxNV09dyoocnQqc3QtaXQqb3QpLWsqKFUqc3QtSCpvdCkrZnQqKFUqaXQtSCpydCksU31mdW5jdGlvbiB5KFMpe3ZhciBUPVNbMF0sdz1TWzFdLFU9U1syXSxIPVNbM10sWT1TWzRdLGs9U1s1XSxydD1TWzZdLGl0PVNbN10sbHQ9U1s4XSxmdD1TWzldLG90PVNbMTBdLHN0PVNbMTFdLGN0PVNbMTJdLG10PVNbMTNdLHZ0PVNbMTRdLGd0PVNbMTVdLFN0PVQqay13KlksQXQ9VCpydC1VKlksUHQ9VCppdC1IKlksVHQ9dypydC1VKmssTXQ9dyppdC1IKmssRXQ9VSppdC1IKnJ0LCR0PWx0Km10LWZ0KmN0LFd0PWx0KnZ0LW90KmN0LEZ0PWx0Kmd0LXN0KmN0LFV0PWZ0KnZ0LW90Km10LEd0PWZ0Kmd0LXN0Km10LEh0PW90Kmd0LXN0KnZ0O3JldHVybiBTdCpIdC1BdCpHdCtQdCpVdCtUdCpGdC1NdCpXdCtFdCokdH1mdW5jdGlvbiBQKFMsVCx3KXt2YXIgVT1UWzBdLEg9VFsxXSxZPVRbMl0saz1UWzNdLHJ0PVRbNF0saXQ9VFs1XSxsdD1UWzZdLGZ0PVRbN10sb3Q9VFs4XSxzdD1UWzldLGN0PVRbMTBdLG10PVRbMTFdLHZ0PVRbMTJdLGd0PVRbMTNdLFN0PVRbMTRdLEF0PVRbMTVdLFB0PXdbMF0sVHQ9d1sxXSxNdD13WzJdLEV0PXdbM107cmV0dXJuIFNbMF09UHQqVStUdCpydCtNdCpvdCtFdCp2dCxTWzFdPVB0KkgrVHQqaXQrTXQqc3QrRXQqZ3QsU1syXT1QdCpZK1R0Kmx0K010KmN0K0V0KlN0LFNbM109UHQqaytUdCpmdCtNdCptdCtFdCpBdCxQdD13WzRdLFR0PXdbNV0sTXQ9d1s2XSxFdD13WzddLFNbNF09UHQqVStUdCpydCtNdCpvdCtFdCp2dCxTWzVdPVB0KkgrVHQqaXQrTXQqc3QrRXQqZ3QsU1s2XT1QdCpZK1R0Kmx0K010KmN0K0V0KlN0LFNbN109UHQqaytUdCpmdCtNdCptdCtFdCpBdCxQdD13WzhdLFR0PXdbOV0sTXQ9d1sxMF0sRXQ9d1sxMV0sU1s4XT1QdCpVK1R0KnJ0K010Km90K0V0KnZ0LFNbOV09UHQqSCtUdCppdCtNdCpzdCtFdCpndCxTWzEwXT1QdCpZK1R0Kmx0K010KmN0K0V0KlN0LFNbMTFdPVB0KmsrVHQqZnQrTXQqbXQrRXQqQXQsUHQ9d1sxMl0sVHQ9d1sxM10sTXQ9d1sxNF0sRXQ9d1sxNV0sU1sxMl09UHQqVStUdCpydCtNdCpvdCtFdCp2dCxTWzEzXT1QdCpIK1R0Kml0K010KnN0K0V0Kmd0LFNbMTRdPVB0KlkrVHQqbHQrTXQqY3QrRXQqU3QsU1sxNV09UHQqaytUdCpmdCtNdCptdCtFdCpBdCxTfWZ1bmN0aW9uIHgoUyxULHcpe3ZhciBVPXdbMF0sSD13WzFdLFk9d1syXSxrLHJ0LGl0LGx0LGZ0LG90LHN0LGN0LG10LHZ0LGd0LFN0O3JldHVybiBUPT09Uz8oU1sxMl09VFswXSpVK1RbNF0qSCtUWzhdKlkrVFsxMl0sU1sxM109VFsxXSpVK1RbNV0qSCtUWzldKlkrVFsxM10sU1sxNF09VFsyXSpVK1RbNl0qSCtUWzEwXSpZK1RbMTRdLFNbMTVdPVRbM10qVStUWzddKkgrVFsxMV0qWStUWzE1XSk6KGs9VFswXSxydD1UWzFdLGl0PVRbMl0sbHQ9VFszXSxmdD1UWzRdLG90PVRbNV0sc3Q9VFs2XSxjdD1UWzddLG10PVRbOF0sdnQ9VFs5XSxndD1UWzEwXSxTdD1UWzExXSxTWzBdPWssU1sxXT1ydCxTWzJdPWl0LFNbM109bHQsU1s0XT1mdCxTWzVdPW90LFNbNl09c3QsU1s3XT1jdCxTWzhdPW10LFNbOV09dnQsU1sxMF09Z3QsU1sxMV09U3QsU1sxMl09aypVK2Z0KkgrbXQqWStUWzEyXSxTWzEzXT1ydCpVK290KkgrdnQqWStUWzEzXSxTWzE0XT1pdCpVK3N0KkgrZ3QqWStUWzE0XSxTWzE1XT1sdCpVK2N0KkgrU3QqWStUWzE1XSksU31mdW5jdGlvbiBtKFMsVCx3KXt2YXIgVT13WzBdLEg9d1sxXSxZPXdbMl07cmV0dXJuIFNbMF09VFswXSpVLFNbMV09VFsxXSpVLFNbMl09VFsyXSpVLFNbM109VFszXSpVLFNbNF09VFs0XSpILFNbNV09VFs1XSpILFNbNl09VFs2XSpILFNbN109VFs3XSpILFNbOF09VFs4XSpZLFNbOV09VFs5XSpZLFNbMTBdPVRbMTBdKlksU1sxMV09VFsxMV0qWSxTWzEyXT1UWzEyXSxTWzEzXT1UWzEzXSxTWzE0XT1UWzE0XSxTWzE1XT1UWzE1XSxTfWZ1bmN0aW9uIE8oUyxULHcsVSl7dmFyIEg9VVswXSxZPVVbMV0saz1VWzJdLHJ0PU1hdGguaHlwb3QoSCxZLGspLGl0LGx0LGZ0LG90LHN0LGN0LG10LHZ0LGd0LFN0LEF0LFB0LFR0LE10LEV0LCR0LFd0LEZ0LFV0LEd0LEh0LEt0LEx0LGt0O3JldHVybiBydDxyLkVQU0lMT04/bnVsbDoocnQ9MS9ydCxIKj1ydCxZKj1ydCxrKj1ydCxpdD1NYXRoLnNpbih3KSxsdD1NYXRoLmNvcyh3KSxmdD0xLWx0LG90PVRbMF0sc3Q9VFsxXSxjdD1UWzJdLG10PVRbM10sdnQ9VFs0XSxndD1UWzVdLFN0PVRbNl0sQXQ9VFs3XSxQdD1UWzhdLFR0PVRbOV0sTXQ9VFsxMF0sRXQ9VFsxMV0sJHQ9SCpIKmZ0K2x0LFd0PVkqSCpmdCtrKml0LEZ0PWsqSCpmdC1ZKml0LFV0PUgqWSpmdC1rKml0LEd0PVkqWSpmdCtsdCxIdD1rKlkqZnQrSCppdCxLdD1IKmsqZnQrWSppdCxMdD1ZKmsqZnQtSCppdCxrdD1rKmsqZnQrbHQsU1swXT1vdCokdCt2dCpXdCtQdCpGdCxTWzFdPXN0KiR0K2d0Kld0K1R0KkZ0LFNbMl09Y3QqJHQrU3QqV3QrTXQqRnQsU1szXT1tdCokdCtBdCpXdCtFdCpGdCxTWzRdPW90KlV0K3Z0Kkd0K1B0Kkh0LFNbNV09c3QqVXQrZ3QqR3QrVHQqSHQsU1s2XT1jdCpVdCtTdCpHdCtNdCpIdCxTWzddPW10KlV0K0F0Kkd0K0V0Kkh0LFNbOF09b3QqS3QrdnQqTHQrUHQqa3QsU1s5XT1zdCpLdCtndCpMdCtUdCprdCxTWzEwXT1jdCpLdCtTdCpMdCtNdCprdCxTWzExXT1tdCpLdCtBdCpMdCtFdCprdCxUIT09UyYmKFNbMTJdPVRbMTJdLFNbMTNdPVRbMTNdLFNbMTRdPVRbMTRdLFNbMTVdPVRbMTVdKSxTKX1mdW5jdGlvbiBvKFMsVCx3KXt2YXIgVT1NYXRoLnNpbih3KSxIPU1hdGguY29zKHcpLFk9VFs0XSxrPVRbNV0scnQ9VFs2XSxpdD1UWzddLGx0PVRbOF0sZnQ9VFs5XSxvdD1UWzEwXSxzdD1UWzExXTtyZXR1cm4gVCE9PVMmJihTWzBdPVRbMF0sU1sxXT1UWzFdLFNbMl09VFsyXSxTWzNdPVRbM10sU1sxMl09VFsxMl0sU1sxM109VFsxM10sU1sxNF09VFsxNF0sU1sxNV09VFsxNV0pLFNbNF09WSpIK2x0KlUsU1s1XT1rKkgrZnQqVSxTWzZdPXJ0Kkgrb3QqVSxTWzddPWl0Kkgrc3QqVSxTWzhdPWx0KkgtWSpVLFNbOV09ZnQqSC1rKlUsU1sxMF09b3QqSC1ydCpVLFNbMTFdPXN0KkgtaXQqVSxTfWZ1bmN0aW9uIGgoUyxULHcpe3ZhciBVPU1hdGguc2luKHcpLEg9TWF0aC5jb3ModyksWT1UWzBdLGs9VFsxXSxydD1UWzJdLGl0PVRbM10sbHQ9VFs4XSxmdD1UWzldLG90PVRbMTBdLHN0PVRbMTFdO3JldHVybiBUIT09UyYmKFNbNF09VFs0XSxTWzVdPVRbNV0sU1s2XT1UWzZdLFNbN109VFs3XSxTWzEyXT1UWzEyXSxTWzEzXT1UWzEzXSxTWzE0XT1UWzE0XSxTWzE1XT1UWzE1XSksU1swXT1ZKkgtbHQqVSxTWzFdPWsqSC1mdCpVLFNbMl09cnQqSC1vdCpVLFNbM109aXQqSC1zdCpVLFNbOF09WSpVK2x0KkgsU1s5XT1rKlUrZnQqSCxTWzEwXT1ydCpVK290KkgsU1sxMV09aXQqVStzdCpILFN9ZnVuY3Rpb24gYyhTLFQsdyl7dmFyIFU9TWF0aC5zaW4odyksSD1NYXRoLmNvcyh3KSxZPVRbMF0saz1UWzFdLHJ0PVRbMl0saXQ9VFszXSxsdD1UWzRdLGZ0PVRbNV0sb3Q9VFs2XSxzdD1UWzddO3JldHVybiBUIT09UyYmKFNbOF09VFs4XSxTWzldPVRbOV0sU1sxMF09VFsxMF0sU1sxMV09VFsxMV0sU1sxMl09VFsxMl0sU1sxM109VFsxM10sU1sxNF09VFsxNF0sU1sxNV09VFsxNV0pLFNbMF09WSpIK2x0KlUsU1sxXT1rKkgrZnQqVSxTWzJdPXJ0Kkgrb3QqVSxTWzNdPWl0Kkgrc3QqVSxTWzRdPWx0KkgtWSpVLFNbNV09ZnQqSC1rKlUsU1s2XT1vdCpILXJ0KlUsU1s3XT1zdCpILWl0KlUsU31mdW5jdGlvbiBnKFMsVCl7cmV0dXJuIFNbMF09MSxTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s1XT0xLFNbNl09MCxTWzddPTAsU1s4XT0wLFNbOV09MCxTWzEwXT0xLFNbMTFdPTAsU1sxMl09VFswXSxTWzEzXT1UWzFdLFNbMTRdPVRbMl0sU1sxNV09MSxTfWZ1bmN0aW9uIGIoUyxUKXtyZXR1cm4gU1swXT1UWzBdLFNbMV09MCxTWzJdPTAsU1szXT0wLFNbNF09MCxTWzVdPVRbMV0sU1s2XT0wLFNbN109MCxTWzhdPTAsU1s5XT0wLFNbMTBdPVRbMl0sU1sxMV09MCxTWzEyXT0wLFNbMTNdPTAsU1sxNF09MCxTWzE1XT0xLFN9ZnVuY3Rpb24gRShTLFQsdyl7dmFyIFU9d1swXSxIPXdbMV0sWT13WzJdLGs9TWF0aC5oeXBvdChVLEgsWSkscnQsaXQsbHQ7cmV0dXJuIGs8ci5FUFNJTE9OP251bGw6KGs9MS9rLFUqPWssSCo9ayxZKj1rLHJ0PU1hdGguc2luKFQpLGl0PU1hdGguY29zKFQpLGx0PTEtaXQsU1swXT1VKlUqbHQraXQsU1sxXT1IKlUqbHQrWSpydCxTWzJdPVkqVSpsdC1IKnJ0LFNbM109MCxTWzRdPVUqSCpsdC1ZKnJ0LFNbNV09SCpIKmx0K2l0LFNbNl09WSpIKmx0K1UqcnQsU1s3XT0wLFNbOF09VSpZKmx0K0gqcnQsU1s5XT1IKlkqbHQtVSpydCxTWzEwXT1ZKlkqbHQraXQsU1sxMV09MCxTWzEyXT0wLFNbMTNdPTAsU1sxNF09MCxTWzE1XT0xLFMpfWZ1bmN0aW9uIEEoUyxUKXt2YXIgdz1NYXRoLnNpbihUKSxVPU1hdGguY29zKFQpO3JldHVybiBTWzBdPTEsU1sxXT0wLFNbMl09MCxTWzNdPTAsU1s0XT0wLFNbNV09VSxTWzZdPXcsU1s3XT0wLFNbOF09MCxTWzldPS13LFNbMTBdPVUsU1sxMV09MCxTWzEyXT0wLFNbMTNdPTAsU1sxNF09MCxTWzE1XT0xLFN9ZnVuY3Rpb24gTChTLFQpe3ZhciB3PU1hdGguc2luKFQpLFU9TWF0aC5jb3MoVCk7cmV0dXJuIFNbMF09VSxTWzFdPTAsU1syXT0tdyxTWzNdPTAsU1s0XT0wLFNbNV09MSxTWzZdPTAsU1s3XT0wLFNbOF09dyxTWzldPTAsU1sxMF09VSxTWzExXT0wLFNbMTJdPTAsU1sxM109MCxTWzE0XT0wLFNbMTVdPTEsU31mdW5jdGlvbiBNKFMsVCl7dmFyIHc9TWF0aC5zaW4oVCksVT1NYXRoLmNvcyhUKTtyZXR1cm4gU1swXT1VLFNbMV09dyxTWzJdPTAsU1szXT0wLFNbNF09LXcsU1s1XT1VLFNbNl09MCxTWzddPTAsU1s4XT0wLFNbOV09MCxTWzEwXT0xLFNbMTFdPTAsU1sxMl09MCxTWzEzXT0wLFNbMTRdPTAsU1sxNV09MSxTfWZ1bmN0aW9uIEkoUyxULHcpe3ZhciBVPVRbMF0sSD1UWzFdLFk9VFsyXSxrPVRbM10scnQ9VStVLGl0PUgrSCxsdD1ZK1ksZnQ9VSpydCxvdD1VKml0LHN0PVUqbHQsY3Q9SCppdCxtdD1IKmx0LHZ0PVkqbHQsZ3Q9aypydCxTdD1rKml0LEF0PWsqbHQ7cmV0dXJuIFNbMF09MS0oY3QrdnQpLFNbMV09b3QrQXQsU1syXT1zdC1TdCxTWzNdPTAsU1s0XT1vdC1BdCxTWzVdPTEtKGZ0K3Z0KSxTWzZdPW10K2d0LFNbN109MCxTWzhdPXN0K1N0LFNbOV09bXQtZ3QsU1sxMF09MS0oZnQrY3QpLFNbMTFdPTAsU1sxMl09d1swXSxTWzEzXT13WzFdLFNbMTRdPXdbMl0sU1sxNV09MSxTfWZ1bmN0aW9uIEQoUyxUKXt2YXIgdz1uZXcgci5BUlJBWV9UWVBFKDMpLFU9LVRbMF0sSD0tVFsxXSxZPS1UWzJdLGs9VFszXSxydD1UWzRdLGl0PVRbNV0sbHQ9VFs2XSxmdD1UWzddLG90PVUqVStIKkgrWSpZK2sqaztyZXR1cm4gb3Q+MD8od1swXT0ocnQqaytmdCpVK2l0KlktbHQqSCkqMi9vdCx3WzFdPShpdCprK2Z0KkgrbHQqVS1ydCpZKSoyL290LHdbMl09KGx0KmsrZnQqWStydCpILWl0KlUpKjIvb3QpOih3WzBdPShydCprK2Z0KlUraXQqWS1sdCpIKSoyLHdbMV09KGl0KmsrZnQqSCtsdCpVLXJ0KlkpKjIsd1syXT0obHQqaytmdCpZK3J0KkgtaXQqVSkqMiksSShTLFQsdyksU31mdW5jdGlvbiBSKFMsVCl7cmV0dXJuIFNbMF09VFsxMl0sU1sxXT1UWzEzXSxTWzJdPVRbMTRdLFN9ZnVuY3Rpb24gQyhTLFQpe3ZhciB3PVRbMF0sVT1UWzFdLEg9VFsyXSxZPVRbNF0saz1UWzVdLHJ0PVRbNl0saXQ9VFs4XSxsdD1UWzldLGZ0PVRbMTBdO3JldHVybiBTWzBdPU1hdGguaHlwb3QodyxVLEgpLFNbMV09TWF0aC5oeXBvdChZLGsscnQpLFNbMl09TWF0aC5oeXBvdChpdCxsdCxmdCksU31mdW5jdGlvbiBCKFMsVCl7dmFyIHc9bmV3IHIuQVJSQVlfVFlQRSgzKTtDKHcsVCk7dmFyIFU9MS93WzBdLEg9MS93WzFdLFk9MS93WzJdLGs9VFswXSpVLHJ0PVRbMV0qSCxpdD1UWzJdKlksbHQ9VFs0XSpVLGZ0PVRbNV0qSCxvdD1UWzZdKlksc3Q9VFs4XSpVLGN0PVRbOV0qSCxtdD1UWzEwXSpZLHZ0PWsrZnQrbXQsZ3Q9MDtyZXR1cm4gdnQ+MD8oZ3Q9TWF0aC5zcXJ0KHZ0KzEpKjIsU1szXT0uMjUqZ3QsU1swXT0ob3QtY3QpL2d0LFNbMV09KHN0LWl0KS9ndCxTWzJdPShydC1sdCkvZ3QpOms+ZnQmJms+bXQ/KGd0PU1hdGguc3FydCgxK2stZnQtbXQpKjIsU1szXT0ob3QtY3QpL2d0LFNbMF09LjI1Kmd0LFNbMV09KHJ0K2x0KS9ndCxTWzJdPShzdCtpdCkvZ3QpOmZ0Pm10PyhndD1NYXRoLnNxcnQoMStmdC1rLW10KSoyLFNbM109KHN0LWl0KS9ndCxTWzBdPShydCtsdCkvZ3QsU1sxXT0uMjUqZ3QsU1syXT0ob3QrY3QpL2d0KTooZ3Q9TWF0aC5zcXJ0KDErbXQtay1mdCkqMixTWzNdPShydC1sdCkvZ3QsU1swXT0oc3QraXQpL2d0LFNbMV09KG90K2N0KS9ndCxTWzJdPS4yNSpndCksU31mdW5jdGlvbiB6KFMsVCx3LFUpe3ZhciBIPVRbMF0sWT1UWzFdLGs9VFsyXSxydD1UWzNdLGl0PUgrSCxsdD1ZK1ksZnQ9aytrLG90PUgqaXQsc3Q9SCpsdCxjdD1IKmZ0LG10PVkqbHQsdnQ9WSpmdCxndD1rKmZ0LFN0PXJ0Kml0LEF0PXJ0Kmx0LFB0PXJ0KmZ0LFR0PVVbMF0sTXQ9VVsxXSxFdD1VWzJdO3JldHVybiBTWzBdPSgxLShtdCtndCkpKlR0LFNbMV09KHN0K1B0KSpUdCxTWzJdPShjdC1BdCkqVHQsU1szXT0wLFNbNF09KHN0LVB0KSpNdCxTWzVdPSgxLShvdCtndCkpKk10LFNbNl09KHZ0K1N0KSpNdCxTWzddPTAsU1s4XT0oY3QrQXQpKkV0LFNbOV09KHZ0LVN0KSpFdCxTWzEwXT0oMS0ob3QrbXQpKSpFdCxTWzExXT0wLFNbMTJdPXdbMF0sU1sxM109d1sxXSxTWzE0XT13WzJdLFNbMTVdPTEsU31mdW5jdGlvbiBLKFMsVCx3LFUsSCl7dmFyIFk9VFswXSxrPVRbMV0scnQ9VFsyXSxpdD1UWzNdLGx0PVkrWSxmdD1rK2ssb3Q9cnQrcnQsc3Q9WSpsdCxjdD1ZKmZ0LG10PVkqb3QsdnQ9aypmdCxndD1rKm90LFN0PXJ0Km90LEF0PWl0Kmx0LFB0PWl0KmZ0LFR0PWl0Km90LE10PVVbMF0sRXQ9VVsxXSwkdD1VWzJdLFd0PUhbMF0sRnQ9SFsxXSxVdD1IWzJdLEd0PSgxLSh2dCtTdCkpKk10LEh0PShjdCtUdCkqTXQsS3Q9KG10LVB0KSpNdCxMdD0oY3QtVHQpKkV0LGt0PSgxLShzdCtTdCkpKkV0LFRlPShndCtBdCkqRXQsTWU9KG10K1B0KSokdCxuaT0oZ3QtQXQpKiR0LGlpPSgxLShzdCt2dCkpKiR0O3JldHVybiBTWzBdPUd0LFNbMV09SHQsU1syXT1LdCxTWzNdPTAsU1s0XT1MdCxTWzVdPWt0LFNbNl09VGUsU1s3XT0wLFNbOF09TWUsU1s5XT1uaSxTWzEwXT1paSxTWzExXT0wLFNbMTJdPXdbMF0rV3QtKEd0Kld0K0x0KkZ0K01lKlV0KSxTWzEzXT13WzFdK0Z0LShIdCpXdCtrdCpGdCtuaSpVdCksU1sxNF09d1syXStVdC0oS3QqV3QrVGUqRnQraWkqVXQpLFNbMTVdPTEsU31mdW5jdGlvbiBRKFMsVCl7dmFyIHc9VFswXSxVPVRbMV0sSD1UWzJdLFk9VFszXSxrPXcrdyxydD1VK1UsaXQ9SCtILGx0PXcqayxmdD1VKmssb3Q9VSpydCxzdD1IKmssY3Q9SCpydCxtdD1IKml0LHZ0PVkqayxndD1ZKnJ0LFN0PVkqaXQ7cmV0dXJuIFNbMF09MS1vdC1tdCxTWzFdPWZ0K1N0LFNbMl09c3QtZ3QsU1szXT0wLFNbNF09ZnQtU3QsU1s1XT0xLWx0LW10LFNbNl09Y3QrdnQsU1s3XT0wLFNbOF09c3QrZ3QsU1s5XT1jdC12dCxTWzEwXT0xLWx0LW90LFNbMTFdPTAsU1sxMl09MCxTWzEzXT0wLFNbMTRdPTAsU1sxNV09MSxTfWZ1bmN0aW9uIF8oUyxULHcsVSxILFksayl7dmFyIHJ0PTEvKHctVCksaXQ9MS8oSC1VKSxsdD0xLyhZLWspO3JldHVybiBTWzBdPVkqMipydCxTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s1XT1ZKjIqaXQsU1s2XT0wLFNbN109MCxTWzhdPSh3K1QpKnJ0LFNbOV09KEgrVSkqaXQsU1sxMF09KGsrWSkqbHQsU1sxMV09LTEsU1sxMl09MCxTWzEzXT0wLFNbMTRdPWsqWSoyKmx0LFNbMTVdPTAsU31mdW5jdGlvbiBGKFMsVCx3LFUsSCl7dmFyIFk9MS9NYXRoLnRhbihULzIpLGs7cmV0dXJuIFNbMF09WS93LFNbMV09MCxTWzJdPTAsU1szXT0wLFNbNF09MCxTWzVdPVksU1s2XT0wLFNbN109MCxTWzhdPTAsU1s5XT0wLFNbMTFdPS0xLFNbMTJdPTAsU1sxM109MCxTWzE1XT0wLEghPW51bGwmJkghPT0xLzA/KGs9MS8oVS1IKSxTWzEwXT0oSCtVKSprLFNbMTRdPTIqSCpVKmspOihTWzEwXT0tMSxTWzE0XT0tMipVKSxTfWZ1bmN0aW9uIEcoUyxULHcsVSl7dmFyIEg9TWF0aC50YW4oVC51cERlZ3JlZXMqTWF0aC5QSS8xODApLFk9TWF0aC50YW4oVC5kb3duRGVncmVlcypNYXRoLlBJLzE4MCksaz1NYXRoLnRhbihULmxlZnREZWdyZWVzKk1hdGguUEkvMTgwKSxydD1NYXRoLnRhbihULnJpZ2h0RGVncmVlcypNYXRoLlBJLzE4MCksaXQ9Mi8oaytydCksbHQ9Mi8oSCtZKTtyZXR1cm4gU1swXT1pdCxTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s1XT1sdCxTWzZdPTAsU1s3XT0wLFNbOF09LSgoay1ydCkqaXQqLjUpLFNbOV09KEgtWSkqbHQqLjUsU1sxMF09VS8ody1VKSxTWzExXT0tMSxTWzEyXT0wLFNbMTNdPTAsU1sxNF09VSp3Lyh3LVUpLFNbMTVdPTAsU31mdW5jdGlvbiBYKFMsVCx3LFUsSCxZLGspe3ZhciBydD0xLyhULXcpLGl0PTEvKFUtSCksbHQ9MS8oWS1rKTtyZXR1cm4gU1swXT0tMipydCxTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s1XT0tMippdCxTWzZdPTAsU1s3XT0wLFNbOF09MCxTWzldPTAsU1sxMF09MipsdCxTWzExXT0wLFNbMTJdPShUK3cpKnJ0LFNbMTNdPShIK1UpKml0LFNbMTRdPShrK1kpKmx0LFNbMTVdPTEsU31mdW5jdGlvbiBaKFMsVCx3LFUpe3ZhciBILFksayxydCxpdCxsdCxmdCxvdCxzdCxjdCxtdD1UWzBdLHZ0PVRbMV0sZ3Q9VFsyXSxTdD1VWzBdLEF0PVVbMV0sUHQ9VVsyXSxUdD13WzBdLE10PXdbMV0sRXQ9d1syXTtyZXR1cm4gTWF0aC5hYnMobXQtVHQpPHIuRVBTSUxPTiYmTWF0aC5hYnModnQtTXQpPHIuRVBTSUxPTiYmTWF0aC5hYnMoZ3QtRXQpPHIuRVBTSUxPTj9mKFMpOihmdD1tdC1UdCxvdD12dC1NdCxzdD1ndC1FdCxjdD0xL01hdGguaHlwb3QoZnQsb3Qsc3QpLGZ0Kj1jdCxvdCo9Y3Qsc3QqPWN0LEg9QXQqc3QtUHQqb3QsWT1QdCpmdC1TdCpzdCxrPVN0Km90LUF0KmZ0LGN0PU1hdGguaHlwb3QoSCxZLGspLGN0PyhjdD0xL2N0LEgqPWN0LFkqPWN0LGsqPWN0KTooSD0wLFk9MCxrPTApLHJ0PW90Kmstc3QqWSxpdD1zdCpILWZ0KmssbHQ9ZnQqWS1vdCpILGN0PU1hdGguaHlwb3QocnQsaXQsbHQpLGN0PyhjdD0xL2N0LHJ0Kj1jdCxpdCo9Y3QsbHQqPWN0KToocnQ9MCxpdD0wLGx0PTApLFNbMF09SCxTWzFdPXJ0LFNbMl09ZnQsU1szXT0wLFNbNF09WSxTWzVdPWl0LFNbNl09b3QsU1s3XT0wLFNbOF09ayxTWzldPWx0LFNbMTBdPXN0LFNbMTFdPTAsU1sxMl09LShIKm10K1kqdnQraypndCksU1sxM109LShydCptdCtpdCp2dCtsdCpndCksU1sxNF09LShmdCptdCtvdCp2dCtzdCpndCksU1sxNV09MSxTKX1mdW5jdGlvbiB0dChTLFQsdyxVKXt2YXIgSD1UWzBdLFk9VFsxXSxrPVRbMl0scnQ9VVswXSxpdD1VWzFdLGx0PVVbMl0sZnQ9SC13WzBdLG90PVktd1sxXSxzdD1rLXdbMl0sY3Q9ZnQqZnQrb3Qqb3Qrc3Qqc3Q7Y3Q+MCYmKGN0PTEvTWF0aC5zcXJ0KGN0KSxmdCo9Y3Qsb3QqPWN0LHN0Kj1jdCk7dmFyIG10PWl0KnN0LWx0Km90LHZ0PWx0KmZ0LXJ0KnN0LGd0PXJ0Km90LWl0KmZ0O3JldHVybiBjdD1tdCptdCt2dCp2dCtndCpndCxjdD4wJiYoY3Q9MS9NYXRoLnNxcnQoY3QpLG10Kj1jdCx2dCo9Y3QsZ3QqPWN0KSxTWzBdPW10LFNbMV09dnQsU1syXT1ndCxTWzNdPTAsU1s0XT1vdCpndC1zdCp2dCxTWzVdPXN0Km10LWZ0Kmd0LFNbNl09ZnQqdnQtb3QqbXQsU1s3XT0wLFNbOF09ZnQsU1s5XT1vdCxTWzEwXT1zdCxTWzExXT0wLFNbMTJdPUgsU1sxM109WSxTWzE0XT1rLFNbMTVdPTEsU31mdW5jdGlvbiBudChTKXtyZXR1cm4ibWF0NCgiK1NbMF0rIiwgIitTWzFdKyIsICIrU1syXSsiLCAiK1NbM10rIiwgIitTWzRdKyIsICIrU1s1XSsiLCAiK1NbNl0rIiwgIitTWzddKyIsICIrU1s4XSsiLCAiK1NbOV0rIiwgIitTWzEwXSsiLCAiK1NbMTFdKyIsICIrU1sxMl0rIiwgIitTWzEzXSsiLCAiK1NbMTRdKyIsICIrU1sxNV0rIikifWZ1bmN0aW9uIHEoUyl7cmV0dXJuIE1hdGguaHlwb3QoU1swXSxTWzFdLFNbMl0sU1szXSxTWzRdLFNbNV0sU1s2XSxTWzddLFNbOF0sU1s5XSxTWzEwXSxTWzExXSxTWzEyXSxTWzEzXSxTWzE0XSxTWzE1XSl9ZnVuY3Rpb24gaHQoUyxULHcpe3JldHVybiBTWzBdPVRbMF0rd1swXSxTWzFdPVRbMV0rd1sxXSxTWzJdPVRbMl0rd1syXSxTWzNdPVRbM10rd1szXSxTWzRdPVRbNF0rd1s0XSxTWzVdPVRbNV0rd1s1XSxTWzZdPVRbNl0rd1s2XSxTWzddPVRbN10rd1s3XSxTWzhdPVRbOF0rd1s4XSxTWzldPVRbOV0rd1s5XSxTWzEwXT1UWzEwXSt3WzEwXSxTWzExXT1UWzExXSt3WzExXSxTWzEyXT1UWzEyXSt3WzEyXSxTWzEzXT1UWzEzXSt3WzEzXSxTWzE0XT1UWzE0XSt3WzE0XSxTWzE1XT1UWzE1XSt3WzE1XSxTfWZ1bmN0aW9uIHV0KFMsVCx3KXtyZXR1cm4gU1swXT1UWzBdLXdbMF0sU1sxXT1UWzFdLXdbMV0sU1syXT1UWzJdLXdbMl0sU1szXT1UWzNdLXdbM10sU1s0XT1UWzRdLXdbNF0sU1s1XT1UWzVdLXdbNV0sU1s2XT1UWzZdLXdbNl0sU1s3XT1UWzddLXdbN10sU1s4XT1UWzhdLXdbOF0sU1s5XT1UWzldLXdbOV0sU1sxMF09VFsxMF0td1sxMF0sU1sxMV09VFsxMV0td1sxMV0sU1sxMl09VFsxMl0td1sxMl0sU1sxM109VFsxM10td1sxM10sU1sxNF09VFsxNF0td1sxNF0sU1sxNV09VFsxNV0td1sxNV0sU31mdW5jdGlvbiBqKFMsVCx3KXtyZXR1cm4gU1swXT1UWzBdKncsU1sxXT1UWzFdKncsU1syXT1UWzJdKncsU1szXT1UWzNdKncsU1s0XT1UWzRdKncsU1s1XT1UWzVdKncsU1s2XT1UWzZdKncsU1s3XT1UWzddKncsU1s4XT1UWzhdKncsU1s5XT1UWzldKncsU1sxMF09VFsxMF0qdyxTWzExXT1UWzExXSp3LFNbMTJdPVRbMTJdKncsU1sxM109VFsxM10qdyxTWzE0XT1UWzE0XSp3LFNbMTVdPVRbMTVdKncsU31mdW5jdGlvbiBXKFMsVCx3LFUpe3JldHVybiBTWzBdPVRbMF0rd1swXSpVLFNbMV09VFsxXSt3WzFdKlUsU1syXT1UWzJdK3dbMl0qVSxTWzNdPVRbM10rd1szXSpVLFNbNF09VFs0XSt3WzRdKlUsU1s1XT1UWzVdK3dbNV0qVSxTWzZdPVRbNl0rd1s2XSpVLFNbN109VFs3XSt3WzddKlUsU1s4XT1UWzhdK3dbOF0qVSxTWzldPVRbOV0rd1s5XSpVLFNbMTBdPVRbMTBdK3dbMTBdKlUsU1sxMV09VFsxMV0rd1sxMV0qVSxTWzEyXT1UWzEyXSt3WzEyXSpVLFNbMTNdPVRbMTNdK3dbMTNdKlUsU1sxNF09VFsxNF0rd1sxNF0qVSxTWzE1XT1UWzE1XSt3WzE1XSpVLFN9ZnVuY3Rpb24gVihTLFQpe3JldHVybiBTWzBdPT09VFswXSYmU1sxXT09PVRbMV0mJlNbMl09PT1UWzJdJiZTWzNdPT09VFszXSYmU1s0XT09PVRbNF0mJlNbNV09PT1UWzVdJiZTWzZdPT09VFs2XSYmU1s3XT09PVRbN10mJlNbOF09PT1UWzhdJiZTWzldPT09VFs5XSYmU1sxMF09PT1UWzEwXSYmU1sxMV09PT1UWzExXSYmU1sxMl09PT1UWzEyXSYmU1sxM109PT1UWzEzXSYmU1sxNF09PT1UWzE0XSYmU1sxNV09PT1UWzE1XX1mdW5jdGlvbiBKKFMsVCl7dmFyIHc9U1swXSxVPVNbMV0sSD1TWzJdLFk9U1szXSxrPVNbNF0scnQ9U1s1XSxpdD1TWzZdLGx0PVNbN10sZnQ9U1s4XSxvdD1TWzldLHN0PVNbMTBdLGN0PVNbMTFdLG10PVNbMTJdLHZ0PVNbMTNdLGd0PVNbMTRdLFN0PVNbMTVdLEF0PVRbMF0sUHQ9VFsxXSxUdD1UWzJdLE10PVRbM10sRXQ9VFs0XSwkdD1UWzVdLFd0PVRbNl0sRnQ9VFs3XSxVdD1UWzhdLEd0PVRbOV0sSHQ9VFsxMF0sS3Q9VFsxMV0sTHQ9VFsxMl0sa3Q9VFsxM10sVGU9VFsxNF0sTWU9VFsxNV07cmV0dXJuIE1hdGguYWJzKHctQXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhBdCkpJiZNYXRoLmFicyhVLVB0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoUHQpKSYmTWF0aC5hYnMoSC1UdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEgpLE1hdGguYWJzKFR0KSkmJk1hdGguYWJzKFktTXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhZKSxNYXRoLmFicyhNdCkpJiZNYXRoLmFicyhrLUV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoayksTWF0aC5hYnMoRXQpKSYmTWF0aC5hYnMocnQtJHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhydCksTWF0aC5hYnMoJHQpKSYmTWF0aC5hYnMoaXQtV3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhpdCksTWF0aC5hYnMoV3QpKSYmTWF0aC5hYnMobHQtRnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhsdCksTWF0aC5hYnMoRnQpKSYmTWF0aC5hYnMoZnQtVXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhmdCksTWF0aC5hYnMoVXQpKSYmTWF0aC5hYnMob3QtR3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhvdCksTWF0aC5hYnMoR3QpKSYmTWF0aC5hYnMoc3QtSHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhzdCksTWF0aC5hYnMoSHQpKSYmTWF0aC5hYnMoY3QtS3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhjdCksTWF0aC5hYnMoS3QpKSYmTWF0aC5hYnMobXQtTHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhtdCksTWF0aC5hYnMoTHQpKSYmTWF0aC5hYnModnQta3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh2dCksTWF0aC5hYnMoa3QpKSYmTWF0aC5hYnMoZ3QtVGUpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhndCksTWF0aC5hYnMoVGUpKSYmTWF0aC5hYnMoU3QtTWUpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhTdCksTWF0aC5hYnMoTWUpKX12YXIgTj1QLCQ9dXR9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXRBeGlzQW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZ2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImdldEFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImNhbGN1bGF0ZVciLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiZXhwIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImxuIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInBvdyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzbGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJmcm9tTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJmcm9tRXVsZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gen0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gS30pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFF9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIG50fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJyb3RhdGlvblRvIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJzcWxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHV0fSksdC5kKGUsInNldEF4ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KTt2YXIgcj10KDIpLG49dCg1KSxpPXQoOCksYT10KDkpO2Z1bmN0aW9uIGwoKXt2YXIgVz1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFdbMF09MCxXWzFdPTAsV1syXT0wKSxXWzNdPTEsV31mdW5jdGlvbiBzKFcpe3JldHVybiBXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzNdPTEsV31mdW5jdGlvbiBmKFcsVixKKXtKPUoqLjU7dmFyIE49TWF0aC5zaW4oSik7cmV0dXJuIFdbMF09TipWWzBdLFdbMV09TipWWzFdLFdbMl09TipWWzJdLFdbM109TWF0aC5jb3MoSiksV31mdW5jdGlvbiB2KFcsVil7dmFyIEo9TWF0aC5hY29zKFZbM10pKjIsTj1NYXRoLnNpbihKLzIpO3JldHVybiBOPnIuRVBTSUxPTj8oV1swXT1WWzBdL04sV1sxXT1WWzFdL04sV1syXT1WWzJdL04pOihXWzBdPTEsV1sxXT0wLFdbMl09MCksSn1mdW5jdGlvbiBkKFcsVil7dmFyIEo9UShXLFYpO3JldHVybiBNYXRoLmFjb3MoMipKKkotMSl9ZnVuY3Rpb24gcChXLFYsSil7dmFyIE49VlswXSwkPVZbMV0sUz1WWzJdLFQ9VlszXSx3PUpbMF0sVT1KWzFdLEg9SlsyXSxZPUpbM107cmV0dXJuIFdbMF09TipZK1QqdyskKkgtUypVLFdbMV09JCpZK1QqVStTKnctTipILFdbMl09UypZK1QqSCtOKlUtJCp3LFdbM109VCpZLU4qdy0kKlUtUypILFd9ZnVuY3Rpb24geShXLFYsSil7Sio9LjU7dmFyIE49VlswXSwkPVZbMV0sUz1WWzJdLFQ9VlszXSx3PU1hdGguc2luKEopLFU9TWF0aC5jb3MoSik7cmV0dXJuIFdbMF09TipVK1QqdyxXWzFdPSQqVStTKncsV1syXT1TKlUtJCp3LFdbM109VCpVLU4qdyxXfWZ1bmN0aW9uIFAoVyxWLEope0oqPS41O3ZhciBOPVZbMF0sJD1WWzFdLFM9VlsyXSxUPVZbM10sdz1NYXRoLnNpbihKKSxVPU1hdGguY29zKEopO3JldHVybiBXWzBdPU4qVS1TKncsV1sxXT0kKlUrVCp3LFdbMl09UypVK04qdyxXWzNdPVQqVS0kKncsV31mdW5jdGlvbiB4KFcsVixKKXtKKj0uNTt2YXIgTj1WWzBdLCQ9VlsxXSxTPVZbMl0sVD1WWzNdLHc9TWF0aC5zaW4oSiksVT1NYXRoLmNvcyhKKTtyZXR1cm4gV1swXT1OKlUrJCp3LFdbMV09JCpVLU4qdyxXWzJdPVMqVStUKncsV1szXT1UKlUtUyp3LFd9ZnVuY3Rpb24gbShXLFYpe3ZhciBKPVZbMF0sTj1WWzFdLCQ9VlsyXTtyZXR1cm4gV1swXT1KLFdbMV09TixXWzJdPSQsV1szXT1NYXRoLnNxcnQoTWF0aC5hYnMoMS1KKkotTipOLSQqJCkpLFd9ZnVuY3Rpb24gTyhXLFYpe3ZhciBKPVZbMF0sTj1WWzFdLCQ9VlsyXSxTPVZbM10sVD1NYXRoLnNxcnQoSipKK04qTiskKiQpLHc9TWF0aC5leHAoUyksVT1UPjA/dypNYXRoLnNpbihUKS9UOjA7cmV0dXJuIFdbMF09SipVLFdbMV09TipVLFdbMl09JCpVLFdbM109dypNYXRoLmNvcyhUKSxXfWZ1bmN0aW9uIG8oVyxWKXt2YXIgSj1WWzBdLE49VlsxXSwkPVZbMl0sUz1WWzNdLFQ9TWF0aC5zcXJ0KEoqSitOKk4rJCokKSx3PVQ+MD9NYXRoLmF0YW4yKFQsUykvVDowO3JldHVybiBXWzBdPUoqdyxXWzFdPU4qdyxXWzJdPSQqdyxXWzNdPS41Kk1hdGgubG9nKEoqSitOKk4rJCokK1MqUyksV31mdW5jdGlvbiBoKFcsVixKKXtyZXR1cm4gbyhXLFYpLEsoVyxXLEopLE8oVyxXKSxXfWZ1bmN0aW9uIGMoVyxWLEosTil7dmFyICQ9VlswXSxTPVZbMV0sVD1WWzJdLHc9VlszXSxVPUpbMF0sSD1KWzFdLFk9SlsyXSxrPUpbM10scnQsaXQsbHQsZnQsb3Q7cmV0dXJuIGl0PSQqVStTKkgrVCpZK3cqayxpdDwwJiYoaXQ9LWl0LFU9LVUsSD0tSCxZPS1ZLGs9LWspLDEtaXQ+ci5FUFNJTE9OPyhydD1NYXRoLmFjb3MoaXQpLGx0PU1hdGguc2luKHJ0KSxmdD1NYXRoLnNpbigoMS1OKSpydCkvbHQsb3Q9TWF0aC5zaW4oTipydCkvbHQpOihmdD0xLU4sb3Q9TiksV1swXT1mdCokK290KlUsV1sxXT1mdCpTK290KkgsV1syXT1mdCpUK290KlksV1szXT1mdCp3K290KmssV31mdW5jdGlvbiBnKFcpe3ZhciBWPXIuUkFORE9NKCksSj1yLlJBTkRPTSgpLE49ci5SQU5ET00oKSwkPU1hdGguc3FydCgxLVYpLFM9TWF0aC5zcXJ0KFYpO3JldHVybiBXWzBdPSQqTWF0aC5zaW4oMipNYXRoLlBJKkopLFdbMV09JCpNYXRoLmNvcygyKk1hdGguUEkqSiksV1syXT1TKk1hdGguc2luKDIqTWF0aC5QSSpOKSxXWzNdPVMqTWF0aC5jb3MoMipNYXRoLlBJKk4pLFd9ZnVuY3Rpb24gYihXLFYpe3ZhciBKPVZbMF0sTj1WWzFdLCQ9VlsyXSxTPVZbM10sVD1KKkorTipOKyQqJCtTKlMsdz1UPzEvVDowO3JldHVybiBXWzBdPS1KKncsV1sxXT0tTip3LFdbMl09LSQqdyxXWzNdPVMqdyxXfWZ1bmN0aW9uIEUoVyxWKXtyZXR1cm4gV1swXT0tVlswXSxXWzFdPS1WWzFdLFdbMl09LVZbMl0sV1szXT1WWzNdLFd9ZnVuY3Rpb24gQShXLFYpe3ZhciBKPVZbMF0rVls0XStWWzhdLE47aWYoSj4wKU49TWF0aC5zcXJ0KEorMSksV1szXT0uNSpOLE49LjUvTixXWzBdPShWWzVdLVZbN10pKk4sV1sxXT0oVls2XS1WWzJdKSpOLFdbMl09KFZbMV0tVlszXSkqTjtlbHNle3ZhciAkPTA7Vls0XT5WWzBdJiYoJD0xKSxWWzhdPlZbJCozKyRdJiYoJD0yKTt2YXIgUz0oJCsxKSUzLFQ9KCQrMiklMztOPU1hdGguc3FydChWWyQqMyskXS1WW1MqMytTXS1WW1QqMytUXSsxKSxXWyRdPS41Kk4sTj0uNS9OLFdbM109KFZbUyozK1RdLVZbVCozK1NdKSpOLFdbU109KFZbUyozKyRdK1ZbJCozK1NdKSpOLFdbVF09KFZbVCozKyRdK1ZbJCozK1RdKSpOfXJldHVybiBXfWZ1bmN0aW9uIEwoVyxWLEosTil7dmFyICQ9LjUqTWF0aC5QSS8xODA7Vio9JCxKKj0kLE4qPSQ7dmFyIFM9TWF0aC5zaW4oViksVD1NYXRoLmNvcyhWKSx3PU1hdGguc2luKEopLFU9TWF0aC5jb3MoSiksSD1NYXRoLnNpbihOKSxZPU1hdGguY29zKE4pO3JldHVybiBXWzBdPVMqVSpZLVQqdypILFdbMV09VCp3KlkrUypVKkgsV1syXT1UKlUqSC1TKncqWSxXWzNdPVQqVSpZK1MqdypILFd9ZnVuY3Rpb24gTShXKXtyZXR1cm4icXVhdCgiK1dbMF0rIiwgIitXWzFdKyIsICIrV1syXSsiLCAiK1dbM10rIikifXZhciBJPWEuY2xvbmUsRD1hLmZyb21WYWx1ZXMsUj1hLmNvcHksQz1hLnNldCxCPWEuYWRkLHo9cCxLPWEuc2NhbGUsUT1hLmRvdCxfPWEubGVycCxGPWEubGVuZ3RoLEc9RixYPWEuc3F1YXJlZExlbmd0aCxaPVgsdHQ9YS5ub3JtYWxpemUsbnQ9YS5leGFjdEVxdWFscyxxPWEuZXF1YWxzLGh0PWZ1bmN0aW9uKCl7dmFyIFc9aS5jcmVhdGUoKSxWPWkuZnJvbVZhbHVlcygxLDAsMCksSj1pLmZyb21WYWx1ZXMoMCwxLDApO3JldHVybiBmdW5jdGlvbihOLCQsUyl7dmFyIFQ9aS5kb3QoJCxTKTtyZXR1cm4gVDwtLjk5OTk5OT8oaS5jcm9zcyhXLFYsJCksaS5sZW4oVyk8MWUtNiYmaS5jcm9zcyhXLEosJCksaS5ub3JtYWxpemUoVyxXKSxmKE4sVyxNYXRoLlBJKSxOKTpUPi45OTk5OTk/KE5bMF09MCxOWzFdPTAsTlsyXT0wLE5bM109MSxOKTooaS5jcm9zcyhXLCQsUyksTlswXT1XWzBdLE5bMV09V1sxXSxOWzJdPVdbMl0sTlszXT0xK1QsdHQoTixOKSl9fSgpLHV0PWZ1bmN0aW9uKCl7dmFyIFc9bCgpLFY9bCgpO3JldHVybiBmdW5jdGlvbihKLE4sJCxTLFQsdyl7cmV0dXJuIGMoVyxOLFQsdyksYyhWLCQsUyx3KSxjKEosVyxWLDIqdyooMS13KSksSn19KCksaj1mdW5jdGlvbigpe3ZhciBXPW4uY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKFYsSixOLCQpe3JldHVybiBXWzBdPU5bMF0sV1szXT1OWzFdLFdbNl09TlsyXSxXWzFdPSRbMF0sV1s0XT0kWzFdLFdbN109JFsyXSxXWzJdPS1KWzBdLFdbNV09LUpbMV0sV1s4XT0tSlsyXSx0dChWLEEoVixXKSl9fSgpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImhlcm1pdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiYmV6aWVyIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gen0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsInRyYW5zZm9ybU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIFF9KSx0LmQoZSwidHJhbnNmb3JtUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIG50fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiB1dH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgVD1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFRbMF09MCxUWzFdPTAsVFsyXT0wKSxUfWZ1bmN0aW9uIGkoVCl7dmFyIHc9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gd1swXT1UWzBdLHdbMV09VFsxXSx3WzJdPVRbMl0sd31mdW5jdGlvbiBhKFQpe3ZhciB3PVRbMF0sVT1UWzFdLEg9VFsyXTtyZXR1cm4gTWF0aC5oeXBvdCh3LFUsSCl9ZnVuY3Rpb24gbChULHcsVSl7dmFyIEg9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gSFswXT1ULEhbMV09dyxIWzJdPVUsSH1mdW5jdGlvbiBzKFQsdyl7cmV0dXJuIFRbMF09d1swXSxUWzFdPXdbMV0sVFsyXT13WzJdLFR9ZnVuY3Rpb24gZihULHcsVSxIKXtyZXR1cm4gVFswXT13LFRbMV09VSxUWzJdPUgsVH1mdW5jdGlvbiB2KFQsdyxVKXtyZXR1cm4gVFswXT13WzBdK1VbMF0sVFsxXT13WzFdK1VbMV0sVFsyXT13WzJdK1VbMl0sVH1mdW5jdGlvbiBkKFQsdyxVKXtyZXR1cm4gVFswXT13WzBdLVVbMF0sVFsxXT13WzFdLVVbMV0sVFsyXT13WzJdLVVbMl0sVH1mdW5jdGlvbiBwKFQsdyxVKXtyZXR1cm4gVFswXT13WzBdKlVbMF0sVFsxXT13WzFdKlVbMV0sVFsyXT13WzJdKlVbMl0sVH1mdW5jdGlvbiB5KFQsdyxVKXtyZXR1cm4gVFswXT13WzBdL1VbMF0sVFsxXT13WzFdL1VbMV0sVFsyXT13WzJdL1VbMl0sVH1mdW5jdGlvbiBQKFQsdyl7cmV0dXJuIFRbMF09TWF0aC5jZWlsKHdbMF0pLFRbMV09TWF0aC5jZWlsKHdbMV0pLFRbMl09TWF0aC5jZWlsKHdbMl0pLFR9ZnVuY3Rpb24geChULHcpe3JldHVybiBUWzBdPU1hdGguZmxvb3Iod1swXSksVFsxXT1NYXRoLmZsb29yKHdbMV0pLFRbMl09TWF0aC5mbG9vcih3WzJdKSxUfWZ1bmN0aW9uIG0oVCx3LFUpe3JldHVybiBUWzBdPU1hdGgubWluKHdbMF0sVVswXSksVFsxXT1NYXRoLm1pbih3WzFdLFVbMV0pLFRbMl09TWF0aC5taW4od1syXSxVWzJdKSxUfWZ1bmN0aW9uIE8oVCx3LFUpe3JldHVybiBUWzBdPU1hdGgubWF4KHdbMF0sVVswXSksVFsxXT1NYXRoLm1heCh3WzFdLFVbMV0pLFRbMl09TWF0aC5tYXgod1syXSxVWzJdKSxUfWZ1bmN0aW9uIG8oVCx3KXtyZXR1cm4gVFswXT1NYXRoLnJvdW5kKHdbMF0pLFRbMV09TWF0aC5yb3VuZCh3WzFdKSxUWzJdPU1hdGgucm91bmQod1syXSksVH1mdW5jdGlvbiBoKFQsdyxVKXtyZXR1cm4gVFswXT13WzBdKlUsVFsxXT13WzFdKlUsVFsyXT13WzJdKlUsVH1mdW5jdGlvbiBjKFQsdyxVLEgpe3JldHVybiBUWzBdPXdbMF0rVVswXSpILFRbMV09d1sxXStVWzFdKkgsVFsyXT13WzJdK1VbMl0qSCxUfWZ1bmN0aW9uIGcoVCx3KXt2YXIgVT13WzBdLVRbMF0sSD13WzFdLVRbMV0sWT13WzJdLVRbMl07cmV0dXJuIE1hdGguaHlwb3QoVSxILFkpfWZ1bmN0aW9uIGIoVCx3KXt2YXIgVT13WzBdLVRbMF0sSD13WzFdLVRbMV0sWT13WzJdLVRbMl07cmV0dXJuIFUqVStIKkgrWSpZfWZ1bmN0aW9uIEUoVCl7dmFyIHc9VFswXSxVPVRbMV0sSD1UWzJdO3JldHVybiB3KncrVSpVK0gqSH1mdW5jdGlvbiBBKFQsdyl7cmV0dXJuIFRbMF09LXdbMF0sVFsxXT0td1sxXSxUWzJdPS13WzJdLFR9ZnVuY3Rpb24gTChULHcpe3JldHVybiBUWzBdPTEvd1swXSxUWzFdPTEvd1sxXSxUWzJdPTEvd1syXSxUfWZ1bmN0aW9uIE0oVCx3KXt2YXIgVT13WzBdLEg9d1sxXSxZPXdbMl0saz1VKlUrSCpIK1kqWTtyZXR1cm4gaz4wJiYoaz0xL01hdGguc3FydChrKSksVFswXT13WzBdKmssVFsxXT13WzFdKmssVFsyXT13WzJdKmssVH1mdW5jdGlvbiBJKFQsdyl7cmV0dXJuIFRbMF0qd1swXStUWzFdKndbMV0rVFsyXSp3WzJdfWZ1bmN0aW9uIEQoVCx3LFUpe3ZhciBIPXdbMF0sWT13WzFdLGs9d1syXSxydD1VWzBdLGl0PVVbMV0sbHQ9VVsyXTtyZXR1cm4gVFswXT1ZKmx0LWsqaXQsVFsxXT1rKnJ0LUgqbHQsVFsyXT1IKml0LVkqcnQsVH1mdW5jdGlvbiBSKFQsdyxVLEgpe3ZhciBZPXdbMF0saz13WzFdLHJ0PXdbMl07cmV0dXJuIFRbMF09WStIKihVWzBdLVkpLFRbMV09aytIKihVWzFdLWspLFRbMl09cnQrSCooVVsyXS1ydCksVH1mdW5jdGlvbiBDKFQsdyxVLEgsWSxrKXt2YXIgcnQ9ayprLGl0PXJ0KigyKmstMykrMSxsdD1ydCooay0yKStrLGZ0PXJ0KihrLTEpLG90PXJ0KigzLTIqayk7cmV0dXJuIFRbMF09d1swXSppdCtVWzBdKmx0K0hbMF0qZnQrWVswXSpvdCxUWzFdPXdbMV0qaXQrVVsxXSpsdCtIWzFdKmZ0K1lbMV0qb3QsVFsyXT13WzJdKml0K1VbMl0qbHQrSFsyXSpmdCtZWzJdKm90LFR9ZnVuY3Rpb24gQihULHcsVSxILFksayl7dmFyIHJ0PTEtayxpdD1ydCpydCxsdD1rKmssZnQ9aXQqcnQsb3Q9MyprKml0LHN0PTMqbHQqcnQsY3Q9bHQqaztyZXR1cm4gVFswXT13WzBdKmZ0K1VbMF0qb3QrSFswXSpzdCtZWzBdKmN0LFRbMV09d1sxXSpmdCtVWzFdKm90K0hbMV0qc3QrWVsxXSpjdCxUWzJdPXdbMl0qZnQrVVsyXSpvdCtIWzJdKnN0K1lbMl0qY3QsVH1mdW5jdGlvbiB6KFQsdyl7dz13fHwxO3ZhciBVPXIuUkFORE9NKCkqMipNYXRoLlBJLEg9ci5SQU5ET00oKSoyLTEsWT1NYXRoLnNxcnQoMS1IKkgpKnc7cmV0dXJuIFRbMF09TWF0aC5jb3MoVSkqWSxUWzFdPU1hdGguc2luKFUpKlksVFsyXT1IKncsVH1mdW5jdGlvbiBLKFQsdyxVKXt2YXIgSD13WzBdLFk9d1sxXSxrPXdbMl0scnQ9VVszXSpIK1VbN10qWStVWzExXSprK1VbMTVdO3JldHVybiBydD1ydHx8MSxUWzBdPShVWzBdKkgrVVs0XSpZK1VbOF0qaytVWzEyXSkvcnQsVFsxXT0oVVsxXSpIK1VbNV0qWStVWzldKmsrVVsxM10pL3J0LFRbMl09KFVbMl0qSCtVWzZdKlkrVVsxMF0qaytVWzE0XSkvcnQsVH1mdW5jdGlvbiBRKFQsdyxVKXt2YXIgSD13WzBdLFk9d1sxXSxrPXdbMl07cmV0dXJuIFRbMF09SCpVWzBdK1kqVVszXStrKlVbNl0sVFsxXT1IKlVbMV0rWSpVWzRdK2sqVVs3XSxUWzJdPUgqVVsyXStZKlVbNV0raypVWzhdLFR9ZnVuY3Rpb24gXyhULHcsVSl7dmFyIEg9VVswXSxZPVVbMV0saz1VWzJdLHJ0PVVbM10saXQ9d1swXSxsdD13WzFdLGZ0PXdbMl0sb3Q9WSpmdC1rKmx0LHN0PWsqaXQtSCpmdCxjdD1IKmx0LVkqaXQsbXQ9WSpjdC1rKnN0LHZ0PWsqb3QtSCpjdCxndD1IKnN0LVkqb3QsU3Q9cnQqMjtyZXR1cm4gb3QqPVN0LHN0Kj1TdCxjdCo9U3QsbXQqPTIsdnQqPTIsZ3QqPTIsVFswXT1pdCtvdCttdCxUWzFdPWx0K3N0K3Z0LFRbMl09ZnQrY3QrZ3QsVH1mdW5jdGlvbiBGKFQsdyxVLEgpe3ZhciBZPVtdLGs9W107cmV0dXJuIFlbMF09d1swXS1VWzBdLFlbMV09d1sxXS1VWzFdLFlbMl09d1syXS1VWzJdLGtbMF09WVswXSxrWzFdPVlbMV0qTWF0aC5jb3MoSCktWVsyXSpNYXRoLnNpbihIKSxrWzJdPVlbMV0qTWF0aC5zaW4oSCkrWVsyXSpNYXRoLmNvcyhIKSxUWzBdPWtbMF0rVVswXSxUWzFdPWtbMV0rVVsxXSxUWzJdPWtbMl0rVVsyXSxUfWZ1bmN0aW9uIEcoVCx3LFUsSCl7dmFyIFk9W10saz1bXTtyZXR1cm4gWVswXT13WzBdLVVbMF0sWVsxXT13WzFdLVVbMV0sWVsyXT13WzJdLVVbMl0sa1swXT1ZWzJdKk1hdGguc2luKEgpK1lbMF0qTWF0aC5jb3MoSCksa1sxXT1ZWzFdLGtbMl09WVsyXSpNYXRoLmNvcyhIKS1ZWzBdKk1hdGguc2luKEgpLFRbMF09a1swXStVWzBdLFRbMV09a1sxXStVWzFdLFRbMl09a1syXStVWzJdLFR9ZnVuY3Rpb24gWChULHcsVSxIKXt2YXIgWT1bXSxrPVtdO3JldHVybiBZWzBdPXdbMF0tVVswXSxZWzFdPXdbMV0tVVsxXSxZWzJdPXdbMl0tVVsyXSxrWzBdPVlbMF0qTWF0aC5jb3MoSCktWVsxXSpNYXRoLnNpbihIKSxrWzFdPVlbMF0qTWF0aC5zaW4oSCkrWVsxXSpNYXRoLmNvcyhIKSxrWzJdPVlbMl0sVFswXT1rWzBdK1VbMF0sVFsxXT1rWzFdK1VbMV0sVFsyXT1rWzJdK1VbMl0sVH1mdW5jdGlvbiBaKFQsdyl7dmFyIFU9VFswXSxIPVRbMV0sWT1UWzJdLGs9d1swXSxydD13WzFdLGl0PXdbMl0sbHQ9TWF0aC5zcXJ0KFUqVStIKkgrWSpZKSxmdD1NYXRoLnNxcnQoayprK3J0KnJ0K2l0Kml0KSxvdD1sdCpmdCxzdD1vdCYmSShULHcpL290O3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoc3QsLTEpLDEpKX1mdW5jdGlvbiB0dChUKXtyZXR1cm4gVFswXT0wLFRbMV09MCxUWzJdPTAsVH1mdW5jdGlvbiBudChUKXtyZXR1cm4idmVjMygiK1RbMF0rIiwgIitUWzFdKyIsICIrVFsyXSsiKSJ9ZnVuY3Rpb24gcShULHcpe3JldHVybiBUWzBdPT09d1swXSYmVFsxXT09PXdbMV0mJlRbMl09PT13WzJdfWZ1bmN0aW9uIGh0KFQsdyl7dmFyIFU9VFswXSxIPVRbMV0sWT1UWzJdLGs9d1swXSxydD13WzFdLGl0PXdbMl07cmV0dXJuIE1hdGguYWJzKFUtayk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFUpLE1hdGguYWJzKGspKSYmTWF0aC5hYnMoSC1ydCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEgpLE1hdGguYWJzKHJ0KSkmJk1hdGguYWJzKFktaXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhZKSxNYXRoLmFicyhpdCkpfXZhciB1dD1kLGo9cCxXPXksVj1nLEo9YixOPWEsJD1FLFM9ZnVuY3Rpb24oKXt2YXIgVD1uKCk7cmV0dXJuIGZ1bmN0aW9uKHcsVSxILFksayxydCl7dmFyIGl0LGx0O2ZvcihVfHwoVT0zKSxIfHwoSD0wKSxZP2x0PU1hdGgubWluKFkqVStILHcubGVuZ3RoKTpsdD13Lmxlbmd0aCxpdD1IO2l0PGx0O2l0Kz1VKVRbMF09d1tpdF0sVFsxXT13W2l0KzFdLFRbMl09d1tpdCsyXSxrKFQsVCxydCksd1tpdF09VFswXSx3W2l0KzFdPVRbMV0sd1tpdCsyXT1UWzJdO3JldHVybiB3fX0oKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwidHJhbnNmb3JtTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiB6fSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBYfSksdC5kKGUsImRpdiIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBudH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJmb3JFYWNoIixmdW5jdGlvbigpe3JldHVybiB1dH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBqPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoalswXT0wLGpbMV09MCxqWzJdPTAsalszXT0wKSxqfWZ1bmN0aW9uIGkoail7dmFyIFc9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gV1swXT1qWzBdLFdbMV09alsxXSxXWzJdPWpbMl0sV1szXT1qWzNdLFd9ZnVuY3Rpb24gYShqLFcsVixKKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBOWzBdPWosTlsxXT1XLE5bMl09VixOWzNdPUosTn1mdW5jdGlvbiBsKGosVyl7cmV0dXJuIGpbMF09V1swXSxqWzFdPVdbMV0salsyXT1XWzJdLGpbM109V1szXSxqfWZ1bmN0aW9uIHMoaixXLFYsSixOKXtyZXR1cm4galswXT1XLGpbMV09VixqWzJdPUosalszXT1OLGp9ZnVuY3Rpb24gZihqLFcsVil7cmV0dXJuIGpbMF09V1swXStWWzBdLGpbMV09V1sxXStWWzFdLGpbMl09V1syXStWWzJdLGpbM109V1szXStWWzNdLGp9ZnVuY3Rpb24gdihqLFcsVil7cmV0dXJuIGpbMF09V1swXS1WWzBdLGpbMV09V1sxXS1WWzFdLGpbMl09V1syXS1WWzJdLGpbM109V1szXS1WWzNdLGp9ZnVuY3Rpb24gZChqLFcsVil7cmV0dXJuIGpbMF09V1swXSpWWzBdLGpbMV09V1sxXSpWWzFdLGpbMl09V1syXSpWWzJdLGpbM109V1szXSpWWzNdLGp9ZnVuY3Rpb24gcChqLFcsVil7cmV0dXJuIGpbMF09V1swXS9WWzBdLGpbMV09V1sxXS9WWzFdLGpbMl09V1syXS9WWzJdLGpbM109V1szXS9WWzNdLGp9ZnVuY3Rpb24geShqLFcpe3JldHVybiBqWzBdPU1hdGguY2VpbChXWzBdKSxqWzFdPU1hdGguY2VpbChXWzFdKSxqWzJdPU1hdGguY2VpbChXWzJdKSxqWzNdPU1hdGguY2VpbChXWzNdKSxqfWZ1bmN0aW9uIFAoaixXKXtyZXR1cm4galswXT1NYXRoLmZsb29yKFdbMF0pLGpbMV09TWF0aC5mbG9vcihXWzFdKSxqWzJdPU1hdGguZmxvb3IoV1syXSksalszXT1NYXRoLmZsb29yKFdbM10pLGp9ZnVuY3Rpb24geChqLFcsVil7cmV0dXJuIGpbMF09TWF0aC5taW4oV1swXSxWWzBdKSxqWzFdPU1hdGgubWluKFdbMV0sVlsxXSksalsyXT1NYXRoLm1pbihXWzJdLFZbMl0pLGpbM109TWF0aC5taW4oV1szXSxWWzNdKSxqfWZ1bmN0aW9uIG0oaixXLFYpe3JldHVybiBqWzBdPU1hdGgubWF4KFdbMF0sVlswXSksalsxXT1NYXRoLm1heChXWzFdLFZbMV0pLGpbMl09TWF0aC5tYXgoV1syXSxWWzJdKSxqWzNdPU1hdGgubWF4KFdbM10sVlszXSksan1mdW5jdGlvbiBPKGosVyl7cmV0dXJuIGpbMF09TWF0aC5yb3VuZChXWzBdKSxqWzFdPU1hdGgucm91bmQoV1sxXSksalsyXT1NYXRoLnJvdW5kKFdbMl0pLGpbM109TWF0aC5yb3VuZChXWzNdKSxqfWZ1bmN0aW9uIG8oaixXLFYpe3JldHVybiBqWzBdPVdbMF0qVixqWzFdPVdbMV0qVixqWzJdPVdbMl0qVixqWzNdPVdbM10qVixqfWZ1bmN0aW9uIGgoaixXLFYsSil7cmV0dXJuIGpbMF09V1swXStWWzBdKkosalsxXT1XWzFdK1ZbMV0qSixqWzJdPVdbMl0rVlsyXSpKLGpbM109V1szXStWWzNdKkosan1mdW5jdGlvbiBjKGosVyl7dmFyIFY9V1swXS1qWzBdLEo9V1sxXS1qWzFdLE49V1syXS1qWzJdLCQ9V1szXS1qWzNdO3JldHVybiBNYXRoLmh5cG90KFYsSixOLCQpfWZ1bmN0aW9uIGcoaixXKXt2YXIgVj1XWzBdLWpbMF0sSj1XWzFdLWpbMV0sTj1XWzJdLWpbMl0sJD1XWzNdLWpbM107cmV0dXJuIFYqVitKKkorTipOKyQqJH1mdW5jdGlvbiBiKGope3ZhciBXPWpbMF0sVj1qWzFdLEo9alsyXSxOPWpbM107cmV0dXJuIE1hdGguaHlwb3QoVyxWLEosTil9ZnVuY3Rpb24gRShqKXt2YXIgVz1qWzBdLFY9alsxXSxKPWpbMl0sTj1qWzNdO3JldHVybiBXKlcrVipWK0oqSitOKk59ZnVuY3Rpb24gQShqLFcpe3JldHVybiBqWzBdPS1XWzBdLGpbMV09LVdbMV0salsyXT0tV1syXSxqWzNdPS1XWzNdLGp9ZnVuY3Rpb24gTChqLFcpe3JldHVybiBqWzBdPTEvV1swXSxqWzFdPTEvV1sxXSxqWzJdPTEvV1syXSxqWzNdPTEvV1szXSxqfWZ1bmN0aW9uIE0oaixXKXt2YXIgVj1XWzBdLEo9V1sxXSxOPVdbMl0sJD1XWzNdLFM9VipWK0oqSitOKk4rJCokO3JldHVybiBTPjAmJihTPTEvTWF0aC5zcXJ0KFMpKSxqWzBdPVYqUyxqWzFdPUoqUyxqWzJdPU4qUyxqWzNdPSQqUyxqfWZ1bmN0aW9uIEkoaixXKXtyZXR1cm4galswXSpXWzBdK2pbMV0qV1sxXStqWzJdKldbMl0ralszXSpXWzNdfWZ1bmN0aW9uIEQoaixXLFYsSil7dmFyIE49VlswXSpKWzFdLVZbMV0qSlswXSwkPVZbMF0qSlsyXS1WWzJdKkpbMF0sUz1WWzBdKkpbM10tVlszXSpKWzBdLFQ9VlsxXSpKWzJdLVZbMl0qSlsxXSx3PVZbMV0qSlszXS1WWzNdKkpbMV0sVT1WWzJdKkpbM10tVlszXSpKWzJdLEg9V1swXSxZPVdbMV0saz1XWzJdLHJ0PVdbM107cmV0dXJuIGpbMF09WSpVLWsqdytydCpULGpbMV09LShIKlUpK2sqUy1ydCokLGpbMl09SCp3LVkqUytydCpOLGpbM109LShIKlQpK1kqJC1rKk4san1mdW5jdGlvbiBSKGosVyxWLEope3ZhciBOPVdbMF0sJD1XWzFdLFM9V1syXSxUPVdbM107cmV0dXJuIGpbMF09TitKKihWWzBdLU4pLGpbMV09JCtKKihWWzFdLSQpLGpbMl09UytKKihWWzJdLVMpLGpbM109VCtKKihWWzNdLVQpLGp9ZnVuY3Rpb24gQyhqLFcpe1c9V3x8MTt2YXIgVixKLE4sJCxTLFQ7ZG8gVj1yLlJBTkRPTSgpKjItMSxKPXIuUkFORE9NKCkqMi0xLFM9VipWK0oqSjt3aGlsZShTPj0xKTtkbyBOPXIuUkFORE9NKCkqMi0xLCQ9ci5SQU5ET00oKSoyLTEsVD1OKk4rJCokO3doaWxlKFQ+PTEpO3ZhciB3PU1hdGguc3FydCgoMS1TKS9UKTtyZXR1cm4galswXT1XKlYsalsxXT1XKkosalsyXT1XKk4qdyxqWzNdPVcqJCp3LGp9ZnVuY3Rpb24gQihqLFcsVil7dmFyIEo9V1swXSxOPVdbMV0sJD1XWzJdLFM9V1szXTtyZXR1cm4galswXT1WWzBdKkorVls0XSpOK1ZbOF0qJCtWWzEyXSpTLGpbMV09VlsxXSpKK1ZbNV0qTitWWzldKiQrVlsxM10qUyxqWzJdPVZbMl0qSitWWzZdKk4rVlsxMF0qJCtWWzE0XSpTLGpbM109VlszXSpKK1ZbN10qTitWWzExXSokK1ZbMTVdKlMsan1mdW5jdGlvbiB6KGosVyxWKXt2YXIgSj1XWzBdLE49V1sxXSwkPVdbMl0sUz1WWzBdLFQ9VlsxXSx3PVZbMl0sVT1WWzNdLEg9VSpKK1QqJC13Kk4sWT1VKk4rdypKLVMqJCxrPVUqJCtTKk4tVCpKLHJ0PS1TKkotVCpOLXcqJDtyZXR1cm4galswXT1IKlUrcnQqLVMrWSotdy1rKi1ULGpbMV09WSpVK3J0Ki1UK2sqLVMtSCotdyxqWzJdPWsqVStydCotdytIKi1ULVkqLVMsalszXT1XWzNdLGp9ZnVuY3Rpb24gSyhqKXtyZXR1cm4galswXT0wLGpbMV09MCxqWzJdPTAsalszXT0wLGp9ZnVuY3Rpb24gUShqKXtyZXR1cm4idmVjNCgiK2pbMF0rIiwgIitqWzFdKyIsICIralsyXSsiLCAiK2pbM10rIikifWZ1bmN0aW9uIF8oaixXKXtyZXR1cm4galswXT09PVdbMF0mJmpbMV09PT1XWzFdJiZqWzJdPT09V1syXSYmalszXT09PVdbM119ZnVuY3Rpb24gRihqLFcpe3ZhciBWPWpbMF0sSj1qWzFdLE49alsyXSwkPWpbM10sUz1XWzBdLFQ9V1sxXSx3PVdbMl0sVT1XWzNdO3JldHVybiBNYXRoLmFicyhWLVMpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhWKSxNYXRoLmFicyhTKSkmJk1hdGguYWJzKEotVCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEopLE1hdGguYWJzKFQpKSYmTWF0aC5hYnMoTi13KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTiksTWF0aC5hYnModykpJiZNYXRoLmFicygkLVUpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhVKSl9dmFyIEc9dixYPWQsWj1wLHR0PWMsbnQ9ZyxxPWIsaHQ9RSx1dD1mdW5jdGlvbigpe3ZhciBqPW4oKTtyZXR1cm4gZnVuY3Rpb24oVyxWLEosTiwkLFMpe3ZhciBULHc7Zm9yKFZ8fChWPTQpLEp8fChKPTApLE4/dz1NYXRoLm1pbihOKlYrSixXLmxlbmd0aCk6dz1XLmxlbmd0aCxUPUo7VDx3O1QrPVYpalswXT1XW1RdLGpbMV09V1tUKzFdLGpbMl09V1tUKzJdLGpbM109V1tUKzNdLCQoaixqLFMpLFdbVF09alswXSxXW1QrMV09alsxXSxXW1QrMl09alsyXSxXW1QrM109alszXTtyZXR1cm4gV319KCl9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiZ2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJnZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldFJlYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwic2V0RHVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwicm90YXRlQnlRdWF0QXBwZW5kIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInJvdGF0ZUJ5UXVhdFByZXBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwicm90YXRlQXJvdW5kQXhpcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB6fSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gS30pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBudH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gdXR9KTt2YXIgcj10KDIpLG49dCg3KSxpPXQoNik7ZnVuY3Rpb24gYSgpe3ZhciBqPW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoalswXT0wLGpbMV09MCxqWzJdPTAsals0XT0wLGpbNV09MCxqWzZdPTAsals3XT0wKSxqWzNdPTEsan1mdW5jdGlvbiBsKGope3ZhciBXPW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIFdbMF09alswXSxXWzFdPWpbMV0sV1syXT1qWzJdLFdbM109alszXSxXWzRdPWpbNF0sV1s1XT1qWzVdLFdbNl09als2XSxXWzddPWpbN10sV31mdW5jdGlvbiBzKGosVyxWLEosTiwkLFMsVCl7dmFyIHc9bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gd1swXT1qLHdbMV09Vyx3WzJdPVYsd1szXT1KLHdbNF09Tix3WzVdPSQsd1s2XT1TLHdbN109VCx3fWZ1bmN0aW9uIGYoaixXLFYsSixOLCQsUyl7dmFyIFQ9bmV3IHIuQVJSQVlfVFlQRSg4KTtUWzBdPWosVFsxXT1XLFRbMl09VixUWzNdPUo7dmFyIHc9TiouNSxVPSQqLjUsSD1TKi41O3JldHVybiBUWzRdPXcqSitVKlYtSCpXLFRbNV09VSpKK0gqai13KlYsVFs2XT1IKkordypXLVUqaixUWzddPS13KmotVSpXLUgqVixUfWZ1bmN0aW9uIHYoaixXLFYpe3ZhciBKPVZbMF0qLjUsTj1WWzFdKi41LCQ9VlsyXSouNSxTPVdbMF0sVD1XWzFdLHc9V1syXSxVPVdbM107cmV0dXJuIGpbMF09UyxqWzFdPVQsalsyXT13LGpbM109VSxqWzRdPUoqVStOKnctJCpULGpbNV09TipVKyQqUy1KKncsals2XT0kKlUrSipULU4qUyxqWzddPS1KKlMtTipULSQqdyxqfWZ1bmN0aW9uIGQoaixXKXtyZXR1cm4galswXT0wLGpbMV09MCxqWzJdPTAsalszXT0xLGpbNF09V1swXSouNSxqWzVdPVdbMV0qLjUsals2XT1XWzJdKi41LGpbN109MCxqfWZ1bmN0aW9uIHAoaixXKXtyZXR1cm4galswXT1XWzBdLGpbMV09V1sxXSxqWzJdPVdbMl0salszXT1XWzNdLGpbNF09MCxqWzVdPTAsals2XT0wLGpbN109MCxqfWZ1bmN0aW9uIHkoaixXKXt2YXIgVj1uLmNyZWF0ZSgpO2kuZ2V0Um90YXRpb24oVixXKTt2YXIgSj1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBpLmdldFRyYW5zbGF0aW9uKEosVyksdihqLFYsSiksan1mdW5jdGlvbiBQKGosVyl7cmV0dXJuIGpbMF09V1swXSxqWzFdPVdbMV0salsyXT1XWzJdLGpbM109V1szXSxqWzRdPVdbNF0sals1XT1XWzVdLGpbNl09V1s2XSxqWzddPVdbN10san1mdW5jdGlvbiB4KGope3JldHVybiBqWzBdPTAsalsxXT0wLGpbMl09MCxqWzNdPTEsals0XT0wLGpbNV09MCxqWzZdPTAsals3XT0wLGp9ZnVuY3Rpb24gbShqLFcsVixKLE4sJCxTLFQsdyl7cmV0dXJuIGpbMF09VyxqWzFdPVYsalsyXT1KLGpbM109TixqWzRdPSQsals1XT1TLGpbNl09VCxqWzddPXcsan12YXIgTz1uLmNvcHk7ZnVuY3Rpb24gbyhqLFcpe3JldHVybiBqWzBdPVdbNF0salsxXT1XWzVdLGpbMl09V1s2XSxqWzNdPVdbN10san12YXIgaD1uLmNvcHk7ZnVuY3Rpb24gYyhqLFcpe3JldHVybiBqWzRdPVdbMF0sals1XT1XWzFdLGpbNl09V1syXSxqWzddPVdbM10san1mdW5jdGlvbiBnKGosVyl7dmFyIFY9V1s0XSxKPVdbNV0sTj1XWzZdLCQ9V1s3XSxTPS1XWzBdLFQ9LVdbMV0sdz0tV1syXSxVPVdbM107cmV0dXJuIGpbMF09KFYqVSskKlMrSip3LU4qVCkqMixqWzFdPShKKlUrJCpUK04qUy1WKncpKjIsalsyXT0oTipVKyQqdytWKlQtSipTKSoyLGp9ZnVuY3Rpb24gYihqLFcsVil7dmFyIEo9V1swXSxOPVdbMV0sJD1XWzJdLFM9V1szXSxUPVZbMF0qLjUsdz1WWzFdKi41LFU9VlsyXSouNSxIPVdbNF0sWT1XWzVdLGs9V1s2XSxydD1XWzddO3JldHVybiBqWzBdPUosalsxXT1OLGpbMl09JCxqWzNdPVMsals0XT1TKlQrTipVLSQqdytILGpbNV09Uyp3KyQqVC1KKlUrWSxqWzZdPVMqVStKKnctTipUK2ssals3XT0tSipULU4qdy0kKlUrcnQsan1mdW5jdGlvbiBFKGosVyxWKXt2YXIgSj0tV1swXSxOPS1XWzFdLCQ9LVdbMl0sUz1XWzNdLFQ9V1s0XSx3PVdbNV0sVT1XWzZdLEg9V1s3XSxZPVQqUytIKkordyokLVUqTixrPXcqUytIKk4rVSpKLVQqJCxydD1VKlMrSCokK1QqTi13KkosaXQ9SCpTLVQqSi13Kk4tVSokO3JldHVybiBuLnJvdGF0ZVgoaixXLFYpLEo9alswXSxOPWpbMV0sJD1qWzJdLFM9alszXSxqWzRdPVkqUytpdCpKK2sqJC1ydCpOLGpbNV09aypTK2l0Kk4rcnQqSi1ZKiQsals2XT1ydCpTK2l0KiQrWSpOLWsqSixqWzddPWl0KlMtWSpKLWsqTi1ydCokLGp9ZnVuY3Rpb24gQShqLFcsVil7dmFyIEo9LVdbMF0sTj0tV1sxXSwkPS1XWzJdLFM9V1szXSxUPVdbNF0sdz1XWzVdLFU9V1s2XSxIPVdbN10sWT1UKlMrSCpKK3cqJC1VKk4saz13KlMrSCpOK1UqSi1UKiQscnQ9VSpTK0gqJCtUKk4tdypKLGl0PUgqUy1UKkotdypOLVUqJDtyZXR1cm4gbi5yb3RhdGVZKGosVyxWKSxKPWpbMF0sTj1qWzFdLCQ9alsyXSxTPWpbM10sals0XT1ZKlMraXQqSitrKiQtcnQqTixqWzVdPWsqUytpdCpOK3J0KkotWSokLGpbNl09cnQqUytpdCokK1kqTi1rKkosals3XT1pdCpTLVkqSi1rKk4tcnQqJCxqfWZ1bmN0aW9uIEwoaixXLFYpe3ZhciBKPS1XWzBdLE49LVdbMV0sJD0tV1syXSxTPVdbM10sVD1XWzRdLHc9V1s1XSxVPVdbNl0sSD1XWzddLFk9VCpTK0gqSit3KiQtVSpOLGs9dypTK0gqTitVKkotVCokLHJ0PVUqUytIKiQrVCpOLXcqSixpdD1IKlMtVCpKLXcqTi1VKiQ7cmV0dXJuIG4ucm90YXRlWihqLFcsViksSj1qWzBdLE49alsxXSwkPWpbMl0sUz1qWzNdLGpbNF09WSpTK2l0KkorayokLXJ0Kk4sals1XT1rKlMraXQqTitydCpKLVkqJCxqWzZdPXJ0KlMraXQqJCtZKk4taypKLGpbN109aXQqUy1ZKkotaypOLXJ0KiQsan1mdW5jdGlvbiBNKGosVyxWKXt2YXIgSj1WWzBdLE49VlsxXSwkPVZbMl0sUz1WWzNdLFQ9V1swXSx3PVdbMV0sVT1XWzJdLEg9V1szXTtyZXR1cm4galswXT1UKlMrSCpKK3cqJC1VKk4salsxXT13KlMrSCpOK1UqSi1UKiQsalsyXT1VKlMrSCokK1QqTi13KkosalszXT1IKlMtVCpKLXcqTi1VKiQsVD1XWzRdLHc9V1s1XSxVPVdbNl0sSD1XWzddLGpbNF09VCpTK0gqSit3KiQtVSpOLGpbNV09dypTK0gqTitVKkotVCokLGpbNl09VSpTK0gqJCtUKk4tdypKLGpbN109SCpTLVQqSi13Kk4tVSokLGp9ZnVuY3Rpb24gSShqLFcsVil7dmFyIEo9V1swXSxOPVdbMV0sJD1XWzJdLFM9V1szXSxUPVZbMF0sdz1WWzFdLFU9VlsyXSxIPVZbM107cmV0dXJuIGpbMF09SipIK1MqVCtOKlUtJCp3LGpbMV09TipIK1MqdyskKlQtSipVLGpbMl09JCpIK1MqVStKKnctTipULGpbM109UypILUoqVC1OKnctJCpVLFQ9Vls0XSx3PVZbNV0sVT1WWzZdLEg9Vls3XSxqWzRdPUoqSCtTKlQrTipVLSQqdyxqWzVdPU4qSCtTKncrJCpULUoqVSxqWzZdPSQqSCtTKlUrSip3LU4qVCxqWzddPVMqSC1KKlQtTip3LSQqVSxqfWZ1bmN0aW9uIEQoaixXLFYsSil7aWYoTWF0aC5hYnMoSik8ci5FUFNJTE9OKXJldHVybiBQKGosVyk7dmFyIE49TWF0aC5oeXBvdChWWzBdLFZbMV0sVlsyXSk7Sj1KKi41O3ZhciAkPU1hdGguc2luKEopLFM9JCpWWzBdL04sVD0kKlZbMV0vTix3PSQqVlsyXS9OLFU9TWF0aC5jb3MoSiksSD1XWzBdLFk9V1sxXSxrPVdbMl0scnQ9V1szXTtqWzBdPUgqVStydCpTK1kqdy1rKlQsalsxXT1ZKlUrcnQqVCtrKlMtSCp3LGpbMl09aypVK3J0KncrSCpULVkqUyxqWzNdPXJ0KlUtSCpTLVkqVC1rKnc7dmFyIGl0PVdbNF0sbHQ9V1s1XSxmdD1XWzZdLG90PVdbN107cmV0dXJuIGpbNF09aXQqVStvdCpTK2x0KnctZnQqVCxqWzVdPWx0KlUrb3QqVCtmdCpTLWl0Kncsals2XT1mdCpVK290KncraXQqVC1sdCpTLGpbN109b3QqVS1pdCpTLWx0KlQtZnQqdyxqfWZ1bmN0aW9uIFIoaixXLFYpe3JldHVybiBqWzBdPVdbMF0rVlswXSxqWzFdPVdbMV0rVlsxXSxqWzJdPVdbMl0rVlsyXSxqWzNdPVdbM10rVlszXSxqWzRdPVdbNF0rVls0XSxqWzVdPVdbNV0rVls1XSxqWzZdPVdbNl0rVls2XSxqWzddPVdbN10rVls3XSxqfWZ1bmN0aW9uIEMoaixXLFYpe3ZhciBKPVdbMF0sTj1XWzFdLCQ9V1syXSxTPVdbM10sVD1WWzRdLHc9Vls1XSxVPVZbNl0sSD1WWzddLFk9V1s0XSxrPVdbNV0scnQ9V1s2XSxpdD1XWzddLGx0PVZbMF0sZnQ9VlsxXSxvdD1WWzJdLHN0PVZbM107cmV0dXJuIGpbMF09SipzdCtTKmx0K04qb3QtJCpmdCxqWzFdPU4qc3QrUypmdCskKmx0LUoqb3QsalsyXT0kKnN0K1Mqb3QrSipmdC1OKmx0LGpbM109UypzdC1KKmx0LU4qZnQtJCpvdCxqWzRdPUoqSCtTKlQrTipVLSQqdytZKnN0K2l0Kmx0K2sqb3QtcnQqZnQsals1XT1OKkgrUyp3KyQqVC1KKlUraypzdCtpdCpmdCtydCpsdC1ZKm90LGpbNl09JCpIK1MqVStKKnctTipUK3J0KnN0K2l0Km90K1kqZnQtaypsdCxqWzddPVMqSC1KKlQtTip3LSQqVStpdCpzdC1ZKmx0LWsqZnQtcnQqb3Qsan12YXIgQj1DO2Z1bmN0aW9uIHooaixXLFYpe3JldHVybiBqWzBdPVdbMF0qVixqWzFdPVdbMV0qVixqWzJdPVdbMl0qVixqWzNdPVdbM10qVixqWzRdPVdbNF0qVixqWzVdPVdbNV0qVixqWzZdPVdbNl0qVixqWzddPVdbN10qVixqfXZhciBLPW4uZG90O2Z1bmN0aW9uIFEoaixXLFYsSil7dmFyIE49MS1KO3JldHVybiBLKFcsVik8MCYmKEo9LUopLGpbMF09V1swXSpOK1ZbMF0qSixqWzFdPVdbMV0qTitWWzFdKkosalsyXT1XWzJdKk4rVlsyXSpKLGpbM109V1szXSpOK1ZbM10qSixqWzRdPVdbNF0qTitWWzRdKkosals1XT1XWzVdKk4rVls1XSpKLGpbNl09V1s2XSpOK1ZbNl0qSixqWzddPVdbN10qTitWWzddKkosan1mdW5jdGlvbiBfKGosVyl7dmFyIFY9WihXKTtyZXR1cm4galswXT0tV1swXS9WLGpbMV09LVdbMV0vVixqWzJdPS1XWzJdL1YsalszXT1XWzNdL1Ysals0XT0tV1s0XS9WLGpbNV09LVdbNV0vVixqWzZdPS1XWzZdL1Ysals3XT1XWzddL1Ysan1mdW5jdGlvbiBGKGosVyl7cmV0dXJuIGpbMF09LVdbMF0salsxXT0tV1sxXSxqWzJdPS1XWzJdLGpbM109V1szXSxqWzRdPS1XWzRdLGpbNV09LVdbNV0sals2XT0tV1s2XSxqWzddPVdbN10san12YXIgRz1uLmxlbmd0aCxYPUcsWj1uLnNxdWFyZWRMZW5ndGgsdHQ9WjtmdW5jdGlvbiBudChqLFcpe3ZhciBWPVooVyk7aWYoVj4wKXtWPU1hdGguc3FydChWKTt2YXIgSj1XWzBdL1YsTj1XWzFdL1YsJD1XWzJdL1YsUz1XWzNdL1YsVD1XWzRdLHc9V1s1XSxVPVdbNl0sSD1XWzddLFk9SipUK04qdyskKlUrUypIO2pbMF09SixqWzFdPU4salsyXT0kLGpbM109UyxqWzRdPShULUoqWSkvVixqWzVdPSh3LU4qWSkvVixqWzZdPShVLSQqWSkvVixqWzddPShILVMqWSkvVn1yZXR1cm4gan1mdW5jdGlvbiBxKGope3JldHVybiJxdWF0MigiK2pbMF0rIiwgIitqWzFdKyIsICIralsyXSsiLCAiK2pbM10rIiwgIitqWzRdKyIsICIrals1XSsiLCAiK2pbNl0rIiwgIitqWzddKyIpIn1mdW5jdGlvbiBodChqLFcpe3JldHVybiBqWzBdPT09V1swXSYmalsxXT09PVdbMV0mJmpbMl09PT1XWzJdJiZqWzNdPT09V1szXSYmals0XT09PVdbNF0mJmpbNV09PT1XWzVdJiZqWzZdPT09V1s2XSYmals3XT09PVdbN119ZnVuY3Rpb24gdXQoaixXKXt2YXIgVj1qWzBdLEo9alsxXSxOPWpbMl0sJD1qWzNdLFM9als0XSxUPWpbNV0sdz1qWzZdLFU9als3XSxIPVdbMF0sWT1XWzFdLGs9V1syXSxydD1XWzNdLGl0PVdbNF0sbHQ9V1s1XSxmdD1XWzZdLG90PVdbN107cmV0dXJuIE1hdGguYWJzKFYtSCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKEgpKSYmTWF0aC5hYnMoSi1ZKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMoWSkpJiZNYXRoLmFicyhOLWspPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhOKSxNYXRoLmFicyhrKSkmJk1hdGguYWJzKCQtcnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhTLWl0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoUyksTWF0aC5hYnMoaXQpKSYmTWF0aC5hYnMoVC1sdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFQpLE1hdGguYWJzKGx0KSkmJk1hdGguYWJzKHctZnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhmdCkpJiZNYXRoLmFicyhVLW90KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMob3QpKX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJkaXZpZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiY2VpbCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJmbG9vciIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJtaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwibWF4IixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInJvdW5kIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInNxdWFyZWREaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInRyYW5zZm9ybU1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwidHJhbnNmb3JtTWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHp9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gS30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gbnR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiB1dH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKE5bMF09MCxOWzFdPTApLE59ZnVuY3Rpb24gaShOKXt2YXIgJD1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiAkWzBdPU5bMF0sJFsxXT1OWzFdLCR9ZnVuY3Rpb24gYShOLCQpe3ZhciBTPW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIFNbMF09TixTWzFdPSQsU31mdW5jdGlvbiBsKE4sJCl7cmV0dXJuIE5bMF09JFswXSxOWzFdPSRbMV0sTn1mdW5jdGlvbiBzKE4sJCxTKXtyZXR1cm4gTlswXT0kLE5bMV09UyxOfWZ1bmN0aW9uIGYoTiwkLFMpe3JldHVybiBOWzBdPSRbMF0rU1swXSxOWzFdPSRbMV0rU1sxXSxOfWZ1bmN0aW9uIHYoTiwkLFMpe3JldHVybiBOWzBdPSRbMF0tU1swXSxOWzFdPSRbMV0tU1sxXSxOfWZ1bmN0aW9uIGQoTiwkLFMpe3JldHVybiBOWzBdPSRbMF0qU1swXSxOWzFdPSRbMV0qU1sxXSxOfWZ1bmN0aW9uIHAoTiwkLFMpe3JldHVybiBOWzBdPSRbMF0vU1swXSxOWzFdPSRbMV0vU1sxXSxOfWZ1bmN0aW9uIHkoTiwkKXtyZXR1cm4gTlswXT1NYXRoLmNlaWwoJFswXSksTlsxXT1NYXRoLmNlaWwoJFsxXSksTn1mdW5jdGlvbiBQKE4sJCl7cmV0dXJuIE5bMF09TWF0aC5mbG9vcigkWzBdKSxOWzFdPU1hdGguZmxvb3IoJFsxXSksTn1mdW5jdGlvbiB4KE4sJCxTKXtyZXR1cm4gTlswXT1NYXRoLm1pbigkWzBdLFNbMF0pLE5bMV09TWF0aC5taW4oJFsxXSxTWzFdKSxOfWZ1bmN0aW9uIG0oTiwkLFMpe3JldHVybiBOWzBdPU1hdGgubWF4KCRbMF0sU1swXSksTlsxXT1NYXRoLm1heCgkWzFdLFNbMV0pLE59ZnVuY3Rpb24gTyhOLCQpe3JldHVybiBOWzBdPU1hdGgucm91bmQoJFswXSksTlsxXT1NYXRoLnJvdW5kKCRbMV0pLE59ZnVuY3Rpb24gbyhOLCQsUyl7cmV0dXJuIE5bMF09JFswXSpTLE5bMV09JFsxXSpTLE59ZnVuY3Rpb24gaChOLCQsUyxUKXtyZXR1cm4gTlswXT0kWzBdK1NbMF0qVCxOWzFdPSRbMV0rU1sxXSpULE59ZnVuY3Rpb24gYyhOLCQpe3ZhciBTPSRbMF0tTlswXSxUPSRbMV0tTlsxXTtyZXR1cm4gTWF0aC5oeXBvdChTLFQpfWZ1bmN0aW9uIGcoTiwkKXt2YXIgUz0kWzBdLU5bMF0sVD0kWzFdLU5bMV07cmV0dXJuIFMqUytUKlR9ZnVuY3Rpb24gYihOKXt2YXIgJD1OWzBdLFM9TlsxXTtyZXR1cm4gTWF0aC5oeXBvdCgkLFMpfWZ1bmN0aW9uIEUoTil7dmFyICQ9TlswXSxTPU5bMV07cmV0dXJuICQqJCtTKlN9ZnVuY3Rpb24gQShOLCQpe3JldHVybiBOWzBdPS0kWzBdLE5bMV09LSRbMV0sTn1mdW5jdGlvbiBMKE4sJCl7cmV0dXJuIE5bMF09MS8kWzBdLE5bMV09MS8kWzFdLE59ZnVuY3Rpb24gTShOLCQpe3ZhciBTPSRbMF0sVD0kWzFdLHc9UypTK1QqVDtyZXR1cm4gdz4wJiYodz0xL01hdGguc3FydCh3KSksTlswXT0kWzBdKncsTlsxXT0kWzFdKncsTn1mdW5jdGlvbiBJKE4sJCl7cmV0dXJuIE5bMF0qJFswXStOWzFdKiRbMV19ZnVuY3Rpb24gRChOLCQsUyl7dmFyIFQ9JFswXSpTWzFdLSRbMV0qU1swXTtyZXR1cm4gTlswXT1OWzFdPTAsTlsyXT1ULE59ZnVuY3Rpb24gUihOLCQsUyxUKXt2YXIgdz0kWzBdLFU9JFsxXTtyZXR1cm4gTlswXT13K1QqKFNbMF0tdyksTlsxXT1VK1QqKFNbMV0tVSksTn1mdW5jdGlvbiBDKE4sJCl7JD0kfHwxO3ZhciBTPXIuUkFORE9NKCkqMipNYXRoLlBJO3JldHVybiBOWzBdPU1hdGguY29zKFMpKiQsTlsxXT1NYXRoLnNpbihTKSokLE59ZnVuY3Rpb24gQihOLCQsUyl7dmFyIFQ9JFswXSx3PSRbMV07cmV0dXJuIE5bMF09U1swXSpUK1NbMl0qdyxOWzFdPVNbMV0qVCtTWzNdKncsTn1mdW5jdGlvbiB6KE4sJCxTKXt2YXIgVD0kWzBdLHc9JFsxXTtyZXR1cm4gTlswXT1TWzBdKlQrU1syXSp3K1NbNF0sTlsxXT1TWzFdKlQrU1szXSp3K1NbNV0sTn1mdW5jdGlvbiBLKE4sJCxTKXt2YXIgVD0kWzBdLHc9JFsxXTtyZXR1cm4gTlswXT1TWzBdKlQrU1szXSp3K1NbNl0sTlsxXT1TWzFdKlQrU1s0XSp3K1NbN10sTn1mdW5jdGlvbiBRKE4sJCxTKXt2YXIgVD0kWzBdLHc9JFsxXTtyZXR1cm4gTlswXT1TWzBdKlQrU1s0XSp3K1NbMTJdLE5bMV09U1sxXSpUK1NbNV0qdytTWzEzXSxOfWZ1bmN0aW9uIF8oTiwkLFMsVCl7dmFyIHc9JFswXS1TWzBdLFU9JFsxXS1TWzFdLEg9TWF0aC5zaW4oVCksWT1NYXRoLmNvcyhUKTtyZXR1cm4gTlswXT13KlktVSpIK1NbMF0sTlsxXT13KkgrVSpZK1NbMV0sTn1mdW5jdGlvbiBGKE4sJCl7dmFyIFM9TlswXSxUPU5bMV0sdz0kWzBdLFU9JFsxXSxIPU1hdGguc3FydChTKlMrVCpUKSpNYXRoLnNxcnQodyp3K1UqVSksWT1IJiYoUyp3K1QqVSkvSDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KFksLTEpLDEpKX1mdW5jdGlvbiBHKE4pe3JldHVybiBOWzBdPTAsTlsxXT0wLE59ZnVuY3Rpb24gWChOKXtyZXR1cm4idmVjMigiK05bMF0rIiwgIitOWzFdKyIpIn1mdW5jdGlvbiBaKE4sJCl7cmV0dXJuIE5bMF09PT0kWzBdJiZOWzFdPT09JFsxXX1mdW5jdGlvbiB0dChOLCQpe3ZhciBTPU5bMF0sVD1OWzFdLHc9JFswXSxVPSRbMV07cmV0dXJuIE1hdGguYWJzKFMtdyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFMpLE1hdGguYWJzKHcpKSYmTWF0aC5hYnMoVC1VKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVCksTWF0aC5hYnMoVSkpfXZhciBudD1iLHE9dixodD1kLHV0PXAsaj1jLFc9ZyxWPUUsSj1mdW5jdGlvbigpe3ZhciBOPW4oKTtyZXR1cm4gZnVuY3Rpb24oJCxTLFQsdyxVLEgpe3ZhciBZLGs7Zm9yKFN8fChTPTIpLFR8fChUPTApLHc/az1NYXRoLm1pbih3KlMrVCwkLmxlbmd0aCk6az0kLmxlbmd0aCxZPVQ7WTxrO1krPVMpTlswXT0kW1ldLE5bMV09JFtZKzFdLFUoTixOLEgpLCRbWV09TlswXSwkW1krMV09TlsxXTtyZXR1cm4gJH19KCl9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMyk7dC5kKGUsIlJlbmRlcmVyIixmdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHR9KTt2YXIgbj10KDQwKTt0LmQoZSwiRmlndXJlMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH0pO3ZhciBpPXQoNTYpO3QuZChlLCJNZXNoMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdH0pO3ZhciBhPXQoMjkpO3QuZChlLCJNZXNoQ2xvdWQiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH0pO3ZhciBsPXQoMjMpO3QuZChlLCJwYXJzZUZvbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH0pO3ZhciBzPXQoMzEpO3QuZChlLCJwYXJzZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHR9KTt2YXIgZj10KDIxKTt0LmQoZSwiRU5WIixmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSl9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KTt2YXIgcj10KDE0KSxuPXQoMSksaT10KDIwKSxhPXQoMjcpLGw9dCgyNSkscz10KDQwKSxmPXQoNTYpLHY9dCgyOSksZD10KDU5KSxwPXQoMjEpLHk9dCg2Myk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFA9e2F1dG9VcGRhdGU6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGJ1ZmZlclNpemU6MTUwMH0seD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOyAgICAKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7ICAgICAgICAgICAgICAKfQpgLG09YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOwp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdlRleHR1cmVDb29yZC54eSk7Cn0KYCxPPVN5bWJvbCgiZ2xSZW5kZXJlciIpLG89U3ltYm9sKCJjYW52YXNSZW5kZXJlciIpLGg9U3ltYm9sKCJvcHRpb25zIiksYz1TeW1ib2woImdsb2JhbFRyYW5zZm9ybSIpLGc9U3ltYm9sKCJhcHBseUdsb2JhbFRyYW5zZm9ybSIpLGI9U3ltYm9sKCJjYW52YXMiKTtmdW5jdGlvbiBFKE0pe2NvbnN0IEk9TS5nbCxEPU0uZmJvO0QmJkkuYmluZEZyYW1lYnVmZmVyKEkuRlJBTUVCVUZGRVIsRCksTS5fZHJhdygpLEQmJkkuYmluZEZyYW1lYnVmZmVyKEkuRlJBTUVCVUZGRVIsbnVsbCl9ZnVuY3Rpb24gQShNLEksRCxSKXtjb25zdCBDPU0uY3JlYXRlVGV4dHVyZShJLmNhbnZhcyksQj1bW1swLDBdLFtELDBdLFtELFJdLFswLFJdLFswLDBdXV07Qi5jbG9zZWQ9ITA7Y29uc3Qgej1uZXcgZi5kZWZhdWx0KHtjb250b3VyczpCfSk7ei5zZXRUZXh0dXJlKEMpLE0uc2V0TWVzaERhdGEoW3oubWVzaERhdGFdKSxFKE0pLEMuZGVsZXRlKCksSS5jbGVhclJlY3QoMCwwLEQsUiksZGVsZXRlIEkuX2ZpbHRlcn1jbGFzcyBMe2NvbnN0cnVjdG9yKEksRD17fSl7bGV0IFI9RC5jb250ZXh0VHlwZTtpZihSfHwodHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Uj0id2ViZ2wyIjp0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0PT0iZnVuY3Rpb24iP1I9IndlYmdsIjpSPSIyZCIpLCFJLmdldENvbnRleHQpe2NvbnN0IEM9STtJPXtnZXRDb250ZXh0KCl7cmV0dXJuIEN9LHdpZHRoOkQud2lkdGgsaGVpZ2h0OkQuaGVpZ2h0fSxDLmNhbnZhcz1JLFI9IjJkIn1pZih0aGlzW2JdPUksUiE9PSJ3ZWJnbCImJlIhPT0id2ViZ2wyIiYmUiE9PSIyZCIpdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbnRleHQgdHlwZSAke1J9YCk7aWYoRC5jb250ZXh0VHlwZT1SLHRoaXNbaF09T2JqZWN0LmFzc2lnbih7fSxQLEQpLFI9PT0id2ViZ2wifHxSPT09IndlYmdsMiIpe1I9PT0id2ViZ2wyIiYmKHRoaXNbaF0ud2ViZ2wyPSEwKTtjb25zdCBDPW5ldyByLmRlZmF1bHQoSSx0aGlzW2hdKTtSPT09IndlYmdsMiImJiFDLmlzV2ViR0wyJiYoRC5jb250ZXh0VHlwZT0id2ViZ2wiKSxPYmplY3QoeS5jcmVhdGVTaGFkZXJzKShDKSxPYmplY3QoeS5hcHBseVNoYWRlcikoQyksT2JqZWN0KHkuY3JlYXRlQ2xvdWRTaGFkZXJzKShDKTtjb25zdCBCPUMuZ2w7Qi5jbGVhckNvbG9yKDAsMCwwLDApLEIuYmxlbmRGdW5jU2VwYXJhdGUoQi5TUkNfQUxQSEEsQi5PTkVfTUlOVVNfU1JDX0FMUEhBLEIuT05FLEIuT05FX01JTlVTX1NSQ19BTFBIQSksdGhpc1tPXT1DfWVsc2UgdGhpc1tvXT1uZXcgaS5kZWZhdWx0KEksdGhpc1toXSk7dGhpc1tjXT1bMSwwLDAsMCwxLDAsMCwwLDFdLHRoaXMudXBkYXRlUmVzb2x1dGlvbigpfWdldCBjYW52YXMoKXtyZXR1cm4gdGhpc1tiXX1nZXQgY2FudmFzUmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tvXX1nZXQgZ2xSZW5kZXJlcigpe3JldHVybiB0aGlzW09dfWdldCBpc1dlYkdMMigpe3JldHVybiB0aGlzW09dJiZ0aGlzW09dLmlzV2ViR0wyfWdldCBvcHRpb25zKCl7cmV0dXJuIHRoaXNbaF19Z2V0IGdsb2JhbFRyYW5zZm9ybU1hdHJpeCgpe2NvbnN0IEk9dGhpc1tjXTtyZXR1cm5bSVswXSxJWzFdLElbM10sSVs0XSxJWzZdLElbN11dfWdldCB2aWV3TWF0cml4KCl7cmV0dXJuIHRoaXNbY119W2ddKCl7Y29uc3QgST10aGlzW09dfHx0aGlzW29dO2lmKHRoaXNbT10pe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OlJ9PXRoaXMuY2FudmFzO0kudW5pZm9ybXMudmlld01hdHJpeD10aGlzLnZpZXdNYXRyaXgsSS51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4PXRoaXMucHJvamVjdGlvbk1hdHJpeCxJLnVuaWZvcm1zLnVfcmVzb2x1dGlvbj1bRCxSXX19dXBkYXRlUmVzb2x1dGlvbigpe2NvbnN0e3dpZHRoOkksaGVpZ2h0OkR9PXRoaXMuY2FudmFzLFI9WzEsMCwwLDAsMSwwLC1JLzIsLUQvMiwxXSxDPVsyL0ksMCwwLDAsLTIvRCwwLDAsMCwxXSxCPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxSKTt0aGlzLnByb2plY3Rpb25NYXRyaXg9Qix0aGlzW09dJiZ0aGlzW09dLmdsLnZpZXdwb3J0KDAsMCxJLEQpfWNyZWF0ZVRleHR1cmUoSSxEKXtyZXR1cm4odGhpc1tPXXx8dGhpc1tvXSkuY3JlYXRlVGV4dHVyZShJLEQpfWxvYWRUZXh0dXJlKEkse3VzZUltYWdlQml0bWFwOkQ9ITF9PXt9KXtyZXR1cm4odGhpc1tPXXx8dGhpc1tvXSkubG9hZFRleHR1cmUoSSx7dXNlSW1hZ2VCaXRtYXA6RH0pfWNyZWF0ZVRleHQoSSx7Zm9udDpEPSIxNnB4IGFyaWFsIixmaWxsQ29sb3I6Uj1udWxsLHN0cm9rZUNvbG9yOkM9bnVsbCxzdHJva2VXaWR0aDpCPTF9PXt9KXtpZih0aGlzW09dKXtjb25zdCB6PXAuZGVmYXVsdC5jcmVhdGVUZXh0KEkse2ZvbnQ6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpDLHN0cm9rZVdpZHRoOkJ9KTtyZXR1cm57aW1hZ2U6dGhpcy5jcmVhdGVUZXh0dXJlKHouaW1hZ2UpLHJlY3Q6ei5yZWN0fX1yZXR1cm57X2ltZzp7Zm9udDpELGZpbGxDb2xvcjpSLHN0cm9rZUNvbG9yOkMsc3Ryb2tlV2lkdGg6Qix0ZXh0Okl9fX1jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6SSxmcmFnbWVudDpELG9wdGlvbnM6Un09e30pe2lmKHRoaXNbT10pe2NvbnN0IEM9dGhpc1tPXS5jb21waWxlU3luYyhELEkpO3JldHVybiBDLl9hdHRyaWJPcHRzPVIsQ310aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IGNyZWF0ZSB3ZWJnbCBwcm9ncmFtLiIpfWNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6ST14LGZyYWdtZW50OkQ9bSxvcHRpb25zOlJ9PXt9KXtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6SSxmcmFnbWVudDpELG9wdGlvbnM6Un0pfXVzZVByb2dyYW0oSSxEPXt9KXtpZih0aGlzW09dKXtjb25zdCBSPU9iamVjdC5hc3NpZ24oe30sSS5fYXR0cmliT3B0cyxEKTtyZXR1cm4gdGhpc1tPXS51c2VQcm9ncmFtKEksUil9dGhyb3cgbmV3IEVycm9yKCJDb250ZXh0IDJEIGNhbm5vdCB1c2Ugd2ViZ2wgcHJvZ3JhbS4iKX1kZWxldGVUZXh0dXJlKEkpe3JldHVybih0aGlzW09dfHx0aGlzW29dKS5kZWxldGVUZXh0dXJlKEkpfWNsZWFyKC4uLkkpe2lmKHRoaXNbT10pe2NvbnN0IEQ9dGhpc1tPXS5nbDtELmNsZWFyKEQuQ09MT1JfQlVGRkVSX0JJVCl9ZWxzZSB0aGlzW29dLmNsZWFyKC4uLkkpfWRyYXdNZXNoQ2xvdWQoSSx7Y2xlYXI6RD0hMSxwcm9ncmFtOlI9bnVsbH09e30pe2NvbnN0IEM9dGhpc1tPXXx8dGhpc1tvXSxCPVJ8fEkucHJvZ3JhbTtpZih0aGlzW09dKXtjb25zdCB6PUMuZ2w7aWYoRCYmei5jbGVhcih6LkNPTE9SX0JVRkZFUl9CSVQpLEIpQy5wcm9ncmFtIT09QiYmdGhpcy51c2VQcm9ncmFtKEIse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSk7ZWxzZXtjb25zdCBLPUkubWVzaC5tZXNoRGF0YSxRPSEhSy51bmlmb3Jtcy51X3RleFNhbXBsZXIsXz0hIUsudW5pZm9ybXMudV9maWx0ZXJGbGFnLEY9ISFLLnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IsRz1JLmhhc0Nsb3VkQ29sb3IsWD1JLmhhc0Nsb3VkRmlsdGVyLFo9ISFLLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHkuYXBwbHlDbG91ZFNoYWRlcikoQyx7aGFzVGV4dHVyZTpRLGhhc0ZpbHRlcjpfLGhhc0dyYWRpZW50OkYsaGFzQ2xvdWRDb2xvcjpHLGhhc0Nsb3VkRmlsdGVyOlgsaGFzQ2xpcFBhdGg6Wn0pfXRoaXNbZ10oKSxDLnNldE1lc2hEYXRhKFtJLm1lc2hEYXRhXSksSS5iZWZvcmVSZW5kZXImJkkuYmVmb3JlUmVuZGVyKHosSSksRShDKSxJLmFmdGVyUmVuZGVyJiZJLmFmdGVyUmVuZGVyKHosSSl9ZWxzZSBDLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksQy5kcmF3TWVzaENsb3VkKEkse2NsZWFyOkQsaG9vazohMX0pfWRyYXdNZXNoZXMoSSx7Y2xlYXI6RD0hMSxwcm9ncmFtOlI9bnVsbH09e30pe2NvbnN0IEM9dGhpc1tPXXx8dGhpc1tvXTtpZih0aGlzW09dKXtjb25zdCBCPUMuZmJvLHo9T2JqZWN0KGEuZGVmYXVsdCkodGhpcyxJLFI9PW51bGwpLEs9Qy5nbDtEJiZLLmNsZWFyKEsuQ09MT1JfQlVGRkVSX0JJVCk7Y29uc3QgUT0hT2JqZWN0KGQuaXNVbml0VHJhbnNmb3JtKSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCk7dGhpcy5fZHJhd0NhbGxzPTA7Zm9yKGNvbnN0IF8gb2Ygeil7dGhpcy5fZHJhd0NhbGxzKys7Y29uc3QgRj1SfHxfLnByb2dyYW07aWYoXyBpbnN0YW5jZW9mIHYuZGVmYXVsdCl0aGlzLmRyYXdNZXNoQ2xvdWQoXyx7Y2xlYXI6RCxwcm9ncmFtOkZ9KTtlbHNle2NvbnN0e3dpZHRoOkcsaGVpZ2h0Olh9PXRoaXMuY2FudmFzO2lmKF8uYmVmb3JlUmVuZGVyJiZfLmJlZm9yZVJlbmRlcihLLF8pLF8ucGFzcy5sZW5ndGgmJigoIXRoaXMuZmJvfHx0aGlzLmZiby53aWR0aCE9PUd8fHRoaXMuZmJvLmhlaWdodCE9PVgpJiYodGhpcy5mYm89e3dpZHRoOkcsaGVpZ2h0OlgsdGFyZ2V0OkMuY3JlYXRlRkJPKCksYnVmZmVyOkMuY3JlYXRlRkJPKCksc3dhcCgpe1t0aGlzLnRhcmdldCx0aGlzLmJ1ZmZlcl09W3RoaXMuYnVmZmVyLHRoaXMudGFyZ2V0XX19KSxDLmJpbmRGQk8odGhpcy5mYm8udGFyZ2V0KSksIUYmJl8uZmlsdGVyQ2FudmFzKXtPYmplY3QoeS5hcHBseVNoYWRlcikoQyx7aGFzVGV4dHVyZTohMH0pO2xldCBaPXRoaXMuZmlsdGVyQ29udGV4dDtafHwoWj1wLmRlZmF1bHQuY3JlYXRlQ2FudmFzKEcsWCkuZ2V0Q29udGV4dCgiMmQiKSx0aGlzLmZpbHRlckNvbnRleHQ9Wik7Y29uc3QgdHQ9SVtfLnBhY2tJbmRleF0sbnQ9dHQuZmlsdGVyLHE9SVtfLnBhY2tJbmRleCsxXSxodD1JW18ucGFja0luZGV4LTFdOyghaHR8fCFodC5maWx0ZXJDYW52YXN8fGh0LmZpbHRlciE9PW50KSYmKCFxfHwhcS5maWx0ZXJDYW52YXN8fHEuZmlsdGVyIT09bnQpPyhRPyhaLnNhdmUoKSxPYmplY3QobC5kcmF3TWVzaDJEKSh0dCxaLCExKSxaLnJlc3RvcmUoKSxPYmplY3QobC5hcHBseUZpbHRlcikoWixudCkpOk9iamVjdChsLmRyYXdNZXNoMkQpKHR0LFosITApLHRoaXNbZ10oKSxBKEMsWixHLFgpKTooUSYmWi5zYXZlKCksT2JqZWN0KGwuZHJhd01lc2gyRCkodHQsWiwhMSksUSYmWi5yZXN0b3JlKCksKCFxfHwhcS5maWx0ZXJDYW52YXN8fHR0LmZpbHRlciE9PXEuZmlsdGVyKSYmKE9iamVjdChsLmFwcGx5RmlsdGVyKShaLG50KSx0aGlzW2ddKCksQShDLFosRyxYKSkpfWVsc2V7aWYoRilDLnByb2dyYW0hPT1GJiZ0aGlzLnVzZVByb2dyYW0oRix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pO2Vsc2V7Y29uc3QgWj0hIV8udW5pZm9ybXMudV90ZXhTYW1wbGVyLHR0PSEhXy51bmlmb3Jtcy51X2ZpbHRlckZsYWcsbnQ9ISFfLnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IscT0hIV8udW5pZm9ybXMudV9jbGlwU2FtcGxlcjtPYmplY3QoeS5hcHBseVNoYWRlcikoQyx7aGFzVGV4dHVyZTpaLGhhc0ZpbHRlcjp0dCxoYXNHcmFkaWVudDpudCxoYXNDbGlwUGF0aDpxfSl9Xy5maWx0ZXJDYW52YXMmJmNvbnNvbGUud2FybigiVXNlciBwcm9ncmFtIGlnbm9yZWQgc29tZSBmaWx0ZXIgZWZmZWN0cy4iKSx0aGlzW2ddKCksQy5zZXRNZXNoRGF0YShbX10pLEUoQyl9aWYoXy5wYXNzLmxlbmd0aCl7Y29uc3QgWj1fLnBhc3MubGVuZ3RoO18ucGFzcy5mb3JFYWNoKCh0dCxudCk9Pnt0dC5ibGVuZD1fLmVuYWJsZUJsZW5kLHR0LnNldFRleHR1cmUoQy5mYm8udGV4dHVyZSksbnQ9PT1aLTE/Qy5iaW5kRkJPKEIpOih0aGlzLmZiby5zd2FwKCksQy5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLHR0LnByb2dyYW0/Qy51c2VQcm9ncmFtKHR0LnByb2dyYW0pOih0aGlzLmRlZmF1bHRQYXNzUHJvZ3JhbT10aGlzLmRlZmF1bHRQYXNzUHJvZ3JhbXx8dGhpcy5jcmVhdGVQYXNzUHJvZ3JhbSgpLEMudXNlUHJvZ3JhbSh0aGlzLmRlZmF1bHRQYXNzUHJvZ3JhbSkpLEMuc2V0TWVzaERhdGEoW3R0Lm1lc2hEYXRhXSksSy5jbGVhcihLLkNPTE9SX0JVRkZFUl9CSVQpLEUoQyl9KX1fLmFmdGVyUmVuZGVyJiZfLmFmdGVyUmVuZGVyKEssXyl9fX1lbHNlIEMuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxDLmRyYXdNZXNoZXMoSSx7Y2xlYXI6RH0pfWRyYXdJbWFnZShJLC4uLkQpe2NvbnN0IFI9RC5sZW5ndGg7aWYoUjwyKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICdkcmF3SW1hZ2UnIG9uICdSZW5kZXJlcic6IDMgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke0QubGVuZ3RoKzF9IHByZXNlbnQuYCk7aWYoUiE9PTImJlIhPT00JiZSIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiBWYWxpZCBhcml0aWVzIGFyZTogWzMsIDUsIDldLCBidXQgJHtELmxlbmd0aCsxfSBhcmd1bWVudHMgcHJvdmlkZWQuYCk7bGV0IEM9bnVsbCxCPW51bGw7Uj09PTI/Qz1bRFswXSxEWzFdLEkud2lkdGgsSS5oZWlnaHRdOlI9PT00P0M9RDpSPT09OCYmKEI9RC5zbGljZSgwLDQpLEM9RC5zbGljZSg0KSk7Y29uc3Qgej10aGlzLmNyZWF0ZVRleHR1cmUoSSkse3dpZHRoOkssaGVpZ2h0OlF9PXRoaXMuY2FudmFzLF89bmV3IHMuZGVmYXVsdDtfLnJlY3QoQ1swXSxDWzFdLEssUSk7Y29uc3QgRj1uZXcgZi5kZWZhdWx0KF8se3dpZHRoOkssaGVpZ2h0OlF9KTtGLnNldFRleHR1cmUoeix7cmVjdDpDLHNyY1JlY3Q6Qn0pLHRoaXMuZHJhd01lc2hlcyhbRl0pLHRoaXMuZGVsZXRlVGV4dHVyZSh6KX1zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uSSl7cmV0dXJuIHRoaXNbY109W0lbMF0sSVsxXSwwLElbMl0sSVszXSwwLElbNF0sSVs1XSwxXSx0aGlzfWdsb2JhbFRyYW5zZm9ybSguLi5JKXtjb25zdCBEPXRoaXNbY107cmV0dXJuIHRoaXNbY109bi5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxELEkpLHRoaXN9Z2xvYmFsVHJhbnNsYXRlKEksRCl7bGV0IFI9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBSPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFIsW0ksRF0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLlIpfWdsb2JhbFJvdGF0ZShJLFtELFJdPVswLDBdKXtsZXQgQz1uLm1hdDMuY3JlYXRlKCk7cmV0dXJuIEM9bi5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxbRCxSXSksQz1uLm1hdDMucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxDLEkpLEM9bi5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxbLUQsLVJdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5DKX1nbG9iYWxTY2FsZShJLEQ9SSxbUixDXT1bMCwwXSl7bGV0IEI9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsW1IsQ10pLEI9bi5tYXQzLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFtJLERdKSxCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsWy1SLC1DXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQil9Z2xvYmFsU2tldyhJLEQ9SSxbUixDXT1bMCwwXSl7bGV0IEI9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsW1IsQ10pLEI9bi5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLG4ubWF0My5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRCksTWF0aC50YW4oSSksMSwwLDApKSxCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsWy1SLC1DXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQil9dHJhbnNmb3JtUG9pbnQoSSxELFIpe2xldCBDPXRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O1ImJihDPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxSKSk7Y29uc3QgQj1JKkNbMF0rRCpDWzJdK0NbNF0sej1JKkNbMV0rRCpDWzNdK0NbNV07cmV0dXJuW0Isel19fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKTt2YXIgcj10KDE1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuZGVmYXVsdH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pO3ZhciByPXQoMTYpLG49dCgxNyksaT10KDE4KSxhPXQoMTkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKFAseCxtKXtyZXR1cm4geCBpbiBQP09iamVjdC5kZWZpbmVQcm9wZXJ0eShQLHgse3ZhbHVlOm0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpQW3hdPW0sUH1jb25zdCBzPXt9O2Z1bmN0aW9uIGYoUCx4PTMpe2NvbnN0IG09W10sTz1QLmxlbmd0aDtmb3IobGV0IG89MDtvPE87bysrKW8leDwyJiZtLnB1c2goLjUqKFBbb10rMSkpO3JldHVybiBtfWZ1bmN0aW9uIHYoUCx4KXtjb25zdCBtPXguX2J1ZmZlcnM7T2JqZWN0LnZhbHVlcyhtKS5mb3JFYWNoKE89PntQLmRlbGV0ZUJ1ZmZlcihPKX0pLHguX2J1ZmZlcnM9e319ZnVuY3Rpb24gZChQLHgsbSl7cmV0dXJuIFAuYWN0aXZlVGV4dHVyZShQLlRFWFRVUkUwK20pLEFycmF5LmlzQXJyYXkoeC5faW1nKT9QLmJpbmRUZXh0dXJlKFAuVEVYVFVSRV9DVUJFX01BUCx4KTpQLmJpbmRUZXh0dXJlKFAuVEVYVFVSRV8yRCx4KSx4fWNvbnN0IHA9e2ludDoiMWkiLGl2ZWMyOiIyaSIsaXZlYzM6IjNpIixpdmVjNDoiNGkiLGZsb2F0OiIxZiIsdmVjMjoiMmYiLHZlYzM6IjNmIix2ZWM0OiI0ZiIsbWF0MjoiTWF0cml4MmZ2IixtYXQzOiJNYXRyaXgzZnYiLG1hdDQ6Ik1hdHJpeDRmdiIsc2FtcGxlcjFEOiJzYW1wbGVyMUQiLHNhbXBsZXIyRDoic2FtcGxlcjJEIixzYW1wbGVyM0Q6InNhbXBsZXIzRCIsc2FtcGxlckN1YmU6InNhbXBsZXJDdWJlIixzYW1wbGVyMURTaGFkb3c6InNhbXBsZXIxRFNoYWRvdyIsc2FtcGxlcjJEU2hhZG93OiJzYW1wbGVyMkRTaGFkb3ciLHNhbXBsZXIyRFJlY3Q6InNhbXBsZXIyRFJlY3QiLHNhbXBsZXIyRFJlY3RTaGFkb3c6InNhbXBsZXIyRFJlY3RTaGFkb3cifTtjbGFzcyB5e3N0YXRpYyBhZGRMaWJzKHg9e30pe09iamVjdC5hc3NpZ24ocyx4KX1zdGF0aWMgRkxPQVQoeCxtKXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKHgsRmxvYXQzMkFycmF5LG0pfXN0YXRpYyBVTlNJR05FRF9CWVRFKHgsbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKSh4LFVpbnQ4QXJyYXksbSl9c3RhdGljIFVOU0lHTkVEX1NIT1JUKHgsbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKSh4LFVpbnQxNkFycmF5LG0pfXN0YXRpYyBCWVRFKHgsbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKSh4LEludDhBcnJheSxtKX1zdGF0aWMgU0hPUlQoeCxtKXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKHgsSW50MTZBcnJheSxtKX1jb25zdHJ1Y3Rvcih4LG09e30pe3RoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LHkuZGVmYXVsdE9wdGlvbnMsbSksdGhpcy5jYW52YXM9eDtsZXQgTzt0aGlzLm9wdGlvbnMud2ViZ2wyJiYoTz14LmdldENvbnRleHQoIndlYmdsMiIsdGhpcy5vcHRpb25zKSksTz09bnVsbCYmKE89T2JqZWN0KHIuc2V0dXBXZWJHTCkoeCx0aGlzLm9wdGlvbnMpLHRoaXMuYWlhX2V4dD1PLmdldEV4dGVuc2lvbigiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpKSx0aGlzLmdsPU8sTy52aWV3cG9ydCgwLDAseC53aWR0aCx4LmhlaWdodCksTy5jbGVhckNvbG9yKDAsMCwwLDApLE8uYmxlbmRGdW5jU2VwYXJhdGUoTy5TUkNfQUxQSEEsTy5PTkVfTUlOVVNfU1JDX0FMUEhBLE8uT05FLE8uT05FX01JTlVTX1NSQ19BTFBIQSksdGhpcy5wcm9ncmFtcz1bXSx0aGlzLl9ldmVudHM9e319Z2V0IHByb2dyYW0oKXtjb25zdCB4PXRoaXMuZ2w7cmV0dXJuIHguZ2V0UGFyYW1ldGVyKHguQ1VSUkVOVF9QUk9HUkFNKX1fZGVjbGFyZVVuaWZvcm0oeCxtLE89IjFmIil7Y29uc3Qgbz10aGlzLmdsLGg9by5nZXRVbmlmb3JtTG9jYXRpb24oeCxtKTtsZXQgYztjb25zdCBnPXRoaXM7aWYoL15zYW1wbGVyLy50ZXN0KE8pKXtjb25zdCBiPXguX3NhbXBsZXJNYXAsRT14Ll9iaW5kVGV4dHVyZXM7T2JqZWN0LmRlZmluZVByb3BlcnR5KHgudW5pZm9ybXMsbSx7Z2V0KCl7cmV0dXJuIGN9LHNldChBKXtjPUE7Y29uc3QgTD1iW21dIT1udWxsP2JbbV06RS5sZW5ndGg7RVtMXT1BLGQobyxBLEwpLGJbbV18fChiW21dPUwsby51bmlmb3JtMWkoaCxMKSksZy5vcHRpb25zLmF1dG9VcGRhdGUmJmcudXBkYXRlKCl9LGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwfSl9ZWxzZXtjb25zdCBiPU8uaW5kZXhPZigiTWF0cml4Iik9PT0wLEU9IWImJi92JC8udGVzdChPKSxBPW9bYHVuaWZvcm0ke099YF0uYmluZChvKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeC51bmlmb3JtcyxtLHtnZXQoKXtyZXR1cm4gY30sc2V0KEwpe2M9TCx0eXBlb2YgTD09Im51bWJlciImJihMPVtMXSksYj9BKGgsITEsTCk6RT9BKGgsTCk6QShoLC4uLkwpLGcub3B0aW9ucy5hdXRvVXBkYXRlJiZnLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfX1fZHJhdygpe2NvbnN0IHg9dGhpcy5wcm9ncmFtO3gubWVzaERhdGEuZm9yRWFjaCgobSxPKT0+e2NvbnN0e3Bvc2l0aW9uczpvLGNlbGxzOmgsaW5zdGFuY2VDb3VudDpjLGNlbGxzQ291bnQ6ZyxhdHRyaWJ1dGVzOmIsdW5pZm9ybXM6RSx0ZXh0dXJlQ29vcmQ6QSxlbmFibGVCbGVuZDpMfT1tLE09dGhpcy5nbDtsZXQgST1tLm1vZGUhPW51bGw/bS5tb2RlOk0uVFJJQU5HTEVTO3R5cGVvZiBJPT0ic3RyaW5nIiYmKEk9TVtJXSksTD9NLmVuYWJsZShNLkJMRU5EKTpNLmRpc2FibGUoTS5CTEVORCksTS5iaW5kQnVmZmVyKE0uQVJSQVlfQlVGRkVSLHguX2J1ZmZlcnMudmVydGljZXNCdWZmZXIpLE0uYnVmZmVyRGF0YShNLkFSUkFZX0JVRkZFUixvLE0uU1RBVElDX0RSQVcpLGgmJihNLmJpbmRCdWZmZXIoTS5FTEVNRU5UX0FSUkFZX0JVRkZFUix4Ll9idWZmZXJzLmNlbGxzQnVmZmVyKSxNLmJ1ZmZlckRhdGEoTS5FTEVNRU5UX0FSUkFZX0JVRkZFUixoLE0uU1RBVElDX0RSQVcpKTtjb25zdCBEPVtdO2ImJk9iamVjdC52YWx1ZXMoYikuZm9yRWFjaCgoe25hbWU6QyxkYXRhOkIsZGl2aXNvcjp6fSk9PntpZihNLmJpbmRCdWZmZXIoTS5BUlJBWV9CVUZGRVIseC5fYnVmZmVyc1tDXSksTS5idWZmZXJEYXRhKE0uQVJSQVlfQlVGRkVSLEIsTS5TVEFUSUNfRFJBVykseiE9bnVsbCl7Y29uc3QgSz1NLmdldEF0dHJpYkxvY2F0aW9uKHgsQyk7Sz49MCYmKE0uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoSyksRC5wdXNoKEspLE0udmVydGV4QXR0cmliRGl2aXNvcj9NLnZlcnRleEF0dHJpYkRpdmlzb3IoSyx6KTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoSyx6KSl9fSksRSYmT2JqZWN0LmVudHJpZXMoRSkuZm9yRWFjaCgoW0MsQl0pPT57dGhpcy51bmlmb3Jtc1tDXT1CfSk7bGV0IFI7aWYoIWgpe2NvbnN0IEM9eC5fZGltZW5zaW9uO1I9by5sZW5ndGgvQ31pZih4Ll9lbmFibGVUZXh0dXJlcyYmeC5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcil7Y29uc3QgQz1BfHxmKG8seC5fZGltZW5zaW9uKTtNLmJpbmRCdWZmZXIoTS5BUlJBWV9CVUZGRVIseC5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlciksTS5idWZmZXJEYXRhKE0uQVJSQVlfQlVGRkVSLHkuRkxPQVQoQyksTS5TVEFUSUNfRFJBVyl9YyE9bnVsbD8oaD9NLmRyYXdFbGVtZW50c0luc3RhbmNlZD9NLmRyYXdFbGVtZW50c0luc3RhbmNlZChJLGcsTS5VTlNJR05FRF9TSE9SVCwwLGMpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKEksZyxNLlVOU0lHTkVEX1NIT1JULDAsYyk6TS5kcmF3QXJyYXlzSW5zdGFuY2VkP00uZHJhd0FycmF5c0luc3RhbmNlZChJLDAsUixjKTp0aGlzLmFpYV9leHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKEksMCxSLGMpLEQuZm9yRWFjaChDPT57TS52ZXJ0ZXhBdHRyaWJEaXZpc29yP00udmVydGV4QXR0cmliRGl2aXNvcihDLG51bGwpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShDLG51bGwpfSkpOmg/TS5kcmF3RWxlbWVudHMoSSxnLE0uVU5TSUdORURfU0hPUlQsMCk6TS5kcmF3QXJyYXlzKEksMCxSKX0pfWdldCBpc1dlYkdMMigpe3JldHVybiB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDwidSImJnRoaXMuZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0fWdldCBlbmFibGVUZXh0dXJlcygpe3JldHVybiB0aGlzLnByb2dyYW0mJnRoaXMucHJvZ3JhbS5fZW5hYmxlVGV4dHVyZXN9Z2V0IHVuaWZvcm1zKCl7Y29uc3QgeD10aGlzLnByb2dyYW07aWYoIXh8fCF4LnVuaWZvcm1zKXRocm93IEVycm9yKCJObyBhdmFsaWFibGUgcHJvZ3JhbS4iKTtyZXR1cm4geC51bmlmb3Jtc31kZWxldGVQcm9ncmFtKHgpe2NvbnN0IG09dGhpcy5nbDt0aGlzLnByb2dyYW09PT14JiYodGhpcy5zdGFydFJlbmRlcj0hMSx0aGlzLl9yZW5kZXJGcmFtZUlEJiYoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyRnJhbWVJRCksZGVsZXRlIHRoaXMuX3JlbmRlckZyYW1lSUQpLG0udXNlUHJvZ3JhbShudWxsKSk7Y29uc3QgTz10aGlzLnByb2dyYW1zLmluZGV4T2YoeCk7Tz49MCYmdGhpcy5wcm9ncmFtcy5zcGxpY2UoTywxKSx2KG0seCksbS5kZWxldGVQcm9ncmFtKHgpfXNldE1lc2hEYXRhKHgpe0FycmF5LmlzQXJyYXkoeCl8fCh4PVt4XSk7Y29uc3QgbT10aGlzLnByb2dyYW07bS5tZXNoRGF0YT14Lm1hcCgoe21vZGU6Tyxwb3NpdGlvbnM6byxpbnN0YW5jZUNvdW50OmgsY2VsbHM6YyxjZWxsc0NvdW50OmcsYXR0cmlidXRlczpiLHVuaWZvcm1zOkUsdGV4dHVyZUNvb3JkOkEsZW5hYmxlQmxlbmQ6TH0pPT57Y29uc3QgTT17cG9zaXRpb25zOnkuRkxPQVQobyksdW5pZm9ybXM6RSxlbmFibGVCbGVuZDohIUwsdGV4dHVyZUNvb3JkOnkuRkxPQVQoQSl9O2lmKGMmJihNLmNlbGxzPXkuVVNIT1JUKGMpLE0uY2VsbHNDb3VudD1nfHxNLmNlbGxzLmxlbmd0aCksTyE9bnVsbCYmKE0ubW9kZT1PKSxoIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgaW5zdGFuY2VDb3VudCBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtNLmluc3RhbmNlQ291bnQ9aH1pZihiKXtjb25zdCBJPXt9O09iamVjdC5lbnRyaWVzKGIpLmZvckVhY2goKFtELFJdKT0+e2lmKCFtLl9hdHRyaWJ1dGVbRF0pbS5fYXR0cmlidXRlW0RdPSJpZ25vcmVkIjtlbHNlIGlmKG0uX2F0dHJpYnV0ZVtEXSE9PSJpZ25vcmVkIil7Y29uc3R7bmFtZTpDLHR5cGU6Qn09bS5fYXR0cmlidXRlW0RdO2xldCB6PVIuZGF0YXx8UjtpZihBcnJheS5pc0FycmF5KHopJiYoej15W0JdKHopKSxJW0RdPXtuYW1lOkMsZGF0YTp6fSxSLmRpdmlzb3IhPW51bGwpe2lmKCF0aGlzLmlzV2ViR0wyJiYhdGhpcy5haWFfZXh0KXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHVzZSBkaXZpc29yIGluIHRoaXMgcmVuZGVyaW5nIGNvbnRleHQsIHVzZSB3ZWJnbDIgY29udGV4dCBpbnN0ZWFkLiIpO0lbRF0uZGl2aXNvcj1SLmRpdmlzb3J9fX0pLE0uYXR0cmlidXRlcz1JfXJldHVybiBNfSksdGhpcy5vcHRpb25zLmF1dG9VcGRhdGUmJnRoaXMudXBkYXRlKCl9Y3JlYXRlUHJvZ3JhbSh4LG0pe2NvbnN0IE89L15ccyp1bmlmb3JtXHMrc2FtcGxlci9tZy50ZXN0KHgpO3g9PW51bGwmJih4PWkuZGVmYXVsdCksbT09bnVsbCYmKG09Tz9hLmRlZmF1bHQ6bi5kZWZhdWx0KTtjb25zdCBvPXRoaXMuZ2wsaD1PYmplY3Qoci5jcmVhdGVQcm9ncmFtKShvLG0seCk7aC5zaGFkZXJUZXh0PXt2ZXJ0ZXhTaGFkZXI6bSxmcmFnbWVudFNoYWRlcjp4fSxoLl9idWZmZXJzPXt9LGguX2F0dHJpYnV0ZT17fSxoLnVuaWZvcm1zPXt9LGguX3NhbXBsZXJNYXA9e30saC5fYmluZFRleHR1cmVzPVtdO2NvbnN0IGM9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhQb3NpdGlvbn1gLCJpbSIpO2xldCBnPW0ubWF0Y2goYyk7ZyYmKGguX2RpbWVuc2lvbj1OdW1iZXIoZ1sxXSkpO2NvbnN0IGI9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhUZXh0dXJlQ29vcmR9YCwiaW0iKTtnPW0ubWF0Y2goYiksZyYmKGguX3RleENvb3JkU2l6ZT1OdW1iZXIoZ1sxXSkpO2NvbnN0IEU9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2dpbTtpZihnPW0ubWF0Y2goRSksZylmb3IobGV0IE09MDtNPGcubGVuZ3RoO00rKyl7Y29uc3QgST0vXlxzKig/OmF0dHJpYnV0ZXxpbikgKFx3Kz8pKFxkKikgKFx3KykvaW0sRD1nW01dLm1hdGNoKEkpO2lmKEQmJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24mJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKXtsZXRbLFIsQyxCXT1EO1I9PT0ibWF0IiYmKEMqKj0yKSxoLl9idWZmZXJzW0JdPW8uY3JlYXRlQnVmZmVyKCksaC5fYXR0cmlidXRlW0JdPXtuYW1lOkIsdHlwZTpSLHNpemU6TnVtYmVyKEMpfHwxfX19Y29uc3QgQT0vXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy9tZztnPW0ubWF0Y2goQSl8fFtdLGc9Zy5jb25jYXQoeC5tYXRjaChBKXx8W10pLGcuZm9yRWFjaChNPT57Y29uc3QgST1NLm1hdGNoKC9eXHMqdW5pZm9ybVxzKyhcdyspXHMrKFx3KykoXFtcZCtcXSk/Lyk7bGV0W0QsUixDXT1JLnNsaWNlKDEpO0Q9cFtEXSxDPSEhQyxELmluZGV4T2YoIk1hdHJpeCIpIT09MCYmQyYmKEQrPSJ2IiksdGhpcy5fZGVjbGFyZVVuaWZvcm0oaCxSLEQpfSksaC5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcj1vLmNyZWF0ZUJ1ZmZlcigpLGguX2J1ZmZlcnMuY2VsbHNCdWZmZXI9by5jcmVhdGVCdWZmZXIoKTtjb25zdCBMPW8uZ2V0QXR0cmliTG9jYXRpb24oaCx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtyZXR1cm4gaC5fZW5hYmxlVGV4dHVyZXM9TD49MCxoLl9lbmFibGVUZXh0dXJlcyYmKGguX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXI9by5jcmVhdGVCdWZmZXIoKSksdGhpcy5wcm9ncmFtcy5wdXNoKGgpLGh9dXNlUHJvZ3JhbSh4LG09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKTtjb25zdCBPPXRoaXMuZ2w7Ty51c2VQcm9ncmFtKHgpO2NvbnN0IG89eC5fZGltZW5zaW9uO08uYmluZEJ1ZmZlcihPLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKTtjb25zdCBoPU8uZ2V0QXR0cmliTG9jYXRpb24oeCx0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24pO2lmKE8udmVydGV4QXR0cmliUG9pbnRlcihoLG8sTy5GTE9BVCwhMSwwLDApLE8uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaCkseC5fZW5hYmxlVGV4dHVyZXMpe08uYmluZEJ1ZmZlcihPLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzLnRleENvb3JkQnVmZmVyKTtjb25zdCBjPU8uZ2V0QXR0cmliTG9jYXRpb24oeCx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtPLnZlcnRleEF0dHJpYlBvaW50ZXIoYyx4Ll90ZXhDb29yZFNpemV8fDIsTy5GTE9BVCwhMSwwLDApLE8uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYyl9aWYoT2JqZWN0LmVudHJpZXMoeC5fYXR0cmlidXRlKS5mb3JFYWNoKChbYyxnXSk9PntpZihnIT09Imlnbm9yZWQiKXtjb25zdCBiPWcuc2l6ZSxFPW1bY118fHt9LEE9ISFFLm5vcm1hbGl6ZTtsZXQgTD1FLnR5cGV8fCJGTE9BVCI7Y29uc3QgTT1FLmtleXx8YztMPT09IlVCWVRFIiYmKEw9IlVOU0lHTkVEX0JZVEUiKSxMPT09IlVTSE9SVCImJihMPSJVTlNJR05FRF9TSE9SVCIpLGcudHlwZT1MLE0mJk0hPT1jJiYoeC5fYXR0cmlidXRlW01dPWcpLE8uYmluZEJ1ZmZlcihPLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzW2NdKTtjb25zdCBJPU8uZ2V0QXR0cmliTG9jYXRpb24oeCxjKTtJPj0wJiYoTy52ZXJ0ZXhBdHRyaWJQb2ludGVyKEksYixPW0xdLEEsMCwwKSxPLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEkpKX19KSwheC5tZXNoRGF0YSl7Y29uc3QgYz1bWy0xLC0xLDAsMV0uc2xpY2UoMCxvKSxbMSwtMSwwLDFdLnNsaWNlKDAsbyksWzEsMSwwLDFdLnNsaWNlKDAsbyksWy0xLDEsMCwxXS5zbGljZSgwLG8pXSxnPVtbMCwxLDNdLFszLDEsMl1dO3RoaXMuc2V0TWVzaERhdGEoe3Bvc2l0aW9uczpjLGNlbGxzOmd9KX1yZXR1cm4geH1jb21waWxlU3luYyh4LG0pe3g9eHx8aS5kZWZhdWx0O2NvbnN0IE89e307ZnVuY3Rpb24gbyhiKXtiPWIucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgRT1bXSxBPWIubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihBKXtmb3IobGV0IEw9MDtMPEEubGVuZ3RoO0wrKyl7Y29uc3QgST1BW0xdLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihJKXtjb25zdCBEPUlbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9SVsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIiksT1tSXSlFLnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKE9bUl09ITAsRD09PSJsaWIiKXtjb25zdCBDPW8oc1tSXSk7RS5wdXNoKEMpfWVsc2UgaWYoRD09PSJsaW5rIil0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBsb2FkIGV4dGVybmFsIGxpbmtzIHN5bmNocm9ub3VzbHkuIFVzZSBjb21waWxlIGluc3RlYWQgb2YgY29tcGlsZVN5bmMuIil9fUUuZm9yRWFjaChMPT57Yj1iLnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sTCl9KX1yZXR1cm4gYn1jb25zdCBoPW8oeCksYz1tP28obSk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGgsYyl9YXN5bmMgY29tcGlsZSh4LG0pe3g9eHx8aS5kZWZhdWx0O2NvbnN0IE89e307YXN5bmMgZnVuY3Rpb24gbyhiKXtiPWIucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgRT1bXSxBPWIubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihBKXtmb3IobGV0IEw9MDtMPEEubGVuZ3RoO0wrKyl7Y29uc3QgST1BW0xdLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihJKXtjb25zdCBEPUlbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9SVsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIiksT1tSXSlFLnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKE9bUl09ITAsRD09PSJsaWIiKXtjb25zdCBDPWF3YWl0IG8oc1tSXSk7RS5wdXNoKEMpfWVsc2UgaWYoRD09PSJsaW5rIil7bGV0IEM9YXdhaXQgeS5mZXRjaFNoYWRlcihSKTtDPWF3YWl0IG8oQyksRS5wdXNoKEMpfX19RS5mb3JFYWNoKEw9PntiPWIucmVwbGFjZSgvXiNwcmFnbWFccytpbmNsdWRlXHMrLiovbSxMKX0pfXJldHVybiBifWNvbnN0IGg9YXdhaXQgbyh4KSxjPW0/YXdhaXQgbyhtKTpudWxsO3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oaCxjKX1hc3luYyBsb2FkKHgsbT1udWxsKXtyZXR1cm4geD1hd2FpdCB5LmZldGNoU2hhZGVyKHgpLG0mJihtPWF3YWl0IHkuZmV0Y2hTaGFkZXIobSkpLHRoaXMuY29tcGlsZSh4LG0pfWNyZWF0ZVRleHR1cmUoeD1udWxsLHt3cmFwUzptPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSx3cmFwVDpPPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSxtaW5GaWx0ZXI6bz10aGlzLmdsLkxJTkVBUixtYWdGaWx0ZXI6aD10aGlzLmdsLkxJTkVBUn09e30pe2NvbnN0IGM9dGhpcy5nbCxnPUFycmF5LmlzQXJyYXkoeCk/Yy5URVhUVVJFX0NVQkVfTUFQOmMuVEVYVFVSRV8yRDt0aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0cz10aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0c3x8Yy5nZXRQYXJhbWV0ZXIoYy5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyksYy5hY3RpdmVUZXh0dXJlKGMuVEVYVFVSRTArdGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHMtMSk7Y29uc3QgYj1jLmNyZWF0ZVRleHR1cmUoKTtjLmJpbmRUZXh0dXJlKGcsYiksYy5waXhlbFN0b3JlaShjLlVOUEFDS19GTElQX1lfV0VCR0wsITApO2NvbnN0e3dpZHRoOkUsaGVpZ2h0OkF9PXRoaXMuY2FudmFzO2lmKHgpaWYoZz09PWMuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEw9MDtMPDY7TCsrKWMudGV4SW1hZ2UyRChjLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtMLDAsYy5SR0JBLGMuUkdCQSxjLlVOU0lHTkVEX0JZVEUseFtMXSk7ZWxzZSBjLnRleEltYWdlMkQoZywwLGMuUkdCQSxjLlJHQkEsYy5VTlNJR05FRF9CWVRFLHgpO2Vsc2UgaWYoZz09PWMuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEw9MDtMPDY7TCsrKXRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtMLDAsYy5SR0JBLEUsQSwwLGMuUkdCQSxjLlVOU0lHTkVEX0JZVEUsbnVsbCk7ZWxzZSBjLnRleEltYWdlMkQoZywwLGMuUkdCQSxFLEEsMCxjLlJHQkEsYy5VTlNJR05FRF9CWVRFLG51bGwpO3JldHVybiBjLnRleFBhcmFtZXRlcmkoZyxjLlRFWFRVUkVfTUlOX0ZJTFRFUixvKSxjLnRleFBhcmFtZXRlcmkoZyxjLlRFWFRVUkVfTUFHX0ZJTFRFUixoKSxjLnRleFBhcmFtZXRlcmkoZyxjLlRFWFRVUkVfV1JBUF9TLG0pLGMudGV4UGFyYW1ldGVyaShnLGMuVEVYVFVSRV9XUkFQX1QsTyksZz09PWMuVEVYVFVSRV9DVUJFX01BUCYmKHgud2lkdGg9eFswXS53aWR0aCx4LmhlaWdodD14WzBdLmhlaWdodCksYy5iaW5kVGV4dHVyZShnLG51bGwpLGIuX2ltZz14fHx7d2lkdGg6RSxoZWlnaHQ6QX0sYi5kZWxldGU9KCk9Pnt0aGlzLmRlbGV0ZVRleHR1cmUoYil9LGJ9ZGVsZXRlVGV4dHVyZSh4KXtjb25zdCBtPXguX2ltZzt0aGlzLmdsLmRlbGV0ZVRleHR1cmUoeCksdHlwZW9mIG0uY2xvc2U9PSJmdW5jdGlvbiImJm0uY2xvc2UoKX1hc3luYyBsb2FkVGV4dHVyZSh4LHt1c2VJbWFnZUJpdG1hcDptPSEwfT17fSl7Y29uc3QgTz1hd2FpdCB5LmxvYWRJbWFnZSh4LHt1c2VJbWFnZUJpdG1hcDptfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShPKX1jcmVhdGVGQk8oe2NvbG9yOng9MSxibGVuZDptPSExLGRlcHRoOk89dGhpcy5vcHRpb25zLmRlcHRoIT09ITEsc3RlbmNpbDpvPSEhdGhpcy5vcHRpb25zLnN0ZW5jaWx9PXt9KXtjb25zdCBoPXRoaXMuZ2wsYz1oLmNyZWF0ZUZyYW1lYnVmZmVyKCk7aC5iaW5kRnJhbWVidWZmZXIoaC5GUkFNRUJVRkZFUixjKTtjb25zdCBnPVtdO2ZvcihsZXQgQT0wO0E8eDtBKyspe2NvbnN0IEw9dGhpcy5jcmVhdGVUZXh0dXJlKCk7aC5mcmFtZWJ1ZmZlclRleHR1cmUyRChoLkZSQU1FQlVGRkVSLGguQ09MT1JfQVRUQUNITUVOVDArQSxoLlRFWFRVUkVfMkQsTCwwKSxnLnB1c2goTCl9Yy50ZXh0dXJlcz1nLGMudGV4dHVyZT1nWzBdLGMuYmxlbmQ9bTtjb25zdHt3aWR0aDpiLGhlaWdodDpFfT10aGlzLmNhbnZhcztyZXR1cm4gTyYmIW8mJihjLmRlcHRoQnVmZmVyPWguY3JlYXRlUmVuZGVyYnVmZmVyKCksaC5iaW5kUmVuZGVyYnVmZmVyKGguUkVOREVSQlVGRkVSLGMuZGVwdGhCdWZmZXIpLGgucmVuZGVyYnVmZmVyU3RvcmFnZShoLlJFTkRFUkJVRkZFUixoLkRFUFRIX0NPTVBPTkVOVDE2LGIsRSksaC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihoLkZSQU1FQlVGRkVSLGguREVQVEhfQVRUQUNITUVOVCxoLlJFTkRFUkJVRkZFUixjLmRlcHRoQnVmZmVyKSksbyYmIU8mJihjLnN0ZW5jaWxCdWZmZXI9aC5jcmVhdGVSZW5kZXJidWZmZXIoKSxoLmJpbmRSZW5kZXJidWZmZXIoaC5SRU5ERVJCVUZGRVIsYy5zdGVuY2lsQnVmZmVyKSxoLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoaC5SRU5ERVJCVUZGRVIsaC5TVEVOQ0lMX0lOREVYOCxiLEUpLGguZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoaC5GUkFNRUJVRkZFUixoLlNURU5DSUxfQVRUQUNITUVOVCxoLlJFTkRFUkJVRkZFUixjLnN0ZW5jaWxCdWZmZXIpKSxPJiZvJiYoYy5kZXB0aFN0ZW5jaWxCdWZmZXI9aC5jcmVhdGVSZW5kZXJidWZmZXIoKSxoLmJpbmRSZW5kZXJidWZmZXIoaC5SRU5ERVJCVUZGRVIsYy5kZXB0aFN0ZW5jaWxCdWZmZXIpLGgucmVuZGVyYnVmZmVyU3RvcmFnZShoLlJFTkRFUkJVRkZFUixoLkRFUFRIX1NURU5DSUwsYixFKSxoLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGguRlJBTUVCVUZGRVIsaC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsaC5SRU5ERVJCVUZGRVIsYy5kZXB0aFN0ZW5jaWxCdWZmZXIpKSxoLmJpbmRGcmFtZWJ1ZmZlcihoLkZSQU1FQlVGRkVSLG51bGwpLGN9YmluZEZCTyh4PW51bGwpe3RoaXMuZmJvPXh9cmVuZGVyKHtjbGVhckJ1ZmZlcjp4PSEwfT17fSl7dGhpcy5zdGFydFJlbmRlcj0hMDtjb25zdCBtPXRoaXMuZ2w7bGV0IE89dGhpcy5wcm9ncmFtO098fChPPXRoaXMuY3JlYXRlUHJvZ3JhbSgpLHRoaXMudXNlUHJvZ3JhbShPKSksdGhpcy5mYm8mJm0uYmluZEZyYW1lYnVmZmVyKG0uRlJBTUVCVUZGRVIsdGhpcy5mYm8pO2NvbnN0IG89dGhpcy5vcHRpb25zLmRlcHRoO28mJm0uZW5hYmxlKG0uREVQVEhfVEVTVCksdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVR8KG8/dGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUOjApfCh0aGlzLm9wdGlvbnMuc3RlbmNpbD90aGlzLmdsLlNURU5DSUxfQlVGRkVSX0JJVDowKSk7Y29uc3QgaD10aGlzLl9yZW5kZXJGcmFtZUlEO3RoaXMuX2RyYXcoKSx0aGlzLmZibyYmbS5iaW5kRnJhbWVidWZmZXIobS5GUkFNRUJVRkZFUixudWxsKSx0aGlzLl9yZW5kZXJGcmFtZUlEPT09aCYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9bnVsbCl9dXBkYXRlKCl7dGhpcy5zdGFydFJlbmRlciYmdGhpcy5fcmVuZGVyRnJhbWVJRD09bnVsbCYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyLmJpbmQodGhpcykpKX19bCh5LCJkZWZhdWx0T3B0aW9ucyIse3ByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMCxhdXRvVXBkYXRlOiEwLHZlcnRleFBvc2l0aW9uOiJhX3ZlcnRleFBvc2l0aW9uIix2ZXJ0ZXhUZXh0dXJlQ29vcmQ6ImFfdmVydGV4VGV4dHVyZUNvb3JkIix3ZWJnbDI6ITF9KSxsKHksIlVCWVRFIix5LlVOU0lHTkVEX0JZVEUpLGwoeSwiVVNIT1JUIix5LlVOU0lHTkVEX1NIT1JUKSxsKHksImZldGNoU2hhZGVyIixyLmZldGNoU2hhZGVyKSxsKHksImxvYWRJbWFnZSIsci5sb2FkSW1hZ2UpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJzZXR1cFdlYkdMIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNyZWF0ZVByb2dyYW0iLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwicG9pbnRzVG9CdWZmZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwibG9hZEltYWdlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZldGNoU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiB2fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoZCxwKXtjb25zdCB5PVsid2ViZ2wiLCJleHBlcmltZW50YWwtd2ViZ2wiLCJ3ZWJraXQtM2QiLCJtb3otd2ViZ2wiXTtsZXQgUD1udWxsO2ZvcihsZXQgeD0wO3g8eS5sZW5ndGg7Kyt4KXt0cnl7UD1kLmdldENvbnRleHQoeVt4XSxwKX1jYXRjaHt9aWYoUClicmVha31yZXR1cm4gUH1mdW5jdGlvbiBuKGQscCl7Y29uc3QgeT1yKGQscCk7aWYoIXkpdGhyb3cgbmV3IEVycm9yKCJTb3JyeSwgeW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTC4iKTtyZXR1cm4geX1mdW5jdGlvbiBpKGQscCx5KXtjb25zdCBQPWQuY3JlYXRlU2hhZGVyKGQuVkVSVEVYX1NIQURFUik7aWYoZC5zaGFkZXJTb3VyY2UoUCxwKSxkLmNvbXBpbGVTaGFkZXIoUCksIWQuZ2V0U2hhZGVyUGFyYW1ldGVyKFAsZC5DT01QSUxFX1NUQVRVUykpe2NvbnN0IE89YFZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7ZC5nZXRTaGFkZXJJbmZvTG9nKFApfWA7dGhyb3cgbmV3IEVycm9yKE8pfWNvbnN0IHg9ZC5jcmVhdGVTaGFkZXIoZC5GUkFHTUVOVF9TSEFERVIpO2lmKGQuc2hhZGVyU291cmNlKHgseSksZC5jb21waWxlU2hhZGVyKHgpLCFkLmdldFNoYWRlclBhcmFtZXRlcih4LGQuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBPPWBGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7ZC5nZXRTaGFkZXJJbmZvTG9nKHgpfWA7dGhyb3cgbmV3IEVycm9yKE8pfWNvbnN0IG09ZC5jcmVhdGVQcm9ncmFtKCk7aWYoZC5hdHRhY2hTaGFkZXIobSxQKSxkLmF0dGFjaFNoYWRlcihtLHgpLGQubGlua1Byb2dyYW0obSksIWQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihtLGQuTElOS19TVEFUVVMpKXtjb25zdCBPPWBTaGFkZXIgcHJvZ3JhbSBmYWlsZWQgdG8gbGluay4gIFRoZSBlcnJvciBsb2cgaXM6JHtkLmdldFByb2dyYW1JbmZvTG9nKG0pfWA7dGhyb3cgbmV3IEVycm9yKE8pfXJldHVybiBkLmRlbGV0ZVNoYWRlcihQKSxkLmRlbGV0ZVNoYWRlcih4KSxtfWZ1bmN0aW9uIGEoZCxwPUZsb2F0MzJBcnJheSx5PW51bGwpe2lmKHkmJiEoeSBpbnN0YW5jZW9mIHApKXRocm93IG5ldyBUeXBlRXJyb3IoIldyb25nIGJ1ZmZlciB0eXBlLiIpO2lmKGQ9PW51bGx8fGQgaW5zdGFuY2VvZiBwKXJldHVybiBkO2lmKGRbMF09PW51bGx8fGRbMF0ubGVuZ3RoPT1udWxsKXJldHVybiB5Pyh5LnNldChkLDApLHkpOm5ldyBwKGQpO2NvbnN0IFA9ZFswXS5sZW5ndGgseD1kLmxlbmd0aDt5fHwoeT1uZXcgcChQKngpKTtsZXQgbT0wO2ZvcihsZXQgTz0wO088eDtPKyspZm9yKGxldCBvPTA7bzxQO28rKyl5W20rK109ZFtPXVtvXTtyZXR1cm4geX1jb25zdCBsPXt9O2Z1bmN0aW9uIHMoZCx7dXNlSW1hZ2VCaXRtYXA6cD0hMCxhbGlhczp5PW51bGx9PXt9KXtpZighbFtkXSl7aWYodHlwZW9mIEltYWdlPT0iZnVuY3Rpb24iKXtjb25zdCBQPW5ldyBJbWFnZTt0eXBlb2YgZD09InN0cmluZyImJiEodHlwZW9mIGxvY2F0aW9uPT0ib2JqZWN0IiYmL15maWxlOi8udGVzdChsb2NhdGlvbi5ocmVmKSkmJiEvXmRhdGE6Ly50ZXN0KGQpJiYoUC5jcm9zc09yaWdpbj0iYW5vbnltb3VzIiksbFtkXT1uZXcgUHJvbWlzZSh4PT57UC5vbmxvYWQ9ZnVuY3Rpb24oKXtwJiZ0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXA9PSJmdW5jdGlvbiI/Y3JlYXRlSW1hZ2VCaXRtYXAoUCx7aW1hZ2VPcmllbnRhdGlvbjoiZmxpcFkifSkudGhlbihtPT57bFtkXT1tLHkmJihsW3ldPW0pLHgobSl9KToobFtkXT1QLHkmJihsW3ldPVApLHgoUCkpfSxQLnNyYz1kfSkseSYmKGxbeV09bFtkXSl9ZWxzZSBpZih0eXBlb2YgZmV0Y2g9PSJmdW5jdGlvbiIpcmV0dXJuIGZldGNoKGQse21ldGhvZDoiR0VUIixtb2RlOiJjb3JzIixjYWNoZToiZGVmYXVsdCJ9KS50aGVuKFA9PlAuYmxvYigpKS50aGVuKFA9PmNyZWF0ZUltYWdlQml0bWFwKFAse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oeD0+KGxbZF09eCx5JiYobFt5XT14KSx4KSkpfXJldHVybiBsW2RdfWNvbnN0IGY9e307YXN5bmMgZnVuY3Rpb24gdihkKXtpZihmW2RdKXJldHVybiBmW2RdO2NvbnN0IHA9YXdhaXQgZmV0Y2goZCk7aWYocC5zdGF0dXM+PTIwMCYmcC5zdGF0dXM8MzAwKXtjb25zdCB5PWF3YWl0IHAudGV4dCgpO3JldHVybiBmW2RdPXkseX10aHJvdyBuZXcgRXJyb3IoIlNoYWRlciBsb2FkZWQgZXJyb3IuIil9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfdmVydGV4UG9zaXRpb24sIDEpOwp9YH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YCNpZmRlZiBHTF9FUwpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjEpOwp9YH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWM0IGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSBhX3ZlcnRleFBvc2l0aW9uOwogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKfWB9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTt2YXIgcj10KDIxKSxuPXQoMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbCgidHJhbnNmb3JtIik7Y2xhc3MgYXtjb25zdHJ1Y3RvcihzLGYpe3RoaXMuY29udGV4dD1zLmdldENvbnRleHQoIjJkIiksdGhpcy5vcHRpb25zPWYsdGhpc1tpXT1bMSwwLDAsMSwwLDBdfWNyZWF0ZVRleHR1cmUocyl7cmV0dXJue19pbWc6c319YXN5bmMgbG9hZFRleHR1cmUocyl7Y29uc3QgZj1hd2FpdCByLmRlZmF1bHQubG9hZEltYWdlKHMse3VzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShmKX1kZWxldGVUZXh0dXJlKHMpe3JldHVybiBzfWNsZWFyKHMsZix2LGQpe2NvbnN0IHA9dGhpcy5jb250ZXh0O3M9c3x8MCxmPWZ8fDAsdj12fHxwLmNhbnZhcy53aWR0aC1zLGQ9ZHx8cC5jYW52YXMuaGVpZ2h0LWYscC5jbGVhclJlY3QocyxmLHYsZCl9ZHJhd01lc2hDbG91ZChzLHtjbGVhcjpmPSExfT17fSl7Y29uc3Qgdj1bXTtmb3IobGV0IGQ9MDtkPHMuYW1vdW50O2QrKyl7Y29uc3QgcD1zLmdldFRyYW5zZm9ybShkKTtsZXQgeT1zLmdldFRleHR1cmVGcmFtZShkKTt5JiYoeT15Ll9pbWcpO2NvbnN0IFA9cy5nZXRGaWx0ZXIoZCkse2ZpbGw6eCxzdHJva2U6bX09cy5nZXRDbG91ZFJHQkEoZCk7di5wdXNoKHttZXNoOnMubWVzaCxfY2xvdWRPcHRpb25zOlt4LG0seSxwLFBdfSl9cy5iZWZvcmVSZW5kZXImJnMuYmVmb3JlUmVuZGVyKHRoaXMuY29udGV4dCxzKSx0aGlzLmRyYXdNZXNoZXModix7Y2xlYXI6Zixob29rOiExfSkscy5hZnRlclJlbmRlciYmcy5hZnRlclJlbmRlcih0aGlzLmNvbnRleHQscyl9ZHJhd01lc2hlcyhzLHtjbGVhcjpmPSExLGhvb2s6dj0hMH09e30pe2NvbnN0IGQ9dGhpcy5jb250ZXh0O2YmJmQuY2xlYXJSZWN0KDAsMCxkLmNhbnZhcy53aWR0aCxkLmNhbnZhcy5oZWlnaHQpO2xldCBwPW51bGw7Y29uc3R7d2lkdGg6eSxoZWlnaHQ6UH09ZC5jYW52YXMseD1zLmxlbmd0aDtzLmZvckVhY2goKG0sTyk9PntsZXQgbyxoLGMsZyxiO3YmJm0uYmVmb3JlUmVuZGVyJiZtLmJlZm9yZVJlbmRlcihkLG0pLG0uX2Nsb3VkT3B0aW9ucyYmKFtvLGgsYyxnLGJdPW0uX2Nsb3VkT3B0aW9ucyxtPW0ubWVzaCk7bGV0IEU9bS5maWx0ZXI7aWYoYiYmKEU9RT9gJHtFfSAke2J9YDpiKSxFJiYhdGhpcy5maWx0ZXJCdWZmZXImJnRoaXMuZmlsdGVyQnVmZmVyIT09ITEpe2NvbnN0IEE9ci5kZWZhdWx0LmNyZWF0ZUNhbnZhcyh5LFApO0E/dGhpcy5maWx0ZXJCdWZmZXI9QS5nZXRDb250ZXh0KCIyZCIpOnRoaXMuZmlsdGVyQnVmZmVyPSExfXAmJnAhPT1FJiYoT2JqZWN0KG4uYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLHApLGQuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAseSxQKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHksUCkscD1udWxsKSxFJiZ0aGlzLmZpbHRlckJ1ZmZlcj8odGhpcy5maWx0ZXJCdWZmZXIuc2F2ZSgpLHRoaXMuZmlsdGVyQnVmZmVyLnRyYW5zZm9ybSguLi50aGlzW2ldKSxPYmplY3Qobi5kcmF3TWVzaDJEKShtLHRoaXMuZmlsdGVyQnVmZmVyLCExLG8saCxjLGcpLHRoaXMuZmlsdGVyQnVmZmVyLnJlc3RvcmUoKSxPPT09eC0xPyhPYmplY3Qobi5hcHBseUZpbHRlcikodGhpcy5maWx0ZXJCdWZmZXIsRSksZC5kcmF3SW1hZ2UodGhpcy5maWx0ZXJCdWZmZXIuY2FudmFzLDAsMCx5LFApLHRoaXMuZmlsdGVyQnVmZmVyLmNsZWFyUmVjdCgwLDAseSxQKSk6cD1FKTooZC5zYXZlKCksZC50cmFuc2Zvcm0oLi4udGhpc1tpXSksT2JqZWN0KG4uZHJhd01lc2gyRCkobSxkLCExLG8saCxjLGcpLGQucmVzdG9yZSgpKSx2JiZtLmFmdGVyUmVuZGVyJiZtLmFmdGVyUmVuZGVyKGQsbSl9KX1zZXRUcmFuc2Zvcm0ocyl7dGhpc1tpXT1zfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKHIpe3ZhciBuPXQoMTQpLGk9dCgyMyksYT10KDI0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgbD17fTtmdW5jdGlvbiBzKHksUCl7Y29uc3R7c3R5bGU6eCx2YXJpYW50Om0sd2VpZ2h0Ok8sc3RyZXRjaDpvLHNpemU6aCxweExpbmVIZWlnaHQ6YyxmYW1pbHk6Z309eTtyZXR1cm4gbz09PSJub3JtYWwiP2Ake3h9ICR7bX0gJHtPfSAke2gqUH1weC8ke2MqUH1weCAke2d9YDpgJHt4fSAke219ICR7T30gJHtvfSAke2gqUH1weC8ke2MqUH1weCAke2d9YH1mdW5jdGlvbiBmKHkse2ZvbnQ6UCxmaWxsQ29sb3I6eCxzdHJva2VDb2xvcjptLHN0cm9rZVdpZHRoOk8scmF0aW86bz0xLHRleHRDYW52YXM6aCxjYWNoYWJsZTpjPSExfSl7bGV0IGc7aWYoYyl7Zz1beSxQLFN0cmluZyh4KSxTdHJpbmcobSksU3RyaW5nKE8pXS5qb2luKCIjIyMiKTtjb25zdCB6PWxbZ107aWYoeilyZXR1cm4gen1ofHwoaD1kKDEsMSkpO2NvbnN0IGI9aC5nZXRDb250ZXh0KCIyZCIpO2Iuc2F2ZSgpLGIuZm9udD1QO2xldHt3aWR0aDpFfT1iLm1lYXN1cmVUZXh0KHkpO2IucmVzdG9yZSgpO2NvbnN0IEE9T2JqZWN0KGkuZGVmYXVsdCkoUCksTD1NYXRoLm1heChBLnB4TGluZUhlaWdodCxBLnB4SGVpZ2h0KjEuMTMpOy9pdGFsaWN8b2JsaXF1ZS8udGVzdChQKSYmKEUrPUwqTWF0aC50YW4oMTUqTWF0aC5QSS8xODApKSwheCYmIW0mJih4PSIjMDAwIik7Y29uc3QgTT1iLmNhbnZhcyxJPU1hdGguY2VpbChFKSxEPU1hdGguY2VpbChMKTtNLndpZHRoPU1hdGgucm91bmQoSSpvKSxNLmhlaWdodD1NYXRoLnJvdW5kKEQqbyksYi5zYXZlKCksYi5mb250PXMoQSxvKSxiLnRleHRBbGlnbj0iY2VudGVyIixiLnRleHRCYXNlbGluZT0ibWlkZGxlIjtjb25zdCBSPU0uaGVpZ2h0Ki41K0EucHhIZWlnaHQqLjA1Km8sQz1NLndpZHRoKi41O2lmKHgpe2lmKEFycmF5LmlzQXJyYXkoeCkpeD1PYmplY3QoYS5kZWZhdWx0KSh4KTtlbHNlIGlmKHgudmVjdG9yKXtsZXQgejtjb25zdHt2ZWN0b3I6Syxjb2xvcnM6UX09eDtLLmxlbmd0aD09PTY/ej1iLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkspOno9Yi5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5LKSxRLmZvckVhY2goKHtvZmZzZXQ6Xyxjb2xvcjpGfSk9Pnt6LmFkZENvbG9yU3RvcChfLEYpfSkseD16fWIuZmlsbFN0eWxlPXgsYi5maWxsVGV4dCh5LEMsUil9aWYobSl7aWYoYi5saW5lV2lkdGg9TypvLEFycmF5LmlzQXJyYXkobSkpbT1PYmplY3QoYS5kZWZhdWx0KShtKTtlbHNlIGlmKG0udmVjdG9yKXtsZXQgejtjb25zdHt2ZWN0b3I6Syxjb2xvcnM6UX09bTtLLmxlbmd0aD09PTY/ej1iLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkspOno9Yi5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5LKSxRLmZvckVhY2goKHtvZmZzZXQ6Xyxjb2xvcjpGfSk9Pnt6LmFkZENvbG9yU3RvcChfLEYpfSksbT16fWIuc3Ryb2tlU3R5bGU9bSxiLnN0cm9rZVRleHQoeSxDLFIpfWIucmVzdG9yZSgpO2NvbnN0IEI9e2ltYWdlOmgscmVjdDpbMCwwLEksRF19O3JldHVybiBjJiYobFtnXT1CKSxCfWxldCB2PSExO2lmKHR5cGVvZiBuYXZpZ2F0b3I9PSJvYmplY3QiJiZ0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudD09InN0cmluZyIpe2NvbnN0IHk9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9jaHJvbWVcLyhcZCspLyk7eSYmKHY9TnVtYmVyKHlbMV0pPDcwKX1mdW5jdGlvbiBkKHksUCx4PXt9KXtjb25zdCBtPXgub2Zmc2NyZWVufHwhdiYmeC5vZmZzY3JlZW4hPT0hMTtsZXQgTztyZXR1cm4gdHlwZW9mIHI8InUiJiZ0eXBlb2Ygci5jcmVhdGVDYW52YXM9PSJmdW5jdGlvbiI/Tz1yLmNyZWF0ZUNhbnZhcyh5LFAseCk6bSYmdHlwZW9mIE9mZnNjcmVlbkNhbnZhcz09ImZ1bmN0aW9uIj9PPW5ldyBPZmZzY3JlZW5DYW52YXMoeSxQKTooTz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxPLndpZHRoPXksTy5oZWlnaHQ9UCksT31jb25zdCBwPXtjcmVhdGVDYW52YXM6ZCxjcmVhdGVUZXh0OmYsbG9hZEltYWdlOm4uZGVmYXVsdC5sb2FkSW1hZ2V9O2UuZGVmYXVsdD1wfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24odSxlKXt2YXIgdDt0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3Q9dHx8bmV3IEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCl9Y2F0Y2h7dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJih0PXdpbmRvdyl9dS5leHBvcnRzPXR9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihtLE8pe2lmKHR5cGVvZiBtPT0ic3RyaW5nIil7Y29uc3QgYz1tLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbnwlKSQvKTtjP209e3NpemU6cGFyc2VGbG9hdChjWzFdKSx1bml0OmNbMl19Om09e3NpemU6cGFyc2VJbnQobSwxMCksdW5pdDoicHgifX1sZXR7c2l6ZTpvLHVuaXQ6aH09bTtpZihoPT09InB0IilvLz0uNzU7ZWxzZSBpZihoPT09InBjIilvKj0xNjtlbHNlIGlmKGg9PT0iaW4iKW8qPTk2O2Vsc2UgaWYoaD09PSJjbSIpbyo9OTYvMi41NDtlbHNlIGlmKGg9PT0ibW0iKW8qPTk2LzI1LjQ7ZWxzZSBpZihoPT09ImVtInx8aD09PSJyZW0ifHxoPT09ImV4Iil7aWYoIU8mJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBjPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTtPPXIoYywxNil9byo9TyxoPT09ImV4IiYmKG8vPTIpfWVsc2UgaWYoaD09PSJxIilvKj05Ni8yNS40LzQ7ZWxzZSBpZihoPT09InZ3Inx8aD09PSJ2aCIpe2lmKHR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IGM9aD09PSJ2dyI/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7byo9Yy8xMDB9fWVsc2UgaWYoKGg9PT0idm1heCJ8fGg9PT0idm1pbiIpJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBjPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxnPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7aD09PSJ2bWF4Ij9vKj1NYXRoLm1heChjLGcpLzEwMDpvKj1NYXRoLm1pbihjLGcpLzEwMH1yZXR1cm4gb31jb25zdCBuPSJib2xkfGJvbGRlcnxsaWdodGVyfFsxLTldMDAiLGk9Iml0YWxpY3xvYmxpcXVlIixhPSJzbWFsbC1jYXBzIixsPSJ1bHRyYS1jb25kZW5zZWR8ZXh0cmEtY29uZGVuc2VkfGNvbmRlbnNlZHxzZW1pLWNvbmRlbnNlZHxzZW1pLWV4cGFuZGVkfGV4cGFuZGVkfGV4dHJhLWV4cGFuZGVkfHVsdHJhLWV4cGFuZGVkIixzPSJweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSIsZj1gJyhbXiddKyknfCIoW14iXSspInwoW1xcdy1dfFvkuIAt6b6lXSkrYCx2PW5ldyBSZWdFeHAoYCgke259KSArYCwiaSIpLGQ9bmV3IFJlZ0V4cChgKCR7aX0pICtgLCJpIikscD1uZXcgUmVnRXhwKGAoJHthfSkgK2AsImkiKSx5PW5ldyBSZWdFeHAoYCgke2x9KSArYCwiaSIpLFA9bmV3IFJlZ0V4cCgiKFtcXGRcXC5dKykoIitzKyIpKD86XFwvKFtcXGRcXC5dKykoIitzKyIpKT8gKigoPzoiK2YrIikoICosICooPzoiK2YrIikpKikiKTtmdW5jdGlvbiB4KG0sTyl7Y29uc3Qgbz1QLmV4ZWMobSk7aWYoIW8pcmV0dXJuO2NvbnN0IGg9cGFyc2VGbG9hdChvWzNdKSxjPXt3ZWlnaHQ6Im5vcm1hbCIsc3R5bGU6Im5vcm1hbCIsc3RyZXRjaDoibm9ybWFsIix2YXJpYW50OiJub3JtYWwiLHNpemU6cGFyc2VGbG9hdChvWzFdKSx1bml0Om9bMl0sbGluZUhlaWdodDpOdW1iZXIuaXNGaW5pdGUoaCk/aDp2b2lkIDAsbGluZUhlaWdodFVuaXQ6b1s0XSxmYW1pbHk6b1s1XS5yZXBsYWNlKC8gKiwgKi9nLCIsIil9LGc9bS5zdWJzdHJpbmcoMCxvLmluZGV4KSxiPXYuZXhlYyhnKSxFPWQuZXhlYyhnKSxBPXAuZXhlYyhnKSxMPXkuZXhlYyhnKTtyZXR1cm4gYiYmKGMud2VpZ2h0PWJbMV0pLEUmJihjLnN0eWxlPUVbMV0pLEEmJihjLnZhcmlhbnQ9QVsxXSksTCYmKGMuc3RyZXRjaD1MWzFdKSxjLnB4SGVpZ2h0PXIoe3NpemU6Yy5zaXplLHVuaXQ6Yy51bml0fSxPKSxjLnB4TGluZUhlaWdodD1yKHtzaXplOmMubGluZUhlaWdodHx8Yy5zaXplLHVuaXQ6Yy5saW5lSGVpZ2h0VW5pdHx8Yy51bml0fSxPKSxjfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG4pe3JldHVybmByZ2JhKCR7bi5tYXAoKGksYSk9PmE8Mz9NYXRoLnJvdW5kKGkqMjU1KTppKS5qb2luKCl9KWB9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJhcHBseUZpbHRlciIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJkcmF3TWVzaDJEIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgxKSxuPXQoMjQpLGk9dCgyMyksYT10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbCh2LGQpe2NvbnN0IHA9di5jYW52YXM7di5zYXZlKCksdi5maWx0ZXI9ZCx2LmRyYXdJbWFnZShwLDAsMCxwLndpZHRoLHAuaGVpZ2h0KSx2LnJlc3RvcmUoKX1mdW5jdGlvbiBzKHYsZCl7Y29uc3QgcD0vcmdiYVwoKFxkKyksKFxkKyksKFxkKyksKFxkKylcKS87dj12Lm1hdGNoKHApLnNsaWNlKDEsNSkubWFwKE51bWJlciksZD1kLm1hdGNoKHApLnNsaWNlKDEsNSkubWFwKE51bWJlcik7Y29uc3QgeT1bXSxQPWRbM107Zm9yKGxldCB4PTA7eDw0O3grKyl5W3hdPU9iamVjdChhLm1peCkodlt4XSxkW3hdLFApO3JldHVybmByZ2JhKCR7eS5qb2luKCl9KWB9ZnVuY3Rpb24gZih2LGQscD0hMCx5PW51bGwsUD1udWxsLHg9bnVsbCxtPW51bGwpe2Quc2F2ZSgpO2xldCBPPSExLG89ITE7aWYoZC5nbG9iYWxBbHBoYT12LmdldE9wYWNpdHkoKSx2Ll91cGRhdGVNYXRyaXgmJnYudHJhbnNmb3JtU2NhbGUvdi5jb250b3Vycy5zY2FsZT4xLjUmJnYuYWNjdXJhdGUodi50cmFuc2Zvcm1TY2FsZSksdi5saW5lV2lkdGgpe2xldCBnPXYuZ3JhZGllbnQmJnYuZ3JhZGllbnQuc3Ryb2tlO2lmKGcpe2NvbnN0e3ZlY3RvcjpiLGNvbG9yczpFfT1nO2lmKGIubGVuZ3RoPT09NilnPWQuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4uYik7ZWxzZSBpZihiLmxlbmd0aD09PTQpZz1kLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLmIpO2Vsc2UgaWYoYi5sZW5ndGg9PT0zKWc9ZC5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLmIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO0UuZm9yRWFjaCgoe29mZnNldDpBLGNvbG9yOkx9KT0+e2xldCBNPU9iamVjdChuLmRlZmF1bHQpKEwpO1AmJihNPXMoTSxQKSksZy5hZGRDb2xvclN0b3AoQSxNKX0pLGQuc3Ryb2tlU3R5bGU9ZyxPPSEwfWVsc2Ugdi5zdHJva2VTdHlsZSYmKFA/ZC5zdHJva2VTdHlsZT1zKHYuc3Ryb2tlU3R5bGUsUCk6ZC5zdHJva2VTdHlsZT12LnN0cm9rZVN0eWxlLE89ITApfU8mJihkLmxpbmVXaWR0aD12LmxpbmVXaWR0aCxkLmxpbmVKb2luPXYubGluZUpvaW4sZC5saW5lQ2FwPXYubGluZUNhcCxkLm1pdGVyTGltaXQ9di5taXRlckxpbWl0LHYubGluZURhc2gmJihkLnNldExpbmVEYXNoKHYubGluZURhc2gpLHYubGluZURhc2hPZmZzZXQmJihkLmxpbmVEYXNoT2Zmc2V0PXYubGluZURhc2hPZmZzZXQpKSk7bGV0IGg9di5ncmFkaWVudCYmdi5ncmFkaWVudC5maWxsO2lmKGgpe2NvbnN0e3ZlY3RvcjpnLGNvbG9yczpifT1oO2lmKGcubGVuZ3RoPT09NiloPWQuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4uZyk7ZWxzZSBpZihnLmxlbmd0aD09PTQpaD1kLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLmcpO2Vsc2UgaWYoZy5sZW5ndGg9PT0zKWg9ZC5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLmcpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO2IuZm9yRWFjaCgoe29mZnNldDpFLGNvbG9yOkF9KT0+e2xldCBMPU9iamVjdChuLmRlZmF1bHQpKEEpO1AmJihMPXMoTCxQKSksaC5hZGRDb2xvclN0b3AoRSxMKX0pLGQuZmlsbFN0eWxlPWgsbz0hMH1lbHNlIHYuZmlsbFN0eWxlJiYoeT9kLmZpbGxTdHlsZT1zKHYuZmlsbFN0eWxlLHkpOmQuZmlsbFN0eWxlPXYuZmlsbFN0eWxlLG89ITApO2lmKG0mJmQudHJhbnNmb3JtKC4uLm0pLGQudHJhbnNmb3JtKC4uLnYudHJhbnNmb3JtTWF0cml4KSx2LmNsaXBQYXRoKXtjb25zdCBnPXYuY2xpcFBhdGgsYj1uZXcgUGF0aDJEKGcpO2QuY2xpcChiKX1jb25zdCBjPXYuY29udG91cnMubGVuZ3RoO2lmKHYuY29udG91cnMuZm9yRWFjaCgoZyxiKT0+e2NvbnN0IEU9Zy5sZW5ndGgsQT1FPjEmJnIudmVjMi5lcXVhbHMoZ1swXSxnW0UtMV0pLEw9Yj09PWMtMSYmdi50ZXh0dXJlO2lmKGcmJkU+MCl7aWYob3x8T3x8TCl7ZC5iZWdpblBhdGgoKSxkLm1vdmVUbyguLi5nWzBdKTtmb3IobGV0IE09MTtNPEU7TSsrKU09PT1FLTEmJkE/ZC5jbG9zZVBhdGgoKTpkLmxpbmVUbyguLi5nW01dKX1pZihvJiZkLmZpbGwodi5maWxsUnVsZSksTCl7ZC5zYXZlKCksZC5jbGlwKCk7bGV0e2ltYWdlOk0sb3B0aW9uczpJfT12LnRleHR1cmU7aWYoeCYmKE09eCksSS5yZXBlYXQmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIGltYWdlIHJlcGVhdCB5ZXQuIiksTS5mb250KXtJLnNjYWxlJiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNjYWxlIHlldC4iKSxJLnNyY1JlY3QmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIHRleHQgc3JjUmVjdCB5ZXQuIik7bGV0e2ZvbnQ6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpDLHN0cm9rZVdpZHRoOkIsdGV4dDp6fT1NOyFSJiYhQyYmKFI9IiMwMDAiKSxBcnJheS5pc0FycmF5KFIpJiYoUj1PYmplY3Qobi5kZWZhdWx0KShSKSksQXJyYXkuaXNBcnJheShDKSYmKEM9T2JqZWN0KG4uZGVmYXVsdCkoQykpLGQuZm9udD1EO2NvbnN0e3dpZHRoOkt9PWQubWVhc3VyZVRleHQoeiksUT1PYmplY3QoaS5kZWZhdWx0KShEKSxfPU1hdGgubWF4KFEucHhMaW5lSGVpZ2h0LFEucHhIZWlnaHQqMS4xMyk7ZC50ZXh0QWxpZ249ImNlbnRlciIsZC50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgRj1JLnJlY3QsRz1GWzBdK18qLjUrUS5weEhlaWdodCouMDYsWD1GWzFdK0sqLjU7RlsyXSE9bnVsbCYmZC5zY2FsZShGWzJdL0ssRlszXS9fKSxSJiYoZC5maWxsU3R5bGU9UixkLmZpbGxUZXh0KHosWCxHKSksQyYmKGQubGluZVdpZHRoPUIsZC5zdHJva2VTdHlsZT1DLGQuc3Ryb2tlVGV4dCh6LFgsRykpfWVsc2V7bGV0IEQ9SS5yZWN0O2NvbnN0IFI9SS5zcmNSZWN0O0kuc2NhbGUmJihEPVswLDAsZC5jYW52YXMud2lkdGgsZC5jYW52YXMuaGVpZ2h0XSksSS5yb3RhdGVkJiZEJiYoRD1bLURbMV0sRFswXSxEWzNdLERbMl1dKSxSJiYoRD1EfHxbMCwwLFJbMl0sUlszXV0pLEkucm90YXRlZCYmKGQudHJhbnNsYXRlKDAsRD9EWzJdOk0ud2lkdGgpLGQucm90YXRlKC0uNSpNYXRoLlBJKSksUj9kLmRyYXdJbWFnZShNLC4uLlIsLi4uRCk6RD9kLmRyYXdJbWFnZShNLC4uLkQpOmQuZHJhd0ltYWdlKE0sMCwwKX1kLnJlc3RvcmUoKX1PJiZkLnN0cm9rZSgpfX0pLGQucmVzdG9yZSgpLHApe2NvbnN0IGc9di5maWx0ZXI7ZyYmbChkLGcpfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNsYW1wIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsIm1peCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJ0cmFuc2Zvcm1Qb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGEsbCxzKXtyZXR1cm4gbD5zJiYoW2wsc109W3MsbF0pLGE8bD9sOmE+cz9zOmF9ZnVuY3Rpb24gbihhLGwscyl7cmV0dXJuIGEqKDEtcykrbCpzfWZ1bmN0aW9uIGkoYSxsKXtjb25zdFtzLGZdPWE7cmV0dXJuW3MqbFswXStmKmxbMl0rbFs0XSxzKmxbMV0rZipsWzNdK2xbNV1dfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciByPXQoMjgpLG49dCgyOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoZix2LGQpe2NvbnN0IHA9Zi51bmlmb3Jtc3x8e30seT12LnVuaWZvcm1zfHx7fTtpZihwLnVfdGV4U2FtcGxlciYmeS51X3RleFNhbXBsZXImJnAudV90ZXhTYW1wbGVyIT09eS51X3RleFNhbXBsZXIpcmV0dXJuITE7Y29uc3QgUD1PYmplY3Qua2V5cyhwKSx4PU9iamVjdC5rZXlzKHkpLG09UC5pbmRleE9mKCJ1X3RleFNhbXBsZXIiKSxPPXguaW5kZXhPZigidV90ZXhTYW1wbGVyIik7aWYobT49MCYmUC5zcGxpY2UobSwxKSxPPj0wJiZ4LnNwbGljZShPLDEpLFAubGVuZ3RoIT09eC5sZW5ndGgpcmV0dXJuITE7Y29uc3Qgbz1QLmV2ZXJ5KGg9Pntjb25zdCBjPXBbaF0sZz15W2hdO2lmKGM9PT1nKXJldHVybiEwO2lmKGMubGVuZ3RoJiZnLmxlbmd0aCYmYy5sZW5ndGg9PT1nLmxlbmd0aCl7Zm9yKGxldCBiPTA7YjxjLmxlbmd0aDtiKyspaWYoY1tiXSE9PWdbYl0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9KTtpZihvKXtpZihwLnVfdGV4U2FtcGxlciYmIXkudV90ZXhTYW1wbGVyKXYuc2V0VGV4dHVyZShwLnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSk7ZWxzZSBpZighcC51X3RleFNhbXBsZXImJnkudV90ZXhTYW1wbGVyKWZvcihsZXQgaD0wO2g8ZC5sZW5ndGg7aCsrKWRbaF0uc2V0VGV4dHVyZSh5LnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSl9cmV0dXJuIG99Y29uc3QgYT17fTtmdW5jdGlvbiBsKGYsdil7aWYoZi5sZW5ndGgpe2NvbnN0IGQ9T2JqZWN0KHIuZGVmYXVsdCkoZixhKTtyZXR1cm4gZC5lbmFibGVCbGVuZD12LGZbMF0uZmlsdGVyQ2FudmFzJiYoZC5maWx0ZXJDYW52YXM9ITApLGQucGFja0luZGV4PWZbMF0ucGFja0luZGV4LGQucGFja0xlbmd0aD1mLmxlbmd0aCxkLmJlZm9yZVJlbmRlcj1mWzBdLmJlZm9yZVJlbmRlcixkLnBhc3M9ZlswXS5wYXNzLGQuYWZ0ZXJSZW5kZXI9ZltmLmxlbmd0aC0xXS5hZnRlclJlbmRlcixmLmxlbmd0aD0wLGR9fWZ1bmN0aW9uKnMoZix2LGQ9ITEpe2NvbnN0IHA9W10seT1mLm9wdGlvbnMuYnVmZmVyU2l6ZTtsZXQgUD0wLHg9ITE7Zm9yKGxldCBtPTA7bTx2Lmxlbmd0aDttKyspe2NvbnN0IE89dlttXTtpZihPIGluc3RhbmNlb2Ygbi5kZWZhdWx0KXAubGVuZ3RoJiYoeWllbGQgbChwLHgpKSxQPTAseD0hMSx5aWVsZCBPO2Vsc2V7Y29uc3Qgbz1PLm1lc2hEYXRhO2lmKG8uY2xpcFBhdGgmJiFvLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXIpe2NvbnN0IGM9Zi5jcmVhdGVUZXh0dXJlKG8uY2xpcFBhdGgpO28udW5pZm9ybXMudV9jbGlwU2FtcGxlcj1jfWxldCBoPTA7aWYoKCFkfHwhTy5jYW5JZ25vcmUoKSkmJm8mJm8ucG9zaXRpb25zLmxlbmd0aCl7Ty5wYWNrSW5kZXg9bTtjb25zdCBjPU8uZmlsdGVyQ2FudmFzO2lmKGg9by5wb3NpdGlvbnMubGVuZ3RoLGN8fFAraD55KXAubGVuZ3RoJiYoeWllbGQgbChwLHgpKSxQPTAseD0hMTtlbHNlIGlmKFApe2NvbnN0IGc9cFtwLmxlbmd0aC0xXTtnJiYoZy5maWx0ZXJDYW52YXN8fGcuYWZ0ZXJSZW5kZXJ8fE8uYmVmb3JlUmVuZGVyfHxnLnBhc3MubGVuZ3RofHxPLnBhc3MubGVuZ3RofHxnLnByb2dyYW0hPT1PLnByb2dyYW18fCFpKGcsTyxwKSkmJih5aWVsZCBsKHAseCksUD0wLHg9ITEpfXAucHVzaChPKSx4PXh8fE8uZW5hYmxlQmxlbmQsUCs9aH1tPT09di5sZW5ndGgtMSYmcC5sZW5ndGgmJih5aWVsZCBsKHAseCkpfX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBpfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9e1VOU0lHTkVEX0JZVEU6VWludDhBcnJheSxVTlNJR05FRF9TSE9SVDpVaW50MTZBcnJheSxCWVRFOkludDhBcnJheSxTSE9SVDpJbnQxNkFycmF5LEZMT0FUOkZsb2F0MzJBcnJheX07ZnVuY3Rpb24gbihhLGwpe2xldCBzPTAsZj0wLHY9MCxkPTAscD0wLHk9MCxQPTA7Y29uc3QgeD1hWzBdLnByb2dyYW07Zm9yKGxldCBtPTA7bTxhLmxlbmd0aDttKyspe2NvbnN0IE89YVttXS5tZXNoRGF0YTtpZihPKXtQKz1PLnBvc2l0aW9ucy5sZW5ndGg7Y29uc3Qgbz1PLnBvc2l0aW9uc1swXS5sZW5ndGg7cys9Ty5wb3NpdGlvbnMubGVuZ3RoKm8sZis9Ty5jZWxscy5sZW5ndGgqMyx5Kz1PLmF0dHJpYnV0ZXMuYV9jb2xvci5sZW5ndGgqNDtjb25zdCBoPU8udGV4dHVyZUNvb3JkO2gmJih2Kz1oLmxlbmd0aCpoWzBdLmxlbmd0aCk7Y29uc3QgYz1PLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2MmJihkKz1jLmxlbmd0aCo0KTtjb25zdCBnPU8uYXR0cmlidXRlcy5hX2NsaXBVVjtnJiYocCs9Zy5sZW5ndGgqMil9fWlmKCghbC5wb3NpdGlvbnN8fGwucG9zaXRpb25zLmxlbmd0aDxzKSYmKGwucG9zaXRpb25zPW5ldyBGbG9hdDMyQXJyYXkocykpLCghbC5jZWxsc3x8bC5jZWxscy5sZW5ndGg8ZikmJihsLmNlbGxzPW5ldyBVaW50MTZBcnJheShmKSksdiYmKCFsLnRleHR1cmVDb29yZHx8bC50ZXh0dXJlQ29vcmQubGVuZ3RoPHYpJiYobC50ZXh0dXJlQ29vcmQ9bmV3IEZsb2F0MzJBcnJheSh2KSksKCFsLmFfY29sb3J8fGwuYV9jb2xvci5sZW5ndGg8eSkmJihsLmFfY29sb3I9bmV3IFVpbnQ4QXJyYXkoeSkpLGQmJighbC5hX3NvdXJjZVJlY3R8fGwuYV9zb3VyY2VSZWN0Lmxlbmd0aDxkKSYmKGwuYV9zb3VyY2VSZWN0PW5ldyBGbG9hdDMyQXJyYXkoZCkpLHAmJighbC5hX2NsaXBVVnx8bC5hX2NsaXBVVi5sZW5ndGg8cCkmJihsLmFfY2xpcFVWPW5ldyBGbG9hdDMyQXJyYXkocCkpLHgpe2NvbnN0IG09T2JqZWN0LmVudHJpZXMoeC5fYXR0cmlidXRlKSxPPXguX2F0dHJpYk9wdHN8fHt9O2ZvcihsZXQgbz0wO288bS5sZW5ndGg7bysrKXtjb25zdFtoLGNdPW1bb107aWYoaCE9PSJhX2NvbG9yIiYmaCE9PSJhX3NvdXJjZVJlY3QiJiZjIT09Imlnbm9yZWQiKXtjb25zdCBnPU9baF0/T1toXS50eXBlOiJGTE9BVCIsYj1yW2ddLEU9Yy5zaXplKlA7KCFsW2hdfHxsW2hdLmxlbmd0aDxFKSYmKGxbaF09bmV3IGIoRSkpfX19cmV0dXJuIGx9ZnVuY3Rpb24gaShhLGwpe2xldCBzPVtdLGY9W10sdj1bXSxkPVtdLHA9W10seT1bXSxQPTAseD0wO2NvbnN0IG09YVswXT9hWzBdLnVuaWZvcm1zfHx7fTp7fSxPPWFbMF0/YVswXS5wcm9ncmFtOm51bGw7bCYmKG4oYSxsKSxmPWwuY2VsbHMscz1sLnBvc2l0aW9ucyx2PWwudGV4dHVyZUNvb3JkLGQ9bC5hX2NvbG9yLHA9bC5hX3NvdXJjZVJlY3QseT1sLmFfY2xpcFVWKTtsZXQgbz0hMSxoPSExO2NvbnN0IGM9e307Zm9yKGxldCBiPTA7YjxhLmxlbmd0aDtiKyspe2xldCBFPWFbYl07aWYoRSl7aWYoRS5tZXNoRGF0YSYmKEU9RS5tZXNoRGF0YSksbCl7Y29uc3QgTD1FLnBvc2l0aW9ucztmb3IobGV0IE09MDtNPEwubGVuZ3RoO00rKyl7Y29uc3QgST1MW01dLEQ9MyooUCtNKTtmb3IobGV0IFI9MDtSPEkubGVuZ3RoO1IrKylzW0QrUl09SVtSXX19ZWxzZSBzLnB1c2goLi4uRS5wb3NpdGlvbnMpO2NvbnN0IEE9RS5jZWxscztmb3IobGV0IEw9MDtMPEEubGVuZ3RoO0wrKyl7Y29uc3QgTT1BW0xdO2lmKGwpe2NvbnN0IEk9MyooeCtMKTtmW0ldPU1bMF0rUCxmW0krMV09TVsxXStQLGZbSSsyXT1NWzJdK1B9ZWxzZSBmLnB1c2goW01bMF0rUCxNWzFdK1AsTVsyXStQXSl9aWYobCl7Y29uc3QgTD1FLmF0dHJpYnV0ZXMuYV9jb2xvcjtmb3IobGV0IE09MDtNPEwubGVuZ3RoO00rKyl7Y29uc3QgST1MW01dLEQ9NCooUCtNKTtkW0RdPUlbMF0sZFtEKzFdPUlbMV0sZFtEKzJdPUlbMl0sZFtEKzNdPUlbM119fWVsc2UgZC5wdXNoKC4uLkUuYXR0cmlidXRlcy5hX2NvbG9yKTtpZihFLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0KWlmKG89ITAsbCl7Y29uc3QgTD1FLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2ZvcihsZXQgTT0wO008TC5sZW5ndGg7TSsrKXtjb25zdCBJPUxbTV0sRD00KihQK00pO3BbRF09SVswXSxwW0QrMV09SVsxXSxwW0QrMl09SVsyXSxwW0QrM109SVszXX19ZWxzZSBwLnB1c2goLi4uRS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdCk7aWYoRS5hdHRyaWJ1dGVzLmFfY2xpcFVWKWlmKGg9ITAsbCl7Y29uc3QgTD1FLmF0dHJpYnV0ZXMuYV9jbGlwVVY7Zm9yKGxldCBNPTA7TTxMLmxlbmd0aDtNKyspe2NvbnN0IEk9TFtNXSxEPTIqKFArTSk7eVtEXT1JWzBdLHlbRCsxXT1JWzFdfX1lbHNlIHkucHVzaCguLi5FLmF0dHJpYnV0ZXMuYV9jbGlwVVYpO2lmKEUudGV4dHVyZUNvb3JkKWlmKGwpe2NvbnN0IEw9RS50ZXh0dXJlQ29vcmQ7Zm9yKGxldCBNPTA7TTxMLmxlbmd0aDtNKyspe2NvbnN0IEk9TFtNXSxEPTMqKFArTSk7Zm9yKGxldCBSPTA7UjxJLmxlbmd0aDtSKyspdltEK1JdPUlbUl19fWVsc2Ugdi5wdXNoKC4uLkUudGV4dHVyZUNvb3JkKTtpZihPKXtjb25zdCBMPU9iamVjdC5lbnRyaWVzKE8uX2F0dHJpYnV0ZSk7Zm9yKGxldCBNPTA7TTxMLmxlbmd0aDtNKyspe2NvbnN0W0ksRF09TFtNXTtpZihJIT09ImFfY29sb3IiJiZJIT09ImFfc291cmNlUmVjdCImJkQhPT0iaWdub3JlZCIpaWYoY1tJXT1bXSxsKXtjW0ldPWxbSV07Y29uc3QgUj1FLmF0dHJpYnV0ZXNbSV0sQz1SWzBdLmxlbmd0aDtmb3IobGV0IEI9MDtCPFIubGVuZ3RoO0IrKyl7Y29uc3Qgej1SW0JdLEs9QyooUCtCKTtmb3IobGV0IFE9MDtRPHoubGVuZ3RoO1ErKyljW0ldW0srUV09eltRXX19ZWxzZSBjW0ldLnB1c2goLi4uRS5hdHRyaWJ1dGVzW0ldKX19UCs9RS5wb3NpdGlvbnMubGVuZ3RoLHgrPUUuY2VsbHMubGVuZ3RofX1jLmFfY29sb3I9ZCxvJiZwJiZwLmxlbmd0aD4wJiYoYy5hX3NvdXJjZVJlY3Q9cCk7Y29uc3QgZz17cG9zaXRpb25zOnMsY2VsbHM6ZixhdHRyaWJ1dGVzOmMsdW5pZm9ybXM6bSxjZWxsc0NvdW50OngqMyxwcm9ncmFtOk99O3JldHVybiB2JiZ2Lmxlbmd0aCYmKGcudGV4dHVyZUNvb3JkPXYpLGgmJnkubGVuZ3RoPjAmJihjLmFfY2xpcFVWPXkpLGd9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpO3ZhciByPXQoMSksbj10KDMwKSxpPXQoMjYpLGE9dCgzMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwoYyxnKXt2YXIgYj1PYmplY3Qua2V5cyhjKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGMpO2cmJihFPUUuZmlsdGVyKGZ1bmN0aW9uKEEpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGMsQSkuZW51bWVyYWJsZX0pKSxiLnB1c2guYXBwbHkoYixFKX1yZXR1cm4gYn1mdW5jdGlvbiBzKGMpe2Zvcih2YXIgZz0xO2c8YXJndW1lbnRzLmxlbmd0aDtnKyspe3ZhciBiPWFyZ3VtZW50c1tnXSE9bnVsbD9hcmd1bWVudHNbZ106e307ZyUyP2woT2JqZWN0KGIpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEUpe2YoYyxFLGJbRV0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiKSk6bChPYmplY3QoYikpLmZvckVhY2goZnVuY3Rpb24oRSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGMsRSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsRSkpfSl9cmV0dXJuIGN9ZnVuY3Rpb24gZihjLGcsYil7cmV0dXJuIGcgaW4gYz9PYmplY3QuZGVmaW5lUHJvcGVydHkoYyxnLHt2YWx1ZTpiLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Y1tnXT1iLGN9Y29uc3Qgdj1TeW1ib2woIm1lc2giKSxkPVN5bWJvbCgiY291bnQiKSxwPVN5bWJvbCgiYmxlbmQiKSx5PVN5bWJvbCgiZmlsdGVyIiksUD1TeW1ib2woInRleHR1cmVzIikseD1TeW1ib2woInRleHR1cmVPcHRpb25zIiksbT1TeW1ib2woImNsb3VkQ29sb3IiKSxPPVN5bWJvbCgiY2xvdWRGaWx0ZXIiKSxvPVN5bWJvbCgiYnVmZmVyIik7ZnVuY3Rpb24gaChjLGc9bnVsbCl7Y29uc3QgYj1uZXcgRmxvYXQzMkFycmF5KDMqYyksRT1uZXcgRmxvYXQzMkFycmF5KDMqYyksQT1uZXcgRmxvYXQzMkFycmF5KDQqYyksTD1uZXcgRmxvYXQzMkFycmF5KDQqYyksTT1uZXcgRmxvYXQzMkFycmF5KDQqYyksST1uZXcgRmxvYXQzMkFycmF5KDQqYyksRD1uZXcgRmxvYXQzMkFycmF5KDQqYyksUj1uZXcgVWludDhBcnJheShjKSxDPW5ldyBVaW50OEFycmF5KDQqYyksQj1uZXcgVWludDhBcnJheSg0KmMpO3JldHVybiBnJiYoYi5zZXQoZy50cmFuc2Zvcm0wLDApLEUuc2V0KGcudHJhbnNmb3JtMSwwKSxBLnNldChnLmNvbG9yMCwwKSxMLnNldChnLmNvbG9yMSwwKSxNLnNldChnLmNvbG9yMiwwKSxJLnNldChnLmNvbG9yMywwKSxELnNldChnLmNvbG9yNCwwKSxSLnNldChnLmZyYW1lSW5kZXgsMCksQy5zZXQoZy5maWxsQ29sb3IsMCksQi5zZXQoZy5zdHJva2VDb2xvciwwKSkse2J1ZmZlclNpemU6Yyx0cmFuc2Zvcm0wOmIsdHJhbnNmb3JtMTpFLGNvbG9yMDpBLGNvbG9yMTpMLGNvbG9yMjpNLGNvbG9yMzpJLGNvbG9yNDpELGZyYW1lSW5kZXg6UixmaWxsQ29sb3I6QyxzdHJva2VDb2xvcjpCfX1lLmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoYyxnPTEse2J1ZmZlcjpiPTFlM309e30pe2I9TWF0aC5tYXgoYixnKSx0aGlzW2RdPWcsdGhpc1t2XT1jLHRoaXNbb109aChiKSx0aGlzW1BdPVtdLHRoaXNbeV09W10sdGhpc1ttXT0hMSx0aGlzW09dPSExLHRoaXNbcF09ITEsdGhpcy5pbml0QnVmZmVyKCl9aW5pdEJ1ZmZlcihjPTApe2NvbnN0IGc9dGhpc1tkXTtmb3IobGV0IGI9YztiPGc7YisrKXRoaXNbb10udHJhbnNmb3JtMC5zZXQoWzEsMCwwXSxiKjMpLHRoaXNbb10udHJhbnNmb3JtMS5zZXQoWzAsMSwwXSxiKjMpLHRoaXNbb10uZnJhbWVJbmRleC5zZXQoWy0xXSxiKSx0aGlzW29dLmZpbGxDb2xvci5zZXQoWzAsMCwwLDBdLGIqNCksdGhpc1tvXS5zdHJva2VDb2xvci5zZXQoWzAsMCwwLDBdLGIqNCksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShiLG51bGwpfWdldCBidWZmZXJTaXplKCl7cmV0dXJuIHRoaXNbb10uYnVmZmVyU2l6ZX1nZXQgbWVzaCgpe3JldHVybiB0aGlzW3ZdfXNldCBtZXNoKGMpe3RoaXNbdl09Yyx0aGlzW1BdJiZ0aGlzLnNldFRleHR1cmVGcmFtZXModGhpc1tQXSx0aGlzW3hdKX1nZXQgaGFzQ2xvdWRDb2xvcigpe3JldHVybiB0aGlzW21dfWdldCBoYXNDbG91ZEZpbHRlcigpe3JldHVybiB0aGlzW09dfV9nZXRGaWx0ZXIoYyl7cmV0dXJuIHRoaXNbeV1bY109dGhpc1t5XVtjXXx8W10sdGhpc1t5XVtjXX1nZXRGaWx0ZXIoYyl7cmV0dXJuIHRoaXMuX2dldEZpbHRlcihjKS5qb2luKCIgIil9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbdl0uZW5hYmxlQmxlbmR8fHRoaXNbcF19Y2FuSWdub3JlKCl7cmV0dXJuIHRoaXNbdl0uY2FuSWdub3JlKCl9ZGVsZXRlKGMpe2lmKGM+PXRoaXNbZF18fGM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdHt0cmFuc2Zvcm0wOmcsdHJhbnNmb3JtMTpiLGNvbG9yMDpFLGNvbG9yMTpBLGNvbG9yMjpMLGNvbG9yMzpNLGNvbG9yNDpJLGZyYW1lSW5kZXg6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpDfT10aGlzW29dO2cuc2V0KGcuc3ViYXJyYXkoMyooYysxKSksMypjKSxiLnNldChiLnN1YmFycmF5KDMqKGMrMSkpLDMqYyksRS5zZXQoRS5zdWJhcnJheSg0KihjKzEpKSw0KmMpLEEuc2V0KEEuc3ViYXJyYXkoNCooYysxKSksNCpjKSxMLnNldChMLnN1YmFycmF5KDQqKGMrMSkpLDQqYyksTS5zZXQoTS5zdWJhcnJheSg0KihjKzEpKSw0KmMpLEkuc2V0KEkuc3ViYXJyYXkoNCooYysxKSksNCpjKSxELnNldChELnN1YmFycmF5KGMrMSksYyksUi5zZXQoUi5zdWJhcnJheSg0KihjKzEpKSw0KmMpLEMuc2V0KEMuc3ViYXJyYXkoNCooYysxKSksNCpjKTtmb3IoY29uc3QgQiBpbiB0aGlzW3ldKUI9PT1jP2RlbGV0ZSB0aGlzW3ldW0JdOkI+YyYmKHRoaXNbeV1bQi0xXT10aGlzW3ldW0JdLGRlbGV0ZSB0aGlzW3ldW0JdKTt0aGlzW2RdLS19c2V0Q29sb3JUcmFuc2Zvcm0oYyxnKXtpZihjPj10aGlzW2RdfHxjPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Yyo9NDtjb25zdHtjb2xvcjA6Yixjb2xvcjE6RSxjb2xvcjI6QSxjb2xvcjM6TCxjb2xvcjQ6TX09dGhpc1tvXTtyZXR1cm4gZyE9bnVsbD8oYi5zZXQoW2dbMF0sZ1s1XSxnWzEwXSxnWzE1XV0sYyksRS5zZXQoW2dbMV0sZ1s2XSxnWzExXSxnWzE2XV0sYyksQS5zZXQoW2dbMl0sZ1s3XSxnWzEyXSxnWzE3XV0sYyksTC5zZXQoW2dbM10sZ1s4XSxnWzEzXSxnWzE4XV0sYyksTS5zZXQoW2dbNF0sZ1s5XSxnWzE0XSxnWzE5XV0sYyksdGhpc1twXT10aGlzW3BdfHxnWzE4XTwxLHRoaXNbT109ITApOihiLnNldChbMSwwLDAsMF0sYyksRS5zZXQoWzAsMSwwLDBdLGMpLEEuc2V0KFswLDAsMSwwXSxjKSxMLnNldChbMCwwLDAsMV0sYyksTS5zZXQoWzAsMCwwLDBdLGMpKSx0aGlzfWdldENvbG9yVHJhbnNmb3JtKGMpe2lmKGM+PXRoaXNbZF18fGM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjKj00O2NvbnN0e2NvbG9yMDpnLGNvbG9yMTpiLGNvbG9yMjpFLGNvbG9yMzpBLGNvbG9yNDpMfT10aGlzW29dO3JldHVybltnW2NdLGJbY10sRVtjXSxBW2NdLExbY10sZ1tjKzFdLGJbYysxXSxFW2MrMV0sQVtjKzFdLExbYysxXSxnW2MrMl0sYltjKzJdLEVbYysyXSxBW2MrMl0sTFtjKzJdLGdbYyszXSxiW2MrM10sRVtjKzNdLEFbYyszXSxMW2MrM11dfXRyYW5zZm9ybUNvbG9yKGMsZyl7bGV0IGI9dGhpcy5nZXRDb2xvclRyYW5zZm9ybShjKTtyZXR1cm4gYj1PYmplY3Qobi5tdWx0aXBseSkoYixnKSx0aGlzLnNldENvbG9yVHJhbnNmb3JtKGMsYiksdGhpc31zZXRGaWxsQ29sb3IoYyxnKXtpZihjPj10aGlzW2RdfHxjPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7dHlwZW9mIGc9PSJzdHJpbmciJiYoZz1PYmplY3QoYS5kZWZhdWx0KShnKSksZ1szXT4wJiYodGhpc1ttXT0hMCksdGhpc1tvXS5maWxsQ29sb3Iuc2V0KGcubWFwKGI9Pk1hdGgucm91bmQoMjU1KmIpKSw0KmMpfXNldFN0cm9rZUNvbG9yKGMsZyl7aWYoYz49dGhpc1tkXXx8YzwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBnPT0ic3RyaW5nIiYmKGc9T2JqZWN0KGEuZGVmYXVsdCkoZykpLGdbM10+MCYmKHRoaXNbbV09ITApLHRoaXNbb10uc3Ryb2tlQ29sb3Iuc2V0KGcubWFwKGI9Pk1hdGgucm91bmQoMjU1KmIpKSw0KmMpfWdldENsb3VkUkdCQShjKXtpZihjPj10aGlzW2RdfHxjPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Yyo9NDtjb25zdHtmaWxsQ29sb3I6ZyxzdHJva2VDb2xvcjpifT10aGlzW29dLEU9W2dbY10sZ1tjKzFdLGdbYysyXSxnW2MrM11dLEE9W2JbY10sYltjKzFdLGJbYysyXSxiW2MrM11dO3JldHVybiBFWzNdLz0yNTUsQVszXS89MjU1LHtmaWxsOmByZ2JhKCR7RS5qb2luKCl9KWAsc3Ryb2tlOmByZ2JhKCR7QS5qb2luKCl9KWB9fWdyYXlzY2FsZShjLGcpe3RoaXMudHJhbnNmb3JtQ29sb3IoYyxPYmplY3Qobi5ncmF5c2NhbGUpKGcpKSx0aGlzLl9nZXRGaWx0ZXIoYykucHVzaChgZ3JheXNjYWxlKCR7MTAwKmd9JSlgKX1icmlnaHRuZXNzKGMsZyl7dGhpcy50cmFuc2Zvcm1Db2xvcihjLE9iamVjdChuLmJyaWdodG5lc3MpKGcpKSx0aGlzLl9nZXRGaWx0ZXIoYykucHVzaChgYnJpZ2h0bmVzcygkezEwMCpnfSUpYCl9c2F0dXJhdGUoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4uc2F0dXJhdGUpKGcpKSx0aGlzLl9nZXRGaWx0ZXIoYykucHVzaChgc2F0dXJhdGUoJHsxMDAqZ30lKWApfWNvbnRyYXN0KGMsZyl7dGhpcy50cmFuc2Zvcm1Db2xvcihjLE9iamVjdChuLmNvbnRyYXN0KShnKSksdGhpcy5fZ2V0RmlsdGVyKGMpLnB1c2goYGNvbnRyYXN0KCR7MTAwKmd9JSlgKX1pbnZlcnQoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4uaW52ZXJ0KShnKSksdGhpcy5fZ2V0RmlsdGVyKGMpLnB1c2goYGludmVydCgkezEwMCpnfSUpYCl9c2VwaWEoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4uc2VwaWEpKGcpKSx0aGlzLl9nZXRGaWx0ZXIoYykucHVzaChgc2VwaWEoJHsxMDAqZ30lKWApfW9wYWNpdHkoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4ub3BhY2l0eSkoZykpLHRoaXMuX2dldEZpbHRlcihjKS5wdXNoKGBvcGFjaXR5KCR7MTAwKmd9JSlgKX1odWVSb3RhdGUoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4uaHVlUm90YXRlKShnKSksdGhpcy5fZ2V0RmlsdGVyKGMpLnB1c2goYGh1ZS1yb3RhdGUoJHtnfWRlZylgKX1zZXRUcmFuc2Zvcm0oYyxnKXtpZihjPj10aGlzW2RdfHxjPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Yyo9MyxnPT1udWxsJiYoZz1bMSwwLDAsMSwwLDBdKTtjb25zdHt0cmFuc2Zvcm0wOmIsdHJhbnNmb3JtMTpFfT10aGlzW29dO3JldHVybiBiLnNldChbZ1swXSxnWzJdLGdbNF1dLGMpLEUuc2V0KFtnWzFdLGdbM10sZ1s1XV0sYyksdGhpc31nZXRUcmFuc2Zvcm0oYyl7aWYoYz49dGhpc1tkXXx8YzwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2MqPTM7Y29uc3R7dHJhbnNmb3JtMDpnLHRyYW5zZm9ybTE6Yn09dGhpc1tvXTtyZXR1cm5bZ1tjXSxiW2NdLGdbYysxXSxiW2MrMV0sZ1tjKzJdLGJbYysyXV19Z2V0VGV4dHVyZUZyYW1lKGMpe3JldHVybiB0aGlzW1BdW3RoaXNbb10uZnJhbWVJbmRleFtjXV19c2V0VGV4dHVyZUZyYW1lcyhjPVtdLGc9e30pe2lmKGMubGVuZ3RoPjEyKXRocm93IG5ldyBFcnJvcigiTWF4IGZyYW1lcyBleGNlZWQuIEFsbG93IDEyIGZyYW1lcy4iKTtjLmxlbmd0aCYmdGhpc1t2XS5zZXRUZXh0dXJlKGNbMF0sZyksdGhpc1tQXT1jLHRoaXNbeF09Z31zZXRGcmFtZUluZGV4KGMsZyl7aWYoYz49dGhpc1tkXXx8YzwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2NvbnN0IGI9dGhpc1tQXS5sZW5ndGg7aWYoYjw9MCl0aHJvdyBuZXcgRXJyb3IoIk5vIGZyYW1lcyIpO3RoaXNbb10uZnJhbWVJbmRleFtjXT1nJWJ9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2RdfXNldCBhbW91bnQoYyl7Y29uc3QgZz10aGlzW2RdO2MhPT1nJiYoYz50aGlzW29dLmJ1ZmZlclNpemUmJih0aGlzW29dPWgoTWF0aC5tYXgoYyx0aGlzW29dLmJ1ZmZlclNpemUrMWUzKSx0aGlzW29dKSksdGhpc1tkXT1jLGM+ZyYmdGhpcy5pbml0QnVmZmVyKGcpKX1nZXQgbWVzaERhdGEoKXtjb25zdHthdHRyaWJ1dGVzOmMsY2VsbHM6Zyxwb3NpdGlvbnM6Yix0ZXh0dXJlQ29vcmQ6RSx1bmlmb3JtczpBfT10aGlzW3ZdLm1lc2hEYXRhLEw9dGhpc1tQXSxNPXthdHRyaWJ1dGVzOnMoe30sYyksY2VsbHM6Zyxwb3NpdGlvbnM6Yix0ZXh0dXJlQ29vcmQ6RSx1bmlmb3JtczpzKHt9LEEpLGluc3RhbmNlQ291bnQ6dGhpc1tkXSxlbmFibGVCbGVuZDp0aGlzLmVuYWJsZUJsZW5kfTtMLmxlbmd0aCYmTC5mb3JFYWNoKChHLFgpPT57TS51bmlmb3Jtc1tgdV90ZXhGcmFtZSR7WH1gXT1HfSk7Y29uc3R7dHJhbnNmb3JtMDpJLHRyYW5zZm9ybTE6RCxjb2xvcjA6Uixjb2xvcjE6Qyxjb2xvcjI6Qixjb2xvcjM6eixjb2xvcjQ6SyxmaWxsQ29sb3I6USxzdHJva2VDb2xvcjpfLGZyYW1lSW5kZXg6Rn09dGhpc1tvXTtyZXR1cm4gdGhpc1t2XS51bmlmb3Jtcy51X3RleFNhbXBsZXImJihNLmF0dHJpYnV0ZXMuYV9mcmFtZUluZGV4PXtkYXRhOkYsZGl2aXNvcjoxfSksTS5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMD17ZGF0YTpJLGRpdmlzb3I6MX0sTS5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMT17ZGF0YTpELGRpdmlzb3I6MX0sTS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDA9e2RhdGE6UixkaXZpc29yOjF9LE0uYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQxPXtkYXRhOkMsZGl2aXNvcjoxfSxNLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMj17ZGF0YTpCLGRpdmlzb3I6MX0sTS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDM9e2RhdGE6eixkaXZpc29yOjF9LE0uYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQ0PXtkYXRhOkssZGl2aXNvcjoxfSx0aGlzLmhhc0Nsb3VkQ29sb3ImJihNLmF0dHJpYnV0ZXMuYV9maWxsQ2xvdWRDb2xvcj17ZGF0YTpRLGRpdmlzb3I6MX0sTS5hdHRyaWJ1dGVzLmFfc3Ryb2tlQ2xvdWRDb2xvcj17ZGF0YTpfLGRpdmlzb3I6MX0pLE19c2V0UHJvZ3JhbShjKXt0aGlzW3ZdLnNldFByb2dyYW0oYyl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1t2XS5wcm9ncmFtfXRyYW5zZm9ybShjLGcpe2NvbnN0IGI9dGhpcy5nZXRUcmFuc2Zvcm0oYyk7cmV0dXJuIGc9ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksYixnKSx0aGlzLnNldFRyYW5zZm9ybShjLGcpLHRoaXN9dHJhbnNsYXRlKGMsW2csYl0pe2xldCBFPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEU9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEUsW2csYl0pLHRoaXMudHJhbnNmb3JtKGMsRSl9cm90YXRlKGMsZyxbYixFXT1bMCwwXSl7bGV0IEE9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gQT1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQSxbYixFXSksQT1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQSxnKSxBPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxBLFstYiwtRV0pLHRoaXMudHJhbnNmb3JtKGMsQSl9c2NhbGUoYyxbZyxiPWddLFtFLEFdPVswLDBdKXtsZXQgTD1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBMPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFtFLEFdKSxMPXIubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEwsW2csYl0pLEw9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEwsWy1FLC1BXSksdGhpcy50cmFuc2Zvcm0oYyxMKX1za2V3KGMsW2csYj1nXSxbRSxBXT1bMCwwXSl7bGV0IEw9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxbRSxBXSksTD1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKGIpLE1hdGgudGFuKGcpLDEsMCwwKSksTD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxbLUUsLUFdKSx0aGlzLnRyYW5zZm9ybShjLEwpfWlzUG9pbnRDb2xsaXNpb24oYyxbZyxiXSxFPSJib3RoIil7Y29uc3QgQT10aGlzLmdldFRyYW5zZm9ybShjKSxMPU9iamVjdChpLnRyYW5zZm9ybVBvaW50KShbZyxiXSxyLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksQSkpO3JldHVybiB0aGlzW3ZdLmlzUG9pbnRDb2xsaXNpb24oLi4uTCxFKX1pc1BvaW50SW5GaWxsKGMsW2csYl0pe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oYyxbZyxiXSwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShjLFtnLGJdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGMsW2csYl0sInN0cm9rZSIpfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImdyYXlzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJicmlnaHRuZXNzIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNhdHVyYXRlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNvbnRyYXN0IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzZXBpYSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJvcGFjaXR5IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImh1ZVJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pO3ZhciByPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHksUCl7Y29uc3QgeD1bXSxtPXlbMF0sTz15WzFdLG89eVsyXSxoPXlbM10sYz15WzRdLGc9eVs1XSxiPXlbNl0sRT15WzddLEE9eVs4XSxMPXlbOV0sTT15WzEwXSxJPXlbMTFdLEQ9eVsxMl0sUj15WzEzXSxDPXlbMTRdLEI9eVsxNV0sej15WzE2XSxLPXlbMTddLFE9eVsxOF0sXz15WzE5XTtsZXQgRj1QWzBdLEc9UFsxXSxYPVBbMl0sWj1QWzNdLHR0PVBbNF07cmV0dXJuIHhbMF09RiptK0cqZytYKk0rWipCLHhbMV09RipPK0cqYitYKkkrWip6LHhbMl09RipvK0cqRStYKkQrWipLLHhbM109RipoK0cqQStYKlIrWipRLHhbNF09RipjK0cqTCtYKkMrWipfK3R0LEY9UFs1XSxHPVBbNl0sWD1QWzddLFo9UFs4XSx0dD1QWzldLHhbNV09RiptK0cqZytYKk0rWipCLHhbNl09RipPK0cqYitYKkkrWip6LHhbN109RipvK0cqRStYKkQrWipLLHhbOF09RipoK0cqQStYKlIrWipRLHhbOV09RipjK0cqTCtYKkMrWipfK3R0LEY9UFsxMF0sRz1QWzExXSxYPVBbMTJdLFo9UFsxM10sdHQ9UFsxNF0seFsxMF09RiptK0cqZytYKk0rWipCLHhbMTFdPUYqTytHKmIrWCpJK1oqeix4WzEyXT1GKm8rRypFK1gqRCtaKksseFsxM109RipoK0cqQStYKlIrWipRLHhbMTRdPUYqYytHKkwrWCpDK1oqXyt0dCxGPVBbMTVdLEc9UFsxNl0sWD1QWzE3XSxaPVBbMThdLHR0PVBbMTldLHhbMTVdPUYqbStHKmcrWCpNK1oqQix4WzE2XT1GKk8rRypiK1gqSStaKnoseFsxN109RipvK0cqRStYKkQrWipLLHhbMThdPUYqaCtHKkErWCpSK1oqUSx4WzE5XT1GKmMrRypMK1gqQytaKl8rdHQseH1mdW5jdGlvbiBpKHkpe3k9T2JqZWN0KHIuY2xhbXApKDAsMSx5KTtjb25zdCBQPS4yMTI2KnkseD0uNzE1Mip5LG09LjA3MjIqeTtyZXR1cm5bUCsxLXkseCxtLDAsMCxQLHgrMS15LG0sMCwwLFAseCxtKzEteSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBhKHkpe3JldHVyblt5LDAsMCwwLDAsMCx5LDAsMCwwLDAsMCx5LDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGwoeSl7Y29uc3QgUD0uMjEyNiooMS15KSx4PS43MTUyKigxLXkpLG09LjA3MjIqKDEteSk7cmV0dXJuW1AreSx4LG0sMCwwLFAseCt5LG0sMCwwLFAseCxtK3ksMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gcyh5KXtjb25zdCBQPS41KigxLXkpO3JldHVyblt5LDAsMCwwLFAsMCx5LDAsMCxQLDAsMCx5LDAsUCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGYoeSl7Y29uc3QgUD0xLTIqeTtyZXR1cm5bUCwwLDAsMCx5LDAsUCwwLDAseSwwLDAsUCwwLHksMCwwLDAsMSwwXX1mdW5jdGlvbiB2KHkpe3JldHVyblsxLS42MDcqeSwuNzY5KnksLjE4OSp5LDAsMCwuMzQ5KnksMS0uMzE0KnksLjE2OCp5LDAsMCwuMjcyKnksLjUzNCp5LDEtLjg2OSp5LDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGQoeSl7cmV0dXJuWzEsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLHksMF19ZnVuY3Rpb24gcCh5KXtjb25zdCBQPXkvMTgwKk1hdGguUEkseD1NYXRoLmNvcyhQKSxtPU1hdGguc2luKFApLE89LjIxMjYsbz0uNzE1MixoPS4wNzIyO3JldHVybltPK3gqKDEtTykrbSotTyxvK3gqLW8rbSotbyxoK3gqLWgrbSooMS1oKSwwLDAsTyt4Ki1PK20qLjE0MyxvK3gqKDEtbykrbSouMTQsaCt4Ki1oK20qLS4yODMsMCwwLE8reCotTyttKi0oMS1PKSxvK3gqLW8rbSpvLGgreCooMS1oKSttKmgsMCwwLDAsMCwwLDEsMF19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBpfSk7dmFyIHI9dCgzMiksbj10Lm4ocik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoYSl7Y29uc3QgbD1uKCkoYSk7aWYoIWx8fCFsLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybltsWzBdLzI1NSxsWzFdLzI1NSxsWzJdLzI1NSxsWzNdXX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDMzKSxuPXQoMzcpLGk9dCgzOSk7dS5leHBvcnRzPWZ1bmN0aW9uKGwpe3ZhciBzLGY9cihsKTtyZXR1cm4gZi5zcGFjZT8ocz1BcnJheSgzKSxzWzBdPWkoZi52YWx1ZXNbMF0sMCwyNTUpLHNbMV09aShmLnZhbHVlc1sxXSwwLDI1NSksc1syXT1pKGYudmFsdWVzWzJdLDAsMjU1KSxmLnNwYWNlWzBdPT09ImgiJiYocz1uLnJnYihzKSkscy5wdXNoKGkoZi5hbHBoYSwwLDEpKSxzKTpbXX19LGZ1bmN0aW9uKHUsZSx0KXsoZnVuY3Rpb24ocil7dmFyIG49dCgzNCksaT10KDM1KSxhPXQoMzYpO3UuZXhwb3J0cz1zO3ZhciBsPXtyZWQ6MCxvcmFuZ2U6NjAseWVsbG93OjEyMCxncmVlbjoxODAsYmx1ZToyNDAscHVycGxlOjMwMH07ZnVuY3Rpb24gcyhmKXt2YXIgdixkPVtdLHA9MSx5O2lmKHR5cGVvZiBmPT0ic3RyaW5nIilpZihuW2ZdKWQ9bltmXS5zbGljZSgpLHk9InJnYiI7ZWxzZSBpZihmPT09InRyYW5zcGFyZW50IilwPTAseT0icmdiIixkPVswLDAsMF07ZWxzZSBpZigvXiNbQS1GYS1mMC05XSskLy50ZXN0KGYpKXt2YXIgUD1mLnNsaWNlKDEpLHg9UC5sZW5ndGgsbT14PD00O3A9MSxtPyhkPVtwYXJzZUludChQWzBdK1BbMF0sMTYpLHBhcnNlSW50KFBbMV0rUFsxXSwxNikscGFyc2VJbnQoUFsyXStQWzJdLDE2KV0seD09PTQmJihwPXBhcnNlSW50KFBbM10rUFszXSwxNikvMjU1KSk6KGQ9W3BhcnNlSW50KFBbMF0rUFsxXSwxNikscGFyc2VJbnQoUFsyXStQWzNdLDE2KSxwYXJzZUludChQWzRdK1BbNV0sMTYpXSx4PT09OCYmKHA9cGFyc2VJbnQoUFs2XStQWzddLDE2KS8yNTUpKSxkWzBdfHwoZFswXT0wKSxkWzFdfHwoZFsxXT0wKSxkWzJdfHwoZFsyXT0wKSx5PSJyZ2IifWVsc2UgaWYodj0vXigoPzpyZ2J8aHNbbHZiXXxod2J8Y215az98eHlbenldfGdyYXl8bGFifGxjaHU/dj98W2x5XXV2fGxtcylhPylccypcKChbXlwpXSopXCkvLmV4ZWMoZikpe3ZhciBPPXZbMV0sbz1PPT09InJnYiIsUD1PLnJlcGxhY2UoL2EkLywiIik7eT1QO3ZhciB4PVA9PT0iY215ayI/NDpQPT09ImdyYXkiPzE6MztkPXZbMl0udHJpbSgpLnNwbGl0KC9ccyosXHMqLykubWFwKGZ1bmN0aW9uKGIsRSl7aWYoLyUkLy50ZXN0KGIpKXJldHVybiBFPT09eD9wYXJzZUZsb2F0KGIpLzEwMDpQPT09InJnYiI/cGFyc2VGbG9hdChiKSoyNTUvMTAwOnBhcnNlRmxvYXQoYik7aWYoUFtFXT09PSJoIil7aWYoL2RlZyQvLnRlc3QoYikpcmV0dXJuIHBhcnNlRmxvYXQoYik7aWYobFtiXSE9PXZvaWQgMClyZXR1cm4gbFtiXX1yZXR1cm4gcGFyc2VGbG9hdChiKX0pLE89PT1QJiZkLnB1c2goMSkscD1vfHxkW3hdPT09dm9pZCAwPzE6ZFt4XSxkPWQuc2xpY2UoMCx4KX1lbHNlIGYubGVuZ3RoPjEwJiYvWzAtOV0oPzpcc3xcLykvLnRlc3QoZikmJihkPWYubWF0Y2goLyhbMC05XSspL2cpLm1hcChmdW5jdGlvbihjKXtyZXR1cm4gcGFyc2VGbG9hdChjKX0pLHk9Zi5tYXRjaCgvKFthLXpdKS9pZykuam9pbigiIikudG9Mb3dlckNhc2UoKSk7ZWxzZSBpZighaXNOYU4oZikpeT0icmdiIixkPVtmPj4+MTYsKGYmNjUyODApPj4+OCxmJjI1NV07ZWxzZSBpZihpKGYpKXt2YXIgaD1hKGYucixmLnJlZCxmLlIsbnVsbCk7aCE9PW51bGw/KHk9InJnYiIsZD1baCxhKGYuZyxmLmdyZWVuLGYuRyksYShmLmIsZi5ibHVlLGYuQildKTooeT0iaHNsIixkPVthKGYuaCxmLmh1ZSxmLkgpLGEoZi5zLGYuc2F0dXJhdGlvbixmLlMpLGEoZi5sLGYubGlnaHRuZXNzLGYuTCxmLmIsZi5icmlnaHRuZXNzKV0pLHA9YShmLmEsZi5hbHBoYSxmLm9wYWNpdHksMSksZi5vcGFjaXR5IT1udWxsJiYocC89MTAwKX1lbHNlKEFycmF5LmlzQXJyYXkoZil8fHIuQXJyYXlCdWZmZXImJkFycmF5QnVmZmVyLmlzVmlldyYmQXJyYXlCdWZmZXIuaXNWaWV3KGYpKSYmKGQ9W2ZbMF0sZlsxXSxmWzJdXSx5PSJyZ2IiLHA9Zi5sZW5ndGg9PT00P2ZbM106MSk7cmV0dXJue3NwYWNlOnksdmFsdWVzOmQsYWxwaGE6cH19fSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17YWxpY2VibHVlOlsyNDAsMjQ4LDI1NV0sYW50aXF1ZXdoaXRlOlsyNTAsMjM1LDIxNV0sYXF1YTpbMCwyNTUsMjU1XSxhcXVhbWFyaW5lOlsxMjcsMjU1LDIxMl0sYXp1cmU6WzI0MCwyNTUsMjU1XSxiZWlnZTpbMjQ1LDI0NSwyMjBdLGJpc3F1ZTpbMjU1LDIyOCwxOTZdLGJsYWNrOlswLDAsMF0sYmxhbmNoZWRhbG1vbmQ6WzI1NSwyMzUsMjA1XSxibHVlOlswLDAsMjU1XSxibHVldmlvbGV0OlsxMzgsNDMsMjI2XSxicm93bjpbMTY1LDQyLDQyXSxidXJseXdvb2Q6WzIyMiwxODQsMTM1XSxjYWRldGJsdWU6Wzk1LDE1OCwxNjBdLGNoYXJ0cmV1c2U6WzEyNywyNTUsMF0sY2hvY29sYXRlOlsyMTAsMTA1LDMwXSxjb3JhbDpbMjU1LDEyNyw4MF0sY29ybmZsb3dlcmJsdWU6WzEwMCwxNDksMjM3XSxjb3Juc2lsazpbMjU1LDI0OCwyMjBdLGNyaW1zb246WzIyMCwyMCw2MF0sY3lhbjpbMCwyNTUsMjU1XSxkYXJrYmx1ZTpbMCwwLDEzOV0sZGFya2N5YW46WzAsMTM5LDEzOV0sZGFya2dvbGRlbnJvZDpbMTg0LDEzNCwxMV0sZGFya2dyYXk6WzE2OSwxNjksMTY5XSxkYXJrZ3JlZW46WzAsMTAwLDBdLGRhcmtncmV5OlsxNjksMTY5LDE2OV0sZGFya2toYWtpOlsxODksMTgzLDEwN10sZGFya21hZ2VudGE6WzEzOSwwLDEzOV0sZGFya29saXZlZ3JlZW46Wzg1LDEwNyw0N10sZGFya29yYW5nZTpbMjU1LDE0MCwwXSxkYXJrb3JjaGlkOlsxNTMsNTAsMjA0XSxkYXJrcmVkOlsxMzksMCwwXSxkYXJrc2FsbW9uOlsyMzMsMTUwLDEyMl0sZGFya3NlYWdyZWVuOlsxNDMsMTg4LDE0M10sZGFya3NsYXRlYmx1ZTpbNzIsNjEsMTM5XSxkYXJrc2xhdGVncmF5Ols0Nyw3OSw3OV0sZGFya3NsYXRlZ3JleTpbNDcsNzksNzldLGRhcmt0dXJxdW9pc2U6WzAsMjA2LDIwOV0sZGFya3Zpb2xldDpbMTQ4LDAsMjExXSxkZWVwcGluazpbMjU1LDIwLDE0N10sZGVlcHNreWJsdWU6WzAsMTkxLDI1NV0sZGltZ3JheTpbMTA1LDEwNSwxMDVdLGRpbWdyZXk6WzEwNSwxMDUsMTA1XSxkb2RnZXJibHVlOlszMCwxNDQsMjU1XSxmaXJlYnJpY2s6WzE3OCwzNCwzNF0sZmxvcmFsd2hpdGU6WzI1NSwyNTAsMjQwXSxmb3Jlc3RncmVlbjpbMzQsMTM5LDM0XSxmdWNoc2lhOlsyNTUsMCwyNTVdLGdhaW5zYm9ybzpbMjIwLDIyMCwyMjBdLGdob3N0d2hpdGU6WzI0OCwyNDgsMjU1XSxnb2xkOlsyNTUsMjE1LDBdLGdvbGRlbnJvZDpbMjE4LDE2NSwzMl0sZ3JheTpbMTI4LDEyOCwxMjhdLGdyZWVuOlswLDEyOCwwXSxncmVlbnllbGxvdzpbMTczLDI1NSw0N10sZ3JleTpbMTI4LDEyOCwxMjhdLGhvbmV5ZGV3OlsyNDAsMjU1LDI0MF0saG90cGluazpbMjU1LDEwNSwxODBdLGluZGlhbnJlZDpbMjA1LDkyLDkyXSxpbmRpZ286Wzc1LDAsMTMwXSxpdm9yeTpbMjU1LDI1NSwyNDBdLGtoYWtpOlsyNDAsMjMwLDE0MF0sbGF2ZW5kZXI6WzIzMCwyMzAsMjUwXSxsYXZlbmRlcmJsdXNoOlsyNTUsMjQwLDI0NV0sbGF3bmdyZWVuOlsxMjQsMjUyLDBdLGxlbW9uY2hpZmZvbjpbMjU1LDI1MCwyMDVdLGxpZ2h0Ymx1ZTpbMTczLDIxNiwyMzBdLGxpZ2h0Y29yYWw6WzI0MCwxMjgsMTI4XSxsaWdodGN5YW46WzIyNCwyNTUsMjU1XSxsaWdodGdvbGRlbnJvZHllbGxvdzpbMjUwLDI1MCwyMTBdLGxpZ2h0Z3JheTpbMjExLDIxMSwyMTFdLGxpZ2h0Z3JlZW46WzE0NCwyMzgsMTQ0XSxsaWdodGdyZXk6WzIxMSwyMTEsMjExXSxsaWdodHBpbms6WzI1NSwxODIsMTkzXSxsaWdodHNhbG1vbjpbMjU1LDE2MCwxMjJdLGxpZ2h0c2VhZ3JlZW46WzMyLDE3OCwxNzBdLGxpZ2h0c2t5Ymx1ZTpbMTM1LDIwNiwyNTBdLGxpZ2h0c2xhdGVncmF5OlsxMTksMTM2LDE1M10sbGlnaHRzbGF0ZWdyZXk6WzExOSwxMzYsMTUzXSxsaWdodHN0ZWVsYmx1ZTpbMTc2LDE5NiwyMjJdLGxpZ2h0eWVsbG93OlsyNTUsMjU1LDIyNF0sbGltZTpbMCwyNTUsMF0sbGltZWdyZWVuOls1MCwyMDUsNTBdLGxpbmVuOlsyNTAsMjQwLDIzMF0sbWFnZW50YTpbMjU1LDAsMjU1XSxtYXJvb246WzEyOCwwLDBdLG1lZGl1bWFxdWFtYXJpbmU6WzEwMiwyMDUsMTcwXSxtZWRpdW1ibHVlOlswLDAsMjA1XSxtZWRpdW1vcmNoaWQ6WzE4Niw4NSwyMTFdLG1lZGl1bXB1cnBsZTpbMTQ3LDExMiwyMTldLG1lZGl1bXNlYWdyZWVuOls2MCwxNzksMTEzXSxtZWRpdW1zbGF0ZWJsdWU6WzEyMywxMDQsMjM4XSxtZWRpdW1zcHJpbmdncmVlbjpbMCwyNTAsMTU0XSxtZWRpdW10dXJxdW9pc2U6WzcyLDIwOSwyMDRdLG1lZGl1bXZpb2xldHJlZDpbMTk5LDIxLDEzM10sbWlkbmlnaHRibHVlOlsyNSwyNSwxMTJdLG1pbnRjcmVhbTpbMjQ1LDI1NSwyNTBdLG1pc3R5cm9zZTpbMjU1LDIyOCwyMjVdLG1vY2Nhc2luOlsyNTUsMjI4LDE4MV0sbmF2YWpvd2hpdGU6WzI1NSwyMjIsMTczXSxuYXZ5OlswLDAsMTI4XSxvbGRsYWNlOlsyNTMsMjQ1LDIzMF0sb2xpdmU6WzEyOCwxMjgsMF0sb2xpdmVkcmFiOlsxMDcsMTQyLDM1XSxvcmFuZ2U6WzI1NSwxNjUsMF0sb3JhbmdlcmVkOlsyNTUsNjksMF0sb3JjaGlkOlsyMTgsMTEyLDIxNF0scGFsZWdvbGRlbnJvZDpbMjM4LDIzMiwxNzBdLHBhbGVncmVlbjpbMTUyLDI1MSwxNTJdLHBhbGV0dXJxdW9pc2U6WzE3NSwyMzgsMjM4XSxwYWxldmlvbGV0cmVkOlsyMTksMTEyLDE0N10scGFwYXlhd2hpcDpbMjU1LDIzOSwyMTNdLHBlYWNocHVmZjpbMjU1LDIxOCwxODVdLHBlcnU6WzIwNSwxMzMsNjNdLHBpbms6WzI1NSwxOTIsMjAzXSxwbHVtOlsyMjEsMTYwLDIyMV0scG93ZGVyYmx1ZTpbMTc2LDIyNCwyMzBdLHB1cnBsZTpbMTI4LDAsMTI4XSxyZWJlY2NhcHVycGxlOlsxMDIsNTEsMTUzXSxyZWQ6WzI1NSwwLDBdLHJvc3licm93bjpbMTg4LDE0MywxNDNdLHJveWFsYmx1ZTpbNjUsMTA1LDIyNV0sc2FkZGxlYnJvd246WzEzOSw2OSwxOV0sc2FsbW9uOlsyNTAsMTI4LDExNF0sc2FuZHlicm93bjpbMjQ0LDE2NCw5Nl0sc2VhZ3JlZW46WzQ2LDEzOSw4N10sc2Vhc2hlbGw6WzI1NSwyNDUsMjM4XSxzaWVubmE6WzE2MCw4Miw0NV0sc2lsdmVyOlsxOTIsMTkyLDE5Ml0sc2t5Ymx1ZTpbMTM1LDIwNiwyMzVdLHNsYXRlYmx1ZTpbMTA2LDkwLDIwNV0sc2xhdGVncmF5OlsxMTIsMTI4LDE0NF0sc2xhdGVncmV5OlsxMTIsMTI4LDE0NF0sc25vdzpbMjU1LDI1MCwyNTBdLHNwcmluZ2dyZWVuOlswLDI1NSwxMjddLHN0ZWVsYmx1ZTpbNzAsMTMwLDE4MF0sdGFuOlsyMTAsMTgwLDE0MF0sdGVhbDpbMCwxMjgsMTI4XSx0aGlzdGxlOlsyMTYsMTkxLDIxNl0sdG9tYXRvOlsyNTUsOTksNzFdLHR1cnF1b2lzZTpbNjQsMjI0LDIwOF0sdmlvbGV0OlsyMzgsMTMwLDIzOF0sd2hlYXQ6WzI0NSwyMjIsMTc5XSx3aGl0ZTpbMjU1LDI1NSwyNTVdLHdoaXRlc21va2U6WzI0NSwyNDUsMjQ1XSx5ZWxsb3c6WzI1NSwyNTUsMF0seWVsbG93Z3JlZW46WzE1NCwyMDUsNTBdfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe3ZhciBpO3JldHVybiByLmNhbGwobik9PT0iW29iamVjdCBPYmplY3RdIiYmKGk9T2JqZWN0LmdldFByb3RvdHlwZU9mKG4pLGk9PT1udWxsfHxpPT09T2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSl9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspaWYoYXJndW1lbnRzW3RdIT09dm9pZCAwKXJldHVybiBhcmd1bWVudHNbdF19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgzOCk7dS5leHBvcnRzPXtuYW1lOiJoc2wiLG1pbjpbMCwwLDBdLG1heDpbMzYwLDEwMCwxMDBdLGNoYW5uZWw6WyJodWUiLCJzYXR1cmF0aW9uIiwibGlnaHRuZXNzIl0sYWxpYXM6WyJIU0wiXSxyZ2I6ZnVuY3Rpb24obil7dmFyIGk9blswXS8zNjAsYT1uWzFdLzEwMCxsPW5bMl0vMTAwLHMsZix2LGQscDtpZihhPT09MClyZXR1cm4gcD1sKjI1NSxbcCxwLHBdO2w8LjU/Zj1sKigxK2EpOmY9bCthLWwqYSxzPTIqbC1mLGQ9WzAsMCwwXTtmb3IodmFyIHk9MDt5PDM7eSsrKXY9aSsxLzMqLSh5LTEpLHY8MD92Kys6dj4xJiZ2LS0sNip2PDE/cD1zKyhmLXMpKjYqdjoyKnY8MT9wPWY6Myp2PDI/cD1zKyhmLXMpKigyLzMtdikqNjpwPXMsZFt5XT1wKjI1NTtyZXR1cm4gZH19LHIuaHNsPWZ1bmN0aW9uKG4pe3ZhciBpPW5bMF0vMjU1LGE9blsxXS8yNTUsbD1uWzJdLzI1NSxzPU1hdGgubWluKGksYSxsKSxmPU1hdGgubWF4KGksYSxsKSx2PWYtcyxkLHAseTtyZXR1cm4gZj09PXM/ZD0wOmk9PT1mP2Q9KGEtbCkvdjphPT09Zj9kPTIrKGwtaSkvdjpsPT09ZiYmKGQ9NCsoaS1hKS92KSxkPU1hdGgubWluKGQqNjAsMzYwKSxkPDAmJihkKz0zNjApLHk9KHMrZikvMixmPT09cz9wPTA6eTw9LjU/cD12LyhmK3MpOnA9di8oMi1mLXMpLFtkLHAqMTAwLHkqMTAwXX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9e25hbWU6InJnYiIsbWluOlswLDAsMF0sbWF4OlsyNTUsMjU1LDI1NV0sY2hhbm5lbDpbInJlZCIsImdyZWVuIiwiYmx1ZSJdLGFsaWFzOlsiUkdCIl19fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz10O2Z1bmN0aW9uIHQocixuLGkpe3JldHVybiBuPGk/cjxuP246cj5pP2k6cjpyPGk/aTpyPm4/bjpyfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciByPXQoNDEpLG49dC5uKHIpLGk9dCg0MiksYT10Lm4oaSksbD10KDQzKSxzPXQubihsKSxmPXQoNDQpLHY9dCg0NiksZD10Lm4odikscD10KDUzKSx5PXQoNTUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBQPVN5bWJvbCgiY29udG91cnMiKSx4PVN5bWJvbCgicGF0aCIpLG09U3ltYm9sKCJzaW1wbGlmeSIpLE89U3ltYm9sKCJzY2FsZSIpLG89MipNYXRoLlBJO2NsYXNzIGh7Y29uc3RydWN0b3IoZz17fSl7dHlwZW9mIGc9PSJzdHJpbmciJiYoZz17cGF0aDpnfSksZy5wYXRoP3RoaXNbeF09bigpKGcucGF0aCk6dGhpc1t4XT1bXSx0aGlzW1BdPW51bGwsdGhpc1ttXT1nLnNpbXBsaWZ5IT1udWxsP2cuc2ltcGxpZnk6MCx0aGlzW09dPWcuc2NhbGUhPW51bGw/Zy5zY2FsZToyfWdldCBjb250b3Vycygpe2xldCBnPW51bGw7aWYoIXRoaXNbUF0mJnRoaXNbeF0pe2NvbnN0IGI9T2JqZWN0KGYuZGVmYXVsdCkocygpKHRoaXNbeF0pKTt0aGlzW1BdPWQoKShiLHRoaXNbT10sdGhpc1ttXSksdGhpc1tQXS5wYXRoPWIsdGhpc1tQXS5zaW1wbGlmeT10aGlzW21dLHRoaXNbUF0uc2NhbGU9dGhpc1tPXX1yZXR1cm4gdGhpc1tQXSYmKGc9dGhpc1tQXS5tYXAoYj0+Wy4uLmJdKSxnLnBhdGg9dGhpc1tQXS5wYXRoLGcuc2ltcGxpZnk9dGhpc1tQXS5zaW1wbGlmeSxnLnNjYWxlPXRoaXNbUF0uc2NhbGUpLGd9Z2V0IHBhdGgoKXtyZXR1cm4gdGhpc1t4XX1nZXQgc2ltcGxpZnkoKXtyZXR1cm4gdGhpc1ttXX1nZXQgYm91bmRpbmdCb3goKXtjb25zdCBnPXRoaXMuY29udG91cnM7aWYoZyYmZy5sZW5ndGgpe2NvbnN0IGI9Zy5yZWR1Y2UoKEUsQSk9PlsuLi5FLC4uLkFdKTtyZXR1cm4gYSgpKGIpfXJldHVybltbMCwwXSxbMCwwXV19Z2V0IGJvdW5kaW5nQ2VudGVyKCl7Y29uc3QgZz10aGlzLmJvdW5kaW5nQm94O3JldHVybiBnP1suNSooZ1swXVswXStnWzFdWzBdKSwuNSooZ1swXVsxXStnWzFdWzFdKV06WzAsMF19bm9ybWFsaXplKGc9MCxiPTApe2NvbnN0IEU9T2JqZWN0KGYuZGVmYXVsdCkocygpKHRoaXNbeF0pKS5tYXAoKFtBLC4uLkxdKT0+e2NvbnN0IE09W0FdO2ZvcihsZXQgST0wO0k8TC5sZW5ndGg7SSs9Mil7Y29uc3QgRD1MW0ldLWcsUj1MW0krMV0tYjtNLnB1c2goRCxSKX1yZXR1cm4gTX0pO3JldHVybiB0aGlzLmJlZ2luUGF0aCgpLHRoaXNbeF0ucHVzaCguLi5FKSx0aGlzfWdldFBvaW50QXRMZW5ndGgoZyl7cmV0dXJuIHRoaXMuY29udG91cnM/T2JqZWN0KHAuZ2V0UG9pbnRBdExlbmd0aCkodGhpc1tQXSxnKTpudWxsfWdldFRvdGFsTGVuZ3RoKCl7cmV0dXJuIHRoaXMuY29udG91cnM/T2JqZWN0KHAuZ2V0VG90YWxMZW5ndGgpKHRoaXNbUF0pOjB9YWRkUGF0aChnKXt0aGlzW1BdPW51bGwsdHlwZW9mIGc9PSJzdHJpbmciJiYoZz1uKCkoZykpLHRoaXNbeF0ucHVzaCguLi5nKX1iZWdpblBhdGgoKXt0aGlzW3hdPVtdLHRoaXNbUF09bnVsbH1jbGVhcigpe3RoaXMuYmVnaW5QYXRoKCl9ZWxsaXBzZShnLGIsRSxBLEwsTSxJLEQ9MCl7aWYoTSs9TCxJKz1MLEU8PTB8fEE8PTB8fEk9PT1NKXJldHVybjtJPE0mJihJPU0rbysoSS1NKSVvKSxJLU0+byYmKEk9TStvKTtjb25zdCBSPUktTTtSPj1vJiYoSS09LjAwMSk7bGV0IEM9dGhpc1t4XS5sZW5ndGg+MCYmUjxvPyJMIjoiTSI7Y29uc3QgQj1PYmplY3QoeS5nZXRQb2ludCkoZyxiLEUsQSxNKSx6PU9iamVjdCh5LmdldFBvaW50KShnLGIsRSxBLEkpLEs9KyFEO2xldCBRPVI+TWF0aC5QST8xOjA7RCYmKFE9MS1RKSxDKz1CLmpvaW4oIiAiKSxDKz1gQSR7RX0gJHtBfSAwICR7UX0gJHtLfSAke3ouam9pbigiICIpfWAsUj49byYmKEMrPSJaIiksdGhpcy5hZGRQYXRoKEMpfWFyYyhnLGIsRSxBLEwsTT0wKXtyZXR1cm4gdGhpcy5lbGxpcHNlKGcsYixFLEUsMCxBLEwsTSl9YXJjVG8oZyxiLEUsQSxMLE0sSSl7dGhpc1tQXT1udWxsLHRoaXNbeF0ucHVzaChbIkEiLGcsYixFLEEsTCxNLEldKX1tb3ZlVG8oZyxiKXt0aGlzW1BdPW51bGwsdGhpc1t4XS5wdXNoKFsiTSIsZyxiXSl9bGluZVRvKGcsYil7dGhpc1tQXT1udWxsLHRoaXNbeF0ucHVzaChbIkwiLGcsYl0pfWJlemllckN1cnZlVG8oZyxiLEUsQSxMLE0pe3RoaXNbUF09bnVsbCx0aGlzW3hdLnB1c2goWyJDIixnLGIsRSxBLEwsTV0pfXF1YWRyYXRpY0N1cnZlVG8oZyxiLEUsQSl7dGhpc1tQXT1udWxsLHRoaXNbeF0ucHVzaChbIlEiLGcsYixFLEFdKX1yZWN0KGcsYixFLEEpe2NvbnN0IEw9YE0ke2d9ICR7Yn1MJHtnK0V9ICR7Yn1MJHtnK0V9ICR7YitBfUwke2d9ICR7YitBfVpgO3RoaXMuYWRkUGF0aChMKX1jbG9zZVBhdGgoKXt0aGlzW1BdPW51bGw7bGV0IGc9W107Y29uc3QgYj10aGlzW3hdLmxlbmd0aDtiPjAmJihnPXRoaXNbeF1bYi0xXSksZ1swXSE9PSJaIiYmZ1swXSE9PSJ6IiYmdGhpc1t4XS5wdXNoKFsiWiJdKX19fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1uO3ZhciB0PXthOjcsYzo2LGg6MSxsOjIsbToyLHE6NCxzOjQsdDoyLHY6MSx6OjB9LHI9LyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9pZztmdW5jdGlvbiBuKGwpe3ZhciBzPVtdO3JldHVybiBsLnJlcGxhY2UocixmdW5jdGlvbihmLHYsZCl7dmFyIHA9di50b0xvd2VyQ2FzZSgpO2ZvcihkPWEoZCkscD09Im0iJiZkLmxlbmd0aD4yJiYocy5wdXNoKFt2XS5jb25jYXQoZC5zcGxpY2UoMCwyKSkpLHA9ImwiLHY9dj09Im0iPyJsIjoiTCIpOzspe2lmKGQubGVuZ3RoPT10W3BdKXJldHVybiBkLnVuc2hpZnQodikscy5wdXNoKGQpO2lmKGQubGVuZ3RoPHRbcF0pdGhyb3cgbmV3IEVycm9yKCJtYWxmb3JtZWQgcGF0aCBkYXRhIik7cy5wdXNoKFt2XS5jb25jYXQoZC5zcGxpY2UoMCx0W3BdKSkpfX0pLHN9dmFyIGk9Ly0/WzAtOV0qXC4/WzAtOV0rKD86ZVstK10/XGQrKT8vaWc7ZnVuY3Rpb24gYShsKXt2YXIgcz1sLm1hdGNoKGkpO3JldHVybiBzP3MubWFwKE51bWJlcik6W119fSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXI7ZnVuY3Rpb24gcihuKXt2YXIgaT1uLmxlbmd0aDtpZihpPT09MClyZXR1cm5bW10sW11dO2Zvcih2YXIgYT1uWzBdLmxlbmd0aCxsPW5bMF0uc2xpY2UoKSxzPW5bMF0uc2xpY2UoKSxmPTE7ZjxpOysrZilmb3IodmFyIHY9bltmXSxkPTA7ZDxhOysrZCl7dmFyIHA9dltkXTtsW2RdPU1hdGgubWluKGxbZF0scCksc1tkXT1NYXRoLm1heChzW2RdLHApfXJldHVybltsLHNdfX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9dDtmdW5jdGlvbiB0KHIpe3ZhciBuPTAsaT0wLGE9MCxsPTA7cmV0dXJuIHIubWFwKGZ1bmN0aW9uKHMpe3M9cy5zbGljZSgpO3ZhciBmPXNbMF0sdj1mLnRvVXBwZXJDYXNlKCk7aWYoZiE9dilzd2l0Y2goc1swXT12LGYpe2Nhc2UiYSI6c1s2XSs9YSxzWzddKz1sO2JyZWFrO2Nhc2UidiI6c1sxXSs9bDticmVhaztjYXNlImgiOnNbMV0rPWE7YnJlYWs7ZGVmYXVsdDpmb3IodmFyIGQ9MTtkPHMubGVuZ3RoOylzW2QrK10rPWEsc1tkKytdKz1sfXN3aXRjaCh2KXtjYXNlIloiOmE9bixsPWk7YnJlYWs7Y2FzZSJIIjphPXNbMV07YnJlYWs7Y2FzZSJWIjpsPXNbMV07YnJlYWs7Y2FzZSJNIjphPW49c1sxXSxsPWk9c1syXTticmVhaztkZWZhdWx0OmE9c1tzLmxlbmd0aC0yXSxsPXNbcy5sZW5ndGgtMV19cmV0dXJuIHN9KX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgcj10KDQ1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihsKXtmb3IodmFyIHMsZj1bXSx2PTAsZD0wLHA9MCx5PTAsUD1udWxsLHg9bnVsbCxtPTAsTz0wLG89MCxoPWwubGVuZ3RoO288aDtvKyspe3ZhciBjPWxbb10sZz1jWzBdO3N3aXRjaChnKXtjYXNlIk0iOnA9Y1sxXSx5PWNbMl07YnJlYWs7Y2FzZSJBIjp2YXIgYj1PYmplY3Qoci5kZWZhdWx0KShtLE8sY1s2XSxjWzddLGNbNF0sY1s1XSxjWzFdLGNbMl0sY1szXSk7aWYoIWIubGVuZ3RoKWNvbnRpbnVlO2I9Yi5tYXAoST0+e2NvbnN0W0QsUixDLEIseixLLFEsX109STtyZXR1cm57eDE6Qyx5MTpCLHgyOnoseTI6Syx4OlEseTpffX0pO2Zvcih2YXIgRT0wLEE7RTxiLmxlbmd0aDtFKyspQT1iW0VdLGM9WyJDIixBLngxLEEueTEsQS54MixBLnkyLEEueCxBLnldLEU8Yi5sZW5ndGgtMSYmZi5wdXNoKGMpO2JyZWFrO2Nhc2UiUyI6dmFyIEw9bSxNPU87KHM9PSJDInx8cz09IlMiKSYmKEwrPUwtdixNKz1NLWQpLGM9WyJDIixMLE0sY1sxXSxjWzJdLGNbM10sY1s0XV07YnJlYWs7Y2FzZSJUIjpzPT0iUSJ8fHM9PSJUIj8oUD1tKjItUCx4PU8qMi14KTooUD1tLHg9TyksYz1hKG0sTyxQLHgsY1sxXSxjWzJdKTticmVhaztjYXNlIlEiOlA9Y1sxXSx4PWNbMl0sYz1hKG0sTyxjWzFdLGNbMl0sY1szXSxjWzRdKTticmVhaztjYXNlIkwiOmM9aShtLE8sY1sxXSxjWzJdKTticmVhaztjYXNlIkgiOmM9aShtLE8sY1sxXSxPKTticmVhaztjYXNlIlYiOmM9aShtLE8sbSxjWzFdKTticmVhaztjYXNlIloiOmM9aShtLE8scCx5KTticmVha31zPWcsbT1jW2MubGVuZ3RoLTJdLE89Y1tjLmxlbmd0aC0xXSxjLmxlbmd0aD40Pyh2PWNbYy5sZW5ndGgtNF0sZD1jW2MubGVuZ3RoLTNdKToodj1tLGQ9TyksZi5wdXNoKGMpfXJldHVybiBmfWZ1bmN0aW9uIGkobCxzLGYsdil7cmV0dXJuWyJDIixsLHMsZix2LGYsdl19ZnVuY3Rpb24gYShsLHMsZix2LGQscCl7cmV0dXJuWyJDIixsLzMrMi8zKmYscy8zKzIvMyp2LGQvMysyLzMqZixwLzMrMi8zKnYsZCxwXX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcj1NYXRoLlBJKjI7ZnVuY3Rpb24gbihzLGYsdixkKXtjb25zdCBwPXMqZC1mKnY8MD8tMToxO2xldCB5PXMqditmKmQ7cmV0dXJuIHk+MSYmKHk9MSkseTwtMSYmKHk9LTEpLHAqTWF0aC5hY29zKHkpfWZ1bmN0aW9uIGkocyxmLHYsZCxwLHksUCx4LG0sTyl7Y29uc3Qgbz1PKihzLXYpLzIrbSooZi1kKS8yLGg9LW0qKHMtdikvMitPKihmLWQpLzIsYz1QKlAsZz14KngsYj1vKm8sRT1oKmg7bGV0IEE9YypnLWMqRS1nKmI7QTwwJiYoQT0wKSxBLz1jKkUrZypiLEE9TWF0aC5zcXJ0KEEpKihwPT09eT8tMToxKTtjb25zdCBMPUEqUC94KmgsTT1BKi14L1AqbyxJPU8qTC1tKk0rKHMrdikvMixEPW0qTCtPKk0rKGYrZCkvMixSPShvLUwpL1AsQz0oaC1NKS94LEI9KC1vLUwpL1Asej0oLWgtTSkveCxLPW4oMSwwLFIsQyk7bGV0IFE9bihSLEMsQix6KTtyZXR1cm4geT09PTAmJlE+MCYmKFEtPXIpLHk9PT0xJiZRPDAmJihRKz1yKSxbSSxELEssUV19ZnVuY3Rpb24gYShzLGYpe2NvbnN0IHY9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKGYvNCksZD1NYXRoLmNvcyhzKSxwPU1hdGguc2luKHMpLHk9TWF0aC5jb3MocytmKSxQPU1hdGguc2luKHMrZik7cmV0dXJuW2QscCxkLXAqdixwK2Qqdix5K1AqdixQLXkqdix5LFBdfWZ1bmN0aW9uIGwocyxmLHYsZCxwLHksUCx4LG0pe2NvbnN0IE89TWF0aC5zaW4obSpyLzM2MCksbz1NYXRoLmNvcyhtKnIvMzYwKSxoPW8qKHMtdikvMitPKihmLWQpLzIsYz0tTyoocy12KS8yK28qKGYtZCkvMjtpZihoPT09MCYmYz09PTApcmV0dXJuW107aWYoUD09PTB8fHg9PT0wKXJldHVybltdO1A9TWF0aC5hYnMoUCkseD1NYXRoLmFicyh4KTtjb25zdCBnPWgqaC8oUCpQKStjKmMvKHgqeCk7Zz4xJiYoUCo9TWF0aC5zcXJ0KGcpLHgqPU1hdGguc3FydChnKSk7Y29uc3QgYj1pKHMsZix2LGQscCx5LFAseCxPLG8pLEU9W107bGV0IEE9YlsyXSxMPWJbM107Y29uc3QgTT1NYXRoLm1heChNYXRoLmNlaWwoTWF0aC5hYnMoTCkvKHIvNCkpLDEpO0wvPU07Zm9yKGxldCBJPTA7STxNO0krKylFLnB1c2goYShBLEwpKSxBKz1MO3JldHVybiBFLm1hcChJPT57Zm9yKGxldCBEPTA7RDxJLmxlbmd0aDtEKz0yKXtsZXQgUj1JW0QrMF0sQz1JW0QrMV07Uio9UCxDKj14O2NvbnN0IEI9bypSLU8qQyx6PU8qUitvKkM7SVtEKzBdPUIrYlswXSxJW0QrMV09eitiWzFdfXJldHVybiBJfSl9fSxmdW5jdGlvbih1LGUsdCl7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO3ZhciByPXQoNDcpLHtjb3B5Om59PXQoNDkpLGk9dCg1MCk7ZnVuY3Rpb24gYShkLHAseSl7cmV0dXJuIGRbMF09cCxkWzFdPXksZH12YXIgbD1bMCwwXSxzPVswLDBdLGY9WzAsMF07ZnVuY3Rpb24gdihkLHAseSxQKXtyKHksYShsLFBbMV0sUFsyXSksYShzLFBbM10sUFs0XSksYShmLFBbNV0sUFs2XSkscCxkKX11LmV4cG9ydHM9ZnVuY3Rpb24ocCx5LFApe3ZhciB4PVtdLG09W10sTz1bMCwwXTtyZXR1cm4gcC5mb3JFYWNoKGZ1bmN0aW9uKG8saCxjKXtpZihvWzBdPT09Ik0iKW4oTyxvLnNsaWNlKDEpKSxtLmxlbmd0aD4wJiYoeC5wdXNoKG0pLG09W10pO2Vsc2UgaWYob1swXT09PSJDIil2KG0seSxPLG8pLGEoTyxvWzVdLG9bNl0pO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJpbGxlZ2FsIHR5cGUgaW4gU1ZHOiAiK29bMF0pfSksbS5sZW5ndGg+MCYmeC5wdXNoKG0pLHgubWFwKGZ1bmN0aW9uKG8pe3JldHVybiBpKG8sUHx8MCl9KX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9dCg0OCkoKX0sZnVuY3Rpb24odSxlKXtmdW5jdGlvbiB0KG4pe3JldHVybltuWzBdLG5bMV1dfWZ1bmN0aW9uIHIobixpKXtyZXR1cm5bbixpXX11LmV4cG9ydHM9ZnVuY3Rpb24oaSl7aT1pfHx7fTt2YXIgYT10eXBlb2YgaS5yZWN1cnNpb249PSJudW1iZXIiP2kucmVjdXJzaW9uOjgsbD10eXBlb2YgaS5lcHNpbG9uPT0ibnVtYmVyIj9pLmVwc2lsb246MTE5MjA5MjllLTE0LHM9dHlwZW9mIGkucGF0aEVwc2lsb249PSJudW1iZXIiP2kucGF0aEVwc2lsb246MSxmPXR5cGVvZiBpLmFuZ2xlRXBzaWxvbj09Im51bWJlciI/aS5hbmdsZUVwc2lsb246LjAxLHY9aS5hbmdsZVRvbGVyYW5jZXx8MCxkPWkuY3VzcExpbWl0fHwwO3JldHVybiBmdW5jdGlvbih4LG0sTyxvLGgsYyl7Y3x8KGM9W10pLGg9dHlwZW9mIGg9PSJudW1iZXIiP2g6MTt2YXIgZz1zL2g7cmV0dXJuIGcqPWcscCh4LG0sTyxvLGMsZyksY307ZnVuY3Rpb24gcChQLHgsbSxPLG8saCl7by5wdXNoKHQoUCkpO3ZhciBjPVBbMF0sZz1QWzFdLGI9eFswXSxFPXhbMV0sQT1tWzBdLEw9bVsxXSxNPU9bMF0sST1PWzFdO3koYyxnLGIsRSxBLEwsTSxJLG8saCwwKSxvLnB1c2godChPKSl9ZnVuY3Rpb24geShQLHgsbSxPLG8saCxjLGcsYixFLEEpe2lmKCEoQT5hKSl7dmFyIEw9TWF0aC5QSSxNPShQK20pLzIsST0oeCtPKS8yLEQ9KG0rbykvMixSPShPK2gpLzIsQz0obytjKS8yLEI9KGgrZykvMix6PShNK0QpLzIsSz0oSStSKS8yLFE9KEQrQykvMixfPShSK0IpLzIsRj0oeitRKS8yLEc9KEsrXykvMjtpZihBPjApe3ZhciBYPWMtUCxaPWcteCx0dD1NYXRoLmFicygobS1jKSpaLShPLWcpKlgpLG50PU1hdGguYWJzKChvLWMpKlotKGgtZykqWCkscSxodDtpZih0dD5sJiZudD5sKXtpZigodHQrbnQpKih0dCtudCk8PUUqKFgqWCtaKlopKXtpZih2PGYpe2IucHVzaChyKEYsRykpO3JldHVybn12YXIgdXQ9TWF0aC5hdGFuMihoLU8sby1tKTtpZihxPU1hdGguYWJzKHV0LU1hdGguYXRhbjIoTy14LG0tUCkpLGh0PU1hdGguYWJzKE1hdGguYXRhbjIoZy1oLGMtbyktdXQpLHE+PUwmJihxPTIqTC1xKSxodD49TCYmKGh0PTIqTC1odCkscStodDx2KXtiLnB1c2gocihGLEcpKTtyZXR1cm59aWYoZCE9PTApe2lmKHE+ZCl7Yi5wdXNoKHIobSxPKSk7cmV0dXJufWlmKGh0PmQpe2IucHVzaChyKG8saCkpO3JldHVybn19fX1lbHNlIGlmKHR0Pmwpe2lmKHR0KnR0PD1FKihYKlgrWipaKSl7aWYodjxmKXtiLnB1c2gocihGLEcpKTtyZXR1cm59aWYocT1NYXRoLmFicyhNYXRoLmF0YW4yKGgtTyxvLW0pLU1hdGguYXRhbjIoTy14LG0tUCkpLHE+PUwmJihxPTIqTC1xKSxxPHYpe2IucHVzaChyKG0sTykpLGIucHVzaChyKG8saCkpO3JldHVybn1pZihkIT09MCYmcT5kKXtiLnB1c2gocihtLE8pKTtyZXR1cm59fX1lbHNlIGlmKG50Pmwpe2lmKG50Km50PD1FKihYKlgrWipaKSl7aWYodjxmKXtiLnB1c2gocihGLEcpKTtyZXR1cm59aWYocT1NYXRoLmFicyhNYXRoLmF0YW4yKGctaCxjLW8pLU1hdGguYXRhbjIoaC1PLG8tbSkpLHE+PUwmJihxPTIqTC1xKSxxPHYpe2IucHVzaChyKG0sTykpLGIucHVzaChyKG8saCkpO3JldHVybn1pZihkIT09MCYmcT5kKXtiLnB1c2gocihvLGgpKTtyZXR1cm59fX1lbHNlIGlmKFg9Ri0oUCtjKS8yLFo9Ry0oeCtnKS8yLFgqWCtaKlo8PUUpe2IucHVzaChyKEYsRykpO3JldHVybn19eShQLHgsTSxJLHosSyxGLEcsYixFLEErMSkseShGLEcsUSxfLEMsQixjLGcsYixFLEErMSl9fX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJjb21wdXRlTWl0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibm9ybWFsIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImRpcmVjdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gb30pO3ZhciByPXQoMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oaCl7cmV0dXJuW2hbMF0saFsxXV19ZnVuY3Rpb24gaSgpe3JldHVyblswLDBdfWNvbnN0IGE9ci52ZWMyLmNvcHksbD1yLnZlYzIuc2NhbGVBbmRBZGQscz1yLnZlYzIuZG90LGY9ci52ZWMyLnJvdGF0ZSx2PXIudmVjMi5jcm9zcyxkPXIudmVjMi5zdWIscD1yLnZlYzIuYWRkLHk9ci52ZWMyLm5vcm1hbGl6ZSxQPXIudmVjMi5zZXQseD1pKCk7ZnVuY3Rpb24gbShoLGMsZyxiLEUpe3AoaCxnLGIpLHkoaCxoKSxQKGMsLWhbMV0saFswXSksUCh4LC1nWzFdLGdbMF0pO2NvbnN0IEE9RS9zKGMseCk7cmV0dXJuIE1hdGguYWJzKEEpfWZ1bmN0aW9uIE8oaCxjKXtyZXR1cm4gUChoLC1jWzFdLGNbMF0pLGh9ZnVuY3Rpb24gbyhoLGMsZyl7cmV0dXJuIGQoaCxjLGcpLHkoaCxoKSxofX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoNTEpLG49dCg1Mik7dS5leHBvcnRzPWZ1bmN0aW9uKGEsbCl7cmV0dXJuIGE9cihhLGwpLGE9bihhLGwpLGF9LHUuZXhwb3J0cy5yYWRpYWxEaXN0YW5jZT1yLHUuZXhwb3J0cy5kb3VnbGFzUGV1Y2tlcj1ufSxmdW5jdGlvbih1LGUpe2Z1bmN0aW9uIHQocixuKXt2YXIgaT1yWzBdLW5bMF0sYT1yWzFdLW5bMV07cmV0dXJuIGkqaSthKmF9dS5leHBvcnRzPWZ1bmN0aW9uKG4saSl7aWYobi5sZW5ndGg8PTEpcmV0dXJuIG47aT10eXBlb2YgaT09Im51bWJlciI/aToxO2Zvcih2YXIgYT1pKmksbD1uWzBdLHM9W2xdLGYsdj0xLGQ9bi5sZW5ndGg7djxkO3YrKylmPW5bdl0sdChmLGwpPmEmJihzLnB1c2goZiksbD1mKTtyZXR1cm4gbCE9PWYmJnMucHVzaChmKSxzfX0sZnVuY3Rpb24odSxlKXtmdW5jdGlvbiB0KG4saSxhKXt2YXIgbD1pWzBdLHM9aVsxXSxmPWFbMF0tbCx2PWFbMV0tcztpZihmIT09MHx8diE9PTApe3ZhciBkPSgoblswXS1sKSpmKyhuWzFdLXMpKnYpLyhmKmYrdip2KTtkPjE/KGw9YVswXSxzPWFbMV0pOmQ+MCYmKGwrPWYqZCxzKz12KmQpfXJldHVybiBmPW5bMF0tbCx2PW5bMV0tcyxmKmYrdip2fWZ1bmN0aW9uIHIobixpLGEsbCxzKXtmb3IodmFyIGY9bCx2LGQ9aSsxO2Q8YTtkKyspe3ZhciBwPXQobltkXSxuW2ldLG5bYV0pO3A+ZiYmKHY9ZCxmPXApfWY+bCYmKHYtaT4xJiZyKG4saSx2LGwscykscy5wdXNoKG5bdl0pLGEtdj4xJiZyKG4sdixhLGwscykpfXUuZXhwb3J0cz1mdW5jdGlvbihpLGEpe2lmKGkubGVuZ3RoPD0xKXJldHVybiBpO2E9dHlwZW9mIGE9PSJudW1iZXIiP2E6MTt2YXIgbD1hKmEscz1pLmxlbmd0aC0xLGY9W2lbMF1dO3JldHVybiByKGksMCxzLGwsZiksZi5wdXNoKGlbc10pLGZ9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJnZXRUb3RhbExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJnZXRQb2ludEF0TGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImdldERhc2hDb250b3VycyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoNTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHMpe2lmKHMudG90YWxMZW5ndGghPW51bGwpcmV0dXJuIHMudG90YWxMZW5ndGg7bGV0IGY9MDtyZXR1cm4gcy5mb3JFYWNoKHY9PntsZXQgZD12WzBdO2ZvcihsZXQgcD0xO3A8di5sZW5ndGg7cCsrKXtjb25zdCB5PXZbcF07Zis9T2JqZWN0KHIuZGlzdGFuY2UpKGQseSksZD15fX0pLHMudG90YWxMZW5ndGg9ZixmfWZ1bmN0aW9uIGkocyxmLHY9ITApe2lmKGY9TnVtYmVyKGYpLCFOdW1iZXIuaXNGaW5pdGUoZikpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoZjw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJMZW5ndGggbXVzdCA+IDAiKTtjb25zdCBkPW4ocyk7aWYoZj49ZCl7Y29uc3QgeT1zW3MubGVuZ3RoLTFdLFA9eVt5Lmxlbmd0aC0yXSx4PXlbeS5sZW5ndGgtMV0sbT1NYXRoLmF0YW4yKHhbMV0tUFsxXSx4WzBdLVBbMF0pO3JldHVybntjdXJyZW50OnMubWFwKE89PlsuLi5PXSkscG9pbnQ6e3g6eFswXSx5OnhbMV0sYW5nbGU6bX19fWNvbnN0IHA9W107Zm9yKGxldCB5PTA7eTxzLmxlbmd0aDt5Kyspe3BbeV09W107Y29uc3QgUD1zW3ldO2xldCB4PVBbMF07Zm9yKGxldCBtPTE7bTxQLmxlbmd0aDttKyspe2NvbnN0IE89UFttXSxvPU9iamVjdChyLmRpc3RhbmNlKSh4LE8pO2lmKGY8byl7Y29uc3QgaD1mL28sYz1NYXRoLmF0YW4yKE9bMV0teFsxXSxPWzBdLXhbMF0pLGc9e3g6eFswXSooMS1oKStPWzBdKmgseTp4WzFdKigxLWgpK09bMV0qaCxhbmdsZTpjfTtpZihwW3ldLnB1c2goeCksZj4wJiZwW3ldLnB1c2goW2cueCxnLnldKSwhdilyZXR1cm57Y3VycmVudDpwLHBvaW50Omd9O2NvbnN0IGI9W10sRT15O2Zvcig7eTxzLmxlbmd0aDt5Kyspe2ZvcihiW3ktRV09W10seT09PUUmJmJbMF0ucHVzaChbZy54LGcueV0pO208UC5sZW5ndGg7bSsrKWJbeS1FXS5wdXNoKFBbbV0pO209MH1yZXR1cm57Y3VycmVudDpwLHBvaW50OmcscmVzdDpifX1mLT1vLHBbeV0ucHVzaCh4KSx4PU99fX1mdW5jdGlvbiBhKHMsZil7aWYoZj1OdW1iZXIoZiksIU51bWJlci5pc0Zpbml0ZShmKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UG9pbnRBdExlbmd0aCcgb24gZmlndXJlOiBUaGUgcHJvdmlkZWQgZmxvYXQgdmFsdWUgaXMgbm9uLWZpbml0ZS4iKTtpZihzLmxlbmd0aDw9MClyZXR1cm57eDowLHk6MCxhbmdsZTowfTtpZihmPD0wKXtjb25zdCB2PXNbMF1bMF0sZD1zWzBdWzFdLHA9TWF0aC5hdGFuMihkWzFdLXZbMV0sZFswXS12WzBdKTtyZXR1cm57eDp2WzBdLHk6dlsxXSxhbmdsZTpwfX1yZXR1cm4gaShzLGYsITEpLnBvaW50fWZ1bmN0aW9uIGwocyxmLHYpe2xldCBkPTAscD1mWzBdLHk9cztjb25zdCBQPVtdLHg9Zi5sZW5ndGg7aWYodj4wKXtkbyB2LT1mW2QleF0sZCsrO3doaWxlKHY+MCk7djwwJiYocD0tdixkLS0pfWVsc2UgaWYodjwwKXtkPS0xO2RvIHYrPWZbZCV4K3gtMV0sZC0tO3doaWxlKHY8MCk7dj49MCYmKGQrKyxwPWZbZCV4K3gtMV0tdil9ZG97Y29uc3QgbT1pKHkscCk7eT1tLnJlc3QsKytkJTImJlAucHVzaCguLi5tLmN1cnJlbnQpO2xldCBPPWQleDtPPDAmJihPKz14KSxwPWZbT119d2hpbGUoeSk7cmV0dXJuIFB9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihbaSxhLGxdLHMsZix2KXtyZXR1cm4gaT1pKjIvcy0xLGE9MS1hKjIvZixOdW1iZXIuaXNGaW5pdGUodik/KGw9bCoyL3YtMSxbaSxhLGxdKTpbaSxhXX1mdW5jdGlvbiBuKFtpLGEsbD0wXSxbcyxmLHY9MF0pe3JldHVybiBNYXRoLmh5cG90KHMtaSxmLWEsdi1sKX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImdldFBvaW50IixmdW5jdGlvbigpe3JldHVybiBufSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIG4oaSxhLGwscyxmKXtmJT1yLGY8MCYmKGYrPXIpO2NvbnN0IHY9TWF0aC50YW4oZik7aWYoTWF0aC5hYnModik8MWU1KXtjb25zdCBkPWEtdippLHA9MS9sKioyK3YqKjIvcyoqMjtsZXQgeT0tMTsoZjw9TWF0aC5QSS8yfHxmPjMqTWF0aC5QSS8yKSYmKHk9MSk7Y29uc3QgUD15Kk1hdGguc3FydCgxL3ApK2kseD12KlArZDtyZXR1cm5bUCx4XX1yZXR1cm4gZjxNYXRoLlBJP1tpLGErc106W2ksYS1zXX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KTt2YXIgcj10KDEpLG49dCg0MiksaT10Lm4obiksYT10KDU3KSxsPXQoMjgpLHM9dCgyNCksZj10KDMwKSx2PXQoNTkpLGQ9dCg1MykscD10KDYwKSx5PXQubihwKSxQPXQoNDYpLHg9dC5uKFApLG09dCgzMSksTz10KDQwKSxvPXQoMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKEosTil7aWYoSj09bnVsbClyZXR1cm57fTt2YXIgJD1jKEosTiksUyxUO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciB3PU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoSik7Zm9yKFQ9MDtUPHcubGVuZ3RoO1QrKylTPXdbVF0sIShOLmluZGV4T2YoUyk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoSixTKSYmKCRbU109SltTXSl9cmV0dXJuICR9ZnVuY3Rpb24gYyhKLE4pe2lmKEo9PW51bGwpcmV0dXJue307dmFyICQ9e30sUz1PYmplY3Qua2V5cyhKKSxULHc7Zm9yKHc9MDt3PFMubGVuZ3RoO3crKylUPVNbd10sIShOLmluZGV4T2YoVCk+PTApJiYoJFtUXT1KW1RdKTtyZXR1cm4gJH1jb25zdCBnPVN5bWJvbCgibWVzaCIpLGI9U3ltYm9sKCJjb250b3VycyIpLEU9U3ltYm9sKCJzdHJva2UiKSxBPVN5bWJvbCgiZmlsbCIpLEw9U3ltYm9sKCJzdHJva2VDb2xvciIpLE09U3ltYm9sKCJmaWxsQ29sb3IiKSxJPVN5bWJvbCgidHJhbnNmb3JtIiksRD1TeW1ib2woImludmVydFRyYW5zZm9ybSIpLFI9U3ltYm9sKCJ1bmlmb3JtcyIpLEM9U3ltYm9sKCJ0ZXhPcHRpb25zIiksQj1TeW1ib2woImJsZW5kIiksej1TeW1ib2woImFwcGx5VGV4dHVyZSIpLEs9U3ltYm9sKCJhcHBseVRyYW5zZm9ybSIpLFE9U3ltYm9sKCJhcHBseUdyYWRpZW50VHJhbnNmb3JtIiksXz1TeW1ib2woImFwcGx5UHJvZ3JhbSIpLEY9U3ltYm9sKCJncmFkaWVudCIpLEc9U3ltYm9sKCJmaWx0ZXIiKSxYPVN5bWJvbCgib3BhY2l0eSIpLFo9U3ltYm9sKCJwcm9ncmFtIiksdHQ9U3ltYm9sKCJhdHRyaWJ1dGVzIiksbnQ9U3ltYm9sKCJwYXNzIikscT1TeW1ib2woImNsaXBDb250ZXh0IiksaHQ9U3ltYm9sKCJhcHBseUNsaXBQYXRoIik7ZnVuY3Rpb24gdXQoSixOKXtjb25zdFskLFNdPVtKWzFdWzBdLUpbMF1bMF0sSlsxXVsxXS1KWzBdWzFdXSxUPVtdO2ZvcihsZXQgdz0wO3c8Ti5sZW5ndGg7dysrKXtjb25zdCBVPU5bd10sSD1bKFVbMF0tSlswXVswXSkvJCwxLShVWzFdLUpbMF1bMV0pL1NdO1QucHVzaChIKX1yZXR1cm4gVH1mdW5jdGlvbiBqKFtKLE5dLFskLFMsVCx3XSx7c2NhbGU6VX0pe3JldHVybiBVfHwoSi89VCxOPTEtTi93LEotPSQsTis9UyksW0osTiwwXX1mdW5jdGlvbiBXKEosTiwkKXtjb25zdCBTPXgoKShKLE4sJCk7cmV0dXJuIFMucGF0aD1KLFMuc2ltcGxpZnk9JCxTLnNjYWxlPU4sU31jbGFzcyBWe2NvbnN0cnVjdG9yKE4pe3RoaXNbRV09bnVsbCx0aGlzW0FdPW51bGwsdGhpc1tJXT1bMSwwLDAsMSwwLDBdLHRoaXNbWF09MSx0aGlzW1JdPXt9LHRoaXNbR109W10sdGhpc1tCXT1udWxsLHRoaXNbQ109e30sdGhpcy5jb250b3Vycz1OLmNvbnRvdXJzLHRoaXNbWl09bnVsbCx0aGlzW3R0XT17fSx0aGlzW250XT1bXX1nZXQgY29udG91cnMoKXtyZXR1cm4gdGhpc1tiXX1zZXQgY29udG91cnMoTil7dGhpc1tnXT1udWxsLHRoaXNbYl09Tjtjb25zdCAkPU4uc2NhbGU7dGhpcy50cmFuc2Zvcm1TY2FsZS8kPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKX1zZXRQcm9ncmFtKE4pe3RoaXNbWl09Tix0aGlzW2ddJiZ0aGlzW19dKE4pfWdldCBwcm9ncmFtKCl7cmV0dXJuIHRoaXNbWl19c2V0QXR0cmlidXRlKE4sJCl7JD09bnVsbD9kZWxldGUgdGhpc1t0dF1bTl06dGhpc1t0dF1bTl09JH1nZXRPcGFjaXR5KCl7cmV0dXJuIHRoaXNbWF19c2V0T3BhY2l0eShOKXtpZihOPDB8fE4+MSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIG9wYWNpdHkgdmFsdWUuIik7dGhpc1tnXSYmdGhpc1tnXS5wb3NpdGlvbnMuZm9yRWFjaCgkPT57JFsyXT0xLyRbMl0+MD9OOi1OfSksdGhpc1tYXT1OfXNldENsaXBQYXRoKE4pe3RoaXMuY2xpcFBhdGg9Tix0aGlzW1JdLnVfY2xpcFNhbXBsZXImJnRoaXNbUl0udV9jbGlwU2FtcGxlci5kZWxldGUoKSx0aGlzLnNldFVuaWZvcm1zKHt1X2NsaXBTYW1wbGVyOm51bGx9KSx0aGlzW2ddJiZkZWxldGUgdGhpc1tnXS5hdHRyaWJ1dGVzLmFfY2xpcFVWLE4mJnRoaXNbZ10mJnRoaXNbaHRdKCl9W2h0XSgpe2lmKHRoaXMuY2xpcFBhdGgpe3RoaXNbcV18fCh0aGlzW3FdPW8uZGVmYXVsdC5jcmVhdGVDYW52YXMoMSwxKSk7Y29uc3RbW04sJF0sW1MsVF1dPXRoaXMuYm91bmRpbmdCb3g7UyYmVCYmKHRoaXNbcV0ud2lkdGg9Uy1OLHRoaXNbcV0uaGVpZ2h0PVQtJCk7Y29uc3Qgdz10aGlzW3FdLmdldENvbnRleHQoIjJkIiksVT1uZXcgUGF0aDJEKHRoaXMuY2xpcFBhdGgpO3cuY2xlYXJSZWN0KDAsMCx0aGlzW3FdLndpZHRoLHRoaXNbcV0uaGVpZ2h0KSx3LnNhdmUoKSx3LnRyYW5zbGF0ZSgtTiwtJCksdy5maWxsU3R5bGU9IndoaXRlIix3LmZpbGwoVSksdy5yZXN0b3JlKCksdGhpc1tnXS5jbGlwUGF0aD10aGlzW3FdO2NvbnN0IEg9dXQodGhpcy5ib3VuZGluZ0JveCx0aGlzW2ddLnBvc2l0aW9uMCk7dGhpc1tnXS5hdHRyaWJ1dGVzLmFfY2xpcFVWPUh9fWdldFBvaW50QXRMZW5ndGgoTil7cmV0dXJuIE9iamVjdChkLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbYl0sTil9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gT2JqZWN0KGQuZ2V0VG90YWxMZW5ndGgpKHRoaXNbYl0pfWdldCBibGVuZCgpe3JldHVybiB0aGlzW0JdPT1udWxsPyJhdXRvIjp0aGlzW0JdfXNldCBibGVuZChOKXt0aGlzW0JdPU4sdGhpc1tnXSYmKHRoaXNbZ10uZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCl9Z2V0IGJvdW5kaW5nQm94KCl7aWYodGhpc1tnXSYmdGhpc1tnXS5ib3VuZGluZ0JveClyZXR1cm4gdGhpc1tnXS5ib3VuZGluZ0JveDtjb25zdCBOPXRoaXMubWVzaERhdGE7aWYoTil7Y29uc3QgJD1OLnBvc2l0aW9uMDtpZigkLmxlbmd0aClOLmJvdW5kaW5nQm94PWkoKSgkKTtlbHNlIHJldHVybltbMCwwXSxbMCwwXV07cmV0dXJuIE4uYm91bmRpbmdCb3h9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBOPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIE4/Wy41KihOWzBdWzBdK05bMV1bMF0pLC41KihOWzBdWzFdK05bMV1bMV0pXTpbMCwwXX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLnJ1bGU6Im5vbnplcm8ifWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tFXT90aGlzW0VdLmxpbmVXaWR0aDowfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5saW5lQ2FwOiIifWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ubGluZUpvaW46IiJ9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tFXT90aGlzW0VdLm1pdGVyTGltaXQ6MH1nZXQgc3Ryb2tlU3R5bGUoKXtyZXR1cm4gdGhpc1tMXSYmdGhpc1tMXVszXSE9PTA/T2JqZWN0KHMuZGVmYXVsdCkodGhpc1tMXSk6IiJ9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5saW5lRGFzaDpudWxsfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ubGluZURhc2hPZmZzZXQ6MH1nZXQgZmlsbFN0eWxlKCl7cmV0dXJuIHRoaXNbTV0mJnRoaXNbTV1bM10hPT0wP09iamVjdChzLmRlZmF1bHQpKHRoaXNbTV0pOiIifWdldCBncmFkaWVudCgpe3JldHVybiB0aGlzW0ZdfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbUl0udV90ZXhTYW1wbGVyP3tpbWFnZTp0aGlzW1JdLnVfdGV4U2FtcGxlci5faW1nLG9wdGlvbnM6dGhpc1tDXX06bnVsbH1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tCXT09PSEwfHx0aGlzW0JdPT09ITE/dGhpc1tCXTp0aGlzW1hdPDF8fHRoaXNbTF0hPW51bGwmJnRoaXNbTF1bM108MXx8dGhpc1tNXSE9bnVsbCYmdGhpc1tNXVszXTwxfHx0aGlzW1JdLnVfY29sb3JNYXRyaXghPW51bGwmJnRoaXNbUl0udV9jb2xvck1hdHJpeFsxOF08MXx8dGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yIT1udWxsfHx0aGlzLmJlZm9yZVJlbmRlcnx8dGhpcy5hZnRlclJlbmRlcn1nZXQgZmlsdGVyQ2FudmFzKCl7cmV0dXJuL2JsdXJ8ZHJvcC1zaGFkb3d8dXJsLy50ZXN0KHRoaXMuZmlsdGVyKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbR10uam9pbigiICIpfWdldCB0cmFuc2Zvcm1NYXRyaXgoKXtyZXR1cm4gdGhpc1tJXX1nZXQgaW52ZXJ0TWF0cml4KCl7aWYoIXRoaXNbRF0pe2NvbnN0IE49ci5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXNbSV0pO3RoaXNbRF09Tn1yZXR1cm4gdGhpc1tEXX1nZXQgdHJhbnNmb3JtU2NhbGUoKXtjb25zdCBOPXRoaXNbSV07cmV0dXJuIE1hdGgubWF4KE1hdGguaHlwb3QoTlswXSxOWzFdKSxNYXRoLmh5cG90KE5bMl0sTlszXSkpfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW1JdfWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbbnRdfVtfXShOKXtjb25zdCAkPXRoaXNbdHRdLFM9dGhpc1tnXS5wb3NpdGlvbjAsVD1PYmplY3QuZW50cmllcyhOLl9hdHRyaWJ1dGUpO2ZvcihsZXQgdz0wO3c8VC5sZW5ndGg7dysrKXtjb25zdFtVLEhdPVRbd107aWYoVSE9PSJhX2NvbG9yIiYmVSE9PSJhX3NvdXJjZVJlY3QiJiZIIT09Imlnbm9yZWQiKXtjb25zdCBZPSRbVV07aWYoVT09PSJ1diImJiFZKXtjb25zdCBrPXRoaXNbZ10uYm91bmRpbmdCb3h8fGkoKShTKTt0aGlzW2ddLmF0dHJpYnV0ZXNbVV09dXQoayxTKX1lbHNle3RoaXNbZ10uYXR0cmlidXRlc1tVXT1bXTtmb3IobGV0IGs9MDtrPFMubGVuZ3RoO2srKyl7Y29uc3QgcnQ9U1trXTt0aGlzW2ddLmF0dHJpYnV0ZXNbVV0ucHVzaChZP1kocnQsdyxTKTpBcnJheShILnNpemUpLmZpbGwoMCkpfX19fX1nZXQgbWVzaERhdGEoKXtpZih0aGlzLl91cGRhdGVNYXRyaXgmJnRoaXMudHJhbnNmb3JtU2NhbGUvdGhpcy5jb250b3Vycy5zY2FsZT4xLjUmJnRoaXMuYWNjdXJhdGUodGhpcy50cmFuc2Zvcm1TY2FsZSksIXRoaXNbZ10peyF0aGlzW0FdJiYhdGhpc1tFXSYmdGhpcy5zZXRGaWxsKCk7Y29uc3QgTj10aGlzW2JdLCQ9e307aWYoTiYmTi5sZW5ndGgpe2lmKHRoaXNbQV0pdHJ5e2NvbnN0IHc9eSgpKE4sdGhpc1tBXSk7dy5wb3NpdGlvbnM9dy5wb3NpdGlvbnMubWFwKFU9PihVLnB1c2godGhpc1tYXSksVSkpLHcuYXR0cmlidXRlcz17YV9jb2xvcjpBcnJheS5mcm9tKHtsZW5ndGg6dy5wb3NpdGlvbnMubGVuZ3RofSkubWFwKCgpPT50aGlzW01dLm1hcChVPT5NYXRoLnJvdW5kKDI1NSpVKSkpfSwkLmZpbGw9d31jYXRjaHt9aWYodGhpc1tFXSl7Y29uc3Qgdz10aGlzW0VdLmxpbmVEYXNoO2xldCBVPU47aWYodyl7Y29uc3QgWT10aGlzW0VdLmxpbmVEYXNoT2Zmc2V0O1U9T2JqZWN0KGQuZ2V0RGFzaENvbnRvdXJzKShOLHcsWSl9Y29uc3QgSD1VLm1hcCgoWSxrKT0+e2NvbnN0IHJ0PVkubGVuZ3RoPjEmJnIudmVjMi5lcXVhbHMoWVswXSxZW1kubGVuZ3RoLTFdKSxpdD10aGlzW0VdLmJ1aWxkKFkscnQpO3JldHVybiB5KCkoW2l0XSl9KTtILmZvckVhY2goWT0+e1kucG9zaXRpb25zPVkucG9zaXRpb25zLm1hcChrPT4oay5wdXNoKC10aGlzW1hdKSxrKSksWS5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpZLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbTF0ubWFwKGs9Pk1hdGgucm91bmQoMjU1KmspKSl9fSksJC5zdHJva2U9T2JqZWN0KGwuZGVmYXVsdCkoSCl9fWNvbnN0IFM9T2JqZWN0KGwuZGVmYXVsdCkoWyQuZmlsbCwkLnN0cm9rZV0pO1MuZmlsbFBvaW50Q291bnQ9JC5maWxsPyQuZmlsbC5wb3NpdGlvbnMubGVuZ3RoOjAsUy5lbmFibGVCbGVuZD10aGlzLmVuYWJsZUJsZW5kLFMucG9zaXRpb24wPVMucG9zaXRpb25zLm1hcCgoW3csVSxIXSk9Plt3LFUsSF0pLFMudW5pZm9ybXM9dGhpc1tSXSx0aGlzW2ddPVMsdGhpc1tSXS51X3RleFNhbXBsZXImJnRoaXNbel0oUyx0aGlzW0NdKTtjb25zdCBUPXRoaXNbSV07T2JqZWN0KHYuaXNVbml0VHJhbnNmb3JtKShUKXx8KHRoaXNbS10oUyxUKSx0aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3ImJnRoaXNbUV0oKSksdGhpcy5jbGlwUGF0aCYmdGhpc1todF0oKSx0aGlzW1pdJiZ0aGlzW19dKHRoaXNbWl0pfXJldHVybiB0aGlzLl91cGRhdGVNYXRyaXgmJih0aGlzW2ddLm1hdHJpeD10aGlzW0ldLHRoaXNbS10odGhpc1tnXSx0aGlzW0ldKSx0aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3ImJnRoaXNbUV0oKSksdGhpc1tnXX1bS10oTiwkKXtjb25zdHtwb3NpdGlvbnM6Uyxwb3NpdGlvbjA6VH09Tjtmb3IobGV0IHc9MDt3PFMubGVuZ3RoO3crKyl7Y29uc3RbVSxIXT1UW3ddLFk9U1t3XTtZWzBdPVUqJFswXStIKiRbMl0rJFs0XSxZWzFdPVUqJFsxXStIKiRbM10rJFs1XX10aGlzLl91cGRhdGVNYXRyaXg9ITF9W1FdKCl7Y29uc3QgTj10aGlzW0ldLCQ9Wy4uLnRoaXMuX3JhZGlhbEdyYWRpZW50VmVjdG9yXTtpZigkKXtjb25zdFtTLFQsLHcsVV09JDskWzBdPVMqTlswXStUKk5bMl0rTls0XSwkWzFdPVMqTlsxXStUKk5bM10rTls1XSwkWzNdPXcqTlswXStVKk5bMl0rTls0XSwkWzRdPXcqTlsxXStVKk5bM10rTls1XSx0aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3I9JH19W3pdKE4sJCl7ZnVuY3Rpb24gUyhrLHJ0KXtyZXR1cm4gaz09bnVsbCYmcnQ9PW51bGw/ITA6az09bnVsbHx8cnQ9PW51bGw/ITE6a1swXT09PXJ0WzBdJiZrWzFdPT09cnRbMV0mJmtbMl09PT1ydFsyXSYma1szXT09PXJ0WzNdfWNvbnN0IFQ9dGhpc1tSXS51X3RleFNhbXBsZXI7aWYoIVQpcmV0dXJuO2NvbnN0e3dpZHRoOncsaGVpZ2h0OlV9PVQuX2ltZyxIPSQuc3JjUmVjdDtsZXQgWT0kLnJlY3R8fFswLDBdO2lmKCQucm90YXRlZCYmKFk9Wy1ZWzFdLFlbMF0sWVszXSxZWzJdXSksWVsyXT09bnVsbCYmKFlbMl09SD9IWzJdOncpLFlbM109PW51bGwmJihZWzNdPUg/SFszXTpVKSwkLmhpZGRlbilOLnRleHR1cmVDb29yZD1OLnBvc2l0aW9ucy5tYXAoKCk9PlstMSwtMSwtMV0pO2Vsc2UgaWYoIU4udGV4dHVyZUNvb3JkfHwhUyh0aGlzW0NdLnJlY3QsJC5yZWN0KXx8dGhpc1tDXS5oaWRkZW4hPT0kLmhpZGRlbnx8dGhpc1tDXS5yb3RhdGVkIT09JC5yb3RhdGVkKXtsZXQgaz1udWxsOyQucm90YXRlZCYmKGs9ci5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCksLjUqTWF0aC5QSSksaz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksayxbMCwtWVsyXV0pKSxOLnRleHR1cmVDb29yZD1OLnBvc2l0aW9uMC5tYXAoKFtydCxpdCxsdF0pPT57aWYoMS9sdD4wKXtpZigkLnJvdGF0ZWQpe2NvbnN0IG90PXJ0KmtbMF0raXQqa1syXStrWzRdLHN0PXJ0KmtbMV0raXQqa1szXStrWzVdO1tydCxpdF09W290LHN0XX1jb25zdCBmdD1qKFtydCxpdF0sW1lbMF0vWVsyXSxZWzFdL1lbM10sWVsyXSxZWzNdXSwkKTtyZXR1cm4gJC5yZXBlYXQmJihmdFsyXT0xKSxmdH1yZXR1cm5bLTEsLTEsLTFdfSl9aWYoSCl7Y29uc3Qgaz1bSFswXS93LEhbMV0vVSxIWzJdL3csSFszXS9VXTtOLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0PU4ucG9zaXRpb25zLm1hcCgoKT0+Wy4uLmtdKX1lbHNlIE4uYXR0cmlidXRlcy5hX3NvdXJjZVJlY3Q9Ti5wb3NpdGlvbnMubWFwKCgpPT5bMCwwLDAsMF0pfWFjY3VyYXRlKE4pe2lmKCF0aGlzLmNvbnRvdXJzKXJldHVybjtpZih0aGlzLmNvbnRvdXJzLnBhdGgpe2NvbnN0IFM9dGhpcy5jb250b3Vycy5zaW1wbGlmeSxUPVcodGhpcy5jb250b3Vycy5wYXRoLDIqTixTKTt0aGlzW2ddPW51bGwsdGhpc1tiXT1UfX1jYW5JZ25vcmUoKXtjb25zdCBOPXRoaXNbRV09PW51bGx8fHRoaXNbRV0ubGluZVdpZHRoPT09MHx8dGhpc1tMXVszXT09PTAsJD10aGlzW0FdPT1udWxsfHx0aGlzW01dWzNdPT09MCxTPXRoaXNbUl0udV9yYWRpYWxHcmFkaWVudFZlY3Rvcj09bnVsbCxUPXRoaXNbUl0udV90ZXhTYW1wbGVyPT1udWxsO3JldHVybiB0aGlzW1hdPT09MHx8dGhpc1taXT09bnVsbCYmTiYmJCYmUyYmVCYmIXRoaXMuYmVmb3JlUmVuZGVyJiYhdGhpcy5hZnRlclJlbmRlcn1zZXRTdHJva2Uoe3RoaWNrbmVzczpOPTEsY2FwOiQ9ImJ1dHQiLGpvaW46Uz0ibWl0ZXIiLG1pdGVyTGltaXQ6VD0xMCxjb2xvcjp3PVswLDAsMCwwXSxsaW5lRGFzaDpVPW51bGwsbGluZURhc2hPZmZzZXQ6SD0wLHJvdW5kU2VnbWVudHM6WT0yMH09e30pe3JldHVybiB0aGlzW2ddPW51bGwsdGhpc1tFXT1uZXcgYS5kZWZhdWx0KHtsaW5lV2lkdGg6TixsaW5lQ2FwOiQsbGluZUpvaW46UyxtaXRlckxpbWl0OlQscm91bmRTZWdtZW50czpZfSksdHlwZW9mIHc9PSJzdHJpbmciJiYodz1PYmplY3QobS5kZWZhdWx0KSh3KSksdGhpc1tMXT13LHRoaXNbRV0ubGluZURhc2g9VSx0aGlzW0VdLmxpbmVEYXNoT2Zmc2V0PUgsdGhpc31zZXRGaWxsKHtydWxlOk49dGhpcy5maWxsUnVsZSxjb2xvcjokPVswLDAsMCwwXX09e30pe3JldHVybiB0aGlzW2ddPW51bGwsdGhpc1tBXT17cnVsZTpOfSx0eXBlb2YgJD09InN0cmluZyImJigkPU9iamVjdChtLmRlZmF1bHQpKCQpKSx0aGlzW01dPSQsdGhpc31zZXRUZXh0dXJlKE4sJD17fSl7aWYoTiYmTi5pbWFnZSl7Y29uc3R7aW1hZ2U6UyxyZWN0OlR9PU47aWYoTj1TLCQucmVjdClmb3IobGV0IHc9MDt3PCQucmVjdC5sZW5ndGg7dysrKVRbd109JC5yZWN0W3ddOyQucmVjdD1UfXJldHVybiB0aGlzW0FdfHx0aGlzLnNldEZpbGwoKSx0aGlzLnNldFVuaWZvcm1zKHt1X3RleFNhbXBsZXI6Tn0pLHRoaXNbZ10mJnRoaXNbel0odGhpc1tnXSwkKSx0aGlzW0NdPSQsdGhpc31zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6JCx0eXBlOlM9ImZpbGwifT17fSl7aWYoTi5sZW5ndGghPT0zKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZWFyR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOiQsdHlwZTpTfSl9c2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczokLHR5cGU6Uz0iZmlsbCJ9PXt9KXtpZihOLmxlbmd0aCE9PTQpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6JCx0eXBlOlN9KX1zZXRSYWRpYWxHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOiQsdHlwZTpTPSJmaWxsIn09e30pe2lmKE4ubGVuZ3RoIT09Nil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHJhZGlhbEdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczokLHR5cGU6U30pfXNldEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6JCx0eXBlOlM9ImZpbGwifT17fSl7JD0kLm1hcCgoe29mZnNldDpVLGNvbG9yOkh9KT0+KHR5cGVvZiBIPT0ic3RyaW5nIiYmKEg9T2JqZWN0KG0uZGVmYXVsdCkoSCkpLHtvZmZzZXQ6VSxjb2xvcjpIfSkpLHRoaXNbRl09dGhpc1tGXXx8e30sdGhpc1tGXVtTXT17dmVjdG9yOk4sY29sb3JzOiR9LCQuc29ydCgoVSxIKT0+VS5vZmZzZXQtSC5vZmZzZXQpO2NvbnN0IFQ9W107JC5mb3JFYWNoKCh7b2Zmc2V0OlUsY29sb3I6SH0pPT57VC5wdXNoKFUsLi4uSCl9KTtsZXQgdztpZihOLmxlbmd0aD09PTQ/dz1bTlswXSxOWzFdLDAsTlsyXSxOWzNdLDBdOnc9Wy4uLk5dLFQubGVuZ3RoPDQwJiZULnB1c2goLTEpLFQubGVuZ3RoPjQwKXRocm93IG5ldyBFcnJvcigiVG9vIG1hbnkgY29sb3JzLCBzaG91bGQgYmUgbGVzcyB0aGFuIDggY29sb3JzIik7cmV0dXJuIHRoaXMuX3JhZGlhbEdyYWRpZW50VmVjdG9yPXcsdGhpc1tSXS51X2NvbG9yU3RlcHM9VCxTPT09ImZpbGwiP3RoaXNbUl0udV9ncmFkaWVudFR5cGU9MTp0aGlzW1JdLnVfZ3JhZGllbnRUeXBlPTAsdGhpc1tRXSgpLHRoaXN9c2V0VW5pZm9ybXMoTj17fSl7cmV0dXJuIE9iamVjdC5hc3NpZ24odGhpc1tSXSxOKSx0aGlzfXNldFRyYW5zZm9ybSguLi5OKXtjb25zdCAkPXRoaXNbSV07cmV0dXJuIHIubWF0MmQuZXF1YWxzKE4sJCl8fCh0aGlzW0ldPU4sZGVsZXRlIHRoaXNbRF0sdGhpcy5fdXBkYXRlTWF0cml4PSEwKSx0aGlzfXRyYW5zZm9ybSguLi5OKXtjb25zdCAkPXRoaXNbSV07cmV0dXJuIHRoaXNbSV09ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksJCxOKSxkZWxldGUgdGhpc1tEXSx0aGlzLl91cGRhdGVNYXRyaXg9ITAsdGhpc310cmFuc2xhdGUoTiwkKXtsZXQgUz1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBTPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxTLFtOLCRdKSx0aGlzLnRyYW5zZm9ybSguLi5TKX1yb3RhdGUoTixbJCxTXT1bMCwwXSl7bGV0IFQ9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gVD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksVCxbJCxTXSksVD1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksVCxOKSxUPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxULFstJCwtU10pLHRoaXMudHJhbnNmb3JtKC4uLlQpfXNjYWxlKE4sJD1OLFtTLFRdPVswLDBdKXtsZXQgdz1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiB3PXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx3LFtTLFRdKSx3PXIubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsW04sJF0pLHc9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsWy1TLC1UXSksdGhpcy50cmFuc2Zvcm0oLi4udyl9c2tldyhOLCQ9TixbUyxUXT1bMCwwXSl7bGV0IHc9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gdz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksdyxbUyxUXSksdz1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx3LHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKCQpLE1hdGgudGFuKE4pLDEsMCwwKSksdz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksdyxbLVMsLVRdKSx0aGlzLnRyYW5zZm9ybSguLi53KX1jbGVhckZpbHRlcigpe3JldHVybiB0aGlzLnNldENvbG9yVHJhbnNmb3JtKG51bGwpLHRoaXNbR10ubGVuZ3RoPTAsdGhpc31zZXRDb2xvclRyYW5zZm9ybSguLi5OKXtyZXR1cm4gTlswXT09PW51bGw/dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjAsdV9jb2xvck1hdHJpeDowfSk6dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjEsdV9jb2xvck1hdHJpeDpOfSksdGhpc310cmFuc2Zvcm1Db2xvciguLi5OKXtsZXQgJD10aGlzLnVuaWZvcm1zLnVfY29sb3JNYXRyaXg7cmV0dXJuICQ/JD1PYmplY3QoZi5tdWx0aXBseSkoJCxOKTokPU4sdGhpcy5zZXRDb2xvclRyYW5zZm9ybSguLi4kKSx0aGlzfWJsdXIoTil7cmV0dXJuIHRoaXNbR10ucHVzaChgYmx1cigke059cHgpYCksdGhpc31icmlnaHRuZXNzKE49MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgYnJpZ2h0bmVzcygkezEwMCpOfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5icmlnaHRuZXNzKShOKSl9Y29udHJhc3QoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBjb250cmFzdCgkezEwMCpOfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5jb250cmFzdCkoTikpfWRyb3BTaGFkb3coTiwkLFM9MCxUPVswLDAsMCwxXSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoVCkmJihUPU9iamVjdChzLmRlZmF1bHQpKFQpKSx0aGlzW0ddLnB1c2goYGRyb3Atc2hhZG93KCR7Tn1weCAkeyR9cHggJHtTfXB4ICR7VH0pYCksdGhpc31ncmF5c2NhbGUoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBncmF5c2NhbGUoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuZ3JheXNjYWxlKShOKSl9aHVlUm90YXRlKE49MCl7cmV0dXJuIHRoaXNbR10ucHVzaChgaHVlLXJvdGF0ZSgke059ZGVnKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuaHVlUm90YXRlKShOKSl9aW52ZXJ0KE49MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgaW52ZXJ0KCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLmludmVydCkoTikpfW9wYWNpdHkoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBvcGFjaXR5KCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLm9wYWNpdHkpKE4pKX1zYXR1cmF0ZShOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYHNhdHVyYXRlKCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLnNhdHVyYXRlKShOKSl9c2VwaWEoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBzZXBpYSgkezEwMCpOfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5zZXBpYSkoTikpfXVybChOKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGB1cmwoJHtOfSlgKSx0aGlzfWlzUG9pbnRDb2xsaXNpb24oTiwkLFM9ImJvdGgiKXtjb25zdCBUPXRoaXMubWVzaERhdGEse3Bvc2l0aW9uczp3LGNlbGxzOlV9PVQsSD10aGlzLmludmVydE1hdHJpeCxZPUhbMF0qTitIWzJdKiQrSFs0XSxrPUhbMV0qTitIWzNdKiQrSFs1XSxydD10aGlzLmJvdW5kaW5nQm94O2lmKFk8cnRbMF1bMF18fFk+cnRbMV1bMF18fGs8cnRbMF1bMV18fGs+cnRbMV1bMV0pcmV0dXJuITE7ZnVuY3Rpb24gaXQoW2x0LGZ0XSxbb3Qsc3RdLFtjdCxtdF0pe2NvbnN0IHZ0PWN0LW90LGd0PW10LXN0LFN0PSgobHQtb3QpKnZ0KyhmdC1zdCkqZ3QpLyh2dCoqMitndCoqMik7cmV0dXJuIFN0Pj0wJiZTdDw9MX1mb3IobGV0IGx0PTA7bHQ8VS5sZW5ndGg7bHQrKyl7Y29uc3QgZnQ9VVtsdF07aWYoUz09PSJmaWxsIiYmZnRbMF0+PVQuZmlsbFBvaW50Q291bnQpYnJlYWs7aWYoUz09PSJzdHJva2UiJiZmdFswXTxULmZpbGxQb2ludENvdW50KWNvbnRpbnVlO2NvbnN0W1tvdCxzdF0sW2N0LG10XSxbdnQsZ3RdXT1mdC5tYXAoVHQ9PndbVHRdKSxTdD1NYXRoLnNpZ24oKE4tb3QpKihtdC1zdCktKGN0LW90KSooJC1zdCkpO2lmKFN0PT09MCYmaXQoW04sJF0sW290LHN0XSxbY3QsbXRdKSlyZXR1cm4hMDtjb25zdCBBdD1NYXRoLnNpZ24oKE4tY3QpKihndC1tdCktKHZ0LWN0KSooJC1tdCkpO2lmKEF0PT09MCYmaXQoW04sJF0sW2N0LG10XSxbdnQsZ3RdKSlyZXR1cm4hMDtjb25zdCBQdD1NYXRoLnNpZ24oKE4tdnQpKihzdC1ndCktKG90LXZ0KSooJC1ndCkpO2lmKFB0PT09MCYmaXQoW04sJF0sW3Z0LGd0XSxbb3Qsc3RdKXx8U3Q9PT0xJiZBdD09PTEmJlB0PT09MXx8U3Q9PT0tMSYmQXQ9PT0tMSYmUHQ9PT0tMSlyZXR1cm4hMH1yZXR1cm4hMX1pc1BvaW50SW5GaWxsKE4sJCl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihOLCQsImZpbGwiKX1pc1BvaW50SW5TdHJva2UoTiwkKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKE4sJCwic3Ryb2tlIil9YWRkUGFzcyhOLCQ9e30pe2xldHt3aWR0aDpTLGhlaWdodDpUfT0kLHc9aCgkLFsid2lkdGgiLCJoZWlnaHQiXSk7Y29uc3QgVT1uZXcgTy5kZWZhdWx0O1UucmVjdCgwLDAsUyxUKTtjb25zdCBIPW5ldyBWKFUse3dpZHRoOlMsaGVpZ2h0OlR9KTtILnNldFVuaWZvcm1zKHcpLEguc2V0UHJvZ3JhbShOKSx0aGlzW250XS5wdXNoKEgpfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSk7dmFyIHI9dCg1OCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1yLlN0cm9rZX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiU3Ryb2tlIixmdW5jdGlvbigpe3JldHVybiB2fSk7dmFyIHI9dCg0OSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49T2JqZWN0KHIuY3JlYXRlKSgpLGk9T2JqZWN0KHIuY3JlYXRlKSgpLGE9T2JqZWN0KHIuY3JlYXRlKSgpLGw9T2JqZWN0KHIuY3JlYXRlKSgpLHM9T2JqZWN0KHIuY3JlYXRlKSgpLGY9MWUyMDtjbGFzcyB2e2NvbnN0cnVjdG9yKHtsaW5lV2lkdGg6eD0xLGxpbmVKb2luOm09Im1pdGVyIixtaXRlckxpbWl0Ok89MTAsbGluZUNhcDpvPSJidXR0Iixyb3VuZFNlZ21lbnRzOmg9MjB9PXt9KXt0aGlzLmxpbmVXaWR0aD14LHRoaXMubGluZUpvaW49bSx0aGlzLm1pdGVyTGltaXQ9Tyx0aGlzLmxpbmVDYXA9byx0aGlzLnJvdW5kU2VnbWVudHM9aCx0aGlzLl9ub3JtYWw9bnVsbH1idWlsZCh4LG09ITEpe2xldCBPPXgubGVuZ3RoO2lmKHg9Wy4uLnhdLE88MilyZXR1cm4geDttJiYoKHhbMF1bMF0hPT14W08tMV1bMF18fHhbMF1bMV0hPT14W08tMV1bMV0pJiZ4LnB1c2goWy4uLnhbMF1dKSx4LnB1c2goWy4uLnhbMV1dKSksTz14Lmxlbmd0aCx0aGlzLl9ub3JtYWw9bnVsbDtjb25zdCBvPXtsZWZ0OltdLHJpZ2h0OltdfSxoPXRoaXMubGluZVdpZHRoLzIsYz10aGlzLmxpbmVDYXA7aWYoIW0mJmM9PT0ic3F1YXJlIil7T2JqZWN0KHIuZGlyZWN0aW9uKShpLHhbMF0seFsxXSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKHhbMF0seFswXSxpLGgpO2NvbnN0IGI9eC5sZW5ndGgtMTtPYmplY3Qoci5kaXJlY3Rpb24pKGkseFtiXSx4W2ItMV0pLE9iamVjdChyLnNjYWxlQW5kQWRkKSh4W2JdLHhbYl0saSxoKX1mb3IobGV0IGI9MTtiPE87YisrKXtjb25zdCBFPXhbYi0xXSxBPXhbYl0sTD14W2IrMV07dGhpcy5fc2VnKG8sRSxBLEwsaCxtKX1yZXR1cm4hbSYmYz09PSJyb3VuZCImJnkobyx0aGlzLnJvdW5kU2VnbWVudHMpLFsuLi5vLmxlZnQsLi4uby5yaWdodC5yZXZlcnNlKCldfV9zZWcoeCxtLE8sbyxoLGMpe2NvbnN0IGc9dGhpcy5saW5lSm9pbj09PSJiZXZlbCIsYj10aGlzLmxpbmVKb2luPT09InJvdW5kIjtpZihPYmplY3Qoci5kaXJlY3Rpb24pKGksTyxtKSx0aGlzLl9ub3JtYWx8fCh0aGlzLl9ub3JtYWw9T2JqZWN0KHIuY3JlYXRlKSgpLE9iamVjdChyLm5vcm1hbCkodGhpcy5fbm9ybWFsLGkpKSx4LmxlZnQubGVuZ3RofHxwKHgsbSx0aGlzLl9ub3JtYWwsaCksIW8pT2JqZWN0KHIubm9ybWFsKSh0aGlzLl9ub3JtYWwsaSksYz9wKHgsbSx0aGlzLl9ub3JtYWwsaCk6cCh4LE8sdGhpcy5fbm9ybWFsLGgpO2Vsc2V7T2JqZWN0KHIuZGlyZWN0aW9uKShhLG8sTyk7bGV0IEU9T2JqZWN0KHIuY29tcHV0ZU1pdGVyKShsLHMsaSxhLGgpO0U9TWF0aC5taW4oRSxmKTtjb25zdCBBPU9iamVjdChyLmRvdCkobCx0aGlzLl9ub3JtYWwpPDA/LTE6MTtsZXQgTD1nfHxiO2lmKCFMJiZ0aGlzLmxpbmVKb2luPT09Im1pdGVyIiYmRS9oPnRoaXMubWl0ZXJMaW1pdCYmKEw9ITApLEwpe09iamVjdChyLnNjYWxlQW5kQWRkKShuLE8sdGhpcy5fbm9ybWFsLC1oKkEpLGQoeCxuLEEpO2xldCBNPTEvMDttJiYoTT1NYXRoLm1pbihNLE1hdGguaHlwb3QoT1swXS1tWzBdLE9bMV0tbVsxXSkpKSxvJiYoTT1NYXRoLm1pbihNLE1hdGguaHlwb3Qob1swXS1PWzBdLG9bMV0tT1sxXSkpKTtjb25zdCBJPU1hdGgubWF4KGgsTWF0aC5taW4oRSxNKSk7aWYoT2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4sTyxzLEkqQSksZCh4LG4sLUEpLG8paWYoT2JqZWN0KHIubm9ybWFsKShuLGEpLE9iamVjdChyLmNvcHkpKHRoaXMuX25vcm1hbCxuKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkobixPLG4sLWgqQSksYil7Y29uc3QgRD1PYmplY3Qoci5jbG9uZSkobiksUj1BPjA/eC5sZWZ0W3gubGVmdC5sZW5ndGgtMV06eC5yaWdodFt4LnJpZ2h0Lmxlbmd0aC0xXSxDPU9iamVjdChyLmNsb25lKShPKSxCPU9iamVjdChyLnN1YikoT2JqZWN0KHIuY3JlYXRlKSgpLFIsQyksej1PYmplY3Qoci5zdWIpKE9iamVjdChyLmNyZWF0ZSkoKSxELEMpLEs9TWF0aC5QSS90aGlzLnJvdW5kU2VnbWVudHM7Zm9yKGxldCBRPTA7UTx0aGlzLnJvdW5kU2VnbWVudHMmJihPYmplY3Qoci5yb3RhdGUpKEIsQixbMCwwXSxBKkspLE1hdGguc2lnbihPYmplY3Qoci5jcm9zcykobixCLHopWzJdKT09PUEpO1ErKylPYmplY3Qoci5hZGQpKG4sQixDKSxkKHgsbixBKTtkKHgsRCxBKX1lbHNlIGQoeCxuLEEpfWVsc2UgcCh4LE8scyxFKSxPYmplY3Qoci5jb3B5KSh0aGlzLl9ub3JtYWwscyl9fX1mdW5jdGlvbiBkKFAseCxtKXttPjA/UC5sZWZ0LnB1c2goT2JqZWN0KHIuY2xvbmUpKHgpKTpQLnJpZ2h0LnB1c2goT2JqZWN0KHIuY2xvbmUpKHgpKX1mdW5jdGlvbiBwKFAseCxtLE8sbz0tMSl7T2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4seCxtLC1PKSxkKFAsbiwtbyksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4seCxtLE8pLGQoUCxuLG8pfWZ1bmN0aW9uIHkoe2xlZnQ6UCxyaWdodDp4fSxtKXtjb25zdCBPPU9iamVjdChyLmNyZWF0ZSkoKSxvPU9iamVjdChyLmNyZWF0ZSkoKTtsZXQgaD1QWzBdLGM9eFswXSxnPVsuNSooaFswXStjWzBdKSwuNSooaFsxXStjWzFdKV07T2JqZWN0KHIuc3ViKShvLGgsZyk7Zm9yKGxldCBiPTE7Yjw9bTtiKyspe2NvbnN0IEU9LTEqTWF0aC5QSSpiL207T2JqZWN0KHIucm90YXRlKShPLG8sWzAsMF0sRSksT2JqZWN0KHIuYWRkKShuLGcsTyksUC51bnNoaWZ0KE9iamVjdChyLmNsb25lKShuKSl9aD14W3gubGVuZ3RoLTFdLGM9UFtQLmxlbmd0aC0xXSxnPVsuNSooaFswXStjWzBdKSwuNSooaFsxXStjWzFdKV0sT2JqZWN0KHIuc3ViKShvLGgsZyk7Zm9yKGxldCBiPTE7Yjw9bTtiKyspe2NvbnN0IEU9LTEqTWF0aC5QSSpiL207T2JqZWN0KHIucm90YXRlKShPLG8sWzAsMF0sRSksT2JqZWN0KHIuYWRkKShuLGcsTykseC5wdXNoKE9iamVjdChyLmNsb25lKShuKSl9fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiaXNVbml0VHJhbnNmb3JtIixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIobil7cmV0dXJuIG5bMF09PT0xJiZuWzFdPT09MCYmblsyXT09PTAmJm5bM109PT0xJiZuWzRdPT09MCYmbls1XT09PTB9fSxmdW5jdGlvbih1LGUsdCl7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO3ZhciByPXQoNjEpLG49dCg2Mik7dS5leHBvcnRzPWZ1bmN0aW9uKGksYSl7aWYoYT1hfHx7fSxpPWkuZmlsdGVyKGZ1bmN0aW9uKG0pe3JldHVybiBtLmxlbmd0aD4yfSksaS5sZW5ndGg9PT0wKXJldHVybntwb3NpdGlvbnM6W10sY2VsbHM6W119O3R5cGVvZiBhLnZlcnRleFNpemUhPSJudW1iZXIiJiYoYS52ZXJ0ZXhTaXplPWlbMF1bMF0ubGVuZ3RoKSxpPWkubWFwKGZ1bmN0aW9uKG0pe3JldHVybiBtLnJlZHVjZShmdW5jdGlvbihPLG8pe3JldHVybiBPLmNvbmNhdChvKX0pfSk7Y29uc3QgbD1hLnJ1bGU9PT0iZXZlbm9kZCI/ci5XSU5ESU5HX09ERDpyLldJTkRJTkdfTk9OWkVSTztmb3IodmFyIHM9ci50ZXNzZWxhdGUobih7Y29udG91cnM6aSx3aW5kaW5nUnVsZTpsLGVsZW1lbnRUeXBlOnIuUE9MWUdPTlMscG9seVNpemU6Myx2ZXJ0ZXhTaXplOjJ9LGEpKSxmPVtdLHY9MDt2PHMudmVydGljZXMubGVuZ3RoO3YrPWEudmVydGV4U2l6ZSl7dmFyIGQ9cy52ZXJ0aWNlcy5zbGljZSh2LHYrYS52ZXJ0ZXhTaXplKTtmLnB1c2goZCl9dmFyIHA9W107Zm9yKHY9MDt2PHMuZWxlbWVudHMubGVuZ3RoO3YrPTMpe3ZhciB5PXMuZWxlbWVudHNbdl0sUD1zLmVsZW1lbnRzW3YrMV0seD1zLmVsZW1lbnRzW3YrMl07cC5wdXNoKFt5LFAseF0pfXJldHVybntwb3NpdGlvbnM6ZixjZWxsczpwfX19LGZ1bmN0aW9uKHUsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9e30sbj17fTt1LmV4cG9ydHM9cixyLldJTkRJTkdfT0REPTAsci5XSU5ESU5HX05PTlpFUk89MSxyLldJTkRJTkdfUE9TSVRJVkU9MixyLldJTkRJTkdfTkVHQVRJVkU9MyxyLldJTkRJTkdfQUJTX0dFUV9UV089NCxyLlBPTFlHT05TPTAsci5DT05ORUNURURfUE9MWUdPTlM9MSxyLkJPVU5EQVJZX0NPTlRPVVJTPTIsci50ZXNzZWxhdGU9ZnVuY3Rpb24obyl7Zm9yKHZhciBoPW8uZGVidWd8fCExLGM9bmV3IE8sZz0wO2c8by5jb250b3Vycy5sZW5ndGg7ZysrKWMuYWRkQ29udG91cihvLnZlcnRleFNpemV8fDIsby5jb250b3Vyc1tnXSk7cmV0dXJuIGMudGVzc2VsYXRlKG8ud2luZGluZ1J1bGV8fHIuV0lORElOR19PREQsby5lbGVtZW50VHlwZXx8ci5QT0xZR09OUyxvLnBvbHlTaXplfHwzLG8udmVydGV4U2l6ZXx8MixvLm5vcm1hbHx8WzAsMCwxXSkse3ZlcnRpY2VzOmMudmVydGljZXMsdmVydGV4SW5kaWNlczpjLnZlcnRleEluZGljZXMsdmVydGV4Q291bnQ6Yy52ZXJ0ZXhDb3VudCxlbGVtZW50czpjLmVsZW1lbnRzLGVsZW1lbnRDb3VudDpjLmVsZW1lbnRDb3VudCxtZXNoOmg/Yy5tZXNoOnZvaWQgMH19O3ZhciBpPWZ1bmN0aW9uKG8pe2lmKCFvKXRocm93IkFzc2VydGlvbiBGYWlsZWQhIn07ZnVuY3Rpb24gYSgpe3RoaXMubmV4dD1udWxsLHRoaXMucHJldj1udWxsLHRoaXMuYW5FZGdlPW51bGwsdGhpcy5jb29yZHM9WzAsMCwwXSx0aGlzLnM9MCx0aGlzLnQ9MCx0aGlzLnBxSGFuZGxlPTAsdGhpcy5uPTAsdGhpcy5pZHg9MH1mdW5jdGlvbiBsKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLnRyYWlsPW51bGwsdGhpcy5uPTAsdGhpcy5tYXJrZWQ9ITEsdGhpcy5pbnNpZGU9ITF9ZnVuY3Rpb24gcyhvKXt0aGlzLm5leHQ9bnVsbCx0aGlzLlN5bT1udWxsLHRoaXMuT25leHQ9bnVsbCx0aGlzLkxuZXh0PW51bGwsdGhpcy5Pcmc9bnVsbCx0aGlzLkxmYWNlPW51bGwsdGhpcy5hY3RpdmVSZWdpb249bnVsbCx0aGlzLndpbmRpbmc9MCx0aGlzLnNpZGU9b31zLnByb3RvdHlwZT17Z2V0IFJmYWNlKCl7cmV0dXJuIHRoaXMuU3ltLkxmYWNlfSxzZXQgUmZhY2Uobyl7dGhpcy5TeW0uTGZhY2U9b30sZ2V0IERzdCgpe3JldHVybiB0aGlzLlN5bS5Pcmd9LHNldCBEc3Qobyl7dGhpcy5TeW0uT3JnPW99LGdldCBPcHJldigpe3JldHVybiB0aGlzLlN5bS5MbmV4dH0sc2V0IE9wcmV2KG8pe3RoaXMuU3ltLkxuZXh0PW99LGdldCBMcHJldigpe3JldHVybiB0aGlzLk9uZXh0LlN5bX0sc2V0IExwcmV2KG8pe3RoaXMuT25leHQuU3ltPW99LGdldCBEcHJldigpe3JldHVybiB0aGlzLkxuZXh0LlN5bX0sc2V0IERwcmV2KG8pe3RoaXMuTG5leHQuU3ltPW99LGdldCBScHJldigpe3JldHVybiB0aGlzLlN5bS5PbmV4dH0sc2V0IFJwcmV2KG8pe3RoaXMuU3ltLk9uZXh0PW99LGdldCBEbmV4dCgpe3JldHVybiB0aGlzLlN5bS5PbmV4dC5TeW19LHNldCBEbmV4dChvKXt0aGlzLlN5bS5PbmV4dC5TeW09b30sZ2V0IFJuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0LlN5bX0sc2V0IFJuZXh0KG8pe3RoaXMuU3ltLkxuZXh0LlN5bT1vfX07ZnVuY3Rpb24gZigpe3ZhciBvPW5ldyBhLGg9bmV3IGwsYz1uZXcgcygwKSxnPW5ldyBzKDEpO28ubmV4dD1vLnByZXY9byxvLmFuRWRnZT1udWxsLGgubmV4dD1oLnByZXY9aCxoLmFuRWRnZT1udWxsLGgudHJhaWw9bnVsbCxoLm1hcmtlZD0hMSxoLmluc2lkZT0hMSxjLm5leHQ9YyxjLlN5bT1nLGMuT25leHQ9bnVsbCxjLkxuZXh0PW51bGwsYy5Pcmc9bnVsbCxjLkxmYWNlPW51bGwsYy53aW5kaW5nPTAsYy5hY3RpdmVSZWdpb249bnVsbCxnLm5leHQ9ZyxnLlN5bT1jLGcuT25leHQ9bnVsbCxnLkxuZXh0PW51bGwsZy5Pcmc9bnVsbCxnLkxmYWNlPW51bGwsZy53aW5kaW5nPTAsZy5hY3RpdmVSZWdpb249bnVsbCx0aGlzLnZIZWFkPW8sdGhpcy5mSGVhZD1oLHRoaXMuZUhlYWQ9Yyx0aGlzLmVIZWFkU3ltPWd9Zi5wcm90b3R5cGU9e21ha2VFZGdlXzpmdW5jdGlvbihvKXt2YXIgaD1uZXcgcygwKSxjPW5ldyBzKDEpO28uU3ltLnNpZGU8by5zaWRlJiYobz1vLlN5bSk7dmFyIGc9by5TeW0ubmV4dDtyZXR1cm4gYy5uZXh0PWcsZy5TeW0ubmV4dD1oLGgubmV4dD1vLG8uU3ltLm5leHQ9YyxoLlN5bT1jLGguT25leHQ9aCxoLkxuZXh0PWMsaC5Pcmc9bnVsbCxoLkxmYWNlPW51bGwsaC53aW5kaW5nPTAsaC5hY3RpdmVSZWdpb249bnVsbCxjLlN5bT1oLGMuT25leHQ9YyxjLkxuZXh0PWgsYy5Pcmc9bnVsbCxjLkxmYWNlPW51bGwsYy53aW5kaW5nPTAsYy5hY3RpdmVSZWdpb249bnVsbCxofSxzcGxpY2VfOmZ1bmN0aW9uKG8saCl7dmFyIGM9by5PbmV4dCxnPWguT25leHQ7Yy5TeW0uTG5leHQ9aCxnLlN5bS5MbmV4dD1vLG8uT25leHQ9ZyxoLk9uZXh0PWN9LG1ha2VWZXJ0ZXhfOmZ1bmN0aW9uKG8saCxjKXt2YXIgZz1vO2koZyE9PW51bGwpO3ZhciBiPWMucHJldjtnLnByZXY9YixiLm5leHQ9ZyxnLm5leHQ9YyxjLnByZXY9ZyxnLmFuRWRnZT1oO3ZhciBFPWg7ZG8gRS5Pcmc9ZyxFPUUuT25leHQ7d2hpbGUoRSE9PWgpfSxtYWtlRmFjZV86ZnVuY3Rpb24obyxoLGMpe3ZhciBnPW87aShnIT09bnVsbCk7dmFyIGI9Yy5wcmV2O2cucHJldj1iLGIubmV4dD1nLGcubmV4dD1jLGMucHJldj1nLGcuYW5FZGdlPWgsZy50cmFpbD1udWxsLGcubWFya2VkPSExLGcuaW5zaWRlPWMuaW5zaWRlO3ZhciBFPWg7ZG8gRS5MZmFjZT1nLEU9RS5MbmV4dDt3aGlsZShFIT09aCl9LGtpbGxFZGdlXzpmdW5jdGlvbihvKXtvLlN5bS5zaWRlPG8uc2lkZSYmKG89by5TeW0pO3ZhciBoPW8ubmV4dCxjPW8uU3ltLm5leHQ7aC5TeW0ubmV4dD1jLGMuU3ltLm5leHQ9aH0sa2lsbFZlcnRleF86ZnVuY3Rpb24obyxoKXt2YXIgYz1vLmFuRWRnZSxnPWM7ZG8gZy5Pcmc9aCxnPWcuT25leHQ7d2hpbGUoZyE9PWMpO3ZhciBiPW8ucHJldixFPW8ubmV4dDtFLnByZXY9YixiLm5leHQ9RX0sa2lsbEZhY2VfOmZ1bmN0aW9uKG8saCl7dmFyIGM9by5hbkVkZ2UsZz1jO2RvIGcuTGZhY2U9aCxnPWcuTG5leHQ7d2hpbGUoZyE9PWMpO3ZhciBiPW8ucHJldixFPW8ubmV4dDtFLnByZXY9YixiLm5leHQ9RX0sbWFrZUVkZ2U6ZnVuY3Rpb24oKXt2YXIgbz1uZXcgYSxoPW5ldyBhLGM9bmV3IGwsZz10aGlzLm1ha2VFZGdlXyh0aGlzLmVIZWFkKTtyZXR1cm4gdGhpcy5tYWtlVmVydGV4XyhvLGcsdGhpcy52SGVhZCksdGhpcy5tYWtlVmVydGV4XyhoLGcuU3ltLHRoaXMudkhlYWQpLHRoaXMubWFrZUZhY2VfKGMsZyx0aGlzLmZIZWFkKSxnfSxzcGxpY2U6ZnVuY3Rpb24obyxoKXt2YXIgYz0hMSxnPSExO2lmKG8hPT1oKXtpZihoLk9yZyE9PW8uT3JnJiYoZz0hMCx0aGlzLmtpbGxWZXJ0ZXhfKGguT3JnLG8uT3JnKSksaC5MZmFjZSE9PW8uTGZhY2UmJihjPSEwLHRoaXMua2lsbEZhY2VfKGguTGZhY2Usby5MZmFjZSkpLHRoaXMuc3BsaWNlXyhoLG8pLCFnKXt2YXIgYj1uZXcgYTt0aGlzLm1ha2VWZXJ0ZXhfKGIsaCxvLk9yZyksby5PcmcuYW5FZGdlPW99aWYoIWMpe3ZhciBFPW5ldyBsO3RoaXMubWFrZUZhY2VfKEUsaCxvLkxmYWNlKSxvLkxmYWNlLmFuRWRnZT1vfX19LGRlbGV0ZTpmdW5jdGlvbihvKXt2YXIgaD1vLlN5bSxjPSExO2lmKG8uTGZhY2UhPT1vLlJmYWNlJiYoYz0hMCx0aGlzLmtpbGxGYWNlXyhvLkxmYWNlLG8uUmZhY2UpKSxvLk9uZXh0PT09byl0aGlzLmtpbGxWZXJ0ZXhfKG8uT3JnLG51bGwpO2Vsc2UgaWYoby5SZmFjZS5hbkVkZ2U9by5PcHJldixvLk9yZy5hbkVkZ2U9by5PbmV4dCx0aGlzLnNwbGljZV8obyxvLk9wcmV2KSwhYyl7dmFyIGc9bmV3IGw7dGhpcy5tYWtlRmFjZV8oZyxvLG8uTGZhY2UpfWguT25leHQ9PT1oPyh0aGlzLmtpbGxWZXJ0ZXhfKGguT3JnLG51bGwpLHRoaXMua2lsbEZhY2VfKGguTGZhY2UsbnVsbCkpOihvLkxmYWNlLmFuRWRnZT1oLk9wcmV2LGguT3JnLmFuRWRnZT1oLk9uZXh0LHRoaXMuc3BsaWNlXyhoLGguT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhvKX0sYWRkRWRnZVZlcnRleDpmdW5jdGlvbihvKXt2YXIgaD10aGlzLm1ha2VFZGdlXyhvKSxjPWguU3ltO3RoaXMuc3BsaWNlXyhoLG8uTG5leHQpLGguT3JnPW8uRHN0O3ZhciBnPW5ldyBhO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKGcsYyxoLk9yZyksaC5MZmFjZT1jLkxmYWNlPW8uTGZhY2UsaH0sc3BsaXRFZGdlOmZ1bmN0aW9uKG8saCl7dmFyIGM9dGhpcy5hZGRFZGdlVmVydGV4KG8pLGc9Yy5TeW07cmV0dXJuIHRoaXMuc3BsaWNlXyhvLlN5bSxvLlN5bS5PcHJldiksdGhpcy5zcGxpY2VfKG8uU3ltLGcpLG8uRHN0PWcuT3JnLGcuRHN0LmFuRWRnZT1nLlN5bSxnLlJmYWNlPW8uUmZhY2UsZy53aW5kaW5nPW8ud2luZGluZyxnLlN5bS53aW5kaW5nPW8uU3ltLndpbmRpbmcsZ30sY29ubmVjdDpmdW5jdGlvbihvLGgpe3ZhciBjPSExLGc9dGhpcy5tYWtlRWRnZV8obyksYj1nLlN5bTtpZihoLkxmYWNlIT09by5MZmFjZSYmKGM9ITAsdGhpcy5raWxsRmFjZV8oaC5MZmFjZSxvLkxmYWNlKSksdGhpcy5zcGxpY2VfKGcsby5MbmV4dCksdGhpcy5zcGxpY2VfKGIsaCksZy5Pcmc9by5Ec3QsYi5Pcmc9aC5PcmcsZy5MZmFjZT1iLkxmYWNlPW8uTGZhY2Usby5MZmFjZS5hbkVkZ2U9YiwhYyl7dmFyIEU9bmV3IGw7dGhpcy5tYWtlRmFjZV8oRSxnLG8uTGZhY2UpfXJldHVybiBnfSx6YXBGYWNlOmZ1bmN0aW9uKG8pe3ZhciBoPW8uYW5FZGdlLGMsZyxiLEUsQTtnPWguTG5leHQ7ZG8gYz1nLGc9Yy5MbmV4dCxjLkxmYWNlPW51bGwsYy5SZmFjZT09PW51bGwmJihjLk9uZXh0PT09Yz90aGlzLmtpbGxWZXJ0ZXhfKGMuT3JnLG51bGwpOihjLk9yZy5hbkVkZ2U9Yy5PbmV4dCx0aGlzLnNwbGljZV8oYyxjLk9wcmV2KSksYj1jLlN5bSxiLk9uZXh0PT09Yj90aGlzLmtpbGxWZXJ0ZXhfKGIuT3JnLG51bGwpOihiLk9yZy5hbkVkZ2U9Yi5PbmV4dCx0aGlzLnNwbGljZV8oYixiLk9wcmV2KSksdGhpcy5raWxsRWRnZV8oYykpO3doaWxlKGMhPWgpO0U9by5wcmV2LEE9by5uZXh0LEEucHJldj1FLEUubmV4dD1BfSxjb3VudEZhY2VWZXJ0c186ZnVuY3Rpb24obyl7dmFyIGg9by5hbkVkZ2UsYz0wO2RvIGMrKyxoPWguTG5leHQ7d2hpbGUoaCE9PW8uYW5FZGdlKTtyZXR1cm4gY30sbWVyZ2VDb252ZXhGYWNlczpmdW5jdGlvbihvKXt2YXIgaCxjLGcsYixFLEEsTDtmb3IoaD10aGlzLmZIZWFkLm5leHQ7aCE9PXRoaXMuZkhlYWQ7aD1oLm5leHQpaWYoaC5pbnNpZGUpZm9yKGM9aC5hbkVkZ2UsRT1jLk9yZztnPWMuTG5leHQsYj1jLlN5bSxiJiZiLkxmYWNlJiZiLkxmYWNlLmluc2lkZSYmKEE9dGhpcy5jb3VudEZhY2VWZXJ0c18oaCksTD10aGlzLmNvdW50RmFjZVZlcnRzXyhiLkxmYWNlKSxBK0wtMjw9byYmbi52ZXJ0Q0NXKGMuTHByZXYuT3JnLGMuT3JnLGIuTG5leHQuTG5leHQuT3JnKSYmbi52ZXJ0Q0NXKGIuTHByZXYuT3JnLGIuT3JnLGMuTG5leHQuTG5leHQuT3JnKSYmKGc9Yi5MbmV4dCx0aGlzLmRlbGV0ZShiKSxjPW51bGwsYj1udWxsKSksIShjJiZjLkxuZXh0Lk9yZz09PUUpOyljPWc7cmV0dXJuITB9LGNoZWNrOmZ1bmN0aW9uKCl7dmFyIG89dGhpcy5mSGVhZCxoPXRoaXMudkhlYWQsYz10aGlzLmVIZWFkLGcsYixFLEEsTCxNO2ZvcihiPW8sYj1vOyhnPWIubmV4dCkhPT1vO2I9Zyl7aShnLnByZXY9PT1iKSxMPWcuYW5FZGdlO2RvIGkoTC5TeW0hPT1MKSxpKEwuU3ltLlN5bT09PUwpLGkoTC5MbmV4dC5PbmV4dC5TeW09PT1MKSxpKEwuT25leHQuU3ltLkxuZXh0PT09TCksaShMLkxmYWNlPT09ZyksTD1MLkxuZXh0O3doaWxlKEwhPT1nLmFuRWRnZSl9Zm9yKGkoZy5wcmV2PT09YiYmZy5hbkVkZ2U9PT1udWxsKSxBPWgsQT1oOyhFPUEubmV4dCkhPT1oO0E9RSl7aShFLnByZXY9PT1BKSxMPUUuYW5FZGdlO2RvIGkoTC5TeW0hPT1MKSxpKEwuU3ltLlN5bT09PUwpLGkoTC5MbmV4dC5PbmV4dC5TeW09PT1MKSxpKEwuT25leHQuU3ltLkxuZXh0PT09TCksaShMLk9yZz09PUUpLEw9TC5PbmV4dDt3aGlsZShMIT09RS5hbkVkZ2UpfWZvcihpKEUucHJldj09PUEmJkUuYW5FZGdlPT09bnVsbCksTT1jLE09YzsoTD1NLm5leHQpIT09YztNPUwpaShMLlN5bS5uZXh0PT09TS5TeW0pLGkoTC5TeW0hPT1MKSxpKEwuU3ltLlN5bT09PUwpLGkoTC5PcmchPT1udWxsKSxpKEwuRHN0IT09bnVsbCksaShMLkxuZXh0Lk9uZXh0LlN5bT09PUwpLGkoTC5PbmV4dC5TeW0uTG5leHQ9PT1MKTtpKEwuU3ltLm5leHQ9PT1NLlN5bSYmTC5TeW09PT10aGlzLmVIZWFkU3ltJiZMLlN5bS5TeW09PT1MJiZMLk9yZz09PW51bGwmJkwuRHN0PT09bnVsbCYmTC5MZmFjZT09PW51bGwmJkwuUmZhY2U9PT1udWxsKX19LG4udmVydEVxPWZ1bmN0aW9uKG8saCl7cmV0dXJuIG8ucz09PWgucyYmby50PT09aC50fSxuLnZlcnRMZXE9ZnVuY3Rpb24obyxoKXtyZXR1cm4gby5zPGguc3x8by5zPT09aC5zJiZvLnQ8PWgudH0sbi50cmFuc0xlcT1mdW5jdGlvbihvLGgpe3JldHVybiBvLnQ8aC50fHxvLnQ9PT1oLnQmJm8uczw9aC5zfSxuLmVkZ2VHb2VzTGVmdD1mdW5jdGlvbihvKXtyZXR1cm4gbi52ZXJ0TGVxKG8uRHN0LG8uT3JnKX0sbi5lZGdlR29lc1JpZ2h0PWZ1bmN0aW9uKG8pe3JldHVybiBuLnZlcnRMZXEoby5Pcmcsby5Ec3QpfSxuLnZlcnRMMWRpc3Q9ZnVuY3Rpb24obyxoKXtyZXR1cm4gTWF0aC5hYnMoby5zLWgucykrTWF0aC5hYnMoby50LWgudCl9LG4uZWRnZUV2YWw9ZnVuY3Rpb24obyxoLGMpe2kobi52ZXJ0TGVxKG8saCkmJm4udmVydExlcShoLGMpKTt2YXIgZz1oLnMtby5zLGI9Yy5zLWgucztyZXR1cm4gZytiPjA/ZzxiP2gudC1vLnQrKG8udC1jLnQpKihnLyhnK2IpKTpoLnQtYy50KyhjLnQtby50KSooYi8oZytiKSk6MH0sbi5lZGdlU2lnbj1mdW5jdGlvbihvLGgsYyl7aShuLnZlcnRMZXEobyxoKSYmbi52ZXJ0TGVxKGgsYykpO3ZhciBnPWgucy1vLnMsYj1jLnMtaC5zO3JldHVybiBnK2I+MD8oaC50LWMudCkqZysoaC50LW8udCkqYjowfSxuLnRyYW5zRXZhbD1mdW5jdGlvbihvLGgsYyl7aShuLnRyYW5zTGVxKG8saCkmJm4udHJhbnNMZXEoaCxjKSk7dmFyIGc9aC50LW8udCxiPWMudC1oLnQ7cmV0dXJuIGcrYj4wP2c8Yj9oLnMtby5zKyhvLnMtYy5zKSooZy8oZytiKSk6aC5zLWMucysoYy5zLW8ucykqKGIvKGcrYikpOjB9LG4udHJhbnNTaWduPWZ1bmN0aW9uKG8saCxjKXtpKG4udHJhbnNMZXEobyxoKSYmbi50cmFuc0xlcShoLGMpKTt2YXIgZz1oLnQtby50LGI9Yy50LWgudDtyZXR1cm4gZytiPjA/KGgucy1jLnMpKmcrKGgucy1vLnMpKmI6MH0sbi52ZXJ0Q0NXPWZ1bmN0aW9uKG8saCxjKXtyZXR1cm4gby5zKihoLnQtYy50KStoLnMqKGMudC1vLnQpK2Mucyooby50LWgudCk+PTB9LG4uaW50ZXJwb2xhdGU9ZnVuY3Rpb24obyxoLGMsZyl7cmV0dXJuIG89bzwwPzA6byxjPWM8MD8wOmMsbzw9Yz9jPT09MD8oaCtnKS8yOmgrKGctaCkqKG8vKG8rYykpOmcrKGgtZykqKGMvKG8rYykpfSxuLmludGVyc2VjdD1mdW5jdGlvbihvLGgsYyxnLGIpe3ZhciBFLEEsTDtuLnZlcnRMZXEobyxoKXx8KEw9byxvPWgsaD1MKSxuLnZlcnRMZXEoYyxnKXx8KEw9YyxjPWcsZz1MKSxuLnZlcnRMZXEobyxjKXx8KEw9byxvPWMsYz1MLEw9aCxoPWcsZz1MKSxuLnZlcnRMZXEoYyxoKT9uLnZlcnRMZXEoaCxnKT8oRT1uLmVkZ2VFdmFsKG8sYyxoKSxBPW4uZWRnZUV2YWwoYyxoLGcpLEUrQTwwJiYoRT0tRSxBPS1BKSxiLnM9bi5pbnRlcnBvbGF0ZShFLGMucyxBLGgucykpOihFPW4uZWRnZVNpZ24obyxjLGgpLEE9LW4uZWRnZVNpZ24obyxnLGgpLEUrQTwwJiYoRT0tRSxBPS1BKSxiLnM9bi5pbnRlcnBvbGF0ZShFLGMucyxBLGcucykpOmIucz0oYy5zK2gucykvMixuLnRyYW5zTGVxKG8saCl8fChMPW8sbz1oLGg9TCksbi50cmFuc0xlcShjLGcpfHwoTD1jLGM9ZyxnPUwpLG4udHJhbnNMZXEobyxjKXx8KEw9byxvPWMsYz1MLEw9aCxoPWcsZz1MKSxuLnRyYW5zTGVxKGMsaCk/bi50cmFuc0xlcShoLGcpPyhFPW4udHJhbnNFdmFsKG8sYyxoKSxBPW4udHJhbnNFdmFsKGMsaCxnKSxFK0E8MCYmKEU9LUUsQT0tQSksYi50PW4uaW50ZXJwb2xhdGUoRSxjLnQsQSxoLnQpKTooRT1uLnRyYW5zU2lnbihvLGMsaCksQT0tbi50cmFuc1NpZ24obyxnLGgpLEUrQTwwJiYoRT0tRSxBPS1BKSxiLnQ9bi5pbnRlcnBvbGF0ZShFLGMudCxBLGcudCkpOmIudD0oYy50K2gudCkvMn07ZnVuY3Rpb24gdigpe3RoaXMua2V5PW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGx9ZnVuY3Rpb24gZChvLGgpe3RoaXMuaGVhZD1uZXcgdix0aGlzLmhlYWQubmV4dD10aGlzLmhlYWQsdGhpcy5oZWFkLnByZXY9dGhpcy5oZWFkLHRoaXMuZnJhbWU9byx0aGlzLmxlcT1ofWQucHJvdG90eXBlPXttaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkLm5leHR9LG1heDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQucHJldn0saW5zZXJ0OmZ1bmN0aW9uKG8pe3JldHVybiB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsbyl9LHNlYXJjaDpmdW5jdGlvbihvKXt2YXIgaD10aGlzLmhlYWQ7ZG8gaD1oLm5leHQ7d2hpbGUoaC5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxvLGgua2V5KSk7cmV0dXJuIGh9LGluc2VydEJlZm9yZTpmdW5jdGlvbihvLGgpe2RvIG89by5wcmV2O3doaWxlKG8ua2V5IT09bnVsbCYmIXRoaXMubGVxKHRoaXMuZnJhbWUsby5rZXksaCkpO3ZhciBjPW5ldyB2O3JldHVybiBjLmtleT1oLGMubmV4dD1vLm5leHQsby5uZXh0LnByZXY9YyxjLnByZXY9byxvLm5leHQ9YyxjfSxkZWxldGU6ZnVuY3Rpb24obyl7by5uZXh0LnByZXY9by5wcmV2LG8ucHJldi5uZXh0PW8ubmV4dH19O2Z1bmN0aW9uIHAoKXt0aGlzLmhhbmRsZT1udWxsfWZ1bmN0aW9uIHkoKXt0aGlzLmtleT1udWxsLHRoaXMubm9kZT1udWxsfWZ1bmN0aW9uIFAobyxoKXt0aGlzLnNpemU9MCx0aGlzLm1heD1vLHRoaXMubm9kZXM9W10sdGhpcy5ub2Rlcy5sZW5ndGg9bysxO3ZhciBjO2ZvcihjPTA7Yzx0aGlzLm5vZGVzLmxlbmd0aDtjKyspdGhpcy5ub2Rlc1tjXT1uZXcgcDtmb3IodGhpcy5oYW5kbGVzPVtdLHRoaXMuaGFuZGxlcy5sZW5ndGg9bysxLGM9MDtjPHRoaXMuaGFuZGxlcy5sZW5ndGg7YysrKXRoaXMuaGFuZGxlc1tjXT1uZXcgeTt0aGlzLmluaXRpYWxpemVkPSExLHRoaXMuZnJlZUxpc3Q9MCx0aGlzLmxlcT1oLHRoaXMubm9kZXNbMV0uaGFuZGxlPTEsdGhpcy5oYW5kbGVzWzFdLmtleT1udWxsfVAucHJvdG90eXBlPXtmbG9hdERvd25fOmZ1bmN0aW9uKG8pe3ZhciBoPXRoaXMubm9kZXMsYz10aGlzLmhhbmRsZXMsZyxiLEU7Zm9yKGc9aFtvXS5oYW5kbGU7Oyl7aWYoRT1vPDwxLEU8dGhpcy5zaXplJiZ0aGlzLmxlcShjW2hbRSsxXS5oYW5kbGVdLmtleSxjW2hbRV0uaGFuZGxlXS5rZXkpJiYrK0UsaShFPD10aGlzLm1heCksYj1oW0VdLmhhbmRsZSxFPnRoaXMuc2l6ZXx8dGhpcy5sZXEoY1tnXS5rZXksY1tiXS5rZXkpKXtoW29dLmhhbmRsZT1nLGNbZ10ubm9kZT1vO2JyZWFrfWhbb10uaGFuZGxlPWIsY1tiXS5ub2RlPW8sbz1FfX0sZmxvYXRVcF86ZnVuY3Rpb24obyl7dmFyIGg9dGhpcy5ub2RlcyxjPXRoaXMuaGFuZGxlcyxnLGIsRTtmb3IoZz1oW29dLmhhbmRsZTs7KXtpZihFPW8+PjEsYj1oW0VdLmhhbmRsZSxFPT09MHx8dGhpcy5sZXEoY1tiXS5rZXksY1tnXS5rZXkpKXtoW29dLmhhbmRsZT1nLGNbZ10ubm9kZT1vO2JyZWFrfWhbb10uaGFuZGxlPWIsY1tiXS5ub2RlPW8sbz1FfX0saW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgbz10aGlzLnNpemU7bz49MTstLW8pdGhpcy5mbG9hdERvd25fKG8pO3RoaXMuaW5pdGlhbGl6ZWQ9ITB9LG1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhbmRsZXNbdGhpcy5ub2Rlc1sxXS5oYW5kbGVdLmtleX0saW5zZXJ0OmZ1bmN0aW9uKG8pe3ZhciBoLGM7aWYoaD0rK3RoaXMuc2l6ZSxoKjI+dGhpcy5tYXgpe3RoaXMubWF4Kj0yO3ZhciBnLGI7Zm9yKGI9dGhpcy5ub2Rlcy5sZW5ndGgsdGhpcy5ub2Rlcy5sZW5ndGg9dGhpcy5tYXgrMSxnPWI7Zzx0aGlzLm5vZGVzLmxlbmd0aDtnKyspdGhpcy5ub2Rlc1tnXT1uZXcgcDtmb3IoYj10aGlzLmhhbmRsZXMubGVuZ3RoLHRoaXMuaGFuZGxlcy5sZW5ndGg9dGhpcy5tYXgrMSxnPWI7Zzx0aGlzLmhhbmRsZXMubGVuZ3RoO2crKyl0aGlzLmhhbmRsZXNbZ109bmV3IHl9cmV0dXJuIHRoaXMuZnJlZUxpc3Q9PT0wP2M9aDooYz10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9dGhpcy5oYW5kbGVzW2NdLm5vZGUpLHRoaXMubm9kZXNbaF0uaGFuZGxlPWMsdGhpcy5oYW5kbGVzW2NdLm5vZGU9aCx0aGlzLmhhbmRsZXNbY10ua2V5PW8sdGhpcy5pbml0aWFsaXplZCYmdGhpcy5mbG9hdFVwXyhoKSxjfSxleHRyYWN0TWluOmZ1bmN0aW9uKCl7dmFyIG89dGhpcy5ub2RlcyxoPXRoaXMuaGFuZGxlcyxjPW9bMV0uaGFuZGxlLGc9aFtjXS5rZXk7cmV0dXJuIHRoaXMuc2l6ZT4wJiYob1sxXS5oYW5kbGU9b1t0aGlzLnNpemVdLmhhbmRsZSxoW29bMV0uaGFuZGxlXS5ub2RlPTEsaFtjXS5rZXk9bnVsbCxoW2NdLm5vZGU9dGhpcy5mcmVlTGlzdCx0aGlzLmZyZWVMaXN0PWMsLS10aGlzLnNpemUsdGhpcy5zaXplPjAmJnRoaXMuZmxvYXREb3duXygxKSksZ30sZGVsZXRlOmZ1bmN0aW9uKG8pe3ZhciBoPXRoaXMubm9kZXMsYz10aGlzLmhhbmRsZXMsZztpKG8+PTEmJm88PXRoaXMubWF4JiZjW29dLmtleSE9PW51bGwpLGc9Y1tvXS5ub2RlLGhbZ10uaGFuZGxlPWhbdGhpcy5zaXplXS5oYW5kbGUsY1toW2ddLmhhbmRsZV0ubm9kZT1nLC0tdGhpcy5zaXplLGc8PXRoaXMuc2l6ZSYmKGc8PTF8fHRoaXMubGVxKGNbaFtnPj4xXS5oYW5kbGVdLmtleSxjW2hbZ10uaGFuZGxlXS5rZXkpP3RoaXMuZmxvYXREb3duXyhnKTp0aGlzLmZsb2F0VXBfKGcpKSxjW29dLmtleT1udWxsLGNbb10ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9b319O2Z1bmN0aW9uIHgoKXt0aGlzLmVVcD1udWxsLHRoaXMubm9kZVVwPW51bGwsdGhpcy53aW5kaW5nTnVtYmVyPTAsdGhpcy5pbnNpZGU9ITEsdGhpcy5zZW50aW5lbD0hMSx0aGlzLmRpcnR5PSExLHRoaXMuZml4VXBwZXJFZGdlPSExfXZhciBtPXt9O20ucmVnaW9uQmVsb3c9ZnVuY3Rpb24obyl7cmV0dXJuIG8ubm9kZVVwLnByZXYua2V5fSxtLnJlZ2lvbkFib3ZlPWZ1bmN0aW9uKG8pe3JldHVybiBvLm5vZGVVcC5uZXh0LmtleX0sbS5kZWJ1Z0V2ZW50PWZ1bmN0aW9uKG8pe30sbS5hZGRXaW5kaW5nPWZ1bmN0aW9uKG8saCl7by53aW5kaW5nKz1oLndpbmRpbmcsby5TeW0ud2luZGluZys9aC5TeW0ud2luZGluZ30sbS5lZGdlTGVxPWZ1bmN0aW9uKG8saCxjKXt2YXIgZz1vLmV2ZW50LEEsTCxiPWguZVVwLEU9Yy5lVXA7aWYoYi5Ec3Q9PT1nKXJldHVybiBFLkRzdD09PWc/bi52ZXJ0TGVxKGIuT3JnLEUuT3JnKT9uLmVkZ2VTaWduKEUuRHN0LGIuT3JnLEUuT3JnKTw9MDpuLmVkZ2VTaWduKGIuRHN0LEUuT3JnLGIuT3JnKT49MDpuLmVkZ2VTaWduKEUuRHN0LGcsRS5PcmcpPD0wO2lmKEUuRHN0PT09ZylyZXR1cm4gbi5lZGdlU2lnbihiLkRzdCxnLGIuT3JnKT49MDt2YXIgQT1uLmVkZ2VFdmFsKGIuRHN0LGcsYi5PcmcpLEw9bi5lZGdlRXZhbChFLkRzdCxnLEUuT3JnKTtyZXR1cm4gQT49TH0sbS5kZWxldGVSZWdpb249ZnVuY3Rpb24obyxoKXtoLmZpeFVwcGVyRWRnZSYmaShoLmVVcC53aW5kaW5nPT09MCksaC5lVXAuYWN0aXZlUmVnaW9uPW51bGwsby5kaWN0LmRlbGV0ZShoLm5vZGVVcCl9LG0uZml4VXBwZXJFZGdlPWZ1bmN0aW9uKG8saCxjKXtpKGguZml4VXBwZXJFZGdlKSxvLm1lc2guZGVsZXRlKGguZVVwKSxoLmZpeFVwcGVyRWRnZT0hMSxoLmVVcD1jLGMuYWN0aXZlUmVnaW9uPWh9LG0udG9wTGVmdFJlZ2lvbj1mdW5jdGlvbihvLGgpe3ZhciBjPWguZVVwLk9yZyxnO2RvIGg9bS5yZWdpb25BYm92ZShoKTt3aGlsZShoLmVVcC5Pcmc9PT1jKTtpZihoLmZpeFVwcGVyRWRnZSl7aWYoZz1vLm1lc2guY29ubmVjdChtLnJlZ2lvbkJlbG93KGgpLmVVcC5TeW0saC5lVXAuTG5leHQpLGc9PT1udWxsKXJldHVybiBudWxsO20uZml4VXBwZXJFZGdlKG8saCxnKSxoPW0ucmVnaW9uQWJvdmUoaCl9cmV0dXJuIGh9LG0udG9wUmlnaHRSZWdpb249ZnVuY3Rpb24obyl7dmFyIGg9by5lVXAuRHN0O2RvIG89bS5yZWdpb25BYm92ZShvKTt3aGlsZShvLmVVcC5Ec3Q9PT1oKTtyZXR1cm4gb30sbS5hZGRSZWdpb25CZWxvdz1mdW5jdGlvbihvLGgsYyl7dmFyIGc9bmV3IHg7cmV0dXJuIGcuZVVwPWMsZy5ub2RlVXA9by5kaWN0Lmluc2VydEJlZm9yZShoLm5vZGVVcCxnKSxnLmZpeFVwcGVyRWRnZT0hMSxnLnNlbnRpbmVsPSExLGcuZGlydHk9ITEsYy5hY3RpdmVSZWdpb249ZyxnfSxtLmlzV2luZGluZ0luc2lkZT1mdW5jdGlvbihvLGgpe3N3aXRjaChvLndpbmRpbmdSdWxlKXtjYXNlIHIuV0lORElOR19PREQ6cmV0dXJuKGgmMSkhPT0wO2Nhc2Ugci5XSU5ESU5HX05PTlpFUk86cmV0dXJuIGghPT0wO2Nhc2Ugci5XSU5ESU5HX1BPU0lUSVZFOnJldHVybiBoPjA7Y2FzZSByLldJTkRJTkdfTkVHQVRJVkU6cmV0dXJuIGg8MDtjYXNlIHIuV0lORElOR19BQlNfR0VRX1RXTzpyZXR1cm4gaD49Mnx8aDw9LTJ9cmV0dXJuIGkoITEpLCExfSxtLmNvbXB1dGVXaW5kaW5nPWZ1bmN0aW9uKG8saCl7aC53aW5kaW5nTnVtYmVyPW0ucmVnaW9uQWJvdmUoaCkud2luZGluZ051bWJlcitoLmVVcC53aW5kaW5nLGguaW5zaWRlPW0uaXNXaW5kaW5nSW5zaWRlKG8saC53aW5kaW5nTnVtYmVyKX0sbS5maW5pc2hSZWdpb249ZnVuY3Rpb24obyxoKXt2YXIgYz1oLmVVcCxnPWMuTGZhY2U7Zy5pbnNpZGU9aC5pbnNpZGUsZy5hbkVkZ2U9YyxtLmRlbGV0ZVJlZ2lvbihvLGgpfSxtLmZpbmlzaExlZnRSZWdpb25zPWZ1bmN0aW9uKG8saCxjKXtmb3IodmFyIGcsQSxiPW51bGwsRT1oLEE9aC5lVXA7RSE9PWM7KXtpZihFLmZpeFVwcGVyRWRnZT0hMSxiPW0ucmVnaW9uQmVsb3coRSksZz1iLmVVcCxnLk9yZyE9QS5Pcmcpe2lmKCFiLmZpeFVwcGVyRWRnZSl7bS5maW5pc2hSZWdpb24obyxFKTticmVha31nPW8ubWVzaC5jb25uZWN0KEEuTHByZXYsZy5TeW0pLG0uZml4VXBwZXJFZGdlKG8sYixnKX1BLk9uZXh0IT09ZyYmKG8ubWVzaC5zcGxpY2UoZy5PcHJldixnKSxvLm1lc2guc3BsaWNlKEEsZykpLG0uZmluaXNoUmVnaW9uKG8sRSksQT1iLmVVcCxFPWJ9cmV0dXJuIEF9LG0uYWRkUmlnaHRFZGdlcz1mdW5jdGlvbihvLGgsYyxnLGIsRSl7dmFyIEEsTCxNLEksRD0hMDtNPWM7ZG8gaShuLnZlcnRMZXEoTS5PcmcsTS5Ec3QpKSxtLmFkZFJlZ2lvbkJlbG93KG8saCxNLlN5bSksTT1NLk9uZXh0O3doaWxlKE0hPT1nKTtmb3IoYj09PW51bGwmJihiPW0ucmVnaW9uQmVsb3coaCkuZVVwLlJwcmV2KSxMPWgsST1iO0E9bS5yZWdpb25CZWxvdyhMKSxNPUEuZVVwLlN5bSxNLk9yZz09PUkuT3JnOylNLk9uZXh0IT09SSYmKG8ubWVzaC5zcGxpY2UoTS5PcHJldixNKSxvLm1lc2guc3BsaWNlKEkuT3ByZXYsTSkpLEEud2luZGluZ051bWJlcj1MLndpbmRpbmdOdW1iZXItTS53aW5kaW5nLEEuaW5zaWRlPW0uaXNXaW5kaW5nSW5zaWRlKG8sQS53aW5kaW5nTnVtYmVyKSxMLmRpcnR5PSEwLCFEJiZtLmNoZWNrRm9yUmlnaHRTcGxpY2UobyxMKSYmKG0uYWRkV2luZGluZyhNLEkpLG0uZGVsZXRlUmVnaW9uKG8sTCksby5tZXNoLmRlbGV0ZShJKSksRD0hMSxMPUEsST1NO0wuZGlydHk9ITAsaShMLndpbmRpbmdOdW1iZXItTS53aW5kaW5nPT09QS53aW5kaW5nTnVtYmVyKSxFJiZtLndhbGtEaXJ0eVJlZ2lvbnMobyxMKX0sbS5zcGxpY2VNZXJnZVZlcnRpY2VzPWZ1bmN0aW9uKG8saCxjKXtvLm1lc2guc3BsaWNlKGgsYyl9LG0udmVydGV4V2VpZ2h0cz1mdW5jdGlvbihvLGgsYyl7dmFyIGc9bi52ZXJ0TDFkaXN0KGgsbyksYj1uLnZlcnRMMWRpc3QoYyxvKSxFPS41KmIvKGcrYiksQT0uNSpnLyhnK2IpO28uY29vcmRzWzBdKz1FKmguY29vcmRzWzBdK0EqYy5jb29yZHNbMF0sby5jb29yZHNbMV0rPUUqaC5jb29yZHNbMV0rQSpjLmNvb3Jkc1sxXSxvLmNvb3Jkc1syXSs9RSpoLmNvb3Jkc1syXStBKmMuY29vcmRzWzJdfSxtLmdldEludGVyc2VjdERhdGE9ZnVuY3Rpb24obyxoLGMsZyxiLEUpe2guY29vcmRzWzBdPWguY29vcmRzWzFdPWguY29vcmRzWzJdPTAsaC5pZHg9LTEsbS52ZXJ0ZXhXZWlnaHRzKGgsYyxnKSxtLnZlcnRleFdlaWdodHMoaCxiLEUpfSxtLmNoZWNrRm9yUmlnaHRTcGxpY2U9ZnVuY3Rpb24obyxoKXt2YXIgYz1tLnJlZ2lvbkJlbG93KGgpLGc9aC5lVXAsYj1jLmVVcDtpZihuLnZlcnRMZXEoZy5PcmcsYi5PcmcpKXtpZihuLmVkZ2VTaWduKGIuRHN0LGcuT3JnLGIuT3JnKT4wKXJldHVybiExO24udmVydEVxKGcuT3JnLGIuT3JnKT9nLk9yZyE9PWIuT3JnJiYoby5wcS5kZWxldGUoZy5PcmcucHFIYW5kbGUpLG0uc3BsaWNlTWVyZ2VWZXJ0aWNlcyhvLGIuT3ByZXYsZykpOihvLm1lc2guc3BsaXRFZGdlKGIuU3ltKSxvLm1lc2guc3BsaWNlKGcsYi5PcHJldiksaC5kaXJ0eT1jLmRpcnR5PSEwKX1lbHNle2lmKG4uZWRnZVNpZ24oZy5Ec3QsYi5PcmcsZy5PcmcpPDApcmV0dXJuITE7bS5yZWdpb25BYm92ZShoKS5kaXJ0eT1oLmRpcnR5PSEwLG8ubWVzaC5zcGxpdEVkZ2UoZy5TeW0pLG8ubWVzaC5zcGxpY2UoYi5PcHJldixnKX1yZXR1cm4hMH0sbS5jaGVja0ZvckxlZnRTcGxpY2U9ZnVuY3Rpb24obyxoKXt2YXIgYz1tLnJlZ2lvbkJlbG93KGgpLGc9aC5lVXAsYj1jLmVVcCxFO2lmKGkoIW4udmVydEVxKGcuRHN0LGIuRHN0KSksbi52ZXJ0TGVxKGcuRHN0LGIuRHN0KSl7aWYobi5lZGdlU2lnbihnLkRzdCxiLkRzdCxnLk9yZyk8MClyZXR1cm4hMTttLnJlZ2lvbkFib3ZlKGgpLmRpcnR5PWguZGlydHk9ITAsRT1vLm1lc2guc3BsaXRFZGdlKGcpLG8ubWVzaC5zcGxpY2UoYi5TeW0sRSksRS5MZmFjZS5pbnNpZGU9aC5pbnNpZGV9ZWxzZXtpZihuLmVkZ2VTaWduKGIuRHN0LGcuRHN0LGIuT3JnKT4wKXJldHVybiExO2guZGlydHk9Yy5kaXJ0eT0hMCxFPW8ubWVzaC5zcGxpdEVkZ2UoYiksby5tZXNoLnNwbGljZShnLkxuZXh0LGIuU3ltKSxFLlJmYWNlLmluc2lkZT1oLmluc2lkZX1yZXR1cm4hMH0sbS5jaGVja0ZvckludGVyc2VjdD1mdW5jdGlvbihvLGgpe3ZhciBjPW0ucmVnaW9uQmVsb3coaCksZz1oLmVVcCxiPWMuZVVwLEU9Zy5PcmcsQT1iLk9yZyxMPWcuRHN0LE09Yi5Ec3QsSSxELFI9bmV3IGEsQyxCO2lmKGkoIW4udmVydEVxKE0sTCkpLGkobi5lZGdlU2lnbihMLG8uZXZlbnQsRSk8PTApLGkobi5lZGdlU2lnbihNLG8uZXZlbnQsQSk+PTApLGkoRSE9PW8uZXZlbnQmJkEhPT1vLmV2ZW50KSxpKCFoLmZpeFVwcGVyRWRnZSYmIWMuZml4VXBwZXJFZGdlKSxFPT09QXx8KEk9TWF0aC5taW4oRS50LEwudCksRD1NYXRoLm1heChBLnQsTS50KSxJPkQpKXJldHVybiExO2lmKG4udmVydExlcShFLEEpKXtpZihuLmVkZ2VTaWduKE0sRSxBKT4wKXJldHVybiExfWVsc2UgaWYobi5lZGdlU2lnbihMLEEsRSk8MClyZXR1cm4hMTtyZXR1cm4gbS5kZWJ1Z0V2ZW50KG8pLG4uaW50ZXJzZWN0KEwsRSxNLEEsUiksaShNYXRoLm1pbihFLnQsTC50KTw9Ui50KSxpKFIudDw9TWF0aC5tYXgoQS50LE0udCkpLGkoTWF0aC5taW4oTS5zLEwucyk8PVIucyksaShSLnM8PU1hdGgubWF4KEEucyxFLnMpKSxuLnZlcnRMZXEoUixvLmV2ZW50KSYmKFIucz1vLmV2ZW50LnMsUi50PW8uZXZlbnQudCksQz1uLnZlcnRMZXEoRSxBKT9FOkEsbi52ZXJ0TGVxKEMsUikmJihSLnM9Qy5zLFIudD1DLnQpLG4udmVydEVxKFIsRSl8fG4udmVydEVxKFIsQSk/KG0uY2hlY2tGb3JSaWdodFNwbGljZShvLGgpLCExKTohbi52ZXJ0RXEoTCxvLmV2ZW50KSYmbi5lZGdlU2lnbihMLG8uZXZlbnQsUik+PTB8fCFuLnZlcnRFcShNLG8uZXZlbnQpJiZuLmVkZ2VTaWduKE0sby5ldmVudCxSKTw9MD9NPT09by5ldmVudD8oby5tZXNoLnNwbGl0RWRnZShnLlN5bSksby5tZXNoLnNwbGljZShiLlN5bSxnKSxoPW0udG9wTGVmdFJlZ2lvbihvLGgpLGc9bS5yZWdpb25CZWxvdyhoKS5lVXAsbS5maW5pc2hMZWZ0UmVnaW9ucyhvLG0ucmVnaW9uQmVsb3coaCksYyksbS5hZGRSaWdodEVkZ2VzKG8saCxnLk9wcmV2LGcsZywhMCksITApOkw9PT1vLmV2ZW50PyhvLm1lc2guc3BsaXRFZGdlKGIuU3ltKSxvLm1lc2guc3BsaWNlKGcuTG5leHQsYi5PcHJldiksYz1oLGg9bS50b3BSaWdodFJlZ2lvbihoKSxCPW0ucmVnaW9uQmVsb3coaCkuZVVwLlJwcmV2LGMuZVVwPWIuT3ByZXYsYj1tLmZpbmlzaExlZnRSZWdpb25zKG8sYyxudWxsKSxtLmFkZFJpZ2h0RWRnZXMobyxoLGIuT25leHQsZy5ScHJldixCLCEwKSwhMCk6KG4uZWRnZVNpZ24oTCxvLmV2ZW50LFIpPj0wJiYobS5yZWdpb25BYm92ZShoKS5kaXJ0eT1oLmRpcnR5PSEwLG8ubWVzaC5zcGxpdEVkZ2UoZy5TeW0pLGcuT3JnLnM9by5ldmVudC5zLGcuT3JnLnQ9by5ldmVudC50KSxuLmVkZ2VTaWduKE0sby5ldmVudCxSKTw9MCYmKGguZGlydHk9Yy5kaXJ0eT0hMCxvLm1lc2guc3BsaXRFZGdlKGIuU3ltKSxiLk9yZy5zPW8uZXZlbnQucyxiLk9yZy50PW8uZXZlbnQudCksITEpOihvLm1lc2guc3BsaXRFZGdlKGcuU3ltKSxvLm1lc2guc3BsaXRFZGdlKGIuU3ltKSxvLm1lc2guc3BsaWNlKGIuT3ByZXYsZyksZy5Pcmcucz1SLnMsZy5PcmcudD1SLnQsZy5PcmcucHFIYW5kbGU9by5wcS5pbnNlcnQoZy5PcmcpLG0uZ2V0SW50ZXJzZWN0RGF0YShvLGcuT3JnLEUsTCxBLE0pLG0ucmVnaW9uQWJvdmUoaCkuZGlydHk9aC5kaXJ0eT1jLmRpcnR5PSEwLCExKX0sbS53YWxrRGlydHlSZWdpb25zPWZ1bmN0aW9uKG8saCl7Zm9yKHZhciBjPW0ucmVnaW9uQmVsb3coaCksZyxiOzspe2Zvcig7Yy5kaXJ0eTspaD1jLGM9bS5yZWdpb25CZWxvdyhjKTtpZighaC5kaXJ0eSYmKGM9aCxoPW0ucmVnaW9uQWJvdmUoaCksaD09PW51bGx8fCFoLmRpcnR5KSlyZXR1cm47aWYoaC5kaXJ0eT0hMSxnPWguZVVwLGI9Yy5lVXAsZy5Ec3QhPT1iLkRzdCYmbS5jaGVja0ZvckxlZnRTcGxpY2UobyxoKSYmKGMuZml4VXBwZXJFZGdlPyhtLmRlbGV0ZVJlZ2lvbihvLGMpLG8ubWVzaC5kZWxldGUoYiksYz1tLnJlZ2lvbkJlbG93KGgpLGI9Yy5lVXApOmguZml4VXBwZXJFZGdlJiYobS5kZWxldGVSZWdpb24obyxoKSxvLm1lc2guZGVsZXRlKGcpLGg9bS5yZWdpb25BYm92ZShjKSxnPWguZVVwKSksZy5PcmchPT1iLk9yZylpZihnLkRzdCE9PWIuRHN0JiYhaC5maXhVcHBlckVkZ2UmJiFjLmZpeFVwcGVyRWRnZSYmKGcuRHN0PT09by5ldmVudHx8Yi5Ec3Q9PT1vLmV2ZW50KSl7aWYobS5jaGVja0ZvckludGVyc2VjdChvLGgpKXJldHVybn1lbHNlIG0uY2hlY2tGb3JSaWdodFNwbGljZShvLGgpO2cuT3JnPT09Yi5PcmcmJmcuRHN0PT09Yi5Ec3QmJihtLmFkZFdpbmRpbmcoYixnKSxtLmRlbGV0ZVJlZ2lvbihvLGgpLG8ubWVzaC5kZWxldGUoZyksaD1tLnJlZ2lvbkFib3ZlKGMpKX19LG0uY29ubmVjdFJpZ2h0VmVydGV4PWZ1bmN0aW9uKG8saCxjKXt2YXIgZyxiPWMuT25leHQsRT1tLnJlZ2lvbkJlbG93KGgpLEE9aC5lVXAsTD1FLmVVcCxNPSExO2lmKEEuRHN0IT09TC5Ec3QmJm0uY2hlY2tGb3JJbnRlcnNlY3QobyxoKSxuLnZlcnRFcShBLk9yZyxvLmV2ZW50KSYmKG8ubWVzaC5zcGxpY2UoYi5PcHJldixBKSxoPW0udG9wTGVmdFJlZ2lvbihvLGgpLGI9bS5yZWdpb25CZWxvdyhoKS5lVXAsbS5maW5pc2hMZWZ0UmVnaW9ucyhvLG0ucmVnaW9uQmVsb3coaCksRSksTT0hMCksbi52ZXJ0RXEoTC5Pcmcsby5ldmVudCkmJihvLm1lc2guc3BsaWNlKGMsTC5PcHJldiksYz1tLmZpbmlzaExlZnRSZWdpb25zKG8sRSxudWxsKSxNPSEwKSxNKXttLmFkZFJpZ2h0RWRnZXMobyxoLGMuT25leHQsYixiLCEwKTtyZXR1cm59bi52ZXJ0TGVxKEwuT3JnLEEuT3JnKT9nPUwuT3ByZXY6Zz1BLGc9by5tZXNoLmNvbm5lY3QoYy5McHJldixnKSxtLmFkZFJpZ2h0RWRnZXMobyxoLGcsZy5PbmV4dCxnLk9uZXh0LCExKSxnLlN5bS5hY3RpdmVSZWdpb24uZml4VXBwZXJFZGdlPSEwLG0ud2Fsa0RpcnR5UmVnaW9ucyhvLGgpfSxtLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZT1mdW5jdGlvbihvLGgsYyl7dmFyIGcsYixFLEEsTDtpZihnPWguZVVwLG4udmVydEVxKGcuT3JnLGMpKXtpKCExKSxtLnNwbGljZU1lcmdlVmVydGljZXMobyxnLGMuYW5FZGdlKTtyZXR1cm59aWYoIW4udmVydEVxKGcuRHN0LGMpKXtvLm1lc2guc3BsaXRFZGdlKGcuU3ltKSxoLmZpeFVwcGVyRWRnZSYmKG8ubWVzaC5kZWxldGUoZy5PbmV4dCksaC5maXhVcHBlckVkZ2U9ITEpLG8ubWVzaC5zcGxpY2UoYy5hbkVkZ2UsZyksbS5zd2VlcEV2ZW50KG8sYyk7cmV0dXJufWkoITEpLGg9bS50b3BSaWdodFJlZ2lvbihoKSxMPW0ucmVnaW9uQmVsb3coaCksRT1MLmVVcC5TeW0sYj1BPUUuT25leHQsTC5maXhVcHBlckVkZ2UmJihpKGIhPT1FKSxtLmRlbGV0ZVJlZ2lvbihvLEwpLG8ubWVzaC5kZWxldGUoRSksRT1iLk9wcmV2KSxvLm1lc2guc3BsaWNlKGMuYW5FZGdlLEUpLG4uZWRnZUdvZXNMZWZ0KGIpfHwoYj1udWxsKSxtLmFkZFJpZ2h0RWRnZXMobyxoLEUuT25leHQsQSxiLCEwKX0sbS5jb25uZWN0TGVmdFZlcnRleD1mdW5jdGlvbihvLGgpe3ZhciBjLGcsYixFLEEsTCxNPW5ldyB4O2lmKE0uZVVwPWguYW5FZGdlLlN5bSxjPW8uZGljdC5zZWFyY2goTSkua2V5LGc9bS5yZWdpb25CZWxvdyhjKSwhIWcpe2lmKEU9Yy5lVXAsQT1nLmVVcCxuLmVkZ2VTaWduKEUuRHN0LGgsRS5PcmcpPT09MCl7bS5jb25uZWN0TGVmdERlZ2VuZXJhdGUobyxjLGgpO3JldHVybn1pZihiPW4udmVydExlcShBLkRzdCxFLkRzdCk/YzpnLGMuaW5zaWRlfHxiLmZpeFVwcGVyRWRnZSl7aWYoYj09PWMpTD1vLm1lc2guY29ubmVjdChoLmFuRWRnZS5TeW0sRS5MbmV4dCk7ZWxzZXt2YXIgST1vLm1lc2guY29ubmVjdChBLkRuZXh0LGguYW5FZGdlKTtMPUkuU3ltfWIuZml4VXBwZXJFZGdlP20uZml4VXBwZXJFZGdlKG8sYixMKTptLmNvbXB1dGVXaW5kaW5nKG8sbS5hZGRSZWdpb25CZWxvdyhvLGMsTCkpLG0uc3dlZXBFdmVudChvLGgpfWVsc2UgbS5hZGRSaWdodEVkZ2VzKG8sYyxoLmFuRWRnZSxoLmFuRWRnZSxudWxsLCEwKX19LG0uc3dlZXBFdmVudD1mdW5jdGlvbihvLGgpe28uZXZlbnQ9aCxtLmRlYnVnRXZlbnQobyk7Zm9yKHZhciBjPWguYW5FZGdlO2MuYWN0aXZlUmVnaW9uPT09bnVsbDspaWYoYz1jLk9uZXh0LGM9PT1oLmFuRWRnZSl7bS5jb25uZWN0TGVmdFZlcnRleChvLGgpO3JldHVybn12YXIgZz1tLnRvcExlZnRSZWdpb24obyxjLmFjdGl2ZVJlZ2lvbik7aShnIT09bnVsbCk7dmFyIGI9bS5yZWdpb25CZWxvdyhnKSxFPWIuZVVwLEE9bS5maW5pc2hMZWZ0UmVnaW9ucyhvLGIsbnVsbCk7QS5PbmV4dD09PUU/bS5jb25uZWN0UmlnaHRWZXJ0ZXgobyxnLEEpOm0uYWRkUmlnaHRFZGdlcyhvLGcsQS5PbmV4dCxFLEUsITApfSxtLmFkZFNlbnRpbmVsPWZ1bmN0aW9uKG8saCxjLGcpe3ZhciBiPW5ldyB4LEU9by5tZXNoLm1ha2VFZGdlKCk7RS5Pcmcucz1jLEUuT3JnLnQ9ZyxFLkRzdC5zPWgsRS5Ec3QudD1nLG8uZXZlbnQ9RS5Ec3QsYi5lVXA9RSxiLndpbmRpbmdOdW1iZXI9MCxiLmluc2lkZT0hMSxiLmZpeFVwcGVyRWRnZT0hMSxiLnNlbnRpbmVsPSEwLGIuZGlydHk9ITEsYi5ub2RlVXA9by5kaWN0Lmluc2VydChiKX0sbS5pbml0RWRnZURpY3Q9ZnVuY3Rpb24obyl7by5kaWN0PW5ldyBkKG8sbS5lZGdlTGVxKTt2YXIgaD1vLmJtYXhbMF0tby5ibWluWzBdLGM9by5ibWF4WzFdLW8uYm1pblsxXSxnPW8uYm1pblswXS1oLGI9by5ibWF4WzBdK2gsRT1vLmJtaW5bMV0tYyxBPW8uYm1heFsxXStjO20uYWRkU2VudGluZWwobyxnLGIsRSksbS5hZGRTZW50aW5lbChvLGcsYixBKX0sbS5kb25lRWRnZURpY3Q9ZnVuY3Rpb24obyl7Zm9yKHZhciBoLGM9MDsoaD1vLmRpY3QubWluKCkua2V5KSE9PW51bGw7KWguc2VudGluZWx8fChpKGguZml4VXBwZXJFZGdlKSxpKCsrYz09PTEpKSxpKGgud2luZGluZ051bWJlcj09PTApLG0uZGVsZXRlUmVnaW9uKG8saCl9LG0ucmVtb3ZlRGVnZW5lcmF0ZUVkZ2VzPWZ1bmN0aW9uKG8pe3ZhciBoLGMsZyxiPW8ubWVzaC5lSGVhZDtmb3IoaD1iLm5leHQ7aCE9PWI7aD1jKWM9aC5uZXh0LGc9aC5MbmV4dCxuLnZlcnRFcShoLk9yZyxoLkRzdCkmJmguTG5leHQuTG5leHQhPT1oJiYobS5zcGxpY2VNZXJnZVZlcnRpY2VzKG8sZyxoKSxvLm1lc2guZGVsZXRlKGgpLGg9ZyxnPWguTG5leHQpLGcuTG5leHQ9PT1oJiYoZyE9PWgmJigoZz09PWN8fGc9PT1jLlN5bSkmJihjPWMubmV4dCksby5tZXNoLmRlbGV0ZShnKSksKGg9PT1jfHxoPT09Yy5TeW0pJiYoYz1jLm5leHQpLG8ubWVzaC5kZWxldGUoaCkpfSxtLmluaXRQcmlvcml0eVE9ZnVuY3Rpb24obyl7dmFyIGgsYyxnLGI9MDtmb3IoZz1vLm1lc2gudkhlYWQsYz1nLm5leHQ7YyE9PWc7Yz1jLm5leHQpYisrO2ZvcihiKz04LGg9by5wcT1uZXcgUChiLG4udmVydExlcSksZz1vLm1lc2gudkhlYWQsYz1nLm5leHQ7YyE9PWc7Yz1jLm5leHQpYy5wcUhhbmRsZT1oLmluc2VydChjKTtyZXR1cm4gYyE9PWc/ITE6KGguaW5pdCgpLCEwKX0sbS5kb25lUHJpb3JpdHlRPWZ1bmN0aW9uKG8pe28ucHE9bnVsbH0sbS5yZW1vdmVEZWdlbmVyYXRlRmFjZXM9ZnVuY3Rpb24obyxoKXt2YXIgYyxnLGI7Zm9yKGM9aC5mSGVhZC5uZXh0O2MhPT1oLmZIZWFkO2M9ZylnPWMubmV4dCxiPWMuYW5FZGdlLGkoYi5MbmV4dCE9PWIpLGIuTG5leHQuTG5leHQ9PT1iJiYobS5hZGRXaW5kaW5nKGIuT25leHQsYiksby5tZXNoLmRlbGV0ZShiKSk7cmV0dXJuITB9LG0uY29tcHV0ZUludGVyaW9yPWZ1bmN0aW9uKG8pe3ZhciBoLGM7aWYobS5yZW1vdmVEZWdlbmVyYXRlRWRnZXMobyksIW0uaW5pdFByaW9yaXR5UShvKSlyZXR1cm4hMTtmb3IobS5pbml0RWRnZURpY3Qobyk7KGg9by5wcS5leHRyYWN0TWluKCkpIT09bnVsbDspe2Zvcig7Yz1vLnBxLm1pbigpLCEoYz09PW51bGx8fCFuLnZlcnRFcShjLGgpKTspYz1vLnBxLmV4dHJhY3RNaW4oKSxtLnNwbGljZU1lcmdlVmVydGljZXMobyxoLmFuRWRnZSxjLmFuRWRnZSk7bS5zd2VlcEV2ZW50KG8saCl9cmV0dXJuIG8uZXZlbnQ9by5kaWN0Lm1pbigpLmtleS5lVXAuT3JnLG0uZGVidWdFdmVudChvKSxtLmRvbmVFZGdlRGljdChvKSxtLmRvbmVQcmlvcml0eVEobyksbS5yZW1vdmVEZWdlbmVyYXRlRmFjZXMobyxvLm1lc2gpPyhvLm1lc2guY2hlY2soKSwhMCk6ITF9O2Z1bmN0aW9uIE8oKXt0aGlzLm1lc2g9bnVsbCx0aGlzLm5vcm1hbD1bMCwwLDBdLHRoaXMuc1VuaXQ9WzAsMCwwXSx0aGlzLnRVbml0PVswLDAsMF0sdGhpcy5ibWluPVswLDBdLHRoaXMuYm1heD1bMCwwXSx0aGlzLndpbmRpbmdSdWxlPXIuV0lORElOR19PREQsdGhpcy5kaWN0PW51bGwsdGhpcy5wcT1udWxsLHRoaXMuZXZlbnQ9bnVsbCx0aGlzLnZlcnRleEluZGV4Q291bnRlcj0wLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudENvdW50PTB9Ty5wcm90b3R5cGU9e2RvdF86ZnVuY3Rpb24obyxoKXtyZXR1cm4gb1swXSpoWzBdK29bMV0qaFsxXStvWzJdKmhbMl19LG5vcm1hbGl6ZV86ZnVuY3Rpb24obyl7dmFyIGg9b1swXSpvWzBdK29bMV0qb1sxXStvWzJdKm9bMl07aShoPjApLGg9TWF0aC5zcXJ0KGgpLG9bMF0vPWgsb1sxXS89aCxvWzJdLz1ofSxsb25nQXhpc186ZnVuY3Rpb24obyl7dmFyIGg9MDtyZXR1cm4gTWF0aC5hYnMob1sxXSk+TWF0aC5hYnMob1swXSkmJihoPTEpLE1hdGguYWJzKG9bMl0pPk1hdGguYWJzKG9baF0pJiYoaD0yKSxofSxjb21wdXRlTm9ybWFsXzpmdW5jdGlvbihvKXt2YXIgaCxjLGcsYixFLEEsTD1bMCwwLDBdLE09WzAsMCwwXSxJPVswLDAsMF0sRD1bMCwwLDBdLFI9WzAsMCwwXSxDPVtudWxsLG51bGwsbnVsbF0sQj1bbnVsbCxudWxsLG51bGxdLHo9dGhpcy5tZXNoLnZIZWFkLEs7Zm9yKGg9ei5uZXh0LEs9MDtLPDM7KytLKWI9aC5jb29yZHNbS10sTVtLXT1iLEJbS109aCxMW0tdPWIsQ1tLXT1oO2ZvcihoPXoubmV4dDtoIT09ejtoPWgubmV4dClmb3IoSz0wO0s8MzsrK0spYj1oLmNvb3Jkc1tLXSxiPE1bS10mJihNW0tdPWIsQltLXT1oKSxiPkxbS10mJihMW0tdPWIsQ1tLXT1oKTtpZihLPTAsTFsxXS1NWzFdPkxbMF0tTVswXSYmKEs9MSksTFsyXS1NWzJdPkxbS10tTVtLXSYmKEs9MiksTVtLXT49TFtLXSl7b1swXT0wLG9bMV09MCxvWzJdPTE7cmV0dXJufWZvcihBPTAsYz1CW0tdLGc9Q1tLXSxJWzBdPWMuY29vcmRzWzBdLWcuY29vcmRzWzBdLElbMV09Yy5jb29yZHNbMV0tZy5jb29yZHNbMV0sSVsyXT1jLmNvb3Jkc1syXS1nLmNvb3Jkc1syXSxoPXoubmV4dDtoIT09ejtoPWgubmV4dClEWzBdPWguY29vcmRzWzBdLWcuY29vcmRzWzBdLERbMV09aC5jb29yZHNbMV0tZy5jb29yZHNbMV0sRFsyXT1oLmNvb3Jkc1syXS1nLmNvb3Jkc1syXSxSWzBdPUlbMV0qRFsyXS1JWzJdKkRbMV0sUlsxXT1JWzJdKkRbMF0tSVswXSpEWzJdLFJbMl09SVswXSpEWzFdLUlbMV0qRFswXSxFPVJbMF0qUlswXStSWzFdKlJbMV0rUlsyXSpSWzJdLEU+QSYmKEE9RSxvWzBdPVJbMF0sb1sxXT1SWzFdLG9bMl09UlsyXSk7QTw9MCYmKG9bMF09b1sxXT1vWzJdPTAsb1t0aGlzLmxvbmdBeGlzXyhJKV09MSl9LGNoZWNrT3JpZW50YXRpb25fOmZ1bmN0aW9uKCl7dmFyIG8saCxjPXRoaXMubWVzaC5mSGVhZCxnLGI9dGhpcy5tZXNoLnZIZWFkLEU7Zm9yKG89MCxoPWMubmV4dDtoIT09YztoPWgubmV4dClpZihFPWguYW5FZGdlLCEoRS53aW5kaW5nPD0wKSlkbyBvKz0oRS5Pcmcucy1FLkRzdC5zKSooRS5PcmcudCtFLkRzdC50KSxFPUUuTG5leHQ7d2hpbGUoRSE9PWguYW5FZGdlKTtpZihvPDApe2ZvcihnPWIubmV4dDtnIT09YjtnPWcubmV4dClnLnQ9LWcudDt0aGlzLnRVbml0WzBdPS10aGlzLnRVbml0WzBdLHRoaXMudFVuaXRbMV09LXRoaXMudFVuaXRbMV0sdGhpcy50VW5pdFsyXT0tdGhpcy50VW5pdFsyXX19LHByb2plY3RQb2x5Z29uXzpmdW5jdGlvbigpe3ZhciBvLGg9dGhpcy5tZXNoLnZIZWFkLGM9WzAsMCwwXSxnLGIsRSxBLEw9ITE7Zm9yKGNbMF09dGhpcy5ub3JtYWxbMF0sY1sxXT10aGlzLm5vcm1hbFsxXSxjWzJdPXRoaXMubm9ybWFsWzJdLGNbMF09PT0wJiZjWzFdPT09MCYmY1syXT09PTAmJih0aGlzLmNvbXB1dGVOb3JtYWxfKGMpLEw9ITApLGc9dGhpcy5zVW5pdCxiPXRoaXMudFVuaXQsRT10aGlzLmxvbmdBeGlzXyhjKSxnW0VdPTAsZ1soRSsxKSUzXT0xLGdbKEUrMiklM109MCxiW0VdPTAsYlsoRSsxKSUzXT0wLGJbKEUrMiklM109Y1tFXT4wPzE6LTEsbz1oLm5leHQ7byE9PWg7bz1vLm5leHQpby5zPXRoaXMuZG90XyhvLmNvb3JkcyxnKSxvLnQ9dGhpcy5kb3RfKG8uY29vcmRzLGIpO2ZvcihMJiZ0aGlzLmNoZWNrT3JpZW50YXRpb25fKCksQT0hMCxvPWgubmV4dDtvIT09aDtvPW8ubmV4dClBPyh0aGlzLmJtaW5bMF09dGhpcy5ibWF4WzBdPW8ucyx0aGlzLmJtaW5bMV09dGhpcy5ibWF4WzFdPW8udCxBPSExKTooby5zPHRoaXMuYm1pblswXSYmKHRoaXMuYm1pblswXT1vLnMpLG8ucz50aGlzLmJtYXhbMF0mJih0aGlzLmJtYXhbMF09by5zKSxvLnQ8dGhpcy5ibWluWzFdJiYodGhpcy5ibWluWzFdPW8udCksby50PnRoaXMuYm1heFsxXSYmKHRoaXMuYm1heFsxXT1vLnQpKX0sYWRkV2luZGluZ186ZnVuY3Rpb24obyxoKXtvLndpbmRpbmcrPWgud2luZGluZyxvLlN5bS53aW5kaW5nKz1oLlN5bS53aW5kaW5nfSx0ZXNzZWxsYXRlTW9ub1JlZ2lvbl86ZnVuY3Rpb24obyxoKXt2YXIgYyxnO2ZvcihjPWguYW5FZGdlLGkoYy5MbmV4dCE9PWMmJmMuTG5leHQuTG5leHQhPT1jKTtuLnZlcnRMZXEoYy5Ec3QsYy5PcmcpO2M9Yy5McHJldik7Zm9yKDtuLnZlcnRMZXEoYy5PcmcsYy5Ec3QpO2M9Yy5MbmV4dCk7Zm9yKGc9Yy5McHJldjtjLkxuZXh0IT09ZzspaWYobi52ZXJ0TGVxKGMuRHN0LGcuT3JnKSl7Zm9yKDtnLkxuZXh0IT09YyYmKG4uZWRnZUdvZXNMZWZ0KGcuTG5leHQpfHxuLmVkZ2VTaWduKGcuT3JnLGcuRHN0LGcuTG5leHQuRHN0KTw9MCk7KXt2YXIgYj1vLmNvbm5lY3QoZy5MbmV4dCxnKTtnPWIuU3ltfWc9Zy5McHJldn1lbHNle2Zvcig7Zy5MbmV4dCE9PWMmJihuLmVkZ2VHb2VzUmlnaHQoYy5McHJldil8fG4uZWRnZVNpZ24oYy5Ec3QsYy5PcmcsYy5McHJldi5PcmcpPj0wKTspe3ZhciBiPW8uY29ubmVjdChjLGMuTHByZXYpO2M9Yi5TeW19Yz1jLkxuZXh0fWZvcihpKGcuTG5leHQhPT1jKTtnLkxuZXh0LkxuZXh0IT09Yzspe3ZhciBiPW8uY29ubmVjdChnLkxuZXh0LGcpO2c9Yi5TeW19cmV0dXJuITB9LHRlc3NlbGxhdGVJbnRlcmlvcl86ZnVuY3Rpb24obyl7dmFyIGgsYztmb3IoaD1vLmZIZWFkLm5leHQ7aCE9PW8uZkhlYWQ7aD1jKWlmKGM9aC5uZXh0LGguaW5zaWRlJiYhdGhpcy50ZXNzZWxsYXRlTW9ub1JlZ2lvbl8obyxoKSlyZXR1cm4hMTtyZXR1cm4hMH0sZGlzY2FyZEV4dGVyaW9yXzpmdW5jdGlvbihvKXt2YXIgaCxjO2ZvcihoPW8uZkhlYWQubmV4dDtoIT09by5mSGVhZDtoPWMpYz1oLm5leHQsaC5pbnNpZGV8fG8uemFwRmFjZShoKX0sc2V0V2luZGluZ051bWJlcl86ZnVuY3Rpb24obyxoLGMpe3ZhciBnLGI7Zm9yKGc9by5lSGVhZC5uZXh0O2chPT1vLmVIZWFkO2c9YiliPWcubmV4dCxnLlJmYWNlLmluc2lkZSE9PWcuTGZhY2UuaW5zaWRlP2cud2luZGluZz1nLkxmYWNlLmluc2lkZT9oOi1oOmM/by5kZWxldGUoZyk6Zy53aW5kaW5nPTB9LGdldE5laWdoYm91ckZhY2VfOmZ1bmN0aW9uKG8pe3JldHVybiFvLlJmYWNlfHwhby5SZmFjZS5pbnNpZGU/LTE6by5SZmFjZS5ufSxvdXRwdXRQb2x5bWVzaF86ZnVuY3Rpb24obyxoLGMsZyl7dmFyIGIsRSxBLEw9MCxNPTAsSSxEO2ZvcihjPjMmJm8ubWVyZ2VDb252ZXhGYWNlcyhjKSxiPW8udkhlYWQubmV4dDtiIT09by52SGVhZDtiPWIubmV4dCliLm49LTE7Zm9yKEU9by5mSGVhZC5uZXh0O0UhPT1vLmZIZWFkO0U9RS5uZXh0KWlmKEUubj0tMSwhIUUuaW5zaWRlKXtBPUUuYW5FZGdlLEk9MDtkbyBiPUEuT3JnLGIubj09PS0xJiYoYi5uPU0sTSsrKSxJKyssQT1BLkxuZXh0O3doaWxlKEEhPT1FLmFuRWRnZSk7aShJPD1jKSxFLm49TCwrK0x9Zm9yKHRoaXMuZWxlbWVudENvdW50PUwsaD09PXIuQ09OTkVDVEVEX1BPTFlHT05TJiYoTCo9MiksdGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD1MKmMsdGhpcy52ZXJ0ZXhDb3VudD1NLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9TSpnLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPU0sYj1vLnZIZWFkLm5leHQ7YiE9PW8udkhlYWQ7Yj1iLm5leHQpaWYoYi5uIT09LTEpe3ZhciBSPWIubipnO3RoaXMudmVydGljZXNbUiswXT1iLmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW1IrMV09Yi5jb29yZHNbMV0sZz4yJiYodGhpcy52ZXJ0aWNlc1tSKzJdPWIuY29vcmRzWzJdKSx0aGlzLnZlcnRleEluZGljZXNbYi5uXT1iLmlkeH12YXIgQz0wO2ZvcihFPW8uZkhlYWQubmV4dDtFIT09by5mSGVhZDtFPUUubmV4dClpZihFLmluc2lkZSl7QT1FLmFuRWRnZSxJPTA7ZG8gYj1BLk9yZyx0aGlzLmVsZW1lbnRzW0MrK109Yi5uLEkrKyxBPUEuTG5leHQ7d2hpbGUoQSE9PUUuYW5FZGdlKTtmb3IoRD1JO0Q8YzsrK0QpdGhpcy5lbGVtZW50c1tDKytdPS0xO2lmKGg9PT1yLkNPTk5FQ1RFRF9QT0xZR09OUyl7QT1FLmFuRWRnZTtkbyB0aGlzLmVsZW1lbnRzW0MrK109dGhpcy5nZXROZWlnaGJvdXJGYWNlXyhBKSxBPUEuTG5leHQ7d2hpbGUoQSE9PUUuYW5FZGdlKTtmb3IoRD1JO0Q8YzsrK0QpdGhpcy5lbGVtZW50c1tDKytdPS0xfX19LG91dHB1dENvbnRvdXJzXzpmdW5jdGlvbihvLGgpe3ZhciBjLGcsYixFPTAsQT0wO2Zvcih0aGlzLnZlcnRleENvdW50PTAsdGhpcy5lbGVtZW50Q291bnQ9MCxjPW8uZkhlYWQubmV4dDtjIT09by5mSGVhZDtjPWMubmV4dClpZihjLmluc2lkZSl7Yj1nPWMuYW5FZGdlO2RvIHRoaXMudmVydGV4Q291bnQrKyxnPWcuTG5leHQ7d2hpbGUoZyE9PWIpO3RoaXMuZWxlbWVudENvdW50Kyt9dGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD10aGlzLmVsZW1lbnRDb3VudCoyLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudCpoLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPXRoaXMudmVydGV4Q291bnQ7dmFyIEw9MCxNPTAsST0wO2ZvcihFPTAsYz1vLmZIZWFkLm5leHQ7YyE9PW8uZkhlYWQ7Yz1jLm5leHQpaWYoYy5pbnNpZGUpe0E9MCxiPWc9Yy5hbkVkZ2U7ZG8gdGhpcy52ZXJ0aWNlc1tMKytdPWcuT3JnLmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW0wrK109Zy5PcmcuY29vcmRzWzFdLGg+MiYmKHRoaXMudmVydGljZXNbTCsrXT1nLk9yZy5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tNKytdPWcuT3JnLmlkeCxBKyssZz1nLkxuZXh0O3doaWxlKGchPT1iKTt0aGlzLmVsZW1lbnRzW0krK109RSx0aGlzLmVsZW1lbnRzW0krK109QSxFKz1BfX0sYWRkQ29udG91cjpmdW5jdGlvbihvLGgpe3ZhciBjLGc7Zm9yKHRoaXMubWVzaD09PW51bGwmJih0aGlzLm1lc2g9bmV3IGYpLG88MiYmKG89Miksbz4zJiYobz0zKSxjPW51bGwsZz0wO2c8aC5sZW5ndGg7Zys9byljPT09bnVsbD8oYz10aGlzLm1lc2gubWFrZUVkZ2UoKSx0aGlzLm1lc2guc3BsaWNlKGMsYy5TeW0pKToodGhpcy5tZXNoLnNwbGl0RWRnZShjKSxjPWMuTG5leHQpLGMuT3JnLmNvb3Jkc1swXT1oW2crMF0sYy5PcmcuY29vcmRzWzFdPWhbZysxXSxvPjI/Yy5PcmcuY29vcmRzWzJdPWhbZysyXTpjLk9yZy5jb29yZHNbMl09MCxjLk9yZy5pZHg9dGhpcy52ZXJ0ZXhJbmRleENvdW50ZXIrKyxjLndpbmRpbmc9MSxjLlN5bS53aW5kaW5nPS0xfSx0ZXNzZWxhdGU6ZnVuY3Rpb24obyxoLGMsZyxiKXtpZih0aGlzLnZlcnRpY2VzPVtdLHRoaXMuZWxlbWVudHM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsYiYmKHRoaXMubm9ybWFsWzBdPWJbMF0sdGhpcy5ub3JtYWxbMV09YlsxXSx0aGlzLm5vcm1hbFsyXT1iWzJdKSx0aGlzLndpbmRpbmdSdWxlPW8sZzwyJiYoZz0yKSxnPjMmJihnPTMpLCF0aGlzLm1lc2gpcmV0dXJuITE7dGhpcy5wcm9qZWN0UG9seWdvbl8oKSxtLmNvbXB1dGVJbnRlcmlvcih0aGlzKTt2YXIgRT10aGlzLm1lc2g7cmV0dXJuIGg9PT1yLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMuc2V0V2luZGluZ051bWJlcl8oRSwxLCEwKTp0aGlzLnRlc3NlbGxhdGVJbnRlcmlvcl8oRSksRS5jaGVjaygpLGg9PT1yLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMub3V0cHV0Q29udG91cnNfKEUsZyk6dGhpcy5vdXRwdXRQb2x5bWVzaF8oRSxoLGMsZyksITB9fX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9cjt2YXIgdD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHIoKXtmb3IodmFyIG49e30saT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe3ZhciBhPWFyZ3VtZW50c1tpXTtmb3IodmFyIGwgaW4gYSl0LmNhbGwoYSxsKSYmKG5bbF09YVtsXSl9cmV0dXJuIG59fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImFwcGx5U2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImNyZWF0ZUNsb3VkU2hhZGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJhcHBseUNsb3VkU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIHI9dCg2NCksbj10KDY1KSxpPXQoNjYpLGE9dCg2Nyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGw9U3ltYm9sKCJzaGFkZXJzIik7ZnVuY3Rpb24gcyh5KXt5W2xdPVtdO2ZvcihsZXQgUD0wO1A8MTY7UCsrKXtjb25zdCB4PVtdLG09ISEoUCYxKSxPPSEhKFAmMiksbz0hIShQJjQpLGg9ISEoUCY4KTttJiZ4LnB1c2goIiNkZWZpbmUgVEVYVFVSRSAxIiksTyYmeC5wdXNoKCIjZGVmaW5lIEZJTFRFUiAxIiksbyYmeC5wdXNoKCIjZGVmaW5lIEdSQURJRU5UIDEiKSxoJiZ4LnB1c2goIiNkZWZpbmUgQ0xJUFBBVEggMSIpO2NvbnN0IGM9YCR7eC5qb2luKGAKYCl9CmAsZz1bXTttJiZnLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U2FtcGxlcjsiKSxoJiZnLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IikseVtsXVtQXT1bYytnLmpvaW4oYApgKStuLmRlZmF1bHQsYytyLmRlZmF1bHRdfX1mdW5jdGlvbiBmKHkse2hhc1RleHR1cmU6UD0hMSxoYXNGaWx0ZXI6eD0hMSxoYXNHcmFkaWVudDptPSExLGhhc0NsaXBQYXRoOk89ITF9PXt9KXtjb25zdCBvPVB8eDw8MXxtPDwyfE88PDM7bGV0IGg9eVtsXVtvXTtBcnJheS5pc0FycmF5KGgpJiYoaD15LmNyZWF0ZVByb2dyYW0oLi4uaCkseVtsXVtvXT1oKSx5LnByb2dyYW0hPT1oJiZ5LnVzZVByb2dyYW0oaCx7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pfWNvbnN0IHY9W107ZnVuY3Rpb24gZCh5KXtmb3IobGV0IFA9MDtQPDY0O1ArKyl7Y29uc3QgeD1bXSxtPSEhKFAmMSksTz0hIShQJjIpLG89ISEoUCY0KSxoPSEhKFAmOCksYz0hIShQJjE2KSxnPSEhKFAmMzIpO20mJngucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxPJiZ4LnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxvJiZ4LnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLGgmJngucHVzaCgiI2RlZmluZSBDTE9VRENPTE9SIDEiKSxjJiZ4LnB1c2goIiNkZWZpbmUgQ0xPVURGSUxURVIgMSIpLGcmJngucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3QgYj1gJHt4LmpvaW4oYApgKX0KYCxFPVtdO2lmKG0pe0UucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpO2ZvcihsZXQgQT0wO0E8MTI7QSsrKUUucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhGcmFtZSR7QX07YCl9ZyYmRS5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X2NsaXBTYW1wbGVyOyIpLHZbUF09W2IrRS5qb2luKGAKYCkrYS5kZWZhdWx0LGIraS5kZWZhdWx0XX19ZnVuY3Rpb24gcCh5LHtoYXNUZXh0dXJlOlA9ITEsaGFzRmlsdGVyOng9ITEsaGFzR3JhZGllbnQ6bT0hMSxoYXNDbG91ZENvbG9yOk89ITEsaGFzQ2xvdWRGaWx0ZXI6bz0hMSxoYXNDbGlwUGF0aDpoPSExfT17fSl7Y29uc3QgYz1QfHg8PDF8bTw8MnxPPDwzfG88PDR8aDw8NTtsZXQgZz12W2NdO0FycmF5LmlzQXJyYXkoZykmJihnPXkuY3JlYXRlUHJvZ3JhbSguLi5nKSx2W2NdPWcpLHkucHJvZ3JhbSE9PWcmJnkudXNlUHJvZ3JhbShnLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZmlsbENsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9zdHJva2VDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZnJhbWVJbmRleDp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiExfX0pfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX1BvaW50U2l6ZSA9IDEuMDsKCiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwogIHZDb2xvciA9IGFfY29sb3I7CgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgp9YH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKCiNpZmRlZiBURVhUVVJFCnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CnVuaWZvcm0gZmxvYXQgdV9jb2xvclN0ZXBzWzQwXTsKdW5pZm9ybSBpbnQgdV9ncmFkaWVudFR5cGU7Ci8vIHVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIHZlYzQgY29sb3IgPSB2Q29sb3I7CiAgZmxvYXQgb3BhY2l0eSA9IGFicyhmbGFnQmFja2dyb3VuZCk7CgojaWZkZWYgR1JBRElFTlQKICBpZih1X2dyYWRpZW50VHlwZSA+IDAgJiYgZmxhZ0JhY2tncm91bmQgPiAwLjAgfHwgdV9ncmFkaWVudFR5cGUgPT0gMCAmJiBmbGFnQmFja2dyb3VuZCA8PSAwLjApIHsKICAgIGdyYWRpZW50KGNvbG9yLCB2R3JhZGllbnRWZWN0b3IxLCB2R3JhZGllbnRWZWN0b3IyLCB1X2NvbG9yU3RlcHMpOwogIH0KI2VuZGlmCgogIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgIGNvbG9yLmEgKj0gb3BhY2l0eTsKICB9CgojaWZkZWYgVEVYVFVSRQogIGlmKGZsYWdCYWNrZ3JvdW5kID4gMC4wKSB7CiAgICB2ZWMzIHRleENvb3JkID0gdlRleHR1cmVDb29yZDsKCiAgICBpZih0ZXhDb29yZC56ID09IDEuMCkgewogICAgICB0ZXhDb29yZCA9IGZyYWN0KHRleENvb3JkKTsKICAgIH0KCiAgICBpZih0ZXhDb29yZC54IDw9IDEuMCAmJiB0ZXhDb29yZC54ID49IDAuMAogICAgICAmJiB0ZXhDb29yZC55IDw9IDEuMCAmJiB0ZXhDb29yZC55ID49IDAuMCkgewogICAgICBpZih2U291cmNlUmVjdC56ID4gMC4wKSB7CiAgICAgICAgdGV4Q29vcmQueCA9IHZTb3VyY2VSZWN0LnggKyB0ZXhDb29yZC54ICogdlNvdXJjZVJlY3QuejsKICAgICAgICB0ZXhDb29yZC55ID0gMS4wIC0gKHZTb3VyY2VSZWN0LnkgKyAoMS4wIC0gdGV4Q29vcmQueSkgKiB2U291cmNlUmVjdC53KTsKICAgICAgfQogICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICB9CiAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAvLyBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNvbG9yLmEpOwogICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgfQogIH0KI2VuZGlmCgojaWZkZWYgRklMVEVSCiAgaWYodV9maWx0ZXJGbGFnID4gMCkgewogICAgdHJhbnNmb3JtQ29sb3IoY29sb3IsIHVfY29sb3JNYXRyaXgpOwogIH0KI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CmF0dHJpYnV0ZSB2ZWMzIGFfdHJhbnNmb3JtMDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0xOwp1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7CgojaWZkZWYgVEVYVFVSRQphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CmF0dHJpYnV0ZSBmbG9hdCBhX2ZyYW1lSW5kZXg7CnZhcnlpbmcgZmxvYXQgZnJhbWVJbmRleDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMDsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMTsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMzsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkNDsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIENMT1VEQ09MT1IKYXR0cmlidXRlIHZlYzQgYV9maWxsQ2xvdWRDb2xvcjsKYXR0cmlidXRlIHZlYzQgYV9zdHJva2VDbG91ZENvbG9yOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICBtYXQzIG1vZGVsTWF0cml4ID0gbWF0MygKICAgIGFfdHJhbnNmb3JtMC54LCBhX3RyYW5zZm9ybTEueCwgMCwgCiAgICBhX3RyYW5zZm9ybTAueSwgYV90cmFuc2Zvcm0xLnksIDAsCiAgICBhX3RyYW5zZm9ybTAueiwgYV90cmFuc2Zvcm0xLnosIDEKICApOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOwoKI2lmZGVmIEdSQURJRU5UCiAgdmVjMyB2ZzEgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzBdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzFdLCAxLjApOwogIHZlYzMgdmcyID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclszXSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls0XSwgMS4wKTsKICBmbG9hdCBoID0gdV9yZXNvbHV0aW9uLnk7CiAgdmcxLnkgPSBoIC0gdmcxLnk7CiAgdmcyLnkgPSBoIC0gdmcyLnk7CiAgdkdyYWRpZW50VmVjdG9yMSA9IHZlYzModmcxLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzJdKTsKICB2R3JhZGllbnRWZWN0b3IyID0gdmVjMyh2ZzIueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNV0pOwojZW5kaWYKICAKICBmbGFnQmFja2dyb3VuZCA9IGFfdmVydGV4UG9zaXRpb24uejsKCiNpZmRlZiBDTE9VRENPTE9SCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLmEpOwogIH0gZWxzZSB7CiAgICB2Q29sb3IgPSBtaXgoYV9jb2xvciwgYV9zdHJva2VDbG91ZENvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IuYSk7CiAgfQojZWxzZQogIHZDb2xvciA9IGFfY29sb3I7CiNlbmRpZgoKI2lmZGVmIFRFWFRVUkUKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CiAgZnJhbWVJbmRleCA9IGFfZnJhbWVJbmRleDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgY29sb3JDbG91ZDAgPSBhX2NvbG9yQ2xvdWQwOwogIGNvbG9yQ2xvdWQxID0gYV9jb2xvckNsb3VkMTsKICBjb2xvckNsb3VkMiA9IGFfY29sb3JDbG91ZDI7CiAgY29sb3JDbG91ZDMgPSBhX2NvbG9yQ2xvdWQzOwogIGNvbG9yQ2xvdWQ0ID0gYV9jb2xvckNsb3VkNDsKI2VuZGlmCn1gfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgRklMVEVSCnVuaWZvcm0gaW50IHVfZmlsdGVyRmxhZzsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yTWF0cml4WzIwXTsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKdm9pZCB0cmFuc2Zvcm1Db2xvcihpbm91dCB2ZWM0IGNvbG9yLCBpbiBmbG9hdCBjb2xvck1hdHJpeFsyMF0pIHsKICBmbG9hdCByID0gY29sb3IuciwgZyA9IGNvbG9yLmcsIGIgPSBjb2xvci5iLCBhID0gY29sb3IuYTsKICBjb2xvclswXSA9IGNvbG9yTWF0cml4WzBdICogciArIGNvbG9yTWF0cml4WzFdICogZyArIGNvbG9yTWF0cml4WzJdICogYiArIGNvbG9yTWF0cml4WzNdICogYSArIGNvbG9yTWF0cml4WzRdOwogIGNvbG9yWzFdID0gY29sb3JNYXRyaXhbNV0gKiByICsgY29sb3JNYXRyaXhbNl0gKiBnICsgY29sb3JNYXRyaXhbN10gKiBiICsgY29sb3JNYXRyaXhbOF0gKiBhICsgY29sb3JNYXRyaXhbOV07CiAgY29sb3JbMl0gPSBjb2xvck1hdHJpeFsxMF0gKiByICsgY29sb3JNYXRyaXhbMTFdICogZyArIGNvbG9yTWF0cml4WzEyXSAqIGIgKyBjb2xvck1hdHJpeFsxM10gKiBhICsgY29sb3JNYXRyaXhbMTRdOwogIGNvbG9yWzNdID0gY29sb3JNYXRyaXhbMTVdICogciArIGNvbG9yTWF0cml4WzE2XSAqIGcgKyBjb2xvck1hdHJpeFsxN10gKiBiICsgY29sb3JNYXRyaXhbMThdICogYSArIGNvbG9yTWF0cml4WzE5XTsKfQoKI2lmZGVmIENMT1VERklMVEVSCnZvaWQgYnVpbGRDbG91ZENvbG9yKGlub3V0IGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdKSB7CiAgY29sb3JDbG91ZE1hdHJpeFswXSA9IGNvbG9yQ2xvdWQwWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMV0gPSBjb2xvckNsb3VkMVswXTsKICBjb2xvckNsb3VkTWF0cml4WzJdID0gY29sb3JDbG91ZDJbMF07CiAgY29sb3JDbG91ZE1hdHJpeFszXSA9IGNvbG9yQ2xvdWQzWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNF0gPSBjb2xvckNsb3VkNFswXTsKCiAgY29sb3JDbG91ZE1hdHJpeFs1XSA9IGNvbG9yQ2xvdWQwWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNl0gPSBjb2xvckNsb3VkMVsxXTsKICBjb2xvckNsb3VkTWF0cml4WzddID0gY29sb3JDbG91ZDJbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs4XSA9IGNvbG9yQ2xvdWQzWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbOV0gPSBjb2xvckNsb3VkNFsxXTsKCiAgY29sb3JDbG91ZE1hdHJpeFsxMF0gPSBjb2xvckNsb3VkMFsyXTsKICBjb2xvckNsb3VkTWF0cml4WzExXSA9IGNvbG9yQ2xvdWQxWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTJdID0gY29sb3JDbG91ZDJbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxM10gPSBjb2xvckNsb3VkM1syXTsKICBjb2xvckNsb3VkTWF0cml4WzE0XSA9IGNvbG9yQ2xvdWQ0WzJdOwoKICBjb2xvckNsb3VkTWF0cml4WzE1XSA9IGNvbG9yQ2xvdWQwWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTZdID0gY29sb3JDbG91ZDFbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxN10gPSBjb2xvckNsb3VkMlszXTsKICBjb2xvckNsb3VkTWF0cml4WzE4XSA9IGNvbG9yQ2xvdWQzWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTldID0gY29sb3JDbG91ZDRbM107Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIGlmKGZyYW1lSW5kZXggPCAwLjApIHsKICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW50IGluZGV4ID0gaW50KGZsb29yKGNsYW1wKDAuMCwgMTEuMCwgZnJhbWVJbmRleCkpKTsKICAgICAgICB2ZWM0IHRleENvbG9yOwogICAgICAgIGlmKGluZGV4ID09IDApIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTIsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDMpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUzLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA0KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTUsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDYpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU2LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA3KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNywgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTgsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDkpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU5LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTEwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTEsIHRleENvb3JkLnh5KTsKICAgICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgICAgdGV4Q29sb3IuYSAqPSBvcGFjaXR5OwogICAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICAgIH0KICAgICAgICAvLyBjb2xvciA9IG1peChjb2xvciwgdGV4Q29sb3IsIHRleENvbG9yLmEpOwogICAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjbGFtcChjb2xvci5hIC8gbWF4KDAuMDAwMSwgdGV4Q29sb3IuYSksIDAuMCwgMS4wKSk7CiAgICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgICB9CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgogIGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdOwogIGJ1aWxkQ2xvdWRDb2xvcihjb2xvckNsb3VkTWF0cml4KTsKICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgY29sb3JDbG91ZE1hdHJpeCk7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgZmxvYXQgY2xpcCA9IHRleHR1cmUyRCh1X2NsaXBTYW1wbGVyLCB2Q2xpcFVWKS5yOwogIGNvbG9yICo9IGNsaXA7CiNlbmRpZgoKICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsKfWB9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKHIsbil7dC5kKGUsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKCl7aWYodHlwZW9mIHBlcmZvcm1hbmNlPCJ1IiYmcGVyZm9ybWFuY2Uubm93KXJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtpZih0eXBlb2YgcjwidSImJnIuaHJ0aW1lKXtjb25zdFtzLGZdPXIuaHJ0aW1lKCk7cmV0dXJuIHMqMWUzK2YqMWUtNn1yZXR1cm4gRGF0ZS5ub3c/RGF0ZS5ub3coKTpuZXcgRGF0ZSgpLmdldFRpbWUoKX1sZXQgYSxsO3R5cGVvZiBuPCJ1IiYmdHlwZW9mIG4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lPT0iZnVuY3Rpb24iPyhhPW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lLGw9bi5jYW5jZWxBbmltYXRpb25GcmFtZSk6KGE9ZnVuY3Rpb24ocyl7cmV0dXJuIHNldFRpbWVvdXQoKCk9PntzKGkoKSl9LDE2KX0sbD1mdW5jdGlvbihzKXtyZXR1cm4gY2xlYXJUaW1lb3V0KHMpfSl9KS5jYWxsKHRoaXMsdCg2OSksdCgyMikpfSxmdW5jdGlvbih1LGUpe3ZhciB0PXUuZXhwb3J0cz17fSxyLG47ZnVuY3Rpb24gaSgpe3Rocm93IG5ldyBFcnJvcigic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfWZ1bmN0aW9uIGEoKXt0aHJvdyBuZXcgRXJyb3IoImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfShmdW5jdGlvbigpe3RyeXt0eXBlb2Ygc2V0VGltZW91dD09ImZ1bmN0aW9uIj9yPXNldFRpbWVvdXQ6cj1pfWNhdGNoe3I9aX10cnl7dHlwZW9mIGNsZWFyVGltZW91dD09ImZ1bmN0aW9uIj9uPWNsZWFyVGltZW91dDpuPWF9Y2F0Y2h7bj1hfX0pKCk7ZnVuY3Rpb24gbChPKXtpZihyPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dChPLDApO2lmKChyPT09aXx8IXIpJiZzZXRUaW1lb3V0KXJldHVybiByPXNldFRpbWVvdXQsc2V0VGltZW91dChPLDApO3RyeXtyZXR1cm4gcihPLDApfWNhdGNoe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsTywwKX1jYXRjaHtyZXR1cm4gci5jYWxsKHRoaXMsTywwKX19fWZ1bmN0aW9uIHMoTyl7aWYobj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KE8pO2lmKChuPT09YXx8IW4pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG49Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChPKTt0cnl7cmV0dXJuIG4oTyl9Y2F0Y2h7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxPKX1jYXRjaHtyZXR1cm4gbi5jYWxsKHRoaXMsTyl9fX12YXIgZj1bXSx2PSExLGQscD0tMTtmdW5jdGlvbiB5KCl7IXZ8fCFkfHwodj0hMSxkLmxlbmd0aD9mPWQuY29uY2F0KGYpOnA9LTEsZi5sZW5ndGgmJlAoKSl9ZnVuY3Rpb24gUCgpe2lmKCF2KXt2YXIgTz1sKHkpO3Y9ITA7Zm9yKHZhciBvPWYubGVuZ3RoO287KXtmb3IoZD1mLGY9W107KytwPG87KWQmJmRbcF0ucnVuKCk7cD0tMSxvPWYubGVuZ3RofWQ9bnVsbCx2PSExLHMoTyl9fXQubmV4dFRpY2s9ZnVuY3Rpb24oTyl7dmFyIG89bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgaD0xO2g8YXJndW1lbnRzLmxlbmd0aDtoKyspb1toLTFdPWFyZ3VtZW50c1toXTtmLnB1c2gobmV3IHgoTyxvKSksZi5sZW5ndGg9PT0xJiYhdiYmbChQKX07ZnVuY3Rpb24geChPLG8pe3RoaXMuZnVuPU8sdGhpcy5hcnJheT1vfXgucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LHQudGl0bGU9ImJyb3dzZXIiLHQuYnJvd3Nlcj0hMCx0LmVudj17fSx0LmFyZ3Y9W10sdC52ZXJzaW9uPSIiLHQudmVyc2lvbnM9e307ZnVuY3Rpb24gbSgpe310Lm9uPW0sdC5hZGRMaXN0ZW5lcj1tLHQub25jZT1tLHQub2ZmPW0sdC5yZW1vdmVMaXN0ZW5lcj1tLHQucmVtb3ZlQWxsTGlzdGVuZXJzPW0sdC5lbWl0PW0sdC5wcmVwZW5kTGlzdGVuZXI9bSx0LnByZXBlbmRPbmNlTGlzdGVuZXI9bSx0Lmxpc3RlbmVycz1mdW5jdGlvbihPKXtyZXR1cm5bXX0sdC5iaW5kaW5nPWZ1bmN0aW9uKE8pe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm4iLyJ9LHQuY2hkaXI9ZnVuY3Rpb24oTyl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pO3ZhciByPXQoMSksbj10KDcxKSxpPXQoNzMpLGE9dCgyMTMpLGw9dCgyMTQpLHM9dCgyMTUpLGY9dCgyMTYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB2KEwsTSl7dmFyIEk9T2JqZWN0LmtleXMoTCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhMKTtNJiYoRD1ELmZpbHRlcihmdW5jdGlvbihSKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihMLFIpLmVudW1lcmFibGV9KSksSS5wdXNoLmFwcGx5KEksRCl9cmV0dXJuIEl9ZnVuY3Rpb24gZChMKXtmb3IodmFyIE09MTtNPGFyZ3VtZW50cy5sZW5ndGg7TSsrKXt2YXIgST1hcmd1bWVudHNbTV0hPW51bGw/YXJndW1lbnRzW01dOnt9O00lMj92KE9iamVjdChJKSwhMCkuZm9yRWFjaChmdW5jdGlvbihEKXtwKEwsRCxJW0RdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEwsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoSSkpOnYoT2JqZWN0KEkpKS5mb3JFYWNoKGZ1bmN0aW9uKEQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShMLEQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihJLEQpKX0pfXJldHVybiBMfWZ1bmN0aW9uIHAoTCxNLEkpe3JldHVybiBNIGluIEw/T2JqZWN0LmRlZmluZVByb3BlcnR5KEwsTSx7dmFsdWU6SSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOkxbTV09SSxMfWNvbnN0IHk9U3ltYm9sLmZvcigic3ByaXRlanNfY2hhbmdlZEF0dHJzIiksUD1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIikseD1TeW1ib2woInJlc29sdXRpb24iKSxtPVN5bWJvbCgiYW5pbWF0aW9ucyIpLE89U3ltYm9sKCJldmVudExpc3RlbmVycyIpLG89U3ltYm9sKCJjYXB0dXJlRXZlbnRMaXN0ZW5lcnMiKSxoPVN5bWJvbCgiZmlsdGVycyIpLGM9U3ltYm9sKCJkaXNwbGF5IiksZz1TeW1ib2woInByb2dyYW0iKSxiPVN5bWJvbCgic2hhZGVyQXR0cnMiKSxFPVN5bWJvbCgidW5pZm9ybXMiKTtjbGFzcyBBe2NvbnN0cnVjdG9yKE09e30pe3RoaXMuYXR0cmlidXRlcz1uZXcgdGhpcy5jb25zdHJ1Y3Rvci5BdHRyKHRoaXMpLHRoaXNbeF09e3dpZHRoOjMwMCxoZWlnaHQ6MTUwfSxPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxNKSx0aGlzW21dPW5ldyBTZXQsdGhpc1tPXT17fSx0aGlzW29dPXt9fWdldCBhbmNlc3RvcnMoKXtsZXQgTT10aGlzLnBhcmVudDtjb25zdCBJPVtdO2Zvcig7TTspSS5wdXNoKE0pLE09TS5wYXJlbnQ7cmV0dXJuIEl9Z2V0IGFuaW1hdGlvbnMoKXtyZXR1cm4gdGhpc1ttXX1nZXQgZmlsdGVycygpe3JldHVybiB0aGlzW2hdfHx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZmlsdGVyc31nZXQgaXNWaXNpYmxlKCl7cmV0dXJuITF9Z2V0IGxheWVyKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50LmxheWVyOm51bGx9Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3QgTT10aGlzLnRyYW5zZm9ybU1hdHJpeCx7eDpJLHk6RH09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBNWzRdKz1JLE1bNV0rPUQsTX1nZXQgb3BhY2l0eSgpe2xldCBNPXRoaXMuYXR0cmlidXRlcy5vcGFjaXR5O3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3BhY2l0eSE9bnVsbCYmKE0qPXRoaXMucGFyZW50Lm9wYWNpdHkpLE19Z2V0IHBhcmVudE5vZGUoKXtyZXR1cm4gdGhpcy5wYXJlbnR9Z2V0IG5leHRTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgxKX1nZXQgcHJldmlvdXNTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgtMSl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1tnXX1nZXQgcmVuZGVyZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQucmVuZGVyZXI6bnVsbH1nZXQgcmVuZGVyTWF0cml4KCl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4KXJldHVybiB0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg7bGV0IE09dGhpcy5sb2NhbE1hdHJpeDtjb25zdCBJPXRoaXMucGFyZW50O2lmKEkpe2NvbnN0IEQ9SS5fX2NhY2hlUmVuZGVyTWF0cml4fHxJLnJlbmRlck1hdHJpeDtEJiYoTT1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELE0pKX1yZXR1cm4gTX1nZXQgd29ybGRTY2FsaW5nKCl7Y29uc3QgTT10aGlzLnJlbmRlck1hdHJpeDtyZXR1cm5bTWF0aC5oeXBvdChNWzBdLE1bMV0pLE1hdGguaHlwb3QoTVsyXSxNWzNdKV19Z2V0IHdvcmxkUm90YXRpb24oKXtjb25zdCBNPXRoaXMucmVuZGVyTWF0cml4O3JldHVybiBNYXRoLmF0YW4yKE1bMV0sTVszXSl9Z2V0IHdvcmxkUG9zaXRpb24oKXtjb25zdCBNPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltNWzRdLE1bNV1dfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW0VdfWdldCBjbGFzc05hbWUoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZX1zZXQgY2xhc3NOYW1lKE0pe3RoaXMuYXR0cmlidXRlcy5jbGFzc05hbWU9TX1nZXQgaWQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmlkfXNldCBpZChNKXt0aGlzLmF0dHJpYnV0ZXMuaWQ9TX1nZXQgbmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMubmFtZX1zZXQgbmFtZShNKXt0aGlzLmF0dHJpYnV0ZXMubmFtZT1NfWdldCB6SW5kZXgoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnpJbmRleH1zZXQgekluZGV4KE0pe3RoaXMuYXR0cmlidXRlcy56SW5kZXg9TX1nZXQgbWVzaCgpe3JldHVybiBudWxsfWdldCBzaGFkZXJBdHRycygpe3JldHVybiB0aGlzW2JdfHx7fX1hY3RpdmF0ZUFuaW1hdGlvbnMoKXtjb25zdCBNPXRoaXMubGF5ZXI7aWYoTSl7Y29uc3QgST10aGlzW21dO0kuZm9yRWFjaChSPT57Ui5iYXNlVGltZWxpbmU9TS50aW1lbGluZSxSLnBsYXkoKSxSLmZpbmlzaGVkLnRoZW4oKCk9PntJLmRlbGV0ZShSKX0pfSk7Y29uc3QgRD10aGlzLmNoaWxkcmVuO0QmJkQuZm9yRWFjaChSPT57Ui5hY3RpdmF0ZUFuaW1hdGlvbnMmJlIuYWN0aXZhdGVBbmltYXRpb25zKCl9KX19YWRkRXZlbnRMaXN0ZW5lcihNLEksRD17fSl7TT09PSJtb3VzZXdoZWVsIiYmKE09IndoZWVsIiksdHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0e2NhcHR1cmU6UixvbmNlOkN9PUQsQj1SP286TztyZXR1cm4gdGhpc1tCXVtNXT10aGlzW0JdW01dfHxbXSx0aGlzW0JdW01dLnB1c2goe2xpc3RlbmVyOkksb25jZTpDfSksdGhpc31hbmltYXRlKE0sSSl7Y29uc3QgRD1uZXcgaS5kZWZhdWx0KHRoaXMsTSxJKTtyZXR1cm4gdGhpcy5lZmZlY3RzJiZELmFwcGx5RWZmZWN0cyh0aGlzLmVmZmVjdHMpLHRoaXMubGF5ZXImJihELmJhc2VUaW1lbGluZT10aGlzLmxheWVyLnRpbWVsaW5lLEQucGxheSgpLEQuZmluaXNoZWQudGhlbigoKT0+e3RoaXNbbV0uZGVsZXRlKEQpfSkpLHRoaXNbbV0uYWRkKEQpLER9YXR0ciguLi5NKXtpZihNLmxlbmd0aD09PTApcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tQXTtpZihNLmxlbmd0aD4xKXtsZXRbSSxEXT1NO3JldHVybiB0eXBlb2YgRD09ImZ1bmN0aW9uIiYmKEQ9RCh0aGlzLmF0dHIoSSkpKSx0aGlzLnNldEF0dHJpYnV0ZShJLEQpLHRoaXN9cmV0dXJuIHR5cGVvZiBNWzBdPT0ic3RyaW5nIj90aGlzLmdldEF0dHJpYnV0ZShNWzBdKTooT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsTVswXSksdGhpcyl9Y2xvbmVOb2RlKCl7Y29uc3QgTT1uZXcgdGhpcy5jb25zdHJ1Y3RvcixJPXRoaXMuYXR0cmlidXRlc1t5XTtyZXR1cm4gTS5hdHRyKEkpLE19Y29ubmVjdChNLEkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYXJlbnQiLHt2YWx1ZTpNLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6T3JkZXIiLHt2YWx1ZTpJLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE0udGltZWxpbmUmJnRoaXMuYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5zZXRSZXNvbHV0aW9uKE0uZ2V0UmVzb2x1dGlvbigpKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhcHBlbmQiLGRldGFpbDp7cGFyZW50Ok0sek9yZGVyOkl9fSl9Y29udGFpbnMoTSl7Zm9yKDtNJiZ0aGlzIT09TTspTT1NLnBhcmVudDtyZXR1cm4hIU19ZGVhY3RpdmF0ZUFuaW1hdGlvbnMoKXt0aGlzW21dLmZvckVhY2goST0+SS5jYW5jZWwoKSk7Y29uc3QgTT10aGlzLmNoaWxkcmVuO00mJk0uZm9yRWFjaChJPT57SS5kZWFjdGl2YXRlQW5pbWF0aW9ucyYmSS5kZWFjdGl2YXRlQW5pbWF0aW9ucygpfSl9ZGlzY29ubmVjdCgpe2NvbnN0e3BhcmVudDpNLHpPcmRlcjpJfT10aGlzO2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXIsdGhpcy5kZWFjdGl2YXRlQW5pbWF0aW9ucygpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVtb3ZlIixkZXRhaWw6e3BhcmVudDpNLHpPcmRlcjpJfX0pLE0mJk0uZm9yY2VVcGRhdGUoKX1kaXNwYXRjaEV2ZW50KE0pe00gaW5zdGFuY2VvZiBsLmRlZmF1bHR8fChNPW5ldyBsLmRlZmF1bHQoTSkpLE0udGFyZ2V0PXRoaXM7bGV0IEk9TS50eXBlO0k9PT0ibW91c2V3aGVlbCImJihJPSJ3aGVlbCIpO2NvbnN0IEQ9W3RoaXNdO2xldCBSPXRoaXMucGFyZW50O2Zvcig7TS5idWJibGVzJiZSOylELnB1c2goUiksUj1SLnBhcmVudDtmb3IobGV0IEM9RC5sZW5ndGgtMTtDPj0wO0MtLSl7Y29uc3QgQj1EW0NdLHo9QltvXSYmQltvXVtJXTtpZih6JiZ6Lmxlbmd0aCYmKE0uY3VycmVudFRhcmdldD1CLHouZm9yRWFjaCgoe2xpc3RlbmVyOkssb25jZTpRfSk9PntLLmNhbGwodGhpcyxNKSxRJiZELnJlbW92ZUV2ZW50TGlzdGVuZXIoSyl9KSxkZWxldGUgTS5jdXJyZW50VGFyZ2V0KSwhTS5idWJibGVzJiZNLmNhbmNlbEJ1YmJsZSlicmVha31pZighTS5jYW5jZWxCdWJibGUpZm9yKGxldCBDPTA7QzxELmxlbmd0aDtDKyspe2NvbnN0IEI9RFtDXSx6PUJbT10mJkJbT11bSV07aWYoeiYmei5sZW5ndGgmJihNLmN1cnJlbnRUYXJnZXQ9Qix6LmZvckVhY2goKHtsaXN0ZW5lcjpLLG9uY2U6UX0pPT57Sy5jYWxsKHRoaXMsTSksUSYmRC5yZW1vdmVFdmVudExpc3RlbmVyKEspfSksZGVsZXRlIE0uY3VycmVudFRhcmdldCksIU0uYnViYmxlc3x8TS5jYW5jZWxCdWJibGUpYnJlYWt9fWRpc3BhdGNoUG9pbnRlckV2ZW50KE0pe2NvbnN0e2xheWVyWDpJLGxheWVyWTpEfT1NO3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oSSxEKT8odGhpcy5kaXNwYXRjaEV2ZW50KE0pLCEwKTohMX1kcmF3KE09W10pe2NvbnN0IEk9dGhpcy5tZXNoO2lmKEkpe2lmKE9iamVjdChzLmFwcGx5RmlsdGVycykoSSx0aGlzLmZpbHRlcnMpLE0ucHVzaChJKSx0aGlzW2ddKXtJLnNldFByb2dyYW0odGhpc1tnXSk7Y29uc3QgRD10aGlzW2JdO0QmJk9iamVjdC5lbnRyaWVzKEQpLmZvckVhY2goKFtDLEJdKT0+e0kuc2V0QXR0cmlidXRlKEMsQil9KTtjb25zdCBSPXRoaXNbRV07aWYodGhpc1tFXSl7Y29uc3QgQz17fTtPYmplY3QuZW50cmllcyhSKS5mb3JFYWNoKChbQix6XSk9Pnt0eXBlb2Ygej09ImZ1bmN0aW9uIiYmKHo9eih0aGlzLEIpKSxDW0JdPXp9KSxJLnNldFVuaWZvcm1zKEMpfX1PYmplY3QoZi5kZWZhdWx0KSh0aGlzLEkpfXJldHVybiBNfWZvcmNlVXBkYXRlKCl7dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmZvcmNlVXBkYXRlKCl9Z2V0QXR0cmlidXRlKE0pe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbTV19Z2V0TGlzdGVuZXJzKE0se2NhcHR1cmU6ST0hMX09e30pe3JldHVyblsuLi50aGlzW0k/bzpPXVtNXXx8W11dfWdldE5vZGVOZWFyQnkoTT0xKXtpZighdGhpcy5wYXJlbnQpcmV0dXJuIG51bGw7aWYoTT09PTApcmV0dXJuIHRoaXM7Y29uc3QgST10aGlzLnBhcmVudC5jaGlsZHJlbixEPUkuaW5kZXhPZih0aGlzKTtyZXR1cm4gSVtEK01dfWdldFdvcmxkUG9zaXRpb24oTSxJKXtjb25zdCBEPXRoaXMucmVuZGVyTWF0cml4LFI9TSpEWzBdK0kqRFsyXStEWzRdLEM9TSpEWzFdK0kqRFszXStEWzVdO3JldHVybltSLENdfWdldE9mZnNldFBvc2l0aW9uKE0sSSl7Y29uc3QgRD1yLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpcy5yZW5kZXJNYXRyaXgpLFI9TSpEWzBdK0kqRFsyXStEWzRdLEM9TSpEWzFdK0kqRFszXStEWzVdO3JldHVybltSLENdfWdldFJlc29sdXRpb24oKXtyZXR1cm4gZCh7fSx0aGlzW3hdKX1pc1BvaW50Q29sbGlzaW9uKE0sSSl7aWYoIXRoaXMubWVzaClyZXR1cm4hMTtjb25zdCBEPXRoaXMuYXR0cmlidXRlcy5wb2ludGVyRXZlbnRzO2lmKEQ9PT0ibm9uZSJ8fEQhPT0iYWxsIiYmIXRoaXMuaXNWaXNpYmxlKXJldHVybiExO2xldCBSPSJib3RoIjtyZXR1cm4gRD09PSJ2aXNpYmxlRmlsbCImJihSPSJmaWxsIiksRD09PSJ2aXNpYmxlU3Ryb2tlIiYmKFI9InN0cm9rZSIpLHRoaXMubWVzaC5pc1BvaW50Q29sbGlzaW9uKE0sSSxSKX1vblByb3BlcnR5Q2hhbmdlKE0sSSxEKXtNIT09ImlkIiYmTSE9PSJuYW1lIiYmTSE9PSJjbGFzc05hbWUiJiZNIT09InBvaW50ZXJFdmVudHMiJiZNIT09InBhc3NFdmVudHMiJiZ0aGlzLmZvcmNlVXBkYXRlKCksTT09PSJmaWx0ZXIiJiYodGhpc1toXT1PYmplY3Qocy5wYXJzZUZpbHRlclN0cmluZykoSSkpLE09PT0iekluZGV4IiYmdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlb3JkZXIoKX1zZXRBdHRyaWJ1dGUoTSxJKXtNPT09ImF0dHJzIiYmdGhpcy5hdHRyKEkpLHRoaXMuYXR0cmlidXRlc1tNXT1JfXNldE1vdXNlQ2FwdHVyZSgpe3RoaXMubGF5ZXImJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD10aGlzKX1zZXRQcm9ncmFtKE0pe3RoaXNbZ109TSx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0U2hhZGVyQXR0cmlidXRlKE0sSSl7dGhpc1tiXT10aGlzW2JdfHx7fSx0aGlzW2JdW01dPUksdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFVuaWZvcm1zKE0pe3RoaXNbRV09dGhpc1tFXXx8e30sT2JqZWN0LmFzc2lnbih0aGlzW0VdLE0pLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpNLGhlaWdodDpJfSl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpc1t4XTsoRCE9PU18fFIhPT1JKSYmKHRoaXNbeF09e3dpZHRoOk0saGVpZ2h0Okl9LHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc29sdXRpb25jaGFuZ2UiLGRldGFpbDp7d2lkdGg6TSxoZWlnaHQ6SX19KSl9c2hvdygpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiJiYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9dGhpc1tjXXx8IiIpfWhpZGUoKXt0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSE9PSJub25lIiYmKHRoaXNbY109dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXksdGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9Im5vbmUiKX1yZWxlYXNlTW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmdGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9PT10aGlzJiYodGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbCl9cmVtb3ZlKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZD8odGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksITApOiExfXJlbW92ZUFsbExpc3RlbmVycyhNLEk9e30pe3R5cGVvZiBJPT0iYm9vbGVhbiImJihJPXtjYXB0dXJlOkl9KTtjb25zdCBSPUkuY2FwdHVyZT9vOk87cmV0dXJuIHRoaXNbUl1bTV0mJih0aGlzW1JdW01dPVtdKSx0aGlzfXJlbW92ZUF0dHJpYnV0ZShNKXt0aGlzLnNldEF0dHJpYnV0ZShNLG51bGwpfXJlbW92ZUV2ZW50TGlzdGVuZXIoTSxJLEQ9e30pe3R5cGVvZiBEPT0iYm9vbGVhbiImJihEPXtjYXB0dXJlOkR9KTtjb25zdCBDPUQuY2FwdHVyZT9vOk87aWYodGhpc1tDXVtNXSl7Y29uc3QgQj10aGlzW0NdW01dO2lmKEIpZm9yKGxldCB6PTA7ejxCLmxlbmd0aDt6Kyspe2NvbnN0e2xpc3RlbmVyOkt9PUJbel07aWYoSz09PUkpe3RoaXNbQ11bTV0uc3BsaWNlKHosMSk7YnJlYWt9fX1yZXR1cm4gdGhpc310cmFuc2l0aW9uKE0sST0ibGluZWFyIil7Y29uc3QgRD10aGlzLFI9U3ltYm9sKCJhbmltYXRpb24iKTtJPUl8fCJsaW5lYXIiO2xldCBDPTA7cmV0dXJuIHR5cGVvZiBNPT0ib2JqZWN0IiYmKEM9TS5kZWxheXx8MCxNPU0uZHVyYXRpb24pLHtbUl06bnVsbCxjYW5jZWwoQj0hMSl7Y29uc3Qgej10aGlzW1JdO3omJnouY2FuY2VsKEIpfSxlbmQoKXtjb25zdCBCPXRoaXNbUl07QiYmKEIucGxheVN0YXRlPT09InJ1bm5pbmcifHxCLnBsYXlTdGF0ZT09PSJwZW5kaW5nIikmJkIuZmluaXNoKCl9LHJldmVyc2UoKXtjb25zdCBCPXRoaXNbUl07aWYoQilpZihCLnBsYXlTdGF0ZT09PSJydW5uaW5nInx8Qi5wbGF5U3RhdGU9PT0icGVuZGluZyIpQi5wbGF5YmFja1JhdGU9LUIucGxheWJhY2tSYXRlO2Vsc2V7Y29uc3Qgej1CLnRpbWluZy5kaXJlY3Rpb247Qi50aW1pbmcuZGlyZWN0aW9uPXo9PT0icmV2ZXJzZSI/Im5vcm1hbCI6InJldmVyc2UiLEIucGxheSgpfXJldHVybiBCLmZpbmlzaGVkfSxhdHRyKEIseil7cmV0dXJuIHRoaXMuZW5kKCksdHlwZW9mIEI9PSJzdHJpbmciJiYoQj17W0JdOnp9KSxPYmplY3QuZW50cmllcyhCKS5mb3JFYWNoKChbSyxRXSk9Pnt0eXBlb2YgUT09ImZ1bmN0aW9uIiYmKEJbS109UShELmF0dHIoSykpKX0pLHRoaXNbUl09RC5hbmltYXRlKFtCXSx7ZHVyYXRpb246TSoxZTMsZGVsYXk6QyoxZTMsZmlsbDoiZm9yd2FyZHMiLGVhc2luZzpJfSksdGhpc1tSXS5maW5pc2hlZH19fXVwZGF0ZUNvbnRvdXJzKCl7fX1wKEEsIkF0dHIiLG4uZGVmYXVsdCksYS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShBLCJub2RlIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KTt2YXIgcj10KDEpLG49dCgxMiksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKSxzPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGY9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxwPVN5bWJvbCgic3ViamVjdCIpLHk9U3ltYm9sKCJhdHRyIiksUD1TeW1ib2woImRlZmF1bHQiKSx4PVN5bWJvbCgiYWxpYXMiKTtmdW5jdGlvbiBtKEwsW00sSV0pe2xldCBEPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7cmV0dXJuWy4uLkxdLmZvckVhY2goKFtSLENdKT0+e2lmKChNfHxJKSYmKEQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsW00sSV0pKSxSPT09Im1hdHJpeCIpRD1yLm1hdDJkLm11bHRpcGx5KEQsRCxDKTtlbHNlIGlmKFI9PT0ib2Zmc2V0VHJhbnNsYXRlIilEWzRdKz1DWzBdLERbNV0rPUNbMV07ZWxzZSBpZihSPT09Im9mZnNldFJvdGF0ZSIpRD1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRCxDKTtlbHNlIGlmKFI9PT0ic2tldyIpe2NvbnN0W0Isel09QztEPXIubWF0MmQubXVsdGlwbHkoRCxELHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKHopLE1hdGgudGFuKEIpLDEsMCwwKSl9ZWxzZSByLm1hdDJkW1JdKEQsRCxDKTsoTXx8SSkmJihEPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELFstTSwtSV0pKX0pLER9Y29uc3QgTz1TeW1ib2woInRyYW5zZm9ybU1hdHJpeCIpLG89U3ltYm9sKCJ0cmFuc2Zvcm1zIiksaD1TeW1ib2woImNoYW5nZWRBdHRycyIpLGM9U3ltYm9sKCJsYXN0Q2hhbmdlZEF0dHIiKSxnPVN5bWJvbCgib2Zmc2V0RmlndXJlIik7ZnVuY3Rpb24gYihMLE0sSSl7Y29uc3QgRD1MW3ldW01dO2lmKExbc10oTSxJLCExKXx8TFtjXSE9PU0pe2NvbnN0IEM9TFtvXTtDLmhhcyhNKSYmQy5kZWxldGUoTSksSSYmKE09PT0icm90YXRlIiYmKEk9TWF0aC5QSSpJLzE4MCksTT09PSJzY2FsZSImJihJPUkubWFwKEI9Pk1hdGguYWJzKEIpPjFlLTU/QjoxL0I+MD8xZS01Oi0xZS01KSksQy5zZXQoTSxJKSksTFtPXT1udWxsLExbcF0ub25Qcm9wZXJ0eUNoYW5nZShNLEksRCxMKX19ZnVuY3Rpb24gRShMKXtjb25zdCBNPUxbZ10sST1MLm9mZnNldERpc3RhbmNlKk0uZ2V0VG90YWxMZW5ndGgoKSxEPU0uZ2V0UG9pbnRBdExlbmd0aChJKTtpZihEKXtjb25zdCBSPUxbb107bGV0IEM9TC5vZmZzZXRSb3RhdGU7Qz09PSJhdXRvIj9DPUQuYW5nbGU6Qz09PSJyZXZlcnNlIj9DPU1hdGguUEkrRC5hbmdsZTpDPU1hdGguUEkqQy8xODAsUi5zZXQoIm9mZnNldFJvdGF0ZSIsQyksUi5zZXQoIm9mZnNldFRyYW5zbGF0ZSIsW0QueCxELnldKSxMW09dPW51bGx9fWNsYXNzIEF7c3RhdGljIHNldERlZmF1bHQoTSwuLi5JKXtyZXR1cm4gTVthXSguLi5JKX1zdGF0aWMgZGVjbGFyZUFsaWFzKE0sLi4uSSl7cmV0dXJuIE1bbF0oLi4uSSl9c3RhdGljIHNldEF0dHJpYnV0ZShNLC4uLkkpe3JldHVybiBNW3NdKC4uLkkpfXN0YXRpYyBnZXRBdHRyaWJ1dGUoTSwuLi5JKXtyZXR1cm4gTVtmXSguLi5JKX1zdGF0aWMgZ2V0QXR0cmlidXRlcyhNKXtyZXR1cm4gTVt2XX1zdGF0aWMgZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoTSl7cmV0dXJuIE1bZF19Y29uc3RydWN0b3IoTSl7dGhpc1twXT1NLHRoaXNbeV09e30sdGhpc1tPXT1yLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLHRoaXNbb109bmV3IE1hcCx0aGlzW1BdPXt9LHRoaXNbeF09W10sT2JqZWN0LmRlZmluZVByb3BlcnR5KE0sInRyYW5zZm9ybU1hdHJpeCIse2dldDooKT0+KHRoaXNbT118fCh0aGlzW09dPW0odGhpc1tvXSx0aGlzLnRyYW5zZm9ybU9yaWdpbikpLFsuLi50aGlzW09dXSl9KSx0aGlzW2FdKHtpZDoiIixuYW1lOiIiLGNsYXNzTmFtZToiIix4OjAseTowLHRyYW5zZm9ybU9yaWdpbjpbMCwwXSx0cmFuc2Zvcm06IiIsdHJhbnNsYXRlOlswLDBdLHJvdGF0ZTowLHNjYWxlOlsxLDFdLHNrZXc6WzAsMF0sb3BhY2l0eToxLHpJbmRleDowLG9mZnNldFBhdGg6dm9pZCAwLG9mZnNldERpc3RhbmNlOjAsb2Zmc2V0Um90YXRlOiJhdXRvIixwb2ludGVyRXZlbnRzOiJ2aXNpYmxlIixmaWx0ZXI6Im5vbmUiLGRpc3BsYXk6IiJ9KSx0aGlzW2xdKCJjbGFzcyIsInBvcyIpLHRoaXNbaF09bmV3IFNldCx0aGlzW2ddPW5ldyBuLkZpZ3VyZTJEKHtzY2FsZTo1LHNpbXBsaWZ5OjB9KX1nZXRbZF0oKXtjb25zdCBNPXt9O3JldHVyblsuLi50aGlzW2hdXS5mb3JFYWNoKEk9PntNW0ldPXRoaXNbeV1bSV19KSxNfWdldFt2XSgpe2NvbnN0IE09T2JqZWN0LmFzc2lnbih7fSx0aGlzW3ldKTtmb3IobGV0IEk9MDtJPHRoaXNbeF0ubGVuZ3RoO0krKyl7Y29uc3QgRD10aGlzW3hdW0ldO01bRF09dGhpc1tEXX1yZXR1cm4gTX1bYV0oTSl7T2JqZWN0LmFzc2lnbih0aGlzW1BdLE0pLE9iamVjdC5hc3NpZ24odGhpc1t5XSxNKX1bbF0oLi4uTSl7dGhpc1t4XS5wdXNoKC4uLk0pfVtzXShNLEksRD0hMCl7Y29uc3QgUj10aGlzW3ldW01dLEM9dGhpc1twXTtyZXR1cm4gST09bnVsbCYmKEk9dGhpc1tQXVtNXSksT2JqZWN0KGkuY29tcGFyZVZhbHVlKShSLEkpPyExOih0aGlzW3ldW01dPUksdGhpc1toXS5oYXMoTSkmJnRoaXNbaF0uZGVsZXRlKE0pLHRoaXNbaF0uYWRkKE0pLHRoaXNbY109TSxEJiZDLm9uUHJvcGVydHlDaGFuZ2UoTSxJLFIsdGhpcyksITApfVtmXShNKXtyZXR1cm4gdGhpc1t5XVtNXX1zZXQgaWQoTSl7dGhpc1tzXSgiaWQiLE0pfWdldCBpZCgpe3JldHVybiB0aGlzW2ZdKCJpZCIpfXNldCBuYW1lKE0pe3RoaXNbc10oIm5hbWUiLE0pfWdldCBuYW1lKCl7cmV0dXJuIHRoaXNbZl0oIm5hbWUiKX1zZXQgY2xhc3NOYW1lKE0pe3RoaXNbc10oImNsYXNzTmFtZSIsTSl9Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzW2ZdKCJjbGFzc05hbWUiKX1zZXQgY2xhc3MoTSl7dGhpcy5jbGFzc05hbWU9TX1nZXQgY2xhc3MoKXtyZXR1cm4gdGhpcy5jbGFzc05hbWV9Z2V0IHgoKXtyZXR1cm4gdGhpc1tmXSgieCIpfXNldCB4KE0pe3RoaXNbc10oIngiLE9iamVjdChpLnRvTnVtYmVyKShNKSl9Z2V0IHkoKXtyZXR1cm4gdGhpc1tmXSgieSIpfXNldCB5KE0pe3RoaXNbc10oInkiLE9iamVjdChpLnRvTnVtYmVyKShNKSl9Z2V0IHBvcygpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXQgcG9zKE0pe009T2JqZWN0KGkudG9BcnJheSkoTSksQXJyYXkuaXNBcnJheShNKXx8KE09W00sTV0pLHRoaXMueD1NWzBdLHRoaXMueT1NWzFdfWdldCB0cmFuc2Zvcm0oKXtyZXR1cm4gdGhpc1tmXSgidHJhbnNmb3JtIil9c2V0IHRyYW5zZm9ybShNKXtsZXQgST1udWxsO2lmKEFycmF5LmlzQXJyYXkoTSkmJihJPU0sTT1gbWF0cml4KCR7TS5tYXAoaS50b051bWJlcikuam9pbigpfSlgKSx0eXBlb2YgTT09InN0cmluZyIpTT1NLnJlcGxhY2UoL1xzKixccyovZywiLCIpO2Vsc2UgaWYoTSE9bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHRyYW5zZm9ybSB2YWx1ZS4iKTtjb25zdCBEPXRoaXNbeV0udHJhbnNmb3JtO2lmKHRoaXNbc10oInRyYW5zZm9ybSIsTSwhMSkpe2NvbnN0IFI9dGhpc1tvXTtpZihSLmhhcygibWF0cml4IikmJlIuZGVsZXRlKCJtYXRyaXgiKSxJKVIuc2V0KCJtYXRyaXgiLEkpO2Vsc2UgaWYoTSl7Y29uc3QgQz1NLm1hdGNoKC8obWF0cml4fHRyYW5zbGF0ZXxyb3RhdGV8c2NhbGV8c2tldylcKFteKCldK1wpL2cpO2lmKEMpe2xldCBCPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7Zm9yKGxldCB6PTA7ejxDLmxlbmd0aDt6Kyspe2NvbnN0IFE9Q1t6XS5tYXRjaCgvXihtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoKFteKCldKylcKS8pO2lmKFEpe2xldFssXyxGXT1RO189PT0icm90YXRlIj9GPU1hdGguUEkqcGFyc2VGbG9hdChGKS8xODA6Rj1GLnRyaW0oKS5zcGxpdCgvW1xzLF0rLykubWFwKEc9Pk9iamVjdChpLnRvTnVtYmVyKShHKSksXz09PSJtYXRyaXgiP0I9ci5tYXQyZC5tdWx0aXBseShCLEIsRik6Xz09PSJza2V3Ij9CPXIubWF0MmQubXVsdGlwbHkoQixCLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKEZbMV0pLE1hdGgudGFuKEZbMF0pLDEsMCwwKSk6ci5tYXQyZFtfXShCLEIsRiksUi5zZXQoIm1hdHJpeCIsQil9fX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpfXRoaXNbT109bnVsbCx0aGlzW3BdLm9uUHJvcGVydHlDaGFuZ2UoInRyYW5zZm9ybSIsTSxELHRoaXMpfX1nZXQgdHJhbnNmb3JtT3JpZ2luKCl7cmV0dXJuIHRoaXNbZl0oInRyYW5zZm9ybU9yaWdpbiIpfXNldCB0cmFuc2Zvcm1PcmlnaW4oTSl7TT1PYmplY3QoaS50b0FycmF5KShNLCEwKSxNIT1udWxsJiYhQXJyYXkuaXNBcnJheShNKSYmKE09W00sTV0pLHRoaXNbc10oInRyYW5zZm9ybU9yaWdpbiIsTSkmJih0aGlzW09dPW51bGwpfWdldCByb3RhdGUoKXtyZXR1cm4gdGhpc1tmXSgicm90YXRlIil9c2V0IHJvdGF0ZShNKXtiKHRoaXMsInJvdGF0ZSIsTSl9Z2V0IHRyYW5zbGF0ZSgpe3JldHVybiB0aGlzW2ZdKCJ0cmFuc2xhdGUiKX1zZXQgdHJhbnNsYXRlKE0pe009T2JqZWN0KGkudG9BcnJheSkoTSwhMCksTSE9bnVsbCYmIUFycmF5LmlzQXJyYXkoTSkmJihNPVtNLE1dKSxiKHRoaXMsInRyYW5zbGF0ZSIsTSl9Z2V0IHNjYWxlKCl7cmV0dXJuIHRoaXNbZl0oInNjYWxlIil9c2V0IHNjYWxlKE0pe009T2JqZWN0KGkudG9BcnJheSkoTSwhMCksTSE9bnVsbCYmIUFycmF5LmlzQXJyYXkoTSkmJihNPVtNLE1dKSxiKHRoaXMsInNjYWxlIixNKX1nZXQgc2tldygpe3JldHVybiB0aGlzW2ZdKCJza2V3Iil9c2V0IHNrZXcoTSl7TT1PYmplY3QoaS50b0FycmF5KShNLCEwKSxNIT1udWxsJiYhQXJyYXkuaXNBcnJheShNKSYmKE09W00sTV0pLGIodGhpcywic2tldyIsTSl9Z2V0IG9wYWNpdHkoKXtyZXR1cm4gdGhpc1tmXSgib3BhY2l0eSIpfXNldCBvcGFjaXR5KE0pe00hPW51bGwmJihNPU51bWJlcihNKSksdGhpc1tzXSgib3BhY2l0eSIsTSl9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzW2ZdKCJ6SW5kZXgiKX1zZXQgekluZGV4KE0pe00hPW51bGwmJihNPU51bWJlcihNKSksdGhpc1tzXSgiekluZGV4IixNKX1nZXQgb2Zmc2V0UGF0aCgpe3JldHVybiB0aGlzW2ZdKCJvZmZzZXRQYXRoIil9c2V0IG9mZnNldFBhdGgoTSl7dGhpc1tzXSgib2Zmc2V0UGF0aCIsTSkmJih0aGlzW2ddLmJlZ2luUGF0aCgpLE0hPW51bGwmJnRoaXNbZ10uYWRkUGF0aChNKSxFKHRoaXMpKX1nZXQgb2Zmc2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpc1tmXSgib2Zmc2V0RGlzdGFuY2UiKX1zZXQgb2Zmc2V0RGlzdGFuY2UoTSl7dGhpc1tzXSgib2Zmc2V0RGlzdGFuY2UiLE9iamVjdChpLnRvTnVtYmVyKShNKSkmJkUodGhpcyl9Z2V0IG9mZnNldFJvdGF0ZSgpe3JldHVybiB0aGlzW2ZdKCJvZmZzZXRSb3RhdGUiKX1zZXQgb2Zmc2V0Um90YXRlKE0pe3RoaXNbc10oIm9mZnNldFJvdGF0ZSIsTSksRSh0aGlzKX1nZXQgcG9pbnRlckV2ZW50cygpe3JldHVybiB0aGlzW2ZdKCJwb2ludGVyRXZlbnRzIil9c2V0IHBvaW50ZXJFdmVudHMoTSl7aWYoTSE9bnVsbCYmTSE9PSJub25lIiYmTSE9PSJ2aXNpYmxlIiYmTSE9PSJ2aXNpYmxlRmlsbCImJk0hPT0idmlzaWJsZVN0cm9rZSImJk0hPT0iYWxsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHBvaW50ZXJFdmVudHMgdHlwZS4iKTt0aGlzW3NdKCJwb2ludGVyRXZlbnRzIixNKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbZl0oImZpbHRlciIpfXNldCBmaWx0ZXIoTSl7dGhpc1tzXSgiZmlsdGVyIixNKX1nZXQgZGlzcGxheSgpe3JldHVybiB0aGlzW2ZdKCJkaXNwbGF5Iil9c2V0IGRpc3BsYXkoTSl7dGhpc1tzXSgiZGlzcGxheSIsTSl9c2V0IG9mZnNldChNKXt9fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwic2l6ZVRvUGl4ZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwidG9OdW1iZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwidG9BcnJheSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJjb21wYXJlVmFsdWUiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihzLGYpe2NvbnN0IHY9cy50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW4pJC8pO3Y/cz17c2l6ZTpwYXJzZUZsb2F0KHZbMV0pLHVuaXQ6dlsyXX06cz17c2l6ZTpwYXJzZUZsb2F0KHMpLHVuaXQ6InB4In07bGV0e3NpemU6ZCx1bml0OnB9PXM7aWYocD09PSJwdCIpZC89Ljc1O2Vsc2UgaWYocD09PSJwYyIpZCo9MTY7ZWxzZSBpZihwPT09ImluIilkKj05NjtlbHNlIGlmKHA9PT0iY20iKWQqPTk2LzIuNTQ7ZWxzZSBpZihwPT09Im1tIilkKj05Ni8yNS40O2Vsc2UgaWYocD09PSJlbSJ8fHA9PT0icmVtInx8cD09PSJleCIpe2lmKCFmJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeT1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7eT9mPXIoeSwxNik6Zj0xNn1kKj1mLHA9PT0iZXgiJiYoZC89Mil9ZWxzZSBpZihwPT09InEiKWQqPTk2LzI1LjQvNDtlbHNlIGlmKHA9PT0idncifHxwPT09InZoIil7aWYodHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeT1wPT09InZ3Ij93aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOndpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtkKj15LzEwMH19ZWxzZSBpZigocD09PSJ2bWF4Inx8cD09PSJ2bWluIikmJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IHk9d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxQPXdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtwPT09InZtYXgiP2QqPU1hdGgubWF4KHksUCkvMTAwOmQqPU1hdGgubWluKHksUCkvMTAwfXJldHVybiBkfWZ1bmN0aW9uIG4ocyl7cmV0dXJuIHM9PW51bGw/czpTdHJpbmcocyl9ZnVuY3Rpb24gaShzKXtpZihzPT1udWxsKXJldHVybiBzO2lmKHR5cGVvZiBzPT0ic3RyaW5nIiYmKHM9cihzKSksIU51bWJlci5pc0Zpbml0ZShzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZhbHVlIik7cmV0dXJuIHN9ZnVuY3Rpb24gYShzLGY9ITEpe3JldHVybiBzPT09IiI/bnVsbDoodHlwZW9mIHM9PSJzdHJpbmciJiYocz1zLnNwbGl0KC9bXHMsXSsvZykpLEFycmF5LmlzQXJyYXkocykmJihmJiYocz1zLm1hcChpKSkscy5sZW5ndGg9PT0xKT9zWzBdOnMpfWZ1bmN0aW9uIGwocyxmKXtpZihBcnJheS5pc0FycmF5KHMpJiZBcnJheS5pc0FycmF5KGYpKXtpZihzLmxlbmd0aCE9PWYubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdj0wO3Y8cy5sZW5ndGg7disrKWlmKHNbdl0hPT1mW3ZdKXJldHVybiExO3JldHVybiEwfXJldHVybiBzPT1udWxsJiZmPT1udWxsfHxzPT09Zn19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgcj10KDc0KSxuPXQoMzIpLGk9dC5uKG4pLGE9dCg2OCksbD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcygpe3JldHVybiBzPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHkpe2Zvcih2YXIgUD0xO1A8YXJndW1lbnRzLmxlbmd0aDtQKyspe3ZhciB4PWFyZ3VtZW50c1tQXTtmb3IodmFyIG0gaW4geClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCxtKSYmKHlbbV09eFttXSl9cmV0dXJuIHl9LHMuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGYoeSl7aWYodHlwZW9mIHk9PSJzdHJpbmciKXtpZih5PXkudHJpbSgpLC9eWzAtOS5dKyUkLy50ZXN0KHkpKXJldHVybiBwYXJzZUZsb2F0KHkpLzEwMDtpZigvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLy50ZXN0KHkpKXJldHVybiBPYmplY3QobC5zaXplVG9QaXhlbCkoeSl9cmV0dXJuIHl9ZnVuY3Rpb24gdih5LFAseCxtLE8pe3JldHVybiB0eXBlb2YgeT09InN0cmluZyImJih5PWkoKSh5KSksdHlwZW9mIFA9PSJzdHJpbmciJiYoUD1pKCkoUCkpLHIuRWZmZWN0cy5kZWZhdWx0KHksUCx4LG0sTyl9ZnVuY3Rpb24gZCh5LFAseCxtLE8pe3JldHVybiByLkVmZmVjdHMuZGVmYXVsdCh5LFAseCxtLE8pfXIuRWZmZWN0cy5kZWZhdWx0PWZ1bmN0aW9uKHksUCx4LG0sTyl7cmV0dXJuIEFycmF5LmlzQXJyYXkoeSkmJkFycmF5LmlzQXJyYXkoUCk/eS5tYXAoKG8saCk9Pm8rKHgtbSkvKE8tbSkqKFBbaF0tbykpOnR5cGVvZiB5PT0ibnVtYmVyIiYmdHlwZW9mIFA9PSJudW1iZXIiP3krKHgtbSkvKE8tbSkqKFAteSk6eC1tPk8teD9QOnl9LHIuRWZmZWN0cy5maWxsQ29sb3I9dixyLkVmZmVjdHMuc3Ryb2tlQ29sb3I9dixyLkVmZmVjdHMuYmdjb2xvcj12LHIuRWZmZWN0cy5ib3JkZXJDb2xvcj12LHIuRWZmZWN0cy50ZXh0PWQ7Y2xhc3MgcCBleHRlbmRzIHIuQW5pbWF0b3J7Y29uc3RydWN0b3IoUCx4LG0pe2NvbnN0IE89UC5hdHRyKCk7T2JqZWN0LmVudHJpZXMoTykuZm9yRWFjaCgoW28saF0pPT57T1tvXT1yLkVmZmVjdHNbb10/aDpmKGgpfSkseD14Lm1hcChvPT57bGV0IGg9cyh7fSxvKTtjb25zdCBjPXt9O3JldHVybiBPYmplY3QuZW50cmllcyhoKS5mb3JFYWNoKChbZyxiXSk9PntjW2ddPXIuRWZmZWN0c1tnXT9iOmYoYil9KSxjfSksc3VwZXIoTyx4LG0pLHRoaXMudGFyZ2V0PVAsdGhpcy5zZXR0ZXI9ZnVuY3Rpb24obyxoKXtoLmF0dHIobyl9fWdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy50YXJnZXQucGFyZW50P3N1cGVyLnBsYXlTdGF0ZToiaWRsZSJ9Z2V0IGZpbmlzaGVkKCl7cmV0dXJuIHN1cGVyLmZpbmlzaGVkLnRoZW4oKCk9Pntjb25zdCBQPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKHg9PntmdW5jdGlvbiBtKCl7UC5zZXR0ZXIoUC5mcmFtZSxQLnRhcmdldCk7Y29uc3QgTz1QLnBsYXlTdGF0ZTtPPT09ImZpbmlzaGVkInx8Tz09PSJpZGxlIj8oT2JqZWN0KGEuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKFAucmVxdWVzdElkKSx4KCkpOk9iamVjdChhLnJlcXVlc3RBbmltYXRpb25GcmFtZSkobSl9bSgpfSl9KX1maW5pc2goKXtzdXBlci5maW5pc2goKSxPYmplY3QoYS5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpfXBsYXkoKXtpZighdGhpcy50YXJnZXQucGFyZW50fHx0aGlzLnBsYXlTdGF0ZT09PSJydW5uaW5nIilyZXR1cm47c3VwZXIucGxheSgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpO2NvbnN0IFA9dGhpczt0aGlzLnJlYWR5LnRoZW4oKCk9PntQLnNldHRlcihQLmZyYW1lLFAudGFyZ2V0KSxQLnJlcXVlc3RJZD1PYmplY3QoYS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGZ1bmN0aW9uIHgoKXtjb25zdCBtPVAudGFyZ2V0O2lmKHR5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zJiZtLmxheWVyJiZtLmxheWVyLmNhbnZhcyYmIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhtLmxheWVyLmNhbnZhcykpe1AuY2FuY2VsKCk7cmV0dXJufWNvbnN0IE89UC5wbGF5U3RhdGU7UC5zZXR0ZXIoUC5mcmFtZSxQLnRhcmdldCksTyE9PSJpZGxlIiYmKE89PT0icnVubmluZyI/UC5yZXF1ZXN0SWQ9T2JqZWN0KGEucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSh4KTooTz09PSJwYXVzZWQifHxPPT09InBlbmRpbmciJiZQLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDApJiZQLnJlYWR5LnRoZW4oKCk9PntQLnNldHRlcihQLmZyYW1lLFAudGFyZ2V0KSxQLnJlcXVlc3RJZD1PYmplY3QoYS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKHgpfSkpfSl9KX1jYW5jZWwoUD0hMSl7T2JqZWN0KGEuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXMucmVxdWVzdElkKSxQPyh0aGlzLnNldHRlcih0aGlzLmZyYW1lLHRoaXMudGFyZ2V0KSxzdXBlci5jYW5jZWwoKSk6KHN1cGVyLmNhbmNlbCgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpKX19fSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuVGltZWxpbmU9ZS5FZmZlY3RzPWUuRWFzaW5ncz1lLkFuaW1hdG9yPXZvaWQgMDt2YXIgcj10KDc1KSxuPXYociksaT10KDE4NyksYT12KGkpLGw9dCgxODgpLHM9dCgxOTApLGY9dihzKTtmdW5jdGlvbiB2KGQpe3JldHVybiBkJiZkLl9fZXNNb2R1bGU/ZDp7ZGVmYXVsdDpkfX1lLkFuaW1hdG9yPWYuZGVmYXVsdCxlLkVhc2luZ3M9bC5FYXNpbmdzLGUuRWZmZWN0cz1hLmRlZmF1bHQsZS5UaW1lbGluZT1uLmRlZmF1bHR9LGZ1bmN0aW9uKHUsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9dCg3Niksbj1vKHIpLGk9dCgxMzMpLGE9byhpKSxsPXQoMTQxKSxzPW8obCksZj10KDE2NCksdj1vKGYpLGQ9dCgxNzApLHA9byhkKSx5PXQoMTcxKSxQPW8oeSkseD10KDE3NSksbT1vKHgpLE89dCgxODYpO2Z1bmN0aW9uIG8oRCl7cmV0dXJuIEQmJkQuX19lc01vZHVsZT9EOntkZWZhdWx0OkR9fXZhciBoPSgwLE8uY3JlYXRlTm93VGltZSkoKSxjPXtvcmlnaW5UaW1lOjAscGxheWJhY2tSYXRlOjF9LGc9KDAsbS5kZWZhdWx0KSgidGltZU1hcmsiKSxiPSgwLG0uZGVmYXVsdCkoInBsYXliYWNrUmF0ZSIpLEU9KDAsbS5kZWZhdWx0KSgidGltZXJzIiksQT0oMCxtLmRlZmF1bHQpKCJvcmlnaW5UaW1lIiksTD0oMCxtLmRlZmF1bHQpKCJzZXRUaW1lciIpLE09KDAsbS5kZWZhdWx0KSgicGFyZW50IiksST1mdW5jdGlvbigpe2Z1bmN0aW9uIEQoUixDKXsoMCxwLmRlZmF1bHQpKHRoaXMsRCksUiBpbnN0YW5jZW9mIEQmJihDPVIsUj17fSksUj0oMCx2LmRlZmF1bHQpKHt9LGMsUiksQyYmKHRoaXNbTV09Qyk7dmFyIEI9Ui5ub3d0aW1lfHxoO2lmKEMpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImdsb2JhbFRpbWUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQy5jdXJyZW50VGltZX19KTtlbHNle3ZhciB6PUIoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBCKCkten19KX10aGlzW2ddPVt7Z2xvYmFsVGltZTp0aGlzLmdsb2JhbFRpbWUsbG9jYWxUaW1lOi1SLm9yaWdpblRpbWUsZW50cm9weTotUi5vcmlnaW5UaW1lLHBsYXliYWNrUmF0ZTpSLnBsYXliYWNrUmF0ZSxnbG9iYWxFbnRyb3B5OjB9XSx0aGlzW01dJiYodGhpc1tnXVswXS5nbG9iYWxFbnRyb3B5PXRoaXNbTV0uZW50cm9weSksdGhpc1tBXT1SLm9yaWdpblRpbWUsdGhpc1tiXT1SLnBsYXliYWNrUmF0ZSx0aGlzW0VdPW5ldyBzLmRlZmF1bHR9cmV0dXJuKDAsUC5kZWZhdWx0KShELFt7a2V5OiJtYXJrVGltZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgQz1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXZvaWQgMD9hcmd1bWVudHNbMF06e30sQj1DLnRpbWUsej1CPT09dm9pZCAwP3RoaXMuY3VycmVudFRpbWU6QixLPUMuZW50cm9weSxRPUs9PT12b2lkIDA/dGhpcy5lbnRyb3B5OkssXz1DLnBsYXliYWNrUmF0ZSxGPV89PT12b2lkIDA/dGhpcy5wbGF5YmFja1JhdGU6XyxHPXtnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6eixlbnRyb3B5OlEscGxheWJhY2tSYXRlOkYsZ2xvYmFsRW50cm9weTp0aGlzLmdsb2JhbEVudHJvcHl9O3RoaXNbZ10ucHVzaChHKX19LHtrZXk6ImZvcmsiLHZhbHVlOmZ1bmN0aW9uKEMpe3JldHVybiBuZXcgRChDLHRoaXMpfX0se2tleToic2Vla0dsb2JhbFRpbWUiLHZhbHVlOmZ1bmN0aW9uKEMpe3ZhciBCPXRoaXMuc2Vla1RpbWVNYXJrKEMpLHo9dGhpc1tnXVtCXSxLPXouZW50cm9weSxRPXoucGxheWJhY2tSYXRlLF89ei5nbG9iYWxUaW1lO3JldHVybiBfKyhDLUspL01hdGguYWJzKFEpfX0se2tleToic2Vla0xvY2FsVGltZSIsdmFsdWU6ZnVuY3Rpb24oQyl7dmFyIEI9dGhpcy5zZWVrVGltZU1hcmsoQyksej10aGlzW2ddW0JdLEs9ei5sb2NhbFRpbWUsUT16LmVudHJvcHksXz16LnBsYXliYWNrUmF0ZTtyZXR1cm4gXz4wP0srKEMtUSk6Sy0oQy1RKX19LHtrZXk6InNlZWtUaW1lTWFyayIsdmFsdWU6ZnVuY3Rpb24oQyl7dmFyIEI9dGhpc1tnXSx6PTAsSz1CLmxlbmd0aC0xO2lmKEM8PUJbel0uZW50cm9weSlyZXR1cm4gejtpZihDPj1CW0tdLmVudHJvcHkpcmV0dXJuIEs7Zm9yKHZhciBRPU1hdGguZmxvb3IoKHorSykvMik7UT56JiZRPEs7KXtpZihDPT09QltRXS5lbnRyb3B5KXJldHVybiBRO0M8QltRXS5lbnRyb3B5P0s9UTpDPkJbUV0uZW50cm9weSYmKHo9USksUT1NYXRoLmZsb29yKCh6K0spLzIpfXJldHVybiB6fX0se2tleToidXBkYXRlVGltZXJzIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBDPXRoaXMsQj1bXS5jb25jYXQoKDAsYS5kZWZhdWx0KSh0aGlzW0VdKSk7Qi5mb3JFYWNoKGZ1bmN0aW9uKHope3ZhciBLPSgwLG4uZGVmYXVsdCkoeiwyKSxRPUtbMF0sXz1LWzFdO0NbTF0oXy5oYW5kbGVyLF8udGltZSxRKX0pfX0se2tleToiY2xlYXJUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihSKXtmdW5jdGlvbiBDKEIpe3JldHVybiBSLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gQy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBSLnRvU3RyaW5nKCl9LEN9KGZ1bmN0aW9uKFIpe3ZhciBDPXRoaXNbRV0uZ2V0KFIpO0MmJkMudGltZXJJRCE9bnVsbCYmKHRoaXNbTV0/dGhpc1tNXS5jbGVhclRpbWVvdXQoQy50aW1lcklEKTpjbGVhclRpbWVvdXQoQy50aW1lcklEKSksdGhpc1tFXS5kZWxldGUoUil9KX0se2tleToiY2xlYXJJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oQyl7cmV0dXJuIHRoaXMuY2xlYXJUaW1lb3V0KEMpfX0se2tleToiY2xlYXIiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEM9dGhpcyxCPXRoaXNbRV07W10uY29uY2F0KCgwLGEuZGVmYXVsdCkoQi5rZXlzKCkpKS5mb3JFYWNoKGZ1bmN0aW9uKHope0MuY2xlYXJUaW1lb3V0KHopfSl9fSx7a2V5OiJzZXRUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihDKXt2YXIgQj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9O3JldHVybiB0aGlzW0xdKEMsQil9fSx7a2V5OiJzZXRJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oQyl7dmFyIEI9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOntkZWxheTowfSx6PXRoaXMsSz10aGlzW0xdKGZ1bmN0aW9uIFEoKXt6W0xdKFEsQixLKSxDKCl9LEIpO3JldHVybiBLfX0se2tleTpMLHZhbHVlOmZ1bmN0aW9uKEMsQil7dmFyIHo9dGhpcyxLPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTooMCxtLmRlZmF1bHQpKCJ0aW1lcklEIik7Qj0oMCxPLmZvcm1hdERlbGF5KShCKTt2YXIgUT10aGlzW0VdLmdldChLKSxfPXZvaWQgMCxGPW51bGwsRz12b2lkIDAsWD12b2lkIDA7UT8odGhpcy5jbGVhclRpbWVvdXQoSyksQi5pc0VudHJvcHk/Xz0oQi5kZWxheS0odGhpcy5lbnRyb3B5LVEuc3RhcnRFbnRyb3B5KSkvTWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOl89KEIuZGVsYXktKHRoaXMuY3VycmVudFRpbWUtUS5zdGFydFRpbWUpKS90aGlzLnBsYXliYWNrUmF0ZSxHPVEuc3RhcnRUaW1lLFg9US5zdGFydEVudHJvcHkpOihfPUIuZGVsYXkvKEIuaXNFbnRyb3B5P01hdGguYWJzKHRoaXMucGxheWJhY2tSYXRlKTp0aGlzLnBsYXliYWNrUmF0ZSksRz10aGlzLmN1cnJlbnRUaW1lLFg9dGhpcy5lbnRyb3B5KTt2YXIgWj10aGlzW01dLHR0PVo/Wi5zZXRUaW1lb3V0LmJpbmQoWik6c2V0VGltZW91dCxudD1CLmhlYWRpbmc7cmV0dXJuIVomJm50PT09ITEmJl88MCYmKF89MS8wKSwoaXNGaW5pdGUoXyl8fFopJiYoXz1NYXRoLmNlaWwoXyksdHQhPT1zZXRUaW1lb3V0JiYoXz17ZGVsYXk6XyxoZWFkaW5nOm50fSksRj10dChmdW5jdGlvbigpe3pbRV0uZGVsZXRlKEspLEMoKX0sXykpLHRoaXNbRV0uc2V0KEsse3RpbWVySUQ6RixoYW5kbGVyOkMsdGltZTpCLHN0YXJ0VGltZTpHLHN0YXJ0RW50cm9weTpYfSksS319LHtrZXk6InBhcmVudCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbTV19fSx7a2V5OiJsYXN0VGltZU1hcmsiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2ddW3RoaXNbZ10ubGVuZ3RoLTFdfX0se2tleToiY3VycmVudFRpbWUiLGdldDpmdW5jdGlvbigpe3ZhciBDPXRoaXMubGFzdFRpbWVNYXJrLEI9Qy5sb2NhbFRpbWUsej1DLmdsb2JhbFRpbWU7cmV0dXJuIEIrKHRoaXMuZ2xvYmFsVGltZS16KSp0aGlzLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKEMpe3ZhciBCPXRoaXMsej10aGlzLmN1cnJlbnRUaW1lLEs9QyxRPXRoaXNbRV07dGhpcy5tYXJrVGltZSh7dGltZTpDfSksW10uY29uY2F0KCgwLGEuZGVmYXVsdCkoUSkpLmZvckVhY2goZnVuY3Rpb24oXyl7dmFyIEY9KDAsbi5kZWZhdWx0KShfLDIpLEc9RlswXSxYPUZbMV07aWYoUS5oYXMoRykpe3ZhciBaPVgudGltZSx0dD1aLmlzRW50cm9weSxudD1aLmRlbGF5LHE9Wi5oZWFkaW5nLGh0PVguaGFuZGxlcix1dD1YLnN0YXJ0VGltZTtpZih0dCludD09PTAmJihodCgpLEIuY2xlYXJUaW1lb3V0KEcpKTtlbHNle3ZhciBqPXV0K250OyhudD09PTB8fHEhPT0hMSYmKEsteikqbnQ8PTB8fHo8PWomJmo8PUt8fHo+PWomJmo+PUspJiYoaHQoKSxCLmNsZWFyVGltZW91dChHKSl9fX0pLHRoaXMudXBkYXRlVGltZXJzKCl9fSx7a2V5OiJlbnRyb3B5IixnZXQ6ZnVuY3Rpb24oKXt2YXIgQz10aGlzLmxhc3RUaW1lTWFyayxCPUMuZW50cm9weSx6PUMuZ2xvYmFsRW50cm9weTtyZXR1cm4gQitNYXRoLmFicygodGhpcy5nbG9iYWxFbnRyb3B5LXopKnRoaXMucGxheWJhY2tSYXRlKX0sc2V0OmZ1bmN0aW9uKEMpe2lmKHRoaXMuZW50cm9weT5DKXt2YXIgQj10aGlzLnNlZWtUaW1lTWFyayhDKTt0aGlzW2ddLmxlbmd0aD1CKzF9dGhpcy5tYXJrVGltZSh7ZW50cm9weTpDfSksdGhpcy51cGRhdGVUaW1lcnMoKX19LHtrZXk6Imdsb2JhbEVudHJvcHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW01dP3RoaXNbTV0uZW50cm9weTp0aGlzLmdsb2JhbFRpbWV9fSx7a2V5OiJwbGF5YmFja1JhdGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2JdfSxzZXQ6ZnVuY3Rpb24oQyl7QyE9PXRoaXMucGxheWJhY2tSYXRlJiYodGhpcy5tYXJrVGltZSh7cGxheWJhY2tSYXRlOkN9KSx0aGlzW2JdPUMsdGhpcy51cGRhdGVUaW1lcnMoKSl9fSx7a2V5OiJwYXVzZWQiLGdldDpmdW5jdGlvbigpe2lmKHRoaXMucGxheWJhY2tSYXRlPT09MClyZXR1cm4hMDtmb3IodmFyIEM9dGhpcy5wYXJlbnQ7Qzspe2lmKEMucGxheWJhY2tSYXRlPT09MClyZXR1cm4hMDtDPUMucGFyZW50fXJldHVybiExfX1dKSxEfSgpO2UuZGVmYXVsdD1JfSxmdW5jdGlvbih1LGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPXQoNzcpLG49bChyKSxpPXQoMTI5KSxhPWwoaSk7ZnVuY3Rpb24gbChzKXtyZXR1cm4gcyYmcy5fX2VzTW9kdWxlP3M6e2RlZmF1bHQ6c319ZS5kZWZhdWx0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcyhmLHYpe3ZhciBkPVtdLHA9ITAseT0hMSxQPXZvaWQgMDt0cnl7Zm9yKHZhciB4PSgwLGEuZGVmYXVsdCkoZiksbTshKHA9KG09eC5uZXh0KCkpLmRvbmUpJiYoZC5wdXNoKG0udmFsdWUpLCEodiYmZC5sZW5ndGg9PT12KSk7cD0hMCk7fWNhdGNoKE8pe3k9ITAsUD1PfWZpbmFsbHl7dHJ5eyFwJiZ4LnJldHVybiYmeC5yZXR1cm4oKX1maW5hbGx5e2lmKHkpdGhyb3cgUH19cmV0dXJuIGR9cmV0dXJuIGZ1bmN0aW9uKGYsdil7aWYoQXJyYXkuaXNBcnJheShmKSlyZXR1cm4gZjtpZigoMCxuLmRlZmF1bHQpKE9iamVjdChmKSkpcmV0dXJuIHMoZix2KTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpfSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXtkZWZhdWx0OnQoNzgpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih1LGUsdCl7dCg3OSksdCgxMjUpLHUuZXhwb3J0cz10KDEyNyl9LGZ1bmN0aW9uKHUsZSx0KXt0KDgwKTtmb3IodmFyIHI9dCg5MSksbj10KDk1KSxpPXQoODMpLGE9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLGw9IkNTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCxNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LFNWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LFRleHRUcmFja0xpc3QsVG91Y2hMaXN0Ii5zcGxpdCgiLCIpLHM9MDtzPGwubGVuZ3RoO3MrKyl7dmFyIGY9bFtzXSx2PXJbZl0sZD12JiZ2LnByb3RvdHlwZTtkJiYhZFthXSYmbihkLGEsZiksaVtmXT1pLkFycmF5fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODEpLG49dCg4MiksaT10KDgzKSxhPXQoODQpO3UuZXhwb3J0cz10KDg4KShBcnJheSwiQXJyYXkiLGZ1bmN0aW9uKGwscyl7dGhpcy5fdD1hKGwpLHRoaXMuX2k9MCx0aGlzLl9rPXN9LGZ1bmN0aW9uKCl7dmFyIGw9dGhpcy5fdCxzPXRoaXMuX2ssZj10aGlzLl9pKys7cmV0dXJuIWx8fGY+PWwubGVuZ3RoPyh0aGlzLl90PXZvaWQgMCxuKDEpKTpzPT0ia2V5cyI/bigwLGYpOnM9PSJ2YWx1ZXMiP24oMCxsW2ZdKTpuKDAsW2YsbFtmXV0pfSwidmFsdWVzIiksaS5Bcmd1bWVudHM9aS5BcnJheSxyKCJrZXlzIikscigidmFsdWVzIikscigiZW50cmllcyIpfSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbigpe319LGZ1bmN0aW9uKHUsZSl7dS5leHBvcnRzPWZ1bmN0aW9uKHQscil7cmV0dXJue3ZhbHVlOnIsZG9uZTohIXR9fX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9e319LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDg1KSxuPXQoODcpO3UuZXhwb3J0cz1mdW5jdGlvbihpKXtyZXR1cm4gcihuKGkpKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDg2KTt1LmV4cG9ydHM9T2JqZWN0KCJ6IikucHJvcGVydHlJc0VudW1lcmFibGUoMCk/T2JqZWN0OmZ1bmN0aW9uKG4pe3JldHVybiByKG4pPT0iU3RyaW5nIj9uLnNwbGl0KCIiKTpPYmplY3Qobil9fSxmdW5jdGlvbih1LGUpe3ZhciB0PXt9LnRvU3RyaW5nO3UuZXhwb3J0cz1mdW5jdGlvbihyKXtyZXR1cm4gdC5jYWxsKHIpLnNsaWNlKDgsLTEpfX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodD09bnVsbCl0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNhbGwgbWV0aG9kIG9uICAiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODkpLG49dCg5MCksaT10KDEwNiksYT10KDk1KSxsPXQoODMpLHM9dCgxMDcpLGY9dCgxMjEpLHY9dCgxMjMpLGQ9dCgxMjIpKCJpdGVyYXRvciIpLHA9IShbXS5rZXlzJiYibmV4dCJpbltdLmtleXMoKSkseT0iQEBpdGVyYXRvciIsUD0ia2V5cyIseD0idmFsdWVzIixtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3UuZXhwb3J0cz1mdW5jdGlvbihPLG8saCxjLGcsYixFKXtzKGgsbyxjKTt2YXIgQT1mdW5jdGlvbihGKXtpZighcCYmRiBpbiBEKXJldHVybiBEW0ZdO3N3aXRjaChGKXtjYXNlIFA6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBoKHRoaXMsRil9O2Nhc2UgeDpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGgodGhpcyxGKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBoKHRoaXMsRil9fSxMPW8rIiBJdGVyYXRvciIsTT1nPT14LEk9ITEsRD1PLnByb3RvdHlwZSxSPURbZF18fERbeV18fGcmJkRbZ10sQz1SfHxBKGcpLEI9Zz9NP0EoImVudHJpZXMiKTpDOnZvaWQgMCx6PW89PSJBcnJheSImJkQuZW50cmllc3x8UixLLFEsXztpZih6JiYoXz12KHouY2FsbChuZXcgTykpLF8hPT1PYmplY3QucHJvdG90eXBlJiZfLm5leHQmJihmKF8sTCwhMCksIXImJnR5cGVvZiBfW2RdIT0iZnVuY3Rpb24iJiZhKF8sZCxtKSkpLE0mJlImJlIubmFtZSE9PXgmJihJPSEwLEM9ZnVuY3Rpb24oKXtyZXR1cm4gUi5jYWxsKHRoaXMpfSksKCFyfHxFKSYmKHB8fEl8fCFEW2RdKSYmYShELGQsQyksbFtvXT1DLGxbTF09bSxnKWlmKEs9e3ZhbHVlczpNP0M6QSh4KSxrZXlzOmI/QzpBKFApLGVudHJpZXM6Qn0sRSlmb3IoUSBpbiBLKVEgaW4gRHx8aShELFEsS1tRXSk7ZWxzZSBuKG4uUCtuLkYqKHB8fEkpLG8sSyk7cmV0dXJuIEt9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz0hMH0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLG49dCg5MiksaT10KDkzKSxhPXQoOTUpLGw9dCgxMDUpLHM9InByb3RvdHlwZSIsZj1mdW5jdGlvbih2LGQscCl7dmFyIHk9diZmLkYsUD12JmYuRyx4PXYmZi5TLG09diZmLlAsTz12JmYuQixvPXYmZi5XLGg9UD9uOm5bZF18fChuW2RdPXt9KSxjPWhbc10sZz1QP3I6eD9yW2RdOihyW2RdfHx7fSlbc10sYixFLEE7UCYmKHA9ZCk7Zm9yKGIgaW4gcClFPSF5JiZnJiZnW2JdIT09dm9pZCAwLCEoRSYmbChoLGIpKSYmKEE9RT9nW2JdOnBbYl0saFtiXT1QJiZ0eXBlb2YgZ1tiXSE9ImZ1bmN0aW9uIj9wW2JdOk8mJkU/aShBLHIpOm8mJmdbYl09PUE/ZnVuY3Rpb24oTCl7dmFyIE09ZnVuY3Rpb24oSSxELFIpe2lmKHRoaXMgaW5zdGFuY2VvZiBMKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgTDtjYXNlIDE6cmV0dXJuIG5ldyBMKEkpO2Nhc2UgMjpyZXR1cm4gbmV3IEwoSSxEKX1yZXR1cm4gbmV3IEwoSSxELFIpfXJldHVybiBMLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIE1bc109TFtzXSxNfShBKTptJiZ0eXBlb2YgQT09ImZ1bmN0aW9uIj9pKEZ1bmN0aW9uLmNhbGwsQSk6QSxtJiYoKGgudmlydHVhbHx8KGgudmlydHVhbD17fSkpW2JdPUEsdiZmLlImJmMmJiFjW2JdJiZhKGMsYixBKSkpfTtmLkY9MSxmLkc9MixmLlM9NCxmLlA9OCxmLkI9MTYsZi5XPTMyLGYuVT02NCxmLlI9MTI4LHUuZXhwb3J0cz1mfSxmdW5jdGlvbih1LGUpe3ZhciB0PXUuZXhwb3J0cz10eXBlb2Ygd2luZG93PCJ1IiYmd2luZG93Lk1hdGg9PU1hdGg/d2luZG93OnR5cGVvZiBzZWxmPCJ1IiYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oInJldHVybiB0aGlzIikoKTt0eXBlb2YgX19nPT0ibnVtYmVyIiYmKF9fZz10KX0sZnVuY3Rpb24odSxlKXt2YXIgdD11LmV4cG9ydHM9e3ZlcnNpb246IjIuNi4xMSJ9O3R5cGVvZiBfX2U9PSJudW1iZXIiJiYoX19lPXQpfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5NCk7dS5leHBvcnRzPWZ1bmN0aW9uKG4saSxhKXtpZihyKG4pLGk9PT12b2lkIDApcmV0dXJuIG47c3dpdGNoKGEpe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24obCl7cmV0dXJuIG4uY2FsbChpLGwpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKGwscyl7cmV0dXJuIG4uY2FsbChpLGwscyl9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24obCxzLGYpe3JldHVybiBuLmNhbGwoaSxsLHMsZil9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuLmFwcGx5KGksYXJndW1lbnRzKX19fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0eXBlb2YgdCE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IodCsiIGlzIG5vdCBhIGZ1bmN0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTYpLG49dCgxMDQpO3UuZXhwb3J0cz10KDEwMCk/ZnVuY3Rpb24oaSxhLGwpe3JldHVybiByLmYoaSxhLG4oMSxsKSl9OmZ1bmN0aW9uKGksYSxsKXtyZXR1cm4gaVthXT1sLGl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5Nyksbj10KDk5KSxpPXQoMTAzKSxhPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTtlLmY9dCgxMDApP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihzLGYsdil7aWYocihzKSxmPWkoZiwhMCkscih2KSxuKXRyeXtyZXR1cm4gYShzLGYsdil9Y2F0Y2h7fWlmKCJnZXQiaW4gdnx8InNldCJpbiB2KXRocm93IFR5cGVFcnJvcigiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhIik7cmV0dXJuInZhbHVlImluIHYmJihzW2ZdPXYudmFsdWUpLHN9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5OCk7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe2lmKCFyKG4pKXRocm93IFR5cGVFcnJvcihuKyIgaXMgbm90IGFuIG9iamVjdCEiKTtyZXR1cm4gbn19LGZ1bmN0aW9uKHUsZSl7dS5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im9iamVjdCI/dCE9PW51bGw6dHlwZW9mIHQ9PSJmdW5jdGlvbiJ9fSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPSF0KDEwMCkmJiF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQoMTAyKSgiZGl2IiksImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKHUsZSl7dS5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaHtyZXR1cm4hMH19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5OCksbj10KDkxKS5kb2N1bWVudCxpPXIobikmJnIobi5jcmVhdGVFbGVtZW50KTt1LmV4cG9ydHM9ZnVuY3Rpb24oYSl7cmV0dXJuIGk/bi5jcmVhdGVFbGVtZW50KGEpOnt9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTgpO3UuZXhwb3J0cz1mdW5jdGlvbihuLGkpe2lmKCFyKG4pKXJldHVybiBuO3ZhciBhLGw7aWYoaSYmdHlwZW9mKGE9bi50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFyKGw9YS5jYWxsKG4pKXx8dHlwZW9mKGE9bi52YWx1ZU9mKT09ImZ1bmN0aW9uIiYmIXIobD1hLmNhbGwobikpfHwhaSYmdHlwZW9mKGE9bi50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFyKGw9YS5jYWxsKG4pKSlyZXR1cm4gbDt0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpfX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9ZnVuY3Rpb24odCxyKXtyZXR1cm57ZW51bWVyYWJsZTohKHQmMSksY29uZmlndXJhYmxlOiEodCYyKSx3cml0YWJsZTohKHQmNCksdmFsdWU6cn19fSxmdW5jdGlvbih1LGUpe3ZhciB0PXt9Lmhhc093blByb3BlcnR5O3UuZXhwb3J0cz1mdW5jdGlvbihyLG4pe3JldHVybiB0LmNhbGwocixuKX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9dCg5NSl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDEwOCksbj10KDEwNCksaT10KDEyMSksYT17fTt0KDk1KShhLHQoMTIyKSgiaXRlcmF0b3IiKSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSksdS5leHBvcnRzPWZ1bmN0aW9uKGwscyxmKXtsLnByb3RvdHlwZT1yKGEse25leHQ6bigxLGYpfSksaShsLHMrIiBJdGVyYXRvciIpfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTcpLG49dCgxMDkpLGk9dCgxMTkpLGE9dCgxMTYpKCJJRV9QUk9UTyIpLGw9ZnVuY3Rpb24oKXt9LHM9InByb3RvdHlwZSIsZj1mdW5jdGlvbigpe3ZhciB2PXQoMTAyKSgiaWZyYW1lIiksZD1pLmxlbmd0aCxwPSI8Iix5PSI+IixQO2Zvcih2LnN0eWxlLmRpc3BsYXk9Im5vbmUiLHQoMTIwKS5hcHBlbmRDaGlsZCh2KSx2LnNyYz0iamF2YXNjcmlwdDoiLFA9di5jb250ZW50V2luZG93LmRvY3VtZW50LFAub3BlbigpLFAud3JpdGUocCsic2NyaXB0Iit5KyJkb2N1bWVudC5GPU9iamVjdCIrcCsiL3NjcmlwdCIreSksUC5jbG9zZSgpLGY9UC5GO2QtLTspZGVsZXRlIGZbc11baVtkXV07cmV0dXJuIGYoKX07dS5leHBvcnRzPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKGQscCl7dmFyIHk7cmV0dXJuIGQhPT1udWxsPyhsW3NdPXIoZCkseT1uZXcgbCxsW3NdPW51bGwseVthXT1kKTp5PWYoKSxwPT09dm9pZCAwP3k6bih5LHApfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTYpLG49dCg5NyksaT10KDExMCk7dS5leHBvcnRzPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbihsLHMpe24obCk7Zm9yKHZhciBmPWkocyksdj1mLmxlbmd0aCxkPTAscDt2PmQ7KXIuZihsLHA9ZltkKytdLHNbcF0pO3JldHVybiBsfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTExKSxuPXQoMTE5KTt1LmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKGEpe3JldHVybiByKGEsbil9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMDUpLG49dCg4NCksaT10KDExMikoITEpLGE9dCgxMTYpKCJJRV9QUk9UTyIpO3UuZXhwb3J0cz1mdW5jdGlvbihsLHMpe3ZhciBmPW4obCksdj0wLGQ9W10scDtmb3IocCBpbiBmKXAhPWEmJnIoZixwKSYmZC5wdXNoKHApO2Zvcig7cy5sZW5ndGg+djspcihmLHA9c1t2KytdKSYmKH5pKGQscCl8fGQucHVzaChwKSk7cmV0dXJuIGR9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg4NCksbj10KDExMyksaT10KDExNSk7dS5leHBvcnRzPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihsLHMsZil7dmFyIHY9cihsKSxkPW4odi5sZW5ndGgpLHA9aShmLGQpLHk7aWYoYSYmcyE9cyl7Zm9yKDtkPnA7KWlmKHk9dltwKytdLHkhPXkpcmV0dXJuITB9ZWxzZSBmb3IoO2Q+cDtwKyspaWYoKGF8fHAgaW4gdikmJnZbcF09PT1zKXJldHVybiBhfHxwfHwwO3JldHVybiFhJiYtMX19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMTQpLG49TWF0aC5taW47dS5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiBpPjA/bihyKGkpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbih1LGUpe3ZhciB0PU1hdGguY2VpbCxyPU1hdGguZmxvb3I7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiBpc05hTihuPStuKT8wOihuPjA/cjp0KShuKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDExNCksbj1NYXRoLm1heCxpPU1hdGgubWluO3UuZXhwb3J0cz1mdW5jdGlvbihhLGwpe3JldHVybiBhPXIoYSksYTwwP24oYStsLDApOmkoYSxsKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDExNykoImtleXMiKSxuPXQoMTE4KTt1LmV4cG9ydHM9ZnVuY3Rpb24oaSl7cmV0dXJuIHJbaV18fChyW2ldPW4oaSkpfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTIpLG49dCg5MSksaT0iX19jb3JlLWpzX3NoYXJlZF9fIixhPW5baV18fChuW2ldPXt9KTsodS5leHBvcnRzPWZ1bmN0aW9uKGwscyl7cmV0dXJuIGFbbF18fChhW2xdPXMhPT12b2lkIDA/czp7fSl9KSgidmVyc2lvbnMiLFtdKS5wdXNoKHt2ZXJzaW9uOnIudmVyc2lvbixtb2RlOnQoODkpPyJwdXJlIjoiZ2xvYmFsIixjb3B5cmlnaHQ6IsKpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSkifSl9LGZ1bmN0aW9uKHUsZSl7dmFyIHQ9MCxyPU1hdGgucmFuZG9tKCk7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiJTeW1ib2woIi5jb25jYXQobj09PXZvaWQgMD8iIjpuLCIpXyIsKCsrdCtyKS50b1N0cmluZygzNikpfX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9ImNvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZiIuc3BsaXQoIiwiKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLmRvY3VtZW50O3UuZXhwb3J0cz1yJiZyLmRvY3VtZW50RWxlbWVudH0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTYpLmYsbj10KDEwNSksaT10KDEyMikoInRvU3RyaW5nVGFnIik7dS5leHBvcnRzPWZ1bmN0aW9uKGEsbCxzKXthJiYhbihhPXM/YTphLnByb3RvdHlwZSxpKSYmcihhLGkse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpsfSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMTcpKCJ3a3MiKSxuPXQoMTE4KSxpPXQoOTEpLlN5bWJvbCxhPXR5cGVvZiBpPT0iZnVuY3Rpb24iLGw9dS5leHBvcnRzPWZ1bmN0aW9uKHMpe3JldHVybiByW3NdfHwocltzXT1hJiZpW3NdfHwoYT9pOm4pKCJTeW1ib2wuIitzKSl9O2wuc3RvcmU9cn0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTA1KSxuPXQoMTI0KSxpPXQoMTE2KSgiSUVfUFJPVE8iKSxhPU9iamVjdC5wcm90b3R5cGU7dS5leHBvcnRzPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24obCl7cmV0dXJuIGw9bihsKSxyKGwsaSk/bFtpXTp0eXBlb2YgbC5jb25zdHJ1Y3Rvcj09ImZ1bmN0aW9uIiYmbCBpbnN0YW5jZW9mIGwuY29uc3RydWN0b3I/bC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6bCBpbnN0YW5jZW9mIE9iamVjdD9hOm51bGx9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg4Nyk7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiBPYmplY3QocihuKSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMjYpKCEwKTt0KDg4KShTdHJpbmcsIlN0cmluZyIsZnVuY3Rpb24obil7dGhpcy5fdD1TdHJpbmcobiksdGhpcy5faT0wfSxmdW5jdGlvbigpe3ZhciBuPXRoaXMuX3QsaT10aGlzLl9pLGE7cmV0dXJuIGk+PW4ubGVuZ3RoP3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06KGE9cihuLGkpLHRoaXMuX2krPWEubGVuZ3RoLHt2YWx1ZTphLGRvbmU6ITF9KX0pfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMTQpLG49dCg4Nyk7dS5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiBmdW5jdGlvbihhLGwpe3ZhciBzPVN0cmluZyhuKGEpKSxmPXIobCksdj1zLmxlbmd0aCxkLHA7cmV0dXJuIGY8MHx8Zj49dj9pPyIiOnZvaWQgMDooZD1zLmNoYXJDb2RlQXQoZiksZDw1NTI5Nnx8ZD41NjMxOXx8ZisxPT09dnx8KHA9cy5jaGFyQ29kZUF0KGYrMSkpPDU2MzIwfHxwPjU3MzQzP2k/cy5jaGFyQXQoZik6ZDppP3Muc2xpY2UoZixmKzIpOihkLTU1Mjk2PDwxMCkrKHAtNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMjgpLG49dCgxMjIpKCJpdGVyYXRvciIpLGk9dCg4Myk7dS5leHBvcnRzPXQoOTIpLmlzSXRlcmFibGU9ZnVuY3Rpb24oYSl7dmFyIGw9T2JqZWN0KGEpO3JldHVybiBsW25dIT09dm9pZCAwfHwiQEBpdGVyYXRvciJpbiBsfHxpLmhhc093blByb3BlcnR5KHIobCkpfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODYpLG49dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLGk9cihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpPT0iQXJndW1lbnRzIixhPWZ1bmN0aW9uKGwscyl7dHJ5e3JldHVybiBsW3NdfWNhdGNoe319O3UuZXhwb3J0cz1mdW5jdGlvbihsKXt2YXIgcyxmLHY7cmV0dXJuIGw9PT12b2lkIDA/IlVuZGVmaW5lZCI6bD09PW51bGw/Ik51bGwiOnR5cGVvZihmPWEocz1PYmplY3QobCksbikpPT0ic3RyaW5nIj9mOmk/cihzKToodj1yKHMpKT09Ik9iamVjdCImJnR5cGVvZiBzLmNhbGxlZT09ImZ1bmN0aW9uIj8iQXJndW1lbnRzIjp2fX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17ZGVmYXVsdDp0KDEzMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHUsZSx0KXt0KDc5KSx0KDEyNSksdS5leHBvcnRzPXQoMTMxKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTcpLG49dCgxMzIpO3UuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvcj1mdW5jdGlvbihpKXt2YXIgYT1uKGkpO2lmKHR5cGVvZiBhIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihpKyIgaXMgbm90IGl0ZXJhYmxlISIpO3JldHVybiByKGEuY2FsbChpKSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMjgpLG49dCgxMjIpKCJpdGVyYXRvciIpLGk9dCg4Myk7dS5leHBvcnRzPXQoOTIpLmdldEl0ZXJhdG9yTWV0aG9kPWZ1bmN0aW9uKGEpe2lmKGEhPW51bGwpcmV0dXJuIGFbbl18fGFbIkBAaXRlcmF0b3IiXXx8aVtyKGEpXX19LGZ1bmN0aW9uKHUsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIHI9dCgxMzQpLG49aShyKTtmdW5jdGlvbiBpKGEpe3JldHVybiBhJiZhLl9fZXNNb2R1bGU/YTp7ZGVmYXVsdDphfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oYSl7aWYoQXJyYXkuaXNBcnJheShhKSl7Zm9yKHZhciBsPTAscz1BcnJheShhLmxlbmd0aCk7bDxhLmxlbmd0aDtsKyspc1tsXT1hW2xdO3JldHVybiBzfWVsc2UgcmV0dXJuKDAsbi5kZWZhdWx0KShhKX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih1LGUsdCl7dCgxMjUpLHQoMTM2KSx1LmV4cG9ydHM9dCg5MikuQXJyYXkuZnJvbX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTMpLG49dCg5MCksaT10KDEyNCksYT10KDEzNyksbD10KDEzOCkscz10KDExMyksZj10KDEzOSksdj10KDEzMik7bihuLlMrbi5GKiF0KDE0MCkoZnVuY3Rpb24oZCl7QXJyYXkuZnJvbShkKX0pLCJBcnJheSIse2Zyb206ZnVuY3Rpb24ocCl7dmFyIHk9aShwKSxQPXR5cGVvZiB0aGlzPT0iZnVuY3Rpb24iP3RoaXM6QXJyYXkseD1hcmd1bWVudHMubGVuZ3RoLG09eD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsTz1tIT09dm9pZCAwLG89MCxoPXYoeSksYyxnLGIsRTtpZihPJiYobT1yKG0seD4yP2FyZ3VtZW50c1syXTp2b2lkIDAsMikpLGghPW51bGwmJiEoUD09QXJyYXkmJmwoaCkpKWZvcihFPWguY2FsbCh5KSxnPW5ldyBQOyEoYj1FLm5leHQoKSkuZG9uZTtvKyspZihnLG8sTz9hKEUsbSxbYi52YWx1ZSxvXSwhMCk6Yi52YWx1ZSk7ZWxzZSBmb3IoYz1zKHkubGVuZ3RoKSxnPW5ldyBQKGMpO2M+bztvKyspZihnLG8sTz9tKHlbb10sbyk6eVtvXSk7cmV0dXJuIGcubGVuZ3RoPW8sZ319KX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTcpO3UuZXhwb3J0cz1mdW5jdGlvbihuLGksYSxsKXt0cnl7cmV0dXJuIGw/aShyKGEpWzBdLGFbMV0pOmkoYSl9Y2F0Y2goZil7dmFyIHM9bi5yZXR1cm47dGhyb3cgcyE9PXZvaWQgMCYmcihzLmNhbGwobikpLGZ9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODMpLG49dCgxMjIpKCJpdGVyYXRvciIpLGk9QXJyYXkucHJvdG90eXBlO3UuZXhwb3J0cz1mdW5jdGlvbihhKXtyZXR1cm4gYSE9PXZvaWQgMCYmKHIuQXJyYXk9PT1hfHxpW25dPT09YSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5Niksbj10KDEwNCk7dS5leHBvcnRzPWZ1bmN0aW9uKGksYSxsKXthIGluIGk/ci5mKGksYSxuKDAsbCkpOmlbYV09bH19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDEyMikoIml0ZXJhdG9yIiksbj0hMTt0cnl7dmFyIGk9WzddW3JdKCk7aS5yZXR1cm49ZnVuY3Rpb24oKXtuPSEwfSxBcnJheS5mcm9tKGksZnVuY3Rpb24oKXt0aHJvdyAyfSl9Y2F0Y2h7fXUuZXhwb3J0cz1mdW5jdGlvbihhLGwpe2lmKCFsJiYhbilyZXR1cm4hMTt2YXIgcz0hMTt0cnl7dmFyIGY9WzddLHY9ZltyXSgpO3YubmV4dD1mdW5jdGlvbigpe3JldHVybntkb25lOnM9ITB9fSxmW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHZ9LGEoZil9Y2F0Y2h7fXJldHVybiBzfX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17ZGVmYXVsdDp0KDE0MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHUsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTQ0KSx0KDE1NyksdCgxNjApLHQoMTYyKSx1LmV4cG9ydHM9dCg5MikuTWFwfSxmdW5jdGlvbih1LGUpe30sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTQ1KSxuPXQoMTUxKSxpPSJNYXAiO3UuZXhwb3J0cz10KDE1MikoaSxmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYSh0aGlzLGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKX19LHtnZXQ6ZnVuY3Rpb24obCl7dmFyIHM9ci5nZXRFbnRyeShuKHRoaXMsaSksbCk7cmV0dXJuIHMmJnMudn0sc2V0OmZ1bmN0aW9uKGwscyl7cmV0dXJuIHIuZGVmKG4odGhpcyxpKSxsPT09MD8wOmwscyl9fSxyLCEwKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTYpLmYsbj10KDEwOCksaT10KDE0NiksYT10KDkzKSxsPXQoMTQ3KSxzPXQoMTQ4KSxmPXQoODgpLHY9dCg4MiksZD10KDE0OSkscD10KDEwMCkseT10KDE1MCkuZmFzdEtleSxQPXQoMTUxKSx4PXA/Il9zIjoic2l6ZSIsbT1mdW5jdGlvbihPLG8pe3ZhciBoPXkobyksYztpZihoIT09IkYiKXJldHVybiBPLl9pW2hdO2ZvcihjPU8uX2Y7YztjPWMubilpZihjLms9PW8pcmV0dXJuIGN9O3UuZXhwb3J0cz17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24oTyxvLGgsYyl7dmFyIGc9TyhmdW5jdGlvbihiLEUpe2woYixnLG8sIl9pIiksYi5fdD1vLGIuX2k9bihudWxsKSxiLl9mPXZvaWQgMCxiLl9sPXZvaWQgMCxiW3hdPTAsRSE9bnVsbCYmcyhFLGgsYltjXSxiKX0pO3JldHVybiBpKGcucHJvdG90eXBlLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgRT1QKHRoaXMsbyksQT1FLl9pLEw9RS5fZjtMO0w9TC5uKUwucj0hMCxMLnAmJihMLnA9TC5wLm49dm9pZCAwKSxkZWxldGUgQVtMLmldO0UuX2Y9RS5fbD12b2lkIDAsRVt4XT0wfSxkZWxldGU6ZnVuY3Rpb24oYil7dmFyIEU9UCh0aGlzLG8pLEE9bShFLGIpO2lmKEEpe3ZhciBMPUEubixNPUEucDtkZWxldGUgRS5faVtBLmldLEEucj0hMCxNJiYoTS5uPUwpLEwmJihMLnA9TSksRS5fZj09QSYmKEUuX2Y9TCksRS5fbD09QSYmKEUuX2w9TSksRVt4XS0tfXJldHVybiEhQX0sZm9yRWFjaDpmdW5jdGlvbihFKXtQKHRoaXMsbyk7Zm9yKHZhciBBPWEoRSxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKSxMO0w9TD9MLm46dGhpcy5fZjspZm9yKEEoTC52LEwuayx0aGlzKTtMJiZMLnI7KUw9TC5wfSxoYXM6ZnVuY3Rpb24oRSl7cmV0dXJuISFtKFAodGhpcyxvKSxFKX19KSxwJiZyKGcucHJvdG90eXBlLCJzaXplIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFAodGhpcyxvKVt4XX19KSxnfSxkZWY6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPW0oTyxvKSxnLGI7cmV0dXJuIGM/Yy52PWg6KE8uX2w9Yz17aTpiPXkobywhMCksazpvLHY6aCxwOmc9Ty5fbCxuOnZvaWQgMCxyOiExfSxPLl9mfHwoTy5fZj1jKSxnJiYoZy5uPWMpLE9beF0rKyxiIT09IkYiJiYoTy5faVtiXT1jKSksT30sZ2V0RW50cnk6bSxzZXRTdHJvbmc6ZnVuY3Rpb24oTyxvLGgpe2YoTyxvLGZ1bmN0aW9uKGMsZyl7dGhpcy5fdD1QKGMsbyksdGhpcy5faz1nLHRoaXMuX2w9dm9pZCAwfSxmdW5jdGlvbigpe2Zvcih2YXIgYz10aGlzLGc9Yy5fayxiPWMuX2w7YiYmYi5yOyliPWIucDtyZXR1cm4hYy5fdHx8IShjLl9sPWI9Yj9iLm46Yy5fdC5fZik/KGMuX3Q9dm9pZCAwLHYoMSkpOmc9PSJrZXlzIj92KDAsYi5rKTpnPT0idmFsdWVzIj92KDAsYi52KTp2KDAsW2IuayxiLnZdKX0saD8iZW50cmllcyI6InZhbHVlcyIsIWgsITApLGQobyl9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTUpO3UuZXhwb3J0cz1mdW5jdGlvbihuLGksYSl7Zm9yKHZhciBsIGluIGkpYSYmbltsXT9uW2xdPWlbbF06cihuLGwsaVtsXSk7cmV0dXJuIG59fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbih0LHIsbixpKXtpZighKHQgaW5zdGFuY2VvZiByKXx8aSE9PXZvaWQgMCYmaSBpbiB0KXRocm93IFR5cGVFcnJvcihuKyI6IGluY29ycmVjdCBpbnZvY2F0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24odSxkLHQpe3ZhciByPXQoOTMpLG49dCgxMzcpLGk9dCgxMzgpLGE9dCg5NyksbD10KDExMykscz10KDEzMiksZj17fSx2PXt9LGQ9dS5leHBvcnRzPWZ1bmN0aW9uKHAseSxQLHgsbSl7dmFyIE89bT9mdW5jdGlvbigpe3JldHVybiBwfTpzKHApLG89cihQLHgseT8yOjEpLGg9MCxjLGcsYixFO2lmKHR5cGVvZiBPIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihwKyIgaXMgbm90IGl0ZXJhYmxlISIpO2lmKGkoTykpe2ZvcihjPWwocC5sZW5ndGgpO2M+aDtoKyspaWYoRT15P28oYShnPXBbaF0pWzBdLGdbMV0pOm8ocFtoXSksRT09PWZ8fEU9PT12KXJldHVybiBFfWVsc2UgZm9yKGI9Ty5jYWxsKHApOyEoZz1iLm5leHQoKSkuZG9uZTspaWYoRT1uKGIsbyxnLnZhbHVlLHkpLEU9PT1mfHxFPT09dilyZXR1cm4gRX07ZC5CUkVBSz1mLGQuUkVUVVJOPXZ9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkxKSxuPXQoOTIpLGk9dCg5NiksYT10KDEwMCksbD10KDEyMikoInNwZWNpZXMiKTt1LmV4cG9ydHM9ZnVuY3Rpb24ocyl7dmFyIGY9dHlwZW9mIG5bc109PSJmdW5jdGlvbiI/bltzXTpyW3NdO2EmJmYmJiFmW2xdJiZpLmYoZixsLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9fSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMTgpKCJtZXRhIiksbj10KDk4KSxpPXQoMTA1KSxhPXQoOTYpLmYsbD0wLHM9T2JqZWN0LmlzRXh0ZW5zaWJsZXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZj0hdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIHMoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSx2PWZ1bmN0aW9uKHgpe2EoeCxyLHt2YWx1ZTp7aToiTyIrICsrbCx3Ont9fX0pfSxkPWZ1bmN0aW9uKHgsbSl7aWYoIW4oeCkpcmV0dXJuIHR5cGVvZiB4PT0ic3ltYm9sIj94Oih0eXBlb2YgeD09InN0cmluZyI/IlMiOiJQIikreDtpZighaSh4LHIpKXtpZighcyh4KSlyZXR1cm4iRiI7aWYoIW0pcmV0dXJuIkUiO3YoeCl9cmV0dXJuIHhbcl0uaX0scD1mdW5jdGlvbih4LG0pe2lmKCFpKHgscikpe2lmKCFzKHgpKXJldHVybiEwO2lmKCFtKXJldHVybiExO3YoeCl9cmV0dXJuIHhbcl0ud30seT1mdW5jdGlvbih4KXtyZXR1cm4gZiYmUC5ORUVEJiZzKHgpJiYhaSh4LHIpJiZ2KHgpLHh9LFA9dS5leHBvcnRzPXtLRVk6cixORUVEOiExLGZhc3RLZXk6ZCxnZXRXZWFrOnAsb25GcmVlemU6eX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDk4KTt1LmV4cG9ydHM9ZnVuY3Rpb24obixpKXtpZighcihuKXx8bi5fdCE9PWkpdGhyb3cgVHlwZUVycm9yKCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICIraSsiIHJlcXVpcmVkISIpO3JldHVybiBufX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLG49dCg5MCksaT10KDE1MCksYT10KDEwMSksbD10KDk1KSxzPXQoMTQ2KSxmPXQoMTQ4KSx2PXQoMTQ3KSxkPXQoOTgpLHA9dCgxMjEpLHk9dCg5NikuZixQPXQoMTUzKSgwKSx4PXQoMTAwKTt1LmV4cG9ydHM9ZnVuY3Rpb24obSxPLG8saCxjLGcpe3ZhciBiPXJbbV0sRT1iLEE9Yz8ic2V0IjoiYWRkIixMPUUmJkUucHJvdG90eXBlLE09e307cmV0dXJuIXh8fHR5cGVvZiBFIT0iZnVuY3Rpb24ifHwhKGd8fEwuZm9yRWFjaCYmIWEoZnVuY3Rpb24oKXtuZXcgRSgpLmVudHJpZXMoKS5uZXh0KCl9KSk/KEU9aC5nZXRDb25zdHJ1Y3RvcihPLG0sYyxBKSxzKEUucHJvdG90eXBlLG8pLGkuTkVFRD0hMCk6KEU9TyhmdW5jdGlvbihJLEQpe3YoSSxFLG0sIl9jIiksSS5fYz1uZXcgYixEIT1udWxsJiZmKEQsYyxJW0FdLEkpfSksUCgiYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OIi5zcGxpdCgiLCIpLGZ1bmN0aW9uKEkpe3ZhciBEPUk9PSJhZGQifHxJPT0ic2V0IjtJIGluIEwmJiEoZyYmST09ImNsZWFyIikmJmwoRS5wcm90b3R5cGUsSSxmdW5jdGlvbihSLEMpe2lmKHYodGhpcyxFLEkpLCFEJiZnJiYhZChSKSlyZXR1cm4gST09ImdldCI/dm9pZCAwOiExO3ZhciBCPXRoaXMuX2NbSV0oUj09PTA/MDpSLEMpO3JldHVybiBEP3RoaXM6Qn0pfSksZ3x8eShFLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jLnNpemV9fSkpLHAoRSxtKSxNW21dPUUsbihuLkcrbi5XK24uRixNKSxnfHxoLnNldFN0cm9uZyhFLG0sYyksRX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkzKSxuPXQoODUpLGk9dCgxMjQpLGE9dCgxMTMpLGw9dCgxNTQpO3UuZXhwb3J0cz1mdW5jdGlvbihzLGYpe3ZhciB2PXM9PTEsZD1zPT0yLHA9cz09Myx5PXM9PTQsUD1zPT02LHg9cz09NXx8UCxtPWZ8fGw7cmV0dXJuIGZ1bmN0aW9uKE8sbyxoKXtmb3IodmFyIGM9aShPKSxnPW4oYyksYj1yKG8saCwzKSxFPWEoZy5sZW5ndGgpLEE9MCxMPXY/bShPLEUpOmQ/bShPLDApOnZvaWQgMCxNLEk7RT5BO0ErKylpZigoeHx8QSBpbiBnKSYmKE09Z1tBXSxJPWIoTSxBLGMpLHMpKXtpZih2KUxbQV09STtlbHNlIGlmKEkpc3dpdGNoKHMpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIE07Y2FzZSA2OnJldHVybiBBO2Nhc2UgMjpMLnB1c2goTSl9ZWxzZSBpZih5KXJldHVybiExfXJldHVybiBQPy0xOnB8fHk/eTpMfX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDE1NSk7dS5leHBvcnRzPWZ1bmN0aW9uKG4saSl7cmV0dXJuIG5ldyhyKG4pKShpKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDk4KSxuPXQoMTU2KSxpPXQoMTIyKSgic3BlY2llcyIpO3UuZXhwb3J0cz1mdW5jdGlvbihhKXt2YXIgbDtyZXR1cm4gbihhKSYmKGw9YS5jb25zdHJ1Y3Rvcix0eXBlb2YgbD09ImZ1bmN0aW9uIiYmKGw9PT1BcnJheXx8bihsLnByb3RvdHlwZSkpJiYobD12b2lkIDApLHIobCkmJihsPWxbaV0sbD09PW51bGwmJihsPXZvaWQgMCkpKSxsPT09dm9pZCAwP0FycmF5Omx9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg4Nik7dS5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGkpe3JldHVybiByKGkpPT0iQXJyYXkifX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTApO3Ioci5QK3IuUiwiTWFwIix7dG9KU09OOnQoMTU4KSgiTWFwIil9KX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTI4KSxuPXQoMTU5KTt1LmV4cG9ydHM9ZnVuY3Rpb24oaSl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYocih0aGlzKSE9aSl0aHJvdyBUeXBlRXJyb3IoaSsiI3RvSlNPTiBpc24ndCBnZW5lcmljIik7cmV0dXJuIG4odGhpcyl9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTQ4KTt1LmV4cG9ydHM9ZnVuY3Rpb24obixpKXt2YXIgYT1bXTtyZXR1cm4gcihuLCExLGEucHVzaCxhLGkpLGF9fSxmdW5jdGlvbih1LGUsdCl7dCgxNjEpKCJNYXAiKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTApO3UuZXhwb3J0cz1mdW5jdGlvbihuKXtyKHIuUyxuLHtvZjpmdW5jdGlvbigpe2Zvcih2YXIgYT1hcmd1bWVudHMubGVuZ3RoLGw9bmV3IEFycmF5KGEpO2EtLTspbFthXT1hcmd1bWVudHNbYV07cmV0dXJuIG5ldyB0aGlzKGwpfX0pfX0sZnVuY3Rpb24odSxlLHQpe3QoMTYzKSgiTWFwIil9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkwKSxuPXQoOTQpLGk9dCg5MyksYT10KDE0OCk7dS5leHBvcnRzPWZ1bmN0aW9uKGwpe3Ioci5TLGwse2Zyb206ZnVuY3Rpb24oZil7dmFyIHY9YXJndW1lbnRzWzFdLGQscCx5LFA7cmV0dXJuIG4odGhpcyksZD12IT09dm9pZCAwLGQmJm4odiksZj09bnVsbD9uZXcgdGhpczoocD1bXSxkPyh5PTAsUD1pKHYsYXJndW1lbnRzWzJdLDIpLGEoZiwhMSxmdW5jdGlvbih4KXtwLnB1c2goUCh4LHkrKykpfSkpOmEoZiwhMSxwLnB1c2gscCksbmV3IHRoaXMocCkpfX0pfX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17ZGVmYXVsdDp0KDE2NSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHUsZSx0KXt0KDE2NiksdS5leHBvcnRzPXQoOTIpLk9iamVjdC5hc3NpZ259LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkwKTtyKHIuUytyLkYsIk9iamVjdCIse2Fzc2lnbjp0KDE2Nyl9KX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTAwKSxuPXQoMTEwKSxpPXQoMTY4KSxhPXQoMTY5KSxsPXQoMTI0KSxzPXQoODUpLGY9T2JqZWN0LmFzc2lnbjt1LmV4cG9ydHM9IWZ8fHQoMTAxKShmdW5jdGlvbigpe3ZhciB2PXt9LGQ9e30scD1TeW1ib2woKSx5PSJhYmNkZWZnaGlqa2xtbm9wcXJzdCI7cmV0dXJuIHZbcF09Nyx5LnNwbGl0KCIiKS5mb3JFYWNoKGZ1bmN0aW9uKFApe2RbUF09UH0pLGYoe30sdilbcF0hPTd8fE9iamVjdC5rZXlzKGYoe30sZCkpLmpvaW4oIiIpIT15fSk/ZnVuY3Rpb24oZCxwKXtmb3IodmFyIHk9bChkKSxQPWFyZ3VtZW50cy5sZW5ndGgseD0xLG09aS5mLE89YS5mO1A+eDspZm9yKHZhciBvPXMoYXJndW1lbnRzW3grK10pLGg9bT9uKG8pLmNvbmNhdChtKG8pKTpuKG8pLGM9aC5sZW5ndGgsZz0wLGI7Yz5nOyliPWhbZysrXSwoIXJ8fE8uY2FsbChvLGIpKSYmKHlbYl09b1tiXSk7cmV0dXJuIHl9OmZ9LGZ1bmN0aW9uKHUsZSl7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LGZ1bmN0aW9uKHUsZSl7ZS5mPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlfSxmdW5jdGlvbih1LGUsdCl7ZS5fX2VzTW9kdWxlPSEwLGUuZGVmYXVsdD1mdW5jdGlvbihyLG4pe2lmKCEociBpbnN0YW5jZW9mIG4pKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfX0sZnVuY3Rpb24odSxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgcj10KDE3Miksbj1pKHIpO2Z1bmN0aW9uIGkoYSl7cmV0dXJuIGEmJmEuX19lc01vZHVsZT9hOntkZWZhdWx0OmF9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGEobCxzKXtmb3IodmFyIGY9MDtmPHMubGVuZ3RoO2YrKyl7dmFyIHY9c1tmXTt2LmVudW1lcmFibGU9di5lbnVtZXJhYmxlfHwhMSx2LmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gdiYmKHYud3JpdGFibGU9ITApLCgwLG4uZGVmYXVsdCkobCx2LmtleSx2KX19cmV0dXJuIGZ1bmN0aW9uKGwscyxmKXtyZXR1cm4gcyYmYShsLnByb3RvdHlwZSxzKSxmJiZhKGwsZiksbH19KCl9LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9e2RlZmF1bHQ6dCgxNzMpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih1LGUsdCl7dCgxNzQpO3ZhciByPXQoOTIpLk9iamVjdDt1LmV4cG9ydHM9ZnVuY3Rpb24oaSxhLGwpe3JldHVybiByLmRlZmluZVByb3BlcnR5KGksYSxsKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkwKTtyKHIuUytyLkYqIXQoMTAwKSwiT2JqZWN0Iix7ZGVmaW5lUHJvcGVydHk6dCg5NikuZn0pfSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXtkZWZhdWx0OnQoMTc2KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odSxlLHQpe3QoMTc3KSx0KDE0MyksdCgxODQpLHQoMTg1KSx1LmV4cG9ydHM9dCg5MikuU3ltYm9sfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MSksbj10KDEwNSksaT10KDEwMCksYT10KDkwKSxsPXQoMTA2KSxzPXQoMTUwKS5LRVksZj10KDEwMSksdj10KDExNyksZD10KDEyMSkscD10KDExOCkseT10KDEyMiksUD10KDE3OCkseD10KDE3OSksbT10KDE4MCksTz10KDE1Niksbz10KDk3KSxoPXQoOTgpLGM9dCgxMjQpLGc9dCg4NCksYj10KDEwMyksRT10KDEwNCksQT10KDEwOCksTD10KDE4MSksTT10KDE4MyksST10KDE2OCksRD10KDk2KSxSPXQoMTEwKSxDPU0uZixCPUQuZix6PUwuZixLPXIuU3ltYm9sLFE9ci5KU09OLF89USYmUS5zdHJpbmdpZnksRj0icHJvdG90eXBlIixHPXkoIl9oaWRkZW4iKSxYPXkoInRvUHJpbWl0aXZlIiksWj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSx0dD12KCJzeW1ib2wtcmVnaXN0cnkiKSxudD12KCJzeW1ib2xzIikscT12KCJvcC1zeW1ib2xzIiksaHQ9T2JqZWN0W0ZdLHV0PXR5cGVvZiBLPT0iZnVuY3Rpb24iJiYhIUkuZixqPXIuUU9iamVjdCxXPSFqfHwhaltGXXx8IWpbRl0uZmluZENoaWxkLFY9aSYmZihmdW5jdGlvbigpe3JldHVybiBBKEIoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQih0aGlzLCJhIix7dmFsdWU6N30pLmF9fSkpLmEhPTd9KT9mdW5jdGlvbihvdCxzdCxjdCl7dmFyIG10PUMoaHQsc3QpO210JiZkZWxldGUgaHRbc3RdLEIob3Qsc3QsY3QpLG10JiZvdCE9PWh0JiZCKGh0LHN0LG10KX06QixKPWZ1bmN0aW9uKG90KXt2YXIgc3Q9bnRbb3RdPUEoS1tGXSk7cmV0dXJuIHN0Ll9rPW90LHN0fSxOPXV0JiZ0eXBlb2YgSy5pdGVyYXRvcj09InN5bWJvbCI/ZnVuY3Rpb24ob3Qpe3JldHVybiB0eXBlb2Ygb3Q9PSJzeW1ib2wifTpmdW5jdGlvbihvdCl7cmV0dXJuIG90IGluc3RhbmNlb2YgS30sJD1mdW5jdGlvbihzdCxjdCxtdCl7cmV0dXJuIHN0PT09aHQmJiQocSxjdCxtdCksbyhzdCksY3Q9YihjdCwhMCksbyhtdCksbihudCxjdCk/KG10LmVudW1lcmFibGU/KG4oc3QsRykmJnN0W0ddW2N0XSYmKHN0W0ddW2N0XT0hMSksbXQ9QShtdCx7ZW51bWVyYWJsZTpFKDAsITEpfSkpOihuKHN0LEcpfHxCKHN0LEcsRSgxLHt9KSksc3RbR11bY3RdPSEwKSxWKHN0LGN0LG10KSk6QihzdCxjdCxtdCl9LFM9ZnVuY3Rpb24oc3QsY3Qpe28oc3QpO2Zvcih2YXIgbXQ9bShjdD1nKGN0KSksdnQ9MCxndD1tdC5sZW5ndGgsU3Q7Z3Q+dnQ7KSQoc3QsU3Q9bXRbdnQrK10sY3RbU3RdKTtyZXR1cm4gc3R9LFQ9ZnVuY3Rpb24oc3QsY3Qpe3JldHVybiBjdD09PXZvaWQgMD9BKHN0KTpTKEEoc3QpLGN0KX0sdz1mdW5jdGlvbihzdCl7dmFyIGN0PVouY2FsbCh0aGlzLHN0PWIoc3QsITApKTtyZXR1cm4gdGhpcz09PWh0JiZuKG50LHN0KSYmIW4ocSxzdCk/ITE6Y3R8fCFuKHRoaXMsc3QpfHwhbihudCxzdCl8fG4odGhpcyxHKSYmdGhpc1tHXVtzdF0/Y3Q6ITB9LFU9ZnVuY3Rpb24oc3QsY3Qpe2lmKHN0PWcoc3QpLGN0PWIoY3QsITApLCEoc3Q9PT1odCYmbihudCxjdCkmJiFuKHEsY3QpKSl7dmFyIG10PUMoc3QsY3QpO3JldHVybiBtdCYmbihudCxjdCkmJiEobihzdCxHKSYmc3RbR11bY3RdKSYmKG10LmVudW1lcmFibGU9ITApLG10fX0sSD1mdW5jdGlvbihzdCl7Zm9yKHZhciBjdD16KGcoc3QpKSxtdD1bXSx2dD0wLGd0O2N0Lmxlbmd0aD52dDspIW4obnQsZ3Q9Y3RbdnQrK10pJiZndCE9RyYmZ3QhPXMmJm10LnB1c2goZ3QpO3JldHVybiBtdH0sWT1mdW5jdGlvbihzdCl7Zm9yKHZhciBjdD1zdD09PWh0LG10PXooY3Q/cTpnKHN0KSksdnQ9W10sZ3Q9MCxTdDttdC5sZW5ndGg+Z3Q7KW4obnQsU3Q9bXRbZ3QrK10pJiYoIWN0fHxuKGh0LFN0KSkmJnZ0LnB1c2gobnRbU3RdKTtyZXR1cm4gdnR9O3V0fHwoSz1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBLKXRocm93IFR5cGVFcnJvcigiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yISIpO3ZhciBzdD1wKGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKSxjdD1mdW5jdGlvbihtdCl7dGhpcz09PWh0JiZjdC5jYWxsKHEsbXQpLG4odGhpcyxHKSYmbih0aGlzW0ddLHN0KSYmKHRoaXNbR11bc3RdPSExKSxWKHRoaXMsc3QsRSgxLG10KSl9O3JldHVybiBpJiZXJiZWKGh0LHN0LHtjb25maWd1cmFibGU6ITAsc2V0OmN0fSksSihzdCl9LGwoS1tGXSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2t9KSxNLmY9VSxELmY9JCx0KDE4MikuZj1MLmY9SCx0KDE2OSkuZj13LEkuZj1ZLGkmJiF0KDg5KSYmbChodCwicHJvcGVydHlJc0VudW1lcmFibGUiLHcsITApLFAuZj1mdW5jdGlvbihvdCl7cmV0dXJuIEooeShvdCkpfSksYShhLkcrYS5XK2EuRiohdXQse1N5bWJvbDpLfSk7Zm9yKHZhciBrPSJoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcyIuc3BsaXQoIiwiKSxydD0wO2subGVuZ3RoPnJ0Oyl5KGtbcnQrK10pO2Zvcih2YXIgaXQ9Uih5LnN0b3JlKSxsdD0wO2l0Lmxlbmd0aD5sdDspeChpdFtsdCsrXSk7YShhLlMrYS5GKiF1dCwiU3ltYm9sIix7Zm9yOmZ1bmN0aW9uKG90KXtyZXR1cm4gbih0dCxvdCs9IiIpP3R0W290XTp0dFtvdF09SyhvdCl9LGtleUZvcjpmdW5jdGlvbihzdCl7aWYoIU4oc3QpKXRocm93IFR5cGVFcnJvcihzdCsiIGlzIG5vdCBhIHN5bWJvbCEiKTtmb3IodmFyIGN0IGluIHR0KWlmKHR0W2N0XT09PXN0KXJldHVybiBjdH0sdXNlU2V0dGVyOmZ1bmN0aW9uKCl7Vz0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7Vz0hMX19KSxhKGEuUythLkYqIXV0LCJPYmplY3QiLHtjcmVhdGU6VCxkZWZpbmVQcm9wZXJ0eTokLGRlZmluZVByb3BlcnRpZXM6UyxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6VSxnZXRPd25Qcm9wZXJ0eU5hbWVzOkgsZ2V0T3duUHJvcGVydHlTeW1ib2xzOll9KTt2YXIgZnQ9ZihmdW5jdGlvbigpe0kuZigxKX0pO2EoYS5TK2EuRipmdCwiT2JqZWN0Iix7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKHN0KXtyZXR1cm4gSS5mKGMoc3QpKX19KSxRJiZhKGEuUythLkYqKCF1dHx8ZihmdW5jdGlvbigpe3ZhciBvdD1LKCk7cmV0dXJuIF8oW290XSkhPSJbbnVsbF0ifHxfKHthOm90fSkhPSJ7fSJ8fF8oT2JqZWN0KG90KSkhPSJ7fSJ9KSksIkpTT04iLHtzdHJpbmdpZnk6ZnVuY3Rpb24oc3Qpe2Zvcih2YXIgY3Q9W3N0XSxtdD0xLHZ0LGd0O2FyZ3VtZW50cy5sZW5ndGg+bXQ7KWN0LnB1c2goYXJndW1lbnRzW210KytdKTtpZihndD12dD1jdFsxXSwhKCFoKHZ0KSYmc3Q9PT12b2lkIDB8fE4oc3QpKSlyZXR1cm4gTyh2dCl8fCh2dD1mdW5jdGlvbihTdCxBdCl7aWYodHlwZW9mIGd0PT0iZnVuY3Rpb24iJiYoQXQ9Z3QuY2FsbCh0aGlzLFN0LEF0KSksIU4oQXQpKXJldHVybiBBdH0pLGN0WzFdPXZ0LF8uYXBwbHkoUSxjdCl9fSksS1tGXVtYXXx8dCg5NSkoS1tGXSxYLEtbRl0udmFsdWVPZiksZChLLCJTeW1ib2wiKSxkKE1hdGgsIk1hdGgiLCEwKSxkKHIuSlNPTiwiSlNPTiIsITApfSxmdW5jdGlvbih1LGUsdCl7ZS5mPXQoMTIyKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLG49dCg5MiksaT10KDg5KSxhPXQoMTc4KSxsPXQoOTYpLmY7dS5leHBvcnRzPWZ1bmN0aW9uKHMpe3ZhciBmPW4uU3ltYm9sfHwobi5TeW1ib2w9aT97fTpyLlN5bWJvbHx8e30pO3MuY2hhckF0KDApIT0iXyImJiEocyBpbiBmKSYmbChmLHMse3ZhbHVlOmEuZihzKX0pfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTEwKSxuPXQoMTY4KSxpPXQoMTY5KTt1LmV4cG9ydHM9ZnVuY3Rpb24oYSl7dmFyIGw9cihhKSxzPW4uZjtpZihzKWZvcih2YXIgZj1zKGEpLHY9aS5mLGQ9MCxwO2YubGVuZ3RoPmQ7KXYuY2FsbChhLHA9ZltkKytdKSYmbC5wdXNoKHApO3JldHVybiBsfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODQpLG49dCgxODIpLmYsaT17fS50b1N0cmluZyxhPXR5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W10sbD1mdW5jdGlvbihzKXt0cnl7cmV0dXJuIG4ocyl9Y2F0Y2h7cmV0dXJuIGEuc2xpY2UoKX19O3UuZXhwb3J0cy5mPWZ1bmN0aW9uKGYpe3JldHVybiBhJiZpLmNhbGwoZik9PSJbb2JqZWN0IFdpbmRvd10iP2woZik6bihyKGYpKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDExMSksbj10KDExOSkuY29uY2F0KCJsZW5ndGgiLCJwcm90b3R5cGUiKTtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKGEpe3JldHVybiByKGEsbil9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxNjkpLG49dCgxMDQpLGk9dCg4NCksYT10KDEwMyksbD10KDEwNSkscz10KDk5KSxmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPXQoMTAwKT9mOmZ1bmN0aW9uKGQscCl7aWYoZD1pKGQpLHA9YShwLCEwKSxzKXRyeXtyZXR1cm4gZihkLHApfWNhdGNoe31pZihsKGQscCkpcmV0dXJuIG4oIXIuZi5jYWxsKGQscCksZFtwXSl9fSxmdW5jdGlvbih1LGUsdCl7dCgxNzkpKCJhc3luY0l0ZXJhdG9yIil9LGZ1bmN0aW9uKHUsZSx0KXt0KDE3OSkoIm9ic2VydmFibGUiKX0sZnVuY3Rpb24odSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmNyZWF0ZU5vd1RpbWU9cixlLmZvcm1hdERlbGF5PW47ZnVuY3Rpb24gcigpe3ZhciBpPW51bGw7cmV0dXJuIERhdGUubm93P2k9RGF0ZS5ub3c6aT1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKX0saX1mdW5jdGlvbiBuKGkpe3JldHVybiB0eXBlb2YgaT09Im51bWJlciI/aT17ZGVsYXk6aX06ImVudHJvcHkiaW4gaSYmKGk9e2RlbGF5OmkuZW50cm9weSxpc0VudHJvcHk6ITB9KSxpfX0sZnVuY3Rpb24odSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9e2RlZmF1bHQ6ZnVuY3Rpb24obixpLGEsbCxzKXtyZXR1cm4gdHlwZW9mIG49PSJudW1iZXIiJiZ0eXBlb2YgaT09Im51bWJlciI/bisoYS1sKS8ocy1sKSooaS1uKTphLWw+cy1hP2k6bn19fSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUucGFyc2VFYXNpbmc9ZS5FYXNpbmdzPXZvaWQgMDt2YXIgcj10KDc2KSxuPWYociksaT10KDEzMyksYT1mKGkpLGw9dCgxNDEpLHM9ZihsKTtmdW5jdGlvbiBmKE8pe3JldHVybiBPJiZPLl9fZXNNb2R1bGU/Tzp7ZGVmYXVsdDpPfX12YXIgdj10KDE4OSksZD1uZXcgcy5kZWZhdWx0O2Z1bmN0aW9uIHAoKXtmb3IodmFyIE89YXJndW1lbnRzLmxlbmd0aCxvPUFycmF5KE8pLGg9MDtoPE87aCsrKW9baF09YXJndW1lbnRzW2hdO3ZhciBjPWQuZ2V0KG8pO3JldHVybiBjfHwoYz12LmFwcGx5KHZvaWQgMCxvKSxkLnNldChvLGMpLGMpfWZ1bmN0aW9uIHkoTyl7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiJlbmQiO3JldHVybiBmdW5jdGlvbihoLGMpe2Zvcih2YXIgZz0xO2c8Yy5sZW5ndGg7ZysrKXt2YXIgYj1jW2ddLm9mZnNldDtpZihoPD1iKXt2YXIgRT1jW2ctMV0ub2Zmc2V0LEE9YixMPShoLUUpLyhBLUUpLE09MS9PLEk9TC9NO3JldHVybiBvPT09ImVuZCI/ST1NYXRoLmZsb29yKEkpOkk9TWF0aC5jZWlsKEkpLE0qSSooQS1FKStFfX1yZXR1cm4gMH19ZnVuY3Rpb24gUChPKXt2YXIgbz0vXmN1YmljLWJlemllclwoKC4qKVwpLyxoPU8ubWF0Y2gobyk7aWYoaCl7dmFyIGM9aFsxXS50cmltKCk7cmV0dXJuIGM9Yy5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihNKXtyZXR1cm4gcGFyc2VGbG9hdChNLnRyaW0oKSl9KSxwLmFwcGx5KHZvaWQgMCwoMCxhLmRlZmF1bHQpKGMpKX1pZihvPS9ec3RlcHNcKCguKilcKS8saD1PLm1hdGNoKG8pLGgpe3ZhciBnPWhbMV0udHJpbSgpO2c9Zy5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihNKXtyZXR1cm4gTS50cmltKCl9KTt2YXIgYj1nLEU9KDAsbi5kZWZhdWx0KShiLDIpLEE9RVswXSxMPUVbMV07cmV0dXJuIHkocGFyc2VJbnQoQSwxMCksTCl9cmV0dXJuIE99dmFyIHg9e2xpbmVhcjpmdW5jdGlvbihvKXtyZXR1cm4gb30sZWFzZTpwKC4yNSwuMSwuMjUsMSksImVhc2UtaW4iOnAoLjQyLDAsMSwxKSwiZWFzZS1vdXQiOnAoMCwwLC41OCwxKSwiZWFzZS1pbi1vdXQiOnAoLjQyLDAsLjU4LDEpLCJzdGVwLXN0YXJ0Ijp5KDEsInN0YXJ0IiksInN0ZXAtZW5kIjp5KDEsImVuZCIpfTtmdW5jdGlvbiBtKE8pe3JldHVybiB0eXBlb2YgTz09InN0cmluZyI/eFtPXT9PPXhbT106Tz1QKE8pOk8udHlwZT09PSJjdWJpYy1iZXppZXIiP089cC5hcHBseSh2b2lkIDAsKDAsYS5kZWZhdWx0KShPLnZhbHVlKSk6Ty50eXBlPT09InN0ZXBzIiYmKE89eShPLnN0ZXAsTy5wb3MpKSxPfWUuRWFzaW5ncz14LGUucGFyc2VFYXNpbmc9bX0sZnVuY3Rpb24odSxlKXt2YXIgdD00LHI9LjAwMSxuPTFlLTcsaT0xMCxhPTExLGw9MS8oYS0xKSxzPXR5cGVvZiBGbG9hdDMyQXJyYXk9PSJmdW5jdGlvbiI7ZnVuY3Rpb24gZihPLG8pe3JldHVybiAxLTMqbyszKk99ZnVuY3Rpb24gdihPLG8pe3JldHVybiAzKm8tNipPfWZ1bmN0aW9uIGQoTyl7cmV0dXJuIDMqT31mdW5jdGlvbiBwKE8sbyxoKXtyZXR1cm4oKGYobyxoKSpPK3YobyxoKSkqTytkKG8pKSpPfWZ1bmN0aW9uIHkoTyxvLGgpe3JldHVybiAzKmYobyxoKSpPKk8rMip2KG8saCkqTytkKG8pfWZ1bmN0aW9uIFAoTyxvLGgsYyxnKXt2YXIgYixFLEE9MDtkbyBFPW8rKGgtbykvMixiPXAoRSxjLGcpLU8sYj4wP2g9RTpvPUU7d2hpbGUoTWF0aC5hYnMoYik+biYmKytBPGkpO3JldHVybiBFfWZ1bmN0aW9uIHgoTyxvLGgsYyl7Zm9yKHZhciBnPTA7Zzx0OysrZyl7dmFyIGI9eShvLGgsYyk7aWYoYj09PTApcmV0dXJuIG87dmFyIEU9cChvLGgsYyktTztvLT1FL2J9cmV0dXJuIG99ZnVuY3Rpb24gbShPKXtyZXR1cm4gT311LmV4cG9ydHM9ZnVuY3Rpb24obyxoLGMsZyl7aWYoISgwPD1vJiZvPD0xJiYwPD1jJiZjPD0xKSl0aHJvdyBuZXcgRXJyb3IoImJlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZSIpO2lmKG89PT1oJiZjPT09ZylyZXR1cm4gbTtmb3IodmFyIGI9cz9uZXcgRmxvYXQzMkFycmF5KGEpOm5ldyBBcnJheShhKSxFPTA7RTxhOysrRSliW0VdPXAoRSpsLG8sYyk7ZnVuY3Rpb24gQShMKXtmb3IodmFyIE09MCxJPTEsRD1hLTE7SSE9PUQmJmJbSV08PUw7KytJKU0rPWw7LS1JO3ZhciBSPShMLWJbSV0pLyhiW0krMV0tYltJXSksQz1NK1IqbCxCPXkoQyxvLGMpO3JldHVybiBCPj1yP3goTCxDLG8sYyk6Qj09PTA/QzpQKEwsTSxNK2wsbyxjKX1yZXR1cm4gZnVuY3Rpb24oTSl7cmV0dXJuIE09PT0wPzA6TT09PTE/MTpwKEEoTSksaCxnKX19fSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXQoMTkxKSxuPWgociksaT10KDIwNCksYT1oKGkpLGw9dCgxNjQpLHM9aChsKSxmPXQoMTcwKSx2PWgoZiksZD10KDE3MSkscD1oKGQpLHk9dCgxNzUpLFA9aCh5KSx4PXQoNzUpLG09aCh4KSxPPXQoMjA4KSxvPXQoMTg4KTtmdW5jdGlvbiBoKEIpe3JldHVybiBCJiZCLl9fZXNNb2R1bGU/Qjp7ZGVmYXVsdDpCfX12YXIgYz0oMCxQLmRlZmF1bHQpKCJ0aW1pbmciKSxnPSgwLFAuZGVmYXVsdCkoImtleWZyYW1lcyIpLGI9KDAsUC5kZWZhdWx0KSgiaW5pdFN0YXRlIiksRT0oMCxQLmRlZmF1bHQpKCJyZWFkeURlZmVyIiksQT0oMCxQLmRlZmF1bHQpKCJmaW5pc2hlZERlZmVyIiksTD0oMCxQLmRlZmF1bHQpKCJlZmZlY3RzIiksTT0oMCxQLmRlZmF1bHQpKCJhY3RpdmVSZWFkeVRpbWVyIiksST0oMCxQLmRlZmF1bHQpKCJhY3RpdmVGaW5pc2hUaW1lciIpLEQ9KDAsUC5kZWZhdWx0KSgicmVtb3ZlRGVmZXIiKSxSPXtkZWxheTowLGVuZERlbGF5OjAsZmlsbDoiYXV0byIsaXRlcmF0aW9uczoxLHBsYXliYWNrUmF0ZToxLGRpcmVjdGlvbjoibm9ybWFsIixlYXNpbmc6ImxpbmVhciIsZWZmZWN0Om51bGx9LEM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBCKHosSyxRKXt2YXIgXz10aGlzO2lmKCgwLHYuZGVmYXVsdCkodGhpcyxCKSxBcnJheS5pc0FycmF5KHopKXt2YXIgRj1belswXSx6LEtdO3o9RlswXSxLPUZbMV0sUT1GWzJdfXR5cGVvZiBRPT0ibnVtYmVyIiYmKFE9e2R1cmF0aW9uOlF9KSx0aGlzW2NdPSgwLHMuZGVmYXVsdCkoe30sUixRKSx0aGlzW2NdLmVhc2luZz0oMCxvLnBhcnNlRWFzaW5nKSh0aGlzW2NdLmVhc2luZyksdGhpc1tnXT0oMCxPLmNhbGN1bGF0ZUZyYW1lc09mZnNldCkoSyk7dmFyIEc9dGhpc1tnXVt0aGlzW2ddLmxlbmd0aC0xXTt0aGlzW2JdPXt9LCgwLGEuZGVmYXVsdCkoRykuZm9yRWFjaChmdW5jdGlvbihYKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeixYKSYmWCE9PSJlYXNpbmciJiZYIT09Im9mZnNldCImJihfW2JdW1hdPXpbWF0pfSksdGhpc1tnXT10aGlzW2ddLm1hcChmdW5jdGlvbihYKXtyZXR1cm4oMCxzLmRlZmF1bHQpKHt9LF9bYl0sWCl9KSx0aGlzW2ddWzBdLm9mZnNldCE9PTAmJnRoaXNbZ10udW5zaGlmdCgoMCxzLmRlZmF1bHQpKHt9LHRoaXNbYl0se29mZnNldDowfSkpLEcub2Zmc2V0PDEmJnRoaXNbZ10ucHVzaCgoMCxzLmRlZmF1bHQpKHt9LEcse29mZnNldDoxfSkpLHRoaXNbTF09e30sdGhpcy50aW1lbGluZT1udWxsfXJldHVybigwLHAuZGVmYXVsdCkoQixbe2tleToicGF1c2UiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9MH19LHtrZXk6TSx2YWx1ZTpmdW5jdGlvbigpe3ZhciBLPXRoaXM7dGhpc1tFXSYmIXRoaXNbRV0udGltZXJJRCYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU8MD90aGlzW0VdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7S1tFXS5yZXNvbHZlKCksZGVsZXRlIEtbRV19LHtkZWxheTotdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxoZWFkaW5nOiExfSk6dGhpc1tFXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0tbRV0ucmVzb2x2ZSgpLGRlbGV0ZSBLW0VdfSx7ZGVsYXk6MCxpc0VudHJvcHk6ITB9KSl9fSx7a2V5OkksdmFsdWU6ZnVuY3Rpb24oKXt2YXIgSz10aGlzLFE9dGhpc1tjXSxfPVEuZHVyYXRpb24sRj1RLml0ZXJhdGlvbnMsRz1RLmVuZERlbGF5LFg9TWF0aC5jZWlsKF8qRitHLXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUpKzE7dGhpc1tBXSYmIXRoaXNbQV0udGltZXJJRCYmKHRoaXNbQV0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtLW0FdLnJlc29sdmUoKSxLW0RdKEUpLEtbRF0oQSl9LHtkZWxheTpYLGhlYWRpbmc6ITF9KSx0aGlzW0FdLnJldmVyc2VUaW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0tbQV0ucmVzb2x2ZSgpLEtbRF0oRSksS1tEXShBKSxLLnRpbWVsaW5lPW51bGx9LHtkZWxheTotdGhpc1tjXS5kZWxheS0xLGhlYWRpbmc6ITF9KSl9fSx7a2V5OiJwbGF5Iix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIiYmdGhpcy5jYW5jZWwoKSx0aGlzLnBsYXlTdGF0ZT09PSJpZGxlIil7aWYodGhpcy5wbGF5YmFja1JhdGU8PTApcmV0dXJuO3ZhciBLPXRoaXNbY10sUT1LLmRlbGF5LF89Sy5wbGF5YmFja1JhdGUsRj1LLnRpbWVsaW5lO3RoaXMudGltZWxpbmU9bmV3IG0uZGVmYXVsdCh7b3JpZ2luVGltZTpRLHBsYXliYWNrUmF0ZTpffSxGKSx0aGlzW01dKCksdGhpc1tJXSgpfWVsc2UgdGhpcy5wbGF5U3RhdGU9PT0icGF1c2VkIiYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlLHRoaXNbTV0oKSl9fSx7a2V5OkQsdmFsdWU6ZnVuY3Rpb24oSyl7dmFyIFE9dGhpc1tLXSxfPXRoaXMudGltZWxpbmU7USYmXyYmKF8uY2xlYXJUaW1lb3V0KFEudGltZXJJRCksUS5yZXZlcnNlVGltZXJJRCYmXy5jbGVhclRpbWVvdXQoUS5yZXZlcnNlVGltZXJJRCkpLGRlbGV0ZSB0aGlzW0tdfX0se2tleToiY2FuY2VsIix2YWx1ZTpmdW5jdGlvbigpe3RoaXNbRF0oRSksdGhpc1tEXShBKSx0aGlzLnRpbWVsaW5lPW51bGx9fSx7a2V5OiJmaW5pc2giLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU9MS8wL3RoaXMucGxheWJhY2tSYXRlKSx0aGlzW0RdKEUpLHRoaXNbRF0oQSl9fSx7a2V5OiJhcHBseUVmZmVjdHMiLHZhbHVlOmZ1bmN0aW9uKEspe3JldHVybigwLHMuZGVmYXVsdCkodGhpc1tMXSxLKX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbY10ucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oSyl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPUspLHRoaXNbY10ucGxheWJhY2tSYXRlPUt9fSx7a2V5OiJwbGF5U3RhdGUiLGdldDpmdW5jdGlvbigpe3ZhciBLPXRoaXMudGltZWxpbmUsUT10aGlzW2NdLF89US5pdGVyYXRpb25zLEY9US5kdXJhdGlvbixHPVEuZW5kRGVsYXksWD0icnVubmluZyI7aWYoSz09bnVsbClYPSJpZGxlIjtlbHNlIGlmKEsucGF1c2VkKVg9InBhdXNlZCI7ZWxzZSBpZihLLmN1cnJlbnRUaW1lPDApWD0icGVuZGluZyI7ZWxzZXt2YXIgWj1LLmN1cnJlbnRUaW1lLV8qRjtaPjAmJlo8Rz9YPSJwZW5kaW5nIjpaPj1HJiYoWD0iZmluaXNoZWQiKX1yZXR1cm4gWH19LHtrZXk6InByb2dyZXNzIixnZXQ6ZnVuY3Rpb24oKXtpZighdGhpcy50aW1lbGluZSlyZXR1cm4gMDt2YXIgSz10aGlzW2NdLFE9Sy5kdXJhdGlvbixfPUsuaXRlcmF0aW9ucyxGPXRoaXMudGltZWxpbmUsRz10aGlzLnBsYXlTdGF0ZSxYPXZvaWQgMDtpZihHPT09ImlkbGUiKVg9MDtlbHNlIGlmKEc9PT0icGF1c2VkIiYmRi5jdXJyZW50VGltZTwwKVg9MDtlbHNlIGlmKEc9PT0icGVuZGluZyIpaWYoRi5jdXJyZW50VGltZTwwKVg9MDtlbHNle3ZhciBaPUYuc2Vla0xvY2FsVGltZShfKlEpO1g9KDAsTy5wZXJpb2RpY2l0eSkoWixRKVsxXS9RfWVsc2UoRz09PSJydW5uaW5nInx8Rz09PSJwYXVzZWQiKSYmKFg9KDAsTy5wZXJpb2RpY2l0eSkoRi5jdXJyZW50VGltZSxRKVsxXS9RKTtyZXR1cm4gRz09PSJmaW5pc2hlZCImJihYPSgwLE8ucGVyaW9kaWNpdHkpKF8sMSlbMV0pLFh9fSx7a2V5OiJmcmFtZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEs9dGhpcy5wbGF5U3RhdGUsUT10aGlzW2JdLF89dGhpc1tjXS5maWxsO2lmKEs9PT0iaWRsZSIpcmV0dXJuIFE7dmFyIEY9dGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxHPXRoaXNbZ10uc2xpY2UoMCksWD0oMCxPLmdldFByb2dyZXNzKSh0aGlzLnRpbWVsaW5lLHRoaXNbY10sdGhpcy5wcm9ncmVzcyksWj1YLnAsdHQ9WC5pbnZlcnRlZCxudD1RO3JldHVybiBGPDAmJks9PT0icGVuZGluZyI/KF89PT0iYmFja3dhcmRzInx8Xz09PSJib3RoIikmJihudD10dD9HW0cubGVuZ3RoLTFdOkdbMF0pOihLIT09InBlbmRpbmciJiZLIT09ImZpbmlzaGVkInx8Xz09PSJmb3J3YXJkcyJ8fF89PT0iYm90aCIpJiYobnQ9KDAsTy5nZXRDdXJyZW50RnJhbWUpKHRoaXNbY10sRyx0aGlzW0xdLFopKSxudH19LHtrZXk6InRpbWluZyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbY119fSx7a2V5OiJlZmZlY3RzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tMXX19LHtrZXk6ImJhc2VUaW1lbGluZSIsc2V0OmZ1bmN0aW9uKEspe3RoaXNbY10udGltZWxpbmU9S30sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbY10udGltZWxpbmV9fSx7a2V5OiJyZWFkeSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5wcm9taXNlOnRoaXMudGltZWxpbmUmJnRoaXMudGltZWxpbmUuY3VycmVudFRpbWU+PTAmJnRoaXMucGxheVN0YXRlIT09InBhdXNlZCI/bi5kZWZhdWx0LnJlc29sdmUoKToodGhpc1tFXT0oMCxPLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbTV0oKSx0aGlzW0VdP3RoaXNbRV0ucHJvbWlzZTpuLmRlZmF1bHQucmVzb2x2ZSgpKX19LHtrZXk6ImZpbmlzaGVkIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGU9PT0iZmluaXNoZWQiP24uZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbQV18fCh0aGlzW0FdPSgwLE8uZGVmZXIpKCksdGhpcy50aW1lbGluZSYmdGhpc1tJXSgpKSx0aGlzW0FdLnByb21pc2UpfX1dKSxCfSgpO2UuZGVmYXVsdD1DfSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXtkZWZhdWx0OnQoMTkyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odSxlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxOTMpLHQoMjAyKSx0KDIwMyksdS5leHBvcnRzPXQoOTIpLlByb21pc2V9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDg5KSxuPXQoOTEpLGk9dCg5MyksYT10KDEyOCksbD10KDkwKSxzPXQoOTgpLGY9dCg5NCksdj10KDE0NyksZD10KDE0OCkscD10KDE5NCkseT10KDE5NSkuc2V0LFA9dCgxOTcpKCkseD10KDE5OCksbT10KDE5OSksTz10KDIwMCksbz10KDIwMSksaD0iUHJvbWlzZSIsYz1uLlR5cGVFcnJvcixnPW4ucHJvY2VzcyxiPWcmJmcudmVyc2lvbnMsRT1iJiZiLnY4fHwiIixBPW5baF0sTD1hKGcpPT0icHJvY2VzcyIsTT1mdW5jdGlvbigpe30sSSxELFIsQyxCPUQ9eC5mLHo9ISFmdW5jdGlvbigpe3RyeXt2YXIgdHQ9QS5yZXNvbHZlKDEpLG50PSh0dC5jb25zdHJ1Y3Rvcj17fSlbdCgxMjIpKCJzcGVjaWVzIildPWZ1bmN0aW9uKHEpe3EoTSxNKX07cmV0dXJuKEx8fHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQ9PSJmdW5jdGlvbiIpJiZ0dC50aGVuKE0paW5zdGFuY2VvZiBudCYmRS5pbmRleE9mKCI2LjYiKSE9PTAmJk8uaW5kZXhPZigiQ2hyb21lLzY2Iik9PT0tMX1jYXRjaHt9fSgpLEs9ZnVuY3Rpb24odHQpe3ZhciBudDtyZXR1cm4gcyh0dCkmJnR5cGVvZihudD10dC50aGVuKT09ImZ1bmN0aW9uIj9udDohMX0sUT1mdW5jdGlvbih0dCxudCl7aWYoIXR0Ll9uKXt0dC5fbj0hMDt2YXIgcT10dC5fYztQKGZ1bmN0aW9uKCl7Zm9yKHZhciBodD10dC5fdix1dD10dC5fcz09MSxqPTAsVz1mdW5jdGlvbihWKXt2YXIgSj11dD9WLm9rOlYuZmFpbCxOPVYucmVzb2x2ZSwkPVYucmVqZWN0LFM9Vi5kb21haW4sVCx3LFU7dHJ5e0o/KHV0fHwodHQuX2g9PTImJkcodHQpLHR0Ll9oPTEpLEo9PT0hMD9UPWh0OihTJiZTLmVudGVyKCksVD1KKGh0KSxTJiYoUy5leGl0KCksVT0hMCkpLFQ9PT1WLnByb21pc2U/JChjKCJQcm9taXNlLWNoYWluIGN5Y2xlIikpOih3PUsoVCkpP3cuY2FsbChULE4sJCk6TihUKSk6JChodCl9Y2F0Y2goSCl7UyYmIVUmJlMuZXhpdCgpLCQoSCl9fTtxLmxlbmd0aD5qOylXKHFbaisrXSk7dHQuX2M9W10sdHQuX249ITEsbnQmJiF0dC5faCYmXyh0dCl9KX19LF89ZnVuY3Rpb24odHQpe3kuY2FsbChuLGZ1bmN0aW9uKCl7dmFyIG50PXR0Ll92LHE9Rih0dCksaHQsdXQsajtpZihxJiYoaHQ9bShmdW5jdGlvbigpe0w/Zy5lbWl0KCJ1bmhhbmRsZWRSZWplY3Rpb24iLG50LHR0KToodXQ9bi5vbnVuaGFuZGxlZHJlamVjdGlvbik/dXQoe3Byb21pc2U6dHQscmVhc29uOm50fSk6KGo9bi5jb25zb2xlKSYmai5lcnJvciYmai5lcnJvcigiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIixudCl9KSx0dC5faD1MfHxGKHR0KT8yOjEpLHR0Ll9hPXZvaWQgMCxxJiZodC5lKXRocm93IGh0LnZ9KX0sRj1mdW5jdGlvbih0dCl7cmV0dXJuIHR0Ll9oIT09MSYmKHR0Ll9hfHx0dC5fYykubGVuZ3RoPT09MH0sRz1mdW5jdGlvbih0dCl7eS5jYWxsKG4sZnVuY3Rpb24oKXt2YXIgbnQ7TD9nLmVtaXQoInJlamVjdGlvbkhhbmRsZWQiLHR0KToobnQ9bi5vbnJlamVjdGlvbmhhbmRsZWQpJiZudCh7cHJvbWlzZTp0dCxyZWFzb246dHQuX3Z9KX0pfSxYPWZ1bmN0aW9uKHR0KXt2YXIgbnQ9dGhpcztudC5fZHx8KG50Ll9kPSEwLG50PW50Ll93fHxudCxudC5fdj10dCxudC5fcz0yLG50Ll9hfHwobnQuX2E9bnQuX2Muc2xpY2UoKSksUShudCwhMCkpfSxaPWZ1bmN0aW9uKHR0KXt2YXIgbnQ9dGhpcyxxO2lmKCFudC5fZCl7bnQuX2Q9ITAsbnQ9bnQuX3d8fG50O3RyeXtpZihudD09PXR0KXRocm93IGMoIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmIik7KHE9Syh0dCkpP1AoZnVuY3Rpb24oKXt2YXIgaHQ9e193Om50LF9kOiExfTt0cnl7cS5jYWxsKHR0LGkoWixodCwxKSxpKFgsaHQsMSkpfWNhdGNoKHV0KXtYLmNhbGwoaHQsdXQpfX0pOihudC5fdj10dCxudC5fcz0xLFEobnQsITEpKX1jYXRjaChodCl7WC5jYWxsKHtfdzpudCxfZDohMX0saHQpfX19O3p8fChBPWZ1bmN0aW9uKG50KXt2KHRoaXMsQSxoLCJfaCIpLGYobnQpLEkuY2FsbCh0aGlzKTt0cnl7bnQoaShaLHRoaXMsMSksaShYLHRoaXMsMSkpfWNhdGNoKHEpe1guY2FsbCh0aGlzLHEpfX0sST1mdW5jdGlvbihudCl7dGhpcy5fYz1bXSx0aGlzLl9hPXZvaWQgMCx0aGlzLl9zPTAsdGhpcy5fZD0hMSx0aGlzLl92PXZvaWQgMCx0aGlzLl9oPTAsdGhpcy5fbj0hMX0sSS5wcm90b3R5cGU9dCgxNDYpKEEucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKG50LHEpe3ZhciBodD1CKHAodGhpcyxBKSk7cmV0dXJuIGh0Lm9rPXR5cGVvZiBudD09ImZ1bmN0aW9uIj9udDohMCxodC5mYWlsPXR5cGVvZiBxPT0iZnVuY3Rpb24iJiZxLGh0LmRvbWFpbj1MP2cuZG9tYWluOnZvaWQgMCx0aGlzLl9jLnB1c2goaHQpLHRoaXMuX2EmJnRoaXMuX2EucHVzaChodCksdGhpcy5fcyYmUSh0aGlzLCExKSxodC5wcm9taXNlfSxjYXRjaDpmdW5jdGlvbih0dCl7cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsdHQpfX0pLFI9ZnVuY3Rpb24oKXt2YXIgdHQ9bmV3IEk7dGhpcy5wcm9taXNlPXR0LHRoaXMucmVzb2x2ZT1pKFosdHQsMSksdGhpcy5yZWplY3Q9aShYLHR0LDEpfSx4LmY9Qj1mdW5jdGlvbih0dCl7cmV0dXJuIHR0PT09QXx8dHQ9PT1DP25ldyBSKHR0KTpEKHR0KX0pLGwobC5HK2wuVytsLkYqIXose1Byb21pc2U6QX0pLHQoMTIxKShBLGgpLHQoMTQ5KShoKSxDPXQoOTIpW2hdLGwobC5TK2wuRioheixoLHtyZWplY3Q6ZnVuY3Rpb24obnQpe3ZhciBxPUIodGhpcyksaHQ9cS5yZWplY3Q7cmV0dXJuIGh0KG50KSxxLnByb21pc2V9fSksbChsLlMrbC5GKihyfHwheiksaCx7cmVzb2x2ZTpmdW5jdGlvbihudCl7cmV0dXJuIG8ociYmdGhpcz09PUM/QTp0aGlzLG50KX19KSxsKGwuUytsLkYqISh6JiZ0KDE0MCkoZnVuY3Rpb24odHQpe0EuYWxsKHR0KS5jYXRjaChNKX0pKSxoLHthbGw6ZnVuY3Rpb24obnQpe3ZhciBxPXRoaXMsaHQ9QihxKSx1dD1odC5yZXNvbHZlLGo9aHQucmVqZWN0LFc9bShmdW5jdGlvbigpe3ZhciBWPVtdLEo9MCxOPTE7ZChudCwhMSxmdW5jdGlvbigkKXt2YXIgUz1KKyssVD0hMTtWLnB1c2godm9pZCAwKSxOKysscS5yZXNvbHZlKCQpLnRoZW4oZnVuY3Rpb24odyl7VHx8KFQ9ITAsVltTXT13LC0tTnx8dXQoVikpfSxqKX0pLC0tTnx8dXQoVil9KTtyZXR1cm4gVy5lJiZqKFcudiksaHQucHJvbWlzZX0scmFjZTpmdW5jdGlvbihudCl7dmFyIHE9dGhpcyxodD1CKHEpLHV0PWh0LnJlamVjdCxqPW0oZnVuY3Rpb24oKXtkKG50LCExLGZ1bmN0aW9uKFcpe3EucmVzb2x2ZShXKS50aGVuKGh0LnJlc29sdmUsdXQpfSl9KTtyZXR1cm4gai5lJiZ1dChqLnYpLGh0LnByb21pc2V9fSl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDk3KSxuPXQoOTQpLGk9dCgxMjIpKCJzcGVjaWVzIik7dS5leHBvcnRzPWZ1bmN0aW9uKGEsbCl7dmFyIHM9cihhKS5jb25zdHJ1Y3RvcixmO3JldHVybiBzPT09dm9pZCAwfHwoZj1yKHMpW2ldKT09bnVsbD9sOm4oZil9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5Myksbj10KDE5NiksaT10KDEyMCksYT10KDEwMiksbD10KDkxKSxzPWwucHJvY2VzcyxmPWwuc2V0SW1tZWRpYXRlLHY9bC5jbGVhckltbWVkaWF0ZSxkPWwuTWVzc2FnZUNoYW5uZWwscD1sLkRpc3BhdGNoLHk9MCxQPXt9LHg9Im9ucmVhZHlzdGF0ZWNoYW5nZSIsbSxPLG8saD1mdW5jdGlvbigpe3ZhciBnPSt0aGlzO2lmKFAuaGFzT3duUHJvcGVydHkoZykpe3ZhciBiPVBbZ107ZGVsZXRlIFBbZ10sYigpfX0sYz1mdW5jdGlvbihnKXtoLmNhbGwoZy5kYXRhKX07KCFmfHwhdikmJihmPWZ1bmN0aW9uKGIpe2Zvcih2YXIgRT1bXSxBPTE7YXJndW1lbnRzLmxlbmd0aD5BOylFLnB1c2goYXJndW1lbnRzW0ErK10pO3JldHVybiBQWysreV09ZnVuY3Rpb24oKXtuKHR5cGVvZiBiPT0iZnVuY3Rpb24iP2I6RnVuY3Rpb24oYiksRSl9LG0oeSkseX0sdj1mdW5jdGlvbihiKXtkZWxldGUgUFtiXX0sdCg4Nikocyk9PSJwcm9jZXNzIj9tPWZ1bmN0aW9uKGcpe3MubmV4dFRpY2socihoLGcsMSkpfTpwJiZwLm5vdz9tPWZ1bmN0aW9uKGcpe3Aubm93KHIoaCxnLDEpKX06ZD8oTz1uZXcgZCxvPU8ucG9ydDIsTy5wb3J0MS5vbm1lc3NhZ2U9YyxtPXIoby5wb3N0TWVzc2FnZSxvLDEpKTpsLmFkZEV2ZW50TGlzdGVuZXImJnR5cGVvZiBwb3N0TWVzc2FnZT09ImZ1bmN0aW9uIiYmIWwuaW1wb3J0U2NyaXB0cz8obT1mdW5jdGlvbihnKXtsLnBvc3RNZXNzYWdlKGcrIiIsIioiKX0sbC5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixjLCExKSk6eCBpbiBhKCJzY3JpcHQiKT9tPWZ1bmN0aW9uKGcpe2kuYXBwZW5kQ2hpbGQoYSgic2NyaXB0IikpW3hdPWZ1bmN0aW9uKCl7aS5yZW1vdmVDaGlsZCh0aGlzKSxoLmNhbGwoZyl9fTptPWZ1bmN0aW9uKGcpe3NldFRpbWVvdXQocihoLGcsMSksMCl9KSx1LmV4cG9ydHM9e3NldDpmLGNsZWFyOnZ9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbih0LHIsbil7dmFyIGk9bj09PXZvaWQgMDtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gaT90KCk6dC5jYWxsKG4pO2Nhc2UgMTpyZXR1cm4gaT90KHJbMF0pOnQuY2FsbChuLHJbMF0pO2Nhc2UgMjpyZXR1cm4gaT90KHJbMF0sclsxXSk6dC5jYWxsKG4sclswXSxyWzFdKTtjYXNlIDM6cmV0dXJuIGk/dChyWzBdLHJbMV0sclsyXSk6dC5jYWxsKG4sclswXSxyWzFdLHJbMl0pO2Nhc2UgNDpyZXR1cm4gaT90KHJbMF0sclsxXSxyWzJdLHJbM10pOnQuY2FsbChuLHJbMF0sclsxXSxyWzJdLHJbM10pfXJldHVybiB0LmFwcGx5KG4scil9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MSksbj10KDE5NSkuc2V0LGk9ci5NdXRhdGlvbk9ic2VydmVyfHxyLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsYT1yLnByb2Nlc3MsbD1yLlByb21pc2Uscz10KDg2KShhKT09InByb2Nlc3MiO3UuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBmLHYsZCxwPWZ1bmN0aW9uKCl7dmFyIG0sTztmb3IocyYmKG09YS5kb21haW4pJiZtLmV4aXQoKTtmOyl7Tz1mLmZuLGY9Zi5uZXh0O3RyeXtPKCl9Y2F0Y2gobyl7dGhyb3cgZj9kKCk6dj12b2lkIDAsb319dj12b2lkIDAsbSYmbS5lbnRlcigpfTtpZihzKWQ9ZnVuY3Rpb24oKXthLm5leHRUaWNrKHApfTtlbHNlIGlmKGkmJiEoci5uYXZpZ2F0b3ImJnIubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgeT0hMCxQPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTtuZXcgaShwKS5vYnNlcnZlKFAse2NoYXJhY3RlckRhdGE6ITB9KSxkPWZ1bmN0aW9uKCl7UC5kYXRhPXk9IXl9fWVsc2UgaWYobCYmbC5yZXNvbHZlKXt2YXIgeD1sLnJlc29sdmUodm9pZCAwKTtkPWZ1bmN0aW9uKCl7eC50aGVuKHApfX1lbHNlIGQ9ZnVuY3Rpb24oKXtuLmNhbGwocixwKX07cmV0dXJuIGZ1bmN0aW9uKG0pe3ZhciBPPXtmbjptLG5leHQ6dm9pZCAwfTt2JiYodi5uZXh0PU8pLGZ8fChmPU8sZCgpKSx2PU99fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTQpO2Z1bmN0aW9uIG4oaSl7dmFyIGEsbDt0aGlzLnByb21pc2U9bmV3IGkoZnVuY3Rpb24ocyxmKXtpZihhIT09dm9pZCAwfHxsIT09dm9pZCAwKXRocm93IFR5cGVFcnJvcigiQmFkIFByb21pc2UgY29uc3RydWN0b3IiKTthPXMsbD1mfSksdGhpcy5yZXNvbHZlPXIoYSksdGhpcy5yZWplY3Q9cihsKX11LmV4cG9ydHMuZj1mdW5jdGlvbihpKXtyZXR1cm4gbmV3IG4oaSl9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJue2U6ITEsdjp0KCl9fWNhdGNoKHIpe3JldHVybntlOiEwLHY6cn19fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLG49ci5uYXZpZ2F0b3I7dS5leHBvcnRzPW4mJm4udXNlckFnZW50fHwiIn0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTcpLG49dCg5OCksaT10KDE5OCk7dS5leHBvcnRzPWZ1bmN0aW9uKGEsbCl7aWYocihhKSxuKGwpJiZsLmNvbnN0cnVjdG9yPT09YSlyZXR1cm4gbDt2YXIgcz1pLmYoYSksZj1zLnJlc29sdmU7cmV0dXJuIGYobCkscy5wcm9taXNlfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTApLG49dCg5MiksaT10KDkxKSxhPXQoMTk0KSxsPXQoMjAxKTtyKHIuUCtyLlIsIlByb21pc2UiLHtmaW5hbGx5OmZ1bmN0aW9uKHMpe3ZhciBmPWEodGhpcyxuLlByb21pc2V8fGkuUHJvbWlzZSksdj10eXBlb2Ygcz09ImZ1bmN0aW9uIjtyZXR1cm4gdGhpcy50aGVuKHY/ZnVuY3Rpb24oZCl7cmV0dXJuIGwoZixzKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZH0pfTpzLHY/ZnVuY3Rpb24oZCl7cmV0dXJuIGwoZixzKCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBkfSl9OnMpfX0pfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MCksbj10KDE5OCksaT10KDE5OSk7cihyLlMsIlByb21pc2UiLHt0cnk6ZnVuY3Rpb24oYSl7dmFyIGw9bi5mKHRoaXMpLHM9aShhKTtyZXR1cm4ocy5lP2wucmVqZWN0OmwucmVzb2x2ZSkocy52KSxsLnByb21pc2V9fSl9LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9e2RlZmF1bHQ6dCgyMDUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih1LGUsdCl7dCgyMDYpLHUuZXhwb3J0cz10KDkyKS5PYmplY3Qua2V5c30sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTI0KSxuPXQoMTEwKTt0KDIwNykoImtleXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBuKHIoYSkpfX0pfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MCksbj10KDkyKSxpPXQoMTAxKTt1LmV4cG9ydHM9ZnVuY3Rpb24oYSxsKXt2YXIgcz0obi5PYmplY3R8fHt9KVthXXx8T2JqZWN0W2FdLGY9e307ZlthXT1sKHMpLHIoci5TK3IuRippKGZ1bmN0aW9uKCl7cygxKX0pLCJPYmplY3QiLGYpfX0sZnVuY3Rpb24odSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxuPVAociksaT10KDIwOSksYT1QKGkpLGw9dCgxNjQpLHM9UChsKSxmPXQoMTkxKSx2PVAoZik7ZS5kZWZlcj14LGUucGVyaW9kaWNpdHk9bSxlLmNhbGN1bGF0ZUZyYW1lc09mZnNldD1PLGUuZ2V0UHJvZ3Jlc3M9byxlLmdldEN1cnJlbnRGcmFtZT1jO3ZhciBkPXQoMTg4KSxwPXQoMTg3KSx5PVAocCk7ZnVuY3Rpb24gUChnKXtyZXR1cm4gZyYmZy5fX2VzTW9kdWxlP2c6e2RlZmF1bHQ6Z319ZnVuY3Rpb24geCgpe3ZhciBnPXt9O3JldHVybiBnLnByb21pc2U9bmV3IHYuZGVmYXVsdChmdW5jdGlvbihiLEUpe2cucmVzb2x2ZT1iLGcucmVqZWN0PUV9KSxnfWZ1bmN0aW9uIG0oZyxiKXt2YXIgRT1NYXRoLmZsb29yKGcvYiksQT1nLUUqYjtyZXR1cm4gQT09PTAmJkU+MCYmKEE9YixFLS0pLFtFLEFdfWZ1bmN0aW9uIE8oZyl7Zz1nLnNsaWNlKDApO3ZhciBiPWdbMF0sRT1nW2cubGVuZ3RoLTFdO0Uub2Zmc2V0PUUub2Zmc2V0fHwxLGIub2Zmc2V0PWIub2Zmc2V0fHwwO2Zvcih2YXIgQT0wLEw9LTEsTT0wO008Zy5sZW5ndGg7TSsrKXt2YXIgST1nW01dO2lmKEkub2Zmc2V0IT1udWxsKXt2YXIgRD1NLUw7aWYoRD4xKWZvcih2YXIgUj0oSS5vZmZzZXQtQSkvRCxDPTA7QzxELTE7QysrKWdbTCtDKzFdLm9mZnNldD1BK1IqKEMrMSk7QT1JLm9mZnNldCxMPU19aWYoSS5lYXNpbmchPW51bGwmJihJLmVhc2luZz0oMCxkLnBhcnNlRWFzaW5nKShJLmVhc2luZykpLE0+MCl7dmFyIEI9Z1tNXS5lYXNpbmchPW51bGw7Z1tNXT0oMCxzLmRlZmF1bHQpKHt9LGdbTS0xXSxnW01dKSxCfHxkZWxldGUgZ1tNXS5lYXNpbmd9fXJldHVybiBnfWZ1bmN0aW9uIG8oZyxiLEUpe3ZhciBBPWcuY3VycmVudFRpbWUsTD1iLmRpcmVjdGlvbixNPWIuZHVyYXRpb24sST0hMTtpZihMPT09InJldmVyc2UiKUU9MS1FLEk9ITA7ZWxzZSBpZihMPT09ImFsdGVybmF0ZSJ8fEw9PT0iYWx0ZXJuYXRlLXJldmVyc2UiKXt2YXIgRD1NYXRoLmZsb29yKEEvTSk7RT09PTEmJkQtLSxEJTJeTD09PSJhbHRlcm5hdGUtcmV2ZXJzZSImJihFPTEtRSxJPSEwKX1yZXR1cm57cDpFLGludmVydGVkOkl9fWZ1bmN0aW9uIGgoZyxiLEUsQSl7dmFyIEw9e307cmV0dXJuKDAsYS5kZWZhdWx0KShiKS5mb3JFYWNoKGZ1bmN0aW9uKE0pe3ZhciBJPSgwLG4uZGVmYXVsdCkoTSwyKSxEPUlbMF0sUj1JWzFdO2lmKEQhPT0ib2Zmc2V0IiYmRCE9PSJlYXNpbmciKXt2YXIgQz1FW0RdfHxFLmRlZmF1bHQsQj1DKGdbRF0sUixBLGcub2Zmc2V0LGIub2Zmc2V0KTtCIT1udWxsJiYoTFtEXT1CKX19KSxMfWZ1bmN0aW9uIGMoZyxiLEUsQSl7dmFyIEw9Zy5lYXNpbmcsTT1nLmVmZmVjdDtNfHwoRT0oMCxzLmRlZmF1bHQpKHt9LHkuZGVmYXVsdCxFKSk7dmFyIEk9e307QT1MKEEsYik7Zm9yKHZhciBEPTE7RDxiLmxlbmd0aDtEKyspe3ZhciBSPWJbRF0sQz1SLm9mZnNldDtpZihDPj1BfHxEPT09Yi5sZW5ndGgtMSl7dmFyIEI9YltELTFdLHo9Qi5vZmZzZXQsSz1CLmVhc2luZyxRPUE7aWYoSyl7dmFyIF89Qy16O1E9SygoQS16KS9fKSpfK3p9TT9JPU0oQixSLFEseixDKTpJPWgoQixSLEUsUSk7YnJlYWt9fXJldHVybiBJfX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17ZGVmYXVsdDp0KDIxMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHUsZSx0KXt0KDIxMSksdS5leHBvcnRzPXQoOTIpLk9iamVjdC5lbnRyaWVzfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MCksbj10KDIxMikoITApO3Ioci5TLCJPYmplY3QiLHtlbnRyaWVzOmZ1bmN0aW9uKGEpe3JldHVybiBuKGEpfX0pfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMDApLG49dCgxMTApLGk9dCg4NCksYT10KDE2OSkuZjt1LmV4cG9ydHM9ZnVuY3Rpb24obCl7cmV0dXJuIGZ1bmN0aW9uKHMpe2Zvcih2YXIgZj1pKHMpLHY9bihmKSxkPXYubGVuZ3RoLHA9MCx5PVtdLFA7ZD5wOylQPXZbcCsrXSwoIXJ8fGEuY2FsbChmLFApKSYmeS5wdXNoKGw/W1AsZltQXV06ZltQXSk7cmV0dXJuIHl9fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcj1uZXcgTWFwO2Z1bmN0aW9uIG4oYSxsPXt9LHM9W10pe2E9YS50b0xvd2VyQ2FzZSgpO2NvbnN0IGY9ci5nZXQoYSk7aWYoIWYpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBub2RlOiAke2F9YCk7Y29uc3Qgdj1uZXcgZihsKTtyZXR1cm4gcy5mb3JFYWNoKGQ9Pnt2LmFwcGVuZENoaWxkKGQpfSksdn1jb25zdCBpPXtyZWdpc3Rlck5vZGUoYSxsLHM9MTAwKXtpZihsPWwudG9Mb3dlckNhc2UoKSxyLmhhcyhsKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVnaXN0ZXJOb2RlLCAke2x9IGhhcyBiZWVuIHRha2VuLmApO3Iuc2V0KGwsYSksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYS5wcm90b3R5cGUse25vZGVUeXBlOnt2YWx1ZTpzfSx0YWdOYW1lOnt2YWx1ZTpsLnRvVXBwZXJDYXNlKCl9LG5vZGVOYW1lOnt2YWx1ZTpsfSxvd25lckRvY3VtZW50Ont2YWx1ZTppfSxuYW1lc3BhY2VVUkk6e3ZhbHVlOmBodHRwOi8vc3ByaXRlanMuY29tLyR7bH1gfX0pfSxjcmVhdGVFbGVtZW50Om4sY3JlYXRlRWxlbWVudE5TKGEsbCl7cmV0dXJuIG4obCl9LGlzU3ByaXRlTm9kZShhKXtyZXR1cm4gci5oYXMoYS50b0xvd2VyQ2FzZSgpKX19O2UuZGVmYXVsdD1pfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9U3ltYm9sKCJ0eXBlIiksbj1TeW1ib2woImJ1YmJsZXMiKSxpPVN5bWJvbCgib3JpZ2luYWxFdmVudCIpLGE9U3ltYm9sKCJkZXRhaWwiKTtjbGFzcyBse2NvbnN0cnVjdG9yKGYse2J1YmJsZXM6dj1udWxsfT17fSl7aWYodHlwZW9mIGY9PSJzdHJpbmciPyh0aGlzW3JdPWYsdGhpc1tuXT0hIXYpOih0aGlzW3JdPWYudHlwZSx0aGlzW2ldPWYsdGhpc1tuXT12IT1udWxsPyEhdjohIWYuYnViYmxlcyxmLmRldGFpbCYmKHRoaXNbYV09Zi5kZXRhaWwpKSwhdGhpc1tyXSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGV2ZW50IHR5cGUuIik7dGhpcy5jYW5jZWxCdWJibGU9ITF9c2V0T3JpZ2luYWxFdmVudChmKXt0aGlzW2ldPWZ9Z2V0IG9yaWdpbmFsRXZlbnQoKXtyZXR1cm4gdGhpc1tpXX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW3JdfWdldCBidWJibGVzKCl7cmV0dXJuIHRoaXNbbl19Z2V0IGRldGFpbCgpe3JldHVybiB0aGlzW2FdfXN0b3BQcm9wYWdhdGlvbigpe3RoaXMuY2FuY2VsQnViYmxlPSEwfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsInBhcnNlRmlsdGVyU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImFwcGx5RmlsdGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciByPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKGEpe2lmKGE9YS50cmltKCksIWF8fGE9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgbD0vXig/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSskL2kscz1hLm1hdGNoKC8oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrPy9pZyksZj1bXTtyZXR1cm4gcyYmcy5mb3JFYWNoKHY9Pntjb25zdCBkPXYubWF0Y2gobCk7aWYoIWQpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaXRsZXIgc3RyaW5nLiIpO2xldFsscCx5XT1kO3A9cC50b0xvd2VyQ2FzZSgpLHk9eS50cmltKCkubWF0Y2goLyhbXiggKV0rfChbXiggKV0rXCguKlwpKSkoPz1cc3wkKS9nKS5tYXAoKFAseCk9PntsZXQgbTtyZXR1cm4gcD09PSJ1cmwifHxwPT09ImRyb3Atc2hhZG93IiYmeD09PTM/bT1QOm09T2JqZWN0KHIudG9OdW1iZXIpKFApLC8lJC8udGVzdChQKSYmKG0vPTEwMCksbX0pLGYucHVzaCh7dHlwZTpwLGFyZ3M6eX0pfSksZn1mdW5jdGlvbiBpKGEsbCl7YS5jbGVhckZpbHRlcigpLGwmJmwuZm9yRWFjaCgoe3R5cGU6cyxhcmdzOmZ9KT0+e2xldCB2PXM7dj09PSJkcm9wLXNoYWRvdyI/dj0iZHJvcFNoYWRvdyI6dj09PSJodWUtcm90YXRlIiYmKHY9Imh1ZVJvdGF0ZSIpLGFbdl0oLi4uZil9KX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihuLGkpe2lmKCFpKXJldHVybjtjb25zdCBhPW4uZ2V0TGlzdGVuZXJzKCJiZWZvcmVyZW5kZXIiKSxsPW4uZ2V0TGlzdGVuZXJzKCJhZnRlcnJlbmRlciIpO2EubGVuZ3RoJiYhaS5iZWZvcmVSZW5kZXI/aS5iZWZvcmVSZW5kZXI9cz0+e24uZGlzcGF0Y2hFdmVudCh7dHlwZToiYmVmb3JlcmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6c319KX06YS5sZW5ndGh8fChpLmJlZm9yZVJlbmRlcj1udWxsKSxsLmxlbmd0aCYmIWkuYWZ0ZXJSZW5kZXI/aS5hZnRlclJlbmRlcj1zPT57bi5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhZnRlcnJlbmRlciIsZGV0YWlsOntjb250ZXh0OnN9fSl9OmwubGVuZ3RofHwoaS5hZnRlclJlbmRlcj1udWxsKX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDEyKSxuPXQoMjE4KSxpPXQoNzApLGE9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBsPVN5bWJvbCgiYW1vdW50Iikscz1TeW1ib2woIm1lc2hDbG91ZCIpO2NsYXNzIGYgZXh0ZW5kcyBpLmRlZmF1bHR7Y29uc3RydWN0b3IoZCxwPTEpe3N1cGVyKCksdGhpcy5tZXNoTm9kZT1kLGQuY29ubmVjdCh0aGlzKSx0aGlzW2xdPXAsdGhpc1tzXT1udWxsfWdldCBtZXNoQ2xvdWQoKXtjb25zdCBkPXRoaXMubWVzaE5vZGUscD10aGlzW2xdO3JldHVybiF0aGlzW3NdJiZkLm1lc2gmJih0aGlzW3NdPW5ldyByLk1lc2hDbG91ZChkLm1lc2gscCkpLHRoaXNbc119Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5tZXNoTm9kZSYmdGhpcy5tZXNoTm9kZS5pc1Zpc2libGV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2xdfXNldCBhbW91bnQoZCl7dGhpc1tsXT1kLHRoaXNbc10mJih0aGlzW3NdLmFtb3VudD1kKX1icmlnaHRuZXNzKGQscCl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5icmlnaHRuZXNzKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1jb250cmFzdChkLHApe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuY29udHJhc3QoZCxwKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRlbGV0ZShkKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmRlbGV0ZShkKSx0aGlzW2xdLS0sdGhpcy5mb3JjZVVwZGF0ZSgpKX1kcmF3KGQ9W10pe2lmKHN1cGVyLmRyYXcoZCksdGhpcy5tZXNoQ2xvdWQpe2lmKHRoaXMucHJvZ3JhbSl7dGhpcy5tZXNoQ2xvdWQuc2V0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO2NvbnN0IHA9dGhpcy5zaGFkZXJBdHRycztwJiZPYmplY3QuZW50cmllcyhwKS5mb3JFYWNoKChbUCx4XSk9Pnt0aGlzLm1lc2hDbG91ZC5tZXNoLnNldEF0dHJpYnV0ZShQLHgpfSk7Y29uc3QgeT10aGlzLnVuaWZvcm1zO2lmKHRoaXMudW5pZm9ybXMpe2NvbnN0IFA9e307T2JqZWN0LmVudHJpZXMoeSkuZm9yRWFjaCgoW3gsbV0pPT57dHlwZW9mIG09PSJmdW5jdGlvbiImJihtPW0odGhpcyx4KSksUFt4XT1tfSksdGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRVbmlmb3JtcyhQKX19dGhpcy5tZXNoTm9kZS50ZXh0dXJlSW1hZ2UmJk9iamVjdChuLmRyYXdUZXh0dXJlKSh0aGlzLm1lc2hOb2RlLHRoaXMubWVzaE5vZGUubWVzaCksZC5wdXNoKHRoaXMubWVzaENsb3VkKX1yZXR1cm4gZH1nZXRUcmFuc2Zvcm0oZCl7aWYodGhpcy5tZXNoQ2xvdWQpcmV0dXJuIHRoaXMubWVzaENsb3VkLmdldFRyYW5zZm9ybShkKX1ncmF5c2NhbGUoZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmdyYXlzY2FsZShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9aHVlUm90YXRlKGQscCl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5odWVSb3RhdGUoZCxwKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWludmVydChkLHApe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaW52ZXJ0KGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pc1BvaW50Q29sbGlzaW9uKGQscCl7aWYoIXRoaXMubWVzaENsb3VkKXJldHVybiExO2NvbnN0IHk9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoeT09PSJub25lInx8eSE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IFA9ImJvdGgiO3k9PT0idmlzaWJsZUZpbGwiJiYoUD0iZmlsbCIpLHk9PT0idmlzaWJsZVN0cm9rZSImJihQPSJzdHJva2UiKTtmb3IobGV0IHg9MDt4PHRoaXNbbF07eCsrKWlmKCF0aGlzLm1lc2hDbG91ZC5pc1BvaW50Q29sbGlzaW9uKHgsW2QscF0sUCkpcmV0dXJuITE7cmV0dXJuITB9c2V0T3BhY2l0eShkLHApe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQub3BhY2l0eShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9cm90YXRlKGQscCxbeSxQXT1bMCwwXSl7Y29uc3QgeD1NYXRoLlBJKnAvMTgwO2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seTpPfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQucm90YXRlKGQseCxbeSttLFArT10pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2F0dXJhdGUoZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNhdHVyYXRlKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zY2FsZShkLFtwLHk9cF0sW1AseF09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seTpPfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXMsbz0xZS01O01hdGguYWJzKHApPG8mJihwPTEvcD4wP286LW8pLE1hdGguYWJzKHkpPG8mJih5PTEveT4wP286LW8pLHRoaXMubWVzaENsb3VkLnNjYWxlKGQsW3AseV0sW1ArbSx4K09dKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNldENvbG9yVHJhbnNmb3JtKGQscCl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRDb2xvclRyYW5zZm9ybShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0RmlsbENvbG9yKGQscCl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KHApJiYocD1bLi4ucF0scFswXS89MjU1LHBbMV0vPTI1NSxwWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldEZpbGxDb2xvcihkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2VwaWEoZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNlcGlhKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpkLGhlaWdodDpwfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZCxoZWlnaHQ6cH0pLHRoaXMubWVzaE5vZGUuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZCxoZWlnaHQ6cH0pfXNldFN0cm9rZUNvbG9yKGQscCl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KHApJiYocD1bLi4ucF0scFswXS89MjU1LHBbMV0vPTI1NSxwWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldFN0cm9rZUNvbG9yKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRUcmFuc2Zvcm0oZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldFRyYW5zZm9ybShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2tldyhkLFtwLHk9cF0sW1AseF09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seTpPfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQuc2tldyhkLFtwLHldLFtQK20seCtPXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX10cmFuc2Zvcm0oZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNmb3JtQ29sb3IoZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybUNvbG9yKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2xhdGUoZCxbcCx5XSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2xhdGUoZCxbcCx5XSksdGhpcy5mb3JjZVVwZGF0ZSgpKX11cGRhdGVNZXNoKCl7dGhpc1tzXSYmKHRoaXNbc10ubWVzaD10aGlzLm1lc2hOb2RlLm1lc2gsdGhpcy5mb3JjZVVwZGF0ZSgpKX19YS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShmLCJjbG91ZCIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJsb2FkVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJhcHBseVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiY3JlYXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJkZWxldGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImRyYXdUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImxvYWRGcmFtZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDEyKSxuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPXt9O2Z1bmN0aW9uIGEoUCx4KXtpZihpW1BdKXJldHVybiBpW1BdO2NvbnN0IG09ci5FTlYubG9hZEltYWdlKFAse2FsaWFzOngsdXNlSW1hZ2VCaXRtYXA6ITF9KTtyZXR1cm4gbT8/UH1hc3luYyBmdW5jdGlvbiBsKFAseCxtKXtsZXQgTz14O2lmKHR5cGVvZiB4PT0ic3RyaW5nIiYmKE89YSh4KSksTyYmdHlwZW9mIE8udGhlbj09ImZ1bmN0aW9uIiYmKE89YXdhaXQgTykseD09PVAuYXR0cmlidXRlcy50ZXh0dXJlKXtPJiZPLmltYWdlJiYoTy5zb3VyY2VSZWN0JiYoUC5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q9Ty5zb3VyY2VSZWN0KSxQLnRleHR1cmVJbWFnZVJvdGF0ZWQ9ISFPLnJvdGF0ZWQsTz1PLmltYWdlKTtjb25zdHt3aWR0aDpvLGhlaWdodDpoLHRleHR1cmVSZWN0OmN9PVAuYXR0cmlidXRlcyxnPVAudGV4dHVyZUltYWdlO1AudGV4dHVyZUltYWdlPU8sbSYmZyE9PU8mJiFjJiYobz09bnVsbHx8aD09bnVsbCkmJlAudXBkYXRlQ29udG91cnMoKSxQLmZvcmNlVXBkYXRlKCl9cmV0dXJuIE99Y29uc3Qgcz1TeW1ib2woInRleHR1cmVNYXAiKTtmdW5jdGlvbiBmKFAseCl7aWYoeFtzXT14W3NdfHxuZXcgTWFwLHhbc10uaGFzKFApKXJldHVybiB4W3NdLmdldChQKTtjb25zdCBtPXguY3JlYXRlVGV4dHVyZShQKTtyZXR1cm4hL15ibG9iOi8udGVzdChQLnNyYykmJnR5cGVvZiBQLmdldENvbnRleHQhPSJmdW5jdGlvbiImJnhbc10uc2V0KFAsbSksbX1mdW5jdGlvbiB2KFAseCl7aWYoeFtzXSYmeFtzXS5oYXMoUCkpe2NvbnN0IG09eFtzXS5nZXQoUCk7cmV0dXJuIHguZGVsZXRlVGV4dHVyZShtKSx4W3NdLmRlbGV0ZShQKSwhMH1yZXR1cm4hMX1jb25zdCBkPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKTtmdW5jdGlvbiBwKFAseCl7Y29uc3QgbT1QLnRleHR1cmVJbWFnZSBpbnN0YW5jZW9mIFN0cmluZz9TdHJpbmcoUC50ZXh0dXJlSW1hZ2UpOlAudGV4dHVyZUltYWdlLE89UC50ZXh0dXJlSW1hZ2VSb3RhdGVkLG89eC50ZXh0dXJlLGg9UC5yZW5kZXJlcjtpZihtKXtjb25zdCBjPVAub3JpZ2luYWxDb250ZW50UmVjdDtsZXQgZz1QLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q7Y29uc3QgYj1QLmF0dHJpYnV0ZXMudGV4dHVyZVJlcGVhdCxFPVAuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKCFvfHxQW2RdJiZQW2RdIT09aHx8by5pbWFnZSE9PW18fG8ub3B0aW9ucy5yZXBlYXQhPT1ifHwhT2JqZWN0KG4uY29tcGFyZVZhbHVlKShvLm9wdGlvbnMucmVjdCxnKXx8IU9iamVjdChuLmNvbXBhcmVWYWx1ZSkoby5vcHRpb25zLnNyY1JlY3QsRSkpe2NvbnN0IEE9ZihtLGgpO2c/KGdbMF0rPWNbMF0sZ1sxXSs9Y1sxXSk6Zz1jO2xldCBMPW51bGw7byYmIWhbc10uaGFzKG8uaW1hZ2UpJiYoIW8ub3B0aW9uc3x8IW8ub3B0aW9ucy5oaWRkZW4pJiYoTD14LnVuaWZvcm1zLnVfdGV4U2FtcGxlcikseC5zZXRUZXh0dXJlKEEse3JlY3Q6ZyxyZXBlYXQ6YixzcmNSZWN0OkUscm90YXRlZDpPfSksTCYmTC5kZWxldGUmJkwuZGVsZXRlKCksUFtkXT1ofX1lbHNlIGlmKG8pe2xldCBjPW51bGw7IWhbc10uaGFzKG8uaW1hZ2UpJiYoIW8ub3B0aW9uc3x8IW8ub3B0aW9ucy5oaWRkZW4pJiYoYz14LnVuaWZvcm1zLnVfdGV4U2FtcGxlcikseC5zZXRUZXh0dXJlKG51bGwpLGMmJmMuZGVsZXRlJiZjLmRlbGV0ZSgpfX1hc3luYyBmdW5jdGlvbiB5KFAseCl7dHlwZW9mIHg9PSJzdHJpbmciJiYoeD1hd2FpdChhd2FpdCBmZXRjaCh4LHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkpLmpzb24oKSk7Y29uc3QgbT1hd2FpdCBhKFApLE89eC5mcmFtZXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKE8pLmZvckVhY2goKFtvLGhdKT0+e2NvbnN0e3g6Yyx5OmcsdzpiLGg6RX09aC5mcmFtZTtsZXQgQT1bYyxnLGIsRV07Y29uc3QgTD1oLnJvdGF0ZWQ7TCYmKEE9W0FbMF0sQVsxXSxBWzNdLEFbMl1dKSxpW29dPXtpbWFnZTptLHNvdXJjZVJlY3Q6QSxyb3RhdGVkOkx9fSksbX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDEpLG49dCgxMiksaT10KDcwKSxhPXQoMjIwKSxsPXQoMjIxKSxzPXQoMjIyKSxmPXQoMjEzKSx2PXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZChQLHgsbSl7cmV0dXJuIHggaW4gUD9PYmplY3QuZGVmaW5lUHJvcGVydHkoUCx4LHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6UFt4XT1tLFB9Y29uc3QgcD1TeW1ib2woIm1lc2giKTtjbGFzcyB5IGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKHg9e30pe3N1cGVyKHgpfWdldCBib3JkZXJTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDp4LHBhZGRpbmdSaWdodDptLHBhZGRpbmdCb3R0b206TyxwYWRkaW5nTGVmdDpvLGJvcmRlcldpZHRoOmh9PXRoaXMuYXR0cmlidXRlcyxbYyxnXT10aGlzLmNvbnRlbnRTaXplO3JldHVybltvK2MrbStoLHgrZytPK2hdfWdldCBjbGllbnRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDp4LHBhZGRpbmdSaWdodDptLHBhZGRpbmdCb3R0b206TyxwYWRkaW5nTGVmdDpvfT10aGlzLmF0dHJpYnV0ZXMsW2gsY109dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bbytoK20seCtjK09dfWdldCBjb250ZW50U2l6ZSgpe2xldHt3aWR0aDp4LGhlaWdodDptLGJveFNpemluZzpPLHBhZGRpbmdUb3A6byxwYWRkaW5nUmlnaHQ6aCxwYWRkaW5nQm90dG9tOmMscGFkZGluZ0xlZnQ6Z309dGhpcy5hdHRyaWJ1dGVzO2lmKHg9eHx8MCxtPW18fDAsTz09PSJib3JkZXItYm94Iil7Y29uc3QgYj0yKnRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDt4LT1iK2grZyxtLT1iK28rYyx4PU1hdGgubWF4KDAseCksbT1NYXRoLm1heCgwLG0pfXJldHVyblt4LG1dfWdldCBoYXNCb3JkZXIoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoPjB9Z2V0IGlzVmlzaWJsZSgpe2NvbnN0W3gsbV09dGhpcy5ib3JkZXJTaXplO3JldHVybiB4PjAmJm0+MH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IHg9dGhpcy5jbGllbnRCb3g7aWYoeCl7bGV0IG09dGhpc1twXTtpZihtKW0uYm94IT09eCYmKG0uY29udG91cnM9eC5jb250b3VycyxtLmJveD14KTtlbHNle209bmV3IG4uTWVzaDJEKHgpLG0uYm94PXg7Y29uc3Qgbz10aGlzLmF0dHJpYnV0ZXMuYmdjb2xvcjtpZihPYmplY3QobC5zZXRGaWxsQ29sb3IpKG0se2NvbG9yOm99KSx0aGlzLmhhc0JvcmRlcil7Y29uc3R7Ym9yZGVyQ29sb3I6Yyxib3JkZXJXaWR0aDpnLGJvcmRlckRhc2g6Yixib3JkZXJEYXNoT2Zmc2V0OkV9PXRoaXMuYXR0cmlidXRlcztPYmplY3QobC5zZXRTdHJva2VDb2xvcikobSx7Y29sb3I6YyxsaW5lV2lkdGg6ZyxsaW5lRGFzaDpiLGxpbmVEYXNoT2Zmc2V0OkV9KX10aGlzW3BdPW07Y29uc3QgaD10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7aCYmdGhpc1twXS5zZXRDbGlwUGF0aChoKX1jb25zdCBPPXRoaXMub3BhY2l0eTtyZXR1cm4gbS5nZXRPcGFjaXR5KCkhPT1PJiZtLnNldE9wYWNpdHkoTyksbS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLG19cmV0dXJuIG51bGx9Z2V0IG9mZnNldFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOngscGFkZGluZ1JpZ2h0Om0scGFkZGluZ0JvdHRvbTpPLHBhZGRpbmdMZWZ0Om8sYm9yZGVyV2lkdGg6aH09dGhpcy5hdHRyaWJ1dGVzLFtjLGddPXRoaXMuY29udGVudFNpemUsYj0yKmg7cmV0dXJuW28rYyttK2IseCtnK08rYl19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgeD10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW3hbMF1bMF0seFswXVsxXSx4WzFdWzBdLXhbMF1bMF0seFsxXVsxXS14WzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtjb25zdFt4LG0sTyxvXT10aGlzLm9yaWdpbmFsQ2xpZW50UmVjdCxoPXRoaXMuYXR0cmlidXRlcy5wYWRkaW5nO3JldHVyblt4K2hbMF0sbStoWzFdLE8taFswXS1oWzJdLG8taFsxXS1oWzNdXX1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgeD10aGlzLnJlbmRlck1hdHJpeDt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLmxheWVyVHJhbnNmb3JtSW52ZXJ0JiYoeD1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLmxheWVyLnRyYW5zZm9ybU1hdHJpeCx4KSk7bGV0IG09bnVsbDtpZih0aGlzLm1lc2gpe209Wy4uLnRoaXMubWVzaC5ib3VuZGluZ0JveF07Y29uc3QgTz10aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7TyYmKG1bMF09W21bMF1bMF0tTyxtWzBdWzFdLU9dLG1bMV09W21bMV1bMF0rTyxtWzFdWzFdK09dKX1yZXR1cm4gT2JqZWN0KHYuZGVmYXVsdCkobSx4KX1vblByb3BlcnR5Q2hhbmdlKHgsbSxPKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKHgsbSxPKSwoeD09PSJhbmNob3JYInx8eD09PSJhbmNob3JZInx8eD09PSJib3hTaXppbmcifHx4PT09IndpZHRoInx8eD09PSJoZWlnaHQifHx4PT09ImJvcmRlcldpZHRoInx8eD09PSJwYWRkaW5nTGVmdCJ8fHg9PT0icGFkZGluZ1JpZ2h0Inx8eD09PSJwYWRkaW5nVG9wInx8eD09PSJwYWRkaW5nQm90dG9tInx8L15ib3JkZXIoVG9wTGVmdHxUb3BSaWdodHxCb3R0b21SaWdodHxCb3R0b21MZWZ0KVJhZGl1cyQvLnRlc3QoeCkpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1twXSYmeD09PSJjbGlwUGF0aCImJnRoaXNbcF0uc2V0Q2xpcFBhdGgobSksdGhpc1twXSYmeD09PSJiZ2NvbG9yIiYmT2JqZWN0KGwuc2V0RmlsbENvbG9yKSh0aGlzW3BdLHtjb2xvcjptfSksdGhpc1twXSYmKHg9PT0iYm9yZGVyQ29sb3IifHx4PT09ImJvcmRlcldpZHRoInx8eD09PSJib3JkZXJEYXNoInx8eD09PSJib3JkZXJEYXNoT2Zmc2V0Iikpe2NvbnN0e2JvcmRlckNvbG9yOm8sYm9yZGVyV2lkdGg6aCxib3JkZXJEYXNoOmMsYm9yZGVyRGFzaE9mZnNldDpnfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGwuc2V0U3Ryb2tlQ29sb3IpKHRoaXNbcF0se2NvbG9yOm8sbGluZVdpZHRoOmgsbGluZURhc2g6aD9jOjAsbGluZURhc2hPZmZzZXQ6Z30pfX11cGRhdGVDb250b3Vycygpe2NvbnN0e2FuY2hvclg6eCxhbmNob3JZOm0sYm9yZGVyV2lkdGg6Tyxib3JkZXJSYWRpdXM6b309dGhpcy5hdHRyaWJ1dGVzLFtoLGNdPXRoaXMuYm9yZGVyU2l6ZSxnPXRoaXMub2Zmc2V0U2l6ZSxiPS41Kk8sRT0teCpnWzBdK2IsQT0tbSpnWzFdK2I7dGhpcy5jbGllbnRCb3g9bmV3IG4uRmlndXJlMkQsT2JqZWN0KHMuY3JlYXRlUmFkaXVzQm94KSh0aGlzLmNsaWVudEJveCxbRSxBLGgsY10sbyl9fWQoeSwiQXR0ciIsYS5kZWZhdWx0KSxmLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHksImJsb2NrIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDcxKSxuPXQoNzIpLGk9dCgyMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIikscz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyB2IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKHApe3N1cGVyKHApLHRoaXNbc10oe2FuY2hvclg6MCxhbmNob3JZOjAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsYm9yZGVyV2lkdGg6MCxib3JkZXJDb2xvcjoicmdiYSgwLDAsMCwxKSIsYm9yZGVyRGFzaDp2b2lkIDAsYm9yZGVyRGFzaE9mZnNldDowLGJvcmRlclRvcExlZnRSYWRpdXM6WzAsMF0sYm9yZGVyVG9wUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tTGVmdFJhZGl1czpbMCwwXSxiZ2NvbG9yOiJyZ2JhKDAsMCwwLDApIixwYWRkaW5nVG9wOjAscGFkZGluZ1JpZ2h0OjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsY2xpcFBhdGg6dm9pZCAwfSksdGhpc1tmXSgiYW5jaG9yIiwic2l6ZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciKX1nZXQgYW5jaG9yWCgpe3JldHVybiB0aGlzW2xdKCJhbmNob3JYIil9c2V0IGFuY2hvclgocCl7dGhpc1thXSgiYW5jaG9yWCIsT2JqZWN0KG4udG9OdW1iZXIpKHApKX1nZXQgYW5jaG9yWSgpe3JldHVybiB0aGlzW2xdKCJhbmNob3JZIil9c2V0IGFuY2hvclkocCl7dGhpc1thXSgiYW5jaG9yWSIsT2JqZWN0KG4udG9OdW1iZXIpKHApKX1nZXQgYW5jaG9yKCl7cmV0dXJuW3RoaXMuYW5jaG9yWCx0aGlzLmFuY2hvclldfXNldCBhbmNob3IocCl7cD1PYmplY3Qobi50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy5hbmNob3JYPXBbMF0sdGhpcy5hbmNob3JZPXBbMV19Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbbF0oIndpZHRoIil9c2V0IHdpZHRoKHApe3RoaXNbYV0oIndpZHRoIixPYmplY3Qobi50b051bWJlcikocCkpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1tsXSgiaGVpZ2h0Iil9c2V0IGhlaWdodChwKXt0aGlzW2FdKCJoZWlnaHQiLE9iamVjdChuLnRvTnVtYmVyKShwKSl9Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUocCl7cD1PYmplY3Qobi50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy53aWR0aD1wWzBdLHRoaXMuaGVpZ2h0PXBbMV19Z2V0IGJvcmRlcldpZHRoKCl7cmV0dXJuIHRoaXNbbF0oImJvcmRlcldpZHRoIil9c2V0IGJvcmRlcldpZHRoKHApe3RoaXNbYV0oImJvcmRlcldpZHRoIixPYmplY3Qobi50b051bWJlcikocCkpfWdldCBib3JkZXJDb2xvcigpe3JldHVybiB0aGlzW2xdKCJib3JkZXJDb2xvciIpfXNldCBib3JkZXJDb2xvcihwKXt0aGlzW2FdKCJib3JkZXJDb2xvciIsT2JqZWN0KGkucGFyc2VDb2xvcikocCkpfWdldCBib3JkZXIoKXtyZXR1cm5bdGhpcy5ib3JkZXJXaWR0aCx0aGlzLmJvcmRlckNvbG9yXX1zZXQgYm9yZGVyKHApe3A9T2JqZWN0KG4udG9BcnJheSkocCksQXJyYXkuaXNBcnJheShwKXx8KHA9W3BdKSx0aGlzLmJvcmRlcldpZHRoPXBbMF0scFsxXSE9bnVsbCYmKHRoaXMuYm9yZGVyQ29sb3I9cFsxXSl9Z2V0IGJvcmRlckRhc2goKXtyZXR1cm4gdGhpc1tsXSgiYm9yZGVyRGFzaCIpfXNldCBib3JkZXJEYXNoKHApe3A9T2JqZWN0KG4udG9BcnJheSkocCwhMCkscCE9bnVsbCYmIUFycmF5LmlzQXJyYXkocCkmJihwPVtwXSksdGhpc1thXSgiYm9yZGVyRGFzaCIscD9wLm1hcChuLnRvTnVtYmVyKTpudWxsKX1nZXQgYm9yZGVyRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW2xdKCJib3JkZXJEYXNoT2Zmc2V0Iil9c2V0IGJvcmRlckRhc2hPZmZzZXQocCl7dGhpc1thXSgiYm9yZGVyRGFzaE9mZnNldCIsT2JqZWN0KG4udG9OdW1iZXIpKHApKX1nZXQgYm9yZGVyVG9wTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW2xdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIil9c2V0IGJvcmRlclRvcExlZnRSYWRpdXMocCl7cD1PYmplY3Qobi50b0FycmF5KShwLCEwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpc1thXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIscC5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJUb3BSaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2xdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIpfXNldCBib3JkZXJUb3BSaWdodFJhZGl1cyhwKXtwPU9iamVjdChuLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzW2FdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIscC5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2xdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyhwKXtwPU9iamVjdChuLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzW2FdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIscC5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbbF0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyhwKXtwPU9iamVjdChuLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzW2FdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIixwLm1hcChuLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclJhZGl1cygpe3JldHVyblsuLi50aGlzLmJvcmRlclRvcExlZnRSYWRpdXMsLi4udGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1c119c2V0IGJvcmRlclJhZGl1cyhwKXtpZihwPU9iamVjdChuLnRvQXJyYXkpKHApLCFBcnJheS5pc0FycmF5KHApKXA9QXJyYXkoOCkuZmlsbChwKTtlbHNlIGlmKHAubGVuZ3RoPT09MilwPVtwWzBdLHBbMV0scFswXSxwWzFdLHBbMF0scFsxXSxwWzBdLHBbMV1dO2Vsc2UgaWYocC5sZW5ndGg9PT00KXA9W3BbMF0scFsxXSxwWzJdLHBbM10scFswXSxwWzFdLHBbMl0scFszXV07ZWxzZSBpZihwLmxlbmd0aD09PTYpcD1bcFswXSxwWzFdLHBbMl0scFszXSxwWzRdLHBbNV0scFsyXSxwWzNdXTtlbHNlIGlmKHAubGVuZ3RoIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJvcmRlclJhZGl1cyB2YWx1ZS4iKTt0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9W3BbMF0scFsxXV0sdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cz1bcFsyXSxwWzNdXSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPVtwWzRdLHBbNV1dLHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1bcFs2XSxwWzddXX1nZXQgYmdjb2xvcigpe3JldHVybiB0aGlzW2xdKCJiZ2NvbG9yIil9c2V0IGJnY29sb3IocCl7dGhpc1thXSgiYmdjb2xvciIsT2JqZWN0KGkucGFyc2VDb2xvcikocCkpfWdldCBwYWRkaW5nVG9wKCl7cmV0dXJuIHRoaXNbbF0oInBhZGRpbmdUb3AiKX1zZXQgcGFkZGluZ1RvcChwKXt0aGlzW2FdKCJwYWRkaW5nVG9wIixPYmplY3Qobi50b051bWJlcikocCkpfWdldCBwYWRkaW5nUmlnaHQoKXtyZXR1cm4gdGhpc1tsXSgicGFkZGluZ1JpZ2h0Iil9c2V0IHBhZGRpbmdSaWdodChwKXt0aGlzW2FdKCJwYWRkaW5nUmlnaHQiLE9iamVjdChuLnRvTnVtYmVyKShwKSl9Z2V0IHBhZGRpbmdCb3R0b20oKXtyZXR1cm4gdGhpc1tsXSgicGFkZGluZ0JvdHRvbSIpfXNldCBwYWRkaW5nQm90dG9tKHApe3RoaXNbYV0oInBhZGRpbmdCb3R0b20iLE9iamVjdChuLnRvTnVtYmVyKShwKSl9Z2V0IHBhZGRpbmdMZWZ0KCl7cmV0dXJuIHRoaXNbbF0oInBhZGRpbmdMZWZ0Iil9c2V0IHBhZGRpbmdMZWZ0KHApe3RoaXNbYV0oInBhZGRpbmdMZWZ0IixPYmplY3Qobi50b051bWJlcikocCkpfWdldCBwYWRkaW5nKCl7cmV0dXJuW3RoaXMucGFkZGluZ1RvcCx0aGlzLnBhZGRpbmdSaWdodCx0aGlzLnBhZGRpbmdCb3R0b20sdGhpcy5wYWRkaW5nTGVmdF19c2V0IHBhZGRpbmcocCl7cD1PYmplY3Qobi50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApP3AubGVuZ3RoPT09Mj9wPVtwWzBdLHBbMV0scFswXSxwWzFdXTpwLmxlbmd0aD09PTMmJihwPVtwWzBdLHBbMV0scFsyXSxwWzFdXSk6cD1bcCxwLHAscF0sdGhpcy5wYWRkaW5nVG9wPXBbMF0sdGhpcy5wYWRkaW5nUmlnaHQ9cFsxXSx0aGlzLnBhZGRpbmdCb3R0b209cFsyXSx0aGlzLnBhZGRpbmdMZWZ0PXBbM119Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbbF0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKHApe3RoaXNbYV0oImNsaXBQYXRoIixwKX1nZXQgYm94U2l6aW5nKCl7cmV0dXJuIHRoaXNbbF0oImJveFNpemluZyIpfXNldCBib3hTaXppbmcocCl7aWYocCE9bnVsbCYmcCE9PSJib3JkZXItYm94IiYmcCE9PSJjb250ZW50LWJveCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3hTaXppbmcgdHlwZS4iKTt0aGlzW2FdKCJib3hTaXppbmciLHApfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImlzVHJhbnNwYXJlbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzZXRGaWxsQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwic2V0U3Ryb2tlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDMyKSxuPXQubihyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgaXtjb25zdHJ1Y3Rvcih7dmVjdG9yOnksY29sb3JzOlB9KXtpZighQXJyYXkuaXNBcnJheSh5KXx8eS5sZW5ndGghPT00JiZ5Lmxlbmd0aCE9PTYmJnkubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGdyYWRpZW50Iik7dGhpcy52ZWN0b3I9eSx0aGlzLmNvbG9ycz1QLm1hcCgoe29mZnNldDp4LGNvbG9yOm19KT0+KHtvZmZzZXQ6eCxjb2xvcjpsKG0pfSkpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt2ZWN0b3I6dGhpcy52ZWN0b3IsY29sb3JzOnRoaXMuY29sb3JzfSl9fWZ1bmN0aW9uIGEocCl7cmV0dXJuIHAgaW5zdGFuY2VvZiBpPyExOnA9PW51bGw/ITA6bigpKHApWzNdPT09MH1mdW5jdGlvbiBsKHApe2lmKHA9PW51bGx8fChwfHwocD0idHJhbnNwYXJlbnQiKSxwIGluc3RhbmNlb2YgaSkpcmV0dXJuIHA7Y29uc3QgeT1uKCkocCk7aWYoIXl8fCF5Lmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybmByZ2JhKCR7eS5qb2luKCl9KWB9ZnVuY3Rpb24gcyhwLHksUCl7Y29uc3QgeD1wLmJvdW5kaW5nQm94WzBdO2lmKFAudmVjdG9yKXtsZXR7dmVjdG9yOm0sY29sb3JzOk99PVA7bS5sZW5ndGg9PT00PyhtPVttWzBdK3hbMF0sbVsxXSt4WzFdLG1bMl0reFswXSxtWzNdK3hbMV1dLHAuc2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjptLGNvbG9yczpPLHR5cGU6eX0pKTptLmxlbmd0aD09PTM/KG09W21bMF0reFswXSxtWzFdK3hbMV0sbVsyXV0scC5zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6bSxjb2xvcnM6Tyx0eXBlOnl9KSk6KG09W21bMF0reFswXSxtWzFdK3hbMV0sbVsyXSxtWzNdK3hbMF0sbVs0XSt4WzFdLG1bNV1dLHAuc2V0UmFkaWFsR3JhZGllbnQoe3ZlY3RvcjptLGNvbG9yczpPLHR5cGU6eX0pKX1lbHNlIHAuZ3JhZGllbnQmJnAuZ3JhZGllbnRbeV0mJihkZWxldGUgcC5ncmFkaWVudFt5XSxkZWxldGUgcC51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yKX1mdW5jdGlvbiBmKHAse2NvbG9yOnkscnVsZTpQPSJub256ZXJvIn0pe3JldHVybiBzKHAsImZpbGwiLHkpLHkudmVjdG9yfHxwLnNldEZpbGwoe2NvbG9yOnkscnVsZTpQfSkscH1mdW5jdGlvbiB2KHAse2NvbG9yOnksbGluZVdpZHRoOlAsbGluZUNhcDp4LGxpbmVKb2luOm0sbGluZURhc2g6TyxsaW5lRGFzaE9mZnNldDpvLG1pdGVyTGltaXQ6aCxyb3VuZFNlZ21lbnRzOmN9KXtzKHAsInN0cm9rZSIseSkseS52ZWN0b3ImJih5PVswLDAsMCwxXSkscC5zZXRTdHJva2Uoe2NvbG9yOnksdGhpY2tuZXNzOlAsY2FwOngsam9pbjptLG1pdGVyTGltaXQ6aCxsaW5lRGFzaDpPLGxpbmVEYXNoT2Zmc2V0Om8scm91bmRTZWdtZW50czpjfSl9Y2xhc3MgZCBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKHk9MCxQPTAseD0wLG09MCl7cmV0dXJuIEFycmF5LmlzQXJyYXkoeSkmJihbeSxQLHgsbV09eSksdHlwZW9mIHk9PSJzdHJpbmciJiYoW3ksUCx4LG1dPW4oKSh5KSx5Lz0yNTUsUC89MjU1LHgvPTI1NSksc3VwZXIoeSxQLHgsbSksdGhpc31nZXQgcigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMF0qMjU1KX1zZXQgcih5KXt0aGlzWzBdPXkvMjU1fWdldCBnKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1sxXSoyNTUpfXNldCBnKHkpe3RoaXNbMV09eS8yNTV9Z2V0IGIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzJdKjI1NSl9c2V0IGIoeSl7dGhpc1syXT15LzI1NX1nZXQgYSgpe3JldHVybiB0aGlzWzNdfXNldCBhKHkpe3RoaXNbM109eX1nZXQgaGV4KCl7Y29uc3QgeT1gMCR7dGhpcy5yLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxQPWAwJHt0aGlzLmcudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLHg9YDAke3RoaXMuYi50b1N0cmluZygxNil9YC5zbGljZSgtMik7bGV0IG07cmV0dXJuIHRoaXMuYTwxJiYobT1NYXRoLnJvdW5kKHRoaXNbM10qMjU1KSxtPWAwJHttLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSksYCMke3l9JHtQfSR7eH0ke218fCIifWB9Z2V0IHJnYmEoKXtyZXR1cm5gcmdiYSgke3RoaXMucn0sJHt0aGlzLmd9LCR7dGhpcy5ifSwke3RoaXMuYX0pYH1mcm9tQ29sb3IoeSl7cmV0dXJuIHR5cGVvZiB5PT0ic3RyaW5nIiYmKHk9bigpKHkpLHlbMF0vPTI1NSx5WzFdLz0yNTUseVsyXS89MjU1KSx0aGlzWzBdPXlbMF0sdGhpc1sxXT15WzFdLHRoaXNbMl09eVsyXSx0aGlzWzNdPXlbM10sdGhpc319fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVSYWRpdXNCb3giLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihpLGEsbCxzLGYsdj0ibGVmdFRvcCIpe2NvbnN0IGQ9LjU1MjI4NDgscD1zLzIqZCx5PWYvMipkLFA9YStzLHg9bCtmLG09YStzLzIsTz1sK2YvMjt2PT09ImxlZnRUb3AiPyhpLm1vdmVUbyhhLE8pLGkuYmV6aWVyQ3VydmVUbyhhLE8teSxtLXAsbCxtLGwpKTp2PT09InJpZ2h0VG9wIj9pLmJlemllckN1cnZlVG8obStwLGwsUCxPLXksUCxPKTp2PT09InJpZ2h0Qm90dG9tIj9pLmJlemllckN1cnZlVG8oUCxPK3ksbStwLHgsbSx4KTp2PT09ImxlZnRCb3R0b20iJiZpLmJlemllckN1cnZlVG8obS1wLHgsYSxPK3ksYSxPKX1mdW5jdGlvbiBuKGksW2EsbCxzLGZdLHYpe2lmKCF2fHxBcnJheS5pc0FycmF5KHYpJiZ2LmV2ZXJ5KGQ9PmQ9PT0wKSlpLmJlZ2luUGF0aCgpLGkucmVjdChhLGwscyxmKTtlbHNle3R5cGVvZiB2PT0ibnVtYmVyIiYmKHY9QXJyYXkoOCkuZmlsbCh2KSk7Y29uc3RbZCxwLHksUCx4LG0sTyxvXT12Lm1hcCgoaCxjKT0+YyUyP01hdGgubWluKGgsZi8yKTpNYXRoLm1pbihoLHMvMikpO2kuYmVnaW5QYXRoKCksaS5tb3ZlVG8oYSxsK3ApLHIoaSxhLGwsZCoyLHAqMiwibGVmdFRvcCIpLGkubGluZVRvKGErcy15LGwpLHIoaSxhK3MteSoyLGwseSoyLFAqMiwicmlnaHRUb3AiKSxpLmxpbmVUbyhhK3MsbCtmLW0pLHIoaSxhK3MteCoyLGwrZi1tKjIseCoyLG0qMiwicmlnaHRCb3R0b20iKSxpLmxpbmVUbyhhK08sbCtmKSxyKGksYSxsK2YtbyoyLE8qMixvKjIsImxlZnRCb3R0b20iKSxpLmNsb3NlUGF0aCgpfXJldHVybiBpfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWZ1bmN0aW9uKHIsbil7aWYoIXIpcmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH07Y29uc3RbW2ksYV0sW2wsc11dPXIsZj1pKm5bMF0rYSpuWzJdK25bNF0sdj1pKm5bMV0rYSpuWzNdK25bNV0sZD1sKm5bMF0rYSpuWzJdK25bNF0scD1sKm5bMV0rYSpuWzNdK25bNV0seT1sKm5bMF0rcypuWzJdK25bNF0sUD1sKm5bMV0rcypuWzNdK25bNV0seD1pKm5bMF0rcypuWzJdK25bNF0sbT1pKm5bMV0rcypuWzNdK25bNV0sTz1NYXRoLm1pbihmLGQseSx4KSxvPU1hdGgubWluKHYscCxQLG0pLGg9TWF0aC5tYXgoZixkLHkseCksYz1NYXRoLm1heCh2LHAsUCxtKTtyZXR1cm57eDpPLHk6byx3aWR0aDpoLU8saGVpZ2h0OmMtbyxsZWZ0Ok8sdG9wOm8scmlnaHQ6aCxib3R0b206Y319fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMTgpLG49dCgyMTkpLGk9dCgyMjUpLGE9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKHYsZCxwKXtyZXR1cm4gZCBpbiB2P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LGQse3ZhbHVlOnAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp2W2RdPXAsdn1jb25zdCBzPVN5bWJvbCgidGV4dHVyZVRhc2siKTtjbGFzcyBmIGV4dGVuZHMgbi5kZWZhdWx0e2NvbnN0cnVjdG9yKGQ9e30pe3R5cGVvZiBkPT0ic3RyaW5nIiYmKGQ9e3RleHR1cmU6ZH0pLHN1cGVyKGQpfWdldCBjb250ZW50U2l6ZSgpe2xldFtkLHBdPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOnksaGVpZ2h0OlB9PXRoaXMuYXR0cmlidXRlcztpZih5PT1udWxsfHxQPT1udWxsKXtjb25zdCB4PXRoaXMudGV4dHVyZUltYWdlLG09dGhpcy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0LE89dGhpcy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYobSl5PT1udWxsJiYoZD1tWzBdK21bMl0pLFA9PW51bGwmJihwPW1bMV0rbVszXSk7ZWxzZSBpZihPKXtjb25zdCBvPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt5PT1udWxsJiYoZD1PWzJdL28pLFA9PW51bGwmJihwPU9bM10vbyl9ZWxzZSBpZih4KXtjb25zdCBvPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt5PT1udWxsJiYoZD14LndpZHRoL28pLFA9PW51bGwmJihwPXguaGVpZ2h0L28pfX1yZXR1cm5bZCxwXX1nZXQgdGV4dHVyZUltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1tzXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhkPVtdKXtzdXBlci5kcmF3KGQpO2NvbnN0IHA9dGhpcy5tZXNoO3JldHVybiBwJiZPYmplY3Qoci5kcmF3VGV4dHVyZSkodGhpcyxwKSxkfW9uUHJvcGVydHlDaGFuZ2UoZCxwLHkpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoZCxwLHkpLGQ9PT0idGV4dHVyZSImJih0aGlzW3NdPU9iamVjdChyLmFwcGx5VGV4dHVyZSkodGhpcyxwLCEwKSksZD09PSJ0ZXh0dXJlUmVjdCIpe2NvbnN0e3dpZHRoOlAsaGVpZ2h0Onh9PXRoaXMuYXR0cmlidXRlczsoUD09bnVsbHx8eD09bnVsbCkmJnRoaXMudXBkYXRlQ29udG91cnMoKX19fWwoZiwiQXR0ciIsaS5kZWZhdWx0KSxhLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGYsInNwcml0ZSIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBuPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxpPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW25dKHt0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMH0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbYV0oInRleHR1cmUiKX1zZXQgdGV4dHVyZShmKXt0aGlzW2ldKCJ0ZXh0dXJlIixmKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1thXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoZil7dGhpc1tpXSgidGV4dHVyZVJlY3QiLGYpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbYV0oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChmKXt0aGlzW2ldKCJzb3VyY2VSZWN0IixmKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW2FdKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoZil7dGhpc1tpXSgidGV4dHVyZVJlcGVhdCIsISFmKX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBQfSk7dmFyIHI9dCgxMiksbj10KDIyNyksaT10Lm4obiksYT10KDcwKSxsPXQoMjI4KSxzPXQoMjIxKSxmPXQoMjE4KSx2PXQoMjEzKSxkPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcCh4LG0sTyl7cmV0dXJuIG0gaW4geD9PYmplY3QuZGVmaW5lUHJvcGVydHkoeCxtLHt2YWx1ZTpPLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6eFttXT1PLHh9Y29uc3QgeT1TeW1ib2woIm1lc2giKTtjbGFzcyBQIGV4dGVuZHMgYS5kZWZhdWx0e2NvbnN0cnVjdG9yKG09e30pe3R5cGVvZiBtPT0ic3RyaW5nIiYmKG09e2Q6bX0pLHN1cGVyKG0pLHRoaXMuZWZmZWN0cz17ZChPLG8saCxjLGcpe2NvbnN0IGI9KGgtYykvKGctYyk7aWYoYjw9MClyZXR1cm4gTztpZihiPj0xKXJldHVybiBvO2NvbnN0IEU9aS5hLl9wcmVwcm9jZXNzaW5nKGkuYS5wYXRoMnNoYXBlcyhPKSxpLmEucGF0aDJzaGFwZXMobykpLEE9aS5hLl9sZXJwKC4uLkUsYilbMF07cmV0dXJuIEEucmVkdWNlKChNLEkpPT5gJHtNfSR7SS5zbGljZSgyKS5qb2luKCIgIil9IGAsYE0ke0FbMF1bMF19ICR7QVswXVsxXX1DYCkudHJpbSgpfX19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5kfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgbT10aGlzLnBhdGg7aWYobSl7bGV0IE89dGhpc1t5XTtpZihPKU8ucGF0aCE9PW0mJihPLmNvbnRvdXJzPW0uY29udG91cnMsTy5wYXRoPW0pO2Vsc2V7Tz1uZXcgci5NZXNoMkQodGhpcy5wYXRoKSxPLnBhdGg9bTtjb25zdCBoPXRoaXMuYXR0cmlidXRlcy5maWxsQ29sb3IsYz10aGlzLmF0dHJpYnV0ZXMuZmlsbFJ1bGU7aCYmT2JqZWN0KHMuc2V0RmlsbENvbG9yKShPLHtjb2xvcjpoLHJ1bGU6Y30pO2NvbnN0IGc9dGhpcy5hdHRyaWJ1dGVzLmxpbmVXaWR0aCxiPXRoaXMuYXR0cmlidXRlcy5zdHJva2VDb2xvcjtpZihiJiZnPjApe2NvbnN0e2xpbmVDYXA6QSxsaW5lSm9pbjpMLG1pdGVyTGltaXQ6TSxsaW5lRGFzaDpJLGxpbmVEYXNoT2Zmc2V0OkQscm91bmRTZWdtZW50czpSfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHMuc2V0U3Ryb2tlQ29sb3IpKE8se2NvbG9yOmIsbGluZVdpZHRoOmcsbGluZUNhcDpBLGxpbmVKb2luOkwsbWl0ZXJMaW1pdDpNLGxpbmVEYXNoOkksbGluZURhc2hPZmZzZXQ6RCxyb3VuZFNlZ21lbnRzOlJ9KX10aGlzW3ldPU87Y29uc3QgRT10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7RSYmdGhpc1t5XS5zZXRDbGlwUGF0aChFKX1jb25zdCBvPXRoaXMub3BhY2l0eTtyZXR1cm4gTy5nZXRPcGFjaXR5KCkhPT1vJiZPLnNldE9wYWNpdHkobyksTy5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLE99cmV0dXJuIG51bGx9Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtpZih0aGlzLnBhdGgpe2NvbnN0IG09dGhpcy5wYXRoLmJvdW5kaW5nQm94O3JldHVyblttWzBdWzBdLG1bMF1bMV0sbVsxXVswXS1tWzBdWzBdLG1bMV1bMV0tbVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IG09dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVyblttWzBdWzBdLG1bMF1bMV0sbVsxXVswXS1tWzBdWzBdLG1bMV1bMV0tbVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudENlbnRlcigpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmJvdW5kaW5nQ2VudGVyOlswLDBdfXNldCBkKG0pe3RoaXMuYXR0cmlidXRlcy5kPW19Z2V0IGQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmR9ZHJhdyhtPVtdKXtzdXBlci5kcmF3KG0pO2NvbnN0IE89dGhpcy5tZXNoO3JldHVybiBPJiZPYmplY3QoZi5kcmF3VGV4dHVyZSkodGhpcyxPKSxtfWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCBtPW51bGw7cmV0dXJuIHRoaXMubWVzaCYmKG09dGhpcy5tZXNoLmJvdW5kaW5nQm94KSxPYmplY3QoZC5kZWZhdWx0KShtLHRoaXMucmVuZGVyTWF0cml4KX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guZ2V0VG90YWxMZW5ndGgoKTowfWdldFBvaW50QXRMZW5ndGgobSl7aWYodGhpcy5tZXNoKXtjb25zdCBPPXRoaXMubWVzaC5nZXRQb2ludEF0TGVuZ3RoKG0pO2lmKE8pcmV0dXJuW08ueCxPLnldfXJldHVyblswLDBdfW9uUHJvcGVydHlDaGFuZ2UobSxPLG8pe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UobSxPLG8pLChtPT09ImQifHxtPT09Im5vcm1hbGl6ZSIpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t5XSYmKG09PT0iZmlsbENvbG9yInx8bT09PSJmaWxsUnVsZSIpKXtjb25zdHtmaWxsQ29sb3I6aCxmaWxsUnVsZTpjfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHMuc2V0RmlsbENvbG9yKSh0aGlzW3ldLHtjb2xvcjpoLHJ1bGU6Y30pfWlmKHRoaXNbeV0mJihtPT09InN0cm9rZUNvbG9yInx8bT09PSJsaW5lV2lkdGgifHxtPT09ImxpbmVDYXAifHxtPT09ImxpbmVKb2luInx8bT09PSJsaW5lRGFzaCJ8fG09PT0ibGluZURhc2hPZmZzZXQifHxtPT09InJvdW5kU2VnbWVudHMiKSl7Y29uc3R7c3Ryb2tlQ29sb3I6aCxsaW5lV2lkdGg6Y309dGhpcy5hdHRyaWJ1dGVzO2lmKGgmJmM+MCl7Y29uc3R7bGluZUNhcDpnLGxpbmVKb2luOmIsbGluZURhc2g6RSxsaW5lRGFzaE9mZnNldDpBLG1pdGVyTGltaXQ6TCxyb3VuZFNlZ21lbnRzOk19PXRoaXMuYXR0cmlidXRlcztPYmplY3Qocy5zZXRTdHJva2VDb2xvcikodGhpc1t5XSx7Y29sb3I6aCxsaW5lQ2FwOmcsbGluZUpvaW46YixsaW5lV2lkdGg6YyxsaW5lRGFzaDpFLGxpbmVEYXNoT2Zmc2V0OkEsbWl0ZXJMaW1pdDpMLHJvdW5kU2VnbWVudHM6TX0pfX10aGlzW3ldJiZtPT09ImNsaXBQYXRoIiYmdGhpc1t5XS5zZXRDbGlwUGF0aChPKSxtPT09InRleHR1cmUiJiZPYmplY3QoZi5hcHBseVRleHR1cmUpKHRoaXMsTyl9dXBkYXRlQ29udG91cnMoKXt0aGlzLnBhdGg9bmV3IHIuRmlndXJlMkQsdGhpcy5wYXRoLmFkZFBhdGgodGhpcy5hdHRyaWJ1dGVzLmQpLHRoaXMuYXR0cmlidXRlcy5ub3JtYWxpemUmJnRoaXMucGF0aC5ub3JtYWxpemUoLi4udGhpcy5wYXRoLmJvdW5kaW5nQ2VudGVyKX19cChQLCJBdHRyIixsLmRlZmF1bHQpLHYuZGVmYXVsdC5yZWdpc3Rlck5vZGUoUCwicGF0aCIpfSxmdW5jdGlvbih1LGUsdCl7KGZ1bmN0aW9uKHIsbil7dS5leHBvcnRzPW4oKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIEkoRCxSKXt2YXIgQz1bXSxCPSEwLHo9ITEsSz12b2lkIDA7dHJ5e2Zvcih2YXIgUT1EW1N5bWJvbC5pdGVyYXRvcl0oKSxfOyEoQj0oXz1RLm5leHQoKSkuZG9uZSkmJihDLnB1c2goXy52YWx1ZSksIShSJiZDLmxlbmd0aD09PVIpKTtCPSEwKTt9Y2F0Y2goRil7ej0hMCxLPUZ9ZmluYWxseXt0cnl7IUImJlEucmV0dXJuJiZRLnJldHVybigpfWZpbmFsbHl7aWYoeil0aHJvdyBLfX1yZXR1cm4gQ31yZXR1cm4gZnVuY3Rpb24oRCxSKXtpZihBcnJheS5pc0FycmF5KEQpKXJldHVybiBEO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoRCkpcmV0dXJuIEkoRCxSKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpLG49TWF0aC5QSSoyLGk9ZnVuY3Rpb24oRCxSLEMsQix6LEssUSl7dmFyIF89RC54LEY9RC55O18qPVIsRio9Qzt2YXIgRz1CKl8teipGLFg9eipfK0IqRjtyZXR1cm57eDpHK0sseTpYK1F9fSxhPWZ1bmN0aW9uKEQsUil7dmFyIEM9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKFIvNCksQj1NYXRoLmNvcyhEKSx6PU1hdGguc2luKEQpLEs9TWF0aC5jb3MoRCtSKSxRPU1hdGguc2luKEQrUik7cmV0dXJuW3t4OkIteipDLHk6eitCKkN9LHt4OksrUSpDLHk6US1LKkN9LHt4OksseTpRfV19LGw9ZnVuY3Rpb24oRCxSLEMsQil7dmFyIHo9RCpCLVIqQzwwPy0xOjEsSz1NYXRoLnNxcnQoRCpEK1IqUiksUT1NYXRoLnNxcnQoRCpEK1IqUiksXz1EKkMrUipCLEY9Xy8oSypRKTtyZXR1cm4gRj4xJiYoRj0xKSxGPC0xJiYoRj0tMSkseipNYXRoLmFjb3MoRil9LHM9ZnVuY3Rpb24oRCxSLEMsQix6LEssUSxfLEYsRyxYLFope3ZhciB0dD1NYXRoLnBvdyh6LDIpLG50PU1hdGgucG93KEssMikscT1NYXRoLnBvdyhYLDIpLGh0PU1hdGgucG93KFosMiksdXQ9dHQqbnQtdHQqaHQtbnQqcTt1dDwwJiYodXQ9MCksdXQvPXR0Kmh0K250KnEsdXQ9TWF0aC5zcXJ0KHV0KSooUT09PV8/LTE6MSk7dmFyIGo9dXQqei9LKlosVz11dCotSy96KlgsVj1HKmotRipXKyhEK0MpLzIsSj1GKmorRypXKyhSK0IpLzIsTj0oWC1qKS96LCQ9KFotVykvSyxTPSgtWC1qKS96LFQ9KC1aLVcpL0ssdz1sKDEsMCxOLCQpLFU9bChOLCQsUyxUKTtyZXR1cm4gXz09PTAmJlU+MCYmKFUtPW4pLF89PT0xJiZVPDAmJihVKz1uKSxbVixKLHcsVV19LGY9ZnVuY3Rpb24oRCl7dmFyIFI9RC5weCxDPUQucHksQj1ELmN4LHo9RC5jeSxLPUQucngsUT1ELnJ5LF89RC54QXhpc1JvdGF0aW9uLEY9Xz09PXZvaWQgMD8wOl8sRz1ELmxhcmdlQXJjRmxhZyxYPUc9PT12b2lkIDA/MDpHLFo9RC5zd2VlcEZsYWcsdHQ9Wj09PXZvaWQgMD8wOlosbnQ9W107aWYoSz09PTB8fFE9PT0wKXJldHVybltdO3ZhciBxPU1hdGguc2luKEYqbi8zNjApLGh0PU1hdGguY29zKEYqbi8zNjApLHV0PWh0KihSLUIpLzIrcSooQy16KS8yLGo9LXEqKFItQikvMitodCooQy16KS8yO2lmKHV0PT09MCYmaj09PTApcmV0dXJuW107Sz1NYXRoLmFicyhLKSxRPU1hdGguYWJzKFEpO3ZhciBXPU1hdGgucG93KHV0LDIpL01hdGgucG93KEssMikrTWF0aC5wb3coaiwyKS9NYXRoLnBvdyhRLDIpO1c+MSYmKEsqPU1hdGguc3FydChXKSxRKj1NYXRoLnNxcnQoVykpO3ZhciBWPXMoUixDLEIseixLLFEsWCx0dCxxLGh0LHV0LGopLEo9cihWLDQpLE49SlswXSwkPUpbMV0sUz1KWzJdLFQ9SlszXSx3PU1hdGgubWF4KE1hdGguY2VpbChNYXRoLmFicyhUKS8obi80KSksMSk7VC89dztmb3IodmFyIFU9MDtVPHc7VSsrKW50LnB1c2goYShTLFQpKSxTKz1UO3JldHVybiBudC5tYXAoZnVuY3Rpb24oSCl7dmFyIFk9aShIWzBdLEssUSxodCxxLE4sJCksaz1ZLngscnQ9WS55LGl0PWkoSFsxXSxLLFEsaHQscSxOLCQpLGx0PWl0LngsZnQ9aXQueSxvdD1pKEhbMl0sSyxRLGh0LHEsTiwkKSxzdD1vdC54LGN0PW90Lnk7cmV0dXJue3gxOmsseTE6cnQseDI6bHQseTI6ZnQseDpzdCx5OmN0fX0pfSx2PXthOjcsYzo2LGg6MSxsOjIsbToyLHE6NCxzOjQsdDoyLHY6MSx6OjB9LGQ9LyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9pZztmdW5jdGlvbiBwKEkpe3ZhciBEPVtdO3JldHVybiBJLnJlcGxhY2UoZCxmdW5jdGlvbihSLEMsQil7dmFyIHo9Qy50b0xvd2VyQ2FzZSgpO2ZvcihCPVAoQiksej09Im0iJiZCLmxlbmd0aD4yJiYoRC5wdXNoKFtDXS5jb25jYXQoQi5zcGxpY2UoMCwyKSkpLHo9ImwiLEM9Qz09Im0iPyJsIjoiTCIpOzspe2lmKEIubGVuZ3RoPT12W3pdKXJldHVybiBCLnVuc2hpZnQoQyksRC5wdXNoKEIpO2lmKEIubGVuZ3RoPHZbel0pdGhyb3cgbmV3IEVycm9yKCJtYWxmb3JtZWQgcGF0aCBkYXRhIik7RC5wdXNoKFtDXS5jb25jYXQoQi5zcGxpY2UoMCx2W3pdKSkpfX0pLER9dmFyIHk9Ly0/WzAtOV0qXC4/WzAtOV0rKD86ZVstK10/XGQrKT8vaWc7ZnVuY3Rpb24gUChJKXt2YXIgRD1JLm1hdGNoKHkpO3JldHVybiBEP0QubWFwKE51bWJlcik6W119ZnVuY3Rpb24geChJKXt2YXIgRD1JWzBdWzBdLFI9SVswXVsxXSxDPUQsQj1SO3JldHVybiBJLmZvckVhY2goZnVuY3Rpb24oeil7dmFyIEs9elswXSxRPXpbMl0sXz16WzRdLEY9els2XSxHPXpbMV0sWD16WzNdLFo9els1XSx0dD16WzddO0Q9TWF0aC5taW4oRCxLLFEsXyxGKSxSPU1hdGgubWluKFIsRyxYLFosdHQpLEM9TWF0aC5tYXgoQyxLLFEsXyxGKSxCPU1hdGgubWF4KEIsRyxYLFosdHQpfSksW0QsUixDLEJdfWZ1bmN0aW9uIG0oSSxEKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KElbMF0tRFswXSwyKStNYXRoLnBvdyhJWzFdLURbMV0sMikpK01hdGguc3FydChNYXRoLnBvdyhJWzJdLURbMl0sMikrTWF0aC5wb3coSVszXS1EWzNdLDIpKX1mdW5jdGlvbiBPKEksRCl7dmFyIFI9SVswXSxDPUlbMl0sQj1JWzRdLHo9SVs2XSxLPUlbMV0sUT1JWzNdLF89SVs1XSxGPUlbN10sRz1EWzBdLFg9RFsyXSxaPURbNF0sdHQ9RFs2XSxudD1EWzFdLHE9RFszXSxodD1EWzVdLHV0PURbN107cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhHLVIsMikrTWF0aC5wb3cobnQtSywyKSkrTWF0aC5zcXJ0KE1hdGgucG93KFgtQywyKStNYXRoLnBvdyhxLVEsMikpK01hdGguc3FydChNYXRoLnBvdyhaLUIsMikrTWF0aC5wb3coaHQtXywyKSkrTWF0aC5zcXJ0KE1hdGgucG93KHR0LXosMikrTWF0aC5wb3codXQtRiwyKSl9ZnVuY3Rpb24gbyhJLEQpe3ZhciBSPWMoSS5sZW5ndGgpLEM9W107Ui5mb3JFYWNoKGZ1bmN0aW9uKHope3ZhciBLPTAsUT0wO3ouZm9yRWFjaChmdW5jdGlvbihfKXtLKz1PKElbX10sRFtRKytdKX0pLEMucHVzaCh7aW5kZXg6eixkaXN0YW5jZTpLfSl9KSxDLnNvcnQoZnVuY3Rpb24oeixLKXtyZXR1cm4gei5kaXN0YW5jZS1LLmRpc3RhbmNlfSk7dmFyIEI9W107cmV0dXJuIENbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbih6KXtCLnB1c2goSVt6XSl9KSxCfWZ1bmN0aW9uIGgoSSxEKXt2YXIgUj1nKEkubGVuZ3RoKSxDPVtdO1IuZm9yRWFjaChmdW5jdGlvbih6KXt2YXIgSz0wO3ouZm9yRWFjaChmdW5jdGlvbihRKXtLKz1tKHgoSVtRXSkseChEW1FdKSl9KSxDLnB1c2goe2luZGV4OnosZGlzdGFuY2U6S30pfSksQy5zb3J0KGZ1bmN0aW9uKHosSyl7cmV0dXJuIHouZGlzdGFuY2UtSy5kaXN0YW5jZX0pO3ZhciBCPVtdO3JldHVybiBDWzBdLmluZGV4LmZvckVhY2goZnVuY3Rpb24oeil7Qi5wdXNoKElbel0pfSksQn1mdW5jdGlvbiBjKEkpe2Zvcih2YXIgRD1bXSxSPTA7UjxJO1IrKyl7Zm9yKHZhciBDPVtdLEI9MDtCPEk7QisrKXt2YXIgej1CK1I7ej5JLTEmJih6LT1JKSxDW3pdPUJ9RC5wdXNoKEMpfXJldHVybiBEfWZ1bmN0aW9uIGcoSSl7Zm9yKHZhciBEPVtdLFI9MDtSPEk7UisrKUQucHVzaChSKTtyZXR1cm4gYihEKX1mdW5jdGlvbiBiKEkpe3ZhciBEPVtdLFI9W107ZnVuY3Rpb24gQyhCKXt2YXIgeixLO2Zvcih6PTA7ejxCLmxlbmd0aDt6KyspSz1CLnNwbGljZSh6LDEpWzBdLFIucHVzaChLKSxCLmxlbmd0aD09MCYmRC5wdXNoKFIuc2xpY2UoKSksQyhCKSxCLnNwbGljZSh6LDAsSyksUi5wb3AoKTtyZXR1cm4gRH1yZXR1cm4gQyhJKX12YXIgRT17fTtFLnBhcnNlcj1wLEUubGVycEN1cnZlPWZ1bmN0aW9uKEksRCxSKXtyZXR1cm4gRS5sZXJwUG9pbnRzKElbMF0sSVsxXSxEWzBdLERbMV0sUikuY29uY2F0KEUubGVycFBvaW50cyhJWzJdLElbM10sRFsyXSxEWzNdLFIpKS5jb25jYXQoRS5sZXJwUG9pbnRzKElbNF0sSVs1XSxEWzRdLERbNV0sUikpLmNvbmNhdChFLmxlcnBQb2ludHMoSVs2XSxJWzddLERbNl0sRFs3XSxSKSl9LEUubGVycFBvaW50cz1mdW5jdGlvbihJLEQsUixDLEIpe3JldHVybltJKyhSLUkpKkIsRCsoQy1EKSpCXX0sRS5xMmI9ZnVuY3Rpb24oSSxELFIsQyxCLHope3JldHVybltJLEQsKEkrMipSKS8zLChEKzIqQykvMywoQisyKlIpLzMsKHorMipDKS8zLEIsel19LEUucGF0aDJzaGFwZXM9ZnVuY3Rpb24oSSl7Zm9yKHZhciBEPUUucGFyc2VyKEkpLFI9MCxDPTAsQj0wLHo9RC5sZW5ndGgsSz1bXSxRPW51bGwsXz12b2lkIDAsRj12b2lkIDAsRz12b2lkIDAsWD12b2lkIDAsWj12b2lkIDAsdHQ9dm9pZCAwLG50PXZvaWQgMDtCPHo7QisrKXt2YXIgcT1EW0JdLGh0PXFbMF0sdXQ9RFtCLTFdO3N3aXRjaChodCl7Y2FzZSJtIjpaPUsubGVuZ3RoLEtbWl09W10sUT1LW1pdLFI9UitxWzFdLEM9QytxWzJdO2JyZWFrO2Nhc2UiTSI6Wj1LLmxlbmd0aCxLW1pdPVtdLFE9S1taXSxSPXFbMV0sQz1xWzJdO2JyZWFrO2Nhc2UibCI6US5wdXNoKFtSLEMsUixDLFIsQyxSK3FbMV0sQytxWzJdXSksUis9cVsxXSxDKz1xWzJdO2JyZWFrO2Nhc2UiTCI6US5wdXNoKFtSLEMscVsxXSxxWzJdLHFbMV0scVsyXSxxWzFdLHFbMl1dKSxSPXFbMV0sQz1xWzJdO2JyZWFrO2Nhc2UiaCI6US5wdXNoKFtSLEMsUixDLFIsQyxSK3FbMV0sQ10pLFIrPXFbMV07YnJlYWs7Y2FzZSJIIjpRLnB1c2goW1IsQyxxWzFdLEMscVsxXSxDLHFbMV0sQ10pLFI9cVsxXTticmVhaztjYXNlInYiOlEucHVzaChbUixDLFIsQyxSLEMsUixDK3FbMV1dKSxDKz1xWzFdO2JyZWFrO2Nhc2UiViI6US5wdXNoKFtSLEMsUixxWzFdLFIscVsxXSxSLHFbMV1dKSxDPXFbMV07YnJlYWs7Y2FzZSJDIjpRLnB1c2goW1IsQyxxWzFdLHFbMl0scVszXSxxWzRdLHFbNV0scVs2XV0pLFI9cVs1XSxDPXFbNl07YnJlYWs7Y2FzZSJTIjp1dFswXT09PSJDInx8dXRbMF09PT0iYyI/US5wdXNoKFtSLEMsUit1dFs1XS11dFszXSxDK3V0WzZdLXV0WzRdLHFbMV0scVsyXSxxWzNdLHFbNF1dKToodXRbMF09PT0iUyJ8fHV0WzBdPT09InMiKSYmUS5wdXNoKFtSLEMsUit1dFszXS11dFsxXSxDK3V0WzRdLXV0WzJdLHFbMV0scVsyXSxxWzNdLHFbNF1dKSxSPXFbM10sQz1xWzRdO2JyZWFrO2Nhc2UiYyI6US5wdXNoKFtSLEMsUitxWzFdLEMrcVsyXSxSK3FbM10sQytxWzRdLFIrcVs1XSxDK3FbNl1dKSxSPVIrcVs1XSxDPUMrcVs2XTticmVhaztjYXNlInMiOnV0WzBdPT09IkMifHx1dFswXT09PSJjIj9RLnB1c2goW1IsQyxSK3V0WzVdLXV0WzNdLEMrdXRbNl0tdXRbNF0sUitxWzFdLEMrcVsyXSxSK3FbM10sQytxWzRdXSk6KHV0WzBdPT09IlMifHx1dFswXT09PSJzIikmJlEucHVzaChbUixDLFIrdXRbM10tdXRbMV0sQyt1dFs0XS11dFsyXSxSK3FbMV0sQytxWzJdLFIrcVszXSxDK3FbNF1dKSxSPVIrcVszXSxDPUMrcVs0XTticmVhaztjYXNlImEiOnR0PWYoe3J4OnFbMV0scnk6cVsyXSxweDpSLHB5OkMseEF4aXNSb3RhdGlvbjpxWzNdLGxhcmdlQXJjRmxhZzpxWzRdLHN3ZWVwRmxhZzpxWzVdLGN4OlIrcVs2XSxjeTpDK3FbN119KSxudD10dFt0dC5sZW5ndGgtMV0sdHQuZm9yRWFjaChmdW5jdGlvbihqLFcpe1c9PT0wP1EucHVzaChbUixDLGoueDEsai55MSxqLngyLGoueTIsai54LGoueV0pOlEucHVzaChbdHRbVy0xXS54LHR0W1ctMV0ueSxqLngxLGoueTEsai54MixqLnkyLGoueCxqLnldKX0pLFI9bnQueCxDPW50Lnk7YnJlYWs7Y2FzZSJBIjp0dD1mKHtyeDpxWzFdLHJ5OnFbMl0scHg6UixweTpDLHhBeGlzUm90YXRpb246cVszXSxsYXJnZUFyY0ZsYWc6cVs0XSxzd2VlcEZsYWc6cVs1XSxjeDpxWzZdLGN5OnFbN119KSxudD10dFt0dC5sZW5ndGgtMV0sdHQuZm9yRWFjaChmdW5jdGlvbihqLFcpe1c9PT0wP1EucHVzaChbUixDLGoueDEsai55MSxqLngyLGoueTIsai54LGoueV0pOlEucHVzaChbdHRbVy0xXS54LHR0W1ctMV0ueSxqLngxLGoueTEsai54MixqLnkyLGoueCxqLnldKX0pLFI9bnQueCxDPW50Lnk7YnJlYWs7Y2FzZSJRIjpRLnB1c2goRS5xMmIoUixDLHFbMV0scVsyXSxxWzNdLHFbNF0pKSxSPXFbM10sQz1xWzRdO2JyZWFrO2Nhc2UicSI6US5wdXNoKEUucTJiKFIsQyxSK3FbMV0sQytxWzJdLHFbM10rUixxWzRdK0MpKSxSKz1xWzNdLEMrPXFbNF07YnJlYWs7Y2FzZSJUIjp1dFswXT09PSJRInx8dXRbMF09PT0icSI/KEc9Uit1dFszXS11dFsxXSxYPUMrdXRbNF0tdXRbMl0sUS5wdXNoKEUucTJiKFIsQyxHLFgscVsxXSxxWzJdKSkpOih1dFswXT09PSJUInx8dXRbMF09PT0idCIpJiYoUS5wdXNoKEUucTJiKFIsQyxSK1ItRyxDK0MtWCxxWzFdLHFbMl0pKSxHPVIrUi1HLFg9QytDLVgpLFI9cVsxXSxDPXFbMl07YnJlYWs7Y2FzZSJ0Ijp1dFswXT09PSJRInx8dXRbMF09PT0icSI/KEc9Uit1dFszXS11dFsxXSxYPUMrdXRbNF0tdXRbMl0sUS5wdXNoKEUucTJiKFIsQyxHLFgsUitxWzFdLEMrcVsyXSkpKToodXRbMF09PT0iVCJ8fHV0WzBdPT09InQiKSYmKFEucHVzaChFLnEyYihSLEMsUitSLUcsQytDLVgsUitxWzFdLEMrcVsyXSkpLEc9UitSLUcsWD1DK0MtWCksUis9cVsxXSxDKz1xWzJdO2JyZWFrO2Nhc2UiWiI6Xz1RWzBdWzBdLEY9UVswXVsxXSxRLnB1c2goW1IsQyxfLEYsXyxGLF8sRl0pO2JyZWFrO2Nhc2UieiI6Xz1RWzBdWzBdLEY9UVswXVsxXSxRLnB1c2goW1IsQyxfLEYsXyxGLF8sRl0pO2JyZWFrfX1yZXR1cm4gS30sRS5fdXBDdXJ2ZXM9ZnVuY3Rpb24oSSxEKXtmb3IodmFyIFI9MCxDPTAsQj1JLmxlbmd0aDtSPEQ7UisrKUkucHVzaChJW0NdLnNsaWNlKDApKSxDKyssQz5CLTEmJihDLT1CKX07ZnVuY3Rpb24gQShJLEQsUixDLEIseixLLFEsXyl7cmV0dXJue2xlZnQ6TChJLEQsUixDLEIseixLLFEsXykscmlnaHQ6TChLLFEsQix6LFIsQyxJLEQsMS1fLCEwKX19ZnVuY3Rpb24gTChJLEQsUixDLEIseixLLFEsXyxGKXt2YXIgRz0oUi1JKSpfK0ksWD0oQy1EKSpfK0QsWj0oQi1SKSpfK1IsdHQ9KHotQykqXytDLG50PShLLUIpKl8rQixxPShRLXopKl8reixodD0oWi1HKSpfK0csdXQ9KHR0LVgpKl8rWCxqPShudC1aKSpfK1osVz0ocS10dCkqXyt0dCxWPShqLWh0KSpfK2h0LEo9KFctdXQpKl8rdXQ7cmV0dXJuIEY/W1YsSixodCx1dCxHLFgsSSxEXTpbSSxELEcsWCxodCx1dCxWLEpdfUUuX3NwbGl0Q3VydmVzPWZ1bmN0aW9uKEksRCl7Zm9yKHZhciBSPTAsQz0wO1I8RDtSKyspe3ZhciBCPUlbQ10sej1BKEJbMF0sQlsxXSxCWzJdLEJbM10sQls0XSxCWzVdLEJbNl0sQls3XSwuNSk7SS5zcGxpY2UoQywxKSxJLnNwbGljZShDLDAsei5sZWZ0LHoucmlnaHQpLEMrPTIsQz49SS5sZW5ndGgtMSYmKEM9MCl9fTtmdW5jdGlvbiBNKEksRCl7Zm9yKHZhciBSPWZ1bmN0aW9uKHope3ZhciBLPUlbSS5sZW5ndGgtMV0sUT1bXTtLLmZvckVhY2goZnVuY3Rpb24oXyl7US5wdXNoKF8uc2xpY2UoMCkpfSksSS5wdXNoKFEpfSxDPTA7QzxEO0MrKylSKCl9cmV0dXJuIEUubGVycD1mdW5jdGlvbihJLEQsUil7cmV0dXJuIEUuX2xlcnAoRS5wYXRoMnNoYXBlcyhJKSxFLnBhdGgyc2hhcGVzKEQpLFIpfSxFLk1JTV9DVVJWRVNfQ09VTlQ9MTAwLEUuX3ByZXByb2Nlc3Npbmc9ZnVuY3Rpb24oSSxEKXt2YXIgUj1JLmxlbmd0aCxDPUQubGVuZ3RoLEI9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShJKSksej1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEQpKTtyZXR1cm4gUj5DP00oeixSLUMpOlI8QyYmTShCLEMtUiksQj1oKEIseiksQi5mb3JFYWNoKGZ1bmN0aW9uKEssUSl7dmFyIF89Sy5sZW5ndGgsRj16W1FdLmxlbmd0aDtfPkY/XzxFLk1JTV9DVVJWRVNfQ09VTlQ/KEUuX3NwbGl0Q3VydmVzKEssRS5NSU1fQ1VSVkVTX0NPVU5ULV8pLEUuX3NwbGl0Q3VydmVzKHpbUV0sRS5NSU1fQ1VSVkVTX0NPVU5ULUYpKTpFLl9zcGxpdEN1cnZlcyh6W1FdLF8tRik6XzxGJiYoRjxFLk1JTV9DVVJWRVNfQ09VTlQ/KEUuX3NwbGl0Q3VydmVzKEssRS5NSU1fQ1VSVkVTX0NPVU5ULV8pLEUuX3NwbGl0Q3VydmVzKHpbUV0sRS5NSU1fQ1VSVkVTX0NPVU5ULUYpKTpFLl9zcGxpdEN1cnZlcyhLLEYtXykpfSksQi5mb3JFYWNoKGZ1bmN0aW9uKEssUSl7QltRXT1vKEsseltRXSl9KSxbQix6XX0sRS5fbGVycD1mdW5jdGlvbihJLEQsUil7dmFyIEM9W107cmV0dXJuIEkuZm9yRWFjaChmdW5jdGlvbihCLHope3ZhciBLPVtdO0IuZm9yRWFjaChmdW5jdGlvbihRLF8pe0sucHVzaChFLmxlcnBDdXJ2ZShRLERbel1bX10sUikpfSksQy5wdXNoKEspfSksQ30sRS5hbmltYXRlPWZ1bmN0aW9uKEkpe3ZhciBEPUUucGF0aDJzaGFwZXMoSS5mcm9tKSxSPUUucGF0aDJzaGFwZXMoSS50byksQz1FLl9wcmVwcm9jZXNzaW5nKEQsUiksQj1uZXcgRGF0ZSx6PUkuZW5kfHxmdW5jdGlvbigpe30sSz1JLnByb2dyZXNzfHxmdW5jdGlvbigpe30sUT1JLmJlZ2lufHxmdW5jdGlvbigpe30sXz1JLmVhc2luZ3x8ZnVuY3Rpb24odHQpe3JldHVybiB0dH0sRj1udWxsLEc9bnVsbCxYPUkudGltZTtRKEQpO3ZhciBaPWZ1bmN0aW9uIHR0KCl7dmFyIG50PW5ldyBEYXRlLUI7aWYobnQ+PVgpe0c9UixLKEcsMSkseihHKSxjYW5jZWxBbmltYXRpb25GcmFtZShGKTtyZXR1cm59dmFyIHE9XyhudC9YKTtHPUUuX2xlcnAoQ1swXSxDWzFdLHEpLEsoRyxxKSxGPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0dCl9O1ooKX0sRX0pfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCg3MSksbj10KDIyMSksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxzPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZCl7c3VwZXIoZCksdGhpc1thXSh7ZDoiIixub3JtYWxpemU6ITEsZmlsbENvbG9yOnZvaWQgMCxmaWxsUnVsZToibm9uemVybyIsc3Ryb2tlQ29sb3I6dm9pZCAwLGxpbmVXaWR0aDoxLGxpbmVKb2luOiJtaXRlciIsbGluZUNhcDoiYnV0dCIscm91bmRTZWdtZW50czoyMCxsaW5lRGFzaDp2b2lkIDAsbGluZURhc2hPZmZzZXQ6MCxtaXRlckxpbWl0OjEwLHRleHR1cmU6dm9pZCAwLHRleHR1cmVSZWN0OnZvaWQgMCx0ZXh0dXJlUmVwZWF0OiExLHNvdXJjZVJlY3Q6dm9pZCAwLGNsaXBQYXRoOnZvaWQgMH0pfWdldCBkKCl7cmV0dXJuIHRoaXNbc10oImQiKX1zZXQgZChkKXt0aGlzW2xdKCJkIixkKX1nZXQgbm9ybWFsaXplKCl7cmV0dXJuIHRoaXNbc10oIm5vcm1hbGl6ZSIpfXNldCBub3JtYWxpemUoZCl7dGhpc1tsXSgibm9ybWFsaXplIiwhIWQpfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1tzXSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcihkKXt0aGlzW2xdKCJmaWxsQ29sb3IiLE9iamVjdChuLnBhcnNlQ29sb3IpKGQpKX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tzXSgiZmlsbFJ1bGUiKX1zZXQgZmlsbFJ1bGUoZCl7aWYoZCE9bnVsbCYmZCE9PSJub256ZXJvIiYmZCE9PSJldmVub2RkIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGZpbGwgcnVsZS4iKTt0aGlzW2xdKCJmaWxsUnVsZSIsZCl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbc10oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKGQpe3RoaXNbbF0oInN0cm9rZUNvbG9yIixPYmplY3Qobi5wYXJzZUNvbG9yKShkKSl9Z2V0IGxpbmVXaWR0aCgpe3JldHVybiB0aGlzW3NdKCJsaW5lV2lkdGgiKX1zZXQgbGluZVdpZHRoKGQpe3RoaXNbbF0oImxpbmVXaWR0aCIsT2JqZWN0KGkudG9OdW1iZXIpKGQpKX1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1tzXSgibGluZUpvaW4iKX1zZXQgbGluZUpvaW4oZCl7aWYoZCE9bnVsbCYmZCE9PSJtaXRlciImJmQhPT0iYmV2ZWwiJiZkIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVKb2luIHR5cGUuIik7dGhpc1tsXSgibGluZUpvaW4iLGQpfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbc10oImxpbmVDYXAiKX1zZXQgbGluZUNhcChkKXtpZihkIT1udWxsJiZkIT09ImJ1dHQiJiZkIT09InNxdWFyZSImJmQhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUNhcCB0eXBlLiIpO3RoaXNbbF0oImxpbmVDYXAiLGQpfWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW3NdKCJsaW5lRGFzaCIpfXNldCBsaW5lRGFzaChkKXtkPU9iamVjdChpLnRvQXJyYXkpKGQsITApLGQhPW51bGwmJiFBcnJheS5pc0FycmF5KGQpJiYoZD1bZF0pLHRoaXNbbF0oImxpbmVEYXNoIixkP2QubWFwKGkudG9OdW1iZXIpOm51bGwpfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW3NdKCJsaW5lRGFzaE9mZnNldCIpfXNldCBsaW5lRGFzaE9mZnNldChkKXt0aGlzW2xdKCJsaW5lRGFzaE9mZnNldCIsT2JqZWN0KGkudG9OdW1iZXIpKGQpKX1nZXQgbWl0ZXJMaW1pdCgpe3JldHVybiB0aGlzW3NdKCJtaXRlckxpbWl0Iil9c2V0IG1pdGVyTGltaXQoZCl7dGhpc1tsXSgibWl0ZXJMaW1pdCIsT2JqZWN0KGkudG9OdW1iZXIpKGQpKX1nZXQgcm91bmRTZWdtZW50cygpe3JldHVybiB0aGlzW3NdKCJyb3VuZFNlZ21lbnRzIil9c2V0IHJvdW5kU2VnbWVudHMoZCl7dGhpc1tsXSgicm91bmRTZWdtZW50cyIsZCl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tzXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGQpe3RoaXNbbF0oInRleHR1cmUiLGQpfWdldCB0ZXh0dXJlUmVjdCgpe3JldHVybiB0aGlzW3NdKCJ0ZXh0dXJlUmVjdCIpfXNldCB0ZXh0dXJlUmVjdChkKXt0aGlzW2xdKCJ0ZXh0dXJlUmVjdCIsZCl9Z2V0IHNvdXJjZVJlY3QoKXtyZXR1cm4gdGhpc1tzXSgic291cmNlUmVjdCIpfXNldCBzb3VyY2VSZWN0KGQpe3RoaXNbbF0oInNvdXJjZVJlY3QiLGQpfWdldCB0ZXh0dXJlUmVwZWF0KCl7cmV0dXJuIHRoaXNbc10oInRleHR1cmVSZXBlYXQiKX1zZXQgdGV4dHVyZVJlcGVhdChkKXt0aGlzW2xdKCJ0ZXh0dXJlUmVwZWF0IiwhIWQpfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW3NdKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aChkKXt0aGlzW2xdKCJjbGlwUGF0aCIsZCl9fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoMjI2KSxuPXQoMjEzKSxpPXQoMjMwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShzLGYsdil7cmV0dXJuIGYgaW4gcz9PYmplY3QuZGVmaW5lUHJvcGVydHkocyxmLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6c1tmXT12LHN9Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7d2lkdGg6ZixoZWlnaHQ6dn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmPjAmJnY+MCYmc3VwZXIuaXNWaXNpYmxlfX1hKGwsIkF0dHIiLGkuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShsLCJyZWN0Iil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDIyOCksbj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gZihkKXtjb25zdHt3aWR0aDpwLGhlaWdodDp5fT1kO3JldHVybmBNMCAwTCR7cH0gMEwke3B9ICR7eX1MMCAke3l9WmB9Y2xhc3MgdiBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ldKHt3aWR0aDowLGhlaWdodDowfSksdGhpc1tzXSgic2l6ZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbbF0oImQiKX1zZXQgZChwKXt9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbbF0oIndpZHRoIil9c2V0IHdpZHRoKHApe2lmKHA9T2JqZWN0KG4udG9OdW1iZXIpKHApLHRoaXNbYV0oIndpZHRoIixwKSl7Y29uc3QgeT1mKHRoaXMpO3RoaXNbYV0oImQiLHkpfX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbbF0oImhlaWdodCIpfXNldCBoZWlnaHQocCl7aWYocD1PYmplY3Qobi50b051bWJlcikocCksdGhpc1thXSgiaGVpZ2h0IixwKSl7Y29uc3QgeT1mKHRoaXMpO3RoaXNbYV0oImQiLHkpfX1nZXQgc2l6ZSgpe3JldHVyblt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XX1zZXQgc2l6ZShwKXtwPU9iamVjdChuLnRvQXJyYXkpKHApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzLndpZHRoPXBbMF0sdGhpcy5oZWlnaHQ9cFsxXX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMzIpLG49dCgyMTMpLGk9dCgyMzUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKHMsZix2KXtyZXR1cm4gZiBpbiBzP09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLGYse3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpzW2ZdPXYsc31jbGFzcyBsIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczpmfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGZbMF0+MCYmZlsxXT4wJiZzdXBlci5pc1Zpc2libGV9fWEobCwiQXR0ciIsaS5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGwsInRyaWFuZ2xlIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDIyNiksbj10KDIxMyksaT10KDIzMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEocyxmLHYpe3JldHVybiBmIGluIHM/T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsZix7dmFsdWU6dixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnNbZl09dixzfWNsYXNzIGwgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3BvaW50czpmfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGYubGVuZ3RoPjAmJnN1cGVyLmlzVmlzaWJsZX19YShsLCJBdHRyIixpLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUobCwicG9seWxpbmUiKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciByPXQoMjI4KSxuPXQoNzIpLGk9dCgyMzQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB2KHApe2NvbnN0e3BvaW50czp5LHNtb290aDpQLHNtb290aFJhbmdlOngsY2xvc2U6bX09cCxPPVtdO2ZvcihsZXQgaD0wO2g8eS5sZW5ndGg7aCs9MilPLnB1c2goW3lbaF0seVtoKzFdXSk7bGV0IG89IiI7cmV0dXJuIFA/bz1PYmplY3QoaS5tYWtlU21vb3RoQ3VydmVMaW5lKShPLHgpOk8ubGVuZ3RoJiYobz1gTSR7Ty5tYXAoaD0+aC5qb2luKCIgIikpLmpvaW4oIkwiKX1gKSxvJiZtJiYobys9IloiKSxvfWNsYXNzIGQgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1thXSh7cG9pbnRzOltdLHNtb290aDohMSxzbW9vdGhSYW5nZTpbMF0sY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbZl0oImNsb3NlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1tzXSgiZCIpfXNldCBkKHkpe31nZXQgY2xvc2UoKXtyZXR1cm4gdGhpcy5jbG9zZVR5cGUhPT0ibm9uZSJ9c2V0IGNsb3NlKHkpe3k9eT8ibm9ybWFsIjoibm9uZSIsdGhpcy5jbG9zZVR5cGU9eX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbc10oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUoeSl7aWYoeSE9bnVsbCYmeSE9PSJub25lIiYmeSE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1tsXSgiY2xvc2VUeXBlIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgc21vb3RoKCl7cmV0dXJuIHRoaXNbc10oInNtb290aCIpfXNldCBzbW9vdGgoeSl7aWYodGhpc1tsXSgic21vb3RoIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgc21vb3RoUmFuZ2UoKXtyZXR1cm4gdGhpc1tzXSgic21vb3RoUmFuZ2UiKX1zZXQgc21vb3RoUmFuZ2UoeSl7aWYoeSYmIUFycmF5LmlzQXJyYXkoeSkmJih5PVt5XSksdGhpc1tsXSgic21vb3RoUmFuZ2UiLHkpJiZ0aGlzLnNtb290aCl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgcG9pbnRzKCl7cmV0dXJuIHRoaXNbc10oInBvaW50cyIpfXNldCBwb2ludHMoeSl7aWYoeT1PYmplY3Qobi50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpJiYoeT15LnJlZHVjZSgoUCx4KT0+QXJyYXkuaXNBcnJheSh4KT9bLi4uUCwuLi54Lm1hcChtPT5PYmplY3Qobi50b051bWJlcikobSkpXTpbLi4uUCxPYmplY3Qobi50b051bWJlcikoeCldLFtdKSksdGhpc1tsXSgicG9pbnRzIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJtYWtlU21vb3RoQ3VydmVMaW5lIixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIobixpPVswXSl7ZnVuY3Rpb24gYShmLHY9LjE2OCxkPS4xNjgpe2xldCBwLHksUCx4O2lmKChuW2ZdLng9PT1uW2YrMV0ueHx8bltmXS55PT09bltmKzFdLnkpJiYodj0wLGQ9MCksZjwxPyhwPW5bMF0ueCsoblsxXS54LW5bMF0ueCkqdix5PW5bMF0ueSsoblsxXS55LW5bMF0ueSkqdik6KHA9bltmXS54KyhuW2YrMV0ueC1uW2YtMV0ueCkqdix5PW5bZl0ueSsobltmKzFdLnktbltmLTFdLnkpKnYpLGY+bi5sZW5ndGgtMyl7Y29uc3QgbT1uLmxlbmd0aC0xO1A9blttXS54LShuW21dLngtblttLTFdLngpKmQseD1uW21dLnktKG5bbV0ueS1uW20tMV0ueSkqZH1lbHNlIFA9bltmKzFdLngtKG5bZisyXS54LW5bZl0ueCkqZCx4PW5bZisxXS55LShuW2YrMl0ueS1uW2ZdLnkpKmQ7cmV0dXJuW3t4OnAseX0se3g6UCx5Onh9XX1uPW4ubWFwKChbZix2XSk9Pih7eDpmLHk6dn0pKTtsZXQgbD0iIixzPTA7cmV0dXJuIG4uZm9yRWFjaCgoZix2KT0+e2lmKHY9PT0wKWwrPWBNJHtmLnh9ICR7Zi55fWA7ZWxzZXtmb3IoO3Y+aVtzXTspcysrO2lmKHMlMil7Y29uc3RbZCxwXT1hKHYtMSk7bCs9YEMke1tkLngsZC55LHAueCxwLnksZi54LGYueV0uam9pbigiICIpfWB9ZWxzZSBsKz1gTCR7Zi54fSAke2YueX1gfX0pLGx9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBzKHYpe2NvbnN0W2QscF09di5zaWRlcztsZXQgeT12LmFuZ2xlJTM2MDtyZXR1cm4geTwwJiYoeSs9MzYwKSx5PU1hdGguUEkqeS8xODAsWzAsMCxkLDAscCpNYXRoLmNvcyh5KSxwKk1hdGguc2luKHkpXX1jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGQpe3N1cGVyKGQpLHRoaXNbaV0oe3NpZGVzOlswLDBdLGFuZ2xlOjYwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZCl7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW2xdKCJzaWRlcyIpfXNldCBzaWRlcyhkKXtpZihkPU9iamVjdChuLnRvQXJyYXkpKGQsITApLGQhPW51bGwmJiFBcnJheS5pc0FycmF5KGQpJiYoZD1bZCxkXSksdGhpc1thXSgic2lkZXMiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW2xdKCJhbmdsZSIpfXNldCBhbmdsZShkKXtpZihkPU9iamVjdChuLnRvTnVtYmVyKShkKSx0aGlzW2FdKCJhbmdsZSIsZCkpe2NvbnN0IHA9cyh0aGlzKTtzdXBlci5wb2ludHM9cH19fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxpPXQoMjM3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShzLGYsdil7cmV0dXJuIGYgaW4gcz9PYmplY3QuZGVmaW5lUHJvcGVydHkocyxmLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6c1tmXT12LHN9Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6Zn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmWzBdPjAmJmZbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX1hKGwsIkF0dHIiLGkuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShsLCJwYXJhbGxlbCIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBzKHYpe2NvbnN0W2QscF09di5zaWRlcztsZXQgeT12LmFuZ2xlJTM2MDt5PDAmJih5Kz0zNjApLHk9TWF0aC5QSSp5LzE4MDtjb25zdCBQPXAqTWF0aC5jb3MoeSkseD1wKk1hdGguc2luKHkpO3JldHVyblswLDAsZCwwLFArZCx4LFAseF19Y2xhc3MgZiBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihkKXtzdXBlcihkKSx0aGlzW2ldKHtzaWRlczpbMCwwXSxhbmdsZTo5MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGQpe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1tsXSgic2lkZXMiKX1zZXQgc2lkZXMoZCl7aWYoZD1PYmplY3Qobi50b0FycmF5KShkLCEwKSxkIT1udWxsJiYhQXJyYXkuaXNBcnJheShkKSYmKGQ9W2QsZF0pLHRoaXNbYV0oInNpZGVzIixkKSl7Y29uc3QgcD1zKHRoaXMpO3N1cGVyLnBvaW50cz1wfX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1tsXSgiYW5nbGUiKX1zZXQgYW5nbGUoZCl7aWYoZD1PYmplY3Qobi50b051bWJlcikoZCksdGhpc1thXSgiYW5nbGUiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDIzMiksbj10KDIxMyksaT10KDIzOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEocyxmLHYpe3JldHVybiBmIGluIHM/T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsZix7dmFsdWU6dixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnNbZl09dixzfWNsYXNzIGwgZXh0ZW5kcyByLmRlZmF1bHR7fWEobCwiQXR0ciIsaS5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGwsInJlZ3VsYXIiKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMjMzKSxuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gcyh2KXtjb25zdHtlZGdlczpkLHJhZGl1czpwLG9mZnNldEFuZ2xlOnl9PXYsUD1NYXRoLlBJKnkvMTgwLS41Kk1hdGguUEk7aWYoZDwzfHxwPD0wKXJldHVybltdO2NvbnN0IHg9W107Zm9yKGxldCBtPTA7bTxkO20rKyl7Y29uc3QgTz1tKjIqTWF0aC5QSS9kK1Asbz1wKk1hdGguY29zKE8pLGg9cCpNYXRoLnNpbihPKTt4LnB1c2gobyxoKX1yZXR1cm4geH1jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGQpe3N1cGVyKGQpLHRoaXNbaV0oe2VkZ2VzOjMscmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGQpe31nZXQgZWRnZXMoKXtyZXR1cm4gdGhpc1tsXSgiZWRnZXMiKX1zZXQgZWRnZXMoZCl7aWYoZD1PYmplY3Qobi50b051bWJlcikoZCksdGhpc1thXSgiZWRnZXMiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fWdldCByYWRpdXMoKXtyZXR1cm4gdGhpc1tsXSgicmFkaXVzIil9c2V0IHJhZGl1cyhkKXtpZihkPU9iamVjdChuLnRvTnVtYmVyKShkKSx0aGlzW2FdKCJyYWRpdXMiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW2xdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShkKXtpZihkPU9iamVjdChuLnRvTnVtYmVyKShkKSx0aGlzW2FdKCJvZmZzZXRBbmdsZSIsZCkpe2NvbnN0IHA9cyh0aGlzKTtzdXBlci5wb2ludHM9cH19fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxpPXQoMjQxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShzLGYsdil7cmV0dXJuIGYgaW4gcz9PYmplY3QuZGVmaW5lUHJvcGVydHkocyxmLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6c1tmXT12LHN9Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHt9YShsLCJBdHRyIixpLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUobCwic3RhciIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBzKHYpe2NvbnN0e2FuZ2xlczpkLGlubmVyUmFkaXVzOnAsb3V0ZXJSYWRpdXM6eSxvZmZzZXRBbmdsZTpQfT12LHg9TWF0aC5QSSpQLzE4MC0uNSpNYXRoLlBJO2lmKGQ8M3x8cDw9MHx8eTw9MClyZXR1cm5bXTtjb25zdCBtPVtdO2ZvcihsZXQgTz0wO088ZCoyO08rKyl7Y29uc3Qgbz1PKk1hdGguUEkvZCt4LGg9TyUyP3A6eSxjPWgqTWF0aC5jb3MobyksZz1oKk1hdGguc2luKG8pO20ucHVzaChjLGcpfXJldHVybiBtfWNsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZCl7c3VwZXIoZCksdGhpc1tpXSh7YW5nbGVzOjUsaW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhkKXt9Z2V0IGFuZ2xlcygpe3JldHVybiB0aGlzW2xdKCJhbmdsZXMiKX1zZXQgYW5nbGVzKGQpe2lmKGQ9T2JqZWN0KG4udG9OdW1iZXIpKGQpLHRoaXNbYV0oImFuZ2xlcyIsZCkpe2NvbnN0IHA9cyh0aGlzKTtzdXBlci5wb2ludHM9cH19Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbbF0oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKGQpe2lmKGQ9T2JqZWN0KG4udG9OdW1iZXIpKGQpLHRoaXNbYV0oImlubmVyUmFkaXVzIixkKSl7Y29uc3QgcD1zKHRoaXMpO3N1cGVyLnBvaW50cz1wfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tsXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoZCl7aWYoZD1PYmplY3Qobi50b051bWJlcikoZCksdGhpc1thXSgib3V0ZXJSYWRpdXMiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKGQpe2Q9T2JqZWN0KG4udG9BcnJheSkoZCwhMCksQXJyYXkuaXNBcnJheShkKXx8KGQ9W2QsZF0pLHRoaXMuaW5uZXJSYWRpdXM9ZFswXSx0aGlzLm91dGVyUmFkaXVzPWRbMV19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbbF0oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGQpe2lmKGQ9T2JqZWN0KG4udG9OdW1iZXIpKGQpLHRoaXNbYV0oIm9mZnNldEFuZ2xlIixkKSl7Y29uc3QgcD1zKHRoaXMpO3N1cGVyLnBvaW50cz1wfX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLGk9dCgyNDMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKHMsZix2KXtyZXR1cm4gZiBpbiBzP09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLGYse3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpzW2ZdPXYsc31jbGFzcyBsIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtyYWRpdXNYOmYscmFkaXVzWTp2LHN0YXJ0QW5nbGU6ZCxlbmRBbmdsZTpwfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGY+MCYmdj4wJiZkIT09cCYmc3VwZXIuaXNWaXNpYmxlfX1hKGwsIkF0dHIiLGkuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShsLCJlbGxpcHNlIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB2KHApe2NvbnN0e3JhZGl1c1g6eSxyYWRpdXNZOlAsc3RhcnRBbmdsZTp4LGVuZEFuZ2xlOm0sZGlyZWN0aW9uOk8sY2xvc2VUeXBlOm99PXAsaD1PPT09ImFuaXRjbG9ja3dpc2UiLGM9bmV3IHIuRmlndXJlMkQ7cmV0dXJuIG89PT0ic2VjdG9yIiYmYy5tb3ZlVG8oMCwwKSxjLmVsbGlwc2UoMCwwLHksUCwwLE1hdGguUEkqeC8xODAsTWF0aC5QSSptLzE4MCxoKSxvIT09Im5vbmUiJiZjLmNsb3NlUGF0aCgpLGMucGF0aC5yZWR1Y2UoKEUsQSk9PkUrQS5qb2luKCIgIiksIiIpfWNsYXNzIGQgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1thXSh7cmFkaXVzWDowLHJhZGl1c1k6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwLGRpcmVjdGlvbjoiY2xvY2t3aXNlIixjbG9zZVR5cGU6Im5vbmUifSksdGhpc1tmXSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW3NdKCJkIil9c2V0IGQoeSl7fWdldCByYWRpdXNYKCl7cmV0dXJuIHRoaXNbc10oInJhZGl1c1giKX1zZXQgcmFkaXVzWCh5KXtpZih5PU9iamVjdChpLnRvTnVtYmVyKSh5KSx0aGlzW2xdKCJyYWRpdXNYIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgcmFkaXVzWSgpe3JldHVybiB0aGlzW3NdKCJyYWRpdXNZIil9c2V0IHJhZGl1c1koeSl7aWYoeT1PYmplY3QoaS50b051bWJlcikoeSksdGhpc1tsXSgicmFkaXVzWSIseSkpe2NvbnN0IFA9dih0aGlzKTt0aGlzW2xdKCJkIixQKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLnJhZGl1c1gsdGhpcy5yYWRpdXNZXX1zZXQgcmFkaXVzKHkpe3k9T2JqZWN0KGkudG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMucmFkaXVzWD15WzBdLHRoaXMucmFkaXVzWT15WzFdfWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKHkpe3k9T2JqZWN0KGkudG9BcnJheSkoeSksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMuc3RhcnRBbmdsZT15WzBdLHRoaXMuZW5kQW5nbGU9eVsxXX1nZXQgZGlyZWN0aW9uKCl7cmV0dXJuIHRoaXNbc10oImRpcmVjdGlvbiIpfXNldCBkaXJlY3Rpb24oeSl7aWYoeSE9bnVsbCYmeSE9PSJjbG9ja3dpc2UiJiZ5IT09ImFudGljbG9ja3dpc2UiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZGlyZWN0aW9uIHR5cGUuIik7dGhpc1tsXSgiZGlyZWN0aW9uIix5KX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW3NdKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUoeSl7aWYoeT1PYmplY3QoaS50b051bWJlcikoeSksdGhpc1tsXSgic3RhcnRBbmdsZSIseSkpe2NvbnN0IFA9dih0aGlzKTt0aGlzW2xdKCJkIixQKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbc10oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKHkpe2lmKHk9T2JqZWN0KGkudG9OdW1iZXIpKHkpLHRoaXNbbF0oImVuZEFuZ2xlIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbc10oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUoeSl7aWYoeSE9bnVsbCYmeSE9PSJub25lIiYmeSE9PSJzZWN0b3IiJiZ5IT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW2xdKCJjbG9zZVR5cGUiLHkpKXtjb25zdCBQPXYodGhpcyk7dGhpc1tsXSgiZCIsUCl9fX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDI0Miksbj10KDIxMyksaT10KDI0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEocyxmLHYpe3JldHVybiBmIGluIHM/T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsZix7dmFsdWU6dixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnNbZl09dixzfWNsYXNzIGwgZXh0ZW5kcyByLmRlZmF1bHR7fWEobCwiQXR0ciIsaS5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGwsImFyYyIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBpfSk7dmFyIHI9dCgyNDMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIGkgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IHJhZGl1cygpe3JldHVybiBzdXBlci5yYWRpdXNYfXNldCByYWRpdXMobCl7bD1PYmplY3Qobi50b051bWJlcikobCksc3VwZXIucmFkaXVzWD1sLHN1cGVyLnJhZGl1c1k9bH19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLGk9dCgyNDcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKHMsZix2KXtyZXR1cm4gZiBpbiBzP09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLGYse3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpzW2ZdPXYsc31jbGFzcyBsIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtpbm5lclJhZGl1czpmLG91dGVyUmFkaXVzOnYsc3RhcnRBbmdsZTpkLGVuZEFuZ2xlOnB9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4oZj4wfHx2PjApJiZkIT09cCYmc3VwZXIuaXNWaXNpYmxlfX1hKGwsIkF0dHIiLGkuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShsLCJyaW5nIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB2KHApe2xldHtpbm5lclJhZGl1czp5LG91dGVyUmFkaXVzOlAsc3RhcnRBbmdsZTp4LGVuZEFuZ2xlOm19PXA7Y29uc3QgTz1uZXcgci5GaWd1cmUyRDtpZih4PU1hdGguUEkqeC8xODAsbT1NYXRoLlBJKm0vMTgwLHk+UCYmKFt5LFBdPVtQLHldKSx5PD0wJiZPLm1vdmVUbygwLDApLE8uYXJjKDAsMCxQLHgsbSwhMSkseT4wKXtjb25zdCBjPU1hdGguUEkqMjttPHgmJihtPXgrYysobS14KSVjKSxtLXg+PWMmJihtPXgrYy0xZS02KSxPLmFyYygwLDAseSxtLHgsITApfXJldHVybiBPLmNsb3NlUGF0aCgpLE8ucGF0aC5yZWR1Y2UoKGMsZyk9PmMrZy5qb2luKCIgIiksIiIpfWNsYXNzIGQgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1thXSh7aW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjB9KSx0aGlzW2ZdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbc10oImQiKX1zZXQgZCh5KXt9Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbc10oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKHkpe2lmKHk9T2JqZWN0KGkudG9OdW1iZXIpKHkpLHRoaXNbbF0oImlubmVyUmFkaXVzIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tzXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoeSl7aWYoeT1PYmplY3QoaS50b051bWJlcikoeSksdGhpc1tsXSgib3V0ZXJSYWRpdXMiLHkpKXtjb25zdCBQPXYodGhpcyk7dGhpc1tsXSgiZCIsUCl9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKHkpe3k9T2JqZWN0KGkudG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMuaW5uZXJSYWRpdXM9eVswXSx0aGlzLm91dGVyUmFkaXVzPXlbMV19Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1tzXSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKHkpe2lmKHk9T2JqZWN0KGkudG9OdW1iZXIpKHkpLHRoaXNbbF0oInN0YXJ0QW5nbGUiLHkpKXtjb25zdCBQPXYodGhpcyk7dGhpc1tsXSgiZCIsUCl9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW3NdKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZSh5KXtpZih5PU9iamVjdChpLnRvTnVtYmVyKSh5KSx0aGlzW2xdKCJlbmRBbmdsZSIseSkpe2NvbnN0IFA9dih0aGlzKTt0aGlzW2xdKCJkIixQKX19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUoeSl7eT1PYmplY3QoaS50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpcy5zdGFydEFuZ2xlPXlbMF0sdGhpcy5lbmRBbmdsZT15WzFdfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KTt2YXIgcj10KDEyKSxuPXQoMjE4KSxpPXQoMjE5KSxhPXQoMjQ5KSxsPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyh4LG0sTyl7cmV0dXJuIG0gaW4geD9PYmplY3QuZGVmaW5lUHJvcGVydHkoeCxtLHt2YWx1ZTpPLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6eFttXT1PLHh9Y29uc3QgZj1TeW1ib2woInRleHRJbWFnZSIpLHY9U3ltYm9sKCJ0ZXh0SW1hZ2VUYXNrIiksZD1TeW1ib2woInRleHR1cmVDb250ZXh0IikscD1TeW1ib2woInVwZGF0ZVRleHR1cmVSZWN0IikseT1TeW1ib2woInRleHRDYW52YXMiKTtjbGFzcyBQIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKG09e30pe3R5cGVvZiBtPT0ic3RyaW5nIiYmKG09e3RleHQ6bX0pLHN1cGVyKG0pfWdldCBjb250ZW50U2l6ZSgpe2xldFttLE9dPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOm8saGVpZ2h0Omh9PXRoaXMuYXR0cmlidXRlcztpZihvPT1udWxsfHxoPT1udWxsKXtjb25zdCBjPXRoaXNbZl07YyYmKG89PW51bGwmJihtPWMucmVjdFsyXSksaD09bnVsbCYmKE89Yy5yZWN0WzNdKSl9cmV0dXJuW20sT119Z2V0IHRleHQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHQobSl7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9bX1nZXQgdGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHRDb250ZW50KG0pe3RoaXMuYXR0cmlidXRlcy50ZXh0PW19Z2V0IHRleHRJbWFnZSgpe3JldHVybiB0aGlzW2ZdfHx7fX1nZXQgdGV4dEltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1t2XXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhtKXtzdXBlci5kcmF3KG0pO2NvbnN0IE89dGhpcy5tZXNoO2lmKE8pe2NvbnN0IG89dGhpc1tmXTtpZihvKXtsZXQgaD1PLnRleHR1cmU7aWYoIWh8fHRoaXNbZF0mJnRoaXNbZF0hPT10aGlzLnJlbmRlcmVyfHxvLm5lZWRzVXBkYXRlPyhvLm5lZWRzVXBkYXRlPSExLE9iamVjdChuLmRlbGV0ZVRleHR1cmUpKG8uaW1hZ2UsdGhpcy5yZW5kZXJlciksaD1PYmplY3Qobi5jcmVhdGVUZXh0dXJlKShvLmltYWdlLHRoaXMucmVuZGVyZXIpLHRoaXNbcF09ITApOmg9Ty51bmlmb3Jtcy51X3RleFNhbXBsZXIsdGhpc1twXSl7Y29uc3RbYyxnXT1vLnJlY3Quc2xpY2UoMiksW2IsRV09dGhpcy5jb250ZW50U2l6ZSxBPXRoaXMuYXR0cmlidXRlcy50ZXh0QWxpZ24sTD10aGlzLmF0dHJpYnV0ZXMudmVydGljYWxBbGlnbjtsZXQgTT0wO0E9PT0iY2VudGVyIj9NPShiLWMpLzI6KEE9PT0icmlnaHQifHxBPT09ImVuZCIpJiYoTT1iLWMpO2NvbnN0IEk9dGhpcy5hdHRyaWJ1dGVzLmZvbnRTaXplLEQ9dGhpcy5hdHRyaWJ1dGVzLmxpbmVIZWlnaHQ7bGV0IFI9MDtMPT09InRvcCI/Uj0oSS1EKS8yOkw9PT0iYm90dG9tIiYmKFI9KEQtSSkvMik7Y29uc3R7cGFkZGluZ0xlZnQ6QyxwYWRkaW5nVG9wOkJ9PXRoaXMuYXR0cmlidXRlcyx7Ym9yZGVyV2lkdGg6en09dGhpcy5hdHRyaWJ1dGVzO00rPUMreixSKz1CK3o7Y29uc3R7YW5jaG9yWDpLLGFuY2hvclk6UX09dGhpcy5hdHRyaWJ1dGVzO00tPXRoaXMub2Zmc2V0U2l6ZVswXSpLLFItPXRoaXMub2Zmc2V0U2l6ZVsxXSpRLE8uc2V0VGV4dHVyZShoLHtyZWN0OltNLFIsYyxnXX0pLHRoaXNbcF09ITEsdGhpc1tkXT10aGlzLnJlbmRlcmVyfX19cmV0dXJuIG19b25Qcm9wZXJ0eUNoYW5nZShtLE8sbyl7bT09PSJ0ZXh0Inx8bT09PSJmb250U2l6ZSJ8fG09PT0iZm9udEZhbWlseSJ8fG09PT0iZm9udFN0eWxlInx8bT09PSJmb250VmFyaWFudCJ8fG09PT0iZm9udFdlaWdodCJ8fG09PT0iZm9udFN0cmV0Y2gifHxtPT09ImxpbmVIZWlnaHQifHxtPT09InN0cm9rZUNvbG9yInx8bT09PSJmaWxsQ29sb3IifHxtPT09InN0cm9rZVdpZHRoIj90aGlzLnVwZGF0ZVRleHQoKTooKG09PT0idGV4dEFsaWduInx8bT09PSJ2ZXJ0aWNhbEFsaWduIikmJih0aGlzW3BdPSEwKSxzdXBlci5vblByb3BlcnR5Q2hhbmdlKG0sTyxvKSl9dXBkYXRlQ29udG91cnMoKXtzdXBlci51cGRhdGVDb250b3VycygpLHRoaXNbcF09ITB9dXBkYXRlVGV4dCgpe3RoaXNbdl18fCh0aGlzW3ZdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzW3ZdPW51bGw7Y29uc3R7dGV4dDptLGZvbnQ6TyxmaWxsQ29sb3I6byxzdHJva2VDb2xvcjpoLHN0cm9rZVdpZHRoOmN9PXRoaXMuYXR0cmlidXRlcyxnPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtyZXR1cm4gdGhpc1t5XT10aGlzW3ldfHxyLkVOVi5jcmVhdGVDYW52YXMoMSwxKSx0aGlzW2ZdPXIuRU5WLmNyZWF0ZVRleHQobSx7Zm9udDpPLGZpbGxDb2xvcjpvLHN0cm9rZUNvbG9yOmgsc3Ryb2tlV2lkdGg6YyxwYXJzZUZvbnQ6ci5wYXJzZUZvbnQscmF0aW86Zyx0ZXh0Q2FudmFzOnRoaXNbeV19KSx0aGlzW2ZdLm5lZWRzVXBkYXRlPSEwLHRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpc1tmXX0pKX19cyhQLCJBdHRyIixhLmRlZmF1bHQpLGwuZGVmYXVsdC5yZWdpc3Rlck5vZGUoUCwibGFiZWwiKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciByPXQoMTIpLG49dCg3MiksaT10KDIyMSksYT10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx2PVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2NsYXNzIGQgZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tsXSh7dGV4dDoiIixmb250U2l6ZToxNixmb250RmFtaWx5OiJIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZiIsZm9udFN0eWxlOiJub3JtYWwiLGZvbnRWYXJpYW50OiJub3JtYWwiLGZvbnRXZWlnaHQ6Im5vcm1hbCIsZm9udFN0cmV0Y2g6Im5vcm1hbCIsbGluZUhlaWdodDoiIix0ZXh0QWxpZ246ImxlZnQiLHN0cm9rZUNvbG9yOnZvaWQgMCxzdHJva2VXaWR0aDoxLGZpbGxDb2xvcjp2b2lkIDAsdmVydGljYWxBbGlnbjoibWlkZGxlIn0pLHRoaXNbdl0oImZvbnQiKX1nZXQgdGV4dCgpe3JldHVybiB0aGlzW2ZdKCJ0ZXh0Iil8fCIgIn1zZXQgdGV4dCh5KXt0aGlzW3NdKCJ0ZXh0Iix5KX1nZXQgZm9udFNpemUoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFNpemUiKX1zZXQgZm9udFNpemUoeSl7dGhpc1tzXSgiZm9udFNpemUiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IGZvbnRGYW1pbHkoKXtyZXR1cm4gdGhpc1tmXSgiZm9udEZhbWlseSIpfXNldCBmb250RmFtaWx5KHkpe3RoaXNbc10oImZvbnRGYW1pbHkiLHkpfWdldCBmb250U3R5bGUoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFN0eWxlIil9c2V0IGZvbnRTdHlsZSh5KXt0aGlzW3NdKCJmb250U3R5bGUiLHkpfWdldCBmb250VmFyaWFudCgpe3JldHVybiB0aGlzW2ZdKCJmb250VmFyaWFudCIpfXNldCBmb250VmFyaWFudCh5KXt0aGlzW3NdKCJmb250VmFyaWFudCIseSl9Z2V0IGZvbnRXZWlnaHQoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFdlaWdodCIpfXNldCBmb250V2VpZ2h0KHkpe3RoaXNbc10oImZvbnRXZWlnaHQiLHkpfWdldCBmb250U3RyZXRjaCgpe3JldHVybiB0aGlzW2ZdKCJmb250U3RyZXRjaCIpfXNldCBmb250U3RyZXRjaCh5KXt0aGlzW3NdKCJmb250U3RyZXRjaCIseSl9Z2V0IGxpbmVIZWlnaHQoKXtyZXR1cm4gdGhpc1tmXSgibGluZUhlaWdodCIpfHx0aGlzLmZvbnRTaXplfXNldCBsaW5lSGVpZ2h0KHkpe3RoaXNbc10oImxpbmVIZWlnaHQiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IHRleHRBbGlnbigpe3JldHVybiB0aGlzW2ZdKCJ0ZXh0QWxpZ24iKX1zZXQgdGV4dEFsaWduKHkpe3RoaXNbc10oInRleHRBbGlnbiIseSl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbZl0oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKHkpe3RoaXNbc10oInN0cm9rZUNvbG9yIixPYmplY3QoaS5wYXJzZUNvbG9yKSh5KSl9Z2V0IHN0cm9rZVdpZHRoKCl7cmV0dXJuIHRoaXNbZl0oInN0cm9rZVdpZHRoIil9c2V0IHN0cm9rZVdpZHRoKHkpe3RoaXNbc10oInN0cm9rZVdpZHRoIixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCB2ZXJ0aWNhbEFsaWduKCl7cmV0dXJuIHRoaXNbZl0oInZlcnRpY2FsQWxpZ24iKX1zZXQgdmVydGljYWxBbGlnbih5KXt0aGlzW3NdKCJ2ZXJ0aWNhbEFsaWduIix5KX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbZl0oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IoeSl7dGhpc1tzXSgiZmlsbENvbG9yIixPYmplY3QoaS5wYXJzZUNvbG9yKSh5KSl9Z2V0IGZvbnQoKXtjb25zdHtmb250U3R5bGU6eSxmb250VmFyaWFudDpQLGZvbnRXZWlnaHQ6eCxmb250U3RyZXRjaDptLGZvbnRTaXplOk8sbGluZUhlaWdodDpvLGZvbnRGYW1pbHk6aH09dGhpcztyZXR1cm5gJHt5fSAke1B9ICR7eH0gJHttfSAke099cHgvJHtvfXB4ICR7aH1gfXNldCBmb250KHkpe2lmKHk9PW51bGwpdGhpcy5mb250U3R5bGU9bnVsbCx0aGlzLmZvbnRWYXJpYW50PW51bGwsdGhpcy5mb250V2VpZ2h0PW51bGwsdGhpcy5mb250U3RyZXRjaD1udWxsLHRoaXMuZm9udFNpemU9bnVsbCx0aGlzLmxpbmVIZWlnaHQ9bnVsbCx0aGlzLmZvbnRGYW1pbHk9bnVsbDtlbHNle2NvbnN0IFA9T2JqZWN0KHIucGFyc2VGb250KSh5KTt0aGlzLmZvbnRTdHlsZT1QLnN0eWxlLHRoaXMuZm9udFZhcmlhbnQ9UC52YXJpYW50LHRoaXMuZm9udFdlaWdodD1QLndlaWdodCx0aGlzLmZvbnRTdHJldGNoPVAuc3RyZXRjaCx0aGlzLmZvbnRTaXplPU9iamVjdChuLnRvTnVtYmVyKShgJHtQLnNpemV9JHtQLnVuaXR9YCksUC5saW5lSGVpZ2h0JiYodGhpcy5saW5lSGVpZ2h0PVAucHhMaW5lSGVpZ2h0KSx0aGlzLmZvbnRGYW1pbHk9UC5mYW1pbHl9fX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDEyKSxuPXQoMjE5KSxpPXQoMjUxKSxhPXQoMjEzKSxsPXQoMjUyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyhQLHgsbSl7cmV0dXJuIHggaW4gUD9PYmplY3QuZGVmaW5lUHJvcGVydHkoUCx4LHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6UFt4XT1tLFB9Y29uc3QgZj1TeW1ib2woInpPcmRlciIpLHY9U3ltYm9sKCJvcmRlcmVkIiksZD1TeW1ib2woImNoaWxkcmVuIikscD1TeW1ib2woInNlYWxlZCIpO2NsYXNzIHkgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoeD17fSl7c3VwZXIoeCksdGhpc1tkXT1bXSx0aGlzW3ZdPW51bGwsdGhpc1tmXT0wfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuIHRoaXNbZF19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXNbZF19Z2V0IG9yZGVyZWRDaGlsZHJlbigpe3JldHVybiB0aGlzW3ZdfHwodGhpc1t2XT1bLi4udGhpc1tkXV0sdGhpc1t2XS5zb3J0KCh4LG0pPT54LnpJbmRleC1tLnpJbmRleHx8eC56T3JkZXItbS56T3JkZXIpKSx0aGlzW3ZdfWFwcGVuZCguLi54KXtyZXR1cm4geC5tYXAobT0+dGhpcy5hcHBlbmRDaGlsZChtKSl9YXBwZW5kQ2hpbGQoeCl7cmV0dXJuIHgucmVtb3ZlKCksdGhpc1tkXS5wdXNoKHgpLHguY29ubmVjdCh0aGlzLHRoaXNbZl0rKyksdGhpc1t2XSYmKHRoaXNbdl0ubGVuZ3RoJiZ4LnpJbmRleDx0aGlzW3ZdW3RoaXNbdl0ubGVuZ3RoLTFdLnpJbmRleD90aGlzLnJlb3JkZXIoKTp0aGlzW3ZdLnB1c2goeCkpLHh9Y2xvbmVOb2RlKHg9ITEpe2NvbnN0IG09c3VwZXIuY2xvbmVOb2RlKCk7cmV0dXJuIHgmJnRoaXNbZF0uZm9yRWFjaChPPT57Y29uc3Qgbz1PLmNsb25lTm9kZSh4KTttLmFwcGVuZENoaWxkKG8pfSksbX1kaXNwYXRjaFBvaW50ZXJFdmVudCh4KXtjb25zdCBtPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgTz1tLmxlbmd0aC0xO08+PTA7Ty0tKWlmKG1bT10uZGlzcGF0Y2hQb2ludGVyRXZlbnQoeCkpcmV0dXJuITA7cmV0dXJuIHN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KHgpfWRyYXcoeD1bXSl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PXRoaXMucmVuZGVyTWF0cml4LHN1cGVyLmRyYXcoeCksIXRoaXNbcF0mJnRoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiKXtjb25zdCBtPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgTz0wO088bS5sZW5ndGg7TysrKW1bT10uZHJhdyh4KX1yZXR1cm4gdGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PW51bGwseH1nZXRFbGVtZW50QnlJZCh4KXtyZXR1cm4gT2JqZWN0KGwucXVlcnlTZWxlY3RvcikoYCMke3h9YCx0aGlzKX1nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHgpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yQWxsKShgLiR7eH1gLHRoaXMpfWdldEVsZW1lbnRzQnlOYW1lKHgpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yQWxsKShgW25hbWU9IiR7eH0iXWAsdGhpcyl9Z2V0RWxlbWVudHNCeVRhZ05hbWUoeCl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKHgsdGhpcyl9aW5zZXJ0QmVmb3JlKHgsbSl7aWYobT09bnVsbClyZXR1cm4gdGhpcy5hcHBlbmRDaGlsZCh4KTt4LnJlbW92ZSgpO2NvbnN0IE89dGhpc1tkXS5pbmRleE9mKG0pO2lmKE88MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7Y29uc3Qgbz1tLnpPcmRlcjtmb3IobGV0IGg9TztoPHRoaXNbZF0ubGVuZ3RoO2grKyl7Y29uc3QgYz10aGlzW2RdW2hdLnpPcmRlcixnPXRoaXNbZF1baF07ZGVsZXRlIGcuek9yZGVyLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnLCJ6T3JkZXIiLHt2YWx1ZTpjKzEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9aWYodGhpc1tkXS5zcGxpY2UoTywwLHgpLHguY29ubmVjdCh0aGlzLG8pLHRoaXNbdl0paWYoeC56SW5kZXghPT1tLnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IGg9dGhpc1t2XS5pbmRleE9mKG0pO3RoaXNbdl0uc3BsaWNlKGgsMCx4KX1yZXR1cm4geH1xdWVyeVNlbGVjdG9yKHgpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yKSh4LHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoeCl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKHgsdGhpcyl9cmVwbGFjZUNoaWxkKHgsbSl7eC5yZW1vdmUoKTtjb25zdCBPPXRoaXNbZF0uaW5kZXhPZihtKTtpZihPPDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2lmKHRoaXNbZF1bT109eCx4LmNvbm5lY3QodGhpcyxtLnpPcmRlciksdGhpc1t2XSlpZih4LnpJbmRleCE9PW0uekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3Qgbz10aGlzW3ZdLmluZGV4T2YobSk7dGhpc1t2XVtvXT14fXJldHVybiBtLmRpc2Nvbm5lY3QodGhpcykseH1yZW1vdmVBbGxDaGlsZHJlbigpe2NvbnN0IHg9dGhpc1tkXTtmb3IobGV0IG09eC5sZW5ndGgtMTttPj0wO20tLSl4W21dLnJlbW92ZSgpfXJlbW92ZUNoaWxkKHgpe2NvbnN0IG09dGhpc1tkXS5pbmRleE9mKHgpO2lmKG0+PTApe2lmKHRoaXNbZF0uc3BsaWNlKG0sMSksdGhpc1t2XSl7Y29uc3QgTz10aGlzW3ZdLmluZGV4T2YoeCk7dGhpc1t2XS5zcGxpY2UoTywxKX1yZXR1cm4geC5kaXNjb25uZWN0KHRoaXMpLHh9cmV0dXJuIG51bGx9cmVvcmRlcigpe3RoaXNbdl09bnVsbH1zZWFsKCl7ZnVuY3Rpb24geChoLGMpe2NvbnN0IGc9W107Zm9yKGxldCBiPTA7YjxoLmxlbmd0aDtiKyspe2NvbnN0IEU9Wy4uLmhbYl1dO2ZvcihsZXQgQT0xO0E8RS5sZW5ndGg7QSs9Mil7Y29uc3QgTD1FW0FdLE09RVtBKzFdO0VbQV09TCpjWzBdK00qY1syXStjWzRdLEVbQSsxXT1MKmNbMV0rTSpjWzNdK2NbNV19Zy5wdXNoKEUpfXJldHVybiBnfWNvbnN0IG09dGhpcy5vcmRlcmVkQ2hpbGRyZW4sTz1uZXcgci5GaWd1cmUyRCxvPXRoaXMubG9jYWxNYXRyaXg7Zm9yKGxldCBoPTA7aDxtLmxlbmd0aDtoKyspe2xldCBjPW1baF07aWYoYyBpbnN0YW5jZW9mIHkmJihjPWMuc2VhbCgpKSxjLmNsaWVudEJveCl7bGV0IGc9Yy5jbGllbnRCb3guY29udG91cnMucGF0aDtnPXgoZyxjLmxvY2FsTWF0cml4KSxPLmFkZFBhdGgoZyl9aWYoYy5wYXRoKXtsZXQgZz1jLnBhdGguY29udG91cnMucGF0aDtnPXgoZyxjLmxvY2FsTWF0cml4KSxPLmFkZFBhdGgoZyl9fXJldHVybiB0aGlzW3BdPSEwLHRoaXMuY2xpZW50Qm94PU8se2NsaWVudEJveDpPLGxvY2FsTWF0cml4Om99fXNldFJlc29sdXRpb24oe3dpZHRoOngsaGVpZ2h0Om19KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDp4LGhlaWdodDptfSksdGhpc1tkXS5mb3JFYWNoKE89PntPLnNldFJlc29sdXRpb24oe3dpZHRoOngsaGVpZ2h0Om19KX0pfXVwZGF0ZUNvbnRvdXJzKCl7dGhpc1twXXx8c3VwZXIudXBkYXRlQ29udG91cnMoKX19cyh5LCJBdHRyIixpLmRlZmF1bHQpLGEuZGVmYXVsdC5yZWdpc3Rlck5vZGUoeSwiZ3JvdXAiKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciByPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgbiBleHRlbmRzIHIuZGVmYXVsdHt9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJxdWVyeVNlbGVjdG9yQWxsIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInF1ZXJ5U2VsZWN0b3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiaXNNYXRjaGVkIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImNvbXBpbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDIyMSksbj10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9dCgyNTMpO2Z1bmN0aW9uIGEobSl7cmV0dXJuIG0ubm9kZVR5cGU9PT0xfHxuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKG0ubm9kZU5hbWUpfWZ1bmN0aW9uIGwobSl7cmV0dXJuIEFycmF5LmZyb20obS5jaGlsZE5vZGVzfHxbXSl9ZnVuY3Rpb24gcyhtKXtyZXR1cm4gbi5kZWZhdWx0LmlzU3ByaXRlTm9kZShtLm5vZGVOYW1lKT9tLnBhcmVudHx8bS5jYW52YXN8fG0uY29udGFpbmVyOm0ucGFyZW50RWxlbWVudH1mdW5jdGlvbiBmKG0pe2xldCBPPW0ubGVuZ3RoLG8saCxjO2Zvcig7LS1PPi0xOyl7Zm9yKG89aD1tW09dLG1bT109bnVsbCxjPSEwO2g7KXtpZihtLmluZGV4T2YoaCk+LTEpe2M9ITEsbS5zcGxpY2UoTywxKTticmVha31oPXMoaCl9YyYmKG1bT109byl9cmV0dXJuIG19Y29uc3Qgdj17aXNUYWc6YSxleGlzdHNPbmUobSxPKXtyZXR1cm4gTy5zb21lKG89PmEobyk/bShvKXx8di5leGlzdHNPbmUobSxsKG8pKTohMSl9LGdldFNpYmxpbmdzKG0pe2NvbnN0IE89cyhtKTtyZXR1cm4gTyYmbChPKX0sZ2V0Q2hpbGRyZW46bCxnZXRQYXJlbnQ6cyxnZXRBdHRyaWJ1dGVWYWx1ZShtLE8pe2lmKG0ubm9kZVR5cGU9PT0xJiZPPT09ImNsYXNzInx8Tz09PSJpZCIpcmV0dXJuIG1bT107aWYodGhpcy5oYXNBdHRyaWIobSxPKSl7bGV0IG89bS5hdHRyaWJ1dGVzW09dO3JldHVybiBBcnJheS5pc0FycmF5KG8pJiYobz1gWyR7by5qb2luKCl9XWApLFN0cmluZyhvKX19LGhhc0F0dHJpYihtLE8pe3JldHVybiBtLmF0dHJpYnV0ZXNbT10hPW51bGx9LHJlbW92ZVN1YnNldHM6ZixnZXROYW1lKG0pe3JldHVybiBtLnRhZ05hbWU/bS50YWdOYW1lLnRvTG93ZXJDYXNlKCk6bnVsbH0sZmluZE9uZTpmdW5jdGlvbiBtKE8sbyl7bGV0IGg9bnVsbDtmb3IobGV0IGM9MCxnPW8ubGVuZ3RoO2M8ZyYmIWg7YysrKWlmKE8ob1tjXSkpaD1vW2NdO2Vsc2V7Y29uc3QgYj1sKG9bY10pO2ImJmIubGVuZ3RoPjAmJihoPW0oTyxiKSl9cmV0dXJuIGh9LGZpbmRBbGw6ZnVuY3Rpb24gbShPLG8pe2xldCBoPVtdO2ZvcihsZXQgYz0wLGc9by5sZW5ndGg7YzxnO2MrKyl7aWYoIWEob1tjXSkpY29udGludWU7TyhvW2NdKSYmaC5wdXNoKG9bY10pO2NvbnN0IGI9bChvW2NdKTtiJiYoaD1oLmNvbmNhdChtKE8sYikpKX1yZXR1cm4gaH0sZ2V0VGV4dDpmdW5jdGlvbiBtKE8pe3JldHVybiBBcnJheS5pc0FycmF5KE8pP08ubWFwKG0pLmpvaW4oIiIpOmEoTyk/bShsKE8pKTpPLm5vZGVUeXBlPT09Mz9PLm5vZGVWYWx1ZTpuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKE8ubm9kZU5hbWUpP08udGV4dDoiIn19O2Z1bmN0aW9uIGQobSl7aWYodHlwZW9mIG0hPSJzdHJpbmciKXJldHVybiBtO2xldCBPPW0ubWF0Y2goL1xbKGJnY29sb3J8ZmlsbENvbG9yfHN0cm9rZUNvbG9yfGNvbG9yKVxzKj1ccypbJyJdP1x3K1snIl0/XF0vZyk7cmV0dXJuIE8mJihPPU8ubWFwKG89Pntjb25zdCBoPW8uc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxjPU9iamVjdChyLnBhcnNlQ29sb3IpKGhbMV0ucmVwbGFjZSgvWyciXS9nLCIiKSk7cmV0dXJuW28sYFske2hbMF19PSIke2N9Il1gXX0pLE8uZm9yRWFjaCgoW28saF0pPT57bT1tLnJlcGxhY2UobyxoKX0pKSxPPW0ubWF0Y2goL1xbXHcrXHMqPVxzKlsnIl1cWy4rP1xdWyciXVxdL2cpLE8mJihPPU8ubWFwKG89Pntjb25zdCBoPW8uc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxjPWhbMV0uc2xpY2UoMiwtMikuc3BsaXQoLywvZykubWFwKGc9PmcudHJpbSgpKTtyZXR1cm5bbyxgWyR7aFswXX09Ilske2N9XSJdYF19KSxPLmZvckVhY2goKFtvLGhdKT0+e209bS5yZXBsYWNlKG8saCl9KSksbX1mdW5jdGlvbiBwKG0sTyl7cmV0dXJuIGkuc2VsZWN0QWxsKGQobSksTyx7YWRhcHRlcjp2fSl9ZnVuY3Rpb24geShtLE8pe3JldHVybiBpLnNlbGVjdE9uZShkKG0pLE8se2FkYXB0ZXI6dn0pfWZ1bmN0aW9uIFAobSxPKXtyZXR1cm4gaS5pcyhtLGQoTykse2FkYXB0ZXI6dn0pfWZ1bmN0aW9uIHgobSl7cmV0dXJuIGkuY29tcGlsZShkKG0pLHthZGFwdGVyOnZ9KX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9eDt2YXIgcj10KDI1NCksbj10KDI3MykuZmFsc2VGdW5jLGk9dCgyNzQpO2Z1bmN0aW9uIGEobSl7cmV0dXJuIGZ1bmN0aW9uKG8saCxjKXtyZXR1cm4gaD1ofHx7fSxoLmFkYXB0ZXI9aC5hZGFwdGVyfHxyLG0obyxoLGMpfX12YXIgbD1hKGkpLHM9YShpLmNvbXBpbGVVbnNhZmUpO2Z1bmN0aW9uIGYobSl7cmV0dXJuIGZ1bmN0aW9uKG8saCxjKXtyZXR1cm4gYz1jfHx7fSxjLmFkYXB0ZXI9Yy5hZGFwdGVyfHxyLHR5cGVvZiBvIT0iZnVuY3Rpb24iJiYobz1zKG8sYyxoKSksby5zaG91bGRUZXN0TmV4dFNpYmxpbmdzJiYoaD1kKGMmJmMuY29udGV4dHx8aCxjLmFkYXB0ZXIpKSxBcnJheS5pc0FycmF5KGgpP2g9Yy5hZGFwdGVyLnJlbW92ZVN1YnNldHMoaCk6aD1jLmFkYXB0ZXIuZ2V0Q2hpbGRyZW4oaCksbShvLGgsYyl9fWZ1bmN0aW9uIHYobSxPKXt2YXIgbz1PLmdldFNpYmxpbmdzKG0pO2lmKCFBcnJheS5pc0FycmF5KG8pKXJldHVybltdO2ZvcihvPW8uc2xpY2UoMCk7by5zaGlmdCgpIT09bTspO3JldHVybiBvfWZ1bmN0aW9uIGQobSxPKXtBcnJheS5pc0FycmF5KG0pfHwobT1bbV0pO2Zvcih2YXIgbz1tLnNsaWNlKDApLGg9MCxjPW0ubGVuZ3RoO2g8YztoKyspe3ZhciBnPXYob1toXSxPKTtvLnB1c2guYXBwbHkobyxnKX1yZXR1cm4gb312YXIgcD1mKGZ1bmN0aW9uKE8sbyxoKXtyZXR1cm4gTz09PW58fCFvfHxvLmxlbmd0aD09PTA/W106aC5hZGFwdGVyLmZpbmRBbGwoTyxvKX0pLHk9ZihmdW5jdGlvbihPLG8saCl7cmV0dXJuIE89PT1ufHwhb3x8by5sZW5ndGg9PT0wP251bGw6aC5hZGFwdGVyLmZpbmRPbmUoTyxvKX0pO2Z1bmN0aW9uIFAobSxPLG8pe3JldHVybiBvPW98fHt9LG8uYWRhcHRlcj1vLmFkYXB0ZXJ8fHIsKHR5cGVvZiBPPT0iZnVuY3Rpb24iP086bChPLG8pKShtKX1mdW5jdGlvbiB4KG0sTyxvKXtyZXR1cm4gcChtLE8sbyl9eC5jb21waWxlPWwseC5maWx0ZXJzPWkuUHNldWRvcy5maWx0ZXJzLHgucHNldWRvcz1pLlBzZXVkb3MucHNldWRvcyx4LnNlbGVjdEFsbD1wLHguc2VsZWN0T25lPXkseC5pcz1QLHgucGFyc2U9bCx4Lml0ZXJhdGU9cCx4Ll9jb21waWxlVW5zYWZlPXMseC5fY29tcGlsZVRva2VuPWkuY29tcGlsZVRva2VufSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dS5leHBvcnRzO1t0KDI1NSksdCgyNjgpLHQoMjY5KSx0KDI3MCksdCgyNzEpLHQoMjcyKV0uZm9yRWFjaChmdW5jdGlvbihuKXtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKGkpe3JbaV09bltpXS5iaW5kKHIpfSl9KX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMjU2KSxuPXQoMjU3KSxpPXIuaXNUYWc7dS5leHBvcnRzPXtnZXRJbm5lckhUTUw6YSxnZXRPdXRlckhUTUw6bixnZXRUZXh0Omx9O2Z1bmN0aW9uIGEocyxmKXtyZXR1cm4gcy5jaGlsZHJlbj9zLmNoaWxkcmVuLm1hcChmdW5jdGlvbih2KXtyZXR1cm4gbih2LGYpfSkuam9pbigiIik6IiJ9ZnVuY3Rpb24gbChzKXtyZXR1cm4gQXJyYXkuaXNBcnJheShzKT9zLm1hcChsKS5qb2luKCIiKTppKHMpP3MubmFtZT09PSJiciI/YApgOmwocy5jaGlsZHJlbik6cy50eXBlPT09ci5DREFUQT9sKHMuY2hpbGRyZW4pOnMudHlwZT09PXIuVGV4dD9zLmRhdGE6IiJ9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz17VGV4dDoidGV4dCIsRGlyZWN0aXZlOiJkaXJlY3RpdmUiLENvbW1lbnQ6ImNvbW1lbnQiLFNjcmlwdDoic2NyaXB0IixTdHlsZToic3R5bGUiLFRhZzoidGFnIixDREFUQToiY2RhdGEiLERvY3R5cGU6ImRvY3R5cGUiLGlzVGFnOmZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGU9PT0idGFnInx8dC50eXBlPT09InNjcmlwdCJ8fHQudHlwZT09PSJzdHlsZSJ9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMjU4KSxuPXQoMjU5KSxpPXQoMjY3KTtpLmVsZW1lbnROYW1lcy5fX3Byb3RvX189bnVsbCxpLmF0dHJpYnV0ZU5hbWVzLl9fcHJvdG9fXz1udWxsO3ZhciBhPXtfX3Byb3RvX186bnVsbCxzdHlsZTohMCxzY3JpcHQ6ITAseG1wOiEwLGlmcmFtZTohMCxub2VtYmVkOiEwLG5vZnJhbWVzOiEwLHBsYWludGV4dDohMCxub3NjcmlwdDohMH07ZnVuY3Rpb24gbChtLE8pe2lmKG0pe3ZhciBvPSIiLGg7Zm9yKHZhciBjIGluIG0paD1tW2NdLG8mJihvKz0iICIpLE8ueG1sTW9kZT09PSJmb3JlaWduIiYmKGM9aS5hdHRyaWJ1dGVOYW1lc1tjXXx8Yyksbys9YywoaCE9PW51bGwmJmghPT0iInx8Ty54bWxNb2RlKSYmKG8rPSc9IicrKE8uZGVjb2RlRW50aXRpZXM/bi5lbmNvZGVYTUwoaCk6aC5yZXBsYWNlKC9cIi9nLCImcXVvdDsiKSkrJyInKTtyZXR1cm4gb319dmFyIHM9e19fcHJvdG9fXzpudWxsLGFyZWE6ITAsYmFzZTohMCxiYXNlZm9udDohMCxicjohMCxjb2w6ITAsY29tbWFuZDohMCxlbWJlZDohMCxmcmFtZTohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsaXNpbmRleDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9LGY9dS5leHBvcnRzPWZ1bmN0aW9uKG0sTyl7IUFycmF5LmlzQXJyYXkobSkmJiFtLmNoZWVyaW8mJihtPVttXSksTz1PfHx7fTtmb3IodmFyIG89IiIsaD0wO2g8bS5sZW5ndGg7aCsrKXt2YXIgYz1tW2hdO2MudHlwZT09PSJyb290Ij9vKz1mKGMuY2hpbGRyZW4sTyk6ci5pc1RhZyhjKT9vKz1kKGMsTyk6Yy50eXBlPT09ci5EaXJlY3RpdmU/bys9cChjKTpjLnR5cGU9PT1yLkNvbW1lbnQ/bys9eChjKTpjLnR5cGU9PT1yLkNEQVRBP28rPVAoYyk6bys9eShjLE8pfXJldHVybiBvfSx2PVsibWkiLCJtbyIsIm1uIiwibXMiLCJtdGV4dCIsImFubm90YXRpb24teG1sIiwiZm9yZWlnbk9iamVjdCIsImRlc2MiLCJ0aXRsZSJdO2Z1bmN0aW9uIGQobSxPKXtPLnhtbE1vZGU9PT0iZm9yZWlnbiImJihtLm5hbWU9aS5lbGVtZW50TmFtZXNbbS5uYW1lXXx8bS5uYW1lLG0ucGFyZW50JiZ2LmluZGV4T2YobS5wYXJlbnQubmFtZSk+PTAmJihPPU9iamVjdC5hc3NpZ24oe30sTyx7eG1sTW9kZTohMX0pKSksIU8ueG1sTW9kZSYmWyJzdmciLCJtYXRoIl0uaW5kZXhPZihtLm5hbWUpPj0wJiYoTz1PYmplY3QuYXNzaWduKHt9LE8se3htbE1vZGU6ImZvcmVpZ24ifSkpO3ZhciBvPSI8IittLm5hbWUsaD1sKG0uYXR0cmlicyxPKTtyZXR1cm4gaCYmKG8rPSIgIitoKSxPLnhtbE1vZGUmJighbS5jaGlsZHJlbnx8bS5jaGlsZHJlbi5sZW5ndGg9PT0wKT9vKz0iLz4iOihvKz0iPiIsbS5jaGlsZHJlbiYmKG8rPWYobS5jaGlsZHJlbixPKSksKCFzW20ubmFtZV18fE8ueG1sTW9kZSkmJihvKz0iPC8iK20ubmFtZSsiPiIpKSxvfWZ1bmN0aW9uIHAobSl7cmV0dXJuIjwiK20uZGF0YSsiPiJ9ZnVuY3Rpb24geShtLE8pe3ZhciBvPW0uZGF0YXx8IiI7cmV0dXJuIE8uZGVjb2RlRW50aXRpZXMmJiEobS5wYXJlbnQmJm0ucGFyZW50Lm5hbWUgaW4gYSkmJihvPW4uZW5jb2RlWE1MKG8pKSxvfWZ1bmN0aW9uIFAobSl7cmV0dXJuIjwhW0NEQVRBWyIrbS5jaGlsZHJlblswXS5kYXRhKyJdXT4ifWZ1bmN0aW9uIHgobSl7cmV0dXJuIjwhLS0iK20uZGF0YSsiLS0+In19LGZ1bmN0aW9uKHUsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gcihuKXtyZXR1cm4gbi50eXBlPT09InRhZyJ8fG4udHlwZT09PSJzY3JpcHQifHxuLnR5cGU9PT0ic3R5bGUifWUuaXNUYWc9cixlLlRleHQ9InRleHQiLGUuRGlyZWN0aXZlPSJkaXJlY3RpdmUiLGUuQ29tbWVudD0iY29tbWVudCIsZS5TY3JpcHQ9InNjcmlwdCIsZS5TdHlsZT0ic3R5bGUiLGUuVGFnPSJ0YWciLGUuQ0RBVEE9ImNkYXRhIixlLkRvY3R5cGU9ImRvY3R5cGUifSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZW5jb2RlPWUuZGVjb2RlU3RyaWN0PWUuZGVjb2RlPXZvaWQgMDt2YXIgcj10KDI2MCksbj10KDI2Nik7ZnVuY3Rpb24gaSh2LGQpe3JldHVybighZHx8ZDw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUwpKHYpfWUuZGVjb2RlPWk7ZnVuY3Rpb24gYSh2LGQpe3JldHVybighZHx8ZDw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUxTdHJpY3QpKHYpfWUuZGVjb2RlU3RyaWN0PWE7ZnVuY3Rpb24gbCh2LGQpe3JldHVybighZHx8ZDw9MD9uLmVuY29kZVhNTDpuLmVuY29kZUhUTUwpKHYpfWUuZW5jb2RlPWw7dmFyIHM9dCgyNjYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmVuY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZXNjYXBlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5lc2NhcGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuZW5jb2RlSFRNTH19KTt2YXIgZj10KDI2MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNVN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVYTUx9fSl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZCl7cmV0dXJuIGQmJmQuX19lc01vZHVsZT9kOntkZWZhdWx0OmR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWNvZGVIVE1MPWUuZGVjb2RlSFRNTFN0cmljdD1lLmRlY29kZVhNTD12b2lkIDA7dmFyIG49cih0KDI2MSkpLGk9cih0KDI2MikpLGE9cih0KDI2MykpLGw9cih0KDI2NCkpO2UuZGVjb2RlWE1MPXMoYS5kZWZhdWx0KSxlLmRlY29kZUhUTUxTdHJpY3Q9cyhuLmRlZmF1bHQpO2Z1bmN0aW9uIHMoZCl7dmFyIHA9T2JqZWN0LmtleXMoZCkuam9pbigifCIpLHk9dihkKTtwKz0ifCNbeFhdW1xcZGEtZkEtRl0rfCNcXGQrIjt2YXIgUD1uZXcgUmVnRXhwKCImKD86IitwKyIpOyIsImciKTtyZXR1cm4gZnVuY3Rpb24oeCl7cmV0dXJuIFN0cmluZyh4KS5yZXBsYWNlKFAseSl9fXZhciBmPWZ1bmN0aW9uKGQscCl7cmV0dXJuIGQ8cD8xOi0xfTtlLmRlY29kZUhUTUw9ZnVuY3Rpb24oKXtmb3IodmFyIGQ9T2JqZWN0LmtleXMoaS5kZWZhdWx0KS5zb3J0KGYpLHA9T2JqZWN0LmtleXMobi5kZWZhdWx0KS5zb3J0KGYpLHk9MCxQPTA7eTxwLmxlbmd0aDt5KyspZFtQXT09PXBbeV0/KHBbeV0rPSI7PyIsUCsrKTpwW3ldKz0iOyI7dmFyIHg9bmV3IFJlZ0V4cCgiJig/OiIrcC5qb2luKCJ8IikrInwjW3hYXVtcXGRhLWZBLUZdKzs/fCNcXGQrOz8pIiwiZyIpLG09dihuLmRlZmF1bHQpO2Z1bmN0aW9uIE8obyl7cmV0dXJuIG8uc3Vic3RyKC0xKSE9PSI7IiYmKG8rPSI7IiksbShvKX1yZXR1cm4gZnVuY3Rpb24obyl7cmV0dXJuIFN0cmluZyhvKS5yZXBsYWNlKHgsTyl9fSgpO2Z1bmN0aW9uIHYoZCl7cmV0dXJuIGZ1bmN0aW9uKHkpe2lmKHkuY2hhckF0KDEpPT09IiMiKXt2YXIgUD15LmNoYXJBdCgyKTtyZXR1cm4gUD09PSJYInx8UD09PSJ4Ij9sLmRlZmF1bHQocGFyc2VJbnQoeS5zdWJzdHIoMyksMTYpKTpsLmRlZmF1bHQocGFyc2VJbnQoeS5zdWJzdHIoMiksMTApKX1yZXR1cm4gZFt5LnNsaWNlKDEsLTEpXX19fSxmdW5jdGlvbih1KXt1LmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWJyZXZlIjoixIIiLCJhYnJldmUiOiLEgyIsImFjIjoi4oi+IiwiYWNkIjoi4oi/IiwiYWNFIjoi4oi+zLMiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBY3kiOiLQkCIsImFjeSI6ItCwIiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJhZiI6IuKBoSIsIkFmciI6IvCdlIQiLCJhZnIiOiLwnZSeIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFsZWZzeW0iOiLihLUiLCJhbGVwaCI6IuKEtSIsIkFscGhhIjoizpEiLCJhbHBoYSI6Is6xIiwiQW1hY3IiOiLEgCIsImFtYWNyIjoixIEiLCJhbWFsZyI6IuKovyIsImFtcCI6IiYiLCJBTVAiOiImIiwiYW5kYW5kIjoi4qmVIiwiQW5kIjoi4qmTIiwiYW5kIjoi4oinIiwiYW5kZCI6IuKpnCIsImFuZHNsb3BlIjoi4qmYIiwiYW5kdiI6IuKpmiIsImFuZyI6IuKIoCIsImFuZ2UiOiLipqQiLCJhbmdsZSI6IuKIoCIsImFuZ21zZGFhIjoi4qaoIiwiYW5nbXNkYWIiOiLipqkiLCJhbmdtc2RhYyI6IuKmqiIsImFuZ21zZGFkIjoi4qarIiwiYW5nbXNkYWUiOiLipqwiLCJhbmdtc2RhZiI6IuKmrSIsImFuZ21zZGFnIjoi4qauIiwiYW5nbXNkYWgiOiLipq8iLCJhbmdtc2QiOiLiiKEiLCJhbmdydCI6IuKInyIsImFuZ3J0dmIiOiLiir4iLCJhbmdydHZiZCI6IuKmnSIsImFuZ3NwaCI6IuKIoiIsImFuZ3N0Ijoiw4UiLCJhbmd6YXJyIjoi4o28IiwiQW9nb24iOiLEhCIsImFvZ29uIjoixIUiLCJBb3BmIjoi8J2UuCIsImFvcGYiOiLwnZWSIiwiYXBhY2lyIjoi4qmvIiwiYXAiOiLiiYgiLCJhcEUiOiLiqbAiLCJhcGUiOiLiiYoiLCJhcGlkIjoi4omLIiwiYXBvcyI6IlwnIiwiQXBwbHlGdW5jdGlvbiI6IuKBoSIsImFwcHJveCI6IuKJiCIsImFwcHJveGVxIjoi4omKIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBc2NyIjoi8J2SnCIsImFzY3IiOiLwnZK2IiwiQXNzaWduIjoi4omUIiwiYXN0IjoiKiIsImFzeW1wIjoi4omIIiwiYXN5bXBlcSI6IuKJjSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJhd2NvbmludCI6IuKIsyIsImF3aW50Ijoi4qiRIiwiYmFja2NvbmciOiLiiYwiLCJiYWNrZXBzaWxvbiI6Is+2IiwiYmFja3ByaW1lIjoi4oC1IiwiYmFja3NpbSI6IuKIvSIsImJhY2tzaW1lcSI6IuKLjSIsIkJhY2tzbGFzaCI6IuKIliIsIkJhcnYiOiLiq6ciLCJiYXJ2ZWUiOiLiir0iLCJiYXJ3ZWQiOiLijIUiLCJCYXJ3ZWQiOiLijIYiLCJiYXJ3ZWRnZSI6IuKMhSIsImJicmsiOiLijrUiLCJiYnJrdGJyayI6IuKOtiIsImJjb25nIjoi4omMIiwiQmN5Ijoi0JEiLCJiY3kiOiLQsSIsImJkcXVvIjoi4oCeIiwiYmVjYXVzIjoi4oi1IiwiYmVjYXVzZSI6IuKItSIsIkJlY2F1c2UiOiLiiLUiLCJiZW1wdHl2Ijoi4qawIiwiYmVwc2kiOiLPtiIsImJlcm5vdSI6IuKErCIsIkJlcm5vdWxsaXMiOiLihKwiLCJCZXRhIjoizpIiLCJiZXRhIjoizrIiLCJiZXRoIjoi4oS2IiwiYmV0d2VlbiI6IuKJrCIsIkJmciI6IvCdlIUiLCJiZnIiOiLwnZSfIiwiYmlnY2FwIjoi4ouCIiwiYmlnY2lyYyI6IuKXryIsImJpZ2N1cCI6IuKLgyIsImJpZ29kb3QiOiLiqIAiLCJiaWdvcGx1cyI6IuKogSIsImJpZ290aW1lcyI6IuKogiIsImJpZ3NxY3VwIjoi4qiGIiwiYmlnc3RhciI6IuKYhSIsImJpZ3RyaWFuZ2xlZG93biI6IuKWvSIsImJpZ3RyaWFuZ2xldXAiOiLilrMiLCJiaWd1cGx1cyI6IuKohCIsImJpZ3ZlZSI6IuKLgSIsImJpZ3dlZGdlIjoi4ouAIiwiYmthcm93Ijoi4qSNIiwiYmxhY2tsb3plbmdlIjoi4qerIiwiYmxhY2tzcXVhcmUiOiLilqoiLCJibGFja3RyaWFuZ2xlIjoi4pa0IiwiYmxhY2t0cmlhbmdsZWRvd24iOiLilr4iLCJibGFja3RyaWFuZ2xlbGVmdCI6IuKXgiIsImJsYWNrdHJpYW5nbGVyaWdodCI6IuKWuCIsImJsYW5rIjoi4pCjIiwiYmxrMTIiOiLilpIiLCJibGsxNCI6IuKWkSIsImJsazM0Ijoi4paTIiwiYmxvY2siOiLilogiLCJibmUiOiI94oOlIiwiYm5lcXVpdiI6IuKJoeKDpSIsImJOb3QiOiLiq60iLCJibm90Ijoi4oyQIiwiQm9wZiI6IvCdlLkiLCJib3BmIjoi8J2VkyIsImJvdCI6IuKKpSIsImJvdHRvbSI6IuKKpSIsImJvd3RpZSI6IuKLiCIsImJveGJveCI6IuKniSIsImJveGRsIjoi4pSQIiwiYm94ZEwiOiLilZUiLCJib3hEbCI6IuKVliIsImJveERMIjoi4pWXIiwiYm94ZHIiOiLilIwiLCJib3hkUiI6IuKVkiIsImJveERyIjoi4pWTIiwiYm94RFIiOiLilZQiLCJib3hoIjoi4pSAIiwiYm94SCI6IuKVkCIsImJveGhkIjoi4pSsIiwiYm94SGQiOiLilaQiLCJib3hoRCI6IuKVpSIsImJveEhEIjoi4pWmIiwiYm94aHUiOiLilLQiLCJib3hIdSI6IuKVpyIsImJveGhVIjoi4pWoIiwiYm94SFUiOiLilakiLCJib3htaW51cyI6IuKKnyIsImJveHBsdXMiOiLiip4iLCJib3h0aW1lcyI6IuKKoCIsImJveHVsIjoi4pSYIiwiYm94dUwiOiLilZsiLCJib3hVbCI6IuKVnCIsImJveFVMIjoi4pWdIiwiYm94dXIiOiLilJQiLCJib3h1UiI6IuKVmCIsImJveFVyIjoi4pWZIiwiYm94VVIiOiLilZoiLCJib3h2Ijoi4pSCIiwiYm94ViI6IuKVkSIsImJveHZoIjoi4pS8IiwiYm94dkgiOiLilaoiLCJib3hWaCI6IuKVqyIsImJveFZIIjoi4pWsIiwiYm94dmwiOiLilKQiLCJib3h2TCI6IuKVoSIsImJveFZsIjoi4pWiIiwiYm94VkwiOiLilaMiLCJib3h2ciI6IuKUnCIsImJveHZSIjoi4pWeIiwiYm94VnIiOiLilZ8iLCJib3hWUiI6IuKVoCIsImJwcmltZSI6IuKAtSIsImJyZXZlIjoiy5giLCJCcmV2ZSI6IsuYIiwiYnJ2YmFyIjoiwqYiLCJic2NyIjoi8J2StyIsIkJzY3IiOiLihKwiLCJic2VtaSI6IuKBjyIsImJzaW0iOiLiiL0iLCJic2ltZSI6IuKLjSIsImJzb2xiIjoi4qeFIiwiYnNvbCI6IlxcXFwiLCJic29saHN1YiI6IuKfiCIsImJ1bGwiOiLigKIiLCJidWxsZXQiOiLigKIiLCJidW1wIjoi4omOIiwiYnVtcEUiOiLiqq4iLCJidW1wZSI6IuKJjyIsIkJ1bXBlcSI6IuKJjiIsImJ1bXBlcSI6IuKJjyIsIkNhY3V0ZSI6IsSGIiwiY2FjdXRlIjoixIciLCJjYXBhbmQiOiLiqYQiLCJjYXBicmN1cCI6IuKpiSIsImNhcGNhcCI6IuKpiyIsImNhcCI6IuKIqSIsIkNhcCI6IuKLkiIsImNhcGN1cCI6IuKphyIsImNhcGRvdCI6IuKpgCIsIkNhcGl0YWxEaWZmZXJlbnRpYWxEIjoi4oWFIiwiY2FwcyI6IuKIqe+4gCIsImNhcmV0Ijoi4oGBIiwiY2Fyb24iOiLLhyIsIkNheWxleXMiOiLihK0iLCJjY2FwcyI6IuKpjSIsIkNjYXJvbiI6IsSMIiwiY2Nhcm9uIjoixI0iLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiQ2NpcmMiOiLEiCIsImNjaXJjIjoixIkiLCJDY29uaW50Ijoi4oiwIiwiY2N1cHMiOiLiqYwiLCJjY3Vwc3NtIjoi4qmQIiwiQ2RvdCI6IsSKIiwiY2RvdCI6IsSLIiwiY2VkaWwiOiLCuCIsIkNlZGlsbGEiOiLCuCIsImNlbXB0eXYiOiLiprIiLCJjZW50IjoiwqIiLCJjZW50ZXJkb3QiOiLCtyIsIkNlbnRlckRvdCI6IsK3IiwiY2ZyIjoi8J2UoCIsIkNmciI6IuKErSIsIkNIY3kiOiLQpyIsImNoY3kiOiLRhyIsImNoZWNrIjoi4pyTIiwiY2hlY2ttYXJrIjoi4pyTIiwiQ2hpIjoizqciLCJjaGkiOiLPhyIsImNpcmMiOiLLhiIsImNpcmNlcSI6IuKJlyIsImNpcmNsZWFycm93bGVmdCI6IuKGuiIsImNpcmNsZWFycm93cmlnaHQiOiLihrsiLCJjaXJjbGVkYXN0Ijoi4oqbIiwiY2lyY2xlZGNpcmMiOiLiipoiLCJjaXJjbGVkZGFzaCI6IuKKnSIsIkNpcmNsZURvdCI6IuKKmSIsImNpcmNsZWRSIjoiwq4iLCJjaXJjbGVkUyI6IuKTiCIsIkNpcmNsZU1pbnVzIjoi4oqWIiwiQ2lyY2xlUGx1cyI6IuKKlSIsIkNpcmNsZVRpbWVzIjoi4oqXIiwiY2lyIjoi4peLIiwiY2lyRSI6IuKngyIsImNpcmUiOiLiiZciLCJjaXJmbmludCI6IuKokCIsImNpcm1pZCI6IuKrryIsImNpcnNjaXIiOiLip4IiLCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLIiLCJDbG9zZUN1cmx5RG91YmxlUXVvdGUiOiLigJ0iLCJDbG9zZUN1cmx5UXVvdGUiOiLigJkiLCJjbHVicyI6IuKZoyIsImNsdWJzdWl0Ijoi4pmjIiwiY29sb24iOiI6IiwiQ29sb24iOiLiiLciLCJDb2xvbmUiOiLiqbQiLCJjb2xvbmUiOiLiiZQiLCJjb2xvbmVxIjoi4omUIiwiY29tbWEiOiIsIiwiY29tbWF0IjoiQCIsImNvbXAiOiLiiIEiLCJjb21wZm4iOiLiiJgiLCJjb21wbGVtZW50Ijoi4oiBIiwiY29tcGxleGVzIjoi4oSCIiwiY29uZyI6IuKJhSIsImNvbmdkb3QiOiLiqa0iLCJDb25ncnVlbnQiOiLiiaEiLCJjb25pbnQiOiLiiK4iLCJDb25pbnQiOiLiiK8iLCJDb250b3VySW50ZWdyYWwiOiLiiK4iLCJjb3BmIjoi8J2VlCIsIkNvcGYiOiLihIIiLCJjb3Byb2QiOiLiiJAiLCJDb3Byb2R1Y3QiOiLiiJAiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjb3B5c3IiOiLihJciLCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oizIiwiY3JhcnIiOiLihrUiLCJjcm9zcyI6IuKclyIsIkNyb3NzIjoi4qivIiwiQ3NjciI6IvCdkp4iLCJjc2NyIjoi8J2SuCIsImNzdWIiOiLiq48iLCJjc3ViZSI6IuKrkSIsImNzdXAiOiLiq5AiLCJjc3VwZSI6IuKrkiIsImN0ZG90Ijoi4ouvIiwiY3VkYXJybCI6IuKkuCIsImN1ZGFycnIiOiLipLUiLCJjdWVwciI6IuKLniIsImN1ZXNjIjoi4oufIiwiY3VsYXJyIjoi4oa2IiwiY3VsYXJycCI6IuKkvSIsImN1cGJyY2FwIjoi4qmIIiwiY3VwY2FwIjoi4qmGIiwiQ3VwQ2FwIjoi4omNIiwiY3VwIjoi4oiqIiwiQ3VwIjoi4ouTIiwiY3VwY3VwIjoi4qmKIiwiY3VwZG90Ijoi4oqNIiwiY3Vwb3IiOiLiqYUiLCJjdXBzIjoi4oiq77iAIiwiY3VyYXJyIjoi4oa3IiwiY3VyYXJybSI6IuKkvCIsImN1cmx5ZXFwcmVjIjoi4oueIiwiY3VybHllcXN1Y2MiOiLii58iLCJjdXJseXZlZSI6IuKLjiIsImN1cmx5d2VkZ2UiOiLii48iLCJjdXJyZW4iOiLCpCIsImN1cnZlYXJyb3dsZWZ0Ijoi4oa2IiwiY3VydmVhcnJvd3JpZ2h0Ijoi4oa3IiwiY3V2ZWUiOiLii44iLCJjdXdlZCI6IuKLjyIsImN3Y29uaW50Ijoi4oiyIiwiY3dpbnQiOiLiiLEiLCJjeWxjdHkiOiLijK0iLCJkYWdnZXIiOiLigKAiLCJEYWdnZXIiOiLigKEiLCJkYWxldGgiOiLihLgiLCJkYXJyIjoi4oaTIiwiRGFyciI6IuKGoSIsImRBcnIiOiLih5MiLCJkYXNoIjoi4oCQIiwiRGFzaHYiOiLiq6QiLCJkYXNodiI6IuKKoyIsImRia2Fyb3ciOiLipI8iLCJkYmxhYyI6IsudIiwiRGNhcm9uIjoixI4iLCJkY2Fyb24iOiLEjyIsIkRjeSI6ItCUIiwiZGN5Ijoi0LQiLCJkZGFnZ2VyIjoi4oChIiwiZGRhcnIiOiLih4oiLCJERCI6IuKFhSIsImRkIjoi4oWGIiwiRERvdHJhaGQiOiLipJEiLCJkZG90c2VxIjoi4qm3IiwiZGVnIjoiwrAiLCJEZWwiOiLiiIciLCJEZWx0YSI6Is6UIiwiZGVsdGEiOiLOtCIsImRlbXB0eXYiOiLiprEiLCJkZmlzaHQiOiLipb8iLCJEZnIiOiLwnZSHIiwiZGZyIjoi8J2UoSIsImRIYXIiOiLipaUiLCJkaGFybCI6IuKHgyIsImRoYXJyIjoi4oeCIiwiRGlhY3JpdGljYWxBY3V0ZSI6IsK0IiwiRGlhY3JpdGljYWxEb3QiOiLLmSIsIkRpYWNyaXRpY2FsRG91YmxlQWN1dGUiOiLLnSIsIkRpYWNyaXRpY2FsR3JhdmUiOiJgIiwiRGlhY3JpdGljYWxUaWxkZSI6IsucIiwiZGlhbSI6IuKLhCIsImRpYW1vbmQiOiLii4QiLCJEaWFtb25kIjoi4ouEIiwiZGlhbW9uZHN1aXQiOiLimaYiLCJkaWFtcyI6IuKZpiIsImRpZSI6IsKoIiwiRGlmZmVyZW50aWFsRCI6IuKFhiIsImRpZ2FtbWEiOiLPnSIsImRpc2luIjoi4ouyIiwiZGl2Ijoiw7ciLCJkaXZpZGUiOiLDtyIsImRpdmlkZW9udGltZXMiOiLii4ciLCJkaXZvbngiOiLii4ciLCJESmN5Ijoi0IIiLCJkamN5Ijoi0ZIiLCJkbGNvcm4iOiLijJ4iLCJkbGNyb3AiOiLijI0iLCJkb2xsYXIiOiIkIiwiRG9wZiI6IvCdlLsiLCJkb3BmIjoi8J2VlSIsIkRvdCI6IsKoIiwiZG90Ijoiy5kiLCJEb3REb3QiOiLig5wiLCJkb3RlcSI6IuKJkCIsImRvdGVxZG90Ijoi4omRIiwiRG90RXF1YWwiOiLiiZAiLCJkb3RtaW51cyI6IuKIuCIsImRvdHBsdXMiOiLiiJQiLCJkb3RzcXVhcmUiOiLiiqEiLCJkb3VibGViYXJ3ZWRnZSI6IuKMhiIsIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbCI6IuKIryIsIkRvdWJsZURvdCI6IsKoIiwiRG91YmxlRG93bkFycm93Ijoi4oeTIiwiRG91YmxlTGVmdEFycm93Ijoi4oeQIiwiRG91YmxlTGVmdFJpZ2h0QXJyb3ciOiLih5QiLCJEb3VibGVMZWZ0VGVlIjoi4qukIiwiRG91YmxlTG9uZ0xlZnRBcnJvdyI6IuKfuCIsIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKfuiIsIkRvdWJsZUxvbmdSaWdodEFycm93Ijoi4p+5IiwiRG91YmxlUmlnaHRBcnJvdyI6IuKHkiIsIkRvdWJsZVJpZ2h0VGVlIjoi4oqoIiwiRG91YmxlVXBBcnJvdyI6IuKHkSIsIkRvdWJsZVVwRG93bkFycm93Ijoi4oeVIiwiRG91YmxlVmVydGljYWxCYXIiOiLiiKUiLCJEb3duQXJyb3dCYXIiOiLipJMiLCJkb3duYXJyb3ciOiLihpMiLCJEb3duQXJyb3ciOiLihpMiLCJEb3duYXJyb3ciOiLih5MiLCJEb3duQXJyb3dVcEFycm93Ijoi4oe1IiwiRG93bkJyZXZlIjoizJEiLCJkb3duZG93bmFycm93cyI6IuKHiiIsImRvd25oYXJwb29ubGVmdCI6IuKHgyIsImRvd25oYXJwb29ucmlnaHQiOiLih4IiLCJEb3duTGVmdFJpZ2h0VmVjdG9yIjoi4qWQIiwiRG93bkxlZnRUZWVWZWN0b3IiOiLipZ4iLCJEb3duTGVmdFZlY3RvckJhciI6IuKlliIsIkRvd25MZWZ0VmVjdG9yIjoi4oa9IiwiRG93blJpZ2h0VGVlVmVjdG9yIjoi4qWfIiwiRG93blJpZ2h0VmVjdG9yQmFyIjoi4qWXIiwiRG93blJpZ2h0VmVjdG9yIjoi4oeBIiwiRG93blRlZUFycm93Ijoi4oanIiwiRG93blRlZSI6IuKKpCIsImRyYmthcm93Ijoi4qSQIiwiZHJjb3JuIjoi4oyfIiwiZHJjcm9wIjoi4oyMIiwiRHNjciI6IvCdkp8iLCJkc2NyIjoi8J2SuSIsIkRTY3kiOiLQhSIsImRzY3kiOiLRlSIsImRzb2wiOiLip7YiLCJEc3Ryb2siOiLEkCIsImRzdHJvayI6IsSRIiwiZHRkb3QiOiLii7EiLCJkdHJpIjoi4pa/IiwiZHRyaWYiOiLilr4iLCJkdWFyciI6IuKHtSIsImR1aGFyIjoi4qWvIiwiZHdhbmdsZSI6IuKmpiIsIkRaY3kiOiLQjyIsImR6Y3kiOiLRnyIsImR6aWdyYXJyIjoi4p+/IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsImVhc3RlciI6IuKpriIsIkVjYXJvbiI6IsSaIiwiZWNhcm9uIjoixJsiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsImVjaXIiOiLiiZYiLCJlY29sb24iOiLiiZUiLCJFY3kiOiLQrSIsImVjeSI6ItGNIiwiZUREb3QiOiLiqbciLCJFZG90IjoixJYiLCJlZG90IjoixJciLCJlRG90Ijoi4omRIiwiZWUiOiLihYciLCJlZkRvdCI6IuKJkiIsIkVmciI6IvCdlIgiLCJlZnIiOiLwnZSiIiwiZWciOiLiqpoiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiZWdzIjoi4qqWIiwiZWdzZG90Ijoi4qqYIiwiZWwiOiLiqpkiLCJFbGVtZW50Ijoi4oiIIiwiZWxpbnRlcnMiOiLij6ciLCJlbGwiOiLihJMiLCJlbHMiOiLiqpUiLCJlbHNkb3QiOiLiqpciLCJFbWFjciI6IsSSIiwiZW1hY3IiOiLEkyIsImVtcHR5Ijoi4oiFIiwiZW1wdHlzZXQiOiLiiIUiLCJFbXB0eVNtYWxsU3F1YXJlIjoi4pe7IiwiZW1wdHl2Ijoi4oiFIiwiRW1wdHlWZXJ5U21hbGxTcXVhcmUiOiLilqsiLCJlbXNwMTMiOiLigIQiLCJlbXNwMTQiOiLigIUiLCJlbXNwIjoi4oCDIiwiRU5HIjoixYoiLCJlbmciOiLFiyIsImVuc3AiOiLigIIiLCJFb2dvbiI6IsSYIiwiZW9nb24iOiLEmSIsIkVvcGYiOiLwnZS8IiwiZW9wZiI6IvCdlZYiLCJlcGFyIjoi4ouVIiwiZXBhcnNsIjoi4qejIiwiZXBsdXMiOiLiqbEiLCJlcHNpIjoizrUiLCJFcHNpbG9uIjoizpUiLCJlcHNpbG9uIjoizrUiLCJlcHNpdiI6Is+1IiwiZXFjaXJjIjoi4omWIiwiZXFjb2xvbiI6IuKJlSIsImVxc2ltIjoi4omCIiwiZXFzbGFudGd0ciI6IuKqliIsImVxc2xhbnRsZXNzIjoi4qqVIiwiRXF1YWwiOiLiqbUiLCJlcXVhbHMiOiI9IiwiRXF1YWxUaWxkZSI6IuKJgiIsImVxdWVzdCI6IuKJnyIsIkVxdWlsaWJyaXVtIjoi4oeMIiwiZXF1aXYiOiLiiaEiLCJlcXVpdkREIjoi4qm4IiwiZXF2cGFyc2wiOiLip6UiLCJlcmFyciI6IuKlsSIsImVyRG90Ijoi4omTIiwiZXNjciI6IuKEryIsIkVzY3IiOiLihLAiLCJlc2RvdCI6IuKJkCIsIkVzaW0iOiLiqbMiLCJlc2ltIjoi4omCIiwiRXRhIjoizpciLCJldGEiOiLOtyIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJldXJvIjoi4oKsIiwiZXhjbCI6IiEiLCJleGlzdCI6IuKIgyIsIkV4aXN0cyI6IuKIgyIsImV4cGVjdGF0aW9uIjoi4oSwIiwiZXhwb25lbnRpYWxlIjoi4oWHIiwiRXhwb25lbnRpYWxFIjoi4oWHIiwiZmFsbGluZ2RvdHNlcSI6IuKJkiIsIkZjeSI6ItCkIiwiZmN5Ijoi0YQiLCJmZW1hbGUiOiLimYAiLCJmZmlsaWciOiLvrIMiLCJmZmxpZyI6Iu+sgCIsImZmbGxpZyI6Iu+shCIsIkZmciI6IvCdlIkiLCJmZnIiOiLwnZSjIiwiZmlsaWciOiLvrIEiLCJGaWxsZWRTbWFsbFNxdWFyZSI6IuKXvCIsIkZpbGxlZFZlcnlTbWFsbFNxdWFyZSI6IuKWqiIsImZqbGlnIjoiZmoiLCJmbGF0Ijoi4pmtIiwiZmxsaWciOiLvrIIiLCJmbHRucyI6IuKWsSIsImZub2YiOiLGkiIsIkZvcGYiOiLwnZS9IiwiZm9wZiI6IvCdlZciLCJmb3JhbGwiOiLiiIAiLCJGb3JBbGwiOiLiiIAiLCJmb3JrIjoi4ouUIiwiZm9ya3YiOiLiq5kiLCJGb3VyaWVydHJmIjoi4oSxIiwiZnBhcnRpbnQiOiLiqI0iLCJmcmFjMTIiOiLCvSIsImZyYWMxMyI6IuKFkyIsImZyYWMxNCI6IsK8IiwiZnJhYzE1Ijoi4oWVIiwiZnJhYzE2Ijoi4oWZIiwiZnJhYzE4Ijoi4oWbIiwiZnJhYzIzIjoi4oWUIiwiZnJhYzI1Ijoi4oWWIiwiZnJhYzM0Ijoiwr4iLCJmcmFjMzUiOiLihZciLCJmcmFjMzgiOiLihZwiLCJmcmFjNDUiOiLihZgiLCJmcmFjNTYiOiLihZoiLCJmcmFjNTgiOiLihZ0iLCJmcmFjNzgiOiLihZ4iLCJmcmFzbCI6IuKBhCIsImZyb3duIjoi4oyiIiwiZnNjciI6IvCdkrsiLCJGc2NyIjoi4oSxIiwiZ2FjdXRlIjoix7UiLCJHYW1tYSI6Is6TIiwiZ2FtbWEiOiLOsyIsIkdhbW1hZCI6Is+cIiwiZ2FtbWFkIjoiz50iLCJnYXAiOiLiqoYiLCJHYnJldmUiOiLEniIsImdicmV2ZSI6IsSfIiwiR2NlZGlsIjoixKIiLCJHY2lyYyI6IsScIiwiZ2NpcmMiOiLEnSIsIkdjeSI6ItCTIiwiZ2N5Ijoi0LMiLCJHZG90IjoixKAiLCJnZG90IjoixKEiLCJnZSI6IuKJpSIsImdFIjoi4omnIiwiZ0VsIjoi4qqMIiwiZ2VsIjoi4oubIiwiZ2VxIjoi4omlIiwiZ2VxcSI6IuKJpyIsImdlcXNsYW50Ijoi4qm+IiwiZ2VzY2MiOiLiqqkiLCJnZXMiOiLiqb4iLCJnZXNkb3QiOiLiqoAiLCJnZXNkb3RvIjoi4qqCIiwiZ2VzZG90b2wiOiLiqoQiLCJnZXNsIjoi4oub77iAIiwiZ2VzbGVzIjoi4qqUIiwiR2ZyIjoi8J2UiiIsImdmciI6IvCdlKQiLCJnZyI6IuKJqyIsIkdnIjoi4ouZIiwiZ2dnIjoi4ouZIiwiZ2ltZWwiOiLihLciLCJHSmN5Ijoi0IMiLCJnamN5Ijoi0ZMiLCJnbGEiOiLiqqUiLCJnbCI6IuKJtyIsImdsRSI6IuKqkiIsImdsaiI6IuKqpCIsImduYXAiOiLiqooiLCJnbmFwcHJveCI6IuKqiiIsImduZSI6IuKqiCIsImduRSI6IuKJqSIsImduZXEiOiLiqogiLCJnbmVxcSI6IuKJqSIsImduc2ltIjoi4ounIiwiR29wZiI6IvCdlL4iLCJnb3BmIjoi8J2VmCIsImdyYXZlIjoiYCIsIkdyZWF0ZXJFcXVhbCI6IuKJpSIsIkdyZWF0ZXJFcXVhbExlc3MiOiLii5siLCJHcmVhdGVyRnVsbEVxdWFsIjoi4omnIiwiR3JlYXRlckdyZWF0ZXIiOiLiqqIiLCJHcmVhdGVyTGVzcyI6IuKJtyIsIkdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+IiwiR3JlYXRlclRpbGRlIjoi4omzIiwiR3NjciI6IvCdkqIiLCJnc2NyIjoi4oSKIiwiZ3NpbSI6IuKJsyIsImdzaW1lIjoi4qqOIiwiZ3NpbWwiOiLiqpAiLCJndGNjIjoi4qqnIiwiZ3RjaXIiOiLiqboiLCJndCI6Ij4iLCJHVCI6Ij4iLCJHdCI6IuKJqyIsImd0ZG90Ijoi4ouXIiwiZ3RsUGFyIjoi4qaVIiwiZ3RxdWVzdCI6IuKpvCIsImd0cmFwcHJveCI6IuKqhiIsImd0cmFyciI6IuKluCIsImd0cmRvdCI6IuKLlyIsImd0cmVxbGVzcyI6IuKLmyIsImd0cmVxcWxlc3MiOiLiqowiLCJndHJsZXNzIjoi4om3IiwiZ3Ryc2ltIjoi4omzIiwiZ3ZlcnRuZXFxIjoi4omp77iAIiwiZ3ZuRSI6IuKJqe+4gCIsIkhhY2VrIjoiy4ciLCJoYWlyc3AiOiLigIoiLCJoYWxmIjoiwr0iLCJoYW1pbHQiOiLihIsiLCJIQVJEY3kiOiLQqiIsImhhcmRjeSI6ItGKIiwiaGFycmNpciI6IuKliCIsImhhcnIiOiLihpQiLCJoQXJyIjoi4oeUIiwiaGFycnciOiLihq0iLCJIYXQiOiJeIiwiaGJhciI6IuKEjyIsIkhjaXJjIjoixKQiLCJoY2lyYyI6IsSlIiwiaGVhcnRzIjoi4pmlIiwiaGVhcnRzdWl0Ijoi4pmlIiwiaGVsbGlwIjoi4oCmIiwiaGVyY29uIjoi4oq5IiwiaGZyIjoi8J2UpSIsIkhmciI6IuKEjCIsIkhpbGJlcnRTcGFjZSI6IuKEiyIsImhrc2Vhcm93Ijoi4qSlIiwiaGtzd2Fyb3ciOiLipKYiLCJob2FyciI6IuKHvyIsImhvbXRodCI6IuKIuyIsImhvb2tsZWZ0YXJyb3ciOiLihqkiLCJob29rcmlnaHRhcnJvdyI6IuKGqiIsImhvcGYiOiLwnZWZIiwiSG9wZiI6IuKEjSIsImhvcmJhciI6IuKAlSIsIkhvcml6b250YWxMaW5lIjoi4pSAIiwiaHNjciI6IvCdkr0iLCJIc2NyIjoi4oSLIiwiaHNsYXNoIjoi4oSPIiwiSHN0cm9rIjoixKYiLCJoc3Ryb2siOiLEpyIsIkh1bXBEb3duSHVtcCI6IuKJjiIsIkh1bXBFcXVhbCI6IuKJjyIsImh5YnVsbCI6IuKBgyIsImh5cGhlbiI6IuKAkCIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJpYyI6IuKBoyIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiSWN5Ijoi0JgiLCJpY3kiOiLQuCIsIklkb3QiOiLEsCIsIklFY3kiOiLQlSIsImllY3kiOiLQtSIsImlleGNsIjoiwqEiLCJpZmYiOiLih5QiLCJpZnIiOiLwnZSmIiwiSWZyIjoi4oSRIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlpIjoi4oWIIiwiaWlpaW50Ijoi4qiMIiwiaWlpbnQiOiLiiK0iLCJpaW5maW4iOiLip5wiLCJpaW90YSI6IuKEqSIsIklKbGlnIjoixLIiLCJpamxpZyI6IsSzIiwiSW1hY3IiOiLEqiIsImltYWNyIjoixKsiLCJpbWFnZSI6IuKEkSIsIkltYWdpbmFyeUkiOiLihYgiLCJpbWFnbGluZSI6IuKEkCIsImltYWdwYXJ0Ijoi4oSRIiwiaW1hdGgiOiLEsSIsIkltIjoi4oSRIiwiaW1vZiI6IuKKtyIsImltcGVkIjoixrUiLCJJbXBsaWVzIjoi4oeSIiwiaW5jYXJlIjoi4oSFIiwiaW4iOiLiiIgiLCJpbmZpbiI6IuKIniIsImluZmludGllIjoi4qedIiwiaW5vZG90IjoixLEiLCJpbnRjYWwiOiLiiroiLCJpbnQiOiLiiKsiLCJJbnQiOiLiiKwiLCJpbnRlZ2VycyI6IuKEpCIsIkludGVncmFsIjoi4oirIiwiaW50ZXJjYWwiOiLiiroiLCJJbnRlcnNlY3Rpb24iOiLii4IiLCJpbnRsYXJoayI6IuKolyIsImludHByb2QiOiLiqLwiLCJJbnZpc2libGVDb21tYSI6IuKBoyIsIkludmlzaWJsZVRpbWVzIjoi4oGiIiwiSU9jeSI6ItCBIiwiaW9jeSI6ItGRIiwiSW9nb24iOiLEriIsImlvZ29uIjoixK8iLCJJb3BmIjoi8J2VgCIsImlvcGYiOiLwnZWaIiwiSW90YSI6Is6ZIiwiaW90YSI6Is65IiwiaXByb2QiOiLiqLwiLCJpcXVlc3QiOiLCvyIsImlzY3IiOiLwnZK+IiwiSXNjciI6IuKEkCIsImlzaW4iOiLiiIgiLCJpc2luZG90Ijoi4ou1IiwiaXNpbkUiOiLii7kiLCJpc2lucyI6IuKLtCIsImlzaW5zdiI6IuKLsyIsImlzaW52Ijoi4oiIIiwiaXQiOiLigaIiLCJJdGlsZGUiOiLEqCIsIml0aWxkZSI6IsSpIiwiSXVrY3kiOiLQhiIsIml1a2N5Ijoi0ZYiLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJKY2lyYyI6IsS0IiwiamNpcmMiOiLEtSIsIkpjeSI6ItCZIiwiamN5Ijoi0LkiLCJKZnIiOiLwnZSNIiwiamZyIjoi8J2UpyIsImptYXRoIjoiyLciLCJKb3BmIjoi8J2VgSIsImpvcGYiOiLwnZWbIiwiSnNjciI6IvCdkqUiLCJqc2NyIjoi8J2SvyIsIkpzZXJjeSI6ItCIIiwianNlcmN5Ijoi0ZgiLCJKdWtjeSI6ItCEIiwianVrY3kiOiLRlCIsIkthcHBhIjoizpoiLCJrYXBwYSI6Is66Iiwia2FwcGF2Ijoiz7AiLCJLY2VkaWwiOiLEtiIsImtjZWRpbCI6IsS3IiwiS2N5Ijoi0JoiLCJrY3kiOiLQuiIsIktmciI6IvCdlI4iLCJrZnIiOiLwnZSoIiwia2dyZWVuIjoixLgiLCJLSGN5Ijoi0KUiLCJraGN5Ijoi0YUiLCJLSmN5Ijoi0IwiLCJramN5Ijoi0ZwiLCJLb3BmIjoi8J2VgiIsImtvcGYiOiLwnZWcIiwiS3NjciI6IvCdkqYiLCJrc2NyIjoi8J2TgCIsImxBYXJyIjoi4oeaIiwiTGFjdXRlIjoixLkiLCJsYWN1dGUiOiLEuiIsImxhZW1wdHl2Ijoi4qa0IiwibGFncmFuIjoi4oSSIiwiTGFtYmRhIjoizpsiLCJsYW1iZGEiOiLOuyIsImxhbmciOiLin6giLCJMYW5nIjoi4p+qIiwibGFuZ2QiOiLippEiLCJsYW5nbGUiOiLin6giLCJsYXAiOiLiqoUiLCJMYXBsYWNldHJmIjoi4oSSIiwibGFxdW8iOiLCqyIsImxhcnJiIjoi4oekIiwibGFycmJmcyI6IuKknyIsImxhcnIiOiLihpAiLCJMYXJyIjoi4oaeIiwibEFyciI6IuKHkCIsImxhcnJmcyI6IuKknSIsImxhcnJoayI6IuKGqSIsImxhcnJscCI6IuKGqyIsImxhcnJwbCI6IuKkuSIsImxhcnJzaW0iOiLipbMiLCJsYXJydGwiOiLihqIiLCJsYXRhaWwiOiLipJkiLCJsQXRhaWwiOiLipJsiLCJsYXQiOiLiqqsiLCJsYXRlIjoi4qqtIiwibGF0ZXMiOiLiqq3vuIAiLCJsYmFyciI6IuKkjCIsImxCYXJyIjoi4qSOIiwibGJicmsiOiLinbIiLCJsYnJhY2UiOiJ7IiwibGJyYWNrIjoiWyIsImxicmtlIjoi4qaLIiwibGJya3NsZCI6IuKmjyIsImxicmtzbHUiOiLipo0iLCJMY2Fyb24iOiLEvSIsImxjYXJvbiI6IsS+IiwiTGNlZGlsIjoixLsiLCJsY2VkaWwiOiLEvCIsImxjZWlsIjoi4oyIIiwibGN1YiI6InsiLCJMY3kiOiLQmyIsImxjeSI6ItC7IiwibGRjYSI6IuKktiIsImxkcXVvIjoi4oCcIiwibGRxdW9yIjoi4oCeIiwibGRyZGhhciI6IuKlpyIsImxkcnVzaGFyIjoi4qWLIiwibGRzaCI6IuKGsiIsImxlIjoi4omkIiwibEUiOiLiiaYiLCJMZWZ0QW5nbGVCcmFja2V0Ijoi4p+oIiwiTGVmdEFycm93QmFyIjoi4oekIiwibGVmdGFycm93Ijoi4oaQIiwiTGVmdEFycm93Ijoi4oaQIiwiTGVmdGFycm93Ijoi4oeQIiwiTGVmdEFycm93UmlnaHRBcnJvdyI6IuKHhiIsImxlZnRhcnJvd3RhaWwiOiLihqIiLCJMZWZ0Q2VpbGluZyI6IuKMiCIsIkxlZnREb3VibGVCcmFja2V0Ijoi4p+mIiwiTGVmdERvd25UZWVWZWN0b3IiOiLipaEiLCJMZWZ0RG93blZlY3RvckJhciI6IuKlmSIsIkxlZnREb3duVmVjdG9yIjoi4oeDIiwiTGVmdEZsb29yIjoi4oyKIiwibGVmdGhhcnBvb25kb3duIjoi4oa9IiwibGVmdGhhcnBvb251cCI6IuKGvCIsImxlZnRsZWZ0YXJyb3dzIjoi4oeHIiwibGVmdHJpZ2h0YXJyb3ciOiLihpQiLCJMZWZ0UmlnaHRBcnJvdyI6IuKGlCIsIkxlZnRyaWdodGFycm93Ijoi4oeUIiwibGVmdHJpZ2h0YXJyb3dzIjoi4oeGIiwibGVmdHJpZ2h0aGFycG9vbnMiOiLih4siLCJsZWZ0cmlnaHRzcXVpZ2Fycm93Ijoi4oatIiwiTGVmdFJpZ2h0VmVjdG9yIjoi4qWOIiwiTGVmdFRlZUFycm93Ijoi4oakIiwiTGVmdFRlZSI6IuKKoyIsIkxlZnRUZWVWZWN0b3IiOiLipZoiLCJsZWZ0dGhyZWV0aW1lcyI6IuKLiyIsIkxlZnRUcmlhbmdsZUJhciI6IuKnjyIsIkxlZnRUcmlhbmdsZSI6IuKKsiIsIkxlZnRUcmlhbmdsZUVxdWFsIjoi4oq0IiwiTGVmdFVwRG93blZlY3RvciI6IuKlkSIsIkxlZnRVcFRlZVZlY3RvciI6IuKloCIsIkxlZnRVcFZlY3RvckJhciI6IuKlmCIsIkxlZnRVcFZlY3RvciI6IuKGvyIsIkxlZnRWZWN0b3JCYXIiOiLipZIiLCJMZWZ0VmVjdG9yIjoi4oa8IiwibEVnIjoi4qqLIiwibGVnIjoi4ouaIiwibGVxIjoi4omkIiwibGVxcSI6IuKJpiIsImxlcXNsYW50Ijoi4qm9IiwibGVzY2MiOiLiqqgiLCJsZXMiOiLiqb0iLCJsZXNkb3QiOiLiqb8iLCJsZXNkb3RvIjoi4qqBIiwibGVzZG90b3IiOiLiqoMiLCJsZXNnIjoi4oua77iAIiwibGVzZ2VzIjoi4qqTIiwibGVzc2FwcHJveCI6IuKqhSIsImxlc3Nkb3QiOiLii5YiLCJsZXNzZXFndHIiOiLii5oiLCJsZXNzZXFxZ3RyIjoi4qqLIiwiTGVzc0VxdWFsR3JlYXRlciI6IuKLmiIsIkxlc3NGdWxsRXF1YWwiOiLiiaYiLCJMZXNzR3JlYXRlciI6IuKJtiIsImxlc3NndHIiOiLiibYiLCJMZXNzTGVzcyI6IuKqoSIsImxlc3NzaW0iOiLiibIiLCJMZXNzU2xhbnRFcXVhbCI6IuKpvSIsIkxlc3NUaWxkZSI6IuKJsiIsImxmaXNodCI6IuKlvCIsImxmbG9vciI6IuKMiiIsIkxmciI6IvCdlI8iLCJsZnIiOiLwnZSpIiwibGciOiLiibYiLCJsZ0UiOiLiqpEiLCJsSGFyIjoi4qWiIiwibGhhcmQiOiLihr0iLCJsaGFydSI6IuKGvCIsImxoYXJ1bCI6IuKlqiIsImxoYmxrIjoi4paEIiwiTEpjeSI6ItCJIiwibGpjeSI6ItGZIiwibGxhcnIiOiLih4ciLCJsbCI6IuKJqiIsIkxsIjoi4ouYIiwibGxjb3JuZXIiOiLijJ4iLCJMbGVmdGFycm93Ijoi4oeaIiwibGxoYXJkIjoi4qWrIiwibGx0cmkiOiLil7oiLCJMbWlkb3QiOiLEvyIsImxtaWRvdCI6IsWAIiwibG1vdXN0YWNoZSI6IuKOsCIsImxtb3VzdCI6IuKOsCIsImxuYXAiOiLiqokiLCJsbmFwcHJveCI6IuKqiSIsImxuZSI6IuKqhyIsImxuRSI6IuKJqCIsImxuZXEiOiLiqociLCJsbmVxcSI6IuKJqCIsImxuc2ltIjoi4oumIiwibG9hbmciOiLin6wiLCJsb2FyciI6IuKHvSIsImxvYnJrIjoi4p+mIiwibG9uZ2xlZnRhcnJvdyI6IuKftSIsIkxvbmdMZWZ0QXJyb3ciOiLin7UiLCJMb25nbGVmdGFycm93Ijoi4p+4IiwibG9uZ2xlZnRyaWdodGFycm93Ijoi4p+3IiwiTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+3IiwiTG9uZ2xlZnRyaWdodGFycm93Ijoi4p+6IiwibG9uZ21hcHN0byI6IuKfvCIsImxvbmdyaWdodGFycm93Ijoi4p+2IiwiTG9uZ1JpZ2h0QXJyb3ciOiLin7YiLCJMb25ncmlnaHRhcnJvdyI6IuKfuSIsImxvb3BhcnJvd2xlZnQiOiLihqsiLCJsb29wYXJyb3dyaWdodCI6IuKGrCIsImxvcGFyIjoi4qaFIiwiTG9wZiI6IvCdlYMiLCJsb3BmIjoi8J2VnSIsImxvcGx1cyI6IuKorSIsImxvdGltZXMiOiLiqLQiLCJsb3dhc3QiOiLiiJciLCJsb3diYXIiOiJfIiwiTG93ZXJMZWZ0QXJyb3ciOiLihpkiLCJMb3dlclJpZ2h0QXJyb3ciOiLihpgiLCJsb3oiOiLil4oiLCJsb3plbmdlIjoi4peKIiwibG96ZiI6IuKnqyIsImxwYXIiOiIoIiwibHBhcmx0Ijoi4qaTIiwibHJhcnIiOiLih4YiLCJscmNvcm5lciI6IuKMnyIsImxyaGFyIjoi4oeLIiwibHJoYXJkIjoi4qWtIiwibHJtIjoi4oCOIiwibHJ0cmkiOiLiir8iLCJsc2FxdW8iOiLigLkiLCJsc2NyIjoi8J2TgSIsIkxzY3IiOiLihJIiLCJsc2giOiLihrAiLCJMc2giOiLihrAiLCJsc2ltIjoi4omyIiwibHNpbWUiOiLiqo0iLCJsc2ltZyI6IuKqjyIsImxzcWIiOiJbIiwibHNxdW8iOiLigJgiLCJsc3F1b3IiOiLigJoiLCJMc3Ryb2siOiLFgSIsImxzdHJvayI6IsWCIiwibHRjYyI6IuKqpiIsImx0Y2lyIjoi4qm5IiwibHQiOiI8IiwiTFQiOiI8IiwiTHQiOiLiiaoiLCJsdGRvdCI6IuKLliIsImx0aHJlZSI6IuKLiyIsImx0aW1lcyI6IuKLiSIsImx0bGFyciI6IuKltiIsImx0cXVlc3QiOiLiqbsiLCJsdHJpIjoi4peDIiwibHRyaWUiOiLiirQiLCJsdHJpZiI6IuKXgiIsImx0clBhciI6IuKmliIsImx1cmRzaGFyIjoi4qWKIiwibHVydWhhciI6IuKlpiIsImx2ZXJ0bmVxcSI6IuKJqO+4gCIsImx2bkUiOiLiiajvuIAiLCJtYWNyIjoiwq8iLCJtYWxlIjoi4pmCIiwibWFsdCI6IuKcoCIsIm1hbHRlc2UiOiLinKAiLCJNYXAiOiLipIUiLCJtYXAiOiLihqYiLCJtYXBzdG8iOiLihqYiLCJtYXBzdG9kb3duIjoi4oanIiwibWFwc3RvbGVmdCI6IuKGpCIsIm1hcHN0b3VwIjoi4oalIiwibWFya2VyIjoi4pauIiwibWNvbW1hIjoi4qipIiwiTWN5Ijoi0JwiLCJtY3kiOiLQvCIsIm1kYXNoIjoi4oCUIiwibUREb3QiOiLiiLoiLCJtZWFzdXJlZGFuZ2xlIjoi4oihIiwiTWVkaXVtU3BhY2UiOiLigZ8iLCJNZWxsaW50cmYiOiLihLMiLCJNZnIiOiLwnZSQIiwibWZyIjoi8J2UqiIsIm1obyI6IuKEpyIsIm1pY3JvIjoiwrUiLCJtaWRhc3QiOiIqIiwibWlkY2lyIjoi4quwIiwibWlkIjoi4oijIiwibWlkZG90IjoiwrciLCJtaW51c2IiOiLiip8iLCJtaW51cyI6IuKIkiIsIm1pbnVzZCI6IuKIuCIsIm1pbnVzZHUiOiLiqKoiLCJNaW51c1BsdXMiOiLiiJMiLCJtbGNwIjoi4qubIiwibWxkciI6IuKApiIsIm1ucGx1cyI6IuKIkyIsIm1vZGVscyI6IuKKpyIsIk1vcGYiOiLwnZWEIiwibW9wZiI6IvCdlZ4iLCJtcCI6IuKIkyIsIm1zY3IiOiLwnZOCIiwiTXNjciI6IuKEsyIsIm1zdHBvcyI6IuKIviIsIk11IjoizpwiLCJtdSI6Is68IiwibXVsdGltYXAiOiLiirgiLCJtdW1hcCI6IuKKuCIsIm5hYmxhIjoi4oiHIiwiTmFjdXRlIjoixYMiLCJuYWN1dGUiOiLFhCIsIm5hbmciOiLiiKDig5IiLCJuYXAiOiLiiYkiLCJuYXBFIjoi4qmwzLgiLCJuYXBpZCI6IuKJi8y4IiwibmFwb3MiOiLFiSIsIm5hcHByb3giOiLiiYkiLCJuYXR1cmFsIjoi4pmuIiwibmF0dXJhbHMiOiLihJUiLCJuYXR1ciI6IuKZriIsIm5ic3AiOiLCoCIsIm5idW1wIjoi4omOzLgiLCJuYnVtcGUiOiLiiY/MuCIsIm5jYXAiOiLiqYMiLCJOY2Fyb24iOiLFhyIsIm5jYXJvbiI6IsWIIiwiTmNlZGlsIjoixYUiLCJuY2VkaWwiOiLFhiIsIm5jb25nIjoi4omHIiwibmNvbmdkb3QiOiLiqa3MuCIsIm5jdXAiOiLiqYIiLCJOY3kiOiLQnSIsIm5jeSI6ItC9IiwibmRhc2giOiLigJMiLCJuZWFyaGsiOiLipKQiLCJuZWFyciI6IuKGlyIsIm5lQXJyIjoi4oeXIiwibmVhcnJvdyI6IuKGlyIsIm5lIjoi4omgIiwibmVkb3QiOiLiiZDMuCIsIk5lZ2F0aXZlTWVkaXVtU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaWNrU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaW5TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZSI6IuKAiyIsIm5lcXVpdiI6IuKJoiIsIm5lc2VhciI6IuKkqCIsIm5lc2ltIjoi4omCzLgiLCJOZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKJqyIsIk5lc3RlZExlc3NMZXNzIjoi4omqIiwiTmV3TGluZSI6IlxcbiIsIm5leGlzdCI6IuKIhCIsIm5leGlzdHMiOiLiiIQiLCJOZnIiOiLwnZSRIiwibmZyIjoi8J2UqyIsIm5nRSI6IuKJp8y4IiwibmdlIjoi4omxIiwibmdlcSI6IuKJsSIsIm5nZXFxIjoi4omnzLgiLCJuZ2Vxc2xhbnQiOiLiqb7MuCIsIm5nZXMiOiLiqb7MuCIsIm5HZyI6IuKLmcy4IiwibmdzaW0iOiLiibUiLCJuR3QiOiLiiavig5IiLCJuZ3QiOiLiia8iLCJuZ3RyIjoi4omvIiwibkd0diI6IuKJq8y4IiwibmhhcnIiOiLihq4iLCJuaEFyciI6IuKHjiIsIm5ocGFyIjoi4quyIiwibmkiOiLiiIsiLCJuaXMiOiLii7wiLCJuaXNkIjoi4ou6Iiwibml2Ijoi4oiLIiwiTkpjeSI6ItCKIiwibmpjeSI6ItGaIiwibmxhcnIiOiLihpoiLCJubEFyciI6IuKHjSIsIm5sZHIiOiLigKUiLCJubEUiOiLiiabMuCIsIm5sZSI6IuKJsCIsIm5sZWZ0YXJyb3ciOiLihpoiLCJuTGVmdGFycm93Ijoi4oeNIiwibmxlZnRyaWdodGFycm93Ijoi4oauIiwibkxlZnRyaWdodGFycm93Ijoi4oeOIiwibmxlcSI6IuKJsCIsIm5sZXFxIjoi4ommzLgiLCJubGVxc2xhbnQiOiLiqb3MuCIsIm5sZXMiOiLiqb3MuCIsIm5sZXNzIjoi4omuIiwibkxsIjoi4ouYzLgiLCJubHNpbSI6IuKJtCIsIm5MdCI6IuKJquKDkiIsIm5sdCI6IuKJriIsIm5sdHJpIjoi4ouqIiwibmx0cmllIjoi4ousIiwibkx0diI6IuKJqsy4Iiwibm1pZCI6IuKIpCIsIk5vQnJlYWsiOiLigaAiLCJOb25CcmVha2luZ1NwYWNlIjoiwqAiLCJub3BmIjoi8J2VnyIsIk5vcGYiOiLihJUiLCJOb3QiOiLiq6wiLCJub3QiOiLCrCIsIk5vdENvbmdydWVudCI6IuKJoiIsIk5vdEN1cENhcCI6IuKJrSIsIk5vdERvdWJsZVZlcnRpY2FsQmFyIjoi4oimIiwiTm90RWxlbWVudCI6IuKIiSIsIk5vdEVxdWFsIjoi4omgIiwiTm90RXF1YWxUaWxkZSI6IuKJgsy4IiwiTm90RXhpc3RzIjoi4oiEIiwiTm90R3JlYXRlciI6IuKJryIsIk5vdEdyZWF0ZXJFcXVhbCI6IuKJsSIsIk5vdEdyZWF0ZXJGdWxsRXF1YWwiOiLiiafMuCIsIk5vdEdyZWF0ZXJHcmVhdGVyIjoi4omrzLgiLCJOb3RHcmVhdGVyTGVzcyI6IuKJuSIsIk5vdEdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+zLgiLCJOb3RHcmVhdGVyVGlsZGUiOiLiibUiLCJOb3RIdW1wRG93bkh1bXAiOiLiiY7MuCIsIk5vdEh1bXBFcXVhbCI6IuKJj8y4Iiwibm90aW4iOiLiiIkiLCJub3RpbmRvdCI6IuKLtcy4Iiwibm90aW5FIjoi4ou5zLgiLCJub3RpbnZhIjoi4oiJIiwibm90aW52YiI6IuKLtyIsIm5vdGludmMiOiLii7YiLCJOb3RMZWZ0VHJpYW5nbGVCYXIiOiLip4/MuCIsIk5vdExlZnRUcmlhbmdsZSI6IuKLqiIsIk5vdExlZnRUcmlhbmdsZUVxdWFsIjoi4ousIiwiTm90TGVzcyI6IuKJriIsIk5vdExlc3NFcXVhbCI6IuKJsCIsIk5vdExlc3NHcmVhdGVyIjoi4om4IiwiTm90TGVzc0xlc3MiOiLiiarMuCIsIk5vdExlc3NTbGFudEVxdWFsIjoi4qm9zLgiLCJOb3RMZXNzVGlsZGUiOiLiibQiLCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKqosy4IiwiTm90TmVzdGVkTGVzc0xlc3MiOiLiqqHMuCIsIm5vdG5pIjoi4oiMIiwibm90bml2YSI6IuKIjCIsIm5vdG5pdmIiOiLii74iLCJub3RuaXZjIjoi4ou9IiwiTm90UHJlY2VkZXMiOiLiioAiLCJOb3RQcmVjZWRlc0VxdWFsIjoi4qqvzLgiLCJOb3RQcmVjZWRlc1NsYW50RXF1YWwiOiLii6AiLCJOb3RSZXZlcnNlRWxlbWVudCI6IuKIjCIsIk5vdFJpZ2h0VHJpYW5nbGVCYXIiOiLip5DMuCIsIk5vdFJpZ2h0VHJpYW5nbGUiOiLii6siLCJOb3RSaWdodFRyaWFuZ2xlRXF1YWwiOiLii60iLCJOb3RTcXVhcmVTdWJzZXQiOiLiio/MuCIsIk5vdFNxdWFyZVN1YnNldEVxdWFsIjoi4ouiIiwiTm90U3F1YXJlU3VwZXJzZXQiOiLiipDMuCIsIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWwiOiLii6MiLCJOb3RTdWJzZXQiOiLiioLig5IiLCJOb3RTdWJzZXRFcXVhbCI6IuKKiCIsIk5vdFN1Y2NlZWRzIjoi4oqBIiwiTm90U3VjY2VlZHNFcXVhbCI6IuKqsMy4IiwiTm90U3VjY2VlZHNTbGFudEVxdWFsIjoi4ouhIiwiTm90U3VjY2VlZHNUaWxkZSI6IuKJv8y4IiwiTm90U3VwZXJzZXQiOiLiioPig5IiLCJOb3RTdXBlcnNldEVxdWFsIjoi4oqJIiwiTm90VGlsZGUiOiLiiYEiLCJOb3RUaWxkZUVxdWFsIjoi4omEIiwiTm90VGlsZGVGdWxsRXF1YWwiOiLiiYciLCJOb3RUaWxkZVRpbGRlIjoi4omJIiwiTm90VmVydGljYWxCYXIiOiLiiKQiLCJucGFyYWxsZWwiOiLiiKYiLCJucGFyIjoi4oimIiwibnBhcnNsIjoi4qu94oOlIiwibnBhcnQiOiLiiILMuCIsIm5wb2xpbnQiOiLiqJQiLCJucHIiOiLiioAiLCJucHJjdWUiOiLii6AiLCJucHJlYyI6IuKKgCIsIm5wcmVjZXEiOiLiqq/MuCIsIm5wcmUiOiLiqq/MuCIsIm5yYXJyYyI6IuKks8y4IiwibnJhcnIiOiLihpsiLCJuckFyciI6IuKHjyIsIm5yYXJydyI6IuKGncy4IiwibnJpZ2h0YXJyb3ciOiLihpsiLCJuUmlnaHRhcnJvdyI6IuKHjyIsIm5ydHJpIjoi4ourIiwibnJ0cmllIjoi4outIiwibnNjIjoi4oqBIiwibnNjY3VlIjoi4ouhIiwibnNjZSI6IuKqsMy4IiwiTnNjciI6IvCdkqkiLCJuc2NyIjoi8J2TgyIsIm5zaG9ydG1pZCI6IuKIpCIsIm5zaG9ydHBhcmFsbGVsIjoi4oimIiwibnNpbSI6IuKJgSIsIm5zaW1lIjoi4omEIiwibnNpbWVxIjoi4omEIiwibnNtaWQiOiLiiKQiLCJuc3BhciI6IuKIpiIsIm5zcXN1YmUiOiLii6IiLCJuc3FzdXBlIjoi4oujIiwibnN1YiI6IuKKhCIsIm5zdWJFIjoi4quFzLgiLCJuc3ViZSI6IuKKiCIsIm5zdWJzZXQiOiLiioLig5IiLCJuc3Vic2V0ZXEiOiLiiogiLCJuc3Vic2V0ZXFxIjoi4quFzLgiLCJuc3VjYyI6IuKKgSIsIm5zdWNjZXEiOiLiqrDMuCIsIm5zdXAiOiLiioUiLCJuc3VwRSI6IuKrhsy4IiwibnN1cGUiOiLiiokiLCJuc3Vwc2V0Ijoi4oqD4oOSIiwibnN1cHNldGVxIjoi4oqJIiwibnN1cHNldGVxcSI6IuKrhsy4IiwibnRnbCI6IuKJuSIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJudGxnIjoi4om4IiwibnRyaWFuZ2xlbGVmdCI6IuKLqiIsIm50cmlhbmdsZWxlZnRlcSI6IuKLrCIsIm50cmlhbmdsZXJpZ2h0Ijoi4ourIiwibnRyaWFuZ2xlcmlnaHRlcSI6IuKLrSIsIk51Ijoizp0iLCJudSI6Is69IiwibnVtIjoiIyIsIm51bWVybyI6IuKEliIsIm51bXNwIjoi4oCHIiwibnZhcCI6IuKJjeKDkiIsIm52ZGFzaCI6IuKKrCIsIm52RGFzaCI6IuKKrSIsIm5WZGFzaCI6IuKKriIsIm5WRGFzaCI6IuKKryIsIm52Z2UiOiLiiaXig5IiLCJudmd0IjoiPuKDkiIsIm52SGFyciI6IuKkhCIsIm52aW5maW4iOiLip54iLCJudmxBcnIiOiLipIIiLCJudmxlIjoi4omk4oOSIiwibnZsdCI6Ijzig5IiLCJudmx0cmllIjoi4oq04oOSIiwibnZyQXJyIjoi4qSDIiwibnZydHJpZSI6IuKKteKDkiIsIm52c2ltIjoi4oi84oOSIiwibndhcmhrIjoi4qSjIiwibndhcnIiOiLihpYiLCJud0FyciI6IuKHliIsIm53YXJyb3ciOiLihpYiLCJud25lYXIiOiLipKciLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwib2FzdCI6IuKKmyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0Iiwib2NpciI6IuKKmiIsIk9jeSI6ItCeIiwib2N5Ijoi0L4iLCJvZGFzaCI6IuKKnSIsIk9kYmxhYyI6IsWQIiwib2RibGFjIjoixZEiLCJvZGl2Ijoi4qi4Iiwib2RvdCI6IuKKmSIsIm9kc29sZCI6IuKmvCIsIk9FbGlnIjoixZIiLCJvZWxpZyI6IsWTIiwib2ZjaXIiOiLipr8iLCJPZnIiOiLwnZSSIiwib2ZyIjoi8J2UrCIsIm9nb24iOiLLmyIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvZ3QiOiLip4EiLCJvaGJhciI6IuKmtSIsIm9obSI6Is6pIiwib2ludCI6IuKIriIsIm9sYXJyIjoi4oa6Iiwib2xjaXIiOiLipr4iLCJvbGNyb3NzIjoi4qa7Iiwib2xpbmUiOiLigL4iLCJvbHQiOiLip4AiLCJPbWFjciI6IsWMIiwib21hY3IiOiLFjSIsIk9tZWdhIjoizqkiLCJvbWVnYSI6Is+JIiwiT21pY3JvbiI6Is6fIiwib21pY3JvbiI6Is6/Iiwib21pZCI6IuKmtiIsIm9taW51cyI6IuKKliIsIk9vcGYiOiLwnZWGIiwib29wZiI6IvCdlaAiLCJvcGFyIjoi4qa3IiwiT3BlbkN1cmx5RG91YmxlUXVvdGUiOiLigJwiLCJPcGVuQ3VybHlRdW90ZSI6IuKAmCIsIm9wZXJwIjoi4qa5Iiwib3BsdXMiOiLiipUiLCJvcmFyciI6IuKGuyIsIk9yIjoi4qmUIiwib3IiOiLiiKgiLCJvcmQiOiLiqZ0iLCJvcmRlciI6IuKEtCIsIm9yZGVyb2YiOiLihLQiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJvcmlnb2YiOiLiirYiLCJvcm9yIjoi4qmWIiwib3JzbG9wZSI6IuKplyIsIm9ydiI6IuKpmyIsIm9TIjoi4pOIIiwiT3NjciI6IvCdkqoiLCJvc2NyIjoi4oS0IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIm9zb2wiOiLiipgiLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1Iiwib3RpbWVzYXMiOiLiqLYiLCJPdGltZXMiOiLiqLciLCJvdGltZXMiOiLiipciLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJvdmJhciI6IuKMvSIsIk92ZXJCYXIiOiLigL4iLCJPdmVyQnJhY2UiOiLij54iLCJPdmVyQnJhY2tldCI6IuKOtCIsIk92ZXJQYXJlbnRoZXNpcyI6IuKPnCIsInBhcmEiOiLCtiIsInBhcmFsbGVsIjoi4oilIiwicGFyIjoi4oilIiwicGFyc2ltIjoi4quzIiwicGFyc2wiOiLiq70iLCJwYXJ0Ijoi4oiCIiwiUGFydGlhbEQiOiLiiIIiLCJQY3kiOiLQnyIsInBjeSI6ItC/IiwicGVyY250IjoiJSIsInBlcmlvZCI6Ii4iLCJwZXJtaWwiOiLigLAiLCJwZXJwIjoi4oqlIiwicGVydGVuayI6IuKAsSIsIlBmciI6IvCdlJMiLCJwZnIiOiLwnZStIiwiUGhpIjoizqYiLCJwaGkiOiLPhiIsInBoaXYiOiLPlSIsInBobW1hdCI6IuKEsyIsInBob25lIjoi4piOIiwiUGkiOiLOoCIsInBpIjoiz4AiLCJwaXRjaGZvcmsiOiLii5QiLCJwaXYiOiLPliIsInBsYW5jayI6IuKEjyIsInBsYW5ja2giOiLihI4iLCJwbGFua3YiOiLihI8iLCJwbHVzYWNpciI6IuKooyIsInBsdXNiIjoi4oqeIiwicGx1c2NpciI6IuKooiIsInBsdXMiOiIrIiwicGx1c2RvIjoi4oiUIiwicGx1c2R1Ijoi4qilIiwicGx1c2UiOiLiqbIiLCJQbHVzTWludXMiOiLCsSIsInBsdXNtbiI6IsKxIiwicGx1c3NpbSI6IuKopiIsInBsdXN0d28iOiLiqKciLCJwbSI6IsKxIiwiUG9pbmNhcmVwbGFuZSI6IuKEjCIsInBvaW50aW50Ijoi4qiVIiwicG9wZiI6IvCdlaEiLCJQb3BmIjoi4oSZIiwicG91bmQiOiLCoyIsInByYXAiOiLiqrciLCJQciI6IuKquyIsInByIjoi4om6IiwicHJjdWUiOiLiibwiLCJwcmVjYXBwcm94Ijoi4qq3IiwicHJlYyI6IuKJuiIsInByZWNjdXJseWVxIjoi4om8IiwiUHJlY2VkZXMiOiLiiboiLCJQcmVjZWRlc0VxdWFsIjoi4qqvIiwiUHJlY2VkZXNTbGFudEVxdWFsIjoi4om8IiwiUHJlY2VkZXNUaWxkZSI6IuKJviIsInByZWNlcSI6IuKqryIsInByZWNuYXBwcm94Ijoi4qq5IiwicHJlY25lcXEiOiLiqrUiLCJwcmVjbnNpbSI6IuKLqCIsInByZSI6IuKqryIsInByRSI6IuKqsyIsInByZWNzaW0iOiLiib4iLCJwcmltZSI6IuKAsiIsIlByaW1lIjoi4oCzIiwicHJpbWVzIjoi4oSZIiwicHJuYXAiOiLiqrkiLCJwcm5FIjoi4qq1IiwicHJuc2ltIjoi4ouoIiwicHJvZCI6IuKIjyIsIlByb2R1Y3QiOiLiiI8iLCJwcm9mYWxhciI6IuKMriIsInByb2ZsaW5lIjoi4oySIiwicHJvZnN1cmYiOiLijJMiLCJwcm9wIjoi4oidIiwiUHJvcG9ydGlvbmFsIjoi4oidIiwiUHJvcG9ydGlvbiI6IuKItyIsInByb3B0byI6IuKInSIsInByc2ltIjoi4om+IiwicHJ1cmVsIjoi4oqwIiwiUHNjciI6IvCdkqsiLCJwc2NyIjoi8J2ThSIsIlBzaSI6Is6oIiwicHNpIjoiz4giLCJwdW5jc3AiOiLigIgiLCJRZnIiOiLwnZSUIiwicWZyIjoi8J2UriIsInFpbnQiOiLiqIwiLCJxb3BmIjoi8J2VoiIsIlFvcGYiOiLihJoiLCJxcHJpbWUiOiLigZciLCJRc2NyIjoi8J2SrCIsInFzY3IiOiLwnZOGIiwicXVhdGVybmlvbnMiOiLihI0iLCJxdWF0aW50Ijoi4qiWIiwicXVlc3QiOiI/IiwicXVlc3RlcSI6IuKJnyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwickFhcnIiOiLih5siLCJyYWNlIjoi4oi9zLEiLCJSYWN1dGUiOiLFlCIsInJhY3V0ZSI6IsWVIiwicmFkaWMiOiLiiJoiLCJyYWVtcHR5diI6IuKmsyIsInJhbmciOiLin6kiLCJSYW5nIjoi4p+rIiwicmFuZ2QiOiLippIiLCJyYW5nZSI6IuKmpSIsInJhbmdsZSI6IuKfqSIsInJhcXVvIjoiwrsiLCJyYXJyYXAiOiLipbUiLCJyYXJyYiI6IuKHpSIsInJhcnJiZnMiOiLipKAiLCJyYXJyYyI6IuKksyIsInJhcnIiOiLihpIiLCJSYXJyIjoi4oagIiwickFyciI6IuKHkiIsInJhcnJmcyI6IuKkniIsInJhcnJoayI6IuKGqiIsInJhcnJscCI6IuKGrCIsInJhcnJwbCI6IuKlhSIsInJhcnJzaW0iOiLipbQiLCJSYXJydGwiOiLipJYiLCJyYXJydGwiOiLihqMiLCJyYXJydyI6IuKGnSIsInJhdGFpbCI6IuKkmiIsInJBdGFpbCI6IuKknCIsInJhdGlvIjoi4oi2IiwicmF0aW9uYWxzIjoi4oSaIiwicmJhcnIiOiLipI0iLCJyQmFyciI6IuKkjyIsIlJCYXJyIjoi4qSQIiwicmJicmsiOiLinbMiLCJyYnJhY2UiOiJ9IiwicmJyYWNrIjoiXSIsInJicmtlIjoi4qaMIiwicmJya3NsZCI6IuKmjiIsInJicmtzbHUiOiLippAiLCJSY2Fyb24iOiLFmCIsInJjYXJvbiI6IsWZIiwiUmNlZGlsIjoixZYiLCJyY2VkaWwiOiLFlyIsInJjZWlsIjoi4oyJIiwicmN1YiI6In0iLCJSY3kiOiLQoCIsInJjeSI6ItGAIiwicmRjYSI6IuKktyIsInJkbGRoYXIiOiLipakiLCJyZHF1byI6IuKAnSIsInJkcXVvciI6IuKAnSIsInJkc2giOiLihrMiLCJyZWFsIjoi4oScIiwicmVhbGluZSI6IuKEmyIsInJlYWxwYXJ0Ijoi4oScIiwicmVhbHMiOiLihJ0iLCJSZSI6IuKEnCIsInJlY3QiOiLilq0iLCJyZWciOiLCriIsIlJFRyI6IsKuIiwiUmV2ZXJzZUVsZW1lbnQiOiLiiIsiLCJSZXZlcnNlRXF1aWxpYnJpdW0iOiLih4siLCJSZXZlcnNlVXBFcXVpbGlicml1bSI6IuKlryIsInJmaXNodCI6IuKlvSIsInJmbG9vciI6IuKMiyIsInJmciI6IvCdlK8iLCJSZnIiOiLihJwiLCJySGFyIjoi4qWkIiwicmhhcmQiOiLih4EiLCJyaGFydSI6IuKHgCIsInJoYXJ1bCI6IuKlrCIsIlJobyI6Is6hIiwicmhvIjoiz4EiLCJyaG92Ijoiz7EiLCJSaWdodEFuZ2xlQnJhY2tldCI6IuKfqSIsIlJpZ2h0QXJyb3dCYXIiOiLih6UiLCJyaWdodGFycm93Ijoi4oaSIiwiUmlnaHRBcnJvdyI6IuKGkiIsIlJpZ2h0YXJyb3ciOiLih5IiLCJSaWdodEFycm93TGVmdEFycm93Ijoi4oeEIiwicmlnaHRhcnJvd3RhaWwiOiLihqMiLCJSaWdodENlaWxpbmciOiLijIkiLCJSaWdodERvdWJsZUJyYWNrZXQiOiLin6ciLCJSaWdodERvd25UZWVWZWN0b3IiOiLipZ0iLCJSaWdodERvd25WZWN0b3JCYXIiOiLipZUiLCJSaWdodERvd25WZWN0b3IiOiLih4IiLCJSaWdodEZsb29yIjoi4oyLIiwicmlnaHRoYXJwb29uZG93biI6IuKHgSIsInJpZ2h0aGFycG9vbnVwIjoi4oeAIiwicmlnaHRsZWZ0YXJyb3dzIjoi4oeEIiwicmlnaHRsZWZ0aGFycG9vbnMiOiLih4wiLCJyaWdodHJpZ2h0YXJyb3dzIjoi4oeJIiwicmlnaHRzcXVpZ2Fycm93Ijoi4oadIiwiUmlnaHRUZWVBcnJvdyI6IuKGpiIsIlJpZ2h0VGVlIjoi4oqiIiwiUmlnaHRUZWVWZWN0b3IiOiLipZsiLCJyaWdodHRocmVldGltZXMiOiLii4wiLCJSaWdodFRyaWFuZ2xlQmFyIjoi4qeQIiwiUmlnaHRUcmlhbmdsZSI6IuKKsyIsIlJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKKtSIsIlJpZ2h0VXBEb3duVmVjdG9yIjoi4qWPIiwiUmlnaHRVcFRlZVZlY3RvciI6IuKlnCIsIlJpZ2h0VXBWZWN0b3JCYXIiOiLipZQiLCJSaWdodFVwVmVjdG9yIjoi4oa+IiwiUmlnaHRWZWN0b3JCYXIiOiLipZMiLCJSaWdodFZlY3RvciI6IuKHgCIsInJpbmciOiLLmiIsInJpc2luZ2RvdHNlcSI6IuKJkyIsInJsYXJyIjoi4oeEIiwicmxoYXIiOiLih4wiLCJybG0iOiLigI8iLCJybW91c3RhY2hlIjoi4o6xIiwicm1vdXN0Ijoi4o6xIiwicm5taWQiOiLiq64iLCJyb2FuZyI6IuKfrSIsInJvYXJyIjoi4oe+Iiwicm9icmsiOiLin6ciLCJyb3BhciI6IuKmhiIsInJvcGYiOiLwnZWjIiwiUm9wZiI6IuKEnSIsInJvcGx1cyI6IuKoriIsInJvdGltZXMiOiLiqLUiLCJSb3VuZEltcGxpZXMiOiLipbAiLCJycGFyIjoiKSIsInJwYXJndCI6IuKmlCIsInJwcG9saW50Ijoi4qiSIiwicnJhcnIiOiLih4kiLCJScmlnaHRhcnJvdyI6IuKHmyIsInJzYXF1byI6IuKAuiIsInJzY3IiOiLwnZOHIiwiUnNjciI6IuKEmyIsInJzaCI6IuKGsSIsIlJzaCI6IuKGsSIsInJzcWIiOiJdIiwicnNxdW8iOiLigJkiLCJyc3F1b3IiOiLigJkiLCJydGhyZWUiOiLii4wiLCJydGltZXMiOiLii4oiLCJydHJpIjoi4pa5IiwicnRyaWUiOiLiirUiLCJydHJpZiI6IuKWuCIsInJ0cmlsdHJpIjoi4qeOIiwiUnVsZURlbGF5ZWQiOiLip7QiLCJydWx1aGFyIjoi4qWoIiwicngiOiLihJ4iLCJTYWN1dGUiOiLFmiIsInNhY3V0ZSI6IsWbIiwic2JxdW8iOiLigJoiLCJzY2FwIjoi4qq4IiwiU2Nhcm9uIjoixaAiLCJzY2Fyb24iOiLFoSIsIlNjIjoi4qq8Iiwic2MiOiLiibsiLCJzY2N1ZSI6IuKJvSIsInNjZSI6IuKqsCIsInNjRSI6IuKqtCIsIlNjZWRpbCI6IsWeIiwic2NlZGlsIjoixZ8iLCJTY2lyYyI6IsWcIiwic2NpcmMiOiLFnSIsInNjbmFwIjoi4qq6Iiwic2NuRSI6IuKqtiIsInNjbnNpbSI6IuKLqSIsInNjcG9saW50Ijoi4qiTIiwic2NzaW0iOiLiib8iLCJTY3kiOiLQoSIsInNjeSI6ItGBIiwic2RvdGIiOiLiiqEiLCJzZG90Ijoi4ouFIiwic2RvdGUiOiLiqaYiLCJzZWFyaGsiOiLipKUiLCJzZWFyciI6IuKGmCIsInNlQXJyIjoi4oeYIiwic2VhcnJvdyI6IuKGmCIsInNlY3QiOiLCpyIsInNlbWkiOiI7Iiwic2Vzd2FyIjoi4qSpIiwic2V0bWludXMiOiLiiJYiLCJzZXRtbiI6IuKIliIsInNleHQiOiLinLYiLCJTZnIiOiLwnZSWIiwic2ZyIjoi8J2UsCIsInNmcm93biI6IuKMoiIsInNoYXJwIjoi4pmvIiwiU0hDSGN5Ijoi0KkiLCJzaGNoY3kiOiLRiSIsIlNIY3kiOiLQqCIsInNoY3kiOiLRiCIsIlNob3J0RG93bkFycm93Ijoi4oaTIiwiU2hvcnRMZWZ0QXJyb3ciOiLihpAiLCJzaG9ydG1pZCI6IuKIoyIsInNob3J0cGFyYWxsZWwiOiLiiKUiLCJTaG9ydFJpZ2h0QXJyb3ciOiLihpIiLCJTaG9ydFVwQXJyb3ciOiLihpEiLCJzaHkiOiLCrSIsIlNpZ21hIjoizqMiLCJzaWdtYSI6Is+DIiwic2lnbWFmIjoiz4IiLCJzaWdtYXYiOiLPgiIsInNpbSI6IuKIvCIsInNpbWRvdCI6IuKpqiIsInNpbWUiOiLiiYMiLCJzaW1lcSI6IuKJgyIsInNpbWciOiLiqp4iLCJzaW1nRSI6IuKqoCIsInNpbWwiOiLiqp0iLCJzaW1sRSI6IuKqnyIsInNpbW5lIjoi4omGIiwic2ltcGx1cyI6IuKopCIsInNpbXJhcnIiOiLipbIiLCJzbGFyciI6IuKGkCIsIlNtYWxsQ2lyY2xlIjoi4oiYIiwic21hbGxzZXRtaW51cyI6IuKIliIsInNtYXNocCI6IuKosyIsInNtZXBhcnNsIjoi4qekIiwic21pZCI6IuKIoyIsInNtaWxlIjoi4oyjIiwic210Ijoi4qqqIiwic210ZSI6IuKqrCIsInNtdGVzIjoi4qqs77iAIiwiU09GVGN5Ijoi0KwiLCJzb2Z0Y3kiOiLRjCIsInNvbGJhciI6IuKMvyIsInNvbGIiOiLip4QiLCJzb2wiOiIvIiwiU29wZiI6IvCdlYoiLCJzb3BmIjoi8J2VpCIsInNwYWRlcyI6IuKZoCIsInNwYWRlc3VpdCI6IuKZoCIsInNwYXIiOiLiiKUiLCJzcWNhcCI6IuKKkyIsInNxY2FwcyI6IuKKk++4gCIsInNxY3VwIjoi4oqUIiwic3FjdXBzIjoi4oqU77iAIiwiU3FydCI6IuKImiIsInNxc3ViIjoi4oqPIiwic3FzdWJlIjoi4oqRIiwic3FzdWJzZXQiOiLiio8iLCJzcXN1YnNldGVxIjoi4oqRIiwic3FzdXAiOiLiipAiLCJzcXN1cGUiOiLiipIiLCJzcXN1cHNldCI6IuKKkCIsInNxc3Vwc2V0ZXEiOiLiipIiLCJzcXVhcmUiOiLilqEiLCJTcXVhcmUiOiLilqEiLCJTcXVhcmVJbnRlcnNlY3Rpb24iOiLiipMiLCJTcXVhcmVTdWJzZXQiOiLiio8iLCJTcXVhcmVTdWJzZXRFcXVhbCI6IuKKkSIsIlNxdWFyZVN1cGVyc2V0Ijoi4oqQIiwiU3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKKkiIsIlNxdWFyZVVuaW9uIjoi4oqUIiwic3F1YXJmIjoi4paqIiwic3F1Ijoi4pahIiwic3F1ZiI6IuKWqiIsInNyYXJyIjoi4oaSIiwiU3NjciI6IvCdkq4iLCJzc2NyIjoi8J2TiCIsInNzZXRtbiI6IuKIliIsInNzbWlsZSI6IuKMoyIsInNzdGFyZiI6IuKLhiIsIlN0YXIiOiLii4YiLCJzdGFyIjoi4piGIiwic3RhcmYiOiLimIUiLCJzdHJhaWdodGVwc2lsb24iOiLPtSIsInN0cmFpZ2h0cGhpIjoiz5UiLCJzdHJucyI6IsKvIiwic3ViIjoi4oqCIiwiU3ViIjoi4ouQIiwic3ViZG90Ijoi4qq9Iiwic3ViRSI6IuKrhSIsInN1YmUiOiLiioYiLCJzdWJlZG90Ijoi4quDIiwic3VibXVsdCI6IuKrgSIsInN1Ym5FIjoi4quLIiwic3VibmUiOiLiiooiLCJzdWJwbHVzIjoi4qq/Iiwic3VicmFyciI6IuKluSIsInN1YnNldCI6IuKKgiIsIlN1YnNldCI6IuKLkCIsInN1YnNldGVxIjoi4oqGIiwic3Vic2V0ZXFxIjoi4quFIiwiU3Vic2V0RXF1YWwiOiLiioYiLCJzdWJzZXRuZXEiOiLiiooiLCJzdWJzZXRuZXFxIjoi4quLIiwic3Vic2ltIjoi4quHIiwic3Vic3ViIjoi4quVIiwic3Vic3VwIjoi4quTIiwic3VjY2FwcHJveCI6IuKquCIsInN1Y2MiOiLiibsiLCJzdWNjY3VybHllcSI6IuKJvSIsIlN1Y2NlZWRzIjoi4om7IiwiU3VjY2VlZHNFcXVhbCI6IuKqsCIsIlN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKJvSIsIlN1Y2NlZWRzVGlsZGUiOiLiib8iLCJzdWNjZXEiOiLiqrAiLCJzdWNjbmFwcHJveCI6IuKquiIsInN1Y2NuZXFxIjoi4qq2Iiwic3VjY25zaW0iOiLii6kiLCJzdWNjc2ltIjoi4om/IiwiU3VjaFRoYXQiOiLiiIsiLCJzdW0iOiLiiJEiLCJTdW0iOiLiiJEiLCJzdW5nIjoi4pmqIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3VwIjoi4oqDIiwiU3VwIjoi4ouRIiwic3VwZG90Ijoi4qq+Iiwic3VwZHN1YiI6IuKrmCIsInN1cEUiOiLiq4YiLCJzdXBlIjoi4oqHIiwic3VwZWRvdCI6IuKrhCIsIlN1cGVyc2V0Ijoi4oqDIiwiU3VwZXJzZXRFcXVhbCI6IuKKhyIsInN1cGhzb2wiOiLin4kiLCJzdXBoc3ViIjoi4quXIiwic3VwbGFyciI6IuKluyIsInN1cG11bHQiOiLiq4IiLCJzdXBuRSI6IuKrjCIsInN1cG5lIjoi4oqLIiwic3VwcGx1cyI6IuKrgCIsInN1cHNldCI6IuKKgyIsIlN1cHNldCI6IuKLkSIsInN1cHNldGVxIjoi4oqHIiwic3Vwc2V0ZXFxIjoi4quGIiwic3Vwc2V0bmVxIjoi4oqLIiwic3Vwc2V0bmVxcSI6IuKrjCIsInN1cHNpbSI6IuKriCIsInN1cHN1YiI6IuKrlCIsInN1cHN1cCI6IuKrliIsInN3YXJoayI6IuKkpiIsInN3YXJyIjoi4oaZIiwic3dBcnIiOiLih5kiLCJzd2Fycm93Ijoi4oaZIiwic3dud2FyIjoi4qSqIiwic3psaWciOiLDnyIsIlRhYiI6IlxcdCIsInRhcmdldCI6IuKMliIsIlRhdSI6Is6kIiwidGF1Ijoiz4QiLCJ0YnJrIjoi4o60IiwiVGNhcm9uIjoixaQiLCJ0Y2Fyb24iOiLFpSIsIlRjZWRpbCI6IsWiIiwidGNlZGlsIjoixaMiLCJUY3kiOiLQoiIsInRjeSI6ItGCIiwidGRvdCI6IuKDmyIsInRlbHJlYyI6IuKMlSIsIlRmciI6IvCdlJciLCJ0ZnIiOiLwnZSxIiwidGhlcmU0Ijoi4oi0IiwidGhlcmVmb3JlIjoi4oi0IiwiVGhlcmVmb3JlIjoi4oi0IiwiVGhldGEiOiLOmCIsInRoZXRhIjoizrgiLCJ0aGV0YXN5bSI6Is+RIiwidGhldGF2Ijoiz5EiLCJ0aGlja2FwcHJveCI6IuKJiCIsInRoaWNrc2ltIjoi4oi8IiwiVGhpY2tTcGFjZSI6IuKBn+KAiiIsIlRoaW5TcGFjZSI6IuKAiSIsInRoaW5zcCI6IuKAiSIsInRoa2FwIjoi4omIIiwidGhrc2ltIjoi4oi8IiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aWxkZSI6IsucIiwiVGlsZGUiOiLiiLwiLCJUaWxkZUVxdWFsIjoi4omDIiwiVGlsZGVGdWxsRXF1YWwiOiLiiYUiLCJUaWxkZVRpbGRlIjoi4omIIiwidGltZXNiYXIiOiLiqLEiLCJ0aW1lc2IiOiLiiqAiLCJ0aW1lcyI6IsOXIiwidGltZXNkIjoi4qiwIiwidGludCI6IuKIrSIsInRvZWEiOiLipKgiLCJ0b3Bib3QiOiLijLYiLCJ0b3BjaXIiOiLiq7EiLCJ0b3AiOiLiiqQiLCJUb3BmIjoi8J2ViyIsInRvcGYiOiLwnZWlIiwidG9wZm9yayI6IuKrmiIsInRvc2EiOiLipKkiLCJ0cHJpbWUiOiLigLQiLCJ0cmFkZSI6IuKEoiIsIlRSQURFIjoi4oSiIiwidHJpYW5nbGUiOiLilrUiLCJ0cmlhbmdsZWRvd24iOiLilr8iLCJ0cmlhbmdsZWxlZnQiOiLil4MiLCJ0cmlhbmdsZWxlZnRlcSI6IuKKtCIsInRyaWFuZ2xlcSI6IuKJnCIsInRyaWFuZ2xlcmlnaHQiOiLilrkiLCJ0cmlhbmdsZXJpZ2h0ZXEiOiLiirUiLCJ0cmlkb3QiOiLil6wiLCJ0cmllIjoi4omcIiwidHJpbWludXMiOiLiqLoiLCJUcmlwbGVEb3QiOiLig5siLCJ0cmlwbHVzIjoi4qi5IiwidHJpc2IiOiLip40iLCJ0cml0aW1lIjoi4qi7IiwidHJwZXppdW0iOiLij6IiLCJUc2NyIjoi8J2SryIsInRzY3IiOiLwnZOJIiwiVFNjeSI6ItCmIiwidHNjeSI6ItGGIiwiVFNIY3kiOiLQiyIsInRzaGN5Ijoi0ZsiLCJUc3Ryb2siOiLFpiIsInRzdHJvayI6IsWnIiwidHdpeHQiOiLiiawiLCJ0d29oZWFkbGVmdGFycm93Ijoi4oaeIiwidHdvaGVhZHJpZ2h0YXJyb3ciOiLihqAiLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwidWFyciI6IuKGkSIsIlVhcnIiOiLihp8iLCJ1QXJyIjoi4oeRIiwiVWFycm9jaXIiOiLipYkiLCJVYnJjeSI6ItCOIiwidWJyY3kiOiLRniIsIlVicmV2ZSI6IsWsIiwidWJyZXZlIjoixa0iLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVjeSI6ItCjIiwidWN5Ijoi0YMiLCJ1ZGFyciI6IuKHhSIsIlVkYmxhYyI6IsWwIiwidWRibGFjIjoixbEiLCJ1ZGhhciI6IuKlriIsInVmaXNodCI6IuKlviIsIlVmciI6IvCdlJgiLCJ1ZnIiOiLwnZSyIiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVIYXIiOiLipaMiLCJ1aGFybCI6IuKGvyIsInVoYXJyIjoi4oa+IiwidWhibGsiOiLiloAiLCJ1bGNvcm4iOiLijJwiLCJ1bGNvcm5lciI6IuKMnCIsInVsY3JvcCI6IuKMjyIsInVsdHJpIjoi4pe4IiwiVW1hY3IiOiLFqiIsInVtYWNyIjoixasiLCJ1bWwiOiLCqCIsIlVuZGVyQmFyIjoiXyIsIlVuZGVyQnJhY2UiOiLij58iLCJVbmRlckJyYWNrZXQiOiLijrUiLCJVbmRlclBhcmVudGhlc2lzIjoi4o+dIiwiVW5pb24iOiLii4MiLCJVbmlvblBsdXMiOiLiio4iLCJVb2dvbiI6IsWyIiwidW9nb24iOiLFsyIsIlVvcGYiOiLwnZWMIiwidW9wZiI6IvCdlaYiLCJVcEFycm93QmFyIjoi4qSSIiwidXBhcnJvdyI6IuKGkSIsIlVwQXJyb3ciOiLihpEiLCJVcGFycm93Ijoi4oeRIiwiVXBBcnJvd0Rvd25BcnJvdyI6IuKHhSIsInVwZG93bmFycm93Ijoi4oaVIiwiVXBEb3duQXJyb3ciOiLihpUiLCJVcGRvd25hcnJvdyI6IuKHlSIsIlVwRXF1aWxpYnJpdW0iOiLipa4iLCJ1cGhhcnBvb25sZWZ0Ijoi4oa/IiwidXBoYXJwb29ucmlnaHQiOiLihr4iLCJ1cGx1cyI6IuKKjiIsIlVwcGVyTGVmdEFycm93Ijoi4oaWIiwiVXBwZXJSaWdodEFycm93Ijoi4oaXIiwidXBzaSI6Is+FIiwiVXBzaSI6Is+SIiwidXBzaWgiOiLPkiIsIlVwc2lsb24iOiLOpSIsInVwc2lsb24iOiLPhSIsIlVwVGVlQXJyb3ciOiLihqUiLCJVcFRlZSI6IuKKpSIsInVwdXBhcnJvd3MiOiLih4giLCJ1cmNvcm4iOiLijJ0iLCJ1cmNvcm5lciI6IuKMnSIsInVyY3JvcCI6IuKMjiIsIlVyaW5nIjoixa4iLCJ1cmluZyI6IsWvIiwidXJ0cmkiOiLil7kiLCJVc2NyIjoi8J2SsCIsInVzY3IiOiLwnZOKIiwidXRkb3QiOiLii7AiLCJVdGlsZGUiOiLFqCIsInV0aWxkZSI6IsWpIiwidXRyaSI6IuKWtSIsInV0cmlmIjoi4pa0IiwidXVhcnIiOiLih4giLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJ1d2FuZ2xlIjoi4qanIiwidmFuZ3J0Ijoi4qacIiwidmFyZXBzaWxvbiI6Is+1IiwidmFya2FwcGEiOiLPsCIsInZhcm5vdGhpbmciOiLiiIUiLCJ2YXJwaGkiOiLPlSIsInZhcnBpIjoiz5YiLCJ2YXJwcm9wdG8iOiLiiJ0iLCJ2YXJyIjoi4oaVIiwidkFyciI6IuKHlSIsInZhcnJobyI6Is+xIiwidmFyc2lnbWEiOiLPgiIsInZhcnN1YnNldG5lcSI6IuKKiu+4gCIsInZhcnN1YnNldG5lcXEiOiLiq4vvuIAiLCJ2YXJzdXBzZXRuZXEiOiLiiovvuIAiLCJ2YXJzdXBzZXRuZXFxIjoi4quM77iAIiwidmFydGhldGEiOiLPkSIsInZhcnRyaWFuZ2xlbGVmdCI6IuKKsiIsInZhcnRyaWFuZ2xlcmlnaHQiOiLiirMiLCJ2QmFyIjoi4quoIiwiVmJhciI6IuKrqyIsInZCYXJ2Ijoi4qupIiwiVmN5Ijoi0JIiLCJ2Y3kiOiLQsiIsInZkYXNoIjoi4oqiIiwidkRhc2giOiLiiqgiLCJWZGFzaCI6IuKKqSIsIlZEYXNoIjoi4oqrIiwiVmRhc2hsIjoi4qumIiwidmVlYmFyIjoi4oq7IiwidmVlIjoi4oioIiwiVmVlIjoi4ouBIiwidmVlZXEiOiLiiZoiLCJ2ZWxsaXAiOiLii64iLCJ2ZXJiYXIiOiJ8IiwiVmVyYmFyIjoi4oCWIiwidmVydCI6InwiLCJWZXJ0Ijoi4oCWIiwiVmVydGljYWxCYXIiOiLiiKMiLCJWZXJ0aWNhbExpbmUiOiJ8IiwiVmVydGljYWxTZXBhcmF0b3IiOiLinZgiLCJWZXJ0aWNhbFRpbGRlIjoi4omAIiwiVmVyeVRoaW5TcGFjZSI6IuKAiiIsIlZmciI6IvCdlJkiLCJ2ZnIiOiLwnZSzIiwidmx0cmkiOiLiirIiLCJ2bnN1YiI6IuKKguKDkiIsInZuc3VwIjoi4oqD4oOSIiwiVm9wZiI6IvCdlY0iLCJ2b3BmIjoi8J2VpyIsInZwcm9wIjoi4oidIiwidnJ0cmkiOiLiirMiLCJWc2NyIjoi8J2SsSIsInZzY3IiOiLwnZOLIiwidnN1Ym5FIjoi4quL77iAIiwidnN1Ym5lIjoi4oqK77iAIiwidnN1cG5FIjoi4quM77iAIiwidnN1cG5lIjoi4oqL77iAIiwiVnZkYXNoIjoi4oqqIiwidnppZ3phZyI6IuKmmiIsIldjaXJjIjoixbQiLCJ3Y2lyYyI6IsW1Iiwid2VkYmFyIjoi4qmfIiwid2VkZ2UiOiLiiKciLCJXZWRnZSI6IuKLgCIsIndlZGdlcSI6IuKJmSIsIndlaWVycCI6IuKEmCIsIldmciI6IvCdlJoiLCJ3ZnIiOiLwnZS0IiwiV29wZiI6IvCdlY4iLCJ3b3BmIjoi8J2VqCIsIndwIjoi4oSYIiwid3IiOiLiiYAiLCJ3cmVhdGgiOiLiiYAiLCJXc2NyIjoi8J2SsiIsIndzY3IiOiLwnZOMIiwieGNhcCI6IuKLgiIsInhjaXJjIjoi4pevIiwieGN1cCI6IuKLgyIsInhkdHJpIjoi4pa9IiwiWGZyIjoi8J2UmyIsInhmciI6IvCdlLUiLCJ4aGFyciI6IuKftyIsInhoQXJyIjoi4p+6IiwiWGkiOiLOniIsInhpIjoizr4iLCJ4bGFyciI6IuKftSIsInhsQXJyIjoi4p+4IiwieG1hcCI6IuKfvCIsInhuaXMiOiLii7siLCJ4b2RvdCI6IuKogCIsIlhvcGYiOiLwnZWPIiwieG9wZiI6IvCdlakiLCJ4b3BsdXMiOiLiqIEiLCJ4b3RpbWUiOiLiqIIiLCJ4cmFyciI6IuKftiIsInhyQXJyIjoi4p+5IiwiWHNjciI6IvCdkrMiLCJ4c2NyIjoi8J2TjSIsInhzcWN1cCI6IuKohiIsInh1cGx1cyI6IuKohCIsInh1dHJpIjoi4pazIiwieHZlZSI6IuKLgSIsInh3ZWRnZSI6IuKLgCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJZQWN5Ijoi0K8iLCJ5YWN5Ijoi0Y8iLCJZY2lyYyI6IsW2IiwieWNpcmMiOiLFtyIsIlljeSI6ItCrIiwieWN5Ijoi0YsiLCJ5ZW4iOiLCpSIsIllmciI6IvCdlJwiLCJ5ZnIiOiLwnZS2IiwiWUljeSI6ItCHIiwieWljeSI6ItGXIiwiWW9wZiI6IvCdlZAiLCJ5b3BmIjoi8J2VqiIsIllzY3IiOiLwnZK0IiwieXNjciI6IvCdk44iLCJZVWN5Ijoi0K4iLCJ5dWN5Ijoi0Y4iLCJ5dW1sIjoiw78iLCJZdW1sIjoixbgiLCJaYWN1dGUiOiLFuSIsInphY3V0ZSI6IsW6IiwiWmNhcm9uIjoixb0iLCJ6Y2Fyb24iOiLFviIsIlpjeSI6ItCXIiwiemN5Ijoi0LciLCJaZG90IjoixbsiLCJ6ZG90IjoixbwiLCJ6ZWV0cmYiOiLihKgiLCJaZXJvV2lkdGhTcGFjZSI6IuKAiyIsIlpldGEiOiLOliIsInpldGEiOiLOtiIsInpmciI6IvCdlLciLCJaZnIiOiLihKgiLCJaSGN5Ijoi0JYiLCJ6aGN5Ijoi0LYiLCJ6aWdyYXJyIjoi4oedIiwiem9wZiI6IvCdlasiLCJab3BmIjoi4oSkIiwiWnNjciI6IvCdkrUiLCJ6c2NyIjoi8J2TjyIsInp3aiI6IuKAjSIsInp3bmoiOiLigIwifScpfSxmdW5jdGlvbih1KXt1LmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJicnZiYXIiOiLCpiIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJjZWRpbCI6IsK4IiwiY2VudCI6IsKiIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY3VycmVuIjoiwqQiLCJkZWciOiLCsCIsImRpdmlkZSI6IsO3IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJmcmFjMTIiOiLCvSIsImZyYWMxNCI6IsK8IiwiZnJhYzM0Ijoiwr4iLCJndCI6Ij4iLCJHVCI6Ij4iLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJpZXhjbCI6IsKhIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlxdWVzdCI6IsK/IiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwibGFxdW8iOiLCqyIsImx0IjoiPCIsIkxUIjoiPCIsIm1hY3IiOiLCryIsIm1pY3JvIjoiwrUiLCJtaWRkb3QiOiLCtyIsIm5ic3AiOiLCoCIsIm5vdCI6IsKsIiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4IiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsInBhcmEiOiLCtiIsInBsdXNtbiI6IsKxIiwicG91bmQiOiLCoyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwicmFxdW8iOiLCuyIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJzZWN0IjoiwqciLCJzaHkiOiLCrSIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN6bGlnIjoiw58iLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbWVzIjoiw5ciLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidW1sIjoiwqgiLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwieWVuIjoiwqUiLCJ5dW1sIjoiw78ifScpfSxmdW5jdGlvbih1KXt1LmV4cG9ydHM9SlNPTi5wYXJzZShgeyJhbXAiOiImIiwiYXBvcyI6IiciLCJndCI6Ij4iLCJsdCI6IjwiLCJxdW90IjoiXFwiIn1gKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihhKXtyZXR1cm4gYSYmYS5fX2VzTW9kdWxlP2E6e2RlZmF1bHQ6YX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj1yKHQoMjY1KSk7ZnVuY3Rpb24gaShhKXtpZihhPj01NTI5NiYmYTw9NTczNDN8fGE+MTExNDExMSlyZXR1cm4i77+9IjthIGluIG4uZGVmYXVsdCYmKGE9bi5kZWZhdWx0W2FdKTt2YXIgbD0iIjtyZXR1cm4gYT42NTUzNSYmKGEtPTY1NTM2LGwrPVN0cmluZy5mcm9tQ2hhckNvZGUoYT4+PjEwJjEwMjN8NTUyOTYpLGE9NTYzMjB8YSYxMDIzKSxsKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpLGx9ZS5kZWZhdWx0PWl9LGZ1bmN0aW9uKHUpe3UuZXhwb3J0cz1KU09OLnBhcnNlKCd7IjAiOjY1NTMzLCIxMjgiOjgzNjQsIjEzMCI6ODIxOCwiMTMxIjo0MDIsIjEzMiI6ODIyMiwiMTMzIjo4MjMwLCIxMzQiOjgyMjQsIjEzNSI6ODIyNSwiMTM2Ijo3MTAsIjEzNyI6ODI0MCwiMTM4IjozNTIsIjEzOSI6ODI0OSwiMTQwIjozMzgsIjE0MiI6MzgxLCIxNDUiOjgyMTYsIjE0NiI6ODIxNywiMTQ3Ijo4MjIwLCIxNDgiOjgyMjEsIjE0OSI6ODIyNiwiMTUwIjo4MjExLCIxNTEiOjgyMTIsIjE1MiI6NzMyLCIxNTMiOjg0ODIsIjE1NCI6MzUzLCIxNTUiOjgyNTAsIjE1NiI6MzM5LCIxNTgiOjM4MiwiMTU5IjozNzZ9Jyl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oTyl7cmV0dXJuIE8mJk8uX19lc01vZHVsZT9POntkZWZhdWx0Ok99fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lc2NhcGU9ZS5lbmNvZGVIVE1MPWUuZW5jb2RlWE1MPXZvaWQgMDt2YXIgbj1yKHQoMjYzKSksaT12KG4uZGVmYXVsdCksYT1kKGkpO2UuZW5jb2RlWE1MPVAoaSxhKTt2YXIgbD1yKHQoMjYxKSkscz12KGwuZGVmYXVsdCksZj1kKHMpO2UuZW5jb2RlSFRNTD1QKHMsZik7ZnVuY3Rpb24gdihPKXtyZXR1cm4gT2JqZWN0LmtleXMoTykuc29ydCgpLnJlZHVjZShmdW5jdGlvbihvLGgpe3JldHVybiBvW09baF1dPSImIitoKyI7IixvfSx7fSl9ZnVuY3Rpb24gZChPKXtmb3IodmFyIG89W10saD1bXSxjPTAsZz1PYmplY3Qua2V5cyhPKTtjPGcubGVuZ3RoO2MrKyl7dmFyIGI9Z1tjXTtiLmxlbmd0aD09PTE/by5wdXNoKCJcXCIrYik6aC5wdXNoKGIpfW8uc29ydCgpO2Zvcih2YXIgRT0wO0U8by5sZW5ndGgtMTtFKyspe2Zvcih2YXIgQT1FO0E8by5sZW5ndGgtMSYmb1tBXS5jaGFyQ29kZUF0KDEpKzE9PT1vW0ErMV0uY2hhckNvZGVBdCgxKTspQSs9MTt2YXIgTD0xK0EtRTtMPDN8fG8uc3BsaWNlKEUsTCxvW0VdKyItIitvW0FdKX1yZXR1cm4gaC51bnNoaWZ0KCJbIitvLmpvaW4oIiIpKyJdIiksbmV3IFJlZ0V4cChoLmpvaW4oInwiKSwiZyIpfXZhciBwPS8oPzpbXHg4MC1cdUQ3RkZcdUUwMDAtXHVGRkZGXXxbXHVEODAwLVx1REJGRl1bXHVEQzAwLVx1REZGRl18W1x1RDgwMC1cdURCRkZdKD8hW1x1REMwMC1cdURGRkZdKXwoPzpbXlx1RDgwMC1cdURCRkZdfF4pW1x1REMwMC1cdURGRkZdKS9nO2Z1bmN0aW9uIHkoTyl7cmV0dXJuIiYjeCIrTy5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSsiOyJ9ZnVuY3Rpb24gUChPLG8pe3JldHVybiBmdW5jdGlvbihoKXtyZXR1cm4gaC5yZXBsYWNlKG8sZnVuY3Rpb24oYyl7cmV0dXJuIE9bY119KS5yZXBsYWNlKHAseSl9fXZhciB4PWQoaSk7ZnVuY3Rpb24gbShPKXtyZXR1cm4gTy5yZXBsYWNlKHgseSkucmVwbGFjZShwLHkpfWUuZXNjYXBlPW19LGZ1bmN0aW9uKHUpe3UuZXhwb3J0cz1KU09OLnBhcnNlKCd7ImVsZW1lbnROYW1lcyI6eyJhbHRnbHlwaCI6ImFsdEdseXBoIiwiYWx0Z2x5cGhkZWYiOiJhbHRHbHlwaERlZiIsImFsdGdseXBoaXRlbSI6ImFsdEdseXBoSXRlbSIsImFuaW1hdGVjb2xvciI6ImFuaW1hdGVDb2xvciIsImFuaW1hdGVtb3Rpb24iOiJhbmltYXRlTW90aW9uIiwiYW5pbWF0ZXRyYW5zZm9ybSI6ImFuaW1hdGVUcmFuc2Zvcm0iLCJjbGlwcGF0aCI6ImNsaXBQYXRoIiwiZmVibGVuZCI6ImZlQmxlbmQiLCJmZWNvbG9ybWF0cml4IjoiZmVDb2xvck1hdHJpeCIsImZlY29tcG9uZW50dHJhbnNmZXIiOiJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVjb21wb3NpdGUiOiJmZUNvbXBvc2l0ZSIsImZlY29udm9sdmVtYXRyaXgiOiJmZUNvbnZvbHZlTWF0cml4IiwiZmVkaWZmdXNlbGlnaHRpbmciOiJmZURpZmZ1c2VMaWdodGluZyIsImZlZGlzcGxhY2VtZW50bWFwIjoiZmVEaXNwbGFjZW1lbnRNYXAiLCJmZWRpc3RhbnRsaWdodCI6ImZlRGlzdGFudExpZ2h0IiwiZmVkcm9wc2hhZG93IjoiZmVEcm9wU2hhZG93IiwiZmVmbG9vZCI6ImZlRmxvb2QiLCJmZWZ1bmNhIjoiZmVGdW5jQSIsImZlZnVuY2IiOiJmZUZ1bmNCIiwiZmVmdW5jZyI6ImZlRnVuY0ciLCJmZWZ1bmNyIjoiZmVGdW5jUiIsImZlZ2F1c3NpYW5ibHVyIjoiZmVHYXVzc2lhbkJsdXIiLCJmZWltYWdlIjoiZmVJbWFnZSIsImZlbWVyZ2UiOiJmZU1lcmdlIiwiZmVtZXJnZW5vZGUiOiJmZU1lcmdlTm9kZSIsImZlbW9ycGhvbG9neSI6ImZlTW9ycGhvbG9neSIsImZlb2Zmc2V0IjoiZmVPZmZzZXQiLCJmZXBvaW50bGlnaHQiOiJmZVBvaW50TGlnaHQiLCJmZXNwZWN1bGFybGlnaHRpbmciOiJmZVNwZWN1bGFyTGlnaHRpbmciLCJmZXNwb3RsaWdodCI6ImZlU3BvdExpZ2h0IiwiZmV0aWxlIjoiZmVUaWxlIiwiZmV0dXJidWxlbmNlIjoiZmVUdXJidWxlbmNlIiwiZm9yZWlnbm9iamVjdCI6ImZvcmVpZ25PYmplY3QiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwibGluZWFyZ3JhZGllbnQiOiJsaW5lYXJHcmFkaWVudCIsInJhZGlhbGdyYWRpZW50IjoicmFkaWFsR3JhZGllbnQiLCJ0ZXh0cGF0aCI6InRleHRQYXRoIn0sImF0dHJpYnV0ZU5hbWVzIjp7ImRlZmluaXRpb251cmwiOiJkZWZpbml0aW9uVVJMIiwiYXR0cmlidXRlbmFtZSI6ImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGV0eXBlIjoiYXR0cmlidXRlVHlwZSIsImJhc2VmcmVxdWVuY3kiOiJiYXNlRnJlcXVlbmN5IiwiYmFzZXByb2ZpbGUiOiJiYXNlUHJvZmlsZSIsImNhbGNtb2RlIjoiY2FsY01vZGUiLCJjbGlwcGF0aHVuaXRzIjoiY2xpcFBhdGhVbml0cyIsImRpZmZ1c2Vjb25zdGFudCI6ImRpZmZ1c2VDb25zdGFudCIsImVkZ2Vtb2RlIjoiZWRnZU1vZGUiLCJmaWx0ZXJ1bml0cyI6ImZpbHRlclVuaXRzIiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImdyYWRpZW50dHJhbnNmb3JtIjoiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIjoiZ3JhZGllbnRVbml0cyIsImtlcm5lbG1hdHJpeCI6Imtlcm5lbE1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiOiJrZXJuZWxVbml0TGVuZ3RoIiwia2V5cG9pbnRzIjoia2V5UG9pbnRzIiwia2V5c3BsaW5lcyI6ImtleVNwbGluZXMiLCJrZXl0aW1lcyI6ImtleVRpbWVzIiwibGVuZ3RoYWRqdXN0IjoibGVuZ3RoQWRqdXN0IiwibGltaXRpbmdjb25lYW5nbGUiOiJsaW1pdGluZ0NvbmVBbmdsZSIsIm1hcmtlcmhlaWdodCI6Im1hcmtlckhlaWdodCIsIm1hcmtlcnVuaXRzIjoibWFya2VyVW5pdHMiLCJtYXJrZXJ3aWR0aCI6Im1hcmtlcldpZHRoIiwibWFza2NvbnRlbnR1bml0cyI6Im1hc2tDb250ZW50VW5pdHMiLCJtYXNrdW5pdHMiOiJtYXNrVW5pdHMiLCJudW1vY3RhdmVzIjoibnVtT2N0YXZlcyIsInBhdGhsZW5ndGgiOiJwYXRoTGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyI6InBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIjoicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm51bml0cyI6InBhdHRlcm5Vbml0cyIsInBvaW50c2F0eCI6InBvaW50c0F0WCIsInBvaW50c2F0eSI6InBvaW50c0F0WSIsInBvaW50c2F0eiI6InBvaW50c0F0WiIsInByZXNlcnZlYWxwaGEiOiJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyI6InByZXNlcnZlQXNwZWN0UmF0aW8iLCJwcmltaXRpdmV1bml0cyI6InByaW1pdGl2ZVVuaXRzIiwicmVmeCI6InJlZlgiLCJyZWZ5IjoicmVmWSIsInJlcGVhdGNvdW50IjoicmVwZWF0Q291bnQiLCJyZXBlYXRkdXIiOiJyZXBlYXREdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiOiJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIjoicmVxdWlyZWRGZWF0dXJlcyIsInNwZWN1bGFyY29uc3RhbnQiOiJzcGVjdWxhckNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCI6InNwZWN1bGFyRXhwb25lbnQiLCJzcHJlYWRtZXRob2QiOiJzcHJlYWRNZXRob2QiLCJzdGFydG9mZnNldCI6InN0YXJ0T2Zmc2V0Iiwic3RkZGV2aWF0aW9uIjoic3RkRGV2aWF0aW9uIiwic3RpdGNodGlsZXMiOiJzdGl0Y2hUaWxlcyIsInN1cmZhY2VzY2FsZSI6InN1cmZhY2VTY2FsZSIsInN5c3RlbWxhbmd1YWdlIjoic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyI6InRhYmxlVmFsdWVzIiwidGFyZ2V0eCI6InRhcmdldFgiLCJ0YXJnZXR5IjoidGFyZ2V0WSIsInRleHRsZW5ndGgiOiJ0ZXh0TGVuZ3RoIiwidmlld2JveCI6InZpZXdCb3giLCJ2aWV3dGFyZ2V0Ijoidmlld1RhcmdldCIsInhjaGFubmVsc2VsZWN0b3IiOiJ4Q2hhbm5lbFNlbGVjdG9yIiwieWNoYW5uZWxzZWxlY3RvciI6InlDaGFubmVsU2VsZWN0b3IiLCJ6b29tYW5kcGFuIjoiem9vbUFuZFBhbiJ9fScpfSxmdW5jdGlvbih1LGUpe3ZhciB0PWUuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24obil7cmV0dXJuIG4uY2hpbGRyZW59LHI9ZS5nZXRQYXJlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIG4ucGFyZW50fTtlLmdldFNpYmxpbmdzPWZ1bmN0aW9uKG4pe3ZhciBpPXIobik7cmV0dXJuIGk/dChpKTpbbl19LGUuZ2V0QXR0cmlidXRlVmFsdWU9ZnVuY3Rpb24obixpKXtyZXR1cm4gbi5hdHRyaWJzJiZuLmF0dHJpYnNbaV19LGUuaGFzQXR0cmliPWZ1bmN0aW9uKG4saSl7cmV0dXJuISFuLmF0dHJpYnMmJmhhc093blByb3BlcnR5LmNhbGwobi5hdHRyaWJzLGkpfSxlLmdldE5hbWU9ZnVuY3Rpb24obil7cmV0dXJuIG4ubmFtZX19LGZ1bmN0aW9uKHUsZSl7ZS5yZW1vdmVFbGVtZW50PWZ1bmN0aW9uKHQpe2lmKHQucHJldiYmKHQucHJldi5uZXh0PXQubmV4dCksdC5uZXh0JiYodC5uZXh0LnByZXY9dC5wcmV2KSx0LnBhcmVudCl7dmFyIHI9dC5wYXJlbnQuY2hpbGRyZW47ci5zcGxpY2Uoci5sYXN0SW5kZXhPZih0KSwxKX19LGUucmVwbGFjZUVsZW1lbnQ9ZnVuY3Rpb24odCxyKXt2YXIgbj1yLnByZXY9dC5wcmV2O24mJihuLm5leHQ9cik7dmFyIGk9ci5uZXh0PXQubmV4dDtpJiYoaS5wcmV2PXIpO3ZhciBhPXIucGFyZW50PXQucGFyZW50O2lmKGEpe3ZhciBsPWEuY2hpbGRyZW47bFtsLmxhc3RJbmRleE9mKHQpXT1yfX0sZS5hcHBlbmRDaGlsZD1mdW5jdGlvbih0LHIpe2lmKHIucGFyZW50PXQsdC5jaGlsZHJlbi5wdXNoKHIpIT09MSl7dmFyIG49dC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aC0yXTtuLm5leHQ9cixyLnByZXY9bixyLm5leHQ9bnVsbH19LGUuYXBwZW5kPWZ1bmN0aW9uKHQscil7dmFyIG49dC5wYXJlbnQsaT10Lm5leHQ7aWYoci5uZXh0PWksci5wcmV2PXQsdC5uZXh0PXIsci5wYXJlbnQ9bixpKXtpZihpLnByZXY9cixuKXt2YXIgYT1uLmNoaWxkcmVuO2Euc3BsaWNlKGEubGFzdEluZGV4T2YoaSksMCxyKX19ZWxzZSBuJiZuLmNoaWxkcmVuLnB1c2gocil9LGUucHJlcGVuZD1mdW5jdGlvbih0LHIpe3ZhciBuPXQucGFyZW50O2lmKG4pe3ZhciBpPW4uY2hpbGRyZW47aS5zcGxpY2UoaS5sYXN0SW5kZXhPZih0KSwwLHIpfXQucHJldiYmKHQucHJldi5uZXh0PXIpLHIucGFyZW50PW4sci5wcmV2PXQucHJldixyLm5leHQ9dCx0LnByZXY9cn19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDI1NikuaXNUYWc7dS5leHBvcnRzPXtmaWx0ZXI6bixmaW5kOmksZmluZE9uZUNoaWxkOmEsZmluZE9uZTpsLGV4aXN0c09uZTpzLGZpbmRBbGw6Zn07ZnVuY3Rpb24gbih2LGQscCx5KXtyZXR1cm4gQXJyYXkuaXNBcnJheShkKXx8KGQ9W2RdKSwodHlwZW9mIHkhPSJudW1iZXIifHwhaXNGaW5pdGUoeSkpJiYoeT0xLzApLGkodixkLHAhPT0hMSx5KX1mdW5jdGlvbiBpKHYsZCxwLHkpe2Zvcih2YXIgUD1bXSx4LG09MCxPPWQubGVuZ3RoO208TyYmISh2KGRbbV0pJiYoUC5wdXNoKGRbbV0pLC0teTw9MCl8fCh4PWRbbV0uY2hpbGRyZW4scCYmeCYmeC5sZW5ndGg+MCYmKHg9aSh2LHgscCx5KSxQPVAuY29uY2F0KHgpLHktPXgubGVuZ3RoLHk8PTApKSk7bSsrKTtyZXR1cm4gUH1mdW5jdGlvbiBhKHYsZCl7Zm9yKHZhciBwPTAseT1kLmxlbmd0aDtwPHk7cCsrKWlmKHYoZFtwXSkpcmV0dXJuIGRbcF07cmV0dXJuIG51bGx9ZnVuY3Rpb24gbCh2LGQpe2Zvcih2YXIgcD1udWxsLHk9MCxQPWQubGVuZ3RoO3k8UCYmIXA7eSsrKWlmKHIoZFt5XSkpdihkW3ldKT9wPWRbeV06ZFt5XS5jaGlsZHJlbi5sZW5ndGg+MCYmKHA9bCh2LGRbeV0uY2hpbGRyZW4pKTtlbHNlIGNvbnRpbnVlO3JldHVybiBwfWZ1bmN0aW9uIHModixkKXtmb3IodmFyIHA9MCx5PWQubGVuZ3RoO3A8eTtwKyspaWYocihkW3BdKSYmKHYoZFtwXSl8fGRbcF0uY2hpbGRyZW4ubGVuZ3RoPjAmJnModixkW3BdLmNoaWxkcmVuKSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZih2LGQpe2Zvcih2YXIgcD1bXSx5PWQuc2xpY2UoKTt5Lmxlbmd0aDspe3ZhciBQPXkuc2hpZnQoKTtyKFApJiYoUC5jaGlsZHJlbiYmUC5jaGlsZHJlbi5sZW5ndGg+MCYmeS51bnNoaWZ0LmFwcGx5KHksUC5jaGlsZHJlbiksdihQKSYmcC5wdXNoKFApKX1yZXR1cm4gcH19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDI1Niksbj1lLmlzVGFnPXIuaXNUYWc7ZS50ZXN0RWxlbWVudD1mdW5jdGlvbihzLGYpe2Zvcih2YXIgdiBpbiBzKWlmKHMuaGFzT3duUHJvcGVydHkodikpe2lmKHY9PT0idGFnX25hbWUiKXtpZighbihmKXx8IXMudGFnX25hbWUoZi5uYW1lKSlyZXR1cm4hMX1lbHNlIGlmKHY9PT0idGFnX3R5cGUiKXtpZighcy50YWdfdHlwZShmLnR5cGUpKXJldHVybiExfWVsc2UgaWYodj09PSJ0YWdfY29udGFpbnMiKXtpZihuKGYpfHwhcy50YWdfY29udGFpbnMoZi5kYXRhKSlyZXR1cm4hMX1lbHNlIGlmKCFmLmF0dHJpYnN8fCFzW3ZdKGYuYXR0cmlic1t2XSkpcmV0dXJuITF9cmV0dXJuITB9O3ZhciBpPXt0YWdfbmFtZTpmdW5jdGlvbihzKXtyZXR1cm4gdHlwZW9mIHM9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oZil7cmV0dXJuIG4oZikmJnMoZi5uYW1lKX06cz09PSIqIj9uOmZ1bmN0aW9uKGYpe3JldHVybiBuKGYpJiZmLm5hbWU9PT1zfX0sdGFnX3R5cGU6ZnVuY3Rpb24ocyl7cmV0dXJuIHR5cGVvZiBzPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGYpe3JldHVybiBzKGYudHlwZSl9OmZ1bmN0aW9uKGYpe3JldHVybiBmLnR5cGU9PT1zfX0sdGFnX2NvbnRhaW5zOmZ1bmN0aW9uKHMpe3JldHVybiB0eXBlb2Ygcz09ImZ1bmN0aW9uIj9mdW5jdGlvbihmKXtyZXR1cm4hbihmKSYmcyhmLmRhdGEpfTpmdW5jdGlvbihmKXtyZXR1cm4hbihmKSYmZi5kYXRhPT09c319fTtmdW5jdGlvbiBhKHMsZil7cmV0dXJuIHR5cGVvZiBmPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKHYpe3JldHVybiB2LmF0dHJpYnMmJmYodi5hdHRyaWJzW3NdKX06ZnVuY3Rpb24odil7cmV0dXJuIHYuYXR0cmlicyYmdi5hdHRyaWJzW3NdPT09Zn19ZnVuY3Rpb24gbChzLGYpe3JldHVybiBmdW5jdGlvbih2KXtyZXR1cm4gcyh2KXx8Zih2KX19ZS5nZXRFbGVtZW50cz1mdW5jdGlvbihzLGYsdixkKXt2YXIgcD1PYmplY3Qua2V5cyhzKS5tYXAoZnVuY3Rpb24oeSl7dmFyIFA9c1t5XTtyZXR1cm4geSBpbiBpP2lbeV0oUCk6YSh5LFApfSk7cmV0dXJuIHAubGVuZ3RoPT09MD9bXTp0aGlzLmZpbHRlcihwLnJlZHVjZShsKSxmLHYsZCl9LGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24ocyxmLHYpe3JldHVybiBBcnJheS5pc0FycmF5KGYpfHwoZj1bZl0pLHRoaXMuZmluZE9uZShhKCJpZCIscyksZix2IT09ITEpfSxlLmdldEVsZW1lbnRzQnlUYWdOYW1lPWZ1bmN0aW9uKHMsZix2LGQpe3JldHVybiB0aGlzLmZpbHRlcihpLnRhZ19uYW1lKHMpLGYsdixkKX0sZS5nZXRFbGVtZW50c0J5VGFnVHlwZT1mdW5jdGlvbihzLGYsdixkKXtyZXR1cm4gdGhpcy5maWx0ZXIoaS50YWdfdHlwZShzKSxmLHYsZCl9fSxmdW5jdGlvbih1LGUpe2UucmVtb3ZlU3Vic2V0cz1mdW5jdGlvbihuKXtmb3IodmFyIGk9bi5sZW5ndGgsYSxsLHM7LS1pPi0xOyl7Zm9yKGE9bD1uW2ldLG5baV09bnVsbCxzPSEwO2w7KXtpZihuLmluZGV4T2YobCk+LTEpe3M9ITEsbi5zcGxpY2UoaSwxKTticmVha31sPWwucGFyZW50fXMmJihuW2ldPWEpfXJldHVybiBufTt2YXIgdD17RElTQ09OTkVDVEVEOjEsUFJFQ0VESU5HOjIsRk9MTE9XSU5HOjQsQ09OVEFJTlM6OCxDT05UQUlORURfQlk6MTZ9LHI9ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj1mdW5jdGlvbihuLGkpe3ZhciBhPVtdLGw9W10scyxmLHYsZCxwLHk7aWYobj09PWkpcmV0dXJuIDA7Zm9yKHM9bjtzOylhLnVuc2hpZnQocykscz1zLnBhcmVudDtmb3Iocz1pO3M7KWwudW5zaGlmdChzKSxzPXMucGFyZW50O2Zvcih5PTA7YVt5XT09PWxbeV07KXkrKztyZXR1cm4geT09PTA/dC5ESVNDT05ORUNURUQ6KGY9YVt5LTFdLHY9Zi5jaGlsZHJlbixkPWFbeV0scD1sW3ldLHYuaW5kZXhPZihkKT52LmluZGV4T2YocCk/Zj09PWk/dC5GT0xMT1dJTkd8dC5DT05UQUlORURfQlk6dC5GT0xMT1dJTkc6Zj09PW4/dC5QUkVDRURJTkd8dC5DT05UQUlOUzp0LlBSRUNFRElORyl9O2UudW5pcXVlU29ydD1mdW5jdGlvbihuKXt2YXIgaT1uLmxlbmd0aCxhLGw7Zm9yKG49bi5zbGljZSgpOy0taT4tMTspYT1uW2ldLGw9bi5pbmRleE9mKGEpLGw+LTEmJmw8aSYmbi5zcGxpY2UoaSwxKTtyZXR1cm4gbi5zb3J0KGZ1bmN0aW9uKHMsZil7dmFyIHY9cihzLGYpO3JldHVybiB2JnQuUFJFQ0VESU5HPy0xOnYmdC5GT0xMT1dJTkc/MTowfSksbn19LGZ1bmN0aW9uKHUsZSl7dS5leHBvcnRzPXt0cnVlRnVuYzpmdW5jdGlvbigpe3JldHVybiEwfSxmYWxzZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMX19fSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXA7dmFyIHI9dCgyNzUpLnBhcnNlLG49dCgyNzMpLGk9dCgyNzgpLGE9dCgyNzkpLGw9dCgyODApLHM9dCgyODIpLGY9bi50cnVlRnVuYyx2PW4uZmFsc2VGdW5jLGQ9cy5maWx0ZXJzO2Z1bmN0aW9uIHAoTSxJLEQpe3ZhciBSPVAoTSxJLEQpO3JldHVybiB5KFIsSSl9ZnVuY3Rpb24geShNLEkpe3ZhciBEPUkuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oQyl7cmV0dXJuIEQuaXNUYWcoQykmJk0oQyl9fWZ1bmN0aW9uIFAoTSxJLEQpe3ZhciBSPXIoTSxJKTtyZXR1cm4gZyhSLEksRCl9ZnVuY3Rpb24geChNKXtyZXR1cm4gTS50eXBlPT09InBzZXVkbyImJihNLm5hbWU9PT0ic2NvcGUifHxBcnJheS5pc0FycmF5KE0uZGF0YSkmJk0uZGF0YS5zb21lKGZ1bmN0aW9uKEkpe3JldHVybiBJLnNvbWUoeCl9KSl9dmFyIG09e3R5cGU6ImRlc2NlbmRhbnQifSxPPXt0eXBlOiJfZmxleGlibGVEZXNjZW5kYW50In0sbz17dHlwZToicHNldWRvIixuYW1lOiJzY29wZSJ9LGg9e307ZnVuY3Rpb24gYyhNLEksRCl7dmFyIFI9SS5hZGFwdGVyLEM9ISFEJiYhIUQubGVuZ3RoJiZELmV2ZXJ5KGZ1bmN0aW9uKEIpe3JldHVybiBCPT09aHx8ISFSLmdldFBhcmVudChCKX0pO00uZm9yRWFjaChmdW5jdGlvbihCKXtpZighKEIubGVuZ3RoPjAmJmIoQlswXSkmJkJbMF0udHlwZSE9PSJkZXNjZW5kYW50IikpaWYoQyYmIShBcnJheS5pc0FycmF5KEIpP0Iuc29tZSh4KTp4KEIpKSlCLnVuc2hpZnQobSk7ZWxzZSByZXR1cm47Qi51bnNoaWZ0KG8pfSl9ZnVuY3Rpb24gZyhNLEksRCl7TT1NLmZpbHRlcihmdW5jdGlvbih6KXtyZXR1cm4gei5sZW5ndGg+MH0pLE0uZm9yRWFjaChpKTt2YXIgUj1BcnJheS5pc0FycmF5KEQpO0Q9SSYmSS5jb250ZXh0fHxELEQmJiFSJiYoRD1bRF0pLGMoTSxJLEQpO3ZhciBDPSExLEI9TS5tYXAoZnVuY3Rpb24oeil7aWYoelswXSYmelsxXSYmelswXS5uYW1lPT09InNjb3BlIil7dmFyIEs9elsxXS50eXBlO1ImJks9PT0iZGVzY2VuZGFudCI/elsxXT1POihLPT09ImFkamFjZW50Inx8Sz09PSJzaWJsaW5nIikmJihDPSEwKX1yZXR1cm4gRSh6LEksRCl9KS5yZWR1Y2UoQSx2KTtyZXR1cm4gQi5zaG91bGRUZXN0TmV4dFNpYmxpbmdzPUMsQn1mdW5jdGlvbiBiKE0pe3JldHVybiBhW00udHlwZV08MH1mdW5jdGlvbiBFKE0sSSxEKXtyZXR1cm4gTS5yZWR1Y2UoZnVuY3Rpb24oUixDKXtpZihSPT09dilyZXR1cm4gUjtpZighKEMudHlwZSBpbiBsKSl0aHJvdyBuZXcgRXJyb3IoIlJ1bGUgdHlwZSAiK0MudHlwZSsiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgY3NzLXNlbGVjdCIpO3JldHVybiBsW0MudHlwZV0oUixDLEksRCl9LEkmJkkucm9vdEZ1bmN8fGYpfWZ1bmN0aW9uIEEoTSxJKXtyZXR1cm4gST09PXZ8fE09PT1mP006TT09PXZ8fEk9PT1mP0k6ZnVuY3Rpb24oUil7cmV0dXJuIE0oUil8fEkoUil9fWZ1bmN0aW9uIEwoTSl7cmV0dXJuIE0uc29tZShiKX1kLm5vdD1mdW5jdGlvbihNLEksRCxSKXt2YXIgQz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCksYWRhcHRlcjpELmFkYXB0ZXJ9O2lmKEMuc3RyaWN0JiYoSS5sZW5ndGg+MXx8SS5zb21lKEwpKSl0aHJvdyBuZXcgRXJyb3IoImNvbXBsZXggc2VsZWN0b3JzIGluIDpub3QgYXJlbid0IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUiKTt2YXIgQj1nKEksQyxSKTtyZXR1cm4gQj09PXY/TTpCPT09Zj92OmZ1bmN0aW9uKEspe3JldHVybiFCKEspJiZNKEspfX0sZC5oYXM9ZnVuY3Rpb24oTSxJLEQpe3ZhciBSPUQuYWRhcHRlcixDPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxhZGFwdGVyOlJ9LEI9SS5zb21lKEwpP1toXTpudWxsLHo9ZyhJLEMsQik7cmV0dXJuIHo9PT12P3Y6ej09PWY/ZnVuY3Rpb24oUSl7cmV0dXJuIFIuZ2V0Q2hpbGRyZW4oUSkuc29tZShSLmlzVGFnKSYmTShRKX06KHo9eSh6LEQpLEI/ZnVuY3Rpb24oUSl7cmV0dXJuIE0oUSkmJihCWzBdPVEsUi5leGlzdHNPbmUoeixSLmdldENoaWxkcmVuKFEpKSl9OmZ1bmN0aW9uKFEpe3JldHVybiBNKFEpJiZSLmV4aXN0c09uZSh6LFIuZ2V0Q2hpbGRyZW4oUSkpfSl9LGQubWF0Y2hlcz1mdW5jdGlvbihNLEksRCxSKXt2YXIgQz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCkscm9vdEZ1bmM6TSxhZGFwdGVyOkQuYWRhcHRlcn07cmV0dXJuIGcoSSxDLFIpfSxwLmNvbXBpbGVUb2tlbj1nLHAuY29tcGlsZVVuc2FmZT1QLHAuUHNldWRvcz1zfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGwscyxmLHYpe3Y9PT12b2lkIDAmJih2PWYpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHYse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHNbZl19fSl9OmZ1bmN0aW9uKGwscyxmLHYpe3Y9PT12b2lkIDAmJih2PWYpLGxbdl09c1tmXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGwscyl7Zm9yKHZhciBmIGluIGwpZiE9PSJkZWZhdWx0IiYmIXMuaGFzT3duUHJvcGVydHkoZikmJnIocyxsLGYpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksbih0KDI3NiksZSk7dmFyIGk9dCgyNzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJwYXJzZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdH19KTt2YXIgYT10KDI3Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInN0cmluZ2lmeSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH19KX0sZnVuY3Rpb24odSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9eDt2YXIgcj0vXlteXFxdPyg/OlxcKD86W1xkYS1mXXsxLDZ9XHM/fC4pfFtcd1wtXHUwMGIwLVx1RkZGRl0pKy8sbj0vXFwoW1xkYS1mXXsxLDZ9XHM/fChccyl8LikvZ2ksaT0vXlxzKigoPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSspXHMqKD86KFxTPyk9XHMqKD86KFsnIl0pKFteXSo/KVwzfCgjPyg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKil8KXwpXHMqKGkpP1xdLyxhPXt1bmRlZmluZWQ6ImV4aXN0cyIsIiI6ImVxdWFscyIsIn4iOiJlbGVtZW50IiwiXiI6InN0YXJ0IiwkOiJlbmQiLCIqIjoiYW55IiwiISI6Im5vdCIsInwiOiJoeXBoZW4ifSxsPXsiPiI6ImNoaWxkIiwiPCI6InBhcmVudCIsIn4iOiJzaWJsaW5nIiwiKyI6ImFkamFjZW50In0scz17IiMiOlsiaWQiLCJlcXVhbHMiXSwiLiI6WyJjbGFzcyIsImVsZW1lbnQiXX0sZj1uZXcgU2V0KFsiaGFzIiwibm90IiwibWF0Y2hlcyJdKSx2PW5ldyBTZXQoWyJjb250YWlucyIsImljb250YWlucyJdKSxkPW5ldyBTZXQoWyciJywiJyJdKTtmdW5jdGlvbiBwKG8saCxjKXt2YXIgZz1wYXJzZUludChoLDE2KS02NTUzNjtyZXR1cm4gZyE9PWd8fGM/aDpnPDA/U3RyaW5nLmZyb21DaGFyQ29kZShnKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKGc+PjEwfDU1Mjk2LGcmMTAyM3w1NjMyMCl9ZnVuY3Rpb24geShvKXtyZXR1cm4gby5yZXBsYWNlKG4scCl9ZnVuY3Rpb24gUChvKXtyZXR1cm4gbz09PSIgInx8bz09PWAKYHx8bz09PSIJInx8bz09PSJcZiJ8fG89PT0iXHIifWZ1bmN0aW9uIHgobyxoKXt2YXIgYz1bXTtpZihvPW0oYywiIitvLGgpLG8hPT0iIil0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBzZWxlY3RvcjogIitvKTtyZXR1cm4gY31mdW5jdGlvbiBtKG8saCxjKXt2YXIgZz1bXSxiPSExO2Z1bmN0aW9uIEUoKXt2YXIgWD1oLm1hdGNoKHIpO2lmKCFYKXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbmFtZSwgZm91bmQgIitoKTt2YXIgWj1YWzBdO3JldHVybiBoPWguc3Vic3RyKFoubGVuZ3RoKSx5KFopfWZ1bmN0aW9uIEEoWCl7Zm9yKDtQKGguY2hhckF0KFgpKTspWCsrO2g9aC5zdWJzdHIoWCl9ZnVuY3Rpb24gTChYKXtmb3IodmFyIFo9MDtoLmNoYXJBdCgtLVgpPT09IlxcIjspWisrO3JldHVybihaJjEpPT09MX1mb3IoQSgwKTtoIT09IiI7KXt2YXIgTT1oLmNoYXJBdCgwKTtpZihQKE0pKWI9ITAsQSgxKTtlbHNlIGlmKE0gaW4gbClnLnB1c2goe3R5cGU6bFtNXX0pLGI9ITEsQSgxKTtlbHNlIGlmKE09PT0iLCIpe2lmKGcubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO28ucHVzaChnKSxnPVtdLGI9ITEsQSgxKX1lbHNlIGlmKGImJihnLmxlbmd0aD4wJiZnLnB1c2goe3R5cGU6ImRlc2NlbmRhbnQifSksYj0hMSksTT09PSIqIiloPWguc3Vic3RyKDEpLGcucHVzaCh7dHlwZToidW5pdmVyc2FsIn0pO2Vsc2UgaWYoTSBpbiBzKXt2YXIgST1zW01dLEQ9SVswXSxSPUlbMV07aD1oLnN1YnN0cigxKSxnLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpELGFjdGlvbjpSLHZhbHVlOkUoKSxpZ25vcmVDYXNlOiExfSl9ZWxzZSBpZihNPT09IlsiKXtoPWguc3Vic3RyKDEpO3ZhciBDPWgubWF0Y2goaSk7aWYoIUMpdGhyb3cgbmV3IEVycm9yKCJNYWxmb3JtZWQgYXR0cmlidXRlIHNlbGVjdG9yOiAiK2gpO2g9aC5zdWJzdHIoQ1swXS5sZW5ndGgpO3ZhciBCPXkoQ1sxXSk7KCFjfHwoImxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzImluIGM/Yy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lczohYy54bWxNb2RlKSkmJihCPUIudG9Mb3dlckNhc2UoKSksZy5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6QixhY3Rpb246YVtDWzJdXSx2YWx1ZTp5KENbNF18fENbNV18fCIiKSxpZ25vcmVDYXNlOiEhQ1s2XX0pfWVsc2UgaWYoTT09PSI6Iil7aWYoaC5jaGFyQXQoMSk9PT0iOiIpe2g9aC5zdWJzdHIoMiksZy5wdXNoKHt0eXBlOiJwc2V1ZG8tZWxlbWVudCIsbmFtZTpFKCkudG9Mb3dlckNhc2UoKX0pO2NvbnRpbnVlfWg9aC5zdWJzdHIoMSk7dmFyIHo9RSgpLnRvTG93ZXJDYXNlKCksQz1udWxsO2lmKGguY2hhckF0KDApPT09IigiKWlmKGYuaGFzKHopKXt2YXIgSz1oLmNoYXJBdCgxKSxRPWQuaGFzKEspO2lmKGg9aC5zdWJzdHIoUT8yOjEpLEM9W10saD1tKEMsaCxjKSxRKXtpZihoLmNoYXJBdCgwKSE9PUspdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgcXVvdGVzIGluIDoiK3opO2g9aC5zdWJzdHIoMSl9aWYoaC5jaGFyQXQoMCkhPT0iKSIpdGhyb3cgbmV3IEVycm9yKCJNaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMgaW4gOiIreisiICgiK2grIikiKTtoPWguc3Vic3RyKDEpfWVsc2V7Zm9yKHZhciBfPTEsRj0xO0Y+MCYmXzxoLmxlbmd0aDtfKyspaC5jaGFyQXQoXyk9PT0iKCImJiFMKF8pP0YrKzpoLmNoYXJBdChfKT09PSIpIiYmIUwoXykmJkYtLTtpZihGKXRocm93IG5ldyBFcnJvcigiUGFyZW50aGVzaXMgbm90IG1hdGNoZWQiKTtpZihDPWguc3Vic3RyKDEsXy0yKSxoPWguc3Vic3RyKF8pLHYuaGFzKHopKXt2YXIgSz1DLmNoYXJBdCgwKTtLPT09Qy5zbGljZSgtMSkmJmQuaGFzKEspJiYoQz1DLnNsaWNlKDEsLTEpKSxDPXkoQyl9fWcucHVzaCh7dHlwZToicHNldWRvIixuYW1lOnosZGF0YTpDfSl9ZWxzZSBpZihyLnRlc3QoaCkpe3ZhciBHPUUoKTsoIWN8fCgibG93ZXJDYXNlVGFncyJpbiBjP2MubG93ZXJDYXNlVGFnczohYy54bWxNb2RlKSkmJihHPUcudG9Mb3dlckNhc2UoKSksZy5wdXNoKHt0eXBlOiJ0YWciLG5hbWU6R30pfWVsc2UgcmV0dXJuIGcubGVuZ3RoJiZnW2cubGVuZ3RoLTFdLnR5cGU9PT0iZGVzY2VuZGFudCImJmcucG9wKCksTyhvLGcpLGh9cmV0dXJuIE8obyxnKSxofWZ1bmN0aW9uIE8obyxoKXtpZihvLmxlbmd0aD4wJiZoLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtvLnB1c2goaCl9fSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXtlcXVhbHM6IiIsZWxlbWVudDoifiIsc3RhcnQ6Il4iLGVuZDoiJCIsYW55OiIqIixub3Q6IiEiLGh5cGhlbjoifCJ9O2Z1bmN0aW9uIG4ocyl7cmV0dXJuIHMubWFwKGkpLmpvaW4oIiwgIil9ZS5kZWZhdWx0PW47ZnVuY3Rpb24gaShzKXtyZXR1cm4gcy5tYXAoYSkuam9pbigiIil9ZnVuY3Rpb24gYShzKXtzd2l0Y2gocy50eXBlKXtjYXNlImNoaWxkIjpyZXR1cm4iID4gIjtjYXNlInBhcmVudCI6cmV0dXJuIiA8ICI7Y2FzZSJzaWJsaW5nIjpyZXR1cm4iIH4gIjtjYXNlImFkamFjZW50IjpyZXR1cm4iICsgIjtjYXNlImRlc2NlbmRhbnQiOnJldHVybiIgIjtjYXNlInVuaXZlcnNhbCI6cmV0dXJuIioiO2Nhc2UidGFnIjpyZXR1cm4gcy5uYW1lO2Nhc2UicHNldWRvLWVsZW1lbnQiOnJldHVybiI6OiIrcy5uYW1lO2Nhc2UicHNldWRvIjpyZXR1cm4gcy5kYXRhPT09bnVsbD8iOiIrcy5uYW1lOnR5cGVvZiBzLmRhdGE9PSJzdHJpbmciPyI6IitzLm5hbWUrIigiK3MuZGF0YSsiKSI6IjoiK3MubmFtZSsiKCIrbihzLmRhdGEpKyIpIjtjYXNlImF0dHJpYnV0ZSI6cmV0dXJuIHMuYWN0aW9uPT09ImV4aXN0cyI/IlsiK3MubmFtZSsiXSI6cy5uYW1lPT09ImlkIiYmcy5hY3Rpb249PT0iZXF1YWxzIiYmIXMuaWdub3JlQ2FzZT8iIyIrcy52YWx1ZTpzLm5hbWU9PT0iY2xhc3MiJiZzLmFjdGlvbj09PSJlbGVtZW50IiYmIXMuaWdub3JlQ2FzZT8iLiIrcy52YWx1ZToiWyIrcy5uYW1lK3Jbcy5hY3Rpb25dKyI9JyIrcy52YWx1ZSsiJyIrKHMuaWdub3JlQ2FzZT8iaSI6IiIpKyJdIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5rbm93biB0eXBlIil9fWZ1bmN0aW9uIGwocyl7cmV0dXJuIHN9fSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPWk7dmFyIHI9dCgyNzkpLG49e19fcHJvdG9fXzpudWxsLGV4aXN0czoxMCxlcXVhbHM6OCxub3Q6NyxzdGFydDo2LGVuZDo2LGFueTo1LGh5cGhlbjo0LGVsZW1lbnQ6NH07ZnVuY3Rpb24gaShsKXtmb3IodmFyIHM9bC5tYXAoYSksZj0xO2Y8bC5sZW5ndGg7ZisrKXt2YXIgdj1zW2ZdO2lmKCEodjwwKSlmb3IodmFyIGQ9Zi0xO2Q+PTAmJnY8c1tkXTtkLS0pe3ZhciBwPWxbZCsxXTtsW2QrMV09bFtkXSxsW2RdPXAsc1tkKzFdPXNbZF0sc1tkXT12fX19ZnVuY3Rpb24gYShsKXt2YXIgcz1yW2wudHlwZV07aWYocz09PXIuYXR0cmlidXRlKXM9bltsLmFjdGlvbl0scz09PW4uZXF1YWxzJiZsLm5hbWU9PT0iaWQiJiYocz05KSxsLmlnbm9yZUNhc2UmJihzPj49MSk7ZWxzZSBpZihzPT09ci5wc2V1ZG8paWYoIWwuZGF0YSlzPTM7ZWxzZSBpZihsLm5hbWU9PT0iaGFzInx8bC5uYW1lPT09ImNvbnRhaW5zIilzPTA7ZWxzZSBpZihsLm5hbWU9PT0ibWF0Y2hlcyJ8fGwubmFtZT09PSJub3QiKXtzPTA7Zm9yKHZhciBmPTA7ZjxsLmRhdGEubGVuZ3RoO2YrKylpZihsLmRhdGFbZl0ubGVuZ3RoPT09MSl7dmFyIHY9YShsLmRhdGFbZl1bMF0pO2lmKHY9PT0wKXtzPTA7YnJlYWt9dj5zJiYocz12KX1sLmRhdGEubGVuZ3RoPjEmJnM+MCYmKHMtPTEpfWVsc2Ugcz0xO3JldHVybiBzfX0sZnVuY3Rpb24odSl7dS5leHBvcnRzPUpTT04ucGFyc2UoJ3sidW5pdmVyc2FsIjo1MCwidGFnIjozMCwiYXR0cmlidXRlIjoxLCJwc2V1ZG8iOjAsImRlc2NlbmRhbnQiOi0xLCJjaGlsZCI6LTEsInBhcmVudCI6LTEsInNpYmxpbmciOi0xLCJhZGphY2VudCI6LTF9Jyl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDI4MSksbj10KDI4Mik7dS5leHBvcnRzPXtfX3Byb3RvX186bnVsbCxhdHRyaWJ1dGU6ci5jb21waWxlLHBzZXVkbzpuLmNvbXBpbGUsdGFnOmZ1bmN0aW9uKGksYSxsKXt2YXIgcz1hLm5hbWUsZj1sLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiBmLmdldE5hbWUoZCk9PT1zJiZpKGQpfX0sZGVzY2VuZGFudDpmdW5jdGlvbihpLGEsbCl7dmFyIHM9dHlwZW9mIFdlYWtTZXQ8InUiP25ldyBXZWFrU2V0Om51bGwsZj1sLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGQpe2Zvcih2YXIgcD0hMTshcCYmKGQ9Zi5nZXRQYXJlbnQoZCkpOykoIXN8fCFzLmhhcyhkKSkmJihwPWkoZCksIXAmJnMmJnMuYWRkKGQpKTtyZXR1cm4gcH19LF9mbGV4aWJsZURlc2NlbmRhbnQ6ZnVuY3Rpb24oaSxhLGwpe3ZhciBzPWwuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24odil7Zm9yKHZhciBkPWkodik7IWQmJih2PXMuZ2V0UGFyZW50KHYpKTspZD1pKHYpO3JldHVybiBkfX0scGFyZW50OmZ1bmN0aW9uKGksYSxsKXtpZihsJiZsLnN0cmljdCl0aHJvdyBuZXcgRXJyb3IoIlBhcmVudCBzZWxlY3RvciBpc24ndCBwYXJ0IG9mIENTUzMiKTt2YXIgcz1sLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiBzLmdldENoaWxkcmVuKGQpLnNvbWUoZil9O2Z1bmN0aW9uIGYodil7cmV0dXJuIHMuaXNUYWcodikmJmkodil9fSxjaGlsZDpmdW5jdGlvbihpLGEsbCl7dmFyIHM9bC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih2KXt2YXIgZD1zLmdldFBhcmVudCh2KTtyZXR1cm4hIWQmJmkoZCl9fSxzaWJsaW5nOmZ1bmN0aW9uKGksYSxsKXt2YXIgcz1sLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHYpe2Zvcih2YXIgZD1zLmdldFNpYmxpbmdzKHYpLHA9MDtwPGQubGVuZ3RoO3ArKylpZihzLmlzVGFnKGRbcF0pKXtpZihkW3BdPT09dilicmVhaztpZihpKGRbcF0pKXJldHVybiEwfXJldHVybiExfX0sYWRqYWNlbnQ6ZnVuY3Rpb24oaSxhLGwpe3ZhciBzPWwuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24odil7Zm9yKHZhciBkPXMuZ2V0U2libGluZ3ModikscCx5PTA7eTxkLmxlbmd0aDt5KyspaWYocy5pc1RhZyhkW3ldKSl7aWYoZFt5XT09PXYpYnJlYWs7cD1kW3ldfXJldHVybiEhcCYmaShwKX19LHVuaXZlcnNhbDpmdW5jdGlvbihpKXtyZXR1cm4gaX19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgyNzMpLmZhbHNlRnVuYyxuPS9bLVtcXXt9KCkqKz8uLFxcXiR8I1xzXS9nLGk9e19fcHJvdG9fXzpudWxsLGVxdWFsczpmdW5jdGlvbihhLGwscyl7dmFyIGY9bC5uYW1lLHY9bC52YWx1ZSxkPXMuYWRhcHRlcjtyZXR1cm4gbC5pZ25vcmVDYXNlPyh2PXYudG9Mb3dlckNhc2UoKSxmdW5jdGlvbih5KXt2YXIgUD1kLmdldEF0dHJpYnV0ZVZhbHVlKHksZik7cmV0dXJuIFAhPW51bGwmJlAudG9Mb3dlckNhc2UoKT09PXYmJmEoeSl9KTpmdW5jdGlvbih5KXtyZXR1cm4gZC5nZXRBdHRyaWJ1dGVWYWx1ZSh5LGYpPT09diYmYSh5KX19LGh5cGhlbjpmdW5jdGlvbihhLGwscyl7dmFyIGY9bC5uYW1lLHY9bC52YWx1ZSxkPXYubGVuZ3RoLHA9cy5hZGFwdGVyO3JldHVybiBsLmlnbm9yZUNhc2U/KHY9di50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKFApe3ZhciB4PXAuZ2V0QXR0cmlidXRlVmFsdWUoUCxmKTtyZXR1cm4geCE9bnVsbCYmKHgubGVuZ3RoPT09ZHx8eC5jaGFyQXQoZCk9PT0iLSIpJiZ4LnN1YnN0cigwLGQpLnRvTG93ZXJDYXNlKCk9PT12JiZhKFApfSk6ZnVuY3Rpb24oUCl7dmFyIHg9cC5nZXRBdHRyaWJ1dGVWYWx1ZShQLGYpO3JldHVybiB4IT1udWxsJiZ4LnN1YnN0cigwLGQpPT09diYmKHgubGVuZ3RoPT09ZHx8eC5jaGFyQXQoZCk9PT0iLSIpJiZhKFApfX0sZWxlbWVudDpmdW5jdGlvbihhLGwscyl7dmFyIGY9bC5uYW1lLHY9bC52YWx1ZSxkPXMuYWRhcHRlcjtpZigvXHMvLnRlc3QodikpcmV0dXJuIHI7dj12LnJlcGxhY2UobiwiXFwkJiIpO3ZhciBwPSIoPzpefFxccykiK3YrIig/OiR8XFxzKSIseT1sLmlnbm9yZUNhc2U/ImkiOiIiLFA9bmV3IFJlZ0V4cChwLHkpO3JldHVybiBmdW5jdGlvbihtKXt2YXIgTz1kLmdldEF0dHJpYnV0ZVZhbHVlKG0sZik7cmV0dXJuIE8hPW51bGwmJlAudGVzdChPKSYmYShtKX19LGV4aXN0czpmdW5jdGlvbihhLGwscyl7dmFyIGY9bC5uYW1lLHY9cy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihwKXtyZXR1cm4gdi5oYXNBdHRyaWIocCxmKSYmYShwKX19LHN0YXJ0OmZ1bmN0aW9uKGEsbCxzKXt2YXIgZj1sLm5hbWUsdj1sLnZhbHVlLGQ9di5sZW5ndGgscD1zLmFkYXB0ZXI7cmV0dXJuIGQ9PT0wP3I6bC5pZ25vcmVDYXNlPyh2PXYudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihQKXt2YXIgeD1wLmdldEF0dHJpYnV0ZVZhbHVlKFAsZik7cmV0dXJuIHghPW51bGwmJnguc3Vic3RyKDAsZCkudG9Mb3dlckNhc2UoKT09PXYmJmEoUCl9KTpmdW5jdGlvbihQKXt2YXIgeD1wLmdldEF0dHJpYnV0ZVZhbHVlKFAsZik7cmV0dXJuIHghPW51bGwmJnguc3Vic3RyKDAsZCk9PT12JiZhKFApfX0sZW5kOmZ1bmN0aW9uKGEsbCxzKXt2YXIgZj1sLm5hbWUsdj1sLnZhbHVlLGQ9LXYubGVuZ3RoLHA9cy5hZGFwdGVyO3JldHVybiBkPT09MD9yOmwuaWdub3JlQ2FzZT8odj12LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oUCl7dmFyIHg9cC5nZXRBdHRyaWJ1dGVWYWx1ZShQLGYpO3JldHVybiB4IT1udWxsJiZ4LnN1YnN0cihkKS50b0xvd2VyQ2FzZSgpPT09diYmYShQKX0pOmZ1bmN0aW9uKFApe3ZhciB4PXAuZ2V0QXR0cmlidXRlVmFsdWUoUCxmKTtyZXR1cm4geCE9bnVsbCYmeC5zdWJzdHIoZCk9PT12JiZhKFApfX0sYW55OmZ1bmN0aW9uKGEsbCxzKXt2YXIgZj1sLm5hbWUsdj1sLnZhbHVlLGQ9cy5hZGFwdGVyO2lmKHY9PT0iIilyZXR1cm4gcjtpZihsLmlnbm9yZUNhc2Upe3ZhciBwPW5ldyBSZWdFeHAodi5yZXBsYWNlKG4sIlxcJCYiKSwiaSIpO3JldHVybiBmdW5jdGlvbihQKXt2YXIgeD1kLmdldEF0dHJpYnV0ZVZhbHVlKFAsZik7cmV0dXJuIHghPW51bGwmJnAudGVzdCh4KSYmYShQKX19cmV0dXJuIGZ1bmN0aW9uKFApe3ZhciB4PWQuZ2V0QXR0cmlidXRlVmFsdWUoUCxmKTtyZXR1cm4geCE9bnVsbCYmeC5pbmRleE9mKHYpPj0wJiZhKFApfX0sbm90OmZ1bmN0aW9uKGEsbCxzKXt2YXIgZj1sLm5hbWUsdj1sLnZhbHVlLGQ9cy5hZGFwdGVyO3JldHVybiB2PT09IiI/ZnVuY3Rpb24oeSl7cmV0dXJuISFkLmdldEF0dHJpYnV0ZVZhbHVlKHksZikmJmEoeSl9OmwuaWdub3JlQ2FzZT8odj12LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oeSl7dmFyIFA9ZC5nZXRBdHRyaWJ1dGVWYWx1ZSh5LGYpO3JldHVybiBQIT1udWxsJiZQLnRvTG93ZXJDYXNlKCkhPT12JiZhKHkpfSk6ZnVuY3Rpb24oeSl7cmV0dXJuIGQuZ2V0QXR0cmlidXRlVmFsdWUoeSxmKSE9PXYmJmEoeSl9fX07dS5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKGEsbCxzKXtpZihzJiZzLnN0cmljdCYmKGwuaWdub3JlQ2FzZXx8bC5hY3Rpb249PT0ibm90IikpdGhyb3cgbmV3IEVycm9yKCJVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgc2VsZWN0b3IiKTtyZXR1cm4gaVtsLmFjdGlvbl0oYSxsLHMpfSxydWxlczppfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMjgzKSxuPXQoMjczKSxpPXQoMjgxKSxhPW4udHJ1ZUZ1bmMsbD1uLmZhbHNlRnVuYyxzPWkucnVsZXMuZXF1YWxzO2Z1bmN0aW9uIGYoTyxvKXt2YXIgaD17bmFtZTpPLHZhbHVlOm99O3JldHVybiBmdW5jdGlvbihnLGIsRSl7cmV0dXJuIHMoZyxoLEUpfX1mdW5jdGlvbiB2KE8sbyl7cmV0dXJuIGZ1bmN0aW9uKGgpe3JldHVybiEhby5nZXRQYXJlbnQoaCkmJk8oaCl9fXZhciBkPXtjb250YWluczpmdW5jdGlvbihPLG8saCl7dmFyIGM9aC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gTyhiKSYmYy5nZXRUZXh0KGIpLmluZGV4T2Yobyk+PTB9fSxpY29udGFpbnM6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPW8udG9Mb3dlckNhc2UoKSxnPWguYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oRSl7cmV0dXJuIE8oRSkmJmcuZ2V0VGV4dChFKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoYyk+PTB9fSwibnRoLWNoaWxkIjpmdW5jdGlvbihPLG8saCl7dmFyIGM9cihvKSxnPWguYWRhcHRlcjtyZXR1cm4gYz09PWw/YzpjPT09YT92KE8sZyk6ZnVuY3Rpb24oRSl7Zm9yKHZhciBBPWcuZ2V0U2libGluZ3MoRSksTD0wLE09MDtMPEEubGVuZ3RoO0wrKylpZihnLmlzVGFnKEFbTF0pKXtpZihBW0xdPT09RSlicmVhaztNKyt9cmV0dXJuIGMoTSkmJk8oRSl9fSwibnRoLWxhc3QtY2hpbGQiOmZ1bmN0aW9uKE8sbyxoKXt2YXIgYz1yKG8pLGc9aC5hZGFwdGVyO3JldHVybiBjPT09bD9jOmM9PT1hP3YoTyxnKTpmdW5jdGlvbihFKXtmb3IodmFyIEE9Zy5nZXRTaWJsaW5ncyhFKSxMPTAsTT1BLmxlbmd0aC0xO00+PTA7TS0tKWlmKGcuaXNUYWcoQVtNXSkpe2lmKEFbTV09PT1FKWJyZWFrO0wrK31yZXR1cm4gYyhMKSYmTyhFKX19LCJudGgtb2YtdHlwZSI6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPXIobyksZz1oLmFkYXB0ZXI7cmV0dXJuIGM9PT1sP2M6Yz09PWE/dihPLGcpOmZ1bmN0aW9uKEUpe2Zvcih2YXIgQT1nLmdldFNpYmxpbmdzKEUpLEw9MCxNPTA7TTxBLmxlbmd0aDtNKyspaWYoZy5pc1RhZyhBW01dKSl7aWYoQVtNXT09PUUpYnJlYWs7Zy5nZXROYW1lKEFbTV0pPT09Zy5nZXROYW1lKEUpJiZMKyt9cmV0dXJuIGMoTCkmJk8oRSl9fSwibnRoLWxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPXIobyksZz1oLmFkYXB0ZXI7cmV0dXJuIGM9PT1sP2M6Yz09PWE/dihPLGcpOmZ1bmN0aW9uKEUpe2Zvcih2YXIgQT1nLmdldFNpYmxpbmdzKEUpLEw9MCxNPUEubGVuZ3RoLTE7TT49MDtNLS0paWYoZy5pc1RhZyhBW01dKSl7aWYoQVtNXT09PUUpYnJlYWs7Zy5nZXROYW1lKEFbTV0pPT09Zy5nZXROYW1lKEUpJiZMKyt9cmV0dXJuIGMoTCkmJk8oRSl9fSxyb290OmZ1bmN0aW9uKE8sbyxoKXt2YXIgYz1oLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiFjLmdldFBhcmVudChnKSYmTyhnKX19LHNjb3BlOmZ1bmN0aW9uKE8sbyxoLGMpe3ZhciBnPWguYWRhcHRlcjtpZighY3x8Yy5sZW5ndGg9PT0wKXJldHVybiBkLnJvb3QoTyxvLGgpO2Z1bmN0aW9uIGIoRSxBKXtyZXR1cm4gdHlwZW9mIGcuZXF1YWxzPT0iZnVuY3Rpb24iP2cuZXF1YWxzKEUsQSk6RT09PUF9cmV0dXJuIGMubGVuZ3RoPT09MT9mdW5jdGlvbihFKXtyZXR1cm4gYihjWzBdLEUpJiZPKEUpfTpmdW5jdGlvbihFKXtyZXR1cm4gYy5pbmRleE9mKEUpPj0wJiZPKEUpfX0sY2hlY2tib3g6ZigidHlwZSIsImNoZWNrYm94IiksZmlsZTpmKCJ0eXBlIiwiZmlsZSIpLHBhc3N3b3JkOmYoInR5cGUiLCJwYXNzd29yZCIpLHJhZGlvOmYoInR5cGUiLCJyYWRpbyIpLHJlc2V0OmYoInR5cGUiLCJyZXNldCIpLGltYWdlOmYoInR5cGUiLCJpbWFnZSIpLHN1Ym1pdDpmKCJ0eXBlIiwic3VibWl0IiksaG92ZXI6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPWguYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGMuaXNIb3ZlcmVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGIpe3JldHVybiBPKGIpJiZjLmlzSG92ZXJlZChiKX06bH0sdmlzaXRlZDpmdW5jdGlvbihPLG8saCl7dmFyIGM9aC5hZGFwdGVyO3JldHVybiB0eXBlb2YgYy5pc1Zpc2l0ZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYil7cmV0dXJuIE8oYikmJmMuaXNWaXNpdGVkKGIpfTpsfSxhY3RpdmU6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPWguYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGMuaXNBY3RpdmU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYil7cmV0dXJuIE8oYikmJmMuaXNBY3RpdmUoYil9Omx9fTtmdW5jdGlvbiBwKE8sbyl7Zm9yKHZhciBoPTA7TyYmaDxPLmxlbmd0aDtoKyspaWYoby5pc1RhZyhPW2hdKSlyZXR1cm4gT1toXX12YXIgeT17ZW1wdHk6ZnVuY3Rpb24oTyxvKXtyZXR1cm4hby5nZXRDaGlsZHJlbihPKS5zb21lKGZ1bmN0aW9uKGgpe3JldHVybiBvLmlzVGFnKGgpfHxoLnR5cGU9PT0idGV4dCJ9KX0sImZpcnN0LWNoaWxkIjpmdW5jdGlvbihPLG8pe3JldHVybiBwKG8uZ2V0U2libGluZ3MoTyksbyk9PT1PfSwibGFzdC1jaGlsZCI6ZnVuY3Rpb24oTyxvKXtmb3IodmFyIGg9by5nZXRTaWJsaW5ncyhPKSxjPWgubGVuZ3RoLTE7Yz49MDtjLS0pe2lmKGhbY109PT1PKXJldHVybiEwO2lmKG8uaXNUYWcoaFtjXSkpYnJlYWt9cmV0dXJuITF9LCJmaXJzdC1vZi10eXBlIjpmdW5jdGlvbihPLG8pe2Zvcih2YXIgaD1vLmdldFNpYmxpbmdzKE8pLGM9MDtjPGgubGVuZ3RoO2MrKylpZihvLmlzVGFnKGhbY10pKXtpZihoW2NdPT09TylyZXR1cm4hMDtpZihvLmdldE5hbWUoaFtjXSk9PT1vLmdldE5hbWUoTykpYnJlYWt9cmV0dXJuITF9LCJsYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKE8sbyl7Zm9yKHZhciBoPW8uZ2V0U2libGluZ3MoTyksYz1oLmxlbmd0aC0xO2M+PTA7Yy0tKWlmKG8uaXNUYWcoaFtjXSkpe2lmKGhbY109PT1PKXJldHVybiEwO2lmKG8uZ2V0TmFtZShoW2NdKT09PW8uZ2V0TmFtZShPKSlicmVha31yZXR1cm4hMX0sIm9ubHktb2YtdHlwZSI6ZnVuY3Rpb24oTyxvKXtmb3IodmFyIGg9by5nZXRTaWJsaW5ncyhPKSxjPTAsZz1oLmxlbmd0aDtjPGc7YysrKWlmKG8uaXNUYWcoaFtjXSkpe2lmKGhbY109PT1PKWNvbnRpbnVlO2lmKG8uZ2V0TmFtZShoW2NdKT09PW8uZ2V0TmFtZShPKSlyZXR1cm4hMX1yZXR1cm4hMH0sIm9ubHktY2hpbGQiOmZ1bmN0aW9uKE8sbyl7Zm9yKHZhciBoPW8uZ2V0U2libGluZ3MoTyksYz0wO2M8aC5sZW5ndGg7YysrKWlmKG8uaXNUYWcoaFtjXSkmJmhbY10hPT1PKXJldHVybiExO3JldHVybiEwfSxsaW5rOmZ1bmN0aW9uKE8sbyl7cmV0dXJuIG8uaGFzQXR0cmliKE8sImhyZWYiKX0sc2VsZWN0ZWQ6ZnVuY3Rpb24oTyxvKXtpZihvLmhhc0F0dHJpYihPLCJzZWxlY3RlZCIpKXJldHVybiEwO2lmKG8uZ2V0TmFtZShPKSE9PSJvcHRpb24iKXJldHVybiExO3ZhciBoPW8uZ2V0UGFyZW50KE8pO2lmKCFofHxvLmdldE5hbWUoaCkhPT0ic2VsZWN0Inx8by5oYXNBdHRyaWIoaCwibXVsdGlwbGUiKSlyZXR1cm4hMTtmb3IodmFyIGM9by5nZXRDaGlsZHJlbihoKSxnPSExLGI9MDtiPGMubGVuZ3RoO2IrKylpZihvLmlzVGFnKGNbYl0pKWlmKGNbYl09PT1PKWc9ITA7ZWxzZSBpZihnKXtpZihvLmhhc0F0dHJpYihjW2JdLCJzZWxlY3RlZCIpKXJldHVybiExfWVsc2UgcmV0dXJuITE7cmV0dXJuIGd9LGRpc2FibGVkOmZ1bmN0aW9uKE8sbyl7cmV0dXJuIG8uaGFzQXR0cmliKE8sImRpc2FibGVkIil9LGVuYWJsZWQ6ZnVuY3Rpb24oTyxvKXtyZXR1cm4hby5oYXNBdHRyaWIoTywiZGlzYWJsZWQiKX0sY2hlY2tlZDpmdW5jdGlvbihPLG8pe3JldHVybiBvLmhhc0F0dHJpYihPLCJjaGVja2VkIil8fHkuc2VsZWN0ZWQoTyxvKX0scmVxdWlyZWQ6ZnVuY3Rpb24oTyxvKXtyZXR1cm4gby5oYXNBdHRyaWIoTywicmVxdWlyZWQiKX0sb3B0aW9uYWw6ZnVuY3Rpb24oTyxvKXtyZXR1cm4hby5oYXNBdHRyaWIoTywicmVxdWlyZWQiKX0scGFyZW50OmZ1bmN0aW9uKE8sbyl7cmV0dXJuIXkuZW1wdHkoTyxvKX0saGVhZGVyOlAoWyJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiXSksYnV0dG9uOmZ1bmN0aW9uKE8sbyl7dmFyIGg9by5nZXROYW1lKE8pO3JldHVybiBoPT09ImJ1dHRvbiJ8fGg9PT0iaW5wdXQiJiZvLmdldEF0dHJpYnV0ZVZhbHVlKE8sInR5cGUiKT09PSJidXR0b24ifSxpbnB1dDpQKFsiaW5wdXQiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsImJ1dHRvbiJdKSx0ZXh0OmZ1bmN0aW9uKE8sbyl7dmFyIGg7cmV0dXJuIG8uZ2V0TmFtZShPKT09PSJpbnB1dCImJighKGg9by5nZXRBdHRyaWJ1dGVWYWx1ZShPLCJ0eXBlIikpfHxoLnRvTG93ZXJDYXNlKCk9PT0idGV4dCIpfX07ZnVuY3Rpb24gUChPKXtpZih0eXBlb2YgU2V0PCJ1Iil7dmFyIG89bmV3IFNldChPKTtyZXR1cm4gZnVuY3Rpb24oaCxjKXtyZXR1cm4gby5oYXMoYy5nZXROYW1lKGgpKX19cmV0dXJuIGZ1bmN0aW9uKGgsYyl7cmV0dXJuIE8uaW5kZXhPZihjLmdldE5hbWUoaCkpPj0wfX1mdW5jdGlvbiB4KE8sbyxoKXtpZihoPT09bnVsbCl7aWYoTy5sZW5ndGg+MiYmbyE9PSJzY29wZSIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIrbysiIHJlcXVpcmVzIGFuIGFyZ3VtZW50Iil9ZWxzZSBpZihPLmxlbmd0aD09PTIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIrbysiIGRvZXNuJ3QgaGF2ZSBhbnkgYXJndW1lbnRzIil9dmFyIG09L14oPzooPzpudGh8bGFzdHxmaXJzdHxvbmx5KS0oPzpjaGlsZHxvZi10eXBlKXxyb290fGVtcHR5fCg/OmVufGRpcylhYmxlZHxjaGVja2VkfG5vdCkkLzt1LmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24oTyxvLGgsYyl7dmFyIGc9by5uYW1lLGI9by5kYXRhLEU9aC5hZGFwdGVyO2lmKGgmJmguc3RyaWN0JiYhbS50ZXN0KGcpKXRocm93IG5ldyBFcnJvcigiOiIrZysiIGlzbid0IHBhcnQgb2YgQ1NTMyIpO2lmKHR5cGVvZiBkW2ddPT0iZnVuY3Rpb24iKXJldHVybiBkW2ddKE8sYixoLGMpO2lmKHR5cGVvZiB5W2ddPT0iZnVuY3Rpb24iKXt2YXIgQT15W2ddO3JldHVybiB4KEEsZyxiKSxBPT09bD9BOk89PT1hP2Z1bmN0aW9uKE0pe3JldHVybiBBKE0sRSxiKX06ZnVuY3Rpb24oTSl7cmV0dXJuIEEoTSxFLGIpJiZPKE0pfX1lbHNlIHRocm93IG5ldyBFcnJvcigidW5tYXRjaGVkIHBzZXVkby1jbGFzcyA6IitnKX0sZmlsdGVyczpkLHBzZXVkb3M6eX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDI4NCksbj10KDI4NSk7dS5leHBvcnRzPWZ1bmN0aW9uKGEpe3JldHVybiBuKHIoYSkpfSx1LmV4cG9ydHMucGFyc2U9cix1LmV4cG9ydHMuY29tcGlsZT1ufSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1yO3ZhciB0PS9eKFsrXC1dP1xkKm4pP1xzKig/OihbK1wtXT8pXHMqKFxkKykpPyQvO2Z1bmN0aW9uIHIobil7aWYobj1uLnRyaW0oKS50b0xvd2VyQ2FzZSgpLG49PT0iZXZlbiIpcmV0dXJuWzIsMF07aWYobj09PSJvZGQiKXJldHVyblsyLDFdO3ZhciBpPW4ubWF0Y2godCk7aWYoIWkpdGhyb3cgbmV3IFN5bnRheEVycm9yKCJuLXRoIHJ1bGUgY291bGRuJ3QgYmUgcGFyc2VkICgnIituKyInKSIpO3ZhciBhO3JldHVybiBpWzFdPyhhPXBhcnNlSW50KGlbMV0sMTApLGlzTmFOKGEpJiYoaVsxXS5jaGFyQXQoMCk9PT0iLSI/YT0tMTphPTEpKTphPTAsW2EsaVszXT9wYXJzZUludCgoaVsyXXx8IiIpK2lbM10sMTApOjBdfX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz1hO3ZhciByPXQoMjczKSxuPXIudHJ1ZUZ1bmMsaT1yLmZhbHNlRnVuYztmdW5jdGlvbiBhKGwpe3ZhciBzPWxbMF0sZj1sWzFdLTE7aWYoZjwwJiZzPD0wKXJldHVybiBpO2lmKHM9PT0tMSlyZXR1cm4gZnVuY3Rpb24oZCl7cmV0dXJuIGQ8PWZ9O2lmKHM9PT0wKXJldHVybiBmdW5jdGlvbihkKXtyZXR1cm4gZD09PWZ9O2lmKHM9PT0xKXJldHVybiBmPDA/bjpmdW5jdGlvbihkKXtyZXR1cm4gZD49Zn07dmFyIHY9ZiVzO3JldHVybiB2PDAmJih2Kz1zKSxzPjE/ZnVuY3Rpb24oZCl7cmV0dXJuIGQ+PWYmJmQlcz09PXZ9OihzKj0tMSxmdW5jdGlvbihkKXtyZXR1cm4gZDw9ZiYmZCVzPT09dn0pfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciByPXQoMTIpLG49dCg3NCksaT10KDEpLGE9dCg2OCksbD10KDI1MCkscz10KDIxMyksZj10KDIxOCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYoRSxBKXtpZihFPT1udWxsKXJldHVybnt9O3ZhciBMPWQoRSxBKSxNLEk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhFKTtmb3IoST0wO0k8RC5sZW5ndGg7SSsrKU09RFtJXSwhKEEuaW5kZXhPZihNKT49MCkmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChFLE0pJiYoTFtNXT1FW01dKX1yZXR1cm4gTH1mdW5jdGlvbiBkKEUsQSl7aWYoRT09bnVsbClyZXR1cm57fTt2YXIgTD17fSxNPU9iamVjdC5rZXlzKEUpLEksRDtmb3IoRD0wO0Q8TS5sZW5ndGg7RCsrKUk9TVtEXSwhKEEuaW5kZXhPZihJKT49MCkmJihMW0ldPUVbSV0pO3JldHVybiBMfWNvbnN0IHA9e2FudGlhbGlhczohMCxhdXRvUmVuZGVyOiEwLGFscGhhOiEwfSx5PVN5bWJvbCgiYXV0b1JlbmRlciIpLFA9U3ltYm9sKCJyZW5kZXJlciIpLHg9U3ltYm9sKCJ0aW1lbGluZSIpLG09U3ltYm9sKCJwcmVwYXJlUmVuZGVyIiksTz1TeW1ib2woInRpY2tSZW5kZXIiKSxvPVN5bWJvbCgicGFzcyIpLGg9U3ltYm9sKCJmYm8iKSxjPVN5bWJvbCgidGlja2VycyIpLGc9U3ltYm9sKCJsYXllclRyYW5zZm9ybUludmVydCIpO2NsYXNzIGIgZXh0ZW5kcyBsLmRlZmF1bHR7Y29uc3RydWN0b3IoQT17fSl7aWYoc3VwZXIoKSwhQS5jYW52YXMpe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OlJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEM9ci5FTlYuY3JlYXRlQ2FudmFzKEQsUix7b2Zmc2NyZWVuOiEhQS5vZmZzY3JlZW4saWQ6QS5pZCxleHRyYTpBLmV4dHJhfSk7Qy5zdHlsZSYmKEMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIiksQy5kYXRhc2V0JiYoQy5kYXRhc2V0LmxheWVySWQ9QS5pZCksQy5jb250ZXh0VHlwZSYmKEEuY29udGV4dFR5cGU9Qy5jb250ZXh0VHlwZSksQS5jYW52YXM9Q31jb25zdCBMPUEuY2FudmFzLE09T2JqZWN0LmFzc2lnbih7fSxwLEEpO3RoaXNbeV09TS5hdXRvUmVuZGVyLGRlbGV0ZSBBLmF1dG9SZW5kZXI7Y29uc3QgST1NLlJlbmRlcmVyfHxyLlJlbmRlcmVyO3RoaXNbUF09bmV3IEkoTCxNKSx0aGlzLm9wdGlvbnM9QSx0aGlzLmlkPUEuaWQsdGhpc1tvXT1bXSx0aGlzLnNldFJlc29sdXRpb24oTCksdGhpcy5jYW52YXM9TCx0aGlzW3hdPW5ldyBuLlRpbWVsaW5lLHRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGwsdGhpc1tnXT1udWxsfWdldCBhdXRvUmVuZGVyKCl7cmV0dXJuIHRoaXNbeV19Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucz90aGlzLnBhcmVudC5vcHRpb25zLmRpc3BsYXlSYXRpbzoxfWdldCBoZWlnaHQoKXtjb25zdHtoZWlnaHQ6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEEvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGdsKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcj90aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuZ2w6bnVsbH1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpc31nZXQgb2Zmc2NyZWVuKCl7cmV0dXJuISF0aGlzLm9wdGlvbnMub2Zmc2NyZWVufHx0aGlzLmNhbnZhcy5fb2Zmc2NyZWVufWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbb119Z2V0IHByZXBhcmVSZW5kZXIoKXtyZXR1cm4gdGhpc1ttXT90aGlzW21dOlByb21pc2UucmVzb2x2ZSgpfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzW1BdfWdldCByZW5kZXJPZmZzZXQoKXtpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucyl7Y29uc3R7bGVmdDpBLHRvcDpMfT10aGlzLnBhcmVudC5vcHRpb25zO3JldHVybltBLExdfXJldHVyblt0aGlzLm9wdGlvbnMubGVmdHwwLHRoaXMub3B0aW9ucy50b3B8MF19Z2V0IHRpbWVsaW5lKCl7cmV0dXJuIHRoaXNbeF19Z2V0IHdpZHRoKCl7Y29uc3R7d2lkdGg6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEEvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3R7eDpBLHk6TH09dGhpcy5hdHRyaWJ1dGVzO3JldHVyblsxLDAsMCwxLEEsTF19Z2V0IGxheWVyVHJhbnNmb3JtSW52ZXJ0KCl7aWYodGhpc1tnXSlyZXR1cm4gdGhpc1tnXTtjb25zdCBBPXRoaXMudHJhbnNmb3JtTWF0cml4O3JldHVybiBBWzBdPT09MSYmQVsxXT09PTAmJkFbMl09PT0wJiZBWzNdPT09MSYmQVs0XT09PTAmJkFbNV09PT0wP251bGw6KHRoaXNbZ109aS5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEpLHRoaXNbZ10pfWZvcmNlQ29udGV4dExvc3MoKXtjb25zdCBBPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcjtpZihBKXtjb25zdCBMPUEuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9sb3NlX2NvbnRleHQiKTtpZihMKXJldHVybiBMLmxvc2VDb250ZXh0KCksITB9cmV0dXJuITF9YWRkUGFzcyh7dmVydGV4OkEsZnJhZ21lbnQ6TCxvcHRpb25zOk0sdW5pZm9ybXM6SX09e30pe2lmKHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcil7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpcy5nZXRSZXNvbHV0aW9uKCksQz10aGlzLnJlbmRlcmVyLmNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6QSxmcmFnbWVudDpMLG9wdGlvbnM6TX0pLEI9bmV3IHIuRmlndXJlMkQ7Qi5yZWN0KDAsMCxEL3RoaXMuZGlzcGxheVJhdGlvLFIvdGhpcy5kaXNwbGF5UmF0aW8pO2NvbnN0IHo9bmV3IHIuTWVzaDJEKEIpO3JldHVybiB6LnNldFVuaWZvcm1zKEkpLHouc2V0UHJvZ3JhbShDKSx0aGlzW29dLnB1c2goeiksdGhpcy5mb3JjZVVwZGF0ZSgpLHp9cmV0dXJuIG51bGx9ZGVsZXRlVGV4dHVyZShBKXtyZXR1cm4gT2JqZWN0KGYuZGVsZXRlVGV4dHVyZSkoQSx0aGlzLnJlbmRlcmVyKX1kaXNwYXRjaFBvaW50ZXJFdmVudChBKXtjb25zdCBMPUEudHlwZTtpZihMPT09Im1vdXNlZG93biJ8fEw9PT0ibW91c2V1cCJ8fEw9PT0ibW91c2Vtb3ZlIil7Y29uc3QgQz10aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldDtpZihDKXtpZihDLmxheWVyPT09dGhpcylyZXR1cm4gQy5kaXNwYXRjaEV2ZW50KEEpLCEwO3RoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGx9fWxldCBNLEk7Y29uc3QgRD10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O2lmKEQpe009QS54LEk9QS55O2NvbnN0IEM9RCxCPUNbMF0qTStDWzJdKkkrQ1s0XSx6PUNbMV0qTStDWzNdKkkrQ1s1XTtkZWxldGUgQS54LGRlbGV0ZSBBLnksZGVsZXRlIEEubGF5ZXJYLGRlbGV0ZSBBLmxheWVyWSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhBLHtsYXllclg6e3ZhbHVlOkIsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOnosY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpCLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6eixjb25maWd1cmFibGU6ITB9fSl9Y29uc3QgUj1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChBKTtyZXR1cm4gRCYmT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQSx7bGF5ZXJYOnt2YWx1ZTpNLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpJLGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6TSxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOkksY29uZmlndXJhYmxlOiEwfX0pLFJ9Zm9yY2VVcGRhdGUoKXtpZighdGhpc1ttXSlpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuaGFzT2Zmc2NyZWVuQ2FudmFzKXt0aGlzLnBhcmVudC5mb3JjZVVwZGF0ZSgpO2xldCBBPW51bGw7Y29uc3QgTD1uZXcgUHJvbWlzZShNPT57QT1NfSk7TC5fcmVzb2x2ZT1BLHRoaXNbbV09TH1lbHNle2xldCBBPW51bGwsTD1udWxsO2NvbnN0IE09bmV3IFByb21pc2UoST0+e0E9SSx0aGlzW3ldJiYoTD1PYmplY3QoYS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIE0uX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfSk7TS5fcmVzb2x2ZT1BLE0uX3JlcXVlc3RJRD1MLHRoaXNbbV09TX19Z2V0RkJPKCl7Y29uc3QgQT10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIse3dpZHRoOkwsaGVpZ2h0Ok19PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBBJiYoIXRoaXNbaF18fHRoaXNbaF0ud2lkdGghPT1MfHx0aGlzW2hdLmhlaWdodCE9PU0pPyh0aGlzW2hdPXt3aWR0aDpMLGhlaWdodDpNLHRhcmdldDpBLmNyZWF0ZUZCTygpLGJ1ZmZlcjpBLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSx0aGlzW2hdKTp0aGlzW2hdP3RoaXNbaF06bnVsbH11cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBBPXRoaXMucmVuZGVyZXIsTD1BLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxBLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtBLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PUw7Y29uc3QgTT1pLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO0Euc2V0R2xvYmFsVHJhbnNmb3JtKC4uLmkubWF0MmQubXVsdGlwbHkoTSxMLHRoaXMudHJhbnNmb3JtTWF0cml4KSl9fW9uUHJvcGVydHlDaGFuZ2UoQSxMLE0pe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoQSxMLE0pLEE9PT0iekluZGV4IiYmKHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleD1MKSxBPT09InRyYW5zZm9ybSJ8fEE9PT0idHJhbnNsYXRlInx8QT09PSJyb3RhdGUifHxBPT09InNjYWxlInx8QT09PSJza2V3Iil7Y29uc3QgST10aGlzW2ddO2lmKHRoaXNbZ109bnVsbCx0aGlzLnVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpLEkmJiF0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBEPXRoaXMucmVuZGVyZXIsUj1ELl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxELmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtELnNldEdsb2JhbFRyYW5zZm9ybSguLi5SKX19fV9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKXt0aGlzW21dJiYodGhpc1ttXS5fcmVxdWVzdElEJiZPYmplY3QoYS5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1ttXS5fcmVxdWVzdElEKSx0aGlzW21dLl9yZXNvbHZlKCksZGVsZXRlIHRoaXNbbV0pfXJlbmRlcih7Y2xlYXI6QT0hMH09e30pe2NvbnN0IEw9dGhpc1tvXS5sZW5ndGg/dGhpcy5nZXRGQk8oKTpudWxsO0wmJnRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5iaW5kRkJPKEwudGFyZ2V0KSxBJiZ0aGlzW1BdLmNsZWFyKCk7Y29uc3QgTT10aGlzLmRyYXcoKTtpZihNJiZNLmxlbmd0aCYmKHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhNKSx0aGlzLmNhbnZhcy5kcmF3JiZ0aGlzLmNhbnZhcy5kcmF3KCkpLEwpe2NvbnN0IEk9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLEQ9dGhpc1tvXS5sZW5ndGgse3dpZHRoOlIsaGVpZ2h0OkN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEI9WzAsMCxSL3RoaXMuZGlzcGxheVJhdGlvLEMvdGhpcy5kaXNwbGF5UmF0aW9dO3RoaXNbb10uZm9yRWFjaCgoeixLKT0+e3ouYmxlbmQ9ITAsei5zZXRUZXh0dXJlKEwudGFyZ2V0LnRleHR1cmUse3JlY3Q6Qn0pLEs9PT1ELTE/SS5iaW5kRkJPKG51bGwpOihMLnN3YXAoKSxJLmJpbmRGQk8oTC50YXJnZXQpKSx0aGlzW1BdLmNsZWFyKCksdGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKFt6XSl9KX10aGlzLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpBLGhlaWdodDpMfSl7Y29uc3QgTT10aGlzLnJlbmRlcmVyLEk9TS5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8TS5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgsRD1JWzRdLFI9SVs1XSxDPUlbMF0se3dpZHRoOkIsaGVpZ2h0Onp9PXRoaXMuZ2V0UmVzb2x1dGlvbigpOyhCIT09QXx8eiE9PUwpJiYoc3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6QSxoZWlnaHQ6TH0pLHRoaXMuY2FudmFzJiYodGhpcy5jYW52YXMud2lkdGg9QSx0aGlzLmNhbnZhcy5oZWlnaHQ9TCxNLnVwZGF0ZVJlc29sdXRpb24mJk0udXBkYXRlUmVzb2x1dGlvbigpKSx0aGlzLmF0dHJpYnV0ZXMuc2l6ZT1bQSxMXSx0aGlzW29dLmxlbmd0aCYmdGhpc1tvXS5mb3JFYWNoKEY9Pntjb25zdCBHPW5ldyByLkZpZ3VyZTJEO0cucmVjdCgwLDAsQS90aGlzLmRpc3BsYXlSYXRpbyxML3RoaXMuZGlzcGxheVJhdGlvKSxGLmNvbnRvdXJzPUcuY29udG91cnN9KSk7Y29uc3RbSyxRXT10aGlzLnJlbmRlck9mZnNldCxfPXRoaXMuZGlzcGxheVJhdGlvOyhEIT09S3x8UiE9PVF8fEMhPT1fKSYmKE0uc2V0R2xvYmFsVHJhbnNmb3JtKF8sMCwwLF8sSyxRKSxNLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PW51bGwsdGhpc1tnXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksdGhpcy5mb3JjZVVwZGF0ZSgpKX10aWNrKEE9bnVsbCxMPXt9KXtsZXR7ZHVyYXRpb246TT0xLzB9PUwsST12KEwsWyJkdXJhdGlvbiJdKTtjb25zdCBEPXRoaXMudGltZWxpbmUuZm9yayhJKSxSPXRoaXM7dGhpc1tjXT10aGlzW2NdfHxbXSx0aGlzW2NdLnB1c2goe2hhbmRsZXI6QSxkdXJhdGlvbjpNfSk7Y29uc3QgQz0oKT0+e2xldCBCPW51bGwsej1udWxsO2NvbnN0IEs9KCk9Pntjb25zdCBRPXRoaXNbY10ubWFwKCh7aGFuZGxlcjpfLGR1cmF0aW9uOkZ9KT0+e2NvbnN0IEc9TWF0aC5taW4oMSxELmN1cnJlbnRUaW1lL0YpO3JldHVybnt2YWx1ZTpfP18oRC5jdXJyZW50VGltZSxHKTpudWxsLHA6R319KTtSW09dfHwoUltPXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57Ult5XSYmUi5yZW5kZXIoKSxkZWxldGUgUltPXTtmb3IobGV0IF89US5sZW5ndGgtMTtfPj0wO18tLSl7Y29uc3R7dmFsdWU6RixwOkd9PVFbX107KEY9PT0hMXx8Rz49MSkmJnRoaXNbY10uc3BsaWNlKF8sMSl9dGhpc1tjXS5sZW5ndGg+MCYmQygpfSkpfTtpZih0aGlzW21dJiZ0aGlzW21dLl90eXBlIT09InRpY2tlciImJihPYmplY3QoYS5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1ttXS5fcmVxdWVzdElEKSxkZWxldGUgdGhpc1ttXSksIXRoaXNbbV0pe2NvbnN0IFE9bmV3IFByb21pc2UoXz0+e0I9Xyx6PU9iamVjdChhLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoSyl9KTtRLl9yZXNvbHZlPUIsUS5fcmVxdWVzdElEPXosUS5fdHlwZT0idGlja2VyIix0aGlzW21dPVF9fTtDKCl9dG9HbG9iYWxQb3MoQSxMKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBCPXRoaXMudHJhbnNmb3JtTWF0cml4O0E9QlswXSpBK0JbMl0qTCtCWzRdLEw9QlsxXSpBK0JbM10qTCtCWzVdfWNvbnN0e3dpZHRoOk0saGVpZ2h0Okl9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEQ9dGhpcy5yZW5kZXJPZmZzZXQsUj1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtBPUEqUlswXS9NK0RbMF0sTD1MKlJbMV0vSStEWzFdO2NvbnN0IEM9dGhpcy5kaXNwbGF5UmF0aW87cmV0dXJuIEEqPUMsTCo9QyxbQSxMXX10b0xvY2FsUG9zKEEsTCl7Y29uc3R7d2lkdGg6TSxoZWlnaHQ6SX09dGhpcy5nZXRSZXNvbHV0aW9uKCksRD10aGlzLnJlbmRlck9mZnNldCxSPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO0E9QSpNL1JbMF0tRFswXSxMPUwqSS9SWzFdLURbMV07Y29uc3QgQz10aGlzLmRpc3BsYXlSYXRpbztBLz1DLEwvPUM7Y29uc3QgQj10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O3JldHVybiBCJiYoQT1CWzBdKkErQlsyXSpMK0JbNF0sTD1CWzFdKkErQlszXSpMK0JbNV0pLFtBLExdfX1zLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsImxheWVyIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgcj10KDIyNCksbj10KDI4OCksaT10KDIxMyksYT10KDI1MiksbD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyhPLG8pe2lmKE89PW51bGwpcmV0dXJue307dmFyIGg9ZihPLG8pLGMsZztpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgYj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pO2ZvcihnPTA7ZzxiLmxlbmd0aDtnKyspYz1iW2ddLCEoby5pbmRleE9mKGMpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKE8sYykmJihoW2NdPU9bY10pfXJldHVybiBofWZ1bmN0aW9uIGYoTyxvKXtpZihPPT1udWxsKXJldHVybnt9O3ZhciBoPXt9LGM9T2JqZWN0LmtleXMoTyksZyxiO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspZz1jW2JdLCEoby5pbmRleE9mKGcpPj0wKSYmKGhbZ109T1tnXSk7cmV0dXJuIGh9ZnVuY3Rpb24gdihPLG8saCl7cmV0dXJuIG8gaW4gTz9PYmplY3QuZGVmaW5lUHJvcGVydHkoTyxvLHt2YWx1ZTpoLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6T1tvXT1oLE99Y29uc3QgZD0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLHA9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIikseT1TeW1ib2woInJvb3QiKSxQPVN5bWJvbCgidGFzayIpO2Z1bmN0aW9uIHgoTyxvPSEwKXtjb25zdCBoPU9beV07aWYoaCYmaC5jaGlsZHJlblswXSl7Y29uc3QgYz1PLnN2ZyxnPU8ubGF5ZXI/Ty5sYXllci5kaXNwbGF5UmF0aW86MTtpZighYy5oYXNBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSl7bGV0IEE9Yy5nZXRBdHRyaWJ1dGUoIndpZHRoIik7QT1BP09iamVjdChsLnNpemVUb1BpeGVsKShBKTozMDA7bGV0IEw9Yy5nZXRBdHRyaWJ1dGUoImhlaWdodCIpO0w9TD9PYmplY3QobC5zaXplVG9QaXhlbCkoTCk6MTUwLGMuaGFzQXR0cmlidXRlKCJ2aWV3Qm94Iil8fGMuc2V0QXR0cmlidXRlKCJ2aWV3Qm94IixgMCAwICR7TWF0aC5yb3VuZChBKX0gJHtNYXRoLnJvdW5kKEwpfWApLGMuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIixBKSxjLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiLEwpfWxldCBiPU8uYXR0cmlidXRlcy53aWR0aHx8TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpLEU9Ty5hdHRyaWJ1dGVzLmhlaWdodHx8TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIpKTtpZihiKj1nLEUqPWcsbyYmTy5hdHRyaWJ1dGVzLmZsZXhpYmxlKXtjb25zdCBBPU8uYXR0cmlidXRlcy5zY2FsZVswXTtpZihiKj1BLEUqPUEsYy5zZXRBdHRyaWJ1dGUoIndpZHRoIixiKSxjLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixFKSxiJiZFJiZPLnRleHR1cmVJbWFnZSl7Y29uc3QgTD1PLnRleHR1cmVJbWFnZS53aWR0aCxNPU8udGV4dHVyZUltYWdlLmhlaWdodCxJPU8uY2xpZW50U2l6ZTtPLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9WzAsMCxNYXRoLnJvdW5kKElbMF0qTC9iKSxNYXRoLnJvdW5kKElbMV0qTS9FKV19fWVsc2UgT1tQXXx8KGMuc2V0QXR0cmlidXRlKCJ3aWR0aCIsYiksYy5zZXRBdHRyaWJ1dGUoImhlaWdodCIsRSksT1tQXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57ZGVsZXRlIE9bUF07Y29uc3QgQT1oLmlubmVySFRNTCxMPW5ldyBCbG9iKFtBXSx7dHlwZToiaW1hZ2Uvc3ZnK3htbCJ9KSxNPVVSTC5jcmVhdGVPYmplY3RVUkwoTCksST1uZXcgSW1hZ2U7SS5vbmxvYWQ9ZnVuY3Rpb24oKXtJLndpZHRoJiZJLmhlaWdodD8oTy5hdHRyaWJ1dGVzW3BdKCJ0ZXh0dXJlIixJKSxPLmF0dHJpYnV0ZXMuZmxleGlibGUmJihPLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9bnVsbCkpOk8uYXR0cmlidXRlc1twXSgidGV4dHVyZSIsbnVsbCl9LEkuc3JjPU19KSl9fWNsYXNzIG0gZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3Iobz17fSl7dHlwZW9mIG89PSJzdHJpbmciJiYobz17c3ZnVGV4dDpvfSk7bGV0e3N2Z1RleHQ6aH09byxjPXMobyxbInN2Z1RleHQiXSk7aWYoc3VwZXIoYyksdGhpc1t5XT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxoKXt0aGlzW3ldLmlubmVySFRNTD1oO2NvbnN0IGc9dGhpc1t5XS5jaGlsZHJlblswXTtnP2cuc2V0QXR0cmlidXRlKCJ4bWxucyIsZCk6KGZldGNoKGgpLnRoZW4oYj0+Yi50ZXh0KCkpLnRoZW4oYj0+e3RoaXNbeV0uaW5uZXJIVE1MPWIsKCF0aGlzLm9ic2VydmVyfHx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUpJiZ4KHRoaXMpfSksaD1udWxsKX1pZighaCl7Y29uc3QgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZCwic3ZnIik7Zy5zZXRBdHRyaWJ1dGUoInhtbG5zIixkKSx0aGlzW3ldLmFwcGVuZENoaWxkKGcpfWlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPT0iZnVuY3Rpb24iKXtjb25zdCBnPW5ldyBNdXRhdGlvbk9ic2VydmVyKGI9Pnt4KHRoaXMsITEpfSk7Zy5vYnNlcnZlKHRoaXNbeV0se2F0dHJpYnV0ZXM6ITAsc3VidHJlZTohMCxjaGFyYWN0ZXJEYXRhOiEwLGNoaWxkTGlzdDohMH0pLHRoaXMub2JzZXJ2ZXI9Z319Z2V0IGNoaWxkcmVuKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgY2hpbGROb2Rlcygpe3JldHVyblt0aGlzLnN2Z119Z2V0IHN2Zygpe3JldHVybiB0aGlzW3ldP3RoaXNbeV0uY2hpbGRyZW5bMF06bnVsbH1zZXRSZXNvbHV0aW9uKHt3aWR0aDpvLGhlaWdodDpofSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6byxoZWlnaHQ6aH0pLHgodGhpcyl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQobyl7Y29uc3QgaD1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChvKTtpZihoJiZ0aGlzLmF0dHJpYnV0ZXMucGFzc0V2ZW50cyYmdHlwZW9mIE1vdXNlRXZlbnQ9PSJmdW5jdGlvbiIpe2NvbnN0e3g6Yyx5Omd9PW87bGV0W2IsRV09dGhpcy5nZXRPZmZzZXRQb3NpdGlvbihjLGcpO2NvbnN0IEE9by5vcmlnaW5hbEV2ZW50LEw9dGhpcy5hdHRyaWJ1dGVzLmFuY2hvcixNPXRoaXMuY2xpZW50U2l6ZTtiPShiK0xbMF0qTVswXSkvMixFPShFK0xbMV0qTVsxXSkvMjtjb25zdCBJPW8udHlwZTtpZihJPT09QS50eXBlKXtsZXQgRD1udWxsO2lmKEEgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KUQ9bmV3IE1vdXNlRXZlbnQoSSx7c2NyZWVuWDpiLHNjcmVlblk6RSxjbGllbnRYOmIsY2xpZW50WTpFLGJ1YmJsZXM6QS5idWJibGVzLGJ1dHRvbjpBLmJ1dHRvbixidXR0b25zOkEuYnV0dG9ucyxjYW5jZWxCdWJibGU6QS5jYW5jZWxCdWJibGUsY2FuY2VsYWJsZTpBLmNhbmNlbGFibGUsY3VycmVudFRhcmdldDpBLmN1cnJlbnRUYXJnZXQsZnJvbUVsZW1lbnQ6QS5mcm9tRWxlbWVudCxyZWxhdGVkVGFyZ2V0OkEucmVsYXRlZFRhcmdldCxyZXR1cm5WYWx1ZTpBLnJldHVyblZhbHVlLHNyY0VsZW1lbnQ6QS5zcmNFbGVtZW50LHRhcmdldDpBLnRhcmdldCx0b0VsZW1lbnQ6QS50b0VsZW1lbnQsd2hpY2g6QS53aXRjaH0pO2Vsc2UgaWYoQSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpe2xldCBSPW51bGw7Y29uc3QgQz1BLmNoYW5nZWRUb3VjaGVzfHxbQV07Zm9yKGxldCBCPTA7QjxDLmxlbmd0aDtCKyspe2NvbnN0IHo9Q1tCXTtpZihvLmlkZW50aWZpZXI9PT16LmlkZW50aWZpZXIpe1I9ejticmVha319aWYoUil7Y29uc3QgQj1uZXcgVG91Y2goe2lkZW50aWZpZXI6Ui5pZGVudGlmaWVyLHRhcmdldDpSLnRhcmdldCxjbGllbnRYOmIsY2xpZW50WTpFLHNjcmVlblg6YixzY3JlZW5ZOkUscGFnZVg6YixwYWdlWTpFLHJhZGl1c1g6Ui5yYWRpdXNYLHJhZGl1c1k6Ui5yYWRpdXNZLHJvdGF0aW9uQW5nbGU6Ui5yb3RhdGlvbkFuZ2xlLGZvcmNlOlIuZm9yY2V9KTtEPW5ldyBUb3VjaEV2ZW50KEkse2NhbmNlbGFibGU6QS5jYW5jZWxhYmxlLGJ1YmJsZXM6QS5idWJibGVzLGNvbXBvc2VkOkEuY29tcG9zZWQsdG91Y2hlczpbQl0sdGFyZ2V0VG91Y2hlczpbQl0sY2hhbmdlZFRvdWNoZXM6W0JdfSl9fWVsc2UgRD1BO0QmJnRoaXMuc3ZnLmRpc3BhdGNoRXZlbnQoRCl9fXJldHVybiBofWdldEVsZW1lbnRCeUlkKG8pe3JldHVybiBPYmplY3QoYS5xdWVyeVNlbGVjdG9yKShgIyR7b31gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUobyl7cmV0dXJuIE9iamVjdChhLnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtvfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUobyl7cmV0dXJuIE9iamVjdChhLnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtvfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShvKXtyZXR1cm4gT2JqZWN0KGEucXVlcnlTZWxlY3RvckFsbCkobyx0aGlzKX1xdWVyeVNlbGVjdG9yKG8pe3JldHVybiBPYmplY3QoYS5xdWVyeVNlbGVjdG9yKShvLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwobyl7cmV0dXJuIE9iamVjdChhLnF1ZXJ5U2VsZWN0b3JBbGwpKG8sdGhpcyl9b25Qcm9wZXJ0eUNoYW5nZShvLGgsYyl7c3VwZXIub25Qcm9wZXJ0eUNoYW5nZShvLGgsYyksbz09PSJmbGV4aWJsZSImJngodGhpcyksdGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYobz09PSJ3aWR0aCJ8fG89PT0iaGVpZ2h0Inx8bz09PSJzY2FsZSJ8fG89PT0idHJhbnNmb3JtIikmJngodGhpcyl9fXYobSwiQXR0ciIsbi5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKG0sInNwcml0ZXN2ZyIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBuPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iik7Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW2FdKHtwYXNzRXZlbnRzOiExLGZsZXhpYmxlOiExfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tuXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe31nZXQgcGFzc0V2ZW50cygpe3JldHVybiB0aGlzW25dKCJwYXNzRXZlbnRzIil9c2V0IHBhc3NFdmVudHMoZil7cmV0dXJuIHRoaXNbaV0oInBhc3NFdmVudHMiLGYpfWdldCBmbGV4aWJsZSgpe3JldHVybiB0aGlzW25dKCJmbGV4aWJsZSIpfXNldCBmbGV4aWJsZShmKXtyZXR1cm4gdGhpc1tpXSgiZmxleGlibGUiLGYpfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oZix2KXt2YXIgZD1PYmplY3Qua2V5cyhmKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGYpO3YmJihwPXAuZmlsdGVyKGZ1bmN0aW9uKHkpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGYseSkuZW51bWVyYWJsZX0pKSxkLnB1c2guYXBwbHkoZCxwKX1yZXR1cm4gZH1mdW5jdGlvbiBpKGYpe2Zvcih2YXIgdj0xO3Y8YXJndW1lbnRzLmxlbmd0aDt2Kyspe3ZhciBkPWFyZ3VtZW50c1t2XSE9bnVsbD9hcmd1bWVudHNbdl06e307diUyP24oT2JqZWN0KGQpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHApe2EoZixwLGRbcF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhkKSk6bihPYmplY3QoZCkpLmZvckVhY2goZnVuY3Rpb24ocCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGYscCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGQscCkpfSl9cmV0dXJuIGZ9ZnVuY3Rpb24gYShmLHYsZCl7cmV0dXJuIHYgaW4gZj9PYmplY3QuZGVmaW5lUHJvcGVydHkoZix2LHt2YWx1ZTpkLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Zlt2XT1kLGZ9Y29uc3QgbD1TeW1ib2woImluaXRlZCIpO2xldCBzPW51bGw7dHlwZW9mIFdvcmtlcj09ImZ1bmN0aW9uIiYmKHM9Y2xhc3MgZXh0ZW5kcyBXb3JrZXJ7Y29uc3RydWN0b3IoZil7aWYoZi53b3JrZXI9PT0hMCYmKGYud29ya2VyPWAuLyR7Zi5pZH0ud29ya2VyLmpzYCksc3VwZXIoZi53b3JrZXIpLHRoaXMub3B0aW9ucz1mLCFmLmNhbnZhcyl7Y29uc3R7d2lkdGg6dixoZWlnaHQ6ZH09dGhpcy5nZXRSZXNvbHV0aW9uKCkscD1yLkVOVi5jcmVhdGVDYW52YXModixkLHtvZmZzY3JlZW46ITF9KTtwLnN0eWxlJiYocC5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxwLmRhdGFzZXQmJihwLmRhdGFzZXQubGF5ZXJJZD1mLmlkKSxmLmNhbnZhcz1wfXRoaXMuY2FudmFzPWYuY2FudmFzfWdldCBpZCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaWR9c2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6dn0pe2lmKHRoaXNbbF0pdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToicmVzb2x1dGlvbl9jaGFuZ2UiLHdpZHRoOmYsaGVpZ2h0OnZ9KTtlbHNle3RoaXMuY2FudmFzLndpZHRoPWYsdGhpcy5jYW52YXMuaGVpZ2h0PXY7Y29uc3QgZD10aGlzLm9wdGlvbnMscD1kLmNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpLHk9aSh7fSxkKTtkZWxldGUgeS5jb250YWluZXIseS5jYW52YXM9cCx0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJjcmVhdGUiLG9wdGlvbnM6eX0sW3BdKSx0aGlzW2xdPSEwfX1nZXRSZXNvbHV0aW9uKCl7aWYodGhpcy5jYW52YXMpe2NvbnN0e3dpZHRoOmYsaGVpZ2h0OnZ9PXRoaXMuY2FudmFzO3JldHVybnt3aWR0aDpmLGhlaWdodDp2fX1yZXR1cm57d2lkdGg6MzAwLGhlaWdodDoxNTB9fXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1jb25uZWN0KGYsdil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOmYsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOnYsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9ZGlzY29ubmVjdCgpe2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXJ9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoZil7dGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiZXZlbnQiLGV2ZW50OntjYW5jZWxCdWJibGU6Zi5jYW5jZWxCdWJibGUsYnViYmxlczpmLmJ1YmJsZXMsZGV0YWlsOmYuZGV0YWlsLGlkZW50aWZpZXI6Zi5pZGVudGlmaWVyLGxheWVyWDpmLmxheWVyWCxsYXllclk6Zi5sYXllclksb3JpZ2luYWxYOmYub3JpZ2luYWxYLG9yaWdpbmFsWTpmLm9yaWdpbmFsWSx0eXBlOmYudHlwZSx4OmYueCx5OmYueX19KX19KSxlLmRlZmF1bHQ9c30sZnVuY3Rpb24odSxlLHQpe3QucihlKSwoZnVuY3Rpb24ocil7dC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KTt2YXIgbj10KDEyKSxpPXQoNjgpLGE9dCg3MCksbD10KDI4Nikscz10KDI4OSksZj10KDI1MCksdj10KDI5MSksZD10KDIxNCkscD10KDIxOCkseT10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFA9U3ltYm9sKCJlbnRlcmVkVGFyZ2V0cyIpO2Z1bmN0aW9uIHgoRSl7cmV0dXJuIEUuaWQ9RS5pZHx8YF9sYXllciR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwxMil9YCxFLmRhdGFzZXR8fChFLmRhdGFzZXQ9e30pLEUuZGF0YXNldC5sYXllcklkPUUuaWQsRS5jb25uZWN0PShBLEwpPT57RS5wYXJlbnQ9QSxPYmplY3QuZGVmaW5lUHJvcGVydHkoRSwiek9yZGVyIix7dmFsdWU6TCx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX0sRS5kaXNjb25uZWN0PUE9PntkZWxldGUgRS56T3JkZXJ9LEUuY2FudmFzPUUsRS5nZXRSZXNvbHV0aW9uPSgpPT4oe3dpZHRoOjAsaGVpZ2h0OjB9KSxFLnNldFJlc29sdXRpb249KCk9PiExLEUub3B0aW9ucz17aGFuZGxlRXZlbnQ6ITF9LEV9ZnVuY3Rpb24gbShFLEEpe2NvbnN0IEw9RS5jaGlsZHJlbjtsZXQgTT1udWxsO2ZvcihsZXQgST0wO0k8TC5sZW5ndGg7SSsrKXtjb25zdCBEPUxbSV07aWYoKEE9PT1EfHxNIT1udWxsKSYmKE09RCksTSYmTSE9PUEmJiFNLm9mZnNjcmVlbilyZXR1cm4gTS5jYW52YXN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gTyhFLEEpe2NvbnN0W0wsTV09RS5yZW5kZXJPZmZzZXQse3dpZHRoOkksaGVpZ2h0OkR9PUUuZ2V0UmVzb2x1dGlvbigpLFI9RS5kaXNwbGF5UmF0aW87RS5yZW5kZXJlci5kcmF3SW1hZ2UoQS5jYW52YXMsLUwvUiwtTS9SLEkvUixEL1IpfWNvbnN0IG89e307ZnVuY3Rpb24gaChFKXtjb25zdCBBPVsibW91c2Vkb3duIiwibW91c2V1cCIsIm1vdXNlbW92ZSIsIm1vdXNld2hlZWwiLCJ3aGVlbCIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoY2FuY2VsIiwiY2xpY2siLCJkYmxjbGljayIsImxvbmdwcmVzcyIsInRhcCIsImNvbnRleHRtZW51Il0sTD1FLmNvbnRhaW5lcjtMLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLE09Pntjb25zdCBJPUVbUF07aWYoSS5zaXplKXtjb25zdCBEPW5ldyBkLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTtELnNldE9yaWdpbmFsRXZlbnQoTSksWy4uLkldLmZvckVhY2goUj0+e1IuZGlzcGF0Y2hFdmVudChEKX0pLEVbUF0uY2xlYXIoKX19LHtwYXNzaXZlOiEwfSksQS5mb3JFYWNoKE09PntMLmFkZEV2ZW50TGlzdGVuZXIoTSxJPT57Y29uc3R7bGVmdDpELHRvcDpSLGRpc3BsYXlSYXRpbzpDfT1FLm9wdGlvbnMsQj1FLm9yZGVyZWRDaGlsZHJlbjtPYmplY3Qodi5kZWZhdWx0KShJLHtvZmZzZXRMZWZ0OkQsb2Zmc2V0VG9wOlIsZGlzcGxheVJhdGlvOkN9KS5mb3JFYWNoKEs9Pntjb25zdCBRPUsuaWRlbnRpZmllcjtpZihLLnR5cGU9PT0idG91Y2htb3ZlInx8Sy50eXBlPT09InRvdWNoZW5kIil7Y29uc3QgRj1vW1FdO0YmJkYuZGlzcGF0Y2hFdmVudChLKSxLLnR5cGU9PT0idG91Y2hlbmQiJiZkZWxldGUgb1tRXX1lbHNle2ZvcihsZXQgRj1CLmxlbmd0aC0xO0Y+PTA7Ri0tKXtjb25zdCBHPUJbRl07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe2lmKEcuZGlzcGF0Y2hQb2ludGVyRXZlbnQoSykmJksudGFyZ2V0IT09RylicmVhaztLLmNhbmNlbEJ1YmJsZT0hMX19aWYoSy50YXJnZXQ9PT1CWzBdKWZvcihsZXQgRj1CLmxlbmd0aC0xO0Y+PTA7Ri0tKXtjb25zdCBHPUJbRl07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe0sudGFyZ2V0PUc7YnJlYWt9fX1jb25zdCBfPUsudGFyZ2V0O2lmKEsudHlwZT09PSJ0b3VjaHN0YXJ0IiYmKG9bUV09Sy50YXJnZXQpLEsudHlwZT09PSJtb3VzZW1vdmUiKXtjb25zdCBGPUVbUF07bGV0IEc7aWYoXyl7Y29uc3QgdHQ9Xy5hbmNlc3RvcnN8fFtdO0c9bmV3IFNldChbXywuLi50dF0pfWVsc2UgRz1uZXcgU2V0O2NvbnN0IFg9T2JqZWN0LmVudHJpZXMoSSk7aWYoIUYuaGFzKF8pJiZfKXtjb25zdCB0dD1uZXcgZC5kZWZhdWx0KCJtb3VzZWVudGVyIik7dHQuc2V0T3JpZ2luYWxFdmVudChJKSxYLmZvckVhY2goKFtxLGh0XSk9Pnt0dFtxXT1odH0pLEYuYWRkKF8pLF8uZGlzcGF0Y2hFdmVudCh0dCk7Y29uc3QgbnQ9Xy5hbmNlc3RvcnM7bnQmJm50LmZvckVhY2gocT0+e3EgaW5zdGFuY2VvZiBhLmRlZmF1bHQmJiFGLmhhcyhxKSYmKEYuYWRkKHEpLHEuZGlzcGF0Y2hFdmVudCh0dCkpfSl9Y29uc3QgWj1uZXcgZC5kZWZhdWx0KCJtb3VzZWxlYXZlIik7Wi5zZXRPcmlnaW5hbEV2ZW50KEkpLFguZm9yRWFjaCgoW3R0LG50XSk9PntaW3R0XT1udH0pLFsuLi5GXS5mb3JFYWNoKHR0PT57Ry5oYXModHQpfHwoRi5kZWxldGUodHQpLHR0LmRpc3BhdGNoRXZlbnQoWikpfSl9fSl9LHtwYXNzaXZlOk0hPT0iY29udGV4dG1lbnUifSl9KX1mdW5jdGlvbiBjKEUsQSl7aWYoQSYmQS5zdHlsZSl7bGV0e3dpZHRoOkwsaGVpZ2h0Ok0sbW9kZTpJLGNvbnRhaW5lcjpEfT1FO2NvbnN0e2NsaWVudFdpZHRoOlIsY2xpZW50SGVpZ2h0OkN9PUQ7TD1MfHxSLE09TXx8QyxJPT09InN0YXRpYyI/KEEuc3R5bGUud2lkdGg9YCR7TH1weGAsQS5zdHlsZS5oZWlnaHQ9YCR7TX1weGApOihBLnN0eWxlLnRvcD0iMCIsQS5zdHlsZS5sZWZ0PSIwIixBLnN0eWxlLndpZHRoPWAke1J9cHhgLEEuc3R5bGUuaGVpZ2h0PWAke0N9cHhgLEEuc3R5bGUudHJhbnNmb3JtPSIiLEEuc3R5bGUud2Via2l0VHJhbnNmb3JtPSIiKX19Y29uc3QgZz1TeW1ib2woIm9mZnNjcmVlbkxheWVyQ291bnQiKTtjbGFzcyBiIGV4dGVuZHMgZi5kZWZhdWx0e2NvbnN0cnVjdG9yKEE9e30pe2lmKHN1cGVyKCksIUEuY29udGFpbmVyKWlmKHR5cGVvZiBuLkVOVi5Db250YWluZXI9PSJmdW5jdGlvbiIpQS5jb250YWluZXI9bmV3IG4uRU5WLkNvbnRhaW5lcihBLndpZHRofHwzMDAsQS5oZWlnaHR8fDE1MCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIk5vIGNvbnRhaW5lciBzcGVjaWZpZWQuIik7aWYodGhpcy5jb250YWluZXI9QS5jb250YWluZXIsdGhpcy5jb250YWluZXIuc3R5bGUmJih0aGlzLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd3x8KHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iKSx0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbnx8KHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSIpKSx0aGlzLm9wdGlvbnM9QSxBLmRpc3BsYXlSYXRpbz1BLmRpc3BsYXlSYXRpb3x8MSxBLm1vZGU9QS5tb2RlfHwic2NhbGUiLEEubGVmdD0wLEEudG9wPTAsQS5hdXRvUmVzaXplPUEuYXV0b1Jlc2l6ZSE9PSExLEEuYXV0b1Jlc2l6ZSl7bGV0IEw7aWYodHlwZW9mIGdsb2JhbFRoaXM8InUiP0w9Z2xvYmFsVGhpczpMPXR5cGVvZiB3aW5kb3c8InUiP3dpbmRvdzpyLEwuYWRkRXZlbnRMaXN0ZW5lcil7Y29uc3QgTT10aGlzO0wuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIixmdW5jdGlvbiBJKCl7dHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuY29udGFpbnMoTS5jb250YWluZXIpP00ucmVzaXplKCk6TC5yZW1vdmVFdmVudExpc3RlbmVyKCJyZXNpemUiLEkpfSl9fXRoaXNbUF09bmV3IFNldCx0aGlzLnNldFJlc29sdXRpb24oQSksaCh0aGlzKSx0aGlzW2ddPTB9Z2V0IGhhc09mZnNjcmVlbkNhbnZhcygpe3JldHVybiB0aGlzW2ddPjB9c2V0IGRpc3BsYXlSYXRpbyhBKXt0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvIT09QSYmKHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW89QSx0aGlzLnJlc2l6ZSgpKX1nZXQgZGlzcGxheVJhdGlvKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW99c2V0IGhlaWdodChBKXt0aGlzLm9wdGlvbnMuaGVpZ2h0IT09QSYmKHRoaXMub3B0aW9ucy5oZWlnaHQ9QSx0aGlzLnJlc2l6ZSgpKX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXMub3B0aW9ucy5oZWlnaHR9c2V0IG1vZGUoQSl7dGhpcy5vcHRpb25zLm1vZGUhPT1BJiYodGhpcy5vcHRpb25zLm1vZGU9QSx0aGlzLnJlc2l6ZSgpKX1nZXQgbW9kZSgpe3JldHVybiB0aGlzLm9wdGlvbnMubW9kZX1zZXQgd2lkdGgoQSl7dGhpcy5vcHRpb25zLndpZHRoIT09QSYmKHRoaXMub3B0aW9ucy53aWR0aD1BLHRoaXMucmVzaXplKCkpfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLm9wdGlvbnMud2lkdGh9YXBwZW5kQ2hpbGQoQSl7IShBIGluc3RhbmNlb2YgbC5kZWZhdWx0KSYmIShBIGluc3RhbmNlb2Ygcy5kZWZhdWx0KSYmeChBKTtjb25zdCBMPXN1cGVyLmFwcGVuZENoaWxkKEEpLE09QS5jYW52YXM7cmV0dXJuIEEub2Zmc2NyZWVuP3RoaXNbZ10rKzp0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChNKSxjKHRoaXMub3B0aW9ucyxNKSxBLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLEx9Zm9yY2VVcGRhdGUoKXt0aGlzLmhhc09mZnNjcmVlbkNhbnZhcyYmIXRoaXMuX3JlcXVlc3RJRCYmKHRoaXMuX3JlcXVlc3RJRD1PYmplY3QoaS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIHRoaXMuX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfWluc2VydEJlZm9yZShBLEwpeyEoQSBpbnN0YW5jZW9mIGwuZGVmYXVsdCkmJiEoQSBpbnN0YW5jZW9mIHMuZGVmYXVsdCkmJngoQSk7Y29uc3QgTT1zdXBlci5pbnNlcnRCZWZvcmUoQSxMKSxJPUEuY2FudmFzO2lmKCFBLm9mZnNjcmVlbil7Y29uc3QgRD1tKHRoaXMsQSk7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEksRCl9cmV0dXJuIGModGhpcy5vcHRpb25zLEkpLEEuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksTX1sYXllcihBPSJkZWZhdWx0IixMPXt9KXtMPU9iamVjdC5hc3NpZ24oe30sdGhpcy5vcHRpb25zLEwpLEwuaWQ9QTtjb25zdCBNPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgUj0wO1I8TS5sZW5ndGg7UisrKWlmKE1bUl0uaWQ9PT1BKXJldHVybiBNW1JdO2NvbnN0IEk9TC53b3JrZXI7bGV0IEQ7cmV0dXJuIEk/RD1uZXcgcy5kZWZhdWx0KEwpOkQ9bmV3IGwuZGVmYXVsdChMKSx0aGlzLmFwcGVuZENoaWxkKEQpLER9YXN5bmMgcHJlbG9hZCguLi5BKXtjb25zdCBMPVtdLE09W10sST1bXTtmb3IobGV0IEQ9MDtEPEEubGVuZ3RoO0QrKyl7Y29uc3QgUj1BW0RdO2xldCBDO2lmKHR5cGVvZiBSPT0ic3RyaW5nIilDPU9iamVjdChwLmxvYWRUZXh0dXJlKShSKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoUikpQz1PYmplY3QocC5sb2FkRnJhbWVzKSguLi5SKTtlbHNle2NvbnN0e2lkOkIsc3JjOnp9PVI7Qz1PYmplY3QocC5sb2FkVGV4dHVyZSkoeixCKX1DIGluc3RhbmNlb2YgUHJvbWlzZXx8KEM9UHJvbWlzZS5yZXNvbHZlKEMpKSxNLnB1c2goQy50aGVuKEI9PntMLnB1c2goQiksSVtEXT1CO2NvbnN0IHo9bmV3IGQuZGVmYXVsdCh7dHlwZToicHJlbG9hZCIsZGV0YWlsOntjdXJyZW50OkIsbG9hZGVkOkwscmVzb3VyY2VzOkF9fSk7dGhpcy5kaXNwYXRjaEV2ZW50KHopfSkpfXJldHVybiBhd2FpdCBQcm9taXNlLmFsbChNKSxJfXJlbW92ZUNoaWxkKEEpe2NvbnN0IEw9c3VwZXIucmVtb3ZlQ2hpbGQoQSk7aWYoTCl7QS5fcHJlcGFyZVJlbmRlckZpbmlzaGVkJiZBLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKTtjb25zdCBNPUEuY2FudmFzO00mJk0ucmVtb3ZlJiZNLnJlbW92ZSgpLEEub2Zmc2NyZWVuJiZ0aGlzW2ddLS19cmV0dXJuIEx9cmVuZGVyKCl7Y29uc3QgQT10aGlzLm9yZGVyZWRDaGlsZHJlbjtsZXQgTD1udWxsO2NvbnN0IE09W107Zm9yKGxldCBJPTA7STxBLmxlbmd0aDtJKyspe2NvbnN0IEQ9QVtJXSxSPU0ubGVuZ3RoPjA7aWYoRCBpbnN0YW5jZW9mIGwuZGVmYXVsdCYmIUQub2Zmc2NyZWVuKWlmKCFELmF1dG9SZW5kZXIpUiYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLE0ubGVuZ3RoPTApO2Vsc2UgaWYoTD1ELFIpe0QucmVuZGVyZXIuY2xlYXIoKTtmb3IobGV0IEM9MDtDPE0ubGVuZ3RoO0MrKyl7Y29uc3QgQj1NW0NdO0IucmVuZGVyKCksTyhELEIpfU0ubGVuZ3RoPTAsRC5yZW5kZXIoe2NsZWFyOiExfSl9ZWxzZSBELnByZXBhcmVSZW5kZXImJkQucmVuZGVyKCk7ZWxzZSBELm9mZnNjcmVlbj9MPyhELnByZXBhcmVSZW5kZXImJkQucmVuZGVyKCksTyhMLEQpKTpNLnB1c2goRCk6RCBpbnN0YW5jZW9mIHMuZGVmYXVsdCYmUiYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLE0ubGVuZ3RoPTApfX1yZXBsYWNlQ2hpbGQoQSxMKXtjb25zdCBNPXN1cGVyLnJlcGxhY2VDaGlsZChBLEwpO0wuY2FudmFzLnJlbW92ZSYmTC5jYW52YXMucmVtb3ZlKCksTC5vZmZzY3JlZW4mJnRoaXNbZ10tLTtjb25zdCBJPUEuY2FudmFzO2lmKCFBLm9mZnNjcmVlbil7Y29uc3QgRD1tKHRoaXMsQSk7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEksRCl9cmV0dXJuIGModGhpcy5vcHRpb25zLEkpLEEuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksTX1yZXNpemUoKXtjb25zdCBBPXRoaXMub3B0aW9uczt0aGlzLmNoaWxkcmVuLmZvckVhY2goTD0+e2MoQSxMLmNhbnZhcyl9KSx0aGlzLnNldFJlc29sdXRpb24oQSksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZXNpemUifSl9c2V0UmVzb2x1dGlvbih7d2lkdGg6QSxoZWlnaHQ6TH09e30pe2NvbnN0IE09dGhpcy5jb250YWluZXIse2NsaWVudFdpZHRoOkksY2xpZW50SGVpZ2h0OkR9PU07KEE9PW51bGx8fEw9PW51bGwpJiYoQT1BPz9JLEw9TD8/RCk7Y29uc3R7bW9kZTpSLGRpc3BsYXlSYXRpbzpDfT10aGlzLm9wdGlvbnM7aWYoQSo9QyxMKj1DLHRoaXMub3B0aW9ucy5sZWZ0PTAsdGhpcy5vcHRpb25zLnRvcD0wLFI9PT0ic3RpY2t5SGVpZ2h0Inx8Uj09PSJzdGlja3lMZWZ0Inx8Uj09PSJzdGlja3lSaWdodCIpe2NvbnN0IEI9QTtBPUkqTC9ELFI9PT0ic3RpY2t5SGVpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PS41KihBLUIpKSxSPT09InN0aWNreVJpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PUEtQil9ZWxzZSBpZihSPT09InN0aWNreVdpZHRoInx8Uj09PSJzdGlja3lUb3AifHxSPT09InN0aWNreUJvdHRvbSIpe2NvbnN0IEI9TDtMPUQqQS9JLFI9PT0ic3RpY2t5V2lkdGgiJiYodGhpcy5vcHRpb25zLnRvcD0uNSooTC1CKSksUj09PSJzdGlja3lCb3R0b20iJiYodGhpcy5vcHRpb25zLnRvcD1MLUIpfXN1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOkEsaGVpZ2h0Okx9KX1zbmFwc2hvdCh7b2Zmc2NyZWVuOkE9ITEsbGF5ZXJzOkx9PXt9KXtjb25zdCBNPUE/InNuYXBzaG90T2ZmU2NyZWVuQ2FudmFzIjoic25hcHNob3RDYW52YXMiLHt3aWR0aDpJLGhlaWdodDpEfT10aGlzLmdldFJlc29sdXRpb24oKTt0aGlzW01dPXRoaXNbTV18fG4uRU5WLmNyZWF0ZUNhbnZhcyhJLEQse29mZnNjcmVlbjpBfSk7Y29uc3QgUj10aGlzW01dLmdldENvbnRleHQoIjJkIik7TD1MfHx0aGlzLm9yZGVyZWRDaGlsZHJlbix0aGlzW01dLndpZHRoPUksdGhpc1tNXS5oZWlnaHQ9RDtmb3IobGV0IEM9MDtDPEwubGVuZ3RoO0MrKyl7Y29uc3QgQj1MW0NdO2lmKCFCLm9wdGlvbnMuaWdub3JlU25hcHNob3Qpe0IucmVuZGVyJiZCLnJlbmRlcigpO2NvbnN0IHo9Qi5jYW52YXM7eiYmeiE9PUImJlIuZHJhd0ltYWdlKHosMCwwLEksRCl9fXJldHVybiB0aGlzW01dfX10eXBlb2YgZG9jdW1lbnQ8InUiJiYoYi5wcm90b3R5cGUubGF5ZXIzZD1mdW5jdGlvbihFLEE9e30pe2NvbnN0IEw9QS51cmx8fCJodHRwczovL3VucGtnLmNvbS9zcHJpdGUtZXh0ZW5kLTNkL2Rpc3Qvc3ByaXRlLWV4dGVuZC0zZC5taW4uanMiO3JldHVybiBuZXcgUHJvbWlzZSgoTSxJKT0+e2NvbnN0IEQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0Iik7RC5hc3luYz0hMSxELnNyYz1MLEQub25sb2FkPSgpPT57dHJ5e00odGhpcy5sYXllcjNkKEUsQSkpfWNhdGNoKFIpe0koUil9fSxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoRCl9KX0pLHkuZGVmYXVsdC5yZWdpc3Rlck5vZGUoYiwic2NlbmUiKX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgcj10KDIxNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oaSx7b2Zmc2V0VG9wOmE9MCxvZmZzZXRMZWZ0Omw9MCxkaXNwbGF5UmF0aW86cz0xfT17fSl7bGV0IGYsdjtjb25zdCBkPVtdLHtsZWZ0OnAsdG9wOnksd2lkdGg6UCxoZWlnaHQ6eH09aS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbT1pLnRhcmdldC53aWR0aCxPPWkudGFyZ2V0LmhlaWdodCxvPWkuY2hhbmdlZFRvdWNoZXN8fFtpXTtmb3IobGV0IGM9MDtjPG8ubGVuZ3RoO2MrKyl7Y29uc3QgZz1vW2NdLGI9Zy5pZGVudGlmaWVyLHtjbGllbnRYOkUsY2xpZW50WTpBfT1nO0UhPW51bGwmJkEhPW51bGwmJmQucHVzaCh7eDpNYXRoLnJvdW5kKChFfDApLXApLHk6TWF0aC5yb3VuZCgoQXwwKS15KSxpZGVudGlmaWVyOmJ9KX1kLmxlbmd0aDw9MCYmZC5wdXNoKHt4OmYseTp2fSk7Y29uc3QgaD1bXTtyZXR1cm4gZC5mb3JFYWNoKGM9PntjLnghPW51bGwmJmMueSE9bnVsbCYmKGY9KGMueCptL1AtbCkvcyx2PShjLnkqTy94LWEpL3MpO2NvbnN0IGc9bmV3IHIuZGVmYXVsdChpKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhnLHtsYXllclg6e3ZhbHVlOmYsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOnYsY29uZmlndXJhYmxlOiEwfSxvcmlnaW5hbFg6e3ZhbHVlOmMueH0sb3JpZ2luYWxZOnt2YWx1ZTpjLnl9LHg6e3ZhbHVlOmYsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTp2LGNvbmZpZ3VyYWJsZTohMH0saWRlbnRpZmllcjp7dmFsdWU6Yy5pZGVudGlmaWVyfX0pLGgucHVzaChnKX0pLGh9fV0pO0R0LnZlcnNpb24sRHQuQXJjLER0LkJsb2NrLER0LkNsb3VkLER0LkNvbG9yO2NvbnN0IFBuPUR0LkVsbGlwc2U7RHQuR3JhZGllbnQ7Y29uc3QgdGU9RHQuR3JvdXAsSGg9RHQuTGFiZWw7RHQuTGF5ZXIsRHQuTGF5ZXJXb3JrZXIsRHQuTm9kZSxEdC5QYXJhbGxlbDtjb25zdCBhZT1EdC5QYXRoLGVlPUR0LlBvbHlsaW5lLGFyPUR0LlJlY3Q7RHQuUmVndWxhcixEdC5SaW5nO2NvbnN0IEtoPUR0LlNjZW5lLFZoPUR0LlNwcml0ZTtEdC5TcHJpdGVTdmcsRHQuU3RhcixEdC5UcmlhbmdsZSxEdC5oZWxwZXJzLER0LmNyZWF0ZUVsZW1lbnQsRHQuaXNTcHJpdGVOb2RlLER0LnJlZ2lzdGVyTm9kZSxEdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsRHQuY2FuY2VsQW5pbWF0aW9uRnJhbWUsRHQuRU5WO2Z1bmN0aW9uIHZlKHUsZT0hMCl7Y29uc3QgdD11Lmxlbmd0aDtpZih0PDIpcmV0dXJuIiI7bGV0IHI9dVswXSxuPXVbMV07aWYodD09PTIpcmV0dXJuYE0ke3BlKHIpfUwke3BlKG4pfWA7bGV0IGk9IiI7Zm9yKGxldCBhPTIsbD10LTE7YTxsO2ErKylyPXVbYV0sbj11W2ErMV0saSs9bWUocixuKTtyZXR1cm4gZT9gTSR7bWUodVswXSx1WzFdKX1RJHtwZSh1WzFdKX0ke21lKHVbMV0sdVsyXSl9VCR7aX0ke21lKHVbdC0xXSx1WzBdKX0ke21lKHVbMF0sdVsxXSl9WmA6YE0ke3BlKHVbMF0pfVEke3BlKHVbMV0pfSR7bWUodVsxXSx1WzJdKX0ke3UubGVuZ3RoPjM/IlQiOiIifSR7aX1MJHtwZSh1W3QtMV0pfWB9dmFyIGxyPXtleHBvcnRzOnt9fTtsci5leHBvcnRzLGZ1bmN0aW9uKHUpe3ZhciBlPWZ1bmN0aW9uKCl7dmFyIHQ9U3RyaW5nLmZyb21DaGFyQ29kZSxyPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSIsbj0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLSQiLGk9e307ZnVuY3Rpb24gYShzLGYpe2lmKCFpW3NdKXtpW3NdPXt9O2Zvcih2YXIgdj0wO3Y8cy5sZW5ndGg7disrKWlbc11bcy5jaGFyQXQodildPXZ9cmV0dXJuIGlbc11bZl19dmFyIGw9e2NvbXByZXNzVG9CYXNlNjQ6ZnVuY3Rpb24ocyl7aWYocz09bnVsbClyZXR1cm4iIjt2YXIgZj1sLl9jb21wcmVzcyhzLDYsZnVuY3Rpb24odil7cmV0dXJuIHIuY2hhckF0KHYpfSk7c3dpdGNoKGYubGVuZ3RoJTQpe2RlZmF1bHQ6Y2FzZSAwOnJldHVybiBmO2Nhc2UgMTpyZXR1cm4gZisiPT09IjtjYXNlIDI6cmV0dXJuIGYrIj09IjtjYXNlIDM6cmV0dXJuIGYrIj0ifX0sZGVjb21wcmVzc0Zyb21CYXNlNjQ6ZnVuY3Rpb24ocyl7cmV0dXJuIHM9PW51bGw/IiI6cz09IiI/bnVsbDpsLl9kZWNvbXByZXNzKHMubGVuZ3RoLDMyLGZ1bmN0aW9uKGYpe3JldHVybiBhKHIscy5jaGFyQXQoZikpfSl9LGNvbXByZXNzVG9VVEYxNjpmdW5jdGlvbihzKXtyZXR1cm4gcz09bnVsbD8iIjpsLl9jb21wcmVzcyhzLDE1LGZ1bmN0aW9uKGYpe3JldHVybiB0KGYrMzIpfSkrIiAifSxkZWNvbXByZXNzRnJvbVVURjE2OmZ1bmN0aW9uKHMpe3JldHVybiBzPT1udWxsPyIiOnM9PSIiP251bGw6bC5fZGVjb21wcmVzcyhzLmxlbmd0aCwxNjM4NCxmdW5jdGlvbihmKXtyZXR1cm4gcy5jaGFyQ29kZUF0KGYpLTMyfSl9LGNvbXByZXNzVG9VaW50OEFycmF5OmZ1bmN0aW9uKHMpe2Zvcih2YXIgZj1sLmNvbXByZXNzKHMpLHY9bmV3IFVpbnQ4QXJyYXkoZi5sZW5ndGgqMiksZD0wLHA9Zi5sZW5ndGg7ZDxwO2QrKyl7dmFyIHk9Zi5jaGFyQ29kZUF0KGQpO3ZbZCoyXT15Pj4+OCx2W2QqMisxXT15JTI1Nn1yZXR1cm4gdn0sZGVjb21wcmVzc0Zyb21VaW50OEFycmF5OmZ1bmN0aW9uKHMpe2lmKHM9PW51bGwpcmV0dXJuIGwuZGVjb21wcmVzcyhzKTtmb3IodmFyIGY9bmV3IEFycmF5KHMubGVuZ3RoLzIpLHY9MCxkPWYubGVuZ3RoO3Y8ZDt2KyspZlt2XT1zW3YqMl0qMjU2K3NbdioyKzFdO3ZhciBwPVtdO3JldHVybiBmLmZvckVhY2goZnVuY3Rpb24oeSl7cC5wdXNoKHQoeSkpfSksbC5kZWNvbXByZXNzKHAuam9pbigiIikpfSxjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihzKXtyZXR1cm4gcz09bnVsbD8iIjpsLl9jb21wcmVzcyhzLDYsZnVuY3Rpb24oZil7cmV0dXJuIG4uY2hhckF0KGYpfSl9LGRlY29tcHJlc3NGcm9tRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihzKXtyZXR1cm4gcz09bnVsbD8iIjpzPT0iIj9udWxsOihzPXMucmVwbGFjZSgvIC9nLCIrIiksbC5fZGVjb21wcmVzcyhzLmxlbmd0aCwzMixmdW5jdGlvbihmKXtyZXR1cm4gYShuLHMuY2hhckF0KGYpKX0pKX0sY29tcHJlc3M6ZnVuY3Rpb24ocyl7cmV0dXJuIGwuX2NvbXByZXNzKHMsMTYsZnVuY3Rpb24oZil7cmV0dXJuIHQoZil9KX0sX2NvbXByZXNzOmZ1bmN0aW9uKHMsZix2KXtpZihzPT1udWxsKXJldHVybiIiO3ZhciBkLHAseT17fSxQPXt9LHg9IiIsbT0iIixPPSIiLG89MixoPTMsYz0yLGc9W10sYj0wLEU9MCxBO2ZvcihBPTA7QTxzLmxlbmd0aDtBKz0xKWlmKHg9cy5jaGFyQXQoQSksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHkseCl8fCh5W3hdPWgrKyxQW3hdPSEwKSxtPU8reCxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeSxtKSlPPW07ZWxzZXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUCxPKSl7aWYoTy5jaGFyQ29kZUF0KDApPDI1Nil7Zm9yKGQ9MDtkPGM7ZCsrKWI9Yjw8MSxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKys7Zm9yKHA9Ty5jaGFyQ29kZUF0KDApLGQ9MDtkPDg7ZCsrKWI9Yjw8MXxwJjEsRT09Zi0xPyhFPTAsZy5wdXNoKHYoYikpLGI9MCk6RSsrLHA9cD4+MX1lbHNle2ZvcihwPTEsZD0wO2Q8YztkKyspYj1iPDwxfHAsRT09Zi0xPyhFPTAsZy5wdXNoKHYoYikpLGI9MCk6RSsrLHA9MDtmb3IocD1PLmNoYXJDb2RlQXQoMCksZD0wO2Q8MTY7ZCsrKWI9Yjw8MXxwJjEsRT09Zi0xPyhFPTAsZy5wdXNoKHYoYikpLGI9MCk6RSsrLHA9cD4+MX1vLS0sbz09MCYmKG89TWF0aC5wb3coMixjKSxjKyspLGRlbGV0ZSBQW09dfWVsc2UgZm9yKHA9eVtPXSxkPTA7ZDxjO2QrKyliPWI8PDF8cCYxLEU9PWYtMT8oRT0wLGcucHVzaCh2KGIpKSxiPTApOkUrKyxwPXA+PjE7by0tLG89PTAmJihvPU1hdGgucG93KDIsYyksYysrKSx5W21dPWgrKyxPPVN0cmluZyh4KX1pZihPIT09IiIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChQLE8pKXtpZihPLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IoZD0wO2Q8YztkKyspYj1iPDwxLEU9PWYtMT8oRT0wLGcucHVzaCh2KGIpKSxiPTApOkUrKztmb3IocD1PLmNoYXJDb2RlQXQoMCksZD0wO2Q8ODtkKyspYj1iPDwxfHAmMSxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKysscD1wPj4xfWVsc2V7Zm9yKHA9MSxkPTA7ZDxjO2QrKyliPWI8PDF8cCxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKysscD0wO2ZvcihwPU8uY2hhckNvZGVBdCgwKSxkPTA7ZDwxNjtkKyspYj1iPDwxfHAmMSxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKysscD1wPj4xfW8tLSxvPT0wJiYobz1NYXRoLnBvdygyLGMpLGMrKyksZGVsZXRlIFBbT119ZWxzZSBmb3IocD15W09dLGQ9MDtkPGM7ZCsrKWI9Yjw8MXxwJjEsRT09Zi0xPyhFPTAsZy5wdXNoKHYoYikpLGI9MCk6RSsrLHA9cD4+MTtvLS0sbz09MCYmKG89TWF0aC5wb3coMixjKSxjKyspfWZvcihwPTIsZD0wO2Q8YztkKyspYj1iPDwxfHAmMSxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKysscD1wPj4xO2Zvcig7OylpZihiPWI8PDEsRT09Zi0xKXtnLnB1c2godihiKSk7YnJlYWt9ZWxzZSBFKys7cmV0dXJuIGcuam9pbigiIil9LGRlY29tcHJlc3M6ZnVuY3Rpb24ocyl7cmV0dXJuIHM9PW51bGw/IiI6cz09IiI/bnVsbDpsLl9kZWNvbXByZXNzKHMubGVuZ3RoLDMyNzY4LGZ1bmN0aW9uKGYpe3JldHVybiBzLmNoYXJDb2RlQXQoZil9KX0sX2RlY29tcHJlc3M6ZnVuY3Rpb24ocyxmLHYpe3ZhciBkPVtdLHA9NCx5PTQsUD0zLHg9IiIsbT1bXSxPLG8saCxjLGcsYixFLEE9e3ZhbDp2KDApLHBvc2l0aW9uOmYsaW5kZXg6MX07Zm9yKE89MDtPPDM7Tys9MSlkW09dPU87Zm9yKGg9MCxnPU1hdGgucG93KDIsMiksYj0xO2IhPWc7KWM9QS52YWwmQS5wb3NpdGlvbixBLnBvc2l0aW9uPj49MSxBLnBvc2l0aW9uPT0wJiYoQS5wb3NpdGlvbj1mLEEudmFsPXYoQS5pbmRleCsrKSksaHw9KGM+MD8xOjApKmIsYjw8PTE7c3dpdGNoKGgpe2Nhc2UgMDpmb3IoaD0wLGc9TWF0aC5wb3coMiw4KSxiPTE7YiE9ZzspYz1BLnZhbCZBLnBvc2l0aW9uLEEucG9zaXRpb24+Pj0xLEEucG9zaXRpb249PTAmJihBLnBvc2l0aW9uPWYsQS52YWw9dihBLmluZGV4KyspKSxofD0oYz4wPzE6MCkqYixiPDw9MTtFPXQoaCk7YnJlYWs7Y2FzZSAxOmZvcihoPTAsZz1NYXRoLnBvdygyLDE2KSxiPTE7YiE9ZzspYz1BLnZhbCZBLnBvc2l0aW9uLEEucG9zaXRpb24+Pj0xLEEucG9zaXRpb249PTAmJihBLnBvc2l0aW9uPWYsQS52YWw9dihBLmluZGV4KyspKSxofD0oYz4wPzE6MCkqYixiPDw9MTtFPXQoaCk7YnJlYWs7Y2FzZSAyOnJldHVybiIifWZvcihkWzNdPUUsbz1FLG0ucHVzaChFKTs7KXtpZihBLmluZGV4PnMpcmV0dXJuIiI7Zm9yKGg9MCxnPU1hdGgucG93KDIsUCksYj0xO2IhPWc7KWM9QS52YWwmQS5wb3NpdGlvbixBLnBvc2l0aW9uPj49MSxBLnBvc2l0aW9uPT0wJiYoQS5wb3NpdGlvbj1mLEEudmFsPXYoQS5pbmRleCsrKSksaHw9KGM+MD8xOjApKmIsYjw8PTE7c3dpdGNoKEU9aCl7Y2FzZSAwOmZvcihoPTAsZz1NYXRoLnBvdygyLDgpLGI9MTtiIT1nOyljPUEudmFsJkEucG9zaXRpb24sQS5wb3NpdGlvbj4+PTEsQS5wb3NpdGlvbj09MCYmKEEucG9zaXRpb249ZixBLnZhbD12KEEuaW5kZXgrKykpLGh8PShjPjA/MTowKSpiLGI8PD0xO2RbeSsrXT10KGgpLEU9eS0xLHAtLTticmVhaztjYXNlIDE6Zm9yKGg9MCxnPU1hdGgucG93KDIsMTYpLGI9MTtiIT1nOyljPUEudmFsJkEucG9zaXRpb24sQS5wb3NpdGlvbj4+PTEsQS5wb3NpdGlvbj09MCYmKEEucG9zaXRpb249ZixBLnZhbD12KEEuaW5kZXgrKykpLGh8PShjPjA/MTowKSpiLGI8PD0xO2RbeSsrXT10KGgpLEU9eS0xLHAtLTticmVhaztjYXNlIDI6cmV0dXJuIG0uam9pbigiIil9aWYocD09MCYmKHA9TWF0aC5wb3coMixQKSxQKyspLGRbRV0peD1kW0VdO2Vsc2UgaWYoRT09PXkpeD1vK28uY2hhckF0KDApO2Vsc2UgcmV0dXJuIG51bGw7bS5wdXNoKHgpLGRbeSsrXT1vK3guY2hhckF0KDApLHAtLSxvPXgscD09MCYmKHA9TWF0aC5wb3coMixQKSxQKyspfX19O3JldHVybiBsfSgpO3UhPW51bGw/dS5leHBvcnRzPWU6dHlwZW9mIGFuZ3VsYXI8InUiJiZhbmd1bGFyIT1udWxsJiZhbmd1bGFyLm1vZHVsZSgiTFpTdHJpbmciLFtdKS5mYWN0b3J5KCJMWlN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gZX0pfShscik7dmFyIFRuPWxyLmV4cG9ydHM7ZnVuY3Rpb24gemUodSl7cmV0dXJuIEpTT04ucGFyc2UoVG4uZGVjb21wcmVzcyh1KSl9ZnVuY3Rpb24gcXQodSl7cmV0dXJuIFRuLmNvbXByZXNzKEpTT04uc3RyaW5naWZ5KHUpKX1jbGFzcyBNbiBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuUGVuY2lsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY0luZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJNQVhfUkVQRUFSIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidW5pVGhpY2tuZXNzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNlbnRlclBvcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlswLDBdfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMudW5pVGhpY2tuZXNzPXRoaXMuTUFYX1JFUEVBUi90aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcy8xMCx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe3ZhciBhO2NvbnN0IGU9KGE9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDphLnRvU3RyaW5nKCksdD10aGlzLnRyYW5zZm9ybURhdGFBbGwoITApLHI9e25hbWU6ZX07bGV0IG47Y29uc3QgaT10aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7cmV0dXJuIHQubGVuZ3RoJiYobj10aGlzLmRyYXcoe2F0dHJzOnIsdGFza3M6dCxyZXBsYWNlSWQ6ZSxsYXllcjppLGlzQ2xlYXJBbGw6ITB9KSkse3JlY3Q6bix0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsfX1zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe3ZhciB4O2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNDbGVhckFsbDpuLGlzU3ViV29ya2VyOml9PWU7aWYoKCh4PXQub3ApPT1udWxsP3ZvaWQgMDp4Lmxlbmd0aCk9PT0wKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0e3dvcmtJZDphfT10LHt0YXNrczpsLGVmZmVjdHM6cyxjb25zdW1lSW5kZXg6Zn09dGhpcy50cmFuc2Zvcm1EYXRhKHQsITEpO3RoaXMuc3luY0luZGV4PU1hdGgubWluKHRoaXMuc3luY0luZGV4LGYsTWF0aC5tYXgoMCx0aGlzLnRtcFBvaW50cy5sZW5ndGgtMikpO2NvbnN0IHY9e25hbWU6YT09bnVsbD92b2lkIDA6YS50b1N0cmluZygpfTtsZXQgZCxwPSExO2NvbnN0IHk9dGhpcy5zeW5jSW5kZXg7aWYodGhpcy5zeW5jVGltZXN0YW1wPT09MCYmKHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpKSxsLmxlbmd0aCYmKGxbMF0udGFza0lkLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZSYmKHA9ITAsdGhpcy5zeW5jVGltZXN0YW1wPWxbMF0udGFza0lkLHRoaXMuc3luY0luZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aCksaSkpe2NvbnN0IG09cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7ZD10aGlzLmRyYXcoe2F0dHJzOnYsdGFza3M6bCxlZmZlY3RzOnMsbGF5ZXI6bSxpc0NsZWFyQWxsOm59KX1pZihpKXJldHVybiBmPjEwJiZ0aGlzLnRtcFBvaW50cy5zcGxpY2UoMCxmLTEwKSx7cmVjdDpkLHR5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWx9O2NvbnN0IFA9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKHkpLmZvckVhY2gobT0+e1AucHVzaChtLngsbS55LHRoaXMuY29tcHV0UmFkaXVzKG0ueix0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcykpfSkse3JlY3Q6ZCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDpwP2E6dm9pZCAwLG9wOnA/UDp2b2lkIDAsaW5kZXg6cD95KjM6dm9pZCAwfX1jb25zdW1lQWxsKGUpe3ZhciBmLHY7aWYoZS5kYXRhKXtjb25zdHtvcDpkLHdvcmtTdGF0ZTpwfT1lLmRhdGE7ZCE9bnVsbCYmZC5sZW5ndGgmJnA9PT1SdC5Eb25lJiZ0aGlzLndvcmtPcHRpb25zLnN0cm9rZVR5cGU9PT16dC5TdHJva2UmJnRoaXMudXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZVdoZW5Eb25lKGQpfWNvbnN0IHQ9KGY9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCk7aWYoIXQpcmV0dXJue3R5cGU6YXQuTm9uZX07Y29uc3Qgcj10aGlzLnRyYW5zZm9ybURhdGFBbGwoITApLG49e25hbWU6dH07bGV0IGk7Y29uc3QgYT10aGlzLmZ1bGxMYXllcjtyLmxlbmd0aCYmKGk9dGhpcy5kcmF3KHthdHRyczpuLHRhc2tzOnIscmVwbGFjZUlkOnQsbGF5ZXI6YSxpc0NsZWFyQWxsOiExfSkpO2NvbnN0IGw9W107dGhpcy50bXBQb2ludHMubWFwKGQ9PntsLnB1c2goZC54LGQueSx0aGlzLmNvbXB1dFJhZGl1cyhkLnosdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MpKX0pLHRoaXMuc3luY1RpbWVzdGFtcD0wLGRlbGV0ZSB0aGlzLndvcmtPcHRpb25zLnN5bmNVbml0VGltZTtjb25zdCBzPXF0KGwpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHQse3JlY3Q6aSxvcDpsLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxhKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6dCxvcHM6cyx1cGRhdGVOb2RlT3B0Ontwb3M6dGhpcy5jZW50ZXJQb3MsdXNlQW5pbWF0aW9uOiEwfSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx1bmRvVGlja2VySWQ6KHY9ZS5kYXRhKT09bnVsbD92b2lkIDA6di51bmRvVGlja2VySWR9fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jSW5kZXg9MH1jb25zdW1lU2VydmljZShlKXt2YXIgdjtjb25zdHtvcDp0LGlzRnVsbFdvcms6cixyZXBsYWNlSWQ6bixpc0NsZWFyQWxsOml9PWU7dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBkPTA7ZDx0Lmxlbmd0aDtkKz0zKXtjb25zdCBwPW5ldyB4dCh0W2RdLHRbZCsxXSx0W2QrMl0pO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD4wKXtjb25zdCB5PXRoaXMudG1wUG9pbnRzW3RoaXMudG1wUG9pbnRzLmxlbmd0aC0xXSxQPWV0LlN1YihwLHkpLnVuaSgpO3Auc2V0dihQKX10aGlzLnRtcFBvaW50cy5wdXNoKHApfWNvbnN0IGE9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCExKSxsPSh2PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6di50b1N0cmluZygpLHM9e25hbWU6bH07bGV0IGY7aWYobCYmYS5sZW5ndGgpe2NvbnN0IGQ9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7Zj10aGlzLmRyYXcoe2F0dHJzOnMsdGFza3M6YSxyZXBsYWNlSWQ6bixsYXllcjpkLGlzQ2xlYXJBbGw6aX0pLHRoaXMudk5vZGVzLnNldEluZm8obCx7cmVjdDpmLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmYmJnB0LmdldENlbnRlclBvcyhmLGQpfSl9cmV0dXJuIGZ9dHJhbnNmb3JtRGF0YUFsbChlPSEwKXtyZXR1cm4gdGhpcy5nZXRUYXNrUG9pbnRzKHRoaXMudG1wUG9pbnRzLGUmJnRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzfHx2b2lkIDApfWRyYXcoZSl7dmFyIGM7Y29uc3R7YXR0cnM6dCx0YXNrczpyLHJlcGxhY2VJZDpuLGVmZmVjdHM6aSxsYXllcjphLGlzQ2xlYXJBbGw6bH09ZSx7c3Ryb2tlQ29sb3I6cyxzdHJva2VUeXBlOmYsdGhpY2tuZXNzOnYsekluZGV4OmQsc2NhbGU6cCxyb3RhdGU6eSx0cmFuc2xhdGU6UH09dGhpcy53b3JrT3B0aW9ucztsJiZhLnJlbW92ZUFsbENoaWxkcmVuKCksbiYmKHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKG4rIiIpLm1hcChnPT5nLnJlbW92ZSgpKSwoYz10aGlzLmRyYXdMYXllcik9PW51bGx8fGMuZ2V0RWxlbWVudHNCeU5hbWUobisiIikubWFwKGc9PmcucmVtb3ZlKCkpKSxpIT1udWxsJiZpLnNpemUmJihpLmZvckVhY2goZz0+e3ZhciBiOyhiPWEuZ2V0RWxlbWVudEJ5SWQoZysiIikpPT1udWxsfHxiLnJlbW92ZSgpfSksaS5jbGVhcigpKTtsZXQgeDtjb25zdCBtPVtdLE89YS53b3JsZFBvc2l0aW9uLG89YS53b3JsZFNjYWxpbmc7Zm9yKGxldCBnPTA7ZzxyLmxlbmd0aDtnKyspe2NvbnN0e3BvczpiLHBvaW50czpFLHRhc2tJZDpBfT1yW2ddO3QuaWQ9QS50b1N0cmluZygpO2NvbnN0e3BzOkwscmVjdDpNfT10aGlzLmNvbXB1dERyYXdQb2ludHMoRSk7bGV0IEk7Y29uc3QgRD1FLmxlbmd0aD09PTE7Zj09PXp0LlN0cm9rZXx8RD9JPXZlKEwsITApOkk9dmUoTCwhMSk7Y29uc3QgUj17cG9zOmIsZDpJLGZpbGxDb2xvcjpmPT09enQuU3Ryb2tlfHxEP3M6dm9pZCAwLGxpbmVEYXNoOmY9PT16dC5Eb3R0ZWQmJiFEP1sxLHYqMl06Zj09PXp0LkxvbmdEb3R0ZWQmJiFEP1t2LHYqMl06dm9pZCAwLHN0cm9rZUNvbG9yOnMsbGluZUNhcDpmPT09enQuU3Ryb2tlfHxEP3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDpmPT09enQuU3Ryb2tlfHxEPzA6dn07eD1idCh4LHt4Ok1hdGguZmxvb3IoKE0ueCtiWzBdKSpvWzBdK09bMF0tcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcigoTS55K2JbMV0pKm9bMV0rT1sxXS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKE0udypvWzBdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihNLmgqb1sxXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKX0pLG0ucHVzaChSKX1wJiYodC5zY2FsZT1wKSx5JiYodC5yb3RhdGU9eSksUCYmKHQudHJhbnNsYXRlPVApO2NvbnN0IGg9bmV3IHRlO2lmKHgpe3RoaXMuY2VudGVyUG9zPXB0LmdldENlbnRlclBvcyh4LGEpLGguYXR0cih7Li4udCxub3JtYWxpemU6ITAsaWQ6dC5uYW1lLGFuY2hvcjpbLjUsLjVdLGJnY29sb3I6Zj09PXp0LlN0cm9rZT9zOnZvaWQgMCxwb3M6dGhpcy5jZW50ZXJQb3Msc2l6ZTpbKHgudy0yKnB0LlNhZmVCb3JkZXJQYWRkaW5nKS9vWzBdLCh4LmgtMipwdC5TYWZlQm9yZGVyUGFkZGluZykvb1sxXV0sekluZGV4OmR9KTtjb25zdCBnPW0ubWFwKGI9PihiLnBvcz1bYi5wb3NbMF0tdGhpcy5jZW50ZXJQb3NbMF0sYi5wb3NbMV0tdGhpcy5jZW50ZXJQb3NbMV1dLG5ldyBhZShiKSkpO2guYXBwZW5kKC4uLmcpLGY9PT16dC5TdHJva2UmJmguc2VhbCgpLGEuYXBwZW5kKGgpfWlmKHB8fHl8fFApe2NvbnN0IGc9aD09bnVsbD92b2lkIDA6aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihnKXJldHVybnt4Ok1hdGguZmxvb3IoZy54LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoZy55LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoZy53aWR0aCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoZy5oZWlnaHQrcHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybiB4fWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PXp0LlN0cm9rZXx8ZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0U3Ryb2tlKGUpOnRoaXMuY29tcHV0Tm9tYWwoZSl9Y29tcHV0Tm9tYWwoZSl7bGV0IHQ9dGhpcy53b3JrT3B0aW9ucy50aGlja25lc3M7Y29uc3Qgcj1lLm1hcChuPT4odD1NYXRoLm1heCh0LG4ucmFkaXVzKSxuLnBvaW50KSk7cmV0dXJue3BzOnIscmVjdDpOdChyLHQpfX1jb21wdXRTdHJva2UoZSl7cmV0dXJuIGUubGVuZ3RoPT09MT90aGlzLmNvbXB1dERvdFN0cm9rZShlWzBdKTp0aGlzLmNvbXB1dExpbmVTdHJva2UoZSl9Y29tcHV0TGluZVN0cm9rZShlKXtjb25zdCB0PVtdLHI9W107Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspe2NvbnN0e3BvaW50OmYscmFkaXVzOnZ9PWVbc107bGV0IGQ9Zi52O3M9PT0wJiZlLmxlbmd0aD4xJiYoZD1lW3MrMV0ucG9pbnQudik7Y29uc3QgcD1ldC5QZXIoZCkubXVsKHYpO3QucHVzaCh4dC5TdWIoZixwKSksci5wdXNoKHh0LkFkZChmLHApKX1jb25zdCBuPWVbZS5sZW5ndGgtMV0saT14dC5HZXRTZW1pY2lyY2xlU3Ryb2tlKG4ucG9pbnQsdFt0Lmxlbmd0aC0xXSwtMSw4KSxhPXh0LkdldFNlbWljaXJjbGVTdHJva2UoZVswXS5wb2ludCxyWzBdLC0xLDgpLGw9dC5jb25jYXQoaSxyLnJldmVyc2UoKSxhKTtyZXR1cm57cHM6bCxyZWN0Ok50KGwpfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6cn09ZSxuPXt4OnQueC1yLHk6dC55LXIsdzpyKjIsaDpyKjJ9O3JldHVybntwczp4dC5HZXREb3RTdHJva2UodCxyLDgpLHJlY3Q6bn19dHJhbnNmb3JtRGF0YShlLHQpe2NvbnN0e29wOnIsd29ya1N0YXRlOm59PWU7bGV0IGk9dGhpcy50bXBQb2ludHMubGVuZ3RoLTEsYT1bXTtpZihyIT1udWxsJiZyLmxlbmd0aCYmbil7Y29uc3R7c3Ryb2tlVHlwZTpsLHRoaWNrbmVzczpzfT10aGlzLndvcmtPcHRpb25zLGY9bmV3IFNldDtpPWw9PT16dC5TdHJva2U/dGhpcy51cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlKHIscyxmKTp0aGlzLnVwZGF0ZVRlbXBQb2ludHMocixzLGYpO2NvbnN0IHY9dD90aGlzLnRtcFBvaW50czp0aGlzLnRtcFBvaW50cy5zbGljZShpKTtyZXR1cm4gYT10aGlzLmdldFRhc2tQb2ludHModixzKSx7dGFza3M6YSxlZmZlY3RzOmYsY29uc3VtZUluZGV4Oml9fXJldHVybnt0YXNrczphLGNvbnN1bWVJbmRleDppfX1jb21wdXRSYWRpdXMoZSx0KXtyZXR1cm4gZSouMDMqdCt0Ki41fWdldE1pblooZSx0KXtyZXR1cm4oKHR8fE1hdGgubWF4KDEsTWF0aC5mbG9vcihlKi4zKSkpLWUqLjUpKjEwMC9lLzN9Z2V0VGFza1BvaW50cyhlLHQpe3ZhciB2O2NvbnN0IHI9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCBuPTAsaT1lWzBdLngsYT1lWzBdLnksbD1baSxhXSxzPVtdLGY9ZVswXS50O2Zvcig7bjxlLmxlbmd0aDspe2NvbnN0IGQ9ZVtuXSxwPWQueC1pLHk9ZC55LWEsUD1kLnoseD10P3RoaXMuY29tcHV0UmFkaXVzKFAsdCk6UDtpZihzLnB1c2goe3BvaW50Om5ldyB4dChwLHksUCxlW25dLnYpLHJhZGl1czp4fSksbj4wJiZuPGUubGVuZ3RoLTEpe2NvbnN0IG09ZVtuXS5nZXRBbmdsZUJ5UG9pbnRzKGVbbi0xXSxlW24rMV0pO2lmKG08OTB8fG0+MjcwKXtjb25zdCBPPSh2PXMucG9wKCkpPT1udWxsP3ZvaWQgMDp2LnBvaW50LmNsb25lKCk7TyYmci5wdXNoKHt0YXNrSWQ6Zixwb3M6bCxwb2ludHM6Wy4uLnMse3BvaW50Ok8scmFkaXVzOnh9XX0pLGk9ZVtuXS54LGE9ZVtuXS55LGw9W2ksYV07Y29uc3Qgbz1kLngtaSxoPWQueS1hO3M9W3twb2ludDpuZXcgeHQobyxoLFApLHJhZGl1czp4fV0sZj1EYXRlLm5vdygpfX1uKyt9cmV0dXJuIHIucHVzaCh7dGFza0lkOmYscG9zOmwscG9pbnRzOnN9KSxyfXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUoZSx0LHIpe2NvbnN0IG49RGF0ZS5ub3coKSxpPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgYT1pO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cys9Mil7YT1NYXRoLm1pbihhLGkpO2NvbnN0IGY9dGhpcy50bXBQb2ludHMubGVuZ3RoLHY9bmV3IHh0KGVbc10sZVtzKzFdKTtpZihmPT09MCl7dGhpcy50bXBQb2ludHMucHVzaCh2KTtjb250aW51ZX1jb25zdCBkPWYtMSxwPXRoaXMudG1wUG9pbnRzW2RdLHk9ZXQuU3ViKHYscCkudW5pKCk7aWYodi5pc05lYXIocCx0KSl7aWYocC56PHRoaXMuTUFYX1JFUEVBUil7aWYocC5zZXR6KE1hdGgubWluKHAueisxLHRoaXMuTUFYX1JFUEVBUikpLGE9TWF0aC5taW4oYSxkKSxmPjEpe2xldCBtPWYtMTtmb3IoO20+MDspe2NvbnN0IE89dGhpcy50bXBQb2ludHNbbV0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbbS0xXSksbz1NYXRoLm1heCh0aGlzLnRtcFBvaW50c1ttXS56LXRoaXMudW5pVGhpY2tuZXNzKk8sMCk7aWYodGhpcy50bXBQb2ludHNbbS0xXS56Pj1vKWJyZWFrO3RoaXMudG1wUG9pbnRzW20tMV0uc2V0eihvKSxhPU1hdGgubWluKGEsbS0xKSxtLS19fX1lbHNlIGE9MS8wO2NvbnRpbnVlfXYuc2V0dih5KTtjb25zdCBQPXYuZGlzdGFuY2UocCkseD1NYXRoLm1heChwLnotdGhpcy51bmlUaGlja25lc3MqUCwwKTtmPjEmJmV0LkVxdWFscyh5LHAudiwuMDIpJiYoeD4wfHxwLno8PTApJiYociYmcC50JiZyLmFkZChwLnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGE9TWF0aC5taW4oZCxhKSksdi5zZXR6KHgpLHRoaXMudG1wUG9pbnRzLnB1c2godil9aWYoYT09PTEvMClyZXR1cm4gdGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBsPWk7aWYoYT09PWkpe2w9TWF0aC5tYXgobC0xLDApO2NvbnN0IHM9dGhpcy50bXBQb2ludHNbbF0udDtzJiYocj09bnVsbHx8ci5hZGQocykpfWVsc2V7bGV0IHM9aS0xO2ZvcihsPWE7cz49MDspe2NvbnN0IGY9dGhpcy50bXBQb2ludHNbc10udDtpZihmJiYocj09bnVsbHx8ci5hZGQoZiksczw9YSkpe2w9cyxzPS0xO2JyZWFrfXMtLX19cmV0dXJuIHRoaXMudG1wUG9pbnRzW2xdLnNldFQobiksbH11cGRhdGVUZW1wUG9pbnRzKGUsdCxyKXt2YXIgcztjb25zdCBuPURhdGUubm93KCksaT10aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGE9aTtmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrPTIpe2NvbnN0IHY9dGhpcy50bXBQb2ludHMubGVuZ3RoLGQ9bmV3IHh0KGVbZl0sZVtmKzFdKTtpZih2PT09MCl7dGhpcy50bXBQb2ludHMucHVzaChkKTtjb250aW51ZX1jb25zdCBwPXYtMSx5PXRoaXMudG1wUG9pbnRzW3BdLFA9ZXQuU3ViKGQseSkudW5pKCk7aWYoZC5pc05lYXIoeSx0LzIpKXthPU1hdGgubWluKHAsYSk7Y29udGludWV9ZXQuRXF1YWxzKFAseS52LC4wMikmJihyJiZ5LnQmJnIuYWRkKHkudCksdGhpcy50bXBQb2ludHMucG9wKCksYT1NYXRoLm1pbihwLGEpKSxkLnNldHYoUCksdGhpcy50bXBQb2ludHMucHVzaChkKX1sZXQgbD1pO2lmKGE9PT1pKXtsPU1hdGgubWF4KGwtMSwwKTtjb25zdCBmPXRoaXMudG1wUG9pbnRzW2xdLnQ7ZiYmKHI9PW51bGx8fHIuYWRkKGYpKX1lbHNle2xldCBmPU1hdGgubWluKGktMSxhKTtmb3IobD1hO2Y+PTA7KXtjb25zdCB2PShzPXRoaXMudG1wUG9pbnRzW2ZdKT09bnVsbD92b2lkIDA6cy50O2lmKHYmJihyPT1udWxsfHxyLmFkZCh2KSxmPD1hKSl7bD1mLGY9LTE7YnJlYWt9Zi0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbbF0uc2V0VChuKSxsfXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxyPWUubGVuZ3RoLG49dGhpcy5nZXRNaW5aKHQpO2ZvcihsZXQgaT0wO2k8cjtpKz0yKXtjb25zdCBhPXRoaXMudG1wUG9pbnRzLmxlbmd0aCxsPW5ldyB4dChlW2ldLGVbaSsxXSk7aWYoYT09PTApe3RoaXMudG1wUG9pbnRzLnB1c2gobCk7Y29udGludWV9Y29uc3Qgcz1hLTEsZj10aGlzLnRtcFBvaW50c1tzXSx2PWV0LlN1YihsLGYpLnVuaSgpLGQ9bC5kaXN0YW5jZShmKTtpZihhPjEmJmYuej09PW4pYnJlYWs7aWYobC5pc05lYXIoZix0LzIpKXtpZihyPDMmJmYuejx0aGlzLk1BWF9SRVBFQVImJihmLnNldHooTWF0aC5taW4oZi56KzEsdGhpcy5NQVhfUkVQRUFSKSksYT4xKSl7bGV0IHk9YS0xO2Zvcig7eT4wOyl7Y29uc3QgUD10aGlzLnRtcFBvaW50c1t5XS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1t5LTFdKSx4PU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW3ldLnotdGhpcy51bmlUaGlja25lc3MqUCwtdC80KTtpZih0aGlzLnRtcFBvaW50c1t5LTFdLno+PXgpYnJlYWs7dGhpcy50bXBQb2ludHNbeS0xXS5zZXR6KHgpLHktLX19Y29udGludWV9bC5zZXR2KHYpO2NvbnN0IHA9TWF0aC5tYXgoZi56LXRoaXMudW5pVGhpY2tuZXNzKmQsbik7YT4xJiZldC5FcXVhbHModixmLnYsLjAyKSYmZi56PD0wJiZ0aGlzLnRtcFBvaW50cy5wb3AoKSxsLnNldHoocCksdGhpcy50bXBQb2ludHMucHVzaChsKX19c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7dmFyIGw7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpufT1lLHtzdHJva2VDb2xvcjppfT1yLGE9bi5nZXQodC5uYW1lKTtyZXR1cm4gaSYmKHQudGFnTmFtZT09PSJHUk9VUCI/VWUodCk/dC5zZXRBdHRyaWJ1dGUoImJnY29sb3IiLGkpOnQuY2hpbGRyZW4uZm9yRWFjaChzPT57cy5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixpKSxzLmdldEF0dHJpYnV0ZSgiZmlsbENvbG9yIikmJnMuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGkpfSk6KHQuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsaSksdC5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsaSkpLChsPWE9PW51bGw/dm9pZCAwOmEub3B0KSE9bnVsbCYmbC5zdHJva2VDb2xvciYmKGEub3B0LnN0cm9rZUNvbG9yPWkpKSxhJiZuLnNldEluZm8odC5uYW1lLGEpLHB0LnVwZGF0ZU5vZGVPcHQoZSl9c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCByPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYocil7Y29uc3Qgbj1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3Iobi54LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3Iobi55LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3Iobi53aWR0aCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3Iobi5oZWlnaHQrcHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fX19Y2xhc3MgRW4gZXh0ZW5kcyBwdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuTGFzZXJQZW59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6anQubm9uZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29uc3VtZUluZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe2NvbnN0e2RhdGE6dCxpc1N1YldvcmtlcjpyfT1lLHt3b3JrSWQ6bixvcDppfT10O2lmKChpPT1udWxsP3ZvaWQgMDppLmxlbmd0aCk9PT0wKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudXBkYXRlVGVtcFBvaW50cyhpfHxbXSksdGhpcy5jb25zdW1lSW5kZXg+dGhpcy50bXBQb2ludHMubGVuZ3RoLTQpcmV0dXJue3R5cGU6YXQuTm9uZX07Y29uc3R7c3Ryb2tlQ29sb3I6YSx0aGlja25lc3M6bCxzdHJva2VUeXBlOnN9PXRoaXMud29ya09wdGlvbnMsZj1OdCh0aGlzLnRtcFBvaW50cyxsKTtsZXQgdj0hMTtjb25zdCBkPXRoaXMuc3luY0luZGV4LHA9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO3RoaXMuY29uc3VtZUluZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aC0xLHRoaXMuc3luY1RpbWVzdGFtcD09PTAmJih0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKSk7Y29uc3QgeT17bmFtZTpuPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCksb3BhY2l0eToxLGxpbmVEYXNoOnM9PT16dC5Eb3R0ZWQ/WzEsbCoyXTpzPT09enQuTG9uZ0RvdHRlZD9bbCxsKjJdOnZvaWQgMCxzdHJva2VDb2xvcjphLGxpbmVDYXA6InJvdW5kIixsaW5lV2lkdGg6bCxhbmNob3I6Wy41LC41XX0sUD10aGlzLmdldFRhc2tQb2ludHMocCk7aWYoUC5sZW5ndGgpe2NvbnN0IG09RGF0ZS5ub3coKTttLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZSYmKHY9ITAsdGhpcy5zeW5jVGltZXN0YW1wPW0sdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSxyJiZ0aGlzLmRyYXcoe2F0dHJzOnksdGFza3M6UCxpc0RvdDohMSxsYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXJ9KX1jb25zdCB4PVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZShkKS5mb3JFYWNoKG09Pnt4LnB1c2gobS54LG0ueSl9KSx7cmVjdDp7eDpmLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTpmLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzpmLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6Zi5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX0sdHlwZTphdC5EcmF3V29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6dj9uOnZvaWQgMCxvcDp2P3g6dm9pZCAwLGluZGV4OnY/ZCoyOnZvaWQgMH19Y29uc3VtZUFsbCgpe3ZhciBuO2NvbnN0IGU9KG49dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCk7bGV0IHQ7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoLTE+dGhpcy5jb25zdW1lSW5kZXgpe2xldCBpPXRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuY29uc3VtZUluZGV4KTtjb25zdCBhPWkubGVuZ3RoPT09MSx7c3Ryb2tlQ29sb3I6bCx0aGlja25lc3M6cyxzdHJva2VUeXBlOmZ9PXRoaXMud29ya09wdGlvbnM7aWYoYSl7Y29uc3QgcD10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6aVswXSxyYWRpdXM6cy8yfSk7aT1wLnBzLHQ9cC5yZWN0fWVsc2UgdD1OdCh0aGlzLnRtcFBvaW50cyxzKTtjb25zdCB2PXtuYW1lOmU9PW51bGw/dm9pZCAwOmUudG9TdHJpbmcoKSxmaWxsQ29sb3I6YT9sOnZvaWQgMCxvcGFjaXR5OjEsbGluZURhc2g6Zj09PXp0LkRvdHRlZCYmIWE/WzEscyoyXTpmPT09enQuTG9uZ0RvdHRlZCYmIWE/W3MscyoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6bCxsaW5lQ2FwOmE/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmE/MDpzLGFuY2hvcjpbLjUsLjVdfSxkPXRoaXMuZ2V0VGFza1BvaW50cyhpKTtkLmxlbmd0aCYmdGhpcy5kcmF3KHthdHRyczp2LHRhc2tzOmQsaXNEb3Q6YSxsYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXJ9KX1jb25zdCByPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLnN5bmNJbmRleCkuZm9yRWFjaChpPT57ci5wdXNoKGkueCxpLnkpfSkse3JlY3Q6dCYme3g6dC54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6dC55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6dC53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOnQuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19LHR5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmUsb3A6cixpbmRleDp0aGlzLnN5bmNJbmRleCoyfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIFA7Y29uc3R7b3A6dCxyZXBsYWNlSWQ6cixpc0Z1bGxXb3JrOm59PWUse3N0cm9rZUNvbG9yOmksdGhpY2tuZXNzOmEsc3Ryb2tlVHlwZTpsfT10aGlzLndvcmtPcHRpb25zO2lmKCF0Lmxlbmd0aCl7Y29uc3QgeD1OdCh0aGlzLnRtcFBvaW50cyxhKTtyZXR1cm57eDp4LngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTp4LnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzp4LncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6eC5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX19Y29uc3Qgcz1NYXRoLm1heCgwLHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xKTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModHx8W10pO2xldCBmLHY9dGhpcy50bXBQb2ludHMuc2xpY2Uocyk7Y29uc3QgZD12Lmxlbmd0aD09PTE7aWYoZCl7Y29uc3QgeD10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6dlswXSxyYWRpdXM6YS8yfSk7dj14LnBzLGY9eC5yZWN0fWVsc2UgZj1OdCh0aGlzLnRtcFBvaW50cyxhKTtjb25zdCBwPXtuYW1lOihQPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6UC50b1N0cmluZygpLGZpbGxDb2xvcjpkP2k6dm9pZCAwLG9wYWNpdHk6MSxsaW5lRGFzaDpsPT09enQuRG90dGVkJiYhZD9bMSxhKjJdOmw9PT16dC5Mb25nRG90dGVkJiYhZD9bYSxhKjJdOnZvaWQgMCxzdHJva2VDb2xvcjppLGxpbmVDYXA6ZD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6ZD8wOmEsYW5jaG9yOlsuNSwuNV19LHk9dGhpcy5nZXRUYXNrUG9pbnRzKHYpO2lmKHkubGVuZ3RoKXtjb25zdCB4PW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyO3RoaXMuZHJhdyh7YXR0cnM6cCx0YXNrczp5LGlzRG90OmQscmVwbGFjZUlkOnIsbGF5ZXI6eH0pfXJldHVybnt4OmYueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OmYueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OmYudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpmLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6cn09ZSxuPXt4OnQueC1yLHk6dC55LXIsdzpyKjIsaDpyKjJ9O3JldHVybntwczp4dC5HZXREb3RTdHJva2UodCxyLDgpLHJlY3Q6bn19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aDtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrPTIpe2lmKHQpe2NvbnN0IG49dGhpcy50bXBQb2ludHMuc2xpY2UoLTEpWzBdO24mJm4ueD09PWVbcl0mJm4ueT09PWVbcisxXSYmdGhpcy50bXBQb2ludHMucG9wKCl9dGhpcy50bXBQb2ludHMucHVzaChuZXcgeHQoZVtyXSxlW3IrMV0pKX19YXN5bmMgZHJhdyhlKXtjb25zdHthdHRyczp0LHRhc2tzOnIsaXNEb3Q6bixsYXllcjppfT1lLHtkdXJhdGlvbjphfT10aGlzLndvcmtPcHRpb25zO2Zvcihjb25zdCBsIG9mIHIpe2NvbnN0IHM9bmV3IGFlLHtwb3M6Zixwb2ludHM6dn09bDtsZXQgZDtuP2Q9dmUodiwhMCk6ZD12ZSh2LCExKSxzLmF0dHIoey4uLnQscG9zOmYsZH0pO2NvbnN0e3ZlcnRleDpwLGZyYWdtZW50Onl9PXRoaXMud29ya09wdGlvbnM7aWYocCYmeSl7Y29uc3QgUD1pLnJlbmRlcmVyLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDpwLGZyYWdtZW50Onl9KSx7d2lkdGg6eCxoZWlnaHQ6bX09aS5nZXRSZXNvbHV0aW9uKCk7cy5zZXRVbmlmb3Jtcyh7dV90aW1lOjAsdV9yZXNvbHV0aW9uOlt4LG1dfSkscy5zZXRQcm9ncmFtKFApfWkuYXBwZW5kQ2hpbGQocykscy50cmFuc2l0aW9uKGEpLmF0dHIoe3NjYWxlOm4/Wy4xLC4xXTpbMSwxXSxsaW5lV2lkdGg6bj8wOjF9KS50aGVuKCgpPT57cy5yZW1vdmUoKX0pfX1nZXRUYXNrUG9pbnRzKGUpe3ZhciBzO2NvbnN0IHQ9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCByPTAsbj1lWzBdLngsaT1lWzBdLnksYT1bbixpXSxsPVtdO2Zvcig7cjxlLmxlbmd0aDspe2NvbnN0IGY9ZVtyXSx2PWYueC1uLGQ9Zi55LWk7aWYobC5wdXNoKG5ldyB4dCh2LGQpKSxyPjAmJnI8ZS5sZW5ndGgtMSl7Y29uc3QgcD1lW3JdLmdldEFuZ2xlQnlQb2ludHMoZVtyLTFdLGVbcisxXSk7aWYocDw5MHx8cD4yNzApe2NvbnN0IHk9KHM9bC5wb3AoKSk9PW51bGw/dm9pZCAwOnMuY2xvbmUoKTt5JiZ0LnB1c2goe3BvczphLHBvaW50czpbLi4ubCx5XX0pLG49ZVtyXS54LGk9ZVtyXS55LGE9W24saV07Y29uc3QgUD1mLngtbix4PWYueS1pO2w9W25ldyB4dChQLHgpXX19cisrfXJldHVybiB0LnB1c2goe3BvczphLHBvaW50czpsfSksdH1yZW1vdmVMb2NhbCgpe31yZW1vdmVTZXJ2aWNlKGUpe2xldCB0O2NvbnN0IHI9W107cmV0dXJuIHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmZvckVhY2gobj0+e2lmKG4ubmFtZT09PWUpe2NvbnN0IGk9bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0PWJ0KHQse3g6aS54LHk6aS55LHc6aS53aWR0aCxoOmkuaGVpZ2h0fSksci5wdXNoKG4pfX0pLHIubGVuZ3RoJiZyLmZvckVhY2gobj0+bi5yZW1vdmUoKSksdH19dmFyIFloPUdlO0dlLnBvbHlsaW5lPUdlLEdlLnBvbHlnb249WGg7ZnVuY3Rpb24gR2UodSxlLHQpe3ZhciByPXUubGVuZ3RoLG49eWUodVswXSxlKSxpPVtdLGEsbCxzLGYsdjtmb3IodHx8KHQ9W10pLGE9MTthPHI7YSsrKXtmb3IobD11W2EtMV0scz11W2FdLGY9dj15ZShzLGUpOzspaWYobnxmKXtpZihuJmYpYnJlYWs7bj8obD1jcihsLHMsbixlKSxuPXllKGwsZSkpOihzPWNyKGwscyxmLGUpLGY9eWUocyxlKSl9ZWxzZXtpLnB1c2gobCksZiE9PXY/KGkucHVzaChzKSxhPHItMSYmKHQucHVzaChpKSxpPVtdKSk6YT09PXItMSYmaS5wdXNoKHMpO2JyZWFrfW49dn1yZXR1cm4gaS5sZW5ndGgmJnQucHVzaChpKSx0fWZ1bmN0aW9uIFhoKHUsZSl7dmFyIHQscixuLGksYSxsLHM7Zm9yKHI9MTtyPD04O3IqPTIpe2Zvcih0PVtdLG49dVt1Lmxlbmd0aC0xXSxpPSEoeWUobixlKSZyKSxhPTA7YTx1Lmxlbmd0aDthKyspbD11W2FdLHM9ISh5ZShsLGUpJnIpLHMhPT1pJiZ0LnB1c2goY3IobixsLHIsZSkpLHMmJnQucHVzaChsKSxuPWwsaT1zO2lmKHU9dCwhdS5sZW5ndGgpYnJlYWt9cmV0dXJuIHR9ZnVuY3Rpb24gY3IodSxlLHQscil7cmV0dXJuIHQmOD9bdVswXSsoZVswXS11WzBdKSooclszXS11WzFdKS8oZVsxXS11WzFdKSxyWzNdXTp0JjQ/W3VbMF0rKGVbMF0tdVswXSkqKHJbMV0tdVsxXSkvKGVbMV0tdVsxXSksclsxXV06dCYyP1tyWzJdLHVbMV0rKGVbMV0tdVsxXSkqKHJbMl0tdVswXSkvKGVbMF0tdVswXSldOnQmMT9bclswXSx1WzFdKyhlWzFdLXVbMV0pKihyWzBdLXVbMF0pLyhlWzBdLXVbMF0pXTpudWxsfWZ1bmN0aW9uIHllKHUsZSl7dmFyIHQ9MDtyZXR1cm4gdVswXTxlWzBdP3R8PTE6dVswXT5lWzJdJiYodHw9MiksdVsxXTxlWzFdP3R8PTQ6dVsxXT5lWzNdJiYodHw9OCksdH12YXIgWmg9Y2UoWWgpO2NsYXNzIEp0IGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6anQubm9uZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpkdC5FcmFzZXJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VydmljZVdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ybGRQb3NpdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFNjYWxpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZXJhc2VyUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJQb2x5bGluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuc2VydmljZVdvcms9dCx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy53b3JsZFBvc2l0aW9uPXRoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb24sdGhpcy53b3JsZFNjYWxpbmc9dGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nfWNvbWJpbmVDb25zdW1lKCl7fWNvbnN1bWVTZXJ2aWNlKCl7fXNldFdvcmtPcHRpb25zKGUpe3N1cGVyLnNldFdvcmtPcHRpb25zKGUpfWNyZWF0ZUVyYXNlclJlY3QoZSl7Y29uc3QgdD1lWzBdKnRoaXMud29ybGRTY2FsaW5nWzBdK3RoaXMud29ybGRQb3NpdGlvblswXSxyPWVbMV0qdGhpcy53b3JsZFNjYWxpbmdbMV0rdGhpcy53b3JsZFBvc2l0aW9uWzFdLHt3aWR0aDpuLGhlaWdodDppfT1KdC5lcmFzZXJTaXplc1t0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc107dGhpcy5lcmFzZXJSZWN0PXt4OnQtbiouNSx5OnItaSouNSx3Om4saDppfSx0aGlzLmVyYXNlclBvbHlsaW5lPVt0aGlzLmVyYXNlclJlY3QueCx0aGlzLmVyYXNlclJlY3QueSx0aGlzLmVyYXNlclJlY3QueCt0aGlzLmVyYXNlclJlY3Qudyx0aGlzLmVyYXNlclJlY3QueSt0aGlzLmVyYXNlclJlY3QuaF19Y29tcHV0UmVjdENlbnRlclBvaW50cygpe2NvbnN0IGU9dGhpcy50bXBQb2ludHMuc2xpY2UoLTIpO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTQpe2NvbnN0IHQ9bmV3IGV0KHRoaXMudG1wUG9pbnRzWzBdLHRoaXMudG1wUG9pbnRzWzFdKSxyPW5ldyBldCh0aGlzLnRtcFBvaW50c1syXSx0aGlzLnRtcFBvaW50c1szXSksbj1ldC5TdWIocix0KS51bmkoKSxpPWV0LkRpc3QodCxyKSx7d2lkdGg6YSxoZWlnaHQ6bH09SnQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdLHM9TWF0aC5taW4oYSxsKSxmPU1hdGgucm91bmQoaS9zKTtpZihmPjEpe2NvbnN0IHY9W107Zm9yKGxldCBkPTA7ZDxmO2QrKyl7Y29uc3QgcD1ldC5NdWwobixkKnMpO3YucHVzaCh0aGlzLnRtcFBvaW50c1swXStwLngsdGhpcy50bXBQb2ludHNbMV0rcC55KX1yZXR1cm4gdi5jb25jYXQoZSl9fXJldHVybiBlfWlzTmVhcihlLHQpe2NvbnN0IHI9bmV3IGV0KGVbMF0sZVsxXSksbj1uZXcgZXQodFswXSx0WzFdKSx7d2lkdGg6aSxoZWlnaHQ6YX09SnQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdO3JldHVybiBldC5EaXN0KHIsbik8TWF0aC5oeXBvdChpLGEpKi41fWN1dFBvbHlsaW5lKGUsdCl7bGV0IHI9W3RdLG49MDtmb3IoO248ZS5sZW5ndGg7KXtjb25zdCBsPWVbbl07aWYobC5sZW5ndGg8MilicmVhaztyPWkocixsKSxuKyt9cmV0dXJuIHI7ZnVuY3Rpb24gaShsLHMpe2NvbnN0IGY9bDtmb3IobGV0IHY9MDt2PGwubGVuZ3RoO3YrKyl7Y29uc3QgZD1sW3ZdLHA9ZC5maW5kSW5kZXgoKHksUCk9PlA8ZC5sZW5ndGgtMT9hKFt5LGRbUCsxXV0sW3NbMF0sc1sxXV0pOiExKTtpZihwIT09LTEmJnA+LTEpe2NvbnN0IHk9W10sUD1kLnNsaWNlKDAscCsxKTtpZihldC5FcXVhbHMoZFtwXSxzWzBdKXx8UC5wdXNoKHNbMF0uY2xvbmUoKS5zZXR6KGRbcF0ueikpLFAubGVuZ3RoPjEmJnkucHVzaChQKSxwK3MubGVuZ3RoLTE8ZC5sZW5ndGgtMSl7Y29uc3QgeD1wK3MubGVuZ3RoLTEsbT1kLnNsaWNlKHgpLE89c1tzLmxlbmd0aC0xXTtldC5FcXVhbHMoZFt4XSxPKXx8bS51bnNoaWZ0KE8uY2xvbmUoKS5zZXR6KGRbeF0ueikpLG0ubGVuZ3RoPjEmJnkucHVzaChtKX1yZXR1cm4gZi5zcGxpY2UodiwxLC4uLnkpLGZ9fXJldHVybiBmfWZ1bmN0aW9uIGEobCxzKXtjb25zdCBmPWV0LlN1YihsWzFdLGxbMF0pLHY9ZXQuU3ViKHNbMV0sc1swXSksZD1ldC5TdWIoc1swXSxsWzBdKTtyZXR1cm4gTWF0aC5hYnMoZXQuQ3ByKGYsdikpPC4xJiZNYXRoLmFicyhldC5DcHIoZixkKSk8LjF9fWlzU2FtZVBvaW50KGUsdCl7cmV0dXJuIGVbMF09PT10WzBdJiZlWzFdPT09dFsxXX10cmFuc2xhdGVJbnRlcnNlY3QoZSl7Y29uc3QgdD1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3Qgbj1lW3JdLmZpbHRlcigobCxzLGYpPT4hKHM+MCYmdGhpcy5pc1NhbWVQb2ludChsLGZbcy0xXSkpKSxpPVtdO2xldCBhPTA7Zm9yKDthPG4ubGVuZ3RoOyl7Y29uc3QgbD1uW2FdLHM9bmV3IGV0KGxbMF0sbFsxXSk7aS5wdXNoKHMpLGErK310LnB1c2goaSl9cmV0dXJuIHR9aXNMaW5lRXJhc2VyKGUsdCl7cmV0dXJuIShlPT09ZHQuUGVuY2lsJiYhdCl9cmVtb3ZlKGUpe2NvbnN0e2N1ck5vZGVNYXA6dCxyZW1vdmVJZHM6cixuZXdXb3JrRGF0YXM6bn09ZSx7aXNMaW5lOml9PXRoaXMud29ya09wdGlvbnM7bGV0IGE7Zm9yKGNvbnN0W2wsc11vZiB0LmVudHJpZXMoKSlpZihzLnJlY3QmJnRoaXMuZXJhc2VyUmVjdCYmdGhpcy5lcmFzZXJQb2x5bGluZSYmeGUodGhpcy5lcmFzZXJSZWN0LHMucmVjdCkpe2NvbnN0e29wOmYsdG9vbHNUeXBlOnZ9PXMsZD10aGlzLmlzTGluZUVyYXNlcih2LGkpLHA9W10seT1bXTtmb3IobGV0IHg9MDt4PGYubGVuZ3RoO3grPTMpe2NvbnN0IG09bmV3IGV0KGZbeF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLGZbeCsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0sZlt4KzJdKTt5LnB1c2gobSkscC5wdXNoKG5ldyB4dChtLngsbS55KSl9Y29uc3QgUD1wLmxlbmd0aCYmTnQocCl8fHMucmVjdDtpZih4ZShQLHRoaXMuZXJhc2VyUmVjdCkpe2lmKHkubGVuZ3RoPjEpe2NvbnN0IHg9WmgucG9seWxpbmUoeS5tYXAobT0+bS5YWSksdGhpcy5lcmFzZXJQb2x5bGluZSk7aWYoeC5sZW5ndGgmJihyLmFkZChzLm5hbWUpLCFkKSl7Y29uc3QgbT10aGlzLnRyYW5zbGF0ZUludGVyc2VjdCh4KSxPPXRoaXMuY3V0UG9seWxpbmUobSx5KTtmb3IobGV0IG89MDtvPE8ubGVuZ3RoO28rKyl7Y29uc3QgaD1gJHtsfV9zXyR7b31gLGM9W107T1tvXS5mb3JFYWNoKGc9PntjLnB1c2goKGcueC10aGlzLndvcmxkUG9zaXRpb25bMF0pL3RoaXMud29ybGRTY2FsaW5nWzBdLChnLnktdGhpcy53b3JsZFBvc2l0aW9uWzFdKS90aGlzLndvcmxkU2NhbGluZ1sxXSxnLnopfSkscy5vcHQmJnMudG9vbHNUeXBlJiZ0aGlzLnZOb2RlcyYmKHRoaXMudk5vZGVzLnNldEluZm8oaCx7cmVjdDpQLG9wOmMsb3B0OnMub3B0LGNhblJvdGF0ZTpzLmNhblJvdGF0ZSxzY2FsZVR5cGU6cy5zY2FsZVR5cGUsdG9vbHNUeXBlOnMudG9vbHNUeXBlfSksbi5zZXQoaCx7d29ya0lkOmgsb3A6YyxvcHQ6cy5vcHQsdG9vbHNUeXBlOnMudG9vbHNUeXBlfSkpfX19ZWxzZSByLmFkZChzLm5hbWUpO2E9YnQoYSxQKX19cmV0dXJuIHIuZm9yRWFjaChsPT57dmFyIHM7cmV0dXJuKHM9dGhpcy52Tm9kZXMpPT1udWxsP3ZvaWQgMDpzLmRlbGV0ZShsKX0pLGEmJihhLngtPXB0LlNhZmVCb3JkZXJQYWRkaW5nLGEueS09cHQuU2FmZUJvcmRlclBhZGRpbmcsYS53Kz1wdC5TYWZlQm9yZGVyUGFkZGluZyoyLGEuaCs9cHQuU2FmZUJvcmRlclBhZGRpbmcqMiksYX1jb25zdW1lKGUpe2NvbnN0e29wOnR9PWUuZGF0YTtpZighdHx8dC5sZW5ndGg9PT0wKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0IHI9dGhpcy50bXBQb2ludHMubGVuZ3RoO2lmKHI+MSYmdGhpcy5pc05lYXIoW3RbMF0sdFsxXV0sW3RoaXMudG1wUG9pbnRzW3ItMl0sdGhpcy50bXBQb2ludHNbci0xXV0pKXJldHVybnt0eXBlOmF0Lk5vbmV9O3I9PT00JiYodGhpcy50bXBQb2ludHMuc2hpZnQoKSx0aGlzLnRtcFBvaW50cy5zaGlmdCgpKSx0aGlzLnRtcFBvaW50cy5wdXNoKHRbMF0sdFsxXSk7Y29uc3Qgbj10aGlzLmNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKTtsZXQgaTtjb25zdCBhPW5ldyBTZXQsbD1uZXcgTWFwO3RoaXMudk5vZGVzLnNldFRhcmdldCgpO2NvbnN0IHM9dGhpcy5nZXRVbkxvY2tOb2RlTWFwKHRoaXMudk5vZGVzLmdldExhc3RUYXJnZXQoKSk7Zm9yKGxldCBmPTA7ZjxuLmxlbmd0aC0xO2YrPTIpe3RoaXMuY3JlYXRlRXJhc2VyUmVjdChuLnNsaWNlKGYsZisyKSk7Y29uc3Qgdj10aGlzLnJlbW92ZSh7Y3VyTm9kZU1hcDpzLHJlbW92ZUlkczphLG5ld1dvcmtEYXRhczpsfSk7aT1idChpLHYpfWlmKHRoaXMudk5vZGVzLmRlbGV0ZUxhc3RUYXJnZXQoKSxpJiZhLnNpemUpe2Zvcihjb25zdCBmIG9mIGwua2V5cygpKWEuaGFzKGYpJiZsLmRlbGV0ZShmKTtyZXR1cm57dHlwZTphdC5SZW1vdmVOb2RlLGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6aSxyZW1vdmVJZHM6Wy4uLmFdLG5ld1dvcmtEYXRhczpsfX1yZXR1cm57dHlwZTphdC5Ob25lfX1jb25zdW1lQWxsKGUpe3JldHVybiB0aGlzLmNvbnN1bWUoZSl9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1nZXRVbkxvY2tOb2RlTWFwKGUpe3ZhciB0O2lmKHRoaXMuc2VydmljZVdvcmspe2NvbnN0IHI9WXQoZSksbj10aGlzLnNlcnZpY2VXb3JrLnNlbGVjdG9yV29ya1NoYXBlcyxpPXRoaXMuc2VydmljZVdvcmsud29ya1NoYXBlcztmb3IoY29uc3QgYSBvZiBuLnZhbHVlcygpKWlmKCh0PWEuc2VsZWN0SWRzKSE9bnVsbCYmdC5sZW5ndGgpZm9yKGNvbnN0IGwgb2YgYS5zZWxlY3RJZHMpci5kZWxldGUobCk7Zm9yKGNvbnN0IGEgb2YgaS5rZXlzKCkpci5kZWxldGUoYSk7cmV0dXJuIHJ9cmV0dXJuIGV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShKdCwiZXJhc2VyU2l6ZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpPYmplY3QuZnJlZXplKFtPYmplY3QuZnJlZXplKHt3aWR0aDoxOCxoZWlnaHQ6MjZ9KSxPYmplY3QuZnJlZXplKHt3aWR0aDoyNixoZWlnaHQ6MzR9KSxPYmplY3QuZnJlZXplKHt3aWR0aDozNCxoZWlnaHQ6NTB9KV0pfSk7Y29uc3QgSmg9IisrIixRaD0ic2VsZWN0b3IiLGtoPSJhbGwiO3ZhciBxaD0iX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyI7ZnVuY3Rpb24gX2godSl7cmV0dXJuIHRoaXMuX19kYXRhX18uc2V0KHUscWgpLHRoaXN9dmFyIHRkPV9oO2Z1bmN0aW9uIGVkKHUpe3JldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh1KX12YXIgcmQ9ZWQsbmQ9TXIsaWQ9dGQsc2Q9cmQ7ZnVuY3Rpb24gSGUodSl7dmFyIGU9LTEsdD11PT1udWxsPzA6dS5sZW5ndGg7Zm9yKHRoaXMuX19kYXRhX189bmV3IG5kOysrZTx0Oyl0aGlzLmFkZCh1W2VdKX1IZS5wcm90b3R5cGUuYWRkPUhlLnByb3RvdHlwZS5wdXNoPWlkLEhlLnByb3RvdHlwZS5oYXM9c2Q7dmFyIG9kPUhlO2Z1bmN0aW9uIGFkKHUsZSl7Zm9yKHZhciB0PS0xLHI9dT09bnVsbD8wOnUubGVuZ3RoOysrdDxyOylpZihlKHVbdF0sdCx1KSlyZXR1cm4hMDtyZXR1cm4hMX12YXIgbGQ9YWQ7ZnVuY3Rpb24gY2QodSxlKXtyZXR1cm4gdS5oYXMoZSl9dmFyIHVkPWNkLGZkPW9kLGhkPWxkLGRkPXVkLGdkPTEscGQ9MjtmdW5jdGlvbiBtZCh1LGUsdCxyLG4saSl7dmFyIGE9dCZnZCxsPXUubGVuZ3RoLHM9ZS5sZW5ndGg7aWYobCE9cyYmIShhJiZzPmwpKXJldHVybiExO3ZhciBmPWkuZ2V0KHUpLHY9aS5nZXQoZSk7aWYoZiYmdilyZXR1cm4gZj09ZSYmdj09dTt2YXIgZD0tMSxwPSEwLHk9dCZwZD9uZXcgZmQ6dm9pZCAwO2ZvcihpLnNldCh1LGUpLGkuc2V0KGUsdSk7KytkPGw7KXt2YXIgUD11W2RdLHg9ZVtkXTtpZihyKXZhciBtPWE/cih4LFAsZCxlLHUsaSk6cihQLHgsZCx1LGUsaSk7aWYobSE9PXZvaWQgMCl7aWYobSljb250aW51ZTtwPSExO2JyZWFrfWlmKHkpe2lmKCFoZChlLGZ1bmN0aW9uKE8sbyl7aWYoIWRkKHksbykmJihQPT09T3x8bihQLE8sdCxyLGkpKSlyZXR1cm4geS5wdXNoKG8pfSkpe3A9ITE7YnJlYWt9fWVsc2UgaWYoIShQPT09eHx8bihQLHgsdCxyLGkpKSl7cD0hMTticmVha319cmV0dXJuIGkuZGVsZXRlKHUpLGkuZGVsZXRlKGUpLHB9dmFyIEFuPW1kO2Z1bmN0aW9uIHZkKHUpe3ZhciBlPS0xLHQ9QXJyYXkodS5zaXplKTtyZXR1cm4gdS5mb3JFYWNoKGZ1bmN0aW9uKHIsbil7dFsrK2VdPVtuLHJdfSksdH12YXIgeWQ9dmQ7ZnVuY3Rpb24gU2QodSl7dmFyIGU9LTEsdD1BcnJheSh1LnNpemUpO3JldHVybiB1LmZvckVhY2goZnVuY3Rpb24ocil7dFsrK2VdPXJ9KSx0fXZhciB4ZD1TZCxDbj1SZSxSbj1xcixPZD1WZSxiZD1BbixQZD15ZCxUZD14ZCxNZD0xLEVkPTIsQWQ9IltvYmplY3QgQm9vbGVhbl0iLENkPSJbb2JqZWN0IERhdGVdIixSZD0iW29iamVjdCBFcnJvcl0iLElkPSJbb2JqZWN0IE1hcF0iLExkPSJbb2JqZWN0IE51bWJlcl0iLERkPSJbb2JqZWN0IFJlZ0V4cF0iLHdkPSJbb2JqZWN0IFNldF0iLE5kPSJbb2JqZWN0IFN0cmluZ10iLEJkPSJbb2JqZWN0IFN5bWJvbF0iLGpkPSJbb2JqZWN0IEFycmF5QnVmZmVyXSIsV2Q9IltvYmplY3QgRGF0YVZpZXddIixJbj1Dbj9Dbi5wcm90b3R5cGU6dm9pZCAwLHVyPUluP0luLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIEZkKHUsZSx0LHIsbixpLGEpe3N3aXRjaCh0KXtjYXNlIFdkOmlmKHUuYnl0ZUxlbmd0aCE9ZS5ieXRlTGVuZ3RofHx1LmJ5dGVPZmZzZXQhPWUuYnl0ZU9mZnNldClyZXR1cm4hMTt1PXUuYnVmZmVyLGU9ZS5idWZmZXI7Y2FzZSBqZDpyZXR1cm4hKHUuYnl0ZUxlbmd0aCE9ZS5ieXRlTGVuZ3RofHwhaShuZXcgUm4odSksbmV3IFJuKGUpKSk7Y2FzZSBBZDpjYXNlIENkOmNhc2UgTGQ6cmV0dXJuIE9kKCt1LCtlKTtjYXNlIFJkOnJldHVybiB1Lm5hbWU9PWUubmFtZSYmdS5tZXNzYWdlPT1lLm1lc3NhZ2U7Y2FzZSBEZDpjYXNlIE5kOnJldHVybiB1PT1lKyIiO2Nhc2UgSWQ6dmFyIGw9UGQ7Y2FzZSB3ZDp2YXIgcz1yJk1kO2lmKGx8fChsPVRkKSx1LnNpemUhPWUuc2l6ZSYmIXMpcmV0dXJuITE7dmFyIGY9YS5nZXQodSk7aWYoZilyZXR1cm4gZj09ZTtyfD1FZCxhLnNldCh1LGUpO3ZhciB2PWJkKGwodSksbChlKSxyLG4saSxhKTtyZXR1cm4gYS5kZWxldGUodSksdjtjYXNlIEJkOmlmKHVyKXJldHVybiB1ci5jYWxsKHUpPT11ci5jYWxsKGUpfXJldHVybiExfXZhciBVZD1GZCxMbj1WciwkZD0xLHpkPU9iamVjdC5wcm90b3R5cGUsR2Q9emQuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gSGQodSxlLHQscixuLGkpe3ZhciBhPXQmJGQsbD1Mbih1KSxzPWwubGVuZ3RoLGY9TG4oZSksdj1mLmxlbmd0aDtpZihzIT12JiYhYSlyZXR1cm4hMTtmb3IodmFyIGQ9cztkLS07KXt2YXIgcD1sW2RdO2lmKCEoYT9wIGluIGU6R2QuY2FsbChlLHApKSlyZXR1cm4hMX12YXIgeT1pLmdldCh1KSxQPWkuZ2V0KGUpO2lmKHkmJlApcmV0dXJuIHk9PWUmJlA9PXU7dmFyIHg9ITA7aS5zZXQodSxlKSxpLnNldChlLHUpO2Zvcih2YXIgbT1hOysrZDxzOyl7cD1sW2RdO3ZhciBPPXVbcF0sbz1lW3BdO2lmKHIpdmFyIGg9YT9yKG8sTyxwLGUsdSxpKTpyKE8sbyxwLHUsZSxpKTtpZighKGg9PT12b2lkIDA/Tz09PW98fG4oTyxvLHQscixpKTpoKSl7eD0hMTticmVha31tfHwobT1wPT0iY29uc3RydWN0b3IiKX1pZih4JiYhbSl7dmFyIGM9dS5jb25zdHJ1Y3RvcixnPWUuY29uc3RydWN0b3I7YyE9ZyYmImNvbnN0cnVjdG9yImluIHUmJiJjb25zdHJ1Y3RvciJpbiBlJiYhKHR5cGVvZiBjPT0iZnVuY3Rpb24iJiZjIGluc3RhbmNlb2YgYyYmdHlwZW9mIGc9PSJmdW5jdGlvbiImJmcgaW5zdGFuY2VvZiBnKSYmKHg9ITEpfXJldHVybiBpLmRlbGV0ZSh1KSxpLmRlbGV0ZShlKSx4fXZhciBLZD1IZCxmcj1FcixWZD1BbixZZD1VZCxYZD1LZCxEbj1XZSx3bj13ZSxObj1aZSxaZD1CcixKZD0xLEJuPSJbb2JqZWN0IEFyZ3VtZW50c10iLGpuPSJbb2JqZWN0IEFycmF5XSIsS2U9IltvYmplY3QgT2JqZWN0XSIsUWQ9T2JqZWN0LnByb3RvdHlwZSxXbj1RZC5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBrZCh1LGUsdCxyLG4saSl7dmFyIGE9d24odSksbD13bihlKSxzPWE/am46RG4odSksZj1sP2puOkRuKGUpO3M9cz09Qm4/S2U6cyxmPWY9PUJuP0tlOmY7dmFyIHY9cz09S2UsZD1mPT1LZSxwPXM9PWY7aWYocCYmTm4odSkpe2lmKCFObihlKSlyZXR1cm4hMTthPSEwLHY9ITF9aWYocCYmIXYpcmV0dXJuIGl8fChpPW5ldyBmciksYXx8WmQodSk/VmQodSxlLHQscixuLGkpOllkKHUsZSxzLHQscixuLGkpO2lmKCEodCZKZCkpe3ZhciB5PXYmJlduLmNhbGwodSwiX193cmFwcGVkX18iKSxQPWQmJlduLmNhbGwoZSwiX193cmFwcGVkX18iKTtpZih5fHxQKXt2YXIgeD15P3UudmFsdWUoKTp1LG09UD9lLnZhbHVlKCk6ZTtyZXR1cm4gaXx8KGk9bmV3IGZyKSxuKHgsbSx0LHIsaSl9fXJldHVybiBwPyhpfHwoaT1uZXcgZnIpLFhkKHUsZSx0LHIsbixpKSk6ITF9dmFyIHFkPWtkLF9kPXFkLEZuPV90O2Z1bmN0aW9uIFVuKHUsZSx0LHIsbil7cmV0dXJuIHU9PT1lPyEwOnU9PW51bGx8fGU9PW51bGx8fCFGbih1KSYmIUZuKGUpP3UhPT11JiZlIT09ZTpfZCh1LGUsdCxyLFVuLG4pfXZhciB0Zz1VbixlZz10ZztmdW5jdGlvbiByZyh1LGUpe3JldHVybiBlZyh1LGUpfXZhciBuZz1yZywkbj1jZShuZyk7Y2xhc3MgSXQgZXh0ZW5kcyBwdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuU2VsZWN0b3J9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VsZWN0SWRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlbGVjdG9yQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3Ryb2tlQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZmlsbENvbG9yIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFNlbGVjdFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuVGV4dEVkaXQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Mb2NrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6anQuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2hhcGVPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidGV4dE9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpc0xvY2tlZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdH1jb21wdXRTZWxlY3RvcihlPSEwKXtjb25zdCB0PU50KHRoaXMudG1wUG9pbnRzKTtpZih0Lnc9PT0wfHx0Lmg9PT0wKXJldHVybntzZWxlY3RJZHM6W10saW50ZXJzZWN0UmVjdDp2b2lkIDAsc3ViTm9kZU1hcDpuZXcgTWFwfTtjb25zdHtyZWN0UmFuZ2U6cixub2RlUmFuZ2U6bn09dGhpcy52Tm9kZXMuZ2V0UmVjdEludGVyc2VjdFJhbmdlKHQsZSk7cmV0dXJue3NlbGVjdElkczpbLi4ubi5rZXlzKCldLGludGVyc2VjdFJlY3Q6cixzdWJOb2RlTWFwOm59fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGgscj1lLmxlbmd0aDtpZihyPjEpe2NvbnN0IG49bmV3IHh0KGVbci0yXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSxlW3ItMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0pO3Q9PT0yP3RoaXMudG1wUG9pbnRzLnNwbGljZSgxLDEsbik6dGhpcy50bXBQb2ludHMucHVzaChuKX19ZHJhd1NlbGVjdG9yKGUpe2NvbnN0e2RyYXdSZWN0OnQsc3ViTm9kZU1hcDpyLHNlbGVjdG9ySWQ6bixsYXllcjppLGlzU2VydmljZTphfT1lLGw9bmV3IHRlKHtwb3M6W3QueCx0LnldLGFuY2hvcjpbMCwwXSxzaXplOlt0LncsdC5oXSxpZDpuLG5hbWU6bix6SW5kZXg6MWUzfSkscz1bXTtpZihhKXtjb25zdCBmPW5ldyBhcih7bm9ybWFsaXplOiEwLHBvczpbdC53LzIsdC5oLzJdLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOnRoaXMuc2VsZWN0b3JDb2xvcnx8dGhpcy53b3JrT3B0aW9ucy5zdHJva2VDb2xvcix3aWR0aDp0LncsaGVpZ2h0OnQuaCxuYW1lOkl0LnNlbGVjdG9yQm9yZGVySWR9KTtzLnB1c2goZil9ci5mb3JFYWNoKChmLHYpPT57Y29uc3QgZD1bZi5yZWN0LngrZi5yZWN0LncvMi10LngsZi5yZWN0LnkrZi5yZWN0LmgvMi10LnldLHA9bmV3IGFyKHtub3JtYWxpemU6ITAscG9zOmQsbGluZVdpZHRoOjEsc3Ryb2tlQ29sb3I6ci5zaXplPjE/dGhpcy5zZWxlY3RvckNvbG9yfHx0aGlzLndvcmtPcHRpb25zLnN0cm9rZUNvbG9yOnZvaWQgMCx3aWR0aDpmLnJlY3QudyxoZWlnaHQ6Zi5yZWN0LmgsaWQ6YHNlbGVjdG9yLSR7dn1gLG5hbWU6YHNlbGVjdG9yLSR7dn1gfSk7cy5wdXNoKHApfSkscyYmbC5hcHBlbmQoLi4ucyksKGk9PW51bGw/dm9pZCAwOmkucGFyZW50KS5hcHBlbmRDaGlsZChsKX1kcmF3KGUsdCxyLG49ITEpe3ZhciBsLHM7Y29uc3R7aW50ZXJzZWN0UmVjdDppLHN1Yk5vZGVNYXA6YX09cjsocz0obD10LnBhcmVudCk9PW51bGw/dm9pZCAwOmwuZ2V0RWxlbWVudEJ5SWQoZSkpPT1udWxsfHxzLnJlbW92ZSgpLGkmJnRoaXMuZHJhd1NlbGVjdG9yKHtkcmF3UmVjdDppLHN1Yk5vZGVNYXA6YSxzZWxlY3RvcklkOmUsbGF5ZXI6dCxpc1NlcnZpY2U6bn0pfWdldFNlbGVjdGVvckluZm8oZSl7dGhpcy5zY2FsZVR5cGU9anQuYWxsLHRoaXMuY2FuUm90YXRlPSExLHRoaXMudGV4dE9wdD12b2lkIDAsdGhpcy5zdHJva2VDb2xvcj12b2lkIDAsdGhpcy5maWxsQ29sb3I9dm9pZCAwLHRoaXMuY2FuVGV4dEVkaXQ9ITEsdGhpcy5jYW5Mb2NrPSExLHRoaXMuaXNMb2NrZWQ9ITEsdGhpcy50b29sc1R5cGVzPXZvaWQgMCx0aGlzLnNoYXBlT3B0PXZvaWQgMDtjb25zdCB0PW5ldyBTZXQ7bGV0IHI7Zm9yKGNvbnN0IG4gb2YgZS52YWx1ZXMoKSl7Y29uc3R7b3B0OmksY2FuUm90YXRlOmEsc2NhbGVUeXBlOmwsdG9vbHNUeXBlOnN9PW47dGhpcy5zZWxlY3RvckNvbG9yPXRoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3IsaS5zdHJva2VDb2xvciYmKHRoaXMuc3Ryb2tlQ29sb3I9aS5zdHJva2VDb2xvciksaS5maWxsQ29sb3ImJih0aGlzLmZpbGxDb2xvcj1pLmZpbGxDb2xvciksaS50ZXh0T3B0JiYodGhpcy50ZXh0T3B0PWkudGV4dE9wdCkscz09PWR0LlNwZWVjaEJhbGxvb24mJih0LmFkZChzKSx0aGlzLnNoYXBlT3B0fHwodGhpcy5zaGFwZU9wdD17fSksdGhpcy5zaGFwZU9wdC5wbGFjZW1lbnQ9aS5wbGFjZW1lbnQpLHM9PT1kdC5Qb2x5Z29uJiYodC5hZGQocyksdGhpcy5zaGFwZU9wdHx8KHRoaXMuc2hhcGVPcHQ9e30pLHRoaXMuc2hhcGVPcHQudmVydGljZXM9aS52ZXJ0aWNlcykscz09PWR0LlN0YXImJih0LmFkZChzKSx0aGlzLnNoYXBlT3B0fHwodGhpcy5zaGFwZU9wdD17fSksdGhpcy5zaGFwZU9wdC52ZXJ0aWNlcz1pLnZlcnRpY2VzLHRoaXMuc2hhcGVPcHQuaW5uZXJSYXRpbz1pLmlubmVyUmF0aW8sdGhpcy5zaGFwZU9wdC5pbm5lclZlcnRpY2VTdGVwPWkuaW5uZXJWZXJ0aWNlU3RlcCkscz09PWR0LlRleHQmJih0aGlzLnRleHRPcHQ9aSksZS5zaXplPT09MSYmKHRoaXMudGV4dE9wdCYmKHRoaXMuY2FuVGV4dEVkaXQ9ITApLHRoaXMuY2FuUm90YXRlPWEsdGhpcy5zY2FsZVR5cGU9bCksbD09PWp0Lm5vbmUmJih0aGlzLnNjYWxlVHlwZT1sKSxzPT09ZHQuSW1hZ2UmJihyPW4pfXQuc2l6ZSYmKHRoaXMudG9vbHNUeXBlcz1bLi4udF0pLHImJihlLnNpemU9PT0xPyh0aGlzLmNhbkxvY2s9ITAsci5vcHQubG9ja2VkJiYodGhpcy5pc0xvY2tlZD0hMCx0aGlzLnNjYWxlVHlwZT1qdC5ub25lLHRoaXMuY2FuUm90YXRlPSExLHRoaXMudGV4dE9wdD12b2lkIDAsdGhpcy5maWxsQ29sb3I9dm9pZCAwLHRoaXMuc2VsZWN0b3JDb2xvcj0icmdiKDE3NywxNzcsMTc3KSIsdGhpcy5zdHJva2VDb2xvcj12b2lkIDAsdGhpcy5jYW5UZXh0RWRpdD0hMSkpOmUuc2l6ZT4xJiYhci5vcHQubG9ja2VkJiYodGhpcy5jYW5Mb2NrPSExLHRoaXMuY2FuUm90YXRlPSExKSl9Z2V0Q2hpbGRyZW5Qb2ludHMoKXt2YXIgZTtpZih0aGlzLnNjYWxlVHlwZT09PWp0LmJvdGgmJnRoaXMuc2VsZWN0SWRzKXtjb25zdCB0PXRoaXMuc2VsZWN0SWRzWzBdLHI9KGU9dGhpcy52Tm9kZXMuZ2V0KHQpKT09bnVsbD92b2lkIDA6ZS5vcDtpZihyKXtjb25zdCBuPVtdO2ZvcihsZXQgaT0wO2k8ci5sZW5ndGg7aSs9MyluLnB1c2goW3JbaV0scltpKzFdXSk7cmV0dXJuIG59fX1jb25zdW1lKGUpe2NvbnN0e29wOnQsd29ya1N0YXRlOnJ9PWUuZGF0YTtsZXQgbj10aGlzLm9sZFNlbGVjdFJlY3Q7aWYocj09PVJ0LlN0YXJ0JiYobj10aGlzLmJhY2tUb0Z1bGxMYXllcigpKSwhKHQhPW51bGwmJnQubGVuZ3RoKXx8IXRoaXMudk5vZGVzLmN1ck5vZGVNYXAuc2l6ZSlyZXR1cm57dHlwZTphdC5Ob25lfTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModCk7Y29uc3QgaT10aGlzLmNvbXB1dFNlbGVjdG9yKCk7aWYodGhpcy5zZWxlY3RJZHMmJk5oKHRoaXMuc2VsZWN0SWRzLGkuc2VsZWN0SWRzKSlyZXR1cm57dHlwZTphdC5Ob25lfTt0aGlzLnNlbGVjdElkcz1pLnNlbGVjdElkcztjb25zdCBhPWkuaW50ZXJzZWN0UmVjdDt0aGlzLmdldFNlbGVjdGVvckluZm8oaS5zdWJOb2RlTWFwKSx0aGlzLmRyYXcoSXQuc2VsZWN0b3JJZCx0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsaSksdGhpcy5vbGRTZWxlY3RSZWN0PWE7Y29uc3QgbD10aGlzLmdldENoaWxkcmVuUG9pbnRzKCk7cmV0dXJue3R5cGU6YXQuU2VsZWN0LGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6YnQoYSxuKSxzZWxlY3RJZHM6aS5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMsc2VsZWN0UmVjdDphLHNlbGVjdG9yQ29sb3I6dGhpcy5zZWxlY3RvckNvbG9yLHN0cm9rZUNvbG9yOnRoaXMuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLHRleHRPcHQ6dGhpcy50ZXh0T3B0LGNhblRleHRFZGl0OnRoaXMuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNhbkxvY2s6dGhpcy5jYW5Mb2NrLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSx3aWxsU3luY1NlcnZpY2U6ITAscG9pbnRzOmwsaXNMb2NrZWQ6dGhpcy5pc0xvY2tlZCx0b29sc1R5cGVzOnRoaXMudG9vbHNUeXBlcyxzaGFwZU9wdDp0aGlzLnNoYXBlT3B0fX1jb25zdW1lQWxsKGUpe3ZhciB0LHI7aWYoISgodD10aGlzLnNlbGVjdElkcykhPW51bGwmJnQubGVuZ3RoKSYmdGhpcy50bXBQb2ludHNbMF0mJnRoaXMuc2VsZWN0U2luZ2xlVG9vbCh0aGlzLnRtcFBvaW50c1swXS5YWSxJdC5zZWxlY3RvcklkLCExLGU9PW51bGw/dm9pZCAwOmUuaG92ZXJJZCksKHI9dGhpcy5zZWxlY3RJZHMpIT1udWxsJiZyLmxlbmd0aCYmdGhpcy5zZWFsVG9EcmF3TGF5ZXIodGhpcy5zZWxlY3RJZHMpLHRoaXMub2xkU2VsZWN0UmVjdCl7Y29uc3Qgbj10aGlzLmdldENoaWxkcmVuUG9pbnRzKCk7cmV0dXJue3R5cGU6YXQuU2VsZWN0LGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LHNlbGVjdElkczp0aGlzLnNlbGVjdElkcyxvcHQ6dGhpcy53b3JrT3B0aW9ucyxzZWxlY3RvckNvbG9yOnRoaXMuc2VsZWN0b3JDb2xvcixzZWxlY3RSZWN0OnRoaXMub2xkU2VsZWN0UmVjdCxzdHJva2VDb2xvcjp0aGlzLnN0cm9rZUNvbG9yLGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvcix0ZXh0T3B0OnRoaXMudGV4dE9wdCxjYW5UZXh0RWRpdDp0aGlzLmNhblRleHRFZGl0LGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjYW5Mb2NrOnRoaXMuY2FuTG9jayxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsd2lsbFN5bmNTZXJ2aWNlOiEwLHBvaW50czpuLGlzTG9ja2VkOnRoaXMuaXNMb2NrZWQsdG9vbHNUeXBlczp0aGlzLnRvb2xzVHlwZXMsc2hhcGVPcHQ6dGhpcy5zaGFwZU9wdH19cmV0dXJue3R5cGU6YXQuTm9uZX19Y29uc3VtZVNlcnZpY2UoKXt9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1jbGVhclNlbGVjdERhdGEoKXt0aGlzLnNlbGVjdElkcz12b2lkIDAsdGhpcy5vbGRTZWxlY3RSZWN0PXZvaWQgMH1zZWxlY3RTaW5nbGVUb29sKGUsdD1JdC5zZWxlY3RvcklkLHI9ITEsbil7aWYoZS5sZW5ndGg9PT0yKXtjb25zdCBpPWVbMF0sYT1lWzFdO2xldCBsO2Zvcihjb25zdCBzIG9mIHRoaXMuZnVsbExheWVyLmNoaWxkcmVuKXtjb25zdCBmPVFuKFtzXSk7bGV0IHY9ITE7aWYoKG4mJm49PT1zLm5hbWV8fCExKSYmZi5maW5kKHA9PnAuaXNQb2ludENvbGxpc2lvbihpLGEpKSl7bD1zO2JyZWFrfWZvcihjb25zdCBwIG9mIGYpaWYodj1wLmlzUG9pbnRDb2xsaXNpb24oaSxhKSx2KXtpZighbClsPXM7ZWxzZXtjb25zdCB5PXRoaXMudk5vZGVzLmdldChzLm5hbWUpLFA9dGhpcy52Tm9kZXMuZ2V0KGwubmFtZSk7aWYoKHk9PW51bGw/dm9pZCAwOnkudG9vbHNUeXBlKSE9PWR0LlRleHQmJihQPT1udWxsP3ZvaWQgMDpQLnRvb2xzVHlwZSk9PT1kdC5UZXh0KWJyZWFrO2lmKCh5PT1udWxsP3ZvaWQgMDp5LnRvb2xzVHlwZSk9PT1kdC5UZXh0JiYoUD09bnVsbD92b2lkIDA6UC50b29sc1R5cGUpIT09ZHQuVGV4dClsPXM7ZWxzZXtjb25zdCB4PSh5PT1udWxsP3ZvaWQgMDp5Lm9wdC56SW5kZXgpfHwwLG09KFA9PW51bGw/dm9pZCAwOlAub3B0LnpJbmRleCl8fDA7TnVtYmVyKHgpPj1OdW1iZXIobSkmJihsPXMpfX1icmVha319aWYobCl7Y29uc3Qgcz1sLm5hbWUsZj10aGlzLnZOb2Rlcy5nZXQocyk7aWYoZil7aWYoISRuKHRoaXMub2xkU2VsZWN0UmVjdCxmLnJlY3QpKXtjb25zdCB2PW5ldyBNYXAoW1tzLGZdXSk7dGhpcy5nZXRTZWxlY3Rlb3JJbmZvKHYpLHRoaXMuZHJhdyh0LHRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7aW50ZXJzZWN0UmVjdDpmLnJlY3Qsc3ViTm9kZU1hcDp2LHNlbGVjdElkczp0aGlzLnNlbGVjdElkc3x8W119LHIpfXRoaXMuc2VsZWN0SWRzPVtzXSx0aGlzLm9sZFNlbGVjdFJlY3Q9Zi5yZWN0fX19fWJhY2tUb0Z1bGxMYXllcihlKXt2YXIgaSxhO2xldCB0O2NvbnN0IHI9W10sbj1bXTtmb3IoY29uc3QgbCBvZigoaT10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmkuY2hpbGRyZW4pfHxbXSlpZighKGUhPW51bGwmJmUubGVuZ3RoJiYhZS5pbmNsdWRlcyhsLmlkKSkmJmwuaWQhPT1JdC5zZWxlY3RvcklkKXtjb25zdCBzPWwuY2xvbmVOb2RlKCEwKTtVZShsKSYmcy5zZWFsKCksdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUobC5uYW1lKS5sZW5ndGh8fHIucHVzaChzKSxuLnB1c2gobCk7Y29uc3QgZj0oYT10aGlzLnZOb2Rlcy5nZXQobC5uYW1lKSk9PW51bGw/dm9pZCAwOmEucmVjdDtmJiYodD1idCh0LGYpKX1yZXR1cm4gbi5mb3JFYWNoKGw9PmwucmVtb3ZlKCkpLHIubGVuZ3RoJiZ0aGlzLmZ1bGxMYXllci5hcHBlbmQoLi4uciksdH1zZWFsVG9EcmF3TGF5ZXIoZSl7dmFyIG47Y29uc3QgdD1bXSxyPVtdO2UuZm9yRWFjaChpPT57dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoaS50b1N0cmluZygpKS5mb3JFYWNoKGE9Pnt2YXIgcztjb25zdCBsPWEuY2xvbmVOb2RlKCEwKTtVZShhKSYmbC5zZWFsKCksKHM9dGhpcy5kcmF3TGF5ZXIpIT1udWxsJiZzLmdldEVsZW1lbnRzQnlOYW1lKGEubmFtZSkubGVuZ3RofHx0LnB1c2gobCksci5wdXNoKGEpfSl9KSxyLmZvckVhY2goaT0+aS5yZW1vdmUoKSksdCYmKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8bi5hcHBlbmQoLi4udCkpfWdldFNlbGVjdG9yUmVjdChlLHQpe3ZhciBhO2xldCByO2NvbnN0IG49KGE9ZS5wYXJlbnQpPT1udWxsP3ZvaWQgMDphLmdldEVsZW1lbnRCeUlkKHQpLGk9bj09bnVsbD92b2lkIDA6bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4gaSYmKHI9YnQocix7eDpNYXRoLmZsb29yKGkueCkseTpNYXRoLmZsb29yKGkueSksdzpNYXRoLnJvdW5kKGkud2lkdGgpLGg6TWF0aC5yb3VuZChpLmhlaWdodCl9KSkscn1pc0NhbkZpbGxDb2xvcihlKXtyZXR1cm4gZT09PWR0LkVsbGlwc2V8fGU9PT1kdC5UcmlhbmdsZXx8ZT09PWR0LlJlY3RhbmdsZXx8ZT09PWR0LlBvbHlnb258fGU9PT1kdC5TdGFyfHxlPT09ZHQuU3BlZWNoQmFsbG9vbn1hc3luYyB1cGRhdGVTZWxlY3RvcihlKXtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDp0LHNlbGVjdElkczpyLHZOb2RlczpuLHdpbGxTZXJpYWxpemVEYXRhOmksd29ya2VyOmEsb2Zmc2V0Omwsc2NlbmU6c309ZSxmPXRoaXMuZHJhd0xheWVyO2lmKCFmKXJldHVybjtsZXQgdjtjb25zdCBkPW5ldyBNYXAse2JveDpwLHdvcmtTdGF0ZTp5LGFuZ2xlOlAsdHJhbnNsYXRlOnh9PXQ7bGV0IG09WzAsMF0sTz1bMSwxXSxvPVswLDBdLGgsYztpZihwfHx4fHxuZShQKSl7aWYoeT09PVJ0LlN0YXJ0KXJldHVybiBuLnNldFRhcmdldCgpLHt0eXBlOmF0LlNlbGVjdCxkYXRhVHlwZTpPdC5Mb2NhbCxzZWxlY3RSZWN0OnRoaXMub2xkU2VsZWN0UmVjdCxyZWN0OnRoaXMub2xkU2VsZWN0UmVjdH07aWYoaD1uLmdldExhc3RUYXJnZXQoKSxoJiZwKXtsZXQgRTtyPT1udWxsfHxyLmZvckVhY2goQT0+e2NvbnN0IEw9aD09bnVsbD92b2lkIDA6aC5nZXQoQSk7RT1idChFLEw9PW51bGw/dm9pZCAwOkwucmVjdCl9KSxFJiYoTz1bcC53L0UudyxwLmgvRS5oXSxtPVtwLngrcC53LzItKEUueCtFLncvMikscC55K3AuaC8yLShFLnkrRS5oLzIpXSxvPVtFLngrRS53LzIsRS55K0UuaC8yXSksYz1FfX1pZihyKWZvcihjb25zdCBFIG9mIHIpe2NvbnN0IEE9bi5nZXQoRSk7aWYoQSl7Y29uc3R7dG9vbHNUeXBlOkx9PUE7bGV0IE09KGY9PW51bGw/dm9pZCAwOmYuZ2V0RWxlbWVudHNCeU5hbWUoRSkpWzBdO2lmKE0pe2NvbnN0IEk9ey4uLnR9O2xldCBEO2lmKEwpe2lmKGgmJihEPWguZ2V0KEUpLEQmJnApKXtJLmJveFNjYWxlPU87Y29uc3QgQz1bRC5yZWN0LngrRC5yZWN0LncvMixELnJlY3QueStELnJlY3QuaC8yXSxCPVtDWzBdLW9bMF0sQ1sxXS1vWzFdXTtJLmJveFRyYW5zbGF0ZT1bQlswXSooT1swXS0xKSttWzBdKyhsJiZsWzBdfHwwKSxCWzFdKihPWzFdLTEpK21bMV0rKGwmJmxbMV18fDApXX1jb25zdCBSPUpuKEwpO2lmKFI9PW51bGx8fFIudXBkYXRlTm9kZU9wdCh7bm9kZTpNLG9wdDpJLHZOb2RlczpuLHdpbGxTZXJpYWxpemVEYXRhOmksdGFyZ2V0Tm9kZTpEfSksQSYmYSYmKGkmJihJLmFuZ2xlfHxJLnRyYW5zbGF0ZSl8fEkuYm94JiZJLndvcmtTdGF0ZSE9PVJ0LlN0YXJ0fHxJLnBvaW50TWFwJiZJLnBvaW50TWFwLmhhcyhFKXx8TD09PWR0LlRleHQmJihJLmZvbnRTaXplfHxJLnRleHRJbmZvcyYmSS50ZXh0SW5mb3MuZ2V0KEUpKXx8TD09PWR0LkltYWdlJiYoSS5hbmdsZXx8SS50cmFuc2xhdGV8fEkuYm94U2NhbGUpfHxMPT09SS50b29sc1R5cGUmJkkud2lsbFJlZnJlc2gpKXtjb25zdCBDPWEuY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNUeXBlOkwsdG9vbHNPcHQ6QS5vcHR9KTtDPT1udWxsfHxDLnNldFdvcmtJZChFKTtsZXQgQjtMPT09ZHQuSW1hZ2UmJnM/Qj1hd2FpdCBDLmNvbnN1bWVTZXJ2aWNlQXN5bmMoe2lzRnVsbFdvcms6ITEscmVwbGFjZUlkOkUsc2NlbmU6c30pOkI9Qz09bnVsbD92b2lkIDA6Qy5jb25zdW1lU2VydmljZSh7b3A6QS5vcCxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDpFLGlzQ2xlYXJBbGw6ITF9KSxCJiYoQS5yZWN0PUIsbi5zZXRJbmZvKEUsQSkpLE09KGY9PW51bGw/dm9pZCAwOmYuZ2V0RWxlbWVudHNCeU5hbWUoRSkpWzBdfUEmJihkLnNldChFLEEpLHY9YnQodixBLnJlY3QpKX19fX1oJiZ5PT09UnQuRG9uZSYmbi5kZWxldGVMYXN0VGFyZ2V0KCk7Y29uc3QgZz12O2lmKGMmJnQuZGlyJiZnKXtsZXQgRT1bMCwwXTtzd2l0Y2godC5kaXIpe2Nhc2UidG9wTGVmdCI6Y2FzZSJsZWZ0Ijp7Y29uc3QgQT1bYy54K2MudyxjLnkrYy5oXTtFPVtBWzBdLShnLngrZy53KSxBWzFdLShnLnkrZy5oKV07YnJlYWt9Y2FzZSJib3R0b21MZWZ0IjpjYXNlImJvdHRvbSI6e2NvbnN0IEE9W2MueCtjLncsYy55XTtFPVtBWzBdLShnLngrZy53KSxBWzFdLWcueV07YnJlYWt9Y2FzZSJ0b3BSaWdodCI6Y2FzZSJ0b3AiOntjb25zdCBBPVtjLngsYy55K2MuaF07RT1bQVswXS1nLngsQVsxXS0oZy55K2cuaCldO2JyZWFrfWNhc2UicmlnaHQiOmNhc2UiYm90dG9tUmlnaHQiOntjb25zdCBBPVtjLngsYy55XTtFPVtBWzBdLWcueCxBWzFdLWcueV07YnJlYWt9fWlmKEVbMF18fEVbMV0pcmV0dXJuIGcueD1nLngrRVswXSxnLnk9Zy55K0VbMV0sYXdhaXQgdGhpcy51cGRhdGVTZWxlY3Rvcih7Li4uZSxvZmZzZXQ6RX0pfXRoaXMuZ2V0U2VsZWN0ZW9ySW5mbyhkKSx0aGlzLmRyYXcoSXQuc2VsZWN0b3JJZCxmLHtzZWxlY3RJZHM6cnx8W10sc3ViTm9kZU1hcDpkLGludGVyc2VjdFJlY3Q6Z30pO2NvbnN0IGI9YnQodGhpcy5vbGRTZWxlY3RSZWN0LHYpO3JldHVybiB0aGlzLm9sZFNlbGVjdFJlY3Q9dix7dHlwZTphdC5TZWxlY3QsZGF0YVR5cGU6T3QuTG9jYWwsc2VsZWN0UmVjdDpnLHJlbmRlclJlY3Q6dixyZWN0OmJ0KGIsZyl9fWJsdXJTZWxlY3Rvcigpe2NvbnN0IGU9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoKTtyZXR1cm57dHlwZTphdC5TZWxlY3QsZGF0YVR5cGU6T3QuTG9jYWwscmVjdDplLHNlbGVjdElkczpbXSx3aWxsU3luY1NlcnZpY2U6ITB9fWdldFJpZ2h0U2VydmljZUlkKGUpe3JldHVybiBlLnJlcGxhY2UoIisrIiwiLSIpfXNlbGVjdFNlcnZpY2VOb2RlKGUsdCxyKXtjb25zdHtzZWxlY3RJZHM6bn09dCxpPXRoaXMuZ2V0UmlnaHRTZXJ2aWNlSWQoZSksYT10aGlzLmdldFNlbGVjdG9yUmVjdCh0aGlzLmZ1bGxMYXllcixpKTtsZXQgbDtjb25zdCBzPW5ldyBNYXA7cmV0dXJuIG49PW51bGx8fG4uZm9yRWFjaChmPT57Y29uc3Qgdj10aGlzLnZOb2Rlcy5nZXQoZiksZD10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShmKVswXTt2JiZkJiYobD1idChsLHYucmVjdCkscy5zZXQoZix2KSl9KSx0aGlzLmdldFNlbGVjdGVvckluZm8ocyksdGhpcy5kcmF3KGksdGhpcy5mdWxsTGF5ZXIse2ludGVyc2VjdFJlY3Q6bCxzZWxlY3RJZHM6bnx8W10sc3ViTm9kZU1hcDpzfSxyKSxidChsLGEpfXJlUmVuZGVyU2VsZWN0b3IoKXt2YXIgcjtsZXQgZTtjb25zdCB0PW5ldyBNYXA7cmV0dXJuKHI9dGhpcy5zZWxlY3RJZHMpPT1udWxsfHxyLmZvckVhY2gobj0+e2NvbnN0IGk9dGhpcy52Tm9kZXMuZ2V0KG4pO2kmJihlPWJ0KGUsaS5yZWN0KSx0LnNldChuLGkpKX0sdGhpcyksdGhpcy5nZXRTZWxlY3Rlb3JJbmZvKHQpLHRoaXMuZHJhdyhJdC5zZWxlY3RvcklkLHRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7aW50ZXJzZWN0UmVjdDplLHN1Yk5vZGVNYXA6dCxzZWxlY3RJZHM6dGhpcy5zZWxlY3RJZHN8fFtdfSksdGhpcy5vbGRTZWxlY3RSZWN0PWUsZX11cGRhdGVTZWxlY3RJZHMoZSl7dmFyIGEsbDtsZXQgdDtjb25zdCByPShhPXRoaXMuc2VsZWN0SWRzKT09bnVsbD92b2lkIDA6YS5maWx0ZXIocz0+IWUuaW5jbHVkZXMocykpLG49ZS5maWx0ZXIocz0+e3ZhciBmO3JldHVybiEoKGY9dGhpcy5zZWxlY3RJZHMpIT1udWxsJiZmLmluY2x1ZGVzKHMpKX0pO2lmKHIhPW51bGwmJnIubGVuZ3RoJiYodD10aGlzLmJhY2tUb0Z1bGxMYXllcihyKSksbi5sZW5ndGgpe3RoaXMuc2VhbFRvRHJhd0xheWVyKG4pO2Zvcihjb25zdCBzIG9mIG4pe2NvbnN0IGY9KGw9dGhpcy52Tm9kZXMuZ2V0KHMpKT09bnVsbD92b2lkIDA6bC5yZWN0O2YmJih0PWJ0KHQsZikpfX10aGlzLnNlbGVjdElkcz1lO2NvbnN0IGk9dGhpcy5yZVJlbmRlclNlbGVjdG9yKCk7cmV0dXJue2JnUmVjdDp0LHNlbGVjdFJlY3Q6aX19Y3Vyc29ySG92ZXIoZSl7dmFyIGksYTtjb25zdCB0PXRoaXMub2xkU2VsZWN0UmVjdDt0aGlzLnNlbGVjdElkcz1bXTtjb25zdCByPShpPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6aS50b1N0cmluZygpLG49W2VbMF0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0sZVsxXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXV07aWYodGhpcy5zZWxlY3RTaW5nbGVUb29sKG4sciwhMCksdGhpcy5vbGRTZWxlY3RSZWN0JiYhJG4odCx0aGlzLm9sZFNlbGVjdFJlY3QpKXJldHVybnt0eXBlOmF0LkN1cnNvckhvdmVyLGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6YnQodCx0aGlzLm9sZFNlbGVjdFJlY3QpLHNlbGVjdG9yQ29sb3I6dGhpcy5zZWxlY3RvckNvbG9yLHdpbGxTeW5jU2VydmljZTohMX07aWYoKGE9dGhpcy5zZWxlY3RJZHMpIT1udWxsJiZhLmxlbmd0aHx8KHRoaXMub2xkU2VsZWN0UmVjdD12b2lkIDApLHQmJiF0aGlzLm9sZFNlbGVjdFJlY3QpcmV0dXJuIHRoaXMuY3Vyc29yQmx1cigpLHt0eXBlOmF0LkN1cnNvckhvdmVyLGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6dCxzZWxlY3RvckNvbG9yOnRoaXMuc2VsZWN0b3JDb2xvcix3aWxsU3luY1NlcnZpY2U6ITF9fWN1cnNvckJsdXIoKXt2YXIgdCxyO2NvbnN0IGU9KHQ9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7KChyPXRoaXMuZnVsbExheWVyKT09bnVsbD92b2lkIDA6ci5wYXJlbnQpLmNoaWxkcmVuLmZvckVhY2gobj0+e24ubmFtZT09PWUmJm4ucmVtb3ZlKCl9KX19T2JqZWN0LmRlZmluZVByb3BlcnR5KEl0LCJzZWxlY3RvcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6UWh9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoSXQsInNlbGVjdG9yQm9yZGVySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToic2VsZWN0b3ItYm9yZGVyIn0pO2NsYXNzIHpuIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmp0LmJvdGh9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuQXJyb3d9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhcnJvd1RpcFdpZHRoIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5hcnJvd1RpcFdpZHRoPXRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKjQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgeTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUsaT0oeT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOnkudG9TdHJpbmcoKTtpZighaSlyZXR1cm57dHlwZTphdC5Ob25lfTtjb25zdHtvcDphLHdvcmtTdGF0ZTpsfT10LHM9YT09bnVsbD92b2lkIDA6YS5sZW5ndGg7aWYoIXN8fHM8MilyZXR1cm57dHlwZTphdC5Ob25lfTtsZXQgZjtpZihsPT09UnQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgeHQoYVswXSxhWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMoYSksIWYpcmV0dXJue3R5cGU6YXQuTm9uZX07aWYoIW4pe2NvbnN0IFA9RGF0ZS5ub3coKTtyZXR1cm4gUC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1QLHt0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppLG9wOnRoaXMudG1wUG9pbnRzLm1hcCh4PT5bLi4ueC5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOmF0Lk5vbmV9fWNvbnN0IHY9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsZD10aGlzLmRyYXcoe3dvcmtJZDppLGxheWVyOnZ9KSxwPWJ0KGQsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWQse3JlY3Q6cCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppfX1jb25zdW1lQWxsKGUpe3ZhciBzO2NvbnN0e2RhdGE6dH09ZSxyPShzPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixpPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bn0pO3RoaXMub2xkUmVjdD1pO2NvbnN0IGE9dGhpcy50bXBQb2ludHMubWFwKGY9PlsuLi5mLlhZLDBdKS5mbGF0KDEpLGw9cXQoYSk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8ocix7cmVjdDppLG9wOmEsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOnB0LmdldENlbnRlclBvcyhpLG4pfSkse3JlY3Q6aSx0eXBlOmF0LkZ1bGxXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDpyLG9wczpsLGlzU3luYzohMH19ZHJhdyhlKXt2YXIgTztjb25zdHt3b3JrSWQ6dCxsYXllcjpyfT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChvPT5vLnJlbW92ZSgpKSwoTz10aGlzLmRyYXdMYXllcik9PW51bGx8fE8uZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKG89Pm8ucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOm4sdGhpY2tuZXNzOmksekluZGV4OmEsc2NhbGU6bCxyb3RhdGU6cyx0cmFuc2xhdGU6Zn09dGhpcy53b3JrT3B0aW9ucyx2PXIud29ybGRQb3NpdGlvbixkPXIud29ybGRTY2FsaW5nLHtwb2ludHM6cCxyZWN0Onl9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhpKSx4PXtwb3M6W3kueCt5LncvMix5LnkreS5oLzJdLG5hbWU6dCxpZDp0LGNsb3NlOiEwLHBvaW50czpwLGZpbGxDb2xvcjpuLHN0cm9rZUNvbG9yOm4sbGluZVdpZHRoOjAsbm9ybWFsaXplOiEwLHpJbmRleDphfTtsJiYoeC5zY2FsZT1sKSxzJiYoeC5yb3RhdGU9cyksZiYmKHgudHJhbnNsYXRlPWYpO2NvbnN0IG09bmV3IGVlKHgpO2lmKHIuYXBwZW5kKG0pLGx8fHN8fGYpe2NvbnN0IG89bS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKG8ueC1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKG8ueS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKG8ud2lkdGgrcHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKG8uaGVpZ2h0K3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm57eDpNYXRoLmZsb29yKHkueCpkWzBdK3ZbMF0tcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcih5LnkqZFsxXSt2WzFdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoeS53KmRbMF0rMipwdC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKHkuaCpkWzFdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpfX1jb21wdXREcmF3UG9pbnRzKGUpe3JldHVybiB0aGlzLnRtcFBvaW50c1sxXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1swXSk+dGhpcy5hcnJvd1RpcFdpZHRoP3RoaXMuY29tcHV0RnVsbEFycm93UG9pbnRzKGUpOnRoaXMuY29tcHV0VHJpYW5nbGVQb2ludHMoKX1jb21wdXRGdWxsQXJyb3dQb2ludHMoZSl7Y29uc3QgdD1ldC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHI9ZXQuUGVyKHQpLm11bChlLzIpLG49eHQuU3ViKHRoaXMudG1wUG9pbnRzWzBdLHIpLGk9eHQuQWRkKHRoaXMudG1wUG9pbnRzWzBdLHIpLGE9ZXQuTXVsKHQsdGhpcy5hcnJvd1RpcFdpZHRoKSxsPWV0LlN1Yih0aGlzLnRtcFBvaW50c1sxXSxhKSxzPXh0LlN1YihsLHIpLGY9eHQuQWRkKGwsciksdj1ldC5QZXIodCkubXVsKGUqMS41KSxkPXh0LlN1YihsLHYpLHA9eHQuQWRkKGwsdikseT1bbixzLGQsdGhpcy50bXBQb2ludHNbMV0scCxmLGldO3JldHVybntwb2ludHM6eS5tYXAoUD0+eHQuU3ViKFAsdGhpcy50bXBQb2ludHNbMF0pLlhZKS5mbGF0KDEpLHJlY3Q6TnQoeSksaXNUcmlhbmdsZTohMSxwb3M6dGhpcy50bXBQb2ludHNbMF0uWFl9fWNvbXB1dFRyaWFuZ2xlUG9pbnRzKCl7Y29uc3QgZT1ldC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHQ9dGhpcy50bXBQb2ludHNbMV0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbMF0pLHI9ZXQuUGVyKGUpLm11bChNYXRoLmZsb29yKHQqMy84KSksbj14dC5TdWIodGhpcy50bXBQb2ludHNbMF0sciksaT14dC5BZGQodGhpcy50bXBQb2ludHNbMF0sciksYT1bbix0aGlzLnRtcFBvaW50c1sxXSxpXTtyZXR1cm57cG9pbnRzOmEubWFwKGw9Pnh0LlN1YihsLHRoaXMudG1wUG9pbnRzWzBdKS5YWSkuZmxhdCgxKSxyZWN0Ok50KGEpLGlzVHJpYW5nbGU6ITAscG9zOnRoaXMudG1wUG9pbnRzWzBdLlhZfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMikscj1uZXcgeHQodFswXSx0WzFdKSxuPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6aX09dGhpcy53b3JrT3B0aW9ucztpZihuLmlzTmVhcihyLGkpKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBsO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGw9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpsLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyB4dCh0W3NdLHRbcysxXSx0W3MrMl0pKTtjb25zdCBpPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGE9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjppfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1hLHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDphLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOnB0LmdldENlbnRlclBvcyhhLGkpfSksYX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBsO2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6aX09cixhPW4uZ2V0KHQubmFtZSk7cmV0dXJuIGkmJih0LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLGkpLHQuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGkpLChsPWE9PW51bGw/dm9pZCAwOmEub3B0KSE9bnVsbCYmbC5zdHJva2VDb2xvciYmKGEub3B0LnN0cm9rZUNvbG9yPWkpLGEmJm4uc2V0SW5mbyh0Lm5hbWUsYSkpLHB0LnVwZGF0ZU5vZGVPcHQoZSl9fWNsYXNzIEduIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmp0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpkdC5FbGxpcHNlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciB5O2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxpPSh5PXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6eS50b1N0cmluZygpO2lmKCFpKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0e29wOmEsd29ya1N0YXRlOmx9PXQscz1hPT1udWxsP3ZvaWQgMDphLmxlbmd0aDtpZighc3x8czwyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2xldCBmO2lmKGw9PT1SdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyB4dChhWzBdLGFbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhhKSwhZilyZXR1cm57dHlwZTphdC5Ob25lfTtpZighbil7Y29uc3QgUD1EYXRlLm5vdygpO3JldHVybiBQLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVAse3R5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmksb3A6dGhpcy50bXBQb2ludHMubWFwKHg9PlsuLi54LlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6YXQuTm9uZX19Y29uc3Qgdj1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixkPXRoaXMuZHJhdyh7d29ya0lkOmksbGF5ZXI6dixpc0RyYXdpbmc6ITB9KSxwPWJ0KGQsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWQse3JlY3Q6cCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppfX1jb25zdW1lQWxsKGUpe3ZhciBzO2NvbnN0e2RhdGE6dH09ZSxyPShzPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixpPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bixpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9aTtjb25zdCBhPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxsPXF0KGEpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6aSxvcDphLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxuKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6bCxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGM7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cixpc0RyYXdpbmc6bn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoZz0+Zy5yZW1vdmUoKSksKGM9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxjLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChnPT5nLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjppLGZpbGxDb2xvcjphLHRoaWNrbmVzczpsLHpJbmRleDpzLHNjYWxlOmYscm90YXRlOnYsdHJhbnNsYXRlOmR9PXRoaXMud29ya09wdGlvbnMscD1yLndvcmxkUG9zaXRpb24seT1yLndvcmxkU2NhbGluZyx7cmFkaXVzOlAscmVjdDp4LHBvczptfT10aGlzLmNvbXB1dERyYXdQb2ludHMobCksTz17cG9zOm0sbmFtZTp0LGlkOnQscmFkaXVzOlAsbGluZVdpZHRoOmwsZmlsbENvbG9yOmEhPT0idHJhbnNwYXJlbnQiJiZhfHx2b2lkIDAsc3Ryb2tlQ29sb3I6aSxub3JtYWxpemU6ITAsekluZGV4OnN9LG89e3g6TWF0aC5mbG9vcih4LngqeVswXStwWzBdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoeC55KnlbMV0rcFsxXS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHgudyp5WzBdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcih4LmgqeVsxXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKX07aWYobil7Y29uc3R7bmFtZTpnLGlkOmIsekluZGV4OkUsc3Ryb2tlQ29sb3I6QX09TyxMPXB0LmdldENlbnRlclBvcyhvLHIpLE09bmV3IHRlKHtuYW1lOmcsaWQ6Yix6SW5kZXg6RSxwb3M6TCxhbmNob3I6Wy41LC41XSxzaXplOltvLncsby5oXX0pLEk9bmV3IFBuKHsuLi5PLHBvczpbMCwwXX0pLEQ9bmV3IGFlKHtkOiJNLTQsMEg0TTAsLTRWNCIsbm9ybWFsaXplOiEwLHBvczpbMCwwXSxzdHJva2VDb2xvcjpBLGxpbmVXaWR0aDoxLHNjYWxlOlsxL3lbMF0sMS95WzFdXX0pO3JldHVybiBNLmFwcGVuZChJLEQpLHIuYXBwZW5kKE0pLG99ZiYmKE8uc2NhbGU9ZiksdiYmKE8ucm90YXRlPXYpLGQmJihPLnRyYW5zbGF0ZT1kKTtjb25zdCBoPW5ldyBQbihPKTtpZihyLmFwcGVuZChoKSx2fHxmfHxkKXtjb25zdCBnPWguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihnLngtcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihnLnktcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihnLndpZHRoK3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihnLmhlaWdodCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19cmV0dXJuIG99Y29tcHV0RHJhd1BvaW50cyhlKXtjb25zdCB0PU50KHRoaXMudG1wUG9pbnRzKSxyPU50KHRoaXMudG1wUG9pbnRzLGUpLG49W01hdGguZmxvb3IodC54K3Qudy8yKSxNYXRoLmZsb29yKHQueSt0LmgvMildO3JldHVybntyZWN0OnIscG9zOm4scmFkaXVzOltNYXRoLmZsb29yKHQudy8yKSxNYXRoLmZsb29yKHQuaC8yKV19fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyB4dCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczppfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIsaSkpcmV0dXJuITE7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09Mil7aWYoci5pc05lYXIodGhpcy50bXBQb2ludHNbMV0sMSkpcmV0dXJuITE7dGhpcy50bXBQb2ludHNbMV09cn1lbHNlIHRoaXMudG1wUG9pbnRzLnB1c2gocik7cmV0dXJuITB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIGw7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOnJ9PWUsbj0obD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmwudG9TdHJpbmcoKTtpZighbilyZXR1cm47dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKz0zKXRoaXMudG1wUG9pbnRzLnB1c2gobmV3IHh0KHRbc10sdFtzKzFdLHRbcysyXSkpO2NvbnN0IGk9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsYT10aGlzLmRyYXcoe3dvcmtJZDpuLGxheWVyOmksaXNEcmF3aW5nOiExfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1hLHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDphLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOnB0LmdldENlbnRlclBvcyhhLGkpfSksYX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBmLHY7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpufT1lLHtzdHJva2VDb2xvcjppLGZpbGxDb2xvcjphfT1yLGw9bi5nZXQodC5uYW1lKTtsZXQgcz10O3JldHVybiB0LnRhZ05hbWU9PT0iR1JPVVAiJiYocz10LmNoaWxkcmVuWzBdKSxpJiYocy5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixpKSwoZj1sPT1udWxsP3ZvaWQgMDpsLm9wdCkhPW51bGwmJmYuc3Ryb2tlQ29sb3ImJihsLm9wdC5zdHJva2VDb2xvcj1pKSksYSYmKGE9PT0idHJhbnNwYXJlbnQiP3Muc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLCJyZ2JhKDAsMCwwLDApIik6cy5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsYSksKHY9bD09bnVsbD92b2lkIDA6bC5vcHQpIT1udWxsJiZ2LmZpbGxDb2xvciYmKGwub3B0LmZpbGxDb2xvcj1hKSksbCYmbi5zZXRJbmZvKHQubmFtZSxsKSxwdC51cGRhdGVOb2RlT3B0KGUpfX12YXIgaWc9aWUsc2c9X3Qsb2c9IltvYmplY3QgQm9vbGVhbl0iO2Z1bmN0aW9uIGFnKHUpe3JldHVybiB1PT09ITB8fHU9PT0hMXx8c2codSkmJmlnKHUpPT1vZ312YXIgbGc9YWcsbGU9Y2UobGcpO2NsYXNzIEhuIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmp0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpkdC5SZWN0YW5nbGV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfXRyYW5zZm9ybURhdGEoKXtjb25zdCBlPU50KHRoaXMudG1wUG9pbnRzKTtyZXR1cm5bW2UueCxlLnksMF0sW2UueCtlLncsZS55LDBdLFtlLngrZS53LGUueStlLmgsMF0sW2UueCxlLnkrZS5oLDBdXX1jb21wdXREcmF3UG9pbnRzKGUpe2NvbnN0e3RoaWNrbmVzczp0fT10aGlzLndvcmtPcHRpb25zLHI9W107Zm9yKGNvbnN0IGEgb2YgZSlyLnB1c2gobmV3IGV0KC4uLmEpKTtjb25zdCBuPU50KHIsdCksaT1bbi54K24udy8yLG4ueStuLmgvMl07cmV0dXJue3JlY3Q6bixwb3M6aSxwb2ludHM6ci5tYXAoYT0+YS5YWSkuZmxhdCgxKX19Y29uc3VtZShlKXt2YXIgUDtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUsaT0oUD10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOlAudG9TdHJpbmcoKTtpZighaSlyZXR1cm57dHlwZTphdC5Ob25lfTtjb25zdHtvcDphLHdvcmtTdGF0ZTpsfT10LHM9YT09bnVsbD92b2lkIDA6YS5sZW5ndGg7aWYoIXN8fHM8MilyZXR1cm57dHlwZTphdC5Ob25lfTtsZXQgZjtpZihsPT09UnQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgeHQoYVswXSxhWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMoYSksIWYpcmV0dXJue3R5cGU6YXQuTm9uZX07Y29uc3Qgdj10aGlzLnRyYW5zZm9ybURhdGEoKTtpZighbil7Y29uc3QgeD1EYXRlLm5vdygpO3JldHVybiB4LXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPXgse3R5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmksb3A6di5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6YXQuTm9uZX19Y29uc3QgZD1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixwPXRoaXMuZHJhdyh7cHM6dix3b3JrSWQ6aSxsYXllcjpkLGlzRHJhd2luZzohMH0pLHk9YnQocCx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9cCx7cmVjdDp5LHR5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOml9fWNvbnN1bWVBbGwoZSl7dmFyIGY7Y29uc3R7ZGF0YTp0fT1lLHI9KGY9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6YXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6YXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMudHJhbnNmb3JtRGF0YSgpLGk9dGhpcy5mdWxsTGF5ZXIsYT10aGlzLmRyYXcoe3BzOm4sd29ya0lkOnIsbGF5ZXI6aSxpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9YTtjb25zdCBsPW4uZmxhdCgxKSxzPXF0KGwpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6YSxvcDpsLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczphJiZwdC5nZXRDZW50ZXJQb3MoYSxpKX0pLHtyZWN0OmEsdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6cyxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIEE7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cixpc0RyYXdpbmc6bixwczppLHJlcGxhY2VJZDphfT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGF8fHQpLm1hcChMPT5MLnJlbW92ZSgpKSwoQT10aGlzLmRyYXdMYXllcik9PW51bGx8fEEuZ2V0RWxlbWVudHNCeU5hbWUoYXx8dCkubWFwKEw9PkwucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOmwsZmlsbENvbG9yOnMsdGhpY2tuZXNzOmYsekluZGV4OnYsc2NhbGU6ZCxyb3RhdGU6cCx0cmFuc2xhdGU6eSx0ZXh0T3B0OlB9PXRoaXMud29ya09wdGlvbnMseD1yLndvcmxkUG9zaXRpb24sbT1yLndvcmxkU2NhbGluZyx7cG9pbnRzOk8scmVjdDpvLHBvczpofT10aGlzLmNvbXB1dERyYXdQb2ludHMoaSksYz17Y2xvc2U6ITAsbm9ybWFsaXplOiEwLHBvaW50czpPLGxpbmVXaWR0aDpmLGZpbGxDb2xvcjpzIT09InRyYW5zcGFyZW50IiYmc3x8dm9pZCAwLHN0cm9rZUNvbG9yOmwsbGluZUpvaW46InJvdW5kIn0sZz17eDpNYXRoLmZsb29yKG8ueCptWzBdK3hbMF0tcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihvLnkqbVsxXSt4WzFdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3Ioby53Km1bMF0rMipwdC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKG8uaCptWzBdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpfSxiPW5ldyB0ZSh7bmFtZTp0LGlkOnQsekluZGV4OnYscG9zOmgsYW5jaG9yOlsuNSwuNV0sc2l6ZTpbby53LG8uaF0sc2NhbGU6ZCxyb3RhdGU6cCx0cmFuc2xhdGU6eX0pLEU9bmV3IGVlKHsuLi5jLHBvczpbMCwwXX0pO2lmKGIuYXBwZW5kQ2hpbGQoRSksbil7Y29uc3QgTD1uZXcgYWUoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOmwsbGluZVdpZHRoOjEsc2NhbGU6WzEvbVswXSwxL21bMV1dfSk7Yi5hcHBlbmRDaGlsZChMKX1pZihyLmFwcGVuZChiKSxkfHxwfHx5KXtjb25zdCBMPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihMLngtcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihMLnktcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihMLndpZHRoKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmhlaWdodCsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKX19cmV0dXJuIGd9dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IHh0KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOml9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixpKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgZjtjb25zdHtvcDp0LGlzRnVsbFdvcms6cixyZXBsYWNlSWQ6bn09ZSxpPShmPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Zi50b1N0cmluZygpO2lmKCFpKXJldHVybjtjb25zdCBhPVtdO2ZvcihsZXQgdj0wO3Y8dC5sZW5ndGg7dis9MylhLnB1c2goW3Rbdl0sdFt2KzFdLHRbdisyXV0pO2NvbnN0IGw9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIscz10aGlzLmRyYXcoe3BzOmEsd29ya0lkOmksbGF5ZXI6bCxpc0RyYXdpbmc6ITEscmVwbGFjZUlkOm59KTtyZXR1cm4gdGhpcy5vbGRSZWN0PXMsdGhpcy52Tm9kZXMuc2V0SW5mbyhpLHtyZWN0OnMsb3A6dCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cyYmcHQuZ2V0Q2VudGVyUG9zKHMsbCl9KSxzfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7dmFyIG0sTztjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOmksZmlsbENvbG9yOmEsZm9udENvbG9yOmwsZm9udEJnQ29sb3I6cyxib2xkOmYsaXRhbGljOnYsbGluZVRocm91Z2g6ZCx1bmRlcmxpbmU6cCxmb250U2l6ZTp5fT1yLFA9bi5nZXQodC5uYW1lKTtsZXQgeD10O2lmKHQudGFnTmFtZT09PSJHUk9VUCImJih4PXQuY2hpbGRyZW5bMF0pLGkmJih4LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLGkpLChtPVA9PW51bGw/dm9pZCAwOlAub3B0KSE9bnVsbCYmbS5zdHJva2VDb2xvciYmKFAub3B0LnN0cm9rZUNvbG9yPWkpKSxhJiYoYT09PSJ0cmFuc3BhcmVudCI/eC5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsInJnYmEoMCwwLDAsMCkiKTp4LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixhKSwoTz1QPT1udWxsP3ZvaWQgMDpQLm9wdCkhPW51bGwmJk8uZmlsbENvbG9yJiYoUC5vcHQuZmlsbENvbG9yPWEpKSxQIT1udWxsJiZQLm9wdC50ZXh0T3B0KXtjb25zdCBvPVAub3B0LnRleHRPcHQ7bCYmby5mb250Q29sb3ImJihvLmZvbnRDb2xvcj1sKSxzJiZvLmZvbnRCZ0NvbG9yJiYoby5mb250QmdDb2xvcj1zKSxmJiYoby5ib2xkPWYpLHYmJihvLml0YWxpYz12KSxsZShkKSYmKG8ubGluZVRocm91Z2g9ZCksbGUocCkmJihvLnVuZGVybGluZT1wKSx5JiYoby5mb250U2l6ZT15KX1yZXR1cm4gUCYmbi5zZXRJbmZvKHQubmFtZSxQKSxwdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBLbiBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuU3Rhcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgeTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUsaT0oeT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOnkudG9TdHJpbmcoKTtpZighaSlyZXR1cm57dHlwZTphdC5Ob25lfTtjb25zdHtvcDphLHdvcmtTdGF0ZTpsfT10LHM9YT09bnVsbD92b2lkIDA6YS5sZW5ndGg7aWYoIXN8fHM8MilyZXR1cm57dHlwZTphdC5Ob25lfTtsZXQgZjtpZihsPT09UnQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgeHQoYVswXSxhWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMoYSksIWYpcmV0dXJue3R5cGU6YXQuTm9uZX07aWYoIW4pe2NvbnN0IFA9RGF0ZS5ub3coKTtyZXR1cm4gUC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1QLHt0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppLG9wOnRoaXMudG1wUG9pbnRzLm1hcCh4PT5bLi4ueC5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOmF0Lk5vbmV9fWNvbnN0IHY9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsZD10aGlzLmRyYXcoe3dvcmtJZDppLGxheWVyOnYsaXNEcmF3aW5nOiEwfSkscD1idChkLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1kLHtyZWN0OnAsdHlwZTphdC5EcmF3V29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6aX19Y29uc3VtZUFsbChlKXt2YXIgcztjb25zdHtkYXRhOnR9PWUscj0ocz10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOnMudG9TdHJpbmcoKTtpZighcilyZXR1cm57dHlwZTphdC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTphdC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbcl19O2NvbnN0IG49dGhpcy5mdWxsTGF5ZXIsaT10aGlzLmRyYXcoe3dvcmtJZDpyLGxheWVyOm4saXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PWk7Y29uc3QgYT10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksbD1xdChhKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0Omksb3A6YSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6aSYmcHQuZ2V0Q2VudGVyUG9zKGksbil9KSx7cmVjdDppLHR5cGU6YXQuRnVsbFdvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOnIsb3BzOmwsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBFO2NvbnN0e3dvcmtJZDp0LGxheWVyOnIsaXNEcmF3aW5nOm59PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKEE9PkEucmVtb3ZlKCkpLChFPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8RS5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoQT0+QS5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6aSxmaWxsQ29sb3I6YSx0aGlja25lc3M6bCx6SW5kZXg6cyx2ZXJ0aWNlczpmLGlubmVyVmVydGljZVN0ZXA6dixpbm5lclJhdGlvOmQsc2NhbGU6cCxyb3RhdGU6eSx0cmFuc2xhdGU6UH09dGhpcy53b3JrT3B0aW9ucyx4PXIud29ybGRQb3NpdGlvbixtPXIud29ybGRTY2FsaW5nLHtyZWN0Ok8scG9zOm8scG9pbnRzOmh9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhsLGYsdixkKSxjPXtwb3M6byxjbG9zZTohMCxuYW1lOnQsaWQ6dCxwb2ludHM6aCxsaW5lV2lkdGg6bCxmaWxsQ29sb3I6YSE9PSJ0cmFuc3BhcmVudCImJmF8fHZvaWQgMCxzdHJva2VDb2xvcjppLGNsYXNzTmFtZTpgJHtvWzBdfSwke29bMV19YCxub3JtYWxpemU6ITAsekluZGV4OnMsbGluZUpvaW46InJvdW5kIn0sZz17eDpNYXRoLmZsb29yKE8ueCptWzBdK3hbMF0tcHQuU2FmZUJvcmRlclBhZGRpbmcqbVswXSkseTpNYXRoLmZsb29yKE8ueSptWzFdK3hbMV0tcHQuU2FmZUJvcmRlclBhZGRpbmcqbVsxXSksdzpNYXRoLmZsb29yKE8udyptWzBdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcqbVswXSksaDpNYXRoLmZsb29yKE8uaCptWzFdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcqbVsxXSl9O2lmKG4pe2NvbnN0e25hbWU6QSxpZDpMLHpJbmRleDpNLHN0cm9rZUNvbG9yOkl9PWMsRD1bKGcueCtnLncvMi14WzBdKS9tWzBdLChnLnkrZy5oLzIteFsxXSkvbVsxXV0sUj1uZXcgdGUoe25hbWU6QSxpZDpMLHpJbmRleDpNLHBvczpELGFuY2hvcjpbLjUsLjVdLHNpemU6W2cudyxnLmhdfSksQz1uZXcgZWUoey4uLmMscG9zOlswLDBdfSksQj1uZXcgYWUoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOkksbGluZVdpZHRoOjEsc2NhbGU6WzEvbVswXSwxL21bMV1dfSk7cmV0dXJuIFIuYXBwZW5kKEMsQiksci5hcHBlbmQoUiksZ31wJiYoYy5zY2FsZT1wKSx5JiYoYy5yb3RhdGU9eSksUCYmKGMudHJhbnNsYXRlPVApO2NvbnN0IGI9bmV3IGVlKGMpO2lmKHIuYXBwZW5kKGIpLHB8fHl8fFApe2NvbnN0IEE9Yi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKEEueC1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEEueS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEEud2lkdGgrcHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKEEuaGVpZ2h0K3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gZ31jb21wdXREcmF3UG9pbnRzKGUsdCxyLG4pe2NvbnN0IGk9TnQodGhpcy50bXBQb2ludHMpLGE9W01hdGguZmxvb3IoaS54K2kudy8yKSxNYXRoLmZsb29yKGkueStpLmgvMildLGw9T24oaS53LGkuaCkscz1NYXRoLmZsb29yKE1hdGgubWluKGkudyxpLmgpLzIpLGY9bipzLHY9W10sZD0yKk1hdGguUEkvdDtmb3IobGV0IHk9MDt5PHQ7eSsrKXtjb25zdCBQPXkqZC0uNSpNYXRoLlBJO2xldCB4LG07eSVyPT09MT8oeD1mKmxbMF0qTWF0aC5jb3MoUCksbT1mKmxbMV0qTWF0aC5zaW4oUCkpOih4PXMqbFswXSpNYXRoLmNvcyhQKSxtPXMqbFsxXSpNYXRoLnNpbihQKSx2LnB1c2goeCxtKSksdi5wdXNoKHgsbSl9cmV0dXJue3JlY3Q6TnQodGhpcy50bXBQb2ludHMsZSkscG9zOmEscG9pbnRzOnZ9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyB4dCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczppfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIsaSl8fHh0LlN1YihuLHIpLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBsO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGw9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpsLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyB4dCh0W3NdLHRbcysxXSx0W3MrMl0pKTtjb25zdCBpPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGE9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjppLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9YSx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6YSxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczphJiZwdC5nZXRDZW50ZXJQb3MoYSxpKX0pLGF9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXtjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOmksZmlsbENvbG9yOmEsdG9vbHNUeXBlOmwsdmVydGljZXM6cyxpbm5lclZlcnRpY2VTdGVwOmYsaW5uZXJSYXRpbzp2fT1yLGQ9bi5nZXQodC5uYW1lKSxwPWQ9PW51bGw/dm9pZCAwOmQub3B0O2xldCB5PXQ7cmV0dXJuIHQudGFnTmFtZT09PSJHUk9VUCImJih5PXQuY2hpbGRyZW5bMF0pLGkmJih5LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLGkpLHAhPW51bGwmJnAuc3Ryb2tlQ29sb3ImJihwLnN0cm9rZUNvbG9yPWkpKSxhJiYoYT09PSJ0cmFuc3BhcmVudCI/eS5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsInJnYmEoMCwwLDAsMCkiKTp5LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixhKSxwIT1udWxsJiZwLmZpbGxDb2xvciYmKHAuZmlsbENvbG9yPWEpKSxsPT09ZHQuU3RhciYmKHMmJihwLnZlcnRpY2VzPXMpLGYmJihwLmlubmVyVmVydGljZVN0ZXA9ZiksdiYmKHAuaW5uZXJSYXRpbz12KSksZCYmbi5zZXRJbmZvKHQubmFtZSx7Li4uZCxvcHQ6cH0pLHB0LnVwZGF0ZU5vZGVPcHQoZSl9fWNsYXNzIFZuIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmp0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpkdC5Qb2x5Z29ufSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciB5O2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxpPSh5PXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6eS50b1N0cmluZygpO2lmKCFpKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0e29wOmEsd29ya1N0YXRlOmx9PXQscz1hPT1udWxsP3ZvaWQgMDphLmxlbmd0aDtpZighc3x8czwyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2xldCBmO2lmKGw9PT1SdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyB4dChhWzBdLGFbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhhKSwhZilyZXR1cm57dHlwZTphdC5Ob25lfTtpZighbil7Y29uc3QgUD1EYXRlLm5vdygpO3JldHVybiBQLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVAse3R5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmksb3A6dGhpcy50bXBQb2ludHMubWFwKHg9PlsuLi54LlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6YXQuTm9uZX19Y29uc3Qgdj1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixkPXRoaXMuZHJhdyh7d29ya0lkOmksbGF5ZXI6dixpc0RyYXdpbmc6ITB9KSxwPWJ0KGQsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWQse3JlY3Q6cCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppfX1jb25zdW1lQWxsKGUpe3ZhciBzO2NvbnN0e2RhdGE6dH09ZSxyPShzPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixpPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bixpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9aTtjb25zdCBhPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxsPXF0KGEpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6aSxvcDphLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxuKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6bCxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGc7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cixpc0RyYXdpbmc6bn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoYj0+Yi5yZW1vdmUoKSksKGc9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxnLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChiPT5iLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjppLGZpbGxDb2xvcjphLHRoaWNrbmVzczpsLHpJbmRleDpzLHZlcnRpY2VzOmYsc2NhbGU6dixyb3RhdGU6ZCx0cmFuc2xhdGU6cH09dGhpcy53b3JrT3B0aW9ucyx5PXIud29ybGRQb3NpdGlvbixQPXIud29ybGRTY2FsaW5nLHtyZWN0OngscG9zOm0scG9pbnRzOk99PXRoaXMuY29tcHV0RHJhd1BvaW50cyhsLGYpLG89e3BvczptLGNsb3NlOiEwLG5hbWU6dCxpZDp0LHBvaW50czpPLGxpbmVXaWR0aDpsLGZpbGxDb2xvcjphIT09InRyYW5zcGFyZW50IiYmYXx8dm9pZCAwLHN0cm9rZUNvbG9yOmksbm9ybWFsaXplOiEwLHpJbmRleDpzLGxpbmVKb2luOiJyb3VuZCJ9LGg9e3g6TWF0aC5mbG9vcih4LngqUFswXSt5WzBdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKlBbMF0pLHk6TWF0aC5mbG9vcih4LnkqUFsxXSt5WzFdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKlBbMV0pLHc6TWF0aC5mbG9vcih4LncqUFswXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKlBbMF0pLGg6TWF0aC5mbG9vcih4LmgqUFsxXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKlBbMV0pfTtpZihuKXtjb25zdHtuYW1lOmIsaWQ6RSx6SW5kZXg6QSxzdHJva2VDb2xvcjpMfT1vLE09WyhoLngraC53LzIteVswXSkvUFswXSwoaC55K2guaC8yLXlbMV0pL1BbMV1dLEk9bmV3IHRlKHtuYW1lOmIsaWQ6RSx6SW5kZXg6QSxwb3M6TSxhbmNob3I6Wy41LC41XSxzaXplOltoLncsaC5oXX0pLEQ9bmV3IGVlKHsuLi5vLHBvczpbMCwwXX0pLFI9bmV3IGFlKHtkOiJNLTQsMEg0TTAsLTRWNCIsbm9ybWFsaXplOiEwLHBvczpbMCwwXSxzdHJva2VDb2xvcjpMLGxpbmVXaWR0aDoxLHNjYWxlOlsxL1BbMF0sMS9QWzFdXX0pO3JldHVybiBJLmFwcGVuZChELFIpLHIuYXBwZW5kKEkpLGh9diYmKG8uc2NhbGU9diksZCYmKG8ucm90YXRlPWQpLHAmJihvLnRyYW5zbGF0ZT1wKTtjb25zdCBjPW5ldyBlZShvKTtpZihyLmFwcGVuZChjKSx2fHxkfHxwKXtjb25zdCBiPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihiLngtcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihiLnktcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihiLndpZHRoK3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihiLmhlaWdodCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19cmV0dXJuIGh9Y29tcHV0RHJhd1BvaW50cyhlLHQpe2NvbnN0IHI9TnQodGhpcy50bXBQb2ludHMpLG49W01hdGguZmxvb3Ioci54K3Iudy8yKSxNYXRoLmZsb29yKHIueStyLmgvMildLGk9T24oci53LHIuaCksYT1NYXRoLmZsb29yKE1hdGgubWluKHIudyxyLmgpLzIpLGw9W10scz0yKk1hdGguUEkvdDtmb3IobGV0IHY9MDt2PHQ7disrKXtjb25zdCBkPXYqcy0uNSpNYXRoLlBJLHA9YSppWzBdKk1hdGguY29zKGQpLHk9YSppWzFdKk1hdGguc2luKGQpO2wucHVzaChwLHkpfXJldHVybntyZWN0Ok50KHRoaXMudG1wUG9pbnRzLGUpLHBvczpuLHBvaW50czpsfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMikscj1uZXcgeHQodFswXSx0WzFdKSxuPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6aX09dGhpcy53b3JrT3B0aW9ucztpZihuLmlzTmVhcihyLGkpfHx4dC5TdWIobixyKS5YWS5pbmNsdWRlcygwKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgbDtjb25zdHtvcDp0LGlzRnVsbFdvcms6cn09ZSxuPShsPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6bC50b1N0cmluZygpO2lmKCFuKXJldHVybjt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrPTMpdGhpcy50bXBQb2ludHMucHVzaChuZXcgeHQodFtzXSx0W3MrMV0sdFtzKzJdKSk7Y29uc3QgaT1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixhPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6aSxpc0RyYXdpbmc6ITF9KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWEsdGhpcy52Tm9kZXMuc2V0SW5mbyhuLHtyZWN0OmEsb3A6dCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6YSYmcHQuZ2V0Q2VudGVyUG9zKGEsaSl9KSxhfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpufT1lLHtzdHJva2VDb2xvcjppLGZpbGxDb2xvcjphLHRvb2xzVHlwZTpsLHZlcnRpY2VzOnN9PXIsZj1uLmdldCh0Lm5hbWUpLHY9Zj09bnVsbD92b2lkIDA6Zi5vcHQ7bGV0IGQ9dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKGQ9dC5jaGlsZHJlblswXSksaSYmKGQuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsaSksdiE9bnVsbCYmdi5zdHJva2VDb2xvciYmKHYuc3Ryb2tlQ29sb3I9aSkpLGEmJihhPT09InRyYW5zcGFyZW50Ij9kLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOmQuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGEpLHYhPW51bGwmJnYuZmlsbENvbG9yJiYodi5maWxsQ29sb3I9YSkpLGw9PT1kdC5Qb2x5Z29uJiZzJiYodi52ZXJ0aWNlcz1zKSxmJiZuLnNldEluZm8odC5uYW1lLHsuLi5mLG9wdDp2fSkscHQudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgUXR7c3RhdGljIGJlemllcihlLHQpe2NvbnN0IHI9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKz00KXtjb25zdCBpPXRbbl0sYT10W24rMV0sbD10W24rMl0scz10W24rM107aSYmYSYmbCYmcz9yLnB1c2goLi4uUXQuZ2V0QmV6aWVyUG9pbnRzKGUsaSxhLGwscykpOmkmJmEmJmw/ci5wdXNoKC4uLlF0LmdldEJlemllclBvaW50cyhlLGksYSxsKSk6aSYmYT9yLnB1c2goLi4uUXQuZ2V0QmV6aWVyUG9pbnRzKGUsaSxhKSk6aSYmci5wdXNoKGkpfXJldHVybiByfXN0YXRpYyBnZXRCZXppZXJQb2ludHMoZT0xMCx0LHIsbixpKXtsZXQgYT1udWxsO2NvbnN0IGw9W107IW4mJiFpP2E9UXQub25lQmV6aWVyOm4mJiFpP2E9UXQudHdvQmV6aWVyOm4mJmkmJihhPVF0LnRocmVlQmV6aWVyKTtmb3IobGV0IHM9MDtzPGU7cysrKWEmJmwucHVzaChhKHMvZSx0LHIsbixpKSk7cmV0dXJuIGk/bC5wdXNoKGkpOm4mJmwucHVzaChuKSxsfXN0YXRpYyBvbmVCZXppZXIoZSx0LHIpe2NvbnN0IG49dC54KyhyLngtdC54KSplLGk9dC55KyhyLnktdC55KSplO3JldHVybiBuZXcgZXQobixpKX1zdGF0aWMgdHdvQmV6aWVyKGUsdCxyLG4pe2NvbnN0IGk9KDEtZSkqKDEtZSkqdC54KzIqZSooMS1lKSpyLngrZSplKm4ueCxhPSgxLWUpKigxLWUpKnQueSsyKmUqKDEtZSkqci55K2UqZSpuLnk7cmV0dXJuIG5ldyBldChpLGEpfXN0YXRpYyB0aHJlZUJlemllcihlLHQscixuLGkpe2NvbnN0IGE9dC54KigxLWUpKigxLWUpKigxLWUpKzMqci54KmUqKDEtZSkqKDEtZSkrMypuLngqZSplKigxLWUpK2kueCplKmUqZSxsPXQueSooMS1lKSooMS1lKSooMS1lKSszKnIueSplKigxLWUpKigxLWUpKzMqbi55KmUqZSooMS1lKStpLnkqZSplKmU7cmV0dXJuIG5ldyBldChhLGwpfX1jbGFzcyBZbiBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuU3BlZWNoQmFsbG9vbn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJyYXRpbyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOi44fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciB5O2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxpPSh5PXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6eS50b1N0cmluZygpO2lmKCFpKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0e29wOmEsd29ya1N0YXRlOmx9PXQscz1hPT1udWxsP3ZvaWQgMDphLmxlbmd0aDtpZighc3x8czwyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2xldCBmO2lmKGw9PT1SdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyB4dChhWzBdLGFbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhhKSwhZilyZXR1cm57dHlwZTphdC5Ob25lfTtpZighbil7Y29uc3QgUD1EYXRlLm5vdygpO3JldHVybiBQLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVAse3R5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmksb3A6dGhpcy50bXBQb2ludHMubWFwKHg9PlsuLi54LlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6YXQuTm9uZX19Y29uc3Qgdj1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixkPXRoaXMuZHJhdyh7d29ya0lkOmksbGF5ZXI6dixpc0RyYXdpbmc6ITB9KSxwPWJ0KGQsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWQse3JlY3Q6cCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppfX1jb25zdW1lQWxsKGUpe3ZhciBzO2NvbnN0e2RhdGE6dH09ZSxyPShzPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixpPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bixpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9aTtjb25zdCBhPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxsPXF0KGEpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6aSxvcDphLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxuKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6bCxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGM7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoZz0+Zy5yZW1vdmUoKSksKGM9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxjLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChnPT5nLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjpuLGZpbGxDb2xvcjppLHRoaWNrbmVzczphLHpJbmRleDpsLHBsYWNlbWVudDpzLHNjYWxlOmYscm90YXRlOnYsdHJhbnNsYXRlOmR9PXRoaXMud29ya09wdGlvbnMscD1yLndvcmxkUG9zaXRpb24seT1yLndvcmxkU2NhbGluZyx7cmVjdDpQLHBvczp4LHBvaW50czptfT10aGlzLmNvbXB1dERyYXdQb2ludHMoYSxzKSxPPXtwb3M6eCxuYW1lOnQsaWQ6dCxwb2ludHM6bS5tYXAoZz0+Zy5YWSksbGluZVdpZHRoOmEsZmlsbENvbG9yOmkhPT0idHJhbnNwYXJlbnQiJiZpfHx2b2lkIDAsc3Ryb2tlQ29sb3I6bixub3JtYWxpemU6ITAsY2xhc3NOYW1lOmAke3hbMF19LCR7eFsxXX1gLHpJbmRleDpsLGxpbmVKb2luOiJyb3VuZCIsY2xvc2U6ITB9LG89e3g6TWF0aC5mbG9vcihQLngqeVswXStwWzBdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKnlbMF0pLHk6TWF0aC5mbG9vcihQLnkqeVsxXStwWzFdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKnlbMV0pLHc6TWF0aC5mbG9vcihQLncqeVswXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKnlbMF0pLGg6TWF0aC5mbG9vcihQLmgqeVsxXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKnlbMV0pfTtmJiYoTy5zY2FsZT1mKSx2JiYoTy5yb3RhdGU9diksZCYmKE8udHJhbnNsYXRlPWQpO2NvbnN0IGg9bmV3IGVlKE8pO2lmKHIuYXBwZW5kKGgpLGZ8fHZ8fGQpe2NvbnN0IGc9aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKGcueC1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKGcueS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKGcud2lkdGgrcHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKGcuaGVpZ2h0K3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gb310cmFuc2Zvcm1Db250cm9sUG9pbnRzKGUpe2NvbnN0IHQ9TnQodGhpcy50bXBQb2ludHMpO3N3aXRjaChlKXtjYXNlImJvdHRvbSI6Y2FzZSJib3R0b21MZWZ0IjpjYXNlImJvdHRvbVJpZ2h0Ijp7Y29uc3Qgcj10LnkrdC5oKnRoaXMucmF0aW87cmV0dXJuW25ldyBldCh0LngsdC55LDApLG5ldyBldCh0LngrdC53LHQueSwwKSxuZXcgZXQodC54K3QudyxyLDApLG5ldyBldCh0LngsciwwKV19Y2FzZSJ0b3AiOmNhc2UidG9wTGVmdCI6Y2FzZSJ0b3BSaWdodCI6e2NvbnN0IHI9dC55K3QuaCooMS10aGlzLnJhdGlvKTtyZXR1cm5bbmV3IGV0KHQueCxyLDApLG5ldyBldCh0LngrdC53LHIsMCksbmV3IGV0KHQueCt0LncsdC55K3QuaCwwKSxuZXcgZXQodC54LHQueSt0LmgsMCldfWNhc2UibGVmdCI6Y2FzZSJsZWZ0Qm90dG9tIjpjYXNlImxlZnRUb3AiOntjb25zdCByPXQueCt0LncqKDEtdGhpcy5yYXRpbyk7cmV0dXJuW25ldyBldChyLHQueSwwKSxuZXcgZXQodC54K3Qudyx0LnksMCksbmV3IGV0KHQueCt0LncsdC55K3QuaCwwKSxuZXcgZXQocix0LnkrdC5oLDApXX1jYXNlInJpZ2h0IjpjYXNlInJpZ2h0Qm90dG9tIjpjYXNlInJpZ2h0VG9wIjp7Y29uc3Qgcj10LngrdC53KnRoaXMucmF0aW87cmV0dXJuW25ldyBldCh0LngsdC55LDApLG5ldyBldChyLHQueSwwKSxuZXcgZXQocix0LnkrdC5oLDApLG5ldyBldCh0LngsdC55K3QuaCwwKV19fX1jb21wdXREcmF3UG9pbnRzKGUsdCl7Y29uc3Qgcj1OdCh0aGlzLnRtcFBvaW50cyksbj10aGlzLnRyYW5zZm9ybUNvbnRyb2xQb2ludHModCksaT1NYXRoLmZsb29yKHIudyouMSksYT1NYXRoLmZsb29yKHIuaCouMSksbD1bXSxzPWV0LkFkZChuWzBdLG5ldyBldCgwLGEsMCkpLGY9ZXQuQWRkKG5bMF0sbmV3IGV0KGksMCwwKSksdj1RdC5nZXRCZXppZXJQb2ludHMoMTAscyxuWzBdLGYpLGQ9ZXQuU3ViKG5bMV0sbmV3IGV0KGksMCwwKSkscD1ldC5BZGQoblsxXSxuZXcgZXQoMCxhLDApKSx5PVF0LmdldEJlemllclBvaW50cygxMCxkLG5bMV0scCksUD1ldC5TdWIoblsyXSxuZXcgZXQoMCxhLDApKSx4PWV0LlN1YihuWzJdLG5ldyBldChpLDAsMCkpLG09UXQuZ2V0QmV6aWVyUG9pbnRzKDEwLFAsblsyXSx4KSxPPWV0LkFkZChuWzNdLG5ldyBldChpLDAsMCkpLG89ZXQuU3ViKG5bM10sbmV3IGV0KDAsYSwwKSksaD1RdC5nZXRCZXppZXJQb2ludHMoMTAsTyxuWzNdLG8pLGM9aSooMS10aGlzLnJhdGlvKSoxMCxnPWEqKDEtdGhpcy5yYXRpbykqMTA7c3dpdGNoKHQpe2Nhc2UiYm90dG9tIjp7Y29uc3QgQT1ldC5TdWIoblsyXSxuZXcgZXQoaSo1LWMvMiwwLDApKSxMPWV0LlN1YihuWzJdLG5ldyBldChpKjUsLWcsMCkpLE09ZXQuU3ViKG5bMl0sbmV3IGV0KGkqNStjLzIsMCwwKSk7bC5wdXNoKEwsTSwuLi5oLC4uLnYsLi4ueSwuLi5tLEEpO2JyZWFrfWNhc2UiYm90dG9tUmlnaHQiOntjb25zdCBBPWV0LlN1YihuWzJdLG5ldyBldChpKjEuMSwwLDApKSxMPWV0LlN1YihuWzJdLG5ldyBldChpKjEuMStjLzIsLWcsMCkpLE09ZXQuU3ViKG5bMl0sbmV3IGV0KGkqMS4xK2MsMCwwKSk7bC5wdXNoKEwsTSwuLi5oLC4uLnYsLi4ueSwuLi5tLEEpO2JyZWFrfWNhc2UiYm90dG9tTGVmdCI6e2NvbnN0IEE9ZXQuQWRkKG5bM10sbmV3IGV0KGkqMS4xK2MsMCwwKSksTD1ldC5BZGQoblszXSxuZXcgZXQoaSoxLjErYy8yLGcsMCkpLE09ZXQuQWRkKG5bM10sbmV3IGV0KGkqMS4xLDAsMCkpO2wucHVzaChMLE0sLi4uaCwuLi52LC4uLnksLi4ubSxBKTticmVha31jYXNlInRvcCI6e2NvbnN0IEE9ZXQuU3ViKG5bMV0sbmV3IGV0KGkqNS1jLzIsMCwwKSksTD1ldC5TdWIoblsxXSxuZXcgZXQoaSo1LGcsMCkpLE09ZXQuU3ViKG5bMV0sbmV3IGV0KGkqNStjLzIsMCwwKSk7bC5wdXNoKEwsQSwuLi55LC4uLm0sLi4uaCwuLi52LE0pO2JyZWFrfWNhc2UidG9wUmlnaHQiOntjb25zdCBBPWV0LlN1YihuWzFdLG5ldyBldChpKjEuMSwwLDApKSxMPWV0LlN1YihuWzFdLG5ldyBldChpKjEuMStjLzIsZywwKSksTT1ldC5TdWIoblsxXSxuZXcgZXQoaSoxLjErYywwLDApKTtsLnB1c2goTCxBLC4uLnksLi4ubSwuLi5oLC4uLnYsTSk7YnJlYWt9Y2FzZSJ0b3BMZWZ0Ijp7Y29uc3QgQT1ldC5BZGQoblswXSxuZXcgZXQoaSoxLjErYywwLDApKSxMPWV0LkFkZChuWzBdLG5ldyBldChpKjEuMStjLzIsLWcsMCkpLE09ZXQuQWRkKG5bMF0sbmV3IGV0KGkqMS4xLDAsMCkpO2wucHVzaChMLEEsLi4ueSwuLi5tLC4uLmgsLi4udixNKTticmVha31jYXNlImxlZnQiOntjb25zdCBBPWV0LkFkZChuWzBdLG5ldyBldCgwLGEqNS1nLzIsMCkpLEw9ZXQuQWRkKG5bMF0sbmV3IGV0KC1jLGEqNSwwKSksTT1ldC5BZGQoblswXSxuZXcgZXQoMCxhKjUrZy8yLDApKTtsLnB1c2goTCxBLC4uLnYsLi4ueSwuLi5tLC4uLmgsTSk7YnJlYWt9Y2FzZSJsZWZ0VG9wIjp7Y29uc3QgQT1ldC5BZGQoblswXSxuZXcgZXQoMCxhKjEuMSwwKSksTD1ldC5BZGQoblswXSxuZXcgZXQoLWMsYSoxLjErZy8yLDApKSxNPWV0LkFkZChuWzBdLG5ldyBldCgwLGEqMS4xK2csMCkpO2wucHVzaChMLEEsLi4udiwuLi55LC4uLm0sLi4uaCxNKTticmVha31jYXNlImxlZnRCb3R0b20iOntjb25zdCBBPWV0LlN1YihuWzNdLG5ldyBldCgwLGEqMS4xK2csMCkpLEw9ZXQuU3ViKG5bM10sbmV3IGV0KGMsYSoxLjErZy8yLDApKSxNPWV0LlN1YihuWzNdLG5ldyBldCgwLGEqMS4xLDApKTtsLnB1c2goTCxBLC4uLnYsLi4ueSwuLi5tLC4uLmgsTSk7YnJlYWt9Y2FzZSJyaWdodCI6e2NvbnN0IEE9ZXQuQWRkKG5bMV0sbmV3IGV0KDAsYSo1LWcvMiwwKSksTD1ldC5BZGQoblsxXSxuZXcgZXQoYyxhKjUsMCkpLE09ZXQuQWRkKG5bMV0sbmV3IGV0KDAsYSo1K2cvMiwwKSk7bC5wdXNoKEwsTSwuLi5tLC4uLmgsLi4udiwuLi55LEEpO2JyZWFrfWNhc2UicmlnaHRUb3AiOntjb25zdCBBPWV0LkFkZChuWzFdLG5ldyBldCgwLGEqMS4xLDApKSxMPWV0LkFkZChuWzFdLG5ldyBldChjLGEqMS4xK2cvMiwwKSksTT1ldC5BZGQoblsxXSxuZXcgZXQoMCxhKjEuMStnLDApKTtsLnB1c2goTCxNLC4uLm0sLi4uaCwuLi52LC4uLnksQSk7YnJlYWt9Y2FzZSJyaWdodEJvdHRvbSI6e2NvbnN0IEE9ZXQuU3ViKG5bMl0sbmV3IGV0KDAsYSoxLjErZywwKSksTD1ldC5TdWIoblsyXSxuZXcgZXQoLWMsYSoxLjErZy8yLDApKSxNPWV0LlN1YihuWzJdLG5ldyBldCgwLGEqMS4xLDApKTtsLnB1c2goTCxNLC4uLm0sLi4uaCwuLi52LC4uLnksQSk7YnJlYWt9fWNvbnN0IGI9TnQodGhpcy50bXBQb2ludHMsZSksRT1bTWF0aC5mbG9vcihiLngrYi53LzIpLE1hdGguZmxvb3IoYi55K2IuaC8yKV07cmV0dXJue3JlY3Q6Yixwb3M6RSxwb2ludHM6bH19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IHh0KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOml9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixpKXx8eHQuU3ViKG4scikuWFkuaW5jbHVkZXMoMCkpcmV0dXJuITE7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09Mil7aWYoci5pc05lYXIodGhpcy50bXBQb2ludHNbMV0sMSkpcmV0dXJuITE7dGhpcy50bXBQb2ludHNbMV09cn1lbHNlIHRoaXMudG1wUG9pbnRzLnB1c2gocik7cmV0dXJuITB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIGw7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOnJ9PWUsbj0obD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmwudG9TdHJpbmcoKTtpZighbilyZXR1cm47dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKz0zKXRoaXMudG1wUG9pbnRzLnB1c2gobmV3IHh0KHRbc10sdFtzKzFdLHRbcysyXSkpO2NvbnN0IGk9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsYT10aGlzLmRyYXcoe3dvcmtJZDpuLGxheWVyOmksaXNEcmF3aW5nOiExfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1hLHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDphLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmEmJnB0LmdldENlbnRlclBvcyhhLGkpfSksYX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6aSxmaWxsQ29sb3I6YSx0b29sc1R5cGU6bCxwbGFjZW1lbnQ6c309cixmPW4uZ2V0KHQubmFtZSksdj1mPT1udWxsP3ZvaWQgMDpmLm9wdDtsZXQgZD10O3JldHVybiB0LnRhZ05hbWU9PT0iR1JPVVAiJiYoZD10LmNoaWxkcmVuWzBdKSxpJiYoZC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixpKSx2IT1udWxsJiZ2LnN0cm9rZUNvbG9yJiYodi5zdHJva2VDb2xvcj1pKSksYSYmKGE9PT0idHJhbnNwYXJlbnQiP2Quc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLCJyZ2JhKDAsMCwwLDApIik6ZC5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsYSksdiE9bnVsbCYmdi5maWxsQ29sb3ImJih2LmZpbGxDb2xvcj1hKSksbD09PWR0LlNwZWVjaEJhbGxvb24mJnMmJih2LnBsYWNlbWVudD1zKSxmJiZuLnNldEluZm8odC5uYW1lLHsuLi5mLG9wdDp2fSkscHQudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgWG4gZXh0ZW5kcyBwdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6anQuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmR0LkltYWdlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zY2FsZVR5cGU9dGhpcy53b3JrT3B0aW9ucy51bmlmb3JtU2NhbGU/anQucHJvcG9ydGlvbmFsOmp0LmFsbH1jb25zdW1lKCl7cmV0dXJue3R5cGU6YXQuTm9uZX19Y29uc3VtZUFsbCgpe3JldHVybnt0eXBlOmF0Lk5vbmV9fWRyYXcoZSl7dmFyIG87Y29uc3R7bGF5ZXI6dCx3b3JrSWQ6cixyZXBsYWNlSWQ6bixpbWFnZUJpdG1hcDppfT1lLHtjZW50ZXJYOmEsY2VudGVyWTpsLHdpZHRoOnMsaGVpZ2h0OmYsc2NhbGU6dixyb3RhdGU6ZCx0cmFuc2xhdGU6cCx6SW5kZXg6eX09dGhpcy53b3JrT3B0aW9uczt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShufHxyKS5tYXAoaD0+aC5yZW1vdmUoKSksKG89dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxvLmdldEVsZW1lbnRzQnlOYW1lKG58fHIpLm1hcChoPT5oLnJlbW92ZSgpKTtjb25zdCBQPXthbmNob3I6Wy41LC41XSxwb3M6W2EsbF0sbmFtZTpyLHNpemU6W3MsZl0sekluZGV4Onl9O2lmKHYpaWYodGhpcy5zY2FsZVR5cGU9PT1qdC5wcm9wb3J0aW9uYWwpe2NvbnN0IGg9TWF0aC5taW4odlswXSx2WzFdKTtQLnNjYWxlPVtoLGhdfWVsc2UgUC5zY2FsZT12O3AmJihQLnRyYW5zbGF0ZT1wKSxkJiYoUC5yb3RhdGU9ZCk7Y29uc3QgeD1uZXcgdGUoUCksbT1uZXcgVmgoe2FuY2hvcjpbLjUsLjVdLHBvczpbMCwwXSxzaXplOltzLGZdLHRleHR1cmU6aSxyb3RhdGU6MTgwfSk7eC5hcHBlbmQobSksdC5hcHBlbmQoeCk7Y29uc3QgTz14LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKE8pcmV0dXJue3g6TWF0aC5mbG9vcihPLngtcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihPLnktcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihPLndpZHRoK3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihPLmhlaWdodCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19Y29uc3VtZVNlcnZpY2UoKXt9YXN5bmMgY29uc3VtZVNlcnZpY2VBc3luYyhlKXt2YXIgZix2O2NvbnN0e2lzRnVsbFdvcms6dCxyZXBsYWNlSWQ6cixzY2VuZTpufT1lLHtzcmM6aSx1dWlkOmF9PXRoaXMud29ya09wdGlvbnMsbD0oKGY9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCkpfHxhLHM9dD90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7aWYoaSl7Y29uc3QgZD1hd2FpdCBuLnByZWxvYWQoe2lkOmEsc3JjOnRoaXMud29ya09wdGlvbnMuc3JjfSkscD10aGlzLmRyYXcoe3dvcmtJZDpsLGxheWVyOnMscmVwbGFjZUlkOnIsaW1hZ2VCaXRtYXA6ZFswXX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCYmKCh2PXRoaXMudk5vZGVzLmdldChsKSk9PW51bGw/dm9pZCAwOnYucmVjdCl8fHZvaWQgMCx0aGlzLnZOb2Rlcy5zZXRJbmZvKGwse3JlY3Q6cCxvcDpbXSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cCYmcHQuZ2V0Q2VudGVyUG9zKHAscyl9KSxwfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bix0YXJnZXROb2RlOml9PWUse3RyYW5zbGF0ZTphLGJveDpsLGJveFNjYWxlOnMsYm94VHJhbnNsYXRlOmYsYW5nbGU6dixpc0xvY2tlZDpkLHpJbmRleDpwfT1yLHk9aSYmWXQoaSl8fG4uZ2V0KHQubmFtZSk7aWYoIXkpcmV0dXJuO2NvbnN0IFA9dC5wYXJlbnQ7aWYoUCl7aWYobmUocCkmJih0LnNldEF0dHJpYnV0ZSgiekluZGV4IixwKSx5Lm9wdC56SW5kZXg9cCksbGUoZCkmJih5Lm9wdC5sb2NrZWQ9ZCksbCYmZiYmcyl7Y29uc3R7Y2VudGVyWDp4LGNlbnRlclk6bSx3aWR0aDpPLGhlaWdodDpvLHVuaWZvcm1TY2FsZTpofT15Lm9wdDtpZihoKXtjb25zdCBiPU1hdGgubWluKHNbMF0sc1sxXSk7eS5vcHQuc2NhbGU9W2IsYl19ZWxzZSB5Lm9wdC5zY2FsZT1zO3kub3B0LndpZHRoPU1hdGguZmxvb3IoTypzWzBdKSx5Lm9wdC5oZWlnaHQ9TWF0aC5mbG9vcihvKnNbMV0pO2NvbnN0IGM9W2ZbMF0vUC53b3JsZFNjYWxpbmdbMF0sZlsxXS9QLndvcmxkU2NhbGluZ1sxXV07eS5vcHQuY2VudGVyWD14K2NbMF0seS5vcHQuY2VudGVyWT1tK2NbMV07Y29uc3QgZz1beS5jZW50ZXJQb3NbMF0rY1swXSx5LmNlbnRlclBvc1sxXStjWzFdXTtpZih5LmNlbnRlclBvcz1nLGkpe2xldCBiPXhuKHkucmVjdCxzKTtiPU9lKGIsYykseS5yZWN0PWJ9fWVsc2UgaWYoYSl7Y29uc3QgeD1bYVswXS9QLndvcmxkU2NhbGluZ1swXSxhWzFdL1Aud29ybGRTY2FsaW5nWzFdXTtpZih5Lm9wdC5jZW50ZXJYPXkub3B0LmNlbnRlclgreFswXSx5Lm9wdC5jZW50ZXJZPXkub3B0LmNlbnRlclkreFsxXSx5LmNlbnRlclBvcz1beS5jZW50ZXJQb3NbMF0reFswXSx5LmNlbnRlclBvc1sxXSt4WzFdXSxpKXtjb25zdCBtPU9lKHkucmVjdCx4KTt5LnJlY3Q9bX19ZWxzZSBpZihuZSh2KSYmKHQuc2V0QXR0cmlidXRlKCJyb3RhdGUiLHYpLHkub3B0LnJvdGF0ZT12LGkpKXtjb25zdCB4PVNuKHkucmVjdCx2KTt5LnJlY3Q9eH1yZXR1cm4geSYmbi5zZXRJbmZvKHQubmFtZSx5KSx5PT1udWxsP3ZvaWQgMDp5LnJlY3R9fX1jbGFzcyBabiBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5ib3RofSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmR0LlN0cmFpZ2h0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3RyYWlnaHRUaXBXaWR0aCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3RyYWlnaHRUaXBXaWR0aD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcy8yLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfWNvbnN1bWUoZSl7dmFyIHk7Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6cixpc1N1YldvcmtlcjpufT1lLGk9KHk9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDp5LnRvU3RyaW5nKCk7aWYoIWkpcmV0dXJue3R5cGU6YXQuTm9uZX07Y29uc3R7b3A6YSx3b3JrU3RhdGU6bH09dCxzPWE9PW51bGw/dm9pZCAwOmEubGVuZ3RoO2lmKCFzfHxzPDIpcmV0dXJue3R5cGU6YXQuTm9uZX07bGV0IGY7aWYobD09PVJ0LlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IHh0KGFbMF0sYVsxXSldLGY9ITEpOmY9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGEpLCFmKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKCFuKXtjb25zdCBQPURhdGUubm93KCk7cmV0dXJuIFAtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lPyh0aGlzLnN5bmNUaW1lc3RhbXA9UCx7dHlwZTphdC5EcmF3V29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6aSxvcDp0aGlzLnRtcFBvaW50cy5tYXAoeD0+Wy4uLnguWFksMF0pLmZsYXQoMSksaXNTeW5jOiEwLGluZGV4OjB9KTp7dHlwZTphdC5Ob25lfX1jb25zdCB2PXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGQ9dGhpcy5kcmF3KHt3b3JrSWQ6aSxsYXllcjp2fSkscD1idChkLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1kLHtyZWN0OnAsdHlwZTphdC5EcmF3V29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6aX19Y29uc3VtZUFsbChlKXt2YXIgcztjb25zdHtkYXRhOnR9PWUscj0ocz10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOnMudG9TdHJpbmcoKTtpZighcilyZXR1cm57dHlwZTphdC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTphdC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbcl19O2NvbnN0IG49dGhpcy5mdWxsTGF5ZXIsaT10aGlzLmRyYXcoe3dvcmtJZDpyLGxheWVyOm59KTt0aGlzLm9sZFJlY3Q9aTtjb25zdCBhPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxsPXF0KGEpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6aSxvcDphLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxuKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6bCxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIG87Y29uc3R7d29ya0lkOnQsbGF5ZXI6cn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoaD0+aC5yZW1vdmUoKSksKG89dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxvLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChoPT5oLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjpuLHRoaWNrbmVzczppLHpJbmRleDphLHNjYWxlOmwscm90YXRlOnMsdHJhbnNsYXRlOmZ9PXRoaXMud29ya09wdGlvbnMsdj1yLndvcmxkUG9zaXRpb24sZD1yLndvcmxkU2NhbGluZyx7ZDpwLHJlY3Q6eX09dGhpcy5jb21wdXREcmF3UG9pbnRzKGkpLFA9W3kueCt5LncvMix5LnkreS5oLzJdLHg9e3BvczpQLG5hbWU6dCxpZDp0LGQ6cCxmaWxsQ29sb3I6bixzdHJva2VDb2xvcjpuLGxpbmVXaWR0aDowLGNsYXNzTmFtZTpgJHtQWzBdfSwke1BbMV19YCxub3JtYWxpemU6ITAsekluZGV4OmF9O2wmJih4LnNjYWxlPWwpLHMmJih4LnJvdGF0ZT1zKSxmJiYoeC50cmFuc2xhdGU9Zik7Y29uc3QgbT1uZXcgYWUoeCk7aWYoci5hcHBlbmQobSksc3x8bHx8Zil7Y29uc3QgaD1tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaC54LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaC55LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaC53aWR0aCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaC5oZWlnaHQrcHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybnt4Ok1hdGguZmxvb3IoeS54KmRbMF0rdlswXS1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKHkueSpkWzFdK3ZbMV0tcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcih5LncqZFswXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IoeS5oKmRbMV0rMipwdC5TYWZlQm9yZGVyUGFkZGluZyl9fWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMudG1wUG9pbnRzWzFdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzWzBdKT50aGlzLnN0cmFpZ2h0VGlwV2lkdGg/dGhpcy5jb21wdXRGdWxsUG9pbnRzKGUpOnRoaXMuY29tcHV0RG90UG9pbnRzKGUpfWNvbXB1dEZ1bGxQb2ludHMoZSl7Y29uc3QgdD1ldC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHI9ZXQuUGVyKHQpLm11bChlLzIpLG49eHQuU3ViKHRoaXMudG1wUG9pbnRzWzBdLHIpLGk9eHQuQWRkKHRoaXMudG1wUG9pbnRzWzBdLHIpLGE9eHQuU3ViKHRoaXMudG1wUG9pbnRzWzFdLHIpLGw9eHQuQWRkKHRoaXMudG1wUG9pbnRzWzFdLHIpLHM9eHQuR2V0U2VtaWNpcmNsZVN0cm9rZSh0aGlzLnRtcFBvaW50c1sxXSxhLC0xLDgpLGY9eHQuR2V0U2VtaWNpcmNsZVN0cm9rZSh0aGlzLnRtcFBvaW50c1swXSxpLC0xLDgpLHY9W24sYSwuLi5zLGwsaSwuLi5mXTtyZXR1cm57ZDp2ZSh2LCEwKSxyZWN0Ok50KHYpLGlzRG90OiExLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19Y29tcHV0RG90UG9pbnRzKGUpe2NvbnN0IHQ9eHQuR2V0RG90U3Ryb2tlKHRoaXMudG1wUG9pbnRzWzBdLGUvMiw4KTtyZXR1cm57ZDp2ZSh0LCEwKSxyZWN0Ok50KHQpLGlzRG90OiEwLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IHh0KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOml9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixpKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgbDtjb25zdHtvcDp0LGlzRnVsbFdvcms6cn09ZSxuPShsPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6bC50b1N0cmluZygpO2lmKCFuKXJldHVybjt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrPTMpdGhpcy50bXBQb2ludHMucHVzaChuZXcgeHQodFtzXSx0W3MrMV0sdFtzKzJdKSk7Y29uc3QgaT1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixhPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6aX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9YSx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6YSxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczphJiZwdC5nZXRDZW50ZXJQb3MoYSxpKX0pLGF9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgbDtjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOml9PXIsYT1uLmdldCh0Lm5hbWUpO3JldHVybiBpJiYodC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixpKSx0LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixpKSwobD1hPT1udWxsP3ZvaWQgMDphLm9wdCkhPW51bGwmJmwuc3Ryb2tlQ29sb3ImJihhLm9wdC5zdHJva2VDb2xvcj1pKSksYSYmbi5zZXRJbmZvKHQubmFtZSxhKSxwdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBiZSBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuVGV4dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0fWNvbnN1bWUoKXtyZXR1cm57dHlwZTphdC5Ob25lfX1jb25zdW1lQWxsKCl7cmV0dXJue3R5cGU6YXQuTm9uZX19ZHJhdyhlKXt2YXIgUDtjb25zdHt3b3JrSWQ6dCxsYXllcjpyLGlzRHJhd0xhYmVsOm59PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKHg9PngucmVtb3ZlKCkpLChQPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8UC5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoeD0+eC5yZW1vdmUoKSk7Y29uc3R7Ym94U2l6ZTppLGJveFBvaW50OmEsekluZGV4Omx9PXRoaXMud29ya09wdGlvbnMscz1yLndvcmxkUG9zaXRpb24sZj1yLndvcmxkU2NhbGluZztpZighYXx8IWkpcmV0dXJuO2NvbnN0IHY9bmV3IHRlKHtuYW1lOnQsaWQ6dCxwb3M6W2FbMF0raVswXS8yLGFbMV0raVsxXS8yXSxhbmNob3I6Wy41LC41XSxzaXplOmksekluZGV4Omx9KSxkPXt4OmFbMF0seTphWzFdLHc6aVswXSxoOmlbMV19LHA9bmV3IGFyKHtub3JtYWxpemU6ITAscG9zOlswLDBdLHNpemU6aX0pLHk9biYmYmUuY3JlYXRlTGFiZWxzKHRoaXMud29ya09wdGlvbnMscil8fFtdO3JldHVybiB2LmFwcGVuZCguLi55LHApLHIuYXBwZW5kKHYpLHt4Ok1hdGguZmxvb3IoZC54KmZbMF0rc1swXSkseTpNYXRoLmZsb29yKGQueSpmWzFdK3NbMV0pLHc6TWF0aC5mbG9vcihkLncqZlswXSksaDpNYXRoLmZsb29yKGQuaCpmWzFdKX19Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHMsZjtjb25zdCB0PShzPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCF0KXJldHVybjtjb25zdHtpc0Z1bGxXb3JrOnIscmVwbGFjZUlkOm4saXNEcmF3TGFiZWw6aX09ZTt0aGlzLm9sZFJlY3Q9biYmKChmPXRoaXMudk5vZGVzLmdldChuKSk9PW51bGw/dm9pZCAwOmYucmVjdCl8fHZvaWQgMDtjb25zdCBhPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6dCxsYXllcjphLGlzRHJhd0xhYmVsOml9KTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyh0LHtyZWN0Omwsb3A6W10sb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmwmJnB0LmdldENlbnRlclBvcyhsLGEpfSksbH11cGRhdGFPcHRTZXJ2aWNlKGUpe2lmKCF0aGlzLndvcmtJZClyZXR1cm47Y29uc3QgdD10aGlzLndvcmtJZC50b1N0cmluZygpLHtmb250Q29sb3I6cixmb250QmdDb2xvcjpuLGJvbGQ6aSxpdGFsaWM6YSxsaW5lVGhyb3VnaDpsLHVuZGVybGluZTpzLHpJbmRleDpmfT1lLHY9dGhpcy52Tm9kZXMuZ2V0KHQpO2lmKCF2KXJldHVybjtyJiYodi5vcHQuZm9udENvbG9yPXIpLG4mJih2Lm9wdC5mb250QmdDb2xvcj1uKSxpJiYodi5vcHQuYm9sZD1pKSxhJiYodi5vcHQuaXRhbGljPWEpLGxlKGwpJiYodi5vcHQubGluZVRocm91Z2g9bCksbGUocykmJih2Lm9wdC51bmRlcmxpbmU9cyksbiYmKHYub3B0LmZvbnRCZ0NvbG9yPW4pLG5lKGYpJiYodi5vcHQuekluZGV4PWYpLHRoaXMub2xkUmVjdD12LnJlY3Q7Y29uc3QgZD10aGlzLmRyYXcoe3dvcmtJZDp0LGxheWVyOnRoaXMuZnVsbExheWVyLGlzRHJhd0xhYmVsOiExfSk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8odCx7cmVjdDpkLG9wOltdLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpkJiZwdC5nZXRDZW50ZXJQb3MoZCx0aGlzLmZ1bGxMYXllcil9KSxkfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIGdldEZvbnRXaWR0aChlKXtjb25zdHtjdHg6dCxvcHQ6cix0ZXh0Om59PWUse2JvbGQ6aSxpdGFsaWM6YSxmb250U2l6ZTpsLGZvbnRGYW1pbHk6c309cjtyZXR1cm4gdC5mb250PWAke2l9ICR7YX0gJHtsfXB4ICR7c31gLHQubWVhc3VyZVRleHQobikud2lkdGh9c3RhdGljIGNyZWF0ZUxhYmVscyhlLHQpe2NvbnN0IHI9W10sbj1lLnRleHQuc3BsaXQoIiwiKSxpPW4ubGVuZ3RoO2ZvcihsZXQgYT0wO2E8aTthKyspe2NvbnN0IGw9blthXSx7Zm9udFNpemU6cyxsaW5lSGVpZ2h0OmYsYm9sZDp2LHRleHRBbGlnbjpkLGl0YWxpYzpwLGJveFNpemU6eSxmb250RmFtaWx5OlAsdmVydGljYWxBbGlnbjp4LGZvbnRDb2xvcjptLHVuZGVybGluZTpPLGxpbmVUaHJvdWdoOm99PWUsaD1mfHxzKjEuMixjPXQmJnQucGFyZW50LmNhbnZhcy5nZXRDb250ZXh0KCIyZCIpLGc9YyYmYmUuZ2V0Rm9udFdpZHRoKHt0ZXh0Omwsb3B0OmUsY3R4OmMsd29ybGRTY2FsaW5nOnQud29ybGRTY2FsaW5nfSk7aWYoZyl7Y29uc3QgYj17YW5jaG9yOlswLC41XSx0ZXh0OmwsZm9udFNpemU6cyxsaW5lSGVpZ2h0OmgsZm9udEZhbWlseTpQLGZvbnRXZWlnaHQ6dixmaWxsQ29sb3I6bSx0ZXh0QWxpZ246ZCxmb250U3R5bGU6cCxuYW1lOmEudG9TdHJpbmcoKSxjbGFzc05hbWU6ImxhYmVsIn0sRT1bMCwwXTtpZih4PT09Im1pZGRsZSIpe2NvbnN0IEw9KGktMSkvMjtFWzFdPShhLUwpKmh9ZD09PSJsZWZ0IiYmKEVbMF09eSYmLXlbMF0vMis1fHwwKSxiLnBvcz1FO2NvbnN0IEE9bmV3IEhoKGIpO2lmKHIucHVzaChBKSxPKXtjb25zdCBMPXtub3JtYWxpemU6ITEscG9zOltiLnBvc1swXSxiLnBvc1sxXStzLzJdLGxpbmVXaWR0aDoyKnQud29ybGRTY2FsaW5nWzBdLHBvaW50czpbMCwwLGcsMF0sc3Ryb2tlQ29sb3I6bSxuYW1lOmAke2F9X3VuZGVybGluZWAsY2xhc3NOYW1lOiJ1bmRlcmxpbmUifSxNPW5ldyBlZShMKTtyLnB1c2goTSl9aWYobyl7Y29uc3QgTD17bm9ybWFsaXplOiExLHBvczpiLnBvcyxsaW5lV2lkdGg6Mip0LndvcmxkU2NhbGluZ1swXSxwb2ludHM6WzAsMCxnLDBdLHN0cm9rZUNvbG9yOm0sbmFtZTpgJHthfV9saW5lVGhyb3VnaGAsY2xhc3NOYW1lOiJsaW5lVGhyb3VnaCJ9LE09bmV3IGVlKEwpO3IucHVzaChNKX19fXJldHVybiByfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bix0YXJnZXROb2RlOml9PWUse2ZvbnRCZ0NvbG9yOmEsZm9udENvbG9yOmwsdHJhbnNsYXRlOnMsYm94OmYsYm94U2NhbGU6dixib3hUcmFuc2xhdGU6ZCxib2xkOnAsaXRhbGljOnksbGluZVRocm91Z2g6UCx1bmRlcmxpbmU6eCxmb250U2l6ZTptLHRleHRJbmZvczpPfT1yLG89aSYmWXQoaSl8fG4uZ2V0KHQubmFtZSk7aWYoIW8pcmV0dXJuO2NvbnN0IGg9dC5wYXJlbnQ7aWYoIWgpcmV0dXJuO2NvbnN0IGM9by5vcHQ7aWYobCYmYy5mb250Q29sb3ImJihjLmZvbnRDb2xvcj1sKSxhJiZjLmZvbnRCZ0NvbG9yJiYoYy5mb250QmdDb2xvcj1hKSxwJiYoYy5ib2xkPXApLHkmJihjLml0YWxpYz15KSxsZShQKSYmKGMubGluZVRocm91Z2g9UCksbGUoeCkmJihjLnVuZGVybGluZT14KSxtJiYoYy5mb250U2l6ZT1tKSxmJiZkJiZ2KXtjb25zdCBnPU89PW51bGw/dm9pZCAwOk8uZ2V0KHQubmFtZSk7aWYoZyl7Y29uc3R7Zm9udFNpemU6QSxib3hTaXplOkx9PWc7Yy5ib3hTaXplPUx8fGMuYm94U2l6ZSxjLmZvbnRTaXplPUF8fGMuZm9udFNpemV9Y29uc3QgYj1vLnJlY3QsRT1PZSh4bihiLHYpLGQpO2MuYm94UG9pbnQ9RSYmWyhFLngtaC53b3JsZFBvc2l0aW9uWzBdKS9oLndvcmxkU2NhbGluZ1swXSwoRS55LWgud29ybGRQb3NpdGlvblsxXSkvaC53b3JsZFNjYWxpbmdbMV1dfWVsc2UgaWYocyYmYy5ib3hQb2ludCl7Y29uc3QgZz1bc1swXS9oLndvcmxkU2NhbGluZ1swXSxzWzFdL2gud29ybGRTY2FsaW5nWzFdXTtjLmJveFBvaW50PVtjLmJveFBvaW50WzBdK2dbMF0sYy5ib3hQb2ludFsxXStnWzFdXSxvLmNlbnRlclBvcz1bby5jZW50ZXJQb3NbMF0rZ1swXSxvLmNlbnRlclBvc1sxXStnWzFdXSxvLnJlY3Q9T2Uoby5yZWN0LGcpfXJldHVybiBvJiZuLnNldEluZm8odC5uYW1lLG8pLG89PW51bGw/dm9pZCAwOm8ucmVjdH1zdGF0aWMgZ2V0UmVjdEZyb21MYXllcihlLHQpe2NvbnN0IHI9ZS5nZXRFbGVtZW50c0J5TmFtZSh0KVswXTtpZihyKXtjb25zdCBuPXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihuLngpLHk6TWF0aC5mbG9vcihuLnkpLHc6TWF0aC5mbG9vcihuLndpZHRoKSxoOk1hdGguZmxvb3Iobi5oZWlnaHQpfX19fWZ1bmN0aW9uIEpuKHUpe3N3aXRjaCh1KXtjYXNlIGR0LkFycm93OnJldHVybiB6bjtjYXNlIGR0LlBlbmNpbDpyZXR1cm4gTW47Y2FzZSBkdC5TdHJhaWdodDpyZXR1cm4gWm47Y2FzZSBkdC5FbGxpcHNlOnJldHVybiBHbjtjYXNlIGR0LlBvbHlnb246Y2FzZSBkdC5UcmlhbmdsZTpyZXR1cm4gVm47Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUmhvbWJ1czpyZXR1cm4gS247Y2FzZSBkdC5SZWN0YW5nbGU6cmV0dXJuIEhuO2Nhc2UgZHQuU3BlZWNoQmFsbG9vbjpyZXR1cm4gWW47Y2FzZSBkdC5UZXh0OnJldHVybiBiZTtjYXNlIGR0Lkxhc2VyUGVuOnJldHVybiBFbjtjYXNlIGR0LkVyYXNlcjpyZXR1cm4gSnQ7Y2FzZSBkdC5TZWxlY3RvcjpyZXR1cm4gSXQ7Y2FzZSBkdC5JbWFnZTpyZXR1cm4gWG59fWZ1bmN0aW9uIGhyKHUsZSl7Y29uc3R7dG9vbHNUeXBlOnQsLi4ucn09dTtzd2l0Y2godCl7Y2FzZSBkdC5BcnJvdzpyZXR1cm4gbmV3IHpuKHIpO2Nhc2UgZHQuUGVuY2lsOnJldHVybiBuZXcgTW4ocik7Y2FzZSBkdC5TdHJhaWdodDpyZXR1cm4gbmV3IFpuKHIpO2Nhc2UgZHQuRWxsaXBzZTpyZXR1cm4gbmV3IEduKHIpO2Nhc2UgZHQuUG9seWdvbjpjYXNlIGR0LlRyaWFuZ2xlOnJldHVybiBuZXcgVm4ocik7Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUmhvbWJ1czpyZXR1cm4gbmV3IEtuKHIpO2Nhc2UgZHQuUmVjdGFuZ2xlOnJldHVybiBuZXcgSG4ocik7Y2FzZSBkdC5TcGVlY2hCYWxsb29uOnJldHVybiBuZXcgWW4ocik7Y2FzZSBkdC5UZXh0OnJldHVybiBuZXcgYmUocik7Y2FzZSBkdC5MYXNlclBlbjpyZXR1cm4gbmV3IEVuKHIpO2Nhc2UgZHQuRXJhc2VyOnJldHVybiBuZXcgSnQocixlKTtjYXNlIGR0LlNlbGVjdG9yOnJldHVybiBuZXcgSXQocik7Y2FzZSBkdC5JbWFnZTpyZXR1cm4gbmV3IFhuKHIpO2RlZmF1bHQ6cmV0dXJufX1mdW5jdGlvbiBRbih1KXtjb25zdCBlPVtdLHQ9WyJQQVRIIiwiU1BSSVRFIiwiUE9MWUxJTkUiLCJSRUNUIiwiRUxMSVBTRSJdO2Zvcihjb25zdCByIG9mIHUpe2lmKHIudGFnTmFtZT09PSJHUk9VUCImJnIuY2hpbGRyZW4ubGVuZ3RoKXJldHVybiBRbihyLmNoaWxkcmVuKTtyLnRhZ05hbWUmJnQuaW5jbHVkZXMoci50YWdOYW1lKSYmZS5wdXNoKHIpfXJldHVybiBlfWNsYXNzIGNnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuWkluZGV4QWN0aXZlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm59PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBsLHMsZix2LGQ7Y29uc3R7d29ya0lkOnQsaXNBY3RpdmVaSW5kZXg6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm59PWU7aWYodCE9PUl0LnNlbGVjdG9ySWQpcmV0dXJuO2NvbnN0IGk9KGw9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpsLndvcmtTaGFwZXMuZ2V0KEl0LnNlbGVjdG9ySWQpO2lmKCFpKXJldHVybjtjb25zdCBhPWkub2xkU2VsZWN0UmVjdDtpZihyJiZhJiZ0aGlzLmxvY2FsV29yayl7Y29uc3QgcD1uZXcgU2V0O2lmKHRoaXMubG9jYWxXb3JrLnZOb2Rlcy5jdXJOb2RlTWFwLmZvckVhY2goKHksUCk9Pnt4ZShhLHkucmVjdCkmJnAuYWRkKFApfSkscC5zaXplKXtjb25zdCB5PVtdO3AuZm9yRWFjaChQPT57dmFyIHg7KHg9dGhpcy5sb2NhbFdvcmspPT1udWxsfHx4LmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShQKS5mb3JFYWNoKG09Pnt2YXIgbyxoO2NvbnN0IE89bS5jbG9uZU5vZGUoITApO1VlKG0pJiZPLnNlYWwoKSwoaD0obz10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOm8uZHJhd0xheWVyKSE9bnVsbCYmaC5nZXRFbGVtZW50c0J5TmFtZShQKS5sZW5ndGh8fHkucHVzaChPKX0pfSkseS5sZW5ndGgmJigocz10aGlzLmxvY2FsV29yay5kcmF3TGF5ZXIpPT1udWxsfHxzLmFwcGVuZCguLi55KSl9fWVsc2Uodj0oZj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOmYuZHJhd0xheWVyKT09bnVsbHx8di5jaGlsZHJlbi5maWx0ZXIocD0+e3ZhciB5O3JldHVybiEoKHk9aS5zZWxlY3RJZHMpIT1udWxsJiZ5LmluY2x1ZGVzKHAubmFtZSkpfSkuZm9yRWFjaChwPT5wLnJlbW92ZSgpKTtuJiYoKGQ9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxkLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmEsZHJhd0NhbnZhczp5dC5TZWxlY3RvcixjbGVhckNhbnZhczp5dC5TZWxlY3Rvcixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMubG9jYWxXb3JrLnZpZXdJZH1dLHNwOlt7dHlwZTphdC5TZWxlY3Qsc2VsZWN0SWRzOmkuc2VsZWN0SWRzLG9wdDppLmdldFdvcmtPcHRpb25zKCksc2VsZWN0UmVjdDphLHN0cm9rZUNvbG9yOmkuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOmkuZmlsbENvbG9yLHdpbGxTeW5jU2VydmljZTohMSxpc1N5bmM6ITB9XX0pKX19Y2xhc3MgdWcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5Db3B5Tm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpuLHVuZG9UaWNrZXJJZDppfT1lO2lmKHQ9PT1hdC5GdWxsV29yayYmcj09PU90LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKS5maW5hbGx5KCgpPT57aSYmc2V0VGltZW91dCgoKT0+e3ZhciBhOyhhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS5fcG9zdCh7c3A6W3t0eXBlOmF0Lk5vbmUsdW5kb1RpY2tlcklkOml9XX0pfSwwKX0pLCEwfWFzeW5jIGNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgcjtjb25zdHt3b3JrSWQ6dH09ZTt0JiZhd2FpdCgocj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOnIuY29uc3VtZUZ1bGwoZSx0aGlzLnNjZW5lKSl9fWNsYXNzIGZnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0Q29sb3JOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOml9PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkuZmluYWxseSgoKT0+e2kmJnNldFRpbWVvdXQoKCk9Pnt2YXIgYTsoYT10aGlzLmxvY2FsV29yayk9PW51bGx8fGEuX3Bvc3Qoe3NwOlt7dHlwZTphdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCl9KSwhMH1hc3luYyBjb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIHM7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSx3aWxsU2VyaWFsaXplRGF0YTphLHRleHRVcGRhdGVGb3JXb2tlcjpsfT1lO3Q9PT1JdC5zZWxlY3RvcklkJiZyJiZhd2FpdCgocz10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOnMudXBkYXRlU2VsZWN0b3Ioe3VwZGF0ZVNlbGVjdG9yT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmEsdGV4dFVwZGF0ZUZvcldva2VyOmwsY2FsbGJhY2s6dGhpcy51cGRhdGVTZWxlY3RvckNhbGxiYWNrfSkpfXVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2soZSl7Y29uc3R7cGFyYW06dCxwb3N0RGF0YTpyLG5ld1NlcnZpY2VTdG9yZTpufT1lLHt3aWxsU3luY1NlcnZpY2U6aSxpc1N5bmM6YSx0ZXh0VXBkYXRlRm9yV29rZXI6bH09dCxzPXIucmVuZGVyfHxbXSxmPXIuc3B8fFtdO2lmKGkpZm9yKGNvbnN0W3YsZF1vZiBuLmVudHJpZXMoKSlsJiZkLnRvb2xzVHlwZT09PWR0LlRleHQ/Zi5wdXNoKHsuLi5kLHdvcmtJZDp2LHR5cGU6YXQuVGV4dFVwZGF0ZSxkYXRhVHlwZTpPdC5Mb2NhbCx3aWxsU3luY1NlcnZpY2U6ITB9KTpmLnB1c2goey4uLmQsd29ya0lkOnYsdHlwZTphdC5VcGRhdGVOb2RlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX0saXNTeW5jOmF9KTtyZXR1cm57cmVuZGVyOnMsc3A6Zn19fWNsYXNzIGhnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuWkluZGV4Tm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT1hdC5VcGRhdGVOb2RlJiZyPT09T3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwfWFzeW5jIGNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgbDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmF9PWU7dD09PUl0LnNlbGVjdG9ySWQmJnImJmF3YWl0KChsPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6bC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm59PWUse3dpbGxTeW5jU2VydmljZTppLGlzU3luYzphfT10LGw9ci5yZW5kZXJ8fFtdLHM9ci5zcHx8W107aWYoaSYmcylmb3IoY29uc3RbZix2XW9mIG4uZW50cmllcygpKXMucHVzaCh7Li4udix3b3JrSWQ6Zix0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6YX0pO3JldHVybntyZW5kZXI6bCxzcDpzfX19Y2xhc3MgZGcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5UcmFuc2xhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOml9PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkuZmluYWxseSgoKT0+e2kmJnNldFRpbWVvdXQoKCk9Pnt2YXIgYTsoYT10aGlzLmxvY2FsV29yayk9PW51bGx8fGEuX3Bvc3Qoe3NwOlt7dHlwZTphdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCl9KSwhMH1hc3luYyBjb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGYsdjtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmEsdGV4dFVwZGF0ZUZvcldva2VyOmwsZW1pdEV2ZW50VHlwZTpzfT1lO3Q9PT1JdC5zZWxlY3RvcklkJiZyJiYoci53b3JrU3RhdGU9PT1SdC5Eb25lJiYociE9bnVsbCYmci50cmFuc2xhdGUpJiYoci50cmFuc2xhdGVbMF18fHIudHJhbnNsYXRlWzFdKXx8ci53b3JrU3RhdGUhPT1SdC5Eb25lP2F3YWl0KChmPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6Zi51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSxpc1N5bmM6ITAsdGV4dFVwZGF0ZUZvcldva2VyOmwsZW1pdEV2ZW50VHlwZTpzLHNjZW5lOnRoaXMuc2NlbmUsY2FsbGJhY2s6dGhpcy51cGRhdGVTZWxlY3RvckNhbGxiYWNrfSkpOnIud29ya1N0YXRlPT09UnQuRG9uZSYmKCh2PXRoaXMubG9jYWxXb3JrKT09bnVsbHx8di52Tm9kZXMuZGVsZXRlTGFzdFRhcmdldCgpKSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm4sd29ya1NoYXBlTm9kZTppLHJlczphfT1lLHt3aWxsU3luY1NlcnZpY2U6bCxpc1N5bmM6cyx1cGRhdGVTZWxlY3Rvck9wdDpmLHdpbGxTZXJpYWxpemVEYXRhOnYsdGV4dFVwZGF0ZUZvcldva2VyOmR9PXQscD1mLndvcmtTdGF0ZSx5PXIucmVuZGVyfHxbXSxQPXIuc3B8fFtdO2lmKHA9PT1SdC5TdGFydClyZXR1cm57c3A6W10scmVuZGVyOltdfTtjb25zdCB4PWE9PW51bGw/dm9pZCAwOmEuc2VsZWN0UmVjdDtpZihsKXtpZih2KXtjb25zdCBtPWkuZ2V0Q2hpbGRyZW5Qb2ludHMoKTttJiZQLnB1c2goe3R5cGU6YXQuU2VsZWN0LHNlbGVjdElkczppLnNlbGVjdElkcyxzZWxlY3RSZWN0Ongsd2lsbFN5bmNTZXJ2aWNlOiExLGlzU3luYzpzLHBvaW50czptfSl9Zm9yKGNvbnN0W20sT11vZiBuLmVudHJpZXMoKSlkJiZPLnRvb2xzVHlwZT09PWR0LlRleHQ/KGNvbnNvbGUubG9nKCJUcmFuc2xhdGVOb2RlIixPKSxQLnB1c2goey4uLk8sd29ya0lkOm0sdHlwZTphdC5UZXh0VXBkYXRlLGRhdGFUeXBlOk90LkxvY2FsLHdpbGxTeW5jU2VydmljZTohMH0pKTpQLnB1c2goey4uLk8sd29ya0lkOm0sdHlwZTphdC5VcGRhdGVOb2RlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX0saXNTeW5jOnN9KX1yZXR1cm57cmVuZGVyOnksc3A6UH19fWNsYXNzIGdnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuRGVsZXRlTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT1hdC5SZW1vdmVOb2RlKXtpZihyPT09T3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwO2lmKHI9PT1PdC5TZXJ2aWNlJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpLCEwfX1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7aWYoIXRoaXMubG9jYWxXb3JrKXJldHVybjtjb25zdHtyZW1vdmVJZHM6dCx3aWxsUmVmcmVzaDpyLHdpbGxTeW5jU2VydmljZTpuLHZpZXdJZDppfT1lO2lmKCEodCE9bnVsbCYmdC5sZW5ndGgpKXJldHVybjtsZXQgYTtjb25zdCBsPVtdLHM9W10sZj1bXTtmb3IoY29uc3QgdiBvZiB0KXtpZih2PT09SXQuc2VsZWN0b3JJZCl7Y29uc3QgcD10aGlzLmxvY2FsV29yay53b3JrU2hhcGVzLmdldChJdC5zZWxlY3RvcklkKTtpZighcClyZXR1cm47Y29uc3QgeT1wLnNlbGVjdElkcyYmWy4uLnAuc2VsZWN0SWRzXXx8W107Zm9yKGNvbnN0IHggb2YgeSl7aWYodGhpcy5sb2NhbFdvcmsudk5vZGVzLmdldCh4KSl7Y29uc3QgTz10aGlzLmNvbW1hbmREZWxldGVUZXh0KHgpO08mJmwucHVzaChPKX1hPWJ0KGEsdGhpcy5sb2NhbFdvcmsucmVtb3ZlTm9kZSh4KSksZi5wdXNoKHgpfWNvbnN0IFA9cD09bnVsbD92b2lkIDA6cC51cGRhdGVTZWxlY3RJZHMoW10pO2E9YnQoYSxQLmJnUmVjdCksdGhpcy5sb2NhbFdvcmsuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoSXQuc2VsZWN0b3JJZCksdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5kZWxldGUoSXQuc2VsZWN0b3JJZCksbC5wdXNoKHt0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6W10sd2lsbFN5bmNTZXJ2aWNlOm59KTtjb250aW51ZX1jb25zdCBkPXRoaXMuY29tbWFuZERlbGV0ZVRleHQodik7ZCYmbC5wdXNoKGQpLGE9YnQoYSx0aGlzLmxvY2FsV29yay5yZW1vdmVOb2RlKHYpKSxmLnB1c2godil9biYmbC5wdXNoKHt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOmYsdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkfSksYSYmciYmcy5wdXNoKHtyZWN0OmEsZHJhd0NhbnZhczp5dC5CZyxjbGVhckNhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsdmlld0lkOml9KSwocy5sZW5ndGh8fGwubGVuZ3RoKSYmdGhpcy5sb2NhbFdvcmsuX3Bvc3Qoe3JlbmRlcjpzLHNwOmx9KX1jb25zdW1lRm9yU2VydmljZVdvcmtlcihlKXt0aGlzLnNlcnZpY2VXb3JrJiZ0aGlzLnNlcnZpY2VXb3JrLnJlbW92ZVNlbGVjdFdvcmsoZSl9Y29tbWFuZERlbGV0ZVRleHQoZSl7dmFyIHI7Y29uc3QgdD0ocj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOnIudk5vZGVzLmdldChlKTtpZih0JiZ0LnRvb2xzVHlwZT09PWR0LlRleHQpcmV0dXJue3R5cGU6YXQuVGV4dFVwZGF0ZSx0b29sc1R5cGU6ZHQuVGV4dCx3b3JrSWQ6ZSxkYXRhVHlwZTpPdC5Mb2NhbH19fWNsYXNzIHBnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2NhbGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOml9PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkuZmluYWxseSgoKT0+e2kmJnNldFRpbWVvdXQoKCk9Pnt2YXIgYTsoYT10aGlzLmxvY2FsV29yayk9PW51bGx8fGEuX3Bvc3Qoe3NwOlt7dHlwZTphdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCl9KSwhMH1hc3luYyBjb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGE7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxTeW5jU2VydmljZTpuLHdpbGxTZXJpYWxpemVEYXRhOml9PWU7dD09PUl0LnNlbGVjdG9ySWQmJnImJmF3YWl0KChhPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6YS51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsU3luY1NlcnZpY2U6bix3aWxsU2VyaWFsaXplRGF0YTppLGlzU3luYzohMCxzY2VuZTp0aGlzLnNjZW5lLGNhbGxiYWNrOnRoaXMudXBkYXRlU2VsZWN0b3JDYWxsYmFjay5iaW5kKHRoaXMpfSkpfXVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2soZSl7Y29uc3R7cGFyYW06dCxwb3N0RGF0YTpyLHdvcmtTaGFwZU5vZGU6bixyZXM6aSxuZXdTZXJ2aWNlU3RvcmU6YX09ZSx7dXBkYXRlU2VsZWN0b3JPcHQ6bCx3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpmfT10LHY9bC53b3JrU3RhdGUsZD1yLnJlbmRlcnx8W10scD1yLnNwfHxbXSx5PWk9PW51bGw/dm9pZCAwOmkuc2VsZWN0UmVjdCxQPWk9PW51bGw/dm9pZCAwOmkucmVuZGVyUmVjdDtpZih2PT09UnQuU3RhcnQpcmV0dXJue3NwOltdLHJlbmRlcjpbXX07aWYodGhpcy5sb2NhbFdvcmspe2QucHVzaCh7aXNDbGVhckFsbDohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOnl0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLmxvY2FsV29yay52aWV3SWR9KTtjb25zdCB4PXtyZWN0OlAsaXNGdWxsV29yazohMSxkcmF3Q2FudmFzOnl0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLmxvY2FsV29yay52aWV3SWR9O2QucHVzaCh4KX1pZihzKXt2PT09UnQuRG9pbmcmJnAucHVzaCh7dHlwZTphdC5TZWxlY3Qsc2VsZWN0SWRzOm4uc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eSx3aWxsU3luY1NlcnZpY2U6ITAsaXNTeW5jOiEwLHBvaW50czpuLmdldENoaWxkcmVuUG9pbnRzKCksdGV4dE9wdDpuLnRleHRPcHR9KSxmJiZ2PT09UnQuRG9uZSYmcC5wdXNoKHt0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6bi5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LHdpbGxTeW5jU2VydmljZTohMSxpc1N5bmM6ITAscG9pbnRzOm4uZ2V0Q2hpbGRyZW5Qb2ludHMoKSx0ZXh0T3B0Om4udGV4dE9wdH0pO2Zvcihjb25zdFt4LG1db2YgYS5lbnRyaWVzKCkpbS50b29sc1R5cGU9PT1kdC5UZXh0P3AucHVzaCh7Li4ubSx3b3JrSWQ6eCx0eXBlOmF0LlRleHRVcGRhdGUsZGF0YVR5cGU6T3QuTG9jYWwsd2lsbFN5bmNTZXJ2aWNlOiEwfSk6cC5wdXNoKHsuLi5tLHdvcmtJZDp4LHR5cGU6YXQuVXBkYXRlTm9kZSx1cGRhdGVOb2RlT3B0Ont1c2VBbmltYXRpb246ITF9LGlzU3luYzohMH0pfXJldHVybntyZW5kZXI6ZCxzcDpwfX19Y2xhc3MgbWcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5Sb3RhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOml9PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkuZmluYWxseSgoKT0+e2kmJnNldFRpbWVvdXQoKCk9Pnt2YXIgYTsoYT10aGlzLmxvY2FsV29yayk9PW51bGx8fGEuX3Bvc3Qoe3NwOlt7dHlwZTphdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCl9KSwhMH1hc3luYyBjb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIHM7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSx3aWxsU2VyaWFsaXplRGF0YTphLGVtaXRFdmVudFR5cGU6bH09ZTt0PT09SXQuc2VsZWN0b3JJZCYmciYmYXdhaXQoKHM9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpzLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSx3aWxsU2VyaWFsaXplRGF0YTphLGVtaXRFdmVudFR5cGU6bCxpc1N5bmM6ITAsc2NlbmU6dGhpcy5zY2VuZSxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsd29ya1NoYXBlTm9kZTpuLHJlczppLG5ld1NlcnZpY2VTdG9yZTphfT1lLHt1cGRhdGVTZWxlY3Rvck9wdDpsLHdpbGxTeW5jU2VydmljZTpzLHdpbGxTZXJpYWxpemVEYXRhOmYsaXNTeW5jOnZ9PXQsZD1sLndvcmtTdGF0ZSxwPXIucmVuZGVyfHxbXSx5PXIuc3B8fFtdLFA9aT09bnVsbD92b2lkIDA6aS5zZWxlY3RSZWN0O2lmKHMpe2YmJmQ9PT1SdC5Eb25lJiZ5LnB1c2goe3R5cGU6YXQuU2VsZWN0LHNlbGVjdElkczpuLnNlbGVjdElkcyxzZWxlY3RSZWN0OlAsd2lsbFN5bmNTZXJ2aWNlOiEwLGlzU3luYzp2LHBvaW50czpuLmdldENoaWxkcmVuUG9pbnRzKCl9KTtmb3IoY29uc3RbeCxtXW9mIGEuZW50cmllcygpKXkucHVzaCh7Li4ubSx3b3JrSWQ6eCx0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6dn0pfXJldHVybntyZW5kZXI6cCxzcDp5fX19Y2xhc3MgdmcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5TZXRGb250U3R5bGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6aX09ZTtpZih0PT09YXQuVXBkYXRlTm9kZSYmcj09PU90LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKS5maW5hbGx5KCgpPT57aSYmc2V0VGltZW91dCgoKT0+e3ZhciBhOyhhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS5fcG9zdCh7c3A6W3t0eXBlOmF0Lk5vbmUsdW5kb1RpY2tlcklkOml9XX0pfSwwKX0pLCEwfWFzeW5jIGNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgcztjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmEsdGV4dFVwZGF0ZUZvcldva2VyOmx9PWU7dD09PUl0LnNlbGVjdG9ySWQmJnImJmF3YWl0KChzPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6cy51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSx0ZXh0VXBkYXRlRm9yV29rZXI6bCxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm4sd29ya1NoYXBlTm9kZTppLHJlczphfT1lLHt3aWxsU3luY1NlcnZpY2U6bCxpc1N5bmM6cyx1cGRhdGVTZWxlY3Rvck9wdDpmLHRleHRVcGRhdGVGb3JXb2tlcjp2fT10LGQ9ci5yZW5kZXJ8fFtdLHA9ci5zcHx8W10seT1hPT1udWxsP3ZvaWQgMDphLnNlbGVjdFJlY3Q7aWYobCYmcCl7Zi5mb250U2l6ZSYmcC5wdXNoKHt0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6aS5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LHdpbGxTeW5jU2VydmljZTpsLGlzU3luYzpzLHBvaW50czppLmdldENoaWxkcmVuUG9pbnRzKCl9KTtmb3IoY29uc3RbUCx4XW9mIG4uZW50cmllcygpKXYmJngudG9vbHNUeXBlPT09ZHQuVGV4dD9wLnB1c2goey4uLngsd29ya0lkOlAsdHlwZTphdC5UZXh0VXBkYXRlLGRhdGFUeXBlOk90LkxvY2FsLHdpbGxTeW5jU2VydmljZTohMH0pOnAucHVzaCh7Li4ueCx3b3JrSWQ6UCx0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6c30pfXJldHVybntyZW5kZXI6ZCxzcDpwfX19Y2xhc3MgeWcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5TZXRQb2ludH0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpuLHVuZG9UaWNrZXJJZDppfT1lO2lmKHQ9PT1hdC5VcGRhdGVOb2RlJiZyPT09T3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLmZpbmFsbHkoKCk9PntpJiZzZXRUaW1lb3V0KCgpPT57dmFyIGE7KGE9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxhLl9wb3N0KHtzcDpbe3R5cGU6YXQuTm9uZSx1bmRvVGlja2VySWQ6aX1dfSl9LDApfSksITB9YXN5bmMgY29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBzO2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSx0ZXh0VXBkYXRlRm9yV29rZXI6bH09ZTt0PT09SXQuc2VsZWN0b3JJZCYmciYmYXdhaXQoKHM9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpzLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSxlbWl0RXZlbnRUeXBlOnRoaXMuZW1pdEV2ZW50VHlwZSx3aWxsU2VyaWFsaXplRGF0YTphLGlzU3luYzohMCx0ZXh0VXBkYXRlRm9yV29rZXI6bCxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm4sd29ya1NoYXBlTm9kZTppLHJlczphfT1lLHt3aWxsU3luY1NlcnZpY2U6bCxpc1N5bmM6c309dCxmPXIucmVuZGVyfHxbXSx2PXIuc3B8fFtdLGQ9YT09bnVsbD92b2lkIDA6YS5zZWxlY3RSZWN0O2lmKGwmJnYpe2Zvcihjb25zdFtwLHldb2Ygbi5lbnRyaWVzKCkpdi5wdXNoKHsuLi55LHdvcmtJZDpwLHR5cGU6YXQuVXBkYXRlTm9kZSx1cGRhdGVOb2RlT3B0Ont1c2VBbmltYXRpb246ITF9LGlzU3luYzpzfSk7di5wdXNoKHt0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6aS5zZWxlY3RJZHMsc2VsZWN0UmVjdDpkLHdpbGxTeW5jU2VydmljZTpsLGlzU3luYzpzLHBvaW50czppLmdldENoaWxkcmVuUG9pbnRzKCl9KX1yZXR1cm57cmVuZGVyOmYsc3A6dn19fWNsYXNzIFNnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0TG9ja30pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpuLHVuZG9UaWNrZXJJZDppfT1lO2lmKHQ9PT1hdC5VcGRhdGVOb2RlJiZyPT09T3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLmZpbmFsbHkoKCk9PntpJiZzZXRUaW1lb3V0KCgpPT57dmFyIGE7KGE9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxhLl9wb3N0KHtzcDpbe3R5cGU6YXQuTm9uZSx1bmRvVGlja2VySWQ6aX1dfSl9LDApfSksITB9YXN5bmMgY29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBsO2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YX09ZTt0PT09SXQuc2VsZWN0b3JJZCYmciYmYXdhaXQoKGw9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpsLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSx3aWxsU2VyaWFsaXplRGF0YTphLGNhbGxiYWNrOnRoaXMudXBkYXRlU2VsZWN0b3JDYWxsYmFja30pKX11cGRhdGVTZWxlY3RvckNhbGxiYWNrKGUpe2NvbnN0e3BhcmFtOnQscG9zdERhdGE6cixuZXdTZXJ2aWNlU3RvcmU6bix3b3JrU2hhcGVOb2RlOmkscmVzOmF9PWUse3dpbGxTeW5jU2VydmljZTpsLGlzU3luYzpzLHVwZGF0ZVNlbGVjdG9yT3B0OmZ9PXQsdj1yLnJlbmRlcnx8W10sZD1yLnNwfHxbXSxwPWE9PW51bGw/dm9pZCAwOmEuc2VsZWN0UmVjdDtpZihsJiZkKXtmb3IoY29uc3RbeSxQXW9mIG4uZW50cmllcygpKWQucHVzaCh7Li4uUCx3b3JrSWQ6eSx0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6c30pO2QucHVzaCh7aXNMb2NrZWQ6Zi5pc0xvY2tlZCxzZWxlY3RvckNvbG9yOmkuc2VsZWN0b3JDb2xvcixzY2FsZVR5cGU6aS5zY2FsZVR5cGUsY2FuUm90YXRlOmkuY2FuUm90YXRlLHR5cGU6YXQuU2VsZWN0LHNlbGVjdElkczppLnNlbGVjdElkcyxzZWxlY3RSZWN0OnAsd2lsbFN5bmNTZXJ2aWNlOmwsaXNTeW5jOnN9KX1yZXR1cm57cmVuZGVyOnYsc3A6ZH19fWNsYXNzIHhnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0U2hhcGVPcHR9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6aX09ZTtpZih0PT09YXQuVXBkYXRlTm9kZSYmcj09PU90LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKS5maW5hbGx5KCgpPT57aSYmc2V0VGltZW91dCgoKT0+e3ZhciBhOyhhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS5fcG9zdCh7c3A6W3t0eXBlOmF0Lk5vbmUsdW5kb1RpY2tlcklkOml9XX0pfSwwKX0pLCEwfWFzeW5jIGNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgbDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmF9PWU7dD09PUl0LnNlbGVjdG9ySWQmJnImJmF3YWl0KChsPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6bC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm59PWUse3dpbGxTeW5jU2VydmljZTppLGlzU3luYzphfT10LGw9ci5yZW5kZXJ8fFtdLHM9ci5zcHx8W107aWYoaSYmcylmb3IoY29uc3RbZix2XW9mIG4uZW50cmllcygpKXMucHVzaCh7Li4udix3b3JrSWQ6Zix0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6YX0pO3JldHVybntyZW5kZXI6bCxzcDpzfX19Y2xhc3MgT2d7Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImJ1aWxkZXJzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMuYnVpbGRlcnM9bmV3IE1hcChlLm1hcCh0PT5bdCx0aGlzLmJ1aWxkKHQpXSkpfWJ1aWxkKGUpe3N3aXRjaChlKXtjYXNlIEN0LlRyYW5zbGF0ZU5vZGU6cmV0dXJuIG5ldyBkZztjYXNlIEN0LlpJbmRleE5vZGU6cmV0dXJuIG5ldyBoZztjYXNlIEN0LlpJbmRleEFjdGl2ZTpyZXR1cm4gbmV3IGNnO2Nhc2UgQ3QuQ29weU5vZGU6cmV0dXJuIG5ldyB1ZztjYXNlIEN0LlNldENvbG9yTm9kZTpyZXR1cm4gbmV3IGZnO2Nhc2UgQ3QuRGVsZXRlTm9kZTpyZXR1cm4gbmV3IGdnO2Nhc2UgQ3QuU2NhbGVOb2RlOnJldHVybiBuZXcgcGc7Y2FzZSBDdC5Sb3RhdGVOb2RlOnJldHVybiBuZXcgbWc7Y2FzZSBDdC5TZXRGb250U3R5bGU6cmV0dXJuIG5ldyB2ZztjYXNlIEN0LlNldFBvaW50OnJldHVybiBuZXcgeWc7Y2FzZSBDdC5TZXRMb2NrOnJldHVybiBuZXcgU2c7Y2FzZSBDdC5TZXRTaGFwZU9wdDpyZXR1cm4gbmV3IHhnfX1yZWdpc3RlckZvcldvcmtlcihlLHQscil7cmV0dXJuIHRoaXMuYnVpbGRlcnMuZm9yRWFjaChuPT57biYmbi5yZWdpc3RlckZvcldvcmtlcihlLHQscil9KSx0aGlzfWNvbnN1bWVGb3JXb3JrZXIoZSl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5idWlsZGVycy52YWx1ZXMoKSlpZih0IT1udWxsJiZ0LmNvbnN1bWUoZSkpcmV0dXJuITA7cmV0dXJuITF9fWNvbnN0IGRyPSJjdXJzb3Job3ZlciI7Y2xhc3MgYmd7Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidmlld0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjZW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjZW5lUGF0aCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRhcmdldE5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLHRoaXMudmlld0lkPWUsdGhpcy5zY2VuZT10fWluaXQoZSx0KXt0aGlzLmZ1bGxMYXllcj1lLHRoaXMuZHJhd0xheWVyPXR9Z2V0KGUpe3JldHVybiB0aGlzLmN1ck5vZGVNYXAuZ2V0KGUpfWhhc1JlbmRlck5vZGVzKCl7bGV0IGU9ITE7Zm9yKGNvbnN0IHQgb2YgdGhpcy5jdXJOb2RlTWFwLnZhbHVlcygpKWJuKHQudG9vbHNUeXBlKSYmKGU9ITApO3JldHVybiBlfWhhcyhlKXt0aGlzLmN1ck5vZGVNYXAuaGFzKGUpfXNldEluZm8oZSx0KXtjb25zdCByPXRoaXMuY3VyTm9kZU1hcC5nZXQoZSl8fHtuYW1lOmUscmVjdDp0LnJlY3R9O3QucmVjdCYmKHIucmVjdD1ZdCh0LnJlY3QpKSx0Lm9wJiYoci5vcD1ZdCh0Lm9wKSksdC5jYW5Sb3RhdGUmJihyLmNhblJvdGF0ZT10LmNhblJvdGF0ZSksdC5zY2FsZVR5cGUmJihyLnNjYWxlVHlwZT10LnNjYWxlVHlwZSksdC5vcHQmJihyLm9wdD1ZdCh0Lm9wdCkpLHQudG9vbHNUeXBlJiYoci50b29sc1R5cGU9dC50b29sc1R5cGUpLHQuY2VudGVyUG9zJiYoci5jZW50ZXJQb3M9WXQodC5jZW50ZXJQb3MpKSxyLnJlY3Q/dGhpcy5jdXJOb2RlTWFwLnNldChlLHIpOnRoaXMuY3VyTm9kZU1hcC5kZWxldGUoZSl9ZGVsZXRlKGUpe3RoaXMuY3VyTm9kZU1hcC5kZWxldGUoZSl9Y2xlYXIoKXt0aGlzLmN1ck5vZGVNYXAuY2xlYXIoKSx0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoPTB9Z2V0UmVjdEludGVyc2VjdFJhbmdlKGUsdD0hMCl7bGV0IHI7Y29uc3Qgbj1uZXcgTWFwO2Zvcihjb25zdFtpLGFdb2YgdGhpcy5jdXJOb2RlTWFwLmVudHJpZXMoKSlpZih4ZShlLGEucmVjdCkpe2lmKHQmJmEudG9vbHNUeXBlPT09ZHQuSW1hZ2UmJmEub3B0LmxvY2tlZHx8dCYmYS50b29sc1R5cGU9PT1kdC5UZXh0JiYoYS5vcHQud29ya1N0YXRlPT09UnQuRG9pbmd8fGEub3B0LndvcmtTdGF0ZT09PVJ0LlN0YXJ0KSljb250aW51ZTtyPWJ0KHIsYS5yZWN0KSxuLnNldChpLGEpfXJldHVybntyZWN0UmFuZ2U6cixub2RlUmFuZ2U6bn19Z2V0Tm9kZVJlY3RGb3JtU2hhcGUoZSx0KXtjb25zdCByPUpuKHQudG9vbHNUeXBlKTtsZXQgbj10aGlzLmZ1bGxMYXllciYmKHI9PW51bGw/dm9pZCAwOnIuZ2V0UmVjdEZyb21MYXllcih0aGlzLmZ1bGxMYXllcixlKSk7cmV0dXJuIW4mJnRoaXMuZHJhd0xheWVyJiYobj1yPT1udWxsP3ZvaWQgMDpyLmdldFJlY3RGcm9tTGF5ZXIodGhpcy5kcmF3TGF5ZXIsZSkpLG59dXBkYXRlTm9kZXNSZWN0KCl7dGhpcy5jdXJOb2RlTWFwLmZvckVhY2goKGUsdCk9Pntjb25zdCByPXRoaXMuZ2V0Tm9kZVJlY3RGb3JtU2hhcGUodCxlKTtyPyhlLnJlY3Q9cix0aGlzLmN1ck5vZGVNYXAuc2V0KHQsZSkpOnRoaXMuY3VyTm9kZU1hcC5kZWxldGUodCl9KX1jb21iaW5lSW50ZXJzZWN0UmVjdChlKXtsZXQgdD1lO3JldHVybiB0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaChyPT57eGUodCxyLnJlY3QpJiYodD1idCh0LHIucmVjdCkpfSksdH1zZXRUYXJnZXQoKXtyZXR1cm4gdGhpcy50YXJnZXROb2RlTWFwLnB1c2goWXQodGhpcy5jdXJOb2RlTWFwKSksdGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aC0xfWdldExhc3RUYXJnZXQoKXtyZXR1cm4gdGhpcy50YXJnZXROb2RlTWFwW3RoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGgtMV19ZGVsZXRlTGFzdFRhcmdldCgpe3RoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGg9dGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aC0xfWdldFRhcmdldChlKXtyZXR1cm4gdGhpcy50YXJnZXROb2RlTWFwW2VdfWRlbGV0ZVRhcmdldChlKXt0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoPWV9fWNsYXNzIGtue2NvbnN0cnVjdG9yKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZpZXdJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRwciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FtZXJhT3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjZW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlzU2FmYXJpIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSx0aGlzLnZpZXdJZD1lLHRoaXMub3B0PXQsdGhpcy5kcHI9dC5kcHIsdGhpcy5zY2VuZT10aGlzLmNyZWF0ZVNjZW5lKHQub2Zmc2NyZWVuQ2FudmFzT3B0KSx0aGlzLmZ1bGxMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJmdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZTp0aGlzLnZpZXdJZD09PSJtYWluVmlldyI/NmUzOjNlM30pLHRoaXMudk5vZGVzPW5ldyBiZyhlLHRoaXMuc2NlbmUpfXNldElzU2FmYXJpKGUpe3RoaXMuaXNTYWZhcmk9ZX1vbihlKXtjb25zdHttc2dUeXBlOnQsdG9vbHNUeXBlOnIsb3B0Om4sd29ya0lkOmksd29ya1N0YXRlOmEsZGF0YVR5cGU6bH09ZTtzd2l0Y2godCl7Y2FzZSBhdC5EZXN0cm95OnRoaXMuZGVzdHJveSgpO2JyZWFrO2Nhc2UgYXQuQ2xlYXI6dGhpcy5jbGVhckFsbCgpO2JyZWFrO2Nhc2UgYXQuVXBkYXRlVG9vbHM6aWYociYmbil7Y29uc3Qgcz17dG9vbHNUeXBlOnIsdG9vbHNPcHQ6bn07dGhpcy5sb2NhbFdvcmsuc2V0VG9vbHNPcHQocyl9YnJlYWs7Y2FzZSBhdC5DcmVhdGVXb3JrOmkmJm4mJighdGhpcy5sb2NhbFdvcmsuZ2V0VG1wV29ya1NoYXBlTm9kZSgpJiZyJiZ0aGlzLnNldFRvb2xzT3B0KHt0b29sc1R5cGU6cix0b29sc09wdDpufSksdGhpcy5zZXRXb3JrT3B0KHt3b3JrSWQ6aSx0b29sc09wdDpufSkpO2JyZWFrO2Nhc2UgYXQuRHJhd1dvcms6YT09PVJ0LkRvbmUmJmw9PT1PdC5Mb2NhbD90aGlzLmNvbnN1bWVEcmF3QWxsKGwsZSk6dGhpcy5jb25zdW1lRHJhdyhsLGUpO2JyZWFrfX11cGRhdGVTY2VuZShlKXt0aGlzLnNjZW5lLmF0dHIoey4uLmV9KTtjb25zdHt3aWR0aDp0LGhlaWdodDpyfT1lO3RoaXMuc2NlbmUuY29udGFpbmVyLndpZHRoPXQsdGhpcy5zY2VuZS5jb250YWluZXIuaGVpZ2h0PXIsdGhpcy5zY2VuZS53aWR0aD10LHRoaXMuc2NlbmUuaGVpZ2h0PXIsdGhpcy51cGRhdGVMYXllcih7d2lkdGg6dCxoZWlnaHQ6cn0pfXVwZGF0ZUxheWVyKGUpe2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWU7dGhpcy5mdWxsTGF5ZXImJih0aGlzLmZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdCksdGhpcy5mdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixyKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LHJdKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInBvcyIsW3QqLjUsciouNV0pKSx0aGlzLmRyYXdMYXllciYmKHRoaXMuZHJhd0xheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLmRyYXdMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHIpLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXImJih0aGlzLnNuYXBzaG90RnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsciksdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LHJdKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpfWNyZWF0ZVNjZW5lKGUpe2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWUsbj1uZXcgT2Zmc2NyZWVuQ2FudmFzKHQscik7cmV0dXJuIG5ldyBLaCh7Y29udGFpbmVyOm4sZGlzcGxheVJhdGlvOnRoaXMuZHByLGRlcHRoOiExLGRlc3luY2hyb25pemVkOiEwLC4uLmV9KX1jcmVhdGVMYXllcihlLHQscil7Y29uc3R7d2lkdGg6bixoZWlnaHQ6aX09cixhPWBvZmZzY3JlZW4tJHtlfWAsbD10LmxheWVyKGEscikscz1uZXcgdGUoe2FuY2hvcjpbLjUsLjVdLHBvczpbbiouNSxpKi41XSxzaXplOltuLGldLG5hbWU6InZpZXdwb3J0IixpZDplfSk7cmV0dXJuIGwuYXBwZW5kKHMpLHN9Y2xlYXJBbGwoKXt2YXIgZTt0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnBhcmVudC5jaGlsZHJlbi5mb3JFYWNoKHQ9Pnt0Lm5hbWUhPT0idmlld3BvcnQiJiZ0LnJlbW92ZSgpfSksdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSksdGhpcy5kcmF3TGF5ZXImJih0aGlzLmRyYXdMYXllci5wYXJlbnQuY2hpbGRyZW4uZm9yRWFjaCh0PT57dC5uYW1lIT09InZpZXdwb3J0IiYmdC5yZW1vdmUoKX0pLHRoaXMuZHJhd0xheWVyLnJlbW92ZUFsbENoaWxkcmVuKCkpLHRoaXMubG9jYWxXb3JrLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCksKGU9dGhpcy5zZXJ2aWNlV29yayk9PW51bGx8fGUuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKX1zZXRUb29sc09wdChlKXt0aGlzLmxvY2FsV29yay5zZXRUb29sc09wdChlKX1zZXRXb3JrT3B0KGUpe2NvbnN0e3dvcmtJZDp0LHRvb2xzT3B0OnJ9PWU7dCYmciYmdGhpcy5sb2NhbFdvcmsuc2V0V29ya09wdGlvbnModCxyKX1kZXN0cm95KCl7dmFyIGU7dGhpcy52Tm9kZXMuY2xlYXIoKSx0aGlzLnNjZW5lLnJlbW92ZSgpLHRoaXMuZnVsbExheWVyLnJlbW92ZSgpLHRoaXMubG9jYWxXb3JrLmRlc3Ryb3koKSwoZT10aGlzLnNlcnZpY2VXb3JrKT09bnVsbHx8ZS5kZXN0cm95KCl9fWNsYXNzIHFue2NvbnN0cnVjdG9yKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRocmVhZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFdvcmtTaGFwZU5vZGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wT3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZVN0YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlZmZlY3RXb3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0NvdW50Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMudGhyZWFkPWUudGhyZWFkLHRoaXMudmlld0lkPWUudmlld0lkLHRoaXMudk5vZGVzPWUudk5vZGVzLHRoaXMuZnVsbExheWVyPWUuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyPWUuZHJhd0xheWVyLHRoaXMuX3Bvc3Q9ZS5wb3N0fWRlc3Ryb3koKXt0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCksdGhpcy53b3JrU2hhcGVzLmNsZWFyKCl9Z2V0V29ya1NoYXBlKGUpe3JldHVybiB0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfWdldFRtcFdvcmtTaGFwZU5vZGUoKXtyZXR1cm4gdGhpcy50bXBXb3JrU2hhcGVOb2RlfXNldFRtcFdvcmtJZChlKXtpZihlJiZ0aGlzLnRtcFdvcmtTaGFwZU5vZGUpe3RoaXMudG1wV29ya1NoYXBlTm9kZS5zZXRXb3JrSWQoZSksdGhpcy53b3JrU2hhcGVzLnNldChlLHRoaXMudG1wV29ya1NoYXBlTm9kZSksdGhpcy50bXBPcHQmJnRoaXMuc2V0VG9vbHNPcHQodGhpcy50bXBPcHQpO3JldHVybn19c2V0VG1wV29ya09wdGlvbnMoZSl7dmFyIHQ7KHQ9dGhpcy50bXBXb3JrU2hhcGVOb2RlKT09bnVsbHx8dC5zZXRXb3JrT3B0aW9ucyhlKX1zZXRXb3JrT3B0aW9ucyhlLHQpe3ZhciBuO3RoaXMud29ya1NoYXBlcy5nZXQoZSl8fHRoaXMuc2V0VG1wV29ya0lkKGUpLChuPXRoaXMud29ya1NoYXBlcy5nZXQoZSkpPT1udWxsfHxuLnNldFdvcmtPcHRpb25zKHQpfWNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl7dmFyIG47Y29uc3R7dG9vbHNUeXBlOnQsd29ya0lkOnJ9PWU7cmV0dXJuIHQ9PT1kdC5TZWxlY3RvciYmcj09PWRyP2hyKHsuLi5lLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZnVsbExheWVyfSk6aHIoey4uLmUsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXJ9LChuPXRoaXMudGhyZWFkKT09bnVsbD92b2lkIDA6bi5zZXJ2aWNlV29yayl9c2V0VG9vbHNPcHQoZSl7dmFyIHQscjsoKHQ9dGhpcy50bXBPcHQpPT1udWxsP3ZvaWQgMDp0LnRvb2xzVHlwZSkhPT1lLnRvb2xzVHlwZSYmKHI9dGhpcy50bXBPcHQpIT1udWxsJiZyLnRvb2xzVHlwZSYmdGhpcy5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLHRoaXMudG1wT3B0PWUsdGhpcy50bXBXb3JrU2hhcGVOb2RlPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZShlKX1jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKXt2YXIgdDsodD10aGlzLmdldFdvcmtTaGFwZShlKSk9PW51bGx8fHQuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGUpLHRoaXMud29ya1NoYXBlU3RhdGUuZGVsZXRlKGUpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goZT0+ZS5jbGVhclRtcFBvaW50cygpKSx0aGlzLndvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCl9c2V0RnVsbFdvcmsoZSl7Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOm59PWU7aWYodCYmciYmbil7Y29uc3QgaT10JiZ0aGlzLndvcmtTaGFwZXMuZ2V0KHQpfHx0aGlzLmNyZWF0ZVdvcmtTaGFwZU5vZGUoe3Rvb2xzT3B0OnIsdG9vbHNUeXBlOm4sd29ya0lkOnR9KTtyZXR1cm4gaT8oaS5zZXRXb3JrSWQodCksdGhpcy53b3JrU2hhcGVzLnNldCh0LGkpLGkpOnZvaWQgMH19fXZhciBQZz1adCxUZz1mdW5jdGlvbigpe3JldHVybiBQZy5EYXRlLm5vdygpfSxNZz1UZyxFZz0vXHMvO2Z1bmN0aW9uIEFnKHUpe2Zvcih2YXIgZT11Lmxlbmd0aDtlLS0mJkVnLnRlc3QodS5jaGFyQXQoZSkpOyk7cmV0dXJuIGV9dmFyIENnPUFnLFJnPUNnLElnPS9eXHMrLztmdW5jdGlvbiBMZyh1KXtyZXR1cm4gdSYmdS5zbGljZSgwLFJnKHUpKzEpLnJlcGxhY2UoSWcsIiIpfXZhciBEZz1MZyx3Zz1pZSxOZz1fdCxCZz0iW29iamVjdCBTeW1ib2xdIjtmdW5jdGlvbiBqZyh1KXtyZXR1cm4gdHlwZW9mIHU9PSJzeW1ib2wifHxOZyh1KSYmd2codSk9PUJnfXZhciBXZz1qZyxGZz1EZyxfbj1yZSxVZz1XZyx0aT1OYU4sJGc9L15bLStdMHhbMC05YS1mXSskL2ksemc9L14wYlswMV0rJC9pLEdnPS9eMG9bMC03XSskL2ksSGc9cGFyc2VJbnQ7ZnVuY3Rpb24gS2codSl7aWYodHlwZW9mIHU9PSJudW1iZXIiKXJldHVybiB1O2lmKFVnKHUpKXJldHVybiB0aTtpZihfbih1KSl7dmFyIGU9dHlwZW9mIHUudmFsdWVPZj09ImZ1bmN0aW9uIj91LnZhbHVlT2YoKTp1O3U9X24oZSk/ZSsiIjplfWlmKHR5cGVvZiB1IT0ic3RyaW5nIilyZXR1cm4gdT09PTA/dTordTt1PUZnKHUpO3ZhciB0PXpnLnRlc3QodSk7cmV0dXJuIHR8fEdnLnRlc3QodSk/SGcodS5zbGljZSgyKSx0PzI6OCk6JGcudGVzdCh1KT90aTordX12YXIgVmc9S2csWWc9cmUsZ3I9TWcsZWk9VmcsWGc9IkV4cGVjdGVkIGEgZnVuY3Rpb24iLFpnPU1hdGgubWF4LEpnPU1hdGgubWluO2Z1bmN0aW9uIFFnKHUsZSx0KXt2YXIgcixuLGksYSxsLHMsZj0wLHY9ITEsZD0hMSxwPSEwO2lmKHR5cGVvZiB1IT0iZnVuY3Rpb24iKXRocm93IG5ldyBUeXBlRXJyb3IoWGcpO2U9ZWkoZSl8fDAsWWcodCkmJih2PSEhdC5sZWFkaW5nLGQ9Im1heFdhaXQiaW4gdCxpPWQ/WmcoZWkodC5tYXhXYWl0KXx8MCxlKTppLHA9InRyYWlsaW5nImluIHQ/ISF0LnRyYWlsaW5nOnApO2Z1bmN0aW9uIHkoYil7dmFyIEU9cixBPW47cmV0dXJuIHI9bj12b2lkIDAsZj1iLGE9dS5hcHBseShBLEUpLGF9ZnVuY3Rpb24gUChiKXtyZXR1cm4gZj1iLGw9c2V0VGltZW91dChPLGUpLHY/eShiKTphfWZ1bmN0aW9uIHgoYil7dmFyIEU9Yi1zLEE9Yi1mLEw9ZS1FO3JldHVybiBkP0pnKEwsaS1BKTpMfWZ1bmN0aW9uIG0oYil7dmFyIEU9Yi1zLEE9Yi1mO3JldHVybiBzPT09dm9pZCAwfHxFPj1lfHxFPDB8fGQmJkE+PWl9ZnVuY3Rpb24gTygpe3ZhciBiPWdyKCk7aWYobShiKSlyZXR1cm4gbyhiKTtsPXNldFRpbWVvdXQoTyx4KGIpKX1mdW5jdGlvbiBvKGIpe3JldHVybiBsPXZvaWQgMCxwJiZyP3koYik6KHI9bj12b2lkIDAsYSl9ZnVuY3Rpb24gaCgpe2whPT12b2lkIDAmJmNsZWFyVGltZW91dChsKSxmPTAscj1zPW49bD12b2lkIDB9ZnVuY3Rpb24gYygpe3JldHVybiBsPT09dm9pZCAwP2E6byhncigpKX1mdW5jdGlvbiBnKCl7dmFyIGI9Z3IoKSxFPW0oYik7aWYocj1hcmd1bWVudHMsbj10aGlzLHM9YixFKXtpZihsPT09dm9pZCAwKXJldHVybiBQKHMpO2lmKGQpcmV0dXJuIGNsZWFyVGltZW91dChsKSxsPXNldFRpbWVvdXQoTyxlKSx5KHMpfXJldHVybiBsPT09dm9pZCAwJiYobD1zZXRUaW1lb3V0KE8sZSkpLGF9cmV0dXJuIGcuY2FuY2VsPWgsZy5mbHVzaD1jLGd9dmFyIGtnPVFnLHFnPWtnLF9nPXJlLHQwPSJFeHBlY3RlZCBhIGZ1bmN0aW9uIjtmdW5jdGlvbiBlMCh1LGUsdCl7dmFyIHI9ITAsbj0hMDtpZih0eXBlb2YgdSE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgVHlwZUVycm9yKHQwKTtyZXR1cm4gX2codCkmJihyPSJsZWFkaW5nImluIHQ/ISF0LmxlYWRpbmc6cixuPSJ0cmFpbGluZyJpbiB0PyEhdC50cmFpbGluZzpuKSxxZyh1LGUse2xlYWRpbmc6cixtYXhXYWl0OmUsdHJhaWxpbmc6bn0pfXZhciByMD1lMCxyaT1jZShyMCk7Y2xhc3MgbjAgZXh0ZW5kcyBxbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZVVuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6NjAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVUaW1lcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVmZmVjdFNlbGVjdE5vZGVEYXRhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVyYXNlcldvcmtzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVyYXNlclJlbW92ZU5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVmZmVjdFdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyaSh0PT57dGhpcy52Tm9kZXMuY3VyTm9kZU1hcC5zaXplJiYodGhpcy52Tm9kZXMudXBkYXRlTm9kZXNSZWN0KCksdGhpcy5yZVJlbmRlclNlbGVjdG9yKCkpLHQmJnQoKX0sMTAwLHtsZWFkaW5nOiExfSl9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFcmFzZXJDb21iaW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6cmkoKCk9Pntjb25zdCB0PXRoaXMudXBkYXRlQmF0Y2hFcmFzZXJDb21iaW5lTm9kZSh0aGlzLmJhdGNoRXJhc2VyV29ya3MsdGhpcy5iYXRjaEVyYXNlclJlbW92ZU5vZGVzKTt0aGlzLmJhdGNoRXJhc2VyV29ya3MuY2xlYXIoKSx0aGlzLmJhdGNoRXJhc2VyUmVtb3ZlTm9kZXMuY2xlYXIoKSx0Lmxlbmd0aCYmdGhpcy5fcG9zdCh7cmVuZGVyOnR9KX0sMTAwLHtsZWFkaW5nOiExfSl9KX1jb25zdW1lRHJhdyhlLHQpe2NvbnN0e29wOnIsd29ya0lkOm59PWU7aWYociE9bnVsbCYmci5sZW5ndGgmJm4pe2NvbnN0IGk9dGhpcy53b3JrU2hhcGVzLmdldChuKTtpZighaSlyZXR1cm47Y29uc3QgYT1pLnRvb2xzVHlwZTtpZihhPT09ZHQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IGw9aS5jb25zdW1lKHtkYXRhOmUsaXNGdWxsV29yazohMH0pO3N3aXRjaChhKXtjYXNlIGR0LlNlbGVjdG9yOmwudHlwZT09PWF0LlNlbGVjdCYmKGwuc2VsZWN0SWRzJiZ0LnJ1blJldmVyc2VTZWxlY3RXb3JrKGwuc2VsZWN0SWRzKSx0aGlzLmRyYXdTZWxlY3RvcihsLCEwKSk7YnJlYWs7Y2FzZSBkdC5FcmFzZXI6bCE9bnVsbCYmbC5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIobCk7YnJlYWs7Y2FzZSBkdC5BcnJvdzpjYXNlIGR0LlN0cmFpZ2h0OmNhc2UgZHQuRWxsaXBzZTpjYXNlIGR0LlJlY3RhbmdsZTpjYXNlIGR0LlN0YXI6Y2FzZSBkdC5Qb2x5Z29uOmNhc2UgZHQuU3BlZWNoQmFsbG9vbjpsJiYodGhpcy5kcmF3Q291bnQrKyx0aGlzLmRyYXdQZW5jaWwobCkpO2JyZWFrO2Nhc2UgZHQuUGVuY2lsOnRoaXMuY29tYmluZVRpbWVySWR8fCh0aGlzLmNvbWJpbmVUaW1lcklkPXNldFRpbWVvdXQoKCk9Pnt0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCx0aGlzLmRyYXdQZW5jaWxDb21iaW5lKG4pfSxNYXRoLmZsb29yKGkuZ2V0V29ya09wdGlvbnMoKS5zeW5jVW5pdFRpbWV8fHRoaXMuY29tYmluZVVuaXRUaW1lLzIpKSksbCYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3UGVuY2lsKGwpKTticmVha319fWNvbnN1bWVEcmF3QWxsKGUsdCl7dmFyIGksYSxsO3RoaXMuY29tYmluZVRpbWVySWQmJihjbGVhclRpbWVvdXQodGhpcy5jb21iaW5lVGltZXJJZCksdGhpcy5jb21iaW5lVGltZXJJZD12b2lkIDApO2NvbnN0e3dvcmtJZDpyLHVuZG9UaWNrZXJJZDpufT1lO2lmKHIpe24mJnNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3R5cGU6YXQuTm9uZSx1bmRvVGlja2VySWQ6bn1dfSl9LDApO2NvbnN0IHM9dGhpcy53b3JrU2hhcGVzLmdldChyKTtpZighcylyZXR1cm47Y29uc3QgZj1zLnRvb2xzVHlwZTtpZihmPT09ZHQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IHY9dGhpcy53b3JrU2hhcGVzLmdldChkciksZD0oaT12PT1udWxsP3ZvaWQgMDp2LnNlbGVjdElkcyk9PW51bGw/dm9pZCAwOmlbMF0scD1zLmNvbnN1bWVBbGwoe2RhdGE6ZSxob3ZlcklkOmR9KSx5PXRoaXMud29ya1NoYXBlU3RhdGUuZ2V0KHIpO3N3aXRjaChmKXtjYXNlIGR0LlNlbGVjdG9yOnAuc2VsZWN0SWRzJiZkJiYoKGE9cC5zZWxlY3RJZHMpIT1udWxsJiZhLmluY2x1ZGVzKGQpKSYmdi5jdXJzb3JCbHVyKCkscC5zZWxlY3RJZHMmJnQucnVuUmV2ZXJzZVNlbGVjdFdvcmsocC5zZWxlY3RJZHMpLHRoaXMuZHJhd1NlbGVjdG9yKHAsITEpLChsPXMuc2VsZWN0SWRzKSE9bnVsbCYmbC5sZW5ndGg/cy5jbGVhclRtcFBvaW50cygpOnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUocik7YnJlYWs7Y2FzZSBkdC5FcmFzZXI6cCE9bnVsbCYmcC5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIocCkscy5jbGVhclRtcFBvaW50cygpO2JyZWFrO2Nhc2UgZHQuQXJyb3c6Y2FzZSBkdC5TdHJhaWdodDpjYXNlIGR0LkVsbGlwc2U6Y2FzZSBkdC5SZWN0YW5nbGU6Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUG9seWdvbjpjYXNlIGR0LlNwZWVjaEJhbGxvb246dGhpcy5kcmF3UGVuY2lsRnVsbChwLHMuZ2V0V29ya09wdGlvbnMoKSx5KSx0aGlzLmRyYXdDb3VudD0wLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUocik7YnJlYWs7Y2FzZSBkdC5QZW5jaWw6cCE9bnVsbCYmcC5yZWN0JiYodGhpcy5kcmF3UGVuY2lsRnVsbChwLHMuZ2V0V29ya09wdGlvbnMoKSx5KSx0aGlzLmRyYXdDb3VudD0wKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHIpO2JyZWFrfX19YXN5bmMgY29uc3VtZUZ1bGwoZSx0KXt2YXIgYSxsO2NvbnN0IHI9dGhpcy5zZXRGdWxsV29yayhlKSxuPWUub3BzJiZ6ZShlLm9wcyksaT0oYT1lLndvcmtJZCk9PW51bGw/dm9pZCAwOmEudG9TdHJpbmcoKTtpZihpJiZyKXtjb25zdCBzPShsPXRoaXMudk5vZGVzLmdldChpKSk9PW51bGw/dm9pZCAwOmwucmVjdDtsZXQgZjtyLnRvb2xzVHlwZT09PWR0LkltYWdlJiZ0P2Y9YXdhaXQgci5jb25zdW1lU2VydmljZUFzeW5jKHtzY2VuZTp0LGlzRnVsbFdvcms6ITAscmVwbGFjZUlkOml9KTpmPXIuY29uc3VtZVNlcnZpY2Uoe29wOm4saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6aX0pO2NvbnN0IHY9KGU9PW51bGw/dm9pZCAwOmUudXBkYXRlTm9kZU9wdCkmJnIudXBkYXRhT3B0U2VydmljZShlLnVwZGF0ZU5vZGVPcHQpO2Y9YnQoZix2KTtjb25zdCBkPVtdLHA9W107aWYoZiYmZS53aWxsUmVmcmVzaCYmKHMmJmQucHVzaCh7cmVjdDpmLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxkLnB1c2goe3JlY3Q6ZixkcmF3Q2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSkpLGUud2lsbFN5bmNTZXJ2aWNlJiZwLnB1c2goe29wdDplLm9wdCx0b29sc1R5cGU6ZS50b29sc1R5cGUsdHlwZTphdC5GdWxsV29yayx3b3JrSWQ6ZS53b3JrSWQsb3BzOmUub3BzLHVwZGF0ZU5vZGVPcHQ6ZS51cGRhdGVOb2RlT3B0LHVuZG9UaWNrZXJJZDplLnVuZG9UaWNrZXJJZCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxkLmxlbmd0aHx8cC5sZW5ndGgpe2NvbnN0IHk9e3JlbmRlcjpkLHNwOnB9O3RoaXMuX3Bvc3QoeSl9ZS53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoZS53b3JrSWQpfX1yZW1vdmVXb3JrKGUpe2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO2lmKHIpe2NvbnN0IG49dGhpcy5yZW1vdmVOb2RlKHIpO24mJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6bixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eXQuQmcsZHJhd0NhbnZhczp5dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pfX1yZW1vdmVOb2RlKGUpe3ZhciBuO3RoaXMud29ya1NoYXBlcy5oYXMoZSkmJnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoZSk7bGV0IHQ7Y29uc3Qgcj10aGlzLnZOb2Rlcy5nZXQoZSk7cmV0dXJuIHImJih0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5jb25jYXQoKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5nZXRFbGVtZW50c0J5TmFtZShlKSl8fFtdKS5mb3JFYWNoKGk9PntpLnJlbW92ZSgpfSksdD1idCh0LHIucmVjdCksdGhpcy52Tm9kZXMuZGVsZXRlKGUpKSx0fWFzeW5jIGNoZWNrVGV4dEFjdGl2ZShlKXtjb25zdHtvcDp0LHZpZXdJZDpyLGRhdGFUeXBlOm59PWU7aWYodCE9bnVsbCYmdC5sZW5ndGgpe2xldCBpO2Zvcihjb25zdCBhIG9mIHRoaXMudk5vZGVzLmN1ck5vZGVNYXAudmFsdWVzKCkpe2NvbnN0e3JlY3Q6bCxuYW1lOnMsdG9vbHNUeXBlOmYsb3B0OnZ9PWE7Y29uc29sZS5sb2coImNoZWNrVGV4dEFjdGl2ZSIscyx2KTtjb25zdCBkPXRbMF0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0scD10WzFdKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdO2lmKGY9PT1kdC5UZXh0JiZXaChbZCxwXSxsKSYmdi53b3JrU3RhdGU9PT1SdC5Eb25lKXtpPXM7YnJlYWt9fWkmJihhd2FpdCB0aGlzLmJsdXJTZWxlY3Rvcih7dmlld0lkOnIsbXNnVHlwZTphdC5TZWxlY3QsZGF0YVR5cGU6bixpc1N5bmM6ITB9KSxjb25zb2xlLmxvZygiR2V0VGV4dEFjdGl2ZS0tLTAwMDEiKSxhd2FpdCB0aGlzLl9wb3N0KHtzcDpbe3R5cGU6YXQuR2V0VGV4dEFjdGl2ZSx0b29sc1R5cGU6ZHQuVGV4dCx3b3JrSWQ6aX1dfSkpfX1hc3luYyBjb2xsb2N0RWZmZWN0U2VsZWN0V29yayhlKXtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoSXQuc2VsZWN0b3JJZCkse3dvcmtJZDpyLG1zZ1R5cGU6bn09ZTtpZih0JiZyJiZ0LnNlbGVjdElkcyYmdC5zZWxlY3RJZHMuaW5jbHVkZXMoci50b1N0cmluZygpKSl7bj09PWF0LlJlbW92ZU5vZGU/dC5zZWxlY3RJZHM9dC5zZWxlY3RJZHMuZmlsdGVyKGk9PmkhPT1yLnRvU3RyaW5nKCkpOnRoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEuYWRkKGUpLGF3YWl0IG5ldyBQcm9taXNlKGk9PntzZXRUaW1lb3V0KCgpPT57aSghMCl9LDApfSksYXdhaXQgdGhpcy5ydW5FZmZlY3RTZWxlY3RXb3JrKCEwKS50aGVuKCgpPT57dmFyIGk7KGk9dGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YSk9PW51bGx8fGkuY2xlYXIoKX0pO3JldHVybn1yZXR1cm4gZX1hc3luYyB1cGRhdGVTZWxlY3RvcihlKXt2YXIgTztjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoSXQuc2VsZWN0b3JJZCk7aWYoISgoTz10PT1udWxsP3ZvaWQgMDp0LnNlbGVjdElkcykhPW51bGwmJk8ubGVuZ3RoKSlyZXR1cm47Y29uc3R7Y2FsbGJhY2s6ciwuLi5ufT1lLHt1cGRhdGVTZWxlY3Rvck9wdDppLHdpbGxSZWZyZXNoU2VsZWN0b3I6YSx3aWxsU2VyaWFsaXplRGF0YTpsLGVtaXRFdmVudFR5cGU6cyxzY2VuZTpmfT1uLHY9aS53b3JrU3RhdGUsZD1hd2FpdCh0PT1udWxsP3ZvaWQgMDp0LnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDppLHNlbGVjdElkczp0LnNlbGVjdElkcyx2Tm9kZXM6dGhpcy52Tm9kZXMsd2lsbFNlcmlhbGl6ZURhdGE6bCx3b3JrZXI6dGhpcyxzY2VuZTpmfSkpLHA9ZD09bnVsbD92b2lkIDA6ZC5zZWxlY3RSZWN0LHk9bmV3IE1hcDt0LnNlbGVjdElkcy5mb3JFYWNoKG89Pntjb25zdCBoPXRoaXMudk5vZGVzLmdldChvKTtpZihoKXtjb25zdHt0b29sc1R5cGU6YyxvcDpnLG9wdDpifT1oO3kuc2V0KG8se29wdDpiLHRvb2xzVHlwZTpjLG9wczooZz09bnVsbD92b2lkIDA6Zy5sZW5ndGgpJiZxdChnKXx8dm9pZCAwfSl9fSk7Y29uc3QgUD1bXSx4PVtdO2lmKGEpe1AucHVzaCh7aXNDbGVhckFsbDohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOnl0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2NvbnN0IG89e3JlY3Q6cCxpc0Z1bGxXb3JrOiExLGRyYXdDYW52YXM6eXQuU2VsZWN0b3Isdmlld0lkOnRoaXMudmlld0lkfTtpLnRyYW5zbGF0ZSYmcz09PUN0LlRyYW5zbGF0ZU5vZGUmJnY9PT1SdC5Eb2luZyYmKG8udHJhbnNsYXRlPWkudHJhbnNsYXRlKSxQLnB1c2gobyl9Y29uc3QgbT1yJiZyKHtyZXM6ZCx3b3JrU2hhcGVOb2RlOnQscGFyYW06bixwb3N0RGF0YTp7cmVuZGVyOlAsc3A6eH0sbmV3U2VydmljZVN0b3JlOnl9KXx8e3JlbmRlcjpQLHNwOnh9OyhtLnJlbmRlci5sZW5ndGh8fG0uc3AubGVuZ3RoKSYmdGhpcy5fcG9zdChtKX1hc3luYyBibHVyU2VsZWN0b3IoZSl7dmFyIG47Y29uc3QgdD10aGlzLndvcmtTaGFwZXMuZ2V0KEl0LnNlbGVjdG9ySWQpLHI9dD09bnVsbD92b2lkIDA6dC5ibHVyU2VsZWN0b3IoKTtpZih0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKEl0LnNlbGVjdG9ySWQpLCgobj10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOm4ucGFyZW50KS5jaGlsZHJlbi5mb3JFYWNoKGk9PntpLm5hbWU9PT1JdC5zZWxlY3RvcklkJiZpLnJlbW92ZSgpfSkscil7Y29uc3QgaT1bXTtpLnB1c2goey4uLnIsdW5kb1RpY2tlcklkOmU9PW51bGw/dm9pZCAwOmUudW5kb1RpY2tlcklkLGlzU3luYzplPT1udWxsP3ZvaWQgMDplLmlzU3luY30pLGF3YWl0IHRoaXMuX3Bvc3Qoe3JlbmRlcjoocj09bnVsbD92b2lkIDA6ci5yZWN0KSYmW3tyZWN0OnIucmVjdCxkcmF3Q2FudmFzOnl0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDppfSl9fXJ1bkVmZmVjdFdvcmsoZSl7dGhpcy5iYXRjaEVmZmVjdFdvcmsoZSl9cmVSZW5kZXJTZWxlY3RvcihlPSExKXt2YXIgcjtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoSXQuc2VsZWN0b3JJZCk7aWYodCl7aWYodCYmISgocj10LnNlbGVjdElkcykhPW51bGwmJnIubGVuZ3RoKSlyZXR1cm4gdGhpcy5ibHVyU2VsZWN0b3IoKTtpZih0aGlzLmRyYXdMYXllcil7Y29uc3Qgbj10LnJlUmVuZGVyU2VsZWN0b3IoKTtuJiZ0aGlzLl9wb3N0KHtyZW5kZXI6W3tyZWN0Om4saXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOnl0LlNlbGVjdG9yLGRyYXdDYW52YXM6eXQuU2VsZWN0b3Isdmlld0lkOnRoaXMudmlld0lkfV0sc3A6W3t0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDpuLHdpbGxTeW5jU2VydmljZTplLHZpZXdJZDp0aGlzLnZpZXdJZCxwb2ludHM6dC5nZXRDaGlsZHJlblBvaW50cygpLHRleHRPcHQ6dC50ZXh0T3B0fV19KX19fXVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpe3ZhciBuLGksYSxsLHMsZix2LGQscCx5O2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldChJdC5zZWxlY3RvcklkKSx7c2VsZWN0SWRzOnJ9PWU7aWYoIShyIT1udWxsJiZyLmxlbmd0aCkpe3RoaXMuYmx1clNlbGVjdG9yKGUpO3JldHVybn1pZighdCl7dGhpcy5zZXRGdWxsV29yayhlKSx0aGlzLnVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpO3JldHVybn1pZih0JiYociE9bnVsbCYmci5sZW5ndGgpKXtjb25zdHtiZ1JlY3Q6UCxzZWxlY3RSZWN0Onh9PXQudXBkYXRlU2VsZWN0SWRzKHIpO2NvbnNvbGUubG9nKCJ1cGRhdGVGdWxsU2VsZWN0V29yayIscixQLHgsKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5wYXJlbnQpLmNoaWxkcmVuLm1hcChPPT5PLm5hbWUpKTtjb25zdCBtPXtyZW5kZXI6W10sc3A6W119O1AmJigoaT1tLnJlbmRlcik9PW51bGx8fGkucHVzaCh7cmVjdDpWdChQKSxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eXQuQmcsZHJhd0NhbnZhczp5dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSksKGE9bS5yZW5kZXIpPT1udWxsfHxhLnB1c2goe3JlY3Q6eCxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6eXQuU2VsZWN0b3IsZHJhd0NhbnZhczp5dC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9KSwoZD1tLnNwKT09bnVsbHx8ZC5wdXNoKHsuLi5lLHNlbGVjdG9yQ29sb3I6KGw9ZS5vcHQpPT1udWxsP3ZvaWQgMDpsLnN0cm9rZUNvbG9yLHN0cm9rZUNvbG9yOihzPWUub3B0KT09bnVsbD92b2lkIDA6cy5zdHJva2VDb2xvcixmaWxsQ29sb3I6KGY9ZS5vcHQpPT1udWxsP3ZvaWQgMDpmLmZpbGxDb2xvcix0ZXh0T3B0Oih2PWUub3B0KT09bnVsbD92b2lkIDA6di50ZXh0T3B0LGNhblRleHRFZGl0OnQuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnQuY2FuUm90YXRlLHNjYWxlVHlwZTp0LnNjYWxlVHlwZSx0eXBlOmF0LlNlbGVjdCxzZWxlY3RSZWN0Ongsd2lsbFN5bmNTZXJ2aWNlOiExLHBvaW50czp0LmdldENoaWxkcmVuUG9pbnRzKCl9KSxjb25zb2xlLmxvZygidXBkYXRlRnVsbFNlbGVjdFdvcmstLS0wMSIsbSx0aGlzLnZOb2Rlcy5jdXJOb2RlTWFwLChwPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6cC5jaGlsZHJlbi5tYXAoTz0+Ty5uYW1lKSwoeT10aGlzLmZ1bGxMYXllcik9PW51bGw/dm9pZCAwOnkuY2hpbGRyZW4ubWFwKE89Pk8ubmFtZSkpLHRoaXMuX3Bvc3QobSl9fWRlc3Ryb3koKXtzdXBlci5kZXN0cm95KCksdGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YS5jbGVhcigpLHRoaXMuYmF0Y2hFcmFzZXJXb3Jrcy5jbGVhcigpLHRoaXMuYmF0Y2hFcmFzZXJSZW1vdmVOb2Rlcy5jbGVhcigpfWRyYXdQZW5jaWxDb21iaW5lKGUpe3ZhciByLG47Y29uc3QgdD0ocj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6ci5jb21iaW5lQ29uc3VtZSgpO2lmKHQpe2NvbnN0IGk9e3JlbmRlcjpbXSxkcmF3Q291bnQ6dGhpcy5kcmF3Q291bnR9OyhuPWkucmVuZGVyKT09bnVsbHx8bi5wdXNoKHtyZWN0Oih0PT1udWxsP3ZvaWQgMDp0LnJlY3QpJiZWdCh0LnJlY3QpLGlzQ2xlYXI6ITAsZHJhd0NhbnZhczp5dC5GbG9hdCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMuX3Bvc3QoaSl9fWRyYXdTZWxlY3RvcihlLHQpe3ZhciBuLGk7Y29uc3Qgcj17cmVuZGVyOltdLHNwOltlXX07ZS50eXBlPT09YXQuU2VsZWN0JiYhdCYmKChuPXIucmVuZGVyKT09bnVsbHx8bi5wdXNoKHtyZWN0OmUuc2VsZWN0UmVjdCxkcmF3Q2FudmFzOnl0LlNlbGVjdG9yLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuU2VsZWN0b3IsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9LHtyZWN0OmUucmVjdCYmVnQoZS5yZWN0KSxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSx7cmVjdDplLnJlY3QmJlZ0KGUucmVjdCksZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSkpLHQmJigoaT1yLnJlbmRlcik9PW51bGx8fGkucHVzaCh7cmVjdDplLnJlY3QmJlZ0KGUucmVjdCksZHJhd0NhbnZhczp5dC5GbG9hdCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSx7cmVjdDplLnJlY3QmJlZ0KGUucmVjdCksZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSkpLHRoaXMuX3Bvc3Qocil9YXN5bmMgZHJhd0VyYXNlcihlKXt2YXIgcixuO2NvbnN0IHQ9W107aWYoKHI9ZS5uZXdXb3JrRGF0YXMpIT1udWxsJiZyLnNpemUpe2Zvcihjb25zdCBpIG9mIGUubmV3V29ya0RhdGFzLnZhbHVlcygpKXtjb25zdCBhPWkud29ya0lkLnRvU3RyaW5nKCk7dGhpcy5iYXRjaEVyYXNlcldvcmtzLmFkZChhKSx0LnB1c2goe3R5cGU6YXQuRnVsbFdvcmssd29ya0lkOmEsb3BzOnF0KGkub3ApLG9wdDppLm9wdCx0b29sc1R5cGU6aS50b29sc1R5cGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfX0pfWRlbGV0ZSBlLm5ld1dvcmtEYXRhc30obj1lLnJlbW92ZUlkcyk9PW51bGx8fG4uZm9yRWFjaChpPT57dGhpcy5iYXRjaEVyYXNlclJlbW92ZU5vZGVzLmFkZChpKX0pLHQucHVzaChlKSx0aGlzLl9wb3N0KHtzcDp0fSksdGhpcy5iYXRjaEVyYXNlckNvbWJpbmUoKX1kcmF3UGVuY2lsKGUpe3RoaXMuX3Bvc3Qoe2RyYXdDb3VudDp0aGlzLmRyYXdDb3VudCxzcDooZT09bnVsbD92b2lkIDA6ZS5vcCkmJltlXX0pfWRyYXdQZW5jaWxGdWxsKGUsdCxyKXt2YXIgaTtjb25zdCBuPXtkcmF3Q291bnQ6MS8wLHJlbmRlcjpbe3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjoocj09bnVsbD92b2lkIDA6ci53aWxsQ2xlYXIpfHwodD09bnVsbD92b2lkIDA6dC5pc09wYWNpdHkpLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfV0sc3A6W2VdfTsoaT1uLnJlbmRlcik9PW51bGx8fGkucHVzaCh7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMuX3Bvc3Qobil9dXBkYXRlQmF0Y2hFcmFzZXJDb21iaW5lTm9kZShlLHQpe2NvbnN0IHI9W107bGV0IG47Zm9yKGNvbnN0IGkgb2YgdC5rZXlzKCkpdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoaSkuZm9yRWFjaChhPT57Y29uc3QgbD1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO249YnQobix7eDpsLngtSnQuU2FmZUJvcmRlclBhZGRpbmcseTpsLnktSnQuU2FmZUJvcmRlclBhZGRpbmcsdzpsLndpZHRoK0p0LlNhZmVCb3JkZXJQYWRkaW5nLGg6bC5oZWlnaHQrSnQuU2FmZUJvcmRlclBhZGRpbmd9KSxhLnJlbW92ZSgpfSk7cmV0dXJuIGUuZm9yRWFjaChpPT57Y29uc3QgYT10aGlzLnZOb2Rlcy5nZXQoaSk7aWYoYSlpZih0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShpKVswXSluPWJ0KG4sYS5yZWN0KTtlbHNle2NvbnN0IHM9dGhpcy5zZXRGdWxsV29yayh7Li4uYSx3b3JrSWQ6aX0pLGY9cyYmcy5jb25zdW1lU2VydmljZSh7b3A6YS5vcCxpc0Z1bGxXb3JrOiEwfSk7ZiYmKGEucmVjdD1mLG49YnQobixmKSl9fSksbiYmci5wdXNoKHtyZWN0Om4saXNDbGVhcjohMCxpc0Z1bGxXb3JrOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGRyYXdDYW52YXM6eXQuQmcsdmlld0lkOnRoaXMudmlld0lkfSkscn1hc3luYyBydW5FZmZlY3RTZWxlY3RXb3JrKGUpe3ZhciB0LHIsbixpO2Zvcihjb25zdCBhIG9mIHRoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEudmFsdWVzKCkpe2NvbnN0IGw9dGhpcy5zZXRGdWxsV29yayhhKTtpZihsKXtpZihsLnRvb2xzVHlwZT09PWR0LkltYWdlKWF3YWl0IGwuY29uc3VtZVNlcnZpY2VBc3luYyh7c2NlbmU6KHI9KHQ9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDp0LnBhcmVudCk9PW51bGw/dm9pZCAwOnIucGFyZW50LGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihuPWwuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCl9KTtlbHNle2NvbnN0IHM9YS5vcHMmJnplKGEub3BzKTtsLmNvbnN1bWVTZXJ2aWNlKHtvcDpzLGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihpPWwuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDppLnRvU3RyaW5nKCl9KX1hIT1udWxsJiZhLnVwZGF0ZU5vZGVPcHQmJmwudXBkYXRhT3B0U2VydmljZShhLnVwZGF0ZU5vZGVPcHQpLGEud29ya0lkJiZ0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGEud29ya0lkKX19dGhpcy5yZVJlbmRlclNlbGVjdG9yKGUpfWN1cnNvckhvdmVyKGUpe3ZhciBhO2NvbnN0e29wdDp0LHRvb2xzVHlwZTpyLHBvaW50Om59PWUsaT10aGlzLnNldEZ1bGxXb3JrKHt3b3JrSWQ6ZHIsdG9vbHNUeXBlOnIsb3B0OnR9KTtpZihpJiZuKXtjb25zdCBsPWkuY3Vyc29ySG92ZXIobikscz17cmVuZGVyOltdfTtsJiZsLnR5cGU9PT1hdC5DdXJzb3JIb3ZlciYmKChhPXMucmVuZGVyKT09bnVsbHx8YS5wdXNoKHtyZWN0OmwucmVjdCYmVnQobC5yZWN0KSxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGRyYXdDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSx0aGlzLl9wb3N0KHMpKX19fWNsYXNzIGkwe2NvbnN0cnVjdG9yKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VsZWN0b3JXb3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25JZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgU2V0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJ1bkVmZmVjdElkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm5vQW5pbWF0aW9uUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy52aWV3SWQ9ZS52aWV3SWQsdGhpcy52Tm9kZXM9ZS52Tm9kZXMsdGhpcy5mdWxsTGF5ZXI9ZS5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXI9ZS5kcmF3TGF5ZXIsdGhpcy5wb3N0PWUucG9zdH1kZXN0cm95KCl7dGhpcy53b3JrU2hhcGVzLmNsZWFyKCksdGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5jbGVhcigpfWNvbnN1bWVEcmF3KGUpe3RoaXMuYWN0aXZlV29ya1NoYXBlKGUpLHRoaXMucnVuQW5pbWF0aW9uKCl9Y29uc3VtZUZ1bGwoZSl7dGhpcy5hY3RpdmVXb3JrU2hhcGUoZSksdGhpcy5ydW5BbmltYXRpb24oKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKChlLHQpPT57ZS50b29sc1R5cGU9PT1kdC5MYXNlclBlbj9zZXRUaW1lb3V0KCgpPT57dGhpcy53b3JrU2hhcGVzLmRlbGV0ZSh0KX0sMmUzKTp0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQpfSl9cnVuU2VsZWN0V29yayhlKXt0aGlzLmFjdGl2ZVNlbGVjdG9yU2hhcGUoZSk7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7ciYmdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKHIpLHRoaXMucnVuRWZmZWN0KCl9c2V0Tm9kZUtleShlLHQscil7cmV0dXJuIGUudG9vbHNUeXBlPXQsZS5ub2RlPWhyKHt0b29sc1R5cGU6dCx0b29sc09wdDpyLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZHJhd0xheWVyfSx0aGlzKSxlfXJ1blJldmVyc2VTZWxlY3RXb3JrKGUpe2UuZm9yRWFjaCh0PT57dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocixuKT0+e3ZhciBpO2lmKChpPXIuc2VsZWN0SWRzKSE9bnVsbCYmaS5sZW5ndGgpe2NvbnN0IGE9ci5zZWxlY3RJZHMuaW5kZXhPZih0KTthPi0xJiYoci5zZWxlY3RJZHMuc3BsaWNlKGEsMSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKG4pKX19KX0pLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLnNpemUmJnRoaXMucnVuRWZmZWN0KCl9cmVtb3ZlV29yayhlKXtjb25zdHt3b3JrSWQ6dH09ZSxyPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtpZihyKXtjb25zdCBuPXRoaXMud29ya1NoYXBlcy5nZXQocik7aWYobil7dGhpcy53b3JrU2hhcGVzLmRlbGV0ZShyKSx0aGlzLnJlbW92ZU5vZGUocixlLG49PW51bGw/dm9pZCAwOm4udG90YWxSZWN0LCExKTtyZXR1cm59dGhpcy5yZW1vdmVOb2RlKHIsZSl9fXJlbW92ZVNlbGVjdFdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7ciYmKHRoaXMuYWN0aXZlU2VsZWN0b3JTaGFwZShlKSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQocikpLHRoaXMucnVuRWZmZWN0KCl9cmVtb3ZlTm9kZShlLHQscixuPSEwKXt2YXIgZjtjb25zdCBpPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmNvbmNhdCh0aGlzLmRyYXdMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKSk7ZS5pbmRleE9mKEl0LnNlbGVjdG9ySWQpPi0xJiZ0aGlzLnJlbW92ZVNlbGVjdFdvcmsodCk7Y29uc3QgYT1bXTtsZXQgbD1yO2NvbnN0IHM9KGY9dGhpcy52Tm9kZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6Zi5yZWN0O3MmJihsPWJ0KHMsbCkpLGkuZm9yRWFjaCh2PT57YS5wdXNoKHYpfSksYS5sZW5ndGgmJmEuZm9yRWFjaCh2PT52LnJlbW92ZSgpKSxsJiYodGhpcy5wb3N0KHtyZW5kZXI6W3tyZWN0OlZ0KGwpLGlzQ2xlYXI6ITAsaXNGdWxsV29yazpuLGNsZWFyQ2FudmFzOm4/eXQuQmc6eXQuRmxvYXQsZHJhd0NhbnZhczpuP3l0LkJnOnl0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH1dfSksdGhpcy52Tm9kZXMuZGVsZXRlKGUpKX1hY3RpdmVXb3JrU2hhcGUoZSl7dmFyIHAseSxQLHg7Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOm4sdHlwZTppLHVwZGF0ZU5vZGVPcHQ6YSxvcHM6bCxvcDpzLHVzZUFuaW1hdGlvbjpmfT1lO2lmKCF0KXJldHVybjtjb25zdCB2PXQudG9TdHJpbmcoKTtpZighKChwPXRoaXMud29ya1NoYXBlcykhPW51bGwmJnAuaGFzKHYpKSl7bGV0IG09e3Rvb2xzVHlwZTpuLGFuaW1hdGlvbldvcmtEYXRhOnN8fFtdLGFuaW1hdGlvbkluZGV4OjAsdHlwZTppLHVwZGF0ZU5vZGVPcHQ6YSxvcHM6bCx1c2VBbmltYXRpb246dHlwZW9mIGY8InUiP2Y6dHlwZW9mKGE9PW51bGw/dm9pZCAwOmEudXNlQW5pbWF0aW9uKTwidSI/YT09bnVsbD92b2lkIDA6YS51c2VBbmltYXRpb246ITAsb2xkUmVjdDooeT10aGlzLnZOb2Rlcy5nZXQodikpPT1udWxsP3ZvaWQgMDp5LnJlY3QsaXNEaWZmOiExfTtuJiZyJiYobT10aGlzLnNldE5vZGVLZXkobSxuLHIpKSwoUD10aGlzLndvcmtTaGFwZXMpPT1udWxsfHxQLnNldCh2LG0pfWNvbnN0IGQ9KHg9dGhpcy53b3JrU2hhcGVzKT09bnVsbD92b2lkIDA6eC5nZXQodik7aSYmKGQudHlwZT1pKSxsJiYoZC5hbmltYXRpb25Xb3JrRGF0YT16ZShsKSxkLm9wcz1sKSxhJiYoZC51cGRhdGVOb2RlT3B0PWEpLHMmJihkLmlzRGlmZj10aGlzLmhhc0RpZmZEYXRhKGQuYW5pbWF0aW9uV29ya0RhdGF8fFtdLHMsZC50b29sc1R5cGUpLGQuYW5pbWF0aW9uV29ya0RhdGE9cyksZC5ub2RlJiZkLm5vZGUuZ2V0V29ya0lkKCkhPT12JiZkLm5vZGUuc2V0V29ya0lkKHYpLG4mJnImJihkLnRvb2xzVHlwZSE9PW4mJm4mJnImJnRoaXMuc2V0Tm9kZUtleShkLG4sciksZC5ub2RlJiZkLm5vZGUuc2V0V29ya09wdGlvbnMocikpfWhhc0RpZmZEYXRhKGUsdCxyKXtjb25zdCBuPWUubGVuZ3RoO2lmKHQubGVuZ3RoPG4pcmV0dXJuITA7c3dpdGNoKHIpe2Nhc2UgZHQuUGVuY2lsOntmb3IobGV0IGk9MDtpPG47aSs9MylpZih0W2ldIT09ZVtpXXx8dFtpKzFdIT09ZVtpKzFdKXJldHVybiEwO2JyZWFrfWNhc2UgZHQuTGFzZXJQZW46e2ZvcihsZXQgaT0wO2k8bjtpKz0yKWlmKHRbaV0hPT1lW2ldfHx0W2krMV0hPT1lW2krMV0pcmV0dXJuITA7YnJlYWt9fXJldHVybiExfWFzeW5jIGFuaW1hdGlvbkRyYXcoKXt2YXIgcyxmLHYsZCxwLHksUCx4LG0sTyxvLGgsYyxnLGIsRSxBLEwsTSxJLEQsUixDLEIseixLLFEsXyxGLEc7dGhpcy5hbmltYXRpb25JZD12b2lkIDA7bGV0IGU9ITE7Y29uc3QgdD1uZXcgTWFwLHI9W10sbj1bXSxpPVtdLGE9W107Zm9yKGNvbnN0W1gsWl1vZiB0aGlzLndvcmtTaGFwZXMuZW50cmllcygpKXN3aXRjaChaLnRvb2xzVHlwZSl7Y2FzZSBkdC5JbWFnZTp7Y29uc3QgdHQ9Wi5vbGRSZWN0O3R0JiZpLnB1c2goe3JlY3Q6dHQsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBudD1hd2FpdCgoZj1aLm5vZGUpPT1udWxsP3ZvaWQgMDpmLmNvbnN1bWVTZXJ2aWNlQXN5bmMoe2lzRnVsbFdvcms6ITAsc2NlbmU6KHM9dGhpcy5mdWxsTGF5ZXIucGFyZW50KT09bnVsbD92b2lkIDA6cy5wYXJlbnR9KSk7dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocSxodCk9Pnt2YXIgdXQ7KHV0PXEuc2VsZWN0SWRzKSE9bnVsbCYmdXQuaW5jbHVkZXMoWCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaHQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHR0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxudCksdGhpcy5ydW5FZmZlY3QoKSl9KSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKFgpLHIucHVzaCh7cmVjdDpudCxkcmF3Q2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSk7YnJlYWt9Y2FzZSBkdC5UZXh0OntpZihaLm5vZGUpe2NvbnN0IHR0PVoub2xkUmVjdCxudD0odj1aLm5vZGUpPT1udWxsP3ZvaWQgMDp2LmNvbnN1bWVTZXJ2aWNlKHtvcDpaLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwfSk7dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocSxodCk9Pnt2YXIgdXQ7KHV0PXEuc2VsZWN0SWRzKSE9bnVsbCYmdXQuaW5jbHVkZXMoWCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaHQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHR0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxudCksdGhpcy5ydW5FZmZlY3QoKSl9KSwoZD1aLm5vZGUpPT1udWxsfHxkLmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShYKX1icmVha31jYXNlIGR0LkFycm93OmNhc2UgZHQuU3RyYWlnaHQ6Y2FzZSBkdC5SZWN0YW5nbGU6Y2FzZSBkdC5FbGxpcHNlOmNhc2UgZHQuU3RhcjpjYXNlIGR0LlBvbHlnb246Y2FzZSBkdC5TcGVlY2hCYWxsb29uOntjb25zdCB0dD0hIVoub3BzO2lmKChwPVouYW5pbWF0aW9uV29ya0RhdGEpIT1udWxsJiZwLmxlbmd0aCl7Y29uc3QgbnQ9Wi5vbGRSZWN0LHE9Wi5ub2RlLm9sZFJlY3Q7bnQmJmkucHVzaCh7cmVjdDpudCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHEmJmEucHVzaCh7cmVjdDpxLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSk7Y29uc3QgaHQ9KHk9Wi5ub2RlKT09bnVsbD92b2lkIDA6eS5jb25zdW1lU2VydmljZSh7b3A6Wi5hbmltYXRpb25Xb3JrRGF0YSxpc0Z1bGxXb3JrOnR0fSk7dC5zZXQoWCx7d29ya1N0YXRlOm50P1oub3BzP1J0LkRvbmU6UnQuRG9pbmc6UnQuU3RhcnQsb3A6Wi5hbmltYXRpb25Xb3JrRGF0YS5maWx0ZXIoKHV0LGopPT57aWYoaiUzIT09MilyZXR1cm4hMH0pLnNsaWNlKC0yKX0pLHR0Pyh0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5mb3JFYWNoKCh1dCxqKT0+e3ZhciBXOyhXPXV0LnNlbGVjdElkcykhPW51bGwmJlcuaW5jbHVkZXMoWCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaiksdGhpcy5ub0FuaW1hdGlvblJlY3Q9YnQodGhpcy5ub0FuaW1hdGlvblJlY3QsbnQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHEpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LGh0KSx0aGlzLnJ1bkVmZmVjdCgpKX0pLChQPVoubm9kZSk9PW51bGx8fFAuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKFgpLHIucHVzaCh7cmVjdDpodCxkcmF3Q2FudmFzOnl0LkJnLGlzRnVsbFdvcms6dHQsdmlld0lkOnRoaXMudmlld0lkfSksdC5zZXQoWCx7d29ya1N0YXRlOlJ0LkRvbmUsb3A6Wi5hbmltYXRpb25Xb3JrRGF0YS5maWx0ZXIoKHV0LGopPT57aWYoaiUzIT09MilyZXR1cm4hMH0pLnNsaWNlKC0yKX0pKTpuLnB1c2goe3JlY3Q6aHQsZHJhd0NhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOnR0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLFouYW5pbWF0aW9uV29ya0RhdGEubGVuZ3RoPTB9YnJlYWt9Y2FzZSBkdC5QZW5jaWw6e2lmKCFaLnVzZUFuaW1hdGlvbiYmWi5vcHMpe2xldCB0dD0oeD1aLm5vZGUpPT1udWxsP3ZvaWQgMDp4LmNvbnN1bWVTZXJ2aWNlKHtvcDpaLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDpYfSk7Y29uc3QgbnQ9KG09Wi5ub2RlKT09bnVsbD92b2lkIDA6bS51cGRhdGFPcHRTZXJ2aWNlKFoudXBkYXRlTm9kZU9wdCk7dHQ9YnQodHQsbnQpLGkucHVzaCh7cmVjdDpidChaLm9sZFJlY3QsdHQpLGNsZWFyQ2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHIucHVzaCh7cmVjdDpidChaLm9sZFJlY3QsdHQpLGRyYXdDYW52YXM6eXQuQmcsdmlld0lkOnRoaXMudmlld0lkfSksdGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocSxodCk9Pnt2YXIgdXQ7KHV0PXEuc2VsZWN0SWRzKSE9bnVsbCYmdXQuaW5jbHVkZXMoWCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaHQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHR0KSx0aGlzLnJ1bkVmZmVjdCgpKX0pLChPPVoubm9kZSk9PW51bGx8fE8uY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKFgpfWVsc2UgaWYoWi51c2VBbmltYXRpb24pe2NvbnN0IG50PXRoaXMuY29tcHV0TmV4dEFuaW1hdGlvbkluZGV4KFosMykscT1aLmlzRGlmZj8wOk1hdGgubWF4KDAsKFouYW5pbWF0aW9uSW5kZXh8fDApLTMpLGh0PShaLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkuc2xpY2UocSxudCk7aWYoWi5pc0RlbClaLmlzRGVsJiYoKEw9Wi5ub2RlKT09bnVsbHx8TC5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoWCkpO2Vsc2V7aWYoKFouYW5pbWF0aW9uSW5kZXh8fDApPG50fHxaLmlzRGlmZil7Y29uc3QgdXQ9KGg9Wi5ub2RlKT09bnVsbD92b2lkIDA6aC5jb25zdW1lU2VydmljZSh7b3A6aHQsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6KG89Wi5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6by50b1N0cmluZygpfSk7aWYobi5wdXNoKHtyZWN0OnV0LGRyYXdDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksWi5hbmltYXRpb25JbmRleD1udCxaLmlzRGlmZiYmKFouaXNEaWZmPSExKSxodC5sZW5ndGgpe2NvbnN0IGo9aHQuZmlsdGVyKChXLFYpPT57aWYoViUzIT09MilyZXR1cm4hMH0pLnNsaWNlKC0yKTt0LnNldChYLHt3b3JrU3RhdGU6cT09PTA/UnQuU3RhcnQ6bnQ9PT0oKGM9Wi5hbmltYXRpb25Xb3JrRGF0YSk9PW51bGw/dm9pZCAwOmMubGVuZ3RoKT9SdC5Eb25lOlJ0LkRvaW5nLG9wOmp9KX19ZWxzZSBpZihaLm9wcyl7Y29uc3QgdXQ9KGI9Wi5ub2RlKT09bnVsbD92b2lkIDA6Yi5jb25zdW1lU2VydmljZSh7b3A6Wi5hbmltYXRpb25Xb3JrRGF0YXx8W10saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KGc9Wi5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6Zy50b1N0cmluZygpfSk7Wi5pc0RlbD0hMCxhLnB1c2goe3JlY3Q6dXQsY2xlYXJDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksKEU9Wi5ub2RlKSE9bnVsbCYmRS5nZXRXb3JrT3B0aW9ucygpLmlzT3BhY2l0eSYmaS5wdXNoKHtyZWN0OnV0LGNsZWFyQ2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHIucHVzaCh7cmVjdDp1dCxkcmF3Q2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMudk5vZGVzLnNldEluZm8oWCx7b3A6Wi5hbmltYXRpb25Xb3JrRGF0YSxvcHQ6KEE9Wi5ub2RlKT09bnVsbD92b2lkIDA6QS5nZXRXb3JrT3B0aW9ucygpLHRvb2xzVHlwZTpaLnRvb2xzVHlwZSxyZWN0OnV0fSksdC5zZXQoWCx7d29ya1N0YXRlOlJ0LkRvbmUsb3A6aHQuZmlsdGVyKChqLFcpPT57aWYoVyUzIT09MilyZXR1cm4hMH0pLnNsaWNlKC0yKX0pfWU9ITB9YnJlYWt9YnJlYWt9Y2FzZSBkdC5MYXNlclBlbjp7Y29uc3QgbnQ9dGhpcy5jb21wdXROZXh0QW5pbWF0aW9uSW5kZXgoWiwyKSxxPU1hdGgubWF4KDAsKFouYW5pbWF0aW9uSW5kZXh8fDApLTIpLGh0PShaLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkuc2xpY2UocSxudCk7aWYoWi5pc0RlbCl7aWYoWi5pc0RlbCl7Y29uc3QgdXQ9KEI9Wi5ub2RlKT09bnVsbD92b2lkIDA6Qi5jb25zdW1lU2VydmljZSh7b3A6W10saXNGdWxsV29yazohMX0pO1oudG90YWxSZWN0PWJ0KFoudG90YWxSZWN0LHV0KSxhLnB1c2goe3JlY3Q6Wi50b3RhbFJlY3QsY2xlYXJDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksbi5wdXNoKHtyZWN0OloudG90YWxSZWN0LGRyYXdDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksKHo9Wi5ub2RlKT09bnVsbHx8ei5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoWCl9fWVsc2V7aWYoKFouYW5pbWF0aW9uSW5kZXh8fDApPG50KXtjb25zdCB1dD0oST1aLm5vZGUpPT1udWxsP3ZvaWQgMDpJLmNvbnN1bWVTZXJ2aWNlKHtvcDpodCxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDooTT1aLm5vZGUuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDpNLnRvU3RyaW5nKCl9KTtaLnRvdGFsUmVjdD1idChaLnRvdGFsUmVjdCx1dCksWi50aW1lciYmKGNsZWFyVGltZW91dChaLnRpbWVyKSxaLnRpbWVyPXZvaWQgMCksWi5hbmltYXRpb25JbmRleD1udCxodC5sZW5ndGgmJnQuc2V0KFgse3dvcmtTdGF0ZTpxPT09MD9SdC5TdGFydDpudD09PSgoRD1aLmFuaW1hdGlvbldvcmtEYXRhKT09bnVsbD92b2lkIDA6RC5sZW5ndGgpP1J0LkRvbmU6UnQuRG9pbmcsb3A6aHQuc2xpY2UoLTIpfSl9ZWxzZXtaLnRpbWVyfHwoWi50aW1lcj1zZXRUaW1lb3V0KCgpPT57Wi50aW1lcj12b2lkIDAsWi5pc0RlbD0hMCx0aGlzLnJ1bkFuaW1hdGlvbigpfSwoKFI9Wi5ub2RlKT09bnVsbD92b2lkIDA6Ui5nZXRXb3JrT3B0aW9ucygpKS5kdXJhdGlvbioxZTMrMTAwKSx0LnNldChYLHt3b3JrU3RhdGU6UnQuRG9uZSxvcDpbXX0pKTtjb25zdCB1dD0oQz1aLm5vZGUpPT1udWxsP3ZvaWQgMDpDLmNvbnN1bWVTZXJ2aWNlKHtvcDpbXSxpc0Z1bGxXb3JrOiExfSk7Wi50b3RhbFJlY3Q9YnQoWi50b3RhbFJlY3QsdXQpfWEucHVzaCh7cmVjdDpaLnRvdGFsUmVjdCxjbGVhckNhbnZhczp5dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxuLnB1c2goe3JlY3Q6Wi50b3RhbFJlY3QsZHJhd0NhbnZhczp5dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxlPSEwfWJyZWFrfX1lJiZ0aGlzLnJ1bkFuaW1hdGlvbigpO2NvbnN0IGw9e3JlbmRlcjpbXX07aWYoaS5sZW5ndGgpe2NvbnN0IFg9aS5yZWR1Y2UoKFosdHQpPT4odHQucmVjdCYmdHQuY2xlYXJDYW52YXM9PT15dC5CZyYmKFoucmVjdD1idChaLnJlY3QsdHQucmVjdCkpLFopLHtpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pO1gucmVjdCYmKFgucmVjdD1YLnJlY3QmJlZ0KFgucmVjdCksKEs9bC5yZW5kZXIpPT1udWxsfHxLLnB1c2goWCkpfWlmKGEubGVuZ3RoKXtjb25zdCBYPWEucmVkdWNlKChaLHR0KT0+KHR0LnJlY3QmJnR0LmNsZWFyQ2FudmFzPT09eXQuRmxvYXQmJihaLnJlY3Q9YnQoWi5yZWN0LHR0LnJlY3QpKSxaKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTtYLnJlY3QmJihYLnJlY3Q9WC5yZWN0JiZWdChYLnJlY3QpLChRPWwucmVuZGVyKT09bnVsbHx8US5wdXNoKFgpKX1pZihyLmxlbmd0aCl7Y29uc3QgWD1yLnJlZHVjZSgoWix0dCk9Pih0dC5yZWN0JiZ0dC5kcmF3Q2FudmFzPT09eXQuQmcmJihaLnJlY3Q9YnQoWi5yZWN0LHR0LnJlY3QpKSxaKSx7aXNGdWxsV29yazohMCxkcmF3Q2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pO1gucmVjdCYmKFgucmVjdD1YLnJlY3QmJlZ0KFgucmVjdCksKF89bC5yZW5kZXIpPT1udWxsfHxfLnB1c2goWCkpfWlmKG4ubGVuZ3RoKXtjb25zdCBYPW4ucmVkdWNlKChaLHR0KT0+KHR0LnJlY3QmJnR0LmRyYXdDYW52YXM9PT15dC5GbG9hdCYmKFoucmVjdD1idChaLnJlY3QsdHQucmVjdCkpLFopLHtpc0Z1bGxXb3JrOiExLGRyYXdDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSk7WC5yZWN0JiYoWC5yZWN0PVgucmVjdCYmVnQoWC5yZWN0KSwoRj1sLnJlbmRlcik9PW51bGx8fEYucHVzaChYKSl9dC5zaXplJiYobC5zcD1bXSx0LmZvckVhY2goKFgsWik9Pnt2YXIgdHQ7KHR0PWwuc3ApPT1udWxsfHx0dC5wdXNoKHt0eXBlOmF0LkN1cnNvcix1aWQ6Wi5zcGxpdChKaClbMF0sb3A6WC5vcCx3b3JrU3RhdGU6WC53b3JrU3RhdGUsdmlld0lkOnRoaXMudmlld0lkfSl9KSksKEc9bC5yZW5kZXIpIT1udWxsJiZHLmxlbmd0aCYmdGhpcy5wb3N0KGwpfXJ1bkFuaW1hdGlvbigpe3RoaXMuYW5pbWF0aW9uSWR8fCh0aGlzLmFuaW1hdGlvbklkPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRyYXcuYmluZCh0aGlzKSkpfWNvbXB1dE5leHRBbmltYXRpb25JbmRleChlLHQpe3ZhciBuO2NvbnN0IHI9TWF0aC5mbG9vcigoZS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKGUuYW5pbWF0aW9uSW5kZXgpLmxlbmd0aCozMi90LygoKG49ZS5ub2RlKT09bnVsbD92b2lkIDA6bi5zeW5jVW5pdFRpbWUpfHwxZTMpKSp0O3JldHVybiBNYXRoLm1pbigoZS5hbmltYXRpb25JbmRleHx8MCkrKHJ8fHQpLChlLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkubGVuZ3RoKX1ydW5FZmZlY3QoKXt0aGlzLnJ1bkVmZmVjdElkfHwodGhpcy5ydW5FZmZlY3RJZD1zZXRUaW1lb3V0KHRoaXMuZWZmZWN0UnVuU2VsZWN0b3IuYmluZCh0aGlzKSwwKSl9ZWZmZWN0UnVuU2VsZWN0b3IoKXt0aGlzLnJ1bkVmZmVjdElkPXZvaWQgMDtsZXQgZT10aGlzLm5vQW5pbWF0aW9uUmVjdDt0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5mb3JFYWNoKHQ9Pnt2YXIgaSxhO2NvbnN0IHI9dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZ2V0KHQpLG49ciYmci5zZWxlY3RJZHMmJigoaT1yLm5vZGUpPT1udWxsP3ZvaWQgMDppLnNlbGVjdFNlcnZpY2VOb2RlKHQsciwhMCkpO2U9YnQoZSxuKSwoYT1yPT1udWxsP3ZvaWQgMDpyLnNlbGVjdElkcykhPW51bGwmJmEubGVuZ3RofHx0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5kZWxldGUodCl9KSxlJiZ0aGlzLnBvc3Qoe3JlbmRlcjpbe3JlY3Q6VnQoZSksZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfV19KSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5jbGVhcigpLHRoaXMubm9BbmltYXRpb25SZWN0PXZvaWQgMH1hY3RpdmVTZWxlY3RvclNoYXBlKGUpe3ZhciBmLHYsZDtjb25zdHt3b3JrSWQ6dCxvcHQ6cix0b29sc1R5cGU6bix0eXBlOmksc2VsZWN0SWRzOmF9PWU7aWYoIXQpcmV0dXJuO2NvbnN0IGw9dC50b1N0cmluZygpO2lmKCEoKGY9dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMpIT1udWxsJiZmLmhhcyhsKSkpe2xldCBwPXt0b29sc1R5cGU6bixzZWxlY3RJZHM6YSx0eXBlOmksb3B0OnJ9O24mJnImJihwPXRoaXMuc2V0Tm9kZUtleShwLG4scikpLCh2PXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzKT09bnVsbHx8di5zZXQobCxwKX1jb25zdCBzPShkPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzKT09bnVsbD92b2lkIDA6ZC5nZXQobCk7aSYmKHMudHlwZT1pKSxzLm5vZGUmJnMubm9kZS5nZXRXb3JrSWQoKSE9PWwmJnMubm9kZS5zZXRXb3JrSWQobCkscy5zZWxlY3RJZHM9YXx8W119fWNsYXNzIHMwIGV4dGVuZHMgcW57Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFuaW1hdGlvbldvcmtSZWN0cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZURyYXdUaW1lciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25JZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjbG9zZUFuaW1hdGlvblRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMTAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJ1bkxhc2VyUGVuU3RlcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KX1hc3luYyBydW5GdWxsV29yayhlLHQpe3ZhciBpLGE7Y29uc3Qgcj10aGlzLnNldEZ1bGxXb3JrKGUpLG49ZS5vcHMmJnplKGUub3BzKTtpZihyKXtsZXQgbDtyLnRvb2xzVHlwZT09PWR0LkltYWdlP2w9YXdhaXQgci5jb25zdW1lU2VydmljZUFzeW5jKHtpc0Z1bGxXb3JrOiEwLHNjZW5lOihpPXRoaXMuZnVsbExheWVyLnBhcmVudCk9PW51bGw/dm9pZCAwOmkucGFyZW50fSk6bD1yLmNvbnN1bWVTZXJ2aWNlKHtvcDpuLGlzRnVsbFdvcms6ITAscmVwbGFjZUlkOihhPXIuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDphLnRvU3RyaW5nKCksaXNEcmF3TGFiZWw6dH0pO2NvbnN0IHM9KGU9PW51bGw/dm9pZCAwOmUudXBkYXRlTm9kZU9wdCkmJnIudXBkYXRhT3B0U2VydmljZShlLnVwZGF0ZU5vZGVPcHQpO3JldHVybiBlLndvcmtJZCYmdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlLndvcmtJZCksc3x8bH19cnVuU2VsZWN0V29yayhlKXt2YXIgcjtjb25zdCB0PXRoaXMuc2V0RnVsbFdvcmsoZSk7dCYmKChyPWUuc2VsZWN0SWRzKSE9bnVsbCYmci5sZW5ndGgpJiZlLndvcmtJZCYmdC5zZWxlY3RTZXJ2aWNlTm9kZShlLndvcmtJZC50b1N0cmluZygpLHtzZWxlY3RJZHM6ZS5zZWxlY3RJZHN9LCExKX1jb25zdW1lRHJhdyhlKXt2YXIgbjtjb25zdHtvcDp0LHdvcmtJZDpyfT1lO2lmKHQhPW51bGwmJnQubGVuZ3RoJiZyKXtjb25zdCBpPXRoaXMud29ya1NoYXBlcy5nZXQocik7aWYoIWkpcmV0dXJuO2NvbnN0IGE9aS50b29sc1R5cGUsbD1pLmNvbnN1bWUoe2RhdGE6ZSxpc0Z1bGxXb3JrOiExLGlzQ2xlYXJBbGw6ITAsaXNTdWJXb3JrZXI6ITB9KTtzd2l0Y2goYSl7Y2FzZSBkdC5MYXNlclBlbjpsIT1udWxsJiZsLnJlY3QmJigobj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fG4uc2V0KHIse3JlczpsLGNhbkRlbDohMSxpc1JlY3Q6ITB9KSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpO2JyZWFrO2Nhc2UgZHQuQXJyb3c6Y2FzZSBkdC5TdHJhaWdodDpjYXNlIGR0LkVsbGlwc2U6Y2FzZSBkdC5SZWN0YW5nbGU6Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUG9seWdvbjpjYXNlIGR0LlNwZWVjaEJhbGxvb246bCYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3QXJyb3cobCkpO2JyZWFrO2Nhc2UgZHQuUGVuY2lsOmwmJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd1BlbmNpbChsKSk7YnJlYWt9fX1jb25zdW1lRHJhd0FsbChlKXt2YXIgcixuO2NvbnN0e3dvcmtJZDp0fT1lO2lmKHQpe2NvbnN0IGk9dGhpcy53b3JrU2hhcGVzLmdldCh0KTtpZighaSlyZXR1cm47c3dpdGNoKGkudG9vbHNUeXBlKXtjYXNlIGR0Lkxhc2VyUGVuOmlmKHRoaXMuYW5pbWF0aW9uSWQpe2NvbnN0IGw9aS5jb25zdW1lQWxsKHtkYXRhOmV9KTtsIT1udWxsJiZsLm9wJiZsIT1udWxsJiZsLnJlY3QmJigocj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fHIuc2V0KHQse3JlczpsLGNhbkRlbDohMSxpc1JlY3Q6ITB9KSx0aGlzLnJ1bkxhc2VyUGVuQW5pbWF0aW9uKGwpKTtjb25zdCBzPShuPWkuZ2V0V29ya09wdGlvbnMoKSk9PW51bGw/dm9pZCAwOm4uZHVyYXRpb247dGhpcy5jbG9zZUFuaW1hdGlvblRpbWU9cz9zKjFlMysxMDA6dGhpcy5jbG9zZUFuaW1hdGlvblRpbWUsc2V0VGltZW91dCgoKT0+e3ZhciB2O3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQudG9TdHJpbmcoKSkubWFwKGQ9PmQucmVtb3ZlKCkpLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodCk7Y29uc3QgZj0odj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGw/dm9pZCAwOnYuZ2V0KHQpO2YmJihmLmNhbkRlbD0hMCksc2V0VGltZW91dCgoKT0+e3RoaXMuX3Bvc3Qoe3NwOlt7cmVtb3ZlSWRzOlt0LnRvU3RyaW5nKCldLHR5cGU6YXQuUmVtb3ZlTm9kZX1dfSl9LGkuZ2V0V29ya09wdGlvbnMoKS5zeW5jVW5pdFRpbWV8fHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKX0sdGhpcy5jbG9zZUFuaW1hdGlvblRpbWUpfWJyZWFrO2Nhc2UgZHQuQXJyb3c6Y2FzZSBkdC5TdHJhaWdodDpjYXNlIGR0LkVsbGlwc2U6Y2FzZSBkdC5QZW5jaWw6Y2FzZSBkdC5SZWN0YW5nbGU6Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUG9seWdvbjpjYXNlIGR0LlNwZWVjaEJhbGxvb246dGhpcy5kcmF3Q291bnQ9MCx0aGlzLmZ1bGxMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodCk7YnJlYWt9fX11cGRhdGVMYWJlbHMoZSx0KXtlLmNoaWxkcmVuLmZvckVhY2gocj0+e2lmKHIudGFnTmFtZT09PSJMQUJFTCIpe2NvbnN0IG49ci5uYW1lLHt3aWR0aDppfT1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFthXT1lLndvcmxkU2NhbGluZyx7dW5kZXJsaW5lOmwsbGluZVRocm91Z2g6c309dC5vcHQ7bCYmZS5nZXRFbGVtZW50c0J5TmFtZShgJHtufV91bmRlcmxpbmVgKVswXS5hdHRyKHtwb2ludHM6WzAsMCxpL2EsMF19KSxzJiZlLmdldEVsZW1lbnRzQnlOYW1lKGAke259X2xpbmVUaHJvdWdoYClbMF0uYXR0cih7cG9pbnRzOlswLDAsaS9hLDBdfSl9fSl9cnVuTGFzZXJQZW5BbmltYXRpb24oZSl7dGhpcy5hbmltYXRpb25JZHx8KHRoaXMuYW5pbWF0aW9uSWQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57dmFyIG4saTtpZih0aGlzLmFuaW1hdGlvbklkPXZvaWQgMCx0aGlzLnJ1bkxhc2VyUGVuU3RlcCsrLHRoaXMucnVuTGFzZXJQZW5TdGVwPjEpe3RoaXMucnVuTGFzZXJQZW5TdGVwPTAsdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbihlKTtyZXR1cm59bGV0IHQ7Y29uc3Qgcj1bXTsobj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fG4uZm9yRWFjaCgoYSxsLHMpPT57YS5pc1JlY3QmJih0PWJ0KHQsYS5yZXMucmVjdCkpLGEucmVzLndvcmtJZCYmci5wdXNoKGEucmVzKSx0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShsLnRvU3RyaW5nKCkpLmxlbmd0aD9hLmlzUmVjdD0hMDphLmlzUmVjdD0hMSxhLmNhbkRlbCYmcy5kZWxldGUobCl9KSwoaT10aGlzLmFuaW1hdGlvbldvcmtSZWN0cykhPW51bGwmJmkuc2l6ZSYmdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpLHQmJihlJiZyLnB1c2goZSksdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDpWdCh0KSxkcmF3Q2FudmFzOnl0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpyfSkpfSkpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHJlbmRlcjpbe3JlY3Q6ZT09bnVsbD92b2lkIDA6ZS5yZWN0LGRyYXdDYW52YXM6eXQuRmxvYXQsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd0Fycm93KGUpe3RoaXMuX3Bvc3Qoe2RyYXdDb3VudDp0aGlzLmRyYXdDb3VudCxyZW5kZXI6W3tyZWN0OihlPT1udWxsP3ZvaWQgMDplLnJlY3QpJiZWdChlLnJlY3QpLGRyYXdDYW52YXM6eXQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSl9fXZhciBQZTsoZnVuY3Rpb24odSl7dS5GdWxsPSJmdWxsIix1LlN1Yj0ic3ViIn0pKFBlfHwoUGU9e30pKTtjbGFzcyBvMHtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfc2VsZiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0eXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtUaHJlYWRNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksdGhpcy5fc2VsZj1lLHRoaXMudHlwZT10LHRoaXMucmVnaXN0ZXIoKX1pbml0KGUpe2NvbnN0e3ZpZXdJZDp0LGRwcjpyLG9mZnNjcmVlbkNhbnZhc09wdDpuLGxheWVyT3B0OmksaXNTYWZhcmk6YX09ZTtpZighcnx8IW58fCFpKXJldHVybjtsZXQgbDt0aGlzLnR5cGU9PT1QZS5GdWxsJiYobD1uZXcgYTAodCx7ZHByOnIsb2Zmc2NyZWVuQ2FudmFzT3B0Om4sbGF5ZXJPcHQ6aX0sdGhpcy5wb3N0LmJpbmQodGhpcykpKSx0aGlzLnR5cGU9PT1QZS5TdWImJihsPW5ldyBsMCh0LHtkcHI6cixvZmZzY3JlZW5DYW52YXNPcHQ6bixsYXllck9wdDppfSx0aGlzLnBvc3QuYmluZCh0aGlzKSkpLGwmJmEmJmwuc2V0SXNTYWZhcmkoYSksbCYmZS5jYW1lcmFPcHQmJmwuc2V0Q2FtZXJhT3B0KGUuY2FtZXJhT3B0KSxsJiZ0aGlzLndvcmtUaHJlYWRNYXAuc2V0KHQsbCl9cmVnaXN0ZXIoKXtvbm1lc3NhZ2U9ZT0+e2NvbnN0IHQ9ZS5kYXRhO2lmKHQpZm9yKGNvbnN0IHIgb2YgdC52YWx1ZXMoKSl7Y29uc3R7bXNnVHlwZTpuLHZpZXdJZDppLHRhc2tzcXVldWU6YSxtYWluVGFza3NxdWV1ZUNvdW50Omx9PXI7aWYobj09PWF0LkluaXQpe3RoaXMuaW5pdChyKTtjb250aW51ZX1pZihuPT09YXQuVGFza3NRdWV1ZSYmKGEhPW51bGwmJmEuc2l6ZSkmJmwpe3RoaXMud29ya1RocmVhZE1hcC5mb3JFYWNoKChmLHYpPT57Y29uc3QgZD1hLmdldCh2KTtkJiZmLm9uKGQpLHRoaXMucG9zdCh7d29ya2VyVGFza3NxdWV1ZUNvdW50Omx9KX0pO2NvbnRpbnVlfWlmKGk9PT1raCl7dGhpcy53b3JrVGhyZWFkTWFwLmZvckVhY2goZj0+e2Yub24ociksbj09PWF0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUoaSl9KTtjb250aW51ZX1jb25zdCBzPXRoaXMud29ya1RocmVhZE1hcC5nZXQoaSk7cyYmKHMub24ociksbj09PWF0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUoaSkpfX19cG9zdChlLHQpe3Q/dGhpcy5fc2VsZi5wb3N0TWVzc2FnZShlLHQpOnRoaXMuX3NlbGYucG9zdE1lc3NhZ2UoZSl9fWNsYXNzIGEwIGV4dGVuZHMga257Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKGUsdCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJtZXRob2RCdWlsZGVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuX3Bvc3Q9cix0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJkcmF3TGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZToxZTN9KTtjb25zdCBuPXt0aHJlYWQ6dGhpcyx2aWV3SWQ6dGhpcy52aWV3SWQsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXIscG9zdDp0aGlzLnBvc3QuYmluZCh0aGlzKX07dGhpcy5sb2NhbFdvcms9bmV3IG4wKG4pLHRoaXMuc2VydmljZVdvcms9bmV3IGkwKG4pLHRoaXMubWV0aG9kQnVpbGRlcj1uZXcgT2coW0N0LkNvcHlOb2RlLEN0LlNldENvbG9yTm9kZSxDdC5EZWxldGVOb2RlLEN0LlJvdGF0ZU5vZGUsQ3QuU2NhbGVOb2RlLEN0LlRyYW5zbGF0ZU5vZGUsQ3QuWkluZGV4QWN0aXZlLEN0LlpJbmRleE5vZGUsQ3QuU2V0Rm9udFN0eWxlLEN0LlNldFBvaW50LEN0LlNldExvY2ssQ3QuU2V0U2hhcGVPcHRdKS5yZWdpc3RlckZvcldvcmtlcih0aGlzLmxvY2FsV29yayx0aGlzLnNlcnZpY2VXb3JrLHRoaXMuc2NlbmUpLHRoaXMudk5vZGVzLmluaXQodGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpfWFzeW5jIHBvc3QoZSx0KXt2YXIgbCxzLGY7Y29uc3Qgcj1lLnJlbmRlcixuPVtdO2xldCBpPXQ7aWYociE9bnVsbCYmci5sZW5ndGgpe2Zvcihjb25zdCB2IG9mIHIpe2lmKHYuaXNDbGVhckFsbCYmKHYucmVjdD10aGlzLmdldFNjZW5lUmVjdCgpLHYuaXNDbGVhcj0hMCxkZWxldGUgdi5pc0NsZWFyQWxsKSx2LmlzRHJhd0FsbCYmKHYucmVjdD10aGlzLmdldFNjZW5lUmVjdCgpLGRlbGV0ZSB2LmlzRHJhd0FsbCksdi5kcmF3Q2FudmFzKXtjb25zdCBkPXYuaXNGdWxsV29yaz90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcjsoZD09bnVsbD92b2lkIDA6ZC5wYXJlbnQpLnJlbmRlcigpfWlmKHYucmVjdCl7di5jbGVhckNhbnZhcz09PXYuZHJhd0NhbnZhcyYmdi5kcmF3Q2FudmFzPT09eXQuQmcmJih2LnJlY3Q9dGhpcy5jaGVja1JpZ2h0UmVjdEJvdW5kaW5nQm94KHYucmVjdCkpO2NvbnN0IGQ9di5yZWN0O2lmKHRoaXMuaXNTYWZhcmkmJih2LnJlY3Q9dGhpcy5zYWZhcmlGaXhSZWN0KFl0KHYucmVjdCkpKSwhdi5yZWN0KWNvbnRpbnVlO2lmKHYuZHJhd0NhbnZhcz09PXl0LlNlbGVjdG9yKXtjb25zdCBwPShsPWUuc3ApPT1udWxsP3ZvaWQgMDpsLmZpbmQoeT0+eS50eXBlPT09YXQuU2VsZWN0KTtwJiYocC5yZWN0PXYucmVjdCksdi5vZmZzZXQ9e3g6di5yZWN0LngtZC54LHk6di5yZWN0LnktZC55fX1pZih2LmRyYXdDYW52YXMpe2NvbnN0IHA9YXdhaXQgdGhpcy5nZXRSZWN0SW1hZ2VCaXRtYXAodi5yZWN0LCEhdi5pc0Z1bGxXb3JrKTt2LmltYWdlQml0bWFwPXAsaXx8KGk9W10pLGkucHVzaChwKX1uLnB1c2godil9fWUucmVuZGVyPW59Y29uc3QgYT0ocz1lLnNwKT09bnVsbD92b2lkIDA6cy5maWx0ZXIodj0+di50eXBlIT09YXQuTm9uZXx8T2JqZWN0LmtleXModikuZmlsdGVyKGQ9PmQ9PT0idHlwZSIpLmxlbmd0aCk7aWYoYSE9bnVsbCYmYS5sZW5ndGgmJihlLnNwPWEubWFwKHY9Pih7Li4udix2aWV3SWQ6dGhpcy52aWV3SWR9KSkpLChlLmRyYXdDb3VudHx8ZS53b3JrZXJUYXNrc3F1ZXVlQ291bnR8fChmPWUuc3ApIT1udWxsJiZmLmxlbmd0aHx8biE9bnVsbCYmbi5sZW5ndGgpJiYodGhpcy5fcG9zdChlLGkpLGkhPW51bGwmJmkubGVuZ3RoKSlmb3IoY29uc3QgdiBvZiBpKXYgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCYmdi5jbG9zZSgpfW9uKGUpe2lmKHRoaXMubWV0aG9kQnVpbGRlci5jb25zdW1lRm9yV29ya2VyKGUpKXJldHVybjtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cix3b3JrSWQ6bn09ZTtzd2l0Y2godCl7Y2FzZSBhdC5VcGRhdGVDYW1lcmE6dGhpcy51cGRhdGVDYW1lcmEoZSk7YnJlYWs7Y2FzZSBhdC5TZWxlY3Q6cj09PU90LlNlcnZpY2UmJihuPT09SXQuc2VsZWN0b3JJZD90aGlzLmxvY2FsV29yay51cGRhdGVGdWxsU2VsZWN0V29yayhlKTp0aGlzLnNlcnZpY2VXb3JrLnJ1blNlbGVjdFdvcmsoZSkpO2JyZWFrO2Nhc2UgYXQuVXBkYXRlTm9kZTpjYXNlIGF0LkZ1bGxXb3JrOnRoaXMuY29uc3VtZUZ1bGwocixlKTticmVhaztjYXNlIGF0LlJlbW92ZU5vZGU6dGhpcy5yZW1vdmVOb2RlKGUpO2JyZWFrO2Nhc2UgYXQuR2V0VGV4dEFjdGl2ZTp0aGlzLmNoZWNrVGV4dEFjdGl2ZShlKTticmVhaztjYXNlIGF0LkN1cnNvckhvdmVyOnRoaXMuY3Vyc29ySG92ZXIoZSl9c3VwZXIub24oZSl9YXN5bmMgcmVtb3ZlTm9kZShlKXtjb25zdHtkYXRhVHlwZTp0LHdvcmtJZDpyfT1lO2lmKHI9PT1JdC5zZWxlY3RvcklkKXt0aGlzLmxvY2FsV29yay5ibHVyU2VsZWN0b3IoZSk7cmV0dXJufXQ9PT1PdC5Mb2NhbCYmKHRoaXMubG9jYWxXb3JrLnJlbW92ZVdvcmsoZSksdGhpcy5sb2NhbFdvcmsuY29sbG9jdEVmZmVjdFNlbGVjdFdvcmsoZSkpLHQ9PT1PdC5TZXJ2aWNlJiYodGhpcy5zZXJ2aWNlV29yay5yZW1vdmVXb3JrKGUpLHRoaXMubG9jYWxXb3JrLmNvbGxvY3RFZmZlY3RTZWxlY3RXb3JrKGUpKX1jaGVja1RleHRBY3RpdmUoZSl7Y29uc3R7ZGF0YVR5cGU6dH09ZTt0PT09T3QuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNoZWNrVGV4dEFjdGl2ZShlKX1jbGVhckFsbCgpe3RoaXMudk5vZGVzLmNsZWFyKCksc3VwZXIuY2xlYXJBbGwoKSx0aGlzLnBvc3Qoe3JlbmRlcjpbe2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9LHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnl0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfV0sc3A6W3t0eXBlOmF0LkNsZWFyfV19KX1zZXRDYW1lcmFPcHQoZSl7dGhpcy5jYW1lcmFPcHQ9ZTtjb25zdHtzY2FsZTp0LGNlbnRlclg6cixjZW50ZXJZOm4sd2lkdGg6aSxoZWlnaHQ6YX09ZTsoaSE9PXRoaXMuc2NlbmUud2lkdGh8fGEhPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOmksaGVpZ2h0OmF9KSx0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFt0LHRdKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1yLC1uXSkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3QsdF0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLXIsLW5dKSl9Z2V0T2Zmc2NyZWVuKGUpe3JldHVybihlP3RoaXMuZnVsbExheWVyLnBhcmVudDp0aGlzLmRyYXdMYXllci5wYXJlbnQpLmNhbnZhc31hc3luYyBjb25zdW1lRnVsbChlLHQpe2NvbnN0IHI9YXdhaXQgdGhpcy5sb2NhbFdvcmsuY29sbG9jdEVmZmVjdFNlbGVjdFdvcmsodCk7ciYmZT09PU90LkxvY2FsJiZhd2FpdCB0aGlzLmxvY2FsV29yay5jb25zdW1lRnVsbChyLHRoaXMuc2NlbmUpLHImJmU9PT1PdC5TZXJ2aWNlJiZ0aGlzLnNlcnZpY2VXb3JrLmNvbnN1bWVGdWxsKHIpfWNvbnN1bWVEcmF3KGUsdCl7ZT09PU90LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhdyh0LHRoaXMuc2VydmljZVdvcmspLGU9PT1PdC5TZXJ2aWNlJiZ0aGlzLnNlcnZpY2VXb3JrLmNvbnN1bWVEcmF3KHQpfWNvbnN1bWVEcmF3QWxsKGUsdCl7ZT09PU90LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhd0FsbCh0LHRoaXMuc2VydmljZVdvcmspfXVwZGF0ZUNhbWVyYShlKXtjb25zdCB0PVtdLHtjYW1lcmFPcHQ6cn09ZTtyJiYodGhpcy5zZXRDYW1lcmFPcHQociksdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5mb3JFYWNoKChuLGkpPT57KG4udG9vbHNUeXBlPT09ZHQuUGVuY2lsfHxuLnRvb2xzVHlwZT09PWR0LkFycm93fHxuLnRvb2xzVHlwZT09PWR0LlN0cmFpZ2h0fHxuLnRvb2xzVHlwZT09PWR0LkVsbGlwc2V8fG4udG9vbHNUeXBlPT09ZHQuUmVjdGFuZ2xlfHxuLnRvb2xzVHlwZT09PWR0LlN0YXJ8fG4udG9vbHNUeXBlPT09ZHQuUG9seWdvbnx8bi50b29sc1R5cGU9PT1kdC5TcGVlY2hCYWxsb29ufHxuLnRvb2xzVHlwZT09PWR0LlRleHQpJiZ0aGlzLmxvY2FsV29yay53b3JrU2hhcGVTdGF0ZS5zZXQoaSx7d2lsbENsZWFyOiEwfSl9KSx0aGlzLmxvY2FsV29yay5ydW5FZmZlY3RXb3JrKCgpPT57aWYodGhpcy5zZXJ2aWNlV29yay5zZWxlY3RvcldvcmtTaGFwZXMuc2l6ZSlmb3IoY29uc3RbbixpXW9mIHRoaXMuc2VydmljZVdvcmsuc2VsZWN0b3JXb3JrU2hhcGVzLmVudHJpZXMoKSl0aGlzLnNlcnZpY2VXb3JrLnJ1blNlbGVjdFdvcmsoe3dvcmtJZDpuLHNlbGVjdElkczppLnNlbGVjdElkcyxtc2dUeXBlOmF0LlNlbGVjdCxkYXRhVHlwZTpPdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2lmKHRoaXMudk5vZGVzLmhhc1JlbmRlck5vZGVzKCkpe2xldCBuO3QucHVzaCh7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp5dC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0se2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9KTtmb3IoY29uc3QgaSBvZiB0aGlzLnZOb2Rlcy5jdXJOb2RlTWFwLnZhbHVlcygpKWJuKGkudG9vbHNUeXBlKSYmKG49YnQobixpLnJlY3QpKTtuJiZ0LnB1c2goe3JlY3Q6VnQobiwxMDApLGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0pfXQubGVuZ3RoJiZ0aGlzLnBvc3Qoe3JlbmRlcjp0fSl9KSl9Z2V0UmVjdEltYWdlQml0bWFwKGUsdCl7Y29uc3Qgcj1lLngqdGhpcy5kcHIsbj1lLnkqdGhpcy5kcHIsaT1lLncqdGhpcy5kcHIsYT1lLmgqdGhpcy5kcHI7cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKHRoaXMuZ2V0T2Zmc2NyZWVuKHQpLHIsbixpLGEpfXNhZmFyaUZpeFJlY3QoZSl7aWYoZS53K2UueDw9MHx8ZS5oK2UueTw9MHx8ZS53PD0wfHxlLmg8PTApcmV0dXJuO2NvbnN0IHQ9e3g6MCx5OjAsdzpNYXRoLmZsb29yKHRoaXMuc2NlbmUud2lkdGgpLGg6TWF0aC5mbG9vcih0aGlzLnNjZW5lLmhlaWdodCl9O2lmKGUueDwwP2UudytlLng8dGhpcy5zY2VuZS53aWR0aCYmKHQudz1lLncrZS54KTplLncrZS54PjAmJih0Lng9ZS54LHQudz1NYXRoLmZsb29yKHRoaXMuc2NlbmUud2lkdGgtZS54KSksZS55PDA/ZS5oK2UueTx0aGlzLnNjZW5lLmhlaWdodCYmKHQuaD1lLmgrZS55KTplLmgrZS55PjAmJih0Lnk9ZS55LHQuaD1NYXRoLmZsb29yKHRoaXMuc2NlbmUuaGVpZ2h0LWUueSkpLCEodC53PD0wfHx0Lmg8PTApKXJldHVybiB0fWdldFNjZW5lUmVjdCgpe2NvbnN0e3dpZHRoOmUsaGVpZ2h0OnR9PXRoaXMuc2NlbmU7cmV0dXJue3g6MCx5OjAsdzpNYXRoLmZsb29yKGUpLGg6TWF0aC5mbG9vcih0KX19Y2hlY2tSaWdodFJlY3RCb3VuZGluZ0JveChlKXtyZXR1cm4gdGhpcy52Tm9kZXMuY29tYmluZUludGVyc2VjdFJlY3QoZSl9Y3Vyc29ySG92ZXIoZSl7dGhpcy5sb2NhbFdvcmsuY3Vyc29ySG92ZXIoZSl9fWNsYXNzIGwwIGV4dGVuZHMga257Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKGUsdCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsb2NhbFdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLl9wb3N0PXI7Y29uc3Qgbj17dGhyZWFkOnRoaXMsdmlld0lkOnRoaXMudmlld0lkLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZHJhd0xheWVyLHBvc3Q6dGhpcy5wb3N0LmJpbmQodGhpcyl9O3RoaXMubG9jYWxXb3JrPW5ldyBzMChuKSx0aGlzLnZOb2Rlcy5pbml0KHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyKX1hc3luYyBwb3N0KGUsdCl7dmFyIGwscztjb25zdCByPWUucmVuZGVyLG49W107bGV0IGk9dDtpZihyIT1udWxsJiZyLmxlbmd0aCl7Zm9yKGNvbnN0IGYgb2YgcilpZihmLmRyYXdDYW52YXMmJnRoaXMuZnVsbExheWVyLnBhcmVudC5yZW5kZXIoKSxmLnJlY3Qpe2lmKHRoaXMuaXNTYWZhcmkmJihmLnJlY3Q9dGhpcy5zYWZhcmlGaXhSZWN0KFl0KGYucmVjdCkpKSwhZi5yZWN0KWNvbnRpbnVlO2lmKGYuZHJhd0NhbnZhcyl7Y29uc3Qgdj1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcChmLnJlY3QsISFmLmlzRnVsbFdvcmspO2YuaW1hZ2VCaXRtYXA9dixpfHwoaT1bXSksaS5wdXNoKHYpfW4ucHVzaChmKX1lLnJlbmRlcj1ufWNvbnN0IGE9KGw9ZS5zcCk9PW51bGw/dm9pZCAwOmwuZmlsdGVyKGY9PmYudHlwZSE9PWF0Lk5vbmV8fE9iamVjdC5rZXlzKGYpLmZpbHRlcih2PT52PT09InR5cGUiKS5sZW5ndGgpO2lmKGEhPW51bGwmJmEubGVuZ3RoJiYoZS5zcD1hLm1hcChmPT4oey4uLmYsdmlld0lkOnRoaXMudmlld0lkfSkpKSwoKHM9ZS5zcCkhPW51bGwmJnMubGVuZ3RofHxlLmRyYXdDb3VudHx8biE9bnVsbCYmbi5sZW5ndGgpJiYodGhpcy5fcG9zdChlLGkpLGkhPW51bGwmJmkubGVuZ3RoKSlmb3IoY29uc3QgZiBvZiBpKWYgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCYmZi5jbG9zZSgpfW9uKGUpe2NvbnN0e21zZ1R5cGU6dH09ZTtzd2l0Y2godCl7Y2FzZSBhdC5VcGRhdGVDYW1lcmE6dGhpcy51cGRhdGVDYW1lcmEoZSk7YnJlYWs7Y2FzZSBhdC5TbmFwc2hvdDp0aGlzLnNuYXBzaG90RnVsbExheWVyPXRoaXMuY3JlYXRlTGF5ZXIoInNuYXBzaG90RnVsbExheWVyIix0aGlzLnNjZW5lLHsuLi50aGlzLm9wdC5sYXllck9wdCxidWZmZXJTaXplOnRoaXMudmlld0lkPT09Im1haW5WaWV3Ij82ZTM6M2UzfSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllciYmdGhpcy5nZXRTbmFwc2hvdChlKS50aGVuKCgpPT57dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj12b2lkIDB9KTticmVhaztjYXNlIGF0LkJvdW5kaW5nQm94OnRoaXMuc25hcHNob3RGdWxsTGF5ZXI9dGhpcy5jcmVhdGVMYXllcigic25hcHNob3RGdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnRoaXMub3B0LmxheWVyT3B0LGJ1ZmZlclNpemU6dGhpcy52aWV3SWQ9PT0ibWFpblZpZXciPzZlMzozZTN9KSx0aGlzLnNuYXBzaG90RnVsbExheWVyJiZ0aGlzLmdldEJvdW5kaW5nUmVjdChlKS50aGVuKCgpPT57dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj12b2lkIDB9KTticmVha31zdXBlci5vbihlKX1nZXRPZmZzY3JlZW4oZSl7dmFyIHQ7cmV0dXJuKHQ9KGUmJnRoaXMuc25hcHNob3RGdWxsTGF5ZXJ8fHRoaXMuZnVsbExheWVyKS5wYXJlbnQpPT1udWxsP3ZvaWQgMDp0LmNhbnZhc31jb25zdW1lRHJhdyhlLHQpe2U9PT1PdC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXcodCl9Y29uc3VtZURyYXdBbGwoZSx0KXt0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhd0FsbCh0KX1nZXRSZWN0SW1hZ2VCaXRtYXAoZSx0PSExLHIpe2NvbnN0IG49ZS54KnRoaXMuZHByLGk9ZS55KnRoaXMuZHByLGE9ZS53KnRoaXMuZHByLGw9ZS5oKnRoaXMuZHByO3JldHVybiBjcmVhdGVJbWFnZUJpdG1hcCh0aGlzLmdldE9mZnNjcmVlbih0KSxuLGksYSxsLHIpfXNhZmFyaUZpeFJlY3QoZSl7aWYoZS53K2UueDw9MHx8ZS5oK2UueTw9MHx8ZS53PD0wfHxlLmg8PTApcmV0dXJuO2NvbnN0IHQ9e3g6MCx5OjAsdzpNYXRoLmZsb29yKHRoaXMuc2NlbmUud2lkdGgpLGg6TWF0aC5mbG9vcih0aGlzLnNjZW5lLmhlaWdodCl9O2lmKGUueDwwP2UudytlLng8dGhpcy5zY2VuZS53aWR0aCYmKHQudz1lLncrZS54KTplLncrZS54PjAmJih0Lng9ZS54LHQudz1NYXRoLmZsb29yKHRoaXMuc2NlbmUud2lkdGgtZS54KSksZS55PDA/ZS5oK2UueTx0aGlzLnNjZW5lLmhlaWdodCYmKHQuaD1lLmgrZS55KTplLmgrZS55PjAmJih0Lnk9ZS55LHQuaD1NYXRoLmZsb29yKHRoaXMuc2NlbmUuaGVpZ2h0LWUueSkpLCEodC53PD0wfHx0Lmg8PTApKXJldHVybiB0fXVwZGF0ZUNhbWVyYShlKXtjb25zdHtjYW1lcmFPcHQ6dH09ZTt0JiZ0aGlzLnNldENhbWVyYU9wdCh0KX1zZXRDYW1lcmFPcHQoZSx0KXt0aGlzLmNhbWVyYU9wdD1lO2NvbnN0e3NjYWxlOnIsY2VudGVyWDpuLGNlbnRlclk6aSx3aWR0aDphLGhlaWdodDpsfT1lOyhhIT09dGhpcy5zY2VuZS53aWR0aHx8bCE9PXRoaXMuc2NlbmUuaGVpZ2h0KSYmdGhpcy51cGRhdGVTY2VuZSh7d2lkdGg6YSxoZWlnaHQ6bH0pLHQ/KHQuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3Iscl0pLHQuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstbiwtaV0pKToodGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3Iscl0pLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLW4sLWldKSl9YXN5bmMgZ2V0U25hcHNob3QoZSl7Y29uc3R7c2NlbmVQYXRoOnQsc2NlbmVzOnIsY2FtZXJhT3B0Om4sdzppLGg6YSxtYXhaSW5kZXg6bH09ZTtpZih0JiZyJiZuJiZ0aGlzLnNuYXBzaG90RnVsbExheWVyKXtjb25zdCBzPVl0KHRoaXMuY2FtZXJhT3B0KTt0aGlzLnNldENhbWVyYU9wdChuLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIpLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLnNuYXBzaG90RnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj10aGlzLmZ1bGxMYXllcjtsZXQgZjtjb25zdCB2PW5ldyBNYXA7Zm9yKGNvbnN0W3AseV1vZiBPYmplY3QuZW50cmllcyhyKSlpZih5IT1udWxsJiZ5LnR5cGUpc3dpdGNoKHk9PW51bGw/dm9pZCAwOnkudHlwZSl7Y2FzZSBhdC5VcGRhdGVOb2RlOmNhc2UgYXQuRnVsbFdvcms6e2NvbnN0e3Rvb2xzVHlwZTpQLG9wdDp4fT15O1A9PT1kdC5UZXh0JiZ4JiYoeC56SW5kZXg9eC56SW5kZXgrKGx8fDApLCh4LmxpbmVUaHJvdWdofHx4LnVuZGVybGluZSkmJnYuc2V0KHAseSkpO2NvbnN0IG09YXdhaXQgdGhpcy5sb2NhbFdvcmsucnVuRnVsbFdvcmsoey4uLnksb3B0Ongsd29ya0lkOnAsbXNnVHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0sUD09PWR0LlRleHQpO2Y9YnQoZixtKTticmVha319dGhpcy5sb2NhbFdvcmsuZnVsbExheWVyPXRoaXMuZnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj12b2lkIDA7bGV0IGQ7aSYmYSYmKGQ9e3Jlc2l6ZVdpZHRoOmkscmVzaXplSGVpZ2h0OmF9KSx2LnNpemUmJihhd2FpdCBuZXcgUHJvbWlzZShwPT57c2V0VGltZW91dChwLDUwMCl9KSx0aGlzLndpbGxSZW5kZXJTcGVjaWFsTGFiZWwodikpLGF3YWl0IHRoaXMuZ2V0U25hcHNob3RSZW5kZXIoe3NjZW5lUGF0aDp0LGN1ckNhbWVyYU9wdDpzLG9wdGlvbnM6ZH0pfX13aWxsUmVuZGVyU3BlY2lhbExhYmVsKGUpe3ZhciB0O2Zvcihjb25zdFtyLG5db2YgZS5lbnRyaWVzKCkpe2NvbnN0IGk9KHQ9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcik9PW51bGw/dm9pZCAwOnQuZ2V0RWxlbWVudHNCeU5hbWUocilbMF07aSYmbi5vcHQmJnRoaXMubG9jYWxXb3JrLnVwZGF0ZUxhYmVscyhpLG4pfX1hc3luYyBnZXRTbmFwc2hvdFJlbmRlcihlKXt2YXIgYSxsO2NvbnN0e3NjZW5lUGF0aDp0LGN1ckNhbWVyYU9wdDpyLG9wdGlvbnM6bn09ZTsoKGE9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcik9PW51bGw/dm9pZCAwOmEucGFyZW50KS5yZW5kZXIoKTtjb25zdCBpPWF3YWl0IHRoaXMuZ2V0UmVjdEltYWdlQml0bWFwKHt4OjAseTowLHc6dGhpcy5zY2VuZS53aWR0aCxoOnRoaXMuc2NlbmUuaGVpZ2h0fSwhMCxuKTtpJiYoYXdhaXQgdGhpcy5wb3N0KHtzcDpbe3R5cGU6YXQuU25hcHNob3Qsc2NlbmVQYXRoOnQsaW1hZ2VCaXRtYXA6aX1dfSxbaV0pLGkuY2xvc2UoKSwobD10aGlzLnNuYXBzaG90RnVsbExheWVyKT09bnVsbHx8bC5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuc2V0Q2FtZXJhT3B0KHIsdGhpcy5mdWxsTGF5ZXIpKX1hc3luYyBnZXRCb3VuZGluZ1JlY3QoZSl7Y29uc3R7c2NlbmVQYXRoOnQsc2NlbmVzOnIsY2FtZXJhT3B0Om59PWU7aWYodCYmciYmbiYmdGhpcy5zbmFwc2hvdEZ1bGxMYXllcil7Y29uc3QgaT1ZdCh0aGlzLmNhbWVyYU9wdCk7dGhpcy5zZXRDYW1lcmFPcHQobix0aGlzLnNuYXBzaG90RnVsbExheWVyKSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dGhpcy5kcmF3TGF5ZXI7bGV0IGE7Zm9yKGNvbnN0W2wsc11vZiBPYmplY3QuZW50cmllcyhyKSlpZihzIT1udWxsJiZzLnR5cGUpc3dpdGNoKHM9PW51bGw/dm9pZCAwOnMudHlwZSl7Y2FzZSBhdC5VcGRhdGVOb2RlOmNhc2UgYXQuRnVsbFdvcms6e2NvbnN0IGY9YXdhaXQgdGhpcy5sb2NhbFdvcmsucnVuRnVsbFdvcmsoey4uLnMsd29ya0lkOmwsbXNnVHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2E9YnQoYSxmKTticmVha319YSYmYXdhaXQgdGhpcy5wb3N0KHtzcDpbe3R5cGU6YXQuQm91bmRpbmdCb3gsc2NlbmVQYXRoOnQscmVjdDphfV19KSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5mdWxsTGF5ZXIsdGhpcy5sb2NhbFdvcmsuZHJhd0xheWVyPXZvaWQgMCx0aGlzLnNuYXBzaG90RnVsbExheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5zZXRDYW1lcmFPcHQoaSx0aGlzLmZ1bGxMYXllcil9fX1jb25zdCBjMD1zZWxmO25ldyBvMChjMCxQZS5GdWxsKX0pKCk7Cg==", Tt = typeof window < "u" && window.Blob && new Blob([atob(ys)], { type: "text/javascript;charset=utf-8" });
function CX(m) {
  let d;
  try {
    if (d = Tt && (window.URL || window.webkitURL).createObjectURL(Tt), !d)
      throw "";
    const l = new Worker(d, {
      name: m == null ? void 0 : m.name
    });
    return l.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(d);
    }), l;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + ys,
      {
        name: m == null ? void 0 : m.name
      }
    );
  } finally {
    d && (window.URL || window.webkitURL).revokeObjectURL(d);
  }
}
const Ls = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBFZT10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIGNlKHUpe3JldHVybiB1JiZ1Ll9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1LCJkZWZhdWx0Iik/dS5kZWZhdWx0OnV9ZnVuY3Rpb24gc2koKXt0aGlzLl9fZGF0YV9fPVtdLHRoaXMuc2l6ZT0wfXZhciBvaT1zaTtmdW5jdGlvbiBhaSh1LGUpe3JldHVybiB1PT09ZXx8dSE9PXUmJmUhPT1lfXZhciBWZT1haSxsaT1WZTtmdW5jdGlvbiBjaSh1LGUpe2Zvcih2YXIgdD11Lmxlbmd0aDt0LS07KWlmKGxpKHVbdF1bMF0sZSkpcmV0dXJuIHQ7cmV0dXJuLTF9dmFyIEFlPWNpLHVpPUFlLGZpPUFycmF5LnByb3RvdHlwZSxoaT1maS5zcGxpY2U7ZnVuY3Rpb24gZGkodSl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PXVpKGUsdSk7aWYodDwwKXJldHVybiExO3ZhciByPWUubGVuZ3RoLTE7cmV0dXJuIHQ9PXI/ZS5wb3AoKTpoaS5jYWxsKGUsdCwxKSwtLXRoaXMuc2l6ZSwhMH12YXIgZ2k9ZGkscGk9QWU7ZnVuY3Rpb24gbWkodSl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PXBpKGUsdSk7cmV0dXJuIHQ8MD92b2lkIDA6ZVt0XVsxXX12YXIgdmk9bWkseWk9QWU7ZnVuY3Rpb24gU2kodSl7cmV0dXJuIHlpKHRoaXMuX19kYXRhX18sdSk+LTF9dmFyIHhpPVNpLE9pPUFlO2Z1bmN0aW9uIGJpKHUsZSl7dmFyIHQ9dGhpcy5fX2RhdGFfXyxyPU9pKHQsdSk7cmV0dXJuIHI8MD8oKyt0aGlzLnNpemUsdC5wdXNoKFt1LGVdKSk6dFtyXVsxXT1lLHRoaXN9dmFyIFBpPWJpLFRpPW9pLE1pPWdpLEVpPXZpLEFpPXhpLENpPVBpO2Z1bmN0aW9uIHVlKHUpe3ZhciBlPS0xLHQ9dT09bnVsbD8wOnUubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj11W2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fXVlLnByb3RvdHlwZS5jbGVhcj1UaSx1ZS5wcm90b3R5cGUuZGVsZXRlPU1pLHVlLnByb3RvdHlwZS5nZXQ9RWksdWUucHJvdG90eXBlLmhhcz1BaSx1ZS5wcm90b3R5cGUuc2V0PUNpO3ZhciBDZT11ZSxSaT1DZTtmdW5jdGlvbiBJaSgpe3RoaXMuX19kYXRhX189bmV3IFJpLHRoaXMuc2l6ZT0wfXZhciBMaT1JaTtmdW5jdGlvbiBEaSh1KXt2YXIgZT10aGlzLl9fZGF0YV9fLHQ9ZS5kZWxldGUodSk7cmV0dXJuIHRoaXMuc2l6ZT1lLnNpemUsdH12YXIgd2k9RGk7ZnVuY3Rpb24gTmkodSl7cmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KHUpfXZhciBCaT1OaTtmdW5jdGlvbiBqaSh1KXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModSl9dmFyIFdpPWppLEZpPXR5cGVvZiBFZT09Im9iamVjdCImJkVlJiZFZS5PYmplY3Q9PT1PYmplY3QmJkVlLHByPUZpLFVpPXByLCRpPXR5cGVvZiBzZWxmPT0ib2JqZWN0IiYmc2VsZiYmc2VsZi5PYmplY3Q9PT1PYmplY3QmJnNlbGYsemk9VWl8fCRpfHxGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpLFp0PXppLEdpPVp0LEhpPUdpLlN5bWJvbCxSZT1IaSxtcj1SZSx2cj1PYmplY3QucHJvdG90eXBlLEtpPXZyLmhhc093blByb3BlcnR5LFZpPXZyLnRvU3RyaW5nLFNlPW1yP21yLnRvU3RyaW5nVGFnOnZvaWQgMDtmdW5jdGlvbiBZaSh1KXt2YXIgZT1LaS5jYWxsKHUsU2UpLHQ9dVtTZV07dHJ5e3VbU2VdPXZvaWQgMDt2YXIgcj0hMH1jYXRjaHt9dmFyIG49VmkuY2FsbCh1KTtyZXR1cm4gciYmKGU/dVtTZV09dDpkZWxldGUgdVtTZV0pLG59dmFyIFhpPVlpLFppPU9iamVjdC5wcm90b3R5cGUsSmk9WmkudG9TdHJpbmc7ZnVuY3Rpb24gUWkodSl7cmV0dXJuIEppLmNhbGwodSl9dmFyIGtpPVFpLHlyPVJlLHFpPVhpLF9pPWtpLHRzPSJbb2JqZWN0IE51bGxdIixlcz0iW29iamVjdCBVbmRlZmluZWRdIixTcj15cj95ci50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24gcnModSl7cmV0dXJuIHU9PW51bGw/dT09PXZvaWQgMD9lczp0czpTciYmU3IgaW4gT2JqZWN0KHUpP3FpKHUpOl9pKHUpfXZhciBpZT1ycztmdW5jdGlvbiBucyh1KXt2YXIgZT10eXBlb2YgdTtyZXR1cm4gdSE9bnVsbCYmKGU9PSJvYmplY3QifHxlPT0iZnVuY3Rpb24iKX12YXIgcmU9bnMsaXM9aWUsc3M9cmUsb3M9IltvYmplY3QgQXN5bmNGdW5jdGlvbl0iLGFzPSJbb2JqZWN0IEZ1bmN0aW9uXSIsbHM9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixjcz0iW29iamVjdCBQcm94eV0iO2Z1bmN0aW9uIHVzKHUpe2lmKCFzcyh1KSlyZXR1cm4hMTt2YXIgZT1pcyh1KTtyZXR1cm4gZT09YXN8fGU9PWxzfHxlPT1vc3x8ZT09Y3N9dmFyIHhyPXVzLGZzPVp0LGhzPWZzWyJfX2NvcmUtanNfc2hhcmVkX18iXSxkcz1ocyxZZT1kcyxPcj1mdW5jdGlvbigpe3ZhciB1PS9bXi5dKyQvLmV4ZWMoWWUmJlllLmtleXMmJlllLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gdT8iU3ltYm9sKHNyYylfMS4iK3U6IiJ9KCk7ZnVuY3Rpb24gZ3ModSl7cmV0dXJuISFPciYmT3IgaW4gdX12YXIgcHM9Z3MsbXM9RnVuY3Rpb24ucHJvdG90eXBlLHZzPW1zLnRvU3RyaW5nO2Z1bmN0aW9uIHlzKHUpe2lmKHUhPW51bGwpe3RyeXtyZXR1cm4gdnMuY2FsbCh1KX1jYXRjaHt9dHJ5e3JldHVybiB1KyIifWNhdGNoe319cmV0dXJuIiJ9dmFyIGJyPXlzLFNzPXhyLHhzPXBzLE9zPXJlLGJzPWJyLFBzPS9bXFxeJC4qKz8oKVtcXXt9fF0vZyxUcz0vXlxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXF0kLyxNcz1GdW5jdGlvbi5wcm90b3R5cGUsRXM9T2JqZWN0LnByb3RvdHlwZSxBcz1Ncy50b1N0cmluZyxDcz1Fcy5oYXNPd25Qcm9wZXJ0eSxScz1SZWdFeHAoIl4iK0FzLmNhbGwoQ3MpLnJlcGxhY2UoUHMsIlxcJCYiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcKCl8IGZvciAuKz8oPz1cXFxdKS9nLCIkMS4qPyIpKyIkIik7ZnVuY3Rpb24gSXModSl7aWYoIU9zKHUpfHx4cyh1KSlyZXR1cm4hMTt2YXIgZT1Tcyh1KT9SczpUcztyZXR1cm4gZS50ZXN0KGJzKHUpKX12YXIgTHM9SXM7ZnVuY3Rpb24gRHModSxlKXtyZXR1cm4gdT09bnVsbD92b2lkIDA6dVtlXX12YXIgd3M9RHMsTnM9THMsQnM9d3M7ZnVuY3Rpb24ganModSxlKXt2YXIgdD1Ccyh1LGUpO3JldHVybiBOcyh0KT90OnZvaWQgMH12YXIgc2U9anMsV3M9c2UsRnM9WnQsVXM9V3MoRnMsIk1hcCIpLFhlPVVzLCRzPXNlLHpzPSRzKE9iamVjdCwiY3JlYXRlIiksSWU9enMsUHI9SWU7ZnVuY3Rpb24gR3MoKXt0aGlzLl9fZGF0YV9fPVByP1ByKG51bGwpOnt9LHRoaXMuc2l6ZT0wfXZhciBIcz1HcztmdW5jdGlvbiBLcyh1KXt2YXIgZT10aGlzLmhhcyh1KSYmZGVsZXRlIHRoaXMuX19kYXRhX19bdV07cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX12YXIgVnM9S3MsWXM9SWUsWHM9Il9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18iLFpzPU9iamVjdC5wcm90b3R5cGUsSnM9WnMuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gUXModSl7dmFyIGU9dGhpcy5fX2RhdGFfXztpZihZcyl7dmFyIHQ9ZVt1XTtyZXR1cm4gdD09PVhzP3ZvaWQgMDp0fXJldHVybiBKcy5jYWxsKGUsdSk/ZVt1XTp2b2lkIDB9dmFyIGtzPVFzLHFzPUllLF9zPU9iamVjdC5wcm90b3R5cGUsdG89X3MuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gZW8odSl7dmFyIGU9dGhpcy5fX2RhdGFfXztyZXR1cm4gcXM/ZVt1XSE9PXZvaWQgMDp0by5jYWxsKGUsdSl9dmFyIHJvPWVvLG5vPUllLGlvPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIjtmdW5jdGlvbiBzbyh1LGUpe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXModSk/MDoxLHRbdV09bm8mJmU9PT12b2lkIDA/aW86ZSx0aGlzfXZhciBvbz1zbyxhbz1Icyxsbz1Wcyxjbz1rcyx1bz1ybyxmbz1vbztmdW5jdGlvbiBmZSh1KXt2YXIgZT0tMSx0PXU9PW51bGw/MDp1Lmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9dVtlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1mZS5wcm90b3R5cGUuY2xlYXI9YW8sZmUucHJvdG90eXBlLmRlbGV0ZT1sbyxmZS5wcm90b3R5cGUuZ2V0PWNvLGZlLnByb3RvdHlwZS5oYXM9dW8sZmUucHJvdG90eXBlLnNldD1mbzt2YXIgaG89ZmUsVHI9aG8sZ289Q2UscG89WGU7ZnVuY3Rpb24gbW8oKXt0aGlzLnNpemU9MCx0aGlzLl9fZGF0YV9fPXtoYXNoOm5ldyBUcixtYXA6bmV3KHBvfHxnbyksc3RyaW5nOm5ldyBUcn19dmFyIHZvPW1vO2Z1bmN0aW9uIHlvKHUpe3ZhciBlPXR5cGVvZiB1O3JldHVybiBlPT0ic3RyaW5nInx8ZT09Im51bWJlciJ8fGU9PSJzeW1ib2wifHxlPT0iYm9vbGVhbiI/dSE9PSJfX3Byb3RvX18iOnU9PT1udWxsfXZhciBTbz15byx4bz1TbztmdW5jdGlvbiBPbyh1LGUpe3ZhciB0PXUuX19kYXRhX187cmV0dXJuIHhvKGUpP3RbdHlwZW9mIGU9PSJzdHJpbmciPyJzdHJpbmciOiJoYXNoIl06dC5tYXB9dmFyIExlPU9vLGJvPUxlO2Z1bmN0aW9uIFBvKHUpe3ZhciBlPWJvKHRoaXMsdSkuZGVsZXRlKHUpO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIFRvPVBvLE1vPUxlO2Z1bmN0aW9uIEVvKHUpe3JldHVybiBNbyh0aGlzLHUpLmdldCh1KX12YXIgQW89RW8sQ289TGU7ZnVuY3Rpb24gUm8odSl7cmV0dXJuIENvKHRoaXMsdSkuaGFzKHUpfXZhciBJbz1SbyxMbz1MZTtmdW5jdGlvbiBEbyh1LGUpe3ZhciB0PUxvKHRoaXMsdSkscj10LnNpemU7cmV0dXJuIHQuc2V0KHUsZSksdGhpcy5zaXplKz10LnNpemU9PXI/MDoxLHRoaXN9dmFyIHdvPURvLE5vPXZvLEJvPVRvLGpvPUFvLFdvPUlvLEZvPXdvO2Z1bmN0aW9uIGhlKHUpe3ZhciBlPS0xLHQ9dT09bnVsbD8wOnUubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj11W2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fWhlLnByb3RvdHlwZS5jbGVhcj1ObyxoZS5wcm90b3R5cGUuZGVsZXRlPUJvLGhlLnByb3RvdHlwZS5nZXQ9am8saGUucHJvdG90eXBlLmhhcz1XbyxoZS5wcm90b3R5cGUuc2V0PUZvO3ZhciBNcj1oZSxVbz1DZSwkbz1YZSx6bz1NcixHbz0yMDA7ZnVuY3Rpb24gSG8odSxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO2lmKHQgaW5zdGFuY2VvZiBVbyl7dmFyIHI9dC5fX2RhdGFfXztpZighJG98fHIubGVuZ3RoPEdvLTEpcmV0dXJuIHIucHVzaChbdSxlXSksdGhpcy5zaXplPSsrdC5zaXplLHRoaXM7dD10aGlzLl9fZGF0YV9fPW5ldyB6byhyKX1yZXR1cm4gdC5zZXQodSxlKSx0aGlzLnNpemU9dC5zaXplLHRoaXN9dmFyIEtvPUhvLFZvPUNlLFlvPUxpLFhvPXdpLFpvPUJpLEpvPVdpLFFvPUtvO2Z1bmN0aW9uIGRlKHUpe3ZhciBlPXRoaXMuX19kYXRhX189bmV3IFZvKHUpO3RoaXMuc2l6ZT1lLnNpemV9ZGUucHJvdG90eXBlLmNsZWFyPVlvLGRlLnByb3RvdHlwZS5kZWxldGU9WG8sZGUucHJvdG90eXBlLmdldD1abyxkZS5wcm90b3R5cGUuaGFzPUpvLGRlLnByb3RvdHlwZS5zZXQ9UW87dmFyIEVyPWRlO2Z1bmN0aW9uIGtvKHUsZSl7Zm9yKHZhciB0PS0xLHI9dT09bnVsbD8wOnUubGVuZ3RoOysrdDxyJiZlKHVbdF0sdCx1KSE9PSExOyk7cmV0dXJuIHV9dmFyIHFvPWtvLF9vPXNlLHRhPWZ1bmN0aW9uKCl7dHJ5e3ZhciB1PV9vKE9iamVjdCwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gdSh7fSwiIix7fSksdX1jYXRjaHt9fSgpLGVhPXRhLEFyPWVhO2Z1bmN0aW9uIHJhKHUsZSx0KXtlPT0iX19wcm90b19fIiYmQXI/QXIodSxlLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0LHdyaXRhYmxlOiEwfSk6dVtlXT10fXZhciBDcj1yYSxuYT1DcixpYT1WZSxzYT1PYmplY3QucHJvdG90eXBlLG9hPXNhLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIGFhKHUsZSx0KXt2YXIgcj11W2VdOyghKG9hLmNhbGwodSxlKSYmaWEocix0KSl8fHQ9PT12b2lkIDAmJiEoZSBpbiB1KSkmJm5hKHUsZSx0KX12YXIgUnI9YWEsbGE9UnIsY2E9Q3I7ZnVuY3Rpb24gdWEodSxlLHQscil7dmFyIG49IXQ7dHx8KHQ9e30pO2Zvcih2YXIgaT0tMSxhPWUubGVuZ3RoOysraTxhOyl7dmFyIGw9ZVtpXSxzPXI/cih0W2xdLHVbbF0sbCx0LHUpOnZvaWQgMDtzPT09dm9pZCAwJiYocz11W2xdKSxuP2NhKHQsbCxzKTpsYSh0LGwscyl9cmV0dXJuIHR9dmFyIERlPXVhO2Z1bmN0aW9uIGZhKHUsZSl7Zm9yKHZhciB0PS0xLHI9QXJyYXkodSk7Kyt0PHU7KXJbdF09ZSh0KTtyZXR1cm4gcn12YXIgaGE9ZmE7ZnVuY3Rpb24gZGEodSl7cmV0dXJuIHUhPW51bGwmJnR5cGVvZiB1PT0ib2JqZWN0In12YXIgX3Q9ZGEsZ2E9aWUscGE9X3QsbWE9IltvYmplY3QgQXJndW1lbnRzXSI7ZnVuY3Rpb24gdmEodSl7cmV0dXJuIHBhKHUpJiZnYSh1KT09bWF9dmFyIHlhPXZhLElyPXlhLFNhPV90LExyPU9iamVjdC5wcm90b3R5cGUseGE9THIuaGFzT3duUHJvcGVydHksT2E9THIucHJvcGVydHlJc0VudW1lcmFibGUsYmE9SXIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT9JcjpmdW5jdGlvbih1KXtyZXR1cm4gU2EodSkmJnhhLmNhbGwodSwiY2FsbGVlIikmJiFPYS5jYWxsKHUsImNhbGxlZSIpfSxQYT1iYSxUYT1BcnJheS5pc0FycmF5LHdlPVRhLE5lPXtleHBvcnRzOnt9fTtmdW5jdGlvbiBNYSgpe3JldHVybiExfXZhciBFYT1NYTtOZS5leHBvcnRzLGZ1bmN0aW9uKHUsZSl7dmFyIHQ9WnQscj1FYSxuPWUmJiFlLm5vZGVUeXBlJiZlLGk9biYmITAmJnUmJiF1Lm5vZGVUeXBlJiZ1LGE9aSYmaS5leHBvcnRzPT09bixsPWE/dC5CdWZmZXI6dm9pZCAwLHM9bD9sLmlzQnVmZmVyOnZvaWQgMCxmPXN8fHI7dS5leHBvcnRzPWZ9KE5lLE5lLmV4cG9ydHMpO3ZhciBaZT1OZS5leHBvcnRzLEFhPTkwMDcxOTkyNTQ3NDA5OTEsQ2E9L14oPzowfFsxLTldXGQqKSQvO2Z1bmN0aW9uIFJhKHUsZSl7dmFyIHQ9dHlwZW9mIHU7cmV0dXJuIGU9ZT8/QWEsISFlJiYodD09Im51bWJlciJ8fHQhPSJzeW1ib2wiJiZDYS50ZXN0KHUpKSYmdT4tMSYmdSUxPT0wJiZ1PGV9dmFyIElhPVJhLExhPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24gRGEodSl7cmV0dXJuIHR5cGVvZiB1PT0ibnVtYmVyIiYmdT4tMSYmdSUxPT0wJiZ1PD1MYX12YXIgRHI9RGEsd2E9aWUsTmE9RHIsQmE9X3QsamE9IltvYmplY3QgQXJndW1lbnRzXSIsV2E9IltvYmplY3QgQXJyYXldIixGYT0iW29iamVjdCBCb29sZWFuXSIsVWE9IltvYmplY3QgRGF0ZV0iLCRhPSJbb2JqZWN0IEVycm9yXSIsemE9IltvYmplY3QgRnVuY3Rpb25dIixHYT0iW29iamVjdCBNYXBdIixIYT0iW29iamVjdCBOdW1iZXJdIixLYT0iW29iamVjdCBPYmplY3RdIixWYT0iW29iamVjdCBSZWdFeHBdIixZYT0iW29iamVjdCBTZXRdIixYYT0iW29iamVjdCBTdHJpbmddIixaYT0iW29iamVjdCBXZWFrTWFwXSIsSmE9IltvYmplY3QgQXJyYXlCdWZmZXJdIixRYT0iW29iamVjdCBEYXRhVmlld10iLGthPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLHFhPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLF9hPSJbb2JqZWN0IEludDhBcnJheV0iLHRsPSJbb2JqZWN0IEludDE2QXJyYXldIixlbD0iW29iamVjdCBJbnQzMkFycmF5XSIscmw9IltvYmplY3QgVWludDhBcnJheV0iLG5sPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsaWw9IltvYmplY3QgVWludDE2QXJyYXldIixzbD0iW29iamVjdCBVaW50MzJBcnJheV0iLEJ0PXt9O0J0W2thXT1CdFtxYV09QnRbX2FdPUJ0W3RsXT1CdFtlbF09QnRbcmxdPUJ0W25sXT1CdFtpbF09QnRbc2xdPSEwLEJ0W2phXT1CdFtXYV09QnRbSmFdPUJ0W0ZhXT1CdFtRYV09QnRbVWFdPUJ0WyRhXT1CdFt6YV09QnRbR2FdPUJ0W0hhXT1CdFtLYV09QnRbVmFdPUJ0W1lhXT1CdFtYYV09QnRbWmFdPSExO2Z1bmN0aW9uIG9sKHUpe3JldHVybiBCYSh1KSYmTmEodS5sZW5ndGgpJiYhIUJ0W3dhKHUpXX12YXIgYWw9b2w7ZnVuY3Rpb24gbGwodSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB1KGUpfX12YXIgSmU9bGwsQmU9e2V4cG9ydHM6e319O0JlLmV4cG9ydHMsZnVuY3Rpb24odSxlKXt2YXIgdD1wcixyPWUmJiFlLm5vZGVUeXBlJiZlLG49ciYmITAmJnUmJiF1Lm5vZGVUeXBlJiZ1LGk9biYmbi5leHBvcnRzPT09cixhPWkmJnQucHJvY2VzcyxsPWZ1bmN0aW9uKCl7dHJ5e3ZhciBzPW4mJm4ucmVxdWlyZSYmbi5yZXF1aXJlKCJ1dGlsIikudHlwZXM7cmV0dXJuIHN8fGEmJmEuYmluZGluZyYmYS5iaW5kaW5nKCJ1dGlsIil9Y2F0Y2h7fX0oKTt1LmV4cG9ydHM9bH0oQmUsQmUuZXhwb3J0cyk7dmFyIFFlPUJlLmV4cG9ydHMsY2w9YWwsdWw9SmUsd3I9UWUsTnI9d3ImJndyLmlzVHlwZWRBcnJheSxmbD1Ocj91bChOcik6Y2wsQnI9ZmwsaGw9aGEsZGw9UGEsZ2w9d2UscGw9WmUsbWw9SWEsdmw9QnIseWw9T2JqZWN0LnByb3RvdHlwZSxTbD15bC5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiB4bCh1LGUpe3ZhciB0PWdsKHUpLHI9IXQmJmRsKHUpLG49IXQmJiFyJiZwbCh1KSxpPSF0JiYhciYmIW4mJnZsKHUpLGE9dHx8cnx8bnx8aSxsPWE/aGwodS5sZW5ndGgsU3RyaW5nKTpbXSxzPWwubGVuZ3RoO2Zvcih2YXIgZiBpbiB1KShlfHxTbC5jYWxsKHUsZikpJiYhKGEmJihmPT0ibGVuZ3RoInx8biYmKGY9PSJvZmZzZXQifHxmPT0icGFyZW50Iil8fGkmJihmPT0iYnVmZmVyInx8Zj09ImJ5dGVMZW5ndGgifHxmPT0iYnl0ZU9mZnNldCIpfHxtbChmLHMpKSkmJmwucHVzaChmKTtyZXR1cm4gbH12YXIganI9eGwsT2w9T2JqZWN0LnByb3RvdHlwZTtmdW5jdGlvbiBibCh1KXt2YXIgZT11JiZ1LmNvbnN0cnVjdG9yLHQ9dHlwZW9mIGU9PSJmdW5jdGlvbiImJmUucHJvdG90eXBlfHxPbDtyZXR1cm4gdT09PXR9dmFyIGtlPWJsO2Z1bmN0aW9uIFBsKHUsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiB1KGUodCkpfX12YXIgV3I9UGwsVGw9V3IsTWw9VGwoT2JqZWN0LmtleXMsT2JqZWN0KSxFbD1NbCxBbD1rZSxDbD1FbCxSbD1PYmplY3QucHJvdG90eXBlLElsPVJsLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIExsKHUpe2lmKCFBbCh1KSlyZXR1cm4gQ2wodSk7dmFyIGU9W107Zm9yKHZhciB0IGluIE9iamVjdCh1KSlJbC5jYWxsKHUsdCkmJnQhPSJjb25zdHJ1Y3RvciImJmUucHVzaCh0KTtyZXR1cm4gZX12YXIgRGw9TGwsd2w9eHIsTmw9RHI7ZnVuY3Rpb24gQmwodSl7cmV0dXJuIHUhPW51bGwmJk5sKHUubGVuZ3RoKSYmIXdsKHUpfXZhciBGcj1CbCxqbD1qcixXbD1EbCxGbD1GcjtmdW5jdGlvbiBVbCh1KXtyZXR1cm4gRmwodSk/amwodSk6V2wodSl9dmFyIHFlPVVsLCRsPURlLHpsPXFlO2Z1bmN0aW9uIEdsKHUsZSl7cmV0dXJuIHUmJiRsKGUsemwoZSksdSl9dmFyIEhsPUdsO2Z1bmN0aW9uIEtsKHUpe3ZhciBlPVtdO2lmKHUhPW51bGwpZm9yKHZhciB0IGluIE9iamVjdCh1KSllLnB1c2godCk7cmV0dXJuIGV9dmFyIFZsPUtsLFlsPXJlLFhsPWtlLFpsPVZsLEpsPU9iamVjdC5wcm90b3R5cGUsUWw9SmwuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24ga2wodSl7aWYoIVlsKHUpKXJldHVybiBabCh1KTt2YXIgZT1YbCh1KSx0PVtdO2Zvcih2YXIgciBpbiB1KXI9PSJjb25zdHJ1Y3RvciImJihlfHwhUWwuY2FsbCh1LHIpKXx8dC5wdXNoKHIpO3JldHVybiB0fXZhciBxbD1rbCxfbD1qcix0Yz1xbCxlYz1GcjtmdW5jdGlvbiByYyh1KXtyZXR1cm4gZWModSk/X2wodSwhMCk6dGModSl9dmFyIF9lPXJjLG5jPURlLGljPV9lO2Z1bmN0aW9uIHNjKHUsZSl7cmV0dXJuIHUmJm5jKGUsaWMoZSksdSl9dmFyIG9jPXNjLGplPXtleHBvcnRzOnt9fTtqZS5leHBvcnRzLGZ1bmN0aW9uKHUsZSl7dmFyIHQ9WnQscj1lJiYhZS5ub2RlVHlwZSYmZSxuPXImJiEwJiZ1JiYhdS5ub2RlVHlwZSYmdSxpPW4mJm4uZXhwb3J0cz09PXIsYT1pP3QuQnVmZmVyOnZvaWQgMCxsPWE/YS5hbGxvY1Vuc2FmZTp2b2lkIDA7ZnVuY3Rpb24gcyhmLHYpe2lmKHYpcmV0dXJuIGYuc2xpY2UoKTt2YXIgZD1mLmxlbmd0aCxwPWw/bChkKTpuZXcgZi5jb25zdHJ1Y3RvcihkKTtyZXR1cm4gZi5jb3B5KHApLHB9dS5leHBvcnRzPXN9KGplLGplLmV4cG9ydHMpO3ZhciBhYz1qZS5leHBvcnRzO2Z1bmN0aW9uIGxjKHUsZSl7dmFyIHQ9LTEscj11Lmxlbmd0aDtmb3IoZXx8KGU9QXJyYXkocikpOysrdDxyOyllW3RdPXVbdF07cmV0dXJuIGV9dmFyIGNjPWxjO2Z1bmN0aW9uIHVjKHUsZSl7Zm9yKHZhciB0PS0xLHI9dT09bnVsbD8wOnUubGVuZ3RoLG49MCxpPVtdOysrdDxyOyl7dmFyIGE9dVt0XTtlKGEsdCx1KSYmKGlbbisrXT1hKX1yZXR1cm4gaX12YXIgZmM9dWM7ZnVuY3Rpb24gaGMoKXtyZXR1cm5bXX12YXIgVXI9aGMsZGM9ZmMsZ2M9VXIscGM9T2JqZWN0LnByb3RvdHlwZSxtYz1wYy5wcm9wZXJ0eUlzRW51bWVyYWJsZSwkcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLHZjPSRyP2Z1bmN0aW9uKHUpe3JldHVybiB1PT1udWxsP1tdOih1PU9iamVjdCh1KSxkYygkcih1KSxmdW5jdGlvbihlKXtyZXR1cm4gbWMuY2FsbCh1LGUpfSkpfTpnYyx0cj12Yyx5Yz1EZSxTYz10cjtmdW5jdGlvbiB4Yyh1LGUpe3JldHVybiB5Yyh1LFNjKHUpLGUpfXZhciBPYz14YztmdW5jdGlvbiBiYyh1LGUpe2Zvcih2YXIgdD0tMSxyPWUubGVuZ3RoLG49dS5sZW5ndGg7Kyt0PHI7KXVbbit0XT1lW3RdO3JldHVybiB1fXZhciB6cj1iYyxQYz1XcixUYz1QYyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KSxHcj1UYyxNYz16cixFYz1HcixBYz10cixDYz1VcixSYz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLEljPVJjP2Z1bmN0aW9uKHUpe2Zvcih2YXIgZT1bXTt1OylNYyhlLEFjKHUpKSx1PUVjKHUpO3JldHVybiBlfTpDYyxIcj1JYyxMYz1EZSxEYz1IcjtmdW5jdGlvbiB3Yyh1LGUpe3JldHVybiBMYyh1LERjKHUpLGUpfXZhciBOYz13YyxCYz16cixqYz13ZTtmdW5jdGlvbiBXYyh1LGUsdCl7dmFyIHI9ZSh1KTtyZXR1cm4gamModSk/cjpCYyhyLHQodSkpfXZhciBLcj1XYyxGYz1LcixVYz10ciwkYz1xZTtmdW5jdGlvbiB6Yyh1KXtyZXR1cm4gRmModSwkYyxVYyl9dmFyIFZyPXpjLEdjPUtyLEhjPUhyLEtjPV9lO2Z1bmN0aW9uIFZjKHUpe3JldHVybiBHYyh1LEtjLEhjKX12YXIgWWM9VmMsWGM9c2UsWmM9WnQsSmM9WGMoWmMsIkRhdGFWaWV3IiksUWM9SmMsa2M9c2UscWM9WnQsX2M9a2MocWMsIlByb21pc2UiKSx0dT1fYyxldT1zZSxydT1adCxudT1ldShydSwiU2V0IiksaXU9bnUsc3U9c2Usb3U9WnQsYXU9c3Uob3UsIldlYWtNYXAiKSxsdT1hdSxlcj1RYyxycj1YZSxucj10dSxpcj1pdSxzcj1sdSxZcj1pZSxnZT1icixYcj0iW29iamVjdCBNYXBdIixjdT0iW29iamVjdCBPYmplY3RdIixacj0iW29iamVjdCBQcm9taXNlXSIsSnI9IltvYmplY3QgU2V0XSIsUXI9IltvYmplY3QgV2Vha01hcF0iLGtyPSJbb2JqZWN0IERhdGFWaWV3XSIsdXU9Z2UoZXIpLGZ1PWdlKHJyKSxodT1nZShuciksZHU9Z2UoaXIpLGd1PWdlKHNyKSxvZT1ZcjsoZXImJm9lKG5ldyBlcihuZXcgQXJyYXlCdWZmZXIoMSkpKSE9a3J8fHJyJiZvZShuZXcgcnIpIT1Ycnx8bnImJm9lKG5yLnJlc29sdmUoKSkhPVpyfHxpciYmb2UobmV3IGlyKSE9SnJ8fHNyJiZvZShuZXcgc3IpIT1RcikmJihvZT1mdW5jdGlvbih1KXt2YXIgZT1Zcih1KSx0PWU9PWN1P3UuY29uc3RydWN0b3I6dm9pZCAwLHI9dD9nZSh0KToiIjtpZihyKXN3aXRjaChyKXtjYXNlIHV1OnJldHVybiBrcjtjYXNlIGZ1OnJldHVybiBYcjtjYXNlIGh1OnJldHVybiBacjtjYXNlIGR1OnJldHVybiBKcjtjYXNlIGd1OnJldHVybiBRcn1yZXR1cm4gZX0pO3ZhciBXZT1vZSxwdT1PYmplY3QucHJvdG90eXBlLG11PXB1Lmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHZ1KHUpe3ZhciBlPXUubGVuZ3RoLHQ9bmV3IHUuY29uc3RydWN0b3IoZSk7cmV0dXJuIGUmJnR5cGVvZiB1WzBdPT0ic3RyaW5nIiYmbXUuY2FsbCh1LCJpbmRleCIpJiYodC5pbmRleD11LmluZGV4LHQuaW5wdXQ9dS5pbnB1dCksdH12YXIgeXU9dnUsU3U9WnQseHU9U3UuVWludDhBcnJheSxxcj14dSxfcj1xcjtmdW5jdGlvbiBPdSh1KXt2YXIgZT1uZXcgdS5jb25zdHJ1Y3Rvcih1LmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgX3IoZSkuc2V0KG5ldyBfcih1KSksZX12YXIgb3I9T3UsYnU9b3I7ZnVuY3Rpb24gUHUodSxlKXt2YXIgdD1lP2J1KHUuYnVmZmVyKTp1LmJ1ZmZlcjtyZXR1cm4gbmV3IHUuY29uc3RydWN0b3IodCx1LmJ5dGVPZmZzZXQsdS5ieXRlTGVuZ3RoKX12YXIgVHU9UHUsTXU9L1x3KiQvO2Z1bmN0aW9uIEV1KHUpe3ZhciBlPW5ldyB1LmNvbnN0cnVjdG9yKHUuc291cmNlLE11LmV4ZWModSkpO3JldHVybiBlLmxhc3RJbmRleD11Lmxhc3RJbmRleCxlfXZhciBBdT1FdSx0bj1SZSxlbj10bj90bi5wcm90b3R5cGU6dm9pZCAwLHJuPWVuP2VuLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIEN1KHUpe3JldHVybiBybj9PYmplY3Qocm4uY2FsbCh1KSk6e319dmFyIFJ1PUN1LEl1PW9yO2Z1bmN0aW9uIEx1KHUsZSl7dmFyIHQ9ZT9JdSh1LmJ1ZmZlcik6dS5idWZmZXI7cmV0dXJuIG5ldyB1LmNvbnN0cnVjdG9yKHQsdS5ieXRlT2Zmc2V0LHUubGVuZ3RoKX12YXIgRHU9THUsd3U9b3IsTnU9VHUsQnU9QXUsanU9UnUsV3U9RHUsRnU9IltvYmplY3QgQm9vbGVhbl0iLFV1PSJbb2JqZWN0IERhdGVdIiwkdT0iW29iamVjdCBNYXBdIix6dT0iW29iamVjdCBOdW1iZXJdIixHdT0iW29iamVjdCBSZWdFeHBdIixIdT0iW29iamVjdCBTZXRdIixLdT0iW29iamVjdCBTdHJpbmddIixWdT0iW29iamVjdCBTeW1ib2xdIixZdT0iW29iamVjdCBBcnJheUJ1ZmZlcl0iLFh1PSJbb2JqZWN0IERhdGFWaWV3XSIsWnU9IltvYmplY3QgRmxvYXQzMkFycmF5XSIsSnU9IltvYmplY3QgRmxvYXQ2NEFycmF5XSIsUXU9IltvYmplY3QgSW50OEFycmF5XSIsa3U9IltvYmplY3QgSW50MTZBcnJheV0iLHF1PSJbb2JqZWN0IEludDMyQXJyYXldIixfdT0iW29iamVjdCBVaW50OEFycmF5XSIsdGY9IltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIixlZj0iW29iamVjdCBVaW50MTZBcnJheV0iLHJmPSJbb2JqZWN0IFVpbnQzMkFycmF5XSI7ZnVuY3Rpb24gbmYodSxlLHQpe3ZhciByPXUuY29uc3RydWN0b3I7c3dpdGNoKGUpe2Nhc2UgWXU6cmV0dXJuIHd1KHUpO2Nhc2UgRnU6Y2FzZSBVdTpyZXR1cm4gbmV3IHIoK3UpO2Nhc2UgWHU6cmV0dXJuIE51KHUsdCk7Y2FzZSBadTpjYXNlIEp1OmNhc2UgUXU6Y2FzZSBrdTpjYXNlIHF1OmNhc2UgX3U6Y2FzZSB0ZjpjYXNlIGVmOmNhc2UgcmY6cmV0dXJuIFd1KHUsdCk7Y2FzZSAkdTpyZXR1cm4gbmV3IHI7Y2FzZSB6dTpjYXNlIEt1OnJldHVybiBuZXcgcih1KTtjYXNlIEd1OnJldHVybiBCdSh1KTtjYXNlIEh1OnJldHVybiBuZXcgcjtjYXNlIFZ1OnJldHVybiBqdSh1KX19dmFyIHNmPW5mLG9mPXJlLG5uPU9iamVjdC5jcmVhdGUsYWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB1KCl7fXJldHVybiBmdW5jdGlvbihlKXtpZighb2YoZSkpcmV0dXJue307aWYobm4pcmV0dXJuIG5uKGUpO3UucHJvdG90eXBlPWU7dmFyIHQ9bmV3IHU7cmV0dXJuIHUucHJvdG90eXBlPXZvaWQgMCx0fX0oKSxsZj1hZixjZj1sZix1Zj1HcixmZj1rZTtmdW5jdGlvbiBoZih1KXtyZXR1cm4gdHlwZW9mIHUuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiFmZih1KT9jZih1Zih1KSk6e319dmFyIGRmPWhmLGdmPVdlLHBmPV90LG1mPSJbb2JqZWN0IE1hcF0iO2Z1bmN0aW9uIHZmKHUpe3JldHVybiBwZih1KSYmZ2YodSk9PW1mfXZhciB5Zj12ZixTZj15Zix4Zj1KZSxzbj1RZSxvbj1zbiYmc24uaXNNYXAsT2Y9b24/eGYob24pOlNmLGJmPU9mLFBmPVdlLFRmPV90LE1mPSJbb2JqZWN0IFNldF0iO2Z1bmN0aW9uIEVmKHUpe3JldHVybiBUZih1KSYmUGYodSk9PU1mfXZhciBBZj1FZixDZj1BZixSZj1KZSxhbj1RZSxsbj1hbiYmYW4uaXNTZXQsSWY9bG4/UmYobG4pOkNmLExmPUlmLERmPUVyLHdmPXFvLE5mPVJyLEJmPUhsLGpmPW9jLFdmPWFjLEZmPWNjLFVmPU9jLCRmPU5jLHpmPVZyLEdmPVljLEhmPVdlLEtmPXl1LFZmPXNmLFlmPWRmLFhmPXdlLFpmPVplLEpmPWJmLFFmPXJlLGtmPUxmLHFmPXFlLF9mPV9lLHRoPTEsZWg9MixyaD00LGNuPSJbb2JqZWN0IEFyZ3VtZW50c10iLG5oPSJbb2JqZWN0IEFycmF5XSIsaWg9IltvYmplY3QgQm9vbGVhbl0iLHNoPSJbb2JqZWN0IERhdGVdIixvaD0iW29iamVjdCBFcnJvcl0iLHVuPSJbb2JqZWN0IEZ1bmN0aW9uXSIsYWg9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixsaD0iW29iamVjdCBNYXBdIixjaD0iW29iamVjdCBOdW1iZXJdIixmbj0iW29iamVjdCBPYmplY3RdIix1aD0iW29iamVjdCBSZWdFeHBdIixmaD0iW29iamVjdCBTZXRdIixoaD0iW29iamVjdCBTdHJpbmddIixkaD0iW29iamVjdCBTeW1ib2xdIixnaD0iW29iamVjdCBXZWFrTWFwXSIscGg9IltvYmplY3QgQXJyYXlCdWZmZXJdIixtaD0iW29iamVjdCBEYXRhVmlld10iLHZoPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLHloPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFNoPSJbb2JqZWN0IEludDhBcnJheV0iLHhoPSJbb2JqZWN0IEludDE2QXJyYXldIixPaD0iW29iamVjdCBJbnQzMkFycmF5XSIsYmg9IltvYmplY3QgVWludDhBcnJheV0iLFBoPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsVGg9IltvYmplY3QgVWludDE2QXJyYXldIixNaD0iW29iamVjdCBVaW50MzJBcnJheV0iLHd0PXt9O3d0W2NuXT13dFtuaF09d3RbcGhdPXd0W21oXT13dFtpaF09d3Rbc2hdPXd0W3ZoXT13dFt5aF09d3RbU2hdPXd0W3hoXT13dFtPaF09d3RbbGhdPXd0W2NoXT13dFtmbl09d3RbdWhdPXd0W2ZoXT13dFtoaF09d3RbZGhdPXd0W2JoXT13dFtQaF09d3RbVGhdPXd0W01oXT0hMCx3dFtvaF09d3RbdW5dPXd0W2doXT0hMTtmdW5jdGlvbiBGZSh1LGUsdCxyLG4saSl7dmFyIGEsbD1lJnRoLHM9ZSZlaCxmPWUmcmg7aWYodCYmKGE9bj90KHUscixuLGkpOnQodSkpLGEhPT12b2lkIDApcmV0dXJuIGE7aWYoIVFmKHUpKXJldHVybiB1O3ZhciB2PVhmKHUpO2lmKHYpe2lmKGE9S2YodSksIWwpcmV0dXJuIEZmKHUsYSl9ZWxzZXt2YXIgZD1IZih1KSxwPWQ9PXVufHxkPT1haDtpZihaZih1KSlyZXR1cm4gV2YodSxsKTtpZihkPT1mbnx8ZD09Y258fHAmJiFuKXtpZihhPXN8fHA/e306WWYodSksIWwpcmV0dXJuIHM/JGYodSxqZihhLHUpKTpVZih1LEJmKGEsdSkpfWVsc2V7aWYoIXd0W2RdKXJldHVybiBuP3U6e307YT1WZih1LGQsbCl9fWl8fChpPW5ldyBEZik7dmFyIHk9aS5nZXQodSk7aWYoeSlyZXR1cm4geTtpLnNldCh1LGEpLGtmKHUpP3UuZm9yRWFjaChmdW5jdGlvbihtKXthLmFkZChGZShtLGUsdCxtLHUsaSkpfSk6SmYodSkmJnUuZm9yRWFjaChmdW5jdGlvbihtLE8pe2Euc2V0KE8sRmUobSxlLHQsTyx1LGkpKX0pO3ZhciBQPWY/cz9HZjp6ZjpzP19mOnFmLHg9dj92b2lkIDA6UCh1KTtyZXR1cm4gd2YoeHx8dSxmdW5jdGlvbihtLE8pe3gmJihPPW0sbT11W09dKSxOZihhLE8sRmUobSxlLHQsTyx1LGkpKX0pLGF9dmFyIEVoPUZlLEFoPUVoLENoPTEsUmg9NDtmdW5jdGlvbiBJaCh1KXtyZXR1cm4gQWgodSxDaHxSaCl9dmFyIExoPUloLFl0PWNlKExoKSxobjsoZnVuY3Rpb24odSl7dVt1LnBlZGRpbmc9MF09InBlZGRpbmciLHVbdS5tb3VudGVkPTFdPSJtb3VudGVkIix1W3UudXBkYXRlPTJdPSJ1cGRhdGUiLHVbdS51bm1vdW50ZWQ9M109InVubW91bnRlZCJ9KShobnx8KGhuPXt9KSk7dmFyIHp0OyhmdW5jdGlvbih1KXt1W3UuTm9ybWFsPTBdPSJOb3JtYWwiLHVbdS5TdHJva2U9MV09IlN0cm9rZSIsdVt1LkRvdHRlZD0yXT0iRG90dGVkIix1W3UuTG9uZ0RvdHRlZD0zXT0iTG9uZ0RvdHRlZCJ9KSh6dHx8KHp0PXt9KSk7dmFyIGRuOyhmdW5jdGlvbih1KXt1LlRyaWFuZ2xlPSJ0cmlhbmdsZSIsdS5SaG9tYnVzPSJyaG9tYnVzIix1LlBlbnRhZ3JhbT0icGVudGFncmFtIix1LlNwZWVjaEJhbGxvb249InNwZWVjaEJhbGxvb24iLHUuU3Rhcj0ic3RhciIsdS5Qb2x5Z29uPSJwb2x5Z29uIn0pKGRufHwoZG49e30pKTt2YXIgQ3Q7KGZ1bmN0aW9uKHUpe3UuTm9uZT0iTm9uZSIsdS5TaG93RmxvYXRCYXI9IlNob3dGbG9hdEJhciIsdS5aSW5kZXhGbG9hdEJhcj0iWkluZGV4RmxvYXRCYXIiLHUuRGVsZXRlTm9kZT0iRGVsZXRlTm9kZSIsdS5Db3B5Tm9kZT0iQ29weU5vZGUiLHUuWkluZGV4QWN0aXZlPSJaSW5kZXhBY3RpdmUiLHUuWkluZGV4Tm9kZT0iWkluZGV4Tm9kZSIsdS5Sb3RhdGVOb2RlPSJSb3RhdGVOb2RlIix1LlNldENvbG9yTm9kZT0iU2V0Q29sb3JOb2RlIix1LlRyYW5zbGF0ZU5vZGU9IlRyYW5zbGF0ZU5vZGUiLHUuU2NhbGVOb2RlPSJTY2FsZU5vZGUiLHUuT3JpZ2luYWxFdmVudD0iT3JpZ2luYWxFdmVudCIsdS5DcmVhdGVTY2VuZT0iQ3JlYXRlU2NlbmUiLHUuQWN0aXZlQ3Vyc29yPSJBY3RpdmVDdXJzb3IiLHUuTW92ZUN1cnNvcj0iTW92ZUN1cnNvciIsdS5Db21tYW5kRWRpdG9yPSJDb21tYW5kRWRpdG9yIix1LlNldEVkaXRvckRhdGE9IlNldEVkaXRvckRhdGEiLHUuU2V0Rm9udFN0eWxlPSJTZXRGb250U3R5bGUiLHUuU2V0UG9pbnQ9IlNldFBvaW50Iix1LlNldExvY2s9IlNldExvY2siLHUuU2V0U2hhcGVPcHQ9IlNldFNoYXBlT3B0In0pKEN0fHwoQ3Q9e30pKTt2YXIgZ247KGZ1bmN0aW9uKHUpe3UuRGlzcGxheVN0YXRlPSJEaXNwbGF5U3RhdGUiLHUuRmxvYXRCYXI9IkZsb2F0QmFyIix1LkNhbnZhc1NlbGVjdG9yPSJDYW52YXNTZWxlY3RvciIsdS5NYWluRW5naW5lPSJNYWluRW5naW5lIix1LkRpc3BsYXlDb250YWluZXI9IkRpc3BsYXlDb250YWluZXIiLHUuQ3Vyc29yPSJDdXJzb3IiLHUuVGV4dEVkaXRvcj0iVGV4dEVkaXRvciIsdS5CaW5kTWFpblZpZXc9IkJpbmRNYWluVmlldyIsdS5Nb3VudE1haW5WaWV3PSJNb3VudE1haW5WaWV3Iix1Lk1vdW50QXBwVmlldz0iTW91bnRBcHBWaWV3In0pKGdufHwoZ249e30pKTt2YXIgcG47KGZ1bmN0aW9uKHUpe3VbdS5NYWluVmlldz0wXT0iTWFpblZpZXciLHVbdS5QbHVnaW49MV09IlBsdWdpbiIsdVt1LkJvdGg9Ml09IkJvdGgifSkocG58fChwbj17fSkpO3ZhciBkdDsoZnVuY3Rpb24odSl7dVt1LlBlbmNpbD0xXT0iUGVuY2lsIix1W3UuRXJhc2VyPTJdPSJFcmFzZXIiLHVbdS5TZWxlY3Rvcj0zXT0iU2VsZWN0b3IiLHVbdS5DbGlja2VyPTRdPSJDbGlja2VyIix1W3UuQXJyb3c9NV09IkFycm93Iix1W3UuSGFuZD02XT0iSGFuZCIsdVt1Lkxhc2VyUGVuPTddPSJMYXNlclBlbiIsdVt1LlRleHQ9OF09IlRleHQiLHVbdS5TdHJhaWdodD05XT0iU3RyYWlnaHQiLHVbdS5SZWN0YW5nbGU9MTBdPSJSZWN0YW5nbGUiLHVbdS5FbGxpcHNlPTExXT0iRWxsaXBzZSIsdVt1LlN0YXI9MTJdPSJTdGFyIix1W3UuVHJpYW5nbGU9MTNdPSJUcmlhbmdsZSIsdVt1LlJob21idXM9MTRdPSJSaG9tYnVzIix1W3UuUG9seWdvbj0xNV09IlBvbHlnb24iLHVbdS5TcGVlY2hCYWxsb29uPTE2XT0iU3BlZWNoQmFsbG9vbiIsdVt1LkltYWdlPTE3XT0iSW1hZ2UifSkoZHR8fChkdD17fSkpO3ZhciBPdDsoZnVuY3Rpb24odSl7dVt1LkxvY2FsPTFdPSJMb2NhbCIsdVt1LlNlcnZpY2U9Ml09IlNlcnZpY2UiLHVbdS5Xb3JrZXI9M109IldvcmtlciJ9KShPdHx8KE90PXt9KSk7dmFyIFJ0OyhmdW5jdGlvbih1KXt1W3UuUGVuZGluZz0wXT0iUGVuZGluZyIsdVt1LlN0YXJ0PTFdPSJTdGFydCIsdVt1LkRvaW5nPTJdPSJEb2luZyIsdVt1LkRvbmU9M109IkRvbmUiLHVbdS5GcmVlemU9NF09IkZyZWV6ZSIsdVt1LlVud3JpdGFibGU9NV09IlVud3JpdGFibGUifSkoUnR8fChSdD17fSkpO3ZhciBhdDsoZnVuY3Rpb24odSl7dVt1Lk5vbmU9MF09Ik5vbmUiLHVbdS5Jbml0PTFdPSJJbml0Iix1W3UuVXBkYXRlQ2FtZXJhPTJdPSJVcGRhdGVDYW1lcmEiLHVbdS5VcGRhdGVUb29scz0zXT0iVXBkYXRlVG9vbHMiLHVbdS5DcmVhdGVXb3JrPTRdPSJDcmVhdGVXb3JrIix1W3UuRHJhd1dvcms9NV09IkRyYXdXb3JrIix1W3UuRnVsbFdvcms9Nl09IkZ1bGxXb3JrIix1W3UuVXBkYXRlTm9kZT03XT0iVXBkYXRlTm9kZSIsdVt1LlJlbW92ZU5vZGU9OF09IlJlbW92ZU5vZGUiLHVbdS5DbGVhcj05XT0iQ2xlYXIiLHVbdS5TZWxlY3Q9MTBdPSJTZWxlY3QiLHVbdS5EZXN0cm95PTExXT0iRGVzdHJveSIsdVt1LlNuYXBzaG90PTEyXT0iU25hcHNob3QiLHVbdS5Cb3VuZGluZ0JveD0xM109IkJvdW5kaW5nQm94Iix1W3UuQ3Vyc29yPTE0XT0iQ3Vyc29yIix1W3UuVGV4dFVwZGF0ZT0xNV09IlRleHRVcGRhdGUiLHVbdS5HZXRUZXh0QWN0aXZlPTE2XT0iR2V0VGV4dEFjdGl2ZSIsdVt1LlRhc2tzUXVldWU9MTddPSJUYXNrc1F1ZXVlIix1W3UuQ3Vyc29ySG92ZXI9MThdPSJDdXJzb3JIb3ZlciJ9KShhdHx8KGF0PXt9KSk7dmFyIG1uOyhmdW5jdGlvbih1KXt1LldlYmdsMj0id2ViZ2wyIix1LldlYmdsPSJ3ZWJnbCIsdS5DYW52YXMyZD0iMmQifSkobW58fChtbj17fSkpO3ZhciB5dDsoZnVuY3Rpb24odSl7dVt1LkZsb2F0PTFdPSJGbG9hdCIsdVt1LkJnPTJdPSJCZyIsdVt1LlNlbGVjdG9yPTNdPSJTZWxlY3RvciIsdVt1Lk5vbmU9NF09Ik5vbmUifSkoeXR8fCh5dD17fSkpO3ZhciB2bjsoZnVuY3Rpb24odSl7dVt1LkN1cnNvcj0xXT0iQ3Vyc29yIix1W3UuVGV4dENyZWF0ZT0yXT0iVGV4dENyZWF0ZSJ9KSh2bnx8KHZuPXt9KSk7dmFyIHluOyhmdW5jdGlvbih1KXt1W3UuVG9wPTFdPSJUb3AiLHVbdS5Cb3R0b209Ml09IkJvdHRvbSJ9KSh5bnx8KHluPXt9KSk7dmFyIGp0OyhmdW5jdGlvbih1KXt1W3Uubm9uZT0xXT0ibm9uZSIsdVt1LmFsbD0yXT0iYWxsIix1W3UuYm90aD0zXT0iYm90aCIsdVt1LnByb3BvcnRpb25hbD00XT0icHJvcG9ydGlvbmFsIn0pKGp0fHwoanQ9e30pKTtjbGFzcyBYdHtjb25zdHJ1Y3Rvcigpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsb2NhbFdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VydmljZVdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NlbmUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KX1yZWdpc3RlckZvcldvcmtlcihlLHQscil7cmV0dXJuIHRoaXMubG9jYWxXb3JrPWUsdGhpcy5zZXJ2aWNlV29yaz10LHRoaXMuc2NlbmU9cix0aGlzfX1jb25zdCBEaD17bGluZWFyOnU9PnUsZWFzZUluUXVhZDp1PT51KnUsZWFzZU91dFF1YWQ6dT0+dSooMi11KSxlYXNlSW5PdXRRdWFkOnU9PnU8LjU/Mip1KnU6LTErKDQtMip1KSp1LGVhc2VJbkN1YmljOnU9PnUqdSp1LGVhc2VPdXRDdWJpYzp1PT4tLXUqdSp1KzEsZWFzZUluT3V0Q3ViaWM6dT0+dTwuNT80KnUqdSp1Oih1LTEpKigyKnUtMikqKDIqdS0yKSsxLGVhc2VJblF1YXJ0OnU9PnUqdSp1KnUsZWFzZU91dFF1YXJ0OnU9PjEtIC0tdSp1KnUqdSxlYXNlSW5PdXRRdWFydDp1PT51PC41PzgqdSp1KnUqdToxLTgqLS11KnUqdSp1LGVhc2VJblF1aW50OnU9PnUqdSp1KnUqdSxlYXNlT3V0UXVpbnQ6dT0+MSstLXUqdSp1KnUqdSxlYXNlSW5PdXRRdWludDp1PT51PC41PzE2KnUqdSp1KnUqdToxKzE2Ki0tdSp1KnUqdSp1LGVhc2VJblNpbmU6dT0+MS1NYXRoLmNvcyh1Kk1hdGguUEkvMiksZWFzZU91dFNpbmU6dT0+TWF0aC5zaW4odSpNYXRoLlBJLzIpLGVhc2VJbk91dFNpbmU6dT0+LShNYXRoLmNvcyhNYXRoLlBJKnUpLTEpLzIsZWFzZUluRXhwbzp1PT51PD0wPzA6TWF0aC5wb3coMiwxMCp1LTEwKSxlYXNlT3V0RXhwbzp1PT51Pj0xPzE6MS1NYXRoLnBvdygyLC0xMCp1KSxlYXNlSW5PdXRFeHBvOnU9PnU8PTA/MDp1Pj0xPzE6dTwuNT9NYXRoLnBvdygyLDIwKnUtMTApLzI6KDItTWF0aC5wb3coMiwtMjAqdSsxMCkpLzJ9O2NsYXNzIGV0e2NvbnN0cnVjdG9yKGU9MCx0PTAscj0xKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnJ9KX1nZXQgWFkoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0eihlKXtyZXR1cm4gdGhpcy56PWUsdGhpc31zZXRYWShlPXRoaXMueCx0PXRoaXMueSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXN9c2V0KGU9dGhpcy54LHQ9dGhpcy55LHI9dGhpcy56KXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PXIsdGhpc31zZXRUbyh7eDplPTAseTp0PTAsejpyPTF9KXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PXIsdGhpc31yb3QoZSl7aWYoZT09PTApcmV0dXJuIHRoaXM7Y29uc3R7eDp0LHk6cn09dGhpcyxuPU1hdGguc2luKGUpLGk9TWF0aC5jb3MoZSk7cmV0dXJuIHRoaXMueD10KmktcipuLHRoaXMueT10Km4rcippLHRoaXN9cm90V2l0aChlLHQpe2lmKHQ9PT0wKXJldHVybiB0aGlzO2NvbnN0IHI9dGhpcy54LWUueCxuPXRoaXMueS1lLnksaT1NYXRoLnNpbih0KSxhPU1hdGguY29zKHQpO3JldHVybiB0aGlzLng9ZS54KyhyKmEtbippKSx0aGlzLnk9ZS55KyhyKmkrbiphKSx0aGlzfWNsb25lKCl7Y29uc3R7eDplLHk6dCx6OnJ9PXRoaXM7cmV0dXJuIG5ldyBldChlLHQscil9c3ViKGUpe3JldHVybiB0aGlzLngtPWUueCx0aGlzLnktPWUueSx0aGlzfXN1YlhZKGUsdCl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPXQsdGhpc31zdWJTY2FsYXIoZSl7cmV0dXJuIHRoaXMueC09ZSx0aGlzLnktPWUsdGhpc31hZGQoZSl7cmV0dXJuIHRoaXMueCs9ZS54LHRoaXMueSs9ZS55LHRoaXN9YWRkWFkoZSx0KXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9dCx0aGlzfWFkZFNjYWxhcihlKXtyZXR1cm4gdGhpcy54Kz1lLHRoaXMueSs9ZSx0aGlzfWNsYW1wKGUsdCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsZSksdGhpcy55PU1hdGgubWF4KHRoaXMueSxlKSx0IT09dm9pZCAwJiYodGhpcy54PU1hdGgubWluKHRoaXMueCx0KSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQpKSx0aGlzfWRpdihlKXtyZXR1cm4gdGhpcy54Lz1lLHRoaXMueS89ZSx0aGlzfWRpdlYoZSl7cmV0dXJuIHRoaXMueC89ZS54LHRoaXMueS89ZS55LHRoaXN9bXVsKGUpe3JldHVybiB0aGlzLngqPWUsdGhpcy55Kj1lLHRoaXN9bXVsVihlKXtyZXR1cm4gdGhpcy54Kj1lLngsdGhpcy55Kj1lLnksdGhpc31hYnMoKXtyZXR1cm4gdGhpcy54PU1hdGguYWJzKHRoaXMueCksdGhpcy55PU1hdGguYWJzKHRoaXMueSksdGhpc31udWRnZShlLHQpe2NvbnN0IHI9ZXQuVGFuKGUsdGhpcyk7cmV0dXJuIHRoaXMuYWRkKHIubXVsKHQpKX1uZWcoKXtyZXR1cm4gdGhpcy54Kj0tMSx0aGlzLnkqPS0xLHRoaXN9Y3Jvc3MoZSl7cmV0dXJuIHRoaXMueD10aGlzLnkqZS56LXRoaXMueiplLnksdGhpcy55PXRoaXMueiplLngtdGhpcy54KmUueix0aGlzfWRwcihlKXtyZXR1cm4gZXQuRHByKHRoaXMsZSl9Y3ByKGUpe3JldHVybiBldC5DcHIodGhpcyxlKX1sZW4yKCl7cmV0dXJuIGV0LkxlbjIodGhpcyl9bGVuKCl7cmV0dXJuIGV0Lkxlbih0aGlzKX1wcnkoZSl7cmV0dXJuIGV0LlByeSh0aGlzLGUpfXBlcigpe2NvbnN0e3g6ZSx5OnR9PXRoaXM7cmV0dXJuIHRoaXMueD10LHRoaXMueT0tZSx0aGlzfXVuaSgpe3JldHVybiBldC5VbmkodGhpcyl9dGFuKGUpe3JldHVybiBldC5UYW4odGhpcyxlKX1kaXN0KGUpe3JldHVybiBldC5EaXN0KHRoaXMsZSl9ZGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCl7cmV0dXJuIGV0LkRpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQsdGhpcyl9c2xvcGUoZSl7cmV0dXJuIGV0LlNsb3BlKHRoaXMsZSl9c25hcFRvR3JpZChlKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54L2UpKmUsdGhpcy55PU1hdGgucm91bmQodGhpcy55L2UpKmUsdGhpc31hbmdsZShlKXtyZXR1cm4gZXQuQW5nbGUodGhpcyxlKX10b0FuZ2xlKCl7cmV0dXJuIGV0LlRvQW5nbGUodGhpcyl9bHJwKGUsdCl7cmV0dXJuIHRoaXMueD10aGlzLngrKGUueC10aGlzLngpKnQsdGhpcy55PXRoaXMueSsoZS55LXRoaXMueSkqdCx0aGlzfWVxdWFscyhlLHQpe3JldHVybiBldC5FcXVhbHModGhpcyxlLHQpfWVxdWFsc1hZKGUsdCl7cmV0dXJuIGV0LkVxdWFsc1hZKHRoaXMsZSx0KX1ub3JtKCl7Y29uc3QgZT10aGlzLmxlbigpO3JldHVybiB0aGlzLng9ZT09PTA/MDp0aGlzLngvZSx0aGlzLnk9ZT09PTA/MDp0aGlzLnkvZSx0aGlzfXRvRml4ZWQoKXtyZXR1cm4gZXQuVG9GaXhlZCh0aGlzKX10b1N0cmluZygpe3JldHVybiBldC5Ub1N0cmluZyhldC5Ub0ZpeGVkKHRoaXMpKX10b0pzb24oKXtyZXR1cm4gZXQuVG9Kc29uKHRoaXMpfXRvQXJyYXkoKXtyZXR1cm4gZXQuVG9BcnJheSh0aGlzKX1zdGF0aWMgQWRkKGUsdCl7cmV0dXJuIG5ldyBldChlLngrdC54LGUueSt0LnkpfXN0YXRpYyBBZGRYWShlLHQscil7cmV0dXJuIG5ldyBldChlLngrdCxlLnkrcil9c3RhdGljIFN1YihlLHQpe3JldHVybiBuZXcgZXQoZS54LXQueCxlLnktdC55KX1zdGF0aWMgU3ViWFkoZSx0LHIpe3JldHVybiBuZXcgZXQoZS54LXQsZS55LXIpfXN0YXRpYyBBZGRTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IGV0KGUueCt0LGUueSt0KX1zdGF0aWMgU3ViU2NhbGFyKGUsdCl7cmV0dXJuIG5ldyBldChlLngtdCxlLnktdCl9c3RhdGljIERpdihlLHQpe3JldHVybiBuZXcgZXQoZS54L3QsZS55L3QpfXN0YXRpYyBNdWwoZSx0KXtyZXR1cm4gbmV3IGV0KGUueCp0LGUueSp0KX1zdGF0aWMgRGl2VihlLHQpe3JldHVybiBuZXcgZXQoZS54L3QueCxlLnkvdC55KX1zdGF0aWMgTXVsVihlLHQpe3JldHVybiBuZXcgZXQoZS54KnQueCxlLnkqdC55KX1zdGF0aWMgTmVnKGUpe3JldHVybiBuZXcgZXQoLWUueCwtZS55KX1zdGF0aWMgUGVyKGUpe3JldHVybiBuZXcgZXQoZS55LC1lLngpfXN0YXRpYyBEaXN0MihlLHQpe3JldHVybiBldC5TdWIoZSx0KS5sZW4yKCl9c3RhdGljIEFicyhlKXtyZXR1cm4gbmV3IGV0KE1hdGguYWJzKGUueCksTWF0aC5hYnMoZS55KSl9c3RhdGljIERpc3QoZSx0KXtyZXR1cm4gTWF0aC5oeXBvdChlLnktdC55LGUueC10LngpfXN0YXRpYyBEcHIoZSx0KXtyZXR1cm4gZS54KnQueCtlLnkqdC55fXN0YXRpYyBDcm9zcyhlLHQpe3JldHVybiBuZXcgZXQoZS55KnQuei1lLnoqdC55LGUueip0LngtZS54KnQueil9c3RhdGljIENwcihlLHQpe3JldHVybiBlLngqdC55LXQueCplLnl9c3RhdGljIExlbjIoZSl7cmV0dXJuIGUueCplLngrZS55KmUueX1zdGF0aWMgTGVuKGUpe3JldHVybiBNYXRoLmh5cG90KGUueCxlLnkpfXN0YXRpYyBQcnkoZSx0KXtyZXR1cm4gZXQuRHByKGUsdCkvZXQuTGVuKHQpfXN0YXRpYyBVbmkoZSl7cmV0dXJuIGV0LkRpdihlLGV0LkxlbihlKSl9c3RhdGljIFRhbihlLHQpe3JldHVybiBldC5VbmkoZXQuU3ViKGUsdCkpfXN0YXRpYyBNaW4oZSx0KXtyZXR1cm4gbmV3IGV0KE1hdGgubWluKGUueCx0LngpLE1hdGgubWluKGUueSx0LnkpKX1zdGF0aWMgTWF4KGUsdCl7cmV0dXJuIG5ldyBldChNYXRoLm1heChlLngsdC54KSxNYXRoLm1heChlLnksdC55KSl9c3RhdGljIEZyb20oZSl7cmV0dXJuIG5ldyBldCgpLmFkZChlKX1zdGF0aWMgRnJvbUFycmF5KGUpe3JldHVybiBuZXcgZXQoZVswXSxlWzFdKX1zdGF0aWMgUm90KGUsdD0wKXtjb25zdCByPU1hdGguc2luKHQpLG49TWF0aC5jb3ModCk7cmV0dXJuIG5ldyBldChlLngqbi1lLnkqcixlLngqcitlLnkqbil9c3RhdGljIFJvdFdpdGgoZSx0LHIpe2NvbnN0IG49ZS54LXQueCxpPWUueS10LnksYT1NYXRoLnNpbihyKSxsPU1hdGguY29zKHIpO3JldHVybiBuZXcgZXQodC54KyhuKmwtaSphKSx0LnkrKG4qYStpKmwpKX1zdGF0aWMgTmVhcmVzdFBvaW50T25MaW5lVGhyb3VnaFBvaW50KGUsdCxyKXtyZXR1cm4gZXQuTXVsKHQsZXQuU3ViKHIsZSkucHJ5KHQpKS5hZGQoZSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoZSx0LHIsbj0hMCl7Y29uc3QgaT1ldC5UYW4odCxlKSxhPWV0LkFkZChlLGV0Lk11bChpLGV0LlN1YihyLGUpLnByeShpKSkpO2lmKG4pe2lmKGEueDxNYXRoLm1pbihlLngsdC54KSlyZXR1cm4gZXQuQ2FzdChlLng8dC54P2U6dCk7aWYoYS54Pk1hdGgubWF4KGUueCx0LngpKXJldHVybiBldC5DYXN0KGUueD50Lng/ZTp0KTtpZihhLnk8TWF0aC5taW4oZS55LHQueSkpcmV0dXJuIGV0LkNhc3QoZS55PHQueT9lOnQpO2lmKGEueT5NYXRoLm1heChlLnksdC55KSlyZXR1cm4gZXQuQ2FzdChlLnk+dC55P2U6dCl9cmV0dXJuIGF9c3RhdGljIERpc3RhbmNlVG9MaW5lVGhyb3VnaFBvaW50KGUsdCxyKXtyZXR1cm4gZXQuRGlzdChyLGV0Lk5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQscikpfXN0YXRpYyBEaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0LHIsbj0hMCl7cmV0dXJuIGV0LkRpc3QocixldC5OZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGUsdCxyLG4pKX1zdGF0aWMgU25hcChlLHQ9MSl7cmV0dXJuIG5ldyBldChNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfXN0YXRpYyBDYXN0KGUpe3JldHVybiBlIGluc3RhbmNlb2YgZXQ/ZTpldC5Gcm9tKGUpfXN0YXRpYyBTbG9wZShlLHQpe3JldHVybiBlLng9PT10Lnk/TmFOOihlLnktdC55KS8oZS54LXQueCl9c3RhdGljIEFuZ2xlKGUsdCl7cmV0dXJuIE1hdGguYXRhbjIodC55LWUueSx0LngtZS54KX1zdGF0aWMgTHJwKGUsdCxyKXtyZXR1cm4gZXQuU3ViKHQsZSkubXVsKHIpLmFkZChlKX1zdGF0aWMgTWVkKGUsdCl7cmV0dXJuIG5ldyBldCgoZS54K3QueCkvMiwoZS55K3QueSkvMil9c3RhdGljIEVxdWFscyhlLHQscj0xZS00KXtyZXR1cm4gTWF0aC5hYnMoZS54LXQueCk8ciYmTWF0aC5hYnMoZS55LXQueSk8cn1zdGF0aWMgRXF1YWxzWFkoZSx0LHIpe3JldHVybiBlLng9PT10JiZlLnk9PT1yfXN0YXRpYyBFcXVhbHNYWVooZSx0LHI9MWUtNCl7cmV0dXJuIGV0LkVxdWFscyhlLHQscikmJk1hdGguYWJzKChlLnp8fDApLSh0Lnp8fDApKTxyfXN0YXRpYyBDbG9ja3dpc2UoZSx0LHIpe3JldHVybihyLngtZS54KSoodC55LWUueSktKHQueC1lLngpKihyLnktZS55KTwwfXN0YXRpYyBSZXNjYWxlKGUsdCl7Y29uc3Qgcj1ldC5MZW4oZSk7cmV0dXJuIG5ldyBldCh0KmUueC9yLHQqZS55L3IpfXN0YXRpYyBTY2FsZVdpdGhPcmlnaW4oZSx0LHIpe3JldHVybiBldC5TdWIoZSxyKS5tdWwodCkuYWRkKHIpfXN0YXRpYyBTY2FsZVdPcmlnaW4oZSx0LHIpe3JldHVybiBldC5TdWIoZSxyKS5tdWxWKHQpLmFkZChyKX1zdGF0aWMgVG9GaXhlZChlLHQ9Mil7cmV0dXJuIG5ldyBldCgrZS54LnRvRml4ZWQodCksK2UueS50b0ZpeGVkKHQpLCtlLnoudG9GaXhlZCh0KSl9c3RhdGljIE51ZGdlKGUsdCxyKXtyZXR1cm4gZXQuQWRkKGUsZXQuVGFuKHQsZSkubXVsKHIpKX1zdGF0aWMgVG9TdHJpbmcoZSl7cmV0dXJuYCR7ZS54fSwgJHtlLnl9YH1zdGF0aWMgVG9BbmdsZShlKXtsZXQgdD1NYXRoLmF0YW4yKGUueSxlLngpO3JldHVybiB0PDAmJih0Kz1NYXRoLlBJKjIpLHR9c3RhdGljIEZyb21BbmdsZShlLHQ9MSl7cmV0dXJuIG5ldyBldChNYXRoLmNvcyhlKSp0LE1hdGguc2luKGUpKnQpfXN0YXRpYyBUb0FycmF5KGUpe3JldHVybltlLngsZS55LGUuel19c3RhdGljIFRvSnNvbihlKXtjb25zdHt4OnQseTpyLHo6bn09ZTtyZXR1cm57eDp0LHk6cix6Om59fXN0YXRpYyBBdmVyYWdlKGUpe2NvbnN0IHQ9ZS5sZW5ndGgscj1uZXcgZXQoMCwwKTtmb3IobGV0IG49MDtuPHQ7bisrKXIuYWRkKGVbbl0pO3JldHVybiByLmRpdih0KX1zdGF0aWMgQ2xhbXAoZSx0LHIpe3JldHVybiByPT09dm9pZCAwP25ldyBldChNYXRoLm1pbihNYXRoLm1heChlLngsdCkpLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSkpOm5ldyBldChNYXRoLm1pbihNYXRoLm1heChlLngsdCksciksTWF0aC5taW4oTWF0aC5tYXgoZS55LHQpLHIpKX1zdGF0aWMgUG9pbnRzQmV0d2VlbihlLHQscj02KXtjb25zdCBuPVtdO2ZvcihsZXQgaT0wO2k8cjtpKyspe2NvbnN0IGE9RGguZWFzZUluUXVhZChpLyhyLTEpKSxsPWV0LkxycChlLHQsYSk7bC56PU1hdGgubWluKDEsLjUrTWF0aC5hYnMoLjUtd2goYSkpKi42NSksbi5wdXNoKGwpfXJldHVybiBufXN0YXRpYyBTbmFwVG9HcmlkKGUsdD04KXtyZXR1cm4gbmV3IGV0KE1hdGgucm91bmQoZS54L3QpKnQsTWF0aC5yb3VuZChlLnkvdCkqdCl9fWNvbnN0IHdoPXU9PnU8LjU/Mip1KnU6LTErKDQtMip1KSp1O2NsYXNzIHh0IGV4dGVuZHMgZXR7Y29uc3RydWN0b3IoZT0wLHQ9MCxyPTAsbj17eDowLHk6MH0saT0wLGE9MCl7c3VwZXIoZSx0LHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6cn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6aX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6YX0pfWdldCB0aW1lc3RhbXAoKXtyZXR1cm4gdGhpcy50fWdldCBwcmVzc3VyZSgpe3JldHVybiB0aGlzLnp9Z2V0IGFuZ2xlTnVtKCl7cmV0dXJuIHRoaXMuYX1nZXQgWFkoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0QShlKXt0aGlzLmE9ZX1zZXRUKGUpe3RoaXMudD1lfXNldHYoZSl7cmV0dXJuIHRoaXMudj17eDplLngseTplLnl9LHRoaXN9c2V0KGU9dGhpcy54LHQ9dGhpcy55LHI9dGhpcy56LG49dGhpcy52LGk9dGhpcy50LGE9dGhpcy5hKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PXIsdGhpcy52PW4sdGhpcy50PWksdGhpcy5hPWEsdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejpyLHY6bix0OmksYX09dGhpcyxsPXt4Om4ueCx5Om4ueX07cmV0dXJuIG5ldyB4dChlLHQscixsLGksYSl9ZGlzdGFuY2UoZSl7cmV0dXJuIHh0LkdldERpc3RhbmNlKHRoaXMsZSl9aXNOZWFyKGUsdCl7cmV0dXJuIHh0LklzTmVhcih0aGlzLGUsdCl9Z2V0QW5nbGVCeVBvaW50cyhlLHQpe3JldHVybiB4dC5HZXRBbmdsZUJ5UG9pbnRzKGUsdGhpcyx0KX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyB4dChlLngtdC54LGUueS10LnkpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IHh0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEdldERpc3RhbmNlKGUsdCl7cmV0dXJuIHh0LkxlbihlLmNsb25lKCkuc3ViKHQpKX1zdGF0aWMgR2V0QW5nbGVCeVBvaW50cyhlLHQscil7Y29uc3Qgbj10LngtZS54LGk9ci54LXQueCxhPXQueS1lLnksbD1yLnktdC55O2xldCBzPTA7Y29uc3QgZj1NYXRoLnNxcnQobipuK2EqYSksdj1NYXRoLnNxcnQoaSppK2wqbCk7aWYoZiYmdil7Y29uc3QgZD1uKmkrYSpsO3M9TWF0aC5hY29zKGQvKGYqdikpLHM9cy9NYXRoLlBJKjE4MDtsZXQgcD1uKmwtYSppO3A9cD4wPzE6LTEscz0xODArcCpzfXJldHVybiBzfXN0YXRpYyBJc05lYXIoZSx0LHIpe3JldHVybiB4dC5MZW4oZS5jbG9uZSgpLnN1Yih0KSk8cn1zdGF0aWMgUm90V2l0aChlLHQscixuPTIpe2NvbnN0IGk9ZS54LXQueCxhPWUueS10LnksbD1NYXRoLnNpbihyKSxzPU1hdGguY29zKHIpLGY9TWF0aC5wb3coMTAsbiksdj1NYXRoLmZsb29yKCh0LngrKGkqcy1hKmwpKSpmKS9mLGQ9TWF0aC5mbG9vcigodC55KyhpKmwrYSpzKSkqZikvZjtyZXR1cm4gbmV3IHh0KHYsZCl9c3RhdGljIEdldERvdFN0cm9rZShlLHQscj0xNil7Y29uc3Qgbj1uZXcgZXQoMSwxKSxpPU1hdGguUEkrLjAwMSxhPXh0LkFkZChlLHh0LlN1YihlLG4pLnVuaSgpLnBlcigpLm11bCgtdCkpLGw9W107Zm9yKGxldCBzPTEvcixmPXM7Zjw9MTtmKz1zKWwucHVzaCh4dC5Sb3RXaXRoKGEsZSxpKjIqZikpO3JldHVybiBsfXN0YXRpYyBHZXRTZW1pY2lyY2xlU3Ryb2tlKGUsdCxyPS0xLG49OCl7Y29uc3QgaT1yKihNYXRoLlBJKy4wMDEpLGE9W107Zm9yKGxldCBsPTEvbixzPWw7czw9MTtzKz1sKWEucHVzaCh4dC5Sb3RXaXRoKHQsZSxpKnMpKTtyZXR1cm4gYX19ZnVuY3Rpb24gYnQodSxlKXtpZih1JiZlKXtjb25zdCB0PU1hdGgubWluKHUueCxlLngpLHI9TWF0aC5taW4odS55LGUueSksbj1NYXRoLm1heCh1LngrdS53LGUueCtlLncpLGk9TWF0aC5tYXgodS55K3UuaCxlLnkrZS5oKSxhPW4tdCxsPWktcjtyZXR1cm57eDp0LHk6cix3OmEsaDpsfX1yZXR1cm4gZXx8dX1mdW5jdGlvbiBOdCh1LGU9MCl7Y29uc3QgdD17eDowLHk6MCx3OjAsaDowfTtsZXQgcj0xLzAsbj0xLzAsaT0tMS8wLGE9LTEvMDtyZXR1cm4gdS5mb3JFYWNoKGw9Pntjb25zdFtzLGZdPWwuWFk7cj1NYXRoLm1pbihyLHMtZSksbj1NYXRoLm1pbihuLGYtZSksaT1NYXRoLm1heChpLHMrZSksYT1NYXRoLm1heChhLGYrZSl9KSx0Lng9cix0Lnk9bix0Lnc9aS1yLHQuaD1hLW4sdH1mdW5jdGlvbiB4ZSh1LGUpe3JldHVybiEodS54K3UudzxlLnh8fHUueD5lLngrZS53fHx1LnkrdS5oPGUueXx8dS55PmUueStlLmgpfWZ1bmN0aW9uIE5oKHUsZSl7cmV0dXJuIHUubGVuZ3RoPT09ZS5sZW5ndGgmJnUuc29ydCgpLnRvU3RyaW5nKCk9PT1lLnNvcnQoKS50b1N0cmluZygpfWZ1bmN0aW9uIFZ0KHUsZT0xMCl7cmV0dXJue3g6TWF0aC5mbG9vcih1LngtZSkseTpNYXRoLmZsb29yKHUueS1lKSx3Ok1hdGguZmxvb3IodS53K2UqMiksaDpNYXRoLmZsb29yKHUuaCtlKjIpfX1mdW5jdGlvbiBPZSh1LGUpe3JldHVybnt4OnUueCtlWzBdLHk6dS55K2VbMV0sdzp1LncsaDp1Lmh9fWZ1bmN0aW9uIFNuKHUsZSl7Y29uc3QgdD1uZXcgZXQodS54LHUueSkscj1uZXcgZXQodS54K3Uudyx1LnkpLG49bmV3IGV0KHUueCt1LncsdS55K3UuaCksaT1uZXcgZXQodS54LHUueSt1LmgpLGE9bmV3IGV0KHUueCt1LncvMix1LnkrdS5oLzIpLGw9TWF0aC5QSSplLzE4MCxzPWV0LlJvdFdpdGgodCxhLGwpLGY9ZXQuUm90V2l0aChyLGEsbCksdj1ldC5Sb3RXaXRoKG4sYSxsKSxkPWV0LlJvdFdpdGgoaSxhLGwpO3JldHVybiBOdChbcyxmLHYsZF0pfWZ1bmN0aW9uIHhuKHUsZSl7Y29uc3QgdD1uZXcgZXQodS54LHUueSkscj1uZXcgZXQodS54K3Uudyx1LnkpLG49bmV3IGV0KHUueCt1LncsdS55K3UuaCksaT1uZXcgZXQodS54LHUueSt1LmgpLGE9bmV3IGV0KHUueCt1LncvMix1LnkrdS5oLzIpLGw9bmV3IGV0KGVbMF0sZVsxXSkscz1ldC5TY2FsZVdPcmlnaW4odCxsLGEpLGY9ZXQuU2NhbGVXT3JpZ2luKHIsbCxhKSx2PWV0LlNjYWxlV09yaWdpbihuLGwsYSksZD1ldC5TY2FsZVdPcmlnaW4oaSxsLGEpO3JldHVybiBOdChbcyxmLHYsZF0pfWZ1bmN0aW9uIEJoKHUsZSx0KXtjb25zdCByPW5ldyBldChlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248dS5sZW5ndGg7bis9Myl7Y29uc3QgaT1uZXcgZXQodVtuXSx1W24rMV0pLGE9TWF0aC5QSSp0LzE4MCxsPWV0LlJvdFdpdGgoaSxyLGEpO3Vbbl09bC54LHVbbisxXT1sLnl9fWZ1bmN0aW9uIGpoKHUsZSx0KXtjb25zdCByPW5ldyBldChlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248dS5sZW5ndGg7bis9Myl7Y29uc3QgaT1uZXcgZXQodVtuXSx1W24rMV0pLGE9bmV3IGV0KHRbMF0sdFsxXSk7aWYobjx1Lmxlbmd0aC0zKXtjb25zdCBzPW5ldyBldCh1W24rM10sdVtuKzRdKSxmPWV0LlRhbihzLGkpLnBlcigpLm11bCh1W24rMl0pLm11bFYoYSkubGVuKCk7dVtuKzJdPWZ9ZWxzZSBpZihuPT09dS5sZW5ndGgtMyl7Y29uc3Qgcz1uZXcgZXQodVtuLTNdLHVbbi0yXSksZj1ldC5UYW4oaSxzKS5wZXIoKS5tdWwodVtuKzJdKS5tdWxWKGEpLmxlbigpO3VbbisyXT1mfWNvbnN0IGw9ZXQuU2NhbGVXT3JpZ2luKGksYSxyKTt1W25dPWwueCx1W24rMV09bC55fX1mdW5jdGlvbiBXaCh1LGUpe3JldHVybiB1WzBdPj1lLngmJnVbMF08PWUueCtlLncmJnVbMV0+PWUueSYmdVsxXTw9ZS55K2UuaH1mdW5jdGlvbiBPbih1LGUpe2NvbnN0IHQ9dTw9ZT8xOnUvZSxyPWU8PXU/MTplL3U7cmV0dXJuW3Qscl19Y29uc3QgVWU9dT0+e2lmKHUudGFnTmFtZT09PSJHUk9VUCIpe2NvbnN0IGU9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh1KS5maW5kKHQ9PnQudG9TdHJpbmcoKT09PSJTeW1ib2woc2VhbGVkKSIpO2lmKGUmJnVbZV0pcmV0dXJuITB9cmV0dXJuITF9LGJuPXU9PnUhPT1kdC5UZXh0O2Z1bmN0aW9uIHBlKHUpe3JldHVybmAkeyRlKHUueCl9LCR7JGUodS55KX0gYH1mdW5jdGlvbiBtZSh1LGUpe3JldHVybmAkeyRlKCh1LngrZS54KS8yKX0sJHskZSgodS55K2UueSkvMil9IGB9ZnVuY3Rpb24gJGUodSl7cmV0dXJuK3UudG9GaXhlZCg0KX12YXIgRmg9aWUsVWg9X3QsJGg9IltvYmplY3QgTnVtYmVyXSI7ZnVuY3Rpb24gemgodSl7cmV0dXJuIHR5cGVvZiB1PT0ibnVtYmVyInx8VWgodSkmJkZoKHUpPT0kaH12YXIgR2g9emgsbmU9Y2UoR2gpO2NsYXNzIHB0e2NvbnN0cnVjdG9yKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVW5pdFRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxZTN9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSk7Y29uc3R7dk5vZGVzOnQsZnVsbExheWVyOnIsZHJhd0xheWVyOm59PWU7dGhpcy52Tm9kZXM9dCx0aGlzLmZ1bGxMYXllcj1yLHRoaXMuZHJhd0xheWVyPW59c2V0V29ya0lkKGUpe3RoaXMud29ya0lkPWV9Z2V0V29ya0lkKCl7cmV0dXJuIHRoaXMud29ya0lkfWdldFdvcmtPcHRpb25zKCl7cmV0dXJuIHRoaXMud29ya09wdGlvbnN9c2V0V29ya09wdGlvbnMoZSl7dmFyIG47dGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1VuaXRUaW1lPWUuc3luY1VuaXRUaW1lfHx0aGlzLnN5bmNVbml0VGltZTtjb25zdCB0PShuPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6bi50b1N0cmluZygpLHI9dCYmdGhpcy52Tm9kZXMuZ2V0KHQpfHx2b2lkIDA7dCYmciYmKHIub3B0PWUsdGhpcy52Tm9kZXMuc2V0SW5mbyh0LHIpKX11cGRhdGFPcHRTZXJ2aWNlKGUpe3ZhciBuO2xldCB0O2NvbnN0IHI9KG49dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCk7aWYociYmZSl7Y29uc3QgaT10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShyKXx8dGhpcy5kcmF3TGF5ZXImJnRoaXMuZHJhd0xheWVyLmdldEVsZW1lbnRzQnlOYW1lKHIpfHxbXTtpZihpLmxlbmd0aCE9PTEpcmV0dXJuO2NvbnN0IGE9aVswXSx7cG9zOmwsekluZGV4OnMsc2NhbGU6ZixhbmdsZTp2LHRyYW5zbGF0ZTpkfT1lLHA9e307bmUocykmJihwLnpJbmRleD1zKSxsJiYocC5wb3M9W2xbMF0sbFsxXV0pLGYmJihwLnNjYWxlPWYpLHYmJihwLnJvdGF0ZT12KSxkJiYocC50cmFuc2xhdGU9ZCksYS5hdHRyKHApO2NvbnN0IHk9YT09bnVsbD92b2lkIDA6YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4geSYmKHQ9YnQodCx7eDpNYXRoLmZsb29yKHkueC1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKHkueS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHkud2lkdGgrcHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKHkuaGVpZ2h0K3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfSkpLHRoaXMudk5vZGVzLnNldEluZm8ocix7cmVjdDp0LGNlbnRlclBvczpsfSksdH19c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpuLHdpbGxTZXJpYWxpemVEYXRhOmksdGFyZ2V0Tm9kZTphfT1lLHt6SW5kZXg6bCx0cmFuc2xhdGU6cyxhbmdsZTpmLGJveDp2LGJveFNjYWxlOmQsYm94VHJhbnNsYXRlOnAscG9pbnRNYXA6eX09cjtsZXQgUDtjb25zdCB4PWEmJll0KGEpfHxuLmdldCh0Lm5hbWUpO2lmKCF4KXJldHVybjtuZShsKSYmKHQuc2V0QXR0cmlidXRlKCJ6SW5kZXgiLGwpLHgub3B0LnpJbmRleD1sKTtjb25zdCBtPXQucGFyZW50O2lmKG0pe2lmKHYmJnAmJmQpe2NvbnN0e3JlY3Q6T309eCxvPVtdO2ZvcihsZXQgST0wO0k8eC5vcC5sZW5ndGg7SSs9MylvLnB1c2gobmV3IHh0KHgub3BbSV0seC5vcFtJKzFdLHgub3BbSSsyXSkpO2NvbnN0IGg9TnQobyksYz1baC53Km0ud29ybGRTY2FsaW5nWzBdLGguaCptLndvcmxkU2NhbGluZ1swXV0sZz1bTy53LWNbMF0sTy5oLWNbMV1dLGI9WyhPLncqZFswXS1nWzBdKS9jWzBdLChPLmgqZFsxXS1nWzFdKS9jWzFdXSxFPVtwWzBdL20ud29ybGRTY2FsaW5nWzBdLHBbMV0vbS53b3JsZFNjYWxpbmdbMV1dLEE9eC5vcC5tYXAoKEksRCk9Pntjb25zdCBSPUQlMztyZXR1cm4gUj09PTA/SStFWzBdOlI9PT0xP0krRVsxXTpJfSksTD1beC5jZW50ZXJQb3NbMF0rRVswXSx4LmNlbnRlclBvc1sxXStFWzFdXTtqaChBLEwsYik7Y29uc3QgTT1bXTtmb3IobGV0IEk9MDtJPEEubGVuZ3RoO0krPTMpTS5wdXNoKG5ldyB4dChBW0ldLEFbSSsxXSxBW0krMl0pKTt4Lm9wPUEseC5jZW50ZXJQb3M9TH1lbHNlIGlmKHMpe2NvbnN0IE89W3NbMF0vbS53b3JsZFNjYWxpbmdbMF0sc1sxXS9tLndvcmxkU2NhbGluZ1sxXV07dC5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsTykseC5vcHQudHJhbnNsYXRlPU8sYSYmKFA9T2UoeC5yZWN0LHMpLHgucmVjdD1QKX1lbHNlIG5lKGYpJiYodC5zZXRBdHRyaWJ1dGUoInJvdGF0ZSIsZikseC5vcHQucm90YXRlPWYsYSYmKFA9U24oeC5yZWN0LGYpLHgucmVjdD1QKSk7aWYoeSl7Y29uc3QgTz15LmdldCh0Lm5hbWUpO2lmKE8pZm9yKGxldCBvPTAsaD0wO288eC5vcC5sZW5ndGg7bys9MyxoKyspeC5vcFtvXT1PW2hdWzBdLHgub3BbbysxXT1PW2hdWzFdfWlmKGkpe2lmKHMpe2NvbnN0IE89W3NbMF0vbS53b3JsZFNjYWxpbmdbMF0sc1sxXS9tLndvcmxkU2NhbGluZ1sxXV0sbz14Lm9wLm1hcCgoaCxjKT0+e2NvbnN0IGc9YyUzO3JldHVybiBnPT09MD9oK09bMF06Zz09PTE/aCtPWzFdOmh9KTt4Lm9wPW8seC5jZW50ZXJQb3M9W3guY2VudGVyUG9zWzBdK09bMF0seC5jZW50ZXJQb3NbMV0rT1sxXV0seCE9bnVsbCYmeC5vcHQmJih4Lm9wdC50cmFuc2xhdGU9dm9pZCAwKX1lbHNlIGlmKG5lKGYpKXtjb25zdCBPPXgub3A7QmgoTyx4LmNlbnRlclBvcyxmKSx4Lm9wPU8seCE9bnVsbCYmeC5vcHQmJih4Lm9wdC5yb3RhdGU9dm9pZCAwKX19eCYmbi5zZXRJbmZvKHQubmFtZSx4KX19c3RhdGljIGdldENlbnRlclBvcyhlLHQpe2NvbnN0e3dvcmxkUG9zaXRpb246cix3b3JsZFNjYWxpbmc6bn09dDtyZXR1cm5bKGUueCtlLncvMi1yWzBdKS9uWzBdLChlLnkrZS5oLzItclsxXSkvblsxXV19c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCByPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYocil7Y29uc3Qgbj1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3Iobi54LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3Iobi55LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3Iobi53aWR0aCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3Iobi5oZWlnaHQrcHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHB0LCJTYWZlQm9yZGVyUGFkZGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSk7dmFyIER0PWZ1bmN0aW9uKHUpe3ZhciBlPXt9O2Z1bmN0aW9uIHQocil7aWYoZVtyXSlyZXR1cm4gZVtyXS5leHBvcnRzO3ZhciBuPWVbcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiB1W3JdLmNhbGwobi5leHBvcnRzLG4sbi5leHBvcnRzLHQpLG4ubD0hMCxuLmV4cG9ydHN9cmV0dXJuIHQubT11LHQuYz1lLHQuZD1mdW5jdGlvbihyLG4saSl7dC5vKHIsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLG4se2VudW1lcmFibGU6ITAsZ2V0Oml9KX0sdC5yPWZ1bmN0aW9uKHIpe3R5cGVvZiBTeW1ib2w8InUiJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkociwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LHQudD1mdW5jdGlvbihyLG4pe2lmKG4mMSYmKHI9dChyKSksbiY4fHxuJjQmJnR5cGVvZiByPT0ib2JqZWN0IiYmciYmci5fX2VzTW9kdWxlKXJldHVybiByO3ZhciBpPU9iamVjdC5jcmVhdGUobnVsbCk7aWYodC5yKGkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCx2YWx1ZTpyfSksbiYyJiZ0eXBlb2YgciE9InN0cmluZyIpZm9yKHZhciBhIGluIHIpdC5kKGksYSwoZnVuY3Rpb24obCl7cmV0dXJuIHJbbF19KS5iaW5kKG51bGwsYSkpO3JldHVybiBpfSx0Lm49ZnVuY3Rpb24ocil7dmFyIG49ciYmci5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gcn07cmV0dXJuIHQuZChuLCJhIixuKSxufSx0Lm89ZnVuY3Rpb24ocixuKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsbil9LHQucD0iL2pzLyIsdCh0LnM9MCl9KFtmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJ2ZXJzaW9uIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsImhlbHBlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiY3JlYXRlRWxlbWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJpc1Nwcml0ZU5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicmVnaXN0ZXJOb2RlIixmdW5jdGlvbigpe3JldHVybiBDfSk7dmFyIHI9dCgxMik7dC5kKGUsIkVOViIsZnVuY3Rpb24oKXtyZXR1cm4gci5FTlZ9KTt2YXIgbj10KDY4KTt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBuLnJlcXVlc3RBbmltYXRpb25GcmFtZX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gbi5jYW5jZWxBbmltYXRpb25GcmFtZX0pO3ZhciBpPXQoNzApO3QuZChlLCJOb2RlIixmdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHR9KTt2YXIgYT10KDIxNyk7dC5kKGUsIkNsb3VkIixmdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHR9KTt2YXIgbD10KDIxOSk7dC5kKGUsIkJsb2NrIixmdW5jdGlvbigpe3JldHVybiBsLmRlZmF1bHR9KTt2YXIgcz10KDIyNCk7dC5kKGUsIlNwcml0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0fSk7dmFyIGY9dCgyMjYpO3QuZChlLCJQYXRoIixmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9KTt2YXIgdj10KDIyOSk7dC5kKGUsIlJlY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHYuZGVmYXVsdH0pO3ZhciBkPXQoMjMxKTt0LmQoZSwiVHJpYW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVmYXVsdH0pO3ZhciBwPXQoMjM2KTt0LmQoZSwiUGFyYWxsZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHAuZGVmYXVsdH0pO3ZhciB5PXQoMjM4KTt0LmQoZSwiUmVndWxhciIsZnVuY3Rpb24oKXtyZXR1cm4geS5kZWZhdWx0fSk7dmFyIFA9dCgyNDApO3QuZChlLCJTdGFyIixmdW5jdGlvbigpe3JldHVybiBQLmRlZmF1bHR9KTt2YXIgeD10KDI0Mik7dC5kKGUsIkVsbGlwc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHguZGVmYXVsdH0pO3ZhciBtPXQoMjQ0KTt0LmQoZSwiQXJjIixmdW5jdGlvbigpe3JldHVybiBtLmRlZmF1bHR9KTt2YXIgTz10KDI0Nik7dC5kKGUsIlJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIE8uZGVmYXVsdH0pO3ZhciBvPXQoMjMyKTt0LmQoZSwiUG9seWxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG8uZGVmYXVsdH0pO3ZhciBoPXQoMjQ4KTt0LmQoZSwiTGFiZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGguZGVmYXVsdH0pO3ZhciBjPXQoMjUwKTt0LmQoZSwiR3JvdXAiLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pO3ZhciBnPXQoMjg2KTt0LmQoZSwiTGF5ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGcuZGVmYXVsdH0pO3ZhciBiPXQoMjg3KTt0LmQoZSwiU3ByaXRlU3ZnIixmdW5jdGlvbigpe3JldHVybiBiLmRlZmF1bHR9KTt2YXIgRT10KDI4OSk7dC5kKGUsIkxheWVyV29ya2VyIixmdW5jdGlvbigpe3JldHVybiBFLmRlZmF1bHR9KTt2YXIgQT10KDI5MCk7dC5kKGUsIlNjZW5lIixmdW5jdGlvbigpe3JldHVybiBBLmRlZmF1bHR9KTt2YXIgTD10KDIxMyksTT10KDIyMSk7dC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBNLkNvbG9yfSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBNLkdyYWRpZW50fSk7dmFyIEk9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEQ9TC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQsUj1MLmRlZmF1bHQuaXNTcHJpdGVOb2RlLEM9TC5kZWZhdWx0LnJlZ2lzdGVyTm9kZSxCPXtwYXJzZUNvbG9yOk0ucGFyc2VDb2xvcixzaXplVG9QaXhlbDpJLnNpemVUb1BpeGVsLHRvQXJyYXk6SS50b0FycmF5LHRvU3RyaW5nOkkudG9TdHJpbmcsdG9OdW1iZXI6SS50b051bWJlcn07bGV0IHo7ej0iMy44LjMiO2NvbnN0IEs9en0sZnVuY3Rpb24odSxlLHQpe3QucihlKTt2YXIgcj10KDIpO3QuZChlLCJnbE1hdHJpeCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pO3ZhciBuPXQoMyk7dC5kKGUsIm1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgaT10KDQpO3QuZChlLCJtYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBhPXQoNSk7dC5kKGUsIm1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTt2YXIgbD10KDYpO3QuZChlLCJtYXQ0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHM9dCg3KTt0LmQoZSwicXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciBmPXQoMTApO3QuZChlLCJxdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciB2PXQoMTEpO3QuZChlLCJ2ZWMyIixmdW5jdGlvbigpe3JldHVybiB2fSk7dmFyIGQ9dCg4KTt0LmQoZSwidmVjMyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBwPXQoOSk7dC5kKGUsInZlYzQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiRVBTSUxPTiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJBUlJBWV9UWVBFIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsIlJBTkRPTSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzZXRNYXRyaXhBcnJheVR5cGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwidG9SYWRpYW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9MWUtNixuPXR5cGVvZiBGbG9hdDMyQXJyYXk8InUiP0Zsb2F0MzJBcnJheTpBcnJheSxpPU1hdGgucmFuZG9tO2Z1bmN0aW9uIGEodil7bj12fXZhciBsPU1hdGguUEkvMTgwO2Z1bmN0aW9uIHModil7cmV0dXJuIHYqbH1mdW5jdGlvbiBmKHYsZCl7cmV0dXJuIE1hdGguYWJzKHYtZCk8PXIqTWF0aC5tYXgoMSxNYXRoLmFicyh2KSxNYXRoLmFicyhkKSl9TWF0aC5oeXBvdHx8KE1hdGguaHlwb3Q9ZnVuY3Rpb24oKXtmb3IodmFyIHY9MCxkPWFyZ3VtZW50cy5sZW5ndGg7ZC0tOyl2Kz1hcmd1bWVudHNbZF0qYXJndW1lbnRzW2RdO3JldHVybiBNYXRoLnNxcnQodil9KX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiTERVIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBDPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoQ1sxXT0wLENbMl09MCksQ1swXT0xLENbM109MSxDfWZ1bmN0aW9uIGkoQyl7dmFyIEI9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gQlswXT1DWzBdLEJbMV09Q1sxXSxCWzJdPUNbMl0sQlszXT1DWzNdLEJ9ZnVuY3Rpb24gYShDLEIpe3JldHVybiBDWzBdPUJbMF0sQ1sxXT1CWzFdLENbMl09QlsyXSxDWzNdPUJbM10sQ31mdW5jdGlvbiBsKEMpe3JldHVybiBDWzBdPTEsQ1sxXT0wLENbMl09MCxDWzNdPTEsQ31mdW5jdGlvbiBzKEMsQix6LEspe3ZhciBRPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIFFbMF09QyxRWzFdPUIsUVsyXT16LFFbM109SyxRfWZ1bmN0aW9uIGYoQyxCLHosSyxRKXtyZXR1cm4gQ1swXT1CLENbMV09eixDWzJdPUssQ1szXT1RLEN9ZnVuY3Rpb24gdihDLEIpe2lmKEM9PT1CKXt2YXIgej1CWzFdO0NbMV09QlsyXSxDWzJdPXp9ZWxzZSBDWzBdPUJbMF0sQ1sxXT1CWzJdLENbMl09QlsxXSxDWzNdPUJbM107cmV0dXJuIEN9ZnVuY3Rpb24gZChDLEIpe3ZhciB6PUJbMF0sSz1CWzFdLFE9QlsyXSxfPUJbM10sRj16Kl8tUSpLO3JldHVybiBGPyhGPTEvRixDWzBdPV8qRixDWzFdPS1LKkYsQ1syXT0tUSpGLENbM109eipGLEMpOm51bGx9ZnVuY3Rpb24gcChDLEIpe3ZhciB6PUJbMF07cmV0dXJuIENbMF09QlszXSxDWzFdPS1CWzFdLENbMl09LUJbMl0sQ1szXT16LEN9ZnVuY3Rpb24geShDKXtyZXR1cm4gQ1swXSpDWzNdLUNbMl0qQ1sxXX1mdW5jdGlvbiBQKEMsQix6KXt2YXIgSz1CWzBdLFE9QlsxXSxfPUJbMl0sRj1CWzNdLEc9elswXSxYPXpbMV0sWj16WzJdLHR0PXpbM107cmV0dXJuIENbMF09SypHK18qWCxDWzFdPVEqRytGKlgsQ1syXT1LKlorXyp0dCxDWzNdPVEqWitGKnR0LEN9ZnVuY3Rpb24geChDLEIseil7dmFyIEs9QlswXSxRPUJbMV0sXz1CWzJdLEY9QlszXSxHPU1hdGguc2luKHopLFg9TWF0aC5jb3Moeik7cmV0dXJuIENbMF09SypYK18qRyxDWzFdPVEqWCtGKkcsQ1syXT1LKi1HK18qWCxDWzNdPVEqLUcrRipYLEN9ZnVuY3Rpb24gbShDLEIseil7dmFyIEs9QlswXSxRPUJbMV0sXz1CWzJdLEY9QlszXSxHPXpbMF0sWD16WzFdO3JldHVybiBDWzBdPUsqRyxDWzFdPVEqRyxDWzJdPV8qWCxDWzNdPUYqWCxDfWZ1bmN0aW9uIE8oQyxCKXt2YXIgej1NYXRoLnNpbihCKSxLPU1hdGguY29zKEIpO3JldHVybiBDWzBdPUssQ1sxXT16LENbMl09LXosQ1szXT1LLEN9ZnVuY3Rpb24gbyhDLEIpe3JldHVybiBDWzBdPUJbMF0sQ1sxXT0wLENbMl09MCxDWzNdPUJbMV0sQ31mdW5jdGlvbiBoKEMpe3JldHVybiJtYXQyKCIrQ1swXSsiLCAiK0NbMV0rIiwgIitDWzJdKyIsICIrQ1szXSsiKSJ9ZnVuY3Rpb24gYyhDKXtyZXR1cm4gTWF0aC5oeXBvdChDWzBdLENbMV0sQ1syXSxDWzNdKX1mdW5jdGlvbiBnKEMsQix6LEspe3JldHVybiBDWzJdPUtbMl0vS1swXSx6WzBdPUtbMF0selsxXT1LWzFdLHpbM109S1szXS1DWzJdKnpbMV0sW0MsQix6XX1mdW5jdGlvbiBiKEMsQix6KXtyZXR1cm4gQ1swXT1CWzBdK3pbMF0sQ1sxXT1CWzFdK3pbMV0sQ1syXT1CWzJdK3pbMl0sQ1szXT1CWzNdK3pbM10sQ31mdW5jdGlvbiBFKEMsQix6KXtyZXR1cm4gQ1swXT1CWzBdLXpbMF0sQ1sxXT1CWzFdLXpbMV0sQ1syXT1CWzJdLXpbMl0sQ1szXT1CWzNdLXpbM10sQ31mdW5jdGlvbiBBKEMsQil7cmV0dXJuIENbMF09PT1CWzBdJiZDWzFdPT09QlsxXSYmQ1syXT09PUJbMl0mJkNbM109PT1CWzNdfWZ1bmN0aW9uIEwoQyxCKXt2YXIgej1DWzBdLEs9Q1sxXSxRPUNbMl0sXz1DWzNdLEY9QlswXSxHPUJbMV0sWD1CWzJdLFo9QlszXTtyZXR1cm4gTWF0aC5hYnMoei1GKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeiksTWF0aC5hYnMoRikpJiZNYXRoLmFicyhLLUcpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhHKSkmJk1hdGguYWJzKFEtWCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFEpLE1hdGguYWJzKFgpKSYmTWF0aC5hYnMoXy1aKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMoWikpfWZ1bmN0aW9uIE0oQyxCLHope3JldHVybiBDWzBdPUJbMF0qeixDWzFdPUJbMV0qeixDWzJdPUJbMl0qeixDWzNdPUJbM10qeixDfWZ1bmN0aW9uIEkoQyxCLHosSyl7cmV0dXJuIENbMF09QlswXSt6WzBdKkssQ1sxXT1CWzFdK3pbMV0qSyxDWzJdPUJbMl0relsyXSpLLENbM109QlszXSt6WzNdKkssQ312YXIgRD1QLFI9RX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgUj1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFJbMV09MCxSWzJdPTAsUls0XT0wLFJbNV09MCksUlswXT0xLFJbM109MSxSfWZ1bmN0aW9uIGkoUil7dmFyIEM9bmV3IHIuQVJSQVlfVFlQRSg2KTtyZXR1cm4gQ1swXT1SWzBdLENbMV09UlsxXSxDWzJdPVJbMl0sQ1szXT1SWzNdLENbNF09Uls0XSxDWzVdPVJbNV0sQ31mdW5jdGlvbiBhKFIsQyl7cmV0dXJuIFJbMF09Q1swXSxSWzFdPUNbMV0sUlsyXT1DWzJdLFJbM109Q1szXSxSWzRdPUNbNF0sUls1XT1DWzVdLFJ9ZnVuY3Rpb24gbChSKXtyZXR1cm4gUlswXT0xLFJbMV09MCxSWzJdPTAsUlszXT0xLFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiBzKFIsQyxCLHosSyxRKXt2YXIgXz1uZXcgci5BUlJBWV9UWVBFKDYpO3JldHVybiBfWzBdPVIsX1sxXT1DLF9bMl09QixfWzNdPXosX1s0XT1LLF9bNV09USxffWZ1bmN0aW9uIGYoUixDLEIseixLLFEsXyl7cmV0dXJuIFJbMF09QyxSWzFdPUIsUlsyXT16LFJbM109SyxSWzRdPVEsUls1XT1fLFJ9ZnVuY3Rpb24gdihSLEMpe3ZhciBCPUNbMF0sej1DWzFdLEs9Q1syXSxRPUNbM10sXz1DWzRdLEY9Q1s1XSxHPUIqUS16Kks7cmV0dXJuIEc/KEc9MS9HLFJbMF09USpHLFJbMV09LXoqRyxSWzJdPS1LKkcsUlszXT1CKkcsUls0XT0oSypGLVEqXykqRyxSWzVdPSh6Kl8tQipGKSpHLFIpOm51bGx9ZnVuY3Rpb24gZChSKXtyZXR1cm4gUlswXSpSWzNdLVJbMV0qUlsyXX1mdW5jdGlvbiBwKFIsQyxCKXt2YXIgej1DWzBdLEs9Q1sxXSxRPUNbMl0sXz1DWzNdLEY9Q1s0XSxHPUNbNV0sWD1CWzBdLFo9QlsxXSx0dD1CWzJdLG50PUJbM10scT1CWzRdLGh0PUJbNV07cmV0dXJuIFJbMF09eipYK1EqWixSWzFdPUsqWCtfKlosUlsyXT16KnR0K1EqbnQsUlszXT1LKnR0K18qbnQsUls0XT16KnErUSpodCtGLFJbNV09SypxK18qaHQrRyxSfWZ1bmN0aW9uIHkoUixDLEIpe3ZhciB6PUNbMF0sSz1DWzFdLFE9Q1syXSxfPUNbM10sRj1DWzRdLEc9Q1s1XSxYPU1hdGguc2luKEIpLFo9TWF0aC5jb3MoQik7cmV0dXJuIFJbMF09eipaK1EqWCxSWzFdPUsqWitfKlgsUlsyXT16Ki1YK1EqWixSWzNdPUsqLVgrXypaLFJbNF09RixSWzVdPUcsUn1mdW5jdGlvbiBQKFIsQyxCKXt2YXIgej1DWzBdLEs9Q1sxXSxRPUNbMl0sXz1DWzNdLEY9Q1s0XSxHPUNbNV0sWD1CWzBdLFo9QlsxXTtyZXR1cm4gUlswXT16KlgsUlsxXT1LKlgsUlsyXT1RKlosUlszXT1fKlosUls0XT1GLFJbNV09RyxSfWZ1bmN0aW9uIHgoUixDLEIpe3ZhciB6PUNbMF0sSz1DWzFdLFE9Q1syXSxfPUNbM10sRj1DWzRdLEc9Q1s1XSxYPUJbMF0sWj1CWzFdO3JldHVybiBSWzBdPXosUlsxXT1LLFJbMl09USxSWzNdPV8sUls0XT16KlgrUSpaK0YsUls1XT1LKlgrXypaK0csUn1mdW5jdGlvbiBtKFIsQyl7dmFyIEI9TWF0aC5zaW4oQyksej1NYXRoLmNvcyhDKTtyZXR1cm4gUlswXT16LFJbMV09QixSWzJdPS1CLFJbM109eixSWzRdPTAsUls1XT0wLFJ9ZnVuY3Rpb24gTyhSLEMpe3JldHVybiBSWzBdPUNbMF0sUlsxXT0wLFJbMl09MCxSWzNdPUNbMV0sUls0XT0wLFJbNV09MCxSfWZ1bmN0aW9uIG8oUixDKXtyZXR1cm4gUlswXT0xLFJbMV09MCxSWzJdPTAsUlszXT0xLFJbNF09Q1swXSxSWzVdPUNbMV0sUn1mdW5jdGlvbiBoKFIpe3JldHVybiJtYXQyZCgiK1JbMF0rIiwgIitSWzFdKyIsICIrUlsyXSsiLCAiK1JbM10rIiwgIitSWzRdKyIsICIrUls1XSsiKSJ9ZnVuY3Rpb24gYyhSKXtyZXR1cm4gTWF0aC5oeXBvdChSWzBdLFJbMV0sUlsyXSxSWzNdLFJbNF0sUls1XSwxKX1mdW5jdGlvbiBnKFIsQyxCKXtyZXR1cm4gUlswXT1DWzBdK0JbMF0sUlsxXT1DWzFdK0JbMV0sUlsyXT1DWzJdK0JbMl0sUlszXT1DWzNdK0JbM10sUls0XT1DWzRdK0JbNF0sUls1XT1DWzVdK0JbNV0sUn1mdW5jdGlvbiBiKFIsQyxCKXtyZXR1cm4gUlswXT1DWzBdLUJbMF0sUlsxXT1DWzFdLUJbMV0sUlsyXT1DWzJdLUJbMl0sUlszXT1DWzNdLUJbM10sUls0XT1DWzRdLUJbNF0sUls1XT1DWzVdLUJbNV0sUn1mdW5jdGlvbiBFKFIsQyxCKXtyZXR1cm4gUlswXT1DWzBdKkIsUlsxXT1DWzFdKkIsUlsyXT1DWzJdKkIsUlszXT1DWzNdKkIsUls0XT1DWzRdKkIsUls1XT1DWzVdKkIsUn1mdW5jdGlvbiBBKFIsQyxCLHope3JldHVybiBSWzBdPUNbMF0rQlswXSp6LFJbMV09Q1sxXStCWzFdKnosUlsyXT1DWzJdK0JbMl0qeixSWzNdPUNbM10rQlszXSp6LFJbNF09Q1s0XStCWzRdKnosUls1XT1DWzVdK0JbNV0qeixSfWZ1bmN0aW9uIEwoUixDKXtyZXR1cm4gUlswXT09PUNbMF0mJlJbMV09PT1DWzFdJiZSWzJdPT09Q1syXSYmUlszXT09PUNbM10mJlJbNF09PT1DWzRdJiZSWzVdPT09Q1s1XX1mdW5jdGlvbiBNKFIsQyl7dmFyIEI9UlswXSx6PVJbMV0sSz1SWzJdLFE9UlszXSxfPVJbNF0sRj1SWzVdLEc9Q1swXSxYPUNbMV0sWj1DWzJdLHR0PUNbM10sbnQ9Q1s0XSxxPUNbNV07cmV0dXJuIE1hdGguYWJzKEItRyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEIpLE1hdGguYWJzKEcpKSYmTWF0aC5hYnMoei1YKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeiksTWF0aC5hYnMoWCkpJiZNYXRoLmFicyhLLVopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKFEtdHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhRKSxNYXRoLmFicyh0dCkpJiZNYXRoLmFicyhfLW50KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMobnQpKSYmTWF0aC5hYnMoRi1xKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoRiksTWF0aC5hYnMocSkpfXZhciBJPXAsRD1ifSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImZyb21NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJub3JtYWxGcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJwcm9qZWN0aW9uIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gen0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gX30pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBGPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoRlsxXT0wLEZbMl09MCxGWzNdPTAsRls1XT0wLEZbNl09MCxGWzddPTApLEZbMF09MSxGWzRdPTEsRls4XT0xLEZ9ZnVuY3Rpb24gaShGLEcpe3JldHVybiBGWzBdPUdbMF0sRlsxXT1HWzFdLEZbMl09R1syXSxGWzNdPUdbNF0sRls0XT1HWzVdLEZbNV09R1s2XSxGWzZdPUdbOF0sRls3XT1HWzldLEZbOF09R1sxMF0sRn1mdW5jdGlvbiBhKEYpe3ZhciBHPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIEdbMF09RlswXSxHWzFdPUZbMV0sR1syXT1GWzJdLEdbM109RlszXSxHWzRdPUZbNF0sR1s1XT1GWzVdLEdbNl09Rls2XSxHWzddPUZbN10sR1s4XT1GWzhdLEd9ZnVuY3Rpb24gbChGLEcpe3JldHVybiBGWzBdPUdbMF0sRlsxXT1HWzFdLEZbMl09R1syXSxGWzNdPUdbM10sRls0XT1HWzRdLEZbNV09R1s1XSxGWzZdPUdbNl0sRls3XT1HWzddLEZbOF09R1s4XSxGfWZ1bmN0aW9uIHMoRixHLFgsWix0dCxudCxxLGh0LHV0KXt2YXIgaj1uZXcgci5BUlJBWV9UWVBFKDkpO3JldHVybiBqWzBdPUYsalsxXT1HLGpbMl09WCxqWzNdPVosals0XT10dCxqWzVdPW50LGpbNl09cSxqWzddPWh0LGpbOF09dXQsan1mdW5jdGlvbiBmKEYsRyxYLFosdHQsbnQscSxodCx1dCxqKXtyZXR1cm4gRlswXT1HLEZbMV09WCxGWzJdPVosRlszXT10dCxGWzRdPW50LEZbNV09cSxGWzZdPWh0LEZbN109dXQsRls4XT1qLEZ9ZnVuY3Rpb24gdihGKXtyZXR1cm4gRlswXT0xLEZbMV09MCxGWzJdPTAsRlszXT0wLEZbNF09MSxGWzVdPTAsRls2XT0wLEZbN109MCxGWzhdPTEsRn1mdW5jdGlvbiBkKEYsRyl7aWYoRj09PUcpe3ZhciBYPUdbMV0sWj1HWzJdLHR0PUdbNV07RlsxXT1HWzNdLEZbMl09R1s2XSxGWzNdPVgsRls1XT1HWzddLEZbNl09WixGWzddPXR0fWVsc2UgRlswXT1HWzBdLEZbMV09R1szXSxGWzJdPUdbNl0sRlszXT1HWzFdLEZbNF09R1s0XSxGWzVdPUdbN10sRls2XT1HWzJdLEZbN109R1s1XSxGWzhdPUdbOF07cmV0dXJuIEZ9ZnVuY3Rpb24gcChGLEcpe3ZhciBYPUdbMF0sWj1HWzFdLHR0PUdbMl0sbnQ9R1szXSxxPUdbNF0saHQ9R1s1XSx1dD1HWzZdLGo9R1s3XSxXPUdbOF0sVj1XKnEtaHQqaixKPS1XKm50K2h0KnV0LE49aipudC1xKnV0LCQ9WCpWK1oqSit0dCpOO3JldHVybiAkPygkPTEvJCxGWzBdPVYqJCxGWzFdPSgtVypaK3R0KmopKiQsRlsyXT0oaHQqWi10dCpxKSokLEZbM109SiokLEZbNF09KFcqWC10dCp1dCkqJCxGWzVdPSgtaHQqWCt0dCpudCkqJCxGWzZdPU4qJCxGWzddPSgtaipYK1oqdXQpKiQsRls4XT0ocSpYLVoqbnQpKiQsRik6bnVsbH1mdW5jdGlvbiB5KEYsRyl7dmFyIFg9R1swXSxaPUdbMV0sdHQ9R1syXSxudD1HWzNdLHE9R1s0XSxodD1HWzVdLHV0PUdbNl0saj1HWzddLFc9R1s4XTtyZXR1cm4gRlswXT1xKlctaHQqaixGWzFdPXR0KmotWipXLEZbMl09WipodC10dCpxLEZbM109aHQqdXQtbnQqVyxGWzRdPVgqVy10dCp1dCxGWzVdPXR0Km50LVgqaHQsRls2XT1udCpqLXEqdXQsRls3XT1aKnV0LVgqaixGWzhdPVgqcS1aKm50LEZ9ZnVuY3Rpb24gUChGKXt2YXIgRz1GWzBdLFg9RlsxXSxaPUZbMl0sdHQ9RlszXSxudD1GWzRdLHE9Rls1XSxodD1GWzZdLHV0PUZbN10saj1GWzhdO3JldHVybiBHKihqKm50LXEqdXQpK1gqKC1qKnR0K3EqaHQpK1oqKHV0KnR0LW50Kmh0KX1mdW5jdGlvbiB4KEYsRyxYKXt2YXIgWj1HWzBdLHR0PUdbMV0sbnQ9R1syXSxxPUdbM10saHQ9R1s0XSx1dD1HWzVdLGo9R1s2XSxXPUdbN10sVj1HWzhdLEo9WFswXSxOPVhbMV0sJD1YWzJdLFM9WFszXSxUPVhbNF0sdz1YWzVdLFU9WFs2XSxIPVhbN10sWT1YWzhdO3JldHVybiBGWzBdPUoqWitOKnErJCpqLEZbMV09Sip0dCtOKmh0KyQqVyxGWzJdPUoqbnQrTip1dCskKlYsRlszXT1TKlorVCpxK3cqaixGWzRdPVMqdHQrVCpodCt3KlcsRls1XT1TKm50K1QqdXQrdypWLEZbNl09VSpaK0gqcStZKmosRls3XT1VKnR0K0gqaHQrWSpXLEZbOF09VSpudCtIKnV0K1kqVixGfWZ1bmN0aW9uIG0oRixHLFgpe3ZhciBaPUdbMF0sdHQ9R1sxXSxudD1HWzJdLHE9R1szXSxodD1HWzRdLHV0PUdbNV0saj1HWzZdLFc9R1s3XSxWPUdbOF0sSj1YWzBdLE49WFsxXTtyZXR1cm4gRlswXT1aLEZbMV09dHQsRlsyXT1udCxGWzNdPXEsRls0XT1odCxGWzVdPXV0LEZbNl09SipaK04qcStqLEZbN109Sip0dCtOKmh0K1csRls4XT1KKm50K04qdXQrVixGfWZ1bmN0aW9uIE8oRixHLFgpe3ZhciBaPUdbMF0sdHQ9R1sxXSxudD1HWzJdLHE9R1szXSxodD1HWzRdLHV0PUdbNV0saj1HWzZdLFc9R1s3XSxWPUdbOF0sSj1NYXRoLnNpbihYKSxOPU1hdGguY29zKFgpO3JldHVybiBGWzBdPU4qWitKKnEsRlsxXT1OKnR0K0oqaHQsRlsyXT1OKm50K0oqdXQsRlszXT1OKnEtSipaLEZbNF09TipodC1KKnR0LEZbNV09Tip1dC1KKm50LEZbNl09aixGWzddPVcsRls4XT1WLEZ9ZnVuY3Rpb24gbyhGLEcsWCl7dmFyIFo9WFswXSx0dD1YWzFdO3JldHVybiBGWzBdPVoqR1swXSxGWzFdPVoqR1sxXSxGWzJdPVoqR1syXSxGWzNdPXR0KkdbM10sRls0XT10dCpHWzRdLEZbNV09dHQqR1s1XSxGWzZdPUdbNl0sRls3XT1HWzddLEZbOF09R1s4XSxGfWZ1bmN0aW9uIGgoRixHKXtyZXR1cm4gRlswXT0xLEZbMV09MCxGWzJdPTAsRlszXT0wLEZbNF09MSxGWzVdPTAsRls2XT1HWzBdLEZbN109R1sxXSxGWzhdPTEsRn1mdW5jdGlvbiBjKEYsRyl7dmFyIFg9TWF0aC5zaW4oRyksWj1NYXRoLmNvcyhHKTtyZXR1cm4gRlswXT1aLEZbMV09WCxGWzJdPTAsRlszXT0tWCxGWzRdPVosRls1XT0wLEZbNl09MCxGWzddPTAsRls4XT0xLEZ9ZnVuY3Rpb24gZyhGLEcpe3JldHVybiBGWzBdPUdbMF0sRlsxXT0wLEZbMl09MCxGWzNdPTAsRls0XT1HWzFdLEZbNV09MCxGWzZdPTAsRls3XT0wLEZbOF09MSxGfWZ1bmN0aW9uIGIoRixHKXtyZXR1cm4gRlswXT1HWzBdLEZbMV09R1sxXSxGWzJdPTAsRlszXT1HWzJdLEZbNF09R1szXSxGWzVdPTAsRls2XT1HWzRdLEZbN109R1s1XSxGWzhdPTEsRn1mdW5jdGlvbiBFKEYsRyl7dmFyIFg9R1swXSxaPUdbMV0sdHQ9R1syXSxudD1HWzNdLHE9WCtYLGh0PVorWix1dD10dCt0dCxqPVgqcSxXPVoqcSxWPVoqaHQsSj10dCpxLE49dHQqaHQsJD10dCp1dCxTPW50KnEsVD1udCpodCx3PW50KnV0O3JldHVybiBGWzBdPTEtVi0kLEZbM109Vy13LEZbNl09SitULEZbMV09Vyt3LEZbNF09MS1qLSQsRls3XT1OLVMsRlsyXT1KLVQsRls1XT1OK1MsRls4XT0xLWotVixGfWZ1bmN0aW9uIEEoRixHKXt2YXIgWD1HWzBdLFo9R1sxXSx0dD1HWzJdLG50PUdbM10scT1HWzRdLGh0PUdbNV0sdXQ9R1s2XSxqPUdbN10sVz1HWzhdLFY9R1s5XSxKPUdbMTBdLE49R1sxMV0sJD1HWzEyXSxTPUdbMTNdLFQ9R1sxNF0sdz1HWzE1XSxVPVgqaHQtWipxLEg9WCp1dC10dCpxLFk9WCpqLW50KnEsaz1aKnV0LXR0Kmh0LHJ0PVoqai1udCpodCxpdD10dCpqLW50KnV0LGx0PVcqUy1WKiQsZnQ9VypULUoqJCxvdD1XKnctTiokLHN0PVYqVC1KKlMsY3Q9Vip3LU4qUyxtdD1KKnctTipULHZ0PVUqbXQtSCpjdCtZKnN0K2sqb3QtcnQqZnQraXQqbHQ7cmV0dXJuIHZ0Pyh2dD0xL3Z0LEZbMF09KGh0Km10LXV0KmN0K2oqc3QpKnZ0LEZbMV09KHV0Km90LXEqbXQtaipmdCkqdnQsRlsyXT0ocSpjdC1odCpvdCtqKmx0KSp2dCxGWzNdPSh0dCpjdC1aKm10LW50KnN0KSp2dCxGWzRdPShYKm10LXR0Km90K250KmZ0KSp2dCxGWzVdPShaKm90LVgqY3QtbnQqbHQpKnZ0LEZbNl09KFMqaXQtVCpydCt3KmspKnZ0LEZbN109KFQqWS0kKml0LXcqSCkqdnQsRls4XT0oJCpydC1TKlkrdypVKSp2dCxGKTpudWxsfWZ1bmN0aW9uIEwoRixHLFgpe3JldHVybiBGWzBdPTIvRyxGWzFdPTAsRlsyXT0wLEZbM109MCxGWzRdPS0yL1gsRls1XT0wLEZbNl09LTEsRls3XT0xLEZbOF09MSxGfWZ1bmN0aW9uIE0oRil7cmV0dXJuIm1hdDMoIitGWzBdKyIsICIrRlsxXSsiLCAiK0ZbMl0rIiwgIitGWzNdKyIsICIrRls0XSsiLCAiK0ZbNV0rIiwgIitGWzZdKyIsICIrRls3XSsiLCAiK0ZbOF0rIikifWZ1bmN0aW9uIEkoRil7cmV0dXJuIE1hdGguaHlwb3QoRlswXSxGWzFdLEZbMl0sRlszXSxGWzRdLEZbNV0sRls2XSxGWzddLEZbOF0pfWZ1bmN0aW9uIEQoRixHLFgpe3JldHVybiBGWzBdPUdbMF0rWFswXSxGWzFdPUdbMV0rWFsxXSxGWzJdPUdbMl0rWFsyXSxGWzNdPUdbM10rWFszXSxGWzRdPUdbNF0rWFs0XSxGWzVdPUdbNV0rWFs1XSxGWzZdPUdbNl0rWFs2XSxGWzddPUdbN10rWFs3XSxGWzhdPUdbOF0rWFs4XSxGfWZ1bmN0aW9uIFIoRixHLFgpe3JldHVybiBGWzBdPUdbMF0tWFswXSxGWzFdPUdbMV0tWFsxXSxGWzJdPUdbMl0tWFsyXSxGWzNdPUdbM10tWFszXSxGWzRdPUdbNF0tWFs0XSxGWzVdPUdbNV0tWFs1XSxGWzZdPUdbNl0tWFs2XSxGWzddPUdbN10tWFs3XSxGWzhdPUdbOF0tWFs4XSxGfWZ1bmN0aW9uIEMoRixHLFgpe3JldHVybiBGWzBdPUdbMF0qWCxGWzFdPUdbMV0qWCxGWzJdPUdbMl0qWCxGWzNdPUdbM10qWCxGWzRdPUdbNF0qWCxGWzVdPUdbNV0qWCxGWzZdPUdbNl0qWCxGWzddPUdbN10qWCxGWzhdPUdbOF0qWCxGfWZ1bmN0aW9uIEIoRixHLFgsWil7cmV0dXJuIEZbMF09R1swXStYWzBdKlosRlsxXT1HWzFdK1hbMV0qWixGWzJdPUdbMl0rWFsyXSpaLEZbM109R1szXStYWzNdKlosRls0XT1HWzRdK1hbNF0qWixGWzVdPUdbNV0rWFs1XSpaLEZbNl09R1s2XStYWzZdKlosRls3XT1HWzddK1hbN10qWixGWzhdPUdbOF0rWFs4XSpaLEZ9ZnVuY3Rpb24geihGLEcpe3JldHVybiBGWzBdPT09R1swXSYmRlsxXT09PUdbMV0mJkZbMl09PT1HWzJdJiZGWzNdPT09R1szXSYmRls0XT09PUdbNF0mJkZbNV09PT1HWzVdJiZGWzZdPT09R1s2XSYmRls3XT09PUdbN10mJkZbOF09PT1HWzhdfWZ1bmN0aW9uIEsoRixHKXt2YXIgWD1GWzBdLFo9RlsxXSx0dD1GWzJdLG50PUZbM10scT1GWzRdLGh0PUZbNV0sdXQ9Rls2XSxqPUZbN10sVz1GWzhdLFY9R1swXSxKPUdbMV0sTj1HWzJdLCQ9R1szXSxTPUdbNF0sVD1HWzVdLHc9R1s2XSxVPUdbN10sSD1HWzhdO3JldHVybiBNYXRoLmFicyhYLVYpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhYKSxNYXRoLmFicyhWKSkmJk1hdGguYWJzKFotSik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFopLE1hdGguYWJzKEopKSYmTWF0aC5hYnModHQtTik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHR0KSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKG50LSQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhudCksTWF0aC5hYnMoJCkpJiZNYXRoLmFicyhxLVMpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyhTKSkmJk1hdGguYWJzKGh0LVQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhodCksTWF0aC5hYnMoVCkpJiZNYXRoLmFicyh1dC13KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModXQpLE1hdGguYWJzKHcpKSYmTWF0aC5hYnMoai1VKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaiksTWF0aC5hYnMoVSkpJiZNYXRoLmFicyhXLUgpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhXKSxNYXRoLmFicyhIKSl9dmFyIFE9eCxfPVJ9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiZnJvbVhSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJmcm9tWVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImZyb21aUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiZnJvbVF1YXQyIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImdldFRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImdldFNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZ2V0Um90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gen0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsImZyb21RdWF0IixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImZydXN0dW0iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwicGVyc3BlY3RpdmUiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwicGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXciLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwib3J0aG8iLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSx0LmQoZSwibG9va0F0IixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInRhcmdldFRvIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIG50fSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gdXR9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuICR9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgUz1uZXcgci5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s2XT0wLFNbN109MCxTWzhdPTAsU1s5XT0wLFNbMTFdPTAsU1sxMl09MCxTWzEzXT0wLFNbMTRdPTApLFNbMF09MSxTWzVdPTEsU1sxMF09MSxTWzE1XT0xLFN9ZnVuY3Rpb24gaShTKXt2YXIgVD1uZXcgci5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gVFswXT1TWzBdLFRbMV09U1sxXSxUWzJdPVNbMl0sVFszXT1TWzNdLFRbNF09U1s0XSxUWzVdPVNbNV0sVFs2XT1TWzZdLFRbN109U1s3XSxUWzhdPVNbOF0sVFs5XT1TWzldLFRbMTBdPVNbMTBdLFRbMTFdPVNbMTFdLFRbMTJdPVNbMTJdLFRbMTNdPVNbMTNdLFRbMTRdPVNbMTRdLFRbMTVdPVNbMTVdLFR9ZnVuY3Rpb24gYShTLFQpe3JldHVybiBTWzBdPVRbMF0sU1sxXT1UWzFdLFNbMl09VFsyXSxTWzNdPVRbM10sU1s0XT1UWzRdLFNbNV09VFs1XSxTWzZdPVRbNl0sU1s3XT1UWzddLFNbOF09VFs4XSxTWzldPVRbOV0sU1sxMF09VFsxMF0sU1sxMV09VFsxMV0sU1sxMl09VFsxMl0sU1sxM109VFsxM10sU1sxNF09VFsxNF0sU1sxNV09VFsxNV0sU31mdW5jdGlvbiBsKFMsVCx3LFUsSCxZLGsscnQsaXQsbHQsZnQsb3Qsc3QsY3QsbXQsdnQpe3ZhciBndD1uZXcgci5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gZ3RbMF09UyxndFsxXT1ULGd0WzJdPXcsZ3RbM109VSxndFs0XT1ILGd0WzVdPVksZ3RbNl09ayxndFs3XT1ydCxndFs4XT1pdCxndFs5XT1sdCxndFsxMF09ZnQsZ3RbMTFdPW90LGd0WzEyXT1zdCxndFsxM109Y3QsZ3RbMTRdPW10LGd0WzE1XT12dCxndH1mdW5jdGlvbiBzKFMsVCx3LFUsSCxZLGsscnQsaXQsbHQsZnQsb3Qsc3QsY3QsbXQsdnQsZ3Qpe3JldHVybiBTWzBdPVQsU1sxXT13LFNbMl09VSxTWzNdPUgsU1s0XT1ZLFNbNV09ayxTWzZdPXJ0LFNbN109aXQsU1s4XT1sdCxTWzldPWZ0LFNbMTBdPW90LFNbMTFdPXN0LFNbMTJdPWN0LFNbMTNdPW10LFNbMTRdPXZ0LFNbMTVdPWd0LFN9ZnVuY3Rpb24gZihTKXtyZXR1cm4gU1swXT0xLFNbMV09MCxTWzJdPTAsU1szXT0wLFNbNF09MCxTWzVdPTEsU1s2XT0wLFNbN109MCxTWzhdPTAsU1s5XT0wLFNbMTBdPTEsU1sxMV09MCxTWzEyXT0wLFNbMTNdPTAsU1sxNF09MCxTWzE1XT0xLFN9ZnVuY3Rpb24gdihTLFQpe2lmKFM9PT1UKXt2YXIgdz1UWzFdLFU9VFsyXSxIPVRbM10sWT1UWzZdLGs9VFs3XSxydD1UWzExXTtTWzFdPVRbNF0sU1syXT1UWzhdLFNbM109VFsxMl0sU1s0XT13LFNbNl09VFs5XSxTWzddPVRbMTNdLFNbOF09VSxTWzldPVksU1sxMV09VFsxNF0sU1sxMl09SCxTWzEzXT1rLFNbMTRdPXJ0fWVsc2UgU1swXT1UWzBdLFNbMV09VFs0XSxTWzJdPVRbOF0sU1szXT1UWzEyXSxTWzRdPVRbMV0sU1s1XT1UWzVdLFNbNl09VFs5XSxTWzddPVRbMTNdLFNbOF09VFsyXSxTWzldPVRbNl0sU1sxMF09VFsxMF0sU1sxMV09VFsxNF0sU1sxMl09VFszXSxTWzEzXT1UWzddLFNbMTRdPVRbMTFdLFNbMTVdPVRbMTVdO3JldHVybiBTfWZ1bmN0aW9uIGQoUyxUKXt2YXIgdz1UWzBdLFU9VFsxXSxIPVRbMl0sWT1UWzNdLGs9VFs0XSxydD1UWzVdLGl0PVRbNl0sbHQ9VFs3XSxmdD1UWzhdLG90PVRbOV0sc3Q9VFsxMF0sY3Q9VFsxMV0sbXQ9VFsxMl0sdnQ9VFsxM10sZ3Q9VFsxNF0sU3Q9VFsxNV0sQXQ9dypydC1VKmssUHQ9dyppdC1IKmssVHQ9dypsdC1ZKmssTXQ9VSppdC1IKnJ0LEV0PVUqbHQtWSpydCwkdD1IKmx0LVkqaXQsV3Q9ZnQqdnQtb3QqbXQsRnQ9ZnQqZ3Qtc3QqbXQsVXQ9ZnQqU3QtY3QqbXQsR3Q9b3QqZ3Qtc3QqdnQsSHQ9b3QqU3QtY3QqdnQsS3Q9c3QqU3QtY3QqZ3QsTHQ9QXQqS3QtUHQqSHQrVHQqR3QrTXQqVXQtRXQqRnQrJHQqV3Q7cmV0dXJuIEx0PyhMdD0xL0x0LFNbMF09KHJ0Kkt0LWl0Kkh0K2x0Kkd0KSpMdCxTWzFdPShIKkh0LVUqS3QtWSpHdCkqTHQsU1syXT0odnQqJHQtZ3QqRXQrU3QqTXQpKkx0LFNbM109KHN0KkV0LW90KiR0LWN0Kk10KSpMdCxTWzRdPShpdCpVdC1rKkt0LWx0KkZ0KSpMdCxTWzVdPSh3Kkt0LUgqVXQrWSpGdCkqTHQsU1s2XT0oZ3QqVHQtbXQqJHQtU3QqUHQpKkx0LFNbN109KGZ0KiR0LXN0KlR0K2N0KlB0KSpMdCxTWzhdPShrKkh0LXJ0KlV0K2x0Kld0KSpMdCxTWzldPShVKlV0LXcqSHQtWSpXdCkqTHQsU1sxMF09KG10KkV0LXZ0KlR0K1N0KkF0KSpMdCxTWzExXT0ob3QqVHQtZnQqRXQtY3QqQXQpKkx0LFNbMTJdPShydCpGdC1rKkd0LWl0Kld0KSpMdCxTWzEzXT0odypHdC1VKkZ0K0gqV3QpKkx0LFNbMTRdPSh2dCpQdC1tdCpNdC1ndCpBdCkqTHQsU1sxNV09KGZ0Kk10LW90KlB0K3N0KkF0KSpMdCxTKTpudWxsfWZ1bmN0aW9uIHAoUyxUKXt2YXIgdz1UWzBdLFU9VFsxXSxIPVRbMl0sWT1UWzNdLGs9VFs0XSxydD1UWzVdLGl0PVRbNl0sbHQ9VFs3XSxmdD1UWzhdLG90PVRbOV0sc3Q9VFsxMF0sY3Q9VFsxMV0sbXQ9VFsxMl0sdnQ9VFsxM10sZ3Q9VFsxNF0sU3Q9VFsxNV07cmV0dXJuIFNbMF09cnQqKHN0KlN0LWN0Kmd0KS1vdCooaXQqU3QtbHQqZ3QpK3Z0KihpdCpjdC1sdCpzdCksU1sxXT0tKFUqKHN0KlN0LWN0Kmd0KS1vdCooSCpTdC1ZKmd0KSt2dCooSCpjdC1ZKnN0KSksU1syXT1VKihpdCpTdC1sdCpndCktcnQqKEgqU3QtWSpndCkrdnQqKEgqbHQtWSppdCksU1szXT0tKFUqKGl0KmN0LWx0KnN0KS1ydCooSCpjdC1ZKnN0KStvdCooSCpsdC1ZKml0KSksU1s0XT0tKGsqKHN0KlN0LWN0Kmd0KS1mdCooaXQqU3QtbHQqZ3QpK210KihpdCpjdC1sdCpzdCkpLFNbNV09dyooc3QqU3QtY3QqZ3QpLWZ0KihIKlN0LVkqZ3QpK210KihIKmN0LVkqc3QpLFNbNl09LSh3KihpdCpTdC1sdCpndCktayooSCpTdC1ZKmd0KSttdCooSCpsdC1ZKml0KSksU1s3XT13KihpdCpjdC1sdCpzdCktayooSCpjdC1ZKnN0KStmdCooSCpsdC1ZKml0KSxTWzhdPWsqKG90KlN0LWN0KnZ0KS1mdCoocnQqU3QtbHQqdnQpK210KihydCpjdC1sdCpvdCksU1s5XT0tKHcqKG90KlN0LWN0KnZ0KS1mdCooVSpTdC1ZKnZ0KSttdCooVSpjdC1ZKm90KSksU1sxMF09dyoocnQqU3QtbHQqdnQpLWsqKFUqU3QtWSp2dCkrbXQqKFUqbHQtWSpydCksU1sxMV09LSh3KihydCpjdC1sdCpvdCktayooVSpjdC1ZKm90KStmdCooVSpsdC1ZKnJ0KSksU1sxMl09LShrKihvdCpndC1zdCp2dCktZnQqKHJ0Kmd0LWl0KnZ0KSttdCoocnQqc3QtaXQqb3QpKSxTWzEzXT13KihvdCpndC1zdCp2dCktZnQqKFUqZ3QtSCp2dCkrbXQqKFUqc3QtSCpvdCksU1sxNF09LSh3KihydCpndC1pdCp2dCktayooVSpndC1IKnZ0KSttdCooVSppdC1IKnJ0KSksU1sxNV09dyoocnQqc3QtaXQqb3QpLWsqKFUqc3QtSCpvdCkrZnQqKFUqaXQtSCpydCksU31mdW5jdGlvbiB5KFMpe3ZhciBUPVNbMF0sdz1TWzFdLFU9U1syXSxIPVNbM10sWT1TWzRdLGs9U1s1XSxydD1TWzZdLGl0PVNbN10sbHQ9U1s4XSxmdD1TWzldLG90PVNbMTBdLHN0PVNbMTFdLGN0PVNbMTJdLG10PVNbMTNdLHZ0PVNbMTRdLGd0PVNbMTVdLFN0PVQqay13KlksQXQ9VCpydC1VKlksUHQ9VCppdC1IKlksVHQ9dypydC1VKmssTXQ9dyppdC1IKmssRXQ9VSppdC1IKnJ0LCR0PWx0Km10LWZ0KmN0LFd0PWx0KnZ0LW90KmN0LEZ0PWx0Kmd0LXN0KmN0LFV0PWZ0KnZ0LW90Km10LEd0PWZ0Kmd0LXN0Km10LEh0PW90Kmd0LXN0KnZ0O3JldHVybiBTdCpIdC1BdCpHdCtQdCpVdCtUdCpGdC1NdCpXdCtFdCokdH1mdW5jdGlvbiBQKFMsVCx3KXt2YXIgVT1UWzBdLEg9VFsxXSxZPVRbMl0saz1UWzNdLHJ0PVRbNF0saXQ9VFs1XSxsdD1UWzZdLGZ0PVRbN10sb3Q9VFs4XSxzdD1UWzldLGN0PVRbMTBdLG10PVRbMTFdLHZ0PVRbMTJdLGd0PVRbMTNdLFN0PVRbMTRdLEF0PVRbMTVdLFB0PXdbMF0sVHQ9d1sxXSxNdD13WzJdLEV0PXdbM107cmV0dXJuIFNbMF09UHQqVStUdCpydCtNdCpvdCtFdCp2dCxTWzFdPVB0KkgrVHQqaXQrTXQqc3QrRXQqZ3QsU1syXT1QdCpZK1R0Kmx0K010KmN0K0V0KlN0LFNbM109UHQqaytUdCpmdCtNdCptdCtFdCpBdCxQdD13WzRdLFR0PXdbNV0sTXQ9d1s2XSxFdD13WzddLFNbNF09UHQqVStUdCpydCtNdCpvdCtFdCp2dCxTWzVdPVB0KkgrVHQqaXQrTXQqc3QrRXQqZ3QsU1s2XT1QdCpZK1R0Kmx0K010KmN0K0V0KlN0LFNbN109UHQqaytUdCpmdCtNdCptdCtFdCpBdCxQdD13WzhdLFR0PXdbOV0sTXQ9d1sxMF0sRXQ9d1sxMV0sU1s4XT1QdCpVK1R0KnJ0K010Km90K0V0KnZ0LFNbOV09UHQqSCtUdCppdCtNdCpzdCtFdCpndCxTWzEwXT1QdCpZK1R0Kmx0K010KmN0K0V0KlN0LFNbMTFdPVB0KmsrVHQqZnQrTXQqbXQrRXQqQXQsUHQ9d1sxMl0sVHQ9d1sxM10sTXQ9d1sxNF0sRXQ9d1sxNV0sU1sxMl09UHQqVStUdCpydCtNdCpvdCtFdCp2dCxTWzEzXT1QdCpIK1R0Kml0K010KnN0K0V0Kmd0LFNbMTRdPVB0KlkrVHQqbHQrTXQqY3QrRXQqU3QsU1sxNV09UHQqaytUdCpmdCtNdCptdCtFdCpBdCxTfWZ1bmN0aW9uIHgoUyxULHcpe3ZhciBVPXdbMF0sSD13WzFdLFk9d1syXSxrLHJ0LGl0LGx0LGZ0LG90LHN0LGN0LG10LHZ0LGd0LFN0O3JldHVybiBUPT09Uz8oU1sxMl09VFswXSpVK1RbNF0qSCtUWzhdKlkrVFsxMl0sU1sxM109VFsxXSpVK1RbNV0qSCtUWzldKlkrVFsxM10sU1sxNF09VFsyXSpVK1RbNl0qSCtUWzEwXSpZK1RbMTRdLFNbMTVdPVRbM10qVStUWzddKkgrVFsxMV0qWStUWzE1XSk6KGs9VFswXSxydD1UWzFdLGl0PVRbMl0sbHQ9VFszXSxmdD1UWzRdLG90PVRbNV0sc3Q9VFs2XSxjdD1UWzddLG10PVRbOF0sdnQ9VFs5XSxndD1UWzEwXSxTdD1UWzExXSxTWzBdPWssU1sxXT1ydCxTWzJdPWl0LFNbM109bHQsU1s0XT1mdCxTWzVdPW90LFNbNl09c3QsU1s3XT1jdCxTWzhdPW10LFNbOV09dnQsU1sxMF09Z3QsU1sxMV09U3QsU1sxMl09aypVK2Z0KkgrbXQqWStUWzEyXSxTWzEzXT1ydCpVK290KkgrdnQqWStUWzEzXSxTWzE0XT1pdCpVK3N0KkgrZ3QqWStUWzE0XSxTWzE1XT1sdCpVK2N0KkgrU3QqWStUWzE1XSksU31mdW5jdGlvbiBtKFMsVCx3KXt2YXIgVT13WzBdLEg9d1sxXSxZPXdbMl07cmV0dXJuIFNbMF09VFswXSpVLFNbMV09VFsxXSpVLFNbMl09VFsyXSpVLFNbM109VFszXSpVLFNbNF09VFs0XSpILFNbNV09VFs1XSpILFNbNl09VFs2XSpILFNbN109VFs3XSpILFNbOF09VFs4XSpZLFNbOV09VFs5XSpZLFNbMTBdPVRbMTBdKlksU1sxMV09VFsxMV0qWSxTWzEyXT1UWzEyXSxTWzEzXT1UWzEzXSxTWzE0XT1UWzE0XSxTWzE1XT1UWzE1XSxTfWZ1bmN0aW9uIE8oUyxULHcsVSl7dmFyIEg9VVswXSxZPVVbMV0saz1VWzJdLHJ0PU1hdGguaHlwb3QoSCxZLGspLGl0LGx0LGZ0LG90LHN0LGN0LG10LHZ0LGd0LFN0LEF0LFB0LFR0LE10LEV0LCR0LFd0LEZ0LFV0LEd0LEh0LEt0LEx0LGt0O3JldHVybiBydDxyLkVQU0lMT04/bnVsbDoocnQ9MS9ydCxIKj1ydCxZKj1ydCxrKj1ydCxpdD1NYXRoLnNpbih3KSxsdD1NYXRoLmNvcyh3KSxmdD0xLWx0LG90PVRbMF0sc3Q9VFsxXSxjdD1UWzJdLG10PVRbM10sdnQ9VFs0XSxndD1UWzVdLFN0PVRbNl0sQXQ9VFs3XSxQdD1UWzhdLFR0PVRbOV0sTXQ9VFsxMF0sRXQ9VFsxMV0sJHQ9SCpIKmZ0K2x0LFd0PVkqSCpmdCtrKml0LEZ0PWsqSCpmdC1ZKml0LFV0PUgqWSpmdC1rKml0LEd0PVkqWSpmdCtsdCxIdD1rKlkqZnQrSCppdCxLdD1IKmsqZnQrWSppdCxMdD1ZKmsqZnQtSCppdCxrdD1rKmsqZnQrbHQsU1swXT1vdCokdCt2dCpXdCtQdCpGdCxTWzFdPXN0KiR0K2d0Kld0K1R0KkZ0LFNbMl09Y3QqJHQrU3QqV3QrTXQqRnQsU1szXT1tdCokdCtBdCpXdCtFdCpGdCxTWzRdPW90KlV0K3Z0Kkd0K1B0Kkh0LFNbNV09c3QqVXQrZ3QqR3QrVHQqSHQsU1s2XT1jdCpVdCtTdCpHdCtNdCpIdCxTWzddPW10KlV0K0F0Kkd0K0V0Kkh0LFNbOF09b3QqS3QrdnQqTHQrUHQqa3QsU1s5XT1zdCpLdCtndCpMdCtUdCprdCxTWzEwXT1jdCpLdCtTdCpMdCtNdCprdCxTWzExXT1tdCpLdCtBdCpMdCtFdCprdCxUIT09UyYmKFNbMTJdPVRbMTJdLFNbMTNdPVRbMTNdLFNbMTRdPVRbMTRdLFNbMTVdPVRbMTVdKSxTKX1mdW5jdGlvbiBvKFMsVCx3KXt2YXIgVT1NYXRoLnNpbih3KSxIPU1hdGguY29zKHcpLFk9VFs0XSxrPVRbNV0scnQ9VFs2XSxpdD1UWzddLGx0PVRbOF0sZnQ9VFs5XSxvdD1UWzEwXSxzdD1UWzExXTtyZXR1cm4gVCE9PVMmJihTWzBdPVRbMF0sU1sxXT1UWzFdLFNbMl09VFsyXSxTWzNdPVRbM10sU1sxMl09VFsxMl0sU1sxM109VFsxM10sU1sxNF09VFsxNF0sU1sxNV09VFsxNV0pLFNbNF09WSpIK2x0KlUsU1s1XT1rKkgrZnQqVSxTWzZdPXJ0Kkgrb3QqVSxTWzddPWl0Kkgrc3QqVSxTWzhdPWx0KkgtWSpVLFNbOV09ZnQqSC1rKlUsU1sxMF09b3QqSC1ydCpVLFNbMTFdPXN0KkgtaXQqVSxTfWZ1bmN0aW9uIGgoUyxULHcpe3ZhciBVPU1hdGguc2luKHcpLEg9TWF0aC5jb3ModyksWT1UWzBdLGs9VFsxXSxydD1UWzJdLGl0PVRbM10sbHQ9VFs4XSxmdD1UWzldLG90PVRbMTBdLHN0PVRbMTFdO3JldHVybiBUIT09UyYmKFNbNF09VFs0XSxTWzVdPVRbNV0sU1s2XT1UWzZdLFNbN109VFs3XSxTWzEyXT1UWzEyXSxTWzEzXT1UWzEzXSxTWzE0XT1UWzE0XSxTWzE1XT1UWzE1XSksU1swXT1ZKkgtbHQqVSxTWzFdPWsqSC1mdCpVLFNbMl09cnQqSC1vdCpVLFNbM109aXQqSC1zdCpVLFNbOF09WSpVK2x0KkgsU1s5XT1rKlUrZnQqSCxTWzEwXT1ydCpVK290KkgsU1sxMV09aXQqVStzdCpILFN9ZnVuY3Rpb24gYyhTLFQsdyl7dmFyIFU9TWF0aC5zaW4odyksSD1NYXRoLmNvcyh3KSxZPVRbMF0saz1UWzFdLHJ0PVRbMl0saXQ9VFszXSxsdD1UWzRdLGZ0PVRbNV0sb3Q9VFs2XSxzdD1UWzddO3JldHVybiBUIT09UyYmKFNbOF09VFs4XSxTWzldPVRbOV0sU1sxMF09VFsxMF0sU1sxMV09VFsxMV0sU1sxMl09VFsxMl0sU1sxM109VFsxM10sU1sxNF09VFsxNF0sU1sxNV09VFsxNV0pLFNbMF09WSpIK2x0KlUsU1sxXT1rKkgrZnQqVSxTWzJdPXJ0Kkgrb3QqVSxTWzNdPWl0Kkgrc3QqVSxTWzRdPWx0KkgtWSpVLFNbNV09ZnQqSC1rKlUsU1s2XT1vdCpILXJ0KlUsU1s3XT1zdCpILWl0KlUsU31mdW5jdGlvbiBnKFMsVCl7cmV0dXJuIFNbMF09MSxTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s1XT0xLFNbNl09MCxTWzddPTAsU1s4XT0wLFNbOV09MCxTWzEwXT0xLFNbMTFdPTAsU1sxMl09VFswXSxTWzEzXT1UWzFdLFNbMTRdPVRbMl0sU1sxNV09MSxTfWZ1bmN0aW9uIGIoUyxUKXtyZXR1cm4gU1swXT1UWzBdLFNbMV09MCxTWzJdPTAsU1szXT0wLFNbNF09MCxTWzVdPVRbMV0sU1s2XT0wLFNbN109MCxTWzhdPTAsU1s5XT0wLFNbMTBdPVRbMl0sU1sxMV09MCxTWzEyXT0wLFNbMTNdPTAsU1sxNF09MCxTWzE1XT0xLFN9ZnVuY3Rpb24gRShTLFQsdyl7dmFyIFU9d1swXSxIPXdbMV0sWT13WzJdLGs9TWF0aC5oeXBvdChVLEgsWSkscnQsaXQsbHQ7cmV0dXJuIGs8ci5FUFNJTE9OP251bGw6KGs9MS9rLFUqPWssSCo9ayxZKj1rLHJ0PU1hdGguc2luKFQpLGl0PU1hdGguY29zKFQpLGx0PTEtaXQsU1swXT1VKlUqbHQraXQsU1sxXT1IKlUqbHQrWSpydCxTWzJdPVkqVSpsdC1IKnJ0LFNbM109MCxTWzRdPVUqSCpsdC1ZKnJ0LFNbNV09SCpIKmx0K2l0LFNbNl09WSpIKmx0K1UqcnQsU1s3XT0wLFNbOF09VSpZKmx0K0gqcnQsU1s5XT1IKlkqbHQtVSpydCxTWzEwXT1ZKlkqbHQraXQsU1sxMV09MCxTWzEyXT0wLFNbMTNdPTAsU1sxNF09MCxTWzE1XT0xLFMpfWZ1bmN0aW9uIEEoUyxUKXt2YXIgdz1NYXRoLnNpbihUKSxVPU1hdGguY29zKFQpO3JldHVybiBTWzBdPTEsU1sxXT0wLFNbMl09MCxTWzNdPTAsU1s0XT0wLFNbNV09VSxTWzZdPXcsU1s3XT0wLFNbOF09MCxTWzldPS13LFNbMTBdPVUsU1sxMV09MCxTWzEyXT0wLFNbMTNdPTAsU1sxNF09MCxTWzE1XT0xLFN9ZnVuY3Rpb24gTChTLFQpe3ZhciB3PU1hdGguc2luKFQpLFU9TWF0aC5jb3MoVCk7cmV0dXJuIFNbMF09VSxTWzFdPTAsU1syXT0tdyxTWzNdPTAsU1s0XT0wLFNbNV09MSxTWzZdPTAsU1s3XT0wLFNbOF09dyxTWzldPTAsU1sxMF09VSxTWzExXT0wLFNbMTJdPTAsU1sxM109MCxTWzE0XT0wLFNbMTVdPTEsU31mdW5jdGlvbiBNKFMsVCl7dmFyIHc9TWF0aC5zaW4oVCksVT1NYXRoLmNvcyhUKTtyZXR1cm4gU1swXT1VLFNbMV09dyxTWzJdPTAsU1szXT0wLFNbNF09LXcsU1s1XT1VLFNbNl09MCxTWzddPTAsU1s4XT0wLFNbOV09MCxTWzEwXT0xLFNbMTFdPTAsU1sxMl09MCxTWzEzXT0wLFNbMTRdPTAsU1sxNV09MSxTfWZ1bmN0aW9uIEkoUyxULHcpe3ZhciBVPVRbMF0sSD1UWzFdLFk9VFsyXSxrPVRbM10scnQ9VStVLGl0PUgrSCxsdD1ZK1ksZnQ9VSpydCxvdD1VKml0LHN0PVUqbHQsY3Q9SCppdCxtdD1IKmx0LHZ0PVkqbHQsZ3Q9aypydCxTdD1rKml0LEF0PWsqbHQ7cmV0dXJuIFNbMF09MS0oY3QrdnQpLFNbMV09b3QrQXQsU1syXT1zdC1TdCxTWzNdPTAsU1s0XT1vdC1BdCxTWzVdPTEtKGZ0K3Z0KSxTWzZdPW10K2d0LFNbN109MCxTWzhdPXN0K1N0LFNbOV09bXQtZ3QsU1sxMF09MS0oZnQrY3QpLFNbMTFdPTAsU1sxMl09d1swXSxTWzEzXT13WzFdLFNbMTRdPXdbMl0sU1sxNV09MSxTfWZ1bmN0aW9uIEQoUyxUKXt2YXIgdz1uZXcgci5BUlJBWV9UWVBFKDMpLFU9LVRbMF0sSD0tVFsxXSxZPS1UWzJdLGs9VFszXSxydD1UWzRdLGl0PVRbNV0sbHQ9VFs2XSxmdD1UWzddLG90PVUqVStIKkgrWSpZK2sqaztyZXR1cm4gb3Q+MD8od1swXT0ocnQqaytmdCpVK2l0KlktbHQqSCkqMi9vdCx3WzFdPShpdCprK2Z0KkgrbHQqVS1ydCpZKSoyL290LHdbMl09KGx0KmsrZnQqWStydCpILWl0KlUpKjIvb3QpOih3WzBdPShydCprK2Z0KlUraXQqWS1sdCpIKSoyLHdbMV09KGl0KmsrZnQqSCtsdCpVLXJ0KlkpKjIsd1syXT0obHQqaytmdCpZK3J0KkgtaXQqVSkqMiksSShTLFQsdyksU31mdW5jdGlvbiBSKFMsVCl7cmV0dXJuIFNbMF09VFsxMl0sU1sxXT1UWzEzXSxTWzJdPVRbMTRdLFN9ZnVuY3Rpb24gQyhTLFQpe3ZhciB3PVRbMF0sVT1UWzFdLEg9VFsyXSxZPVRbNF0saz1UWzVdLHJ0PVRbNl0saXQ9VFs4XSxsdD1UWzldLGZ0PVRbMTBdO3JldHVybiBTWzBdPU1hdGguaHlwb3QodyxVLEgpLFNbMV09TWF0aC5oeXBvdChZLGsscnQpLFNbMl09TWF0aC5oeXBvdChpdCxsdCxmdCksU31mdW5jdGlvbiBCKFMsVCl7dmFyIHc9bmV3IHIuQVJSQVlfVFlQRSgzKTtDKHcsVCk7dmFyIFU9MS93WzBdLEg9MS93WzFdLFk9MS93WzJdLGs9VFswXSpVLHJ0PVRbMV0qSCxpdD1UWzJdKlksbHQ9VFs0XSpVLGZ0PVRbNV0qSCxvdD1UWzZdKlksc3Q9VFs4XSpVLGN0PVRbOV0qSCxtdD1UWzEwXSpZLHZ0PWsrZnQrbXQsZ3Q9MDtyZXR1cm4gdnQ+MD8oZ3Q9TWF0aC5zcXJ0KHZ0KzEpKjIsU1szXT0uMjUqZ3QsU1swXT0ob3QtY3QpL2d0LFNbMV09KHN0LWl0KS9ndCxTWzJdPShydC1sdCkvZ3QpOms+ZnQmJms+bXQ/KGd0PU1hdGguc3FydCgxK2stZnQtbXQpKjIsU1szXT0ob3QtY3QpL2d0LFNbMF09LjI1Kmd0LFNbMV09KHJ0K2x0KS9ndCxTWzJdPShzdCtpdCkvZ3QpOmZ0Pm10PyhndD1NYXRoLnNxcnQoMStmdC1rLW10KSoyLFNbM109KHN0LWl0KS9ndCxTWzBdPShydCtsdCkvZ3QsU1sxXT0uMjUqZ3QsU1syXT0ob3QrY3QpL2d0KTooZ3Q9TWF0aC5zcXJ0KDErbXQtay1mdCkqMixTWzNdPShydC1sdCkvZ3QsU1swXT0oc3QraXQpL2d0LFNbMV09KG90K2N0KS9ndCxTWzJdPS4yNSpndCksU31mdW5jdGlvbiB6KFMsVCx3LFUpe3ZhciBIPVRbMF0sWT1UWzFdLGs9VFsyXSxydD1UWzNdLGl0PUgrSCxsdD1ZK1ksZnQ9aytrLG90PUgqaXQsc3Q9SCpsdCxjdD1IKmZ0LG10PVkqbHQsdnQ9WSpmdCxndD1rKmZ0LFN0PXJ0Kml0LEF0PXJ0Kmx0LFB0PXJ0KmZ0LFR0PVVbMF0sTXQ9VVsxXSxFdD1VWzJdO3JldHVybiBTWzBdPSgxLShtdCtndCkpKlR0LFNbMV09KHN0K1B0KSpUdCxTWzJdPShjdC1BdCkqVHQsU1szXT0wLFNbNF09KHN0LVB0KSpNdCxTWzVdPSgxLShvdCtndCkpKk10LFNbNl09KHZ0K1N0KSpNdCxTWzddPTAsU1s4XT0oY3QrQXQpKkV0LFNbOV09KHZ0LVN0KSpFdCxTWzEwXT0oMS0ob3QrbXQpKSpFdCxTWzExXT0wLFNbMTJdPXdbMF0sU1sxM109d1sxXSxTWzE0XT13WzJdLFNbMTVdPTEsU31mdW5jdGlvbiBLKFMsVCx3LFUsSCl7dmFyIFk9VFswXSxrPVRbMV0scnQ9VFsyXSxpdD1UWzNdLGx0PVkrWSxmdD1rK2ssb3Q9cnQrcnQsc3Q9WSpsdCxjdD1ZKmZ0LG10PVkqb3QsdnQ9aypmdCxndD1rKm90LFN0PXJ0Km90LEF0PWl0Kmx0LFB0PWl0KmZ0LFR0PWl0Km90LE10PVVbMF0sRXQ9VVsxXSwkdD1VWzJdLFd0PUhbMF0sRnQ9SFsxXSxVdD1IWzJdLEd0PSgxLSh2dCtTdCkpKk10LEh0PShjdCtUdCkqTXQsS3Q9KG10LVB0KSpNdCxMdD0oY3QtVHQpKkV0LGt0PSgxLShzdCtTdCkpKkV0LFRlPShndCtBdCkqRXQsTWU9KG10K1B0KSokdCxuaT0oZ3QtQXQpKiR0LGlpPSgxLShzdCt2dCkpKiR0O3JldHVybiBTWzBdPUd0LFNbMV09SHQsU1syXT1LdCxTWzNdPTAsU1s0XT1MdCxTWzVdPWt0LFNbNl09VGUsU1s3XT0wLFNbOF09TWUsU1s5XT1uaSxTWzEwXT1paSxTWzExXT0wLFNbMTJdPXdbMF0rV3QtKEd0Kld0K0x0KkZ0K01lKlV0KSxTWzEzXT13WzFdK0Z0LShIdCpXdCtrdCpGdCtuaSpVdCksU1sxNF09d1syXStVdC0oS3QqV3QrVGUqRnQraWkqVXQpLFNbMTVdPTEsU31mdW5jdGlvbiBRKFMsVCl7dmFyIHc9VFswXSxVPVRbMV0sSD1UWzJdLFk9VFszXSxrPXcrdyxydD1VK1UsaXQ9SCtILGx0PXcqayxmdD1VKmssb3Q9VSpydCxzdD1IKmssY3Q9SCpydCxtdD1IKml0LHZ0PVkqayxndD1ZKnJ0LFN0PVkqaXQ7cmV0dXJuIFNbMF09MS1vdC1tdCxTWzFdPWZ0K1N0LFNbMl09c3QtZ3QsU1szXT0wLFNbNF09ZnQtU3QsU1s1XT0xLWx0LW10LFNbNl09Y3QrdnQsU1s3XT0wLFNbOF09c3QrZ3QsU1s5XT1jdC12dCxTWzEwXT0xLWx0LW90LFNbMTFdPTAsU1sxMl09MCxTWzEzXT0wLFNbMTRdPTAsU1sxNV09MSxTfWZ1bmN0aW9uIF8oUyxULHcsVSxILFksayl7dmFyIHJ0PTEvKHctVCksaXQ9MS8oSC1VKSxsdD0xLyhZLWspO3JldHVybiBTWzBdPVkqMipydCxTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s1XT1ZKjIqaXQsU1s2XT0wLFNbN109MCxTWzhdPSh3K1QpKnJ0LFNbOV09KEgrVSkqaXQsU1sxMF09KGsrWSkqbHQsU1sxMV09LTEsU1sxMl09MCxTWzEzXT0wLFNbMTRdPWsqWSoyKmx0LFNbMTVdPTAsU31mdW5jdGlvbiBGKFMsVCx3LFUsSCl7dmFyIFk9MS9NYXRoLnRhbihULzIpLGs7cmV0dXJuIFNbMF09WS93LFNbMV09MCxTWzJdPTAsU1szXT0wLFNbNF09MCxTWzVdPVksU1s2XT0wLFNbN109MCxTWzhdPTAsU1s5XT0wLFNbMTFdPS0xLFNbMTJdPTAsU1sxM109MCxTWzE1XT0wLEghPW51bGwmJkghPT0xLzA/KGs9MS8oVS1IKSxTWzEwXT0oSCtVKSprLFNbMTRdPTIqSCpVKmspOihTWzEwXT0tMSxTWzE0XT0tMipVKSxTfWZ1bmN0aW9uIEcoUyxULHcsVSl7dmFyIEg9TWF0aC50YW4oVC51cERlZ3JlZXMqTWF0aC5QSS8xODApLFk9TWF0aC50YW4oVC5kb3duRGVncmVlcypNYXRoLlBJLzE4MCksaz1NYXRoLnRhbihULmxlZnREZWdyZWVzKk1hdGguUEkvMTgwKSxydD1NYXRoLnRhbihULnJpZ2h0RGVncmVlcypNYXRoLlBJLzE4MCksaXQ9Mi8oaytydCksbHQ9Mi8oSCtZKTtyZXR1cm4gU1swXT1pdCxTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s1XT1sdCxTWzZdPTAsU1s3XT0wLFNbOF09LSgoay1ydCkqaXQqLjUpLFNbOV09KEgtWSkqbHQqLjUsU1sxMF09VS8ody1VKSxTWzExXT0tMSxTWzEyXT0wLFNbMTNdPTAsU1sxNF09VSp3Lyh3LVUpLFNbMTVdPTAsU31mdW5jdGlvbiBYKFMsVCx3LFUsSCxZLGspe3ZhciBydD0xLyhULXcpLGl0PTEvKFUtSCksbHQ9MS8oWS1rKTtyZXR1cm4gU1swXT0tMipydCxTWzFdPTAsU1syXT0wLFNbM109MCxTWzRdPTAsU1s1XT0tMippdCxTWzZdPTAsU1s3XT0wLFNbOF09MCxTWzldPTAsU1sxMF09MipsdCxTWzExXT0wLFNbMTJdPShUK3cpKnJ0LFNbMTNdPShIK1UpKml0LFNbMTRdPShrK1kpKmx0LFNbMTVdPTEsU31mdW5jdGlvbiBaKFMsVCx3LFUpe3ZhciBILFksayxydCxpdCxsdCxmdCxvdCxzdCxjdCxtdD1UWzBdLHZ0PVRbMV0sZ3Q9VFsyXSxTdD1VWzBdLEF0PVVbMV0sUHQ9VVsyXSxUdD13WzBdLE10PXdbMV0sRXQ9d1syXTtyZXR1cm4gTWF0aC5hYnMobXQtVHQpPHIuRVBTSUxPTiYmTWF0aC5hYnModnQtTXQpPHIuRVBTSUxPTiYmTWF0aC5hYnMoZ3QtRXQpPHIuRVBTSUxPTj9mKFMpOihmdD1tdC1UdCxvdD12dC1NdCxzdD1ndC1FdCxjdD0xL01hdGguaHlwb3QoZnQsb3Qsc3QpLGZ0Kj1jdCxvdCo9Y3Qsc3QqPWN0LEg9QXQqc3QtUHQqb3QsWT1QdCpmdC1TdCpzdCxrPVN0Km90LUF0KmZ0LGN0PU1hdGguaHlwb3QoSCxZLGspLGN0PyhjdD0xL2N0LEgqPWN0LFkqPWN0LGsqPWN0KTooSD0wLFk9MCxrPTApLHJ0PW90Kmstc3QqWSxpdD1zdCpILWZ0KmssbHQ9ZnQqWS1vdCpILGN0PU1hdGguaHlwb3QocnQsaXQsbHQpLGN0PyhjdD0xL2N0LHJ0Kj1jdCxpdCo9Y3QsbHQqPWN0KToocnQ9MCxpdD0wLGx0PTApLFNbMF09SCxTWzFdPXJ0LFNbMl09ZnQsU1szXT0wLFNbNF09WSxTWzVdPWl0LFNbNl09b3QsU1s3XT0wLFNbOF09ayxTWzldPWx0LFNbMTBdPXN0LFNbMTFdPTAsU1sxMl09LShIKm10K1kqdnQraypndCksU1sxM109LShydCptdCtpdCp2dCtsdCpndCksU1sxNF09LShmdCptdCtvdCp2dCtzdCpndCksU1sxNV09MSxTKX1mdW5jdGlvbiB0dChTLFQsdyxVKXt2YXIgSD1UWzBdLFk9VFsxXSxrPVRbMl0scnQ9VVswXSxpdD1VWzFdLGx0PVVbMl0sZnQ9SC13WzBdLG90PVktd1sxXSxzdD1rLXdbMl0sY3Q9ZnQqZnQrb3Qqb3Qrc3Qqc3Q7Y3Q+MCYmKGN0PTEvTWF0aC5zcXJ0KGN0KSxmdCo9Y3Qsb3QqPWN0LHN0Kj1jdCk7dmFyIG10PWl0KnN0LWx0Km90LHZ0PWx0KmZ0LXJ0KnN0LGd0PXJ0Km90LWl0KmZ0O3JldHVybiBjdD1tdCptdCt2dCp2dCtndCpndCxjdD4wJiYoY3Q9MS9NYXRoLnNxcnQoY3QpLG10Kj1jdCx2dCo9Y3QsZ3QqPWN0KSxTWzBdPW10LFNbMV09dnQsU1syXT1ndCxTWzNdPTAsU1s0XT1vdCpndC1zdCp2dCxTWzVdPXN0Km10LWZ0Kmd0LFNbNl09ZnQqdnQtb3QqbXQsU1s3XT0wLFNbOF09ZnQsU1s5XT1vdCxTWzEwXT1zdCxTWzExXT0wLFNbMTJdPUgsU1sxM109WSxTWzE0XT1rLFNbMTVdPTEsU31mdW5jdGlvbiBudChTKXtyZXR1cm4ibWF0NCgiK1NbMF0rIiwgIitTWzFdKyIsICIrU1syXSsiLCAiK1NbM10rIiwgIitTWzRdKyIsICIrU1s1XSsiLCAiK1NbNl0rIiwgIitTWzddKyIsICIrU1s4XSsiLCAiK1NbOV0rIiwgIitTWzEwXSsiLCAiK1NbMTFdKyIsICIrU1sxMl0rIiwgIitTWzEzXSsiLCAiK1NbMTRdKyIsICIrU1sxNV0rIikifWZ1bmN0aW9uIHEoUyl7cmV0dXJuIE1hdGguaHlwb3QoU1swXSxTWzFdLFNbMl0sU1szXSxTWzRdLFNbNV0sU1s2XSxTWzddLFNbOF0sU1s5XSxTWzEwXSxTWzExXSxTWzEyXSxTWzEzXSxTWzE0XSxTWzE1XSl9ZnVuY3Rpb24gaHQoUyxULHcpe3JldHVybiBTWzBdPVRbMF0rd1swXSxTWzFdPVRbMV0rd1sxXSxTWzJdPVRbMl0rd1syXSxTWzNdPVRbM10rd1szXSxTWzRdPVRbNF0rd1s0XSxTWzVdPVRbNV0rd1s1XSxTWzZdPVRbNl0rd1s2XSxTWzddPVRbN10rd1s3XSxTWzhdPVRbOF0rd1s4XSxTWzldPVRbOV0rd1s5XSxTWzEwXT1UWzEwXSt3WzEwXSxTWzExXT1UWzExXSt3WzExXSxTWzEyXT1UWzEyXSt3WzEyXSxTWzEzXT1UWzEzXSt3WzEzXSxTWzE0XT1UWzE0XSt3WzE0XSxTWzE1XT1UWzE1XSt3WzE1XSxTfWZ1bmN0aW9uIHV0KFMsVCx3KXtyZXR1cm4gU1swXT1UWzBdLXdbMF0sU1sxXT1UWzFdLXdbMV0sU1syXT1UWzJdLXdbMl0sU1szXT1UWzNdLXdbM10sU1s0XT1UWzRdLXdbNF0sU1s1XT1UWzVdLXdbNV0sU1s2XT1UWzZdLXdbNl0sU1s3XT1UWzddLXdbN10sU1s4XT1UWzhdLXdbOF0sU1s5XT1UWzldLXdbOV0sU1sxMF09VFsxMF0td1sxMF0sU1sxMV09VFsxMV0td1sxMV0sU1sxMl09VFsxMl0td1sxMl0sU1sxM109VFsxM10td1sxM10sU1sxNF09VFsxNF0td1sxNF0sU1sxNV09VFsxNV0td1sxNV0sU31mdW5jdGlvbiBqKFMsVCx3KXtyZXR1cm4gU1swXT1UWzBdKncsU1sxXT1UWzFdKncsU1syXT1UWzJdKncsU1szXT1UWzNdKncsU1s0XT1UWzRdKncsU1s1XT1UWzVdKncsU1s2XT1UWzZdKncsU1s3XT1UWzddKncsU1s4XT1UWzhdKncsU1s5XT1UWzldKncsU1sxMF09VFsxMF0qdyxTWzExXT1UWzExXSp3LFNbMTJdPVRbMTJdKncsU1sxM109VFsxM10qdyxTWzE0XT1UWzE0XSp3LFNbMTVdPVRbMTVdKncsU31mdW5jdGlvbiBXKFMsVCx3LFUpe3JldHVybiBTWzBdPVRbMF0rd1swXSpVLFNbMV09VFsxXSt3WzFdKlUsU1syXT1UWzJdK3dbMl0qVSxTWzNdPVRbM10rd1szXSpVLFNbNF09VFs0XSt3WzRdKlUsU1s1XT1UWzVdK3dbNV0qVSxTWzZdPVRbNl0rd1s2XSpVLFNbN109VFs3XSt3WzddKlUsU1s4XT1UWzhdK3dbOF0qVSxTWzldPVRbOV0rd1s5XSpVLFNbMTBdPVRbMTBdK3dbMTBdKlUsU1sxMV09VFsxMV0rd1sxMV0qVSxTWzEyXT1UWzEyXSt3WzEyXSpVLFNbMTNdPVRbMTNdK3dbMTNdKlUsU1sxNF09VFsxNF0rd1sxNF0qVSxTWzE1XT1UWzE1XSt3WzE1XSpVLFN9ZnVuY3Rpb24gVihTLFQpe3JldHVybiBTWzBdPT09VFswXSYmU1sxXT09PVRbMV0mJlNbMl09PT1UWzJdJiZTWzNdPT09VFszXSYmU1s0XT09PVRbNF0mJlNbNV09PT1UWzVdJiZTWzZdPT09VFs2XSYmU1s3XT09PVRbN10mJlNbOF09PT1UWzhdJiZTWzldPT09VFs5XSYmU1sxMF09PT1UWzEwXSYmU1sxMV09PT1UWzExXSYmU1sxMl09PT1UWzEyXSYmU1sxM109PT1UWzEzXSYmU1sxNF09PT1UWzE0XSYmU1sxNV09PT1UWzE1XX1mdW5jdGlvbiBKKFMsVCl7dmFyIHc9U1swXSxVPVNbMV0sSD1TWzJdLFk9U1szXSxrPVNbNF0scnQ9U1s1XSxpdD1TWzZdLGx0PVNbN10sZnQ9U1s4XSxvdD1TWzldLHN0PVNbMTBdLGN0PVNbMTFdLG10PVNbMTJdLHZ0PVNbMTNdLGd0PVNbMTRdLFN0PVNbMTVdLEF0PVRbMF0sUHQ9VFsxXSxUdD1UWzJdLE10PVRbM10sRXQ9VFs0XSwkdD1UWzVdLFd0PVRbNl0sRnQ9VFs3XSxVdD1UWzhdLEd0PVRbOV0sSHQ9VFsxMF0sS3Q9VFsxMV0sTHQ9VFsxMl0sa3Q9VFsxM10sVGU9VFsxNF0sTWU9VFsxNV07cmV0dXJuIE1hdGguYWJzKHctQXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhBdCkpJiZNYXRoLmFicyhVLVB0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoUHQpKSYmTWF0aC5hYnMoSC1UdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEgpLE1hdGguYWJzKFR0KSkmJk1hdGguYWJzKFktTXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhZKSxNYXRoLmFicyhNdCkpJiZNYXRoLmFicyhrLUV0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoayksTWF0aC5hYnMoRXQpKSYmTWF0aC5hYnMocnQtJHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhydCksTWF0aC5hYnMoJHQpKSYmTWF0aC5hYnMoaXQtV3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhpdCksTWF0aC5hYnMoV3QpKSYmTWF0aC5hYnMobHQtRnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhsdCksTWF0aC5hYnMoRnQpKSYmTWF0aC5hYnMoZnQtVXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhmdCksTWF0aC5hYnMoVXQpKSYmTWF0aC5hYnMob3QtR3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhvdCksTWF0aC5hYnMoR3QpKSYmTWF0aC5hYnMoc3QtSHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhzdCksTWF0aC5hYnMoSHQpKSYmTWF0aC5hYnMoY3QtS3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhjdCksTWF0aC5hYnMoS3QpKSYmTWF0aC5hYnMobXQtTHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhtdCksTWF0aC5hYnMoTHQpKSYmTWF0aC5hYnModnQta3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh2dCksTWF0aC5hYnMoa3QpKSYmTWF0aC5hYnMoZ3QtVGUpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhndCksTWF0aC5hYnMoVGUpKSYmTWF0aC5hYnMoU3QtTWUpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhTdCksTWF0aC5hYnMoTWUpKX12YXIgTj1QLCQ9dXR9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXRBeGlzQW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZ2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImdldEFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImNhbGN1bGF0ZVciLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiZXhwIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImxuIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInBvdyIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJzbGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJmcm9tTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJmcm9tRXVsZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gen0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gS30pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFF9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIG50fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJyb3RhdGlvblRvIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJzcWxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHV0fSksdC5kKGUsInNldEF4ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KTt2YXIgcj10KDIpLG49dCg1KSxpPXQoOCksYT10KDkpO2Z1bmN0aW9uIGwoKXt2YXIgVz1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFdbMF09MCxXWzFdPTAsV1syXT0wKSxXWzNdPTEsV31mdW5jdGlvbiBzKFcpe3JldHVybiBXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzNdPTEsV31mdW5jdGlvbiBmKFcsVixKKXtKPUoqLjU7dmFyIE49TWF0aC5zaW4oSik7cmV0dXJuIFdbMF09TipWWzBdLFdbMV09TipWWzFdLFdbMl09TipWWzJdLFdbM109TWF0aC5jb3MoSiksV31mdW5jdGlvbiB2KFcsVil7dmFyIEo9TWF0aC5hY29zKFZbM10pKjIsTj1NYXRoLnNpbihKLzIpO3JldHVybiBOPnIuRVBTSUxPTj8oV1swXT1WWzBdL04sV1sxXT1WWzFdL04sV1syXT1WWzJdL04pOihXWzBdPTEsV1sxXT0wLFdbMl09MCksSn1mdW5jdGlvbiBkKFcsVil7dmFyIEo9UShXLFYpO3JldHVybiBNYXRoLmFjb3MoMipKKkotMSl9ZnVuY3Rpb24gcChXLFYsSil7dmFyIE49VlswXSwkPVZbMV0sUz1WWzJdLFQ9VlszXSx3PUpbMF0sVT1KWzFdLEg9SlsyXSxZPUpbM107cmV0dXJuIFdbMF09TipZK1QqdyskKkgtUypVLFdbMV09JCpZK1QqVStTKnctTipILFdbMl09UypZK1QqSCtOKlUtJCp3LFdbM109VCpZLU4qdy0kKlUtUypILFd9ZnVuY3Rpb24geShXLFYsSil7Sio9LjU7dmFyIE49VlswXSwkPVZbMV0sUz1WWzJdLFQ9VlszXSx3PU1hdGguc2luKEopLFU9TWF0aC5jb3MoSik7cmV0dXJuIFdbMF09TipVK1QqdyxXWzFdPSQqVStTKncsV1syXT1TKlUtJCp3LFdbM109VCpVLU4qdyxXfWZ1bmN0aW9uIFAoVyxWLEope0oqPS41O3ZhciBOPVZbMF0sJD1WWzFdLFM9VlsyXSxUPVZbM10sdz1NYXRoLnNpbihKKSxVPU1hdGguY29zKEopO3JldHVybiBXWzBdPU4qVS1TKncsV1sxXT0kKlUrVCp3LFdbMl09UypVK04qdyxXWzNdPVQqVS0kKncsV31mdW5jdGlvbiB4KFcsVixKKXtKKj0uNTt2YXIgTj1WWzBdLCQ9VlsxXSxTPVZbMl0sVD1WWzNdLHc9TWF0aC5zaW4oSiksVT1NYXRoLmNvcyhKKTtyZXR1cm4gV1swXT1OKlUrJCp3LFdbMV09JCpVLU4qdyxXWzJdPVMqVStUKncsV1szXT1UKlUtUyp3LFd9ZnVuY3Rpb24gbShXLFYpe3ZhciBKPVZbMF0sTj1WWzFdLCQ9VlsyXTtyZXR1cm4gV1swXT1KLFdbMV09TixXWzJdPSQsV1szXT1NYXRoLnNxcnQoTWF0aC5hYnMoMS1KKkotTipOLSQqJCkpLFd9ZnVuY3Rpb24gTyhXLFYpe3ZhciBKPVZbMF0sTj1WWzFdLCQ9VlsyXSxTPVZbM10sVD1NYXRoLnNxcnQoSipKK04qTiskKiQpLHc9TWF0aC5leHAoUyksVT1UPjA/dypNYXRoLnNpbihUKS9UOjA7cmV0dXJuIFdbMF09SipVLFdbMV09TipVLFdbMl09JCpVLFdbM109dypNYXRoLmNvcyhUKSxXfWZ1bmN0aW9uIG8oVyxWKXt2YXIgSj1WWzBdLE49VlsxXSwkPVZbMl0sUz1WWzNdLFQ9TWF0aC5zcXJ0KEoqSitOKk4rJCokKSx3PVQ+MD9NYXRoLmF0YW4yKFQsUykvVDowO3JldHVybiBXWzBdPUoqdyxXWzFdPU4qdyxXWzJdPSQqdyxXWzNdPS41Kk1hdGgubG9nKEoqSitOKk4rJCokK1MqUyksV31mdW5jdGlvbiBoKFcsVixKKXtyZXR1cm4gbyhXLFYpLEsoVyxXLEopLE8oVyxXKSxXfWZ1bmN0aW9uIGMoVyxWLEosTil7dmFyICQ9VlswXSxTPVZbMV0sVD1WWzJdLHc9VlszXSxVPUpbMF0sSD1KWzFdLFk9SlsyXSxrPUpbM10scnQsaXQsbHQsZnQsb3Q7cmV0dXJuIGl0PSQqVStTKkgrVCpZK3cqayxpdDwwJiYoaXQ9LWl0LFU9LVUsSD0tSCxZPS1ZLGs9LWspLDEtaXQ+ci5FUFNJTE9OPyhydD1NYXRoLmFjb3MoaXQpLGx0PU1hdGguc2luKHJ0KSxmdD1NYXRoLnNpbigoMS1OKSpydCkvbHQsb3Q9TWF0aC5zaW4oTipydCkvbHQpOihmdD0xLU4sb3Q9TiksV1swXT1mdCokK290KlUsV1sxXT1mdCpTK290KkgsV1syXT1mdCpUK290KlksV1szXT1mdCp3K290KmssV31mdW5jdGlvbiBnKFcpe3ZhciBWPXIuUkFORE9NKCksSj1yLlJBTkRPTSgpLE49ci5SQU5ET00oKSwkPU1hdGguc3FydCgxLVYpLFM9TWF0aC5zcXJ0KFYpO3JldHVybiBXWzBdPSQqTWF0aC5zaW4oMipNYXRoLlBJKkopLFdbMV09JCpNYXRoLmNvcygyKk1hdGguUEkqSiksV1syXT1TKk1hdGguc2luKDIqTWF0aC5QSSpOKSxXWzNdPVMqTWF0aC5jb3MoMipNYXRoLlBJKk4pLFd9ZnVuY3Rpb24gYihXLFYpe3ZhciBKPVZbMF0sTj1WWzFdLCQ9VlsyXSxTPVZbM10sVD1KKkorTipOKyQqJCtTKlMsdz1UPzEvVDowO3JldHVybiBXWzBdPS1KKncsV1sxXT0tTip3LFdbMl09LSQqdyxXWzNdPVMqdyxXfWZ1bmN0aW9uIEUoVyxWKXtyZXR1cm4gV1swXT0tVlswXSxXWzFdPS1WWzFdLFdbMl09LVZbMl0sV1szXT1WWzNdLFd9ZnVuY3Rpb24gQShXLFYpe3ZhciBKPVZbMF0rVls0XStWWzhdLE47aWYoSj4wKU49TWF0aC5zcXJ0KEorMSksV1szXT0uNSpOLE49LjUvTixXWzBdPShWWzVdLVZbN10pKk4sV1sxXT0oVls2XS1WWzJdKSpOLFdbMl09KFZbMV0tVlszXSkqTjtlbHNle3ZhciAkPTA7Vls0XT5WWzBdJiYoJD0xKSxWWzhdPlZbJCozKyRdJiYoJD0yKTt2YXIgUz0oJCsxKSUzLFQ9KCQrMiklMztOPU1hdGguc3FydChWWyQqMyskXS1WW1MqMytTXS1WW1QqMytUXSsxKSxXWyRdPS41Kk4sTj0uNS9OLFdbM109KFZbUyozK1RdLVZbVCozK1NdKSpOLFdbU109KFZbUyozKyRdK1ZbJCozK1NdKSpOLFdbVF09KFZbVCozKyRdK1ZbJCozK1RdKSpOfXJldHVybiBXfWZ1bmN0aW9uIEwoVyxWLEosTil7dmFyICQ9LjUqTWF0aC5QSS8xODA7Vio9JCxKKj0kLE4qPSQ7dmFyIFM9TWF0aC5zaW4oViksVD1NYXRoLmNvcyhWKSx3PU1hdGguc2luKEopLFU9TWF0aC5jb3MoSiksSD1NYXRoLnNpbihOKSxZPU1hdGguY29zKE4pO3JldHVybiBXWzBdPVMqVSpZLVQqdypILFdbMV09VCp3KlkrUypVKkgsV1syXT1UKlUqSC1TKncqWSxXWzNdPVQqVSpZK1MqdypILFd9ZnVuY3Rpb24gTShXKXtyZXR1cm4icXVhdCgiK1dbMF0rIiwgIitXWzFdKyIsICIrV1syXSsiLCAiK1dbM10rIikifXZhciBJPWEuY2xvbmUsRD1hLmZyb21WYWx1ZXMsUj1hLmNvcHksQz1hLnNldCxCPWEuYWRkLHo9cCxLPWEuc2NhbGUsUT1hLmRvdCxfPWEubGVycCxGPWEubGVuZ3RoLEc9RixYPWEuc3F1YXJlZExlbmd0aCxaPVgsdHQ9YS5ub3JtYWxpemUsbnQ9YS5leGFjdEVxdWFscyxxPWEuZXF1YWxzLGh0PWZ1bmN0aW9uKCl7dmFyIFc9aS5jcmVhdGUoKSxWPWkuZnJvbVZhbHVlcygxLDAsMCksSj1pLmZyb21WYWx1ZXMoMCwxLDApO3JldHVybiBmdW5jdGlvbihOLCQsUyl7dmFyIFQ9aS5kb3QoJCxTKTtyZXR1cm4gVDwtLjk5OTk5OT8oaS5jcm9zcyhXLFYsJCksaS5sZW4oVyk8MWUtNiYmaS5jcm9zcyhXLEosJCksaS5ub3JtYWxpemUoVyxXKSxmKE4sVyxNYXRoLlBJKSxOKTpUPi45OTk5OTk/KE5bMF09MCxOWzFdPTAsTlsyXT0wLE5bM109MSxOKTooaS5jcm9zcyhXLCQsUyksTlswXT1XWzBdLE5bMV09V1sxXSxOWzJdPVdbMl0sTlszXT0xK1QsdHQoTixOKSl9fSgpLHV0PWZ1bmN0aW9uKCl7dmFyIFc9bCgpLFY9bCgpO3JldHVybiBmdW5jdGlvbihKLE4sJCxTLFQsdyl7cmV0dXJuIGMoVyxOLFQsdyksYyhWLCQsUyx3KSxjKEosVyxWLDIqdyooMS13KSksSn19KCksaj1mdW5jdGlvbigpe3ZhciBXPW4uY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKFYsSixOLCQpe3JldHVybiBXWzBdPU5bMF0sV1szXT1OWzFdLFdbNl09TlsyXSxXWzFdPSRbMF0sV1s0XT0kWzFdLFdbN109JFsyXSxXWzJdPS1KWzBdLFdbNV09LUpbMV0sV1s4XT0tSlsyXSx0dChWLEEoVixXKSl9fSgpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImhlcm1pdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiYmV6aWVyIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gen0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsInRyYW5zZm9ybU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIFF9KSx0LmQoZSwidHJhbnNmb3JtUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIG50fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiB1dH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgVD1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFRbMF09MCxUWzFdPTAsVFsyXT0wKSxUfWZ1bmN0aW9uIGkoVCl7dmFyIHc9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gd1swXT1UWzBdLHdbMV09VFsxXSx3WzJdPVRbMl0sd31mdW5jdGlvbiBhKFQpe3ZhciB3PVRbMF0sVT1UWzFdLEg9VFsyXTtyZXR1cm4gTWF0aC5oeXBvdCh3LFUsSCl9ZnVuY3Rpb24gbChULHcsVSl7dmFyIEg9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gSFswXT1ULEhbMV09dyxIWzJdPVUsSH1mdW5jdGlvbiBzKFQsdyl7cmV0dXJuIFRbMF09d1swXSxUWzFdPXdbMV0sVFsyXT13WzJdLFR9ZnVuY3Rpb24gZihULHcsVSxIKXtyZXR1cm4gVFswXT13LFRbMV09VSxUWzJdPUgsVH1mdW5jdGlvbiB2KFQsdyxVKXtyZXR1cm4gVFswXT13WzBdK1VbMF0sVFsxXT13WzFdK1VbMV0sVFsyXT13WzJdK1VbMl0sVH1mdW5jdGlvbiBkKFQsdyxVKXtyZXR1cm4gVFswXT13WzBdLVVbMF0sVFsxXT13WzFdLVVbMV0sVFsyXT13WzJdLVVbMl0sVH1mdW5jdGlvbiBwKFQsdyxVKXtyZXR1cm4gVFswXT13WzBdKlVbMF0sVFsxXT13WzFdKlVbMV0sVFsyXT13WzJdKlVbMl0sVH1mdW5jdGlvbiB5KFQsdyxVKXtyZXR1cm4gVFswXT13WzBdL1VbMF0sVFsxXT13WzFdL1VbMV0sVFsyXT13WzJdL1VbMl0sVH1mdW5jdGlvbiBQKFQsdyl7cmV0dXJuIFRbMF09TWF0aC5jZWlsKHdbMF0pLFRbMV09TWF0aC5jZWlsKHdbMV0pLFRbMl09TWF0aC5jZWlsKHdbMl0pLFR9ZnVuY3Rpb24geChULHcpe3JldHVybiBUWzBdPU1hdGguZmxvb3Iod1swXSksVFsxXT1NYXRoLmZsb29yKHdbMV0pLFRbMl09TWF0aC5mbG9vcih3WzJdKSxUfWZ1bmN0aW9uIG0oVCx3LFUpe3JldHVybiBUWzBdPU1hdGgubWluKHdbMF0sVVswXSksVFsxXT1NYXRoLm1pbih3WzFdLFVbMV0pLFRbMl09TWF0aC5taW4od1syXSxVWzJdKSxUfWZ1bmN0aW9uIE8oVCx3LFUpe3JldHVybiBUWzBdPU1hdGgubWF4KHdbMF0sVVswXSksVFsxXT1NYXRoLm1heCh3WzFdLFVbMV0pLFRbMl09TWF0aC5tYXgod1syXSxVWzJdKSxUfWZ1bmN0aW9uIG8oVCx3KXtyZXR1cm4gVFswXT1NYXRoLnJvdW5kKHdbMF0pLFRbMV09TWF0aC5yb3VuZCh3WzFdKSxUWzJdPU1hdGgucm91bmQod1syXSksVH1mdW5jdGlvbiBoKFQsdyxVKXtyZXR1cm4gVFswXT13WzBdKlUsVFsxXT13WzFdKlUsVFsyXT13WzJdKlUsVH1mdW5jdGlvbiBjKFQsdyxVLEgpe3JldHVybiBUWzBdPXdbMF0rVVswXSpILFRbMV09d1sxXStVWzFdKkgsVFsyXT13WzJdK1VbMl0qSCxUfWZ1bmN0aW9uIGcoVCx3KXt2YXIgVT13WzBdLVRbMF0sSD13WzFdLVRbMV0sWT13WzJdLVRbMl07cmV0dXJuIE1hdGguaHlwb3QoVSxILFkpfWZ1bmN0aW9uIGIoVCx3KXt2YXIgVT13WzBdLVRbMF0sSD13WzFdLVRbMV0sWT13WzJdLVRbMl07cmV0dXJuIFUqVStIKkgrWSpZfWZ1bmN0aW9uIEUoVCl7dmFyIHc9VFswXSxVPVRbMV0sSD1UWzJdO3JldHVybiB3KncrVSpVK0gqSH1mdW5jdGlvbiBBKFQsdyl7cmV0dXJuIFRbMF09LXdbMF0sVFsxXT0td1sxXSxUWzJdPS13WzJdLFR9ZnVuY3Rpb24gTChULHcpe3JldHVybiBUWzBdPTEvd1swXSxUWzFdPTEvd1sxXSxUWzJdPTEvd1syXSxUfWZ1bmN0aW9uIE0oVCx3KXt2YXIgVT13WzBdLEg9d1sxXSxZPXdbMl0saz1VKlUrSCpIK1kqWTtyZXR1cm4gaz4wJiYoaz0xL01hdGguc3FydChrKSksVFswXT13WzBdKmssVFsxXT13WzFdKmssVFsyXT13WzJdKmssVH1mdW5jdGlvbiBJKFQsdyl7cmV0dXJuIFRbMF0qd1swXStUWzFdKndbMV0rVFsyXSp3WzJdfWZ1bmN0aW9uIEQoVCx3LFUpe3ZhciBIPXdbMF0sWT13WzFdLGs9d1syXSxydD1VWzBdLGl0PVVbMV0sbHQ9VVsyXTtyZXR1cm4gVFswXT1ZKmx0LWsqaXQsVFsxXT1rKnJ0LUgqbHQsVFsyXT1IKml0LVkqcnQsVH1mdW5jdGlvbiBSKFQsdyxVLEgpe3ZhciBZPXdbMF0saz13WzFdLHJ0PXdbMl07cmV0dXJuIFRbMF09WStIKihVWzBdLVkpLFRbMV09aytIKihVWzFdLWspLFRbMl09cnQrSCooVVsyXS1ydCksVH1mdW5jdGlvbiBDKFQsdyxVLEgsWSxrKXt2YXIgcnQ9ayprLGl0PXJ0KigyKmstMykrMSxsdD1ydCooay0yKStrLGZ0PXJ0KihrLTEpLG90PXJ0KigzLTIqayk7cmV0dXJuIFRbMF09d1swXSppdCtVWzBdKmx0K0hbMF0qZnQrWVswXSpvdCxUWzFdPXdbMV0qaXQrVVsxXSpsdCtIWzFdKmZ0K1lbMV0qb3QsVFsyXT13WzJdKml0K1VbMl0qbHQrSFsyXSpmdCtZWzJdKm90LFR9ZnVuY3Rpb24gQihULHcsVSxILFksayl7dmFyIHJ0PTEtayxpdD1ydCpydCxsdD1rKmssZnQ9aXQqcnQsb3Q9MyprKml0LHN0PTMqbHQqcnQsY3Q9bHQqaztyZXR1cm4gVFswXT13WzBdKmZ0K1VbMF0qb3QrSFswXSpzdCtZWzBdKmN0LFRbMV09d1sxXSpmdCtVWzFdKm90K0hbMV0qc3QrWVsxXSpjdCxUWzJdPXdbMl0qZnQrVVsyXSpvdCtIWzJdKnN0K1lbMl0qY3QsVH1mdW5jdGlvbiB6KFQsdyl7dz13fHwxO3ZhciBVPXIuUkFORE9NKCkqMipNYXRoLlBJLEg9ci5SQU5ET00oKSoyLTEsWT1NYXRoLnNxcnQoMS1IKkgpKnc7cmV0dXJuIFRbMF09TWF0aC5jb3MoVSkqWSxUWzFdPU1hdGguc2luKFUpKlksVFsyXT1IKncsVH1mdW5jdGlvbiBLKFQsdyxVKXt2YXIgSD13WzBdLFk9d1sxXSxrPXdbMl0scnQ9VVszXSpIK1VbN10qWStVWzExXSprK1VbMTVdO3JldHVybiBydD1ydHx8MSxUWzBdPShVWzBdKkgrVVs0XSpZK1VbOF0qaytVWzEyXSkvcnQsVFsxXT0oVVsxXSpIK1VbNV0qWStVWzldKmsrVVsxM10pL3J0LFRbMl09KFVbMl0qSCtVWzZdKlkrVVsxMF0qaytVWzE0XSkvcnQsVH1mdW5jdGlvbiBRKFQsdyxVKXt2YXIgSD13WzBdLFk9d1sxXSxrPXdbMl07cmV0dXJuIFRbMF09SCpVWzBdK1kqVVszXStrKlVbNl0sVFsxXT1IKlVbMV0rWSpVWzRdK2sqVVs3XSxUWzJdPUgqVVsyXStZKlVbNV0raypVWzhdLFR9ZnVuY3Rpb24gXyhULHcsVSl7dmFyIEg9VVswXSxZPVVbMV0saz1VWzJdLHJ0PVVbM10saXQ9d1swXSxsdD13WzFdLGZ0PXdbMl0sb3Q9WSpmdC1rKmx0LHN0PWsqaXQtSCpmdCxjdD1IKmx0LVkqaXQsbXQ9WSpjdC1rKnN0LHZ0PWsqb3QtSCpjdCxndD1IKnN0LVkqb3QsU3Q9cnQqMjtyZXR1cm4gb3QqPVN0LHN0Kj1TdCxjdCo9U3QsbXQqPTIsdnQqPTIsZ3QqPTIsVFswXT1pdCtvdCttdCxUWzFdPWx0K3N0K3Z0LFRbMl09ZnQrY3QrZ3QsVH1mdW5jdGlvbiBGKFQsdyxVLEgpe3ZhciBZPVtdLGs9W107cmV0dXJuIFlbMF09d1swXS1VWzBdLFlbMV09d1sxXS1VWzFdLFlbMl09d1syXS1VWzJdLGtbMF09WVswXSxrWzFdPVlbMV0qTWF0aC5jb3MoSCktWVsyXSpNYXRoLnNpbihIKSxrWzJdPVlbMV0qTWF0aC5zaW4oSCkrWVsyXSpNYXRoLmNvcyhIKSxUWzBdPWtbMF0rVVswXSxUWzFdPWtbMV0rVVsxXSxUWzJdPWtbMl0rVVsyXSxUfWZ1bmN0aW9uIEcoVCx3LFUsSCl7dmFyIFk9W10saz1bXTtyZXR1cm4gWVswXT13WzBdLVVbMF0sWVsxXT13WzFdLVVbMV0sWVsyXT13WzJdLVVbMl0sa1swXT1ZWzJdKk1hdGguc2luKEgpK1lbMF0qTWF0aC5jb3MoSCksa1sxXT1ZWzFdLGtbMl09WVsyXSpNYXRoLmNvcyhIKS1ZWzBdKk1hdGguc2luKEgpLFRbMF09a1swXStVWzBdLFRbMV09a1sxXStVWzFdLFRbMl09a1syXStVWzJdLFR9ZnVuY3Rpb24gWChULHcsVSxIKXt2YXIgWT1bXSxrPVtdO3JldHVybiBZWzBdPXdbMF0tVVswXSxZWzFdPXdbMV0tVVsxXSxZWzJdPXdbMl0tVVsyXSxrWzBdPVlbMF0qTWF0aC5jb3MoSCktWVsxXSpNYXRoLnNpbihIKSxrWzFdPVlbMF0qTWF0aC5zaW4oSCkrWVsxXSpNYXRoLmNvcyhIKSxrWzJdPVlbMl0sVFswXT1rWzBdK1VbMF0sVFsxXT1rWzFdK1VbMV0sVFsyXT1rWzJdK1VbMl0sVH1mdW5jdGlvbiBaKFQsdyl7dmFyIFU9VFswXSxIPVRbMV0sWT1UWzJdLGs9d1swXSxydD13WzFdLGl0PXdbMl0sbHQ9TWF0aC5zcXJ0KFUqVStIKkgrWSpZKSxmdD1NYXRoLnNxcnQoayprK3J0KnJ0K2l0Kml0KSxvdD1sdCpmdCxzdD1vdCYmSShULHcpL290O3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoc3QsLTEpLDEpKX1mdW5jdGlvbiB0dChUKXtyZXR1cm4gVFswXT0wLFRbMV09MCxUWzJdPTAsVH1mdW5jdGlvbiBudChUKXtyZXR1cm4idmVjMygiK1RbMF0rIiwgIitUWzFdKyIsICIrVFsyXSsiKSJ9ZnVuY3Rpb24gcShULHcpe3JldHVybiBUWzBdPT09d1swXSYmVFsxXT09PXdbMV0mJlRbMl09PT13WzJdfWZ1bmN0aW9uIGh0KFQsdyl7dmFyIFU9VFswXSxIPVRbMV0sWT1UWzJdLGs9d1swXSxydD13WzFdLGl0PXdbMl07cmV0dXJuIE1hdGguYWJzKFUtayk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFUpLE1hdGguYWJzKGspKSYmTWF0aC5hYnMoSC1ydCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEgpLE1hdGguYWJzKHJ0KSkmJk1hdGguYWJzKFktaXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhZKSxNYXRoLmFicyhpdCkpfXZhciB1dD1kLGo9cCxXPXksVj1nLEo9YixOPWEsJD1FLFM9ZnVuY3Rpb24oKXt2YXIgVD1uKCk7cmV0dXJuIGZ1bmN0aW9uKHcsVSxILFksayxydCl7dmFyIGl0LGx0O2ZvcihVfHwoVT0zKSxIfHwoSD0wKSxZP2x0PU1hdGgubWluKFkqVStILHcubGVuZ3RoKTpsdD13Lmxlbmd0aCxpdD1IO2l0PGx0O2l0Kz1VKVRbMF09d1tpdF0sVFsxXT13W2l0KzFdLFRbMl09d1tpdCsyXSxrKFQsVCxydCksd1tpdF09VFswXSx3W2l0KzFdPVRbMV0sd1tpdCsyXT1UWzJdO3JldHVybiB3fX0oKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwidHJhbnNmb3JtTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiB6fSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBYfSksdC5kKGUsImRpdiIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBudH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJmb3JFYWNoIixmdW5jdGlvbigpe3JldHVybiB1dH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBqPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoalswXT0wLGpbMV09MCxqWzJdPTAsalszXT0wKSxqfWZ1bmN0aW9uIGkoail7dmFyIFc9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gV1swXT1qWzBdLFdbMV09alsxXSxXWzJdPWpbMl0sV1szXT1qWzNdLFd9ZnVuY3Rpb24gYShqLFcsVixKKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBOWzBdPWosTlsxXT1XLE5bMl09VixOWzNdPUosTn1mdW5jdGlvbiBsKGosVyl7cmV0dXJuIGpbMF09V1swXSxqWzFdPVdbMV0salsyXT1XWzJdLGpbM109V1szXSxqfWZ1bmN0aW9uIHMoaixXLFYsSixOKXtyZXR1cm4galswXT1XLGpbMV09VixqWzJdPUosalszXT1OLGp9ZnVuY3Rpb24gZihqLFcsVil7cmV0dXJuIGpbMF09V1swXStWWzBdLGpbMV09V1sxXStWWzFdLGpbMl09V1syXStWWzJdLGpbM109V1szXStWWzNdLGp9ZnVuY3Rpb24gdihqLFcsVil7cmV0dXJuIGpbMF09V1swXS1WWzBdLGpbMV09V1sxXS1WWzFdLGpbMl09V1syXS1WWzJdLGpbM109V1szXS1WWzNdLGp9ZnVuY3Rpb24gZChqLFcsVil7cmV0dXJuIGpbMF09V1swXSpWWzBdLGpbMV09V1sxXSpWWzFdLGpbMl09V1syXSpWWzJdLGpbM109V1szXSpWWzNdLGp9ZnVuY3Rpb24gcChqLFcsVil7cmV0dXJuIGpbMF09V1swXS9WWzBdLGpbMV09V1sxXS9WWzFdLGpbMl09V1syXS9WWzJdLGpbM109V1szXS9WWzNdLGp9ZnVuY3Rpb24geShqLFcpe3JldHVybiBqWzBdPU1hdGguY2VpbChXWzBdKSxqWzFdPU1hdGguY2VpbChXWzFdKSxqWzJdPU1hdGguY2VpbChXWzJdKSxqWzNdPU1hdGguY2VpbChXWzNdKSxqfWZ1bmN0aW9uIFAoaixXKXtyZXR1cm4galswXT1NYXRoLmZsb29yKFdbMF0pLGpbMV09TWF0aC5mbG9vcihXWzFdKSxqWzJdPU1hdGguZmxvb3IoV1syXSksalszXT1NYXRoLmZsb29yKFdbM10pLGp9ZnVuY3Rpb24geChqLFcsVil7cmV0dXJuIGpbMF09TWF0aC5taW4oV1swXSxWWzBdKSxqWzFdPU1hdGgubWluKFdbMV0sVlsxXSksalsyXT1NYXRoLm1pbihXWzJdLFZbMl0pLGpbM109TWF0aC5taW4oV1szXSxWWzNdKSxqfWZ1bmN0aW9uIG0oaixXLFYpe3JldHVybiBqWzBdPU1hdGgubWF4KFdbMF0sVlswXSksalsxXT1NYXRoLm1heChXWzFdLFZbMV0pLGpbMl09TWF0aC5tYXgoV1syXSxWWzJdKSxqWzNdPU1hdGgubWF4KFdbM10sVlszXSksan1mdW5jdGlvbiBPKGosVyl7cmV0dXJuIGpbMF09TWF0aC5yb3VuZChXWzBdKSxqWzFdPU1hdGgucm91bmQoV1sxXSksalsyXT1NYXRoLnJvdW5kKFdbMl0pLGpbM109TWF0aC5yb3VuZChXWzNdKSxqfWZ1bmN0aW9uIG8oaixXLFYpe3JldHVybiBqWzBdPVdbMF0qVixqWzFdPVdbMV0qVixqWzJdPVdbMl0qVixqWzNdPVdbM10qVixqfWZ1bmN0aW9uIGgoaixXLFYsSil7cmV0dXJuIGpbMF09V1swXStWWzBdKkosalsxXT1XWzFdK1ZbMV0qSixqWzJdPVdbMl0rVlsyXSpKLGpbM109V1szXStWWzNdKkosan1mdW5jdGlvbiBjKGosVyl7dmFyIFY9V1swXS1qWzBdLEo9V1sxXS1qWzFdLE49V1syXS1qWzJdLCQ9V1szXS1qWzNdO3JldHVybiBNYXRoLmh5cG90KFYsSixOLCQpfWZ1bmN0aW9uIGcoaixXKXt2YXIgVj1XWzBdLWpbMF0sSj1XWzFdLWpbMV0sTj1XWzJdLWpbMl0sJD1XWzNdLWpbM107cmV0dXJuIFYqVitKKkorTipOKyQqJH1mdW5jdGlvbiBiKGope3ZhciBXPWpbMF0sVj1qWzFdLEo9alsyXSxOPWpbM107cmV0dXJuIE1hdGguaHlwb3QoVyxWLEosTil9ZnVuY3Rpb24gRShqKXt2YXIgVz1qWzBdLFY9alsxXSxKPWpbMl0sTj1qWzNdO3JldHVybiBXKlcrVipWK0oqSitOKk59ZnVuY3Rpb24gQShqLFcpe3JldHVybiBqWzBdPS1XWzBdLGpbMV09LVdbMV0salsyXT0tV1syXSxqWzNdPS1XWzNdLGp9ZnVuY3Rpb24gTChqLFcpe3JldHVybiBqWzBdPTEvV1swXSxqWzFdPTEvV1sxXSxqWzJdPTEvV1syXSxqWzNdPTEvV1szXSxqfWZ1bmN0aW9uIE0oaixXKXt2YXIgVj1XWzBdLEo9V1sxXSxOPVdbMl0sJD1XWzNdLFM9VipWK0oqSitOKk4rJCokO3JldHVybiBTPjAmJihTPTEvTWF0aC5zcXJ0KFMpKSxqWzBdPVYqUyxqWzFdPUoqUyxqWzJdPU4qUyxqWzNdPSQqUyxqfWZ1bmN0aW9uIEkoaixXKXtyZXR1cm4galswXSpXWzBdK2pbMV0qV1sxXStqWzJdKldbMl0ralszXSpXWzNdfWZ1bmN0aW9uIEQoaixXLFYsSil7dmFyIE49VlswXSpKWzFdLVZbMV0qSlswXSwkPVZbMF0qSlsyXS1WWzJdKkpbMF0sUz1WWzBdKkpbM10tVlszXSpKWzBdLFQ9VlsxXSpKWzJdLVZbMl0qSlsxXSx3PVZbMV0qSlszXS1WWzNdKkpbMV0sVT1WWzJdKkpbM10tVlszXSpKWzJdLEg9V1swXSxZPVdbMV0saz1XWzJdLHJ0PVdbM107cmV0dXJuIGpbMF09WSpVLWsqdytydCpULGpbMV09LShIKlUpK2sqUy1ydCokLGpbMl09SCp3LVkqUytydCpOLGpbM109LShIKlQpK1kqJC1rKk4san1mdW5jdGlvbiBSKGosVyxWLEope3ZhciBOPVdbMF0sJD1XWzFdLFM9V1syXSxUPVdbM107cmV0dXJuIGpbMF09TitKKihWWzBdLU4pLGpbMV09JCtKKihWWzFdLSQpLGpbMl09UytKKihWWzJdLVMpLGpbM109VCtKKihWWzNdLVQpLGp9ZnVuY3Rpb24gQyhqLFcpe1c9V3x8MTt2YXIgVixKLE4sJCxTLFQ7ZG8gVj1yLlJBTkRPTSgpKjItMSxKPXIuUkFORE9NKCkqMi0xLFM9VipWK0oqSjt3aGlsZShTPj0xKTtkbyBOPXIuUkFORE9NKCkqMi0xLCQ9ci5SQU5ET00oKSoyLTEsVD1OKk4rJCokO3doaWxlKFQ+PTEpO3ZhciB3PU1hdGguc3FydCgoMS1TKS9UKTtyZXR1cm4galswXT1XKlYsalsxXT1XKkosalsyXT1XKk4qdyxqWzNdPVcqJCp3LGp9ZnVuY3Rpb24gQihqLFcsVil7dmFyIEo9V1swXSxOPVdbMV0sJD1XWzJdLFM9V1szXTtyZXR1cm4galswXT1WWzBdKkorVls0XSpOK1ZbOF0qJCtWWzEyXSpTLGpbMV09VlsxXSpKK1ZbNV0qTitWWzldKiQrVlsxM10qUyxqWzJdPVZbMl0qSitWWzZdKk4rVlsxMF0qJCtWWzE0XSpTLGpbM109VlszXSpKK1ZbN10qTitWWzExXSokK1ZbMTVdKlMsan1mdW5jdGlvbiB6KGosVyxWKXt2YXIgSj1XWzBdLE49V1sxXSwkPVdbMl0sUz1WWzBdLFQ9VlsxXSx3PVZbMl0sVT1WWzNdLEg9VSpKK1QqJC13Kk4sWT1VKk4rdypKLVMqJCxrPVUqJCtTKk4tVCpKLHJ0PS1TKkotVCpOLXcqJDtyZXR1cm4galswXT1IKlUrcnQqLVMrWSotdy1rKi1ULGpbMV09WSpVK3J0Ki1UK2sqLVMtSCotdyxqWzJdPWsqVStydCotdytIKi1ULVkqLVMsalszXT1XWzNdLGp9ZnVuY3Rpb24gSyhqKXtyZXR1cm4galswXT0wLGpbMV09MCxqWzJdPTAsalszXT0wLGp9ZnVuY3Rpb24gUShqKXtyZXR1cm4idmVjNCgiK2pbMF0rIiwgIitqWzFdKyIsICIralsyXSsiLCAiK2pbM10rIikifWZ1bmN0aW9uIF8oaixXKXtyZXR1cm4galswXT09PVdbMF0mJmpbMV09PT1XWzFdJiZqWzJdPT09V1syXSYmalszXT09PVdbM119ZnVuY3Rpb24gRihqLFcpe3ZhciBWPWpbMF0sSj1qWzFdLE49alsyXSwkPWpbM10sUz1XWzBdLFQ9V1sxXSx3PVdbMl0sVT1XWzNdO3JldHVybiBNYXRoLmFicyhWLVMpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhWKSxNYXRoLmFicyhTKSkmJk1hdGguYWJzKEotVCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEopLE1hdGguYWJzKFQpKSYmTWF0aC5hYnMoTi13KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTiksTWF0aC5hYnModykpJiZNYXRoLmFicygkLVUpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhVKSl9dmFyIEc9dixYPWQsWj1wLHR0PWMsbnQ9ZyxxPWIsaHQ9RSx1dD1mdW5jdGlvbigpe3ZhciBqPW4oKTtyZXR1cm4gZnVuY3Rpb24oVyxWLEosTiwkLFMpe3ZhciBULHc7Zm9yKFZ8fChWPTQpLEp8fChKPTApLE4/dz1NYXRoLm1pbihOKlYrSixXLmxlbmd0aCk6dz1XLmxlbmd0aCxUPUo7VDx3O1QrPVYpalswXT1XW1RdLGpbMV09V1tUKzFdLGpbMl09V1tUKzJdLGpbM109V1tUKzNdLCQoaixqLFMpLFdbVF09alswXSxXW1QrMV09alsxXSxXW1QrMl09alsyXSxXW1QrM109alszXTtyZXR1cm4gV319KCl9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiZ2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJnZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldFJlYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwic2V0RHVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwicm90YXRlQnlRdWF0QXBwZW5kIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInJvdGF0ZUJ5UXVhdFByZXBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwicm90YXRlQXJvdW5kQXhpcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB6fSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gS30pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBudH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gdXR9KTt2YXIgcj10KDIpLG49dCg3KSxpPXQoNik7ZnVuY3Rpb24gYSgpe3ZhciBqPW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoalswXT0wLGpbMV09MCxqWzJdPTAsals0XT0wLGpbNV09MCxqWzZdPTAsals3XT0wKSxqWzNdPTEsan1mdW5jdGlvbiBsKGope3ZhciBXPW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIFdbMF09alswXSxXWzFdPWpbMV0sV1syXT1qWzJdLFdbM109alszXSxXWzRdPWpbNF0sV1s1XT1qWzVdLFdbNl09als2XSxXWzddPWpbN10sV31mdW5jdGlvbiBzKGosVyxWLEosTiwkLFMsVCl7dmFyIHc9bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gd1swXT1qLHdbMV09Vyx3WzJdPVYsd1szXT1KLHdbNF09Tix3WzVdPSQsd1s2XT1TLHdbN109VCx3fWZ1bmN0aW9uIGYoaixXLFYsSixOLCQsUyl7dmFyIFQ9bmV3IHIuQVJSQVlfVFlQRSg4KTtUWzBdPWosVFsxXT1XLFRbMl09VixUWzNdPUo7dmFyIHc9TiouNSxVPSQqLjUsSD1TKi41O3JldHVybiBUWzRdPXcqSitVKlYtSCpXLFRbNV09VSpKK0gqai13KlYsVFs2XT1IKkordypXLVUqaixUWzddPS13KmotVSpXLUgqVixUfWZ1bmN0aW9uIHYoaixXLFYpe3ZhciBKPVZbMF0qLjUsTj1WWzFdKi41LCQ9VlsyXSouNSxTPVdbMF0sVD1XWzFdLHc9V1syXSxVPVdbM107cmV0dXJuIGpbMF09UyxqWzFdPVQsalsyXT13LGpbM109VSxqWzRdPUoqVStOKnctJCpULGpbNV09TipVKyQqUy1KKncsals2XT0kKlUrSipULU4qUyxqWzddPS1KKlMtTipULSQqdyxqfWZ1bmN0aW9uIGQoaixXKXtyZXR1cm4galswXT0wLGpbMV09MCxqWzJdPTAsalszXT0xLGpbNF09V1swXSouNSxqWzVdPVdbMV0qLjUsals2XT1XWzJdKi41LGpbN109MCxqfWZ1bmN0aW9uIHAoaixXKXtyZXR1cm4galswXT1XWzBdLGpbMV09V1sxXSxqWzJdPVdbMl0salszXT1XWzNdLGpbNF09MCxqWzVdPTAsals2XT0wLGpbN109MCxqfWZ1bmN0aW9uIHkoaixXKXt2YXIgVj1uLmNyZWF0ZSgpO2kuZ2V0Um90YXRpb24oVixXKTt2YXIgSj1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBpLmdldFRyYW5zbGF0aW9uKEosVyksdihqLFYsSiksan1mdW5jdGlvbiBQKGosVyl7cmV0dXJuIGpbMF09V1swXSxqWzFdPVdbMV0salsyXT1XWzJdLGpbM109V1szXSxqWzRdPVdbNF0sals1XT1XWzVdLGpbNl09V1s2XSxqWzddPVdbN10san1mdW5jdGlvbiB4KGope3JldHVybiBqWzBdPTAsalsxXT0wLGpbMl09MCxqWzNdPTEsals0XT0wLGpbNV09MCxqWzZdPTAsals3XT0wLGp9ZnVuY3Rpb24gbShqLFcsVixKLE4sJCxTLFQsdyl7cmV0dXJuIGpbMF09VyxqWzFdPVYsalsyXT1KLGpbM109TixqWzRdPSQsals1XT1TLGpbNl09VCxqWzddPXcsan12YXIgTz1uLmNvcHk7ZnVuY3Rpb24gbyhqLFcpe3JldHVybiBqWzBdPVdbNF0salsxXT1XWzVdLGpbMl09V1s2XSxqWzNdPVdbN10san12YXIgaD1uLmNvcHk7ZnVuY3Rpb24gYyhqLFcpe3JldHVybiBqWzRdPVdbMF0sals1XT1XWzFdLGpbNl09V1syXSxqWzddPVdbM10san1mdW5jdGlvbiBnKGosVyl7dmFyIFY9V1s0XSxKPVdbNV0sTj1XWzZdLCQ9V1s3XSxTPS1XWzBdLFQ9LVdbMV0sdz0tV1syXSxVPVdbM107cmV0dXJuIGpbMF09KFYqVSskKlMrSip3LU4qVCkqMixqWzFdPShKKlUrJCpUK04qUy1WKncpKjIsalsyXT0oTipVKyQqdytWKlQtSipTKSoyLGp9ZnVuY3Rpb24gYihqLFcsVil7dmFyIEo9V1swXSxOPVdbMV0sJD1XWzJdLFM9V1szXSxUPVZbMF0qLjUsdz1WWzFdKi41LFU9VlsyXSouNSxIPVdbNF0sWT1XWzVdLGs9V1s2XSxydD1XWzddO3JldHVybiBqWzBdPUosalsxXT1OLGpbMl09JCxqWzNdPVMsals0XT1TKlQrTipVLSQqdytILGpbNV09Uyp3KyQqVC1KKlUrWSxqWzZdPVMqVStKKnctTipUK2ssals3XT0tSipULU4qdy0kKlUrcnQsan1mdW5jdGlvbiBFKGosVyxWKXt2YXIgSj0tV1swXSxOPS1XWzFdLCQ9LVdbMl0sUz1XWzNdLFQ9V1s0XSx3PVdbNV0sVT1XWzZdLEg9V1s3XSxZPVQqUytIKkordyokLVUqTixrPXcqUytIKk4rVSpKLVQqJCxydD1VKlMrSCokK1QqTi13KkosaXQ9SCpTLVQqSi13Kk4tVSokO3JldHVybiBuLnJvdGF0ZVgoaixXLFYpLEo9alswXSxOPWpbMV0sJD1qWzJdLFM9alszXSxqWzRdPVkqUytpdCpKK2sqJC1ydCpOLGpbNV09aypTK2l0Kk4rcnQqSi1ZKiQsals2XT1ydCpTK2l0KiQrWSpOLWsqSixqWzddPWl0KlMtWSpKLWsqTi1ydCokLGp9ZnVuY3Rpb24gQShqLFcsVil7dmFyIEo9LVdbMF0sTj0tV1sxXSwkPS1XWzJdLFM9V1szXSxUPVdbNF0sdz1XWzVdLFU9V1s2XSxIPVdbN10sWT1UKlMrSCpKK3cqJC1VKk4saz13KlMrSCpOK1UqSi1UKiQscnQ9VSpTK0gqJCtUKk4tdypKLGl0PUgqUy1UKkotdypOLVUqJDtyZXR1cm4gbi5yb3RhdGVZKGosVyxWKSxKPWpbMF0sTj1qWzFdLCQ9alsyXSxTPWpbM10sals0XT1ZKlMraXQqSitrKiQtcnQqTixqWzVdPWsqUytpdCpOK3J0KkotWSokLGpbNl09cnQqUytpdCokK1kqTi1rKkosals3XT1pdCpTLVkqSi1rKk4tcnQqJCxqfWZ1bmN0aW9uIEwoaixXLFYpe3ZhciBKPS1XWzBdLE49LVdbMV0sJD0tV1syXSxTPVdbM10sVD1XWzRdLHc9V1s1XSxVPVdbNl0sSD1XWzddLFk9VCpTK0gqSit3KiQtVSpOLGs9dypTK0gqTitVKkotVCokLHJ0PVUqUytIKiQrVCpOLXcqSixpdD1IKlMtVCpKLXcqTi1VKiQ7cmV0dXJuIG4ucm90YXRlWihqLFcsViksSj1qWzBdLE49alsxXSwkPWpbMl0sUz1qWzNdLGpbNF09WSpTK2l0KkorayokLXJ0Kk4sals1XT1rKlMraXQqTitydCpKLVkqJCxqWzZdPXJ0KlMraXQqJCtZKk4taypKLGpbN109aXQqUy1ZKkotaypOLXJ0KiQsan1mdW5jdGlvbiBNKGosVyxWKXt2YXIgSj1WWzBdLE49VlsxXSwkPVZbMl0sUz1WWzNdLFQ9V1swXSx3PVdbMV0sVT1XWzJdLEg9V1szXTtyZXR1cm4galswXT1UKlMrSCpKK3cqJC1VKk4salsxXT13KlMrSCpOK1UqSi1UKiQsalsyXT1VKlMrSCokK1QqTi13KkosalszXT1IKlMtVCpKLXcqTi1VKiQsVD1XWzRdLHc9V1s1XSxVPVdbNl0sSD1XWzddLGpbNF09VCpTK0gqSit3KiQtVSpOLGpbNV09dypTK0gqTitVKkotVCokLGpbNl09VSpTK0gqJCtUKk4tdypKLGpbN109SCpTLVQqSi13Kk4tVSokLGp9ZnVuY3Rpb24gSShqLFcsVil7dmFyIEo9V1swXSxOPVdbMV0sJD1XWzJdLFM9V1szXSxUPVZbMF0sdz1WWzFdLFU9VlsyXSxIPVZbM107cmV0dXJuIGpbMF09SipIK1MqVCtOKlUtJCp3LGpbMV09TipIK1MqdyskKlQtSipVLGpbMl09JCpIK1MqVStKKnctTipULGpbM109UypILUoqVC1OKnctJCpVLFQ9Vls0XSx3PVZbNV0sVT1WWzZdLEg9Vls3XSxqWzRdPUoqSCtTKlQrTipVLSQqdyxqWzVdPU4qSCtTKncrJCpULUoqVSxqWzZdPSQqSCtTKlUrSip3LU4qVCxqWzddPVMqSC1KKlQtTip3LSQqVSxqfWZ1bmN0aW9uIEQoaixXLFYsSil7aWYoTWF0aC5hYnMoSik8ci5FUFNJTE9OKXJldHVybiBQKGosVyk7dmFyIE49TWF0aC5oeXBvdChWWzBdLFZbMV0sVlsyXSk7Sj1KKi41O3ZhciAkPU1hdGguc2luKEopLFM9JCpWWzBdL04sVD0kKlZbMV0vTix3PSQqVlsyXS9OLFU9TWF0aC5jb3MoSiksSD1XWzBdLFk9V1sxXSxrPVdbMl0scnQ9V1szXTtqWzBdPUgqVStydCpTK1kqdy1rKlQsalsxXT1ZKlUrcnQqVCtrKlMtSCp3LGpbMl09aypVK3J0KncrSCpULVkqUyxqWzNdPXJ0KlUtSCpTLVkqVC1rKnc7dmFyIGl0PVdbNF0sbHQ9V1s1XSxmdD1XWzZdLG90PVdbN107cmV0dXJuIGpbNF09aXQqVStvdCpTK2x0KnctZnQqVCxqWzVdPWx0KlUrb3QqVCtmdCpTLWl0Kncsals2XT1mdCpVK290KncraXQqVC1sdCpTLGpbN109b3QqVS1pdCpTLWx0KlQtZnQqdyxqfWZ1bmN0aW9uIFIoaixXLFYpe3JldHVybiBqWzBdPVdbMF0rVlswXSxqWzFdPVdbMV0rVlsxXSxqWzJdPVdbMl0rVlsyXSxqWzNdPVdbM10rVlszXSxqWzRdPVdbNF0rVls0XSxqWzVdPVdbNV0rVls1XSxqWzZdPVdbNl0rVls2XSxqWzddPVdbN10rVls3XSxqfWZ1bmN0aW9uIEMoaixXLFYpe3ZhciBKPVdbMF0sTj1XWzFdLCQ9V1syXSxTPVdbM10sVD1WWzRdLHc9Vls1XSxVPVZbNl0sSD1WWzddLFk9V1s0XSxrPVdbNV0scnQ9V1s2XSxpdD1XWzddLGx0PVZbMF0sZnQ9VlsxXSxvdD1WWzJdLHN0PVZbM107cmV0dXJuIGpbMF09SipzdCtTKmx0K04qb3QtJCpmdCxqWzFdPU4qc3QrUypmdCskKmx0LUoqb3QsalsyXT0kKnN0K1Mqb3QrSipmdC1OKmx0LGpbM109UypzdC1KKmx0LU4qZnQtJCpvdCxqWzRdPUoqSCtTKlQrTipVLSQqdytZKnN0K2l0Kmx0K2sqb3QtcnQqZnQsals1XT1OKkgrUyp3KyQqVC1KKlUraypzdCtpdCpmdCtydCpsdC1ZKm90LGpbNl09JCpIK1MqVStKKnctTipUK3J0KnN0K2l0Km90K1kqZnQtaypsdCxqWzddPVMqSC1KKlQtTip3LSQqVStpdCpzdC1ZKmx0LWsqZnQtcnQqb3Qsan12YXIgQj1DO2Z1bmN0aW9uIHooaixXLFYpe3JldHVybiBqWzBdPVdbMF0qVixqWzFdPVdbMV0qVixqWzJdPVdbMl0qVixqWzNdPVdbM10qVixqWzRdPVdbNF0qVixqWzVdPVdbNV0qVixqWzZdPVdbNl0qVixqWzddPVdbN10qVixqfXZhciBLPW4uZG90O2Z1bmN0aW9uIFEoaixXLFYsSil7dmFyIE49MS1KO3JldHVybiBLKFcsVik8MCYmKEo9LUopLGpbMF09V1swXSpOK1ZbMF0qSixqWzFdPVdbMV0qTitWWzFdKkosalsyXT1XWzJdKk4rVlsyXSpKLGpbM109V1szXSpOK1ZbM10qSixqWzRdPVdbNF0qTitWWzRdKkosals1XT1XWzVdKk4rVls1XSpKLGpbNl09V1s2XSpOK1ZbNl0qSixqWzddPVdbN10qTitWWzddKkosan1mdW5jdGlvbiBfKGosVyl7dmFyIFY9WihXKTtyZXR1cm4galswXT0tV1swXS9WLGpbMV09LVdbMV0vVixqWzJdPS1XWzJdL1YsalszXT1XWzNdL1Ysals0XT0tV1s0XS9WLGpbNV09LVdbNV0vVixqWzZdPS1XWzZdL1Ysals3XT1XWzddL1Ysan1mdW5jdGlvbiBGKGosVyl7cmV0dXJuIGpbMF09LVdbMF0salsxXT0tV1sxXSxqWzJdPS1XWzJdLGpbM109V1szXSxqWzRdPS1XWzRdLGpbNV09LVdbNV0sals2XT0tV1s2XSxqWzddPVdbN10san12YXIgRz1uLmxlbmd0aCxYPUcsWj1uLnNxdWFyZWRMZW5ndGgsdHQ9WjtmdW5jdGlvbiBudChqLFcpe3ZhciBWPVooVyk7aWYoVj4wKXtWPU1hdGguc3FydChWKTt2YXIgSj1XWzBdL1YsTj1XWzFdL1YsJD1XWzJdL1YsUz1XWzNdL1YsVD1XWzRdLHc9V1s1XSxVPVdbNl0sSD1XWzddLFk9SipUK04qdyskKlUrUypIO2pbMF09SixqWzFdPU4salsyXT0kLGpbM109UyxqWzRdPShULUoqWSkvVixqWzVdPSh3LU4qWSkvVixqWzZdPShVLSQqWSkvVixqWzddPShILVMqWSkvVn1yZXR1cm4gan1mdW5jdGlvbiBxKGope3JldHVybiJxdWF0MigiK2pbMF0rIiwgIitqWzFdKyIsICIralsyXSsiLCAiK2pbM10rIiwgIitqWzRdKyIsICIrals1XSsiLCAiK2pbNl0rIiwgIitqWzddKyIpIn1mdW5jdGlvbiBodChqLFcpe3JldHVybiBqWzBdPT09V1swXSYmalsxXT09PVdbMV0mJmpbMl09PT1XWzJdJiZqWzNdPT09V1szXSYmals0XT09PVdbNF0mJmpbNV09PT1XWzVdJiZqWzZdPT09V1s2XSYmals3XT09PVdbN119ZnVuY3Rpb24gdXQoaixXKXt2YXIgVj1qWzBdLEo9alsxXSxOPWpbMl0sJD1qWzNdLFM9als0XSxUPWpbNV0sdz1qWzZdLFU9als3XSxIPVdbMF0sWT1XWzFdLGs9V1syXSxydD1XWzNdLGl0PVdbNF0sbHQ9V1s1XSxmdD1XWzZdLG90PVdbN107cmV0dXJuIE1hdGguYWJzKFYtSCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKEgpKSYmTWF0aC5hYnMoSi1ZKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMoWSkpJiZNYXRoLmFicyhOLWspPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhOKSxNYXRoLmFicyhrKSkmJk1hdGguYWJzKCQtcnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhTLWl0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoUyksTWF0aC5hYnMoaXQpKSYmTWF0aC5hYnMoVC1sdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFQpLE1hdGguYWJzKGx0KSkmJk1hdGguYWJzKHctZnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhmdCkpJiZNYXRoLmFicyhVLW90KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMob3QpKX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJkaXZpZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiY2VpbCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJmbG9vciIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJtaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwibWF4IixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInJvdW5kIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInNxdWFyZWREaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInRyYW5zZm9ybU1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwidHJhbnNmb3JtTWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHp9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gS30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gbnR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiB1dH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKE5bMF09MCxOWzFdPTApLE59ZnVuY3Rpb24gaShOKXt2YXIgJD1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiAkWzBdPU5bMF0sJFsxXT1OWzFdLCR9ZnVuY3Rpb24gYShOLCQpe3ZhciBTPW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIFNbMF09TixTWzFdPSQsU31mdW5jdGlvbiBsKE4sJCl7cmV0dXJuIE5bMF09JFswXSxOWzFdPSRbMV0sTn1mdW5jdGlvbiBzKE4sJCxTKXtyZXR1cm4gTlswXT0kLE5bMV09UyxOfWZ1bmN0aW9uIGYoTiwkLFMpe3JldHVybiBOWzBdPSRbMF0rU1swXSxOWzFdPSRbMV0rU1sxXSxOfWZ1bmN0aW9uIHYoTiwkLFMpe3JldHVybiBOWzBdPSRbMF0tU1swXSxOWzFdPSRbMV0tU1sxXSxOfWZ1bmN0aW9uIGQoTiwkLFMpe3JldHVybiBOWzBdPSRbMF0qU1swXSxOWzFdPSRbMV0qU1sxXSxOfWZ1bmN0aW9uIHAoTiwkLFMpe3JldHVybiBOWzBdPSRbMF0vU1swXSxOWzFdPSRbMV0vU1sxXSxOfWZ1bmN0aW9uIHkoTiwkKXtyZXR1cm4gTlswXT1NYXRoLmNlaWwoJFswXSksTlsxXT1NYXRoLmNlaWwoJFsxXSksTn1mdW5jdGlvbiBQKE4sJCl7cmV0dXJuIE5bMF09TWF0aC5mbG9vcigkWzBdKSxOWzFdPU1hdGguZmxvb3IoJFsxXSksTn1mdW5jdGlvbiB4KE4sJCxTKXtyZXR1cm4gTlswXT1NYXRoLm1pbigkWzBdLFNbMF0pLE5bMV09TWF0aC5taW4oJFsxXSxTWzFdKSxOfWZ1bmN0aW9uIG0oTiwkLFMpe3JldHVybiBOWzBdPU1hdGgubWF4KCRbMF0sU1swXSksTlsxXT1NYXRoLm1heCgkWzFdLFNbMV0pLE59ZnVuY3Rpb24gTyhOLCQpe3JldHVybiBOWzBdPU1hdGgucm91bmQoJFswXSksTlsxXT1NYXRoLnJvdW5kKCRbMV0pLE59ZnVuY3Rpb24gbyhOLCQsUyl7cmV0dXJuIE5bMF09JFswXSpTLE5bMV09JFsxXSpTLE59ZnVuY3Rpb24gaChOLCQsUyxUKXtyZXR1cm4gTlswXT0kWzBdK1NbMF0qVCxOWzFdPSRbMV0rU1sxXSpULE59ZnVuY3Rpb24gYyhOLCQpe3ZhciBTPSRbMF0tTlswXSxUPSRbMV0tTlsxXTtyZXR1cm4gTWF0aC5oeXBvdChTLFQpfWZ1bmN0aW9uIGcoTiwkKXt2YXIgUz0kWzBdLU5bMF0sVD0kWzFdLU5bMV07cmV0dXJuIFMqUytUKlR9ZnVuY3Rpb24gYihOKXt2YXIgJD1OWzBdLFM9TlsxXTtyZXR1cm4gTWF0aC5oeXBvdCgkLFMpfWZ1bmN0aW9uIEUoTil7dmFyICQ9TlswXSxTPU5bMV07cmV0dXJuICQqJCtTKlN9ZnVuY3Rpb24gQShOLCQpe3JldHVybiBOWzBdPS0kWzBdLE5bMV09LSRbMV0sTn1mdW5jdGlvbiBMKE4sJCl7cmV0dXJuIE5bMF09MS8kWzBdLE5bMV09MS8kWzFdLE59ZnVuY3Rpb24gTShOLCQpe3ZhciBTPSRbMF0sVD0kWzFdLHc9UypTK1QqVDtyZXR1cm4gdz4wJiYodz0xL01hdGguc3FydCh3KSksTlswXT0kWzBdKncsTlsxXT0kWzFdKncsTn1mdW5jdGlvbiBJKE4sJCl7cmV0dXJuIE5bMF0qJFswXStOWzFdKiRbMV19ZnVuY3Rpb24gRChOLCQsUyl7dmFyIFQ9JFswXSpTWzFdLSRbMV0qU1swXTtyZXR1cm4gTlswXT1OWzFdPTAsTlsyXT1ULE59ZnVuY3Rpb24gUihOLCQsUyxUKXt2YXIgdz0kWzBdLFU9JFsxXTtyZXR1cm4gTlswXT13K1QqKFNbMF0tdyksTlsxXT1VK1QqKFNbMV0tVSksTn1mdW5jdGlvbiBDKE4sJCl7JD0kfHwxO3ZhciBTPXIuUkFORE9NKCkqMipNYXRoLlBJO3JldHVybiBOWzBdPU1hdGguY29zKFMpKiQsTlsxXT1NYXRoLnNpbihTKSokLE59ZnVuY3Rpb24gQihOLCQsUyl7dmFyIFQ9JFswXSx3PSRbMV07cmV0dXJuIE5bMF09U1swXSpUK1NbMl0qdyxOWzFdPVNbMV0qVCtTWzNdKncsTn1mdW5jdGlvbiB6KE4sJCxTKXt2YXIgVD0kWzBdLHc9JFsxXTtyZXR1cm4gTlswXT1TWzBdKlQrU1syXSp3K1NbNF0sTlsxXT1TWzFdKlQrU1szXSp3K1NbNV0sTn1mdW5jdGlvbiBLKE4sJCxTKXt2YXIgVD0kWzBdLHc9JFsxXTtyZXR1cm4gTlswXT1TWzBdKlQrU1szXSp3K1NbNl0sTlsxXT1TWzFdKlQrU1s0XSp3K1NbN10sTn1mdW5jdGlvbiBRKE4sJCxTKXt2YXIgVD0kWzBdLHc9JFsxXTtyZXR1cm4gTlswXT1TWzBdKlQrU1s0XSp3K1NbMTJdLE5bMV09U1sxXSpUK1NbNV0qdytTWzEzXSxOfWZ1bmN0aW9uIF8oTiwkLFMsVCl7dmFyIHc9JFswXS1TWzBdLFU9JFsxXS1TWzFdLEg9TWF0aC5zaW4oVCksWT1NYXRoLmNvcyhUKTtyZXR1cm4gTlswXT13KlktVSpIK1NbMF0sTlsxXT13KkgrVSpZK1NbMV0sTn1mdW5jdGlvbiBGKE4sJCl7dmFyIFM9TlswXSxUPU5bMV0sdz0kWzBdLFU9JFsxXSxIPU1hdGguc3FydChTKlMrVCpUKSpNYXRoLnNxcnQodyp3K1UqVSksWT1IJiYoUyp3K1QqVSkvSDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KFksLTEpLDEpKX1mdW5jdGlvbiBHKE4pe3JldHVybiBOWzBdPTAsTlsxXT0wLE59ZnVuY3Rpb24gWChOKXtyZXR1cm4idmVjMigiK05bMF0rIiwgIitOWzFdKyIpIn1mdW5jdGlvbiBaKE4sJCl7cmV0dXJuIE5bMF09PT0kWzBdJiZOWzFdPT09JFsxXX1mdW5jdGlvbiB0dChOLCQpe3ZhciBTPU5bMF0sVD1OWzFdLHc9JFswXSxVPSRbMV07cmV0dXJuIE1hdGguYWJzKFMtdyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFMpLE1hdGguYWJzKHcpKSYmTWF0aC5hYnMoVC1VKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVCksTWF0aC5hYnMoVSkpfXZhciBudD1iLHE9dixodD1kLHV0PXAsaj1jLFc9ZyxWPUUsSj1mdW5jdGlvbigpe3ZhciBOPW4oKTtyZXR1cm4gZnVuY3Rpb24oJCxTLFQsdyxVLEgpe3ZhciBZLGs7Zm9yKFN8fChTPTIpLFR8fChUPTApLHc/az1NYXRoLm1pbih3KlMrVCwkLmxlbmd0aCk6az0kLmxlbmd0aCxZPVQ7WTxrO1krPVMpTlswXT0kW1ldLE5bMV09JFtZKzFdLFUoTixOLEgpLCRbWV09TlswXSwkW1krMV09TlsxXTtyZXR1cm4gJH19KCl9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMyk7dC5kKGUsIlJlbmRlcmVyIixmdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHR9KTt2YXIgbj10KDQwKTt0LmQoZSwiRmlndXJlMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH0pO3ZhciBpPXQoNTYpO3QuZChlLCJNZXNoMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdH0pO3ZhciBhPXQoMjkpO3QuZChlLCJNZXNoQ2xvdWQiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH0pO3ZhciBsPXQoMjMpO3QuZChlLCJwYXJzZUZvbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH0pO3ZhciBzPXQoMzEpO3QuZChlLCJwYXJzZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHR9KTt2YXIgZj10KDIxKTt0LmQoZSwiRU5WIixmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSl9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KTt2YXIgcj10KDE0KSxuPXQoMSksaT10KDIwKSxhPXQoMjcpLGw9dCgyNSkscz10KDQwKSxmPXQoNTYpLHY9dCgyOSksZD10KDU5KSxwPXQoMjEpLHk9dCg2Myk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFA9e2F1dG9VcGRhdGU6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGJ1ZmZlclNpemU6MTUwMH0seD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOyAgICAKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7ICAgICAgICAgICAgICAKfQpgLG09YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOwp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdlRleHR1cmVDb29yZC54eSk7Cn0KYCxPPVN5bWJvbCgiZ2xSZW5kZXJlciIpLG89U3ltYm9sKCJjYW52YXNSZW5kZXJlciIpLGg9U3ltYm9sKCJvcHRpb25zIiksYz1TeW1ib2woImdsb2JhbFRyYW5zZm9ybSIpLGc9U3ltYm9sKCJhcHBseUdsb2JhbFRyYW5zZm9ybSIpLGI9U3ltYm9sKCJjYW52YXMiKTtmdW5jdGlvbiBFKE0pe2NvbnN0IEk9TS5nbCxEPU0uZmJvO0QmJkkuYmluZEZyYW1lYnVmZmVyKEkuRlJBTUVCVUZGRVIsRCksTS5fZHJhdygpLEQmJkkuYmluZEZyYW1lYnVmZmVyKEkuRlJBTUVCVUZGRVIsbnVsbCl9ZnVuY3Rpb24gQShNLEksRCxSKXtjb25zdCBDPU0uY3JlYXRlVGV4dHVyZShJLmNhbnZhcyksQj1bW1swLDBdLFtELDBdLFtELFJdLFswLFJdLFswLDBdXV07Qi5jbG9zZWQ9ITA7Y29uc3Qgej1uZXcgZi5kZWZhdWx0KHtjb250b3VyczpCfSk7ei5zZXRUZXh0dXJlKEMpLE0uc2V0TWVzaERhdGEoW3oubWVzaERhdGFdKSxFKE0pLEMuZGVsZXRlKCksSS5jbGVhclJlY3QoMCwwLEQsUiksZGVsZXRlIEkuX2ZpbHRlcn1jbGFzcyBMe2NvbnN0cnVjdG9yKEksRD17fSl7bGV0IFI9RC5jb250ZXh0VHlwZTtpZihSfHwodHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Uj0id2ViZ2wyIjp0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0PT0iZnVuY3Rpb24iP1I9IndlYmdsIjpSPSIyZCIpLCFJLmdldENvbnRleHQpe2NvbnN0IEM9STtJPXtnZXRDb250ZXh0KCl7cmV0dXJuIEN9LHdpZHRoOkQud2lkdGgsaGVpZ2h0OkQuaGVpZ2h0fSxDLmNhbnZhcz1JLFI9IjJkIn1pZih0aGlzW2JdPUksUiE9PSJ3ZWJnbCImJlIhPT0id2ViZ2wyIiYmUiE9PSIyZCIpdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbnRleHQgdHlwZSAke1J9YCk7aWYoRC5jb250ZXh0VHlwZT1SLHRoaXNbaF09T2JqZWN0LmFzc2lnbih7fSxQLEQpLFI9PT0id2ViZ2wifHxSPT09IndlYmdsMiIpe1I9PT0id2ViZ2wyIiYmKHRoaXNbaF0ud2ViZ2wyPSEwKTtjb25zdCBDPW5ldyByLmRlZmF1bHQoSSx0aGlzW2hdKTtSPT09IndlYmdsMiImJiFDLmlzV2ViR0wyJiYoRC5jb250ZXh0VHlwZT0id2ViZ2wiKSxPYmplY3QoeS5jcmVhdGVTaGFkZXJzKShDKSxPYmplY3QoeS5hcHBseVNoYWRlcikoQyksT2JqZWN0KHkuY3JlYXRlQ2xvdWRTaGFkZXJzKShDKTtjb25zdCBCPUMuZ2w7Qi5jbGVhckNvbG9yKDAsMCwwLDApLEIuYmxlbmRGdW5jU2VwYXJhdGUoQi5TUkNfQUxQSEEsQi5PTkVfTUlOVVNfU1JDX0FMUEhBLEIuT05FLEIuT05FX01JTlVTX1NSQ19BTFBIQSksdGhpc1tPXT1DfWVsc2UgdGhpc1tvXT1uZXcgaS5kZWZhdWx0KEksdGhpc1toXSk7dGhpc1tjXT1bMSwwLDAsMCwxLDAsMCwwLDFdLHRoaXMudXBkYXRlUmVzb2x1dGlvbigpfWdldCBjYW52YXMoKXtyZXR1cm4gdGhpc1tiXX1nZXQgY2FudmFzUmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tvXX1nZXQgZ2xSZW5kZXJlcigpe3JldHVybiB0aGlzW09dfWdldCBpc1dlYkdMMigpe3JldHVybiB0aGlzW09dJiZ0aGlzW09dLmlzV2ViR0wyfWdldCBvcHRpb25zKCl7cmV0dXJuIHRoaXNbaF19Z2V0IGdsb2JhbFRyYW5zZm9ybU1hdHJpeCgpe2NvbnN0IEk9dGhpc1tjXTtyZXR1cm5bSVswXSxJWzFdLElbM10sSVs0XSxJWzZdLElbN11dfWdldCB2aWV3TWF0cml4KCl7cmV0dXJuIHRoaXNbY119W2ddKCl7Y29uc3QgST10aGlzW09dfHx0aGlzW29dO2lmKHRoaXNbT10pe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OlJ9PXRoaXMuY2FudmFzO0kudW5pZm9ybXMudmlld01hdHJpeD10aGlzLnZpZXdNYXRyaXgsSS51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4PXRoaXMucHJvamVjdGlvbk1hdHJpeCxJLnVuaWZvcm1zLnVfcmVzb2x1dGlvbj1bRCxSXX19dXBkYXRlUmVzb2x1dGlvbigpe2NvbnN0e3dpZHRoOkksaGVpZ2h0OkR9PXRoaXMuY2FudmFzLFI9WzEsMCwwLDAsMSwwLC1JLzIsLUQvMiwxXSxDPVsyL0ksMCwwLDAsLTIvRCwwLDAsMCwxXSxCPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxSKTt0aGlzLnByb2plY3Rpb25NYXRyaXg9Qix0aGlzW09dJiZ0aGlzW09dLmdsLnZpZXdwb3J0KDAsMCxJLEQpfWNyZWF0ZVRleHR1cmUoSSxEKXtyZXR1cm4odGhpc1tPXXx8dGhpc1tvXSkuY3JlYXRlVGV4dHVyZShJLEQpfWxvYWRUZXh0dXJlKEkse3VzZUltYWdlQml0bWFwOkQ9ITF9PXt9KXtyZXR1cm4odGhpc1tPXXx8dGhpc1tvXSkubG9hZFRleHR1cmUoSSx7dXNlSW1hZ2VCaXRtYXA6RH0pfWNyZWF0ZVRleHQoSSx7Zm9udDpEPSIxNnB4IGFyaWFsIixmaWxsQ29sb3I6Uj1udWxsLHN0cm9rZUNvbG9yOkM9bnVsbCxzdHJva2VXaWR0aDpCPTF9PXt9KXtpZih0aGlzW09dKXtjb25zdCB6PXAuZGVmYXVsdC5jcmVhdGVUZXh0KEkse2ZvbnQ6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpDLHN0cm9rZVdpZHRoOkJ9KTtyZXR1cm57aW1hZ2U6dGhpcy5jcmVhdGVUZXh0dXJlKHouaW1hZ2UpLHJlY3Q6ei5yZWN0fX1yZXR1cm57X2ltZzp7Zm9udDpELGZpbGxDb2xvcjpSLHN0cm9rZUNvbG9yOkMsc3Ryb2tlV2lkdGg6Qix0ZXh0Okl9fX1jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6SSxmcmFnbWVudDpELG9wdGlvbnM6Un09e30pe2lmKHRoaXNbT10pe2NvbnN0IEM9dGhpc1tPXS5jb21waWxlU3luYyhELEkpO3JldHVybiBDLl9hdHRyaWJPcHRzPVIsQ310aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IGNyZWF0ZSB3ZWJnbCBwcm9ncmFtLiIpfWNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6ST14LGZyYWdtZW50OkQ9bSxvcHRpb25zOlJ9PXt9KXtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6SSxmcmFnbWVudDpELG9wdGlvbnM6Un0pfXVzZVByb2dyYW0oSSxEPXt9KXtpZih0aGlzW09dKXtjb25zdCBSPU9iamVjdC5hc3NpZ24oe30sSS5fYXR0cmliT3B0cyxEKTtyZXR1cm4gdGhpc1tPXS51c2VQcm9ncmFtKEksUil9dGhyb3cgbmV3IEVycm9yKCJDb250ZXh0IDJEIGNhbm5vdCB1c2Ugd2ViZ2wgcHJvZ3JhbS4iKX1kZWxldGVUZXh0dXJlKEkpe3JldHVybih0aGlzW09dfHx0aGlzW29dKS5kZWxldGVUZXh0dXJlKEkpfWNsZWFyKC4uLkkpe2lmKHRoaXNbT10pe2NvbnN0IEQ9dGhpc1tPXS5nbDtELmNsZWFyKEQuQ09MT1JfQlVGRkVSX0JJVCl9ZWxzZSB0aGlzW29dLmNsZWFyKC4uLkkpfWRyYXdNZXNoQ2xvdWQoSSx7Y2xlYXI6RD0hMSxwcm9ncmFtOlI9bnVsbH09e30pe2NvbnN0IEM9dGhpc1tPXXx8dGhpc1tvXSxCPVJ8fEkucHJvZ3JhbTtpZih0aGlzW09dKXtjb25zdCB6PUMuZ2w7aWYoRCYmei5jbGVhcih6LkNPTE9SX0JVRkZFUl9CSVQpLEIpQy5wcm9ncmFtIT09QiYmdGhpcy51c2VQcm9ncmFtKEIse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSk7ZWxzZXtjb25zdCBLPUkubWVzaC5tZXNoRGF0YSxRPSEhSy51bmlmb3Jtcy51X3RleFNhbXBsZXIsXz0hIUsudW5pZm9ybXMudV9maWx0ZXJGbGFnLEY9ISFLLnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IsRz1JLmhhc0Nsb3VkQ29sb3IsWD1JLmhhc0Nsb3VkRmlsdGVyLFo9ISFLLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHkuYXBwbHlDbG91ZFNoYWRlcikoQyx7aGFzVGV4dHVyZTpRLGhhc0ZpbHRlcjpfLGhhc0dyYWRpZW50OkYsaGFzQ2xvdWRDb2xvcjpHLGhhc0Nsb3VkRmlsdGVyOlgsaGFzQ2xpcFBhdGg6Wn0pfXRoaXNbZ10oKSxDLnNldE1lc2hEYXRhKFtJLm1lc2hEYXRhXSksSS5iZWZvcmVSZW5kZXImJkkuYmVmb3JlUmVuZGVyKHosSSksRShDKSxJLmFmdGVyUmVuZGVyJiZJLmFmdGVyUmVuZGVyKHosSSl9ZWxzZSBDLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksQy5kcmF3TWVzaENsb3VkKEkse2NsZWFyOkQsaG9vazohMX0pfWRyYXdNZXNoZXMoSSx7Y2xlYXI6RD0hMSxwcm9ncmFtOlI9bnVsbH09e30pe2NvbnN0IEM9dGhpc1tPXXx8dGhpc1tvXTtpZih0aGlzW09dKXtjb25zdCBCPUMuZmJvLHo9T2JqZWN0KGEuZGVmYXVsdCkodGhpcyxJLFI9PW51bGwpLEs9Qy5nbDtEJiZLLmNsZWFyKEsuQ09MT1JfQlVGRkVSX0JJVCk7Y29uc3QgUT0hT2JqZWN0KGQuaXNVbml0VHJhbnNmb3JtKSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCk7dGhpcy5fZHJhd0NhbGxzPTA7Zm9yKGNvbnN0IF8gb2Ygeil7dGhpcy5fZHJhd0NhbGxzKys7Y29uc3QgRj1SfHxfLnByb2dyYW07aWYoXyBpbnN0YW5jZW9mIHYuZGVmYXVsdCl0aGlzLmRyYXdNZXNoQ2xvdWQoXyx7Y2xlYXI6RCxwcm9ncmFtOkZ9KTtlbHNle2NvbnN0e3dpZHRoOkcsaGVpZ2h0Olh9PXRoaXMuY2FudmFzO2lmKF8uYmVmb3JlUmVuZGVyJiZfLmJlZm9yZVJlbmRlcihLLF8pLF8ucGFzcy5sZW5ndGgmJigoIXRoaXMuZmJvfHx0aGlzLmZiby53aWR0aCE9PUd8fHRoaXMuZmJvLmhlaWdodCE9PVgpJiYodGhpcy5mYm89e3dpZHRoOkcsaGVpZ2h0OlgsdGFyZ2V0OkMuY3JlYXRlRkJPKCksYnVmZmVyOkMuY3JlYXRlRkJPKCksc3dhcCgpe1t0aGlzLnRhcmdldCx0aGlzLmJ1ZmZlcl09W3RoaXMuYnVmZmVyLHRoaXMudGFyZ2V0XX19KSxDLmJpbmRGQk8odGhpcy5mYm8udGFyZ2V0KSksIUYmJl8uZmlsdGVyQ2FudmFzKXtPYmplY3QoeS5hcHBseVNoYWRlcikoQyx7aGFzVGV4dHVyZTohMH0pO2xldCBaPXRoaXMuZmlsdGVyQ29udGV4dDtafHwoWj1wLmRlZmF1bHQuY3JlYXRlQ2FudmFzKEcsWCkuZ2V0Q29udGV4dCgiMmQiKSx0aGlzLmZpbHRlckNvbnRleHQ9Wik7Y29uc3QgdHQ9SVtfLnBhY2tJbmRleF0sbnQ9dHQuZmlsdGVyLHE9SVtfLnBhY2tJbmRleCsxXSxodD1JW18ucGFja0luZGV4LTFdOyghaHR8fCFodC5maWx0ZXJDYW52YXN8fGh0LmZpbHRlciE9PW50KSYmKCFxfHwhcS5maWx0ZXJDYW52YXN8fHEuZmlsdGVyIT09bnQpPyhRPyhaLnNhdmUoKSxPYmplY3QobC5kcmF3TWVzaDJEKSh0dCxaLCExKSxaLnJlc3RvcmUoKSxPYmplY3QobC5hcHBseUZpbHRlcikoWixudCkpOk9iamVjdChsLmRyYXdNZXNoMkQpKHR0LFosITApLHRoaXNbZ10oKSxBKEMsWixHLFgpKTooUSYmWi5zYXZlKCksT2JqZWN0KGwuZHJhd01lc2gyRCkodHQsWiwhMSksUSYmWi5yZXN0b3JlKCksKCFxfHwhcS5maWx0ZXJDYW52YXN8fHR0LmZpbHRlciE9PXEuZmlsdGVyKSYmKE9iamVjdChsLmFwcGx5RmlsdGVyKShaLG50KSx0aGlzW2ddKCksQShDLFosRyxYKSkpfWVsc2V7aWYoRilDLnByb2dyYW0hPT1GJiZ0aGlzLnVzZVByb2dyYW0oRix7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pO2Vsc2V7Y29uc3QgWj0hIV8udW5pZm9ybXMudV90ZXhTYW1wbGVyLHR0PSEhXy51bmlmb3Jtcy51X2ZpbHRlckZsYWcsbnQ9ISFfLnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IscT0hIV8udW5pZm9ybXMudV9jbGlwU2FtcGxlcjtPYmplY3QoeS5hcHBseVNoYWRlcikoQyx7aGFzVGV4dHVyZTpaLGhhc0ZpbHRlcjp0dCxoYXNHcmFkaWVudDpudCxoYXNDbGlwUGF0aDpxfSl9Xy5maWx0ZXJDYW52YXMmJmNvbnNvbGUud2FybigiVXNlciBwcm9ncmFtIGlnbm9yZWQgc29tZSBmaWx0ZXIgZWZmZWN0cy4iKSx0aGlzW2ddKCksQy5zZXRNZXNoRGF0YShbX10pLEUoQyl9aWYoXy5wYXNzLmxlbmd0aCl7Y29uc3QgWj1fLnBhc3MubGVuZ3RoO18ucGFzcy5mb3JFYWNoKCh0dCxudCk9Pnt0dC5ibGVuZD1fLmVuYWJsZUJsZW5kLHR0LnNldFRleHR1cmUoQy5mYm8udGV4dHVyZSksbnQ9PT1aLTE/Qy5iaW5kRkJPKEIpOih0aGlzLmZiby5zd2FwKCksQy5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLHR0LnByb2dyYW0/Qy51c2VQcm9ncmFtKHR0LnByb2dyYW0pOih0aGlzLmRlZmF1bHRQYXNzUHJvZ3JhbT10aGlzLmRlZmF1bHRQYXNzUHJvZ3JhbXx8dGhpcy5jcmVhdGVQYXNzUHJvZ3JhbSgpLEMudXNlUHJvZ3JhbSh0aGlzLmRlZmF1bHRQYXNzUHJvZ3JhbSkpLEMuc2V0TWVzaERhdGEoW3R0Lm1lc2hEYXRhXSksSy5jbGVhcihLLkNPTE9SX0JVRkZFUl9CSVQpLEUoQyl9KX1fLmFmdGVyUmVuZGVyJiZfLmFmdGVyUmVuZGVyKEssXyl9fX1lbHNlIEMuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxDLmRyYXdNZXNoZXMoSSx7Y2xlYXI6RH0pfWRyYXdJbWFnZShJLC4uLkQpe2NvbnN0IFI9RC5sZW5ndGg7aWYoUjwyKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICdkcmF3SW1hZ2UnIG9uICdSZW5kZXJlcic6IDMgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke0QubGVuZ3RoKzF9IHByZXNlbnQuYCk7aWYoUiE9PTImJlIhPT00JiZSIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiBWYWxpZCBhcml0aWVzIGFyZTogWzMsIDUsIDldLCBidXQgJHtELmxlbmd0aCsxfSBhcmd1bWVudHMgcHJvdmlkZWQuYCk7bGV0IEM9bnVsbCxCPW51bGw7Uj09PTI/Qz1bRFswXSxEWzFdLEkud2lkdGgsSS5oZWlnaHRdOlI9PT00P0M9RDpSPT09OCYmKEI9RC5zbGljZSgwLDQpLEM9RC5zbGljZSg0KSk7Y29uc3Qgej10aGlzLmNyZWF0ZVRleHR1cmUoSSkse3dpZHRoOkssaGVpZ2h0OlF9PXRoaXMuY2FudmFzLF89bmV3IHMuZGVmYXVsdDtfLnJlY3QoQ1swXSxDWzFdLEssUSk7Y29uc3QgRj1uZXcgZi5kZWZhdWx0KF8se3dpZHRoOkssaGVpZ2h0OlF9KTtGLnNldFRleHR1cmUoeix7cmVjdDpDLHNyY1JlY3Q6Qn0pLHRoaXMuZHJhd01lc2hlcyhbRl0pLHRoaXMuZGVsZXRlVGV4dHVyZSh6KX1zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uSSl7cmV0dXJuIHRoaXNbY109W0lbMF0sSVsxXSwwLElbMl0sSVszXSwwLElbNF0sSVs1XSwxXSx0aGlzfWdsb2JhbFRyYW5zZm9ybSguLi5JKXtjb25zdCBEPXRoaXNbY107cmV0dXJuIHRoaXNbY109bi5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxELEkpLHRoaXN9Z2xvYmFsVHJhbnNsYXRlKEksRCl7bGV0IFI9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBSPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFIsW0ksRF0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLlIpfWdsb2JhbFJvdGF0ZShJLFtELFJdPVswLDBdKXtsZXQgQz1uLm1hdDMuY3JlYXRlKCk7cmV0dXJuIEM9bi5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxbRCxSXSksQz1uLm1hdDMucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxDLEkpLEM9bi5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxbLUQsLVJdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5DKX1nbG9iYWxTY2FsZShJLEQ9SSxbUixDXT1bMCwwXSl7bGV0IEI9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsW1IsQ10pLEI9bi5tYXQzLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFtJLERdKSxCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsWy1SLC1DXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQil9Z2xvYmFsU2tldyhJLEQ9SSxbUixDXT1bMCwwXSl7bGV0IEI9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsW1IsQ10pLEI9bi5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLG4ubWF0My5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRCksTWF0aC50YW4oSSksMSwwLDApKSxCPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLEIsWy1SLC1DXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uQil9dHJhbnNmb3JtUG9pbnQoSSxELFIpe2xldCBDPXRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O1ImJihDPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQyxSKSk7Y29uc3QgQj1JKkNbMF0rRCpDWzJdK0NbNF0sej1JKkNbMV0rRCpDWzNdK0NbNV07cmV0dXJuW0Isel19fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKTt2YXIgcj10KDE1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PXIuZGVmYXVsdH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pO3ZhciByPXQoMTYpLG49dCgxNyksaT10KDE4KSxhPXQoMTkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKFAseCxtKXtyZXR1cm4geCBpbiBQP09iamVjdC5kZWZpbmVQcm9wZXJ0eShQLHgse3ZhbHVlOm0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpQW3hdPW0sUH1jb25zdCBzPXt9O2Z1bmN0aW9uIGYoUCx4PTMpe2NvbnN0IG09W10sTz1QLmxlbmd0aDtmb3IobGV0IG89MDtvPE87bysrKW8leDwyJiZtLnB1c2goLjUqKFBbb10rMSkpO3JldHVybiBtfWZ1bmN0aW9uIHYoUCx4KXtjb25zdCBtPXguX2J1ZmZlcnM7T2JqZWN0LnZhbHVlcyhtKS5mb3JFYWNoKE89PntQLmRlbGV0ZUJ1ZmZlcihPKX0pLHguX2J1ZmZlcnM9e319ZnVuY3Rpb24gZChQLHgsbSl7cmV0dXJuIFAuYWN0aXZlVGV4dHVyZShQLlRFWFRVUkUwK20pLEFycmF5LmlzQXJyYXkoeC5faW1nKT9QLmJpbmRUZXh0dXJlKFAuVEVYVFVSRV9DVUJFX01BUCx4KTpQLmJpbmRUZXh0dXJlKFAuVEVYVFVSRV8yRCx4KSx4fWNvbnN0IHA9e2ludDoiMWkiLGl2ZWMyOiIyaSIsaXZlYzM6IjNpIixpdmVjNDoiNGkiLGZsb2F0OiIxZiIsdmVjMjoiMmYiLHZlYzM6IjNmIix2ZWM0OiI0ZiIsbWF0MjoiTWF0cml4MmZ2IixtYXQzOiJNYXRyaXgzZnYiLG1hdDQ6Ik1hdHJpeDRmdiIsc2FtcGxlcjFEOiJzYW1wbGVyMUQiLHNhbXBsZXIyRDoic2FtcGxlcjJEIixzYW1wbGVyM0Q6InNhbXBsZXIzRCIsc2FtcGxlckN1YmU6InNhbXBsZXJDdWJlIixzYW1wbGVyMURTaGFkb3c6InNhbXBsZXIxRFNoYWRvdyIsc2FtcGxlcjJEU2hhZG93OiJzYW1wbGVyMkRTaGFkb3ciLHNhbXBsZXIyRFJlY3Q6InNhbXBsZXIyRFJlY3QiLHNhbXBsZXIyRFJlY3RTaGFkb3c6InNhbXBsZXIyRFJlY3RTaGFkb3cifTtjbGFzcyB5e3N0YXRpYyBhZGRMaWJzKHg9e30pe09iamVjdC5hc3NpZ24ocyx4KX1zdGF0aWMgRkxPQVQoeCxtKXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKHgsRmxvYXQzMkFycmF5LG0pfXN0YXRpYyBVTlNJR05FRF9CWVRFKHgsbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKSh4LFVpbnQ4QXJyYXksbSl9c3RhdGljIFVOU0lHTkVEX1NIT1JUKHgsbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKSh4LFVpbnQxNkFycmF5LG0pfXN0YXRpYyBCWVRFKHgsbSl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKSh4LEludDhBcnJheSxtKX1zdGF0aWMgU0hPUlQoeCxtKXtyZXR1cm4gT2JqZWN0KHIucG9pbnRzVG9CdWZmZXIpKHgsSW50MTZBcnJheSxtKX1jb25zdHJ1Y3Rvcih4LG09e30pe3RoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LHkuZGVmYXVsdE9wdGlvbnMsbSksdGhpcy5jYW52YXM9eDtsZXQgTzt0aGlzLm9wdGlvbnMud2ViZ2wyJiYoTz14LmdldENvbnRleHQoIndlYmdsMiIsdGhpcy5vcHRpb25zKSksTz09bnVsbCYmKE89T2JqZWN0KHIuc2V0dXBXZWJHTCkoeCx0aGlzLm9wdGlvbnMpLHRoaXMuYWlhX2V4dD1PLmdldEV4dGVuc2lvbigiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpKSx0aGlzLmdsPU8sTy52aWV3cG9ydCgwLDAseC53aWR0aCx4LmhlaWdodCksTy5jbGVhckNvbG9yKDAsMCwwLDApLE8uYmxlbmRGdW5jU2VwYXJhdGUoTy5TUkNfQUxQSEEsTy5PTkVfTUlOVVNfU1JDX0FMUEhBLE8uT05FLE8uT05FX01JTlVTX1NSQ19BTFBIQSksdGhpcy5wcm9ncmFtcz1bXSx0aGlzLl9ldmVudHM9e319Z2V0IHByb2dyYW0oKXtjb25zdCB4PXRoaXMuZ2w7cmV0dXJuIHguZ2V0UGFyYW1ldGVyKHguQ1VSUkVOVF9QUk9HUkFNKX1fZGVjbGFyZVVuaWZvcm0oeCxtLE89IjFmIil7Y29uc3Qgbz10aGlzLmdsLGg9by5nZXRVbmlmb3JtTG9jYXRpb24oeCxtKTtsZXQgYztjb25zdCBnPXRoaXM7aWYoL15zYW1wbGVyLy50ZXN0KE8pKXtjb25zdCBiPXguX3NhbXBsZXJNYXAsRT14Ll9iaW5kVGV4dHVyZXM7T2JqZWN0LmRlZmluZVByb3BlcnR5KHgudW5pZm9ybXMsbSx7Z2V0KCl7cmV0dXJuIGN9LHNldChBKXtjPUE7Y29uc3QgTD1iW21dIT1udWxsP2JbbV06RS5sZW5ndGg7RVtMXT1BLGQobyxBLEwpLGJbbV18fChiW21dPUwsby51bmlmb3JtMWkoaCxMKSksZy5vcHRpb25zLmF1dG9VcGRhdGUmJmcudXBkYXRlKCl9LGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwfSl9ZWxzZXtjb25zdCBiPU8uaW5kZXhPZigiTWF0cml4Iik9PT0wLEU9IWImJi92JC8udGVzdChPKSxBPW9bYHVuaWZvcm0ke099YF0uYmluZChvKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeC51bmlmb3JtcyxtLHtnZXQoKXtyZXR1cm4gY30sc2V0KEwpe2M9TCx0eXBlb2YgTD09Im51bWJlciImJihMPVtMXSksYj9BKGgsITEsTCk6RT9BKGgsTCk6QShoLC4uLkwpLGcub3B0aW9ucy5hdXRvVXBkYXRlJiZnLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfX1fZHJhdygpe2NvbnN0IHg9dGhpcy5wcm9ncmFtO3gubWVzaERhdGEuZm9yRWFjaCgobSxPKT0+e2NvbnN0e3Bvc2l0aW9uczpvLGNlbGxzOmgsaW5zdGFuY2VDb3VudDpjLGNlbGxzQ291bnQ6ZyxhdHRyaWJ1dGVzOmIsdW5pZm9ybXM6RSx0ZXh0dXJlQ29vcmQ6QSxlbmFibGVCbGVuZDpMfT1tLE09dGhpcy5nbDtsZXQgST1tLm1vZGUhPW51bGw/bS5tb2RlOk0uVFJJQU5HTEVTO3R5cGVvZiBJPT0ic3RyaW5nIiYmKEk9TVtJXSksTD9NLmVuYWJsZShNLkJMRU5EKTpNLmRpc2FibGUoTS5CTEVORCksTS5iaW5kQnVmZmVyKE0uQVJSQVlfQlVGRkVSLHguX2J1ZmZlcnMudmVydGljZXNCdWZmZXIpLE0uYnVmZmVyRGF0YShNLkFSUkFZX0JVRkZFUixvLE0uU1RBVElDX0RSQVcpLGgmJihNLmJpbmRCdWZmZXIoTS5FTEVNRU5UX0FSUkFZX0JVRkZFUix4Ll9idWZmZXJzLmNlbGxzQnVmZmVyKSxNLmJ1ZmZlckRhdGEoTS5FTEVNRU5UX0FSUkFZX0JVRkZFUixoLE0uU1RBVElDX0RSQVcpKTtjb25zdCBEPVtdO2ImJk9iamVjdC52YWx1ZXMoYikuZm9yRWFjaCgoe25hbWU6QyxkYXRhOkIsZGl2aXNvcjp6fSk9PntpZihNLmJpbmRCdWZmZXIoTS5BUlJBWV9CVUZGRVIseC5fYnVmZmVyc1tDXSksTS5idWZmZXJEYXRhKE0uQVJSQVlfQlVGRkVSLEIsTS5TVEFUSUNfRFJBVykseiE9bnVsbCl7Y29uc3QgSz1NLmdldEF0dHJpYkxvY2F0aW9uKHgsQyk7Sz49MCYmKE0uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoSyksRC5wdXNoKEspLE0udmVydGV4QXR0cmliRGl2aXNvcj9NLnZlcnRleEF0dHJpYkRpdmlzb3IoSyx6KTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoSyx6KSl9fSksRSYmT2JqZWN0LmVudHJpZXMoRSkuZm9yRWFjaCgoW0MsQl0pPT57dGhpcy51bmlmb3Jtc1tDXT1CfSk7bGV0IFI7aWYoIWgpe2NvbnN0IEM9eC5fZGltZW5zaW9uO1I9by5sZW5ndGgvQ31pZih4Ll9lbmFibGVUZXh0dXJlcyYmeC5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcil7Y29uc3QgQz1BfHxmKG8seC5fZGltZW5zaW9uKTtNLmJpbmRCdWZmZXIoTS5BUlJBWV9CVUZGRVIseC5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlciksTS5idWZmZXJEYXRhKE0uQVJSQVlfQlVGRkVSLHkuRkxPQVQoQyksTS5TVEFUSUNfRFJBVyl9YyE9bnVsbD8oaD9NLmRyYXdFbGVtZW50c0luc3RhbmNlZD9NLmRyYXdFbGVtZW50c0luc3RhbmNlZChJLGcsTS5VTlNJR05FRF9TSE9SVCwwLGMpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKEksZyxNLlVOU0lHTkVEX1NIT1JULDAsYyk6TS5kcmF3QXJyYXlzSW5zdGFuY2VkP00uZHJhd0FycmF5c0luc3RhbmNlZChJLDAsUixjKTp0aGlzLmFpYV9leHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKEksMCxSLGMpLEQuZm9yRWFjaChDPT57TS52ZXJ0ZXhBdHRyaWJEaXZpc29yP00udmVydGV4QXR0cmliRGl2aXNvcihDLG51bGwpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShDLG51bGwpfSkpOmg/TS5kcmF3RWxlbWVudHMoSSxnLE0uVU5TSUdORURfU0hPUlQsMCk6TS5kcmF3QXJyYXlzKEksMCxSKX0pfWdldCBpc1dlYkdMMigpe3JldHVybiB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDwidSImJnRoaXMuZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0fWdldCBlbmFibGVUZXh0dXJlcygpe3JldHVybiB0aGlzLnByb2dyYW0mJnRoaXMucHJvZ3JhbS5fZW5hYmxlVGV4dHVyZXN9Z2V0IHVuaWZvcm1zKCl7Y29uc3QgeD10aGlzLnByb2dyYW07aWYoIXh8fCF4LnVuaWZvcm1zKXRocm93IEVycm9yKCJObyBhdmFsaWFibGUgcHJvZ3JhbS4iKTtyZXR1cm4geC51bmlmb3Jtc31kZWxldGVQcm9ncmFtKHgpe2NvbnN0IG09dGhpcy5nbDt0aGlzLnByb2dyYW09PT14JiYodGhpcy5zdGFydFJlbmRlcj0hMSx0aGlzLl9yZW5kZXJGcmFtZUlEJiYoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyRnJhbWVJRCksZGVsZXRlIHRoaXMuX3JlbmRlckZyYW1lSUQpLG0udXNlUHJvZ3JhbShudWxsKSk7Y29uc3QgTz10aGlzLnByb2dyYW1zLmluZGV4T2YoeCk7Tz49MCYmdGhpcy5wcm9ncmFtcy5zcGxpY2UoTywxKSx2KG0seCksbS5kZWxldGVQcm9ncmFtKHgpfXNldE1lc2hEYXRhKHgpe0FycmF5LmlzQXJyYXkoeCl8fCh4PVt4XSk7Y29uc3QgbT10aGlzLnByb2dyYW07bS5tZXNoRGF0YT14Lm1hcCgoe21vZGU6Tyxwb3NpdGlvbnM6byxpbnN0YW5jZUNvdW50OmgsY2VsbHM6YyxjZWxsc0NvdW50OmcsYXR0cmlidXRlczpiLHVuaWZvcm1zOkUsdGV4dHVyZUNvb3JkOkEsZW5hYmxlQmxlbmQ6TH0pPT57Y29uc3QgTT17cG9zaXRpb25zOnkuRkxPQVQobyksdW5pZm9ybXM6RSxlbmFibGVCbGVuZDohIUwsdGV4dHVyZUNvb3JkOnkuRkxPQVQoQSl9O2lmKGMmJihNLmNlbGxzPXkuVVNIT1JUKGMpLE0uY2VsbHNDb3VudD1nfHxNLmNlbGxzLmxlbmd0aCksTyE9bnVsbCYmKE0ubW9kZT1PKSxoIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgaW5zdGFuY2VDb3VudCBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtNLmluc3RhbmNlQ291bnQ9aH1pZihiKXtjb25zdCBJPXt9O09iamVjdC5lbnRyaWVzKGIpLmZvckVhY2goKFtELFJdKT0+e2lmKCFtLl9hdHRyaWJ1dGVbRF0pbS5fYXR0cmlidXRlW0RdPSJpZ25vcmVkIjtlbHNlIGlmKG0uX2F0dHJpYnV0ZVtEXSE9PSJpZ25vcmVkIil7Y29uc3R7bmFtZTpDLHR5cGU6Qn09bS5fYXR0cmlidXRlW0RdO2xldCB6PVIuZGF0YXx8UjtpZihBcnJheS5pc0FycmF5KHopJiYoej15W0JdKHopKSxJW0RdPXtuYW1lOkMsZGF0YTp6fSxSLmRpdmlzb3IhPW51bGwpe2lmKCF0aGlzLmlzV2ViR0wyJiYhdGhpcy5haWFfZXh0KXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHVzZSBkaXZpc29yIGluIHRoaXMgcmVuZGVyaW5nIGNvbnRleHQsIHVzZSB3ZWJnbDIgY29udGV4dCBpbnN0ZWFkLiIpO0lbRF0uZGl2aXNvcj1SLmRpdmlzb3J9fX0pLE0uYXR0cmlidXRlcz1JfXJldHVybiBNfSksdGhpcy5vcHRpb25zLmF1dG9VcGRhdGUmJnRoaXMudXBkYXRlKCl9Y3JlYXRlUHJvZ3JhbSh4LG0pe2NvbnN0IE89L15ccyp1bmlmb3JtXHMrc2FtcGxlci9tZy50ZXN0KHgpO3g9PW51bGwmJih4PWkuZGVmYXVsdCksbT09bnVsbCYmKG09Tz9hLmRlZmF1bHQ6bi5kZWZhdWx0KTtjb25zdCBvPXRoaXMuZ2wsaD1PYmplY3Qoci5jcmVhdGVQcm9ncmFtKShvLG0seCk7aC5zaGFkZXJUZXh0PXt2ZXJ0ZXhTaGFkZXI6bSxmcmFnbWVudFNoYWRlcjp4fSxoLl9idWZmZXJzPXt9LGguX2F0dHJpYnV0ZT17fSxoLnVuaWZvcm1zPXt9LGguX3NhbXBsZXJNYXA9e30saC5fYmluZFRleHR1cmVzPVtdO2NvbnN0IGM9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhQb3NpdGlvbn1gLCJpbSIpO2xldCBnPW0ubWF0Y2goYyk7ZyYmKGguX2RpbWVuc2lvbj1OdW1iZXIoZ1sxXSkpO2NvbnN0IGI9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhUZXh0dXJlQ29vcmR9YCwiaW0iKTtnPW0ubWF0Y2goYiksZyYmKGguX3RleENvb3JkU2l6ZT1OdW1iZXIoZ1sxXSkpO2NvbnN0IEU9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2dpbTtpZihnPW0ubWF0Y2goRSksZylmb3IobGV0IE09MDtNPGcubGVuZ3RoO00rKyl7Y29uc3QgST0vXlxzKig/OmF0dHJpYnV0ZXxpbikgKFx3Kz8pKFxkKikgKFx3KykvaW0sRD1nW01dLm1hdGNoKEkpO2lmKEQmJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24mJkRbM10hPT10aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKXtsZXRbLFIsQyxCXT1EO1I9PT0ibWF0IiYmKEMqKj0yKSxoLl9idWZmZXJzW0JdPW8uY3JlYXRlQnVmZmVyKCksaC5fYXR0cmlidXRlW0JdPXtuYW1lOkIsdHlwZTpSLHNpemU6TnVtYmVyKEMpfHwxfX19Y29uc3QgQT0vXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy9tZztnPW0ubWF0Y2goQSl8fFtdLGc9Zy5jb25jYXQoeC5tYXRjaChBKXx8W10pLGcuZm9yRWFjaChNPT57Y29uc3QgST1NLm1hdGNoKC9eXHMqdW5pZm9ybVxzKyhcdyspXHMrKFx3KykoXFtcZCtcXSk/Lyk7bGV0W0QsUixDXT1JLnNsaWNlKDEpO0Q9cFtEXSxDPSEhQyxELmluZGV4T2YoIk1hdHJpeCIpIT09MCYmQyYmKEQrPSJ2IiksdGhpcy5fZGVjbGFyZVVuaWZvcm0oaCxSLEQpfSksaC5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcj1vLmNyZWF0ZUJ1ZmZlcigpLGguX2J1ZmZlcnMuY2VsbHNCdWZmZXI9by5jcmVhdGVCdWZmZXIoKTtjb25zdCBMPW8uZ2V0QXR0cmliTG9jYXRpb24oaCx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtyZXR1cm4gaC5fZW5hYmxlVGV4dHVyZXM9TD49MCxoLl9lbmFibGVUZXh0dXJlcyYmKGguX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXI9by5jcmVhdGVCdWZmZXIoKSksdGhpcy5wcm9ncmFtcy5wdXNoKGgpLGh9dXNlUHJvZ3JhbSh4LG09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKTtjb25zdCBPPXRoaXMuZ2w7Ty51c2VQcm9ncmFtKHgpO2NvbnN0IG89eC5fZGltZW5zaW9uO08uYmluZEJ1ZmZlcihPLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKTtjb25zdCBoPU8uZ2V0QXR0cmliTG9jYXRpb24oeCx0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24pO2lmKE8udmVydGV4QXR0cmliUG9pbnRlcihoLG8sTy5GTE9BVCwhMSwwLDApLE8uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaCkseC5fZW5hYmxlVGV4dHVyZXMpe08uYmluZEJ1ZmZlcihPLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzLnRleENvb3JkQnVmZmVyKTtjb25zdCBjPU8uZ2V0QXR0cmliTG9jYXRpb24oeCx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtPLnZlcnRleEF0dHJpYlBvaW50ZXIoYyx4Ll90ZXhDb29yZFNpemV8fDIsTy5GTE9BVCwhMSwwLDApLE8uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYyl9aWYoT2JqZWN0LmVudHJpZXMoeC5fYXR0cmlidXRlKS5mb3JFYWNoKChbYyxnXSk9PntpZihnIT09Imlnbm9yZWQiKXtjb25zdCBiPWcuc2l6ZSxFPW1bY118fHt9LEE9ISFFLm5vcm1hbGl6ZTtsZXQgTD1FLnR5cGV8fCJGTE9BVCI7Y29uc3QgTT1FLmtleXx8YztMPT09IlVCWVRFIiYmKEw9IlVOU0lHTkVEX0JZVEUiKSxMPT09IlVTSE9SVCImJihMPSJVTlNJR05FRF9TSE9SVCIpLGcudHlwZT1MLE0mJk0hPT1jJiYoeC5fYXR0cmlidXRlW01dPWcpLE8uYmluZEJ1ZmZlcihPLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzW2NdKTtjb25zdCBJPU8uZ2V0QXR0cmliTG9jYXRpb24oeCxjKTtJPj0wJiYoTy52ZXJ0ZXhBdHRyaWJQb2ludGVyKEksYixPW0xdLEEsMCwwKSxPLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEkpKX19KSwheC5tZXNoRGF0YSl7Y29uc3QgYz1bWy0xLC0xLDAsMV0uc2xpY2UoMCxvKSxbMSwtMSwwLDFdLnNsaWNlKDAsbyksWzEsMSwwLDFdLnNsaWNlKDAsbyksWy0xLDEsMCwxXS5zbGljZSgwLG8pXSxnPVtbMCwxLDNdLFszLDEsMl1dO3RoaXMuc2V0TWVzaERhdGEoe3Bvc2l0aW9uczpjLGNlbGxzOmd9KX1yZXR1cm4geH1jb21waWxlU3luYyh4LG0pe3g9eHx8aS5kZWZhdWx0O2NvbnN0IE89e307ZnVuY3Rpb24gbyhiKXtiPWIucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgRT1bXSxBPWIubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihBKXtmb3IobGV0IEw9MDtMPEEubGVuZ3RoO0wrKyl7Y29uc3QgST1BW0xdLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihJKXtjb25zdCBEPUlbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9SVsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIiksT1tSXSlFLnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKE9bUl09ITAsRD09PSJsaWIiKXtjb25zdCBDPW8oc1tSXSk7RS5wdXNoKEMpfWVsc2UgaWYoRD09PSJsaW5rIil0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBsb2FkIGV4dGVybmFsIGxpbmtzIHN5bmNocm9ub3VzbHkuIFVzZSBjb21waWxlIGluc3RlYWQgb2YgY29tcGlsZVN5bmMuIil9fUUuZm9yRWFjaChMPT57Yj1iLnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sTCl9KX1yZXR1cm4gYn1jb25zdCBoPW8oeCksYz1tP28obSk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGgsYyl9YXN5bmMgY29tcGlsZSh4LG0pe3g9eHx8aS5kZWZhdWx0O2NvbnN0IE89e307YXN5bmMgZnVuY3Rpb24gbyhiKXtiPWIucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgRT1bXSxBPWIubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihBKXtmb3IobGV0IEw9MDtMPEEubGVuZ3RoO0wrKyl7Y29uc3QgST1BW0xdLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihJKXtjb25zdCBEPUlbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9SVsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIiksT1tSXSlFLnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKE9bUl09ITAsRD09PSJsaWIiKXtjb25zdCBDPWF3YWl0IG8oc1tSXSk7RS5wdXNoKEMpfWVsc2UgaWYoRD09PSJsaW5rIil7bGV0IEM9YXdhaXQgeS5mZXRjaFNoYWRlcihSKTtDPWF3YWl0IG8oQyksRS5wdXNoKEMpfX19RS5mb3JFYWNoKEw9PntiPWIucmVwbGFjZSgvXiNwcmFnbWFccytpbmNsdWRlXHMrLiovbSxMKX0pfXJldHVybiBifWNvbnN0IGg9YXdhaXQgbyh4KSxjPW0/YXdhaXQgbyhtKTpudWxsO3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oaCxjKX1hc3luYyBsb2FkKHgsbT1udWxsKXtyZXR1cm4geD1hd2FpdCB5LmZldGNoU2hhZGVyKHgpLG0mJihtPWF3YWl0IHkuZmV0Y2hTaGFkZXIobSkpLHRoaXMuY29tcGlsZSh4LG0pfWNyZWF0ZVRleHR1cmUoeD1udWxsLHt3cmFwUzptPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSx3cmFwVDpPPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSxtaW5GaWx0ZXI6bz10aGlzLmdsLkxJTkVBUixtYWdGaWx0ZXI6aD10aGlzLmdsLkxJTkVBUn09e30pe2NvbnN0IGM9dGhpcy5nbCxnPUFycmF5LmlzQXJyYXkoeCk/Yy5URVhUVVJFX0NVQkVfTUFQOmMuVEVYVFVSRV8yRDt0aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0cz10aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0c3x8Yy5nZXRQYXJhbWV0ZXIoYy5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyksYy5hY3RpdmVUZXh0dXJlKGMuVEVYVFVSRTArdGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHMtMSk7Y29uc3QgYj1jLmNyZWF0ZVRleHR1cmUoKTtjLmJpbmRUZXh0dXJlKGcsYiksYy5waXhlbFN0b3JlaShjLlVOUEFDS19GTElQX1lfV0VCR0wsITApO2NvbnN0e3dpZHRoOkUsaGVpZ2h0OkF9PXRoaXMuY2FudmFzO2lmKHgpaWYoZz09PWMuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEw9MDtMPDY7TCsrKWMudGV4SW1hZ2UyRChjLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtMLDAsYy5SR0JBLGMuUkdCQSxjLlVOU0lHTkVEX0JZVEUseFtMXSk7ZWxzZSBjLnRleEltYWdlMkQoZywwLGMuUkdCQSxjLlJHQkEsYy5VTlNJR05FRF9CWVRFLHgpO2Vsc2UgaWYoZz09PWMuVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IEw9MDtMPDY7TCsrKXRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtMLDAsYy5SR0JBLEUsQSwwLGMuUkdCQSxjLlVOU0lHTkVEX0JZVEUsbnVsbCk7ZWxzZSBjLnRleEltYWdlMkQoZywwLGMuUkdCQSxFLEEsMCxjLlJHQkEsYy5VTlNJR05FRF9CWVRFLG51bGwpO3JldHVybiBjLnRleFBhcmFtZXRlcmkoZyxjLlRFWFRVUkVfTUlOX0ZJTFRFUixvKSxjLnRleFBhcmFtZXRlcmkoZyxjLlRFWFRVUkVfTUFHX0ZJTFRFUixoKSxjLnRleFBhcmFtZXRlcmkoZyxjLlRFWFRVUkVfV1JBUF9TLG0pLGMudGV4UGFyYW1ldGVyaShnLGMuVEVYVFVSRV9XUkFQX1QsTyksZz09PWMuVEVYVFVSRV9DVUJFX01BUCYmKHgud2lkdGg9eFswXS53aWR0aCx4LmhlaWdodD14WzBdLmhlaWdodCksYy5iaW5kVGV4dHVyZShnLG51bGwpLGIuX2ltZz14fHx7d2lkdGg6RSxoZWlnaHQ6QX0sYi5kZWxldGU9KCk9Pnt0aGlzLmRlbGV0ZVRleHR1cmUoYil9LGJ9ZGVsZXRlVGV4dHVyZSh4KXtjb25zdCBtPXguX2ltZzt0aGlzLmdsLmRlbGV0ZVRleHR1cmUoeCksdHlwZW9mIG0uY2xvc2U9PSJmdW5jdGlvbiImJm0uY2xvc2UoKX1hc3luYyBsb2FkVGV4dHVyZSh4LHt1c2VJbWFnZUJpdG1hcDptPSEwfT17fSl7Y29uc3QgTz1hd2FpdCB5LmxvYWRJbWFnZSh4LHt1c2VJbWFnZUJpdG1hcDptfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShPKX1jcmVhdGVGQk8oe2NvbG9yOng9MSxibGVuZDptPSExLGRlcHRoOk89dGhpcy5vcHRpb25zLmRlcHRoIT09ITEsc3RlbmNpbDpvPSEhdGhpcy5vcHRpb25zLnN0ZW5jaWx9PXt9KXtjb25zdCBoPXRoaXMuZ2wsYz1oLmNyZWF0ZUZyYW1lYnVmZmVyKCk7aC5iaW5kRnJhbWVidWZmZXIoaC5GUkFNRUJVRkZFUixjKTtjb25zdCBnPVtdO2ZvcihsZXQgQT0wO0E8eDtBKyspe2NvbnN0IEw9dGhpcy5jcmVhdGVUZXh0dXJlKCk7aC5mcmFtZWJ1ZmZlclRleHR1cmUyRChoLkZSQU1FQlVGRkVSLGguQ09MT1JfQVRUQUNITUVOVDArQSxoLlRFWFRVUkVfMkQsTCwwKSxnLnB1c2goTCl9Yy50ZXh0dXJlcz1nLGMudGV4dHVyZT1nWzBdLGMuYmxlbmQ9bTtjb25zdHt3aWR0aDpiLGhlaWdodDpFfT10aGlzLmNhbnZhcztyZXR1cm4gTyYmIW8mJihjLmRlcHRoQnVmZmVyPWguY3JlYXRlUmVuZGVyYnVmZmVyKCksaC5iaW5kUmVuZGVyYnVmZmVyKGguUkVOREVSQlVGRkVSLGMuZGVwdGhCdWZmZXIpLGgucmVuZGVyYnVmZmVyU3RvcmFnZShoLlJFTkRFUkJVRkZFUixoLkRFUFRIX0NPTVBPTkVOVDE2LGIsRSksaC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihoLkZSQU1FQlVGRkVSLGguREVQVEhfQVRUQUNITUVOVCxoLlJFTkRFUkJVRkZFUixjLmRlcHRoQnVmZmVyKSksbyYmIU8mJihjLnN0ZW5jaWxCdWZmZXI9aC5jcmVhdGVSZW5kZXJidWZmZXIoKSxoLmJpbmRSZW5kZXJidWZmZXIoaC5SRU5ERVJCVUZGRVIsYy5zdGVuY2lsQnVmZmVyKSxoLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoaC5SRU5ERVJCVUZGRVIsaC5TVEVOQ0lMX0lOREVYOCxiLEUpLGguZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoaC5GUkFNRUJVRkZFUixoLlNURU5DSUxfQVRUQUNITUVOVCxoLlJFTkRFUkJVRkZFUixjLnN0ZW5jaWxCdWZmZXIpKSxPJiZvJiYoYy5kZXB0aFN0ZW5jaWxCdWZmZXI9aC5jcmVhdGVSZW5kZXJidWZmZXIoKSxoLmJpbmRSZW5kZXJidWZmZXIoaC5SRU5ERVJCVUZGRVIsYy5kZXB0aFN0ZW5jaWxCdWZmZXIpLGgucmVuZGVyYnVmZmVyU3RvcmFnZShoLlJFTkRFUkJVRkZFUixoLkRFUFRIX1NURU5DSUwsYixFKSxoLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGguRlJBTUVCVUZGRVIsaC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsaC5SRU5ERVJCVUZGRVIsYy5kZXB0aFN0ZW5jaWxCdWZmZXIpKSxoLmJpbmRGcmFtZWJ1ZmZlcihoLkZSQU1FQlVGRkVSLG51bGwpLGN9YmluZEZCTyh4PW51bGwpe3RoaXMuZmJvPXh9cmVuZGVyKHtjbGVhckJ1ZmZlcjp4PSEwfT17fSl7dGhpcy5zdGFydFJlbmRlcj0hMDtjb25zdCBtPXRoaXMuZ2w7bGV0IE89dGhpcy5wcm9ncmFtO098fChPPXRoaXMuY3JlYXRlUHJvZ3JhbSgpLHRoaXMudXNlUHJvZ3JhbShPKSksdGhpcy5mYm8mJm0uYmluZEZyYW1lYnVmZmVyKG0uRlJBTUVCVUZGRVIsdGhpcy5mYm8pO2NvbnN0IG89dGhpcy5vcHRpb25zLmRlcHRoO28mJm0uZW5hYmxlKG0uREVQVEhfVEVTVCksdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVR8KG8/dGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUOjApfCh0aGlzLm9wdGlvbnMuc3RlbmNpbD90aGlzLmdsLlNURU5DSUxfQlVGRkVSX0JJVDowKSk7Y29uc3QgaD10aGlzLl9yZW5kZXJGcmFtZUlEO3RoaXMuX2RyYXcoKSx0aGlzLmZibyYmbS5iaW5kRnJhbWVidWZmZXIobS5GUkFNRUJVRkZFUixudWxsKSx0aGlzLl9yZW5kZXJGcmFtZUlEPT09aCYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9bnVsbCl9dXBkYXRlKCl7dGhpcy5zdGFydFJlbmRlciYmdGhpcy5fcmVuZGVyRnJhbWVJRD09bnVsbCYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyLmJpbmQodGhpcykpKX19bCh5LCJkZWZhdWx0T3B0aW9ucyIse3ByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMCxhdXRvVXBkYXRlOiEwLHZlcnRleFBvc2l0aW9uOiJhX3ZlcnRleFBvc2l0aW9uIix2ZXJ0ZXhUZXh0dXJlQ29vcmQ6ImFfdmVydGV4VGV4dHVyZUNvb3JkIix3ZWJnbDI6ITF9KSxsKHksIlVCWVRFIix5LlVOU0lHTkVEX0JZVEUpLGwoeSwiVVNIT1JUIix5LlVOU0lHTkVEX1NIT1JUKSxsKHksImZldGNoU2hhZGVyIixyLmZldGNoU2hhZGVyKSxsKHksImxvYWRJbWFnZSIsci5sb2FkSW1hZ2UpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJzZXR1cFdlYkdMIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNyZWF0ZVByb2dyYW0iLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwicG9pbnRzVG9CdWZmZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwibG9hZEltYWdlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZldGNoU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiB2fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoZCxwKXtjb25zdCB5PVsid2ViZ2wiLCJleHBlcmltZW50YWwtd2ViZ2wiLCJ3ZWJraXQtM2QiLCJtb3otd2ViZ2wiXTtsZXQgUD1udWxsO2ZvcihsZXQgeD0wO3g8eS5sZW5ndGg7Kyt4KXt0cnl7UD1kLmdldENvbnRleHQoeVt4XSxwKX1jYXRjaHt9aWYoUClicmVha31yZXR1cm4gUH1mdW5jdGlvbiBuKGQscCl7Y29uc3QgeT1yKGQscCk7aWYoIXkpdGhyb3cgbmV3IEVycm9yKCJTb3JyeSwgeW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTC4iKTtyZXR1cm4geX1mdW5jdGlvbiBpKGQscCx5KXtjb25zdCBQPWQuY3JlYXRlU2hhZGVyKGQuVkVSVEVYX1NIQURFUik7aWYoZC5zaGFkZXJTb3VyY2UoUCxwKSxkLmNvbXBpbGVTaGFkZXIoUCksIWQuZ2V0U2hhZGVyUGFyYW1ldGVyKFAsZC5DT01QSUxFX1NUQVRVUykpe2NvbnN0IE89YFZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7ZC5nZXRTaGFkZXJJbmZvTG9nKFApfWA7dGhyb3cgbmV3IEVycm9yKE8pfWNvbnN0IHg9ZC5jcmVhdGVTaGFkZXIoZC5GUkFHTUVOVF9TSEFERVIpO2lmKGQuc2hhZGVyU291cmNlKHgseSksZC5jb21waWxlU2hhZGVyKHgpLCFkLmdldFNoYWRlclBhcmFtZXRlcih4LGQuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBPPWBGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7ZC5nZXRTaGFkZXJJbmZvTG9nKHgpfWA7dGhyb3cgbmV3IEVycm9yKE8pfWNvbnN0IG09ZC5jcmVhdGVQcm9ncmFtKCk7aWYoZC5hdHRhY2hTaGFkZXIobSxQKSxkLmF0dGFjaFNoYWRlcihtLHgpLGQubGlua1Byb2dyYW0obSksIWQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihtLGQuTElOS19TVEFUVVMpKXtjb25zdCBPPWBTaGFkZXIgcHJvZ3JhbSBmYWlsZWQgdG8gbGluay4gIFRoZSBlcnJvciBsb2cgaXM6JHtkLmdldFByb2dyYW1JbmZvTG9nKG0pfWA7dGhyb3cgbmV3IEVycm9yKE8pfXJldHVybiBkLmRlbGV0ZVNoYWRlcihQKSxkLmRlbGV0ZVNoYWRlcih4KSxtfWZ1bmN0aW9uIGEoZCxwPUZsb2F0MzJBcnJheSx5PW51bGwpe2lmKHkmJiEoeSBpbnN0YW5jZW9mIHApKXRocm93IG5ldyBUeXBlRXJyb3IoIldyb25nIGJ1ZmZlciB0eXBlLiIpO2lmKGQ9PW51bGx8fGQgaW5zdGFuY2VvZiBwKXJldHVybiBkO2lmKGRbMF09PW51bGx8fGRbMF0ubGVuZ3RoPT1udWxsKXJldHVybiB5Pyh5LnNldChkLDApLHkpOm5ldyBwKGQpO2NvbnN0IFA9ZFswXS5sZW5ndGgseD1kLmxlbmd0aDt5fHwoeT1uZXcgcChQKngpKTtsZXQgbT0wO2ZvcihsZXQgTz0wO088eDtPKyspZm9yKGxldCBvPTA7bzxQO28rKyl5W20rK109ZFtPXVtvXTtyZXR1cm4geX1jb25zdCBsPXt9O2Z1bmN0aW9uIHMoZCx7dXNlSW1hZ2VCaXRtYXA6cD0hMCxhbGlhczp5PW51bGx9PXt9KXtpZighbFtkXSl7aWYodHlwZW9mIEltYWdlPT0iZnVuY3Rpb24iKXtjb25zdCBQPW5ldyBJbWFnZTt0eXBlb2YgZD09InN0cmluZyImJiEodHlwZW9mIGxvY2F0aW9uPT0ib2JqZWN0IiYmL15maWxlOi8udGVzdChsb2NhdGlvbi5ocmVmKSkmJiEvXmRhdGE6Ly50ZXN0KGQpJiYoUC5jcm9zc09yaWdpbj0iYW5vbnltb3VzIiksbFtkXT1uZXcgUHJvbWlzZSh4PT57UC5vbmxvYWQ9ZnVuY3Rpb24oKXtwJiZ0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXA9PSJmdW5jdGlvbiI/Y3JlYXRlSW1hZ2VCaXRtYXAoUCx7aW1hZ2VPcmllbnRhdGlvbjoiZmxpcFkifSkudGhlbihtPT57bFtkXT1tLHkmJihsW3ldPW0pLHgobSl9KToobFtkXT1QLHkmJihsW3ldPVApLHgoUCkpfSxQLnNyYz1kfSkseSYmKGxbeV09bFtkXSl9ZWxzZSBpZih0eXBlb2YgZmV0Y2g9PSJmdW5jdGlvbiIpcmV0dXJuIGZldGNoKGQse21ldGhvZDoiR0VUIixtb2RlOiJjb3JzIixjYWNoZToiZGVmYXVsdCJ9KS50aGVuKFA9PlAuYmxvYigpKS50aGVuKFA9PmNyZWF0ZUltYWdlQml0bWFwKFAse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oeD0+KGxbZF09eCx5JiYobFt5XT14KSx4KSkpfXJldHVybiBsW2RdfWNvbnN0IGY9e307YXN5bmMgZnVuY3Rpb24gdihkKXtpZihmW2RdKXJldHVybiBmW2RdO2NvbnN0IHA9YXdhaXQgZmV0Y2goZCk7aWYocC5zdGF0dXM+PTIwMCYmcC5zdGF0dXM8MzAwKXtjb25zdCB5PWF3YWl0IHAudGV4dCgpO3JldHVybiBmW2RdPXkseX10aHJvdyBuZXcgRXJyb3IoIlNoYWRlciBsb2FkZWQgZXJyb3IuIil9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfdmVydGV4UG9zaXRpb24sIDEpOwp9YH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YCNpZmRlZiBHTF9FUwpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjEpOwp9YH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWM0IGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSBhX3ZlcnRleFBvc2l0aW9uOwogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKfWB9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTt2YXIgcj10KDIxKSxuPXQoMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbCgidHJhbnNmb3JtIik7Y2xhc3MgYXtjb25zdHJ1Y3RvcihzLGYpe3RoaXMuY29udGV4dD1zLmdldENvbnRleHQoIjJkIiksdGhpcy5vcHRpb25zPWYsdGhpc1tpXT1bMSwwLDAsMSwwLDBdfWNyZWF0ZVRleHR1cmUocyl7cmV0dXJue19pbWc6c319YXN5bmMgbG9hZFRleHR1cmUocyl7Y29uc3QgZj1hd2FpdCByLmRlZmF1bHQubG9hZEltYWdlKHMse3VzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShmKX1kZWxldGVUZXh0dXJlKHMpe3JldHVybiBzfWNsZWFyKHMsZix2LGQpe2NvbnN0IHA9dGhpcy5jb250ZXh0O3M9c3x8MCxmPWZ8fDAsdj12fHxwLmNhbnZhcy53aWR0aC1zLGQ9ZHx8cC5jYW52YXMuaGVpZ2h0LWYscC5jbGVhclJlY3QocyxmLHYsZCl9ZHJhd01lc2hDbG91ZChzLHtjbGVhcjpmPSExfT17fSl7Y29uc3Qgdj1bXTtmb3IobGV0IGQ9MDtkPHMuYW1vdW50O2QrKyl7Y29uc3QgcD1zLmdldFRyYW5zZm9ybShkKTtsZXQgeT1zLmdldFRleHR1cmVGcmFtZShkKTt5JiYoeT15Ll9pbWcpO2NvbnN0IFA9cy5nZXRGaWx0ZXIoZCkse2ZpbGw6eCxzdHJva2U6bX09cy5nZXRDbG91ZFJHQkEoZCk7di5wdXNoKHttZXNoOnMubWVzaCxfY2xvdWRPcHRpb25zOlt4LG0seSxwLFBdfSl9cy5iZWZvcmVSZW5kZXImJnMuYmVmb3JlUmVuZGVyKHRoaXMuY29udGV4dCxzKSx0aGlzLmRyYXdNZXNoZXModix7Y2xlYXI6Zixob29rOiExfSkscy5hZnRlclJlbmRlciYmcy5hZnRlclJlbmRlcih0aGlzLmNvbnRleHQscyl9ZHJhd01lc2hlcyhzLHtjbGVhcjpmPSExLGhvb2s6dj0hMH09e30pe2NvbnN0IGQ9dGhpcy5jb250ZXh0O2YmJmQuY2xlYXJSZWN0KDAsMCxkLmNhbnZhcy53aWR0aCxkLmNhbnZhcy5oZWlnaHQpO2xldCBwPW51bGw7Y29uc3R7d2lkdGg6eSxoZWlnaHQ6UH09ZC5jYW52YXMseD1zLmxlbmd0aDtzLmZvckVhY2goKG0sTyk9PntsZXQgbyxoLGMsZyxiO3YmJm0uYmVmb3JlUmVuZGVyJiZtLmJlZm9yZVJlbmRlcihkLG0pLG0uX2Nsb3VkT3B0aW9ucyYmKFtvLGgsYyxnLGJdPW0uX2Nsb3VkT3B0aW9ucyxtPW0ubWVzaCk7bGV0IEU9bS5maWx0ZXI7aWYoYiYmKEU9RT9gJHtFfSAke2J9YDpiKSxFJiYhdGhpcy5maWx0ZXJCdWZmZXImJnRoaXMuZmlsdGVyQnVmZmVyIT09ITEpe2NvbnN0IEE9ci5kZWZhdWx0LmNyZWF0ZUNhbnZhcyh5LFApO0E/dGhpcy5maWx0ZXJCdWZmZXI9QS5nZXRDb250ZXh0KCIyZCIpOnRoaXMuZmlsdGVyQnVmZmVyPSExfXAmJnAhPT1FJiYoT2JqZWN0KG4uYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLHApLGQuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAseSxQKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHksUCkscD1udWxsKSxFJiZ0aGlzLmZpbHRlckJ1ZmZlcj8odGhpcy5maWx0ZXJCdWZmZXIuc2F2ZSgpLHRoaXMuZmlsdGVyQnVmZmVyLnRyYW5zZm9ybSguLi50aGlzW2ldKSxPYmplY3Qobi5kcmF3TWVzaDJEKShtLHRoaXMuZmlsdGVyQnVmZmVyLCExLG8saCxjLGcpLHRoaXMuZmlsdGVyQnVmZmVyLnJlc3RvcmUoKSxPPT09eC0xPyhPYmplY3Qobi5hcHBseUZpbHRlcikodGhpcy5maWx0ZXJCdWZmZXIsRSksZC5kcmF3SW1hZ2UodGhpcy5maWx0ZXJCdWZmZXIuY2FudmFzLDAsMCx5LFApLHRoaXMuZmlsdGVyQnVmZmVyLmNsZWFyUmVjdCgwLDAseSxQKSk6cD1FKTooZC5zYXZlKCksZC50cmFuc2Zvcm0oLi4udGhpc1tpXSksT2JqZWN0KG4uZHJhd01lc2gyRCkobSxkLCExLG8saCxjLGcpLGQucmVzdG9yZSgpKSx2JiZtLmFmdGVyUmVuZGVyJiZtLmFmdGVyUmVuZGVyKGQsbSl9KX1zZXRUcmFuc2Zvcm0ocyl7dGhpc1tpXT1zfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKHIpe3ZhciBuPXQoMTQpLGk9dCgyMyksYT10KDI0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgbD17fTtmdW5jdGlvbiBzKHksUCl7Y29uc3R7c3R5bGU6eCx2YXJpYW50Om0sd2VpZ2h0Ok8sc3RyZXRjaDpvLHNpemU6aCxweExpbmVIZWlnaHQ6YyxmYW1pbHk6Z309eTtyZXR1cm4gbz09PSJub3JtYWwiP2Ake3h9ICR7bX0gJHtPfSAke2gqUH1weC8ke2MqUH1weCAke2d9YDpgJHt4fSAke219ICR7T30gJHtvfSAke2gqUH1weC8ke2MqUH1weCAke2d9YH1mdW5jdGlvbiBmKHkse2ZvbnQ6UCxmaWxsQ29sb3I6eCxzdHJva2VDb2xvcjptLHN0cm9rZVdpZHRoOk8scmF0aW86bz0xLHRleHRDYW52YXM6aCxjYWNoYWJsZTpjPSExfSl7bGV0IGc7aWYoYyl7Zz1beSxQLFN0cmluZyh4KSxTdHJpbmcobSksU3RyaW5nKE8pXS5qb2luKCIjIyMiKTtjb25zdCB6PWxbZ107aWYoeilyZXR1cm4gen1ofHwoaD1kKDEsMSkpO2NvbnN0IGI9aC5nZXRDb250ZXh0KCIyZCIpO2Iuc2F2ZSgpLGIuZm9udD1QO2xldHt3aWR0aDpFfT1iLm1lYXN1cmVUZXh0KHkpO2IucmVzdG9yZSgpO2NvbnN0IEE9T2JqZWN0KGkuZGVmYXVsdCkoUCksTD1NYXRoLm1heChBLnB4TGluZUhlaWdodCxBLnB4SGVpZ2h0KjEuMTMpOy9pdGFsaWN8b2JsaXF1ZS8udGVzdChQKSYmKEUrPUwqTWF0aC50YW4oMTUqTWF0aC5QSS8xODApKSwheCYmIW0mJih4PSIjMDAwIik7Y29uc3QgTT1iLmNhbnZhcyxJPU1hdGguY2VpbChFKSxEPU1hdGguY2VpbChMKTtNLndpZHRoPU1hdGgucm91bmQoSSpvKSxNLmhlaWdodD1NYXRoLnJvdW5kKEQqbyksYi5zYXZlKCksYi5mb250PXMoQSxvKSxiLnRleHRBbGlnbj0iY2VudGVyIixiLnRleHRCYXNlbGluZT0ibWlkZGxlIjtjb25zdCBSPU0uaGVpZ2h0Ki41K0EucHhIZWlnaHQqLjA1Km8sQz1NLndpZHRoKi41O2lmKHgpe2lmKEFycmF5LmlzQXJyYXkoeCkpeD1PYmplY3QoYS5kZWZhdWx0KSh4KTtlbHNlIGlmKHgudmVjdG9yKXtsZXQgejtjb25zdHt2ZWN0b3I6Syxjb2xvcnM6UX09eDtLLmxlbmd0aD09PTY/ej1iLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkspOno9Yi5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5LKSxRLmZvckVhY2goKHtvZmZzZXQ6Xyxjb2xvcjpGfSk9Pnt6LmFkZENvbG9yU3RvcChfLEYpfSkseD16fWIuZmlsbFN0eWxlPXgsYi5maWxsVGV4dCh5LEMsUil9aWYobSl7aWYoYi5saW5lV2lkdGg9TypvLEFycmF5LmlzQXJyYXkobSkpbT1PYmplY3QoYS5kZWZhdWx0KShtKTtlbHNlIGlmKG0udmVjdG9yKXtsZXQgejtjb25zdHt2ZWN0b3I6Syxjb2xvcnM6UX09bTtLLmxlbmd0aD09PTY/ej1iLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLkspOno9Yi5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5LKSxRLmZvckVhY2goKHtvZmZzZXQ6Xyxjb2xvcjpGfSk9Pnt6LmFkZENvbG9yU3RvcChfLEYpfSksbT16fWIuc3Ryb2tlU3R5bGU9bSxiLnN0cm9rZVRleHQoeSxDLFIpfWIucmVzdG9yZSgpO2NvbnN0IEI9e2ltYWdlOmgscmVjdDpbMCwwLEksRF19O3JldHVybiBjJiYobFtnXT1CKSxCfWxldCB2PSExO2lmKHR5cGVvZiBuYXZpZ2F0b3I9PSJvYmplY3QiJiZ0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudD09InN0cmluZyIpe2NvbnN0IHk9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9jaHJvbWVcLyhcZCspLyk7eSYmKHY9TnVtYmVyKHlbMV0pPDcwKX1mdW5jdGlvbiBkKHksUCx4PXt9KXtjb25zdCBtPXgub2Zmc2NyZWVufHwhdiYmeC5vZmZzY3JlZW4hPT0hMTtsZXQgTztyZXR1cm4gdHlwZW9mIHI8InUiJiZ0eXBlb2Ygci5jcmVhdGVDYW52YXM9PSJmdW5jdGlvbiI/Tz1yLmNyZWF0ZUNhbnZhcyh5LFAseCk6bSYmdHlwZW9mIE9mZnNjcmVlbkNhbnZhcz09ImZ1bmN0aW9uIj9PPW5ldyBPZmZzY3JlZW5DYW52YXMoeSxQKTooTz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxPLndpZHRoPXksTy5oZWlnaHQ9UCksT31jb25zdCBwPXtjcmVhdGVDYW52YXM6ZCxjcmVhdGVUZXh0OmYsbG9hZEltYWdlOm4uZGVmYXVsdC5sb2FkSW1hZ2V9O2UuZGVmYXVsdD1wfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24odSxlKXt2YXIgdDt0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3Q9dHx8bmV3IEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCl9Y2F0Y2h7dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJih0PXdpbmRvdyl9dS5leHBvcnRzPXR9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihtLE8pe2lmKHR5cGVvZiBtPT0ic3RyaW5nIil7Y29uc3QgYz1tLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbnwlKSQvKTtjP209e3NpemU6cGFyc2VGbG9hdChjWzFdKSx1bml0OmNbMl19Om09e3NpemU6cGFyc2VJbnQobSwxMCksdW5pdDoicHgifX1sZXR7c2l6ZTpvLHVuaXQ6aH09bTtpZihoPT09InB0IilvLz0uNzU7ZWxzZSBpZihoPT09InBjIilvKj0xNjtlbHNlIGlmKGg9PT0iaW4iKW8qPTk2O2Vsc2UgaWYoaD09PSJjbSIpbyo9OTYvMi41NDtlbHNlIGlmKGg9PT0ibW0iKW8qPTk2LzI1LjQ7ZWxzZSBpZihoPT09ImVtInx8aD09PSJyZW0ifHxoPT09ImV4Iil7aWYoIU8mJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBjPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTtPPXIoYywxNil9byo9TyxoPT09ImV4IiYmKG8vPTIpfWVsc2UgaWYoaD09PSJxIilvKj05Ni8yNS40LzQ7ZWxzZSBpZihoPT09InZ3Inx8aD09PSJ2aCIpe2lmKHR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IGM9aD09PSJ2dyI/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7byo9Yy8xMDB9fWVsc2UgaWYoKGg9PT0idm1heCJ8fGg9PT0idm1pbiIpJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBjPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxnPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7aD09PSJ2bWF4Ij9vKj1NYXRoLm1heChjLGcpLzEwMDpvKj1NYXRoLm1pbihjLGcpLzEwMH1yZXR1cm4gb31jb25zdCBuPSJib2xkfGJvbGRlcnxsaWdodGVyfFsxLTldMDAiLGk9Iml0YWxpY3xvYmxpcXVlIixhPSJzbWFsbC1jYXBzIixsPSJ1bHRyYS1jb25kZW5zZWR8ZXh0cmEtY29uZGVuc2VkfGNvbmRlbnNlZHxzZW1pLWNvbmRlbnNlZHxzZW1pLWV4cGFuZGVkfGV4cGFuZGVkfGV4dHJhLWV4cGFuZGVkfHVsdHJhLWV4cGFuZGVkIixzPSJweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSIsZj1gJyhbXiddKyknfCIoW14iXSspInwoW1xcdy1dfFvkuIAt6b6lXSkrYCx2PW5ldyBSZWdFeHAoYCgke259KSArYCwiaSIpLGQ9bmV3IFJlZ0V4cChgKCR7aX0pICtgLCJpIikscD1uZXcgUmVnRXhwKGAoJHthfSkgK2AsImkiKSx5PW5ldyBSZWdFeHAoYCgke2x9KSArYCwiaSIpLFA9bmV3IFJlZ0V4cCgiKFtcXGRcXC5dKykoIitzKyIpKD86XFwvKFtcXGRcXC5dKykoIitzKyIpKT8gKigoPzoiK2YrIikoICosICooPzoiK2YrIikpKikiKTtmdW5jdGlvbiB4KG0sTyl7Y29uc3Qgbz1QLmV4ZWMobSk7aWYoIW8pcmV0dXJuO2NvbnN0IGg9cGFyc2VGbG9hdChvWzNdKSxjPXt3ZWlnaHQ6Im5vcm1hbCIsc3R5bGU6Im5vcm1hbCIsc3RyZXRjaDoibm9ybWFsIix2YXJpYW50OiJub3JtYWwiLHNpemU6cGFyc2VGbG9hdChvWzFdKSx1bml0Om9bMl0sbGluZUhlaWdodDpOdW1iZXIuaXNGaW5pdGUoaCk/aDp2b2lkIDAsbGluZUhlaWdodFVuaXQ6b1s0XSxmYW1pbHk6b1s1XS5yZXBsYWNlKC8gKiwgKi9nLCIsIil9LGc9bS5zdWJzdHJpbmcoMCxvLmluZGV4KSxiPXYuZXhlYyhnKSxFPWQuZXhlYyhnKSxBPXAuZXhlYyhnKSxMPXkuZXhlYyhnKTtyZXR1cm4gYiYmKGMud2VpZ2h0PWJbMV0pLEUmJihjLnN0eWxlPUVbMV0pLEEmJihjLnZhcmlhbnQ9QVsxXSksTCYmKGMuc3RyZXRjaD1MWzFdKSxjLnB4SGVpZ2h0PXIoe3NpemU6Yy5zaXplLHVuaXQ6Yy51bml0fSxPKSxjLnB4TGluZUhlaWdodD1yKHtzaXplOmMubGluZUhlaWdodHx8Yy5zaXplLHVuaXQ6Yy5saW5lSGVpZ2h0VW5pdHx8Yy51bml0fSxPKSxjfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG4pe3JldHVybmByZ2JhKCR7bi5tYXAoKGksYSk9PmE8Mz9NYXRoLnJvdW5kKGkqMjU1KTppKS5qb2luKCl9KWB9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJhcHBseUZpbHRlciIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJkcmF3TWVzaDJEIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgxKSxuPXQoMjQpLGk9dCgyMyksYT10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbCh2LGQpe2NvbnN0IHA9di5jYW52YXM7di5zYXZlKCksdi5maWx0ZXI9ZCx2LmRyYXdJbWFnZShwLDAsMCxwLndpZHRoLHAuaGVpZ2h0KSx2LnJlc3RvcmUoKX1mdW5jdGlvbiBzKHYsZCl7Y29uc3QgcD0vcmdiYVwoKFxkKyksKFxkKyksKFxkKyksKFxkKylcKS87dj12Lm1hdGNoKHApLnNsaWNlKDEsNSkubWFwKE51bWJlciksZD1kLm1hdGNoKHApLnNsaWNlKDEsNSkubWFwKE51bWJlcik7Y29uc3QgeT1bXSxQPWRbM107Zm9yKGxldCB4PTA7eDw0O3grKyl5W3hdPU9iamVjdChhLm1peCkodlt4XSxkW3hdLFApO3JldHVybmByZ2JhKCR7eS5qb2luKCl9KWB9ZnVuY3Rpb24gZih2LGQscD0hMCx5PW51bGwsUD1udWxsLHg9bnVsbCxtPW51bGwpe2Quc2F2ZSgpO2xldCBPPSExLG89ITE7aWYoZC5nbG9iYWxBbHBoYT12LmdldE9wYWNpdHkoKSx2Ll91cGRhdGVNYXRyaXgmJnYudHJhbnNmb3JtU2NhbGUvdi5jb250b3Vycy5zY2FsZT4xLjUmJnYuYWNjdXJhdGUodi50cmFuc2Zvcm1TY2FsZSksdi5saW5lV2lkdGgpe2xldCBnPXYuZ3JhZGllbnQmJnYuZ3JhZGllbnQuc3Ryb2tlO2lmKGcpe2NvbnN0e3ZlY3RvcjpiLGNvbG9yczpFfT1nO2lmKGIubGVuZ3RoPT09NilnPWQuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4uYik7ZWxzZSBpZihiLmxlbmd0aD09PTQpZz1kLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLmIpO2Vsc2UgaWYoYi5sZW5ndGg9PT0zKWc9ZC5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLmIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO0UuZm9yRWFjaCgoe29mZnNldDpBLGNvbG9yOkx9KT0+e2xldCBNPU9iamVjdChuLmRlZmF1bHQpKEwpO1AmJihNPXMoTSxQKSksZy5hZGRDb2xvclN0b3AoQSxNKX0pLGQuc3Ryb2tlU3R5bGU9ZyxPPSEwfWVsc2Ugdi5zdHJva2VTdHlsZSYmKFA/ZC5zdHJva2VTdHlsZT1zKHYuc3Ryb2tlU3R5bGUsUCk6ZC5zdHJva2VTdHlsZT12LnN0cm9rZVN0eWxlLE89ITApfU8mJihkLmxpbmVXaWR0aD12LmxpbmVXaWR0aCxkLmxpbmVKb2luPXYubGluZUpvaW4sZC5saW5lQ2FwPXYubGluZUNhcCxkLm1pdGVyTGltaXQ9di5taXRlckxpbWl0LHYubGluZURhc2gmJihkLnNldExpbmVEYXNoKHYubGluZURhc2gpLHYubGluZURhc2hPZmZzZXQmJihkLmxpbmVEYXNoT2Zmc2V0PXYubGluZURhc2hPZmZzZXQpKSk7bGV0IGg9di5ncmFkaWVudCYmdi5ncmFkaWVudC5maWxsO2lmKGgpe2NvbnN0e3ZlY3RvcjpnLGNvbG9yczpifT1oO2lmKGcubGVuZ3RoPT09NiloPWQuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4uZyk7ZWxzZSBpZihnLmxlbmd0aD09PTQpaD1kLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLmcpO2Vsc2UgaWYoZy5sZW5ndGg9PT0zKWg9ZC5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLmcpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO2IuZm9yRWFjaCgoe29mZnNldDpFLGNvbG9yOkF9KT0+e2xldCBMPU9iamVjdChuLmRlZmF1bHQpKEEpO1AmJihMPXMoTCxQKSksaC5hZGRDb2xvclN0b3AoRSxMKX0pLGQuZmlsbFN0eWxlPWgsbz0hMH1lbHNlIHYuZmlsbFN0eWxlJiYoeT9kLmZpbGxTdHlsZT1zKHYuZmlsbFN0eWxlLHkpOmQuZmlsbFN0eWxlPXYuZmlsbFN0eWxlLG89ITApO2lmKG0mJmQudHJhbnNmb3JtKC4uLm0pLGQudHJhbnNmb3JtKC4uLnYudHJhbnNmb3JtTWF0cml4KSx2LmNsaXBQYXRoKXtjb25zdCBnPXYuY2xpcFBhdGgsYj1uZXcgUGF0aDJEKGcpO2QuY2xpcChiKX1jb25zdCBjPXYuY29udG91cnMubGVuZ3RoO2lmKHYuY29udG91cnMuZm9yRWFjaCgoZyxiKT0+e2NvbnN0IEU9Zy5sZW5ndGgsQT1FPjEmJnIudmVjMi5lcXVhbHMoZ1swXSxnW0UtMV0pLEw9Yj09PWMtMSYmdi50ZXh0dXJlO2lmKGcmJkU+MCl7aWYob3x8T3x8TCl7ZC5iZWdpblBhdGgoKSxkLm1vdmVUbyguLi5nWzBdKTtmb3IobGV0IE09MTtNPEU7TSsrKU09PT1FLTEmJkE/ZC5jbG9zZVBhdGgoKTpkLmxpbmVUbyguLi5nW01dKX1pZihvJiZkLmZpbGwodi5maWxsUnVsZSksTCl7ZC5zYXZlKCksZC5jbGlwKCk7bGV0e2ltYWdlOk0sb3B0aW9uczpJfT12LnRleHR1cmU7aWYoeCYmKE09eCksSS5yZXBlYXQmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIGltYWdlIHJlcGVhdCB5ZXQuIiksTS5mb250KXtJLnNjYWxlJiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNjYWxlIHlldC4iKSxJLnNyY1JlY3QmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIHRleHQgc3JjUmVjdCB5ZXQuIik7bGV0e2ZvbnQ6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpDLHN0cm9rZVdpZHRoOkIsdGV4dDp6fT1NOyFSJiYhQyYmKFI9IiMwMDAiKSxBcnJheS5pc0FycmF5KFIpJiYoUj1PYmplY3Qobi5kZWZhdWx0KShSKSksQXJyYXkuaXNBcnJheShDKSYmKEM9T2JqZWN0KG4uZGVmYXVsdCkoQykpLGQuZm9udD1EO2NvbnN0e3dpZHRoOkt9PWQubWVhc3VyZVRleHQoeiksUT1PYmplY3QoaS5kZWZhdWx0KShEKSxfPU1hdGgubWF4KFEucHhMaW5lSGVpZ2h0LFEucHhIZWlnaHQqMS4xMyk7ZC50ZXh0QWxpZ249ImNlbnRlciIsZC50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgRj1JLnJlY3QsRz1GWzBdK18qLjUrUS5weEhlaWdodCouMDYsWD1GWzFdK0sqLjU7RlsyXSE9bnVsbCYmZC5zY2FsZShGWzJdL0ssRlszXS9fKSxSJiYoZC5maWxsU3R5bGU9UixkLmZpbGxUZXh0KHosWCxHKSksQyYmKGQubGluZVdpZHRoPUIsZC5zdHJva2VTdHlsZT1DLGQuc3Ryb2tlVGV4dCh6LFgsRykpfWVsc2V7bGV0IEQ9SS5yZWN0O2NvbnN0IFI9SS5zcmNSZWN0O0kuc2NhbGUmJihEPVswLDAsZC5jYW52YXMud2lkdGgsZC5jYW52YXMuaGVpZ2h0XSksSS5yb3RhdGVkJiZEJiYoRD1bLURbMV0sRFswXSxEWzNdLERbMl1dKSxSJiYoRD1EfHxbMCwwLFJbMl0sUlszXV0pLEkucm90YXRlZCYmKGQudHJhbnNsYXRlKDAsRD9EWzJdOk0ud2lkdGgpLGQucm90YXRlKC0uNSpNYXRoLlBJKSksUj9kLmRyYXdJbWFnZShNLC4uLlIsLi4uRCk6RD9kLmRyYXdJbWFnZShNLC4uLkQpOmQuZHJhd0ltYWdlKE0sMCwwKX1kLnJlc3RvcmUoKX1PJiZkLnN0cm9rZSgpfX0pLGQucmVzdG9yZSgpLHApe2NvbnN0IGc9di5maWx0ZXI7ZyYmbChkLGcpfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNsYW1wIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsIm1peCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJ0cmFuc2Zvcm1Qb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGEsbCxzKXtyZXR1cm4gbD5zJiYoW2wsc109W3MsbF0pLGE8bD9sOmE+cz9zOmF9ZnVuY3Rpb24gbihhLGwscyl7cmV0dXJuIGEqKDEtcykrbCpzfWZ1bmN0aW9uIGkoYSxsKXtjb25zdFtzLGZdPWE7cmV0dXJuW3MqbFswXStmKmxbMl0rbFs0XSxzKmxbMV0rZipsWzNdK2xbNV1dfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciByPXQoMjgpLG49dCgyOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoZix2LGQpe2NvbnN0IHA9Zi51bmlmb3Jtc3x8e30seT12LnVuaWZvcm1zfHx7fTtpZihwLnVfdGV4U2FtcGxlciYmeS51X3RleFNhbXBsZXImJnAudV90ZXhTYW1wbGVyIT09eS51X3RleFNhbXBsZXIpcmV0dXJuITE7Y29uc3QgUD1PYmplY3Qua2V5cyhwKSx4PU9iamVjdC5rZXlzKHkpLG09UC5pbmRleE9mKCJ1X3RleFNhbXBsZXIiKSxPPXguaW5kZXhPZigidV90ZXhTYW1wbGVyIik7aWYobT49MCYmUC5zcGxpY2UobSwxKSxPPj0wJiZ4LnNwbGljZShPLDEpLFAubGVuZ3RoIT09eC5sZW5ndGgpcmV0dXJuITE7Y29uc3Qgbz1QLmV2ZXJ5KGg9Pntjb25zdCBjPXBbaF0sZz15W2hdO2lmKGM9PT1nKXJldHVybiEwO2lmKGMubGVuZ3RoJiZnLmxlbmd0aCYmYy5sZW5ndGg9PT1nLmxlbmd0aCl7Zm9yKGxldCBiPTA7YjxjLmxlbmd0aDtiKyspaWYoY1tiXSE9PWdbYl0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9KTtpZihvKXtpZihwLnVfdGV4U2FtcGxlciYmIXkudV90ZXhTYW1wbGVyKXYuc2V0VGV4dHVyZShwLnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSk7ZWxzZSBpZighcC51X3RleFNhbXBsZXImJnkudV90ZXhTYW1wbGVyKWZvcihsZXQgaD0wO2g8ZC5sZW5ndGg7aCsrKWRbaF0uc2V0VGV4dHVyZSh5LnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSl9cmV0dXJuIG99Y29uc3QgYT17fTtmdW5jdGlvbiBsKGYsdil7aWYoZi5sZW5ndGgpe2NvbnN0IGQ9T2JqZWN0KHIuZGVmYXVsdCkoZixhKTtyZXR1cm4gZC5lbmFibGVCbGVuZD12LGZbMF0uZmlsdGVyQ2FudmFzJiYoZC5maWx0ZXJDYW52YXM9ITApLGQucGFja0luZGV4PWZbMF0ucGFja0luZGV4LGQucGFja0xlbmd0aD1mLmxlbmd0aCxkLmJlZm9yZVJlbmRlcj1mWzBdLmJlZm9yZVJlbmRlcixkLnBhc3M9ZlswXS5wYXNzLGQuYWZ0ZXJSZW5kZXI9ZltmLmxlbmd0aC0xXS5hZnRlclJlbmRlcixmLmxlbmd0aD0wLGR9fWZ1bmN0aW9uKnMoZix2LGQ9ITEpe2NvbnN0IHA9W10seT1mLm9wdGlvbnMuYnVmZmVyU2l6ZTtsZXQgUD0wLHg9ITE7Zm9yKGxldCBtPTA7bTx2Lmxlbmd0aDttKyspe2NvbnN0IE89dlttXTtpZihPIGluc3RhbmNlb2Ygbi5kZWZhdWx0KXAubGVuZ3RoJiYoeWllbGQgbChwLHgpKSxQPTAseD0hMSx5aWVsZCBPO2Vsc2V7Y29uc3Qgbz1PLm1lc2hEYXRhO2lmKG8uY2xpcFBhdGgmJiFvLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXIpe2NvbnN0IGM9Zi5jcmVhdGVUZXh0dXJlKG8uY2xpcFBhdGgpO28udW5pZm9ybXMudV9jbGlwU2FtcGxlcj1jfWxldCBoPTA7aWYoKCFkfHwhTy5jYW5JZ25vcmUoKSkmJm8mJm8ucG9zaXRpb25zLmxlbmd0aCl7Ty5wYWNrSW5kZXg9bTtjb25zdCBjPU8uZmlsdGVyQ2FudmFzO2lmKGg9by5wb3NpdGlvbnMubGVuZ3RoLGN8fFAraD55KXAubGVuZ3RoJiYoeWllbGQgbChwLHgpKSxQPTAseD0hMTtlbHNlIGlmKFApe2NvbnN0IGc9cFtwLmxlbmd0aC0xXTtnJiYoZy5maWx0ZXJDYW52YXN8fGcuYWZ0ZXJSZW5kZXJ8fE8uYmVmb3JlUmVuZGVyfHxnLnBhc3MubGVuZ3RofHxPLnBhc3MubGVuZ3RofHxnLnByb2dyYW0hPT1PLnByb2dyYW18fCFpKGcsTyxwKSkmJih5aWVsZCBsKHAseCksUD0wLHg9ITEpfXAucHVzaChPKSx4PXh8fE8uZW5hYmxlQmxlbmQsUCs9aH1tPT09di5sZW5ndGgtMSYmcC5sZW5ndGgmJih5aWVsZCBsKHAseCkpfX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBpfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9e1VOU0lHTkVEX0JZVEU6VWludDhBcnJheSxVTlNJR05FRF9TSE9SVDpVaW50MTZBcnJheSxCWVRFOkludDhBcnJheSxTSE9SVDpJbnQxNkFycmF5LEZMT0FUOkZsb2F0MzJBcnJheX07ZnVuY3Rpb24gbihhLGwpe2xldCBzPTAsZj0wLHY9MCxkPTAscD0wLHk9MCxQPTA7Y29uc3QgeD1hWzBdLnByb2dyYW07Zm9yKGxldCBtPTA7bTxhLmxlbmd0aDttKyspe2NvbnN0IE89YVttXS5tZXNoRGF0YTtpZihPKXtQKz1PLnBvc2l0aW9ucy5sZW5ndGg7Y29uc3Qgbz1PLnBvc2l0aW9uc1swXS5sZW5ndGg7cys9Ty5wb3NpdGlvbnMubGVuZ3RoKm8sZis9Ty5jZWxscy5sZW5ndGgqMyx5Kz1PLmF0dHJpYnV0ZXMuYV9jb2xvci5sZW5ndGgqNDtjb25zdCBoPU8udGV4dHVyZUNvb3JkO2gmJih2Kz1oLmxlbmd0aCpoWzBdLmxlbmd0aCk7Y29uc3QgYz1PLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2MmJihkKz1jLmxlbmd0aCo0KTtjb25zdCBnPU8uYXR0cmlidXRlcy5hX2NsaXBVVjtnJiYocCs9Zy5sZW5ndGgqMil9fWlmKCghbC5wb3NpdGlvbnN8fGwucG9zaXRpb25zLmxlbmd0aDxzKSYmKGwucG9zaXRpb25zPW5ldyBGbG9hdDMyQXJyYXkocykpLCghbC5jZWxsc3x8bC5jZWxscy5sZW5ndGg8ZikmJihsLmNlbGxzPW5ldyBVaW50MTZBcnJheShmKSksdiYmKCFsLnRleHR1cmVDb29yZHx8bC50ZXh0dXJlQ29vcmQubGVuZ3RoPHYpJiYobC50ZXh0dXJlQ29vcmQ9bmV3IEZsb2F0MzJBcnJheSh2KSksKCFsLmFfY29sb3J8fGwuYV9jb2xvci5sZW5ndGg8eSkmJihsLmFfY29sb3I9bmV3IFVpbnQ4QXJyYXkoeSkpLGQmJighbC5hX3NvdXJjZVJlY3R8fGwuYV9zb3VyY2VSZWN0Lmxlbmd0aDxkKSYmKGwuYV9zb3VyY2VSZWN0PW5ldyBGbG9hdDMyQXJyYXkoZCkpLHAmJighbC5hX2NsaXBVVnx8bC5hX2NsaXBVVi5sZW5ndGg8cCkmJihsLmFfY2xpcFVWPW5ldyBGbG9hdDMyQXJyYXkocCkpLHgpe2NvbnN0IG09T2JqZWN0LmVudHJpZXMoeC5fYXR0cmlidXRlKSxPPXguX2F0dHJpYk9wdHN8fHt9O2ZvcihsZXQgbz0wO288bS5sZW5ndGg7bysrKXtjb25zdFtoLGNdPW1bb107aWYoaCE9PSJhX2NvbG9yIiYmaCE9PSJhX3NvdXJjZVJlY3QiJiZjIT09Imlnbm9yZWQiKXtjb25zdCBnPU9baF0/T1toXS50eXBlOiJGTE9BVCIsYj1yW2ddLEU9Yy5zaXplKlA7KCFsW2hdfHxsW2hdLmxlbmd0aDxFKSYmKGxbaF09bmV3IGIoRSkpfX19cmV0dXJuIGx9ZnVuY3Rpb24gaShhLGwpe2xldCBzPVtdLGY9W10sdj1bXSxkPVtdLHA9W10seT1bXSxQPTAseD0wO2NvbnN0IG09YVswXT9hWzBdLnVuaWZvcm1zfHx7fTp7fSxPPWFbMF0/YVswXS5wcm9ncmFtOm51bGw7bCYmKG4oYSxsKSxmPWwuY2VsbHMscz1sLnBvc2l0aW9ucyx2PWwudGV4dHVyZUNvb3JkLGQ9bC5hX2NvbG9yLHA9bC5hX3NvdXJjZVJlY3QseT1sLmFfY2xpcFVWKTtsZXQgbz0hMSxoPSExO2NvbnN0IGM9e307Zm9yKGxldCBiPTA7YjxhLmxlbmd0aDtiKyspe2xldCBFPWFbYl07aWYoRSl7aWYoRS5tZXNoRGF0YSYmKEU9RS5tZXNoRGF0YSksbCl7Y29uc3QgTD1FLnBvc2l0aW9ucztmb3IobGV0IE09MDtNPEwubGVuZ3RoO00rKyl7Y29uc3QgST1MW01dLEQ9MyooUCtNKTtmb3IobGV0IFI9MDtSPEkubGVuZ3RoO1IrKylzW0QrUl09SVtSXX19ZWxzZSBzLnB1c2goLi4uRS5wb3NpdGlvbnMpO2NvbnN0IEE9RS5jZWxscztmb3IobGV0IEw9MDtMPEEubGVuZ3RoO0wrKyl7Y29uc3QgTT1BW0xdO2lmKGwpe2NvbnN0IEk9MyooeCtMKTtmW0ldPU1bMF0rUCxmW0krMV09TVsxXStQLGZbSSsyXT1NWzJdK1B9ZWxzZSBmLnB1c2goW01bMF0rUCxNWzFdK1AsTVsyXStQXSl9aWYobCl7Y29uc3QgTD1FLmF0dHJpYnV0ZXMuYV9jb2xvcjtmb3IobGV0IE09MDtNPEwubGVuZ3RoO00rKyl7Y29uc3QgST1MW01dLEQ9NCooUCtNKTtkW0RdPUlbMF0sZFtEKzFdPUlbMV0sZFtEKzJdPUlbMl0sZFtEKzNdPUlbM119fWVsc2UgZC5wdXNoKC4uLkUuYXR0cmlidXRlcy5hX2NvbG9yKTtpZihFLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0KWlmKG89ITAsbCl7Y29uc3QgTD1FLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2ZvcihsZXQgTT0wO008TC5sZW5ndGg7TSsrKXtjb25zdCBJPUxbTV0sRD00KihQK00pO3BbRF09SVswXSxwW0QrMV09SVsxXSxwW0QrMl09SVsyXSxwW0QrM109SVszXX19ZWxzZSBwLnB1c2goLi4uRS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdCk7aWYoRS5hdHRyaWJ1dGVzLmFfY2xpcFVWKWlmKGg9ITAsbCl7Y29uc3QgTD1FLmF0dHJpYnV0ZXMuYV9jbGlwVVY7Zm9yKGxldCBNPTA7TTxMLmxlbmd0aDtNKyspe2NvbnN0IEk9TFtNXSxEPTIqKFArTSk7eVtEXT1JWzBdLHlbRCsxXT1JWzFdfX1lbHNlIHkucHVzaCguLi5FLmF0dHJpYnV0ZXMuYV9jbGlwVVYpO2lmKEUudGV4dHVyZUNvb3JkKWlmKGwpe2NvbnN0IEw9RS50ZXh0dXJlQ29vcmQ7Zm9yKGxldCBNPTA7TTxMLmxlbmd0aDtNKyspe2NvbnN0IEk9TFtNXSxEPTMqKFArTSk7Zm9yKGxldCBSPTA7UjxJLmxlbmd0aDtSKyspdltEK1JdPUlbUl19fWVsc2Ugdi5wdXNoKC4uLkUudGV4dHVyZUNvb3JkKTtpZihPKXtjb25zdCBMPU9iamVjdC5lbnRyaWVzKE8uX2F0dHJpYnV0ZSk7Zm9yKGxldCBNPTA7TTxMLmxlbmd0aDtNKyspe2NvbnN0W0ksRF09TFtNXTtpZihJIT09ImFfY29sb3IiJiZJIT09ImFfc291cmNlUmVjdCImJkQhPT0iaWdub3JlZCIpaWYoY1tJXT1bXSxsKXtjW0ldPWxbSV07Y29uc3QgUj1FLmF0dHJpYnV0ZXNbSV0sQz1SWzBdLmxlbmd0aDtmb3IobGV0IEI9MDtCPFIubGVuZ3RoO0IrKyl7Y29uc3Qgej1SW0JdLEs9QyooUCtCKTtmb3IobGV0IFE9MDtRPHoubGVuZ3RoO1ErKyljW0ldW0srUV09eltRXX19ZWxzZSBjW0ldLnB1c2goLi4uRS5hdHRyaWJ1dGVzW0ldKX19UCs9RS5wb3NpdGlvbnMubGVuZ3RoLHgrPUUuY2VsbHMubGVuZ3RofX1jLmFfY29sb3I9ZCxvJiZwJiZwLmxlbmd0aD4wJiYoYy5hX3NvdXJjZVJlY3Q9cCk7Y29uc3QgZz17cG9zaXRpb25zOnMsY2VsbHM6ZixhdHRyaWJ1dGVzOmMsdW5pZm9ybXM6bSxjZWxsc0NvdW50OngqMyxwcm9ncmFtOk99O3JldHVybiB2JiZ2Lmxlbmd0aCYmKGcudGV4dHVyZUNvb3JkPXYpLGgmJnkubGVuZ3RoPjAmJihjLmFfY2xpcFVWPXkpLGd9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpO3ZhciByPXQoMSksbj10KDMwKSxpPXQoMjYpLGE9dCgzMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwoYyxnKXt2YXIgYj1PYmplY3Qua2V5cyhjKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgRT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGMpO2cmJihFPUUuZmlsdGVyKGZ1bmN0aW9uKEEpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGMsQSkuZW51bWVyYWJsZX0pKSxiLnB1c2guYXBwbHkoYixFKX1yZXR1cm4gYn1mdW5jdGlvbiBzKGMpe2Zvcih2YXIgZz0xO2c8YXJndW1lbnRzLmxlbmd0aDtnKyspe3ZhciBiPWFyZ3VtZW50c1tnXSE9bnVsbD9hcmd1bWVudHNbZ106e307ZyUyP2woT2JqZWN0KGIpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEUpe2YoYyxFLGJbRV0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiKSk6bChPYmplY3QoYikpLmZvckVhY2goZnVuY3Rpb24oRSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGMsRSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsRSkpfSl9cmV0dXJuIGN9ZnVuY3Rpb24gZihjLGcsYil7cmV0dXJuIGcgaW4gYz9PYmplY3QuZGVmaW5lUHJvcGVydHkoYyxnLHt2YWx1ZTpiLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Y1tnXT1iLGN9Y29uc3Qgdj1TeW1ib2woIm1lc2giKSxkPVN5bWJvbCgiY291bnQiKSxwPVN5bWJvbCgiYmxlbmQiKSx5PVN5bWJvbCgiZmlsdGVyIiksUD1TeW1ib2woInRleHR1cmVzIikseD1TeW1ib2woInRleHR1cmVPcHRpb25zIiksbT1TeW1ib2woImNsb3VkQ29sb3IiKSxPPVN5bWJvbCgiY2xvdWRGaWx0ZXIiKSxvPVN5bWJvbCgiYnVmZmVyIik7ZnVuY3Rpb24gaChjLGc9bnVsbCl7Y29uc3QgYj1uZXcgRmxvYXQzMkFycmF5KDMqYyksRT1uZXcgRmxvYXQzMkFycmF5KDMqYyksQT1uZXcgRmxvYXQzMkFycmF5KDQqYyksTD1uZXcgRmxvYXQzMkFycmF5KDQqYyksTT1uZXcgRmxvYXQzMkFycmF5KDQqYyksST1uZXcgRmxvYXQzMkFycmF5KDQqYyksRD1uZXcgRmxvYXQzMkFycmF5KDQqYyksUj1uZXcgVWludDhBcnJheShjKSxDPW5ldyBVaW50OEFycmF5KDQqYyksQj1uZXcgVWludDhBcnJheSg0KmMpO3JldHVybiBnJiYoYi5zZXQoZy50cmFuc2Zvcm0wLDApLEUuc2V0KGcudHJhbnNmb3JtMSwwKSxBLnNldChnLmNvbG9yMCwwKSxMLnNldChnLmNvbG9yMSwwKSxNLnNldChnLmNvbG9yMiwwKSxJLnNldChnLmNvbG9yMywwKSxELnNldChnLmNvbG9yNCwwKSxSLnNldChnLmZyYW1lSW5kZXgsMCksQy5zZXQoZy5maWxsQ29sb3IsMCksQi5zZXQoZy5zdHJva2VDb2xvciwwKSkse2J1ZmZlclNpemU6Yyx0cmFuc2Zvcm0wOmIsdHJhbnNmb3JtMTpFLGNvbG9yMDpBLGNvbG9yMTpMLGNvbG9yMjpNLGNvbG9yMzpJLGNvbG9yNDpELGZyYW1lSW5kZXg6UixmaWxsQ29sb3I6QyxzdHJva2VDb2xvcjpCfX1lLmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoYyxnPTEse2J1ZmZlcjpiPTFlM309e30pe2I9TWF0aC5tYXgoYixnKSx0aGlzW2RdPWcsdGhpc1t2XT1jLHRoaXNbb109aChiKSx0aGlzW1BdPVtdLHRoaXNbeV09W10sdGhpc1ttXT0hMSx0aGlzW09dPSExLHRoaXNbcF09ITEsdGhpcy5pbml0QnVmZmVyKCl9aW5pdEJ1ZmZlcihjPTApe2NvbnN0IGc9dGhpc1tkXTtmb3IobGV0IGI9YztiPGc7YisrKXRoaXNbb10udHJhbnNmb3JtMC5zZXQoWzEsMCwwXSxiKjMpLHRoaXNbb10udHJhbnNmb3JtMS5zZXQoWzAsMSwwXSxiKjMpLHRoaXNbb10uZnJhbWVJbmRleC5zZXQoWy0xXSxiKSx0aGlzW29dLmZpbGxDb2xvci5zZXQoWzAsMCwwLDBdLGIqNCksdGhpc1tvXS5zdHJva2VDb2xvci5zZXQoWzAsMCwwLDBdLGIqNCksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShiLG51bGwpfWdldCBidWZmZXJTaXplKCl7cmV0dXJuIHRoaXNbb10uYnVmZmVyU2l6ZX1nZXQgbWVzaCgpe3JldHVybiB0aGlzW3ZdfXNldCBtZXNoKGMpe3RoaXNbdl09Yyx0aGlzW1BdJiZ0aGlzLnNldFRleHR1cmVGcmFtZXModGhpc1tQXSx0aGlzW3hdKX1nZXQgaGFzQ2xvdWRDb2xvcigpe3JldHVybiB0aGlzW21dfWdldCBoYXNDbG91ZEZpbHRlcigpe3JldHVybiB0aGlzW09dfV9nZXRGaWx0ZXIoYyl7cmV0dXJuIHRoaXNbeV1bY109dGhpc1t5XVtjXXx8W10sdGhpc1t5XVtjXX1nZXRGaWx0ZXIoYyl7cmV0dXJuIHRoaXMuX2dldEZpbHRlcihjKS5qb2luKCIgIil9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbdl0uZW5hYmxlQmxlbmR8fHRoaXNbcF19Y2FuSWdub3JlKCl7cmV0dXJuIHRoaXNbdl0uY2FuSWdub3JlKCl9ZGVsZXRlKGMpe2lmKGM+PXRoaXNbZF18fGM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdHt0cmFuc2Zvcm0wOmcsdHJhbnNmb3JtMTpiLGNvbG9yMDpFLGNvbG9yMTpBLGNvbG9yMjpMLGNvbG9yMzpNLGNvbG9yNDpJLGZyYW1lSW5kZXg6RCxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpDfT10aGlzW29dO2cuc2V0KGcuc3ViYXJyYXkoMyooYysxKSksMypjKSxiLnNldChiLnN1YmFycmF5KDMqKGMrMSkpLDMqYyksRS5zZXQoRS5zdWJhcnJheSg0KihjKzEpKSw0KmMpLEEuc2V0KEEuc3ViYXJyYXkoNCooYysxKSksNCpjKSxMLnNldChMLnN1YmFycmF5KDQqKGMrMSkpLDQqYyksTS5zZXQoTS5zdWJhcnJheSg0KihjKzEpKSw0KmMpLEkuc2V0KEkuc3ViYXJyYXkoNCooYysxKSksNCpjKSxELnNldChELnN1YmFycmF5KGMrMSksYyksUi5zZXQoUi5zdWJhcnJheSg0KihjKzEpKSw0KmMpLEMuc2V0KEMuc3ViYXJyYXkoNCooYysxKSksNCpjKTtmb3IoY29uc3QgQiBpbiB0aGlzW3ldKUI9PT1jP2RlbGV0ZSB0aGlzW3ldW0JdOkI+YyYmKHRoaXNbeV1bQi0xXT10aGlzW3ldW0JdLGRlbGV0ZSB0aGlzW3ldW0JdKTt0aGlzW2RdLS19c2V0Q29sb3JUcmFuc2Zvcm0oYyxnKXtpZihjPj10aGlzW2RdfHxjPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Yyo9NDtjb25zdHtjb2xvcjA6Yixjb2xvcjE6RSxjb2xvcjI6QSxjb2xvcjM6TCxjb2xvcjQ6TX09dGhpc1tvXTtyZXR1cm4gZyE9bnVsbD8oYi5zZXQoW2dbMF0sZ1s1XSxnWzEwXSxnWzE1XV0sYyksRS5zZXQoW2dbMV0sZ1s2XSxnWzExXSxnWzE2XV0sYyksQS5zZXQoW2dbMl0sZ1s3XSxnWzEyXSxnWzE3XV0sYyksTC5zZXQoW2dbM10sZ1s4XSxnWzEzXSxnWzE4XV0sYyksTS5zZXQoW2dbNF0sZ1s5XSxnWzE0XSxnWzE5XV0sYyksdGhpc1twXT10aGlzW3BdfHxnWzE4XTwxLHRoaXNbT109ITApOihiLnNldChbMSwwLDAsMF0sYyksRS5zZXQoWzAsMSwwLDBdLGMpLEEuc2V0KFswLDAsMSwwXSxjKSxMLnNldChbMCwwLDAsMV0sYyksTS5zZXQoWzAsMCwwLDBdLGMpKSx0aGlzfWdldENvbG9yVHJhbnNmb3JtKGMpe2lmKGM+PXRoaXNbZF18fGM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjKj00O2NvbnN0e2NvbG9yMDpnLGNvbG9yMTpiLGNvbG9yMjpFLGNvbG9yMzpBLGNvbG9yNDpMfT10aGlzW29dO3JldHVybltnW2NdLGJbY10sRVtjXSxBW2NdLExbY10sZ1tjKzFdLGJbYysxXSxFW2MrMV0sQVtjKzFdLExbYysxXSxnW2MrMl0sYltjKzJdLEVbYysyXSxBW2MrMl0sTFtjKzJdLGdbYyszXSxiW2MrM10sRVtjKzNdLEFbYyszXSxMW2MrM11dfXRyYW5zZm9ybUNvbG9yKGMsZyl7bGV0IGI9dGhpcy5nZXRDb2xvclRyYW5zZm9ybShjKTtyZXR1cm4gYj1PYmplY3Qobi5tdWx0aXBseSkoYixnKSx0aGlzLnNldENvbG9yVHJhbnNmb3JtKGMsYiksdGhpc31zZXRGaWxsQ29sb3IoYyxnKXtpZihjPj10aGlzW2RdfHxjPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7dHlwZW9mIGc9PSJzdHJpbmciJiYoZz1PYmplY3QoYS5kZWZhdWx0KShnKSksZ1szXT4wJiYodGhpc1ttXT0hMCksdGhpc1tvXS5maWxsQ29sb3Iuc2V0KGcubWFwKGI9Pk1hdGgucm91bmQoMjU1KmIpKSw0KmMpfXNldFN0cm9rZUNvbG9yKGMsZyl7aWYoYz49dGhpc1tkXXx8YzwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBnPT0ic3RyaW5nIiYmKGc9T2JqZWN0KGEuZGVmYXVsdCkoZykpLGdbM10+MCYmKHRoaXNbbV09ITApLHRoaXNbb10uc3Ryb2tlQ29sb3Iuc2V0KGcubWFwKGI9Pk1hdGgucm91bmQoMjU1KmIpKSw0KmMpfWdldENsb3VkUkdCQShjKXtpZihjPj10aGlzW2RdfHxjPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Yyo9NDtjb25zdHtmaWxsQ29sb3I6ZyxzdHJva2VDb2xvcjpifT10aGlzW29dLEU9W2dbY10sZ1tjKzFdLGdbYysyXSxnW2MrM11dLEE9W2JbY10sYltjKzFdLGJbYysyXSxiW2MrM11dO3JldHVybiBFWzNdLz0yNTUsQVszXS89MjU1LHtmaWxsOmByZ2JhKCR7RS5qb2luKCl9KWAsc3Ryb2tlOmByZ2JhKCR7QS5qb2luKCl9KWB9fWdyYXlzY2FsZShjLGcpe3RoaXMudHJhbnNmb3JtQ29sb3IoYyxPYmplY3Qobi5ncmF5c2NhbGUpKGcpKSx0aGlzLl9nZXRGaWx0ZXIoYykucHVzaChgZ3JheXNjYWxlKCR7MTAwKmd9JSlgKX1icmlnaHRuZXNzKGMsZyl7dGhpcy50cmFuc2Zvcm1Db2xvcihjLE9iamVjdChuLmJyaWdodG5lc3MpKGcpKSx0aGlzLl9nZXRGaWx0ZXIoYykucHVzaChgYnJpZ2h0bmVzcygkezEwMCpnfSUpYCl9c2F0dXJhdGUoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4uc2F0dXJhdGUpKGcpKSx0aGlzLl9nZXRGaWx0ZXIoYykucHVzaChgc2F0dXJhdGUoJHsxMDAqZ30lKWApfWNvbnRyYXN0KGMsZyl7dGhpcy50cmFuc2Zvcm1Db2xvcihjLE9iamVjdChuLmNvbnRyYXN0KShnKSksdGhpcy5fZ2V0RmlsdGVyKGMpLnB1c2goYGNvbnRyYXN0KCR7MTAwKmd9JSlgKX1pbnZlcnQoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4uaW52ZXJ0KShnKSksdGhpcy5fZ2V0RmlsdGVyKGMpLnB1c2goYGludmVydCgkezEwMCpnfSUpYCl9c2VwaWEoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4uc2VwaWEpKGcpKSx0aGlzLl9nZXRGaWx0ZXIoYykucHVzaChgc2VwaWEoJHsxMDAqZ30lKWApfW9wYWNpdHkoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4ub3BhY2l0eSkoZykpLHRoaXMuX2dldEZpbHRlcihjKS5wdXNoKGBvcGFjaXR5KCR7MTAwKmd9JSlgKX1odWVSb3RhdGUoYyxnKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGMsT2JqZWN0KG4uaHVlUm90YXRlKShnKSksdGhpcy5fZ2V0RmlsdGVyKGMpLnB1c2goYGh1ZS1yb3RhdGUoJHtnfWRlZylgKX1zZXRUcmFuc2Zvcm0oYyxnKXtpZihjPj10aGlzW2RdfHxjPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Yyo9MyxnPT1udWxsJiYoZz1bMSwwLDAsMSwwLDBdKTtjb25zdHt0cmFuc2Zvcm0wOmIsdHJhbnNmb3JtMTpFfT10aGlzW29dO3JldHVybiBiLnNldChbZ1swXSxnWzJdLGdbNF1dLGMpLEUuc2V0KFtnWzFdLGdbM10sZ1s1XV0sYyksdGhpc31nZXRUcmFuc2Zvcm0oYyl7aWYoYz49dGhpc1tkXXx8YzwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2MqPTM7Y29uc3R7dHJhbnNmb3JtMDpnLHRyYW5zZm9ybTE6Yn09dGhpc1tvXTtyZXR1cm5bZ1tjXSxiW2NdLGdbYysxXSxiW2MrMV0sZ1tjKzJdLGJbYysyXV19Z2V0VGV4dHVyZUZyYW1lKGMpe3JldHVybiB0aGlzW1BdW3RoaXNbb10uZnJhbWVJbmRleFtjXV19c2V0VGV4dHVyZUZyYW1lcyhjPVtdLGc9e30pe2lmKGMubGVuZ3RoPjEyKXRocm93IG5ldyBFcnJvcigiTWF4IGZyYW1lcyBleGNlZWQuIEFsbG93IDEyIGZyYW1lcy4iKTtjLmxlbmd0aCYmdGhpc1t2XS5zZXRUZXh0dXJlKGNbMF0sZyksdGhpc1tQXT1jLHRoaXNbeF09Z31zZXRGcmFtZUluZGV4KGMsZyl7aWYoYz49dGhpc1tkXXx8YzwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2NvbnN0IGI9dGhpc1tQXS5sZW5ndGg7aWYoYjw9MCl0aHJvdyBuZXcgRXJyb3IoIk5vIGZyYW1lcyIpO3RoaXNbb10uZnJhbWVJbmRleFtjXT1nJWJ9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2RdfXNldCBhbW91bnQoYyl7Y29uc3QgZz10aGlzW2RdO2MhPT1nJiYoYz50aGlzW29dLmJ1ZmZlclNpemUmJih0aGlzW29dPWgoTWF0aC5tYXgoYyx0aGlzW29dLmJ1ZmZlclNpemUrMWUzKSx0aGlzW29dKSksdGhpc1tkXT1jLGM+ZyYmdGhpcy5pbml0QnVmZmVyKGcpKX1nZXQgbWVzaERhdGEoKXtjb25zdHthdHRyaWJ1dGVzOmMsY2VsbHM6Zyxwb3NpdGlvbnM6Yix0ZXh0dXJlQ29vcmQ6RSx1bmlmb3JtczpBfT10aGlzW3ZdLm1lc2hEYXRhLEw9dGhpc1tQXSxNPXthdHRyaWJ1dGVzOnMoe30sYyksY2VsbHM6Zyxwb3NpdGlvbnM6Yix0ZXh0dXJlQ29vcmQ6RSx1bmlmb3JtczpzKHt9LEEpLGluc3RhbmNlQ291bnQ6dGhpc1tkXSxlbmFibGVCbGVuZDp0aGlzLmVuYWJsZUJsZW5kfTtMLmxlbmd0aCYmTC5mb3JFYWNoKChHLFgpPT57TS51bmlmb3Jtc1tgdV90ZXhGcmFtZSR7WH1gXT1HfSk7Y29uc3R7dHJhbnNmb3JtMDpJLHRyYW5zZm9ybTE6RCxjb2xvcjA6Uixjb2xvcjE6Qyxjb2xvcjI6Qixjb2xvcjM6eixjb2xvcjQ6SyxmaWxsQ29sb3I6USxzdHJva2VDb2xvcjpfLGZyYW1lSW5kZXg6Rn09dGhpc1tvXTtyZXR1cm4gdGhpc1t2XS51bmlmb3Jtcy51X3RleFNhbXBsZXImJihNLmF0dHJpYnV0ZXMuYV9mcmFtZUluZGV4PXtkYXRhOkYsZGl2aXNvcjoxfSksTS5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMD17ZGF0YTpJLGRpdmlzb3I6MX0sTS5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMT17ZGF0YTpELGRpdmlzb3I6MX0sTS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDA9e2RhdGE6UixkaXZpc29yOjF9LE0uYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQxPXtkYXRhOkMsZGl2aXNvcjoxfSxNLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMj17ZGF0YTpCLGRpdmlzb3I6MX0sTS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDM9e2RhdGE6eixkaXZpc29yOjF9LE0uYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQ0PXtkYXRhOkssZGl2aXNvcjoxfSx0aGlzLmhhc0Nsb3VkQ29sb3ImJihNLmF0dHJpYnV0ZXMuYV9maWxsQ2xvdWRDb2xvcj17ZGF0YTpRLGRpdmlzb3I6MX0sTS5hdHRyaWJ1dGVzLmFfc3Ryb2tlQ2xvdWRDb2xvcj17ZGF0YTpfLGRpdmlzb3I6MX0pLE19c2V0UHJvZ3JhbShjKXt0aGlzW3ZdLnNldFByb2dyYW0oYyl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1t2XS5wcm9ncmFtfXRyYW5zZm9ybShjLGcpe2NvbnN0IGI9dGhpcy5nZXRUcmFuc2Zvcm0oYyk7cmV0dXJuIGc9ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksYixnKSx0aGlzLnNldFRyYW5zZm9ybShjLGcpLHRoaXN9dHJhbnNsYXRlKGMsW2csYl0pe2xldCBFPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEU9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEUsW2csYl0pLHRoaXMudHJhbnNmb3JtKGMsRSl9cm90YXRlKGMsZyxbYixFXT1bMCwwXSl7bGV0IEE9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gQT1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQSxbYixFXSksQT1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQSxnKSxBPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxBLFstYiwtRV0pLHRoaXMudHJhbnNmb3JtKGMsQSl9c2NhbGUoYyxbZyxiPWddLFtFLEFdPVswLDBdKXtsZXQgTD1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBMPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLFtFLEFdKSxMPXIubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEwsW2csYl0pLEw9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEwsWy1FLC1BXSksdGhpcy50cmFuc2Zvcm0oYyxMKX1za2V3KGMsW2csYj1nXSxbRSxBXT1bMCwwXSl7bGV0IEw9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxbRSxBXSksTD1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxMLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKGIpLE1hdGgudGFuKGcpLDEsMCwwKSksTD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTCxbLUUsLUFdKSx0aGlzLnRyYW5zZm9ybShjLEwpfWlzUG9pbnRDb2xsaXNpb24oYyxbZyxiXSxFPSJib3RoIil7Y29uc3QgQT10aGlzLmdldFRyYW5zZm9ybShjKSxMPU9iamVjdChpLnRyYW5zZm9ybVBvaW50KShbZyxiXSxyLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksQSkpO3JldHVybiB0aGlzW3ZdLmlzUG9pbnRDb2xsaXNpb24oLi4uTCxFKX1pc1BvaW50SW5GaWxsKGMsW2csYl0pe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oYyxbZyxiXSwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShjLFtnLGJdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGMsW2csYl0sInN0cm9rZSIpfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImdyYXlzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJicmlnaHRuZXNzIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNhdHVyYXRlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNvbnRyYXN0IixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJzZXBpYSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJvcGFjaXR5IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImh1ZVJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pO3ZhciByPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHksUCl7Y29uc3QgeD1bXSxtPXlbMF0sTz15WzFdLG89eVsyXSxoPXlbM10sYz15WzRdLGc9eVs1XSxiPXlbNl0sRT15WzddLEE9eVs4XSxMPXlbOV0sTT15WzEwXSxJPXlbMTFdLEQ9eVsxMl0sUj15WzEzXSxDPXlbMTRdLEI9eVsxNV0sej15WzE2XSxLPXlbMTddLFE9eVsxOF0sXz15WzE5XTtsZXQgRj1QWzBdLEc9UFsxXSxYPVBbMl0sWj1QWzNdLHR0PVBbNF07cmV0dXJuIHhbMF09RiptK0cqZytYKk0rWipCLHhbMV09RipPK0cqYitYKkkrWip6LHhbMl09RipvK0cqRStYKkQrWipLLHhbM109RipoK0cqQStYKlIrWipRLHhbNF09RipjK0cqTCtYKkMrWipfK3R0LEY9UFs1XSxHPVBbNl0sWD1QWzddLFo9UFs4XSx0dD1QWzldLHhbNV09RiptK0cqZytYKk0rWipCLHhbNl09RipPK0cqYitYKkkrWip6LHhbN109RipvK0cqRStYKkQrWipLLHhbOF09RipoK0cqQStYKlIrWipRLHhbOV09RipjK0cqTCtYKkMrWipfK3R0LEY9UFsxMF0sRz1QWzExXSxYPVBbMTJdLFo9UFsxM10sdHQ9UFsxNF0seFsxMF09RiptK0cqZytYKk0rWipCLHhbMTFdPUYqTytHKmIrWCpJK1oqeix4WzEyXT1GKm8rRypFK1gqRCtaKksseFsxM109RipoK0cqQStYKlIrWipRLHhbMTRdPUYqYytHKkwrWCpDK1oqXyt0dCxGPVBbMTVdLEc9UFsxNl0sWD1QWzE3XSxaPVBbMThdLHR0PVBbMTldLHhbMTVdPUYqbStHKmcrWCpNK1oqQix4WzE2XT1GKk8rRypiK1gqSStaKnoseFsxN109RipvK0cqRStYKkQrWipLLHhbMThdPUYqaCtHKkErWCpSK1oqUSx4WzE5XT1GKmMrRypMK1gqQytaKl8rdHQseH1mdW5jdGlvbiBpKHkpe3k9T2JqZWN0KHIuY2xhbXApKDAsMSx5KTtjb25zdCBQPS4yMTI2KnkseD0uNzE1Mip5LG09LjA3MjIqeTtyZXR1cm5bUCsxLXkseCxtLDAsMCxQLHgrMS15LG0sMCwwLFAseCxtKzEteSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBhKHkpe3JldHVyblt5LDAsMCwwLDAsMCx5LDAsMCwwLDAsMCx5LDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGwoeSl7Y29uc3QgUD0uMjEyNiooMS15KSx4PS43MTUyKigxLXkpLG09LjA3MjIqKDEteSk7cmV0dXJuW1AreSx4LG0sMCwwLFAseCt5LG0sMCwwLFAseCxtK3ksMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gcyh5KXtjb25zdCBQPS41KigxLXkpO3JldHVyblt5LDAsMCwwLFAsMCx5LDAsMCxQLDAsMCx5LDAsUCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGYoeSl7Y29uc3QgUD0xLTIqeTtyZXR1cm5bUCwwLDAsMCx5LDAsUCwwLDAseSwwLDAsUCwwLHksMCwwLDAsMSwwXX1mdW5jdGlvbiB2KHkpe3JldHVyblsxLS42MDcqeSwuNzY5KnksLjE4OSp5LDAsMCwuMzQ5KnksMS0uMzE0KnksLjE2OCp5LDAsMCwuMjcyKnksLjUzNCp5LDEtLjg2OSp5LDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGQoeSl7cmV0dXJuWzEsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLHksMF19ZnVuY3Rpb24gcCh5KXtjb25zdCBQPXkvMTgwKk1hdGguUEkseD1NYXRoLmNvcyhQKSxtPU1hdGguc2luKFApLE89LjIxMjYsbz0uNzE1MixoPS4wNzIyO3JldHVybltPK3gqKDEtTykrbSotTyxvK3gqLW8rbSotbyxoK3gqLWgrbSooMS1oKSwwLDAsTyt4Ki1PK20qLjE0MyxvK3gqKDEtbykrbSouMTQsaCt4Ki1oK20qLS4yODMsMCwwLE8reCotTyttKi0oMS1PKSxvK3gqLW8rbSpvLGgreCooMS1oKSttKmgsMCwwLDAsMCwwLDEsMF19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBpfSk7dmFyIHI9dCgzMiksbj10Lm4ocik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGkoYSl7Y29uc3QgbD1uKCkoYSk7aWYoIWx8fCFsLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybltsWzBdLzI1NSxsWzFdLzI1NSxsWzJdLzI1NSxsWzNdXX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDMzKSxuPXQoMzcpLGk9dCgzOSk7dS5leHBvcnRzPWZ1bmN0aW9uKGwpe3ZhciBzLGY9cihsKTtyZXR1cm4gZi5zcGFjZT8ocz1BcnJheSgzKSxzWzBdPWkoZi52YWx1ZXNbMF0sMCwyNTUpLHNbMV09aShmLnZhbHVlc1sxXSwwLDI1NSksc1syXT1pKGYudmFsdWVzWzJdLDAsMjU1KSxmLnNwYWNlWzBdPT09ImgiJiYocz1uLnJnYihzKSkscy5wdXNoKGkoZi5hbHBoYSwwLDEpKSxzKTpbXX19LGZ1bmN0aW9uKHUsZSx0KXsoZnVuY3Rpb24ocil7dmFyIG49dCgzNCksaT10KDM1KSxhPXQoMzYpO3UuZXhwb3J0cz1zO3ZhciBsPXtyZWQ6MCxvcmFuZ2U6NjAseWVsbG93OjEyMCxncmVlbjoxODAsYmx1ZToyNDAscHVycGxlOjMwMH07ZnVuY3Rpb24gcyhmKXt2YXIgdixkPVtdLHA9MSx5O2lmKHR5cGVvZiBmPT0ic3RyaW5nIilpZihuW2ZdKWQ9bltmXS5zbGljZSgpLHk9InJnYiI7ZWxzZSBpZihmPT09InRyYW5zcGFyZW50IilwPTAseT0icmdiIixkPVswLDAsMF07ZWxzZSBpZigvXiNbQS1GYS1mMC05XSskLy50ZXN0KGYpKXt2YXIgUD1mLnNsaWNlKDEpLHg9UC5sZW5ndGgsbT14PD00O3A9MSxtPyhkPVtwYXJzZUludChQWzBdK1BbMF0sMTYpLHBhcnNlSW50KFBbMV0rUFsxXSwxNikscGFyc2VJbnQoUFsyXStQWzJdLDE2KV0seD09PTQmJihwPXBhcnNlSW50KFBbM10rUFszXSwxNikvMjU1KSk6KGQ9W3BhcnNlSW50KFBbMF0rUFsxXSwxNikscGFyc2VJbnQoUFsyXStQWzNdLDE2KSxwYXJzZUludChQWzRdK1BbNV0sMTYpXSx4PT09OCYmKHA9cGFyc2VJbnQoUFs2XStQWzddLDE2KS8yNTUpKSxkWzBdfHwoZFswXT0wKSxkWzFdfHwoZFsxXT0wKSxkWzJdfHwoZFsyXT0wKSx5PSJyZ2IifWVsc2UgaWYodj0vXigoPzpyZ2J8aHNbbHZiXXxod2J8Y215az98eHlbenldfGdyYXl8bGFifGxjaHU/dj98W2x5XXV2fGxtcylhPylccypcKChbXlwpXSopXCkvLmV4ZWMoZikpe3ZhciBPPXZbMV0sbz1PPT09InJnYiIsUD1PLnJlcGxhY2UoL2EkLywiIik7eT1QO3ZhciB4PVA9PT0iY215ayI/NDpQPT09ImdyYXkiPzE6MztkPXZbMl0udHJpbSgpLnNwbGl0KC9ccyosXHMqLykubWFwKGZ1bmN0aW9uKGIsRSl7aWYoLyUkLy50ZXN0KGIpKXJldHVybiBFPT09eD9wYXJzZUZsb2F0KGIpLzEwMDpQPT09InJnYiI/cGFyc2VGbG9hdChiKSoyNTUvMTAwOnBhcnNlRmxvYXQoYik7aWYoUFtFXT09PSJoIil7aWYoL2RlZyQvLnRlc3QoYikpcmV0dXJuIHBhcnNlRmxvYXQoYik7aWYobFtiXSE9PXZvaWQgMClyZXR1cm4gbFtiXX1yZXR1cm4gcGFyc2VGbG9hdChiKX0pLE89PT1QJiZkLnB1c2goMSkscD1vfHxkW3hdPT09dm9pZCAwPzE6ZFt4XSxkPWQuc2xpY2UoMCx4KX1lbHNlIGYubGVuZ3RoPjEwJiYvWzAtOV0oPzpcc3xcLykvLnRlc3QoZikmJihkPWYubWF0Y2goLyhbMC05XSspL2cpLm1hcChmdW5jdGlvbihjKXtyZXR1cm4gcGFyc2VGbG9hdChjKX0pLHk9Zi5tYXRjaCgvKFthLXpdKS9pZykuam9pbigiIikudG9Mb3dlckNhc2UoKSk7ZWxzZSBpZighaXNOYU4oZikpeT0icmdiIixkPVtmPj4+MTYsKGYmNjUyODApPj4+OCxmJjI1NV07ZWxzZSBpZihpKGYpKXt2YXIgaD1hKGYucixmLnJlZCxmLlIsbnVsbCk7aCE9PW51bGw/KHk9InJnYiIsZD1baCxhKGYuZyxmLmdyZWVuLGYuRyksYShmLmIsZi5ibHVlLGYuQildKTooeT0iaHNsIixkPVthKGYuaCxmLmh1ZSxmLkgpLGEoZi5zLGYuc2F0dXJhdGlvbixmLlMpLGEoZi5sLGYubGlnaHRuZXNzLGYuTCxmLmIsZi5icmlnaHRuZXNzKV0pLHA9YShmLmEsZi5hbHBoYSxmLm9wYWNpdHksMSksZi5vcGFjaXR5IT1udWxsJiYocC89MTAwKX1lbHNlKEFycmF5LmlzQXJyYXkoZil8fHIuQXJyYXlCdWZmZXImJkFycmF5QnVmZmVyLmlzVmlldyYmQXJyYXlCdWZmZXIuaXNWaWV3KGYpKSYmKGQ9W2ZbMF0sZlsxXSxmWzJdXSx5PSJyZ2IiLHA9Zi5sZW5ndGg9PT00P2ZbM106MSk7cmV0dXJue3NwYWNlOnksdmFsdWVzOmQsYWxwaGE6cH19fSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17YWxpY2VibHVlOlsyNDAsMjQ4LDI1NV0sYW50aXF1ZXdoaXRlOlsyNTAsMjM1LDIxNV0sYXF1YTpbMCwyNTUsMjU1XSxhcXVhbWFyaW5lOlsxMjcsMjU1LDIxMl0sYXp1cmU6WzI0MCwyNTUsMjU1XSxiZWlnZTpbMjQ1LDI0NSwyMjBdLGJpc3F1ZTpbMjU1LDIyOCwxOTZdLGJsYWNrOlswLDAsMF0sYmxhbmNoZWRhbG1vbmQ6WzI1NSwyMzUsMjA1XSxibHVlOlswLDAsMjU1XSxibHVldmlvbGV0OlsxMzgsNDMsMjI2XSxicm93bjpbMTY1LDQyLDQyXSxidXJseXdvb2Q6WzIyMiwxODQsMTM1XSxjYWRldGJsdWU6Wzk1LDE1OCwxNjBdLGNoYXJ0cmV1c2U6WzEyNywyNTUsMF0sY2hvY29sYXRlOlsyMTAsMTA1LDMwXSxjb3JhbDpbMjU1LDEyNyw4MF0sY29ybmZsb3dlcmJsdWU6WzEwMCwxNDksMjM3XSxjb3Juc2lsazpbMjU1LDI0OCwyMjBdLGNyaW1zb246WzIyMCwyMCw2MF0sY3lhbjpbMCwyNTUsMjU1XSxkYXJrYmx1ZTpbMCwwLDEzOV0sZGFya2N5YW46WzAsMTM5LDEzOV0sZGFya2dvbGRlbnJvZDpbMTg0LDEzNCwxMV0sZGFya2dyYXk6WzE2OSwxNjksMTY5XSxkYXJrZ3JlZW46WzAsMTAwLDBdLGRhcmtncmV5OlsxNjksMTY5LDE2OV0sZGFya2toYWtpOlsxODksMTgzLDEwN10sZGFya21hZ2VudGE6WzEzOSwwLDEzOV0sZGFya29saXZlZ3JlZW46Wzg1LDEwNyw0N10sZGFya29yYW5nZTpbMjU1LDE0MCwwXSxkYXJrb3JjaGlkOlsxNTMsNTAsMjA0XSxkYXJrcmVkOlsxMzksMCwwXSxkYXJrc2FsbW9uOlsyMzMsMTUwLDEyMl0sZGFya3NlYWdyZWVuOlsxNDMsMTg4LDE0M10sZGFya3NsYXRlYmx1ZTpbNzIsNjEsMTM5XSxkYXJrc2xhdGVncmF5Ols0Nyw3OSw3OV0sZGFya3NsYXRlZ3JleTpbNDcsNzksNzldLGRhcmt0dXJxdW9pc2U6WzAsMjA2LDIwOV0sZGFya3Zpb2xldDpbMTQ4LDAsMjExXSxkZWVwcGluazpbMjU1LDIwLDE0N10sZGVlcHNreWJsdWU6WzAsMTkxLDI1NV0sZGltZ3JheTpbMTA1LDEwNSwxMDVdLGRpbWdyZXk6WzEwNSwxMDUsMTA1XSxkb2RnZXJibHVlOlszMCwxNDQsMjU1XSxmaXJlYnJpY2s6WzE3OCwzNCwzNF0sZmxvcmFsd2hpdGU6WzI1NSwyNTAsMjQwXSxmb3Jlc3RncmVlbjpbMzQsMTM5LDM0XSxmdWNoc2lhOlsyNTUsMCwyNTVdLGdhaW5zYm9ybzpbMjIwLDIyMCwyMjBdLGdob3N0d2hpdGU6WzI0OCwyNDgsMjU1XSxnb2xkOlsyNTUsMjE1LDBdLGdvbGRlbnJvZDpbMjE4LDE2NSwzMl0sZ3JheTpbMTI4LDEyOCwxMjhdLGdyZWVuOlswLDEyOCwwXSxncmVlbnllbGxvdzpbMTczLDI1NSw0N10sZ3JleTpbMTI4LDEyOCwxMjhdLGhvbmV5ZGV3OlsyNDAsMjU1LDI0MF0saG90cGluazpbMjU1LDEwNSwxODBdLGluZGlhbnJlZDpbMjA1LDkyLDkyXSxpbmRpZ286Wzc1LDAsMTMwXSxpdm9yeTpbMjU1LDI1NSwyNDBdLGtoYWtpOlsyNDAsMjMwLDE0MF0sbGF2ZW5kZXI6WzIzMCwyMzAsMjUwXSxsYXZlbmRlcmJsdXNoOlsyNTUsMjQwLDI0NV0sbGF3bmdyZWVuOlsxMjQsMjUyLDBdLGxlbW9uY2hpZmZvbjpbMjU1LDI1MCwyMDVdLGxpZ2h0Ymx1ZTpbMTczLDIxNiwyMzBdLGxpZ2h0Y29yYWw6WzI0MCwxMjgsMTI4XSxsaWdodGN5YW46WzIyNCwyNTUsMjU1XSxsaWdodGdvbGRlbnJvZHllbGxvdzpbMjUwLDI1MCwyMTBdLGxpZ2h0Z3JheTpbMjExLDIxMSwyMTFdLGxpZ2h0Z3JlZW46WzE0NCwyMzgsMTQ0XSxsaWdodGdyZXk6WzIxMSwyMTEsMjExXSxsaWdodHBpbms6WzI1NSwxODIsMTkzXSxsaWdodHNhbG1vbjpbMjU1LDE2MCwxMjJdLGxpZ2h0c2VhZ3JlZW46WzMyLDE3OCwxNzBdLGxpZ2h0c2t5Ymx1ZTpbMTM1LDIwNiwyNTBdLGxpZ2h0c2xhdGVncmF5OlsxMTksMTM2LDE1M10sbGlnaHRzbGF0ZWdyZXk6WzExOSwxMzYsMTUzXSxsaWdodHN0ZWVsYmx1ZTpbMTc2LDE5NiwyMjJdLGxpZ2h0eWVsbG93OlsyNTUsMjU1LDIyNF0sbGltZTpbMCwyNTUsMF0sbGltZWdyZWVuOls1MCwyMDUsNTBdLGxpbmVuOlsyNTAsMjQwLDIzMF0sbWFnZW50YTpbMjU1LDAsMjU1XSxtYXJvb246WzEyOCwwLDBdLG1lZGl1bWFxdWFtYXJpbmU6WzEwMiwyMDUsMTcwXSxtZWRpdW1ibHVlOlswLDAsMjA1XSxtZWRpdW1vcmNoaWQ6WzE4Niw4NSwyMTFdLG1lZGl1bXB1cnBsZTpbMTQ3LDExMiwyMTldLG1lZGl1bXNlYWdyZWVuOls2MCwxNzksMTEzXSxtZWRpdW1zbGF0ZWJsdWU6WzEyMywxMDQsMjM4XSxtZWRpdW1zcHJpbmdncmVlbjpbMCwyNTAsMTU0XSxtZWRpdW10dXJxdW9pc2U6WzcyLDIwOSwyMDRdLG1lZGl1bXZpb2xldHJlZDpbMTk5LDIxLDEzM10sbWlkbmlnaHRibHVlOlsyNSwyNSwxMTJdLG1pbnRjcmVhbTpbMjQ1LDI1NSwyNTBdLG1pc3R5cm9zZTpbMjU1LDIyOCwyMjVdLG1vY2Nhc2luOlsyNTUsMjI4LDE4MV0sbmF2YWpvd2hpdGU6WzI1NSwyMjIsMTczXSxuYXZ5OlswLDAsMTI4XSxvbGRsYWNlOlsyNTMsMjQ1LDIzMF0sb2xpdmU6WzEyOCwxMjgsMF0sb2xpdmVkcmFiOlsxMDcsMTQyLDM1XSxvcmFuZ2U6WzI1NSwxNjUsMF0sb3JhbmdlcmVkOlsyNTUsNjksMF0sb3JjaGlkOlsyMTgsMTEyLDIxNF0scGFsZWdvbGRlbnJvZDpbMjM4LDIzMiwxNzBdLHBhbGVncmVlbjpbMTUyLDI1MSwxNTJdLHBhbGV0dXJxdW9pc2U6WzE3NSwyMzgsMjM4XSxwYWxldmlvbGV0cmVkOlsyMTksMTEyLDE0N10scGFwYXlhd2hpcDpbMjU1LDIzOSwyMTNdLHBlYWNocHVmZjpbMjU1LDIxOCwxODVdLHBlcnU6WzIwNSwxMzMsNjNdLHBpbms6WzI1NSwxOTIsMjAzXSxwbHVtOlsyMjEsMTYwLDIyMV0scG93ZGVyYmx1ZTpbMTc2LDIyNCwyMzBdLHB1cnBsZTpbMTI4LDAsMTI4XSxyZWJlY2NhcHVycGxlOlsxMDIsNTEsMTUzXSxyZWQ6WzI1NSwwLDBdLHJvc3licm93bjpbMTg4LDE0MywxNDNdLHJveWFsYmx1ZTpbNjUsMTA1LDIyNV0sc2FkZGxlYnJvd246WzEzOSw2OSwxOV0sc2FsbW9uOlsyNTAsMTI4LDExNF0sc2FuZHlicm93bjpbMjQ0LDE2NCw5Nl0sc2VhZ3JlZW46WzQ2LDEzOSw4N10sc2Vhc2hlbGw6WzI1NSwyNDUsMjM4XSxzaWVubmE6WzE2MCw4Miw0NV0sc2lsdmVyOlsxOTIsMTkyLDE5Ml0sc2t5Ymx1ZTpbMTM1LDIwNiwyMzVdLHNsYXRlYmx1ZTpbMTA2LDkwLDIwNV0sc2xhdGVncmF5OlsxMTIsMTI4LDE0NF0sc2xhdGVncmV5OlsxMTIsMTI4LDE0NF0sc25vdzpbMjU1LDI1MCwyNTBdLHNwcmluZ2dyZWVuOlswLDI1NSwxMjddLHN0ZWVsYmx1ZTpbNzAsMTMwLDE4MF0sdGFuOlsyMTAsMTgwLDE0MF0sdGVhbDpbMCwxMjgsMTI4XSx0aGlzdGxlOlsyMTYsMTkxLDIxNl0sdG9tYXRvOlsyNTUsOTksNzFdLHR1cnF1b2lzZTpbNjQsMjI0LDIwOF0sdmlvbGV0OlsyMzgsMTMwLDIzOF0sd2hlYXQ6WzI0NSwyMjIsMTc5XSx3aGl0ZTpbMjU1LDI1NSwyNTVdLHdoaXRlc21va2U6WzI0NSwyNDUsMjQ1XSx5ZWxsb3c6WzI1NSwyNTUsMF0seWVsbG93Z3JlZW46WzE1NCwyMDUsNTBdfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe3ZhciBpO3JldHVybiByLmNhbGwobik9PT0iW29iamVjdCBPYmplY3RdIiYmKGk9T2JqZWN0LmdldFByb3RvdHlwZU9mKG4pLGk9PT1udWxsfHxpPT09T2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSl9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspaWYoYXJndW1lbnRzW3RdIT09dm9pZCAwKXJldHVybiBhcmd1bWVudHNbdF19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgzOCk7dS5leHBvcnRzPXtuYW1lOiJoc2wiLG1pbjpbMCwwLDBdLG1heDpbMzYwLDEwMCwxMDBdLGNoYW5uZWw6WyJodWUiLCJzYXR1cmF0aW9uIiwibGlnaHRuZXNzIl0sYWxpYXM6WyJIU0wiXSxyZ2I6ZnVuY3Rpb24obil7dmFyIGk9blswXS8zNjAsYT1uWzFdLzEwMCxsPW5bMl0vMTAwLHMsZix2LGQscDtpZihhPT09MClyZXR1cm4gcD1sKjI1NSxbcCxwLHBdO2w8LjU/Zj1sKigxK2EpOmY9bCthLWwqYSxzPTIqbC1mLGQ9WzAsMCwwXTtmb3IodmFyIHk9MDt5PDM7eSsrKXY9aSsxLzMqLSh5LTEpLHY8MD92Kys6dj4xJiZ2LS0sNip2PDE/cD1zKyhmLXMpKjYqdjoyKnY8MT9wPWY6Myp2PDI/cD1zKyhmLXMpKigyLzMtdikqNjpwPXMsZFt5XT1wKjI1NTtyZXR1cm4gZH19LHIuaHNsPWZ1bmN0aW9uKG4pe3ZhciBpPW5bMF0vMjU1LGE9blsxXS8yNTUsbD1uWzJdLzI1NSxzPU1hdGgubWluKGksYSxsKSxmPU1hdGgubWF4KGksYSxsKSx2PWYtcyxkLHAseTtyZXR1cm4gZj09PXM/ZD0wOmk9PT1mP2Q9KGEtbCkvdjphPT09Zj9kPTIrKGwtaSkvdjpsPT09ZiYmKGQ9NCsoaS1hKS92KSxkPU1hdGgubWluKGQqNjAsMzYwKSxkPDAmJihkKz0zNjApLHk9KHMrZikvMixmPT09cz9wPTA6eTw9LjU/cD12LyhmK3MpOnA9di8oMi1mLXMpLFtkLHAqMTAwLHkqMTAwXX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9e25hbWU6InJnYiIsbWluOlswLDAsMF0sbWF4OlsyNTUsMjU1LDI1NV0sY2hhbm5lbDpbInJlZCIsImdyZWVuIiwiYmx1ZSJdLGFsaWFzOlsiUkdCIl19fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz10O2Z1bmN0aW9uIHQocixuLGkpe3JldHVybiBuPGk/cjxuP246cj5pP2k6cjpyPGk/aTpyPm4/bjpyfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciByPXQoNDEpLG49dC5uKHIpLGk9dCg0MiksYT10Lm4oaSksbD10KDQzKSxzPXQubihsKSxmPXQoNDQpLHY9dCg0NiksZD10Lm4odikscD10KDUzKSx5PXQoNTUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBQPVN5bWJvbCgiY29udG91cnMiKSx4PVN5bWJvbCgicGF0aCIpLG09U3ltYm9sKCJzaW1wbGlmeSIpLE89U3ltYm9sKCJzY2FsZSIpLG89MipNYXRoLlBJO2NsYXNzIGh7Y29uc3RydWN0b3IoZz17fSl7dHlwZW9mIGc9PSJzdHJpbmciJiYoZz17cGF0aDpnfSksZy5wYXRoP3RoaXNbeF09bigpKGcucGF0aCk6dGhpc1t4XT1bXSx0aGlzW1BdPW51bGwsdGhpc1ttXT1nLnNpbXBsaWZ5IT1udWxsP2cuc2ltcGxpZnk6MCx0aGlzW09dPWcuc2NhbGUhPW51bGw/Zy5zY2FsZToyfWdldCBjb250b3Vycygpe2xldCBnPW51bGw7aWYoIXRoaXNbUF0mJnRoaXNbeF0pe2NvbnN0IGI9T2JqZWN0KGYuZGVmYXVsdCkocygpKHRoaXNbeF0pKTt0aGlzW1BdPWQoKShiLHRoaXNbT10sdGhpc1ttXSksdGhpc1tQXS5wYXRoPWIsdGhpc1tQXS5zaW1wbGlmeT10aGlzW21dLHRoaXNbUF0uc2NhbGU9dGhpc1tPXX1yZXR1cm4gdGhpc1tQXSYmKGc9dGhpc1tQXS5tYXAoYj0+Wy4uLmJdKSxnLnBhdGg9dGhpc1tQXS5wYXRoLGcuc2ltcGxpZnk9dGhpc1tQXS5zaW1wbGlmeSxnLnNjYWxlPXRoaXNbUF0uc2NhbGUpLGd9Z2V0IHBhdGgoKXtyZXR1cm4gdGhpc1t4XX1nZXQgc2ltcGxpZnkoKXtyZXR1cm4gdGhpc1ttXX1nZXQgYm91bmRpbmdCb3goKXtjb25zdCBnPXRoaXMuY29udG91cnM7aWYoZyYmZy5sZW5ndGgpe2NvbnN0IGI9Zy5yZWR1Y2UoKEUsQSk9PlsuLi5FLC4uLkFdKTtyZXR1cm4gYSgpKGIpfXJldHVybltbMCwwXSxbMCwwXV19Z2V0IGJvdW5kaW5nQ2VudGVyKCl7Y29uc3QgZz10aGlzLmJvdW5kaW5nQm94O3JldHVybiBnP1suNSooZ1swXVswXStnWzFdWzBdKSwuNSooZ1swXVsxXStnWzFdWzFdKV06WzAsMF19bm9ybWFsaXplKGc9MCxiPTApe2NvbnN0IEU9T2JqZWN0KGYuZGVmYXVsdCkocygpKHRoaXNbeF0pKS5tYXAoKFtBLC4uLkxdKT0+e2NvbnN0IE09W0FdO2ZvcihsZXQgST0wO0k8TC5sZW5ndGg7SSs9Mil7Y29uc3QgRD1MW0ldLWcsUj1MW0krMV0tYjtNLnB1c2goRCxSKX1yZXR1cm4gTX0pO3JldHVybiB0aGlzLmJlZ2luUGF0aCgpLHRoaXNbeF0ucHVzaCguLi5FKSx0aGlzfWdldFBvaW50QXRMZW5ndGgoZyl7cmV0dXJuIHRoaXMuY29udG91cnM/T2JqZWN0KHAuZ2V0UG9pbnRBdExlbmd0aCkodGhpc1tQXSxnKTpudWxsfWdldFRvdGFsTGVuZ3RoKCl7cmV0dXJuIHRoaXMuY29udG91cnM/T2JqZWN0KHAuZ2V0VG90YWxMZW5ndGgpKHRoaXNbUF0pOjB9YWRkUGF0aChnKXt0aGlzW1BdPW51bGwsdHlwZW9mIGc9PSJzdHJpbmciJiYoZz1uKCkoZykpLHRoaXNbeF0ucHVzaCguLi5nKX1iZWdpblBhdGgoKXt0aGlzW3hdPVtdLHRoaXNbUF09bnVsbH1jbGVhcigpe3RoaXMuYmVnaW5QYXRoKCl9ZWxsaXBzZShnLGIsRSxBLEwsTSxJLEQ9MCl7aWYoTSs9TCxJKz1MLEU8PTB8fEE8PTB8fEk9PT1NKXJldHVybjtJPE0mJihJPU0rbysoSS1NKSVvKSxJLU0+byYmKEk9TStvKTtjb25zdCBSPUktTTtSPj1vJiYoSS09LjAwMSk7bGV0IEM9dGhpc1t4XS5sZW5ndGg+MCYmUjxvPyJMIjoiTSI7Y29uc3QgQj1PYmplY3QoeS5nZXRQb2ludCkoZyxiLEUsQSxNKSx6PU9iamVjdCh5LmdldFBvaW50KShnLGIsRSxBLEkpLEs9KyFEO2xldCBRPVI+TWF0aC5QST8xOjA7RCYmKFE9MS1RKSxDKz1CLmpvaW4oIiAiKSxDKz1gQSR7RX0gJHtBfSAwICR7UX0gJHtLfSAke3ouam9pbigiICIpfWAsUj49byYmKEMrPSJaIiksdGhpcy5hZGRQYXRoKEMpfWFyYyhnLGIsRSxBLEwsTT0wKXtyZXR1cm4gdGhpcy5lbGxpcHNlKGcsYixFLEUsMCxBLEwsTSl9YXJjVG8oZyxiLEUsQSxMLE0sSSl7dGhpc1tQXT1udWxsLHRoaXNbeF0ucHVzaChbIkEiLGcsYixFLEEsTCxNLEldKX1tb3ZlVG8oZyxiKXt0aGlzW1BdPW51bGwsdGhpc1t4XS5wdXNoKFsiTSIsZyxiXSl9bGluZVRvKGcsYil7dGhpc1tQXT1udWxsLHRoaXNbeF0ucHVzaChbIkwiLGcsYl0pfWJlemllckN1cnZlVG8oZyxiLEUsQSxMLE0pe3RoaXNbUF09bnVsbCx0aGlzW3hdLnB1c2goWyJDIixnLGIsRSxBLEwsTV0pfXF1YWRyYXRpY0N1cnZlVG8oZyxiLEUsQSl7dGhpc1tQXT1udWxsLHRoaXNbeF0ucHVzaChbIlEiLGcsYixFLEFdKX1yZWN0KGcsYixFLEEpe2NvbnN0IEw9YE0ke2d9ICR7Yn1MJHtnK0V9ICR7Yn1MJHtnK0V9ICR7YitBfUwke2d9ICR7YitBfVpgO3RoaXMuYWRkUGF0aChMKX1jbG9zZVBhdGgoKXt0aGlzW1BdPW51bGw7bGV0IGc9W107Y29uc3QgYj10aGlzW3hdLmxlbmd0aDtiPjAmJihnPXRoaXNbeF1bYi0xXSksZ1swXSE9PSJaIiYmZ1swXSE9PSJ6IiYmdGhpc1t4XS5wdXNoKFsiWiJdKX19fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1uO3ZhciB0PXthOjcsYzo2LGg6MSxsOjIsbToyLHE6NCxzOjQsdDoyLHY6MSx6OjB9LHI9LyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9pZztmdW5jdGlvbiBuKGwpe3ZhciBzPVtdO3JldHVybiBsLnJlcGxhY2UocixmdW5jdGlvbihmLHYsZCl7dmFyIHA9di50b0xvd2VyQ2FzZSgpO2ZvcihkPWEoZCkscD09Im0iJiZkLmxlbmd0aD4yJiYocy5wdXNoKFt2XS5jb25jYXQoZC5zcGxpY2UoMCwyKSkpLHA9ImwiLHY9dj09Im0iPyJsIjoiTCIpOzspe2lmKGQubGVuZ3RoPT10W3BdKXJldHVybiBkLnVuc2hpZnQodikscy5wdXNoKGQpO2lmKGQubGVuZ3RoPHRbcF0pdGhyb3cgbmV3IEVycm9yKCJtYWxmb3JtZWQgcGF0aCBkYXRhIik7cy5wdXNoKFt2XS5jb25jYXQoZC5zcGxpY2UoMCx0W3BdKSkpfX0pLHN9dmFyIGk9Ly0/WzAtOV0qXC4/WzAtOV0rKD86ZVstK10/XGQrKT8vaWc7ZnVuY3Rpb24gYShsKXt2YXIgcz1sLm1hdGNoKGkpO3JldHVybiBzP3MubWFwKE51bWJlcik6W119fSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXI7ZnVuY3Rpb24gcihuKXt2YXIgaT1uLmxlbmd0aDtpZihpPT09MClyZXR1cm5bW10sW11dO2Zvcih2YXIgYT1uWzBdLmxlbmd0aCxsPW5bMF0uc2xpY2UoKSxzPW5bMF0uc2xpY2UoKSxmPTE7ZjxpOysrZilmb3IodmFyIHY9bltmXSxkPTA7ZDxhOysrZCl7dmFyIHA9dltkXTtsW2RdPU1hdGgubWluKGxbZF0scCksc1tkXT1NYXRoLm1heChzW2RdLHApfXJldHVybltsLHNdfX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9dDtmdW5jdGlvbiB0KHIpe3ZhciBuPTAsaT0wLGE9MCxsPTA7cmV0dXJuIHIubWFwKGZ1bmN0aW9uKHMpe3M9cy5zbGljZSgpO3ZhciBmPXNbMF0sdj1mLnRvVXBwZXJDYXNlKCk7aWYoZiE9dilzd2l0Y2goc1swXT12LGYpe2Nhc2UiYSI6c1s2XSs9YSxzWzddKz1sO2JyZWFrO2Nhc2UidiI6c1sxXSs9bDticmVhaztjYXNlImgiOnNbMV0rPWE7YnJlYWs7ZGVmYXVsdDpmb3IodmFyIGQ9MTtkPHMubGVuZ3RoOylzW2QrK10rPWEsc1tkKytdKz1sfXN3aXRjaCh2KXtjYXNlIloiOmE9bixsPWk7YnJlYWs7Y2FzZSJIIjphPXNbMV07YnJlYWs7Y2FzZSJWIjpsPXNbMV07YnJlYWs7Y2FzZSJNIjphPW49c1sxXSxsPWk9c1syXTticmVhaztkZWZhdWx0OmE9c1tzLmxlbmd0aC0yXSxsPXNbcy5sZW5ndGgtMV19cmV0dXJuIHN9KX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgcj10KDQ1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihsKXtmb3IodmFyIHMsZj1bXSx2PTAsZD0wLHA9MCx5PTAsUD1udWxsLHg9bnVsbCxtPTAsTz0wLG89MCxoPWwubGVuZ3RoO288aDtvKyspe3ZhciBjPWxbb10sZz1jWzBdO3N3aXRjaChnKXtjYXNlIk0iOnA9Y1sxXSx5PWNbMl07YnJlYWs7Y2FzZSJBIjp2YXIgYj1PYmplY3Qoci5kZWZhdWx0KShtLE8sY1s2XSxjWzddLGNbNF0sY1s1XSxjWzFdLGNbMl0sY1szXSk7aWYoIWIubGVuZ3RoKWNvbnRpbnVlO2I9Yi5tYXAoST0+e2NvbnN0W0QsUixDLEIseixLLFEsX109STtyZXR1cm57eDE6Qyx5MTpCLHgyOnoseTI6Syx4OlEseTpffX0pO2Zvcih2YXIgRT0wLEE7RTxiLmxlbmd0aDtFKyspQT1iW0VdLGM9WyJDIixBLngxLEEueTEsQS54MixBLnkyLEEueCxBLnldLEU8Yi5sZW5ndGgtMSYmZi5wdXNoKGMpO2JyZWFrO2Nhc2UiUyI6dmFyIEw9bSxNPU87KHM9PSJDInx8cz09IlMiKSYmKEwrPUwtdixNKz1NLWQpLGM9WyJDIixMLE0sY1sxXSxjWzJdLGNbM10sY1s0XV07YnJlYWs7Y2FzZSJUIjpzPT0iUSJ8fHM9PSJUIj8oUD1tKjItUCx4PU8qMi14KTooUD1tLHg9TyksYz1hKG0sTyxQLHgsY1sxXSxjWzJdKTticmVhaztjYXNlIlEiOlA9Y1sxXSx4PWNbMl0sYz1hKG0sTyxjWzFdLGNbMl0sY1szXSxjWzRdKTticmVhaztjYXNlIkwiOmM9aShtLE8sY1sxXSxjWzJdKTticmVhaztjYXNlIkgiOmM9aShtLE8sY1sxXSxPKTticmVhaztjYXNlIlYiOmM9aShtLE8sbSxjWzFdKTticmVhaztjYXNlIloiOmM9aShtLE8scCx5KTticmVha31zPWcsbT1jW2MubGVuZ3RoLTJdLE89Y1tjLmxlbmd0aC0xXSxjLmxlbmd0aD40Pyh2PWNbYy5sZW5ndGgtNF0sZD1jW2MubGVuZ3RoLTNdKToodj1tLGQ9TyksZi5wdXNoKGMpfXJldHVybiBmfWZ1bmN0aW9uIGkobCxzLGYsdil7cmV0dXJuWyJDIixsLHMsZix2LGYsdl19ZnVuY3Rpb24gYShsLHMsZix2LGQscCl7cmV0dXJuWyJDIixsLzMrMi8zKmYscy8zKzIvMyp2LGQvMysyLzMqZixwLzMrMi8zKnYsZCxwXX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcj1NYXRoLlBJKjI7ZnVuY3Rpb24gbihzLGYsdixkKXtjb25zdCBwPXMqZC1mKnY8MD8tMToxO2xldCB5PXMqditmKmQ7cmV0dXJuIHk+MSYmKHk9MSkseTwtMSYmKHk9LTEpLHAqTWF0aC5hY29zKHkpfWZ1bmN0aW9uIGkocyxmLHYsZCxwLHksUCx4LG0sTyl7Y29uc3Qgbz1PKihzLXYpLzIrbSooZi1kKS8yLGg9LW0qKHMtdikvMitPKihmLWQpLzIsYz1QKlAsZz14KngsYj1vKm8sRT1oKmg7bGV0IEE9YypnLWMqRS1nKmI7QTwwJiYoQT0wKSxBLz1jKkUrZypiLEE9TWF0aC5zcXJ0KEEpKihwPT09eT8tMToxKTtjb25zdCBMPUEqUC94KmgsTT1BKi14L1AqbyxJPU8qTC1tKk0rKHMrdikvMixEPW0qTCtPKk0rKGYrZCkvMixSPShvLUwpL1AsQz0oaC1NKS94LEI9KC1vLUwpL1Asej0oLWgtTSkveCxLPW4oMSwwLFIsQyk7bGV0IFE9bihSLEMsQix6KTtyZXR1cm4geT09PTAmJlE+MCYmKFEtPXIpLHk9PT0xJiZRPDAmJihRKz1yKSxbSSxELEssUV19ZnVuY3Rpb24gYShzLGYpe2NvbnN0IHY9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKGYvNCksZD1NYXRoLmNvcyhzKSxwPU1hdGguc2luKHMpLHk9TWF0aC5jb3MocytmKSxQPU1hdGguc2luKHMrZik7cmV0dXJuW2QscCxkLXAqdixwK2Qqdix5K1AqdixQLXkqdix5LFBdfWZ1bmN0aW9uIGwocyxmLHYsZCxwLHksUCx4LG0pe2NvbnN0IE89TWF0aC5zaW4obSpyLzM2MCksbz1NYXRoLmNvcyhtKnIvMzYwKSxoPW8qKHMtdikvMitPKihmLWQpLzIsYz0tTyoocy12KS8yK28qKGYtZCkvMjtpZihoPT09MCYmYz09PTApcmV0dXJuW107aWYoUD09PTB8fHg9PT0wKXJldHVybltdO1A9TWF0aC5hYnMoUCkseD1NYXRoLmFicyh4KTtjb25zdCBnPWgqaC8oUCpQKStjKmMvKHgqeCk7Zz4xJiYoUCo9TWF0aC5zcXJ0KGcpLHgqPU1hdGguc3FydChnKSk7Y29uc3QgYj1pKHMsZix2LGQscCx5LFAseCxPLG8pLEU9W107bGV0IEE9YlsyXSxMPWJbM107Y29uc3QgTT1NYXRoLm1heChNYXRoLmNlaWwoTWF0aC5hYnMoTCkvKHIvNCkpLDEpO0wvPU07Zm9yKGxldCBJPTA7STxNO0krKylFLnB1c2goYShBLEwpKSxBKz1MO3JldHVybiBFLm1hcChJPT57Zm9yKGxldCBEPTA7RDxJLmxlbmd0aDtEKz0yKXtsZXQgUj1JW0QrMF0sQz1JW0QrMV07Uio9UCxDKj14O2NvbnN0IEI9bypSLU8qQyx6PU8qUitvKkM7SVtEKzBdPUIrYlswXSxJW0QrMV09eitiWzFdfXJldHVybiBJfSl9fSxmdW5jdGlvbih1LGUsdCl7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO3ZhciByPXQoNDcpLHtjb3B5Om59PXQoNDkpLGk9dCg1MCk7ZnVuY3Rpb24gYShkLHAseSl7cmV0dXJuIGRbMF09cCxkWzFdPXksZH12YXIgbD1bMCwwXSxzPVswLDBdLGY9WzAsMF07ZnVuY3Rpb24gdihkLHAseSxQKXtyKHksYShsLFBbMV0sUFsyXSksYShzLFBbM10sUFs0XSksYShmLFBbNV0sUFs2XSkscCxkKX11LmV4cG9ydHM9ZnVuY3Rpb24ocCx5LFApe3ZhciB4PVtdLG09W10sTz1bMCwwXTtyZXR1cm4gcC5mb3JFYWNoKGZ1bmN0aW9uKG8saCxjKXtpZihvWzBdPT09Ik0iKW4oTyxvLnNsaWNlKDEpKSxtLmxlbmd0aD4wJiYoeC5wdXNoKG0pLG09W10pO2Vsc2UgaWYob1swXT09PSJDIil2KG0seSxPLG8pLGEoTyxvWzVdLG9bNl0pO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJpbGxlZ2FsIHR5cGUgaW4gU1ZHOiAiK29bMF0pfSksbS5sZW5ndGg+MCYmeC5wdXNoKG0pLHgubWFwKGZ1bmN0aW9uKG8pe3JldHVybiBpKG8sUHx8MCl9KX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9dCg0OCkoKX0sZnVuY3Rpb24odSxlKXtmdW5jdGlvbiB0KG4pe3JldHVybltuWzBdLG5bMV1dfWZ1bmN0aW9uIHIobixpKXtyZXR1cm5bbixpXX11LmV4cG9ydHM9ZnVuY3Rpb24oaSl7aT1pfHx7fTt2YXIgYT10eXBlb2YgaS5yZWN1cnNpb249PSJudW1iZXIiP2kucmVjdXJzaW9uOjgsbD10eXBlb2YgaS5lcHNpbG9uPT0ibnVtYmVyIj9pLmVwc2lsb246MTE5MjA5MjllLTE0LHM9dHlwZW9mIGkucGF0aEVwc2lsb249PSJudW1iZXIiP2kucGF0aEVwc2lsb246MSxmPXR5cGVvZiBpLmFuZ2xlRXBzaWxvbj09Im51bWJlciI/aS5hbmdsZUVwc2lsb246LjAxLHY9aS5hbmdsZVRvbGVyYW5jZXx8MCxkPWkuY3VzcExpbWl0fHwwO3JldHVybiBmdW5jdGlvbih4LG0sTyxvLGgsYyl7Y3x8KGM9W10pLGg9dHlwZW9mIGg9PSJudW1iZXIiP2g6MTt2YXIgZz1zL2g7cmV0dXJuIGcqPWcscCh4LG0sTyxvLGMsZyksY307ZnVuY3Rpb24gcChQLHgsbSxPLG8saCl7by5wdXNoKHQoUCkpO3ZhciBjPVBbMF0sZz1QWzFdLGI9eFswXSxFPXhbMV0sQT1tWzBdLEw9bVsxXSxNPU9bMF0sST1PWzFdO3koYyxnLGIsRSxBLEwsTSxJLG8saCwwKSxvLnB1c2godChPKSl9ZnVuY3Rpb24geShQLHgsbSxPLG8saCxjLGcsYixFLEEpe2lmKCEoQT5hKSl7dmFyIEw9TWF0aC5QSSxNPShQK20pLzIsST0oeCtPKS8yLEQ9KG0rbykvMixSPShPK2gpLzIsQz0obytjKS8yLEI9KGgrZykvMix6PShNK0QpLzIsSz0oSStSKS8yLFE9KEQrQykvMixfPShSK0IpLzIsRj0oeitRKS8yLEc9KEsrXykvMjtpZihBPjApe3ZhciBYPWMtUCxaPWcteCx0dD1NYXRoLmFicygobS1jKSpaLShPLWcpKlgpLG50PU1hdGguYWJzKChvLWMpKlotKGgtZykqWCkscSxodDtpZih0dD5sJiZudD5sKXtpZigodHQrbnQpKih0dCtudCk8PUUqKFgqWCtaKlopKXtpZih2PGYpe2IucHVzaChyKEYsRykpO3JldHVybn12YXIgdXQ9TWF0aC5hdGFuMihoLU8sby1tKTtpZihxPU1hdGguYWJzKHV0LU1hdGguYXRhbjIoTy14LG0tUCkpLGh0PU1hdGguYWJzKE1hdGguYXRhbjIoZy1oLGMtbyktdXQpLHE+PUwmJihxPTIqTC1xKSxodD49TCYmKGh0PTIqTC1odCkscStodDx2KXtiLnB1c2gocihGLEcpKTtyZXR1cm59aWYoZCE9PTApe2lmKHE+ZCl7Yi5wdXNoKHIobSxPKSk7cmV0dXJufWlmKGh0PmQpe2IucHVzaChyKG8saCkpO3JldHVybn19fX1lbHNlIGlmKHR0Pmwpe2lmKHR0KnR0PD1FKihYKlgrWipaKSl7aWYodjxmKXtiLnB1c2gocihGLEcpKTtyZXR1cm59aWYocT1NYXRoLmFicyhNYXRoLmF0YW4yKGgtTyxvLW0pLU1hdGguYXRhbjIoTy14LG0tUCkpLHE+PUwmJihxPTIqTC1xKSxxPHYpe2IucHVzaChyKG0sTykpLGIucHVzaChyKG8saCkpO3JldHVybn1pZihkIT09MCYmcT5kKXtiLnB1c2gocihtLE8pKTtyZXR1cm59fX1lbHNlIGlmKG50Pmwpe2lmKG50Km50PD1FKihYKlgrWipaKSl7aWYodjxmKXtiLnB1c2gocihGLEcpKTtyZXR1cm59aWYocT1NYXRoLmFicyhNYXRoLmF0YW4yKGctaCxjLW8pLU1hdGguYXRhbjIoaC1PLG8tbSkpLHE+PUwmJihxPTIqTC1xKSxxPHYpe2IucHVzaChyKG0sTykpLGIucHVzaChyKG8saCkpO3JldHVybn1pZihkIT09MCYmcT5kKXtiLnB1c2gocihvLGgpKTtyZXR1cm59fX1lbHNlIGlmKFg9Ri0oUCtjKS8yLFo9Ry0oeCtnKS8yLFgqWCtaKlo8PUUpe2IucHVzaChyKEYsRykpO3JldHVybn19eShQLHgsTSxJLHosSyxGLEcsYixFLEErMSkseShGLEcsUSxfLEMsQixjLGcsYixFLEErMSl9fX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJjb21wdXRlTWl0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibm9ybWFsIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImRpcmVjdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gb30pO3ZhciByPXQoMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oaCl7cmV0dXJuW2hbMF0saFsxXV19ZnVuY3Rpb24gaSgpe3JldHVyblswLDBdfWNvbnN0IGE9ci52ZWMyLmNvcHksbD1yLnZlYzIuc2NhbGVBbmRBZGQscz1yLnZlYzIuZG90LGY9ci52ZWMyLnJvdGF0ZSx2PXIudmVjMi5jcm9zcyxkPXIudmVjMi5zdWIscD1yLnZlYzIuYWRkLHk9ci52ZWMyLm5vcm1hbGl6ZSxQPXIudmVjMi5zZXQseD1pKCk7ZnVuY3Rpb24gbShoLGMsZyxiLEUpe3AoaCxnLGIpLHkoaCxoKSxQKGMsLWhbMV0saFswXSksUCh4LC1nWzFdLGdbMF0pO2NvbnN0IEE9RS9zKGMseCk7cmV0dXJuIE1hdGguYWJzKEEpfWZ1bmN0aW9uIE8oaCxjKXtyZXR1cm4gUChoLC1jWzFdLGNbMF0pLGh9ZnVuY3Rpb24gbyhoLGMsZyl7cmV0dXJuIGQoaCxjLGcpLHkoaCxoKSxofX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoNTEpLG49dCg1Mik7dS5leHBvcnRzPWZ1bmN0aW9uKGEsbCl7cmV0dXJuIGE9cihhLGwpLGE9bihhLGwpLGF9LHUuZXhwb3J0cy5yYWRpYWxEaXN0YW5jZT1yLHUuZXhwb3J0cy5kb3VnbGFzUGV1Y2tlcj1ufSxmdW5jdGlvbih1LGUpe2Z1bmN0aW9uIHQocixuKXt2YXIgaT1yWzBdLW5bMF0sYT1yWzFdLW5bMV07cmV0dXJuIGkqaSthKmF9dS5leHBvcnRzPWZ1bmN0aW9uKG4saSl7aWYobi5sZW5ndGg8PTEpcmV0dXJuIG47aT10eXBlb2YgaT09Im51bWJlciI/aToxO2Zvcih2YXIgYT1pKmksbD1uWzBdLHM9W2xdLGYsdj0xLGQ9bi5sZW5ndGg7djxkO3YrKylmPW5bdl0sdChmLGwpPmEmJihzLnB1c2goZiksbD1mKTtyZXR1cm4gbCE9PWYmJnMucHVzaChmKSxzfX0sZnVuY3Rpb24odSxlKXtmdW5jdGlvbiB0KG4saSxhKXt2YXIgbD1pWzBdLHM9aVsxXSxmPWFbMF0tbCx2PWFbMV0tcztpZihmIT09MHx8diE9PTApe3ZhciBkPSgoblswXS1sKSpmKyhuWzFdLXMpKnYpLyhmKmYrdip2KTtkPjE/KGw9YVswXSxzPWFbMV0pOmQ+MCYmKGwrPWYqZCxzKz12KmQpfXJldHVybiBmPW5bMF0tbCx2PW5bMV0tcyxmKmYrdip2fWZ1bmN0aW9uIHIobixpLGEsbCxzKXtmb3IodmFyIGY9bCx2LGQ9aSsxO2Q8YTtkKyspe3ZhciBwPXQobltkXSxuW2ldLG5bYV0pO3A+ZiYmKHY9ZCxmPXApfWY+bCYmKHYtaT4xJiZyKG4saSx2LGwscykscy5wdXNoKG5bdl0pLGEtdj4xJiZyKG4sdixhLGwscykpfXUuZXhwb3J0cz1mdW5jdGlvbihpLGEpe2lmKGkubGVuZ3RoPD0xKXJldHVybiBpO2E9dHlwZW9mIGE9PSJudW1iZXIiP2E6MTt2YXIgbD1hKmEscz1pLmxlbmd0aC0xLGY9W2lbMF1dO3JldHVybiByKGksMCxzLGwsZiksZi5wdXNoKGlbc10pLGZ9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJnZXRUb3RhbExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJnZXRQb2ludEF0TGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImdldERhc2hDb250b3VycyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoNTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHMpe2lmKHMudG90YWxMZW5ndGghPW51bGwpcmV0dXJuIHMudG90YWxMZW5ndGg7bGV0IGY9MDtyZXR1cm4gcy5mb3JFYWNoKHY9PntsZXQgZD12WzBdO2ZvcihsZXQgcD0xO3A8di5sZW5ndGg7cCsrKXtjb25zdCB5PXZbcF07Zis9T2JqZWN0KHIuZGlzdGFuY2UpKGQseSksZD15fX0pLHMudG90YWxMZW5ndGg9ZixmfWZ1bmN0aW9uIGkocyxmLHY9ITApe2lmKGY9TnVtYmVyKGYpLCFOdW1iZXIuaXNGaW5pdGUoZikpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoZjw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJMZW5ndGggbXVzdCA+IDAiKTtjb25zdCBkPW4ocyk7aWYoZj49ZCl7Y29uc3QgeT1zW3MubGVuZ3RoLTFdLFA9eVt5Lmxlbmd0aC0yXSx4PXlbeS5sZW5ndGgtMV0sbT1NYXRoLmF0YW4yKHhbMV0tUFsxXSx4WzBdLVBbMF0pO3JldHVybntjdXJyZW50OnMubWFwKE89PlsuLi5PXSkscG9pbnQ6e3g6eFswXSx5OnhbMV0sYW5nbGU6bX19fWNvbnN0IHA9W107Zm9yKGxldCB5PTA7eTxzLmxlbmd0aDt5Kyspe3BbeV09W107Y29uc3QgUD1zW3ldO2xldCB4PVBbMF07Zm9yKGxldCBtPTE7bTxQLmxlbmd0aDttKyspe2NvbnN0IE89UFttXSxvPU9iamVjdChyLmRpc3RhbmNlKSh4LE8pO2lmKGY8byl7Y29uc3QgaD1mL28sYz1NYXRoLmF0YW4yKE9bMV0teFsxXSxPWzBdLXhbMF0pLGc9e3g6eFswXSooMS1oKStPWzBdKmgseTp4WzFdKigxLWgpK09bMV0qaCxhbmdsZTpjfTtpZihwW3ldLnB1c2goeCksZj4wJiZwW3ldLnB1c2goW2cueCxnLnldKSwhdilyZXR1cm57Y3VycmVudDpwLHBvaW50Omd9O2NvbnN0IGI9W10sRT15O2Zvcig7eTxzLmxlbmd0aDt5Kyspe2ZvcihiW3ktRV09W10seT09PUUmJmJbMF0ucHVzaChbZy54LGcueV0pO208UC5sZW5ndGg7bSsrKWJbeS1FXS5wdXNoKFBbbV0pO209MH1yZXR1cm57Y3VycmVudDpwLHBvaW50OmcscmVzdDpifX1mLT1vLHBbeV0ucHVzaCh4KSx4PU99fX1mdW5jdGlvbiBhKHMsZil7aWYoZj1OdW1iZXIoZiksIU51bWJlci5pc0Zpbml0ZShmKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UG9pbnRBdExlbmd0aCcgb24gZmlndXJlOiBUaGUgcHJvdmlkZWQgZmxvYXQgdmFsdWUgaXMgbm9uLWZpbml0ZS4iKTtpZihzLmxlbmd0aDw9MClyZXR1cm57eDowLHk6MCxhbmdsZTowfTtpZihmPD0wKXtjb25zdCB2PXNbMF1bMF0sZD1zWzBdWzFdLHA9TWF0aC5hdGFuMihkWzFdLXZbMV0sZFswXS12WzBdKTtyZXR1cm57eDp2WzBdLHk6dlsxXSxhbmdsZTpwfX1yZXR1cm4gaShzLGYsITEpLnBvaW50fWZ1bmN0aW9uIGwocyxmLHYpe2xldCBkPTAscD1mWzBdLHk9cztjb25zdCBQPVtdLHg9Zi5sZW5ndGg7aWYodj4wKXtkbyB2LT1mW2QleF0sZCsrO3doaWxlKHY+MCk7djwwJiYocD0tdixkLS0pfWVsc2UgaWYodjwwKXtkPS0xO2RvIHYrPWZbZCV4K3gtMV0sZC0tO3doaWxlKHY8MCk7dj49MCYmKGQrKyxwPWZbZCV4K3gtMV0tdil9ZG97Y29uc3QgbT1pKHkscCk7eT1tLnJlc3QsKytkJTImJlAucHVzaCguLi5tLmN1cnJlbnQpO2xldCBPPWQleDtPPDAmJihPKz14KSxwPWZbT119d2hpbGUoeSk7cmV0dXJuIFB9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihbaSxhLGxdLHMsZix2KXtyZXR1cm4gaT1pKjIvcy0xLGE9MS1hKjIvZixOdW1iZXIuaXNGaW5pdGUodik/KGw9bCoyL3YtMSxbaSxhLGxdKTpbaSxhXX1mdW5jdGlvbiBuKFtpLGEsbD0wXSxbcyxmLHY9MF0pe3JldHVybiBNYXRoLmh5cG90KHMtaSxmLWEsdi1sKX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImdldFBvaW50IixmdW5jdGlvbigpe3JldHVybiBufSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9TWF0aC5QSSoyO2Z1bmN0aW9uIG4oaSxhLGwscyxmKXtmJT1yLGY8MCYmKGYrPXIpO2NvbnN0IHY9TWF0aC50YW4oZik7aWYoTWF0aC5hYnModik8MWU1KXtjb25zdCBkPWEtdippLHA9MS9sKioyK3YqKjIvcyoqMjtsZXQgeT0tMTsoZjw9TWF0aC5QSS8yfHxmPjMqTWF0aC5QSS8yKSYmKHk9MSk7Y29uc3QgUD15Kk1hdGguc3FydCgxL3ApK2kseD12KlArZDtyZXR1cm5bUCx4XX1yZXR1cm4gZjxNYXRoLlBJP1tpLGErc106W2ksYS1zXX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KTt2YXIgcj10KDEpLG49dCg0MiksaT10Lm4obiksYT10KDU3KSxsPXQoMjgpLHM9dCgyNCksZj10KDMwKSx2PXQoNTkpLGQ9dCg1MykscD10KDYwKSx5PXQubihwKSxQPXQoNDYpLHg9dC5uKFApLG09dCgzMSksTz10KDQwKSxvPXQoMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBoKEosTil7aWYoSj09bnVsbClyZXR1cm57fTt2YXIgJD1jKEosTiksUyxUO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciB3PU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoSik7Zm9yKFQ9MDtUPHcubGVuZ3RoO1QrKylTPXdbVF0sIShOLmluZGV4T2YoUyk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoSixTKSYmKCRbU109SltTXSl9cmV0dXJuICR9ZnVuY3Rpb24gYyhKLE4pe2lmKEo9PW51bGwpcmV0dXJue307dmFyICQ9e30sUz1PYmplY3Qua2V5cyhKKSxULHc7Zm9yKHc9MDt3PFMubGVuZ3RoO3crKylUPVNbd10sIShOLmluZGV4T2YoVCk+PTApJiYoJFtUXT1KW1RdKTtyZXR1cm4gJH1jb25zdCBnPVN5bWJvbCgibWVzaCIpLGI9U3ltYm9sKCJjb250b3VycyIpLEU9U3ltYm9sKCJzdHJva2UiKSxBPVN5bWJvbCgiZmlsbCIpLEw9U3ltYm9sKCJzdHJva2VDb2xvciIpLE09U3ltYm9sKCJmaWxsQ29sb3IiKSxJPVN5bWJvbCgidHJhbnNmb3JtIiksRD1TeW1ib2woImludmVydFRyYW5zZm9ybSIpLFI9U3ltYm9sKCJ1bmlmb3JtcyIpLEM9U3ltYm9sKCJ0ZXhPcHRpb25zIiksQj1TeW1ib2woImJsZW5kIiksej1TeW1ib2woImFwcGx5VGV4dHVyZSIpLEs9U3ltYm9sKCJhcHBseVRyYW5zZm9ybSIpLFE9U3ltYm9sKCJhcHBseUdyYWRpZW50VHJhbnNmb3JtIiksXz1TeW1ib2woImFwcGx5UHJvZ3JhbSIpLEY9U3ltYm9sKCJncmFkaWVudCIpLEc9U3ltYm9sKCJmaWx0ZXIiKSxYPVN5bWJvbCgib3BhY2l0eSIpLFo9U3ltYm9sKCJwcm9ncmFtIiksdHQ9U3ltYm9sKCJhdHRyaWJ1dGVzIiksbnQ9U3ltYm9sKCJwYXNzIikscT1TeW1ib2woImNsaXBDb250ZXh0IiksaHQ9U3ltYm9sKCJhcHBseUNsaXBQYXRoIik7ZnVuY3Rpb24gdXQoSixOKXtjb25zdFskLFNdPVtKWzFdWzBdLUpbMF1bMF0sSlsxXVsxXS1KWzBdWzFdXSxUPVtdO2ZvcihsZXQgdz0wO3c8Ti5sZW5ndGg7dysrKXtjb25zdCBVPU5bd10sSD1bKFVbMF0tSlswXVswXSkvJCwxLShVWzFdLUpbMF1bMV0pL1NdO1QucHVzaChIKX1yZXR1cm4gVH1mdW5jdGlvbiBqKFtKLE5dLFskLFMsVCx3XSx7c2NhbGU6VX0pe3JldHVybiBVfHwoSi89VCxOPTEtTi93LEotPSQsTis9UyksW0osTiwwXX1mdW5jdGlvbiBXKEosTiwkKXtjb25zdCBTPXgoKShKLE4sJCk7cmV0dXJuIFMucGF0aD1KLFMuc2ltcGxpZnk9JCxTLnNjYWxlPU4sU31jbGFzcyBWe2NvbnN0cnVjdG9yKE4pe3RoaXNbRV09bnVsbCx0aGlzW0FdPW51bGwsdGhpc1tJXT1bMSwwLDAsMSwwLDBdLHRoaXNbWF09MSx0aGlzW1JdPXt9LHRoaXNbR109W10sdGhpc1tCXT1udWxsLHRoaXNbQ109e30sdGhpcy5jb250b3Vycz1OLmNvbnRvdXJzLHRoaXNbWl09bnVsbCx0aGlzW3R0XT17fSx0aGlzW250XT1bXX1nZXQgY29udG91cnMoKXtyZXR1cm4gdGhpc1tiXX1zZXQgY29udG91cnMoTil7dGhpc1tnXT1udWxsLHRoaXNbYl09Tjtjb25zdCAkPU4uc2NhbGU7dGhpcy50cmFuc2Zvcm1TY2FsZS8kPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKX1zZXRQcm9ncmFtKE4pe3RoaXNbWl09Tix0aGlzW2ddJiZ0aGlzW19dKE4pfWdldCBwcm9ncmFtKCl7cmV0dXJuIHRoaXNbWl19c2V0QXR0cmlidXRlKE4sJCl7JD09bnVsbD9kZWxldGUgdGhpc1t0dF1bTl06dGhpc1t0dF1bTl09JH1nZXRPcGFjaXR5KCl7cmV0dXJuIHRoaXNbWF19c2V0T3BhY2l0eShOKXtpZihOPDB8fE4+MSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIG9wYWNpdHkgdmFsdWUuIik7dGhpc1tnXSYmdGhpc1tnXS5wb3NpdGlvbnMuZm9yRWFjaCgkPT57JFsyXT0xLyRbMl0+MD9OOi1OfSksdGhpc1tYXT1OfXNldENsaXBQYXRoKE4pe3RoaXMuY2xpcFBhdGg9Tix0aGlzW1JdLnVfY2xpcFNhbXBsZXImJnRoaXNbUl0udV9jbGlwU2FtcGxlci5kZWxldGUoKSx0aGlzLnNldFVuaWZvcm1zKHt1X2NsaXBTYW1wbGVyOm51bGx9KSx0aGlzW2ddJiZkZWxldGUgdGhpc1tnXS5hdHRyaWJ1dGVzLmFfY2xpcFVWLE4mJnRoaXNbZ10mJnRoaXNbaHRdKCl9W2h0XSgpe2lmKHRoaXMuY2xpcFBhdGgpe3RoaXNbcV18fCh0aGlzW3FdPW8uZGVmYXVsdC5jcmVhdGVDYW52YXMoMSwxKSk7Y29uc3RbW04sJF0sW1MsVF1dPXRoaXMuYm91bmRpbmdCb3g7UyYmVCYmKHRoaXNbcV0ud2lkdGg9Uy1OLHRoaXNbcV0uaGVpZ2h0PVQtJCk7Y29uc3Qgdz10aGlzW3FdLmdldENvbnRleHQoIjJkIiksVT1uZXcgUGF0aDJEKHRoaXMuY2xpcFBhdGgpO3cuY2xlYXJSZWN0KDAsMCx0aGlzW3FdLndpZHRoLHRoaXNbcV0uaGVpZ2h0KSx3LnNhdmUoKSx3LnRyYW5zbGF0ZSgtTiwtJCksdy5maWxsU3R5bGU9IndoaXRlIix3LmZpbGwoVSksdy5yZXN0b3JlKCksdGhpc1tnXS5jbGlwUGF0aD10aGlzW3FdO2NvbnN0IEg9dXQodGhpcy5ib3VuZGluZ0JveCx0aGlzW2ddLnBvc2l0aW9uMCk7dGhpc1tnXS5hdHRyaWJ1dGVzLmFfY2xpcFVWPUh9fWdldFBvaW50QXRMZW5ndGgoTil7cmV0dXJuIE9iamVjdChkLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbYl0sTil9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gT2JqZWN0KGQuZ2V0VG90YWxMZW5ndGgpKHRoaXNbYl0pfWdldCBibGVuZCgpe3JldHVybiB0aGlzW0JdPT1udWxsPyJhdXRvIjp0aGlzW0JdfXNldCBibGVuZChOKXt0aGlzW0JdPU4sdGhpc1tnXSYmKHRoaXNbZ10uZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCl9Z2V0IGJvdW5kaW5nQm94KCl7aWYodGhpc1tnXSYmdGhpc1tnXS5ib3VuZGluZ0JveClyZXR1cm4gdGhpc1tnXS5ib3VuZGluZ0JveDtjb25zdCBOPXRoaXMubWVzaERhdGE7aWYoTil7Y29uc3QgJD1OLnBvc2l0aW9uMDtpZigkLmxlbmd0aClOLmJvdW5kaW5nQm94PWkoKSgkKTtlbHNlIHJldHVybltbMCwwXSxbMCwwXV07cmV0dXJuIE4uYm91bmRpbmdCb3h9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBOPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIE4/Wy41KihOWzBdWzBdK05bMV1bMF0pLC41KihOWzBdWzFdK05bMV1bMV0pXTpbMCwwXX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLnJ1bGU6Im5vbnplcm8ifWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tFXT90aGlzW0VdLmxpbmVXaWR0aDowfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5saW5lQ2FwOiIifWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ubGluZUpvaW46IiJ9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tFXT90aGlzW0VdLm1pdGVyTGltaXQ6MH1nZXQgc3Ryb2tlU3R5bGUoKXtyZXR1cm4gdGhpc1tMXSYmdGhpc1tMXVszXSE9PTA/T2JqZWN0KHMuZGVmYXVsdCkodGhpc1tMXSk6IiJ9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5saW5lRGFzaDpudWxsfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW0VdP3RoaXNbRV0ubGluZURhc2hPZmZzZXQ6MH1nZXQgZmlsbFN0eWxlKCl7cmV0dXJuIHRoaXNbTV0mJnRoaXNbTV1bM10hPT0wP09iamVjdChzLmRlZmF1bHQpKHRoaXNbTV0pOiIifWdldCBncmFkaWVudCgpe3JldHVybiB0aGlzW0ZdfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbUl0udV90ZXhTYW1wbGVyP3tpbWFnZTp0aGlzW1JdLnVfdGV4U2FtcGxlci5faW1nLG9wdGlvbnM6dGhpc1tDXX06bnVsbH1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tCXT09PSEwfHx0aGlzW0JdPT09ITE/dGhpc1tCXTp0aGlzW1hdPDF8fHRoaXNbTF0hPW51bGwmJnRoaXNbTF1bM108MXx8dGhpc1tNXSE9bnVsbCYmdGhpc1tNXVszXTwxfHx0aGlzW1JdLnVfY29sb3JNYXRyaXghPW51bGwmJnRoaXNbUl0udV9jb2xvck1hdHJpeFsxOF08MXx8dGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yIT1udWxsfHx0aGlzLmJlZm9yZVJlbmRlcnx8dGhpcy5hZnRlclJlbmRlcn1nZXQgZmlsdGVyQ2FudmFzKCl7cmV0dXJuL2JsdXJ8ZHJvcC1zaGFkb3d8dXJsLy50ZXN0KHRoaXMuZmlsdGVyKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbR10uam9pbigiICIpfWdldCB0cmFuc2Zvcm1NYXRyaXgoKXtyZXR1cm4gdGhpc1tJXX1nZXQgaW52ZXJ0TWF0cml4KCl7aWYoIXRoaXNbRF0pe2NvbnN0IE49ci5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXNbSV0pO3RoaXNbRF09Tn1yZXR1cm4gdGhpc1tEXX1nZXQgdHJhbnNmb3JtU2NhbGUoKXtjb25zdCBOPXRoaXNbSV07cmV0dXJuIE1hdGgubWF4KE1hdGguaHlwb3QoTlswXSxOWzFdKSxNYXRoLmh5cG90KE5bMl0sTlszXSkpfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW1JdfWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbbnRdfVtfXShOKXtjb25zdCAkPXRoaXNbdHRdLFM9dGhpc1tnXS5wb3NpdGlvbjAsVD1PYmplY3QuZW50cmllcyhOLl9hdHRyaWJ1dGUpO2ZvcihsZXQgdz0wO3c8VC5sZW5ndGg7dysrKXtjb25zdFtVLEhdPVRbd107aWYoVSE9PSJhX2NvbG9yIiYmVSE9PSJhX3NvdXJjZVJlY3QiJiZIIT09Imlnbm9yZWQiKXtjb25zdCBZPSRbVV07aWYoVT09PSJ1diImJiFZKXtjb25zdCBrPXRoaXNbZ10uYm91bmRpbmdCb3h8fGkoKShTKTt0aGlzW2ddLmF0dHJpYnV0ZXNbVV09dXQoayxTKX1lbHNle3RoaXNbZ10uYXR0cmlidXRlc1tVXT1bXTtmb3IobGV0IGs9MDtrPFMubGVuZ3RoO2srKyl7Y29uc3QgcnQ9U1trXTt0aGlzW2ddLmF0dHJpYnV0ZXNbVV0ucHVzaChZP1kocnQsdyxTKTpBcnJheShILnNpemUpLmZpbGwoMCkpfX19fX1nZXQgbWVzaERhdGEoKXtpZih0aGlzLl91cGRhdGVNYXRyaXgmJnRoaXMudHJhbnNmb3JtU2NhbGUvdGhpcy5jb250b3Vycy5zY2FsZT4xLjUmJnRoaXMuYWNjdXJhdGUodGhpcy50cmFuc2Zvcm1TY2FsZSksIXRoaXNbZ10peyF0aGlzW0FdJiYhdGhpc1tFXSYmdGhpcy5zZXRGaWxsKCk7Y29uc3QgTj10aGlzW2JdLCQ9e307aWYoTiYmTi5sZW5ndGgpe2lmKHRoaXNbQV0pdHJ5e2NvbnN0IHc9eSgpKE4sdGhpc1tBXSk7dy5wb3NpdGlvbnM9dy5wb3NpdGlvbnMubWFwKFU9PihVLnB1c2godGhpc1tYXSksVSkpLHcuYXR0cmlidXRlcz17YV9jb2xvcjpBcnJheS5mcm9tKHtsZW5ndGg6dy5wb3NpdGlvbnMubGVuZ3RofSkubWFwKCgpPT50aGlzW01dLm1hcChVPT5NYXRoLnJvdW5kKDI1NSpVKSkpfSwkLmZpbGw9d31jYXRjaHt9aWYodGhpc1tFXSl7Y29uc3Qgdz10aGlzW0VdLmxpbmVEYXNoO2xldCBVPU47aWYodyl7Y29uc3QgWT10aGlzW0VdLmxpbmVEYXNoT2Zmc2V0O1U9T2JqZWN0KGQuZ2V0RGFzaENvbnRvdXJzKShOLHcsWSl9Y29uc3QgSD1VLm1hcCgoWSxrKT0+e2NvbnN0IHJ0PVkubGVuZ3RoPjEmJnIudmVjMi5lcXVhbHMoWVswXSxZW1kubGVuZ3RoLTFdKSxpdD10aGlzW0VdLmJ1aWxkKFkscnQpO3JldHVybiB5KCkoW2l0XSl9KTtILmZvckVhY2goWT0+e1kucG9zaXRpb25zPVkucG9zaXRpb25zLm1hcChrPT4oay5wdXNoKC10aGlzW1hdKSxrKSksWS5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpZLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbTF0ubWFwKGs9Pk1hdGgucm91bmQoMjU1KmspKSl9fSksJC5zdHJva2U9T2JqZWN0KGwuZGVmYXVsdCkoSCl9fWNvbnN0IFM9T2JqZWN0KGwuZGVmYXVsdCkoWyQuZmlsbCwkLnN0cm9rZV0pO1MuZmlsbFBvaW50Q291bnQ9JC5maWxsPyQuZmlsbC5wb3NpdGlvbnMubGVuZ3RoOjAsUy5lbmFibGVCbGVuZD10aGlzLmVuYWJsZUJsZW5kLFMucG9zaXRpb24wPVMucG9zaXRpb25zLm1hcCgoW3csVSxIXSk9Plt3LFUsSF0pLFMudW5pZm9ybXM9dGhpc1tSXSx0aGlzW2ddPVMsdGhpc1tSXS51X3RleFNhbXBsZXImJnRoaXNbel0oUyx0aGlzW0NdKTtjb25zdCBUPXRoaXNbSV07T2JqZWN0KHYuaXNVbml0VHJhbnNmb3JtKShUKXx8KHRoaXNbS10oUyxUKSx0aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3ImJnRoaXNbUV0oKSksdGhpcy5jbGlwUGF0aCYmdGhpc1todF0oKSx0aGlzW1pdJiZ0aGlzW19dKHRoaXNbWl0pfXJldHVybiB0aGlzLl91cGRhdGVNYXRyaXgmJih0aGlzW2ddLm1hdHJpeD10aGlzW0ldLHRoaXNbS10odGhpc1tnXSx0aGlzW0ldKSx0aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3ImJnRoaXNbUV0oKSksdGhpc1tnXX1bS10oTiwkKXtjb25zdHtwb3NpdGlvbnM6Uyxwb3NpdGlvbjA6VH09Tjtmb3IobGV0IHc9MDt3PFMubGVuZ3RoO3crKyl7Y29uc3RbVSxIXT1UW3ddLFk9U1t3XTtZWzBdPVUqJFswXStIKiRbMl0rJFs0XSxZWzFdPVUqJFsxXStIKiRbM10rJFs1XX10aGlzLl91cGRhdGVNYXRyaXg9ITF9W1FdKCl7Y29uc3QgTj10aGlzW0ldLCQ9Wy4uLnRoaXMuX3JhZGlhbEdyYWRpZW50VmVjdG9yXTtpZigkKXtjb25zdFtTLFQsLHcsVV09JDskWzBdPVMqTlswXStUKk5bMl0rTls0XSwkWzFdPVMqTlsxXStUKk5bM10rTls1XSwkWzNdPXcqTlswXStVKk5bMl0rTls0XSwkWzRdPXcqTlsxXStVKk5bM10rTls1XSx0aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3I9JH19W3pdKE4sJCl7ZnVuY3Rpb24gUyhrLHJ0KXtyZXR1cm4gaz09bnVsbCYmcnQ9PW51bGw/ITA6az09bnVsbHx8cnQ9PW51bGw/ITE6a1swXT09PXJ0WzBdJiZrWzFdPT09cnRbMV0mJmtbMl09PT1ydFsyXSYma1szXT09PXJ0WzNdfWNvbnN0IFQ9dGhpc1tSXS51X3RleFNhbXBsZXI7aWYoIVQpcmV0dXJuO2NvbnN0e3dpZHRoOncsaGVpZ2h0OlV9PVQuX2ltZyxIPSQuc3JjUmVjdDtsZXQgWT0kLnJlY3R8fFswLDBdO2lmKCQucm90YXRlZCYmKFk9Wy1ZWzFdLFlbMF0sWVszXSxZWzJdXSksWVsyXT09bnVsbCYmKFlbMl09SD9IWzJdOncpLFlbM109PW51bGwmJihZWzNdPUg/SFszXTpVKSwkLmhpZGRlbilOLnRleHR1cmVDb29yZD1OLnBvc2l0aW9ucy5tYXAoKCk9PlstMSwtMSwtMV0pO2Vsc2UgaWYoIU4udGV4dHVyZUNvb3JkfHwhUyh0aGlzW0NdLnJlY3QsJC5yZWN0KXx8dGhpc1tDXS5oaWRkZW4hPT0kLmhpZGRlbnx8dGhpc1tDXS5yb3RhdGVkIT09JC5yb3RhdGVkKXtsZXQgaz1udWxsOyQucm90YXRlZCYmKGs9ci5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCksLjUqTWF0aC5QSSksaz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksayxbMCwtWVsyXV0pKSxOLnRleHR1cmVDb29yZD1OLnBvc2l0aW9uMC5tYXAoKFtydCxpdCxsdF0pPT57aWYoMS9sdD4wKXtpZigkLnJvdGF0ZWQpe2NvbnN0IG90PXJ0KmtbMF0raXQqa1syXStrWzRdLHN0PXJ0KmtbMV0raXQqa1szXStrWzVdO1tydCxpdF09W290LHN0XX1jb25zdCBmdD1qKFtydCxpdF0sW1lbMF0vWVsyXSxZWzFdL1lbM10sWVsyXSxZWzNdXSwkKTtyZXR1cm4gJC5yZXBlYXQmJihmdFsyXT0xKSxmdH1yZXR1cm5bLTEsLTEsLTFdfSl9aWYoSCl7Y29uc3Qgaz1bSFswXS93LEhbMV0vVSxIWzJdL3csSFszXS9VXTtOLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0PU4ucG9zaXRpb25zLm1hcCgoKT0+Wy4uLmtdKX1lbHNlIE4uYXR0cmlidXRlcy5hX3NvdXJjZVJlY3Q9Ti5wb3NpdGlvbnMubWFwKCgpPT5bMCwwLDAsMF0pfWFjY3VyYXRlKE4pe2lmKCF0aGlzLmNvbnRvdXJzKXJldHVybjtpZih0aGlzLmNvbnRvdXJzLnBhdGgpe2NvbnN0IFM9dGhpcy5jb250b3Vycy5zaW1wbGlmeSxUPVcodGhpcy5jb250b3Vycy5wYXRoLDIqTixTKTt0aGlzW2ddPW51bGwsdGhpc1tiXT1UfX1jYW5JZ25vcmUoKXtjb25zdCBOPXRoaXNbRV09PW51bGx8fHRoaXNbRV0ubGluZVdpZHRoPT09MHx8dGhpc1tMXVszXT09PTAsJD10aGlzW0FdPT1udWxsfHx0aGlzW01dWzNdPT09MCxTPXRoaXNbUl0udV9yYWRpYWxHcmFkaWVudFZlY3Rvcj09bnVsbCxUPXRoaXNbUl0udV90ZXhTYW1wbGVyPT1udWxsO3JldHVybiB0aGlzW1hdPT09MHx8dGhpc1taXT09bnVsbCYmTiYmJCYmUyYmVCYmIXRoaXMuYmVmb3JlUmVuZGVyJiYhdGhpcy5hZnRlclJlbmRlcn1zZXRTdHJva2Uoe3RoaWNrbmVzczpOPTEsY2FwOiQ9ImJ1dHQiLGpvaW46Uz0ibWl0ZXIiLG1pdGVyTGltaXQ6VD0xMCxjb2xvcjp3PVswLDAsMCwwXSxsaW5lRGFzaDpVPW51bGwsbGluZURhc2hPZmZzZXQ6SD0wLHJvdW5kU2VnbWVudHM6WT0yMH09e30pe3JldHVybiB0aGlzW2ddPW51bGwsdGhpc1tFXT1uZXcgYS5kZWZhdWx0KHtsaW5lV2lkdGg6TixsaW5lQ2FwOiQsbGluZUpvaW46UyxtaXRlckxpbWl0OlQscm91bmRTZWdtZW50czpZfSksdHlwZW9mIHc9PSJzdHJpbmciJiYodz1PYmplY3QobS5kZWZhdWx0KSh3KSksdGhpc1tMXT13LHRoaXNbRV0ubGluZURhc2g9VSx0aGlzW0VdLmxpbmVEYXNoT2Zmc2V0PUgsdGhpc31zZXRGaWxsKHtydWxlOk49dGhpcy5maWxsUnVsZSxjb2xvcjokPVswLDAsMCwwXX09e30pe3JldHVybiB0aGlzW2ddPW51bGwsdGhpc1tBXT17cnVsZTpOfSx0eXBlb2YgJD09InN0cmluZyImJigkPU9iamVjdChtLmRlZmF1bHQpKCQpKSx0aGlzW01dPSQsdGhpc31zZXRUZXh0dXJlKE4sJD17fSl7aWYoTiYmTi5pbWFnZSl7Y29uc3R7aW1hZ2U6UyxyZWN0OlR9PU47aWYoTj1TLCQucmVjdClmb3IobGV0IHc9MDt3PCQucmVjdC5sZW5ndGg7dysrKVRbd109JC5yZWN0W3ddOyQucmVjdD1UfXJldHVybiB0aGlzW0FdfHx0aGlzLnNldEZpbGwoKSx0aGlzLnNldFVuaWZvcm1zKHt1X3RleFNhbXBsZXI6Tn0pLHRoaXNbZ10mJnRoaXNbel0odGhpc1tnXSwkKSx0aGlzW0NdPSQsdGhpc31zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6JCx0eXBlOlM9ImZpbGwifT17fSl7aWYoTi5sZW5ndGghPT0zKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZWFyR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOiQsdHlwZTpTfSl9c2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczokLHR5cGU6Uz0iZmlsbCJ9PXt9KXtpZihOLmxlbmd0aCE9PTQpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6JCx0eXBlOlN9KX1zZXRSYWRpYWxHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOiQsdHlwZTpTPSJmaWxsIn09e30pe2lmKE4ubGVuZ3RoIT09Nil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHJhZGlhbEdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczokLHR5cGU6U30pfXNldEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6JCx0eXBlOlM9ImZpbGwifT17fSl7JD0kLm1hcCgoe29mZnNldDpVLGNvbG9yOkh9KT0+KHR5cGVvZiBIPT0ic3RyaW5nIiYmKEg9T2JqZWN0KG0uZGVmYXVsdCkoSCkpLHtvZmZzZXQ6VSxjb2xvcjpIfSkpLHRoaXNbRl09dGhpc1tGXXx8e30sdGhpc1tGXVtTXT17dmVjdG9yOk4sY29sb3JzOiR9LCQuc29ydCgoVSxIKT0+VS5vZmZzZXQtSC5vZmZzZXQpO2NvbnN0IFQ9W107JC5mb3JFYWNoKCh7b2Zmc2V0OlUsY29sb3I6SH0pPT57VC5wdXNoKFUsLi4uSCl9KTtsZXQgdztpZihOLmxlbmd0aD09PTQ/dz1bTlswXSxOWzFdLDAsTlsyXSxOWzNdLDBdOnc9Wy4uLk5dLFQubGVuZ3RoPDQwJiZULnB1c2goLTEpLFQubGVuZ3RoPjQwKXRocm93IG5ldyBFcnJvcigiVG9vIG1hbnkgY29sb3JzLCBzaG91bGQgYmUgbGVzcyB0aGFuIDggY29sb3JzIik7cmV0dXJuIHRoaXMuX3JhZGlhbEdyYWRpZW50VmVjdG9yPXcsdGhpc1tSXS51X2NvbG9yU3RlcHM9VCxTPT09ImZpbGwiP3RoaXNbUl0udV9ncmFkaWVudFR5cGU9MTp0aGlzW1JdLnVfZ3JhZGllbnRUeXBlPTAsdGhpc1tRXSgpLHRoaXN9c2V0VW5pZm9ybXMoTj17fSl7cmV0dXJuIE9iamVjdC5hc3NpZ24odGhpc1tSXSxOKSx0aGlzfXNldFRyYW5zZm9ybSguLi5OKXtjb25zdCAkPXRoaXNbSV07cmV0dXJuIHIubWF0MmQuZXF1YWxzKE4sJCl8fCh0aGlzW0ldPU4sZGVsZXRlIHRoaXNbRF0sdGhpcy5fdXBkYXRlTWF0cml4PSEwKSx0aGlzfXRyYW5zZm9ybSguLi5OKXtjb25zdCAkPXRoaXNbSV07cmV0dXJuIHRoaXNbSV09ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksJCxOKSxkZWxldGUgdGhpc1tEXSx0aGlzLl91cGRhdGVNYXRyaXg9ITAsdGhpc310cmFuc2xhdGUoTiwkKXtsZXQgUz1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBTPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxTLFtOLCRdKSx0aGlzLnRyYW5zZm9ybSguLi5TKX1yb3RhdGUoTixbJCxTXT1bMCwwXSl7bGV0IFQ9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gVD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksVCxbJCxTXSksVD1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksVCxOKSxUPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxULFstJCwtU10pLHRoaXMudHJhbnNmb3JtKC4uLlQpfXNjYWxlKE4sJD1OLFtTLFRdPVswLDBdKXtsZXQgdz1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiB3PXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx3LFtTLFRdKSx3PXIubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsW04sJF0pLHc9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsWy1TLC1UXSksdGhpcy50cmFuc2Zvcm0oLi4udyl9c2tldyhOLCQ9TixbUyxUXT1bMCwwXSl7bGV0IHc9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gdz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksdyxbUyxUXSksdz1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx3LHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKCQpLE1hdGgudGFuKE4pLDEsMCwwKSksdz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksdyxbLVMsLVRdKSx0aGlzLnRyYW5zZm9ybSguLi53KX1jbGVhckZpbHRlcigpe3JldHVybiB0aGlzLnNldENvbG9yVHJhbnNmb3JtKG51bGwpLHRoaXNbR10ubGVuZ3RoPTAsdGhpc31zZXRDb2xvclRyYW5zZm9ybSguLi5OKXtyZXR1cm4gTlswXT09PW51bGw/dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjAsdV9jb2xvck1hdHJpeDowfSk6dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjEsdV9jb2xvck1hdHJpeDpOfSksdGhpc310cmFuc2Zvcm1Db2xvciguLi5OKXtsZXQgJD10aGlzLnVuaWZvcm1zLnVfY29sb3JNYXRyaXg7cmV0dXJuICQ/JD1PYmplY3QoZi5tdWx0aXBseSkoJCxOKTokPU4sdGhpcy5zZXRDb2xvclRyYW5zZm9ybSguLi4kKSx0aGlzfWJsdXIoTil7cmV0dXJuIHRoaXNbR10ucHVzaChgYmx1cigke059cHgpYCksdGhpc31icmlnaHRuZXNzKE49MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgYnJpZ2h0bmVzcygkezEwMCpOfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5icmlnaHRuZXNzKShOKSl9Y29udHJhc3QoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBjb250cmFzdCgkezEwMCpOfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5jb250cmFzdCkoTikpfWRyb3BTaGFkb3coTiwkLFM9MCxUPVswLDAsMCwxXSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoVCkmJihUPU9iamVjdChzLmRlZmF1bHQpKFQpKSx0aGlzW0ddLnB1c2goYGRyb3Atc2hhZG93KCR7Tn1weCAkeyR9cHggJHtTfXB4ICR7VH0pYCksdGhpc31ncmF5c2NhbGUoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBncmF5c2NhbGUoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuZ3JheXNjYWxlKShOKSl9aHVlUm90YXRlKE49MCl7cmV0dXJuIHRoaXNbR10ucHVzaChgaHVlLXJvdGF0ZSgke059ZGVnKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGYuaHVlUm90YXRlKShOKSl9aW52ZXJ0KE49MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgaW52ZXJ0KCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLmludmVydCkoTikpfW9wYWNpdHkoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBvcGFjaXR5KCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLm9wYWNpdHkpKE4pKX1zYXR1cmF0ZShOPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYHNhdHVyYXRlKCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChmLnNhdHVyYXRlKShOKSl9c2VwaWEoTj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBzZXBpYSgkezEwMCpOfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoZi5zZXBpYSkoTikpfXVybChOKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGB1cmwoJHtOfSlgKSx0aGlzfWlzUG9pbnRDb2xsaXNpb24oTiwkLFM9ImJvdGgiKXtjb25zdCBUPXRoaXMubWVzaERhdGEse3Bvc2l0aW9uczp3LGNlbGxzOlV9PVQsSD10aGlzLmludmVydE1hdHJpeCxZPUhbMF0qTitIWzJdKiQrSFs0XSxrPUhbMV0qTitIWzNdKiQrSFs1XSxydD10aGlzLmJvdW5kaW5nQm94O2lmKFk8cnRbMF1bMF18fFk+cnRbMV1bMF18fGs8cnRbMF1bMV18fGs+cnRbMV1bMV0pcmV0dXJuITE7ZnVuY3Rpb24gaXQoW2x0LGZ0XSxbb3Qsc3RdLFtjdCxtdF0pe2NvbnN0IHZ0PWN0LW90LGd0PW10LXN0LFN0PSgobHQtb3QpKnZ0KyhmdC1zdCkqZ3QpLyh2dCoqMitndCoqMik7cmV0dXJuIFN0Pj0wJiZTdDw9MX1mb3IobGV0IGx0PTA7bHQ8VS5sZW5ndGg7bHQrKyl7Y29uc3QgZnQ9VVtsdF07aWYoUz09PSJmaWxsIiYmZnRbMF0+PVQuZmlsbFBvaW50Q291bnQpYnJlYWs7aWYoUz09PSJzdHJva2UiJiZmdFswXTxULmZpbGxQb2ludENvdW50KWNvbnRpbnVlO2NvbnN0W1tvdCxzdF0sW2N0LG10XSxbdnQsZ3RdXT1mdC5tYXAoVHQ9PndbVHRdKSxTdD1NYXRoLnNpZ24oKE4tb3QpKihtdC1zdCktKGN0LW90KSooJC1zdCkpO2lmKFN0PT09MCYmaXQoW04sJF0sW290LHN0XSxbY3QsbXRdKSlyZXR1cm4hMDtjb25zdCBBdD1NYXRoLnNpZ24oKE4tY3QpKihndC1tdCktKHZ0LWN0KSooJC1tdCkpO2lmKEF0PT09MCYmaXQoW04sJF0sW2N0LG10XSxbdnQsZ3RdKSlyZXR1cm4hMDtjb25zdCBQdD1NYXRoLnNpZ24oKE4tdnQpKihzdC1ndCktKG90LXZ0KSooJC1ndCkpO2lmKFB0PT09MCYmaXQoW04sJF0sW3Z0LGd0XSxbb3Qsc3RdKXx8U3Q9PT0xJiZBdD09PTEmJlB0PT09MXx8U3Q9PT0tMSYmQXQ9PT0tMSYmUHQ9PT0tMSlyZXR1cm4hMH1yZXR1cm4hMX1pc1BvaW50SW5GaWxsKE4sJCl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihOLCQsImZpbGwiKX1pc1BvaW50SW5TdHJva2UoTiwkKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKE4sJCwic3Ryb2tlIil9YWRkUGFzcyhOLCQ9e30pe2xldHt3aWR0aDpTLGhlaWdodDpUfT0kLHc9aCgkLFsid2lkdGgiLCJoZWlnaHQiXSk7Y29uc3QgVT1uZXcgTy5kZWZhdWx0O1UucmVjdCgwLDAsUyxUKTtjb25zdCBIPW5ldyBWKFUse3dpZHRoOlMsaGVpZ2h0OlR9KTtILnNldFVuaWZvcm1zKHcpLEguc2V0UHJvZ3JhbShOKSx0aGlzW250XS5wdXNoKEgpfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSk7dmFyIHI9dCg1OCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1yLlN0cm9rZX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiU3Ryb2tlIixmdW5jdGlvbigpe3JldHVybiB2fSk7dmFyIHI9dCg0OSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49T2JqZWN0KHIuY3JlYXRlKSgpLGk9T2JqZWN0KHIuY3JlYXRlKSgpLGE9T2JqZWN0KHIuY3JlYXRlKSgpLGw9T2JqZWN0KHIuY3JlYXRlKSgpLHM9T2JqZWN0KHIuY3JlYXRlKSgpLGY9MWUyMDtjbGFzcyB2e2NvbnN0cnVjdG9yKHtsaW5lV2lkdGg6eD0xLGxpbmVKb2luOm09Im1pdGVyIixtaXRlckxpbWl0Ok89MTAsbGluZUNhcDpvPSJidXR0Iixyb3VuZFNlZ21lbnRzOmg9MjB9PXt9KXt0aGlzLmxpbmVXaWR0aD14LHRoaXMubGluZUpvaW49bSx0aGlzLm1pdGVyTGltaXQ9Tyx0aGlzLmxpbmVDYXA9byx0aGlzLnJvdW5kU2VnbWVudHM9aCx0aGlzLl9ub3JtYWw9bnVsbH1idWlsZCh4LG09ITEpe2xldCBPPXgubGVuZ3RoO2lmKHg9Wy4uLnhdLE88MilyZXR1cm4geDttJiYoKHhbMF1bMF0hPT14W08tMV1bMF18fHhbMF1bMV0hPT14W08tMV1bMV0pJiZ4LnB1c2goWy4uLnhbMF1dKSx4LnB1c2goWy4uLnhbMV1dKSksTz14Lmxlbmd0aCx0aGlzLl9ub3JtYWw9bnVsbDtjb25zdCBvPXtsZWZ0OltdLHJpZ2h0OltdfSxoPXRoaXMubGluZVdpZHRoLzIsYz10aGlzLmxpbmVDYXA7aWYoIW0mJmM9PT0ic3F1YXJlIil7T2JqZWN0KHIuZGlyZWN0aW9uKShpLHhbMF0seFsxXSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKHhbMF0seFswXSxpLGgpO2NvbnN0IGI9eC5sZW5ndGgtMTtPYmplY3Qoci5kaXJlY3Rpb24pKGkseFtiXSx4W2ItMV0pLE9iamVjdChyLnNjYWxlQW5kQWRkKSh4W2JdLHhbYl0saSxoKX1mb3IobGV0IGI9MTtiPE87YisrKXtjb25zdCBFPXhbYi0xXSxBPXhbYl0sTD14W2IrMV07dGhpcy5fc2VnKG8sRSxBLEwsaCxtKX1yZXR1cm4hbSYmYz09PSJyb3VuZCImJnkobyx0aGlzLnJvdW5kU2VnbWVudHMpLFsuLi5vLmxlZnQsLi4uby5yaWdodC5yZXZlcnNlKCldfV9zZWcoeCxtLE8sbyxoLGMpe2NvbnN0IGc9dGhpcy5saW5lSm9pbj09PSJiZXZlbCIsYj10aGlzLmxpbmVKb2luPT09InJvdW5kIjtpZihPYmplY3Qoci5kaXJlY3Rpb24pKGksTyxtKSx0aGlzLl9ub3JtYWx8fCh0aGlzLl9ub3JtYWw9T2JqZWN0KHIuY3JlYXRlKSgpLE9iamVjdChyLm5vcm1hbCkodGhpcy5fbm9ybWFsLGkpKSx4LmxlZnQubGVuZ3RofHxwKHgsbSx0aGlzLl9ub3JtYWwsaCksIW8pT2JqZWN0KHIubm9ybWFsKSh0aGlzLl9ub3JtYWwsaSksYz9wKHgsbSx0aGlzLl9ub3JtYWwsaCk6cCh4LE8sdGhpcy5fbm9ybWFsLGgpO2Vsc2V7T2JqZWN0KHIuZGlyZWN0aW9uKShhLG8sTyk7bGV0IEU9T2JqZWN0KHIuY29tcHV0ZU1pdGVyKShsLHMsaSxhLGgpO0U9TWF0aC5taW4oRSxmKTtjb25zdCBBPU9iamVjdChyLmRvdCkobCx0aGlzLl9ub3JtYWwpPDA/LTE6MTtsZXQgTD1nfHxiO2lmKCFMJiZ0aGlzLmxpbmVKb2luPT09Im1pdGVyIiYmRS9oPnRoaXMubWl0ZXJMaW1pdCYmKEw9ITApLEwpe09iamVjdChyLnNjYWxlQW5kQWRkKShuLE8sdGhpcy5fbm9ybWFsLC1oKkEpLGQoeCxuLEEpO2xldCBNPTEvMDttJiYoTT1NYXRoLm1pbihNLE1hdGguaHlwb3QoT1swXS1tWzBdLE9bMV0tbVsxXSkpKSxvJiYoTT1NYXRoLm1pbihNLE1hdGguaHlwb3Qob1swXS1PWzBdLG9bMV0tT1sxXSkpKTtjb25zdCBJPU1hdGgubWF4KGgsTWF0aC5taW4oRSxNKSk7aWYoT2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4sTyxzLEkqQSksZCh4LG4sLUEpLG8paWYoT2JqZWN0KHIubm9ybWFsKShuLGEpLE9iamVjdChyLmNvcHkpKHRoaXMuX25vcm1hbCxuKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkobixPLG4sLWgqQSksYil7Y29uc3QgRD1PYmplY3Qoci5jbG9uZSkobiksUj1BPjA/eC5sZWZ0W3gubGVmdC5sZW5ndGgtMV06eC5yaWdodFt4LnJpZ2h0Lmxlbmd0aC0xXSxDPU9iamVjdChyLmNsb25lKShPKSxCPU9iamVjdChyLnN1YikoT2JqZWN0KHIuY3JlYXRlKSgpLFIsQyksej1PYmplY3Qoci5zdWIpKE9iamVjdChyLmNyZWF0ZSkoKSxELEMpLEs9TWF0aC5QSS90aGlzLnJvdW5kU2VnbWVudHM7Zm9yKGxldCBRPTA7UTx0aGlzLnJvdW5kU2VnbWVudHMmJihPYmplY3Qoci5yb3RhdGUpKEIsQixbMCwwXSxBKkspLE1hdGguc2lnbihPYmplY3Qoci5jcm9zcykobixCLHopWzJdKT09PUEpO1ErKylPYmplY3Qoci5hZGQpKG4sQixDKSxkKHgsbixBKTtkKHgsRCxBKX1lbHNlIGQoeCxuLEEpfWVsc2UgcCh4LE8scyxFKSxPYmplY3Qoci5jb3B5KSh0aGlzLl9ub3JtYWwscyl9fX1mdW5jdGlvbiBkKFAseCxtKXttPjA/UC5sZWZ0LnB1c2goT2JqZWN0KHIuY2xvbmUpKHgpKTpQLnJpZ2h0LnB1c2goT2JqZWN0KHIuY2xvbmUpKHgpKX1mdW5jdGlvbiBwKFAseCxtLE8sbz0tMSl7T2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4seCxtLC1PKSxkKFAsbiwtbyksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4seCxtLE8pLGQoUCxuLG8pfWZ1bmN0aW9uIHkoe2xlZnQ6UCxyaWdodDp4fSxtKXtjb25zdCBPPU9iamVjdChyLmNyZWF0ZSkoKSxvPU9iamVjdChyLmNyZWF0ZSkoKTtsZXQgaD1QWzBdLGM9eFswXSxnPVsuNSooaFswXStjWzBdKSwuNSooaFsxXStjWzFdKV07T2JqZWN0KHIuc3ViKShvLGgsZyk7Zm9yKGxldCBiPTE7Yjw9bTtiKyspe2NvbnN0IEU9LTEqTWF0aC5QSSpiL207T2JqZWN0KHIucm90YXRlKShPLG8sWzAsMF0sRSksT2JqZWN0KHIuYWRkKShuLGcsTyksUC51bnNoaWZ0KE9iamVjdChyLmNsb25lKShuKSl9aD14W3gubGVuZ3RoLTFdLGM9UFtQLmxlbmd0aC0xXSxnPVsuNSooaFswXStjWzBdKSwuNSooaFsxXStjWzFdKV0sT2JqZWN0KHIuc3ViKShvLGgsZyk7Zm9yKGxldCBiPTE7Yjw9bTtiKyspe2NvbnN0IEU9LTEqTWF0aC5QSSpiL207T2JqZWN0KHIucm90YXRlKShPLG8sWzAsMF0sRSksT2JqZWN0KHIuYWRkKShuLGcsTykseC5wdXNoKE9iamVjdChyLmNsb25lKShuKSl9fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiaXNVbml0VHJhbnNmb3JtIixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIobil7cmV0dXJuIG5bMF09PT0xJiZuWzFdPT09MCYmblsyXT09PTAmJm5bM109PT0xJiZuWzRdPT09MCYmbls1XT09PTB9fSxmdW5jdGlvbih1LGUsdCl7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO3ZhciByPXQoNjEpLG49dCg2Mik7dS5leHBvcnRzPWZ1bmN0aW9uKGksYSl7aWYoYT1hfHx7fSxpPWkuZmlsdGVyKGZ1bmN0aW9uKG0pe3JldHVybiBtLmxlbmd0aD4yfSksaS5sZW5ndGg9PT0wKXJldHVybntwb3NpdGlvbnM6W10sY2VsbHM6W119O3R5cGVvZiBhLnZlcnRleFNpemUhPSJudW1iZXIiJiYoYS52ZXJ0ZXhTaXplPWlbMF1bMF0ubGVuZ3RoKSxpPWkubWFwKGZ1bmN0aW9uKG0pe3JldHVybiBtLnJlZHVjZShmdW5jdGlvbihPLG8pe3JldHVybiBPLmNvbmNhdChvKX0pfSk7Y29uc3QgbD1hLnJ1bGU9PT0iZXZlbm9kZCI/ci5XSU5ESU5HX09ERDpyLldJTkRJTkdfTk9OWkVSTztmb3IodmFyIHM9ci50ZXNzZWxhdGUobih7Y29udG91cnM6aSx3aW5kaW5nUnVsZTpsLGVsZW1lbnRUeXBlOnIuUE9MWUdPTlMscG9seVNpemU6Myx2ZXJ0ZXhTaXplOjJ9LGEpKSxmPVtdLHY9MDt2PHMudmVydGljZXMubGVuZ3RoO3YrPWEudmVydGV4U2l6ZSl7dmFyIGQ9cy52ZXJ0aWNlcy5zbGljZSh2LHYrYS52ZXJ0ZXhTaXplKTtmLnB1c2goZCl9dmFyIHA9W107Zm9yKHY9MDt2PHMuZWxlbWVudHMubGVuZ3RoO3YrPTMpe3ZhciB5PXMuZWxlbWVudHNbdl0sUD1zLmVsZW1lbnRzW3YrMV0seD1zLmVsZW1lbnRzW3YrMl07cC5wdXNoKFt5LFAseF0pfXJldHVybntwb3NpdGlvbnM6ZixjZWxsczpwfX19LGZ1bmN0aW9uKHUsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9e30sbj17fTt1LmV4cG9ydHM9cixyLldJTkRJTkdfT0REPTAsci5XSU5ESU5HX05PTlpFUk89MSxyLldJTkRJTkdfUE9TSVRJVkU9MixyLldJTkRJTkdfTkVHQVRJVkU9MyxyLldJTkRJTkdfQUJTX0dFUV9UV089NCxyLlBPTFlHT05TPTAsci5DT05ORUNURURfUE9MWUdPTlM9MSxyLkJPVU5EQVJZX0NPTlRPVVJTPTIsci50ZXNzZWxhdGU9ZnVuY3Rpb24obyl7Zm9yKHZhciBoPW8uZGVidWd8fCExLGM9bmV3IE8sZz0wO2c8by5jb250b3Vycy5sZW5ndGg7ZysrKWMuYWRkQ29udG91cihvLnZlcnRleFNpemV8fDIsby5jb250b3Vyc1tnXSk7cmV0dXJuIGMudGVzc2VsYXRlKG8ud2luZGluZ1J1bGV8fHIuV0lORElOR19PREQsby5lbGVtZW50VHlwZXx8ci5QT0xZR09OUyxvLnBvbHlTaXplfHwzLG8udmVydGV4U2l6ZXx8MixvLm5vcm1hbHx8WzAsMCwxXSkse3ZlcnRpY2VzOmMudmVydGljZXMsdmVydGV4SW5kaWNlczpjLnZlcnRleEluZGljZXMsdmVydGV4Q291bnQ6Yy52ZXJ0ZXhDb3VudCxlbGVtZW50czpjLmVsZW1lbnRzLGVsZW1lbnRDb3VudDpjLmVsZW1lbnRDb3VudCxtZXNoOmg/Yy5tZXNoOnZvaWQgMH19O3ZhciBpPWZ1bmN0aW9uKG8pe2lmKCFvKXRocm93IkFzc2VydGlvbiBGYWlsZWQhIn07ZnVuY3Rpb24gYSgpe3RoaXMubmV4dD1udWxsLHRoaXMucHJldj1udWxsLHRoaXMuYW5FZGdlPW51bGwsdGhpcy5jb29yZHM9WzAsMCwwXSx0aGlzLnM9MCx0aGlzLnQ9MCx0aGlzLnBxSGFuZGxlPTAsdGhpcy5uPTAsdGhpcy5pZHg9MH1mdW5jdGlvbiBsKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLnRyYWlsPW51bGwsdGhpcy5uPTAsdGhpcy5tYXJrZWQ9ITEsdGhpcy5pbnNpZGU9ITF9ZnVuY3Rpb24gcyhvKXt0aGlzLm5leHQ9bnVsbCx0aGlzLlN5bT1udWxsLHRoaXMuT25leHQ9bnVsbCx0aGlzLkxuZXh0PW51bGwsdGhpcy5Pcmc9bnVsbCx0aGlzLkxmYWNlPW51bGwsdGhpcy5hY3RpdmVSZWdpb249bnVsbCx0aGlzLndpbmRpbmc9MCx0aGlzLnNpZGU9b31zLnByb3RvdHlwZT17Z2V0IFJmYWNlKCl7cmV0dXJuIHRoaXMuU3ltLkxmYWNlfSxzZXQgUmZhY2Uobyl7dGhpcy5TeW0uTGZhY2U9b30sZ2V0IERzdCgpe3JldHVybiB0aGlzLlN5bS5Pcmd9LHNldCBEc3Qobyl7dGhpcy5TeW0uT3JnPW99LGdldCBPcHJldigpe3JldHVybiB0aGlzLlN5bS5MbmV4dH0sc2V0IE9wcmV2KG8pe3RoaXMuU3ltLkxuZXh0PW99LGdldCBMcHJldigpe3JldHVybiB0aGlzLk9uZXh0LlN5bX0sc2V0IExwcmV2KG8pe3RoaXMuT25leHQuU3ltPW99LGdldCBEcHJldigpe3JldHVybiB0aGlzLkxuZXh0LlN5bX0sc2V0IERwcmV2KG8pe3RoaXMuTG5leHQuU3ltPW99LGdldCBScHJldigpe3JldHVybiB0aGlzLlN5bS5PbmV4dH0sc2V0IFJwcmV2KG8pe3RoaXMuU3ltLk9uZXh0PW99LGdldCBEbmV4dCgpe3JldHVybiB0aGlzLlN5bS5PbmV4dC5TeW19LHNldCBEbmV4dChvKXt0aGlzLlN5bS5PbmV4dC5TeW09b30sZ2V0IFJuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0LlN5bX0sc2V0IFJuZXh0KG8pe3RoaXMuU3ltLkxuZXh0LlN5bT1vfX07ZnVuY3Rpb24gZigpe3ZhciBvPW5ldyBhLGg9bmV3IGwsYz1uZXcgcygwKSxnPW5ldyBzKDEpO28ubmV4dD1vLnByZXY9byxvLmFuRWRnZT1udWxsLGgubmV4dD1oLnByZXY9aCxoLmFuRWRnZT1udWxsLGgudHJhaWw9bnVsbCxoLm1hcmtlZD0hMSxoLmluc2lkZT0hMSxjLm5leHQ9YyxjLlN5bT1nLGMuT25leHQ9bnVsbCxjLkxuZXh0PW51bGwsYy5Pcmc9bnVsbCxjLkxmYWNlPW51bGwsYy53aW5kaW5nPTAsYy5hY3RpdmVSZWdpb249bnVsbCxnLm5leHQ9ZyxnLlN5bT1jLGcuT25leHQ9bnVsbCxnLkxuZXh0PW51bGwsZy5Pcmc9bnVsbCxnLkxmYWNlPW51bGwsZy53aW5kaW5nPTAsZy5hY3RpdmVSZWdpb249bnVsbCx0aGlzLnZIZWFkPW8sdGhpcy5mSGVhZD1oLHRoaXMuZUhlYWQ9Yyx0aGlzLmVIZWFkU3ltPWd9Zi5wcm90b3R5cGU9e21ha2VFZGdlXzpmdW5jdGlvbihvKXt2YXIgaD1uZXcgcygwKSxjPW5ldyBzKDEpO28uU3ltLnNpZGU8by5zaWRlJiYobz1vLlN5bSk7dmFyIGc9by5TeW0ubmV4dDtyZXR1cm4gYy5uZXh0PWcsZy5TeW0ubmV4dD1oLGgubmV4dD1vLG8uU3ltLm5leHQ9YyxoLlN5bT1jLGguT25leHQ9aCxoLkxuZXh0PWMsaC5Pcmc9bnVsbCxoLkxmYWNlPW51bGwsaC53aW5kaW5nPTAsaC5hY3RpdmVSZWdpb249bnVsbCxjLlN5bT1oLGMuT25leHQ9YyxjLkxuZXh0PWgsYy5Pcmc9bnVsbCxjLkxmYWNlPW51bGwsYy53aW5kaW5nPTAsYy5hY3RpdmVSZWdpb249bnVsbCxofSxzcGxpY2VfOmZ1bmN0aW9uKG8saCl7dmFyIGM9by5PbmV4dCxnPWguT25leHQ7Yy5TeW0uTG5leHQ9aCxnLlN5bS5MbmV4dD1vLG8uT25leHQ9ZyxoLk9uZXh0PWN9LG1ha2VWZXJ0ZXhfOmZ1bmN0aW9uKG8saCxjKXt2YXIgZz1vO2koZyE9PW51bGwpO3ZhciBiPWMucHJldjtnLnByZXY9YixiLm5leHQ9ZyxnLm5leHQ9YyxjLnByZXY9ZyxnLmFuRWRnZT1oO3ZhciBFPWg7ZG8gRS5Pcmc9ZyxFPUUuT25leHQ7d2hpbGUoRSE9PWgpfSxtYWtlRmFjZV86ZnVuY3Rpb24obyxoLGMpe3ZhciBnPW87aShnIT09bnVsbCk7dmFyIGI9Yy5wcmV2O2cucHJldj1iLGIubmV4dD1nLGcubmV4dD1jLGMucHJldj1nLGcuYW5FZGdlPWgsZy50cmFpbD1udWxsLGcubWFya2VkPSExLGcuaW5zaWRlPWMuaW5zaWRlO3ZhciBFPWg7ZG8gRS5MZmFjZT1nLEU9RS5MbmV4dDt3aGlsZShFIT09aCl9LGtpbGxFZGdlXzpmdW5jdGlvbihvKXtvLlN5bS5zaWRlPG8uc2lkZSYmKG89by5TeW0pO3ZhciBoPW8ubmV4dCxjPW8uU3ltLm5leHQ7aC5TeW0ubmV4dD1jLGMuU3ltLm5leHQ9aH0sa2lsbFZlcnRleF86ZnVuY3Rpb24obyxoKXt2YXIgYz1vLmFuRWRnZSxnPWM7ZG8gZy5Pcmc9aCxnPWcuT25leHQ7d2hpbGUoZyE9PWMpO3ZhciBiPW8ucHJldixFPW8ubmV4dDtFLnByZXY9YixiLm5leHQ9RX0sa2lsbEZhY2VfOmZ1bmN0aW9uKG8saCl7dmFyIGM9by5hbkVkZ2UsZz1jO2RvIGcuTGZhY2U9aCxnPWcuTG5leHQ7d2hpbGUoZyE9PWMpO3ZhciBiPW8ucHJldixFPW8ubmV4dDtFLnByZXY9YixiLm5leHQ9RX0sbWFrZUVkZ2U6ZnVuY3Rpb24oKXt2YXIgbz1uZXcgYSxoPW5ldyBhLGM9bmV3IGwsZz10aGlzLm1ha2VFZGdlXyh0aGlzLmVIZWFkKTtyZXR1cm4gdGhpcy5tYWtlVmVydGV4XyhvLGcsdGhpcy52SGVhZCksdGhpcy5tYWtlVmVydGV4XyhoLGcuU3ltLHRoaXMudkhlYWQpLHRoaXMubWFrZUZhY2VfKGMsZyx0aGlzLmZIZWFkKSxnfSxzcGxpY2U6ZnVuY3Rpb24obyxoKXt2YXIgYz0hMSxnPSExO2lmKG8hPT1oKXtpZihoLk9yZyE9PW8uT3JnJiYoZz0hMCx0aGlzLmtpbGxWZXJ0ZXhfKGguT3JnLG8uT3JnKSksaC5MZmFjZSE9PW8uTGZhY2UmJihjPSEwLHRoaXMua2lsbEZhY2VfKGguTGZhY2Usby5MZmFjZSkpLHRoaXMuc3BsaWNlXyhoLG8pLCFnKXt2YXIgYj1uZXcgYTt0aGlzLm1ha2VWZXJ0ZXhfKGIsaCxvLk9yZyksby5PcmcuYW5FZGdlPW99aWYoIWMpe3ZhciBFPW5ldyBsO3RoaXMubWFrZUZhY2VfKEUsaCxvLkxmYWNlKSxvLkxmYWNlLmFuRWRnZT1vfX19LGRlbGV0ZTpmdW5jdGlvbihvKXt2YXIgaD1vLlN5bSxjPSExO2lmKG8uTGZhY2UhPT1vLlJmYWNlJiYoYz0hMCx0aGlzLmtpbGxGYWNlXyhvLkxmYWNlLG8uUmZhY2UpKSxvLk9uZXh0PT09byl0aGlzLmtpbGxWZXJ0ZXhfKG8uT3JnLG51bGwpO2Vsc2UgaWYoby5SZmFjZS5hbkVkZ2U9by5PcHJldixvLk9yZy5hbkVkZ2U9by5PbmV4dCx0aGlzLnNwbGljZV8obyxvLk9wcmV2KSwhYyl7dmFyIGc9bmV3IGw7dGhpcy5tYWtlRmFjZV8oZyxvLG8uTGZhY2UpfWguT25leHQ9PT1oPyh0aGlzLmtpbGxWZXJ0ZXhfKGguT3JnLG51bGwpLHRoaXMua2lsbEZhY2VfKGguTGZhY2UsbnVsbCkpOihvLkxmYWNlLmFuRWRnZT1oLk9wcmV2LGguT3JnLmFuRWRnZT1oLk9uZXh0LHRoaXMuc3BsaWNlXyhoLGguT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhvKX0sYWRkRWRnZVZlcnRleDpmdW5jdGlvbihvKXt2YXIgaD10aGlzLm1ha2VFZGdlXyhvKSxjPWguU3ltO3RoaXMuc3BsaWNlXyhoLG8uTG5leHQpLGguT3JnPW8uRHN0O3ZhciBnPW5ldyBhO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKGcsYyxoLk9yZyksaC5MZmFjZT1jLkxmYWNlPW8uTGZhY2UsaH0sc3BsaXRFZGdlOmZ1bmN0aW9uKG8saCl7dmFyIGM9dGhpcy5hZGRFZGdlVmVydGV4KG8pLGc9Yy5TeW07cmV0dXJuIHRoaXMuc3BsaWNlXyhvLlN5bSxvLlN5bS5PcHJldiksdGhpcy5zcGxpY2VfKG8uU3ltLGcpLG8uRHN0PWcuT3JnLGcuRHN0LmFuRWRnZT1nLlN5bSxnLlJmYWNlPW8uUmZhY2UsZy53aW5kaW5nPW8ud2luZGluZyxnLlN5bS53aW5kaW5nPW8uU3ltLndpbmRpbmcsZ30sY29ubmVjdDpmdW5jdGlvbihvLGgpe3ZhciBjPSExLGc9dGhpcy5tYWtlRWRnZV8obyksYj1nLlN5bTtpZihoLkxmYWNlIT09by5MZmFjZSYmKGM9ITAsdGhpcy5raWxsRmFjZV8oaC5MZmFjZSxvLkxmYWNlKSksdGhpcy5zcGxpY2VfKGcsby5MbmV4dCksdGhpcy5zcGxpY2VfKGIsaCksZy5Pcmc9by5Ec3QsYi5Pcmc9aC5PcmcsZy5MZmFjZT1iLkxmYWNlPW8uTGZhY2Usby5MZmFjZS5hbkVkZ2U9YiwhYyl7dmFyIEU9bmV3IGw7dGhpcy5tYWtlRmFjZV8oRSxnLG8uTGZhY2UpfXJldHVybiBnfSx6YXBGYWNlOmZ1bmN0aW9uKG8pe3ZhciBoPW8uYW5FZGdlLGMsZyxiLEUsQTtnPWguTG5leHQ7ZG8gYz1nLGc9Yy5MbmV4dCxjLkxmYWNlPW51bGwsYy5SZmFjZT09PW51bGwmJihjLk9uZXh0PT09Yz90aGlzLmtpbGxWZXJ0ZXhfKGMuT3JnLG51bGwpOihjLk9yZy5hbkVkZ2U9Yy5PbmV4dCx0aGlzLnNwbGljZV8oYyxjLk9wcmV2KSksYj1jLlN5bSxiLk9uZXh0PT09Yj90aGlzLmtpbGxWZXJ0ZXhfKGIuT3JnLG51bGwpOihiLk9yZy5hbkVkZ2U9Yi5PbmV4dCx0aGlzLnNwbGljZV8oYixiLk9wcmV2KSksdGhpcy5raWxsRWRnZV8oYykpO3doaWxlKGMhPWgpO0U9by5wcmV2LEE9by5uZXh0LEEucHJldj1FLEUubmV4dD1BfSxjb3VudEZhY2VWZXJ0c186ZnVuY3Rpb24obyl7dmFyIGg9by5hbkVkZ2UsYz0wO2RvIGMrKyxoPWguTG5leHQ7d2hpbGUoaCE9PW8uYW5FZGdlKTtyZXR1cm4gY30sbWVyZ2VDb252ZXhGYWNlczpmdW5jdGlvbihvKXt2YXIgaCxjLGcsYixFLEEsTDtmb3IoaD10aGlzLmZIZWFkLm5leHQ7aCE9PXRoaXMuZkhlYWQ7aD1oLm5leHQpaWYoaC5pbnNpZGUpZm9yKGM9aC5hbkVkZ2UsRT1jLk9yZztnPWMuTG5leHQsYj1jLlN5bSxiJiZiLkxmYWNlJiZiLkxmYWNlLmluc2lkZSYmKEE9dGhpcy5jb3VudEZhY2VWZXJ0c18oaCksTD10aGlzLmNvdW50RmFjZVZlcnRzXyhiLkxmYWNlKSxBK0wtMjw9byYmbi52ZXJ0Q0NXKGMuTHByZXYuT3JnLGMuT3JnLGIuTG5leHQuTG5leHQuT3JnKSYmbi52ZXJ0Q0NXKGIuTHByZXYuT3JnLGIuT3JnLGMuTG5leHQuTG5leHQuT3JnKSYmKGc9Yi5MbmV4dCx0aGlzLmRlbGV0ZShiKSxjPW51bGwsYj1udWxsKSksIShjJiZjLkxuZXh0Lk9yZz09PUUpOyljPWc7cmV0dXJuITB9LGNoZWNrOmZ1bmN0aW9uKCl7dmFyIG89dGhpcy5mSGVhZCxoPXRoaXMudkhlYWQsYz10aGlzLmVIZWFkLGcsYixFLEEsTCxNO2ZvcihiPW8sYj1vOyhnPWIubmV4dCkhPT1vO2I9Zyl7aShnLnByZXY9PT1iKSxMPWcuYW5FZGdlO2RvIGkoTC5TeW0hPT1MKSxpKEwuU3ltLlN5bT09PUwpLGkoTC5MbmV4dC5PbmV4dC5TeW09PT1MKSxpKEwuT25leHQuU3ltLkxuZXh0PT09TCksaShMLkxmYWNlPT09ZyksTD1MLkxuZXh0O3doaWxlKEwhPT1nLmFuRWRnZSl9Zm9yKGkoZy5wcmV2PT09YiYmZy5hbkVkZ2U9PT1udWxsKSxBPWgsQT1oOyhFPUEubmV4dCkhPT1oO0E9RSl7aShFLnByZXY9PT1BKSxMPUUuYW5FZGdlO2RvIGkoTC5TeW0hPT1MKSxpKEwuU3ltLlN5bT09PUwpLGkoTC5MbmV4dC5PbmV4dC5TeW09PT1MKSxpKEwuT25leHQuU3ltLkxuZXh0PT09TCksaShMLk9yZz09PUUpLEw9TC5PbmV4dDt3aGlsZShMIT09RS5hbkVkZ2UpfWZvcihpKEUucHJldj09PUEmJkUuYW5FZGdlPT09bnVsbCksTT1jLE09YzsoTD1NLm5leHQpIT09YztNPUwpaShMLlN5bS5uZXh0PT09TS5TeW0pLGkoTC5TeW0hPT1MKSxpKEwuU3ltLlN5bT09PUwpLGkoTC5PcmchPT1udWxsKSxpKEwuRHN0IT09bnVsbCksaShMLkxuZXh0Lk9uZXh0LlN5bT09PUwpLGkoTC5PbmV4dC5TeW0uTG5leHQ9PT1MKTtpKEwuU3ltLm5leHQ9PT1NLlN5bSYmTC5TeW09PT10aGlzLmVIZWFkU3ltJiZMLlN5bS5TeW09PT1MJiZMLk9yZz09PW51bGwmJkwuRHN0PT09bnVsbCYmTC5MZmFjZT09PW51bGwmJkwuUmZhY2U9PT1udWxsKX19LG4udmVydEVxPWZ1bmN0aW9uKG8saCl7cmV0dXJuIG8ucz09PWgucyYmby50PT09aC50fSxuLnZlcnRMZXE9ZnVuY3Rpb24obyxoKXtyZXR1cm4gby5zPGguc3x8by5zPT09aC5zJiZvLnQ8PWgudH0sbi50cmFuc0xlcT1mdW5jdGlvbihvLGgpe3JldHVybiBvLnQ8aC50fHxvLnQ9PT1oLnQmJm8uczw9aC5zfSxuLmVkZ2VHb2VzTGVmdD1mdW5jdGlvbihvKXtyZXR1cm4gbi52ZXJ0TGVxKG8uRHN0LG8uT3JnKX0sbi5lZGdlR29lc1JpZ2h0PWZ1bmN0aW9uKG8pe3JldHVybiBuLnZlcnRMZXEoby5Pcmcsby5Ec3QpfSxuLnZlcnRMMWRpc3Q9ZnVuY3Rpb24obyxoKXtyZXR1cm4gTWF0aC5hYnMoby5zLWgucykrTWF0aC5hYnMoby50LWgudCl9LG4uZWRnZUV2YWw9ZnVuY3Rpb24obyxoLGMpe2kobi52ZXJ0TGVxKG8saCkmJm4udmVydExlcShoLGMpKTt2YXIgZz1oLnMtby5zLGI9Yy5zLWgucztyZXR1cm4gZytiPjA/ZzxiP2gudC1vLnQrKG8udC1jLnQpKihnLyhnK2IpKTpoLnQtYy50KyhjLnQtby50KSooYi8oZytiKSk6MH0sbi5lZGdlU2lnbj1mdW5jdGlvbihvLGgsYyl7aShuLnZlcnRMZXEobyxoKSYmbi52ZXJ0TGVxKGgsYykpO3ZhciBnPWgucy1vLnMsYj1jLnMtaC5zO3JldHVybiBnK2I+MD8oaC50LWMudCkqZysoaC50LW8udCkqYjowfSxuLnRyYW5zRXZhbD1mdW5jdGlvbihvLGgsYyl7aShuLnRyYW5zTGVxKG8saCkmJm4udHJhbnNMZXEoaCxjKSk7dmFyIGc9aC50LW8udCxiPWMudC1oLnQ7cmV0dXJuIGcrYj4wP2c8Yj9oLnMtby5zKyhvLnMtYy5zKSooZy8oZytiKSk6aC5zLWMucysoYy5zLW8ucykqKGIvKGcrYikpOjB9LG4udHJhbnNTaWduPWZ1bmN0aW9uKG8saCxjKXtpKG4udHJhbnNMZXEobyxoKSYmbi50cmFuc0xlcShoLGMpKTt2YXIgZz1oLnQtby50LGI9Yy50LWgudDtyZXR1cm4gZytiPjA/KGgucy1jLnMpKmcrKGgucy1vLnMpKmI6MH0sbi52ZXJ0Q0NXPWZ1bmN0aW9uKG8saCxjKXtyZXR1cm4gby5zKihoLnQtYy50KStoLnMqKGMudC1vLnQpK2Mucyooby50LWgudCk+PTB9LG4uaW50ZXJwb2xhdGU9ZnVuY3Rpb24obyxoLGMsZyl7cmV0dXJuIG89bzwwPzA6byxjPWM8MD8wOmMsbzw9Yz9jPT09MD8oaCtnKS8yOmgrKGctaCkqKG8vKG8rYykpOmcrKGgtZykqKGMvKG8rYykpfSxuLmludGVyc2VjdD1mdW5jdGlvbihvLGgsYyxnLGIpe3ZhciBFLEEsTDtuLnZlcnRMZXEobyxoKXx8KEw9byxvPWgsaD1MKSxuLnZlcnRMZXEoYyxnKXx8KEw9YyxjPWcsZz1MKSxuLnZlcnRMZXEobyxjKXx8KEw9byxvPWMsYz1MLEw9aCxoPWcsZz1MKSxuLnZlcnRMZXEoYyxoKT9uLnZlcnRMZXEoaCxnKT8oRT1uLmVkZ2VFdmFsKG8sYyxoKSxBPW4uZWRnZUV2YWwoYyxoLGcpLEUrQTwwJiYoRT0tRSxBPS1BKSxiLnM9bi5pbnRlcnBvbGF0ZShFLGMucyxBLGgucykpOihFPW4uZWRnZVNpZ24obyxjLGgpLEE9LW4uZWRnZVNpZ24obyxnLGgpLEUrQTwwJiYoRT0tRSxBPS1BKSxiLnM9bi5pbnRlcnBvbGF0ZShFLGMucyxBLGcucykpOmIucz0oYy5zK2gucykvMixuLnRyYW5zTGVxKG8saCl8fChMPW8sbz1oLGg9TCksbi50cmFuc0xlcShjLGcpfHwoTD1jLGM9ZyxnPUwpLG4udHJhbnNMZXEobyxjKXx8KEw9byxvPWMsYz1MLEw9aCxoPWcsZz1MKSxuLnRyYW5zTGVxKGMsaCk/bi50cmFuc0xlcShoLGcpPyhFPW4udHJhbnNFdmFsKG8sYyxoKSxBPW4udHJhbnNFdmFsKGMsaCxnKSxFK0E8MCYmKEU9LUUsQT0tQSksYi50PW4uaW50ZXJwb2xhdGUoRSxjLnQsQSxoLnQpKTooRT1uLnRyYW5zU2lnbihvLGMsaCksQT0tbi50cmFuc1NpZ24obyxnLGgpLEUrQTwwJiYoRT0tRSxBPS1BKSxiLnQ9bi5pbnRlcnBvbGF0ZShFLGMudCxBLGcudCkpOmIudD0oYy50K2gudCkvMn07ZnVuY3Rpb24gdigpe3RoaXMua2V5PW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGx9ZnVuY3Rpb24gZChvLGgpe3RoaXMuaGVhZD1uZXcgdix0aGlzLmhlYWQubmV4dD10aGlzLmhlYWQsdGhpcy5oZWFkLnByZXY9dGhpcy5oZWFkLHRoaXMuZnJhbWU9byx0aGlzLmxlcT1ofWQucHJvdG90eXBlPXttaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkLm5leHR9LG1heDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQucHJldn0saW5zZXJ0OmZ1bmN0aW9uKG8pe3JldHVybiB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsbyl9LHNlYXJjaDpmdW5jdGlvbihvKXt2YXIgaD10aGlzLmhlYWQ7ZG8gaD1oLm5leHQ7d2hpbGUoaC5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxvLGgua2V5KSk7cmV0dXJuIGh9LGluc2VydEJlZm9yZTpmdW5jdGlvbihvLGgpe2RvIG89by5wcmV2O3doaWxlKG8ua2V5IT09bnVsbCYmIXRoaXMubGVxKHRoaXMuZnJhbWUsby5rZXksaCkpO3ZhciBjPW5ldyB2O3JldHVybiBjLmtleT1oLGMubmV4dD1vLm5leHQsby5uZXh0LnByZXY9YyxjLnByZXY9byxvLm5leHQ9YyxjfSxkZWxldGU6ZnVuY3Rpb24obyl7by5uZXh0LnByZXY9by5wcmV2LG8ucHJldi5uZXh0PW8ubmV4dH19O2Z1bmN0aW9uIHAoKXt0aGlzLmhhbmRsZT1udWxsfWZ1bmN0aW9uIHkoKXt0aGlzLmtleT1udWxsLHRoaXMubm9kZT1udWxsfWZ1bmN0aW9uIFAobyxoKXt0aGlzLnNpemU9MCx0aGlzLm1heD1vLHRoaXMubm9kZXM9W10sdGhpcy5ub2Rlcy5sZW5ndGg9bysxO3ZhciBjO2ZvcihjPTA7Yzx0aGlzLm5vZGVzLmxlbmd0aDtjKyspdGhpcy5ub2Rlc1tjXT1uZXcgcDtmb3IodGhpcy5oYW5kbGVzPVtdLHRoaXMuaGFuZGxlcy5sZW5ndGg9bysxLGM9MDtjPHRoaXMuaGFuZGxlcy5sZW5ndGg7YysrKXRoaXMuaGFuZGxlc1tjXT1uZXcgeTt0aGlzLmluaXRpYWxpemVkPSExLHRoaXMuZnJlZUxpc3Q9MCx0aGlzLmxlcT1oLHRoaXMubm9kZXNbMV0uaGFuZGxlPTEsdGhpcy5oYW5kbGVzWzFdLmtleT1udWxsfVAucHJvdG90eXBlPXtmbG9hdERvd25fOmZ1bmN0aW9uKG8pe3ZhciBoPXRoaXMubm9kZXMsYz10aGlzLmhhbmRsZXMsZyxiLEU7Zm9yKGc9aFtvXS5oYW5kbGU7Oyl7aWYoRT1vPDwxLEU8dGhpcy5zaXplJiZ0aGlzLmxlcShjW2hbRSsxXS5oYW5kbGVdLmtleSxjW2hbRV0uaGFuZGxlXS5rZXkpJiYrK0UsaShFPD10aGlzLm1heCksYj1oW0VdLmhhbmRsZSxFPnRoaXMuc2l6ZXx8dGhpcy5sZXEoY1tnXS5rZXksY1tiXS5rZXkpKXtoW29dLmhhbmRsZT1nLGNbZ10ubm9kZT1vO2JyZWFrfWhbb10uaGFuZGxlPWIsY1tiXS5ub2RlPW8sbz1FfX0sZmxvYXRVcF86ZnVuY3Rpb24obyl7dmFyIGg9dGhpcy5ub2RlcyxjPXRoaXMuaGFuZGxlcyxnLGIsRTtmb3IoZz1oW29dLmhhbmRsZTs7KXtpZihFPW8+PjEsYj1oW0VdLmhhbmRsZSxFPT09MHx8dGhpcy5sZXEoY1tiXS5rZXksY1tnXS5rZXkpKXtoW29dLmhhbmRsZT1nLGNbZ10ubm9kZT1vO2JyZWFrfWhbb10uaGFuZGxlPWIsY1tiXS5ub2RlPW8sbz1FfX0saW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgbz10aGlzLnNpemU7bz49MTstLW8pdGhpcy5mbG9hdERvd25fKG8pO3RoaXMuaW5pdGlhbGl6ZWQ9ITB9LG1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhbmRsZXNbdGhpcy5ub2Rlc1sxXS5oYW5kbGVdLmtleX0saW5zZXJ0OmZ1bmN0aW9uKG8pe3ZhciBoLGM7aWYoaD0rK3RoaXMuc2l6ZSxoKjI+dGhpcy5tYXgpe3RoaXMubWF4Kj0yO3ZhciBnLGI7Zm9yKGI9dGhpcy5ub2Rlcy5sZW5ndGgsdGhpcy5ub2Rlcy5sZW5ndGg9dGhpcy5tYXgrMSxnPWI7Zzx0aGlzLm5vZGVzLmxlbmd0aDtnKyspdGhpcy5ub2Rlc1tnXT1uZXcgcDtmb3IoYj10aGlzLmhhbmRsZXMubGVuZ3RoLHRoaXMuaGFuZGxlcy5sZW5ndGg9dGhpcy5tYXgrMSxnPWI7Zzx0aGlzLmhhbmRsZXMubGVuZ3RoO2crKyl0aGlzLmhhbmRsZXNbZ109bmV3IHl9cmV0dXJuIHRoaXMuZnJlZUxpc3Q9PT0wP2M9aDooYz10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9dGhpcy5oYW5kbGVzW2NdLm5vZGUpLHRoaXMubm9kZXNbaF0uaGFuZGxlPWMsdGhpcy5oYW5kbGVzW2NdLm5vZGU9aCx0aGlzLmhhbmRsZXNbY10ua2V5PW8sdGhpcy5pbml0aWFsaXplZCYmdGhpcy5mbG9hdFVwXyhoKSxjfSxleHRyYWN0TWluOmZ1bmN0aW9uKCl7dmFyIG89dGhpcy5ub2RlcyxoPXRoaXMuaGFuZGxlcyxjPW9bMV0uaGFuZGxlLGc9aFtjXS5rZXk7cmV0dXJuIHRoaXMuc2l6ZT4wJiYob1sxXS5oYW5kbGU9b1t0aGlzLnNpemVdLmhhbmRsZSxoW29bMV0uaGFuZGxlXS5ub2RlPTEsaFtjXS5rZXk9bnVsbCxoW2NdLm5vZGU9dGhpcy5mcmVlTGlzdCx0aGlzLmZyZWVMaXN0PWMsLS10aGlzLnNpemUsdGhpcy5zaXplPjAmJnRoaXMuZmxvYXREb3duXygxKSksZ30sZGVsZXRlOmZ1bmN0aW9uKG8pe3ZhciBoPXRoaXMubm9kZXMsYz10aGlzLmhhbmRsZXMsZztpKG8+PTEmJm88PXRoaXMubWF4JiZjW29dLmtleSE9PW51bGwpLGc9Y1tvXS5ub2RlLGhbZ10uaGFuZGxlPWhbdGhpcy5zaXplXS5oYW5kbGUsY1toW2ddLmhhbmRsZV0ubm9kZT1nLC0tdGhpcy5zaXplLGc8PXRoaXMuc2l6ZSYmKGc8PTF8fHRoaXMubGVxKGNbaFtnPj4xXS5oYW5kbGVdLmtleSxjW2hbZ10uaGFuZGxlXS5rZXkpP3RoaXMuZmxvYXREb3duXyhnKTp0aGlzLmZsb2F0VXBfKGcpKSxjW29dLmtleT1udWxsLGNbb10ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9b319O2Z1bmN0aW9uIHgoKXt0aGlzLmVVcD1udWxsLHRoaXMubm9kZVVwPW51bGwsdGhpcy53aW5kaW5nTnVtYmVyPTAsdGhpcy5pbnNpZGU9ITEsdGhpcy5zZW50aW5lbD0hMSx0aGlzLmRpcnR5PSExLHRoaXMuZml4VXBwZXJFZGdlPSExfXZhciBtPXt9O20ucmVnaW9uQmVsb3c9ZnVuY3Rpb24obyl7cmV0dXJuIG8ubm9kZVVwLnByZXYua2V5fSxtLnJlZ2lvbkFib3ZlPWZ1bmN0aW9uKG8pe3JldHVybiBvLm5vZGVVcC5uZXh0LmtleX0sbS5kZWJ1Z0V2ZW50PWZ1bmN0aW9uKG8pe30sbS5hZGRXaW5kaW5nPWZ1bmN0aW9uKG8saCl7by53aW5kaW5nKz1oLndpbmRpbmcsby5TeW0ud2luZGluZys9aC5TeW0ud2luZGluZ30sbS5lZGdlTGVxPWZ1bmN0aW9uKG8saCxjKXt2YXIgZz1vLmV2ZW50LEEsTCxiPWguZVVwLEU9Yy5lVXA7aWYoYi5Ec3Q9PT1nKXJldHVybiBFLkRzdD09PWc/bi52ZXJ0TGVxKGIuT3JnLEUuT3JnKT9uLmVkZ2VTaWduKEUuRHN0LGIuT3JnLEUuT3JnKTw9MDpuLmVkZ2VTaWduKGIuRHN0LEUuT3JnLGIuT3JnKT49MDpuLmVkZ2VTaWduKEUuRHN0LGcsRS5PcmcpPD0wO2lmKEUuRHN0PT09ZylyZXR1cm4gbi5lZGdlU2lnbihiLkRzdCxnLGIuT3JnKT49MDt2YXIgQT1uLmVkZ2VFdmFsKGIuRHN0LGcsYi5PcmcpLEw9bi5lZGdlRXZhbChFLkRzdCxnLEUuT3JnKTtyZXR1cm4gQT49TH0sbS5kZWxldGVSZWdpb249ZnVuY3Rpb24obyxoKXtoLmZpeFVwcGVyRWRnZSYmaShoLmVVcC53aW5kaW5nPT09MCksaC5lVXAuYWN0aXZlUmVnaW9uPW51bGwsby5kaWN0LmRlbGV0ZShoLm5vZGVVcCl9LG0uZml4VXBwZXJFZGdlPWZ1bmN0aW9uKG8saCxjKXtpKGguZml4VXBwZXJFZGdlKSxvLm1lc2guZGVsZXRlKGguZVVwKSxoLmZpeFVwcGVyRWRnZT0hMSxoLmVVcD1jLGMuYWN0aXZlUmVnaW9uPWh9LG0udG9wTGVmdFJlZ2lvbj1mdW5jdGlvbihvLGgpe3ZhciBjPWguZVVwLk9yZyxnO2RvIGg9bS5yZWdpb25BYm92ZShoKTt3aGlsZShoLmVVcC5Pcmc9PT1jKTtpZihoLmZpeFVwcGVyRWRnZSl7aWYoZz1vLm1lc2guY29ubmVjdChtLnJlZ2lvbkJlbG93KGgpLmVVcC5TeW0saC5lVXAuTG5leHQpLGc9PT1udWxsKXJldHVybiBudWxsO20uZml4VXBwZXJFZGdlKG8saCxnKSxoPW0ucmVnaW9uQWJvdmUoaCl9cmV0dXJuIGh9LG0udG9wUmlnaHRSZWdpb249ZnVuY3Rpb24obyl7dmFyIGg9by5lVXAuRHN0O2RvIG89bS5yZWdpb25BYm92ZShvKTt3aGlsZShvLmVVcC5Ec3Q9PT1oKTtyZXR1cm4gb30sbS5hZGRSZWdpb25CZWxvdz1mdW5jdGlvbihvLGgsYyl7dmFyIGc9bmV3IHg7cmV0dXJuIGcuZVVwPWMsZy5ub2RlVXA9by5kaWN0Lmluc2VydEJlZm9yZShoLm5vZGVVcCxnKSxnLmZpeFVwcGVyRWRnZT0hMSxnLnNlbnRpbmVsPSExLGcuZGlydHk9ITEsYy5hY3RpdmVSZWdpb249ZyxnfSxtLmlzV2luZGluZ0luc2lkZT1mdW5jdGlvbihvLGgpe3N3aXRjaChvLndpbmRpbmdSdWxlKXtjYXNlIHIuV0lORElOR19PREQ6cmV0dXJuKGgmMSkhPT0wO2Nhc2Ugci5XSU5ESU5HX05PTlpFUk86cmV0dXJuIGghPT0wO2Nhc2Ugci5XSU5ESU5HX1BPU0lUSVZFOnJldHVybiBoPjA7Y2FzZSByLldJTkRJTkdfTkVHQVRJVkU6cmV0dXJuIGg8MDtjYXNlIHIuV0lORElOR19BQlNfR0VRX1RXTzpyZXR1cm4gaD49Mnx8aDw9LTJ9cmV0dXJuIGkoITEpLCExfSxtLmNvbXB1dGVXaW5kaW5nPWZ1bmN0aW9uKG8saCl7aC53aW5kaW5nTnVtYmVyPW0ucmVnaW9uQWJvdmUoaCkud2luZGluZ051bWJlcitoLmVVcC53aW5kaW5nLGguaW5zaWRlPW0uaXNXaW5kaW5nSW5zaWRlKG8saC53aW5kaW5nTnVtYmVyKX0sbS5maW5pc2hSZWdpb249ZnVuY3Rpb24obyxoKXt2YXIgYz1oLmVVcCxnPWMuTGZhY2U7Zy5pbnNpZGU9aC5pbnNpZGUsZy5hbkVkZ2U9YyxtLmRlbGV0ZVJlZ2lvbihvLGgpfSxtLmZpbmlzaExlZnRSZWdpb25zPWZ1bmN0aW9uKG8saCxjKXtmb3IodmFyIGcsQSxiPW51bGwsRT1oLEE9aC5lVXA7RSE9PWM7KXtpZihFLmZpeFVwcGVyRWRnZT0hMSxiPW0ucmVnaW9uQmVsb3coRSksZz1iLmVVcCxnLk9yZyE9QS5Pcmcpe2lmKCFiLmZpeFVwcGVyRWRnZSl7bS5maW5pc2hSZWdpb24obyxFKTticmVha31nPW8ubWVzaC5jb25uZWN0KEEuTHByZXYsZy5TeW0pLG0uZml4VXBwZXJFZGdlKG8sYixnKX1BLk9uZXh0IT09ZyYmKG8ubWVzaC5zcGxpY2UoZy5PcHJldixnKSxvLm1lc2guc3BsaWNlKEEsZykpLG0uZmluaXNoUmVnaW9uKG8sRSksQT1iLmVVcCxFPWJ9cmV0dXJuIEF9LG0uYWRkUmlnaHRFZGdlcz1mdW5jdGlvbihvLGgsYyxnLGIsRSl7dmFyIEEsTCxNLEksRD0hMDtNPWM7ZG8gaShuLnZlcnRMZXEoTS5PcmcsTS5Ec3QpKSxtLmFkZFJlZ2lvbkJlbG93KG8saCxNLlN5bSksTT1NLk9uZXh0O3doaWxlKE0hPT1nKTtmb3IoYj09PW51bGwmJihiPW0ucmVnaW9uQmVsb3coaCkuZVVwLlJwcmV2KSxMPWgsST1iO0E9bS5yZWdpb25CZWxvdyhMKSxNPUEuZVVwLlN5bSxNLk9yZz09PUkuT3JnOylNLk9uZXh0IT09SSYmKG8ubWVzaC5zcGxpY2UoTS5PcHJldixNKSxvLm1lc2guc3BsaWNlKEkuT3ByZXYsTSkpLEEud2luZGluZ051bWJlcj1MLndpbmRpbmdOdW1iZXItTS53aW5kaW5nLEEuaW5zaWRlPW0uaXNXaW5kaW5nSW5zaWRlKG8sQS53aW5kaW5nTnVtYmVyKSxMLmRpcnR5PSEwLCFEJiZtLmNoZWNrRm9yUmlnaHRTcGxpY2UobyxMKSYmKG0uYWRkV2luZGluZyhNLEkpLG0uZGVsZXRlUmVnaW9uKG8sTCksby5tZXNoLmRlbGV0ZShJKSksRD0hMSxMPUEsST1NO0wuZGlydHk9ITAsaShMLndpbmRpbmdOdW1iZXItTS53aW5kaW5nPT09QS53aW5kaW5nTnVtYmVyKSxFJiZtLndhbGtEaXJ0eVJlZ2lvbnMobyxMKX0sbS5zcGxpY2VNZXJnZVZlcnRpY2VzPWZ1bmN0aW9uKG8saCxjKXtvLm1lc2guc3BsaWNlKGgsYyl9LG0udmVydGV4V2VpZ2h0cz1mdW5jdGlvbihvLGgsYyl7dmFyIGc9bi52ZXJ0TDFkaXN0KGgsbyksYj1uLnZlcnRMMWRpc3QoYyxvKSxFPS41KmIvKGcrYiksQT0uNSpnLyhnK2IpO28uY29vcmRzWzBdKz1FKmguY29vcmRzWzBdK0EqYy5jb29yZHNbMF0sby5jb29yZHNbMV0rPUUqaC5jb29yZHNbMV0rQSpjLmNvb3Jkc1sxXSxvLmNvb3Jkc1syXSs9RSpoLmNvb3Jkc1syXStBKmMuY29vcmRzWzJdfSxtLmdldEludGVyc2VjdERhdGE9ZnVuY3Rpb24obyxoLGMsZyxiLEUpe2guY29vcmRzWzBdPWguY29vcmRzWzFdPWguY29vcmRzWzJdPTAsaC5pZHg9LTEsbS52ZXJ0ZXhXZWlnaHRzKGgsYyxnKSxtLnZlcnRleFdlaWdodHMoaCxiLEUpfSxtLmNoZWNrRm9yUmlnaHRTcGxpY2U9ZnVuY3Rpb24obyxoKXt2YXIgYz1tLnJlZ2lvbkJlbG93KGgpLGc9aC5lVXAsYj1jLmVVcDtpZihuLnZlcnRMZXEoZy5PcmcsYi5PcmcpKXtpZihuLmVkZ2VTaWduKGIuRHN0LGcuT3JnLGIuT3JnKT4wKXJldHVybiExO24udmVydEVxKGcuT3JnLGIuT3JnKT9nLk9yZyE9PWIuT3JnJiYoby5wcS5kZWxldGUoZy5PcmcucHFIYW5kbGUpLG0uc3BsaWNlTWVyZ2VWZXJ0aWNlcyhvLGIuT3ByZXYsZykpOihvLm1lc2guc3BsaXRFZGdlKGIuU3ltKSxvLm1lc2guc3BsaWNlKGcsYi5PcHJldiksaC5kaXJ0eT1jLmRpcnR5PSEwKX1lbHNle2lmKG4uZWRnZVNpZ24oZy5Ec3QsYi5PcmcsZy5PcmcpPDApcmV0dXJuITE7bS5yZWdpb25BYm92ZShoKS5kaXJ0eT1oLmRpcnR5PSEwLG8ubWVzaC5zcGxpdEVkZ2UoZy5TeW0pLG8ubWVzaC5zcGxpY2UoYi5PcHJldixnKX1yZXR1cm4hMH0sbS5jaGVja0ZvckxlZnRTcGxpY2U9ZnVuY3Rpb24obyxoKXt2YXIgYz1tLnJlZ2lvbkJlbG93KGgpLGc9aC5lVXAsYj1jLmVVcCxFO2lmKGkoIW4udmVydEVxKGcuRHN0LGIuRHN0KSksbi52ZXJ0TGVxKGcuRHN0LGIuRHN0KSl7aWYobi5lZGdlU2lnbihnLkRzdCxiLkRzdCxnLk9yZyk8MClyZXR1cm4hMTttLnJlZ2lvbkFib3ZlKGgpLmRpcnR5PWguZGlydHk9ITAsRT1vLm1lc2guc3BsaXRFZGdlKGcpLG8ubWVzaC5zcGxpY2UoYi5TeW0sRSksRS5MZmFjZS5pbnNpZGU9aC5pbnNpZGV9ZWxzZXtpZihuLmVkZ2VTaWduKGIuRHN0LGcuRHN0LGIuT3JnKT4wKXJldHVybiExO2guZGlydHk9Yy5kaXJ0eT0hMCxFPW8ubWVzaC5zcGxpdEVkZ2UoYiksby5tZXNoLnNwbGljZShnLkxuZXh0LGIuU3ltKSxFLlJmYWNlLmluc2lkZT1oLmluc2lkZX1yZXR1cm4hMH0sbS5jaGVja0ZvckludGVyc2VjdD1mdW5jdGlvbihvLGgpe3ZhciBjPW0ucmVnaW9uQmVsb3coaCksZz1oLmVVcCxiPWMuZVVwLEU9Zy5PcmcsQT1iLk9yZyxMPWcuRHN0LE09Yi5Ec3QsSSxELFI9bmV3IGEsQyxCO2lmKGkoIW4udmVydEVxKE0sTCkpLGkobi5lZGdlU2lnbihMLG8uZXZlbnQsRSk8PTApLGkobi5lZGdlU2lnbihNLG8uZXZlbnQsQSk+PTApLGkoRSE9PW8uZXZlbnQmJkEhPT1vLmV2ZW50KSxpKCFoLmZpeFVwcGVyRWRnZSYmIWMuZml4VXBwZXJFZGdlKSxFPT09QXx8KEk9TWF0aC5taW4oRS50LEwudCksRD1NYXRoLm1heChBLnQsTS50KSxJPkQpKXJldHVybiExO2lmKG4udmVydExlcShFLEEpKXtpZihuLmVkZ2VTaWduKE0sRSxBKT4wKXJldHVybiExfWVsc2UgaWYobi5lZGdlU2lnbihMLEEsRSk8MClyZXR1cm4hMTtyZXR1cm4gbS5kZWJ1Z0V2ZW50KG8pLG4uaW50ZXJzZWN0KEwsRSxNLEEsUiksaShNYXRoLm1pbihFLnQsTC50KTw9Ui50KSxpKFIudDw9TWF0aC5tYXgoQS50LE0udCkpLGkoTWF0aC5taW4oTS5zLEwucyk8PVIucyksaShSLnM8PU1hdGgubWF4KEEucyxFLnMpKSxuLnZlcnRMZXEoUixvLmV2ZW50KSYmKFIucz1vLmV2ZW50LnMsUi50PW8uZXZlbnQudCksQz1uLnZlcnRMZXEoRSxBKT9FOkEsbi52ZXJ0TGVxKEMsUikmJihSLnM9Qy5zLFIudD1DLnQpLG4udmVydEVxKFIsRSl8fG4udmVydEVxKFIsQSk/KG0uY2hlY2tGb3JSaWdodFNwbGljZShvLGgpLCExKTohbi52ZXJ0RXEoTCxvLmV2ZW50KSYmbi5lZGdlU2lnbihMLG8uZXZlbnQsUik+PTB8fCFuLnZlcnRFcShNLG8uZXZlbnQpJiZuLmVkZ2VTaWduKE0sby5ldmVudCxSKTw9MD9NPT09by5ldmVudD8oby5tZXNoLnNwbGl0RWRnZShnLlN5bSksby5tZXNoLnNwbGljZShiLlN5bSxnKSxoPW0udG9wTGVmdFJlZ2lvbihvLGgpLGc9bS5yZWdpb25CZWxvdyhoKS5lVXAsbS5maW5pc2hMZWZ0UmVnaW9ucyhvLG0ucmVnaW9uQmVsb3coaCksYyksbS5hZGRSaWdodEVkZ2VzKG8saCxnLk9wcmV2LGcsZywhMCksITApOkw9PT1vLmV2ZW50PyhvLm1lc2guc3BsaXRFZGdlKGIuU3ltKSxvLm1lc2guc3BsaWNlKGcuTG5leHQsYi5PcHJldiksYz1oLGg9bS50b3BSaWdodFJlZ2lvbihoKSxCPW0ucmVnaW9uQmVsb3coaCkuZVVwLlJwcmV2LGMuZVVwPWIuT3ByZXYsYj1tLmZpbmlzaExlZnRSZWdpb25zKG8sYyxudWxsKSxtLmFkZFJpZ2h0RWRnZXMobyxoLGIuT25leHQsZy5ScHJldixCLCEwKSwhMCk6KG4uZWRnZVNpZ24oTCxvLmV2ZW50LFIpPj0wJiYobS5yZWdpb25BYm92ZShoKS5kaXJ0eT1oLmRpcnR5PSEwLG8ubWVzaC5zcGxpdEVkZ2UoZy5TeW0pLGcuT3JnLnM9by5ldmVudC5zLGcuT3JnLnQ9by5ldmVudC50KSxuLmVkZ2VTaWduKE0sby5ldmVudCxSKTw9MCYmKGguZGlydHk9Yy5kaXJ0eT0hMCxvLm1lc2guc3BsaXRFZGdlKGIuU3ltKSxiLk9yZy5zPW8uZXZlbnQucyxiLk9yZy50PW8uZXZlbnQudCksITEpOihvLm1lc2guc3BsaXRFZGdlKGcuU3ltKSxvLm1lc2guc3BsaXRFZGdlKGIuU3ltKSxvLm1lc2guc3BsaWNlKGIuT3ByZXYsZyksZy5Pcmcucz1SLnMsZy5PcmcudD1SLnQsZy5PcmcucHFIYW5kbGU9by5wcS5pbnNlcnQoZy5PcmcpLG0uZ2V0SW50ZXJzZWN0RGF0YShvLGcuT3JnLEUsTCxBLE0pLG0ucmVnaW9uQWJvdmUoaCkuZGlydHk9aC5kaXJ0eT1jLmRpcnR5PSEwLCExKX0sbS53YWxrRGlydHlSZWdpb25zPWZ1bmN0aW9uKG8saCl7Zm9yKHZhciBjPW0ucmVnaW9uQmVsb3coaCksZyxiOzspe2Zvcig7Yy5kaXJ0eTspaD1jLGM9bS5yZWdpb25CZWxvdyhjKTtpZighaC5kaXJ0eSYmKGM9aCxoPW0ucmVnaW9uQWJvdmUoaCksaD09PW51bGx8fCFoLmRpcnR5KSlyZXR1cm47aWYoaC5kaXJ0eT0hMSxnPWguZVVwLGI9Yy5lVXAsZy5Ec3QhPT1iLkRzdCYmbS5jaGVja0ZvckxlZnRTcGxpY2UobyxoKSYmKGMuZml4VXBwZXJFZGdlPyhtLmRlbGV0ZVJlZ2lvbihvLGMpLG8ubWVzaC5kZWxldGUoYiksYz1tLnJlZ2lvbkJlbG93KGgpLGI9Yy5lVXApOmguZml4VXBwZXJFZGdlJiYobS5kZWxldGVSZWdpb24obyxoKSxvLm1lc2guZGVsZXRlKGcpLGg9bS5yZWdpb25BYm92ZShjKSxnPWguZVVwKSksZy5PcmchPT1iLk9yZylpZihnLkRzdCE9PWIuRHN0JiYhaC5maXhVcHBlckVkZ2UmJiFjLmZpeFVwcGVyRWRnZSYmKGcuRHN0PT09by5ldmVudHx8Yi5Ec3Q9PT1vLmV2ZW50KSl7aWYobS5jaGVja0ZvckludGVyc2VjdChvLGgpKXJldHVybn1lbHNlIG0uY2hlY2tGb3JSaWdodFNwbGljZShvLGgpO2cuT3JnPT09Yi5PcmcmJmcuRHN0PT09Yi5Ec3QmJihtLmFkZFdpbmRpbmcoYixnKSxtLmRlbGV0ZVJlZ2lvbihvLGgpLG8ubWVzaC5kZWxldGUoZyksaD1tLnJlZ2lvbkFib3ZlKGMpKX19LG0uY29ubmVjdFJpZ2h0VmVydGV4PWZ1bmN0aW9uKG8saCxjKXt2YXIgZyxiPWMuT25leHQsRT1tLnJlZ2lvbkJlbG93KGgpLEE9aC5lVXAsTD1FLmVVcCxNPSExO2lmKEEuRHN0IT09TC5Ec3QmJm0uY2hlY2tGb3JJbnRlcnNlY3QobyxoKSxuLnZlcnRFcShBLk9yZyxvLmV2ZW50KSYmKG8ubWVzaC5zcGxpY2UoYi5PcHJldixBKSxoPW0udG9wTGVmdFJlZ2lvbihvLGgpLGI9bS5yZWdpb25CZWxvdyhoKS5lVXAsbS5maW5pc2hMZWZ0UmVnaW9ucyhvLG0ucmVnaW9uQmVsb3coaCksRSksTT0hMCksbi52ZXJ0RXEoTC5Pcmcsby5ldmVudCkmJihvLm1lc2guc3BsaWNlKGMsTC5PcHJldiksYz1tLmZpbmlzaExlZnRSZWdpb25zKG8sRSxudWxsKSxNPSEwKSxNKXttLmFkZFJpZ2h0RWRnZXMobyxoLGMuT25leHQsYixiLCEwKTtyZXR1cm59bi52ZXJ0TGVxKEwuT3JnLEEuT3JnKT9nPUwuT3ByZXY6Zz1BLGc9by5tZXNoLmNvbm5lY3QoYy5McHJldixnKSxtLmFkZFJpZ2h0RWRnZXMobyxoLGcsZy5PbmV4dCxnLk9uZXh0LCExKSxnLlN5bS5hY3RpdmVSZWdpb24uZml4VXBwZXJFZGdlPSEwLG0ud2Fsa0RpcnR5UmVnaW9ucyhvLGgpfSxtLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZT1mdW5jdGlvbihvLGgsYyl7dmFyIGcsYixFLEEsTDtpZihnPWguZVVwLG4udmVydEVxKGcuT3JnLGMpKXtpKCExKSxtLnNwbGljZU1lcmdlVmVydGljZXMobyxnLGMuYW5FZGdlKTtyZXR1cm59aWYoIW4udmVydEVxKGcuRHN0LGMpKXtvLm1lc2guc3BsaXRFZGdlKGcuU3ltKSxoLmZpeFVwcGVyRWRnZSYmKG8ubWVzaC5kZWxldGUoZy5PbmV4dCksaC5maXhVcHBlckVkZ2U9ITEpLG8ubWVzaC5zcGxpY2UoYy5hbkVkZ2UsZyksbS5zd2VlcEV2ZW50KG8sYyk7cmV0dXJufWkoITEpLGg9bS50b3BSaWdodFJlZ2lvbihoKSxMPW0ucmVnaW9uQmVsb3coaCksRT1MLmVVcC5TeW0sYj1BPUUuT25leHQsTC5maXhVcHBlckVkZ2UmJihpKGIhPT1FKSxtLmRlbGV0ZVJlZ2lvbihvLEwpLG8ubWVzaC5kZWxldGUoRSksRT1iLk9wcmV2KSxvLm1lc2guc3BsaWNlKGMuYW5FZGdlLEUpLG4uZWRnZUdvZXNMZWZ0KGIpfHwoYj1udWxsKSxtLmFkZFJpZ2h0RWRnZXMobyxoLEUuT25leHQsQSxiLCEwKX0sbS5jb25uZWN0TGVmdFZlcnRleD1mdW5jdGlvbihvLGgpe3ZhciBjLGcsYixFLEEsTCxNPW5ldyB4O2lmKE0uZVVwPWguYW5FZGdlLlN5bSxjPW8uZGljdC5zZWFyY2goTSkua2V5LGc9bS5yZWdpb25CZWxvdyhjKSwhIWcpe2lmKEU9Yy5lVXAsQT1nLmVVcCxuLmVkZ2VTaWduKEUuRHN0LGgsRS5PcmcpPT09MCl7bS5jb25uZWN0TGVmdERlZ2VuZXJhdGUobyxjLGgpO3JldHVybn1pZihiPW4udmVydExlcShBLkRzdCxFLkRzdCk/YzpnLGMuaW5zaWRlfHxiLmZpeFVwcGVyRWRnZSl7aWYoYj09PWMpTD1vLm1lc2guY29ubmVjdChoLmFuRWRnZS5TeW0sRS5MbmV4dCk7ZWxzZXt2YXIgST1vLm1lc2guY29ubmVjdChBLkRuZXh0LGguYW5FZGdlKTtMPUkuU3ltfWIuZml4VXBwZXJFZGdlP20uZml4VXBwZXJFZGdlKG8sYixMKTptLmNvbXB1dGVXaW5kaW5nKG8sbS5hZGRSZWdpb25CZWxvdyhvLGMsTCkpLG0uc3dlZXBFdmVudChvLGgpfWVsc2UgbS5hZGRSaWdodEVkZ2VzKG8sYyxoLmFuRWRnZSxoLmFuRWRnZSxudWxsLCEwKX19LG0uc3dlZXBFdmVudD1mdW5jdGlvbihvLGgpe28uZXZlbnQ9aCxtLmRlYnVnRXZlbnQobyk7Zm9yKHZhciBjPWguYW5FZGdlO2MuYWN0aXZlUmVnaW9uPT09bnVsbDspaWYoYz1jLk9uZXh0LGM9PT1oLmFuRWRnZSl7bS5jb25uZWN0TGVmdFZlcnRleChvLGgpO3JldHVybn12YXIgZz1tLnRvcExlZnRSZWdpb24obyxjLmFjdGl2ZVJlZ2lvbik7aShnIT09bnVsbCk7dmFyIGI9bS5yZWdpb25CZWxvdyhnKSxFPWIuZVVwLEE9bS5maW5pc2hMZWZ0UmVnaW9ucyhvLGIsbnVsbCk7QS5PbmV4dD09PUU/bS5jb25uZWN0UmlnaHRWZXJ0ZXgobyxnLEEpOm0uYWRkUmlnaHRFZGdlcyhvLGcsQS5PbmV4dCxFLEUsITApfSxtLmFkZFNlbnRpbmVsPWZ1bmN0aW9uKG8saCxjLGcpe3ZhciBiPW5ldyB4LEU9by5tZXNoLm1ha2VFZGdlKCk7RS5Pcmcucz1jLEUuT3JnLnQ9ZyxFLkRzdC5zPWgsRS5Ec3QudD1nLG8uZXZlbnQ9RS5Ec3QsYi5lVXA9RSxiLndpbmRpbmdOdW1iZXI9MCxiLmluc2lkZT0hMSxiLmZpeFVwcGVyRWRnZT0hMSxiLnNlbnRpbmVsPSEwLGIuZGlydHk9ITEsYi5ub2RlVXA9by5kaWN0Lmluc2VydChiKX0sbS5pbml0RWRnZURpY3Q9ZnVuY3Rpb24obyl7by5kaWN0PW5ldyBkKG8sbS5lZGdlTGVxKTt2YXIgaD1vLmJtYXhbMF0tby5ibWluWzBdLGM9by5ibWF4WzFdLW8uYm1pblsxXSxnPW8uYm1pblswXS1oLGI9by5ibWF4WzBdK2gsRT1vLmJtaW5bMV0tYyxBPW8uYm1heFsxXStjO20uYWRkU2VudGluZWwobyxnLGIsRSksbS5hZGRTZW50aW5lbChvLGcsYixBKX0sbS5kb25lRWRnZURpY3Q9ZnVuY3Rpb24obyl7Zm9yKHZhciBoLGM9MDsoaD1vLmRpY3QubWluKCkua2V5KSE9PW51bGw7KWguc2VudGluZWx8fChpKGguZml4VXBwZXJFZGdlKSxpKCsrYz09PTEpKSxpKGgud2luZGluZ051bWJlcj09PTApLG0uZGVsZXRlUmVnaW9uKG8saCl9LG0ucmVtb3ZlRGVnZW5lcmF0ZUVkZ2VzPWZ1bmN0aW9uKG8pe3ZhciBoLGMsZyxiPW8ubWVzaC5lSGVhZDtmb3IoaD1iLm5leHQ7aCE9PWI7aD1jKWM9aC5uZXh0LGc9aC5MbmV4dCxuLnZlcnRFcShoLk9yZyxoLkRzdCkmJmguTG5leHQuTG5leHQhPT1oJiYobS5zcGxpY2VNZXJnZVZlcnRpY2VzKG8sZyxoKSxvLm1lc2guZGVsZXRlKGgpLGg9ZyxnPWguTG5leHQpLGcuTG5leHQ9PT1oJiYoZyE9PWgmJigoZz09PWN8fGc9PT1jLlN5bSkmJihjPWMubmV4dCksby5tZXNoLmRlbGV0ZShnKSksKGg9PT1jfHxoPT09Yy5TeW0pJiYoYz1jLm5leHQpLG8ubWVzaC5kZWxldGUoaCkpfSxtLmluaXRQcmlvcml0eVE9ZnVuY3Rpb24obyl7dmFyIGgsYyxnLGI9MDtmb3IoZz1vLm1lc2gudkhlYWQsYz1nLm5leHQ7YyE9PWc7Yz1jLm5leHQpYisrO2ZvcihiKz04LGg9by5wcT1uZXcgUChiLG4udmVydExlcSksZz1vLm1lc2gudkhlYWQsYz1nLm5leHQ7YyE9PWc7Yz1jLm5leHQpYy5wcUhhbmRsZT1oLmluc2VydChjKTtyZXR1cm4gYyE9PWc/ITE6KGguaW5pdCgpLCEwKX0sbS5kb25lUHJpb3JpdHlRPWZ1bmN0aW9uKG8pe28ucHE9bnVsbH0sbS5yZW1vdmVEZWdlbmVyYXRlRmFjZXM9ZnVuY3Rpb24obyxoKXt2YXIgYyxnLGI7Zm9yKGM9aC5mSGVhZC5uZXh0O2MhPT1oLmZIZWFkO2M9ZylnPWMubmV4dCxiPWMuYW5FZGdlLGkoYi5MbmV4dCE9PWIpLGIuTG5leHQuTG5leHQ9PT1iJiYobS5hZGRXaW5kaW5nKGIuT25leHQsYiksby5tZXNoLmRlbGV0ZShiKSk7cmV0dXJuITB9LG0uY29tcHV0ZUludGVyaW9yPWZ1bmN0aW9uKG8pe3ZhciBoLGM7aWYobS5yZW1vdmVEZWdlbmVyYXRlRWRnZXMobyksIW0uaW5pdFByaW9yaXR5UShvKSlyZXR1cm4hMTtmb3IobS5pbml0RWRnZURpY3Qobyk7KGg9by5wcS5leHRyYWN0TWluKCkpIT09bnVsbDspe2Zvcig7Yz1vLnBxLm1pbigpLCEoYz09PW51bGx8fCFuLnZlcnRFcShjLGgpKTspYz1vLnBxLmV4dHJhY3RNaW4oKSxtLnNwbGljZU1lcmdlVmVydGljZXMobyxoLmFuRWRnZSxjLmFuRWRnZSk7bS5zd2VlcEV2ZW50KG8saCl9cmV0dXJuIG8uZXZlbnQ9by5kaWN0Lm1pbigpLmtleS5lVXAuT3JnLG0uZGVidWdFdmVudChvKSxtLmRvbmVFZGdlRGljdChvKSxtLmRvbmVQcmlvcml0eVEobyksbS5yZW1vdmVEZWdlbmVyYXRlRmFjZXMobyxvLm1lc2gpPyhvLm1lc2guY2hlY2soKSwhMCk6ITF9O2Z1bmN0aW9uIE8oKXt0aGlzLm1lc2g9bnVsbCx0aGlzLm5vcm1hbD1bMCwwLDBdLHRoaXMuc1VuaXQ9WzAsMCwwXSx0aGlzLnRVbml0PVswLDAsMF0sdGhpcy5ibWluPVswLDBdLHRoaXMuYm1heD1bMCwwXSx0aGlzLndpbmRpbmdSdWxlPXIuV0lORElOR19PREQsdGhpcy5kaWN0PW51bGwsdGhpcy5wcT1udWxsLHRoaXMuZXZlbnQ9bnVsbCx0aGlzLnZlcnRleEluZGV4Q291bnRlcj0wLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudENvdW50PTB9Ty5wcm90b3R5cGU9e2RvdF86ZnVuY3Rpb24obyxoKXtyZXR1cm4gb1swXSpoWzBdK29bMV0qaFsxXStvWzJdKmhbMl19LG5vcm1hbGl6ZV86ZnVuY3Rpb24obyl7dmFyIGg9b1swXSpvWzBdK29bMV0qb1sxXStvWzJdKm9bMl07aShoPjApLGg9TWF0aC5zcXJ0KGgpLG9bMF0vPWgsb1sxXS89aCxvWzJdLz1ofSxsb25nQXhpc186ZnVuY3Rpb24obyl7dmFyIGg9MDtyZXR1cm4gTWF0aC5hYnMob1sxXSk+TWF0aC5hYnMob1swXSkmJihoPTEpLE1hdGguYWJzKG9bMl0pPk1hdGguYWJzKG9baF0pJiYoaD0yKSxofSxjb21wdXRlTm9ybWFsXzpmdW5jdGlvbihvKXt2YXIgaCxjLGcsYixFLEEsTD1bMCwwLDBdLE09WzAsMCwwXSxJPVswLDAsMF0sRD1bMCwwLDBdLFI9WzAsMCwwXSxDPVtudWxsLG51bGwsbnVsbF0sQj1bbnVsbCxudWxsLG51bGxdLHo9dGhpcy5tZXNoLnZIZWFkLEs7Zm9yKGg9ei5uZXh0LEs9MDtLPDM7KytLKWI9aC5jb29yZHNbS10sTVtLXT1iLEJbS109aCxMW0tdPWIsQ1tLXT1oO2ZvcihoPXoubmV4dDtoIT09ejtoPWgubmV4dClmb3IoSz0wO0s8MzsrK0spYj1oLmNvb3Jkc1tLXSxiPE1bS10mJihNW0tdPWIsQltLXT1oKSxiPkxbS10mJihMW0tdPWIsQ1tLXT1oKTtpZihLPTAsTFsxXS1NWzFdPkxbMF0tTVswXSYmKEs9MSksTFsyXS1NWzJdPkxbS10tTVtLXSYmKEs9MiksTVtLXT49TFtLXSl7b1swXT0wLG9bMV09MCxvWzJdPTE7cmV0dXJufWZvcihBPTAsYz1CW0tdLGc9Q1tLXSxJWzBdPWMuY29vcmRzWzBdLWcuY29vcmRzWzBdLElbMV09Yy5jb29yZHNbMV0tZy5jb29yZHNbMV0sSVsyXT1jLmNvb3Jkc1syXS1nLmNvb3Jkc1syXSxoPXoubmV4dDtoIT09ejtoPWgubmV4dClEWzBdPWguY29vcmRzWzBdLWcuY29vcmRzWzBdLERbMV09aC5jb29yZHNbMV0tZy5jb29yZHNbMV0sRFsyXT1oLmNvb3Jkc1syXS1nLmNvb3Jkc1syXSxSWzBdPUlbMV0qRFsyXS1JWzJdKkRbMV0sUlsxXT1JWzJdKkRbMF0tSVswXSpEWzJdLFJbMl09SVswXSpEWzFdLUlbMV0qRFswXSxFPVJbMF0qUlswXStSWzFdKlJbMV0rUlsyXSpSWzJdLEU+QSYmKEE9RSxvWzBdPVJbMF0sb1sxXT1SWzFdLG9bMl09UlsyXSk7QTw9MCYmKG9bMF09b1sxXT1vWzJdPTAsb1t0aGlzLmxvbmdBeGlzXyhJKV09MSl9LGNoZWNrT3JpZW50YXRpb25fOmZ1bmN0aW9uKCl7dmFyIG8saCxjPXRoaXMubWVzaC5mSGVhZCxnLGI9dGhpcy5tZXNoLnZIZWFkLEU7Zm9yKG89MCxoPWMubmV4dDtoIT09YztoPWgubmV4dClpZihFPWguYW5FZGdlLCEoRS53aW5kaW5nPD0wKSlkbyBvKz0oRS5Pcmcucy1FLkRzdC5zKSooRS5PcmcudCtFLkRzdC50KSxFPUUuTG5leHQ7d2hpbGUoRSE9PWguYW5FZGdlKTtpZihvPDApe2ZvcihnPWIubmV4dDtnIT09YjtnPWcubmV4dClnLnQ9LWcudDt0aGlzLnRVbml0WzBdPS10aGlzLnRVbml0WzBdLHRoaXMudFVuaXRbMV09LXRoaXMudFVuaXRbMV0sdGhpcy50VW5pdFsyXT0tdGhpcy50VW5pdFsyXX19LHByb2plY3RQb2x5Z29uXzpmdW5jdGlvbigpe3ZhciBvLGg9dGhpcy5tZXNoLnZIZWFkLGM9WzAsMCwwXSxnLGIsRSxBLEw9ITE7Zm9yKGNbMF09dGhpcy5ub3JtYWxbMF0sY1sxXT10aGlzLm5vcm1hbFsxXSxjWzJdPXRoaXMubm9ybWFsWzJdLGNbMF09PT0wJiZjWzFdPT09MCYmY1syXT09PTAmJih0aGlzLmNvbXB1dGVOb3JtYWxfKGMpLEw9ITApLGc9dGhpcy5zVW5pdCxiPXRoaXMudFVuaXQsRT10aGlzLmxvbmdBeGlzXyhjKSxnW0VdPTAsZ1soRSsxKSUzXT0xLGdbKEUrMiklM109MCxiW0VdPTAsYlsoRSsxKSUzXT0wLGJbKEUrMiklM109Y1tFXT4wPzE6LTEsbz1oLm5leHQ7byE9PWg7bz1vLm5leHQpby5zPXRoaXMuZG90XyhvLmNvb3JkcyxnKSxvLnQ9dGhpcy5kb3RfKG8uY29vcmRzLGIpO2ZvcihMJiZ0aGlzLmNoZWNrT3JpZW50YXRpb25fKCksQT0hMCxvPWgubmV4dDtvIT09aDtvPW8ubmV4dClBPyh0aGlzLmJtaW5bMF09dGhpcy5ibWF4WzBdPW8ucyx0aGlzLmJtaW5bMV09dGhpcy5ibWF4WzFdPW8udCxBPSExKTooby5zPHRoaXMuYm1pblswXSYmKHRoaXMuYm1pblswXT1vLnMpLG8ucz50aGlzLmJtYXhbMF0mJih0aGlzLmJtYXhbMF09by5zKSxvLnQ8dGhpcy5ibWluWzFdJiYodGhpcy5ibWluWzFdPW8udCksby50PnRoaXMuYm1heFsxXSYmKHRoaXMuYm1heFsxXT1vLnQpKX0sYWRkV2luZGluZ186ZnVuY3Rpb24obyxoKXtvLndpbmRpbmcrPWgud2luZGluZyxvLlN5bS53aW5kaW5nKz1oLlN5bS53aW5kaW5nfSx0ZXNzZWxsYXRlTW9ub1JlZ2lvbl86ZnVuY3Rpb24obyxoKXt2YXIgYyxnO2ZvcihjPWguYW5FZGdlLGkoYy5MbmV4dCE9PWMmJmMuTG5leHQuTG5leHQhPT1jKTtuLnZlcnRMZXEoYy5Ec3QsYy5PcmcpO2M9Yy5McHJldik7Zm9yKDtuLnZlcnRMZXEoYy5PcmcsYy5Ec3QpO2M9Yy5MbmV4dCk7Zm9yKGc9Yy5McHJldjtjLkxuZXh0IT09ZzspaWYobi52ZXJ0TGVxKGMuRHN0LGcuT3JnKSl7Zm9yKDtnLkxuZXh0IT09YyYmKG4uZWRnZUdvZXNMZWZ0KGcuTG5leHQpfHxuLmVkZ2VTaWduKGcuT3JnLGcuRHN0LGcuTG5leHQuRHN0KTw9MCk7KXt2YXIgYj1vLmNvbm5lY3QoZy5MbmV4dCxnKTtnPWIuU3ltfWc9Zy5McHJldn1lbHNle2Zvcig7Zy5MbmV4dCE9PWMmJihuLmVkZ2VHb2VzUmlnaHQoYy5McHJldil8fG4uZWRnZVNpZ24oYy5Ec3QsYy5PcmcsYy5McHJldi5PcmcpPj0wKTspe3ZhciBiPW8uY29ubmVjdChjLGMuTHByZXYpO2M9Yi5TeW19Yz1jLkxuZXh0fWZvcihpKGcuTG5leHQhPT1jKTtnLkxuZXh0LkxuZXh0IT09Yzspe3ZhciBiPW8uY29ubmVjdChnLkxuZXh0LGcpO2c9Yi5TeW19cmV0dXJuITB9LHRlc3NlbGxhdGVJbnRlcmlvcl86ZnVuY3Rpb24obyl7dmFyIGgsYztmb3IoaD1vLmZIZWFkLm5leHQ7aCE9PW8uZkhlYWQ7aD1jKWlmKGM9aC5uZXh0LGguaW5zaWRlJiYhdGhpcy50ZXNzZWxsYXRlTW9ub1JlZ2lvbl8obyxoKSlyZXR1cm4hMTtyZXR1cm4hMH0sZGlzY2FyZEV4dGVyaW9yXzpmdW5jdGlvbihvKXt2YXIgaCxjO2ZvcihoPW8uZkhlYWQubmV4dDtoIT09by5mSGVhZDtoPWMpYz1oLm5leHQsaC5pbnNpZGV8fG8uemFwRmFjZShoKX0sc2V0V2luZGluZ051bWJlcl86ZnVuY3Rpb24obyxoLGMpe3ZhciBnLGI7Zm9yKGc9by5lSGVhZC5uZXh0O2chPT1vLmVIZWFkO2c9YiliPWcubmV4dCxnLlJmYWNlLmluc2lkZSE9PWcuTGZhY2UuaW5zaWRlP2cud2luZGluZz1nLkxmYWNlLmluc2lkZT9oOi1oOmM/by5kZWxldGUoZyk6Zy53aW5kaW5nPTB9LGdldE5laWdoYm91ckZhY2VfOmZ1bmN0aW9uKG8pe3JldHVybiFvLlJmYWNlfHwhby5SZmFjZS5pbnNpZGU/LTE6by5SZmFjZS5ufSxvdXRwdXRQb2x5bWVzaF86ZnVuY3Rpb24obyxoLGMsZyl7dmFyIGIsRSxBLEw9MCxNPTAsSSxEO2ZvcihjPjMmJm8ubWVyZ2VDb252ZXhGYWNlcyhjKSxiPW8udkhlYWQubmV4dDtiIT09by52SGVhZDtiPWIubmV4dCliLm49LTE7Zm9yKEU9by5mSGVhZC5uZXh0O0UhPT1vLmZIZWFkO0U9RS5uZXh0KWlmKEUubj0tMSwhIUUuaW5zaWRlKXtBPUUuYW5FZGdlLEk9MDtkbyBiPUEuT3JnLGIubj09PS0xJiYoYi5uPU0sTSsrKSxJKyssQT1BLkxuZXh0O3doaWxlKEEhPT1FLmFuRWRnZSk7aShJPD1jKSxFLm49TCwrK0x9Zm9yKHRoaXMuZWxlbWVudENvdW50PUwsaD09PXIuQ09OTkVDVEVEX1BPTFlHT05TJiYoTCo9MiksdGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD1MKmMsdGhpcy52ZXJ0ZXhDb3VudD1NLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9TSpnLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPU0sYj1vLnZIZWFkLm5leHQ7YiE9PW8udkhlYWQ7Yj1iLm5leHQpaWYoYi5uIT09LTEpe3ZhciBSPWIubipnO3RoaXMudmVydGljZXNbUiswXT1iLmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW1IrMV09Yi5jb29yZHNbMV0sZz4yJiYodGhpcy52ZXJ0aWNlc1tSKzJdPWIuY29vcmRzWzJdKSx0aGlzLnZlcnRleEluZGljZXNbYi5uXT1iLmlkeH12YXIgQz0wO2ZvcihFPW8uZkhlYWQubmV4dDtFIT09by5mSGVhZDtFPUUubmV4dClpZihFLmluc2lkZSl7QT1FLmFuRWRnZSxJPTA7ZG8gYj1BLk9yZyx0aGlzLmVsZW1lbnRzW0MrK109Yi5uLEkrKyxBPUEuTG5leHQ7d2hpbGUoQSE9PUUuYW5FZGdlKTtmb3IoRD1JO0Q8YzsrK0QpdGhpcy5lbGVtZW50c1tDKytdPS0xO2lmKGg9PT1yLkNPTk5FQ1RFRF9QT0xZR09OUyl7QT1FLmFuRWRnZTtkbyB0aGlzLmVsZW1lbnRzW0MrK109dGhpcy5nZXROZWlnaGJvdXJGYWNlXyhBKSxBPUEuTG5leHQ7d2hpbGUoQSE9PUUuYW5FZGdlKTtmb3IoRD1JO0Q8YzsrK0QpdGhpcy5lbGVtZW50c1tDKytdPS0xfX19LG91dHB1dENvbnRvdXJzXzpmdW5jdGlvbihvLGgpe3ZhciBjLGcsYixFPTAsQT0wO2Zvcih0aGlzLnZlcnRleENvdW50PTAsdGhpcy5lbGVtZW50Q291bnQ9MCxjPW8uZkhlYWQubmV4dDtjIT09by5mSGVhZDtjPWMubmV4dClpZihjLmluc2lkZSl7Yj1nPWMuYW5FZGdlO2RvIHRoaXMudmVydGV4Q291bnQrKyxnPWcuTG5leHQ7d2hpbGUoZyE9PWIpO3RoaXMuZWxlbWVudENvdW50Kyt9dGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD10aGlzLmVsZW1lbnRDb3VudCoyLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudCpoLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPXRoaXMudmVydGV4Q291bnQ7dmFyIEw9MCxNPTAsST0wO2ZvcihFPTAsYz1vLmZIZWFkLm5leHQ7YyE9PW8uZkhlYWQ7Yz1jLm5leHQpaWYoYy5pbnNpZGUpe0E9MCxiPWc9Yy5hbkVkZ2U7ZG8gdGhpcy52ZXJ0aWNlc1tMKytdPWcuT3JnLmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW0wrK109Zy5PcmcuY29vcmRzWzFdLGg+MiYmKHRoaXMudmVydGljZXNbTCsrXT1nLk9yZy5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tNKytdPWcuT3JnLmlkeCxBKyssZz1nLkxuZXh0O3doaWxlKGchPT1iKTt0aGlzLmVsZW1lbnRzW0krK109RSx0aGlzLmVsZW1lbnRzW0krK109QSxFKz1BfX0sYWRkQ29udG91cjpmdW5jdGlvbihvLGgpe3ZhciBjLGc7Zm9yKHRoaXMubWVzaD09PW51bGwmJih0aGlzLm1lc2g9bmV3IGYpLG88MiYmKG89Miksbz4zJiYobz0zKSxjPW51bGwsZz0wO2c8aC5sZW5ndGg7Zys9byljPT09bnVsbD8oYz10aGlzLm1lc2gubWFrZUVkZ2UoKSx0aGlzLm1lc2guc3BsaWNlKGMsYy5TeW0pKToodGhpcy5tZXNoLnNwbGl0RWRnZShjKSxjPWMuTG5leHQpLGMuT3JnLmNvb3Jkc1swXT1oW2crMF0sYy5PcmcuY29vcmRzWzFdPWhbZysxXSxvPjI/Yy5PcmcuY29vcmRzWzJdPWhbZysyXTpjLk9yZy5jb29yZHNbMl09MCxjLk9yZy5pZHg9dGhpcy52ZXJ0ZXhJbmRleENvdW50ZXIrKyxjLndpbmRpbmc9MSxjLlN5bS53aW5kaW5nPS0xfSx0ZXNzZWxhdGU6ZnVuY3Rpb24obyxoLGMsZyxiKXtpZih0aGlzLnZlcnRpY2VzPVtdLHRoaXMuZWxlbWVudHM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsYiYmKHRoaXMubm9ybWFsWzBdPWJbMF0sdGhpcy5ub3JtYWxbMV09YlsxXSx0aGlzLm5vcm1hbFsyXT1iWzJdKSx0aGlzLndpbmRpbmdSdWxlPW8sZzwyJiYoZz0yKSxnPjMmJihnPTMpLCF0aGlzLm1lc2gpcmV0dXJuITE7dGhpcy5wcm9qZWN0UG9seWdvbl8oKSxtLmNvbXB1dGVJbnRlcmlvcih0aGlzKTt2YXIgRT10aGlzLm1lc2g7cmV0dXJuIGg9PT1yLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMuc2V0V2luZGluZ051bWJlcl8oRSwxLCEwKTp0aGlzLnRlc3NlbGxhdGVJbnRlcmlvcl8oRSksRS5jaGVjaygpLGg9PT1yLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMub3V0cHV0Q29udG91cnNfKEUsZyk6dGhpcy5vdXRwdXRQb2x5bWVzaF8oRSxoLGMsZyksITB9fX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9cjt2YXIgdD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHIoKXtmb3IodmFyIG49e30saT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe3ZhciBhPWFyZ3VtZW50c1tpXTtmb3IodmFyIGwgaW4gYSl0LmNhbGwoYSxsKSYmKG5bbF09YVtsXSl9cmV0dXJuIG59fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImFwcGx5U2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImNyZWF0ZUNsb3VkU2hhZGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJhcHBseUNsb3VkU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIHI9dCg2NCksbj10KDY1KSxpPXQoNjYpLGE9dCg2Nyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGw9U3ltYm9sKCJzaGFkZXJzIik7ZnVuY3Rpb24gcyh5KXt5W2xdPVtdO2ZvcihsZXQgUD0wO1A8MTY7UCsrKXtjb25zdCB4PVtdLG09ISEoUCYxKSxPPSEhKFAmMiksbz0hIShQJjQpLGg9ISEoUCY4KTttJiZ4LnB1c2goIiNkZWZpbmUgVEVYVFVSRSAxIiksTyYmeC5wdXNoKCIjZGVmaW5lIEZJTFRFUiAxIiksbyYmeC5wdXNoKCIjZGVmaW5lIEdSQURJRU5UIDEiKSxoJiZ4LnB1c2goIiNkZWZpbmUgQ0xJUFBBVEggMSIpO2NvbnN0IGM9YCR7eC5qb2luKGAKYCl9CmAsZz1bXTttJiZnLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U2FtcGxlcjsiKSxoJiZnLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IikseVtsXVtQXT1bYytnLmpvaW4oYApgKStuLmRlZmF1bHQsYytyLmRlZmF1bHRdfX1mdW5jdGlvbiBmKHkse2hhc1RleHR1cmU6UD0hMSxoYXNGaWx0ZXI6eD0hMSxoYXNHcmFkaWVudDptPSExLGhhc0NsaXBQYXRoOk89ITF9PXt9KXtjb25zdCBvPVB8eDw8MXxtPDwyfE88PDM7bGV0IGg9eVtsXVtvXTtBcnJheS5pc0FycmF5KGgpJiYoaD15LmNyZWF0ZVByb2dyYW0oLi4uaCkseVtsXVtvXT1oKSx5LnByb2dyYW0hPT1oJiZ5LnVzZVByb2dyYW0oaCx7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pfWNvbnN0IHY9W107ZnVuY3Rpb24gZCh5KXtmb3IobGV0IFA9MDtQPDY0O1ArKyl7Y29uc3QgeD1bXSxtPSEhKFAmMSksTz0hIShQJjIpLG89ISEoUCY0KSxoPSEhKFAmOCksYz0hIShQJjE2KSxnPSEhKFAmMzIpO20mJngucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxPJiZ4LnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxvJiZ4LnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLGgmJngucHVzaCgiI2RlZmluZSBDTE9VRENPTE9SIDEiKSxjJiZ4LnB1c2goIiNkZWZpbmUgQ0xPVURGSUxURVIgMSIpLGcmJngucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3QgYj1gJHt4LmpvaW4oYApgKX0KYCxFPVtdO2lmKG0pe0UucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpO2ZvcihsZXQgQT0wO0E8MTI7QSsrKUUucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhGcmFtZSR7QX07YCl9ZyYmRS5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X2NsaXBTYW1wbGVyOyIpLHZbUF09W2IrRS5qb2luKGAKYCkrYS5kZWZhdWx0LGIraS5kZWZhdWx0XX19ZnVuY3Rpb24gcCh5LHtoYXNUZXh0dXJlOlA9ITEsaGFzRmlsdGVyOng9ITEsaGFzR3JhZGllbnQ6bT0hMSxoYXNDbG91ZENvbG9yOk89ITEsaGFzQ2xvdWRGaWx0ZXI6bz0hMSxoYXNDbGlwUGF0aDpoPSExfT17fSl7Y29uc3QgYz1QfHg8PDF8bTw8MnxPPDwzfG88PDR8aDw8NTtsZXQgZz12W2NdO0FycmF5LmlzQXJyYXkoZykmJihnPXkuY3JlYXRlUHJvZ3JhbSguLi5nKSx2W2NdPWcpLHkucHJvZ3JhbSE9PWcmJnkudXNlUHJvZ3JhbShnLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZmlsbENsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9zdHJva2VDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZnJhbWVJbmRleDp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiExfX0pfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX1BvaW50U2l6ZSA9IDEuMDsKCiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwogIHZDb2xvciA9IGFfY29sb3I7CgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgp9YH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKCiNpZmRlZiBURVhUVVJFCnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CnVuaWZvcm0gZmxvYXQgdV9jb2xvclN0ZXBzWzQwXTsKdW5pZm9ybSBpbnQgdV9ncmFkaWVudFR5cGU7Ci8vIHVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIHZlYzQgY29sb3IgPSB2Q29sb3I7CiAgZmxvYXQgb3BhY2l0eSA9IGFicyhmbGFnQmFja2dyb3VuZCk7CgojaWZkZWYgR1JBRElFTlQKICBpZih1X2dyYWRpZW50VHlwZSA+IDAgJiYgZmxhZ0JhY2tncm91bmQgPiAwLjAgfHwgdV9ncmFkaWVudFR5cGUgPT0gMCAmJiBmbGFnQmFja2dyb3VuZCA8PSAwLjApIHsKICAgIGdyYWRpZW50KGNvbG9yLCB2R3JhZGllbnRWZWN0b3IxLCB2R3JhZGllbnRWZWN0b3IyLCB1X2NvbG9yU3RlcHMpOwogIH0KI2VuZGlmCgogIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgIGNvbG9yLmEgKj0gb3BhY2l0eTsKICB9CgojaWZkZWYgVEVYVFVSRQogIGlmKGZsYWdCYWNrZ3JvdW5kID4gMC4wKSB7CiAgICB2ZWMzIHRleENvb3JkID0gdlRleHR1cmVDb29yZDsKCiAgICBpZih0ZXhDb29yZC56ID09IDEuMCkgewogICAgICB0ZXhDb29yZCA9IGZyYWN0KHRleENvb3JkKTsKICAgIH0KCiAgICBpZih0ZXhDb29yZC54IDw9IDEuMCAmJiB0ZXhDb29yZC54ID49IDAuMAogICAgICAmJiB0ZXhDb29yZC55IDw9IDEuMCAmJiB0ZXhDb29yZC55ID49IDAuMCkgewogICAgICBpZih2U291cmNlUmVjdC56ID4gMC4wKSB7CiAgICAgICAgdGV4Q29vcmQueCA9IHZTb3VyY2VSZWN0LnggKyB0ZXhDb29yZC54ICogdlNvdXJjZVJlY3QuejsKICAgICAgICB0ZXhDb29yZC55ID0gMS4wIC0gKHZTb3VyY2VSZWN0LnkgKyAoMS4wIC0gdGV4Q29vcmQueSkgKiB2U291cmNlUmVjdC53KTsKICAgICAgfQogICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICB9CiAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAvLyBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNvbG9yLmEpOwogICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgfQogIH0KI2VuZGlmCgojaWZkZWYgRklMVEVSCiAgaWYodV9maWx0ZXJGbGFnID4gMCkgewogICAgdHJhbnNmb3JtQ29sb3IoY29sb3IsIHVfY29sb3JNYXRyaXgpOwogIH0KI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24odSxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CmF0dHJpYnV0ZSB2ZWMzIGFfdHJhbnNmb3JtMDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0xOwp1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7CgojaWZkZWYgVEVYVFVSRQphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CmF0dHJpYnV0ZSBmbG9hdCBhX2ZyYW1lSW5kZXg7CnZhcnlpbmcgZmxvYXQgZnJhbWVJbmRleDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMDsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMTsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMzsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkNDsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIENMT1VEQ09MT1IKYXR0cmlidXRlIHZlYzQgYV9maWxsQ2xvdWRDb2xvcjsKYXR0cmlidXRlIHZlYzQgYV9zdHJva2VDbG91ZENvbG9yOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICBtYXQzIG1vZGVsTWF0cml4ID0gbWF0MygKICAgIGFfdHJhbnNmb3JtMC54LCBhX3RyYW5zZm9ybTEueCwgMCwgCiAgICBhX3RyYW5zZm9ybTAueSwgYV90cmFuc2Zvcm0xLnksIDAsCiAgICBhX3RyYW5zZm9ybTAueiwgYV90cmFuc2Zvcm0xLnosIDEKICApOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOwoKI2lmZGVmIEdSQURJRU5UCiAgdmVjMyB2ZzEgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzBdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzFdLCAxLjApOwogIHZlYzMgdmcyID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclszXSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls0XSwgMS4wKTsKICBmbG9hdCBoID0gdV9yZXNvbHV0aW9uLnk7CiAgdmcxLnkgPSBoIC0gdmcxLnk7CiAgdmcyLnkgPSBoIC0gdmcyLnk7CiAgdkdyYWRpZW50VmVjdG9yMSA9IHZlYzModmcxLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzJdKTsKICB2R3JhZGllbnRWZWN0b3IyID0gdmVjMyh2ZzIueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNV0pOwojZW5kaWYKICAKICBmbGFnQmFja2dyb3VuZCA9IGFfdmVydGV4UG9zaXRpb24uejsKCiNpZmRlZiBDTE9VRENPTE9SCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLmEpOwogIH0gZWxzZSB7CiAgICB2Q29sb3IgPSBtaXgoYV9jb2xvciwgYV9zdHJva2VDbG91ZENvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IuYSk7CiAgfQojZWxzZQogIHZDb2xvciA9IGFfY29sb3I7CiNlbmRpZgoKI2lmZGVmIFRFWFRVUkUKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CiAgZnJhbWVJbmRleCA9IGFfZnJhbWVJbmRleDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgY29sb3JDbG91ZDAgPSBhX2NvbG9yQ2xvdWQwOwogIGNvbG9yQ2xvdWQxID0gYV9jb2xvckNsb3VkMTsKICBjb2xvckNsb3VkMiA9IGFfY29sb3JDbG91ZDI7CiAgY29sb3JDbG91ZDMgPSBhX2NvbG9yQ2xvdWQzOwogIGNvbG9yQ2xvdWQ0ID0gYV9jb2xvckNsb3VkNDsKI2VuZGlmCn1gfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgRklMVEVSCnVuaWZvcm0gaW50IHVfZmlsdGVyRmxhZzsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yTWF0cml4WzIwXTsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKdm9pZCB0cmFuc2Zvcm1Db2xvcihpbm91dCB2ZWM0IGNvbG9yLCBpbiBmbG9hdCBjb2xvck1hdHJpeFsyMF0pIHsKICBmbG9hdCByID0gY29sb3IuciwgZyA9IGNvbG9yLmcsIGIgPSBjb2xvci5iLCBhID0gY29sb3IuYTsKICBjb2xvclswXSA9IGNvbG9yTWF0cml4WzBdICogciArIGNvbG9yTWF0cml4WzFdICogZyArIGNvbG9yTWF0cml4WzJdICogYiArIGNvbG9yTWF0cml4WzNdICogYSArIGNvbG9yTWF0cml4WzRdOwogIGNvbG9yWzFdID0gY29sb3JNYXRyaXhbNV0gKiByICsgY29sb3JNYXRyaXhbNl0gKiBnICsgY29sb3JNYXRyaXhbN10gKiBiICsgY29sb3JNYXRyaXhbOF0gKiBhICsgY29sb3JNYXRyaXhbOV07CiAgY29sb3JbMl0gPSBjb2xvck1hdHJpeFsxMF0gKiByICsgY29sb3JNYXRyaXhbMTFdICogZyArIGNvbG9yTWF0cml4WzEyXSAqIGIgKyBjb2xvck1hdHJpeFsxM10gKiBhICsgY29sb3JNYXRyaXhbMTRdOwogIGNvbG9yWzNdID0gY29sb3JNYXRyaXhbMTVdICogciArIGNvbG9yTWF0cml4WzE2XSAqIGcgKyBjb2xvck1hdHJpeFsxN10gKiBiICsgY29sb3JNYXRyaXhbMThdICogYSArIGNvbG9yTWF0cml4WzE5XTsKfQoKI2lmZGVmIENMT1VERklMVEVSCnZvaWQgYnVpbGRDbG91ZENvbG9yKGlub3V0IGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdKSB7CiAgY29sb3JDbG91ZE1hdHJpeFswXSA9IGNvbG9yQ2xvdWQwWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMV0gPSBjb2xvckNsb3VkMVswXTsKICBjb2xvckNsb3VkTWF0cml4WzJdID0gY29sb3JDbG91ZDJbMF07CiAgY29sb3JDbG91ZE1hdHJpeFszXSA9IGNvbG9yQ2xvdWQzWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNF0gPSBjb2xvckNsb3VkNFswXTsKCiAgY29sb3JDbG91ZE1hdHJpeFs1XSA9IGNvbG9yQ2xvdWQwWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNl0gPSBjb2xvckNsb3VkMVsxXTsKICBjb2xvckNsb3VkTWF0cml4WzddID0gY29sb3JDbG91ZDJbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs4XSA9IGNvbG9yQ2xvdWQzWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbOV0gPSBjb2xvckNsb3VkNFsxXTsKCiAgY29sb3JDbG91ZE1hdHJpeFsxMF0gPSBjb2xvckNsb3VkMFsyXTsKICBjb2xvckNsb3VkTWF0cml4WzExXSA9IGNvbG9yQ2xvdWQxWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTJdID0gY29sb3JDbG91ZDJbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxM10gPSBjb2xvckNsb3VkM1syXTsKICBjb2xvckNsb3VkTWF0cml4WzE0XSA9IGNvbG9yQ2xvdWQ0WzJdOwoKICBjb2xvckNsb3VkTWF0cml4WzE1XSA9IGNvbG9yQ2xvdWQwWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTZdID0gY29sb3JDbG91ZDFbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxN10gPSBjb2xvckNsb3VkMlszXTsKICBjb2xvckNsb3VkTWF0cml4WzE4XSA9IGNvbG9yQ2xvdWQzWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTldID0gY29sb3JDbG91ZDRbM107Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIGlmKGZyYW1lSW5kZXggPCAwLjApIHsKICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW50IGluZGV4ID0gaW50KGZsb29yKGNsYW1wKDAuMCwgMTEuMCwgZnJhbWVJbmRleCkpKTsKICAgICAgICB2ZWM0IHRleENvbG9yOwogICAgICAgIGlmKGluZGV4ID09IDApIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTIsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDMpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUzLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA0KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTUsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDYpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU2LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA3KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNywgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTgsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDkpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU5LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTEwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTEsIHRleENvb3JkLnh5KTsKICAgICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgICAgdGV4Q29sb3IuYSAqPSBvcGFjaXR5OwogICAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICAgIH0KICAgICAgICAvLyBjb2xvciA9IG1peChjb2xvciwgdGV4Q29sb3IsIHRleENvbG9yLmEpOwogICAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjbGFtcChjb2xvci5hIC8gbWF4KDAuMDAwMSwgdGV4Q29sb3IuYSksIDAuMCwgMS4wKSk7CiAgICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgICB9CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgogIGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdOwogIGJ1aWxkQ2xvdWRDb2xvcihjb2xvckNsb3VkTWF0cml4KTsKICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgY29sb3JDbG91ZE1hdHJpeCk7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgZmxvYXQgY2xpcCA9IHRleHR1cmUyRCh1X2NsaXBTYW1wbGVyLCB2Q2xpcFVWKS5yOwogIGNvbG9yICo9IGNsaXA7CiNlbmRpZgoKICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsKfWB9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKHIsbil7dC5kKGUsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKCl7aWYodHlwZW9mIHBlcmZvcm1hbmNlPCJ1IiYmcGVyZm9ybWFuY2Uubm93KXJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtpZih0eXBlb2YgcjwidSImJnIuaHJ0aW1lKXtjb25zdFtzLGZdPXIuaHJ0aW1lKCk7cmV0dXJuIHMqMWUzK2YqMWUtNn1yZXR1cm4gRGF0ZS5ub3c/RGF0ZS5ub3coKTpuZXcgRGF0ZSgpLmdldFRpbWUoKX1sZXQgYSxsO3R5cGVvZiBuPCJ1IiYmdHlwZW9mIG4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lPT0iZnVuY3Rpb24iPyhhPW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lLGw9bi5jYW5jZWxBbmltYXRpb25GcmFtZSk6KGE9ZnVuY3Rpb24ocyl7cmV0dXJuIHNldFRpbWVvdXQoKCk9PntzKGkoKSl9LDE2KX0sbD1mdW5jdGlvbihzKXtyZXR1cm4gY2xlYXJUaW1lb3V0KHMpfSl9KS5jYWxsKHRoaXMsdCg2OSksdCgyMikpfSxmdW5jdGlvbih1LGUpe3ZhciB0PXUuZXhwb3J0cz17fSxyLG47ZnVuY3Rpb24gaSgpe3Rocm93IG5ldyBFcnJvcigic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfWZ1bmN0aW9uIGEoKXt0aHJvdyBuZXcgRXJyb3IoImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfShmdW5jdGlvbigpe3RyeXt0eXBlb2Ygc2V0VGltZW91dD09ImZ1bmN0aW9uIj9yPXNldFRpbWVvdXQ6cj1pfWNhdGNoe3I9aX10cnl7dHlwZW9mIGNsZWFyVGltZW91dD09ImZ1bmN0aW9uIj9uPWNsZWFyVGltZW91dDpuPWF9Y2F0Y2h7bj1hfX0pKCk7ZnVuY3Rpb24gbChPKXtpZihyPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dChPLDApO2lmKChyPT09aXx8IXIpJiZzZXRUaW1lb3V0KXJldHVybiByPXNldFRpbWVvdXQsc2V0VGltZW91dChPLDApO3RyeXtyZXR1cm4gcihPLDApfWNhdGNoe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsTywwKX1jYXRjaHtyZXR1cm4gci5jYWxsKHRoaXMsTywwKX19fWZ1bmN0aW9uIHMoTyl7aWYobj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KE8pO2lmKChuPT09YXx8IW4pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG49Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChPKTt0cnl7cmV0dXJuIG4oTyl9Y2F0Y2h7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxPKX1jYXRjaHtyZXR1cm4gbi5jYWxsKHRoaXMsTyl9fX12YXIgZj1bXSx2PSExLGQscD0tMTtmdW5jdGlvbiB5KCl7IXZ8fCFkfHwodj0hMSxkLmxlbmd0aD9mPWQuY29uY2F0KGYpOnA9LTEsZi5sZW5ndGgmJlAoKSl9ZnVuY3Rpb24gUCgpe2lmKCF2KXt2YXIgTz1sKHkpO3Y9ITA7Zm9yKHZhciBvPWYubGVuZ3RoO287KXtmb3IoZD1mLGY9W107KytwPG87KWQmJmRbcF0ucnVuKCk7cD0tMSxvPWYubGVuZ3RofWQ9bnVsbCx2PSExLHMoTyl9fXQubmV4dFRpY2s9ZnVuY3Rpb24oTyl7dmFyIG89bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgaD0xO2g8YXJndW1lbnRzLmxlbmd0aDtoKyspb1toLTFdPWFyZ3VtZW50c1toXTtmLnB1c2gobmV3IHgoTyxvKSksZi5sZW5ndGg9PT0xJiYhdiYmbChQKX07ZnVuY3Rpb24geChPLG8pe3RoaXMuZnVuPU8sdGhpcy5hcnJheT1vfXgucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LHQudGl0bGU9ImJyb3dzZXIiLHQuYnJvd3Nlcj0hMCx0LmVudj17fSx0LmFyZ3Y9W10sdC52ZXJzaW9uPSIiLHQudmVyc2lvbnM9e307ZnVuY3Rpb24gbSgpe310Lm9uPW0sdC5hZGRMaXN0ZW5lcj1tLHQub25jZT1tLHQub2ZmPW0sdC5yZW1vdmVMaXN0ZW5lcj1tLHQucmVtb3ZlQWxsTGlzdGVuZXJzPW0sdC5lbWl0PW0sdC5wcmVwZW5kTGlzdGVuZXI9bSx0LnByZXBlbmRPbmNlTGlzdGVuZXI9bSx0Lmxpc3RlbmVycz1mdW5jdGlvbihPKXtyZXR1cm5bXX0sdC5iaW5kaW5nPWZ1bmN0aW9uKE8pe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm4iLyJ9LHQuY2hkaXI9ZnVuY3Rpb24oTyl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pO3ZhciByPXQoMSksbj10KDcxKSxpPXQoNzMpLGE9dCgyMTMpLGw9dCgyMTQpLHM9dCgyMTUpLGY9dCgyMTYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB2KEwsTSl7dmFyIEk9T2JqZWN0LmtleXMoTCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhMKTtNJiYoRD1ELmZpbHRlcihmdW5jdGlvbihSKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihMLFIpLmVudW1lcmFibGV9KSksSS5wdXNoLmFwcGx5KEksRCl9cmV0dXJuIEl9ZnVuY3Rpb24gZChMKXtmb3IodmFyIE09MTtNPGFyZ3VtZW50cy5sZW5ndGg7TSsrKXt2YXIgST1hcmd1bWVudHNbTV0hPW51bGw/YXJndW1lbnRzW01dOnt9O00lMj92KE9iamVjdChJKSwhMCkuZm9yRWFjaChmdW5jdGlvbihEKXtwKEwsRCxJW0RdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEwsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoSSkpOnYoT2JqZWN0KEkpKS5mb3JFYWNoKGZ1bmN0aW9uKEQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShMLEQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihJLEQpKX0pfXJldHVybiBMfWZ1bmN0aW9uIHAoTCxNLEkpe3JldHVybiBNIGluIEw/T2JqZWN0LmRlZmluZVByb3BlcnR5KEwsTSx7dmFsdWU6SSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOkxbTV09SSxMfWNvbnN0IHk9U3ltYm9sLmZvcigic3ByaXRlanNfY2hhbmdlZEF0dHJzIiksUD1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIikseD1TeW1ib2woInJlc29sdXRpb24iKSxtPVN5bWJvbCgiYW5pbWF0aW9ucyIpLE89U3ltYm9sKCJldmVudExpc3RlbmVycyIpLG89U3ltYm9sKCJjYXB0dXJlRXZlbnRMaXN0ZW5lcnMiKSxoPVN5bWJvbCgiZmlsdGVycyIpLGM9U3ltYm9sKCJkaXNwbGF5IiksZz1TeW1ib2woInByb2dyYW0iKSxiPVN5bWJvbCgic2hhZGVyQXR0cnMiKSxFPVN5bWJvbCgidW5pZm9ybXMiKTtjbGFzcyBBe2NvbnN0cnVjdG9yKE09e30pe3RoaXMuYXR0cmlidXRlcz1uZXcgdGhpcy5jb25zdHJ1Y3Rvci5BdHRyKHRoaXMpLHRoaXNbeF09e3dpZHRoOjMwMCxoZWlnaHQ6MTUwfSxPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxNKSx0aGlzW21dPW5ldyBTZXQsdGhpc1tPXT17fSx0aGlzW29dPXt9fWdldCBhbmNlc3RvcnMoKXtsZXQgTT10aGlzLnBhcmVudDtjb25zdCBJPVtdO2Zvcig7TTspSS5wdXNoKE0pLE09TS5wYXJlbnQ7cmV0dXJuIEl9Z2V0IGFuaW1hdGlvbnMoKXtyZXR1cm4gdGhpc1ttXX1nZXQgZmlsdGVycygpe3JldHVybiB0aGlzW2hdfHx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZmlsdGVyc31nZXQgaXNWaXNpYmxlKCl7cmV0dXJuITF9Z2V0IGxheWVyKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50LmxheWVyOm51bGx9Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3QgTT10aGlzLnRyYW5zZm9ybU1hdHJpeCx7eDpJLHk6RH09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBNWzRdKz1JLE1bNV0rPUQsTX1nZXQgb3BhY2l0eSgpe2xldCBNPXRoaXMuYXR0cmlidXRlcy5vcGFjaXR5O3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3BhY2l0eSE9bnVsbCYmKE0qPXRoaXMucGFyZW50Lm9wYWNpdHkpLE19Z2V0IHBhcmVudE5vZGUoKXtyZXR1cm4gdGhpcy5wYXJlbnR9Z2V0IG5leHRTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgxKX1nZXQgcHJldmlvdXNTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgtMSl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1tnXX1nZXQgcmVuZGVyZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQucmVuZGVyZXI6bnVsbH1nZXQgcmVuZGVyTWF0cml4KCl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4KXJldHVybiB0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg7bGV0IE09dGhpcy5sb2NhbE1hdHJpeDtjb25zdCBJPXRoaXMucGFyZW50O2lmKEkpe2NvbnN0IEQ9SS5fX2NhY2hlUmVuZGVyTWF0cml4fHxJLnJlbmRlck1hdHJpeDtEJiYoTT1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELE0pKX1yZXR1cm4gTX1nZXQgd29ybGRTY2FsaW5nKCl7Y29uc3QgTT10aGlzLnJlbmRlck1hdHJpeDtyZXR1cm5bTWF0aC5oeXBvdChNWzBdLE1bMV0pLE1hdGguaHlwb3QoTVsyXSxNWzNdKV19Z2V0IHdvcmxkUm90YXRpb24oKXtjb25zdCBNPXRoaXMucmVuZGVyTWF0cml4O3JldHVybiBNYXRoLmF0YW4yKE1bMV0sTVszXSl9Z2V0IHdvcmxkUG9zaXRpb24oKXtjb25zdCBNPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltNWzRdLE1bNV1dfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW0VdfWdldCBjbGFzc05hbWUoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZX1zZXQgY2xhc3NOYW1lKE0pe3RoaXMuYXR0cmlidXRlcy5jbGFzc05hbWU9TX1nZXQgaWQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmlkfXNldCBpZChNKXt0aGlzLmF0dHJpYnV0ZXMuaWQ9TX1nZXQgbmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMubmFtZX1zZXQgbmFtZShNKXt0aGlzLmF0dHJpYnV0ZXMubmFtZT1NfWdldCB6SW5kZXgoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnpJbmRleH1zZXQgekluZGV4KE0pe3RoaXMuYXR0cmlidXRlcy56SW5kZXg9TX1nZXQgbWVzaCgpe3JldHVybiBudWxsfWdldCBzaGFkZXJBdHRycygpe3JldHVybiB0aGlzW2JdfHx7fX1hY3RpdmF0ZUFuaW1hdGlvbnMoKXtjb25zdCBNPXRoaXMubGF5ZXI7aWYoTSl7Y29uc3QgST10aGlzW21dO0kuZm9yRWFjaChSPT57Ui5iYXNlVGltZWxpbmU9TS50aW1lbGluZSxSLnBsYXkoKSxSLmZpbmlzaGVkLnRoZW4oKCk9PntJLmRlbGV0ZShSKX0pfSk7Y29uc3QgRD10aGlzLmNoaWxkcmVuO0QmJkQuZm9yRWFjaChSPT57Ui5hY3RpdmF0ZUFuaW1hdGlvbnMmJlIuYWN0aXZhdGVBbmltYXRpb25zKCl9KX19YWRkRXZlbnRMaXN0ZW5lcihNLEksRD17fSl7TT09PSJtb3VzZXdoZWVsIiYmKE09IndoZWVsIiksdHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0e2NhcHR1cmU6UixvbmNlOkN9PUQsQj1SP286TztyZXR1cm4gdGhpc1tCXVtNXT10aGlzW0JdW01dfHxbXSx0aGlzW0JdW01dLnB1c2goe2xpc3RlbmVyOkksb25jZTpDfSksdGhpc31hbmltYXRlKE0sSSl7Y29uc3QgRD1uZXcgaS5kZWZhdWx0KHRoaXMsTSxJKTtyZXR1cm4gdGhpcy5lZmZlY3RzJiZELmFwcGx5RWZmZWN0cyh0aGlzLmVmZmVjdHMpLHRoaXMubGF5ZXImJihELmJhc2VUaW1lbGluZT10aGlzLmxheWVyLnRpbWVsaW5lLEQucGxheSgpLEQuZmluaXNoZWQudGhlbigoKT0+e3RoaXNbbV0uZGVsZXRlKEQpfSkpLHRoaXNbbV0uYWRkKEQpLER9YXR0ciguLi5NKXtpZihNLmxlbmd0aD09PTApcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tQXTtpZihNLmxlbmd0aD4xKXtsZXRbSSxEXT1NO3JldHVybiB0eXBlb2YgRD09ImZ1bmN0aW9uIiYmKEQ9RCh0aGlzLmF0dHIoSSkpKSx0aGlzLnNldEF0dHJpYnV0ZShJLEQpLHRoaXN9cmV0dXJuIHR5cGVvZiBNWzBdPT0ic3RyaW5nIj90aGlzLmdldEF0dHJpYnV0ZShNWzBdKTooT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsTVswXSksdGhpcyl9Y2xvbmVOb2RlKCl7Y29uc3QgTT1uZXcgdGhpcy5jb25zdHJ1Y3RvcixJPXRoaXMuYXR0cmlidXRlc1t5XTtyZXR1cm4gTS5hdHRyKEkpLE19Y29ubmVjdChNLEkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYXJlbnQiLHt2YWx1ZTpNLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6T3JkZXIiLHt2YWx1ZTpJLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE0udGltZWxpbmUmJnRoaXMuYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5zZXRSZXNvbHV0aW9uKE0uZ2V0UmVzb2x1dGlvbigpKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhcHBlbmQiLGRldGFpbDp7cGFyZW50Ok0sek9yZGVyOkl9fSl9Y29udGFpbnMoTSl7Zm9yKDtNJiZ0aGlzIT09TTspTT1NLnBhcmVudDtyZXR1cm4hIU19ZGVhY3RpdmF0ZUFuaW1hdGlvbnMoKXt0aGlzW21dLmZvckVhY2goST0+SS5jYW5jZWwoKSk7Y29uc3QgTT10aGlzLmNoaWxkcmVuO00mJk0uZm9yRWFjaChJPT57SS5kZWFjdGl2YXRlQW5pbWF0aW9ucyYmSS5kZWFjdGl2YXRlQW5pbWF0aW9ucygpfSl9ZGlzY29ubmVjdCgpe2NvbnN0e3BhcmVudDpNLHpPcmRlcjpJfT10aGlzO2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXIsdGhpcy5kZWFjdGl2YXRlQW5pbWF0aW9ucygpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVtb3ZlIixkZXRhaWw6e3BhcmVudDpNLHpPcmRlcjpJfX0pLE0mJk0uZm9yY2VVcGRhdGUoKX1kaXNwYXRjaEV2ZW50KE0pe00gaW5zdGFuY2VvZiBsLmRlZmF1bHR8fChNPW5ldyBsLmRlZmF1bHQoTSkpLE0udGFyZ2V0PXRoaXM7bGV0IEk9TS50eXBlO0k9PT0ibW91c2V3aGVlbCImJihJPSJ3aGVlbCIpO2NvbnN0IEQ9W3RoaXNdO2xldCBSPXRoaXMucGFyZW50O2Zvcig7TS5idWJibGVzJiZSOylELnB1c2goUiksUj1SLnBhcmVudDtmb3IobGV0IEM9RC5sZW5ndGgtMTtDPj0wO0MtLSl7Y29uc3QgQj1EW0NdLHo9QltvXSYmQltvXVtJXTtpZih6JiZ6Lmxlbmd0aCYmKE0uY3VycmVudFRhcmdldD1CLHouZm9yRWFjaCgoe2xpc3RlbmVyOkssb25jZTpRfSk9PntLLmNhbGwodGhpcyxNKSxRJiZELnJlbW92ZUV2ZW50TGlzdGVuZXIoSyl9KSxkZWxldGUgTS5jdXJyZW50VGFyZ2V0KSwhTS5idWJibGVzJiZNLmNhbmNlbEJ1YmJsZSlicmVha31pZighTS5jYW5jZWxCdWJibGUpZm9yKGxldCBDPTA7QzxELmxlbmd0aDtDKyspe2NvbnN0IEI9RFtDXSx6PUJbT10mJkJbT11bSV07aWYoeiYmei5sZW5ndGgmJihNLmN1cnJlbnRUYXJnZXQ9Qix6LmZvckVhY2goKHtsaXN0ZW5lcjpLLG9uY2U6UX0pPT57Sy5jYWxsKHRoaXMsTSksUSYmRC5yZW1vdmVFdmVudExpc3RlbmVyKEspfSksZGVsZXRlIE0uY3VycmVudFRhcmdldCksIU0uYnViYmxlc3x8TS5jYW5jZWxCdWJibGUpYnJlYWt9fWRpc3BhdGNoUG9pbnRlckV2ZW50KE0pe2NvbnN0e2xheWVyWDpJLGxheWVyWTpEfT1NO3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oSSxEKT8odGhpcy5kaXNwYXRjaEV2ZW50KE0pLCEwKTohMX1kcmF3KE09W10pe2NvbnN0IEk9dGhpcy5tZXNoO2lmKEkpe2lmKE9iamVjdChzLmFwcGx5RmlsdGVycykoSSx0aGlzLmZpbHRlcnMpLE0ucHVzaChJKSx0aGlzW2ddKXtJLnNldFByb2dyYW0odGhpc1tnXSk7Y29uc3QgRD10aGlzW2JdO0QmJk9iamVjdC5lbnRyaWVzKEQpLmZvckVhY2goKFtDLEJdKT0+e0kuc2V0QXR0cmlidXRlKEMsQil9KTtjb25zdCBSPXRoaXNbRV07aWYodGhpc1tFXSl7Y29uc3QgQz17fTtPYmplY3QuZW50cmllcyhSKS5mb3JFYWNoKChbQix6XSk9Pnt0eXBlb2Ygej09ImZ1bmN0aW9uIiYmKHo9eih0aGlzLEIpKSxDW0JdPXp9KSxJLnNldFVuaWZvcm1zKEMpfX1PYmplY3QoZi5kZWZhdWx0KSh0aGlzLEkpfXJldHVybiBNfWZvcmNlVXBkYXRlKCl7dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmZvcmNlVXBkYXRlKCl9Z2V0QXR0cmlidXRlKE0pe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbTV19Z2V0TGlzdGVuZXJzKE0se2NhcHR1cmU6ST0hMX09e30pe3JldHVyblsuLi50aGlzW0k/bzpPXVtNXXx8W11dfWdldE5vZGVOZWFyQnkoTT0xKXtpZighdGhpcy5wYXJlbnQpcmV0dXJuIG51bGw7aWYoTT09PTApcmV0dXJuIHRoaXM7Y29uc3QgST10aGlzLnBhcmVudC5jaGlsZHJlbixEPUkuaW5kZXhPZih0aGlzKTtyZXR1cm4gSVtEK01dfWdldFdvcmxkUG9zaXRpb24oTSxJKXtjb25zdCBEPXRoaXMucmVuZGVyTWF0cml4LFI9TSpEWzBdK0kqRFsyXStEWzRdLEM9TSpEWzFdK0kqRFszXStEWzVdO3JldHVybltSLENdfWdldE9mZnNldFBvc2l0aW9uKE0sSSl7Y29uc3QgRD1yLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpcy5yZW5kZXJNYXRyaXgpLFI9TSpEWzBdK0kqRFsyXStEWzRdLEM9TSpEWzFdK0kqRFszXStEWzVdO3JldHVybltSLENdfWdldFJlc29sdXRpb24oKXtyZXR1cm4gZCh7fSx0aGlzW3hdKX1pc1BvaW50Q29sbGlzaW9uKE0sSSl7aWYoIXRoaXMubWVzaClyZXR1cm4hMTtjb25zdCBEPXRoaXMuYXR0cmlidXRlcy5wb2ludGVyRXZlbnRzO2lmKEQ9PT0ibm9uZSJ8fEQhPT0iYWxsIiYmIXRoaXMuaXNWaXNpYmxlKXJldHVybiExO2xldCBSPSJib3RoIjtyZXR1cm4gRD09PSJ2aXNpYmxlRmlsbCImJihSPSJmaWxsIiksRD09PSJ2aXNpYmxlU3Ryb2tlIiYmKFI9InN0cm9rZSIpLHRoaXMubWVzaC5pc1BvaW50Q29sbGlzaW9uKE0sSSxSKX1vblByb3BlcnR5Q2hhbmdlKE0sSSxEKXtNIT09ImlkIiYmTSE9PSJuYW1lIiYmTSE9PSJjbGFzc05hbWUiJiZNIT09InBvaW50ZXJFdmVudHMiJiZNIT09InBhc3NFdmVudHMiJiZ0aGlzLmZvcmNlVXBkYXRlKCksTT09PSJmaWx0ZXIiJiYodGhpc1toXT1PYmplY3Qocy5wYXJzZUZpbHRlclN0cmluZykoSSkpLE09PT0iekluZGV4IiYmdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlb3JkZXIoKX1zZXRBdHRyaWJ1dGUoTSxJKXtNPT09ImF0dHJzIiYmdGhpcy5hdHRyKEkpLHRoaXMuYXR0cmlidXRlc1tNXT1JfXNldE1vdXNlQ2FwdHVyZSgpe3RoaXMubGF5ZXImJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD10aGlzKX1zZXRQcm9ncmFtKE0pe3RoaXNbZ109TSx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0U2hhZGVyQXR0cmlidXRlKE0sSSl7dGhpc1tiXT10aGlzW2JdfHx7fSx0aGlzW2JdW01dPUksdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFVuaWZvcm1zKE0pe3RoaXNbRV09dGhpc1tFXXx8e30sT2JqZWN0LmFzc2lnbih0aGlzW0VdLE0pLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpNLGhlaWdodDpJfSl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpc1t4XTsoRCE9PU18fFIhPT1JKSYmKHRoaXNbeF09e3dpZHRoOk0saGVpZ2h0Okl9LHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc29sdXRpb25jaGFuZ2UiLGRldGFpbDp7d2lkdGg6TSxoZWlnaHQ6SX19KSl9c2hvdygpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiJiYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9dGhpc1tjXXx8IiIpfWhpZGUoKXt0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSE9PSJub25lIiYmKHRoaXNbY109dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXksdGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9Im5vbmUiKX1yZWxlYXNlTW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmdGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9PT10aGlzJiYodGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbCl9cmVtb3ZlKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZD8odGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksITApOiExfXJlbW92ZUFsbExpc3RlbmVycyhNLEk9e30pe3R5cGVvZiBJPT0iYm9vbGVhbiImJihJPXtjYXB0dXJlOkl9KTtjb25zdCBSPUkuY2FwdHVyZT9vOk87cmV0dXJuIHRoaXNbUl1bTV0mJih0aGlzW1JdW01dPVtdKSx0aGlzfXJlbW92ZUF0dHJpYnV0ZShNKXt0aGlzLnNldEF0dHJpYnV0ZShNLG51bGwpfXJlbW92ZUV2ZW50TGlzdGVuZXIoTSxJLEQ9e30pe3R5cGVvZiBEPT0iYm9vbGVhbiImJihEPXtjYXB0dXJlOkR9KTtjb25zdCBDPUQuY2FwdHVyZT9vOk87aWYodGhpc1tDXVtNXSl7Y29uc3QgQj10aGlzW0NdW01dO2lmKEIpZm9yKGxldCB6PTA7ejxCLmxlbmd0aDt6Kyspe2NvbnN0e2xpc3RlbmVyOkt9PUJbel07aWYoSz09PUkpe3RoaXNbQ11bTV0uc3BsaWNlKHosMSk7YnJlYWt9fX1yZXR1cm4gdGhpc310cmFuc2l0aW9uKE0sST0ibGluZWFyIil7Y29uc3QgRD10aGlzLFI9U3ltYm9sKCJhbmltYXRpb24iKTtJPUl8fCJsaW5lYXIiO2xldCBDPTA7cmV0dXJuIHR5cGVvZiBNPT0ib2JqZWN0IiYmKEM9TS5kZWxheXx8MCxNPU0uZHVyYXRpb24pLHtbUl06bnVsbCxjYW5jZWwoQj0hMSl7Y29uc3Qgej10aGlzW1JdO3omJnouY2FuY2VsKEIpfSxlbmQoKXtjb25zdCBCPXRoaXNbUl07QiYmKEIucGxheVN0YXRlPT09InJ1bm5pbmcifHxCLnBsYXlTdGF0ZT09PSJwZW5kaW5nIikmJkIuZmluaXNoKCl9LHJldmVyc2UoKXtjb25zdCBCPXRoaXNbUl07aWYoQilpZihCLnBsYXlTdGF0ZT09PSJydW5uaW5nInx8Qi5wbGF5U3RhdGU9PT0icGVuZGluZyIpQi5wbGF5YmFja1JhdGU9LUIucGxheWJhY2tSYXRlO2Vsc2V7Y29uc3Qgej1CLnRpbWluZy5kaXJlY3Rpb247Qi50aW1pbmcuZGlyZWN0aW9uPXo9PT0icmV2ZXJzZSI/Im5vcm1hbCI6InJldmVyc2UiLEIucGxheSgpfXJldHVybiBCLmZpbmlzaGVkfSxhdHRyKEIseil7cmV0dXJuIHRoaXMuZW5kKCksdHlwZW9mIEI9PSJzdHJpbmciJiYoQj17W0JdOnp9KSxPYmplY3QuZW50cmllcyhCKS5mb3JFYWNoKChbSyxRXSk9Pnt0eXBlb2YgUT09ImZ1bmN0aW9uIiYmKEJbS109UShELmF0dHIoSykpKX0pLHRoaXNbUl09RC5hbmltYXRlKFtCXSx7ZHVyYXRpb246TSoxZTMsZGVsYXk6QyoxZTMsZmlsbDoiZm9yd2FyZHMiLGVhc2luZzpJfSksdGhpc1tSXS5maW5pc2hlZH19fXVwZGF0ZUNvbnRvdXJzKCl7fX1wKEEsIkF0dHIiLG4uZGVmYXVsdCksYS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShBLCJub2RlIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KTt2YXIgcj10KDEpLG49dCgxMiksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKSxzPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGY9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxwPVN5bWJvbCgic3ViamVjdCIpLHk9U3ltYm9sKCJhdHRyIiksUD1TeW1ib2woImRlZmF1bHQiKSx4PVN5bWJvbCgiYWxpYXMiKTtmdW5jdGlvbiBtKEwsW00sSV0pe2xldCBEPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7cmV0dXJuWy4uLkxdLmZvckVhY2goKFtSLENdKT0+e2lmKChNfHxJKSYmKEQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsW00sSV0pKSxSPT09Im1hdHJpeCIpRD1yLm1hdDJkLm11bHRpcGx5KEQsRCxDKTtlbHNlIGlmKFI9PT0ib2Zmc2V0VHJhbnNsYXRlIilEWzRdKz1DWzBdLERbNV0rPUNbMV07ZWxzZSBpZihSPT09Im9mZnNldFJvdGF0ZSIpRD1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRCxDKTtlbHNlIGlmKFI9PT0ic2tldyIpe2NvbnN0W0Isel09QztEPXIubWF0MmQubXVsdGlwbHkoRCxELHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKHopLE1hdGgudGFuKEIpLDEsMCwwKSl9ZWxzZSByLm1hdDJkW1JdKEQsRCxDKTsoTXx8SSkmJihEPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELFstTSwtSV0pKX0pLER9Y29uc3QgTz1TeW1ib2woInRyYW5zZm9ybU1hdHJpeCIpLG89U3ltYm9sKCJ0cmFuc2Zvcm1zIiksaD1TeW1ib2woImNoYW5nZWRBdHRycyIpLGM9U3ltYm9sKCJsYXN0Q2hhbmdlZEF0dHIiKSxnPVN5bWJvbCgib2Zmc2V0RmlndXJlIik7ZnVuY3Rpb24gYihMLE0sSSl7Y29uc3QgRD1MW3ldW01dO2lmKExbc10oTSxJLCExKXx8TFtjXSE9PU0pe2NvbnN0IEM9TFtvXTtDLmhhcyhNKSYmQy5kZWxldGUoTSksSSYmKE09PT0icm90YXRlIiYmKEk9TWF0aC5QSSpJLzE4MCksTT09PSJzY2FsZSImJihJPUkubWFwKEI9Pk1hdGguYWJzKEIpPjFlLTU/QjoxL0I+MD8xZS01Oi0xZS01KSksQy5zZXQoTSxJKSksTFtPXT1udWxsLExbcF0ub25Qcm9wZXJ0eUNoYW5nZShNLEksRCxMKX19ZnVuY3Rpb24gRShMKXtjb25zdCBNPUxbZ10sST1MLm9mZnNldERpc3RhbmNlKk0uZ2V0VG90YWxMZW5ndGgoKSxEPU0uZ2V0UG9pbnRBdExlbmd0aChJKTtpZihEKXtjb25zdCBSPUxbb107bGV0IEM9TC5vZmZzZXRSb3RhdGU7Qz09PSJhdXRvIj9DPUQuYW5nbGU6Qz09PSJyZXZlcnNlIj9DPU1hdGguUEkrRC5hbmdsZTpDPU1hdGguUEkqQy8xODAsUi5zZXQoIm9mZnNldFJvdGF0ZSIsQyksUi5zZXQoIm9mZnNldFRyYW5zbGF0ZSIsW0QueCxELnldKSxMW09dPW51bGx9fWNsYXNzIEF7c3RhdGljIHNldERlZmF1bHQoTSwuLi5JKXtyZXR1cm4gTVthXSguLi5JKX1zdGF0aWMgZGVjbGFyZUFsaWFzKE0sLi4uSSl7cmV0dXJuIE1bbF0oLi4uSSl9c3RhdGljIHNldEF0dHJpYnV0ZShNLC4uLkkpe3JldHVybiBNW3NdKC4uLkkpfXN0YXRpYyBnZXRBdHRyaWJ1dGUoTSwuLi5JKXtyZXR1cm4gTVtmXSguLi5JKX1zdGF0aWMgZ2V0QXR0cmlidXRlcyhNKXtyZXR1cm4gTVt2XX1zdGF0aWMgZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoTSl7cmV0dXJuIE1bZF19Y29uc3RydWN0b3IoTSl7dGhpc1twXT1NLHRoaXNbeV09e30sdGhpc1tPXT1yLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLHRoaXNbb109bmV3IE1hcCx0aGlzW1BdPXt9LHRoaXNbeF09W10sT2JqZWN0LmRlZmluZVByb3BlcnR5KE0sInRyYW5zZm9ybU1hdHJpeCIse2dldDooKT0+KHRoaXNbT118fCh0aGlzW09dPW0odGhpc1tvXSx0aGlzLnRyYW5zZm9ybU9yaWdpbikpLFsuLi50aGlzW09dXSl9KSx0aGlzW2FdKHtpZDoiIixuYW1lOiIiLGNsYXNzTmFtZToiIix4OjAseTowLHRyYW5zZm9ybU9yaWdpbjpbMCwwXSx0cmFuc2Zvcm06IiIsdHJhbnNsYXRlOlswLDBdLHJvdGF0ZTowLHNjYWxlOlsxLDFdLHNrZXc6WzAsMF0sb3BhY2l0eToxLHpJbmRleDowLG9mZnNldFBhdGg6dm9pZCAwLG9mZnNldERpc3RhbmNlOjAsb2Zmc2V0Um90YXRlOiJhdXRvIixwb2ludGVyRXZlbnRzOiJ2aXNpYmxlIixmaWx0ZXI6Im5vbmUiLGRpc3BsYXk6IiJ9KSx0aGlzW2xdKCJjbGFzcyIsInBvcyIpLHRoaXNbaF09bmV3IFNldCx0aGlzW2ddPW5ldyBuLkZpZ3VyZTJEKHtzY2FsZTo1LHNpbXBsaWZ5OjB9KX1nZXRbZF0oKXtjb25zdCBNPXt9O3JldHVyblsuLi50aGlzW2hdXS5mb3JFYWNoKEk9PntNW0ldPXRoaXNbeV1bSV19KSxNfWdldFt2XSgpe2NvbnN0IE09T2JqZWN0LmFzc2lnbih7fSx0aGlzW3ldKTtmb3IobGV0IEk9MDtJPHRoaXNbeF0ubGVuZ3RoO0krKyl7Y29uc3QgRD10aGlzW3hdW0ldO01bRF09dGhpc1tEXX1yZXR1cm4gTX1bYV0oTSl7T2JqZWN0LmFzc2lnbih0aGlzW1BdLE0pLE9iamVjdC5hc3NpZ24odGhpc1t5XSxNKX1bbF0oLi4uTSl7dGhpc1t4XS5wdXNoKC4uLk0pfVtzXShNLEksRD0hMCl7Y29uc3QgUj10aGlzW3ldW01dLEM9dGhpc1twXTtyZXR1cm4gST09bnVsbCYmKEk9dGhpc1tQXVtNXSksT2JqZWN0KGkuY29tcGFyZVZhbHVlKShSLEkpPyExOih0aGlzW3ldW01dPUksdGhpc1toXS5oYXMoTSkmJnRoaXNbaF0uZGVsZXRlKE0pLHRoaXNbaF0uYWRkKE0pLHRoaXNbY109TSxEJiZDLm9uUHJvcGVydHlDaGFuZ2UoTSxJLFIsdGhpcyksITApfVtmXShNKXtyZXR1cm4gdGhpc1t5XVtNXX1zZXQgaWQoTSl7dGhpc1tzXSgiaWQiLE0pfWdldCBpZCgpe3JldHVybiB0aGlzW2ZdKCJpZCIpfXNldCBuYW1lKE0pe3RoaXNbc10oIm5hbWUiLE0pfWdldCBuYW1lKCl7cmV0dXJuIHRoaXNbZl0oIm5hbWUiKX1zZXQgY2xhc3NOYW1lKE0pe3RoaXNbc10oImNsYXNzTmFtZSIsTSl9Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzW2ZdKCJjbGFzc05hbWUiKX1zZXQgY2xhc3MoTSl7dGhpcy5jbGFzc05hbWU9TX1nZXQgY2xhc3MoKXtyZXR1cm4gdGhpcy5jbGFzc05hbWV9Z2V0IHgoKXtyZXR1cm4gdGhpc1tmXSgieCIpfXNldCB4KE0pe3RoaXNbc10oIngiLE9iamVjdChpLnRvTnVtYmVyKShNKSl9Z2V0IHkoKXtyZXR1cm4gdGhpc1tmXSgieSIpfXNldCB5KE0pe3RoaXNbc10oInkiLE9iamVjdChpLnRvTnVtYmVyKShNKSl9Z2V0IHBvcygpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXQgcG9zKE0pe009T2JqZWN0KGkudG9BcnJheSkoTSksQXJyYXkuaXNBcnJheShNKXx8KE09W00sTV0pLHRoaXMueD1NWzBdLHRoaXMueT1NWzFdfWdldCB0cmFuc2Zvcm0oKXtyZXR1cm4gdGhpc1tmXSgidHJhbnNmb3JtIil9c2V0IHRyYW5zZm9ybShNKXtsZXQgST1udWxsO2lmKEFycmF5LmlzQXJyYXkoTSkmJihJPU0sTT1gbWF0cml4KCR7TS5tYXAoaS50b051bWJlcikuam9pbigpfSlgKSx0eXBlb2YgTT09InN0cmluZyIpTT1NLnJlcGxhY2UoL1xzKixccyovZywiLCIpO2Vsc2UgaWYoTSE9bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHRyYW5zZm9ybSB2YWx1ZS4iKTtjb25zdCBEPXRoaXNbeV0udHJhbnNmb3JtO2lmKHRoaXNbc10oInRyYW5zZm9ybSIsTSwhMSkpe2NvbnN0IFI9dGhpc1tvXTtpZihSLmhhcygibWF0cml4IikmJlIuZGVsZXRlKCJtYXRyaXgiKSxJKVIuc2V0KCJtYXRyaXgiLEkpO2Vsc2UgaWYoTSl7Y29uc3QgQz1NLm1hdGNoKC8obWF0cml4fHRyYW5zbGF0ZXxyb3RhdGV8c2NhbGV8c2tldylcKFteKCldK1wpL2cpO2lmKEMpe2xldCBCPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7Zm9yKGxldCB6PTA7ejxDLmxlbmd0aDt6Kyspe2NvbnN0IFE9Q1t6XS5tYXRjaCgvXihtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoKFteKCldKylcKS8pO2lmKFEpe2xldFssXyxGXT1RO189PT0icm90YXRlIj9GPU1hdGguUEkqcGFyc2VGbG9hdChGKS8xODA6Rj1GLnRyaW0oKS5zcGxpdCgvW1xzLF0rLykubWFwKEc9Pk9iamVjdChpLnRvTnVtYmVyKShHKSksXz09PSJtYXRyaXgiP0I9ci5tYXQyZC5tdWx0aXBseShCLEIsRik6Xz09PSJza2V3Ij9CPXIubWF0MmQubXVsdGlwbHkoQixCLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKEZbMV0pLE1hdGgudGFuKEZbMF0pLDEsMCwwKSk6ci5tYXQyZFtfXShCLEIsRiksUi5zZXQoIm1hdHJpeCIsQil9fX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpfXRoaXNbT109bnVsbCx0aGlzW3BdLm9uUHJvcGVydHlDaGFuZ2UoInRyYW5zZm9ybSIsTSxELHRoaXMpfX1nZXQgdHJhbnNmb3JtT3JpZ2luKCl7cmV0dXJuIHRoaXNbZl0oInRyYW5zZm9ybU9yaWdpbiIpfXNldCB0cmFuc2Zvcm1PcmlnaW4oTSl7TT1PYmplY3QoaS50b0FycmF5KShNLCEwKSxNIT1udWxsJiYhQXJyYXkuaXNBcnJheShNKSYmKE09W00sTV0pLHRoaXNbc10oInRyYW5zZm9ybU9yaWdpbiIsTSkmJih0aGlzW09dPW51bGwpfWdldCByb3RhdGUoKXtyZXR1cm4gdGhpc1tmXSgicm90YXRlIil9c2V0IHJvdGF0ZShNKXtiKHRoaXMsInJvdGF0ZSIsTSl9Z2V0IHRyYW5zbGF0ZSgpe3JldHVybiB0aGlzW2ZdKCJ0cmFuc2xhdGUiKX1zZXQgdHJhbnNsYXRlKE0pe009T2JqZWN0KGkudG9BcnJheSkoTSwhMCksTSE9bnVsbCYmIUFycmF5LmlzQXJyYXkoTSkmJihNPVtNLE1dKSxiKHRoaXMsInRyYW5zbGF0ZSIsTSl9Z2V0IHNjYWxlKCl7cmV0dXJuIHRoaXNbZl0oInNjYWxlIil9c2V0IHNjYWxlKE0pe009T2JqZWN0KGkudG9BcnJheSkoTSwhMCksTSE9bnVsbCYmIUFycmF5LmlzQXJyYXkoTSkmJihNPVtNLE1dKSxiKHRoaXMsInNjYWxlIixNKX1nZXQgc2tldygpe3JldHVybiB0aGlzW2ZdKCJza2V3Iil9c2V0IHNrZXcoTSl7TT1PYmplY3QoaS50b0FycmF5KShNLCEwKSxNIT1udWxsJiYhQXJyYXkuaXNBcnJheShNKSYmKE09W00sTV0pLGIodGhpcywic2tldyIsTSl9Z2V0IG9wYWNpdHkoKXtyZXR1cm4gdGhpc1tmXSgib3BhY2l0eSIpfXNldCBvcGFjaXR5KE0pe00hPW51bGwmJihNPU51bWJlcihNKSksdGhpc1tzXSgib3BhY2l0eSIsTSl9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzW2ZdKCJ6SW5kZXgiKX1zZXQgekluZGV4KE0pe00hPW51bGwmJihNPU51bWJlcihNKSksdGhpc1tzXSgiekluZGV4IixNKX1nZXQgb2Zmc2V0UGF0aCgpe3JldHVybiB0aGlzW2ZdKCJvZmZzZXRQYXRoIil9c2V0IG9mZnNldFBhdGgoTSl7dGhpc1tzXSgib2Zmc2V0UGF0aCIsTSkmJih0aGlzW2ddLmJlZ2luUGF0aCgpLE0hPW51bGwmJnRoaXNbZ10uYWRkUGF0aChNKSxFKHRoaXMpKX1nZXQgb2Zmc2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpc1tmXSgib2Zmc2V0RGlzdGFuY2UiKX1zZXQgb2Zmc2V0RGlzdGFuY2UoTSl7dGhpc1tzXSgib2Zmc2V0RGlzdGFuY2UiLE9iamVjdChpLnRvTnVtYmVyKShNKSkmJkUodGhpcyl9Z2V0IG9mZnNldFJvdGF0ZSgpe3JldHVybiB0aGlzW2ZdKCJvZmZzZXRSb3RhdGUiKX1zZXQgb2Zmc2V0Um90YXRlKE0pe3RoaXNbc10oIm9mZnNldFJvdGF0ZSIsTSksRSh0aGlzKX1nZXQgcG9pbnRlckV2ZW50cygpe3JldHVybiB0aGlzW2ZdKCJwb2ludGVyRXZlbnRzIil9c2V0IHBvaW50ZXJFdmVudHMoTSl7aWYoTSE9bnVsbCYmTSE9PSJub25lIiYmTSE9PSJ2aXNpYmxlIiYmTSE9PSJ2aXNpYmxlRmlsbCImJk0hPT0idmlzaWJsZVN0cm9rZSImJk0hPT0iYWxsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHBvaW50ZXJFdmVudHMgdHlwZS4iKTt0aGlzW3NdKCJwb2ludGVyRXZlbnRzIixNKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbZl0oImZpbHRlciIpfXNldCBmaWx0ZXIoTSl7dGhpc1tzXSgiZmlsdGVyIixNKX1nZXQgZGlzcGxheSgpe3JldHVybiB0aGlzW2ZdKCJkaXNwbGF5Iil9c2V0IGRpc3BsYXkoTSl7dGhpc1tzXSgiZGlzcGxheSIsTSl9c2V0IG9mZnNldChNKXt9fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwic2l6ZVRvUGl4ZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwidG9OdW1iZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwidG9BcnJheSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJjb21wYXJlVmFsdWUiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihzLGYpe2NvbnN0IHY9cy50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW4pJC8pO3Y/cz17c2l6ZTpwYXJzZUZsb2F0KHZbMV0pLHVuaXQ6dlsyXX06cz17c2l6ZTpwYXJzZUZsb2F0KHMpLHVuaXQ6InB4In07bGV0e3NpemU6ZCx1bml0OnB9PXM7aWYocD09PSJwdCIpZC89Ljc1O2Vsc2UgaWYocD09PSJwYyIpZCo9MTY7ZWxzZSBpZihwPT09ImluIilkKj05NjtlbHNlIGlmKHA9PT0iY20iKWQqPTk2LzIuNTQ7ZWxzZSBpZihwPT09Im1tIilkKj05Ni8yNS40O2Vsc2UgaWYocD09PSJlbSJ8fHA9PT0icmVtInx8cD09PSJleCIpe2lmKCFmJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeT1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7eT9mPXIoeSwxNik6Zj0xNn1kKj1mLHA9PT0iZXgiJiYoZC89Mil9ZWxzZSBpZihwPT09InEiKWQqPTk2LzI1LjQvNDtlbHNlIGlmKHA9PT0idncifHxwPT09InZoIil7aWYodHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeT1wPT09InZ3Ij93aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOndpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtkKj15LzEwMH19ZWxzZSBpZigocD09PSJ2bWF4Inx8cD09PSJ2bWluIikmJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IHk9d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxQPXdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtwPT09InZtYXgiP2QqPU1hdGgubWF4KHksUCkvMTAwOmQqPU1hdGgubWluKHksUCkvMTAwfXJldHVybiBkfWZ1bmN0aW9uIG4ocyl7cmV0dXJuIHM9PW51bGw/czpTdHJpbmcocyl9ZnVuY3Rpb24gaShzKXtpZihzPT1udWxsKXJldHVybiBzO2lmKHR5cGVvZiBzPT0ic3RyaW5nIiYmKHM9cihzKSksIU51bWJlci5pc0Zpbml0ZShzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZhbHVlIik7cmV0dXJuIHN9ZnVuY3Rpb24gYShzLGY9ITEpe3JldHVybiBzPT09IiI/bnVsbDoodHlwZW9mIHM9PSJzdHJpbmciJiYocz1zLnNwbGl0KC9bXHMsXSsvZykpLEFycmF5LmlzQXJyYXkocykmJihmJiYocz1zLm1hcChpKSkscy5sZW5ndGg9PT0xKT9zWzBdOnMpfWZ1bmN0aW9uIGwocyxmKXtpZihBcnJheS5pc0FycmF5KHMpJiZBcnJheS5pc0FycmF5KGYpKXtpZihzLmxlbmd0aCE9PWYubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdj0wO3Y8cy5sZW5ndGg7disrKWlmKHNbdl0hPT1mW3ZdKXJldHVybiExO3JldHVybiEwfXJldHVybiBzPT1udWxsJiZmPT1udWxsfHxzPT09Zn19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KTt2YXIgcj10KDc0KSxuPXQoMzIpLGk9dC5uKG4pLGE9dCg2OCksbD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcygpe3JldHVybiBzPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHkpe2Zvcih2YXIgUD0xO1A8YXJndW1lbnRzLmxlbmd0aDtQKyspe3ZhciB4PWFyZ3VtZW50c1tQXTtmb3IodmFyIG0gaW4geClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCxtKSYmKHlbbV09eFttXSl9cmV0dXJuIHl9LHMuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGYoeSl7aWYodHlwZW9mIHk9PSJzdHJpbmciKXtpZih5PXkudHJpbSgpLC9eWzAtOS5dKyUkLy50ZXN0KHkpKXJldHVybiBwYXJzZUZsb2F0KHkpLzEwMDtpZigvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLy50ZXN0KHkpKXJldHVybiBPYmplY3QobC5zaXplVG9QaXhlbCkoeSl9cmV0dXJuIHl9ZnVuY3Rpb24gdih5LFAseCxtLE8pe3JldHVybiB0eXBlb2YgeT09InN0cmluZyImJih5PWkoKSh5KSksdHlwZW9mIFA9PSJzdHJpbmciJiYoUD1pKCkoUCkpLHIuRWZmZWN0cy5kZWZhdWx0KHksUCx4LG0sTyl9ZnVuY3Rpb24gZCh5LFAseCxtLE8pe3JldHVybiByLkVmZmVjdHMuZGVmYXVsdCh5LFAseCxtLE8pfXIuRWZmZWN0cy5kZWZhdWx0PWZ1bmN0aW9uKHksUCx4LG0sTyl7cmV0dXJuIEFycmF5LmlzQXJyYXkoeSkmJkFycmF5LmlzQXJyYXkoUCk/eS5tYXAoKG8saCk9Pm8rKHgtbSkvKE8tbSkqKFBbaF0tbykpOnR5cGVvZiB5PT0ibnVtYmVyIiYmdHlwZW9mIFA9PSJudW1iZXIiP3krKHgtbSkvKE8tbSkqKFAteSk6eC1tPk8teD9QOnl9LHIuRWZmZWN0cy5maWxsQ29sb3I9dixyLkVmZmVjdHMuc3Ryb2tlQ29sb3I9dixyLkVmZmVjdHMuYmdjb2xvcj12LHIuRWZmZWN0cy5ib3JkZXJDb2xvcj12LHIuRWZmZWN0cy50ZXh0PWQ7Y2xhc3MgcCBleHRlbmRzIHIuQW5pbWF0b3J7Y29uc3RydWN0b3IoUCx4LG0pe2NvbnN0IE89UC5hdHRyKCk7T2JqZWN0LmVudHJpZXMoTykuZm9yRWFjaCgoW28saF0pPT57T1tvXT1yLkVmZmVjdHNbb10/aDpmKGgpfSkseD14Lm1hcChvPT57bGV0IGg9cyh7fSxvKTtjb25zdCBjPXt9O3JldHVybiBPYmplY3QuZW50cmllcyhoKS5mb3JFYWNoKChbZyxiXSk9PntjW2ddPXIuRWZmZWN0c1tnXT9iOmYoYil9KSxjfSksc3VwZXIoTyx4LG0pLHRoaXMudGFyZ2V0PVAsdGhpcy5zZXR0ZXI9ZnVuY3Rpb24obyxoKXtoLmF0dHIobyl9fWdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy50YXJnZXQucGFyZW50P3N1cGVyLnBsYXlTdGF0ZToiaWRsZSJ9Z2V0IGZpbmlzaGVkKCl7cmV0dXJuIHN1cGVyLmZpbmlzaGVkLnRoZW4oKCk9Pntjb25zdCBQPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKHg9PntmdW5jdGlvbiBtKCl7UC5zZXR0ZXIoUC5mcmFtZSxQLnRhcmdldCk7Y29uc3QgTz1QLnBsYXlTdGF0ZTtPPT09ImZpbmlzaGVkInx8Tz09PSJpZGxlIj8oT2JqZWN0KGEuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKFAucmVxdWVzdElkKSx4KCkpOk9iamVjdChhLnJlcXVlc3RBbmltYXRpb25GcmFtZSkobSl9bSgpfSl9KX1maW5pc2goKXtzdXBlci5maW5pc2goKSxPYmplY3QoYS5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpfXBsYXkoKXtpZighdGhpcy50YXJnZXQucGFyZW50fHx0aGlzLnBsYXlTdGF0ZT09PSJydW5uaW5nIilyZXR1cm47c3VwZXIucGxheSgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpO2NvbnN0IFA9dGhpczt0aGlzLnJlYWR5LnRoZW4oKCk9PntQLnNldHRlcihQLmZyYW1lLFAudGFyZ2V0KSxQLnJlcXVlc3RJZD1PYmplY3QoYS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGZ1bmN0aW9uIHgoKXtjb25zdCBtPVAudGFyZ2V0O2lmKHR5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zJiZtLmxheWVyJiZtLmxheWVyLmNhbnZhcyYmIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhtLmxheWVyLmNhbnZhcykpe1AuY2FuY2VsKCk7cmV0dXJufWNvbnN0IE89UC5wbGF5U3RhdGU7UC5zZXR0ZXIoUC5mcmFtZSxQLnRhcmdldCksTyE9PSJpZGxlIiYmKE89PT0icnVubmluZyI/UC5yZXF1ZXN0SWQ9T2JqZWN0KGEucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSh4KTooTz09PSJwYXVzZWQifHxPPT09InBlbmRpbmciJiZQLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDApJiZQLnJlYWR5LnRoZW4oKCk9PntQLnNldHRlcihQLmZyYW1lLFAudGFyZ2V0KSxQLnJlcXVlc3RJZD1PYmplY3QoYS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKHgpfSkpfSl9KX1jYW5jZWwoUD0hMSl7T2JqZWN0KGEuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXMucmVxdWVzdElkKSxQPyh0aGlzLnNldHRlcih0aGlzLmZyYW1lLHRoaXMudGFyZ2V0KSxzdXBlci5jYW5jZWwoKSk6KHN1cGVyLmNhbmNlbCgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpKX19fSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuVGltZWxpbmU9ZS5FZmZlY3RzPWUuRWFzaW5ncz1lLkFuaW1hdG9yPXZvaWQgMDt2YXIgcj10KDc1KSxuPXYociksaT10KDE4NyksYT12KGkpLGw9dCgxODgpLHM9dCgxOTApLGY9dihzKTtmdW5jdGlvbiB2KGQpe3JldHVybiBkJiZkLl9fZXNNb2R1bGU/ZDp7ZGVmYXVsdDpkfX1lLkFuaW1hdG9yPWYuZGVmYXVsdCxlLkVhc2luZ3M9bC5FYXNpbmdzLGUuRWZmZWN0cz1hLmRlZmF1bHQsZS5UaW1lbGluZT1uLmRlZmF1bHR9LGZ1bmN0aW9uKHUsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9dCg3Niksbj1vKHIpLGk9dCgxMzMpLGE9byhpKSxsPXQoMTQxKSxzPW8obCksZj10KDE2NCksdj1vKGYpLGQ9dCgxNzApLHA9byhkKSx5PXQoMTcxKSxQPW8oeSkseD10KDE3NSksbT1vKHgpLE89dCgxODYpO2Z1bmN0aW9uIG8oRCl7cmV0dXJuIEQmJkQuX19lc01vZHVsZT9EOntkZWZhdWx0OkR9fXZhciBoPSgwLE8uY3JlYXRlTm93VGltZSkoKSxjPXtvcmlnaW5UaW1lOjAscGxheWJhY2tSYXRlOjF9LGc9KDAsbS5kZWZhdWx0KSgidGltZU1hcmsiKSxiPSgwLG0uZGVmYXVsdCkoInBsYXliYWNrUmF0ZSIpLEU9KDAsbS5kZWZhdWx0KSgidGltZXJzIiksQT0oMCxtLmRlZmF1bHQpKCJvcmlnaW5UaW1lIiksTD0oMCxtLmRlZmF1bHQpKCJzZXRUaW1lciIpLE09KDAsbS5kZWZhdWx0KSgicGFyZW50IiksST1mdW5jdGlvbigpe2Z1bmN0aW9uIEQoUixDKXsoMCxwLmRlZmF1bHQpKHRoaXMsRCksUiBpbnN0YW5jZW9mIEQmJihDPVIsUj17fSksUj0oMCx2LmRlZmF1bHQpKHt9LGMsUiksQyYmKHRoaXNbTV09Qyk7dmFyIEI9Ui5ub3d0aW1lfHxoO2lmKEMpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImdsb2JhbFRpbWUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQy5jdXJyZW50VGltZX19KTtlbHNle3ZhciB6PUIoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBCKCkten19KX10aGlzW2ddPVt7Z2xvYmFsVGltZTp0aGlzLmdsb2JhbFRpbWUsbG9jYWxUaW1lOi1SLm9yaWdpblRpbWUsZW50cm9weTotUi5vcmlnaW5UaW1lLHBsYXliYWNrUmF0ZTpSLnBsYXliYWNrUmF0ZSxnbG9iYWxFbnRyb3B5OjB9XSx0aGlzW01dJiYodGhpc1tnXVswXS5nbG9iYWxFbnRyb3B5PXRoaXNbTV0uZW50cm9weSksdGhpc1tBXT1SLm9yaWdpblRpbWUsdGhpc1tiXT1SLnBsYXliYWNrUmF0ZSx0aGlzW0VdPW5ldyBzLmRlZmF1bHR9cmV0dXJuKDAsUC5kZWZhdWx0KShELFt7a2V5OiJtYXJrVGltZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgQz1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXZvaWQgMD9hcmd1bWVudHNbMF06e30sQj1DLnRpbWUsej1CPT09dm9pZCAwP3RoaXMuY3VycmVudFRpbWU6QixLPUMuZW50cm9weSxRPUs9PT12b2lkIDA/dGhpcy5lbnRyb3B5OkssXz1DLnBsYXliYWNrUmF0ZSxGPV89PT12b2lkIDA/dGhpcy5wbGF5YmFja1JhdGU6XyxHPXtnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6eixlbnRyb3B5OlEscGxheWJhY2tSYXRlOkYsZ2xvYmFsRW50cm9weTp0aGlzLmdsb2JhbEVudHJvcHl9O3RoaXNbZ10ucHVzaChHKX19LHtrZXk6ImZvcmsiLHZhbHVlOmZ1bmN0aW9uKEMpe3JldHVybiBuZXcgRChDLHRoaXMpfX0se2tleToic2Vla0dsb2JhbFRpbWUiLHZhbHVlOmZ1bmN0aW9uKEMpe3ZhciBCPXRoaXMuc2Vla1RpbWVNYXJrKEMpLHo9dGhpc1tnXVtCXSxLPXouZW50cm9weSxRPXoucGxheWJhY2tSYXRlLF89ei5nbG9iYWxUaW1lO3JldHVybiBfKyhDLUspL01hdGguYWJzKFEpfX0se2tleToic2Vla0xvY2FsVGltZSIsdmFsdWU6ZnVuY3Rpb24oQyl7dmFyIEI9dGhpcy5zZWVrVGltZU1hcmsoQyksej10aGlzW2ddW0JdLEs9ei5sb2NhbFRpbWUsUT16LmVudHJvcHksXz16LnBsYXliYWNrUmF0ZTtyZXR1cm4gXz4wP0srKEMtUSk6Sy0oQy1RKX19LHtrZXk6InNlZWtUaW1lTWFyayIsdmFsdWU6ZnVuY3Rpb24oQyl7dmFyIEI9dGhpc1tnXSx6PTAsSz1CLmxlbmd0aC0xO2lmKEM8PUJbel0uZW50cm9weSlyZXR1cm4gejtpZihDPj1CW0tdLmVudHJvcHkpcmV0dXJuIEs7Zm9yKHZhciBRPU1hdGguZmxvb3IoKHorSykvMik7UT56JiZRPEs7KXtpZihDPT09QltRXS5lbnRyb3B5KXJldHVybiBRO0M8QltRXS5lbnRyb3B5P0s9UTpDPkJbUV0uZW50cm9weSYmKHo9USksUT1NYXRoLmZsb29yKCh6K0spLzIpfXJldHVybiB6fX0se2tleToidXBkYXRlVGltZXJzIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBDPXRoaXMsQj1bXS5jb25jYXQoKDAsYS5kZWZhdWx0KSh0aGlzW0VdKSk7Qi5mb3JFYWNoKGZ1bmN0aW9uKHope3ZhciBLPSgwLG4uZGVmYXVsdCkoeiwyKSxRPUtbMF0sXz1LWzFdO0NbTF0oXy5oYW5kbGVyLF8udGltZSxRKX0pfX0se2tleToiY2xlYXJUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihSKXtmdW5jdGlvbiBDKEIpe3JldHVybiBSLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gQy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBSLnRvU3RyaW5nKCl9LEN9KGZ1bmN0aW9uKFIpe3ZhciBDPXRoaXNbRV0uZ2V0KFIpO0MmJkMudGltZXJJRCE9bnVsbCYmKHRoaXNbTV0/dGhpc1tNXS5jbGVhclRpbWVvdXQoQy50aW1lcklEKTpjbGVhclRpbWVvdXQoQy50aW1lcklEKSksdGhpc1tFXS5kZWxldGUoUil9KX0se2tleToiY2xlYXJJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oQyl7cmV0dXJuIHRoaXMuY2xlYXJUaW1lb3V0KEMpfX0se2tleToiY2xlYXIiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEM9dGhpcyxCPXRoaXNbRV07W10uY29uY2F0KCgwLGEuZGVmYXVsdCkoQi5rZXlzKCkpKS5mb3JFYWNoKGZ1bmN0aW9uKHope0MuY2xlYXJUaW1lb3V0KHopfSl9fSx7a2V5OiJzZXRUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihDKXt2YXIgQj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9O3JldHVybiB0aGlzW0xdKEMsQil9fSx7a2V5OiJzZXRJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oQyl7dmFyIEI9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOntkZWxheTowfSx6PXRoaXMsSz10aGlzW0xdKGZ1bmN0aW9uIFEoKXt6W0xdKFEsQixLKSxDKCl9LEIpO3JldHVybiBLfX0se2tleTpMLHZhbHVlOmZ1bmN0aW9uKEMsQil7dmFyIHo9dGhpcyxLPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTooMCxtLmRlZmF1bHQpKCJ0aW1lcklEIik7Qj0oMCxPLmZvcm1hdERlbGF5KShCKTt2YXIgUT10aGlzW0VdLmdldChLKSxfPXZvaWQgMCxGPW51bGwsRz12b2lkIDAsWD12b2lkIDA7UT8odGhpcy5jbGVhclRpbWVvdXQoSyksQi5pc0VudHJvcHk/Xz0oQi5kZWxheS0odGhpcy5lbnRyb3B5LVEuc3RhcnRFbnRyb3B5KSkvTWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOl89KEIuZGVsYXktKHRoaXMuY3VycmVudFRpbWUtUS5zdGFydFRpbWUpKS90aGlzLnBsYXliYWNrUmF0ZSxHPVEuc3RhcnRUaW1lLFg9US5zdGFydEVudHJvcHkpOihfPUIuZGVsYXkvKEIuaXNFbnRyb3B5P01hdGguYWJzKHRoaXMucGxheWJhY2tSYXRlKTp0aGlzLnBsYXliYWNrUmF0ZSksRz10aGlzLmN1cnJlbnRUaW1lLFg9dGhpcy5lbnRyb3B5KTt2YXIgWj10aGlzW01dLHR0PVo/Wi5zZXRUaW1lb3V0LmJpbmQoWik6c2V0VGltZW91dCxudD1CLmhlYWRpbmc7cmV0dXJuIVomJm50PT09ITEmJl88MCYmKF89MS8wKSwoaXNGaW5pdGUoXyl8fFopJiYoXz1NYXRoLmNlaWwoXyksdHQhPT1zZXRUaW1lb3V0JiYoXz17ZGVsYXk6XyxoZWFkaW5nOm50fSksRj10dChmdW5jdGlvbigpe3pbRV0uZGVsZXRlKEspLEMoKX0sXykpLHRoaXNbRV0uc2V0KEsse3RpbWVySUQ6RixoYW5kbGVyOkMsdGltZTpCLHN0YXJ0VGltZTpHLHN0YXJ0RW50cm9weTpYfSksS319LHtrZXk6InBhcmVudCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbTV19fSx7a2V5OiJsYXN0VGltZU1hcmsiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2ddW3RoaXNbZ10ubGVuZ3RoLTFdfX0se2tleToiY3VycmVudFRpbWUiLGdldDpmdW5jdGlvbigpe3ZhciBDPXRoaXMubGFzdFRpbWVNYXJrLEI9Qy5sb2NhbFRpbWUsej1DLmdsb2JhbFRpbWU7cmV0dXJuIEIrKHRoaXMuZ2xvYmFsVGltZS16KSp0aGlzLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKEMpe3ZhciBCPXRoaXMsej10aGlzLmN1cnJlbnRUaW1lLEs9QyxRPXRoaXNbRV07dGhpcy5tYXJrVGltZSh7dGltZTpDfSksW10uY29uY2F0KCgwLGEuZGVmYXVsdCkoUSkpLmZvckVhY2goZnVuY3Rpb24oXyl7dmFyIEY9KDAsbi5kZWZhdWx0KShfLDIpLEc9RlswXSxYPUZbMV07aWYoUS5oYXMoRykpe3ZhciBaPVgudGltZSx0dD1aLmlzRW50cm9weSxudD1aLmRlbGF5LHE9Wi5oZWFkaW5nLGh0PVguaGFuZGxlcix1dD1YLnN0YXJ0VGltZTtpZih0dCludD09PTAmJihodCgpLEIuY2xlYXJUaW1lb3V0KEcpKTtlbHNle3ZhciBqPXV0K250OyhudD09PTB8fHEhPT0hMSYmKEsteikqbnQ8PTB8fHo8PWomJmo8PUt8fHo+PWomJmo+PUspJiYoaHQoKSxCLmNsZWFyVGltZW91dChHKSl9fX0pLHRoaXMudXBkYXRlVGltZXJzKCl9fSx7a2V5OiJlbnRyb3B5IixnZXQ6ZnVuY3Rpb24oKXt2YXIgQz10aGlzLmxhc3RUaW1lTWFyayxCPUMuZW50cm9weSx6PUMuZ2xvYmFsRW50cm9weTtyZXR1cm4gQitNYXRoLmFicygodGhpcy5nbG9iYWxFbnRyb3B5LXopKnRoaXMucGxheWJhY2tSYXRlKX0sc2V0OmZ1bmN0aW9uKEMpe2lmKHRoaXMuZW50cm9weT5DKXt2YXIgQj10aGlzLnNlZWtUaW1lTWFyayhDKTt0aGlzW2ddLmxlbmd0aD1CKzF9dGhpcy5tYXJrVGltZSh7ZW50cm9weTpDfSksdGhpcy51cGRhdGVUaW1lcnMoKX19LHtrZXk6Imdsb2JhbEVudHJvcHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW01dP3RoaXNbTV0uZW50cm9weTp0aGlzLmdsb2JhbFRpbWV9fSx7a2V5OiJwbGF5YmFja1JhdGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2JdfSxzZXQ6ZnVuY3Rpb24oQyl7QyE9PXRoaXMucGxheWJhY2tSYXRlJiYodGhpcy5tYXJrVGltZSh7cGxheWJhY2tSYXRlOkN9KSx0aGlzW2JdPUMsdGhpcy51cGRhdGVUaW1lcnMoKSl9fSx7a2V5OiJwYXVzZWQiLGdldDpmdW5jdGlvbigpe2lmKHRoaXMucGxheWJhY2tSYXRlPT09MClyZXR1cm4hMDtmb3IodmFyIEM9dGhpcy5wYXJlbnQ7Qzspe2lmKEMucGxheWJhY2tSYXRlPT09MClyZXR1cm4hMDtDPUMucGFyZW50fXJldHVybiExfX1dKSxEfSgpO2UuZGVmYXVsdD1JfSxmdW5jdGlvbih1LGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPXQoNzcpLG49bChyKSxpPXQoMTI5KSxhPWwoaSk7ZnVuY3Rpb24gbChzKXtyZXR1cm4gcyYmcy5fX2VzTW9kdWxlP3M6e2RlZmF1bHQ6c319ZS5kZWZhdWx0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcyhmLHYpe3ZhciBkPVtdLHA9ITAseT0hMSxQPXZvaWQgMDt0cnl7Zm9yKHZhciB4PSgwLGEuZGVmYXVsdCkoZiksbTshKHA9KG09eC5uZXh0KCkpLmRvbmUpJiYoZC5wdXNoKG0udmFsdWUpLCEodiYmZC5sZW5ndGg9PT12KSk7cD0hMCk7fWNhdGNoKE8pe3k9ITAsUD1PfWZpbmFsbHl7dHJ5eyFwJiZ4LnJldHVybiYmeC5yZXR1cm4oKX1maW5hbGx5e2lmKHkpdGhyb3cgUH19cmV0dXJuIGR9cmV0dXJuIGZ1bmN0aW9uKGYsdil7aWYoQXJyYXkuaXNBcnJheShmKSlyZXR1cm4gZjtpZigoMCxuLmRlZmF1bHQpKE9iamVjdChmKSkpcmV0dXJuIHMoZix2KTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpfSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXtkZWZhdWx0OnQoNzgpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih1LGUsdCl7dCg3OSksdCgxMjUpLHUuZXhwb3J0cz10KDEyNyl9LGZ1bmN0aW9uKHUsZSx0KXt0KDgwKTtmb3IodmFyIHI9dCg5MSksbj10KDk1KSxpPXQoODMpLGE9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLGw9IkNTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCxNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LFNWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LFRleHRUcmFja0xpc3QsVG91Y2hMaXN0Ii5zcGxpdCgiLCIpLHM9MDtzPGwubGVuZ3RoO3MrKyl7dmFyIGY9bFtzXSx2PXJbZl0sZD12JiZ2LnByb3RvdHlwZTtkJiYhZFthXSYmbihkLGEsZiksaVtmXT1pLkFycmF5fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODEpLG49dCg4MiksaT10KDgzKSxhPXQoODQpO3UuZXhwb3J0cz10KDg4KShBcnJheSwiQXJyYXkiLGZ1bmN0aW9uKGwscyl7dGhpcy5fdD1hKGwpLHRoaXMuX2k9MCx0aGlzLl9rPXN9LGZ1bmN0aW9uKCl7dmFyIGw9dGhpcy5fdCxzPXRoaXMuX2ssZj10aGlzLl9pKys7cmV0dXJuIWx8fGY+PWwubGVuZ3RoPyh0aGlzLl90PXZvaWQgMCxuKDEpKTpzPT0ia2V5cyI/bigwLGYpOnM9PSJ2YWx1ZXMiP24oMCxsW2ZdKTpuKDAsW2YsbFtmXV0pfSwidmFsdWVzIiksaS5Bcmd1bWVudHM9aS5BcnJheSxyKCJrZXlzIikscigidmFsdWVzIikscigiZW50cmllcyIpfSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbigpe319LGZ1bmN0aW9uKHUsZSl7dS5leHBvcnRzPWZ1bmN0aW9uKHQscil7cmV0dXJue3ZhbHVlOnIsZG9uZTohIXR9fX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9e319LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDg1KSxuPXQoODcpO3UuZXhwb3J0cz1mdW5jdGlvbihpKXtyZXR1cm4gcihuKGkpKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDg2KTt1LmV4cG9ydHM9T2JqZWN0KCJ6IikucHJvcGVydHlJc0VudW1lcmFibGUoMCk/T2JqZWN0OmZ1bmN0aW9uKG4pe3JldHVybiByKG4pPT0iU3RyaW5nIj9uLnNwbGl0KCIiKTpPYmplY3Qobil9fSxmdW5jdGlvbih1LGUpe3ZhciB0PXt9LnRvU3RyaW5nO3UuZXhwb3J0cz1mdW5jdGlvbihyKXtyZXR1cm4gdC5jYWxsKHIpLnNsaWNlKDgsLTEpfX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodD09bnVsbCl0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNhbGwgbWV0aG9kIG9uICAiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODkpLG49dCg5MCksaT10KDEwNiksYT10KDk1KSxsPXQoODMpLHM9dCgxMDcpLGY9dCgxMjEpLHY9dCgxMjMpLGQ9dCgxMjIpKCJpdGVyYXRvciIpLHA9IShbXS5rZXlzJiYibmV4dCJpbltdLmtleXMoKSkseT0iQEBpdGVyYXRvciIsUD0ia2V5cyIseD0idmFsdWVzIixtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3UuZXhwb3J0cz1mdW5jdGlvbihPLG8saCxjLGcsYixFKXtzKGgsbyxjKTt2YXIgQT1mdW5jdGlvbihGKXtpZighcCYmRiBpbiBEKXJldHVybiBEW0ZdO3N3aXRjaChGKXtjYXNlIFA6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBoKHRoaXMsRil9O2Nhc2UgeDpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGgodGhpcyxGKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBoKHRoaXMsRil9fSxMPW8rIiBJdGVyYXRvciIsTT1nPT14LEk9ITEsRD1PLnByb3RvdHlwZSxSPURbZF18fERbeV18fGcmJkRbZ10sQz1SfHxBKGcpLEI9Zz9NP0EoImVudHJpZXMiKTpDOnZvaWQgMCx6PW89PSJBcnJheSImJkQuZW50cmllc3x8UixLLFEsXztpZih6JiYoXz12KHouY2FsbChuZXcgTykpLF8hPT1PYmplY3QucHJvdG90eXBlJiZfLm5leHQmJihmKF8sTCwhMCksIXImJnR5cGVvZiBfW2RdIT0iZnVuY3Rpb24iJiZhKF8sZCxtKSkpLE0mJlImJlIubmFtZSE9PXgmJihJPSEwLEM9ZnVuY3Rpb24oKXtyZXR1cm4gUi5jYWxsKHRoaXMpfSksKCFyfHxFKSYmKHB8fEl8fCFEW2RdKSYmYShELGQsQyksbFtvXT1DLGxbTF09bSxnKWlmKEs9e3ZhbHVlczpNP0M6QSh4KSxrZXlzOmI/QzpBKFApLGVudHJpZXM6Qn0sRSlmb3IoUSBpbiBLKVEgaW4gRHx8aShELFEsS1tRXSk7ZWxzZSBuKG4uUCtuLkYqKHB8fEkpLG8sSyk7cmV0dXJuIEt9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz0hMH0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLG49dCg5MiksaT10KDkzKSxhPXQoOTUpLGw9dCgxMDUpLHM9InByb3RvdHlwZSIsZj1mdW5jdGlvbih2LGQscCl7dmFyIHk9diZmLkYsUD12JmYuRyx4PXYmZi5TLG09diZmLlAsTz12JmYuQixvPXYmZi5XLGg9UD9uOm5bZF18fChuW2RdPXt9KSxjPWhbc10sZz1QP3I6eD9yW2RdOihyW2RdfHx7fSlbc10sYixFLEE7UCYmKHA9ZCk7Zm9yKGIgaW4gcClFPSF5JiZnJiZnW2JdIT09dm9pZCAwLCEoRSYmbChoLGIpKSYmKEE9RT9nW2JdOnBbYl0saFtiXT1QJiZ0eXBlb2YgZ1tiXSE9ImZ1bmN0aW9uIj9wW2JdOk8mJkU/aShBLHIpOm8mJmdbYl09PUE/ZnVuY3Rpb24oTCl7dmFyIE09ZnVuY3Rpb24oSSxELFIpe2lmKHRoaXMgaW5zdGFuY2VvZiBMKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgTDtjYXNlIDE6cmV0dXJuIG5ldyBMKEkpO2Nhc2UgMjpyZXR1cm4gbmV3IEwoSSxEKX1yZXR1cm4gbmV3IEwoSSxELFIpfXJldHVybiBMLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIE1bc109TFtzXSxNfShBKTptJiZ0eXBlb2YgQT09ImZ1bmN0aW9uIj9pKEZ1bmN0aW9uLmNhbGwsQSk6QSxtJiYoKGgudmlydHVhbHx8KGgudmlydHVhbD17fSkpW2JdPUEsdiZmLlImJmMmJiFjW2JdJiZhKGMsYixBKSkpfTtmLkY9MSxmLkc9MixmLlM9NCxmLlA9OCxmLkI9MTYsZi5XPTMyLGYuVT02NCxmLlI9MTI4LHUuZXhwb3J0cz1mfSxmdW5jdGlvbih1LGUpe3ZhciB0PXUuZXhwb3J0cz10eXBlb2Ygd2luZG93PCJ1IiYmd2luZG93Lk1hdGg9PU1hdGg/d2luZG93OnR5cGVvZiBzZWxmPCJ1IiYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oInJldHVybiB0aGlzIikoKTt0eXBlb2YgX19nPT0ibnVtYmVyIiYmKF9fZz10KX0sZnVuY3Rpb24odSxlKXt2YXIgdD11LmV4cG9ydHM9e3ZlcnNpb246IjIuNi4xMSJ9O3R5cGVvZiBfX2U9PSJudW1iZXIiJiYoX19lPXQpfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5NCk7dS5leHBvcnRzPWZ1bmN0aW9uKG4saSxhKXtpZihyKG4pLGk9PT12b2lkIDApcmV0dXJuIG47c3dpdGNoKGEpe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24obCl7cmV0dXJuIG4uY2FsbChpLGwpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKGwscyl7cmV0dXJuIG4uY2FsbChpLGwscyl9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24obCxzLGYpe3JldHVybiBuLmNhbGwoaSxsLHMsZil9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuLmFwcGx5KGksYXJndW1lbnRzKX19fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0eXBlb2YgdCE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IodCsiIGlzIG5vdCBhIGZ1bmN0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTYpLG49dCgxMDQpO3UuZXhwb3J0cz10KDEwMCk/ZnVuY3Rpb24oaSxhLGwpe3JldHVybiByLmYoaSxhLG4oMSxsKSl9OmZ1bmN0aW9uKGksYSxsKXtyZXR1cm4gaVthXT1sLGl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5Nyksbj10KDk5KSxpPXQoMTAzKSxhPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTtlLmY9dCgxMDApP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihzLGYsdil7aWYocihzKSxmPWkoZiwhMCkscih2KSxuKXRyeXtyZXR1cm4gYShzLGYsdil9Y2F0Y2h7fWlmKCJnZXQiaW4gdnx8InNldCJpbiB2KXRocm93IFR5cGVFcnJvcigiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhIik7cmV0dXJuInZhbHVlImluIHYmJihzW2ZdPXYudmFsdWUpLHN9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5OCk7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe2lmKCFyKG4pKXRocm93IFR5cGVFcnJvcihuKyIgaXMgbm90IGFuIG9iamVjdCEiKTtyZXR1cm4gbn19LGZ1bmN0aW9uKHUsZSl7dS5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im9iamVjdCI/dCE9PW51bGw6dHlwZW9mIHQ9PSJmdW5jdGlvbiJ9fSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPSF0KDEwMCkmJiF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQoMTAyKSgiZGl2IiksImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hIT03fSl9LGZ1bmN0aW9uKHUsZSl7dS5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaHtyZXR1cm4hMH19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5OCksbj10KDkxKS5kb2N1bWVudCxpPXIobikmJnIobi5jcmVhdGVFbGVtZW50KTt1LmV4cG9ydHM9ZnVuY3Rpb24oYSl7cmV0dXJuIGk/bi5jcmVhdGVFbGVtZW50KGEpOnt9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTgpO3UuZXhwb3J0cz1mdW5jdGlvbihuLGkpe2lmKCFyKG4pKXJldHVybiBuO3ZhciBhLGw7aWYoaSYmdHlwZW9mKGE9bi50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFyKGw9YS5jYWxsKG4pKXx8dHlwZW9mKGE9bi52YWx1ZU9mKT09ImZ1bmN0aW9uIiYmIXIobD1hLmNhbGwobikpfHwhaSYmdHlwZW9mKGE9bi50b1N0cmluZyk9PSJmdW5jdGlvbiImJiFyKGw9YS5jYWxsKG4pKSlyZXR1cm4gbDt0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpfX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9ZnVuY3Rpb24odCxyKXtyZXR1cm57ZW51bWVyYWJsZTohKHQmMSksY29uZmlndXJhYmxlOiEodCYyKSx3cml0YWJsZTohKHQmNCksdmFsdWU6cn19fSxmdW5jdGlvbih1LGUpe3ZhciB0PXt9Lmhhc093blByb3BlcnR5O3UuZXhwb3J0cz1mdW5jdGlvbihyLG4pe3JldHVybiB0LmNhbGwocixuKX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9dCg5NSl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDEwOCksbj10KDEwNCksaT10KDEyMSksYT17fTt0KDk1KShhLHQoMTIyKSgiaXRlcmF0b3IiKSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSksdS5leHBvcnRzPWZ1bmN0aW9uKGwscyxmKXtsLnByb3RvdHlwZT1yKGEse25leHQ6bigxLGYpfSksaShsLHMrIiBJdGVyYXRvciIpfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTcpLG49dCgxMDkpLGk9dCgxMTkpLGE9dCgxMTYpKCJJRV9QUk9UTyIpLGw9ZnVuY3Rpb24oKXt9LHM9InByb3RvdHlwZSIsZj1mdW5jdGlvbigpe3ZhciB2PXQoMTAyKSgiaWZyYW1lIiksZD1pLmxlbmd0aCxwPSI8Iix5PSI+IixQO2Zvcih2LnN0eWxlLmRpc3BsYXk9Im5vbmUiLHQoMTIwKS5hcHBlbmRDaGlsZCh2KSx2LnNyYz0iamF2YXNjcmlwdDoiLFA9di5jb250ZW50V2luZG93LmRvY3VtZW50LFAub3BlbigpLFAud3JpdGUocCsic2NyaXB0Iit5KyJkb2N1bWVudC5GPU9iamVjdCIrcCsiL3NjcmlwdCIreSksUC5jbG9zZSgpLGY9UC5GO2QtLTspZGVsZXRlIGZbc11baVtkXV07cmV0dXJuIGYoKX07dS5leHBvcnRzPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKGQscCl7dmFyIHk7cmV0dXJuIGQhPT1udWxsPyhsW3NdPXIoZCkseT1uZXcgbCxsW3NdPW51bGwseVthXT1kKTp5PWYoKSxwPT09dm9pZCAwP3k6bih5LHApfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTYpLG49dCg5NyksaT10KDExMCk7dS5leHBvcnRzPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbihsLHMpe24obCk7Zm9yKHZhciBmPWkocyksdj1mLmxlbmd0aCxkPTAscDt2PmQ7KXIuZihsLHA9ZltkKytdLHNbcF0pO3JldHVybiBsfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTExKSxuPXQoMTE5KTt1LmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKGEpe3JldHVybiByKGEsbil9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMDUpLG49dCg4NCksaT10KDExMikoITEpLGE9dCgxMTYpKCJJRV9QUk9UTyIpO3UuZXhwb3J0cz1mdW5jdGlvbihsLHMpe3ZhciBmPW4obCksdj0wLGQ9W10scDtmb3IocCBpbiBmKXAhPWEmJnIoZixwKSYmZC5wdXNoKHApO2Zvcig7cy5sZW5ndGg+djspcihmLHA9c1t2KytdKSYmKH5pKGQscCl8fGQucHVzaChwKSk7cmV0dXJuIGR9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg4NCksbj10KDExMyksaT10KDExNSk7dS5leHBvcnRzPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihsLHMsZil7dmFyIHY9cihsKSxkPW4odi5sZW5ndGgpLHA9aShmLGQpLHk7aWYoYSYmcyE9cyl7Zm9yKDtkPnA7KWlmKHk9dltwKytdLHkhPXkpcmV0dXJuITB9ZWxzZSBmb3IoO2Q+cDtwKyspaWYoKGF8fHAgaW4gdikmJnZbcF09PT1zKXJldHVybiBhfHxwfHwwO3JldHVybiFhJiYtMX19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMTQpLG49TWF0aC5taW47dS5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiBpPjA/bihyKGkpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbih1LGUpe3ZhciB0PU1hdGguY2VpbCxyPU1hdGguZmxvb3I7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiBpc05hTihuPStuKT8wOihuPjA/cjp0KShuKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDExNCksbj1NYXRoLm1heCxpPU1hdGgubWluO3UuZXhwb3J0cz1mdW5jdGlvbihhLGwpe3JldHVybiBhPXIoYSksYTwwP24oYStsLDApOmkoYSxsKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDExNykoImtleXMiKSxuPXQoMTE4KTt1LmV4cG9ydHM9ZnVuY3Rpb24oaSl7cmV0dXJuIHJbaV18fChyW2ldPW4oaSkpfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTIpLG49dCg5MSksaT0iX19jb3JlLWpzX3NoYXJlZF9fIixhPW5baV18fChuW2ldPXt9KTsodS5leHBvcnRzPWZ1bmN0aW9uKGwscyl7cmV0dXJuIGFbbF18fChhW2xdPXMhPT12b2lkIDA/czp7fSl9KSgidmVyc2lvbnMiLFtdKS5wdXNoKHt2ZXJzaW9uOnIudmVyc2lvbixtb2RlOnQoODkpPyJwdXJlIjoiZ2xvYmFsIixjb3B5cmlnaHQ6IsKpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSkifSl9LGZ1bmN0aW9uKHUsZSl7dmFyIHQ9MCxyPU1hdGgucmFuZG9tKCk7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiJTeW1ib2woIi5jb25jYXQobj09PXZvaWQgMD8iIjpuLCIpXyIsKCsrdCtyKS50b1N0cmluZygzNikpfX0sZnVuY3Rpb24odSxlKXt1LmV4cG9ydHM9ImNvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZiIuc3BsaXQoIiwiKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLmRvY3VtZW50O3UuZXhwb3J0cz1yJiZyLmRvY3VtZW50RWxlbWVudH0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTYpLmYsbj10KDEwNSksaT10KDEyMikoInRvU3RyaW5nVGFnIik7dS5leHBvcnRzPWZ1bmN0aW9uKGEsbCxzKXthJiYhbihhPXM/YTphLnByb3RvdHlwZSxpKSYmcihhLGkse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpsfSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMTcpKCJ3a3MiKSxuPXQoMTE4KSxpPXQoOTEpLlN5bWJvbCxhPXR5cGVvZiBpPT0iZnVuY3Rpb24iLGw9dS5leHBvcnRzPWZ1bmN0aW9uKHMpe3JldHVybiByW3NdfHwocltzXT1hJiZpW3NdfHwoYT9pOm4pKCJTeW1ib2wuIitzKSl9O2wuc3RvcmU9cn0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTA1KSxuPXQoMTI0KSxpPXQoMTE2KSgiSUVfUFJPVE8iKSxhPU9iamVjdC5wcm90b3R5cGU7dS5leHBvcnRzPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24obCl7cmV0dXJuIGw9bihsKSxyKGwsaSk/bFtpXTp0eXBlb2YgbC5jb25zdHJ1Y3Rvcj09ImZ1bmN0aW9uIiYmbCBpbnN0YW5jZW9mIGwuY29uc3RydWN0b3I/bC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6bCBpbnN0YW5jZW9mIE9iamVjdD9hOm51bGx9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg4Nyk7dS5leHBvcnRzPWZ1bmN0aW9uKG4pe3JldHVybiBPYmplY3QocihuKSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMjYpKCEwKTt0KDg4KShTdHJpbmcsIlN0cmluZyIsZnVuY3Rpb24obil7dGhpcy5fdD1TdHJpbmcobiksdGhpcy5faT0wfSxmdW5jdGlvbigpe3ZhciBuPXRoaXMuX3QsaT10aGlzLl9pLGE7cmV0dXJuIGk+PW4ubGVuZ3RoP3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06KGE9cihuLGkpLHRoaXMuX2krPWEubGVuZ3RoLHt2YWx1ZTphLGRvbmU6ITF9KX0pfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMTQpLG49dCg4Nyk7dS5leHBvcnRzPWZ1bmN0aW9uKGkpe3JldHVybiBmdW5jdGlvbihhLGwpe3ZhciBzPVN0cmluZyhuKGEpKSxmPXIobCksdj1zLmxlbmd0aCxkLHA7cmV0dXJuIGY8MHx8Zj49dj9pPyIiOnZvaWQgMDooZD1zLmNoYXJDb2RlQXQoZiksZDw1NTI5Nnx8ZD41NjMxOXx8ZisxPT09dnx8KHA9cy5jaGFyQ29kZUF0KGYrMSkpPDU2MzIwfHxwPjU3MzQzP2k/cy5jaGFyQXQoZik6ZDppP3Muc2xpY2UoZixmKzIpOihkLTU1Mjk2PDwxMCkrKHAtNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMjgpLG49dCgxMjIpKCJpdGVyYXRvciIpLGk9dCg4Myk7dS5leHBvcnRzPXQoOTIpLmlzSXRlcmFibGU9ZnVuY3Rpb24oYSl7dmFyIGw9T2JqZWN0KGEpO3JldHVybiBsW25dIT09dm9pZCAwfHwiQEBpdGVyYXRvciJpbiBsfHxpLmhhc093blByb3BlcnR5KHIobCkpfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODYpLG49dCgxMjIpKCJ0b1N0cmluZ1RhZyIpLGk9cihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpPT0iQXJndW1lbnRzIixhPWZ1bmN0aW9uKGwscyl7dHJ5e3JldHVybiBsW3NdfWNhdGNoe319O3UuZXhwb3J0cz1mdW5jdGlvbihsKXt2YXIgcyxmLHY7cmV0dXJuIGw9PT12b2lkIDA/IlVuZGVmaW5lZCI6bD09PW51bGw/Ik51bGwiOnR5cGVvZihmPWEocz1PYmplY3QobCksbikpPT0ic3RyaW5nIj9mOmk/cihzKToodj1yKHMpKT09Ik9iamVjdCImJnR5cGVvZiBzLmNhbGxlZT09ImZ1bmN0aW9uIj8iQXJndW1lbnRzIjp2fX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17ZGVmYXVsdDp0KDEzMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHUsZSx0KXt0KDc5KSx0KDEyNSksdS5leHBvcnRzPXQoMTMxKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTcpLG49dCgxMzIpO3UuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvcj1mdW5jdGlvbihpKXt2YXIgYT1uKGkpO2lmKHR5cGVvZiBhIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihpKyIgaXMgbm90IGl0ZXJhYmxlISIpO3JldHVybiByKGEuY2FsbChpKSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMjgpLG49dCgxMjIpKCJpdGVyYXRvciIpLGk9dCg4Myk7dS5leHBvcnRzPXQoOTIpLmdldEl0ZXJhdG9yTWV0aG9kPWZ1bmN0aW9uKGEpe2lmKGEhPW51bGwpcmV0dXJuIGFbbl18fGFbIkBAaXRlcmF0b3IiXXx8aVtyKGEpXX19LGZ1bmN0aW9uKHUsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIHI9dCgxMzQpLG49aShyKTtmdW5jdGlvbiBpKGEpe3JldHVybiBhJiZhLl9fZXNNb2R1bGU/YTp7ZGVmYXVsdDphfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oYSl7aWYoQXJyYXkuaXNBcnJheShhKSl7Zm9yKHZhciBsPTAscz1BcnJheShhLmxlbmd0aCk7bDxhLmxlbmd0aDtsKyspc1tsXT1hW2xdO3JldHVybiBzfWVsc2UgcmV0dXJuKDAsbi5kZWZhdWx0KShhKX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih1LGUsdCl7dCgxMjUpLHQoMTM2KSx1LmV4cG9ydHM9dCg5MikuQXJyYXkuZnJvbX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTMpLG49dCg5MCksaT10KDEyNCksYT10KDEzNyksbD10KDEzOCkscz10KDExMyksZj10KDEzOSksdj10KDEzMik7bihuLlMrbi5GKiF0KDE0MCkoZnVuY3Rpb24oZCl7QXJyYXkuZnJvbShkKX0pLCJBcnJheSIse2Zyb206ZnVuY3Rpb24ocCl7dmFyIHk9aShwKSxQPXR5cGVvZiB0aGlzPT0iZnVuY3Rpb24iP3RoaXM6QXJyYXkseD1hcmd1bWVudHMubGVuZ3RoLG09eD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsTz1tIT09dm9pZCAwLG89MCxoPXYoeSksYyxnLGIsRTtpZihPJiYobT1yKG0seD4yP2FyZ3VtZW50c1syXTp2b2lkIDAsMikpLGghPW51bGwmJiEoUD09QXJyYXkmJmwoaCkpKWZvcihFPWguY2FsbCh5KSxnPW5ldyBQOyEoYj1FLm5leHQoKSkuZG9uZTtvKyspZihnLG8sTz9hKEUsbSxbYi52YWx1ZSxvXSwhMCk6Yi52YWx1ZSk7ZWxzZSBmb3IoYz1zKHkubGVuZ3RoKSxnPW5ldyBQKGMpO2M+bztvKyspZihnLG8sTz9tKHlbb10sbyk6eVtvXSk7cmV0dXJuIGcubGVuZ3RoPW8sZ319KX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTcpO3UuZXhwb3J0cz1mdW5jdGlvbihuLGksYSxsKXt0cnl7cmV0dXJuIGw/aShyKGEpWzBdLGFbMV0pOmkoYSl9Y2F0Y2goZil7dmFyIHM9bi5yZXR1cm47dGhyb3cgcyE9PXZvaWQgMCYmcihzLmNhbGwobikpLGZ9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODMpLG49dCgxMjIpKCJpdGVyYXRvciIpLGk9QXJyYXkucHJvdG90eXBlO3UuZXhwb3J0cz1mdW5jdGlvbihhKXtyZXR1cm4gYSE9PXZvaWQgMCYmKHIuQXJyYXk9PT1hfHxpW25dPT09YSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5Niksbj10KDEwNCk7dS5leHBvcnRzPWZ1bmN0aW9uKGksYSxsKXthIGluIGk/ci5mKGksYSxuKDAsbCkpOmlbYV09bH19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDEyMikoIml0ZXJhdG9yIiksbj0hMTt0cnl7dmFyIGk9WzddW3JdKCk7aS5yZXR1cm49ZnVuY3Rpb24oKXtuPSEwfSxBcnJheS5mcm9tKGksZnVuY3Rpb24oKXt0aHJvdyAyfSl9Y2F0Y2h7fXUuZXhwb3J0cz1mdW5jdGlvbihhLGwpe2lmKCFsJiYhbilyZXR1cm4hMTt2YXIgcz0hMTt0cnl7dmFyIGY9WzddLHY9ZltyXSgpO3YubmV4dD1mdW5jdGlvbigpe3JldHVybntkb25lOnM9ITB9fSxmW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHZ9LGEoZil9Y2F0Y2h7fXJldHVybiBzfX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17ZGVmYXVsdDp0KDE0MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHUsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTQ0KSx0KDE1NyksdCgxNjApLHQoMTYyKSx1LmV4cG9ydHM9dCg5MikuTWFwfSxmdW5jdGlvbih1LGUpe30sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTQ1KSxuPXQoMTUxKSxpPSJNYXAiO3UuZXhwb3J0cz10KDE1MikoaSxmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYSh0aGlzLGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKX19LHtnZXQ6ZnVuY3Rpb24obCl7dmFyIHM9ci5nZXRFbnRyeShuKHRoaXMsaSksbCk7cmV0dXJuIHMmJnMudn0sc2V0OmZ1bmN0aW9uKGwscyl7cmV0dXJuIHIuZGVmKG4odGhpcyxpKSxsPT09MD8wOmwscyl9fSxyLCEwKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTYpLmYsbj10KDEwOCksaT10KDE0NiksYT10KDkzKSxsPXQoMTQ3KSxzPXQoMTQ4KSxmPXQoODgpLHY9dCg4MiksZD10KDE0OSkscD10KDEwMCkseT10KDE1MCkuZmFzdEtleSxQPXQoMTUxKSx4PXA/Il9zIjoic2l6ZSIsbT1mdW5jdGlvbihPLG8pe3ZhciBoPXkobyksYztpZihoIT09IkYiKXJldHVybiBPLl9pW2hdO2ZvcihjPU8uX2Y7YztjPWMubilpZihjLms9PW8pcmV0dXJuIGN9O3UuZXhwb3J0cz17Z2V0Q29uc3RydWN0b3I6ZnVuY3Rpb24oTyxvLGgsYyl7dmFyIGc9TyhmdW5jdGlvbihiLEUpe2woYixnLG8sIl9pIiksYi5fdD1vLGIuX2k9bihudWxsKSxiLl9mPXZvaWQgMCxiLl9sPXZvaWQgMCxiW3hdPTAsRSE9bnVsbCYmcyhFLGgsYltjXSxiKX0pO3JldHVybiBpKGcucHJvdG90eXBlLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgRT1QKHRoaXMsbyksQT1FLl9pLEw9RS5fZjtMO0w9TC5uKUwucj0hMCxMLnAmJihMLnA9TC5wLm49dm9pZCAwKSxkZWxldGUgQVtMLmldO0UuX2Y9RS5fbD12b2lkIDAsRVt4XT0wfSxkZWxldGU6ZnVuY3Rpb24oYil7dmFyIEU9UCh0aGlzLG8pLEE9bShFLGIpO2lmKEEpe3ZhciBMPUEubixNPUEucDtkZWxldGUgRS5faVtBLmldLEEucj0hMCxNJiYoTS5uPUwpLEwmJihMLnA9TSksRS5fZj09QSYmKEUuX2Y9TCksRS5fbD09QSYmKEUuX2w9TSksRVt4XS0tfXJldHVybiEhQX0sZm9yRWFjaDpmdW5jdGlvbihFKXtQKHRoaXMsbyk7Zm9yKHZhciBBPWEoRSxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCwzKSxMO0w9TD9MLm46dGhpcy5fZjspZm9yKEEoTC52LEwuayx0aGlzKTtMJiZMLnI7KUw9TC5wfSxoYXM6ZnVuY3Rpb24oRSl7cmV0dXJuISFtKFAodGhpcyxvKSxFKX19KSxwJiZyKGcucHJvdG90eXBlLCJzaXplIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFAodGhpcyxvKVt4XX19KSxnfSxkZWY6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPW0oTyxvKSxnLGI7cmV0dXJuIGM/Yy52PWg6KE8uX2w9Yz17aTpiPXkobywhMCksazpvLHY6aCxwOmc9Ty5fbCxuOnZvaWQgMCxyOiExfSxPLl9mfHwoTy5fZj1jKSxnJiYoZy5uPWMpLE9beF0rKyxiIT09IkYiJiYoTy5faVtiXT1jKSksT30sZ2V0RW50cnk6bSxzZXRTdHJvbmc6ZnVuY3Rpb24oTyxvLGgpe2YoTyxvLGZ1bmN0aW9uKGMsZyl7dGhpcy5fdD1QKGMsbyksdGhpcy5faz1nLHRoaXMuX2w9dm9pZCAwfSxmdW5jdGlvbigpe2Zvcih2YXIgYz10aGlzLGc9Yy5fayxiPWMuX2w7YiYmYi5yOyliPWIucDtyZXR1cm4hYy5fdHx8IShjLl9sPWI9Yj9iLm46Yy5fdC5fZik/KGMuX3Q9dm9pZCAwLHYoMSkpOmc9PSJrZXlzIj92KDAsYi5rKTpnPT0idmFsdWVzIj92KDAsYi52KTp2KDAsW2IuayxiLnZdKX0saD8iZW50cmllcyI6InZhbHVlcyIsIWgsITApLGQobyl9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTUpO3UuZXhwb3J0cz1mdW5jdGlvbihuLGksYSl7Zm9yKHZhciBsIGluIGkpYSYmbltsXT9uW2xdPWlbbF06cihuLGwsaVtsXSk7cmV0dXJuIG59fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbih0LHIsbixpKXtpZighKHQgaW5zdGFuY2VvZiByKXx8aSE9PXZvaWQgMCYmaSBpbiB0KXRocm93IFR5cGVFcnJvcihuKyI6IGluY29ycmVjdCBpbnZvY2F0aW9uISIpO3JldHVybiB0fX0sZnVuY3Rpb24odSxkLHQpe3ZhciByPXQoOTMpLG49dCgxMzcpLGk9dCgxMzgpLGE9dCg5NyksbD10KDExMykscz10KDEzMiksZj17fSx2PXt9LGQ9dS5leHBvcnRzPWZ1bmN0aW9uKHAseSxQLHgsbSl7dmFyIE89bT9mdW5jdGlvbigpe3JldHVybiBwfTpzKHApLG89cihQLHgseT8yOjEpLGg9MCxjLGcsYixFO2lmKHR5cGVvZiBPIT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcihwKyIgaXMgbm90IGl0ZXJhYmxlISIpO2lmKGkoTykpe2ZvcihjPWwocC5sZW5ndGgpO2M+aDtoKyspaWYoRT15P28oYShnPXBbaF0pWzBdLGdbMV0pOm8ocFtoXSksRT09PWZ8fEU9PT12KXJldHVybiBFfWVsc2UgZm9yKGI9Ty5jYWxsKHApOyEoZz1iLm5leHQoKSkuZG9uZTspaWYoRT1uKGIsbyxnLnZhbHVlLHkpLEU9PT1mfHxFPT09dilyZXR1cm4gRX07ZC5CUkVBSz1mLGQuUkVUVVJOPXZ9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkxKSxuPXQoOTIpLGk9dCg5NiksYT10KDEwMCksbD10KDEyMikoInNwZWNpZXMiKTt1LmV4cG9ydHM9ZnVuY3Rpb24ocyl7dmFyIGY9dHlwZW9mIG5bc109PSJmdW5jdGlvbiI/bltzXTpyW3NdO2EmJmYmJiFmW2xdJiZpLmYoZixsLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9fSl9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMTgpKCJtZXRhIiksbj10KDk4KSxpPXQoMTA1KSxhPXQoOTYpLmYsbD0wLHM9T2JqZWN0LmlzRXh0ZW5zaWJsZXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZj0hdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIHMoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSx2PWZ1bmN0aW9uKHgpe2EoeCxyLHt2YWx1ZTp7aToiTyIrICsrbCx3Ont9fX0pfSxkPWZ1bmN0aW9uKHgsbSl7aWYoIW4oeCkpcmV0dXJuIHR5cGVvZiB4PT0ic3ltYm9sIj94Oih0eXBlb2YgeD09InN0cmluZyI/IlMiOiJQIikreDtpZighaSh4LHIpKXtpZighcyh4KSlyZXR1cm4iRiI7aWYoIW0pcmV0dXJuIkUiO3YoeCl9cmV0dXJuIHhbcl0uaX0scD1mdW5jdGlvbih4LG0pe2lmKCFpKHgscikpe2lmKCFzKHgpKXJldHVybiEwO2lmKCFtKXJldHVybiExO3YoeCl9cmV0dXJuIHhbcl0ud30seT1mdW5jdGlvbih4KXtyZXR1cm4gZiYmUC5ORUVEJiZzKHgpJiYhaSh4LHIpJiZ2KHgpLHh9LFA9dS5leHBvcnRzPXtLRVk6cixORUVEOiExLGZhc3RLZXk6ZCxnZXRXZWFrOnAsb25GcmVlemU6eX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDk4KTt1LmV4cG9ydHM9ZnVuY3Rpb24obixpKXtpZighcihuKXx8bi5fdCE9PWkpdGhyb3cgVHlwZUVycm9yKCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICIraSsiIHJlcXVpcmVkISIpO3JldHVybiBufX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLG49dCg5MCksaT10KDE1MCksYT10KDEwMSksbD10KDk1KSxzPXQoMTQ2KSxmPXQoMTQ4KSx2PXQoMTQ3KSxkPXQoOTgpLHA9dCgxMjEpLHk9dCg5NikuZixQPXQoMTUzKSgwKSx4PXQoMTAwKTt1LmV4cG9ydHM9ZnVuY3Rpb24obSxPLG8saCxjLGcpe3ZhciBiPXJbbV0sRT1iLEE9Yz8ic2V0IjoiYWRkIixMPUUmJkUucHJvdG90eXBlLE09e307cmV0dXJuIXh8fHR5cGVvZiBFIT0iZnVuY3Rpb24ifHwhKGd8fEwuZm9yRWFjaCYmIWEoZnVuY3Rpb24oKXtuZXcgRSgpLmVudHJpZXMoKS5uZXh0KCl9KSk/KEU9aC5nZXRDb25zdHJ1Y3RvcihPLG0sYyxBKSxzKEUucHJvdG90eXBlLG8pLGkuTkVFRD0hMCk6KEU9TyhmdW5jdGlvbihJLEQpe3YoSSxFLG0sIl9jIiksSS5fYz1uZXcgYixEIT1udWxsJiZmKEQsYyxJW0FdLEkpfSksUCgiYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OIi5zcGxpdCgiLCIpLGZ1bmN0aW9uKEkpe3ZhciBEPUk9PSJhZGQifHxJPT0ic2V0IjtJIGluIEwmJiEoZyYmST09ImNsZWFyIikmJmwoRS5wcm90b3R5cGUsSSxmdW5jdGlvbihSLEMpe2lmKHYodGhpcyxFLEkpLCFEJiZnJiYhZChSKSlyZXR1cm4gST09ImdldCI/dm9pZCAwOiExO3ZhciBCPXRoaXMuX2NbSV0oUj09PTA/MDpSLEMpO3JldHVybiBEP3RoaXM6Qn0pfSksZ3x8eShFLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jLnNpemV9fSkpLHAoRSxtKSxNW21dPUUsbihuLkcrbi5XK24uRixNKSxnfHxoLnNldFN0cm9uZyhFLG0sYyksRX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkzKSxuPXQoODUpLGk9dCgxMjQpLGE9dCgxMTMpLGw9dCgxNTQpO3UuZXhwb3J0cz1mdW5jdGlvbihzLGYpe3ZhciB2PXM9PTEsZD1zPT0yLHA9cz09Myx5PXM9PTQsUD1zPT02LHg9cz09NXx8UCxtPWZ8fGw7cmV0dXJuIGZ1bmN0aW9uKE8sbyxoKXtmb3IodmFyIGM9aShPKSxnPW4oYyksYj1yKG8saCwzKSxFPWEoZy5sZW5ndGgpLEE9MCxMPXY/bShPLEUpOmQ/bShPLDApOnZvaWQgMCxNLEk7RT5BO0ErKylpZigoeHx8QSBpbiBnKSYmKE09Z1tBXSxJPWIoTSxBLGMpLHMpKXtpZih2KUxbQV09STtlbHNlIGlmKEkpc3dpdGNoKHMpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIE07Y2FzZSA2OnJldHVybiBBO2Nhc2UgMjpMLnB1c2goTSl9ZWxzZSBpZih5KXJldHVybiExfXJldHVybiBQPy0xOnB8fHk/eTpMfX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDE1NSk7dS5leHBvcnRzPWZ1bmN0aW9uKG4saSl7cmV0dXJuIG5ldyhyKG4pKShpKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDk4KSxuPXQoMTU2KSxpPXQoMTIyKSgic3BlY2llcyIpO3UuZXhwb3J0cz1mdW5jdGlvbihhKXt2YXIgbDtyZXR1cm4gbihhKSYmKGw9YS5jb25zdHJ1Y3Rvcix0eXBlb2YgbD09ImZ1bmN0aW9uIiYmKGw9PT1BcnJheXx8bihsLnByb3RvdHlwZSkpJiYobD12b2lkIDApLHIobCkmJihsPWxbaV0sbD09PW51bGwmJihsPXZvaWQgMCkpKSxsPT09dm9pZCAwP0FycmF5Omx9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg4Nik7dS5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGkpe3JldHVybiByKGkpPT0iQXJyYXkifX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTApO3Ioci5QK3IuUiwiTWFwIix7dG9KU09OOnQoMTU4KSgiTWFwIil9KX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTI4KSxuPXQoMTU5KTt1LmV4cG9ydHM9ZnVuY3Rpb24oaSl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYocih0aGlzKSE9aSl0aHJvdyBUeXBlRXJyb3IoaSsiI3RvSlNPTiBpc24ndCBnZW5lcmljIik7cmV0dXJuIG4odGhpcyl9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTQ4KTt1LmV4cG9ydHM9ZnVuY3Rpb24obixpKXt2YXIgYT1bXTtyZXR1cm4gcihuLCExLGEucHVzaCxhLGkpLGF9fSxmdW5jdGlvbih1LGUsdCl7dCgxNjEpKCJNYXAiKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTApO3UuZXhwb3J0cz1mdW5jdGlvbihuKXtyKHIuUyxuLHtvZjpmdW5jdGlvbigpe2Zvcih2YXIgYT1hcmd1bWVudHMubGVuZ3RoLGw9bmV3IEFycmF5KGEpO2EtLTspbFthXT1hcmd1bWVudHNbYV07cmV0dXJuIG5ldyB0aGlzKGwpfX0pfX0sZnVuY3Rpb24odSxlLHQpe3QoMTYzKSgiTWFwIil9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkwKSxuPXQoOTQpLGk9dCg5MyksYT10KDE0OCk7dS5leHBvcnRzPWZ1bmN0aW9uKGwpe3Ioci5TLGwse2Zyb206ZnVuY3Rpb24oZil7dmFyIHY9YXJndW1lbnRzWzFdLGQscCx5LFA7cmV0dXJuIG4odGhpcyksZD12IT09dm9pZCAwLGQmJm4odiksZj09bnVsbD9uZXcgdGhpczoocD1bXSxkPyh5PTAsUD1pKHYsYXJndW1lbnRzWzJdLDIpLGEoZiwhMSxmdW5jdGlvbih4KXtwLnB1c2goUCh4LHkrKykpfSkpOmEoZiwhMSxwLnB1c2gscCksbmV3IHRoaXMocCkpfX0pfX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17ZGVmYXVsdDp0KDE2NSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHUsZSx0KXt0KDE2NiksdS5leHBvcnRzPXQoOTIpLk9iamVjdC5hc3NpZ259LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkwKTtyKHIuUytyLkYsIk9iamVjdCIse2Fzc2lnbjp0KDE2Nyl9KX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTAwKSxuPXQoMTEwKSxpPXQoMTY4KSxhPXQoMTY5KSxsPXQoMTI0KSxzPXQoODUpLGY9T2JqZWN0LmFzc2lnbjt1LmV4cG9ydHM9IWZ8fHQoMTAxKShmdW5jdGlvbigpe3ZhciB2PXt9LGQ9e30scD1TeW1ib2woKSx5PSJhYmNkZWZnaGlqa2xtbm9wcXJzdCI7cmV0dXJuIHZbcF09Nyx5LnNwbGl0KCIiKS5mb3JFYWNoKGZ1bmN0aW9uKFApe2RbUF09UH0pLGYoe30sdilbcF0hPTd8fE9iamVjdC5rZXlzKGYoe30sZCkpLmpvaW4oIiIpIT15fSk/ZnVuY3Rpb24oZCxwKXtmb3IodmFyIHk9bChkKSxQPWFyZ3VtZW50cy5sZW5ndGgseD0xLG09aS5mLE89YS5mO1A+eDspZm9yKHZhciBvPXMoYXJndW1lbnRzW3grK10pLGg9bT9uKG8pLmNvbmNhdChtKG8pKTpuKG8pLGM9aC5sZW5ndGgsZz0wLGI7Yz5nOyliPWhbZysrXSwoIXJ8fE8uY2FsbChvLGIpKSYmKHlbYl09b1tiXSk7cmV0dXJuIHl9OmZ9LGZ1bmN0aW9uKHUsZSl7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LGZ1bmN0aW9uKHUsZSl7ZS5mPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlfSxmdW5jdGlvbih1LGUsdCl7ZS5fX2VzTW9kdWxlPSEwLGUuZGVmYXVsdD1mdW5jdGlvbihyLG4pe2lmKCEociBpbnN0YW5jZW9mIG4pKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfX0sZnVuY3Rpb24odSxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgcj10KDE3Miksbj1pKHIpO2Z1bmN0aW9uIGkoYSl7cmV0dXJuIGEmJmEuX19lc01vZHVsZT9hOntkZWZhdWx0OmF9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGEobCxzKXtmb3IodmFyIGY9MDtmPHMubGVuZ3RoO2YrKyl7dmFyIHY9c1tmXTt2LmVudW1lcmFibGU9di5lbnVtZXJhYmxlfHwhMSx2LmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gdiYmKHYud3JpdGFibGU9ITApLCgwLG4uZGVmYXVsdCkobCx2LmtleSx2KX19cmV0dXJuIGZ1bmN0aW9uKGwscyxmKXtyZXR1cm4gcyYmYShsLnByb3RvdHlwZSxzKSxmJiZhKGwsZiksbH19KCl9LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9e2RlZmF1bHQ6dCgxNzMpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih1LGUsdCl7dCgxNzQpO3ZhciByPXQoOTIpLk9iamVjdDt1LmV4cG9ydHM9ZnVuY3Rpb24oaSxhLGwpe3JldHVybiByLmRlZmluZVByb3BlcnR5KGksYSxsKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDkwKTtyKHIuUytyLkYqIXQoMTAwKSwiT2JqZWN0Iix7ZGVmaW5lUHJvcGVydHk6dCg5NikuZn0pfSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXtkZWZhdWx0OnQoMTc2KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odSxlLHQpe3QoMTc3KSx0KDE0MyksdCgxODQpLHQoMTg1KSx1LmV4cG9ydHM9dCg5MikuU3ltYm9sfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MSksbj10KDEwNSksaT10KDEwMCksYT10KDkwKSxsPXQoMTA2KSxzPXQoMTUwKS5LRVksZj10KDEwMSksdj10KDExNyksZD10KDEyMSkscD10KDExOCkseT10KDEyMiksUD10KDE3OCkseD10KDE3OSksbT10KDE4MCksTz10KDE1Niksbz10KDk3KSxoPXQoOTgpLGM9dCgxMjQpLGc9dCg4NCksYj10KDEwMyksRT10KDEwNCksQT10KDEwOCksTD10KDE4MSksTT10KDE4MyksST10KDE2OCksRD10KDk2KSxSPXQoMTEwKSxDPU0uZixCPUQuZix6PUwuZixLPXIuU3ltYm9sLFE9ci5KU09OLF89USYmUS5zdHJpbmdpZnksRj0icHJvdG90eXBlIixHPXkoIl9oaWRkZW4iKSxYPXkoInRvUHJpbWl0aXZlIiksWj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSx0dD12KCJzeW1ib2wtcmVnaXN0cnkiKSxudD12KCJzeW1ib2xzIikscT12KCJvcC1zeW1ib2xzIiksaHQ9T2JqZWN0W0ZdLHV0PXR5cGVvZiBLPT0iZnVuY3Rpb24iJiYhIUkuZixqPXIuUU9iamVjdCxXPSFqfHwhaltGXXx8IWpbRl0uZmluZENoaWxkLFY9aSYmZihmdW5jdGlvbigpe3JldHVybiBBKEIoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQih0aGlzLCJhIix7dmFsdWU6N30pLmF9fSkpLmEhPTd9KT9mdW5jdGlvbihvdCxzdCxjdCl7dmFyIG10PUMoaHQsc3QpO210JiZkZWxldGUgaHRbc3RdLEIob3Qsc3QsY3QpLG10JiZvdCE9PWh0JiZCKGh0LHN0LG10KX06QixKPWZ1bmN0aW9uKG90KXt2YXIgc3Q9bnRbb3RdPUEoS1tGXSk7cmV0dXJuIHN0Ll9rPW90LHN0fSxOPXV0JiZ0eXBlb2YgSy5pdGVyYXRvcj09InN5bWJvbCI/ZnVuY3Rpb24ob3Qpe3JldHVybiB0eXBlb2Ygb3Q9PSJzeW1ib2wifTpmdW5jdGlvbihvdCl7cmV0dXJuIG90IGluc3RhbmNlb2YgS30sJD1mdW5jdGlvbihzdCxjdCxtdCl7cmV0dXJuIHN0PT09aHQmJiQocSxjdCxtdCksbyhzdCksY3Q9YihjdCwhMCksbyhtdCksbihudCxjdCk/KG10LmVudW1lcmFibGU/KG4oc3QsRykmJnN0W0ddW2N0XSYmKHN0W0ddW2N0XT0hMSksbXQ9QShtdCx7ZW51bWVyYWJsZTpFKDAsITEpfSkpOihuKHN0LEcpfHxCKHN0LEcsRSgxLHt9KSksc3RbR11bY3RdPSEwKSxWKHN0LGN0LG10KSk6QihzdCxjdCxtdCl9LFM9ZnVuY3Rpb24oc3QsY3Qpe28oc3QpO2Zvcih2YXIgbXQ9bShjdD1nKGN0KSksdnQ9MCxndD1tdC5sZW5ndGgsU3Q7Z3Q+dnQ7KSQoc3QsU3Q9bXRbdnQrK10sY3RbU3RdKTtyZXR1cm4gc3R9LFQ9ZnVuY3Rpb24oc3QsY3Qpe3JldHVybiBjdD09PXZvaWQgMD9BKHN0KTpTKEEoc3QpLGN0KX0sdz1mdW5jdGlvbihzdCl7dmFyIGN0PVouY2FsbCh0aGlzLHN0PWIoc3QsITApKTtyZXR1cm4gdGhpcz09PWh0JiZuKG50LHN0KSYmIW4ocSxzdCk/ITE6Y3R8fCFuKHRoaXMsc3QpfHwhbihudCxzdCl8fG4odGhpcyxHKSYmdGhpc1tHXVtzdF0/Y3Q6ITB9LFU9ZnVuY3Rpb24oc3QsY3Qpe2lmKHN0PWcoc3QpLGN0PWIoY3QsITApLCEoc3Q9PT1odCYmbihudCxjdCkmJiFuKHEsY3QpKSl7dmFyIG10PUMoc3QsY3QpO3JldHVybiBtdCYmbihudCxjdCkmJiEobihzdCxHKSYmc3RbR11bY3RdKSYmKG10LmVudW1lcmFibGU9ITApLG10fX0sSD1mdW5jdGlvbihzdCl7Zm9yKHZhciBjdD16KGcoc3QpKSxtdD1bXSx2dD0wLGd0O2N0Lmxlbmd0aD52dDspIW4obnQsZ3Q9Y3RbdnQrK10pJiZndCE9RyYmZ3QhPXMmJm10LnB1c2goZ3QpO3JldHVybiBtdH0sWT1mdW5jdGlvbihzdCl7Zm9yKHZhciBjdD1zdD09PWh0LG10PXooY3Q/cTpnKHN0KSksdnQ9W10sZ3Q9MCxTdDttdC5sZW5ndGg+Z3Q7KW4obnQsU3Q9bXRbZ3QrK10pJiYoIWN0fHxuKGh0LFN0KSkmJnZ0LnB1c2gobnRbU3RdKTtyZXR1cm4gdnR9O3V0fHwoSz1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBLKXRocm93IFR5cGVFcnJvcigiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yISIpO3ZhciBzdD1wKGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKSxjdD1mdW5jdGlvbihtdCl7dGhpcz09PWh0JiZjdC5jYWxsKHEsbXQpLG4odGhpcyxHKSYmbih0aGlzW0ddLHN0KSYmKHRoaXNbR11bc3RdPSExKSxWKHRoaXMsc3QsRSgxLG10KSl9O3JldHVybiBpJiZXJiZWKGh0LHN0LHtjb25maWd1cmFibGU6ITAsc2V0OmN0fSksSihzdCl9LGwoS1tGXSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2t9KSxNLmY9VSxELmY9JCx0KDE4MikuZj1MLmY9SCx0KDE2OSkuZj13LEkuZj1ZLGkmJiF0KDg5KSYmbChodCwicHJvcGVydHlJc0VudW1lcmFibGUiLHcsITApLFAuZj1mdW5jdGlvbihvdCl7cmV0dXJuIEooeShvdCkpfSksYShhLkcrYS5XK2EuRiohdXQse1N5bWJvbDpLfSk7Zm9yKHZhciBrPSJoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcyIuc3BsaXQoIiwiKSxydD0wO2subGVuZ3RoPnJ0Oyl5KGtbcnQrK10pO2Zvcih2YXIgaXQ9Uih5LnN0b3JlKSxsdD0wO2l0Lmxlbmd0aD5sdDspeChpdFtsdCsrXSk7YShhLlMrYS5GKiF1dCwiU3ltYm9sIix7Zm9yOmZ1bmN0aW9uKG90KXtyZXR1cm4gbih0dCxvdCs9IiIpP3R0W290XTp0dFtvdF09SyhvdCl9LGtleUZvcjpmdW5jdGlvbihzdCl7aWYoIU4oc3QpKXRocm93IFR5cGVFcnJvcihzdCsiIGlzIG5vdCBhIHN5bWJvbCEiKTtmb3IodmFyIGN0IGluIHR0KWlmKHR0W2N0XT09PXN0KXJldHVybiBjdH0sdXNlU2V0dGVyOmZ1bmN0aW9uKCl7Vz0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7Vz0hMX19KSxhKGEuUythLkYqIXV0LCJPYmplY3QiLHtjcmVhdGU6VCxkZWZpbmVQcm9wZXJ0eTokLGRlZmluZVByb3BlcnRpZXM6UyxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6VSxnZXRPd25Qcm9wZXJ0eU5hbWVzOkgsZ2V0T3duUHJvcGVydHlTeW1ib2xzOll9KTt2YXIgZnQ9ZihmdW5jdGlvbigpe0kuZigxKX0pO2EoYS5TK2EuRipmdCwiT2JqZWN0Iix7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKHN0KXtyZXR1cm4gSS5mKGMoc3QpKX19KSxRJiZhKGEuUythLkYqKCF1dHx8ZihmdW5jdGlvbigpe3ZhciBvdD1LKCk7cmV0dXJuIF8oW290XSkhPSJbbnVsbF0ifHxfKHthOm90fSkhPSJ7fSJ8fF8oT2JqZWN0KG90KSkhPSJ7fSJ9KSksIkpTT04iLHtzdHJpbmdpZnk6ZnVuY3Rpb24oc3Qpe2Zvcih2YXIgY3Q9W3N0XSxtdD0xLHZ0LGd0O2FyZ3VtZW50cy5sZW5ndGg+bXQ7KWN0LnB1c2goYXJndW1lbnRzW210KytdKTtpZihndD12dD1jdFsxXSwhKCFoKHZ0KSYmc3Q9PT12b2lkIDB8fE4oc3QpKSlyZXR1cm4gTyh2dCl8fCh2dD1mdW5jdGlvbihTdCxBdCl7aWYodHlwZW9mIGd0PT0iZnVuY3Rpb24iJiYoQXQ9Z3QuY2FsbCh0aGlzLFN0LEF0KSksIU4oQXQpKXJldHVybiBBdH0pLGN0WzFdPXZ0LF8uYXBwbHkoUSxjdCl9fSksS1tGXVtYXXx8dCg5NSkoS1tGXSxYLEtbRl0udmFsdWVPZiksZChLLCJTeW1ib2wiKSxkKE1hdGgsIk1hdGgiLCEwKSxkKHIuSlNPTiwiSlNPTiIsITApfSxmdW5jdGlvbih1LGUsdCl7ZS5mPXQoMTIyKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLG49dCg5MiksaT10KDg5KSxhPXQoMTc4KSxsPXQoOTYpLmY7dS5leHBvcnRzPWZ1bmN0aW9uKHMpe3ZhciBmPW4uU3ltYm9sfHwobi5TeW1ib2w9aT97fTpyLlN5bWJvbHx8e30pO3MuY2hhckF0KDApIT0iXyImJiEocyBpbiBmKSYmbChmLHMse3ZhbHVlOmEuZihzKX0pfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTEwKSxuPXQoMTY4KSxpPXQoMTY5KTt1LmV4cG9ydHM9ZnVuY3Rpb24oYSl7dmFyIGw9cihhKSxzPW4uZjtpZihzKWZvcih2YXIgZj1zKGEpLHY9aS5mLGQ9MCxwO2YubGVuZ3RoPmQ7KXYuY2FsbChhLHA9ZltkKytdKSYmbC5wdXNoKHApO3JldHVybiBsfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoODQpLG49dCgxODIpLmYsaT17fS50b1N0cmluZyxhPXR5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W10sbD1mdW5jdGlvbihzKXt0cnl7cmV0dXJuIG4ocyl9Y2F0Y2h7cmV0dXJuIGEuc2xpY2UoKX19O3UuZXhwb3J0cy5mPWZ1bmN0aW9uKGYpe3JldHVybiBhJiZpLmNhbGwoZik9PSJbb2JqZWN0IFdpbmRvd10iP2woZik6bihyKGYpKX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDExMSksbj10KDExOSkuY29uY2F0KCJsZW5ndGgiLCJwcm90b3R5cGUiKTtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKGEpe3JldHVybiByKGEsbil9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxNjkpLG49dCgxMDQpLGk9dCg4NCksYT10KDEwMyksbD10KDEwNSkscz10KDk5KSxmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPXQoMTAwKT9mOmZ1bmN0aW9uKGQscCl7aWYoZD1pKGQpLHA9YShwLCEwKSxzKXRyeXtyZXR1cm4gZihkLHApfWNhdGNoe31pZihsKGQscCkpcmV0dXJuIG4oIXIuZi5jYWxsKGQscCksZFtwXSl9fSxmdW5jdGlvbih1LGUsdCl7dCgxNzkpKCJhc3luY0l0ZXJhdG9yIil9LGZ1bmN0aW9uKHUsZSx0KXt0KDE3OSkoIm9ic2VydmFibGUiKX0sZnVuY3Rpb24odSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmNyZWF0ZU5vd1RpbWU9cixlLmZvcm1hdERlbGF5PW47ZnVuY3Rpb24gcigpe3ZhciBpPW51bGw7cmV0dXJuIERhdGUubm93P2k9RGF0ZS5ub3c6aT1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKX0saX1mdW5jdGlvbiBuKGkpe3JldHVybiB0eXBlb2YgaT09Im51bWJlciI/aT17ZGVsYXk6aX06ImVudHJvcHkiaW4gaSYmKGk9e2RlbGF5OmkuZW50cm9weSxpc0VudHJvcHk6ITB9KSxpfX0sZnVuY3Rpb24odSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9e2RlZmF1bHQ6ZnVuY3Rpb24obixpLGEsbCxzKXtyZXR1cm4gdHlwZW9mIG49PSJudW1iZXIiJiZ0eXBlb2YgaT09Im51bWJlciI/bisoYS1sKS8ocy1sKSooaS1uKTphLWw+cy1hP2k6bn19fSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUucGFyc2VFYXNpbmc9ZS5FYXNpbmdzPXZvaWQgMDt2YXIgcj10KDc2KSxuPWYociksaT10KDEzMyksYT1mKGkpLGw9dCgxNDEpLHM9ZihsKTtmdW5jdGlvbiBmKE8pe3JldHVybiBPJiZPLl9fZXNNb2R1bGU/Tzp7ZGVmYXVsdDpPfX12YXIgdj10KDE4OSksZD1uZXcgcy5kZWZhdWx0O2Z1bmN0aW9uIHAoKXtmb3IodmFyIE89YXJndW1lbnRzLmxlbmd0aCxvPUFycmF5KE8pLGg9MDtoPE87aCsrKW9baF09YXJndW1lbnRzW2hdO3ZhciBjPWQuZ2V0KG8pO3JldHVybiBjfHwoYz12LmFwcGx5KHZvaWQgMCxvKSxkLnNldChvLGMpLGMpfWZ1bmN0aW9uIHkoTyl7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiJlbmQiO3JldHVybiBmdW5jdGlvbihoLGMpe2Zvcih2YXIgZz0xO2c8Yy5sZW5ndGg7ZysrKXt2YXIgYj1jW2ddLm9mZnNldDtpZihoPD1iKXt2YXIgRT1jW2ctMV0ub2Zmc2V0LEE9YixMPShoLUUpLyhBLUUpLE09MS9PLEk9TC9NO3JldHVybiBvPT09ImVuZCI/ST1NYXRoLmZsb29yKEkpOkk9TWF0aC5jZWlsKEkpLE0qSSooQS1FKStFfX1yZXR1cm4gMH19ZnVuY3Rpb24gUChPKXt2YXIgbz0vXmN1YmljLWJlemllclwoKC4qKVwpLyxoPU8ubWF0Y2gobyk7aWYoaCl7dmFyIGM9aFsxXS50cmltKCk7cmV0dXJuIGM9Yy5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihNKXtyZXR1cm4gcGFyc2VGbG9hdChNLnRyaW0oKSl9KSxwLmFwcGx5KHZvaWQgMCwoMCxhLmRlZmF1bHQpKGMpKX1pZihvPS9ec3RlcHNcKCguKilcKS8saD1PLm1hdGNoKG8pLGgpe3ZhciBnPWhbMV0udHJpbSgpO2c9Zy5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihNKXtyZXR1cm4gTS50cmltKCl9KTt2YXIgYj1nLEU9KDAsbi5kZWZhdWx0KShiLDIpLEE9RVswXSxMPUVbMV07cmV0dXJuIHkocGFyc2VJbnQoQSwxMCksTCl9cmV0dXJuIE99dmFyIHg9e2xpbmVhcjpmdW5jdGlvbihvKXtyZXR1cm4gb30sZWFzZTpwKC4yNSwuMSwuMjUsMSksImVhc2UtaW4iOnAoLjQyLDAsMSwxKSwiZWFzZS1vdXQiOnAoMCwwLC41OCwxKSwiZWFzZS1pbi1vdXQiOnAoLjQyLDAsLjU4LDEpLCJzdGVwLXN0YXJ0Ijp5KDEsInN0YXJ0IiksInN0ZXAtZW5kIjp5KDEsImVuZCIpfTtmdW5jdGlvbiBtKE8pe3JldHVybiB0eXBlb2YgTz09InN0cmluZyI/eFtPXT9PPXhbT106Tz1QKE8pOk8udHlwZT09PSJjdWJpYy1iZXppZXIiP089cC5hcHBseSh2b2lkIDAsKDAsYS5kZWZhdWx0KShPLnZhbHVlKSk6Ty50eXBlPT09InN0ZXBzIiYmKE89eShPLnN0ZXAsTy5wb3MpKSxPfWUuRWFzaW5ncz14LGUucGFyc2VFYXNpbmc9bX0sZnVuY3Rpb24odSxlKXt2YXIgdD00LHI9LjAwMSxuPTFlLTcsaT0xMCxhPTExLGw9MS8oYS0xKSxzPXR5cGVvZiBGbG9hdDMyQXJyYXk9PSJmdW5jdGlvbiI7ZnVuY3Rpb24gZihPLG8pe3JldHVybiAxLTMqbyszKk99ZnVuY3Rpb24gdihPLG8pe3JldHVybiAzKm8tNipPfWZ1bmN0aW9uIGQoTyl7cmV0dXJuIDMqT31mdW5jdGlvbiBwKE8sbyxoKXtyZXR1cm4oKGYobyxoKSpPK3YobyxoKSkqTytkKG8pKSpPfWZ1bmN0aW9uIHkoTyxvLGgpe3JldHVybiAzKmYobyxoKSpPKk8rMip2KG8saCkqTytkKG8pfWZ1bmN0aW9uIFAoTyxvLGgsYyxnKXt2YXIgYixFLEE9MDtkbyBFPW8rKGgtbykvMixiPXAoRSxjLGcpLU8sYj4wP2g9RTpvPUU7d2hpbGUoTWF0aC5hYnMoYik+biYmKytBPGkpO3JldHVybiBFfWZ1bmN0aW9uIHgoTyxvLGgsYyl7Zm9yKHZhciBnPTA7Zzx0OysrZyl7dmFyIGI9eShvLGgsYyk7aWYoYj09PTApcmV0dXJuIG87dmFyIEU9cChvLGgsYyktTztvLT1FL2J9cmV0dXJuIG99ZnVuY3Rpb24gbShPKXtyZXR1cm4gT311LmV4cG9ydHM9ZnVuY3Rpb24obyxoLGMsZyl7aWYoISgwPD1vJiZvPD0xJiYwPD1jJiZjPD0xKSl0aHJvdyBuZXcgRXJyb3IoImJlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZSIpO2lmKG89PT1oJiZjPT09ZylyZXR1cm4gbTtmb3IodmFyIGI9cz9uZXcgRmxvYXQzMkFycmF5KGEpOm5ldyBBcnJheShhKSxFPTA7RTxhOysrRSliW0VdPXAoRSpsLG8sYyk7ZnVuY3Rpb24gQShMKXtmb3IodmFyIE09MCxJPTEsRD1hLTE7SSE9PUQmJmJbSV08PUw7KytJKU0rPWw7LS1JO3ZhciBSPShMLWJbSV0pLyhiW0krMV0tYltJXSksQz1NK1IqbCxCPXkoQyxvLGMpO3JldHVybiBCPj1yP3goTCxDLG8sYyk6Qj09PTA/QzpQKEwsTSxNK2wsbyxjKX1yZXR1cm4gZnVuY3Rpb24oTSl7cmV0dXJuIE09PT0wPzA6TT09PTE/MTpwKEEoTSksaCxnKX19fSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXQoMTkxKSxuPWgociksaT10KDIwNCksYT1oKGkpLGw9dCgxNjQpLHM9aChsKSxmPXQoMTcwKSx2PWgoZiksZD10KDE3MSkscD1oKGQpLHk9dCgxNzUpLFA9aCh5KSx4PXQoNzUpLG09aCh4KSxPPXQoMjA4KSxvPXQoMTg4KTtmdW5jdGlvbiBoKEIpe3JldHVybiBCJiZCLl9fZXNNb2R1bGU/Qjp7ZGVmYXVsdDpCfX12YXIgYz0oMCxQLmRlZmF1bHQpKCJ0aW1pbmciKSxnPSgwLFAuZGVmYXVsdCkoImtleWZyYW1lcyIpLGI9KDAsUC5kZWZhdWx0KSgiaW5pdFN0YXRlIiksRT0oMCxQLmRlZmF1bHQpKCJyZWFkeURlZmVyIiksQT0oMCxQLmRlZmF1bHQpKCJmaW5pc2hlZERlZmVyIiksTD0oMCxQLmRlZmF1bHQpKCJlZmZlY3RzIiksTT0oMCxQLmRlZmF1bHQpKCJhY3RpdmVSZWFkeVRpbWVyIiksST0oMCxQLmRlZmF1bHQpKCJhY3RpdmVGaW5pc2hUaW1lciIpLEQ9KDAsUC5kZWZhdWx0KSgicmVtb3ZlRGVmZXIiKSxSPXtkZWxheTowLGVuZERlbGF5OjAsZmlsbDoiYXV0byIsaXRlcmF0aW9uczoxLHBsYXliYWNrUmF0ZToxLGRpcmVjdGlvbjoibm9ybWFsIixlYXNpbmc6ImxpbmVhciIsZWZmZWN0Om51bGx9LEM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBCKHosSyxRKXt2YXIgXz10aGlzO2lmKCgwLHYuZGVmYXVsdCkodGhpcyxCKSxBcnJheS5pc0FycmF5KHopKXt2YXIgRj1belswXSx6LEtdO3o9RlswXSxLPUZbMV0sUT1GWzJdfXR5cGVvZiBRPT0ibnVtYmVyIiYmKFE9e2R1cmF0aW9uOlF9KSx0aGlzW2NdPSgwLHMuZGVmYXVsdCkoe30sUixRKSx0aGlzW2NdLmVhc2luZz0oMCxvLnBhcnNlRWFzaW5nKSh0aGlzW2NdLmVhc2luZyksdGhpc1tnXT0oMCxPLmNhbGN1bGF0ZUZyYW1lc09mZnNldCkoSyk7dmFyIEc9dGhpc1tnXVt0aGlzW2ddLmxlbmd0aC0xXTt0aGlzW2JdPXt9LCgwLGEuZGVmYXVsdCkoRykuZm9yRWFjaChmdW5jdGlvbihYKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeixYKSYmWCE9PSJlYXNpbmciJiZYIT09Im9mZnNldCImJihfW2JdW1hdPXpbWF0pfSksdGhpc1tnXT10aGlzW2ddLm1hcChmdW5jdGlvbihYKXtyZXR1cm4oMCxzLmRlZmF1bHQpKHt9LF9bYl0sWCl9KSx0aGlzW2ddWzBdLm9mZnNldCE9PTAmJnRoaXNbZ10udW5zaGlmdCgoMCxzLmRlZmF1bHQpKHt9LHRoaXNbYl0se29mZnNldDowfSkpLEcub2Zmc2V0PDEmJnRoaXNbZ10ucHVzaCgoMCxzLmRlZmF1bHQpKHt9LEcse29mZnNldDoxfSkpLHRoaXNbTF09e30sdGhpcy50aW1lbGluZT1udWxsfXJldHVybigwLHAuZGVmYXVsdCkoQixbe2tleToicGF1c2UiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9MH19LHtrZXk6TSx2YWx1ZTpmdW5jdGlvbigpe3ZhciBLPXRoaXM7dGhpc1tFXSYmIXRoaXNbRV0udGltZXJJRCYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU8MD90aGlzW0VdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7S1tFXS5yZXNvbHZlKCksZGVsZXRlIEtbRV19LHtkZWxheTotdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxoZWFkaW5nOiExfSk6dGhpc1tFXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0tbRV0ucmVzb2x2ZSgpLGRlbGV0ZSBLW0VdfSx7ZGVsYXk6MCxpc0VudHJvcHk6ITB9KSl9fSx7a2V5OkksdmFsdWU6ZnVuY3Rpb24oKXt2YXIgSz10aGlzLFE9dGhpc1tjXSxfPVEuZHVyYXRpb24sRj1RLml0ZXJhdGlvbnMsRz1RLmVuZERlbGF5LFg9TWF0aC5jZWlsKF8qRitHLXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUpKzE7dGhpc1tBXSYmIXRoaXNbQV0udGltZXJJRCYmKHRoaXNbQV0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtLW0FdLnJlc29sdmUoKSxLW0RdKEUpLEtbRF0oQSl9LHtkZWxheTpYLGhlYWRpbmc6ITF9KSx0aGlzW0FdLnJldmVyc2VUaW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0tbQV0ucmVzb2x2ZSgpLEtbRF0oRSksS1tEXShBKSxLLnRpbWVsaW5lPW51bGx9LHtkZWxheTotdGhpc1tjXS5kZWxheS0xLGhlYWRpbmc6ITF9KSl9fSx7a2V5OiJwbGF5Iix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIiYmdGhpcy5jYW5jZWwoKSx0aGlzLnBsYXlTdGF0ZT09PSJpZGxlIil7aWYodGhpcy5wbGF5YmFja1JhdGU8PTApcmV0dXJuO3ZhciBLPXRoaXNbY10sUT1LLmRlbGF5LF89Sy5wbGF5YmFja1JhdGUsRj1LLnRpbWVsaW5lO3RoaXMudGltZWxpbmU9bmV3IG0uZGVmYXVsdCh7b3JpZ2luVGltZTpRLHBsYXliYWNrUmF0ZTpffSxGKSx0aGlzW01dKCksdGhpc1tJXSgpfWVsc2UgdGhpcy5wbGF5U3RhdGU9PT0icGF1c2VkIiYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlLHRoaXNbTV0oKSl9fSx7a2V5OkQsdmFsdWU6ZnVuY3Rpb24oSyl7dmFyIFE9dGhpc1tLXSxfPXRoaXMudGltZWxpbmU7USYmXyYmKF8uY2xlYXJUaW1lb3V0KFEudGltZXJJRCksUS5yZXZlcnNlVGltZXJJRCYmXy5jbGVhclRpbWVvdXQoUS5yZXZlcnNlVGltZXJJRCkpLGRlbGV0ZSB0aGlzW0tdfX0se2tleToiY2FuY2VsIix2YWx1ZTpmdW5jdGlvbigpe3RoaXNbRF0oRSksdGhpc1tEXShBKSx0aGlzLnRpbWVsaW5lPW51bGx9fSx7a2V5OiJmaW5pc2giLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU9MS8wL3RoaXMucGxheWJhY2tSYXRlKSx0aGlzW0RdKEUpLHRoaXNbRF0oQSl9fSx7a2V5OiJhcHBseUVmZmVjdHMiLHZhbHVlOmZ1bmN0aW9uKEspe3JldHVybigwLHMuZGVmYXVsdCkodGhpc1tMXSxLKX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbY10ucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oSyl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPUspLHRoaXNbY10ucGxheWJhY2tSYXRlPUt9fSx7a2V5OiJwbGF5U3RhdGUiLGdldDpmdW5jdGlvbigpe3ZhciBLPXRoaXMudGltZWxpbmUsUT10aGlzW2NdLF89US5pdGVyYXRpb25zLEY9US5kdXJhdGlvbixHPVEuZW5kRGVsYXksWD0icnVubmluZyI7aWYoSz09bnVsbClYPSJpZGxlIjtlbHNlIGlmKEsucGF1c2VkKVg9InBhdXNlZCI7ZWxzZSBpZihLLmN1cnJlbnRUaW1lPDApWD0icGVuZGluZyI7ZWxzZXt2YXIgWj1LLmN1cnJlbnRUaW1lLV8qRjtaPjAmJlo8Rz9YPSJwZW5kaW5nIjpaPj1HJiYoWD0iZmluaXNoZWQiKX1yZXR1cm4gWH19LHtrZXk6InByb2dyZXNzIixnZXQ6ZnVuY3Rpb24oKXtpZighdGhpcy50aW1lbGluZSlyZXR1cm4gMDt2YXIgSz10aGlzW2NdLFE9Sy5kdXJhdGlvbixfPUsuaXRlcmF0aW9ucyxGPXRoaXMudGltZWxpbmUsRz10aGlzLnBsYXlTdGF0ZSxYPXZvaWQgMDtpZihHPT09ImlkbGUiKVg9MDtlbHNlIGlmKEc9PT0icGF1c2VkIiYmRi5jdXJyZW50VGltZTwwKVg9MDtlbHNlIGlmKEc9PT0icGVuZGluZyIpaWYoRi5jdXJyZW50VGltZTwwKVg9MDtlbHNle3ZhciBaPUYuc2Vla0xvY2FsVGltZShfKlEpO1g9KDAsTy5wZXJpb2RpY2l0eSkoWixRKVsxXS9RfWVsc2UoRz09PSJydW5uaW5nInx8Rz09PSJwYXVzZWQiKSYmKFg9KDAsTy5wZXJpb2RpY2l0eSkoRi5jdXJyZW50VGltZSxRKVsxXS9RKTtyZXR1cm4gRz09PSJmaW5pc2hlZCImJihYPSgwLE8ucGVyaW9kaWNpdHkpKF8sMSlbMV0pLFh9fSx7a2V5OiJmcmFtZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEs9dGhpcy5wbGF5U3RhdGUsUT10aGlzW2JdLF89dGhpc1tjXS5maWxsO2lmKEs9PT0iaWRsZSIpcmV0dXJuIFE7dmFyIEY9dGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxHPXRoaXNbZ10uc2xpY2UoMCksWD0oMCxPLmdldFByb2dyZXNzKSh0aGlzLnRpbWVsaW5lLHRoaXNbY10sdGhpcy5wcm9ncmVzcyksWj1YLnAsdHQ9WC5pbnZlcnRlZCxudD1RO3JldHVybiBGPDAmJks9PT0icGVuZGluZyI/KF89PT0iYmFja3dhcmRzInx8Xz09PSJib3RoIikmJihudD10dD9HW0cubGVuZ3RoLTFdOkdbMF0pOihLIT09InBlbmRpbmciJiZLIT09ImZpbmlzaGVkInx8Xz09PSJmb3J3YXJkcyJ8fF89PT0iYm90aCIpJiYobnQ9KDAsTy5nZXRDdXJyZW50RnJhbWUpKHRoaXNbY10sRyx0aGlzW0xdLFopKSxudH19LHtrZXk6InRpbWluZyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbY119fSx7a2V5OiJlZmZlY3RzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tMXX19LHtrZXk6ImJhc2VUaW1lbGluZSIsc2V0OmZ1bmN0aW9uKEspe3RoaXNbY10udGltZWxpbmU9S30sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbY10udGltZWxpbmV9fSx7a2V5OiJyZWFkeSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbRV0/dGhpc1tFXS5wcm9taXNlOnRoaXMudGltZWxpbmUmJnRoaXMudGltZWxpbmUuY3VycmVudFRpbWU+PTAmJnRoaXMucGxheVN0YXRlIT09InBhdXNlZCI/bi5kZWZhdWx0LnJlc29sdmUoKToodGhpc1tFXT0oMCxPLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbTV0oKSx0aGlzW0VdP3RoaXNbRV0ucHJvbWlzZTpuLmRlZmF1bHQucmVzb2x2ZSgpKX19LHtrZXk6ImZpbmlzaGVkIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGU9PT0iZmluaXNoZWQiP24uZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbQV18fCh0aGlzW0FdPSgwLE8uZGVmZXIpKCksdGhpcy50aW1lbGluZSYmdGhpc1tJXSgpKSx0aGlzW0FdLnByb21pc2UpfX1dKSxCfSgpO2UuZGVmYXVsdD1DfSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXtkZWZhdWx0OnQoMTkyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odSxlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxOTMpLHQoMjAyKSx0KDIwMyksdS5leHBvcnRzPXQoOTIpLlByb21pc2V9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDg5KSxuPXQoOTEpLGk9dCg5MyksYT10KDEyOCksbD10KDkwKSxzPXQoOTgpLGY9dCg5NCksdj10KDE0NyksZD10KDE0OCkscD10KDE5NCkseT10KDE5NSkuc2V0LFA9dCgxOTcpKCkseD10KDE5OCksbT10KDE5OSksTz10KDIwMCksbz10KDIwMSksaD0iUHJvbWlzZSIsYz1uLlR5cGVFcnJvcixnPW4ucHJvY2VzcyxiPWcmJmcudmVyc2lvbnMsRT1iJiZiLnY4fHwiIixBPW5baF0sTD1hKGcpPT0icHJvY2VzcyIsTT1mdW5jdGlvbigpe30sSSxELFIsQyxCPUQ9eC5mLHo9ISFmdW5jdGlvbigpe3RyeXt2YXIgdHQ9QS5yZXNvbHZlKDEpLG50PSh0dC5jb25zdHJ1Y3Rvcj17fSlbdCgxMjIpKCJzcGVjaWVzIildPWZ1bmN0aW9uKHEpe3EoTSxNKX07cmV0dXJuKEx8fHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQ9PSJmdW5jdGlvbiIpJiZ0dC50aGVuKE0paW5zdGFuY2VvZiBudCYmRS5pbmRleE9mKCI2LjYiKSE9PTAmJk8uaW5kZXhPZigiQ2hyb21lLzY2Iik9PT0tMX1jYXRjaHt9fSgpLEs9ZnVuY3Rpb24odHQpe3ZhciBudDtyZXR1cm4gcyh0dCkmJnR5cGVvZihudD10dC50aGVuKT09ImZ1bmN0aW9uIj9udDohMX0sUT1mdW5jdGlvbih0dCxudCl7aWYoIXR0Ll9uKXt0dC5fbj0hMDt2YXIgcT10dC5fYztQKGZ1bmN0aW9uKCl7Zm9yKHZhciBodD10dC5fdix1dD10dC5fcz09MSxqPTAsVz1mdW5jdGlvbihWKXt2YXIgSj11dD9WLm9rOlYuZmFpbCxOPVYucmVzb2x2ZSwkPVYucmVqZWN0LFM9Vi5kb21haW4sVCx3LFU7dHJ5e0o/KHV0fHwodHQuX2g9PTImJkcodHQpLHR0Ll9oPTEpLEo9PT0hMD9UPWh0OihTJiZTLmVudGVyKCksVD1KKGh0KSxTJiYoUy5leGl0KCksVT0hMCkpLFQ9PT1WLnByb21pc2U/JChjKCJQcm9taXNlLWNoYWluIGN5Y2xlIikpOih3PUsoVCkpP3cuY2FsbChULE4sJCk6TihUKSk6JChodCl9Y2F0Y2goSCl7UyYmIVUmJlMuZXhpdCgpLCQoSCl9fTtxLmxlbmd0aD5qOylXKHFbaisrXSk7dHQuX2M9W10sdHQuX249ITEsbnQmJiF0dC5faCYmXyh0dCl9KX19LF89ZnVuY3Rpb24odHQpe3kuY2FsbChuLGZ1bmN0aW9uKCl7dmFyIG50PXR0Ll92LHE9Rih0dCksaHQsdXQsajtpZihxJiYoaHQ9bShmdW5jdGlvbigpe0w/Zy5lbWl0KCJ1bmhhbmRsZWRSZWplY3Rpb24iLG50LHR0KToodXQ9bi5vbnVuaGFuZGxlZHJlamVjdGlvbik/dXQoe3Byb21pc2U6dHQscmVhc29uOm50fSk6KGo9bi5jb25zb2xlKSYmai5lcnJvciYmai5lcnJvcigiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIixudCl9KSx0dC5faD1MfHxGKHR0KT8yOjEpLHR0Ll9hPXZvaWQgMCxxJiZodC5lKXRocm93IGh0LnZ9KX0sRj1mdW5jdGlvbih0dCl7cmV0dXJuIHR0Ll9oIT09MSYmKHR0Ll9hfHx0dC5fYykubGVuZ3RoPT09MH0sRz1mdW5jdGlvbih0dCl7eS5jYWxsKG4sZnVuY3Rpb24oKXt2YXIgbnQ7TD9nLmVtaXQoInJlamVjdGlvbkhhbmRsZWQiLHR0KToobnQ9bi5vbnJlamVjdGlvbmhhbmRsZWQpJiZudCh7cHJvbWlzZTp0dCxyZWFzb246dHQuX3Z9KX0pfSxYPWZ1bmN0aW9uKHR0KXt2YXIgbnQ9dGhpcztudC5fZHx8KG50Ll9kPSEwLG50PW50Ll93fHxudCxudC5fdj10dCxudC5fcz0yLG50Ll9hfHwobnQuX2E9bnQuX2Muc2xpY2UoKSksUShudCwhMCkpfSxaPWZ1bmN0aW9uKHR0KXt2YXIgbnQ9dGhpcyxxO2lmKCFudC5fZCl7bnQuX2Q9ITAsbnQ9bnQuX3d8fG50O3RyeXtpZihudD09PXR0KXRocm93IGMoIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmIik7KHE9Syh0dCkpP1AoZnVuY3Rpb24oKXt2YXIgaHQ9e193Om50LF9kOiExfTt0cnl7cS5jYWxsKHR0LGkoWixodCwxKSxpKFgsaHQsMSkpfWNhdGNoKHV0KXtYLmNhbGwoaHQsdXQpfX0pOihudC5fdj10dCxudC5fcz0xLFEobnQsITEpKX1jYXRjaChodCl7WC5jYWxsKHtfdzpudCxfZDohMX0saHQpfX19O3p8fChBPWZ1bmN0aW9uKG50KXt2KHRoaXMsQSxoLCJfaCIpLGYobnQpLEkuY2FsbCh0aGlzKTt0cnl7bnQoaShaLHRoaXMsMSksaShYLHRoaXMsMSkpfWNhdGNoKHEpe1guY2FsbCh0aGlzLHEpfX0sST1mdW5jdGlvbihudCl7dGhpcy5fYz1bXSx0aGlzLl9hPXZvaWQgMCx0aGlzLl9zPTAsdGhpcy5fZD0hMSx0aGlzLl92PXZvaWQgMCx0aGlzLl9oPTAsdGhpcy5fbj0hMX0sSS5wcm90b3R5cGU9dCgxNDYpKEEucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKG50LHEpe3ZhciBodD1CKHAodGhpcyxBKSk7cmV0dXJuIGh0Lm9rPXR5cGVvZiBudD09ImZ1bmN0aW9uIj9udDohMCxodC5mYWlsPXR5cGVvZiBxPT0iZnVuY3Rpb24iJiZxLGh0LmRvbWFpbj1MP2cuZG9tYWluOnZvaWQgMCx0aGlzLl9jLnB1c2goaHQpLHRoaXMuX2EmJnRoaXMuX2EucHVzaChodCksdGhpcy5fcyYmUSh0aGlzLCExKSxodC5wcm9taXNlfSxjYXRjaDpmdW5jdGlvbih0dCl7cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsdHQpfX0pLFI9ZnVuY3Rpb24oKXt2YXIgdHQ9bmV3IEk7dGhpcy5wcm9taXNlPXR0LHRoaXMucmVzb2x2ZT1pKFosdHQsMSksdGhpcy5yZWplY3Q9aShYLHR0LDEpfSx4LmY9Qj1mdW5jdGlvbih0dCl7cmV0dXJuIHR0PT09QXx8dHQ9PT1DP25ldyBSKHR0KTpEKHR0KX0pLGwobC5HK2wuVytsLkYqIXose1Byb21pc2U6QX0pLHQoMTIxKShBLGgpLHQoMTQ5KShoKSxDPXQoOTIpW2hdLGwobC5TK2wuRioheixoLHtyZWplY3Q6ZnVuY3Rpb24obnQpe3ZhciBxPUIodGhpcyksaHQ9cS5yZWplY3Q7cmV0dXJuIGh0KG50KSxxLnByb21pc2V9fSksbChsLlMrbC5GKihyfHwheiksaCx7cmVzb2x2ZTpmdW5jdGlvbihudCl7cmV0dXJuIG8ociYmdGhpcz09PUM/QTp0aGlzLG50KX19KSxsKGwuUytsLkYqISh6JiZ0KDE0MCkoZnVuY3Rpb24odHQpe0EuYWxsKHR0KS5jYXRjaChNKX0pKSxoLHthbGw6ZnVuY3Rpb24obnQpe3ZhciBxPXRoaXMsaHQ9QihxKSx1dD1odC5yZXNvbHZlLGo9aHQucmVqZWN0LFc9bShmdW5jdGlvbigpe3ZhciBWPVtdLEo9MCxOPTE7ZChudCwhMSxmdW5jdGlvbigkKXt2YXIgUz1KKyssVD0hMTtWLnB1c2godm9pZCAwKSxOKysscS5yZXNvbHZlKCQpLnRoZW4oZnVuY3Rpb24odyl7VHx8KFQ9ITAsVltTXT13LC0tTnx8dXQoVikpfSxqKX0pLC0tTnx8dXQoVil9KTtyZXR1cm4gVy5lJiZqKFcudiksaHQucHJvbWlzZX0scmFjZTpmdW5jdGlvbihudCl7dmFyIHE9dGhpcyxodD1CKHEpLHV0PWh0LnJlamVjdCxqPW0oZnVuY3Rpb24oKXtkKG50LCExLGZ1bmN0aW9uKFcpe3EucmVzb2x2ZShXKS50aGVuKGh0LnJlc29sdmUsdXQpfSl9KTtyZXR1cm4gai5lJiZ1dChqLnYpLGh0LnByb21pc2V9fSl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDk3KSxuPXQoOTQpLGk9dCgxMjIpKCJzcGVjaWVzIik7dS5leHBvcnRzPWZ1bmN0aW9uKGEsbCl7dmFyIHM9cihhKS5jb25zdHJ1Y3RvcixmO3JldHVybiBzPT09dm9pZCAwfHwoZj1yKHMpW2ldKT09bnVsbD9sOm4oZil9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5Myksbj10KDE5NiksaT10KDEyMCksYT10KDEwMiksbD10KDkxKSxzPWwucHJvY2VzcyxmPWwuc2V0SW1tZWRpYXRlLHY9bC5jbGVhckltbWVkaWF0ZSxkPWwuTWVzc2FnZUNoYW5uZWwscD1sLkRpc3BhdGNoLHk9MCxQPXt9LHg9Im9ucmVhZHlzdGF0ZWNoYW5nZSIsbSxPLG8saD1mdW5jdGlvbigpe3ZhciBnPSt0aGlzO2lmKFAuaGFzT3duUHJvcGVydHkoZykpe3ZhciBiPVBbZ107ZGVsZXRlIFBbZ10sYigpfX0sYz1mdW5jdGlvbihnKXtoLmNhbGwoZy5kYXRhKX07KCFmfHwhdikmJihmPWZ1bmN0aW9uKGIpe2Zvcih2YXIgRT1bXSxBPTE7YXJndW1lbnRzLmxlbmd0aD5BOylFLnB1c2goYXJndW1lbnRzW0ErK10pO3JldHVybiBQWysreV09ZnVuY3Rpb24oKXtuKHR5cGVvZiBiPT0iZnVuY3Rpb24iP2I6RnVuY3Rpb24oYiksRSl9LG0oeSkseX0sdj1mdW5jdGlvbihiKXtkZWxldGUgUFtiXX0sdCg4Nikocyk9PSJwcm9jZXNzIj9tPWZ1bmN0aW9uKGcpe3MubmV4dFRpY2socihoLGcsMSkpfTpwJiZwLm5vdz9tPWZ1bmN0aW9uKGcpe3Aubm93KHIoaCxnLDEpKX06ZD8oTz1uZXcgZCxvPU8ucG9ydDIsTy5wb3J0MS5vbm1lc3NhZ2U9YyxtPXIoby5wb3N0TWVzc2FnZSxvLDEpKTpsLmFkZEV2ZW50TGlzdGVuZXImJnR5cGVvZiBwb3N0TWVzc2FnZT09ImZ1bmN0aW9uIiYmIWwuaW1wb3J0U2NyaXB0cz8obT1mdW5jdGlvbihnKXtsLnBvc3RNZXNzYWdlKGcrIiIsIioiKX0sbC5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixjLCExKSk6eCBpbiBhKCJzY3JpcHQiKT9tPWZ1bmN0aW9uKGcpe2kuYXBwZW5kQ2hpbGQoYSgic2NyaXB0IikpW3hdPWZ1bmN0aW9uKCl7aS5yZW1vdmVDaGlsZCh0aGlzKSxoLmNhbGwoZyl9fTptPWZ1bmN0aW9uKGcpe3NldFRpbWVvdXQocihoLGcsMSksMCl9KSx1LmV4cG9ydHM9e3NldDpmLGNsZWFyOnZ9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbih0LHIsbil7dmFyIGk9bj09PXZvaWQgMDtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gaT90KCk6dC5jYWxsKG4pO2Nhc2UgMTpyZXR1cm4gaT90KHJbMF0pOnQuY2FsbChuLHJbMF0pO2Nhc2UgMjpyZXR1cm4gaT90KHJbMF0sclsxXSk6dC5jYWxsKG4sclswXSxyWzFdKTtjYXNlIDM6cmV0dXJuIGk/dChyWzBdLHJbMV0sclsyXSk6dC5jYWxsKG4sclswXSxyWzFdLHJbMl0pO2Nhc2UgNDpyZXR1cm4gaT90KHJbMF0sclsxXSxyWzJdLHJbM10pOnQuY2FsbChuLHJbMF0sclsxXSxyWzJdLHJbM10pfXJldHVybiB0LmFwcGx5KG4scil9fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MSksbj10KDE5NSkuc2V0LGk9ci5NdXRhdGlvbk9ic2VydmVyfHxyLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsYT1yLnByb2Nlc3MsbD1yLlByb21pc2Uscz10KDg2KShhKT09InByb2Nlc3MiO3UuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBmLHYsZCxwPWZ1bmN0aW9uKCl7dmFyIG0sTztmb3IocyYmKG09YS5kb21haW4pJiZtLmV4aXQoKTtmOyl7Tz1mLmZuLGY9Zi5uZXh0O3RyeXtPKCl9Y2F0Y2gobyl7dGhyb3cgZj9kKCk6dj12b2lkIDAsb319dj12b2lkIDAsbSYmbS5lbnRlcigpfTtpZihzKWQ9ZnVuY3Rpb24oKXthLm5leHRUaWNrKHApfTtlbHNlIGlmKGkmJiEoci5uYXZpZ2F0b3ImJnIubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgeT0hMCxQPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTtuZXcgaShwKS5vYnNlcnZlKFAse2NoYXJhY3RlckRhdGE6ITB9KSxkPWZ1bmN0aW9uKCl7UC5kYXRhPXk9IXl9fWVsc2UgaWYobCYmbC5yZXNvbHZlKXt2YXIgeD1sLnJlc29sdmUodm9pZCAwKTtkPWZ1bmN0aW9uKCl7eC50aGVuKHApfX1lbHNlIGQ9ZnVuY3Rpb24oKXtuLmNhbGwocixwKX07cmV0dXJuIGZ1bmN0aW9uKG0pe3ZhciBPPXtmbjptLG5leHQ6dm9pZCAwfTt2JiYodi5uZXh0PU8pLGZ8fChmPU8sZCgpKSx2PU99fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTQpO2Z1bmN0aW9uIG4oaSl7dmFyIGEsbDt0aGlzLnByb21pc2U9bmV3IGkoZnVuY3Rpb24ocyxmKXtpZihhIT09dm9pZCAwfHxsIT09dm9pZCAwKXRocm93IFR5cGVFcnJvcigiQmFkIFByb21pc2UgY29uc3RydWN0b3IiKTthPXMsbD1mfSksdGhpcy5yZXNvbHZlPXIoYSksdGhpcy5yZWplY3Q9cihsKX11LmV4cG9ydHMuZj1mdW5jdGlvbihpKXtyZXR1cm4gbmV3IG4oaSl9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJue2U6ITEsdjp0KCl9fWNhdGNoKHIpe3JldHVybntlOiEwLHY6cn19fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTEpLG49ci5uYXZpZ2F0b3I7dS5leHBvcnRzPW4mJm4udXNlckFnZW50fHwiIn0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTcpLG49dCg5OCksaT10KDE5OCk7dS5leHBvcnRzPWZ1bmN0aW9uKGEsbCl7aWYocihhKSxuKGwpJiZsLmNvbnN0cnVjdG9yPT09YSlyZXR1cm4gbDt2YXIgcz1pLmYoYSksZj1zLnJlc29sdmU7cmV0dXJuIGYobCkscy5wcm9taXNlfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoOTApLG49dCg5MiksaT10KDkxKSxhPXQoMTk0KSxsPXQoMjAxKTtyKHIuUCtyLlIsIlByb21pc2UiLHtmaW5hbGx5OmZ1bmN0aW9uKHMpe3ZhciBmPWEodGhpcyxuLlByb21pc2V8fGkuUHJvbWlzZSksdj10eXBlb2Ygcz09ImZ1bmN0aW9uIjtyZXR1cm4gdGhpcy50aGVuKHY/ZnVuY3Rpb24oZCl7cmV0dXJuIGwoZixzKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZH0pfTpzLHY/ZnVuY3Rpb24oZCl7cmV0dXJuIGwoZixzKCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBkfSl9OnMpfX0pfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MCksbj10KDE5OCksaT10KDE5OSk7cihyLlMsIlByb21pc2UiLHt0cnk6ZnVuY3Rpb24oYSl7dmFyIGw9bi5mKHRoaXMpLHM9aShhKTtyZXR1cm4ocy5lP2wucmVqZWN0OmwucmVzb2x2ZSkocy52KSxsLnByb21pc2V9fSl9LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9e2RlZmF1bHQ6dCgyMDUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih1LGUsdCl7dCgyMDYpLHUuZXhwb3J0cz10KDkyKS5PYmplY3Qua2V5c30sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMTI0KSxuPXQoMTEwKTt0KDIwNykoImtleXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBuKHIoYSkpfX0pfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MCksbj10KDkyKSxpPXQoMTAxKTt1LmV4cG9ydHM9ZnVuY3Rpb24oYSxsKXt2YXIgcz0obi5PYmplY3R8fHt9KVthXXx8T2JqZWN0W2FdLGY9e307ZlthXT1sKHMpLHIoci5TK3IuRippKGZ1bmN0aW9uKCl7cygxKX0pLCJPYmplY3QiLGYpfX0sZnVuY3Rpb24odSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDc2KSxuPVAociksaT10KDIwOSksYT1QKGkpLGw9dCgxNjQpLHM9UChsKSxmPXQoMTkxKSx2PVAoZik7ZS5kZWZlcj14LGUucGVyaW9kaWNpdHk9bSxlLmNhbGN1bGF0ZUZyYW1lc09mZnNldD1PLGUuZ2V0UHJvZ3Jlc3M9byxlLmdldEN1cnJlbnRGcmFtZT1jO3ZhciBkPXQoMTg4KSxwPXQoMTg3KSx5PVAocCk7ZnVuY3Rpb24gUChnKXtyZXR1cm4gZyYmZy5fX2VzTW9kdWxlP2c6e2RlZmF1bHQ6Z319ZnVuY3Rpb24geCgpe3ZhciBnPXt9O3JldHVybiBnLnByb21pc2U9bmV3IHYuZGVmYXVsdChmdW5jdGlvbihiLEUpe2cucmVzb2x2ZT1iLGcucmVqZWN0PUV9KSxnfWZ1bmN0aW9uIG0oZyxiKXt2YXIgRT1NYXRoLmZsb29yKGcvYiksQT1nLUUqYjtyZXR1cm4gQT09PTAmJkU+MCYmKEE9YixFLS0pLFtFLEFdfWZ1bmN0aW9uIE8oZyl7Zz1nLnNsaWNlKDApO3ZhciBiPWdbMF0sRT1nW2cubGVuZ3RoLTFdO0Uub2Zmc2V0PUUub2Zmc2V0fHwxLGIub2Zmc2V0PWIub2Zmc2V0fHwwO2Zvcih2YXIgQT0wLEw9LTEsTT0wO008Zy5sZW5ndGg7TSsrKXt2YXIgST1nW01dO2lmKEkub2Zmc2V0IT1udWxsKXt2YXIgRD1NLUw7aWYoRD4xKWZvcih2YXIgUj0oSS5vZmZzZXQtQSkvRCxDPTA7QzxELTE7QysrKWdbTCtDKzFdLm9mZnNldD1BK1IqKEMrMSk7QT1JLm9mZnNldCxMPU19aWYoSS5lYXNpbmchPW51bGwmJihJLmVhc2luZz0oMCxkLnBhcnNlRWFzaW5nKShJLmVhc2luZykpLE0+MCl7dmFyIEI9Z1tNXS5lYXNpbmchPW51bGw7Z1tNXT0oMCxzLmRlZmF1bHQpKHt9LGdbTS0xXSxnW01dKSxCfHxkZWxldGUgZ1tNXS5lYXNpbmd9fXJldHVybiBnfWZ1bmN0aW9uIG8oZyxiLEUpe3ZhciBBPWcuY3VycmVudFRpbWUsTD1iLmRpcmVjdGlvbixNPWIuZHVyYXRpb24sST0hMTtpZihMPT09InJldmVyc2UiKUU9MS1FLEk9ITA7ZWxzZSBpZihMPT09ImFsdGVybmF0ZSJ8fEw9PT0iYWx0ZXJuYXRlLXJldmVyc2UiKXt2YXIgRD1NYXRoLmZsb29yKEEvTSk7RT09PTEmJkQtLSxEJTJeTD09PSJhbHRlcm5hdGUtcmV2ZXJzZSImJihFPTEtRSxJPSEwKX1yZXR1cm57cDpFLGludmVydGVkOkl9fWZ1bmN0aW9uIGgoZyxiLEUsQSl7dmFyIEw9e307cmV0dXJuKDAsYS5kZWZhdWx0KShiKS5mb3JFYWNoKGZ1bmN0aW9uKE0pe3ZhciBJPSgwLG4uZGVmYXVsdCkoTSwyKSxEPUlbMF0sUj1JWzFdO2lmKEQhPT0ib2Zmc2V0IiYmRCE9PSJlYXNpbmciKXt2YXIgQz1FW0RdfHxFLmRlZmF1bHQsQj1DKGdbRF0sUixBLGcub2Zmc2V0LGIub2Zmc2V0KTtCIT1udWxsJiYoTFtEXT1CKX19KSxMfWZ1bmN0aW9uIGMoZyxiLEUsQSl7dmFyIEw9Zy5lYXNpbmcsTT1nLmVmZmVjdDtNfHwoRT0oMCxzLmRlZmF1bHQpKHt9LHkuZGVmYXVsdCxFKSk7dmFyIEk9e307QT1MKEEsYik7Zm9yKHZhciBEPTE7RDxiLmxlbmd0aDtEKyspe3ZhciBSPWJbRF0sQz1SLm9mZnNldDtpZihDPj1BfHxEPT09Yi5sZW5ndGgtMSl7dmFyIEI9YltELTFdLHo9Qi5vZmZzZXQsSz1CLmVhc2luZyxRPUE7aWYoSyl7dmFyIF89Qy16O1E9SygoQS16KS9fKSpfK3p9TT9JPU0oQixSLFEseixDKTpJPWgoQixSLEUsUSk7YnJlYWt9fXJldHVybiBJfX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz17ZGVmYXVsdDp0KDIxMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHUsZSx0KXt0KDIxMSksdS5leHBvcnRzPXQoOTIpLk9iamVjdC5lbnRyaWVzfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCg5MCksbj10KDIxMikoITApO3Ioci5TLCJPYmplY3QiLHtlbnRyaWVzOmZ1bmN0aW9uKGEpe3JldHVybiBuKGEpfX0pfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgxMDApLG49dCgxMTApLGk9dCg4NCksYT10KDE2OSkuZjt1LmV4cG9ydHM9ZnVuY3Rpb24obCl7cmV0dXJuIGZ1bmN0aW9uKHMpe2Zvcih2YXIgZj1pKHMpLHY9bihmKSxkPXYubGVuZ3RoLHA9MCx5PVtdLFA7ZD5wOylQPXZbcCsrXSwoIXJ8fGEuY2FsbChmLFApKSYmeS5wdXNoKGw/W1AsZltQXV06ZltQXSk7cmV0dXJuIHl9fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcj1uZXcgTWFwO2Z1bmN0aW9uIG4oYSxsPXt9LHM9W10pe2E9YS50b0xvd2VyQ2FzZSgpO2NvbnN0IGY9ci5nZXQoYSk7aWYoIWYpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBub2RlOiAke2F9YCk7Y29uc3Qgdj1uZXcgZihsKTtyZXR1cm4gcy5mb3JFYWNoKGQ9Pnt2LmFwcGVuZENoaWxkKGQpfSksdn1jb25zdCBpPXtyZWdpc3Rlck5vZGUoYSxsLHM9MTAwKXtpZihsPWwudG9Mb3dlckNhc2UoKSxyLmhhcyhsKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVnaXN0ZXJOb2RlLCAke2x9IGhhcyBiZWVuIHRha2VuLmApO3Iuc2V0KGwsYSksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYS5wcm90b3R5cGUse25vZGVUeXBlOnt2YWx1ZTpzfSx0YWdOYW1lOnt2YWx1ZTpsLnRvVXBwZXJDYXNlKCl9LG5vZGVOYW1lOnt2YWx1ZTpsfSxvd25lckRvY3VtZW50Ont2YWx1ZTppfSxuYW1lc3BhY2VVUkk6e3ZhbHVlOmBodHRwOi8vc3ByaXRlanMuY29tLyR7bH1gfX0pfSxjcmVhdGVFbGVtZW50Om4sY3JlYXRlRWxlbWVudE5TKGEsbCl7cmV0dXJuIG4obCl9LGlzU3ByaXRlTm9kZShhKXtyZXR1cm4gci5oYXMoYS50b0xvd2VyQ2FzZSgpKX19O2UuZGVmYXVsdD1pfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9U3ltYm9sKCJ0eXBlIiksbj1TeW1ib2woImJ1YmJsZXMiKSxpPVN5bWJvbCgib3JpZ2luYWxFdmVudCIpLGE9U3ltYm9sKCJkZXRhaWwiKTtjbGFzcyBse2NvbnN0cnVjdG9yKGYse2J1YmJsZXM6dj1udWxsfT17fSl7aWYodHlwZW9mIGY9PSJzdHJpbmciPyh0aGlzW3JdPWYsdGhpc1tuXT0hIXYpOih0aGlzW3JdPWYudHlwZSx0aGlzW2ldPWYsdGhpc1tuXT12IT1udWxsPyEhdjohIWYuYnViYmxlcyxmLmRldGFpbCYmKHRoaXNbYV09Zi5kZXRhaWwpKSwhdGhpc1tyXSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGV2ZW50IHR5cGUuIik7dGhpcy5jYW5jZWxCdWJibGU9ITF9c2V0T3JpZ2luYWxFdmVudChmKXt0aGlzW2ldPWZ9Z2V0IG9yaWdpbmFsRXZlbnQoKXtyZXR1cm4gdGhpc1tpXX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW3JdfWdldCBidWJibGVzKCl7cmV0dXJuIHRoaXNbbl19Z2V0IGRldGFpbCgpe3JldHVybiB0aGlzW2FdfXN0b3BQcm9wYWdhdGlvbigpe3RoaXMuY2FuY2VsQnViYmxlPSEwfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsInBhcnNlRmlsdGVyU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImFwcGx5RmlsdGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciByPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKGEpe2lmKGE9YS50cmltKCksIWF8fGE9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgbD0vXig/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSskL2kscz1hLm1hdGNoKC8oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrPy9pZyksZj1bXTtyZXR1cm4gcyYmcy5mb3JFYWNoKHY9Pntjb25zdCBkPXYubWF0Y2gobCk7aWYoIWQpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaXRsZXIgc3RyaW5nLiIpO2xldFsscCx5XT1kO3A9cC50b0xvd2VyQ2FzZSgpLHk9eS50cmltKCkubWF0Y2goLyhbXiggKV0rfChbXiggKV0rXCguKlwpKSkoPz1cc3wkKS9nKS5tYXAoKFAseCk9PntsZXQgbTtyZXR1cm4gcD09PSJ1cmwifHxwPT09ImRyb3Atc2hhZG93IiYmeD09PTM/bT1QOm09T2JqZWN0KHIudG9OdW1iZXIpKFApLC8lJC8udGVzdChQKSYmKG0vPTEwMCksbX0pLGYucHVzaCh7dHlwZTpwLGFyZ3M6eX0pfSksZn1mdW5jdGlvbiBpKGEsbCl7YS5jbGVhckZpbHRlcigpLGwmJmwuZm9yRWFjaCgoe3R5cGU6cyxhcmdzOmZ9KT0+e2xldCB2PXM7dj09PSJkcm9wLXNoYWRvdyI/dj0iZHJvcFNoYWRvdyI6dj09PSJodWUtcm90YXRlIiYmKHY9Imh1ZVJvdGF0ZSIpLGFbdl0oLi4uZil9KX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihuLGkpe2lmKCFpKXJldHVybjtjb25zdCBhPW4uZ2V0TGlzdGVuZXJzKCJiZWZvcmVyZW5kZXIiKSxsPW4uZ2V0TGlzdGVuZXJzKCJhZnRlcnJlbmRlciIpO2EubGVuZ3RoJiYhaS5iZWZvcmVSZW5kZXI/aS5iZWZvcmVSZW5kZXI9cz0+e24uZGlzcGF0Y2hFdmVudCh7dHlwZToiYmVmb3JlcmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6c319KX06YS5sZW5ndGh8fChpLmJlZm9yZVJlbmRlcj1udWxsKSxsLmxlbmd0aCYmIWkuYWZ0ZXJSZW5kZXI/aS5hZnRlclJlbmRlcj1zPT57bi5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhZnRlcnJlbmRlciIsZGV0YWlsOntjb250ZXh0OnN9fSl9OmwubGVuZ3RofHwoaS5hZnRlclJlbmRlcj1udWxsKX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDEyKSxuPXQoMjE4KSxpPXQoNzApLGE9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBsPVN5bWJvbCgiYW1vdW50Iikscz1TeW1ib2woIm1lc2hDbG91ZCIpO2NsYXNzIGYgZXh0ZW5kcyBpLmRlZmF1bHR7Y29uc3RydWN0b3IoZCxwPTEpe3N1cGVyKCksdGhpcy5tZXNoTm9kZT1kLGQuY29ubmVjdCh0aGlzKSx0aGlzW2xdPXAsdGhpc1tzXT1udWxsfWdldCBtZXNoQ2xvdWQoKXtjb25zdCBkPXRoaXMubWVzaE5vZGUscD10aGlzW2xdO3JldHVybiF0aGlzW3NdJiZkLm1lc2gmJih0aGlzW3NdPW5ldyByLk1lc2hDbG91ZChkLm1lc2gscCkpLHRoaXNbc119Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5tZXNoTm9kZSYmdGhpcy5tZXNoTm9kZS5pc1Zpc2libGV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2xdfXNldCBhbW91bnQoZCl7dGhpc1tsXT1kLHRoaXNbc10mJih0aGlzW3NdLmFtb3VudD1kKX1icmlnaHRuZXNzKGQscCl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5icmlnaHRuZXNzKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1jb250cmFzdChkLHApe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuY29udHJhc3QoZCxwKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRlbGV0ZShkKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmRlbGV0ZShkKSx0aGlzW2xdLS0sdGhpcy5mb3JjZVVwZGF0ZSgpKX1kcmF3KGQ9W10pe2lmKHN1cGVyLmRyYXcoZCksdGhpcy5tZXNoQ2xvdWQpe2lmKHRoaXMucHJvZ3JhbSl7dGhpcy5tZXNoQ2xvdWQuc2V0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO2NvbnN0IHA9dGhpcy5zaGFkZXJBdHRycztwJiZPYmplY3QuZW50cmllcyhwKS5mb3JFYWNoKChbUCx4XSk9Pnt0aGlzLm1lc2hDbG91ZC5tZXNoLnNldEF0dHJpYnV0ZShQLHgpfSk7Y29uc3QgeT10aGlzLnVuaWZvcm1zO2lmKHRoaXMudW5pZm9ybXMpe2NvbnN0IFA9e307T2JqZWN0LmVudHJpZXMoeSkuZm9yRWFjaCgoW3gsbV0pPT57dHlwZW9mIG09PSJmdW5jdGlvbiImJihtPW0odGhpcyx4KSksUFt4XT1tfSksdGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRVbmlmb3JtcyhQKX19dGhpcy5tZXNoTm9kZS50ZXh0dXJlSW1hZ2UmJk9iamVjdChuLmRyYXdUZXh0dXJlKSh0aGlzLm1lc2hOb2RlLHRoaXMubWVzaE5vZGUubWVzaCksZC5wdXNoKHRoaXMubWVzaENsb3VkKX1yZXR1cm4gZH1nZXRUcmFuc2Zvcm0oZCl7aWYodGhpcy5tZXNoQ2xvdWQpcmV0dXJuIHRoaXMubWVzaENsb3VkLmdldFRyYW5zZm9ybShkKX1ncmF5c2NhbGUoZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmdyYXlzY2FsZShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9aHVlUm90YXRlKGQscCl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5odWVSb3RhdGUoZCxwKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWludmVydChkLHApe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaW52ZXJ0KGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pc1BvaW50Q29sbGlzaW9uKGQscCl7aWYoIXRoaXMubWVzaENsb3VkKXJldHVybiExO2NvbnN0IHk9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoeT09PSJub25lInx8eSE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IFA9ImJvdGgiO3k9PT0idmlzaWJsZUZpbGwiJiYoUD0iZmlsbCIpLHk9PT0idmlzaWJsZVN0cm9rZSImJihQPSJzdHJva2UiKTtmb3IobGV0IHg9MDt4PHRoaXNbbF07eCsrKWlmKCF0aGlzLm1lc2hDbG91ZC5pc1BvaW50Q29sbGlzaW9uKHgsW2QscF0sUCkpcmV0dXJuITE7cmV0dXJuITB9c2V0T3BhY2l0eShkLHApe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQub3BhY2l0eShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9cm90YXRlKGQscCxbeSxQXT1bMCwwXSl7Y29uc3QgeD1NYXRoLlBJKnAvMTgwO2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seTpPfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQucm90YXRlKGQseCxbeSttLFArT10pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2F0dXJhdGUoZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNhdHVyYXRlKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zY2FsZShkLFtwLHk9cF0sW1AseF09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seTpPfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXMsbz0xZS01O01hdGguYWJzKHApPG8mJihwPTEvcD4wP286LW8pLE1hdGguYWJzKHkpPG8mJih5PTEveT4wP286LW8pLHRoaXMubWVzaENsb3VkLnNjYWxlKGQsW3AseV0sW1ArbSx4K09dKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNldENvbG9yVHJhbnNmb3JtKGQscCl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRDb2xvclRyYW5zZm9ybShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0RmlsbENvbG9yKGQscCl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KHApJiYocD1bLi4ucF0scFswXS89MjU1LHBbMV0vPTI1NSxwWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldEZpbGxDb2xvcihkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2VwaWEoZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNlcGlhKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpkLGhlaWdodDpwfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZCxoZWlnaHQ6cH0pLHRoaXMubWVzaE5vZGUuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZCxoZWlnaHQ6cH0pfXNldFN0cm9rZUNvbG9yKGQscCl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KHApJiYocD1bLi4ucF0scFswXS89MjU1LHBbMV0vPTI1NSxwWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldFN0cm9rZUNvbG9yKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRUcmFuc2Zvcm0oZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldFRyYW5zZm9ybShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2tldyhkLFtwLHk9cF0sW1AseF09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4Om0seTpPfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQuc2tldyhkLFtwLHldLFtQK20seCtPXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX10cmFuc2Zvcm0oZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybShkLHApLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNmb3JtQ29sb3IoZCxwKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybUNvbG9yKGQscCksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2xhdGUoZCxbcCx5XSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2xhdGUoZCxbcCx5XSksdGhpcy5mb3JjZVVwZGF0ZSgpKX11cGRhdGVNZXNoKCl7dGhpc1tzXSYmKHRoaXNbc10ubWVzaD10aGlzLm1lc2hOb2RlLm1lc2gsdGhpcy5mb3JjZVVwZGF0ZSgpKX19YS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShmLCJjbG91ZCIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJsb2FkVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJhcHBseVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiY3JlYXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJkZWxldGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImRyYXdUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImxvYWRGcmFtZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDEyKSxuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPXt9O2Z1bmN0aW9uIGEoUCx4KXtpZihpW1BdKXJldHVybiBpW1BdO2NvbnN0IG09ci5FTlYubG9hZEltYWdlKFAse2FsaWFzOngsdXNlSW1hZ2VCaXRtYXA6ITF9KTtyZXR1cm4gbT8/UH1hc3luYyBmdW5jdGlvbiBsKFAseCxtKXtsZXQgTz14O2lmKHR5cGVvZiB4PT0ic3RyaW5nIiYmKE89YSh4KSksTyYmdHlwZW9mIE8udGhlbj09ImZ1bmN0aW9uIiYmKE89YXdhaXQgTykseD09PVAuYXR0cmlidXRlcy50ZXh0dXJlKXtPJiZPLmltYWdlJiYoTy5zb3VyY2VSZWN0JiYoUC5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q9Ty5zb3VyY2VSZWN0KSxQLnRleHR1cmVJbWFnZVJvdGF0ZWQ9ISFPLnJvdGF0ZWQsTz1PLmltYWdlKTtjb25zdHt3aWR0aDpvLGhlaWdodDpoLHRleHR1cmVSZWN0OmN9PVAuYXR0cmlidXRlcyxnPVAudGV4dHVyZUltYWdlO1AudGV4dHVyZUltYWdlPU8sbSYmZyE9PU8mJiFjJiYobz09bnVsbHx8aD09bnVsbCkmJlAudXBkYXRlQ29udG91cnMoKSxQLmZvcmNlVXBkYXRlKCl9cmV0dXJuIE99Y29uc3Qgcz1TeW1ib2woInRleHR1cmVNYXAiKTtmdW5jdGlvbiBmKFAseCl7aWYoeFtzXT14W3NdfHxuZXcgTWFwLHhbc10uaGFzKFApKXJldHVybiB4W3NdLmdldChQKTtjb25zdCBtPXguY3JlYXRlVGV4dHVyZShQKTtyZXR1cm4hL15ibG9iOi8udGVzdChQLnNyYykmJnR5cGVvZiBQLmdldENvbnRleHQhPSJmdW5jdGlvbiImJnhbc10uc2V0KFAsbSksbX1mdW5jdGlvbiB2KFAseCl7aWYoeFtzXSYmeFtzXS5oYXMoUCkpe2NvbnN0IG09eFtzXS5nZXQoUCk7cmV0dXJuIHguZGVsZXRlVGV4dHVyZShtKSx4W3NdLmRlbGV0ZShQKSwhMH1yZXR1cm4hMX1jb25zdCBkPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKTtmdW5jdGlvbiBwKFAseCl7Y29uc3QgbT1QLnRleHR1cmVJbWFnZSBpbnN0YW5jZW9mIFN0cmluZz9TdHJpbmcoUC50ZXh0dXJlSW1hZ2UpOlAudGV4dHVyZUltYWdlLE89UC50ZXh0dXJlSW1hZ2VSb3RhdGVkLG89eC50ZXh0dXJlLGg9UC5yZW5kZXJlcjtpZihtKXtjb25zdCBjPVAub3JpZ2luYWxDb250ZW50UmVjdDtsZXQgZz1QLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q7Y29uc3QgYj1QLmF0dHJpYnV0ZXMudGV4dHVyZVJlcGVhdCxFPVAuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKCFvfHxQW2RdJiZQW2RdIT09aHx8by5pbWFnZSE9PW18fG8ub3B0aW9ucy5yZXBlYXQhPT1ifHwhT2JqZWN0KG4uY29tcGFyZVZhbHVlKShvLm9wdGlvbnMucmVjdCxnKXx8IU9iamVjdChuLmNvbXBhcmVWYWx1ZSkoby5vcHRpb25zLnNyY1JlY3QsRSkpe2NvbnN0IEE9ZihtLGgpO2c/KGdbMF0rPWNbMF0sZ1sxXSs9Y1sxXSk6Zz1jO2xldCBMPW51bGw7byYmIWhbc10uaGFzKG8uaW1hZ2UpJiYoIW8ub3B0aW9uc3x8IW8ub3B0aW9ucy5oaWRkZW4pJiYoTD14LnVuaWZvcm1zLnVfdGV4U2FtcGxlcikseC5zZXRUZXh0dXJlKEEse3JlY3Q6ZyxyZXBlYXQ6YixzcmNSZWN0OkUscm90YXRlZDpPfSksTCYmTC5kZWxldGUmJkwuZGVsZXRlKCksUFtkXT1ofX1lbHNlIGlmKG8pe2xldCBjPW51bGw7IWhbc10uaGFzKG8uaW1hZ2UpJiYoIW8ub3B0aW9uc3x8IW8ub3B0aW9ucy5oaWRkZW4pJiYoYz14LnVuaWZvcm1zLnVfdGV4U2FtcGxlcikseC5zZXRUZXh0dXJlKG51bGwpLGMmJmMuZGVsZXRlJiZjLmRlbGV0ZSgpfX1hc3luYyBmdW5jdGlvbiB5KFAseCl7dHlwZW9mIHg9PSJzdHJpbmciJiYoeD1hd2FpdChhd2FpdCBmZXRjaCh4LHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkpLmpzb24oKSk7Y29uc3QgbT1hd2FpdCBhKFApLE89eC5mcmFtZXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKE8pLmZvckVhY2goKFtvLGhdKT0+e2NvbnN0e3g6Yyx5OmcsdzpiLGg6RX09aC5mcmFtZTtsZXQgQT1bYyxnLGIsRV07Y29uc3QgTD1oLnJvdGF0ZWQ7TCYmKEE9W0FbMF0sQVsxXSxBWzNdLEFbMl1dKSxpW29dPXtpbWFnZTptLHNvdXJjZVJlY3Q6QSxyb3RhdGVkOkx9fSksbX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDEpLG49dCgxMiksaT10KDcwKSxhPXQoMjIwKSxsPXQoMjIxKSxzPXQoMjIyKSxmPXQoMjEzKSx2PXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZChQLHgsbSl7cmV0dXJuIHggaW4gUD9PYmplY3QuZGVmaW5lUHJvcGVydHkoUCx4LHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6UFt4XT1tLFB9Y29uc3QgcD1TeW1ib2woIm1lc2giKTtjbGFzcyB5IGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKHg9e30pe3N1cGVyKHgpfWdldCBib3JkZXJTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDp4LHBhZGRpbmdSaWdodDptLHBhZGRpbmdCb3R0b206TyxwYWRkaW5nTGVmdDpvLGJvcmRlcldpZHRoOmh9PXRoaXMuYXR0cmlidXRlcyxbYyxnXT10aGlzLmNvbnRlbnRTaXplO3JldHVybltvK2MrbStoLHgrZytPK2hdfWdldCBjbGllbnRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDp4LHBhZGRpbmdSaWdodDptLHBhZGRpbmdCb3R0b206TyxwYWRkaW5nTGVmdDpvfT10aGlzLmF0dHJpYnV0ZXMsW2gsY109dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bbytoK20seCtjK09dfWdldCBjb250ZW50U2l6ZSgpe2xldHt3aWR0aDp4LGhlaWdodDptLGJveFNpemluZzpPLHBhZGRpbmdUb3A6byxwYWRkaW5nUmlnaHQ6aCxwYWRkaW5nQm90dG9tOmMscGFkZGluZ0xlZnQ6Z309dGhpcy5hdHRyaWJ1dGVzO2lmKHg9eHx8MCxtPW18fDAsTz09PSJib3JkZXItYm94Iil7Y29uc3QgYj0yKnRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDt4LT1iK2grZyxtLT1iK28rYyx4PU1hdGgubWF4KDAseCksbT1NYXRoLm1heCgwLG0pfXJldHVyblt4LG1dfWdldCBoYXNCb3JkZXIoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoPjB9Z2V0IGlzVmlzaWJsZSgpe2NvbnN0W3gsbV09dGhpcy5ib3JkZXJTaXplO3JldHVybiB4PjAmJm0+MH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IHg9dGhpcy5jbGllbnRCb3g7aWYoeCl7bGV0IG09dGhpc1twXTtpZihtKW0uYm94IT09eCYmKG0uY29udG91cnM9eC5jb250b3VycyxtLmJveD14KTtlbHNle209bmV3IG4uTWVzaDJEKHgpLG0uYm94PXg7Y29uc3Qgbz10aGlzLmF0dHJpYnV0ZXMuYmdjb2xvcjtpZihPYmplY3QobC5zZXRGaWxsQ29sb3IpKG0se2NvbG9yOm99KSx0aGlzLmhhc0JvcmRlcil7Y29uc3R7Ym9yZGVyQ29sb3I6Yyxib3JkZXJXaWR0aDpnLGJvcmRlckRhc2g6Yixib3JkZXJEYXNoT2Zmc2V0OkV9PXRoaXMuYXR0cmlidXRlcztPYmplY3QobC5zZXRTdHJva2VDb2xvcikobSx7Y29sb3I6YyxsaW5lV2lkdGg6ZyxsaW5lRGFzaDpiLGxpbmVEYXNoT2Zmc2V0OkV9KX10aGlzW3BdPW07Y29uc3QgaD10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7aCYmdGhpc1twXS5zZXRDbGlwUGF0aChoKX1jb25zdCBPPXRoaXMub3BhY2l0eTtyZXR1cm4gbS5nZXRPcGFjaXR5KCkhPT1PJiZtLnNldE9wYWNpdHkoTyksbS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLG19cmV0dXJuIG51bGx9Z2V0IG9mZnNldFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOngscGFkZGluZ1JpZ2h0Om0scGFkZGluZ0JvdHRvbTpPLHBhZGRpbmdMZWZ0Om8sYm9yZGVyV2lkdGg6aH09dGhpcy5hdHRyaWJ1dGVzLFtjLGddPXRoaXMuY29udGVudFNpemUsYj0yKmg7cmV0dXJuW28rYyttK2IseCtnK08rYl19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgeD10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW3hbMF1bMF0seFswXVsxXSx4WzFdWzBdLXhbMF1bMF0seFsxXVsxXS14WzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtjb25zdFt4LG0sTyxvXT10aGlzLm9yaWdpbmFsQ2xpZW50UmVjdCxoPXRoaXMuYXR0cmlidXRlcy5wYWRkaW5nO3JldHVyblt4K2hbMF0sbStoWzFdLE8taFswXS1oWzJdLG8taFsxXS1oWzNdXX1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgeD10aGlzLnJlbmRlck1hdHJpeDt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLmxheWVyVHJhbnNmb3JtSW52ZXJ0JiYoeD1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLmxheWVyLnRyYW5zZm9ybU1hdHJpeCx4KSk7bGV0IG09bnVsbDtpZih0aGlzLm1lc2gpe209Wy4uLnRoaXMubWVzaC5ib3VuZGluZ0JveF07Y29uc3QgTz10aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7TyYmKG1bMF09W21bMF1bMF0tTyxtWzBdWzFdLU9dLG1bMV09W21bMV1bMF0rTyxtWzFdWzFdK09dKX1yZXR1cm4gT2JqZWN0KHYuZGVmYXVsdCkobSx4KX1vblByb3BlcnR5Q2hhbmdlKHgsbSxPKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKHgsbSxPKSwoeD09PSJhbmNob3JYInx8eD09PSJhbmNob3JZInx8eD09PSJib3hTaXppbmcifHx4PT09IndpZHRoInx8eD09PSJoZWlnaHQifHx4PT09ImJvcmRlcldpZHRoInx8eD09PSJwYWRkaW5nTGVmdCJ8fHg9PT0icGFkZGluZ1JpZ2h0Inx8eD09PSJwYWRkaW5nVG9wInx8eD09PSJwYWRkaW5nQm90dG9tInx8L15ib3JkZXIoVG9wTGVmdHxUb3BSaWdodHxCb3R0b21SaWdodHxCb3R0b21MZWZ0KVJhZGl1cyQvLnRlc3QoeCkpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1twXSYmeD09PSJjbGlwUGF0aCImJnRoaXNbcF0uc2V0Q2xpcFBhdGgobSksdGhpc1twXSYmeD09PSJiZ2NvbG9yIiYmT2JqZWN0KGwuc2V0RmlsbENvbG9yKSh0aGlzW3BdLHtjb2xvcjptfSksdGhpc1twXSYmKHg9PT0iYm9yZGVyQ29sb3IifHx4PT09ImJvcmRlcldpZHRoInx8eD09PSJib3JkZXJEYXNoInx8eD09PSJib3JkZXJEYXNoT2Zmc2V0Iikpe2NvbnN0e2JvcmRlckNvbG9yOm8sYm9yZGVyV2lkdGg6aCxib3JkZXJEYXNoOmMsYm9yZGVyRGFzaE9mZnNldDpnfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGwuc2V0U3Ryb2tlQ29sb3IpKHRoaXNbcF0se2NvbG9yOm8sbGluZVdpZHRoOmgsbGluZURhc2g6aD9jOjAsbGluZURhc2hPZmZzZXQ6Z30pfX11cGRhdGVDb250b3Vycygpe2NvbnN0e2FuY2hvclg6eCxhbmNob3JZOm0sYm9yZGVyV2lkdGg6Tyxib3JkZXJSYWRpdXM6b309dGhpcy5hdHRyaWJ1dGVzLFtoLGNdPXRoaXMuYm9yZGVyU2l6ZSxnPXRoaXMub2Zmc2V0U2l6ZSxiPS41Kk8sRT0teCpnWzBdK2IsQT0tbSpnWzFdK2I7dGhpcy5jbGllbnRCb3g9bmV3IG4uRmlndXJlMkQsT2JqZWN0KHMuY3JlYXRlUmFkaXVzQm94KSh0aGlzLmNsaWVudEJveCxbRSxBLGgsY10sbyl9fWQoeSwiQXR0ciIsYS5kZWZhdWx0KSxmLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHksImJsb2NrIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDcxKSxuPXQoNzIpLGk9dCgyMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIikscz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyB2IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKHApe3N1cGVyKHApLHRoaXNbc10oe2FuY2hvclg6MCxhbmNob3JZOjAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsYm9yZGVyV2lkdGg6MCxib3JkZXJDb2xvcjoicmdiYSgwLDAsMCwxKSIsYm9yZGVyRGFzaDp2b2lkIDAsYm9yZGVyRGFzaE9mZnNldDowLGJvcmRlclRvcExlZnRSYWRpdXM6WzAsMF0sYm9yZGVyVG9wUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tTGVmdFJhZGl1czpbMCwwXSxiZ2NvbG9yOiJyZ2JhKDAsMCwwLDApIixwYWRkaW5nVG9wOjAscGFkZGluZ1JpZ2h0OjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsY2xpcFBhdGg6dm9pZCAwfSksdGhpc1tmXSgiYW5jaG9yIiwic2l6ZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciKX1nZXQgYW5jaG9yWCgpe3JldHVybiB0aGlzW2xdKCJhbmNob3JYIil9c2V0IGFuY2hvclgocCl7dGhpc1thXSgiYW5jaG9yWCIsT2JqZWN0KG4udG9OdW1iZXIpKHApKX1nZXQgYW5jaG9yWSgpe3JldHVybiB0aGlzW2xdKCJhbmNob3JZIil9c2V0IGFuY2hvclkocCl7dGhpc1thXSgiYW5jaG9yWSIsT2JqZWN0KG4udG9OdW1iZXIpKHApKX1nZXQgYW5jaG9yKCl7cmV0dXJuW3RoaXMuYW5jaG9yWCx0aGlzLmFuY2hvclldfXNldCBhbmNob3IocCl7cD1PYmplY3Qobi50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy5hbmNob3JYPXBbMF0sdGhpcy5hbmNob3JZPXBbMV19Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbbF0oIndpZHRoIil9c2V0IHdpZHRoKHApe3RoaXNbYV0oIndpZHRoIixPYmplY3Qobi50b051bWJlcikocCkpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1tsXSgiaGVpZ2h0Iil9c2V0IGhlaWdodChwKXt0aGlzW2FdKCJoZWlnaHQiLE9iamVjdChuLnRvTnVtYmVyKShwKSl9Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUocCl7cD1PYmplY3Qobi50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpcy53aWR0aD1wWzBdLHRoaXMuaGVpZ2h0PXBbMV19Z2V0IGJvcmRlcldpZHRoKCl7cmV0dXJuIHRoaXNbbF0oImJvcmRlcldpZHRoIil9c2V0IGJvcmRlcldpZHRoKHApe3RoaXNbYV0oImJvcmRlcldpZHRoIixPYmplY3Qobi50b051bWJlcikocCkpfWdldCBib3JkZXJDb2xvcigpe3JldHVybiB0aGlzW2xdKCJib3JkZXJDb2xvciIpfXNldCBib3JkZXJDb2xvcihwKXt0aGlzW2FdKCJib3JkZXJDb2xvciIsT2JqZWN0KGkucGFyc2VDb2xvcikocCkpfWdldCBib3JkZXIoKXtyZXR1cm5bdGhpcy5ib3JkZXJXaWR0aCx0aGlzLmJvcmRlckNvbG9yXX1zZXQgYm9yZGVyKHApe3A9T2JqZWN0KG4udG9BcnJheSkocCksQXJyYXkuaXNBcnJheShwKXx8KHA9W3BdKSx0aGlzLmJvcmRlcldpZHRoPXBbMF0scFsxXSE9bnVsbCYmKHRoaXMuYm9yZGVyQ29sb3I9cFsxXSl9Z2V0IGJvcmRlckRhc2goKXtyZXR1cm4gdGhpc1tsXSgiYm9yZGVyRGFzaCIpfXNldCBib3JkZXJEYXNoKHApe3A9T2JqZWN0KG4udG9BcnJheSkocCwhMCkscCE9bnVsbCYmIUFycmF5LmlzQXJyYXkocCkmJihwPVtwXSksdGhpc1thXSgiYm9yZGVyRGFzaCIscD9wLm1hcChuLnRvTnVtYmVyKTpudWxsKX1nZXQgYm9yZGVyRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW2xdKCJib3JkZXJEYXNoT2Zmc2V0Iil9c2V0IGJvcmRlckRhc2hPZmZzZXQocCl7dGhpc1thXSgiYm9yZGVyRGFzaE9mZnNldCIsT2JqZWN0KG4udG9OdW1iZXIpKHApKX1nZXQgYm9yZGVyVG9wTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW2xdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIil9c2V0IGJvcmRlclRvcExlZnRSYWRpdXMocCl7cD1PYmplY3Qobi50b0FycmF5KShwLCEwKSxBcnJheS5pc0FycmF5KHApfHwocD1bcCxwXSksdGhpc1thXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIscC5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJUb3BSaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2xdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIpfXNldCBib3JkZXJUb3BSaWdodFJhZGl1cyhwKXtwPU9iamVjdChuLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzW2FdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIscC5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2xdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyhwKXtwPU9iamVjdChuLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzW2FdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIscC5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbbF0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyhwKXtwPU9iamVjdChuLnRvQXJyYXkpKHAsITApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzW2FdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIixwLm1hcChuLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclJhZGl1cygpe3JldHVyblsuLi50aGlzLmJvcmRlclRvcExlZnRSYWRpdXMsLi4udGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1c119c2V0IGJvcmRlclJhZGl1cyhwKXtpZihwPU9iamVjdChuLnRvQXJyYXkpKHApLCFBcnJheS5pc0FycmF5KHApKXA9QXJyYXkoOCkuZmlsbChwKTtlbHNlIGlmKHAubGVuZ3RoPT09MilwPVtwWzBdLHBbMV0scFswXSxwWzFdLHBbMF0scFsxXSxwWzBdLHBbMV1dO2Vsc2UgaWYocC5sZW5ndGg9PT00KXA9W3BbMF0scFsxXSxwWzJdLHBbM10scFswXSxwWzFdLHBbMl0scFszXV07ZWxzZSBpZihwLmxlbmd0aD09PTYpcD1bcFswXSxwWzFdLHBbMl0scFszXSxwWzRdLHBbNV0scFsyXSxwWzNdXTtlbHNlIGlmKHAubGVuZ3RoIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJvcmRlclJhZGl1cyB2YWx1ZS4iKTt0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9W3BbMF0scFsxXV0sdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cz1bcFsyXSxwWzNdXSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPVtwWzRdLHBbNV1dLHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1bcFs2XSxwWzddXX1nZXQgYmdjb2xvcigpe3JldHVybiB0aGlzW2xdKCJiZ2NvbG9yIil9c2V0IGJnY29sb3IocCl7dGhpc1thXSgiYmdjb2xvciIsT2JqZWN0KGkucGFyc2VDb2xvcikocCkpfWdldCBwYWRkaW5nVG9wKCl7cmV0dXJuIHRoaXNbbF0oInBhZGRpbmdUb3AiKX1zZXQgcGFkZGluZ1RvcChwKXt0aGlzW2FdKCJwYWRkaW5nVG9wIixPYmplY3Qobi50b051bWJlcikocCkpfWdldCBwYWRkaW5nUmlnaHQoKXtyZXR1cm4gdGhpc1tsXSgicGFkZGluZ1JpZ2h0Iil9c2V0IHBhZGRpbmdSaWdodChwKXt0aGlzW2FdKCJwYWRkaW5nUmlnaHQiLE9iamVjdChuLnRvTnVtYmVyKShwKSl9Z2V0IHBhZGRpbmdCb3R0b20oKXtyZXR1cm4gdGhpc1tsXSgicGFkZGluZ0JvdHRvbSIpfXNldCBwYWRkaW5nQm90dG9tKHApe3RoaXNbYV0oInBhZGRpbmdCb3R0b20iLE9iamVjdChuLnRvTnVtYmVyKShwKSl9Z2V0IHBhZGRpbmdMZWZ0KCl7cmV0dXJuIHRoaXNbbF0oInBhZGRpbmdMZWZ0Iil9c2V0IHBhZGRpbmdMZWZ0KHApe3RoaXNbYV0oInBhZGRpbmdMZWZ0IixPYmplY3Qobi50b051bWJlcikocCkpfWdldCBwYWRkaW5nKCl7cmV0dXJuW3RoaXMucGFkZGluZ1RvcCx0aGlzLnBhZGRpbmdSaWdodCx0aGlzLnBhZGRpbmdCb3R0b20sdGhpcy5wYWRkaW5nTGVmdF19c2V0IHBhZGRpbmcocCl7cD1PYmplY3Qobi50b0FycmF5KShwKSxBcnJheS5pc0FycmF5KHApP3AubGVuZ3RoPT09Mj9wPVtwWzBdLHBbMV0scFswXSxwWzFdXTpwLmxlbmd0aD09PTMmJihwPVtwWzBdLHBbMV0scFsyXSxwWzFdXSk6cD1bcCxwLHAscF0sdGhpcy5wYWRkaW5nVG9wPXBbMF0sdGhpcy5wYWRkaW5nUmlnaHQ9cFsxXSx0aGlzLnBhZGRpbmdCb3R0b209cFsyXSx0aGlzLnBhZGRpbmdMZWZ0PXBbM119Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbbF0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKHApe3RoaXNbYV0oImNsaXBQYXRoIixwKX1nZXQgYm94U2l6aW5nKCl7cmV0dXJuIHRoaXNbbF0oImJveFNpemluZyIpfXNldCBib3hTaXppbmcocCl7aWYocCE9bnVsbCYmcCE9PSJib3JkZXItYm94IiYmcCE9PSJjb250ZW50LWJveCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3hTaXppbmcgdHlwZS4iKTt0aGlzW2FdKCJib3hTaXppbmciLHApfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImlzVHJhbnNwYXJlbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzZXRGaWxsQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwic2V0U3Ryb2tlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDMyKSxuPXQubihyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgaXtjb25zdHJ1Y3Rvcih7dmVjdG9yOnksY29sb3JzOlB9KXtpZighQXJyYXkuaXNBcnJheSh5KXx8eS5sZW5ndGghPT00JiZ5Lmxlbmd0aCE9PTYmJnkubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGdyYWRpZW50Iik7dGhpcy52ZWN0b3I9eSx0aGlzLmNvbG9ycz1QLm1hcCgoe29mZnNldDp4LGNvbG9yOm19KT0+KHtvZmZzZXQ6eCxjb2xvcjpsKG0pfSkpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt2ZWN0b3I6dGhpcy52ZWN0b3IsY29sb3JzOnRoaXMuY29sb3JzfSl9fWZ1bmN0aW9uIGEocCl7cmV0dXJuIHAgaW5zdGFuY2VvZiBpPyExOnA9PW51bGw/ITA6bigpKHApWzNdPT09MH1mdW5jdGlvbiBsKHApe2lmKHA9PW51bGx8fChwfHwocD0idHJhbnNwYXJlbnQiKSxwIGluc3RhbmNlb2YgaSkpcmV0dXJuIHA7Y29uc3QgeT1uKCkocCk7aWYoIXl8fCF5Lmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybmByZ2JhKCR7eS5qb2luKCl9KWB9ZnVuY3Rpb24gcyhwLHksUCl7Y29uc3QgeD1wLmJvdW5kaW5nQm94WzBdO2lmKFAudmVjdG9yKXtsZXR7dmVjdG9yOm0sY29sb3JzOk99PVA7bS5sZW5ndGg9PT00PyhtPVttWzBdK3hbMF0sbVsxXSt4WzFdLG1bMl0reFswXSxtWzNdK3hbMV1dLHAuc2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjptLGNvbG9yczpPLHR5cGU6eX0pKTptLmxlbmd0aD09PTM/KG09W21bMF0reFswXSxtWzFdK3hbMV0sbVsyXV0scC5zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6bSxjb2xvcnM6Tyx0eXBlOnl9KSk6KG09W21bMF0reFswXSxtWzFdK3hbMV0sbVsyXSxtWzNdK3hbMF0sbVs0XSt4WzFdLG1bNV1dLHAuc2V0UmFkaWFsR3JhZGllbnQoe3ZlY3RvcjptLGNvbG9yczpPLHR5cGU6eX0pKX1lbHNlIHAuZ3JhZGllbnQmJnAuZ3JhZGllbnRbeV0mJihkZWxldGUgcC5ncmFkaWVudFt5XSxkZWxldGUgcC51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yKX1mdW5jdGlvbiBmKHAse2NvbG9yOnkscnVsZTpQPSJub256ZXJvIn0pe3JldHVybiBzKHAsImZpbGwiLHkpLHkudmVjdG9yfHxwLnNldEZpbGwoe2NvbG9yOnkscnVsZTpQfSkscH1mdW5jdGlvbiB2KHAse2NvbG9yOnksbGluZVdpZHRoOlAsbGluZUNhcDp4LGxpbmVKb2luOm0sbGluZURhc2g6TyxsaW5lRGFzaE9mZnNldDpvLG1pdGVyTGltaXQ6aCxyb3VuZFNlZ21lbnRzOmN9KXtzKHAsInN0cm9rZSIseSkseS52ZWN0b3ImJih5PVswLDAsMCwxXSkscC5zZXRTdHJva2Uoe2NvbG9yOnksdGhpY2tuZXNzOlAsY2FwOngsam9pbjptLG1pdGVyTGltaXQ6aCxsaW5lRGFzaDpPLGxpbmVEYXNoT2Zmc2V0Om8scm91bmRTZWdtZW50czpjfSl9Y2xhc3MgZCBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKHk9MCxQPTAseD0wLG09MCl7cmV0dXJuIEFycmF5LmlzQXJyYXkoeSkmJihbeSxQLHgsbV09eSksdHlwZW9mIHk9PSJzdHJpbmciJiYoW3ksUCx4LG1dPW4oKSh5KSx5Lz0yNTUsUC89MjU1LHgvPTI1NSksc3VwZXIoeSxQLHgsbSksdGhpc31nZXQgcigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMF0qMjU1KX1zZXQgcih5KXt0aGlzWzBdPXkvMjU1fWdldCBnKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1sxXSoyNTUpfXNldCBnKHkpe3RoaXNbMV09eS8yNTV9Z2V0IGIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzJdKjI1NSl9c2V0IGIoeSl7dGhpc1syXT15LzI1NX1nZXQgYSgpe3JldHVybiB0aGlzWzNdfXNldCBhKHkpe3RoaXNbM109eX1nZXQgaGV4KCl7Y29uc3QgeT1gMCR7dGhpcy5yLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxQPWAwJHt0aGlzLmcudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLHg9YDAke3RoaXMuYi50b1N0cmluZygxNil9YC5zbGljZSgtMik7bGV0IG07cmV0dXJuIHRoaXMuYTwxJiYobT1NYXRoLnJvdW5kKHRoaXNbM10qMjU1KSxtPWAwJHttLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSksYCMke3l9JHtQfSR7eH0ke218fCIifWB9Z2V0IHJnYmEoKXtyZXR1cm5gcmdiYSgke3RoaXMucn0sJHt0aGlzLmd9LCR7dGhpcy5ifSwke3RoaXMuYX0pYH1mcm9tQ29sb3IoeSl7cmV0dXJuIHR5cGVvZiB5PT0ic3RyaW5nIiYmKHk9bigpKHkpLHlbMF0vPTI1NSx5WzFdLz0yNTUseVsyXS89MjU1KSx0aGlzWzBdPXlbMF0sdGhpc1sxXT15WzFdLHRoaXNbMl09eVsyXSx0aGlzWzNdPXlbM10sdGhpc319fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVSYWRpdXNCb3giLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihpLGEsbCxzLGYsdj0ibGVmdFRvcCIpe2NvbnN0IGQ9LjU1MjI4NDgscD1zLzIqZCx5PWYvMipkLFA9YStzLHg9bCtmLG09YStzLzIsTz1sK2YvMjt2PT09ImxlZnRUb3AiPyhpLm1vdmVUbyhhLE8pLGkuYmV6aWVyQ3VydmVUbyhhLE8teSxtLXAsbCxtLGwpKTp2PT09InJpZ2h0VG9wIj9pLmJlemllckN1cnZlVG8obStwLGwsUCxPLXksUCxPKTp2PT09InJpZ2h0Qm90dG9tIj9pLmJlemllckN1cnZlVG8oUCxPK3ksbStwLHgsbSx4KTp2PT09ImxlZnRCb3R0b20iJiZpLmJlemllckN1cnZlVG8obS1wLHgsYSxPK3ksYSxPKX1mdW5jdGlvbiBuKGksW2EsbCxzLGZdLHYpe2lmKCF2fHxBcnJheS5pc0FycmF5KHYpJiZ2LmV2ZXJ5KGQ9PmQ9PT0wKSlpLmJlZ2luUGF0aCgpLGkucmVjdChhLGwscyxmKTtlbHNle3R5cGVvZiB2PT0ibnVtYmVyIiYmKHY9QXJyYXkoOCkuZmlsbCh2KSk7Y29uc3RbZCxwLHksUCx4LG0sTyxvXT12Lm1hcCgoaCxjKT0+YyUyP01hdGgubWluKGgsZi8yKTpNYXRoLm1pbihoLHMvMikpO2kuYmVnaW5QYXRoKCksaS5tb3ZlVG8oYSxsK3ApLHIoaSxhLGwsZCoyLHAqMiwibGVmdFRvcCIpLGkubGluZVRvKGErcy15LGwpLHIoaSxhK3MteSoyLGwseSoyLFAqMiwicmlnaHRUb3AiKSxpLmxpbmVUbyhhK3MsbCtmLW0pLHIoaSxhK3MteCoyLGwrZi1tKjIseCoyLG0qMiwicmlnaHRCb3R0b20iKSxpLmxpbmVUbyhhK08sbCtmKSxyKGksYSxsK2YtbyoyLE8qMixvKjIsImxlZnRCb3R0b20iKSxpLmNsb3NlUGF0aCgpfXJldHVybiBpfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWZ1bmN0aW9uKHIsbil7aWYoIXIpcmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH07Y29uc3RbW2ksYV0sW2wsc11dPXIsZj1pKm5bMF0rYSpuWzJdK25bNF0sdj1pKm5bMV0rYSpuWzNdK25bNV0sZD1sKm5bMF0rYSpuWzJdK25bNF0scD1sKm5bMV0rYSpuWzNdK25bNV0seT1sKm5bMF0rcypuWzJdK25bNF0sUD1sKm5bMV0rcypuWzNdK25bNV0seD1pKm5bMF0rcypuWzJdK25bNF0sbT1pKm5bMV0rcypuWzNdK25bNV0sTz1NYXRoLm1pbihmLGQseSx4KSxvPU1hdGgubWluKHYscCxQLG0pLGg9TWF0aC5tYXgoZixkLHkseCksYz1NYXRoLm1heCh2LHAsUCxtKTtyZXR1cm57eDpPLHk6byx3aWR0aDpoLU8saGVpZ2h0OmMtbyxsZWZ0Ok8sdG9wOm8scmlnaHQ6aCxib3R0b206Y319fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMTgpLG49dCgyMTkpLGk9dCgyMjUpLGE9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKHYsZCxwKXtyZXR1cm4gZCBpbiB2P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LGQse3ZhbHVlOnAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp2W2RdPXAsdn1jb25zdCBzPVN5bWJvbCgidGV4dHVyZVRhc2siKTtjbGFzcyBmIGV4dGVuZHMgbi5kZWZhdWx0e2NvbnN0cnVjdG9yKGQ9e30pe3R5cGVvZiBkPT0ic3RyaW5nIiYmKGQ9e3RleHR1cmU6ZH0pLHN1cGVyKGQpfWdldCBjb250ZW50U2l6ZSgpe2xldFtkLHBdPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOnksaGVpZ2h0OlB9PXRoaXMuYXR0cmlidXRlcztpZih5PT1udWxsfHxQPT1udWxsKXtjb25zdCB4PXRoaXMudGV4dHVyZUltYWdlLG09dGhpcy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0LE89dGhpcy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYobSl5PT1udWxsJiYoZD1tWzBdK21bMl0pLFA9PW51bGwmJihwPW1bMV0rbVszXSk7ZWxzZSBpZihPKXtjb25zdCBvPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt5PT1udWxsJiYoZD1PWzJdL28pLFA9PW51bGwmJihwPU9bM10vbyl9ZWxzZSBpZih4KXtjb25zdCBvPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt5PT1udWxsJiYoZD14LndpZHRoL28pLFA9PW51bGwmJihwPXguaGVpZ2h0L28pfX1yZXR1cm5bZCxwXX1nZXQgdGV4dHVyZUltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1tzXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhkPVtdKXtzdXBlci5kcmF3KGQpO2NvbnN0IHA9dGhpcy5tZXNoO3JldHVybiBwJiZPYmplY3Qoci5kcmF3VGV4dHVyZSkodGhpcyxwKSxkfW9uUHJvcGVydHlDaGFuZ2UoZCxwLHkpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoZCxwLHkpLGQ9PT0idGV4dHVyZSImJih0aGlzW3NdPU9iamVjdChyLmFwcGx5VGV4dHVyZSkodGhpcyxwLCEwKSksZD09PSJ0ZXh0dXJlUmVjdCIpe2NvbnN0e3dpZHRoOlAsaGVpZ2h0Onh9PXRoaXMuYXR0cmlidXRlczsoUD09bnVsbHx8eD09bnVsbCkmJnRoaXMudXBkYXRlQ29udG91cnMoKX19fWwoZiwiQXR0ciIsaS5kZWZhdWx0KSxhLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGYsInNwcml0ZSIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBuPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxpPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW25dKHt0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMH0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbYV0oInRleHR1cmUiKX1zZXQgdGV4dHVyZShmKXt0aGlzW2ldKCJ0ZXh0dXJlIixmKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1thXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoZil7dGhpc1tpXSgidGV4dHVyZVJlY3QiLGYpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbYV0oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChmKXt0aGlzW2ldKCJzb3VyY2VSZWN0IixmKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW2FdKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoZil7dGhpc1tpXSgidGV4dHVyZVJlcGVhdCIsISFmKX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBQfSk7dmFyIHI9dCgxMiksbj10KDIyNyksaT10Lm4obiksYT10KDcwKSxsPXQoMjI4KSxzPXQoMjIxKSxmPXQoMjE4KSx2PXQoMjEzKSxkPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcCh4LG0sTyl7cmV0dXJuIG0gaW4geD9PYmplY3QuZGVmaW5lUHJvcGVydHkoeCxtLHt2YWx1ZTpPLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6eFttXT1PLHh9Y29uc3QgeT1TeW1ib2woIm1lc2giKTtjbGFzcyBQIGV4dGVuZHMgYS5kZWZhdWx0e2NvbnN0cnVjdG9yKG09e30pe3R5cGVvZiBtPT0ic3RyaW5nIiYmKG09e2Q6bX0pLHN1cGVyKG0pLHRoaXMuZWZmZWN0cz17ZChPLG8saCxjLGcpe2NvbnN0IGI9KGgtYykvKGctYyk7aWYoYjw9MClyZXR1cm4gTztpZihiPj0xKXJldHVybiBvO2NvbnN0IEU9aS5hLl9wcmVwcm9jZXNzaW5nKGkuYS5wYXRoMnNoYXBlcyhPKSxpLmEucGF0aDJzaGFwZXMobykpLEE9aS5hLl9sZXJwKC4uLkUsYilbMF07cmV0dXJuIEEucmVkdWNlKChNLEkpPT5gJHtNfSR7SS5zbGljZSgyKS5qb2luKCIgIil9IGAsYE0ke0FbMF1bMF19ICR7QVswXVsxXX1DYCkudHJpbSgpfX19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5kfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgbT10aGlzLnBhdGg7aWYobSl7bGV0IE89dGhpc1t5XTtpZihPKU8ucGF0aCE9PW0mJihPLmNvbnRvdXJzPW0uY29udG91cnMsTy5wYXRoPW0pO2Vsc2V7Tz1uZXcgci5NZXNoMkQodGhpcy5wYXRoKSxPLnBhdGg9bTtjb25zdCBoPXRoaXMuYXR0cmlidXRlcy5maWxsQ29sb3IsYz10aGlzLmF0dHJpYnV0ZXMuZmlsbFJ1bGU7aCYmT2JqZWN0KHMuc2V0RmlsbENvbG9yKShPLHtjb2xvcjpoLHJ1bGU6Y30pO2NvbnN0IGc9dGhpcy5hdHRyaWJ1dGVzLmxpbmVXaWR0aCxiPXRoaXMuYXR0cmlidXRlcy5zdHJva2VDb2xvcjtpZihiJiZnPjApe2NvbnN0e2xpbmVDYXA6QSxsaW5lSm9pbjpMLG1pdGVyTGltaXQ6TSxsaW5lRGFzaDpJLGxpbmVEYXNoT2Zmc2V0OkQscm91bmRTZWdtZW50czpSfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHMuc2V0U3Ryb2tlQ29sb3IpKE8se2NvbG9yOmIsbGluZVdpZHRoOmcsbGluZUNhcDpBLGxpbmVKb2luOkwsbWl0ZXJMaW1pdDpNLGxpbmVEYXNoOkksbGluZURhc2hPZmZzZXQ6RCxyb3VuZFNlZ21lbnRzOlJ9KX10aGlzW3ldPU87Y29uc3QgRT10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7RSYmdGhpc1t5XS5zZXRDbGlwUGF0aChFKX1jb25zdCBvPXRoaXMub3BhY2l0eTtyZXR1cm4gTy5nZXRPcGFjaXR5KCkhPT1vJiZPLnNldE9wYWNpdHkobyksTy5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLE99cmV0dXJuIG51bGx9Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtpZih0aGlzLnBhdGgpe2NvbnN0IG09dGhpcy5wYXRoLmJvdW5kaW5nQm94O3JldHVyblttWzBdWzBdLG1bMF1bMV0sbVsxXVswXS1tWzBdWzBdLG1bMV1bMV0tbVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IG09dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVyblttWzBdWzBdLG1bMF1bMV0sbVsxXVswXS1tWzBdWzBdLG1bMV1bMV0tbVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudENlbnRlcigpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmJvdW5kaW5nQ2VudGVyOlswLDBdfXNldCBkKG0pe3RoaXMuYXR0cmlidXRlcy5kPW19Z2V0IGQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmR9ZHJhdyhtPVtdKXtzdXBlci5kcmF3KG0pO2NvbnN0IE89dGhpcy5tZXNoO3JldHVybiBPJiZPYmplY3QoZi5kcmF3VGV4dHVyZSkodGhpcyxPKSxtfWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCBtPW51bGw7cmV0dXJuIHRoaXMubWVzaCYmKG09dGhpcy5tZXNoLmJvdW5kaW5nQm94KSxPYmplY3QoZC5kZWZhdWx0KShtLHRoaXMucmVuZGVyTWF0cml4KX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guZ2V0VG90YWxMZW5ndGgoKTowfWdldFBvaW50QXRMZW5ndGgobSl7aWYodGhpcy5tZXNoKXtjb25zdCBPPXRoaXMubWVzaC5nZXRQb2ludEF0TGVuZ3RoKG0pO2lmKE8pcmV0dXJuW08ueCxPLnldfXJldHVyblswLDBdfW9uUHJvcGVydHlDaGFuZ2UobSxPLG8pe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UobSxPLG8pLChtPT09ImQifHxtPT09Im5vcm1hbGl6ZSIpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t5XSYmKG09PT0iZmlsbENvbG9yInx8bT09PSJmaWxsUnVsZSIpKXtjb25zdHtmaWxsQ29sb3I6aCxmaWxsUnVsZTpjfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHMuc2V0RmlsbENvbG9yKSh0aGlzW3ldLHtjb2xvcjpoLHJ1bGU6Y30pfWlmKHRoaXNbeV0mJihtPT09InN0cm9rZUNvbG9yInx8bT09PSJsaW5lV2lkdGgifHxtPT09ImxpbmVDYXAifHxtPT09ImxpbmVKb2luInx8bT09PSJsaW5lRGFzaCJ8fG09PT0ibGluZURhc2hPZmZzZXQifHxtPT09InJvdW5kU2VnbWVudHMiKSl7Y29uc3R7c3Ryb2tlQ29sb3I6aCxsaW5lV2lkdGg6Y309dGhpcy5hdHRyaWJ1dGVzO2lmKGgmJmM+MCl7Y29uc3R7bGluZUNhcDpnLGxpbmVKb2luOmIsbGluZURhc2g6RSxsaW5lRGFzaE9mZnNldDpBLG1pdGVyTGltaXQ6TCxyb3VuZFNlZ21lbnRzOk19PXRoaXMuYXR0cmlidXRlcztPYmplY3Qocy5zZXRTdHJva2VDb2xvcikodGhpc1t5XSx7Y29sb3I6aCxsaW5lQ2FwOmcsbGluZUpvaW46YixsaW5lV2lkdGg6YyxsaW5lRGFzaDpFLGxpbmVEYXNoT2Zmc2V0OkEsbWl0ZXJMaW1pdDpMLHJvdW5kU2VnbWVudHM6TX0pfX10aGlzW3ldJiZtPT09ImNsaXBQYXRoIiYmdGhpc1t5XS5zZXRDbGlwUGF0aChPKSxtPT09InRleHR1cmUiJiZPYmplY3QoZi5hcHBseVRleHR1cmUpKHRoaXMsTyl9dXBkYXRlQ29udG91cnMoKXt0aGlzLnBhdGg9bmV3IHIuRmlndXJlMkQsdGhpcy5wYXRoLmFkZFBhdGgodGhpcy5hdHRyaWJ1dGVzLmQpLHRoaXMuYXR0cmlidXRlcy5ub3JtYWxpemUmJnRoaXMucGF0aC5ub3JtYWxpemUoLi4udGhpcy5wYXRoLmJvdW5kaW5nQ2VudGVyKX19cChQLCJBdHRyIixsLmRlZmF1bHQpLHYuZGVmYXVsdC5yZWdpc3Rlck5vZGUoUCwicGF0aCIpfSxmdW5jdGlvbih1LGUsdCl7KGZ1bmN0aW9uKHIsbil7dS5leHBvcnRzPW4oKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIEkoRCxSKXt2YXIgQz1bXSxCPSEwLHo9ITEsSz12b2lkIDA7dHJ5e2Zvcih2YXIgUT1EW1N5bWJvbC5pdGVyYXRvcl0oKSxfOyEoQj0oXz1RLm5leHQoKSkuZG9uZSkmJihDLnB1c2goXy52YWx1ZSksIShSJiZDLmxlbmd0aD09PVIpKTtCPSEwKTt9Y2F0Y2goRil7ej0hMCxLPUZ9ZmluYWxseXt0cnl7IUImJlEucmV0dXJuJiZRLnJldHVybigpfWZpbmFsbHl7aWYoeil0aHJvdyBLfX1yZXR1cm4gQ31yZXR1cm4gZnVuY3Rpb24oRCxSKXtpZihBcnJheS5pc0FycmF5KEQpKXJldHVybiBEO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoRCkpcmV0dXJuIEkoRCxSKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpLG49TWF0aC5QSSoyLGk9ZnVuY3Rpb24oRCxSLEMsQix6LEssUSl7dmFyIF89RC54LEY9RC55O18qPVIsRio9Qzt2YXIgRz1CKl8teipGLFg9eipfK0IqRjtyZXR1cm57eDpHK0sseTpYK1F9fSxhPWZ1bmN0aW9uKEQsUil7dmFyIEM9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKFIvNCksQj1NYXRoLmNvcyhEKSx6PU1hdGguc2luKEQpLEs9TWF0aC5jb3MoRCtSKSxRPU1hdGguc2luKEQrUik7cmV0dXJuW3t4OkIteipDLHk6eitCKkN9LHt4OksrUSpDLHk6US1LKkN9LHt4OksseTpRfV19LGw9ZnVuY3Rpb24oRCxSLEMsQil7dmFyIHo9RCpCLVIqQzwwPy0xOjEsSz1NYXRoLnNxcnQoRCpEK1IqUiksUT1NYXRoLnNxcnQoRCpEK1IqUiksXz1EKkMrUipCLEY9Xy8oSypRKTtyZXR1cm4gRj4xJiYoRj0xKSxGPC0xJiYoRj0tMSkseipNYXRoLmFjb3MoRil9LHM9ZnVuY3Rpb24oRCxSLEMsQix6LEssUSxfLEYsRyxYLFope3ZhciB0dD1NYXRoLnBvdyh6LDIpLG50PU1hdGgucG93KEssMikscT1NYXRoLnBvdyhYLDIpLGh0PU1hdGgucG93KFosMiksdXQ9dHQqbnQtdHQqaHQtbnQqcTt1dDwwJiYodXQ9MCksdXQvPXR0Kmh0K250KnEsdXQ9TWF0aC5zcXJ0KHV0KSooUT09PV8/LTE6MSk7dmFyIGo9dXQqei9LKlosVz11dCotSy96KlgsVj1HKmotRipXKyhEK0MpLzIsSj1GKmorRypXKyhSK0IpLzIsTj0oWC1qKS96LCQ9KFotVykvSyxTPSgtWC1qKS96LFQ9KC1aLVcpL0ssdz1sKDEsMCxOLCQpLFU9bChOLCQsUyxUKTtyZXR1cm4gXz09PTAmJlU+MCYmKFUtPW4pLF89PT0xJiZVPDAmJihVKz1uKSxbVixKLHcsVV19LGY9ZnVuY3Rpb24oRCl7dmFyIFI9RC5weCxDPUQucHksQj1ELmN4LHo9RC5jeSxLPUQucngsUT1ELnJ5LF89RC54QXhpc1JvdGF0aW9uLEY9Xz09PXZvaWQgMD8wOl8sRz1ELmxhcmdlQXJjRmxhZyxYPUc9PT12b2lkIDA/MDpHLFo9RC5zd2VlcEZsYWcsdHQ9Wj09PXZvaWQgMD8wOlosbnQ9W107aWYoSz09PTB8fFE9PT0wKXJldHVybltdO3ZhciBxPU1hdGguc2luKEYqbi8zNjApLGh0PU1hdGguY29zKEYqbi8zNjApLHV0PWh0KihSLUIpLzIrcSooQy16KS8yLGo9LXEqKFItQikvMitodCooQy16KS8yO2lmKHV0PT09MCYmaj09PTApcmV0dXJuW107Sz1NYXRoLmFicyhLKSxRPU1hdGguYWJzKFEpO3ZhciBXPU1hdGgucG93KHV0LDIpL01hdGgucG93KEssMikrTWF0aC5wb3coaiwyKS9NYXRoLnBvdyhRLDIpO1c+MSYmKEsqPU1hdGguc3FydChXKSxRKj1NYXRoLnNxcnQoVykpO3ZhciBWPXMoUixDLEIseixLLFEsWCx0dCxxLGh0LHV0LGopLEo9cihWLDQpLE49SlswXSwkPUpbMV0sUz1KWzJdLFQ9SlszXSx3PU1hdGgubWF4KE1hdGguY2VpbChNYXRoLmFicyhUKS8obi80KSksMSk7VC89dztmb3IodmFyIFU9MDtVPHc7VSsrKW50LnB1c2goYShTLFQpKSxTKz1UO3JldHVybiBudC5tYXAoZnVuY3Rpb24oSCl7dmFyIFk9aShIWzBdLEssUSxodCxxLE4sJCksaz1ZLngscnQ9WS55LGl0PWkoSFsxXSxLLFEsaHQscSxOLCQpLGx0PWl0LngsZnQ9aXQueSxvdD1pKEhbMl0sSyxRLGh0LHEsTiwkKSxzdD1vdC54LGN0PW90Lnk7cmV0dXJue3gxOmsseTE6cnQseDI6bHQseTI6ZnQseDpzdCx5OmN0fX0pfSx2PXthOjcsYzo2LGg6MSxsOjIsbToyLHE6NCxzOjQsdDoyLHY6MSx6OjB9LGQ9LyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9pZztmdW5jdGlvbiBwKEkpe3ZhciBEPVtdO3JldHVybiBJLnJlcGxhY2UoZCxmdW5jdGlvbihSLEMsQil7dmFyIHo9Qy50b0xvd2VyQ2FzZSgpO2ZvcihCPVAoQiksej09Im0iJiZCLmxlbmd0aD4yJiYoRC5wdXNoKFtDXS5jb25jYXQoQi5zcGxpY2UoMCwyKSkpLHo9ImwiLEM9Qz09Im0iPyJsIjoiTCIpOzspe2lmKEIubGVuZ3RoPT12W3pdKXJldHVybiBCLnVuc2hpZnQoQyksRC5wdXNoKEIpO2lmKEIubGVuZ3RoPHZbel0pdGhyb3cgbmV3IEVycm9yKCJtYWxmb3JtZWQgcGF0aCBkYXRhIik7RC5wdXNoKFtDXS5jb25jYXQoQi5zcGxpY2UoMCx2W3pdKSkpfX0pLER9dmFyIHk9Ly0/WzAtOV0qXC4/WzAtOV0rKD86ZVstK10/XGQrKT8vaWc7ZnVuY3Rpb24gUChJKXt2YXIgRD1JLm1hdGNoKHkpO3JldHVybiBEP0QubWFwKE51bWJlcik6W119ZnVuY3Rpb24geChJKXt2YXIgRD1JWzBdWzBdLFI9SVswXVsxXSxDPUQsQj1SO3JldHVybiBJLmZvckVhY2goZnVuY3Rpb24oeil7dmFyIEs9elswXSxRPXpbMl0sXz16WzRdLEY9els2XSxHPXpbMV0sWD16WzNdLFo9els1XSx0dD16WzddO0Q9TWF0aC5taW4oRCxLLFEsXyxGKSxSPU1hdGgubWluKFIsRyxYLFosdHQpLEM9TWF0aC5tYXgoQyxLLFEsXyxGKSxCPU1hdGgubWF4KEIsRyxYLFosdHQpfSksW0QsUixDLEJdfWZ1bmN0aW9uIG0oSSxEKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KElbMF0tRFswXSwyKStNYXRoLnBvdyhJWzFdLURbMV0sMikpK01hdGguc3FydChNYXRoLnBvdyhJWzJdLURbMl0sMikrTWF0aC5wb3coSVszXS1EWzNdLDIpKX1mdW5jdGlvbiBPKEksRCl7dmFyIFI9SVswXSxDPUlbMl0sQj1JWzRdLHo9SVs2XSxLPUlbMV0sUT1JWzNdLF89SVs1XSxGPUlbN10sRz1EWzBdLFg9RFsyXSxaPURbNF0sdHQ9RFs2XSxudD1EWzFdLHE9RFszXSxodD1EWzVdLHV0PURbN107cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhHLVIsMikrTWF0aC5wb3cobnQtSywyKSkrTWF0aC5zcXJ0KE1hdGgucG93KFgtQywyKStNYXRoLnBvdyhxLVEsMikpK01hdGguc3FydChNYXRoLnBvdyhaLUIsMikrTWF0aC5wb3coaHQtXywyKSkrTWF0aC5zcXJ0KE1hdGgucG93KHR0LXosMikrTWF0aC5wb3codXQtRiwyKSl9ZnVuY3Rpb24gbyhJLEQpe3ZhciBSPWMoSS5sZW5ndGgpLEM9W107Ui5mb3JFYWNoKGZ1bmN0aW9uKHope3ZhciBLPTAsUT0wO3ouZm9yRWFjaChmdW5jdGlvbihfKXtLKz1PKElbX10sRFtRKytdKX0pLEMucHVzaCh7aW5kZXg6eixkaXN0YW5jZTpLfSl9KSxDLnNvcnQoZnVuY3Rpb24oeixLKXtyZXR1cm4gei5kaXN0YW5jZS1LLmRpc3RhbmNlfSk7dmFyIEI9W107cmV0dXJuIENbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbih6KXtCLnB1c2goSVt6XSl9KSxCfWZ1bmN0aW9uIGgoSSxEKXt2YXIgUj1nKEkubGVuZ3RoKSxDPVtdO1IuZm9yRWFjaChmdW5jdGlvbih6KXt2YXIgSz0wO3ouZm9yRWFjaChmdW5jdGlvbihRKXtLKz1tKHgoSVtRXSkseChEW1FdKSl9KSxDLnB1c2goe2luZGV4OnosZGlzdGFuY2U6S30pfSksQy5zb3J0KGZ1bmN0aW9uKHosSyl7cmV0dXJuIHouZGlzdGFuY2UtSy5kaXN0YW5jZX0pO3ZhciBCPVtdO3JldHVybiBDWzBdLmluZGV4LmZvckVhY2goZnVuY3Rpb24oeil7Qi5wdXNoKElbel0pfSksQn1mdW5jdGlvbiBjKEkpe2Zvcih2YXIgRD1bXSxSPTA7UjxJO1IrKyl7Zm9yKHZhciBDPVtdLEI9MDtCPEk7QisrKXt2YXIgej1CK1I7ej5JLTEmJih6LT1JKSxDW3pdPUJ9RC5wdXNoKEMpfXJldHVybiBEfWZ1bmN0aW9uIGcoSSl7Zm9yKHZhciBEPVtdLFI9MDtSPEk7UisrKUQucHVzaChSKTtyZXR1cm4gYihEKX1mdW5jdGlvbiBiKEkpe3ZhciBEPVtdLFI9W107ZnVuY3Rpb24gQyhCKXt2YXIgeixLO2Zvcih6PTA7ejxCLmxlbmd0aDt6KyspSz1CLnNwbGljZSh6LDEpWzBdLFIucHVzaChLKSxCLmxlbmd0aD09MCYmRC5wdXNoKFIuc2xpY2UoKSksQyhCKSxCLnNwbGljZSh6LDAsSyksUi5wb3AoKTtyZXR1cm4gRH1yZXR1cm4gQyhJKX12YXIgRT17fTtFLnBhcnNlcj1wLEUubGVycEN1cnZlPWZ1bmN0aW9uKEksRCxSKXtyZXR1cm4gRS5sZXJwUG9pbnRzKElbMF0sSVsxXSxEWzBdLERbMV0sUikuY29uY2F0KEUubGVycFBvaW50cyhJWzJdLElbM10sRFsyXSxEWzNdLFIpKS5jb25jYXQoRS5sZXJwUG9pbnRzKElbNF0sSVs1XSxEWzRdLERbNV0sUikpLmNvbmNhdChFLmxlcnBQb2ludHMoSVs2XSxJWzddLERbNl0sRFs3XSxSKSl9LEUubGVycFBvaW50cz1mdW5jdGlvbihJLEQsUixDLEIpe3JldHVybltJKyhSLUkpKkIsRCsoQy1EKSpCXX0sRS5xMmI9ZnVuY3Rpb24oSSxELFIsQyxCLHope3JldHVybltJLEQsKEkrMipSKS8zLChEKzIqQykvMywoQisyKlIpLzMsKHorMipDKS8zLEIsel19LEUucGF0aDJzaGFwZXM9ZnVuY3Rpb24oSSl7Zm9yKHZhciBEPUUucGFyc2VyKEkpLFI9MCxDPTAsQj0wLHo9RC5sZW5ndGgsSz1bXSxRPW51bGwsXz12b2lkIDAsRj12b2lkIDAsRz12b2lkIDAsWD12b2lkIDAsWj12b2lkIDAsdHQ9dm9pZCAwLG50PXZvaWQgMDtCPHo7QisrKXt2YXIgcT1EW0JdLGh0PXFbMF0sdXQ9RFtCLTFdO3N3aXRjaChodCl7Y2FzZSJtIjpaPUsubGVuZ3RoLEtbWl09W10sUT1LW1pdLFI9UitxWzFdLEM9QytxWzJdO2JyZWFrO2Nhc2UiTSI6Wj1LLmxlbmd0aCxLW1pdPVtdLFE9S1taXSxSPXFbMV0sQz1xWzJdO2JyZWFrO2Nhc2UibCI6US5wdXNoKFtSLEMsUixDLFIsQyxSK3FbMV0sQytxWzJdXSksUis9cVsxXSxDKz1xWzJdO2JyZWFrO2Nhc2UiTCI6US5wdXNoKFtSLEMscVsxXSxxWzJdLHFbMV0scVsyXSxxWzFdLHFbMl1dKSxSPXFbMV0sQz1xWzJdO2JyZWFrO2Nhc2UiaCI6US5wdXNoKFtSLEMsUixDLFIsQyxSK3FbMV0sQ10pLFIrPXFbMV07YnJlYWs7Y2FzZSJIIjpRLnB1c2goW1IsQyxxWzFdLEMscVsxXSxDLHFbMV0sQ10pLFI9cVsxXTticmVhaztjYXNlInYiOlEucHVzaChbUixDLFIsQyxSLEMsUixDK3FbMV1dKSxDKz1xWzFdO2JyZWFrO2Nhc2UiViI6US5wdXNoKFtSLEMsUixxWzFdLFIscVsxXSxSLHFbMV1dKSxDPXFbMV07YnJlYWs7Y2FzZSJDIjpRLnB1c2goW1IsQyxxWzFdLHFbMl0scVszXSxxWzRdLHFbNV0scVs2XV0pLFI9cVs1XSxDPXFbNl07YnJlYWs7Y2FzZSJTIjp1dFswXT09PSJDInx8dXRbMF09PT0iYyI/US5wdXNoKFtSLEMsUit1dFs1XS11dFszXSxDK3V0WzZdLXV0WzRdLHFbMV0scVsyXSxxWzNdLHFbNF1dKToodXRbMF09PT0iUyJ8fHV0WzBdPT09InMiKSYmUS5wdXNoKFtSLEMsUit1dFszXS11dFsxXSxDK3V0WzRdLXV0WzJdLHFbMV0scVsyXSxxWzNdLHFbNF1dKSxSPXFbM10sQz1xWzRdO2JyZWFrO2Nhc2UiYyI6US5wdXNoKFtSLEMsUitxWzFdLEMrcVsyXSxSK3FbM10sQytxWzRdLFIrcVs1XSxDK3FbNl1dKSxSPVIrcVs1XSxDPUMrcVs2XTticmVhaztjYXNlInMiOnV0WzBdPT09IkMifHx1dFswXT09PSJjIj9RLnB1c2goW1IsQyxSK3V0WzVdLXV0WzNdLEMrdXRbNl0tdXRbNF0sUitxWzFdLEMrcVsyXSxSK3FbM10sQytxWzRdXSk6KHV0WzBdPT09IlMifHx1dFswXT09PSJzIikmJlEucHVzaChbUixDLFIrdXRbM10tdXRbMV0sQyt1dFs0XS11dFsyXSxSK3FbMV0sQytxWzJdLFIrcVszXSxDK3FbNF1dKSxSPVIrcVszXSxDPUMrcVs0XTticmVhaztjYXNlImEiOnR0PWYoe3J4OnFbMV0scnk6cVsyXSxweDpSLHB5OkMseEF4aXNSb3RhdGlvbjpxWzNdLGxhcmdlQXJjRmxhZzpxWzRdLHN3ZWVwRmxhZzpxWzVdLGN4OlIrcVs2XSxjeTpDK3FbN119KSxudD10dFt0dC5sZW5ndGgtMV0sdHQuZm9yRWFjaChmdW5jdGlvbihqLFcpe1c9PT0wP1EucHVzaChbUixDLGoueDEsai55MSxqLngyLGoueTIsai54LGoueV0pOlEucHVzaChbdHRbVy0xXS54LHR0W1ctMV0ueSxqLngxLGoueTEsai54MixqLnkyLGoueCxqLnldKX0pLFI9bnQueCxDPW50Lnk7YnJlYWs7Y2FzZSJBIjp0dD1mKHtyeDpxWzFdLHJ5OnFbMl0scHg6UixweTpDLHhBeGlzUm90YXRpb246cVszXSxsYXJnZUFyY0ZsYWc6cVs0XSxzd2VlcEZsYWc6cVs1XSxjeDpxWzZdLGN5OnFbN119KSxudD10dFt0dC5sZW5ndGgtMV0sdHQuZm9yRWFjaChmdW5jdGlvbihqLFcpe1c9PT0wP1EucHVzaChbUixDLGoueDEsai55MSxqLngyLGoueTIsai54LGoueV0pOlEucHVzaChbdHRbVy0xXS54LHR0W1ctMV0ueSxqLngxLGoueTEsai54MixqLnkyLGoueCxqLnldKX0pLFI9bnQueCxDPW50Lnk7YnJlYWs7Y2FzZSJRIjpRLnB1c2goRS5xMmIoUixDLHFbMV0scVsyXSxxWzNdLHFbNF0pKSxSPXFbM10sQz1xWzRdO2JyZWFrO2Nhc2UicSI6US5wdXNoKEUucTJiKFIsQyxSK3FbMV0sQytxWzJdLHFbM10rUixxWzRdK0MpKSxSKz1xWzNdLEMrPXFbNF07YnJlYWs7Y2FzZSJUIjp1dFswXT09PSJRInx8dXRbMF09PT0icSI/KEc9Uit1dFszXS11dFsxXSxYPUMrdXRbNF0tdXRbMl0sUS5wdXNoKEUucTJiKFIsQyxHLFgscVsxXSxxWzJdKSkpOih1dFswXT09PSJUInx8dXRbMF09PT0idCIpJiYoUS5wdXNoKEUucTJiKFIsQyxSK1ItRyxDK0MtWCxxWzFdLHFbMl0pKSxHPVIrUi1HLFg9QytDLVgpLFI9cVsxXSxDPXFbMl07YnJlYWs7Y2FzZSJ0Ijp1dFswXT09PSJRInx8dXRbMF09PT0icSI/KEc9Uit1dFszXS11dFsxXSxYPUMrdXRbNF0tdXRbMl0sUS5wdXNoKEUucTJiKFIsQyxHLFgsUitxWzFdLEMrcVsyXSkpKToodXRbMF09PT0iVCJ8fHV0WzBdPT09InQiKSYmKFEucHVzaChFLnEyYihSLEMsUitSLUcsQytDLVgsUitxWzFdLEMrcVsyXSkpLEc9UitSLUcsWD1DK0MtWCksUis9cVsxXSxDKz1xWzJdO2JyZWFrO2Nhc2UiWiI6Xz1RWzBdWzBdLEY9UVswXVsxXSxRLnB1c2goW1IsQyxfLEYsXyxGLF8sRl0pO2JyZWFrO2Nhc2UieiI6Xz1RWzBdWzBdLEY9UVswXVsxXSxRLnB1c2goW1IsQyxfLEYsXyxGLF8sRl0pO2JyZWFrfX1yZXR1cm4gS30sRS5fdXBDdXJ2ZXM9ZnVuY3Rpb24oSSxEKXtmb3IodmFyIFI9MCxDPTAsQj1JLmxlbmd0aDtSPEQ7UisrKUkucHVzaChJW0NdLnNsaWNlKDApKSxDKyssQz5CLTEmJihDLT1CKX07ZnVuY3Rpb24gQShJLEQsUixDLEIseixLLFEsXyl7cmV0dXJue2xlZnQ6TChJLEQsUixDLEIseixLLFEsXykscmlnaHQ6TChLLFEsQix6LFIsQyxJLEQsMS1fLCEwKX19ZnVuY3Rpb24gTChJLEQsUixDLEIseixLLFEsXyxGKXt2YXIgRz0oUi1JKSpfK0ksWD0oQy1EKSpfK0QsWj0oQi1SKSpfK1IsdHQ9KHotQykqXytDLG50PShLLUIpKl8rQixxPShRLXopKl8reixodD0oWi1HKSpfK0csdXQ9KHR0LVgpKl8rWCxqPShudC1aKSpfK1osVz0ocS10dCkqXyt0dCxWPShqLWh0KSpfK2h0LEo9KFctdXQpKl8rdXQ7cmV0dXJuIEY/W1YsSixodCx1dCxHLFgsSSxEXTpbSSxELEcsWCxodCx1dCxWLEpdfUUuX3NwbGl0Q3VydmVzPWZ1bmN0aW9uKEksRCl7Zm9yKHZhciBSPTAsQz0wO1I8RDtSKyspe3ZhciBCPUlbQ10sej1BKEJbMF0sQlsxXSxCWzJdLEJbM10sQls0XSxCWzVdLEJbNl0sQls3XSwuNSk7SS5zcGxpY2UoQywxKSxJLnNwbGljZShDLDAsei5sZWZ0LHoucmlnaHQpLEMrPTIsQz49SS5sZW5ndGgtMSYmKEM9MCl9fTtmdW5jdGlvbiBNKEksRCl7Zm9yKHZhciBSPWZ1bmN0aW9uKHope3ZhciBLPUlbSS5sZW5ndGgtMV0sUT1bXTtLLmZvckVhY2goZnVuY3Rpb24oXyl7US5wdXNoKF8uc2xpY2UoMCkpfSksSS5wdXNoKFEpfSxDPTA7QzxEO0MrKylSKCl9cmV0dXJuIEUubGVycD1mdW5jdGlvbihJLEQsUil7cmV0dXJuIEUuX2xlcnAoRS5wYXRoMnNoYXBlcyhJKSxFLnBhdGgyc2hhcGVzKEQpLFIpfSxFLk1JTV9DVVJWRVNfQ09VTlQ9MTAwLEUuX3ByZXByb2Nlc3Npbmc9ZnVuY3Rpb24oSSxEKXt2YXIgUj1JLmxlbmd0aCxDPUQubGVuZ3RoLEI9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShJKSksej1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEQpKTtyZXR1cm4gUj5DP00oeixSLUMpOlI8QyYmTShCLEMtUiksQj1oKEIseiksQi5mb3JFYWNoKGZ1bmN0aW9uKEssUSl7dmFyIF89Sy5sZW5ndGgsRj16W1FdLmxlbmd0aDtfPkY/XzxFLk1JTV9DVVJWRVNfQ09VTlQ/KEUuX3NwbGl0Q3VydmVzKEssRS5NSU1fQ1VSVkVTX0NPVU5ULV8pLEUuX3NwbGl0Q3VydmVzKHpbUV0sRS5NSU1fQ1VSVkVTX0NPVU5ULUYpKTpFLl9zcGxpdEN1cnZlcyh6W1FdLF8tRik6XzxGJiYoRjxFLk1JTV9DVVJWRVNfQ09VTlQ/KEUuX3NwbGl0Q3VydmVzKEssRS5NSU1fQ1VSVkVTX0NPVU5ULV8pLEUuX3NwbGl0Q3VydmVzKHpbUV0sRS5NSU1fQ1VSVkVTX0NPVU5ULUYpKTpFLl9zcGxpdEN1cnZlcyhLLEYtXykpfSksQi5mb3JFYWNoKGZ1bmN0aW9uKEssUSl7QltRXT1vKEsseltRXSl9KSxbQix6XX0sRS5fbGVycD1mdW5jdGlvbihJLEQsUil7dmFyIEM9W107cmV0dXJuIEkuZm9yRWFjaChmdW5jdGlvbihCLHope3ZhciBLPVtdO0IuZm9yRWFjaChmdW5jdGlvbihRLF8pe0sucHVzaChFLmxlcnBDdXJ2ZShRLERbel1bX10sUikpfSksQy5wdXNoKEspfSksQ30sRS5hbmltYXRlPWZ1bmN0aW9uKEkpe3ZhciBEPUUucGF0aDJzaGFwZXMoSS5mcm9tKSxSPUUucGF0aDJzaGFwZXMoSS50byksQz1FLl9wcmVwcm9jZXNzaW5nKEQsUiksQj1uZXcgRGF0ZSx6PUkuZW5kfHxmdW5jdGlvbigpe30sSz1JLnByb2dyZXNzfHxmdW5jdGlvbigpe30sUT1JLmJlZ2lufHxmdW5jdGlvbigpe30sXz1JLmVhc2luZ3x8ZnVuY3Rpb24odHQpe3JldHVybiB0dH0sRj1udWxsLEc9bnVsbCxYPUkudGltZTtRKEQpO3ZhciBaPWZ1bmN0aW9uIHR0KCl7dmFyIG50PW5ldyBEYXRlLUI7aWYobnQ+PVgpe0c9UixLKEcsMSkseihHKSxjYW5jZWxBbmltYXRpb25GcmFtZShGKTtyZXR1cm59dmFyIHE9XyhudC9YKTtHPUUuX2xlcnAoQ1swXSxDWzFdLHEpLEsoRyxxKSxGPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0dCl9O1ooKX0sRX0pfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCg3MSksbj10KDIyMSksaT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxzPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZCl7c3VwZXIoZCksdGhpc1thXSh7ZDoiIixub3JtYWxpemU6ITEsZmlsbENvbG9yOnZvaWQgMCxmaWxsUnVsZToibm9uemVybyIsc3Ryb2tlQ29sb3I6dm9pZCAwLGxpbmVXaWR0aDoxLGxpbmVKb2luOiJtaXRlciIsbGluZUNhcDoiYnV0dCIscm91bmRTZWdtZW50czoyMCxsaW5lRGFzaDp2b2lkIDAsbGluZURhc2hPZmZzZXQ6MCxtaXRlckxpbWl0OjEwLHRleHR1cmU6dm9pZCAwLHRleHR1cmVSZWN0OnZvaWQgMCx0ZXh0dXJlUmVwZWF0OiExLHNvdXJjZVJlY3Q6dm9pZCAwLGNsaXBQYXRoOnZvaWQgMH0pfWdldCBkKCl7cmV0dXJuIHRoaXNbc10oImQiKX1zZXQgZChkKXt0aGlzW2xdKCJkIixkKX1nZXQgbm9ybWFsaXplKCl7cmV0dXJuIHRoaXNbc10oIm5vcm1hbGl6ZSIpfXNldCBub3JtYWxpemUoZCl7dGhpc1tsXSgibm9ybWFsaXplIiwhIWQpfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1tzXSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcihkKXt0aGlzW2xdKCJmaWxsQ29sb3IiLE9iamVjdChuLnBhcnNlQ29sb3IpKGQpKX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tzXSgiZmlsbFJ1bGUiKX1zZXQgZmlsbFJ1bGUoZCl7aWYoZCE9bnVsbCYmZCE9PSJub256ZXJvIiYmZCE9PSJldmVub2RkIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGZpbGwgcnVsZS4iKTt0aGlzW2xdKCJmaWxsUnVsZSIsZCl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbc10oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKGQpe3RoaXNbbF0oInN0cm9rZUNvbG9yIixPYmplY3Qobi5wYXJzZUNvbG9yKShkKSl9Z2V0IGxpbmVXaWR0aCgpe3JldHVybiB0aGlzW3NdKCJsaW5lV2lkdGgiKX1zZXQgbGluZVdpZHRoKGQpe3RoaXNbbF0oImxpbmVXaWR0aCIsT2JqZWN0KGkudG9OdW1iZXIpKGQpKX1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1tzXSgibGluZUpvaW4iKX1zZXQgbGluZUpvaW4oZCl7aWYoZCE9bnVsbCYmZCE9PSJtaXRlciImJmQhPT0iYmV2ZWwiJiZkIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVKb2luIHR5cGUuIik7dGhpc1tsXSgibGluZUpvaW4iLGQpfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbc10oImxpbmVDYXAiKX1zZXQgbGluZUNhcChkKXtpZihkIT1udWxsJiZkIT09ImJ1dHQiJiZkIT09InNxdWFyZSImJmQhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUNhcCB0eXBlLiIpO3RoaXNbbF0oImxpbmVDYXAiLGQpfWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW3NdKCJsaW5lRGFzaCIpfXNldCBsaW5lRGFzaChkKXtkPU9iamVjdChpLnRvQXJyYXkpKGQsITApLGQhPW51bGwmJiFBcnJheS5pc0FycmF5KGQpJiYoZD1bZF0pLHRoaXNbbF0oImxpbmVEYXNoIixkP2QubWFwKGkudG9OdW1iZXIpOm51bGwpfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW3NdKCJsaW5lRGFzaE9mZnNldCIpfXNldCBsaW5lRGFzaE9mZnNldChkKXt0aGlzW2xdKCJsaW5lRGFzaE9mZnNldCIsT2JqZWN0KGkudG9OdW1iZXIpKGQpKX1nZXQgbWl0ZXJMaW1pdCgpe3JldHVybiB0aGlzW3NdKCJtaXRlckxpbWl0Iil9c2V0IG1pdGVyTGltaXQoZCl7dGhpc1tsXSgibWl0ZXJMaW1pdCIsT2JqZWN0KGkudG9OdW1iZXIpKGQpKX1nZXQgcm91bmRTZWdtZW50cygpe3JldHVybiB0aGlzW3NdKCJyb3VuZFNlZ21lbnRzIil9c2V0IHJvdW5kU2VnbWVudHMoZCl7dGhpc1tsXSgicm91bmRTZWdtZW50cyIsZCl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tzXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGQpe3RoaXNbbF0oInRleHR1cmUiLGQpfWdldCB0ZXh0dXJlUmVjdCgpe3JldHVybiB0aGlzW3NdKCJ0ZXh0dXJlUmVjdCIpfXNldCB0ZXh0dXJlUmVjdChkKXt0aGlzW2xdKCJ0ZXh0dXJlUmVjdCIsZCl9Z2V0IHNvdXJjZVJlY3QoKXtyZXR1cm4gdGhpc1tzXSgic291cmNlUmVjdCIpfXNldCBzb3VyY2VSZWN0KGQpe3RoaXNbbF0oInNvdXJjZVJlY3QiLGQpfWdldCB0ZXh0dXJlUmVwZWF0KCl7cmV0dXJuIHRoaXNbc10oInRleHR1cmVSZXBlYXQiKX1zZXQgdGV4dHVyZVJlcGVhdChkKXt0aGlzW2xdKCJ0ZXh0dXJlUmVwZWF0IiwhIWQpfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW3NdKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aChkKXt0aGlzW2xdKCJjbGlwUGF0aCIsZCl9fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoMjI2KSxuPXQoMjEzKSxpPXQoMjMwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShzLGYsdil7cmV0dXJuIGYgaW4gcz9PYmplY3QuZGVmaW5lUHJvcGVydHkocyxmLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6c1tmXT12LHN9Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7d2lkdGg6ZixoZWlnaHQ6dn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmPjAmJnY+MCYmc3VwZXIuaXNWaXNpYmxlfX1hKGwsIkF0dHIiLGkuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShsLCJyZWN0Iil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDIyOCksbj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgaT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gZihkKXtjb25zdHt3aWR0aDpwLGhlaWdodDp5fT1kO3JldHVybmBNMCAwTCR7cH0gMEwke3B9ICR7eX1MMCAke3l9WmB9Y2xhc3MgdiBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihwKXtzdXBlcihwKSx0aGlzW2ldKHt3aWR0aDowLGhlaWdodDowfSksdGhpc1tzXSgic2l6ZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbbF0oImQiKX1zZXQgZChwKXt9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbbF0oIndpZHRoIil9c2V0IHdpZHRoKHApe2lmKHA9T2JqZWN0KG4udG9OdW1iZXIpKHApLHRoaXNbYV0oIndpZHRoIixwKSl7Y29uc3QgeT1mKHRoaXMpO3RoaXNbYV0oImQiLHkpfX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbbF0oImhlaWdodCIpfXNldCBoZWlnaHQocCl7aWYocD1PYmplY3Qobi50b051bWJlcikocCksdGhpc1thXSgiaGVpZ2h0IixwKSl7Y29uc3QgeT1mKHRoaXMpO3RoaXNbYV0oImQiLHkpfX1nZXQgc2l6ZSgpe3JldHVyblt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XX1zZXQgc2l6ZShwKXtwPU9iamVjdChuLnRvQXJyYXkpKHApLEFycmF5LmlzQXJyYXkocCl8fChwPVtwLHBdKSx0aGlzLndpZHRoPXBbMF0sdGhpcy5oZWlnaHQ9cFsxXX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMzIpLG49dCgyMTMpLGk9dCgyMzUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKHMsZix2KXtyZXR1cm4gZiBpbiBzP09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLGYse3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpzW2ZdPXYsc31jbGFzcyBsIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczpmfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGZbMF0+MCYmZlsxXT4wJiZzdXBlci5pc1Zpc2libGV9fWEobCwiQXR0ciIsaS5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGwsInRyaWFuZ2xlIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDIyNiksbj10KDIxMyksaT10KDIzMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEocyxmLHYpe3JldHVybiBmIGluIHM/T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsZix7dmFsdWU6dixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnNbZl09dixzfWNsYXNzIGwgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3BvaW50czpmfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGYubGVuZ3RoPjAmJnN1cGVyLmlzVmlzaWJsZX19YShsLCJBdHRyIixpLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUobCwicG9seWxpbmUiKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciByPXQoMjI4KSxuPXQoNzIpLGk9dCgyMzQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB2KHApe2NvbnN0e3BvaW50czp5LHNtb290aDpQLHNtb290aFJhbmdlOngsY2xvc2U6bX09cCxPPVtdO2ZvcihsZXQgaD0wO2g8eS5sZW5ndGg7aCs9MilPLnB1c2goW3lbaF0seVtoKzFdXSk7bGV0IG89IiI7cmV0dXJuIFA/bz1PYmplY3QoaS5tYWtlU21vb3RoQ3VydmVMaW5lKShPLHgpOk8ubGVuZ3RoJiYobz1gTSR7Ty5tYXAoaD0+aC5qb2luKCIgIikpLmpvaW4oIkwiKX1gKSxvJiZtJiYobys9IloiKSxvfWNsYXNzIGQgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1thXSh7cG9pbnRzOltdLHNtb290aDohMSxzbW9vdGhSYW5nZTpbMF0sY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbZl0oImNsb3NlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1tzXSgiZCIpfXNldCBkKHkpe31nZXQgY2xvc2UoKXtyZXR1cm4gdGhpcy5jbG9zZVR5cGUhPT0ibm9uZSJ9c2V0IGNsb3NlKHkpe3k9eT8ibm9ybWFsIjoibm9uZSIsdGhpcy5jbG9zZVR5cGU9eX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbc10oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUoeSl7aWYoeSE9bnVsbCYmeSE9PSJub25lIiYmeSE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1tsXSgiY2xvc2VUeXBlIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgc21vb3RoKCl7cmV0dXJuIHRoaXNbc10oInNtb290aCIpfXNldCBzbW9vdGgoeSl7aWYodGhpc1tsXSgic21vb3RoIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgc21vb3RoUmFuZ2UoKXtyZXR1cm4gdGhpc1tzXSgic21vb3RoUmFuZ2UiKX1zZXQgc21vb3RoUmFuZ2UoeSl7aWYoeSYmIUFycmF5LmlzQXJyYXkoeSkmJih5PVt5XSksdGhpc1tsXSgic21vb3RoUmFuZ2UiLHkpJiZ0aGlzLnNtb290aCl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgcG9pbnRzKCl7cmV0dXJuIHRoaXNbc10oInBvaW50cyIpfXNldCBwb2ludHMoeSl7aWYoeT1PYmplY3Qobi50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpJiYoeT15LnJlZHVjZSgoUCx4KT0+QXJyYXkuaXNBcnJheSh4KT9bLi4uUCwuLi54Lm1hcChtPT5PYmplY3Qobi50b051bWJlcikobSkpXTpbLi4uUCxPYmplY3Qobi50b051bWJlcikoeCldLFtdKSksdGhpc1tsXSgicG9pbnRzIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJtYWtlU21vb3RoQ3VydmVMaW5lIixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIobixpPVswXSl7ZnVuY3Rpb24gYShmLHY9LjE2OCxkPS4xNjgpe2xldCBwLHksUCx4O2lmKChuW2ZdLng9PT1uW2YrMV0ueHx8bltmXS55PT09bltmKzFdLnkpJiYodj0wLGQ9MCksZjwxPyhwPW5bMF0ueCsoblsxXS54LW5bMF0ueCkqdix5PW5bMF0ueSsoblsxXS55LW5bMF0ueSkqdik6KHA9bltmXS54KyhuW2YrMV0ueC1uW2YtMV0ueCkqdix5PW5bZl0ueSsobltmKzFdLnktbltmLTFdLnkpKnYpLGY+bi5sZW5ndGgtMyl7Y29uc3QgbT1uLmxlbmd0aC0xO1A9blttXS54LShuW21dLngtblttLTFdLngpKmQseD1uW21dLnktKG5bbV0ueS1uW20tMV0ueSkqZH1lbHNlIFA9bltmKzFdLngtKG5bZisyXS54LW5bZl0ueCkqZCx4PW5bZisxXS55LShuW2YrMl0ueS1uW2ZdLnkpKmQ7cmV0dXJuW3t4OnAseX0se3g6UCx5Onh9XX1uPW4ubWFwKChbZix2XSk9Pih7eDpmLHk6dn0pKTtsZXQgbD0iIixzPTA7cmV0dXJuIG4uZm9yRWFjaCgoZix2KT0+e2lmKHY9PT0wKWwrPWBNJHtmLnh9ICR7Zi55fWA7ZWxzZXtmb3IoO3Y+aVtzXTspcysrO2lmKHMlMil7Y29uc3RbZCxwXT1hKHYtMSk7bCs9YEMke1tkLngsZC55LHAueCxwLnksZi54LGYueV0uam9pbigiICIpfWB9ZWxzZSBsKz1gTCR7Zi54fSAke2YueX1gfX0pLGx9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBzKHYpe2NvbnN0W2QscF09di5zaWRlcztsZXQgeT12LmFuZ2xlJTM2MDtyZXR1cm4geTwwJiYoeSs9MzYwKSx5PU1hdGguUEkqeS8xODAsWzAsMCxkLDAscCpNYXRoLmNvcyh5KSxwKk1hdGguc2luKHkpXX1jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGQpe3N1cGVyKGQpLHRoaXNbaV0oe3NpZGVzOlswLDBdLGFuZ2xlOjYwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZCl7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW2xdKCJzaWRlcyIpfXNldCBzaWRlcyhkKXtpZihkPU9iamVjdChuLnRvQXJyYXkpKGQsITApLGQhPW51bGwmJiFBcnJheS5pc0FycmF5KGQpJiYoZD1bZCxkXSksdGhpc1thXSgic2lkZXMiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW2xdKCJhbmdsZSIpfXNldCBhbmdsZShkKXtpZihkPU9iamVjdChuLnRvTnVtYmVyKShkKSx0aGlzW2FdKCJhbmdsZSIsZCkpe2NvbnN0IHA9cyh0aGlzKTtzdXBlci5wb2ludHM9cH19fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxpPXQoMjM3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShzLGYsdil7cmV0dXJuIGYgaW4gcz9PYmplY3QuZGVmaW5lUHJvcGVydHkocyxmLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6c1tmXT12LHN9Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6Zn09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBmWzBdPjAmJmZbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX1hKGwsIkF0dHIiLGkuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShsLCJwYXJhbGxlbCIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBzKHYpe2NvbnN0W2QscF09di5zaWRlcztsZXQgeT12LmFuZ2xlJTM2MDt5PDAmJih5Kz0zNjApLHk9TWF0aC5QSSp5LzE4MDtjb25zdCBQPXAqTWF0aC5jb3MoeSkseD1wKk1hdGguc2luKHkpO3JldHVyblswLDAsZCwwLFArZCx4LFAseF19Y2xhc3MgZiBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihkKXtzdXBlcihkKSx0aGlzW2ldKHtzaWRlczpbMCwwXSxhbmdsZTo5MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGQpe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1tsXSgic2lkZXMiKX1zZXQgc2lkZXMoZCl7aWYoZD1PYmplY3Qobi50b0FycmF5KShkLCEwKSxkIT1udWxsJiYhQXJyYXkuaXNBcnJheShkKSYmKGQ9W2QsZF0pLHRoaXNbYV0oInNpZGVzIixkKSl7Y29uc3QgcD1zKHRoaXMpO3N1cGVyLnBvaW50cz1wfX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1tsXSgiYW5nbGUiKX1zZXQgYW5nbGUoZCl7aWYoZD1PYmplY3Qobi50b051bWJlcikoZCksdGhpc1thXSgiYW5nbGUiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDIzMiksbj10KDIxMyksaT10KDIzOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEocyxmLHYpe3JldHVybiBmIGluIHM/T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsZix7dmFsdWU6dixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnNbZl09dixzfWNsYXNzIGwgZXh0ZW5kcyByLmRlZmF1bHR7fWEobCwiQXR0ciIsaS5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGwsInJlZ3VsYXIiKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMjMzKSxuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBpPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gcyh2KXtjb25zdHtlZGdlczpkLHJhZGl1czpwLG9mZnNldEFuZ2xlOnl9PXYsUD1NYXRoLlBJKnkvMTgwLS41Kk1hdGguUEk7aWYoZDwzfHxwPD0wKXJldHVybltdO2NvbnN0IHg9W107Zm9yKGxldCBtPTA7bTxkO20rKyl7Y29uc3QgTz1tKjIqTWF0aC5QSS9kK1Asbz1wKk1hdGguY29zKE8pLGg9cCpNYXRoLnNpbihPKTt4LnB1c2gobyxoKX1yZXR1cm4geH1jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGQpe3N1cGVyKGQpLHRoaXNbaV0oe2VkZ2VzOjMscmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGQpe31nZXQgZWRnZXMoKXtyZXR1cm4gdGhpc1tsXSgiZWRnZXMiKX1zZXQgZWRnZXMoZCl7aWYoZD1PYmplY3Qobi50b051bWJlcikoZCksdGhpc1thXSgiZWRnZXMiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fWdldCByYWRpdXMoKXtyZXR1cm4gdGhpc1tsXSgicmFkaXVzIil9c2V0IHJhZGl1cyhkKXtpZihkPU9iamVjdChuLnRvTnVtYmVyKShkKSx0aGlzW2FdKCJyYWRpdXMiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW2xdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShkKXtpZihkPU9iamVjdChuLnRvTnVtYmVyKShkKSx0aGlzW2FdKCJvZmZzZXRBbmdsZSIsZCkpe2NvbnN0IHA9cyh0aGlzKTtzdXBlci5wb2ludHM9cH19fX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxpPXQoMjQxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShzLGYsdil7cmV0dXJuIGYgaW4gcz9PYmplY3QuZGVmaW5lUHJvcGVydHkocyxmLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6c1tmXT12LHN9Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHt9YShsLCJBdHRyIixpLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUobCwic3RhciIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGE9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBzKHYpe2NvbnN0e2FuZ2xlczpkLGlubmVyUmFkaXVzOnAsb3V0ZXJSYWRpdXM6eSxvZmZzZXRBbmdsZTpQfT12LHg9TWF0aC5QSSpQLzE4MC0uNSpNYXRoLlBJO2lmKGQ8M3x8cDw9MHx8eTw9MClyZXR1cm5bXTtjb25zdCBtPVtdO2ZvcihsZXQgTz0wO088ZCoyO08rKyl7Y29uc3Qgbz1PKk1hdGguUEkvZCt4LGg9TyUyP3A6eSxjPWgqTWF0aC5jb3MobyksZz1oKk1hdGguc2luKG8pO20ucHVzaChjLGcpfXJldHVybiBtfWNsYXNzIGYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZCl7c3VwZXIoZCksdGhpc1tpXSh7YW5nbGVzOjUsaW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhkKXt9Z2V0IGFuZ2xlcygpe3JldHVybiB0aGlzW2xdKCJhbmdsZXMiKX1zZXQgYW5nbGVzKGQpe2lmKGQ9T2JqZWN0KG4udG9OdW1iZXIpKGQpLHRoaXNbYV0oImFuZ2xlcyIsZCkpe2NvbnN0IHA9cyh0aGlzKTtzdXBlci5wb2ludHM9cH19Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbbF0oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKGQpe2lmKGQ9T2JqZWN0KG4udG9OdW1iZXIpKGQpLHRoaXNbYV0oImlubmVyUmFkaXVzIixkKSl7Y29uc3QgcD1zKHRoaXMpO3N1cGVyLnBvaW50cz1wfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tsXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoZCl7aWYoZD1PYmplY3Qobi50b051bWJlcikoZCksdGhpc1thXSgib3V0ZXJSYWRpdXMiLGQpKXtjb25zdCBwPXModGhpcyk7c3VwZXIucG9pbnRzPXB9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKGQpe2Q9T2JqZWN0KG4udG9BcnJheSkoZCwhMCksQXJyYXkuaXNBcnJheShkKXx8KGQ9W2QsZF0pLHRoaXMuaW5uZXJSYWRpdXM9ZFswXSx0aGlzLm91dGVyUmFkaXVzPWRbMV19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbbF0oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGQpe2lmKGQ9T2JqZWN0KG4udG9OdW1iZXIpKGQpLHRoaXNbYV0oIm9mZnNldEFuZ2xlIixkKSl7Y29uc3QgcD1zKHRoaXMpO3N1cGVyLnBvaW50cz1wfX19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLGk9dCgyNDMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKHMsZix2KXtyZXR1cm4gZiBpbiBzP09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLGYse3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpzW2ZdPXYsc31jbGFzcyBsIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtyYWRpdXNYOmYscmFkaXVzWTp2LHN0YXJ0QW5nbGU6ZCxlbmRBbmdsZTpwfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGY+MCYmdj4wJiZkIT09cCYmc3VwZXIuaXNWaXNpYmxlfX1hKGwsIkF0dHIiLGkuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShsLCJlbGxpcHNlIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB2KHApe2NvbnN0e3JhZGl1c1g6eSxyYWRpdXNZOlAsc3RhcnRBbmdsZTp4LGVuZEFuZ2xlOm0sZGlyZWN0aW9uOk8sY2xvc2VUeXBlOm99PXAsaD1PPT09ImFuaXRjbG9ja3dpc2UiLGM9bmV3IHIuRmlndXJlMkQ7cmV0dXJuIG89PT0ic2VjdG9yIiYmYy5tb3ZlVG8oMCwwKSxjLmVsbGlwc2UoMCwwLHksUCwwLE1hdGguUEkqeC8xODAsTWF0aC5QSSptLzE4MCxoKSxvIT09Im5vbmUiJiZjLmNsb3NlUGF0aCgpLGMucGF0aC5yZWR1Y2UoKEUsQSk9PkUrQS5qb2luKCIgIiksIiIpfWNsYXNzIGQgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1thXSh7cmFkaXVzWDowLHJhZGl1c1k6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwLGRpcmVjdGlvbjoiY2xvY2t3aXNlIixjbG9zZVR5cGU6Im5vbmUifSksdGhpc1tmXSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW3NdKCJkIil9c2V0IGQoeSl7fWdldCByYWRpdXNYKCl7cmV0dXJuIHRoaXNbc10oInJhZGl1c1giKX1zZXQgcmFkaXVzWCh5KXtpZih5PU9iamVjdChpLnRvTnVtYmVyKSh5KSx0aGlzW2xdKCJyYWRpdXNYIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgcmFkaXVzWSgpe3JldHVybiB0aGlzW3NdKCJyYWRpdXNZIil9c2V0IHJhZGl1c1koeSl7aWYoeT1PYmplY3QoaS50b051bWJlcikoeSksdGhpc1tsXSgicmFkaXVzWSIseSkpe2NvbnN0IFA9dih0aGlzKTt0aGlzW2xdKCJkIixQKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLnJhZGl1c1gsdGhpcy5yYWRpdXNZXX1zZXQgcmFkaXVzKHkpe3k9T2JqZWN0KGkudG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMucmFkaXVzWD15WzBdLHRoaXMucmFkaXVzWT15WzFdfWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKHkpe3k9T2JqZWN0KGkudG9BcnJheSkoeSksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMuc3RhcnRBbmdsZT15WzBdLHRoaXMuZW5kQW5nbGU9eVsxXX1nZXQgZGlyZWN0aW9uKCl7cmV0dXJuIHRoaXNbc10oImRpcmVjdGlvbiIpfXNldCBkaXJlY3Rpb24oeSl7aWYoeSE9bnVsbCYmeSE9PSJjbG9ja3dpc2UiJiZ5IT09ImFudGljbG9ja3dpc2UiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZGlyZWN0aW9uIHR5cGUuIik7dGhpc1tsXSgiZGlyZWN0aW9uIix5KX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW3NdKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUoeSl7aWYoeT1PYmplY3QoaS50b051bWJlcikoeSksdGhpc1tsXSgic3RhcnRBbmdsZSIseSkpe2NvbnN0IFA9dih0aGlzKTt0aGlzW2xdKCJkIixQKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbc10oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKHkpe2lmKHk9T2JqZWN0KGkudG9OdW1iZXIpKHkpLHRoaXNbbF0oImVuZEFuZ2xlIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbc10oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUoeSl7aWYoeSE9bnVsbCYmeSE9PSJub25lIiYmeSE9PSJzZWN0b3IiJiZ5IT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW2xdKCJjbG9zZVR5cGUiLHkpKXtjb25zdCBQPXYodGhpcyk7dGhpc1tsXSgiZCIsUCl9fX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDI0Miksbj10KDIxMyksaT10KDI0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEocyxmLHYpe3JldHVybiBmIGluIHM/T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsZix7dmFsdWU6dixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnNbZl09dixzfWNsYXNzIGwgZXh0ZW5kcyByLmRlZmF1bHR7fWEobCwiQXR0ciIsaS5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGwsImFyYyIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBpfSk7dmFyIHI9dCgyNDMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIGkgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IHJhZGl1cygpe3JldHVybiBzdXBlci5yYWRpdXNYfXNldCByYWRpdXMobCl7bD1PYmplY3Qobi50b051bWJlcikobCksc3VwZXIucmFkaXVzWD1sLHN1cGVyLnJhZGl1c1k9bH19fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLGk9dCgyNDcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKHMsZix2KXtyZXR1cm4gZiBpbiBzP09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLGYse3ZhbHVlOnYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpzW2ZdPXYsc31jbGFzcyBsIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtpbm5lclJhZGl1czpmLG91dGVyUmFkaXVzOnYsc3RhcnRBbmdsZTpkLGVuZEFuZ2xlOnB9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4oZj4wfHx2PjApJiZkIT09cCYmc3VwZXIuaXNWaXNpYmxlfX1hKGwsIkF0dHIiLGkuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZShsLCJyaW5nIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxpPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBhPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiB2KHApe2xldHtpbm5lclJhZGl1czp5LG91dGVyUmFkaXVzOlAsc3RhcnRBbmdsZTp4LGVuZEFuZ2xlOm19PXA7Y29uc3QgTz1uZXcgci5GaWd1cmUyRDtpZih4PU1hdGguUEkqeC8xODAsbT1NYXRoLlBJKm0vMTgwLHk+UCYmKFt5LFBdPVtQLHldKSx5PD0wJiZPLm1vdmVUbygwLDApLE8uYXJjKDAsMCxQLHgsbSwhMSkseT4wKXtjb25zdCBjPU1hdGguUEkqMjttPHgmJihtPXgrYysobS14KSVjKSxtLXg+PWMmJihtPXgrYy0xZS02KSxPLmFyYygwLDAseSxtLHgsITApfXJldHVybiBPLmNsb3NlUGF0aCgpLE8ucGF0aC5yZWR1Y2UoKGMsZyk9PmMrZy5qb2luKCIgIiksIiIpfWNsYXNzIGQgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1thXSh7aW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjB9KSx0aGlzW2ZdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbc10oImQiKX1zZXQgZCh5KXt9Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbc10oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKHkpe2lmKHk9T2JqZWN0KGkudG9OdW1iZXIpKHkpLHRoaXNbbF0oImlubmVyUmFkaXVzIix5KSl7Y29uc3QgUD12KHRoaXMpO3RoaXNbbF0oImQiLFApfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tzXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoeSl7aWYoeT1PYmplY3QoaS50b051bWJlcikoeSksdGhpc1tsXSgib3V0ZXJSYWRpdXMiLHkpKXtjb25zdCBQPXYodGhpcyk7dGhpc1tsXSgiZCIsUCl9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKHkpe3k9T2JqZWN0KGkudG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMuaW5uZXJSYWRpdXM9eVswXSx0aGlzLm91dGVyUmFkaXVzPXlbMV19Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1tzXSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKHkpe2lmKHk9T2JqZWN0KGkudG9OdW1iZXIpKHkpLHRoaXNbbF0oInN0YXJ0QW5nbGUiLHkpKXtjb25zdCBQPXYodGhpcyk7dGhpc1tsXSgiZCIsUCl9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW3NdKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZSh5KXtpZih5PU9iamVjdChpLnRvTnVtYmVyKSh5KSx0aGlzW2xdKCJlbmRBbmdsZSIseSkpe2NvbnN0IFA9dih0aGlzKTt0aGlzW2xdKCJkIixQKX19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUoeSl7eT1PYmplY3QoaS50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpcy5zdGFydEFuZ2xlPXlbMF0sdGhpcy5lbmRBbmdsZT15WzFdfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KTt2YXIgcj10KDEyKSxuPXQoMjE4KSxpPXQoMjE5KSxhPXQoMjQ5KSxsPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyh4LG0sTyl7cmV0dXJuIG0gaW4geD9PYmplY3QuZGVmaW5lUHJvcGVydHkoeCxtLHt2YWx1ZTpPLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6eFttXT1PLHh9Y29uc3QgZj1TeW1ib2woInRleHRJbWFnZSIpLHY9U3ltYm9sKCJ0ZXh0SW1hZ2VUYXNrIiksZD1TeW1ib2woInRleHR1cmVDb250ZXh0IikscD1TeW1ib2woInVwZGF0ZVRleHR1cmVSZWN0IikseT1TeW1ib2woInRleHRDYW52YXMiKTtjbGFzcyBQIGV4dGVuZHMgaS5kZWZhdWx0e2NvbnN0cnVjdG9yKG09e30pe3R5cGVvZiBtPT0ic3RyaW5nIiYmKG09e3RleHQ6bX0pLHN1cGVyKG0pfWdldCBjb250ZW50U2l6ZSgpe2xldFttLE9dPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOm8saGVpZ2h0Omh9PXRoaXMuYXR0cmlidXRlcztpZihvPT1udWxsfHxoPT1udWxsKXtjb25zdCBjPXRoaXNbZl07YyYmKG89PW51bGwmJihtPWMucmVjdFsyXSksaD09bnVsbCYmKE89Yy5yZWN0WzNdKSl9cmV0dXJuW20sT119Z2V0IHRleHQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHQobSl7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9bX1nZXQgdGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHRDb250ZW50KG0pe3RoaXMuYXR0cmlidXRlcy50ZXh0PW19Z2V0IHRleHRJbWFnZSgpe3JldHVybiB0aGlzW2ZdfHx7fX1nZXQgdGV4dEltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1t2XXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhtKXtzdXBlci5kcmF3KG0pO2NvbnN0IE89dGhpcy5tZXNoO2lmKE8pe2NvbnN0IG89dGhpc1tmXTtpZihvKXtsZXQgaD1PLnRleHR1cmU7aWYoIWh8fHRoaXNbZF0mJnRoaXNbZF0hPT10aGlzLnJlbmRlcmVyfHxvLm5lZWRzVXBkYXRlPyhvLm5lZWRzVXBkYXRlPSExLE9iamVjdChuLmRlbGV0ZVRleHR1cmUpKG8uaW1hZ2UsdGhpcy5yZW5kZXJlciksaD1PYmplY3Qobi5jcmVhdGVUZXh0dXJlKShvLmltYWdlLHRoaXMucmVuZGVyZXIpLHRoaXNbcF09ITApOmg9Ty51bmlmb3Jtcy51X3RleFNhbXBsZXIsdGhpc1twXSl7Y29uc3RbYyxnXT1vLnJlY3Quc2xpY2UoMiksW2IsRV09dGhpcy5jb250ZW50U2l6ZSxBPXRoaXMuYXR0cmlidXRlcy50ZXh0QWxpZ24sTD10aGlzLmF0dHJpYnV0ZXMudmVydGljYWxBbGlnbjtsZXQgTT0wO0E9PT0iY2VudGVyIj9NPShiLWMpLzI6KEE9PT0icmlnaHQifHxBPT09ImVuZCIpJiYoTT1iLWMpO2NvbnN0IEk9dGhpcy5hdHRyaWJ1dGVzLmZvbnRTaXplLEQ9dGhpcy5hdHRyaWJ1dGVzLmxpbmVIZWlnaHQ7bGV0IFI9MDtMPT09InRvcCI/Uj0oSS1EKS8yOkw9PT0iYm90dG9tIiYmKFI9KEQtSSkvMik7Y29uc3R7cGFkZGluZ0xlZnQ6QyxwYWRkaW5nVG9wOkJ9PXRoaXMuYXR0cmlidXRlcyx7Ym9yZGVyV2lkdGg6en09dGhpcy5hdHRyaWJ1dGVzO00rPUMreixSKz1CK3o7Y29uc3R7YW5jaG9yWDpLLGFuY2hvclk6UX09dGhpcy5hdHRyaWJ1dGVzO00tPXRoaXMub2Zmc2V0U2l6ZVswXSpLLFItPXRoaXMub2Zmc2V0U2l6ZVsxXSpRLE8uc2V0VGV4dHVyZShoLHtyZWN0OltNLFIsYyxnXX0pLHRoaXNbcF09ITEsdGhpc1tkXT10aGlzLnJlbmRlcmVyfX19cmV0dXJuIG19b25Qcm9wZXJ0eUNoYW5nZShtLE8sbyl7bT09PSJ0ZXh0Inx8bT09PSJmb250U2l6ZSJ8fG09PT0iZm9udEZhbWlseSJ8fG09PT0iZm9udFN0eWxlInx8bT09PSJmb250VmFyaWFudCJ8fG09PT0iZm9udFdlaWdodCJ8fG09PT0iZm9udFN0cmV0Y2gifHxtPT09ImxpbmVIZWlnaHQifHxtPT09InN0cm9rZUNvbG9yInx8bT09PSJmaWxsQ29sb3IifHxtPT09InN0cm9rZVdpZHRoIj90aGlzLnVwZGF0ZVRleHQoKTooKG09PT0idGV4dEFsaWduInx8bT09PSJ2ZXJ0aWNhbEFsaWduIikmJih0aGlzW3BdPSEwKSxzdXBlci5vblByb3BlcnR5Q2hhbmdlKG0sTyxvKSl9dXBkYXRlQ29udG91cnMoKXtzdXBlci51cGRhdGVDb250b3VycygpLHRoaXNbcF09ITB9dXBkYXRlVGV4dCgpe3RoaXNbdl18fCh0aGlzW3ZdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzW3ZdPW51bGw7Y29uc3R7dGV4dDptLGZvbnQ6TyxmaWxsQ29sb3I6byxzdHJva2VDb2xvcjpoLHN0cm9rZVdpZHRoOmN9PXRoaXMuYXR0cmlidXRlcyxnPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtyZXR1cm4gdGhpc1t5XT10aGlzW3ldfHxyLkVOVi5jcmVhdGVDYW52YXMoMSwxKSx0aGlzW2ZdPXIuRU5WLmNyZWF0ZVRleHQobSx7Zm9udDpPLGZpbGxDb2xvcjpvLHN0cm9rZUNvbG9yOmgsc3Ryb2tlV2lkdGg6YyxwYXJzZUZvbnQ6ci5wYXJzZUZvbnQscmF0aW86Zyx0ZXh0Q2FudmFzOnRoaXNbeV19KSx0aGlzW2ZdLm5lZWRzVXBkYXRlPSEwLHRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpc1tmXX0pKX19cyhQLCJBdHRyIixhLmRlZmF1bHQpLGwuZGVmYXVsdC5yZWdpc3Rlck5vZGUoUCwibGFiZWwiKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciByPXQoMTIpLG49dCg3MiksaT10KDIyMSksYT10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSx2PVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2NsYXNzIGQgZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tsXSh7dGV4dDoiIixmb250U2l6ZToxNixmb250RmFtaWx5OiJIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZiIsZm9udFN0eWxlOiJub3JtYWwiLGZvbnRWYXJpYW50OiJub3JtYWwiLGZvbnRXZWlnaHQ6Im5vcm1hbCIsZm9udFN0cmV0Y2g6Im5vcm1hbCIsbGluZUhlaWdodDoiIix0ZXh0QWxpZ246ImxlZnQiLHN0cm9rZUNvbG9yOnZvaWQgMCxzdHJva2VXaWR0aDoxLGZpbGxDb2xvcjp2b2lkIDAsdmVydGljYWxBbGlnbjoibWlkZGxlIn0pLHRoaXNbdl0oImZvbnQiKX1nZXQgdGV4dCgpe3JldHVybiB0aGlzW2ZdKCJ0ZXh0Iil8fCIgIn1zZXQgdGV4dCh5KXt0aGlzW3NdKCJ0ZXh0Iix5KX1nZXQgZm9udFNpemUoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFNpemUiKX1zZXQgZm9udFNpemUoeSl7dGhpc1tzXSgiZm9udFNpemUiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IGZvbnRGYW1pbHkoKXtyZXR1cm4gdGhpc1tmXSgiZm9udEZhbWlseSIpfXNldCBmb250RmFtaWx5KHkpe3RoaXNbc10oImZvbnRGYW1pbHkiLHkpfWdldCBmb250U3R5bGUoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFN0eWxlIil9c2V0IGZvbnRTdHlsZSh5KXt0aGlzW3NdKCJmb250U3R5bGUiLHkpfWdldCBmb250VmFyaWFudCgpe3JldHVybiB0aGlzW2ZdKCJmb250VmFyaWFudCIpfXNldCBmb250VmFyaWFudCh5KXt0aGlzW3NdKCJmb250VmFyaWFudCIseSl9Z2V0IGZvbnRXZWlnaHQoKXtyZXR1cm4gdGhpc1tmXSgiZm9udFdlaWdodCIpfXNldCBmb250V2VpZ2h0KHkpe3RoaXNbc10oImZvbnRXZWlnaHQiLHkpfWdldCBmb250U3RyZXRjaCgpe3JldHVybiB0aGlzW2ZdKCJmb250U3RyZXRjaCIpfXNldCBmb250U3RyZXRjaCh5KXt0aGlzW3NdKCJmb250U3RyZXRjaCIseSl9Z2V0IGxpbmVIZWlnaHQoKXtyZXR1cm4gdGhpc1tmXSgibGluZUhlaWdodCIpfHx0aGlzLmZvbnRTaXplfXNldCBsaW5lSGVpZ2h0KHkpe3RoaXNbc10oImxpbmVIZWlnaHQiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IHRleHRBbGlnbigpe3JldHVybiB0aGlzW2ZdKCJ0ZXh0QWxpZ24iKX1zZXQgdGV4dEFsaWduKHkpe3RoaXNbc10oInRleHRBbGlnbiIseSl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbZl0oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKHkpe3RoaXNbc10oInN0cm9rZUNvbG9yIixPYmplY3QoaS5wYXJzZUNvbG9yKSh5KSl9Z2V0IHN0cm9rZVdpZHRoKCl7cmV0dXJuIHRoaXNbZl0oInN0cm9rZVdpZHRoIil9c2V0IHN0cm9rZVdpZHRoKHkpe3RoaXNbc10oInN0cm9rZVdpZHRoIixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCB2ZXJ0aWNhbEFsaWduKCl7cmV0dXJuIHRoaXNbZl0oInZlcnRpY2FsQWxpZ24iKX1zZXQgdmVydGljYWxBbGlnbih5KXt0aGlzW3NdKCJ2ZXJ0aWNhbEFsaWduIix5KX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbZl0oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IoeSl7dGhpc1tzXSgiZmlsbENvbG9yIixPYmplY3QoaS5wYXJzZUNvbG9yKSh5KSl9Z2V0IGZvbnQoKXtjb25zdHtmb250U3R5bGU6eSxmb250VmFyaWFudDpQLGZvbnRXZWlnaHQ6eCxmb250U3RyZXRjaDptLGZvbnRTaXplOk8sbGluZUhlaWdodDpvLGZvbnRGYW1pbHk6aH09dGhpcztyZXR1cm5gJHt5fSAke1B9ICR7eH0gJHttfSAke099cHgvJHtvfXB4ICR7aH1gfXNldCBmb250KHkpe2lmKHk9PW51bGwpdGhpcy5mb250U3R5bGU9bnVsbCx0aGlzLmZvbnRWYXJpYW50PW51bGwsdGhpcy5mb250V2VpZ2h0PW51bGwsdGhpcy5mb250U3RyZXRjaD1udWxsLHRoaXMuZm9udFNpemU9bnVsbCx0aGlzLmxpbmVIZWlnaHQ9bnVsbCx0aGlzLmZvbnRGYW1pbHk9bnVsbDtlbHNle2NvbnN0IFA9T2JqZWN0KHIucGFyc2VGb250KSh5KTt0aGlzLmZvbnRTdHlsZT1QLnN0eWxlLHRoaXMuZm9udFZhcmlhbnQ9UC52YXJpYW50LHRoaXMuZm9udFdlaWdodD1QLndlaWdodCx0aGlzLmZvbnRTdHJldGNoPVAuc3RyZXRjaCx0aGlzLmZvbnRTaXplPU9iamVjdChuLnRvTnVtYmVyKShgJHtQLnNpemV9JHtQLnVuaXR9YCksUC5saW5lSGVpZ2h0JiYodGhpcy5saW5lSGVpZ2h0PVAucHhMaW5lSGVpZ2h0KSx0aGlzLmZvbnRGYW1pbHk9UC5mYW1pbHl9fX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDEyKSxuPXQoMjE5KSxpPXQoMjUxKSxhPXQoMjEzKSxsPXQoMjUyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyhQLHgsbSl7cmV0dXJuIHggaW4gUD9PYmplY3QuZGVmaW5lUHJvcGVydHkoUCx4LHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6UFt4XT1tLFB9Y29uc3QgZj1TeW1ib2woInpPcmRlciIpLHY9U3ltYm9sKCJvcmRlcmVkIiksZD1TeW1ib2woImNoaWxkcmVuIikscD1TeW1ib2woInNlYWxlZCIpO2NsYXNzIHkgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoeD17fSl7c3VwZXIoeCksdGhpc1tkXT1bXSx0aGlzW3ZdPW51bGwsdGhpc1tmXT0wfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuIHRoaXNbZF19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXNbZF19Z2V0IG9yZGVyZWRDaGlsZHJlbigpe3JldHVybiB0aGlzW3ZdfHwodGhpc1t2XT1bLi4udGhpc1tkXV0sdGhpc1t2XS5zb3J0KCh4LG0pPT54LnpJbmRleC1tLnpJbmRleHx8eC56T3JkZXItbS56T3JkZXIpKSx0aGlzW3ZdfWFwcGVuZCguLi54KXtyZXR1cm4geC5tYXAobT0+dGhpcy5hcHBlbmRDaGlsZChtKSl9YXBwZW5kQ2hpbGQoeCl7cmV0dXJuIHgucmVtb3ZlKCksdGhpc1tkXS5wdXNoKHgpLHguY29ubmVjdCh0aGlzLHRoaXNbZl0rKyksdGhpc1t2XSYmKHRoaXNbdl0ubGVuZ3RoJiZ4LnpJbmRleDx0aGlzW3ZdW3RoaXNbdl0ubGVuZ3RoLTFdLnpJbmRleD90aGlzLnJlb3JkZXIoKTp0aGlzW3ZdLnB1c2goeCkpLHh9Y2xvbmVOb2RlKHg9ITEpe2NvbnN0IG09c3VwZXIuY2xvbmVOb2RlKCk7cmV0dXJuIHgmJnRoaXNbZF0uZm9yRWFjaChPPT57Y29uc3Qgbz1PLmNsb25lTm9kZSh4KTttLmFwcGVuZENoaWxkKG8pfSksbX1kaXNwYXRjaFBvaW50ZXJFdmVudCh4KXtjb25zdCBtPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgTz1tLmxlbmd0aC0xO08+PTA7Ty0tKWlmKG1bT10uZGlzcGF0Y2hQb2ludGVyRXZlbnQoeCkpcmV0dXJuITA7cmV0dXJuIHN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KHgpfWRyYXcoeD1bXSl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PXRoaXMucmVuZGVyTWF0cml4LHN1cGVyLmRyYXcoeCksIXRoaXNbcF0mJnRoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiKXtjb25zdCBtPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgTz0wO088bS5sZW5ndGg7TysrKW1bT10uZHJhdyh4KX1yZXR1cm4gdGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PW51bGwseH1nZXRFbGVtZW50QnlJZCh4KXtyZXR1cm4gT2JqZWN0KGwucXVlcnlTZWxlY3RvcikoYCMke3h9YCx0aGlzKX1nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHgpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yQWxsKShgLiR7eH1gLHRoaXMpfWdldEVsZW1lbnRzQnlOYW1lKHgpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yQWxsKShgW25hbWU9IiR7eH0iXWAsdGhpcyl9Z2V0RWxlbWVudHNCeVRhZ05hbWUoeCl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKHgsdGhpcyl9aW5zZXJ0QmVmb3JlKHgsbSl7aWYobT09bnVsbClyZXR1cm4gdGhpcy5hcHBlbmRDaGlsZCh4KTt4LnJlbW92ZSgpO2NvbnN0IE89dGhpc1tkXS5pbmRleE9mKG0pO2lmKE88MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7Y29uc3Qgbz1tLnpPcmRlcjtmb3IobGV0IGg9TztoPHRoaXNbZF0ubGVuZ3RoO2grKyl7Y29uc3QgYz10aGlzW2RdW2hdLnpPcmRlcixnPXRoaXNbZF1baF07ZGVsZXRlIGcuek9yZGVyLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnLCJ6T3JkZXIiLHt2YWx1ZTpjKzEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9aWYodGhpc1tkXS5zcGxpY2UoTywwLHgpLHguY29ubmVjdCh0aGlzLG8pLHRoaXNbdl0paWYoeC56SW5kZXghPT1tLnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IGg9dGhpc1t2XS5pbmRleE9mKG0pO3RoaXNbdl0uc3BsaWNlKGgsMCx4KX1yZXR1cm4geH1xdWVyeVNlbGVjdG9yKHgpe3JldHVybiBPYmplY3QobC5xdWVyeVNlbGVjdG9yKSh4LHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoeCl7cmV0dXJuIE9iamVjdChsLnF1ZXJ5U2VsZWN0b3JBbGwpKHgsdGhpcyl9cmVwbGFjZUNoaWxkKHgsbSl7eC5yZW1vdmUoKTtjb25zdCBPPXRoaXNbZF0uaW5kZXhPZihtKTtpZihPPDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2lmKHRoaXNbZF1bT109eCx4LmNvbm5lY3QodGhpcyxtLnpPcmRlciksdGhpc1t2XSlpZih4LnpJbmRleCE9PW0uekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3Qgbz10aGlzW3ZdLmluZGV4T2YobSk7dGhpc1t2XVtvXT14fXJldHVybiBtLmRpc2Nvbm5lY3QodGhpcykseH1yZW1vdmVBbGxDaGlsZHJlbigpe2NvbnN0IHg9dGhpc1tkXTtmb3IobGV0IG09eC5sZW5ndGgtMTttPj0wO20tLSl4W21dLnJlbW92ZSgpfXJlbW92ZUNoaWxkKHgpe2NvbnN0IG09dGhpc1tkXS5pbmRleE9mKHgpO2lmKG0+PTApe2lmKHRoaXNbZF0uc3BsaWNlKG0sMSksdGhpc1t2XSl7Y29uc3QgTz10aGlzW3ZdLmluZGV4T2YoeCk7dGhpc1t2XS5zcGxpY2UoTywxKX1yZXR1cm4geC5kaXNjb25uZWN0KHRoaXMpLHh9cmV0dXJuIG51bGx9cmVvcmRlcigpe3RoaXNbdl09bnVsbH1zZWFsKCl7ZnVuY3Rpb24geChoLGMpe2NvbnN0IGc9W107Zm9yKGxldCBiPTA7YjxoLmxlbmd0aDtiKyspe2NvbnN0IEU9Wy4uLmhbYl1dO2ZvcihsZXQgQT0xO0E8RS5sZW5ndGg7QSs9Mil7Y29uc3QgTD1FW0FdLE09RVtBKzFdO0VbQV09TCpjWzBdK00qY1syXStjWzRdLEVbQSsxXT1MKmNbMV0rTSpjWzNdK2NbNV19Zy5wdXNoKEUpfXJldHVybiBnfWNvbnN0IG09dGhpcy5vcmRlcmVkQ2hpbGRyZW4sTz1uZXcgci5GaWd1cmUyRCxvPXRoaXMubG9jYWxNYXRyaXg7Zm9yKGxldCBoPTA7aDxtLmxlbmd0aDtoKyspe2xldCBjPW1baF07aWYoYyBpbnN0YW5jZW9mIHkmJihjPWMuc2VhbCgpKSxjLmNsaWVudEJveCl7bGV0IGc9Yy5jbGllbnRCb3guY29udG91cnMucGF0aDtnPXgoZyxjLmxvY2FsTWF0cml4KSxPLmFkZFBhdGgoZyl9aWYoYy5wYXRoKXtsZXQgZz1jLnBhdGguY29udG91cnMucGF0aDtnPXgoZyxjLmxvY2FsTWF0cml4KSxPLmFkZFBhdGgoZyl9fXJldHVybiB0aGlzW3BdPSEwLHRoaXMuY2xpZW50Qm94PU8se2NsaWVudEJveDpPLGxvY2FsTWF0cml4Om99fXNldFJlc29sdXRpb24oe3dpZHRoOngsaGVpZ2h0Om19KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDp4LGhlaWdodDptfSksdGhpc1tkXS5mb3JFYWNoKE89PntPLnNldFJlc29sdXRpb24oe3dpZHRoOngsaGVpZ2h0Om19KX0pfXVwZGF0ZUNvbnRvdXJzKCl7dGhpc1twXXx8c3VwZXIudXBkYXRlQ29udG91cnMoKX19cyh5LCJBdHRyIixpLmRlZmF1bHQpLGEuZGVmYXVsdC5yZWdpc3Rlck5vZGUoeSwiZ3JvdXAiKX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciByPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgbiBleHRlbmRzIHIuZGVmYXVsdHt9fSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJxdWVyeVNlbGVjdG9yQWxsIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInF1ZXJ5U2VsZWN0b3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiaXNNYXRjaGVkIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImNvbXBpbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDIyMSksbj10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGk9dCgyNTMpO2Z1bmN0aW9uIGEobSl7cmV0dXJuIG0ubm9kZVR5cGU9PT0xfHxuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKG0ubm9kZU5hbWUpfWZ1bmN0aW9uIGwobSl7cmV0dXJuIEFycmF5LmZyb20obS5jaGlsZE5vZGVzfHxbXSl9ZnVuY3Rpb24gcyhtKXtyZXR1cm4gbi5kZWZhdWx0LmlzU3ByaXRlTm9kZShtLm5vZGVOYW1lKT9tLnBhcmVudHx8bS5jYW52YXN8fG0uY29udGFpbmVyOm0ucGFyZW50RWxlbWVudH1mdW5jdGlvbiBmKG0pe2xldCBPPW0ubGVuZ3RoLG8saCxjO2Zvcig7LS1PPi0xOyl7Zm9yKG89aD1tW09dLG1bT109bnVsbCxjPSEwO2g7KXtpZihtLmluZGV4T2YoaCk+LTEpe2M9ITEsbS5zcGxpY2UoTywxKTticmVha31oPXMoaCl9YyYmKG1bT109byl9cmV0dXJuIG19Y29uc3Qgdj17aXNUYWc6YSxleGlzdHNPbmUobSxPKXtyZXR1cm4gTy5zb21lKG89PmEobyk/bShvKXx8di5leGlzdHNPbmUobSxsKG8pKTohMSl9LGdldFNpYmxpbmdzKG0pe2NvbnN0IE89cyhtKTtyZXR1cm4gTyYmbChPKX0sZ2V0Q2hpbGRyZW46bCxnZXRQYXJlbnQ6cyxnZXRBdHRyaWJ1dGVWYWx1ZShtLE8pe2lmKG0ubm9kZVR5cGU9PT0xJiZPPT09ImNsYXNzInx8Tz09PSJpZCIpcmV0dXJuIG1bT107aWYodGhpcy5oYXNBdHRyaWIobSxPKSl7bGV0IG89bS5hdHRyaWJ1dGVzW09dO3JldHVybiBBcnJheS5pc0FycmF5KG8pJiYobz1gWyR7by5qb2luKCl9XWApLFN0cmluZyhvKX19LGhhc0F0dHJpYihtLE8pe3JldHVybiBtLmF0dHJpYnV0ZXNbT10hPW51bGx9LHJlbW92ZVN1YnNldHM6ZixnZXROYW1lKG0pe3JldHVybiBtLnRhZ05hbWU/bS50YWdOYW1lLnRvTG93ZXJDYXNlKCk6bnVsbH0sZmluZE9uZTpmdW5jdGlvbiBtKE8sbyl7bGV0IGg9bnVsbDtmb3IobGV0IGM9MCxnPW8ubGVuZ3RoO2M8ZyYmIWg7YysrKWlmKE8ob1tjXSkpaD1vW2NdO2Vsc2V7Y29uc3QgYj1sKG9bY10pO2ImJmIubGVuZ3RoPjAmJihoPW0oTyxiKSl9cmV0dXJuIGh9LGZpbmRBbGw6ZnVuY3Rpb24gbShPLG8pe2xldCBoPVtdO2ZvcihsZXQgYz0wLGc9by5sZW5ndGg7YzxnO2MrKyl7aWYoIWEob1tjXSkpY29udGludWU7TyhvW2NdKSYmaC5wdXNoKG9bY10pO2NvbnN0IGI9bChvW2NdKTtiJiYoaD1oLmNvbmNhdChtKE8sYikpKX1yZXR1cm4gaH0sZ2V0VGV4dDpmdW5jdGlvbiBtKE8pe3JldHVybiBBcnJheS5pc0FycmF5KE8pP08ubWFwKG0pLmpvaW4oIiIpOmEoTyk/bShsKE8pKTpPLm5vZGVUeXBlPT09Mz9PLm5vZGVWYWx1ZTpuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKE8ubm9kZU5hbWUpP08udGV4dDoiIn19O2Z1bmN0aW9uIGQobSl7aWYodHlwZW9mIG0hPSJzdHJpbmciKXJldHVybiBtO2xldCBPPW0ubWF0Y2goL1xbKGJnY29sb3J8ZmlsbENvbG9yfHN0cm9rZUNvbG9yfGNvbG9yKVxzKj1ccypbJyJdP1x3K1snIl0/XF0vZyk7cmV0dXJuIE8mJihPPU8ubWFwKG89Pntjb25zdCBoPW8uc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxjPU9iamVjdChyLnBhcnNlQ29sb3IpKGhbMV0ucmVwbGFjZSgvWyciXS9nLCIiKSk7cmV0dXJuW28sYFske2hbMF19PSIke2N9Il1gXX0pLE8uZm9yRWFjaCgoW28saF0pPT57bT1tLnJlcGxhY2UobyxoKX0pKSxPPW0ubWF0Y2goL1xbXHcrXHMqPVxzKlsnIl1cWy4rP1xdWyciXVxdL2cpLE8mJihPPU8ubWFwKG89Pntjb25zdCBoPW8uc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxjPWhbMV0uc2xpY2UoMiwtMikuc3BsaXQoLywvZykubWFwKGc9PmcudHJpbSgpKTtyZXR1cm5bbyxgWyR7aFswXX09Ilske2N9XSJdYF19KSxPLmZvckVhY2goKFtvLGhdKT0+e209bS5yZXBsYWNlKG8saCl9KSksbX1mdW5jdGlvbiBwKG0sTyl7cmV0dXJuIGkuc2VsZWN0QWxsKGQobSksTyx7YWRhcHRlcjp2fSl9ZnVuY3Rpb24geShtLE8pe3JldHVybiBpLnNlbGVjdE9uZShkKG0pLE8se2FkYXB0ZXI6dn0pfWZ1bmN0aW9uIFAobSxPKXtyZXR1cm4gaS5pcyhtLGQoTykse2FkYXB0ZXI6dn0pfWZ1bmN0aW9uIHgobSl7cmV0dXJuIGkuY29tcGlsZShkKG0pLHthZGFwdGVyOnZ9KX19LGZ1bmN0aW9uKHUsZSx0KXt1LmV4cG9ydHM9eDt2YXIgcj10KDI1NCksbj10KDI3MykuZmFsc2VGdW5jLGk9dCgyNzQpO2Z1bmN0aW9uIGEobSl7cmV0dXJuIGZ1bmN0aW9uKG8saCxjKXtyZXR1cm4gaD1ofHx7fSxoLmFkYXB0ZXI9aC5hZGFwdGVyfHxyLG0obyxoLGMpfX12YXIgbD1hKGkpLHM9YShpLmNvbXBpbGVVbnNhZmUpO2Z1bmN0aW9uIGYobSl7cmV0dXJuIGZ1bmN0aW9uKG8saCxjKXtyZXR1cm4gYz1jfHx7fSxjLmFkYXB0ZXI9Yy5hZGFwdGVyfHxyLHR5cGVvZiBvIT0iZnVuY3Rpb24iJiYobz1zKG8sYyxoKSksby5zaG91bGRUZXN0TmV4dFNpYmxpbmdzJiYoaD1kKGMmJmMuY29udGV4dHx8aCxjLmFkYXB0ZXIpKSxBcnJheS5pc0FycmF5KGgpP2g9Yy5hZGFwdGVyLnJlbW92ZVN1YnNldHMoaCk6aD1jLmFkYXB0ZXIuZ2V0Q2hpbGRyZW4oaCksbShvLGgsYyl9fWZ1bmN0aW9uIHYobSxPKXt2YXIgbz1PLmdldFNpYmxpbmdzKG0pO2lmKCFBcnJheS5pc0FycmF5KG8pKXJldHVybltdO2ZvcihvPW8uc2xpY2UoMCk7by5zaGlmdCgpIT09bTspO3JldHVybiBvfWZ1bmN0aW9uIGQobSxPKXtBcnJheS5pc0FycmF5KG0pfHwobT1bbV0pO2Zvcih2YXIgbz1tLnNsaWNlKDApLGg9MCxjPW0ubGVuZ3RoO2g8YztoKyspe3ZhciBnPXYob1toXSxPKTtvLnB1c2guYXBwbHkobyxnKX1yZXR1cm4gb312YXIgcD1mKGZ1bmN0aW9uKE8sbyxoKXtyZXR1cm4gTz09PW58fCFvfHxvLmxlbmd0aD09PTA/W106aC5hZGFwdGVyLmZpbmRBbGwoTyxvKX0pLHk9ZihmdW5jdGlvbihPLG8saCl7cmV0dXJuIE89PT1ufHwhb3x8by5sZW5ndGg9PT0wP251bGw6aC5hZGFwdGVyLmZpbmRPbmUoTyxvKX0pO2Z1bmN0aW9uIFAobSxPLG8pe3JldHVybiBvPW98fHt9LG8uYWRhcHRlcj1vLmFkYXB0ZXJ8fHIsKHR5cGVvZiBPPT0iZnVuY3Rpb24iP086bChPLG8pKShtKX1mdW5jdGlvbiB4KG0sTyxvKXtyZXR1cm4gcChtLE8sbyl9eC5jb21waWxlPWwseC5maWx0ZXJzPWkuUHNldWRvcy5maWx0ZXJzLHgucHNldWRvcz1pLlBzZXVkb3MucHNldWRvcyx4LnNlbGVjdEFsbD1wLHguc2VsZWN0T25lPXkseC5pcz1QLHgucGFyc2U9bCx4Lml0ZXJhdGU9cCx4Ll9jb21waWxlVW5zYWZlPXMseC5fY29tcGlsZVRva2VuPWkuY29tcGlsZVRva2VufSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dS5leHBvcnRzO1t0KDI1NSksdCgyNjgpLHQoMjY5KSx0KDI3MCksdCgyNzEpLHQoMjcyKV0uZm9yRWFjaChmdW5jdGlvbihuKXtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKGkpe3JbaV09bltpXS5iaW5kKHIpfSl9KX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMjU2KSxuPXQoMjU3KSxpPXIuaXNUYWc7dS5leHBvcnRzPXtnZXRJbm5lckhUTUw6YSxnZXRPdXRlckhUTUw6bixnZXRUZXh0Omx9O2Z1bmN0aW9uIGEocyxmKXtyZXR1cm4gcy5jaGlsZHJlbj9zLmNoaWxkcmVuLm1hcChmdW5jdGlvbih2KXtyZXR1cm4gbih2LGYpfSkuam9pbigiIik6IiJ9ZnVuY3Rpb24gbChzKXtyZXR1cm4gQXJyYXkuaXNBcnJheShzKT9zLm1hcChsKS5qb2luKCIiKTppKHMpP3MubmFtZT09PSJiciI/YApgOmwocy5jaGlsZHJlbik6cy50eXBlPT09ci5DREFUQT9sKHMuY2hpbGRyZW4pOnMudHlwZT09PXIuVGV4dD9zLmRhdGE6IiJ9fSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz17VGV4dDoidGV4dCIsRGlyZWN0aXZlOiJkaXJlY3RpdmUiLENvbW1lbnQ6ImNvbW1lbnQiLFNjcmlwdDoic2NyaXB0IixTdHlsZToic3R5bGUiLFRhZzoidGFnIixDREFUQToiY2RhdGEiLERvY3R5cGU6ImRvY3R5cGUiLGlzVGFnOmZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGU9PT0idGFnInx8dC50eXBlPT09InNjcmlwdCJ8fHQudHlwZT09PSJzdHlsZSJ9fX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMjU4KSxuPXQoMjU5KSxpPXQoMjY3KTtpLmVsZW1lbnROYW1lcy5fX3Byb3RvX189bnVsbCxpLmF0dHJpYnV0ZU5hbWVzLl9fcHJvdG9fXz1udWxsO3ZhciBhPXtfX3Byb3RvX186bnVsbCxzdHlsZTohMCxzY3JpcHQ6ITAseG1wOiEwLGlmcmFtZTohMCxub2VtYmVkOiEwLG5vZnJhbWVzOiEwLHBsYWludGV4dDohMCxub3NjcmlwdDohMH07ZnVuY3Rpb24gbChtLE8pe2lmKG0pe3ZhciBvPSIiLGg7Zm9yKHZhciBjIGluIG0paD1tW2NdLG8mJihvKz0iICIpLE8ueG1sTW9kZT09PSJmb3JlaWduIiYmKGM9aS5hdHRyaWJ1dGVOYW1lc1tjXXx8Yyksbys9YywoaCE9PW51bGwmJmghPT0iInx8Ty54bWxNb2RlKSYmKG8rPSc9IicrKE8uZGVjb2RlRW50aXRpZXM/bi5lbmNvZGVYTUwoaCk6aC5yZXBsYWNlKC9cIi9nLCImcXVvdDsiKSkrJyInKTtyZXR1cm4gb319dmFyIHM9e19fcHJvdG9fXzpudWxsLGFyZWE6ITAsYmFzZTohMCxiYXNlZm9udDohMCxicjohMCxjb2w6ITAsY29tbWFuZDohMCxlbWJlZDohMCxmcmFtZTohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsaXNpbmRleDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9LGY9dS5leHBvcnRzPWZ1bmN0aW9uKG0sTyl7IUFycmF5LmlzQXJyYXkobSkmJiFtLmNoZWVyaW8mJihtPVttXSksTz1PfHx7fTtmb3IodmFyIG89IiIsaD0wO2g8bS5sZW5ndGg7aCsrKXt2YXIgYz1tW2hdO2MudHlwZT09PSJyb290Ij9vKz1mKGMuY2hpbGRyZW4sTyk6ci5pc1RhZyhjKT9vKz1kKGMsTyk6Yy50eXBlPT09ci5EaXJlY3RpdmU/bys9cChjKTpjLnR5cGU9PT1yLkNvbW1lbnQ/bys9eChjKTpjLnR5cGU9PT1yLkNEQVRBP28rPVAoYyk6bys9eShjLE8pfXJldHVybiBvfSx2PVsibWkiLCJtbyIsIm1uIiwibXMiLCJtdGV4dCIsImFubm90YXRpb24teG1sIiwiZm9yZWlnbk9iamVjdCIsImRlc2MiLCJ0aXRsZSJdO2Z1bmN0aW9uIGQobSxPKXtPLnhtbE1vZGU9PT0iZm9yZWlnbiImJihtLm5hbWU9aS5lbGVtZW50TmFtZXNbbS5uYW1lXXx8bS5uYW1lLG0ucGFyZW50JiZ2LmluZGV4T2YobS5wYXJlbnQubmFtZSk+PTAmJihPPU9iamVjdC5hc3NpZ24oe30sTyx7eG1sTW9kZTohMX0pKSksIU8ueG1sTW9kZSYmWyJzdmciLCJtYXRoIl0uaW5kZXhPZihtLm5hbWUpPj0wJiYoTz1PYmplY3QuYXNzaWduKHt9LE8se3htbE1vZGU6ImZvcmVpZ24ifSkpO3ZhciBvPSI8IittLm5hbWUsaD1sKG0uYXR0cmlicyxPKTtyZXR1cm4gaCYmKG8rPSIgIitoKSxPLnhtbE1vZGUmJighbS5jaGlsZHJlbnx8bS5jaGlsZHJlbi5sZW5ndGg9PT0wKT9vKz0iLz4iOihvKz0iPiIsbS5jaGlsZHJlbiYmKG8rPWYobS5jaGlsZHJlbixPKSksKCFzW20ubmFtZV18fE8ueG1sTW9kZSkmJihvKz0iPC8iK20ubmFtZSsiPiIpKSxvfWZ1bmN0aW9uIHAobSl7cmV0dXJuIjwiK20uZGF0YSsiPiJ9ZnVuY3Rpb24geShtLE8pe3ZhciBvPW0uZGF0YXx8IiI7cmV0dXJuIE8uZGVjb2RlRW50aXRpZXMmJiEobS5wYXJlbnQmJm0ucGFyZW50Lm5hbWUgaW4gYSkmJihvPW4uZW5jb2RlWE1MKG8pKSxvfWZ1bmN0aW9uIFAobSl7cmV0dXJuIjwhW0NEQVRBWyIrbS5jaGlsZHJlblswXS5kYXRhKyJdXT4ifWZ1bmN0aW9uIHgobSl7cmV0dXJuIjwhLS0iK20uZGF0YSsiLS0+In19LGZ1bmN0aW9uKHUsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gcihuKXtyZXR1cm4gbi50eXBlPT09InRhZyJ8fG4udHlwZT09PSJzY3JpcHQifHxuLnR5cGU9PT0ic3R5bGUifWUuaXNUYWc9cixlLlRleHQ9InRleHQiLGUuRGlyZWN0aXZlPSJkaXJlY3RpdmUiLGUuQ29tbWVudD0iY29tbWVudCIsZS5TY3JpcHQ9InNjcmlwdCIsZS5TdHlsZT0ic3R5bGUiLGUuVGFnPSJ0YWciLGUuQ0RBVEE9ImNkYXRhIixlLkRvY3R5cGU9ImRvY3R5cGUifSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZW5jb2RlPWUuZGVjb2RlU3RyaWN0PWUuZGVjb2RlPXZvaWQgMDt2YXIgcj10KDI2MCksbj10KDI2Nik7ZnVuY3Rpb24gaSh2LGQpe3JldHVybighZHx8ZDw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUwpKHYpfWUuZGVjb2RlPWk7ZnVuY3Rpb24gYSh2LGQpe3JldHVybighZHx8ZDw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUxTdHJpY3QpKHYpfWUuZGVjb2RlU3RyaWN0PWE7ZnVuY3Rpb24gbCh2LGQpe3JldHVybighZHx8ZDw9MD9uLmVuY29kZVhNTDpuLmVuY29kZUhUTUwpKHYpfWUuZW5jb2RlPWw7dmFyIHM9dCgyNjYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmVuY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZXNjYXBlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5lc2NhcGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuZW5jb2RlSFRNTH19KTt2YXIgZj10KDI2MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNVN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWNvZGVYTUx9fSl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZCl7cmV0dXJuIGQmJmQuX19lc01vZHVsZT9kOntkZWZhdWx0OmR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWNvZGVIVE1MPWUuZGVjb2RlSFRNTFN0cmljdD1lLmRlY29kZVhNTD12b2lkIDA7dmFyIG49cih0KDI2MSkpLGk9cih0KDI2MikpLGE9cih0KDI2MykpLGw9cih0KDI2NCkpO2UuZGVjb2RlWE1MPXMoYS5kZWZhdWx0KSxlLmRlY29kZUhUTUxTdHJpY3Q9cyhuLmRlZmF1bHQpO2Z1bmN0aW9uIHMoZCl7dmFyIHA9T2JqZWN0LmtleXMoZCkuam9pbigifCIpLHk9dihkKTtwKz0ifCNbeFhdW1xcZGEtZkEtRl0rfCNcXGQrIjt2YXIgUD1uZXcgUmVnRXhwKCImKD86IitwKyIpOyIsImciKTtyZXR1cm4gZnVuY3Rpb24oeCl7cmV0dXJuIFN0cmluZyh4KS5yZXBsYWNlKFAseSl9fXZhciBmPWZ1bmN0aW9uKGQscCl7cmV0dXJuIGQ8cD8xOi0xfTtlLmRlY29kZUhUTUw9ZnVuY3Rpb24oKXtmb3IodmFyIGQ9T2JqZWN0LmtleXMoaS5kZWZhdWx0KS5zb3J0KGYpLHA9T2JqZWN0LmtleXMobi5kZWZhdWx0KS5zb3J0KGYpLHk9MCxQPTA7eTxwLmxlbmd0aDt5KyspZFtQXT09PXBbeV0/KHBbeV0rPSI7PyIsUCsrKTpwW3ldKz0iOyI7dmFyIHg9bmV3IFJlZ0V4cCgiJig/OiIrcC5qb2luKCJ8IikrInwjW3hYXVtcXGRhLWZBLUZdKzs/fCNcXGQrOz8pIiwiZyIpLG09dihuLmRlZmF1bHQpO2Z1bmN0aW9uIE8obyl7cmV0dXJuIG8uc3Vic3RyKC0xKSE9PSI7IiYmKG8rPSI7IiksbShvKX1yZXR1cm4gZnVuY3Rpb24obyl7cmV0dXJuIFN0cmluZyhvKS5yZXBsYWNlKHgsTyl9fSgpO2Z1bmN0aW9uIHYoZCl7cmV0dXJuIGZ1bmN0aW9uKHkpe2lmKHkuY2hhckF0KDEpPT09IiMiKXt2YXIgUD15LmNoYXJBdCgyKTtyZXR1cm4gUD09PSJYInx8UD09PSJ4Ij9sLmRlZmF1bHQocGFyc2VJbnQoeS5zdWJzdHIoMyksMTYpKTpsLmRlZmF1bHQocGFyc2VJbnQoeS5zdWJzdHIoMiksMTApKX1yZXR1cm4gZFt5LnNsaWNlKDEsLTEpXX19fSxmdW5jdGlvbih1KXt1LmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWJyZXZlIjoixIIiLCJhYnJldmUiOiLEgyIsImFjIjoi4oi+IiwiYWNkIjoi4oi/IiwiYWNFIjoi4oi+zLMiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBY3kiOiLQkCIsImFjeSI6ItCwIiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJhZiI6IuKBoSIsIkFmciI6IvCdlIQiLCJhZnIiOiLwnZSeIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFsZWZzeW0iOiLihLUiLCJhbGVwaCI6IuKEtSIsIkFscGhhIjoizpEiLCJhbHBoYSI6Is6xIiwiQW1hY3IiOiLEgCIsImFtYWNyIjoixIEiLCJhbWFsZyI6IuKovyIsImFtcCI6IiYiLCJBTVAiOiImIiwiYW5kYW5kIjoi4qmVIiwiQW5kIjoi4qmTIiwiYW5kIjoi4oinIiwiYW5kZCI6IuKpnCIsImFuZHNsb3BlIjoi4qmYIiwiYW5kdiI6IuKpmiIsImFuZyI6IuKIoCIsImFuZ2UiOiLipqQiLCJhbmdsZSI6IuKIoCIsImFuZ21zZGFhIjoi4qaoIiwiYW5nbXNkYWIiOiLipqkiLCJhbmdtc2RhYyI6IuKmqiIsImFuZ21zZGFkIjoi4qarIiwiYW5nbXNkYWUiOiLipqwiLCJhbmdtc2RhZiI6IuKmrSIsImFuZ21zZGFnIjoi4qauIiwiYW5nbXNkYWgiOiLipq8iLCJhbmdtc2QiOiLiiKEiLCJhbmdydCI6IuKInyIsImFuZ3J0dmIiOiLiir4iLCJhbmdydHZiZCI6IuKmnSIsImFuZ3NwaCI6IuKIoiIsImFuZ3N0Ijoiw4UiLCJhbmd6YXJyIjoi4o28IiwiQW9nb24iOiLEhCIsImFvZ29uIjoixIUiLCJBb3BmIjoi8J2UuCIsImFvcGYiOiLwnZWSIiwiYXBhY2lyIjoi4qmvIiwiYXAiOiLiiYgiLCJhcEUiOiLiqbAiLCJhcGUiOiLiiYoiLCJhcGlkIjoi4omLIiwiYXBvcyI6IlwnIiwiQXBwbHlGdW5jdGlvbiI6IuKBoSIsImFwcHJveCI6IuKJiCIsImFwcHJveGVxIjoi4omKIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBc2NyIjoi8J2SnCIsImFzY3IiOiLwnZK2IiwiQXNzaWduIjoi4omUIiwiYXN0IjoiKiIsImFzeW1wIjoi4omIIiwiYXN5bXBlcSI6IuKJjSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJhd2NvbmludCI6IuKIsyIsImF3aW50Ijoi4qiRIiwiYmFja2NvbmciOiLiiYwiLCJiYWNrZXBzaWxvbiI6Is+2IiwiYmFja3ByaW1lIjoi4oC1IiwiYmFja3NpbSI6IuKIvSIsImJhY2tzaW1lcSI6IuKLjSIsIkJhY2tzbGFzaCI6IuKIliIsIkJhcnYiOiLiq6ciLCJiYXJ2ZWUiOiLiir0iLCJiYXJ3ZWQiOiLijIUiLCJCYXJ3ZWQiOiLijIYiLCJiYXJ3ZWRnZSI6IuKMhSIsImJicmsiOiLijrUiLCJiYnJrdGJyayI6IuKOtiIsImJjb25nIjoi4omMIiwiQmN5Ijoi0JEiLCJiY3kiOiLQsSIsImJkcXVvIjoi4oCeIiwiYmVjYXVzIjoi4oi1IiwiYmVjYXVzZSI6IuKItSIsIkJlY2F1c2UiOiLiiLUiLCJiZW1wdHl2Ijoi4qawIiwiYmVwc2kiOiLPtiIsImJlcm5vdSI6IuKErCIsIkJlcm5vdWxsaXMiOiLihKwiLCJCZXRhIjoizpIiLCJiZXRhIjoizrIiLCJiZXRoIjoi4oS2IiwiYmV0d2VlbiI6IuKJrCIsIkJmciI6IvCdlIUiLCJiZnIiOiLwnZSfIiwiYmlnY2FwIjoi4ouCIiwiYmlnY2lyYyI6IuKXryIsImJpZ2N1cCI6IuKLgyIsImJpZ29kb3QiOiLiqIAiLCJiaWdvcGx1cyI6IuKogSIsImJpZ290aW1lcyI6IuKogiIsImJpZ3NxY3VwIjoi4qiGIiwiYmlnc3RhciI6IuKYhSIsImJpZ3RyaWFuZ2xlZG93biI6IuKWvSIsImJpZ3RyaWFuZ2xldXAiOiLilrMiLCJiaWd1cGx1cyI6IuKohCIsImJpZ3ZlZSI6IuKLgSIsImJpZ3dlZGdlIjoi4ouAIiwiYmthcm93Ijoi4qSNIiwiYmxhY2tsb3plbmdlIjoi4qerIiwiYmxhY2tzcXVhcmUiOiLilqoiLCJibGFja3RyaWFuZ2xlIjoi4pa0IiwiYmxhY2t0cmlhbmdsZWRvd24iOiLilr4iLCJibGFja3RyaWFuZ2xlbGVmdCI6IuKXgiIsImJsYWNrdHJpYW5nbGVyaWdodCI6IuKWuCIsImJsYW5rIjoi4pCjIiwiYmxrMTIiOiLilpIiLCJibGsxNCI6IuKWkSIsImJsazM0Ijoi4paTIiwiYmxvY2siOiLilogiLCJibmUiOiI94oOlIiwiYm5lcXVpdiI6IuKJoeKDpSIsImJOb3QiOiLiq60iLCJibm90Ijoi4oyQIiwiQm9wZiI6IvCdlLkiLCJib3BmIjoi8J2VkyIsImJvdCI6IuKKpSIsImJvdHRvbSI6IuKKpSIsImJvd3RpZSI6IuKLiCIsImJveGJveCI6IuKniSIsImJveGRsIjoi4pSQIiwiYm94ZEwiOiLilZUiLCJib3hEbCI6IuKVliIsImJveERMIjoi4pWXIiwiYm94ZHIiOiLilIwiLCJib3hkUiI6IuKVkiIsImJveERyIjoi4pWTIiwiYm94RFIiOiLilZQiLCJib3hoIjoi4pSAIiwiYm94SCI6IuKVkCIsImJveGhkIjoi4pSsIiwiYm94SGQiOiLilaQiLCJib3hoRCI6IuKVpSIsImJveEhEIjoi4pWmIiwiYm94aHUiOiLilLQiLCJib3hIdSI6IuKVpyIsImJveGhVIjoi4pWoIiwiYm94SFUiOiLilakiLCJib3htaW51cyI6IuKKnyIsImJveHBsdXMiOiLiip4iLCJib3h0aW1lcyI6IuKKoCIsImJveHVsIjoi4pSYIiwiYm94dUwiOiLilZsiLCJib3hVbCI6IuKVnCIsImJveFVMIjoi4pWdIiwiYm94dXIiOiLilJQiLCJib3h1UiI6IuKVmCIsImJveFVyIjoi4pWZIiwiYm94VVIiOiLilZoiLCJib3h2Ijoi4pSCIiwiYm94ViI6IuKVkSIsImJveHZoIjoi4pS8IiwiYm94dkgiOiLilaoiLCJib3hWaCI6IuKVqyIsImJveFZIIjoi4pWsIiwiYm94dmwiOiLilKQiLCJib3h2TCI6IuKVoSIsImJveFZsIjoi4pWiIiwiYm94VkwiOiLilaMiLCJib3h2ciI6IuKUnCIsImJveHZSIjoi4pWeIiwiYm94VnIiOiLilZ8iLCJib3hWUiI6IuKVoCIsImJwcmltZSI6IuKAtSIsImJyZXZlIjoiy5giLCJCcmV2ZSI6IsuYIiwiYnJ2YmFyIjoiwqYiLCJic2NyIjoi8J2StyIsIkJzY3IiOiLihKwiLCJic2VtaSI6IuKBjyIsImJzaW0iOiLiiL0iLCJic2ltZSI6IuKLjSIsImJzb2xiIjoi4qeFIiwiYnNvbCI6IlxcXFwiLCJic29saHN1YiI6IuKfiCIsImJ1bGwiOiLigKIiLCJidWxsZXQiOiLigKIiLCJidW1wIjoi4omOIiwiYnVtcEUiOiLiqq4iLCJidW1wZSI6IuKJjyIsIkJ1bXBlcSI6IuKJjiIsImJ1bXBlcSI6IuKJjyIsIkNhY3V0ZSI6IsSGIiwiY2FjdXRlIjoixIciLCJjYXBhbmQiOiLiqYQiLCJjYXBicmN1cCI6IuKpiSIsImNhcGNhcCI6IuKpiyIsImNhcCI6IuKIqSIsIkNhcCI6IuKLkiIsImNhcGN1cCI6IuKphyIsImNhcGRvdCI6IuKpgCIsIkNhcGl0YWxEaWZmZXJlbnRpYWxEIjoi4oWFIiwiY2FwcyI6IuKIqe+4gCIsImNhcmV0Ijoi4oGBIiwiY2Fyb24iOiLLhyIsIkNheWxleXMiOiLihK0iLCJjY2FwcyI6IuKpjSIsIkNjYXJvbiI6IsSMIiwiY2Nhcm9uIjoixI0iLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiQ2NpcmMiOiLEiCIsImNjaXJjIjoixIkiLCJDY29uaW50Ijoi4oiwIiwiY2N1cHMiOiLiqYwiLCJjY3Vwc3NtIjoi4qmQIiwiQ2RvdCI6IsSKIiwiY2RvdCI6IsSLIiwiY2VkaWwiOiLCuCIsIkNlZGlsbGEiOiLCuCIsImNlbXB0eXYiOiLiprIiLCJjZW50IjoiwqIiLCJjZW50ZXJkb3QiOiLCtyIsIkNlbnRlckRvdCI6IsK3IiwiY2ZyIjoi8J2UoCIsIkNmciI6IuKErSIsIkNIY3kiOiLQpyIsImNoY3kiOiLRhyIsImNoZWNrIjoi4pyTIiwiY2hlY2ttYXJrIjoi4pyTIiwiQ2hpIjoizqciLCJjaGkiOiLPhyIsImNpcmMiOiLLhiIsImNpcmNlcSI6IuKJlyIsImNpcmNsZWFycm93bGVmdCI6IuKGuiIsImNpcmNsZWFycm93cmlnaHQiOiLihrsiLCJjaXJjbGVkYXN0Ijoi4oqbIiwiY2lyY2xlZGNpcmMiOiLiipoiLCJjaXJjbGVkZGFzaCI6IuKKnSIsIkNpcmNsZURvdCI6IuKKmSIsImNpcmNsZWRSIjoiwq4iLCJjaXJjbGVkUyI6IuKTiCIsIkNpcmNsZU1pbnVzIjoi4oqWIiwiQ2lyY2xlUGx1cyI6IuKKlSIsIkNpcmNsZVRpbWVzIjoi4oqXIiwiY2lyIjoi4peLIiwiY2lyRSI6IuKngyIsImNpcmUiOiLiiZciLCJjaXJmbmludCI6IuKokCIsImNpcm1pZCI6IuKrryIsImNpcnNjaXIiOiLip4IiLCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLIiLCJDbG9zZUN1cmx5RG91YmxlUXVvdGUiOiLigJ0iLCJDbG9zZUN1cmx5UXVvdGUiOiLigJkiLCJjbHVicyI6IuKZoyIsImNsdWJzdWl0Ijoi4pmjIiwiY29sb24iOiI6IiwiQ29sb24iOiLiiLciLCJDb2xvbmUiOiLiqbQiLCJjb2xvbmUiOiLiiZQiLCJjb2xvbmVxIjoi4omUIiwiY29tbWEiOiIsIiwiY29tbWF0IjoiQCIsImNvbXAiOiLiiIEiLCJjb21wZm4iOiLiiJgiLCJjb21wbGVtZW50Ijoi4oiBIiwiY29tcGxleGVzIjoi4oSCIiwiY29uZyI6IuKJhSIsImNvbmdkb3QiOiLiqa0iLCJDb25ncnVlbnQiOiLiiaEiLCJjb25pbnQiOiLiiK4iLCJDb25pbnQiOiLiiK8iLCJDb250b3VySW50ZWdyYWwiOiLiiK4iLCJjb3BmIjoi8J2VlCIsIkNvcGYiOiLihIIiLCJjb3Byb2QiOiLiiJAiLCJDb3Byb2R1Y3QiOiLiiJAiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjb3B5c3IiOiLihJciLCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oizIiwiY3JhcnIiOiLihrUiLCJjcm9zcyI6IuKclyIsIkNyb3NzIjoi4qivIiwiQ3NjciI6IvCdkp4iLCJjc2NyIjoi8J2SuCIsImNzdWIiOiLiq48iLCJjc3ViZSI6IuKrkSIsImNzdXAiOiLiq5AiLCJjc3VwZSI6IuKrkiIsImN0ZG90Ijoi4ouvIiwiY3VkYXJybCI6IuKkuCIsImN1ZGFycnIiOiLipLUiLCJjdWVwciI6IuKLniIsImN1ZXNjIjoi4oufIiwiY3VsYXJyIjoi4oa2IiwiY3VsYXJycCI6IuKkvSIsImN1cGJyY2FwIjoi4qmIIiwiY3VwY2FwIjoi4qmGIiwiQ3VwQ2FwIjoi4omNIiwiY3VwIjoi4oiqIiwiQ3VwIjoi4ouTIiwiY3VwY3VwIjoi4qmKIiwiY3VwZG90Ijoi4oqNIiwiY3Vwb3IiOiLiqYUiLCJjdXBzIjoi4oiq77iAIiwiY3VyYXJyIjoi4oa3IiwiY3VyYXJybSI6IuKkvCIsImN1cmx5ZXFwcmVjIjoi4oueIiwiY3VybHllcXN1Y2MiOiLii58iLCJjdXJseXZlZSI6IuKLjiIsImN1cmx5d2VkZ2UiOiLii48iLCJjdXJyZW4iOiLCpCIsImN1cnZlYXJyb3dsZWZ0Ijoi4oa2IiwiY3VydmVhcnJvd3JpZ2h0Ijoi4oa3IiwiY3V2ZWUiOiLii44iLCJjdXdlZCI6IuKLjyIsImN3Y29uaW50Ijoi4oiyIiwiY3dpbnQiOiLiiLEiLCJjeWxjdHkiOiLijK0iLCJkYWdnZXIiOiLigKAiLCJEYWdnZXIiOiLigKEiLCJkYWxldGgiOiLihLgiLCJkYXJyIjoi4oaTIiwiRGFyciI6IuKGoSIsImRBcnIiOiLih5MiLCJkYXNoIjoi4oCQIiwiRGFzaHYiOiLiq6QiLCJkYXNodiI6IuKKoyIsImRia2Fyb3ciOiLipI8iLCJkYmxhYyI6IsudIiwiRGNhcm9uIjoixI4iLCJkY2Fyb24iOiLEjyIsIkRjeSI6ItCUIiwiZGN5Ijoi0LQiLCJkZGFnZ2VyIjoi4oChIiwiZGRhcnIiOiLih4oiLCJERCI6IuKFhSIsImRkIjoi4oWGIiwiRERvdHJhaGQiOiLipJEiLCJkZG90c2VxIjoi4qm3IiwiZGVnIjoiwrAiLCJEZWwiOiLiiIciLCJEZWx0YSI6Is6UIiwiZGVsdGEiOiLOtCIsImRlbXB0eXYiOiLiprEiLCJkZmlzaHQiOiLipb8iLCJEZnIiOiLwnZSHIiwiZGZyIjoi8J2UoSIsImRIYXIiOiLipaUiLCJkaGFybCI6IuKHgyIsImRoYXJyIjoi4oeCIiwiRGlhY3JpdGljYWxBY3V0ZSI6IsK0IiwiRGlhY3JpdGljYWxEb3QiOiLLmSIsIkRpYWNyaXRpY2FsRG91YmxlQWN1dGUiOiLLnSIsIkRpYWNyaXRpY2FsR3JhdmUiOiJgIiwiRGlhY3JpdGljYWxUaWxkZSI6IsucIiwiZGlhbSI6IuKLhCIsImRpYW1vbmQiOiLii4QiLCJEaWFtb25kIjoi4ouEIiwiZGlhbW9uZHN1aXQiOiLimaYiLCJkaWFtcyI6IuKZpiIsImRpZSI6IsKoIiwiRGlmZmVyZW50aWFsRCI6IuKFhiIsImRpZ2FtbWEiOiLPnSIsImRpc2luIjoi4ouyIiwiZGl2Ijoiw7ciLCJkaXZpZGUiOiLDtyIsImRpdmlkZW9udGltZXMiOiLii4ciLCJkaXZvbngiOiLii4ciLCJESmN5Ijoi0IIiLCJkamN5Ijoi0ZIiLCJkbGNvcm4iOiLijJ4iLCJkbGNyb3AiOiLijI0iLCJkb2xsYXIiOiIkIiwiRG9wZiI6IvCdlLsiLCJkb3BmIjoi8J2VlSIsIkRvdCI6IsKoIiwiZG90Ijoiy5kiLCJEb3REb3QiOiLig5wiLCJkb3RlcSI6IuKJkCIsImRvdGVxZG90Ijoi4omRIiwiRG90RXF1YWwiOiLiiZAiLCJkb3RtaW51cyI6IuKIuCIsImRvdHBsdXMiOiLiiJQiLCJkb3RzcXVhcmUiOiLiiqEiLCJkb3VibGViYXJ3ZWRnZSI6IuKMhiIsIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbCI6IuKIryIsIkRvdWJsZURvdCI6IsKoIiwiRG91YmxlRG93bkFycm93Ijoi4oeTIiwiRG91YmxlTGVmdEFycm93Ijoi4oeQIiwiRG91YmxlTGVmdFJpZ2h0QXJyb3ciOiLih5QiLCJEb3VibGVMZWZ0VGVlIjoi4qukIiwiRG91YmxlTG9uZ0xlZnRBcnJvdyI6IuKfuCIsIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKfuiIsIkRvdWJsZUxvbmdSaWdodEFycm93Ijoi4p+5IiwiRG91YmxlUmlnaHRBcnJvdyI6IuKHkiIsIkRvdWJsZVJpZ2h0VGVlIjoi4oqoIiwiRG91YmxlVXBBcnJvdyI6IuKHkSIsIkRvdWJsZVVwRG93bkFycm93Ijoi4oeVIiwiRG91YmxlVmVydGljYWxCYXIiOiLiiKUiLCJEb3duQXJyb3dCYXIiOiLipJMiLCJkb3duYXJyb3ciOiLihpMiLCJEb3duQXJyb3ciOiLihpMiLCJEb3duYXJyb3ciOiLih5MiLCJEb3duQXJyb3dVcEFycm93Ijoi4oe1IiwiRG93bkJyZXZlIjoizJEiLCJkb3duZG93bmFycm93cyI6IuKHiiIsImRvd25oYXJwb29ubGVmdCI6IuKHgyIsImRvd25oYXJwb29ucmlnaHQiOiLih4IiLCJEb3duTGVmdFJpZ2h0VmVjdG9yIjoi4qWQIiwiRG93bkxlZnRUZWVWZWN0b3IiOiLipZ4iLCJEb3duTGVmdFZlY3RvckJhciI6IuKlliIsIkRvd25MZWZ0VmVjdG9yIjoi4oa9IiwiRG93blJpZ2h0VGVlVmVjdG9yIjoi4qWfIiwiRG93blJpZ2h0VmVjdG9yQmFyIjoi4qWXIiwiRG93blJpZ2h0VmVjdG9yIjoi4oeBIiwiRG93blRlZUFycm93Ijoi4oanIiwiRG93blRlZSI6IuKKpCIsImRyYmthcm93Ijoi4qSQIiwiZHJjb3JuIjoi4oyfIiwiZHJjcm9wIjoi4oyMIiwiRHNjciI6IvCdkp8iLCJkc2NyIjoi8J2SuSIsIkRTY3kiOiLQhSIsImRzY3kiOiLRlSIsImRzb2wiOiLip7YiLCJEc3Ryb2siOiLEkCIsImRzdHJvayI6IsSRIiwiZHRkb3QiOiLii7EiLCJkdHJpIjoi4pa/IiwiZHRyaWYiOiLilr4iLCJkdWFyciI6IuKHtSIsImR1aGFyIjoi4qWvIiwiZHdhbmdsZSI6IuKmpiIsIkRaY3kiOiLQjyIsImR6Y3kiOiLRnyIsImR6aWdyYXJyIjoi4p+/IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsImVhc3RlciI6IuKpriIsIkVjYXJvbiI6IsSaIiwiZWNhcm9uIjoixJsiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsImVjaXIiOiLiiZYiLCJlY29sb24iOiLiiZUiLCJFY3kiOiLQrSIsImVjeSI6ItGNIiwiZUREb3QiOiLiqbciLCJFZG90IjoixJYiLCJlZG90IjoixJciLCJlRG90Ijoi4omRIiwiZWUiOiLihYciLCJlZkRvdCI6IuKJkiIsIkVmciI6IvCdlIgiLCJlZnIiOiLwnZSiIiwiZWciOiLiqpoiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiZWdzIjoi4qqWIiwiZWdzZG90Ijoi4qqYIiwiZWwiOiLiqpkiLCJFbGVtZW50Ijoi4oiIIiwiZWxpbnRlcnMiOiLij6ciLCJlbGwiOiLihJMiLCJlbHMiOiLiqpUiLCJlbHNkb3QiOiLiqpciLCJFbWFjciI6IsSSIiwiZW1hY3IiOiLEkyIsImVtcHR5Ijoi4oiFIiwiZW1wdHlzZXQiOiLiiIUiLCJFbXB0eVNtYWxsU3F1YXJlIjoi4pe7IiwiZW1wdHl2Ijoi4oiFIiwiRW1wdHlWZXJ5U21hbGxTcXVhcmUiOiLilqsiLCJlbXNwMTMiOiLigIQiLCJlbXNwMTQiOiLigIUiLCJlbXNwIjoi4oCDIiwiRU5HIjoixYoiLCJlbmciOiLFiyIsImVuc3AiOiLigIIiLCJFb2dvbiI6IsSYIiwiZW9nb24iOiLEmSIsIkVvcGYiOiLwnZS8IiwiZW9wZiI6IvCdlZYiLCJlcGFyIjoi4ouVIiwiZXBhcnNsIjoi4qejIiwiZXBsdXMiOiLiqbEiLCJlcHNpIjoizrUiLCJFcHNpbG9uIjoizpUiLCJlcHNpbG9uIjoizrUiLCJlcHNpdiI6Is+1IiwiZXFjaXJjIjoi4omWIiwiZXFjb2xvbiI6IuKJlSIsImVxc2ltIjoi4omCIiwiZXFzbGFudGd0ciI6IuKqliIsImVxc2xhbnRsZXNzIjoi4qqVIiwiRXF1YWwiOiLiqbUiLCJlcXVhbHMiOiI9IiwiRXF1YWxUaWxkZSI6IuKJgiIsImVxdWVzdCI6IuKJnyIsIkVxdWlsaWJyaXVtIjoi4oeMIiwiZXF1aXYiOiLiiaEiLCJlcXVpdkREIjoi4qm4IiwiZXF2cGFyc2wiOiLip6UiLCJlcmFyciI6IuKlsSIsImVyRG90Ijoi4omTIiwiZXNjciI6IuKEryIsIkVzY3IiOiLihLAiLCJlc2RvdCI6IuKJkCIsIkVzaW0iOiLiqbMiLCJlc2ltIjoi4omCIiwiRXRhIjoizpciLCJldGEiOiLOtyIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJldXJvIjoi4oKsIiwiZXhjbCI6IiEiLCJleGlzdCI6IuKIgyIsIkV4aXN0cyI6IuKIgyIsImV4cGVjdGF0aW9uIjoi4oSwIiwiZXhwb25lbnRpYWxlIjoi4oWHIiwiRXhwb25lbnRpYWxFIjoi4oWHIiwiZmFsbGluZ2RvdHNlcSI6IuKJkiIsIkZjeSI6ItCkIiwiZmN5Ijoi0YQiLCJmZW1hbGUiOiLimYAiLCJmZmlsaWciOiLvrIMiLCJmZmxpZyI6Iu+sgCIsImZmbGxpZyI6Iu+shCIsIkZmciI6IvCdlIkiLCJmZnIiOiLwnZSjIiwiZmlsaWciOiLvrIEiLCJGaWxsZWRTbWFsbFNxdWFyZSI6IuKXvCIsIkZpbGxlZFZlcnlTbWFsbFNxdWFyZSI6IuKWqiIsImZqbGlnIjoiZmoiLCJmbGF0Ijoi4pmtIiwiZmxsaWciOiLvrIIiLCJmbHRucyI6IuKWsSIsImZub2YiOiLGkiIsIkZvcGYiOiLwnZS9IiwiZm9wZiI6IvCdlZciLCJmb3JhbGwiOiLiiIAiLCJGb3JBbGwiOiLiiIAiLCJmb3JrIjoi4ouUIiwiZm9ya3YiOiLiq5kiLCJGb3VyaWVydHJmIjoi4oSxIiwiZnBhcnRpbnQiOiLiqI0iLCJmcmFjMTIiOiLCvSIsImZyYWMxMyI6IuKFkyIsImZyYWMxNCI6IsK8IiwiZnJhYzE1Ijoi4oWVIiwiZnJhYzE2Ijoi4oWZIiwiZnJhYzE4Ijoi4oWbIiwiZnJhYzIzIjoi4oWUIiwiZnJhYzI1Ijoi4oWWIiwiZnJhYzM0Ijoiwr4iLCJmcmFjMzUiOiLihZciLCJmcmFjMzgiOiLihZwiLCJmcmFjNDUiOiLihZgiLCJmcmFjNTYiOiLihZoiLCJmcmFjNTgiOiLihZ0iLCJmcmFjNzgiOiLihZ4iLCJmcmFzbCI6IuKBhCIsImZyb3duIjoi4oyiIiwiZnNjciI6IvCdkrsiLCJGc2NyIjoi4oSxIiwiZ2FjdXRlIjoix7UiLCJHYW1tYSI6Is6TIiwiZ2FtbWEiOiLOsyIsIkdhbW1hZCI6Is+cIiwiZ2FtbWFkIjoiz50iLCJnYXAiOiLiqoYiLCJHYnJldmUiOiLEniIsImdicmV2ZSI6IsSfIiwiR2NlZGlsIjoixKIiLCJHY2lyYyI6IsScIiwiZ2NpcmMiOiLEnSIsIkdjeSI6ItCTIiwiZ2N5Ijoi0LMiLCJHZG90IjoixKAiLCJnZG90IjoixKEiLCJnZSI6IuKJpSIsImdFIjoi4omnIiwiZ0VsIjoi4qqMIiwiZ2VsIjoi4oubIiwiZ2VxIjoi4omlIiwiZ2VxcSI6IuKJpyIsImdlcXNsYW50Ijoi4qm+IiwiZ2VzY2MiOiLiqqkiLCJnZXMiOiLiqb4iLCJnZXNkb3QiOiLiqoAiLCJnZXNkb3RvIjoi4qqCIiwiZ2VzZG90b2wiOiLiqoQiLCJnZXNsIjoi4oub77iAIiwiZ2VzbGVzIjoi4qqUIiwiR2ZyIjoi8J2UiiIsImdmciI6IvCdlKQiLCJnZyI6IuKJqyIsIkdnIjoi4ouZIiwiZ2dnIjoi4ouZIiwiZ2ltZWwiOiLihLciLCJHSmN5Ijoi0IMiLCJnamN5Ijoi0ZMiLCJnbGEiOiLiqqUiLCJnbCI6IuKJtyIsImdsRSI6IuKqkiIsImdsaiI6IuKqpCIsImduYXAiOiLiqooiLCJnbmFwcHJveCI6IuKqiiIsImduZSI6IuKqiCIsImduRSI6IuKJqSIsImduZXEiOiLiqogiLCJnbmVxcSI6IuKJqSIsImduc2ltIjoi4ounIiwiR29wZiI6IvCdlL4iLCJnb3BmIjoi8J2VmCIsImdyYXZlIjoiYCIsIkdyZWF0ZXJFcXVhbCI6IuKJpSIsIkdyZWF0ZXJFcXVhbExlc3MiOiLii5siLCJHcmVhdGVyRnVsbEVxdWFsIjoi4omnIiwiR3JlYXRlckdyZWF0ZXIiOiLiqqIiLCJHcmVhdGVyTGVzcyI6IuKJtyIsIkdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+IiwiR3JlYXRlclRpbGRlIjoi4omzIiwiR3NjciI6IvCdkqIiLCJnc2NyIjoi4oSKIiwiZ3NpbSI6IuKJsyIsImdzaW1lIjoi4qqOIiwiZ3NpbWwiOiLiqpAiLCJndGNjIjoi4qqnIiwiZ3RjaXIiOiLiqboiLCJndCI6Ij4iLCJHVCI6Ij4iLCJHdCI6IuKJqyIsImd0ZG90Ijoi4ouXIiwiZ3RsUGFyIjoi4qaVIiwiZ3RxdWVzdCI6IuKpvCIsImd0cmFwcHJveCI6IuKqhiIsImd0cmFyciI6IuKluCIsImd0cmRvdCI6IuKLlyIsImd0cmVxbGVzcyI6IuKLmyIsImd0cmVxcWxlc3MiOiLiqowiLCJndHJsZXNzIjoi4om3IiwiZ3Ryc2ltIjoi4omzIiwiZ3ZlcnRuZXFxIjoi4omp77iAIiwiZ3ZuRSI6IuKJqe+4gCIsIkhhY2VrIjoiy4ciLCJoYWlyc3AiOiLigIoiLCJoYWxmIjoiwr0iLCJoYW1pbHQiOiLihIsiLCJIQVJEY3kiOiLQqiIsImhhcmRjeSI6ItGKIiwiaGFycmNpciI6IuKliCIsImhhcnIiOiLihpQiLCJoQXJyIjoi4oeUIiwiaGFycnciOiLihq0iLCJIYXQiOiJeIiwiaGJhciI6IuKEjyIsIkhjaXJjIjoixKQiLCJoY2lyYyI6IsSlIiwiaGVhcnRzIjoi4pmlIiwiaGVhcnRzdWl0Ijoi4pmlIiwiaGVsbGlwIjoi4oCmIiwiaGVyY29uIjoi4oq5IiwiaGZyIjoi8J2UpSIsIkhmciI6IuKEjCIsIkhpbGJlcnRTcGFjZSI6IuKEiyIsImhrc2Vhcm93Ijoi4qSlIiwiaGtzd2Fyb3ciOiLipKYiLCJob2FyciI6IuKHvyIsImhvbXRodCI6IuKIuyIsImhvb2tsZWZ0YXJyb3ciOiLihqkiLCJob29rcmlnaHRhcnJvdyI6IuKGqiIsImhvcGYiOiLwnZWZIiwiSG9wZiI6IuKEjSIsImhvcmJhciI6IuKAlSIsIkhvcml6b250YWxMaW5lIjoi4pSAIiwiaHNjciI6IvCdkr0iLCJIc2NyIjoi4oSLIiwiaHNsYXNoIjoi4oSPIiwiSHN0cm9rIjoixKYiLCJoc3Ryb2siOiLEpyIsIkh1bXBEb3duSHVtcCI6IuKJjiIsIkh1bXBFcXVhbCI6IuKJjyIsImh5YnVsbCI6IuKBgyIsImh5cGhlbiI6IuKAkCIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJpYyI6IuKBoyIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiSWN5Ijoi0JgiLCJpY3kiOiLQuCIsIklkb3QiOiLEsCIsIklFY3kiOiLQlSIsImllY3kiOiLQtSIsImlleGNsIjoiwqEiLCJpZmYiOiLih5QiLCJpZnIiOiLwnZSmIiwiSWZyIjoi4oSRIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlpIjoi4oWIIiwiaWlpaW50Ijoi4qiMIiwiaWlpbnQiOiLiiK0iLCJpaW5maW4iOiLip5wiLCJpaW90YSI6IuKEqSIsIklKbGlnIjoixLIiLCJpamxpZyI6IsSzIiwiSW1hY3IiOiLEqiIsImltYWNyIjoixKsiLCJpbWFnZSI6IuKEkSIsIkltYWdpbmFyeUkiOiLihYgiLCJpbWFnbGluZSI6IuKEkCIsImltYWdwYXJ0Ijoi4oSRIiwiaW1hdGgiOiLEsSIsIkltIjoi4oSRIiwiaW1vZiI6IuKKtyIsImltcGVkIjoixrUiLCJJbXBsaWVzIjoi4oeSIiwiaW5jYXJlIjoi4oSFIiwiaW4iOiLiiIgiLCJpbmZpbiI6IuKIniIsImluZmludGllIjoi4qedIiwiaW5vZG90IjoixLEiLCJpbnRjYWwiOiLiiroiLCJpbnQiOiLiiKsiLCJJbnQiOiLiiKwiLCJpbnRlZ2VycyI6IuKEpCIsIkludGVncmFsIjoi4oirIiwiaW50ZXJjYWwiOiLiiroiLCJJbnRlcnNlY3Rpb24iOiLii4IiLCJpbnRsYXJoayI6IuKolyIsImludHByb2QiOiLiqLwiLCJJbnZpc2libGVDb21tYSI6IuKBoyIsIkludmlzaWJsZVRpbWVzIjoi4oGiIiwiSU9jeSI6ItCBIiwiaW9jeSI6ItGRIiwiSW9nb24iOiLEriIsImlvZ29uIjoixK8iLCJJb3BmIjoi8J2VgCIsImlvcGYiOiLwnZWaIiwiSW90YSI6Is6ZIiwiaW90YSI6Is65IiwiaXByb2QiOiLiqLwiLCJpcXVlc3QiOiLCvyIsImlzY3IiOiLwnZK+IiwiSXNjciI6IuKEkCIsImlzaW4iOiLiiIgiLCJpc2luZG90Ijoi4ou1IiwiaXNpbkUiOiLii7kiLCJpc2lucyI6IuKLtCIsImlzaW5zdiI6IuKLsyIsImlzaW52Ijoi4oiIIiwiaXQiOiLigaIiLCJJdGlsZGUiOiLEqCIsIml0aWxkZSI6IsSpIiwiSXVrY3kiOiLQhiIsIml1a2N5Ijoi0ZYiLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJKY2lyYyI6IsS0IiwiamNpcmMiOiLEtSIsIkpjeSI6ItCZIiwiamN5Ijoi0LkiLCJKZnIiOiLwnZSNIiwiamZyIjoi8J2UpyIsImptYXRoIjoiyLciLCJKb3BmIjoi8J2VgSIsImpvcGYiOiLwnZWbIiwiSnNjciI6IvCdkqUiLCJqc2NyIjoi8J2SvyIsIkpzZXJjeSI6ItCIIiwianNlcmN5Ijoi0ZgiLCJKdWtjeSI6ItCEIiwianVrY3kiOiLRlCIsIkthcHBhIjoizpoiLCJrYXBwYSI6Is66Iiwia2FwcGF2Ijoiz7AiLCJLY2VkaWwiOiLEtiIsImtjZWRpbCI6IsS3IiwiS2N5Ijoi0JoiLCJrY3kiOiLQuiIsIktmciI6IvCdlI4iLCJrZnIiOiLwnZSoIiwia2dyZWVuIjoixLgiLCJLSGN5Ijoi0KUiLCJraGN5Ijoi0YUiLCJLSmN5Ijoi0IwiLCJramN5Ijoi0ZwiLCJLb3BmIjoi8J2VgiIsImtvcGYiOiLwnZWcIiwiS3NjciI6IvCdkqYiLCJrc2NyIjoi8J2TgCIsImxBYXJyIjoi4oeaIiwiTGFjdXRlIjoixLkiLCJsYWN1dGUiOiLEuiIsImxhZW1wdHl2Ijoi4qa0IiwibGFncmFuIjoi4oSSIiwiTGFtYmRhIjoizpsiLCJsYW1iZGEiOiLOuyIsImxhbmciOiLin6giLCJMYW5nIjoi4p+qIiwibGFuZ2QiOiLippEiLCJsYW5nbGUiOiLin6giLCJsYXAiOiLiqoUiLCJMYXBsYWNldHJmIjoi4oSSIiwibGFxdW8iOiLCqyIsImxhcnJiIjoi4oekIiwibGFycmJmcyI6IuKknyIsImxhcnIiOiLihpAiLCJMYXJyIjoi4oaeIiwibEFyciI6IuKHkCIsImxhcnJmcyI6IuKknSIsImxhcnJoayI6IuKGqSIsImxhcnJscCI6IuKGqyIsImxhcnJwbCI6IuKkuSIsImxhcnJzaW0iOiLipbMiLCJsYXJydGwiOiLihqIiLCJsYXRhaWwiOiLipJkiLCJsQXRhaWwiOiLipJsiLCJsYXQiOiLiqqsiLCJsYXRlIjoi4qqtIiwibGF0ZXMiOiLiqq3vuIAiLCJsYmFyciI6IuKkjCIsImxCYXJyIjoi4qSOIiwibGJicmsiOiLinbIiLCJsYnJhY2UiOiJ7IiwibGJyYWNrIjoiWyIsImxicmtlIjoi4qaLIiwibGJya3NsZCI6IuKmjyIsImxicmtzbHUiOiLipo0iLCJMY2Fyb24iOiLEvSIsImxjYXJvbiI6IsS+IiwiTGNlZGlsIjoixLsiLCJsY2VkaWwiOiLEvCIsImxjZWlsIjoi4oyIIiwibGN1YiI6InsiLCJMY3kiOiLQmyIsImxjeSI6ItC7IiwibGRjYSI6IuKktiIsImxkcXVvIjoi4oCcIiwibGRxdW9yIjoi4oCeIiwibGRyZGhhciI6IuKlpyIsImxkcnVzaGFyIjoi4qWLIiwibGRzaCI6IuKGsiIsImxlIjoi4omkIiwibEUiOiLiiaYiLCJMZWZ0QW5nbGVCcmFja2V0Ijoi4p+oIiwiTGVmdEFycm93QmFyIjoi4oekIiwibGVmdGFycm93Ijoi4oaQIiwiTGVmdEFycm93Ijoi4oaQIiwiTGVmdGFycm93Ijoi4oeQIiwiTGVmdEFycm93UmlnaHRBcnJvdyI6IuKHhiIsImxlZnRhcnJvd3RhaWwiOiLihqIiLCJMZWZ0Q2VpbGluZyI6IuKMiCIsIkxlZnREb3VibGVCcmFja2V0Ijoi4p+mIiwiTGVmdERvd25UZWVWZWN0b3IiOiLipaEiLCJMZWZ0RG93blZlY3RvckJhciI6IuKlmSIsIkxlZnREb3duVmVjdG9yIjoi4oeDIiwiTGVmdEZsb29yIjoi4oyKIiwibGVmdGhhcnBvb25kb3duIjoi4oa9IiwibGVmdGhhcnBvb251cCI6IuKGvCIsImxlZnRsZWZ0YXJyb3dzIjoi4oeHIiwibGVmdHJpZ2h0YXJyb3ciOiLihpQiLCJMZWZ0UmlnaHRBcnJvdyI6IuKGlCIsIkxlZnRyaWdodGFycm93Ijoi4oeUIiwibGVmdHJpZ2h0YXJyb3dzIjoi4oeGIiwibGVmdHJpZ2h0aGFycG9vbnMiOiLih4siLCJsZWZ0cmlnaHRzcXVpZ2Fycm93Ijoi4oatIiwiTGVmdFJpZ2h0VmVjdG9yIjoi4qWOIiwiTGVmdFRlZUFycm93Ijoi4oakIiwiTGVmdFRlZSI6IuKKoyIsIkxlZnRUZWVWZWN0b3IiOiLipZoiLCJsZWZ0dGhyZWV0aW1lcyI6IuKLiyIsIkxlZnRUcmlhbmdsZUJhciI6IuKnjyIsIkxlZnRUcmlhbmdsZSI6IuKKsiIsIkxlZnRUcmlhbmdsZUVxdWFsIjoi4oq0IiwiTGVmdFVwRG93blZlY3RvciI6IuKlkSIsIkxlZnRVcFRlZVZlY3RvciI6IuKloCIsIkxlZnRVcFZlY3RvckJhciI6IuKlmCIsIkxlZnRVcFZlY3RvciI6IuKGvyIsIkxlZnRWZWN0b3JCYXIiOiLipZIiLCJMZWZ0VmVjdG9yIjoi4oa8IiwibEVnIjoi4qqLIiwibGVnIjoi4ouaIiwibGVxIjoi4omkIiwibGVxcSI6IuKJpiIsImxlcXNsYW50Ijoi4qm9IiwibGVzY2MiOiLiqqgiLCJsZXMiOiLiqb0iLCJsZXNkb3QiOiLiqb8iLCJsZXNkb3RvIjoi4qqBIiwibGVzZG90b3IiOiLiqoMiLCJsZXNnIjoi4oua77iAIiwibGVzZ2VzIjoi4qqTIiwibGVzc2FwcHJveCI6IuKqhSIsImxlc3Nkb3QiOiLii5YiLCJsZXNzZXFndHIiOiLii5oiLCJsZXNzZXFxZ3RyIjoi4qqLIiwiTGVzc0VxdWFsR3JlYXRlciI6IuKLmiIsIkxlc3NGdWxsRXF1YWwiOiLiiaYiLCJMZXNzR3JlYXRlciI6IuKJtiIsImxlc3NndHIiOiLiibYiLCJMZXNzTGVzcyI6IuKqoSIsImxlc3NzaW0iOiLiibIiLCJMZXNzU2xhbnRFcXVhbCI6IuKpvSIsIkxlc3NUaWxkZSI6IuKJsiIsImxmaXNodCI6IuKlvCIsImxmbG9vciI6IuKMiiIsIkxmciI6IvCdlI8iLCJsZnIiOiLwnZSpIiwibGciOiLiibYiLCJsZ0UiOiLiqpEiLCJsSGFyIjoi4qWiIiwibGhhcmQiOiLihr0iLCJsaGFydSI6IuKGvCIsImxoYXJ1bCI6IuKlqiIsImxoYmxrIjoi4paEIiwiTEpjeSI6ItCJIiwibGpjeSI6ItGZIiwibGxhcnIiOiLih4ciLCJsbCI6IuKJqiIsIkxsIjoi4ouYIiwibGxjb3JuZXIiOiLijJ4iLCJMbGVmdGFycm93Ijoi4oeaIiwibGxoYXJkIjoi4qWrIiwibGx0cmkiOiLil7oiLCJMbWlkb3QiOiLEvyIsImxtaWRvdCI6IsWAIiwibG1vdXN0YWNoZSI6IuKOsCIsImxtb3VzdCI6IuKOsCIsImxuYXAiOiLiqokiLCJsbmFwcHJveCI6IuKqiSIsImxuZSI6IuKqhyIsImxuRSI6IuKJqCIsImxuZXEiOiLiqociLCJsbmVxcSI6IuKJqCIsImxuc2ltIjoi4oumIiwibG9hbmciOiLin6wiLCJsb2FyciI6IuKHvSIsImxvYnJrIjoi4p+mIiwibG9uZ2xlZnRhcnJvdyI6IuKftSIsIkxvbmdMZWZ0QXJyb3ciOiLin7UiLCJMb25nbGVmdGFycm93Ijoi4p+4IiwibG9uZ2xlZnRyaWdodGFycm93Ijoi4p+3IiwiTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+3IiwiTG9uZ2xlZnRyaWdodGFycm93Ijoi4p+6IiwibG9uZ21hcHN0byI6IuKfvCIsImxvbmdyaWdodGFycm93Ijoi4p+2IiwiTG9uZ1JpZ2h0QXJyb3ciOiLin7YiLCJMb25ncmlnaHRhcnJvdyI6IuKfuSIsImxvb3BhcnJvd2xlZnQiOiLihqsiLCJsb29wYXJyb3dyaWdodCI6IuKGrCIsImxvcGFyIjoi4qaFIiwiTG9wZiI6IvCdlYMiLCJsb3BmIjoi8J2VnSIsImxvcGx1cyI6IuKorSIsImxvdGltZXMiOiLiqLQiLCJsb3dhc3QiOiLiiJciLCJsb3diYXIiOiJfIiwiTG93ZXJMZWZ0QXJyb3ciOiLihpkiLCJMb3dlclJpZ2h0QXJyb3ciOiLihpgiLCJsb3oiOiLil4oiLCJsb3plbmdlIjoi4peKIiwibG96ZiI6IuKnqyIsImxwYXIiOiIoIiwibHBhcmx0Ijoi4qaTIiwibHJhcnIiOiLih4YiLCJscmNvcm5lciI6IuKMnyIsImxyaGFyIjoi4oeLIiwibHJoYXJkIjoi4qWtIiwibHJtIjoi4oCOIiwibHJ0cmkiOiLiir8iLCJsc2FxdW8iOiLigLkiLCJsc2NyIjoi8J2TgSIsIkxzY3IiOiLihJIiLCJsc2giOiLihrAiLCJMc2giOiLihrAiLCJsc2ltIjoi4omyIiwibHNpbWUiOiLiqo0iLCJsc2ltZyI6IuKqjyIsImxzcWIiOiJbIiwibHNxdW8iOiLigJgiLCJsc3F1b3IiOiLigJoiLCJMc3Ryb2siOiLFgSIsImxzdHJvayI6IsWCIiwibHRjYyI6IuKqpiIsImx0Y2lyIjoi4qm5IiwibHQiOiI8IiwiTFQiOiI8IiwiTHQiOiLiiaoiLCJsdGRvdCI6IuKLliIsImx0aHJlZSI6IuKLiyIsImx0aW1lcyI6IuKLiSIsImx0bGFyciI6IuKltiIsImx0cXVlc3QiOiLiqbsiLCJsdHJpIjoi4peDIiwibHRyaWUiOiLiirQiLCJsdHJpZiI6IuKXgiIsImx0clBhciI6IuKmliIsImx1cmRzaGFyIjoi4qWKIiwibHVydWhhciI6IuKlpiIsImx2ZXJ0bmVxcSI6IuKJqO+4gCIsImx2bkUiOiLiiajvuIAiLCJtYWNyIjoiwq8iLCJtYWxlIjoi4pmCIiwibWFsdCI6IuKcoCIsIm1hbHRlc2UiOiLinKAiLCJNYXAiOiLipIUiLCJtYXAiOiLihqYiLCJtYXBzdG8iOiLihqYiLCJtYXBzdG9kb3duIjoi4oanIiwibWFwc3RvbGVmdCI6IuKGpCIsIm1hcHN0b3VwIjoi4oalIiwibWFya2VyIjoi4pauIiwibWNvbW1hIjoi4qipIiwiTWN5Ijoi0JwiLCJtY3kiOiLQvCIsIm1kYXNoIjoi4oCUIiwibUREb3QiOiLiiLoiLCJtZWFzdXJlZGFuZ2xlIjoi4oihIiwiTWVkaXVtU3BhY2UiOiLigZ8iLCJNZWxsaW50cmYiOiLihLMiLCJNZnIiOiLwnZSQIiwibWZyIjoi8J2UqiIsIm1obyI6IuKEpyIsIm1pY3JvIjoiwrUiLCJtaWRhc3QiOiIqIiwibWlkY2lyIjoi4quwIiwibWlkIjoi4oijIiwibWlkZG90IjoiwrciLCJtaW51c2IiOiLiip8iLCJtaW51cyI6IuKIkiIsIm1pbnVzZCI6IuKIuCIsIm1pbnVzZHUiOiLiqKoiLCJNaW51c1BsdXMiOiLiiJMiLCJtbGNwIjoi4qubIiwibWxkciI6IuKApiIsIm1ucGx1cyI6IuKIkyIsIm1vZGVscyI6IuKKpyIsIk1vcGYiOiLwnZWEIiwibW9wZiI6IvCdlZ4iLCJtcCI6IuKIkyIsIm1zY3IiOiLwnZOCIiwiTXNjciI6IuKEsyIsIm1zdHBvcyI6IuKIviIsIk11IjoizpwiLCJtdSI6Is68IiwibXVsdGltYXAiOiLiirgiLCJtdW1hcCI6IuKKuCIsIm5hYmxhIjoi4oiHIiwiTmFjdXRlIjoixYMiLCJuYWN1dGUiOiLFhCIsIm5hbmciOiLiiKDig5IiLCJuYXAiOiLiiYkiLCJuYXBFIjoi4qmwzLgiLCJuYXBpZCI6IuKJi8y4IiwibmFwb3MiOiLFiSIsIm5hcHByb3giOiLiiYkiLCJuYXR1cmFsIjoi4pmuIiwibmF0dXJhbHMiOiLihJUiLCJuYXR1ciI6IuKZriIsIm5ic3AiOiLCoCIsIm5idW1wIjoi4omOzLgiLCJuYnVtcGUiOiLiiY/MuCIsIm5jYXAiOiLiqYMiLCJOY2Fyb24iOiLFhyIsIm5jYXJvbiI6IsWIIiwiTmNlZGlsIjoixYUiLCJuY2VkaWwiOiLFhiIsIm5jb25nIjoi4omHIiwibmNvbmdkb3QiOiLiqa3MuCIsIm5jdXAiOiLiqYIiLCJOY3kiOiLQnSIsIm5jeSI6ItC9IiwibmRhc2giOiLigJMiLCJuZWFyaGsiOiLipKQiLCJuZWFyciI6IuKGlyIsIm5lQXJyIjoi4oeXIiwibmVhcnJvdyI6IuKGlyIsIm5lIjoi4omgIiwibmVkb3QiOiLiiZDMuCIsIk5lZ2F0aXZlTWVkaXVtU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaWNrU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaW5TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZSI6IuKAiyIsIm5lcXVpdiI6IuKJoiIsIm5lc2VhciI6IuKkqCIsIm5lc2ltIjoi4omCzLgiLCJOZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKJqyIsIk5lc3RlZExlc3NMZXNzIjoi4omqIiwiTmV3TGluZSI6IlxcbiIsIm5leGlzdCI6IuKIhCIsIm5leGlzdHMiOiLiiIQiLCJOZnIiOiLwnZSRIiwibmZyIjoi8J2UqyIsIm5nRSI6IuKJp8y4IiwibmdlIjoi4omxIiwibmdlcSI6IuKJsSIsIm5nZXFxIjoi4omnzLgiLCJuZ2Vxc2xhbnQiOiLiqb7MuCIsIm5nZXMiOiLiqb7MuCIsIm5HZyI6IuKLmcy4IiwibmdzaW0iOiLiibUiLCJuR3QiOiLiiavig5IiLCJuZ3QiOiLiia8iLCJuZ3RyIjoi4omvIiwibkd0diI6IuKJq8y4IiwibmhhcnIiOiLihq4iLCJuaEFyciI6IuKHjiIsIm5ocGFyIjoi4quyIiwibmkiOiLiiIsiLCJuaXMiOiLii7wiLCJuaXNkIjoi4ou6Iiwibml2Ijoi4oiLIiwiTkpjeSI6ItCKIiwibmpjeSI6ItGaIiwibmxhcnIiOiLihpoiLCJubEFyciI6IuKHjSIsIm5sZHIiOiLigKUiLCJubEUiOiLiiabMuCIsIm5sZSI6IuKJsCIsIm5sZWZ0YXJyb3ciOiLihpoiLCJuTGVmdGFycm93Ijoi4oeNIiwibmxlZnRyaWdodGFycm93Ijoi4oauIiwibkxlZnRyaWdodGFycm93Ijoi4oeOIiwibmxlcSI6IuKJsCIsIm5sZXFxIjoi4ommzLgiLCJubGVxc2xhbnQiOiLiqb3MuCIsIm5sZXMiOiLiqb3MuCIsIm5sZXNzIjoi4omuIiwibkxsIjoi4ouYzLgiLCJubHNpbSI6IuKJtCIsIm5MdCI6IuKJquKDkiIsIm5sdCI6IuKJriIsIm5sdHJpIjoi4ouqIiwibmx0cmllIjoi4ousIiwibkx0diI6IuKJqsy4Iiwibm1pZCI6IuKIpCIsIk5vQnJlYWsiOiLigaAiLCJOb25CcmVha2luZ1NwYWNlIjoiwqAiLCJub3BmIjoi8J2VnyIsIk5vcGYiOiLihJUiLCJOb3QiOiLiq6wiLCJub3QiOiLCrCIsIk5vdENvbmdydWVudCI6IuKJoiIsIk5vdEN1cENhcCI6IuKJrSIsIk5vdERvdWJsZVZlcnRpY2FsQmFyIjoi4oimIiwiTm90RWxlbWVudCI6IuKIiSIsIk5vdEVxdWFsIjoi4omgIiwiTm90RXF1YWxUaWxkZSI6IuKJgsy4IiwiTm90RXhpc3RzIjoi4oiEIiwiTm90R3JlYXRlciI6IuKJryIsIk5vdEdyZWF0ZXJFcXVhbCI6IuKJsSIsIk5vdEdyZWF0ZXJGdWxsRXF1YWwiOiLiiafMuCIsIk5vdEdyZWF0ZXJHcmVhdGVyIjoi4omrzLgiLCJOb3RHcmVhdGVyTGVzcyI6IuKJuSIsIk5vdEdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+zLgiLCJOb3RHcmVhdGVyVGlsZGUiOiLiibUiLCJOb3RIdW1wRG93bkh1bXAiOiLiiY7MuCIsIk5vdEh1bXBFcXVhbCI6IuKJj8y4Iiwibm90aW4iOiLiiIkiLCJub3RpbmRvdCI6IuKLtcy4Iiwibm90aW5FIjoi4ou5zLgiLCJub3RpbnZhIjoi4oiJIiwibm90aW52YiI6IuKLtyIsIm5vdGludmMiOiLii7YiLCJOb3RMZWZ0VHJpYW5nbGVCYXIiOiLip4/MuCIsIk5vdExlZnRUcmlhbmdsZSI6IuKLqiIsIk5vdExlZnRUcmlhbmdsZUVxdWFsIjoi4ousIiwiTm90TGVzcyI6IuKJriIsIk5vdExlc3NFcXVhbCI6IuKJsCIsIk5vdExlc3NHcmVhdGVyIjoi4om4IiwiTm90TGVzc0xlc3MiOiLiiarMuCIsIk5vdExlc3NTbGFudEVxdWFsIjoi4qm9zLgiLCJOb3RMZXNzVGlsZGUiOiLiibQiLCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKqosy4IiwiTm90TmVzdGVkTGVzc0xlc3MiOiLiqqHMuCIsIm5vdG5pIjoi4oiMIiwibm90bml2YSI6IuKIjCIsIm5vdG5pdmIiOiLii74iLCJub3RuaXZjIjoi4ou9IiwiTm90UHJlY2VkZXMiOiLiioAiLCJOb3RQcmVjZWRlc0VxdWFsIjoi4qqvzLgiLCJOb3RQcmVjZWRlc1NsYW50RXF1YWwiOiLii6AiLCJOb3RSZXZlcnNlRWxlbWVudCI6IuKIjCIsIk5vdFJpZ2h0VHJpYW5nbGVCYXIiOiLip5DMuCIsIk5vdFJpZ2h0VHJpYW5nbGUiOiLii6siLCJOb3RSaWdodFRyaWFuZ2xlRXF1YWwiOiLii60iLCJOb3RTcXVhcmVTdWJzZXQiOiLiio/MuCIsIk5vdFNxdWFyZVN1YnNldEVxdWFsIjoi4ouiIiwiTm90U3F1YXJlU3VwZXJzZXQiOiLiipDMuCIsIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWwiOiLii6MiLCJOb3RTdWJzZXQiOiLiioLig5IiLCJOb3RTdWJzZXRFcXVhbCI6IuKKiCIsIk5vdFN1Y2NlZWRzIjoi4oqBIiwiTm90U3VjY2VlZHNFcXVhbCI6IuKqsMy4IiwiTm90U3VjY2VlZHNTbGFudEVxdWFsIjoi4ouhIiwiTm90U3VjY2VlZHNUaWxkZSI6IuKJv8y4IiwiTm90U3VwZXJzZXQiOiLiioPig5IiLCJOb3RTdXBlcnNldEVxdWFsIjoi4oqJIiwiTm90VGlsZGUiOiLiiYEiLCJOb3RUaWxkZUVxdWFsIjoi4omEIiwiTm90VGlsZGVGdWxsRXF1YWwiOiLiiYciLCJOb3RUaWxkZVRpbGRlIjoi4omJIiwiTm90VmVydGljYWxCYXIiOiLiiKQiLCJucGFyYWxsZWwiOiLiiKYiLCJucGFyIjoi4oimIiwibnBhcnNsIjoi4qu94oOlIiwibnBhcnQiOiLiiILMuCIsIm5wb2xpbnQiOiLiqJQiLCJucHIiOiLiioAiLCJucHJjdWUiOiLii6AiLCJucHJlYyI6IuKKgCIsIm5wcmVjZXEiOiLiqq/MuCIsIm5wcmUiOiLiqq/MuCIsIm5yYXJyYyI6IuKks8y4IiwibnJhcnIiOiLihpsiLCJuckFyciI6IuKHjyIsIm5yYXJydyI6IuKGncy4IiwibnJpZ2h0YXJyb3ciOiLihpsiLCJuUmlnaHRhcnJvdyI6IuKHjyIsIm5ydHJpIjoi4ourIiwibnJ0cmllIjoi4outIiwibnNjIjoi4oqBIiwibnNjY3VlIjoi4ouhIiwibnNjZSI6IuKqsMy4IiwiTnNjciI6IvCdkqkiLCJuc2NyIjoi8J2TgyIsIm5zaG9ydG1pZCI6IuKIpCIsIm5zaG9ydHBhcmFsbGVsIjoi4oimIiwibnNpbSI6IuKJgSIsIm5zaW1lIjoi4omEIiwibnNpbWVxIjoi4omEIiwibnNtaWQiOiLiiKQiLCJuc3BhciI6IuKIpiIsIm5zcXN1YmUiOiLii6IiLCJuc3FzdXBlIjoi4oujIiwibnN1YiI6IuKKhCIsIm5zdWJFIjoi4quFzLgiLCJuc3ViZSI6IuKKiCIsIm5zdWJzZXQiOiLiioLig5IiLCJuc3Vic2V0ZXEiOiLiiogiLCJuc3Vic2V0ZXFxIjoi4quFzLgiLCJuc3VjYyI6IuKKgSIsIm5zdWNjZXEiOiLiqrDMuCIsIm5zdXAiOiLiioUiLCJuc3VwRSI6IuKrhsy4IiwibnN1cGUiOiLiiokiLCJuc3Vwc2V0Ijoi4oqD4oOSIiwibnN1cHNldGVxIjoi4oqJIiwibnN1cHNldGVxcSI6IuKrhsy4IiwibnRnbCI6IuKJuSIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJudGxnIjoi4om4IiwibnRyaWFuZ2xlbGVmdCI6IuKLqiIsIm50cmlhbmdsZWxlZnRlcSI6IuKLrCIsIm50cmlhbmdsZXJpZ2h0Ijoi4ourIiwibnRyaWFuZ2xlcmlnaHRlcSI6IuKLrSIsIk51Ijoizp0iLCJudSI6Is69IiwibnVtIjoiIyIsIm51bWVybyI6IuKEliIsIm51bXNwIjoi4oCHIiwibnZhcCI6IuKJjeKDkiIsIm52ZGFzaCI6IuKKrCIsIm52RGFzaCI6IuKKrSIsIm5WZGFzaCI6IuKKriIsIm5WRGFzaCI6IuKKryIsIm52Z2UiOiLiiaXig5IiLCJudmd0IjoiPuKDkiIsIm52SGFyciI6IuKkhCIsIm52aW5maW4iOiLip54iLCJudmxBcnIiOiLipIIiLCJudmxlIjoi4omk4oOSIiwibnZsdCI6Ijzig5IiLCJudmx0cmllIjoi4oq04oOSIiwibnZyQXJyIjoi4qSDIiwibnZydHJpZSI6IuKKteKDkiIsIm52c2ltIjoi4oi84oOSIiwibndhcmhrIjoi4qSjIiwibndhcnIiOiLihpYiLCJud0FyciI6IuKHliIsIm53YXJyb3ciOiLihpYiLCJud25lYXIiOiLipKciLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwib2FzdCI6IuKKmyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0Iiwib2NpciI6IuKKmiIsIk9jeSI6ItCeIiwib2N5Ijoi0L4iLCJvZGFzaCI6IuKKnSIsIk9kYmxhYyI6IsWQIiwib2RibGFjIjoixZEiLCJvZGl2Ijoi4qi4Iiwib2RvdCI6IuKKmSIsIm9kc29sZCI6IuKmvCIsIk9FbGlnIjoixZIiLCJvZWxpZyI6IsWTIiwib2ZjaXIiOiLipr8iLCJPZnIiOiLwnZSSIiwib2ZyIjoi8J2UrCIsIm9nb24iOiLLmyIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvZ3QiOiLip4EiLCJvaGJhciI6IuKmtSIsIm9obSI6Is6pIiwib2ludCI6IuKIriIsIm9sYXJyIjoi4oa6Iiwib2xjaXIiOiLipr4iLCJvbGNyb3NzIjoi4qa7Iiwib2xpbmUiOiLigL4iLCJvbHQiOiLip4AiLCJPbWFjciI6IsWMIiwib21hY3IiOiLFjSIsIk9tZWdhIjoizqkiLCJvbWVnYSI6Is+JIiwiT21pY3JvbiI6Is6fIiwib21pY3JvbiI6Is6/Iiwib21pZCI6IuKmtiIsIm9taW51cyI6IuKKliIsIk9vcGYiOiLwnZWGIiwib29wZiI6IvCdlaAiLCJvcGFyIjoi4qa3IiwiT3BlbkN1cmx5RG91YmxlUXVvdGUiOiLigJwiLCJPcGVuQ3VybHlRdW90ZSI6IuKAmCIsIm9wZXJwIjoi4qa5Iiwib3BsdXMiOiLiipUiLCJvcmFyciI6IuKGuyIsIk9yIjoi4qmUIiwib3IiOiLiiKgiLCJvcmQiOiLiqZ0iLCJvcmRlciI6IuKEtCIsIm9yZGVyb2YiOiLihLQiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJvcmlnb2YiOiLiirYiLCJvcm9yIjoi4qmWIiwib3JzbG9wZSI6IuKplyIsIm9ydiI6IuKpmyIsIm9TIjoi4pOIIiwiT3NjciI6IvCdkqoiLCJvc2NyIjoi4oS0IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIm9zb2wiOiLiipgiLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1Iiwib3RpbWVzYXMiOiLiqLYiLCJPdGltZXMiOiLiqLciLCJvdGltZXMiOiLiipciLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJvdmJhciI6IuKMvSIsIk92ZXJCYXIiOiLigL4iLCJPdmVyQnJhY2UiOiLij54iLCJPdmVyQnJhY2tldCI6IuKOtCIsIk92ZXJQYXJlbnRoZXNpcyI6IuKPnCIsInBhcmEiOiLCtiIsInBhcmFsbGVsIjoi4oilIiwicGFyIjoi4oilIiwicGFyc2ltIjoi4quzIiwicGFyc2wiOiLiq70iLCJwYXJ0Ijoi4oiCIiwiUGFydGlhbEQiOiLiiIIiLCJQY3kiOiLQnyIsInBjeSI6ItC/IiwicGVyY250IjoiJSIsInBlcmlvZCI6Ii4iLCJwZXJtaWwiOiLigLAiLCJwZXJwIjoi4oqlIiwicGVydGVuayI6IuKAsSIsIlBmciI6IvCdlJMiLCJwZnIiOiLwnZStIiwiUGhpIjoizqYiLCJwaGkiOiLPhiIsInBoaXYiOiLPlSIsInBobW1hdCI6IuKEsyIsInBob25lIjoi4piOIiwiUGkiOiLOoCIsInBpIjoiz4AiLCJwaXRjaGZvcmsiOiLii5QiLCJwaXYiOiLPliIsInBsYW5jayI6IuKEjyIsInBsYW5ja2giOiLihI4iLCJwbGFua3YiOiLihI8iLCJwbHVzYWNpciI6IuKooyIsInBsdXNiIjoi4oqeIiwicGx1c2NpciI6IuKooiIsInBsdXMiOiIrIiwicGx1c2RvIjoi4oiUIiwicGx1c2R1Ijoi4qilIiwicGx1c2UiOiLiqbIiLCJQbHVzTWludXMiOiLCsSIsInBsdXNtbiI6IsKxIiwicGx1c3NpbSI6IuKopiIsInBsdXN0d28iOiLiqKciLCJwbSI6IsKxIiwiUG9pbmNhcmVwbGFuZSI6IuKEjCIsInBvaW50aW50Ijoi4qiVIiwicG9wZiI6IvCdlaEiLCJQb3BmIjoi4oSZIiwicG91bmQiOiLCoyIsInByYXAiOiLiqrciLCJQciI6IuKquyIsInByIjoi4om6IiwicHJjdWUiOiLiibwiLCJwcmVjYXBwcm94Ijoi4qq3IiwicHJlYyI6IuKJuiIsInByZWNjdXJseWVxIjoi4om8IiwiUHJlY2VkZXMiOiLiiboiLCJQcmVjZWRlc0VxdWFsIjoi4qqvIiwiUHJlY2VkZXNTbGFudEVxdWFsIjoi4om8IiwiUHJlY2VkZXNUaWxkZSI6IuKJviIsInByZWNlcSI6IuKqryIsInByZWNuYXBwcm94Ijoi4qq5IiwicHJlY25lcXEiOiLiqrUiLCJwcmVjbnNpbSI6IuKLqCIsInByZSI6IuKqryIsInByRSI6IuKqsyIsInByZWNzaW0iOiLiib4iLCJwcmltZSI6IuKAsiIsIlByaW1lIjoi4oCzIiwicHJpbWVzIjoi4oSZIiwicHJuYXAiOiLiqrkiLCJwcm5FIjoi4qq1IiwicHJuc2ltIjoi4ouoIiwicHJvZCI6IuKIjyIsIlByb2R1Y3QiOiLiiI8iLCJwcm9mYWxhciI6IuKMriIsInByb2ZsaW5lIjoi4oySIiwicHJvZnN1cmYiOiLijJMiLCJwcm9wIjoi4oidIiwiUHJvcG9ydGlvbmFsIjoi4oidIiwiUHJvcG9ydGlvbiI6IuKItyIsInByb3B0byI6IuKInSIsInByc2ltIjoi4om+IiwicHJ1cmVsIjoi4oqwIiwiUHNjciI6IvCdkqsiLCJwc2NyIjoi8J2ThSIsIlBzaSI6Is6oIiwicHNpIjoiz4giLCJwdW5jc3AiOiLigIgiLCJRZnIiOiLwnZSUIiwicWZyIjoi8J2UriIsInFpbnQiOiLiqIwiLCJxb3BmIjoi8J2VoiIsIlFvcGYiOiLihJoiLCJxcHJpbWUiOiLigZciLCJRc2NyIjoi8J2SrCIsInFzY3IiOiLwnZOGIiwicXVhdGVybmlvbnMiOiLihI0iLCJxdWF0aW50Ijoi4qiWIiwicXVlc3QiOiI/IiwicXVlc3RlcSI6IuKJnyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwickFhcnIiOiLih5siLCJyYWNlIjoi4oi9zLEiLCJSYWN1dGUiOiLFlCIsInJhY3V0ZSI6IsWVIiwicmFkaWMiOiLiiJoiLCJyYWVtcHR5diI6IuKmsyIsInJhbmciOiLin6kiLCJSYW5nIjoi4p+rIiwicmFuZ2QiOiLippIiLCJyYW5nZSI6IuKmpSIsInJhbmdsZSI6IuKfqSIsInJhcXVvIjoiwrsiLCJyYXJyYXAiOiLipbUiLCJyYXJyYiI6IuKHpSIsInJhcnJiZnMiOiLipKAiLCJyYXJyYyI6IuKksyIsInJhcnIiOiLihpIiLCJSYXJyIjoi4oagIiwickFyciI6IuKHkiIsInJhcnJmcyI6IuKkniIsInJhcnJoayI6IuKGqiIsInJhcnJscCI6IuKGrCIsInJhcnJwbCI6IuKlhSIsInJhcnJzaW0iOiLipbQiLCJSYXJydGwiOiLipJYiLCJyYXJydGwiOiLihqMiLCJyYXJydyI6IuKGnSIsInJhdGFpbCI6IuKkmiIsInJBdGFpbCI6IuKknCIsInJhdGlvIjoi4oi2IiwicmF0aW9uYWxzIjoi4oSaIiwicmJhcnIiOiLipI0iLCJyQmFyciI6IuKkjyIsIlJCYXJyIjoi4qSQIiwicmJicmsiOiLinbMiLCJyYnJhY2UiOiJ9IiwicmJyYWNrIjoiXSIsInJicmtlIjoi4qaMIiwicmJya3NsZCI6IuKmjiIsInJicmtzbHUiOiLippAiLCJSY2Fyb24iOiLFmCIsInJjYXJvbiI6IsWZIiwiUmNlZGlsIjoixZYiLCJyY2VkaWwiOiLFlyIsInJjZWlsIjoi4oyJIiwicmN1YiI6In0iLCJSY3kiOiLQoCIsInJjeSI6ItGAIiwicmRjYSI6IuKktyIsInJkbGRoYXIiOiLipakiLCJyZHF1byI6IuKAnSIsInJkcXVvciI6IuKAnSIsInJkc2giOiLihrMiLCJyZWFsIjoi4oScIiwicmVhbGluZSI6IuKEmyIsInJlYWxwYXJ0Ijoi4oScIiwicmVhbHMiOiLihJ0iLCJSZSI6IuKEnCIsInJlY3QiOiLilq0iLCJyZWciOiLCriIsIlJFRyI6IsKuIiwiUmV2ZXJzZUVsZW1lbnQiOiLiiIsiLCJSZXZlcnNlRXF1aWxpYnJpdW0iOiLih4siLCJSZXZlcnNlVXBFcXVpbGlicml1bSI6IuKlryIsInJmaXNodCI6IuKlvSIsInJmbG9vciI6IuKMiyIsInJmciI6IvCdlK8iLCJSZnIiOiLihJwiLCJySGFyIjoi4qWkIiwicmhhcmQiOiLih4EiLCJyaGFydSI6IuKHgCIsInJoYXJ1bCI6IuKlrCIsIlJobyI6Is6hIiwicmhvIjoiz4EiLCJyaG92Ijoiz7EiLCJSaWdodEFuZ2xlQnJhY2tldCI6IuKfqSIsIlJpZ2h0QXJyb3dCYXIiOiLih6UiLCJyaWdodGFycm93Ijoi4oaSIiwiUmlnaHRBcnJvdyI6IuKGkiIsIlJpZ2h0YXJyb3ciOiLih5IiLCJSaWdodEFycm93TGVmdEFycm93Ijoi4oeEIiwicmlnaHRhcnJvd3RhaWwiOiLihqMiLCJSaWdodENlaWxpbmciOiLijIkiLCJSaWdodERvdWJsZUJyYWNrZXQiOiLin6ciLCJSaWdodERvd25UZWVWZWN0b3IiOiLipZ0iLCJSaWdodERvd25WZWN0b3JCYXIiOiLipZUiLCJSaWdodERvd25WZWN0b3IiOiLih4IiLCJSaWdodEZsb29yIjoi4oyLIiwicmlnaHRoYXJwb29uZG93biI6IuKHgSIsInJpZ2h0aGFycG9vbnVwIjoi4oeAIiwicmlnaHRsZWZ0YXJyb3dzIjoi4oeEIiwicmlnaHRsZWZ0aGFycG9vbnMiOiLih4wiLCJyaWdodHJpZ2h0YXJyb3dzIjoi4oeJIiwicmlnaHRzcXVpZ2Fycm93Ijoi4oadIiwiUmlnaHRUZWVBcnJvdyI6IuKGpiIsIlJpZ2h0VGVlIjoi4oqiIiwiUmlnaHRUZWVWZWN0b3IiOiLipZsiLCJyaWdodHRocmVldGltZXMiOiLii4wiLCJSaWdodFRyaWFuZ2xlQmFyIjoi4qeQIiwiUmlnaHRUcmlhbmdsZSI6IuKKsyIsIlJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKKtSIsIlJpZ2h0VXBEb3duVmVjdG9yIjoi4qWPIiwiUmlnaHRVcFRlZVZlY3RvciI6IuKlnCIsIlJpZ2h0VXBWZWN0b3JCYXIiOiLipZQiLCJSaWdodFVwVmVjdG9yIjoi4oa+IiwiUmlnaHRWZWN0b3JCYXIiOiLipZMiLCJSaWdodFZlY3RvciI6IuKHgCIsInJpbmciOiLLmiIsInJpc2luZ2RvdHNlcSI6IuKJkyIsInJsYXJyIjoi4oeEIiwicmxoYXIiOiLih4wiLCJybG0iOiLigI8iLCJybW91c3RhY2hlIjoi4o6xIiwicm1vdXN0Ijoi4o6xIiwicm5taWQiOiLiq64iLCJyb2FuZyI6IuKfrSIsInJvYXJyIjoi4oe+Iiwicm9icmsiOiLin6ciLCJyb3BhciI6IuKmhiIsInJvcGYiOiLwnZWjIiwiUm9wZiI6IuKEnSIsInJvcGx1cyI6IuKoriIsInJvdGltZXMiOiLiqLUiLCJSb3VuZEltcGxpZXMiOiLipbAiLCJycGFyIjoiKSIsInJwYXJndCI6IuKmlCIsInJwcG9saW50Ijoi4qiSIiwicnJhcnIiOiLih4kiLCJScmlnaHRhcnJvdyI6IuKHmyIsInJzYXF1byI6IuKAuiIsInJzY3IiOiLwnZOHIiwiUnNjciI6IuKEmyIsInJzaCI6IuKGsSIsIlJzaCI6IuKGsSIsInJzcWIiOiJdIiwicnNxdW8iOiLigJkiLCJyc3F1b3IiOiLigJkiLCJydGhyZWUiOiLii4wiLCJydGltZXMiOiLii4oiLCJydHJpIjoi4pa5IiwicnRyaWUiOiLiirUiLCJydHJpZiI6IuKWuCIsInJ0cmlsdHJpIjoi4qeOIiwiUnVsZURlbGF5ZWQiOiLip7QiLCJydWx1aGFyIjoi4qWoIiwicngiOiLihJ4iLCJTYWN1dGUiOiLFmiIsInNhY3V0ZSI6IsWbIiwic2JxdW8iOiLigJoiLCJzY2FwIjoi4qq4IiwiU2Nhcm9uIjoixaAiLCJzY2Fyb24iOiLFoSIsIlNjIjoi4qq8Iiwic2MiOiLiibsiLCJzY2N1ZSI6IuKJvSIsInNjZSI6IuKqsCIsInNjRSI6IuKqtCIsIlNjZWRpbCI6IsWeIiwic2NlZGlsIjoixZ8iLCJTY2lyYyI6IsWcIiwic2NpcmMiOiLFnSIsInNjbmFwIjoi4qq6Iiwic2NuRSI6IuKqtiIsInNjbnNpbSI6IuKLqSIsInNjcG9saW50Ijoi4qiTIiwic2NzaW0iOiLiib8iLCJTY3kiOiLQoSIsInNjeSI6ItGBIiwic2RvdGIiOiLiiqEiLCJzZG90Ijoi4ouFIiwic2RvdGUiOiLiqaYiLCJzZWFyaGsiOiLipKUiLCJzZWFyciI6IuKGmCIsInNlQXJyIjoi4oeYIiwic2VhcnJvdyI6IuKGmCIsInNlY3QiOiLCpyIsInNlbWkiOiI7Iiwic2Vzd2FyIjoi4qSpIiwic2V0bWludXMiOiLiiJYiLCJzZXRtbiI6IuKIliIsInNleHQiOiLinLYiLCJTZnIiOiLwnZSWIiwic2ZyIjoi8J2UsCIsInNmcm93biI6IuKMoiIsInNoYXJwIjoi4pmvIiwiU0hDSGN5Ijoi0KkiLCJzaGNoY3kiOiLRiSIsIlNIY3kiOiLQqCIsInNoY3kiOiLRiCIsIlNob3J0RG93bkFycm93Ijoi4oaTIiwiU2hvcnRMZWZ0QXJyb3ciOiLihpAiLCJzaG9ydG1pZCI6IuKIoyIsInNob3J0cGFyYWxsZWwiOiLiiKUiLCJTaG9ydFJpZ2h0QXJyb3ciOiLihpIiLCJTaG9ydFVwQXJyb3ciOiLihpEiLCJzaHkiOiLCrSIsIlNpZ21hIjoizqMiLCJzaWdtYSI6Is+DIiwic2lnbWFmIjoiz4IiLCJzaWdtYXYiOiLPgiIsInNpbSI6IuKIvCIsInNpbWRvdCI6IuKpqiIsInNpbWUiOiLiiYMiLCJzaW1lcSI6IuKJgyIsInNpbWciOiLiqp4iLCJzaW1nRSI6IuKqoCIsInNpbWwiOiLiqp0iLCJzaW1sRSI6IuKqnyIsInNpbW5lIjoi4omGIiwic2ltcGx1cyI6IuKopCIsInNpbXJhcnIiOiLipbIiLCJzbGFyciI6IuKGkCIsIlNtYWxsQ2lyY2xlIjoi4oiYIiwic21hbGxzZXRtaW51cyI6IuKIliIsInNtYXNocCI6IuKosyIsInNtZXBhcnNsIjoi4qekIiwic21pZCI6IuKIoyIsInNtaWxlIjoi4oyjIiwic210Ijoi4qqqIiwic210ZSI6IuKqrCIsInNtdGVzIjoi4qqs77iAIiwiU09GVGN5Ijoi0KwiLCJzb2Z0Y3kiOiLRjCIsInNvbGJhciI6IuKMvyIsInNvbGIiOiLip4QiLCJzb2wiOiIvIiwiU29wZiI6IvCdlYoiLCJzb3BmIjoi8J2VpCIsInNwYWRlcyI6IuKZoCIsInNwYWRlc3VpdCI6IuKZoCIsInNwYXIiOiLiiKUiLCJzcWNhcCI6IuKKkyIsInNxY2FwcyI6IuKKk++4gCIsInNxY3VwIjoi4oqUIiwic3FjdXBzIjoi4oqU77iAIiwiU3FydCI6IuKImiIsInNxc3ViIjoi4oqPIiwic3FzdWJlIjoi4oqRIiwic3FzdWJzZXQiOiLiio8iLCJzcXN1YnNldGVxIjoi4oqRIiwic3FzdXAiOiLiipAiLCJzcXN1cGUiOiLiipIiLCJzcXN1cHNldCI6IuKKkCIsInNxc3Vwc2V0ZXEiOiLiipIiLCJzcXVhcmUiOiLilqEiLCJTcXVhcmUiOiLilqEiLCJTcXVhcmVJbnRlcnNlY3Rpb24iOiLiipMiLCJTcXVhcmVTdWJzZXQiOiLiio8iLCJTcXVhcmVTdWJzZXRFcXVhbCI6IuKKkSIsIlNxdWFyZVN1cGVyc2V0Ijoi4oqQIiwiU3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKKkiIsIlNxdWFyZVVuaW9uIjoi4oqUIiwic3F1YXJmIjoi4paqIiwic3F1Ijoi4pahIiwic3F1ZiI6IuKWqiIsInNyYXJyIjoi4oaSIiwiU3NjciI6IvCdkq4iLCJzc2NyIjoi8J2TiCIsInNzZXRtbiI6IuKIliIsInNzbWlsZSI6IuKMoyIsInNzdGFyZiI6IuKLhiIsIlN0YXIiOiLii4YiLCJzdGFyIjoi4piGIiwic3RhcmYiOiLimIUiLCJzdHJhaWdodGVwc2lsb24iOiLPtSIsInN0cmFpZ2h0cGhpIjoiz5UiLCJzdHJucyI6IsKvIiwic3ViIjoi4oqCIiwiU3ViIjoi4ouQIiwic3ViZG90Ijoi4qq9Iiwic3ViRSI6IuKrhSIsInN1YmUiOiLiioYiLCJzdWJlZG90Ijoi4quDIiwic3VibXVsdCI6IuKrgSIsInN1Ym5FIjoi4quLIiwic3VibmUiOiLiiooiLCJzdWJwbHVzIjoi4qq/Iiwic3VicmFyciI6IuKluSIsInN1YnNldCI6IuKKgiIsIlN1YnNldCI6IuKLkCIsInN1YnNldGVxIjoi4oqGIiwic3Vic2V0ZXFxIjoi4quFIiwiU3Vic2V0RXF1YWwiOiLiioYiLCJzdWJzZXRuZXEiOiLiiooiLCJzdWJzZXRuZXFxIjoi4quLIiwic3Vic2ltIjoi4quHIiwic3Vic3ViIjoi4quVIiwic3Vic3VwIjoi4quTIiwic3VjY2FwcHJveCI6IuKquCIsInN1Y2MiOiLiibsiLCJzdWNjY3VybHllcSI6IuKJvSIsIlN1Y2NlZWRzIjoi4om7IiwiU3VjY2VlZHNFcXVhbCI6IuKqsCIsIlN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKJvSIsIlN1Y2NlZWRzVGlsZGUiOiLiib8iLCJzdWNjZXEiOiLiqrAiLCJzdWNjbmFwcHJveCI6IuKquiIsInN1Y2NuZXFxIjoi4qq2Iiwic3VjY25zaW0iOiLii6kiLCJzdWNjc2ltIjoi4om/IiwiU3VjaFRoYXQiOiLiiIsiLCJzdW0iOiLiiJEiLCJTdW0iOiLiiJEiLCJzdW5nIjoi4pmqIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3VwIjoi4oqDIiwiU3VwIjoi4ouRIiwic3VwZG90Ijoi4qq+Iiwic3VwZHN1YiI6IuKrmCIsInN1cEUiOiLiq4YiLCJzdXBlIjoi4oqHIiwic3VwZWRvdCI6IuKrhCIsIlN1cGVyc2V0Ijoi4oqDIiwiU3VwZXJzZXRFcXVhbCI6IuKKhyIsInN1cGhzb2wiOiLin4kiLCJzdXBoc3ViIjoi4quXIiwic3VwbGFyciI6IuKluyIsInN1cG11bHQiOiLiq4IiLCJzdXBuRSI6IuKrjCIsInN1cG5lIjoi4oqLIiwic3VwcGx1cyI6IuKrgCIsInN1cHNldCI6IuKKgyIsIlN1cHNldCI6IuKLkSIsInN1cHNldGVxIjoi4oqHIiwic3Vwc2V0ZXFxIjoi4quGIiwic3Vwc2V0bmVxIjoi4oqLIiwic3Vwc2V0bmVxcSI6IuKrjCIsInN1cHNpbSI6IuKriCIsInN1cHN1YiI6IuKrlCIsInN1cHN1cCI6IuKrliIsInN3YXJoayI6IuKkpiIsInN3YXJyIjoi4oaZIiwic3dBcnIiOiLih5kiLCJzd2Fycm93Ijoi4oaZIiwic3dud2FyIjoi4qSqIiwic3psaWciOiLDnyIsIlRhYiI6IlxcdCIsInRhcmdldCI6IuKMliIsIlRhdSI6Is6kIiwidGF1Ijoiz4QiLCJ0YnJrIjoi4o60IiwiVGNhcm9uIjoixaQiLCJ0Y2Fyb24iOiLFpSIsIlRjZWRpbCI6IsWiIiwidGNlZGlsIjoixaMiLCJUY3kiOiLQoiIsInRjeSI6ItGCIiwidGRvdCI6IuKDmyIsInRlbHJlYyI6IuKMlSIsIlRmciI6IvCdlJciLCJ0ZnIiOiLwnZSxIiwidGhlcmU0Ijoi4oi0IiwidGhlcmVmb3JlIjoi4oi0IiwiVGhlcmVmb3JlIjoi4oi0IiwiVGhldGEiOiLOmCIsInRoZXRhIjoizrgiLCJ0aGV0YXN5bSI6Is+RIiwidGhldGF2Ijoiz5EiLCJ0aGlja2FwcHJveCI6IuKJiCIsInRoaWNrc2ltIjoi4oi8IiwiVGhpY2tTcGFjZSI6IuKBn+KAiiIsIlRoaW5TcGFjZSI6IuKAiSIsInRoaW5zcCI6IuKAiSIsInRoa2FwIjoi4omIIiwidGhrc2ltIjoi4oi8IiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aWxkZSI6IsucIiwiVGlsZGUiOiLiiLwiLCJUaWxkZUVxdWFsIjoi4omDIiwiVGlsZGVGdWxsRXF1YWwiOiLiiYUiLCJUaWxkZVRpbGRlIjoi4omIIiwidGltZXNiYXIiOiLiqLEiLCJ0aW1lc2IiOiLiiqAiLCJ0aW1lcyI6IsOXIiwidGltZXNkIjoi4qiwIiwidGludCI6IuKIrSIsInRvZWEiOiLipKgiLCJ0b3Bib3QiOiLijLYiLCJ0b3BjaXIiOiLiq7EiLCJ0b3AiOiLiiqQiLCJUb3BmIjoi8J2ViyIsInRvcGYiOiLwnZWlIiwidG9wZm9yayI6IuKrmiIsInRvc2EiOiLipKkiLCJ0cHJpbWUiOiLigLQiLCJ0cmFkZSI6IuKEoiIsIlRSQURFIjoi4oSiIiwidHJpYW5nbGUiOiLilrUiLCJ0cmlhbmdsZWRvd24iOiLilr8iLCJ0cmlhbmdsZWxlZnQiOiLil4MiLCJ0cmlhbmdsZWxlZnRlcSI6IuKKtCIsInRyaWFuZ2xlcSI6IuKJnCIsInRyaWFuZ2xlcmlnaHQiOiLilrkiLCJ0cmlhbmdsZXJpZ2h0ZXEiOiLiirUiLCJ0cmlkb3QiOiLil6wiLCJ0cmllIjoi4omcIiwidHJpbWludXMiOiLiqLoiLCJUcmlwbGVEb3QiOiLig5siLCJ0cmlwbHVzIjoi4qi5IiwidHJpc2IiOiLip40iLCJ0cml0aW1lIjoi4qi7IiwidHJwZXppdW0iOiLij6IiLCJUc2NyIjoi8J2SryIsInRzY3IiOiLwnZOJIiwiVFNjeSI6ItCmIiwidHNjeSI6ItGGIiwiVFNIY3kiOiLQiyIsInRzaGN5Ijoi0ZsiLCJUc3Ryb2siOiLFpiIsInRzdHJvayI6IsWnIiwidHdpeHQiOiLiiawiLCJ0d29oZWFkbGVmdGFycm93Ijoi4oaeIiwidHdvaGVhZHJpZ2h0YXJyb3ciOiLihqAiLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwidWFyciI6IuKGkSIsIlVhcnIiOiLihp8iLCJ1QXJyIjoi4oeRIiwiVWFycm9jaXIiOiLipYkiLCJVYnJjeSI6ItCOIiwidWJyY3kiOiLRniIsIlVicmV2ZSI6IsWsIiwidWJyZXZlIjoixa0iLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVjeSI6ItCjIiwidWN5Ijoi0YMiLCJ1ZGFyciI6IuKHhSIsIlVkYmxhYyI6IsWwIiwidWRibGFjIjoixbEiLCJ1ZGhhciI6IuKlriIsInVmaXNodCI6IuKlviIsIlVmciI6IvCdlJgiLCJ1ZnIiOiLwnZSyIiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVIYXIiOiLipaMiLCJ1aGFybCI6IuKGvyIsInVoYXJyIjoi4oa+IiwidWhibGsiOiLiloAiLCJ1bGNvcm4iOiLijJwiLCJ1bGNvcm5lciI6IuKMnCIsInVsY3JvcCI6IuKMjyIsInVsdHJpIjoi4pe4IiwiVW1hY3IiOiLFqiIsInVtYWNyIjoixasiLCJ1bWwiOiLCqCIsIlVuZGVyQmFyIjoiXyIsIlVuZGVyQnJhY2UiOiLij58iLCJVbmRlckJyYWNrZXQiOiLijrUiLCJVbmRlclBhcmVudGhlc2lzIjoi4o+dIiwiVW5pb24iOiLii4MiLCJVbmlvblBsdXMiOiLiio4iLCJVb2dvbiI6IsWyIiwidW9nb24iOiLFsyIsIlVvcGYiOiLwnZWMIiwidW9wZiI6IvCdlaYiLCJVcEFycm93QmFyIjoi4qSSIiwidXBhcnJvdyI6IuKGkSIsIlVwQXJyb3ciOiLihpEiLCJVcGFycm93Ijoi4oeRIiwiVXBBcnJvd0Rvd25BcnJvdyI6IuKHhSIsInVwZG93bmFycm93Ijoi4oaVIiwiVXBEb3duQXJyb3ciOiLihpUiLCJVcGRvd25hcnJvdyI6IuKHlSIsIlVwRXF1aWxpYnJpdW0iOiLipa4iLCJ1cGhhcnBvb25sZWZ0Ijoi4oa/IiwidXBoYXJwb29ucmlnaHQiOiLihr4iLCJ1cGx1cyI6IuKKjiIsIlVwcGVyTGVmdEFycm93Ijoi4oaWIiwiVXBwZXJSaWdodEFycm93Ijoi4oaXIiwidXBzaSI6Is+FIiwiVXBzaSI6Is+SIiwidXBzaWgiOiLPkiIsIlVwc2lsb24iOiLOpSIsInVwc2lsb24iOiLPhSIsIlVwVGVlQXJyb3ciOiLihqUiLCJVcFRlZSI6IuKKpSIsInVwdXBhcnJvd3MiOiLih4giLCJ1cmNvcm4iOiLijJ0iLCJ1cmNvcm5lciI6IuKMnSIsInVyY3JvcCI6IuKMjiIsIlVyaW5nIjoixa4iLCJ1cmluZyI6IsWvIiwidXJ0cmkiOiLil7kiLCJVc2NyIjoi8J2SsCIsInVzY3IiOiLwnZOKIiwidXRkb3QiOiLii7AiLCJVdGlsZGUiOiLFqCIsInV0aWxkZSI6IsWpIiwidXRyaSI6IuKWtSIsInV0cmlmIjoi4pa0IiwidXVhcnIiOiLih4giLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJ1d2FuZ2xlIjoi4qanIiwidmFuZ3J0Ijoi4qacIiwidmFyZXBzaWxvbiI6Is+1IiwidmFya2FwcGEiOiLPsCIsInZhcm5vdGhpbmciOiLiiIUiLCJ2YXJwaGkiOiLPlSIsInZhcnBpIjoiz5YiLCJ2YXJwcm9wdG8iOiLiiJ0iLCJ2YXJyIjoi4oaVIiwidkFyciI6IuKHlSIsInZhcnJobyI6Is+xIiwidmFyc2lnbWEiOiLPgiIsInZhcnN1YnNldG5lcSI6IuKKiu+4gCIsInZhcnN1YnNldG5lcXEiOiLiq4vvuIAiLCJ2YXJzdXBzZXRuZXEiOiLiiovvuIAiLCJ2YXJzdXBzZXRuZXFxIjoi4quM77iAIiwidmFydGhldGEiOiLPkSIsInZhcnRyaWFuZ2xlbGVmdCI6IuKKsiIsInZhcnRyaWFuZ2xlcmlnaHQiOiLiirMiLCJ2QmFyIjoi4quoIiwiVmJhciI6IuKrqyIsInZCYXJ2Ijoi4qupIiwiVmN5Ijoi0JIiLCJ2Y3kiOiLQsiIsInZkYXNoIjoi4oqiIiwidkRhc2giOiLiiqgiLCJWZGFzaCI6IuKKqSIsIlZEYXNoIjoi4oqrIiwiVmRhc2hsIjoi4qumIiwidmVlYmFyIjoi4oq7IiwidmVlIjoi4oioIiwiVmVlIjoi4ouBIiwidmVlZXEiOiLiiZoiLCJ2ZWxsaXAiOiLii64iLCJ2ZXJiYXIiOiJ8IiwiVmVyYmFyIjoi4oCWIiwidmVydCI6InwiLCJWZXJ0Ijoi4oCWIiwiVmVydGljYWxCYXIiOiLiiKMiLCJWZXJ0aWNhbExpbmUiOiJ8IiwiVmVydGljYWxTZXBhcmF0b3IiOiLinZgiLCJWZXJ0aWNhbFRpbGRlIjoi4omAIiwiVmVyeVRoaW5TcGFjZSI6IuKAiiIsIlZmciI6IvCdlJkiLCJ2ZnIiOiLwnZSzIiwidmx0cmkiOiLiirIiLCJ2bnN1YiI6IuKKguKDkiIsInZuc3VwIjoi4oqD4oOSIiwiVm9wZiI6IvCdlY0iLCJ2b3BmIjoi8J2VpyIsInZwcm9wIjoi4oidIiwidnJ0cmkiOiLiirMiLCJWc2NyIjoi8J2SsSIsInZzY3IiOiLwnZOLIiwidnN1Ym5FIjoi4quL77iAIiwidnN1Ym5lIjoi4oqK77iAIiwidnN1cG5FIjoi4quM77iAIiwidnN1cG5lIjoi4oqL77iAIiwiVnZkYXNoIjoi4oqqIiwidnppZ3phZyI6IuKmmiIsIldjaXJjIjoixbQiLCJ3Y2lyYyI6IsW1Iiwid2VkYmFyIjoi4qmfIiwid2VkZ2UiOiLiiKciLCJXZWRnZSI6IuKLgCIsIndlZGdlcSI6IuKJmSIsIndlaWVycCI6IuKEmCIsIldmciI6IvCdlJoiLCJ3ZnIiOiLwnZS0IiwiV29wZiI6IvCdlY4iLCJ3b3BmIjoi8J2VqCIsIndwIjoi4oSYIiwid3IiOiLiiYAiLCJ3cmVhdGgiOiLiiYAiLCJXc2NyIjoi8J2SsiIsIndzY3IiOiLwnZOMIiwieGNhcCI6IuKLgiIsInhjaXJjIjoi4pevIiwieGN1cCI6IuKLgyIsInhkdHJpIjoi4pa9IiwiWGZyIjoi8J2UmyIsInhmciI6IvCdlLUiLCJ4aGFyciI6IuKftyIsInhoQXJyIjoi4p+6IiwiWGkiOiLOniIsInhpIjoizr4iLCJ4bGFyciI6IuKftSIsInhsQXJyIjoi4p+4IiwieG1hcCI6IuKfvCIsInhuaXMiOiLii7siLCJ4b2RvdCI6IuKogCIsIlhvcGYiOiLwnZWPIiwieG9wZiI6IvCdlakiLCJ4b3BsdXMiOiLiqIEiLCJ4b3RpbWUiOiLiqIIiLCJ4cmFyciI6IuKftiIsInhyQXJyIjoi4p+5IiwiWHNjciI6IvCdkrMiLCJ4c2NyIjoi8J2TjSIsInhzcWN1cCI6IuKohiIsInh1cGx1cyI6IuKohCIsInh1dHJpIjoi4pazIiwieHZlZSI6IuKLgSIsInh3ZWRnZSI6IuKLgCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJZQWN5Ijoi0K8iLCJ5YWN5Ijoi0Y8iLCJZY2lyYyI6IsW2IiwieWNpcmMiOiLFtyIsIlljeSI6ItCrIiwieWN5Ijoi0YsiLCJ5ZW4iOiLCpSIsIllmciI6IvCdlJwiLCJ5ZnIiOiLwnZS2IiwiWUljeSI6ItCHIiwieWljeSI6ItGXIiwiWW9wZiI6IvCdlZAiLCJ5b3BmIjoi8J2VqiIsIllzY3IiOiLwnZK0IiwieXNjciI6IvCdk44iLCJZVWN5Ijoi0K4iLCJ5dWN5Ijoi0Y4iLCJ5dW1sIjoiw78iLCJZdW1sIjoixbgiLCJaYWN1dGUiOiLFuSIsInphY3V0ZSI6IsW6IiwiWmNhcm9uIjoixb0iLCJ6Y2Fyb24iOiLFviIsIlpjeSI6ItCXIiwiemN5Ijoi0LciLCJaZG90IjoixbsiLCJ6ZG90IjoixbwiLCJ6ZWV0cmYiOiLihKgiLCJaZXJvV2lkdGhTcGFjZSI6IuKAiyIsIlpldGEiOiLOliIsInpldGEiOiLOtiIsInpmciI6IvCdlLciLCJaZnIiOiLihKgiLCJaSGN5Ijoi0JYiLCJ6aGN5Ijoi0LYiLCJ6aWdyYXJyIjoi4oedIiwiem9wZiI6IvCdlasiLCJab3BmIjoi4oSkIiwiWnNjciI6IvCdkrUiLCJ6c2NyIjoi8J2TjyIsInp3aiI6IuKAjSIsInp3bmoiOiLigIwifScpfSxmdW5jdGlvbih1KXt1LmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJicnZiYXIiOiLCpiIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJjZWRpbCI6IsK4IiwiY2VudCI6IsKiIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY3VycmVuIjoiwqQiLCJkZWciOiLCsCIsImRpdmlkZSI6IsO3IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJmcmFjMTIiOiLCvSIsImZyYWMxNCI6IsK8IiwiZnJhYzM0Ijoiwr4iLCJndCI6Ij4iLCJHVCI6Ij4iLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJpZXhjbCI6IsKhIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlxdWVzdCI6IsK/IiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwibGFxdW8iOiLCqyIsImx0IjoiPCIsIkxUIjoiPCIsIm1hY3IiOiLCryIsIm1pY3JvIjoiwrUiLCJtaWRkb3QiOiLCtyIsIm5ic3AiOiLCoCIsIm5vdCI6IsKsIiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4IiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsInBhcmEiOiLCtiIsInBsdXNtbiI6IsKxIiwicG91bmQiOiLCoyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwicmFxdW8iOiLCuyIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJzZWN0IjoiwqciLCJzaHkiOiLCrSIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN6bGlnIjoiw58iLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbWVzIjoiw5ciLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidW1sIjoiwqgiLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwieWVuIjoiwqUiLCJ5dW1sIjoiw78ifScpfSxmdW5jdGlvbih1KXt1LmV4cG9ydHM9SlNPTi5wYXJzZShgeyJhbXAiOiImIiwiYXBvcyI6IiciLCJndCI6Ij4iLCJsdCI6IjwiLCJxdW90IjoiXFwiIn1gKX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihhKXtyZXR1cm4gYSYmYS5fX2VzTW9kdWxlP2E6e2RlZmF1bHQ6YX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj1yKHQoMjY1KSk7ZnVuY3Rpb24gaShhKXtpZihhPj01NTI5NiYmYTw9NTczNDN8fGE+MTExNDExMSlyZXR1cm4i77+9IjthIGluIG4uZGVmYXVsdCYmKGE9bi5kZWZhdWx0W2FdKTt2YXIgbD0iIjtyZXR1cm4gYT42NTUzNSYmKGEtPTY1NTM2LGwrPVN0cmluZy5mcm9tQ2hhckNvZGUoYT4+PjEwJjEwMjN8NTUyOTYpLGE9NTYzMjB8YSYxMDIzKSxsKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpLGx9ZS5kZWZhdWx0PWl9LGZ1bmN0aW9uKHUpe3UuZXhwb3J0cz1KU09OLnBhcnNlKCd7IjAiOjY1NTMzLCIxMjgiOjgzNjQsIjEzMCI6ODIxOCwiMTMxIjo0MDIsIjEzMiI6ODIyMiwiMTMzIjo4MjMwLCIxMzQiOjgyMjQsIjEzNSI6ODIyNSwiMTM2Ijo3MTAsIjEzNyI6ODI0MCwiMTM4IjozNTIsIjEzOSI6ODI0OSwiMTQwIjozMzgsIjE0MiI6MzgxLCIxNDUiOjgyMTYsIjE0NiI6ODIxNywiMTQ3Ijo4MjIwLCIxNDgiOjgyMjEsIjE0OSI6ODIyNiwiMTUwIjo4MjExLCIxNTEiOjgyMTIsIjE1MiI6NzMyLCIxNTMiOjg0ODIsIjE1NCI6MzUzLCIxNTUiOjgyNTAsIjE1NiI6MzM5LCIxNTgiOjM4MiwiMTU5IjozNzZ9Jyl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oTyl7cmV0dXJuIE8mJk8uX19lc01vZHVsZT9POntkZWZhdWx0Ok99fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lc2NhcGU9ZS5lbmNvZGVIVE1MPWUuZW5jb2RlWE1MPXZvaWQgMDt2YXIgbj1yKHQoMjYzKSksaT12KG4uZGVmYXVsdCksYT1kKGkpO2UuZW5jb2RlWE1MPVAoaSxhKTt2YXIgbD1yKHQoMjYxKSkscz12KGwuZGVmYXVsdCksZj1kKHMpO2UuZW5jb2RlSFRNTD1QKHMsZik7ZnVuY3Rpb24gdihPKXtyZXR1cm4gT2JqZWN0LmtleXMoTykuc29ydCgpLnJlZHVjZShmdW5jdGlvbihvLGgpe3JldHVybiBvW09baF1dPSImIitoKyI7IixvfSx7fSl9ZnVuY3Rpb24gZChPKXtmb3IodmFyIG89W10saD1bXSxjPTAsZz1PYmplY3Qua2V5cyhPKTtjPGcubGVuZ3RoO2MrKyl7dmFyIGI9Z1tjXTtiLmxlbmd0aD09PTE/by5wdXNoKCJcXCIrYik6aC5wdXNoKGIpfW8uc29ydCgpO2Zvcih2YXIgRT0wO0U8by5sZW5ndGgtMTtFKyspe2Zvcih2YXIgQT1FO0E8by5sZW5ndGgtMSYmb1tBXS5jaGFyQ29kZUF0KDEpKzE9PT1vW0ErMV0uY2hhckNvZGVBdCgxKTspQSs9MTt2YXIgTD0xK0EtRTtMPDN8fG8uc3BsaWNlKEUsTCxvW0VdKyItIitvW0FdKX1yZXR1cm4gaC51bnNoaWZ0KCJbIitvLmpvaW4oIiIpKyJdIiksbmV3IFJlZ0V4cChoLmpvaW4oInwiKSwiZyIpfXZhciBwPS8oPzpbXHg4MC1cdUQ3RkZcdUUwMDAtXHVGRkZGXXxbXHVEODAwLVx1REJGRl1bXHVEQzAwLVx1REZGRl18W1x1RDgwMC1cdURCRkZdKD8hW1x1REMwMC1cdURGRkZdKXwoPzpbXlx1RDgwMC1cdURCRkZdfF4pW1x1REMwMC1cdURGRkZdKS9nO2Z1bmN0aW9uIHkoTyl7cmV0dXJuIiYjeCIrTy5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSsiOyJ9ZnVuY3Rpb24gUChPLG8pe3JldHVybiBmdW5jdGlvbihoKXtyZXR1cm4gaC5yZXBsYWNlKG8sZnVuY3Rpb24oYyl7cmV0dXJuIE9bY119KS5yZXBsYWNlKHAseSl9fXZhciB4PWQoaSk7ZnVuY3Rpb24gbShPKXtyZXR1cm4gTy5yZXBsYWNlKHgseSkucmVwbGFjZShwLHkpfWUuZXNjYXBlPW19LGZ1bmN0aW9uKHUpe3UuZXhwb3J0cz1KU09OLnBhcnNlKCd7ImVsZW1lbnROYW1lcyI6eyJhbHRnbHlwaCI6ImFsdEdseXBoIiwiYWx0Z2x5cGhkZWYiOiJhbHRHbHlwaERlZiIsImFsdGdseXBoaXRlbSI6ImFsdEdseXBoSXRlbSIsImFuaW1hdGVjb2xvciI6ImFuaW1hdGVDb2xvciIsImFuaW1hdGVtb3Rpb24iOiJhbmltYXRlTW90aW9uIiwiYW5pbWF0ZXRyYW5zZm9ybSI6ImFuaW1hdGVUcmFuc2Zvcm0iLCJjbGlwcGF0aCI6ImNsaXBQYXRoIiwiZmVibGVuZCI6ImZlQmxlbmQiLCJmZWNvbG9ybWF0cml4IjoiZmVDb2xvck1hdHJpeCIsImZlY29tcG9uZW50dHJhbnNmZXIiOiJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVjb21wb3NpdGUiOiJmZUNvbXBvc2l0ZSIsImZlY29udm9sdmVtYXRyaXgiOiJmZUNvbnZvbHZlTWF0cml4IiwiZmVkaWZmdXNlbGlnaHRpbmciOiJmZURpZmZ1c2VMaWdodGluZyIsImZlZGlzcGxhY2VtZW50bWFwIjoiZmVEaXNwbGFjZW1lbnRNYXAiLCJmZWRpc3RhbnRsaWdodCI6ImZlRGlzdGFudExpZ2h0IiwiZmVkcm9wc2hhZG93IjoiZmVEcm9wU2hhZG93IiwiZmVmbG9vZCI6ImZlRmxvb2QiLCJmZWZ1bmNhIjoiZmVGdW5jQSIsImZlZnVuY2IiOiJmZUZ1bmNCIiwiZmVmdW5jZyI6ImZlRnVuY0ciLCJmZWZ1bmNyIjoiZmVGdW5jUiIsImZlZ2F1c3NpYW5ibHVyIjoiZmVHYXVzc2lhbkJsdXIiLCJmZWltYWdlIjoiZmVJbWFnZSIsImZlbWVyZ2UiOiJmZU1lcmdlIiwiZmVtZXJnZW5vZGUiOiJmZU1lcmdlTm9kZSIsImZlbW9ycGhvbG9neSI6ImZlTW9ycGhvbG9neSIsImZlb2Zmc2V0IjoiZmVPZmZzZXQiLCJmZXBvaW50bGlnaHQiOiJmZVBvaW50TGlnaHQiLCJmZXNwZWN1bGFybGlnaHRpbmciOiJmZVNwZWN1bGFyTGlnaHRpbmciLCJmZXNwb3RsaWdodCI6ImZlU3BvdExpZ2h0IiwiZmV0aWxlIjoiZmVUaWxlIiwiZmV0dXJidWxlbmNlIjoiZmVUdXJidWxlbmNlIiwiZm9yZWlnbm9iamVjdCI6ImZvcmVpZ25PYmplY3QiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwibGluZWFyZ3JhZGllbnQiOiJsaW5lYXJHcmFkaWVudCIsInJhZGlhbGdyYWRpZW50IjoicmFkaWFsR3JhZGllbnQiLCJ0ZXh0cGF0aCI6InRleHRQYXRoIn0sImF0dHJpYnV0ZU5hbWVzIjp7ImRlZmluaXRpb251cmwiOiJkZWZpbml0aW9uVVJMIiwiYXR0cmlidXRlbmFtZSI6ImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGV0eXBlIjoiYXR0cmlidXRlVHlwZSIsImJhc2VmcmVxdWVuY3kiOiJiYXNlRnJlcXVlbmN5IiwiYmFzZXByb2ZpbGUiOiJiYXNlUHJvZmlsZSIsImNhbGNtb2RlIjoiY2FsY01vZGUiLCJjbGlwcGF0aHVuaXRzIjoiY2xpcFBhdGhVbml0cyIsImRpZmZ1c2Vjb25zdGFudCI6ImRpZmZ1c2VDb25zdGFudCIsImVkZ2Vtb2RlIjoiZWRnZU1vZGUiLCJmaWx0ZXJ1bml0cyI6ImZpbHRlclVuaXRzIiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImdyYWRpZW50dHJhbnNmb3JtIjoiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIjoiZ3JhZGllbnRVbml0cyIsImtlcm5lbG1hdHJpeCI6Imtlcm5lbE1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiOiJrZXJuZWxVbml0TGVuZ3RoIiwia2V5cG9pbnRzIjoia2V5UG9pbnRzIiwia2V5c3BsaW5lcyI6ImtleVNwbGluZXMiLCJrZXl0aW1lcyI6ImtleVRpbWVzIiwibGVuZ3RoYWRqdXN0IjoibGVuZ3RoQWRqdXN0IiwibGltaXRpbmdjb25lYW5nbGUiOiJsaW1pdGluZ0NvbmVBbmdsZSIsIm1hcmtlcmhlaWdodCI6Im1hcmtlckhlaWdodCIsIm1hcmtlcnVuaXRzIjoibWFya2VyVW5pdHMiLCJtYXJrZXJ3aWR0aCI6Im1hcmtlcldpZHRoIiwibWFza2NvbnRlbnR1bml0cyI6Im1hc2tDb250ZW50VW5pdHMiLCJtYXNrdW5pdHMiOiJtYXNrVW5pdHMiLCJudW1vY3RhdmVzIjoibnVtT2N0YXZlcyIsInBhdGhsZW5ndGgiOiJwYXRoTGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyI6InBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIjoicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm51bml0cyI6InBhdHRlcm5Vbml0cyIsInBvaW50c2F0eCI6InBvaW50c0F0WCIsInBvaW50c2F0eSI6InBvaW50c0F0WSIsInBvaW50c2F0eiI6InBvaW50c0F0WiIsInByZXNlcnZlYWxwaGEiOiJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyI6InByZXNlcnZlQXNwZWN0UmF0aW8iLCJwcmltaXRpdmV1bml0cyI6InByaW1pdGl2ZVVuaXRzIiwicmVmeCI6InJlZlgiLCJyZWZ5IjoicmVmWSIsInJlcGVhdGNvdW50IjoicmVwZWF0Q291bnQiLCJyZXBlYXRkdXIiOiJyZXBlYXREdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiOiJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIjoicmVxdWlyZWRGZWF0dXJlcyIsInNwZWN1bGFyY29uc3RhbnQiOiJzcGVjdWxhckNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCI6InNwZWN1bGFyRXhwb25lbnQiLCJzcHJlYWRtZXRob2QiOiJzcHJlYWRNZXRob2QiLCJzdGFydG9mZnNldCI6InN0YXJ0T2Zmc2V0Iiwic3RkZGV2aWF0aW9uIjoic3RkRGV2aWF0aW9uIiwic3RpdGNodGlsZXMiOiJzdGl0Y2hUaWxlcyIsInN1cmZhY2VzY2FsZSI6InN1cmZhY2VTY2FsZSIsInN5c3RlbWxhbmd1YWdlIjoic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyI6InRhYmxlVmFsdWVzIiwidGFyZ2V0eCI6InRhcmdldFgiLCJ0YXJnZXR5IjoidGFyZ2V0WSIsInRleHRsZW5ndGgiOiJ0ZXh0TGVuZ3RoIiwidmlld2JveCI6InZpZXdCb3giLCJ2aWV3dGFyZ2V0Ijoidmlld1RhcmdldCIsInhjaGFubmVsc2VsZWN0b3IiOiJ4Q2hhbm5lbFNlbGVjdG9yIiwieWNoYW5uZWxzZWxlY3RvciI6InlDaGFubmVsU2VsZWN0b3IiLCJ6b29tYW5kcGFuIjoiem9vbUFuZFBhbiJ9fScpfSxmdW5jdGlvbih1LGUpe3ZhciB0PWUuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24obil7cmV0dXJuIG4uY2hpbGRyZW59LHI9ZS5nZXRQYXJlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIG4ucGFyZW50fTtlLmdldFNpYmxpbmdzPWZ1bmN0aW9uKG4pe3ZhciBpPXIobik7cmV0dXJuIGk/dChpKTpbbl19LGUuZ2V0QXR0cmlidXRlVmFsdWU9ZnVuY3Rpb24obixpKXtyZXR1cm4gbi5hdHRyaWJzJiZuLmF0dHJpYnNbaV19LGUuaGFzQXR0cmliPWZ1bmN0aW9uKG4saSl7cmV0dXJuISFuLmF0dHJpYnMmJmhhc093blByb3BlcnR5LmNhbGwobi5hdHRyaWJzLGkpfSxlLmdldE5hbWU9ZnVuY3Rpb24obil7cmV0dXJuIG4ubmFtZX19LGZ1bmN0aW9uKHUsZSl7ZS5yZW1vdmVFbGVtZW50PWZ1bmN0aW9uKHQpe2lmKHQucHJldiYmKHQucHJldi5uZXh0PXQubmV4dCksdC5uZXh0JiYodC5uZXh0LnByZXY9dC5wcmV2KSx0LnBhcmVudCl7dmFyIHI9dC5wYXJlbnQuY2hpbGRyZW47ci5zcGxpY2Uoci5sYXN0SW5kZXhPZih0KSwxKX19LGUucmVwbGFjZUVsZW1lbnQ9ZnVuY3Rpb24odCxyKXt2YXIgbj1yLnByZXY9dC5wcmV2O24mJihuLm5leHQ9cik7dmFyIGk9ci5uZXh0PXQubmV4dDtpJiYoaS5wcmV2PXIpO3ZhciBhPXIucGFyZW50PXQucGFyZW50O2lmKGEpe3ZhciBsPWEuY2hpbGRyZW47bFtsLmxhc3RJbmRleE9mKHQpXT1yfX0sZS5hcHBlbmRDaGlsZD1mdW5jdGlvbih0LHIpe2lmKHIucGFyZW50PXQsdC5jaGlsZHJlbi5wdXNoKHIpIT09MSl7dmFyIG49dC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aC0yXTtuLm5leHQ9cixyLnByZXY9bixyLm5leHQ9bnVsbH19LGUuYXBwZW5kPWZ1bmN0aW9uKHQscil7dmFyIG49dC5wYXJlbnQsaT10Lm5leHQ7aWYoci5uZXh0PWksci5wcmV2PXQsdC5uZXh0PXIsci5wYXJlbnQ9bixpKXtpZihpLnByZXY9cixuKXt2YXIgYT1uLmNoaWxkcmVuO2Euc3BsaWNlKGEubGFzdEluZGV4T2YoaSksMCxyKX19ZWxzZSBuJiZuLmNoaWxkcmVuLnB1c2gocil9LGUucHJlcGVuZD1mdW5jdGlvbih0LHIpe3ZhciBuPXQucGFyZW50O2lmKG4pe3ZhciBpPW4uY2hpbGRyZW47aS5zcGxpY2UoaS5sYXN0SW5kZXhPZih0KSwwLHIpfXQucHJldiYmKHQucHJldi5uZXh0PXIpLHIucGFyZW50PW4sci5wcmV2PXQucHJldixyLm5leHQ9dCx0LnByZXY9cn19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDI1NikuaXNUYWc7dS5leHBvcnRzPXtmaWx0ZXI6bixmaW5kOmksZmluZE9uZUNoaWxkOmEsZmluZE9uZTpsLGV4aXN0c09uZTpzLGZpbmRBbGw6Zn07ZnVuY3Rpb24gbih2LGQscCx5KXtyZXR1cm4gQXJyYXkuaXNBcnJheShkKXx8KGQ9W2RdKSwodHlwZW9mIHkhPSJudW1iZXIifHwhaXNGaW5pdGUoeSkpJiYoeT0xLzApLGkodixkLHAhPT0hMSx5KX1mdW5jdGlvbiBpKHYsZCxwLHkpe2Zvcih2YXIgUD1bXSx4LG09MCxPPWQubGVuZ3RoO208TyYmISh2KGRbbV0pJiYoUC5wdXNoKGRbbV0pLC0teTw9MCl8fCh4PWRbbV0uY2hpbGRyZW4scCYmeCYmeC5sZW5ndGg+MCYmKHg9aSh2LHgscCx5KSxQPVAuY29uY2F0KHgpLHktPXgubGVuZ3RoLHk8PTApKSk7bSsrKTtyZXR1cm4gUH1mdW5jdGlvbiBhKHYsZCl7Zm9yKHZhciBwPTAseT1kLmxlbmd0aDtwPHk7cCsrKWlmKHYoZFtwXSkpcmV0dXJuIGRbcF07cmV0dXJuIG51bGx9ZnVuY3Rpb24gbCh2LGQpe2Zvcih2YXIgcD1udWxsLHk9MCxQPWQubGVuZ3RoO3k8UCYmIXA7eSsrKWlmKHIoZFt5XSkpdihkW3ldKT9wPWRbeV06ZFt5XS5jaGlsZHJlbi5sZW5ndGg+MCYmKHA9bCh2LGRbeV0uY2hpbGRyZW4pKTtlbHNlIGNvbnRpbnVlO3JldHVybiBwfWZ1bmN0aW9uIHModixkKXtmb3IodmFyIHA9MCx5PWQubGVuZ3RoO3A8eTtwKyspaWYocihkW3BdKSYmKHYoZFtwXSl8fGRbcF0uY2hpbGRyZW4ubGVuZ3RoPjAmJnModixkW3BdLmNoaWxkcmVuKSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZih2LGQpe2Zvcih2YXIgcD1bXSx5PWQuc2xpY2UoKTt5Lmxlbmd0aDspe3ZhciBQPXkuc2hpZnQoKTtyKFApJiYoUC5jaGlsZHJlbiYmUC5jaGlsZHJlbi5sZW5ndGg+MCYmeS51bnNoaWZ0LmFwcGx5KHksUC5jaGlsZHJlbiksdihQKSYmcC5wdXNoKFApKX1yZXR1cm4gcH19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDI1Niksbj1lLmlzVGFnPXIuaXNUYWc7ZS50ZXN0RWxlbWVudD1mdW5jdGlvbihzLGYpe2Zvcih2YXIgdiBpbiBzKWlmKHMuaGFzT3duUHJvcGVydHkodikpe2lmKHY9PT0idGFnX25hbWUiKXtpZighbihmKXx8IXMudGFnX25hbWUoZi5uYW1lKSlyZXR1cm4hMX1lbHNlIGlmKHY9PT0idGFnX3R5cGUiKXtpZighcy50YWdfdHlwZShmLnR5cGUpKXJldHVybiExfWVsc2UgaWYodj09PSJ0YWdfY29udGFpbnMiKXtpZihuKGYpfHwhcy50YWdfY29udGFpbnMoZi5kYXRhKSlyZXR1cm4hMX1lbHNlIGlmKCFmLmF0dHJpYnN8fCFzW3ZdKGYuYXR0cmlic1t2XSkpcmV0dXJuITF9cmV0dXJuITB9O3ZhciBpPXt0YWdfbmFtZTpmdW5jdGlvbihzKXtyZXR1cm4gdHlwZW9mIHM9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oZil7cmV0dXJuIG4oZikmJnMoZi5uYW1lKX06cz09PSIqIj9uOmZ1bmN0aW9uKGYpe3JldHVybiBuKGYpJiZmLm5hbWU9PT1zfX0sdGFnX3R5cGU6ZnVuY3Rpb24ocyl7cmV0dXJuIHR5cGVvZiBzPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGYpe3JldHVybiBzKGYudHlwZSl9OmZ1bmN0aW9uKGYpe3JldHVybiBmLnR5cGU9PT1zfX0sdGFnX2NvbnRhaW5zOmZ1bmN0aW9uKHMpe3JldHVybiB0eXBlb2Ygcz09ImZ1bmN0aW9uIj9mdW5jdGlvbihmKXtyZXR1cm4hbihmKSYmcyhmLmRhdGEpfTpmdW5jdGlvbihmKXtyZXR1cm4hbihmKSYmZi5kYXRhPT09c319fTtmdW5jdGlvbiBhKHMsZil7cmV0dXJuIHR5cGVvZiBmPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKHYpe3JldHVybiB2LmF0dHJpYnMmJmYodi5hdHRyaWJzW3NdKX06ZnVuY3Rpb24odil7cmV0dXJuIHYuYXR0cmlicyYmdi5hdHRyaWJzW3NdPT09Zn19ZnVuY3Rpb24gbChzLGYpe3JldHVybiBmdW5jdGlvbih2KXtyZXR1cm4gcyh2KXx8Zih2KX19ZS5nZXRFbGVtZW50cz1mdW5jdGlvbihzLGYsdixkKXt2YXIgcD1PYmplY3Qua2V5cyhzKS5tYXAoZnVuY3Rpb24oeSl7dmFyIFA9c1t5XTtyZXR1cm4geSBpbiBpP2lbeV0oUCk6YSh5LFApfSk7cmV0dXJuIHAubGVuZ3RoPT09MD9bXTp0aGlzLmZpbHRlcihwLnJlZHVjZShsKSxmLHYsZCl9LGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24ocyxmLHYpe3JldHVybiBBcnJheS5pc0FycmF5KGYpfHwoZj1bZl0pLHRoaXMuZmluZE9uZShhKCJpZCIscyksZix2IT09ITEpfSxlLmdldEVsZW1lbnRzQnlUYWdOYW1lPWZ1bmN0aW9uKHMsZix2LGQpe3JldHVybiB0aGlzLmZpbHRlcihpLnRhZ19uYW1lKHMpLGYsdixkKX0sZS5nZXRFbGVtZW50c0J5VGFnVHlwZT1mdW5jdGlvbihzLGYsdixkKXtyZXR1cm4gdGhpcy5maWx0ZXIoaS50YWdfdHlwZShzKSxmLHYsZCl9fSxmdW5jdGlvbih1LGUpe2UucmVtb3ZlU3Vic2V0cz1mdW5jdGlvbihuKXtmb3IodmFyIGk9bi5sZW5ndGgsYSxsLHM7LS1pPi0xOyl7Zm9yKGE9bD1uW2ldLG5baV09bnVsbCxzPSEwO2w7KXtpZihuLmluZGV4T2YobCk+LTEpe3M9ITEsbi5zcGxpY2UoaSwxKTticmVha31sPWwucGFyZW50fXMmJihuW2ldPWEpfXJldHVybiBufTt2YXIgdD17RElTQ09OTkVDVEVEOjEsUFJFQ0VESU5HOjIsRk9MTE9XSU5HOjQsQ09OVEFJTlM6OCxDT05UQUlORURfQlk6MTZ9LHI9ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj1mdW5jdGlvbihuLGkpe3ZhciBhPVtdLGw9W10scyxmLHYsZCxwLHk7aWYobj09PWkpcmV0dXJuIDA7Zm9yKHM9bjtzOylhLnVuc2hpZnQocykscz1zLnBhcmVudDtmb3Iocz1pO3M7KWwudW5zaGlmdChzKSxzPXMucGFyZW50O2Zvcih5PTA7YVt5XT09PWxbeV07KXkrKztyZXR1cm4geT09PTA/dC5ESVNDT05ORUNURUQ6KGY9YVt5LTFdLHY9Zi5jaGlsZHJlbixkPWFbeV0scD1sW3ldLHYuaW5kZXhPZihkKT52LmluZGV4T2YocCk/Zj09PWk/dC5GT0xMT1dJTkd8dC5DT05UQUlORURfQlk6dC5GT0xMT1dJTkc6Zj09PW4/dC5QUkVDRURJTkd8dC5DT05UQUlOUzp0LlBSRUNFRElORyl9O2UudW5pcXVlU29ydD1mdW5jdGlvbihuKXt2YXIgaT1uLmxlbmd0aCxhLGw7Zm9yKG49bi5zbGljZSgpOy0taT4tMTspYT1uW2ldLGw9bi5pbmRleE9mKGEpLGw+LTEmJmw8aSYmbi5zcGxpY2UoaSwxKTtyZXR1cm4gbi5zb3J0KGZ1bmN0aW9uKHMsZil7dmFyIHY9cihzLGYpO3JldHVybiB2JnQuUFJFQ0VESU5HPy0xOnYmdC5GT0xMT1dJTkc/MTowfSksbn19LGZ1bmN0aW9uKHUsZSl7dS5leHBvcnRzPXt0cnVlRnVuYzpmdW5jdGlvbigpe3JldHVybiEwfSxmYWxzZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMX19fSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPXA7dmFyIHI9dCgyNzUpLnBhcnNlLG49dCgyNzMpLGk9dCgyNzgpLGE9dCgyNzkpLGw9dCgyODApLHM9dCgyODIpLGY9bi50cnVlRnVuYyx2PW4uZmFsc2VGdW5jLGQ9cy5maWx0ZXJzO2Z1bmN0aW9uIHAoTSxJLEQpe3ZhciBSPVAoTSxJLEQpO3JldHVybiB5KFIsSSl9ZnVuY3Rpb24geShNLEkpe3ZhciBEPUkuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oQyl7cmV0dXJuIEQuaXNUYWcoQykmJk0oQyl9fWZ1bmN0aW9uIFAoTSxJLEQpe3ZhciBSPXIoTSxJKTtyZXR1cm4gZyhSLEksRCl9ZnVuY3Rpb24geChNKXtyZXR1cm4gTS50eXBlPT09InBzZXVkbyImJihNLm5hbWU9PT0ic2NvcGUifHxBcnJheS5pc0FycmF5KE0uZGF0YSkmJk0uZGF0YS5zb21lKGZ1bmN0aW9uKEkpe3JldHVybiBJLnNvbWUoeCl9KSl9dmFyIG09e3R5cGU6ImRlc2NlbmRhbnQifSxPPXt0eXBlOiJfZmxleGlibGVEZXNjZW5kYW50In0sbz17dHlwZToicHNldWRvIixuYW1lOiJzY29wZSJ9LGg9e307ZnVuY3Rpb24gYyhNLEksRCl7dmFyIFI9SS5hZGFwdGVyLEM9ISFEJiYhIUQubGVuZ3RoJiZELmV2ZXJ5KGZ1bmN0aW9uKEIpe3JldHVybiBCPT09aHx8ISFSLmdldFBhcmVudChCKX0pO00uZm9yRWFjaChmdW5jdGlvbihCKXtpZighKEIubGVuZ3RoPjAmJmIoQlswXSkmJkJbMF0udHlwZSE9PSJkZXNjZW5kYW50IikpaWYoQyYmIShBcnJheS5pc0FycmF5KEIpP0Iuc29tZSh4KTp4KEIpKSlCLnVuc2hpZnQobSk7ZWxzZSByZXR1cm47Qi51bnNoaWZ0KG8pfSl9ZnVuY3Rpb24gZyhNLEksRCl7TT1NLmZpbHRlcihmdW5jdGlvbih6KXtyZXR1cm4gei5sZW5ndGg+MH0pLE0uZm9yRWFjaChpKTt2YXIgUj1BcnJheS5pc0FycmF5KEQpO0Q9SSYmSS5jb250ZXh0fHxELEQmJiFSJiYoRD1bRF0pLGMoTSxJLEQpO3ZhciBDPSExLEI9TS5tYXAoZnVuY3Rpb24oeil7aWYoelswXSYmelsxXSYmelswXS5uYW1lPT09InNjb3BlIil7dmFyIEs9elsxXS50eXBlO1ImJks9PT0iZGVzY2VuZGFudCI/elsxXT1POihLPT09ImFkamFjZW50Inx8Sz09PSJzaWJsaW5nIikmJihDPSEwKX1yZXR1cm4gRSh6LEksRCl9KS5yZWR1Y2UoQSx2KTtyZXR1cm4gQi5zaG91bGRUZXN0TmV4dFNpYmxpbmdzPUMsQn1mdW5jdGlvbiBiKE0pe3JldHVybiBhW00udHlwZV08MH1mdW5jdGlvbiBFKE0sSSxEKXtyZXR1cm4gTS5yZWR1Y2UoZnVuY3Rpb24oUixDKXtpZihSPT09dilyZXR1cm4gUjtpZighKEMudHlwZSBpbiBsKSl0aHJvdyBuZXcgRXJyb3IoIlJ1bGUgdHlwZSAiK0MudHlwZSsiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgY3NzLXNlbGVjdCIpO3JldHVybiBsW0MudHlwZV0oUixDLEksRCl9LEkmJkkucm9vdEZ1bmN8fGYpfWZ1bmN0aW9uIEEoTSxJKXtyZXR1cm4gST09PXZ8fE09PT1mP006TT09PXZ8fEk9PT1mP0k6ZnVuY3Rpb24oUil7cmV0dXJuIE0oUil8fEkoUil9fWZ1bmN0aW9uIEwoTSl7cmV0dXJuIE0uc29tZShiKX1kLm5vdD1mdW5jdGlvbihNLEksRCxSKXt2YXIgQz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCksYWRhcHRlcjpELmFkYXB0ZXJ9O2lmKEMuc3RyaWN0JiYoSS5sZW5ndGg+MXx8SS5zb21lKEwpKSl0aHJvdyBuZXcgRXJyb3IoImNvbXBsZXggc2VsZWN0b3JzIGluIDpub3QgYXJlbid0IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUiKTt2YXIgQj1nKEksQyxSKTtyZXR1cm4gQj09PXY/TTpCPT09Zj92OmZ1bmN0aW9uKEspe3JldHVybiFCKEspJiZNKEspfX0sZC5oYXM9ZnVuY3Rpb24oTSxJLEQpe3ZhciBSPUQuYWRhcHRlcixDPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxhZGFwdGVyOlJ9LEI9SS5zb21lKEwpP1toXTpudWxsLHo9ZyhJLEMsQik7cmV0dXJuIHo9PT12P3Y6ej09PWY/ZnVuY3Rpb24oUSl7cmV0dXJuIFIuZ2V0Q2hpbGRyZW4oUSkuc29tZShSLmlzVGFnKSYmTShRKX06KHo9eSh6LEQpLEI/ZnVuY3Rpb24oUSl7cmV0dXJuIE0oUSkmJihCWzBdPVEsUi5leGlzdHNPbmUoeixSLmdldENoaWxkcmVuKFEpKSl9OmZ1bmN0aW9uKFEpe3JldHVybiBNKFEpJiZSLmV4aXN0c09uZSh6LFIuZ2V0Q2hpbGRyZW4oUSkpfSl9LGQubWF0Y2hlcz1mdW5jdGlvbihNLEksRCxSKXt2YXIgQz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCkscm9vdEZ1bmM6TSxhZGFwdGVyOkQuYWRhcHRlcn07cmV0dXJuIGcoSSxDLFIpfSxwLmNvbXBpbGVUb2tlbj1nLHAuY29tcGlsZVVuc2FmZT1QLHAuUHNldWRvcz1zfSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGwscyxmLHYpe3Y9PT12b2lkIDAmJih2PWYpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHYse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHNbZl19fSl9OmZ1bmN0aW9uKGwscyxmLHYpe3Y9PT12b2lkIDAmJih2PWYpLGxbdl09c1tmXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGwscyl7Zm9yKHZhciBmIGluIGwpZiE9PSJkZWZhdWx0IiYmIXMuaGFzT3duUHJvcGVydHkoZikmJnIocyxsLGYpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksbih0KDI3NiksZSk7dmFyIGk9dCgyNzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJwYXJzZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdH19KTt2YXIgYT10KDI3Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInN0cmluZ2lmeSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH19KX0sZnVuY3Rpb24odSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9eDt2YXIgcj0vXlteXFxdPyg/OlxcKD86W1xkYS1mXXsxLDZ9XHM/fC4pfFtcd1wtXHUwMGIwLVx1RkZGRl0pKy8sbj0vXFwoW1xkYS1mXXsxLDZ9XHM/fChccyl8LikvZ2ksaT0vXlxzKigoPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSspXHMqKD86KFxTPyk9XHMqKD86KFsnIl0pKFteXSo/KVwzfCgjPyg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKil8KXwpXHMqKGkpP1xdLyxhPXt1bmRlZmluZWQ6ImV4aXN0cyIsIiI6ImVxdWFscyIsIn4iOiJlbGVtZW50IiwiXiI6InN0YXJ0IiwkOiJlbmQiLCIqIjoiYW55IiwiISI6Im5vdCIsInwiOiJoeXBoZW4ifSxsPXsiPiI6ImNoaWxkIiwiPCI6InBhcmVudCIsIn4iOiJzaWJsaW5nIiwiKyI6ImFkamFjZW50In0scz17IiMiOlsiaWQiLCJlcXVhbHMiXSwiLiI6WyJjbGFzcyIsImVsZW1lbnQiXX0sZj1uZXcgU2V0KFsiaGFzIiwibm90IiwibWF0Y2hlcyJdKSx2PW5ldyBTZXQoWyJjb250YWlucyIsImljb250YWlucyJdKSxkPW5ldyBTZXQoWyciJywiJyJdKTtmdW5jdGlvbiBwKG8saCxjKXt2YXIgZz1wYXJzZUludChoLDE2KS02NTUzNjtyZXR1cm4gZyE9PWd8fGM/aDpnPDA/U3RyaW5nLmZyb21DaGFyQ29kZShnKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKGc+PjEwfDU1Mjk2LGcmMTAyM3w1NjMyMCl9ZnVuY3Rpb24geShvKXtyZXR1cm4gby5yZXBsYWNlKG4scCl9ZnVuY3Rpb24gUChvKXtyZXR1cm4gbz09PSIgInx8bz09PWAKYHx8bz09PSIJInx8bz09PSJcZiJ8fG89PT0iXHIifWZ1bmN0aW9uIHgobyxoKXt2YXIgYz1bXTtpZihvPW0oYywiIitvLGgpLG8hPT0iIil0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBzZWxlY3RvcjogIitvKTtyZXR1cm4gY31mdW5jdGlvbiBtKG8saCxjKXt2YXIgZz1bXSxiPSExO2Z1bmN0aW9uIEUoKXt2YXIgWD1oLm1hdGNoKHIpO2lmKCFYKXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbmFtZSwgZm91bmQgIitoKTt2YXIgWj1YWzBdO3JldHVybiBoPWguc3Vic3RyKFoubGVuZ3RoKSx5KFopfWZ1bmN0aW9uIEEoWCl7Zm9yKDtQKGguY2hhckF0KFgpKTspWCsrO2g9aC5zdWJzdHIoWCl9ZnVuY3Rpb24gTChYKXtmb3IodmFyIFo9MDtoLmNoYXJBdCgtLVgpPT09IlxcIjspWisrO3JldHVybihaJjEpPT09MX1mb3IoQSgwKTtoIT09IiI7KXt2YXIgTT1oLmNoYXJBdCgwKTtpZihQKE0pKWI9ITAsQSgxKTtlbHNlIGlmKE0gaW4gbClnLnB1c2goe3R5cGU6bFtNXX0pLGI9ITEsQSgxKTtlbHNlIGlmKE09PT0iLCIpe2lmKGcubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO28ucHVzaChnKSxnPVtdLGI9ITEsQSgxKX1lbHNlIGlmKGImJihnLmxlbmd0aD4wJiZnLnB1c2goe3R5cGU6ImRlc2NlbmRhbnQifSksYj0hMSksTT09PSIqIiloPWguc3Vic3RyKDEpLGcucHVzaCh7dHlwZToidW5pdmVyc2FsIn0pO2Vsc2UgaWYoTSBpbiBzKXt2YXIgST1zW01dLEQ9SVswXSxSPUlbMV07aD1oLnN1YnN0cigxKSxnLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpELGFjdGlvbjpSLHZhbHVlOkUoKSxpZ25vcmVDYXNlOiExfSl9ZWxzZSBpZihNPT09IlsiKXtoPWguc3Vic3RyKDEpO3ZhciBDPWgubWF0Y2goaSk7aWYoIUMpdGhyb3cgbmV3IEVycm9yKCJNYWxmb3JtZWQgYXR0cmlidXRlIHNlbGVjdG9yOiAiK2gpO2g9aC5zdWJzdHIoQ1swXS5sZW5ndGgpO3ZhciBCPXkoQ1sxXSk7KCFjfHwoImxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzImluIGM/Yy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lczohYy54bWxNb2RlKSkmJihCPUIudG9Mb3dlckNhc2UoKSksZy5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6QixhY3Rpb246YVtDWzJdXSx2YWx1ZTp5KENbNF18fENbNV18fCIiKSxpZ25vcmVDYXNlOiEhQ1s2XX0pfWVsc2UgaWYoTT09PSI6Iil7aWYoaC5jaGFyQXQoMSk9PT0iOiIpe2g9aC5zdWJzdHIoMiksZy5wdXNoKHt0eXBlOiJwc2V1ZG8tZWxlbWVudCIsbmFtZTpFKCkudG9Mb3dlckNhc2UoKX0pO2NvbnRpbnVlfWg9aC5zdWJzdHIoMSk7dmFyIHo9RSgpLnRvTG93ZXJDYXNlKCksQz1udWxsO2lmKGguY2hhckF0KDApPT09IigiKWlmKGYuaGFzKHopKXt2YXIgSz1oLmNoYXJBdCgxKSxRPWQuaGFzKEspO2lmKGg9aC5zdWJzdHIoUT8yOjEpLEM9W10saD1tKEMsaCxjKSxRKXtpZihoLmNoYXJBdCgwKSE9PUspdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgcXVvdGVzIGluIDoiK3opO2g9aC5zdWJzdHIoMSl9aWYoaC5jaGFyQXQoMCkhPT0iKSIpdGhyb3cgbmV3IEVycm9yKCJNaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMgaW4gOiIreisiICgiK2grIikiKTtoPWguc3Vic3RyKDEpfWVsc2V7Zm9yKHZhciBfPTEsRj0xO0Y+MCYmXzxoLmxlbmd0aDtfKyspaC5jaGFyQXQoXyk9PT0iKCImJiFMKF8pP0YrKzpoLmNoYXJBdChfKT09PSIpIiYmIUwoXykmJkYtLTtpZihGKXRocm93IG5ldyBFcnJvcigiUGFyZW50aGVzaXMgbm90IG1hdGNoZWQiKTtpZihDPWguc3Vic3RyKDEsXy0yKSxoPWguc3Vic3RyKF8pLHYuaGFzKHopKXt2YXIgSz1DLmNoYXJBdCgwKTtLPT09Qy5zbGljZSgtMSkmJmQuaGFzKEspJiYoQz1DLnNsaWNlKDEsLTEpKSxDPXkoQyl9fWcucHVzaCh7dHlwZToicHNldWRvIixuYW1lOnosZGF0YTpDfSl9ZWxzZSBpZihyLnRlc3QoaCkpe3ZhciBHPUUoKTsoIWN8fCgibG93ZXJDYXNlVGFncyJpbiBjP2MubG93ZXJDYXNlVGFnczohYy54bWxNb2RlKSkmJihHPUcudG9Mb3dlckNhc2UoKSksZy5wdXNoKHt0eXBlOiJ0YWciLG5hbWU6R30pfWVsc2UgcmV0dXJuIGcubGVuZ3RoJiZnW2cubGVuZ3RoLTFdLnR5cGU9PT0iZGVzY2VuZGFudCImJmcucG9wKCksTyhvLGcpLGh9cmV0dXJuIE8obyxnKSxofWZ1bmN0aW9uIE8obyxoKXtpZihvLmxlbmd0aD4wJiZoLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtvLnB1c2goaCl9fSxmdW5jdGlvbih1LGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXtlcXVhbHM6IiIsZWxlbWVudDoifiIsc3RhcnQ6Il4iLGVuZDoiJCIsYW55OiIqIixub3Q6IiEiLGh5cGhlbjoifCJ9O2Z1bmN0aW9uIG4ocyl7cmV0dXJuIHMubWFwKGkpLmpvaW4oIiwgIil9ZS5kZWZhdWx0PW47ZnVuY3Rpb24gaShzKXtyZXR1cm4gcy5tYXAoYSkuam9pbigiIil9ZnVuY3Rpb24gYShzKXtzd2l0Y2gocy50eXBlKXtjYXNlImNoaWxkIjpyZXR1cm4iID4gIjtjYXNlInBhcmVudCI6cmV0dXJuIiA8ICI7Y2FzZSJzaWJsaW5nIjpyZXR1cm4iIH4gIjtjYXNlImFkamFjZW50IjpyZXR1cm4iICsgIjtjYXNlImRlc2NlbmRhbnQiOnJldHVybiIgIjtjYXNlInVuaXZlcnNhbCI6cmV0dXJuIioiO2Nhc2UidGFnIjpyZXR1cm4gcy5uYW1lO2Nhc2UicHNldWRvLWVsZW1lbnQiOnJldHVybiI6OiIrcy5uYW1lO2Nhc2UicHNldWRvIjpyZXR1cm4gcy5kYXRhPT09bnVsbD8iOiIrcy5uYW1lOnR5cGVvZiBzLmRhdGE9PSJzdHJpbmciPyI6IitzLm5hbWUrIigiK3MuZGF0YSsiKSI6IjoiK3MubmFtZSsiKCIrbihzLmRhdGEpKyIpIjtjYXNlImF0dHJpYnV0ZSI6cmV0dXJuIHMuYWN0aW9uPT09ImV4aXN0cyI/IlsiK3MubmFtZSsiXSI6cy5uYW1lPT09ImlkIiYmcy5hY3Rpb249PT0iZXF1YWxzIiYmIXMuaWdub3JlQ2FzZT8iIyIrcy52YWx1ZTpzLm5hbWU9PT0iY2xhc3MiJiZzLmFjdGlvbj09PSJlbGVtZW50IiYmIXMuaWdub3JlQ2FzZT8iLiIrcy52YWx1ZToiWyIrcy5uYW1lK3Jbcy5hY3Rpb25dKyI9JyIrcy52YWx1ZSsiJyIrKHMuaWdub3JlQ2FzZT8iaSI6IiIpKyJdIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5rbm93biB0eXBlIil9fWZ1bmN0aW9uIGwocyl7cmV0dXJuIHN9fSxmdW5jdGlvbih1LGUsdCl7dS5leHBvcnRzPWk7dmFyIHI9dCgyNzkpLG49e19fcHJvdG9fXzpudWxsLGV4aXN0czoxMCxlcXVhbHM6OCxub3Q6NyxzdGFydDo2LGVuZDo2LGFueTo1LGh5cGhlbjo0LGVsZW1lbnQ6NH07ZnVuY3Rpb24gaShsKXtmb3IodmFyIHM9bC5tYXAoYSksZj0xO2Y8bC5sZW5ndGg7ZisrKXt2YXIgdj1zW2ZdO2lmKCEodjwwKSlmb3IodmFyIGQ9Zi0xO2Q+PTAmJnY8c1tkXTtkLS0pe3ZhciBwPWxbZCsxXTtsW2QrMV09bFtkXSxsW2RdPXAsc1tkKzFdPXNbZF0sc1tkXT12fX19ZnVuY3Rpb24gYShsKXt2YXIgcz1yW2wudHlwZV07aWYocz09PXIuYXR0cmlidXRlKXM9bltsLmFjdGlvbl0scz09PW4uZXF1YWxzJiZsLm5hbWU9PT0iaWQiJiYocz05KSxsLmlnbm9yZUNhc2UmJihzPj49MSk7ZWxzZSBpZihzPT09ci5wc2V1ZG8paWYoIWwuZGF0YSlzPTM7ZWxzZSBpZihsLm5hbWU9PT0iaGFzInx8bC5uYW1lPT09ImNvbnRhaW5zIilzPTA7ZWxzZSBpZihsLm5hbWU9PT0ibWF0Y2hlcyJ8fGwubmFtZT09PSJub3QiKXtzPTA7Zm9yKHZhciBmPTA7ZjxsLmRhdGEubGVuZ3RoO2YrKylpZihsLmRhdGFbZl0ubGVuZ3RoPT09MSl7dmFyIHY9YShsLmRhdGFbZl1bMF0pO2lmKHY9PT0wKXtzPTA7YnJlYWt9dj5zJiYocz12KX1sLmRhdGEubGVuZ3RoPjEmJnM+MCYmKHMtPTEpfWVsc2Ugcz0xO3JldHVybiBzfX0sZnVuY3Rpb24odSl7dS5leHBvcnRzPUpTT04ucGFyc2UoJ3sidW5pdmVyc2FsIjo1MCwidGFnIjozMCwiYXR0cmlidXRlIjoxLCJwc2V1ZG8iOjAsImRlc2NlbmRhbnQiOi0xLCJjaGlsZCI6LTEsInBhcmVudCI6LTEsInNpYmxpbmciOi0xLCJhZGphY2VudCI6LTF9Jyl9LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDI4MSksbj10KDI4Mik7dS5leHBvcnRzPXtfX3Byb3RvX186bnVsbCxhdHRyaWJ1dGU6ci5jb21waWxlLHBzZXVkbzpuLmNvbXBpbGUsdGFnOmZ1bmN0aW9uKGksYSxsKXt2YXIgcz1hLm5hbWUsZj1sLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiBmLmdldE5hbWUoZCk9PT1zJiZpKGQpfX0sZGVzY2VuZGFudDpmdW5jdGlvbihpLGEsbCl7dmFyIHM9dHlwZW9mIFdlYWtTZXQ8InUiP25ldyBXZWFrU2V0Om51bGwsZj1sLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGQpe2Zvcih2YXIgcD0hMTshcCYmKGQ9Zi5nZXRQYXJlbnQoZCkpOykoIXN8fCFzLmhhcyhkKSkmJihwPWkoZCksIXAmJnMmJnMuYWRkKGQpKTtyZXR1cm4gcH19LF9mbGV4aWJsZURlc2NlbmRhbnQ6ZnVuY3Rpb24oaSxhLGwpe3ZhciBzPWwuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24odil7Zm9yKHZhciBkPWkodik7IWQmJih2PXMuZ2V0UGFyZW50KHYpKTspZD1pKHYpO3JldHVybiBkfX0scGFyZW50OmZ1bmN0aW9uKGksYSxsKXtpZihsJiZsLnN0cmljdCl0aHJvdyBuZXcgRXJyb3IoIlBhcmVudCBzZWxlY3RvciBpc24ndCBwYXJ0IG9mIENTUzMiKTt2YXIgcz1sLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiBzLmdldENoaWxkcmVuKGQpLnNvbWUoZil9O2Z1bmN0aW9uIGYodil7cmV0dXJuIHMuaXNUYWcodikmJmkodil9fSxjaGlsZDpmdW5jdGlvbihpLGEsbCl7dmFyIHM9bC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih2KXt2YXIgZD1zLmdldFBhcmVudCh2KTtyZXR1cm4hIWQmJmkoZCl9fSxzaWJsaW5nOmZ1bmN0aW9uKGksYSxsKXt2YXIgcz1sLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHYpe2Zvcih2YXIgZD1zLmdldFNpYmxpbmdzKHYpLHA9MDtwPGQubGVuZ3RoO3ArKylpZihzLmlzVGFnKGRbcF0pKXtpZihkW3BdPT09dilicmVhaztpZihpKGRbcF0pKXJldHVybiEwfXJldHVybiExfX0sYWRqYWNlbnQ6ZnVuY3Rpb24oaSxhLGwpe3ZhciBzPWwuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24odil7Zm9yKHZhciBkPXMuZ2V0U2libGluZ3ModikscCx5PTA7eTxkLmxlbmd0aDt5KyspaWYocy5pc1RhZyhkW3ldKSl7aWYoZFt5XT09PXYpYnJlYWs7cD1kW3ldfXJldHVybiEhcCYmaShwKX19LHVuaXZlcnNhbDpmdW5jdGlvbihpKXtyZXR1cm4gaX19fSxmdW5jdGlvbih1LGUsdCl7dmFyIHI9dCgyNzMpLmZhbHNlRnVuYyxuPS9bLVtcXXt9KCkqKz8uLFxcXiR8I1xzXS9nLGk9e19fcHJvdG9fXzpudWxsLGVxdWFsczpmdW5jdGlvbihhLGwscyl7dmFyIGY9bC5uYW1lLHY9bC52YWx1ZSxkPXMuYWRhcHRlcjtyZXR1cm4gbC5pZ25vcmVDYXNlPyh2PXYudG9Mb3dlckNhc2UoKSxmdW5jdGlvbih5KXt2YXIgUD1kLmdldEF0dHJpYnV0ZVZhbHVlKHksZik7cmV0dXJuIFAhPW51bGwmJlAudG9Mb3dlckNhc2UoKT09PXYmJmEoeSl9KTpmdW5jdGlvbih5KXtyZXR1cm4gZC5nZXRBdHRyaWJ1dGVWYWx1ZSh5LGYpPT09diYmYSh5KX19LGh5cGhlbjpmdW5jdGlvbihhLGwscyl7dmFyIGY9bC5uYW1lLHY9bC52YWx1ZSxkPXYubGVuZ3RoLHA9cy5hZGFwdGVyO3JldHVybiBsLmlnbm9yZUNhc2U/KHY9di50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKFApe3ZhciB4PXAuZ2V0QXR0cmlidXRlVmFsdWUoUCxmKTtyZXR1cm4geCE9bnVsbCYmKHgubGVuZ3RoPT09ZHx8eC5jaGFyQXQoZCk9PT0iLSIpJiZ4LnN1YnN0cigwLGQpLnRvTG93ZXJDYXNlKCk9PT12JiZhKFApfSk6ZnVuY3Rpb24oUCl7dmFyIHg9cC5nZXRBdHRyaWJ1dGVWYWx1ZShQLGYpO3JldHVybiB4IT1udWxsJiZ4LnN1YnN0cigwLGQpPT09diYmKHgubGVuZ3RoPT09ZHx8eC5jaGFyQXQoZCk9PT0iLSIpJiZhKFApfX0sZWxlbWVudDpmdW5jdGlvbihhLGwscyl7dmFyIGY9bC5uYW1lLHY9bC52YWx1ZSxkPXMuYWRhcHRlcjtpZigvXHMvLnRlc3QodikpcmV0dXJuIHI7dj12LnJlcGxhY2UobiwiXFwkJiIpO3ZhciBwPSIoPzpefFxccykiK3YrIig/OiR8XFxzKSIseT1sLmlnbm9yZUNhc2U/ImkiOiIiLFA9bmV3IFJlZ0V4cChwLHkpO3JldHVybiBmdW5jdGlvbihtKXt2YXIgTz1kLmdldEF0dHJpYnV0ZVZhbHVlKG0sZik7cmV0dXJuIE8hPW51bGwmJlAudGVzdChPKSYmYShtKX19LGV4aXN0czpmdW5jdGlvbihhLGwscyl7dmFyIGY9bC5uYW1lLHY9cy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihwKXtyZXR1cm4gdi5oYXNBdHRyaWIocCxmKSYmYShwKX19LHN0YXJ0OmZ1bmN0aW9uKGEsbCxzKXt2YXIgZj1sLm5hbWUsdj1sLnZhbHVlLGQ9di5sZW5ndGgscD1zLmFkYXB0ZXI7cmV0dXJuIGQ9PT0wP3I6bC5pZ25vcmVDYXNlPyh2PXYudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihQKXt2YXIgeD1wLmdldEF0dHJpYnV0ZVZhbHVlKFAsZik7cmV0dXJuIHghPW51bGwmJnguc3Vic3RyKDAsZCkudG9Mb3dlckNhc2UoKT09PXYmJmEoUCl9KTpmdW5jdGlvbihQKXt2YXIgeD1wLmdldEF0dHJpYnV0ZVZhbHVlKFAsZik7cmV0dXJuIHghPW51bGwmJnguc3Vic3RyKDAsZCk9PT12JiZhKFApfX0sZW5kOmZ1bmN0aW9uKGEsbCxzKXt2YXIgZj1sLm5hbWUsdj1sLnZhbHVlLGQ9LXYubGVuZ3RoLHA9cy5hZGFwdGVyO3JldHVybiBkPT09MD9yOmwuaWdub3JlQ2FzZT8odj12LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oUCl7dmFyIHg9cC5nZXRBdHRyaWJ1dGVWYWx1ZShQLGYpO3JldHVybiB4IT1udWxsJiZ4LnN1YnN0cihkKS50b0xvd2VyQ2FzZSgpPT09diYmYShQKX0pOmZ1bmN0aW9uKFApe3ZhciB4PXAuZ2V0QXR0cmlidXRlVmFsdWUoUCxmKTtyZXR1cm4geCE9bnVsbCYmeC5zdWJzdHIoZCk9PT12JiZhKFApfX0sYW55OmZ1bmN0aW9uKGEsbCxzKXt2YXIgZj1sLm5hbWUsdj1sLnZhbHVlLGQ9cy5hZGFwdGVyO2lmKHY9PT0iIilyZXR1cm4gcjtpZihsLmlnbm9yZUNhc2Upe3ZhciBwPW5ldyBSZWdFeHAodi5yZXBsYWNlKG4sIlxcJCYiKSwiaSIpO3JldHVybiBmdW5jdGlvbihQKXt2YXIgeD1kLmdldEF0dHJpYnV0ZVZhbHVlKFAsZik7cmV0dXJuIHghPW51bGwmJnAudGVzdCh4KSYmYShQKX19cmV0dXJuIGZ1bmN0aW9uKFApe3ZhciB4PWQuZ2V0QXR0cmlidXRlVmFsdWUoUCxmKTtyZXR1cm4geCE9bnVsbCYmeC5pbmRleE9mKHYpPj0wJiZhKFApfX0sbm90OmZ1bmN0aW9uKGEsbCxzKXt2YXIgZj1sLm5hbWUsdj1sLnZhbHVlLGQ9cy5hZGFwdGVyO3JldHVybiB2PT09IiI/ZnVuY3Rpb24oeSl7cmV0dXJuISFkLmdldEF0dHJpYnV0ZVZhbHVlKHksZikmJmEoeSl9OmwuaWdub3JlQ2FzZT8odj12LnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oeSl7dmFyIFA9ZC5nZXRBdHRyaWJ1dGVWYWx1ZSh5LGYpO3JldHVybiBQIT1udWxsJiZQLnRvTG93ZXJDYXNlKCkhPT12JiZhKHkpfSk6ZnVuY3Rpb24oeSl7cmV0dXJuIGQuZ2V0QXR0cmlidXRlVmFsdWUoeSxmKSE9PXYmJmEoeSl9fX07dS5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKGEsbCxzKXtpZihzJiZzLnN0cmljdCYmKGwuaWdub3JlQ2FzZXx8bC5hY3Rpb249PT0ibm90IikpdGhyb3cgbmV3IEVycm9yKCJVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgc2VsZWN0b3IiKTtyZXR1cm4gaVtsLmFjdGlvbl0oYSxsLHMpfSxydWxlczppfX0sZnVuY3Rpb24odSxlLHQpe3ZhciByPXQoMjgzKSxuPXQoMjczKSxpPXQoMjgxKSxhPW4udHJ1ZUZ1bmMsbD1uLmZhbHNlRnVuYyxzPWkucnVsZXMuZXF1YWxzO2Z1bmN0aW9uIGYoTyxvKXt2YXIgaD17bmFtZTpPLHZhbHVlOm99O3JldHVybiBmdW5jdGlvbihnLGIsRSl7cmV0dXJuIHMoZyxoLEUpfX1mdW5jdGlvbiB2KE8sbyl7cmV0dXJuIGZ1bmN0aW9uKGgpe3JldHVybiEhby5nZXRQYXJlbnQoaCkmJk8oaCl9fXZhciBkPXtjb250YWluczpmdW5jdGlvbihPLG8saCl7dmFyIGM9aC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gTyhiKSYmYy5nZXRUZXh0KGIpLmluZGV4T2Yobyk+PTB9fSxpY29udGFpbnM6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPW8udG9Mb3dlckNhc2UoKSxnPWguYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oRSl7cmV0dXJuIE8oRSkmJmcuZ2V0VGV4dChFKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoYyk+PTB9fSwibnRoLWNoaWxkIjpmdW5jdGlvbihPLG8saCl7dmFyIGM9cihvKSxnPWguYWRhcHRlcjtyZXR1cm4gYz09PWw/YzpjPT09YT92KE8sZyk6ZnVuY3Rpb24oRSl7Zm9yKHZhciBBPWcuZ2V0U2libGluZ3MoRSksTD0wLE09MDtMPEEubGVuZ3RoO0wrKylpZihnLmlzVGFnKEFbTF0pKXtpZihBW0xdPT09RSlicmVhaztNKyt9cmV0dXJuIGMoTSkmJk8oRSl9fSwibnRoLWxhc3QtY2hpbGQiOmZ1bmN0aW9uKE8sbyxoKXt2YXIgYz1yKG8pLGc9aC5hZGFwdGVyO3JldHVybiBjPT09bD9jOmM9PT1hP3YoTyxnKTpmdW5jdGlvbihFKXtmb3IodmFyIEE9Zy5nZXRTaWJsaW5ncyhFKSxMPTAsTT1BLmxlbmd0aC0xO00+PTA7TS0tKWlmKGcuaXNUYWcoQVtNXSkpe2lmKEFbTV09PT1FKWJyZWFrO0wrK31yZXR1cm4gYyhMKSYmTyhFKX19LCJudGgtb2YtdHlwZSI6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPXIobyksZz1oLmFkYXB0ZXI7cmV0dXJuIGM9PT1sP2M6Yz09PWE/dihPLGcpOmZ1bmN0aW9uKEUpe2Zvcih2YXIgQT1nLmdldFNpYmxpbmdzKEUpLEw9MCxNPTA7TTxBLmxlbmd0aDtNKyspaWYoZy5pc1RhZyhBW01dKSl7aWYoQVtNXT09PUUpYnJlYWs7Zy5nZXROYW1lKEFbTV0pPT09Zy5nZXROYW1lKEUpJiZMKyt9cmV0dXJuIGMoTCkmJk8oRSl9fSwibnRoLWxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPXIobyksZz1oLmFkYXB0ZXI7cmV0dXJuIGM9PT1sP2M6Yz09PWE/dihPLGcpOmZ1bmN0aW9uKEUpe2Zvcih2YXIgQT1nLmdldFNpYmxpbmdzKEUpLEw9MCxNPUEubGVuZ3RoLTE7TT49MDtNLS0paWYoZy5pc1RhZyhBW01dKSl7aWYoQVtNXT09PUUpYnJlYWs7Zy5nZXROYW1lKEFbTV0pPT09Zy5nZXROYW1lKEUpJiZMKyt9cmV0dXJuIGMoTCkmJk8oRSl9fSxyb290OmZ1bmN0aW9uKE8sbyxoKXt2YXIgYz1oLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiFjLmdldFBhcmVudChnKSYmTyhnKX19LHNjb3BlOmZ1bmN0aW9uKE8sbyxoLGMpe3ZhciBnPWguYWRhcHRlcjtpZighY3x8Yy5sZW5ndGg9PT0wKXJldHVybiBkLnJvb3QoTyxvLGgpO2Z1bmN0aW9uIGIoRSxBKXtyZXR1cm4gdHlwZW9mIGcuZXF1YWxzPT0iZnVuY3Rpb24iP2cuZXF1YWxzKEUsQSk6RT09PUF9cmV0dXJuIGMubGVuZ3RoPT09MT9mdW5jdGlvbihFKXtyZXR1cm4gYihjWzBdLEUpJiZPKEUpfTpmdW5jdGlvbihFKXtyZXR1cm4gYy5pbmRleE9mKEUpPj0wJiZPKEUpfX0sY2hlY2tib3g6ZigidHlwZSIsImNoZWNrYm94IiksZmlsZTpmKCJ0eXBlIiwiZmlsZSIpLHBhc3N3b3JkOmYoInR5cGUiLCJwYXNzd29yZCIpLHJhZGlvOmYoInR5cGUiLCJyYWRpbyIpLHJlc2V0OmYoInR5cGUiLCJyZXNldCIpLGltYWdlOmYoInR5cGUiLCJpbWFnZSIpLHN1Ym1pdDpmKCJ0eXBlIiwic3VibWl0IiksaG92ZXI6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPWguYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGMuaXNIb3ZlcmVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGIpe3JldHVybiBPKGIpJiZjLmlzSG92ZXJlZChiKX06bH0sdmlzaXRlZDpmdW5jdGlvbihPLG8saCl7dmFyIGM9aC5hZGFwdGVyO3JldHVybiB0eXBlb2YgYy5pc1Zpc2l0ZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYil7cmV0dXJuIE8oYikmJmMuaXNWaXNpdGVkKGIpfTpsfSxhY3RpdmU6ZnVuY3Rpb24oTyxvLGgpe3ZhciBjPWguYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGMuaXNBY3RpdmU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYil7cmV0dXJuIE8oYikmJmMuaXNBY3RpdmUoYil9Omx9fTtmdW5jdGlvbiBwKE8sbyl7Zm9yKHZhciBoPTA7TyYmaDxPLmxlbmd0aDtoKyspaWYoby5pc1RhZyhPW2hdKSlyZXR1cm4gT1toXX12YXIgeT17ZW1wdHk6ZnVuY3Rpb24oTyxvKXtyZXR1cm4hby5nZXRDaGlsZHJlbihPKS5zb21lKGZ1bmN0aW9uKGgpe3JldHVybiBvLmlzVGFnKGgpfHxoLnR5cGU9PT0idGV4dCJ9KX0sImZpcnN0LWNoaWxkIjpmdW5jdGlvbihPLG8pe3JldHVybiBwKG8uZ2V0U2libGluZ3MoTyksbyk9PT1PfSwibGFzdC1jaGlsZCI6ZnVuY3Rpb24oTyxvKXtmb3IodmFyIGg9by5nZXRTaWJsaW5ncyhPKSxjPWgubGVuZ3RoLTE7Yz49MDtjLS0pe2lmKGhbY109PT1PKXJldHVybiEwO2lmKG8uaXNUYWcoaFtjXSkpYnJlYWt9cmV0dXJuITF9LCJmaXJzdC1vZi10eXBlIjpmdW5jdGlvbihPLG8pe2Zvcih2YXIgaD1vLmdldFNpYmxpbmdzKE8pLGM9MDtjPGgubGVuZ3RoO2MrKylpZihvLmlzVGFnKGhbY10pKXtpZihoW2NdPT09TylyZXR1cm4hMDtpZihvLmdldE5hbWUoaFtjXSk9PT1vLmdldE5hbWUoTykpYnJlYWt9cmV0dXJuITF9LCJsYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKE8sbyl7Zm9yKHZhciBoPW8uZ2V0U2libGluZ3MoTyksYz1oLmxlbmd0aC0xO2M+PTA7Yy0tKWlmKG8uaXNUYWcoaFtjXSkpe2lmKGhbY109PT1PKXJldHVybiEwO2lmKG8uZ2V0TmFtZShoW2NdKT09PW8uZ2V0TmFtZShPKSlicmVha31yZXR1cm4hMX0sIm9ubHktb2YtdHlwZSI6ZnVuY3Rpb24oTyxvKXtmb3IodmFyIGg9by5nZXRTaWJsaW5ncyhPKSxjPTAsZz1oLmxlbmd0aDtjPGc7YysrKWlmKG8uaXNUYWcoaFtjXSkpe2lmKGhbY109PT1PKWNvbnRpbnVlO2lmKG8uZ2V0TmFtZShoW2NdKT09PW8uZ2V0TmFtZShPKSlyZXR1cm4hMX1yZXR1cm4hMH0sIm9ubHktY2hpbGQiOmZ1bmN0aW9uKE8sbyl7Zm9yKHZhciBoPW8uZ2V0U2libGluZ3MoTyksYz0wO2M8aC5sZW5ndGg7YysrKWlmKG8uaXNUYWcoaFtjXSkmJmhbY10hPT1PKXJldHVybiExO3JldHVybiEwfSxsaW5rOmZ1bmN0aW9uKE8sbyl7cmV0dXJuIG8uaGFzQXR0cmliKE8sImhyZWYiKX0sc2VsZWN0ZWQ6ZnVuY3Rpb24oTyxvKXtpZihvLmhhc0F0dHJpYihPLCJzZWxlY3RlZCIpKXJldHVybiEwO2lmKG8uZ2V0TmFtZShPKSE9PSJvcHRpb24iKXJldHVybiExO3ZhciBoPW8uZ2V0UGFyZW50KE8pO2lmKCFofHxvLmdldE5hbWUoaCkhPT0ic2VsZWN0Inx8by5oYXNBdHRyaWIoaCwibXVsdGlwbGUiKSlyZXR1cm4hMTtmb3IodmFyIGM9by5nZXRDaGlsZHJlbihoKSxnPSExLGI9MDtiPGMubGVuZ3RoO2IrKylpZihvLmlzVGFnKGNbYl0pKWlmKGNbYl09PT1PKWc9ITA7ZWxzZSBpZihnKXtpZihvLmhhc0F0dHJpYihjW2JdLCJzZWxlY3RlZCIpKXJldHVybiExfWVsc2UgcmV0dXJuITE7cmV0dXJuIGd9LGRpc2FibGVkOmZ1bmN0aW9uKE8sbyl7cmV0dXJuIG8uaGFzQXR0cmliKE8sImRpc2FibGVkIil9LGVuYWJsZWQ6ZnVuY3Rpb24oTyxvKXtyZXR1cm4hby5oYXNBdHRyaWIoTywiZGlzYWJsZWQiKX0sY2hlY2tlZDpmdW5jdGlvbihPLG8pe3JldHVybiBvLmhhc0F0dHJpYihPLCJjaGVja2VkIil8fHkuc2VsZWN0ZWQoTyxvKX0scmVxdWlyZWQ6ZnVuY3Rpb24oTyxvKXtyZXR1cm4gby5oYXNBdHRyaWIoTywicmVxdWlyZWQiKX0sb3B0aW9uYWw6ZnVuY3Rpb24oTyxvKXtyZXR1cm4hby5oYXNBdHRyaWIoTywicmVxdWlyZWQiKX0scGFyZW50OmZ1bmN0aW9uKE8sbyl7cmV0dXJuIXkuZW1wdHkoTyxvKX0saGVhZGVyOlAoWyJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiXSksYnV0dG9uOmZ1bmN0aW9uKE8sbyl7dmFyIGg9by5nZXROYW1lKE8pO3JldHVybiBoPT09ImJ1dHRvbiJ8fGg9PT0iaW5wdXQiJiZvLmdldEF0dHJpYnV0ZVZhbHVlKE8sInR5cGUiKT09PSJidXR0b24ifSxpbnB1dDpQKFsiaW5wdXQiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsImJ1dHRvbiJdKSx0ZXh0OmZ1bmN0aW9uKE8sbyl7dmFyIGg7cmV0dXJuIG8uZ2V0TmFtZShPKT09PSJpbnB1dCImJighKGg9by5nZXRBdHRyaWJ1dGVWYWx1ZShPLCJ0eXBlIikpfHxoLnRvTG93ZXJDYXNlKCk9PT0idGV4dCIpfX07ZnVuY3Rpb24gUChPKXtpZih0eXBlb2YgU2V0PCJ1Iil7dmFyIG89bmV3IFNldChPKTtyZXR1cm4gZnVuY3Rpb24oaCxjKXtyZXR1cm4gby5oYXMoYy5nZXROYW1lKGgpKX19cmV0dXJuIGZ1bmN0aW9uKGgsYyl7cmV0dXJuIE8uaW5kZXhPZihjLmdldE5hbWUoaCkpPj0wfX1mdW5jdGlvbiB4KE8sbyxoKXtpZihoPT09bnVsbCl7aWYoTy5sZW5ndGg+MiYmbyE9PSJzY29wZSIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIrbysiIHJlcXVpcmVzIGFuIGFyZ3VtZW50Iil9ZWxzZSBpZihPLmxlbmd0aD09PTIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIrbysiIGRvZXNuJ3QgaGF2ZSBhbnkgYXJndW1lbnRzIil9dmFyIG09L14oPzooPzpudGh8bGFzdHxmaXJzdHxvbmx5KS0oPzpjaGlsZHxvZi10eXBlKXxyb290fGVtcHR5fCg/OmVufGRpcylhYmxlZHxjaGVja2VkfG5vdCkkLzt1LmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24oTyxvLGgsYyl7dmFyIGc9by5uYW1lLGI9by5kYXRhLEU9aC5hZGFwdGVyO2lmKGgmJmguc3RyaWN0JiYhbS50ZXN0KGcpKXRocm93IG5ldyBFcnJvcigiOiIrZysiIGlzbid0IHBhcnQgb2YgQ1NTMyIpO2lmKHR5cGVvZiBkW2ddPT0iZnVuY3Rpb24iKXJldHVybiBkW2ddKE8sYixoLGMpO2lmKHR5cGVvZiB5W2ddPT0iZnVuY3Rpb24iKXt2YXIgQT15W2ddO3JldHVybiB4KEEsZyxiKSxBPT09bD9BOk89PT1hP2Z1bmN0aW9uKE0pe3JldHVybiBBKE0sRSxiKX06ZnVuY3Rpb24oTSl7cmV0dXJuIEEoTSxFLGIpJiZPKE0pfX1lbHNlIHRocm93IG5ldyBFcnJvcigidW5tYXRjaGVkIHBzZXVkby1jbGFzcyA6IitnKX0sZmlsdGVyczpkLHBzZXVkb3M6eX19LGZ1bmN0aW9uKHUsZSx0KXt2YXIgcj10KDI4NCksbj10KDI4NSk7dS5leHBvcnRzPWZ1bmN0aW9uKGEpe3JldHVybiBuKHIoYSkpfSx1LmV4cG9ydHMucGFyc2U9cix1LmV4cG9ydHMuY29tcGlsZT1ufSxmdW5jdGlvbih1LGUpe3UuZXhwb3J0cz1yO3ZhciB0PS9eKFsrXC1dP1xkKm4pP1xzKig/OihbK1wtXT8pXHMqKFxkKykpPyQvO2Z1bmN0aW9uIHIobil7aWYobj1uLnRyaW0oKS50b0xvd2VyQ2FzZSgpLG49PT0iZXZlbiIpcmV0dXJuWzIsMF07aWYobj09PSJvZGQiKXJldHVyblsyLDFdO3ZhciBpPW4ubWF0Y2godCk7aWYoIWkpdGhyb3cgbmV3IFN5bnRheEVycm9yKCJuLXRoIHJ1bGUgY291bGRuJ3QgYmUgcGFyc2VkICgnIituKyInKSIpO3ZhciBhO3JldHVybiBpWzFdPyhhPXBhcnNlSW50KGlbMV0sMTApLGlzTmFOKGEpJiYoaVsxXS5jaGFyQXQoMCk9PT0iLSI/YT0tMTphPTEpKTphPTAsW2EsaVszXT9wYXJzZUludCgoaVsyXXx8IiIpK2lbM10sMTApOjBdfX0sZnVuY3Rpb24odSxlLHQpe3UuZXhwb3J0cz1hO3ZhciByPXQoMjczKSxuPXIudHJ1ZUZ1bmMsaT1yLmZhbHNlRnVuYztmdW5jdGlvbiBhKGwpe3ZhciBzPWxbMF0sZj1sWzFdLTE7aWYoZjwwJiZzPD0wKXJldHVybiBpO2lmKHM9PT0tMSlyZXR1cm4gZnVuY3Rpb24oZCl7cmV0dXJuIGQ8PWZ9O2lmKHM9PT0wKXJldHVybiBmdW5jdGlvbihkKXtyZXR1cm4gZD09PWZ9O2lmKHM9PT0xKXJldHVybiBmPDA/bjpmdW5jdGlvbihkKXtyZXR1cm4gZD49Zn07dmFyIHY9ZiVzO3JldHVybiB2PDAmJih2Kz1zKSxzPjE/ZnVuY3Rpb24oZCl7cmV0dXJuIGQ+PWYmJmQlcz09PXZ9OihzKj0tMSxmdW5jdGlvbihkKXtyZXR1cm4gZDw9ZiYmZCVzPT09dn0pfX0sZnVuY3Rpb24odSxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciByPXQoMTIpLG49dCg3NCksaT10KDEpLGE9dCg2OCksbD10KDI1MCkscz10KDIxMyksZj10KDIxOCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYoRSxBKXtpZihFPT1udWxsKXJldHVybnt9O3ZhciBMPWQoRSxBKSxNLEk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhFKTtmb3IoST0wO0k8RC5sZW5ndGg7SSsrKU09RFtJXSwhKEEuaW5kZXhPZihNKT49MCkmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChFLE0pJiYoTFtNXT1FW01dKX1yZXR1cm4gTH1mdW5jdGlvbiBkKEUsQSl7aWYoRT09bnVsbClyZXR1cm57fTt2YXIgTD17fSxNPU9iamVjdC5rZXlzKEUpLEksRDtmb3IoRD0wO0Q8TS5sZW5ndGg7RCsrKUk9TVtEXSwhKEEuaW5kZXhPZihJKT49MCkmJihMW0ldPUVbSV0pO3JldHVybiBMfWNvbnN0IHA9e2FudGlhbGlhczohMCxhdXRvUmVuZGVyOiEwLGFscGhhOiEwfSx5PVN5bWJvbCgiYXV0b1JlbmRlciIpLFA9U3ltYm9sKCJyZW5kZXJlciIpLHg9U3ltYm9sKCJ0aW1lbGluZSIpLG09U3ltYm9sKCJwcmVwYXJlUmVuZGVyIiksTz1TeW1ib2woInRpY2tSZW5kZXIiKSxvPVN5bWJvbCgicGFzcyIpLGg9U3ltYm9sKCJmYm8iKSxjPVN5bWJvbCgidGlja2VycyIpLGc9U3ltYm9sKCJsYXllclRyYW5zZm9ybUludmVydCIpO2NsYXNzIGIgZXh0ZW5kcyBsLmRlZmF1bHR7Y29uc3RydWN0b3IoQT17fSl7aWYoc3VwZXIoKSwhQS5jYW52YXMpe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OlJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEM9ci5FTlYuY3JlYXRlQ2FudmFzKEQsUix7b2Zmc2NyZWVuOiEhQS5vZmZzY3JlZW4saWQ6QS5pZCxleHRyYTpBLmV4dHJhfSk7Qy5zdHlsZSYmKEMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIiksQy5kYXRhc2V0JiYoQy5kYXRhc2V0LmxheWVySWQ9QS5pZCksQy5jb250ZXh0VHlwZSYmKEEuY29udGV4dFR5cGU9Qy5jb250ZXh0VHlwZSksQS5jYW52YXM9Q31jb25zdCBMPUEuY2FudmFzLE09T2JqZWN0LmFzc2lnbih7fSxwLEEpO3RoaXNbeV09TS5hdXRvUmVuZGVyLGRlbGV0ZSBBLmF1dG9SZW5kZXI7Y29uc3QgST1NLlJlbmRlcmVyfHxyLlJlbmRlcmVyO3RoaXNbUF09bmV3IEkoTCxNKSx0aGlzLm9wdGlvbnM9QSx0aGlzLmlkPUEuaWQsdGhpc1tvXT1bXSx0aGlzLnNldFJlc29sdXRpb24oTCksdGhpcy5jYW52YXM9TCx0aGlzW3hdPW5ldyBuLlRpbWVsaW5lLHRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGwsdGhpc1tnXT1udWxsfWdldCBhdXRvUmVuZGVyKCl7cmV0dXJuIHRoaXNbeV19Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucz90aGlzLnBhcmVudC5vcHRpb25zLmRpc3BsYXlSYXRpbzoxfWdldCBoZWlnaHQoKXtjb25zdHtoZWlnaHQ6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEEvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGdsKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcj90aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuZ2w6bnVsbH1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpc31nZXQgb2Zmc2NyZWVuKCl7cmV0dXJuISF0aGlzLm9wdGlvbnMub2Zmc2NyZWVufHx0aGlzLmNhbnZhcy5fb2Zmc2NyZWVufWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbb119Z2V0IHByZXBhcmVSZW5kZXIoKXtyZXR1cm4gdGhpc1ttXT90aGlzW21dOlByb21pc2UucmVzb2x2ZSgpfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzW1BdfWdldCByZW5kZXJPZmZzZXQoKXtpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucyl7Y29uc3R7bGVmdDpBLHRvcDpMfT10aGlzLnBhcmVudC5vcHRpb25zO3JldHVybltBLExdfXJldHVyblt0aGlzLm9wdGlvbnMubGVmdHwwLHRoaXMub3B0aW9ucy50b3B8MF19Z2V0IHRpbWVsaW5lKCl7cmV0dXJuIHRoaXNbeF19Z2V0IHdpZHRoKCl7Y29uc3R7d2lkdGg6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEEvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3R7eDpBLHk6TH09dGhpcy5hdHRyaWJ1dGVzO3JldHVyblsxLDAsMCwxLEEsTF19Z2V0IGxheWVyVHJhbnNmb3JtSW52ZXJ0KCl7aWYodGhpc1tnXSlyZXR1cm4gdGhpc1tnXTtjb25zdCBBPXRoaXMudHJhbnNmb3JtTWF0cml4O3JldHVybiBBWzBdPT09MSYmQVsxXT09PTAmJkFbMl09PT0wJiZBWzNdPT09MSYmQVs0XT09PTAmJkFbNV09PT0wP251bGw6KHRoaXNbZ109aS5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLEEpLHRoaXNbZ10pfWZvcmNlQ29udGV4dExvc3MoKXtjb25zdCBBPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcjtpZihBKXtjb25zdCBMPUEuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9sb3NlX2NvbnRleHQiKTtpZihMKXJldHVybiBMLmxvc2VDb250ZXh0KCksITB9cmV0dXJuITF9YWRkUGFzcyh7dmVydGV4OkEsZnJhZ21lbnQ6TCxvcHRpb25zOk0sdW5pZm9ybXM6SX09e30pe2lmKHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcil7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Un09dGhpcy5nZXRSZXNvbHV0aW9uKCksQz10aGlzLnJlbmRlcmVyLmNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6QSxmcmFnbWVudDpMLG9wdGlvbnM6TX0pLEI9bmV3IHIuRmlndXJlMkQ7Qi5yZWN0KDAsMCxEL3RoaXMuZGlzcGxheVJhdGlvLFIvdGhpcy5kaXNwbGF5UmF0aW8pO2NvbnN0IHo9bmV3IHIuTWVzaDJEKEIpO3JldHVybiB6LnNldFVuaWZvcm1zKEkpLHouc2V0UHJvZ3JhbShDKSx0aGlzW29dLnB1c2goeiksdGhpcy5mb3JjZVVwZGF0ZSgpLHp9cmV0dXJuIG51bGx9ZGVsZXRlVGV4dHVyZShBKXtyZXR1cm4gT2JqZWN0KGYuZGVsZXRlVGV4dHVyZSkoQSx0aGlzLnJlbmRlcmVyKX1kaXNwYXRjaFBvaW50ZXJFdmVudChBKXtjb25zdCBMPUEudHlwZTtpZihMPT09Im1vdXNlZG93biJ8fEw9PT0ibW91c2V1cCJ8fEw9PT0ibW91c2Vtb3ZlIil7Y29uc3QgQz10aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldDtpZihDKXtpZihDLmxheWVyPT09dGhpcylyZXR1cm4gQy5kaXNwYXRjaEV2ZW50KEEpLCEwO3RoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGx9fWxldCBNLEk7Y29uc3QgRD10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O2lmKEQpe009QS54LEk9QS55O2NvbnN0IEM9RCxCPUNbMF0qTStDWzJdKkkrQ1s0XSx6PUNbMV0qTStDWzNdKkkrQ1s1XTtkZWxldGUgQS54LGRlbGV0ZSBBLnksZGVsZXRlIEEubGF5ZXJYLGRlbGV0ZSBBLmxheWVyWSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhBLHtsYXllclg6e3ZhbHVlOkIsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOnosY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpCLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6eixjb25maWd1cmFibGU6ITB9fSl9Y29uc3QgUj1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChBKTtyZXR1cm4gRCYmT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQSx7bGF5ZXJYOnt2YWx1ZTpNLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpJLGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6TSxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOkksY29uZmlndXJhYmxlOiEwfX0pLFJ9Zm9yY2VVcGRhdGUoKXtpZighdGhpc1ttXSlpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuaGFzT2Zmc2NyZWVuQ2FudmFzKXt0aGlzLnBhcmVudC5mb3JjZVVwZGF0ZSgpO2xldCBBPW51bGw7Y29uc3QgTD1uZXcgUHJvbWlzZShNPT57QT1NfSk7TC5fcmVzb2x2ZT1BLHRoaXNbbV09TH1lbHNle2xldCBBPW51bGwsTD1udWxsO2NvbnN0IE09bmV3IFByb21pc2UoST0+e0E9SSx0aGlzW3ldJiYoTD1PYmplY3QoYS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIE0uX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfSk7TS5fcmVzb2x2ZT1BLE0uX3JlcXVlc3RJRD1MLHRoaXNbbV09TX19Z2V0RkJPKCl7Y29uc3QgQT10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIse3dpZHRoOkwsaGVpZ2h0Ok19PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBBJiYoIXRoaXNbaF18fHRoaXNbaF0ud2lkdGghPT1MfHx0aGlzW2hdLmhlaWdodCE9PU0pPyh0aGlzW2hdPXt3aWR0aDpMLGhlaWdodDpNLHRhcmdldDpBLmNyZWF0ZUZCTygpLGJ1ZmZlcjpBLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSx0aGlzW2hdKTp0aGlzW2hdP3RoaXNbaF06bnVsbH11cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBBPXRoaXMucmVuZGVyZXIsTD1BLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxBLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtBLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PUw7Y29uc3QgTT1pLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO0Euc2V0R2xvYmFsVHJhbnNmb3JtKC4uLmkubWF0MmQubXVsdGlwbHkoTSxMLHRoaXMudHJhbnNmb3JtTWF0cml4KSl9fW9uUHJvcGVydHlDaGFuZ2UoQSxMLE0pe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoQSxMLE0pLEE9PT0iekluZGV4IiYmKHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleD1MKSxBPT09InRyYW5zZm9ybSJ8fEE9PT0idHJhbnNsYXRlInx8QT09PSJyb3RhdGUifHxBPT09InNjYWxlInx8QT09PSJza2V3Iil7Y29uc3QgST10aGlzW2ddO2lmKHRoaXNbZ109bnVsbCx0aGlzLnVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpLEkmJiF0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBEPXRoaXMucmVuZGVyZXIsUj1ELl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxELmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtELnNldEdsb2JhbFRyYW5zZm9ybSguLi5SKX19fV9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKXt0aGlzW21dJiYodGhpc1ttXS5fcmVxdWVzdElEJiZPYmplY3QoYS5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1ttXS5fcmVxdWVzdElEKSx0aGlzW21dLl9yZXNvbHZlKCksZGVsZXRlIHRoaXNbbV0pfXJlbmRlcih7Y2xlYXI6QT0hMH09e30pe2NvbnN0IEw9dGhpc1tvXS5sZW5ndGg/dGhpcy5nZXRGQk8oKTpudWxsO0wmJnRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5iaW5kRkJPKEwudGFyZ2V0KSxBJiZ0aGlzW1BdLmNsZWFyKCk7Y29uc3QgTT10aGlzLmRyYXcoKTtpZihNJiZNLmxlbmd0aCYmKHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhNKSx0aGlzLmNhbnZhcy5kcmF3JiZ0aGlzLmNhbnZhcy5kcmF3KCkpLEwpe2NvbnN0IEk9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLEQ9dGhpc1tvXS5sZW5ndGgse3dpZHRoOlIsaGVpZ2h0OkN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEI9WzAsMCxSL3RoaXMuZGlzcGxheVJhdGlvLEMvdGhpcy5kaXNwbGF5UmF0aW9dO3RoaXNbb10uZm9yRWFjaCgoeixLKT0+e3ouYmxlbmQ9ITAsei5zZXRUZXh0dXJlKEwudGFyZ2V0LnRleHR1cmUse3JlY3Q6Qn0pLEs9PT1ELTE/SS5iaW5kRkJPKG51bGwpOihMLnN3YXAoKSxJLmJpbmRGQk8oTC50YXJnZXQpKSx0aGlzW1BdLmNsZWFyKCksdGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKFt6XSl9KX10aGlzLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpBLGhlaWdodDpMfSl7Y29uc3QgTT10aGlzLnJlbmRlcmVyLEk9TS5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8TS5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgsRD1JWzRdLFI9SVs1XSxDPUlbMF0se3dpZHRoOkIsaGVpZ2h0Onp9PXRoaXMuZ2V0UmVzb2x1dGlvbigpOyhCIT09QXx8eiE9PUwpJiYoc3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6QSxoZWlnaHQ6TH0pLHRoaXMuY2FudmFzJiYodGhpcy5jYW52YXMud2lkdGg9QSx0aGlzLmNhbnZhcy5oZWlnaHQ9TCxNLnVwZGF0ZVJlc29sdXRpb24mJk0udXBkYXRlUmVzb2x1dGlvbigpKSx0aGlzLmF0dHJpYnV0ZXMuc2l6ZT1bQSxMXSx0aGlzW29dLmxlbmd0aCYmdGhpc1tvXS5mb3JFYWNoKEY9Pntjb25zdCBHPW5ldyByLkZpZ3VyZTJEO0cucmVjdCgwLDAsQS90aGlzLmRpc3BsYXlSYXRpbyxML3RoaXMuZGlzcGxheVJhdGlvKSxGLmNvbnRvdXJzPUcuY29udG91cnN9KSk7Y29uc3RbSyxRXT10aGlzLnJlbmRlck9mZnNldCxfPXRoaXMuZGlzcGxheVJhdGlvOyhEIT09S3x8UiE9PVF8fEMhPT1fKSYmKE0uc2V0R2xvYmFsVHJhbnNmb3JtKF8sMCwwLF8sSyxRKSxNLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PW51bGwsdGhpc1tnXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksdGhpcy5mb3JjZVVwZGF0ZSgpKX10aWNrKEE9bnVsbCxMPXt9KXtsZXR7ZHVyYXRpb246TT0xLzB9PUwsST12KEwsWyJkdXJhdGlvbiJdKTtjb25zdCBEPXRoaXMudGltZWxpbmUuZm9yayhJKSxSPXRoaXM7dGhpc1tjXT10aGlzW2NdfHxbXSx0aGlzW2NdLnB1c2goe2hhbmRsZXI6QSxkdXJhdGlvbjpNfSk7Y29uc3QgQz0oKT0+e2xldCBCPW51bGwsej1udWxsO2NvbnN0IEs9KCk9Pntjb25zdCBRPXRoaXNbY10ubWFwKCh7aGFuZGxlcjpfLGR1cmF0aW9uOkZ9KT0+e2NvbnN0IEc9TWF0aC5taW4oMSxELmN1cnJlbnRUaW1lL0YpO3JldHVybnt2YWx1ZTpfP18oRC5jdXJyZW50VGltZSxHKTpudWxsLHA6R319KTtSW09dfHwoUltPXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57Ult5XSYmUi5yZW5kZXIoKSxkZWxldGUgUltPXTtmb3IobGV0IF89US5sZW5ndGgtMTtfPj0wO18tLSl7Y29uc3R7dmFsdWU6RixwOkd9PVFbX107KEY9PT0hMXx8Rz49MSkmJnRoaXNbY10uc3BsaWNlKF8sMSl9dGhpc1tjXS5sZW5ndGg+MCYmQygpfSkpfTtpZih0aGlzW21dJiZ0aGlzW21dLl90eXBlIT09InRpY2tlciImJihPYmplY3QoYS5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1ttXS5fcmVxdWVzdElEKSxkZWxldGUgdGhpc1ttXSksIXRoaXNbbV0pe2NvbnN0IFE9bmV3IFByb21pc2UoXz0+e0I9Xyx6PU9iamVjdChhLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoSyl9KTtRLl9yZXNvbHZlPUIsUS5fcmVxdWVzdElEPXosUS5fdHlwZT0idGlja2VyIix0aGlzW21dPVF9fTtDKCl9dG9HbG9iYWxQb3MoQSxMKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBCPXRoaXMudHJhbnNmb3JtTWF0cml4O0E9QlswXSpBK0JbMl0qTCtCWzRdLEw9QlsxXSpBK0JbM10qTCtCWzVdfWNvbnN0e3dpZHRoOk0saGVpZ2h0Okl9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEQ9dGhpcy5yZW5kZXJPZmZzZXQsUj1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtBPUEqUlswXS9NK0RbMF0sTD1MKlJbMV0vSStEWzFdO2NvbnN0IEM9dGhpcy5kaXNwbGF5UmF0aW87cmV0dXJuIEEqPUMsTCo9QyxbQSxMXX10b0xvY2FsUG9zKEEsTCl7Y29uc3R7d2lkdGg6TSxoZWlnaHQ6SX09dGhpcy5nZXRSZXNvbHV0aW9uKCksRD10aGlzLnJlbmRlck9mZnNldCxSPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO0E9QSpNL1JbMF0tRFswXSxMPUwqSS9SWzFdLURbMV07Y29uc3QgQz10aGlzLmRpc3BsYXlSYXRpbztBLz1DLEwvPUM7Y29uc3QgQj10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O3JldHVybiBCJiYoQT1CWzBdKkErQlsyXSpMK0JbNF0sTD1CWzFdKkErQlszXSpMK0JbNV0pLFtBLExdfX1zLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsImxheWVyIil9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgcj10KDIyNCksbj10KDI4OCksaT10KDIxMyksYT10KDI1MiksbD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyhPLG8pe2lmKE89PW51bGwpcmV0dXJue307dmFyIGg9ZihPLG8pLGMsZztpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgYj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pO2ZvcihnPTA7ZzxiLmxlbmd0aDtnKyspYz1iW2ddLCEoby5pbmRleE9mKGMpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKE8sYykmJihoW2NdPU9bY10pfXJldHVybiBofWZ1bmN0aW9uIGYoTyxvKXtpZihPPT1udWxsKXJldHVybnt9O3ZhciBoPXt9LGM9T2JqZWN0LmtleXMoTyksZyxiO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspZz1jW2JdLCEoby5pbmRleE9mKGcpPj0wKSYmKGhbZ109T1tnXSk7cmV0dXJuIGh9ZnVuY3Rpb24gdihPLG8saCl7cmV0dXJuIG8gaW4gTz9PYmplY3QuZGVmaW5lUHJvcGVydHkoTyxvLHt2YWx1ZTpoLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6T1tvXT1oLE99Y29uc3QgZD0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLHA9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIikseT1TeW1ib2woInJvb3QiKSxQPVN5bWJvbCgidGFzayIpO2Z1bmN0aW9uIHgoTyxvPSEwKXtjb25zdCBoPU9beV07aWYoaCYmaC5jaGlsZHJlblswXSl7Y29uc3QgYz1PLnN2ZyxnPU8ubGF5ZXI/Ty5sYXllci5kaXNwbGF5UmF0aW86MTtpZighYy5oYXNBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSl7bGV0IEE9Yy5nZXRBdHRyaWJ1dGUoIndpZHRoIik7QT1BP09iamVjdChsLnNpemVUb1BpeGVsKShBKTozMDA7bGV0IEw9Yy5nZXRBdHRyaWJ1dGUoImhlaWdodCIpO0w9TD9PYmplY3QobC5zaXplVG9QaXhlbCkoTCk6MTUwLGMuaGFzQXR0cmlidXRlKCJ2aWV3Qm94Iil8fGMuc2V0QXR0cmlidXRlKCJ2aWV3Qm94IixgMCAwICR7TWF0aC5yb3VuZChBKX0gJHtNYXRoLnJvdW5kKEwpfWApLGMuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIixBKSxjLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiLEwpfWxldCBiPU8uYXR0cmlidXRlcy53aWR0aHx8TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpLEU9Ty5hdHRyaWJ1dGVzLmhlaWdodHx8TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIpKTtpZihiKj1nLEUqPWcsbyYmTy5hdHRyaWJ1dGVzLmZsZXhpYmxlKXtjb25zdCBBPU8uYXR0cmlidXRlcy5zY2FsZVswXTtpZihiKj1BLEUqPUEsYy5zZXRBdHRyaWJ1dGUoIndpZHRoIixiKSxjLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixFKSxiJiZFJiZPLnRleHR1cmVJbWFnZSl7Y29uc3QgTD1PLnRleHR1cmVJbWFnZS53aWR0aCxNPU8udGV4dHVyZUltYWdlLmhlaWdodCxJPU8uY2xpZW50U2l6ZTtPLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9WzAsMCxNYXRoLnJvdW5kKElbMF0qTC9iKSxNYXRoLnJvdW5kKElbMV0qTS9FKV19fWVsc2UgT1tQXXx8KGMuc2V0QXR0cmlidXRlKCJ3aWR0aCIsYiksYy5zZXRBdHRyaWJ1dGUoImhlaWdodCIsRSksT1tQXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57ZGVsZXRlIE9bUF07Y29uc3QgQT1oLmlubmVySFRNTCxMPW5ldyBCbG9iKFtBXSx7dHlwZToiaW1hZ2Uvc3ZnK3htbCJ9KSxNPVVSTC5jcmVhdGVPYmplY3RVUkwoTCksST1uZXcgSW1hZ2U7SS5vbmxvYWQ9ZnVuY3Rpb24oKXtJLndpZHRoJiZJLmhlaWdodD8oTy5hdHRyaWJ1dGVzW3BdKCJ0ZXh0dXJlIixJKSxPLmF0dHJpYnV0ZXMuZmxleGlibGUmJihPLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9bnVsbCkpOk8uYXR0cmlidXRlc1twXSgidGV4dHVyZSIsbnVsbCl9LEkuc3JjPU19KSl9fWNsYXNzIG0gZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3Iobz17fSl7dHlwZW9mIG89PSJzdHJpbmciJiYobz17c3ZnVGV4dDpvfSk7bGV0e3N2Z1RleHQ6aH09byxjPXMobyxbInN2Z1RleHQiXSk7aWYoc3VwZXIoYyksdGhpc1t5XT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxoKXt0aGlzW3ldLmlubmVySFRNTD1oO2NvbnN0IGc9dGhpc1t5XS5jaGlsZHJlblswXTtnP2cuc2V0QXR0cmlidXRlKCJ4bWxucyIsZCk6KGZldGNoKGgpLnRoZW4oYj0+Yi50ZXh0KCkpLnRoZW4oYj0+e3RoaXNbeV0uaW5uZXJIVE1MPWIsKCF0aGlzLm9ic2VydmVyfHx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUpJiZ4KHRoaXMpfSksaD1udWxsKX1pZighaCl7Y29uc3QgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZCwic3ZnIik7Zy5zZXRBdHRyaWJ1dGUoInhtbG5zIixkKSx0aGlzW3ldLmFwcGVuZENoaWxkKGcpfWlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPT0iZnVuY3Rpb24iKXtjb25zdCBnPW5ldyBNdXRhdGlvbk9ic2VydmVyKGI9Pnt4KHRoaXMsITEpfSk7Zy5vYnNlcnZlKHRoaXNbeV0se2F0dHJpYnV0ZXM6ITAsc3VidHJlZTohMCxjaGFyYWN0ZXJEYXRhOiEwLGNoaWxkTGlzdDohMH0pLHRoaXMub2JzZXJ2ZXI9Z319Z2V0IGNoaWxkcmVuKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgY2hpbGROb2Rlcygpe3JldHVyblt0aGlzLnN2Z119Z2V0IHN2Zygpe3JldHVybiB0aGlzW3ldP3RoaXNbeV0uY2hpbGRyZW5bMF06bnVsbH1zZXRSZXNvbHV0aW9uKHt3aWR0aDpvLGhlaWdodDpofSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6byxoZWlnaHQ6aH0pLHgodGhpcyl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQobyl7Y29uc3QgaD1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChvKTtpZihoJiZ0aGlzLmF0dHJpYnV0ZXMucGFzc0V2ZW50cyYmdHlwZW9mIE1vdXNlRXZlbnQ9PSJmdW5jdGlvbiIpe2NvbnN0e3g6Yyx5Omd9PW87bGV0W2IsRV09dGhpcy5nZXRPZmZzZXRQb3NpdGlvbihjLGcpO2NvbnN0IEE9by5vcmlnaW5hbEV2ZW50LEw9dGhpcy5hdHRyaWJ1dGVzLmFuY2hvcixNPXRoaXMuY2xpZW50U2l6ZTtiPShiK0xbMF0qTVswXSkvMixFPShFK0xbMV0qTVsxXSkvMjtjb25zdCBJPW8udHlwZTtpZihJPT09QS50eXBlKXtsZXQgRD1udWxsO2lmKEEgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KUQ9bmV3IE1vdXNlRXZlbnQoSSx7c2NyZWVuWDpiLHNjcmVlblk6RSxjbGllbnRYOmIsY2xpZW50WTpFLGJ1YmJsZXM6QS5idWJibGVzLGJ1dHRvbjpBLmJ1dHRvbixidXR0b25zOkEuYnV0dG9ucyxjYW5jZWxCdWJibGU6QS5jYW5jZWxCdWJibGUsY2FuY2VsYWJsZTpBLmNhbmNlbGFibGUsY3VycmVudFRhcmdldDpBLmN1cnJlbnRUYXJnZXQsZnJvbUVsZW1lbnQ6QS5mcm9tRWxlbWVudCxyZWxhdGVkVGFyZ2V0OkEucmVsYXRlZFRhcmdldCxyZXR1cm5WYWx1ZTpBLnJldHVyblZhbHVlLHNyY0VsZW1lbnQ6QS5zcmNFbGVtZW50LHRhcmdldDpBLnRhcmdldCx0b0VsZW1lbnQ6QS50b0VsZW1lbnQsd2hpY2g6QS53aXRjaH0pO2Vsc2UgaWYoQSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpe2xldCBSPW51bGw7Y29uc3QgQz1BLmNoYW5nZWRUb3VjaGVzfHxbQV07Zm9yKGxldCBCPTA7QjxDLmxlbmd0aDtCKyspe2NvbnN0IHo9Q1tCXTtpZihvLmlkZW50aWZpZXI9PT16LmlkZW50aWZpZXIpe1I9ejticmVha319aWYoUil7Y29uc3QgQj1uZXcgVG91Y2goe2lkZW50aWZpZXI6Ui5pZGVudGlmaWVyLHRhcmdldDpSLnRhcmdldCxjbGllbnRYOmIsY2xpZW50WTpFLHNjcmVlblg6YixzY3JlZW5ZOkUscGFnZVg6YixwYWdlWTpFLHJhZGl1c1g6Ui5yYWRpdXNYLHJhZGl1c1k6Ui5yYWRpdXNZLHJvdGF0aW9uQW5nbGU6Ui5yb3RhdGlvbkFuZ2xlLGZvcmNlOlIuZm9yY2V9KTtEPW5ldyBUb3VjaEV2ZW50KEkse2NhbmNlbGFibGU6QS5jYW5jZWxhYmxlLGJ1YmJsZXM6QS5idWJibGVzLGNvbXBvc2VkOkEuY29tcG9zZWQsdG91Y2hlczpbQl0sdGFyZ2V0VG91Y2hlczpbQl0sY2hhbmdlZFRvdWNoZXM6W0JdfSl9fWVsc2UgRD1BO0QmJnRoaXMuc3ZnLmRpc3BhdGNoRXZlbnQoRCl9fXJldHVybiBofWdldEVsZW1lbnRCeUlkKG8pe3JldHVybiBPYmplY3QoYS5xdWVyeVNlbGVjdG9yKShgIyR7b31gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUobyl7cmV0dXJuIE9iamVjdChhLnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtvfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUobyl7cmV0dXJuIE9iamVjdChhLnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtvfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShvKXtyZXR1cm4gT2JqZWN0KGEucXVlcnlTZWxlY3RvckFsbCkobyx0aGlzKX1xdWVyeVNlbGVjdG9yKG8pe3JldHVybiBPYmplY3QoYS5xdWVyeVNlbGVjdG9yKShvLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwobyl7cmV0dXJuIE9iamVjdChhLnF1ZXJ5U2VsZWN0b3JBbGwpKG8sdGhpcyl9b25Qcm9wZXJ0eUNoYW5nZShvLGgsYyl7c3VwZXIub25Qcm9wZXJ0eUNoYW5nZShvLGgsYyksbz09PSJmbGV4aWJsZSImJngodGhpcyksdGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYobz09PSJ3aWR0aCJ8fG89PT0iaGVpZ2h0Inx8bz09PSJzY2FsZSJ8fG89PT0idHJhbnNmb3JtIikmJngodGhpcyl9fXYobSwiQXR0ciIsbi5kZWZhdWx0KSxpLmRlZmF1bHQucmVnaXN0ZXJOb2RlKG0sInNwcml0ZXN2ZyIpfSxmdW5jdGlvbih1LGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgyMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBuPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iik7Y2xhc3MgbCBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW2FdKHtwYXNzRXZlbnRzOiExLGZsZXhpYmxlOiExfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tuXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe31nZXQgcGFzc0V2ZW50cygpe3JldHVybiB0aGlzW25dKCJwYXNzRXZlbnRzIil9c2V0IHBhc3NFdmVudHMoZil7cmV0dXJuIHRoaXNbaV0oInBhc3NFdmVudHMiLGYpfWdldCBmbGV4aWJsZSgpe3JldHVybiB0aGlzW25dKCJmbGV4aWJsZSIpfXNldCBmbGV4aWJsZShmKXtyZXR1cm4gdGhpc1tpXSgiZmxleGlibGUiLGYpfX19LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oZix2KXt2YXIgZD1PYmplY3Qua2V5cyhmKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGYpO3YmJihwPXAuZmlsdGVyKGZ1bmN0aW9uKHkpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGYseSkuZW51bWVyYWJsZX0pKSxkLnB1c2guYXBwbHkoZCxwKX1yZXR1cm4gZH1mdW5jdGlvbiBpKGYpe2Zvcih2YXIgdj0xO3Y8YXJndW1lbnRzLmxlbmd0aDt2Kyspe3ZhciBkPWFyZ3VtZW50c1t2XSE9bnVsbD9hcmd1bWVudHNbdl06e307diUyP24oT2JqZWN0KGQpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHApe2EoZixwLGRbcF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhkKSk6bihPYmplY3QoZCkpLmZvckVhY2goZnVuY3Rpb24ocCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGYscCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGQscCkpfSl9cmV0dXJuIGZ9ZnVuY3Rpb24gYShmLHYsZCl7cmV0dXJuIHYgaW4gZj9PYmplY3QuZGVmaW5lUHJvcGVydHkoZix2LHt2YWx1ZTpkLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Zlt2XT1kLGZ9Y29uc3QgbD1TeW1ib2woImluaXRlZCIpO2xldCBzPW51bGw7dHlwZW9mIFdvcmtlcj09ImZ1bmN0aW9uIiYmKHM9Y2xhc3MgZXh0ZW5kcyBXb3JrZXJ7Y29uc3RydWN0b3IoZil7aWYoZi53b3JrZXI9PT0hMCYmKGYud29ya2VyPWAuLyR7Zi5pZH0ud29ya2VyLmpzYCksc3VwZXIoZi53b3JrZXIpLHRoaXMub3B0aW9ucz1mLCFmLmNhbnZhcyl7Y29uc3R7d2lkdGg6dixoZWlnaHQ6ZH09dGhpcy5nZXRSZXNvbHV0aW9uKCkscD1yLkVOVi5jcmVhdGVDYW52YXModixkLHtvZmZzY3JlZW46ITF9KTtwLnN0eWxlJiYocC5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxwLmRhdGFzZXQmJihwLmRhdGFzZXQubGF5ZXJJZD1mLmlkKSxmLmNhbnZhcz1wfXRoaXMuY2FudmFzPWYuY2FudmFzfWdldCBpZCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaWR9c2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6dn0pe2lmKHRoaXNbbF0pdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToicmVzb2x1dGlvbl9jaGFuZ2UiLHdpZHRoOmYsaGVpZ2h0OnZ9KTtlbHNle3RoaXMuY2FudmFzLndpZHRoPWYsdGhpcy5jYW52YXMuaGVpZ2h0PXY7Y29uc3QgZD10aGlzLm9wdGlvbnMscD1kLmNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpLHk9aSh7fSxkKTtkZWxldGUgeS5jb250YWluZXIseS5jYW52YXM9cCx0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJjcmVhdGUiLG9wdGlvbnM6eX0sW3BdKSx0aGlzW2xdPSEwfX1nZXRSZXNvbHV0aW9uKCl7aWYodGhpcy5jYW52YXMpe2NvbnN0e3dpZHRoOmYsaGVpZ2h0OnZ9PXRoaXMuY2FudmFzO3JldHVybnt3aWR0aDpmLGhlaWdodDp2fX1yZXR1cm57d2lkdGg6MzAwLGhlaWdodDoxNTB9fXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1jb25uZWN0KGYsdil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOmYsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOnYsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9ZGlzY29ubmVjdCgpe2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXJ9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoZil7dGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiZXZlbnQiLGV2ZW50OntjYW5jZWxCdWJibGU6Zi5jYW5jZWxCdWJibGUsYnViYmxlczpmLmJ1YmJsZXMsZGV0YWlsOmYuZGV0YWlsLGlkZW50aWZpZXI6Zi5pZGVudGlmaWVyLGxheWVyWDpmLmxheWVyWCxsYXllclk6Zi5sYXllclksb3JpZ2luYWxYOmYub3JpZ2luYWxYLG9yaWdpbmFsWTpmLm9yaWdpbmFsWSx0eXBlOmYudHlwZSx4OmYueCx5OmYueX19KX19KSxlLmRlZmF1bHQ9c30sZnVuY3Rpb24odSxlLHQpe3QucihlKSwoZnVuY3Rpb24ocil7dC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KTt2YXIgbj10KDEyKSxpPXQoNjgpLGE9dCg3MCksbD10KDI4Nikscz10KDI4OSksZj10KDI1MCksdj10KDI5MSksZD10KDIxNCkscD10KDIxOCkseT10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFA9U3ltYm9sKCJlbnRlcmVkVGFyZ2V0cyIpO2Z1bmN0aW9uIHgoRSl7cmV0dXJuIEUuaWQ9RS5pZHx8YF9sYXllciR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwxMil9YCxFLmRhdGFzZXR8fChFLmRhdGFzZXQ9e30pLEUuZGF0YXNldC5sYXllcklkPUUuaWQsRS5jb25uZWN0PShBLEwpPT57RS5wYXJlbnQ9QSxPYmplY3QuZGVmaW5lUHJvcGVydHkoRSwiek9yZGVyIix7dmFsdWU6TCx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX0sRS5kaXNjb25uZWN0PUE9PntkZWxldGUgRS56T3JkZXJ9LEUuY2FudmFzPUUsRS5nZXRSZXNvbHV0aW9uPSgpPT4oe3dpZHRoOjAsaGVpZ2h0OjB9KSxFLnNldFJlc29sdXRpb249KCk9PiExLEUub3B0aW9ucz17aGFuZGxlRXZlbnQ6ITF9LEV9ZnVuY3Rpb24gbShFLEEpe2NvbnN0IEw9RS5jaGlsZHJlbjtsZXQgTT1udWxsO2ZvcihsZXQgST0wO0k8TC5sZW5ndGg7SSsrKXtjb25zdCBEPUxbSV07aWYoKEE9PT1EfHxNIT1udWxsKSYmKE09RCksTSYmTSE9PUEmJiFNLm9mZnNjcmVlbilyZXR1cm4gTS5jYW52YXN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gTyhFLEEpe2NvbnN0W0wsTV09RS5yZW5kZXJPZmZzZXQse3dpZHRoOkksaGVpZ2h0OkR9PUUuZ2V0UmVzb2x1dGlvbigpLFI9RS5kaXNwbGF5UmF0aW87RS5yZW5kZXJlci5kcmF3SW1hZ2UoQS5jYW52YXMsLUwvUiwtTS9SLEkvUixEL1IpfWNvbnN0IG89e307ZnVuY3Rpb24gaChFKXtjb25zdCBBPVsibW91c2Vkb3duIiwibW91c2V1cCIsIm1vdXNlbW92ZSIsIm1vdXNld2hlZWwiLCJ3aGVlbCIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoY2FuY2VsIiwiY2xpY2siLCJkYmxjbGljayIsImxvbmdwcmVzcyIsInRhcCIsImNvbnRleHRtZW51Il0sTD1FLmNvbnRhaW5lcjtMLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLE09Pntjb25zdCBJPUVbUF07aWYoSS5zaXplKXtjb25zdCBEPW5ldyBkLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTtELnNldE9yaWdpbmFsRXZlbnQoTSksWy4uLkldLmZvckVhY2goUj0+e1IuZGlzcGF0Y2hFdmVudChEKX0pLEVbUF0uY2xlYXIoKX19LHtwYXNzaXZlOiEwfSksQS5mb3JFYWNoKE09PntMLmFkZEV2ZW50TGlzdGVuZXIoTSxJPT57Y29uc3R7bGVmdDpELHRvcDpSLGRpc3BsYXlSYXRpbzpDfT1FLm9wdGlvbnMsQj1FLm9yZGVyZWRDaGlsZHJlbjtPYmplY3Qodi5kZWZhdWx0KShJLHtvZmZzZXRMZWZ0OkQsb2Zmc2V0VG9wOlIsZGlzcGxheVJhdGlvOkN9KS5mb3JFYWNoKEs9Pntjb25zdCBRPUsuaWRlbnRpZmllcjtpZihLLnR5cGU9PT0idG91Y2htb3ZlInx8Sy50eXBlPT09InRvdWNoZW5kIil7Y29uc3QgRj1vW1FdO0YmJkYuZGlzcGF0Y2hFdmVudChLKSxLLnR5cGU9PT0idG91Y2hlbmQiJiZkZWxldGUgb1tRXX1lbHNle2ZvcihsZXQgRj1CLmxlbmd0aC0xO0Y+PTA7Ri0tKXtjb25zdCBHPUJbRl07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe2lmKEcuZGlzcGF0Y2hQb2ludGVyRXZlbnQoSykmJksudGFyZ2V0IT09RylicmVhaztLLmNhbmNlbEJ1YmJsZT0hMX19aWYoSy50YXJnZXQ9PT1CWzBdKWZvcihsZXQgRj1CLmxlbmd0aC0xO0Y+PTA7Ri0tKXtjb25zdCBHPUJbRl07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe0sudGFyZ2V0PUc7YnJlYWt9fX1jb25zdCBfPUsudGFyZ2V0O2lmKEsudHlwZT09PSJ0b3VjaHN0YXJ0IiYmKG9bUV09Sy50YXJnZXQpLEsudHlwZT09PSJtb3VzZW1vdmUiKXtjb25zdCBGPUVbUF07bGV0IEc7aWYoXyl7Y29uc3QgdHQ9Xy5hbmNlc3RvcnN8fFtdO0c9bmV3IFNldChbXywuLi50dF0pfWVsc2UgRz1uZXcgU2V0O2NvbnN0IFg9T2JqZWN0LmVudHJpZXMoSSk7aWYoIUYuaGFzKF8pJiZfKXtjb25zdCB0dD1uZXcgZC5kZWZhdWx0KCJtb3VzZWVudGVyIik7dHQuc2V0T3JpZ2luYWxFdmVudChJKSxYLmZvckVhY2goKFtxLGh0XSk9Pnt0dFtxXT1odH0pLEYuYWRkKF8pLF8uZGlzcGF0Y2hFdmVudCh0dCk7Y29uc3QgbnQ9Xy5hbmNlc3RvcnM7bnQmJm50LmZvckVhY2gocT0+e3EgaW5zdGFuY2VvZiBhLmRlZmF1bHQmJiFGLmhhcyhxKSYmKEYuYWRkKHEpLHEuZGlzcGF0Y2hFdmVudCh0dCkpfSl9Y29uc3QgWj1uZXcgZC5kZWZhdWx0KCJtb3VzZWxlYXZlIik7Wi5zZXRPcmlnaW5hbEV2ZW50KEkpLFguZm9yRWFjaCgoW3R0LG50XSk9PntaW3R0XT1udH0pLFsuLi5GXS5mb3JFYWNoKHR0PT57Ry5oYXModHQpfHwoRi5kZWxldGUodHQpLHR0LmRpc3BhdGNoRXZlbnQoWikpfSl9fSl9LHtwYXNzaXZlOk0hPT0iY29udGV4dG1lbnUifSl9KX1mdW5jdGlvbiBjKEUsQSl7aWYoQSYmQS5zdHlsZSl7bGV0e3dpZHRoOkwsaGVpZ2h0Ok0sbW9kZTpJLGNvbnRhaW5lcjpEfT1FO2NvbnN0e2NsaWVudFdpZHRoOlIsY2xpZW50SGVpZ2h0OkN9PUQ7TD1MfHxSLE09TXx8QyxJPT09InN0YXRpYyI/KEEuc3R5bGUud2lkdGg9YCR7TH1weGAsQS5zdHlsZS5oZWlnaHQ9YCR7TX1weGApOihBLnN0eWxlLnRvcD0iMCIsQS5zdHlsZS5sZWZ0PSIwIixBLnN0eWxlLndpZHRoPWAke1J9cHhgLEEuc3R5bGUuaGVpZ2h0PWAke0N9cHhgLEEuc3R5bGUudHJhbnNmb3JtPSIiLEEuc3R5bGUud2Via2l0VHJhbnNmb3JtPSIiKX19Y29uc3QgZz1TeW1ib2woIm9mZnNjcmVlbkxheWVyQ291bnQiKTtjbGFzcyBiIGV4dGVuZHMgZi5kZWZhdWx0e2NvbnN0cnVjdG9yKEE9e30pe2lmKHN1cGVyKCksIUEuY29udGFpbmVyKWlmKHR5cGVvZiBuLkVOVi5Db250YWluZXI9PSJmdW5jdGlvbiIpQS5jb250YWluZXI9bmV3IG4uRU5WLkNvbnRhaW5lcihBLndpZHRofHwzMDAsQS5oZWlnaHR8fDE1MCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIk5vIGNvbnRhaW5lciBzcGVjaWZpZWQuIik7aWYodGhpcy5jb250YWluZXI9QS5jb250YWluZXIsdGhpcy5jb250YWluZXIuc3R5bGUmJih0aGlzLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd3x8KHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iKSx0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbnx8KHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSIpKSx0aGlzLm9wdGlvbnM9QSxBLmRpc3BsYXlSYXRpbz1BLmRpc3BsYXlSYXRpb3x8MSxBLm1vZGU9QS5tb2RlfHwic2NhbGUiLEEubGVmdD0wLEEudG9wPTAsQS5hdXRvUmVzaXplPUEuYXV0b1Jlc2l6ZSE9PSExLEEuYXV0b1Jlc2l6ZSl7bGV0IEw7aWYodHlwZW9mIGdsb2JhbFRoaXM8InUiP0w9Z2xvYmFsVGhpczpMPXR5cGVvZiB3aW5kb3c8InUiP3dpbmRvdzpyLEwuYWRkRXZlbnRMaXN0ZW5lcil7Y29uc3QgTT10aGlzO0wuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIixmdW5jdGlvbiBJKCl7dHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuY29udGFpbnMoTS5jb250YWluZXIpP00ucmVzaXplKCk6TC5yZW1vdmVFdmVudExpc3RlbmVyKCJyZXNpemUiLEkpfSl9fXRoaXNbUF09bmV3IFNldCx0aGlzLnNldFJlc29sdXRpb24oQSksaCh0aGlzKSx0aGlzW2ddPTB9Z2V0IGhhc09mZnNjcmVlbkNhbnZhcygpe3JldHVybiB0aGlzW2ddPjB9c2V0IGRpc3BsYXlSYXRpbyhBKXt0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvIT09QSYmKHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW89QSx0aGlzLnJlc2l6ZSgpKX1nZXQgZGlzcGxheVJhdGlvKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW99c2V0IGhlaWdodChBKXt0aGlzLm9wdGlvbnMuaGVpZ2h0IT09QSYmKHRoaXMub3B0aW9ucy5oZWlnaHQ9QSx0aGlzLnJlc2l6ZSgpKX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXMub3B0aW9ucy5oZWlnaHR9c2V0IG1vZGUoQSl7dGhpcy5vcHRpb25zLm1vZGUhPT1BJiYodGhpcy5vcHRpb25zLm1vZGU9QSx0aGlzLnJlc2l6ZSgpKX1nZXQgbW9kZSgpe3JldHVybiB0aGlzLm9wdGlvbnMubW9kZX1zZXQgd2lkdGgoQSl7dGhpcy5vcHRpb25zLndpZHRoIT09QSYmKHRoaXMub3B0aW9ucy53aWR0aD1BLHRoaXMucmVzaXplKCkpfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLm9wdGlvbnMud2lkdGh9YXBwZW5kQ2hpbGQoQSl7IShBIGluc3RhbmNlb2YgbC5kZWZhdWx0KSYmIShBIGluc3RhbmNlb2Ygcy5kZWZhdWx0KSYmeChBKTtjb25zdCBMPXN1cGVyLmFwcGVuZENoaWxkKEEpLE09QS5jYW52YXM7cmV0dXJuIEEub2Zmc2NyZWVuP3RoaXNbZ10rKzp0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChNKSxjKHRoaXMub3B0aW9ucyxNKSxBLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLEx9Zm9yY2VVcGRhdGUoKXt0aGlzLmhhc09mZnNjcmVlbkNhbnZhcyYmIXRoaXMuX3JlcXVlc3RJRCYmKHRoaXMuX3JlcXVlc3RJRD1PYmplY3QoaS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIHRoaXMuX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfWluc2VydEJlZm9yZShBLEwpeyEoQSBpbnN0YW5jZW9mIGwuZGVmYXVsdCkmJiEoQSBpbnN0YW5jZW9mIHMuZGVmYXVsdCkmJngoQSk7Y29uc3QgTT1zdXBlci5pbnNlcnRCZWZvcmUoQSxMKSxJPUEuY2FudmFzO2lmKCFBLm9mZnNjcmVlbil7Y29uc3QgRD1tKHRoaXMsQSk7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEksRCl9cmV0dXJuIGModGhpcy5vcHRpb25zLEkpLEEuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksTX1sYXllcihBPSJkZWZhdWx0IixMPXt9KXtMPU9iamVjdC5hc3NpZ24oe30sdGhpcy5vcHRpb25zLEwpLEwuaWQ9QTtjb25zdCBNPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgUj0wO1I8TS5sZW5ndGg7UisrKWlmKE1bUl0uaWQ9PT1BKXJldHVybiBNW1JdO2NvbnN0IEk9TC53b3JrZXI7bGV0IEQ7cmV0dXJuIEk/RD1uZXcgcy5kZWZhdWx0KEwpOkQ9bmV3IGwuZGVmYXVsdChMKSx0aGlzLmFwcGVuZENoaWxkKEQpLER9YXN5bmMgcHJlbG9hZCguLi5BKXtjb25zdCBMPVtdLE09W10sST1bXTtmb3IobGV0IEQ9MDtEPEEubGVuZ3RoO0QrKyl7Y29uc3QgUj1BW0RdO2xldCBDO2lmKHR5cGVvZiBSPT0ic3RyaW5nIilDPU9iamVjdChwLmxvYWRUZXh0dXJlKShSKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoUikpQz1PYmplY3QocC5sb2FkRnJhbWVzKSguLi5SKTtlbHNle2NvbnN0e2lkOkIsc3JjOnp9PVI7Qz1PYmplY3QocC5sb2FkVGV4dHVyZSkoeixCKX1DIGluc3RhbmNlb2YgUHJvbWlzZXx8KEM9UHJvbWlzZS5yZXNvbHZlKEMpKSxNLnB1c2goQy50aGVuKEI9PntMLnB1c2goQiksSVtEXT1CO2NvbnN0IHo9bmV3IGQuZGVmYXVsdCh7dHlwZToicHJlbG9hZCIsZGV0YWlsOntjdXJyZW50OkIsbG9hZGVkOkwscmVzb3VyY2VzOkF9fSk7dGhpcy5kaXNwYXRjaEV2ZW50KHopfSkpfXJldHVybiBhd2FpdCBQcm9taXNlLmFsbChNKSxJfXJlbW92ZUNoaWxkKEEpe2NvbnN0IEw9c3VwZXIucmVtb3ZlQ2hpbGQoQSk7aWYoTCl7QS5fcHJlcGFyZVJlbmRlckZpbmlzaGVkJiZBLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKTtjb25zdCBNPUEuY2FudmFzO00mJk0ucmVtb3ZlJiZNLnJlbW92ZSgpLEEub2Zmc2NyZWVuJiZ0aGlzW2ddLS19cmV0dXJuIEx9cmVuZGVyKCl7Y29uc3QgQT10aGlzLm9yZGVyZWRDaGlsZHJlbjtsZXQgTD1udWxsO2NvbnN0IE09W107Zm9yKGxldCBJPTA7STxBLmxlbmd0aDtJKyspe2NvbnN0IEQ9QVtJXSxSPU0ubGVuZ3RoPjA7aWYoRCBpbnN0YW5jZW9mIGwuZGVmYXVsdCYmIUQub2Zmc2NyZWVuKWlmKCFELmF1dG9SZW5kZXIpUiYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLE0ubGVuZ3RoPTApO2Vsc2UgaWYoTD1ELFIpe0QucmVuZGVyZXIuY2xlYXIoKTtmb3IobGV0IEM9MDtDPE0ubGVuZ3RoO0MrKyl7Y29uc3QgQj1NW0NdO0IucmVuZGVyKCksTyhELEIpfU0ubGVuZ3RoPTAsRC5yZW5kZXIoe2NsZWFyOiExfSl9ZWxzZSBELnByZXBhcmVSZW5kZXImJkQucmVuZGVyKCk7ZWxzZSBELm9mZnNjcmVlbj9MPyhELnByZXBhcmVSZW5kZXImJkQucmVuZGVyKCksTyhMLEQpKTpNLnB1c2goRCk6RCBpbnN0YW5jZW9mIHMuZGVmYXVsdCYmUiYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLE0ubGVuZ3RoPTApfX1yZXBsYWNlQ2hpbGQoQSxMKXtjb25zdCBNPXN1cGVyLnJlcGxhY2VDaGlsZChBLEwpO0wuY2FudmFzLnJlbW92ZSYmTC5jYW52YXMucmVtb3ZlKCksTC5vZmZzY3JlZW4mJnRoaXNbZ10tLTtjb25zdCBJPUEuY2FudmFzO2lmKCFBLm9mZnNjcmVlbil7Y29uc3QgRD1tKHRoaXMsQSk7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEksRCl9cmV0dXJuIGModGhpcy5vcHRpb25zLEkpLEEuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksTX1yZXNpemUoKXtjb25zdCBBPXRoaXMub3B0aW9uczt0aGlzLmNoaWxkcmVuLmZvckVhY2goTD0+e2MoQSxMLmNhbnZhcyl9KSx0aGlzLnNldFJlc29sdXRpb24oQSksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZXNpemUifSl9c2V0UmVzb2x1dGlvbih7d2lkdGg6QSxoZWlnaHQ6TH09e30pe2NvbnN0IE09dGhpcy5jb250YWluZXIse2NsaWVudFdpZHRoOkksY2xpZW50SGVpZ2h0OkR9PU07KEE9PW51bGx8fEw9PW51bGwpJiYoQT1BPz9JLEw9TD8/RCk7Y29uc3R7bW9kZTpSLGRpc3BsYXlSYXRpbzpDfT10aGlzLm9wdGlvbnM7aWYoQSo9QyxMKj1DLHRoaXMub3B0aW9ucy5sZWZ0PTAsdGhpcy5vcHRpb25zLnRvcD0wLFI9PT0ic3RpY2t5SGVpZ2h0Inx8Uj09PSJzdGlja3lMZWZ0Inx8Uj09PSJzdGlja3lSaWdodCIpe2NvbnN0IEI9QTtBPUkqTC9ELFI9PT0ic3RpY2t5SGVpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PS41KihBLUIpKSxSPT09InN0aWNreVJpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PUEtQil9ZWxzZSBpZihSPT09InN0aWNreVdpZHRoInx8Uj09PSJzdGlja3lUb3AifHxSPT09InN0aWNreUJvdHRvbSIpe2NvbnN0IEI9TDtMPUQqQS9JLFI9PT0ic3RpY2t5V2lkdGgiJiYodGhpcy5vcHRpb25zLnRvcD0uNSooTC1CKSksUj09PSJzdGlja3lCb3R0b20iJiYodGhpcy5vcHRpb25zLnRvcD1MLUIpfXN1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOkEsaGVpZ2h0Okx9KX1zbmFwc2hvdCh7b2Zmc2NyZWVuOkE9ITEsbGF5ZXJzOkx9PXt9KXtjb25zdCBNPUE/InNuYXBzaG90T2ZmU2NyZWVuQ2FudmFzIjoic25hcHNob3RDYW52YXMiLHt3aWR0aDpJLGhlaWdodDpEfT10aGlzLmdldFJlc29sdXRpb24oKTt0aGlzW01dPXRoaXNbTV18fG4uRU5WLmNyZWF0ZUNhbnZhcyhJLEQse29mZnNjcmVlbjpBfSk7Y29uc3QgUj10aGlzW01dLmdldENvbnRleHQoIjJkIik7TD1MfHx0aGlzLm9yZGVyZWRDaGlsZHJlbix0aGlzW01dLndpZHRoPUksdGhpc1tNXS5oZWlnaHQ9RDtmb3IobGV0IEM9MDtDPEwubGVuZ3RoO0MrKyl7Y29uc3QgQj1MW0NdO2lmKCFCLm9wdGlvbnMuaWdub3JlU25hcHNob3Qpe0IucmVuZGVyJiZCLnJlbmRlcigpO2NvbnN0IHo9Qi5jYW52YXM7eiYmeiE9PUImJlIuZHJhd0ltYWdlKHosMCwwLEksRCl9fXJldHVybiB0aGlzW01dfX10eXBlb2YgZG9jdW1lbnQ8InUiJiYoYi5wcm90b3R5cGUubGF5ZXIzZD1mdW5jdGlvbihFLEE9e30pe2NvbnN0IEw9QS51cmx8fCJodHRwczovL3VucGtnLmNvbS9zcHJpdGUtZXh0ZW5kLTNkL2Rpc3Qvc3ByaXRlLWV4dGVuZC0zZC5taW4uanMiO3JldHVybiBuZXcgUHJvbWlzZSgoTSxJKT0+e2NvbnN0IEQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0Iik7RC5hc3luYz0hMSxELnNyYz1MLEQub25sb2FkPSgpPT57dHJ5e00odGhpcy5sYXllcjNkKEUsQSkpfWNhdGNoKFIpe0koUil9fSxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoRCl9KX0pLHkuZGVmYXVsdC5yZWdpc3Rlck5vZGUoYiwic2NlbmUiKX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKHUsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgcj10KDIxNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oaSx7b2Zmc2V0VG9wOmE9MCxvZmZzZXRMZWZ0Omw9MCxkaXNwbGF5UmF0aW86cz0xfT17fSl7bGV0IGYsdjtjb25zdCBkPVtdLHtsZWZ0OnAsdG9wOnksd2lkdGg6UCxoZWlnaHQ6eH09aS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbT1pLnRhcmdldC53aWR0aCxPPWkudGFyZ2V0LmhlaWdodCxvPWkuY2hhbmdlZFRvdWNoZXN8fFtpXTtmb3IobGV0IGM9MDtjPG8ubGVuZ3RoO2MrKyl7Y29uc3QgZz1vW2NdLGI9Zy5pZGVudGlmaWVyLHtjbGllbnRYOkUsY2xpZW50WTpBfT1nO0UhPW51bGwmJkEhPW51bGwmJmQucHVzaCh7eDpNYXRoLnJvdW5kKChFfDApLXApLHk6TWF0aC5yb3VuZCgoQXwwKS15KSxpZGVudGlmaWVyOmJ9KX1kLmxlbmd0aDw9MCYmZC5wdXNoKHt4OmYseTp2fSk7Y29uc3QgaD1bXTtyZXR1cm4gZC5mb3JFYWNoKGM9PntjLnghPW51bGwmJmMueSE9bnVsbCYmKGY9KGMueCptL1AtbCkvcyx2PShjLnkqTy94LWEpL3MpO2NvbnN0IGc9bmV3IHIuZGVmYXVsdChpKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhnLHtsYXllclg6e3ZhbHVlOmYsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOnYsY29uZmlndXJhYmxlOiEwfSxvcmlnaW5hbFg6e3ZhbHVlOmMueH0sb3JpZ2luYWxZOnt2YWx1ZTpjLnl9LHg6e3ZhbHVlOmYsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTp2LGNvbmZpZ3VyYWJsZTohMH0saWRlbnRpZmllcjp7dmFsdWU6Yy5pZGVudGlmaWVyfX0pLGgucHVzaChnKX0pLGh9fV0pO0R0LnZlcnNpb24sRHQuQXJjLER0LkJsb2NrLER0LkNsb3VkLER0LkNvbG9yO2NvbnN0IFBuPUR0LkVsbGlwc2U7RHQuR3JhZGllbnQ7Y29uc3QgdGU9RHQuR3JvdXAsSGg9RHQuTGFiZWw7RHQuTGF5ZXIsRHQuTGF5ZXJXb3JrZXIsRHQuTm9kZSxEdC5QYXJhbGxlbDtjb25zdCBhZT1EdC5QYXRoLGVlPUR0LlBvbHlsaW5lLGFyPUR0LlJlY3Q7RHQuUmVndWxhcixEdC5SaW5nO2NvbnN0IEtoPUR0LlNjZW5lLFZoPUR0LlNwcml0ZTtEdC5TcHJpdGVTdmcsRHQuU3RhcixEdC5UcmlhbmdsZSxEdC5oZWxwZXJzLER0LmNyZWF0ZUVsZW1lbnQsRHQuaXNTcHJpdGVOb2RlLER0LnJlZ2lzdGVyTm9kZSxEdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsRHQuY2FuY2VsQW5pbWF0aW9uRnJhbWUsRHQuRU5WO2Z1bmN0aW9uIHZlKHUsZT0hMCl7Y29uc3QgdD11Lmxlbmd0aDtpZih0PDIpcmV0dXJuIiI7bGV0IHI9dVswXSxuPXVbMV07aWYodD09PTIpcmV0dXJuYE0ke3BlKHIpfUwke3BlKG4pfWA7bGV0IGk9IiI7Zm9yKGxldCBhPTIsbD10LTE7YTxsO2ErKylyPXVbYV0sbj11W2ErMV0saSs9bWUocixuKTtyZXR1cm4gZT9gTSR7bWUodVswXSx1WzFdKX1RJHtwZSh1WzFdKX0ke21lKHVbMV0sdVsyXSl9VCR7aX0ke21lKHVbdC0xXSx1WzBdKX0ke21lKHVbMF0sdVsxXSl9WmA6YE0ke3BlKHVbMF0pfVEke3BlKHVbMV0pfSR7bWUodVsxXSx1WzJdKX0ke3UubGVuZ3RoPjM/IlQiOiIifSR7aX1MJHtwZSh1W3QtMV0pfWB9dmFyIGxyPXtleHBvcnRzOnt9fTtsci5leHBvcnRzLGZ1bmN0aW9uKHUpe3ZhciBlPWZ1bmN0aW9uKCl7dmFyIHQ9U3RyaW5nLmZyb21DaGFyQ29kZSxyPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSIsbj0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLSQiLGk9e307ZnVuY3Rpb24gYShzLGYpe2lmKCFpW3NdKXtpW3NdPXt9O2Zvcih2YXIgdj0wO3Y8cy5sZW5ndGg7disrKWlbc11bcy5jaGFyQXQodildPXZ9cmV0dXJuIGlbc11bZl19dmFyIGw9e2NvbXByZXNzVG9CYXNlNjQ6ZnVuY3Rpb24ocyl7aWYocz09bnVsbClyZXR1cm4iIjt2YXIgZj1sLl9jb21wcmVzcyhzLDYsZnVuY3Rpb24odil7cmV0dXJuIHIuY2hhckF0KHYpfSk7c3dpdGNoKGYubGVuZ3RoJTQpe2RlZmF1bHQ6Y2FzZSAwOnJldHVybiBmO2Nhc2UgMTpyZXR1cm4gZisiPT09IjtjYXNlIDI6cmV0dXJuIGYrIj09IjtjYXNlIDM6cmV0dXJuIGYrIj0ifX0sZGVjb21wcmVzc0Zyb21CYXNlNjQ6ZnVuY3Rpb24ocyl7cmV0dXJuIHM9PW51bGw/IiI6cz09IiI/bnVsbDpsLl9kZWNvbXByZXNzKHMubGVuZ3RoLDMyLGZ1bmN0aW9uKGYpe3JldHVybiBhKHIscy5jaGFyQXQoZikpfSl9LGNvbXByZXNzVG9VVEYxNjpmdW5jdGlvbihzKXtyZXR1cm4gcz09bnVsbD8iIjpsLl9jb21wcmVzcyhzLDE1LGZ1bmN0aW9uKGYpe3JldHVybiB0KGYrMzIpfSkrIiAifSxkZWNvbXByZXNzRnJvbVVURjE2OmZ1bmN0aW9uKHMpe3JldHVybiBzPT1udWxsPyIiOnM9PSIiP251bGw6bC5fZGVjb21wcmVzcyhzLmxlbmd0aCwxNjM4NCxmdW5jdGlvbihmKXtyZXR1cm4gcy5jaGFyQ29kZUF0KGYpLTMyfSl9LGNvbXByZXNzVG9VaW50OEFycmF5OmZ1bmN0aW9uKHMpe2Zvcih2YXIgZj1sLmNvbXByZXNzKHMpLHY9bmV3IFVpbnQ4QXJyYXkoZi5sZW5ndGgqMiksZD0wLHA9Zi5sZW5ndGg7ZDxwO2QrKyl7dmFyIHk9Zi5jaGFyQ29kZUF0KGQpO3ZbZCoyXT15Pj4+OCx2W2QqMisxXT15JTI1Nn1yZXR1cm4gdn0sZGVjb21wcmVzc0Zyb21VaW50OEFycmF5OmZ1bmN0aW9uKHMpe2lmKHM9PW51bGwpcmV0dXJuIGwuZGVjb21wcmVzcyhzKTtmb3IodmFyIGY9bmV3IEFycmF5KHMubGVuZ3RoLzIpLHY9MCxkPWYubGVuZ3RoO3Y8ZDt2KyspZlt2XT1zW3YqMl0qMjU2K3NbdioyKzFdO3ZhciBwPVtdO3JldHVybiBmLmZvckVhY2goZnVuY3Rpb24oeSl7cC5wdXNoKHQoeSkpfSksbC5kZWNvbXByZXNzKHAuam9pbigiIikpfSxjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihzKXtyZXR1cm4gcz09bnVsbD8iIjpsLl9jb21wcmVzcyhzLDYsZnVuY3Rpb24oZil7cmV0dXJuIG4uY2hhckF0KGYpfSl9LGRlY29tcHJlc3NGcm9tRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihzKXtyZXR1cm4gcz09bnVsbD8iIjpzPT0iIj9udWxsOihzPXMucmVwbGFjZSgvIC9nLCIrIiksbC5fZGVjb21wcmVzcyhzLmxlbmd0aCwzMixmdW5jdGlvbihmKXtyZXR1cm4gYShuLHMuY2hhckF0KGYpKX0pKX0sY29tcHJlc3M6ZnVuY3Rpb24ocyl7cmV0dXJuIGwuX2NvbXByZXNzKHMsMTYsZnVuY3Rpb24oZil7cmV0dXJuIHQoZil9KX0sX2NvbXByZXNzOmZ1bmN0aW9uKHMsZix2KXtpZihzPT1udWxsKXJldHVybiIiO3ZhciBkLHAseT17fSxQPXt9LHg9IiIsbT0iIixPPSIiLG89MixoPTMsYz0yLGc9W10sYj0wLEU9MCxBO2ZvcihBPTA7QTxzLmxlbmd0aDtBKz0xKWlmKHg9cy5jaGFyQXQoQSksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHkseCl8fCh5W3hdPWgrKyxQW3hdPSEwKSxtPU8reCxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeSxtKSlPPW07ZWxzZXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUCxPKSl7aWYoTy5jaGFyQ29kZUF0KDApPDI1Nil7Zm9yKGQ9MDtkPGM7ZCsrKWI9Yjw8MSxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKys7Zm9yKHA9Ty5jaGFyQ29kZUF0KDApLGQ9MDtkPDg7ZCsrKWI9Yjw8MXxwJjEsRT09Zi0xPyhFPTAsZy5wdXNoKHYoYikpLGI9MCk6RSsrLHA9cD4+MX1lbHNle2ZvcihwPTEsZD0wO2Q8YztkKyspYj1iPDwxfHAsRT09Zi0xPyhFPTAsZy5wdXNoKHYoYikpLGI9MCk6RSsrLHA9MDtmb3IocD1PLmNoYXJDb2RlQXQoMCksZD0wO2Q8MTY7ZCsrKWI9Yjw8MXxwJjEsRT09Zi0xPyhFPTAsZy5wdXNoKHYoYikpLGI9MCk6RSsrLHA9cD4+MX1vLS0sbz09MCYmKG89TWF0aC5wb3coMixjKSxjKyspLGRlbGV0ZSBQW09dfWVsc2UgZm9yKHA9eVtPXSxkPTA7ZDxjO2QrKyliPWI8PDF8cCYxLEU9PWYtMT8oRT0wLGcucHVzaCh2KGIpKSxiPTApOkUrKyxwPXA+PjE7by0tLG89PTAmJihvPU1hdGgucG93KDIsYyksYysrKSx5W21dPWgrKyxPPVN0cmluZyh4KX1pZihPIT09IiIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChQLE8pKXtpZihPLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IoZD0wO2Q8YztkKyspYj1iPDwxLEU9PWYtMT8oRT0wLGcucHVzaCh2KGIpKSxiPTApOkUrKztmb3IocD1PLmNoYXJDb2RlQXQoMCksZD0wO2Q8ODtkKyspYj1iPDwxfHAmMSxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKysscD1wPj4xfWVsc2V7Zm9yKHA9MSxkPTA7ZDxjO2QrKyliPWI8PDF8cCxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKysscD0wO2ZvcihwPU8uY2hhckNvZGVBdCgwKSxkPTA7ZDwxNjtkKyspYj1iPDwxfHAmMSxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKysscD1wPj4xfW8tLSxvPT0wJiYobz1NYXRoLnBvdygyLGMpLGMrKyksZGVsZXRlIFBbT119ZWxzZSBmb3IocD15W09dLGQ9MDtkPGM7ZCsrKWI9Yjw8MXxwJjEsRT09Zi0xPyhFPTAsZy5wdXNoKHYoYikpLGI9MCk6RSsrLHA9cD4+MTtvLS0sbz09MCYmKG89TWF0aC5wb3coMixjKSxjKyspfWZvcihwPTIsZD0wO2Q8YztkKyspYj1iPDwxfHAmMSxFPT1mLTE/KEU9MCxnLnB1c2godihiKSksYj0wKTpFKysscD1wPj4xO2Zvcig7OylpZihiPWI8PDEsRT09Zi0xKXtnLnB1c2godihiKSk7YnJlYWt9ZWxzZSBFKys7cmV0dXJuIGcuam9pbigiIil9LGRlY29tcHJlc3M6ZnVuY3Rpb24ocyl7cmV0dXJuIHM9PW51bGw/IiI6cz09IiI/bnVsbDpsLl9kZWNvbXByZXNzKHMubGVuZ3RoLDMyNzY4LGZ1bmN0aW9uKGYpe3JldHVybiBzLmNoYXJDb2RlQXQoZil9KX0sX2RlY29tcHJlc3M6ZnVuY3Rpb24ocyxmLHYpe3ZhciBkPVtdLHA9NCx5PTQsUD0zLHg9IiIsbT1bXSxPLG8saCxjLGcsYixFLEE9e3ZhbDp2KDApLHBvc2l0aW9uOmYsaW5kZXg6MX07Zm9yKE89MDtPPDM7Tys9MSlkW09dPU87Zm9yKGg9MCxnPU1hdGgucG93KDIsMiksYj0xO2IhPWc7KWM9QS52YWwmQS5wb3NpdGlvbixBLnBvc2l0aW9uPj49MSxBLnBvc2l0aW9uPT0wJiYoQS5wb3NpdGlvbj1mLEEudmFsPXYoQS5pbmRleCsrKSksaHw9KGM+MD8xOjApKmIsYjw8PTE7c3dpdGNoKGgpe2Nhc2UgMDpmb3IoaD0wLGc9TWF0aC5wb3coMiw4KSxiPTE7YiE9ZzspYz1BLnZhbCZBLnBvc2l0aW9uLEEucG9zaXRpb24+Pj0xLEEucG9zaXRpb249PTAmJihBLnBvc2l0aW9uPWYsQS52YWw9dihBLmluZGV4KyspKSxofD0oYz4wPzE6MCkqYixiPDw9MTtFPXQoaCk7YnJlYWs7Y2FzZSAxOmZvcihoPTAsZz1NYXRoLnBvdygyLDE2KSxiPTE7YiE9ZzspYz1BLnZhbCZBLnBvc2l0aW9uLEEucG9zaXRpb24+Pj0xLEEucG9zaXRpb249PTAmJihBLnBvc2l0aW9uPWYsQS52YWw9dihBLmluZGV4KyspKSxofD0oYz4wPzE6MCkqYixiPDw9MTtFPXQoaCk7YnJlYWs7Y2FzZSAyOnJldHVybiIifWZvcihkWzNdPUUsbz1FLG0ucHVzaChFKTs7KXtpZihBLmluZGV4PnMpcmV0dXJuIiI7Zm9yKGg9MCxnPU1hdGgucG93KDIsUCksYj0xO2IhPWc7KWM9QS52YWwmQS5wb3NpdGlvbixBLnBvc2l0aW9uPj49MSxBLnBvc2l0aW9uPT0wJiYoQS5wb3NpdGlvbj1mLEEudmFsPXYoQS5pbmRleCsrKSksaHw9KGM+MD8xOjApKmIsYjw8PTE7c3dpdGNoKEU9aCl7Y2FzZSAwOmZvcihoPTAsZz1NYXRoLnBvdygyLDgpLGI9MTtiIT1nOyljPUEudmFsJkEucG9zaXRpb24sQS5wb3NpdGlvbj4+PTEsQS5wb3NpdGlvbj09MCYmKEEucG9zaXRpb249ZixBLnZhbD12KEEuaW5kZXgrKykpLGh8PShjPjA/MTowKSpiLGI8PD0xO2RbeSsrXT10KGgpLEU9eS0xLHAtLTticmVhaztjYXNlIDE6Zm9yKGg9MCxnPU1hdGgucG93KDIsMTYpLGI9MTtiIT1nOyljPUEudmFsJkEucG9zaXRpb24sQS5wb3NpdGlvbj4+PTEsQS5wb3NpdGlvbj09MCYmKEEucG9zaXRpb249ZixBLnZhbD12KEEuaW5kZXgrKykpLGh8PShjPjA/MTowKSpiLGI8PD0xO2RbeSsrXT10KGgpLEU9eS0xLHAtLTticmVhaztjYXNlIDI6cmV0dXJuIG0uam9pbigiIil9aWYocD09MCYmKHA9TWF0aC5wb3coMixQKSxQKyspLGRbRV0peD1kW0VdO2Vsc2UgaWYoRT09PXkpeD1vK28uY2hhckF0KDApO2Vsc2UgcmV0dXJuIG51bGw7bS5wdXNoKHgpLGRbeSsrXT1vK3guY2hhckF0KDApLHAtLSxvPXgscD09MCYmKHA9TWF0aC5wb3coMixQKSxQKyspfX19O3JldHVybiBsfSgpO3UhPW51bGw/dS5leHBvcnRzPWU6dHlwZW9mIGFuZ3VsYXI8InUiJiZhbmd1bGFyIT1udWxsJiZhbmd1bGFyLm1vZHVsZSgiTFpTdHJpbmciLFtdKS5mYWN0b3J5KCJMWlN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gZX0pfShscik7dmFyIFRuPWxyLmV4cG9ydHM7ZnVuY3Rpb24gemUodSl7cmV0dXJuIEpTT04ucGFyc2UoVG4uZGVjb21wcmVzcyh1KSl9ZnVuY3Rpb24gcXQodSl7cmV0dXJuIFRuLmNvbXByZXNzKEpTT04uc3RyaW5naWZ5KHUpKX1jbGFzcyBNbiBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuUGVuY2lsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY0luZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJNQVhfUkVQRUFSIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidW5pVGhpY2tuZXNzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNlbnRlclBvcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlswLDBdfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMudW5pVGhpY2tuZXNzPXRoaXMuTUFYX1JFUEVBUi90aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcy8xMCx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe3ZhciBhO2NvbnN0IGU9KGE9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDphLnRvU3RyaW5nKCksdD10aGlzLnRyYW5zZm9ybURhdGFBbGwoITApLHI9e25hbWU6ZX07bGV0IG47Y29uc3QgaT10aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7cmV0dXJuIHQubGVuZ3RoJiYobj10aGlzLmRyYXcoe2F0dHJzOnIsdGFza3M6dCxyZXBsYWNlSWQ6ZSxsYXllcjppLGlzQ2xlYXJBbGw6ITB9KSkse3JlY3Q6bix0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsfX1zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe3ZhciB4O2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNDbGVhckFsbDpuLGlzU3ViV29ya2VyOml9PWU7aWYoKCh4PXQub3ApPT1udWxsP3ZvaWQgMDp4Lmxlbmd0aCk9PT0wKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0e3dvcmtJZDphfT10LHt0YXNrczpsLGVmZmVjdHM6cyxjb25zdW1lSW5kZXg6Zn09dGhpcy50cmFuc2Zvcm1EYXRhKHQsITEpO3RoaXMuc3luY0luZGV4PU1hdGgubWluKHRoaXMuc3luY0luZGV4LGYsTWF0aC5tYXgoMCx0aGlzLnRtcFBvaW50cy5sZW5ndGgtMikpO2NvbnN0IHY9e25hbWU6YT09bnVsbD92b2lkIDA6YS50b1N0cmluZygpfTtsZXQgZCxwPSExO2NvbnN0IHk9dGhpcy5zeW5jSW5kZXg7aWYodGhpcy5zeW5jVGltZXN0YW1wPT09MCYmKHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpKSxsLmxlbmd0aCYmKGxbMF0udGFza0lkLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZSYmKHA9ITAsdGhpcy5zeW5jVGltZXN0YW1wPWxbMF0udGFza0lkLHRoaXMuc3luY0luZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aCksaSkpe2NvbnN0IG09cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7ZD10aGlzLmRyYXcoe2F0dHJzOnYsdGFza3M6bCxlZmZlY3RzOnMsbGF5ZXI6bSxpc0NsZWFyQWxsOm59KX1pZihpKXJldHVybiBmPjEwJiZ0aGlzLnRtcFBvaW50cy5zcGxpY2UoMCxmLTEwKSx7cmVjdDpkLHR5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWx9O2NvbnN0IFA9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKHkpLmZvckVhY2gobT0+e1AucHVzaChtLngsbS55LHRoaXMuY29tcHV0UmFkaXVzKG0ueix0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcykpfSkse3JlY3Q6ZCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDpwP2E6dm9pZCAwLG9wOnA/UDp2b2lkIDAsaW5kZXg6cD95KjM6dm9pZCAwfX1jb25zdW1lQWxsKGUpe3ZhciBmLHY7aWYoZS5kYXRhKXtjb25zdHtvcDpkLHdvcmtTdGF0ZTpwfT1lLmRhdGE7ZCE9bnVsbCYmZC5sZW5ndGgmJnA9PT1SdC5Eb25lJiZ0aGlzLndvcmtPcHRpb25zLnN0cm9rZVR5cGU9PT16dC5TdHJva2UmJnRoaXMudXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZVdoZW5Eb25lKGQpfWNvbnN0IHQ9KGY9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCk7aWYoIXQpcmV0dXJue3R5cGU6YXQuTm9uZX07Y29uc3Qgcj10aGlzLnRyYW5zZm9ybURhdGFBbGwoITApLG49e25hbWU6dH07bGV0IGk7Y29uc3QgYT10aGlzLmZ1bGxMYXllcjtyLmxlbmd0aCYmKGk9dGhpcy5kcmF3KHthdHRyczpuLHRhc2tzOnIscmVwbGFjZUlkOnQsbGF5ZXI6YSxpc0NsZWFyQWxsOiExfSkpO2NvbnN0IGw9W107dGhpcy50bXBQb2ludHMubWFwKGQ9PntsLnB1c2goZC54LGQueSx0aGlzLmNvbXB1dFJhZGl1cyhkLnosdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MpKX0pLHRoaXMuc3luY1RpbWVzdGFtcD0wLGRlbGV0ZSB0aGlzLndvcmtPcHRpb25zLnN5bmNVbml0VGltZTtjb25zdCBzPXF0KGwpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHQse3JlY3Q6aSxvcDpsLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxhKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6dCxvcHM6cyx1cGRhdGVOb2RlT3B0Ontwb3M6dGhpcy5jZW50ZXJQb3MsdXNlQW5pbWF0aW9uOiEwfSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx1bmRvVGlja2VySWQ6KHY9ZS5kYXRhKT09bnVsbD92b2lkIDA6di51bmRvVGlja2VySWR9fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jSW5kZXg9MH1jb25zdW1lU2VydmljZShlKXt2YXIgdjtjb25zdHtvcDp0LGlzRnVsbFdvcms6cixyZXBsYWNlSWQ6bixpc0NsZWFyQWxsOml9PWU7dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBkPTA7ZDx0Lmxlbmd0aDtkKz0zKXtjb25zdCBwPW5ldyB4dCh0W2RdLHRbZCsxXSx0W2QrMl0pO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD4wKXtjb25zdCB5PXRoaXMudG1wUG9pbnRzW3RoaXMudG1wUG9pbnRzLmxlbmd0aC0xXSxQPWV0LlN1YihwLHkpLnVuaSgpO3Auc2V0dihQKX10aGlzLnRtcFBvaW50cy5wdXNoKHApfWNvbnN0IGE9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCExKSxsPSh2PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6di50b1N0cmluZygpLHM9e25hbWU6bH07bGV0IGY7aWYobCYmYS5sZW5ndGgpe2NvbnN0IGQ9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7Zj10aGlzLmRyYXcoe2F0dHJzOnMsdGFza3M6YSxyZXBsYWNlSWQ6bixsYXllcjpkLGlzQ2xlYXJBbGw6aX0pLHRoaXMudk5vZGVzLnNldEluZm8obCx7cmVjdDpmLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmYmJnB0LmdldENlbnRlclBvcyhmLGQpfSl9cmV0dXJuIGZ9dHJhbnNmb3JtRGF0YUFsbChlPSEwKXtyZXR1cm4gdGhpcy5nZXRUYXNrUG9pbnRzKHRoaXMudG1wUG9pbnRzLGUmJnRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzfHx2b2lkIDApfWRyYXcoZSl7dmFyIGM7Y29uc3R7YXR0cnM6dCx0YXNrczpyLHJlcGxhY2VJZDpuLGVmZmVjdHM6aSxsYXllcjphLGlzQ2xlYXJBbGw6bH09ZSx7c3Ryb2tlQ29sb3I6cyxzdHJva2VUeXBlOmYsdGhpY2tuZXNzOnYsekluZGV4OmQsc2NhbGU6cCxyb3RhdGU6eSx0cmFuc2xhdGU6UH09dGhpcy53b3JrT3B0aW9ucztsJiZhLnJlbW92ZUFsbENoaWxkcmVuKCksbiYmKHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKG4rIiIpLm1hcChnPT5nLnJlbW92ZSgpKSwoYz10aGlzLmRyYXdMYXllcik9PW51bGx8fGMuZ2V0RWxlbWVudHNCeU5hbWUobisiIikubWFwKGc9PmcucmVtb3ZlKCkpKSxpIT1udWxsJiZpLnNpemUmJihpLmZvckVhY2goZz0+e3ZhciBiOyhiPWEuZ2V0RWxlbWVudEJ5SWQoZysiIikpPT1udWxsfHxiLnJlbW92ZSgpfSksaS5jbGVhcigpKTtsZXQgeDtjb25zdCBtPVtdLE89YS53b3JsZFBvc2l0aW9uLG89YS53b3JsZFNjYWxpbmc7Zm9yKGxldCBnPTA7ZzxyLmxlbmd0aDtnKyspe2NvbnN0e3BvczpiLHBvaW50czpFLHRhc2tJZDpBfT1yW2ddO3QuaWQ9QS50b1N0cmluZygpO2NvbnN0e3BzOkwscmVjdDpNfT10aGlzLmNvbXB1dERyYXdQb2ludHMoRSk7bGV0IEk7Y29uc3QgRD1FLmxlbmd0aD09PTE7Zj09PXp0LlN0cm9rZXx8RD9JPXZlKEwsITApOkk9dmUoTCwhMSk7Y29uc3QgUj17cG9zOmIsZDpJLGZpbGxDb2xvcjpmPT09enQuU3Ryb2tlfHxEP3M6dm9pZCAwLGxpbmVEYXNoOmY9PT16dC5Eb3R0ZWQmJiFEP1sxLHYqMl06Zj09PXp0LkxvbmdEb3R0ZWQmJiFEP1t2LHYqMl06dm9pZCAwLHN0cm9rZUNvbG9yOnMsbGluZUNhcDpmPT09enQuU3Ryb2tlfHxEP3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDpmPT09enQuU3Ryb2tlfHxEPzA6dn07eD1idCh4LHt4Ok1hdGguZmxvb3IoKE0ueCtiWzBdKSpvWzBdK09bMF0tcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcigoTS55K2JbMV0pKm9bMV0rT1sxXS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKE0udypvWzBdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihNLmgqb1sxXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKX0pLG0ucHVzaChSKX1wJiYodC5zY2FsZT1wKSx5JiYodC5yb3RhdGU9eSksUCYmKHQudHJhbnNsYXRlPVApO2NvbnN0IGg9bmV3IHRlO2lmKHgpe3RoaXMuY2VudGVyUG9zPXB0LmdldENlbnRlclBvcyh4LGEpLGguYXR0cih7Li4udCxub3JtYWxpemU6ITAsaWQ6dC5uYW1lLGFuY2hvcjpbLjUsLjVdLGJnY29sb3I6Zj09PXp0LlN0cm9rZT9zOnZvaWQgMCxwb3M6dGhpcy5jZW50ZXJQb3Msc2l6ZTpbKHgudy0yKnB0LlNhZmVCb3JkZXJQYWRkaW5nKS9vWzBdLCh4LmgtMipwdC5TYWZlQm9yZGVyUGFkZGluZykvb1sxXV0sekluZGV4OmR9KTtjb25zdCBnPW0ubWFwKGI9PihiLnBvcz1bYi5wb3NbMF0tdGhpcy5jZW50ZXJQb3NbMF0sYi5wb3NbMV0tdGhpcy5jZW50ZXJQb3NbMV1dLG5ldyBhZShiKSkpO2guYXBwZW5kKC4uLmcpLGY9PT16dC5TdHJva2UmJmguc2VhbCgpLGEuYXBwZW5kKGgpfWlmKHB8fHl8fFApe2NvbnN0IGc9aD09bnVsbD92b2lkIDA6aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihnKXJldHVybnt4Ok1hdGguZmxvb3IoZy54LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoZy55LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoZy53aWR0aCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoZy5oZWlnaHQrcHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybiB4fWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PXp0LlN0cm9rZXx8ZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0U3Ryb2tlKGUpOnRoaXMuY29tcHV0Tm9tYWwoZSl9Y29tcHV0Tm9tYWwoZSl7bGV0IHQ9dGhpcy53b3JrT3B0aW9ucy50aGlja25lc3M7Y29uc3Qgcj1lLm1hcChuPT4odD1NYXRoLm1heCh0LG4ucmFkaXVzKSxuLnBvaW50KSk7cmV0dXJue3BzOnIscmVjdDpOdChyLHQpfX1jb21wdXRTdHJva2UoZSl7cmV0dXJuIGUubGVuZ3RoPT09MT90aGlzLmNvbXB1dERvdFN0cm9rZShlWzBdKTp0aGlzLmNvbXB1dExpbmVTdHJva2UoZSl9Y29tcHV0TGluZVN0cm9rZShlKXtjb25zdCB0PVtdLHI9W107Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspe2NvbnN0e3BvaW50OmYscmFkaXVzOnZ9PWVbc107bGV0IGQ9Zi52O3M9PT0wJiZlLmxlbmd0aD4xJiYoZD1lW3MrMV0ucG9pbnQudik7Y29uc3QgcD1ldC5QZXIoZCkubXVsKHYpO3QucHVzaCh4dC5TdWIoZixwKSksci5wdXNoKHh0LkFkZChmLHApKX1jb25zdCBuPWVbZS5sZW5ndGgtMV0saT14dC5HZXRTZW1pY2lyY2xlU3Ryb2tlKG4ucG9pbnQsdFt0Lmxlbmd0aC0xXSwtMSw4KSxhPXh0LkdldFNlbWljaXJjbGVTdHJva2UoZVswXS5wb2ludCxyWzBdLC0xLDgpLGw9dC5jb25jYXQoaSxyLnJldmVyc2UoKSxhKTtyZXR1cm57cHM6bCxyZWN0Ok50KGwpfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6cn09ZSxuPXt4OnQueC1yLHk6dC55LXIsdzpyKjIsaDpyKjJ9O3JldHVybntwczp4dC5HZXREb3RTdHJva2UodCxyLDgpLHJlY3Q6bn19dHJhbnNmb3JtRGF0YShlLHQpe2NvbnN0e29wOnIsd29ya1N0YXRlOm59PWU7bGV0IGk9dGhpcy50bXBQb2ludHMubGVuZ3RoLTEsYT1bXTtpZihyIT1udWxsJiZyLmxlbmd0aCYmbil7Y29uc3R7c3Ryb2tlVHlwZTpsLHRoaWNrbmVzczpzfT10aGlzLndvcmtPcHRpb25zLGY9bmV3IFNldDtpPWw9PT16dC5TdHJva2U/dGhpcy51cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlKHIscyxmKTp0aGlzLnVwZGF0ZVRlbXBQb2ludHMocixzLGYpO2NvbnN0IHY9dD90aGlzLnRtcFBvaW50czp0aGlzLnRtcFBvaW50cy5zbGljZShpKTtyZXR1cm4gYT10aGlzLmdldFRhc2tQb2ludHModixzKSx7dGFza3M6YSxlZmZlY3RzOmYsY29uc3VtZUluZGV4Oml9fXJldHVybnt0YXNrczphLGNvbnN1bWVJbmRleDppfX1jb21wdXRSYWRpdXMoZSx0KXtyZXR1cm4gZSouMDMqdCt0Ki41fWdldE1pblooZSx0KXtyZXR1cm4oKHR8fE1hdGgubWF4KDEsTWF0aC5mbG9vcihlKi4zKSkpLWUqLjUpKjEwMC9lLzN9Z2V0VGFza1BvaW50cyhlLHQpe3ZhciB2O2NvbnN0IHI9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCBuPTAsaT1lWzBdLngsYT1lWzBdLnksbD1baSxhXSxzPVtdLGY9ZVswXS50O2Zvcig7bjxlLmxlbmd0aDspe2NvbnN0IGQ9ZVtuXSxwPWQueC1pLHk9ZC55LWEsUD1kLnoseD10P3RoaXMuY29tcHV0UmFkaXVzKFAsdCk6UDtpZihzLnB1c2goe3BvaW50Om5ldyB4dChwLHksUCxlW25dLnYpLHJhZGl1czp4fSksbj4wJiZuPGUubGVuZ3RoLTEpe2NvbnN0IG09ZVtuXS5nZXRBbmdsZUJ5UG9pbnRzKGVbbi0xXSxlW24rMV0pO2lmKG08OTB8fG0+MjcwKXtjb25zdCBPPSh2PXMucG9wKCkpPT1udWxsP3ZvaWQgMDp2LnBvaW50LmNsb25lKCk7TyYmci5wdXNoKHt0YXNrSWQ6Zixwb3M6bCxwb2ludHM6Wy4uLnMse3BvaW50Ok8scmFkaXVzOnh9XX0pLGk9ZVtuXS54LGE9ZVtuXS55LGw9W2ksYV07Y29uc3Qgbz1kLngtaSxoPWQueS1hO3M9W3twb2ludDpuZXcgeHQobyxoLFApLHJhZGl1czp4fV0sZj1EYXRlLm5vdygpfX1uKyt9cmV0dXJuIHIucHVzaCh7dGFza0lkOmYscG9zOmwscG9pbnRzOnN9KSxyfXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUoZSx0LHIpe2NvbnN0IG49RGF0ZS5ub3coKSxpPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgYT1pO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cys9Mil7YT1NYXRoLm1pbihhLGkpO2NvbnN0IGY9dGhpcy50bXBQb2ludHMubGVuZ3RoLHY9bmV3IHh0KGVbc10sZVtzKzFdKTtpZihmPT09MCl7dGhpcy50bXBQb2ludHMucHVzaCh2KTtjb250aW51ZX1jb25zdCBkPWYtMSxwPXRoaXMudG1wUG9pbnRzW2RdLHk9ZXQuU3ViKHYscCkudW5pKCk7aWYodi5pc05lYXIocCx0KSl7aWYocC56PHRoaXMuTUFYX1JFUEVBUil7aWYocC5zZXR6KE1hdGgubWluKHAueisxLHRoaXMuTUFYX1JFUEVBUikpLGE9TWF0aC5taW4oYSxkKSxmPjEpe2xldCBtPWYtMTtmb3IoO20+MDspe2NvbnN0IE89dGhpcy50bXBQb2ludHNbbV0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbbS0xXSksbz1NYXRoLm1heCh0aGlzLnRtcFBvaW50c1ttXS56LXRoaXMudW5pVGhpY2tuZXNzKk8sMCk7aWYodGhpcy50bXBQb2ludHNbbS0xXS56Pj1vKWJyZWFrO3RoaXMudG1wUG9pbnRzW20tMV0uc2V0eihvKSxhPU1hdGgubWluKGEsbS0xKSxtLS19fX1lbHNlIGE9MS8wO2NvbnRpbnVlfXYuc2V0dih5KTtjb25zdCBQPXYuZGlzdGFuY2UocCkseD1NYXRoLm1heChwLnotdGhpcy51bmlUaGlja25lc3MqUCwwKTtmPjEmJmV0LkVxdWFscyh5LHAudiwuMDIpJiYoeD4wfHxwLno8PTApJiYociYmcC50JiZyLmFkZChwLnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLGE9TWF0aC5taW4oZCxhKSksdi5zZXR6KHgpLHRoaXMudG1wUG9pbnRzLnB1c2godil9aWYoYT09PTEvMClyZXR1cm4gdGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBsPWk7aWYoYT09PWkpe2w9TWF0aC5tYXgobC0xLDApO2NvbnN0IHM9dGhpcy50bXBQb2ludHNbbF0udDtzJiYocj09bnVsbHx8ci5hZGQocykpfWVsc2V7bGV0IHM9aS0xO2ZvcihsPWE7cz49MDspe2NvbnN0IGY9dGhpcy50bXBQb2ludHNbc10udDtpZihmJiYocj09bnVsbHx8ci5hZGQoZiksczw9YSkpe2w9cyxzPS0xO2JyZWFrfXMtLX19cmV0dXJuIHRoaXMudG1wUG9pbnRzW2xdLnNldFQobiksbH11cGRhdGVUZW1wUG9pbnRzKGUsdCxyKXt2YXIgcztjb25zdCBuPURhdGUubm93KCksaT10aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGE9aTtmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrPTIpe2NvbnN0IHY9dGhpcy50bXBQb2ludHMubGVuZ3RoLGQ9bmV3IHh0KGVbZl0sZVtmKzFdKTtpZih2PT09MCl7dGhpcy50bXBQb2ludHMucHVzaChkKTtjb250aW51ZX1jb25zdCBwPXYtMSx5PXRoaXMudG1wUG9pbnRzW3BdLFA9ZXQuU3ViKGQseSkudW5pKCk7aWYoZC5pc05lYXIoeSx0LzIpKXthPU1hdGgubWluKHAsYSk7Y29udGludWV9ZXQuRXF1YWxzKFAseS52LC4wMikmJihyJiZ5LnQmJnIuYWRkKHkudCksdGhpcy50bXBQb2ludHMucG9wKCksYT1NYXRoLm1pbihwLGEpKSxkLnNldHYoUCksdGhpcy50bXBQb2ludHMucHVzaChkKX1sZXQgbD1pO2lmKGE9PT1pKXtsPU1hdGgubWF4KGwtMSwwKTtjb25zdCBmPXRoaXMudG1wUG9pbnRzW2xdLnQ7ZiYmKHI9PW51bGx8fHIuYWRkKGYpKX1lbHNle2xldCBmPU1hdGgubWluKGktMSxhKTtmb3IobD1hO2Y+PTA7KXtjb25zdCB2PShzPXRoaXMudG1wUG9pbnRzW2ZdKT09bnVsbD92b2lkIDA6cy50O2lmKHYmJihyPT1udWxsfHxyLmFkZCh2KSxmPD1hKSl7bD1mLGY9LTE7YnJlYWt9Zi0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbbF0uc2V0VChuKSxsfXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxyPWUubGVuZ3RoLG49dGhpcy5nZXRNaW5aKHQpO2ZvcihsZXQgaT0wO2k8cjtpKz0yKXtjb25zdCBhPXRoaXMudG1wUG9pbnRzLmxlbmd0aCxsPW5ldyB4dChlW2ldLGVbaSsxXSk7aWYoYT09PTApe3RoaXMudG1wUG9pbnRzLnB1c2gobCk7Y29udGludWV9Y29uc3Qgcz1hLTEsZj10aGlzLnRtcFBvaW50c1tzXSx2PWV0LlN1YihsLGYpLnVuaSgpLGQ9bC5kaXN0YW5jZShmKTtpZihhPjEmJmYuej09PW4pYnJlYWs7aWYobC5pc05lYXIoZix0LzIpKXtpZihyPDMmJmYuejx0aGlzLk1BWF9SRVBFQVImJihmLnNldHooTWF0aC5taW4oZi56KzEsdGhpcy5NQVhfUkVQRUFSKSksYT4xKSl7bGV0IHk9YS0xO2Zvcig7eT4wOyl7Y29uc3QgUD10aGlzLnRtcFBvaW50c1t5XS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1t5LTFdKSx4PU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW3ldLnotdGhpcy51bmlUaGlja25lc3MqUCwtdC80KTtpZih0aGlzLnRtcFBvaW50c1t5LTFdLno+PXgpYnJlYWs7dGhpcy50bXBQb2ludHNbeS0xXS5zZXR6KHgpLHktLX19Y29udGludWV9bC5zZXR2KHYpO2NvbnN0IHA9TWF0aC5tYXgoZi56LXRoaXMudW5pVGhpY2tuZXNzKmQsbik7YT4xJiZldC5FcXVhbHModixmLnYsLjAyKSYmZi56PD0wJiZ0aGlzLnRtcFBvaW50cy5wb3AoKSxsLnNldHoocCksdGhpcy50bXBQb2ludHMucHVzaChsKX19c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7dmFyIGw7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpufT1lLHtzdHJva2VDb2xvcjppfT1yLGE9bi5nZXQodC5uYW1lKTtyZXR1cm4gaSYmKHQudGFnTmFtZT09PSJHUk9VUCI/VWUodCk/dC5zZXRBdHRyaWJ1dGUoImJnY29sb3IiLGkpOnQuY2hpbGRyZW4uZm9yRWFjaChzPT57cy5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixpKSxzLmdldEF0dHJpYnV0ZSgiZmlsbENvbG9yIikmJnMuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGkpfSk6KHQuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsaSksdC5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsaSkpLChsPWE9PW51bGw/dm9pZCAwOmEub3B0KSE9bnVsbCYmbC5zdHJva2VDb2xvciYmKGEub3B0LnN0cm9rZUNvbG9yPWkpKSxhJiZuLnNldEluZm8odC5uYW1lLGEpLHB0LnVwZGF0ZU5vZGVPcHQoZSl9c3RhdGljIGdldFJlY3RGcm9tTGF5ZXIoZSx0KXtjb25zdCByPWUuZ2V0RWxlbWVudHNCeU5hbWUodClbMF07aWYocil7Y29uc3Qgbj1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3Iobi54LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3Iobi55LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3Iobi53aWR0aCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3Iobi5oZWlnaHQrcHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fX19Y2xhc3MgRW4gZXh0ZW5kcyBwdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuTGFzZXJQZW59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6anQubm9uZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29uc3VtZUluZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe2NvbnN0e2RhdGE6dCxpc1N1YldvcmtlcjpyfT1lLHt3b3JrSWQ6bixvcDppfT10O2lmKChpPT1udWxsP3ZvaWQgMDppLmxlbmd0aCk9PT0wKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudXBkYXRlVGVtcFBvaW50cyhpfHxbXSksdGhpcy5jb25zdW1lSW5kZXg+dGhpcy50bXBQb2ludHMubGVuZ3RoLTQpcmV0dXJue3R5cGU6YXQuTm9uZX07Y29uc3R7c3Ryb2tlQ29sb3I6YSx0aGlja25lc3M6bCxzdHJva2VUeXBlOnN9PXRoaXMud29ya09wdGlvbnMsZj1OdCh0aGlzLnRtcFBvaW50cyxsKTtsZXQgdj0hMTtjb25zdCBkPXRoaXMuc3luY0luZGV4LHA9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO3RoaXMuY29uc3VtZUluZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aC0xLHRoaXMuc3luY1RpbWVzdGFtcD09PTAmJih0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKSk7Y29uc3QgeT17bmFtZTpuPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCksb3BhY2l0eToxLGxpbmVEYXNoOnM9PT16dC5Eb3R0ZWQ/WzEsbCoyXTpzPT09enQuTG9uZ0RvdHRlZD9bbCxsKjJdOnZvaWQgMCxzdHJva2VDb2xvcjphLGxpbmVDYXA6InJvdW5kIixsaW5lV2lkdGg6bCxhbmNob3I6Wy41LC41XX0sUD10aGlzLmdldFRhc2tQb2ludHMocCk7aWYoUC5sZW5ndGgpe2NvbnN0IG09RGF0ZS5ub3coKTttLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZSYmKHY9ITAsdGhpcy5zeW5jVGltZXN0YW1wPW0sdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSxyJiZ0aGlzLmRyYXcoe2F0dHJzOnksdGFza3M6UCxpc0RvdDohMSxsYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXJ9KX1jb25zdCB4PVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZShkKS5mb3JFYWNoKG09Pnt4LnB1c2gobS54LG0ueSl9KSx7cmVjdDp7eDpmLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTpmLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzpmLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6Zi5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX0sdHlwZTphdC5EcmF3V29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6dj9uOnZvaWQgMCxvcDp2P3g6dm9pZCAwLGluZGV4OnY/ZCoyOnZvaWQgMH19Y29uc3VtZUFsbCgpe3ZhciBuO2NvbnN0IGU9KG49dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCk7bGV0IHQ7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoLTE+dGhpcy5jb25zdW1lSW5kZXgpe2xldCBpPXRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuY29uc3VtZUluZGV4KTtjb25zdCBhPWkubGVuZ3RoPT09MSx7c3Ryb2tlQ29sb3I6bCx0aGlja25lc3M6cyxzdHJva2VUeXBlOmZ9PXRoaXMud29ya09wdGlvbnM7aWYoYSl7Y29uc3QgcD10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6aVswXSxyYWRpdXM6cy8yfSk7aT1wLnBzLHQ9cC5yZWN0fWVsc2UgdD1OdCh0aGlzLnRtcFBvaW50cyxzKTtjb25zdCB2PXtuYW1lOmU9PW51bGw/dm9pZCAwOmUudG9TdHJpbmcoKSxmaWxsQ29sb3I6YT9sOnZvaWQgMCxvcGFjaXR5OjEsbGluZURhc2g6Zj09PXp0LkRvdHRlZCYmIWE/WzEscyoyXTpmPT09enQuTG9uZ0RvdHRlZCYmIWE/W3MscyoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6bCxsaW5lQ2FwOmE/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmE/MDpzLGFuY2hvcjpbLjUsLjVdfSxkPXRoaXMuZ2V0VGFza1BvaW50cyhpKTtkLmxlbmd0aCYmdGhpcy5kcmF3KHthdHRyczp2LHRhc2tzOmQsaXNEb3Q6YSxsYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXJ9KX1jb25zdCByPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLnN5bmNJbmRleCkuZm9yRWFjaChpPT57ci5wdXNoKGkueCxpLnkpfSkse3JlY3Q6dCYme3g6dC54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6dC55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6dC53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOnQuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19LHR5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmUsb3A6cixpbmRleDp0aGlzLnN5bmNJbmRleCoyfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIFA7Y29uc3R7b3A6dCxyZXBsYWNlSWQ6cixpc0Z1bGxXb3JrOm59PWUse3N0cm9rZUNvbG9yOmksdGhpY2tuZXNzOmEsc3Ryb2tlVHlwZTpsfT10aGlzLndvcmtPcHRpb25zO2lmKCF0Lmxlbmd0aCl7Y29uc3QgeD1OdCh0aGlzLnRtcFBvaW50cyxhKTtyZXR1cm57eDp4LngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTp4LnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzp4LncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6eC5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX19Y29uc3Qgcz1NYXRoLm1heCgwLHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xKTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModHx8W10pO2xldCBmLHY9dGhpcy50bXBQb2ludHMuc2xpY2Uocyk7Y29uc3QgZD12Lmxlbmd0aD09PTE7aWYoZCl7Y29uc3QgeD10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6dlswXSxyYWRpdXM6YS8yfSk7dj14LnBzLGY9eC5yZWN0fWVsc2UgZj1OdCh0aGlzLnRtcFBvaW50cyxhKTtjb25zdCBwPXtuYW1lOihQPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6UC50b1N0cmluZygpLGZpbGxDb2xvcjpkP2k6dm9pZCAwLG9wYWNpdHk6MSxsaW5lRGFzaDpsPT09enQuRG90dGVkJiYhZD9bMSxhKjJdOmw9PT16dC5Mb25nRG90dGVkJiYhZD9bYSxhKjJdOnZvaWQgMCxzdHJva2VDb2xvcjppLGxpbmVDYXA6ZD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6ZD8wOmEsYW5jaG9yOlsuNSwuNV19LHk9dGhpcy5nZXRUYXNrUG9pbnRzKHYpO2lmKHkubGVuZ3RoKXtjb25zdCB4PW4/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyO3RoaXMuZHJhdyh7YXR0cnM6cCx0YXNrczp5LGlzRG90OmQscmVwbGFjZUlkOnIsbGF5ZXI6eH0pfXJldHVybnt4OmYueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OmYueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OmYudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpmLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6cn09ZSxuPXt4OnQueC1yLHk6dC55LXIsdzpyKjIsaDpyKjJ9O3JldHVybntwczp4dC5HZXREb3RTdHJva2UodCxyLDgpLHJlY3Q6bn19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aDtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrPTIpe2lmKHQpe2NvbnN0IG49dGhpcy50bXBQb2ludHMuc2xpY2UoLTEpWzBdO24mJm4ueD09PWVbcl0mJm4ueT09PWVbcisxXSYmdGhpcy50bXBQb2ludHMucG9wKCl9dGhpcy50bXBQb2ludHMucHVzaChuZXcgeHQoZVtyXSxlW3IrMV0pKX19YXN5bmMgZHJhdyhlKXtjb25zdHthdHRyczp0LHRhc2tzOnIsaXNEb3Q6bixsYXllcjppfT1lLHtkdXJhdGlvbjphfT10aGlzLndvcmtPcHRpb25zO2Zvcihjb25zdCBsIG9mIHIpe2NvbnN0IHM9bmV3IGFlLHtwb3M6Zixwb2ludHM6dn09bDtsZXQgZDtuP2Q9dmUodiwhMCk6ZD12ZSh2LCExKSxzLmF0dHIoey4uLnQscG9zOmYsZH0pO2NvbnN0e3ZlcnRleDpwLGZyYWdtZW50Onl9PXRoaXMud29ya09wdGlvbnM7aWYocCYmeSl7Y29uc3QgUD1pLnJlbmRlcmVyLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDpwLGZyYWdtZW50Onl9KSx7d2lkdGg6eCxoZWlnaHQ6bX09aS5nZXRSZXNvbHV0aW9uKCk7cy5zZXRVbmlmb3Jtcyh7dV90aW1lOjAsdV9yZXNvbHV0aW9uOlt4LG1dfSkscy5zZXRQcm9ncmFtKFApfWkuYXBwZW5kQ2hpbGQocykscy50cmFuc2l0aW9uKGEpLmF0dHIoe3NjYWxlOm4/Wy4xLC4xXTpbMSwxXSxsaW5lV2lkdGg6bj8wOjF9KS50aGVuKCgpPT57cy5yZW1vdmUoKX0pfX1nZXRUYXNrUG9pbnRzKGUpe3ZhciBzO2NvbnN0IHQ9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCByPTAsbj1lWzBdLngsaT1lWzBdLnksYT1bbixpXSxsPVtdO2Zvcig7cjxlLmxlbmd0aDspe2NvbnN0IGY9ZVtyXSx2PWYueC1uLGQ9Zi55LWk7aWYobC5wdXNoKG5ldyB4dCh2LGQpKSxyPjAmJnI8ZS5sZW5ndGgtMSl7Y29uc3QgcD1lW3JdLmdldEFuZ2xlQnlQb2ludHMoZVtyLTFdLGVbcisxXSk7aWYocDw5MHx8cD4yNzApe2NvbnN0IHk9KHM9bC5wb3AoKSk9PW51bGw/dm9pZCAwOnMuY2xvbmUoKTt5JiZ0LnB1c2goe3BvczphLHBvaW50czpbLi4ubCx5XX0pLG49ZVtyXS54LGk9ZVtyXS55LGE9W24saV07Y29uc3QgUD1mLngtbix4PWYueS1pO2w9W25ldyB4dChQLHgpXX19cisrfXJldHVybiB0LnB1c2goe3BvczphLHBvaW50czpsfSksdH1yZW1vdmVMb2NhbCgpe31yZW1vdmVTZXJ2aWNlKGUpe2xldCB0O2NvbnN0IHI9W107cmV0dXJuIHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmZvckVhY2gobj0+e2lmKG4ubmFtZT09PWUpe2NvbnN0IGk9bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0PWJ0KHQse3g6aS54LHk6aS55LHc6aS53aWR0aCxoOmkuaGVpZ2h0fSksci5wdXNoKG4pfX0pLHIubGVuZ3RoJiZyLmZvckVhY2gobj0+bi5yZW1vdmUoKSksdH19dmFyIFloPUdlO0dlLnBvbHlsaW5lPUdlLEdlLnBvbHlnb249WGg7ZnVuY3Rpb24gR2UodSxlLHQpe3ZhciByPXUubGVuZ3RoLG49eWUodVswXSxlKSxpPVtdLGEsbCxzLGYsdjtmb3IodHx8KHQ9W10pLGE9MTthPHI7YSsrKXtmb3IobD11W2EtMV0scz11W2FdLGY9dj15ZShzLGUpOzspaWYobnxmKXtpZihuJmYpYnJlYWs7bj8obD1jcihsLHMsbixlKSxuPXllKGwsZSkpOihzPWNyKGwscyxmLGUpLGY9eWUocyxlKSl9ZWxzZXtpLnB1c2gobCksZiE9PXY/KGkucHVzaChzKSxhPHItMSYmKHQucHVzaChpKSxpPVtdKSk6YT09PXItMSYmaS5wdXNoKHMpO2JyZWFrfW49dn1yZXR1cm4gaS5sZW5ndGgmJnQucHVzaChpKSx0fWZ1bmN0aW9uIFhoKHUsZSl7dmFyIHQscixuLGksYSxsLHM7Zm9yKHI9MTtyPD04O3IqPTIpe2Zvcih0PVtdLG49dVt1Lmxlbmd0aC0xXSxpPSEoeWUobixlKSZyKSxhPTA7YTx1Lmxlbmd0aDthKyspbD11W2FdLHM9ISh5ZShsLGUpJnIpLHMhPT1pJiZ0LnB1c2goY3IobixsLHIsZSkpLHMmJnQucHVzaChsKSxuPWwsaT1zO2lmKHU9dCwhdS5sZW5ndGgpYnJlYWt9cmV0dXJuIHR9ZnVuY3Rpb24gY3IodSxlLHQscil7cmV0dXJuIHQmOD9bdVswXSsoZVswXS11WzBdKSooclszXS11WzFdKS8oZVsxXS11WzFdKSxyWzNdXTp0JjQ/W3VbMF0rKGVbMF0tdVswXSkqKHJbMV0tdVsxXSkvKGVbMV0tdVsxXSksclsxXV06dCYyP1tyWzJdLHVbMV0rKGVbMV0tdVsxXSkqKHJbMl0tdVswXSkvKGVbMF0tdVswXSldOnQmMT9bclswXSx1WzFdKyhlWzFdLXVbMV0pKihyWzBdLXVbMF0pLyhlWzBdLXVbMF0pXTpudWxsfWZ1bmN0aW9uIHllKHUsZSl7dmFyIHQ9MDtyZXR1cm4gdVswXTxlWzBdP3R8PTE6dVswXT5lWzJdJiYodHw9MiksdVsxXTxlWzFdP3R8PTQ6dVsxXT5lWzNdJiYodHw9OCksdH12YXIgWmg9Y2UoWWgpO2NsYXNzIEp0IGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6anQubm9uZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpkdC5FcmFzZXJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VydmljZVdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ybGRQb3NpdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFNjYWxpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZXJhc2VyUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJQb2x5bGluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuc2VydmljZVdvcms9dCx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy53b3JsZFBvc2l0aW9uPXRoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb24sdGhpcy53b3JsZFNjYWxpbmc9dGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nfWNvbWJpbmVDb25zdW1lKCl7fWNvbnN1bWVTZXJ2aWNlKCl7fXNldFdvcmtPcHRpb25zKGUpe3N1cGVyLnNldFdvcmtPcHRpb25zKGUpfWNyZWF0ZUVyYXNlclJlY3QoZSl7Y29uc3QgdD1lWzBdKnRoaXMud29ybGRTY2FsaW5nWzBdK3RoaXMud29ybGRQb3NpdGlvblswXSxyPWVbMV0qdGhpcy53b3JsZFNjYWxpbmdbMV0rdGhpcy53b3JsZFBvc2l0aW9uWzFdLHt3aWR0aDpuLGhlaWdodDppfT1KdC5lcmFzZXJTaXplc1t0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc107dGhpcy5lcmFzZXJSZWN0PXt4OnQtbiouNSx5OnItaSouNSx3Om4saDppfSx0aGlzLmVyYXNlclBvbHlsaW5lPVt0aGlzLmVyYXNlclJlY3QueCx0aGlzLmVyYXNlclJlY3QueSx0aGlzLmVyYXNlclJlY3QueCt0aGlzLmVyYXNlclJlY3Qudyx0aGlzLmVyYXNlclJlY3QueSt0aGlzLmVyYXNlclJlY3QuaF19Y29tcHV0UmVjdENlbnRlclBvaW50cygpe2NvbnN0IGU9dGhpcy50bXBQb2ludHMuc2xpY2UoLTIpO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTQpe2NvbnN0IHQ9bmV3IGV0KHRoaXMudG1wUG9pbnRzWzBdLHRoaXMudG1wUG9pbnRzWzFdKSxyPW5ldyBldCh0aGlzLnRtcFBvaW50c1syXSx0aGlzLnRtcFBvaW50c1szXSksbj1ldC5TdWIocix0KS51bmkoKSxpPWV0LkRpc3QodCxyKSx7d2lkdGg6YSxoZWlnaHQ6bH09SnQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdLHM9TWF0aC5taW4oYSxsKSxmPU1hdGgucm91bmQoaS9zKTtpZihmPjEpe2NvbnN0IHY9W107Zm9yKGxldCBkPTA7ZDxmO2QrKyl7Y29uc3QgcD1ldC5NdWwobixkKnMpO3YucHVzaCh0aGlzLnRtcFBvaW50c1swXStwLngsdGhpcy50bXBQb2ludHNbMV0rcC55KX1yZXR1cm4gdi5jb25jYXQoZSl9fXJldHVybiBlfWlzTmVhcihlLHQpe2NvbnN0IHI9bmV3IGV0KGVbMF0sZVsxXSksbj1uZXcgZXQodFswXSx0WzFdKSx7d2lkdGg6aSxoZWlnaHQ6YX09SnQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdO3JldHVybiBldC5EaXN0KHIsbik8TWF0aC5oeXBvdChpLGEpKi41fWN1dFBvbHlsaW5lKGUsdCl7bGV0IHI9W3RdLG49MDtmb3IoO248ZS5sZW5ndGg7KXtjb25zdCBsPWVbbl07aWYobC5sZW5ndGg8MilicmVhaztyPWkocixsKSxuKyt9cmV0dXJuIHI7ZnVuY3Rpb24gaShsLHMpe2NvbnN0IGY9bDtmb3IobGV0IHY9MDt2PGwubGVuZ3RoO3YrKyl7Y29uc3QgZD1sW3ZdLHA9ZC5maW5kSW5kZXgoKHksUCk9PlA8ZC5sZW5ndGgtMT9hKFt5LGRbUCsxXV0sW3NbMF0sc1sxXV0pOiExKTtpZihwIT09LTEmJnA+LTEpe2NvbnN0IHk9W10sUD1kLnNsaWNlKDAscCsxKTtpZihldC5FcXVhbHMoZFtwXSxzWzBdKXx8UC5wdXNoKHNbMF0uY2xvbmUoKS5zZXR6KGRbcF0ueikpLFAubGVuZ3RoPjEmJnkucHVzaChQKSxwK3MubGVuZ3RoLTE8ZC5sZW5ndGgtMSl7Y29uc3QgeD1wK3MubGVuZ3RoLTEsbT1kLnNsaWNlKHgpLE89c1tzLmxlbmd0aC0xXTtldC5FcXVhbHMoZFt4XSxPKXx8bS51bnNoaWZ0KE8uY2xvbmUoKS5zZXR6KGRbeF0ueikpLG0ubGVuZ3RoPjEmJnkucHVzaChtKX1yZXR1cm4gZi5zcGxpY2UodiwxLC4uLnkpLGZ9fXJldHVybiBmfWZ1bmN0aW9uIGEobCxzKXtjb25zdCBmPWV0LlN1YihsWzFdLGxbMF0pLHY9ZXQuU3ViKHNbMV0sc1swXSksZD1ldC5TdWIoc1swXSxsWzBdKTtyZXR1cm4gTWF0aC5hYnMoZXQuQ3ByKGYsdikpPC4xJiZNYXRoLmFicyhldC5DcHIoZixkKSk8LjF9fWlzU2FtZVBvaW50KGUsdCl7cmV0dXJuIGVbMF09PT10WzBdJiZlWzFdPT09dFsxXX10cmFuc2xhdGVJbnRlcnNlY3QoZSl7Y29uc3QgdD1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3Qgbj1lW3JdLmZpbHRlcigobCxzLGYpPT4hKHM+MCYmdGhpcy5pc1NhbWVQb2ludChsLGZbcy0xXSkpKSxpPVtdO2xldCBhPTA7Zm9yKDthPG4ubGVuZ3RoOyl7Y29uc3QgbD1uW2FdLHM9bmV3IGV0KGxbMF0sbFsxXSk7aS5wdXNoKHMpLGErK310LnB1c2goaSl9cmV0dXJuIHR9aXNMaW5lRXJhc2VyKGUsdCl7cmV0dXJuIShlPT09ZHQuUGVuY2lsJiYhdCl9cmVtb3ZlKGUpe2NvbnN0e2N1ck5vZGVNYXA6dCxyZW1vdmVJZHM6cixuZXdXb3JrRGF0YXM6bn09ZSx7aXNMaW5lOml9PXRoaXMud29ya09wdGlvbnM7bGV0IGE7Zm9yKGNvbnN0W2wsc11vZiB0LmVudHJpZXMoKSlpZihzLnJlY3QmJnRoaXMuZXJhc2VyUmVjdCYmdGhpcy5lcmFzZXJQb2x5bGluZSYmeGUodGhpcy5lcmFzZXJSZWN0LHMucmVjdCkpe2NvbnN0e29wOmYsdG9vbHNUeXBlOnZ9PXMsZD10aGlzLmlzTGluZUVyYXNlcih2LGkpLHA9W10seT1bXTtmb3IobGV0IHg9MDt4PGYubGVuZ3RoO3grPTMpe2NvbnN0IG09bmV3IGV0KGZbeF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLGZbeCsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0sZlt4KzJdKTt5LnB1c2gobSkscC5wdXNoKG5ldyB4dChtLngsbS55KSl9Y29uc3QgUD1wLmxlbmd0aCYmTnQocCl8fHMucmVjdDtpZih4ZShQLHRoaXMuZXJhc2VyUmVjdCkpe2lmKHkubGVuZ3RoPjEpe2NvbnN0IHg9WmgucG9seWxpbmUoeS5tYXAobT0+bS5YWSksdGhpcy5lcmFzZXJQb2x5bGluZSk7aWYoeC5sZW5ndGgmJihyLmFkZChzLm5hbWUpLCFkKSl7Y29uc3QgbT10aGlzLnRyYW5zbGF0ZUludGVyc2VjdCh4KSxPPXRoaXMuY3V0UG9seWxpbmUobSx5KTtmb3IobGV0IG89MDtvPE8ubGVuZ3RoO28rKyl7Y29uc3QgaD1gJHtsfV9zXyR7b31gLGM9W107T1tvXS5mb3JFYWNoKGc9PntjLnB1c2goKGcueC10aGlzLndvcmxkUG9zaXRpb25bMF0pL3RoaXMud29ybGRTY2FsaW5nWzBdLChnLnktdGhpcy53b3JsZFBvc2l0aW9uWzFdKS90aGlzLndvcmxkU2NhbGluZ1sxXSxnLnopfSkscy5vcHQmJnMudG9vbHNUeXBlJiZ0aGlzLnZOb2RlcyYmKHRoaXMudk5vZGVzLnNldEluZm8oaCx7cmVjdDpQLG9wOmMsb3B0OnMub3B0LGNhblJvdGF0ZTpzLmNhblJvdGF0ZSxzY2FsZVR5cGU6cy5zY2FsZVR5cGUsdG9vbHNUeXBlOnMudG9vbHNUeXBlfSksbi5zZXQoaCx7d29ya0lkOmgsb3A6YyxvcHQ6cy5vcHQsdG9vbHNUeXBlOnMudG9vbHNUeXBlfSkpfX19ZWxzZSByLmFkZChzLm5hbWUpO2E9YnQoYSxQKX19cmV0dXJuIHIuZm9yRWFjaChsPT57dmFyIHM7cmV0dXJuKHM9dGhpcy52Tm9kZXMpPT1udWxsP3ZvaWQgMDpzLmRlbGV0ZShsKX0pLGEmJihhLngtPXB0LlNhZmVCb3JkZXJQYWRkaW5nLGEueS09cHQuU2FmZUJvcmRlclBhZGRpbmcsYS53Kz1wdC5TYWZlQm9yZGVyUGFkZGluZyoyLGEuaCs9cHQuU2FmZUJvcmRlclBhZGRpbmcqMiksYX1jb25zdW1lKGUpe2NvbnN0e29wOnR9PWUuZGF0YTtpZighdHx8dC5sZW5ndGg9PT0wKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0IHI9dGhpcy50bXBQb2ludHMubGVuZ3RoO2lmKHI+MSYmdGhpcy5pc05lYXIoW3RbMF0sdFsxXV0sW3RoaXMudG1wUG9pbnRzW3ItMl0sdGhpcy50bXBQb2ludHNbci0xXV0pKXJldHVybnt0eXBlOmF0Lk5vbmV9O3I9PT00JiYodGhpcy50bXBQb2ludHMuc2hpZnQoKSx0aGlzLnRtcFBvaW50cy5zaGlmdCgpKSx0aGlzLnRtcFBvaW50cy5wdXNoKHRbMF0sdFsxXSk7Y29uc3Qgbj10aGlzLmNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKTtsZXQgaTtjb25zdCBhPW5ldyBTZXQsbD1uZXcgTWFwO3RoaXMudk5vZGVzLnNldFRhcmdldCgpO2NvbnN0IHM9dGhpcy5nZXRVbkxvY2tOb2RlTWFwKHRoaXMudk5vZGVzLmdldExhc3RUYXJnZXQoKSk7Zm9yKGxldCBmPTA7ZjxuLmxlbmd0aC0xO2YrPTIpe3RoaXMuY3JlYXRlRXJhc2VyUmVjdChuLnNsaWNlKGYsZisyKSk7Y29uc3Qgdj10aGlzLnJlbW92ZSh7Y3VyTm9kZU1hcDpzLHJlbW92ZUlkczphLG5ld1dvcmtEYXRhczpsfSk7aT1idChpLHYpfWlmKHRoaXMudk5vZGVzLmRlbGV0ZUxhc3RUYXJnZXQoKSxpJiZhLnNpemUpe2Zvcihjb25zdCBmIG9mIGwua2V5cygpKWEuaGFzKGYpJiZsLmRlbGV0ZShmKTtyZXR1cm57dHlwZTphdC5SZW1vdmVOb2RlLGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6aSxyZW1vdmVJZHM6Wy4uLmFdLG5ld1dvcmtEYXRhczpsfX1yZXR1cm57dHlwZTphdC5Ob25lfX1jb25zdW1lQWxsKGUpe3JldHVybiB0aGlzLmNvbnN1bWUoZSl9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1nZXRVbkxvY2tOb2RlTWFwKGUpe3ZhciB0O2lmKHRoaXMuc2VydmljZVdvcmspe2NvbnN0IHI9WXQoZSksbj10aGlzLnNlcnZpY2VXb3JrLnNlbGVjdG9yV29ya1NoYXBlcyxpPXRoaXMuc2VydmljZVdvcmsud29ya1NoYXBlcztmb3IoY29uc3QgYSBvZiBuLnZhbHVlcygpKWlmKCh0PWEuc2VsZWN0SWRzKSE9bnVsbCYmdC5sZW5ndGgpZm9yKGNvbnN0IGwgb2YgYS5zZWxlY3RJZHMpci5kZWxldGUobCk7Zm9yKGNvbnN0IGEgb2YgaS5rZXlzKCkpci5kZWxldGUoYSk7cmV0dXJuIHJ9cmV0dXJuIGV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShKdCwiZXJhc2VyU2l6ZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpPYmplY3QuZnJlZXplKFtPYmplY3QuZnJlZXplKHt3aWR0aDoxOCxoZWlnaHQ6MjZ9KSxPYmplY3QuZnJlZXplKHt3aWR0aDoyNixoZWlnaHQ6MzR9KSxPYmplY3QuZnJlZXplKHt3aWR0aDozNCxoZWlnaHQ6NTB9KV0pfSk7Y29uc3QgSmg9IisrIixRaD0ic2VsZWN0b3IiLGtoPSJhbGwiO3ZhciBxaD0iX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyI7ZnVuY3Rpb24gX2godSl7cmV0dXJuIHRoaXMuX19kYXRhX18uc2V0KHUscWgpLHRoaXN9dmFyIHRkPV9oO2Z1bmN0aW9uIGVkKHUpe3JldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh1KX12YXIgcmQ9ZWQsbmQ9TXIsaWQ9dGQsc2Q9cmQ7ZnVuY3Rpb24gSGUodSl7dmFyIGU9LTEsdD11PT1udWxsPzA6dS5sZW5ndGg7Zm9yKHRoaXMuX19kYXRhX189bmV3IG5kOysrZTx0Oyl0aGlzLmFkZCh1W2VdKX1IZS5wcm90b3R5cGUuYWRkPUhlLnByb3RvdHlwZS5wdXNoPWlkLEhlLnByb3RvdHlwZS5oYXM9c2Q7dmFyIG9kPUhlO2Z1bmN0aW9uIGFkKHUsZSl7Zm9yKHZhciB0PS0xLHI9dT09bnVsbD8wOnUubGVuZ3RoOysrdDxyOylpZihlKHVbdF0sdCx1KSlyZXR1cm4hMDtyZXR1cm4hMX12YXIgbGQ9YWQ7ZnVuY3Rpb24gY2QodSxlKXtyZXR1cm4gdS5oYXMoZSl9dmFyIHVkPWNkLGZkPW9kLGhkPWxkLGRkPXVkLGdkPTEscGQ9MjtmdW5jdGlvbiBtZCh1LGUsdCxyLG4saSl7dmFyIGE9dCZnZCxsPXUubGVuZ3RoLHM9ZS5sZW5ndGg7aWYobCE9cyYmIShhJiZzPmwpKXJldHVybiExO3ZhciBmPWkuZ2V0KHUpLHY9aS5nZXQoZSk7aWYoZiYmdilyZXR1cm4gZj09ZSYmdj09dTt2YXIgZD0tMSxwPSEwLHk9dCZwZD9uZXcgZmQ6dm9pZCAwO2ZvcihpLnNldCh1LGUpLGkuc2V0KGUsdSk7KytkPGw7KXt2YXIgUD11W2RdLHg9ZVtkXTtpZihyKXZhciBtPWE/cih4LFAsZCxlLHUsaSk6cihQLHgsZCx1LGUsaSk7aWYobSE9PXZvaWQgMCl7aWYobSljb250aW51ZTtwPSExO2JyZWFrfWlmKHkpe2lmKCFoZChlLGZ1bmN0aW9uKE8sbyl7aWYoIWRkKHksbykmJihQPT09T3x8bihQLE8sdCxyLGkpKSlyZXR1cm4geS5wdXNoKG8pfSkpe3A9ITE7YnJlYWt9fWVsc2UgaWYoIShQPT09eHx8bihQLHgsdCxyLGkpKSl7cD0hMTticmVha319cmV0dXJuIGkuZGVsZXRlKHUpLGkuZGVsZXRlKGUpLHB9dmFyIEFuPW1kO2Z1bmN0aW9uIHZkKHUpe3ZhciBlPS0xLHQ9QXJyYXkodS5zaXplKTtyZXR1cm4gdS5mb3JFYWNoKGZ1bmN0aW9uKHIsbil7dFsrK2VdPVtuLHJdfSksdH12YXIgeWQ9dmQ7ZnVuY3Rpb24gU2QodSl7dmFyIGU9LTEsdD1BcnJheSh1LnNpemUpO3JldHVybiB1LmZvckVhY2goZnVuY3Rpb24ocil7dFsrK2VdPXJ9KSx0fXZhciB4ZD1TZCxDbj1SZSxSbj1xcixPZD1WZSxiZD1BbixQZD15ZCxUZD14ZCxNZD0xLEVkPTIsQWQ9IltvYmplY3QgQm9vbGVhbl0iLENkPSJbb2JqZWN0IERhdGVdIixSZD0iW29iamVjdCBFcnJvcl0iLElkPSJbb2JqZWN0IE1hcF0iLExkPSJbb2JqZWN0IE51bWJlcl0iLERkPSJbb2JqZWN0IFJlZ0V4cF0iLHdkPSJbb2JqZWN0IFNldF0iLE5kPSJbb2JqZWN0IFN0cmluZ10iLEJkPSJbb2JqZWN0IFN5bWJvbF0iLGpkPSJbb2JqZWN0IEFycmF5QnVmZmVyXSIsV2Q9IltvYmplY3QgRGF0YVZpZXddIixJbj1Dbj9Dbi5wcm90b3R5cGU6dm9pZCAwLHVyPUluP0luLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIEZkKHUsZSx0LHIsbixpLGEpe3N3aXRjaCh0KXtjYXNlIFdkOmlmKHUuYnl0ZUxlbmd0aCE9ZS5ieXRlTGVuZ3RofHx1LmJ5dGVPZmZzZXQhPWUuYnl0ZU9mZnNldClyZXR1cm4hMTt1PXUuYnVmZmVyLGU9ZS5idWZmZXI7Y2FzZSBqZDpyZXR1cm4hKHUuYnl0ZUxlbmd0aCE9ZS5ieXRlTGVuZ3RofHwhaShuZXcgUm4odSksbmV3IFJuKGUpKSk7Y2FzZSBBZDpjYXNlIENkOmNhc2UgTGQ6cmV0dXJuIE9kKCt1LCtlKTtjYXNlIFJkOnJldHVybiB1Lm5hbWU9PWUubmFtZSYmdS5tZXNzYWdlPT1lLm1lc3NhZ2U7Y2FzZSBEZDpjYXNlIE5kOnJldHVybiB1PT1lKyIiO2Nhc2UgSWQ6dmFyIGw9UGQ7Y2FzZSB3ZDp2YXIgcz1yJk1kO2lmKGx8fChsPVRkKSx1LnNpemUhPWUuc2l6ZSYmIXMpcmV0dXJuITE7dmFyIGY9YS5nZXQodSk7aWYoZilyZXR1cm4gZj09ZTtyfD1FZCxhLnNldCh1LGUpO3ZhciB2PWJkKGwodSksbChlKSxyLG4saSxhKTtyZXR1cm4gYS5kZWxldGUodSksdjtjYXNlIEJkOmlmKHVyKXJldHVybiB1ci5jYWxsKHUpPT11ci5jYWxsKGUpfXJldHVybiExfXZhciBVZD1GZCxMbj1WciwkZD0xLHpkPU9iamVjdC5wcm90b3R5cGUsR2Q9emQuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gSGQodSxlLHQscixuLGkpe3ZhciBhPXQmJGQsbD1Mbih1KSxzPWwubGVuZ3RoLGY9TG4oZSksdj1mLmxlbmd0aDtpZihzIT12JiYhYSlyZXR1cm4hMTtmb3IodmFyIGQ9cztkLS07KXt2YXIgcD1sW2RdO2lmKCEoYT9wIGluIGU6R2QuY2FsbChlLHApKSlyZXR1cm4hMX12YXIgeT1pLmdldCh1KSxQPWkuZ2V0KGUpO2lmKHkmJlApcmV0dXJuIHk9PWUmJlA9PXU7dmFyIHg9ITA7aS5zZXQodSxlKSxpLnNldChlLHUpO2Zvcih2YXIgbT1hOysrZDxzOyl7cD1sW2RdO3ZhciBPPXVbcF0sbz1lW3BdO2lmKHIpdmFyIGg9YT9yKG8sTyxwLGUsdSxpKTpyKE8sbyxwLHUsZSxpKTtpZighKGg9PT12b2lkIDA/Tz09PW98fG4oTyxvLHQscixpKTpoKSl7eD0hMTticmVha31tfHwobT1wPT0iY29uc3RydWN0b3IiKX1pZih4JiYhbSl7dmFyIGM9dS5jb25zdHJ1Y3RvcixnPWUuY29uc3RydWN0b3I7YyE9ZyYmImNvbnN0cnVjdG9yImluIHUmJiJjb25zdHJ1Y3RvciJpbiBlJiYhKHR5cGVvZiBjPT0iZnVuY3Rpb24iJiZjIGluc3RhbmNlb2YgYyYmdHlwZW9mIGc9PSJmdW5jdGlvbiImJmcgaW5zdGFuY2VvZiBnKSYmKHg9ITEpfXJldHVybiBpLmRlbGV0ZSh1KSxpLmRlbGV0ZShlKSx4fXZhciBLZD1IZCxmcj1FcixWZD1BbixZZD1VZCxYZD1LZCxEbj1XZSx3bj13ZSxObj1aZSxaZD1CcixKZD0xLEJuPSJbb2JqZWN0IEFyZ3VtZW50c10iLGpuPSJbb2JqZWN0IEFycmF5XSIsS2U9IltvYmplY3QgT2JqZWN0XSIsUWQ9T2JqZWN0LnByb3RvdHlwZSxXbj1RZC5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBrZCh1LGUsdCxyLG4saSl7dmFyIGE9d24odSksbD13bihlKSxzPWE/am46RG4odSksZj1sP2puOkRuKGUpO3M9cz09Qm4/S2U6cyxmPWY9PUJuP0tlOmY7dmFyIHY9cz09S2UsZD1mPT1LZSxwPXM9PWY7aWYocCYmTm4odSkpe2lmKCFObihlKSlyZXR1cm4hMTthPSEwLHY9ITF9aWYocCYmIXYpcmV0dXJuIGl8fChpPW5ldyBmciksYXx8WmQodSk/VmQodSxlLHQscixuLGkpOllkKHUsZSxzLHQscixuLGkpO2lmKCEodCZKZCkpe3ZhciB5PXYmJlduLmNhbGwodSwiX193cmFwcGVkX18iKSxQPWQmJlduLmNhbGwoZSwiX193cmFwcGVkX18iKTtpZih5fHxQKXt2YXIgeD15P3UudmFsdWUoKTp1LG09UD9lLnZhbHVlKCk6ZTtyZXR1cm4gaXx8KGk9bmV3IGZyKSxuKHgsbSx0LHIsaSl9fXJldHVybiBwPyhpfHwoaT1uZXcgZnIpLFhkKHUsZSx0LHIsbixpKSk6ITF9dmFyIHFkPWtkLF9kPXFkLEZuPV90O2Z1bmN0aW9uIFVuKHUsZSx0LHIsbil7cmV0dXJuIHU9PT1lPyEwOnU9PW51bGx8fGU9PW51bGx8fCFGbih1KSYmIUZuKGUpP3UhPT11JiZlIT09ZTpfZCh1LGUsdCxyLFVuLG4pfXZhciB0Zz1VbixlZz10ZztmdW5jdGlvbiByZyh1LGUpe3JldHVybiBlZyh1LGUpfXZhciBuZz1yZywkbj1jZShuZyk7Y2xhc3MgSXQgZXh0ZW5kcyBwdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuU2VsZWN0b3J9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VsZWN0SWRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlbGVjdG9yQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3Ryb2tlQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZmlsbENvbG9yIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFNlbGVjdFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuVGV4dEVkaXQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Mb2NrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6anQuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2hhcGVPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidGV4dE9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpc0xvY2tlZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdH1jb21wdXRTZWxlY3RvcihlPSEwKXtjb25zdCB0PU50KHRoaXMudG1wUG9pbnRzKTtpZih0Lnc9PT0wfHx0Lmg9PT0wKXJldHVybntzZWxlY3RJZHM6W10saW50ZXJzZWN0UmVjdDp2b2lkIDAsc3ViTm9kZU1hcDpuZXcgTWFwfTtjb25zdHtyZWN0UmFuZ2U6cixub2RlUmFuZ2U6bn09dGhpcy52Tm9kZXMuZ2V0UmVjdEludGVyc2VjdFJhbmdlKHQsZSk7cmV0dXJue3NlbGVjdElkczpbLi4ubi5rZXlzKCldLGludGVyc2VjdFJlY3Q6cixzdWJOb2RlTWFwOm59fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGgscj1lLmxlbmd0aDtpZihyPjEpe2NvbnN0IG49bmV3IHh0KGVbci0yXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSxlW3ItMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0pO3Q9PT0yP3RoaXMudG1wUG9pbnRzLnNwbGljZSgxLDEsbik6dGhpcy50bXBQb2ludHMucHVzaChuKX19ZHJhd1NlbGVjdG9yKGUpe2NvbnN0e2RyYXdSZWN0OnQsc3ViTm9kZU1hcDpyLHNlbGVjdG9ySWQ6bixsYXllcjppLGlzU2VydmljZTphfT1lLGw9bmV3IHRlKHtwb3M6W3QueCx0LnldLGFuY2hvcjpbMCwwXSxzaXplOlt0LncsdC5oXSxpZDpuLG5hbWU6bix6SW5kZXg6MWUzfSkscz1bXTtpZihhKXtjb25zdCBmPW5ldyBhcih7bm9ybWFsaXplOiEwLHBvczpbdC53LzIsdC5oLzJdLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOnRoaXMuc2VsZWN0b3JDb2xvcnx8dGhpcy53b3JrT3B0aW9ucy5zdHJva2VDb2xvcix3aWR0aDp0LncsaGVpZ2h0OnQuaCxuYW1lOkl0LnNlbGVjdG9yQm9yZGVySWR9KTtzLnB1c2goZil9ci5mb3JFYWNoKChmLHYpPT57Y29uc3QgZD1bZi5yZWN0LngrZi5yZWN0LncvMi10LngsZi5yZWN0LnkrZi5yZWN0LmgvMi10LnldLHA9bmV3IGFyKHtub3JtYWxpemU6ITAscG9zOmQsbGluZVdpZHRoOjEsc3Ryb2tlQ29sb3I6ci5zaXplPjE/dGhpcy5zZWxlY3RvckNvbG9yfHx0aGlzLndvcmtPcHRpb25zLnN0cm9rZUNvbG9yOnZvaWQgMCx3aWR0aDpmLnJlY3QudyxoZWlnaHQ6Zi5yZWN0LmgsaWQ6YHNlbGVjdG9yLSR7dn1gLG5hbWU6YHNlbGVjdG9yLSR7dn1gfSk7cy5wdXNoKHApfSkscyYmbC5hcHBlbmQoLi4ucyksKGk9PW51bGw/dm9pZCAwOmkucGFyZW50KS5hcHBlbmRDaGlsZChsKX1kcmF3KGUsdCxyLG49ITEpe3ZhciBsLHM7Y29uc3R7aW50ZXJzZWN0UmVjdDppLHN1Yk5vZGVNYXA6YX09cjsocz0obD10LnBhcmVudCk9PW51bGw/dm9pZCAwOmwuZ2V0RWxlbWVudEJ5SWQoZSkpPT1udWxsfHxzLnJlbW92ZSgpLGkmJnRoaXMuZHJhd1NlbGVjdG9yKHtkcmF3UmVjdDppLHN1Yk5vZGVNYXA6YSxzZWxlY3RvcklkOmUsbGF5ZXI6dCxpc1NlcnZpY2U6bn0pfWdldFNlbGVjdGVvckluZm8oZSl7dGhpcy5zY2FsZVR5cGU9anQuYWxsLHRoaXMuY2FuUm90YXRlPSExLHRoaXMudGV4dE9wdD12b2lkIDAsdGhpcy5zdHJva2VDb2xvcj12b2lkIDAsdGhpcy5maWxsQ29sb3I9dm9pZCAwLHRoaXMuY2FuVGV4dEVkaXQ9ITEsdGhpcy5jYW5Mb2NrPSExLHRoaXMuaXNMb2NrZWQ9ITEsdGhpcy50b29sc1R5cGVzPXZvaWQgMCx0aGlzLnNoYXBlT3B0PXZvaWQgMDtjb25zdCB0PW5ldyBTZXQ7bGV0IHI7Zm9yKGNvbnN0IG4gb2YgZS52YWx1ZXMoKSl7Y29uc3R7b3B0OmksY2FuUm90YXRlOmEsc2NhbGVUeXBlOmwsdG9vbHNUeXBlOnN9PW47dGhpcy5zZWxlY3RvckNvbG9yPXRoaXMud29ya09wdGlvbnMuc3Ryb2tlQ29sb3IsaS5zdHJva2VDb2xvciYmKHRoaXMuc3Ryb2tlQ29sb3I9aS5zdHJva2VDb2xvciksaS5maWxsQ29sb3ImJih0aGlzLmZpbGxDb2xvcj1pLmZpbGxDb2xvciksaS50ZXh0T3B0JiYodGhpcy50ZXh0T3B0PWkudGV4dE9wdCkscz09PWR0LlNwZWVjaEJhbGxvb24mJih0LmFkZChzKSx0aGlzLnNoYXBlT3B0fHwodGhpcy5zaGFwZU9wdD17fSksdGhpcy5zaGFwZU9wdC5wbGFjZW1lbnQ9aS5wbGFjZW1lbnQpLHM9PT1kdC5Qb2x5Z29uJiYodC5hZGQocyksdGhpcy5zaGFwZU9wdHx8KHRoaXMuc2hhcGVPcHQ9e30pLHRoaXMuc2hhcGVPcHQudmVydGljZXM9aS52ZXJ0aWNlcykscz09PWR0LlN0YXImJih0LmFkZChzKSx0aGlzLnNoYXBlT3B0fHwodGhpcy5zaGFwZU9wdD17fSksdGhpcy5zaGFwZU9wdC52ZXJ0aWNlcz1pLnZlcnRpY2VzLHRoaXMuc2hhcGVPcHQuaW5uZXJSYXRpbz1pLmlubmVyUmF0aW8sdGhpcy5zaGFwZU9wdC5pbm5lclZlcnRpY2VTdGVwPWkuaW5uZXJWZXJ0aWNlU3RlcCkscz09PWR0LlRleHQmJih0aGlzLnRleHRPcHQ9aSksZS5zaXplPT09MSYmKHRoaXMudGV4dE9wdCYmKHRoaXMuY2FuVGV4dEVkaXQ9ITApLHRoaXMuY2FuUm90YXRlPWEsdGhpcy5zY2FsZVR5cGU9bCksbD09PWp0Lm5vbmUmJih0aGlzLnNjYWxlVHlwZT1sKSxzPT09ZHQuSW1hZ2UmJihyPW4pfXQuc2l6ZSYmKHRoaXMudG9vbHNUeXBlcz1bLi4udF0pLHImJihlLnNpemU9PT0xPyh0aGlzLmNhbkxvY2s9ITAsci5vcHQubG9ja2VkJiYodGhpcy5pc0xvY2tlZD0hMCx0aGlzLnNjYWxlVHlwZT1qdC5ub25lLHRoaXMuY2FuUm90YXRlPSExLHRoaXMudGV4dE9wdD12b2lkIDAsdGhpcy5maWxsQ29sb3I9dm9pZCAwLHRoaXMuc2VsZWN0b3JDb2xvcj0icmdiKDE3NywxNzcsMTc3KSIsdGhpcy5zdHJva2VDb2xvcj12b2lkIDAsdGhpcy5jYW5UZXh0RWRpdD0hMSkpOmUuc2l6ZT4xJiYhci5vcHQubG9ja2VkJiYodGhpcy5jYW5Mb2NrPSExLHRoaXMuY2FuUm90YXRlPSExKSl9Z2V0Q2hpbGRyZW5Qb2ludHMoKXt2YXIgZTtpZih0aGlzLnNjYWxlVHlwZT09PWp0LmJvdGgmJnRoaXMuc2VsZWN0SWRzKXtjb25zdCB0PXRoaXMuc2VsZWN0SWRzWzBdLHI9KGU9dGhpcy52Tm9kZXMuZ2V0KHQpKT09bnVsbD92b2lkIDA6ZS5vcDtpZihyKXtjb25zdCBuPVtdO2ZvcihsZXQgaT0wO2k8ci5sZW5ndGg7aSs9MyluLnB1c2goW3JbaV0scltpKzFdXSk7cmV0dXJuIG59fX1jb25zdW1lKGUpe2NvbnN0e29wOnQsd29ya1N0YXRlOnJ9PWUuZGF0YTtsZXQgbj10aGlzLm9sZFNlbGVjdFJlY3Q7aWYocj09PVJ0LlN0YXJ0JiYobj10aGlzLmJhY2tUb0Z1bGxMYXllcigpKSwhKHQhPW51bGwmJnQubGVuZ3RoKXx8IXRoaXMudk5vZGVzLmN1ck5vZGVNYXAuc2l6ZSlyZXR1cm57dHlwZTphdC5Ob25lfTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModCk7Y29uc3QgaT10aGlzLmNvbXB1dFNlbGVjdG9yKCk7aWYodGhpcy5zZWxlY3RJZHMmJk5oKHRoaXMuc2VsZWN0SWRzLGkuc2VsZWN0SWRzKSlyZXR1cm57dHlwZTphdC5Ob25lfTt0aGlzLnNlbGVjdElkcz1pLnNlbGVjdElkcztjb25zdCBhPWkuaW50ZXJzZWN0UmVjdDt0aGlzLmdldFNlbGVjdGVvckluZm8oaS5zdWJOb2RlTWFwKSx0aGlzLmRyYXcoSXQuc2VsZWN0b3JJZCx0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsaSksdGhpcy5vbGRTZWxlY3RSZWN0PWE7Y29uc3QgbD10aGlzLmdldENoaWxkcmVuUG9pbnRzKCk7cmV0dXJue3R5cGU6YXQuU2VsZWN0LGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6YnQoYSxuKSxzZWxlY3RJZHM6aS5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMsc2VsZWN0UmVjdDphLHNlbGVjdG9yQ29sb3I6dGhpcy5zZWxlY3RvckNvbG9yLHN0cm9rZUNvbG9yOnRoaXMuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLHRleHRPcHQ6dGhpcy50ZXh0T3B0LGNhblRleHRFZGl0OnRoaXMuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNhbkxvY2s6dGhpcy5jYW5Mb2NrLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSx3aWxsU3luY1NlcnZpY2U6ITAscG9pbnRzOmwsaXNMb2NrZWQ6dGhpcy5pc0xvY2tlZCx0b29sc1R5cGVzOnRoaXMudG9vbHNUeXBlcyxzaGFwZU9wdDp0aGlzLnNoYXBlT3B0fX1jb25zdW1lQWxsKGUpe3ZhciB0LHI7aWYoISgodD10aGlzLnNlbGVjdElkcykhPW51bGwmJnQubGVuZ3RoKSYmdGhpcy50bXBQb2ludHNbMF0mJnRoaXMuc2VsZWN0U2luZ2xlVG9vbCh0aGlzLnRtcFBvaW50c1swXS5YWSxJdC5zZWxlY3RvcklkLCExLGU9PW51bGw/dm9pZCAwOmUuaG92ZXJJZCksKHI9dGhpcy5zZWxlY3RJZHMpIT1udWxsJiZyLmxlbmd0aCYmdGhpcy5zZWFsVG9EcmF3TGF5ZXIodGhpcy5zZWxlY3RJZHMpLHRoaXMub2xkU2VsZWN0UmVjdCl7Y29uc3Qgbj10aGlzLmdldENoaWxkcmVuUG9pbnRzKCk7cmV0dXJue3R5cGU6YXQuU2VsZWN0LGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LHNlbGVjdElkczp0aGlzLnNlbGVjdElkcyxvcHQ6dGhpcy53b3JrT3B0aW9ucyxzZWxlY3RvckNvbG9yOnRoaXMuc2VsZWN0b3JDb2xvcixzZWxlY3RSZWN0OnRoaXMub2xkU2VsZWN0UmVjdCxzdHJva2VDb2xvcjp0aGlzLnN0cm9rZUNvbG9yLGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvcix0ZXh0T3B0OnRoaXMudGV4dE9wdCxjYW5UZXh0RWRpdDp0aGlzLmNhblRleHRFZGl0LGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjYW5Mb2NrOnRoaXMuY2FuTG9jayxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsd2lsbFN5bmNTZXJ2aWNlOiEwLHBvaW50czpuLGlzTG9ja2VkOnRoaXMuaXNMb2NrZWQsdG9vbHNUeXBlczp0aGlzLnRvb2xzVHlwZXMsc2hhcGVPcHQ6dGhpcy5zaGFwZU9wdH19cmV0dXJue3R5cGU6YXQuTm9uZX19Y29uc3VtZVNlcnZpY2UoKXt9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1jbGVhclNlbGVjdERhdGEoKXt0aGlzLnNlbGVjdElkcz12b2lkIDAsdGhpcy5vbGRTZWxlY3RSZWN0PXZvaWQgMH1zZWxlY3RTaW5nbGVUb29sKGUsdD1JdC5zZWxlY3RvcklkLHI9ITEsbil7aWYoZS5sZW5ndGg9PT0yKXtjb25zdCBpPWVbMF0sYT1lWzFdO2xldCBsO2Zvcihjb25zdCBzIG9mIHRoaXMuZnVsbExheWVyLmNoaWxkcmVuKXtjb25zdCBmPVFuKFtzXSk7bGV0IHY9ITE7aWYoKG4mJm49PT1zLm5hbWV8fCExKSYmZi5maW5kKHA9PnAuaXNQb2ludENvbGxpc2lvbihpLGEpKSl7bD1zO2JyZWFrfWZvcihjb25zdCBwIG9mIGYpaWYodj1wLmlzUG9pbnRDb2xsaXNpb24oaSxhKSx2KXtpZighbClsPXM7ZWxzZXtjb25zdCB5PXRoaXMudk5vZGVzLmdldChzLm5hbWUpLFA9dGhpcy52Tm9kZXMuZ2V0KGwubmFtZSk7aWYoKHk9PW51bGw/dm9pZCAwOnkudG9vbHNUeXBlKSE9PWR0LlRleHQmJihQPT1udWxsP3ZvaWQgMDpQLnRvb2xzVHlwZSk9PT1kdC5UZXh0KWJyZWFrO2lmKCh5PT1udWxsP3ZvaWQgMDp5LnRvb2xzVHlwZSk9PT1kdC5UZXh0JiYoUD09bnVsbD92b2lkIDA6UC50b29sc1R5cGUpIT09ZHQuVGV4dClsPXM7ZWxzZXtjb25zdCB4PSh5PT1udWxsP3ZvaWQgMDp5Lm9wdC56SW5kZXgpfHwwLG09KFA9PW51bGw/dm9pZCAwOlAub3B0LnpJbmRleCl8fDA7TnVtYmVyKHgpPj1OdW1iZXIobSkmJihsPXMpfX1icmVha319aWYobCl7Y29uc3Qgcz1sLm5hbWUsZj10aGlzLnZOb2Rlcy5nZXQocyk7aWYoZil7aWYoISRuKHRoaXMub2xkU2VsZWN0UmVjdCxmLnJlY3QpKXtjb25zdCB2PW5ldyBNYXAoW1tzLGZdXSk7dGhpcy5nZXRTZWxlY3Rlb3JJbmZvKHYpLHRoaXMuZHJhdyh0LHRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7aW50ZXJzZWN0UmVjdDpmLnJlY3Qsc3ViTm9kZU1hcDp2LHNlbGVjdElkczp0aGlzLnNlbGVjdElkc3x8W119LHIpfXRoaXMuc2VsZWN0SWRzPVtzXSx0aGlzLm9sZFNlbGVjdFJlY3Q9Zi5yZWN0fX19fWJhY2tUb0Z1bGxMYXllcihlKXt2YXIgaSxhO2xldCB0O2NvbnN0IHI9W10sbj1bXTtmb3IoY29uc3QgbCBvZigoaT10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmkuY2hpbGRyZW4pfHxbXSlpZighKGUhPW51bGwmJmUubGVuZ3RoJiYhZS5pbmNsdWRlcyhsLmlkKSkmJmwuaWQhPT1JdC5zZWxlY3RvcklkKXtjb25zdCBzPWwuY2xvbmVOb2RlKCEwKTtVZShsKSYmcy5zZWFsKCksdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUobC5uYW1lKS5sZW5ndGh8fHIucHVzaChzKSxuLnB1c2gobCk7Y29uc3QgZj0oYT10aGlzLnZOb2Rlcy5nZXQobC5uYW1lKSk9PW51bGw/dm9pZCAwOmEucmVjdDtmJiYodD1idCh0LGYpKX1yZXR1cm4gbi5mb3JFYWNoKGw9PmwucmVtb3ZlKCkpLHIubGVuZ3RoJiZ0aGlzLmZ1bGxMYXllci5hcHBlbmQoLi4uciksdH1zZWFsVG9EcmF3TGF5ZXIoZSl7dmFyIG47Y29uc3QgdD1bXSxyPVtdO2UuZm9yRWFjaChpPT57dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoaS50b1N0cmluZygpKS5mb3JFYWNoKGE9Pnt2YXIgcztjb25zdCBsPWEuY2xvbmVOb2RlKCEwKTtVZShhKSYmbC5zZWFsKCksKHM9dGhpcy5kcmF3TGF5ZXIpIT1udWxsJiZzLmdldEVsZW1lbnRzQnlOYW1lKGEubmFtZSkubGVuZ3RofHx0LnB1c2gobCksci5wdXNoKGEpfSl9KSxyLmZvckVhY2goaT0+aS5yZW1vdmUoKSksdCYmKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8bi5hcHBlbmQoLi4udCkpfWdldFNlbGVjdG9yUmVjdChlLHQpe3ZhciBhO2xldCByO2NvbnN0IG49KGE9ZS5wYXJlbnQpPT1udWxsP3ZvaWQgMDphLmdldEVsZW1lbnRCeUlkKHQpLGk9bj09bnVsbD92b2lkIDA6bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4gaSYmKHI9YnQocix7eDpNYXRoLmZsb29yKGkueCkseTpNYXRoLmZsb29yKGkueSksdzpNYXRoLnJvdW5kKGkud2lkdGgpLGg6TWF0aC5yb3VuZChpLmhlaWdodCl9KSkscn1pc0NhbkZpbGxDb2xvcihlKXtyZXR1cm4gZT09PWR0LkVsbGlwc2V8fGU9PT1kdC5UcmlhbmdsZXx8ZT09PWR0LlJlY3RhbmdsZXx8ZT09PWR0LlBvbHlnb258fGU9PT1kdC5TdGFyfHxlPT09ZHQuU3BlZWNoQmFsbG9vbn1hc3luYyB1cGRhdGVTZWxlY3RvcihlKXtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDp0LHNlbGVjdElkczpyLHZOb2RlczpuLHdpbGxTZXJpYWxpemVEYXRhOmksd29ya2VyOmEsb2Zmc2V0Omwsc2NlbmU6c309ZSxmPXRoaXMuZHJhd0xheWVyO2lmKCFmKXJldHVybjtsZXQgdjtjb25zdCBkPW5ldyBNYXAse2JveDpwLHdvcmtTdGF0ZTp5LGFuZ2xlOlAsdHJhbnNsYXRlOnh9PXQ7bGV0IG09WzAsMF0sTz1bMSwxXSxvPVswLDBdLGgsYztpZihwfHx4fHxuZShQKSl7aWYoeT09PVJ0LlN0YXJ0KXJldHVybiBuLnNldFRhcmdldCgpLHt0eXBlOmF0LlNlbGVjdCxkYXRhVHlwZTpPdC5Mb2NhbCxzZWxlY3RSZWN0OnRoaXMub2xkU2VsZWN0UmVjdCxyZWN0OnRoaXMub2xkU2VsZWN0UmVjdH07aWYoaD1uLmdldExhc3RUYXJnZXQoKSxoJiZwKXtsZXQgRTtyPT1udWxsfHxyLmZvckVhY2goQT0+e2NvbnN0IEw9aD09bnVsbD92b2lkIDA6aC5nZXQoQSk7RT1idChFLEw9PW51bGw/dm9pZCAwOkwucmVjdCl9KSxFJiYoTz1bcC53L0UudyxwLmgvRS5oXSxtPVtwLngrcC53LzItKEUueCtFLncvMikscC55K3AuaC8yLShFLnkrRS5oLzIpXSxvPVtFLngrRS53LzIsRS55K0UuaC8yXSksYz1FfX1pZihyKWZvcihjb25zdCBFIG9mIHIpe2NvbnN0IEE9bi5nZXQoRSk7aWYoQSl7Y29uc3R7dG9vbHNUeXBlOkx9PUE7bGV0IE09KGY9PW51bGw/dm9pZCAwOmYuZ2V0RWxlbWVudHNCeU5hbWUoRSkpWzBdO2lmKE0pe2NvbnN0IEk9ey4uLnR9O2xldCBEO2lmKEwpe2lmKGgmJihEPWguZ2V0KEUpLEQmJnApKXtJLmJveFNjYWxlPU87Y29uc3QgQz1bRC5yZWN0LngrRC5yZWN0LncvMixELnJlY3QueStELnJlY3QuaC8yXSxCPVtDWzBdLW9bMF0sQ1sxXS1vWzFdXTtJLmJveFRyYW5zbGF0ZT1bQlswXSooT1swXS0xKSttWzBdKyhsJiZsWzBdfHwwKSxCWzFdKihPWzFdLTEpK21bMV0rKGwmJmxbMV18fDApXX1jb25zdCBSPUpuKEwpO2lmKFI9PW51bGx8fFIudXBkYXRlTm9kZU9wdCh7bm9kZTpNLG9wdDpJLHZOb2RlczpuLHdpbGxTZXJpYWxpemVEYXRhOmksdGFyZ2V0Tm9kZTpEfSksQSYmYSYmKGkmJihJLmFuZ2xlfHxJLnRyYW5zbGF0ZSl8fEkuYm94JiZJLndvcmtTdGF0ZSE9PVJ0LlN0YXJ0fHxJLnBvaW50TWFwJiZJLnBvaW50TWFwLmhhcyhFKXx8TD09PWR0LlRleHQmJihJLmZvbnRTaXplfHxJLnRleHRJbmZvcyYmSS50ZXh0SW5mb3MuZ2V0KEUpKXx8TD09PWR0LkltYWdlJiYoSS5hbmdsZXx8SS50cmFuc2xhdGV8fEkuYm94U2NhbGUpfHxMPT09SS50b29sc1R5cGUmJkkud2lsbFJlZnJlc2gpKXtjb25zdCBDPWEuY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNUeXBlOkwsdG9vbHNPcHQ6QS5vcHR9KTtDPT1udWxsfHxDLnNldFdvcmtJZChFKTtsZXQgQjtMPT09ZHQuSW1hZ2UmJnM/Qj1hd2FpdCBDLmNvbnN1bWVTZXJ2aWNlQXN5bmMoe2lzRnVsbFdvcms6ITEscmVwbGFjZUlkOkUsc2NlbmU6c30pOkI9Qz09bnVsbD92b2lkIDA6Qy5jb25zdW1lU2VydmljZSh7b3A6QS5vcCxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDpFLGlzQ2xlYXJBbGw6ITF9KSxCJiYoQS5yZWN0PUIsbi5zZXRJbmZvKEUsQSkpLE09KGY9PW51bGw/dm9pZCAwOmYuZ2V0RWxlbWVudHNCeU5hbWUoRSkpWzBdfUEmJihkLnNldChFLEEpLHY9YnQodixBLnJlY3QpKX19fX1oJiZ5PT09UnQuRG9uZSYmbi5kZWxldGVMYXN0VGFyZ2V0KCk7Y29uc3QgZz12O2lmKGMmJnQuZGlyJiZnKXtsZXQgRT1bMCwwXTtzd2l0Y2godC5kaXIpe2Nhc2UidG9wTGVmdCI6Y2FzZSJsZWZ0Ijp7Y29uc3QgQT1bYy54K2MudyxjLnkrYy5oXTtFPVtBWzBdLShnLngrZy53KSxBWzFdLShnLnkrZy5oKV07YnJlYWt9Y2FzZSJib3R0b21MZWZ0IjpjYXNlImJvdHRvbSI6e2NvbnN0IEE9W2MueCtjLncsYy55XTtFPVtBWzBdLShnLngrZy53KSxBWzFdLWcueV07YnJlYWt9Y2FzZSJ0b3BSaWdodCI6Y2FzZSJ0b3AiOntjb25zdCBBPVtjLngsYy55K2MuaF07RT1bQVswXS1nLngsQVsxXS0oZy55K2cuaCldO2JyZWFrfWNhc2UicmlnaHQiOmNhc2UiYm90dG9tUmlnaHQiOntjb25zdCBBPVtjLngsYy55XTtFPVtBWzBdLWcueCxBWzFdLWcueV07YnJlYWt9fWlmKEVbMF18fEVbMV0pcmV0dXJuIGcueD1nLngrRVswXSxnLnk9Zy55K0VbMV0sYXdhaXQgdGhpcy51cGRhdGVTZWxlY3Rvcih7Li4uZSxvZmZzZXQ6RX0pfXRoaXMuZ2V0U2VsZWN0ZW9ySW5mbyhkKSx0aGlzLmRyYXcoSXQuc2VsZWN0b3JJZCxmLHtzZWxlY3RJZHM6cnx8W10sc3ViTm9kZU1hcDpkLGludGVyc2VjdFJlY3Q6Z30pO2NvbnN0IGI9YnQodGhpcy5vbGRTZWxlY3RSZWN0LHYpO3JldHVybiB0aGlzLm9sZFNlbGVjdFJlY3Q9dix7dHlwZTphdC5TZWxlY3QsZGF0YVR5cGU6T3QuTG9jYWwsc2VsZWN0UmVjdDpnLHJlbmRlclJlY3Q6dixyZWN0OmJ0KGIsZyl9fWJsdXJTZWxlY3Rvcigpe2NvbnN0IGU9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoKTtyZXR1cm57dHlwZTphdC5TZWxlY3QsZGF0YVR5cGU6T3QuTG9jYWwscmVjdDplLHNlbGVjdElkczpbXSx3aWxsU3luY1NlcnZpY2U6ITB9fWdldFJpZ2h0U2VydmljZUlkKGUpe3JldHVybiBlLnJlcGxhY2UoIisrIiwiLSIpfXNlbGVjdFNlcnZpY2VOb2RlKGUsdCxyKXtjb25zdHtzZWxlY3RJZHM6bn09dCxpPXRoaXMuZ2V0UmlnaHRTZXJ2aWNlSWQoZSksYT10aGlzLmdldFNlbGVjdG9yUmVjdCh0aGlzLmZ1bGxMYXllcixpKTtsZXQgbDtjb25zdCBzPW5ldyBNYXA7cmV0dXJuIG49PW51bGx8fG4uZm9yRWFjaChmPT57Y29uc3Qgdj10aGlzLnZOb2Rlcy5nZXQoZiksZD10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShmKVswXTt2JiZkJiYobD1idChsLHYucmVjdCkscy5zZXQoZix2KSl9KSx0aGlzLmdldFNlbGVjdGVvckluZm8ocyksdGhpcy5kcmF3KGksdGhpcy5mdWxsTGF5ZXIse2ludGVyc2VjdFJlY3Q6bCxzZWxlY3RJZHM6bnx8W10sc3ViTm9kZU1hcDpzfSxyKSxidChsLGEpfXJlUmVuZGVyU2VsZWN0b3IoKXt2YXIgcjtsZXQgZTtjb25zdCB0PW5ldyBNYXA7cmV0dXJuKHI9dGhpcy5zZWxlY3RJZHMpPT1udWxsfHxyLmZvckVhY2gobj0+e2NvbnN0IGk9dGhpcy52Tm9kZXMuZ2V0KG4pO2kmJihlPWJ0KGUsaS5yZWN0KSx0LnNldChuLGkpKX0sdGhpcyksdGhpcy5nZXRTZWxlY3Rlb3JJbmZvKHQpLHRoaXMuZHJhdyhJdC5zZWxlY3RvcklkLHRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7aW50ZXJzZWN0UmVjdDplLHN1Yk5vZGVNYXA6dCxzZWxlY3RJZHM6dGhpcy5zZWxlY3RJZHN8fFtdfSksdGhpcy5vbGRTZWxlY3RSZWN0PWUsZX11cGRhdGVTZWxlY3RJZHMoZSl7dmFyIGEsbDtsZXQgdDtjb25zdCByPShhPXRoaXMuc2VsZWN0SWRzKT09bnVsbD92b2lkIDA6YS5maWx0ZXIocz0+IWUuaW5jbHVkZXMocykpLG49ZS5maWx0ZXIocz0+e3ZhciBmO3JldHVybiEoKGY9dGhpcy5zZWxlY3RJZHMpIT1udWxsJiZmLmluY2x1ZGVzKHMpKX0pO2lmKHIhPW51bGwmJnIubGVuZ3RoJiYodD10aGlzLmJhY2tUb0Z1bGxMYXllcihyKSksbi5sZW5ndGgpe3RoaXMuc2VhbFRvRHJhd0xheWVyKG4pO2Zvcihjb25zdCBzIG9mIG4pe2NvbnN0IGY9KGw9dGhpcy52Tm9kZXMuZ2V0KHMpKT09bnVsbD92b2lkIDA6bC5yZWN0O2YmJih0PWJ0KHQsZikpfX10aGlzLnNlbGVjdElkcz1lO2NvbnN0IGk9dGhpcy5yZVJlbmRlclNlbGVjdG9yKCk7cmV0dXJue2JnUmVjdDp0LHNlbGVjdFJlY3Q6aX19Y3Vyc29ySG92ZXIoZSl7dmFyIGksYTtjb25zdCB0PXRoaXMub2xkU2VsZWN0UmVjdDt0aGlzLnNlbGVjdElkcz1bXTtjb25zdCByPShpPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6aS50b1N0cmluZygpLG49W2VbMF0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0sZVsxXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXV07aWYodGhpcy5zZWxlY3RTaW5nbGVUb29sKG4sciwhMCksdGhpcy5vbGRTZWxlY3RSZWN0JiYhJG4odCx0aGlzLm9sZFNlbGVjdFJlY3QpKXJldHVybnt0eXBlOmF0LkN1cnNvckhvdmVyLGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6YnQodCx0aGlzLm9sZFNlbGVjdFJlY3QpLHNlbGVjdG9yQ29sb3I6dGhpcy5zZWxlY3RvckNvbG9yLHdpbGxTeW5jU2VydmljZTohMX07aWYoKGE9dGhpcy5zZWxlY3RJZHMpIT1udWxsJiZhLmxlbmd0aHx8KHRoaXMub2xkU2VsZWN0UmVjdD12b2lkIDApLHQmJiF0aGlzLm9sZFNlbGVjdFJlY3QpcmV0dXJuIHRoaXMuY3Vyc29yQmx1cigpLHt0eXBlOmF0LkN1cnNvckhvdmVyLGRhdGFUeXBlOk90LkxvY2FsLHJlY3Q6dCxzZWxlY3RvckNvbG9yOnRoaXMuc2VsZWN0b3JDb2xvcix3aWxsU3luY1NlcnZpY2U6ITF9fWN1cnNvckJsdXIoKXt2YXIgdCxyO2NvbnN0IGU9KHQ9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7KChyPXRoaXMuZnVsbExheWVyKT09bnVsbD92b2lkIDA6ci5wYXJlbnQpLmNoaWxkcmVuLmZvckVhY2gobj0+e24ubmFtZT09PWUmJm4ucmVtb3ZlKCl9KX19T2JqZWN0LmRlZmluZVByb3BlcnR5KEl0LCJzZWxlY3RvcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6UWh9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoSXQsInNlbGVjdG9yQm9yZGVySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToic2VsZWN0b3ItYm9yZGVyIn0pO2NsYXNzIHpuIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmp0LmJvdGh9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuQXJyb3d9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhcnJvd1RpcFdpZHRoIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5hcnJvd1RpcFdpZHRoPXRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKjQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgeTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUsaT0oeT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOnkudG9TdHJpbmcoKTtpZighaSlyZXR1cm57dHlwZTphdC5Ob25lfTtjb25zdHtvcDphLHdvcmtTdGF0ZTpsfT10LHM9YT09bnVsbD92b2lkIDA6YS5sZW5ndGg7aWYoIXN8fHM8MilyZXR1cm57dHlwZTphdC5Ob25lfTtsZXQgZjtpZihsPT09UnQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgeHQoYVswXSxhWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMoYSksIWYpcmV0dXJue3R5cGU6YXQuTm9uZX07aWYoIW4pe2NvbnN0IFA9RGF0ZS5ub3coKTtyZXR1cm4gUC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1QLHt0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppLG9wOnRoaXMudG1wUG9pbnRzLm1hcCh4PT5bLi4ueC5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOmF0Lk5vbmV9fWNvbnN0IHY9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsZD10aGlzLmRyYXcoe3dvcmtJZDppLGxheWVyOnZ9KSxwPWJ0KGQsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWQse3JlY3Q6cCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppfX1jb25zdW1lQWxsKGUpe3ZhciBzO2NvbnN0e2RhdGE6dH09ZSxyPShzPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixpPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bn0pO3RoaXMub2xkUmVjdD1pO2NvbnN0IGE9dGhpcy50bXBQb2ludHMubWFwKGY9PlsuLi5mLlhZLDBdKS5mbGF0KDEpLGw9cXQoYSk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8ocix7cmVjdDppLG9wOmEsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOnB0LmdldENlbnRlclBvcyhpLG4pfSkse3JlY3Q6aSx0eXBlOmF0LkZ1bGxXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDpyLG9wczpsLGlzU3luYzohMH19ZHJhdyhlKXt2YXIgTztjb25zdHt3b3JrSWQ6dCxsYXllcjpyfT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChvPT5vLnJlbW92ZSgpKSwoTz10aGlzLmRyYXdMYXllcik9PW51bGx8fE8uZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKG89Pm8ucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOm4sdGhpY2tuZXNzOmksekluZGV4OmEsc2NhbGU6bCxyb3RhdGU6cyx0cmFuc2xhdGU6Zn09dGhpcy53b3JrT3B0aW9ucyx2PXIud29ybGRQb3NpdGlvbixkPXIud29ybGRTY2FsaW5nLHtwb2ludHM6cCxyZWN0Onl9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhpKSx4PXtwb3M6W3kueCt5LncvMix5LnkreS5oLzJdLG5hbWU6dCxpZDp0LGNsb3NlOiEwLHBvaW50czpwLGZpbGxDb2xvcjpuLHN0cm9rZUNvbG9yOm4sbGluZVdpZHRoOjAsbm9ybWFsaXplOiEwLHpJbmRleDphfTtsJiYoeC5zY2FsZT1sKSxzJiYoeC5yb3RhdGU9cyksZiYmKHgudHJhbnNsYXRlPWYpO2NvbnN0IG09bmV3IGVlKHgpO2lmKHIuYXBwZW5kKG0pLGx8fHN8fGYpe2NvbnN0IG89bS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKG8ueC1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKG8ueS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKG8ud2lkdGgrcHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKG8uaGVpZ2h0K3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm57eDpNYXRoLmZsb29yKHkueCpkWzBdK3ZbMF0tcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcih5LnkqZFsxXSt2WzFdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoeS53KmRbMF0rMipwdC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKHkuaCpkWzFdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpfX1jb21wdXREcmF3UG9pbnRzKGUpe3JldHVybiB0aGlzLnRtcFBvaW50c1sxXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1swXSk+dGhpcy5hcnJvd1RpcFdpZHRoP3RoaXMuY29tcHV0RnVsbEFycm93UG9pbnRzKGUpOnRoaXMuY29tcHV0VHJpYW5nbGVQb2ludHMoKX1jb21wdXRGdWxsQXJyb3dQb2ludHMoZSl7Y29uc3QgdD1ldC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHI9ZXQuUGVyKHQpLm11bChlLzIpLG49eHQuU3ViKHRoaXMudG1wUG9pbnRzWzBdLHIpLGk9eHQuQWRkKHRoaXMudG1wUG9pbnRzWzBdLHIpLGE9ZXQuTXVsKHQsdGhpcy5hcnJvd1RpcFdpZHRoKSxsPWV0LlN1Yih0aGlzLnRtcFBvaW50c1sxXSxhKSxzPXh0LlN1YihsLHIpLGY9eHQuQWRkKGwsciksdj1ldC5QZXIodCkubXVsKGUqMS41KSxkPXh0LlN1YihsLHYpLHA9eHQuQWRkKGwsdikseT1bbixzLGQsdGhpcy50bXBQb2ludHNbMV0scCxmLGldO3JldHVybntwb2ludHM6eS5tYXAoUD0+eHQuU3ViKFAsdGhpcy50bXBQb2ludHNbMF0pLlhZKS5mbGF0KDEpLHJlY3Q6TnQoeSksaXNUcmlhbmdsZTohMSxwb3M6dGhpcy50bXBQb2ludHNbMF0uWFl9fWNvbXB1dFRyaWFuZ2xlUG9pbnRzKCl7Y29uc3QgZT1ldC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHQ9dGhpcy50bXBQb2ludHNbMV0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbMF0pLHI9ZXQuUGVyKGUpLm11bChNYXRoLmZsb29yKHQqMy84KSksbj14dC5TdWIodGhpcy50bXBQb2ludHNbMF0sciksaT14dC5BZGQodGhpcy50bXBQb2ludHNbMF0sciksYT1bbix0aGlzLnRtcFBvaW50c1sxXSxpXTtyZXR1cm57cG9pbnRzOmEubWFwKGw9Pnh0LlN1YihsLHRoaXMudG1wUG9pbnRzWzBdKS5YWSkuZmxhdCgxKSxyZWN0Ok50KGEpLGlzVHJpYW5nbGU6ITAscG9zOnRoaXMudG1wUG9pbnRzWzBdLlhZfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMikscj1uZXcgeHQodFswXSx0WzFdKSxuPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6aX09dGhpcy53b3JrT3B0aW9ucztpZihuLmlzTmVhcihyLGkpKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBsO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGw9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpsLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyB4dCh0W3NdLHRbcysxXSx0W3MrMl0pKTtjb25zdCBpPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGE9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjppfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1hLHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDphLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOnB0LmdldENlbnRlclBvcyhhLGkpfSksYX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBsO2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6aX09cixhPW4uZ2V0KHQubmFtZSk7cmV0dXJuIGkmJih0LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLGkpLHQuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGkpLChsPWE9PW51bGw/dm9pZCAwOmEub3B0KSE9bnVsbCYmbC5zdHJva2VDb2xvciYmKGEub3B0LnN0cm9rZUNvbG9yPWkpLGEmJm4uc2V0SW5mbyh0Lm5hbWUsYSkpLHB0LnVwZGF0ZU5vZGVPcHQoZSl9fWNsYXNzIEduIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmp0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpkdC5FbGxpcHNlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciB5O2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxpPSh5PXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6eS50b1N0cmluZygpO2lmKCFpKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0e29wOmEsd29ya1N0YXRlOmx9PXQscz1hPT1udWxsP3ZvaWQgMDphLmxlbmd0aDtpZighc3x8czwyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2xldCBmO2lmKGw9PT1SdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyB4dChhWzBdLGFbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhhKSwhZilyZXR1cm57dHlwZTphdC5Ob25lfTtpZighbil7Y29uc3QgUD1EYXRlLm5vdygpO3JldHVybiBQLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVAse3R5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmksb3A6dGhpcy50bXBQb2ludHMubWFwKHg9PlsuLi54LlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6YXQuTm9uZX19Y29uc3Qgdj1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixkPXRoaXMuZHJhdyh7d29ya0lkOmksbGF5ZXI6dixpc0RyYXdpbmc6ITB9KSxwPWJ0KGQsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWQse3JlY3Q6cCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppfX1jb25zdW1lQWxsKGUpe3ZhciBzO2NvbnN0e2RhdGE6dH09ZSxyPShzPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixpPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bixpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9aTtjb25zdCBhPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxsPXF0KGEpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6aSxvcDphLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxuKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6bCxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGM7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cixpc0RyYXdpbmc6bn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoZz0+Zy5yZW1vdmUoKSksKGM9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxjLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChnPT5nLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjppLGZpbGxDb2xvcjphLHRoaWNrbmVzczpsLHpJbmRleDpzLHNjYWxlOmYscm90YXRlOnYsdHJhbnNsYXRlOmR9PXRoaXMud29ya09wdGlvbnMscD1yLndvcmxkUG9zaXRpb24seT1yLndvcmxkU2NhbGluZyx7cmFkaXVzOlAscmVjdDp4LHBvczptfT10aGlzLmNvbXB1dERyYXdQb2ludHMobCksTz17cG9zOm0sbmFtZTp0LGlkOnQscmFkaXVzOlAsbGluZVdpZHRoOmwsZmlsbENvbG9yOmEhPT0idHJhbnNwYXJlbnQiJiZhfHx2b2lkIDAsc3Ryb2tlQ29sb3I6aSxub3JtYWxpemU6ITAsekluZGV4OnN9LG89e3g6TWF0aC5mbG9vcih4LngqeVswXStwWzBdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoeC55KnlbMV0rcFsxXS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKHgudyp5WzBdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcih4LmgqeVsxXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKX07aWYobil7Y29uc3R7bmFtZTpnLGlkOmIsekluZGV4OkUsc3Ryb2tlQ29sb3I6QX09TyxMPXB0LmdldENlbnRlclBvcyhvLHIpLE09bmV3IHRlKHtuYW1lOmcsaWQ6Yix6SW5kZXg6RSxwb3M6TCxhbmNob3I6Wy41LC41XSxzaXplOltvLncsby5oXX0pLEk9bmV3IFBuKHsuLi5PLHBvczpbMCwwXX0pLEQ9bmV3IGFlKHtkOiJNLTQsMEg0TTAsLTRWNCIsbm9ybWFsaXplOiEwLHBvczpbMCwwXSxzdHJva2VDb2xvcjpBLGxpbmVXaWR0aDoxLHNjYWxlOlsxL3lbMF0sMS95WzFdXX0pO3JldHVybiBNLmFwcGVuZChJLEQpLHIuYXBwZW5kKE0pLG99ZiYmKE8uc2NhbGU9ZiksdiYmKE8ucm90YXRlPXYpLGQmJihPLnRyYW5zbGF0ZT1kKTtjb25zdCBoPW5ldyBQbihPKTtpZihyLmFwcGVuZChoKSx2fHxmfHxkKXtjb25zdCBnPWguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihnLngtcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihnLnktcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihnLndpZHRoK3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihnLmhlaWdodCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19cmV0dXJuIG99Y29tcHV0RHJhd1BvaW50cyhlKXtjb25zdCB0PU50KHRoaXMudG1wUG9pbnRzKSxyPU50KHRoaXMudG1wUG9pbnRzLGUpLG49W01hdGguZmxvb3IodC54K3Qudy8yKSxNYXRoLmZsb29yKHQueSt0LmgvMildO3JldHVybntyZWN0OnIscG9zOm4scmFkaXVzOltNYXRoLmZsb29yKHQudy8yKSxNYXRoLmZsb29yKHQuaC8yKV19fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyB4dCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczppfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIsaSkpcmV0dXJuITE7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09Mil7aWYoci5pc05lYXIodGhpcy50bXBQb2ludHNbMV0sMSkpcmV0dXJuITE7dGhpcy50bXBQb2ludHNbMV09cn1lbHNlIHRoaXMudG1wUG9pbnRzLnB1c2gocik7cmV0dXJuITB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIGw7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOnJ9PWUsbj0obD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmwudG9TdHJpbmcoKTtpZighbilyZXR1cm47dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKz0zKXRoaXMudG1wUG9pbnRzLnB1c2gobmV3IHh0KHRbc10sdFtzKzFdLHRbcysyXSkpO2NvbnN0IGk9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsYT10aGlzLmRyYXcoe3dvcmtJZDpuLGxheWVyOmksaXNEcmF3aW5nOiExfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1hLHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDphLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2VudGVyUG9zOnB0LmdldENlbnRlclBvcyhhLGkpfSksYX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe3ZhciBmLHY7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpufT1lLHtzdHJva2VDb2xvcjppLGZpbGxDb2xvcjphfT1yLGw9bi5nZXQodC5uYW1lKTtsZXQgcz10O3JldHVybiB0LnRhZ05hbWU9PT0iR1JPVVAiJiYocz10LmNoaWxkcmVuWzBdKSxpJiYocy5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixpKSwoZj1sPT1udWxsP3ZvaWQgMDpsLm9wdCkhPW51bGwmJmYuc3Ryb2tlQ29sb3ImJihsLm9wdC5zdHJva2VDb2xvcj1pKSksYSYmKGE9PT0idHJhbnNwYXJlbnQiP3Muc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLCJyZ2JhKDAsMCwwLDApIik6cy5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsYSksKHY9bD09bnVsbD92b2lkIDA6bC5vcHQpIT1udWxsJiZ2LmZpbGxDb2xvciYmKGwub3B0LmZpbGxDb2xvcj1hKSksbCYmbi5zZXRJbmZvKHQubmFtZSxsKSxwdC51cGRhdGVOb2RlT3B0KGUpfX12YXIgaWc9aWUsc2c9X3Qsb2c9IltvYmplY3QgQm9vbGVhbl0iO2Z1bmN0aW9uIGFnKHUpe3JldHVybiB1PT09ITB8fHU9PT0hMXx8c2codSkmJmlnKHUpPT1vZ312YXIgbGc9YWcsbGU9Y2UobGcpO2NsYXNzIEhuIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmp0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpkdC5SZWN0YW5nbGV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfXRyYW5zZm9ybURhdGEoKXtjb25zdCBlPU50KHRoaXMudG1wUG9pbnRzKTtyZXR1cm5bW2UueCxlLnksMF0sW2UueCtlLncsZS55LDBdLFtlLngrZS53LGUueStlLmgsMF0sW2UueCxlLnkrZS5oLDBdXX1jb21wdXREcmF3UG9pbnRzKGUpe2NvbnN0e3RoaWNrbmVzczp0fT10aGlzLndvcmtPcHRpb25zLHI9W107Zm9yKGNvbnN0IGEgb2YgZSlyLnB1c2gobmV3IGV0KC4uLmEpKTtjb25zdCBuPU50KHIsdCksaT1bbi54K24udy8yLG4ueStuLmgvMl07cmV0dXJue3JlY3Q6bixwb3M6aSxwb2ludHM6ci5tYXAoYT0+YS5YWSkuZmxhdCgxKX19Y29uc3VtZShlKXt2YXIgUDtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUsaT0oUD10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOlAudG9TdHJpbmcoKTtpZighaSlyZXR1cm57dHlwZTphdC5Ob25lfTtjb25zdHtvcDphLHdvcmtTdGF0ZTpsfT10LHM9YT09bnVsbD92b2lkIDA6YS5sZW5ndGg7aWYoIXN8fHM8MilyZXR1cm57dHlwZTphdC5Ob25lfTtsZXQgZjtpZihsPT09UnQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgeHQoYVswXSxhWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMoYSksIWYpcmV0dXJue3R5cGU6YXQuTm9uZX07Y29uc3Qgdj10aGlzLnRyYW5zZm9ybURhdGEoKTtpZighbil7Y29uc3QgeD1EYXRlLm5vdygpO3JldHVybiB4LXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPXgse3R5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmksb3A6di5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6YXQuTm9uZX19Y29uc3QgZD1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixwPXRoaXMuZHJhdyh7cHM6dix3b3JrSWQ6aSxsYXllcjpkLGlzRHJhd2luZzohMH0pLHk9YnQocCx0aGlzLm9sZFJlY3QpO3JldHVybiB0aGlzLm9sZFJlY3Q9cCx7cmVjdDp5LHR5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOml9fWNvbnN1bWVBbGwoZSl7dmFyIGY7Y29uc3R7ZGF0YTp0fT1lLHI9KGY9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCk7aWYoIXIpcmV0dXJue3R5cGU6YXQuTm9uZX07aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPDIpcmV0dXJue3R5cGU6YXQuUmVtb3ZlTm9kZSxyZW1vdmVJZHM6W3JdfTtjb25zdCBuPXRoaXMudHJhbnNmb3JtRGF0YSgpLGk9dGhpcy5mdWxsTGF5ZXIsYT10aGlzLmRyYXcoe3BzOm4sd29ya0lkOnIsbGF5ZXI6aSxpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9YTtjb25zdCBsPW4uZmxhdCgxKSxzPXF0KGwpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6YSxvcDpsLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczphJiZwdC5nZXRDZW50ZXJQb3MoYSxpKX0pLHtyZWN0OmEsdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6cyxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIEE7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cixpc0RyYXdpbmc6bixwczppLHJlcGxhY2VJZDphfT1lO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGF8fHQpLm1hcChMPT5MLnJlbW92ZSgpKSwoQT10aGlzLmRyYXdMYXllcik9PW51bGx8fEEuZ2V0RWxlbWVudHNCeU5hbWUoYXx8dCkubWFwKEw9PkwucmVtb3ZlKCkpO2NvbnN0e3N0cm9rZUNvbG9yOmwsZmlsbENvbG9yOnMsdGhpY2tuZXNzOmYsekluZGV4OnYsc2NhbGU6ZCxyb3RhdGU6cCx0cmFuc2xhdGU6eSx0ZXh0T3B0OlB9PXRoaXMud29ya09wdGlvbnMseD1yLndvcmxkUG9zaXRpb24sbT1yLndvcmxkU2NhbGluZyx7cG9pbnRzOk8scmVjdDpvLHBvczpofT10aGlzLmNvbXB1dERyYXdQb2ludHMoaSksYz17Y2xvc2U6ITAsbm9ybWFsaXplOiEwLHBvaW50czpPLGxpbmVXaWR0aDpmLGZpbGxDb2xvcjpzIT09InRyYW5zcGFyZW50IiYmc3x8dm9pZCAwLHN0cm9rZUNvbG9yOmwsbGluZUpvaW46InJvdW5kIn0sZz17eDpNYXRoLmZsb29yKG8ueCptWzBdK3hbMF0tcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihvLnkqbVsxXSt4WzFdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3Ioby53Km1bMF0rMipwdC5TYWZlQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKG8uaCptWzBdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpfSxiPW5ldyB0ZSh7bmFtZTp0LGlkOnQsekluZGV4OnYscG9zOmgsYW5jaG9yOlsuNSwuNV0sc2l6ZTpbby53LG8uaF0sc2NhbGU6ZCxyb3RhdGU6cCx0cmFuc2xhdGU6eX0pLEU9bmV3IGVlKHsuLi5jLHBvczpbMCwwXX0pO2lmKGIuYXBwZW5kQ2hpbGQoRSksbil7Y29uc3QgTD1uZXcgYWUoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOmwsbGluZVdpZHRoOjEsc2NhbGU6WzEvbVswXSwxL21bMV1dfSk7Yi5hcHBlbmRDaGlsZChMKX1pZihyLmFwcGVuZChiKSxkfHxwfHx5KXtjb25zdCBMPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihMLngtcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihMLnktcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihMLndpZHRoKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmhlaWdodCsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKX19cmV0dXJuIGd9dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IHh0KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOml9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixpKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgZjtjb25zdHtvcDp0LGlzRnVsbFdvcms6cixyZXBsYWNlSWQ6bn09ZSxpPShmPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Zi50b1N0cmluZygpO2lmKCFpKXJldHVybjtjb25zdCBhPVtdO2ZvcihsZXQgdj0wO3Y8dC5sZW5ndGg7dis9MylhLnB1c2goW3Rbdl0sdFt2KzFdLHRbdisyXV0pO2NvbnN0IGw9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIscz10aGlzLmRyYXcoe3BzOmEsd29ya0lkOmksbGF5ZXI6bCxpc0RyYXdpbmc6ITEscmVwbGFjZUlkOm59KTtyZXR1cm4gdGhpcy5vbGRSZWN0PXMsdGhpcy52Tm9kZXMuc2V0SW5mbyhpLHtyZWN0OnMsb3A6dCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cyYmcHQuZ2V0Q2VudGVyUG9zKHMsbCl9KSxzfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7dmFyIG0sTztjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOmksZmlsbENvbG9yOmEsZm9udENvbG9yOmwsZm9udEJnQ29sb3I6cyxib2xkOmYsaXRhbGljOnYsbGluZVRocm91Z2g6ZCx1bmRlcmxpbmU6cCxmb250U2l6ZTp5fT1yLFA9bi5nZXQodC5uYW1lKTtsZXQgeD10O2lmKHQudGFnTmFtZT09PSJHUk9VUCImJih4PXQuY2hpbGRyZW5bMF0pLGkmJih4LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLGkpLChtPVA9PW51bGw/dm9pZCAwOlAub3B0KSE9bnVsbCYmbS5zdHJva2VDb2xvciYmKFAub3B0LnN0cm9rZUNvbG9yPWkpKSxhJiYoYT09PSJ0cmFuc3BhcmVudCI/eC5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsInJnYmEoMCwwLDAsMCkiKTp4LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixhKSwoTz1QPT1udWxsP3ZvaWQgMDpQLm9wdCkhPW51bGwmJk8uZmlsbENvbG9yJiYoUC5vcHQuZmlsbENvbG9yPWEpKSxQIT1udWxsJiZQLm9wdC50ZXh0T3B0KXtjb25zdCBvPVAub3B0LnRleHRPcHQ7bCYmby5mb250Q29sb3ImJihvLmZvbnRDb2xvcj1sKSxzJiZvLmZvbnRCZ0NvbG9yJiYoby5mb250QmdDb2xvcj1zKSxmJiYoby5ib2xkPWYpLHYmJihvLml0YWxpYz12KSxsZShkKSYmKG8ubGluZVRocm91Z2g9ZCksbGUocCkmJihvLnVuZGVybGluZT1wKSx5JiYoby5mb250U2l6ZT15KX1yZXR1cm4gUCYmbi5zZXRJbmZvKHQubmFtZSxQKSxwdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBLbiBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuU3Rhcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jVW5pdFRpbWU9NTB9Y29uc3VtZShlKXt2YXIgeTtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzU3ViV29ya2VyOm59PWUsaT0oeT10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOnkudG9TdHJpbmcoKTtpZighaSlyZXR1cm57dHlwZTphdC5Ob25lfTtjb25zdHtvcDphLHdvcmtTdGF0ZTpsfT10LHM9YT09bnVsbD92b2lkIDA6YS5sZW5ndGg7aWYoIXN8fHM8MilyZXR1cm57dHlwZTphdC5Ob25lfTtsZXQgZjtpZihsPT09UnQuU3RhcnQ/KHRoaXMudG1wUG9pbnRzPVtuZXcgeHQoYVswXSxhWzFdKV0sZj0hMSk6Zj10aGlzLnVwZGF0ZVRlbXBQb2ludHMoYSksIWYpcmV0dXJue3R5cGU6YXQuTm9uZX07aWYoIW4pe2NvbnN0IFA9RGF0ZS5ub3coKTtyZXR1cm4gUC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWU/KHRoaXMuc3luY1RpbWVzdGFtcD1QLHt0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppLG9wOnRoaXMudG1wUG9pbnRzLm1hcCh4PT5bLi4ueC5YWSwwXSkuZmxhdCgxKSxpc1N5bmM6ITAsaW5kZXg6MH0pOnt0eXBlOmF0Lk5vbmV9fWNvbnN0IHY9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsZD10aGlzLmRyYXcoe3dvcmtJZDppLGxheWVyOnYsaXNEcmF3aW5nOiEwfSkscD1idChkLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1kLHtyZWN0OnAsdHlwZTphdC5EcmF3V29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6aX19Y29uc3VtZUFsbChlKXt2YXIgcztjb25zdHtkYXRhOnR9PWUscj0ocz10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOnMudG9TdHJpbmcoKTtpZighcilyZXR1cm57dHlwZTphdC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTphdC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbcl19O2NvbnN0IG49dGhpcy5mdWxsTGF5ZXIsaT10aGlzLmRyYXcoe3dvcmtJZDpyLGxheWVyOm4saXNEcmF3aW5nOiExfSk7dGhpcy5vbGRSZWN0PWk7Y29uc3QgYT10aGlzLnRtcFBvaW50cy5tYXAoZj0+Wy4uLmYuWFksMF0pLmZsYXQoMSksbD1xdChhKTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyhyLHtyZWN0Omksb3A6YSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6aSYmcHQuZ2V0Q2VudGVyUG9zKGksbil9KSx7cmVjdDppLHR5cGU6YXQuRnVsbFdvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOnIsb3BzOmwsaXNTeW5jOiEwfX1kcmF3KGUpe3ZhciBFO2NvbnN0e3dvcmtJZDp0LGxheWVyOnIsaXNEcmF3aW5nOm59PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKEE9PkEucmVtb3ZlKCkpLChFPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8RS5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoQT0+QS5yZW1vdmUoKSk7Y29uc3R7c3Ryb2tlQ29sb3I6aSxmaWxsQ29sb3I6YSx0aGlja25lc3M6bCx6SW5kZXg6cyx2ZXJ0aWNlczpmLGlubmVyVmVydGljZVN0ZXA6dixpbm5lclJhdGlvOmQsc2NhbGU6cCxyb3RhdGU6eSx0cmFuc2xhdGU6UH09dGhpcy53b3JrT3B0aW9ucyx4PXIud29ybGRQb3NpdGlvbixtPXIud29ybGRTY2FsaW5nLHtyZWN0Ok8scG9zOm8scG9pbnRzOmh9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhsLGYsdixkKSxjPXtwb3M6byxjbG9zZTohMCxuYW1lOnQsaWQ6dCxwb2ludHM6aCxsaW5lV2lkdGg6bCxmaWxsQ29sb3I6YSE9PSJ0cmFuc3BhcmVudCImJmF8fHZvaWQgMCxzdHJva2VDb2xvcjppLGNsYXNzTmFtZTpgJHtvWzBdfSwke29bMV19YCxub3JtYWxpemU6ITAsekluZGV4OnMsbGluZUpvaW46InJvdW5kIn0sZz17eDpNYXRoLmZsb29yKE8ueCptWzBdK3hbMF0tcHQuU2FmZUJvcmRlclBhZGRpbmcqbVswXSkseTpNYXRoLmZsb29yKE8ueSptWzFdK3hbMV0tcHQuU2FmZUJvcmRlclBhZGRpbmcqbVsxXSksdzpNYXRoLmZsb29yKE8udyptWzBdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcqbVswXSksaDpNYXRoLmZsb29yKE8uaCptWzFdKzIqcHQuU2FmZUJvcmRlclBhZGRpbmcqbVsxXSl9O2lmKG4pe2NvbnN0e25hbWU6QSxpZDpMLHpJbmRleDpNLHN0cm9rZUNvbG9yOkl9PWMsRD1bKGcueCtnLncvMi14WzBdKS9tWzBdLChnLnkrZy5oLzIteFsxXSkvbVsxXV0sUj1uZXcgdGUoe25hbWU6QSxpZDpMLHpJbmRleDpNLHBvczpELGFuY2hvcjpbLjUsLjVdLHNpemU6W2cudyxnLmhdfSksQz1uZXcgZWUoey4uLmMscG9zOlswLDBdfSksQj1uZXcgYWUoe2Q6Ik0tNCwwSDRNMCwtNFY0Iixub3JtYWxpemU6ITAscG9zOlswLDBdLHN0cm9rZUNvbG9yOkksbGluZVdpZHRoOjEsc2NhbGU6WzEvbVswXSwxL21bMV1dfSk7cmV0dXJuIFIuYXBwZW5kKEMsQiksci5hcHBlbmQoUiksZ31wJiYoYy5zY2FsZT1wKSx5JiYoYy5yb3RhdGU9eSksUCYmKGMudHJhbnNsYXRlPVApO2NvbnN0IGI9bmV3IGVlKGMpO2lmKHIuYXBwZW5kKGIpLHB8fHl8fFApe2NvbnN0IEE9Yi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKEEueC1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEEueS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEEud2lkdGgrcHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKEEuaGVpZ2h0K3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gZ31jb21wdXREcmF3UG9pbnRzKGUsdCxyLG4pe2NvbnN0IGk9TnQodGhpcy50bXBQb2ludHMpLGE9W01hdGguZmxvb3IoaS54K2kudy8yKSxNYXRoLmZsb29yKGkueStpLmgvMildLGw9T24oaS53LGkuaCkscz1NYXRoLmZsb29yKE1hdGgubWluKGkudyxpLmgpLzIpLGY9bipzLHY9W10sZD0yKk1hdGguUEkvdDtmb3IobGV0IHk9MDt5PHQ7eSsrKXtjb25zdCBQPXkqZC0uNSpNYXRoLlBJO2xldCB4LG07eSVyPT09MT8oeD1mKmxbMF0qTWF0aC5jb3MoUCksbT1mKmxbMV0qTWF0aC5zaW4oUCkpOih4PXMqbFswXSpNYXRoLmNvcyhQKSxtPXMqbFsxXSpNYXRoLnNpbihQKSx2LnB1c2goeCxtKSksdi5wdXNoKHgsbSl9cmV0dXJue3JlY3Q6TnQodGhpcy50bXBQb2ludHMsZSkscG9zOmEscG9pbnRzOnZ9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD1lLnNsaWNlKC0yKSxyPW5ldyB4dCh0WzBdLHRbMV0pLG49dGhpcy50bXBQb2ludHNbMF0se3RoaWNrbmVzczppfT10aGlzLndvcmtPcHRpb25zO2lmKG4uaXNOZWFyKHIsaSl8fHh0LlN1YihuLHIpLlhZLmluY2x1ZGVzKDApKXJldHVybiExO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTIpe2lmKHIuaXNOZWFyKHRoaXMudG1wUG9pbnRzWzFdLDEpKXJldHVybiExO3RoaXMudG1wUG9pbnRzWzFdPXJ9ZWxzZSB0aGlzLnRtcFBvaW50cy5wdXNoKHIpO3JldHVybiEwfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciBsO2NvbnN0e29wOnQsaXNGdWxsV29yazpyfT1lLG49KGw9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpsLnRvU3RyaW5nKCk7aWYoIW4pcmV0dXJuO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cys9Myl0aGlzLnRtcFBvaW50cy5wdXNoKG5ldyB4dCh0W3NdLHRbcysxXSx0W3MrMl0pKTtjb25zdCBpPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGE9dGhpcy5kcmF3KHt3b3JrSWQ6bixsYXllcjppLGlzRHJhd2luZzohMX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9YSx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6YSxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczphJiZwdC5nZXRDZW50ZXJQb3MoYSxpKX0pLGF9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXtjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOmksZmlsbENvbG9yOmEsdG9vbHNUeXBlOmwsdmVydGljZXM6cyxpbm5lclZlcnRpY2VTdGVwOmYsaW5uZXJSYXRpbzp2fT1yLGQ9bi5nZXQodC5uYW1lKSxwPWQ9PW51bGw/dm9pZCAwOmQub3B0O2xldCB5PXQ7cmV0dXJuIHQudGFnTmFtZT09PSJHUk9VUCImJih5PXQuY2hpbGRyZW5bMF0pLGkmJih5LnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLGkpLHAhPW51bGwmJnAuc3Ryb2tlQ29sb3ImJihwLnN0cm9rZUNvbG9yPWkpKSxhJiYoYT09PSJ0cmFuc3BhcmVudCI/eS5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsInJnYmEoMCwwLDAsMCkiKTp5LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixhKSxwIT1udWxsJiZwLmZpbGxDb2xvciYmKHAuZmlsbENvbG9yPWEpKSxsPT09ZHQuU3RhciYmKHMmJihwLnZlcnRpY2VzPXMpLGYmJihwLmlubmVyVmVydGljZVN0ZXA9ZiksdiYmKHAuaW5uZXJSYXRpbz12KSksZCYmbi5zZXRJbmZvKHQubmFtZSx7Li4uZCxvcHQ6cH0pLHB0LnVwZGF0ZU5vZGVPcHQoZSl9fWNsYXNzIFZuIGV4dGVuZHMgcHR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhblJvdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjYWxlVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmp0LmFsbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpkdC5Qb2x5Z29ufSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciB5O2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxpPSh5PXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6eS50b1N0cmluZygpO2lmKCFpKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0e29wOmEsd29ya1N0YXRlOmx9PXQscz1hPT1udWxsP3ZvaWQgMDphLmxlbmd0aDtpZighc3x8czwyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2xldCBmO2lmKGw9PT1SdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyB4dChhWzBdLGFbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhhKSwhZilyZXR1cm57dHlwZTphdC5Ob25lfTtpZighbil7Y29uc3QgUD1EYXRlLm5vdygpO3JldHVybiBQLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVAse3R5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmksb3A6dGhpcy50bXBQb2ludHMubWFwKHg9PlsuLi54LlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6YXQuTm9uZX19Y29uc3Qgdj1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixkPXRoaXMuZHJhdyh7d29ya0lkOmksbGF5ZXI6dixpc0RyYXdpbmc6ITB9KSxwPWJ0KGQsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWQse3JlY3Q6cCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppfX1jb25zdW1lQWxsKGUpe3ZhciBzO2NvbnN0e2RhdGE6dH09ZSxyPShzPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixpPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bixpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9aTtjb25zdCBhPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxsPXF0KGEpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6aSxvcDphLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxuKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6bCxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGc7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cixpc0RyYXdpbmc6bn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoYj0+Yi5yZW1vdmUoKSksKGc9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxnLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChiPT5iLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjppLGZpbGxDb2xvcjphLHRoaWNrbmVzczpsLHpJbmRleDpzLHZlcnRpY2VzOmYsc2NhbGU6dixyb3RhdGU6ZCx0cmFuc2xhdGU6cH09dGhpcy53b3JrT3B0aW9ucyx5PXIud29ybGRQb3NpdGlvbixQPXIud29ybGRTY2FsaW5nLHtyZWN0OngscG9zOm0scG9pbnRzOk99PXRoaXMuY29tcHV0RHJhd1BvaW50cyhsLGYpLG89e3BvczptLGNsb3NlOiEwLG5hbWU6dCxpZDp0LHBvaW50czpPLGxpbmVXaWR0aDpsLGZpbGxDb2xvcjphIT09InRyYW5zcGFyZW50IiYmYXx8dm9pZCAwLHN0cm9rZUNvbG9yOmksbm9ybWFsaXplOiEwLHpJbmRleDpzLGxpbmVKb2luOiJyb3VuZCJ9LGg9e3g6TWF0aC5mbG9vcih4LngqUFswXSt5WzBdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKlBbMF0pLHk6TWF0aC5mbG9vcih4LnkqUFsxXSt5WzFdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKlBbMV0pLHc6TWF0aC5mbG9vcih4LncqUFswXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKlBbMF0pLGg6TWF0aC5mbG9vcih4LmgqUFsxXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKlBbMV0pfTtpZihuKXtjb25zdHtuYW1lOmIsaWQ6RSx6SW5kZXg6QSxzdHJva2VDb2xvcjpMfT1vLE09WyhoLngraC53LzIteVswXSkvUFswXSwoaC55K2guaC8yLXlbMV0pL1BbMV1dLEk9bmV3IHRlKHtuYW1lOmIsaWQ6RSx6SW5kZXg6QSxwb3M6TSxhbmNob3I6Wy41LC41XSxzaXplOltoLncsaC5oXX0pLEQ9bmV3IGVlKHsuLi5vLHBvczpbMCwwXX0pLFI9bmV3IGFlKHtkOiJNLTQsMEg0TTAsLTRWNCIsbm9ybWFsaXplOiEwLHBvczpbMCwwXSxzdHJva2VDb2xvcjpMLGxpbmVXaWR0aDoxLHNjYWxlOlsxL1BbMF0sMS9QWzFdXX0pO3JldHVybiBJLmFwcGVuZChELFIpLHIuYXBwZW5kKEkpLGh9diYmKG8uc2NhbGU9diksZCYmKG8ucm90YXRlPWQpLHAmJihvLnRyYW5zbGF0ZT1wKTtjb25zdCBjPW5ldyBlZShvKTtpZihyLmFwcGVuZChjKSx2fHxkfHxwKXtjb25zdCBiPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihiLngtcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihiLnktcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihiLndpZHRoK3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihiLmhlaWdodCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19cmV0dXJuIGh9Y29tcHV0RHJhd1BvaW50cyhlLHQpe2NvbnN0IHI9TnQodGhpcy50bXBQb2ludHMpLG49W01hdGguZmxvb3Ioci54K3Iudy8yKSxNYXRoLmZsb29yKHIueStyLmgvMildLGk9T24oci53LHIuaCksYT1NYXRoLmZsb29yKE1hdGgubWluKHIudyxyLmgpLzIpLGw9W10scz0yKk1hdGguUEkvdDtmb3IobGV0IHY9MDt2PHQ7disrKXtjb25zdCBkPXYqcy0uNSpNYXRoLlBJLHA9YSppWzBdKk1hdGguY29zKGQpLHk9YSppWzFdKk1hdGguc2luKGQpO2wucHVzaChwLHkpfXJldHVybntyZWN0Ok50KHRoaXMudG1wUG9pbnRzLGUpLHBvczpuLHBvaW50czpsfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9ZS5zbGljZSgtMikscj1uZXcgeHQodFswXSx0WzFdKSxuPXRoaXMudG1wUG9pbnRzWzBdLHt0aGlja25lc3M6aX09dGhpcy53b3JrT3B0aW9ucztpZihuLmlzTmVhcihyLGkpfHx4dC5TdWIobixyKS5YWS5pbmNsdWRlcygwKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgbDtjb25zdHtvcDp0LGlzRnVsbFdvcms6cn09ZSxuPShsPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6bC50b1N0cmluZygpO2lmKCFuKXJldHVybjt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrPTMpdGhpcy50bXBQb2ludHMucHVzaChuZXcgeHQodFtzXSx0W3MrMV0sdFtzKzJdKSk7Y29uc3QgaT1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixhPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6aSxpc0RyYXdpbmc6ITF9KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWEsdGhpcy52Tm9kZXMuc2V0SW5mbyhuLHtyZWN0OmEsb3A6dCxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6YSYmcHQuZ2V0Q2VudGVyUG9zKGEsaSl9KSxhfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIHVwZGF0ZU5vZGVPcHQoZSl7Y29uc3R7bm9kZTp0LG9wdDpyLHZOb2RlczpufT1lLHtzdHJva2VDb2xvcjppLGZpbGxDb2xvcjphLHRvb2xzVHlwZTpsLHZlcnRpY2VzOnN9PXIsZj1uLmdldCh0Lm5hbWUpLHY9Zj09bnVsbD92b2lkIDA6Zi5vcHQ7bGV0IGQ9dDtyZXR1cm4gdC50YWdOYW1lPT09IkdST1VQIiYmKGQ9dC5jaGlsZHJlblswXSksaSYmKGQuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsaSksdiE9bnVsbCYmdi5zdHJva2VDb2xvciYmKHYuc3Ryb2tlQ29sb3I9aSkpLGEmJihhPT09InRyYW5zcGFyZW50Ij9kLnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIiwicmdiYSgwLDAsMCwwKSIpOmQuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLGEpLHYhPW51bGwmJnYuZmlsbENvbG9yJiYodi5maWxsQ29sb3I9YSkpLGw9PT1kdC5Qb2x5Z29uJiZzJiYodi52ZXJ0aWNlcz1zKSxmJiZuLnNldEluZm8odC5uYW1lLHsuLi5mLG9wdDp2fSkscHQudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgUXR7c3RhdGljIGJlemllcihlLHQpe2NvbnN0IHI9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKz00KXtjb25zdCBpPXRbbl0sYT10W24rMV0sbD10W24rMl0scz10W24rM107aSYmYSYmbCYmcz9yLnB1c2goLi4uUXQuZ2V0QmV6aWVyUG9pbnRzKGUsaSxhLGwscykpOmkmJmEmJmw/ci5wdXNoKC4uLlF0LmdldEJlemllclBvaW50cyhlLGksYSxsKSk6aSYmYT9yLnB1c2goLi4uUXQuZ2V0QmV6aWVyUG9pbnRzKGUsaSxhKSk6aSYmci5wdXNoKGkpfXJldHVybiByfXN0YXRpYyBnZXRCZXppZXJQb2ludHMoZT0xMCx0LHIsbixpKXtsZXQgYT1udWxsO2NvbnN0IGw9W107IW4mJiFpP2E9UXQub25lQmV6aWVyOm4mJiFpP2E9UXQudHdvQmV6aWVyOm4mJmkmJihhPVF0LnRocmVlQmV6aWVyKTtmb3IobGV0IHM9MDtzPGU7cysrKWEmJmwucHVzaChhKHMvZSx0LHIsbixpKSk7cmV0dXJuIGk/bC5wdXNoKGkpOm4mJmwucHVzaChuKSxsfXN0YXRpYyBvbmVCZXppZXIoZSx0LHIpe2NvbnN0IG49dC54KyhyLngtdC54KSplLGk9dC55KyhyLnktdC55KSplO3JldHVybiBuZXcgZXQobixpKX1zdGF0aWMgdHdvQmV6aWVyKGUsdCxyLG4pe2NvbnN0IGk9KDEtZSkqKDEtZSkqdC54KzIqZSooMS1lKSpyLngrZSplKm4ueCxhPSgxLWUpKigxLWUpKnQueSsyKmUqKDEtZSkqci55K2UqZSpuLnk7cmV0dXJuIG5ldyBldChpLGEpfXN0YXRpYyB0aHJlZUJlemllcihlLHQscixuLGkpe2NvbnN0IGE9dC54KigxLWUpKigxLWUpKigxLWUpKzMqci54KmUqKDEtZSkqKDEtZSkrMypuLngqZSplKigxLWUpK2kueCplKmUqZSxsPXQueSooMS1lKSooMS1lKSooMS1lKSszKnIueSplKigxLWUpKigxLWUpKzMqbi55KmUqZSooMS1lKStpLnkqZSplKmU7cmV0dXJuIG5ldyBldChhLGwpfX1jbGFzcyBZbiBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuU3BlZWNoQmFsbG9vbn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJyYXRpbyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOi44fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZS50b29sc09wdCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNVbml0VGltZT01MH1jb25zdW1lKGUpe3ZhciB5O2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNTdWJXb3JrZXI6bn09ZSxpPSh5PXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6eS50b1N0cmluZygpO2lmKCFpKXJldHVybnt0eXBlOmF0Lk5vbmV9O2NvbnN0e29wOmEsd29ya1N0YXRlOmx9PXQscz1hPT1udWxsP3ZvaWQgMDphLmxlbmd0aDtpZighc3x8czwyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2xldCBmO2lmKGw9PT1SdC5TdGFydD8odGhpcy50bXBQb2ludHM9W25ldyB4dChhWzBdLGFbMV0pXSxmPSExKTpmPXRoaXMudXBkYXRlVGVtcFBvaW50cyhhKSwhZilyZXR1cm57dHlwZTphdC5Ob25lfTtpZighbil7Y29uc3QgUD1EYXRlLm5vdygpO3JldHVybiBQLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZT8odGhpcy5zeW5jVGltZXN0YW1wPVAse3R5cGU6YXQuRHJhd1dvcmssZGF0YVR5cGU6T3QuTG9jYWwsd29ya0lkOmksb3A6dGhpcy50bXBQb2ludHMubWFwKHg9PlsuLi54LlhZLDBdKS5mbGF0KDEpLGlzU3luYzohMCxpbmRleDowfSk6e3R5cGU6YXQuTm9uZX19Y29uc3Qgdj1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixkPXRoaXMuZHJhdyh7d29ya0lkOmksbGF5ZXI6dixpc0RyYXdpbmc6ITB9KSxwPWJ0KGQsdGhpcy5vbGRSZWN0KTtyZXR1cm4gdGhpcy5vbGRSZWN0PWQse3JlY3Q6cCx0eXBlOmF0LkRyYXdXb3JrLGRhdGFUeXBlOk90LkxvY2FsLHdvcmtJZDppfX1jb25zdW1lQWxsKGUpe3ZhciBzO2NvbnN0e2RhdGE6dH09ZSxyPShzPXQ9PW51bGw/dm9pZCAwOnQud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCFyKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aDwyKXJldHVybnt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOltyXX07Y29uc3Qgbj10aGlzLmZ1bGxMYXllcixpPXRoaXMuZHJhdyh7d29ya0lkOnIsbGF5ZXI6bixpc0RyYXdpbmc6ITF9KTt0aGlzLm9sZFJlY3Q9aTtjb25zdCBhPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxsPXF0KGEpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6aSxvcDphLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxuKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6bCxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIGM7Y29uc3R7d29ya0lkOnQsbGF5ZXI6cn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoZz0+Zy5yZW1vdmUoKSksKGM9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxjLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChnPT5nLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjpuLGZpbGxDb2xvcjppLHRoaWNrbmVzczphLHpJbmRleDpsLHBsYWNlbWVudDpzLHNjYWxlOmYscm90YXRlOnYsdHJhbnNsYXRlOmR9PXRoaXMud29ya09wdGlvbnMscD1yLndvcmxkUG9zaXRpb24seT1yLndvcmxkU2NhbGluZyx7cmVjdDpQLHBvczp4LHBvaW50czptfT10aGlzLmNvbXB1dERyYXdQb2ludHMoYSxzKSxPPXtwb3M6eCxuYW1lOnQsaWQ6dCxwb2ludHM6bS5tYXAoZz0+Zy5YWSksbGluZVdpZHRoOmEsZmlsbENvbG9yOmkhPT0idHJhbnNwYXJlbnQiJiZpfHx2b2lkIDAsc3Ryb2tlQ29sb3I6bixub3JtYWxpemU6ITAsY2xhc3NOYW1lOmAke3hbMF19LCR7eFsxXX1gLHpJbmRleDpsLGxpbmVKb2luOiJyb3VuZCIsY2xvc2U6ITB9LG89e3g6TWF0aC5mbG9vcihQLngqeVswXStwWzBdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKnlbMF0pLHk6TWF0aC5mbG9vcihQLnkqeVsxXStwWzFdLXB0LlNhZmVCb3JkZXJQYWRkaW5nKnlbMV0pLHc6TWF0aC5mbG9vcihQLncqeVswXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKnlbMF0pLGg6TWF0aC5mbG9vcihQLmgqeVsxXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKnlbMV0pfTtmJiYoTy5zY2FsZT1mKSx2JiYoTy5yb3RhdGU9diksZCYmKE8udHJhbnNsYXRlPWQpO2NvbnN0IGg9bmV3IGVlKE8pO2lmKHIuYXBwZW5kKGgpLGZ8fHZ8fGQpe2NvbnN0IGc9aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57eDpNYXRoLmZsb29yKGcueC1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKGcueS1wdC5TYWZlQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKGcud2lkdGgrcHQuU2FmZUJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKGcuaGVpZ2h0K3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpfX1yZXR1cm4gb310cmFuc2Zvcm1Db250cm9sUG9pbnRzKGUpe2NvbnN0IHQ9TnQodGhpcy50bXBQb2ludHMpO3N3aXRjaChlKXtjYXNlImJvdHRvbSI6Y2FzZSJib3R0b21MZWZ0IjpjYXNlImJvdHRvbVJpZ2h0Ijp7Y29uc3Qgcj10LnkrdC5oKnRoaXMucmF0aW87cmV0dXJuW25ldyBldCh0LngsdC55LDApLG5ldyBldCh0LngrdC53LHQueSwwKSxuZXcgZXQodC54K3QudyxyLDApLG5ldyBldCh0LngsciwwKV19Y2FzZSJ0b3AiOmNhc2UidG9wTGVmdCI6Y2FzZSJ0b3BSaWdodCI6e2NvbnN0IHI9dC55K3QuaCooMS10aGlzLnJhdGlvKTtyZXR1cm5bbmV3IGV0KHQueCxyLDApLG5ldyBldCh0LngrdC53LHIsMCksbmV3IGV0KHQueCt0LncsdC55K3QuaCwwKSxuZXcgZXQodC54LHQueSt0LmgsMCldfWNhc2UibGVmdCI6Y2FzZSJsZWZ0Qm90dG9tIjpjYXNlImxlZnRUb3AiOntjb25zdCByPXQueCt0LncqKDEtdGhpcy5yYXRpbyk7cmV0dXJuW25ldyBldChyLHQueSwwKSxuZXcgZXQodC54K3Qudyx0LnksMCksbmV3IGV0KHQueCt0LncsdC55K3QuaCwwKSxuZXcgZXQocix0LnkrdC5oLDApXX1jYXNlInJpZ2h0IjpjYXNlInJpZ2h0Qm90dG9tIjpjYXNlInJpZ2h0VG9wIjp7Y29uc3Qgcj10LngrdC53KnRoaXMucmF0aW87cmV0dXJuW25ldyBldCh0LngsdC55LDApLG5ldyBldChyLHQueSwwKSxuZXcgZXQocix0LnkrdC5oLDApLG5ldyBldCh0LngsdC55K3QuaCwwKV19fX1jb21wdXREcmF3UG9pbnRzKGUsdCl7Y29uc3Qgcj1OdCh0aGlzLnRtcFBvaW50cyksbj10aGlzLnRyYW5zZm9ybUNvbnRyb2xQb2ludHModCksaT1NYXRoLmZsb29yKHIudyouMSksYT1NYXRoLmZsb29yKHIuaCouMSksbD1bXSxzPWV0LkFkZChuWzBdLG5ldyBldCgwLGEsMCkpLGY9ZXQuQWRkKG5bMF0sbmV3IGV0KGksMCwwKSksdj1RdC5nZXRCZXppZXJQb2ludHMoMTAscyxuWzBdLGYpLGQ9ZXQuU3ViKG5bMV0sbmV3IGV0KGksMCwwKSkscD1ldC5BZGQoblsxXSxuZXcgZXQoMCxhLDApKSx5PVF0LmdldEJlemllclBvaW50cygxMCxkLG5bMV0scCksUD1ldC5TdWIoblsyXSxuZXcgZXQoMCxhLDApKSx4PWV0LlN1YihuWzJdLG5ldyBldChpLDAsMCkpLG09UXQuZ2V0QmV6aWVyUG9pbnRzKDEwLFAsblsyXSx4KSxPPWV0LkFkZChuWzNdLG5ldyBldChpLDAsMCkpLG89ZXQuU3ViKG5bM10sbmV3IGV0KDAsYSwwKSksaD1RdC5nZXRCZXppZXJQb2ludHMoMTAsTyxuWzNdLG8pLGM9aSooMS10aGlzLnJhdGlvKSoxMCxnPWEqKDEtdGhpcy5yYXRpbykqMTA7c3dpdGNoKHQpe2Nhc2UiYm90dG9tIjp7Y29uc3QgQT1ldC5TdWIoblsyXSxuZXcgZXQoaSo1LWMvMiwwLDApKSxMPWV0LlN1YihuWzJdLG5ldyBldChpKjUsLWcsMCkpLE09ZXQuU3ViKG5bMl0sbmV3IGV0KGkqNStjLzIsMCwwKSk7bC5wdXNoKEwsTSwuLi5oLC4uLnYsLi4ueSwuLi5tLEEpO2JyZWFrfWNhc2UiYm90dG9tUmlnaHQiOntjb25zdCBBPWV0LlN1YihuWzJdLG5ldyBldChpKjEuMSwwLDApKSxMPWV0LlN1YihuWzJdLG5ldyBldChpKjEuMStjLzIsLWcsMCkpLE09ZXQuU3ViKG5bMl0sbmV3IGV0KGkqMS4xK2MsMCwwKSk7bC5wdXNoKEwsTSwuLi5oLC4uLnYsLi4ueSwuLi5tLEEpO2JyZWFrfWNhc2UiYm90dG9tTGVmdCI6e2NvbnN0IEE9ZXQuQWRkKG5bM10sbmV3IGV0KGkqMS4xK2MsMCwwKSksTD1ldC5BZGQoblszXSxuZXcgZXQoaSoxLjErYy8yLGcsMCkpLE09ZXQuQWRkKG5bM10sbmV3IGV0KGkqMS4xLDAsMCkpO2wucHVzaChMLE0sLi4uaCwuLi52LC4uLnksLi4ubSxBKTticmVha31jYXNlInRvcCI6e2NvbnN0IEE9ZXQuU3ViKG5bMV0sbmV3IGV0KGkqNS1jLzIsMCwwKSksTD1ldC5TdWIoblsxXSxuZXcgZXQoaSo1LGcsMCkpLE09ZXQuU3ViKG5bMV0sbmV3IGV0KGkqNStjLzIsMCwwKSk7bC5wdXNoKEwsQSwuLi55LC4uLm0sLi4uaCwuLi52LE0pO2JyZWFrfWNhc2UidG9wUmlnaHQiOntjb25zdCBBPWV0LlN1YihuWzFdLG5ldyBldChpKjEuMSwwLDApKSxMPWV0LlN1YihuWzFdLG5ldyBldChpKjEuMStjLzIsZywwKSksTT1ldC5TdWIoblsxXSxuZXcgZXQoaSoxLjErYywwLDApKTtsLnB1c2goTCxBLC4uLnksLi4ubSwuLi5oLC4uLnYsTSk7YnJlYWt9Y2FzZSJ0b3BMZWZ0Ijp7Y29uc3QgQT1ldC5BZGQoblswXSxuZXcgZXQoaSoxLjErYywwLDApKSxMPWV0LkFkZChuWzBdLG5ldyBldChpKjEuMStjLzIsLWcsMCkpLE09ZXQuQWRkKG5bMF0sbmV3IGV0KGkqMS4xLDAsMCkpO2wucHVzaChMLEEsLi4ueSwuLi5tLC4uLmgsLi4udixNKTticmVha31jYXNlImxlZnQiOntjb25zdCBBPWV0LkFkZChuWzBdLG5ldyBldCgwLGEqNS1nLzIsMCkpLEw9ZXQuQWRkKG5bMF0sbmV3IGV0KC1jLGEqNSwwKSksTT1ldC5BZGQoblswXSxuZXcgZXQoMCxhKjUrZy8yLDApKTtsLnB1c2goTCxBLC4uLnYsLi4ueSwuLi5tLC4uLmgsTSk7YnJlYWt9Y2FzZSJsZWZ0VG9wIjp7Y29uc3QgQT1ldC5BZGQoblswXSxuZXcgZXQoMCxhKjEuMSwwKSksTD1ldC5BZGQoblswXSxuZXcgZXQoLWMsYSoxLjErZy8yLDApKSxNPWV0LkFkZChuWzBdLG5ldyBldCgwLGEqMS4xK2csMCkpO2wucHVzaChMLEEsLi4udiwuLi55LC4uLm0sLi4uaCxNKTticmVha31jYXNlImxlZnRCb3R0b20iOntjb25zdCBBPWV0LlN1YihuWzNdLG5ldyBldCgwLGEqMS4xK2csMCkpLEw9ZXQuU3ViKG5bM10sbmV3IGV0KGMsYSoxLjErZy8yLDApKSxNPWV0LlN1YihuWzNdLG5ldyBldCgwLGEqMS4xLDApKTtsLnB1c2goTCxBLC4uLnYsLi4ueSwuLi5tLC4uLmgsTSk7YnJlYWt9Y2FzZSJyaWdodCI6e2NvbnN0IEE9ZXQuQWRkKG5bMV0sbmV3IGV0KDAsYSo1LWcvMiwwKSksTD1ldC5BZGQoblsxXSxuZXcgZXQoYyxhKjUsMCkpLE09ZXQuQWRkKG5bMV0sbmV3IGV0KDAsYSo1K2cvMiwwKSk7bC5wdXNoKEwsTSwuLi5tLC4uLmgsLi4udiwuLi55LEEpO2JyZWFrfWNhc2UicmlnaHRUb3AiOntjb25zdCBBPWV0LkFkZChuWzFdLG5ldyBldCgwLGEqMS4xLDApKSxMPWV0LkFkZChuWzFdLG5ldyBldChjLGEqMS4xK2cvMiwwKSksTT1ldC5BZGQoblsxXSxuZXcgZXQoMCxhKjEuMStnLDApKTtsLnB1c2goTCxNLC4uLm0sLi4uaCwuLi52LC4uLnksQSk7YnJlYWt9Y2FzZSJyaWdodEJvdHRvbSI6e2NvbnN0IEE9ZXQuU3ViKG5bMl0sbmV3IGV0KDAsYSoxLjErZywwKSksTD1ldC5TdWIoblsyXSxuZXcgZXQoLWMsYSoxLjErZy8yLDApKSxNPWV0LlN1YihuWzJdLG5ldyBldCgwLGEqMS4xLDApKTtsLnB1c2goTCxNLC4uLm0sLi4uaCwuLi52LC4uLnksQSk7YnJlYWt9fWNvbnN0IGI9TnQodGhpcy50bXBQb2ludHMsZSksRT1bTWF0aC5mbG9vcihiLngrYi53LzIpLE1hdGguZmxvb3IoYi55K2IuaC8yKV07cmV0dXJue3JlY3Q6Yixwb3M6RSxwb2ludHM6bH19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IHh0KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOml9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixpKXx8eHQuU3ViKG4scikuWFkuaW5jbHVkZXMoMCkpcmV0dXJuITE7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoPT09Mil7aWYoci5pc05lYXIodGhpcy50bXBQb2ludHNbMV0sMSkpcmV0dXJuITE7dGhpcy50bXBQb2ludHNbMV09cn1lbHNlIHRoaXMudG1wUG9pbnRzLnB1c2gocik7cmV0dXJuITB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIGw7Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOnJ9PWUsbj0obD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmwudG9TdHJpbmcoKTtpZighbilyZXR1cm47dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKz0zKXRoaXMudG1wUG9pbnRzLnB1c2gobmV3IHh0KHRbc10sdFtzKzFdLHRbcysyXSkpO2NvbnN0IGk9cj90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIsYT10aGlzLmRyYXcoe3dvcmtJZDpuLGxheWVyOmksaXNEcmF3aW5nOiExfSk7cmV0dXJuIHRoaXMub2xkUmVjdD1hLHRoaXMudk5vZGVzLnNldEluZm8obix7cmVjdDphLG9wOnQsb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmEmJnB0LmdldENlbnRlclBvcyhhLGkpfSksYX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bn09ZSx7c3Ryb2tlQ29sb3I6aSxmaWxsQ29sb3I6YSx0b29sc1R5cGU6bCxwbGFjZW1lbnQ6c309cixmPW4uZ2V0KHQubmFtZSksdj1mPT1udWxsP3ZvaWQgMDpmLm9wdDtsZXQgZD10O3JldHVybiB0LnRhZ05hbWU9PT0iR1JPVVAiJiYoZD10LmNoaWxkcmVuWzBdKSxpJiYoZC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixpKSx2IT1udWxsJiZ2LnN0cm9rZUNvbG9yJiYodi5zdHJva2VDb2xvcj1pKSksYSYmKGE9PT0idHJhbnNwYXJlbnQiP2Quc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLCJyZ2JhKDAsMCwwLDApIik6ZC5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIsYSksdiE9bnVsbCYmdi5maWxsQ29sb3ImJih2LmZpbGxDb2xvcj1hKSksbD09PWR0LlNwZWVjaEJhbGxvb24mJnMmJih2LnBsYWNlbWVudD1zKSxmJiZuLnNldEluZm8odC5uYW1lLHsuLi5mLG9wdDp2fSkscHQudXBkYXRlTm9kZU9wdChlKX19Y2xhc3MgWG4gZXh0ZW5kcyBwdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FuUm90YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGVUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6anQuYWxsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmR0LkltYWdlfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUudG9vbHNPcHQsdGhpcy5zY2FsZVR5cGU9dGhpcy53b3JrT3B0aW9ucy51bmlmb3JtU2NhbGU/anQucHJvcG9ydGlvbmFsOmp0LmFsbH1jb25zdW1lKCl7cmV0dXJue3R5cGU6YXQuTm9uZX19Y29uc3VtZUFsbCgpe3JldHVybnt0eXBlOmF0Lk5vbmV9fWRyYXcoZSl7dmFyIG87Y29uc3R7bGF5ZXI6dCx3b3JrSWQ6cixyZXBsYWNlSWQ6bixpbWFnZUJpdG1hcDppfT1lLHtjZW50ZXJYOmEsY2VudGVyWTpsLHdpZHRoOnMsaGVpZ2h0OmYsc2NhbGU6dixyb3RhdGU6ZCx0cmFuc2xhdGU6cCx6SW5kZXg6eX09dGhpcy53b3JrT3B0aW9uczt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShufHxyKS5tYXAoaD0+aC5yZW1vdmUoKSksKG89dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxvLmdldEVsZW1lbnRzQnlOYW1lKG58fHIpLm1hcChoPT5oLnJlbW92ZSgpKTtjb25zdCBQPXthbmNob3I6Wy41LC41XSxwb3M6W2EsbF0sbmFtZTpyLHNpemU6W3MsZl0sekluZGV4Onl9O2lmKHYpaWYodGhpcy5zY2FsZVR5cGU9PT1qdC5wcm9wb3J0aW9uYWwpe2NvbnN0IGg9TWF0aC5taW4odlswXSx2WzFdKTtQLnNjYWxlPVtoLGhdfWVsc2UgUC5zY2FsZT12O3AmJihQLnRyYW5zbGF0ZT1wKSxkJiYoUC5yb3RhdGU9ZCk7Y29uc3QgeD1uZXcgdGUoUCksbT1uZXcgVmgoe2FuY2hvcjpbLjUsLjVdLHBvczpbMCwwXSxzaXplOltzLGZdLHRleHR1cmU6aSxyb3RhdGU6MTgwfSk7eC5hcHBlbmQobSksdC5hcHBlbmQoeCk7Y29uc3QgTz14LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKE8pcmV0dXJue3g6TWF0aC5mbG9vcihPLngtcHQuU2FmZUJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcihPLnktcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihPLndpZHRoK3B0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihPLmhlaWdodCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKX19Y29uc3VtZVNlcnZpY2UoKXt9YXN5bmMgY29uc3VtZVNlcnZpY2VBc3luYyhlKXt2YXIgZix2O2NvbnN0e2lzRnVsbFdvcms6dCxyZXBsYWNlSWQ6cixzY2VuZTpufT1lLHtzcmM6aSx1dWlkOmF9PXRoaXMud29ya09wdGlvbnMsbD0oKGY9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpmLnRvU3RyaW5nKCkpfHxhLHM9dD90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXI7aWYoaSl7Y29uc3QgZD1hd2FpdCBuLnByZWxvYWQoe2lkOmEsc3JjOnRoaXMud29ya09wdGlvbnMuc3JjfSkscD10aGlzLmRyYXcoe3dvcmtJZDpsLGxheWVyOnMscmVwbGFjZUlkOnIsaW1hZ2VCaXRtYXA6ZFswXX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9bCYmKCh2PXRoaXMudk5vZGVzLmdldChsKSk9PW51bGw/dm9pZCAwOnYucmVjdCl8fHZvaWQgMCx0aGlzLnZOb2Rlcy5zZXRJbmZvKGwse3JlY3Q6cCxvcDpbXSxvcHQ6dGhpcy53b3JrT3B0aW9ucyx0b29sc1R5cGU6dGhpcy50b29sc1R5cGUsc2NhbGVUeXBlOnRoaXMuc2NhbGVUeXBlLGNhblJvdGF0ZTp0aGlzLmNhblJvdGF0ZSxjZW50ZXJQb3M6cCYmcHQuZ2V0Q2VudGVyUG9zKHAscyl9KSxwfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bix0YXJnZXROb2RlOml9PWUse3RyYW5zbGF0ZTphLGJveDpsLGJveFNjYWxlOnMsYm94VHJhbnNsYXRlOmYsYW5nbGU6dixpc0xvY2tlZDpkLHpJbmRleDpwfT1yLHk9aSYmWXQoaSl8fG4uZ2V0KHQubmFtZSk7aWYoIXkpcmV0dXJuO2NvbnN0IFA9dC5wYXJlbnQ7aWYoUCl7aWYobmUocCkmJih0LnNldEF0dHJpYnV0ZSgiekluZGV4IixwKSx5Lm9wdC56SW5kZXg9cCksbGUoZCkmJih5Lm9wdC5sb2NrZWQ9ZCksbCYmZiYmcyl7Y29uc3R7Y2VudGVyWDp4LGNlbnRlclk6bSx3aWR0aDpPLGhlaWdodDpvLHVuaWZvcm1TY2FsZTpofT15Lm9wdDtpZihoKXtjb25zdCBiPU1hdGgubWluKHNbMF0sc1sxXSk7eS5vcHQuc2NhbGU9W2IsYl19ZWxzZSB5Lm9wdC5zY2FsZT1zO3kub3B0LndpZHRoPU1hdGguZmxvb3IoTypzWzBdKSx5Lm9wdC5oZWlnaHQ9TWF0aC5mbG9vcihvKnNbMV0pO2NvbnN0IGM9W2ZbMF0vUC53b3JsZFNjYWxpbmdbMF0sZlsxXS9QLndvcmxkU2NhbGluZ1sxXV07eS5vcHQuY2VudGVyWD14K2NbMF0seS5vcHQuY2VudGVyWT1tK2NbMV07Y29uc3QgZz1beS5jZW50ZXJQb3NbMF0rY1swXSx5LmNlbnRlclBvc1sxXStjWzFdXTtpZih5LmNlbnRlclBvcz1nLGkpe2xldCBiPXhuKHkucmVjdCxzKTtiPU9lKGIsYykseS5yZWN0PWJ9fWVsc2UgaWYoYSl7Y29uc3QgeD1bYVswXS9QLndvcmxkU2NhbGluZ1swXSxhWzFdL1Aud29ybGRTY2FsaW5nWzFdXTtpZih5Lm9wdC5jZW50ZXJYPXkub3B0LmNlbnRlclgreFswXSx5Lm9wdC5jZW50ZXJZPXkub3B0LmNlbnRlclkreFsxXSx5LmNlbnRlclBvcz1beS5jZW50ZXJQb3NbMF0reFswXSx5LmNlbnRlclBvc1sxXSt4WzFdXSxpKXtjb25zdCBtPU9lKHkucmVjdCx4KTt5LnJlY3Q9bX19ZWxzZSBpZihuZSh2KSYmKHQuc2V0QXR0cmlidXRlKCJyb3RhdGUiLHYpLHkub3B0LnJvdGF0ZT12LGkpKXtjb25zdCB4PVNuKHkucmVjdCx2KTt5LnJlY3Q9eH1yZXR1cm4geSYmbi5zZXRJbmZvKHQubmFtZSx5KSx5PT1udWxsP3ZvaWQgMDp5LnJlY3R9fX1jbGFzcyBabiBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5ib3RofSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmR0LlN0cmFpZ2h0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3RyYWlnaHRUaXBXaWR0aCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0LHRoaXMuc3RyYWlnaHRUaXBXaWR0aD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcy8yLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY1VuaXRUaW1lPTUwfWNvbnN1bWUoZSl7dmFyIHk7Y29uc3R7ZGF0YTp0LGlzRnVsbFdvcms6cixpc1N1YldvcmtlcjpufT1lLGk9KHk9dD09bnVsbD92b2lkIDA6dC53b3JrSWQpPT1udWxsP3ZvaWQgMDp5LnRvU3RyaW5nKCk7aWYoIWkpcmV0dXJue3R5cGU6YXQuTm9uZX07Y29uc3R7b3A6YSx3b3JrU3RhdGU6bH09dCxzPWE9PW51bGw/dm9pZCAwOmEubGVuZ3RoO2lmKCFzfHxzPDIpcmV0dXJue3R5cGU6YXQuTm9uZX07bGV0IGY7aWYobD09PVJ0LlN0YXJ0Pyh0aGlzLnRtcFBvaW50cz1bbmV3IHh0KGFbMF0sYVsxXSldLGY9ITEpOmY9dGhpcy51cGRhdGVUZW1wUG9pbnRzKGEpLCFmKXJldHVybnt0eXBlOmF0Lk5vbmV9O2lmKCFuKXtjb25zdCBQPURhdGUubm93KCk7cmV0dXJuIFAtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lPyh0aGlzLnN5bmNUaW1lc3RhbXA9UCx7dHlwZTphdC5EcmF3V29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6aSxvcDp0aGlzLnRtcFBvaW50cy5tYXAoeD0+Wy4uLnguWFksMF0pLmZsYXQoMSksaXNTeW5jOiEwLGluZGV4OjB9KTp7dHlwZTphdC5Ob25lfX1jb25zdCB2PXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGQ9dGhpcy5kcmF3KHt3b3JrSWQ6aSxsYXllcjp2fSkscD1idChkLHRoaXMub2xkUmVjdCk7cmV0dXJuIHRoaXMub2xkUmVjdD1kLHtyZWN0OnAsdHlwZTphdC5EcmF3V29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6aX19Y29uc3VtZUFsbChlKXt2YXIgcztjb25zdHtkYXRhOnR9PWUscj0ocz10PT1udWxsP3ZvaWQgMDp0LndvcmtJZCk9PW51bGw/dm9pZCAwOnMudG9TdHJpbmcoKTtpZighcilyZXR1cm57dHlwZTphdC5Ob25lfTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg8MilyZXR1cm57dHlwZTphdC5SZW1vdmVOb2RlLHJlbW92ZUlkczpbcl19O2NvbnN0IG49dGhpcy5mdWxsTGF5ZXIsaT10aGlzLmRyYXcoe3dvcmtJZDpyLGxheWVyOm59KTt0aGlzLm9sZFJlY3Q9aTtjb25zdCBhPXRoaXMudG1wUG9pbnRzLm1hcChmPT5bLi4uZi5YWSwwXSkuZmxhdCgxKSxsPXF0KGEpO3JldHVybiB0aGlzLnZOb2Rlcy5zZXRJbmZvKHIse3JlY3Q6aSxvcDphLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczppJiZwdC5nZXRDZW50ZXJQb3MoaSxuKX0pLHtyZWN0OmksdHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5Mb2NhbCx3b3JrSWQ6cixvcHM6bCxpc1N5bmM6ITB9fWRyYXcoZSl7dmFyIG87Y29uc3R7d29ya0lkOnQsbGF5ZXI6cn09ZTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoaD0+aC5yZW1vdmUoKSksKG89dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxvLmdldEVsZW1lbnRzQnlOYW1lKHQpLm1hcChoPT5oLnJlbW92ZSgpKTtjb25zdHtzdHJva2VDb2xvcjpuLHRoaWNrbmVzczppLHpJbmRleDphLHNjYWxlOmwscm90YXRlOnMsdHJhbnNsYXRlOmZ9PXRoaXMud29ya09wdGlvbnMsdj1yLndvcmxkUG9zaXRpb24sZD1yLndvcmxkU2NhbGluZyx7ZDpwLHJlY3Q6eX09dGhpcy5jb21wdXREcmF3UG9pbnRzKGkpLFA9W3kueCt5LncvMix5LnkreS5oLzJdLHg9e3BvczpQLG5hbWU6dCxpZDp0LGQ6cCxmaWxsQ29sb3I6bixzdHJva2VDb2xvcjpuLGxpbmVXaWR0aDowLGNsYXNzTmFtZTpgJHtQWzBdfSwke1BbMV19YCxub3JtYWxpemU6ITAsekluZGV4OmF9O2wmJih4LnNjYWxlPWwpLHMmJih4LnJvdGF0ZT1zKSxmJiYoeC50cmFuc2xhdGU9Zik7Y29uc3QgbT1uZXcgYWUoeCk7aWYoci5hcHBlbmQobSksc3x8bHx8Zil7Y29uc3QgaD1tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Ok1hdGguZmxvb3IoaC54LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoaC55LXB0LlNhZmVCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoaC53aWR0aCtwdC5TYWZlQm9yZGVyUGFkZGluZyoyKSxoOk1hdGguZmxvb3IoaC5oZWlnaHQrcHQuU2FmZUJvcmRlclBhZGRpbmcqMil9fXJldHVybnt4Ok1hdGguZmxvb3IoeS54KmRbMF0rdlswXS1wdC5TYWZlQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKHkueSpkWzFdK3ZbMV0tcHQuU2FmZUJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcih5LncqZFswXSsyKnB0LlNhZmVCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IoeS5oKmRbMV0rMipwdC5TYWZlQm9yZGVyUGFkZGluZyl9fWNvbXB1dERyYXdQb2ludHMoZSl7cmV0dXJuIHRoaXMudG1wUG9pbnRzWzFdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzWzBdKT50aGlzLnN0cmFpZ2h0VGlwV2lkdGg/dGhpcy5jb21wdXRGdWxsUG9pbnRzKGUpOnRoaXMuY29tcHV0RG90UG9pbnRzKGUpfWNvbXB1dEZ1bGxQb2ludHMoZSl7Y29uc3QgdD1ldC5TdWIodGhpcy50bXBQb2ludHNbMV0sdGhpcy50bXBQb2ludHNbMF0pLnVuaSgpLHI9ZXQuUGVyKHQpLm11bChlLzIpLG49eHQuU3ViKHRoaXMudG1wUG9pbnRzWzBdLHIpLGk9eHQuQWRkKHRoaXMudG1wUG9pbnRzWzBdLHIpLGE9eHQuU3ViKHRoaXMudG1wUG9pbnRzWzFdLHIpLGw9eHQuQWRkKHRoaXMudG1wUG9pbnRzWzFdLHIpLHM9eHQuR2V0U2VtaWNpcmNsZVN0cm9rZSh0aGlzLnRtcFBvaW50c1sxXSxhLC0xLDgpLGY9eHQuR2V0U2VtaWNpcmNsZVN0cm9rZSh0aGlzLnRtcFBvaW50c1swXSxpLC0xLDgpLHY9W24sYSwuLi5zLGwsaSwuLi5mXTtyZXR1cm57ZDp2ZSh2LCEwKSxyZWN0Ok50KHYpLGlzRG90OiExLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19Y29tcHV0RG90UG9pbnRzKGUpe2NvbnN0IHQ9eHQuR2V0RG90U3Ryb2tlKHRoaXMudG1wUG9pbnRzWzBdLGUvMiw4KTtyZXR1cm57ZDp2ZSh0LCEwKSxyZWN0Ok50KHQpLGlzRG90OiEwLHBvczp0aGlzLnRtcFBvaW50c1swXS5YWX19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PWUuc2xpY2UoLTIpLHI9bmV3IHh0KHRbMF0sdFsxXSksbj10aGlzLnRtcFBvaW50c1swXSx7dGhpY2tuZXNzOml9PXRoaXMud29ya09wdGlvbnM7aWYobi5pc05lYXIocixpKSlyZXR1cm4hMTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT0yKXtpZihyLmlzTmVhcih0aGlzLnRtcFBvaW50c1sxXSwxKSlyZXR1cm4hMTt0aGlzLnRtcFBvaW50c1sxXT1yfWVsc2UgdGhpcy50bXBQb2ludHMucHVzaChyKTtyZXR1cm4hMH1jb25zdW1lU2VydmljZShlKXt2YXIgbDtjb25zdHtvcDp0LGlzRnVsbFdvcms6cn09ZSxuPShsPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6bC50b1N0cmluZygpO2lmKCFuKXJldHVybjt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrPTMpdGhpcy50bXBQb2ludHMucHVzaChuZXcgeHQodFtzXSx0W3MrMV0sdFtzKzJdKSk7Y29uc3QgaT1yP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcixhPXRoaXMuZHJhdyh7d29ya0lkOm4sbGF5ZXI6aX0pO3JldHVybiB0aGlzLm9sZFJlY3Q9YSx0aGlzLnZOb2Rlcy5zZXRJbmZvKG4se3JlY3Q6YSxvcDp0LG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczphJiZwdC5nZXRDZW50ZXJQb3MoYSxpKX0pLGF9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1zdGF0aWMgdXBkYXRlTm9kZU9wdChlKXt2YXIgbDtjb25zdHtub2RlOnQsb3B0OnIsdk5vZGVzOm59PWUse3N0cm9rZUNvbG9yOml9PXIsYT1uLmdldCh0Lm5hbWUpO3JldHVybiBpJiYodC5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixpKSx0LnNldEF0dHJpYnV0ZSgiZmlsbENvbG9yIixpKSwobD1hPT1udWxsP3ZvaWQgMDphLm9wdCkhPW51bGwmJmwuc3Ryb2tlQ29sb3ImJihhLm9wdC5zdHJva2VDb2xvcj1pKSksYSYmbi5zZXRJbmZvKHQubmFtZSxhKSxwdC51cGRhdGVOb2RlT3B0KGUpfX1jbGFzcyBiZSBleHRlbmRzIHB0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYW5Sb3RhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZVR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpqdC5hbGx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZHQuVGV4dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvbGRSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLnRvb2xzT3B0fWNvbnN1bWUoKXtyZXR1cm57dHlwZTphdC5Ob25lfX1jb25zdW1lQWxsKCl7cmV0dXJue3R5cGU6YXQuTm9uZX19ZHJhdyhlKXt2YXIgUDtjb25zdHt3b3JrSWQ6dCxsYXllcjpyLGlzRHJhd0xhYmVsOm59PWU7dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodCkubWFwKHg9PngucmVtb3ZlKCkpLChQPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8UC5nZXRFbGVtZW50c0J5TmFtZSh0KS5tYXAoeD0+eC5yZW1vdmUoKSk7Y29uc3R7Ym94U2l6ZTppLGJveFBvaW50OmEsekluZGV4Omx9PXRoaXMud29ya09wdGlvbnMscz1yLndvcmxkUG9zaXRpb24sZj1yLndvcmxkU2NhbGluZztpZighYXx8IWkpcmV0dXJuO2NvbnN0IHY9bmV3IHRlKHtuYW1lOnQsaWQ6dCxwb3M6W2FbMF0raVswXS8yLGFbMV0raVsxXS8yXSxhbmNob3I6Wy41LC41XSxzaXplOmksekluZGV4Omx9KSxkPXt4OmFbMF0seTphWzFdLHc6aVswXSxoOmlbMV19LHA9bmV3IGFyKHtub3JtYWxpemU6ITAscG9zOlswLDBdLHNpemU6aX0pLHk9biYmYmUuY3JlYXRlTGFiZWxzKHRoaXMud29ya09wdGlvbnMscil8fFtdO3JldHVybiB2LmFwcGVuZCguLi55LHApLHIuYXBwZW5kKHYpLHt4Ok1hdGguZmxvb3IoZC54KmZbMF0rc1swXSkseTpNYXRoLmZsb29yKGQueSpmWzFdK3NbMV0pLHc6TWF0aC5mbG9vcihkLncqZlswXSksaDpNYXRoLmZsb29yKGQuaCpmWzFdKX19Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHMsZjtjb25zdCB0PShzPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKCF0KXJldHVybjtjb25zdHtpc0Z1bGxXb3JrOnIscmVwbGFjZUlkOm4saXNEcmF3TGFiZWw6aX09ZTt0aGlzLm9sZFJlY3Q9biYmKChmPXRoaXMudk5vZGVzLmdldChuKSk9PW51bGw/dm9pZCAwOmYucmVjdCl8fHZvaWQgMDtjb25zdCBhPXI/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLGw9dGhpcy5kcmF3KHt3b3JrSWQ6dCxsYXllcjphLGlzRHJhd0xhYmVsOml9KTtyZXR1cm4gdGhpcy52Tm9kZXMuc2V0SW5mbyh0LHtyZWN0Omwsb3A6W10sb3B0OnRoaXMud29ya09wdGlvbnMsdG9vbHNUeXBlOnRoaXMudG9vbHNUeXBlLHNjYWxlVHlwZTp0aGlzLnNjYWxlVHlwZSxjYW5Sb3RhdGU6dGhpcy5jYW5Sb3RhdGUsY2VudGVyUG9zOmwmJnB0LmdldENlbnRlclBvcyhsLGEpfSksbH11cGRhdGFPcHRTZXJ2aWNlKGUpe2lmKCF0aGlzLndvcmtJZClyZXR1cm47Y29uc3QgdD10aGlzLndvcmtJZC50b1N0cmluZygpLHtmb250Q29sb3I6cixmb250QmdDb2xvcjpuLGJvbGQ6aSxpdGFsaWM6YSxsaW5lVGhyb3VnaDpsLHVuZGVybGluZTpzLHpJbmRleDpmfT1lLHY9dGhpcy52Tm9kZXMuZ2V0KHQpO2lmKCF2KXJldHVybjtyJiYodi5vcHQuZm9udENvbG9yPXIpLG4mJih2Lm9wdC5mb250QmdDb2xvcj1uKSxpJiYodi5vcHQuYm9sZD1pKSxhJiYodi5vcHQuaXRhbGljPWEpLGxlKGwpJiYodi5vcHQubGluZVRocm91Z2g9bCksbGUocykmJih2Lm9wdC51bmRlcmxpbmU9cyksbiYmKHYub3B0LmZvbnRCZ0NvbG9yPW4pLG5lKGYpJiYodi5vcHQuekluZGV4PWYpLHRoaXMub2xkUmVjdD12LnJlY3Q7Y29uc3QgZD10aGlzLmRyYXcoe3dvcmtJZDp0LGxheWVyOnRoaXMuZnVsbExheWVyLGlzRHJhd0xhYmVsOiExfSk7cmV0dXJuIHRoaXMudk5vZGVzLnNldEluZm8odCx7cmVjdDpkLG9wOltdLG9wdDp0aGlzLndvcmtPcHRpb25zLHRvb2xzVHlwZTp0aGlzLnRvb2xzVHlwZSxzY2FsZVR5cGU6dGhpcy5zY2FsZVR5cGUsY2FuUm90YXRlOnRoaXMuY2FuUm90YXRlLGNlbnRlclBvczpkJiZwdC5nZXRDZW50ZXJQb3MoZCx0aGlzLmZ1bGxMYXllcil9KSxkfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9c3RhdGljIGdldEZvbnRXaWR0aChlKXtjb25zdHtjdHg6dCxvcHQ6cix0ZXh0Om59PWUse2JvbGQ6aSxpdGFsaWM6YSxmb250U2l6ZTpsLGZvbnRGYW1pbHk6c309cjtyZXR1cm4gdC5mb250PWAke2l9ICR7YX0gJHtsfXB4ICR7c31gLHQubWVhc3VyZVRleHQobikud2lkdGh9c3RhdGljIGNyZWF0ZUxhYmVscyhlLHQpe2NvbnN0IHI9W10sbj1lLnRleHQuc3BsaXQoIiwiKSxpPW4ubGVuZ3RoO2ZvcihsZXQgYT0wO2E8aTthKyspe2NvbnN0IGw9blthXSx7Zm9udFNpemU6cyxsaW5lSGVpZ2h0OmYsYm9sZDp2LHRleHRBbGlnbjpkLGl0YWxpYzpwLGJveFNpemU6eSxmb250RmFtaWx5OlAsdmVydGljYWxBbGlnbjp4LGZvbnRDb2xvcjptLHVuZGVybGluZTpPLGxpbmVUaHJvdWdoOm99PWUsaD1mfHxzKjEuMixjPXQmJnQucGFyZW50LmNhbnZhcy5nZXRDb250ZXh0KCIyZCIpLGc9YyYmYmUuZ2V0Rm9udFdpZHRoKHt0ZXh0Omwsb3B0OmUsY3R4OmMsd29ybGRTY2FsaW5nOnQud29ybGRTY2FsaW5nfSk7aWYoZyl7Y29uc3QgYj17YW5jaG9yOlswLC41XSx0ZXh0OmwsZm9udFNpemU6cyxsaW5lSGVpZ2h0OmgsZm9udEZhbWlseTpQLGZvbnRXZWlnaHQ6dixmaWxsQ29sb3I6bSx0ZXh0QWxpZ246ZCxmb250U3R5bGU6cCxuYW1lOmEudG9TdHJpbmcoKSxjbGFzc05hbWU6ImxhYmVsIn0sRT1bMCwwXTtpZih4PT09Im1pZGRsZSIpe2NvbnN0IEw9KGktMSkvMjtFWzFdPShhLUwpKmh9ZD09PSJsZWZ0IiYmKEVbMF09eSYmLXlbMF0vMis1fHwwKSxiLnBvcz1FO2NvbnN0IEE9bmV3IEhoKGIpO2lmKHIucHVzaChBKSxPKXtjb25zdCBMPXtub3JtYWxpemU6ITEscG9zOltiLnBvc1swXSxiLnBvc1sxXStzLzJdLGxpbmVXaWR0aDoyKnQud29ybGRTY2FsaW5nWzBdLHBvaW50czpbMCwwLGcsMF0sc3Ryb2tlQ29sb3I6bSxuYW1lOmAke2F9X3VuZGVybGluZWAsY2xhc3NOYW1lOiJ1bmRlcmxpbmUifSxNPW5ldyBlZShMKTtyLnB1c2goTSl9aWYobyl7Y29uc3QgTD17bm9ybWFsaXplOiExLHBvczpiLnBvcyxsaW5lV2lkdGg6Mip0LndvcmxkU2NhbGluZ1swXSxwb2ludHM6WzAsMCxnLDBdLHN0cm9rZUNvbG9yOm0sbmFtZTpgJHthfV9saW5lVGhyb3VnaGAsY2xhc3NOYW1lOiJsaW5lVGhyb3VnaCJ9LE09bmV3IGVlKEwpO3IucHVzaChNKX19fXJldHVybiByfXN0YXRpYyB1cGRhdGVOb2RlT3B0KGUpe2NvbnN0e25vZGU6dCxvcHQ6cix2Tm9kZXM6bix0YXJnZXROb2RlOml9PWUse2ZvbnRCZ0NvbG9yOmEsZm9udENvbG9yOmwsdHJhbnNsYXRlOnMsYm94OmYsYm94U2NhbGU6dixib3hUcmFuc2xhdGU6ZCxib2xkOnAsaXRhbGljOnksbGluZVRocm91Z2g6UCx1bmRlcmxpbmU6eCxmb250U2l6ZTptLHRleHRJbmZvczpPfT1yLG89aSYmWXQoaSl8fG4uZ2V0KHQubmFtZSk7aWYoIW8pcmV0dXJuO2NvbnN0IGg9dC5wYXJlbnQ7aWYoIWgpcmV0dXJuO2NvbnN0IGM9by5vcHQ7aWYobCYmYy5mb250Q29sb3ImJihjLmZvbnRDb2xvcj1sKSxhJiZjLmZvbnRCZ0NvbG9yJiYoYy5mb250QmdDb2xvcj1hKSxwJiYoYy5ib2xkPXApLHkmJihjLml0YWxpYz15KSxsZShQKSYmKGMubGluZVRocm91Z2g9UCksbGUoeCkmJihjLnVuZGVybGluZT14KSxtJiYoYy5mb250U2l6ZT1tKSxmJiZkJiZ2KXtjb25zdCBnPU89PW51bGw/dm9pZCAwOk8uZ2V0KHQubmFtZSk7aWYoZyl7Y29uc3R7Zm9udFNpemU6QSxib3hTaXplOkx9PWc7Yy5ib3hTaXplPUx8fGMuYm94U2l6ZSxjLmZvbnRTaXplPUF8fGMuZm9udFNpemV9Y29uc3QgYj1vLnJlY3QsRT1PZSh4bihiLHYpLGQpO2MuYm94UG9pbnQ9RSYmWyhFLngtaC53b3JsZFBvc2l0aW9uWzBdKS9oLndvcmxkU2NhbGluZ1swXSwoRS55LWgud29ybGRQb3NpdGlvblsxXSkvaC53b3JsZFNjYWxpbmdbMV1dfWVsc2UgaWYocyYmYy5ib3hQb2ludCl7Y29uc3QgZz1bc1swXS9oLndvcmxkU2NhbGluZ1swXSxzWzFdL2gud29ybGRTY2FsaW5nWzFdXTtjLmJveFBvaW50PVtjLmJveFBvaW50WzBdK2dbMF0sYy5ib3hQb2ludFsxXStnWzFdXSxvLmNlbnRlclBvcz1bby5jZW50ZXJQb3NbMF0rZ1swXSxvLmNlbnRlclBvc1sxXStnWzFdXSxvLnJlY3Q9T2Uoby5yZWN0LGcpfXJldHVybiBvJiZuLnNldEluZm8odC5uYW1lLG8pLG89PW51bGw/dm9pZCAwOm8ucmVjdH1zdGF0aWMgZ2V0UmVjdEZyb21MYXllcihlLHQpe2NvbnN0IHI9ZS5nZXRFbGVtZW50c0J5TmFtZSh0KVswXTtpZihyKXtjb25zdCBuPXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6TWF0aC5mbG9vcihuLngpLHk6TWF0aC5mbG9vcihuLnkpLHc6TWF0aC5mbG9vcihuLndpZHRoKSxoOk1hdGguZmxvb3Iobi5oZWlnaHQpfX19fWZ1bmN0aW9uIEpuKHUpe3N3aXRjaCh1KXtjYXNlIGR0LkFycm93OnJldHVybiB6bjtjYXNlIGR0LlBlbmNpbDpyZXR1cm4gTW47Y2FzZSBkdC5TdHJhaWdodDpyZXR1cm4gWm47Y2FzZSBkdC5FbGxpcHNlOnJldHVybiBHbjtjYXNlIGR0LlBvbHlnb246Y2FzZSBkdC5UcmlhbmdsZTpyZXR1cm4gVm47Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUmhvbWJ1czpyZXR1cm4gS247Y2FzZSBkdC5SZWN0YW5nbGU6cmV0dXJuIEhuO2Nhc2UgZHQuU3BlZWNoQmFsbG9vbjpyZXR1cm4gWW47Y2FzZSBkdC5UZXh0OnJldHVybiBiZTtjYXNlIGR0Lkxhc2VyUGVuOnJldHVybiBFbjtjYXNlIGR0LkVyYXNlcjpyZXR1cm4gSnQ7Y2FzZSBkdC5TZWxlY3RvcjpyZXR1cm4gSXQ7Y2FzZSBkdC5JbWFnZTpyZXR1cm4gWG59fWZ1bmN0aW9uIGhyKHUsZSl7Y29uc3R7dG9vbHNUeXBlOnQsLi4ucn09dTtzd2l0Y2godCl7Y2FzZSBkdC5BcnJvdzpyZXR1cm4gbmV3IHpuKHIpO2Nhc2UgZHQuUGVuY2lsOnJldHVybiBuZXcgTW4ocik7Y2FzZSBkdC5TdHJhaWdodDpyZXR1cm4gbmV3IFpuKHIpO2Nhc2UgZHQuRWxsaXBzZTpyZXR1cm4gbmV3IEduKHIpO2Nhc2UgZHQuUG9seWdvbjpjYXNlIGR0LlRyaWFuZ2xlOnJldHVybiBuZXcgVm4ocik7Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUmhvbWJ1czpyZXR1cm4gbmV3IEtuKHIpO2Nhc2UgZHQuUmVjdGFuZ2xlOnJldHVybiBuZXcgSG4ocik7Y2FzZSBkdC5TcGVlY2hCYWxsb29uOnJldHVybiBuZXcgWW4ocik7Y2FzZSBkdC5UZXh0OnJldHVybiBuZXcgYmUocik7Y2FzZSBkdC5MYXNlclBlbjpyZXR1cm4gbmV3IEVuKHIpO2Nhc2UgZHQuRXJhc2VyOnJldHVybiBuZXcgSnQocixlKTtjYXNlIGR0LlNlbGVjdG9yOnJldHVybiBuZXcgSXQocik7Y2FzZSBkdC5JbWFnZTpyZXR1cm4gbmV3IFhuKHIpO2RlZmF1bHQ6cmV0dXJufX1mdW5jdGlvbiBRbih1KXtjb25zdCBlPVtdLHQ9WyJQQVRIIiwiU1BSSVRFIiwiUE9MWUxJTkUiLCJSRUNUIiwiRUxMSVBTRSJdO2Zvcihjb25zdCByIG9mIHUpe2lmKHIudGFnTmFtZT09PSJHUk9VUCImJnIuY2hpbGRyZW4ubGVuZ3RoKXJldHVybiBRbihyLmNoaWxkcmVuKTtyLnRhZ05hbWUmJnQuaW5jbHVkZXMoci50YWdOYW1lKSYmZS5wdXNoKHIpfXJldHVybiBlfWNsYXNzIGNnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuWkluZGV4QWN0aXZlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm59PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBsLHMsZix2LGQ7Y29uc3R7d29ya0lkOnQsaXNBY3RpdmVaSW5kZXg6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm59PWU7aWYodCE9PUl0LnNlbGVjdG9ySWQpcmV0dXJuO2NvbnN0IGk9KGw9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpsLndvcmtTaGFwZXMuZ2V0KEl0LnNlbGVjdG9ySWQpO2lmKCFpKXJldHVybjtjb25zdCBhPWkub2xkU2VsZWN0UmVjdDtpZihyJiZhJiZ0aGlzLmxvY2FsV29yayl7Y29uc3QgcD1uZXcgU2V0O2lmKHRoaXMubG9jYWxXb3JrLnZOb2Rlcy5jdXJOb2RlTWFwLmZvckVhY2goKHksUCk9Pnt4ZShhLHkucmVjdCkmJnAuYWRkKFApfSkscC5zaXplKXtjb25zdCB5PVtdO3AuZm9yRWFjaChQPT57dmFyIHg7KHg9dGhpcy5sb2NhbFdvcmspPT1udWxsfHx4LmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShQKS5mb3JFYWNoKG09Pnt2YXIgbyxoO2NvbnN0IE89bS5jbG9uZU5vZGUoITApO1VlKG0pJiZPLnNlYWwoKSwoaD0obz10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOm8uZHJhd0xheWVyKSE9bnVsbCYmaC5nZXRFbGVtZW50c0J5TmFtZShQKS5sZW5ndGh8fHkucHVzaChPKX0pfSkseS5sZW5ndGgmJigocz10aGlzLmxvY2FsV29yay5kcmF3TGF5ZXIpPT1udWxsfHxzLmFwcGVuZCguLi55KSl9fWVsc2Uodj0oZj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOmYuZHJhd0xheWVyKT09bnVsbHx8di5jaGlsZHJlbi5maWx0ZXIocD0+e3ZhciB5O3JldHVybiEoKHk9aS5zZWxlY3RJZHMpIT1udWxsJiZ5LmluY2x1ZGVzKHAubmFtZSkpfSkuZm9yRWFjaChwPT5wLnJlbW92ZSgpKTtuJiYoKGQ9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxkLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmEsZHJhd0NhbnZhczp5dC5TZWxlY3RvcixjbGVhckNhbnZhczp5dC5TZWxlY3Rvcixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMubG9jYWxXb3JrLnZpZXdJZH1dLHNwOlt7dHlwZTphdC5TZWxlY3Qsc2VsZWN0SWRzOmkuc2VsZWN0SWRzLG9wdDppLmdldFdvcmtPcHRpb25zKCksc2VsZWN0UmVjdDphLHN0cm9rZUNvbG9yOmkuc3Ryb2tlQ29sb3IsZmlsbENvbG9yOmkuZmlsbENvbG9yLHdpbGxTeW5jU2VydmljZTohMSxpc1N5bmM6ITB9XX0pKX19Y2xhc3MgdWcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5Db3B5Tm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpuLHVuZG9UaWNrZXJJZDppfT1lO2lmKHQ9PT1hdC5GdWxsV29yayYmcj09PU90LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKS5maW5hbGx5KCgpPT57aSYmc2V0VGltZW91dCgoKT0+e3ZhciBhOyhhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS5fcG9zdCh7c3A6W3t0eXBlOmF0Lk5vbmUsdW5kb1RpY2tlcklkOml9XX0pfSwwKX0pLCEwfWFzeW5jIGNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgcjtjb25zdHt3b3JrSWQ6dH09ZTt0JiZhd2FpdCgocj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOnIuY29uc3VtZUZ1bGwoZSx0aGlzLnNjZW5lKSl9fWNsYXNzIGZnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0Q29sb3JOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOml9PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkuZmluYWxseSgoKT0+e2kmJnNldFRpbWVvdXQoKCk9Pnt2YXIgYTsoYT10aGlzLmxvY2FsV29yayk9PW51bGx8fGEuX3Bvc3Qoe3NwOlt7dHlwZTphdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCl9KSwhMH1hc3luYyBjb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIHM7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSx3aWxsU2VyaWFsaXplRGF0YTphLHRleHRVcGRhdGVGb3JXb2tlcjpsfT1lO3Q9PT1JdC5zZWxlY3RvcklkJiZyJiZhd2FpdCgocz10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOnMudXBkYXRlU2VsZWN0b3Ioe3VwZGF0ZVNlbGVjdG9yT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmEsdGV4dFVwZGF0ZUZvcldva2VyOmwsY2FsbGJhY2s6dGhpcy51cGRhdGVTZWxlY3RvckNhbGxiYWNrfSkpfXVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2soZSl7Y29uc3R7cGFyYW06dCxwb3N0RGF0YTpyLG5ld1NlcnZpY2VTdG9yZTpufT1lLHt3aWxsU3luY1NlcnZpY2U6aSxpc1N5bmM6YSx0ZXh0VXBkYXRlRm9yV29rZXI6bH09dCxzPXIucmVuZGVyfHxbXSxmPXIuc3B8fFtdO2lmKGkpZm9yKGNvbnN0W3YsZF1vZiBuLmVudHJpZXMoKSlsJiZkLnRvb2xzVHlwZT09PWR0LlRleHQ/Zi5wdXNoKHsuLi5kLHdvcmtJZDp2LHR5cGU6YXQuVGV4dFVwZGF0ZSxkYXRhVHlwZTpPdC5Mb2NhbCx3aWxsU3luY1NlcnZpY2U6ITB9KTpmLnB1c2goey4uLmQsd29ya0lkOnYsdHlwZTphdC5VcGRhdGVOb2RlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX0saXNTeW5jOmF9KTtyZXR1cm57cmVuZGVyOnMsc3A6Zn19fWNsYXNzIGhnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuWkluZGV4Tm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT1hdC5VcGRhdGVOb2RlJiZyPT09T3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwfWFzeW5jIGNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgbDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmF9PWU7dD09PUl0LnNlbGVjdG9ySWQmJnImJmF3YWl0KChsPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6bC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm59PWUse3dpbGxTeW5jU2VydmljZTppLGlzU3luYzphfT10LGw9ci5yZW5kZXJ8fFtdLHM9ci5zcHx8W107aWYoaSYmcylmb3IoY29uc3RbZix2XW9mIG4uZW50cmllcygpKXMucHVzaCh7Li4udix3b3JrSWQ6Zix0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6YX0pO3JldHVybntyZW5kZXI6bCxzcDpzfX19Y2xhc3MgZGcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5UcmFuc2xhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOml9PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkuZmluYWxseSgoKT0+e2kmJnNldFRpbWVvdXQoKCk9Pnt2YXIgYTsoYT10aGlzLmxvY2FsV29yayk9PW51bGx8fGEuX3Bvc3Qoe3NwOlt7dHlwZTphdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCl9KSwhMH1hc3luYyBjb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGYsdjtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmEsdGV4dFVwZGF0ZUZvcldva2VyOmwsZW1pdEV2ZW50VHlwZTpzfT1lO3Q9PT1JdC5zZWxlY3RvcklkJiZyJiYoci53b3JrU3RhdGU9PT1SdC5Eb25lJiYociE9bnVsbCYmci50cmFuc2xhdGUpJiYoci50cmFuc2xhdGVbMF18fHIudHJhbnNsYXRlWzFdKXx8ci53b3JrU3RhdGUhPT1SdC5Eb25lP2F3YWl0KChmPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6Zi51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSxpc1N5bmM6ITAsdGV4dFVwZGF0ZUZvcldva2VyOmwsZW1pdEV2ZW50VHlwZTpzLHNjZW5lOnRoaXMuc2NlbmUsY2FsbGJhY2s6dGhpcy51cGRhdGVTZWxlY3RvckNhbGxiYWNrfSkpOnIud29ya1N0YXRlPT09UnQuRG9uZSYmKCh2PXRoaXMubG9jYWxXb3JrKT09bnVsbHx8di52Tm9kZXMuZGVsZXRlTGFzdFRhcmdldCgpKSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm4sd29ya1NoYXBlTm9kZTppLHJlczphfT1lLHt3aWxsU3luY1NlcnZpY2U6bCxpc1N5bmM6cyx1cGRhdGVTZWxlY3Rvck9wdDpmLHdpbGxTZXJpYWxpemVEYXRhOnYsdGV4dFVwZGF0ZUZvcldva2VyOmR9PXQscD1mLndvcmtTdGF0ZSx5PXIucmVuZGVyfHxbXSxQPXIuc3B8fFtdO2lmKHA9PT1SdC5TdGFydClyZXR1cm57c3A6W10scmVuZGVyOltdfTtjb25zdCB4PWE9PW51bGw/dm9pZCAwOmEuc2VsZWN0UmVjdDtpZihsKXtpZih2KXtjb25zdCBtPWkuZ2V0Q2hpbGRyZW5Qb2ludHMoKTttJiZQLnB1c2goe3R5cGU6YXQuU2VsZWN0LHNlbGVjdElkczppLnNlbGVjdElkcyxzZWxlY3RSZWN0Ongsd2lsbFN5bmNTZXJ2aWNlOiExLGlzU3luYzpzLHBvaW50czptfSl9Zm9yKGNvbnN0W20sT11vZiBuLmVudHJpZXMoKSlkJiZPLnRvb2xzVHlwZT09PWR0LlRleHQ/KGNvbnNvbGUubG9nKCJUcmFuc2xhdGVOb2RlIixPKSxQLnB1c2goey4uLk8sd29ya0lkOm0sdHlwZTphdC5UZXh0VXBkYXRlLGRhdGFUeXBlOk90LkxvY2FsLHdpbGxTeW5jU2VydmljZTohMH0pKTpQLnB1c2goey4uLk8sd29ya0lkOm0sdHlwZTphdC5VcGRhdGVOb2RlLHVwZGF0ZU5vZGVPcHQ6e3VzZUFuaW1hdGlvbjohMX0saXNTeW5jOnN9KX1yZXR1cm57cmVuZGVyOnksc3A6UH19fWNsYXNzIGdnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuRGVsZXRlTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT1hdC5SZW1vdmVOb2RlKXtpZihyPT09T3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwO2lmKHI9PT1PdC5TZXJ2aWNlJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpLCEwfX1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7aWYoIXRoaXMubG9jYWxXb3JrKXJldHVybjtjb25zdHtyZW1vdmVJZHM6dCx3aWxsUmVmcmVzaDpyLHdpbGxTeW5jU2VydmljZTpuLHZpZXdJZDppfT1lO2lmKCEodCE9bnVsbCYmdC5sZW5ndGgpKXJldHVybjtsZXQgYTtjb25zdCBsPVtdLHM9W10sZj1bXTtmb3IoY29uc3QgdiBvZiB0KXtpZih2PT09SXQuc2VsZWN0b3JJZCl7Y29uc3QgcD10aGlzLmxvY2FsV29yay53b3JrU2hhcGVzLmdldChJdC5zZWxlY3RvcklkKTtpZighcClyZXR1cm47Y29uc3QgeT1wLnNlbGVjdElkcyYmWy4uLnAuc2VsZWN0SWRzXXx8W107Zm9yKGNvbnN0IHggb2YgeSl7aWYodGhpcy5sb2NhbFdvcmsudk5vZGVzLmdldCh4KSl7Y29uc3QgTz10aGlzLmNvbW1hbmREZWxldGVUZXh0KHgpO08mJmwucHVzaChPKX1hPWJ0KGEsdGhpcy5sb2NhbFdvcmsucmVtb3ZlTm9kZSh4KSksZi5wdXNoKHgpfWNvbnN0IFA9cD09bnVsbD92b2lkIDA6cC51cGRhdGVTZWxlY3RJZHMoW10pO2E9YnQoYSxQLmJnUmVjdCksdGhpcy5sb2NhbFdvcmsuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoSXQuc2VsZWN0b3JJZCksdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5kZWxldGUoSXQuc2VsZWN0b3JJZCksbC5wdXNoKHt0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6W10sd2lsbFN5bmNTZXJ2aWNlOm59KTtjb250aW51ZX1jb25zdCBkPXRoaXMuY29tbWFuZERlbGV0ZVRleHQodik7ZCYmbC5wdXNoKGQpLGE9YnQoYSx0aGlzLmxvY2FsV29yay5yZW1vdmVOb2RlKHYpKSxmLnB1c2godil9biYmbC5wdXNoKHt0eXBlOmF0LlJlbW92ZU5vZGUscmVtb3ZlSWRzOmYsdW5kb1RpY2tlcklkOmUudW5kb1RpY2tlcklkfSksYSYmciYmcy5wdXNoKHtyZWN0OmEsZHJhd0NhbnZhczp5dC5CZyxjbGVhckNhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsdmlld0lkOml9KSwocy5sZW5ndGh8fGwubGVuZ3RoKSYmdGhpcy5sb2NhbFdvcmsuX3Bvc3Qoe3JlbmRlcjpzLHNwOmx9KX1jb25zdW1lRm9yU2VydmljZVdvcmtlcihlKXt0aGlzLnNlcnZpY2VXb3JrJiZ0aGlzLnNlcnZpY2VXb3JrLnJlbW92ZVNlbGVjdFdvcmsoZSl9Y29tbWFuZERlbGV0ZVRleHQoZSl7dmFyIHI7Y29uc3QgdD0ocj10aGlzLmxvY2FsV29yayk9PW51bGw/dm9pZCAwOnIudk5vZGVzLmdldChlKTtpZih0JiZ0LnRvb2xzVHlwZT09PWR0LlRleHQpcmV0dXJue3R5cGU6YXQuVGV4dFVwZGF0ZSx0b29sc1R5cGU6ZHQuVGV4dCx3b3JrSWQ6ZSxkYXRhVHlwZTpPdC5Mb2NhbH19fWNsYXNzIHBnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2NhbGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOml9PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkuZmluYWxseSgoKT0+e2kmJnNldFRpbWVvdXQoKCk9Pnt2YXIgYTsoYT10aGlzLmxvY2FsV29yayk9PW51bGx8fGEuX3Bvc3Qoe3NwOlt7dHlwZTphdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCl9KSwhMH1hc3luYyBjb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGE7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxTeW5jU2VydmljZTpuLHdpbGxTZXJpYWxpemVEYXRhOml9PWU7dD09PUl0LnNlbGVjdG9ySWQmJnImJmF3YWl0KChhPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6YS51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsU3luY1NlcnZpY2U6bix3aWxsU2VyaWFsaXplRGF0YTppLGlzU3luYzohMCxzY2VuZTp0aGlzLnNjZW5lLGNhbGxiYWNrOnRoaXMudXBkYXRlU2VsZWN0b3JDYWxsYmFjay5iaW5kKHRoaXMpfSkpfXVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2soZSl7Y29uc3R7cGFyYW06dCxwb3N0RGF0YTpyLHdvcmtTaGFwZU5vZGU6bixyZXM6aSxuZXdTZXJ2aWNlU3RvcmU6YX09ZSx7dXBkYXRlU2VsZWN0b3JPcHQ6bCx3aWxsU3luY1NlcnZpY2U6cyx3aWxsU2VyaWFsaXplRGF0YTpmfT10LHY9bC53b3JrU3RhdGUsZD1yLnJlbmRlcnx8W10scD1yLnNwfHxbXSx5PWk9PW51bGw/dm9pZCAwOmkuc2VsZWN0UmVjdCxQPWk9PW51bGw/dm9pZCAwOmkucmVuZGVyUmVjdDtpZih2PT09UnQuU3RhcnQpcmV0dXJue3NwOltdLHJlbmRlcjpbXX07aWYodGhpcy5sb2NhbFdvcmspe2QucHVzaCh7aXNDbGVhckFsbDohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOnl0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLmxvY2FsV29yay52aWV3SWR9KTtjb25zdCB4PXtyZWN0OlAsaXNGdWxsV29yazohMSxkcmF3Q2FudmFzOnl0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLmxvY2FsV29yay52aWV3SWR9O2QucHVzaCh4KX1pZihzKXt2PT09UnQuRG9pbmcmJnAucHVzaCh7dHlwZTphdC5TZWxlY3Qsc2VsZWN0SWRzOm4uc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eSx3aWxsU3luY1NlcnZpY2U6ITAsaXNTeW5jOiEwLHBvaW50czpuLmdldENoaWxkcmVuUG9pbnRzKCksdGV4dE9wdDpuLnRleHRPcHR9KSxmJiZ2PT09UnQuRG9uZSYmcC5wdXNoKHt0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6bi5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LHdpbGxTeW5jU2VydmljZTohMSxpc1N5bmM6ITAscG9pbnRzOm4uZ2V0Q2hpbGRyZW5Qb2ludHMoKSx0ZXh0T3B0Om4udGV4dE9wdH0pO2Zvcihjb25zdFt4LG1db2YgYS5lbnRyaWVzKCkpbS50b29sc1R5cGU9PT1kdC5UZXh0P3AucHVzaCh7Li4ubSx3b3JrSWQ6eCx0eXBlOmF0LlRleHRVcGRhdGUsZGF0YVR5cGU6T3QuTG9jYWwsd2lsbFN5bmNTZXJ2aWNlOiEwfSk6cC5wdXNoKHsuLi5tLHdvcmtJZDp4LHR5cGU6YXQuVXBkYXRlTm9kZSx1cGRhdGVOb2RlT3B0Ont1c2VBbmltYXRpb246ITF9LGlzU3luYzohMH0pfXJldHVybntyZW5kZXI6ZCxzcDpwfX19Y2xhc3MgbWcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5Sb3RhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOml9PWU7aWYodD09PWF0LlVwZGF0ZU5vZGUmJnI9PT1PdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSkuZmluYWxseSgoKT0+e2kmJnNldFRpbWVvdXQoKCk9Pnt2YXIgYTsoYT10aGlzLmxvY2FsV29yayk9PW51bGx8fGEuX3Bvc3Qoe3NwOlt7dHlwZTphdC5Ob25lLHVuZG9UaWNrZXJJZDppfV19KX0sMCl9KSwhMH1hc3luYyBjb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIHM7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSx3aWxsU2VyaWFsaXplRGF0YTphLGVtaXRFdmVudFR5cGU6bH09ZTt0PT09SXQuc2VsZWN0b3JJZCYmciYmYXdhaXQoKHM9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpzLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSx3aWxsU2VyaWFsaXplRGF0YTphLGVtaXRFdmVudFR5cGU6bCxpc1N5bmM6ITAsc2NlbmU6dGhpcy5zY2VuZSxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsd29ya1NoYXBlTm9kZTpuLHJlczppLG5ld1NlcnZpY2VTdG9yZTphfT1lLHt1cGRhdGVTZWxlY3Rvck9wdDpsLHdpbGxTeW5jU2VydmljZTpzLHdpbGxTZXJpYWxpemVEYXRhOmYsaXNTeW5jOnZ9PXQsZD1sLndvcmtTdGF0ZSxwPXIucmVuZGVyfHxbXSx5PXIuc3B8fFtdLFA9aT09bnVsbD92b2lkIDA6aS5zZWxlY3RSZWN0O2lmKHMpe2YmJmQ9PT1SdC5Eb25lJiZ5LnB1c2goe3R5cGU6YXQuU2VsZWN0LHNlbGVjdElkczpuLnNlbGVjdElkcyxzZWxlY3RSZWN0OlAsd2lsbFN5bmNTZXJ2aWNlOiEwLGlzU3luYzp2LHBvaW50czpuLmdldENoaWxkcmVuUG9pbnRzKCl9KTtmb3IoY29uc3RbeCxtXW9mIGEuZW50cmllcygpKXkucHVzaCh7Li4ubSx3b3JrSWQ6eCx0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6dn0pfXJldHVybntyZW5kZXI6cCxzcDp5fX19Y2xhc3MgdmcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5TZXRGb250U3R5bGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6aX09ZTtpZih0PT09YXQuVXBkYXRlTm9kZSYmcj09PU90LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKS5maW5hbGx5KCgpPT57aSYmc2V0VGltZW91dCgoKT0+e3ZhciBhOyhhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS5fcG9zdCh7c3A6W3t0eXBlOmF0Lk5vbmUsdW5kb1RpY2tlcklkOml9XX0pfSwwKX0pLCEwfWFzeW5jIGNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgcztjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmEsdGV4dFVwZGF0ZUZvcldva2VyOmx9PWU7dD09PUl0LnNlbGVjdG9ySWQmJnImJmF3YWl0KChzPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6cy51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSx0ZXh0VXBkYXRlRm9yV29rZXI6bCxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm4sd29ya1NoYXBlTm9kZTppLHJlczphfT1lLHt3aWxsU3luY1NlcnZpY2U6bCxpc1N5bmM6cyx1cGRhdGVTZWxlY3Rvck9wdDpmLHRleHRVcGRhdGVGb3JXb2tlcjp2fT10LGQ9ci5yZW5kZXJ8fFtdLHA9ci5zcHx8W10seT1hPT1udWxsP3ZvaWQgMDphLnNlbGVjdFJlY3Q7aWYobCYmcCl7Zi5mb250U2l6ZSYmcC5wdXNoKHt0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6aS5zZWxlY3RJZHMsc2VsZWN0UmVjdDp5LHdpbGxTeW5jU2VydmljZTpsLGlzU3luYzpzLHBvaW50czppLmdldENoaWxkcmVuUG9pbnRzKCl9KTtmb3IoY29uc3RbUCx4XW9mIG4uZW50cmllcygpKXYmJngudG9vbHNUeXBlPT09ZHQuVGV4dD9wLnB1c2goey4uLngsd29ya0lkOlAsdHlwZTphdC5UZXh0VXBkYXRlLGRhdGFUeXBlOk90LkxvY2FsLHdpbGxTeW5jU2VydmljZTohMH0pOnAucHVzaCh7Li4ueCx3b3JrSWQ6UCx0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6c30pfXJldHVybntyZW5kZXI6ZCxzcDpwfX19Y2xhc3MgeWcgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpDdC5TZXRQb2ludH0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpuLHVuZG9UaWNrZXJJZDppfT1lO2lmKHQ9PT1hdC5VcGRhdGVOb2RlJiZyPT09T3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLmZpbmFsbHkoKCk9PntpJiZzZXRUaW1lb3V0KCgpPT57dmFyIGE7KGE9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxhLl9wb3N0KHtzcDpbe3R5cGU6YXQuTm9uZSx1bmRvVGlja2VySWQ6aX1dfSl9LDApfSksITB9YXN5bmMgY29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBzO2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSx0ZXh0VXBkYXRlRm9yV29rZXI6bH09ZTt0PT09SXQuc2VsZWN0b3JJZCYmciYmYXdhaXQoKHM9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpzLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSxlbWl0RXZlbnRUeXBlOnRoaXMuZW1pdEV2ZW50VHlwZSx3aWxsU2VyaWFsaXplRGF0YTphLGlzU3luYzohMCx0ZXh0VXBkYXRlRm9yV29rZXI6bCxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm4sd29ya1NoYXBlTm9kZTppLHJlczphfT1lLHt3aWxsU3luY1NlcnZpY2U6bCxpc1N5bmM6c309dCxmPXIucmVuZGVyfHxbXSx2PXIuc3B8fFtdLGQ9YT09bnVsbD92b2lkIDA6YS5zZWxlY3RSZWN0O2lmKGwmJnYpe2Zvcihjb25zdFtwLHldb2Ygbi5lbnRyaWVzKCkpdi5wdXNoKHsuLi55LHdvcmtJZDpwLHR5cGU6YXQuVXBkYXRlTm9kZSx1cGRhdGVOb2RlT3B0Ont1c2VBbmltYXRpb246ITF9LGlzU3luYzpzfSk7di5wdXNoKHt0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6aS5zZWxlY3RJZHMsc2VsZWN0UmVjdDpkLHdpbGxTeW5jU2VydmljZTpsLGlzU3luYzpzLHBvaW50czppLmdldENoaWxkcmVuUG9pbnRzKCl9KX1yZXR1cm57cmVuZGVyOmYsc3A6dn19fWNsYXNzIFNnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0TG9ja30pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpuLHVuZG9UaWNrZXJJZDppfT1lO2lmKHQ9PT1hdC5VcGRhdGVOb2RlJiZyPT09T3QuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLmZpbmFsbHkoKCk9PntpJiZzZXRUaW1lb3V0KCgpPT57dmFyIGE7KGE9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxhLl9wb3N0KHtzcDpbe3R5cGU6YXQuTm9uZSx1bmRvVGlja2VySWQ6aX1dfSl9LDApfSksITB9YXN5bmMgY29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBsO2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YX09ZTt0PT09SXQuc2VsZWN0b3JJZCYmciYmYXdhaXQoKGw9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpsLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6aSx3aWxsU2VyaWFsaXplRGF0YTphLGNhbGxiYWNrOnRoaXMudXBkYXRlU2VsZWN0b3JDYWxsYmFja30pKX11cGRhdGVTZWxlY3RvckNhbGxiYWNrKGUpe2NvbnN0e3BhcmFtOnQscG9zdERhdGE6cixuZXdTZXJ2aWNlU3RvcmU6bix3b3JrU2hhcGVOb2RlOmkscmVzOmF9PWUse3dpbGxTeW5jU2VydmljZTpsLGlzU3luYzpzLHVwZGF0ZVNlbGVjdG9yT3B0OmZ9PXQsdj1yLnJlbmRlcnx8W10sZD1yLnNwfHxbXSxwPWE9PW51bGw/dm9pZCAwOmEuc2VsZWN0UmVjdDtpZihsJiZkKXtmb3IoY29uc3RbeSxQXW9mIG4uZW50cmllcygpKWQucHVzaCh7Li4uUCx3b3JrSWQ6eSx0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6c30pO2QucHVzaCh7aXNMb2NrZWQ6Zi5pc0xvY2tlZCxzZWxlY3RvckNvbG9yOmkuc2VsZWN0b3JDb2xvcixzY2FsZVR5cGU6aS5zY2FsZVR5cGUsY2FuUm90YXRlOmkuY2FuUm90YXRlLHR5cGU6YXQuU2VsZWN0LHNlbGVjdElkczppLnNlbGVjdElkcyxzZWxlY3RSZWN0OnAsd2lsbFN5bmNTZXJ2aWNlOmwsaXNTeW5jOnN9KX1yZXR1cm57cmVuZGVyOnYsc3A6ZH19fWNsYXNzIHhnIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Q3QuU2V0U2hhcGVPcHR9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6aX09ZTtpZih0PT09YXQuVXBkYXRlTm9kZSYmcj09PU90LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKS5maW5hbGx5KCgpPT57aSYmc2V0VGltZW91dCgoKT0+e3ZhciBhOyhhPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8YS5fcG9zdCh7c3A6W3t0eXBlOmF0Lk5vbmUsdW5kb1RpY2tlcklkOml9XX0pfSwwKX0pLCEwfWFzeW5jIGNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgbDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTppLHdpbGxTZXJpYWxpemVEYXRhOmF9PWU7dD09PUl0LnNlbGVjdG9ySWQmJnImJmF3YWl0KChsPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6bC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmksd2lsbFNlcmlhbGl6ZURhdGE6YSxjYWxsYmFjazp0aGlzLnVwZGF0ZVNlbGVjdG9yQ2FsbGJhY2t9KSl9dXBkYXRlU2VsZWN0b3JDYWxsYmFjayhlKXtjb25zdHtwYXJhbTp0LHBvc3REYXRhOnIsbmV3U2VydmljZVN0b3JlOm59PWUse3dpbGxTeW5jU2VydmljZTppLGlzU3luYzphfT10LGw9ci5yZW5kZXJ8fFtdLHM9ci5zcHx8W107aWYoaSYmcylmb3IoY29uc3RbZix2XW9mIG4uZW50cmllcygpKXMucHVzaCh7Li4udix3b3JrSWQ6Zix0eXBlOmF0LlVwZGF0ZU5vZGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfSxpc1N5bmM6YX0pO3JldHVybntyZW5kZXI6bCxzcDpzfX19Y2xhc3MgT2d7Y29uc3RydWN0b3IoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImJ1aWxkZXJzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLHRoaXMuYnVpbGRlcnM9bmV3IE1hcChlLm1hcCh0PT5bdCx0aGlzLmJ1aWxkKHQpXSkpfWJ1aWxkKGUpe3N3aXRjaChlKXtjYXNlIEN0LlRyYW5zbGF0ZU5vZGU6cmV0dXJuIG5ldyBkZztjYXNlIEN0LlpJbmRleE5vZGU6cmV0dXJuIG5ldyBoZztjYXNlIEN0LlpJbmRleEFjdGl2ZTpyZXR1cm4gbmV3IGNnO2Nhc2UgQ3QuQ29weU5vZGU6cmV0dXJuIG5ldyB1ZztjYXNlIEN0LlNldENvbG9yTm9kZTpyZXR1cm4gbmV3IGZnO2Nhc2UgQ3QuRGVsZXRlTm9kZTpyZXR1cm4gbmV3IGdnO2Nhc2UgQ3QuU2NhbGVOb2RlOnJldHVybiBuZXcgcGc7Y2FzZSBDdC5Sb3RhdGVOb2RlOnJldHVybiBuZXcgbWc7Y2FzZSBDdC5TZXRGb250U3R5bGU6cmV0dXJuIG5ldyB2ZztjYXNlIEN0LlNldFBvaW50OnJldHVybiBuZXcgeWc7Y2FzZSBDdC5TZXRMb2NrOnJldHVybiBuZXcgU2c7Y2FzZSBDdC5TZXRTaGFwZU9wdDpyZXR1cm4gbmV3IHhnfX1yZWdpc3RlckZvcldvcmtlcihlLHQscil7cmV0dXJuIHRoaXMuYnVpbGRlcnMuZm9yRWFjaChuPT57biYmbi5yZWdpc3RlckZvcldvcmtlcihlLHQscil9KSx0aGlzfWNvbnN1bWVGb3JXb3JrZXIoZSl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5idWlsZGVycy52YWx1ZXMoKSlpZih0IT1udWxsJiZ0LmNvbnN1bWUoZSkpcmV0dXJuITA7cmV0dXJuITF9fWNvbnN0IGRyPSJjdXJzb3Job3ZlciI7Y2xhc3MgYmd7Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidmlld0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjZW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjZW5lUGF0aCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRhcmdldE5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLHRoaXMudmlld0lkPWUsdGhpcy5zY2VuZT10fWluaXQoZSx0KXt0aGlzLmZ1bGxMYXllcj1lLHRoaXMuZHJhd0xheWVyPXR9Z2V0KGUpe3JldHVybiB0aGlzLmN1ck5vZGVNYXAuZ2V0KGUpfWhhc1JlbmRlck5vZGVzKCl7bGV0IGU9ITE7Zm9yKGNvbnN0IHQgb2YgdGhpcy5jdXJOb2RlTWFwLnZhbHVlcygpKWJuKHQudG9vbHNUeXBlKSYmKGU9ITApO3JldHVybiBlfWhhcyhlKXt0aGlzLmN1ck5vZGVNYXAuaGFzKGUpfXNldEluZm8oZSx0KXtjb25zdCByPXRoaXMuY3VyTm9kZU1hcC5nZXQoZSl8fHtuYW1lOmUscmVjdDp0LnJlY3R9O3QucmVjdCYmKHIucmVjdD1ZdCh0LnJlY3QpKSx0Lm9wJiYoci5vcD1ZdCh0Lm9wKSksdC5jYW5Sb3RhdGUmJihyLmNhblJvdGF0ZT10LmNhblJvdGF0ZSksdC5zY2FsZVR5cGUmJihyLnNjYWxlVHlwZT10LnNjYWxlVHlwZSksdC5vcHQmJihyLm9wdD1ZdCh0Lm9wdCkpLHQudG9vbHNUeXBlJiYoci50b29sc1R5cGU9dC50b29sc1R5cGUpLHQuY2VudGVyUG9zJiYoci5jZW50ZXJQb3M9WXQodC5jZW50ZXJQb3MpKSxyLnJlY3Q/dGhpcy5jdXJOb2RlTWFwLnNldChlLHIpOnRoaXMuY3VyTm9kZU1hcC5kZWxldGUoZSl9ZGVsZXRlKGUpe3RoaXMuY3VyTm9kZU1hcC5kZWxldGUoZSl9Y2xlYXIoKXt0aGlzLmN1ck5vZGVNYXAuY2xlYXIoKSx0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoPTB9Z2V0UmVjdEludGVyc2VjdFJhbmdlKGUsdD0hMCl7bGV0IHI7Y29uc3Qgbj1uZXcgTWFwO2Zvcihjb25zdFtpLGFdb2YgdGhpcy5jdXJOb2RlTWFwLmVudHJpZXMoKSlpZih4ZShlLGEucmVjdCkpe2lmKHQmJmEudG9vbHNUeXBlPT09ZHQuSW1hZ2UmJmEub3B0LmxvY2tlZHx8dCYmYS50b29sc1R5cGU9PT1kdC5UZXh0JiYoYS5vcHQud29ya1N0YXRlPT09UnQuRG9pbmd8fGEub3B0LndvcmtTdGF0ZT09PVJ0LlN0YXJ0KSljb250aW51ZTtyPWJ0KHIsYS5yZWN0KSxuLnNldChpLGEpfXJldHVybntyZWN0UmFuZ2U6cixub2RlUmFuZ2U6bn19Z2V0Tm9kZVJlY3RGb3JtU2hhcGUoZSx0KXtjb25zdCByPUpuKHQudG9vbHNUeXBlKTtsZXQgbj10aGlzLmZ1bGxMYXllciYmKHI9PW51bGw/dm9pZCAwOnIuZ2V0UmVjdEZyb21MYXllcih0aGlzLmZ1bGxMYXllcixlKSk7cmV0dXJuIW4mJnRoaXMuZHJhd0xheWVyJiYobj1yPT1udWxsP3ZvaWQgMDpyLmdldFJlY3RGcm9tTGF5ZXIodGhpcy5kcmF3TGF5ZXIsZSkpLG59dXBkYXRlTm9kZXNSZWN0KCl7dGhpcy5jdXJOb2RlTWFwLmZvckVhY2goKGUsdCk9Pntjb25zdCByPXRoaXMuZ2V0Tm9kZVJlY3RGb3JtU2hhcGUodCxlKTtyPyhlLnJlY3Q9cix0aGlzLmN1ck5vZGVNYXAuc2V0KHQsZSkpOnRoaXMuY3VyTm9kZU1hcC5kZWxldGUodCl9KX1jb21iaW5lSW50ZXJzZWN0UmVjdChlKXtsZXQgdD1lO3JldHVybiB0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaChyPT57eGUodCxyLnJlY3QpJiYodD1idCh0LHIucmVjdCkpfSksdH1zZXRUYXJnZXQoKXtyZXR1cm4gdGhpcy50YXJnZXROb2RlTWFwLnB1c2goWXQodGhpcy5jdXJOb2RlTWFwKSksdGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aC0xfWdldExhc3RUYXJnZXQoKXtyZXR1cm4gdGhpcy50YXJnZXROb2RlTWFwW3RoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGgtMV19ZGVsZXRlTGFzdFRhcmdldCgpe3RoaXMudGFyZ2V0Tm9kZU1hcC5sZW5ndGg9dGhpcy50YXJnZXROb2RlTWFwLmxlbmd0aC0xfWdldFRhcmdldChlKXtyZXR1cm4gdGhpcy50YXJnZXROb2RlTWFwW2VdfWRlbGV0ZVRhcmdldChlKXt0aGlzLnRhcmdldE5vZGVNYXAubGVuZ3RoPWV9fWNsYXNzIGtue2NvbnN0cnVjdG9yKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInZpZXdJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRwciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FtZXJhT3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjZW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlzU2FmYXJpIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ITF9KSx0aGlzLnZpZXdJZD1lLHRoaXMub3B0PXQsdGhpcy5kcHI9dC5kcHIsdGhpcy5zY2VuZT10aGlzLmNyZWF0ZVNjZW5lKHQub2Zmc2NyZWVuQ2FudmFzT3B0KSx0aGlzLmZ1bGxMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJmdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZTp0aGlzLnZpZXdJZD09PSJtYWluVmlldyI/NmUzOjNlM30pLHRoaXMudk5vZGVzPW5ldyBiZyhlLHRoaXMuc2NlbmUpfXNldElzU2FmYXJpKGUpe3RoaXMuaXNTYWZhcmk9ZX1vbihlKXtjb25zdHttc2dUeXBlOnQsdG9vbHNUeXBlOnIsb3B0Om4sd29ya0lkOmksd29ya1N0YXRlOmEsZGF0YVR5cGU6bH09ZTtzd2l0Y2godCl7Y2FzZSBhdC5EZXN0cm95OnRoaXMuZGVzdHJveSgpO2JyZWFrO2Nhc2UgYXQuQ2xlYXI6dGhpcy5jbGVhckFsbCgpO2JyZWFrO2Nhc2UgYXQuVXBkYXRlVG9vbHM6aWYociYmbil7Y29uc3Qgcz17dG9vbHNUeXBlOnIsdG9vbHNPcHQ6bn07dGhpcy5sb2NhbFdvcmsuc2V0VG9vbHNPcHQocyl9YnJlYWs7Y2FzZSBhdC5DcmVhdGVXb3JrOmkmJm4mJighdGhpcy5sb2NhbFdvcmsuZ2V0VG1wV29ya1NoYXBlTm9kZSgpJiZyJiZ0aGlzLnNldFRvb2xzT3B0KHt0b29sc1R5cGU6cix0b29sc09wdDpufSksdGhpcy5zZXRXb3JrT3B0KHt3b3JrSWQ6aSx0b29sc09wdDpufSkpO2JyZWFrO2Nhc2UgYXQuRHJhd1dvcms6YT09PVJ0LkRvbmUmJmw9PT1PdC5Mb2NhbD90aGlzLmNvbnN1bWVEcmF3QWxsKGwsZSk6dGhpcy5jb25zdW1lRHJhdyhsLGUpO2JyZWFrfX11cGRhdGVTY2VuZShlKXt0aGlzLnNjZW5lLmF0dHIoey4uLmV9KTtjb25zdHt3aWR0aDp0LGhlaWdodDpyfT1lO3RoaXMuc2NlbmUuY29udGFpbmVyLndpZHRoPXQsdGhpcy5zY2VuZS5jb250YWluZXIuaGVpZ2h0PXIsdGhpcy5zY2VuZS53aWR0aD10LHRoaXMuc2NlbmUuaGVpZ2h0PXIsdGhpcy51cGRhdGVMYXllcih7d2lkdGg6dCxoZWlnaHQ6cn0pfXVwZGF0ZUxheWVyKGUpe2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWU7dGhpcy5mdWxsTGF5ZXImJih0aGlzLmZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdCksdGhpcy5mdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixyKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LHJdKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInBvcyIsW3QqLjUsciouNV0pKSx0aGlzLmRyYXdMYXllciYmKHRoaXMuZHJhd0xheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLmRyYXdMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHIpLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXImJih0aGlzLnNuYXBzaG90RnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsciksdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LHJdKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpfWNyZWF0ZVNjZW5lKGUpe2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWUsbj1uZXcgT2Zmc2NyZWVuQ2FudmFzKHQscik7cmV0dXJuIG5ldyBLaCh7Y29udGFpbmVyOm4sZGlzcGxheVJhdGlvOnRoaXMuZHByLGRlcHRoOiExLGRlc3luY2hyb25pemVkOiEwLC4uLmV9KX1jcmVhdGVMYXllcihlLHQscil7Y29uc3R7d2lkdGg6bixoZWlnaHQ6aX09cixhPWBvZmZzY3JlZW4tJHtlfWAsbD10LmxheWVyKGEscikscz1uZXcgdGUoe2FuY2hvcjpbLjUsLjVdLHBvczpbbiouNSxpKi41XSxzaXplOltuLGldLG5hbWU6InZpZXdwb3J0IixpZDplfSk7cmV0dXJuIGwuYXBwZW5kKHMpLHN9Y2xlYXJBbGwoKXt2YXIgZTt0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnBhcmVudC5jaGlsZHJlbi5mb3JFYWNoKHQ9Pnt0Lm5hbWUhPT0idmlld3BvcnQiJiZ0LnJlbW92ZSgpfSksdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSksdGhpcy5kcmF3TGF5ZXImJih0aGlzLmRyYXdMYXllci5wYXJlbnQuY2hpbGRyZW4uZm9yRWFjaCh0PT57dC5uYW1lIT09InZpZXdwb3J0IiYmdC5yZW1vdmUoKX0pLHRoaXMuZHJhd0xheWVyLnJlbW92ZUFsbENoaWxkcmVuKCkpLHRoaXMubG9jYWxXb3JrLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCksKGU9dGhpcy5zZXJ2aWNlV29yayk9PW51bGx8fGUuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKX1zZXRUb29sc09wdChlKXt0aGlzLmxvY2FsV29yay5zZXRUb29sc09wdChlKX1zZXRXb3JrT3B0KGUpe2NvbnN0e3dvcmtJZDp0LHRvb2xzT3B0OnJ9PWU7dCYmciYmdGhpcy5sb2NhbFdvcmsuc2V0V29ya09wdGlvbnModCxyKX1kZXN0cm95KCl7dmFyIGU7dGhpcy52Tm9kZXMuY2xlYXIoKSx0aGlzLnNjZW5lLnJlbW92ZSgpLHRoaXMuZnVsbExheWVyLnJlbW92ZSgpLHRoaXMubG9jYWxXb3JrLmRlc3Ryb3koKSwoZT10aGlzLnNlcnZpY2VXb3JrKT09bnVsbHx8ZS5kZXN0cm95KCl9fWNsYXNzIHFue2NvbnN0cnVjdG9yKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRocmVhZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFdvcmtTaGFwZU5vZGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wT3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZVN0YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlZmZlY3RXb3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0NvdW50Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMudGhyZWFkPWUudGhyZWFkLHRoaXMudmlld0lkPWUudmlld0lkLHRoaXMudk5vZGVzPWUudk5vZGVzLHRoaXMuZnVsbExheWVyPWUuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyPWUuZHJhd0xheWVyLHRoaXMuX3Bvc3Q9ZS5wb3N0fWRlc3Ryb3koKXt0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCksdGhpcy53b3JrU2hhcGVzLmNsZWFyKCl9Z2V0V29ya1NoYXBlKGUpe3JldHVybiB0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfWdldFRtcFdvcmtTaGFwZU5vZGUoKXtyZXR1cm4gdGhpcy50bXBXb3JrU2hhcGVOb2RlfXNldFRtcFdvcmtJZChlKXtpZihlJiZ0aGlzLnRtcFdvcmtTaGFwZU5vZGUpe3RoaXMudG1wV29ya1NoYXBlTm9kZS5zZXRXb3JrSWQoZSksdGhpcy53b3JrU2hhcGVzLnNldChlLHRoaXMudG1wV29ya1NoYXBlTm9kZSksdGhpcy50bXBPcHQmJnRoaXMuc2V0VG9vbHNPcHQodGhpcy50bXBPcHQpO3JldHVybn19c2V0VG1wV29ya09wdGlvbnMoZSl7dmFyIHQ7KHQ9dGhpcy50bXBXb3JrU2hhcGVOb2RlKT09bnVsbHx8dC5zZXRXb3JrT3B0aW9ucyhlKX1zZXRXb3JrT3B0aW9ucyhlLHQpe3ZhciBuO3RoaXMud29ya1NoYXBlcy5nZXQoZSl8fHRoaXMuc2V0VG1wV29ya0lkKGUpLChuPXRoaXMud29ya1NoYXBlcy5nZXQoZSkpPT1udWxsfHxuLnNldFdvcmtPcHRpb25zKHQpfWNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl7dmFyIG47Y29uc3R7dG9vbHNUeXBlOnQsd29ya0lkOnJ9PWU7cmV0dXJuIHQ9PT1kdC5TZWxlY3RvciYmcj09PWRyP2hyKHsuLi5lLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZnVsbExheWVyfSk6aHIoey4uLmUsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXJ9LChuPXRoaXMudGhyZWFkKT09bnVsbD92b2lkIDA6bi5zZXJ2aWNlV29yayl9c2V0VG9vbHNPcHQoZSl7dmFyIHQscjsoKHQ9dGhpcy50bXBPcHQpPT1udWxsP3ZvaWQgMDp0LnRvb2xzVHlwZSkhPT1lLnRvb2xzVHlwZSYmKHI9dGhpcy50bXBPcHQpIT1udWxsJiZyLnRvb2xzVHlwZSYmdGhpcy5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLHRoaXMudG1wT3B0PWUsdGhpcy50bXBXb3JrU2hhcGVOb2RlPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZShlKX1jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKXt2YXIgdDsodD10aGlzLmdldFdvcmtTaGFwZShlKSk9PW51bGx8fHQuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGUpLHRoaXMud29ya1NoYXBlU3RhdGUuZGVsZXRlKGUpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goZT0+ZS5jbGVhclRtcFBvaW50cygpKSx0aGlzLndvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndvcmtTaGFwZVN0YXRlLmNsZWFyKCl9c2V0RnVsbFdvcmsoZSl7Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOm59PWU7aWYodCYmciYmbil7Y29uc3QgaT10JiZ0aGlzLndvcmtTaGFwZXMuZ2V0KHQpfHx0aGlzLmNyZWF0ZVdvcmtTaGFwZU5vZGUoe3Rvb2xzT3B0OnIsdG9vbHNUeXBlOm4sd29ya0lkOnR9KTtyZXR1cm4gaT8oaS5zZXRXb3JrSWQodCksdGhpcy53b3JrU2hhcGVzLnNldCh0LGkpLGkpOnZvaWQgMH19fXZhciBQZz1adCxUZz1mdW5jdGlvbigpe3JldHVybiBQZy5EYXRlLm5vdygpfSxNZz1UZyxFZz0vXHMvO2Z1bmN0aW9uIEFnKHUpe2Zvcih2YXIgZT11Lmxlbmd0aDtlLS0mJkVnLnRlc3QodS5jaGFyQXQoZSkpOyk7cmV0dXJuIGV9dmFyIENnPUFnLFJnPUNnLElnPS9eXHMrLztmdW5jdGlvbiBMZyh1KXtyZXR1cm4gdSYmdS5zbGljZSgwLFJnKHUpKzEpLnJlcGxhY2UoSWcsIiIpfXZhciBEZz1MZyx3Zz1pZSxOZz1fdCxCZz0iW29iamVjdCBTeW1ib2xdIjtmdW5jdGlvbiBqZyh1KXtyZXR1cm4gdHlwZW9mIHU9PSJzeW1ib2wifHxOZyh1KSYmd2codSk9PUJnfXZhciBXZz1qZyxGZz1EZyxfbj1yZSxVZz1XZyx0aT1OYU4sJGc9L15bLStdMHhbMC05YS1mXSskL2ksemc9L14wYlswMV0rJC9pLEdnPS9eMG9bMC03XSskL2ksSGc9cGFyc2VJbnQ7ZnVuY3Rpb24gS2codSl7aWYodHlwZW9mIHU9PSJudW1iZXIiKXJldHVybiB1O2lmKFVnKHUpKXJldHVybiB0aTtpZihfbih1KSl7dmFyIGU9dHlwZW9mIHUudmFsdWVPZj09ImZ1bmN0aW9uIj91LnZhbHVlT2YoKTp1O3U9X24oZSk/ZSsiIjplfWlmKHR5cGVvZiB1IT0ic3RyaW5nIilyZXR1cm4gdT09PTA/dTordTt1PUZnKHUpO3ZhciB0PXpnLnRlc3QodSk7cmV0dXJuIHR8fEdnLnRlc3QodSk/SGcodS5zbGljZSgyKSx0PzI6OCk6JGcudGVzdCh1KT90aTordX12YXIgVmc9S2csWWc9cmUsZ3I9TWcsZWk9VmcsWGc9IkV4cGVjdGVkIGEgZnVuY3Rpb24iLFpnPU1hdGgubWF4LEpnPU1hdGgubWluO2Z1bmN0aW9uIFFnKHUsZSx0KXt2YXIgcixuLGksYSxsLHMsZj0wLHY9ITEsZD0hMSxwPSEwO2lmKHR5cGVvZiB1IT0iZnVuY3Rpb24iKXRocm93IG5ldyBUeXBlRXJyb3IoWGcpO2U9ZWkoZSl8fDAsWWcodCkmJih2PSEhdC5sZWFkaW5nLGQ9Im1heFdhaXQiaW4gdCxpPWQ/WmcoZWkodC5tYXhXYWl0KXx8MCxlKTppLHA9InRyYWlsaW5nImluIHQ/ISF0LnRyYWlsaW5nOnApO2Z1bmN0aW9uIHkoYil7dmFyIEU9cixBPW47cmV0dXJuIHI9bj12b2lkIDAsZj1iLGE9dS5hcHBseShBLEUpLGF9ZnVuY3Rpb24gUChiKXtyZXR1cm4gZj1iLGw9c2V0VGltZW91dChPLGUpLHY/eShiKTphfWZ1bmN0aW9uIHgoYil7dmFyIEU9Yi1zLEE9Yi1mLEw9ZS1FO3JldHVybiBkP0pnKEwsaS1BKTpMfWZ1bmN0aW9uIG0oYil7dmFyIEU9Yi1zLEE9Yi1mO3JldHVybiBzPT09dm9pZCAwfHxFPj1lfHxFPDB8fGQmJkE+PWl9ZnVuY3Rpb24gTygpe3ZhciBiPWdyKCk7aWYobShiKSlyZXR1cm4gbyhiKTtsPXNldFRpbWVvdXQoTyx4KGIpKX1mdW5jdGlvbiBvKGIpe3JldHVybiBsPXZvaWQgMCxwJiZyP3koYik6KHI9bj12b2lkIDAsYSl9ZnVuY3Rpb24gaCgpe2whPT12b2lkIDAmJmNsZWFyVGltZW91dChsKSxmPTAscj1zPW49bD12b2lkIDB9ZnVuY3Rpb24gYygpe3JldHVybiBsPT09dm9pZCAwP2E6byhncigpKX1mdW5jdGlvbiBnKCl7dmFyIGI9Z3IoKSxFPW0oYik7aWYocj1hcmd1bWVudHMsbj10aGlzLHM9YixFKXtpZihsPT09dm9pZCAwKXJldHVybiBQKHMpO2lmKGQpcmV0dXJuIGNsZWFyVGltZW91dChsKSxsPXNldFRpbWVvdXQoTyxlKSx5KHMpfXJldHVybiBsPT09dm9pZCAwJiYobD1zZXRUaW1lb3V0KE8sZSkpLGF9cmV0dXJuIGcuY2FuY2VsPWgsZy5mbHVzaD1jLGd9dmFyIGtnPVFnLHFnPWtnLF9nPXJlLHQwPSJFeHBlY3RlZCBhIGZ1bmN0aW9uIjtmdW5jdGlvbiBlMCh1LGUsdCl7dmFyIHI9ITAsbj0hMDtpZih0eXBlb2YgdSE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgVHlwZUVycm9yKHQwKTtyZXR1cm4gX2codCkmJihyPSJsZWFkaW5nImluIHQ/ISF0LmxlYWRpbmc6cixuPSJ0cmFpbGluZyJpbiB0PyEhdC50cmFpbGluZzpuKSxxZyh1LGUse2xlYWRpbmc6cixtYXhXYWl0OmUsdHJhaWxpbmc6bn0pfXZhciByMD1lMCxyaT1jZShyMCk7Y2xhc3MgbjAgZXh0ZW5kcyBxbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZVVuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6NjAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVUaW1lcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVmZmVjdFNlbGVjdE5vZGVEYXRhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVyYXNlcldvcmtzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVyYXNlclJlbW92ZU5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJiYXRjaEVmZmVjdFdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyaSh0PT57dGhpcy52Tm9kZXMuY3VyTm9kZU1hcC5zaXplJiYodGhpcy52Tm9kZXMudXBkYXRlTm9kZXNSZWN0KCksdGhpcy5yZVJlbmRlclNlbGVjdG9yKCkpLHQmJnQoKX0sMTAwLHtsZWFkaW5nOiExfSl9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYmF0Y2hFcmFzZXJDb21iaW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6cmkoKCk9Pntjb25zdCB0PXRoaXMudXBkYXRlQmF0Y2hFcmFzZXJDb21iaW5lTm9kZSh0aGlzLmJhdGNoRXJhc2VyV29ya3MsdGhpcy5iYXRjaEVyYXNlclJlbW92ZU5vZGVzKTt0aGlzLmJhdGNoRXJhc2VyV29ya3MuY2xlYXIoKSx0aGlzLmJhdGNoRXJhc2VyUmVtb3ZlTm9kZXMuY2xlYXIoKSx0Lmxlbmd0aCYmdGhpcy5fcG9zdCh7cmVuZGVyOnR9KX0sMTAwLHtsZWFkaW5nOiExfSl9KX1jb25zdW1lRHJhdyhlLHQpe2NvbnN0e29wOnIsd29ya0lkOm59PWU7aWYociE9bnVsbCYmci5sZW5ndGgmJm4pe2NvbnN0IGk9dGhpcy53b3JrU2hhcGVzLmdldChuKTtpZighaSlyZXR1cm47Y29uc3QgYT1pLnRvb2xzVHlwZTtpZihhPT09ZHQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IGw9aS5jb25zdW1lKHtkYXRhOmUsaXNGdWxsV29yazohMH0pO3N3aXRjaChhKXtjYXNlIGR0LlNlbGVjdG9yOmwudHlwZT09PWF0LlNlbGVjdCYmKGwuc2VsZWN0SWRzJiZ0LnJ1blJldmVyc2VTZWxlY3RXb3JrKGwuc2VsZWN0SWRzKSx0aGlzLmRyYXdTZWxlY3RvcihsLCEwKSk7YnJlYWs7Y2FzZSBkdC5FcmFzZXI6bCE9bnVsbCYmbC5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIobCk7YnJlYWs7Y2FzZSBkdC5BcnJvdzpjYXNlIGR0LlN0cmFpZ2h0OmNhc2UgZHQuRWxsaXBzZTpjYXNlIGR0LlJlY3RhbmdsZTpjYXNlIGR0LlN0YXI6Y2FzZSBkdC5Qb2x5Z29uOmNhc2UgZHQuU3BlZWNoQmFsbG9vbjpsJiYodGhpcy5kcmF3Q291bnQrKyx0aGlzLmRyYXdQZW5jaWwobCkpO2JyZWFrO2Nhc2UgZHQuUGVuY2lsOnRoaXMuY29tYmluZVRpbWVySWR8fCh0aGlzLmNvbWJpbmVUaW1lcklkPXNldFRpbWVvdXQoKCk9Pnt0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCx0aGlzLmRyYXdQZW5jaWxDb21iaW5lKG4pfSxNYXRoLmZsb29yKGkuZ2V0V29ya09wdGlvbnMoKS5zeW5jVW5pdFRpbWV8fHRoaXMuY29tYmluZVVuaXRUaW1lLzIpKSksbCYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3UGVuY2lsKGwpKTticmVha319fWNvbnN1bWVEcmF3QWxsKGUsdCl7dmFyIGksYSxsO3RoaXMuY29tYmluZVRpbWVySWQmJihjbGVhclRpbWVvdXQodGhpcy5jb21iaW5lVGltZXJJZCksdGhpcy5jb21iaW5lVGltZXJJZD12b2lkIDApO2NvbnN0e3dvcmtJZDpyLHVuZG9UaWNrZXJJZDpufT1lO2lmKHIpe24mJnNldFRpbWVvdXQoKCk9Pnt0aGlzLl9wb3N0KHtzcDpbe3R5cGU6YXQuTm9uZSx1bmRvVGlja2VySWQ6bn1dfSl9LDApO2NvbnN0IHM9dGhpcy53b3JrU2hhcGVzLmdldChyKTtpZighcylyZXR1cm47Y29uc3QgZj1zLnRvb2xzVHlwZTtpZihmPT09ZHQuTGFzZXJQZW4pcmV0dXJuO2NvbnN0IHY9dGhpcy53b3JrU2hhcGVzLmdldChkciksZD0oaT12PT1udWxsP3ZvaWQgMDp2LnNlbGVjdElkcyk9PW51bGw/dm9pZCAwOmlbMF0scD1zLmNvbnN1bWVBbGwoe2RhdGE6ZSxob3ZlcklkOmR9KSx5PXRoaXMud29ya1NoYXBlU3RhdGUuZ2V0KHIpO3N3aXRjaChmKXtjYXNlIGR0LlNlbGVjdG9yOnAuc2VsZWN0SWRzJiZkJiYoKGE9cC5zZWxlY3RJZHMpIT1udWxsJiZhLmluY2x1ZGVzKGQpKSYmdi5jdXJzb3JCbHVyKCkscC5zZWxlY3RJZHMmJnQucnVuUmV2ZXJzZVNlbGVjdFdvcmsocC5zZWxlY3RJZHMpLHRoaXMuZHJhd1NlbGVjdG9yKHAsITEpLChsPXMuc2VsZWN0SWRzKSE9bnVsbCYmbC5sZW5ndGg/cy5jbGVhclRtcFBvaW50cygpOnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUocik7YnJlYWs7Y2FzZSBkdC5FcmFzZXI6cCE9bnVsbCYmcC5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIocCkscy5jbGVhclRtcFBvaW50cygpO2JyZWFrO2Nhc2UgZHQuQXJyb3c6Y2FzZSBkdC5TdHJhaWdodDpjYXNlIGR0LkVsbGlwc2U6Y2FzZSBkdC5SZWN0YW5nbGU6Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUG9seWdvbjpjYXNlIGR0LlNwZWVjaEJhbGxvb246dGhpcy5kcmF3UGVuY2lsRnVsbChwLHMuZ2V0V29ya09wdGlvbnMoKSx5KSx0aGlzLmRyYXdDb3VudD0wLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUocik7YnJlYWs7Y2FzZSBkdC5QZW5jaWw6cCE9bnVsbCYmcC5yZWN0JiYodGhpcy5kcmF3UGVuY2lsRnVsbChwLHMuZ2V0V29ya09wdGlvbnMoKSx5KSx0aGlzLmRyYXdDb3VudD0wKSx0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHIpO2JyZWFrfX19YXN5bmMgY29uc3VtZUZ1bGwoZSx0KXt2YXIgYSxsO2NvbnN0IHI9dGhpcy5zZXRGdWxsV29yayhlKSxuPWUub3BzJiZ6ZShlLm9wcyksaT0oYT1lLndvcmtJZCk9PW51bGw/dm9pZCAwOmEudG9TdHJpbmcoKTtpZihpJiZyKXtjb25zdCBzPShsPXRoaXMudk5vZGVzLmdldChpKSk9PW51bGw/dm9pZCAwOmwucmVjdDtsZXQgZjtyLnRvb2xzVHlwZT09PWR0LkltYWdlJiZ0P2Y9YXdhaXQgci5jb25zdW1lU2VydmljZUFzeW5jKHtzY2VuZTp0LGlzRnVsbFdvcms6ITAscmVwbGFjZUlkOml9KTpmPXIuY29uc3VtZVNlcnZpY2Uoe29wOm4saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6aX0pO2NvbnN0IHY9KGU9PW51bGw/dm9pZCAwOmUudXBkYXRlTm9kZU9wdCkmJnIudXBkYXRhT3B0U2VydmljZShlLnVwZGF0ZU5vZGVPcHQpO2Y9YnQoZix2KTtjb25zdCBkPVtdLHA9W107aWYoZiYmZS53aWxsUmVmcmVzaCYmKHMmJmQucHVzaCh7cmVjdDpmLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxkLnB1c2goe3JlY3Q6ZixkcmF3Q2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSkpLGUud2lsbFN5bmNTZXJ2aWNlJiZwLnB1c2goe29wdDplLm9wdCx0b29sc1R5cGU6ZS50b29sc1R5cGUsdHlwZTphdC5GdWxsV29yayx3b3JrSWQ6ZS53b3JrSWQsb3BzOmUub3BzLHVwZGF0ZU5vZGVPcHQ6ZS51cGRhdGVOb2RlT3B0LHVuZG9UaWNrZXJJZDplLnVuZG9UaWNrZXJJZCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxkLmxlbmd0aHx8cC5sZW5ndGgpe2NvbnN0IHk9e3JlbmRlcjpkLHNwOnB9O3RoaXMuX3Bvc3QoeSl9ZS53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoZS53b3JrSWQpfX1yZW1vdmVXb3JrKGUpe2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO2lmKHIpe2NvbnN0IG49dGhpcy5yZW1vdmVOb2RlKHIpO24mJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6bixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eXQuQmcsZHJhd0NhbnZhczp5dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9XX0pfX1yZW1vdmVOb2RlKGUpe3ZhciBuO3RoaXMud29ya1NoYXBlcy5oYXMoZSkmJnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoZSk7bGV0IHQ7Y29uc3Qgcj10aGlzLnZOb2Rlcy5nZXQoZSk7cmV0dXJuIHImJih0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5jb25jYXQoKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5nZXRFbGVtZW50c0J5TmFtZShlKSl8fFtdKS5mb3JFYWNoKGk9PntpLnJlbW92ZSgpfSksdD1idCh0LHIucmVjdCksdGhpcy52Tm9kZXMuZGVsZXRlKGUpKSx0fWFzeW5jIGNoZWNrVGV4dEFjdGl2ZShlKXtjb25zdHtvcDp0LHZpZXdJZDpyLGRhdGFUeXBlOm59PWU7aWYodCE9bnVsbCYmdC5sZW5ndGgpe2xldCBpO2Zvcihjb25zdCBhIG9mIHRoaXMudk5vZGVzLmN1ck5vZGVNYXAudmFsdWVzKCkpe2NvbnN0e3JlY3Q6bCxuYW1lOnMsdG9vbHNUeXBlOmYsb3B0OnZ9PWE7Y29uc29sZS5sb2coImNoZWNrVGV4dEFjdGl2ZSIscyx2KTtjb25zdCBkPXRbMF0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0scD10WzFdKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdO2lmKGY9PT1kdC5UZXh0JiZXaChbZCxwXSxsKSYmdi53b3JrU3RhdGU9PT1SdC5Eb25lKXtpPXM7YnJlYWt9fWkmJihhd2FpdCB0aGlzLmJsdXJTZWxlY3Rvcih7dmlld0lkOnIsbXNnVHlwZTphdC5TZWxlY3QsZGF0YVR5cGU6bixpc1N5bmM6ITB9KSxjb25zb2xlLmxvZygiR2V0VGV4dEFjdGl2ZS0tLTAwMDEiKSxhd2FpdCB0aGlzLl9wb3N0KHtzcDpbe3R5cGU6YXQuR2V0VGV4dEFjdGl2ZSx0b29sc1R5cGU6ZHQuVGV4dCx3b3JrSWQ6aX1dfSkpfX1hc3luYyBjb2xsb2N0RWZmZWN0U2VsZWN0V29yayhlKXtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoSXQuc2VsZWN0b3JJZCkse3dvcmtJZDpyLG1zZ1R5cGU6bn09ZTtpZih0JiZyJiZ0LnNlbGVjdElkcyYmdC5zZWxlY3RJZHMuaW5jbHVkZXMoci50b1N0cmluZygpKSl7bj09PWF0LlJlbW92ZU5vZGU/dC5zZWxlY3RJZHM9dC5zZWxlY3RJZHMuZmlsdGVyKGk9PmkhPT1yLnRvU3RyaW5nKCkpOnRoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEuYWRkKGUpLGF3YWl0IG5ldyBQcm9taXNlKGk9PntzZXRUaW1lb3V0KCgpPT57aSghMCl9LDApfSksYXdhaXQgdGhpcy5ydW5FZmZlY3RTZWxlY3RXb3JrKCEwKS50aGVuKCgpPT57dmFyIGk7KGk9dGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YSk9PW51bGx8fGkuY2xlYXIoKX0pO3JldHVybn1yZXR1cm4gZX1hc3luYyB1cGRhdGVTZWxlY3RvcihlKXt2YXIgTztjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoSXQuc2VsZWN0b3JJZCk7aWYoISgoTz10PT1udWxsP3ZvaWQgMDp0LnNlbGVjdElkcykhPW51bGwmJk8ubGVuZ3RoKSlyZXR1cm47Y29uc3R7Y2FsbGJhY2s6ciwuLi5ufT1lLHt1cGRhdGVTZWxlY3Rvck9wdDppLHdpbGxSZWZyZXNoU2VsZWN0b3I6YSx3aWxsU2VyaWFsaXplRGF0YTpsLGVtaXRFdmVudFR5cGU6cyxzY2VuZTpmfT1uLHY9aS53b3JrU3RhdGUsZD1hd2FpdCh0PT1udWxsP3ZvaWQgMDp0LnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDppLHNlbGVjdElkczp0LnNlbGVjdElkcyx2Tm9kZXM6dGhpcy52Tm9kZXMsd2lsbFNlcmlhbGl6ZURhdGE6bCx3b3JrZXI6dGhpcyxzY2VuZTpmfSkpLHA9ZD09bnVsbD92b2lkIDA6ZC5zZWxlY3RSZWN0LHk9bmV3IE1hcDt0LnNlbGVjdElkcy5mb3JFYWNoKG89Pntjb25zdCBoPXRoaXMudk5vZGVzLmdldChvKTtpZihoKXtjb25zdHt0b29sc1R5cGU6YyxvcDpnLG9wdDpifT1oO3kuc2V0KG8se29wdDpiLHRvb2xzVHlwZTpjLG9wczooZz09bnVsbD92b2lkIDA6Zy5sZW5ndGgpJiZxdChnKXx8dm9pZCAwfSl9fSk7Y29uc3QgUD1bXSx4PVtdO2lmKGEpe1AucHVzaCh7aXNDbGVhckFsbDohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOnl0LlNlbGVjdG9yLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2NvbnN0IG89e3JlY3Q6cCxpc0Z1bGxXb3JrOiExLGRyYXdDYW52YXM6eXQuU2VsZWN0b3Isdmlld0lkOnRoaXMudmlld0lkfTtpLnRyYW5zbGF0ZSYmcz09PUN0LlRyYW5zbGF0ZU5vZGUmJnY9PT1SdC5Eb2luZyYmKG8udHJhbnNsYXRlPWkudHJhbnNsYXRlKSxQLnB1c2gobyl9Y29uc3QgbT1yJiZyKHtyZXM6ZCx3b3JrU2hhcGVOb2RlOnQscGFyYW06bixwb3N0RGF0YTp7cmVuZGVyOlAsc3A6eH0sbmV3U2VydmljZVN0b3JlOnl9KXx8e3JlbmRlcjpQLHNwOnh9OyhtLnJlbmRlci5sZW5ndGh8fG0uc3AubGVuZ3RoKSYmdGhpcy5fcG9zdChtKX1hc3luYyBibHVyU2VsZWN0b3IoZSl7dmFyIG47Y29uc3QgdD10aGlzLndvcmtTaGFwZXMuZ2V0KEl0LnNlbGVjdG9ySWQpLHI9dD09bnVsbD92b2lkIDA6dC5ibHVyU2VsZWN0b3IoKTtpZih0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKEl0LnNlbGVjdG9ySWQpLCgobj10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOm4ucGFyZW50KS5jaGlsZHJlbi5mb3JFYWNoKGk9PntpLm5hbWU9PT1JdC5zZWxlY3RvcklkJiZpLnJlbW92ZSgpfSkscil7Y29uc3QgaT1bXTtpLnB1c2goey4uLnIsdW5kb1RpY2tlcklkOmU9PW51bGw/dm9pZCAwOmUudW5kb1RpY2tlcklkLGlzU3luYzplPT1udWxsP3ZvaWQgMDplLmlzU3luY30pLGF3YWl0IHRoaXMuX3Bvc3Qoe3JlbmRlcjoocj09bnVsbD92b2lkIDA6ci5yZWN0KSYmW3tyZWN0OnIucmVjdCxkcmF3Q2FudmFzOnl0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDppfSl9fXJ1bkVmZmVjdFdvcmsoZSl7dGhpcy5iYXRjaEVmZmVjdFdvcmsoZSl9cmVSZW5kZXJTZWxlY3RvcihlPSExKXt2YXIgcjtjb25zdCB0PXRoaXMud29ya1NoYXBlcy5nZXQoSXQuc2VsZWN0b3JJZCk7aWYodCl7aWYodCYmISgocj10LnNlbGVjdElkcykhPW51bGwmJnIubGVuZ3RoKSlyZXR1cm4gdGhpcy5ibHVyU2VsZWN0b3IoKTtpZih0aGlzLmRyYXdMYXllcil7Y29uc3Qgbj10LnJlUmVuZGVyU2VsZWN0b3IoKTtuJiZ0aGlzLl9wb3N0KHtyZW5kZXI6W3tyZWN0Om4saXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOnl0LlNlbGVjdG9yLGRyYXdDYW52YXM6eXQuU2VsZWN0b3Isdmlld0lkOnRoaXMudmlld0lkfV0sc3A6W3t0eXBlOmF0LlNlbGVjdCxzZWxlY3RJZHM6dC5zZWxlY3RJZHMsc2VsZWN0UmVjdDpuLHdpbGxTeW5jU2VydmljZTplLHZpZXdJZDp0aGlzLnZpZXdJZCxwb2ludHM6dC5nZXRDaGlsZHJlblBvaW50cygpLHRleHRPcHQ6dC50ZXh0T3B0fV19KX19fXVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpe3ZhciBuLGksYSxsLHMsZix2LGQscCx5O2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldChJdC5zZWxlY3RvcklkKSx7c2VsZWN0SWRzOnJ9PWU7aWYoIShyIT1udWxsJiZyLmxlbmd0aCkpe3RoaXMuYmx1clNlbGVjdG9yKGUpO3JldHVybn1pZighdCl7dGhpcy5zZXRGdWxsV29yayhlKSx0aGlzLnVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpO3JldHVybn1pZih0JiYociE9bnVsbCYmci5sZW5ndGgpKXtjb25zdHtiZ1JlY3Q6UCxzZWxlY3RSZWN0Onh9PXQudXBkYXRlU2VsZWN0SWRzKHIpO2NvbnNvbGUubG9nKCJ1cGRhdGVGdWxsU2VsZWN0V29yayIscixQLHgsKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5wYXJlbnQpLmNoaWxkcmVuLm1hcChPPT5PLm5hbWUpKTtjb25zdCBtPXtyZW5kZXI6W10sc3A6W119O1AmJigoaT1tLnJlbmRlcik9PW51bGx8fGkucHVzaCh7cmVjdDpWdChQKSxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6eXQuQmcsZHJhd0NhbnZhczp5dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KSksKGE9bS5yZW5kZXIpPT1udWxsfHxhLnB1c2goe3JlY3Q6eCxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6eXQuU2VsZWN0b3IsZHJhd0NhbnZhczp5dC5TZWxlY3Rvcix2aWV3SWQ6dGhpcy52aWV3SWR9KSwoZD1tLnNwKT09bnVsbHx8ZC5wdXNoKHsuLi5lLHNlbGVjdG9yQ29sb3I6KGw9ZS5vcHQpPT1udWxsP3ZvaWQgMDpsLnN0cm9rZUNvbG9yLHN0cm9rZUNvbG9yOihzPWUub3B0KT09bnVsbD92b2lkIDA6cy5zdHJva2VDb2xvcixmaWxsQ29sb3I6KGY9ZS5vcHQpPT1udWxsP3ZvaWQgMDpmLmZpbGxDb2xvcix0ZXh0T3B0Oih2PWUub3B0KT09bnVsbD92b2lkIDA6di50ZXh0T3B0LGNhblRleHRFZGl0OnQuY2FuVGV4dEVkaXQsY2FuUm90YXRlOnQuY2FuUm90YXRlLHNjYWxlVHlwZTp0LnNjYWxlVHlwZSx0eXBlOmF0LlNlbGVjdCxzZWxlY3RSZWN0Ongsd2lsbFN5bmNTZXJ2aWNlOiExLHBvaW50czp0LmdldENoaWxkcmVuUG9pbnRzKCl9KSxjb25zb2xlLmxvZygidXBkYXRlRnVsbFNlbGVjdFdvcmstLS0wMSIsbSx0aGlzLnZOb2Rlcy5jdXJOb2RlTWFwLChwPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6cC5jaGlsZHJlbi5tYXAoTz0+Ty5uYW1lKSwoeT10aGlzLmZ1bGxMYXllcik9PW51bGw/dm9pZCAwOnkuY2hpbGRyZW4ubWFwKE89Pk8ubmFtZSkpLHRoaXMuX3Bvc3QobSl9fWRlc3Ryb3koKXtzdXBlci5kZXN0cm95KCksdGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YS5jbGVhcigpLHRoaXMuYmF0Y2hFcmFzZXJXb3Jrcy5jbGVhcigpLHRoaXMuYmF0Y2hFcmFzZXJSZW1vdmVOb2Rlcy5jbGVhcigpfWRyYXdQZW5jaWxDb21iaW5lKGUpe3ZhciByLG47Y29uc3QgdD0ocj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6ci5jb21iaW5lQ29uc3VtZSgpO2lmKHQpe2NvbnN0IGk9e3JlbmRlcjpbXSxkcmF3Q291bnQ6dGhpcy5kcmF3Q291bnR9OyhuPWkucmVuZGVyKT09bnVsbHx8bi5wdXNoKHtyZWN0Oih0PT1udWxsP3ZvaWQgMDp0LnJlY3QpJiZWdCh0LnJlY3QpLGlzQ2xlYXI6ITAsZHJhd0NhbnZhczp5dC5GbG9hdCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMuX3Bvc3QoaSl9fWRyYXdTZWxlY3RvcihlLHQpe3ZhciBuLGk7Y29uc3Qgcj17cmVuZGVyOltdLHNwOltlXX07ZS50eXBlPT09YXQuU2VsZWN0JiYhdCYmKChuPXIucmVuZGVyKT09bnVsbHx8bi5wdXNoKHtyZWN0OmUuc2VsZWN0UmVjdCxkcmF3Q2FudmFzOnl0LlNlbGVjdG9yLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuU2VsZWN0b3IsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9LHtyZWN0OmUucmVjdCYmVnQoZS5yZWN0KSxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSx7cmVjdDplLnJlY3QmJlZ0KGUucmVjdCksZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSkpLHQmJigoaT1yLnJlbmRlcik9PW51bGx8fGkucHVzaCh7cmVjdDplLnJlY3QmJlZ0KGUucmVjdCksZHJhd0NhbnZhczp5dC5GbG9hdCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfSx7cmVjdDplLnJlY3QmJlZ0KGUucmVjdCksZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSkpLHRoaXMuX3Bvc3Qocil9YXN5bmMgZHJhd0VyYXNlcihlKXt2YXIgcixuO2NvbnN0IHQ9W107aWYoKHI9ZS5uZXdXb3JrRGF0YXMpIT1udWxsJiZyLnNpemUpe2Zvcihjb25zdCBpIG9mIGUubmV3V29ya0RhdGFzLnZhbHVlcygpKXtjb25zdCBhPWkud29ya0lkLnRvU3RyaW5nKCk7dGhpcy5iYXRjaEVyYXNlcldvcmtzLmFkZChhKSx0LnB1c2goe3R5cGU6YXQuRnVsbFdvcmssd29ya0lkOmEsb3BzOnF0KGkub3ApLG9wdDppLm9wdCx0b29sc1R5cGU6aS50b29sc1R5cGUsdXBkYXRlTm9kZU9wdDp7dXNlQW5pbWF0aW9uOiExfX0pfWRlbGV0ZSBlLm5ld1dvcmtEYXRhc30obj1lLnJlbW92ZUlkcyk9PW51bGx8fG4uZm9yRWFjaChpPT57dGhpcy5iYXRjaEVyYXNlclJlbW92ZU5vZGVzLmFkZChpKX0pLHQucHVzaChlKSx0aGlzLl9wb3N0KHtzcDp0fSksdGhpcy5iYXRjaEVyYXNlckNvbWJpbmUoKX1kcmF3UGVuY2lsKGUpe3RoaXMuX3Bvc3Qoe2RyYXdDb3VudDp0aGlzLmRyYXdDb3VudCxzcDooZT09bnVsbD92b2lkIDA6ZS5vcCkmJltlXX0pfWRyYXdQZW5jaWxGdWxsKGUsdCxyKXt2YXIgaTtjb25zdCBuPXtkcmF3Q291bnQ6MS8wLHJlbmRlcjpbe3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjoocj09bnVsbD92b2lkIDA6ci53aWxsQ2xlYXIpfHwodD09bnVsbD92b2lkIDA6dC5pc09wYWNpdHkpLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfV0sc3A6W2VdfTsoaT1uLnJlbmRlcik9PW51bGx8fGkucHVzaCh7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMuX3Bvc3Qobil9dXBkYXRlQmF0Y2hFcmFzZXJDb21iaW5lTm9kZShlLHQpe2NvbnN0IHI9W107bGV0IG47Zm9yKGNvbnN0IGkgb2YgdC5rZXlzKCkpdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoaSkuZm9yRWFjaChhPT57Y29uc3QgbD1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO249YnQobix7eDpsLngtSnQuU2FmZUJvcmRlclBhZGRpbmcseTpsLnktSnQuU2FmZUJvcmRlclBhZGRpbmcsdzpsLndpZHRoK0p0LlNhZmVCb3JkZXJQYWRkaW5nLGg6bC5oZWlnaHQrSnQuU2FmZUJvcmRlclBhZGRpbmd9KSxhLnJlbW92ZSgpfSk7cmV0dXJuIGUuZm9yRWFjaChpPT57Y29uc3QgYT10aGlzLnZOb2Rlcy5nZXQoaSk7aWYoYSlpZih0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShpKVswXSluPWJ0KG4sYS5yZWN0KTtlbHNle2NvbnN0IHM9dGhpcy5zZXRGdWxsV29yayh7Li4uYSx3b3JrSWQ6aX0pLGY9cyYmcy5jb25zdW1lU2VydmljZSh7b3A6YS5vcCxpc0Z1bGxXb3JrOiEwfSk7ZiYmKGEucmVjdD1mLG49YnQobixmKSl9fSksbiYmci5wdXNoKHtyZWN0Om4saXNDbGVhcjohMCxpc0Z1bGxXb3JrOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGRyYXdDYW52YXM6eXQuQmcsdmlld0lkOnRoaXMudmlld0lkfSkscn1hc3luYyBydW5FZmZlY3RTZWxlY3RXb3JrKGUpe3ZhciB0LHIsbixpO2Zvcihjb25zdCBhIG9mIHRoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEudmFsdWVzKCkpe2NvbnN0IGw9dGhpcy5zZXRGdWxsV29yayhhKTtpZihsKXtpZihsLnRvb2xzVHlwZT09PWR0LkltYWdlKWF3YWl0IGwuY29uc3VtZVNlcnZpY2VBc3luYyh7c2NlbmU6KHI9KHQ9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDp0LnBhcmVudCk9PW51bGw/dm9pZCAwOnIucGFyZW50LGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihuPWwuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCl9KTtlbHNle2NvbnN0IHM9YS5vcHMmJnplKGEub3BzKTtsLmNvbnN1bWVTZXJ2aWNlKHtvcDpzLGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihpPWwuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDppLnRvU3RyaW5nKCl9KX1hIT1udWxsJiZhLnVwZGF0ZU5vZGVPcHQmJmwudXBkYXRhT3B0U2VydmljZShhLnVwZGF0ZU5vZGVPcHQpLGEud29ya0lkJiZ0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGEud29ya0lkKX19dGhpcy5yZVJlbmRlclNlbGVjdG9yKGUpfWN1cnNvckhvdmVyKGUpe3ZhciBhO2NvbnN0e29wdDp0LHRvb2xzVHlwZTpyLHBvaW50Om59PWUsaT10aGlzLnNldEZ1bGxXb3JrKHt3b3JrSWQ6ZHIsdG9vbHNUeXBlOnIsb3B0OnR9KTtpZihpJiZuKXtjb25zdCBsPWkuY3Vyc29ySG92ZXIobikscz17cmVuZGVyOltdfTtsJiZsLnR5cGU9PT1hdC5DdXJzb3JIb3ZlciYmKChhPXMucmVuZGVyKT09bnVsbHx8YS5wdXNoKHtyZWN0OmwucmVjdCYmVnQobC5yZWN0KSxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGRyYXdDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9KSx0aGlzLl9wb3N0KHMpKX19fWNsYXNzIGkwe2NvbnN0cnVjdG9yKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2aWV3SWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidk5vZGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VsZWN0b3JXb3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25JZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgU2V0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJ1bkVmZmVjdElkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm5vQW5pbWF0aW9uUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy52aWV3SWQ9ZS52aWV3SWQsdGhpcy52Tm9kZXM9ZS52Tm9kZXMsdGhpcy5mdWxsTGF5ZXI9ZS5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXI9ZS5kcmF3TGF5ZXIsdGhpcy5wb3N0PWUucG9zdH1kZXN0cm95KCl7dGhpcy53b3JrU2hhcGVzLmNsZWFyKCksdGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuY2xlYXIoKSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5jbGVhcigpfWNvbnN1bWVEcmF3KGUpe3RoaXMuYWN0aXZlV29ya1NoYXBlKGUpLHRoaXMucnVuQW5pbWF0aW9uKCl9Y29uc3VtZUZ1bGwoZSl7dGhpcy5hY3RpdmVXb3JrU2hhcGUoZSksdGhpcy5ydW5BbmltYXRpb24oKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKChlLHQpPT57ZS50b29sc1R5cGU9PT1kdC5MYXNlclBlbj9zZXRUaW1lb3V0KCgpPT57dGhpcy53b3JrU2hhcGVzLmRlbGV0ZSh0KX0sMmUzKTp0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQpfSl9cnVuU2VsZWN0V29yayhlKXt0aGlzLmFjdGl2ZVNlbGVjdG9yU2hhcGUoZSk7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7ciYmdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKHIpLHRoaXMucnVuRWZmZWN0KCl9c2V0Tm9kZUtleShlLHQscil7cmV0dXJuIGUudG9vbHNUeXBlPXQsZS5ub2RlPWhyKHt0b29sc1R5cGU6dCx0b29sc09wdDpyLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZHJhd0xheWVyfSx0aGlzKSxlfXJ1blJldmVyc2VTZWxlY3RXb3JrKGUpe2UuZm9yRWFjaCh0PT57dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocixuKT0+e3ZhciBpO2lmKChpPXIuc2VsZWN0SWRzKSE9bnVsbCYmaS5sZW5ndGgpe2NvbnN0IGE9ci5zZWxlY3RJZHMuaW5kZXhPZih0KTthPi0xJiYoci5zZWxlY3RJZHMuc3BsaWNlKGEsMSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKG4pKX19KX0pLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLnNpemUmJnRoaXMucnVuRWZmZWN0KCl9cmVtb3ZlV29yayhlKXtjb25zdHt3b3JrSWQ6dH09ZSxyPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtpZihyKXtjb25zdCBuPXRoaXMud29ya1NoYXBlcy5nZXQocik7aWYobil7dGhpcy53b3JrU2hhcGVzLmRlbGV0ZShyKSx0aGlzLnJlbW92ZU5vZGUocixlLG49PW51bGw/dm9pZCAwOm4udG90YWxSZWN0LCExKTtyZXR1cm59dGhpcy5yZW1vdmVOb2RlKHIsZSl9fXJlbW92ZVNlbGVjdFdvcmsoZSl7Y29uc3R7d29ya0lkOnR9PWUscj10PT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCk7ciYmKHRoaXMuYWN0aXZlU2VsZWN0b3JTaGFwZShlKSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQocikpLHRoaXMucnVuRWZmZWN0KCl9cmVtb3ZlTm9kZShlLHQscixuPSEwKXt2YXIgZjtjb25zdCBpPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmNvbmNhdCh0aGlzLmRyYXdMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKSk7ZS5pbmRleE9mKEl0LnNlbGVjdG9ySWQpPi0xJiZ0aGlzLnJlbW92ZVNlbGVjdFdvcmsodCk7Y29uc3QgYT1bXTtsZXQgbD1yO2NvbnN0IHM9KGY9dGhpcy52Tm9kZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6Zi5yZWN0O3MmJihsPWJ0KHMsbCkpLGkuZm9yRWFjaCh2PT57YS5wdXNoKHYpfSksYS5sZW5ndGgmJmEuZm9yRWFjaCh2PT52LnJlbW92ZSgpKSxsJiYodGhpcy5wb3N0KHtyZW5kZXI6W3tyZWN0OlZ0KGwpLGlzQ2xlYXI6ITAsaXNGdWxsV29yazpuLGNsZWFyQ2FudmFzOm4/eXQuQmc6eXQuRmxvYXQsZHJhd0NhbnZhczpuP3l0LkJnOnl0LkZsb2F0LHZpZXdJZDp0aGlzLnZpZXdJZH1dfSksdGhpcy52Tm9kZXMuZGVsZXRlKGUpKX1hY3RpdmVXb3JrU2hhcGUoZSl7dmFyIHAseSxQLHg7Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOm4sdHlwZTppLHVwZGF0ZU5vZGVPcHQ6YSxvcHM6bCxvcDpzLHVzZUFuaW1hdGlvbjpmfT1lO2lmKCF0KXJldHVybjtjb25zdCB2PXQudG9TdHJpbmcoKTtpZighKChwPXRoaXMud29ya1NoYXBlcykhPW51bGwmJnAuaGFzKHYpKSl7bGV0IG09e3Rvb2xzVHlwZTpuLGFuaW1hdGlvbldvcmtEYXRhOnN8fFtdLGFuaW1hdGlvbkluZGV4OjAsdHlwZTppLHVwZGF0ZU5vZGVPcHQ6YSxvcHM6bCx1c2VBbmltYXRpb246dHlwZW9mIGY8InUiP2Y6dHlwZW9mKGE9PW51bGw/dm9pZCAwOmEudXNlQW5pbWF0aW9uKTwidSI/YT09bnVsbD92b2lkIDA6YS51c2VBbmltYXRpb246ITAsb2xkUmVjdDooeT10aGlzLnZOb2Rlcy5nZXQodikpPT1udWxsP3ZvaWQgMDp5LnJlY3QsaXNEaWZmOiExfTtuJiZyJiYobT10aGlzLnNldE5vZGVLZXkobSxuLHIpKSwoUD10aGlzLndvcmtTaGFwZXMpPT1udWxsfHxQLnNldCh2LG0pfWNvbnN0IGQ9KHg9dGhpcy53b3JrU2hhcGVzKT09bnVsbD92b2lkIDA6eC5nZXQodik7aSYmKGQudHlwZT1pKSxsJiYoZC5hbmltYXRpb25Xb3JrRGF0YT16ZShsKSxkLm9wcz1sKSxhJiYoZC51cGRhdGVOb2RlT3B0PWEpLHMmJihkLmlzRGlmZj10aGlzLmhhc0RpZmZEYXRhKGQuYW5pbWF0aW9uV29ya0RhdGF8fFtdLHMsZC50b29sc1R5cGUpLGQuYW5pbWF0aW9uV29ya0RhdGE9cyksZC5ub2RlJiZkLm5vZGUuZ2V0V29ya0lkKCkhPT12JiZkLm5vZGUuc2V0V29ya0lkKHYpLG4mJnImJihkLnRvb2xzVHlwZSE9PW4mJm4mJnImJnRoaXMuc2V0Tm9kZUtleShkLG4sciksZC5ub2RlJiZkLm5vZGUuc2V0V29ya09wdGlvbnMocikpfWhhc0RpZmZEYXRhKGUsdCxyKXtjb25zdCBuPWUubGVuZ3RoO2lmKHQubGVuZ3RoPG4pcmV0dXJuITA7c3dpdGNoKHIpe2Nhc2UgZHQuUGVuY2lsOntmb3IobGV0IGk9MDtpPG47aSs9MylpZih0W2ldIT09ZVtpXXx8dFtpKzFdIT09ZVtpKzFdKXJldHVybiEwO2JyZWFrfWNhc2UgZHQuTGFzZXJQZW46e2ZvcihsZXQgaT0wO2k8bjtpKz0yKWlmKHRbaV0hPT1lW2ldfHx0W2krMV0hPT1lW2krMV0pcmV0dXJuITA7YnJlYWt9fXJldHVybiExfWFzeW5jIGFuaW1hdGlvbkRyYXcoKXt2YXIgcyxmLHYsZCxwLHksUCx4LG0sTyxvLGgsYyxnLGIsRSxBLEwsTSxJLEQsUixDLEIseixLLFEsXyxGLEc7dGhpcy5hbmltYXRpb25JZD12b2lkIDA7bGV0IGU9ITE7Y29uc3QgdD1uZXcgTWFwLHI9W10sbj1bXSxpPVtdLGE9W107Zm9yKGNvbnN0W1gsWl1vZiB0aGlzLndvcmtTaGFwZXMuZW50cmllcygpKXN3aXRjaChaLnRvb2xzVHlwZSl7Y2FzZSBkdC5JbWFnZTp7Y29uc3QgdHQ9Wi5vbGRSZWN0O3R0JiZpLnB1c2goe3JlY3Q6dHQsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5CZyx2aWV3SWQ6dGhpcy52aWV3SWR9KTtjb25zdCBudD1hd2FpdCgoZj1aLm5vZGUpPT1udWxsP3ZvaWQgMDpmLmNvbnN1bWVTZXJ2aWNlQXN5bmMoe2lzRnVsbFdvcms6ITAsc2NlbmU6KHM9dGhpcy5mdWxsTGF5ZXIucGFyZW50KT09bnVsbD92b2lkIDA6cy5wYXJlbnR9KSk7dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocSxodCk9Pnt2YXIgdXQ7KHV0PXEuc2VsZWN0SWRzKSE9bnVsbCYmdXQuaW5jbHVkZXMoWCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaHQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHR0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxudCksdGhpcy5ydW5FZmZlY3QoKSl9KSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKFgpLHIucHVzaCh7cmVjdDpudCxkcmF3Q2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfSk7YnJlYWt9Y2FzZSBkdC5UZXh0OntpZihaLm5vZGUpe2NvbnN0IHR0PVoub2xkUmVjdCxudD0odj1aLm5vZGUpPT1udWxsP3ZvaWQgMDp2LmNvbnN1bWVTZXJ2aWNlKHtvcDpaLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwfSk7dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocSxodCk9Pnt2YXIgdXQ7KHV0PXEuc2VsZWN0SWRzKSE9bnVsbCYmdXQuaW5jbHVkZXMoWCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaHQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHR0KSx0aGlzLm5vQW5pbWF0aW9uUmVjdD1idCh0aGlzLm5vQW5pbWF0aW9uUmVjdCxudCksdGhpcy5ydW5FZmZlY3QoKSl9KSwoZD1aLm5vZGUpPT1udWxsfHxkLmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShYKX1icmVha31jYXNlIGR0LkFycm93OmNhc2UgZHQuU3RyYWlnaHQ6Y2FzZSBkdC5SZWN0YW5nbGU6Y2FzZSBkdC5FbGxpcHNlOmNhc2UgZHQuU3RhcjpjYXNlIGR0LlBvbHlnb246Y2FzZSBkdC5TcGVlY2hCYWxsb29uOntjb25zdCB0dD0hIVoub3BzO2lmKChwPVouYW5pbWF0aW9uV29ya0RhdGEpIT1udWxsJiZwLmxlbmd0aCl7Y29uc3QgbnQ9Wi5vbGRSZWN0LHE9Wi5ub2RlLm9sZFJlY3Q7bnQmJmkucHVzaCh7cmVjdDpudCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHEmJmEucHVzaCh7cmVjdDpxLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSk7Y29uc3QgaHQ9KHk9Wi5ub2RlKT09bnVsbD92b2lkIDA6eS5jb25zdW1lU2VydmljZSh7b3A6Wi5hbmltYXRpb25Xb3JrRGF0YSxpc0Z1bGxXb3JrOnR0fSk7dC5zZXQoWCx7d29ya1N0YXRlOm50P1oub3BzP1J0LkRvbmU6UnQuRG9pbmc6UnQuU3RhcnQsb3A6Wi5hbmltYXRpb25Xb3JrRGF0YS5maWx0ZXIoKHV0LGopPT57aWYoaiUzIT09MilyZXR1cm4hMH0pLnNsaWNlKC0yKX0pLHR0Pyh0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5mb3JFYWNoKCh1dCxqKT0+e3ZhciBXOyhXPXV0LnNlbGVjdElkcykhPW51bGwmJlcuaW5jbHVkZXMoWCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaiksdGhpcy5ub0FuaW1hdGlvblJlY3Q9YnQodGhpcy5ub0FuaW1hdGlvblJlY3QsbnQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHEpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LGh0KSx0aGlzLnJ1bkVmZmVjdCgpKX0pLChQPVoubm9kZSk9PW51bGx8fFAuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKFgpLHIucHVzaCh7cmVjdDpodCxkcmF3Q2FudmFzOnl0LkJnLGlzRnVsbFdvcms6dHQsdmlld0lkOnRoaXMudmlld0lkfSksdC5zZXQoWCx7d29ya1N0YXRlOlJ0LkRvbmUsb3A6Wi5hbmltYXRpb25Xb3JrRGF0YS5maWx0ZXIoKHV0LGopPT57aWYoaiUzIT09MilyZXR1cm4hMH0pLnNsaWNlKC0yKX0pKTpuLnB1c2goe3JlY3Q6aHQsZHJhd0NhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOnR0LHZpZXdJZDp0aGlzLnZpZXdJZH0pLFouYW5pbWF0aW9uV29ya0RhdGEubGVuZ3RoPTB9YnJlYWt9Y2FzZSBkdC5QZW5jaWw6e2lmKCFaLnVzZUFuaW1hdGlvbiYmWi5vcHMpe2xldCB0dD0oeD1aLm5vZGUpPT1udWxsP3ZvaWQgMDp4LmNvbnN1bWVTZXJ2aWNlKHtvcDpaLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDpYfSk7Y29uc3QgbnQ9KG09Wi5ub2RlKT09bnVsbD92b2lkIDA6bS51cGRhdGFPcHRTZXJ2aWNlKFoudXBkYXRlTm9kZU9wdCk7dHQ9YnQodHQsbnQpLGkucHVzaCh7cmVjdDpidChaLm9sZFJlY3QsdHQpLGNsZWFyQ2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHIucHVzaCh7cmVjdDpidChaLm9sZFJlY3QsdHQpLGRyYXdDYW52YXM6eXQuQmcsdmlld0lkOnRoaXMudmlld0lkfSksdGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZm9yRWFjaCgocSxodCk9Pnt2YXIgdXQ7KHV0PXEuc2VsZWN0SWRzKSE9bnVsbCYmdXQuaW5jbHVkZXMoWCkmJih0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQoaHQpLHRoaXMubm9BbmltYXRpb25SZWN0PWJ0KHRoaXMubm9BbmltYXRpb25SZWN0LHR0KSx0aGlzLnJ1bkVmZmVjdCgpKX0pLChPPVoubm9kZSk9PW51bGx8fE8uY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKFgpfWVsc2UgaWYoWi51c2VBbmltYXRpb24pe2NvbnN0IG50PXRoaXMuY29tcHV0TmV4dEFuaW1hdGlvbkluZGV4KFosMykscT1aLmlzRGlmZj8wOk1hdGgubWF4KDAsKFouYW5pbWF0aW9uSW5kZXh8fDApLTMpLGh0PShaLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkuc2xpY2UocSxudCk7aWYoWi5pc0RlbClaLmlzRGVsJiYoKEw9Wi5ub2RlKT09bnVsbHx8TC5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoWCkpO2Vsc2V7aWYoKFouYW5pbWF0aW9uSW5kZXh8fDApPG50fHxaLmlzRGlmZil7Y29uc3QgdXQ9KGg9Wi5ub2RlKT09bnVsbD92b2lkIDA6aC5jb25zdW1lU2VydmljZSh7b3A6aHQsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6KG89Wi5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6by50b1N0cmluZygpfSk7aWYobi5wdXNoKHtyZWN0OnV0LGRyYXdDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksWi5hbmltYXRpb25JbmRleD1udCxaLmlzRGlmZiYmKFouaXNEaWZmPSExKSxodC5sZW5ndGgpe2NvbnN0IGo9aHQuZmlsdGVyKChXLFYpPT57aWYoViUzIT09MilyZXR1cm4hMH0pLnNsaWNlKC0yKTt0LnNldChYLHt3b3JrU3RhdGU6cT09PTA/UnQuU3RhcnQ6bnQ9PT0oKGM9Wi5hbmltYXRpb25Xb3JrRGF0YSk9PW51bGw/dm9pZCAwOmMubGVuZ3RoKT9SdC5Eb25lOlJ0LkRvaW5nLG9wOmp9KX19ZWxzZSBpZihaLm9wcyl7Y29uc3QgdXQ9KGI9Wi5ub2RlKT09bnVsbD92b2lkIDA6Yi5jb25zdW1lU2VydmljZSh7b3A6Wi5hbmltYXRpb25Xb3JrRGF0YXx8W10saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KGc9Wi5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6Zy50b1N0cmluZygpfSk7Wi5pc0RlbD0hMCxhLnB1c2goe3JlY3Q6dXQsY2xlYXJDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksKEU9Wi5ub2RlKSE9bnVsbCYmRS5nZXRXb3JrT3B0aW9ucygpLmlzT3BhY2l0eSYmaS5wdXNoKHtyZWN0OnV0LGNsZWFyQ2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHIucHVzaCh7cmVjdDp1dCxkcmF3Q2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pLHRoaXMudk5vZGVzLnNldEluZm8oWCx7b3A6Wi5hbmltYXRpb25Xb3JrRGF0YSxvcHQ6KEE9Wi5ub2RlKT09bnVsbD92b2lkIDA6QS5nZXRXb3JrT3B0aW9ucygpLHRvb2xzVHlwZTpaLnRvb2xzVHlwZSxyZWN0OnV0fSksdC5zZXQoWCx7d29ya1N0YXRlOlJ0LkRvbmUsb3A6aHQuZmlsdGVyKChqLFcpPT57aWYoVyUzIT09MilyZXR1cm4hMH0pLnNsaWNlKC0yKX0pfWU9ITB9YnJlYWt9YnJlYWt9Y2FzZSBkdC5MYXNlclBlbjp7Y29uc3QgbnQ9dGhpcy5jb21wdXROZXh0QW5pbWF0aW9uSW5kZXgoWiwyKSxxPU1hdGgubWF4KDAsKFouYW5pbWF0aW9uSW5kZXh8fDApLTIpLGh0PShaLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkuc2xpY2UocSxudCk7aWYoWi5pc0RlbCl7aWYoWi5pc0RlbCl7Y29uc3QgdXQ9KEI9Wi5ub2RlKT09bnVsbD92b2lkIDA6Qi5jb25zdW1lU2VydmljZSh7b3A6W10saXNGdWxsV29yazohMX0pO1oudG90YWxSZWN0PWJ0KFoudG90YWxSZWN0LHV0KSxhLnB1c2goe3JlY3Q6Wi50b3RhbFJlY3QsY2xlYXJDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksbi5wdXNoKHtyZWN0OloudG90YWxSZWN0LGRyYXdDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSksKHo9Wi5ub2RlKT09bnVsbHx8ei5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoWCl9fWVsc2V7aWYoKFouYW5pbWF0aW9uSW5kZXh8fDApPG50KXtjb25zdCB1dD0oST1aLm5vZGUpPT1udWxsP3ZvaWQgMDpJLmNvbnN1bWVTZXJ2aWNlKHtvcDpodCxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDooTT1aLm5vZGUuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDpNLnRvU3RyaW5nKCl9KTtaLnRvdGFsUmVjdD1idChaLnRvdGFsUmVjdCx1dCksWi50aW1lciYmKGNsZWFyVGltZW91dChaLnRpbWVyKSxaLnRpbWVyPXZvaWQgMCksWi5hbmltYXRpb25JbmRleD1udCxodC5sZW5ndGgmJnQuc2V0KFgse3dvcmtTdGF0ZTpxPT09MD9SdC5TdGFydDpudD09PSgoRD1aLmFuaW1hdGlvbldvcmtEYXRhKT09bnVsbD92b2lkIDA6RC5sZW5ndGgpP1J0LkRvbmU6UnQuRG9pbmcsb3A6aHQuc2xpY2UoLTIpfSl9ZWxzZXtaLnRpbWVyfHwoWi50aW1lcj1zZXRUaW1lb3V0KCgpPT57Wi50aW1lcj12b2lkIDAsWi5pc0RlbD0hMCx0aGlzLnJ1bkFuaW1hdGlvbigpfSwoKFI9Wi5ub2RlKT09bnVsbD92b2lkIDA6Ui5nZXRXb3JrT3B0aW9ucygpKS5kdXJhdGlvbioxZTMrMTAwKSx0LnNldChYLHt3b3JrU3RhdGU6UnQuRG9uZSxvcDpbXX0pKTtjb25zdCB1dD0oQz1aLm5vZGUpPT1udWxsP3ZvaWQgMDpDLmNvbnN1bWVTZXJ2aWNlKHtvcDpbXSxpc0Z1bGxXb3JrOiExfSk7Wi50b3RhbFJlY3Q9YnQoWi50b3RhbFJlY3QsdXQpfWEucHVzaCh7cmVjdDpaLnRvdGFsUmVjdCxjbGVhckNhbnZhczp5dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxuLnB1c2goe3JlY3Q6Wi50b3RhbFJlY3QsZHJhd0NhbnZhczp5dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KSxlPSEwfWJyZWFrfX1lJiZ0aGlzLnJ1bkFuaW1hdGlvbigpO2NvbnN0IGw9e3JlbmRlcjpbXX07aWYoaS5sZW5ndGgpe2NvbnN0IFg9aS5yZWR1Y2UoKFosdHQpPT4odHQucmVjdCYmdHQuY2xlYXJDYW52YXM9PT15dC5CZyYmKFoucmVjdD1idChaLnJlY3QsdHQucmVjdCkpLFopLHtpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pO1gucmVjdCYmKFgucmVjdD1YLnJlY3QmJlZ0KFgucmVjdCksKEs9bC5yZW5kZXIpPT1udWxsfHxLLnB1c2goWCkpfWlmKGEubGVuZ3RoKXtjb25zdCBYPWEucmVkdWNlKChaLHR0KT0+KHR0LnJlY3QmJnR0LmNsZWFyQ2FudmFzPT09eXQuRmxvYXQmJihaLnJlY3Q9YnQoWi5yZWN0LHR0LnJlY3QpKSxaKSx7aXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5GbG9hdCx2aWV3SWQ6dGhpcy52aWV3SWR9KTtYLnJlY3QmJihYLnJlY3Q9WC5yZWN0JiZWdChYLnJlY3QpLChRPWwucmVuZGVyKT09bnVsbHx8US5wdXNoKFgpKX1pZihyLmxlbmd0aCl7Y29uc3QgWD1yLnJlZHVjZSgoWix0dCk9Pih0dC5yZWN0JiZ0dC5kcmF3Q2FudmFzPT09eXQuQmcmJihaLnJlY3Q9YnQoWi5yZWN0LHR0LnJlY3QpKSxaKSx7aXNGdWxsV29yazohMCxkcmF3Q2FudmFzOnl0LkJnLHZpZXdJZDp0aGlzLnZpZXdJZH0pO1gucmVjdCYmKFgucmVjdD1YLnJlY3QmJlZ0KFgucmVjdCksKF89bC5yZW5kZXIpPT1udWxsfHxfLnB1c2goWCkpfWlmKG4ubGVuZ3RoKXtjb25zdCBYPW4ucmVkdWNlKChaLHR0KT0+KHR0LnJlY3QmJnR0LmRyYXdDYW52YXM9PT15dC5GbG9hdCYmKFoucmVjdD1idChaLnJlY3QsdHQucmVjdCkpLFopLHtpc0Z1bGxXb3JrOiExLGRyYXdDYW52YXM6eXQuRmxvYXQsdmlld0lkOnRoaXMudmlld0lkfSk7WC5yZWN0JiYoWC5yZWN0PVgucmVjdCYmVnQoWC5yZWN0KSwoRj1sLnJlbmRlcik9PW51bGx8fEYucHVzaChYKSl9dC5zaXplJiYobC5zcD1bXSx0LmZvckVhY2goKFgsWik9Pnt2YXIgdHQ7KHR0PWwuc3ApPT1udWxsfHx0dC5wdXNoKHt0eXBlOmF0LkN1cnNvcix1aWQ6Wi5zcGxpdChKaClbMF0sb3A6WC5vcCx3b3JrU3RhdGU6WC53b3JrU3RhdGUsdmlld0lkOnRoaXMudmlld0lkfSl9KSksKEc9bC5yZW5kZXIpIT1udWxsJiZHLmxlbmd0aCYmdGhpcy5wb3N0KGwpfXJ1bkFuaW1hdGlvbigpe3RoaXMuYW5pbWF0aW9uSWR8fCh0aGlzLmFuaW1hdGlvbklkPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRyYXcuYmluZCh0aGlzKSkpfWNvbXB1dE5leHRBbmltYXRpb25JbmRleChlLHQpe3ZhciBuO2NvbnN0IHI9TWF0aC5mbG9vcigoZS5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKGUuYW5pbWF0aW9uSW5kZXgpLmxlbmd0aCozMi90LygoKG49ZS5ub2RlKT09bnVsbD92b2lkIDA6bi5zeW5jVW5pdFRpbWUpfHwxZTMpKSp0O3JldHVybiBNYXRoLm1pbigoZS5hbmltYXRpb25JbmRleHx8MCkrKHJ8fHQpLChlLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkubGVuZ3RoKX1ydW5FZmZlY3QoKXt0aGlzLnJ1bkVmZmVjdElkfHwodGhpcy5ydW5FZmZlY3RJZD1zZXRUaW1lb3V0KHRoaXMuZWZmZWN0UnVuU2VsZWN0b3IuYmluZCh0aGlzKSwwKSl9ZWZmZWN0UnVuU2VsZWN0b3IoKXt0aGlzLnJ1bkVmZmVjdElkPXZvaWQgMDtsZXQgZT10aGlzLm5vQW5pbWF0aW9uUmVjdDt0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5mb3JFYWNoKHQ9Pnt2YXIgaSxhO2NvbnN0IHI9dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMuZ2V0KHQpLG49ciYmci5zZWxlY3RJZHMmJigoaT1yLm5vZGUpPT1udWxsP3ZvaWQgMDppLnNlbGVjdFNlcnZpY2VOb2RlKHQsciwhMCkpO2U9YnQoZSxuKSwoYT1yPT1udWxsP3ZvaWQgMDpyLnNlbGVjdElkcykhPW51bGwmJmEubGVuZ3RofHx0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5kZWxldGUodCl9KSxlJiZ0aGlzLnBvc3Qoe3JlbmRlcjpbe3JlY3Q6VnQoZSksZHJhd0NhbnZhczp5dC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnl0LkJnLGlzRnVsbFdvcms6ITAsdmlld0lkOnRoaXMudmlld0lkfV19KSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5jbGVhcigpLHRoaXMubm9BbmltYXRpb25SZWN0PXZvaWQgMH1hY3RpdmVTZWxlY3RvclNoYXBlKGUpe3ZhciBmLHYsZDtjb25zdHt3b3JrSWQ6dCxvcHQ6cix0b29sc1R5cGU6bix0eXBlOmksc2VsZWN0SWRzOmF9PWU7aWYoIXQpcmV0dXJuO2NvbnN0IGw9dC50b1N0cmluZygpO2lmKCEoKGY9dGhpcy5zZWxlY3RvcldvcmtTaGFwZXMpIT1udWxsJiZmLmhhcyhsKSkpe2xldCBwPXt0b29sc1R5cGU6bixzZWxlY3RJZHM6YSx0eXBlOmksb3B0OnJ9O24mJnImJihwPXRoaXMuc2V0Tm9kZUtleShwLG4scikpLCh2PXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzKT09bnVsbHx8di5zZXQobCxwKX1jb25zdCBzPShkPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzKT09bnVsbD92b2lkIDA6ZC5nZXQobCk7aSYmKHMudHlwZT1pKSxzLm5vZGUmJnMubm9kZS5nZXRXb3JrSWQoKSE9PWwmJnMubm9kZS5zZXRXb3JrSWQobCkscy5zZWxlY3RJZHM9YXx8W119fWNsYXNzIHMwIGV4dGVuZHMgcW57Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFuaW1hdGlvbldvcmtSZWN0cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZURyYXdUaW1lciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25JZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjbG9zZUFuaW1hdGlvblRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMTAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJ1bkxhc2VyUGVuU3RlcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KX1hc3luYyBydW5GdWxsV29yayhlLHQpe3ZhciBpLGE7Y29uc3Qgcj10aGlzLnNldEZ1bGxXb3JrKGUpLG49ZS5vcHMmJnplKGUub3BzKTtpZihyKXtsZXQgbDtyLnRvb2xzVHlwZT09PWR0LkltYWdlP2w9YXdhaXQgci5jb25zdW1lU2VydmljZUFzeW5jKHtpc0Z1bGxXb3JrOiEwLHNjZW5lOihpPXRoaXMuZnVsbExheWVyLnBhcmVudCk9PW51bGw/dm9pZCAwOmkucGFyZW50fSk6bD1yLmNvbnN1bWVTZXJ2aWNlKHtvcDpuLGlzRnVsbFdvcms6ITAscmVwbGFjZUlkOihhPXIuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDphLnRvU3RyaW5nKCksaXNEcmF3TGFiZWw6dH0pO2NvbnN0IHM9KGU9PW51bGw/dm9pZCAwOmUudXBkYXRlTm9kZU9wdCkmJnIudXBkYXRhT3B0U2VydmljZShlLnVwZGF0ZU5vZGVPcHQpO3JldHVybiBlLndvcmtJZCYmdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlLndvcmtJZCksc3x8bH19cnVuU2VsZWN0V29yayhlKXt2YXIgcjtjb25zdCB0PXRoaXMuc2V0RnVsbFdvcmsoZSk7dCYmKChyPWUuc2VsZWN0SWRzKSE9bnVsbCYmci5sZW5ndGgpJiZlLndvcmtJZCYmdC5zZWxlY3RTZXJ2aWNlTm9kZShlLndvcmtJZC50b1N0cmluZygpLHtzZWxlY3RJZHM6ZS5zZWxlY3RJZHN9LCExKX1jb25zdW1lRHJhdyhlKXt2YXIgbjtjb25zdHtvcDp0LHdvcmtJZDpyfT1lO2lmKHQhPW51bGwmJnQubGVuZ3RoJiZyKXtjb25zdCBpPXRoaXMud29ya1NoYXBlcy5nZXQocik7aWYoIWkpcmV0dXJuO2NvbnN0IGE9aS50b29sc1R5cGUsbD1pLmNvbnN1bWUoe2RhdGE6ZSxpc0Z1bGxXb3JrOiExLGlzQ2xlYXJBbGw6ITAsaXNTdWJXb3JrZXI6ITB9KTtzd2l0Y2goYSl7Y2FzZSBkdC5MYXNlclBlbjpsIT1udWxsJiZsLnJlY3QmJigobj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fG4uc2V0KHIse3JlczpsLGNhbkRlbDohMSxpc1JlY3Q6ITB9KSksdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpO2JyZWFrO2Nhc2UgZHQuQXJyb3c6Y2FzZSBkdC5TdHJhaWdodDpjYXNlIGR0LkVsbGlwc2U6Y2FzZSBkdC5SZWN0YW5nbGU6Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUG9seWdvbjpjYXNlIGR0LlNwZWVjaEJhbGxvb246bCYmKHRoaXMuZHJhd0NvdW50KyssdGhpcy5kcmF3QXJyb3cobCkpO2JyZWFrO2Nhc2UgZHQuUGVuY2lsOmwmJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd1BlbmNpbChsKSk7YnJlYWt9fX1jb25zdW1lRHJhd0FsbChlKXt2YXIgcixuO2NvbnN0e3dvcmtJZDp0fT1lO2lmKHQpe2NvbnN0IGk9dGhpcy53b3JrU2hhcGVzLmdldCh0KTtpZighaSlyZXR1cm47c3dpdGNoKGkudG9vbHNUeXBlKXtjYXNlIGR0Lkxhc2VyUGVuOmlmKHRoaXMuYW5pbWF0aW9uSWQpe2NvbnN0IGw9aS5jb25zdW1lQWxsKHtkYXRhOmV9KTtsIT1udWxsJiZsLm9wJiZsIT1udWxsJiZsLnJlY3QmJigocj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fHIuc2V0KHQse3JlczpsLGNhbkRlbDohMSxpc1JlY3Q6ITB9KSx0aGlzLnJ1bkxhc2VyUGVuQW5pbWF0aW9uKGwpKTtjb25zdCBzPShuPWkuZ2V0V29ya09wdGlvbnMoKSk9PW51bGw/dm9pZCAwOm4uZHVyYXRpb247dGhpcy5jbG9zZUFuaW1hdGlvblRpbWU9cz9zKjFlMysxMDA6dGhpcy5jbG9zZUFuaW1hdGlvblRpbWUsc2V0VGltZW91dCgoKT0+e3ZhciB2O3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQudG9TdHJpbmcoKSkubWFwKGQ9PmQucmVtb3ZlKCkpLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodCk7Y29uc3QgZj0odj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGw/dm9pZCAwOnYuZ2V0KHQpO2YmJihmLmNhbkRlbD0hMCksc2V0VGltZW91dCgoKT0+e3RoaXMuX3Bvc3Qoe3NwOlt7cmVtb3ZlSWRzOlt0LnRvU3RyaW5nKCldLHR5cGU6YXQuUmVtb3ZlTm9kZX1dfSl9LGkuZ2V0V29ya09wdGlvbnMoKS5zeW5jVW5pdFRpbWV8fHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKX0sdGhpcy5jbG9zZUFuaW1hdGlvblRpbWUpfWJyZWFrO2Nhc2UgZHQuQXJyb3c6Y2FzZSBkdC5TdHJhaWdodDpjYXNlIGR0LkVsbGlwc2U6Y2FzZSBkdC5QZW5jaWw6Y2FzZSBkdC5SZWN0YW5nbGU6Y2FzZSBkdC5TdGFyOmNhc2UgZHQuUG9seWdvbjpjYXNlIGR0LlNwZWVjaEJhbGxvb246dGhpcy5kcmF3Q291bnQ9MCx0aGlzLmZ1bGxMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodCk7YnJlYWt9fX11cGRhdGVMYWJlbHMoZSx0KXtlLmNoaWxkcmVuLmZvckVhY2gocj0+e2lmKHIudGFnTmFtZT09PSJMQUJFTCIpe2NvbnN0IG49ci5uYW1lLHt3aWR0aDppfT1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFthXT1lLndvcmxkU2NhbGluZyx7dW5kZXJsaW5lOmwsbGluZVRocm91Z2g6c309dC5vcHQ7bCYmZS5nZXRFbGVtZW50c0J5TmFtZShgJHtufV91bmRlcmxpbmVgKVswXS5hdHRyKHtwb2ludHM6WzAsMCxpL2EsMF19KSxzJiZlLmdldEVsZW1lbnRzQnlOYW1lKGAke259X2xpbmVUaHJvdWdoYClbMF0uYXR0cih7cG9pbnRzOlswLDAsaS9hLDBdfSl9fSl9cnVuTGFzZXJQZW5BbmltYXRpb24oZSl7dGhpcy5hbmltYXRpb25JZHx8KHRoaXMuYW5pbWF0aW9uSWQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57dmFyIG4saTtpZih0aGlzLmFuaW1hdGlvbklkPXZvaWQgMCx0aGlzLnJ1bkxhc2VyUGVuU3RlcCsrLHRoaXMucnVuTGFzZXJQZW5TdGVwPjEpe3RoaXMucnVuTGFzZXJQZW5TdGVwPTAsdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbihlKTtyZXR1cm59bGV0IHQ7Y29uc3Qgcj1bXTsobj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fG4uZm9yRWFjaCgoYSxsLHMpPT57YS5pc1JlY3QmJih0PWJ0KHQsYS5yZXMucmVjdCkpLGEucmVzLndvcmtJZCYmci5wdXNoKGEucmVzKSx0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShsLnRvU3RyaW5nKCkpLmxlbmd0aD9hLmlzUmVjdD0hMDphLmlzUmVjdD0hMSxhLmNhbkRlbCYmcy5kZWxldGUobCl9KSwoaT10aGlzLmFuaW1hdGlvbldvcmtSZWN0cykhPW51bGwmJmkuc2l6ZSYmdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpLHQmJihlJiZyLnB1c2goZSksdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDpWdCh0KSxkcmF3Q2FudmFzOnl0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9XSxzcDpyfSkpfSkpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHJlbmRlcjpbe3JlY3Q6ZT09bnVsbD92b2lkIDA6ZS5yZWN0LGRyYXdDYW52YXM6eXQuRmxvYXQsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dLHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd0Fycm93KGUpe3RoaXMuX3Bvc3Qoe2RyYXdDb3VudDp0aGlzLmRyYXdDb3VudCxyZW5kZXI6W3tyZWN0OihlPT1udWxsP3ZvaWQgMDplLnJlY3QpJiZWdChlLnJlY3QpLGRyYXdDYW52YXM6eXQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczp5dC5GbG9hdCxpc0Z1bGxXb3JrOiExLHZpZXdJZDp0aGlzLnZpZXdJZH1dfSl9fXZhciBQZTsoZnVuY3Rpb24odSl7dS5GdWxsPSJmdWxsIix1LlN1Yj0ic3ViIn0pKFBlfHwoUGU9e30pKTtjbGFzcyBvMHtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfc2VsZiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0eXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtUaHJlYWRNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksdGhpcy5fc2VsZj1lLHRoaXMudHlwZT10LHRoaXMucmVnaXN0ZXIoKX1pbml0KGUpe2NvbnN0e3ZpZXdJZDp0LGRwcjpyLG9mZnNjcmVlbkNhbnZhc09wdDpuLGxheWVyT3B0OmksaXNTYWZhcmk6YX09ZTtpZighcnx8IW58fCFpKXJldHVybjtsZXQgbDt0aGlzLnR5cGU9PT1QZS5GdWxsJiYobD1uZXcgYTAodCx7ZHByOnIsb2Zmc2NyZWVuQ2FudmFzT3B0Om4sbGF5ZXJPcHQ6aX0sdGhpcy5wb3N0LmJpbmQodGhpcykpKSx0aGlzLnR5cGU9PT1QZS5TdWImJihsPW5ldyBsMCh0LHtkcHI6cixvZmZzY3JlZW5DYW52YXNPcHQ6bixsYXllck9wdDppfSx0aGlzLnBvc3QuYmluZCh0aGlzKSkpLGwmJmEmJmwuc2V0SXNTYWZhcmkoYSksbCYmZS5jYW1lcmFPcHQmJmwuc2V0Q2FtZXJhT3B0KGUuY2FtZXJhT3B0KSxsJiZ0aGlzLndvcmtUaHJlYWRNYXAuc2V0KHQsbCl9cmVnaXN0ZXIoKXtvbm1lc3NhZ2U9ZT0+e2NvbnN0IHQ9ZS5kYXRhO2lmKHQpZm9yKGNvbnN0IHIgb2YgdC52YWx1ZXMoKSl7Y29uc3R7bXNnVHlwZTpuLHZpZXdJZDppLHRhc2tzcXVldWU6YSxtYWluVGFza3NxdWV1ZUNvdW50Omx9PXI7aWYobj09PWF0LkluaXQpe3RoaXMuaW5pdChyKTtjb250aW51ZX1pZihuPT09YXQuVGFza3NRdWV1ZSYmKGEhPW51bGwmJmEuc2l6ZSkmJmwpe3RoaXMud29ya1RocmVhZE1hcC5mb3JFYWNoKChmLHYpPT57Y29uc3QgZD1hLmdldCh2KTtkJiZmLm9uKGQpLHRoaXMucG9zdCh7d29ya2VyVGFza3NxdWV1ZUNvdW50Omx9KX0pO2NvbnRpbnVlfWlmKGk9PT1raCl7dGhpcy53b3JrVGhyZWFkTWFwLmZvckVhY2goZj0+e2Yub24ociksbj09PWF0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUoaSl9KTtjb250aW51ZX1jb25zdCBzPXRoaXMud29ya1RocmVhZE1hcC5nZXQoaSk7cyYmKHMub24ociksbj09PWF0LkRlc3Ryb3kmJnRoaXMud29ya1RocmVhZE1hcC5kZWxldGUoaSkpfX19cG9zdChlLHQpe3Q/dGhpcy5fc2VsZi5wb3N0TWVzc2FnZShlLHQpOnRoaXMuX3NlbGYucG9zdE1lc3NhZ2UoZSl9fWNsYXNzIGEwIGV4dGVuZHMga257Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKGUsdCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJtZXRob2RCdWlsZGVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxvY2FsV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuX3Bvc3Q9cix0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKCJkcmF3TGF5ZXIiLHRoaXMuc2NlbmUsey4uLnQubGF5ZXJPcHQsYnVmZmVyU2l6ZToxZTN9KTtjb25zdCBuPXt0aHJlYWQ6dGhpcyx2aWV3SWQ6dGhpcy52aWV3SWQsdk5vZGVzOnRoaXMudk5vZGVzLGZ1bGxMYXllcjp0aGlzLmZ1bGxMYXllcixkcmF3TGF5ZXI6dGhpcy5kcmF3TGF5ZXIscG9zdDp0aGlzLnBvc3QuYmluZCh0aGlzKX07dGhpcy5sb2NhbFdvcms9bmV3IG4wKG4pLHRoaXMuc2VydmljZVdvcms9bmV3IGkwKG4pLHRoaXMubWV0aG9kQnVpbGRlcj1uZXcgT2coW0N0LkNvcHlOb2RlLEN0LlNldENvbG9yTm9kZSxDdC5EZWxldGVOb2RlLEN0LlJvdGF0ZU5vZGUsQ3QuU2NhbGVOb2RlLEN0LlRyYW5zbGF0ZU5vZGUsQ3QuWkluZGV4QWN0aXZlLEN0LlpJbmRleE5vZGUsQ3QuU2V0Rm9udFN0eWxlLEN0LlNldFBvaW50LEN0LlNldExvY2ssQ3QuU2V0U2hhcGVPcHRdKS5yZWdpc3RlckZvcldvcmtlcih0aGlzLmxvY2FsV29yayx0aGlzLnNlcnZpY2VXb3JrLHRoaXMuc2NlbmUpLHRoaXMudk5vZGVzLmluaXQodGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpfWFzeW5jIHBvc3QoZSx0KXt2YXIgbCxzLGY7Y29uc3Qgcj1lLnJlbmRlcixuPVtdO2xldCBpPXQ7aWYociE9bnVsbCYmci5sZW5ndGgpe2Zvcihjb25zdCB2IG9mIHIpe2lmKHYuaXNDbGVhckFsbCYmKHYucmVjdD10aGlzLmdldFNjZW5lUmVjdCgpLHYuaXNDbGVhcj0hMCxkZWxldGUgdi5pc0NsZWFyQWxsKSx2LmlzRHJhd0FsbCYmKHYucmVjdD10aGlzLmdldFNjZW5lUmVjdCgpLGRlbGV0ZSB2LmlzRHJhd0FsbCksdi5kcmF3Q2FudmFzKXtjb25zdCBkPXYuaXNGdWxsV29yaz90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcjsoZD09bnVsbD92b2lkIDA6ZC5wYXJlbnQpLnJlbmRlcigpfWlmKHYucmVjdCl7di5jbGVhckNhbnZhcz09PXYuZHJhd0NhbnZhcyYmdi5kcmF3Q2FudmFzPT09eXQuQmcmJih2LnJlY3Q9dGhpcy5jaGVja1JpZ2h0UmVjdEJvdW5kaW5nQm94KHYucmVjdCkpO2NvbnN0IGQ9di5yZWN0O2lmKHRoaXMuaXNTYWZhcmkmJih2LnJlY3Q9dGhpcy5zYWZhcmlGaXhSZWN0KFl0KHYucmVjdCkpKSwhdi5yZWN0KWNvbnRpbnVlO2lmKHYuZHJhd0NhbnZhcz09PXl0LlNlbGVjdG9yKXtjb25zdCBwPShsPWUuc3ApPT1udWxsP3ZvaWQgMDpsLmZpbmQoeT0+eS50eXBlPT09YXQuU2VsZWN0KTtwJiYocC5yZWN0PXYucmVjdCksdi5vZmZzZXQ9e3g6di5yZWN0LngtZC54LHk6di5yZWN0LnktZC55fX1pZih2LmRyYXdDYW52YXMpe2NvbnN0IHA9YXdhaXQgdGhpcy5nZXRSZWN0SW1hZ2VCaXRtYXAodi5yZWN0LCEhdi5pc0Z1bGxXb3JrKTt2LmltYWdlQml0bWFwPXAsaXx8KGk9W10pLGkucHVzaChwKX1uLnB1c2godil9fWUucmVuZGVyPW59Y29uc3QgYT0ocz1lLnNwKT09bnVsbD92b2lkIDA6cy5maWx0ZXIodj0+di50eXBlIT09YXQuTm9uZXx8T2JqZWN0LmtleXModikuZmlsdGVyKGQ9PmQ9PT0idHlwZSIpLmxlbmd0aCk7aWYoYSE9bnVsbCYmYS5sZW5ndGgmJihlLnNwPWEubWFwKHY9Pih7Li4udix2aWV3SWQ6dGhpcy52aWV3SWR9KSkpLChlLmRyYXdDb3VudHx8ZS53b3JrZXJUYXNrc3F1ZXVlQ291bnR8fChmPWUuc3ApIT1udWxsJiZmLmxlbmd0aHx8biE9bnVsbCYmbi5sZW5ndGgpJiYodGhpcy5fcG9zdChlLGkpLGkhPW51bGwmJmkubGVuZ3RoKSlmb3IoY29uc3QgdiBvZiBpKXYgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCYmdi5jbG9zZSgpfW9uKGUpe2lmKHRoaXMubWV0aG9kQnVpbGRlci5jb25zdW1lRm9yV29ya2VyKGUpKXJldHVybjtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cix3b3JrSWQ6bn09ZTtzd2l0Y2godCl7Y2FzZSBhdC5VcGRhdGVDYW1lcmE6dGhpcy51cGRhdGVDYW1lcmEoZSk7YnJlYWs7Y2FzZSBhdC5TZWxlY3Q6cj09PU90LlNlcnZpY2UmJihuPT09SXQuc2VsZWN0b3JJZD90aGlzLmxvY2FsV29yay51cGRhdGVGdWxsU2VsZWN0V29yayhlKTp0aGlzLnNlcnZpY2VXb3JrLnJ1blNlbGVjdFdvcmsoZSkpO2JyZWFrO2Nhc2UgYXQuVXBkYXRlTm9kZTpjYXNlIGF0LkZ1bGxXb3JrOnRoaXMuY29uc3VtZUZ1bGwocixlKTticmVhaztjYXNlIGF0LlJlbW92ZU5vZGU6dGhpcy5yZW1vdmVOb2RlKGUpO2JyZWFrO2Nhc2UgYXQuR2V0VGV4dEFjdGl2ZTp0aGlzLmNoZWNrVGV4dEFjdGl2ZShlKTticmVhaztjYXNlIGF0LkN1cnNvckhvdmVyOnRoaXMuY3Vyc29ySG92ZXIoZSl9c3VwZXIub24oZSl9YXN5bmMgcmVtb3ZlTm9kZShlKXtjb25zdHtkYXRhVHlwZTp0LHdvcmtJZDpyfT1lO2lmKHI9PT1JdC5zZWxlY3RvcklkKXt0aGlzLmxvY2FsV29yay5ibHVyU2VsZWN0b3IoZSk7cmV0dXJufXQ9PT1PdC5Mb2NhbCYmKHRoaXMubG9jYWxXb3JrLnJlbW92ZVdvcmsoZSksdGhpcy5sb2NhbFdvcmsuY29sbG9jdEVmZmVjdFNlbGVjdFdvcmsoZSkpLHQ9PT1PdC5TZXJ2aWNlJiYodGhpcy5zZXJ2aWNlV29yay5yZW1vdmVXb3JrKGUpLHRoaXMubG9jYWxXb3JrLmNvbGxvY3RFZmZlY3RTZWxlY3RXb3JrKGUpKX1jaGVja1RleHRBY3RpdmUoZSl7Y29uc3R7ZGF0YVR5cGU6dH09ZTt0PT09T3QuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNoZWNrVGV4dEFjdGl2ZShlKX1jbGVhckFsbCgpe3RoaXMudk5vZGVzLmNsZWFyKCksc3VwZXIuY2xlYXJBbGwoKSx0aGlzLnBvc3Qoe3JlbmRlcjpbe2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6eXQuQmcsaXNGdWxsV29yazohMCx2aWV3SWQ6dGhpcy52aWV3SWR9LHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnl0LkZsb2F0LGlzRnVsbFdvcms6ITEsdmlld0lkOnRoaXMudmlld0lkfV0sc3A6W3t0eXBlOmF0LkNsZWFyfV19KX1zZXRDYW1lcmFPcHQoZSl7dGhpcy5jYW1lcmFPcHQ9ZTtjb25zdHtzY2FsZTp0LGNlbnRlclg6cixjZW50ZXJZOm4sd2lkdGg6aSxoZWlnaHQ6YX09ZTsoaSE9PXRoaXMuc2NlbmUud2lkdGh8fGEhPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOmksaGVpZ2h0OmF9KSx0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFt0LHRdKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1yLC1uXSkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3QsdF0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLXIsLW5dKSl9Z2V0T2Zmc2NyZWVuKGUpe3JldHVybihlP3RoaXMuZnVsbExheWVyLnBhcmVudDp0aGlzLmRyYXdMYXllci5wYXJlbnQpLmNhbnZhc31hc3luYyBjb25zdW1lRnVsbChlLHQpe2NvbnN0IHI9YXdhaXQgdGhpcy5sb2NhbFdvcmsuY29sbG9jdEVmZmVjdFNlbGVjdFdvcmsodCk7ciYmZT09PU90LkxvY2FsJiZhd2FpdCB0aGlzLmxvY2FsV29yay5jb25zdW1lRnVsbChyLHRoaXMuc2NlbmUpLHImJmU9PT1PdC5TZXJ2aWNlJiZ0aGlzLnNlcnZpY2VXb3JrLmNvbnN1bWVGdWxsKHIpfWNvbnN1bWVEcmF3KGUsdCl7ZT09PU90LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhdyh0LHRoaXMuc2VydmljZVdvcmspLGU9PT1PdC5TZXJ2aWNlJiZ0aGlzLnNlcnZpY2VXb3JrLmNvbnN1bWVEcmF3KHQpfWNvbnN1bWVEcmF3QWxsKGUsdCl7ZT09PU90LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhd0FsbCh0LHRoaXMuc2VydmljZVdvcmspfXVwZGF0ZUNhbWVyYShlKXtjb25zdCB0PVtdLHtjYW1lcmFPcHQ6cn09ZTtyJiYodGhpcy5zZXRDYW1lcmFPcHQociksdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5mb3JFYWNoKChuLGkpPT57KG4udG9vbHNUeXBlPT09ZHQuUGVuY2lsfHxuLnRvb2xzVHlwZT09PWR0LkFycm93fHxuLnRvb2xzVHlwZT09PWR0LlN0cmFpZ2h0fHxuLnRvb2xzVHlwZT09PWR0LkVsbGlwc2V8fG4udG9vbHNUeXBlPT09ZHQuUmVjdGFuZ2xlfHxuLnRvb2xzVHlwZT09PWR0LlN0YXJ8fG4udG9vbHNUeXBlPT09ZHQuUG9seWdvbnx8bi50b29sc1R5cGU9PT1kdC5TcGVlY2hCYWxsb29ufHxuLnRvb2xzVHlwZT09PWR0LlRleHQpJiZ0aGlzLmxvY2FsV29yay53b3JrU2hhcGVTdGF0ZS5zZXQoaSx7d2lsbENsZWFyOiEwfSl9KSx0aGlzLmxvY2FsV29yay5ydW5FZmZlY3RXb3JrKCgpPT57aWYodGhpcy5zZXJ2aWNlV29yay5zZWxlY3RvcldvcmtTaGFwZXMuc2l6ZSlmb3IoY29uc3RbbixpXW9mIHRoaXMuc2VydmljZVdvcmsuc2VsZWN0b3JXb3JrU2hhcGVzLmVudHJpZXMoKSl0aGlzLnNlcnZpY2VXb3JrLnJ1blNlbGVjdFdvcmsoe3dvcmtJZDpuLHNlbGVjdElkczppLnNlbGVjdElkcyxtc2dUeXBlOmF0LlNlbGVjdCxkYXRhVHlwZTpPdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2lmKHRoaXMudk5vZGVzLmhhc1JlbmRlck5vZGVzKCkpe2xldCBuO3QucHVzaCh7aXNDbGVhckFsbDohMCxjbGVhckNhbnZhczp5dC5CZyxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0se2lzQ2xlYXJBbGw6ITAsY2xlYXJDYW52YXM6eXQuRmxvYXQsaXNGdWxsV29yazohMSx2aWV3SWQ6dGhpcy52aWV3SWR9KTtmb3IoY29uc3QgaSBvZiB0aGlzLnZOb2Rlcy5jdXJOb2RlTWFwLnZhbHVlcygpKWJuKGkudG9vbHNUeXBlKSYmKG49YnQobixpLnJlY3QpKTtuJiZ0LnB1c2goe3JlY3Q6VnQobiwxMDApLGRyYXdDYW52YXM6eXQuQmcsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiEwLHZpZXdJZDp0aGlzLnZpZXdJZH0pfXQubGVuZ3RoJiZ0aGlzLnBvc3Qoe3JlbmRlcjp0fSl9KSl9Z2V0UmVjdEltYWdlQml0bWFwKGUsdCl7Y29uc3Qgcj1lLngqdGhpcy5kcHIsbj1lLnkqdGhpcy5kcHIsaT1lLncqdGhpcy5kcHIsYT1lLmgqdGhpcy5kcHI7cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKHRoaXMuZ2V0T2Zmc2NyZWVuKHQpLHIsbixpLGEpfXNhZmFyaUZpeFJlY3QoZSl7aWYoZS53K2UueDw9MHx8ZS5oK2UueTw9MHx8ZS53PD0wfHxlLmg8PTApcmV0dXJuO2NvbnN0IHQ9e3g6MCx5OjAsdzpNYXRoLmZsb29yKHRoaXMuc2NlbmUud2lkdGgpLGg6TWF0aC5mbG9vcih0aGlzLnNjZW5lLmhlaWdodCl9O2lmKGUueDwwP2UudytlLng8dGhpcy5zY2VuZS53aWR0aCYmKHQudz1lLncrZS54KTplLncrZS54PjAmJih0Lng9ZS54LHQudz1NYXRoLmZsb29yKHRoaXMuc2NlbmUud2lkdGgtZS54KSksZS55PDA/ZS5oK2UueTx0aGlzLnNjZW5lLmhlaWdodCYmKHQuaD1lLmgrZS55KTplLmgrZS55PjAmJih0Lnk9ZS55LHQuaD1NYXRoLmZsb29yKHRoaXMuc2NlbmUuaGVpZ2h0LWUueSkpLCEodC53PD0wfHx0Lmg8PTApKXJldHVybiB0fWdldFNjZW5lUmVjdCgpe2NvbnN0e3dpZHRoOmUsaGVpZ2h0OnR9PXRoaXMuc2NlbmU7cmV0dXJue3g6MCx5OjAsdzpNYXRoLmZsb29yKGUpLGg6TWF0aC5mbG9vcih0KX19Y2hlY2tSaWdodFJlY3RCb3VuZGluZ0JveChlKXtyZXR1cm4gdGhpcy52Tm9kZXMuY29tYmluZUludGVyc2VjdFJlY3QoZSl9Y3Vyc29ySG92ZXIoZSl7dGhpcy5sb2NhbFdvcmsuY3Vyc29ySG92ZXIoZSl9fWNsYXNzIGwwIGV4dGVuZHMga257Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKGUsdCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZXJ2aWNlV29yayIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsb2NhbFdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLl9wb3N0PXI7Y29uc3Qgbj17dGhyZWFkOnRoaXMsdmlld0lkOnRoaXMudmlld0lkLHZOb2Rlczp0aGlzLnZOb2RlcyxmdWxsTGF5ZXI6dGhpcy5mdWxsTGF5ZXIsZHJhd0xheWVyOnRoaXMuZHJhd0xheWVyLHBvc3Q6dGhpcy5wb3N0LmJpbmQodGhpcyl9O3RoaXMubG9jYWxXb3JrPW5ldyBzMChuKSx0aGlzLnZOb2Rlcy5pbml0KHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyKX1hc3luYyBwb3N0KGUsdCl7dmFyIGwscztjb25zdCByPWUucmVuZGVyLG49W107bGV0IGk9dDtpZihyIT1udWxsJiZyLmxlbmd0aCl7Zm9yKGNvbnN0IGYgb2YgcilpZihmLmRyYXdDYW52YXMmJnRoaXMuZnVsbExheWVyLnBhcmVudC5yZW5kZXIoKSxmLnJlY3Qpe2lmKHRoaXMuaXNTYWZhcmkmJihmLnJlY3Q9dGhpcy5zYWZhcmlGaXhSZWN0KFl0KGYucmVjdCkpKSwhZi5yZWN0KWNvbnRpbnVlO2lmKGYuZHJhd0NhbnZhcyl7Y29uc3Qgdj1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcChmLnJlY3QsISFmLmlzRnVsbFdvcmspO2YuaW1hZ2VCaXRtYXA9dixpfHwoaT1bXSksaS5wdXNoKHYpfW4ucHVzaChmKX1lLnJlbmRlcj1ufWNvbnN0IGE9KGw9ZS5zcCk9PW51bGw/dm9pZCAwOmwuZmlsdGVyKGY9PmYudHlwZSE9PWF0Lk5vbmV8fE9iamVjdC5rZXlzKGYpLmZpbHRlcih2PT52PT09InR5cGUiKS5sZW5ndGgpO2lmKGEhPW51bGwmJmEubGVuZ3RoJiYoZS5zcD1hLm1hcChmPT4oey4uLmYsdmlld0lkOnRoaXMudmlld0lkfSkpKSwoKHM9ZS5zcCkhPW51bGwmJnMubGVuZ3RofHxlLmRyYXdDb3VudHx8biE9bnVsbCYmbi5sZW5ndGgpJiYodGhpcy5fcG9zdChlLGkpLGkhPW51bGwmJmkubGVuZ3RoKSlmb3IoY29uc3QgZiBvZiBpKWYgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCYmZi5jbG9zZSgpfW9uKGUpe2NvbnN0e21zZ1R5cGU6dH09ZTtzd2l0Y2godCl7Y2FzZSBhdC5VcGRhdGVDYW1lcmE6dGhpcy51cGRhdGVDYW1lcmEoZSk7YnJlYWs7Y2FzZSBhdC5TbmFwc2hvdDp0aGlzLnNuYXBzaG90RnVsbExheWVyPXRoaXMuY3JlYXRlTGF5ZXIoInNuYXBzaG90RnVsbExheWVyIix0aGlzLnNjZW5lLHsuLi50aGlzLm9wdC5sYXllck9wdCxidWZmZXJTaXplOnRoaXMudmlld0lkPT09Im1haW5WaWV3Ij82ZTM6M2UzfSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllciYmdGhpcy5nZXRTbmFwc2hvdChlKS50aGVuKCgpPT57dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj12b2lkIDB9KTticmVhaztjYXNlIGF0LkJvdW5kaW5nQm94OnRoaXMuc25hcHNob3RGdWxsTGF5ZXI9dGhpcy5jcmVhdGVMYXllcigic25hcHNob3RGdWxsTGF5ZXIiLHRoaXMuc2NlbmUsey4uLnRoaXMub3B0LmxheWVyT3B0LGJ1ZmZlclNpemU6dGhpcy52aWV3SWQ9PT0ibWFpblZpZXciPzZlMzozZTN9KSx0aGlzLnNuYXBzaG90RnVsbExheWVyJiZ0aGlzLmdldEJvdW5kaW5nUmVjdChlKS50aGVuKCgpPT57dGhpcy5zbmFwc2hvdEZ1bGxMYXllcj12b2lkIDB9KTticmVha31zdXBlci5vbihlKX1nZXRPZmZzY3JlZW4oZSl7dmFyIHQ7cmV0dXJuKHQ9KGUmJnRoaXMuc25hcHNob3RGdWxsTGF5ZXJ8fHRoaXMuZnVsbExheWVyKS5wYXJlbnQpPT1udWxsP3ZvaWQgMDp0LmNhbnZhc31jb25zdW1lRHJhdyhlLHQpe2U9PT1PdC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXcodCl9Y29uc3VtZURyYXdBbGwoZSx0KXt0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhd0FsbCh0KX1nZXRSZWN0SW1hZ2VCaXRtYXAoZSx0PSExLHIpe2NvbnN0IG49ZS54KnRoaXMuZHByLGk9ZS55KnRoaXMuZHByLGE9ZS53KnRoaXMuZHByLGw9ZS5oKnRoaXMuZHByO3JldHVybiBjcmVhdGVJbWFnZUJpdG1hcCh0aGlzLmdldE9mZnNjcmVlbih0KSxuLGksYSxsLHIpfXNhZmFyaUZpeFJlY3QoZSl7aWYoZS53K2UueDw9MHx8ZS5oK2UueTw9MHx8ZS53PD0wfHxlLmg8PTApcmV0dXJuO2NvbnN0IHQ9e3g6MCx5OjAsdzpNYXRoLmZsb29yKHRoaXMuc2NlbmUud2lkdGgpLGg6TWF0aC5mbG9vcih0aGlzLnNjZW5lLmhlaWdodCl9O2lmKGUueDwwP2UudytlLng8dGhpcy5zY2VuZS53aWR0aCYmKHQudz1lLncrZS54KTplLncrZS54PjAmJih0Lng9ZS54LHQudz1NYXRoLmZsb29yKHRoaXMuc2NlbmUud2lkdGgtZS54KSksZS55PDA/ZS5oK2UueTx0aGlzLnNjZW5lLmhlaWdodCYmKHQuaD1lLmgrZS55KTplLmgrZS55PjAmJih0Lnk9ZS55LHQuaD1NYXRoLmZsb29yKHRoaXMuc2NlbmUuaGVpZ2h0LWUueSkpLCEodC53PD0wfHx0Lmg8PTApKXJldHVybiB0fXVwZGF0ZUNhbWVyYShlKXtjb25zdHtjYW1lcmFPcHQ6dH09ZTt0JiZ0aGlzLnNldENhbWVyYU9wdCh0KX1zZXRDYW1lcmFPcHQoZSx0KXt0aGlzLmNhbWVyYU9wdD1lO2NvbnN0e3NjYWxlOnIsY2VudGVyWDpuLGNlbnRlclk6aSx3aWR0aDphLGhlaWdodDpsfT1lOyhhIT09dGhpcy5zY2VuZS53aWR0aHx8bCE9PXRoaXMuc2NlbmUuaGVpZ2h0KSYmdGhpcy51cGRhdGVTY2VuZSh7d2lkdGg6YSxoZWlnaHQ6bH0pLHQ/KHQuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3Iscl0pLHQuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstbiwtaV0pKToodGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJzY2FsZSIsW3Iscl0pLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLW4sLWldKSl9YXN5bmMgZ2V0U25hcHNob3QoZSl7Y29uc3R7c2NlbmVQYXRoOnQsc2NlbmVzOnIsY2FtZXJhT3B0Om4sdzppLGg6YSxtYXhaSW5kZXg6bH09ZTtpZih0JiZyJiZuJiZ0aGlzLnNuYXBzaG90RnVsbExheWVyKXtjb25zdCBzPVl0KHRoaXMuY2FtZXJhT3B0KTt0aGlzLnNldENhbWVyYU9wdChuLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIpLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLnNuYXBzaG90RnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj10aGlzLmZ1bGxMYXllcjtsZXQgZjtjb25zdCB2PW5ldyBNYXA7Zm9yKGNvbnN0W3AseV1vZiBPYmplY3QuZW50cmllcyhyKSlpZih5IT1udWxsJiZ5LnR5cGUpc3dpdGNoKHk9PW51bGw/dm9pZCAwOnkudHlwZSl7Y2FzZSBhdC5VcGRhdGVOb2RlOmNhc2UgYXQuRnVsbFdvcms6e2NvbnN0e3Rvb2xzVHlwZTpQLG9wdDp4fT15O1A9PT1kdC5UZXh0JiZ4JiYoeC56SW5kZXg9eC56SW5kZXgrKGx8fDApLCh4LmxpbmVUaHJvdWdofHx4LnVuZGVybGluZSkmJnYuc2V0KHAseSkpO2NvbnN0IG09YXdhaXQgdGhpcy5sb2NhbFdvcmsucnVuRnVsbFdvcmsoey4uLnksb3B0Ongsd29ya0lkOnAsbXNnVHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0sUD09PWR0LlRleHQpO2Y9YnQoZixtKTticmVha319dGhpcy5sb2NhbFdvcmsuZnVsbExheWVyPXRoaXMuZnVsbExheWVyLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcj12b2lkIDA7bGV0IGQ7aSYmYSYmKGQ9e3Jlc2l6ZVdpZHRoOmkscmVzaXplSGVpZ2h0OmF9KSx2LnNpemUmJihhd2FpdCBuZXcgUHJvbWlzZShwPT57c2V0VGltZW91dChwLDUwMCl9KSx0aGlzLndpbGxSZW5kZXJTcGVjaWFsTGFiZWwodikpLGF3YWl0IHRoaXMuZ2V0U25hcHNob3RSZW5kZXIoe3NjZW5lUGF0aDp0LGN1ckNhbWVyYU9wdDpzLG9wdGlvbnM6ZH0pfX13aWxsUmVuZGVyU3BlY2lhbExhYmVsKGUpe3ZhciB0O2Zvcihjb25zdFtyLG5db2YgZS5lbnRyaWVzKCkpe2NvbnN0IGk9KHQ9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcik9PW51bGw/dm9pZCAwOnQuZ2V0RWxlbWVudHNCeU5hbWUocilbMF07aSYmbi5vcHQmJnRoaXMubG9jYWxXb3JrLnVwZGF0ZUxhYmVscyhpLG4pfX1hc3luYyBnZXRTbmFwc2hvdFJlbmRlcihlKXt2YXIgYSxsO2NvbnN0e3NjZW5lUGF0aDp0LGN1ckNhbWVyYU9wdDpyLG9wdGlvbnM6bn09ZTsoKGE9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcik9PW51bGw/dm9pZCAwOmEucGFyZW50KS5yZW5kZXIoKTtjb25zdCBpPWF3YWl0IHRoaXMuZ2V0UmVjdEltYWdlQml0bWFwKHt4OjAseTowLHc6dGhpcy5zY2VuZS53aWR0aCxoOnRoaXMuc2NlbmUuaGVpZ2h0fSwhMCxuKTtpJiYoYXdhaXQgdGhpcy5wb3N0KHtzcDpbe3R5cGU6YXQuU25hcHNob3Qsc2NlbmVQYXRoOnQsaW1hZ2VCaXRtYXA6aX1dfSxbaV0pLGkuY2xvc2UoKSwobD10aGlzLnNuYXBzaG90RnVsbExheWVyKT09bnVsbHx8bC5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuc2V0Q2FtZXJhT3B0KHIsdGhpcy5mdWxsTGF5ZXIpKX1hc3luYyBnZXRCb3VuZGluZ1JlY3QoZSl7Y29uc3R7c2NlbmVQYXRoOnQsc2NlbmVzOnIsY2FtZXJhT3B0Om59PWU7aWYodCYmciYmbiYmdGhpcy5zbmFwc2hvdEZ1bGxMYXllcil7Y29uc3QgaT1ZdCh0aGlzLmNhbWVyYU9wdCk7dGhpcy5zZXRDYW1lcmFPcHQobix0aGlzLnNuYXBzaG90RnVsbExheWVyKSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dGhpcy5kcmF3TGF5ZXI7bGV0IGE7Zm9yKGNvbnN0W2wsc11vZiBPYmplY3QuZW50cmllcyhyKSlpZihzIT1udWxsJiZzLnR5cGUpc3dpdGNoKHM9PW51bGw/dm9pZCAwOnMudHlwZSl7Y2FzZSBhdC5VcGRhdGVOb2RlOmNhc2UgYXQuRnVsbFdvcms6e2NvbnN0IGY9YXdhaXQgdGhpcy5sb2NhbFdvcmsucnVuRnVsbFdvcmsoey4uLnMsd29ya0lkOmwsbXNnVHlwZTphdC5GdWxsV29yayxkYXRhVHlwZTpPdC5TZXJ2aWNlLHZpZXdJZDp0aGlzLnZpZXdJZH0pO2E9YnQoYSxmKTticmVha319YSYmYXdhaXQgdGhpcy5wb3N0KHtzcDpbe3R5cGU6YXQuQm91bmRpbmdCb3gsc2NlbmVQYXRoOnQscmVjdDphfV19KSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5mdWxsTGF5ZXIsdGhpcy5sb2NhbFdvcmsuZHJhd0xheWVyPXZvaWQgMCx0aGlzLnNuYXBzaG90RnVsbExheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5zZXRDYW1lcmFPcHQoaSx0aGlzLmZ1bGxMYXllcil9fX1jb25zdCBjMD1zZWxmO25ldyBvMChjMCxQZS5TdWIpfSkoKTsK", Ft = typeof window < "u" && window.Blob && new Blob([atob(Ls)], { type: "text/javascript;charset=utf-8" });
function JX(m) {
  let d;
  try {
    if (d = Ft && (window.URL || window.webkitURL).createObjectURL(Ft), !d)
      throw "";
    const l = new Worker(d, {
      name: m == null ? void 0 : m.name
    });
    return l.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(d);
    }), l;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + Ls,
      {
        name: m == null ? void 0 : m.name
      }
    );
  } finally {
    d && (window.URL || window.webkitURL).revokeObjectURL(d);
  }
}
class ed {
  constructor() {
    Object.defineProperty(this, "emtType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  static dispatch(d, l, i) {
    var t;
    (t = sd.InternalMsgEmitter) == null || t.emit([d, l], i);
  }
  get serviceColloctor() {
    return this.control.collector;
  }
  registerForMainEngine(d, l) {
    return this.emtType = d, this.control = l, this.mainEngine = l.worker, this.mainEngine.internalMsgEmitter.on([this.emtType, this.emitEventType], this.collect.bind(this)), this;
  }
  destroy() {
    this.emtType && this.mainEngine && this.mainEngine.internalMsgEmitter.off([this.emtType, this.emitEventType], this.collect.bind(this));
  }
  collectForLocalWorker(d) {
    var l, i, t;
    for (const [s, b] of d)
      (l = this.mainEngine) == null || l.queryTaskBatchData(b).forEach((Z) => {
        var o;
        (o = this.mainEngine) == null || o.taskBatchData.delete(Z);
      }), (i = this.mainEngine) == null || i.taskBatchData.add(s);
    (t = this.mainEngine) == null || t.runAnimation();
  }
  collectForServiceWorker(d) {
    gd(() => {
      d.forEach((l) => {
        var s, b, Z;
        (s = this.serviceColloctor) == null || s.dispatch(l);
        const { viewId: i, undoTickerId: t } = l;
        t && i && ((Z = (b = this.mainEngine) == null ? void 0 : b.internalMsgEmitter) == null || Z.emit("undoTickerEnd", t, i));
      });
    }, this.mainEngine.maxLastSyncTime);
  }
}
class NX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.ZIndexActive
    });
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workId: l, isActive: i, viewId: t } = d, s = this.control.viewContainerManager.getView(t);
    if (!(s != null && s.displayer))
      return;
    const b = s.focusScenePath, Z = [], o = [];
    l === Il && Z.push([{
      workId: l,
      msgType: Vl.UpdateNode,
      dataType: Jl.Local,
      isActiveZIndex: i,
      emitEventType: this.emitEventType,
      willRefreshSelector: !0,
      willSyncService: !1,
      viewId: t,
      scenePath: b
    }, {
      workId: l,
      msgType: Vl.UpdateNode,
      emitEventType: this.emitEventType
    }]), Z.length && this.collectForLocalWorker(Z), o.length && this.collectForServiceWorker(o);
  }
}
class TX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.CopyNode
    });
  }
  collect(d) {
    var b;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, viewId: i } = d, t = this.control.viewContainerManager.getView(i);
    if (!(t != null && t.displayer))
      return;
    const s = t.focusScenePath;
    for (const Z of l) {
      const o = Z.toString(), y = this.serviceColloctor.isLocalId(o) ? this.serviceColloctor.transformKey(Z) : o, X = (b = this.serviceColloctor.getStorageData(i, s)) == null ? void 0 : b[y];
      if (X) {
        if (Z === Il) {
          const W = X && this.copySelector({
            viewId: i,
            store: X
          });
          W && this.pasteSelector({
            ...W,
            viewId: i,
            scenePath: s
          });
          break;
        }
        if (X.toolsType === bl.Text && X.opt && X.opt.workState && X.opt.workState !== hl.Done) {
          const W = X && this.copyText({
            viewId: i,
            store: X
          });
          W && this.pasteText({
            ...W,
            viewId: i,
            scenePath: s,
            key: y,
            store: X
          });
          break;
        }
      }
    }
  }
  copyText(d) {
    const { viewId: l, store: i } = d, t = this.control.viewContainerManager.getView(l);
    if (!this.serviceColloctor || !t)
      return;
    const s = t == null ? void 0 : t.cameraOpt, b = s && [s.centerX, s.centerY], Z = i.opt, o = Z.boxPoint && Z.boxSize && [Z.boxPoint[0] + Z.boxSize[0] / 2, Z.boxPoint[1] + Z.boxSize[1] / 2];
    return {
      bgCenter: b,
      textCenter: o
    };
  }
  pasteText(d) {
    var L, u;
    const { bgCenter: l, textCenter: i, store: t, key: s, viewId: b, scenePath: Z } = d, o = this.control.viewContainerManager.getView(b);
    if (!this.serviceColloctor || !o)
      return;
    const G = Math.floor(Math.random() * 30 + 1), y = Date.now(), X = ((L = o.cameraOpt) == null ? void 0 : L.scale) || 1, W = l && i && [l[0] - i[0] + G, l[1] - i[1] + G] || [G / X, G / X], r = (this.serviceColloctor.isLocalId(s) ? s : this.serviceColloctor.getLocalId(s.toString())) + "-" + y;
    if (this.mainEngine.internalMsgEmitter.emit("undoTickerStart", y, b), t.toolsType === bl.Text && t.opt) {
      const V = t.opt;
      if (V && V.boxPoint && V.text) {
        V.workState = hl.Done;
        const c = V.boxPoint;
        V.boxPoint = [c[0] + W[0], c[1] + W[1]], V.workState = hl.Done;
        const n = this.control.viewContainerManager.transformToOriginPoint(V.boxPoint, b);
        this.control.textEditorManager.createTextForMasterController({
          workId: r,
          x: n[0],
          y: n[1],
          opt: V,
          scale: ((u = o.cameraOpt) == null ? void 0 : u.scale) || 1,
          type: ad.Text,
          isActive: !1,
          viewId: b,
          scenePath: Z
        }), this.collectForServiceWorker([{
          ...t,
          opt: V,
          type: Vl.FullWork,
          workId: r,
          viewId: b,
          scenePath: Z,
          undoTickerId: y
        }]);
      }
    }
  }
  copySelector(d) {
    var r, L, u, V, c, n, e, a;
    const { viewId: l, store: i } = d, t = this.control.viewContainerManager.getView(l), s = i.selectIds;
    if (!this.serviceColloctor || !(s != null && s.length) || !t)
      return;
    const b = /* @__PURE__ */ new Map(), Z = {
      offset: {
        x: 0,
        y: 0
      },
      cameraOpt: {
        centerX: ((r = t.cameraOpt) == null ? void 0 : r.centerX) || 0,
        centerY: ((L = t.cameraOpt) == null ? void 0 : L.centerY) || 0,
        scale: ((u = t.cameraOpt) == null ? void 0 : u.scale) || 1
      }
    }, o = (V = t.displayer.canvasBgRef.current) == null ? void 0 : V.getBoundingClientRect(), G = (n = (c = t.displayer) == null ? void 0 : c.floatBarCanvasRef.current) == null ? void 0 : n.getBoundingClientRect(), y = o && [o.x + o.width / 2, o.y + o.height / 2], X = G && [G.x + G.width / 2, G.y + G.height / 2], W = y && t.viewData && t.viewData.convertToPointInWorld({ x: y[0], y: y[1] }), h = X && t.viewData && t.viewData.convertToPointInWorld({ x: X[0], y: X[1] });
    W && h && (Z.offset = {
      x: W.x - h.x,
      y: W.y - h.y
    });
    for (const Y of s) {
      const R = (a = (e = this.serviceColloctor) == null ? void 0 : e.getStorageData(t.id, t.focusScenePath)) == null ? void 0 : a[Y];
      R && b.set(Y, R);
    }
    return {
      copyStores: b,
      copyCoordInfo: Z
    };
  }
  pasteSelector(d) {
    var L;
    const { copyStores: l, copyCoordInfo: i, viewId: t, scenePath: s } = d, b = this.control.viewContainerManager.getView(t);
    if (!l.size || !this.serviceColloctor || !b)
      return;
    const { offset: Z, cameraOpt: o } = i, { scale: G } = o, y = Math.floor(Math.random() * 30 + 1), X = [Z.x + y, Z.y + y], W = Date.now(), h = [], r = [];
    this.mainEngine.internalMsgEmitter.emit("undoTickerStart", W, t);
    for (const [u, V] of l.entries()) {
      const n = (this.serviceColloctor.isLocalId(u) ? u : this.serviceColloctor.getLocalId(u.toString())) + "-" + W, e = { useAnimation: !1 };
      if (V.toolsType === bl.Text && V.opt) {
        const a = V.opt;
        if (a && a.boxPoint && a.text) {
          a.workState = hl.Done;
          const Y = a.boxPoint;
          a.boxPoint = [Y[0] + X[0], Y[1] + X[1]], a.workState = hl.Done;
          const R = this.control.viewContainerManager.transformToOriginPoint(a.boxPoint, t);
          this.control.textEditorManager.createTextForMasterController({
            workId: n,
            x: R[0],
            y: R[1],
            opt: a,
            scale: ((L = b.cameraOpt) == null ? void 0 : L.scale) || 1,
            type: ad.Text,
            isActive: !1,
            viewId: t,
            scenePath: s
          });
        }
        r.push({
          ...V,
          opt: a,
          type: Vl.FullWork,
          workId: n,
          viewId: t,
          scenePath: s,
          undoTickerId: W
        });
        continue;
      }
      if (V.toolsType === bl.Image && (V.opt.uuid = n, V.opt.centerX = V.opt.centerX + X[0], V.opt.centerY = V.opt.centerY + X[1]), V.ops) {
        const a = Fs(V.ops).map((R, C) => {
          const N = C % 3;
          return N === 0 ? R + X[0] : N === 1 ? R + X[1] : R;
        }), Y = Hs(a);
        V.ops = Y;
      }
      r.push({
        ...V,
        updateNodeOpt: e,
        type: Vl.FullWork,
        workId: n,
        viewId: t,
        scenePath: s,
        undoTickerId: W
      }), h.push([{
        ...V,
        updateNodeOpt: e,
        workId: n,
        msgType: Vl.FullWork,
        dataType: Jl.Local,
        emitEventType: ul.CopyNode,
        willSyncService: !1,
        willRefresh: !0,
        viewId: t,
        undoTickerId: W
      }, { workId: n, msgType: Vl.FullWork, emitEventType: ul.CopyNode }]);
    }
    h.length && this.collectForLocalWorker(h), r.length && this.collectForServiceWorker(r);
  }
}
function ui(m, d, l) {
  return "#" + ((m << 16) + (d << 8) + l).toString(16).padStart(6, "0");
}
function id(m, d = 1) {
  return "rgba(" + parseInt("0x" + m.slice(1, 3)) + "," + parseInt("0x" + m.slice(3, 5)) + "," + parseInt("0x" + m.slice(5, 7)) + "," + d + ")";
}
function qd(m, d, l, i = 1) {
  return `rgba(${m},${d},${l},${i})`;
}
function Qi(m) {
  const d = m.split(","), l = parseInt(d[0].split("(")[1]), i = parseInt(d[1]), t = parseInt(d[2]), s = Number(d[3].split(")")[0]);
  return [ui(l, i, t), s];
}
function $d(m) {
  const d = m.split(","), l = parseInt(d[0].split("(")[1]), i = parseInt(d[1]), t = parseInt(d[2]), s = Number(d[3].split(")")[0]);
  return [l, i, t, s];
}
class FX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.SetColorNode
    });
  }
  setTextColor(d, l, i, t) {
    const { fontColor: s, fontBgColor: b } = i;
    l.opt && (s && (l.opt.fontColor = s), b && (l.opt.fontColor = b), this.control.textEditorManager.updateTextForMasterController({
      workId: d,
      opt: l.opt,
      viewId: t,
      canSync: !0,
      canWorker: !0
    }));
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, strokeColor: i, fillColor: t, fontColor: s, fontBgColor: b, viewId: Z } = d, o = this.control.viewContainerManager.getView(Z);
    if (!(o != null && o.displayer))
      return;
    const G = o.focusScenePath, y = [...l], X = this.serviceColloctor.storage, W = [], h = {};
    for (; y.length; ) {
      const r = y.pop();
      if (!r)
        continue;
      const L = r.toString(), u = this.serviceColloctor.isLocalId(L), V = u ? this.serviceColloctor.transformKey(r) : L;
      let c = L;
      !u && this.serviceColloctor.isOwn(c) && (c = this.serviceColloctor.getLocalId(c));
      const n = X[Z][G][V] || void 0;
      if (n) {
        const e = n.updateNodeOpt || {};
        if (s || b) {
          if (s) {
            e.fontColor = s;
            const [Y, R, C, N] = $d(s);
            h.textColor = [Y, R, C], h.textOpacity = N;
          }
          if (b) {
            e.fontBgColor = b;
            const [Y, R, C, N] = $d(b);
            h.textBgColor = [Y, R, C], h.textBgOpacity = N;
          }
          if (n.toolsType === bl.Text && n.opt) {
            this.setTextColor(c, El(n), e, Z);
            continue;
          }
        }
        if (i) {
          e.strokeColor = i;
          const [Y, R, C, N] = $d(i);
          h.strokeColor = [Y, R, C], h.strokeOpacity = N;
        }
        if (t) {
          e.fillColor = t;
          const [Y, R, C, N] = $d(t);
          h.fillColor = [Y, R, C], h.fillOpacity = N;
        }
        const a = {
          workId: c,
          msgType: Vl.UpdateNode,
          dataType: Jl.Local,
          updateNodeOpt: e,
          emitEventType: this.emitEventType,
          willRefresh: !0,
          willRefreshSelector: !0,
          willSyncService: !0,
          textUpdateForWoker: !0,
          viewId: Z
          // undoTickerId
        };
        W.push([a, {
          workId: c,
          msgType: Vl.UpdateNode,
          emitEventType: this.emitEventType
        }]);
      }
    }
    W.length && this.collectForLocalWorker(W), Object.keys(h).length && setTimeout(() => {
      var r;
      (r = this.control.room) == null || r.setMemberState(h);
    }, 0);
  }
}
class HX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.ZIndexNode
    }), Object.defineProperty(this, "min", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "max", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  get minZIndex() {
    return this.min;
  }
  get maxZIndex() {
    return this.max;
  }
  set maxZIndex(d) {
    this.max = d;
  }
  set minZIndex(d) {
    this.min = d;
  }
  addMaxLayer() {
    this.max = this.max + 1;
  }
  addMinLayer() {
    this.min = this.min - 1;
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, layer: i, viewId: t } = d, s = this.control.viewContainerManager.getView(t);
    if (!(s != null && s.displayer))
      return;
    const b = s.focusScenePath, Z = [...l], o = this.serviceColloctor.storage, G = [], y = [];
    for (; Z.length; ) {
      const W = Z.pop();
      if (!W)
        continue;
      const h = W.toString(), r = this.serviceColloctor.isLocalId(h), L = r ? this.serviceColloctor.transformKey(W) : h;
      let u = h;
      !r && this.serviceColloctor.isOwn(u) && (u = this.serviceColloctor.getLocalId(u));
      const V = El(o[t][b][L]);
      let c;
      if (V && u === Il) {
        if (V.selectIds) {
          y.push(...V.selectIds), y.sort((Y, R) => {
            var I, J, T, K;
            const C = ((J = (I = o[X(Y, this.serviceColloctor)]) == null ? void 0 : I.opt) == null ? void 0 : J.zIndex) || 0, N = ((K = (T = o[X(Y, this.serviceColloctor)]) == null ? void 0 : T.opt) == null ? void 0 : K.zIndex) || 0;
            return C > N ? 1 : Y < R ? -1 : 0;
          });
          const n = V.updateNodeOpt || {};
          n.zIndexLayer = i;
          const e = {
            workId: W,
            msgType: Vl.UpdateNode,
            dataType: Jl.Local,
            updateNodeOpt: n,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0,
            viewId: t
          }, a = /* @__PURE__ */ new Map();
          i === Cd.Top ? (this.addMaxLayer(), c = this.max) : (this.addMinLayer(), c = this.min), y.forEach((Y) => {
            var I, J, T;
            const R = (I = this.serviceColloctor) == null ? void 0 : I.isLocalId(Y);
            let C = R && ((J = this.serviceColloctor) == null ? void 0 : J.transformKey(Y)) || Y;
            const N = o[t][b][C];
            !R && ((T = this.serviceColloctor) != null && T.isOwn(C)) && (C = this.serviceColloctor.getLocalId(C)), n.zIndex = c, N != null && N.opt && (N.opt.zIndex = c), N != null && N.opt && a.set(C, {
              updateNodeOpt: N.updateNodeOpt,
              opt: N.opt
            });
          }), e.selectStore = a, e.willSerializeData = !0, G.push([e, {
            workId: W,
            msgType: Vl.UpdateNode,
            emitEventType: this.emitEventType
          }]);
        }
        continue;
      }
    }
    G.length && this.collectForLocalWorker(G);
    function X(W, h) {
      return h.isLocalId(W) && h.transformKey(W) || W;
    }
  }
}
class MX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.TranslateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(d) {
    var L, u, V, c;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, position: i, workState: t, viewId: s } = d, b = this.control.viewContainerManager.getView(s);
    if (!(b != null && b.displayer))
      return;
    const Z = b.focusScenePath, o = [...l], G = (L = this.serviceColloctor) == null ? void 0 : L.storage, y = [], X = (u = b.displayer.canvasBgRef.current) == null ? void 0 : u.getBoundingClientRect(), W = (c = (V = b.displayer) == null ? void 0 : V.floatBarCanvasRef.current) == null ? void 0 : c.getBoundingClientRect();
    let h = !1;
    const r = t === hl.Start && Date.now() || void 0;
    for (r && (this.undoTickerId = r, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", r, s)), X && W && this.oldRect && (this.oldRect.x < X.x && W.x > this.oldRect.x || this.oldRect.y < X.y && W.y > this.oldRect.y || this.oldRect.x + this.oldRect.width > X.x + X.width && W.x < this.oldRect.x || this.oldRect.y + this.oldRect.height > X.y + X.height && W.y < this.oldRect.y) && (h = !0), W && (this.oldRect = W); o.length; ) {
      const n = o.pop();
      if (!n)
        continue;
      const e = n.toString(), a = this.serviceColloctor.isLocalId(e), Y = a && this.serviceColloctor.transformKey(n) || e;
      let R = e;
      !a && this.serviceColloctor.isOwn(R) && (R = this.serviceColloctor.getLocalId(R));
      const C = G[s][Z][Y];
      if (C && R === Il) {
        if (C.selectIds && (t === hl.Start && (this.cachePosition = i), this.cachePosition)) {
          const N = C.updateNodeOpt || {};
          N.translate = [i.x - this.cachePosition.x, i.y - this.cachePosition.y], N.workState = t;
          const I = {
            workId: n,
            msgType: Vl.UpdateNode,
            dataType: Jl.Local,
            updateNodeOpt: N,
            emitEventType: this.emitEventType,
            willRefreshSelector: h,
            willSyncService: !0,
            textUpdateForWoker: !1,
            viewId: s
          };
          t === hl.Done && (I.willRefreshSelector = !0, I.textUpdateForWoker = !0, I.willSerializeData = !0, I.undoTickerId = this.undoTickerId, this.cachePosition = void 0), y.push([I, {
            workId: n,
            msgType: Vl.UpdateNode,
            emitEventType: this.emitEventType
          }]);
        }
        continue;
      }
    }
    y.length && (console.log("TranslateNode", y), this.collectForLocalWorker(y));
  }
}
class zX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.DeleteNode
    });
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, viewId: i } = d, t = this.control.viewContainerManager.getView(i);
    if (!(t != null && t.displayer))
      return;
    const s = t.focusScenePath, b = this.serviceColloctor.storage, Z = [...l], o = [], G = [], y = Date.now();
    for (; Z.length; ) {
      const X = Z.pop();
      if (!X)
        continue;
      const W = X.toString(), h = this.serviceColloctor.isLocalId(W), r = h ? this.serviceColloctor.transformKey(X) : W, L = b[i][s][r];
      if (L) {
        let u = W;
        if (!h && this.serviceColloctor.isOwn(u) && (u = this.serviceColloctor.getLocalId(u)), L.toolsType === bl.Text) {
          this.control.textEditorManager.delete(u, !0, !0);
          continue;
        }
        G.push(u);
      }
    }
    G.length && (o.push([{
      msgType: Vl.RemoveNode,
      emitEventType: ul.DeleteNode,
      removeIds: G,
      dataType: Jl.Local,
      willSyncService: !0,
      willRefresh: !0,
      undoTickerId: y,
      viewId: i
    }, void 0]), this.mainEngine.internalMsgEmitter.emit("undoTickerStart", y, i), this.collectForLocalWorker(o));
  }
}
class gX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.ScaleNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "targetBox", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "targetText", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "cacheTextInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
  }
  async collect(d) {
    var h, r, L, u, V;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, box: i, workState: t, viewId: s, dir: b } = d, Z = this.control.viewContainerManager.getView(s);
    if (!(Z != null && Z.displayer))
      return;
    const o = Z.focusScenePath, G = [...l], y = (h = this.serviceColloctor) == null ? void 0 : h.storage, X = [], W = t === hl.Start && Date.now() || void 0;
    for (W && (this.undoTickerId = W, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", W, s)); G.length; ) {
      const c = G.pop();
      if (!c)
        continue;
      const n = c.toString(), e = this.serviceColloctor.isLocalId(n), a = e && this.serviceColloctor.transformKey(c) || n;
      let Y = n;
      !e && this.serviceColloctor.isOwn(Y) && (Y = this.serviceColloctor.getLocalId(Y));
      const R = y[s][o][a];
      if (R && Y === Il && R.selectIds) {
        const C = R.updateNodeOpt || {};
        if (C.dir = b, C.box = i, C.workState = t, t === hl.Start && i) {
          for (const I of R.selectIds) {
            const J = (r = this.serviceColloctor) == null ? void 0 : r.isLocalId(I), T = J && ((L = this.serviceColloctor) == null ? void 0 : L.transformKey(I)) || I;
            let K = T;
            !J && ((u = this.serviceColloctor) != null && u.isOwn(T)) && (K = this.serviceColloctor.getLocalId(T));
            const S = this.control.textEditorManager.get(K);
            S && t === hl.Start && this.targetText.set(K, El(S));
          }
          this.targetText.size && this.targetBox.set(Y, i);
        }
        if (this.targetText.size && t !== hl.Start) {
          const I = this.targetBox.get(Y);
          if (I) {
            const J = [i.w / I.w, i.h / I.h];
            for (const [T, K] of this.targetText.entries()) {
              const { opt: S } = K, H = Math.floor(S.fontSize * J[0]), w = this.cacheTextInfo.get(T), P = !w && S.fontSize !== H || w && w.fontSize !== H || !1, B = (V = this.control.textEditorManager.get(T)) == null ? void 0 : V.opt;
              if (P && B && S.boxSize && S.boxPoint) {
                const D = await this.control.textEditorManager.updateTextControllerWithEffectAsync({
                  workId: T,
                  opt: { ...B, fontSize: H },
                  viewId: s,
                  canSync: !1,
                  canWorker: !1
                });
                D && this.cacheTextInfo.set(T, {
                  fontSize: D.opt.fontSize,
                  boxSize: D.opt.boxSize,
                  boxPoint: D.opt.boxPoint
                });
              }
            }
            C.textInfos = this.cacheTextInfo;
          }
        }
        const N = {
          workId: c,
          msgType: Vl.UpdateNode,
          dataType: Jl.Local,
          updateNodeOpt: C,
          emitEventType: this.emitEventType,
          willRefreshSelector: !0,
          willSyncService: !0,
          viewId: s
        };
        t === hl.Done && (N.willSerializeData = !0, N.undoTickerId = this.undoTickerId, this.targetBox.delete(Y), this.targetText.clear()), X.push([N, {
          workId: c,
          msgType: Vl.UpdateNode,
          emitEventType: this.emitEventType
        }]);
        continue;
      }
    }
    X.length && this.collectForLocalWorker(X);
  }
}
class kX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.RotateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cacheOriginRotate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  collect(d) {
    var W, h, r, L, u;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, angle: i, workState: t, viewId: s } = d, b = this.control.viewContainerManager.getView(s);
    if (!(b != null && b.displayer))
      return;
    const Z = b.focusScenePath, o = [...l], G = (W = this.serviceColloctor) == null ? void 0 : W.storage, y = [], X = t === hl.Start && Date.now() || void 0;
    for (X && (this.undoTickerId = X, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", X, s)); o.length; ) {
      const V = o.pop();
      if (!V)
        continue;
      const c = V.toString(), n = this.serviceColloctor.isLocalId(c), e = n && this.serviceColloctor.transformKey(V) || c;
      let a = c;
      !n && this.serviceColloctor.isOwn(a) && (a = this.serviceColloctor.getLocalId(a));
      const Y = G[s][Z][e];
      if (Y && a === Il) {
        if (((h = Y.selectIds) == null ? void 0 : h.length) === 1) {
          const R = Y.selectIds[0];
          if (t === hl.Start) {
            const J = ((r = this.serviceColloctor) == null ? void 0 : r.isLocalId(R)) && ((L = this.serviceColloctor) == null ? void 0 : L.transformKey(R)) || R, T = G[s][Z][J];
            this.cacheOriginRotate = ((u = T == null ? void 0 : T.opt) == null ? void 0 : u.rotate) || 0;
          }
          const C = Y.updateNodeOpt || {};
          C.angle = (i + this.cacheOriginRotate) % 360, C.workState = t;
          const N = {
            workId: V,
            msgType: Vl.UpdateNode,
            dataType: Jl.Local,
            updateNodeOpt: C,
            emitEventType: this.emitEventType,
            willRefreshSelector: !1,
            willSyncService: !0,
            viewId: s
          };
          t === hl.Done && (N.willRefreshSelector = !0, N.willSerializeData = !0, N.undoTickerId = this.undoTickerId, this.cacheOriginRotate = 0), y.push([N, {
            workId: V,
            msgType: Vl.UpdateNode,
            emitEventType: this.emitEventType
          }]);
        }
        continue;
      }
    }
    y.length && this.collectForLocalWorker(y);
  }
}
function vX(m) {
  switch (m) {
    case bl.Text:
      return ad.Text;
    case bl.SpeechBalloon:
    case bl.Star:
    case bl.Ellipse:
    case bl.Rectangle:
    case bl.Triangle:
    case bl.Rhombus:
    case bl.Polygon:
      return ad.Shape;
  }
}
class UX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.SetFontStyle
    });
  }
  setTextStyle(d, l, i, t, s) {
    const { bold: b, underline: Z, lineThrough: o, italic: G, fontSize: y } = i;
    if (l.toolsType) {
      const X = vX(l.toolsType);
      X === ad.Text && (l.opt && (b && (l.opt.bold = b), md(Z) && (l.opt.underline = Z), md(o) && (l.opt.lineThrough = o), G && (l.opt.italic = G), y && (l.opt.fontSize = y)), this.control.textEditorManager.updateTextForMasterController({
        workId: d,
        opt: l.opt,
        viewId: t,
        canSync: !0,
        canWorker: !0
      }, s)), ad.Shape;
    }
  }
  collect(d) {
    var r, L, u, V;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, bold: i, italic: t, lineThrough: s, underline: b, viewId: Z, fontSize: o } = d, G = this.control.viewContainerManager.getView(Z);
    if (!(G != null && G.displayer))
      return;
    const y = G.focusScenePath, X = [...l], W = this.serviceColloctor.storage, h = {};
    for (; X.length; ) {
      const c = X.pop();
      if (!c)
        continue;
      const n = c.toString(), e = this.serviceColloctor.isLocalId(n), a = e ? this.serviceColloctor.transformKey(c) : n;
      let Y = n;
      !e && this.serviceColloctor.isOwn(Y) && (Y = this.serviceColloctor.getLocalId(Y));
      const R = W[Z][y][a] || void 0;
      if (R) {
        const C = R.updateNodeOpt || {};
        if (i && (C.bold = i, h.bold = i === "bold"), t && (C.italic = t, h.italic = t === "italic"), md(s) && (C.lineThrough = s, h.lineThrough = s), md(b) && (C.underline = b, h.underline = b), o && (C.fontSize = o, h.textSize = o), R.toolsType === bl.Text && R.opt) {
          this.setTextStyle(Y, El(R), C, Z);
          continue;
        }
        if (R && Y === Il && ((r = R.selectIds) != null && r.length))
          for (const N of R.selectIds) {
            const I = (L = this.serviceColloctor) == null ? void 0 : L.isLocalId(N);
            let J = I && ((u = this.serviceColloctor) == null ? void 0 : u.transformKey(N)) || N;
            const T = W[Z][y][J] || void 0;
            if (!I && ((V = this.serviceColloctor) != null && V.isOwn(J)) && (J = this.serviceColloctor.getLocalId(J)), T && T.toolsType === bl.Text && R.opt) {
              this.setTextStyle(J, El(T), C, Z);
              continue;
            }
          }
      }
    }
    Object.keys(h).length && setTimeout(() => {
      var c;
      (c = this.control.room) == null || c.setMemberState(h);
    }, 0);
  }
}
class QX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.SetPoint
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(d) {
    var V;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workId: l, pointMap: i, workState: t, viewId: s } = d, b = this.control.viewContainerManager.getView(s);
    if (!(b != null && b.displayer))
      return;
    const Z = b.focusScenePath, o = (V = this.serviceColloctor) == null ? void 0 : V.storage, G = [], y = t === hl.Start && Date.now() || void 0;
    y && (this.undoTickerId = y, this.mainEngine.internalMsgEmitter.emit("undoTickerStart", y, s));
    const X = l;
    if (!X)
      return;
    const W = X.toString(), h = this.serviceColloctor.isLocalId(W), r = h && this.serviceColloctor.transformKey(X) || W;
    let L = W;
    !h && this.serviceColloctor.isOwn(L) && (L = this.serviceColloctor.getLocalId(L));
    const u = o[s][Z][r];
    if (u && L === Il && u.selectIds) {
      const c = u.updateNodeOpt || {};
      c.pointMap = i, c.workState = t;
      const n = {
        workId: X,
        msgType: Vl.UpdateNode,
        dataType: Jl.Local,
        updateNodeOpt: c,
        emitEventType: this.emitEventType,
        willRefreshSelector: !0,
        willSyncService: !0,
        viewId: s
      };
      t === hl.Done && (n.undoTickerId = this.undoTickerId), G.push([n, {
        workId: X,
        msgType: Vl.UpdateNode,
        emitEventType: this.emitEventType
      }]);
    }
    G.length && this.collectForLocalWorker(G);
  }
}
class wX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.SetLock
    });
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, isLocked: i, viewId: t } = d, s = this.control.viewContainerManager.getView(t);
    if (!(s != null && s.displayer))
      return;
    const b = s.focusScenePath, Z = [...l], o = this.serviceColloctor.storage, G = [], y = Date.now();
    for (; Z.length; ) {
      const X = Z.pop();
      if (!X)
        continue;
      const W = X.toString(), h = this.serviceColloctor.isLocalId(W), r = h ? this.serviceColloctor.transformKey(X) : W;
      let L = W;
      !h && this.serviceColloctor.isOwn(L) && (L = this.serviceColloctor.getLocalId(L));
      const u = o[t][b][r] || void 0;
      if (u) {
        const V = u.updateNodeOpt || {};
        V.isLocked = i;
        const c = {
          workId: L,
          msgType: Vl.UpdateNode,
          dataType: Jl.Local,
          updateNodeOpt: V,
          emitEventType: this.emitEventType,
          willRefresh: !0,
          willRefreshSelector: !0,
          willSyncService: !0,
          viewId: t
        };
        G.push([c, {
          workId: L,
          msgType: Vl.UpdateNode,
          emitEventType: this.emitEventType
        }]);
      }
    }
    this.mainEngine.internalMsgEmitter.emit("undoTickerStart", y, t), G.length && this.collectForLocalWorker(G);
  }
}
class PX extends ed {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.SetShapeOpt
    });
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, viewId: i, ...t } = d, s = this.control.viewContainerManager.getView(i);
    if (!(s != null && s.displayer))
      return;
    const b = s.focusScenePath, Z = [...l], o = this.serviceColloctor.storage, G = [];
    for (; Z.length; ) {
      const y = Z.pop();
      if (!y)
        continue;
      const X = y.toString(), W = this.serviceColloctor.isLocalId(X), h = W ? this.serviceColloctor.transformKey(y) : X;
      let r = X;
      !W && this.serviceColloctor.isOwn(r) && (r = this.serviceColloctor.getLocalId(r));
      const L = o[i][b][h] || void 0;
      if (L) {
        const u = {
          ...L.updateNodeOpt,
          ...t,
          willRefresh: !0
        };
        if (L && r === Il) {
          const V = {
            workId: r,
            msgType: Vl.UpdateNode,
            dataType: Jl.Local,
            updateNodeOpt: u,
            emitEventType: this.emitEventType,
            willRefresh: !0,
            willRefreshSelector: !0,
            willSyncService: !0,
            viewId: i
            // undoTickerId
          };
          G.push([V, {
            workId: r,
            msgType: Vl.UpdateNode,
            emitEventType: this.emitEventType
          }]);
        }
      }
    }
    G.length && this.collectForLocalWorker(G);
  }
}
class xl {
  constructor(d) {
    Object.defineProperty(this, "builders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), this.builders = new Map(d.map((l) => [l, this.build(l)]));
  }
  build(d) {
    switch (d) {
      case ul.TranslateNode:
        return new MX();
      case ul.ZIndexNode:
        return new HX();
      case ul.ZIndexActive:
        return new NX();
      case ul.CopyNode:
        return new TX();
      case ul.SetColorNode:
        return new FX();
      case ul.DeleteNode:
        return new zX();
      case ul.ScaleNode:
        return new gX();
      case ul.RotateNode:
        return new kX();
      case ul.SetFontStyle:
        return new UX();
      case ul.SetPoint:
        return new QX();
      case ul.SetLock:
        return new wX();
      case ul.SetShapeOpt:
        return new PX();
    }
  }
  getBuilder(d) {
    return this.builders.get(d);
  }
  registerForMainEngine(d, l) {
    return this.builders.forEach((i) => {
      i && i.registerForMainEngine(d, l);
    }), this;
  }
  destroy() {
    this.builders.forEach((d) => {
      d && d.destroy();
    });
  }
  static emitMethod(d, l, i) {
    ed.dispatch(d, l, i);
  }
}
class fX {
  constructor() {
    Object.defineProperty(this, "maxLastSyncTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 500
    });
  }
  /** 设置当前选中的工具配置数据 */
  setCurrentToolsData(d) {
    this.currentToolsData = d;
  }
  /** 设置当前绘制任务数据 */
  setCurrentLocalWorkData(d) {
    this.currentLocalWorkData = d;
  }
  /** 获取当前激活的工作任务id */
  getWorkId() {
    return this.currentLocalWorkData.workId;
  }
}
class jX extends fX {
  constructor(d) {
    var t, s;
    super(), Object.defineProperty(this, "isActive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "currentToolsData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "currentLocalWorkData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localPointsBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "taskBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "fullWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "methodBuilder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "zIndexNodeMethod", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorkerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "wokerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "maxDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "cacheDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "reRenders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "tasksqueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "useTasksqueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "useTasksClockId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mianTasksqueueCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workerTasksqueueCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "snapshotMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "boundingRectMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "clearAllResolve", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localEventTimerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { control: l, internalMsgEmitter: i } = d;
    this.control = l, this.maxLastSyncTime = (((s = (t = this.control.pluginOptions) == null ? void 0 : t.syncOpt) == null ? void 0 : s.interval) || this.maxLastSyncTime) * 0.5, this.internalMsgEmitter = i, this.currentLocalWorkData = { workState: hl.Pending };
  }
  get viewContainerManager() {
    return this.control.viewContainerManager;
  }
  get collector() {
    return this.control.collector;
  }
  get isRunSubWork() {
    var l;
    const d = (l = this.currentToolsData) == null ? void 0 : l.toolsType;
    return d === bl.Pencil || d === bl.LaserPen || d === bl.Arrow || d === bl.Straight || d === bl.Ellipse || d === bl.Rectangle || d === bl.Star || d === bl.Polygon || d === bl.SpeechBalloon;
  }
  get isCanDrawWork() {
    var l;
    const d = (l = this.currentToolsData) == null ? void 0 : l.toolsType;
    return d === bl.Pencil || d === bl.LaserPen || d === bl.Arrow || d === bl.Straight || d === bl.Ellipse || d === bl.Rectangle || d === bl.Star || d === bl.Polygon || d === bl.SpeechBalloon || d === bl.Triangle || d === bl.Rhombus;
  }
  get isUseZIndex() {
    var l;
    const d = (l = this.currentToolsData) == null ? void 0 : l.toolsType;
    return d === bl.Pencil || d === bl.Arrow || d === bl.Straight || d === bl.Ellipse || d === bl.Rectangle || d === bl.Star || d === bl.Polygon || d === bl.SpeechBalloon || d === bl.Text || d === bl.Image;
  }
  get isCanRecordUndoRedo() {
    var l;
    const d = (l = this.currentToolsData) == null ? void 0 : l.toolsType;
    return d === bl.Pencil || d === bl.Eraser || d === bl.Arrow || d === bl.Straight || d === bl.Ellipse || d === bl.Rectangle || d === bl.Star || d === bl.Polygon || d === bl.SpeechBalloon || d === bl.Text || d === bl.Image;
  }
  get isCanSentCursor() {
    var l;
    const d = (l = this.currentToolsData) == null ? void 0 : l.toolsType;
    return d === bl.Pencil || d === bl.Text || d === bl.LaserPen || d === bl.Arrow || d === bl.Straight || d === bl.Ellipse || d === bl.Rectangle || d === bl.Star || d === bl.Polygon || d === bl.SpeechBalloon || d === bl.Triangle || d === bl.Rhombus;
  }
  init() {
    this.on(), this.internalMsgEmitterListener(), this.isActive = !0;
  }
  on() {
    this.fullWorker = new CX(), this.subWorker = new JX(), this.fullWorker.onmessage = (d) => {
      if (d.data) {
        const { render: l, sp: i, drawCount: t, workerTasksqueueCount: s } = d.data;
        if (s && (this.workerTasksqueueCount = s), i != null && i.length && this.collectorSyncData(i), !t && (l != null && l.length)) {
          this.viewContainerManager.render(l);
          return;
        }
        t && (this.wokerDrawCount = t, this.wokerDrawCount < 1 / 0 ? this.maxDrawCount = Math.max(this.maxDrawCount, this.wokerDrawCount) : this.maxDrawCount = 0, l != null && l.length && (this.viewContainerManager.render(l), this.wokerDrawCount < this.subWorkerDrawCount && (this.reRenders.forEach((b) => {
          b.isUnClose = !1;
        }), this.viewContainerManager.render(this.reRenders), this.reRenders.length = 0)));
      }
    }, this.subWorker.onmessage = (d) => {
      if (d.data) {
        const { render: l, drawCount: i, sp: t } = d.data;
        if (t != null && t.length && this.collectorSyncData(t), !i && (l != null && l.length)) {
          this.viewContainerManager.render(l);
          return;
        }
        i && (this.subWorkerDrawCount = i, this.wokerDrawCount < 1 / 0 && (this.maxDrawCount = Math.max(this.maxDrawCount, this.subWorkerDrawCount)), l != null && l.length && (this.subWorkerDrawCount > this.wokerDrawCount && (l.forEach((s) => s.isUnClose = !0), this.reRenders.push(...l)), this.wokerDrawCount < 1 / 0 && this.viewContainerManager.render(l)));
      }
    };
  }
  collectorSyncData(d) {
    var i, t;
    let l = !1;
    for (const s of d) {
      const { type: b, selectIds: Z, opt: o, selectRect: G, strokeColor: y, fillColor: X, willSyncService: W, isSync: h, undoTickerId: r, imageBitmap: L, canvasHeight: u, canvasWidth: V, rect: c, op: n, canTextEdit: e, points: a, selectorColor: Y, canRotate: R, scaleType: C, textOpt: N, toolsType: I, workId: J, viewId: T, scenePath: K, dataType: S, canLock: H, isLocked: w, shapeOpt: P, toolsTypes: B } = s;
      if (!T) {
        console.error("collectorSyncData", s);
        return;
      }
      switch (b) {
        case Vl.Select: {
          const D = Z != null && Z.length ? { ...G, selectIds: Z, canvasHeight: u, canvasWidth: V, points: a } : void 0;
          if (D && (o != null && o.strokeColor) && (D.selectorColor = o.strokeColor), D && Y && (D.selectorColor = Y), D && y && (D.strokeColor = y), D && (o != null && o.fillColor) && (D.fillColor = o.fillColor), D && X && (D.fillColor = X), D && md(R) && (D.canRotate = R), D && C && (D.scaleType = C), D && e && (D.canTextEdit = e), D && N && (D.textOpt = N), D && md(H) && (D.canLock = H), D && md(w) && (D.isLocked = w), D && P && (D.shapeOpt = P), D && B && (D.toolsTypes = B), T && this.viewContainerManager.showFloatBar(T, !!D, D), W) {
            const z = this.viewContainerManager.getCurScenePath(T);
            (i = this.collector) == null || i.dispatch({ type: b, selectIds: Z, opt: o, isSync: h, viewId: T, scenePath: z });
          }
          break;
        }
        case Vl.Snapshot:
          if (L && K) {
            const D = this.snapshotMap.get(K);
            D && D(L);
          }
          break;
        case Vl.BoundingBox:
          if (c && K) {
            const D = this.boundingRectMap.get(K);
            D && D(c);
          }
          break;
        case Vl.Cursor:
          n && this.control.cursor.collectServiceCursor({ ...s });
          break;
        case Vl.Clear:
          T && this.viewContainerManager.showFloatBar(T, !1), T && this.clearAllResolve && this.clearAllResolve(T);
          break;
        case Vl.TextUpdate:
          if (I === bl.Text && J && T) {
            const D = this.viewContainerManager.transformToOriginPoint((o == null ? void 0 : o.boxPoint) || [0, 0], T), z = (o == null ? void 0 : o.boxSize) || [0, 0], U = (t = this.viewContainerManager.getView(T)) == null ? void 0 : t.cameraOpt;
            o ? this.control.textEditorManager.updateTextForWorker({
              x: D[0],
              y: D[1],
              w: z[0],
              h: z[1],
              scale: (U == null ? void 0 : U.scale) || 1,
              workId: J,
              opt: o,
              dataType: S,
              viewId: T,
              canSync: W || !1,
              canWorker: !1
            }) : this.control.textEditorManager.delete(J, W || !1, !1);
          }
          break;
        case Vl.GetTextActive:
          I === bl.Text && J && T && this.control.textEditorManager.updateTextForWorker({
            workId: J,
            isActive: !0,
            viewId: T,
            dataType: Jl.Local,
            canWorker: !1,
            canSync: !0
          }, Date.now());
          break;
        default:
          l = !0;
          break;
      }
      !l && r && this.internalMsgEmitter.emit("undoTickerEnd", r, T);
    }
    l && gd(() => {
      this.collectorAsyncData(d);
    }, this.maxLastSyncTime);
  }
  collectorAsyncData(d) {
    var l, i, t, s;
    for (const b of d) {
      const { type: Z, op: o, workId: G, index: y, removeIds: X, ops: W, opt: h, updateNodeOpt: r, toolsType: L, isSync: u, undoTickerId: V, viewId: c } = b;
      if (!c) {
        console.error("collectorAsyncData", b);
        return;
      }
      switch (Z) {
        case Vl.DrawWork: {
          const n = this.viewContainerManager.getCurScenePath(c);
          (l = this.collector) == null || l.dispatch({
            type: Z,
            op: o,
            workId: G,
            index: y,
            isSync: u,
            viewId: c,
            scenePath: n
          });
          break;
        }
        case Vl.FullWork: {
          const n = this.viewContainerManager.getCurScenePath(c);
          (i = this.collector) == null || i.dispatch({
            type: Z,
            ops: W,
            workId: G,
            updateNodeOpt: r,
            opt: h,
            toolsType: L,
            isSync: u,
            viewId: c,
            scenePath: n
          });
          break;
        }
        case Vl.UpdateNode: {
          const n = this.viewContainerManager.getCurScenePath(c);
          (t = this.collector) == null || t.dispatch({ type: Z, updateNodeOpt: r, workId: G, opt: h, ops: W, op: o, isSync: u, viewId: c, scenePath: n });
          break;
        }
        case Vl.RemoveNode: {
          const n = this.viewContainerManager.getCurScenePath(c);
          X && this.control.textEditorManager.deleteBatch(X, !1, !1), (s = this.collector) == null || s.dispatch({ type: Z, removeIds: X, isSync: u, viewId: c, scenePath: n });
          break;
        }
      }
      V && this.internalMsgEmitter.emit("undoTickerEnd", V, c);
    }
  }
  setCurrentToolsData(d) {
    var s, b, Z;
    const l = d.toolsType, i = ((s = this.currentToolsData) == null ? void 0 : s.toolsType) !== d.toolsType;
    super.setCurrentToolsData(d);
    const t = (b = this.viewContainerManager) == null ? void 0 : b.getAllViews();
    if (i) {
      for (const o of t)
        if (o) {
          const { id: G, focusScenePath: y } = o;
          i && G && y && ((Z = this.collector) != null && Z.hasSelector(G, y) && this.blurSelector(G, y), this.control.textEditorManager.checkEmptyTextBlur());
        }
      this.taskBatchData.add({
        msgType: Vl.UpdateTools,
        dataType: Jl.Local,
        toolsType: l,
        opt: { ...d.toolsOpt, syncUnitTime: this.maxLastSyncTime },
        isRunSubWork: this.isRunSubWork,
        viewId: Ts
      }), this.runAnimation();
    }
  }
  setCurrentLocalWorkData(d, l = Vl.None) {
    var b, Z;
    super.setCurrentLocalWorkData(d);
    const { workState: i, workId: t, toolsOpt: s } = d;
    if (i !== hl.Unwritable && l !== Vl.None && this.viewContainerManager.focuedView) {
      const { id: o } = this.viewContainerManager.focuedView;
      if (o) {
        const G = (b = this.currentToolsData) == null ? void 0 : b.toolsType;
        this.taskBatchData.add({
          msgType: l,
          workId: t,
          toolsType: G,
          opt: { ...(Z = this.currentToolsData) == null ? void 0 : Z.toolsOpt, ...s, syncUnitTime: this.maxLastSyncTime },
          dataType: Jl.Local,
          isRunSubWork: this.isRunSubWork,
          viewId: o
        }), this.runAnimation();
      }
    }
  }
  createViewWorker(d, l) {
    const { offscreenCanvasOpt: i, layerOpt: t, dpr: s, cameraOpt: b } = l;
    this.taskBatchData.add({
      msgType: Vl.Init,
      dataType: Jl.Local,
      viewId: d,
      offscreenCanvasOpt: i,
      layerOpt: t,
      dpr: s,
      cameraOpt: b,
      isRunSubWork: !0,
      isSafari: navigator.userAgent.indexOf("Safari") !== -1 && navigator.userAgent.indexOf("Chrome") === -1
    }), this.runAnimation();
  }
  destroyViewWorker(d, l = !1) {
    var i;
    this.taskBatchData.add({
      msgType: Vl.Destroy,
      dataType: Jl.Local,
      viewId: d,
      isRunSubWork: !0
    }), this.runAnimation(), l || (i = this.collector) == null || i.dispatch({
      type: Vl.Clear,
      viewId: d
    });
  }
  onServiceDerive(d, l) {
    var y, X, W, h;
    const { newValue: i, oldValue: t, viewId: s, scenePath: b } = l, Z = El(i) || {}, o = d;
    let G = Z.type;
    if (!(!i && t && (G = Vl.RemoveNode, t.toolsType === bl.LaserPen))) {
      if (G && o) {
        const r = Z;
        if (r.workId = (y = this.collector) != null && y.isOwn(o) ? (X = this.collector) == null ? void 0 : X.getLocalId(o) : o, r.msgType = G, r.dataType = Jl.Service, r.viewId = s, r.scenePath = b, r.selectIds && (r.selectIds = r.selectIds.map((L) => {
          var u, V;
          return (u = this.collector) != null && u.isOwn(L) ? (V = this.collector) == null ? void 0 : V.getLocalId(L) : L;
        })), r && r.toolsType === bl.Text || (t == null ? void 0 : t.toolsType) === bl.Text) {
          console.log("onServiceDerive", r, o, (W = this.collector) == null ? void 0 : W.uid), this.control.textEditorManager.onServiceDerive(r);
          return;
        }
        this.taskBatchData.add(r);
      }
      if (this.runAnimation(), this.zIndexNodeMethod) {
        let r, L;
        l.newValue && ((h = l.newValue.opt) != null && h.zIndex) && (L = Math.max(L || 0, l.newValue.opt.zIndex), r = Math.min(r || 1 / 0, l.newValue.opt.zIndex)), L && (this.zIndexNodeMethod.maxZIndex = L), r && (this.zIndexNodeMethod.minZIndex = r);
      }
    }
  }
  pullServiceData(d, l) {
    var t, s, b, Z, o, G, y;
    const i = ((t = this.collector) == null ? void 0 : t.storage[d]) && ((s = this.collector) == null ? void 0 : s.storage[d][l]) || void 0;
    if (i) {
      let X, W;
      const h = Object.keys(i);
      for (const r of h) {
        const L = (b = i[r]) == null ? void 0 : b.type;
        if (L && r) {
          const u = El(i[r]);
          if (u.workId = (Z = this.collector) != null && Z.isOwn(r) ? (o = this.collector) == null ? void 0 : o.getLocalId(r) : r, u.msgType = L, u.dataType = Jl.Service, u.viewId = d, u.scenePath = l, u.useAnimation = !1, u.selectIds && (u.selectIds = u.selectIds.map((V) => {
            var c, n;
            return (c = this.collector) != null && c.isOwn(V) ? (n = this.collector) == null ? void 0 : n.getLocalId(V) : V;
          })), u.toolsType === bl.Text) {
            console.log("onServiceDerive---00", u, d, (G = this.collector) == null ? void 0 : G.uid), this.control.textEditorManager.onServiceDerive(u);
            continue;
          }
          this.taskBatchData.add(u), (y = u.opt) != null && y.zIndex && (W = Math.max(W || 0, u.opt.zIndex), X = Math.min(X || 1 / 0, u.opt.zIndex));
        }
        this.internalMsgEmitter.emit("excludeIds", h, d);
      }
      this.runAnimation(), this.zIndexNodeMethod && (W && (this.zIndexNodeMethod.maxZIndex = W), X && (this.zIndexNodeMethod.minZIndex = X));
    }
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  consume() {
    this.animationId = void 0;
    const d = this.currentLocalWorkData.workState;
    let l = !1;
    if (!this.localEventTimerId && (d !== hl.Pending && this.localPointsBatchData.length && (this.wokerDrawCount !== 1 / 0 && this.wokerDrawCount <= this.subWorkerDrawCount && this.cacheDrawCount < this.maxDrawCount && (l = !0), this.maxDrawCount || (l = !0), l && this.viewContainerManager.focuedViewId && (this.taskBatchData.add({
      op: this.localPointsBatchData.map((i) => i),
      workState: d,
      workId: this.currentLocalWorkData.workId,
      dataType: Jl.Local,
      msgType: Vl.DrawWork,
      isRunSubWork: this.isRunSubWork,
      undoTickerId: d === hl.Done && this.undoTickerId || void 0,
      viewId: this.viewContainerManager.focuedViewId,
      scenePath: this.viewContainerManager.focuedViewId && this.viewContainerManager.getCurScenePath(this.viewContainerManager.focuedViewId)
    }), this.localPointsBatchData.length = 0, this.cacheDrawCount = this.maxDrawCount)), this.taskBatchData.size)) {
      this.post(this.taskBatchData);
      for (const i of this.taskBatchData.values())
        if (i.msgType === Vl.TasksQueue) {
          this.tasksqueue.clear();
          break;
        }
      this.taskBatchData.clear(), this.undoTickerId && d === hl.Done && (this.undoTickerId = void 0);
    }
    this.tasksqueue.size && this.consumeQueue(), (this.tasksqueue.size || this.taskBatchData.size || this.localPointsBatchData.length) && (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  unabled() {
    this.setCurrentLocalWorkData({ workState: hl.Freeze, workId: void 0 });
  }
  abled() {
    this.setCurrentLocalWorkData({ workState: hl.Pending, workId: void 0 });
  }
  post(d) {
    this.fullWorker.postMessage(d);
    const l = /* @__PURE__ */ new Set();
    for (const i of d.values()) {
      const t = i.msgType;
      (t === Vl.Init || t === Vl.Clear || t === Vl.Destroy || t === Vl.UpdateCamera || i.isRunSubWork) && l.add(i);
    }
    l.size && this.subWorker.postMessage(l);
  }
  destroy() {
    this.unabled(), this.taskBatchData.clear(), this.localPointsBatchData.length = 0, this.fullWorker.terminate(), this.subWorker.terminate(), this.isActive = !1;
  }
  updateNode(d, l, i, t) {
    this.taskBatchData.add({
      msgType: Vl.UpdateNode,
      workId: d,
      updateNodeOpt: l,
      viewId: i,
      scenePath: t,
      dataType: Jl.Local
    }), this.runAnimation();
  }
  updateCamera(d, l) {
    this.useTasksqueue || (this.useTasksqueue = !0, this.mianTasksqueueCount = 1, this.workerTasksqueueCount = 1), this.useTasksqueue && (this.tasksqueue.set(d, {
      msgType: Vl.UpdateCamera,
      dataType: Jl.Local,
      cameraOpt: l,
      isRunSubWork: !0,
      viewId: d
    }), this.control.textEditorManager.onCameraChange(l, d), this.runAnimation(), this.useTasksClockId && clearTimeout(this.useTasksClockId), this.useTasksClockId = setTimeout(() => {
      this.useTasksClockId = void 0, this.tasksqueue.clear(), this.useTasksqueue = !1, this.mianTasksqueueCount = void 0, this.workerTasksqueueCount = void 0;
    }, this.maxLastSyncTime));
  }
  consumeQueue() {
    this.mianTasksqueueCount && this.workerTasksqueueCount && this.mianTasksqueueCount === this.workerTasksqueueCount && (this.mianTasksqueueCount++, this.taskBatchData.add({
      msgType: Vl.TasksQueue,
      dataType: Jl.Local,
      isRunSubWork: !0,
      mainTasksqueueCount: this.mianTasksqueueCount,
      tasksqueue: this.tasksqueue,
      viewId: ""
    }));
  }
  async clearViewScenePath(d, l) {
    var i;
    if (this.control.textEditorManager.clear(d, l), this.taskBatchData.add({
      dataType: Jl.Local,
      msgType: Vl.Clear,
      viewId: d
    }), this.runAnimation(), !l) {
      const t = this.viewContainerManager.getCurScenePath(d);
      (i = this.collector) == null || i.dispatch({
        type: Vl.Clear,
        viewId: d,
        scenePath: t
      });
    }
    this.zIndexNodeMethod && (this.zIndexNodeMethod.maxZIndex = 0, this.zIndexNodeMethod.minZIndex = 0), this.localPointsBatchData.length = 0, await new Promise((t) => {
      this.clearAllResolve = t;
    }).then(() => {
      this.clearAllResolve = void 0;
    });
  }
  internalMsgEmitterListener() {
    var d;
    this.methodBuilder = new xl([
      ul.CopyNode,
      ul.SetColorNode,
      ul.DeleteNode,
      ul.RotateNode,
      ul.ScaleNode,
      ul.TranslateNode,
      ul.ZIndexActive,
      ul.ZIndexNode,
      ul.RotateNode,
      ul.SetFontStyle,
      ul.SetPoint,
      ul.SetLock,
      ul.SetShapeOpt
    ]).registerForMainEngine(Yl.MainEngine, this.control), this.zIndexNodeMethod = (d = this.methodBuilder) == null ? void 0 : d.getBuilder(ul.ZIndexNode);
  }
  originalEventLintener(d, l, i) {
    switch (d) {
      case hl.Start:
        this.onLocalEventStart(l, i);
        break;
      case hl.Doing:
        i === this.viewContainerManager.focuedViewId && this.onLocalEventDoing(l);
        break;
      case hl.Done:
        i === this.viewContainerManager.focuedViewId && this.onLocalEventEnd(l);
        break;
    }
  }
  setZIndex() {
    const d = this.currentToolsData && El(this.currentToolsData.toolsOpt);
    return d && this.zIndexNodeMethod && this.isUseZIndex && (this.zIndexNodeMethod.addMaxLayer(), d.zIndex = this.zIndexNodeMethod.maxZIndex), d;
  }
  onLocalEventEnd(d) {
    var i, t;
    const l = this.currentLocalWorkData.workState;
    if (!(l === hl.Freeze || l === hl.Unwritable) && this.viewContainerManager.focuedView) {
      const { id: s, focusScenePath: b, cameraOpt: Z } = this.viewContainerManager.focuedView;
      if (l === hl.Start || l === hl.Doing) {
        const o = this.viewContainerManager.transformToScenePoint(d, s);
        this.pushPoint(o), this.localEventTimerId = setTimeout(() => {
          this.localEventTimerId = void 0, this.setCurrentLocalWorkData({ ...this.currentLocalWorkData, workState: hl.Done }), this.runAnimation();
        }, 0), ((i = this.currentToolsData) == null ? void 0 : i.toolsType) === bl.Selector && this.viewContainerManager.activeFloatBar(s);
      } else if (((t = this.currentToolsData) == null ? void 0 : t.toolsType) === bl.Text) {
        const o = this.viewContainerManager.transformToScenePoint(d, s);
        if (this.localPointsBatchData[0] === o[0] && this.localPointsBatchData[1] === o[1]) {
          const G = this.currentToolsData.toolsOpt;
          G.workState = hl.Doing, G.boxPoint = o, G.boxSize = [G.fontSize, G.fontSize], this.control.textEditorManager.checkEmptyTextBlur(), this.control.textEditorManager.createTextForMasterController({
            workId: Date.now().toString(),
            x: d[0],
            y: d[1],
            scale: (Z == null ? void 0 : Z.scale) || 1,
            opt: G,
            type: ad.Text,
            isActive: !0,
            viewId: s,
            scenePath: b
          }, Date.now());
        }
        this.localPointsBatchData.length = 0;
      }
    }
  }
  onLocalEventDoing(d) {
    var t;
    let l = this.currentLocalWorkData.workState;
    if (l === hl.Freeze || l === hl.Unwritable)
      return;
    const i = this.viewContainerManager.focuedViewId;
    if (i) {
      if (l === hl.Start && (l = hl.Doing, this.setCurrentLocalWorkData({ ...this.currentLocalWorkData, workState: l })), l === hl.Doing || this.localEventTimerId) {
        const s = this.viewContainerManager.transformToScenePoint(d, i);
        this.pushPoint(s), this.localEventTimerId || this.runAnimation();
      } else if (((t = this.currentToolsData) == null ? void 0 : t.toolsType) === bl.Selector) {
        const s = this.viewContainerManager.transformToScenePoint(d, i), b = {
          msgType: Vl.CursorHover,
          dataType: Jl.Local,
          point: s,
          toolsType: this.currentToolsData.toolsType,
          opt: this.currentToolsData.toolsOpt,
          isRunSubWork: !1,
          viewId: i
        };
        this.queryTaskBatchData({
          msgType: Vl.CursorHover,
          dataType: Jl.Local,
          toolsType: this.currentToolsData.toolsType,
          viewId: i
        }).forEach((Z) => {
          this.taskBatchData.delete(Z);
        }), this.taskBatchData.add(b), this.runAnimation();
      }
    }
  }
  onLocalEventStart(d, l) {
    var Z, o, G, y, X, W;
    const { workState: i } = this.currentLocalWorkData;
    if (i === hl.Freeze || i === hl.Unwritable || !l)
      return;
    this.viewContainerManager.focuedViewId !== l && this.viewContainerManager.setFocuedViewId(l);
    const t = this.viewContainerManager.transformToScenePoint(d, l);
    if (this.pushPoint(t), ((Z = this.currentToolsData) == null ? void 0 : Z.toolsType) === bl.Text)
      return;
    this.control.textEditorManager.checkEmptyTextBlur();
    const s = ((o = this.currentToolsData) == null ? void 0 : o.toolsType) === bl.Selector ? Il : Date.now(), b = this.setZIndex();
    if (this.setCurrentLocalWorkData({
      workId: s,
      workState: hl.Start,
      toolsOpt: b
    }, Vl.CreateWork), this.maxDrawCount = 0, this.cacheDrawCount = 0, this.wokerDrawCount = 0, this.subWorkerDrawCount = 0, this.reRenders.length = 0, this.isCanRecordUndoRedo && (this.undoTickerId = s, this.internalMsgEmitter.emit("undoTickerStart", this.undoTickerId, l)), this.isCanDrawWork) {
      const h = this.viewContainerManager.getCurScenePath(l);
      (X = this.collector) == null || X.dispatch({
        type: Vl.CreateWork,
        workId: s,
        toolsType: (G = this.currentToolsData) == null ? void 0 : G.toolsType,
        opt: (y = this.currentToolsData) == null ? void 0 : y.toolsOpt,
        viewId: l,
        scenePath: h
      }), h && this.blurSelector(l, h);
    } else
      ((W = this.currentToolsData) == null ? void 0 : W.toolsType) === bl.Selector && this.viewContainerManager.unActiveFloatBar(l);
    this.consume();
  }
  pushPoint(d) {
    this.localPointsBatchData.push(d[0], d[1]);
  }
  sendCursorEvent(d, l) {
    if (!this.currentLocalWorkData || this.currentLocalWorkData.workState === hl.Freeze || this.currentLocalWorkData.workState === hl.Unwritable || !this.currentToolsData || !this.isCanSentCursor)
      return;
    let i = [void 0, void 0];
    this.currentToolsData && (this.isCanDrawWork || this.currentToolsData.toolsType === bl.Text) && this.currentLocalWorkData.workState !== hl.Start && this.currentLocalWorkData.workState !== hl.Doing && (i = d, this.control.cursor.sendEvent(i, l));
  }
  blurSelector(d, l, i) {
    var t;
    (t = this.collector) != null && t.hasSelector(d, l) && (this.taskBatchData.add({
      workId: Il,
      selectIds: [],
      msgType: Vl.Select,
      dataType: Jl.Service,
      viewId: d,
      scenePath: l,
      undoTickerId: i
    }), this.runAnimation());
  }
  getBoundingRect(d) {
    var i, t;
    if (!((i = this.boundingRectMap) == null ? void 0 : i.get(d))) {
      const s = (t = this.collector) == null ? void 0 : t.getScenePathData(d);
      if (!s)
        return;
      if (Object.keys(s).forEach((b) => {
        var Z;
        ((Z = this.collector) == null ? void 0 : Z.getLocalId(b)) === Il && delete s[b];
      }), Object.keys(s).length && this.viewContainerManager.mainView && this.viewContainerManager.mainView.cameraOpt) {
        const b = {
          msgType: Vl.BoundingBox,
          dataType: Jl.Local,
          scenePath: d,
          scenes: s,
          cameraOpt: { ...this.viewContainerManager.mainView.cameraOpt },
          isRunSubWork: !0,
          viewId: this.viewContainerManager.mainView.id
        };
        return this.taskBatchData.add(b), this.runAnimation(), new Promise((Z) => {
          this.boundingRectMap.set(d, Z);
        }).then((Z) => (this.boundingRectMap.delete(d), Z));
      }
    }
  }
  getSnapshot(d, l, i, t) {
    var b, Z, o, G, y, X;
    if (!((b = this.snapshotMap) == null ? void 0 : b.get(d))) {
      const W = (Z = this.collector) == null ? void 0 : Z.getViewIdBySecenPath(d);
      if (!W)
        return;
      const h = (o = this.collector) == null ? void 0 : o.getStorageData(W, d);
      if (!h)
        return;
      if (Object.keys(h).forEach((r) => {
        var L;
        ((L = this.collector) == null ? void 0 : L.getLocalId(r)) === Il && delete h[r];
      }), Object.keys(h).length) {
        const r = this.viewContainerManager.getView(W) || this.viewContainerManager.focuedView;
        if (!r)
          return;
        const L = l || ((G = r.cameraOpt) == null ? void 0 : G.width), u = i || ((y = r.cameraOpt) == null ? void 0 : y.height), V = {
          msgType: Vl.Snapshot,
          dataType: Jl.Local,
          scenePath: d,
          scenes: h,
          w: L,
          h: u,
          cameraOpt: t && {
            ...t,
            width: L,
            height: u
          } || r.cameraOpt,
          isRunSubWork: !0,
          viewId: W,
          maxZIndex: (X = this.zIndexNodeMethod) == null ? void 0 : X.maxZIndex
        };
        return this.taskBatchData.add(V), this.runAnimation(), new Promise((c) => {
          this.snapshotMap.set(d, c);
        }).then((c) => (this.snapshotMap.delete(d), c));
      }
    }
  }
  queryTaskBatchData(d) {
    const l = [];
    if (d)
      for (const i of this.taskBatchData.values()) {
        let t = !0;
        for (const [s, b] of Object.entries(d))
          if (i[s] !== b) {
            t = !1;
            break;
          }
        t && l.push(i);
      }
    return l;
  }
  insertImage(d) {
    const l = this.viewContainerManager.mainView, i = l == null ? void 0 : l.id, t = l == null ? void 0 : l.focusScenePath;
    if (i && t) {
      this.undoTickerId = Date.now(), sd.InternalMsgEmitter.emit("undoTickerStart", this.undoTickerId, i);
      const s = { ...d };
      this.zIndexNodeMethod && this.isUseZIndex && (this.zIndexNodeMethod.addMaxLayer(), s.zIndex = this.zIndexNodeMethod.maxZIndex), this.taskBatchData.add({
        msgType: Vl.FullWork,
        dataType: Jl.Local,
        toolsType: bl.Image,
        workId: d.uuid,
        opt: s,
        viewId: i,
        undoTickerId: d.src && this.undoTickerId || void 0,
        willRefresh: !0,
        willSyncService: !0
      }), this.runAnimation();
    }
  }
  lockImage(d, l) {
    var b, Z;
    const i = this.viewContainerManager.mainView, t = i == null ? void 0 : i.id, s = i == null ? void 0 : i.focusScenePath;
    if (t && s && this.collector) {
      const o = this.collector.getStorageData(t, s);
      if (!o)
        return;
      for (const [G, y] of Object.entries(o))
        if (y && y.toolsType === bl.Image && y.opt.uuid === d) {
          const X = Date.now();
          sd.InternalMsgEmitter.emit("undoTickerStart", X, t);
          const W = (b = this.collector) != null && b.isOwn(G) ? (Z = this.collector) == null ? void 0 : Z.getLocalId(G) : G, h = { ...y.opt, locked: l };
          this.taskBatchData.add({
            msgType: Vl.FullWork,
            dataType: Jl.Local,
            toolsType: bl.Image,
            workId: W,
            opt: h,
            viewId: t,
            undoTickerId: X,
            willRefresh: !0,
            willSyncService: !0
          }), this.runAnimation();
          return;
        }
    }
  }
  completeImageUpload(d, l) {
    var b, Z;
    const i = this.viewContainerManager.mainView, t = i == null ? void 0 : i.id, s = i == null ? void 0 : i.focusScenePath;
    if (t && s && this.collector) {
      const o = this.collector.getStorageData(t, s);
      if (!o)
        return;
      for (const [G, y] of Object.entries(o))
        if (y && y.toolsType === bl.Image && y.opt.uuid === d) {
          const X = (b = this.collector) != null && b.isOwn(G) ? (Z = this.collector) == null ? void 0 : Z.getLocalId(G) : G, W = { ...y.opt, src: l };
          this.taskBatchData.add({
            msgType: Vl.FullWork,
            dataType: Jl.Local,
            toolsType: bl.Image,
            workId: X,
            opt: W,
            viewId: t,
            undoTickerId: this.undoTickerId,
            willRefresh: !0,
            willSyncService: !0
          }), this.runAnimation();
          break;
        }
    }
  }
  getImagesInformation(d) {
    const l = [];
    if (this.collector) {
      const i = this.collector.getScenePathData(d);
      if (!i)
        return l;
      for (const t of Object.values(i))
        if (t && t.toolsType === bl.Image) {
          const s = t.opt;
          l.push({
            uuid: s.uuid,
            centerX: s.centerX,
            centerY: s.centerY,
            width: s.width,
            height: s.height,
            locked: s.locked,
            uniformScale: s.uniformScale,
            crossOrigin: s.crossOrigin
          });
        }
    }
    return l;
  }
}
var EX = ud, BX = function() {
  return EX.Date.now();
}, OX = BX, DX = /\s/;
function AX(m) {
  for (var d = m.length; d-- && DX.test(m.charAt(d)); )
    ;
  return d;
}
var qX = AX, $X = qX, _X = /^\s+/;
function lG(m) {
  return m && m.slice(0, $X(m) + 1).replace(_X, "");
}
var dG = lG, iG = Fd, tG = xd, sG = "[object Symbol]";
function cG(m) {
  return typeof m == "symbol" || tG(m) && iG(m) == sG;
}
var bG = cG, ZG = dG, Ht = Sd, mG = bG, Mt = NaN, nG = /^[-+]0x[0-9a-f]+$/i, eG = /^0b[01]+$/i, oG = /^0o[0-7]+$/i, aG = parseInt;
function XG(m) {
  if (typeof m == "number")
    return m;
  if (mG(m))
    return Mt;
  if (Ht(m)) {
    var d = typeof m.valueOf == "function" ? m.valueOf() : m;
    m = Ht(d) ? d + "" : d;
  }
  if (typeof m != "string")
    return m === 0 ? m : +m;
  m = ZG(m);
  var l = eG.test(m);
  return l || oG.test(m) ? aG(m.slice(2), l ? 2 : 8) : nG.test(m) ? Mt : +m;
}
var GG = XG, WG = Sd, yi = OX, zt = GG, uG = "Expected a function", hG = Math.max, VG = Math.min;
function pG(m, d, l) {
  var i, t, s, b, Z, o, G = 0, y = !1, X = !1, W = !0;
  if (typeof m != "function")
    throw new TypeError(uG);
  d = zt(d) || 0, WG(l) && (y = !!l.leading, X = "maxWait" in l, s = X ? hG(zt(l.maxWait) || 0, d) : s, W = "trailing" in l ? !!l.trailing : W);
  function h(Y) {
    var R = i, C = t;
    return i = t = void 0, G = Y, b = m.apply(C, R), b;
  }
  function r(Y) {
    return G = Y, Z = setTimeout(V, d), y ? h(Y) : b;
  }
  function L(Y) {
    var R = Y - o, C = Y - G, N = d - R;
    return X ? VG(N, s - C) : N;
  }
  function u(Y) {
    var R = Y - o, C = Y - G;
    return o === void 0 || R >= d || R < 0 || X && C >= s;
  }
  function V() {
    var Y = yi();
    if (u(Y))
      return c(Y);
    Z = setTimeout(V, L(Y));
  }
  function c(Y) {
    return Z = void 0, W && i ? h(Y) : (i = t = void 0, b);
  }
  function n() {
    Z !== void 0 && clearTimeout(Z), G = 0, i = o = t = Z = void 0;
  }
  function e() {
    return Z === void 0 ? b : c(yi());
  }
  function a() {
    var Y = yi(), R = u(Y);
    if (i = arguments, t = this, o = Y, R) {
      if (Z === void 0)
        return r(o);
      if (X)
        return clearTimeout(Z), Z = setTimeout(V, d), h(o);
    }
    return Z === void 0 && (Z = setTimeout(V, d)), b;
  }
  return a.cancel = n, a.flush = e, a;
}
var Is = pG;
const gt = /* @__PURE__ */ Td(Is);
var yG = Is, LG = Sd, IG = "Expected a function";
function YG(m, d, l) {
  var i = !0, t = !0;
  if (typeof m != "function")
    throw new TypeError(IG);
  return LG(l) && (i = "leading" in l ? !!l.leading : i, t = "trailing" in l ? !!l.trailing : t), yG(m, d, {
    leading: i,
    maxWait: d,
    trailing: t
  });
}
var xG = YG;
const wl = /* @__PURE__ */ Td(xG);
var Zi;
(function(m) {
  m.Mac = "mac", m.Windows = "windows";
})(Zi || (Zi = {}));
class rG {
  constructor(d) {
    var t;
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomHotkeyCheckers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tmpCopyStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "tmpCopyCoordInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const { control: l, internalMsgEmitter: i } = d;
    this.control = l, this.internalMsgEmitter = i, this.roomHotkeyCheckers = ((t = this.control.room) == null ? void 0 : t.viewsParams.hotKeys.nodes) || [];
  }
  get isUseSelf() {
    var d;
    return ((d = this.control.room) == null ? void 0 : d.disableDeviceInputs) || !1;
  }
  get isSelector() {
    var d;
    return ((d = this.control.worker.currentToolsData) == null ? void 0 : d.toolsType) === bl.Selector;
  }
  get collector() {
    return this.control.collector;
  }
  get mainEngine() {
    return this.control.worker;
  }
  get keyboardKind() {
    return /^Mac/i.test(navigator.platform) ? Zi.Mac : Zi.Windows;
  }
  getEventKey(d) {
    switch (d.type) {
      case "keydown":
        return "KeyDown";
    }
    return "KeyUp";
  }
  onActiveHotkey(d) {
    var t, s, b;
    console.log("onActiveHotkey---sdk", d);
    const l = this.control.viewContainerManager.focuedViewId, i = (t = this.control.viewContainerManager.focuedView) == null ? void 0 : t.focusScenePath;
    if (l && i)
      switch (d) {
        case "delete":
          this.isSelector && ((s = this.collector) != null && s.hasSelector(l, i)) && xl.emitMethod(Yl.MainEngine, ul.DeleteNode, { workIds: [Il], viewId: l });
          break;
        case "copy":
          this.isSelector && ((b = this.collector) != null && b.hasSelector(l, i)) && this.copySelectorToTemp(l, i);
          break;
        case "paste":
          this.tmpCopyStore.size && this.pasteTempToFocusView(l, i);
          break;
      }
    (d === "changeToPencil" || d === "redo" || d === "undo") && this.onSelfActiveHotkey(d);
  }
  colloctHotkey(d) {
    if (this.isUseSelf) {
      const l = this.checkHotkey(d);
      l && this.onSelfActiveHotkey(l);
    }
  }
  onSelfActiveHotkey(d) {
    switch (console.log("onActiveHotkey---self", d), d) {
      case "changeToPencil":
        this.setMemberState({ currentApplianceName: Tl.pencil, useNewPencil: !0 });
        break;
      case "changeToArrow":
        this.setMemberState({ currentApplianceName: Tl.arrow });
        break;
      case "changeToClick":
        this.setMemberState({ currentApplianceName: Tl.clicker });
        break;
      case "changeToEllipse":
        this.setMemberState({ currentApplianceName: Tl.ellipse });
        break;
      case "changeToEraser":
        this.setMemberState({ currentApplianceName: Tl.eraser, isLine: !0 });
        break;
      case "changeToHand":
        this.setMemberState({ currentApplianceName: Tl.hand });
        break;
      case "changeToLaserPointer":
        this.setMemberState({ currentApplianceName: Tl.laserPointer });
        break;
      case "changeToSelector":
        this.setMemberState({ currentApplianceName: Tl.selector });
        break;
      case "changeToRectangle":
        this.setMemberState({ currentApplianceName: Tl.rectangle });
        break;
      case "changeToStraight":
        this.setMemberState({ currentApplianceName: Tl.straight });
        break;
      case "redo":
        this.control.room && !this.control.room.disableSerialization && this.control.viewContainerManager.redo();
        break;
      case "undo":
        this.control.room && !this.control.room.disableSerialization && this.control.viewContainerManager.undo();
        break;
      case "changeToText":
        this.setMemberState({ currentApplianceName: Tl.text });
        break;
    }
  }
  checkHotkey(d) {
    for (const l of this.roomHotkeyCheckers) {
      const { kind: i, checker: t } = l;
      if (t({
        nativeEvent: d,
        kind: this.getEventKey(d),
        key: d.key,
        altKey: d.altKey,
        ctrlKey: d.ctrlKey,
        shiftKey: d.shiftKey
      }, this.keyboardKind))
        return i;
    }
  }
  copySelectorToTemp(d, l) {
    var G, y;
    const i = this.control.viewContainerManager.getView(d), t = (y = (G = this.mainEngine) == null ? void 0 : G.methodBuilder) == null ? void 0 : y.getBuilder(ul.CopyNode);
    if (!i || !this.collector || !t)
      return;
    const s = this.collector.transformKey(Il), b = this.collector.getStorageData(d, l);
    if (!b)
      return;
    const Z = b[s], o = Z && t.copySelector({
      viewId: d,
      store: Z
    });
    o && (this.tmpCopyCoordInfo = o == null ? void 0 : o.copyCoordInfo, this.tmpCopyStore = o == null ? void 0 : o.copyStores);
  }
  pasteTempToFocusView(d, l) {
    var s, b;
    const i = this.control.viewContainerManager.getView(d), t = (b = (s = this.mainEngine) == null ? void 0 : s.methodBuilder) == null ? void 0 : b.getBuilder(ul.CopyNode);
    if (!(!i || !this.tmpCopyCoordInfo || !this.tmpCopyStore.size || !this.collector || !t) && i.viewData && this.tmpCopyCoordInfo) {
      const Z = Bi(this.tmpCopyCoordInfo.offset), o = this.tmpCopyCoordInfo.cameraOpt, G = i.viewData.camera;
      Z.x = Z.x + G.centerX - o.centerX, Z.y = Z.y + G.centerY - o.centerY, t.pasteSelector({
        viewId: d,
        scenePath: l,
        copyStores: Bi(this.tmpCopyStore),
        copyCoordInfo: {
          offset: Z,
          cameraOpt: G
        }
      });
    }
  }
  setMemberState(d) {
    var l;
    (l = this.control.room) == null || l.setMemberState(d);
  }
}
class sd {
  constructor(d) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "play", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "hotkeyManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "roomMember", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cursor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textEditorManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b, Z) => {
        var y;
        const o = (y = this.viewContainerManager.getView(Z)) == null ? void 0 : y.focusScenePath;
        o && this.worker.blurSelector(Z, o);
        const G = b;
        G && this.viewContainerManager.setViewScenePath(Z, G);
      }
    }), Object.defineProperty(this, "onRoomMembersChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b) => {
        this.roomMember.setRoomMembers(wt(b));
      }
    }), Object.defineProperty(this, "onMemberChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wl((b) => {
        if (!this.room || !this.worker)
          return;
        const Z = this.getToolsKey(b), o = this.getToolsOpt(Z, b);
        this.worker.setCurrentToolsData(o), this.effectViewContainer(Z);
      }, 100, { leading: !1 })
    }), Object.defineProperty(this, "internalSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b, Z) => {
        var o;
        this.textEditorManager.checkEmptyTextBlur(), (o = this.worker) == null || o.clearViewScenePath(b, !0).then(() => {
          var G;
          (G = this.worker) == null || G.pullServiceData(b, Z);
        });
      }
    }), Object.defineProperty(this, "internalCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (b, Z) => {
        var o;
        (o = this.worker) == null || o.updateCamera(b, Z);
      }
    });
    const { displayer: l, plugin: i, options: t } = d;
    this.plugin = i, this.room = cd(l) ? l : void 0, this.play = ft(l) ? l : void 0, this.pluginOptions = t, this.roomMember = new RX();
    const s = {
      control: this,
      internalMsgEmitter: sd.InternalMsgEmitter
    };
    this.cursor = new KX(s), this.textEditorManager = new SX(s), this.worker = new jX(s), this.hotkeyManager = new rG(s);
  }
  bindPlugin(d) {
    var l, i;
    this.plugin = d, this.collector && this.collector.removeStorageStateListener(), this.collector = new Ld(d, (i = (l = this.pluginOptions) == null ? void 0 : l.syncOpt) == null ? void 0 : i.interval), this.cursor.activeCollector(), this.activePlugin();
  }
  /** 销毁 */
  destroy() {
    var d, l, i, t, s;
    this.roomMember.destroy(), (d = this.collector) == null || d.destroy(), (l = this.worker) == null || l.destroy(), (i = this.viewContainerManager) == null || i.destroy(), (t = this.cursor) == null || t.destroy(), (s = this.textEditorManager) == null || s.destory();
  }
  /** 清空当前获焦路径下的所有内容 */
  cleanCurrentScene() {
    const d = Date.now(), l = this.viewContainerManager.focuedViewId;
    l && (sd.InternalMsgEmitter.emit("undoTickerStart", d, l), this.worker.clearViewScenePath(l).then(() => {
      sd.InternalMsgEmitter.emit("undoTickerEnd", d, l);
    }));
  }
  /** 监听读写状态变更 */
  onWritableChange(d) {
    var l, i;
    d ? (i = this.worker) == null || i.abled() : (l = this.worker) == null || l.unabled();
  }
  /** 获取当前工具key */
  getToolsKey(d) {
    switch (d.currentApplianceName) {
      case Tl.text:
        return bl.Text;
      case Tl.pencil:
        if (d.useNewPencil)
          return bl.Pencil;
        if (d.useLaserPen)
          return bl.LaserPen;
        break;
      case Tl.eraser:
      case Tl.pencilEraser:
        return bl.Eraser;
      case Tl.selector:
        return bl.Selector;
      case Tl.arrow:
        return bl.Arrow;
      case Tl.straight:
        return bl.Straight;
      case Tl.ellipse:
        return bl.Ellipse;
      case Tl.rectangle:
        return bl.Rectangle;
      case Tl.shape:
        if (d.shapeType === Gd.Pentagram || d.shapeType === Gd.Star)
          return bl.Star;
        if (d.shapeType === Gd.Polygon || d.shapeType === Gd.Triangle || d.shapeType === Gd.Rhombus)
          return bl.Polygon;
        if (d.shapeType === Gd.SpeechBalloon)
          return bl.SpeechBalloon;
        break;
    }
    return bl.Clicker;
  }
  /** 获取当前工具默认配置 */
  getToolsOpt(d, l) {
    const i = l.currentApplianceName, t = {
      strokeColor: qd(l.strokeColor[0], l.strokeColor[1], l.strokeColor[2], l.strokeOpacity || 1),
      thickness: l.strokeWidth,
      isOpacity: (l == null ? void 0 : l.strokeOpacity) && l.strokeOpacity < 1 || (l == null ? void 0 : l.fillOpacity) && l.fillOpacity < 1 || (l == null ? void 0 : l.textOpacity) && l.textOpacity < 1 || (l == null ? void 0 : l.textBgOpacity) && l.textBgOpacity < 1 || !1
    };
    switch (d) {
      case bl.Text:
        t.fontFamily = window.getComputedStyle(document.documentElement).getPropertyValue("font-family"), t.fontSize = (l == null ? void 0 : l.textSize) || Number(window.getComputedStyle(document.body).fontSize), t.textAlign = (l == null ? void 0 : l.textAlign) || "left", t.verticalAlign = (l == null ? void 0 : l.verticalAlign) || "middle", t.fontColor = (l == null ? void 0 : l.textColor) && qd(l.textColor[0], l.textColor[1], l.textColor[2], l.textOpacity || 1) || t.strokeColor || "rgba(0,0,0,1)", t.fontBgColor = Array.isArray(l == null ? void 0 : l.textBgColor) && qd(l.textBgColor[0], l.textBgColor[1], l.textBgColor[2], l.textBgOpacity || 1) || "transparent", t.bold = (l == null ? void 0 : l.bold) && "bold" || void 0, t.italic = (l == null ? void 0 : l.italic) && "italic" || void 0, t.underline = (l == null ? void 0 : l.underline) || void 0, t.lineThrough = (l == null ? void 0 : l.lineThrough) || void 0, t.text = "", t.strokeColor = void 0;
        break;
      case bl.Pencil:
        t.strokeType = (l == null ? void 0 : l.strokeType) || di.Normal;
        break;
      case bl.Eraser:
        t.thickness = Math.min(3, Math.max(1, Math.floor(l.pencilEraserSize || 1))) - 1, t.isLine = i === Tl.eraser && !0;
        break;
      case bl.LaserPen:
        t.duration = (l == null ? void 0 : l.duration) || 1, t.strokeType = (l == null ? void 0 : l.strokeType) || di.Normal;
        break;
      case bl.Ellipse:
      case bl.Rectangle:
      case bl.Star:
      case bl.Polygon:
      case bl.SpeechBalloon:
        d === bl.Star && (l.shapeType === Gd.Pentagram ? (t.vertices = 10, t.innerVerticeStep = 2, t.innerRatio = 0.4) : l != null && l.vertices && (l != null && l.innerVerticeStep) && (l != null && l.innerRatio) && (t.vertices = l.vertices, t.innerVerticeStep = l.innerVerticeStep, t.innerRatio = l.innerRatio)), d === bl.Polygon && (l.shapeType === Gd.Triangle ? t.vertices = 3 : l.shapeType === Gd.Rhombus ? t.vertices = 4 : l.vertices && (t.vertices = l.vertices)), t.fillColor = (l == null ? void 0 : l.fillColor) && qd(l.fillColor[0], l.fillColor[1], l.fillColor[2], l == null ? void 0 : l.fillOpacity) || "transparent", d === bl.SpeechBalloon && (t.placement = l.placement || "bottomLeft");
        break;
    }
    return {
      toolsType: d,
      toolsOpt: t
    };
  }
  /** 激活当前view容器*/
  effectViewContainer(d) {
    var l, i, t, s, b;
    switch (d) {
      case bl.Text:
      case bl.Pencil:
      case bl.LaserPen:
      case bl.Arrow:
      case bl.Straight:
      case bl.Rectangle:
      case bl.Ellipse:
      case bl.Star:
      case bl.Polygon:
      case bl.SpeechBalloon:
      case bl.Triangle:
      case bl.Rhombus:
        this.room.disableDeviceInputs = !0, (l = this.worker) == null || l.abled();
        break;
      case bl.Eraser:
      case bl.Selector:
        this.room.disableDeviceInputs = !1, (i = this.cursor) == null || i.unabled(), (t = this.worker) == null || t.abled();
        break;
      default:
        this.room.disableDeviceInputs = !1, (s = this.worker) == null || s.unabled(), (b = this.cursor) == null || b.unabled();
        break;
    }
    setTimeout(() => {
      this.viewContainerManager.getAllViews().forEach((o) => {
        o != null && o.displayer && o.displayer.bindToolsClass();
      });
    }, 0);
  }
  /** 异步获取指定路径下绘制内容的区域大小 */
  async getBoundingRect(d) {
    var i, t, s, b, Z;
    const l = await ((i = this.worker) == null ? void 0 : i.getBoundingRect(d));
    if (l) {
      const o = ((s = (t = this.viewContainerManager.mainView) == null ? void 0 : t.viewData) == null ? void 0 : s.convertToPointInWorld({ x: l.x, y: l.y })) || { x: l.x, y: l.y }, G = ((Z = (b = this.viewContainerManager.mainView) == null ? void 0 : b.viewData) == null ? void 0 : Z.camera.scale) || 1;
      return {
        width: Math.floor(l.w / G) + 1,
        height: Math.floor(l.h / G) + 1,
        originX: o.x,
        originY: o.y
      };
    }
  }
  /** 异步获取指定路径下的的快照并绘制到指定的画布上 */
  async screenshotToCanvas(d, l, i, t, s) {
    const b = await this.worker.getSnapshot(l, i, t, s);
    b && (d.drawImage(b, 0, 0), b.close());
  }
  /** 异步获取指定路径下的缩略图 */
  async scenePreview(d, l) {
    var b, Z, o, G;
    const i = (b = this.collector) == null ? void 0 : b.getViewIdBySecenPath(d);
    if (!i)
      return;
    const t = this.viewContainerManager.getView(i);
    if (!t || !((Z = t.cameraOpt) != null && Z.width) || !((o = t.cameraOpt) != null && o.height))
      return;
    const s = await ((G = this.worker) == null ? void 0 : G.getSnapshot(d));
    if (s && this.worker) {
      const y = document.createElement("canvas"), X = y.getContext("2d"), { width: W, height: h } = t.cameraOpt;
      y.width = W, y.height = h, X && (X.drawImage(s, 0, 0), l.src = y.toDataURL(), l.onload = () => {
        y.remove();
      }, l.onerror = () => {
        y.remove(), l.remove();
      }), s.close();
    }
  }
}
Object.defineProperty(sd, "InternalMsgEmitter", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: new Qt()
});
var RG = ps, SG = 4;
function KG(m) {
  return RG(m, SG);
}
var CG = KG;
const kt = /* @__PURE__ */ Td(CG);
var zd;
(function(m) {
  m[m.sdk = 1] = "sdk", m[m.plugin = 2] = "plugin", m[m.both = 3] = "both";
})(zd || (zd = {}));
var rd;
(function(m) {
  m[m.Draw = 1] = "Draw", m[m.Delete = 2] = "Delete", m[m.Update = 3] = "Update";
})(rd || (rd = {}));
class Yd {
  constructor(d) {
    Object.defineProperty(this, "emitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Qt()
    }), Object.defineProperty(this, "undoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "redoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "isTicking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scenePath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tickStartStorerCache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "undoTickerEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: gt((s, b, Z) => {
        var o, G;
        if (s === this.undoTickerId && Z === this.scenePath && b === this.viewId && this.tickStartStorerCache) {
          const y = ((o = this.collector) == null ? void 0 : o.storage[b]) && ((G = this.collector) == null ? void 0 : G.storage[b][Z]) || {}, X = this.diffFun(this.tickStartStorerCache, new Map(Object.entries(y)));
          X.size && (this.undoStack.push({
            id: s,
            type: zd.plugin,
            data: El(X),
            scenePath: Z
          }), this.undoStack.length > Yd.MaxStackLength && this.undoStack.shift(), this.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length)), this.redoStack.length && (this.redoStack.length = 0, this.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length)), this.isTicking = !1, this.scenePath = void 0, this.tickStartStorerCache = void 0, this.undoTickerId = void 0, this.excludeIds.clear();
        }
      }, Yd.waitTime)
    }), Object.defineProperty(this, "onChangeScene", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: gt(() => {
        const s = this.control.viewContainerManager.getCurScenePath(this.viewId);
        if (s) {
          const b = this.undoStack.filter((o) => o.scenePath === s).length, Z = this.redoStack.filter((o) => o.scenePath === s).length;
          this.emitter.emit("onCanUndoStepsUpdate", b), this.emitter.emit("onCanRedoStepsUpdate", Z);
        }
      }, Yd.waitTime)
    });
    const { control: l, internalMsgEmitter: i, viewId: t } = d;
    this.control = l, this.emitter = i, this.undoStack = [], this.redoStack = [], this.room = l.room, this.worker = l.worker, this.isTicking = !1, this.viewId = t;
  }
  get collector() {
    return this.control.collector;
  }
  addExcludeIds(d) {
    if (this.isTicking)
      for (const l of d)
        this.excludeIds.add(l);
  }
  undoTickerStart(d, l) {
    var i, t;
    if (this.undoTickerId !== d || this.scenePath !== l) {
      this.isTicking = !0, this.excludeIds.clear(), this.undoTickerId = d, this.scenePath = l;
      const s = ((i = this.collector) == null ? void 0 : i.storage[this.viewId]) && ((t = this.collector) == null ? void 0 : t.storage[this.viewId][l]) || {};
      this.tickStartStorerCache = new Map(Object.entries(El(s)));
    }
  }
  undoTickerEndSync(d, l, i, t) {
    var s, b;
    if (d === this.undoTickerId && i === this.scenePath && l === this.viewId && this.tickStartStorerCache) {
      const Z = ((s = this.collector) == null ? void 0 : s.storage[l]) && ((b = this.collector) == null ? void 0 : b.storage[l][i]) || {}, o = this.diffFun(this.tickStartStorerCache, new Map(Object.entries(Z)));
      o.size && (this.undoStack.push({
        id: d,
        type: zd.plugin,
        data: El(o),
        scenePath: i,
        tickStartStorerCache: t && El(this.tickStartStorerCache) || void 0
      }), this.undoStack.length > Yd.MaxStackLength && this.undoStack.shift(), this.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length)), this.redoStack.length && (this.redoStack.length = 0, this.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length)), this.isTicking = !1, this.scenePath = void 0, this.tickStartStorerCache = void 0, this.undoTickerId = void 0, this.excludeIds.clear();
    }
  }
  undo(d) {
    this.undoTickerId && this.tickStartStorerCache && this.scenePath && this.undoTickerEndSync(this.undoTickerId, this.viewId, this.scenePath, !0);
    let l = this.undoStack.length - 1;
    for (; l >= 0; ) {
      if (this.undoStack[l].scenePath === d) {
        const b = this.undoStack[l];
        b && (this.redoStack.push(b), b.type === zd.plugin && b.data && this.refreshPlugin(b)), this.undoStack.splice(l, 1);
        break;
      }
      l--;
    }
    const i = this.undoStack.filter((s) => s.scenePath === d).length, t = this.redoStack.filter((s) => s.scenePath === d).length;
    return this.emitter.emit("onCanUndoStepsUpdate", i), this.emitter.emit("onCanRedoStepsUpdate", t), i;
  }
  redo(d) {
    let l = this.redoStack.length - 1;
    for (; l >= 0; ) {
      if (this.redoStack[l].scenePath === d) {
        const b = this.redoStack[l];
        b && (!this.undoTickerId && b.tickStartStorerCache ? (this.undoTickerId = b.id, this.tickStartStorerCache = b.tickStartStorerCache, this.scenePath = b.scenePath) : this.undoStack.push(b), b.type === zd.plugin && b.data && this.refreshPlugin(b, !0)), this.redoStack.splice(l, 1);
        break;
      }
      l--;
    }
    const i = this.undoStack.filter((s) => s.scenePath === d).length, t = this.redoStack.filter((s) => s.scenePath === d).length;
    return this.emitter.emit("onCanUndoStepsUpdate", i), this.emitter.emit("onCanRedoStepsUpdate", t), t;
  }
  clear() {
    this.clearUndo(), this.clearRedo();
  }
  clearUndo() {
    this.undoStack.length = 0, this.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length);
  }
  clearRedo() {
    this.redoStack.length = 0, this.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length);
  }
  canUndo() {
    return !!this.undoStack.length;
  }
  canRedo() {
    return !!this.redoStack.length;
  }
  onFocusView() {
    const d = this.control.viewContainerManager.getCurScenePath(this.viewId);
    if (d) {
      const l = this.undoStack.filter((t) => t.scenePath === d).length, i = this.redoStack.filter((t) => t.scenePath === d).length;
      this.emitter.emit("onCanUndoStepsUpdate", l), this.emitter.emit("onCanRedoStepsUpdate", i);
    }
  }
  diffFun(d, l) {
    const i = /* @__PURE__ */ new Set(), t = d.keys(), s = l.keys();
    for (const b of t) {
      if (this.excludeIds.has(b))
        continue;
      const Z = d.get(b), o = l.get(b);
      if (Z && o) {
        if (dd(o, Z))
          continue;
        i.add({
          dataType: rd.Update,
          key: b,
          data: [Z, o]
        });
        continue;
      }
      Z && i.add({
        dataType: rd.Delete,
        key: b,
        data: Z
      });
    }
    for (const b of s) {
      if (this.excludeIds.has(b))
        continue;
      const Z = l.get(b);
      Z && !d.has(b) && i.add({
        dataType: rd.Draw,
        key: b,
        data: Z
      });
    }
    return i;
  }
  isDrawEffectiveScene(d, l) {
    const { key: i } = d;
    return !l.includes(i);
  }
  isDeleteEffectiveScene(d, l, i) {
    var b;
    const { key: t } = d;
    if (!l.includes(t))
      return !1;
    const s = l.filter((Z) => {
      var o, G;
      return ((o = this.collector) == null ? void 0 : o.getLocalId(Z)) === Il && !((G = this.collector) != null && G.isOwn(Z));
    }).map((Z) => {
      var o;
      return (o = this.collector) == null ? void 0 : o.storage[this.viewId][i][Z];
    });
    for (const Z of s)
      if ((b = Z == null ? void 0 : Z.selectIds) != null && b.includes(t))
        return !1;
    return !0;
  }
  isOldEffectiveScene(d, l, i) {
    var b;
    const { key: t } = d;
    if (!l.includes(t))
      return !1;
    const s = l.filter((Z) => {
      var o, G;
      return ((o = this.collector) == null ? void 0 : o.getLocalId(Z)) === Il && !((G = this.collector) != null && G.isOwn(Z));
    }).map((Z) => {
      var o;
      return (o = this.collector) == null ? void 0 : o.storage[this.viewId][i][Z];
    });
    for (const Z of s)
      if ((b = Z == null ? void 0 : Z.selectIds) != null && b.includes(t))
        return !1;
    return !0;
  }
  isNewEffectiveScene(d, l) {
    const { key: i } = d;
    return !!l.includes(i);
  }
  refreshPlugin(d, l = !1) {
    var b, Z, o, G, y, X, W, h, r, L, u, V, c, n, e, a, Y, R, C, N, I;
    let i;
    const { scenePath: t } = d, s = d.data;
    if (!(!s || !this.collector))
      for (const J of s.values()) {
        const { dataType: T, data: K, key: S } = J, H = this.collector.storage[this.viewId] && this.collector.storage[this.viewId][t], w = H && Object.keys(H) || [];
        switch (T) {
          case rd.Draw:
            if (i = l ? this.isDrawEffectiveScene(J, w) : this.isDeleteEffectiveScene(J, w, t), i)
              if (l && !Array.isArray(K)) {
                if ((b = K.updateNodeOpt) != null && b.useAnimation && (K.updateNodeOpt.useAnimation = !1), ((Z = this.collector) == null ? void 0 : Z.getLocalId(S)) === Il && ((o = this.collector) != null && o.isOwn(J.key))) {
                  const P = K.selectIds;
                  if (P) {
                    const B = w.filter((z) => {
                      var U, O;
                      return ((U = this.collector) == null ? void 0 : U.getLocalId(z)) === Il && !((O = this.collector) != null && O.isOwn(z));
                    }).map((z) => {
                      var U;
                      return (U = this.collector) == null ? void 0 : U.storage[this.viewId][t][z];
                    });
                    let D = !1;
                    for (const z of B)
                      for (let U = 0; U < P.length; U++)
                        (G = z == null ? void 0 : z.selectIds) != null && G.includes(P[U]) && (delete P[U], D = !0);
                    D && (K.selectIds = P.filter((z) => !!z));
                  }
                }
                (y = this.collector) == null || y.updateValue(J.key, K, { isAfterUpdate: !0, viewId: this.viewId, scenePath: t, isSync: !0 });
              } else
                !l && !Array.isArray(J.data) && ((X = this.collector) == null || X.updateValue(J.key, void 0, { isAfterUpdate: !0, viewId: this.viewId, scenePath: t, isSync: !0 }));
            break;
          case rd.Delete:
            if (i = l ? this.isDeleteEffectiveScene(J, w, t) : this.isDrawEffectiveScene(J, w), i) {
              if (l && !Array.isArray(K))
                (W = this.collector) == null || W.updateValue(S, void 0, { isAfterUpdate: !0, viewId: this.viewId, scenePath: t, isSync: !0 });
              else if (!l && !Array.isArray(K)) {
                if ((h = K.updateNodeOpt) != null && h.useAnimation && (K.updateNodeOpt.useAnimation = !1), ((r = this.collector) == null ? void 0 : r.getLocalId(J.key)) === Il && ((L = this.collector) != null && L.isOwn(J.key))) {
                  const P = K.selectIds;
                  if (P) {
                    const B = w.filter((z) => {
                      var U, O;
                      return ((U = this.collector) == null ? void 0 : U.getLocalId(z)) === Il && !((O = this.collector) != null && O.isOwn(z));
                    }).map((z) => {
                      var U;
                      return (U = this.collector) == null ? void 0 : U.storage[this.viewId][t][z];
                    });
                    let D = !1;
                    for (const z of B)
                      for (let U = 0; U < P.length; U++)
                        (u = z == null ? void 0 : z.selectIds) != null && u.includes(P[U]) && (delete P[U], D = !0);
                    D && (K.selectIds = P.filter((z) => !!z));
                  }
                }
                (V = this.collector) == null || V.updateValue(J.key, J.data, { isAfterUpdate: !0, viewId: this.viewId, scenePath: t, isSync: !0 });
              }
            }
            break;
          case rd.Update:
            if (i = l ? this.isNewEffectiveScene(J, w) : this.isOldEffectiveScene(J, w, t), i) {
              if (l && Array.isArray(K) && K.length === 2) {
                const P = K[1];
                if ((c = P.updateNodeOpt) != null && c.useAnimation && (P.updateNodeOpt.useAnimation = !1), ((n = this.collector) == null ? void 0 : n.getLocalId(J.key)) === Il && ((e = this.collector) != null && e.isOwn(J.key))) {
                  const B = P.selectIds;
                  if (B) {
                    const D = w.filter((U) => {
                      var O, ll;
                      return ((O = this.collector) == null ? void 0 : O.getLocalId(U)) === Il && !((ll = this.collector) != null && ll.isOwn(U));
                    }).map((U) => {
                      var O;
                      return (O = this.collector) == null ? void 0 : O.storage[this.viewId][t][U];
                    });
                    let z = !1;
                    for (const U of D)
                      for (let O = 0; O < B.length; O++)
                        U != null && U.selectIds && ((a = U.selectIds) != null && a.includes(B[O])) && (delete B[O], z = !0);
                    z && (P.selectIds = B.filter((U) => !!U));
                  }
                }
                (Y = this.collector) == null || Y.updateValue(S, P, { isAfterUpdate: !0, viewId: this.viewId, scenePath: t, isSync: !0 });
              } else if (!l && Array.isArray(K) && K.length === 2) {
                const P = K[0];
                if ((R = P.updateNodeOpt) != null && R.useAnimation && (P.updateNodeOpt.useAnimation = !1), ((C = this.collector) == null ? void 0 : C.getLocalId(J.key)) === Il && ((N = this.collector) != null && N.isOwn(J.key))) {
                  const B = P.selectIds;
                  if (B) {
                    const D = w.filter((U) => {
                      var O, ll;
                      return ((O = this.collector) == null ? void 0 : O.getLocalId(U)) === Il && !((ll = this.collector) != null && ll.isOwn(U));
                    }).map((U) => {
                      var O;
                      return (O = this.collector) == null ? void 0 : O.storage[this.viewId][t][U];
                    });
                    let z = !1;
                    for (const U of D)
                      for (let O = 0; O < B.length; O++)
                        U != null && U.selectIds && U.selectIds.includes(B[O]) && (delete B[O], z = !0);
                    z && (P.selectIds = B.filter((U) => !!U));
                  }
                }
                (I = this.collector) == null || I.updateValue(J.key, P, { isAfterUpdate: !0, viewId: this.viewId, scenePath: t, isSync: !0 });
              }
            }
            break;
        }
      }
  }
}
Object.defineProperty(Yd, "MaxStackLength", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 20
});
Object.defineProperty(Yd, "waitTime", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 100
});
function Ys(m) {
  return m.touches && m.touches.length ? {
    x: m.touches[0].pageX,
    y: m.touches[0].pageY
  } : m.changedTouches && m.changedTouches.length ? {
    x: m.changedTouches[0].pageX,
    y: m.changedTouches[0].pageY
  } : {
    x: m.pageX,
    y: m.pageY
  };
}
class Od {
  constructor(d) {
    Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "appViews", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
    const { control: l, internalMsgEmitter: i } = d;
    this.control = l, this.internalMsgEmitter = i, this.internalMsgEmitter.on("undoTickerStart", this.undoTickerStart.bind(this)), this.internalMsgEmitter.on("undoTickerEnd", this.undoTickerEnd.bind(this)), this.internalMsgEmitter.on("excludeIds", this.addExcludeIds.bind(this));
  }
  undoTickerStart(d, l) {
    const i = this.getView(l);
    i && i.displayer && i.focusScenePath && i.displayer.commiter.undoTickerStart(d, i.focusScenePath);
  }
  undoTickerEnd(d, l, i) {
    const t = this.getView(l);
    if (t && t.displayer && t.focusScenePath) {
      if (i) {
        t.displayer.commiter.undoTickerEndSync(d, l, t.focusScenePath);
        return;
      }
      t.displayer.commiter.undoTickerEnd(d, l, t.focusScenePath);
    }
  }
  addExcludeIds(d, l) {
    const i = this.getView(l);
    i && i.displayer && i.focusScenePath && i.displayer.commiter.addExcludeIds(d);
  }
  undo() {
    const d = this.focuedView;
    let l = 0;
    if (d) {
      const i = d.focusScenePath;
      l = d.displayer.commiter.undo(i) || 0;
    }
    return l;
  }
  redo() {
    const d = this.focuedView;
    let l = 0;
    if (d) {
      const i = d.focusScenePath;
      l = d.displayer.commiter.redo(i) || 0;
    }
    return l;
  }
  validator(d, l, i) {
    var b;
    const t = kt(d[l]), s = kt(i);
    if (l === "focusScenePath" && i && !dd(t, s) && (this.control.internalSceneChange(d.id, s), (b = this.focuedView) == null || b.displayer.commiter.onChangeScene()), l === "cameraOpt" && !dd(t, s)) {
      if (s.width !== (t == null ? void 0 : t.width) || s.height !== (t == null ? void 0 : t.height)) {
        const Z = this.getView(l);
        Z == null || Z.displayer.updateSize();
      }
      this.control.internalCameraChange(d.id, s);
    }
  }
  destroyAppView(d, l = !1) {
    const i = this.appViews.get(d);
    i && (this.control.textEditorManager.clear(d, l), i.displayer.destroy(), this.appViews.delete(d));
  }
  createMianView(d) {
    this.mainView = new Proxy(d, {
      set: (l, i, t) => (this.control.worker.isActive && this.validator(l, i, t), l[i] = t, !0)
    });
  }
  createAppView(d) {
    const l = d.id, i = new Proxy(d, {
      set: (t, s, b) => (this.control.worker.isActive && this.validator(t, s, b), t[s] = b, !0)
    });
    this.appViews.set(l, i);
  }
  isAppView(d) {
    return d !== od.viewId && this.appViews.has(d);
  }
  getView(d) {
    var l;
    return d === od.viewId ? this.mainView : (l = this.appViews) == null ? void 0 : l.get(d);
  }
  getCurScenePath(d) {
    const l = this.getView(d);
    if (l)
      return l.focusScenePath;
  }
  getAllViews() {
    return [this.mainView, ...this.appViews.values()];
  }
  setViewScenePath(d, l) {
    var i;
    if (d === od.viewId && this.mainView)
      this.mainView.focusScenePath = l;
    else {
      const t = d && ((i = this.appViews) == null ? void 0 : i.get(d)) || void 0;
      t && (t.focusScenePath = l);
    }
  }
  setViewData(d, l) {
    var i;
    if (d === od.viewId && this.mainView)
      this.mainView.viewData = l;
    else {
      const t = d && ((i = this.appViews) == null ? void 0 : i.get(d)) || void 0;
      t && (t.viewData = l);
    }
  }
  setFocuedViewId(d) {
    var l;
    this.focuedViewId = d, d === od.viewId ? this.focuedView = this.mainView : this.focuedView = d && ((l = this.appViews) == null ? void 0 : l.get(d)) || void 0, this.control.cursor.onFocusViewChange(), this.focuedView && this.focuedView.displayer.commiter.onFocusView();
  }
  setViewFocusScenePath(d, l) {
    var t;
    let i;
    d === od.viewId ? i = this.mainView : i = (t = this.appViews) == null ? void 0 : t.get(d), i && (i.focusScenePath = l);
  }
  /** 销毁 */
  destroy() {
    var d;
    this.internalMsgEmitter.removeAllListeners("undoTickerStart"), this.internalMsgEmitter.removeAllListeners("undoTickerEnd"), this.internalMsgEmitter.removeAllListeners("excludeIds"), (d = this.mainView) == null || d.displayer.destroy(), this.appViews.forEach((l) => {
      l.displayer.destroy();
    });
  }
  /** 是否绘制浮动选框 */
  showFloatBar(d, l, i) {
    const t = this.getView(d), s = t == null ? void 0 : t.displayer.vDom;
    s && s.showFloatBar(l, i);
  }
  /** 激活浮动选框 */
  activeFloatBar(d) {
    var i;
    const l = (i = this.getView(d)) == null ? void 0 : i.displayer;
    l != null && l.vDom && l.vDom.setFloatZIndex(2);
  }
  /** 销毁浮动选框 */
  unActiveFloatBar(d) {
    const l = this.getView(d), i = l == null ? void 0 : l.displayer.vDom;
    i && i.setFloatZIndex(-1);
  }
  /** 激活刷新指针 */
  setActiveCursor(d, l) {
    const i = this.getView(d), t = i == null ? void 0 : i.displayer.vDom;
    t && t.setActiveCursor(l);
  }
  /** 激活刷新文字编辑器 */
  setActiveTextEditor(d, l) {
    const i = this.getView(d), t = i == null ? void 0 : i.displayer.vDom;
    t && t.setActiveTextEditor(l);
  }
}
Object.defineProperty(Od, "defaultCameraOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    centerX: 0,
    centerY: 0,
    scale: 1
  }
});
Object.defineProperty(Od, "defaultScreenCanvasOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    autoRender: !1,
    contextType: ii.Canvas2d
  }
});
Object.defineProperty(Od, "defaultLayerOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    offscreen: !0,
    handleEvent: !1,
    depth: !1
  }
});
class JG {
  constructor(d, l, i) {
    Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "commiter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cacheCursorPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (s.button === 0 && this.viewId) {
          const b = this.getPoint(s);
          this.cachePoint = b, b && this.control.worker.originalEventLintener(hl.Start, b, this.viewId);
        }
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (this.viewId) {
          const b = this.getPoint(s);
          this.cachePoint = b, b && this.control.worker.originalEventLintener(hl.Doing, b, this.viewId);
        }
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (s.button === 0 && this.viewId) {
          const b = this.getPoint(s) || this.cachePoint;
          b && this.control.worker.originalEventLintener(hl.Done, b, this.viewId), this.cachePoint = void 0;
        }
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (this.viewId) {
          const b = this.getPoint(s);
          this.cachePoint = b, b && this.control.worker.originalEventLintener(hl.Start, b, this.viewId);
        }
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wl((s) => {
        if (this.viewId) {
          const b = this.getPoint(s);
          this.cachePoint = b, b && this.control.worker.originalEventLintener(hl.Doing, b, this.viewId);
        }
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (this.viewId) {
          const b = this.getPoint(s) || this.cachePoint;
          b && this.control.worker.originalEventLintener(hl.Done, b, this.viewId), this.cachePoint = void 0;
        }
      }
    }), Object.defineProperty(this, "cursorMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wl((s) => {
        const b = this.getPoint(s);
        this.cacheCursorPoint && dd(b, this.cacheCursorPoint) || !this.viewId || (this.cacheCursorPoint = b, b && this.control.worker.sendCursorEvent(b, this.viewId));
      }, 30, { leading: !1 })
    }), Object.defineProperty(this, "cursorMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wl(() => {
        this.viewId && (this.cacheCursorPoint = [void 0, void 0], this.control.worker.sendCursorEvent(this.cacheCursorPoint, this.viewId));
      }, 30, { leading: !1 })
    }), Object.defineProperty(this, "keydown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.control.hotkeyManager.colloctHotkey(s);
      }
    }), this.viewId = d, this.control = l, this.internalMsgEmitter = i;
    const t = {
      control: this.control,
      internalMsgEmitter: this.internalMsgEmitter,
      viewId: this.viewId
    };
    this.commiter = new Yd(t);
  }
  bindToolsClass() {
    var l, i;
    const d = (i = (l = this.control.worker) == null ? void 0 : l.currentToolsData) == null ? void 0 : i.toolsType;
    switch (d) {
      case bl.Text:
      case bl.Pencil:
      case bl.LaserPen:
      case bl.Arrow:
      case bl.Straight:
      case bl.Rectangle:
      case bl.Ellipse:
      case bl.Star:
      case bl.Polygon:
      case bl.SpeechBalloon:
        this.eventTragetElement && (this.eventTragetElement.className = `netless-whiteboard ${d === bl.Text ? "cursor-text" : d === bl.Pencil || d === bl.LaserPen ? "cursor-pencil" : "cursor-arrow"}`);
        break;
    }
  }
  mountView() {
    this.setCanvassStyle(), this.control.viewContainerManager.mountView(this.viewId);
  }
  reflashContainerOffset() {
    this.eventTragetElement && (this.containerOffset = this.getContainerOffset(this.eventTragetElement, { x: 0, y: 0 }));
  }
  updateSize() {
    this.setCanvassStyle(), this.reflashContainerOffset();
  }
  setViewId(d) {
    this.viewId = d;
  }
  destroy() {
    this.eventTragetElement && this.removeDisplayerEvent(this.eventTragetElement);
  }
  getPoint(d) {
    const l = Ys(d);
    if (l && td(l.x) && td(l.y))
      return [l.x - this.containerOffset.x, l.y - this.containerOffset.y];
  }
  getTranslate(d) {
    const i = (d.style.WebkitTransform || getComputedStyle(d, "").getPropertyValue("-webkit-transform") || d.style.transform || getComputedStyle(d, "").getPropertyValue("transform")).match(/-?[0-9]+\.?[0-9]*/g), t = i && parseInt(i[0]) || 0, s = i && parseInt(i[1]) || 0;
    return [t, s];
  }
  getContainerOffset(d, l) {
    var s;
    const i = this.getTranslate(d);
    let t = {
      x: l.x + d.offsetLeft + i[0],
      y: l.y + d.offsetTop + i[1]
    };
    return (s = d.offsetParent) != null && s.nodeName && d.offsetParent.nodeName !== "BODY" && (t = this.getContainerOffset(d.offsetParent, t)), t;
  }
  bindDisplayerEvent(d) {
    d.addEventListener("mousedown", this.mousedown, !1), d.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("mouseleave", this.mouseup, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1), d.addEventListener("mousemove", this.cursorMouseMove, !1), d.addEventListener("mouseleave", this.cursorMouseLeave, !1), d.addEventListener("keydown", this.keydown, !0);
  }
  removeDisplayerEvent(d) {
    d.removeEventListener("mousedown", this.mousedown), d.removeEventListener("touchstart", this.touchstart), window.removeEventListener("mouseleave", this.mouseup), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend), d.removeEventListener("mousemove", this.cursorMouseMove), d.removeEventListener("mouseleave", this.cursorMouseLeave), d.removeEventListener("keydown", this.keydown);
  }
}
class od {
  constructor(d, l) {
    Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mainView"
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "internalMsgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "commiter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cacheCursorPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (t) => {
        if (t.button === 0) {
          this.reflashContainerOffset();
          const s = this.getPoint(t);
          this.cachePoint = s, s && this.control.worker.originalEventLintener(hl.Start, s, this.viewId);
        }
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (t) => {
        const s = this.getPoint(t);
        this.cachePoint = s, s && this.control.worker.originalEventLintener(hl.Doing, s, this.viewId);
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (t) => {
        if (t.button === 0) {
          const s = this.getPoint(t) || this.cachePoint;
          s && this.control.worker.originalEventLintener(hl.Done, s, this.viewId), this.cachePoint = void 0;
        }
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (t) => {
        this.reflashContainerOffset();
        const s = this.getPoint(t);
        this.cachePoint = s, s && this.control.worker.originalEventLintener(hl.Start, s, this.viewId);
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wl((t) => {
        const s = this.getPoint(t);
        this.cachePoint = s, s && this.control.worker.originalEventLintener(hl.Doing, s, this.viewId);
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (t) => {
        const s = this.getPoint(t) || this.cachePoint;
        s && this.control.worker.originalEventLintener(hl.Done, s, this.viewId), this.cachePoint = void 0;
      }
    }), Object.defineProperty(this, "cursorMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wl((t) => {
        const s = this.getPoint(t);
        this.cacheCursorPoint && dd(s, this.cacheCursorPoint) || (this.cacheCursorPoint = s, s && this.control.worker.sendCursorEvent(s, this.viewId));
      }, 30, { leading: !1 })
    }), Object.defineProperty(this, "cursorMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wl(() => {
        this.cacheCursorPoint = [void 0, void 0], this.control.worker.sendCursorEvent(this.cacheCursorPoint, this.viewId);
      }, 30, { leading: !1 })
    }), Object.defineProperty(this, "keydown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (t) => {
        this.control.hotkeyManager.colloctHotkey(t);
      }
    }), this.control = d, this.internalMsgEmitter = l;
    const i = {
      control: this.control,
      internalMsgEmitter: this.internalMsgEmitter,
      viewId: this.viewId
    };
    this.commiter = new Yd(i);
  }
  bindToolsClass() {
    var l, i;
    const d = (i = (l = this.control.worker) == null ? void 0 : l.currentToolsData) == null ? void 0 : i.toolsType;
    switch (d) {
      case bl.Text:
      case bl.Pencil:
      case bl.LaserPen:
      case bl.Arrow:
      case bl.Straight:
      case bl.Rectangle:
      case bl.Ellipse:
      case bl.Star:
      case bl.Polygon:
      case bl.SpeechBalloon:
        this.eventTragetElement && (this.eventTragetElement.className = `netless-whiteboard ${d === bl.Text ? "cursor-text" : d === bl.Pencil || d === bl.LaserPen ? "cursor-pencil" : "cursor-arrow"}`);
        break;
    }
  }
  mountView() {
    this.setCanvassStyle(), this.control.viewContainerManager.mountView(this.viewId);
  }
  updateSize() {
    this.setCanvassStyle();
  }
  reflashContainerOffset() {
    this.eventTragetElement && (this.containerOffset = this.getContainerOffset(this.eventTragetElement, { x: 0, y: 0 }));
  }
  destroy() {
    this.eventTragetElement && this.removeDisplayerEvent(this.eventTragetElement), this.vDom = void 0;
  }
  getPoint(d) {
    const l = Ys(d);
    if (l && td(l.x) && td(l.y))
      return [l.x - this.containerOffset.x, l.y - this.containerOffset.y];
  }
  getTranslate(d) {
    const i = (d.style.WebkitTransform || getComputedStyle(d, "").getPropertyValue("-webkit-transform") || d.style.transform || getComputedStyle(d, "").getPropertyValue("transform")).match(/-?[0-9]+\.?[0-9]*/g), t = i && parseInt(i[0]) || 0, s = i && parseInt(i[1]) || 0;
    return [t, s];
  }
  getContainerOffset(d, l) {
    var s;
    const i = this.getTranslate(d);
    let t = {
      x: l.x + d.offsetLeft + i[0],
      y: l.y + d.offsetTop + i[1]
    };
    return (s = d.offsetParent) != null && s.nodeName && d.offsetParent.nodeName !== "BODY" && (t = this.getContainerOffset(d.offsetParent, t)), t;
  }
  bindDisplayerEvent(d) {
    d.addEventListener("mousedown", this.mousedown, !1), d.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("mouseleave", this.mouseup, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1), d.addEventListener("mousemove", this.cursorMouseMove, !1), d.addEventListener("mouseleave", this.cursorMouseLeave, !1), d.addEventListener("keydown", this.keydown, !0);
  }
  removeDisplayerEvent(d) {
    d.removeEventListener("mousedown", this.mousedown), d.removeEventListener("touchstart", this.touchstart), window.removeEventListener("mouseleave", this.mouseup), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend), d.removeEventListener("mousemove", this.cursorMouseMove), d.removeEventListener("mouseleave", this.cursorMouseLeave), d.removeEventListener("keydown", this.keydown);
  }
}
Object.defineProperty(od, "viewId", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "mainView"
});
const NG = "index-module__Container__nLsM3", TG = "index-module__CanvasBox__j2Xe-", FG = "index-module__FloatCanvas__d1YR7", HG = "index-module__FloatBar__cm-EL", MG = "index-module__RotateBtn__HSSkf", zG = "index-module__ResizeBtn__yjvda", gG = "index-module__CursorBox__2UHvI", kG = "index-module__TextEditorContainer__Qm8KC", vG = "index-module__ResizeTowBox__HOllX", UG = "index-module__FloatBarBtn__FJrOG", hd = {
  Container: NG,
  CanvasBox: TG,
  FloatCanvas: FG,
  FloatBar: HG,
  RotateBtn: MG,
  ResizeBtn: zG,
  CursorBox: gG,
  TextEditorContainer: kG,
  ResizeTowBox: vG,
  FloatBarBtn: UG
}, QG = {
  delete: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDZ2NmEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2aDBtMS0yYTIgMiAwIDAgMSAyLTJoMmEyIDIgMCAwIDEgMiAyaDBNMyA0aDEwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  duplicate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0xMSAySDZhMSAxIDAgMCAwLTEgMXY4YTEgMSAwIDAgMCAxIDFoNmExIDEgMCAwIDAgMS0xVjRoMGwtMi0yeiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTExIDJ2MWExIDEgMCAwIDAgMSAxaDFsLTItMnoiLz48cGF0aCBkPSJNOSAxNEg0YTEgMSAwIDAgMS0xLTFWNWgwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9zdmc+",
  "layer-pressed": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzMzODFGRiIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  layer: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  rotate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTEzIDZhNiA2IDAgMSAxLTMuNzA5IDEuMjgzIi8+PHBhdGggZD0ibTEzIDYgMS40MTQgMi40NUwxMyA2bDIuNDUtMS40MTQiLz48L2c+PC9zdmc+",
  "rotation-button": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  rotation: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBmaWxsPSIjRkZGIiBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  "font-colors-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "font-colors": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "to-bottom": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDEwdjhtMCAwLTItMm0yIDIgMi0ybS00IDZoMTJtLTYtNGg2bS02LTRoNm0tNi00aDYiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  "to-top": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDIydi04bTAgMC0yIDJtMi0yIDIgMm0tNC02aDEybS02IDRoNm0tNiA0aDZtLTYgNGg2IiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  "bold-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQuNSAySDhhMi41IDIuNSAwIDAgMSAwIDVINS41aDBtLTEgMGg0YTMgMyAwIDAgMSAwIDZoLTQgMG0wIDFWMiIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  bold: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQuNSAySDhhMi41IDIuNSAwIDAgMSAwIDVINS41aDBtLTEgMGg0YTMgMyAwIDAgMSAwIDZoLTQgMG0wIDFWMiIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "underline-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDJ2NWE0IDQgMCAxIDEtOCAwVjJoME0zIDE0aDEwIiBzdHJva2U9IiMzMzgxRkYiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  underline: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDJ2NWE0IDQgMCAxIDEtOCAwVjJoME0zIDE0aDEwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  "line-through-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQgOGg4bS0xLTNhMyAzIDAgMCAwLTMtM2gtLjkzOEEyLjY0IDIuNjQgMCAwIDAgNC41IDRhMi41NyAyLjU3IDAgMCAwIDEuMzQ0IDIuOTIybDQuMzEyIDIuMTU2QTIuNTcgMi41NyAwIDAgMSAxMS41IDEyYTIuNjQgMi42NCAwIDAgMS0yLjU2MiAySDdhMyAzIDAgMCAxLTMtM2gwIiBzdHJva2U9IiMzMzgxRkYiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  "line-through": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQgOGg4bS0xLTNhMyAzIDAgMCAwLTMtM2gtLjkzOEEyLjY0IDIuNjQgMCAwIDAgNC41IDRhMi41NyAyLjU3IDAgMCAwIDEuMzQ0IDIuOTIybDQuMzEyIDIuMTU2QTIuNTcgMi41NyAwIDAgMSAxMS41IDEyYTIuNjQgMi42NCAwIDAgMS0yLjU2MiAySDdhMyAzIDAgMCAxLTMtM2gwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  "italic-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcgMTQgOSAyTTUgMTRoNE03IDJoNCIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  italic: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcgMTQgOSAyTTUgMTRoNE03IDJoNCIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "unlock-new": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48Y2lyY2xlIGZpbGw9IiMzMzgxRkYiIGN4PSIxNiIgY3k9IjE3IiByPSIxIi8+PHJlY3Qgc3Ryb2tlPSIjMzM4MUZGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjExIiB5PSIxNCIgd2lkdGg9IjEwIiBoZWlnaHQ9IjgiIHJ4PSIyIi8+PHBhdGggZD0iTTEzIDE0di0xYTMgMyAwIDAgMSA2IDB2MWgwbS0zIDN2MyIgc3Ryb2tlPSIjMzM4MUZGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L2c+PC9zdmc+",
  "lock-new": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48Y2lyY2xlIGZpbGw9IiM0NDRFNjAiIGN4PSIxNiIgY3k9IjE3IiByPSIxIi8+PHJlY3Qgc3Ryb2tlPSIjNDQ0RTYwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjExIiB5PSIxNCIgd2lkdGg9IjEwIiBoZWlnaHQ9IjgiIHJ4PSIyIi8+PHBhdGggZD0iTTEzIDE0di0zYTMgMyAwIDAgMSA2IDB2MWgwbS0zIDV2MyIgc3Ryb2tlPSIjNDQ0RTYwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L2c+PC9zdmc+",
  shapes: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTY4Mi42NjY2NjcgMTAyNEM2ODIuNjY2NjY3IDEwMjQgNjgyLjY2NjY2NyAxMDI0IDY4Mi42NjY2NjcgMTAyNEwxNzAuNjY2NjY3IDEwMjRjLTE3LjA2NjY2NyAwLTI5Ljg2NjY2Ny04LjUzMzMzMy0zOC40LTIxLjMzMzMzMy04LjUzMzMzMy0xMi44LTguNTMzMzMzLTI5Ljg2NjY2NyAwLTQyLjY2NjY2N2wyNTYtMzg0YzE3LjA2NjY2Ny0yNS42IDU1LjQ2NjY2Ny0yNS42IDcyLjUzMzMzMyAwbDI1MS43MzMzMzMgMzc5LjczMzMzM2M4LjUzMzMzMyA4LjUzMzMzMyAxMi44IDE3LjA2NjY2NyAxMi44IDI5Ljg2NjY2N0M3MjUuMzMzMzMzIDEwMDYuOTMzMzMzIDcwOC4yNjY2NjcgMTAyNCA2ODIuNjY2NjY3IDEwMjR6TTI1MS43MzMzMzMgOTM4LjY2NjY2N2wzNTQuMTMzMzMzIDBMNDI2LjY2NjY2NyA2NzQuMTMzMzMzIDI1MS43MzMzMzMgOTM4LjY2NjY2N3oiIGZpbGw9IiM0NDRFNjAiPjwvcGF0aD48cGF0aCBkPSJNOTgxLjMzMzMzMyA3MjUuMzMzMzMzbC0zNDEuMzMzMzMzIDBjLTI1LjYgMC00Mi42NjY2NjctMTcuMDY2NjY3LTQyLjY2NjY2Ny00Mi42NjY2NjdMNTk3LjMzMzMzMyAzNDEuMzMzMzMzYzAtMjUuNiAxNy4wNjY2NjctNDIuNjY2NjY3IDQyLjY2NjY2Ny00Mi42NjY2NjdsMzQxLjMzMzMzMyAwYzI1LjYgMCA0Mi42NjY2NjcgMTcuMDY2NjY3IDQyLjY2NjY2NyA0Mi42NjY2NjdsMCAzNDEuMzMzMzMzQzEwMjQgNzA4LjI2NjY2NyAxMDA2LjkzMzMzMyA3MjUuMzMzMzMzIDk4MS4zMzMzMzMgNzI1LjMzMzMzM3pNNjgyLjY2NjY2NyA2NDBsMjU2IDBMOTM4LjY2NjY2NyAzODRsLTI1NiAwTDY4Mi42NjY2NjcgNjQweiIgZmlsbD0iIzQ0NEU2MCI+PC9wYXRoPjxwYXRoIGQ9Ik0yNzcuMzMzMzMzIDU1NC42NjY2NjdDMTIzLjczMzMzMyA1NTQuNjY2NjY3IDAgNDMwLjkzMzMzMyAwIDI3Ny4zMzMzMzNTMTIzLjczMzMzMyAwIDI3Ny4zMzMzMzMgMCA1NTQuNjY2NjY3IDEyMy43MzMzMzMgNTU0LjY2NjY2NyAyNzcuMzMzMzMzIDQzMC45MzMzMzMgNTU0LjY2NjY2NyAyNzcuMzMzMzMzIDU1NC42NjY2Njd6TTI3Ny4zMzMzMzMgODUuMzMzMzMzQzE3MC42NjY2NjcgODUuMzMzMzMzIDg1LjMzMzMzMyAxNzAuNjY2NjY3IDg1LjMzMzMzMyAyNzcuMzMzMzMzUzE3MC42NjY2NjcgNDY5LjMzMzMzMyAyNzcuMzMzMzMzIDQ2OS4zMzMzMzMgNDY5LjMzMzMzMyAzODQgNDY5LjMzMzMzMyAyNzcuMzMzMzMzIDM4NCA4NS4zMzMzMzMgMjc3LjMzMzMzMyA4NS4zMzMzMzN6IiBmaWxsPSIjNDQ0RTYwIj48L3BhdGg+PC9zdmc+",
  "shapes-active": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTY4Mi42NjY2NjcgMTAyNEM2ODIuNjY2NjY3IDEwMjQgNjgyLjY2NjY2NyAxMDI0IDY4Mi42NjY2NjcgMTAyNEwxNzAuNjY2NjY3IDEwMjRjLTE3LjA2NjY2NyAwLTI5Ljg2NjY2Ny04LjUzMzMzMy0zOC40LTIxLjMzMzMzMy04LjUzMzMzMy0xMi44LTguNTMzMzMzLTI5Ljg2NjY2NyAwLTQyLjY2NjY2N2wyNTYtMzg0YzE3LjA2NjY2Ny0yNS42IDU1LjQ2NjY2Ny0yNS42IDcyLjUzMzMzMyAwbDI1MS43MzMzMzMgMzc5LjczMzMzM2M4LjUzMzMzMyA4LjUzMzMzMyAxMi44IDE3LjA2NjY2NyAxMi44IDI5Ljg2NjY2N0M3MjUuMzMzMzMzIDEwMDYuOTMzMzMzIDcwOC4yNjY2NjcgMTAyNCA2ODIuNjY2NjY3IDEwMjR6TTI1MS43MzMzMzMgOTM4LjY2NjY2N2wzNTQuMTMzMzMzIDBMNDI2LjY2NjY2NyA2NzQuMTMzMzMzIDI1MS43MzMzMzMgOTM4LjY2NjY2N3oiIGZpbGw9IiMzMzgxRkYiPjwvcGF0aD48cGF0aCBkPSJNOTgxLjMzMzMzMyA3MjUuMzMzMzMzbC0zNDEuMzMzMzMzIDBjLTI1LjYgMC00Mi42NjY2NjctMTcuMDY2NjY3LTQyLjY2NjY2Ny00Mi42NjY2NjdMNTk3LjMzMzMzMyAzNDEuMzMzMzMzYzAtMjUuNiAxNy4wNjY2NjctNDIuNjY2NjY3IDQyLjY2NjY2Ny00Mi42NjY2NjdsMzQxLjMzMzMzMyAwYzI1LjYgMCA0Mi42NjY2NjcgMTcuMDY2NjY3IDQyLjY2NjY2NyA0Mi42NjY2NjdsMCAzNDEuMzMzMzMzQzEwMjQgNzA4LjI2NjY2NyAxMDA2LjkzMzMzMyA3MjUuMzMzMzMzIDk4MS4zMzMzMzMgNzI1LjMzMzMzM3pNNjgyLjY2NjY2NyA2NDBsMjU2IDBMOTM4LjY2NjY2NyAzODRsLTI1NiAwTDY4Mi42NjY2NjcgNjQweiIgZmlsbD0iIzMzODFGRiI+PC9wYXRoPjxwYXRoIGQ9Ik0yNzcuMzMzMzMzIDU1NC42NjY2NjdDMTIzLjczMzMzMyA1NTQuNjY2NjY3IDAgNDMwLjkzMzMzMyAwIDI3Ny4zMzMzMzNTMTIzLjczMzMzMyAwIDI3Ny4zMzMzMzMgMCA1NTQuNjY2NjY3IDEyMy43MzMzMzMgNTU0LjY2NjY2NyAyNzcuMzMzMzMzIDQzMC45MzMzMzMgNTU0LjY2NjY2NyAyNzcuMzMzMzMzIDU1NC42NjY2Njd6TTI3Ny4zMzMzMzMgODUuMzMzMzMzQzE3MC42NjY2NjcgODUuMzMzMzMzIDg1LjMzMzMzMyAxNzAuNjY2NjY3IDg1LjMzMzMzMyAyNzcuMzMzMzMzUzE3MC42NjY2NjcgNDY5LjMzMzMzMyAyNzcuMzMzMzMzIDQ2OS4zMzMzMzMgNDY5LjMzMzMzMyAzODQgNDY5LjMzMzMzMyAyNzcuMzMzMzMzIDM4NCA4NS4zMzMzMzMgMjc3LjMzMzMzMyA4NS4zMzMzMzN6IiBmaWxsPSIjMzM4MUZGIj48L3BhdGg+PC9zdmc+",
  "font-style-active": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTM2MC4yMzQ2NjcgMjEzLjMzMzMzM0w1NTQuNjY2NjY3IDc3Ni4yNzczMzNoLTc2LjU0NGwtNTQuNjEzMzM0LTE3Mi4wMzJIMjE0LjE4NjY2N2wtNTUuNDY2NjY3IDE3Mi4wMzJIODUuMzMzMzMzTDI3OS43NjUzMzMgMjEzLjMzMzMzM2g4MC40NjkzMzR6IG00MTAuMDI2NjY2IDE3My44MjRjOTAuMTEyIDAgMTI4LjM0MTMzMyA2MC43NTczMzMgMTI4LjM0MTMzNCAxNTIuMjM0NjY3djIyOC4wMTA2NjdoLTUxLjJsLTUuNDYxMzM0LTQ0LjM3MzMzNGgtMi4wNDhjLTM1LjQ5ODY2NyAyOS4zNTQ2NjctNzcuMTQxMzMzIDUzLjI0OC0xMjIuODggNTMuMjQ4LTYyLjEyMjY2NyAwLTEwOC41NDQtMzguMjI5MzMzLTEwOC41NDQtMTA1LjEzMDY2NiAwLTgwLjU1NDY2NyA3MC4zMTQ2NjctMTIwLjgzMiAyMjguMDEwNjY3LTEzOC41ODEzMzQgMC00Ny43ODY2NjctMTUuNzAxMzMzLTkzLjUyNTMzMy03Ni40NTg2NjctOTMuNTI1MzMzLTQzLjAwOCAwLTgxLjkyIDE5Ljc5NzMzMy0xMTEuMjc0NjY2IDM5LjU5NDY2N2wtMjQuNTc2LTQzLjAwOGMzNC4xMzMzMzMtMjEuODQ1MzMzIDg2LjY5ODY2Ny00OC40NjkzMzMgMTQ2LjA5MDY2Ni00OC40NjkzMzR6IG02Ni4yMTg2NjcgMTg2LjM2OGMtMTI0LjkyOCAxNS4wMTg2NjctMTY3LjI1MzMzMyA0NS43Mzg2NjctMTY3LjI1MzMzMyA5My41MjUzMzQgMCA0Mi4zMjUzMzMgMjguNjcyIDU5LjM5MiA2NS41MzYgNTkuMzkyIDM2LjE4MTMzMyAwIDY1LjUzNi0xNy4wNjY2NjcgMTAxLjcxNzMzMy00OS4xNTJ6TTMyMC4zODQgMjcwLjkzMzMzM2gtMy4xMTQ2NjdjLTE3Ljk2MjY2NyA2Ni4wNDgtMzYuNjkzMzMzIDEyNi43Mi01Ny4wMDI2NjYgMTkwLjQ2NGwtMjguMTYgODYuMDE2aDE3My4zOTczMzNsLTI3LjMwNjY2Ny04Ni4wMTZBNDkxMy40OTMzMzMgNDkxMy40OTMzMzMgMCAwIDEgMzIwLjM4NCAyNzAuOTMzMzMzeiIgZmlsbD0iIzMzODFGRiI+PC9wYXRoPjwvc3ZnPg==",
  "font-style": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTM2MC4yMzQ2NjcgMjEzLjMzMzMzM0w1NTQuNjY2NjY3IDc3Ni4yNzczMzNoLTc2LjU0NGwtNTQuNjEzMzM0LTE3Mi4wMzJIMjE0LjE4NjY2N2wtNTUuNDY2NjY3IDE3Mi4wMzJIODUuMzMzMzMzTDI3OS43NjUzMzMgMjEzLjMzMzMzM2g4MC40NjkzMzR6IG00MTAuMDI2NjY2IDE3My44MjRjOTAuMTEyIDAgMTI4LjM0MTMzMyA2MC43NTczMzMgMTI4LjM0MTMzNCAxNTIuMjM0NjY3djIyOC4wMTA2NjdoLTUxLjJsLTUuNDYxMzM0LTQ0LjM3MzMzNGgtMi4wNDhjLTM1LjQ5ODY2NyAyOS4zNTQ2NjctNzcuMTQxMzMzIDUzLjI0OC0xMjIuODggNTMuMjQ4LTYyLjEyMjY2NyAwLTEwOC41NDQtMzguMjI5MzMzLTEwOC41NDQtMTA1LjEzMDY2NiAwLTgwLjU1NDY2NyA3MC4zMTQ2NjctMTIwLjgzMiAyMjguMDEwNjY3LTEzOC41ODEzMzQgMC00Ny43ODY2NjctMTUuNzAxMzMzLTkzLjUyNTMzMy03Ni40NTg2NjctOTMuNTI1MzMzLTQzLjAwOCAwLTgxLjkyIDE5Ljc5NzMzMy0xMTEuMjc0NjY2IDM5LjU5NDY2N2wtMjQuNTc2LTQzLjAwOGMzNC4xMzMzMzMtMjEuODQ1MzMzIDg2LjY5ODY2Ny00OC40NjkzMzMgMTQ2LjA5MDY2Ni00OC40NjkzMzR6IG02Ni4yMTg2NjcgMTg2LjM2OGMtMTI0LjkyOCAxNS4wMTg2NjctMTY3LjI1MzMzMyA0NS43Mzg2NjctMTY3LjI1MzMzMyA5My41MjUzMzQgMCA0Mi4zMjUzMzMgMjguNjcyIDU5LjM5MiA2NS41MzYgNTkuMzkyIDM2LjE4MTMzMyAwIDY1LjUzNi0xNy4wNjY2NjcgMTAxLjcxNzMzMy00OS4xNTJ6TTMyMC4zODQgMjcwLjkzMzMzM2gtMy4xMTQ2NjdjLTE3Ljk2MjY2NyA2Ni4wNDgtMzYuNjkzMzMzIDEyNi43Mi01Ny4wMDI2NjYgMTkwLjQ2NGwtMjguMTYgODYuMDE2aDE3My4zOTczMzNsLTI3LjMwNjY2Ny04Ni4wMTZBNDkxMy40OTMzMzMgNDkxMy40OTMzMzMgMCAwIDEgMzIwLjM4NCAyNzAuOTMzMzMzeiIgZmlsbD0iIzQ0NEU2MCI+PC9wYXRoPjwvc3ZnPg==",
  polygon: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTkzMy4xMiA0OTAuNjY2NjY3bC0xOTItMzMyLjM3MzMzNGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMCAwLTM3LjEyLTIxLjMzMzMzM2gtMzg0YTQyLjY2NjY2NyA0Mi42NjY2NjcgMCAwIDAtMzcuMTIgMjEuMzMzMzMzbC0xOTIgMzMyLjM3MzMzNGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMCAwIDAgNDIuNjY2NjY2bDE5MiAzMzIuMzczMzM0YTQyLjY2NjY2NyA0Mi42NjY2NjcgMCAwIDAgMzcuMTIgMjEuMzMzMzMzaDM4NGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMCAwIDM3LjEyLTIxLjMzMzMzM2wxOTItMzMyLjM3MzMzNGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMCAwIDAtNDIuNjY2NjY2eiBtLTI1NiAzMTEuMDRIMzQ0Ljc0NjY2N0wxNzcuMDY2NjY3IDUxMmwxNjcuNjgtMjg5LjcwNjY2N2gzMzQuNTA2NjY2TDg0Ni45MzMzMzMgNTEyeiIgZmlsbD0iIzQ0NEU2MCI+PC9wYXRoPjwvc3ZnPg==",
  "polygon-active": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTkzMy4xMiA0OTAuNjY2NjY3bC0xOTItMzMyLjM3MzMzNGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMCAwLTM3LjEyLTIxLjMzMzMzM2gtMzg0YTQyLjY2NjY2NyA0Mi42NjY2NjcgMCAwIDAtMzcuMTIgMjEuMzMzMzMzbC0xOTIgMzMyLjM3MzMzNGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMCAwIDAgNDIuNjY2NjY2bDE5MiAzMzIuMzczMzM0YTQyLjY2NjY2NyA0Mi42NjY2NjcgMCAwIDAgMzcuMTIgMjEuMzMzMzMzaDM4NGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMCAwIDM3LjEyLTIxLjMzMzMzM2wxOTItMzMyLjM3MzMzNGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMCAwIDAtNDIuNjY2NjY2eiBtLTI1NiAzMTEuMDRIMzQ0Ljc0NjY2N0wxNzcuMDY2NjY3IDUxMmwxNjcuNjgtMjg5LjcwNjY2N2gzMzQuNTA2NjY2TDg0Ni45MzMzMzMgNTEyeiIgZmlsbD0iIzMzODFGRiI+PC9wYXRoPjwvc3ZnPg==",
  "polygon-vertex": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTA3NyAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTU0My40NzQ1MjYgNDIuMzA3MzY4YTExOS4zNzY4NDIgMTE5LjM3Njg0MiAwIDAgMSAxMTAuODA3NTc5IDE2My44NGwxOTAuNTcxNzkgMTM4LjYxNzI2NGExMTkuMzc2ODQyIDExOS4zNzY4NDIgMCAxIDEgODMuMzc1MTU4IDIxOC43MDQ4NDJsLTc0LjMyMDg0MiAyMjguODM3MDUyYTExOS4zMjI5NDcgMTE5LjMyMjk0NyAwIDAgMS02MS4yNzgzMTYgMjIxLjg4NDYzMmMtNDYuNzgwNjMyIDAtODcuMzA5NDc0LTI2Ljk0NzM2OC0xMDYuODczMjYzLTY2LjEyODg0MmgtMjg5LjQxNDczN2ExMTkuMzc2ODQyIDExOS4zNzY4NDIgMCAxIDEtMTc5LjczODk0OC0xNDcuODMzMjYzbC03Mi4yNzI4NDItMjIyLjY5MzA1My0zLjM5NTM2OCAwLjEwNzc4OUExMTkuMzc2ODQyIDExOS4zNzY4NDIgMCAwIDEgMjEuODI3MzY4IDQ2Ni43Mjg0MjFMMjEuNTU3ODk1IDQ1OC4yMTMwNTNhMTE5LjM3Njg0MiAxMTkuMzc2ODQyIDAgMCAxIDE4My44MzQ5NDctMTAwLjUxMzY4NWwyMjMuNTAxNDc0LTE2Mi4zODQ4NDJhMTE5LjQzMDczNyAxMTkuNDMwNzM3IDAgMCAxIDExNC41ODAyMS0xNTMuMDYxMDUyek0yODkuNDE0NzM3IDg0MC4wNTcyNjNhNTQuNzAzMTU4IDU0LjcwMzE1OCAwIDEgMCAwIDEwOS40MDYzMTYgNTQuNzAzMTU4IDU0LjcwMzE1OCAwIDAgMCAwLTEwOS40MDYzMTZ6IG01MDMuMTYxMjYzIDBhNTQuNzAzMTU4IDU0LjcwMzE1OCAwIDEgMCAwIDEwOS40MDYzMTYgNTQuNzAzMTU4IDU0LjcwMzE1OCAwIDAgMCAwLTEwOS40MDYzMTZ6TTQ2Mi42ODYzMTYgMjQ5LjU4NjUyNkwyNDguMTMxMzY4IDQwNS41NTc4OTVhMTE5LjMyMjk0NyAxMTkuMzIyOTQ3IDAgMCAxLTQyLjg0NjMxNSAxNTMuMjIyNzM3bDcwLjcwOTg5NCAyMTcuMzU3NDczYTExOS40MzA3MzcgMTE5LjQzMDczNyAwIDAgMSAxMzIuNDE5MzY5IDEwOC4yMjA2MzJINjczLjY4NDIxMWExMTkuNDMwNzM3IDExOS40MzA3MzcgMCAwIDEgMTE5LjE2MTI2My0xMDguOTc1MTU4bDcxLjE0MTA1Mi0yMTguOTc0MzE2YTExOS40MzA3MzcgMTE5LjQzMDczNyAwIDAgMS02Mi4wODY3MzctMTY0LjIxNzI2M2wtMTg2LjM2OC0xMzUuMjc1Nzg5Yy0xOS45OTQ5NDcgMTUuMDkwNTI2LTQ1LjAwMjEwNSAyNC4xNDQ4NDItNzIuMDU3MjYzIDI0LjE0NDg0MmExMTguOTQ1Njg0IDExOC45NDU2ODQgMCAwIDEtODAuNzg4MjEtMzEuNDc0NTI3eiBtLTMyMS43NTE1NzkgMTUzLjkyMzM2OWE1NC43MDMxNTggNTQuNzAzMTU4IDAgMSAwIDAgMTA5LjQwNjMxNiA1NC43MDMxNTggNTQuNzAzMTU4IDAgMCAwIDAtMTA5LjQwNjMxNnogbTc2Ny43MzA1MjYtMTIuNTU3NDc0YTU0LjcwMzE1OCA1NC43MDMxNTggMCAxIDAgMCAxMDkuNDA2MzE2IDU0LjcwMzE1OCA1NC43MDMxNTggMCAwIDAgMC0xMDkuNDA2MzE2eiBtLTM2NS4xOTA3MzctMjg0LjAyNTI2M2E1NC43MDMxNTggNTQuNzAzMTU4IDAgMSAwIDAgMTA5LjQ2MDIxIDU0LjcwMzE1OCA1NC43MDMxNTggMCAwIDAgMC0xMDkuNDA2MzE1eiIgZmlsbD0iIzQ0NEU2MCI+PC9wYXRoPjwvc3ZnPg==",
  star: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTkwOC4xIDM1My4xbC0yNTMuOS0zNi45TDU0MC43IDg2LjFjLTMuMS02LjMtOC4yLTExLjQtMTQuNS0xNC41LTE1LjgtNy44LTM1LTEuMy00Mi45IDE0LjVMMzY5LjggMzE2LjJsLTI1My45IDM2LjljLTcgMS0xMy40IDQuMy0xOC4zIDkuMy0xMi4zIDEyLjctMTIuMSAzMi45IDAuNiA0NS4zbDE4My43IDE3OS4xLTQzLjQgMjUyLjljLTEuMiA2LjktMC4xIDE0LjEgMy4yIDIwLjMgOC4yIDE1LjYgMjcuNiAyMS43IDQzLjIgMTMuNEw1MTIgNzU0bDIyNy4xIDExOS40YzYuMiAzLjMgMTMuNCA0LjQgMjAuMyAzLjIgMTcuNC0zIDI5LjEtMTkuNSAyNi4xLTM2LjlsLTQzLjQtMjUyLjkgMTgzLjctMTc5LjFjNS00LjkgOC4zLTExLjMgOS4zLTE4LjMgMi43LTE3LjUtOS41LTMzLjctMjctMzYuM3pNNjY0LjggNTYxLjZsMzYuMSAyMTAuM0w1MTIgNjcyLjcgMzIzLjEgNzcybDM2LjEtMjEwLjMtMTUyLjgtMTQ5TDQxNy42IDM4MiA1MTIgMTkwLjcgNjA2LjQgMzgybDIxMS4yIDMwLjctMTUyLjggMTQ4Ljl6IiBmaWxsPSIjNDQ0RTYwIj48L3BhdGg+PC9zdmc+",
  "star-active": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTkwOC4xIDM1My4xbC0yNTMuOS0zNi45TDU0MC43IDg2LjFjLTMuMS02LjMtOC4yLTExLjQtMTQuNS0xNC41LTE1LjgtNy44LTM1LTEuMy00Mi45IDE0LjVMMzY5LjggMzE2LjJsLTI1My45IDM2LjljLTcgMS0xMy40IDQuMy0xOC4zIDkuMy0xMi4zIDEyLjctMTIuMSAzMi45IDAuNiA0NS4zbDE4My43IDE3OS4xLTQzLjQgMjUyLjljLTEuMiA2LjktMC4xIDE0LjEgMy4yIDIwLjMgOC4yIDE1LjYgMjcuNiAyMS43IDQzLjIgMTMuNEw1MTIgNzU0bDIyNy4xIDExOS40YzYuMiAzLjMgMTMuNCA0LjQgMjAuMyAzLjIgMTcuNC0zIDI5LjEtMTkuNSAyNi4xLTM2LjlsLTQzLjQtMjUyLjkgMTgzLjctMTc5LjFjNS00LjkgOC4zLTExLjMgOS4zLTE4LjMgMi43LTE3LjUtOS41LTMzLjctMjctMzYuM3pNNjY0LjggNTYxLjZsMzYuMSAyMTAuM0w1MTIgNjcyLjcgMzIzLjEgNzcybDM2LjEtMjEwLjMtMTUyLjgtMTQ5TDQxNy42IDM4MiA1MTIgMTkwLjcgNjA2LjQgMzgybDIxMS4yIDMwLjctMTUyLjggMTQ4Ljl6IiBmaWxsPSIjMzM4MUZGIj48L3BhdGg+PC9zdmc+",
  "star-innerVertex": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTg1LjMzMzMzMyAwYTg1LjMzMzMzMyA4NS4zMzMzMzMgMCAwIDEgODEuNDA4IDU5LjczMzMzM2g0OC4yMTMzMzR2ODUuMzMzMzM0TDE3MC42NjY2NjcgMTQ0Ljk4MTMzM1Y4NTMuMzMzMzMzaDY5My4zMzMzMzNsLTI2LjQ1MzMzMy02My40ODggNzguNzYyNjY2LTMyLjc2OCAzMi44NTMzMzQgNzguNzYyNjY3LTQyLjI0IDE3LjQ5MzMzM0g5MzguNjY2NjY3YTg1LjMzMzMzMyA4NS4zMzMzMzMgMCAwIDEgODQuNzM2IDc1LjM0OTMzNEwxMDI0IDkzOC42NjY2NjdhODUuMzMzMzMzIDg1LjMzMzMzMyAwIDAgMS0xNzAuNjY2NjY3IDBIMTcwLjY2NjY2N2E4NS4zMzMzMzMgODUuMzMzMzMzIDAgMSAxLTg1LjMzMzMzNC04NS4zMzMzMzRWMTcwLjY2NjY2N2E4NS4zMzMzMzMgODUuMzMzMzMzIDAgMSAxIDAtMTcwLjY2NjY2N3ogbTc2NS4zNTQ2NjcgNTk5LjQ2NjY2N2wzMi44NTMzMzMgNzguNzYyNjY2LTc4Ljg0OCAzMi44NTMzMzQtMzIuNzY4LTc4Ljc2MjY2NyA3OC43NjI2NjctMzIuODUzMzMzeiBtLTY1LjcwNjY2Ny0xNTcuNTI1MzM0bDMyLjg1MzMzNCA3OC43NjI2NjctNzguNzYyNjY3IDMyLjg1MzMzMy0zMi43NjgtNzguNzYyNjY2IDc4Ljc2MjY2Ny0zMi44NTMzMzR6TTcxOS4zNiAyODQuNDE2bDMyLjg1MzMzMyA3OC43NjI2NjctNzguNzYyNjY2IDMyLjg1MzMzMy0zMi44NTMzMzQtNzguNzYyNjY3IDc4Ljc2MjY2Ny0zMi44NTMzMzN6IG0tNjUuNjIxMzMzLTE1Ny41MjUzMzNsMzIuODUzMzMzIDc4Ljc2MjY2Ni03OC43NjI2NjcgMzIuODUzMzM0LTMyLjg1MzMzMy03OC43NjI2NjcgNzguNzYyNjY3LTMyLjg1MzMzM3pNMzg1LjcwNjY2NyA1OS43MzMzMzN2ODUuMzMzMzM0aC04NS4zMzMzMzR2LTg1LjMzMzMzNGg4NS4zMzMzMzR6IG0xNzAuNjY2NjY2IDB2ODUuMzMzMzM0aC04NS4zMzMzMzN2LTg1LjMzMzMzNGg4NS4zMzMzMzN6IiBmaWxsPSIjNDQ0RTYwIiA+PC9wYXRoPjwvc3ZnPg==",
  "star-innerRatio": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTU2OS4zNDQgNDQ5LjUzNmwxNDYuOTQ0IDI4LjY3MiAxLjAyNC00LjYwOHY0LjYwOGgxLjAyNGM5LjcyOCAwIDE2Ljg5Ni03LjY4IDIwLjQ4LTE0Ljg0OGwxLjAyNC0yLjA0OHYtMi41NmMwLTUuNjMyIDAtMTEuMjY0LTUuMTItMTYuMzg0LTMuMDcyLTMuMDcyLTcuMTY4LTcuMTY4LTEyLjgtNy42OGwtMTI0LjkyOC0yNC4wNjRMNTQxLjY5NiAyODYuNzJjLTIuMDQ4LTQuNjA4LTYuNjU2LTguMTkyLTExLjc3Ni05LjcyOC01LjEyLTEuNTM2LTEwLjc1Mi0xLjUzNi0xNS4zNiAxLjAyNGwtMS41MzYgMC41MTItMS4wMjQgMS4wMjRjLTguMTkyIDguMTkyLTEwLjc1MiAxOS40NTYtNi42NTYgMjcuMTM2bDY0IDE0Mi44NDh6IiBmaWxsPSIjMzM4MUZGIj48L3BhdGg+PHBhdGggZD0iTTkzMS4zMjggNDAzLjQ1NmMtMTAuMjQtMzUuMzI4LTM4LjQtNjEuNDQtNzEuNjgtNjYuNTZsLTE4NC44MzItMzUuODQtODIuNDMyLTE4Mi43ODRjLTEyLjgtMzMuMjgtNDYuMDgtNTYuMzItODAuMzg0LTU2LjMyLTMzLjc5MiAwLTY0LjUxMiAyMC40OC03OS44NzIgNTMuNzZMMzQ5LjE4NCAyOTkuMDA4bC0xODQuMzIgMzUuMzI4Yy0zMy43OTIgNS4xMi02MS45NTIgMzEuMjMyLTcyLjE5MiA2Ni41Ni05LjcyOCAzNC4zMDQtMS4wMjQgNzIuMTkyIDIzLjA0IDk4LjgxNmwxMzEuNTg0IDEzMy42MzItMzUuODQgMTk2LjYwOGMtNS42MzIgMzQuODE2IDguNzA0IDcxLjY4IDM1Ljg0IDk0LjIwOCAxMy44MjQgMTEuMjY0IDM0LjMwNCAxOC40MzIgNTIuMjI0IDE4LjQzMiAxNi44OTYgMCAyOS42OTYtMy4wNzIgNDEuNDcyLTEwLjI0bDE2OC45Ni05MS4xMzYgMTY2LjkxMiA5MS4xMzYgMS4wMjQgMC41MTJjMTYuODk2IDYuNjU2IDI5LjY5NiA5LjcyOCA0MC40NDggOS43MjggMTQuMzM2IDAgMjcuNjQ4LTQuMDk2IDQwLjQ0OC03LjY4IDQuNjA4LTEuNTM2IDkuNzI4LTMuMDcyIDE0Ljg0OC00LjA5NmwyLjU2LTAuNTEyIDIuMDQ4LTEuNTM2YzI1LjA4OC0yMy4wNCAzNy44ODgtNTguODggMzIuNzY4LTkzLjY5NmwtMzMuMjgtMTk2LjYwOCAxMzEuNTg0LTEzNi4xOTJjMjQuMDY0LTI3LjY0OCAzMi4yNTYtNjIuOTc2IDIyLjAxNi05OC44MTZ6TTI3Ni45OTIgODM2LjA5Nmw0MS45ODQtMjMxLjkzNi0xNTcuMTg0LTE1OS4yMzJjLTUuNjMyLTUuNjMyLTguMTkyLTE3LjQwOC02LjY1Ni0yOS4xODQgMy41ODQtMTAuMjQgMTAuMjQtMTYuMzg0IDE5LjQ1Ni0xNy45MmwyMTguMTEyLTQxLjk4NCA5Ni4yNTYtMjE1LjU1MmMzLjA3Mi03LjE2OCAxMi44LTE0LjMzNiAyMC40OC0xNC4zMzZzMTcuNDA4IDcuMTY4IDIwLjQ4IDE0Ljg0OGw5OC4zMDQgMjE1LjA0IDIxOC4xMTIgNDEuOTg0YzcuMTY4IDEuNTM2IDE1LjM2IDcuMTY4IDE2Ljg5NiAxNi4zODR2My4wNzJjMi4wNDggMTEuNzc2LTAuNTEyIDIyLjUyOC02LjY1NiAzMC43Mkw2OTkuOTA0IDYwOS4yOGwzOS45MzYgMjMxLjQyNGMxLjUzNiAxMC43NTItMi4wNDggMjAuNDgtMTAuMjQgMjcuMTM2bC0xLjAyNCAwLjUxMmMtMi41NiAyLjU2LTYuNjU2IDQuMDk2LTExLjI2NCA0LjA5Ni0yLjA0OCAwLTcuMTY4LTEuNTM2LTExLjI2NC0zLjU4NGwtMTk3LjEyLTEwOC4wMzItMTk5LjE2OCAxMDIuOTEyYy00LjA5NiAyLjA0OC05LjIxNiAzLjU4NC0xMS43NzYgMy41ODQtNC42MDggMC04LjcwNC0xLjUzNi0xMS4yNjQtNC4wOTZsLTEuMDI0LTAuNTEyYy02LjY1Ni02LjE0NC0xMC43NTItMTYuMzg0LTguNzA0LTI2LjYyNHoiIGZpbGw9IiM0NDRFNjAiPjwvcGF0aD48L3N2Zz4=",
  speechBallon: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTgzMiA4MzJINDQ4bC0xMjggMTkyLTEyOC0xOTJjLTEwNi4wNDggMC0xOTItODYuMDE2LTE5Mi0xOTJWMTkyYTE5MiAxOTIgMCAwIDEgMTkyLTE5Mmg2NDBjMTA1Ljk4NCAwIDE5MiA4NS45NTIgMTkyIDE5MnY0NDhjMCAxMDUuOTg0LTg2LjAxNiAxOTItMTkyIDE5MnogbTY0LTY0MGE2NCA2NCAwIDAgMC02NC02NEgxOTJDMTU2LjY3MiAxMjggMTI4IDE1Ni42NzIgMTI4IDE5MnY0NDhhNjQgNjQgMCAwIDAgNjQgNjRoNDIuNjg4TDMyMCA4MzJsODUuMzEyLTEyOEg4MzJjMzUuMzkyIDAgNjQtMjguNjA4IDY0LTY0VjE5MnoiIGZpbGw9IiM0NDRFNjAiPjwvcGF0aD48L3N2Zz4=",
  "speechBallon-active": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTgzMiA4MzJINDQ4bC0xMjggMTkyLTEyOC0xOTJjLTEwNi4wNDggMC0xOTItODYuMDE2LTE5Mi0xOTJWMTkyYTE5MiAxOTIgMCAwIDEgMTkyLTE5Mmg2NDBjMTA1Ljk4NCAwIDE5MiA4NS45NTIgMTkyIDE5MnY0NDhjMCAxMDUuOTg0LTg2LjAxNiAxOTItMTkyIDE5MnogbTY0LTY0MGE2NCA2NCAwIDAgMC02NC02NEgxOTJDMTU2LjY3MiAxMjggMTI4IDE1Ni42NzIgMTI4IDE5MnY0NDhhNjQgNjQgMCAwIDAgNjQgNjRoNDIuNjg4TDMyMCA4MzJsODUuMzEyLTEyOEg4MzJjMzUuMzkyIDAgNjQtMjguNjA4IDY0LTY0VjE5MnoiIGZpbGw9IiMzMzgxRkYiPjwvcGF0aD48L3N2Zz4=",
  "speechBallon-placement": "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTU3NiAyMTMuMzMzMzMzbDIyLjYxMzMzMyAyMi42MTMzMzRhMzIgMzIgMCAwIDAgMC00NS4yMjY2NjdMNTc2IDIxMy4zMzMzMzN6IG0tNjIuNzItMTA3Ljk0NjY2NmEzMiAzMiAwIDEgMC00NS4yMjY2NjcgNDUuMjI2NjY2bDQ1LjIyNjY2Ny00NS4yMjY2NjZ6IG0tNDUuMjI2NjY3IDE3MC42NjY2NjZhMzIgMzIgMCAwIDAgNDUuMjI2NjY3IDQ1LjIyNjY2N2wtNDUuMjI2NjY3LTQ1LjIyNjY2N3pNNDQ4IDgxMC42NjY2NjdsLTIyLjYxMzMzMy0yMi42MTMzMzRhMzIgMzIgMCAwIDAgMCA0NS4yMjY2NjdsMjIuNjEzMzMzLTIyLjYxMzMzM3ogbTEwNy45NDY2NjctNjIuNzJhMzIgMzIgMCAxIDAtNDUuMjI2NjY3LTQ1LjIyNjY2N2w0NS4yMjY2NjcgNDUuMjI2NjY3eiBtLTQ1LjIyNjY2NyAxNzAuNjY2NjY2YTMyIDMyIDAgMSAwIDQ1LjIyNjY2Ny00NS4yMjY2NjZsLTQ1LjIyNjY2NyA0NS4yMjY2NjZ6TTgxMC42NjY2NjcgNTc2bC0yMi42MTMzMzQgMjIuNjEzMzMzYTMyIDMyIDAgMCAwIDQ1LjIyNjY2NyAwTDgxMC42NjY2NjcgNTc2eiBtMTA3Ljk0NjY2Ni02Mi43MmEzMiAzMiAwIDEgMC00NS4yMjY2NjYtNDUuMjI2NjY3bDQ1LjIyNjY2NiA0NS4yMjY2Njd6IG0tMTcwLjY2NjY2Ni00NS4yMjY2NjdhMzIgMzIgMCAxIDAtNDUuMjI2NjY3IDQ1LjIyNjY2N2w0NS4yMjY2NjctNDUuMjI2NjY3ek0yMTMuMzMzMzMzIDQ0OGwyMi42MTMzMzQtMjIuNjEzMzMzYTMyIDMyIDAgMCAwLTQ1LjIyNjY2NyAwbDIyLjYxMzMzMyAyMi42MTMzMzN6IG02Mi43MiAxMDcuOTQ2NjY3YTMyIDMyIDAgMCAwIDQ1LjIyNjY2Ny00NS4yMjY2NjdsLTQ1LjIyNjY2NyA0NS4yMjY2Njd6IG0tMTcwLjY2NjY2Ni00NS4yMjY2NjdhMzIgMzIgMCAxIDAgNDUuMjI2NjY2IDQ1LjIyNjY2N2wtNDUuMjI2NjY2LTQ1LjIyNjY2N3pNMzA5LjMzMzMzMyAyMTMuMzMzMzMzQTc0LjY2NjY2NyA3NC42NjY2NjcgMCAwIDEgMjM0LjY2NjY2NyAyODh2NjRBMTM4LjY2NjY2NyAxMzguNjY2NjY3IDAgMCAwIDM3My4zMzMzMzMgMjEzLjMzMzMzM2gtNjR6TTIzNC42NjY2NjcgMjg4QTc0LjY2NjY2NyA3NC42NjY2NjcgMCAwIDEgMTYwIDIxMy4zMzMzMzNoLTY0QTEzOC42NjY2NjcgMTM4LjY2NjY2NyAwIDAgMCAyMzQuNjY2NjY3IDM1MnYtNjR6TTE2MCAyMTMuMzMzMzMzYzAtNDEuMjE2IDMzLjQ1MDY2Ny03NC42NjY2NjcgNzQuNjY2NjY3LTc0LjY2NjY2NnYtNjRBMTM4LjY2NjY2NyAxMzguNjY2NjY3IDAgMCAwIDk2IDIxMy4zMzMzMzNoNjR6TTIzNC42NjY2NjcgMTM4LjY2NjY2N2M0MS4yMTYgMCA3NC42NjY2NjcgMzMuNDUwNjY3IDc0LjY2NjY2NiA3NC42NjY2NjZoNjRBMTM4LjY2NjY2NyAxMzguNjY2NjY3IDAgMCAwIDIzNC42NjY2NjcgNzQuNjY2NjY3djY0ek0zNDEuMzMzMzMzIDI0NS4zMzMzMzNoMjM0LjY2NjY2N3YtNjRIMzQxLjMzMzMzM3Y2NHogbTI1Ny4yOC01NC42MTMzMzNsLTg1LjMzMzMzMy04NS4zMzMzMzMtNDUuMjI2NjY3IDQ1LjIyNjY2NiA4NS4zMzMzMzQgODUuMzMzMzM0IDQ1LjIyNjY2Ni00NS4yMjY2Njd6IG0tNDUuMjI2NjY2IDBsLTg1LjMzMzMzNCA4NS4zMzMzMzMgNDUuMjI2NjY3IDQ1LjIyNjY2NyA4NS4zMzMzMzMtODUuMzMzMzMzLTQ1LjIyNjY2Ni00NS4yMjY2Njd6TTY1MC42NjY2NjcgODEwLjY2NjY2N2ExMzguNjY2NjY3IDEzOC42NjY2NjcgMCAwIDAgMTM4LjY2NjY2NiAxMzguNjY2NjY2di02NEE3NC42NjY2NjcgNzQuNjY2NjY3IDAgMCAxIDcxNC42NjY2NjcgODEwLjY2NjY2N2gtNjR6IG0xMzguNjY2NjY2IDEzOC42NjY2NjZBMTM4LjY2NjY2NyAxMzguNjY2NjY3IDAgMCAwIDkyOCA4MTAuNjY2NjY3aC02NGE3NC42NjY2NjcgNzQuNjY2NjY3IDAgMCAxLTc0LjY2NjY2NyA3NC42NjY2NjZ2NjR6TTkyOCA4MTAuNjY2NjY3YTEzOC42NjY2NjcgMTM4LjY2NjY2NyAwIDAgMC0xMzguNjY2NjY3LTEzOC42NjY2Njd2NjRjNDEuMjE2IDAgNzQuNjY2NjY3IDMzLjQ1MDY2NyA3NC42NjY2NjcgNzQuNjY2NjY3aDY0eiBtLTEzOC42NjY2NjctMTM4LjY2NjY2N0ExMzguNjY2NjY3IDEzOC42NjY2NjcgMCAwIDAgNjUwLjY2NjY2NyA4MTAuNjY2NjY3aDY0YzAtNDEuMjE2IDMzLjQ1MDY2Ny03NC42NjY2NjcgNzQuNjY2NjY2LTc0LjY2NjY2N3YtNjR6IG0tMTA2LjY2NjY2NiAxMDYuNjY2NjY3aC0yMzQuNjY2NjY3djY0SDY4Mi42NjY2Njd2LTY0eiBtLTIxMi4wNTMzMzQgNTQuNjEzMzMzbDg1LjMzMzMzNC04NS4zMzMzMzMtNDUuMjI2NjY3LTQ1LjIyNjY2Ny04NS4zMzMzMzMgODUuMzMzMzMzIDQ1LjIyNjY2NiA0NS4yMjY2Njd6IG0tNDUuMjI2NjY2IDBsODUuMzMzMzMzIDg1LjMzMzMzMyA0NS4yMjY2NjctNDUuMjI2NjY2LTg1LjMzMzMzNC04NS4zMzMzMzQtNDUuMjI2NjY2IDQ1LjIyNjY2N3pNNjcyIDIzNC42NjY2NjdBMTM4LjY2NjY2NyAxMzguNjY2NjY3IDAgMCAwIDgxMC42NjY2NjcgMzczLjMzMzMzM3YtNjRhNzQuNjY2NjY3IDc0LjY2NjY2NyAwIDAgMS03NC42NjY2NjctNzQuNjY2NjY2aC02NHpNODEwLjY2NjY2NyAzNzMuMzMzMzMzYTEzOC42NjY2NjcgMTM4LjY2NjY2NyAwIDAgMCAxMzguNjY2NjY2LTEzOC42NjY2NjZoLTY0QTc0LjY2NjY2NyA3NC42NjY2NjcgMCAwIDEgODEwLjY2NjY2NyAzMDkuMzMzMzMzdjY0eiBtMTM4LjY2NjY2Ni0xMzguNjY2NjY2QTEzOC42NjY2NjcgMTM4LjY2NjY2NyAwIDAgMCA4MTAuNjY2NjY3IDk2djY0YzQxLjIxNiAwIDc0LjY2NjY2NyAzMy40NTA2NjcgNzQuNjY2NjY2IDc0LjY2NjY2N2g2NHpNODEwLjY2NjY2NyA5NmExMzguNjY2NjY3IDEzOC42NjY2NjcgMCAwIDAtMTM4LjY2NjY2NyAxMzguNjY2NjY3aDY0YzAtNDEuMjE2IDMzLjQ1MDY2Ny03NC42NjY2NjcgNzQuNjY2NjY3LTc0LjY2NjY2N3YtNjR6TTc3OC42NjY2NjcgMzQxLjMzMzMzM3YyMzQuNjY2NjY3aDY0VjM0MS4zMzMzMzNoLTY0eiBtNTQuNjEzMzMzIDI1Ny4yOGw4NS4zMzMzMzMtODUuMzMzMzMzLTQ1LjIyNjY2Ni00NS4yMjY2NjctODUuMzMzMzM0IDg1LjMzMzMzNCA0NS4yMjY2NjcgNDUuMjI2NjY2eiBtMC00NS4yMjY2NjZsLTg1LjMzMzMzMy04NS4zMzMzMzQtNDUuMjI2NjY3IDQ1LjIyNjY2NyA4NS4zMzMzMzMgODUuMzMzMzMzIDQ1LjIyNjY2Ny00NS4yMjY2NjZ6TTEzOC42NjY2NjcgNzg5LjMzMzMzM2MwLTQxLjIxNiAzMy40NTA2NjctNzQuNjY2NjY3IDc0LjY2NjY2Ni03NC42NjY2NjZ2LTY0YTEzOC42NjY2NjcgMTM4LjY2NjY2NyAwIDAgMC0xMzguNjY2NjY2IDEzOC42NjY2NjZoNjR6TTIxMy4zMzMzMzMgNzE0LjY2NjY2N2M0MS4yMTYgMCA3NC42NjY2NjcgMzMuNDUwNjY3IDc0LjY2NjY2NyA3NC42NjY2NjZoNjRBMTM4LjY2NjY2NyAxMzguNjY2NjY3IDAgMCAwIDIxMy4zMzMzMzMgNjUwLjY2NjY2N3Y2NHogbTc0LjY2NjY2NyA3NC42NjY2NjZBNzQuNjY2NjY3IDc0LjY2NjY2NyAwIDAgMSAyMTMuMzMzMzMzIDg2NHY2NGExMzguNjY2NjY3IDEzOC42NjY2NjcgMCAwIDAgMTM4LjY2NjY2Ny0xMzguNjY2NjY3aC02NHpNMjEzLjMzMzMzMyA4NjRhNzQuNjY2NjY3IDc0LjY2NjY2NyAwIDAgMS03NC42NjY2NjYtNzQuNjY2NjY3aC02NEExMzguNjY2NjY3IDEzOC42NjY2NjcgMCAwIDAgMjEzLjMzMzMzMyA5Mjh2LTY0ek0yNDUuMzMzMzMzIDY4Mi42NjY2Njd2LTIzNC42NjY2NjdoLTY0VjY4Mi42NjY2NjdoNjR6IG0tNTQuNjEzMzMzLTIxMi4wNTMzMzRsODUuMzMzMzMzIDg1LjMzMzMzNCA0NS4yMjY2NjctNDUuMjI2NjY3LTg1LjMzMzMzMy04NS4zMzMzMzMtNDUuMjI2NjY3IDQ1LjIyNjY2NnogbTAtNDUuMjI2NjY2bC04NS4zMzMzMzMgODUuMzMzMzMzIDQ1LjIyNjY2NiA0NS4yMjY2NjcgODUuMzMzMzM0LTg1LjMzMzMzNC00NS4yMjY2NjctNDUuMjI2NjY2eiIgIGZpbGw9IiM0NDRFNjAiPjwvcGF0aD48L3N2Zz4="
};
function $l(m) {
  return QG[m];
}
const wG = (m) => {
  const { workIds: d, maranger: l } = m;
  return il.createElement(
    "div",
    { className: "button normal-button", onClick: (i) => {
      i.preventDefault(), i.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.DeleteNode, { workIds: d || [Il], viewId: l.viewId });
    }, onTouchEnd: (i) => {
      i.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.DeleteNode, { workIds: d || [Il], viewId: l.viewId });
    } },
    il.createElement("img", { alt: "icon", src: $l("delete") })
  );
}, PG = (m) => {
  const { workIds: d, viewId: l } = m;
  return il.createElement(
    "div",
    { className: "button normal-button", onClick: (i) => {
      i.preventDefault(), i.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.CopyNode, { workIds: d || [Il], viewId: l });
    }, onTouchEnd: (i) => {
      i.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.CopyNode, { workIds: d || [Il], viewId: l });
    } },
    il.createElement("img", { alt: "icon", src: $l("duplicate") })
  );
}, vt = (m) => {
  const { icon: d, onClickHandler: l, onTouchEndHandler: i } = m;
  return il.createElement(
    "div",
    { className: "button normal-button", onClick: l, onTouchEnd: i },
    il.createElement("img", { src: $l(d) })
  );
}, fG = (m) => {
  const { open: d, setOpen: l, style: i } = m, { floatBarData: t, maranger: s } = _l(Al), [b, Z] = Fl([]), o = Nl(() => {
    if (i && i.bottom) {
      const W = {};
      return W.top = "inherit", W.bottom = 50, W;
    }
  }, [i]), G = Nl(() => d ? il.createElement(
    "div",
    { className: "image-layer-menu", style: o },
    il.createElement(vt, { icon: "to-top", onClickHandler: (W) => {
      W.preventDefault(), W.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.ZIndexNode, { workIds: [Il], layer: Cd.Top, viewId: s == null ? void 0 : s.viewId });
    }, onTouchEndHandler: (W) => {
      W.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.ZIndexNode, { workIds: [Il], layer: Cd.Top, viewId: s == null ? void 0 : s.viewId });
    } }),
    il.createElement(vt, { icon: "to-bottom", onClickHandler: (W) => {
      W.preventDefault(), W.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.ZIndexNode, { workIds: [Il], layer: Cd.Bottom, viewId: s == null ? void 0 : s.viewId });
    }, onTouchEndHandler: (W) => {
      W.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.ZIndexNode, { workIds: [Il], layer: Cd.Bottom, viewId: s == null ? void 0 : s.viewId });
    } })
  ) : null, [d, o]), y = (W) => {
    W.preventDefault(), W.stopPropagation(), W.nativeEvent.stopImmediatePropagation();
    const h = !d;
    l(h), h && xl.emitMethod(Yl.MainEngine, ul.ZIndexActive, { workId: Il, isActive: h, viewId: s == null ? void 0 : s.viewId });
  }, X = (W) => {
    W.stopPropagation(), W.nativeEvent.stopImmediatePropagation();
    const h = !d;
    l(h), xl.emitMethod(Yl.MainEngine, ul.ZIndexActive, { workId: Il, isActive: h, viewId: s == null ? void 0 : s.viewId });
  };
  return Ql(() => {
    dd(t == null ? void 0 : t.selectIds, b) || t != null && t.selectIds && !dd(t == null ? void 0 : t.selectIds, b) && (Z(t == null ? void 0 : t.selectIds), l(!1));
  }, [d, t, b, l]), Ql(() => () => {
    d && xl.emitMethod(Yl.MainEngine, ul.ZIndexActive, { workId: Il, isActive: !1, viewId: s == null ? void 0 : s.viewId });
  }, [d]), il.createElement(
    "div",
    { className: `button normal-button ${d && "active"}`, onClick: y, onTouchEnd: X },
    G,
    il.createElement("img", { alt: "icon", src: $l(d ? "layer-pressed" : "layer") })
  );
}, jG = (m) => {
  const { activeColor: d, onClickHandler: l, onTouchEndHandler: i } = m;
  return il.createElement(
    "div",
    { className: `font-color-button ${d === "transparent" ? "active" : ""}`, onClick: l, onTouchEnd: i },
    il.createElement("div", { className: "circle none" })
  );
}, wi = (m) => {
  const { color: d, activeColor: l, onClickHandler: i, onTouchEndHandler: t } = m;
  return il.createElement(
    "div",
    { className: `font-color-button ${d === l ? "active" : ""}`, onClick: i, onTouchEnd: t },
    il.createElement("div", { className: "circle", style: { backgroundColor: id(d, 1) } })
  );
}, Pi = (m) => {
  const { opacity: d, activeColor: l, setCurOpacity: i } = m, [t, s] = Fl({ x: 108, y: 0 });
  if (Ql(() => {
    s({ x: d * 100 + 8, y: 0 });
  }, []), !l)
    return null;
  const b = wl((G, y) => {
    G.preventDefault(), G.stopPropagation(), y.x !== (t == null ? void 0 : t.x) && s({ x: y.x, y: 0 });
    const X = Math.min(Math.max(y.x - 8, 0), 100) / 100;
    d !== X && i(X, l, hl.Doing);
  }, 100, { leading: !1 }), Z = (G) => {
    G.preventDefault(), G.stopPropagation(), i(d, l, hl.Start);
  }, o = wl((G, y) => {
    G.preventDefault(), G.stopPropagation(), y.x !== (t == null ? void 0 : t.x) && s({ x: y.x, y: 0 });
    const X = Math.min(Math.max(y.x - 8, 0), 100) / 100;
    i(X, l, hl.Done);
  }, 100, { leading: !1 });
  return il.createElement(
    "div",
    { className: "font-color-opacity", style: { marginLeft: "10px" }, onClick: (G) => {
      const y = G.nativeEvent.offsetX, X = Math.min(Math.max(y - 12, 0), 100) / 100;
      s({ x: X * 100 + 8, y: 0 }), i(X, l, hl.Done);
    } },
    il.createElement("div", { className: "range-color", style: {
      background: `linear-gradient(to right, ${id(l, 0)}, ${id(l, 1)})`
    } }),
    il.createElement(
      "div",
      { className: "range-opacity" },
      il.createElement(
        Bd,
        { bounds: "parent", axis: "x", position: t, onDrag: b, onStart: Z, onStop: o },
        il.createElement("div", { className: "circle", style: {
          backgroundColor: id(l, d)
        }, onClick: (G) => {
          G == null || G.preventDefault(), G == null || G.stopPropagation();
        } })
      )
    )
  );
}, EG = (m) => {
  const { open: d, setOpen: l, floatBarRef: i } = m, { floatBarData: t, floatBarColors: s, maranger: b, position: Z, setFloatBarData: o } = _l(Al), [G, y] = Fl(), [X, W] = Fl(1);
  Ql(() => {
    if (t != null && t.strokeColor) {
      const [V, c] = Qi(t.strokeColor);
      y(V), W(c);
    }
  }, [t]);
  const h = Nl(() => {
    if (i != null && i.current && Z && (b != null && b.height)) {
      if (i.current.offsetTop && i.current.offsetTop + Z.y > 180) {
        const V = {};
        return V.top = "inherit", V.bottom = 50, V;
      } else if (!i.current.offsetTop && (b == null ? void 0 : b.height) - i.current.offsetTop - Z.y < 120) {
        const V = {};
        return V.top = "inherit", V.bottom = 50, V;
      }
    }
  }, [i, Z, b]), r = Nl(() => il.createElement(Pi, { key: "strokeColors", opacity: X, activeColor: G, setCurOpacity: (V, c, n) => {
    n === hl.Start && (b != null && b.control.room) && (b.control.room.disableDeviceInputs = !0), n === hl.Done && (b != null && b.control.room) && (b.control.room.disableDeviceInputs = !1), W(V);
    const e = id(c, V);
    t != null && t.strokeColor && (t.strokeColor = e, o({ strokeColor: e })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: [Il], strokeColor: e, workState: n, viewId: b == null ? void 0 : b.viewId });
  } }), [X, G, b == null ? void 0 : b.control.room, b == null ? void 0 : b.viewId, t]), L = Nl(() => d ? il.createElement(
    "div",
    { className: "font-colors-menu", style: h, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    } },
    s.concat().map((V, c) => {
      const n = ui(...V);
      return il.createElement(wi, { key: c, color: n, activeColor: G, onTouchEndHandler: (e) => {
        e.stopPropagation(), y(n);
        const a = id(n, X);
        t != null && t.strokeColor && (t.strokeColor = a, o({ strokeColor: a })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: [Il], strokeColor: a, viewId: b == null ? void 0 : b.viewId });
      }, onClickHandler: (e) => {
        e.preventDefault(), e.stopPropagation(), y(n);
        const a = id(n, X);
        t != null && t.strokeColor && (t.strokeColor = a, o({ strokeColor: a })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: [Il], strokeColor: a, viewId: b == null ? void 0 : b.viewId });
      } });
    }),
    r
  ) : null, [d, s, r, G, X, t, b == null ? void 0 : b.viewId, h]), u = Nl(() => G ? il.createElement(
    "div",
    { className: "color-bar-ring", style: { backgroundColor: id(G, X) } },
    il.createElement("div", { className: "circle" })
  ) : null, [G, X]);
  return il.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${d && "active"}`, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    } },
    u,
    L
  );
}, BG = (m) => {
  const { open: d, setOpen: l, floatBarRef: i } = m, { floatBarData: t, floatBarColors: s, maranger: b, position: Z, setFloatBarData: o } = _l(Al), [G, y] = Fl(), [X, W] = Fl(1);
  Ql(() => {
    if (t != null && t.fillColor) {
      const [V, c] = (t == null ? void 0 : t.fillColor) === "transparent" && ["transparent", 1] || Qi(t.fillColor);
      y(V), W(c);
    }
  }, [t]);
  const h = Nl(() => {
    if (i != null && i.current && Z && (b != null && b.height)) {
      if (i.current.offsetTop && i.current.offsetTop + Z.y > 200) {
        const V = {};
        return V.top = "inherit", V.bottom = 50, V;
      } else if (!i.current.offsetTop && (b == null ? void 0 : b.height) - i.current.offsetTop - Z.y < 140) {
        const V = {};
        return V.top = "inherit", V.bottom = 50, V;
      }
    }
  }, [i, Z, b]), r = Nl(() => G && G !== "transparent" ? il.createElement(Pi, { key: "fillColors", opacity: X || 0, activeColor: G, setCurOpacity: (V, c, n) => {
    n === hl.Start && (b != null && b.control.room) && (b.control.room.disableDeviceInputs = !0), n === hl.Done && (b != null && b.control.room) && (b.control.room.disableDeviceInputs = !1), W(V);
    const e = id(c, V);
    t != null && t.fillColor && (t.fillColor = e, o({ fillColor: e })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: [Il], fillColor: G && id(c, V), workState: n, viewId: b == null ? void 0 : b.viewId });
  } }) : null, [G, X, b == null ? void 0 : b.control.room, b == null ? void 0 : b.viewId, t]), L = Nl(() => d ? il.createElement(
    "div",
    { className: "font-colors-menu", style: h, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    } },
    il.createElement(jG, { activeColor: G, onTouchEndHandler: (V) => {
      V.stopPropagation(), y("transparent");
      const c = "transparent";
      t != null && t.fillColor && (t.fillColor = c, o({ fillColor: c })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: [Il], fillColor: c, viewId: b == null ? void 0 : b.viewId });
    }, onClickHandler: (V) => {
      V.preventDefault(), V.stopPropagation(), y("transparent");
      const c = "transparent";
      t != null && t.fillColor && (t.fillColor = c, o({ fillColor: c })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: [Il], fillColor: c, viewId: b == null ? void 0 : b.viewId });
    } }),
    s.map((V, c) => {
      const n = ui(...V);
      return il.createElement(wi, { key: c, color: n, activeColor: G, onTouchEndHandler: (e) => {
        e.stopPropagation(), y(n);
        const a = id(n, X);
        t != null && t.fillColor && (t.fillColor = a, o({ fillColor: a })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: [Il], fillColor: a, viewId: b == null ? void 0 : b.viewId });
      }, onClickHandler: (e) => {
        e.preventDefault(), e.stopPropagation(), y(n);
        const a = id(n, X);
        t != null && t.fillColor && (t.fillColor = a, o({ fillColor: a })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: [Il], fillColor: a, viewId: b == null ? void 0 : b.viewId });
      } });
    }),
    r
  ) : null, [d, G, s, r, t, b == null ? void 0 : b.viewId, X, h]), u = Nl(() => {
    const V = G && G !== "transparent" && id(G, X) || "transparent";
    return il.createElement(
      "div",
      { className: "color-bar-fill" },
      il.createElement("div", { className: "circle", style: { backgroundColor: V } })
    );
  }, [G, X]);
  return il.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${d && "active"}`, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    } },
    u,
    L
  );
}, OG = (m) => {
  const { open: d, setOpen: l, textOpt: i, workIds: t, floatBarRef: s } = m, { floatBarColors: b, maranger: Z, position: o, setFloatBarData: G, floatBarData: y } = _l(Al), [X, W] = Fl(), [h, r] = Fl(1);
  Ql(() => {
    if (i != null && i.fontColor) {
      const [n, e] = (i == null ? void 0 : i.fontColor) === "transparent" && ["transparent", 0] || Qi(i.fontColor);
      W(n), r(e);
    }
  }, [i == null ? void 0 : i.fontColor]);
  const L = Nl(() => {
    if (s != null && s.current && o && (Z != null && Z.height)) {
      if (s.current.offsetTop && s.current.offsetTop + o.y > 180) {
        const n = {};
        return n.top = "inherit", n.bottom = 50, n;
      } else if (!s.current.offsetTop && (Z == null ? void 0 : Z.height) - s.current.offsetTop - o.y < 120) {
        const n = {};
        return n.top = "inherit", n.bottom = 50, n;
      }
    }
  }, [s, o, Z]), u = Nl(() => X && X !== "transparent" ? il.createElement(Pi, { key: "fontColors", opacity: h, activeColor: X, setCurOpacity: (n, e, a) => {
    a === hl.Start && (Z != null && Z.control.room) && (Z.control.room.disableDeviceInputs = !0), a === hl.Done && (Z != null && Z.control.room) && (Z.control.room.disableDeviceInputs = !1), r(n);
    const Y = id(e, n);
    y != null && y.textOpt && (y.textOpt.fontColor = Y, G({ textOpt: y.textOpt })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, {
      workIds: t || [Il],
      fontColor: X && Y,
      workState: a,
      viewId: Z == null ? void 0 : Z.viewId
    });
  } }) : null, [X, h, Z == null ? void 0 : Z.control.room, Z == null ? void 0 : Z.viewId, y == null ? void 0 : y.textOpt, t]), V = Nl(() => d ? il.createElement(
    "div",
    { className: "font-colors-menu", style: L, onTouchEnd: (n) => {
      n.stopPropagation(), n.nativeEvent.stopImmediatePropagation();
    }, onClick: (n) => {
      n.preventDefault(), n.stopPropagation(), n.nativeEvent.stopImmediatePropagation();
    } },
    b.map((n, e) => {
      const a = ui(...n);
      return il.createElement(wi, { key: e, color: a, activeColor: X, onTouchEndHandler: (Y) => {
        Y.stopPropagation(), W(a);
        const R = id(a, h);
        y != null && y.textOpt && (y.textOpt.fontColor = R, G({ textOpt: y.textOpt })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: t || [Il], fontColor: R, viewId: Z == null ? void 0 : Z.viewId });
      }, onClickHandler: (Y) => {
        Y.preventDefault(), Y.stopPropagation(), W(a);
        const R = id(a, h);
        y != null && y.textOpt && (y.textOpt.fontColor = R, G({ textOpt: y.textOpt })), xl.emitMethod(Yl.MainEngine, ul.SetColorNode, { workIds: t || [Il], fontColor: R, viewId: Z == null ? void 0 : Z.viewId });
      } });
    }),
    u
  ) : null, [d, b, u, X, h, y == null ? void 0 : y.textOpt, t, Z == null ? void 0 : Z.viewId, L]), c = Nl(() => {
    const n = X && X !== "transparent" && id(X, h) || "transparent";
    return il.createElement(
      "div",
      { className: "color-bar" },
      il.createElement("div", { className: "color-bar-color", style: { backgroundColor: n } })
    );
  }, [X, h]);
  return il.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${d && "active"}`, onTouchEnd: (n) => {
      n.stopPropagation(), n.nativeEvent.stopImmediatePropagation(), l(!d);
    }, onClick: (n) => {
      n.preventDefault(), n.stopPropagation(), n.nativeEvent.stopImmediatePropagation(), l(!d);
    } },
    il.createElement("img", { alt: "icon", src: $l("font-colors") }),
    c,
    V
  );
}, DG = (m) => {
  const { bold: d, setBold: l, workIds: i, viewId: t } = m, s = (b) => {
    const Z = d === "bold" ? "normal" : "bold";
    b == null || b.preventDefault(), b == null || b.stopPropagation(), l(Z), xl.emitMethod(Yl.MainEngine, ul.SetFontStyle, { workIds: i, viewId: t, bold: Z });
  };
  return il.createElement(
    "div",
    { className: "font-style-button", onClick: s, onTouchEnd: s },
    il.createElement("img", { alt: "icon", src: $l(d === "bold" ? "bold-active" : "bold") })
  );
}, AG = (m) => {
  const { underline: d, setUnderline: l, workIds: i, viewId: t } = m, s = (b) => {
    const Z = !d;
    b == null || b.preventDefault(), b == null || b.stopPropagation(), l(Z), xl.emitMethod(Yl.MainEngine, ul.SetFontStyle, { workIds: i, viewId: t, underline: Z });
  };
  return il.createElement(
    "div",
    { className: "font-style-button", onClick: s, onTouchEnd: s },
    il.createElement("img", { alt: "icon", src: $l(d ? "underline-active" : "underline") })
  );
}, qG = (m) => {
  const { lineThrough: d, setLineThrough: l, workIds: i, viewId: t } = m, s = (b) => {
    const Z = !d;
    b == null || b.preventDefault(), b == null || b.stopPropagation(), l(Z), xl.emitMethod(Yl.MainEngine, ul.SetFontStyle, { workIds: i, viewId: t, lineThrough: Z });
  };
  return il.createElement(
    "div",
    { className: "font-style-button", onClick: s, onTouchEnd: s },
    il.createElement("img", { alt: "icon", src: $l(d ? "line-through-active" : "line-through") })
  );
}, $G = (m) => {
  const { italic: d, setItalic: l, workIds: i, viewId: t } = m, s = (b) => {
    const Z = d === "italic" ? "normal" : "italic";
    b == null || b.preventDefault(), b == null || b.stopPropagation(), l(Z), xl.emitMethod(Yl.MainEngine, ul.SetFontStyle, { workIds: i, viewId: t, italic: Z });
  };
  return il.createElement(
    "div",
    { className: "font-style-button", onClick: s, onTouchEnd: s },
    il.createElement("img", { alt: "icon", src: $l(d === "italic" ? "italic-active" : "italic") })
  );
}, _G = (m) => {
  const { open: d, setOpen: l, textOpt: i, workIds: t, style: s } = m, { maranger: b } = _l(Al), [Z, o] = Fl("normal"), [G, y] = Fl("normal"), [X, W] = Fl(!1), [h, r] = Fl(!1);
  Ql(() => {
    i != null && i.bold && o(i.bold), md(i == null ? void 0 : i.underline) && W(i.underline || !1), md(i == null ? void 0 : i.lineThrough) && r(i.lineThrough || !1), i != null && i.italic && y(i.italic);
  }, [i]);
  const L = Nl(() => {
    if (s && s.bottom) {
      const V = {};
      return V.top = "inherit", V.bottom = 50, V;
    }
  }, [s]), u = Nl(() => d ? il.createElement(
    "div",
    { className: "font-style-menu", style: L, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation();
    } },
    il.createElement(DG, { workIds: t || [Il], bold: Z, setBold: o, viewId: b == null ? void 0 : b.viewId }),
    il.createElement(AG, { workIds: t || [Il], underline: X, setUnderline: W, viewId: b == null ? void 0 : b.viewId }),
    il.createElement(qG, { workIds: t || [Il], lineThrough: h, setLineThrough: r, viewId: b == null ? void 0 : b.viewId }),
    il.createElement($G, { workIds: t || [Il], italic: G, setItalic: y, viewId: b == null ? void 0 : b.viewId })
  ) : null, [d, t, Z, b == null ? void 0 : b.viewId, X, h, G, L]);
  return il.createElement(
    "div",
    { className: `button normal-button ${d && "active"}`, onTouchEnd: (V) => {
      V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    }, onClick: (V) => {
      V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
    } },
    il.createElement("img", { alt: "icon", src: $l(d ? "font-style-active" : "font-style") }),
    u
  );
}, bd = Object.freeze([
  12,
  14,
  18,
  24,
  36,
  48,
  64,
  80,
  144,
  288
]), Md = [
  "top",
  "topLeft",
  "topRight",
  "bottom",
  "bottomLeft",
  "bottomRight",
  "left",
  "leftTop",
  "leftBottom",
  "right",
  "rightTop",
  "rightBottom"
], lW = (m) => {
  const { style: d, onClickHandler: l } = m;
  return il.createElement("div", { className: "font-size-menu", style: d, onTouchEnd: (i) => {
    i.stopPropagation(), i.nativeEvent.stopImmediatePropagation();
  }, onClick: (i) => {
    i.preventDefault(), i.stopPropagation(), i.nativeEvent.stopImmediatePropagation();
  } }, bd.map((i) => il.createElement("div", { className: "font-size-btn", key: i, onClick: () => {
    l(i);
  }, onTouchEnd: () => {
    l(i);
  } }, i)));
}, dW = (m) => {
  const d = Nd(null), { open: l, setOpen: i, textOpt: t, workIds: s, floatBarRef: b } = m, { maranger: Z, position: o } = _l(Al), [G, y] = Fl(0), [X, W] = Fl(), h = bd.length - 1;
  Ql(() => {
    t != null && t.fontSize && (y(t.fontSize), d.current && (d.current.value = t.fontSize.toString()));
  }, [t == null ? void 0 : t.fontSize]);
  const r = Nl(() => {
    if (b != null && b.current && o && (Z != null && Z.height)) {
      if (b.current.offsetTop && b.current.offsetTop + o.y > 250) {
        const n = {};
        return n.top = "inherit", n.bottom = 35, n;
      } else if (!b.current.offsetTop && (Z == null ? void 0 : Z.height) - b.current.offsetTop - o.y < 180) {
        const n = {};
        return n.top = "inherit", n.bottom = 35, n;
      }
    }
  }, [b, o, Z]);
  function L(n) {
    y(n), n && n >= bd[0] && n <= bd[h] && xl.emitMethod(Yl.MainEngine, ul.SetFontStyle, {
      workIds: s || [Il],
      fontSize: n,
      viewId: Z == null ? void 0 : Z.viewId
    });
  }
  const u = (n) => {
    var e;
    y(n), i(!1), (e = d.current) == null || e.blur(), n && n >= bd[0] && n <= bd[h] && xl.emitMethod(Yl.MainEngine, ul.SetFontStyle, {
      workIds: s || [Il],
      fontSize: n,
      viewId: Z == null ? void 0 : Z.viewId
    });
  }, V = Nl(() => l ? il.createElement(lW, { onClickHandler: u, style: r }) : null, [l, u, r]), c = (n) => {
    n > bd[h] && (n = bd[h]), n < bd[0] && (n = bd[0]), L(n);
  };
  return Ql(() => () => {
    Z != null && Z.control.room && md(X) && (Z.control.room.disableDeviceInputs = X);
  }, [Z, X]), il.createElement(
    "div",
    { className: "button normal-button font-size-barBtn", style: { width: 50 }, onTouchEnd: (n) => {
      n.stopPropagation(), n.nativeEvent.stopImmediatePropagation();
    }, onClick: (n) => {
      n.preventDefault(), n.stopPropagation(), n.nativeEvent.stopImmediatePropagation();
    } },
    il.createElement("input", { className: "font-size-input", ref: d, onTouchEnd: () => {
      d.current && d.current.focus();
    }, onClick: () => {
      i(!l), d.current && d.current.focus();
    }, onKeyDown: (n) => {
      if (n.key === "Backspace") {
        const e = window.getSelection(), a = e == null ? void 0 : e.getRangeAt(0);
        if (a != null && a.collapsed)
          return n.preventDefault(), document.execCommand("delete", !1), !1;
      }
    }, onKeyUp: () => {
      if (d.current) {
        const n = d.current.value, e = parseInt(n);
        isNaN(e) ? d.current.value = "0" : d.current.value = e.toString();
      }
    }, onChange: (n) => {
      const e = n.target.value, a = parseInt(e);
      a && L(a);
    }, onFocus: () => {
      Z != null && Z.control.room && !Z.control.room.disableDeviceInputs && (W(Z.control.room.disableDeviceInputs), Z.control.room.disableDeviceInputs = !0);
    }, onBlur: () => {
      Z != null && Z.control.room && md(X) && (Z.control.room.disableDeviceInputs = X);
    } }),
    il.createElement(
      "div",
      { className: "font-size-btns" },
      il.createElement("div", { className: "font-size-add", onClick: () => {
        c(G + bd[0]);
      }, onTouchEnd: () => {
        c(G + bd[0]);
      } }),
      il.createElement("div", { className: "font-size-cut", onClick: () => {
        c(G - bd[0]);
      }, onTouchEnd: () => {
        c(G - bd[0]);
      } })
    ),
    V
  );
}, iW = (m) => {
  const { workIds: d, maranger: l, islocked: i } = m;
  return il.createElement(
    "div",
    { className: "button normal-button", onClick: (t) => {
      t.preventDefault(), t.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.SetLock, { workIds: d || [Il], isLocked: !i, viewId: l == null ? void 0 : l.viewId });
    }, onTouchEnd: (t) => {
      t.stopPropagation(), xl.emitMethod(Yl.MainEngine, ul.SetLock, { workIds: d || [Il], isLocked: !i, viewId: l == null ? void 0 : l.viewId });
    } },
    il.createElement("img", { alt: "icon", src: $l(i ? "unlock-new" : "lock-new") })
  );
}, Ki = (m) => {
  const { icon: d, min: l, max: i, step: t, value: s, onInputHandler: b } = m, [Z, o] = Fl(0), G = Nd(null), y = (X) => {
    X > i && (X = i), X < l && (X = l), o(X), b(X), G.current && (G.current.value = X.toString());
  };
  return Ql(() => {
    s && (o(s), G.current && (G.current.value = s.toString()));
  }, [s]), il.createElement(
    "div",
    { className: "button input-button", onTouchEnd: (X) => {
      X.stopPropagation(), X.nativeEvent.stopImmediatePropagation();
    }, onClick: (X) => {
      X.preventDefault(), X.stopPropagation(), X.nativeEvent.stopImmediatePropagation();
    } },
    il.createElement("img", { src: $l(d) }),
    il.createElement("input", { className: "input-number", type: "text", ref: G, onTouchEnd: () => {
      G.current && G.current.focus();
    }, onClick: () => {
      G.current && G.current.focus();
    }, onKeyDown: (X) => {
      if (X.key === "Backspace") {
        const W = window.getSelection(), h = W == null ? void 0 : W.getRangeAt(0);
        if (h != null && h.collapsed)
          return X.preventDefault(), document.execCommand("delete", !1), !1;
      }
    }, onKeyUp: () => {
      if (G.current) {
        const X = G.current.value, W = parseInt(X);
        isNaN(W) ? G.current.value = "0" : G.current.value = W.toString();
      }
    }, onChange: (X) => {
      const W = X.target.value, h = parseInt(W);
      h && h && h >= l && h <= i && y(h);
    } }),
    il.createElement(
      "div",
      { className: "input-number-btns" },
      il.createElement("div", { className: "input-number-add", onClick: () => {
        y(Z + t);
      }, onTouchEnd: () => {
        y(Z + t);
      } }),
      il.createElement("div", { className: "input-number-cut", onClick: () => {
        y(Z - t);
      }, onTouchEnd: () => {
        y(Z - t);
      } })
    )
  );
}, tW = (m) => {
  const { icon: d, min: l, max: i, step: t, value: s, onInputHandler: b } = m;
  return il.createElement(
    "div",
    { className: "button input-button" },
    il.createElement("img", { src: $l(d) }),
    il.createElement(sW, { min: l, max: i, step: t, value: s, onInputHandler: b })
  );
}, sW = (m) => {
  const { value: d, min: l, max: i, onInputHandler: t } = m, [s, b] = Fl({ x: 0, y: 0 });
  Ql(() => {
    b({ x: d * 100, y: 0 });
  }, []);
  const Z = wl((y, X) => {
    y.preventDefault(), y.stopPropagation();
    let W = Math.floor(Math.max(X.x, l * 100));
    W = Math.floor(Math.min(W, i * 100)), X.x !== (s == null ? void 0 : s.x) && b({ x: W, y: 0 });
    const h = W / 100;
    console.log("first1--doing", X, X.x, W, h), d !== h && t(h);
  }, 100, { leading: !1 }), o = (y) => {
    y.preventDefault(), y.stopPropagation();
  }, G = wl((y, X) => {
    y.preventDefault(), y.stopPropagation();
    let W = Math.floor(Math.max(X.x, l * 100));
    W = Math.floor(Math.min(W, i * 100)), X.x !== (s == null ? void 0 : s.x) && b({ x: W, y: 0 });
    const h = W / 100;
    console.log("first1--end", X, X.x, W, h), d !== h && t(h);
  }, 100, { leading: !1 });
  return console.log("position", s), il.createElement(
    "div",
    { className: "range-number-container", onClick: (y) => {
      const X = y.nativeEvent.offsetX - 6;
      let W = Math.floor(Math.max(X, l * 100));
      W = Math.floor(Math.min(W, i * 100)), b({ x: W, y: 0 });
      const h = W / 100;
      console.log("first1", y.nativeEvent.offsetX, W, h), d !== h && t(h);
    } },
    il.createElement("div", { className: "range-number-color" }),
    il.createElement(
      "div",
      { className: "range-number" },
      il.createElement(
        Bd,
        { bounds: "parent", axis: "x", position: s, onDrag: Z, onStart: o, onStop: G },
        il.createElement("div", { className: "circle", onClick: o })
      )
    )
  );
}, cW = (m) => {
  const { icon: d, value: l, onChangeHandler: i, style: t } = m, [s, b] = Fl(0), [Z, o] = Fl(), G = Nd(null), y = Rs((h) => {
    h >= Md.length && (h = 0), h < 0 && (h = Md.length - 1), b(h), i(Md[h]), o(!1), G.current && (G.current.value = Md[h]);
  }, [i]), X = Nl(() => {
    if (t && t.bottom) {
      const h = {};
      return h.top = "inherit", h.bottom = 50, h;
    }
  }, [t]);
  Ql(() => {
    l && (b(Md.indexOf(l)), G.current && (G.current.value = l));
  }, [l]);
  const W = Nl(() => Z ? il.createElement(bW, { options: Md, onClickHandler: y, style: X }) : null, [Z, y, X]);
  return il.createElement(
    "div",
    { className: "button input-button" },
    il.createElement("img", { src: $l(d) }),
    il.createElement("input", { readOnly: !0, className: "input-number", type: "text", ref: G, onTouchEnd: () => {
      G.current && G.current.focus();
    }, onClick: () => {
      G.current && (G.current.focus(), o(!Z));
    } }),
    il.createElement(
      "div",
      { className: "input-number-btns" },
      il.createElement("div", { className: "input-number-add", onClick: () => {
        y(s + 1);
      }, onTouchEnd: () => {
        y(s + 1);
      } }),
      il.createElement("div", { className: "input-number-cut", onClick: () => {
        y(s - 1);
      }, onTouchEnd: () => {
        y(s - 1);
      } })
    ),
    W
  );
}, bW = (m) => {
  const { options: d, style: l, onClickHandler: i } = m;
  return il.createElement("div", { className: "select-option-menu", style: l, onTouchEnd: (t) => {
    t.stopPropagation(), t.nativeEvent.stopImmediatePropagation();
  }, onClick: (t) => {
    t.preventDefault(), t.stopPropagation(), t.nativeEvent.stopImmediatePropagation();
  } }, d.map((t, s) => il.createElement("div", { className: "select-option-btn", key: t, onClick: () => {
    i(s);
  }, onTouchEnd: () => {
    i(s);
  } }, t)));
}, ZW = (m) => {
  const { maranger: d, innerRatio: l, innerVerticeStep: i, vertices: t } = m, s = (o) => {
    console.log("onInputHandler", o), xl.emitMethod(Yl.MainEngine, ul.SetShapeOpt, {
      workIds: [Il],
      toolsType: bl.Star,
      viewId: d.viewId,
      vertices: o
    });
  }, b = (o) => {
    console.log("onInputHandler", o), xl.emitMethod(Yl.MainEngine, ul.SetShapeOpt, {
      workIds: [Il],
      toolsType: bl.Star,
      viewId: d.viewId,
      innerVerticeStep: o
    });
  }, Z = (o) => {
    console.log("onInputHandler", o), xl.emitMethod(Yl.MainEngine, ul.SetShapeOpt, {
      workIds: [Il],
      toolsType: bl.Star,
      viewId: d.viewId,
      innerRatio: o
    });
  };
  return il.createElement(
    il.Fragment,
    null,
    il.createElement(Ki, { value: t, icon: "polygon-vertex", min: 3, max: 100, step: 1, onInputHandler: s }),
    il.createElement(Ki, { value: i, icon: "star-innerVertex", min: 1, max: 100, step: 1, onInputHandler: b }),
    il.createElement(tW, { value: l, icon: "star-innerRatio", min: 0.1, max: 1, step: 0.1, onInputHandler: Z })
  );
}, mW = (m) => {
  const { maranger: d, vertices: l } = m, i = (t) => {
    xl.emitMethod(Yl.MainEngine, ul.SetShapeOpt, {
      workIds: [Il],
      toolsType: bl.Polygon,
      viewId: d.viewId,
      vertices: t
    });
  };
  return il.createElement(Ki, { value: l, icon: "polygon-vertex", min: 3, max: 100, step: 1, onInputHandler: i });
}, nW = (m) => {
  const { maranger: d, placement: l } = m, i = (t) => {
    console.log("onChangeHandler-SpeechBalloonFormView", t), xl.emitMethod(Yl.MainEngine, ul.SetShapeOpt, {
      workIds: [Il],
      toolsType: bl.SpeechBalloon,
      viewId: d.viewId,
      placement: t
    });
  };
  return il.createElement(cW, { value: l, icon: "speechBallon-placement", onChangeHandler: i });
}, Li = (m) => {
  const { icon: d, isActive: l, onClickHandler: i, onTouchEndHandler: t } = m;
  return il.createElement(
    "div",
    { className: `button tab-button ${l ? "active" : ""}`, onClick: i, onTouchEnd: t },
    il.createElement("img", { src: $l(d) })
  );
}, eW = (m) => {
  const { toolsTypes: d, style: l, maranger: i, shapeOpt: t } = m, [s, b] = Fl();
  Ql(() => {
    d.includes(bl.Polygon) ? b(bl.Polygon) : d.includes(bl.Star) ? b(bl.Star) : b(bl.SpeechBalloon);
  }, [d]);
  const Z = (X, W) => {
    W == null || W.preventDefault(), W == null || W.stopPropagation(), b(X);
  }, o = Nl(() => s === bl.Polygon && i && t.vertices ? il.createElement(mW, { vertices: t.vertices, maranger: i }) : null, [i, s, t]), G = Nl(() => s === bl.Star && i && t.vertices && t.innerVerticeStep && t.innerRatio ? il.createElement(ZW, { maranger: i, vertices: t.vertices, innerVerticeStep: t.innerVerticeStep, innerRatio: t.innerRatio }) : null, [i, s, t]), y = Nl(() => s === bl.SpeechBalloon && i && t.placement ? il.createElement(nW, { maranger: i, placement: t.placement }) : null, [i, s, t]);
  return il.createElement(
    "div",
    { className: "shapeOpt-sub-menu", style: l, onClick: (X) => {
      X.stopPropagation(), X.nativeEvent.stopImmediatePropagation(), X == null || X.preventDefault();
    } },
    il.createElement(
      "div",
      { className: "shapeOpt-sub-menu-tabs" },
      d.includes(bl.Polygon) && il.createElement(Li, { isActive: s === bl.Polygon, icon: s === bl.Polygon ? "polygon-active" : "polygon", onClickHandler: Z.bind(void 0, bl.Polygon), onTouchEndHandler: Z.bind(void 0, bl.Polygon) }) || null,
      d.includes(bl.Star) && il.createElement(Li, { isActive: s === bl.Star, icon: s === bl.Star ? "star-active" : "star", onClickHandler: Z.bind(void 0, bl.Star), onTouchEndHandler: Z.bind(void 0, bl.Star) }) || null,
      d.includes(bl.SpeechBalloon) && il.createElement(Li, { isActive: s === bl.SpeechBalloon, icon: s === bl.SpeechBalloon ? "speechBallon-active" : "speechBallon", onClickHandler: Z.bind(void 0, bl.SpeechBalloon), onTouchEndHandler: Z.bind(void 0, bl.SpeechBalloon) }) || null
    ),
    il.createElement(
      "div",
      { className: "shapeOpt-sub-menu-content" },
      o,
      G,
      y
    )
  );
}, oW = (m) => {
  const { open: d, setOpen: l, floatBarRef: i, toolsTypes: t, shapeOpt: s } = m, { floatBarData: b, maranger: Z, position: o } = _l(Al), [G, y] = Fl([]), [X, W] = Fl(), h = Nl(() => {
    if (i != null && i.current && o && (Z != null && Z.height)) {
      if (i.current.offsetTop && i.current.offsetTop + o.y > 200) {
        const V = {};
        return V.top = "inherit", V.bottom = 50, V;
      } else if (!i.current.offsetTop && (Z == null ? void 0 : Z.height) - i.current.offsetTop - o.y < 140) {
        const V = {};
        return V.top = "inherit", V.bottom = 50, V;
      }
    }
  }, [i, o, Z]), r = Nl(() => d && t && Z && s ? (Z.control.room && !Z.control.room.disableDeviceInputs && (W(Z.control.room.disableDeviceInputs), Z.control.room.disableDeviceInputs = !0), il.createElement(eW, { shapeOpt: s, style: h, toolsTypes: t, maranger: Z })) : (Z != null && Z.control.room && md(X) && (Z.control.room.disableDeviceInputs = X, console.log("showSubBtn---false---001", d)), null), [d, h, t, Z, s]), L = (V) => {
    V.preventDefault(), V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
  }, u = (V) => {
    V.stopPropagation(), V.nativeEvent.stopImmediatePropagation(), l(!d);
  };
  return Ql(() => {
    dd(b == null ? void 0 : b.selectIds, G) || b != null && b.selectIds && !dd(b == null ? void 0 : b.selectIds, G) && (y(b == null ? void 0 : b.selectIds), l(!1));
  }, [d, b, G, l]), Ql(() => () => {
    d && Z != null && Z.control.room && md(X) && (Z.control.room.disableDeviceInputs = X, console.log("showSubBtn---false---002", d));
  }, [d, Z, X]), il.createElement(
    "div",
    { className: `button normal-button ${d && "active"}`, onClick: L, onTouchEnd: u },
    r,
    il.createElement("img", { alt: "icon", src: $l(d ? "shapes-active" : "shapes") })
  );
};
var kl;
(function(m) {
  m[m.none = 0] = "none", m[m.Layer = 1] = "Layer", m[m.StrokeColor = 2] = "StrokeColor", m[m.FillColor = 3] = "FillColor", m[m.TextColor = 4] = "TextColor", m[m.TextBgColor = 5] = "TextBgColor", m[m.FontStyle = 6] = "FontStyle", m[m.FontSize = 7] = "FontSize", m[m.ShapeOpt = 8] = "ShapeOpt";
})(kl || (kl = {}));
const xs = il.memo((m) => {
  const { textOpt: d, workIds: l, noLayer: i, position: t } = m, { floatBarData: s, maranger: b } = _l(Al), [Z, o] = il.useState(kl.none), G = Nd(null), y = Nl(() => {
    var Y, R, C;
    const n = {}, e = (s == null ? void 0 : s.w) || ((Y = d == null ? void 0 : d.boxSize) == null ? void 0 : Y[0]) || 0, a = (s == null ? void 0 : s.h) || ((R = d == null ? void 0 : d.boxSize) == null ? void 0 : R[1]) || 0;
    if (t && e && a && (b != null && b.width) && (b != null && b.height)) {
      if (t.y < 60 && (t.y + e < b.height - 60 ? n.bottom = -120 : t.y + a < b.height ? n.bottom = -58 : t.y > 0 ? n.top = 62 : n.top = -t.y + 62), t.x < 0)
        n.left = -t.x + 3;
      else if (t.x + (((C = G.current) == null ? void 0 : C.offsetWidth) || e) > b.width) {
        const N = e + t.x - b.width;
        n.left = "initial", n.right = N;
      }
      return n;
    }
  }, [G, t, s == null ? void 0 : s.w, s == null ? void 0 : s.h, b == null ? void 0 : b.width, b == null ? void 0 : b.height, d == null ? void 0 : d.boxSize]), X = Nl(() => s != null && s.fillColor ? il.createElement(BG, { floatBarRef: G, open: Z === kl.FillColor, setOpen: (n) => {
    o(n === !0 ? kl.FillColor : kl.none);
  } }) : null, [s == null ? void 0 : s.fillColor, Z, G]), W = Nl(() => s != null && s.strokeColor ? il.createElement(EG, { floatBarRef: G, open: Z === kl.StrokeColor, setOpen: (n) => {
    o(n === !0 ? kl.StrokeColor : kl.none);
  } }) : null, [s == null ? void 0 : s.strokeColor, Z, G]), h = Nl(() => d != null && d.fontColor && (b != null && b.viewId) ? il.createElement(OG, { floatBarRef: G, open: Z === kl.TextColor, setOpen: (n) => {
    o(n === !0 ? kl.TextColor : kl.none);
  }, textOpt: d, workIds: l }) : null, [d, Z, l, b, G]), r = Nl(() => d && (b != null && b.viewId) ? il.createElement(_G, { open: Z === kl.FontStyle, setOpen: (n) => {
    o(n === !0 ? kl.FontStyle : kl.none);
  }, textOpt: d, workIds: l, style: y }) : null, [d, Z, l, b, y]), L = Nl(() => d && (b != null && b.viewId) ? il.createElement(dW, { open: Z === kl.FontSize, setOpen: (n) => {
    o(n === !0 ? kl.FontSize : kl.none);
  }, textOpt: d, workIds: l, floatBarRef: G }) : null, [d, Z, l, b, G]), u = Nl(() => i ? null : il.createElement(fG, { open: Z === kl.Layer, setOpen: (n) => {
    o(n === !0 ? kl.Layer : kl.none);
  }, floatBarRef: G }), [i, Z, G]), V = Nl(() => s != null && s.canLock && b ? il.createElement(iW, { workIds: l, maranger: b, islocked: s.isLocked }) : null, [s, b, l]), c = Nl(() => b && (b != null && b.viewId) && y && (s != null && s.shapeOpt) && (s != null && s.toolsTypes) ? il.createElement(oW, { open: Z === kl.ShapeOpt, setOpen: (n) => {
    o(n === !0 ? kl.ShapeOpt : kl.none);
  }, floatBarRef: G, workIds: l, toolsTypes: s.toolsTypes, shapeOpt: s.shapeOpt }) : null, [s, b, Z, y, l, G]);
  return il.createElement(
    "div",
    { className: "bezier-pencil-plugin-floatbtns", style: y, ref: G },
    b && il.createElement(wG, { workIds: l, maranger: b }),
    u,
    V,
    !!(b != null && b.viewId) && il.createElement(PG, { workIds: l, viewId: b.viewId }),
    c,
    L,
    r,
    h,
    W,
    X
  );
}), aW = (m) => {
  const { data: d, isActive: l, manager: i, workId: t } = m, { opt: s, scale: b, translate: Z, x: o, y: G } = d, y = `scale(${b || 1}) ${Z && "translate(" + Z[0] + "px," + Z[1] + "px)" || ""}`, { fontSize: X, fontFamily: W, underline: h, fontColor: r, lineThrough: L, textAlign: u, strokeColor: V, lineHeight: c, bold: n, italic: e, uid: a } = s, Y = X, R = c || Y * 1.2, C = {
    fontSize: `${Y}px`,
    lineHeight: `${R}px`,
    color: r,
    borderColor: V,
    minHeight: `${R}px`
  };
  W && (C.fontFamily = `${W}`), (L || h) && (C.textDecoration = `${L && "line-through" || ""}${h && " underline" || ""}`), n && (C.fontWeight = `${n}`), e && (C.fontStyle = `${e}`), u && (C.textAlign = `${u}`);
  let N = "";
  s != null && s.text && (N = s.text.split(",").reduce((T, K, S) => {
    const H = K === "" ? "<br/>" : K;
    return S === 0 ? H : `${T}<div>${H}</div>`;
  }, ""));
  function I() {
    var J, T;
    console.log("onServiceDerive---handleClick", l, a, (J = i.control.collector) == null ? void 0 : J.uid), l && (a && a === ((T = i.control.collector) == null ? void 0 : T.uid) || !a) && i.control.textEditorManager.active(t);
  }
  return il.createElement(
    "div",
    { className: "editor-box", style: {
      left: `${o}px`,
      top: `${G}px`,
      transform: y,
      transformOrigin: "left top",
      pointerEvents: "none"
    } },
    il.createElement("div", {
      className: `editor ${l ? "" : "readOnly"}`,
      // className={`editor ${(workState !== EvevtWorkState.Start && workState !== EvevtWorkState.Doing) ? 'readOnly' : ''}`}
      style: C,
      dangerouslySetInnerHTML: { __html: N },
      onClick: I
    })
  );
}, XW = il.memo((m) => {
  const { data: d, position: l, workId: i, selectIds: t, updateOptInfo: s } = m, [b, Z] = Fl([0, 0]), { opt: o, scale: G, translate: y, x: X, y: W } = d, h = Nd(null);
  Ql(() => {
    td(X) && td(W) && Z([X - ((l == null ? void 0 : l.x) || 0), W - ((l == null ? void 0 : l.y) || 0)]);
  }, [X, W, t, i]), Ql(() => {
    var K, S;
    if ((K = h.current) != null && K.offsetWidth && ((S = h.current) != null && S.offsetHeight)) {
      const H = o.boxSize;
      ((H == null ? void 0 : H[0]) !== h.current.offsetWidth || H[1] !== h.current.offsetHeight || !H) && (console.log("updateForViewEdited---1--0", i, H, [h.current.offsetWidth, h.current.offsetHeight]), s({
        activeTextId: i,
        update: {
          boxSize: [h.current.offsetWidth, h.current.offsetHeight],
          workState: hl.Done
        },
        syncData: {
          canSync: !0,
          canWorker: !0
        }
      }));
    }
  }, [o.fontSize]);
  const r = `scale(${G || 1}) ${y && "translate(" + y[0] + "px," + y[1] + "px)" || ""}`, { fontSize: L, fontFamily: u, underline: V, fontColor: c, lineThrough: n, textAlign: e, strokeColor: a, lineHeight: Y, bold: R, italic: C } = o, N = L, I = Y || N * 1.2, J = {
    fontSize: `${N}px`,
    lineHeight: `${I}px`,
    color: c,
    borderColor: a,
    minHeight: `${I}px`,
    pointerEvents: "none"
  };
  u && (J.fontFamily = `${u}`), (n || V) && (J.textDecoration = `${n && "line-through" || ""}${V && " underline" || ""}`), e && (J.textAlign = `${e}`), R && (J.fontWeight = `${R}`), C && (J.fontStyle = `${C}`);
  let T = "";
  return o != null && o.text && (T = o.text.split(",").reduce((S, H, w) => {
    const P = H === "" ? "<br/>" : H;
    return w === 0 ? P : `${S}<div>${P}</div>`;
  }, "")), il.createElement(
    "div",
    { className: "editor-box", style: {
      left: `${b[0]}px`,
      top: `${b[1]}px`,
      transform: r,
      transformOrigin: "left top",
      zIndex: 1,
      pointerEvents: "none"
    } },
    il.createElement("div", { className: "editor readOnly", ref: h, style: J, dangerouslySetInnerHTML: { __html: T } })
  );
}), GW = (m) => {
  const { data: d, workId: l, isSelect: i, handleKeyUp: t, handleFocus: s, updateOptInfo: b, showFloatBtns: Z, manager: o } = m, [G, y] = Fl(), { opt: X, scale: W, translate: h, x: r, y: L } = d, [u, V] = Fl(""), c = Nd(null);
  Ql(() => {
    let z = "";
    X != null && X.text && (z = X.text.split(",").reduce((O, ll, _) => {
      const Zl = ll === "" ? "<br/>" : ll;
      return _ === 0 ? Zl : `${O}<div>${Zl}</div>`;
    }, "")), V(z), Promise.resolve().then(() => {
      c.current && c.current.click();
    });
  }, []), Ql(() => {
    var z, U;
    (z = c.current) != null && z.offsetWidth && ((U = c.current) != null && U.offsetHeight) && b({
      activeTextId: l,
      update: {
        boxSize: [c.current.offsetWidth, c.current.offsetHeight],
        workState: hl.Doing
      }
    });
  });
  const n = `scale(${W || 1}) ${h && "translate(" + h[0] + "px," + h[1] + "px)" || ""}`, { fontSize: e, fontFamily: a, underline: Y, fontColor: R, lineThrough: C, textAlign: N, strokeColor: I, lineHeight: J, bold: T, italic: K } = X, S = e, H = J || S * 1.2, w = {
    transform: n,
    transformOrigin: "left top",
    fontSize: `${S}px`,
    lineHeight: `${H}px`,
    color: R,
    borderColor: I,
    minHeight: `${H}px`
  };
  a && (w.fontFamily = `${a}`), (C || Y) && (w.textDecoration = `${C && "line-through" || ""} ${Y && " underline" || ""}`), N && (w.textAlign = `${N}`), T && (w.fontWeight = `${T}`), K && (w.fontStyle = `${K}`);
  function P() {
    var z;
    if (c.current) {
      c.current.focus();
      const U = window == null ? void 0 : window.getSelection(), O = c.current.lastChild;
      if (U && O) {
        const ll = document.createRange(), _ = ((z = O.textContent) == null ? void 0 : z.length) || 0;
        (O == null ? void 0 : O.nodeName) === "#text" ? ll.setStart(O, _) : ll.setStart(O, _ && 1 || 0), ll.collapse(!0), U.removeAllRanges(), U.addRange(ll);
      }
    }
  }
  function B(z) {
    if (z.key === "Backspace") {
      const U = window.getSelection(), O = U == null ? void 0 : U.getRangeAt(0);
      if (O != null && O.collapsed)
        return z.preventDefault(), document.execCommand("delete", !1), !1;
    }
    return !1;
  }
  function D(z) {
    var U, O;
    if (z.preventDefault(), c.current) {
      let ll = (z.clipboardData || window.clipboardData).getData("text");
      ll = ll.toUpperCase();
      const _ = window == null ? void 0 : window.getSelection();
      if (!(_ != null && _.rangeCount))
        return;
      const Zl = ll.split(/\n/);
      if (_ && Zl.length) {
        _.deleteFromDocument();
        const $ = document.createRange();
        let ol = c.current.lastChild;
        if (!ol) {
          const al = document.createTextNode(Zl[0]);
          if (c.current.appendChild(al), Zl.length === 1) {
            const g = ((U = al.textContent) == null ? void 0 : U.length) || 0;
            $.setStart(al, g), $.collapse(!0), _.removeAllRanges(), _.addRange($);
            return;
          }
        }
        if ((ol == null ? void 0 : ol.nodeName) === "#text" && (ol.textContent = ol.textContent + Zl[0], Zl.length === 1)) {
          const al = ((O = ol.textContent) == null ? void 0 : O.length) || 0;
          $.setStart(ol, al), $.collapse(!0), _.removeAllRanges(), _.addRange($);
          return;
        }
        (ol == null ? void 0 : ol.nodeName) === "DIV" && (ol.innerText = ol.innerText + Zl[0]);
        for (let al = 1; al < Zl.length; al++) {
          const g = Zl[al];
          if (g) {
            const k = document.createElement("div");
            k.innerText = g, c.current.appendChild(k);
          }
        }
        ol = c.current.lastChild, ol && $.setStart(ol, 1), $.collapse(!0), _.removeAllRanges(), _.addRange($);
      }
    }
  }
  return il.createElement(
    "div",
    { className: "editor-box", style: {
      left: `${r}px`,
      top: `${L}px`,
      zIndex: 2,
      pointerEvents: "none"
    }, onFocus: () => {
      o.control.room && !o.control.room.disableDeviceInputs && (y(o.control.room.disableDeviceInputs), o.control.room.disableDeviceInputs = !0);
    }, onBlur: () => {
      o != null && o.control.room && md(G) && (o.control.room.disableDeviceInputs = G);
    }, onKeyDown: (z) => (z.stopPropagation(), !0), onMouseMove: (z) => (z.stopPropagation(), z.preventDefault(), !0) },
    !i && Z && il.createElement(xs, { textOpt: X, workIds: [l], noLayer: !0, position: { x: r, y: L } }),
    il.createElement("div", { id: l, contentEditable: !0, className: "editor", ref: c, style: w, dangerouslySetInnerHTML: { __html: u }, onKeyDown: B, onKeyUp: t, onClick: P, onTouchEnd: P, onFocus: s, onPaste: D })
  );
};
class rs extends il.Component {
  constructor(d) {
    super(d);
  }
  getInnerText(d) {
    const l = [];
    for (let i = 0; i < d.childNodes.length; i++) {
      const t = d.childNodes[i];
      if (t.nodeName === "#text" && i === 0) {
        const s = t.textContent.split(/\n/), b = s.pop();
        l.push(...s), b && l.push(b);
      } else if (t.nodeName === "DIV") {
        const s = t.innerText.split(/\n/);
        if (s.length === 2 && s[0] === "" && s[1] === "")
          l.push("");
        else {
          const b = s.shift();
          b && l.push(b);
          const Z = s.pop();
          l.push(...s), Z && l.push(Z);
        }
      }
    }
    return l;
  }
  updateOptInfo(d) {
    var b, Z;
    const { activeTextId: l, update: i, syncData: t } = d, s = l && El(((b = this.props.manager.control.textEditorManager) == null ? void 0 : b.get(l)) || ((Z = this.props.editors) == null ? void 0 : Z.get(l)));
    s && s.opt && (s.opt = {
      ...s.opt,
      ...i
    }, t && (s.canSync = t.canSync, s.canWorker = t.canWorker), this.props.manager.control.textEditorManager.updateForViewEdited(l, s));
  }
  get editorUI() {
    var d;
    if ((d = this.props.editors) != null && d.size) {
      const l = [];
      return this.props.editors.forEach((i, t) => {
        if (this.props.selectIds.includes(t) && !(this.props.activeTextId == t)) {
          const b = il.createElement(XW, { key: t, data: i, workId: t, isSelect: !0, position: this.props.position, selectIds: this.props.selectIds, updateOptInfo: this.updateOptInfo.bind(this), manager: this.props.manager });
          l.push(b);
        }
      }), l;
    }
    return null;
  }
  render() {
    return il.createElement("div", { ref: this.props.textRef }, this.editorUI);
  }
}
class WW extends rs {
  constructor(d) {
    super(d);
  }
  handleKeyUp(d) {
    const l = this.getInnerText(d.nativeEvent.target), i = this.props.activeTextId;
    i && this.updateOptInfo({
      activeTextId: i,
      update: {
        text: l.toString(),
        boxSize: [d.nativeEvent.target.offsetWidth, d.nativeEvent.target.offsetHeight],
        workState: hl.Doing
      },
      syncData: {
        canSync: !0,
        canWorker: !0
      }
    });
  }
  handleFocus(d) {
    const l = this.props.activeTextId;
    l && this.updateOptInfo({
      activeTextId: l,
      update: {
        boxSize: [d.nativeEvent.target.offsetWidth, d.nativeEvent.target.offsetHeight],
        workState: hl.Doing
      },
      syncData: {
        canSync: !0,
        canWorker: !0
      }
    });
  }
  get editorUI() {
    var d;
    if ((d = this.props.editors) != null && d.size) {
      const l = [];
      return this.props.editors.forEach((i, t) => {
        if (!(this.props.selectIds.includes(t) && this.props.activeTextId !== t)) {
          const Z = this.props.activeTextId == t ? il.createElement(GW, { key: t, data: i, workId: t, showFloatBtns: this.props.showFloatBtns || !1, handleFocus: this.handleFocus.bind(this), handleKeyUp: this.handleKeyUp.bind(this), updateOptInfo: this.updateOptInfo.bind(this), manager: this.props.manager }) : il.createElement(aW, { manager: this.props.manager, isActive: i.opt.workState === hl.Doing || i.opt.workState === hl.Start || !1, key: t, data: i, workId: t });
          l.push(Z);
        }
      }), l;
    }
    return null;
  }
  render() {
    return il.createElement("div", { className: `${this.props.className}` }, this.editorUI);
  }
}
const uW = () => {
  const { floatBarData: m } = _l(Al);
  return il.createElement(
    "div",
    { className: "bezier-pencil-plugin-hightlight-box", style: { borderColor: m == null ? void 0 : m.selectorColor } },
    il.createElement("div", { className: "point LT nwse-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point LC ew-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point LB nesw-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point TC ns-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point RT nesw-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point RC ew-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point RB nwse-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point BC ns-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } })
  );
}, hW = () => {
  const { floatBarData: m } = _l(Al);
  return il.createElement("div", { className: "bezier-pencil-plugin-hightlight-box", style: { borderColor: m == null ? void 0 : m.selectorColor } });
}, VW = () => {
  const { floatBarData: m } = _l(Al);
  return il.createElement(
    "div",
    { className: "bezier-pencil-plugin-hightlight-box", style: { borderColor: m == null ? void 0 : m.selectorColor } },
    il.createElement("div", { className: "point LT nwse-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point LB nesw-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point RT nesw-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } }),
    il.createElement("div", { className: "point RB nwse-resize", style: { backgroundColor: m == null ? void 0 : m.selectorColor } })
  );
}, pW = () => {
  const { floatBarData: m } = _l(Al);
  return il.createElement(
    "div",
    { className: "bezier-pencil-plugin-hightlight-box", style: {
      borderColor: m == null ? void 0 : m.selectorColor
    } },
    il.createElement("img", { className: "lock", alt: "lock", src: "https://sdk.netless.link/resource/icons/lock.svg" })
  );
}, yW = il.forwardRef((m, d) => {
  const { floatBarData: l, zIndex: i, position: t, angle: s, operationType: b, setPosition: Z, setOperationType: o, maranger: G } = _l(Al), { className: y, editors: X, activeTextId: W } = m, h = Nd(null), [r, L] = Fl(hl.Pending), [u, V] = Fl(), c = (I) => {
    I.preventDefault(), I.stopPropagation(), o(ul.TranslateNode), L(hl.Start), V(t), G != null && G.control.room && (G.control.room.disableDeviceInputs = !0), xl.emitMethod(Yl.MainEngine, ul.TranslateNode, { workIds: [Il], position: t, workState: hl.Start, viewId: G == null ? void 0 : G.viewId });
  }, n = wl((I, J) => {
    I.preventDefault(), I.stopPropagation();
    const T = { x: J.x, y: J.y };
    Z(T), o(ul.None), L(hl.Done), G != null && G.control.room && (G.control.room.disableDeviceInputs = !1), console.log("onDragEndHandler"), xl.emitMethod(Yl.MainEngine, ul.TranslateNode, { workIds: [Il], position: T, workState: hl.Done, viewId: G == null ? void 0 : G.viewId });
  }, 100, { leading: !1 }), e = wl((I, J) => {
    I.preventDefault(), I.stopPropagation();
    const T = { x: J.x, y: J.y };
    (J.x !== (t == null ? void 0 : t.x) || J.y !== (t == null ? void 0 : t.y)) && (Z(T), L(hl.Doing), xl.emitMethod(Yl.MainEngine, ul.TranslateNode, { workIds: [Il], position: T, workState: hl.Doing, viewId: G == null ? void 0 : G.viewId }));
  }, 100, { leading: !1 }), a = Nl(() => (l == null ? void 0 : l.scaleType) !== Zd.all || b === ul.RotateNode ? null : il.createElement(uW, null), [l, b]), Y = Nl(() => (l == null ? void 0 : l.scaleType) !== Zd.both || b === ul.RotateNode ? null : il.createElement(hW, null), [l, b]), R = Nl(() => (l == null ? void 0 : l.scaleType) !== Zd.proportional || b === ul.RotateNode ? null : il.createElement(VW, null), [l, b]), C = Nl(() => (l == null ? void 0 : l.scaleType) === Zd.none && (l != null && l.canLock) ? il.createElement(pW, null) : null, [l]), N = Nl(() => {
    const I = (l == null ? void 0 : l.selectIds) || [];
    return X && G && I ? il.createElement(rs, { manager: G, textRef: h, selectIds: I, position: t, activeTextId: W, editors: X }) : null;
  }, [l == null ? void 0 : l.selectIds, X, G, W]);
  return il.createElement(
    Bd,
    { disabled: !!(l != null && l.isLocked), position: t, onStart: c, onDrag: e, onStop: n, handle: "canvas" },
    il.createElement(
      "div",
      {
        className: `${y}`,
        style: l ? {
          width: l.w,
          height: l.h,
          zIndex: i,
          pointerEvents: i < 2 || C ? "none" : "auto"
        } : void 0,
        // onMouseMove={(e)=>{
        //     e.stopPropagation();
        //     e.preventDefault();
        // }}
        onClick: wl((I) => {
          if (I.stopPropagation(), I.preventDefault(), G && (X != null && X.size) && h.current && dd(u, t)) {
            const J = G.getPoint(I.nativeEvent);
            J && G.control.textEditorManager.computeTextActive(J, G.viewId);
          }
          return !1;
        }, 100, { leading: !1 }),
        onTouchEndCapture: wl((I) => {
          if (I.stopPropagation(), I.preventDefault(), G && (X != null && X.size) && h.current && r !== hl.Doing) {
            const J = G.getPoint(I.nativeEvent);
            J && G.control.textEditorManager.computeTextActive(J, G.viewId);
          }
          return !1;
        }, 100, { leading: !1 })
      },
      il.createElement(
        "div",
        { className: "bezier-pencil-plugin-floatCanvas-box", style: {
          width: "100%",
          height: "100%",
          transform: `rotate(${s}deg)`
        } },
        il.createElement("canvas", { ref: d, className: "bezier-pencil-plugin-floatCanvas" })
      ),
      C,
      a,
      Y,
      R,
      N
    )
  );
}), LW = (m) => {
  const { floatBarData: d, position: l, operationType: i } = _l(Al), { className: t } = m;
  return i === ul.None ? il.createElement(
    "div",
    { className: `${t}`, style: d ? {
      left: l == null ? void 0 : l.x,
      top: l == null ? void 0 : l.y,
      width: d.w,
      height: d.h
    } : void 0 },
    il.createElement(xs, { textOpt: d == null ? void 0 : d.textOpt, position: l, noLayer: d == null ? void 0 : d.isLocked })
  ) : null;
}, IW = (m) => {
  const { className: d } = m, { floatBarData: l, angle: i, setAngle: t, position: s, setOperationType: b, maranger: Z } = _l(Al), [o, G] = Fl(!1), [y, X] = Fl(new vl()), [W, h] = Fl(new vl());
  Ql(() => {
    if (l) {
      const V = Math.floor(l.w / 2), c = Math.floor(-l.h / 2);
      h(new vl(V, c)), X(new vl());
    }
  }, [l, s]);
  const r = (V, c) => {
    V.preventDefault(), V.stopPropagation(), G(!0);
    const n = Math.round(vl.GetAngleByPoints(y, W, new vl(c.x, c.y))) || 0;
    t(n), b(ul.RotateNode), Z != null && Z.control.room && (Z.control.room.disableDeviceInputs = !0), xl.emitMethod(Yl.MainEngine, ul.RotateNode, { workIds: [Il], angle: n, workState: hl.Start, viewId: Z == null ? void 0 : Z.viewId });
  }, L = wl((V, c) => {
    V.preventDefault(), V.stopPropagation(), G(!1);
    const n = Math.round(vl.GetAngleByPoints(y, W, new vl(c.x, c.y))) || 0;
    t(n), b(ul.None), Z != null && Z.control.room && (Z.control.room.disableDeviceInputs = !1), xl.emitMethod(Yl.MainEngine, ul.RotateNode, { workIds: [Il], angle: n, workState: hl.Done, viewId: Z == null ? void 0 : Z.viewId });
  }, 100, { leading: !1 }), u = wl((V, c) => {
    V.preventDefault(), V.stopPropagation(), G(!0);
    const n = Math.round(vl.GetAngleByPoints(y, W, new vl(c.x, c.y))) || 0;
    t(n), b(ul.RotateNode), xl.emitMethod(Yl.MainEngine, ul.RotateNode, { workIds: [Il], angle: n, workState: hl.Doing, viewId: Z == null ? void 0 : Z.viewId });
  }, 100, { leading: !1 });
  return il.createElement(
    Bd,
    { handle: ".bezier-pencil-plugin-rotate-mouse-pointer", onStart: r, onDrag: u, onStop: L },
    il.createElement(
      "div",
      { className: `${d}`, style: s && l ? {
        left: s.x - 30,
        top: s.y + l.h + 20
      } : void 0 },
      !o && il.createElement(
        "div",
        { className: "bezier-pencil-plugin-rotate-btn", style: { backgroundColor: l == null ? void 0 : l.selectorColor } },
        il.createElement("img", { alt: "icon", src: $l("rotation-button") })
      ),
      il.createElement(
        "div",
        { className: `bezier-pencil-plugin-rotate-mouse-pointer ${o ? "active" : ""}` },
        il.createElement("img", { alt: "icon", src: $l("rotation") }),
        il.createElement(
          "div",
          { className: "angle-icon" },
          i,
          "°"
        )
      )
    )
  );
}, YW = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAYAAADFeBvrAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYISURBVHgB7ZpNSCtXFIBPEuvz+dMGpYUKD/sWFX+Qti6kK7Hqpm6e9q0rIoIUFUShPLV10VZx4+JZqa9v20LBhdq9fyBUCtKNPH8qYl2IOw3G38Rkek4y15y5uTOZJDOWggcOSSYzN/ebc+45554JwIM8iBCPyTEP+86T4vyMfsRN4b+nQTKIJp0vzuGvlpID7os8EQNEIBD4oKio6Bm9DwaDv/v9/n/076JgbtWUYPchwrW8qD7UnOvr6wFNkpubm+/wu7f0c7y6mrnlvQufxB0Iau7V1dX3BDA/P6/V1dVpzc3N2uLiIofK1c8VYHys/wRKBUN3/hGHqaysNOjc3FwMis6hc0FtLTHuvYLxCCZgci8uLn4wg5Gh6Fy8Jk+/NkcCAlAAuUkoW4g0B+d5tLS05O/r67O8eGxsDNra2uDy8nKsoKCAwCIQDxQa0yTxgrvCYXyTk5Ml+Orf2dlJeeHIyAigFSE/P38ELfUNqNdSkjgF5FF89jL1TU1NlQwODl5gZPujp6cHWltbUw7Koc7Pz8mkZpHPFeFrJuZeqLnoMoPoZqe0JjDP/IZgnyLUG/o8NDRkuo5Ua2pjY6MC4oFCFf1cA0oKzRSOp6enRfTaGh0d/QxBt+1CUVgnOTs7+xrHfQzGyOcKkK3QTJMnQffZ6e/v/xwttmsHqqmpKXbdycnJCxy7ABLh3FEgVZ6hZJhnFZoFFMF0d3c/w7v+dyookXBnZ2c/xvHfhriVcvXfdBRItsxjnOhYqjwjoAimq6vrCysoGofk+Ph4Esd/F/UdiFtJAGUd2DygTpp5dmBUUJ2dnc9VUALm8PDwJY7/BPU9VD8k3M4RC6kskxZMKigKIMLN9vf3p3H8DyWgfEhEOwOQD9IXOTz7EObbwsLC4YWFBRgeHrY9ECXYo6MjaGlpKWlsbPxkYGDgRW1tbSEWquVlZWXBzc3Nl1VVVa8hXiXc6ioqBqGaPDk7AACJTRZ3NS9lcUp86cJwoSQ7Pj4Op6enfxUXF3/V0NCQv7q6GsCvwrqGUG/01xAD4+VQTOxaSF43d5bBOisrGBJRCtXX17+/trb268rKSgASFgmz97KFkmo6OztWuVyPweiWGc4WRkhFRQVEIpHg8vJyQAIQVlLBROVxvBYQHsXnO8tk62ZcyN0wecLBwcEvYHSzEPscBqOLCRhLC4n9uqaA8UAWAcAKhtbQ3t7eTHl5+Y9gtAp3twhT056CDMQ7MRzIFTeTYKb1yYYVQFH9VdzsqNmYKpfTJBDX3Ixgdnd3XyHMT2AMALJlBBSPaMpNngrIsTyTCgaj288YDGakictrxizvKFNOjgSSBLS+vv6UYHDb7DgMVgsChjTEgCIKGG4ZU+EWkgNBzN1qamq+pAMTExPgFMzW1tZrhHkFyWE5KxgSszx0527RaDRmOSpRshEOU11dPQPG8CwHARHJlMnTSrwSRFIlfXt7m3V5ngJGuJtqzaQtZkFBVNJezN5ZAdmwjKo2k9tVtrcI3OXk4tPgcg7ChCDZ1URgMOu72Xa5VFHOkymQhWVU60YVmjN6wiC7k6p+S1syCACOwJBYFaexV+yhBekNPsMBO6KAEeE4BMaCU67RsoYhSbXgaT//ht709vZCaWmp6YkEbLFmVJWzas04+iBL7EKpm0J7duqu0B7+CTUpNJuyvb1NCfMj1CqI9wLKUOlOUMeG+gGFkHii4HizUF4z/KFUrPsJ8WbEIyx7nnZ0dDynME6BAuce09iFHo+GrnmGltltb2//E4wVAN82y7vOjKOZXSBhJdHNiT3TYWD8OY2PTUJkdd7MkJMnT5wZVQF2RFX6yBMUdzPMvvfqxz3sXHF+GNT9ANXit/10O1sgHkZvdQAOKvs9B5L7ARELGAAXLSTvM8QExTE+YbHe+HURhZp1aRyF4CJXClbbWwGketgkW9VsY+YaiBCVhfgE+XvxRwgZSM4jUVCDZFQ9pytmXR8hUTB2gnidx4XffVWydN0yQjwmx/jkAZJBrIBI5J7ZvQGZWUgVSuU/EqmOAzicKNMVu816DdRWUV1/7xAP8n+SfwF3Du3NF2sYhwAAAABJRU5ErkJggg==", xW = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='40px'%20height='40px'%20viewBox='0%200%2040%2040'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3c!--%20Generator:%20Sketch%2060.1%20(88133)%20-%20https://sketch.com%20--%3e%3ctitle%3eshape-cursor%3c/title%3e%3cdesc%3eCreated%20with%20Sketch.%3c/desc%3e%3cdefs%3e%3cpath%20d='M20,21.5%20C20.2454599,21.5%2020.4496084,21.6768752%2020.4919443,21.9101244%20L20.5,22%20L20.5,27%20C20.5,27.2761424%2020.2761424,27.5%2020,27.5%20C19.7545401,27.5%2019.5503916,27.3231248%2019.5080557,27.0898756%20L19.5,27%20L19.5,22%20C19.5,21.7238576%2019.7238576,21.5%2020,21.5%20Z%20M27,19.5%20C27.2761424,19.5%2027.5,19.7238576%2027.5,20%20C27.5,20.2454599%2027.3231248,20.4496084%2027.0898756,20.4919443%20L27,20.5%20L22,20.5%20C21.7238576,20.5%2021.5,20.2761424%2021.5,20%20C21.5,19.7545401%2021.6768752,19.5503916%2021.9101244,19.5080557%20L22,19.5%20L27,19.5%20Z%20M18,19.5%20C18.2761424,19.5%2018.5,19.7238576%2018.5,20%20C18.5,20.2454599%2018.3231248,20.4496084%2018.0898756,20.4919443%20L18,20.5%20L13,20.5%20C12.7238576,20.5%2012.5,20.2761424%2012.5,20%20C12.5,19.7545401%2012.6768752,19.5503916%2012.9101244,19.5080557%20L13,19.5%20L18,19.5%20Z%20M20,12.5%20C20.2454599,12.5%2020.4496084,12.6768752%2020.4919443,12.9101244%20L20.5,13%20L20.5,18%20C20.5,18.2761424%2020.2761424,18.5%2020,18.5%20C19.7545401,18.5%2019.5503916,18.3231248%2019.5080557,18.0898756%20L19.5,18%20L19.5,13%20C19.5,12.7238576%2019.7238576,12.5%2020,12.5%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-64.6%25'%20y='-59.5%25'%20width='229.3%25'%20height='246.1%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeMorphology%20radius='1'%20operator='dilate'%20in='SourceAlpha'%20result='shadowSpreadOuter1'%3e%3c/feMorphology%3e%3cfeOffset%20dx='0'%20dy='2'%20in='shadowSpreadOuter1'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='3'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeComposite%20in='shadowBlurOuter1'%20in2='SourceAlpha'%20operator='out'%20result='shadowBlurOuter1'%3e%3c/feComposite%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.16%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-4'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='Whiteboard-Guidelines'%20transform='translate(-344.000000,%20-751.000000)'%3e%3cg%20id='shape-cursor'%20transform='translate(344.000000,%20751.000000)'%3e%3crect%20id='矩形备份-44'%20fill='%23FFFFFF'%20opacity='0.01'%20x='0'%20y='0'%20width='40'%20height='40'%20rx='2'%3e%3c/rect%3e%3cg%20id='形状结合'%20fill-rule='nonzero'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cpath%20stroke='%23FFFFFF'%20stroke-width='1'%20d='M20,21%20C20.4854103,21%2020.898085,21.3479993%2020.9899479,21.8654877%20L21,22%20L21,27%20C21,27.5522847%2020.5522847,28%2020,28%20C19.5145897,28%2019.101915,27.6520007%2019.0100521,27.1345123%20L19,27%20L19,22%20C19,21.4477153%2019.4477153,21%2020,21%20Z%20M27,19%20C27.5522847,19%2028,19.4477153%2028,20%20C28,20.4854103%2027.6520007,20.898085%2027.1345123,20.9899479%20L27,21%20L22,21%20C21.4477153,21%2021,20.5522847%2021,20%20C21,19.5145897%2021.3479993,19.101915%2021.8654877,19.0100521%20L22,19%20L27,19%20Z%20M18,19%20C18.5522847,19%2019,19.4477153%2019,20%20C19,20.4854103%2018.6520007,20.898085%2018.1345123,20.9899479%20L18,21%20L13,21%20C12.4477153,21%2012,20.5522847%2012,20%20C12,19.5145897%2012.3479993,19.101915%2012.8654877,19.0100521%20L13,19%20L18,19%20Z%20M20,12%20C20.4854103,12%2020.898085,12.3479993%2020.9899479,12.8654877%20L21,13%20L21,18%20C21,18.5522847%2020.5522847,19%2020,19%20C19.5145897,19%2019.101915,18.6520007%2019.0100521,18.1345123%20L19,18%20L19,13%20C19,12.4477153%2019.4477153,12%2020,12%20Z'%20fill='%23212324'%20fill-rule='evenodd'%3e%3c/path%3e%3c/g%3e%3crect%20id='矩形'%20fill='%23FFFFFF'%20x='18.5'%20y='17'%20width='3'%20height='6'%3e%3c/rect%3e%3crect%20id='矩形'%20fill='%23FFFFFF'%20x='17'%20y='18.5'%20width='6'%20height='3'%3e%3c/rect%3e%3cpath%20d='M20,21.5%20C20.2454599,21.5%2020.4496084,21.6768752%2020.4919443,21.9101244%20L20.5,22%20L20.5,27%20C20.5,27.2761424%2020.2761424,27.5%2020,27.5%20C19.7545401,27.5%2019.5503916,27.3231248%2019.5080557,27.0898756%20L19.5,27%20L19.5,22%20C19.5,21.7238576%2019.7238576,21.5%2020,21.5%20Z%20M27,19.5%20C27.2761424,19.5%2027.5,19.7238576%2027.5,20%20C27.5,20.2454599%2027.3231248,20.4496084%2027.0898756,20.4919443%20L27,20.5%20L22,20.5%20C21.7238576,20.5%2021.5,20.2761424%2021.5,20%20C21.5,19.7545401%2021.6768752,19.5503916%2021.9101244,19.5080557%20L22,19.5%20L27,19.5%20Z%20M18,19.5%20C18.2761424,19.5%2018.5,19.7238576%2018.5,20%20C18.5,20.2454599%2018.3231248,20.4496084%2018.0898756,20.4919443%20L18,20.5%20L13,20.5%20C12.7238576,20.5%2012.5,20.2761424%2012.5,20%20C12.5,19.7545401%2012.6768752,19.5503916%2012.9101244,19.5080557%20L13,19.5%20L18,19.5%20Z%20M20,12.5%20C20.2454599,12.5%2020.4496084,12.6768752%2020.4919443,12.9101244%20L20.5,13%20L20.5,18%20C20.5,18.2761424%2020.2761424,18.5%2020,18.5%20C19.7545401,18.5%2019.5503916,18.3231248%2019.5080557,18.0898756%20L19.5,18%20L19.5,13%20C19.5,12.7238576%2019.7238576,12.5%2020,12.5%20Z'%20id='形状结合'%20fill='%23212324'%20fill-rule='nonzero'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", rW = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='47px'%20height='40px'%20viewBox='0%200%2047%2040'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3c!--%20Generator:%20Sketch%2060.1%20(88133)%20-%20https://sketch.com%20--%3e%3ctitle%3etext-cursor%3c/title%3e%3cdesc%3eCreated%20with%20Sketch.%3c/desc%3e%3cdefs%3e%3cpath%20d='M16,26.5%20C15.7238576,26.5%2015.5,26.2761424%2015.5,26%20C15.5,25.7545401%2015.6768752,25.5503916%2015.9101244,25.5080557%20L16,25.5%20L19.5,25.5%20L19.5,14.5%20L16,14.5%20C15.7238576,14.5%2015.5,14.2761424%2015.5,14%20C15.5,13.7545401%2015.6768752,13.5503916%2015.9101244,13.5080557%20L16,13.5%20L24,13.5%20C24.2761424,13.5%2024.5,13.7238576%2024.5,14%20C24.5,14.2454599%2024.3231248,14.4496084%2024.0898756,14.4919443%20L24,14.5%20L20.5,14.5%20L20.5,25.5%20L24,25.5%20C24.2761424,25.5%2024.5,25.7238576%2024.5,26%20C24.5,26.2454599%2024.3231248,26.4496084%2024.0898756,26.4919443%20L24,26.5%20L16,26.5%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-284.0%25'%20y='-81.5%25'%20width='668.1%25'%20height='293.9%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeMorphology%20radius='1'%20operator='dilate'%20in='SourceAlpha'%20result='shadowSpreadOuter1'%3e%3c/feMorphology%3e%3cfeOffset%20dx='0'%20dy='2'%20in='shadowSpreadOuter1'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='3'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeComposite%20in='shadowBlurOuter1'%20in2='SourceAlpha'%20operator='out'%20result='shadowBlurOuter1'%3e%3c/feComposite%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.16%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-4'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='Whiteboard-Guidelines'%20transform='translate(-388.000000,%20-672.000000)'%3e%3cg%20id='text-cursor'%20transform='translate(392.000000,%20672.000000)'%3e%3crect%20id='矩形备份-40'%20fill='%23FFFFFF'%20opacity='0.01'%20x='0'%20y='0'%20width='40'%20height='40'%20rx='2'%3e%3c/rect%3e%3cg%20id='形状结合'%20fill-rule='nonzero'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cpath%20stroke='%23FFFFFF'%20stroke-width='1'%20d='M19,25%20L19,15%20L16,15%20C15.4477153,15%2015,14.5522847%2015,14%20C15,13.5145897%2015.3479993,13.101915%2015.8654877,13.0100521%20L16,13%20L24,13%20C24.5522847,13%2025,13.4477153%2025,14%20C25,14.4854103%2024.6520007,14.898085%2024.1345123,14.9899479%20L24,15%20L21,15%20L21,25%20L24,25%20C24.5522847,25%2025,25.4477153%2025,26%20C25,26.4854103%2024.6520007,26.898085%2024.1345123,26.9899479%20L24,27%20L16,27%20C15.4477153,27%2015,26.5522847%2015,26%20C15,25.5145897%2015.3479993,25.101915%2015.8654877,25.0100521%20L16,25%20L19,25%20Z'%20fill='%23212324'%20fill-rule='evenodd'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
class RW extends Ul.Component {
  constructor(d) {
    super(d), Object.defineProperty(this, "renderAvatar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        var t;
        const i = `rgb(${l.memberState.strokeColor[0]}, ${l.memberState.strokeColor[1]}, ${l.memberState.strokeColor[2]})`;
        if (this.detectAvatar(l)) {
          const s = this.detectCursorName(l);
          return Ul.createElement("img", { className: "cursor-selector-avatar", style: {
            width: s ? 19 : 28,
            height: s ? 19 : 28,
            position: s ? "initial" : "absolute",
            borderColor: s ? "white" : i,
            marginRight: s ? 4 : 0
          }, src: (t = l.payload) == null ? void 0 : t.avatar, alt: "avatar" });
        } else
          return null;
      }
    }), Object.defineProperty(this, "getOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        const i = this.getCursorName(l), t = this.detectAvatar(l);
        return i === void 0 && t === void 0 ? 0 : 1;
      }
    }), Object.defineProperty(this, "getCursorName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        if (l.payload && l.payload.cursorName)
          return l.payload.cursorName;
      }
    }), Object.defineProperty(this, "getThemeClass", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => l.payload && l.payload.theme ? "cursor-inner-mellow" : "cursor-inner"
    }), Object.defineProperty(this, "getCursorBackgroundColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        const i = this.detectCursorName(l);
        return l.payload && l.payload.cursorBackgroundColor ? l.payload.cursorBackgroundColor : i ? `rgb(${l.memberState.strokeColor[0]}, ${l.memberState.strokeColor[1]}, ${l.memberState.strokeColor[2]})` : void 0;
      }
    }), Object.defineProperty(this, "getCursorTextColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => l.payload && l.payload.cursorTextColor ? l.payload.cursorTextColor : "#FFFFFF"
    }), Object.defineProperty(this, "getCursorTagBackgroundColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => l.payload && l.payload.cursorTagBackgroundColor ? l.payload.cursorTagBackgroundColor : this.getCursorBackgroundColor(l)
    }), Object.defineProperty(this, "detectCursorName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => !!(l.payload && l.payload.cursorName)
    }), Object.defineProperty(this, "detectAvatar", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => !!(l.payload && l.payload.avatar)
    }), Object.defineProperty(this, "renderTag", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        if (l.payload && l.payload.cursorTagName)
          return Ul.createElement("span", { className: "cursor-tag-name", style: { backgroundColor: this.getCursorTagBackgroundColor(l) } }, l.payload.cursorTagName);
      }
    });
  }
  render() {
    const { roomMember: d } = this.props, l = this.getCursorName(d);
    switch (d.memberState.currentApplianceName) {
      case Tl.pencil:
        return Ul.createElement(
          "div",
          { className: "cursor-box" },
          Ul.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -90%)", marginLeft: "10px" } },
            Ul.createElement(
              "div",
              { className: "cursor-name" },
              Ul.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(d),
                  backgroundColor: this.getCursorBackgroundColor(d),
                  color: this.getCursorTextColor(d)
                }, className: this.getThemeClass(d) },
                this.renderAvatar(d),
                l,
                this.renderTag(d)
              )
            ),
            Ul.createElement(
              "div",
              null,
              Ul.createElement("img", { className: "cursor-pencil-image", src: YW, alt: "pencilCursor" })
            )
          )
        );
      case Tl.text:
        return Ul.createElement(
          "div",
          { className: "cursor-box" },
          Ul.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -65%)", marginLeft: "0px" } },
            Ul.createElement(
              "div",
              { className: "cursor-name" },
              Ul.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(d),
                  backgroundColor: this.getCursorBackgroundColor(d),
                  color: this.getCursorTextColor(d)
                }, className: this.getThemeClass(d) },
                this.renderAvatar(d),
                l,
                this.renderTag(d)
              )
            ),
            Ul.createElement(
              "div",
              null,
              Ul.createElement("img", { className: "cursor-arrow-image", src: rW, alt: "textCursor" })
            )
          )
        );
      case Tl.rectangle:
      case Tl.arrow:
      case Tl.straight:
      case Tl.shape:
      case Tl.ellipse:
        return Ul.createElement(
          "div",
          { className: "cursor-box" },
          Ul.createElement(
            "div",
            { className: "cursor-mid cursor-pencil-offset", style: { transform: "translate(-50%, -65%)", marginLeft: "0px" } },
            Ul.createElement(
              "div",
              { className: "cursor-name" },
              Ul.createElement(
                "div",
                { style: {
                  opacity: this.getOpacity(d),
                  backgroundColor: this.getCursorBackgroundColor(d),
                  color: this.getCursorTextColor(d)
                }, className: this.getThemeClass(d) },
                this.renderAvatar(d),
                l,
                this.renderTag(d)
              )
            ),
            Ul.createElement(
              "div",
              null,
              Ul.createElement("img", { className: "cursor-arrow-image", src: xW, alt: "shapeCursor" })
            )
          )
        );
      default:
        return null;
    }
  }
}
const SW = (m) => {
  const { className: d, info: l } = m, { roomMember: i, ...t } = l || {};
  return Ul.createElement("div", { className: `${d}`, style: t ? {
    transform: `translate(${t.x}px, ${t.y}px)`
  } : { display: "none" } }, i && Ul.createElement(RW, { roomMember: i }));
}, KW = (m) => {
  const { className: d } = m, [l, i] = Fl({ x: 0, y: 0, h: 0, w: 0 }), { floatBarData: t, position: s, maranger: b } = _l(Al);
  Ql(() => {
    t && i({ x: t.x, y: t.y, w: t.w, h: t.h });
  }, []);
  const Z = (y) => {
    if (y.preventDefault(), y.stopPropagation(), t != null && t.w && (t != null && t.h)) {
      const X = {
        x: (s == null ? void 0 : s.x) || 0,
        y: (s == null ? void 0 : s.y) || 0,
        w: t.w,
        h: t.h
      };
      i(X), b != null && b.control.room && (b.control.room.disableDeviceInputs = !0), xl.emitMethod(Yl.MainEngine, ul.ScaleNode, { workIds: [Il], box: X, workState: hl.Start, viewId: b == null ? void 0 : b.viewId });
    }
  }, o = wl((y, X, W, h) => {
    y.preventDefault(), y.stopPropagation();
    const r = {
      x: l.x,
      y: l.y,
      w: l.w,
      h: l.h
    };
    switch (r.w += h.width, r.h += h.height, X) {
      case "bottomLeft":
      case "left":
        r.x -= h.width;
        break;
      case "topLeft":
        r.x -= h.width, r.y -= h.height;
        break;
      case "top":
      case "topRight":
        r.y -= h.height;
        break;
    }
    (h.width !== 0 || h.height !== 0) && xl.emitMethod(Yl.MainEngine, ul.ScaleNode, { workIds: [Il], box: r, dir: X, workState: hl.Doing, viewId: b == null ? void 0 : b.viewId });
  }, 100, { leading: !1 }), G = wl((y, X, W, h) => {
    y.preventDefault(), y.stopPropagation();
    const r = {
      x: l.x,
      y: l.y,
      w: l.w,
      h: l.h
    };
    switch (r.w += h.width, r.h += h.height, X) {
      case "bottomLeft":
      case "left":
        r.x -= h.width;
        break;
      case "topLeft":
        r.x -= h.width, r.y -= h.height;
        break;
      case "top":
      case "topRight":
        r.y -= h.height;
        break;
    }
    b != null && b.control.room && (b.control.room.disableDeviceInputs = !1), xl.emitMethod(Yl.MainEngine, ul.ScaleNode, { workIds: [Il], box: r, dir: X, workState: hl.Done, viewId: b == null ? void 0 : b.viewId });
  }, 100, { leading: !1 });
  return il.createElement(Js, { className: `${d}`, boundsByDirection: !0, size: {
    width: (t == null ? void 0 : t.w) || 0,
    height: (t == null ? void 0 : t.h) || 0
  }, style: {
    position: "absolute",
    pointerEvents: "auto",
    left: s == null ? void 0 : s.x,
    top: s == null ? void 0 : s.y
  }, enable: {
    top: (t == null ? void 0 : t.scaleType) === Zd.all && !0 || !1,
    right: (t == null ? void 0 : t.scaleType) === Zd.all && !0 || !1,
    bottom: (t == null ? void 0 : t.scaleType) === Zd.all && !0 || !1,
    left: (t == null ? void 0 : t.scaleType) === Zd.all && !0 || !1,
    topRight: !0,
    bottomRight: !0,
    bottomLeft: !0,
    topLeft: !0
  }, lockAspectRatio: (t == null ? void 0 : t.scaleType) === Zd.proportional, onResizeStart: Z, onResize: o, onResizeStop: G });
}, Ut = (m) => {
  const { id: d, pos: l, pointMap: i, type: t } = m, { setOperationType: s, maranger: b, floatBarData: Z } = _l(Al), [o, G] = Fl({ x: 0, y: 0 }), [y, X] = Fl(hl.Pending);
  Ql(() => {
    (y === hl.Pending || y === hl.Done) && G(l);
  }, [l, y]);
  const W = (L) => {
    L.preventDefault(), L.stopPropagation(), s(ul.SetPoint), X(hl.Start), b != null && b.control.room && (b.control.room.disableDeviceInputs = !0), xl.emitMethod(Yl.MainEngine, ul.SetPoint, { workId: Il, pointMap: i, workState: hl.Start, viewId: b == null ? void 0 : b.viewId });
  }, h = wl((L, u) => {
    if (L.preventDefault(), L.stopPropagation(), s(ul.SetPoint), X(hl.Doing), u.x !== (o == null ? void 0 : o.x) || u.y !== (o == null ? void 0 : o.y)) {
      const V = i.get(d);
      V && t === "start" && (b != null && b.control.viewContainerManager) ? V[0] = b.control.viewContainerManager.transformToScenePoint([u.x, u.y], b.viewId) : V && t === "end" && (b != null && b.control.viewContainerManager) && (V[1] = b.control.viewContainerManager.transformToScenePoint([u.x, u.y], b.viewId)), xl.emitMethod(Yl.MainEngine, ul.SetPoint, { workId: Il, pointMap: i, workState: hl.Doing, viewId: b == null ? void 0 : b.viewId });
    }
  }, 50, { leading: !1 }), r = wl((L, u) => {
    if (L.preventDefault(), L.stopPropagation(), s(ul.None), X(hl.Done), u.x !== (o == null ? void 0 : o.x) || u.y !== (o == null ? void 0 : o.y)) {
      G(u);
      const V = i.get(d);
      V && t === "start" && (b != null && b.control.viewContainerManager) ? V[0] = b.control.viewContainerManager.transformToScenePoint([u.x, u.y], b.viewId) : V && t === "end" && (b != null && b.control.viewContainerManager) && (V[1] = b.control.viewContainerManager.transformToScenePoint([u.x, u.y], b.viewId)), xl.emitMethod(Yl.MainEngine, ul.SetPoint, { workId: Il, pointMap: i, workState: hl.Done, viewId: b == null ? void 0 : b.viewId });
    }
  }, 100, { leading: !1 });
  return il.createElement(
    Bd,
    { position: o, onStart: W, onDrag: h, onStop: r },
    il.createElement(
      "div",
      { className: "bezier-pencil-plugin-point-draggable-btn" },
      il.createElement("div", { className: "bezier-pencil-plugin-point-draggable-btn-inner", style: {
        borderColor: Z == null ? void 0 : Z.selectorColor
      } })
    )
  );
}, CW = (m) => {
  const { className: d } = m, { floatBarData: l, maranger: i } = _l(Al), [t, s] = Fl(), [b, Z] = Fl(), [o, G] = Fl(/* @__PURE__ */ new Map());
  Ql(() => {
    const W = [];
    if (i && (l != null && l.points)) {
      const h = i.viewId;
      if (i.control.viewContainerManager.getView(h))
        for (const L of l.points) {
          const u = i.control.viewContainerManager.transformToOriginPoint(L, h);
          W.push(u);
        }
      l != null && l.selectIds && l.selectIds.length === 1 && (o.set(l.selectIds[0], l.points), G(o));
    }
    W[0] && s({ x: W[0][0], y: W[0][1] }), W[1] && Z({ x: W[1][0], y: W[1][1] });
  }, [i, l == null ? void 0 : l.points, l == null ? void 0 : l.selectIds, o]);
  const y = Nl(() => t && (l != null && l.selectIds) ? il.createElement(Ut, { pos: t, type: "start", id: l.selectIds[0], pointMap: o }) : null, [t, l == null ? void 0 : l.selectIds, o]), X = Nl(() => b && (l != null && l.selectIds) ? il.createElement(Ut, { pos: b, type: "end", id: l.selectIds[0], pointMap: o }) : null, [b, l == null ? void 0 : l.selectIds, o]);
  return il.createElement(
    "div",
    { className: `${d}` },
    y,
    X
  );
}, Al = il.createContext({
  maranger: void 0,
  floatBarColors: [],
  floatBarData: void 0,
  zIndex: -1,
  dpr: 1,
  position: void 0,
  angle: 0,
  operationType: ul.None,
  scale: [1, 1],
  setPosition: () => {
  },
  setAngle: () => {
  },
  setOperationType: () => {
  },
  setFloatBarData: () => {
  }
});
class fi extends il.Component {
  constructor(d) {
    var l;
    super(d), Object.defineProperty(this, "setPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ position: i });
      }
    }), Object.defineProperty(this, "setAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ angle: i });
      }
    }), Object.defineProperty(this, "setOperationType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.setState({ operationType: i });
      }
    }), this.state = {
      floatBarData: void 0,
      showFloatBar: !1,
      zIndex: -1,
      dpr: 1,
      position: void 0,
      angle: 0,
      operationType: ul.None,
      cursorInfo: void 0,
      scale: [1, 1],
      editors: this.editors,
      activeTextId: (l = this.props.maranger.control.textEditorManager) == null ? void 0 : l.activeId
    };
  }
  get editors() {
    return El(this.props.maranger.control.textEditorManager.filterEditor(this.props.maranger.viewId));
  }
  componentDidMount() {
    this.props.maranger.vDom = this, this.props.maranger.mountView(), this.setState({ dpr: this.props.maranger.dpr });
  }
  componentWillUnmount() {
  }
  showFloatBar(d, l) {
    const i = d && l && { ...this.state.floatBarData, ...l } || void 0;
    this.setState({
      showFloatBar: d,
      floatBarData: i,
      position: i && { x: i.x, y: i.y },
      angle: 0
    }), i && this.props.refs.floatBarCanvasRef.current && (i.canvasHeight && i.canvasWidth ? (this.props.refs.floatBarCanvasRef.current.width = i.canvasWidth * this.state.dpr, this.props.refs.floatBarCanvasRef.current.height = i.canvasHeight * this.state.dpr, this.props.refs.floatBarCanvasRef.current.style.width = i.canvasWidth + "px", this.props.refs.floatBarCanvasRef.current.style.height = i.canvasHeight + "px") : (this.props.refs.floatBarCanvasRef.current.width = i.w * this.state.dpr, this.props.refs.floatBarCanvasRef.current.height = i.h * this.state.dpr, this.props.refs.floatBarCanvasRef.current.style.width = "100%", this.props.refs.floatBarCanvasRef.current.style.height = "100%"));
  }
  setActiveTextEditor(d) {
    this.setState({
      activeTextId: d,
      editors: this.editors
    });
  }
  setActiveCursor(d) {
    this.setState({ cursorInfo: d });
  }
  setFloatZIndex(d) {
    this.setState({ zIndex: d });
  }
  setFloatBarData(d) {
    this.state.floatBarData && this.setState({
      floatBarData: { ...this.state.floatBarData, ...d }
    });
  }
  render() {
    var l, i, t, s, b, Z, o, G, y, X, W, h, r;
    const d = !!((i = (l = this.props.maranger.control) == null ? void 0 : l.room) != null && i.floatBarOptions);
    return il.createElement(
      il.Fragment,
      null,
      il.createElement(
        "div",
        { className: hd.Container, onMouseDown: (L) => {
          L.preventDefault(), L.stopPropagation();
        }, onTouchStart: (L) => {
          L.stopPropagation();
        }, onMouseMove: (L) => {
          this.props.maranger.cursorMouseMove(L);
        } },
        il.createElement(
          "div",
          { className: hd.CanvasBox },
          il.createElement("canvas", { className: hd.FloatCanvas, ref: this.props.refs.canvasFloatRef }),
          il.createElement("canvas", { ref: this.props.refs.canvasBgRef })
        ),
        il.createElement(
          Al.Provider,
          { value: {
            maranger: this.props.maranger,
            floatBarColors: d && ((b = (s = (t = this.props.maranger.control) == null ? void 0 : t.room) == null ? void 0 : s.floatBarOptions) == null ? void 0 : b.colors) || [],
            floatBarData: this.state.floatBarData,
            zIndex: this.state.zIndex,
            dpr: this.state.dpr,
            position: this.state.position,
            angle: this.state.angle,
            operationType: this.state.operationType,
            scale: this.state.scale,
            setPosition: this.setPosition.bind(this),
            setAngle: this.setAngle.bind(this),
            setOperationType: this.setOperationType.bind(this),
            setFloatBarData: this.setFloatBarData.bind(this)
          } },
          this.state.showFloatBar && il.createElement(yW, { className: hd.FloatBar, ref: this.props.refs.floatBarCanvasRef, editors: this.state.editors, activeTextId: this.state.activeTextId }) || null,
          ((Z = this.state.editors) == null ? void 0 : Z.size) && il.createElement(WW, { className: hd.TextEditorContainer, showFloatBtns: d, manager: this.props.maranger, selectIds: ((o = this.state.floatBarData) == null ? void 0 : o.selectIds) || [], editors: this.state.editors, activeTextId: this.state.activeTextId }) || null,
          ((G = this.state.floatBarData) == null ? void 0 : G.canRotate) && ((X = (y = this.state.floatBarData) == null ? void 0 : y.selectIds) == null ? void 0 : X.length) === 1 && (this.state.operationType === ul.None || this.state.operationType === ul.RotateNode) && il.createElement(IW, { className: hd.RotateBtn }) || null,
          (((W = this.state.floatBarData) == null ? void 0 : W.scaleType) === Zd.all || ((h = this.state.floatBarData) == null ? void 0 : h.scaleType) === Zd.proportional) && this.state.showFloatBar && (this.state.operationType === ul.None || this.state.operationType === ul.ScaleNode) && il.createElement(KW, { className: hd.ResizeBtn }) || null,
          ((r = this.state.floatBarData) == null ? void 0 : r.scaleType) === Zd.both && this.state.showFloatBar && (this.state.operationType === ul.None || this.state.operationType === ul.SetPoint) && il.createElement(CW, { className: hd.ResizeTowBox }) || null,
          this.state.showFloatBar && d && il.createElement(LW, { className: hd.FloatBarBtn }) || null
        ),
        this.state.cursorInfo && this.state.cursorInfo.roomMember && (il.createElement(SW, { key: this.state.cursorInfo.roomMember.memberId, className: hd.CursorBox, info: this.state.cursorInfo }) || null)
      )
    );
  }
}
class JW extends od {
  constructor(d, l) {
    super(d, l), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "vDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "mainView"
    }), Object.defineProperty(this, "eventTragetElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    });
  }
  setCanvassStyle() {
    if (this.eventTragetElement) {
      const d = this.eventTragetElement.offsetWidth, l = this.eventTragetElement.offsetHeight;
      d && l && this.canvasBgRef.current && this.canvasFloatRef.current && (this.dpr = Ui(this.canvasBgRef.current.getContext("2d")), this.width = d, this.height = l, this.canvasBgRef.current.style.width = `${d}px`, this.canvasBgRef.current.style.height = `${l}px`, this.canvasFloatRef.current.style.width = `${d}px`, this.canvasFloatRef.current.style.height = `${l}px`, this.canvasFloatRef.current.width = d * this.dpr, this.canvasFloatRef.current.height = l * this.dpr, this.canvasBgRef.current.width = d * this.dpr, this.canvasBgRef.current.height = l * this.dpr);
    }
  }
  createMainViewDisplayer(d) {
    return this.vDom || (this.containerOffset = this.getContainerOffset(d, this.containerOffset), this.eventTragetElement = d.parentElement.children[0], d.innerHTML = "", Ci.render(il.createElement(fi, { viewId: this.viewId, maranger: this, refs: {
      canvasFloatRef: this.canvasFloatRef,
      canvasBgRef: this.canvasBgRef,
      floatBarRef: this.floatBarRef,
      floatBarCanvasRef: this.floatBarCanvasRef
    } }), d), this.control.room && this.bindDisplayerEvent(this.eventTragetElement)), this;
  }
}
class Rd extends Od {
  constructor(d) {
    super(d), Object.defineProperty(this, "focuedViewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "focuedView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.control = d.control;
  }
  bindMainView() {
    if (!this.control.divMainView)
      return;
    const d = new JW(this.control, sd.InternalMsgEmitter);
    this.focuedViewId = od.viewId;
    const { width: l, height: i, dpr: t } = d, s = {
      dpr: t,
      originalPoint: [l / 2, i / 2],
      offscreenCanvasOpt: {
        ...Rd.defaultScreenCanvasOpt,
        width: l,
        height: i
      },
      layerOpt: {
        ...Rd.defaultLayerOpt,
        width: l,
        height: i
      },
      cameraOpt: {
        ...Rd.defaultCameraOpt,
        width: l,
        height: i
      }
    }, b = this.control.room && this.control.room.mainView || this.control.play && this.control.play.mainView;
    if (b) {
      const { scale: Z, ...o } = b.camera;
      s.cameraOpt = {
        ...s.cameraOpt,
        ...o,
        scale: Z === 1 / 0 ? 1 : Z
      }, this.createMianView({
        id: od.viewId,
        displayer: d,
        focusScenePath: b.focusScenePath || b.scenePath,
        cameraOpt: s.cameraOpt,
        viewData: b
      }), this.focuedView = this.mainView, d.createMainViewDisplayer(this.control.divMainView);
    }
  }
  mountView(d) {
    var i;
    const l = this.getView(d);
    if (l) {
      const { width: t, height: s, dpr: b } = l.displayer, Z = {
        dpr: b,
        originalPoint: [t / 2, s / 2],
        offscreenCanvasOpt: {
          ...Rd.defaultScreenCanvasOpt,
          width: t,
          height: s
        },
        layerOpt: {
          ...Rd.defaultLayerOpt,
          width: t,
          height: s
        },
        cameraOpt: {
          ...Rd.defaultCameraOpt,
          width: t,
          height: s
        }
      };
      if (l.viewData) {
        const { scale: o, ...G } = l.viewData.camera;
        Z.cameraOpt = {
          ...Z.cameraOpt,
          ...G,
          scale: o === 1 / 0 ? 1 : o
        };
      }
      this.control.worker.isActive || this.control.activeWorker(), (i = this.control.worker) == null || i.createViewWorker(d, Z), l.focusScenePath && this.control.collector && this.control.worker.pullServiceData(d, l.focusScenePath);
    }
  }
  setFocuedViewCameraOpt(d) {
    this.focuedView && (this.focuedView.cameraOpt = d);
  }
  transformToOriginPoint(d, l) {
    const i = this.getView(l);
    if (i != null && i.viewData) {
      const t = i.viewData.convertToPointOnScreen(d[0], d[1]);
      return [t.x, t.y];
    }
    return d;
  }
  transformToScenePoint(d, l) {
    const i = this.getView(l);
    if (i != null && i.viewData) {
      const t = i.viewData.convertToPointInWorld({ x: d[0], y: d[1] });
      return [t.x, t.y];
    }
    return d;
  }
  render(d) {
    var l, i, t, s, b, Z, o, G, y;
    for (const X of d) {
      const { rect: W, imageBitmap: h, isClear: r, isUnClose: L, drawCanvas: u, clearCanvas: V, offset: c, viewId: n } = X, e = (l = this.getView(n)) == null ? void 0 : l.displayer;
      if (e && W) {
        const { dpr: a, canvasBgRef: Y, canvasFloatRef: R, floatBarCanvasRef: C } = e, N = W.w * a, I = W.h * a, J = W.x * a, T = W.y * a;
        if (r)
          if (V === pd.Selector)
            (t = (i = C.current) == null ? void 0 : i.getContext("2d")) == null || t.clearRect(0, 0, N, I);
          else {
            const K = V === pd.Float ? (s = R.current) == null ? void 0 : s.getContext("2d") : (b = Y.current) == null ? void 0 : b.getContext("2d");
            K == null || K.clearRect(J, T, N, I);
          }
        if (u && h)
          if (u === pd.Selector) {
            const K = ((c == null ? void 0 : c.x) || 0) * a, S = ((c == null ? void 0 : c.y) || 0) * a;
            (o = (Z = C.current) == null ? void 0 : Z.getContext("2d")) == null || o.drawImage(h, 0, 0, N, I, K, S, N, I);
          } else {
            const K = u === pd.Float ? (G = R.current) == null ? void 0 : G.getContext("2d") : (y = Y.current) == null ? void 0 : y.getContext("2d");
            K == null || K.drawImage(h, 0, 0, N, I, J, T, N, I);
          }
        if (L)
          return;
        h == null || h.close();
      }
    }
  }
}
class yd extends sd {
  constructor(d) {
    super(d), Object.defineProperty(this, "viewContainerManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "divMainView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wl((i) => {
        this.viewContainerManager.setFocuedViewCameraOpt(i);
      }, 20, { leading: !1 })
    });
    const l = {
      control: this,
      internalMsgEmitter: yd.InternalMsgEmitter
    };
    this.viewContainerManager = new Rd(l);
  }
  init() {
    yd.InternalMsgEmitter.on(Yl.BindMainView, (d) => {
      this.divMainView = d, this.plugin && !this.viewContainerManager.mainView && this.viewContainerManager.bindMainView();
    });
  }
  activePlugin() {
    this.plugin && this.divMainView && !this.viewContainerManager.mainView && this.viewContainerManager.bindMainView(), this.collector && (this.collector.addStorageStateListener((d) => {
      var l, i;
      if ((l = this.collector) != null && l.storage && Object.keys(this.collector.storage).length === 0) {
        (i = this.worker) == null || i.clearViewScenePath("mainView", !0);
        return;
      }
      if (d) {
        const t = /* @__PURE__ */ new Map();
        Object.keys(d).forEach((s) => {
          var Z;
          const b = d[s];
          if (b) {
            const o = b.viewId, G = t.get(o) || /* @__PURE__ */ new Set();
            G.add(s), t.set(o, G), (Z = this.worker) == null || Z.onServiceDerive(s, b);
          }
        });
        for (const [s, b] of t.entries())
          yd.InternalMsgEmitter.emit("excludeIds", [...b], s);
      }
    }), this.room && (this.roomMember.onUidChangeHook((d) => {
      var l, i, t, s;
      if ((l = this.collector) != null && l.serviceStorage) {
        const b = [];
        this.viewContainerManager.getAllViews().forEach((Z) => {
          var o, G, y;
          if (Z && Z.focusScenePath && ((o = this.collector) != null && o.serviceStorage[Z.id]) && ((G = this.collector) != null && G.serviceStorage[Z.id][Z.focusScenePath])) {
            const X = Object.keys((y = this.collector) == null ? void 0 : y.serviceStorage[Z.id][Z.focusScenePath]).filter((W) => {
              var h;
              return (h = this.collector) == null ? void 0 : h.isSelector(W);
            }).map((W) => ({ viewId: Z.id, scenePath: Z.focusScenePath, key: W }));
            X.length && b.push(...X);
          }
        }), b.forEach(({ key: Z, viewId: o, scenePath: G }) => {
          var X, W;
          const y = (X = this.collector) == null ? void 0 : X.getUidFromKey(Z);
          y && !d.online.includes(y) && ((W = this.collector) == null || W.updateValue(Z, void 0, { isAfterUpdate: !0, viewId: o, scenePath: G }));
        });
      }
      (t = (i = this.cursor) == null ? void 0 : i.eventCollector) != null && t.serviceStorage && Object.keys((s = this.cursor) == null ? void 0 : s.eventCollector.serviceStorage).forEach((Z) => {
        var o, G;
        d.online.includes(Z) || (G = (o = this.cursor) == null ? void 0 : o.eventCollector) == null || G.clearValue(Z);
      });
    }), this.worker.isActive && this.viewContainerManager.getAllViews().forEach((d) => {
      d && d.focusScenePath && this.worker.pullServiceData(d.id, d.focusScenePath);
    })));
  }
  activeWorker() {
    this.worker.init();
  }
}
class Ed extends il.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "mainViewRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    Ed.emiter || (Ed.emiter = yd.InternalMsgEmitter), Ed.emiter.emit(Yl.BindMainView, this.mainViewRef);
  }
  componentWillUnmount() {
    Ed.emiter.emit(Yl.DisplayState, Ii.unmounted);
  }
  render() {
    return il.createElement(
      il.Fragment,
      null,
      this.props.children,
      il.createElement("div", { className: "teaching-aids-plugin-main-view-displayer", ref: (d) => this.mainViewRef = d })
    );
  }
}
class _d extends od {
  constructor(d, l) {
    super(d, l), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "vDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "eventTragetElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    });
  }
  setCanvassStyle() {
    if (this.eventTragetElement) {
      const d = this.eventTragetElement.offsetWidth || this.width, l = this.eventTragetElement.offsetHeight || this.height;
      d && l && this.canvasBgRef.current && this.canvasFloatRef.current && (this.dpr = Ui(this.canvasBgRef.current.getContext("2d")), this.width = d, this.height = l, this.canvasBgRef.current.style.width = `${d}px`, this.canvasBgRef.current.style.height = `${l}px`, this.canvasFloatRef.current.style.width = `${d}px`, this.canvasFloatRef.current.style.height = `${l}px`, this.canvasFloatRef.current.width = d * this.dpr, this.canvasFloatRef.current.height = l * this.dpr, this.canvasBgRef.current.width = d * this.dpr, this.canvasBgRef.current.height = l * this.dpr);
    }
  }
  destroy() {
    if (super.destroy(), this.eventTragetElement) {
      const d = this.eventTragetElement.parentElement;
      if (d) {
        const l = d.querySelectorAll(".teaching-aids-plugin-main-view-displayer");
        for (const i of l)
          i.remove();
      }
    }
  }
  createMainViewDisplayer(d) {
    const l = document.createElement("div");
    return l.className = "teaching-aids-plugin-main-view-displayer", d.appendChild(l), this.eventTragetElement = d.children[0], this.containerOffset = this.getContainerOffset(this.eventTragetElement, this.containerOffset), this.bindToolsClass(), Ci.render(il.createElement(fi, { viewId: this.viewId, maranger: this, refs: {
      canvasFloatRef: this.canvasFloatRef,
      canvasBgRef: this.canvasBgRef,
      floatBarRef: this.floatBarRef,
      floatBarCanvasRef: this.floatBarCanvasRef
    } }), l), this.control.room && this.bindDisplayerEvent(this.eventTragetElement), this;
  }
}
class NW extends JG {
  constructor(d, l, i) {
    super(d, l, i), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "vDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "eventTragetElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: il.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    });
  }
  setCanvassStyle() {
    if (this.eventTragetElement && this.canvasBgRef.current) {
      this.dpr = Ui(this.canvasBgRef.current.getContext("2d"));
      const d = this.eventTragetElement.offsetWidth || this.width, l = this.eventTragetElement.offsetHeight || this.height;
      d && l && this.canvasFloatRef.current && (this.width = d, this.height = l, this.canvasBgRef.current.style.width = `${d}px`, this.canvasBgRef.current.style.height = `${l}px`, this.canvasFloatRef.current.style.width = `${d}px`, this.canvasFloatRef.current.style.height = `${l}px`, this.canvasFloatRef.current.width = d * this.dpr, this.canvasFloatRef.current.height = l * this.dpr, this.canvasBgRef.current.width = d * this.dpr, this.canvasBgRef.current.height = l * this.dpr);
    }
  }
  createAppViewDisplayer(d, l) {
    const i = document.createElement("div");
    return i.className = "teaching-aids-plugin-app-view-displayer", l.appendChild(i), this.eventTragetElement = l.children[0], this.containerOffset = this.getContainerOffset(this.eventTragetElement, this.containerOffset), this.bindToolsClass(), Ci.render(il.createElement(fi, { viewId: d, maranger: this, refs: {
      canvasFloatRef: this.canvasFloatRef,
      canvasBgRef: this.canvasBgRef,
      floatBarRef: this.floatBarRef,
      floatBarCanvasRef: this.floatBarCanvasRef
    } }), i), this.control.room && this.bindDisplayerEvent(this.eventTragetElement), this;
  }
}
class Wd extends Od {
  constructor(d) {
    super(d), Object.defineProperty(this, "focuedViewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "focuedView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "control", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tmpFocusedViewId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "checkScaleTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onMainViewRelease", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        this.control.textEditorManager.clear(_d.viewId, !0), this.onMainViewMounted(l);
      }
    }), Object.defineProperty(this, "onMainViewMounted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        var W;
        const i = l.divElement;
        if (!i || !l.focusScenePath || !(l.focusScenePath || l.scenePath))
          return;
        if (this.mainView && this.mainView.displayer) {
          this.mainView.displayer.destroy();
          const h = i.getElementsByClassName("teaching-aids-plugin-main-view-displayer");
          for (const r of h)
            r.remove();
          (W = this.control.worker) == null || W.destroyViewWorker(this.mainView.id, !0), this.mainView = void 0;
        }
        const s = new _d(this.control, sd.InternalMsgEmitter), b = l.size.width || s.width, Z = l.size.height || s.height, G = {
          dpr: s.dpr,
          originalPoint: [b / 2, Z / 2],
          offscreenCanvasOpt: {
            ...Wd.defaultScreenCanvasOpt,
            width: b,
            height: Z
          },
          layerOpt: {
            ...Wd.defaultLayerOpt,
            width: b,
            height: Z
          },
          cameraOpt: {
            ...Wd.defaultCameraOpt,
            width: b,
            height: Z
          }
        }, { scale: y, ...X } = l.camera;
        G.cameraOpt = {
          ...G.cameraOpt,
          ...X,
          scale: y === 1 / 0 ? 1 : y
        }, this.focuedViewId = _d.viewId, this.createMianView({
          id: _d.viewId,
          container: i,
          displayer: s,
          focusScenePath: l.focusScenePath,
          cameraOpt: G.cameraOpt,
          viewData: l
        }), this.focuedView = this.mainView, s.createMainViewDisplayer(i), l.callbacks.on("onSizeUpdated", this.onMainViewSizeUpdated), l.callbacks.on("onCameraUpdated", this.onMainViewCameraUpdated), l.callbacks.on("onActiveHotkey", this.onActiveHotkeyChange.bind(this));
      }
    }), Object.defineProperty(this, "onMainViewSizeUpdated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async () => {
        Promise.resolve().then(() => {
          if (this.mainView && this.mainView.viewData) {
            const l = this.mainView.viewData.size, i = this.mainView.cameraOpt;
            i && (this.mainView.displayer.updateSize(), this.mainView.cameraOpt = { ...i, ...l });
          }
        });
      }
    }), Object.defineProperty(this, "onMainViewCameraUpdated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async () => {
        Promise.resolve().then(() => {
          if (this.mainView && this.mainView.viewData) {
            const l = this.mainView.viewData.camera, i = this.mainView.cameraOpt;
            if (i) {
              const t = l.scale === 1 / 0 ? 1 : l.scale, s = l.centerX || 0, b = l.centerY || 0;
              this.mainView.cameraOpt = { ...i, scale: t, centerX: s, centerY: b }, this.checkScaleTimer && l.scale == 1 / 0 && (clearTimeout(this.checkScaleTimer), this.checkScaleTimer = void 0), !this.checkScaleTimer && l.scale === 1 / 0 && this.mainView.viewData && this.mainView.viewData.camera.scale === 1 / 0 && (this.checkScaleTimer = setTimeout(() => {
                var Z, o;
                (o = (Z = this.mainView) == null ? void 0 : Z.viewData) == null || o.moveCamera({ scale: t, centerX: s, centerY: b, animationMode: "immediately" }), this.checkScaleTimer = void 0;
              }, 500));
            }
          }
        });
      }
    }), Object.defineProperty(this, "onAppViewMounted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        var W;
        const { appId: i, view: t } = l, s = t.divElement;
        if (!s || !t.focusScenePath)
          return;
        const b = this.appViews.get(i);
        if (b && b.displayer) {
          const h = s.getElementsByClassName("teaching-aids-plugin-app-view-displayer");
          for (const r of h)
            r.remove();
          this.destroyAppView(l.appId, !0), (W = this.control.worker) == null || W.destroyViewWorker(i, !0);
        }
        const Z = new NW(i, this.control, sd.InternalMsgEmitter), o = t.size.width || Z.width, G = t.size.height || Z.height, X = {
          dpr: Z.dpr,
          originalPoint: [o / 2, G / 2],
          offscreenCanvasOpt: {
            ...Wd.defaultScreenCanvasOpt,
            width: o,
            height: G
          },
          layerOpt: {
            ...Wd.defaultLayerOpt,
            width: o,
            height: G
          },
          cameraOpt: {
            ...Wd.defaultCameraOpt,
            ...t.camera,
            width: o,
            height: G
          }
        };
        this.createAppView({
          id: i,
          container: s,
          displayer: Z,
          cameraOpt: X.cameraOpt,
          focusScenePath: t.focusScenePath,
          viewData: t
        }), Z.createAppViewDisplayer(i, s), t.callbacks.on("onSizeUpdated", this.onAppViewSizeUpdated.bind(this, i)), t.callbacks.on("onCameraUpdated", this.onAppViewCameraUpdated.bind(this, i)), t.callbacks.on("onActiveHotkey", this.onActiveHotkeyChange.bind(this)), this.tmpFocusedViewId === i && (this.setFocuedViewId(i), this.tmpFocusedViewId = void 0);
      }
    }), Object.defineProperty(this, "onAppViewSizeUpdated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (l) => {
        Promise.resolve().then(() => {
          const i = this.appViews.get(l);
          if (i && i.viewData) {
            const t = i.viewData.size, s = i.cameraOpt;
            s && (i.displayer.updateSize(), i.cameraOpt = { ...s, ...t });
          }
        });
      }
    }), Object.defineProperty(this, "onAppViewCameraUpdated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (l) => {
        Promise.resolve().then(() => {
          const i = this.appViews.get(l);
          if (i && i.viewData) {
            const t = i.viewData.camera, s = i.cameraOpt;
            if (s) {
              const b = t.scale === 1 / 0 ? 1 : t.scale, Z = t.centerX || 0, o = t.centerY || 0;
              i.cameraOpt = { ...s, scale: b, centerX: Z, centerY: o };
            }
          }
        });
      }
    }), this.control = d.control;
  }
  mountView(d) {
    var i, t;
    const l = this.getView(d);
    if (l) {
      const { width: s, height: b, dpr: Z } = l.displayer, o = {
        dpr: Z,
        originalPoint: [s / 2, b / 2],
        offscreenCanvasOpt: {
          ...Wd.defaultScreenCanvasOpt,
          width: s,
          height: b
        },
        layerOpt: {
          ...Wd.defaultLayerOpt,
          width: s,
          height: b
        },
        cameraOpt: {
          ...Wd.defaultCameraOpt,
          width: s,
          height: b
        }
      };
      if (l.viewData) {
        const { scale: G, ...y } = l.viewData.camera;
        o.cameraOpt = {
          ...o.cameraOpt,
          ...y,
          scale: G === 1 / 0 ? 1 : G
        };
      }
      d === ((i = this.mainView) == null ? void 0 : i.id) && this.control.activeWorker(), (t = this.control.worker) == null || t.createViewWorker(d, o), l.focusScenePath && this.control.collector && this.control.worker.pullServiceData(d, l.focusScenePath);
    }
  }
  setFocuedViewCameraOpt(d) {
    this.focuedView && (this.focuedView.cameraOpt = d);
  }
  listenerWindowManager(d) {
    d.emitter.on("boxStateChange", (l) => {
      l !== "minimized" && setTimeout(() => {
        this.appViews.forEach((i) => {
          i.displayer.reflashContainerOffset();
        });
      }, 100);
    }), d.emitter.on("focusedChange", (l) => {
      const i = l || od.viewId;
      if (this.focuedViewId !== i) {
        const t = this.getView(i);
        t ? (t.displayer.reflashContainerOffset(), this.setFocuedViewId(i)) : this.tmpFocusedViewId = i;
      }
    }), d.emitter.on("mainViewScenePathChange", (l) => {
      this.mainView && (this.mainView.focusScenePath = l);
    }), d.emitter.on("onMainViewMounted", this.onMainViewMounted), d.emitter.on("onAppViewMounted", this.onAppViewMounted), d.emitter.on("onMainViewRebind", this.onMainViewRelease), d.emitter.on("onBoxMove", (l) => {
      const i = this.getView(l.appId);
      i && i.displayer.reflashContainerOffset();
    }), d.emitter.on("onBoxResize", (l) => {
      const i = this.getView(l.appId);
      i && i.displayer.reflashContainerOffset();
    }), d.emitter.on("onBoxFocus", (l) => {
      const i = this.getView(l.appId);
      i && i.displayer.reflashContainerOffset();
    }), d.emitter.on("onBoxClose", (l) => {
      this.appViews.get(l.appId) && (this.destroyAppView(l.appId), this.control.worker.destroyViewWorker(l.appId));
    }), d.emitter.on("onBoxStateChange", (l) => {
      const i = this.getView(l.appId);
      i && i.displayer.reflashContainerOffset();
    }), d.emitter.on("onAppScenePathChange", (l) => {
      const { appId: i, view: t } = l, s = this.getView(i);
      if (s) {
        const b = t.focusScenePath;
        b && (s.focusScenePath = b);
      }
    });
  }
  transformToOriginPoint(d, l) {
    const i = this.getView(l);
    if (i != null && i.viewData) {
      const t = i.viewData.convertToPointOnScreen(d[0], d[1]);
      return [t.x, t.y];
    }
    return d;
  }
  transformToScenePoint(d, l) {
    const i = this.getView(l);
    if (i != null && i.viewData) {
      const t = i.viewData.convertToPointInWorld({ x: d[0], y: d[1] });
      return [t.x, t.y];
    }
    return d;
  }
  render(d) {
    var l, i, t, s, b, Z, o, G, y;
    for (const X of d) {
      const { rect: W, imageBitmap: h, isClear: r, isUnClose: L, drawCanvas: u, clearCanvas: V, offset: c, viewId: n } = X, e = (l = this.getView(n)) == null ? void 0 : l.displayer;
      if (e && W) {
        const { dpr: a, canvasBgRef: Y, canvasFloatRef: R, floatBarCanvasRef: C } = e, N = W.w * a, I = W.h * a, J = W.x * a, T = W.y * a;
        if (r)
          if (V === pd.Selector)
            (t = (i = C.current) == null ? void 0 : i.getContext("2d")) == null || t.clearRect(0, 0, N, I);
          else {
            const K = V === pd.Float ? (s = R.current) == null ? void 0 : s.getContext("2d") : (b = Y.current) == null ? void 0 : b.getContext("2d");
            K == null || K.clearRect(J, T, N, I);
          }
        if (u && h)
          if (u === pd.Selector) {
            const K = ((c == null ? void 0 : c.x) || 0) * a, S = ((c == null ? void 0 : c.y) || 0) * a;
            (o = (Z = C.current) == null ? void 0 : Z.getContext("2d")) == null || o.drawImage(h, 0, 0, N, I, K, S, N, I);
          } else {
            const K = u === pd.Float ? (G = R.current) == null ? void 0 : G.getContext("2d") : (y = Y.current) == null ? void 0 : y.getContext("2d");
            K == null || K.drawImage(h, 0, 0, N, I, J, T, N, I);
          }
        if (L)
          return;
        h == null || h.close();
      }
    }
  }
  onActiveHotkeyChange(d) {
    this.control.hotkeyManager.onActiveHotkey(d);
  }
}
class TW extends sd {
  constructor(d) {
    super(d), Object.defineProperty(this, "windowManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "viewContainerManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const l = {
      control: this,
      internalMsgEmitter: sd.InternalMsgEmitter
    };
    this.viewContainerManager = new Wd(l);
  }
  init() {
  }
  destroy() {
    var d, l, i, t;
    this.roomMember.destroy(), (d = this.collector) == null || d.destroy(), (l = this.worker) == null || l.destroy(), (i = this.viewContainerManager) == null || i.destroy(), (t = this.cursor) == null || t.destroy();
  }
  activePlugin() {
    this.collector && (this.collector.addStorageStateListener((d) => {
      var l, i;
      if ((l = this.collector) != null && l.storage && Object.keys(this.collector.storage).length === 0) {
        (i = this.worker) == null || i.clearViewScenePath("mainView", !0);
        return;
      }
      if (d) {
        const t = /* @__PURE__ */ new Map();
        Object.keys(d).forEach((s) => {
          var Z;
          const b = d[s];
          if (b) {
            const o = b.viewId, G = t.get(o) || /* @__PURE__ */ new Set();
            G.add(s), t.set(o, G), (Z = this.worker) == null || Z.onServiceDerive(s, b);
          }
        });
        for (const [s, b] of t.entries())
          sd.InternalMsgEmitter.emit("excludeIds", [...b], s);
      }
    }), this.room && this.roomMember.onUidChangeHook((d) => {
      var l, i, t, s;
      if ((l = this.collector) != null && l.serviceStorage) {
        const b = [];
        this.viewContainerManager.getAllViews().forEach((Z) => {
          var o;
          if (Z && Z.focusScenePath && ((o = this.collector) != null && o.serviceStorage[Z.id]) && this.collector.serviceStorage[Z.id][Z.focusScenePath]) {
            const G = Object.keys(this.collector.serviceStorage[Z.id][Z.focusScenePath]).filter((y) => {
              var X;
              return (X = this.collector) == null ? void 0 : X.isSelector(y);
            }).map((y) => ({ viewId: Z.id, scenePath: Z.focusScenePath, key: y }));
            G.length && b.push(...G);
          }
        }), b.forEach(({ key: Z, viewId: o, scenePath: G }) => {
          var X, W;
          const y = (X = this.collector) == null ? void 0 : X.getUidFromKey(Z);
          y && !d.online.includes(y) && ((W = this.collector) == null || W.updateValue(Z, void 0, { isAfterUpdate: !0, viewId: o, scenePath: G }));
        });
      }
      (t = (i = this.cursor) == null ? void 0 : i.eventCollector) != null && t.serviceStorage && Object.keys((s = this.cursor) == null ? void 0 : s.eventCollector.serviceStorage).forEach((Z) => {
        var o, G;
        d.online.includes(Z) || (G = (o = this.cursor) == null ? void 0 : o.eventCollector) == null || G.clearValue(Z);
      });
    }), this.worker.isActive && this.viewContainerManager.getAllViews().forEach((d) => {
      d && d.focusScenePath && this.worker.pullServiceData(d.id, d.focusScenePath);
    }));
  }
  activeWorker() {
    this.worker.init();
  }
  setWindowManager(d) {
    var l, i, t, s;
    this.windowManager = d, (l = this.windowManager) != null && l.mainView && this.viewContainerManager.onMainViewMounted(this.windowManager.mainView), (s = (t = (i = this.windowManager.appManager) == null ? void 0 : i.viewManager) == null ? void 0 : t.views) != null && s.size && this.windowManager.appManager.viewManager.views.forEach((b, Z) => {
      this.viewContainerManager.onAppViewMounted({ appId: Z, view: b });
    }), this.viewContainerManager.listenerWindowManager(this.windowManager);
  }
}
class Ll extends Ss {
  constructor() {
    super(...arguments), Object.defineProperty(this, "updateRoomWritable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        var d;
        (d = Ll.currentManager) == null || d.onWritableChange(this.displayer.isWritable);
      }
    }), Object.defineProperty(this, "roomStateChangeListener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (d) => {
        var l, i;
        Ll.currentManager instanceof yd && (d.cameraState && Ll.currentManager.onCameraChange(d.cameraState), d.sceneState && Ll.currentManager.onSceneChange(d.sceneState.scenePath, "mainView")), !(cd(this.displayer) && !this.displayer.isWritable) && (d.memberState && ((l = Ll.currentManager) == null || l.onMemberChange(d.memberState)), d != null && d.roomMembers && ((i = Ll.currentManager) == null || i.onRoomMembersChange(d.roomMembers)));
      }
    });
  }
  static async getInstance(d, l) {
    const i = d instanceof Ns;
    Ll.windowManager = i && d || void 0, l != null && l.logger && (Ll.logger = l.logger), l != null && l.options && (Ll.options = l.options), l != null && l.cursorAdapter && (Ll.cursorAdapter = l.cursorAdapter, Ll.effectInstance());
    const t = i ? d.displayer : d;
    let s = t.getInvisiblePlugin(Ll.kind);
    t && Ll.createCurrentManager(t, Ll.options, s, Ll.windowManager), !s && cd(t) && (s = await Ll.createTeachingAidsPlugin(t, Ll.kind)), s && Ll.currentManager && (Ll.currentManager.bindPlugin(s), s.init(t));
    const b = {
      plugin: s,
      displayer: t,
      windowManager: i && d || void 0,
      getBoundingRectAsync: async function(Z) {
        var y;
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] getBoundingRect");
        const o = (this.windowManager && this.windowManager.mainView || this.displayer).getBoundingRect(Z), G = await ((y = Ll.currentManager) == null ? void 0 : y.getBoundingRect(Z));
        return !o.width || !o.height ? G : rX(o, G);
      },
      screenshotToCanvasAsync: async function(Z, o, G, y, X, W) {
        var L;
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] screenshotToCanvasAsync");
        const h = document.createElement("canvas"), r = h.getContext("2d");
        h.width = G * (W || 1), h.height = y * (W || 1), r && ((this.windowManager && this.windowManager.mainView || this.displayer).screenshotToCanvas(r, o, G, y, X, W), Z.drawImage(h, 0, 0, G * (W || 1), y * (W || 1), 0, 0, G, y), h.remove()), Ll.currentManager && await ((L = Ll.currentManager) == null ? void 0 : L.screenshotToCanvas(Z, o, G, y, X));
      },
      scenePreviewAsync: async function(Z, o, G, y, X) {
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] scenePreview"), (this.windowManager && this.windowManager.mainView || this.displayer).scenePreview(Z, o, G, y, X);
        const W = document.createElement("img");
        W.style.position = "absolute", W.style.top = "0px", W.style.left = "0px", W.style.width = "100%", W.style.height = "100%", W.style.pointerEvents = "none", o.append(W), getComputedStyle(o).position || (o.style.position = "relative"), Ll.currentManager && await Ll.currentManager.scenePreview(Z, W);
      },
      callbacksOn: function(Z, o) {
        Ll.logger.info(`[TeachingAidsSinglePlugin plugin] callbacks ${Z}`), (Z === "onCanUndoStepsUpdate" || Z === "onCanRedoStepsUpdate") && cd(this.displayer) && this.displayer.isWritable ? yd.InternalMsgEmitter.on(Z, o) : this.displayer.callbacks.on(Z, o);
      },
      callbacksOnce: function(Z, o) {
        Ll.logger.info(`[TeachingAidsSinglePlugin plugin] callbacks ${Z}`), (Z === "onCanUndoStepsUpdate" || Z === "onCanRedoStepsUpdate") && cd(this.displayer) && this.displayer.isWritable ? yd.InternalMsgEmitter.on(Z, o) : this.displayer.callbacks.on(Z, o);
      },
      callbacksOff: function(Z, o) {
        Ll.logger.info(`[TeachingAidsSinglePlugin plugin] callbacks ${Z}`), (Z === "onCanUndoStepsUpdate" || Z === "onCanRedoStepsUpdate") && cd(this.displayer) && this.displayer.isWritable ? yd.InternalMsgEmitter.off(Z, o) : this.displayer.callbacks.off(Z, o);
      },
      undo: function() {
        return Ll.logger.info("[TeachingAidsSinglePlugin plugin] undo"), Ll.currentManager && cd(this.displayer) && !this.displayer.disableSerialization ? Ll.currentManager.viewContainerManager.undo() : 0;
      },
      redo: function() {
        return Ll.logger.info("[TeachingAidsSinglePlugin plugin] redo"), Ll.currentManager && cd(this.displayer) && !this.displayer.disableSerialization ? Ll.currentManager.viewContainerManager.redo() : 0;
      },
      cleanCurrentScene: function(Z) {
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] cleanCurrentScene"), Ll.currentManager && cd(this.displayer) && this.displayer.isWritable && (Ll.currentManager.cleanCurrentScene(), this.displayer.cleanCurrentScene(Z));
      },
      insertImage: function(Z) {
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] insertImage"), Ll.currentManager && cd(this.displayer) && this.displayer.isWritable && Ll.currentManager.worker.insertImage(Z);
      },
      lockImage: function(Z, o) {
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] lockImage"), Ll.currentManager && cd(this.displayer) && this.displayer.isWritable && Ll.currentManager.worker.lockImage(Z, o);
      },
      completeImageUpload: function(Z, o) {
        Ll.logger.info("[TeachingAidsSinglePlugin plugin] completeImageUpload"), Ll.currentManager && cd(this.displayer) && this.displayer.isWritable && Ll.currentManager.worker.completeImageUpload(Z, o);
      },
      getImagesInformation: function(Z) {
        return Ll.logger.info("[TeachingAidsSinglePlugin plugin] completeImageUpload"), Ll.currentManager && cd(this.displayer) && this.displayer.isWritable ? Ll.currentManager.worker.getImagesInformation(Z) : [];
      }
    };
    return {
      ...b,
      callbacks: {
        on: b.callbacksOn.bind(b),
        once: b.callbacksOnce.bind(b),
        off: b.callbacksOff.bind(b),
        forwardTo: b.displayer.callbacks.forwardTo
      }
    };
  }
  static onCreate(d) {
    d && Ll.currentManager && (Ll.currentManager.bindPlugin(d), d.init(d.displayer));
  }
  static async createTeachingAidsPlugin(d, l) {
    await d.createInvisiblePlugin(Ll, {});
    let i = d.getInvisiblePlugin(l);
    return i || (i = await Ll.createTeachingAidsPlugin(d, l)), i;
  }
  // static onDestroy(plugin: TeachingAidsPlugin) {}
  /**
   * 房间实例化时，将当前实例对displayer外部API的添加内部处理逻辑;
   * @param displayer
   */
  static effectInstance() {
    if (Ll.cursorAdapter) {
      if (Ll.options && Ll.windowManager) {
        Ll.logger.warn("[TeachingAidsPlugin plugin] cursorAdapter is Invalid configuration data in MultiView");
        return;
      }
      const d = Ll.cursorAdapter.onAddedCursor;
      Ll.cursorAdapter.onAddedCursor = function(l) {
        l.onCursorMemberChanged = (i) => {
          try {
            i.appliance === Tl.pencil || i.appliance === Tl.shape || i.appliance === Tl.text || i.appliance === Tl.arrow || i.appliance === Tl.straight || i.appliance === Tl.rectangle || i.appliance === Tl.ellipse ? l != null && l.divElement && (l.divElement.style.display = "none") : l != null && l.divElement && (l.divElement.style.display = "block");
          } catch {
          }
        }, d.call(Ll.cursorAdapter, l);
      };
    }
  }
  get isReplay() {
    return ft(this.displayer);
  }
  get callbackName() {
    return this.isReplay ? "onPlayerStateChanged" : "onRoomStateChanged";
  }
  init(d) {
    var l;
    if (cd(d)) {
      const i = d.state;
      i != null && i.memberState && ((l = Ll.currentManager) == null || l.onMemberChange(i.memberState));
    }
    this.displayer.callbacks.on(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.on("onEnableWriteNowChanged", this.updateRoomWritable);
  }
  destroy() {
    var d;
    console.log("currentManager--destroy -- 1"), (d = Ll.currentManager) == null || d.destroy(), Ll.currentManager = void 0, Ll.windowManager = void 0, Ll.cursorAdapter = void 0;
  }
}
Object.defineProperty(Ll, "kind", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "teaching-aids-plugin"
});
Object.defineProperty(Ll, "logger", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    info: console.log,
    warn: console.warn,
    error: console.error
  }
});
Object.defineProperty(Ll, "options", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    syncOpt: {
      interval: 300
    },
    canvasOpt: {
      contextType: ii.Canvas2d
    }
  }
});
Object.defineProperty(Ll, "createCurrentManager", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: (m, d, l, i) => {
    Ll.currentManager && Ll.currentManager.destroy();
    let t;
    const s = {
      plugin: l,
      displayer: m,
      options: d
    };
    d && i ? (t = new TW(s), Ll.logger.info("[TeachingAidsPlugin plugin] refresh TeachingAidsMultiManager object"), t.setWindowManager(i)) : (t = new yd(s), t.init(), Ll.logger.info("[TeachingAidsPlugin plugin] refresh TeachingAidsSingleManager object")), Ll.currentManager = t;
  }
});
export {
  ii as ECanvasContextType,
  Ll as TeachingAidsPlugin,
  Ed as TeachingAidsSigleWrapper
};
