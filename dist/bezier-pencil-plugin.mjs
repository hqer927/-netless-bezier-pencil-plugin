import { decompress as fs, compress as ws } from "lz-string";
import "lineclip";
import { toJS as li, autorun as Es, ApplianceNames as ed, isRoom as $l, isPlayer as es, InvisiblePlugin as js, RoomPhase as Bs } from "white-web-sdk";
import { setValue as Os, val as Ds } from "value-enhancer";
import Vl, { useContext as td, useState as sd, useMemo as Rd, useEffect as Hd } from "react";
import di from "react-draggable";
import As, { EventEmitter2 as qs } from "eventemitter2";
import { debounce as $s, isEqual as _s, cloneDeep as lt } from "lodash";
import { Resizable as dt } from "re-resizable";
var od;
(function(Z) {
  Z[Z.pedding = 0] = "pedding", Z[Z.mounted = 1] = "mounted", Z[Z.update = 2] = "update", Z[Z.unmounted = 3] = "unmounted";
})(od || (od = {}));
var _l;
(function(Z) {
  Z[Z.Normal = 0] = "Normal", Z[Z.Stroke = 1] = "Stroke", Z[Z.Dotted = 2] = "Dotted", Z[Z.LongDotted = 3] = "LongDotted";
})(_l || (_l = {}));
var ul;
(function(Z) {
  Z.ShowFloatBar = "ShowFloatBar", Z.ZIndexFloatBar = "ZIndexFloatBar", Z.DeleteNode = "DeleteNode", Z.CopyNode = "CopyNode", Z.ZIndexActive = "ZIndexActive", Z.ZIndexNode = "ZIndexNode", Z.RotateNode = "RotateNode", Z.SetColorNode = "SetColorNode", Z.TranslateNode = "TranslateNode", Z.ScaleNode = "ScaleNode", Z.OriginalEvent = "OriginalEvent", Z.CreateScene = "createScene";
})(ul || (ul = {}));
var pl;
(function(Z) {
  Z.DisplayState = "DisplayState", Z.FloatBar = "FloatBar", Z.CanvasSelector = "CanvasSelector", Z.MainEngine = "MainEngine", Z.DisplayContainer = "DisplayContainer";
})(pl || (pl = {}));
var Jl;
(function(Z) {
  Z[Z.Pencil = 1] = "Pencil", Z[Z.Eraser = 2] = "Eraser", Z[Z.Selector = 3] = "Selector", Z[Z.Clicker = 4] = "Clicker", Z[Z.Arrow = 5] = "Arrow", Z[Z.Hand = 6] = "Hand", Z[Z.LaserPen = 7] = "LaserPen";
})(Jl || (Jl = {}));
var Vi;
(function(Z) {
  Z[Z.Path = 0] = "Path", Z[Z.Rect = 1] = "Rect";
})(Vi || (Vi = {}));
var Fl;
(function(Z) {
  Z[Z.Local = 1] = "Local", Z[Z.Service = 2] = "Service";
})(Fl || (Fl = {}));
var Ll;
(function(Z) {
  Z[Z.Pending = 0] = "Pending", Z[Z.Start = 1] = "Start", Z[Z.Doing = 2] = "Doing", Z[Z.Done = 3] = "Done", Z[Z.Freeze = 4] = "Freeze", Z[Z.Unwritable = 5] = "Unwritable";
})(Ll || (Ll = {}));
var hl;
(function(Z) {
  Z[Z.Init = 0] = "Init", Z[Z.UpdateCamera = 1] = "UpdateCamera", Z[Z.UpdateTools = 2] = "UpdateTools", Z[Z.CreateWork = 3] = "CreateWork", Z[Z.DrawWork = 4] = "DrawWork", Z[Z.FullWork = 5] = "FullWork", Z[Z.UpdateNode = 6] = "UpdateNode", Z[Z.RemoveNode = 7] = "RemoveNode", Z[Z.Clear = 8] = "Clear", Z[Z.Select = 9] = "Select", Z[Z.Destroy = 10] = "Destroy", Z[Z.None = 11] = "None", Z[Z.Snapshot = 12] = "Snapshot";
})(hl || (hl = {}));
var hi;
(function(Z) {
  Z[Z.Path = 0] = "Path", Z[Z.Rect = 1] = "Rect", Z[Z.Texture = 2] = "Texture";
})(hi || (hi = {}));
var Od;
(function(Z) {
  Z.Webgl2 = "webgl2", Z.Webgl = "webgl", Z.Canvas2d = "2d";
})(Od || (Od = {}));
var ad;
(function(Z) {
  Z[Z.Float = 1] = "Float", Z[Z.Bg = 2] = "Bg", Z[Z.Selector = 3] = "Selector", Z[Z.None = 4] = "None";
})(ad || (ad = {}));
var Ii;
(function(Z) {
  Z.LT = "topLeft", Z.LC = "left", Z.LB = "bottomLeft", Z.TC = "top", Z.RT = "topRight", Z.RC = "right", Z.RB = "bottomRight", Z.BC = "bottom";
})(Ii || (Ii = {}));
class it {
  constructor(d, l) {
    Object.defineProperty(this, "syncUnitTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1e3
    }), Object.defineProperty(this, "drawLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fullLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.fullLayer = d, this.drawLayer = l;
  }
  setWorkId(d) {
    this.workId = d;
  }
  getWorkId() {
    return this.workId;
  }
  getWorkOptions() {
    return this.workOptions;
  }
  setWorkOptions(d) {
    this.workOptions = d, this.syncUnitTime = d.syncUnitTime || this.syncUnitTime;
  }
}
var Nl = (
  /******/
  function(Z) {
    var d = {};
    function l(s) {
      if (d[s])
        return d[s].exports;
      var c = d[s] = {
        /******/
        i: s,
        /******/
        l: !1,
        /******/
        exports: {}
        /******/
      };
      return Z[s].call(c.exports, c, c.exports, l), c.l = !0, c.exports;
    }
    return l.m = Z, l.c = d, l.d = function(s, c, W) {
      l.o(s, c) || Object.defineProperty(s, c, { enumerable: !0, get: W });
    }, l.r = function(s) {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(s, "__esModule", { value: !0 });
    }, l.t = function(s, c) {
      if (c & 1 && (s = l(s)), c & 8 || c & 4 && typeof s == "object" && s && s.__esModule)
        return s;
      var W = /* @__PURE__ */ Object.create(null);
      if (l.r(W), Object.defineProperty(W, "default", { enumerable: !0, value: s }), c & 2 && typeof s != "string")
        for (var u in s)
          l.d(W, u, (function(e) {
            return s[e];
          }).bind(null, u));
      return W;
    }, l.n = function(s) {
      var c = s && s.__esModule ? (
        /******/
        function() {
          return s.default;
        }
      ) : (
        /******/
        function() {
          return s;
        }
      );
      return l.d(c, "a", c), c;
    }, l.o = function(s, c) {
      return Object.prototype.hasOwnProperty.call(s, c);
    }, l.p = "/js/", l(l.s = 0);
  }([
    /* 0 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "version", function() {
        return w;
      }), l.d(d, "helpers", function() {
        return H;
      }), l.d(d, "createElement", function() {
        return F;
      }), l.d(d, "isSpriteNode", function() {
        return r;
      }), l.d(d, "registerNode", function() {
        return Y;
      });
      var s = l(12);
      l.d(d, "ENV", function() {
        return s.ENV;
      });
      var c = l(68);
      l.d(d, "requestAnimationFrame", function() {
        return c.requestAnimationFrame;
      }), l.d(d, "cancelAnimationFrame", function() {
        return c.cancelAnimationFrame;
      });
      var W = l(70);
      l.d(d, "Node", function() {
        return W.default;
      });
      var u = l(217);
      l.d(d, "Cloud", function() {
        return u.default;
      });
      var e = l(219);
      l.d(d, "Block", function() {
        return e.default;
      });
      var n = l(224);
      l.d(d, "Sprite", function() {
        return n.default;
      });
      var G = l(226);
      l.d(d, "Path", function() {
        return G.default;
      });
      var y = l(229);
      l.d(d, "Rect", function() {
        return y.default;
      });
      var a = l(231);
      l.d(d, "Triangle", function() {
        return a.default;
      });
      var I = l(236);
      l.d(d, "Parallel", function() {
        return I.default;
      });
      var h = l(238);
      l.d(d, "Regular", function() {
        return h.default;
      });
      var S = l(240);
      l.d(d, "Star", function() {
        return S.default;
      });
      var p = l(242);
      l.d(d, "Ellipse", function() {
        return p.default;
      });
      var X = l(244);
      l.d(d, "Arc", function() {
        return X.default;
      });
      var V = l(246);
      l.d(d, "Ring", function() {
        return V.default;
      });
      var i = l(232);
      l.d(d, "Polyline", function() {
        return i.default;
      });
      var b = l(248);
      l.d(d, "Label", function() {
        return b.default;
      });
      var t = l(250);
      l.d(d, "Group", function() {
        return t.default;
      });
      var m = l(286);
      l.d(d, "Layer", function() {
        return m.default;
      });
      var R = l(287);
      l.d(d, "SpriteSvg", function() {
        return R.default;
      });
      var x = l(289);
      l.d(d, "LayerWorker", function() {
        return x.default;
      });
      var C = l(290);
      l.d(d, "Scene", function() {
        return C.default;
      });
      var T = l(213), K = l(221);
      l.d(d, "Color", function() {
        return K.Color;
      }), l.d(d, "Gradient", function() {
        return K.Gradient;
      });
      var J = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const F = T.default.createElement, r = T.default.isSpriteNode, Y = T.default.registerNode, H = {
        parseColor: K.parseColor,
        sizeToPixel: J.sizeToPixel,
        toArray: J.toArray,
        toString: J.toString,
        toNumber: J.toNumber
      };
      let Q;
      Q = "3.8.3";
      const w = Q;
    },
    /* 1 */
    /***/
    function(Z, d, l) {
      l.r(d);
      var s = l(2);
      l.d(d, "glMatrix", function() {
        return s;
      });
      var c = l(3);
      l.d(d, "mat2", function() {
        return c;
      });
      var W = l(4);
      l.d(d, "mat2d", function() {
        return W;
      });
      var u = l(5);
      l.d(d, "mat3", function() {
        return u;
      });
      var e = l(6);
      l.d(d, "mat4", function() {
        return e;
      });
      var n = l(7);
      l.d(d, "quat", function() {
        return n;
      });
      var G = l(10);
      l.d(d, "quat2", function() {
        return G;
      });
      var y = l(11);
      l.d(d, "vec2", function() {
        return y;
      });
      var a = l(8);
      l.d(d, "vec3", function() {
        return a;
      });
      var I = l(9);
      l.d(d, "vec4", function() {
        return I;
      });
    },
    /* 2 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "EPSILON", function() {
        return s;
      }), l.d(d, "ARRAY_TYPE", function() {
        return c;
      }), l.d(d, "RANDOM", function() {
        return W;
      }), l.d(d, "setMatrixArrayType", function() {
        return u;
      }), l.d(d, "toRadian", function() {
        return n;
      }), l.d(d, "equals", function() {
        return G;
      });
      var s = 1e-6, c = typeof Float32Array < "u" ? Float32Array : Array, W = Math.random;
      function u(y) {
        c = y;
      }
      var e = Math.PI / 180;
      function n(y) {
        return y * e;
      }
      function G(y, a) {
        return Math.abs(y - a) <= s * Math.max(1, Math.abs(y), Math.abs(a));
      }
      Math.hypot || (Math.hypot = function() {
        for (var y = 0, a = arguments.length; a--; )
          y += arguments[a] * arguments[a];
        return Math.sqrt(y);
      });
    },
    /* 3 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return c;
      }), l.d(d, "clone", function() {
        return W;
      }), l.d(d, "copy", function() {
        return u;
      }), l.d(d, "identity", function() {
        return e;
      }), l.d(d, "fromValues", function() {
        return n;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "transpose", function() {
        return y;
      }), l.d(d, "invert", function() {
        return a;
      }), l.d(d, "adjoint", function() {
        return I;
      }), l.d(d, "determinant", function() {
        return h;
      }), l.d(d, "multiply", function() {
        return S;
      }), l.d(d, "rotate", function() {
        return p;
      }), l.d(d, "scale", function() {
        return X;
      }), l.d(d, "fromRotation", function() {
        return V;
      }), l.d(d, "fromScaling", function() {
        return i;
      }), l.d(d, "str", function() {
        return b;
      }), l.d(d, "frob", function() {
        return t;
      }), l.d(d, "LDU", function() {
        return m;
      }), l.d(d, "add", function() {
        return R;
      }), l.d(d, "subtract", function() {
        return x;
      }), l.d(d, "exactEquals", function() {
        return C;
      }), l.d(d, "equals", function() {
        return T;
      }), l.d(d, "multiplyScalar", function() {
        return K;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return J;
      }), l.d(d, "mul", function() {
        return F;
      }), l.d(d, "sub", function() {
        return r;
      });
      var s = l(2);
      function c() {
        var Y = new s.ARRAY_TYPE(4);
        return s.ARRAY_TYPE != Float32Array && (Y[1] = 0, Y[2] = 0), Y[0] = 1, Y[3] = 1, Y;
      }
      function W(Y) {
        var H = new s.ARRAY_TYPE(4);
        return H[0] = Y[0], H[1] = Y[1], H[2] = Y[2], H[3] = Y[3], H;
      }
      function u(Y, H) {
        return Y[0] = H[0], Y[1] = H[1], Y[2] = H[2], Y[3] = H[3], Y;
      }
      function e(Y) {
        return Y[0] = 1, Y[1] = 0, Y[2] = 0, Y[3] = 1, Y;
      }
      function n(Y, H, Q, w) {
        var O = new s.ARRAY_TYPE(4);
        return O[0] = Y, O[1] = H, O[2] = Q, O[3] = w, O;
      }
      function G(Y, H, Q, w, O) {
        return Y[0] = H, Y[1] = Q, Y[2] = w, Y[3] = O, Y;
      }
      function y(Y, H) {
        if (Y === H) {
          var Q = H[1];
          Y[1] = H[2], Y[2] = Q;
        } else
          Y[0] = H[0], Y[1] = H[2], Y[2] = H[1], Y[3] = H[3];
        return Y;
      }
      function a(Y, H) {
        var Q = H[0], w = H[1], O = H[2], q = H[3], k = Q * q - O * w;
        return k ? (k = 1 / k, Y[0] = q * k, Y[1] = -w * k, Y[2] = -O * k, Y[3] = Q * k, Y) : null;
      }
      function I(Y, H) {
        var Q = H[0];
        return Y[0] = H[3], Y[1] = -H[1], Y[2] = -H[2], Y[3] = Q, Y;
      }
      function h(Y) {
        return Y[0] * Y[3] - Y[2] * Y[1];
      }
      function S(Y, H, Q) {
        var w = H[0], O = H[1], q = H[2], k = H[3], P = Q[0], D = Q[1], ll = Q[2], _ = Q[3];
        return Y[0] = w * P + q * D, Y[1] = O * P + k * D, Y[2] = w * ll + q * _, Y[3] = O * ll + k * _, Y;
      }
      function p(Y, H, Q) {
        var w = H[0], O = H[1], q = H[2], k = H[3], P = Math.sin(Q), D = Math.cos(Q);
        return Y[0] = w * D + q * P, Y[1] = O * D + k * P, Y[2] = w * -P + q * D, Y[3] = O * -P + k * D, Y;
      }
      function X(Y, H, Q) {
        var w = H[0], O = H[1], q = H[2], k = H[3], P = Q[0], D = Q[1];
        return Y[0] = w * P, Y[1] = O * P, Y[2] = q * D, Y[3] = k * D, Y;
      }
      function V(Y, H) {
        var Q = Math.sin(H), w = Math.cos(H);
        return Y[0] = w, Y[1] = Q, Y[2] = -Q, Y[3] = w, Y;
      }
      function i(Y, H) {
        return Y[0] = H[0], Y[1] = 0, Y[2] = 0, Y[3] = H[1], Y;
      }
      function b(Y) {
        return "mat2(" + Y[0] + ", " + Y[1] + ", " + Y[2] + ", " + Y[3] + ")";
      }
      function t(Y) {
        return Math.hypot(Y[0], Y[1], Y[2], Y[3]);
      }
      function m(Y, H, Q, w) {
        return Y[2] = w[2] / w[0], Q[0] = w[0], Q[1] = w[1], Q[3] = w[3] - Y[2] * Q[1], [Y, H, Q];
      }
      function R(Y, H, Q) {
        return Y[0] = H[0] + Q[0], Y[1] = H[1] + Q[1], Y[2] = H[2] + Q[2], Y[3] = H[3] + Q[3], Y;
      }
      function x(Y, H, Q) {
        return Y[0] = H[0] - Q[0], Y[1] = H[1] - Q[1], Y[2] = H[2] - Q[2], Y[3] = H[3] - Q[3], Y;
      }
      function C(Y, H) {
        return Y[0] === H[0] && Y[1] === H[1] && Y[2] === H[2] && Y[3] === H[3];
      }
      function T(Y, H) {
        var Q = Y[0], w = Y[1], O = Y[2], q = Y[3], k = H[0], P = H[1], D = H[2], ll = H[3];
        return Math.abs(Q - k) <= s.EPSILON * Math.max(1, Math.abs(Q), Math.abs(k)) && Math.abs(w - P) <= s.EPSILON * Math.max(1, Math.abs(w), Math.abs(P)) && Math.abs(O - D) <= s.EPSILON * Math.max(1, Math.abs(O), Math.abs(D)) && Math.abs(q - ll) <= s.EPSILON * Math.max(1, Math.abs(q), Math.abs(ll));
      }
      function K(Y, H, Q) {
        return Y[0] = H[0] * Q, Y[1] = H[1] * Q, Y[2] = H[2] * Q, Y[3] = H[3] * Q, Y;
      }
      function J(Y, H, Q, w) {
        return Y[0] = H[0] + Q[0] * w, Y[1] = H[1] + Q[1] * w, Y[2] = H[2] + Q[2] * w, Y[3] = H[3] + Q[3] * w, Y;
      }
      var F = S, r = x;
    },
    /* 4 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return c;
      }), l.d(d, "clone", function() {
        return W;
      }), l.d(d, "copy", function() {
        return u;
      }), l.d(d, "identity", function() {
        return e;
      }), l.d(d, "fromValues", function() {
        return n;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "invert", function() {
        return y;
      }), l.d(d, "determinant", function() {
        return a;
      }), l.d(d, "multiply", function() {
        return I;
      }), l.d(d, "rotate", function() {
        return h;
      }), l.d(d, "scale", function() {
        return S;
      }), l.d(d, "translate", function() {
        return p;
      }), l.d(d, "fromRotation", function() {
        return X;
      }), l.d(d, "fromScaling", function() {
        return V;
      }), l.d(d, "fromTranslation", function() {
        return i;
      }), l.d(d, "str", function() {
        return b;
      }), l.d(d, "frob", function() {
        return t;
      }), l.d(d, "add", function() {
        return m;
      }), l.d(d, "subtract", function() {
        return R;
      }), l.d(d, "multiplyScalar", function() {
        return x;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return C;
      }), l.d(d, "exactEquals", function() {
        return T;
      }), l.d(d, "equals", function() {
        return K;
      }), l.d(d, "mul", function() {
        return J;
      }), l.d(d, "sub", function() {
        return F;
      });
      var s = l(2);
      function c() {
        var r = new s.ARRAY_TYPE(6);
        return s.ARRAY_TYPE != Float32Array && (r[1] = 0, r[2] = 0, r[4] = 0, r[5] = 0), r[0] = 1, r[3] = 1, r;
      }
      function W(r) {
        var Y = new s.ARRAY_TYPE(6);
        return Y[0] = r[0], Y[1] = r[1], Y[2] = r[2], Y[3] = r[3], Y[4] = r[4], Y[5] = r[5], Y;
      }
      function u(r, Y) {
        return r[0] = Y[0], r[1] = Y[1], r[2] = Y[2], r[3] = Y[3], r[4] = Y[4], r[5] = Y[5], r;
      }
      function e(r) {
        return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r;
      }
      function n(r, Y, H, Q, w, O) {
        var q = new s.ARRAY_TYPE(6);
        return q[0] = r, q[1] = Y, q[2] = H, q[3] = Q, q[4] = w, q[5] = O, q;
      }
      function G(r, Y, H, Q, w, O, q) {
        return r[0] = Y, r[1] = H, r[2] = Q, r[3] = w, r[4] = O, r[5] = q, r;
      }
      function y(r, Y) {
        var H = Y[0], Q = Y[1], w = Y[2], O = Y[3], q = Y[4], k = Y[5], P = H * O - Q * w;
        return P ? (P = 1 / P, r[0] = O * P, r[1] = -Q * P, r[2] = -w * P, r[3] = H * P, r[4] = (w * k - O * q) * P, r[5] = (Q * q - H * k) * P, r) : null;
      }
      function a(r) {
        return r[0] * r[3] - r[1] * r[2];
      }
      function I(r, Y, H) {
        var Q = Y[0], w = Y[1], O = Y[2], q = Y[3], k = Y[4], P = Y[5], D = H[0], ll = H[1], _ = H[2], bl = H[3], $ = H[4], el = H[5];
        return r[0] = Q * D + O * ll, r[1] = w * D + q * ll, r[2] = Q * _ + O * bl, r[3] = w * _ + q * bl, r[4] = Q * $ + O * el + k, r[5] = w * $ + q * el + P, r;
      }
      function h(r, Y, H) {
        var Q = Y[0], w = Y[1], O = Y[2], q = Y[3], k = Y[4], P = Y[5], D = Math.sin(H), ll = Math.cos(H);
        return r[0] = Q * ll + O * D, r[1] = w * ll + q * D, r[2] = Q * -D + O * ll, r[3] = w * -D + q * ll, r[4] = k, r[5] = P, r;
      }
      function S(r, Y, H) {
        var Q = Y[0], w = Y[1], O = Y[2], q = Y[3], k = Y[4], P = Y[5], D = H[0], ll = H[1];
        return r[0] = Q * D, r[1] = w * D, r[2] = O * ll, r[3] = q * ll, r[4] = k, r[5] = P, r;
      }
      function p(r, Y, H) {
        var Q = Y[0], w = Y[1], O = Y[2], q = Y[3], k = Y[4], P = Y[5], D = H[0], ll = H[1];
        return r[0] = Q, r[1] = w, r[2] = O, r[3] = q, r[4] = Q * D + O * ll + k, r[5] = w * D + q * ll + P, r;
      }
      function X(r, Y) {
        var H = Math.sin(Y), Q = Math.cos(Y);
        return r[0] = Q, r[1] = H, r[2] = -H, r[3] = Q, r[4] = 0, r[5] = 0, r;
      }
      function V(r, Y) {
        return r[0] = Y[0], r[1] = 0, r[2] = 0, r[3] = Y[1], r[4] = 0, r[5] = 0, r;
      }
      function i(r, Y) {
        return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = Y[0], r[5] = Y[1], r;
      }
      function b(r) {
        return "mat2d(" + r[0] + ", " + r[1] + ", " + r[2] + ", " + r[3] + ", " + r[4] + ", " + r[5] + ")";
      }
      function t(r) {
        return Math.hypot(r[0], r[1], r[2], r[3], r[4], r[5], 1);
      }
      function m(r, Y, H) {
        return r[0] = Y[0] + H[0], r[1] = Y[1] + H[1], r[2] = Y[2] + H[2], r[3] = Y[3] + H[3], r[4] = Y[4] + H[4], r[5] = Y[5] + H[5], r;
      }
      function R(r, Y, H) {
        return r[0] = Y[0] - H[0], r[1] = Y[1] - H[1], r[2] = Y[2] - H[2], r[3] = Y[3] - H[3], r[4] = Y[4] - H[4], r[5] = Y[5] - H[5], r;
      }
      function x(r, Y, H) {
        return r[0] = Y[0] * H, r[1] = Y[1] * H, r[2] = Y[2] * H, r[3] = Y[3] * H, r[4] = Y[4] * H, r[5] = Y[5] * H, r;
      }
      function C(r, Y, H, Q) {
        return r[0] = Y[0] + H[0] * Q, r[1] = Y[1] + H[1] * Q, r[2] = Y[2] + H[2] * Q, r[3] = Y[3] + H[3] * Q, r[4] = Y[4] + H[4] * Q, r[5] = Y[5] + H[5] * Q, r;
      }
      function T(r, Y) {
        return r[0] === Y[0] && r[1] === Y[1] && r[2] === Y[2] && r[3] === Y[3] && r[4] === Y[4] && r[5] === Y[5];
      }
      function K(r, Y) {
        var H = r[0], Q = r[1], w = r[2], O = r[3], q = r[4], k = r[5], P = Y[0], D = Y[1], ll = Y[2], _ = Y[3], bl = Y[4], $ = Y[5];
        return Math.abs(H - P) <= s.EPSILON * Math.max(1, Math.abs(H), Math.abs(P)) && Math.abs(Q - D) <= s.EPSILON * Math.max(1, Math.abs(Q), Math.abs(D)) && Math.abs(w - ll) <= s.EPSILON * Math.max(1, Math.abs(w), Math.abs(ll)) && Math.abs(O - _) <= s.EPSILON * Math.max(1, Math.abs(O), Math.abs(_)) && Math.abs(q - bl) <= s.EPSILON * Math.max(1, Math.abs(q), Math.abs(bl)) && Math.abs(k - $) <= s.EPSILON * Math.max(1, Math.abs(k), Math.abs($));
      }
      var J = I, F = R;
    },
    /* 5 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return c;
      }), l.d(d, "fromMat4", function() {
        return W;
      }), l.d(d, "clone", function() {
        return u;
      }), l.d(d, "copy", function() {
        return e;
      }), l.d(d, "fromValues", function() {
        return n;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "identity", function() {
        return y;
      }), l.d(d, "transpose", function() {
        return a;
      }), l.d(d, "invert", function() {
        return I;
      }), l.d(d, "adjoint", function() {
        return h;
      }), l.d(d, "determinant", function() {
        return S;
      }), l.d(d, "multiply", function() {
        return p;
      }), l.d(d, "translate", function() {
        return X;
      }), l.d(d, "rotate", function() {
        return V;
      }), l.d(d, "scale", function() {
        return i;
      }), l.d(d, "fromTranslation", function() {
        return b;
      }), l.d(d, "fromRotation", function() {
        return t;
      }), l.d(d, "fromScaling", function() {
        return m;
      }), l.d(d, "fromMat2d", function() {
        return R;
      }), l.d(d, "fromQuat", function() {
        return x;
      }), l.d(d, "normalFromMat4", function() {
        return C;
      }), l.d(d, "projection", function() {
        return T;
      }), l.d(d, "str", function() {
        return K;
      }), l.d(d, "frob", function() {
        return J;
      }), l.d(d, "add", function() {
        return F;
      }), l.d(d, "subtract", function() {
        return r;
      }), l.d(d, "multiplyScalar", function() {
        return Y;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return H;
      }), l.d(d, "exactEquals", function() {
        return Q;
      }), l.d(d, "equals", function() {
        return w;
      }), l.d(d, "mul", function() {
        return O;
      }), l.d(d, "sub", function() {
        return q;
      });
      var s = l(2);
      function c() {
        var k = new s.ARRAY_TYPE(9);
        return s.ARRAY_TYPE != Float32Array && (k[1] = 0, k[2] = 0, k[3] = 0, k[5] = 0, k[6] = 0, k[7] = 0), k[0] = 1, k[4] = 1, k[8] = 1, k;
      }
      function W(k, P) {
        return k[0] = P[0], k[1] = P[1], k[2] = P[2], k[3] = P[4], k[4] = P[5], k[5] = P[6], k[6] = P[8], k[7] = P[9], k[8] = P[10], k;
      }
      function u(k) {
        var P = new s.ARRAY_TYPE(9);
        return P[0] = k[0], P[1] = k[1], P[2] = k[2], P[3] = k[3], P[4] = k[4], P[5] = k[5], P[6] = k[6], P[7] = k[7], P[8] = k[8], P;
      }
      function e(k, P) {
        return k[0] = P[0], k[1] = P[1], k[2] = P[2], k[3] = P[3], k[4] = P[4], k[5] = P[5], k[6] = P[6], k[7] = P[7], k[8] = P[8], k;
      }
      function n(k, P, D, ll, _, bl, $, el, nl) {
        var z = new s.ARRAY_TYPE(9);
        return z[0] = k, z[1] = P, z[2] = D, z[3] = ll, z[4] = _, z[5] = bl, z[6] = $, z[7] = el, z[8] = nl, z;
      }
      function G(k, P, D, ll, _, bl, $, el, nl, z) {
        return k[0] = P, k[1] = D, k[2] = ll, k[3] = _, k[4] = bl, k[5] = $, k[6] = el, k[7] = nl, k[8] = z, k;
      }
      function y(k) {
        return k[0] = 1, k[1] = 0, k[2] = 0, k[3] = 0, k[4] = 1, k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1, k;
      }
      function a(k, P) {
        if (k === P) {
          var D = P[1], ll = P[2], _ = P[5];
          k[1] = P[3], k[2] = P[6], k[3] = D, k[5] = P[7], k[6] = ll, k[7] = _;
        } else
          k[0] = P[0], k[1] = P[3], k[2] = P[6], k[3] = P[1], k[4] = P[4], k[5] = P[7], k[6] = P[2], k[7] = P[5], k[8] = P[8];
        return k;
      }
      function I(k, P) {
        var D = P[0], ll = P[1], _ = P[2], bl = P[3], $ = P[4], el = P[5], nl = P[6], z = P[7], M = P[8], E = M * $ - el * z, B = -M * bl + el * nl, g = z * bl - $ * nl, U = D * E + ll * B + _ * g;
        return U ? (U = 1 / U, k[0] = E * U, k[1] = (-M * ll + _ * z) * U, k[2] = (el * ll - _ * $) * U, k[3] = B * U, k[4] = (M * D - _ * nl) * U, k[5] = (-el * D + _ * bl) * U, k[6] = g * U, k[7] = (-z * D + ll * nl) * U, k[8] = ($ * D - ll * bl) * U, k) : null;
      }
      function h(k, P) {
        var D = P[0], ll = P[1], _ = P[2], bl = P[3], $ = P[4], el = P[5], nl = P[6], z = P[7], M = P[8];
        return k[0] = $ * M - el * z, k[1] = _ * z - ll * M, k[2] = ll * el - _ * $, k[3] = el * nl - bl * M, k[4] = D * M - _ * nl, k[5] = _ * bl - D * el, k[6] = bl * z - $ * nl, k[7] = ll * nl - D * z, k[8] = D * $ - ll * bl, k;
      }
      function S(k) {
        var P = k[0], D = k[1], ll = k[2], _ = k[3], bl = k[4], $ = k[5], el = k[6], nl = k[7], z = k[8];
        return P * (z * bl - $ * nl) + D * (-z * _ + $ * el) + ll * (nl * _ - bl * el);
      }
      function p(k, P, D) {
        var ll = P[0], _ = P[1], bl = P[2], $ = P[3], el = P[4], nl = P[5], z = P[6], M = P[7], E = P[8], B = D[0], g = D[1], U = D[2], o = D[3], L = D[4], N = D[5], v = D[6], f = D[7], j = D[8];
        return k[0] = B * ll + g * $ + U * z, k[1] = B * _ + g * el + U * M, k[2] = B * bl + g * nl + U * E, k[3] = o * ll + L * $ + N * z, k[4] = o * _ + L * el + N * M, k[5] = o * bl + L * nl + N * E, k[6] = v * ll + f * $ + j * z, k[7] = v * _ + f * el + j * M, k[8] = v * bl + f * nl + j * E, k;
      }
      function X(k, P, D) {
        var ll = P[0], _ = P[1], bl = P[2], $ = P[3], el = P[4], nl = P[5], z = P[6], M = P[7], E = P[8], B = D[0], g = D[1];
        return k[0] = ll, k[1] = _, k[2] = bl, k[3] = $, k[4] = el, k[5] = nl, k[6] = B * ll + g * $ + z, k[7] = B * _ + g * el + M, k[8] = B * bl + g * nl + E, k;
      }
      function V(k, P, D) {
        var ll = P[0], _ = P[1], bl = P[2], $ = P[3], el = P[4], nl = P[5], z = P[6], M = P[7], E = P[8], B = Math.sin(D), g = Math.cos(D);
        return k[0] = g * ll + B * $, k[1] = g * _ + B * el, k[2] = g * bl + B * nl, k[3] = g * $ - B * ll, k[4] = g * el - B * _, k[5] = g * nl - B * bl, k[6] = z, k[7] = M, k[8] = E, k;
      }
      function i(k, P, D) {
        var ll = D[0], _ = D[1];
        return k[0] = ll * P[0], k[1] = ll * P[1], k[2] = ll * P[2], k[3] = _ * P[3], k[4] = _ * P[4], k[5] = _ * P[5], k[6] = P[6], k[7] = P[7], k[8] = P[8], k;
      }
      function b(k, P) {
        return k[0] = 1, k[1] = 0, k[2] = 0, k[3] = 0, k[4] = 1, k[5] = 0, k[6] = P[0], k[7] = P[1], k[8] = 1, k;
      }
      function t(k, P) {
        var D = Math.sin(P), ll = Math.cos(P);
        return k[0] = ll, k[1] = D, k[2] = 0, k[3] = -D, k[4] = ll, k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1, k;
      }
      function m(k, P) {
        return k[0] = P[0], k[1] = 0, k[2] = 0, k[3] = 0, k[4] = P[1], k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1, k;
      }
      function R(k, P) {
        return k[0] = P[0], k[1] = P[1], k[2] = 0, k[3] = P[2], k[4] = P[3], k[5] = 0, k[6] = P[4], k[7] = P[5], k[8] = 1, k;
      }
      function x(k, P) {
        var D = P[0], ll = P[1], _ = P[2], bl = P[3], $ = D + D, el = ll + ll, nl = _ + _, z = D * $, M = ll * $, E = ll * el, B = _ * $, g = _ * el, U = _ * nl, o = bl * $, L = bl * el, N = bl * nl;
        return k[0] = 1 - E - U, k[3] = M - N, k[6] = B + L, k[1] = M + N, k[4] = 1 - z - U, k[7] = g - o, k[2] = B - L, k[5] = g + o, k[8] = 1 - z - E, k;
      }
      function C(k, P) {
        var D = P[0], ll = P[1], _ = P[2], bl = P[3], $ = P[4], el = P[5], nl = P[6], z = P[7], M = P[8], E = P[9], B = P[10], g = P[11], U = P[12], o = P[13], L = P[14], N = P[15], v = D * el - ll * $, f = D * nl - _ * $, j = D * z - bl * $, A = ll * nl - _ * el, dl = ll * z - bl * el, il = _ * z - bl * nl, cl = M * o - E * U, ml = M * L - B * U, tl = M * N - g * U, sl = E * L - B * o, Zl = E * N - g * o, al = B * N - g * L, ol = v * al - f * Zl + j * sl + A * tl - dl * ml + il * cl;
        return ol ? (ol = 1 / ol, k[0] = (el * al - nl * Zl + z * sl) * ol, k[1] = (nl * tl - $ * al - z * ml) * ol, k[2] = ($ * Zl - el * tl + z * cl) * ol, k[3] = (_ * Zl - ll * al - bl * sl) * ol, k[4] = (D * al - _ * tl + bl * ml) * ol, k[5] = (ll * tl - D * Zl - bl * cl) * ol, k[6] = (o * il - L * dl + N * A) * ol, k[7] = (L * j - U * il - N * f) * ol, k[8] = (U * dl - o * j + N * v) * ol, k) : null;
      }
      function T(k, P, D) {
        return k[0] = 2 / P, k[1] = 0, k[2] = 0, k[3] = 0, k[4] = -2 / D, k[5] = 0, k[6] = -1, k[7] = 1, k[8] = 1, k;
      }
      function K(k) {
        return "mat3(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ", " + k[4] + ", " + k[5] + ", " + k[6] + ", " + k[7] + ", " + k[8] + ")";
      }
      function J(k) {
        return Math.hypot(k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8]);
      }
      function F(k, P, D) {
        return k[0] = P[0] + D[0], k[1] = P[1] + D[1], k[2] = P[2] + D[2], k[3] = P[3] + D[3], k[4] = P[4] + D[4], k[5] = P[5] + D[5], k[6] = P[6] + D[6], k[7] = P[7] + D[7], k[8] = P[8] + D[8], k;
      }
      function r(k, P, D) {
        return k[0] = P[0] - D[0], k[1] = P[1] - D[1], k[2] = P[2] - D[2], k[3] = P[3] - D[3], k[4] = P[4] - D[4], k[5] = P[5] - D[5], k[6] = P[6] - D[6], k[7] = P[7] - D[7], k[8] = P[8] - D[8], k;
      }
      function Y(k, P, D) {
        return k[0] = P[0] * D, k[1] = P[1] * D, k[2] = P[2] * D, k[3] = P[3] * D, k[4] = P[4] * D, k[5] = P[5] * D, k[6] = P[6] * D, k[7] = P[7] * D, k[8] = P[8] * D, k;
      }
      function H(k, P, D, ll) {
        return k[0] = P[0] + D[0] * ll, k[1] = P[1] + D[1] * ll, k[2] = P[2] + D[2] * ll, k[3] = P[3] + D[3] * ll, k[4] = P[4] + D[4] * ll, k[5] = P[5] + D[5] * ll, k[6] = P[6] + D[6] * ll, k[7] = P[7] + D[7] * ll, k[8] = P[8] + D[8] * ll, k;
      }
      function Q(k, P) {
        return k[0] === P[0] && k[1] === P[1] && k[2] === P[2] && k[3] === P[3] && k[4] === P[4] && k[5] === P[5] && k[6] === P[6] && k[7] === P[7] && k[8] === P[8];
      }
      function w(k, P) {
        var D = k[0], ll = k[1], _ = k[2], bl = k[3], $ = k[4], el = k[5], nl = k[6], z = k[7], M = k[8], E = P[0], B = P[1], g = P[2], U = P[3], o = P[4], L = P[5], N = P[6], v = P[7], f = P[8];
        return Math.abs(D - E) <= s.EPSILON * Math.max(1, Math.abs(D), Math.abs(E)) && Math.abs(ll - B) <= s.EPSILON * Math.max(1, Math.abs(ll), Math.abs(B)) && Math.abs(_ - g) <= s.EPSILON * Math.max(1, Math.abs(_), Math.abs(g)) && Math.abs(bl - U) <= s.EPSILON * Math.max(1, Math.abs(bl), Math.abs(U)) && Math.abs($ - o) <= s.EPSILON * Math.max(1, Math.abs($), Math.abs(o)) && Math.abs(el - L) <= s.EPSILON * Math.max(1, Math.abs(el), Math.abs(L)) && Math.abs(nl - N) <= s.EPSILON * Math.max(1, Math.abs(nl), Math.abs(N)) && Math.abs(z - v) <= s.EPSILON * Math.max(1, Math.abs(z), Math.abs(v)) && Math.abs(M - f) <= s.EPSILON * Math.max(1, Math.abs(M), Math.abs(f));
      }
      var O = p, q = r;
    },
    /* 6 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return c;
      }), l.d(d, "clone", function() {
        return W;
      }), l.d(d, "copy", function() {
        return u;
      }), l.d(d, "fromValues", function() {
        return e;
      }), l.d(d, "set", function() {
        return n;
      }), l.d(d, "identity", function() {
        return G;
      }), l.d(d, "transpose", function() {
        return y;
      }), l.d(d, "invert", function() {
        return a;
      }), l.d(d, "adjoint", function() {
        return I;
      }), l.d(d, "determinant", function() {
        return h;
      }), l.d(d, "multiply", function() {
        return S;
      }), l.d(d, "translate", function() {
        return p;
      }), l.d(d, "scale", function() {
        return X;
      }), l.d(d, "rotate", function() {
        return V;
      }), l.d(d, "rotateX", function() {
        return i;
      }), l.d(d, "rotateY", function() {
        return b;
      }), l.d(d, "rotateZ", function() {
        return t;
      }), l.d(d, "fromTranslation", function() {
        return m;
      }), l.d(d, "fromScaling", function() {
        return R;
      }), l.d(d, "fromRotation", function() {
        return x;
      }), l.d(d, "fromXRotation", function() {
        return C;
      }), l.d(d, "fromYRotation", function() {
        return T;
      }), l.d(d, "fromZRotation", function() {
        return K;
      }), l.d(d, "fromRotationTranslation", function() {
        return J;
      }), l.d(d, "fromQuat2", function() {
        return F;
      }), l.d(d, "getTranslation", function() {
        return r;
      }), l.d(d, "getScaling", function() {
        return Y;
      }), l.d(d, "getRotation", function() {
        return H;
      }), l.d(d, "fromRotationTranslationScale", function() {
        return Q;
      }), l.d(d, "fromRotationTranslationScaleOrigin", function() {
        return w;
      }), l.d(d, "fromQuat", function() {
        return O;
      }), l.d(d, "frustum", function() {
        return q;
      }), l.d(d, "perspective", function() {
        return k;
      }), l.d(d, "perspectiveFromFieldOfView", function() {
        return P;
      }), l.d(d, "ortho", function() {
        return D;
      }), l.d(d, "lookAt", function() {
        return ll;
      }), l.d(d, "targetTo", function() {
        return _;
      }), l.d(d, "str", function() {
        return bl;
      }), l.d(d, "frob", function() {
        return $;
      }), l.d(d, "add", function() {
        return el;
      }), l.d(d, "subtract", function() {
        return nl;
      }), l.d(d, "multiplyScalar", function() {
        return z;
      }), l.d(d, "multiplyScalarAndAdd", function() {
        return M;
      }), l.d(d, "exactEquals", function() {
        return E;
      }), l.d(d, "equals", function() {
        return B;
      }), l.d(d, "mul", function() {
        return g;
      }), l.d(d, "sub", function() {
        return U;
      });
      var s = l(2);
      function c() {
        var o = new s.ARRAY_TYPE(16);
        return s.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0), o[0] = 1, o[5] = 1, o[10] = 1, o[15] = 1, o;
      }
      function W(o) {
        var L = new s.ARRAY_TYPE(16);
        return L[0] = o[0], L[1] = o[1], L[2] = o[2], L[3] = o[3], L[4] = o[4], L[5] = o[5], L[6] = o[6], L[7] = o[7], L[8] = o[8], L[9] = o[9], L[10] = o[10], L[11] = o[11], L[12] = o[12], L[13] = o[13], L[14] = o[14], L[15] = o[15], L;
      }
      function u(o, L) {
        return o[0] = L[0], o[1] = L[1], o[2] = L[2], o[3] = L[3], o[4] = L[4], o[5] = L[5], o[6] = L[6], o[7] = L[7], o[8] = L[8], o[9] = L[9], o[10] = L[10], o[11] = L[11], o[12] = L[12], o[13] = L[13], o[14] = L[14], o[15] = L[15], o;
      }
      function e(o, L, N, v, f, j, A, dl, il, cl, ml, tl, sl, Zl, al, ol) {
        var Xl = new s.ARRAY_TYPE(16);
        return Xl[0] = o, Xl[1] = L, Xl[2] = N, Xl[3] = v, Xl[4] = f, Xl[5] = j, Xl[6] = A, Xl[7] = dl, Xl[8] = il, Xl[9] = cl, Xl[10] = ml, Xl[11] = tl, Xl[12] = sl, Xl[13] = Zl, Xl[14] = al, Xl[15] = ol, Xl;
      }
      function n(o, L, N, v, f, j, A, dl, il, cl, ml, tl, sl, Zl, al, ol, Xl) {
        return o[0] = L, o[1] = N, o[2] = v, o[3] = f, o[4] = j, o[5] = A, o[6] = dl, o[7] = il, o[8] = cl, o[9] = ml, o[10] = tl, o[11] = sl, o[12] = Zl, o[13] = al, o[14] = ol, o[15] = Xl, o;
      }
      function G(o) {
        return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 1, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 1, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
      }
      function y(o, L) {
        if (o === L) {
          var N = L[1], v = L[2], f = L[3], j = L[6], A = L[7], dl = L[11];
          o[1] = L[4], o[2] = L[8], o[3] = L[12], o[4] = N, o[6] = L[9], o[7] = L[13], o[8] = v, o[9] = j, o[11] = L[14], o[12] = f, o[13] = A, o[14] = dl;
        } else
          o[0] = L[0], o[1] = L[4], o[2] = L[8], o[3] = L[12], o[4] = L[1], o[5] = L[5], o[6] = L[9], o[7] = L[13], o[8] = L[2], o[9] = L[6], o[10] = L[10], o[11] = L[14], o[12] = L[3], o[13] = L[7], o[14] = L[11], o[15] = L[15];
        return o;
      }
      function a(o, L) {
        var N = L[0], v = L[1], f = L[2], j = L[3], A = L[4], dl = L[5], il = L[6], cl = L[7], ml = L[8], tl = L[9], sl = L[10], Zl = L[11], al = L[12], ol = L[13], Xl = L[14], Gl = L[15], xl = N * dl - v * A, Kl = N * il - f * A, Rl = N * cl - j * A, Yl = v * il - f * dl, Sl = v * cl - j * dl, Ql = f * cl - j * il, kl = ml * ol - tl * al, vl = ml * Xl - sl * al, Ul = ml * Gl - Zl * al, Pl = tl * Xl - sl * ol, fl = tl * Gl - Zl * ol, wl = sl * Gl - Zl * Xl, Tl = xl * wl - Kl * fl + Rl * Pl + Yl * Ul - Sl * vl + Ql * kl;
        return Tl ? (Tl = 1 / Tl, o[0] = (dl * wl - il * fl + cl * Pl) * Tl, o[1] = (f * fl - v * wl - j * Pl) * Tl, o[2] = (ol * Ql - Xl * Sl + Gl * Yl) * Tl, o[3] = (sl * Sl - tl * Ql - Zl * Yl) * Tl, o[4] = (il * Ul - A * wl - cl * vl) * Tl, o[5] = (N * wl - f * Ul + j * vl) * Tl, o[6] = (Xl * Rl - al * Ql - Gl * Kl) * Tl, o[7] = (ml * Ql - sl * Rl + Zl * Kl) * Tl, o[8] = (A * fl - dl * Ul + cl * kl) * Tl, o[9] = (v * Ul - N * fl - j * kl) * Tl, o[10] = (al * Sl - ol * Rl + Gl * xl) * Tl, o[11] = (tl * Rl - ml * Sl - Zl * xl) * Tl, o[12] = (dl * vl - A * Pl - il * kl) * Tl, o[13] = (N * Pl - v * vl + f * kl) * Tl, o[14] = (ol * Kl - al * Yl - Xl * xl) * Tl, o[15] = (ml * Yl - tl * Kl + sl * xl) * Tl, o) : null;
      }
      function I(o, L) {
        var N = L[0], v = L[1], f = L[2], j = L[3], A = L[4], dl = L[5], il = L[6], cl = L[7], ml = L[8], tl = L[9], sl = L[10], Zl = L[11], al = L[12], ol = L[13], Xl = L[14], Gl = L[15];
        return o[0] = dl * (sl * Gl - Zl * Xl) - tl * (il * Gl - cl * Xl) + ol * (il * Zl - cl * sl), o[1] = -(v * (sl * Gl - Zl * Xl) - tl * (f * Gl - j * Xl) + ol * (f * Zl - j * sl)), o[2] = v * (il * Gl - cl * Xl) - dl * (f * Gl - j * Xl) + ol * (f * cl - j * il), o[3] = -(v * (il * Zl - cl * sl) - dl * (f * Zl - j * sl) + tl * (f * cl - j * il)), o[4] = -(A * (sl * Gl - Zl * Xl) - ml * (il * Gl - cl * Xl) + al * (il * Zl - cl * sl)), o[5] = N * (sl * Gl - Zl * Xl) - ml * (f * Gl - j * Xl) + al * (f * Zl - j * sl), o[6] = -(N * (il * Gl - cl * Xl) - A * (f * Gl - j * Xl) + al * (f * cl - j * il)), o[7] = N * (il * Zl - cl * sl) - A * (f * Zl - j * sl) + ml * (f * cl - j * il), o[8] = A * (tl * Gl - Zl * ol) - ml * (dl * Gl - cl * ol) + al * (dl * Zl - cl * tl), o[9] = -(N * (tl * Gl - Zl * ol) - ml * (v * Gl - j * ol) + al * (v * Zl - j * tl)), o[10] = N * (dl * Gl - cl * ol) - A * (v * Gl - j * ol) + al * (v * cl - j * dl), o[11] = -(N * (dl * Zl - cl * tl) - A * (v * Zl - j * tl) + ml * (v * cl - j * dl)), o[12] = -(A * (tl * Xl - sl * ol) - ml * (dl * Xl - il * ol) + al * (dl * sl - il * tl)), o[13] = N * (tl * Xl - sl * ol) - ml * (v * Xl - f * ol) + al * (v * sl - f * tl), o[14] = -(N * (dl * Xl - il * ol) - A * (v * Xl - f * ol) + al * (v * il - f * dl)), o[15] = N * (dl * sl - il * tl) - A * (v * sl - f * tl) + ml * (v * il - f * dl), o;
      }
      function h(o) {
        var L = o[0], N = o[1], v = o[2], f = o[3], j = o[4], A = o[5], dl = o[6], il = o[7], cl = o[8], ml = o[9], tl = o[10], sl = o[11], Zl = o[12], al = o[13], ol = o[14], Xl = o[15], Gl = L * A - N * j, xl = L * dl - v * j, Kl = L * il - f * j, Rl = N * dl - v * A, Yl = N * il - f * A, Sl = v * il - f * dl, Ql = cl * al - ml * Zl, kl = cl * ol - tl * Zl, vl = cl * Xl - sl * Zl, Ul = ml * ol - tl * al, Pl = ml * Xl - sl * al, fl = tl * Xl - sl * ol;
        return Gl * fl - xl * Pl + Kl * Ul + Rl * vl - Yl * kl + Sl * Ql;
      }
      function S(o, L, N) {
        var v = L[0], f = L[1], j = L[2], A = L[3], dl = L[4], il = L[5], cl = L[6], ml = L[7], tl = L[8], sl = L[9], Zl = L[10], al = L[11], ol = L[12], Xl = L[13], Gl = L[14], xl = L[15], Kl = N[0], Rl = N[1], Yl = N[2], Sl = N[3];
        return o[0] = Kl * v + Rl * dl + Yl * tl + Sl * ol, o[1] = Kl * f + Rl * il + Yl * sl + Sl * Xl, o[2] = Kl * j + Rl * cl + Yl * Zl + Sl * Gl, o[3] = Kl * A + Rl * ml + Yl * al + Sl * xl, Kl = N[4], Rl = N[5], Yl = N[6], Sl = N[7], o[4] = Kl * v + Rl * dl + Yl * tl + Sl * ol, o[5] = Kl * f + Rl * il + Yl * sl + Sl * Xl, o[6] = Kl * j + Rl * cl + Yl * Zl + Sl * Gl, o[7] = Kl * A + Rl * ml + Yl * al + Sl * xl, Kl = N[8], Rl = N[9], Yl = N[10], Sl = N[11], o[8] = Kl * v + Rl * dl + Yl * tl + Sl * ol, o[9] = Kl * f + Rl * il + Yl * sl + Sl * Xl, o[10] = Kl * j + Rl * cl + Yl * Zl + Sl * Gl, o[11] = Kl * A + Rl * ml + Yl * al + Sl * xl, Kl = N[12], Rl = N[13], Yl = N[14], Sl = N[15], o[12] = Kl * v + Rl * dl + Yl * tl + Sl * ol, o[13] = Kl * f + Rl * il + Yl * sl + Sl * Xl, o[14] = Kl * j + Rl * cl + Yl * Zl + Sl * Gl, o[15] = Kl * A + Rl * ml + Yl * al + Sl * xl, o;
      }
      function p(o, L, N) {
        var v = N[0], f = N[1], j = N[2], A, dl, il, cl, ml, tl, sl, Zl, al, ol, Xl, Gl;
        return L === o ? (o[12] = L[0] * v + L[4] * f + L[8] * j + L[12], o[13] = L[1] * v + L[5] * f + L[9] * j + L[13], o[14] = L[2] * v + L[6] * f + L[10] * j + L[14], o[15] = L[3] * v + L[7] * f + L[11] * j + L[15]) : (A = L[0], dl = L[1], il = L[2], cl = L[3], ml = L[4], tl = L[5], sl = L[6], Zl = L[7], al = L[8], ol = L[9], Xl = L[10], Gl = L[11], o[0] = A, o[1] = dl, o[2] = il, o[3] = cl, o[4] = ml, o[5] = tl, o[6] = sl, o[7] = Zl, o[8] = al, o[9] = ol, o[10] = Xl, o[11] = Gl, o[12] = A * v + ml * f + al * j + L[12], o[13] = dl * v + tl * f + ol * j + L[13], o[14] = il * v + sl * f + Xl * j + L[14], o[15] = cl * v + Zl * f + Gl * j + L[15]), o;
      }
      function X(o, L, N) {
        var v = N[0], f = N[1], j = N[2];
        return o[0] = L[0] * v, o[1] = L[1] * v, o[2] = L[2] * v, o[3] = L[3] * v, o[4] = L[4] * f, o[5] = L[5] * f, o[6] = L[6] * f, o[7] = L[7] * f, o[8] = L[8] * j, o[9] = L[9] * j, o[10] = L[10] * j, o[11] = L[11] * j, o[12] = L[12], o[13] = L[13], o[14] = L[14], o[15] = L[15], o;
      }
      function V(o, L, N, v) {
        var f = v[0], j = v[1], A = v[2], dl = Math.hypot(f, j, A), il, cl, ml, tl, sl, Zl, al, ol, Xl, Gl, xl, Kl, Rl, Yl, Sl, Ql, kl, vl, Ul, Pl, fl, wl, Tl, Dl;
        return dl < s.EPSILON ? null : (dl = 1 / dl, f *= dl, j *= dl, A *= dl, il = Math.sin(N), cl = Math.cos(N), ml = 1 - cl, tl = L[0], sl = L[1], Zl = L[2], al = L[3], ol = L[4], Xl = L[5], Gl = L[6], xl = L[7], Kl = L[8], Rl = L[9], Yl = L[10], Sl = L[11], Ql = f * f * ml + cl, kl = j * f * ml + A * il, vl = A * f * ml - j * il, Ul = f * j * ml - A * il, Pl = j * j * ml + cl, fl = A * j * ml + f * il, wl = f * A * ml + j * il, Tl = j * A * ml - f * il, Dl = A * A * ml + cl, o[0] = tl * Ql + ol * kl + Kl * vl, o[1] = sl * Ql + Xl * kl + Rl * vl, o[2] = Zl * Ql + Gl * kl + Yl * vl, o[3] = al * Ql + xl * kl + Sl * vl, o[4] = tl * Ul + ol * Pl + Kl * fl, o[5] = sl * Ul + Xl * Pl + Rl * fl, o[6] = Zl * Ul + Gl * Pl + Yl * fl, o[7] = al * Ul + xl * Pl + Sl * fl, o[8] = tl * wl + ol * Tl + Kl * Dl, o[9] = sl * wl + Xl * Tl + Rl * Dl, o[10] = Zl * wl + Gl * Tl + Yl * Dl, o[11] = al * wl + xl * Tl + Sl * Dl, L !== o && (o[12] = L[12], o[13] = L[13], o[14] = L[14], o[15] = L[15]), o);
      }
      function i(o, L, N) {
        var v = Math.sin(N), f = Math.cos(N), j = L[4], A = L[5], dl = L[6], il = L[7], cl = L[8], ml = L[9], tl = L[10], sl = L[11];
        return L !== o && (o[0] = L[0], o[1] = L[1], o[2] = L[2], o[3] = L[3], o[12] = L[12], o[13] = L[13], o[14] = L[14], o[15] = L[15]), o[4] = j * f + cl * v, o[5] = A * f + ml * v, o[6] = dl * f + tl * v, o[7] = il * f + sl * v, o[8] = cl * f - j * v, o[9] = ml * f - A * v, o[10] = tl * f - dl * v, o[11] = sl * f - il * v, o;
      }
      function b(o, L, N) {
        var v = Math.sin(N), f = Math.cos(N), j = L[0], A = L[1], dl = L[2], il = L[3], cl = L[8], ml = L[9], tl = L[10], sl = L[11];
        return L !== o && (o[4] = L[4], o[5] = L[5], o[6] = L[6], o[7] = L[7], o[12] = L[12], o[13] = L[13], o[14] = L[14], o[15] = L[15]), o[0] = j * f - cl * v, o[1] = A * f - ml * v, o[2] = dl * f - tl * v, o[3] = il * f - sl * v, o[8] = j * v + cl * f, o[9] = A * v + ml * f, o[10] = dl * v + tl * f, o[11] = il * v + sl * f, o;
      }
      function t(o, L, N) {
        var v = Math.sin(N), f = Math.cos(N), j = L[0], A = L[1], dl = L[2], il = L[3], cl = L[4], ml = L[5], tl = L[6], sl = L[7];
        return L !== o && (o[8] = L[8], o[9] = L[9], o[10] = L[10], o[11] = L[11], o[12] = L[12], o[13] = L[13], o[14] = L[14], o[15] = L[15]), o[0] = j * f + cl * v, o[1] = A * f + ml * v, o[2] = dl * f + tl * v, o[3] = il * f + sl * v, o[4] = cl * f - j * v, o[5] = ml * f - A * v, o[6] = tl * f - dl * v, o[7] = sl * f - il * v, o;
      }
      function m(o, L) {
        return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 1, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 1, o[11] = 0, o[12] = L[0], o[13] = L[1], o[14] = L[2], o[15] = 1, o;
      }
      function R(o, L) {
        return o[0] = L[0], o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = L[1], o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = L[2], o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
      }
      function x(o, L, N) {
        var v = N[0], f = N[1], j = N[2], A = Math.hypot(v, f, j), dl, il, cl;
        return A < s.EPSILON ? null : (A = 1 / A, v *= A, f *= A, j *= A, dl = Math.sin(L), il = Math.cos(L), cl = 1 - il, o[0] = v * v * cl + il, o[1] = f * v * cl + j * dl, o[2] = j * v * cl - f * dl, o[3] = 0, o[4] = v * f * cl - j * dl, o[5] = f * f * cl + il, o[6] = j * f * cl + v * dl, o[7] = 0, o[8] = v * j * cl + f * dl, o[9] = f * j * cl - v * dl, o[10] = j * j * cl + il, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o);
      }
      function C(o, L) {
        var N = Math.sin(L), v = Math.cos(L);
        return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = v, o[6] = N, o[7] = 0, o[8] = 0, o[9] = -N, o[10] = v, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
      }
      function T(o, L) {
        var N = Math.sin(L), v = Math.cos(L);
        return o[0] = v, o[1] = 0, o[2] = -N, o[3] = 0, o[4] = 0, o[5] = 1, o[6] = 0, o[7] = 0, o[8] = N, o[9] = 0, o[10] = v, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
      }
      function K(o, L) {
        var N = Math.sin(L), v = Math.cos(L);
        return o[0] = v, o[1] = N, o[2] = 0, o[3] = 0, o[4] = -N, o[5] = v, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 1, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
      }
      function J(o, L, N) {
        var v = L[0], f = L[1], j = L[2], A = L[3], dl = v + v, il = f + f, cl = j + j, ml = v * dl, tl = v * il, sl = v * cl, Zl = f * il, al = f * cl, ol = j * cl, Xl = A * dl, Gl = A * il, xl = A * cl;
        return o[0] = 1 - (Zl + ol), o[1] = tl + xl, o[2] = sl - Gl, o[3] = 0, o[4] = tl - xl, o[5] = 1 - (ml + ol), o[6] = al + Xl, o[7] = 0, o[8] = sl + Gl, o[9] = al - Xl, o[10] = 1 - (ml + Zl), o[11] = 0, o[12] = N[0], o[13] = N[1], o[14] = N[2], o[15] = 1, o;
      }
      function F(o, L) {
        var N = new s.ARRAY_TYPE(3), v = -L[0], f = -L[1], j = -L[2], A = L[3], dl = L[4], il = L[5], cl = L[6], ml = L[7], tl = v * v + f * f + j * j + A * A;
        return tl > 0 ? (N[0] = (dl * A + ml * v + il * j - cl * f) * 2 / tl, N[1] = (il * A + ml * f + cl * v - dl * j) * 2 / tl, N[2] = (cl * A + ml * j + dl * f - il * v) * 2 / tl) : (N[0] = (dl * A + ml * v + il * j - cl * f) * 2, N[1] = (il * A + ml * f + cl * v - dl * j) * 2, N[2] = (cl * A + ml * j + dl * f - il * v) * 2), J(o, L, N), o;
      }
      function r(o, L) {
        return o[0] = L[12], o[1] = L[13], o[2] = L[14], o;
      }
      function Y(o, L) {
        var N = L[0], v = L[1], f = L[2], j = L[4], A = L[5], dl = L[6], il = L[8], cl = L[9], ml = L[10];
        return o[0] = Math.hypot(N, v, f), o[1] = Math.hypot(j, A, dl), o[2] = Math.hypot(il, cl, ml), o;
      }
      function H(o, L) {
        var N = new s.ARRAY_TYPE(3);
        Y(N, L);
        var v = 1 / N[0], f = 1 / N[1], j = 1 / N[2], A = L[0] * v, dl = L[1] * f, il = L[2] * j, cl = L[4] * v, ml = L[5] * f, tl = L[6] * j, sl = L[8] * v, Zl = L[9] * f, al = L[10] * j, ol = A + ml + al, Xl = 0;
        return ol > 0 ? (Xl = Math.sqrt(ol + 1) * 2, o[3] = 0.25 * Xl, o[0] = (tl - Zl) / Xl, o[1] = (sl - il) / Xl, o[2] = (dl - cl) / Xl) : A > ml && A > al ? (Xl = Math.sqrt(1 + A - ml - al) * 2, o[3] = (tl - Zl) / Xl, o[0] = 0.25 * Xl, o[1] = (dl + cl) / Xl, o[2] = (sl + il) / Xl) : ml > al ? (Xl = Math.sqrt(1 + ml - A - al) * 2, o[3] = (sl - il) / Xl, o[0] = (dl + cl) / Xl, o[1] = 0.25 * Xl, o[2] = (tl + Zl) / Xl) : (Xl = Math.sqrt(1 + al - A - ml) * 2, o[3] = (dl - cl) / Xl, o[0] = (sl + il) / Xl, o[1] = (tl + Zl) / Xl, o[2] = 0.25 * Xl), o;
      }
      function Q(o, L, N, v) {
        var f = L[0], j = L[1], A = L[2], dl = L[3], il = f + f, cl = j + j, ml = A + A, tl = f * il, sl = f * cl, Zl = f * ml, al = j * cl, ol = j * ml, Xl = A * ml, Gl = dl * il, xl = dl * cl, Kl = dl * ml, Rl = v[0], Yl = v[1], Sl = v[2];
        return o[0] = (1 - (al + Xl)) * Rl, o[1] = (sl + Kl) * Rl, o[2] = (Zl - xl) * Rl, o[3] = 0, o[4] = (sl - Kl) * Yl, o[5] = (1 - (tl + Xl)) * Yl, o[6] = (ol + Gl) * Yl, o[7] = 0, o[8] = (Zl + xl) * Sl, o[9] = (ol - Gl) * Sl, o[10] = (1 - (tl + al)) * Sl, o[11] = 0, o[12] = N[0], o[13] = N[1], o[14] = N[2], o[15] = 1, o;
      }
      function w(o, L, N, v, f) {
        var j = L[0], A = L[1], dl = L[2], il = L[3], cl = j + j, ml = A + A, tl = dl + dl, sl = j * cl, Zl = j * ml, al = j * tl, ol = A * ml, Xl = A * tl, Gl = dl * tl, xl = il * cl, Kl = il * ml, Rl = il * tl, Yl = v[0], Sl = v[1], Ql = v[2], kl = f[0], vl = f[1], Ul = f[2], Pl = (1 - (ol + Gl)) * Yl, fl = (Zl + Rl) * Yl, wl = (al - Kl) * Yl, Tl = (Zl - Rl) * Sl, Dl = (1 - (sl + Gl)) * Sl, Id = (Xl + xl) * Sl, pd = (al + Kl) * Ql, Gi = (Xl - xl) * Ql, ui = (1 - (sl + ol)) * Ql;
        return o[0] = Pl, o[1] = fl, o[2] = wl, o[3] = 0, o[4] = Tl, o[5] = Dl, o[6] = Id, o[7] = 0, o[8] = pd, o[9] = Gi, o[10] = ui, o[11] = 0, o[12] = N[0] + kl - (Pl * kl + Tl * vl + pd * Ul), o[13] = N[1] + vl - (fl * kl + Dl * vl + Gi * Ul), o[14] = N[2] + Ul - (wl * kl + Id * vl + ui * Ul), o[15] = 1, o;
      }
      function O(o, L) {
        var N = L[0], v = L[1], f = L[2], j = L[3], A = N + N, dl = v + v, il = f + f, cl = N * A, ml = v * A, tl = v * dl, sl = f * A, Zl = f * dl, al = f * il, ol = j * A, Xl = j * dl, Gl = j * il;
        return o[0] = 1 - tl - al, o[1] = ml + Gl, o[2] = sl - Xl, o[3] = 0, o[4] = ml - Gl, o[5] = 1 - cl - al, o[6] = Zl + ol, o[7] = 0, o[8] = sl + Xl, o[9] = Zl - ol, o[10] = 1 - cl - tl, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
      }
      function q(o, L, N, v, f, j, A) {
        var dl = 1 / (N - L), il = 1 / (f - v), cl = 1 / (j - A);
        return o[0] = j * 2 * dl, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = j * 2 * il, o[6] = 0, o[7] = 0, o[8] = (N + L) * dl, o[9] = (f + v) * il, o[10] = (A + j) * cl, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = A * j * 2 * cl, o[15] = 0, o;
      }
      function k(o, L, N, v, f) {
        var j = 1 / Math.tan(L / 2), A;
        return o[0] = j / N, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = j, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = -1, o[12] = 0, o[13] = 0, o[15] = 0, f != null && f !== 1 / 0 ? (A = 1 / (v - f), o[10] = (f + v) * A, o[14] = 2 * f * v * A) : (o[10] = -1, o[14] = -2 * v), o;
      }
      function P(o, L, N, v) {
        var f = Math.tan(L.upDegrees * Math.PI / 180), j = Math.tan(L.downDegrees * Math.PI / 180), A = Math.tan(L.leftDegrees * Math.PI / 180), dl = Math.tan(L.rightDegrees * Math.PI / 180), il = 2 / (A + dl), cl = 2 / (f + j);
        return o[0] = il, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = cl, o[6] = 0, o[7] = 0, o[8] = -((A - dl) * il * 0.5), o[9] = (f - j) * cl * 0.5, o[10] = v / (N - v), o[11] = -1, o[12] = 0, o[13] = 0, o[14] = v * N / (N - v), o[15] = 0, o;
      }
      function D(o, L, N, v, f, j, A) {
        var dl = 1 / (L - N), il = 1 / (v - f), cl = 1 / (j - A);
        return o[0] = -2 * dl, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * il, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * cl, o[11] = 0, o[12] = (L + N) * dl, o[13] = (f + v) * il, o[14] = (A + j) * cl, o[15] = 1, o;
      }
      function ll(o, L, N, v) {
        var f, j, A, dl, il, cl, ml, tl, sl, Zl, al = L[0], ol = L[1], Xl = L[2], Gl = v[0], xl = v[1], Kl = v[2], Rl = N[0], Yl = N[1], Sl = N[2];
        return Math.abs(al - Rl) < s.EPSILON && Math.abs(ol - Yl) < s.EPSILON && Math.abs(Xl - Sl) < s.EPSILON ? G(o) : (ml = al - Rl, tl = ol - Yl, sl = Xl - Sl, Zl = 1 / Math.hypot(ml, tl, sl), ml *= Zl, tl *= Zl, sl *= Zl, f = xl * sl - Kl * tl, j = Kl * ml - Gl * sl, A = Gl * tl - xl * ml, Zl = Math.hypot(f, j, A), Zl ? (Zl = 1 / Zl, f *= Zl, j *= Zl, A *= Zl) : (f = 0, j = 0, A = 0), dl = tl * A - sl * j, il = sl * f - ml * A, cl = ml * j - tl * f, Zl = Math.hypot(dl, il, cl), Zl ? (Zl = 1 / Zl, dl *= Zl, il *= Zl, cl *= Zl) : (dl = 0, il = 0, cl = 0), o[0] = f, o[1] = dl, o[2] = ml, o[3] = 0, o[4] = j, o[5] = il, o[6] = tl, o[7] = 0, o[8] = A, o[9] = cl, o[10] = sl, o[11] = 0, o[12] = -(f * al + j * ol + A * Xl), o[13] = -(dl * al + il * ol + cl * Xl), o[14] = -(ml * al + tl * ol + sl * Xl), o[15] = 1, o);
      }
      function _(o, L, N, v) {
        var f = L[0], j = L[1], A = L[2], dl = v[0], il = v[1], cl = v[2], ml = f - N[0], tl = j - N[1], sl = A - N[2], Zl = ml * ml + tl * tl + sl * sl;
        Zl > 0 && (Zl = 1 / Math.sqrt(Zl), ml *= Zl, tl *= Zl, sl *= Zl);
        var al = il * sl - cl * tl, ol = cl * ml - dl * sl, Xl = dl * tl - il * ml;
        return Zl = al * al + ol * ol + Xl * Xl, Zl > 0 && (Zl = 1 / Math.sqrt(Zl), al *= Zl, ol *= Zl, Xl *= Zl), o[0] = al, o[1] = ol, o[2] = Xl, o[3] = 0, o[4] = tl * Xl - sl * ol, o[5] = sl * al - ml * Xl, o[6] = ml * ol - tl * al, o[7] = 0, o[8] = ml, o[9] = tl, o[10] = sl, o[11] = 0, o[12] = f, o[13] = j, o[14] = A, o[15] = 1, o;
      }
      function bl(o) {
        return "mat4(" + o[0] + ", " + o[1] + ", " + o[2] + ", " + o[3] + ", " + o[4] + ", " + o[5] + ", " + o[6] + ", " + o[7] + ", " + o[8] + ", " + o[9] + ", " + o[10] + ", " + o[11] + ", " + o[12] + ", " + o[13] + ", " + o[14] + ", " + o[15] + ")";
      }
      function $(o) {
        return Math.hypot(o[0], o[1], o[2], o[3], o[4], o[5], o[6], o[7], o[8], o[9], o[10], o[11], o[12], o[13], o[14], o[15]);
      }
      function el(o, L, N) {
        return o[0] = L[0] + N[0], o[1] = L[1] + N[1], o[2] = L[2] + N[2], o[3] = L[3] + N[3], o[4] = L[4] + N[4], o[5] = L[5] + N[5], o[6] = L[6] + N[6], o[7] = L[7] + N[7], o[8] = L[8] + N[8], o[9] = L[9] + N[9], o[10] = L[10] + N[10], o[11] = L[11] + N[11], o[12] = L[12] + N[12], o[13] = L[13] + N[13], o[14] = L[14] + N[14], o[15] = L[15] + N[15], o;
      }
      function nl(o, L, N) {
        return o[0] = L[0] - N[0], o[1] = L[1] - N[1], o[2] = L[2] - N[2], o[3] = L[3] - N[3], o[4] = L[4] - N[4], o[5] = L[5] - N[5], o[6] = L[6] - N[6], o[7] = L[7] - N[7], o[8] = L[8] - N[8], o[9] = L[9] - N[9], o[10] = L[10] - N[10], o[11] = L[11] - N[11], o[12] = L[12] - N[12], o[13] = L[13] - N[13], o[14] = L[14] - N[14], o[15] = L[15] - N[15], o;
      }
      function z(o, L, N) {
        return o[0] = L[0] * N, o[1] = L[1] * N, o[2] = L[2] * N, o[3] = L[3] * N, o[4] = L[4] * N, o[5] = L[5] * N, o[6] = L[6] * N, o[7] = L[7] * N, o[8] = L[8] * N, o[9] = L[9] * N, o[10] = L[10] * N, o[11] = L[11] * N, o[12] = L[12] * N, o[13] = L[13] * N, o[14] = L[14] * N, o[15] = L[15] * N, o;
      }
      function M(o, L, N, v) {
        return o[0] = L[0] + N[0] * v, o[1] = L[1] + N[1] * v, o[2] = L[2] + N[2] * v, o[3] = L[3] + N[3] * v, o[4] = L[4] + N[4] * v, o[5] = L[5] + N[5] * v, o[6] = L[6] + N[6] * v, o[7] = L[7] + N[7] * v, o[8] = L[8] + N[8] * v, o[9] = L[9] + N[9] * v, o[10] = L[10] + N[10] * v, o[11] = L[11] + N[11] * v, o[12] = L[12] + N[12] * v, o[13] = L[13] + N[13] * v, o[14] = L[14] + N[14] * v, o[15] = L[15] + N[15] * v, o;
      }
      function E(o, L) {
        return o[0] === L[0] && o[1] === L[1] && o[2] === L[2] && o[3] === L[3] && o[4] === L[4] && o[5] === L[5] && o[6] === L[6] && o[7] === L[7] && o[8] === L[8] && o[9] === L[9] && o[10] === L[10] && o[11] === L[11] && o[12] === L[12] && o[13] === L[13] && o[14] === L[14] && o[15] === L[15];
      }
      function B(o, L) {
        var N = o[0], v = o[1], f = o[2], j = o[3], A = o[4], dl = o[5], il = o[6], cl = o[7], ml = o[8], tl = o[9], sl = o[10], Zl = o[11], al = o[12], ol = o[13], Xl = o[14], Gl = o[15], xl = L[0], Kl = L[1], Rl = L[2], Yl = L[3], Sl = L[4], Ql = L[5], kl = L[6], vl = L[7], Ul = L[8], Pl = L[9], fl = L[10], wl = L[11], Tl = L[12], Dl = L[13], Id = L[14], pd = L[15];
        return Math.abs(N - xl) <= s.EPSILON * Math.max(1, Math.abs(N), Math.abs(xl)) && Math.abs(v - Kl) <= s.EPSILON * Math.max(1, Math.abs(v), Math.abs(Kl)) && Math.abs(f - Rl) <= s.EPSILON * Math.max(1, Math.abs(f), Math.abs(Rl)) && Math.abs(j - Yl) <= s.EPSILON * Math.max(1, Math.abs(j), Math.abs(Yl)) && Math.abs(A - Sl) <= s.EPSILON * Math.max(1, Math.abs(A), Math.abs(Sl)) && Math.abs(dl - Ql) <= s.EPSILON * Math.max(1, Math.abs(dl), Math.abs(Ql)) && Math.abs(il - kl) <= s.EPSILON * Math.max(1, Math.abs(il), Math.abs(kl)) && Math.abs(cl - vl) <= s.EPSILON * Math.max(1, Math.abs(cl), Math.abs(vl)) && Math.abs(ml - Ul) <= s.EPSILON * Math.max(1, Math.abs(ml), Math.abs(Ul)) && Math.abs(tl - Pl) <= s.EPSILON * Math.max(1, Math.abs(tl), Math.abs(Pl)) && Math.abs(sl - fl) <= s.EPSILON * Math.max(1, Math.abs(sl), Math.abs(fl)) && Math.abs(Zl - wl) <= s.EPSILON * Math.max(1, Math.abs(Zl), Math.abs(wl)) && Math.abs(al - Tl) <= s.EPSILON * Math.max(1, Math.abs(al), Math.abs(Tl)) && Math.abs(ol - Dl) <= s.EPSILON * Math.max(1, Math.abs(ol), Math.abs(Dl)) && Math.abs(Xl - Id) <= s.EPSILON * Math.max(1, Math.abs(Xl), Math.abs(Id)) && Math.abs(Gl - pd) <= s.EPSILON * Math.max(1, Math.abs(Gl), Math.abs(pd));
      }
      var g = S, U = nl;
    },
    /* 7 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return e;
      }), l.d(d, "identity", function() {
        return n;
      }), l.d(d, "setAxisAngle", function() {
        return G;
      }), l.d(d, "getAxisAngle", function() {
        return y;
      }), l.d(d, "getAngle", function() {
        return a;
      }), l.d(d, "multiply", function() {
        return I;
      }), l.d(d, "rotateX", function() {
        return h;
      }), l.d(d, "rotateY", function() {
        return S;
      }), l.d(d, "rotateZ", function() {
        return p;
      }), l.d(d, "calculateW", function() {
        return X;
      }), l.d(d, "exp", function() {
        return V;
      }), l.d(d, "ln", function() {
        return i;
      }), l.d(d, "pow", function() {
        return b;
      }), l.d(d, "slerp", function() {
        return t;
      }), l.d(d, "random", function() {
        return m;
      }), l.d(d, "invert", function() {
        return R;
      }), l.d(d, "conjugate", function() {
        return x;
      }), l.d(d, "fromMat3", function() {
        return C;
      }), l.d(d, "fromEuler", function() {
        return T;
      }), l.d(d, "str", function() {
        return K;
      }), l.d(d, "clone", function() {
        return J;
      }), l.d(d, "fromValues", function() {
        return F;
      }), l.d(d, "copy", function() {
        return r;
      }), l.d(d, "set", function() {
        return Y;
      }), l.d(d, "add", function() {
        return H;
      }), l.d(d, "mul", function() {
        return Q;
      }), l.d(d, "scale", function() {
        return w;
      }), l.d(d, "dot", function() {
        return O;
      }), l.d(d, "lerp", function() {
        return q;
      }), l.d(d, "length", function() {
        return k;
      }), l.d(d, "len", function() {
        return P;
      }), l.d(d, "squaredLength", function() {
        return D;
      }), l.d(d, "sqrLen", function() {
        return ll;
      }), l.d(d, "normalize", function() {
        return _;
      }), l.d(d, "exactEquals", function() {
        return bl;
      }), l.d(d, "equals", function() {
        return $;
      }), l.d(d, "rotationTo", function() {
        return el;
      }), l.d(d, "sqlerp", function() {
        return nl;
      }), l.d(d, "setAxes", function() {
        return z;
      });
      var s = l(2), c = l(5), W = l(8), u = l(9);
      function e() {
        var M = new s.ARRAY_TYPE(4);
        return s.ARRAY_TYPE != Float32Array && (M[0] = 0, M[1] = 0, M[2] = 0), M[3] = 1, M;
      }
      function n(M) {
        return M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 1, M;
      }
      function G(M, E, B) {
        B = B * 0.5;
        var g = Math.sin(B);
        return M[0] = g * E[0], M[1] = g * E[1], M[2] = g * E[2], M[3] = Math.cos(B), M;
      }
      function y(M, E) {
        var B = Math.acos(E[3]) * 2, g = Math.sin(B / 2);
        return g > s.EPSILON ? (M[0] = E[0] / g, M[1] = E[1] / g, M[2] = E[2] / g) : (M[0] = 1, M[1] = 0, M[2] = 0), B;
      }
      function a(M, E) {
        var B = O(M, E);
        return Math.acos(2 * B * B - 1);
      }
      function I(M, E, B) {
        var g = E[0], U = E[1], o = E[2], L = E[3], N = B[0], v = B[1], f = B[2], j = B[3];
        return M[0] = g * j + L * N + U * f - o * v, M[1] = U * j + L * v + o * N - g * f, M[2] = o * j + L * f + g * v - U * N, M[3] = L * j - g * N - U * v - o * f, M;
      }
      function h(M, E, B) {
        B *= 0.5;
        var g = E[0], U = E[1], o = E[2], L = E[3], N = Math.sin(B), v = Math.cos(B);
        return M[0] = g * v + L * N, M[1] = U * v + o * N, M[2] = o * v - U * N, M[3] = L * v - g * N, M;
      }
      function S(M, E, B) {
        B *= 0.5;
        var g = E[0], U = E[1], o = E[2], L = E[3], N = Math.sin(B), v = Math.cos(B);
        return M[0] = g * v - o * N, M[1] = U * v + L * N, M[2] = o * v + g * N, M[3] = L * v - U * N, M;
      }
      function p(M, E, B) {
        B *= 0.5;
        var g = E[0], U = E[1], o = E[2], L = E[3], N = Math.sin(B), v = Math.cos(B);
        return M[0] = g * v + U * N, M[1] = U * v - g * N, M[2] = o * v + L * N, M[3] = L * v - o * N, M;
      }
      function X(M, E) {
        var B = E[0], g = E[1], U = E[2];
        return M[0] = B, M[1] = g, M[2] = U, M[3] = Math.sqrt(Math.abs(1 - B * B - g * g - U * U)), M;
      }
      function V(M, E) {
        var B = E[0], g = E[1], U = E[2], o = E[3], L = Math.sqrt(B * B + g * g + U * U), N = Math.exp(o), v = L > 0 ? N * Math.sin(L) / L : 0;
        return M[0] = B * v, M[1] = g * v, M[2] = U * v, M[3] = N * Math.cos(L), M;
      }
      function i(M, E) {
        var B = E[0], g = E[1], U = E[2], o = E[3], L = Math.sqrt(B * B + g * g + U * U), N = L > 0 ? Math.atan2(L, o) / L : 0;
        return M[0] = B * N, M[1] = g * N, M[2] = U * N, M[3] = 0.5 * Math.log(B * B + g * g + U * U + o * o), M;
      }
      function b(M, E, B) {
        return i(M, E), w(M, M, B), V(M, M), M;
      }
      function t(M, E, B, g) {
        var U = E[0], o = E[1], L = E[2], N = E[3], v = B[0], f = B[1], j = B[2], A = B[3], dl, il, cl, ml, tl;
        return il = U * v + o * f + L * j + N * A, il < 0 && (il = -il, v = -v, f = -f, j = -j, A = -A), 1 - il > s.EPSILON ? (dl = Math.acos(il), cl = Math.sin(dl), ml = Math.sin((1 - g) * dl) / cl, tl = Math.sin(g * dl) / cl) : (ml = 1 - g, tl = g), M[0] = ml * U + tl * v, M[1] = ml * o + tl * f, M[2] = ml * L + tl * j, M[3] = ml * N + tl * A, M;
      }
      function m(M) {
        var E = s.RANDOM(), B = s.RANDOM(), g = s.RANDOM(), U = Math.sqrt(1 - E), o = Math.sqrt(E);
        return M[0] = U * Math.sin(2 * Math.PI * B), M[1] = U * Math.cos(2 * Math.PI * B), M[2] = o * Math.sin(2 * Math.PI * g), M[3] = o * Math.cos(2 * Math.PI * g), M;
      }
      function R(M, E) {
        var B = E[0], g = E[1], U = E[2], o = E[3], L = B * B + g * g + U * U + o * o, N = L ? 1 / L : 0;
        return M[0] = -B * N, M[1] = -g * N, M[2] = -U * N, M[3] = o * N, M;
      }
      function x(M, E) {
        return M[0] = -E[0], M[1] = -E[1], M[2] = -E[2], M[3] = E[3], M;
      }
      function C(M, E) {
        var B = E[0] + E[4] + E[8], g;
        if (B > 0)
          g = Math.sqrt(B + 1), M[3] = 0.5 * g, g = 0.5 / g, M[0] = (E[5] - E[7]) * g, M[1] = (E[6] - E[2]) * g, M[2] = (E[1] - E[3]) * g;
        else {
          var U = 0;
          E[4] > E[0] && (U = 1), E[8] > E[U * 3 + U] && (U = 2);
          var o = (U + 1) % 3, L = (U + 2) % 3;
          g = Math.sqrt(E[U * 3 + U] - E[o * 3 + o] - E[L * 3 + L] + 1), M[U] = 0.5 * g, g = 0.5 / g, M[3] = (E[o * 3 + L] - E[L * 3 + o]) * g, M[o] = (E[o * 3 + U] + E[U * 3 + o]) * g, M[L] = (E[L * 3 + U] + E[U * 3 + L]) * g;
        }
        return M;
      }
      function T(M, E, B, g) {
        var U = 0.5 * Math.PI / 180;
        E *= U, B *= U, g *= U;
        var o = Math.sin(E), L = Math.cos(E), N = Math.sin(B), v = Math.cos(B), f = Math.sin(g), j = Math.cos(g);
        return M[0] = o * v * j - L * N * f, M[1] = L * N * j + o * v * f, M[2] = L * v * f - o * N * j, M[3] = L * v * j + o * N * f, M;
      }
      function K(M) {
        return "quat(" + M[0] + ", " + M[1] + ", " + M[2] + ", " + M[3] + ")";
      }
      var J = u.clone, F = u.fromValues, r = u.copy, Y = u.set, H = u.add, Q = I, w = u.scale, O = u.dot, q = u.lerp, k = u.length, P = k, D = u.squaredLength, ll = D, _ = u.normalize, bl = u.exactEquals, $ = u.equals, el = function() {
        var M = W.create(), E = W.fromValues(1, 0, 0), B = W.fromValues(0, 1, 0);
        return function(g, U, o) {
          var L = W.dot(U, o);
          return L < -0.999999 ? (W.cross(M, E, U), W.len(M) < 1e-6 && W.cross(M, B, U), W.normalize(M, M), G(g, M, Math.PI), g) : L > 0.999999 ? (g[0] = 0, g[1] = 0, g[2] = 0, g[3] = 1, g) : (W.cross(M, U, o), g[0] = M[0], g[1] = M[1], g[2] = M[2], g[3] = 1 + L, _(g, g));
        };
      }(), nl = function() {
        var M = e(), E = e();
        return function(B, g, U, o, L, N) {
          return t(M, g, L, N), t(E, U, o, N), t(B, M, E, 2 * N * (1 - N)), B;
        };
      }(), z = function() {
        var M = c.create();
        return function(E, B, g, U) {
          return M[0] = g[0], M[3] = g[1], M[6] = g[2], M[1] = U[0], M[4] = U[1], M[7] = U[2], M[2] = -B[0], M[5] = -B[1], M[8] = -B[2], _(E, C(E, M));
        };
      }();
    },
    /* 8 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return c;
      }), l.d(d, "clone", function() {
        return W;
      }), l.d(d, "length", function() {
        return u;
      }), l.d(d, "fromValues", function() {
        return e;
      }), l.d(d, "copy", function() {
        return n;
      }), l.d(d, "set", function() {
        return G;
      }), l.d(d, "add", function() {
        return y;
      }), l.d(d, "subtract", function() {
        return a;
      }), l.d(d, "multiply", function() {
        return I;
      }), l.d(d, "divide", function() {
        return h;
      }), l.d(d, "ceil", function() {
        return S;
      }), l.d(d, "floor", function() {
        return p;
      }), l.d(d, "min", function() {
        return X;
      }), l.d(d, "max", function() {
        return V;
      }), l.d(d, "round", function() {
        return i;
      }), l.d(d, "scale", function() {
        return b;
      }), l.d(d, "scaleAndAdd", function() {
        return t;
      }), l.d(d, "distance", function() {
        return m;
      }), l.d(d, "squaredDistance", function() {
        return R;
      }), l.d(d, "squaredLength", function() {
        return x;
      }), l.d(d, "negate", function() {
        return C;
      }), l.d(d, "inverse", function() {
        return T;
      }), l.d(d, "normalize", function() {
        return K;
      }), l.d(d, "dot", function() {
        return J;
      }), l.d(d, "cross", function() {
        return F;
      }), l.d(d, "lerp", function() {
        return r;
      }), l.d(d, "hermite", function() {
        return Y;
      }), l.d(d, "bezier", function() {
        return H;
      }), l.d(d, "random", function() {
        return Q;
      }), l.d(d, "transformMat4", function() {
        return w;
      }), l.d(d, "transformMat3", function() {
        return O;
      }), l.d(d, "transformQuat", function() {
        return q;
      }), l.d(d, "rotateX", function() {
        return k;
      }), l.d(d, "rotateY", function() {
        return P;
      }), l.d(d, "rotateZ", function() {
        return D;
      }), l.d(d, "angle", function() {
        return ll;
      }), l.d(d, "zero", function() {
        return _;
      }), l.d(d, "str", function() {
        return bl;
      }), l.d(d, "exactEquals", function() {
        return $;
      }), l.d(d, "equals", function() {
        return el;
      }), l.d(d, "sub", function() {
        return nl;
      }), l.d(d, "mul", function() {
        return z;
      }), l.d(d, "div", function() {
        return M;
      }), l.d(d, "dist", function() {
        return E;
      }), l.d(d, "sqrDist", function() {
        return B;
      }), l.d(d, "len", function() {
        return g;
      }), l.d(d, "sqrLen", function() {
        return U;
      }), l.d(d, "forEach", function() {
        return o;
      });
      var s = l(2);
      function c() {
        var L = new s.ARRAY_TYPE(3);
        return s.ARRAY_TYPE != Float32Array && (L[0] = 0, L[1] = 0, L[2] = 0), L;
      }
      function W(L) {
        var N = new s.ARRAY_TYPE(3);
        return N[0] = L[0], N[1] = L[1], N[2] = L[2], N;
      }
      function u(L) {
        var N = L[0], v = L[1], f = L[2];
        return Math.hypot(N, v, f);
      }
      function e(L, N, v) {
        var f = new s.ARRAY_TYPE(3);
        return f[0] = L, f[1] = N, f[2] = v, f;
      }
      function n(L, N) {
        return L[0] = N[0], L[1] = N[1], L[2] = N[2], L;
      }
      function G(L, N, v, f) {
        return L[0] = N, L[1] = v, L[2] = f, L;
      }
      function y(L, N, v) {
        return L[0] = N[0] + v[0], L[1] = N[1] + v[1], L[2] = N[2] + v[2], L;
      }
      function a(L, N, v) {
        return L[0] = N[0] - v[0], L[1] = N[1] - v[1], L[2] = N[2] - v[2], L;
      }
      function I(L, N, v) {
        return L[0] = N[0] * v[0], L[1] = N[1] * v[1], L[2] = N[2] * v[2], L;
      }
      function h(L, N, v) {
        return L[0] = N[0] / v[0], L[1] = N[1] / v[1], L[2] = N[2] / v[2], L;
      }
      function S(L, N) {
        return L[0] = Math.ceil(N[0]), L[1] = Math.ceil(N[1]), L[2] = Math.ceil(N[2]), L;
      }
      function p(L, N) {
        return L[0] = Math.floor(N[0]), L[1] = Math.floor(N[1]), L[2] = Math.floor(N[2]), L;
      }
      function X(L, N, v) {
        return L[0] = Math.min(N[0], v[0]), L[1] = Math.min(N[1], v[1]), L[2] = Math.min(N[2], v[2]), L;
      }
      function V(L, N, v) {
        return L[0] = Math.max(N[0], v[0]), L[1] = Math.max(N[1], v[1]), L[2] = Math.max(N[2], v[2]), L;
      }
      function i(L, N) {
        return L[0] = Math.round(N[0]), L[1] = Math.round(N[1]), L[2] = Math.round(N[2]), L;
      }
      function b(L, N, v) {
        return L[0] = N[0] * v, L[1] = N[1] * v, L[2] = N[2] * v, L;
      }
      function t(L, N, v, f) {
        return L[0] = N[0] + v[0] * f, L[1] = N[1] + v[1] * f, L[2] = N[2] + v[2] * f, L;
      }
      function m(L, N) {
        var v = N[0] - L[0], f = N[1] - L[1], j = N[2] - L[2];
        return Math.hypot(v, f, j);
      }
      function R(L, N) {
        var v = N[0] - L[0], f = N[1] - L[1], j = N[2] - L[2];
        return v * v + f * f + j * j;
      }
      function x(L) {
        var N = L[0], v = L[1], f = L[2];
        return N * N + v * v + f * f;
      }
      function C(L, N) {
        return L[0] = -N[0], L[1] = -N[1], L[2] = -N[2], L;
      }
      function T(L, N) {
        return L[0] = 1 / N[0], L[1] = 1 / N[1], L[2] = 1 / N[2], L;
      }
      function K(L, N) {
        var v = N[0], f = N[1], j = N[2], A = v * v + f * f + j * j;
        return A > 0 && (A = 1 / Math.sqrt(A)), L[0] = N[0] * A, L[1] = N[1] * A, L[2] = N[2] * A, L;
      }
      function J(L, N) {
        return L[0] * N[0] + L[1] * N[1] + L[2] * N[2];
      }
      function F(L, N, v) {
        var f = N[0], j = N[1], A = N[2], dl = v[0], il = v[1], cl = v[2];
        return L[0] = j * cl - A * il, L[1] = A * dl - f * cl, L[2] = f * il - j * dl, L;
      }
      function r(L, N, v, f) {
        var j = N[0], A = N[1], dl = N[2];
        return L[0] = j + f * (v[0] - j), L[1] = A + f * (v[1] - A), L[2] = dl + f * (v[2] - dl), L;
      }
      function Y(L, N, v, f, j, A) {
        var dl = A * A, il = dl * (2 * A - 3) + 1, cl = dl * (A - 2) + A, ml = dl * (A - 1), tl = dl * (3 - 2 * A);
        return L[0] = N[0] * il + v[0] * cl + f[0] * ml + j[0] * tl, L[1] = N[1] * il + v[1] * cl + f[1] * ml + j[1] * tl, L[2] = N[2] * il + v[2] * cl + f[2] * ml + j[2] * tl, L;
      }
      function H(L, N, v, f, j, A) {
        var dl = 1 - A, il = dl * dl, cl = A * A, ml = il * dl, tl = 3 * A * il, sl = 3 * cl * dl, Zl = cl * A;
        return L[0] = N[0] * ml + v[0] * tl + f[0] * sl + j[0] * Zl, L[1] = N[1] * ml + v[1] * tl + f[1] * sl + j[1] * Zl, L[2] = N[2] * ml + v[2] * tl + f[2] * sl + j[2] * Zl, L;
      }
      function Q(L, N) {
        N = N || 1;
        var v = s.RANDOM() * 2 * Math.PI, f = s.RANDOM() * 2 - 1, j = Math.sqrt(1 - f * f) * N;
        return L[0] = Math.cos(v) * j, L[1] = Math.sin(v) * j, L[2] = f * N, L;
      }
      function w(L, N, v) {
        var f = N[0], j = N[1], A = N[2], dl = v[3] * f + v[7] * j + v[11] * A + v[15];
        return dl = dl || 1, L[0] = (v[0] * f + v[4] * j + v[8] * A + v[12]) / dl, L[1] = (v[1] * f + v[5] * j + v[9] * A + v[13]) / dl, L[2] = (v[2] * f + v[6] * j + v[10] * A + v[14]) / dl, L;
      }
      function O(L, N, v) {
        var f = N[0], j = N[1], A = N[2];
        return L[0] = f * v[0] + j * v[3] + A * v[6], L[1] = f * v[1] + j * v[4] + A * v[7], L[2] = f * v[2] + j * v[5] + A * v[8], L;
      }
      function q(L, N, v) {
        var f = v[0], j = v[1], A = v[2], dl = v[3], il = N[0], cl = N[1], ml = N[2], tl = j * ml - A * cl, sl = A * il - f * ml, Zl = f * cl - j * il, al = j * Zl - A * sl, ol = A * tl - f * Zl, Xl = f * sl - j * tl, Gl = dl * 2;
        return tl *= Gl, sl *= Gl, Zl *= Gl, al *= 2, ol *= 2, Xl *= 2, L[0] = il + tl + al, L[1] = cl + sl + ol, L[2] = ml + Zl + Xl, L;
      }
      function k(L, N, v, f) {
        var j = [], A = [];
        return j[0] = N[0] - v[0], j[1] = N[1] - v[1], j[2] = N[2] - v[2], A[0] = j[0], A[1] = j[1] * Math.cos(f) - j[2] * Math.sin(f), A[2] = j[1] * Math.sin(f) + j[2] * Math.cos(f), L[0] = A[0] + v[0], L[1] = A[1] + v[1], L[2] = A[2] + v[2], L;
      }
      function P(L, N, v, f) {
        var j = [], A = [];
        return j[0] = N[0] - v[0], j[1] = N[1] - v[1], j[2] = N[2] - v[2], A[0] = j[2] * Math.sin(f) + j[0] * Math.cos(f), A[1] = j[1], A[2] = j[2] * Math.cos(f) - j[0] * Math.sin(f), L[0] = A[0] + v[0], L[1] = A[1] + v[1], L[2] = A[2] + v[2], L;
      }
      function D(L, N, v, f) {
        var j = [], A = [];
        return j[0] = N[0] - v[0], j[1] = N[1] - v[1], j[2] = N[2] - v[2], A[0] = j[0] * Math.cos(f) - j[1] * Math.sin(f), A[1] = j[0] * Math.sin(f) + j[1] * Math.cos(f), A[2] = j[2], L[0] = A[0] + v[0], L[1] = A[1] + v[1], L[2] = A[2] + v[2], L;
      }
      function ll(L, N) {
        var v = L[0], f = L[1], j = L[2], A = N[0], dl = N[1], il = N[2], cl = Math.sqrt(v * v + f * f + j * j), ml = Math.sqrt(A * A + dl * dl + il * il), tl = cl * ml, sl = tl && J(L, N) / tl;
        return Math.acos(Math.min(Math.max(sl, -1), 1));
      }
      function _(L) {
        return L[0] = 0, L[1] = 0, L[2] = 0, L;
      }
      function bl(L) {
        return "vec3(" + L[0] + ", " + L[1] + ", " + L[2] + ")";
      }
      function $(L, N) {
        return L[0] === N[0] && L[1] === N[1] && L[2] === N[2];
      }
      function el(L, N) {
        var v = L[0], f = L[1], j = L[2], A = N[0], dl = N[1], il = N[2];
        return Math.abs(v - A) <= s.EPSILON * Math.max(1, Math.abs(v), Math.abs(A)) && Math.abs(f - dl) <= s.EPSILON * Math.max(1, Math.abs(f), Math.abs(dl)) && Math.abs(j - il) <= s.EPSILON * Math.max(1, Math.abs(j), Math.abs(il));
      }
      var nl = a, z = I, M = h, E = m, B = R, g = u, U = x, o = function() {
        var L = c();
        return function(N, v, f, j, A, dl) {
          var il, cl;
          for (v || (v = 3), f || (f = 0), j ? cl = Math.min(j * v + f, N.length) : cl = N.length, il = f; il < cl; il += v)
            L[0] = N[il], L[1] = N[il + 1], L[2] = N[il + 2], A(L, L, dl), N[il] = L[0], N[il + 1] = L[1], N[il + 2] = L[2];
          return N;
        };
      }();
    },
    /* 9 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return c;
      }), l.d(d, "clone", function() {
        return W;
      }), l.d(d, "fromValues", function() {
        return u;
      }), l.d(d, "copy", function() {
        return e;
      }), l.d(d, "set", function() {
        return n;
      }), l.d(d, "add", function() {
        return G;
      }), l.d(d, "subtract", function() {
        return y;
      }), l.d(d, "multiply", function() {
        return a;
      }), l.d(d, "divide", function() {
        return I;
      }), l.d(d, "ceil", function() {
        return h;
      }), l.d(d, "floor", function() {
        return S;
      }), l.d(d, "min", function() {
        return p;
      }), l.d(d, "max", function() {
        return X;
      }), l.d(d, "round", function() {
        return V;
      }), l.d(d, "scale", function() {
        return i;
      }), l.d(d, "scaleAndAdd", function() {
        return b;
      }), l.d(d, "distance", function() {
        return t;
      }), l.d(d, "squaredDistance", function() {
        return m;
      }), l.d(d, "length", function() {
        return R;
      }), l.d(d, "squaredLength", function() {
        return x;
      }), l.d(d, "negate", function() {
        return C;
      }), l.d(d, "inverse", function() {
        return T;
      }), l.d(d, "normalize", function() {
        return K;
      }), l.d(d, "dot", function() {
        return J;
      }), l.d(d, "cross", function() {
        return F;
      }), l.d(d, "lerp", function() {
        return r;
      }), l.d(d, "random", function() {
        return Y;
      }), l.d(d, "transformMat4", function() {
        return H;
      }), l.d(d, "transformQuat", function() {
        return Q;
      }), l.d(d, "zero", function() {
        return w;
      }), l.d(d, "str", function() {
        return O;
      }), l.d(d, "exactEquals", function() {
        return q;
      }), l.d(d, "equals", function() {
        return k;
      }), l.d(d, "sub", function() {
        return P;
      }), l.d(d, "mul", function() {
        return D;
      }), l.d(d, "div", function() {
        return ll;
      }), l.d(d, "dist", function() {
        return _;
      }), l.d(d, "sqrDist", function() {
        return bl;
      }), l.d(d, "len", function() {
        return $;
      }), l.d(d, "sqrLen", function() {
        return el;
      }), l.d(d, "forEach", function() {
        return nl;
      });
      var s = l(2);
      function c() {
        var z = new s.ARRAY_TYPE(4);
        return s.ARRAY_TYPE != Float32Array && (z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 0), z;
      }
      function W(z) {
        var M = new s.ARRAY_TYPE(4);
        return M[0] = z[0], M[1] = z[1], M[2] = z[2], M[3] = z[3], M;
      }
      function u(z, M, E, B) {
        var g = new s.ARRAY_TYPE(4);
        return g[0] = z, g[1] = M, g[2] = E, g[3] = B, g;
      }
      function e(z, M) {
        return z[0] = M[0], z[1] = M[1], z[2] = M[2], z[3] = M[3], z;
      }
      function n(z, M, E, B, g) {
        return z[0] = M, z[1] = E, z[2] = B, z[3] = g, z;
      }
      function G(z, M, E) {
        return z[0] = M[0] + E[0], z[1] = M[1] + E[1], z[2] = M[2] + E[2], z[3] = M[3] + E[3], z;
      }
      function y(z, M, E) {
        return z[0] = M[0] - E[0], z[1] = M[1] - E[1], z[2] = M[2] - E[2], z[3] = M[3] - E[3], z;
      }
      function a(z, M, E) {
        return z[0] = M[0] * E[0], z[1] = M[1] * E[1], z[2] = M[2] * E[2], z[3] = M[3] * E[3], z;
      }
      function I(z, M, E) {
        return z[0] = M[0] / E[0], z[1] = M[1] / E[1], z[2] = M[2] / E[2], z[3] = M[3] / E[3], z;
      }
      function h(z, M) {
        return z[0] = Math.ceil(M[0]), z[1] = Math.ceil(M[1]), z[2] = Math.ceil(M[2]), z[3] = Math.ceil(M[3]), z;
      }
      function S(z, M) {
        return z[0] = Math.floor(M[0]), z[1] = Math.floor(M[1]), z[2] = Math.floor(M[2]), z[3] = Math.floor(M[3]), z;
      }
      function p(z, M, E) {
        return z[0] = Math.min(M[0], E[0]), z[1] = Math.min(M[1], E[1]), z[2] = Math.min(M[2], E[2]), z[3] = Math.min(M[3], E[3]), z;
      }
      function X(z, M, E) {
        return z[0] = Math.max(M[0], E[0]), z[1] = Math.max(M[1], E[1]), z[2] = Math.max(M[2], E[2]), z[3] = Math.max(M[3], E[3]), z;
      }
      function V(z, M) {
        return z[0] = Math.round(M[0]), z[1] = Math.round(M[1]), z[2] = Math.round(M[2]), z[3] = Math.round(M[3]), z;
      }
      function i(z, M, E) {
        return z[0] = M[0] * E, z[1] = M[1] * E, z[2] = M[2] * E, z[3] = M[3] * E, z;
      }
      function b(z, M, E, B) {
        return z[0] = M[0] + E[0] * B, z[1] = M[1] + E[1] * B, z[2] = M[2] + E[2] * B, z[3] = M[3] + E[3] * B, z;
      }
      function t(z, M) {
        var E = M[0] - z[0], B = M[1] - z[1], g = M[2] - z[2], U = M[3] - z[3];
        return Math.hypot(E, B, g, U);
      }
      function m(z, M) {
        var E = M[0] - z[0], B = M[1] - z[1], g = M[2] - z[2], U = M[3] - z[3];
        return E * E + B * B + g * g + U * U;
      }
      function R(z) {
        var M = z[0], E = z[1], B = z[2], g = z[3];
        return Math.hypot(M, E, B, g);
      }
      function x(z) {
        var M = z[0], E = z[1], B = z[2], g = z[3];
        return M * M + E * E + B * B + g * g;
      }
      function C(z, M) {
        return z[0] = -M[0], z[1] = -M[1], z[2] = -M[2], z[3] = -M[3], z;
      }
      function T(z, M) {
        return z[0] = 1 / M[0], z[1] = 1 / M[1], z[2] = 1 / M[2], z[3] = 1 / M[3], z;
      }
      function K(z, M) {
        var E = M[0], B = M[1], g = M[2], U = M[3], o = E * E + B * B + g * g + U * U;
        return o > 0 && (o = 1 / Math.sqrt(o)), z[0] = E * o, z[1] = B * o, z[2] = g * o, z[3] = U * o, z;
      }
      function J(z, M) {
        return z[0] * M[0] + z[1] * M[1] + z[2] * M[2] + z[3] * M[3];
      }
      function F(z, M, E, B) {
        var g = E[0] * B[1] - E[1] * B[0], U = E[0] * B[2] - E[2] * B[0], o = E[0] * B[3] - E[3] * B[0], L = E[1] * B[2] - E[2] * B[1], N = E[1] * B[3] - E[3] * B[1], v = E[2] * B[3] - E[3] * B[2], f = M[0], j = M[1], A = M[2], dl = M[3];
        return z[0] = j * v - A * N + dl * L, z[1] = -(f * v) + A * o - dl * U, z[2] = f * N - j * o + dl * g, z[3] = -(f * L) + j * U - A * g, z;
      }
      function r(z, M, E, B) {
        var g = M[0], U = M[1], o = M[2], L = M[3];
        return z[0] = g + B * (E[0] - g), z[1] = U + B * (E[1] - U), z[2] = o + B * (E[2] - o), z[3] = L + B * (E[3] - L), z;
      }
      function Y(z, M) {
        M = M || 1;
        var E, B, g, U, o, L;
        do
          E = s.RANDOM() * 2 - 1, B = s.RANDOM() * 2 - 1, o = E * E + B * B;
        while (o >= 1);
        do
          g = s.RANDOM() * 2 - 1, U = s.RANDOM() * 2 - 1, L = g * g + U * U;
        while (L >= 1);
        var N = Math.sqrt((1 - o) / L);
        return z[0] = M * E, z[1] = M * B, z[2] = M * g * N, z[3] = M * U * N, z;
      }
      function H(z, M, E) {
        var B = M[0], g = M[1], U = M[2], o = M[3];
        return z[0] = E[0] * B + E[4] * g + E[8] * U + E[12] * o, z[1] = E[1] * B + E[5] * g + E[9] * U + E[13] * o, z[2] = E[2] * B + E[6] * g + E[10] * U + E[14] * o, z[3] = E[3] * B + E[7] * g + E[11] * U + E[15] * o, z;
      }
      function Q(z, M, E) {
        var B = M[0], g = M[1], U = M[2], o = E[0], L = E[1], N = E[2], v = E[3], f = v * B + L * U - N * g, j = v * g + N * B - o * U, A = v * U + o * g - L * B, dl = -o * B - L * g - N * U;
        return z[0] = f * v + dl * -o + j * -N - A * -L, z[1] = j * v + dl * -L + A * -o - f * -N, z[2] = A * v + dl * -N + f * -L - j * -o, z[3] = M[3], z;
      }
      function w(z) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 0, z;
      }
      function O(z) {
        return "vec4(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ")";
      }
      function q(z, M) {
        return z[0] === M[0] && z[1] === M[1] && z[2] === M[2] && z[3] === M[3];
      }
      function k(z, M) {
        var E = z[0], B = z[1], g = z[2], U = z[3], o = M[0], L = M[1], N = M[2], v = M[3];
        return Math.abs(E - o) <= s.EPSILON * Math.max(1, Math.abs(E), Math.abs(o)) && Math.abs(B - L) <= s.EPSILON * Math.max(1, Math.abs(B), Math.abs(L)) && Math.abs(g - N) <= s.EPSILON * Math.max(1, Math.abs(g), Math.abs(N)) && Math.abs(U - v) <= s.EPSILON * Math.max(1, Math.abs(U), Math.abs(v));
      }
      var P = y, D = a, ll = I, _ = t, bl = m, $ = R, el = x, nl = function() {
        var z = c();
        return function(M, E, B, g, U, o) {
          var L, N;
          for (E || (E = 4), B || (B = 0), g ? N = Math.min(g * E + B, M.length) : N = M.length, L = B; L < N; L += E)
            z[0] = M[L], z[1] = M[L + 1], z[2] = M[L + 2], z[3] = M[L + 3], U(z, z, o), M[L] = z[0], M[L + 1] = z[1], M[L + 2] = z[2], M[L + 3] = z[3];
          return M;
        };
      }();
    },
    /* 10 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return u;
      }), l.d(d, "clone", function() {
        return e;
      }), l.d(d, "fromValues", function() {
        return n;
      }), l.d(d, "fromRotationTranslationValues", function() {
        return G;
      }), l.d(d, "fromRotationTranslation", function() {
        return y;
      }), l.d(d, "fromTranslation", function() {
        return a;
      }), l.d(d, "fromRotation", function() {
        return I;
      }), l.d(d, "fromMat4", function() {
        return h;
      }), l.d(d, "copy", function() {
        return S;
      }), l.d(d, "identity", function() {
        return p;
      }), l.d(d, "set", function() {
        return X;
      }), l.d(d, "getReal", function() {
        return V;
      }), l.d(d, "getDual", function() {
        return i;
      }), l.d(d, "setReal", function() {
        return b;
      }), l.d(d, "setDual", function() {
        return t;
      }), l.d(d, "getTranslation", function() {
        return m;
      }), l.d(d, "translate", function() {
        return R;
      }), l.d(d, "rotateX", function() {
        return x;
      }), l.d(d, "rotateY", function() {
        return C;
      }), l.d(d, "rotateZ", function() {
        return T;
      }), l.d(d, "rotateByQuatAppend", function() {
        return K;
      }), l.d(d, "rotateByQuatPrepend", function() {
        return J;
      }), l.d(d, "rotateAroundAxis", function() {
        return F;
      }), l.d(d, "add", function() {
        return r;
      }), l.d(d, "multiply", function() {
        return Y;
      }), l.d(d, "mul", function() {
        return H;
      }), l.d(d, "scale", function() {
        return Q;
      }), l.d(d, "dot", function() {
        return w;
      }), l.d(d, "lerp", function() {
        return O;
      }), l.d(d, "invert", function() {
        return q;
      }), l.d(d, "conjugate", function() {
        return k;
      }), l.d(d, "length", function() {
        return P;
      }), l.d(d, "len", function() {
        return D;
      }), l.d(d, "squaredLength", function() {
        return ll;
      }), l.d(d, "sqrLen", function() {
        return _;
      }), l.d(d, "normalize", function() {
        return bl;
      }), l.d(d, "str", function() {
        return $;
      }), l.d(d, "exactEquals", function() {
        return el;
      }), l.d(d, "equals", function() {
        return nl;
      });
      var s = l(2), c = l(7), W = l(6);
      function u() {
        var z = new s.ARRAY_TYPE(8);
        return s.ARRAY_TYPE != Float32Array && (z[0] = 0, z[1] = 0, z[2] = 0, z[4] = 0, z[5] = 0, z[6] = 0, z[7] = 0), z[3] = 1, z;
      }
      function e(z) {
        var M = new s.ARRAY_TYPE(8);
        return M[0] = z[0], M[1] = z[1], M[2] = z[2], M[3] = z[3], M[4] = z[4], M[5] = z[5], M[6] = z[6], M[7] = z[7], M;
      }
      function n(z, M, E, B, g, U, o, L) {
        var N = new s.ARRAY_TYPE(8);
        return N[0] = z, N[1] = M, N[2] = E, N[3] = B, N[4] = g, N[5] = U, N[6] = o, N[7] = L, N;
      }
      function G(z, M, E, B, g, U, o) {
        var L = new s.ARRAY_TYPE(8);
        L[0] = z, L[1] = M, L[2] = E, L[3] = B;
        var N = g * 0.5, v = U * 0.5, f = o * 0.5;
        return L[4] = N * B + v * E - f * M, L[5] = v * B + f * z - N * E, L[6] = f * B + N * M - v * z, L[7] = -N * z - v * M - f * E, L;
      }
      function y(z, M, E) {
        var B = E[0] * 0.5, g = E[1] * 0.5, U = E[2] * 0.5, o = M[0], L = M[1], N = M[2], v = M[3];
        return z[0] = o, z[1] = L, z[2] = N, z[3] = v, z[4] = B * v + g * N - U * L, z[5] = g * v + U * o - B * N, z[6] = U * v + B * L - g * o, z[7] = -B * o - g * L - U * N, z;
      }
      function a(z, M) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z[4] = M[0] * 0.5, z[5] = M[1] * 0.5, z[6] = M[2] * 0.5, z[7] = 0, z;
      }
      function I(z, M) {
        return z[0] = M[0], z[1] = M[1], z[2] = M[2], z[3] = M[3], z[4] = 0, z[5] = 0, z[6] = 0, z[7] = 0, z;
      }
      function h(z, M) {
        var E = c.create();
        W.getRotation(E, M);
        var B = new s.ARRAY_TYPE(3);
        return W.getTranslation(B, M), y(z, E, B), z;
      }
      function S(z, M) {
        return z[0] = M[0], z[1] = M[1], z[2] = M[2], z[3] = M[3], z[4] = M[4], z[5] = M[5], z[6] = M[6], z[7] = M[7], z;
      }
      function p(z) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z[4] = 0, z[5] = 0, z[6] = 0, z[7] = 0, z;
      }
      function X(z, M, E, B, g, U, o, L, N) {
        return z[0] = M, z[1] = E, z[2] = B, z[3] = g, z[4] = U, z[5] = o, z[6] = L, z[7] = N, z;
      }
      var V = c.copy;
      function i(z, M) {
        return z[0] = M[4], z[1] = M[5], z[2] = M[6], z[3] = M[7], z;
      }
      var b = c.copy;
      function t(z, M) {
        return z[4] = M[0], z[5] = M[1], z[6] = M[2], z[7] = M[3], z;
      }
      function m(z, M) {
        var E = M[4], B = M[5], g = M[6], U = M[7], o = -M[0], L = -M[1], N = -M[2], v = M[3];
        return z[0] = (E * v + U * o + B * N - g * L) * 2, z[1] = (B * v + U * L + g * o - E * N) * 2, z[2] = (g * v + U * N + E * L - B * o) * 2, z;
      }
      function R(z, M, E) {
        var B = M[0], g = M[1], U = M[2], o = M[3], L = E[0] * 0.5, N = E[1] * 0.5, v = E[2] * 0.5, f = M[4], j = M[5], A = M[6], dl = M[7];
        return z[0] = B, z[1] = g, z[2] = U, z[3] = o, z[4] = o * L + g * v - U * N + f, z[5] = o * N + U * L - B * v + j, z[6] = o * v + B * N - g * L + A, z[7] = -B * L - g * N - U * v + dl, z;
      }
      function x(z, M, E) {
        var B = -M[0], g = -M[1], U = -M[2], o = M[3], L = M[4], N = M[5], v = M[6], f = M[7], j = L * o + f * B + N * U - v * g, A = N * o + f * g + v * B - L * U, dl = v * o + f * U + L * g - N * B, il = f * o - L * B - N * g - v * U;
        return c.rotateX(z, M, E), B = z[0], g = z[1], U = z[2], o = z[3], z[4] = j * o + il * B + A * U - dl * g, z[5] = A * o + il * g + dl * B - j * U, z[6] = dl * o + il * U + j * g - A * B, z[7] = il * o - j * B - A * g - dl * U, z;
      }
      function C(z, M, E) {
        var B = -M[0], g = -M[1], U = -M[2], o = M[3], L = M[4], N = M[5], v = M[6], f = M[7], j = L * o + f * B + N * U - v * g, A = N * o + f * g + v * B - L * U, dl = v * o + f * U + L * g - N * B, il = f * o - L * B - N * g - v * U;
        return c.rotateY(z, M, E), B = z[0], g = z[1], U = z[2], o = z[3], z[4] = j * o + il * B + A * U - dl * g, z[5] = A * o + il * g + dl * B - j * U, z[6] = dl * o + il * U + j * g - A * B, z[7] = il * o - j * B - A * g - dl * U, z;
      }
      function T(z, M, E) {
        var B = -M[0], g = -M[1], U = -M[2], o = M[3], L = M[4], N = M[5], v = M[6], f = M[7], j = L * o + f * B + N * U - v * g, A = N * o + f * g + v * B - L * U, dl = v * o + f * U + L * g - N * B, il = f * o - L * B - N * g - v * U;
        return c.rotateZ(z, M, E), B = z[0], g = z[1], U = z[2], o = z[3], z[4] = j * o + il * B + A * U - dl * g, z[5] = A * o + il * g + dl * B - j * U, z[6] = dl * o + il * U + j * g - A * B, z[7] = il * o - j * B - A * g - dl * U, z;
      }
      function K(z, M, E) {
        var B = E[0], g = E[1], U = E[2], o = E[3], L = M[0], N = M[1], v = M[2], f = M[3];
        return z[0] = L * o + f * B + N * U - v * g, z[1] = N * o + f * g + v * B - L * U, z[2] = v * o + f * U + L * g - N * B, z[3] = f * o - L * B - N * g - v * U, L = M[4], N = M[5], v = M[6], f = M[7], z[4] = L * o + f * B + N * U - v * g, z[5] = N * o + f * g + v * B - L * U, z[6] = v * o + f * U + L * g - N * B, z[7] = f * o - L * B - N * g - v * U, z;
      }
      function J(z, M, E) {
        var B = M[0], g = M[1], U = M[2], o = M[3], L = E[0], N = E[1], v = E[2], f = E[3];
        return z[0] = B * f + o * L + g * v - U * N, z[1] = g * f + o * N + U * L - B * v, z[2] = U * f + o * v + B * N - g * L, z[3] = o * f - B * L - g * N - U * v, L = E[4], N = E[5], v = E[6], f = E[7], z[4] = B * f + o * L + g * v - U * N, z[5] = g * f + o * N + U * L - B * v, z[6] = U * f + o * v + B * N - g * L, z[7] = o * f - B * L - g * N - U * v, z;
      }
      function F(z, M, E, B) {
        if (Math.abs(B) < s.EPSILON)
          return S(z, M);
        var g = Math.hypot(E[0], E[1], E[2]);
        B = B * 0.5;
        var U = Math.sin(B), o = U * E[0] / g, L = U * E[1] / g, N = U * E[2] / g, v = Math.cos(B), f = M[0], j = M[1], A = M[2], dl = M[3];
        z[0] = f * v + dl * o + j * N - A * L, z[1] = j * v + dl * L + A * o - f * N, z[2] = A * v + dl * N + f * L - j * o, z[3] = dl * v - f * o - j * L - A * N;
        var il = M[4], cl = M[5], ml = M[6], tl = M[7];
        return z[4] = il * v + tl * o + cl * N - ml * L, z[5] = cl * v + tl * L + ml * o - il * N, z[6] = ml * v + tl * N + il * L - cl * o, z[7] = tl * v - il * o - cl * L - ml * N, z;
      }
      function r(z, M, E) {
        return z[0] = M[0] + E[0], z[1] = M[1] + E[1], z[2] = M[2] + E[2], z[3] = M[3] + E[3], z[4] = M[4] + E[4], z[5] = M[5] + E[5], z[6] = M[6] + E[6], z[7] = M[7] + E[7], z;
      }
      function Y(z, M, E) {
        var B = M[0], g = M[1], U = M[2], o = M[3], L = E[4], N = E[5], v = E[6], f = E[7], j = M[4], A = M[5], dl = M[6], il = M[7], cl = E[0], ml = E[1], tl = E[2], sl = E[3];
        return z[0] = B * sl + o * cl + g * tl - U * ml, z[1] = g * sl + o * ml + U * cl - B * tl, z[2] = U * sl + o * tl + B * ml - g * cl, z[3] = o * sl - B * cl - g * ml - U * tl, z[4] = B * f + o * L + g * v - U * N + j * sl + il * cl + A * tl - dl * ml, z[5] = g * f + o * N + U * L - B * v + A * sl + il * ml + dl * cl - j * tl, z[6] = U * f + o * v + B * N - g * L + dl * sl + il * tl + j * ml - A * cl, z[7] = o * f - B * L - g * N - U * v + il * sl - j * cl - A * ml - dl * tl, z;
      }
      var H = Y;
      function Q(z, M, E) {
        return z[0] = M[0] * E, z[1] = M[1] * E, z[2] = M[2] * E, z[3] = M[3] * E, z[4] = M[4] * E, z[5] = M[5] * E, z[6] = M[6] * E, z[7] = M[7] * E, z;
      }
      var w = c.dot;
      function O(z, M, E, B) {
        var g = 1 - B;
        return w(M, E) < 0 && (B = -B), z[0] = M[0] * g + E[0] * B, z[1] = M[1] * g + E[1] * B, z[2] = M[2] * g + E[2] * B, z[3] = M[3] * g + E[3] * B, z[4] = M[4] * g + E[4] * B, z[5] = M[5] * g + E[5] * B, z[6] = M[6] * g + E[6] * B, z[7] = M[7] * g + E[7] * B, z;
      }
      function q(z, M) {
        var E = ll(M);
        return z[0] = -M[0] / E, z[1] = -M[1] / E, z[2] = -M[2] / E, z[3] = M[3] / E, z[4] = -M[4] / E, z[5] = -M[5] / E, z[6] = -M[6] / E, z[7] = M[7] / E, z;
      }
      function k(z, M) {
        return z[0] = -M[0], z[1] = -M[1], z[2] = -M[2], z[3] = M[3], z[4] = -M[4], z[5] = -M[5], z[6] = -M[6], z[7] = M[7], z;
      }
      var P = c.length, D = P, ll = c.squaredLength, _ = ll;
      function bl(z, M) {
        var E = ll(M);
        if (E > 0) {
          E = Math.sqrt(E);
          var B = M[0] / E, g = M[1] / E, U = M[2] / E, o = M[3] / E, L = M[4], N = M[5], v = M[6], f = M[7], j = B * L + g * N + U * v + o * f;
          z[0] = B, z[1] = g, z[2] = U, z[3] = o, z[4] = (L - B * j) / E, z[5] = (N - g * j) / E, z[6] = (v - U * j) / E, z[7] = (f - o * j) / E;
        }
        return z;
      }
      function $(z) {
        return "quat2(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ", " + z[4] + ", " + z[5] + ", " + z[6] + ", " + z[7] + ")";
      }
      function el(z, M) {
        return z[0] === M[0] && z[1] === M[1] && z[2] === M[2] && z[3] === M[3] && z[4] === M[4] && z[5] === M[5] && z[6] === M[6] && z[7] === M[7];
      }
      function nl(z, M) {
        var E = z[0], B = z[1], g = z[2], U = z[3], o = z[4], L = z[5], N = z[6], v = z[7], f = M[0], j = M[1], A = M[2], dl = M[3], il = M[4], cl = M[5], ml = M[6], tl = M[7];
        return Math.abs(E - f) <= s.EPSILON * Math.max(1, Math.abs(E), Math.abs(f)) && Math.abs(B - j) <= s.EPSILON * Math.max(1, Math.abs(B), Math.abs(j)) && Math.abs(g - A) <= s.EPSILON * Math.max(1, Math.abs(g), Math.abs(A)) && Math.abs(U - dl) <= s.EPSILON * Math.max(1, Math.abs(U), Math.abs(dl)) && Math.abs(o - il) <= s.EPSILON * Math.max(1, Math.abs(o), Math.abs(il)) && Math.abs(L - cl) <= s.EPSILON * Math.max(1, Math.abs(L), Math.abs(cl)) && Math.abs(N - ml) <= s.EPSILON * Math.max(1, Math.abs(N), Math.abs(ml)) && Math.abs(v - tl) <= s.EPSILON * Math.max(1, Math.abs(v), Math.abs(tl));
      }
    },
    /* 11 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return c;
      }), l.d(d, "clone", function() {
        return W;
      }), l.d(d, "fromValues", function() {
        return u;
      }), l.d(d, "copy", function() {
        return e;
      }), l.d(d, "set", function() {
        return n;
      }), l.d(d, "add", function() {
        return G;
      }), l.d(d, "subtract", function() {
        return y;
      }), l.d(d, "multiply", function() {
        return a;
      }), l.d(d, "divide", function() {
        return I;
      }), l.d(d, "ceil", function() {
        return h;
      }), l.d(d, "floor", function() {
        return S;
      }), l.d(d, "min", function() {
        return p;
      }), l.d(d, "max", function() {
        return X;
      }), l.d(d, "round", function() {
        return V;
      }), l.d(d, "scale", function() {
        return i;
      }), l.d(d, "scaleAndAdd", function() {
        return b;
      }), l.d(d, "distance", function() {
        return t;
      }), l.d(d, "squaredDistance", function() {
        return m;
      }), l.d(d, "length", function() {
        return R;
      }), l.d(d, "squaredLength", function() {
        return x;
      }), l.d(d, "negate", function() {
        return C;
      }), l.d(d, "inverse", function() {
        return T;
      }), l.d(d, "normalize", function() {
        return K;
      }), l.d(d, "dot", function() {
        return J;
      }), l.d(d, "cross", function() {
        return F;
      }), l.d(d, "lerp", function() {
        return r;
      }), l.d(d, "random", function() {
        return Y;
      }), l.d(d, "transformMat2", function() {
        return H;
      }), l.d(d, "transformMat2d", function() {
        return Q;
      }), l.d(d, "transformMat3", function() {
        return w;
      }), l.d(d, "transformMat4", function() {
        return O;
      }), l.d(d, "rotate", function() {
        return q;
      }), l.d(d, "angle", function() {
        return k;
      }), l.d(d, "zero", function() {
        return P;
      }), l.d(d, "str", function() {
        return D;
      }), l.d(d, "exactEquals", function() {
        return ll;
      }), l.d(d, "equals", function() {
        return _;
      }), l.d(d, "len", function() {
        return bl;
      }), l.d(d, "sub", function() {
        return $;
      }), l.d(d, "mul", function() {
        return el;
      }), l.d(d, "div", function() {
        return nl;
      }), l.d(d, "dist", function() {
        return z;
      }), l.d(d, "sqrDist", function() {
        return M;
      }), l.d(d, "sqrLen", function() {
        return E;
      }), l.d(d, "forEach", function() {
        return B;
      });
      var s = l(2);
      function c() {
        var g = new s.ARRAY_TYPE(2);
        return s.ARRAY_TYPE != Float32Array && (g[0] = 0, g[1] = 0), g;
      }
      function W(g) {
        var U = new s.ARRAY_TYPE(2);
        return U[0] = g[0], U[1] = g[1], U;
      }
      function u(g, U) {
        var o = new s.ARRAY_TYPE(2);
        return o[0] = g, o[1] = U, o;
      }
      function e(g, U) {
        return g[0] = U[0], g[1] = U[1], g;
      }
      function n(g, U, o) {
        return g[0] = U, g[1] = o, g;
      }
      function G(g, U, o) {
        return g[0] = U[0] + o[0], g[1] = U[1] + o[1], g;
      }
      function y(g, U, o) {
        return g[0] = U[0] - o[0], g[1] = U[1] - o[1], g;
      }
      function a(g, U, o) {
        return g[0] = U[0] * o[0], g[1] = U[1] * o[1], g;
      }
      function I(g, U, o) {
        return g[0] = U[0] / o[0], g[1] = U[1] / o[1], g;
      }
      function h(g, U) {
        return g[0] = Math.ceil(U[0]), g[1] = Math.ceil(U[1]), g;
      }
      function S(g, U) {
        return g[0] = Math.floor(U[0]), g[1] = Math.floor(U[1]), g;
      }
      function p(g, U, o) {
        return g[0] = Math.min(U[0], o[0]), g[1] = Math.min(U[1], o[1]), g;
      }
      function X(g, U, o) {
        return g[0] = Math.max(U[0], o[0]), g[1] = Math.max(U[1], o[1]), g;
      }
      function V(g, U) {
        return g[0] = Math.round(U[0]), g[1] = Math.round(U[1]), g;
      }
      function i(g, U, o) {
        return g[0] = U[0] * o, g[1] = U[1] * o, g;
      }
      function b(g, U, o, L) {
        return g[0] = U[0] + o[0] * L, g[1] = U[1] + o[1] * L, g;
      }
      function t(g, U) {
        var o = U[0] - g[0], L = U[1] - g[1];
        return Math.hypot(o, L);
      }
      function m(g, U) {
        var o = U[0] - g[0], L = U[1] - g[1];
        return o * o + L * L;
      }
      function R(g) {
        var U = g[0], o = g[1];
        return Math.hypot(U, o);
      }
      function x(g) {
        var U = g[0], o = g[1];
        return U * U + o * o;
      }
      function C(g, U) {
        return g[0] = -U[0], g[1] = -U[1], g;
      }
      function T(g, U) {
        return g[0] = 1 / U[0], g[1] = 1 / U[1], g;
      }
      function K(g, U) {
        var o = U[0], L = U[1], N = o * o + L * L;
        return N > 0 && (N = 1 / Math.sqrt(N)), g[0] = U[0] * N, g[1] = U[1] * N, g;
      }
      function J(g, U) {
        return g[0] * U[0] + g[1] * U[1];
      }
      function F(g, U, o) {
        var L = U[0] * o[1] - U[1] * o[0];
        return g[0] = g[1] = 0, g[2] = L, g;
      }
      function r(g, U, o, L) {
        var N = U[0], v = U[1];
        return g[0] = N + L * (o[0] - N), g[1] = v + L * (o[1] - v), g;
      }
      function Y(g, U) {
        U = U || 1;
        var o = s.RANDOM() * 2 * Math.PI;
        return g[0] = Math.cos(o) * U, g[1] = Math.sin(o) * U, g;
      }
      function H(g, U, o) {
        var L = U[0], N = U[1];
        return g[0] = o[0] * L + o[2] * N, g[1] = o[1] * L + o[3] * N, g;
      }
      function Q(g, U, o) {
        var L = U[0], N = U[1];
        return g[0] = o[0] * L + o[2] * N + o[4], g[1] = o[1] * L + o[3] * N + o[5], g;
      }
      function w(g, U, o) {
        var L = U[0], N = U[1];
        return g[0] = o[0] * L + o[3] * N + o[6], g[1] = o[1] * L + o[4] * N + o[7], g;
      }
      function O(g, U, o) {
        var L = U[0], N = U[1];
        return g[0] = o[0] * L + o[4] * N + o[12], g[1] = o[1] * L + o[5] * N + o[13], g;
      }
      function q(g, U, o, L) {
        var N = U[0] - o[0], v = U[1] - o[1], f = Math.sin(L), j = Math.cos(L);
        return g[0] = N * j - v * f + o[0], g[1] = N * f + v * j + o[1], g;
      }
      function k(g, U) {
        var o = g[0], L = g[1], N = U[0], v = U[1], f = Math.sqrt(o * o + L * L) * Math.sqrt(N * N + v * v), j = f && (o * N + L * v) / f;
        return Math.acos(Math.min(Math.max(j, -1), 1));
      }
      function P(g) {
        return g[0] = 0, g[1] = 0, g;
      }
      function D(g) {
        return "vec2(" + g[0] + ", " + g[1] + ")";
      }
      function ll(g, U) {
        return g[0] === U[0] && g[1] === U[1];
      }
      function _(g, U) {
        var o = g[0], L = g[1], N = U[0], v = U[1];
        return Math.abs(o - N) <= s.EPSILON * Math.max(1, Math.abs(o), Math.abs(N)) && Math.abs(L - v) <= s.EPSILON * Math.max(1, Math.abs(L), Math.abs(v));
      }
      var bl = R, $ = y, el = a, nl = I, z = t, M = m, E = x, B = function() {
        var g = c();
        return function(U, o, L, N, v, f) {
          var j, A;
          for (o || (o = 2), L || (L = 0), N ? A = Math.min(N * o + L, U.length) : A = U.length, j = L; j < A; j += o)
            g[0] = U[j], g[1] = U[j + 1], v(g, g, f), U[j] = g[0], U[j + 1] = g[1];
          return U;
        };
      }();
    },
    /* 12 */
    /***/
    function(Z, d, l) {
      l.r(d);
      var s = l(13);
      l.d(d, "Renderer", function() {
        return s.default;
      });
      var c = l(40);
      l.d(d, "Figure2D", function() {
        return c.default;
      });
      var W = l(56);
      l.d(d, "Mesh2D", function() {
        return W.default;
      });
      var u = l(29);
      l.d(d, "MeshCloud", function() {
        return u.default;
      });
      var e = l(23);
      l.d(d, "parseFont", function() {
        return e.default;
      });
      var n = l(31);
      l.d(d, "parseColor", function() {
        return n.default;
      });
      var G = l(21);
      l.d(d, "ENV", function() {
        return G.default;
      }), l(1).glMatrix.setMatrixArrayType(Array);
    },
    /* 13 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return T;
      });
      var s = l(14), c = l(1), W = l(20), u = l(27), e = l(25), n = l(40), G = l(56), y = l(29), a = l(59), I = l(21), h = l(63);
      l(1).glMatrix.setMatrixArrayType(Array);
      const S = {
        autoUpdate: !1,
        // premultipliedAlpha: true,
        preserveDrawingBuffer: !1,
        // depth: false,
        // antialias: false,
        bufferSize: 1500
      }, p = `attribute vec3 a_vertexPosition;
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

void main() {
  gl_PointSize = 1.0;
  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);    
  vTextureCoord = a_vertexTextureCoord;              
}
`, X = `precision mediump float;
varying vec3 vTextureCoord;
uniform sampler2D u_texSampler;
void main() {
  gl_FragColor = texture2D(u_texSampler, vTextureCoord.xy);
}
`, V = Symbol("glRenderer"), i = Symbol("canvasRenderer"), b = Symbol("options"), t = Symbol("globalTransform"), m = Symbol("applyGlobalTransform"), R = Symbol("canvas");
      function x(K) {
        const J = K.gl, F = K.fbo;
        F && J.bindFramebuffer(J.FRAMEBUFFER, F), K._draw(), F && J.bindFramebuffer(J.FRAMEBUFFER, null);
      }
      function C(K, J, F, r) {
        const Y = K.createTexture(J.canvas), H = [[[0, 0], [F, 0], [F, r], [0, r], [0, 0]]];
        H.closed = !0;
        const Q = new G.default({
          contours: H
        });
        Q.setTexture(Y), K.setMeshData([Q.meshData]), x(K), Y.delete(), J.clearRect(0, 0, F, r), delete J._filter;
      }
      class T {
        constructor(J, F = {}) {
          let r = F.contextType;
          if (r || (typeof WebGL2RenderingContext == "function" ? r = "webgl2" : typeof WebGLRenderingContext == "function" ? r = "webgl" : r = "2d"), !J.getContext) {
            const Y = J;
            J = {
              getContext() {
                return Y;
              },
              width: F.width,
              height: F.height
            }, Y.canvas = J, r = "2d";
          }
          if (this[R] = J, r !== "webgl" && r !== "webgl2" && r !== "2d")
            throw new Error(`Unknown context type ${r}`);
          if (F.contextType = r, this[b] = Object.assign({}, S, F), r === "webgl" || r === "webgl2") {
            r === "webgl2" && (this[b].webgl2 = !0);
            const Y = new s.default(J, this[b]);
            r === "webgl2" && !Y.isWebGL2 && (F.contextType = "webgl"), Object(h.createShaders)(Y), Object(h.applyShader)(Y), Object(h.createCloudShaders)(Y);
            const H = Y.gl;
            H.clearColor(0, 0, 0, 0), H.blendFuncSeparate(H.SRC_ALPHA, H.ONE_MINUS_SRC_ALPHA, H.ONE, H.ONE_MINUS_SRC_ALPHA), this[V] = Y;
          } else
            this[i] = new W.default(J, this[b]);
          this[t] = [1, 0, 0, 0, 1, 0, 0, 0, 1], this.updateResolution();
        }
        get canvas() {
          return this[R];
        }
        get canvasRenderer() {
          return this[i];
        }
        get glRenderer() {
          return this[V];
        }
        get isWebGL2() {
          return this[V] && this[V].isWebGL2;
        }
        get options() {
          return this[b];
        }
        get globalTransformMatrix() {
          const J = this[t];
          return [J[0], J[1], J[3], J[4], J[6], J[7]];
        }
        get viewMatrix() {
          return this[t];
        }
        [m]() {
          const J = this[V] || this[i];
          if (this[V]) {
            const {
              width: F,
              height: r
            } = this.canvas;
            J.uniforms.viewMatrix = this.viewMatrix, J.uniforms.projectionMatrix = this.projectionMatrix, J.uniforms.u_resolution = [F, r];
          }
        }
        updateResolution() {
          const {
            width: J,
            height: F
          } = this.canvas, r = [
            // translation
            1,
            0,
            0,
            0,
            1,
            0,
            -J / 2,
            -F / 2,
            1
          ], Y = [
            // scale
            2 / J,
            0,
            0,
            0,
            -2 / F,
            0,
            0,
            0,
            1
          ], H = c.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), Y, r);
          this.projectionMatrix = H, this[V] && this[V].gl.viewport(0, 0, J, F);
        }
        createTexture(J, F) {
          return (this[V] || this[i]).createTexture(J, F);
        }
        /* async */
        loadTexture(J, {
          useImageBitmap: F = !1
        } = {}) {
          return (this[V] || this[i]).loadTexture(J, {
            useImageBitmap: F
          });
        }
        createText(J, {
          font: F = "16px arial",
          fillColor: r = null,
          strokeColor: Y = null,
          strokeWidth: H = 1
        } = {}) {
          if (this[V]) {
            const Q = I.default.createText(J, {
              font: F,
              fillColor: r,
              strokeColor: Y,
              strokeWidth: H
            });
            return {
              image: this.createTexture(Q.image),
              rect: Q.rect
            };
          }
          return {
            _img: {
              font: F,
              fillColor: r,
              strokeColor: Y,
              strokeWidth: H,
              text: J
            }
          };
        }
        createProgram({
          vertex: J,
          fragment: F,
          options: r
        } = {}) {
          if (this[V]) {
            const Y = this[V].compileSync(F, J);
            return Y._attribOpts = r, Y;
          }
          throw new Error("Context 2D cannot create webgl program.");
        }
        createPassProgram({
          vertex: J = p,
          fragment: F = X,
          options: r
        } = {}) {
          return this.createProgram({
            vertex: J,
            fragment: F,
            options: r
          });
        }
        useProgram(J, F = {}) {
          if (this[V]) {
            const r = Object.assign({}, J._attribOpts, F);
            return this[V].useProgram(J, r);
          }
          throw new Error("Context 2D cannot use webgl program.");
        }
        deleteTexture(J) {
          return (this[V] || this[i]).deleteTexture(J);
        }
        clear(...J) {
          if (this[V]) {
            const F = this[V].gl;
            F.clear(F.COLOR_BUFFER_BIT);
          } else
            this[i].clear(...J);
        }
        drawMeshCloud(J, {
          clear: F = !1,
          program: r = null
        } = {}) {
          const Y = this[V] || this[i], H = r || J.program;
          if (this[V]) {
            const Q = Y.gl;
            if (F && Q.clear(Q.COLOR_BUFFER_BIT), H)
              Y.program !== H && this.useProgram(H, {
                a_color: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_fillCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_strokeCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_frameIndex: {
                  type: "UNSIGNED_BYTE",
                  normalize: !1
                }
              });
            else {
              const w = J.mesh.meshData, O = !!w.uniforms.u_texSampler, q = !!w.uniforms.u_filterFlag, k = !!w.uniforms.u_radialGradientVector, P = J.hasCloudColor, D = J.hasCloudFilter, ll = !!w.uniforms.u_clipSampler;
              Object(h.applyCloudShader)(Y, {
                hasTexture: O,
                hasFilter: q,
                hasGradient: k,
                hasCloudColor: P,
                hasCloudFilter: D,
                hasClipPath: ll
              });
            }
            this[m](), Y.setMeshData([J.meshData]), J.beforeRender && J.beforeRender(Q, J), x(Y), J.afterRender && J.afterRender(Q, J);
          } else
            Y.setTransform(this.globalTransformMatrix), Y.drawMeshCloud(J, {
              clear: F,
              hook: !1
            });
        }
        drawMeshes(J, {
          clear: F = !1,
          program: r = null
        } = {}) {
          const Y = this[V] || this[i];
          if (this[V]) {
            const H = Y.fbo, Q = Object(u.default)(this, J, r == null), w = Y.gl;
            F && w.clear(w.COLOR_BUFFER_BIT);
            const O = !Object(a.isUnitTransform)(this.globalTransformMatrix);
            this._drawCalls = 0;
            for (const q of Q) {
              this._drawCalls++;
              const k = r || q.program;
              if (q instanceof y.default)
                this.drawMeshCloud(q, {
                  clear: F,
                  program: k
                });
              else {
                const {
                  width: P,
                  height: D
                } = this.canvas;
                if (q.beforeRender && q.beforeRender(w, q), q.pass.length && ((!this.fbo || this.fbo.width !== P || this.fbo.height !== D) && (this.fbo = {
                  width: P,
                  height: D,
                  target: Y.createFBO(),
                  buffer: Y.createFBO(),
                  swap() {
                    [this.target, this.buffer] = [this.buffer, this.target];
                  }
                }), Y.bindFBO(this.fbo.target)), !k && q.filterCanvas) {
                  Object(h.applyShader)(Y, {
                    hasTexture: !0
                  });
                  let ll = this.filterContext;
                  ll || (ll = I.default.createCanvas(P, D).getContext("2d"), this.filterContext = ll);
                  const _ = J[q.packIndex], bl = _.filter, $ = J[q.packIndex + 1], el = J[q.packIndex - 1];
                  (!el || !el.filterCanvas || el.filter !== bl) && (!$ || !$.filterCanvas || $.filter !== bl) ? (O ? (ll.save(), Object(e.drawMesh2D)(_, ll, !1), ll.restore(), Object(e.applyFilter)(ll, bl)) : Object(e.drawMesh2D)(_, ll, !0), this[m](), C(Y, ll, P, D)) : (O && ll.save(), Object(e.drawMesh2D)(_, ll, !1), O && ll.restore(), (!$ || !$.filterCanvas || _.filter !== $.filter) && (Object(e.applyFilter)(ll, bl), this[m](), C(Y, ll, P, D)));
                } else {
                  if (k)
                    Y.program !== k && this.useProgram(k, {
                      a_color: {
                        type: "UNSIGNED_BYTE",
                        normalize: !0
                      }
                    });
                  else {
                    const ll = !!q.uniforms.u_texSampler, _ = !!q.uniforms.u_filterFlag, bl = !!q.uniforms.u_radialGradientVector, $ = !!q.uniforms.u_clipSampler;
                    Object(h.applyShader)(Y, {
                      hasTexture: ll,
                      hasFilter: _,
                      hasGradient: bl,
                      hasClipPath: $
                    });
                  }
                  q.filterCanvas && console.warn("User program ignored some filter effects."), this[m](), Y.setMeshData([q]), x(Y);
                }
                if (q.pass.length) {
                  const ll = q.pass.length;
                  q.pass.forEach((_, bl) => {
                    _.blend = q.enableBlend, _.setTexture(Y.fbo.texture), bl === ll - 1 ? Y.bindFBO(H) : (this.fbo.swap(), Y.bindFBO(this.fbo.target)), _.program ? Y.useProgram(_.program) : (this.defaultPassProgram = this.defaultPassProgram || this.createPassProgram(), Y.useProgram(this.defaultPassProgram)), Y.setMeshData([_.meshData]), w.clear(w.COLOR_BUFFER_BIT), x(Y);
                  });
                }
                q.afterRender && q.afterRender(w, q);
              }
            }
          } else
            Y.setTransform(this.globalTransformMatrix), Y.drawMeshes(J, {
              clear: F
            });
        }
        drawImage(J, ...F) {
          const r = F.length;
          if (r < 2)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': 3 arguments required, but only ${F.length + 1} present.`);
          if (r !== 2 && r !== 4 && r !== 8)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': Valid arities are: [3, 5, 9], but ${F.length + 1} arguments provided.`);
          let Y = null, H = null;
          r === 2 ? Y = [F[0], F[1], J.width, J.height] : r === 4 ? Y = F : r === 8 && (H = F.slice(0, 4), Y = F.slice(4));
          const Q = this.createTexture(J), {
            width: w,
            height: O
          } = this.canvas, q = new n.default();
          q.rect(Y[0], Y[1], w, O);
          const k = new G.default(q, {
            width: w,
            height: O
          });
          k.setTexture(Q, {
            rect: Y,
            srcRect: H
          }), this.drawMeshes([k]), this.deleteTexture(Q);
        }
        setGlobalTransform(...J) {
          return this[t] = [J[0], J[1], 0, J[2], J[3], 0, J[4], J[5], 1], this;
        }
        globalTransform(...J) {
          const F = this[t];
          return this[t] = c.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), F, J), this;
        }
        globalTranslate(J, F) {
          let r = c.mat3.create();
          return r = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), r, [J, F]), this.globalTransform(...r);
        }
        globalRotate(J, [F, r] = [0, 0]) {
          let Y = c.mat3.create();
          return Y = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), Y, [F, r]), Y = c.mat3.rotate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), Y, J), Y = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), Y, [-F, -r]), this.globalTransform(...Y);
        }
        globalScale(J, F = J, [r, Y] = [0, 0]) {
          let H = c.mat3.create();
          return H = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [r, Y]), H = c.mat3.scale(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [J, F]), H = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [-r, -Y]), this.globalTransform(...H);
        }
        globalSkew(J, F = J, [r, Y] = [0, 0]) {
          let H = c.mat3.create();
          return H = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [r, Y]), H = c.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, c.mat3.fromValues(1, Math.tan(F), Math.tan(J), 1, 0, 0)), H = c.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), H, [-r, -Y]), this.globalTransform(...H);
        }
        transformPoint(J, F, r) {
          let Y = this.globalTransformMatrix;
          r && (Y = c.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), Y, r));
          const H = J * Y[0] + F * Y[2] + Y[4], Q = J * Y[1] + F * Y[3] + Y[5];
          return [H, Q];
        }
      }
    },
    /* 14 */
    /***/
    function(Z, d, l) {
      l.r(d);
      var s = l(15);
      l(1).glMatrix.setMatrixArrayType(Array), d.default = s.default;
    },
    /* 15 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return h;
      });
      var s = l(16), c = l(17), W = l(18), u = l(19);
      l(1).glMatrix.setMatrixArrayType(Array);
      function e(S, p, X) {
        return p in S ? Object.defineProperty(S, p, { value: X, enumerable: !0, configurable: !0, writable: !0 }) : S[p] = X, S;
      }
      const n = {};
      function G(S, p = 3) {
        const X = [], V = S.length;
        for (let i = 0; i < V; i++)
          i % p < 2 && X.push(0.5 * (S[i] + 1));
        return X;
      }
      function y(S, p) {
        const X = p._buffers;
        Object.values(X).forEach((V) => {
          S.deleteBuffer(V);
        }), p._buffers = {};
      }
      function a(S, p, X) {
        return S.activeTexture(S.TEXTURE0 + X), Array.isArray(p._img) ? S.bindTexture(S.TEXTURE_CUBE_MAP, p) : S.bindTexture(S.TEXTURE_2D, p), p;
      }
      const I = {
        int: "1i",
        ivec2: "2i",
        ivec3: "3i",
        ivec4: "4i",
        float: "1f",
        vec2: "2f",
        vec3: "3f",
        vec4: "4f",
        mat2: "Matrix2fv",
        mat3: "Matrix3fv",
        mat4: "Matrix4fv",
        sampler1D: "sampler1D",
        sampler2D: "sampler2D",
        sampler3D: "sampler3D",
        samplerCube: "samplerCube",
        sampler1DShadow: "sampler1DShadow",
        sampler2DShadow: "sampler2DShadow",
        sampler2DRect: "sampler2DRect",
        sampler2DRectShadow: "sampler2DRectShadow"
      };
      class h {
        static addLibs(p = {}) {
          Object.assign(n, p);
        }
        static FLOAT(p, X) {
          return Object(s.pointsToBuffer)(p, Float32Array, X);
        }
        static UNSIGNED_BYTE(p, X) {
          return Object(s.pointsToBuffer)(p, Uint8Array, X);
        }
        static UNSIGNED_SHORT(p, X) {
          return Object(s.pointsToBuffer)(p, Uint16Array, X);
        }
        static BYTE(p, X) {
          return Object(s.pointsToBuffer)(p, Int8Array, X);
        }
        static SHORT(p, X) {
          return Object(s.pointsToBuffer)(p, Int16Array, X);
        }
        constructor(p, X = {}) {
          this.options = Object.assign({}, h.defaultOptions, X), this.canvas = p;
          let V;
          this.options.webgl2 && (V = p.getContext("webgl2", this.options)), V == null && (V = Object(s.setupWebGL)(p, this.options), this.aia_ext = V.getExtension("ANGLE_instanced_arrays")), this.gl = V, V.viewport(0, 0, p.width, p.height), V.clearColor(0, 0, 0, 0), V.blendFuncSeparate(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA, V.ONE, V.ONE_MINUS_SRC_ALPHA), this.programs = [], this._events = {};
        }
        get program() {
          const p = this.gl;
          return p.getParameter(p.CURRENT_PROGRAM);
        }
        // WebGLRenderingContext.uniform[1234][fi][v]()
        // WebGLRenderingContext.uniformMatrix[234]fv()
        _declareUniform(p, X, V = "1f") {
          const i = this.gl, b = i.getUniformLocation(p, X);
          let t;
          const m = this;
          if (/^sampler/.test(V)) {
            const R = p._samplerMap, x = p._bindTextures;
            Object.defineProperty(p.uniforms, X, {
              get() {
                return t;
              },
              set(C) {
                t = C;
                const T = R[X] != null ? R[X] : x.length;
                x[T] = C, a(i, C, T), R[X] || (R[X] = T, i.uniform1i(b, T)), m.options.autoUpdate && m.update();
              },
              configurable: !1,
              enumerable: !0
            });
          } else {
            const R = V.indexOf("Matrix") === 0, x = !R && /v$/.test(V), C = i[`uniform${V}`].bind(i);
            Object.defineProperty(p.uniforms, X, {
              get() {
                return t;
              },
              set(T) {
                t = T, typeof T == "number" && (T = [T]), R ? C(b, !1, T) : x ? C(b, T) : C(b, ...T), m.options.autoUpdate && m.update();
              },
              configurable: !1,
              enumerable: !0
            });
          }
        }
        _draw() {
          const p = this.program;
          p.meshData.forEach((X, V) => {
            const {
              positions: i,
              cells: b,
              instanceCount: t,
              cellsCount: m,
              attributes: R,
              uniforms: x,
              textureCoord: C,
              enableBlend: T
            } = X, K = this.gl;
            let J = X.mode != null ? X.mode : K.TRIANGLES;
            typeof J == "string" && (J = K[J]), T ? K.enable(K.BLEND) : K.disable(K.BLEND), K.bindBuffer(K.ARRAY_BUFFER, p._buffers.verticesBuffer), K.bufferData(K.ARRAY_BUFFER, i, K.STATIC_DRAW), b && (K.bindBuffer(K.ELEMENT_ARRAY_BUFFER, p._buffers.cellsBuffer), K.bufferData(K.ELEMENT_ARRAY_BUFFER, b, K.STATIC_DRAW));
            const F = [];
            R && Object.values(R).forEach(({
              name: Y,
              data: H,
              divisor: Q
            }) => {
              if (K.bindBuffer(K.ARRAY_BUFFER, p._buffers[Y]), K.bufferData(K.ARRAY_BUFFER, H, K.STATIC_DRAW), Q != null) {
                const w = K.getAttribLocation(p, Y);
                w >= 0 && (K.enableVertexAttribArray(w), F.push(w), K.vertexAttribDivisor ? K.vertexAttribDivisor(w, Q) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(w, Q));
              }
            }), x && Object.entries(x).forEach(([Y, H]) => {
              this.uniforms[Y] = H;
            });
            let r;
            if (!b) {
              const Y = p._dimension;
              r = i.length / Y;
            }
            if (p._enableTextures && p._buffers.texCoordBuffer) {
              const Y = C || G(i, p._dimension);
              K.bindBuffer(K.ARRAY_BUFFER, p._buffers.texCoordBuffer), K.bufferData(K.ARRAY_BUFFER, h.FLOAT(Y), K.STATIC_DRAW);
            }
            t != null ? (b ? K.drawElementsInstanced ? K.drawElementsInstanced(J, m, K.UNSIGNED_SHORT, 0, t) : this.aia_ext && this.aia_ext.drawElementsInstancedANGLE(J, m, K.UNSIGNED_SHORT, 0, t) : K.drawArraysInstanced ? K.drawArraysInstanced(J, 0, r, t) : this.aia_ext.drawArraysInstancedANGLE(J, 0, r, t), F.forEach((Y) => {
              K.vertexAttribDivisor ? K.vertexAttribDivisor(Y, null) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(Y, null);
            })) : b ? K.drawElements(J, m, K.UNSIGNED_SHORT, 0) : K.drawArrays(J, 0, r);
          });
        }
        get isWebGL2() {
          return typeof WebGL2RenderingContext < "u" && this.gl instanceof WebGL2RenderingContext;
        }
        get enableTextures() {
          return this.program && this.program._enableTextures;
        }
        get uniforms() {
          const p = this.program;
          if (!p || !p.uniforms)
            throw Error("No avaliable program.");
          return p.uniforms;
        }
        deleteProgram(p) {
          const X = this.gl;
          this.program === p && (this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID), X.useProgram(null));
          const V = this.programs.indexOf(p);
          V >= 0 && this.programs.splice(V, 1), y(X, p), X.deleteProgram(p);
        }
        /**
          [{
            positions: ...
            cells: ...
            textureCoord: ...
            attributes: {name: {data:..., normalize: true}},
            uniforms: ...
          }]
         */
        setMeshData(p) {
          Array.isArray(p) || (p = [p]);
          const X = this.program;
          X.meshData = p.map(({
            mode: V,
            positions: i,
            instanceCount: b,
            cells: t,
            cellsCount: m,
            attributes: R,
            uniforms: x,
            textureCoord: C,
            enableBlend: T
          }) => {
            const K = {
              positions: h.FLOAT(i),
              uniforms: x,
              enableBlend: !!T,
              textureCoord: h.FLOAT(C)
            };
            if (t && (K.cells = h.USHORT(t), K.cellsCount = m || K.cells.length), V != null && (K.mode = V), b != null) {
              if (!this.isWebGL2 && !this.aia_ext)
                throw new Error("Cannot use instanceCount in this rendering context, use webgl2 context instead.");
              K.instanceCount = b;
            }
            if (R) {
              const J = {};
              Object.entries(R).forEach(([F, r]) => {
                if (!X._attribute[F])
                  X._attribute[F] = "ignored";
                else if (X._attribute[F] !== "ignored") {
                  const {
                    name: Y,
                    type: H
                  } = X._attribute[F];
                  let Q = r.data || r;
                  if (Array.isArray(Q) && (Q = h[H](Q)), J[F] = {
                    name: Y,
                    data: Q
                  }, r.divisor != null) {
                    if (!this.isWebGL2 && !this.aia_ext)
                      throw new Error("Cannot use divisor in this rendering context, use webgl2 context instead.");
                    J[F].divisor = r.divisor;
                  }
                }
              }), K.attributes = J;
            }
            return K;
          }), this.options.autoUpdate && this.update();
        }
        createProgram(p, X) {
          const V = /^\s*uniform\s+sampler/mg.test(p);
          p == null && (p = W.default), X == null && (X = V ? u.default : c.default);
          const i = this.gl, b = Object(s.createProgram)(i, X, p);
          b.shaderText = {
            vertexShader: X,
            fragmentShader: p
          }, b._buffers = {}, b._attribute = {}, b.uniforms = {}, b._samplerMap = {}, b._bindTextures = [];
          const t = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexPosition}`, "im");
          let m = X.match(t);
          m && (b._dimension = Number(m[1]));
          const R = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexTextureCoord}`, "im");
          m = X.match(R), m && (b._texCoordSize = Number(m[1]));
          const x = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/gim;
          if (m = X.match(x), m)
            for (let K = 0; K < m.length; K++) {
              const J = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/im, F = m[K].match(J);
              if (F && F[3] !== this.options.vertexPosition && F[3] !== this.options.vertexTextureCoord) {
                let [, r, Y, H] = F;
                r === "mat" && (Y **= 2), b._buffers[H] = i.createBuffer(), b._attribute[H] = {
                  name: H,
                  type: r,
                  size: Number(Y) || 1
                };
              }
            }
          const C = /^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/mg;
          m = X.match(C) || [], m = m.concat(p.match(C) || []), m.forEach((K) => {
            const J = K.match(/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/);
            let [F, r, Y] = J.slice(1);
            F = I[F], Y = !!Y, F.indexOf("Matrix") !== 0 && Y && (F += "v"), this._declareUniform(b, r, F);
          }), b._buffers.verticesBuffer = i.createBuffer(), b._buffers.cellsBuffer = i.createBuffer();
          const T = i.getAttribLocation(b, this.options.vertexTextureCoord);
          return b._enableTextures = T >= 0, b._enableTextures && (b._buffers.texCoordBuffer = i.createBuffer()), this.programs.push(b), b;
        }
        useProgram(p, X = {}) {
          this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID);
          const V = this.gl;
          V.useProgram(p);
          const i = p._dimension;
          V.bindBuffer(V.ARRAY_BUFFER, p._buffers.verticesBuffer);
          const b = V.getAttribLocation(p, this.options.vertexPosition);
          if (V.vertexAttribPointer(b, i, V.FLOAT, !1, 0, 0), V.enableVertexAttribArray(b), p._enableTextures) {
            V.bindBuffer(V.ARRAY_BUFFER, p._buffers.texCoordBuffer);
            const t = V.getAttribLocation(p, this.options.vertexTextureCoord);
            V.vertexAttribPointer(t, p._texCoordSize || 2, V.FLOAT, !1, 0, 0), V.enableVertexAttribArray(t);
          }
          if (Object.entries(p._attribute).forEach(([t, m]) => {
            if (m !== "ignored") {
              const R = m.size, x = X[t] || {}, C = !!x.normalize;
              let T = x.type || "FLOAT";
              const K = x.key || t;
              T === "UBYTE" && (T = "UNSIGNED_BYTE"), T === "USHORT" && (T = "UNSIGNED_SHORT"), m.type = T, K && K !== t && (p._attribute[K] = m), V.bindBuffer(V.ARRAY_BUFFER, p._buffers[t]);
              const J = V.getAttribLocation(p, t);
              J >= 0 && (V.vertexAttribPointer(J, R, V[T], C, 0, 0), V.enableVertexAttribArray(J));
            }
          }), !p.meshData) {
            const t = [[-1, -1, 0, 1].slice(0, i), [1, -1, 0, 1].slice(0, i), [1, 1, 0, 1].slice(0, i), [-1, 1, 0, 1].slice(0, i)], m = [[0, 1, 3], [3, 1, 2]];
            this.setMeshData({
              positions: t,
              cells: m
            });
          }
          return p;
        }
        compileSync(p, X) {
          p = p || W.default;
          const V = {};
          function i(R) {
            R = R.replace(/^\s*/mg, "");
            const x = [], C = R.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let T = 0; T < C.length; T++) {
                const J = C[T].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const F = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let r = J[1];
                  if (r === "graph" && (r = "graphics"), V[r])
                    x.push(`/* included ${r} */`);
                  else if (V[r] = !0, F === "lib") {
                    const Y = i(n[r]);
                    x.push(Y);
                  } else if (F === "link")
                    throw new Error("Cannot load external links synchronously. Use compile instead of compileSync.");
                }
              }
              x.forEach((T) => {
                R = R.replace(/^#pragma\s+include\s+.*/m, T);
              });
            }
            return R;
          }
          const b = i(p), t = X ? i(X) : null;
          return this.createProgram(b, t);
        }
        async compile(p, X) {
          p = p || W.default;
          const V = {};
          async function i(R) {
            R = R.replace(/^\s*/mg, "");
            const x = [], C = R.match(/^#pragma\s+include\s+.*/mg);
            if (C) {
              for (let T = 0; T < C.length; T++) {
                const J = C[T].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const F = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let r = J[1];
                  if (r === "graph" && (r = "graphics"), V[r])
                    x.push(`/* included ${r} */`);
                  else if (V[r] = !0, F === "lib") {
                    const Y = await i(n[r]);
                    x.push(Y);
                  } else if (F === "link") {
                    let Y = await h.fetchShader(r);
                    Y = await i(Y), x.push(Y);
                  }
                }
              }
              x.forEach((T) => {
                R = R.replace(/^#pragma\s+include\s+.*/m, T);
              });
            }
            return R;
          }
          const b = await i(p), t = X ? await i(X) : null;
          return this.createProgram(b, t);
        }
        async load(p, X = null) {
          return p = await h.fetchShader(p), X && (X = await h.fetchShader(X)), this.compile(p, X);
        }
        createTexture(p = null, {
          wrapS: X = this.gl.CLAMP_TO_EDGE,
          wrapT: V = this.gl.CLAMP_TO_EDGE,
          minFilter: i = this.gl.LINEAR,
          magFilter: b = this.gl.LINEAR
        } = {}) {
          const t = this.gl, m = Array.isArray(p) ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D;
          this._max_texture_image_units = this._max_texture_image_units || t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS), t.activeTexture(t.TEXTURE0 + this._max_texture_image_units - 1);
          const R = t.createTexture();
          t.bindTexture(m, R), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !0);
          const {
            width: x,
            height: C
          } = this.canvas;
          if (p)
            if (m === t.TEXTURE_CUBE_MAP)
              for (let T = 0; T < 6; T++)
                t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + T, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, p[T]);
            else
              t.texImage2D(m, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, p);
          else if (m === t.TEXTURE_CUBE_MAP)
            for (let T = 0; T < 6; T++)
              this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + T, 0, t.RGBA, x, C, 0, t.RGBA, t.UNSIGNED_BYTE, null);
          else
            t.texImage2D(m, 0, t.RGBA, x, C, 0, t.RGBA, t.UNSIGNED_BYTE, null);
          return t.texParameteri(m, t.TEXTURE_MIN_FILTER, i), t.texParameteri(m, t.TEXTURE_MAG_FILTER, b), t.texParameteri(m, t.TEXTURE_WRAP_S, X), t.texParameteri(m, t.TEXTURE_WRAP_T, V), m === t.TEXTURE_CUBE_MAP && (p.width = p[0].width, p.height = p[0].height), t.bindTexture(m, null), R._img = p || {
            width: x,
            height: C
          }, R.delete = () => {
            this.deleteTexture(R);
          }, R;
        }
        deleteTexture(p) {
          const X = p._img;
          this.gl.deleteTexture(p), typeof X.close == "function" && X.close();
        }
        async loadTexture(p, {
          useImageBitmap: X = !0
        } = {}) {
          const V = await h.loadImage(p, {
            useImageBitmap: X
          });
          return this.createTexture(V);
        }
        createFBO({
          color: p = 1,
          blend: X = !1,
          depth: V = this.options.depth !== !1,
          stencil: i = !!this.options.stencil
        } = {}) {
          const b = this.gl, t = b.createFramebuffer();
          b.bindFramebuffer(b.FRAMEBUFFER, t);
          const m = [];
          for (let C = 0; C < p; C++) {
            const T = this.createTexture();
            b.framebufferTexture2D(
              b.FRAMEBUFFER,
              b.COLOR_ATTACHMENT0 + C,
              b.TEXTURE_2D,
              T,
              0
              /* level */
            ), m.push(T);
          }
          t.textures = m, t.texture = m[0], t.blend = X;
          const {
            width: R,
            height: x
          } = this.canvas;
          return V && !i && (t.depthBuffer = b.createRenderbuffer(), b.bindRenderbuffer(b.RENDERBUFFER, t.depthBuffer), b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_COMPONENT16, R, x), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, b.RENDERBUFFER, t.depthBuffer)), i && !V && (t.stencilBuffer = b.createRenderbuffer(), b.bindRenderbuffer(b.RENDERBUFFER, t.stencilBuffer), b.renderbufferStorage(b.RENDERBUFFER, b.STENCIL_INDEX8, R, x), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.STENCIL_ATTACHMENT, b.RENDERBUFFER, t.stencilBuffer)), V && i && (t.depthStencilBuffer = b.createRenderbuffer(), b.bindRenderbuffer(b.RENDERBUFFER, t.depthStencilBuffer), b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_STENCIL, R, x), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, b.RENDERBUFFER, t.depthStencilBuffer)), b.bindFramebuffer(b.FRAMEBUFFER, null), t;
        }
        bindFBO(p = null) {
          this.fbo = p;
        }
        render({
          clearBuffer: p = !0
        } = {}) {
          this.startRender = !0;
          const X = this.gl;
          let V = this.program;
          V || (V = this.createProgram(), this.useProgram(V)), this.fbo && X.bindFramebuffer(X.FRAMEBUFFER, this.fbo);
          const i = this.options.depth;
          i && X.enable(X.DEPTH_TEST), this.gl.clear(this.gl.COLOR_BUFFER_BIT | (i ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.options.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));
          const b = this._renderFrameID;
          this._draw(), this.fbo && X.bindFramebuffer(X.FRAMEBUFFER, null), this._renderFrameID === b && (this._renderFrameID = null);
        }
        update() {
          this.startRender && this._renderFrameID == null && (this._renderFrameID = requestAnimationFrame(this.render.bind(this)));
        }
      }
      e(h, "defaultOptions", {
        preserveDrawingBuffer: !0,
        autoUpdate: !0,
        vertexPosition: "a_vertexPosition",
        vertexTextureCoord: "a_vertexTextureCoord",
        webgl2: !1
      }), e(h, "UBYTE", h.UNSIGNED_BYTE), e(h, "USHORT", h.UNSIGNED_SHORT), e(h, "fetchShader", s.fetchShader), e(h, "loadImage", s.loadImage);
    },
    /* 16 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "setupWebGL", function() {
        return c;
      }), l.d(d, "createProgram", function() {
        return W;
      }), l.d(d, "pointsToBuffer", function() {
        return u;
      }), l.d(d, "loadImage", function() {
        return n;
      }), l.d(d, "fetchShader", function() {
        return y;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s(a, I) {
        const h = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        let S = null;
        for (let p = 0; p < h.length; ++p) {
          try {
            S = a.getContext(h[p], I);
          } catch {
          }
          if (S)
            break;
        }
        return S;
      }
      function c(a, I) {
        const h = s(a, I);
        if (!h)
          throw new Error("Sorry, your browser doesn't support WebGL.");
        return h;
      }
      function W(a, I, h) {
        const S = a.createShader(a.VERTEX_SHADER);
        if (a.shaderSource(S, I), a.compileShader(S), !a.getShaderParameter(S, a.COMPILE_STATUS)) {
          const V = `Vertex shader failed to compile.  The error log is:${a.getShaderInfoLog(S)}`;
          throw new Error(V);
        }
        const p = a.createShader(a.FRAGMENT_SHADER);
        if (a.shaderSource(p, h), a.compileShader(p), !a.getShaderParameter(p, a.COMPILE_STATUS)) {
          const V = `Fragment shader failed to compile.  The error log is:${a.getShaderInfoLog(p)}`;
          throw new Error(V);
        }
        const X = a.createProgram();
        if (a.attachShader(X, S), a.attachShader(X, p), a.linkProgram(X), !a.getProgramParameter(X, a.LINK_STATUS)) {
          const V = `Shader program failed to link.  The error log is:${a.getProgramInfoLog(X)}`;
          throw new Error(V);
        }
        return a.deleteShader(S), a.deleteShader(p), X;
      }
      function u(a, I = Float32Array, h = null) {
        if (h && !(h instanceof I))
          throw new TypeError("Wrong buffer type.");
        if (a == null || a instanceof I)
          return a;
        if (a[0] == null || a[0].length == null)
          return h ? (h.set(a, 0), h) : new I(a);
        const S = a[0].length, p = a.length;
        h || (h = new I(S * p));
        let X = 0;
        for (let V = 0; V < p; V++)
          for (let i = 0; i < S; i++)
            h[X++] = a[V][i];
        return h;
      }
      const e = {};
      function n(a, {
        useImageBitmap: I = !0,
        alias: h = null
      } = {}) {
        if (!e[a]) {
          if (typeof Image == "function") {
            const S = new Image();
            typeof a == "string" && !(typeof location == "object" && /^file:/.test(location.href)) && !/^data:/.test(a) && (S.crossOrigin = "anonymous"), e[a] = new Promise((p) => {
              S.onload = function() {
                I && typeof createImageBitmap == "function" ? createImageBitmap(S, {
                  imageOrientation: "flipY"
                }).then((X) => {
                  e[a] = X, h && (e[h] = X), p(X);
                }) : (e[a] = S, h && (e[h] = S), p(S));
              }, S.src = a;
            }), h && (e[h] = e[a]);
          } else if (typeof fetch == "function")
            return fetch(a, {
              method: "GET",
              mode: "cors",
              cache: "default"
            }).then((S) => S.blob()).then((S) => createImageBitmap(S, {
              imageOrientation: "flipY"
            }).then((p) => (e[a] = p, h && (e[h] = p), p)));
        }
        return e[a];
      }
      const G = {};
      async function y(a) {
        if (G[a])
          return G[a];
        const I = await fetch(a);
        if (I.status >= 200 && I.status < 300) {
          const h = await I.text();
          return G[a] = h, h;
        }
        throw new Error("Shader loaded error.");
      }
    },
    /* 17 */
    /***/
    function(Z, d, l) {
      l.r(d), d.default = `attribute vec3 a_vertexPosition;

void main() {
  gl_PointSize = 1.0;
  gl_Position = vec4(a_vertexPosition, 1);
}`;
    },
    /* 18 */
    /***/
    function(Z, d, l) {
      l.r(d), d.default = `#ifdef GL_ES
precision mediump float;
#endif

void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
}`;
    },
    /* 19 */
    /***/
    function(Z, d, l) {
      l.r(d), d.default = `attribute vec4 a_vertexPosition;
attribute vec2 a_vertexTextureCoord;
varying vec2 vTextureCoord;

void main() {
  gl_PointSize = 1.0;
  gl_Position = a_vertexPosition;
  vTextureCoord = a_vertexTextureCoord;
}`;
    },
    /* 20 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return u;
      });
      var s = l(21), c = l(25);
      l(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol("transform");
      class u {
        constructor(n, G) {
          this.context = n.getContext("2d"), this.options = G, this[W] = [1, 0, 0, 1, 0, 0];
        }
        createTexture(n) {
          return {
            _img: n
          };
        }
        async loadTexture(n) {
          const G = await s.default.loadImage(n, {
            useImageBitmap: !1
          });
          return this.createTexture(G);
        }
        deleteTexture(n) {
          return n;
        }
        clear(n, G, y, a) {
          const I = this.context;
          n = n || 0, G = G || 0, y = y || I.canvas.width - n, a = a || I.canvas.height - G, I.clearRect(n, G, y, a);
        }
        drawMeshCloud(n, {
          clear: G = !1
        } = {}) {
          const y = [];
          for (let a = 0; a < n.amount; a++) {
            const I = n.getTransform(a);
            let h = n.getTextureFrame(a);
            h && (h = h._img);
            const S = n.getFilter(a), {
              fill: p,
              stroke: X
            } = n.getCloudRGBA(a);
            y.push({
              mesh: n.mesh,
              _cloudOptions: [p, X, h, I, S]
            });
          }
          n.beforeRender && n.beforeRender(this.context, n), this.drawMeshes(y, {
            clear: G,
            hook: !1
          }), n.afterRender && n.afterRender(this.context, n);
        }
        drawMeshes(n, {
          clear: G = !1,
          hook: y = !0
        } = {}) {
          const a = this.context;
          G && a.clearRect(0, 0, a.canvas.width, a.canvas.height);
          let I = null;
          const {
            width: h,
            height: S
          } = a.canvas, p = n.length;
          n.forEach((X, V) => {
            let i, b, t, m, R;
            y && X.beforeRender && X.beforeRender(a, X), X._cloudOptions && ([i, b, t, m, R] = X._cloudOptions, X = X.mesh);
            let x = X.filter;
            if (R && (x = x ? `${x} ${R}` : R), x && !this.filterBuffer && this.filterBuffer !== !1) {
              const C = s.default.createCanvas(h, S);
              C ? this.filterBuffer = C.getContext("2d") : this.filterBuffer = !1;
            }
            I && I !== x && (Object(c.applyFilter)(this.filterBuffer, I), a.drawImage(this.filterBuffer.canvas, 0, 0, h, S), this.filterBuffer.clearRect(0, 0, h, S), I = null), x && this.filterBuffer ? (this.filterBuffer.save(), this.filterBuffer.transform(...this[W]), Object(c.drawMesh2D)(X, this.filterBuffer, !1, i, b, t, m), this.filterBuffer.restore(), V === p - 1 ? (Object(c.applyFilter)(this.filterBuffer, x), a.drawImage(this.filterBuffer.canvas, 0, 0, h, S), this.filterBuffer.clearRect(0, 0, h, S)) : I = x) : (a.save(), a.transform(...this[W]), Object(c.drawMesh2D)(X, a, !1, i, b, t, m), a.restore()), y && X.afterRender && X.afterRender(a, X);
          });
        }
        setTransform(n) {
          this[W] = n;
        }
      }
    },
    /* 21 */
    /***/
    function(Z, d, l) {
      l.r(d), (function(s) {
        var c = l(14), W = l(23), u = l(24);
        l(1).glMatrix.setMatrixArrayType(Array);
        const e = {};
        function n(h, S) {
          const {
            style: p,
            variant: X,
            weight: V,
            stretch: i,
            size: b,
            pxLineHeight: t,
            family: m
          } = h;
          return i === "normal" ? `${p} ${X} ${V} ${b * S}px/${t * S}px ${m}` : `${p} ${X} ${V} ${i} ${b * S}px/${t * S}px ${m}`;
        }
        function G(h, {
          font: S,
          fillColor: p,
          strokeColor: X,
          strokeWidth: V,
          ratio: i = 1,
          textCanvas: b,
          cachable: t = !1
        }) {
          let m;
          if (t) {
            m = [h, S, String(p), String(X), String(V)].join("###");
            const Q = e[m];
            if (Q)
              return Q;
          }
          b || (b = a(1, 1));
          const R = b.getContext("2d");
          R.save(), R.font = S;
          let {
            width: x
          } = R.measureText(h);
          R.restore();
          const C = Object(W.default)(S), T = Math.max(C.pxLineHeight, C.pxHeight * 1.13);
          /italic|oblique/.test(S) && (x += T * Math.tan(15 * Math.PI / 180)), !p && !X && (p = "#000");
          const K = R.canvas, J = Math.ceil(x), F = Math.ceil(T);
          K.width = Math.round(J * i), K.height = Math.round(F * i), R.save(), R.font = n(C, i), R.textAlign = "center", R.textBaseline = "middle";
          const r = K.height * 0.5 + C.pxHeight * 0.05 * i, Y = K.width * 0.5;
          if (p) {
            if (Array.isArray(p))
              p = Object(u.default)(p);
            else if (p.vector) {
              let Q;
              const {
                vector: w,
                colors: O
              } = p;
              w.length === 6 ? Q = R.createRadialGradient(...w) : Q = R.createLinearGradient(...w), O.forEach(({
                offset: q,
                color: k
              }) => {
                Q.addColorStop(q, k);
              }), p = Q;
            }
            R.fillStyle = p, R.fillText(h, Y, r);
          }
          if (X) {
            if (R.lineWidth = V * i, Array.isArray(X))
              X = Object(u.default)(X);
            else if (X.vector) {
              let Q;
              const {
                vector: w,
                colors: O
              } = X;
              w.length === 6 ? Q = R.createRadialGradient(...w) : Q = R.createLinearGradient(...w), O.forEach(({
                offset: q,
                color: k
              }) => {
                Q.addColorStop(q, k);
              }), X = Q;
            }
            R.strokeStyle = X, R.strokeText(h, Y, r);
          }
          R.restore();
          const H = {
            image: b,
            rect: [0, 0, J, F]
          };
          return t && (e[m] = H), H;
        }
        let y = !1;
        if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
          const h = navigator.userAgent.toLowerCase().match(/chrome\/(\d+)/);
          h && (y = Number(h[1]) < 70);
        }
        function a(h, S, p = {}) {
          const X = p.offscreen || !y && p.offscreen !== !1;
          let V;
          return typeof s < "u" && typeof s.createCanvas == "function" ? V = s.createCanvas(h, S, p) : X && typeof OffscreenCanvas == "function" ? V = new OffscreenCanvas(h, S) : (V = document.createElement("canvas"), V.width = h, V.height = S), V;
        }
        const I = {
          createCanvas: a,
          createText: G,
          loadImage: c.default.loadImage
        };
        d.default = I;
      }).call(this, l(22));
    },
    /* 22 */
    /***/
    function(Z, d) {
      var l;
      l = /* @__PURE__ */ function() {
        return this;
      }();
      try {
        l = l || new Function("return this")();
      } catch {
        typeof window == "object" && (l = window);
      }
      Z.exports = l;
    },
    /* 23 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return p;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s(X, V) {
        if (typeof X == "string") {
          const t = X.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%)$/);
          t ? X = {
            size: parseFloat(t[1]),
            unit: t[2]
          } : X = {
            size: parseInt(X, 10),
            unit: "px"
          };
        }
        let {
          size: i,
          unit: b
        } = X;
        if (b === "pt")
          i /= 0.75;
        else if (b === "pc")
          i *= 16;
        else if (b === "in")
          i *= 96;
        else if (b === "cm")
          i *= 96 / 2.54;
        else if (b === "mm")
          i *= 96 / 25.4;
        else if (b === "em" || b === "rem" || b === "ex") {
          if (!V && typeof getComputedStyle == "function" && typeof document < "u") {
            const t = getComputedStyle(document.documentElement).fontSize;
            V = s(t, 16);
          }
          i *= V, b === "ex" && (i /= 2);
        } else if (b === "q")
          i *= 96 / 25.4 / 4;
        else if (b === "vw" || b === "vh") {
          if (typeof document < "u") {
            const t = b === "vw" ? document.documentElement.clientWidth : document.documentElement.clientHeight;
            i *= t / 100;
          }
        } else if ((b === "vmax" || b === "vmin") && typeof document < "u") {
          const t = document.documentElement.clientWidth, m = document.documentElement.clientHeight;
          b === "vmax" ? i *= Math.max(t, m) / 100 : i *= Math.min(t, m) / 100;
        }
        return i;
      }
      const c = "bold|bolder|lighter|[1-9]00", W = "italic|oblique", u = "small-caps", e = "ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded", n = "px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%", G = `'([^']+)'|"([^"]+)"|([\\w-]|[一-龥])+`, y = new RegExp(`(${c}) +`, "i"), a = new RegExp(`(${W}) +`, "i"), I = new RegExp(`(${u}) +`, "i"), h = new RegExp(`(${e}) +`, "i"), S = new RegExp("([\\d\\.]+)(" + n + ")(?:\\/([\\d\\.]+)(" + n + "))? *((?:" + G + ")( *, *(?:" + G + "))*)");
      function p(X, V) {
        const i = S.exec(X);
        if (!i)
          return;
        const b = parseFloat(i[3]), t = {
          weight: "normal",
          style: "normal",
          stretch: "normal",
          variant: "normal",
          size: parseFloat(i[1]),
          unit: i[2],
          lineHeight: Number.isFinite(b) ? b : void 0,
          lineHeightUnit: i[4],
          family: i[5].replace(/ *, */g, ",")
        }, m = X.substring(0, i.index), R = y.exec(m), x = a.exec(m), C = I.exec(m), T = h.exec(m);
        return R && (t.weight = R[1]), x && (t.style = x[1]), C && (t.variant = C[1]), T && (t.stretch = T[1]), t.pxHeight = s({
          size: t.size,
          unit: t.unit
        }, V), t.pxLineHeight = s({
          size: t.lineHeight || t.size,
          unit: t.lineHeightUnit || t.unit
        }, V), t;
      }
    },
    /* 24 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return s;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s(c) {
        return `rgba(${c.map((W, u) => u < 3 ? Math.round(W * 255) : W).join()})`;
      }
    },
    /* 25 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "applyFilter", function() {
        return e;
      }), l.d(d, "drawMesh2D", function() {
        return G;
      });
      var s = l(1), c = l(24), W = l(23), u = l(26);
      l(1).glMatrix.setMatrixArrayType(Array);
      function e(y, a) {
        const I = y.canvas;
        y.save(), y.filter = a, y.drawImage(I, 0, 0, I.width, I.height), y.restore();
      }
      function n(y, a) {
        const I = /rgba\((\d+),(\d+),(\d+),(\d+)\)/;
        y = y.match(I).slice(1, 5).map(Number), a = a.match(I).slice(1, 5).map(Number);
        const h = [], S = a[3];
        for (let p = 0; p < 4; p++)
          h[p] = Object(u.mix)(y[p], a[p], S);
        return `rgba(${h.join()})`;
      }
      function G(y, a, I = !0, h = null, S = null, p = null, X = null) {
        a.save();
        let V = !1, i = !1;
        if (a.globalAlpha = y.getOpacity(), y._updateMatrix && y.transformScale / y.contours.scale > 1.5 && y.accurate(y.transformScale), y.lineWidth) {
          let m = y.gradient && y.gradient.stroke;
          if (m) {
            const {
              vector: R,
              colors: x
            } = m;
            if (R.length === 6)
              m = a.createRadialGradient(...R);
            else if (R.length === 4)
              m = a.createLinearGradient(...R);
            else if (R.length === 3)
              m = a.createCircularGradient(...R);
            else
              throw new TypeError("Invalid vector dimension.");
            x.forEach(({
              offset: C,
              color: T
            }) => {
              let K = Object(c.default)(T);
              S && (K = n(K, S)), m.addColorStop(C, K);
            }), a.strokeStyle = m, V = !0;
          } else
            y.strokeStyle && (S ? a.strokeStyle = n(y.strokeStyle, S) : a.strokeStyle = y.strokeStyle, V = !0);
        }
        V && (a.lineWidth = y.lineWidth, a.lineJoin = y.lineJoin, a.lineCap = y.lineCap, a.miterLimit = y.miterLimit, y.lineDash && (a.setLineDash(y.lineDash), y.lineDashOffset && (a.lineDashOffset = y.lineDashOffset)));
        let b = y.gradient && y.gradient.fill;
        if (b) {
          const {
            vector: m,
            colors: R
          } = b;
          if (m.length === 6)
            b = a.createRadialGradient(...m);
          else if (m.length === 4)
            b = a.createLinearGradient(...m);
          else if (m.length === 3)
            b = a.createCircularGradient(...m);
          else
            throw new TypeError("Invalid vector dimension.");
          R.forEach(({
            offset: x,
            color: C
          }) => {
            let T = Object(c.default)(C);
            S && (T = n(T, S)), b.addColorStop(x, T);
          }), a.fillStyle = b, i = !0;
        } else
          y.fillStyle && (h ? a.fillStyle = n(y.fillStyle, h) : a.fillStyle = y.fillStyle, i = !0);
        if (X && a.transform(...X), a.transform(...y.transformMatrix), y.clipPath) {
          const m = y.clipPath, R = new Path2D(m);
          a.clip(R);
        }
        const t = y.contours.length;
        if (y.contours.forEach((m, R) => {
          const x = m.length, C = x > 1 && s.vec2.equals(m[0], m[x - 1]), T = R === t - 1 && y.texture;
          if (m && x > 0) {
            if (i || V || T) {
              a.beginPath(), a.moveTo(...m[0]);
              for (let K = 1; K < x; K++)
                K === x - 1 && C ? a.closePath() : a.lineTo(...m[K]);
            }
            if (i && a.fill(y.fillRule), T) {
              a.save(), a.clip();
              let {
                image: K,
                options: J
              } = y.texture;
              if (p && (K = p), J.repeat && console.warn("Context 2D not supported image repeat yet."), K.font) {
                J.scale && console.warn("Context 2D not supported text scale yet."), J.srcRect && console.warn("Context 2D not supported text srcRect yet.");
                let {
                  font: F,
                  fillColor: r,
                  strokeColor: Y,
                  strokeWidth: H,
                  text: Q
                } = K;
                !r && !Y && (r = "#000"), Array.isArray(r) && (r = Object(c.default)(r)), Array.isArray(Y) && (Y = Object(c.default)(Y)), a.font = F;
                const {
                  width: w
                } = a.measureText(Q), O = Object(W.default)(F), q = Math.max(O.pxLineHeight, O.pxHeight * 1.13);
                a.textAlign = "center", a.textBaseline = "middle";
                const k = J.rect, P = k[0] + q * 0.5 + O.pxHeight * 0.06, D = k[1] + w * 0.5;
                k[2] != null && a.scale(k[2] / w, k[3] / q), r && (a.fillStyle = r, a.fillText(Q, D, P)), Y && (a.lineWidth = H, a.strokeStyle = Y, a.strokeText(Q, D, P));
              } else {
                let F = J.rect;
                const r = J.srcRect;
                J.scale && (F = [0, 0, a.canvas.width, a.canvas.height]), J.rotated && F && (F = [-F[1], F[0], F[3], F[2]]), r && (F = F || [0, 0, r[2], r[3]]), J.rotated && (a.translate(0, F ? F[2] : K.width), a.rotate(-0.5 * Math.PI)), r ? a.drawImage(K, ...r, ...F) : F ? a.drawImage(K, ...F) : a.drawImage(K, 0, 0);
              }
              a.restore();
            }
            V && a.stroke();
          }
        }), a.restore(), I) {
          const m = y.filter;
          m && e(a, m);
        }
      }
    },
    /* 26 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "clamp", function() {
        return s;
      }), l.d(d, "mix", function() {
        return c;
      }), l.d(d, "transformPoint", function() {
        return W;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s(u, e, n) {
        return e > n && ([e, n] = [n, e]), u < e ? e : u > n ? n : u;
      }
      function c(u, e, n) {
        return u * (1 - n) + e * n;
      }
      function W(u, e) {
        const [n, G] = u;
        return [n * e[0] + G * e[2] + e[4], n * e[1] + G * e[3] + e[5]];
      }
    },
    /* 27 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return n;
      });
      var s = l(28), c = l(29);
      l(1).glMatrix.setMatrixArrayType(Array);
      function W(G, y, a) {
        const I = G.uniforms || {}, h = y.uniforms || {};
        if (I.u_texSampler && h.u_texSampler && I.u_texSampler !== h.u_texSampler)
          return !1;
        const S = Object.keys(I), p = Object.keys(h), X = S.indexOf("u_texSampler"), V = p.indexOf("u_texSampler");
        if (X >= 0 && S.splice(X, 1), V >= 0 && p.splice(V, 1), S.length !== p.length)
          return !1;
        const i = S.every((b) => {
          const t = I[b], m = h[b];
          if (t === m)
            return !0;
          if (t.length && m.length && t.length === m.length) {
            for (let R = 0; R < t.length; R++)
              if (t[R] !== m[R])
                return !1;
            return !0;
          }
          return !1;
        });
        if (i) {
          if (I.u_texSampler && !h.u_texSampler)
            y.setTexture(I.u_texSampler, {
              hidden: !0
            });
          else if (!I.u_texSampler && h.u_texSampler)
            for (let b = 0; b < a.length; b++)
              a[b].setTexture(h.u_texSampler, {
                hidden: !0
              });
        }
        return i;
      }
      const u = {};
      function e(G, y) {
        if (G.length) {
          const a = Object(s.default)(G, u);
          return a.enableBlend = y, G[0].filterCanvas && (a.filterCanvas = !0), a.packIndex = G[0].packIndex, a.packLength = G.length, a.beforeRender = G[0].beforeRender, a.pass = G[0].pass, a.afterRender = G[G.length - 1].afterRender, G.length = 0, a;
        }
      }
      function* n(G, y, a = !1) {
        const I = [], h = G.options.bufferSize;
        let S = 0, p = !1;
        for (let X = 0; X < y.length; X++) {
          const V = y[X];
          if (V instanceof c.default)
            I.length && (yield e(I, p)), S = 0, p = !1, yield V;
          else {
            const i = V.meshData;
            if (i.clipPath && !i.uniforms.u_clipSampler) {
              const t = G.createTexture(i.clipPath);
              i.uniforms.u_clipSampler = t;
            }
            let b = 0;
            if ((!a || !V.canIgnore()) && i && i.positions.length) {
              V.packIndex = X;
              const t = V.filterCanvas;
              if (b = i.positions.length, t || S + b > h)
                I.length && (yield e(I, p)), S = 0, p = !1;
              else if (S) {
                const m = I[I.length - 1];
                m && (m.filterCanvas || m.afterRender || V.beforeRender || m.pass.length || V.pass.length || m.program !== V.program || !W(m, V, I)) && (yield e(I, p), S = 0, p = !1);
              }
              I.push(V), p = p || V.enableBlend, S += b;
            }
            X === y.length - 1 && I.length && (yield e(I, p));
          }
        }
      }
    },
    /* 28 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return W;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const s = {
        UNSIGNED_BYTE: Uint8Array,
        UNSIGNED_SHORT: Uint16Array,
        BYTE: Int8Array,
        SHORT: Int16Array,
        FLOAT: Float32Array
      };
      function c(u, e) {
        let n = 0, G = 0, y = 0, a = 0, I = 0, h = 0, S = 0;
        const p = u[0].program;
        for (let X = 0; X < u.length; X++) {
          const V = u[X].meshData;
          if (V) {
            S += V.positions.length;
            const i = V.positions[0].length;
            n += V.positions.length * i, G += V.cells.length * 3, h += V.attributes.a_color.length * 4;
            const b = V.textureCoord;
            b && (y += b.length * b[0].length);
            const t = V.attributes.a_sourceRect;
            t && (a += t.length * 4);
            const m = V.attributes.a_clipUV;
            m && (I += m.length * 2);
          }
        }
        if ((!e.positions || e.positions.length < n) && (e.positions = new Float32Array(n)), (!e.cells || e.cells.length < G) && (e.cells = new Uint16Array(G)), y && (!e.textureCoord || e.textureCoord.length < y) && (e.textureCoord = new Float32Array(y)), (!e.a_color || e.a_color.length < h) && (e.a_color = new Uint8Array(h)), a && (!e.a_sourceRect || e.a_sourceRect.length < a) && (e.a_sourceRect = new Float32Array(a)), I && (!e.a_clipUV || e.a_clipUV.length < I) && (e.a_clipUV = new Float32Array(I)), p) {
          const X = Object.entries(p._attribute), V = p._attribOpts || {};
          for (let i = 0; i < X.length; i++) {
            const [b, t] = X[i];
            if (b !== "a_color" && b !== "a_sourceRect" && t !== "ignored") {
              const m = V[b] ? V[b].type : "FLOAT", R = s[m], x = t.size * S;
              (!e[b] || e[b].length < x) && (e[b] = new R(x));
            }
          }
        }
        return e;
      }
      function W(u, e) {
        let n = [], G = [], y = [], a = [], I = [], h = [], S = 0, p = 0;
        const X = u[0] ? u[0].uniforms || {} : {}, V = u[0] ? u[0].program : null;
        e && (c(u, e), G = e.cells, n = e.positions, y = e.textureCoord, a = e.a_color, I = e.a_sourceRect, h = e.a_clipUV);
        let i = !1, b = !1;
        const t = {};
        for (let R = 0; R < u.length; R++) {
          let x = u[R];
          if (x) {
            if (x.meshData && (x = x.meshData), e) {
              const T = x.positions;
              for (let K = 0; K < T.length; K++) {
                const J = T[K], F = 3 * (S + K);
                for (let r = 0; r < J.length; r++)
                  n[F + r] = J[r];
              }
            } else
              n.push(...x.positions);
            const C = x.cells;
            for (let T = 0; T < C.length; T++) {
              const K = C[T];
              if (e) {
                const J = 3 * (p + T);
                G[J] = K[0] + S, G[J + 1] = K[1] + S, G[J + 2] = K[2] + S;
              } else
                G.push([K[0] + S, K[1] + S, K[2] + S]);
            }
            if (e) {
              const T = x.attributes.a_color;
              for (let K = 0; K < T.length; K++) {
                const J = T[K], F = 4 * (S + K);
                a[F] = J[0], a[F + 1] = J[1], a[F + 2] = J[2], a[F + 3] = J[3];
              }
            } else
              a.push(...x.attributes.a_color);
            if (x.attributes.a_sourceRect)
              if (i = !0, e) {
                const T = x.attributes.a_sourceRect;
                for (let K = 0; K < T.length; K++) {
                  const J = T[K], F = 4 * (S + K);
                  I[F] = J[0], I[F + 1] = J[1], I[F + 2] = J[2], I[F + 3] = J[3];
                }
              } else
                I.push(...x.attributes.a_sourceRect);
            if (x.attributes.a_clipUV)
              if (b = !0, e) {
                const T = x.attributes.a_clipUV;
                for (let K = 0; K < T.length; K++) {
                  const J = T[K], F = 2 * (S + K);
                  h[F] = J[0], h[F + 1] = J[1];
                }
              } else
                h.push(...x.attributes.a_clipUV);
            if (x.textureCoord)
              if (e) {
                const T = x.textureCoord;
                for (let K = 0; K < T.length; K++) {
                  const J = T[K], F = 3 * (S + K);
                  for (let r = 0; r < J.length; r++)
                    y[F + r] = J[r];
                }
              } else
                y.push(...x.textureCoord);
            if (V) {
              const T = Object.entries(V._attribute);
              for (let K = 0; K < T.length; K++) {
                const [J, F] = T[K];
                if (J !== "a_color" && J !== "a_sourceRect" && F !== "ignored")
                  if (t[J] = [], e) {
                    t[J] = e[J];
                    const r = x.attributes[J], Y = r[0].length;
                    for (let H = 0; H < r.length; H++) {
                      const Q = r[H], w = Y * (S + H);
                      for (let O = 0; O < Q.length; O++)
                        t[J][w + O] = Q[O];
                    }
                  } else
                    t[J].push(...x.attributes[J]);
              }
            }
            S += x.positions.length, p += x.cells.length;
          }
        }
        t.a_color = a, i && I && I.length > 0 && (t.a_sourceRect = I);
        const m = {
          positions: n,
          cells: G,
          attributes: t,
          uniforms: X,
          cellsCount: p * 3,
          program: V
        };
        return y && y.length && (m.textureCoord = y), b && h.length > 0 && (t.a_clipUV = h), m;
      }
    },
    /* 29 */
    /***/
    function(Z, d, l) {
      l.r(d);
      var s = l(1), c = l(30), W = l(26), u = l(31);
      l(1).glMatrix.setMatrixArrayType(Array);
      function e(t, m) {
        var R = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var x = Object.getOwnPropertySymbols(t);
          m && (x = x.filter(function(C) {
            return Object.getOwnPropertyDescriptor(t, C).enumerable;
          })), R.push.apply(R, x);
        }
        return R;
      }
      function n(t) {
        for (var m = 1; m < arguments.length; m++) {
          var R = arguments[m] != null ? arguments[m] : {};
          m % 2 ? e(Object(R), !0).forEach(function(x) {
            G(t, x, R[x]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(R)) : e(Object(R)).forEach(function(x) {
            Object.defineProperty(t, x, Object.getOwnPropertyDescriptor(R, x));
          });
        }
        return t;
      }
      function G(t, m, R) {
        return m in t ? Object.defineProperty(t, m, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : t[m] = R, t;
      }
      const y = Symbol("mesh"), a = Symbol("count"), I = Symbol("blend"), h = Symbol("filter"), S = Symbol("textures"), p = Symbol("textureOptions"), X = Symbol("cloudColor"), V = Symbol("cloudFilter"), i = Symbol("buffer");
      function b(t, m = null) {
        const R = new Float32Array(3 * t), x = new Float32Array(3 * t), C = new Float32Array(4 * t), T = new Float32Array(4 * t), K = new Float32Array(4 * t), J = new Float32Array(4 * t), F = new Float32Array(4 * t), r = new Uint8Array(t), Y = new Uint8Array(4 * t), H = new Uint8Array(4 * t);
        return m && (R.set(m.transform0, 0), x.set(m.transform1, 0), C.set(m.color0, 0), T.set(m.color1, 0), K.set(m.color2, 0), J.set(m.color3, 0), F.set(m.color4, 0), r.set(m.frameIndex, 0), Y.set(m.fillColor, 0), H.set(m.strokeColor, 0)), {
          bufferSize: t,
          transform0: R,
          transform1: x,
          color0: C,
          color1: T,
          color2: K,
          color3: J,
          color4: F,
          frameIndex: r,
          fillColor: Y,
          strokeColor: H
        };
      }
      d.default = class {
        constructor(t, m = 1, {
          buffer: R = 1e3
        } = {}) {
          R = Math.max(R, m), this[a] = m, this[y] = t, this[i] = b(R), this[S] = [], this[h] = [], this[X] = !1, this[V] = !1, this[I] = !1, this.initBuffer();
        }
        initBuffer(t = 0) {
          const m = this[a];
          for (let R = t; R < m; R++)
            this[i].transform0.set([1, 0, 0], R * 3), this[i].transform1.set([0, 1, 0], R * 3), this[i].frameIndex.set([-1], R), this[i].fillColor.set([0, 0, 0, 0], R * 4), this[i].strokeColor.set([0, 0, 0, 0], R * 4), this.setColorTransform(R, null);
        }
        get bufferSize() {
          return this[i].bufferSize;
        }
        get mesh() {
          return this[y];
        }
        set mesh(t) {
          this[y] = t, this[S] && this.setTextureFrames(this[S], this[p]);
        }
        get hasCloudColor() {
          return this[X];
        }
        get hasCloudFilter() {
          return this[V];
        }
        _getFilter(t) {
          return this[h][t] = this[h][t] || [], this[h][t];
        }
        getFilter(t) {
          return this._getFilter(t).join(" ");
        }
        get enableBlend() {
          return this[y].enableBlend || this[I];
        }
        canIgnore() {
          return this[y].canIgnore();
        }
        delete(t) {
          if (t >= this[a] || t < 0)
            throw new Error("Out of range.");
          const {
            transform0: m,
            transform1: R,
            color0: x,
            color1: C,
            color2: T,
            color3: K,
            color4: J,
            frameIndex: F,
            fillColor: r,
            strokeColor: Y
          } = this[i];
          m.set(m.subarray(3 * (t + 1)), 3 * t), R.set(R.subarray(3 * (t + 1)), 3 * t), x.set(x.subarray(4 * (t + 1)), 4 * t), C.set(C.subarray(4 * (t + 1)), 4 * t), T.set(T.subarray(4 * (t + 1)), 4 * t), K.set(K.subarray(4 * (t + 1)), 4 * t), J.set(J.subarray(4 * (t + 1)), 4 * t), F.set(F.subarray(t + 1), t), r.set(r.subarray(4 * (t + 1)), 4 * t), Y.set(Y.subarray(4 * (t + 1)), 4 * t);
          for (const H in this[h])
            H === t ? delete this[h][H] : H > t && (this[h][H - 1] = this[h][H], delete this[h][H]);
          this[a]--;
        }
        setColorTransform(t, m) {
          if (t >= this[a] || t < 0)
            throw new Error("Out of range.");
          t *= 4;
          const {
            color0: R,
            color1: x,
            color2: C,
            color3: T,
            color4: K
          } = this[i];
          return m != null ? (R.set([m[0], m[5], m[10], m[15]], t), x.set([m[1], m[6], m[11], m[16]], t), C.set([m[2], m[7], m[12], m[17]], t), T.set([m[3], m[8], m[13], m[18]], t), K.set([m[4], m[9], m[14], m[19]], t), this[I] = this[I] || m[18] < 1, this[V] = !0) : (R.set([1, 0, 0, 0], t), x.set([0, 1, 0, 0], t), C.set([0, 0, 1, 0], t), T.set([0, 0, 0, 1], t), K.set([0, 0, 0, 0], t)), this;
        }
        getColorTransform(t) {
          if (t >= this[a] || t < 0)
            throw new Error("Out of range.");
          t *= 4;
          const {
            color0: m,
            color1: R,
            color2: x,
            color3: C,
            color4: T
          } = this[i];
          return [m[t], R[t], x[t], C[t], T[t], m[t + 1], R[t + 1], x[t + 1], C[t + 1], T[t + 1], m[t + 2], R[t + 2], x[t + 2], C[t + 2], T[t + 2], m[t + 3], R[t + 3], x[t + 3], C[t + 3], T[t + 3]];
        }
        transformColor(t, m) {
          let R = this.getColorTransform(t);
          return R = Object(c.multiply)(R, m), this.setColorTransform(t, R), this;
        }
        setFillColor(t, m) {
          if (t >= this[a] || t < 0)
            throw new Error("Out of range.");
          typeof m == "string" && (m = Object(u.default)(m)), m[3] > 0 && (this[X] = !0), this[i].fillColor.set(m.map((R) => Math.round(255 * R)), 4 * t);
        }
        setStrokeColor(t, m) {
          if (t >= this[a] || t < 0)
            throw new Error("Out of range.");
          typeof m == "string" && (m = Object(u.default)(m)), m[3] > 0 && (this[X] = !0), this[i].strokeColor.set(m.map((R) => Math.round(255 * R)), 4 * t);
        }
        getCloudRGBA(t) {
          if (t >= this[a] || t < 0)
            throw new Error("Out of range.");
          t *= 4;
          const {
            fillColor: m,
            strokeColor: R
          } = this[i], x = [m[t], m[t + 1], m[t + 2], m[t + 3]], C = [R[t], R[t + 1], R[t + 2], R[t + 3]];
          return x[3] /= 255, C[3] /= 255, {
            fill: `rgba(${x.join()})`,
            stroke: `rgba(${C.join()})`
          };
        }
        grayscale(t, m) {
          this.transformColor(t, Object(c.grayscale)(m)), this._getFilter(t).push(`grayscale(${100 * m}%)`);
        }
        brightness(t, m) {
          this.transformColor(t, Object(c.brightness)(m)), this._getFilter(t).push(`brightness(${100 * m}%)`);
        }
        saturate(t, m) {
          this.transformColor(t, Object(c.saturate)(m)), this._getFilter(t).push(`saturate(${100 * m}%)`);
        }
        contrast(t, m) {
          this.transformColor(t, Object(c.contrast)(m)), this._getFilter(t).push(`contrast(${100 * m}%)`);
        }
        invert(t, m) {
          this.transformColor(t, Object(c.invert)(m)), this._getFilter(t).push(`invert(${100 * m}%)`);
        }
        sepia(t, m) {
          this.transformColor(t, Object(c.sepia)(m)), this._getFilter(t).push(`sepia(${100 * m}%)`);
        }
        opacity(t, m) {
          this.transformColor(t, Object(c.opacity)(m)), this._getFilter(t).push(`opacity(${100 * m}%)`);
        }
        hueRotate(t, m) {
          this.transformColor(t, Object(c.hueRotate)(m)), this._getFilter(t).push(`hue-rotate(${m}deg)`);
        }
        setTransform(t, m) {
          if (t >= this[a] || t < 0)
            throw new Error("Out of range.");
          t *= 3, m == null && (m = [1, 0, 0, 1, 0, 0]);
          const {
            transform0: R,
            transform1: x
          } = this[i];
          return R.set([m[0], m[2], m[4]], t), x.set([m[1], m[3], m[5]], t), this;
        }
        getTransform(t) {
          if (t >= this[a] || t < 0)
            throw new Error("Out of range.");
          t *= 3;
          const {
            transform0: m,
            transform1: R
          } = this[i];
          return [m[t], R[t], m[t + 1], R[t + 1], m[t + 2], R[t + 2]];
        }
        getTextureFrame(t) {
          return this[S][this[i].frameIndex[t]];
        }
        setTextureFrames(t = [], m = {}) {
          if (t.length > 12)
            throw new Error("Max frames exceed. Allow 12 frames.");
          t.length && this[y].setTexture(t[0], m), this[S] = t, this[p] = m;
        }
        setFrameIndex(t, m) {
          if (t >= this[a] || t < 0)
            throw new Error("Out of range.");
          const R = this[S].length;
          if (R <= 0)
            throw new Error("No frames");
          this[i].frameIndex[t] = m % R;
        }
        get amount() {
          return this[a];
        }
        set amount(t) {
          const m = this[a];
          t !== m && (t > this[i].bufferSize && (this[i] = b(Math.max(t, this[i].bufferSize + 1e3), this[i])), this[a] = t, t > m && this.initBuffer(m));
        }
        get meshData() {
          const {
            attributes: t,
            cells: m,
            positions: R,
            textureCoord: x,
            uniforms: C
          } = this[y].meshData, T = this[S], K = {
            attributes: n({}, t),
            cells: m,
            positions: R,
            textureCoord: x,
            uniforms: n({}, C),
            instanceCount: this[a],
            enableBlend: this.enableBlend
          };
          T.length && T.forEach((P, D) => {
            K.uniforms[`u_texFrame${D}`] = P;
          });
          const {
            transform0: J,
            transform1: F,
            color0: r,
            color1: Y,
            color2: H,
            color3: Q,
            color4: w,
            fillColor: O,
            strokeColor: q,
            frameIndex: k
          } = this[i];
          return this[y].uniforms.u_texSampler && (K.attributes.a_frameIndex = {
            data: k,
            divisor: 1
          }), K.attributes.a_transform0 = {
            data: J,
            divisor: 1
          }, K.attributes.a_transform1 = {
            data: F,
            divisor: 1
          }, K.attributes.a_colorCloud0 = {
            data: r,
            divisor: 1
          }, K.attributes.a_colorCloud1 = {
            data: Y,
            divisor: 1
          }, K.attributes.a_colorCloud2 = {
            data: H,
            divisor: 1
          }, K.attributes.a_colorCloud3 = {
            data: Q,
            divisor: 1
          }, K.attributes.a_colorCloud4 = {
            data: w,
            divisor: 1
          }, this.hasCloudColor && (K.attributes.a_fillCloudColor = {
            data: O,
            divisor: 1
          }, K.attributes.a_strokeCloudColor = {
            data: q,
            divisor: 1
          }), K;
        }
        setProgram(t) {
          this[y].setProgram(t);
        }
        get program() {
          return this[y].program;
        }
        transform(t, m) {
          const R = this.getTransform(t);
          return m = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), R, m), this.setTransform(t, m), this;
        }
        translate(t, [m, R]) {
          let x = s.mat2d.create();
          return x = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), x, [m, R]), this.transform(t, x);
        }
        rotate(t, m, [R, x] = [0, 0]) {
          let C = s.mat2d.create();
          return C = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [R, x]), C = s.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), C, m), C = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), C, [-R, -x]), this.transform(t, C);
        }
        scale(t, [m, R = m], [x, C] = [0, 0]) {
          let T = s.mat2d.create();
          return T = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [x, C]), T = s.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), T, [m, R]), T = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-x, -C]), this.transform(t, T);
        }
        skew(t, [m, R = m], [x, C] = [0, 0]) {
          let T = s.mat2d.create();
          return T = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [x, C]), T = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), T, s.mat2d.fromValues(1, Math.tan(R), Math.tan(m), 1, 0, 0)), T = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-x, -C]), this.transform(t, T);
        }
        isPointCollision(t, [m, R], x = "both") {
          const C = this.getTransform(t), T = Object(W.transformPoint)([m, R], s.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C));
          return this[y].isPointCollision(...T, x);
        }
        isPointInFill(t, [m, R]) {
          return this.isPointCollision(t, [m, R], "fill");
        }
        isPointInStroke(t, [m, R]) {
          return this.isPointCollision(t, [m, R], "stroke");
        }
      };
    },
    /* 30 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "multiply", function() {
        return c;
      }), l.d(d, "grayscale", function() {
        return W;
      }), l.d(d, "brightness", function() {
        return u;
      }), l.d(d, "saturate", function() {
        return e;
      }), l.d(d, "contrast", function() {
        return n;
      }), l.d(d, "invert", function() {
        return G;
      }), l.d(d, "sepia", function() {
        return y;
      }), l.d(d, "opacity", function() {
        return a;
      }), l.d(d, "hueRotate", function() {
        return I;
      });
      var s = l(26);
      l(1).glMatrix.setMatrixArrayType(Array);
      function c(h, S) {
        const p = [], X = h[0], V = h[1], i = h[2], b = h[3], t = h[4], m = h[5], R = h[6], x = h[7], C = h[8], T = h[9], K = h[10], J = h[11], F = h[12], r = h[13], Y = h[14], H = h[15], Q = h[16], w = h[17], O = h[18], q = h[19];
        let k = S[0], P = S[1], D = S[2], ll = S[3], _ = S[4];
        return p[0] = k * X + P * m + D * K + ll * H, p[1] = k * V + P * R + D * J + ll * Q, p[2] = k * i + P * x + D * F + ll * w, p[3] = k * b + P * C + D * r + ll * O, p[4] = k * t + P * T + D * Y + ll * q + _, k = S[5], P = S[6], D = S[7], ll = S[8], _ = S[9], p[5] = k * X + P * m + D * K + ll * H, p[6] = k * V + P * R + D * J + ll * Q, p[7] = k * i + P * x + D * F + ll * w, p[8] = k * b + P * C + D * r + ll * O, p[9] = k * t + P * T + D * Y + ll * q + _, k = S[10], P = S[11], D = S[12], ll = S[13], _ = S[14], p[10] = k * X + P * m + D * K + ll * H, p[11] = k * V + P * R + D * J + ll * Q, p[12] = k * i + P * x + D * F + ll * w, p[13] = k * b + P * C + D * r + ll * O, p[14] = k * t + P * T + D * Y + ll * q + _, k = S[15], P = S[16], D = S[17], ll = S[18], _ = S[19], p[15] = k * X + P * m + D * K + ll * H, p[16] = k * V + P * R + D * J + ll * Q, p[17] = k * i + P * x + D * F + ll * w, p[18] = k * b + P * C + D * r + ll * O, p[19] = k * t + P * T + D * Y + ll * q + _, p;
      }
      function W(h) {
        h = Object(s.clamp)(0, 1, h);
        const S = 0.2126 * h, p = 0.7152 * h, X = 0.0722 * h;
        return [S + 1 - h, p, X, 0, 0, S, p + 1 - h, X, 0, 0, S, p, X + 1 - h, 0, 0, 0, 0, 0, 1, 0];
      }
      function u(h) {
        return [h, 0, 0, 0, 0, 0, h, 0, 0, 0, 0, 0, h, 0, 0, 0, 0, 0, 1, 0];
      }
      function e(h) {
        const S = 0.2126 * (1 - h), p = 0.7152 * (1 - h), X = 0.0722 * (1 - h);
        return [S + h, p, X, 0, 0, S, p + h, X, 0, 0, S, p, X + h, 0, 0, 0, 0, 0, 1, 0];
      }
      function n(h) {
        const S = 0.5 * (1 - h);
        return [h, 0, 0, 0, S, 0, h, 0, 0, S, 0, 0, h, 0, S, 0, 0, 0, 1, 0];
      }
      function G(h) {
        const S = 1 - 2 * h;
        return [S, 0, 0, 0, h, 0, S, 0, 0, h, 0, 0, S, 0, h, 0, 0, 0, 1, 0];
      }
      function y(h) {
        return [1 - 0.607 * h, 0.769 * h, 0.189 * h, 0, 0, 0.349 * h, 1 - 0.314 * h, 0.168 * h, 0, 0, 0.272 * h, 0.534 * h, 1 - 0.869 * h, 0, 0, 0, 0, 0, 1, 0];
      }
      function a(h) {
        return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, h, 0];
      }
      function I(h) {
        const S = h / 180 * Math.PI, p = Math.cos(S), X = Math.sin(S), V = 0.2126, i = 0.7152, b = 0.0722;
        return [V + p * (1 - V) + X * -V, i + p * -i + X * -i, b + p * -b + X * (1 - b), 0, 0, V + p * -V + X * 0.143, i + p * (1 - i) + X * 0.14, b + p * -b + X * -0.283, 0, 0, V + p * -V + X * -(1 - V), i + p * -i + X * i, b + p * (1 - b) + X * b, 0, 0, 0, 0, 0, 1, 0];
      }
    },
    /* 31 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return W;
      });
      var s = l(32), c = /* @__PURE__ */ l.n(s);
      l(1).glMatrix.setMatrixArrayType(Array);
      function W(u) {
        const e = c()(u);
        if (!e || !e.length)
          throw new TypeError("Invalid color value.");
        return [e[0] / 255, e[1] / 255, e[2] / 255, e[3]];
      }
    },
    /* 32 */
    /***/
    function(Z, d, l) {
      var s = l(33), c = l(37), W = l(39);
      Z.exports = function(e) {
        var n, G = s(e);
        return G.space ? (n = Array(3), n[0] = W(G.values[0], 0, 255), n[1] = W(G.values[1], 0, 255), n[2] = W(G.values[2], 0, 255), G.space[0] === "h" && (n = c.rgb(n)), n.push(W(G.alpha, 0, 1)), n) : [];
      };
    },
    /* 33 */
    /***/
    function(Z, d, l) {
      (function(s) {
        var c = l(34), W = l(35), u = l(36);
        Z.exports = n;
        var e = {
          red: 0,
          orange: 60,
          yellow: 120,
          green: 180,
          blue: 240,
          purple: 300
        };
        function n(G) {
          var y, a = [], I = 1, h;
          if (typeof G == "string")
            if (c[G])
              a = c[G].slice(), h = "rgb";
            else if (G === "transparent")
              I = 0, h = "rgb", a = [0, 0, 0];
            else if (/^#[A-Fa-f0-9]+$/.test(G)) {
              var S = G.slice(1), p = S.length, X = p <= 4;
              I = 1, X ? (a = [
                parseInt(S[0] + S[0], 16),
                parseInt(S[1] + S[1], 16),
                parseInt(S[2] + S[2], 16)
              ], p === 4 && (I = parseInt(S[3] + S[3], 16) / 255)) : (a = [
                parseInt(S[0] + S[1], 16),
                parseInt(S[2] + S[3], 16),
                parseInt(S[4] + S[5], 16)
              ], p === 8 && (I = parseInt(S[6] + S[7], 16) / 255)), a[0] || (a[0] = 0), a[1] || (a[1] = 0), a[2] || (a[2] = 0), h = "rgb";
            } else if (y = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(G)) {
              var V = y[1], i = V === "rgb", S = V.replace(/a$/, "");
              h = S;
              var p = S === "cmyk" ? 4 : S === "gray" ? 1 : 3;
              a = y[2].trim().split(/\s*,\s*/).map(function(R, x) {
                if (/%$/.test(R))
                  return x === p ? parseFloat(R) / 100 : S === "rgb" ? parseFloat(R) * 255 / 100 : parseFloat(R);
                if (S[x] === "h") {
                  if (/deg$/.test(R))
                    return parseFloat(R);
                  if (e[R] !== void 0)
                    return e[R];
                }
                return parseFloat(R);
              }), V === S && a.push(1), I = i || a[p] === void 0 ? 1 : a[p], a = a.slice(0, p);
            } else
              G.length > 10 && /[0-9](?:\s|\/)/.test(G) && (a = G.match(/([0-9]+)/g).map(function(t) {
                return parseFloat(t);
              }), h = G.match(/([a-z])/ig).join("").toLowerCase());
          else if (!isNaN(G))
            h = "rgb", a = [G >>> 16, (G & 65280) >>> 8, G & 255];
          else if (W(G)) {
            var b = u(G.r, G.red, G.R, null);
            b !== null ? (h = "rgb", a = [
              b,
              u(G.g, G.green, G.G),
              u(G.b, G.blue, G.B)
            ]) : (h = "hsl", a = [
              u(G.h, G.hue, G.H),
              u(G.s, G.saturation, G.S),
              u(G.l, G.lightness, G.L, G.b, G.brightness)
            ]), I = u(G.a, G.alpha, G.opacity, 1), G.opacity != null && (I /= 100);
          } else
            (Array.isArray(G) || s.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(G)) && (a = [G[0], G[1], G[2]], h = "rgb", I = G.length === 4 ? G[3] : 1);
          return {
            space: h,
            values: a,
            alpha: I
          };
        }
      }).call(this, l(22));
    },
    /* 34 */
    /***/
    function(Z, d, l) {
      Z.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    },
    /* 35 */
    /***/
    function(Z, d, l) {
      var s = Object.prototype.toString;
      Z.exports = function(c) {
        var W;
        return s.call(c) === "[object Object]" && (W = Object.getPrototypeOf(c), W === null || W === Object.getPrototypeOf({}));
      };
    },
    /* 36 */
    /***/
    function(Z, d) {
      Z.exports = function() {
        for (var l = 0; l < arguments.length; l++)
          if (arguments[l] !== void 0)
            return arguments[l];
      };
    },
    /* 37 */
    /***/
    function(Z, d, l) {
      var s = l(38);
      Z.exports = {
        name: "hsl",
        min: [0, 0, 0],
        max: [360, 100, 100],
        channel: ["hue", "saturation", "lightness"],
        alias: ["HSL"],
        rgb: function(c) {
          var W = c[0] / 360, u = c[1] / 100, e = c[2] / 100, n, G, y, a, I;
          if (u === 0)
            return I = e * 255, [I, I, I];
          e < 0.5 ? G = e * (1 + u) : G = e + u - e * u, n = 2 * e - G, a = [0, 0, 0];
          for (var h = 0; h < 3; h++)
            y = W + 1 / 3 * -(h - 1), y < 0 ? y++ : y > 1 && y--, 6 * y < 1 ? I = n + (G - n) * 6 * y : 2 * y < 1 ? I = G : 3 * y < 2 ? I = n + (G - n) * (2 / 3 - y) * 6 : I = n, a[h] = I * 255;
          return a;
        }
      }, s.hsl = function(c) {
        var W = c[0] / 255, u = c[1] / 255, e = c[2] / 255, n = Math.min(W, u, e), G = Math.max(W, u, e), y = G - n, a, I, h;
        return G === n ? a = 0 : W === G ? a = (u - e) / y : u === G ? a = 2 + (e - W) / y : e === G && (a = 4 + (W - u) / y), a = Math.min(a * 60, 360), a < 0 && (a += 360), h = (n + G) / 2, G === n ? I = 0 : h <= 0.5 ? I = y / (G + n) : I = y / (2 - G - n), [a, I * 100, h * 100];
      };
    },
    /* 38 */
    /***/
    function(Z, d, l) {
      Z.exports = {
        name: "rgb",
        min: [0, 0, 0],
        max: [255, 255, 255],
        channel: ["red", "green", "blue"],
        alias: ["RGB"]
      };
    },
    /* 39 */
    /***/
    function(Z, d) {
      Z.exports = l;
      function l(s, c, W) {
        return c < W ? s < c ? c : s > W ? W : s : s < W ? W : s > c ? c : s;
      }
    },
    /* 40 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return b;
      });
      var s = l(41), c = /* @__PURE__ */ l.n(s), W = l(42), u = /* @__PURE__ */ l.n(W), e = l(43), n = /* @__PURE__ */ l.n(e), G = l(44), y = l(46), a = /* @__PURE__ */ l.n(y), I = l(53), h = l(55);
      l(1).glMatrix.setMatrixArrayType(Array);
      const S = Symbol("contours"), p = Symbol("path"), X = Symbol("simplify"), V = Symbol("scale"), i = 2 * Math.PI;
      class b {
        constructor(m = {}) {
          typeof m == "string" && (m = {
            path: m
          }), m.path ? this[p] = c()(m.path) : this[p] = [], this[S] = null, this[X] = m.simplify != null ? m.simplify : 0, this[V] = m.scale != null ? m.scale : 2;
        }
        get contours() {
          let m = null;
          if (!this[S] && this[p]) {
            const R = Object(G.default)(n()(this[p]));
            this[S] = a()(R, this[V], this[X]), this[S].path = R, this[S].simplify = this[X], this[S].scale = this[V];
          }
          return this[S] && (m = this[S].map((R) => [...R]), m.path = this[S].path, m.simplify = this[S].simplify, m.scale = this[S].scale), m;
        }
        get path() {
          return this[p];
        }
        get simplify() {
          return this[X];
        }
        get boundingBox() {
          const m = this.contours;
          if (m && m.length) {
            const R = m.reduce((x, C) => [...x, ...C]);
            return u()(R);
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const m = this.boundingBox;
          return m ? [0.5 * (m[0][0] + m[1][0]), 0.5 * (m[0][1] + m[1][1])] : [0, 0];
        }
        normalize(m = 0, R = 0) {
          const x = Object(G.default)(n()(this[p])).map(([C, ...T]) => {
            const K = [C];
            for (let J = 0; J < T.length; J += 2) {
              const F = T[J] - m, r = T[J + 1] - R;
              K.push(F, r);
            }
            return K;
          });
          return this.beginPath(), this[p].push(...x), this;
        }
        getPointAtLength(m) {
          return this.contours ? Object(I.getPointAtLength)(this[S], m) : null;
        }
        getTotalLength() {
          return this.contours ? Object(I.getTotalLength)(this[S]) : 0;
        }
        addPath(m) {
          this[S] = null, typeof m == "string" && (m = c()(m)), this[p].push(...m);
        }
        beginPath() {
          this[p] = [], this[S] = null;
        }
        clear() {
          this.beginPath();
        }
        ellipse(m, R, x, C, T, K, J, F = 0) {
          if (K += T, J += T, x <= 0 || C <= 0 || J === K)
            return;
          J < K && (J = K + i + (J - K) % i), J - K > i && (J = K + i);
          const r = J - K;
          r >= i && (J -= 1e-3);
          let Y = this[p].length > 0 && r < i ? "L" : "M";
          const H = Object(h.getPoint)(m, R, x, C, K), Q = Object(h.getPoint)(m, R, x, C, J), w = +!F;
          let O = r > Math.PI ? 1 : 0;
          F && (O = 1 - O), Y += H.join(" "), Y += `A${x} ${C} 0 ${O} ${w} ${Q.join(" ")}`, r >= i && (Y += "Z"), this.addPath(Y);
        }
        arc(m, R, x, C, T, K = 0) {
          return this.ellipse(m, R, x, x, 0, C, T, K);
        }
        arcTo(m, R, x, C, T, K, J) {
          this[S] = null, this[p].push(["A", m, R, x, C, T, K, J]);
        }
        moveTo(m, R) {
          this[S] = null, this[p].push(["M", m, R]);
        }
        lineTo(m, R) {
          this[S] = null, this[p].push(["L", m, R]);
        }
        bezierCurveTo(m, R, x, C, T, K) {
          this[S] = null, this[p].push(["C", m, R, x, C, T, K]);
        }
        quadraticCurveTo(m, R, x, C) {
          this[S] = null, this[p].push(["Q", m, R, x, C]);
        }
        rect(m, R, x, C) {
          const T = `M${m} ${R}L${m + x} ${R}L${m + x} ${R + C}L${m} ${R + C}Z`;
          this.addPath(T);
        }
        closePath() {
          this[S] = null;
          let m = [];
          const R = this[p].length;
          R > 0 && (m = this[p][R - 1]), m[0] !== "Z" && m[0] !== "z" && this[p].push(["Z"]);
        }
      }
    },
    /* 41 */
    /***/
    function(Z, d) {
      Z.exports = c;
      var l = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, s = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function c(e) {
        var n = [];
        return e.replace(s, function(G, y, a) {
          var I = y.toLowerCase();
          for (a = u(a), I == "m" && a.length > 2 && (n.push([y].concat(a.splice(0, 2))), I = "l", y = y == "m" ? "l" : "L"); ; ) {
            if (a.length == l[I])
              return a.unshift(y), n.push(a);
            if (a.length < l[I])
              throw new Error("malformed path data");
            n.push([y].concat(a.splice(0, l[I])));
          }
        }), n;
      }
      var W = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function u(e) {
        var n = e.match(W);
        return n ? n.map(Number) : [];
      }
    },
    /* 42 */
    /***/
    function(Z, d, l) {
      Z.exports = s;
      function s(c) {
        var W = c.length;
        if (W === 0)
          return [[], []];
        for (var u = c[0].length, e = c[0].slice(), n = c[0].slice(), G = 1; G < W; ++G)
          for (var y = c[G], a = 0; a < u; ++a) {
            var I = y[a];
            e[a] = Math.min(e[a], I), n[a] = Math.max(n[a], I);
          }
        return [e, n];
      }
    },
    /* 43 */
    /***/
    function(Z, d) {
      Z.exports = l;
      function l(s) {
        var c = 0, W = 0, u = 0, e = 0;
        return s.map(function(n) {
          n = n.slice();
          var G = n[0], y = G.toUpperCase();
          if (G != y)
            switch (n[0] = y, G) {
              case "a":
                n[6] += u, n[7] += e;
                break;
              case "v":
                n[1] += e;
                break;
              case "h":
                n[1] += u;
                break;
              default:
                for (var a = 1; a < n.length; )
                  n[a++] += u, n[a++] += e;
            }
          switch (y) {
            case "Z":
              u = c, e = W;
              break;
            case "H":
              u = n[1];
              break;
            case "V":
              e = n[1];
              break;
            case "M":
              u = c = n[1], e = W = n[2];
              break;
            default:
              u = n[n.length - 2], e = n[n.length - 1];
          }
          return n;
        });
      }
    },
    /* 44 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return c;
      });
      var s = l(45);
      l(1).glMatrix.setMatrixArrayType(Array);
      function c(e) {
        for (var n, G = [], y = 0, a = 0, I = 0, h = 0, S = null, p = null, X = 0, V = 0, i = 0, b = e.length; i < b; i++) {
          var t = e[i], m = t[0];
          switch (m) {
            case "M":
              I = t[1], h = t[2];
              break;
            case "A":
              var R = Object(s.default)(X, V, t[6], t[7], t[4], t[5], t[1], t[2], t[3]);
              if (!R.length)
                continue;
              R = R.map((J) => {
                const [F, r, Y, H, Q, w, O, q] = J;
                return {
                  x1: Y,
                  y1: H,
                  x2: Q,
                  y2: w,
                  x: O,
                  y: q
                };
              });
              for (var x = 0, C; x < R.length; x++)
                C = R[x], t = ["C", C.x1, C.y1, C.x2, C.y2, C.x, C.y], x < R.length - 1 && G.push(t);
              break;
            case "S":
              var T = X, K = V;
              (n == "C" || n == "S") && (T += T - y, K += K - a), t = ["C", T, K, t[1], t[2], t[3], t[4]];
              break;
            case "T":
              n == "Q" || n == "T" ? (S = X * 2 - S, p = V * 2 - p) : (S = X, p = V), t = u(X, V, S, p, t[1], t[2]);
              break;
            case "Q":
              S = t[1], p = t[2], t = u(X, V, t[1], t[2], t[3], t[4]);
              break;
            case "L":
              t = W(X, V, t[1], t[2]);
              break;
            case "H":
              t = W(X, V, t[1], V);
              break;
            case "V":
              t = W(X, V, X, t[1]);
              break;
            case "Z":
              t = W(X, V, I, h);
              break;
          }
          n = m, X = t[t.length - 2], V = t[t.length - 1], t.length > 4 ? (y = t[t.length - 4], a = t[t.length - 3]) : (y = X, a = V), G.push(t);
        }
        return G;
      }
      function W(e, n, G, y) {
        return ["C", e, n, G, y, G, y];
      }
      function u(e, n, G, y, a, I) {
        return ["C", e / 3 + 2 / 3 * G, n / 3 + 2 / 3 * y, a / 3 + 2 / 3 * G, I / 3 + 2 / 3 * y, a, I];
      }
    },
    /* 45 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const s = Math.PI * 2;
      function c(n, G, y, a) {
        const I = n * a - G * y < 0 ? -1 : 1;
        let h = n * y + G * a;
        return h > 1 && (h = 1), h < -1 && (h = -1), I * Math.acos(h);
      }
      function W(n, G, y, a, I, h, S, p, X, V) {
        const i = V * (n - y) / 2 + X * (G - a) / 2, b = -X * (n - y) / 2 + V * (G - a) / 2, t = S * S, m = p * p, R = i * i, x = b * b;
        let C = t * m - t * x - m * R;
        C < 0 && (C = 0), C /= t * x + m * R, C = Math.sqrt(C) * (I === h ? -1 : 1);
        const T = C * S / p * b, K = C * -p / S * i, J = V * T - X * K + (n + y) / 2, F = X * T + V * K + (G + a) / 2, r = (i - T) / S, Y = (b - K) / p, H = (-i - T) / S, Q = (-b - K) / p, w = c(1, 0, r, Y);
        let O = c(r, Y, H, Q);
        return h === 0 && O > 0 && (O -= s), h === 1 && O < 0 && (O += s), [J, F, w, O];
      }
      function u(n, G) {
        const y = 1.3333333333333333 * Math.tan(G / 4), a = Math.cos(n), I = Math.sin(n), h = Math.cos(n + G), S = Math.sin(n + G);
        return [a, I, a - I * y, I + a * y, h + S * y, S - h * y, h, S];
      }
      function e(n, G, y, a, I, h, S, p, X) {
        const V = Math.sin(X * s / 360), i = Math.cos(X * s / 360), b = i * (n - y) / 2 + V * (G - a) / 2, t = -V * (n - y) / 2 + i * (G - a) / 2;
        if (b === 0 && t === 0)
          return [];
        if (S === 0 || p === 0)
          return [];
        S = Math.abs(S), p = Math.abs(p);
        const m = b * b / (S * S) + t * t / (p * p);
        m > 1 && (S *= Math.sqrt(m), p *= Math.sqrt(m));
        const R = W(n, G, y, a, I, h, S, p, V, i), x = [];
        let C = R[2], T = R[3];
        const K = Math.max(Math.ceil(Math.abs(T) / (s / 4)), 1);
        T /= K;
        for (let J = 0; J < K; J++)
          x.push(u(C, T)), C += T;
        return x.map((J) => {
          for (let F = 0; F < J.length; F += 2) {
            let r = J[F + 0], Y = J[F + 1];
            r *= S, Y *= p;
            const H = i * r - V * Y, Q = V * r + i * Y;
            J[F + 0] = H + R[0], J[F + 1] = Q + R[1];
          }
          return J;
        });
      }
    },
    /* 46 */
    /***/
    function(Z, d, l) {
      l(1).glMatrix.setMatrixArrayType(Array);
      var s = l(47), {
        copy: c
      } = l(49), W = l(50);
      function u(a, I, h) {
        return a[0] = I, a[1] = h, a;
      }
      var e = [0, 0], n = [0, 0], G = [0, 0];
      function y(a, I, h, S) {
        s(h, u(e, S[1], S[2]), u(n, S[3], S[4]), u(G, S[5], S[6]), I, a);
      }
      Z.exports = function(I, h, S) {
        var p = [], X = [], V = [0, 0];
        return I.forEach(function(i, b, t) {
          if (i[0] === "M")
            c(V, i.slice(1)), X.length > 0 && (p.push(X), X = []);
          else if (i[0] === "C")
            y(X, h, V, i), u(V, i[5], i[6]);
          else
            throw new Error("illegal type in SVG: " + i[0]);
        }), X.length > 0 && p.push(X), p.map(function(i) {
          return W(i, S || 0);
        });
      };
    },
    /* 47 */
    /***/
    function(Z, d, l) {
      Z.exports = l(48)();
    },
    /* 48 */
    /***/
    function(Z, d) {
      function l(c) {
        return [c[0], c[1]];
      }
      function s(c, W) {
        return [c, W];
      }
      Z.exports = function(W) {
        W = W || {};
        var u = typeof W.recursion == "number" ? W.recursion : 8, e = typeof W.epsilon == "number" ? W.epsilon : 11920929e-14, n = typeof W.pathEpsilon == "number" ? W.pathEpsilon : 1, G = typeof W.angleEpsilon == "number" ? W.angleEpsilon : 0.01, y = W.angleTolerance || 0, a = W.cuspLimit || 0;
        return function(p, X, V, i, b, t) {
          t || (t = []), b = typeof b == "number" ? b : 1;
          var m = n / b;
          return m *= m, I(p, X, V, i, t, m), t;
        };
        function I(S, p, X, V, i, b) {
          i.push(l(S));
          var t = S[0], m = S[1], R = p[0], x = p[1], C = X[0], T = X[1], K = V[0], J = V[1];
          h(t, m, R, x, C, T, K, J, i, b, 0), i.push(l(V));
        }
        function h(S, p, X, V, i, b, t, m, R, x, C) {
          if (!(C > u)) {
            var T = Math.PI, K = (S + X) / 2, J = (p + V) / 2, F = (X + i) / 2, r = (V + b) / 2, Y = (i + t) / 2, H = (b + m) / 2, Q = (K + F) / 2, w = (J + r) / 2, O = (F + Y) / 2, q = (r + H) / 2, k = (Q + O) / 2, P = (w + q) / 2;
            if (C > 0) {
              var D = t - S, ll = m - p, _ = Math.abs((X - t) * ll - (V - m) * D), bl = Math.abs((i - t) * ll - (b - m) * D), $, el;
              if (_ > e && bl > e) {
                if ((_ + bl) * (_ + bl) <= x * (D * D + ll * ll)) {
                  if (y < G) {
                    R.push(s(k, P));
                    return;
                  }
                  var nl = Math.atan2(b - V, i - X);
                  if ($ = Math.abs(nl - Math.atan2(V - p, X - S)), el = Math.abs(Math.atan2(m - b, t - i) - nl), $ >= T && ($ = 2 * T - $), el >= T && (el = 2 * T - el), $ + el < y) {
                    R.push(s(k, P));
                    return;
                  }
                  if (a !== 0) {
                    if ($ > a) {
                      R.push(s(X, V));
                      return;
                    }
                    if (el > a) {
                      R.push(s(i, b));
                      return;
                    }
                  }
                }
              } else if (_ > e) {
                if (_ * _ <= x * (D * D + ll * ll)) {
                  if (y < G) {
                    R.push(s(k, P));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(b - V, i - X) - Math.atan2(V - p, X - S)), $ >= T && ($ = 2 * T - $), $ < y) {
                    R.push(s(X, V)), R.push(s(i, b));
                    return;
                  }
                  if (a !== 0 && $ > a) {
                    R.push(s(X, V));
                    return;
                  }
                }
              } else if (bl > e) {
                if (bl * bl <= x * (D * D + ll * ll)) {
                  if (y < G) {
                    R.push(s(k, P));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(m - b, t - i) - Math.atan2(b - V, i - X)), $ >= T && ($ = 2 * T - $), $ < y) {
                    R.push(s(X, V)), R.push(s(i, b));
                    return;
                  }
                  if (a !== 0 && $ > a) {
                    R.push(s(i, b));
                    return;
                  }
                }
              } else if (D = k - (S + t) / 2, ll = P - (p + m) / 2, D * D + ll * ll <= x) {
                R.push(s(k, P));
                return;
              }
            }
            h(S, p, K, J, Q, w, k, P, R, x, C + 1), h(k, P, O, q, Y, H, t, m, R, x, C + 1);
          }
        }
      };
    },
    /* 49 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "create", function() {
        return W;
      }), l.d(d, "clone", function() {
        return c;
      }), l.d(d, "copy", function() {
        return u;
      }), l.d(d, "scaleAndAdd", function() {
        return e;
      }), l.d(d, "dot", function() {
        return n;
      }), l.d(d, "rotate", function() {
        return G;
      }), l.d(d, "cross", function() {
        return y;
      }), l.d(d, "sub", function() {
        return a;
      }), l.d(d, "add", function() {
        return I;
      }), l.d(d, "computeMiter", function() {
        return X;
      }), l.d(d, "normal", function() {
        return V;
      }), l.d(d, "direction", function() {
        return i;
      });
      var s = l(1);
      l(1).glMatrix.setMatrixArrayType(Array);
      function c(b) {
        return [b[0], b[1]];
      }
      function W() {
        return [0, 0];
      }
      const u = s.vec2.copy, e = s.vec2.scaleAndAdd, n = s.vec2.dot, G = s.vec2.rotate, y = s.vec2.cross, a = s.vec2.sub, I = s.vec2.add, h = s.vec2.normalize, S = s.vec2.set, p = W();
      function X(b, t, m, R, x) {
        I(b, m, R), h(b, b), S(t, -b[1], b[0]), S(p, -m[1], m[0]);
        const C = x / n(t, p);
        return Math.abs(C);
      }
      function V(b, t) {
        return S(b, -t[1], t[0]), b;
      }
      function i(b, t, m) {
        return a(b, t, m), h(b, b), b;
      }
    },
    /* 50 */
    /***/
    function(Z, d, l) {
      var s = l(51), c = l(52);
      Z.exports = function(u, e) {
        return u = s(u, e), u = c(u, e), u;
      }, Z.exports.radialDistance = s, Z.exports.douglasPeucker = c;
    },
    /* 51 */
    /***/
    function(Z, d) {
      function l(s, c) {
        var W = s[0] - c[0], u = s[1] - c[1];
        return W * W + u * u;
      }
      Z.exports = function(c, W) {
        if (c.length <= 1)
          return c;
        W = typeof W == "number" ? W : 1;
        for (var u = W * W, e = c[0], n = [e], G, y = 1, a = c.length; y < a; y++)
          G = c[y], l(G, e) > u && (n.push(G), e = G);
        return e !== G && n.push(G), n;
      };
    },
    /* 52 */
    /***/
    function(Z, d) {
      function l(c, W, u) {
        var e = W[0], n = W[1], G = u[0] - e, y = u[1] - n;
        if (G !== 0 || y !== 0) {
          var a = ((c[0] - e) * G + (c[1] - n) * y) / (G * G + y * y);
          a > 1 ? (e = u[0], n = u[1]) : a > 0 && (e += G * a, n += y * a);
        }
        return G = c[0] - e, y = c[1] - n, G * G + y * y;
      }
      function s(c, W, u, e, n) {
        for (var G = e, y, a = W + 1; a < u; a++) {
          var I = l(c[a], c[W], c[u]);
          I > G && (y = a, G = I);
        }
        G > e && (y - W > 1 && s(c, W, y, e, n), n.push(c[y]), u - y > 1 && s(c, y, u, e, n));
      }
      Z.exports = function(W, u) {
        if (W.length <= 1)
          return W;
        u = typeof u == "number" ? u : 1;
        var e = u * u, n = W.length - 1, G = [W[0]];
        return s(W, 0, n, e, G), G.push(W[n]), G;
      };
    },
    /* 53 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "getTotalLength", function() {
        return c;
      }), l.d(d, "getPointAtLength", function() {
        return u;
      }), l.d(d, "getDashContours", function() {
        return e;
      });
      var s = l(54);
      l(1).glMatrix.setMatrixArrayType(Array);
      function c(n) {
        if (n.totalLength != null)
          return n.totalLength;
        let G = 0;
        return n.forEach((y) => {
          let a = y[0];
          for (let I = 1; I < y.length; I++) {
            const h = y[I];
            G += Object(s.distance)(a, h), a = h;
          }
        }), n.totalLength = G, G;
      }
      function W(n, G, y = !0) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (G <= 0)
          throw new TypeError("Length must > 0");
        const a = c(n);
        if (G >= a) {
          const h = n[n.length - 1], S = h[h.length - 2], p = h[h.length - 1], X = Math.atan2(p[1] - S[1], p[0] - S[0]);
          return {
            current: n.map((V) => [...V]),
            point: {
              x: p[0],
              y: p[1],
              angle: X
            }
          };
        }
        const I = [];
        for (let h = 0; h < n.length; h++) {
          I[h] = [];
          const S = n[h];
          let p = S[0];
          for (let X = 1; X < S.length; X++) {
            const V = S[X], i = Object(s.distance)(p, V);
            if (G < i) {
              const b = G / i, t = Math.atan2(V[1] - p[1], V[0] - p[0]), m = {
                x: p[0] * (1 - b) + V[0] * b,
                y: p[1] * (1 - b) + V[1] * b,
                angle: t
              };
              if (I[h].push(p), G > 0 && I[h].push([m.x, m.y]), !y)
                return {
                  current: I,
                  point: m
                };
              const R = [], x = h;
              for (; h < n.length; h++) {
                for (R[h - x] = [], h === x && R[0].push([m.x, m.y]); X < S.length; X++)
                  R[h - x].push(S[X]);
                X = 0;
              }
              return {
                current: I,
                point: m,
                rest: R
              };
            }
            G -= i, I[h].push(p), p = V;
          }
        }
      }
      function u(n, G) {
        if (G = Number(G), !Number.isFinite(G))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (n.length <= 0)
          return {
            x: 0,
            y: 0,
            angle: 0
          };
        if (G <= 0) {
          const y = n[0][0], a = n[0][1], I = Math.atan2(a[1] - y[1], a[0] - y[0]);
          return {
            x: y[0],
            y: y[1],
            angle: I
          };
        }
        return W(n, G, !1).point;
      }
      function e(n, G, y) {
        let a = 0, I = G[0], h = n;
        const S = [], p = G.length;
        if (y > 0) {
          do
            y -= G[a % p], a++;
          while (y > 0);
          y < 0 && (I = -y, a--);
        } else if (y < 0) {
          a = -1;
          do
            y += G[a % p + p - 1], a--;
          while (y < 0);
          y >= 0 && (a++, I = G[a % p + p - 1] - y);
        }
        do {
          const X = W(h, I);
          h = X.rest, ++a % 2 && S.push(...X.current);
          let V = a % p;
          V < 0 && (V += p), I = G[V];
        } while (h);
        return S;
      }
    },
    /* 54 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "normalize", function() {
        return s;
      }), l.d(d, "distance", function() {
        return c;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s([W, u, e], n, G, y) {
        return W = W * 2 / n - 1, u = 1 - u * 2 / G, Number.isFinite(y) ? (e = e * 2 / y - 1, [W, u, e]) : [W, u];
      }
      function c([W, u, e = 0], [n, G, y = 0]) {
        return Math.hypot(n - W, G - u, y - e);
      }
    },
    /* 55 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "getPoint", function() {
        return c;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const s = Math.PI * 2;
      function c(W, u, e, n, G) {
        G %= s, G < 0 && (G += s);
        const y = Math.tan(G);
        if (Math.abs(y) < 1e5) {
          const a = u - y * W, I = 1 / e ** 2 + y ** 2 / n ** 2;
          let h = -1;
          (G <= Math.PI / 2 || G > 3 * Math.PI / 2) && (h = 1);
          const S = h * Math.sqrt(1 / I) + W, p = y * S + a;
          return [S, p];
        }
        return G < Math.PI ? [W, u + n] : [W, u - n];
      }
    },
    /* 56 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return E;
      });
      var s = l(1), c = l(42), W = /* @__PURE__ */ l.n(c), u = l(57), e = l(28), n = l(24), G = l(30), y = l(59), a = l(53), I = l(60), h = /* @__PURE__ */ l.n(I), S = l(46), p = /* @__PURE__ */ l.n(S), X = l(31), V = l(40), i = l(21);
      l(1).glMatrix.setMatrixArrayType(Array);
      function b(B, g) {
        if (B == null)
          return {};
        var U = t(B, g), o, L;
        if (Object.getOwnPropertySymbols) {
          var N = Object.getOwnPropertySymbols(B);
          for (L = 0; L < N.length; L++)
            o = N[L], !(g.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(B, o) && (U[o] = B[o]);
        }
        return U;
      }
      function t(B, g) {
        if (B == null)
          return {};
        var U = {}, o = Object.keys(B), L, N;
        for (N = 0; N < o.length; N++)
          L = o[N], !(g.indexOf(L) >= 0) && (U[L] = B[L]);
        return U;
      }
      const m = Symbol("mesh"), R = Symbol("contours"), x = Symbol("stroke"), C = Symbol("fill"), T = Symbol("strokeColor"), K = Symbol("fillColor"), J = Symbol("transform"), F = Symbol("invertTransform"), r = Symbol("uniforms"), Y = Symbol("texOptions"), H = Symbol("blend"), Q = Symbol("applyTexture"), w = Symbol("applyTransform"), O = Symbol("applyGradientTransform"), q = Symbol("applyProgram"), k = Symbol("gradient"), P = Symbol("filter"), D = Symbol("opacity"), ll = Symbol("program"), _ = Symbol("attributes"), bl = Symbol("pass"), $ = Symbol("clipContext"), el = Symbol("applyClipPath");
      function nl(B, g) {
        const [U, o] = [B[1][0] - B[0][0], B[1][1] - B[0][1]], L = [];
        for (let N = 0; N < g.length; N++) {
          const v = g[N], f = [(v[0] - B[0][0]) / U, 1 - (v[1] - B[0][1]) / o];
          L.push(f);
        }
        return L;
      }
      function z([B, g], [U, o, L, N], {
        scale: v
      }) {
        return v || (B /= L, g = 1 - g / N, B -= U, g += o), [B, g, 0];
      }
      function M(B, g, U) {
        const o = p()(B, g, U);
        return o.path = B, o.simplify = U, o.scale = g, o;
      }
      class E {
        constructor(g) {
          this[x] = null, this[C] = null, this[J] = [1, 0, 0, 1, 0, 0], this[D] = 1, this[r] = {}, this[P] = [], this[H] = null, this[Y] = {}, this.contours = g.contours, this[ll] = null, this[_] = {}, this[bl] = [];
        }
        get contours() {
          return this[R];
        }
        set contours(g) {
          this[m] = null, this[R] = g;
          const U = g.scale;
          this.transformScale / U > 1.5 && this.accurate(this.transformScale);
        }
        setProgram(g) {
          this[ll] = g, this[m] && this[q](g);
        }
        get program() {
          return this[ll];
        }
        setAttribute(g, U) {
          U == null ? delete this[_][g] : this[_][g] = U;
        }
        getOpacity() {
          return this[D];
        }
        setOpacity(g) {
          if (g < 0 || g > 1)
            throw new TypeError("Invalid opacity value.");
          this[m] && this[m].positions.forEach((U) => {
            U[2] = 1 / U[2] > 0 ? g : -g;
          }), this[D] = g;
        }
        setClipPath(g) {
          this.clipPath = g, this[r].u_clipSampler && this[r].u_clipSampler.delete(), this.setUniforms({
            u_clipSampler: null
          }), this[m] && delete this[m].attributes.a_clipUV, g && this[m] && this[el]();
        }
        [el]() {
          if (this.clipPath) {
            this[$] || (this[$] = i.default.createCanvas(1, 1));
            const [[g, U], [o, L]] = this.boundingBox;
            o && L && (this[$].width = o - g, this[$].height = L - U);
            const N = this[$].getContext("2d"), v = new Path2D(this.clipPath);
            N.clearRect(0, 0, this[$].width, this[$].height), N.save(), N.translate(-g, -U), N.fillStyle = "white", N.fill(v), N.restore(), this[m].clipPath = this[$];
            const f = nl(this.boundingBox, this[m].position0);
            this[m].attributes.a_clipUV = f;
          }
        }
        getPointAtLength(g) {
          return Object(a.getPointAtLength)(this[R], g);
        }
        getTotalLength() {
          return Object(a.getTotalLength)(this[R]);
        }
        get blend() {
          return this[H] == null ? "auto" : this[H];
        }
        set blend(g) {
          this[H] = g, this[m] && (this[m].enableBlend = this.enableBlend);
        }
        get boundingBox() {
          if (this[m] && this[m].boundingBox)
            return this[m].boundingBox;
          const g = this.meshData;
          if (g) {
            const U = g.position0;
            if (U.length)
              g.boundingBox = W()(U);
            else
              return [[0, 0], [0, 0]];
            return g.boundingBox;
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const g = this.boundingBox;
          return g ? [0.5 * (g[0][0] + g[1][0]), 0.5 * (g[0][1] + g[1][1])] : [0, 0];
        }
        get fillRule() {
          return this[C] ? this[C].rule : "nonzero";
        }
        get lineWidth() {
          return this[x] ? this[x].lineWidth : 0;
        }
        get lineCap() {
          return this[x] ? this[x].lineCap : "";
        }
        get lineJoin() {
          return this[x] ? this[x].lineJoin : "";
        }
        get miterLimit() {
          return this[x] ? this[x].miterLimit : 0;
        }
        get strokeStyle() {
          return this[T] && this[T][3] !== 0 ? Object(n.default)(this[T]) : "";
        }
        get lineDash() {
          return this[x] ? this[x].lineDash : null;
        }
        get lineDashOffset() {
          return this[x] ? this[x].lineDashOffset : 0;
        }
        get fillStyle() {
          return this[K] && this[K][3] !== 0 ? Object(n.default)(this[K]) : "";
        }
        get gradient() {
          return this[k];
        }
        get texture() {
          return this[r].u_texSampler ? {
            image: this[r].u_texSampler._img,
            options: this[Y]
          } : null;
        }
        get enableBlend() {
          return this[H] === !0 || this[H] === !1 ? this[H] : this[D] < 1 || this[T] != null && this[T][3] < 1 || this[K] != null && this[K][3] < 1 || this[r].u_colorMatrix != null && this[r].u_colorMatrix[18] < 1 || this[r].u_radialGradientVector != null || this.beforeRender || this.afterRender;
        }
        get filterCanvas() {
          return /blur|drop-shadow|url/.test(this.filter);
        }
        get filter() {
          return this[P].join(" ");
        }
        get transformMatrix() {
          return this[J];
        }
        get invertMatrix() {
          if (!this[F]) {
            const g = s.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this[J]);
            this[F] = g;
          }
          return this[F];
        }
        get transformScale() {
          const g = this[J];
          return Math.max(Math.hypot(g[0], g[1]), Math.hypot(g[2], g[3]));
        }
        get uniforms() {
          return this[r];
        }
        get pass() {
          return this[bl];
        }
        [q](g) {
          const U = this[_], o = this[m].position0, L = Object.entries(g._attribute);
          for (let N = 0; N < L.length; N++) {
            const [v, f] = L[N];
            if (v !== "a_color" && v !== "a_sourceRect" && f !== "ignored") {
              const j = U[v];
              if (v === "uv" && !j) {
                const A = this[m].boundingBox || W()(o);
                this[m].attributes[v] = nl(A, o);
              } else {
                this[m].attributes[v] = [];
                for (let A = 0; A < o.length; A++) {
                  const dl = o[A];
                  this[m].attributes[v].push(j ? j(dl, N, o) : Array(f.size).fill(0));
                }
              }
            }
          }
        }
        // {stroke, fill}
        get meshData() {
          if (this._updateMatrix && this.transformScale / this.contours.scale > 1.5 && this.accurate(this.transformScale), !this[m]) {
            !this[C] && !this[x] && this.setFill();
            const g = this[R], U = {};
            if (g && g.length) {
              if (this[C])
                try {
                  const N = h()(g, this[C]);
                  N.positions = N.positions.map((v) => (v.push(this[D]), v)), N.attributes = {
                    a_color: Array.from({
                      length: N.positions.length
                    }).map(() => this[K].map((v) => Math.round(255 * v)))
                    // a_sourceRect: Array.from({length: mesh.positions.length}).map(() => [0, 0, 0, 0]),
                  }, U.fill = N;
                } catch {
                }
              if (this[x]) {
                const N = this[x].lineDash;
                let v = g;
                if (N) {
                  const j = this[x].lineDashOffset;
                  v = Object(a.getDashContours)(g, N, j);
                }
                const f = v.map((j, A) => {
                  const dl = j.length > 1 && s.vec2.equals(j[0], j[j.length - 1]), il = this[x].build(j, dl);
                  return h()([il]);
                });
                f.forEach((j) => {
                  j.positions = j.positions.map((A) => (A.push(-this[D]), A)), j.attributes = {
                    a_color: Array.from({
                      length: j.positions.length
                    }).map(() => this[T].map((A) => Math.round(255 * A)))
                  };
                }), U.stroke = Object(e.default)(f);
              }
            }
            const o = Object(e.default)([U.fill, U.stroke]);
            o.fillPointCount = U.fill ? U.fill.positions.length : 0, o.enableBlend = this.enableBlend, o.position0 = o.positions.map(([N, v, f]) => [N, v, f]), o.uniforms = this[r], this[m] = o, this[r].u_texSampler && this[Q](o, this[Y]);
            const L = this[J];
            Object(y.isUnitTransform)(L) || (this[w](o, L), this[r].u_radialGradientVector && this[O]()), this.clipPath && this[el](), this[ll] && this[q](this[ll]);
          }
          return this._updateMatrix && (this[m].matrix = this[J], this[w](this[m], this[J]), this[r].u_radialGradientVector && this[O]()), this[m];
        }
        [w](g, U) {
          const {
            positions: o,
            position0: L
          } = g;
          for (let N = 0; N < o.length; N++) {
            const [v, f] = L[N], j = o[N];
            j[0] = v * U[0] + f * U[2] + U[4], j[1] = v * U[1] + f * U[3] + U[5];
          }
          this._updateMatrix = !1;
        }
        [O]() {
          const g = this[J], U = [...this._radialGradientVector];
          if (U) {
            const [o, L, , N, v] = U;
            U[0] = o * g[0] + L * g[2] + g[4], U[1] = o * g[1] + L * g[3] + g[5], U[3] = N * g[0] + v * g[2] + g[4], U[4] = N * g[1] + v * g[3] + g[5], this[r].u_radialGradientVector = U;
          }
        }
        [Q](g, U) {
          function o(A, dl) {
            return A == null && dl == null ? !0 : A == null || dl == null ? !1 : A[0] === dl[0] && A[1] === dl[1] && A[2] === dl[2] && A[3] === dl[3];
          }
          const L = this[r].u_texSampler;
          if (!L)
            return;
          const {
            width: N,
            height: v
          } = L._img, f = U.srcRect;
          let j = U.rect || [0, 0];
          if (U.rotated && (j = [-j[1], j[0], j[3], j[2]]), j[2] == null && (j[2] = f ? f[2] : N), j[3] == null && (j[3] = f ? f[3] : v), U.hidden)
            g.textureCoord = g.positions.map(() => [-1, -1, -1]);
          else if (!g.textureCoord || !o(this[Y].rect, U.rect) || this[Y].hidden !== U.hidden || this[Y].rotated !== U.rotated) {
            let A = null;
            U.rotated && (A = s.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), s.mat2d.fromValues(1, 0, 0, 1, 0, 0), 0.5 * Math.PI), A = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), A, [0, -j[2]])), g.textureCoord = g.position0.map(([dl, il, cl]) => {
              if (1 / cl > 0) {
                if (U.rotated) {
                  const tl = dl * A[0] + il * A[2] + A[4], sl = dl * A[1] + il * A[3] + A[5];
                  [dl, il] = [tl, sl];
                }
                const ml = z([dl, il], [j[0] / j[2], j[1] / j[3], j[2], j[3]], U);
                return U.repeat && (ml[2] = 1), ml;
              }
              return [-1, -1, -1];
            });
          }
          if (f) {
            const A = [f[0] / N, f[1] / v, f[2] / N, f[3] / v];
            g.attributes.a_sourceRect = g.positions.map(() => [...A]);
          } else
            g.attributes.a_sourceRect = g.positions.map(() => [0, 0, 0, 0]);
        }
        accurate(g) {
          if (!this.contours)
            return;
          if (this.contours.path) {
            const o = this.contours.simplify, L = M(this.contours.path, 2 * g, o);
            this[m] = null, this[R] = L;
          }
        }
        canIgnore() {
          const g = this[x] == null || this[x].lineWidth === 0 || this[T][3] === 0, U = this[C] == null || this[K][3] === 0, o = this[r].u_radialGradientVector == null, L = this[r].u_texSampler == null;
          return this[D] === 0 || this[ll] == null && g && U && o && L && !this.beforeRender && !this.afterRender;
        }
        // join: 'miter' or 'bevel'
        // cap: 'butt' or 'square'
        // lineDash: null
        // lineDashOffset: 0
        setStroke({
          thickness: g = 1,
          cap: U = "butt",
          join: o = "miter",
          miterLimit: L = 10,
          color: N = [0, 0, 0, 0],
          lineDash: v = null,
          lineDashOffset: f = 0,
          roundSegments: j = 20
        } = {}) {
          return this[m] = null, this[x] = new u.default({
            lineWidth: g,
            lineCap: U,
            lineJoin: o,
            miterLimit: L,
            roundSegments: j
          }), typeof N == "string" && (N = Object(X.default)(N)), this[T] = N, this[x].lineDash = v, this[x].lineDashOffset = f, this;
        }
        setFill({
          rule: g = this.fillRule,
          color: U = [0, 0, 0, 0]
        } = {}) {
          return this[m] = null, this[C] = {
            rule: g
          }, typeof U == "string" && (U = Object(X.default)(U)), this[K] = U, this;
        }
        /**
          options: {
            scale: false,
            repeat: false,
            rotated: false,
            rect: [10, 10],
            srcRect: [...],
            hidden: false,
          }
         */
        setTexture(g, U = {}) {
          if (g && g.image) {
            const {
              image: o,
              rect: L
            } = g;
            if (g = o, U.rect)
              for (let N = 0; N < U.rect.length; N++)
                L[N] = U.rect[N];
            U.rect = L;
          }
          return this[C] || this.setFill(), this.setUniforms({
            u_texSampler: g
          }), this[m] && this[Q](this[m], U), this[Y] = U, this;
        }
        setCircularGradient({
          vector: g,
          colors: U,
          type: o = "fill"
        } = {}) {
          if (g.length !== 3)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: o
          });
        }
        setLinearGradient({
          vector: g,
          colors: U,
          type: o = "fill"
        } = {}) {
          if (g.length !== 4)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: o
          });
        }
        setRadialGradient({
          vector: g,
          colors: U,
          type: o = "fill"
        } = {}) {
          if (g.length !== 6)
            throw new TypeError("Invalid radialGradient.");
          this.setGradient({
            vector: g,
            colors: U,
            type: o
          });
        }
        /**
          vector: [x0, y0, r0, x1, y1, r1],
          colors: [{offset:0, color}, {offset:1, color}, ...],
         */
        setGradient({
          vector: g,
          colors: U,
          type: o = "fill"
        } = {}) {
          U = U.map(({
            offset: v,
            color: f
          }) => (typeof f == "string" && (f = Object(X.default)(f)), {
            offset: v,
            color: f
          })), this[k] = this[k] || {}, this[k][o] = {
            vector: g,
            colors: U
          }, U.sort((v, f) => v.offset - f.offset);
          const L = [];
          U.forEach(({
            offset: v,
            color: f
          }) => {
            L.push(v, ...f);
          });
          let N;
          if (g.length === 4 ? N = [g[0], g[1], 0, g[2], g[3], 0] : N = [...g], L.length < 40 && L.push(-1), L.length > 40)
            throw new Error("Too many colors, should be less than 8 colors");
          return this._radialGradientVector = N, this[r].u_colorSteps = L, o === "fill" ? this[r].u_gradientType = 1 : this[r].u_gradientType = 0, this[O](), this;
        }
        setUniforms(g = {}) {
          return Object.assign(this[r], g), this;
        }
        setTransform(...g) {
          const U = this[J];
          return s.mat2d.equals(g, U) || (this[J] = g, delete this[F], this._updateMatrix = !0), this;
        }
        transform(...g) {
          const U = this[J];
          return this[J] = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), U, g), delete this[F], this._updateMatrix = !0, this;
        }
        translate(g, U) {
          let o = s.mat2d.create();
          return o = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), o, [g, U]), this.transform(...o);
        }
        rotate(g, [U, o] = [0, 0]) {
          let L = s.mat2d.create();
          return L = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), L, [U, o]), L = s.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), L, g), L = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), L, [-U, -o]), this.transform(...L);
        }
        scale(g, U = g, [o, L] = [0, 0]) {
          let N = s.mat2d.create();
          return N = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [o, L]), N = s.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), N, [g, U]), N = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [-o, -L]), this.transform(...N);
        }
        skew(g, U = g, [o, L] = [0, 0]) {
          let N = s.mat2d.create();
          return N = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [o, L]), N = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), N, s.mat2d.fromValues(1, Math.tan(U), Math.tan(g), 1, 0, 0)), N = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [-o, -L]), this.transform(...N);
        }
        clearFilter() {
          return this.setColorTransform(null), this[P].length = 0, this;
        }
        setColorTransform(...g) {
          return g[0] === null ? this.setUniforms({
            u_filterFlag: 0,
            u_colorMatrix: 0
          }) : this.setUniforms({
            u_filterFlag: 1,
            u_colorMatrix: g
          }), this;
        }
        // apply linear color transform
        transformColor(...g) {
          let U = this.uniforms.u_colorMatrix;
          return U ? U = Object(G.multiply)(U, g) : U = g, this.setColorTransform(...U), this;
        }
        blur(g) {
          return this[P].push(`blur(${g}px)`), this;
        }
        brightness(g = 1) {
          return this[P].push(`brightness(${100 * g}%)`), this.transformColor(...Object(G.brightness)(g));
        }
        contrast(g = 1) {
          return this[P].push(`contrast(${100 * g}%)`), this.transformColor(...Object(G.contrast)(g));
        }
        dropShadow(g, U, o = 0, L = [0, 0, 0, 1]) {
          return Array.isArray(L) && (L = Object(n.default)(L)), this[P].push(`drop-shadow(${g}px ${U}px ${o}px ${L})`), this;
        }
        grayscale(g = 1) {
          return this[P].push(`grayscale(${100 * g}%)`), this.transformColor(...Object(G.grayscale)(g));
        }
        // https://github.com/phoboslab/WebGLImageFilter/blob/master/webgl-image-filter.js#L371
        hueRotate(g = 0) {
          return this[P].push(`hue-rotate(${g}deg)`), this.transformColor(...Object(G.hueRotate)(g));
        }
        invert(g = 1) {
          return this[P].push(`invert(${100 * g}%)`), this.transformColor(...Object(G.invert)(g));
        }
        opacity(g = 1) {
          return this[P].push(`opacity(${100 * g}%)`), this.transformColor(...Object(G.opacity)(g));
        }
        saturate(g = 1) {
          return this[P].push(`saturate(${100 * g}%)`), this.transformColor(...Object(G.saturate)(g));
        }
        sepia(g = 1) {
          return this[P].push(`sepia(${100 * g}%)`), this.transformColor(...Object(G.sepia)(g));
        }
        url(g) {
          return this[P].push(`url(${g})`), this;
        }
        isPointCollision(g, U, o = "both") {
          const L = this.meshData, {
            positions: N,
            cells: v
          } = L, f = this.invertMatrix, j = f[0] * g + f[2] * U + f[4], A = f[1] * g + f[3] * U + f[5], dl = this.boundingBox;
          if (j < dl[0][0] || j > dl[1][0] || A < dl[0][1] || A > dl[1][1])
            return !1;
          function il([cl, ml], [tl, sl], [Zl, al]) {
            const ol = Zl - tl, Xl = al - sl, Gl = ((cl - tl) * ol + (ml - sl) * Xl) / (ol ** 2 + Xl ** 2);
            return Gl >= 0 && Gl <= 1;
          }
          for (let cl = 0; cl < v.length; cl++) {
            const ml = v[cl];
            if (o === "fill" && ml[0] >= L.fillPointCount)
              break;
            if (o === "stroke" && ml[0] < L.fillPointCount)
              continue;
            const [[tl, sl], [Zl, al], [ol, Xl]] = ml.map((Rl) => N[Rl]), Gl = Math.sign((g - tl) * (al - sl) - (Zl - tl) * (U - sl));
            if (Gl === 0 && il([g, U], [tl, sl], [Zl, al]))
              return !0;
            const xl = Math.sign((g - Zl) * (Xl - al) - (ol - Zl) * (U - al));
            if (xl === 0 && il([g, U], [Zl, al], [ol, Xl]))
              return !0;
            const Kl = Math.sign((g - ol) * (sl - Xl) - (tl - ol) * (U - Xl));
            if (Kl === 0 && il([g, U], [ol, Xl], [tl, sl]) || Gl === 1 && xl === 1 && Kl === 1 || Gl === -1 && xl === -1 && Kl === -1)
              return !0;
          }
          return !1;
        }
        isPointInFill(g, U) {
          return this.isPointCollision(g, U, "fill");
        }
        isPointInStroke(g, U) {
          return this.isPointCollision(g, U, "stroke");
        }
        addPass(g, U = {}) {
          let {
            width: o,
            height: L
          } = U, N = b(U, ["width", "height"]);
          const v = new V.default();
          v.rect(0, 0, o, L);
          const f = new E(v, {
            width: o,
            height: L
          });
          f.setUniforms(N), f.setProgram(g), this[bl].push(f);
        }
      }
    },
    /* 57 */
    /***/
    function(Z, d, l) {
      l.r(d);
      var s = l(58);
      l(1).glMatrix.setMatrixArrayType(Array), d.default = s.Stroke;
    },
    /* 58 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "Stroke", function() {
        return y;
      });
      var s = l(49);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = Object(s.create)(), W = Object(s.create)(), u = Object(s.create)(), e = Object(s.create)(), n = Object(s.create)(), G = 1e20;
      class y {
        constructor({
          lineWidth: p = 1,
          lineJoin: X = "miter",
          miterLimit: V = 10,
          lineCap: i = "butt",
          roundSegments: b = 20
        } = {}) {
          this.lineWidth = p, this.lineJoin = X, this.miterLimit = V, this.lineCap = i, this.roundSegments = b, this._normal = null;
        }
        build(p, X = !1) {
          let V = p.length;
          if (p = [...p], V < 2)
            return p;
          X && ((p[0][0] !== p[V - 1][0] || p[0][1] !== p[V - 1][1]) && p.push([...p[0]]), p.push([...p[1]])), V = p.length, this._normal = null;
          const i = {
            left: [],
            right: []
          }, b = this.lineWidth / 2, t = this.lineCap;
          if (!X && t === "square") {
            Object(s.direction)(W, p[0], p[1]), Object(s.scaleAndAdd)(p[0], p[0], W, b);
            const R = p.length - 1;
            Object(s.direction)(W, p[R], p[R - 1]), Object(s.scaleAndAdd)(p[R], p[R], W, b);
          }
          for (let R = 1; R < V; R++) {
            const x = p[R - 1], C = p[R], T = p[R + 1];
            this._seg(i, x, C, T, b, X);
          }
          return !X && t === "round" && h(i, this.roundSegments), [...i.left, ...i.right.reverse()];
        }
        _seg(p, X, V, i, b, t) {
          const m = this.lineJoin === "bevel", R = this.lineJoin === "round";
          if (Object(s.direction)(W, V, X), this._normal || (this._normal = Object(s.create)(), Object(s.normal)(this._normal, W)), p.left.length || I(p, X, this._normal, b), !i)
            Object(s.normal)(this._normal, W), t ? I(p, X, this._normal, b) : I(p, V, this._normal, b);
          else {
            Object(s.direction)(u, i, V);
            let x = Object(s.computeMiter)(e, n, W, u, b);
            x = Math.min(x, G);
            const C = Object(s.dot)(e, this._normal) < 0 ? -1 : 1;
            let T = m || R;
            if (!T && this.lineJoin === "miter" && x / b > this.miterLimit && (T = !0), T) {
              Object(s.scaleAndAdd)(c, V, this._normal, -b * C), a(p, c, C);
              let K = 1 / 0;
              X && (K = Math.min(K, Math.hypot(V[0] - X[0], V[1] - X[1]))), i && (K = Math.min(K, Math.hypot(i[0] - V[0], i[1] - V[1])));
              const J = Math.max(b, Math.min(x, K));
              if (Object(s.scaleAndAdd)(c, V, n, J * C), a(p, c, -C), i)
                if (Object(s.normal)(c, u), Object(s.copy)(this._normal, c), Object(s.scaleAndAdd)(c, V, c, -b * C), R) {
                  const F = Object(s.clone)(c), r = C > 0 ? p.left[p.left.length - 1] : p.right[p.right.length - 1], Y = Object(s.clone)(V), H = Object(s.sub)(Object(s.create)(), r, Y), Q = Object(s.sub)(Object(s.create)(), F, Y), w = Math.PI / this.roundSegments;
                  for (let O = 0; O < this.roundSegments && (Object(s.rotate)(H, H, [0, 0], C * w), Math.sign(Object(s.cross)(c, H, Q)[2]) === C); O++)
                    Object(s.add)(c, H, Y), a(p, c, C);
                  a(p, F, C);
                } else
                  a(p, c, C);
            } else
              I(p, V, n, x), Object(s.copy)(this._normal, n);
          }
        }
      }
      function a(S, p, X) {
        X > 0 ? S.left.push(Object(s.clone)(p)) : S.right.push(Object(s.clone)(p));
      }
      function I(S, p, X, V, i = -1) {
        Object(s.scaleAndAdd)(c, p, X, -V), a(S, c, -i), Object(s.scaleAndAdd)(c, p, X, V), a(S, c, i);
      }
      function h({
        left: S,
        right: p
      }, X) {
        const V = Object(s.create)(), i = Object(s.create)();
        let b = S[0], t = p[0], m = [0.5 * (b[0] + t[0]), 0.5 * (b[1] + t[1])];
        Object(s.sub)(i, b, m);
        for (let R = 1; R <= X; R++) {
          const x = -1 * Math.PI * R / X;
          Object(s.rotate)(V, i, [0, 0], x), Object(s.add)(c, m, V), S.unshift(Object(s.clone)(c));
        }
        b = p[p.length - 1], t = S[S.length - 1], m = [0.5 * (b[0] + t[0]), 0.5 * (b[1] + t[1])], Object(s.sub)(i, b, m);
        for (let R = 1; R <= X; R++) {
          const x = -1 * Math.PI * R / X;
          Object(s.rotate)(V, i, [0, 0], x), Object(s.add)(c, m, V), p.push(Object(s.clone)(c));
        }
      }
    },
    /* 59 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "isUnitTransform", function() {
        return s;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s(c) {
        return c[0] === 1 && c[1] === 0 && c[2] === 0 && c[3] === 1 && c[4] === 0 && c[5] === 0;
      }
    },
    /* 60 */
    /***/
    function(Z, d, l) {
      l(1).glMatrix.setMatrixArrayType(Array);
      var s = l(61), c = l(62);
      Z.exports = function(W, u) {
        if (u = u || {}, W = W.filter(function(X) {
          return X.length > 2;
        }), W.length === 0)
          return {
            positions: [],
            cells: []
          };
        typeof u.vertexSize != "number" && (u.vertexSize = W[0][0].length), W = W.map(function(X) {
          return X.reduce(function(V, i) {
            return V.concat(i);
          });
        });
        const e = u.rule === "evenodd" ? s.WINDING_ODD : s.WINDING_NONZERO;
        for (var n = s.tesselate(c({
          contours: W,
          windingRule: e,
          elementType: s.POLYGONS,
          polySize: 3,
          vertexSize: 2
        }, u)), G = [], y = 0; y < n.vertices.length; y += u.vertexSize) {
          var a = n.vertices.slice(y, y + u.vertexSize);
          G.push(a);
        }
        var I = [];
        for (y = 0; y < n.elements.length; y += 3) {
          var h = n.elements[y], S = n.elements[y + 1], p = n.elements[y + 2];
          I.push([h, S, p]);
        }
        return {
          positions: G,
          cells: I
        };
      };
    },
    /* 61 */
    /***/
    function(Z, d, l) {
      l(1).glMatrix.setMatrixArrayType(Array);
      var s = {}, c = {};
      Z.exports = s, s.WINDING_ODD = 0, s.WINDING_NONZERO = 1, s.WINDING_POSITIVE = 2, s.WINDING_NEGATIVE = 3, s.WINDING_ABS_GEQ_TWO = 4, s.POLYGONS = 0, s.CONNECTED_POLYGONS = 1, s.BOUNDARY_CONTOURS = 2, s.tesselate = function(i) {
        for (var b = i.debug || !1, t = new V(), m = 0; m < i.contours.length; m++)
          t.addContour(i.vertexSize || 2, i.contours[m]);
        return t.tesselate(i.windingRule || s.WINDING_ODD, i.elementType || s.POLYGONS, i.polySize || 3, i.vertexSize || 2, i.normal || [0, 0, 1]), {
          vertices: t.vertices,
          vertexIndices: t.vertexIndices,
          vertexCount: t.vertexCount,
          elements: t.elements,
          elementCount: t.elementCount,
          mesh: b ? t.mesh : void 0
        };
      };
      var W = function(i) {
        if (!i)
          throw "Assertion Failed!";
      };
      function u() {
        this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
      }
      function e() {
        this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1;
      }
      function n(i) {
        this.next = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Org = null, this.Lface = null, this.activeRegion = null, this.winding = 0, this.side = i;
      }
      n.prototype = {
        get Rface() {
          return this.Sym.Lface;
        },
        set Rface(i) {
          this.Sym.Lface = i;
        },
        get Dst() {
          return this.Sym.Org;
        },
        set Dst(i) {
          this.Sym.Org = i;
        },
        get Oprev() {
          return this.Sym.Lnext;
        },
        set Oprev(i) {
          this.Sym.Lnext = i;
        },
        get Lprev() {
          return this.Onext.Sym;
        },
        set Lprev(i) {
          this.Onext.Sym = i;
        },
        get Dprev() {
          return this.Lnext.Sym;
        },
        set Dprev(i) {
          this.Lnext.Sym = i;
        },
        get Rprev() {
          return this.Sym.Onext;
        },
        set Rprev(i) {
          this.Sym.Onext = i;
        },
        get Dnext() {
          return (
            /*this.Rprev*/
            this.Sym.Onext.Sym
          );
        },
        /* 3 pointers */
        set Dnext(i) {
          this.Sym.Onext.Sym = i;
        },
        /* 3 pointers */
        get Rnext() {
          return (
            /*this.Oprev*/
            this.Sym.Lnext.Sym
          );
        },
        /* 3 pointers */
        set Rnext(i) {
          this.Sym.Lnext.Sym = i;
        }
        /* 3 pointers */
      };
      function G() {
        var i = new u(), b = new e(), t = new n(0), m = new n(1);
        i.next = i.prev = i, i.anEdge = null, b.next = b.prev = b, b.anEdge = null, b.trail = null, b.marked = !1, b.inside = !1, t.next = t, t.Sym = m, t.Onext = null, t.Lnext = null, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, m.next = m, m.Sym = t, m.Onext = null, m.Lnext = null, m.Org = null, m.Lface = null, m.winding = 0, m.activeRegion = null, this.vHead = i, this.fHead = b, this.eHead = t, this.eHeadSym = m;
      }
      G.prototype = {
        /* MakeEdge creates a new pair of half-edges which form their own loop.
        * No vertex or face structures are allocated, but these must be assigned
        * before the current edge operation is completed.
        */
        //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
        makeEdge_: function(i) {
          var b = new n(0), t = new n(1);
          i.Sym.side < i.side && (i = i.Sym);
          var m = i.Sym.next;
          return t.next = m, m.Sym.next = b, b.next = i, i.Sym.next = t, b.Sym = t, b.Onext = b, b.Lnext = t, b.Org = null, b.Lface = null, b.winding = 0, b.activeRegion = null, t.Sym = b, t.Onext = t, t.Lnext = b, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, b;
        },
        /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
        * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
        * a->Onext and b->Onext are exchanged.  This can have various effects
        * depending on whether a and b belong to different face or vertex rings.
        * For more explanation see tessMeshSplice() below.
        */
        // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
        splice_: function(i, b) {
          var t = i.Onext, m = b.Onext;
          t.Sym.Lnext = b, m.Sym.Lnext = i, i.Onext = m, b.Onext = t;
        },
        /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
        * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
        * a place to insert the new vertex in the global vertex list.  We insert
        * the new vertex *before* vNext so that algorithms which walk the vertex
        * list will not see the newly created vertices.
        */
        //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
        makeVertex_: function(i, b, t) {
          var m = i;
          W(m !== null);
          var R = t.prev;
          m.prev = R, R.next = m, m.next = t, t.prev = m, m.anEdge = b;
          var x = b;
          do
            x.Org = m, x = x.Onext;
          while (x !== b);
        },
        /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
        * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
        * a place to insert the new face in the global face list.  We insert
        * the new face *before* fNext so that algorithms which walk the face
        * list will not see the newly created faces.
        */
        // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
        makeFace_: function(i, b, t) {
          var m = i;
          W(m !== null);
          var R = t.prev;
          m.prev = R, R.next = m, m.next = t, t.prev = m, m.anEdge = b, m.trail = null, m.marked = !1, m.inside = t.inside;
          var x = b;
          do
            x.Lface = m, x = x.Lnext;
          while (x !== b);
        },
        /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
        * and removes from the global edge list.
        */
        //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
        killEdge_: function(i) {
          i.Sym.side < i.side && (i = i.Sym);
          var b = i.next, t = i.Sym.next;
          b.Sym.next = t, t.Sym.next = b;
        },
        /* KillVertex( vDel ) destroys a vertex and removes it from the global
        * vertex list.  It updates the vertex loop to point to a given new vertex.
        */
        //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
        killVertex_: function(i, b) {
          var t = i.anEdge, m = t;
          do
            m.Org = b, m = m.Onext;
          while (m !== t);
          var R = i.prev, x = i.next;
          x.prev = R, R.next = x;
        },
        /* KillFace( fDel ) destroys a face and removes it from the global face
        * list.  It updates the face loop to point to a given new face.
        */
        //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
        killFace_: function(i, b) {
          var t = i.anEdge, m = t;
          do
            m.Lface = b, m = m.Lnext;
          while (m !== t);
          var R = i.prev, x = i.next;
          x.prev = R, R.next = x;
        },
        /****************** Basic Edge Operations **********************/
        /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
        * The loop consists of the two new half-edges.
        */
        //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
        makeEdge: function() {
          var i = new u(), b = new u(), t = new e(), m = this.makeEdge_(this.eHead);
          return this.makeVertex_(i, m, this.vHead), this.makeVertex_(b, m.Sym, this.vHead), this.makeFace_(t, m, this.fHead), m;
        },
        /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
        * mesh connectivity and topology.  It changes the mesh so that
        *	eOrg->Onext <- OLD( eDst->Onext )
        *	eDst->Onext <- OLD( eOrg->Onext )
        * where OLD(...) means the value before the meshSplice operation.
        *
        * This can have two effects on the vertex structure:
        *  - if eOrg->Org != eDst->Org, the two vertices are merged together
        *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
        * In both cases, eDst->Org is changed and eOrg->Org is untouched.
        *
        * Similarly (and independently) for the face structure,
        *  - if eOrg->Lface == eDst->Lface, one loop is split into two
        *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
        * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
        *
        * Some special cases:
        * If eDst == eOrg, the operation has no effect.
        * If eDst == eOrg->Lnext, the new face will have a single edge.
        * If eDst == eOrg->Lprev, the old face will have a single edge.
        * If eDst == eOrg->Onext, the new vertex will have a single edge.
        * If eDst == eOrg->Oprev, the old vertex will have a single edge.
        */
        //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
        splice: function(i, b) {
          var t = !1, m = !1;
          if (i !== b) {
            if (b.Org !== i.Org && (m = !0, this.killVertex_(b.Org, i.Org)), b.Lface !== i.Lface && (t = !0, this.killFace_(b.Lface, i.Lface)), this.splice_(b, i), !m) {
              var R = new u();
              this.makeVertex_(R, b, i.Org), i.Org.anEdge = i;
            }
            if (!t) {
              var x = new e();
              this.makeFace_(x, b, i.Lface), i.Lface.anEdge = i;
            }
          }
        },
        /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
        * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
        * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
        * the newly created loop will contain eDel->Dst.  If the deletion of eDel
        * would create isolated vertices, those are deleted as well.
        *
        * This function could be implemented as two calls to tessMeshSplice
        * plus a few calls to memFree, but this would allocate and delete
        * unnecessary vertices and faces.
        */
        //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
        delete: function(i) {
          var b = i.Sym, t = !1;
          if (i.Lface !== i.Rface && (t = !0, this.killFace_(i.Lface, i.Rface)), i.Onext === i)
            this.killVertex_(i.Org, null);
          else if (i.Rface.anEdge = i.Oprev, i.Org.anEdge = i.Onext, this.splice_(i, i.Oprev), !t) {
            var m = new e();
            this.makeFace_(m, i, i.Lface);
          }
          b.Onext === b ? (this.killVertex_(b.Org, null), this.killFace_(b.Lface, null)) : (i.Lface.anEdge = b.Oprev, b.Org.anEdge = b.Onext, this.splice_(b, b.Oprev)), this.killEdge_(i);
        },
        /******************** Other Edge Operations **********************/
        /* All these routines can be implemented with the basic edge
        * operations above.  They are provided for convenience and efficiency.
        */
        /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
        * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
        addEdgeVertex: function(i) {
          var b = this.makeEdge_(i), t = b.Sym;
          this.splice_(b, i.Lnext), b.Org = i.Dst;
          var m = new u();
          return this.makeVertex_(m, t, b.Org), b.Lface = t.Lface = i.Lface, b;
        },
        /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
        * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
        splitEdge: function(i, b) {
          var t = this.addEdgeVertex(i), m = t.Sym;
          return this.splice_(i.Sym, i.Sym.Oprev), this.splice_(i.Sym, m), i.Dst = m.Org, m.Dst.anEdge = m.Sym, m.Rface = i.Rface, m.winding = i.winding, m.Sym.winding = i.Sym.winding, m;
        },
        /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
        * to eDst->Org, and returns the corresponding half-edge eNew.
        * If eOrg->Lface == eDst->Lface, this splits one loop into two,
        * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
        * loops are merged into one, and the loop eDst->Lface is destroyed.
        *
        * If (eOrg == eDst), the new face will have only two edges.
        * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
        * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
        */
        // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
        connect: function(i, b) {
          var t = !1, m = this.makeEdge_(i), R = m.Sym;
          if (b.Lface !== i.Lface && (t = !0, this.killFace_(b.Lface, i.Lface)), this.splice_(m, i.Lnext), this.splice_(R, b), m.Org = i.Dst, R.Org = b.Org, m.Lface = R.Lface = i.Lface, i.Lface.anEdge = R, !t) {
            var x = new e();
            this.makeFace_(x, m, i.Lface);
          }
          return m;
        },
        /* tessMeshZapFace( fZap ) destroys a face and removes it from the
        * global face list.  All edges of fZap will have a NULL pointer as their
        * left face.  Any edges which also have a NULL pointer as their right face
        * are deleted entirely (along with any isolated vertices this produces).
        * An entire mesh can be deleted by zapping its faces, one at a time,
        * in any order.  Zapped faces cannot be used in further mesh operations!
        */
        zapFace: function(i) {
          var b = i.anEdge, t, m, R, x, C;
          m = b.Lnext;
          do
            t = m, m = t.Lnext, t.Lface = null, t.Rface === null && (t.Onext === t ? this.killVertex_(t.Org, null) : (t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), R = t.Sym, R.Onext === R ? this.killVertex_(R.Org, null) : (R.Org.anEdge = R.Onext, this.splice_(R, R.Oprev)), this.killEdge_(t));
          while (t != b);
          x = i.prev, C = i.next, C.prev = x, x.next = C;
        },
        countFaceVerts_: function(i) {
          var b = i.anEdge, t = 0;
          do
            t++, b = b.Lnext;
          while (b !== i.anEdge);
          return t;
        },
        //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
        mergeConvexFaces: function(i) {
          var b, t, m, R, x, C, T;
          for (b = this.fHead.next; b !== this.fHead; b = b.next)
            if (b.inside)
              for (t = b.anEdge, x = t.Org; m = t.Lnext, R = t.Sym, R && R.Lface && R.Lface.inside && (C = this.countFaceVerts_(b), T = this.countFaceVerts_(R.Lface), C + T - 2 <= i && c.vertCCW(t.Lprev.Org, t.Org, R.Lnext.Lnext.Org) && c.vertCCW(R.Lprev.Org, R.Org, t.Lnext.Lnext.Org) && (m = R.Lnext, this.delete(R), t = null, R = null)), !(t && t.Lnext.Org === x); )
                t = m;
          return !0;
        },
        /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
        */
        check: function() {
          var i = this.fHead, b = this.vHead, t = this.eHead, m, R, x, C, T, K;
          for (R = i, R = i; (m = R.next) !== i; R = m) {
            W(m.prev === R), T = m.anEdge;
            do
              W(T.Sym !== T), W(T.Sym.Sym === T), W(T.Lnext.Onext.Sym === T), W(T.Onext.Sym.Lnext === T), W(T.Lface === m), T = T.Lnext;
            while (T !== m.anEdge);
          }
          for (W(m.prev === R && m.anEdge === null), C = b, C = b; (x = C.next) !== b; C = x) {
            W(x.prev === C), T = x.anEdge;
            do
              W(T.Sym !== T), W(T.Sym.Sym === T), W(T.Lnext.Onext.Sym === T), W(T.Onext.Sym.Lnext === T), W(T.Org === x), T = T.Onext;
            while (T !== x.anEdge);
          }
          for (W(x.prev === C && x.anEdge === null), K = t, K = t; (T = K.next) !== t; K = T)
            W(T.Sym.next === K.Sym), W(T.Sym !== T), W(T.Sym.Sym === T), W(T.Org !== null), W(T.Dst !== null), W(T.Lnext.Onext.Sym === T), W(T.Onext.Sym.Lnext === T);
          W(T.Sym.next === K.Sym && T.Sym === this.eHeadSym && T.Sym.Sym === T && T.Org === null && T.Dst === null && T.Lface === null && T.Rface === null);
        }
      }, c.vertEq = function(i, b) {
        return i.s === b.s && i.t === b.t;
      }, c.vertLeq = function(i, b) {
        return i.s < b.s || i.s === b.s && i.t <= b.t;
      }, c.transLeq = function(i, b) {
        return i.t < b.t || i.t === b.t && i.s <= b.s;
      }, c.edgeGoesLeft = function(i) {
        return c.vertLeq(i.Dst, i.Org);
      }, c.edgeGoesRight = function(i) {
        return c.vertLeq(i.Org, i.Dst);
      }, c.vertL1dist = function(i, b) {
        return Math.abs(i.s - b.s) + Math.abs(i.t - b.t);
      }, c.edgeEval = function(i, b, t) {
        W(c.vertLeq(i, b) && c.vertLeq(b, t));
        var m = b.s - i.s, R = t.s - b.s;
        return m + R > 0 ? m < R ? b.t - i.t + (i.t - t.t) * (m / (m + R)) : b.t - t.t + (t.t - i.t) * (R / (m + R)) : 0;
      }, c.edgeSign = function(i, b, t) {
        W(c.vertLeq(i, b) && c.vertLeq(b, t));
        var m = b.s - i.s, R = t.s - b.s;
        return m + R > 0 ? (b.t - t.t) * m + (b.t - i.t) * R : 0;
      }, c.transEval = function(i, b, t) {
        W(c.transLeq(i, b) && c.transLeq(b, t));
        var m = b.t - i.t, R = t.t - b.t;
        return m + R > 0 ? m < R ? b.s - i.s + (i.s - t.s) * (m / (m + R)) : b.s - t.s + (t.s - i.s) * (R / (m + R)) : 0;
      }, c.transSign = function(i, b, t) {
        W(c.transLeq(i, b) && c.transLeq(b, t));
        var m = b.t - i.t, R = t.t - b.t;
        return m + R > 0 ? (b.s - t.s) * m + (b.s - i.s) * R : 0;
      }, c.vertCCW = function(i, b, t) {
        return i.s * (b.t - t.t) + b.s * (t.t - i.t) + t.s * (i.t - b.t) >= 0;
      }, c.interpolate = function(i, b, t, m) {
        return i = i < 0 ? 0 : i, t = t < 0 ? 0 : t, i <= t ? t === 0 ? (b + m) / 2 : b + (m - b) * (i / (i + t)) : m + (b - m) * (t / (i + t));
      }, c.intersect = function(i, b, t, m, R) {
        var x, C, T;
        c.vertLeq(i, b) || (T = i, i = b, b = T), c.vertLeq(t, m) || (T = t, t = m, m = T), c.vertLeq(i, t) || (T = i, i = t, t = T, T = b, b = m, m = T), c.vertLeq(t, b) ? c.vertLeq(b, m) ? (x = c.edgeEval(i, t, b), C = c.edgeEval(t, b, m), x + C < 0 && (x = -x, C = -C), R.s = c.interpolate(x, t.s, C, b.s)) : (x = c.edgeSign(i, t, b), C = -c.edgeSign(i, m, b), x + C < 0 && (x = -x, C = -C), R.s = c.interpolate(x, t.s, C, m.s)) : R.s = (t.s + b.s) / 2, c.transLeq(i, b) || (T = i, i = b, b = T), c.transLeq(t, m) || (T = t, t = m, m = T), c.transLeq(i, t) || (T = i, i = t, t = T, T = b, b = m, m = T), c.transLeq(t, b) ? c.transLeq(b, m) ? (x = c.transEval(i, t, b), C = c.transEval(t, b, m), x + C < 0 && (x = -x, C = -C), R.t = c.interpolate(x, t.t, C, b.t)) : (x = c.transSign(i, t, b), C = -c.transSign(i, m, b), x + C < 0 && (x = -x, C = -C), R.t = c.interpolate(x, t.t, C, m.t)) : R.t = (t.t + b.t) / 2;
      };
      function y() {
        this.key = null, this.next = null, this.prev = null;
      }
      function a(i, b) {
        this.head = new y(), this.head.next = this.head, this.head.prev = this.head, this.frame = i, this.leq = b;
      }
      a.prototype = {
        min: function() {
          return this.head.next;
        },
        max: function() {
          return this.head.prev;
        },
        insert: function(i) {
          return this.insertBefore(this.head, i);
        },
        search: function(i) {
          var b = this.head;
          do
            b = b.next;
          while (b.key !== null && !this.leq(this.frame, i, b.key));
          return b;
        },
        insertBefore: function(i, b) {
          do
            i = i.prev;
          while (i.key !== null && !this.leq(this.frame, i.key, b));
          var t = new y();
          return t.key = b, t.next = i.next, i.next.prev = t, t.prev = i, i.next = t, t;
        },
        delete: function(i) {
          i.next.prev = i.prev, i.prev.next = i.next;
        }
      };
      function I() {
        this.handle = null;
      }
      function h() {
        this.key = null, this.node = null;
      }
      function S(i, b) {
        this.size = 0, this.max = i, this.nodes = [], this.nodes.length = i + 1;
        var t;
        for (t = 0; t < this.nodes.length; t++)
          this.nodes[t] = new I();
        for (this.handles = [], this.handles.length = i + 1, t = 0; t < this.handles.length; t++)
          this.handles[t] = new h();
        this.initialized = !1, this.freeList = 0, this.leq = b, this.nodes[1].handle = 1, this.handles[1].key = null;
      }
      S.prototype = {
        floatDown_: function(i) {
          var b = this.nodes, t = this.handles, m, R, x;
          for (m = b[i].handle; ; ) {
            if (x = i << 1, x < this.size && this.leq(t[b[x + 1].handle].key, t[b[x].handle].key) && ++x, W(x <= this.max), R = b[x].handle, x > this.size || this.leq(t[m].key, t[R].key)) {
              b[i].handle = m, t[m].node = i;
              break;
            }
            b[i].handle = R, t[R].node = i, i = x;
          }
        },
        floatUp_: function(i) {
          var b = this.nodes, t = this.handles, m, R, x;
          for (m = b[i].handle; ; ) {
            if (x = i >> 1, R = b[x].handle, x === 0 || this.leq(t[R].key, t[m].key)) {
              b[i].handle = m, t[m].node = i;
              break;
            }
            b[i].handle = R, t[R].node = i, i = x;
          }
        },
        init: function() {
          for (var i = this.size; i >= 1; --i)
            this.floatDown_(i);
          this.initialized = !0;
        },
        min: function() {
          return this.handles[this.nodes[1].handle].key;
        },
        /* really pqHeapInsert */
        /* returns INV_HANDLE iff out of memory */
        //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
        insert: function(i) {
          var b, t;
          if (b = ++this.size, b * 2 > this.max) {
            this.max *= 2;
            var m, R;
            for (R = this.nodes.length, this.nodes.length = this.max + 1, m = R; m < this.nodes.length; m++)
              this.nodes[m] = new I();
            for (R = this.handles.length, this.handles.length = this.max + 1, m = R; m < this.handles.length; m++)
              this.handles[m] = new h();
          }
          return this.freeList === 0 ? t = b : (t = this.freeList, this.freeList = this.handles[t].node), this.nodes[b].handle = t, this.handles[t].node = b, this.handles[t].key = i, this.initialized && this.floatUp_(b), t;
        },
        //PQkey pqHeapExtractMin( PriorityQHeap *pq )
        extractMin: function() {
          var i = this.nodes, b = this.handles, t = i[1].handle, m = b[t].key;
          return this.size > 0 && (i[1].handle = i[this.size].handle, b[i[1].handle].node = 1, b[t].key = null, b[t].node = this.freeList, this.freeList = t, --this.size, this.size > 0 && this.floatDown_(1)), m;
        },
        delete: function(i) {
          var b = this.nodes, t = this.handles, m;
          W(i >= 1 && i <= this.max && t[i].key !== null), m = t[i].node, b[m].handle = b[this.size].handle, t[b[m].handle].node = m, --this.size, m <= this.size && (m <= 1 || this.leq(t[b[m >> 1].handle].key, t[b[m].handle].key) ? this.floatDown_(m) : this.floatUp_(m)), t[i].key = null, t[i].node = this.freeList, this.freeList = i;
        }
      };
      function p() {
        this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1;
      }
      var X = {};
      X.regionBelow = function(i) {
        return i.nodeUp.prev.key;
      }, X.regionAbove = function(i) {
        return i.nodeUp.next.key;
      }, X.debugEvent = function(i) {
      }, X.addWinding = function(i, b) {
        i.winding += b.winding, i.Sym.winding += b.Sym.winding;
      }, X.edgeLeq = function(i, b, t) {
        var m = i.event, C, T, R = b.eUp, x = t.eUp;
        if (R.Dst === m)
          return x.Dst === m ? c.vertLeq(R.Org, x.Org) ? c.edgeSign(x.Dst, R.Org, x.Org) <= 0 : c.edgeSign(R.Dst, x.Org, R.Org) >= 0 : c.edgeSign(x.Dst, m, x.Org) <= 0;
        if (x.Dst === m)
          return c.edgeSign(R.Dst, m, R.Org) >= 0;
        var C = c.edgeEval(R.Dst, m, R.Org), T = c.edgeEval(x.Dst, m, x.Org);
        return C >= T;
      }, X.deleteRegion = function(i, b) {
        b.fixUpperEdge && W(b.eUp.winding === 0), b.eUp.activeRegion = null, i.dict.delete(b.nodeUp);
      }, X.fixUpperEdge = function(i, b, t) {
        W(b.fixUpperEdge), i.mesh.delete(b.eUp), b.fixUpperEdge = !1, b.eUp = t, t.activeRegion = b;
      }, X.topLeftRegion = function(i, b) {
        var t = b.eUp.Org, m;
        do
          b = X.regionAbove(b);
        while (b.eUp.Org === t);
        if (b.fixUpperEdge) {
          if (m = i.mesh.connect(X.regionBelow(b).eUp.Sym, b.eUp.Lnext), m === null)
            return null;
          X.fixUpperEdge(i, b, m), b = X.regionAbove(b);
        }
        return b;
      }, X.topRightRegion = function(i) {
        var b = i.eUp.Dst;
        do
          i = X.regionAbove(i);
        while (i.eUp.Dst === b);
        return i;
      }, X.addRegionBelow = function(i, b, t) {
        var m = new p();
        return m.eUp = t, m.nodeUp = i.dict.insertBefore(b.nodeUp, m), m.fixUpperEdge = !1, m.sentinel = !1, m.dirty = !1, t.activeRegion = m, m;
      }, X.isWindingInside = function(i, b) {
        switch (i.windingRule) {
          case s.WINDING_ODD:
            return (b & 1) !== 0;
          case s.WINDING_NONZERO:
            return b !== 0;
          case s.WINDING_POSITIVE:
            return b > 0;
          case s.WINDING_NEGATIVE:
            return b < 0;
          case s.WINDING_ABS_GEQ_TWO:
            return b >= 2 || b <= -2;
        }
        return W(!1), !1;
      }, X.computeWinding = function(i, b) {
        b.windingNumber = X.regionAbove(b).windingNumber + b.eUp.winding, b.inside = X.isWindingInside(i, b.windingNumber);
      }, X.finishRegion = function(i, b) {
        var t = b.eUp, m = t.Lface;
        m.inside = b.inside, m.anEdge = t, X.deleteRegion(i, b);
      }, X.finishLeftRegions = function(i, b, t) {
        for (var m, C, R = null, x = b, C = b.eUp; x !== t; ) {
          if (x.fixUpperEdge = !1, R = X.regionBelow(x), m = R.eUp, m.Org != C.Org) {
            if (!R.fixUpperEdge) {
              X.finishRegion(i, x);
              break;
            }
            m = i.mesh.connect(C.Lprev, m.Sym), X.fixUpperEdge(i, R, m);
          }
          C.Onext !== m && (i.mesh.splice(m.Oprev, m), i.mesh.splice(C, m)), X.finishRegion(i, x), C = R.eUp, x = R;
        }
        return C;
      }, X.addRightEdges = function(i, b, t, m, R, x) {
        var C, T, K, J, F = !0;
        K = t;
        do
          W(c.vertLeq(K.Org, K.Dst)), X.addRegionBelow(i, b, K.Sym), K = K.Onext;
        while (K !== m);
        for (R === null && (R = X.regionBelow(b).eUp.Rprev), T = b, J = R; C = X.regionBelow(T), K = C.eUp.Sym, K.Org === J.Org; )
          K.Onext !== J && (i.mesh.splice(K.Oprev, K), i.mesh.splice(J.Oprev, K)), C.windingNumber = T.windingNumber - K.winding, C.inside = X.isWindingInside(i, C.windingNumber), T.dirty = !0, !F && X.checkForRightSplice(i, T) && (X.addWinding(K, J), X.deleteRegion(i, T), i.mesh.delete(J)), F = !1, T = C, J = K;
        T.dirty = !0, W(T.windingNumber - K.winding === C.windingNumber), x && X.walkDirtyRegions(i, T);
      }, X.spliceMergeVertices = function(i, b, t) {
        i.mesh.splice(b, t);
      }, X.vertexWeights = function(i, b, t) {
        var m = c.vertL1dist(b, i), R = c.vertL1dist(t, i), x = 0.5 * R / (m + R), C = 0.5 * m / (m + R);
        i.coords[0] += x * b.coords[0] + C * t.coords[0], i.coords[1] += x * b.coords[1] + C * t.coords[1], i.coords[2] += x * b.coords[2] + C * t.coords[2];
      }, X.getIntersectData = function(i, b, t, m, R, x) {
        b.coords[0] = b.coords[1] = b.coords[2] = 0, b.idx = -1, X.vertexWeights(b, t, m), X.vertexWeights(b, R, x);
      }, X.checkForRightSplice = function(i, b) {
        var t = X.regionBelow(b), m = b.eUp, R = t.eUp;
        if (c.vertLeq(m.Org, R.Org)) {
          if (c.edgeSign(R.Dst, m.Org, R.Org) > 0)
            return !1;
          c.vertEq(m.Org, R.Org) ? m.Org !== R.Org && (i.pq.delete(m.Org.pqHandle), X.spliceMergeVertices(i, R.Oprev, m)) : (i.mesh.splitEdge(R.Sym), i.mesh.splice(m, R.Oprev), b.dirty = t.dirty = !0);
        } else {
          if (c.edgeSign(m.Dst, R.Org, m.Org) < 0)
            return !1;
          X.regionAbove(b).dirty = b.dirty = !0, i.mesh.splitEdge(m.Sym), i.mesh.splice(R.Oprev, m);
        }
        return !0;
      }, X.checkForLeftSplice = function(i, b) {
        var t = X.regionBelow(b), m = b.eUp, R = t.eUp, x;
        if (W(!c.vertEq(m.Dst, R.Dst)), c.vertLeq(m.Dst, R.Dst)) {
          if (c.edgeSign(m.Dst, R.Dst, m.Org) < 0)
            return !1;
          X.regionAbove(b).dirty = b.dirty = !0, x = i.mesh.splitEdge(m), i.mesh.splice(R.Sym, x), x.Lface.inside = b.inside;
        } else {
          if (c.edgeSign(R.Dst, m.Dst, R.Org) > 0)
            return !1;
          b.dirty = t.dirty = !0, x = i.mesh.splitEdge(R), i.mesh.splice(m.Lnext, R.Sym), x.Rface.inside = b.inside;
        }
        return !0;
      }, X.checkForIntersect = function(i, b) {
        var t = X.regionBelow(b), m = b.eUp, R = t.eUp, x = m.Org, C = R.Org, T = m.Dst, K = R.Dst, J, F, r = new u(), Y, H;
        if (W(!c.vertEq(K, T)), W(c.edgeSign(T, i.event, x) <= 0), W(c.edgeSign(K, i.event, C) >= 0), W(x !== i.event && C !== i.event), W(!b.fixUpperEdge && !t.fixUpperEdge), x === C || (J = Math.min(x.t, T.t), F = Math.max(C.t, K.t), J > F))
          return !1;
        if (c.vertLeq(x, C)) {
          if (c.edgeSign(K, x, C) > 0)
            return !1;
        } else if (c.edgeSign(T, C, x) < 0)
          return !1;
        return X.debugEvent(i), c.intersect(T, x, K, C, r), W(Math.min(x.t, T.t) <= r.t), W(r.t <= Math.max(C.t, K.t)), W(Math.min(K.s, T.s) <= r.s), W(r.s <= Math.max(C.s, x.s)), c.vertLeq(r, i.event) && (r.s = i.event.s, r.t = i.event.t), Y = c.vertLeq(x, C) ? x : C, c.vertLeq(Y, r) && (r.s = Y.s, r.t = Y.t), c.vertEq(r, x) || c.vertEq(r, C) ? (X.checkForRightSplice(i, b), !1) : !c.vertEq(T, i.event) && c.edgeSign(T, i.event, r) >= 0 || !c.vertEq(K, i.event) && c.edgeSign(K, i.event, r) <= 0 ? K === i.event ? (i.mesh.splitEdge(m.Sym), i.mesh.splice(R.Sym, m), b = X.topLeftRegion(i, b), m = X.regionBelow(b).eUp, X.finishLeftRegions(i, X.regionBelow(b), t), X.addRightEdges(i, b, m.Oprev, m, m, !0), !0) : T === i.event ? (i.mesh.splitEdge(R.Sym), i.mesh.splice(m.Lnext, R.Oprev), t = b, b = X.topRightRegion(b), H = X.regionBelow(b).eUp.Rprev, t.eUp = R.Oprev, R = X.finishLeftRegions(i, t, null), X.addRightEdges(i, b, R.Onext, m.Rprev, H, !0), !0) : (c.edgeSign(T, i.event, r) >= 0 && (X.regionAbove(b).dirty = b.dirty = !0, i.mesh.splitEdge(m.Sym), m.Org.s = i.event.s, m.Org.t = i.event.t), c.edgeSign(K, i.event, r) <= 0 && (b.dirty = t.dirty = !0, i.mesh.splitEdge(R.Sym), R.Org.s = i.event.s, R.Org.t = i.event.t), !1) : (i.mesh.splitEdge(m.Sym), i.mesh.splitEdge(R.Sym), i.mesh.splice(R.Oprev, m), m.Org.s = r.s, m.Org.t = r.t, m.Org.pqHandle = i.pq.insert(m.Org), X.getIntersectData(i, m.Org, x, T, C, K), X.regionAbove(b).dirty = b.dirty = t.dirty = !0, !1);
      }, X.walkDirtyRegions = function(i, b) {
        for (var t = X.regionBelow(b), m, R; ; ) {
          for (; t.dirty; )
            b = t, t = X.regionBelow(t);
          if (!b.dirty && (t = b, b = X.regionAbove(b), b === null || !b.dirty))
            return;
          if (b.dirty = !1, m = b.eUp, R = t.eUp, m.Dst !== R.Dst && X.checkForLeftSplice(i, b) && (t.fixUpperEdge ? (X.deleteRegion(i, t), i.mesh.delete(R), t = X.regionBelow(b), R = t.eUp) : b.fixUpperEdge && (X.deleteRegion(i, b), i.mesh.delete(m), b = X.regionAbove(t), m = b.eUp)), m.Org !== R.Org)
            if (m.Dst !== R.Dst && !b.fixUpperEdge && !t.fixUpperEdge && (m.Dst === i.event || R.Dst === i.event)) {
              if (X.checkForIntersect(i, b))
                return;
            } else
              X.checkForRightSplice(i, b);
          m.Org === R.Org && m.Dst === R.Dst && (X.addWinding(R, m), X.deleteRegion(i, b), i.mesh.delete(m), b = X.regionAbove(t));
        }
      }, X.connectRightVertex = function(i, b, t) {
        var m, R = t.Onext, x = X.regionBelow(b), C = b.eUp, T = x.eUp, K = !1;
        if (C.Dst !== T.Dst && X.checkForIntersect(i, b), c.vertEq(C.Org, i.event) && (i.mesh.splice(R.Oprev, C), b = X.topLeftRegion(i, b), R = X.regionBelow(b).eUp, X.finishLeftRegions(i, X.regionBelow(b), x), K = !0), c.vertEq(T.Org, i.event) && (i.mesh.splice(t, T.Oprev), t = X.finishLeftRegions(i, x, null), K = !0), K) {
          X.addRightEdges(i, b, t.Onext, R, R, !0);
          return;
        }
        c.vertLeq(T.Org, C.Org) ? m = T.Oprev : m = C, m = i.mesh.connect(t.Lprev, m), X.addRightEdges(i, b, m, m.Onext, m.Onext, !1), m.Sym.activeRegion.fixUpperEdge = !0, X.walkDirtyRegions(i, b);
      }, X.connectLeftDegenerate = function(i, b, t) {
        var m, R, x, C, T;
        if (m = b.eUp, c.vertEq(m.Org, t)) {
          W(
            !1
            /*TOLERANCE_NONZERO*/
          ), X.spliceMergeVertices(i, m, t.anEdge);
          return;
        }
        if (!c.vertEq(m.Dst, t)) {
          i.mesh.splitEdge(m.Sym), b.fixUpperEdge && (i.mesh.delete(m.Onext), b.fixUpperEdge = !1), i.mesh.splice(t.anEdge, m), X.sweepEvent(i, t);
          return;
        }
        W(
          !1
          /*TOLERANCE_NONZERO*/
        ), b = X.topRightRegion(b), T = X.regionBelow(b), x = T.eUp.Sym, R = C = x.Onext, T.fixUpperEdge && (W(R !== x), X.deleteRegion(i, T), i.mesh.delete(x), x = R.Oprev), i.mesh.splice(t.anEdge, x), c.edgeGoesLeft(R) || (R = null), X.addRightEdges(i, b, x.Onext, C, R, !0);
      }, X.connectLeftVertex = function(i, b) {
        var t, m, R, x, C, T, K = new p();
        if (K.eUp = b.anEdge.Sym, t = i.dict.search(K).key, m = X.regionBelow(t), !!m) {
          if (x = t.eUp, C = m.eUp, c.edgeSign(x.Dst, b, x.Org) === 0) {
            X.connectLeftDegenerate(i, t, b);
            return;
          }
          if (R = c.vertLeq(C.Dst, x.Dst) ? t : m, t.inside || R.fixUpperEdge) {
            if (R === t)
              T = i.mesh.connect(b.anEdge.Sym, x.Lnext);
            else {
              var J = i.mesh.connect(C.Dnext, b.anEdge);
              T = J.Sym;
            }
            R.fixUpperEdge ? X.fixUpperEdge(i, R, T) : X.computeWinding(i, X.addRegionBelow(i, t, T)), X.sweepEvent(i, b);
          } else
            X.addRightEdges(i, t, b.anEdge, b.anEdge, null, !0);
        }
      }, X.sweepEvent = function(i, b) {
        i.event = b, X.debugEvent(i);
        for (var t = b.anEdge; t.activeRegion === null; )
          if (t = t.Onext, t === b.anEdge) {
            X.connectLeftVertex(i, b);
            return;
          }
        var m = X.topLeftRegion(i, t.activeRegion);
        W(m !== null);
        var R = X.regionBelow(m), x = R.eUp, C = X.finishLeftRegions(i, R, null);
        C.Onext === x ? X.connectRightVertex(i, m, C) : X.addRightEdges(i, m, C.Onext, x, x, !0);
      }, X.addSentinel = function(i, b, t, m) {
        var R = new p(), x = i.mesh.makeEdge();
        x.Org.s = t, x.Org.t = m, x.Dst.s = b, x.Dst.t = m, i.event = x.Dst, R.eUp = x, R.windingNumber = 0, R.inside = !1, R.fixUpperEdge = !1, R.sentinel = !0, R.dirty = !1, R.nodeUp = i.dict.insert(R);
      }, X.initEdgeDict = function(i) {
        i.dict = new a(i, X.edgeLeq);
        var b = i.bmax[0] - i.bmin[0], t = i.bmax[1] - i.bmin[1], m = i.bmin[0] - b, R = i.bmax[0] + b, x = i.bmin[1] - t, C = i.bmax[1] + t;
        X.addSentinel(i, m, R, x), X.addSentinel(i, m, R, C);
      }, X.doneEdgeDict = function(i) {
        for (var b, t = 0; (b = i.dict.min().key) !== null; )
          b.sentinel || (W(b.fixUpperEdge), W(++t === 1)), W(b.windingNumber === 0), X.deleteRegion(i, b);
      }, X.removeDegenerateEdges = function(i) {
        var b, t, m, R = i.mesh.eHead;
        for (b = R.next; b !== R; b = t)
          t = b.next, m = b.Lnext, c.vertEq(b.Org, b.Dst) && b.Lnext.Lnext !== b && (X.spliceMergeVertices(i, m, b), i.mesh.delete(b), b = m, m = b.Lnext), m.Lnext === b && (m !== b && ((m === t || m === t.Sym) && (t = t.next), i.mesh.delete(m)), (b === t || b === t.Sym) && (t = t.next), i.mesh.delete(b));
      }, X.initPriorityQ = function(i) {
        var b, t, m, R = 0;
        for (m = i.mesh.vHead, t = m.next; t !== m; t = t.next)
          R++;
        for (R += 8, b = i.pq = new S(R, c.vertLeq), m = i.mesh.vHead, t = m.next; t !== m; t = t.next)
          t.pqHandle = b.insert(t);
        return t !== m ? !1 : (b.init(), !0);
      }, X.donePriorityQ = function(i) {
        i.pq = null;
      }, X.removeDegenerateFaces = function(i, b) {
        var t, m, R;
        for (t = b.fHead.next; t !== b.fHead; t = m)
          m = t.next, R = t.anEdge, W(R.Lnext !== R), R.Lnext.Lnext === R && (X.addWinding(R.Onext, R), i.mesh.delete(R));
        return !0;
      }, X.computeInterior = function(i) {
        var b, t;
        if (X.removeDegenerateEdges(i), !X.initPriorityQ(i))
          return !1;
        for (X.initEdgeDict(i); (b = i.pq.extractMin()) !== null; ) {
          for (; t = i.pq.min(), !(t === null || !c.vertEq(t, b)); )
            t = i.pq.extractMin(), X.spliceMergeVertices(i, b.anEdge, t.anEdge);
          X.sweepEvent(i, b);
        }
        return i.event = i.dict.min().key.eUp.Org, X.debugEvent(i), X.doneEdgeDict(i), X.donePriorityQ(i), X.removeDegenerateFaces(i, i.mesh) ? (i.mesh.check(), !0) : !1;
      };
      function V() {
        this.mesh = null, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = s.WINDING_ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
      }
      V.prototype = {
        dot_: function(i, b) {
          return i[0] * b[0] + i[1] * b[1] + i[2] * b[2];
        },
        normalize_: function(i) {
          var b = i[0] * i[0] + i[1] * i[1] + i[2] * i[2];
          W(b > 0), b = Math.sqrt(b), i[0] /= b, i[1] /= b, i[2] /= b;
        },
        longAxis_: function(i) {
          var b = 0;
          return Math.abs(i[1]) > Math.abs(i[0]) && (b = 1), Math.abs(i[2]) > Math.abs(i[b]) && (b = 2), b;
        },
        computeNormal_: function(i) {
          var b, t, m, R, x, C, T = [0, 0, 0], K = [0, 0, 0], J = [0, 0, 0], F = [0, 0, 0], r = [0, 0, 0], Y = [null, null, null], H = [null, null, null], Q = this.mesh.vHead, w;
          for (b = Q.next, w = 0; w < 3; ++w)
            R = b.coords[w], K[w] = R, H[w] = b, T[w] = R, Y[w] = b;
          for (b = Q.next; b !== Q; b = b.next)
            for (w = 0; w < 3; ++w)
              R = b.coords[w], R < K[w] && (K[w] = R, H[w] = b), R > T[w] && (T[w] = R, Y[w] = b);
          if (w = 0, T[1] - K[1] > T[0] - K[0] && (w = 1), T[2] - K[2] > T[w] - K[w] && (w = 2), K[w] >= T[w]) {
            i[0] = 0, i[1] = 0, i[2] = 1;
            return;
          }
          for (C = 0, t = H[w], m = Y[w], J[0] = t.coords[0] - m.coords[0], J[1] = t.coords[1] - m.coords[1], J[2] = t.coords[2] - m.coords[2], b = Q.next; b !== Q; b = b.next)
            F[0] = b.coords[0] - m.coords[0], F[1] = b.coords[1] - m.coords[1], F[2] = b.coords[2] - m.coords[2], r[0] = J[1] * F[2] - J[2] * F[1], r[1] = J[2] * F[0] - J[0] * F[2], r[2] = J[0] * F[1] - J[1] * F[0], x = r[0] * r[0] + r[1] * r[1] + r[2] * r[2], x > C && (C = x, i[0] = r[0], i[1] = r[1], i[2] = r[2]);
          C <= 0 && (i[0] = i[1] = i[2] = 0, i[this.longAxis_(J)] = 1);
        },
        checkOrientation_: function() {
          var i, b, t = this.mesh.fHead, m, R = this.mesh.vHead, x;
          for (i = 0, b = t.next; b !== t; b = b.next)
            if (x = b.anEdge, !(x.winding <= 0))
              do
                i += (x.Org.s - x.Dst.s) * (x.Org.t + x.Dst.t), x = x.Lnext;
              while (x !== b.anEdge);
          if (i < 0) {
            for (m = R.next; m !== R; m = m.next)
              m.t = -m.t;
            this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
          }
        },
        /*	#ifdef FOR_TRITE_TEST_PROGRAM
          #include <stdlib.h>
          extern int RandomSweep;
          #define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
          #define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
          #else
          #if defined(SLANTED_SWEEP) */
        /* The "feature merging" is not intended to be complete.  There are
        * special cases where edges are nearly parallel to the sweep line
        * which are not implemented.  The algorithm should still behave
        * robustly (ie. produce a reasonable tesselation) in the presence
        * of such edges, however it may miss features which could have been
        * merged.  We could minimize this effect by choosing the sweep line
        * direction to be something unusual (ie. not parallel to one of the
        * coordinate axes).
        */
        /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
          #define S_UNIT_Y	(TESSreal)0.86052074622010633
          #else
          #define S_UNIT_X	(TESSreal)1.0
          #define S_UNIT_Y	(TESSreal)0.0
          #endif
          #endif*/
        /* Determine the polygon normal and project vertices onto the plane
        * of the polygon.
        */
        projectPolygon_: function() {
          var i, b = this.mesh.vHead, t = [0, 0, 0], m, R, x, C, T = !1;
          for (t[0] = this.normal[0], t[1] = this.normal[1], t[2] = this.normal[2], t[0] === 0 && t[1] === 0 && t[2] === 0 && (this.computeNormal_(t), T = !0), m = this.sUnit, R = this.tUnit, x = this.longAxis_(t), m[x] = 0, m[(x + 1) % 3] = 1, m[(x + 2) % 3] = 0, R[x] = 0, R[(x + 1) % 3] = 0, R[(x + 2) % 3] = t[x] > 0 ? 1 : -1, i = b.next; i !== b; i = i.next)
            i.s = this.dot_(i.coords, m), i.t = this.dot_(i.coords, R);
          for (T && this.checkOrientation_(), C = !0, i = b.next; i !== b; i = i.next)
            C ? (this.bmin[0] = this.bmax[0] = i.s, this.bmin[1] = this.bmax[1] = i.t, C = !1) : (i.s < this.bmin[0] && (this.bmin[0] = i.s), i.s > this.bmax[0] && (this.bmax[0] = i.s), i.t < this.bmin[1] && (this.bmin[1] = i.t), i.t > this.bmax[1] && (this.bmax[1] = i.t));
        },
        addWinding_: function(i, b) {
          i.winding += b.winding, i.Sym.winding += b.Sym.winding;
        },
        /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
        * (what else would it do??)  The region must consist of a single
        * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
        * case means that any vertical line intersects the interior of the
        * region in a single interval.  
        *
        * Tessellation consists of adding interior edges (actually pairs of
        * half-edges), to split the region into non-overlapping triangles.
        *
        * The basic idea is explained in Preparata and Shamos (which I don''t
        * have handy right now), although their implementation is more
        * complicated than this one.  The are two edge chains, an upper chain
        * and a lower chain.  We process all vertices from both chains in order,
        * from right to left.
        *
        * The algorithm ensures that the following invariant holds after each
        * vertex is processed: the untessellated region consists of two
        * chains, where one chain (say the upper) is a single edge, and
        * the other chain is concave.  The left vertex of the single edge
        * is always to the left of all vertices in the concave chain.
        *
        * Each step consists of adding the rightmost unprocessed vertex to one
        * of the two chains, and forming a fan of triangles from the rightmost
        * of two chain endpoints.  Determining whether we can add each triangle
        * to the fan is a simple orientation test.  By making the fan as large
        * as possible, we restore the invariant (check it yourself).
        */
        //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
        tessellateMonoRegion_: function(i, b) {
          var t, m;
          for (t = b.anEdge, W(t.Lnext !== t && t.Lnext.Lnext !== t); c.vertLeq(t.Dst, t.Org); t = t.Lprev)
            ;
          for (; c.vertLeq(t.Org, t.Dst); t = t.Lnext)
            ;
          for (m = t.Lprev; t.Lnext !== m; )
            if (c.vertLeq(t.Dst, m.Org)) {
              for (; m.Lnext !== t && (c.edgeGoesLeft(m.Lnext) || c.edgeSign(m.Org, m.Dst, m.Lnext.Dst) <= 0); ) {
                var R = i.connect(m.Lnext, m);
                m = R.Sym;
              }
              m = m.Lprev;
            } else {
              for (; m.Lnext !== t && (c.edgeGoesRight(t.Lprev) || c.edgeSign(t.Dst, t.Org, t.Lprev.Org) >= 0); ) {
                var R = i.connect(t, t.Lprev);
                t = R.Sym;
              }
              t = t.Lnext;
            }
          for (W(m.Lnext !== t); m.Lnext.Lnext !== t; ) {
            var R = i.connect(m.Lnext, m);
            m = R.Sym;
          }
          return !0;
        },
        /* tessMeshTessellateInterior( mesh ) tessellates each region of
        * the mesh which is marked "inside" the polygon.  Each such region
        * must be monotone.
        */
        //int tessMeshTessellateInterior( TESSmesh *mesh )
        tessellateInterior_: function(i) {
          var b, t;
          for (b = i.fHead.next; b !== i.fHead; b = t)
            if (t = b.next, b.inside && !this.tessellateMonoRegion_(i, b))
              return !1;
          return !0;
        },
        /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
        * which are not marked "inside" the polygon.  Since further mesh operations
        * on NULL faces are not allowed, the main purpose is to clean up the
        * mesh so that exterior loops are not represented in the data structure.
        */
        //void tessMeshDiscardExterior( TESSmesh *mesh )
        discardExterior_: function(i) {
          var b, t;
          for (b = i.fHead.next; b !== i.fHead; b = t)
            t = b.next, b.inside || i.zapFace(b);
        },
        /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
        * winding numbers on all edges so that regions marked "inside" the
        * polygon have a winding number of "value", and regions outside
        * have a winding number of 0.
        *
        * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
        * separate an interior region from an exterior one.
        */
        //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
        setWindingNumber_: function(i, b, t) {
          var m, R;
          for (m = i.eHead.next; m !== i.eHead; m = R)
            R = m.next, m.Rface.inside !== m.Lface.inside ? m.winding = m.Lface.inside ? b : -b : t ? i.delete(m) : m.winding = 0;
        },
        getNeighbourFace_: function(i) {
          return !i.Rface || !i.Rface.inside ? -1 : i.Rface.n;
        },
        outputPolymesh_: function(i, b, t, m) {
          var R, x, C, T = 0, K = 0, J, F;
          for (t > 3 && i.mergeConvexFaces(t), R = i.vHead.next; R !== i.vHead; R = R.next)
            R.n = -1;
          for (x = i.fHead.next; x !== i.fHead; x = x.next)
            if (x.n = -1, !!x.inside) {
              C = x.anEdge, J = 0;
              do
                R = C.Org, R.n === -1 && (R.n = K, K++), J++, C = C.Lnext;
              while (C !== x.anEdge);
              W(J <= t), x.n = T, ++T;
            }
          for (this.elementCount = T, b === s.CONNECTED_POLYGONS && (T *= 2), this.elements = [], this.elements.length = T * t, this.vertexCount = K, this.vertices = [], this.vertices.length = K * m, this.vertexIndices = [], this.vertexIndices.length = K, R = i.vHead.next; R !== i.vHead; R = R.next)
            if (R.n !== -1) {
              var r = R.n * m;
              this.vertices[r + 0] = R.coords[0], this.vertices[r + 1] = R.coords[1], m > 2 && (this.vertices[r + 2] = R.coords[2]), this.vertexIndices[R.n] = R.idx;
            }
          var Y = 0;
          for (x = i.fHead.next; x !== i.fHead; x = x.next)
            if (x.inside) {
              C = x.anEdge, J = 0;
              do
                R = C.Org, this.elements[Y++] = R.n, J++, C = C.Lnext;
              while (C !== x.anEdge);
              for (F = J; F < t; ++F)
                this.elements[Y++] = -1;
              if (b === s.CONNECTED_POLYGONS) {
                C = x.anEdge;
                do
                  this.elements[Y++] = this.getNeighbourFace_(C), C = C.Lnext;
                while (C !== x.anEdge);
                for (F = J; F < t; ++F)
                  this.elements[Y++] = -1;
              }
            }
        },
        //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
        outputContours_: function(i, b) {
          var t, m, R, x = 0, C = 0;
          for (this.vertexCount = 0, this.elementCount = 0, t = i.fHead.next; t !== i.fHead; t = t.next)
            if (t.inside) {
              R = m = t.anEdge;
              do
                this.vertexCount++, m = m.Lnext;
              while (m !== R);
              this.elementCount++;
            }
          this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * b, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
          var T = 0, K = 0, J = 0;
          for (x = 0, t = i.fHead.next; t !== i.fHead; t = t.next)
            if (t.inside) {
              C = 0, R = m = t.anEdge;
              do
                this.vertices[T++] = m.Org.coords[0], this.vertices[T++] = m.Org.coords[1], b > 2 && (this.vertices[T++] = m.Org.coords[2]), this.vertexIndices[K++] = m.Org.idx, C++, m = m.Lnext;
              while (m !== R);
              this.elements[J++] = x, this.elements[J++] = C, x += C;
            }
        },
        addContour: function(i, b) {
          var t, m;
          for (this.mesh === null && (this.mesh = new G()), i < 2 && (i = 2), i > 3 && (i = 3), t = null, m = 0; m < b.length; m += i)
            t === null ? (t = this.mesh.makeEdge(), this.mesh.splice(t, t.Sym)) : (this.mesh.splitEdge(t), t = t.Lnext), t.Org.coords[0] = b[m + 0], t.Org.coords[1] = b[m + 1], i > 2 ? t.Org.coords[2] = b[m + 2] : t.Org.coords[2] = 0, t.Org.idx = this.vertexIndexCounter++, t.winding = 1, t.Sym.winding = -1;
        },
        //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
        tesselate: function(i, b, t, m, R) {
          if (this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, R && (this.normal[0] = R[0], this.normal[1] = R[1], this.normal[2] = R[2]), this.windingRule = i, m < 2 && (m = 2), m > 3 && (m = 3), !this.mesh)
            return !1;
          this.projectPolygon_(), X.computeInterior(this);
          var x = this.mesh;
          return b === s.BOUNDARY_CONTOURS ? this.setWindingNumber_(x, 1, !0) : this.tessellateInterior_(x), x.check(), b === s.BOUNDARY_CONTOURS ? this.outputContours_(x, m) : this.outputPolymesh_(x, b, t, m), !0;
        }
      };
    },
    /* 62 */
    /***/
    function(Z, d) {
      Z.exports = s;
      var l = Object.prototype.hasOwnProperty;
      function s() {
        for (var c = {}, W = 0; W < arguments.length; W++) {
          var u = arguments[W];
          for (var e in u)
            l.call(u, e) && (c[e] = u[e]);
        }
        return c;
      }
    },
    /* 63 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "createShaders", function() {
        return n;
      }), l.d(d, "applyShader", function() {
        return G;
      }), l.d(d, "createCloudShaders", function() {
        return a;
      }), l.d(d, "applyCloudShader", function() {
        return I;
      });
      var s = l(64), c = l(65), W = l(66), u = l(67);
      l(1).glMatrix.setMatrixArrayType(Array);
      const e = Symbol("shaders");
      function n(h) {
        h[e] = [];
        for (let S = 0; S < 16; S++) {
          const p = [], X = !!(S & 1), V = !!(S & 2), i = !!(S & 4), b = !!(S & 8);
          X && p.push("#define TEXTURE 1"), V && p.push("#define FILTER 1"), i && p.push("#define GRADIENT 1"), b && p.push("#define CLIPPATH 1");
          const t = `${p.join(`
`)}
`, m = [];
          X && m.push("uniform sampler2D u_texSampler;"), b && m.push("uniform sampler2D u_clipSampler;"), h[e][S] = [t + m.join(`
`) + c.default, t + s.default];
        }
      }
      function G(h, {
        hasTexture: S = !1,
        hasFilter: p = !1,
        hasGradient: X = !1,
        hasClipPath: V = !1
      } = {}) {
        const i = S | p << 1 | X << 2 | V << 3;
        let b = h[e][i];
        Array.isArray(b) && (b = h.createProgram(...b), h[e][i] = b), h.program !== b && h.useProgram(b, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          }
        });
      }
      const y = [];
      function a(h) {
        for (let S = 0; S < 64; S++) {
          const p = [], X = !!(S & 1), V = !!(S & 2), i = !!(S & 4), b = !!(S & 8), t = !!(S & 16), m = !!(S & 32);
          X && p.push("#define TEXTURE 1"), V && p.push("#define FILTER 1"), i && p.push("#define GRADIENT 1"), b && p.push("#define CLOUDCOLOR 1"), t && p.push("#define CLOUDFILTER 1"), m && p.push("#define CLIPPATH 1");
          const R = `${p.join(`
`)}
`, x = [];
          if (X) {
            x.push("uniform sampler2D u_texSampler;");
            for (let C = 0; C < 12; C++)
              x.push(`uniform sampler2D u_texFrame${C};`);
          }
          m && x.push("uniform sampler2D u_clipSampler;"), y[S] = [R + x.join(`
`) + u.default, R + W.default];
        }
      }
      function I(h, {
        hasTexture: S = !1,
        hasFilter: p = !1,
        hasGradient: X = !1,
        hasCloudColor: V = !1,
        hasCloudFilter: i = !1,
        hasClipPath: b = !1
      } = {}) {
        const t = S | p << 1 | X << 2 | V << 3 | i << 4 | b << 5;
        let m = y[t];
        Array.isArray(m) && (m = h.createProgram(...m), y[t] = m), h.program !== m && h.useProgram(m, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_fillCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_strokeCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_frameIndex: {
            type: "UNSIGNED_BYTE",
            normalize: !1
          }
        });
      }
    },
    /* 64 */
    /***/
    function(Z, d, l) {
      l.r(d), d.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;
  vColor = a_color;

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif
}`;
    },
    /* 65 */
    /***/
    function(Z, d, l) {
      l.r(d), d.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;
// uniform float u_radialGradientVector[6];

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

#ifdef FILTER
void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      vec4 texColor = texture2D(u_texSampler, texCoord.xy);
      float alpha = texColor.a;
      if(opacity < 1.0) {
        texColor.a *= opacity;
        alpha *= mix(0.465, 1.0, opacity);
      }
      // color = mix(color, texColor, texColor.a);
      color.rgb = mix(color.rgb, texColor.rgb, alpha);
      // color.rgb = mix(texColor.rgb, color.rgb, color.a);
      color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
      color.a = texColor.a + (1.0 - texColor.a) * color.a;
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 66 */
    /***/
    function(Z, d, l) {
      l.r(d), d.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
attribute vec3 a_transform0;
attribute vec3 a_transform1;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute float a_frameIndex;
varying float frameIndex;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef CLOUDFILTER
attribute vec4 a_colorCloud0;
attribute vec4 a_colorCloud1;
attribute vec4 a_colorCloud2;
attribute vec4 a_colorCloud3;
attribute vec4 a_colorCloud4;
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef CLOUDCOLOR
attribute vec4 a_fillCloudColor;
attribute vec4 a_strokeCloudColor;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  mat3 modelMatrix = mat3(
    a_transform0.x, a_transform1.x, 0, 
    a_transform0.y, a_transform1.y, 0,
    a_transform0.z, a_transform1.z, 1
  );

  vec3 pos = projectionMatrix * viewMatrix * modelMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;

#ifdef CLOUDCOLOR
  if(flagBackground > 0.0) {
    vColor = mix(a_color, a_fillCloudColor, a_fillCloudColor.a);
  } else {
    vColor = mix(a_color, a_strokeCloudColor, a_strokeCloudColor.a);
  }
#else
  vColor = a_color;
#endif

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  frameIndex = a_frameIndex;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif

#ifdef CLOUDFILTER
  colorCloud0 = a_colorCloud0;
  colorCloud1 = a_colorCloud1;
  colorCloud2 = a_colorCloud2;
  colorCloud3 = a_colorCloud3;
  colorCloud4 = a_colorCloud4;
#endif
}`;
    },
    /* 67 */
    /***/
    function(Z, d, l) {
      l.r(d), d.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying float frameIndex;
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef CLOUDFILTER
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}

#ifdef CLOUDFILTER
void buildCloudColor(inout float colorCloudMatrix[20]) {
  colorCloudMatrix[0] = colorCloud0[0];
  colorCloudMatrix[1] = colorCloud1[0];
  colorCloudMatrix[2] = colorCloud2[0];
  colorCloudMatrix[3] = colorCloud3[0];
  colorCloudMatrix[4] = colorCloud4[0];

  colorCloudMatrix[5] = colorCloud0[1];
  colorCloudMatrix[6] = colorCloud1[1];
  colorCloudMatrix[7] = colorCloud2[1];
  colorCloudMatrix[8] = colorCloud3[1];
  colorCloudMatrix[9] = colorCloud4[1];

  colorCloudMatrix[10] = colorCloud0[2];
  colorCloudMatrix[11] = colorCloud1[2];
  colorCloudMatrix[12] = colorCloud2[2];
  colorCloudMatrix[13] = colorCloud3[2];
  colorCloudMatrix[14] = colorCloud4[2];

  colorCloudMatrix[15] = colorCloud0[3];
  colorCloudMatrix[16] = colorCloud1[3];
  colorCloudMatrix[17] = colorCloud2[3];
  colorCloudMatrix[18] = colorCloud3[3];
  colorCloudMatrix[19] = colorCloud4[3];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      if(frameIndex < 0.0) {
        vec4 texColor = texture2D(u_texSampler, texCoord.xy);
        color = mix(color, texColor, texColor.a);
      } else {
        int index = int(floor(clamp(0.0, 11.0, frameIndex)));
        vec4 texColor;
        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);
        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);
        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);
        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);
        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);
        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);
        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);
        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);
        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);
        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);
        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);
        else texColor = texture2D(u_texFrame11, texCoord.xy);
        float alpha = texColor.a;
        if(opacity < 1.0) {
          texColor.a *= opacity;
          alpha *= mix(0.465, 1.0, opacity);
        }
        // color = mix(color, texColor, texColor.a);
        color.rgb = mix(color.rgb, texColor.rgb, alpha);
        // color.rgb = mix(texColor.rgb, color.rgb, color.a);
        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
        color.a = texColor.a + (1.0 - texColor.a) * color.a;
      }
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLOUDFILTER
  float colorCloudMatrix[20];
  buildCloudColor(colorCloudMatrix);
  transformColor(color, colorCloudMatrix);
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 68 */
    /***/
    function(Z, d, l) {
      l.r(d), (function(s, c) {
        l.d(d, "requestAnimationFrame", function() {
          return u;
        }), l.d(d, "cancelAnimationFrame", function() {
          return e;
        }), l(1).glMatrix.setMatrixArrayType(Array);
        function W() {
          if (typeof performance < "u" && performance.now)
            return performance.now();
          if (typeof s < "u" && s.hrtime) {
            const [n, G] = s.hrtime();
            return n * 1e3 + G * 1e-6;
          }
          return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
        }
        let u, e;
        typeof c < "u" && typeof c.requestAnimationFrame == "function" ? (u = c.requestAnimationFrame, e = c.cancelAnimationFrame) : (u = function(n) {
          return setTimeout(() => {
            n(W());
          }, 16);
        }, e = function(n) {
          return clearTimeout(n);
        });
      }).call(this, l(69), l(22));
    },
    /* 69 */
    /***/
    function(Z, d) {
      var l = Z.exports = {}, s, c;
      function W() {
        throw new Error("setTimeout has not been defined");
      }
      function u() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? s = setTimeout : s = W;
        } catch {
          s = W;
        }
        try {
          typeof clearTimeout == "function" ? c = clearTimeout : c = u;
        } catch {
          c = u;
        }
      })();
      function e(V) {
        if (s === setTimeout)
          return setTimeout(V, 0);
        if ((s === W || !s) && setTimeout)
          return s = setTimeout, setTimeout(V, 0);
        try {
          return s(V, 0);
        } catch {
          try {
            return s.call(null, V, 0);
          } catch {
            return s.call(this, V, 0);
          }
        }
      }
      function n(V) {
        if (c === clearTimeout)
          return clearTimeout(V);
        if ((c === u || !c) && clearTimeout)
          return c = clearTimeout, clearTimeout(V);
        try {
          return c(V);
        } catch {
          try {
            return c.call(null, V);
          } catch {
            return c.call(this, V);
          }
        }
      }
      var G = [], y = !1, a, I = -1;
      function h() {
        !y || !a || (y = !1, a.length ? G = a.concat(G) : I = -1, G.length && S());
      }
      function S() {
        if (!y) {
          var V = e(h);
          y = !0;
          for (var i = G.length; i; ) {
            for (a = G, G = []; ++I < i; )
              a && a[I].run();
            I = -1, i = G.length;
          }
          a = null, y = !1, n(V);
        }
      }
      l.nextTick = function(V) {
        var i = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var b = 1; b < arguments.length; b++)
            i[b - 1] = arguments[b];
        G.push(new p(V, i)), G.length === 1 && !y && e(S);
      };
      function p(V, i) {
        this.fun = V, this.array = i;
      }
      p.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, l.title = "browser", l.browser = !0, l.env = {}, l.argv = [], l.version = "", l.versions = {};
      function X() {
      }
      l.on = X, l.addListener = X, l.once = X, l.off = X, l.removeListener = X, l.removeAllListeners = X, l.emit = X, l.prependListener = X, l.prependOnceListener = X, l.listeners = function(V) {
        return [];
      }, l.binding = function(V) {
        throw new Error("process.binding is not supported");
      }, l.cwd = function() {
        return "/";
      }, l.chdir = function(V) {
        throw new Error("process.chdir is not supported");
      }, l.umask = function() {
        return 0;
      };
    },
    /* 70 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return C;
      });
      var s = l(1), c = l(71), W = l(73), u = l(213), e = l(214), n = l(215), G = l(216);
      l(1).glMatrix.setMatrixArrayType(Array);
      function y(T, K) {
        var J = Object.keys(T);
        if (Object.getOwnPropertySymbols) {
          var F = Object.getOwnPropertySymbols(T);
          K && (F = F.filter(function(r) {
            return Object.getOwnPropertyDescriptor(T, r).enumerable;
          })), J.push.apply(J, F);
        }
        return J;
      }
      function a(T) {
        for (var K = 1; K < arguments.length; K++) {
          var J = arguments[K] != null ? arguments[K] : {};
          K % 2 ? y(Object(J), !0).forEach(function(F) {
            I(T, F, J[F]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(T, Object.getOwnPropertyDescriptors(J)) : y(Object(J)).forEach(function(F) {
            Object.defineProperty(T, F, Object.getOwnPropertyDescriptor(J, F));
          });
        }
        return T;
      }
      function I(T, K, J) {
        return K in T ? Object.defineProperty(T, K, { value: J, enumerable: !0, configurable: !0, writable: !0 }) : T[K] = J, T;
      }
      const h = Symbol.for("spritejs_changedAttrs"), S = Symbol.for("spritejs_attributes"), p = Symbol("resolution"), X = Symbol("animations"), V = Symbol("eventListeners"), i = Symbol("captureEventListeners"), b = Symbol("filters"), t = Symbol("display"), m = Symbol("program"), R = Symbol("shaderAttrs"), x = Symbol("uniforms");
      class C {
        constructor(K = {}) {
          this.attributes = new this.constructor.Attr(this), this[p] = {
            width: 300,
            height: 150
          }, Object.assign(this.attributes, K), this[X] = /* @__PURE__ */ new Set(), this[V] = {}, this[i] = {};
        }
        get ancestors() {
          let K = this.parent;
          const J = [];
          for (; K; )
            J.push(K), K = K.parent;
          return J;
        }
        get animations() {
          return this[X];
        }
        get filters() {
          return this[b] || this.parent && this.parent.filters;
        }
        get isVisible() {
          return !1;
        }
        get layer() {
          return this.parent ? this.parent.layer : null;
        }
        get localMatrix() {
          const K = this.transformMatrix, {
            x: J,
            y: F
          } = this.attributes;
          return K[4] += J, K[5] += F, K;
        }
        get opacity() {
          let K = this.attributes.opacity;
          return this.parent && this.parent.opacity != null && (K *= this.parent.opacity), K;
        }
        get parentNode() {
          return this.parent;
        }
        get nextSibling() {
          return this.getNodeNearBy(1);
        }
        get previousSibling() {
          return this.getNodeNearBy(-1);
        }
        get program() {
          return this[m];
        }
        /* get parent defined by connect method */
        get renderer() {
          return this.parent ? this.parent.renderer : null;
        }
        get renderMatrix() {
          if (this.__cacheRenderMatrix)
            return this.__cacheRenderMatrix;
          let K = this.localMatrix;
          const J = this.parent;
          if (J) {
            const F = J.__cacheRenderMatrix || J.renderMatrix;
            F && (K = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), F, K));
          }
          return K;
        }
        get worldScaling() {
          const K = this.renderMatrix;
          return [Math.hypot(K[0], K[1]), Math.hypot(K[2], K[3])];
        }
        get worldRotation() {
          const K = this.renderMatrix;
          return Math.atan2(K[1], K[3]);
        }
        get worldPosition() {
          const K = this.renderMatrix;
          return [K[4], K[5]];
        }
        get uniforms() {
          return this[x];
        }
        /* get zOrder defined by connect method */
        /* attributes */
        get className() {
          return this.attributes.className;
        }
        set className(K) {
          this.attributes.className = K;
        }
        get id() {
          return this.attributes.id;
        }
        set id(K) {
          this.attributes.id = K;
        }
        get name() {
          return this.attributes.name;
        }
        set name(K) {
          this.attributes.name = K;
        }
        get zIndex() {
          return this.attributes.zIndex;
        }
        set zIndex(K) {
          this.attributes.zIndex = K;
        }
        get mesh() {
          return null;
        }
        get shaderAttrs() {
          return this[R] || {};
        }
        activateAnimations() {
          const K = this.layer;
          if (K) {
            const J = this[X];
            J.forEach((r) => {
              r.baseTimeline = K.timeline, r.play(), r.finished.then(() => {
                J.delete(r);
              });
            });
            const F = this.children;
            F && F.forEach((r) => {
              r.activateAnimations && r.activateAnimations();
            });
          }
        }
        addEventListener(K, J, F = {}) {
          K === "mousewheel" && (K = "wheel"), typeof F == "boolean" && (F = {
            capture: F
          });
          const {
            capture: r,
            once: Y
          } = F, H = r ? i : V;
          return this[H][K] = this[H][K] || [], this[H][K].push({
            listener: J,
            once: Y
          }), this;
        }
        animate(K, J) {
          const F = new W.default(this, K, J);
          return this.effects && F.applyEffects(this.effects), this.layer && (F.baseTimeline = this.layer.timeline, F.play(), F.finished.then(() => {
            this[X].delete(F);
          })), this[X].add(F), F;
        }
        attr(...K) {
          if (K.length === 0)
            return this.attributes[S];
          if (K.length > 1) {
            let [J, F] = K;
            return typeof F == "function" && (F = F(this.attr(J))), this.setAttribute(J, F), this;
          }
          return typeof K[0] == "string" ? this.getAttribute(K[0]) : (Object.assign(this.attributes, K[0]), this);
        }
        cloneNode() {
          const K = new this.constructor(), J = this.attributes[h];
          return K.attr(J), K;
        }
        connect(K, J) {
          Object.defineProperty(this, "parent", {
            value: K,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: J,
            writable: !1,
            configurable: !0
          }), K.timeline && this.activateAnimations(), this.setResolution(K.getResolution()), this.forceUpdate(), this.dispatchEvent({
            type: "append",
            detail: {
              parent: K,
              zOrder: J
            }
          });
        }
        contains(K) {
          for (; K && this !== K; )
            K = K.parent;
          return !!K;
        }
        deactivateAnimations() {
          this[X].forEach((J) => J.cancel());
          const K = this.children;
          K && K.forEach((J) => {
            J.deactivateAnimations && J.deactivateAnimations();
          });
        }
        disconnect() {
          const {
            parent: K,
            zOrder: J
          } = this;
          delete this.parent, delete this.zOrder, this.deactivateAnimations(), this.dispatchEvent({
            type: "remove",
            detail: {
              parent: K,
              zOrder: J
            }
          }), K && K.forceUpdate();
        }
        dispatchEvent(K) {
          K instanceof e.default || (K = new e.default(K)), K.target = this;
          let J = K.type;
          J === "mousewheel" && (J = "wheel");
          const F = [this];
          let r = this.parent;
          for (; K.bubbles && r; )
            F.push(r), r = r.parent;
          for (let Y = F.length - 1; Y >= 0; Y--) {
            const H = F[Y], Q = H[i] && H[i][J];
            if (Q && Q.length && (K.currentTarget = H, Q.forEach(({
              listener: w,
              once: O
            }) => {
              w.call(this, K), O && F.removeEventListener(w);
            }), delete K.currentTarget), !K.bubbles && K.cancelBubble)
              break;
          }
          if (!K.cancelBubble)
            for (let Y = 0; Y < F.length; Y++) {
              const H = F[Y], Q = H[V] && H[V][J];
              if (Q && Q.length && (K.currentTarget = H, Q.forEach(({
                listener: w,
                once: O
              }) => {
                w.call(this, K), O && F.removeEventListener(w);
              }), delete K.currentTarget), !K.bubbles || K.cancelBubble)
                break;
            }
        }
        dispatchPointerEvent(K) {
          const {
            layerX: J,
            layerY: F
          } = K;
          return this.isPointCollision(J, F) ? (this.dispatchEvent(K), !0) : !1;
        }
        draw(K = []) {
          const J = this.mesh;
          if (J) {
            if (Object(n.applyFilters)(J, this.filters), K.push(J), this[m]) {
              J.setProgram(this[m]);
              const F = this[R];
              F && Object.entries(F).forEach(([Y, H]) => {
                J.setAttribute(Y, H);
              });
              const r = this[x];
              if (this[x]) {
                const Y = {};
                Object.entries(r).forEach(([H, Q]) => {
                  typeof Q == "function" && (Q = Q(this, H)), Y[H] = Q;
                }), J.setUniforms(Y);
              }
            }
            Object(G.default)(this, J);
          }
          return K;
        }
        forceUpdate() {
          this.parent && this.parent.forceUpdate();
        }
        getAttribute(K) {
          return this.attributes[K];
        }
        getListeners(K, {
          capture: J = !1
        } = {}) {
          return [...this[J ? i : V][K] || []];
        }
        getNodeNearBy(K = 1) {
          if (!this.parent)
            return null;
          if (K === 0)
            return this;
          const J = this.parent.children, F = J.indexOf(this);
          return J[F + K];
        }
        getWorldPosition(K, J) {
          const F = this.renderMatrix, r = K * F[0] + J * F[2] + F[4], Y = K * F[1] + J * F[3] + F[5];
          return [r, Y];
        }
        getOffsetPosition(K, J) {
          const F = s.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this.renderMatrix), r = K * F[0] + J * F[2] + F[4], Y = K * F[1] + J * F[3] + F[5];
          return [r, Y];
        }
        getResolution() {
          return a({}, this[p]);
        }
        isPointCollision(K, J) {
          if (!this.mesh)
            return !1;
          const F = this.attributes.pointerEvents;
          if (F === "none" || F !== "all" && !this.isVisible)
            return !1;
          let r = "both";
          return F === "visibleFill" && (r = "fill"), F === "visibleStroke" && (r = "stroke"), this.mesh.isPointCollision(K, J, r);
        }
        onPropertyChange(K, J, F) {
          K !== "id" && K !== "name" && K !== "className" && K !== "pointerEvents" && K !== "passEvents" && this.forceUpdate(), K === "filter" && (this[b] = Object(n.parseFilterString)(J)), K === "zIndex" && this.parent && this.parent.reorder();
        }
        setAttribute(K, J) {
          K === "attrs" && this.attr(J), this.attributes[K] = J;
        }
        setMouseCapture() {
          this.layer && (this.layer.__mouseCapturedTarget = this);
        }
        // layer.renderer.createProgram(fragmentShader, vertexShader, attributeOptions)
        setProgram(K) {
          this[m] = K, this.forceUpdate();
        }
        setShaderAttribute(K, J) {
          this[R] = this[R] || {}, this[R][K] = J, this.forceUpdate();
        }
        setUniforms(K) {
          this[x] = this[x] || {}, Object.assign(this[x], K), this.forceUpdate();
        }
        setResolution({
          width: K,
          height: J
        }) {
          const {
            width: F,
            height: r
          } = this[p];
          (F !== K || r !== J) && (this[p] = {
            width: K,
            height: J
          }, this.forceUpdate(), this.dispatchEvent({
            type: "resolutionchange",
            detail: {
              width: K,
              height: J
            }
          }));
        }
        show() {
          this.attributes.display === "none" && (this.attributes.display = this[t] || "");
        }
        hide() {
          this.attributes.display !== "none" && (this[t] = this.attributes.display, this.attributes.display = "none");
        }
        releaseMouseCapture() {
          this.layer && this.layer.__mouseCapturedTarget === this && (this.layer.__mouseCapturedTarget = null);
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        removeAllListeners(K, J = {}) {
          typeof J == "boolean" && (J = {
            capture: J
          });
          const r = J.capture ? i : V;
          return this[r][K] && (this[r][K] = []), this;
        }
        removeAttribute(K) {
          this.setAttribute(K, null);
        }
        removeEventListener(K, J, F = {}) {
          typeof F == "boolean" && (F = {
            capture: F
          });
          const Y = F.capture ? i : V;
          if (this[Y][K]) {
            const H = this[Y][K];
            if (H)
              for (let Q = 0; Q < H.length; Q++) {
                const {
                  listener: w
                } = H[Q];
                if (w === J) {
                  this[Y][K].splice(Q, 1);
                  break;
                }
              }
          }
          return this;
        }
        transition(K, J = "linear") {
          const F = this, r = Symbol("animation");
          J = J || "linear";
          let Y = 0;
          return typeof K == "object" && (Y = K.delay || 0, K = K.duration), {
            [r]: null,
            cancel(H = !1) {
              const Q = this[r];
              Q && Q.cancel(H);
            },
            end() {
              const H = this[r];
              H && (H.playState === "running" || H.playState === "pending") && H.finish();
            },
            reverse() {
              const H = this[r];
              if (H)
                if (H.playState === "running" || H.playState === "pending")
                  H.playbackRate = -H.playbackRate;
                else {
                  const Q = H.timing.direction;
                  H.timing.direction = Q === "reverse" ? "normal" : "reverse", H.play();
                }
              return H.finished;
            },
            attr(H, Q) {
              return this.end(), typeof H == "string" && (H = {
                [H]: Q
              }), Object.entries(H).forEach(([w, O]) => {
                typeof O == "function" && (H[w] = O(F.attr(w)));
              }), this[r] = F.animate([H], {
                duration: K * 1e3,
                delay: Y * 1e3,
                fill: "forwards",
                easing: J
              }), this[r].finished;
            }
          };
        }
        updateContours() {
        }
      }
      I(C, "Attr", c.default), u.default.registerNode(C, "node");
    },
    /* 71 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return C;
      });
      var s = l(1), c = l(12), W = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const u = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_declareAlias"), n = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), y = Symbol.for("spritejs_attributes"), a = Symbol.for("spritejs_changedAttrs"), I = Symbol("subject"), h = Symbol("attr"), S = Symbol("default"), p = Symbol("alias");
      function X(T, [K, J]) {
        let F = s.mat2d.fromValues(1, 0, 0, 1, 0, 0);
        return [...T].forEach(([r, Y]) => {
          if ((K || J) && (F = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [K, J])), r === "matrix")
            F = s.mat2d.multiply(F, F, Y);
          else if (r === "offsetTranslate")
            F[4] += Y[0], F[5] += Y[1];
          else if (r === "offsetRotate")
            F = s.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), F, Y);
          else if (r === "skew") {
            const [H, Q] = Y;
            F = s.mat2d.multiply(F, F, s.mat2d.fromValues(1, Math.tan(Q), Math.tan(H), 1, 0, 0));
          } else
            s.mat2d[r](F, F, Y);
          (K || J) && (F = s.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), F, [-K, -J]));
        }), F;
      }
      const V = Symbol("transformMatrix"), i = Symbol("transforms"), b = Symbol("changedAttrs"), t = Symbol("lastChangedAttr"), m = Symbol("offsetFigure");
      function R(T, K, J) {
        const F = T[h][K];
        if (T[n](K, J, !1) || T[t] !== K) {
          const Y = T[i];
          Y.has(K) && Y.delete(K), J && (K === "rotate" && (J = Math.PI * J / 180), K === "scale" && (J = J.map((H) => Math.abs(H) > 1e-5 ? H : 1 / H > 0 ? 1e-5 : -1e-5)), Y.set(K, J)), T[V] = null, T[I].onPropertyChange(K, J, F, T);
        }
      }
      function x(T) {
        const K = T[m], J = T.offsetDistance * K.getTotalLength(), F = K.getPointAtLength(J);
        if (F) {
          const r = T[i];
          let Y = T.offsetRotate;
          Y === "auto" ? Y = F.angle : Y === "reverse" ? Y = Math.PI + F.angle : Y = Math.PI * Y / 180, r.set("offsetRotate", Y), r.set("offsetTranslate", [F.x, F.y]), T[V] = null;
        }
      }
      class C {
        static setDefault(K, ...J) {
          return K[u](...J);
        }
        static declareAlias(K, ...J) {
          return K[e](...J);
        }
        static setAttribute(K, ...J) {
          return K[n](...J);
        }
        static getAttribute(K, ...J) {
          return K[G](...J);
        }
        static getAttributes(K) {
          return K[y];
        }
        static getChangedAttributes(K) {
          return K[a];
        }
        constructor(K) {
          this[I] = K, this[h] = {}, this[V] = s.mat2d.fromValues(1, 0, 0, 1, 0, 0), this[i] = /* @__PURE__ */ new Map(), this[S] = {}, this[p] = [], Object.defineProperty(K, "transformMatrix", {
            get: () => (this[V] || (this[V] = X(this[i], this.transformOrigin)), [...this[V]])
          }), this[u]({
            id: "",
            name: "",
            className: "",
            /* class */
            x: 0,
            y: 0,
            /* pos */
            transformOrigin: [0, 0],
            transform: "",
            translate: [0, 0],
            rotate: 0,
            scale: [1, 1],
            skew: [0, 0],
            opacity: 1,
            zIndex: 0,
            offsetPath: void 0,
            offsetDistance: 0,
            offsetRotate: "auto",
            pointerEvents: "visible",
            // none | visible | visibleFill | visibleStroke | all
            filter: "none",
            display: ""
          }), this[e]("class", "pos"), this[b] = /* @__PURE__ */ new Set(), this[m] = new c.Figure2D({
            scale: 5,
            simplify: 0
          });
        }
        get [a]() {
          const K = {};
          return [...this[b]].forEach((J) => {
            K[J] = this[h][J];
          }), K;
        }
        get [y]() {
          const K = Object.assign({}, this[h]);
          for (let J = 0; J < this[p].length; J++) {
            const F = this[p][J];
            K[F] = this[F];
          }
          return K;
        }
        [u](K) {
          Object.assign(this[S], K), Object.assign(this[h], K);
        }
        [e](...K) {
          this[p].push(...K);
        }
        [n](K, J, F = !0) {
          const r = this[h][K], Y = this[I];
          return J == null && (J = this[S][K]), Object(W.compareValue)(r, J) ? !1 : (this[h][K] = J, this[b].has(K) && this[b].delete(K), this[b].add(K), this[t] = K, F && Y.onPropertyChange(K, J, r, this), !0);
        }
        [G](K) {
          return this[h][K];
        }
        set id(K) {
          this[n]("id", K);
        }
        get id() {
          return this[G]("id");
        }
        set name(K) {
          this[n]("name", K);
        }
        get name() {
          return this[G]("name");
        }
        set className(K) {
          this[n]("className", K);
        }
        get className() {
          return this[G]("className");
        }
        set class(K) {
          this.className = K;
        }
        get class() {
          return this.className;
        }
        get x() {
          return this[G]("x");
        }
        set x(K) {
          this[n]("x", Object(W.toNumber)(K));
        }
        get y() {
          return this[G]("y");
        }
        set y(K) {
          this[n]("y", Object(W.toNumber)(K));
        }
        get pos() {
          return [this.x, this.y];
        }
        set pos(K) {
          K = Object(W.toArray)(K), Array.isArray(K) || (K = [K, K]), this.x = K[0], this.y = K[1];
        }
        get transform() {
          return this[G]("transform");
        }
        set transform(K) {
          let J = null;
          if (Array.isArray(K) && (J = K, K = `matrix(${K.map(W.toNumber).join()})`), typeof K == "string")
            K = K.replace(/\s*,\s*/g, ",");
          else if (K != null)
            throw new TypeError("Invalid transform value.");
          const F = this[h].transform;
          if (this[n]("transform", K, !1)) {
            const r = this[i];
            if (r.has("matrix") && r.delete("matrix"), J)
              r.set("matrix", J);
            else if (K) {
              const Y = K.match(/(matrix|translate|rotate|scale|skew)\([^()]+\)/g);
              if (Y) {
                let H = s.mat2d.fromValues(1, 0, 0, 1, 0, 0);
                for (let Q = 0; Q < Y.length; Q++) {
                  const O = Y[Q].match(/^(matrix|translate|rotate|scale|skew)\(([^()]+)\)/);
                  if (O) {
                    let [, q, k] = O;
                    q === "rotate" ? k = Math.PI * parseFloat(k) / 180 : k = k.trim().split(/[\s,]+/).map((P) => Object(W.toNumber)(P)), q === "matrix" ? H = s.mat2d.multiply(H, H, k) : q === "skew" ? H = s.mat2d.multiply(H, H, s.mat2d.fromValues(1, Math.tan(k[1]), Math.tan(k[0]), 1, 0, 0)) : s.mat2d[q](H, H, k), r.set("matrix", H);
                  }
                }
              } else
                throw new TypeError("Invalid transform value.");
            }
            this[V] = null, this[I].onPropertyChange("transform", K, F, this);
          }
        }
        get transformOrigin() {
          return this[G]("transformOrigin");
        }
        set transformOrigin(K) {
          K = Object(W.toArray)(K, !0), K != null && !Array.isArray(K) && (K = [K, K]), this[n]("transformOrigin", K) && (this[V] = null);
        }
        get rotate() {
          return this[G]("rotate");
        }
        set rotate(K) {
          R(this, "rotate", K);
        }
        get translate() {
          return this[G]("translate");
        }
        set translate(K) {
          K = Object(W.toArray)(K, !0), K != null && !Array.isArray(K) && (K = [K, K]), R(this, "translate", K);
        }
        get scale() {
          return this[G]("scale");
        }
        set scale(K) {
          K = Object(W.toArray)(K, !0), K != null && !Array.isArray(K) && (K = [K, K]), R(this, "scale", K);
        }
        get skew() {
          return this[G]("skew");
        }
        set skew(K) {
          K = Object(W.toArray)(K, !0), K != null && !Array.isArray(K) && (K = [K, K]), R(this, "skew", K);
        }
        get opacity() {
          return this[G]("opacity");
        }
        set opacity(K) {
          K != null && (K = Number(K)), this[n]("opacity", K);
        }
        get zIndex() {
          return this[G]("zIndex");
        }
        set zIndex(K) {
          K != null && (K = Number(K)), this[n]("zIndex", K);
        }
        get offsetPath() {
          return this[G]("offsetPath");
        }
        set offsetPath(K) {
          this[n]("offsetPath", K) && (this[m].beginPath(), K != null && this[m].addPath(K), x(this));
        }
        get offsetDistance() {
          return this[G]("offsetDistance");
        }
        set offsetDistance(K) {
          this[n]("offsetDistance", Object(W.toNumber)(K)) && x(this);
        }
        get offsetRotate() {
          return this[G]("offsetRotate");
        }
        set offsetRotate(K) {
          this[n]("offsetRotate", K), x(this);
        }
        get pointerEvents() {
          return this[G]("pointerEvents");
        }
        set pointerEvents(K) {
          if (K != null && K !== "none" && K !== "visible" && K !== "visibleFill" && K !== "visibleStroke" && K !== "all")
            throw new TypeError("Invalid pointerEvents type.");
          this[n]("pointerEvents", K);
        }
        get filter() {
          return this[G]("filter");
        }
        set filter(K) {
          this[n]("filter", K);
        }
        get display() {
          return this[G]("display");
        }
        set display(K) {
          this[n]("display", K);
        }
        /* istanbul ignore next */
        set offset(K) {
        }
      }
    },
    /* 72 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "sizeToPixel", function() {
        return s;
      }), l.d(d, "toString", function() {
        return c;
      }), l.d(d, "toNumber", function() {
        return W;
      }), l.d(d, "toArray", function() {
        return u;
      }), l.d(d, "compareValue", function() {
        return e;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s(n, G) {
        const y = n.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/);
        y ? n = {
          size: parseFloat(y[1]),
          unit: y[2]
        } : n = {
          size: parseFloat(n),
          unit: "px"
        };
        let {
          size: a,
          unit: I
        } = n;
        if (I === "pt")
          a /= 0.75;
        else if (I === "pc")
          a *= 16;
        else if (I === "in")
          a *= 96;
        else if (I === "cm")
          a *= 96 / 2.54;
        else if (I === "mm")
          a *= 96 / 25.4;
        else if (I === "em" || I === "rem" || I === "ex") {
          if (!G && typeof getComputedStyle == "function" && typeof document < "u") {
            const h = getComputedStyle(document.documentElement).fontSize;
            h ? G = s(h, 16) : G = 16;
          }
          a *= G, I === "ex" && (a /= 2);
        } else if (I === "q")
          a *= 96 / 25.4 / 4;
        else if (I === "vw" || I === "vh") {
          if (typeof document < "u") {
            const h = I === "vw" ? window.innerWidth || document.documentElement.clientWidth : window.innerHeight || document.documentElement.clientHeight;
            a *= h / 100;
          }
        } else if ((I === "vmax" || I === "vmin") && typeof document < "u") {
          const h = window.innerWidth || document.documentElement.clientWidth, S = window.innerHeight || document.documentElement.clientHeight;
          I === "vmax" ? a *= Math.max(h, S) / 100 : a *= Math.min(h, S) / 100;
        }
        return a;
      }
      function c(n) {
        return n == null ? n : String(n);
      }
      function W(n) {
        if (n == null)
          return n;
        if (typeof n == "string" && (n = s(n)), !Number.isFinite(n))
          throw new TypeError("Invalid value");
        return n;
      }
      function u(n, G = !1) {
        return n === "" ? null : (typeof n == "string" && (n = n.split(/[\s,]+/g)), Array.isArray(n) && (G && (n = n.map(W)), n.length === 1) ? n[0] : n);
      }
      function e(n, G) {
        if (Array.isArray(n) && Array.isArray(G)) {
          if (n.length !== G.length)
            return !1;
          for (let y = 0; y < n.length; y++)
            if (n[y] !== G[y])
              return !1;
          return !0;
        }
        return n == null && G == null || n === G;
      }
    },
    /* 73 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return I;
      });
      var s = l(74), c = l(32), W = /* @__PURE__ */ l.n(c), u = l(68), e = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      function n() {
        return n = Object.assign || function(h) {
          for (var S = 1; S < arguments.length; S++) {
            var p = arguments[S];
            for (var X in p)
              Object.prototype.hasOwnProperty.call(p, X) && (h[X] = p[X]);
          }
          return h;
        }, n.apply(this, arguments);
      }
      function G(h) {
        if (typeof h == "string") {
          if (h = h.trim(), /^[0-9.]+%$/.test(h))
            return parseFloat(h) / 100;
          if (/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/.test(h))
            return Object(e.sizeToPixel)(h);
        }
        return h;
      }
      function y(h, S, p, X, V) {
        return typeof h == "string" && (h = W()(h)), typeof S == "string" && (S = W()(S)), s.Effects.default(h, S, p, X, V);
      }
      function a(h, S, p, X, V) {
        return s.Effects.default(h, S, p, X, V);
      }
      s.Effects.default = function(h, S, p, X, V) {
        return Array.isArray(h) && Array.isArray(S) ? h.map((i, b) => i + (p - X) / (V - X) * (S[b] - i)) : typeof h == "number" && typeof S == "number" ? h + (p - X) / (V - X) * (S - h) : p - X > V - p ? S : h;
      }, s.Effects.fillColor = y, s.Effects.strokeColor = y, s.Effects.bgcolor = y, s.Effects.borderColor = y, s.Effects.text = a;
      class I extends s.Animator {
        constructor(S, p, X) {
          const V = S.attr();
          Object.entries(V).forEach(([i, b]) => {
            V[i] = s.Effects[i] ? b : G(b);
          }), p = p.map((i) => {
            let b = n({}, i);
            const t = {};
            return Object.entries(b).forEach(([m, R]) => {
              t[m] = s.Effects[m] ? R : G(R);
            }), t;
          }), super(V, p, X), this.target = S, this.setter = function(i, b) {
            b.attr(i);
          };
        }
        get playState() {
          return this.target.parent ? super.playState : "idle";
        }
        get finished() {
          return super.finished.then(() => {
            const S = this;
            return new Promise((p) => {
              function X() {
                S.setter(S.frame, S.target);
                const V = S.playState;
                V === "finished" || V === "idle" ? (Object(u.cancelAnimationFrame)(S.requestId), p()) : Object(u.requestAnimationFrame)(X);
              }
              X();
            });
          });
        }
        finish() {
          super.finish(), Object(u.cancelAnimationFrame)(this.requestId), this.setter(this.frame, this.target);
        }
        play() {
          if (!this.target.parent || this.playState === "running")
            return;
          super.play(), this.setter(this.frame, this.target);
          const S = this;
          this.ready.then(() => {
            S.setter(S.frame, S.target), S.requestId = Object(u.requestAnimationFrame)(function p() {
              const X = S.target;
              if (typeof document < "u" && document.documentElement && document.documentElement.contains && X.layer && X.layer.canvas && !document.documentElement.contains(X.layer.canvas)) {
                S.cancel();
                return;
              }
              const V = S.playState;
              S.setter(S.frame, S.target), V !== "idle" && (V === "running" ? S.requestId = Object(u.requestAnimationFrame)(p) : (V === "paused" || V === "pending" && S.timeline.currentTime < 0) && S.ready.then(() => {
                S.setter(S.frame, S.target), S.requestId = Object(u.requestAnimationFrame)(p);
              }));
            });
          });
        }
        cancel(S = !1) {
          Object(u.cancelAnimationFrame)(this.requestId), S ? (this.setter(this.frame, this.target), super.cancel()) : (super.cancel(), this.setter(this.frame, this.target));
        }
      }
    },
    /* 74 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.Timeline = d.Effects = d.Easings = d.Animator = void 0;
      var s = l(75), c = y(s), W = l(187), u = y(W), e = l(188), n = l(190), G = y(n);
      function y(a) {
        return a && a.__esModule ? a : { default: a };
      }
      d.Animator = G.default, d.Easings = e.Easings, d.Effects = u.default, d.Timeline = c.default;
    },
    /* 75 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      });
      var s = l(76), c = i(s), W = l(133), u = i(W), e = l(141), n = i(e), G = l(164), y = i(G), a = l(170), I = i(a), h = l(171), S = i(h), p = l(175), X = i(p), V = l(186);
      function i(F) {
        return F && F.__esModule ? F : { default: F };
      }
      var b = (0, V.createNowTime)(), t = {
        originTime: 0,
        playbackRate: 1
      }, m = (0, X.default)("timeMark"), R = (0, X.default)("playbackRate"), x = (0, X.default)("timers"), C = (0, X.default)("originTime"), T = (0, X.default)("setTimer"), K = (0, X.default)("parent"), J = function() {
        function F(r, Y) {
          (0, I.default)(this, F), r instanceof F && (Y = r, r = {}), r = (0, y.default)({}, t, r), Y && (this[K] = Y);
          var H = r.nowtime || b;
          if (Y)
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return Y.currentTime;
              }
            });
          else {
            var Q = H();
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return H() - Q;
              }
            });
          }
          this[m] = [{
            globalTime: this.globalTime,
            localTime: -r.originTime,
            entropy: -r.originTime,
            playbackRate: r.playbackRate,
            globalEntropy: 0
          }], this[K] && (this[m][0].globalEntropy = this[K].entropy), this[C] = r.originTime, this[R] = r.playbackRate, this[x] = new n.default();
        }
        return (0, S.default)(F, [{
          key: "markTime",
          value: function() {
            var Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, H = Y.time, Q = H === void 0 ? this.currentTime : H, w = Y.entropy, O = w === void 0 ? this.entropy : w, q = Y.playbackRate, k = q === void 0 ? this.playbackRate : q, P = {
              globalTime: this.globalTime,
              localTime: Q,
              entropy: O,
              playbackRate: k,
              globalEntropy: this.globalEntropy
            };
            this[m].push(P);
          }
        }, {
          key: "fork",
          value: function(Y) {
            return new F(Y, this);
          }
        }, {
          key: "seekGlobalTime",
          value: function(Y) {
            var H = this.seekTimeMark(Y), Q = this[m][H], w = Q.entropy, O = Q.playbackRate, q = Q.globalTime;
            return q + (Y - w) / Math.abs(O);
          }
        }, {
          key: "seekLocalTime",
          value: function(Y) {
            var H = this.seekTimeMark(Y), Q = this[m][H], w = Q.localTime, O = Q.entropy, q = Q.playbackRate;
            return q > 0 ? w + (Y - O) : w - (Y - O);
          }
        }, {
          key: "seekTimeMark",
          value: function(Y) {
            var H = this[m], Q = 0, w = H.length - 1;
            if (Y <= H[Q].entropy)
              return Q;
            if (Y >= H[w].entropy)
              return w;
            for (var O = Math.floor((Q + w) / 2); O > Q && O < w; ) {
              if (Y === H[O].entropy)
                return O;
              Y < H[O].entropy ? w = O : Y > H[O].entropy && (Q = O), O = Math.floor((Q + w) / 2);
            }
            return Q;
          }
        }, {
          key: "updateTimers",
          value: function() {
            var Y = this, H = [].concat((0, u.default)(this[x]));
            H.forEach(function(Q) {
              var w = (0, c.default)(Q, 2), O = w[0], q = w[1];
              Y[T](q.handler, q.time, O);
            });
          }
        }, {
          key: "clearTimeout",
          value: function(r) {
            function Y(H) {
              return r.apply(this, arguments);
            }
            return Y.toString = function() {
              return r.toString();
            }, Y;
          }(function(r) {
            var Y = this[x].get(r);
            Y && Y.timerID != null && (this[K] ? this[K].clearTimeout(Y.timerID) : clearTimeout(Y.timerID)), this[x].delete(r);
          })
        }, {
          key: "clearInterval",
          value: function(Y) {
            return this.clearTimeout(Y);
          }
        }, {
          key: "clear",
          value: function() {
            var Y = this, H = this[x];
            [].concat((0, u.default)(H.keys())).forEach(function(Q) {
              Y.clearTimeout(Q);
            });
          }
          /*
            setTimeout(func, {delay: 100, isEntropy: true})
            setTimeout(func, {entropy: 100})
            setTimeout(func, 100})
           */
        }, {
          key: "setTimeout",
          value: function(Y) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 };
            return this[T](Y, H);
          }
        }, {
          key: "setInterval",
          value: function(Y) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 }, Q = this, w = this[T](function O() {
              Q[T](O, H, w), Y();
            }, H);
            return w;
          }
        }, {
          key: T,
          value: function(Y, H) {
            var Q = this, w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, X.default)("timerID");
            H = (0, V.formatDelay)(H);
            var O = this[x].get(w), q = void 0, k = null, P = void 0, D = void 0;
            O ? (this.clearTimeout(w), H.isEntropy ? q = (H.delay - (this.entropy - O.startEntropy)) / Math.abs(this.playbackRate) : q = (H.delay - (this.currentTime - O.startTime)) / this.playbackRate, P = O.startTime, D = O.startEntropy) : (q = H.delay / (H.isEntropy ? Math.abs(this.playbackRate) : this.playbackRate), P = this.currentTime, D = this.entropy);
            var ll = this[K], _ = ll ? ll.setTimeout.bind(ll) : setTimeout, bl = H.heading;
            return !ll && bl === !1 && q < 0 && (q = 1 / 0), (isFinite(q) || ll) && (q = Math.ceil(q), _ !== setTimeout && (q = { delay: q, heading: bl }), k = _(function() {
              Q[x].delete(w), Y();
            }, q)), this[x].set(w, {
              timerID: k,
              handler: Y,
              time: H,
              startTime: P,
              startEntropy: D
            }), w;
          }
        }, {
          key: "parent",
          get: function() {
            return this[K];
          }
        }, {
          key: "lastTimeMark",
          get: function() {
            return this[m][this[m].length - 1];
          }
        }, {
          key: "currentTime",
          get: function() {
            var Y = this.lastTimeMark, H = Y.localTime, Q = Y.globalTime;
            return H + (this.globalTime - Q) * this.playbackRate;
          },
          set: function(Y) {
            var H = this, Q = this.currentTime, w = Y, O = this[x];
            this.markTime({ time: Y }), [].concat((0, u.default)(O)).forEach(function(q) {
              var k = (0, c.default)(q, 2), P = k[0], D = k[1];
              if (O.has(P)) {
                var ll = D.time, _ = ll.isEntropy, bl = ll.delay, $ = ll.heading, el = D.handler, nl = D.startTime;
                if (_)
                  bl === 0 && (el(), H.clearTimeout(P));
                else {
                  var z = nl + bl;
                  (bl === 0 || $ !== !1 && (w - Q) * bl <= 0 || Q <= z && z <= w || Q >= z && z >= w) && (el(), H.clearTimeout(P));
                }
              }
            }), this.updateTimers();
          }
          // Both currentTime and entropy should be influenced by playbackRate.
          // If current playbackRate is negative, the currentTime should go backwards
          // while the entropy remain to go forwards.
          // Both of the initial values is set to -originTime
        }, {
          key: "entropy",
          get: function() {
            var Y = this.lastTimeMark, H = Y.entropy, Q = Y.globalEntropy;
            return H + Math.abs((this.globalEntropy - Q) * this.playbackRate);
          },
          // get globalTime() {
          //   if(this[_parent]) {
          //     return this[_parent].currentTime;
          //   }
          //   return nowtime();
          // }
          // change entropy will NOT cause currentTime changing but may influence the pass
          // and the future of the timeline. (It may change the result of seek***Time)
          // While entropy is set, all the marks behind will be droped
          set: function(Y) {
            if (this.entropy > Y) {
              var H = this.seekTimeMark(Y);
              this[m].length = H + 1;
            }
            this.markTime({ entropy: Y }), this.updateTimers();
          }
        }, {
          key: "globalEntropy",
          get: function() {
            return this[K] ? this[K].entropy : this.globalTime;
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[R];
          },
          set: function(Y) {
            Y !== this.playbackRate && (this.markTime({ playbackRate: Y }), this[R] = Y, this.updateTimers());
          }
        }, {
          key: "paused",
          get: function() {
            if (this.playbackRate === 0)
              return !0;
            for (var Y = this.parent; Y; ) {
              if (Y.playbackRate === 0)
                return !0;
              Y = Y.parent;
            }
            return !1;
          }
        }]), F;
      }();
      d.default = J;
    },
    /* 76 */
    /***/
    function(Z, d, l) {
      d.__esModule = !0;
      var s = l(77), c = e(s), W = l(129), u = e(W);
      function e(n) {
        return n && n.__esModule ? n : { default: n };
      }
      d.default = /* @__PURE__ */ function() {
        function n(G, y) {
          var a = [], I = !0, h = !1, S = void 0;
          try {
            for (var p = (0, u.default)(G), X; !(I = (X = p.next()).done) && (a.push(X.value), !(y && a.length === y)); I = !0)
              ;
          } catch (V) {
            h = !0, S = V;
          } finally {
            try {
              !I && p.return && p.return();
            } finally {
              if (h)
                throw S;
            }
          }
          return a;
        }
        return function(G, y) {
          if (Array.isArray(G))
            return G;
          if ((0, c.default)(Object(G)))
            return n(G, y);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }();
    },
    /* 77 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(78), __esModule: !0 };
    },
    /* 78 */
    /***/
    function(Z, d, l) {
      l(79), l(125), Z.exports = l(127);
    },
    /* 79 */
    /***/
    function(Z, d, l) {
      l(80);
      for (var s = l(91), c = l(95), W = l(83), u = l(122)("toStringTag"), e = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), n = 0; n < e.length; n++) {
        var G = e[n], y = s[G], a = y && y.prototype;
        a && !a[u] && c(a, u, G), W[G] = W.Array;
      }
    },
    /* 80 */
    /***/
    function(Z, d, l) {
      var s = l(81), c = l(82), W = l(83), u = l(84);
      Z.exports = l(88)(Array, "Array", function(e, n) {
        this._t = u(e), this._i = 0, this._k = n;
      }, function() {
        var e = this._t, n = this._k, G = this._i++;
        return !e || G >= e.length ? (this._t = void 0, c(1)) : n == "keys" ? c(0, G) : n == "values" ? c(0, e[G]) : c(0, [G, e[G]]);
      }, "values"), W.Arguments = W.Array, s("keys"), s("values"), s("entries");
    },
    /* 81 */
    /***/
    function(Z, d) {
      Z.exports = function() {
      };
    },
    /* 82 */
    /***/
    function(Z, d) {
      Z.exports = function(l, s) {
        return { value: s, done: !!l };
      };
    },
    /* 83 */
    /***/
    function(Z, d) {
      Z.exports = {};
    },
    /* 84 */
    /***/
    function(Z, d, l) {
      var s = l(85), c = l(87);
      Z.exports = function(W) {
        return s(c(W));
      };
    },
    /* 85 */
    /***/
    function(Z, d, l) {
      var s = l(86);
      Z.exports = Object("z").propertyIsEnumerable(0) ? Object : function(c) {
        return s(c) == "String" ? c.split("") : Object(c);
      };
    },
    /* 86 */
    /***/
    function(Z, d) {
      var l = {}.toString;
      Z.exports = function(s) {
        return l.call(s).slice(8, -1);
      };
    },
    /* 87 */
    /***/
    function(Z, d) {
      Z.exports = function(l) {
        if (l == null)
          throw TypeError("Can't call method on  " + l);
        return l;
      };
    },
    /* 88 */
    /***/
    function(Z, d, l) {
      var s = l(89), c = l(90), W = l(106), u = l(95), e = l(83), n = l(107), G = l(121), y = l(123), a = l(122)("iterator"), I = !([].keys && "next" in [].keys()), h = "@@iterator", S = "keys", p = "values", X = function() {
        return this;
      };
      Z.exports = function(V, i, b, t, m, R, x) {
        n(b, i, t);
        var C = function(k) {
          if (!I && k in F)
            return F[k];
          switch (k) {
            case S:
              return function() {
                return new b(this, k);
              };
            case p:
              return function() {
                return new b(this, k);
              };
          }
          return function() {
            return new b(this, k);
          };
        }, T = i + " Iterator", K = m == p, J = !1, F = V.prototype, r = F[a] || F[h] || m && F[m], Y = r || C(m), H = m ? K ? C("entries") : Y : void 0, Q = i == "Array" && F.entries || r, w, O, q;
        if (Q && (q = y(Q.call(new V())), q !== Object.prototype && q.next && (G(q, T, !0), !s && typeof q[a] != "function" && u(q, a, X))), K && r && r.name !== p && (J = !0, Y = function() {
          return r.call(this);
        }), (!s || x) && (I || J || !F[a]) && u(F, a, Y), e[i] = Y, e[T] = X, m)
          if (w = {
            values: K ? Y : C(p),
            keys: R ? Y : C(S),
            entries: H
          }, x)
            for (O in w)
              O in F || W(F, O, w[O]);
          else
            c(c.P + c.F * (I || J), i, w);
        return w;
      };
    },
    /* 89 */
    /***/
    function(Z, d) {
      Z.exports = !0;
    },
    /* 90 */
    /***/
    function(Z, d, l) {
      var s = l(91), c = l(92), W = l(93), u = l(95), e = l(105), n = "prototype", G = function(y, a, I) {
        var h = y & G.F, S = y & G.G, p = y & G.S, X = y & G.P, V = y & G.B, i = y & G.W, b = S ? c : c[a] || (c[a] = {}), t = b[n], m = S ? s : p ? s[a] : (s[a] || {})[n], R, x, C;
        S && (I = a);
        for (R in I)
          x = !h && m && m[R] !== void 0, !(x && e(b, R)) && (C = x ? m[R] : I[R], b[R] = S && typeof m[R] != "function" ? I[R] : V && x ? W(C, s) : i && m[R] == C ? function(T) {
            var K = function(J, F, r) {
              if (this instanceof T) {
                switch (arguments.length) {
                  case 0:
                    return new T();
                  case 1:
                    return new T(J);
                  case 2:
                    return new T(J, F);
                }
                return new T(J, F, r);
              }
              return T.apply(this, arguments);
            };
            return K[n] = T[n], K;
          }(C) : X && typeof C == "function" ? W(Function.call, C) : C, X && ((b.virtual || (b.virtual = {}))[R] = C, y & G.R && t && !t[R] && u(t, R, C)));
      };
      G.F = 1, G.G = 2, G.S = 4, G.P = 8, G.B = 16, G.W = 32, G.U = 64, G.R = 128, Z.exports = G;
    },
    /* 91 */
    /***/
    function(Z, d) {
      var l = Z.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
      typeof __g == "number" && (__g = l);
    },
    /* 92 */
    /***/
    function(Z, d) {
      var l = Z.exports = { version: "2.6.11" };
      typeof __e == "number" && (__e = l);
    },
    /* 93 */
    /***/
    function(Z, d, l) {
      var s = l(94);
      Z.exports = function(c, W, u) {
        if (s(c), W === void 0)
          return c;
        switch (u) {
          case 1:
            return function(e) {
              return c.call(W, e);
            };
          case 2:
            return function(e, n) {
              return c.call(W, e, n);
            };
          case 3:
            return function(e, n, G) {
              return c.call(W, e, n, G);
            };
        }
        return function() {
          return c.apply(W, arguments);
        };
      };
    },
    /* 94 */
    /***/
    function(Z, d) {
      Z.exports = function(l) {
        if (typeof l != "function")
          throw TypeError(l + " is not a function!");
        return l;
      };
    },
    /* 95 */
    /***/
    function(Z, d, l) {
      var s = l(96), c = l(104);
      Z.exports = l(100) ? function(W, u, e) {
        return s.f(W, u, c(1, e));
      } : function(W, u, e) {
        return W[u] = e, W;
      };
    },
    /* 96 */
    /***/
    function(Z, d, l) {
      var s = l(97), c = l(99), W = l(103), u = Object.defineProperty;
      d.f = l(100) ? Object.defineProperty : function(n, G, y) {
        if (s(n), G = W(G, !0), s(y), c)
          try {
            return u(n, G, y);
          } catch {
          }
        if ("get" in y || "set" in y)
          throw TypeError("Accessors not supported!");
        return "value" in y && (n[G] = y.value), n;
      };
    },
    /* 97 */
    /***/
    function(Z, d, l) {
      var s = l(98);
      Z.exports = function(c) {
        if (!s(c))
          throw TypeError(c + " is not an object!");
        return c;
      };
    },
    /* 98 */
    /***/
    function(Z, d) {
      Z.exports = function(l) {
        return typeof l == "object" ? l !== null : typeof l == "function";
      };
    },
    /* 99 */
    /***/
    function(Z, d, l) {
      Z.exports = !l(100) && !l(101)(function() {
        return Object.defineProperty(l(102)("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 100 */
    /***/
    function(Z, d, l) {
      Z.exports = !l(101)(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 101 */
    /***/
    function(Z, d) {
      Z.exports = function(l) {
        try {
          return !!l();
        } catch {
          return !0;
        }
      };
    },
    /* 102 */
    /***/
    function(Z, d, l) {
      var s = l(98), c = l(91).document, W = s(c) && s(c.createElement);
      Z.exports = function(u) {
        return W ? c.createElement(u) : {};
      };
    },
    /* 103 */
    /***/
    function(Z, d, l) {
      var s = l(98);
      Z.exports = function(c, W) {
        if (!s(c))
          return c;
        var u, e;
        if (W && typeof (u = c.toString) == "function" && !s(e = u.call(c)) || typeof (u = c.valueOf) == "function" && !s(e = u.call(c)) || !W && typeof (u = c.toString) == "function" && !s(e = u.call(c)))
          return e;
        throw TypeError("Can't convert object to primitive value");
      };
    },
    /* 104 */
    /***/
    function(Z, d) {
      Z.exports = function(l, s) {
        return {
          enumerable: !(l & 1),
          configurable: !(l & 2),
          writable: !(l & 4),
          value: s
        };
      };
    },
    /* 105 */
    /***/
    function(Z, d) {
      var l = {}.hasOwnProperty;
      Z.exports = function(s, c) {
        return l.call(s, c);
      };
    },
    /* 106 */
    /***/
    function(Z, d, l) {
      Z.exports = l(95);
    },
    /* 107 */
    /***/
    function(Z, d, l) {
      var s = l(108), c = l(104), W = l(121), u = {};
      l(95)(u, l(122)("iterator"), function() {
        return this;
      }), Z.exports = function(e, n, G) {
        e.prototype = s(u, { next: c(1, G) }), W(e, n + " Iterator");
      };
    },
    /* 108 */
    /***/
    function(Z, d, l) {
      var s = l(97), c = l(109), W = l(119), u = l(116)("IE_PROTO"), e = function() {
      }, n = "prototype", G = function() {
        var y = l(102)("iframe"), a = W.length, I = "<", h = ">", S;
        for (y.style.display = "none", l(120).appendChild(y), y.src = "javascript:", S = y.contentWindow.document, S.open(), S.write(I + "script" + h + "document.F=Object" + I + "/script" + h), S.close(), G = S.F; a--; )
          delete G[n][W[a]];
        return G();
      };
      Z.exports = Object.create || function(a, I) {
        var h;
        return a !== null ? (e[n] = s(a), h = new e(), e[n] = null, h[u] = a) : h = G(), I === void 0 ? h : c(h, I);
      };
    },
    /* 109 */
    /***/
    function(Z, d, l) {
      var s = l(96), c = l(97), W = l(110);
      Z.exports = l(100) ? Object.defineProperties : function(e, n) {
        c(e);
        for (var G = W(n), y = G.length, a = 0, I; y > a; )
          s.f(e, I = G[a++], n[I]);
        return e;
      };
    },
    /* 110 */
    /***/
    function(Z, d, l) {
      var s = l(111), c = l(119);
      Z.exports = Object.keys || function(u) {
        return s(u, c);
      };
    },
    /* 111 */
    /***/
    function(Z, d, l) {
      var s = l(105), c = l(84), W = l(112)(!1), u = l(116)("IE_PROTO");
      Z.exports = function(e, n) {
        var G = c(e), y = 0, a = [], I;
        for (I in G)
          I != u && s(G, I) && a.push(I);
        for (; n.length > y; )
          s(G, I = n[y++]) && (~W(a, I) || a.push(I));
        return a;
      };
    },
    /* 112 */
    /***/
    function(Z, d, l) {
      var s = l(84), c = l(113), W = l(115);
      Z.exports = function(u) {
        return function(e, n, G) {
          var y = s(e), a = c(y.length), I = W(G, a), h;
          if (u && n != n) {
            for (; a > I; )
              if (h = y[I++], h != h)
                return !0;
          } else
            for (; a > I; I++)
              if ((u || I in y) && y[I] === n)
                return u || I || 0;
          return !u && -1;
        };
      };
    },
    /* 113 */
    /***/
    function(Z, d, l) {
      var s = l(114), c = Math.min;
      Z.exports = function(W) {
        return W > 0 ? c(s(W), 9007199254740991) : 0;
      };
    },
    /* 114 */
    /***/
    function(Z, d) {
      var l = Math.ceil, s = Math.floor;
      Z.exports = function(c) {
        return isNaN(c = +c) ? 0 : (c > 0 ? s : l)(c);
      };
    },
    /* 115 */
    /***/
    function(Z, d, l) {
      var s = l(114), c = Math.max, W = Math.min;
      Z.exports = function(u, e) {
        return u = s(u), u < 0 ? c(u + e, 0) : W(u, e);
      };
    },
    /* 116 */
    /***/
    function(Z, d, l) {
      var s = l(117)("keys"), c = l(118);
      Z.exports = function(W) {
        return s[W] || (s[W] = c(W));
      };
    },
    /* 117 */
    /***/
    function(Z, d, l) {
      var s = l(92), c = l(91), W = "__core-js_shared__", u = c[W] || (c[W] = {});
      (Z.exports = function(e, n) {
        return u[e] || (u[e] = n !== void 0 ? n : {});
      })("versions", []).push({
        version: s.version,
        mode: l(89) ? "pure" : "global",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
      });
    },
    /* 118 */
    /***/
    function(Z, d) {
      var l = 0, s = Math.random();
      Z.exports = function(c) {
        return "Symbol(".concat(c === void 0 ? "" : c, ")_", (++l + s).toString(36));
      };
    },
    /* 119 */
    /***/
    function(Z, d) {
      Z.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    },
    /* 120 */
    /***/
    function(Z, d, l) {
      var s = l(91).document;
      Z.exports = s && s.documentElement;
    },
    /* 121 */
    /***/
    function(Z, d, l) {
      var s = l(96).f, c = l(105), W = l(122)("toStringTag");
      Z.exports = function(u, e, n) {
        u && !c(u = n ? u : u.prototype, W) && s(u, W, { configurable: !0, value: e });
      };
    },
    /* 122 */
    /***/
    function(Z, d, l) {
      var s = l(117)("wks"), c = l(118), W = l(91).Symbol, u = typeof W == "function", e = Z.exports = function(n) {
        return s[n] || (s[n] = u && W[n] || (u ? W : c)("Symbol." + n));
      };
      e.store = s;
    },
    /* 123 */
    /***/
    function(Z, d, l) {
      var s = l(105), c = l(124), W = l(116)("IE_PROTO"), u = Object.prototype;
      Z.exports = Object.getPrototypeOf || function(e) {
        return e = c(e), s(e, W) ? e[W] : typeof e.constructor == "function" && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? u : null;
      };
    },
    /* 124 */
    /***/
    function(Z, d, l) {
      var s = l(87);
      Z.exports = function(c) {
        return Object(s(c));
      };
    },
    /* 125 */
    /***/
    function(Z, d, l) {
      var s = l(126)(!0);
      l(88)(String, "String", function(c) {
        this._t = String(c), this._i = 0;
      }, function() {
        var c = this._t, W = this._i, u;
        return W >= c.length ? { value: void 0, done: !0 } : (u = s(c, W), this._i += u.length, { value: u, done: !1 });
      });
    },
    /* 126 */
    /***/
    function(Z, d, l) {
      var s = l(114), c = l(87);
      Z.exports = function(W) {
        return function(u, e) {
          var n = String(c(u)), G = s(e), y = n.length, a, I;
          return G < 0 || G >= y ? W ? "" : void 0 : (a = n.charCodeAt(G), a < 55296 || a > 56319 || G + 1 === y || (I = n.charCodeAt(G + 1)) < 56320 || I > 57343 ? W ? n.charAt(G) : a : W ? n.slice(G, G + 2) : (a - 55296 << 10) + (I - 56320) + 65536);
        };
      };
    },
    /* 127 */
    /***/
    function(Z, d, l) {
      var s = l(128), c = l(122)("iterator"), W = l(83);
      Z.exports = l(92).isIterable = function(u) {
        var e = Object(u);
        return e[c] !== void 0 || "@@iterator" in e || W.hasOwnProperty(s(e));
      };
    },
    /* 128 */
    /***/
    function(Z, d, l) {
      var s = l(86), c = l(122)("toStringTag"), W = s(/* @__PURE__ */ function() {
        return arguments;
      }()) == "Arguments", u = function(e, n) {
        try {
          return e[n];
        } catch {
        }
      };
      Z.exports = function(e) {
        var n, G, y;
        return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (G = u(n = Object(e), c)) == "string" ? G : W ? s(n) : (y = s(n)) == "Object" && typeof n.callee == "function" ? "Arguments" : y;
      };
    },
    /* 129 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(130), __esModule: !0 };
    },
    /* 130 */
    /***/
    function(Z, d, l) {
      l(79), l(125), Z.exports = l(131);
    },
    /* 131 */
    /***/
    function(Z, d, l) {
      var s = l(97), c = l(132);
      Z.exports = l(92).getIterator = function(W) {
        var u = c(W);
        if (typeof u != "function")
          throw TypeError(W + " is not iterable!");
        return s(u.call(W));
      };
    },
    /* 132 */
    /***/
    function(Z, d, l) {
      var s = l(128), c = l(122)("iterator"), W = l(83);
      Z.exports = l(92).getIteratorMethod = function(u) {
        if (u != null)
          return u[c] || u["@@iterator"] || W[s(u)];
      };
    },
    /* 133 */
    /***/
    function(Z, d, l) {
      d.__esModule = !0;
      var s = l(134), c = W(s);
      function W(u) {
        return u && u.__esModule ? u : { default: u };
      }
      d.default = function(u) {
        if (Array.isArray(u)) {
          for (var e = 0, n = Array(u.length); e < u.length; e++)
            n[e] = u[e];
          return n;
        } else
          return (0, c.default)(u);
      };
    },
    /* 134 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(135), __esModule: !0 };
    },
    /* 135 */
    /***/
    function(Z, d, l) {
      l(125), l(136), Z.exports = l(92).Array.from;
    },
    /* 136 */
    /***/
    function(Z, d, l) {
      var s = l(93), c = l(90), W = l(124), u = l(137), e = l(138), n = l(113), G = l(139), y = l(132);
      c(c.S + c.F * !l(140)(function(a) {
        Array.from(a);
      }), "Array", {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function(I) {
          var h = W(I), S = typeof this == "function" ? this : Array, p = arguments.length, X = p > 1 ? arguments[1] : void 0, V = X !== void 0, i = 0, b = y(h), t, m, R, x;
          if (V && (X = s(X, p > 2 ? arguments[2] : void 0, 2)), b != null && !(S == Array && e(b)))
            for (x = b.call(h), m = new S(); !(R = x.next()).done; i++)
              G(m, i, V ? u(x, X, [R.value, i], !0) : R.value);
          else
            for (t = n(h.length), m = new S(t); t > i; i++)
              G(m, i, V ? X(h[i], i) : h[i]);
          return m.length = i, m;
        }
      });
    },
    /* 137 */
    /***/
    function(Z, d, l) {
      var s = l(97);
      Z.exports = function(c, W, u, e) {
        try {
          return e ? W(s(u)[0], u[1]) : W(u);
        } catch (G) {
          var n = c.return;
          throw n !== void 0 && s(n.call(c)), G;
        }
      };
    },
    /* 138 */
    /***/
    function(Z, d, l) {
      var s = l(83), c = l(122)("iterator"), W = Array.prototype;
      Z.exports = function(u) {
        return u !== void 0 && (s.Array === u || W[c] === u);
      };
    },
    /* 139 */
    /***/
    function(Z, d, l) {
      var s = l(96), c = l(104);
      Z.exports = function(W, u, e) {
        u in W ? s.f(W, u, c(0, e)) : W[u] = e;
      };
    },
    /* 140 */
    /***/
    function(Z, d, l) {
      var s = l(122)("iterator"), c = !1;
      try {
        var W = [7][s]();
        W.return = function() {
          c = !0;
        }, Array.from(W, function() {
          throw 2;
        });
      } catch {
      }
      Z.exports = function(u, e) {
        if (!e && !c)
          return !1;
        var n = !1;
        try {
          var G = [7], y = G[s]();
          y.next = function() {
            return { done: n = !0 };
          }, G[s] = function() {
            return y;
          }, u(G);
        } catch {
        }
        return n;
      };
    },
    /* 141 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(142), __esModule: !0 };
    },
    /* 142 */
    /***/
    function(Z, d, l) {
      l(143), l(125), l(79), l(144), l(157), l(160), l(162), Z.exports = l(92).Map;
    },
    /* 143 */
    /***/
    function(Z, d) {
    },
    /* 144 */
    /***/
    function(Z, d, l) {
      var s = l(145), c = l(151), W = "Map";
      Z.exports = l(152)(W, function(u) {
        return function() {
          return u(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function(e) {
          var n = s.getEntry(c(this, W), e);
          return n && n.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function(e, n) {
          return s.def(c(this, W), e === 0 ? 0 : e, n);
        }
      }, s, !0);
    },
    /* 145 */
    /***/
    function(Z, d, l) {
      var s = l(96).f, c = l(108), W = l(146), u = l(93), e = l(147), n = l(148), G = l(88), y = l(82), a = l(149), I = l(100), h = l(150).fastKey, S = l(151), p = I ? "_s" : "size", X = function(V, i) {
        var b = h(i), t;
        if (b !== "F")
          return V._i[b];
        for (t = V._f; t; t = t.n)
          if (t.k == i)
            return t;
      };
      Z.exports = {
        getConstructor: function(V, i, b, t) {
          var m = V(function(R, x) {
            e(R, m, i, "_i"), R._t = i, R._i = c(null), R._f = void 0, R._l = void 0, R[p] = 0, x != null && n(x, b, R[t], R);
          });
          return W(m.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function() {
              for (var x = S(this, i), C = x._i, T = x._f; T; T = T.n)
                T.r = !0, T.p && (T.p = T.p.n = void 0), delete C[T.i];
              x._f = x._l = void 0, x[p] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            delete: function(R) {
              var x = S(this, i), C = X(x, R);
              if (C) {
                var T = C.n, K = C.p;
                delete x._i[C.i], C.r = !0, K && (K.n = T), T && (T.p = K), x._f == C && (x._f = T), x._l == C && (x._l = K), x[p]--;
              }
              return !!C;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function(x) {
              S(this, i);
              for (var C = u(x, arguments.length > 1 ? arguments[1] : void 0, 3), T; T = T ? T.n : this._f; )
                for (C(T.v, T.k, this); T && T.r; )
                  T = T.p;
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function(x) {
              return !!X(S(this, i), x);
            }
          }), I && s(m.prototype, "size", {
            get: function() {
              return S(this, i)[p];
            }
          }), m;
        },
        def: function(V, i, b) {
          var t = X(V, i), m, R;
          return t ? t.v = b : (V._l = t = {
            i: R = h(i, !0),
            // <- index
            k: i,
            // <- key
            v: b,
            // <- value
            p: m = V._l,
            // <- previous entry
            n: void 0,
            // <- next entry
            r: !1
            // <- removed
          }, V._f || (V._f = t), m && (m.n = t), V[p]++, R !== "F" && (V._i[R] = t)), V;
        },
        getEntry: X,
        setStrong: function(V, i, b) {
          G(V, i, function(t, m) {
            this._t = S(t, i), this._k = m, this._l = void 0;
          }, function() {
            for (var t = this, m = t._k, R = t._l; R && R.r; )
              R = R.p;
            return !t._t || !(t._l = R = R ? R.n : t._t._f) ? (t._t = void 0, y(1)) : m == "keys" ? y(0, R.k) : m == "values" ? y(0, R.v) : y(0, [R.k, R.v]);
          }, b ? "entries" : "values", !b, !0), a(i);
        }
      };
    },
    /* 146 */
    /***/
    function(Z, d, l) {
      var s = l(95);
      Z.exports = function(c, W, u) {
        for (var e in W)
          u && c[e] ? c[e] = W[e] : s(c, e, W[e]);
        return c;
      };
    },
    /* 147 */
    /***/
    function(Z, d) {
      Z.exports = function(l, s, c, W) {
        if (!(l instanceof s) || W !== void 0 && W in l)
          throw TypeError(c + ": incorrect invocation!");
        return l;
      };
    },
    /* 148 */
    /***/
    function(Z, a, l) {
      var s = l(93), c = l(137), W = l(138), u = l(97), e = l(113), n = l(132), G = {}, y = {}, a = Z.exports = function(I, h, S, p, X) {
        var V = X ? function() {
          return I;
        } : n(I), i = s(S, p, h ? 2 : 1), b = 0, t, m, R, x;
        if (typeof V != "function")
          throw TypeError(I + " is not iterable!");
        if (W(V)) {
          for (t = e(I.length); t > b; b++)
            if (x = h ? i(u(m = I[b])[0], m[1]) : i(I[b]), x === G || x === y)
              return x;
        } else
          for (R = V.call(I); !(m = R.next()).done; )
            if (x = c(R, i, m.value, h), x === G || x === y)
              return x;
      };
      a.BREAK = G, a.RETURN = y;
    },
    /* 149 */
    /***/
    function(Z, d, l) {
      var s = l(91), c = l(92), W = l(96), u = l(100), e = l(122)("species");
      Z.exports = function(n) {
        var G = typeof c[n] == "function" ? c[n] : s[n];
        u && G && !G[e] && W.f(G, e, {
          configurable: !0,
          get: function() {
            return this;
          }
        });
      };
    },
    /* 150 */
    /***/
    function(Z, d, l) {
      var s = l(118)("meta"), c = l(98), W = l(105), u = l(96).f, e = 0, n = Object.isExtensible || function() {
        return !0;
      }, G = !l(101)(function() {
        return n(Object.preventExtensions({}));
      }), y = function(p) {
        u(p, s, { value: {
          i: "O" + ++e,
          // object ID
          w: {}
          // weak collections IDs
        } });
      }, a = function(p, X) {
        if (!c(p))
          return typeof p == "symbol" ? p : (typeof p == "string" ? "S" : "P") + p;
        if (!W(p, s)) {
          if (!n(p))
            return "F";
          if (!X)
            return "E";
          y(p);
        }
        return p[s].i;
      }, I = function(p, X) {
        if (!W(p, s)) {
          if (!n(p))
            return !0;
          if (!X)
            return !1;
          y(p);
        }
        return p[s].w;
      }, h = function(p) {
        return G && S.NEED && n(p) && !W(p, s) && y(p), p;
      }, S = Z.exports = {
        KEY: s,
        NEED: !1,
        fastKey: a,
        getWeak: I,
        onFreeze: h
      };
    },
    /* 151 */
    /***/
    function(Z, d, l) {
      var s = l(98);
      Z.exports = function(c, W) {
        if (!s(c) || c._t !== W)
          throw TypeError("Incompatible receiver, " + W + " required!");
        return c;
      };
    },
    /* 152 */
    /***/
    function(Z, d, l) {
      var s = l(91), c = l(90), W = l(150), u = l(101), e = l(95), n = l(146), G = l(148), y = l(147), a = l(98), I = l(121), h = l(96).f, S = l(153)(0), p = l(100);
      Z.exports = function(X, V, i, b, t, m) {
        var R = s[X], x = R, C = t ? "set" : "add", T = x && x.prototype, K = {};
        return !p || typeof x != "function" || !(m || T.forEach && !u(function() {
          new x().entries().next();
        })) ? (x = b.getConstructor(V, X, t, C), n(x.prototype, i), W.NEED = !0) : (x = V(function(J, F) {
          y(J, x, X, "_c"), J._c = new R(), F != null && G(F, t, J[C], J);
        }), S("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(J) {
          var F = J == "add" || J == "set";
          J in T && !(m && J == "clear") && e(x.prototype, J, function(r, Y) {
            if (y(this, x, J), !F && m && !a(r))
              return J == "get" ? void 0 : !1;
            var H = this._c[J](r === 0 ? 0 : r, Y);
            return F ? this : H;
          });
        }), m || h(x.prototype, "size", {
          get: function() {
            return this._c.size;
          }
        })), I(x, X), K[X] = x, c(c.G + c.W + c.F, K), m || b.setStrong(x, X, t), x;
      };
    },
    /* 153 */
    /***/
    function(Z, d, l) {
      var s = l(93), c = l(85), W = l(124), u = l(113), e = l(154);
      Z.exports = function(n, G) {
        var y = n == 1, a = n == 2, I = n == 3, h = n == 4, S = n == 6, p = n == 5 || S, X = G || e;
        return function(V, i, b) {
          for (var t = W(V), m = c(t), R = s(i, b, 3), x = u(m.length), C = 0, T = y ? X(V, x) : a ? X(V, 0) : void 0, K, J; x > C; C++)
            if ((p || C in m) && (K = m[C], J = R(K, C, t), n)) {
              if (y)
                T[C] = J;
              else if (J)
                switch (n) {
                  case 3:
                    return !0;
                  case 5:
                    return K;
                  case 6:
                    return C;
                  case 2:
                    T.push(K);
                }
              else if (h)
                return !1;
            }
          return S ? -1 : I || h ? h : T;
        };
      };
    },
    /* 154 */
    /***/
    function(Z, d, l) {
      var s = l(155);
      Z.exports = function(c, W) {
        return new (s(c))(W);
      };
    },
    /* 155 */
    /***/
    function(Z, d, l) {
      var s = l(98), c = l(156), W = l(122)("species");
      Z.exports = function(u) {
        var e;
        return c(u) && (e = u.constructor, typeof e == "function" && (e === Array || c(e.prototype)) && (e = void 0), s(e) && (e = e[W], e === null && (e = void 0))), e === void 0 ? Array : e;
      };
    },
    /* 156 */
    /***/
    function(Z, d, l) {
      var s = l(86);
      Z.exports = Array.isArray || function(W) {
        return s(W) == "Array";
      };
    },
    /* 157 */
    /***/
    function(Z, d, l) {
      var s = l(90);
      s(s.P + s.R, "Map", { toJSON: l(158)("Map") });
    },
    /* 158 */
    /***/
    function(Z, d, l) {
      var s = l(128), c = l(159);
      Z.exports = function(W) {
        return function() {
          if (s(this) != W)
            throw TypeError(W + "#toJSON isn't generic");
          return c(this);
        };
      };
    },
    /* 159 */
    /***/
    function(Z, d, l) {
      var s = l(148);
      Z.exports = function(c, W) {
        var u = [];
        return s(c, !1, u.push, u, W), u;
      };
    },
    /* 160 */
    /***/
    function(Z, d, l) {
      l(161)("Map");
    },
    /* 161 */
    /***/
    function(Z, d, l) {
      var s = l(90);
      Z.exports = function(c) {
        s(s.S, c, { of: function() {
          for (var u = arguments.length, e = new Array(u); u--; )
            e[u] = arguments[u];
          return new this(e);
        } });
      };
    },
    /* 162 */
    /***/
    function(Z, d, l) {
      l(163)("Map");
    },
    /* 163 */
    /***/
    function(Z, d, l) {
      var s = l(90), c = l(94), W = l(93), u = l(148);
      Z.exports = function(e) {
        s(s.S, e, { from: function(G) {
          var y = arguments[1], a, I, h, S;
          return c(this), a = y !== void 0, a && c(y), G == null ? new this() : (I = [], a ? (h = 0, S = W(y, arguments[2], 2), u(G, !1, function(p) {
            I.push(S(p, h++));
          })) : u(G, !1, I.push, I), new this(I));
        } });
      };
    },
    /* 164 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(165), __esModule: !0 };
    },
    /* 165 */
    /***/
    function(Z, d, l) {
      l(166), Z.exports = l(92).Object.assign;
    },
    /* 166 */
    /***/
    function(Z, d, l) {
      var s = l(90);
      s(s.S + s.F, "Object", { assign: l(167) });
    },
    /* 167 */
    /***/
    function(Z, d, l) {
      var s = l(100), c = l(110), W = l(168), u = l(169), e = l(124), n = l(85), G = Object.assign;
      Z.exports = !G || l(101)(function() {
        var y = {}, a = {}, I = Symbol(), h = "abcdefghijklmnopqrst";
        return y[I] = 7, h.split("").forEach(function(S) {
          a[S] = S;
        }), G({}, y)[I] != 7 || Object.keys(G({}, a)).join("") != h;
      }) ? function(a, I) {
        for (var h = e(a), S = arguments.length, p = 1, X = W.f, V = u.f; S > p; )
          for (var i = n(arguments[p++]), b = X ? c(i).concat(X(i)) : c(i), t = b.length, m = 0, R; t > m; )
            R = b[m++], (!s || V.call(i, R)) && (h[R] = i[R]);
        return h;
      } : G;
    },
    /* 168 */
    /***/
    function(Z, d) {
      d.f = Object.getOwnPropertySymbols;
    },
    /* 169 */
    /***/
    function(Z, d) {
      d.f = {}.propertyIsEnumerable;
    },
    /* 170 */
    /***/
    function(Z, d, l) {
      d.__esModule = !0, d.default = function(s, c) {
        if (!(s instanceof c))
          throw new TypeError("Cannot call a class as a function");
      };
    },
    /* 171 */
    /***/
    function(Z, d, l) {
      d.__esModule = !0;
      var s = l(172), c = W(s);
      function W(u) {
        return u && u.__esModule ? u : { default: u };
      }
      d.default = /* @__PURE__ */ function() {
        function u(e, n) {
          for (var G = 0; G < n.length; G++) {
            var y = n[G];
            y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), (0, c.default)(e, y.key, y);
          }
        }
        return function(e, n, G) {
          return n && u(e.prototype, n), G && u(e, G), e;
        };
      }();
    },
    /* 172 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(173), __esModule: !0 };
    },
    /* 173 */
    /***/
    function(Z, d, l) {
      l(174);
      var s = l(92).Object;
      Z.exports = function(W, u, e) {
        return s.defineProperty(W, u, e);
      };
    },
    /* 174 */
    /***/
    function(Z, d, l) {
      var s = l(90);
      s(s.S + s.F * !l(100), "Object", { defineProperty: l(96).f });
    },
    /* 175 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(176), __esModule: !0 };
    },
    /* 176 */
    /***/
    function(Z, d, l) {
      l(177), l(143), l(184), l(185), Z.exports = l(92).Symbol;
    },
    /* 177 */
    /***/
    function(Z, d, l) {
      var s = l(91), c = l(105), W = l(100), u = l(90), e = l(106), n = l(150).KEY, G = l(101), y = l(117), a = l(121), I = l(118), h = l(122), S = l(178), p = l(179), X = l(180), V = l(156), i = l(97), b = l(98), t = l(124), m = l(84), R = l(103), x = l(104), C = l(108), T = l(181), K = l(183), J = l(168), F = l(96), r = l(110), Y = K.f, H = F.f, Q = T.f, w = s.Symbol, O = s.JSON, q = O && O.stringify, k = "prototype", P = h("_hidden"), D = h("toPrimitive"), ll = {}.propertyIsEnumerable, _ = y("symbol-registry"), bl = y("symbols"), $ = y("op-symbols"), el = Object[k], nl = typeof w == "function" && !!J.f, z = s.QObject, M = !z || !z[k] || !z[k].findChild, E = W && G(function() {
        return C(H({}, "a", {
          get: function() {
            return H(this, "a", { value: 7 }).a;
          }
        })).a != 7;
      }) ? function(tl, sl, Zl) {
        var al = Y(el, sl);
        al && delete el[sl], H(tl, sl, Zl), al && tl !== el && H(el, sl, al);
      } : H, B = function(tl) {
        var sl = bl[tl] = C(w[k]);
        return sl._k = tl, sl;
      }, g = nl && typeof w.iterator == "symbol" ? function(tl) {
        return typeof tl == "symbol";
      } : function(tl) {
        return tl instanceof w;
      }, U = function(sl, Zl, al) {
        return sl === el && U($, Zl, al), i(sl), Zl = R(Zl, !0), i(al), c(bl, Zl) ? (al.enumerable ? (c(sl, P) && sl[P][Zl] && (sl[P][Zl] = !1), al = C(al, { enumerable: x(0, !1) })) : (c(sl, P) || H(sl, P, x(1, {})), sl[P][Zl] = !0), E(sl, Zl, al)) : H(sl, Zl, al);
      }, o = function(sl, Zl) {
        i(sl);
        for (var al = X(Zl = m(Zl)), ol = 0, Xl = al.length, Gl; Xl > ol; )
          U(sl, Gl = al[ol++], Zl[Gl]);
        return sl;
      }, L = function(sl, Zl) {
        return Zl === void 0 ? C(sl) : o(C(sl), Zl);
      }, N = function(sl) {
        var Zl = ll.call(this, sl = R(sl, !0));
        return this === el && c(bl, sl) && !c($, sl) ? !1 : Zl || !c(this, sl) || !c(bl, sl) || c(this, P) && this[P][sl] ? Zl : !0;
      }, v = function(sl, Zl) {
        if (sl = m(sl), Zl = R(Zl, !0), !(sl === el && c(bl, Zl) && !c($, Zl))) {
          var al = Y(sl, Zl);
          return al && c(bl, Zl) && !(c(sl, P) && sl[P][Zl]) && (al.enumerable = !0), al;
        }
      }, f = function(sl) {
        for (var Zl = Q(m(sl)), al = [], ol = 0, Xl; Zl.length > ol; )
          !c(bl, Xl = Zl[ol++]) && Xl != P && Xl != n && al.push(Xl);
        return al;
      }, j = function(sl) {
        for (var Zl = sl === el, al = Q(Zl ? $ : m(sl)), ol = [], Xl = 0, Gl; al.length > Xl; )
          c(bl, Gl = al[Xl++]) && (!Zl || c(el, Gl)) && ol.push(bl[Gl]);
        return ol;
      };
      nl || (w = function() {
        if (this instanceof w)
          throw TypeError("Symbol is not a constructor!");
        var sl = I(arguments.length > 0 ? arguments[0] : void 0), Zl = function(al) {
          this === el && Zl.call($, al), c(this, P) && c(this[P], sl) && (this[P][sl] = !1), E(this, sl, x(1, al));
        };
        return W && M && E(el, sl, { configurable: !0, set: Zl }), B(sl);
      }, e(w[k], "toString", function() {
        return this._k;
      }), K.f = v, F.f = U, l(182).f = T.f = f, l(169).f = N, J.f = j, W && !l(89) && e(el, "propertyIsEnumerable", N, !0), S.f = function(tl) {
        return B(h(tl));
      }), u(u.G + u.W + u.F * !nl, { Symbol: w });
      for (var A = (
        // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
        "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(",")
      ), dl = 0; A.length > dl; )
        h(A[dl++]);
      for (var il = r(h.store), cl = 0; il.length > cl; )
        p(il[cl++]);
      u(u.S + u.F * !nl, "Symbol", {
        // 19.4.2.1 Symbol.for(key)
        for: function(tl) {
          return c(_, tl += "") ? _[tl] : _[tl] = w(tl);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function(sl) {
          if (!g(sl))
            throw TypeError(sl + " is not a symbol!");
          for (var Zl in _)
            if (_[Zl] === sl)
              return Zl;
        },
        useSetter: function() {
          M = !0;
        },
        useSimple: function() {
          M = !1;
        }
      }), u(u.S + u.F * !nl, "Object", {
        // 19.1.2.2 Object.create(O [, Properties])
        create: L,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: U,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: o,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: v,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: f,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: j
      });
      var ml = G(function() {
        J.f(1);
      });
      u(u.S + u.F * ml, "Object", {
        getOwnPropertySymbols: function(sl) {
          return J.f(t(sl));
        }
      }), O && u(u.S + u.F * (!nl || G(function() {
        var tl = w();
        return q([tl]) != "[null]" || q({ a: tl }) != "{}" || q(Object(tl)) != "{}";
      })), "JSON", {
        stringify: function(sl) {
          for (var Zl = [sl], al = 1, ol, Xl; arguments.length > al; )
            Zl.push(arguments[al++]);
          if (Xl = ol = Zl[1], !(!b(ol) && sl === void 0 || g(sl)))
            return V(ol) || (ol = function(Gl, xl) {
              if (typeof Xl == "function" && (xl = Xl.call(this, Gl, xl)), !g(xl))
                return xl;
            }), Zl[1] = ol, q.apply(O, Zl);
        }
      }), w[k][D] || l(95)(w[k], D, w[k].valueOf), a(w, "Symbol"), a(Math, "Math", !0), a(s.JSON, "JSON", !0);
    },
    /* 178 */
    /***/
    function(Z, d, l) {
      d.f = l(122);
    },
    /* 179 */
    /***/
    function(Z, d, l) {
      var s = l(91), c = l(92), W = l(89), u = l(178), e = l(96).f;
      Z.exports = function(n) {
        var G = c.Symbol || (c.Symbol = W ? {} : s.Symbol || {});
        n.charAt(0) != "_" && !(n in G) && e(G, n, { value: u.f(n) });
      };
    },
    /* 180 */
    /***/
    function(Z, d, l) {
      var s = l(110), c = l(168), W = l(169);
      Z.exports = function(u) {
        var e = s(u), n = c.f;
        if (n)
          for (var G = n(u), y = W.f, a = 0, I; G.length > a; )
            y.call(u, I = G[a++]) && e.push(I);
        return e;
      };
    },
    /* 181 */
    /***/
    function(Z, d, l) {
      var s = l(84), c = l(182).f, W = {}.toString, u = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], e = function(n) {
        try {
          return c(n);
        } catch {
          return u.slice();
        }
      };
      Z.exports.f = function(G) {
        return u && W.call(G) == "[object Window]" ? e(G) : c(s(G));
      };
    },
    /* 182 */
    /***/
    function(Z, d, l) {
      var s = l(111), c = l(119).concat("length", "prototype");
      d.f = Object.getOwnPropertyNames || function(u) {
        return s(u, c);
      };
    },
    /* 183 */
    /***/
    function(Z, d, l) {
      var s = l(169), c = l(104), W = l(84), u = l(103), e = l(105), n = l(99), G = Object.getOwnPropertyDescriptor;
      d.f = l(100) ? G : function(a, I) {
        if (a = W(a), I = u(I, !0), n)
          try {
            return G(a, I);
          } catch {
          }
        if (e(a, I))
          return c(!s.f.call(a, I), a[I]);
      };
    },
    /* 184 */
    /***/
    function(Z, d, l) {
      l(179)("asyncIterator");
    },
    /* 185 */
    /***/
    function(Z, d, l) {
      l(179)("observable");
    },
    /* 186 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.createNowTime = s, d.formatDelay = c;
      function s() {
        var W = null;
        return Date.now ? W = Date.now : W = function() {
          return (/* @__PURE__ */ new Date()).getTime();
        }, W;
      }
      function c(W) {
        return typeof W == "number" ? W = { delay: W } : "entropy" in W && (W = { delay: W.entropy, isEntropy: !0 }), W;
      }
    },
    /* 187 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.default = {
        // s - startFrame, e - endFrame
        default: function(c, W, u, e, n) {
          return typeof c == "number" && typeof W == "number" ? c + (u - e) / (n - e) * (W - c) : u - e > n - u ? W : c;
        }
      };
    },
    /* 188 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      }), d.parseEasing = d.Easings = void 0;
      var s = l(76), c = G(s), W = l(133), u = G(W), e = l(141), n = G(e);
      function G(V) {
        return V && V.__esModule ? V : { default: V };
      }
      var y = l(189), a = new n.default();
      function I() {
        for (var V = arguments.length, i = Array(V), b = 0; b < V; b++)
          i[b] = arguments[b];
        var t = a.get(i);
        return t || (t = y.apply(void 0, i), a.set(i, t), t);
      }
      function h(V) {
        var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "end";
        return function(b, t) {
          for (var m = 1; m < t.length; m++) {
            var R = t[m].offset;
            if (b <= R) {
              var x = t[m - 1].offset, C = R, T = (b - x) / (C - x), K = 1 / V, J = T / K;
              return i === "end" ? J = Math.floor(J) : J = Math.ceil(J), K * J * (C - x) + x;
            }
          }
          return 0;
        };
      }
      function S(V) {
        var i = /^cubic-bezier\((.*)\)/, b = V.match(i);
        if (b) {
          var t = b[1].trim();
          return t = t.split(",").map(function(K) {
            return parseFloat(K.trim());
          }), I.apply(void 0, (0, u.default)(t));
        }
        if (i = /^steps\((.*)\)/, b = V.match(i), b) {
          var m = b[1].trim();
          m = m.split(",").map(function(K) {
            return K.trim();
          });
          var R = m, x = (0, c.default)(R, 2), C = x[0], T = x[1];
          return h(parseInt(C, 10), T);
        }
        return V;
      }
      var p = {
        linear: function(i) {
          return i;
        },
        ease: I(0.25, 0.1, 0.25, 1),
        "ease-in": I(0.42, 0, 1, 1),
        "ease-out": I(0, 0, 0.58, 1),
        "ease-in-out": I(0.42, 0, 0.58, 1),
        // 'step-start': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     ret = offset
        //     if(p < offset){
        //       break
        //     }
        //   }
        //   return ret
        // },
        // 'step-end': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     if(p < offset){
        //       break
        //     }
        //     ret = offset
        //   }
        //   return ret
        // }
        "step-start": h(1, "start"),
        "step-end": h(1, "end")
      };
      function X(V) {
        return typeof V == "string" ? p[V] ? V = p[V] : V = S(V) : V.type === "cubic-bezier" ? V = I.apply(void 0, (0, u.default)(V.value)) : V.type === "steps" && (V = h(V.step, V.pos)), V;
      }
      d.Easings = p, d.parseEasing = X;
    },
    /* 189 */
    /***/
    function(Z, d) {
      var l = 4, s = 1e-3, c = 1e-7, W = 10, u = 11, e = 1 / (u - 1), n = typeof Float32Array == "function";
      function G(V, i) {
        return 1 - 3 * i + 3 * V;
      }
      function y(V, i) {
        return 3 * i - 6 * V;
      }
      function a(V) {
        return 3 * V;
      }
      function I(V, i, b) {
        return ((G(i, b) * V + y(i, b)) * V + a(i)) * V;
      }
      function h(V, i, b) {
        return 3 * G(i, b) * V * V + 2 * y(i, b) * V + a(i);
      }
      function S(V, i, b, t, m) {
        var R, x, C = 0;
        do
          x = i + (b - i) / 2, R = I(x, t, m) - V, R > 0 ? b = x : i = x;
        while (Math.abs(R) > c && ++C < W);
        return x;
      }
      function p(V, i, b, t) {
        for (var m = 0; m < l; ++m) {
          var R = h(i, b, t);
          if (R === 0)
            return i;
          var x = I(i, b, t) - V;
          i -= x / R;
        }
        return i;
      }
      function X(V) {
        return V;
      }
      Z.exports = function(i, b, t, m) {
        if (!(0 <= i && i <= 1 && 0 <= t && t <= 1))
          throw new Error("bezier x values must be in [0, 1] range");
        if (i === b && t === m)
          return X;
        for (var R = n ? new Float32Array(u) : new Array(u), x = 0; x < u; ++x)
          R[x] = I(x * e, i, t);
        function C(T) {
          for (var K = 0, J = 1, F = u - 1; J !== F && R[J] <= T; ++J)
            K += e;
          --J;
          var r = (T - R[J]) / (R[J + 1] - R[J]), Y = K + r * e, H = h(Y, i, t);
          return H >= s ? p(T, Y, i, t) : H === 0 ? Y : S(T, K, K + e, i, t);
        }
        return function(K) {
          return K === 0 ? 0 : K === 1 ? 1 : I(C(K), b, m);
        };
      };
    },
    /* 190 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      });
      var s = l(191), c = b(s), W = l(204), u = b(W), e = l(164), n = b(e), G = l(170), y = b(G), a = l(171), I = b(a), h = l(175), S = b(h), p = l(75), X = b(p), V = l(208), i = l(188);
      function b(H) {
        return H && H.__esModule ? H : { default: H };
      }
      var t = (0, S.default)("timing"), m = (0, S.default)("keyframes"), R = (0, S.default)("initState"), x = (0, S.default)("readyDefer"), C = (0, S.default)("finishedDefer"), T = (0, S.default)("effects"), K = (0, S.default)("activeReadyTimer"), J = (0, S.default)("activeFinishTimer"), F = (0, S.default)("removeDefer"), r = {
        delay: 0,
        endDelay: 0,
        fill: "auto",
        iterations: 1,
        playbackRate: 1,
        direction: "normal",
        easing: "linear",
        effect: null
      }, Y = function() {
        function H(Q, w, O) {
          var q = this;
          if ((0, y.default)(this, H), Array.isArray(Q)) {
            var k = [Q[0], Q, w];
            Q = k[0], w = k[1], O = k[2];
          }
          typeof O == "number" && (O = { duration: O }), this[t] = (0, n.default)({}, r, O), this[t].easing = (0, i.parseEasing)(this[t].easing), this[m] = (0, V.calculateFramesOffset)(w);
          var P = this[m][this[m].length - 1];
          this[R] = {}, (0, u.default)(P).forEach(function(D) {
            Object.prototype.hasOwnProperty.call(Q, D) && D !== "easing" && D !== "offset" && (q[R][D] = Q[D]);
          }), this[m] = this[m].map(function(D) {
            return (0, n.default)({}, q[R], D);
          }), this[m][0].offset !== 0 && this[m].unshift((0, n.default)({}, this[R], { offset: 0 })), P.offset < 1 && this[m].push((0, n.default)({}, P, { offset: 1 })), this[T] = {}, this.timeline = null;
        }
        return (0, I.default)(H, [{
          key: "pause",
          value: function() {
            this.timeline.playbackRate = 0;
          }
        }, {
          key: K,
          value: function() {
            var w = this;
            this[x] && !this[x].timerID && (this.timeline.currentTime < 0 ? this[x].timerID = this.timeline.setTimeout(function() {
              w[x].resolve(), delete w[x];
            }, { delay: -this.timeline.currentTime, heading: !1 }) : this[x].timerID = this.timeline.setTimeout(function() {
              w[x].resolve(), delete w[x];
            }, { delay: 0, isEntropy: !0 }));
          }
        }, {
          key: J,
          value: function() {
            var w = this, O = this[t], q = O.duration, k = O.iterations, P = O.endDelay, D = Math.ceil(q * k + P - this.timeline.currentTime) + 1;
            this[C] && !this[C].timerID && (this[C].timerID = this.timeline.setTimeout(function() {
              w[C].resolve(), w[F](x), w[F](C);
            }, { delay: D, heading: !1 }), this[C].reverseTimerID = this.timeline.setTimeout(function() {
              w[C].resolve(), w[F](x), w[F](C), w.timeline = null;
            }, { delay: -this[t].delay - 1, heading: !1 }));
          }
        }, {
          key: "play",
          value: function() {
            if (this.playState === "finished" && this.cancel(), this.playState === "idle") {
              if (this.playbackRate <= 0)
                return;
              var w = this[t], O = w.delay, q = w.playbackRate, k = w.timeline;
              this.timeline = new X.default({
                originTime: O,
                playbackRate: q
              }, k), this[K](), this[J]();
            } else
              this.playState === "paused" && (this.timeline.playbackRate = this.playbackRate, this[K]());
          }
        }, {
          key: F,
          value: function(w) {
            var O = this[w], q = this.timeline;
            O && q && (q.clearTimeout(O.timerID), O.reverseTimerID && q.clearTimeout(O.reverseTimerID)), delete this[w];
          }
        }, {
          key: "cancel",
          value: function() {
            this[F](x), this[F](C), this.timeline = null;
          }
        }, {
          key: "finish",
          value: function() {
            this.timeline && (this.timeline.currentTime = 1 / 0 / this.playbackRate), this[F](x), this[F](C);
          }
        }, {
          key: "applyEffects",
          value: function(w) {
            return (0, n.default)(this[T], w);
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[t].playbackRate;
          },
          set: function(w) {
            this.timeline && (this.timeline.playbackRate = w), this[t].playbackRate = w;
          }
        }, {
          key: "playState",
          get: function() {
            var w = this.timeline, O = this[t], q = O.iterations, k = O.duration, P = O.endDelay, D = "running";
            if (w == null)
              D = "idle";
            else if (w.paused)
              D = "paused";
            else if (w.currentTime < 0)
              D = "pending";
            else {
              var ll = w.currentTime - q * k;
              ll > 0 && ll < P ? D = "pending" : ll >= P && (D = "finished");
            }
            return D;
          }
        }, {
          key: "progress",
          get: function() {
            if (!this.timeline)
              return 0;
            var w = this[t], O = w.duration, q = w.iterations, k = this.timeline, P = this.playState, D = void 0;
            if (P === "idle")
              D = 0;
            else if (P === "paused" && k.currentTime < 0)
              D = 0;
            else if (P === "pending")
              if (k.currentTime < 0)
                D = 0;
              else {
                var ll = k.seekLocalTime(q * O);
                D = (0, V.periodicity)(ll, O)[1] / O;
              }
            else
              (P === "running" || P === "paused") && (D = (0, V.periodicity)(k.currentTime, O)[1] / O);
            return P === "finished" && (D = (0, V.periodicity)(q, 1)[1]), D;
          }
        }, {
          key: "frame",
          get: function() {
            var w = this.playState, O = this[R], q = this[t].fill;
            if (w === "idle")
              return O;
            var k = this.timeline.currentTime, P = this[m].slice(0), D = (0, V.getProgress)(this.timeline, this[t], this.progress), ll = D.p, _ = D.inverted, bl = O;
            return k < 0 && w === "pending" ? (q === "backwards" || q === "both") && (bl = _ ? P[P.length - 1] : P[0]) : (w !== "pending" && w !== "finished" || q === "forwards" || q === "both") && (bl = (0, V.getCurrentFrame)(this[t], P, this[T], ll)), bl;
          }
        }, {
          key: "timing",
          get: function() {
            return this[t];
          }
        }, {
          key: "effects",
          get: function() {
            return this[T];
          }
        }, {
          key: "baseTimeline",
          set: function(w) {
            this[t].timeline = w;
          },
          get: function() {
            return this[t].timeline;
          }
        }, {
          key: "ready",
          get: function() {
            return this[x] ? this[x].promise : this.timeline && this.timeline.currentTime >= 0 && this.playState !== "paused" ? c.default.resolve() : (this[x] = (0, V.defer)(), this.timeline && this[K](), this[x] ? this[x].promise : c.default.resolve());
          }
        }, {
          key: "finished",
          get: function() {
            return this.playState === "finished" ? c.default.resolve() : (this[C] || (this[C] = (0, V.defer)(), this.timeline && this[J]()), this[C].promise);
          }
        }]), H;
      }();
      d.default = Y;
    },
    /* 191 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(192), __esModule: !0 };
    },
    /* 192 */
    /***/
    function(Z, d, l) {
      l(143), l(125), l(79), l(193), l(202), l(203), Z.exports = l(92).Promise;
    },
    /* 193 */
    /***/
    function(Z, d, l) {
      var s = l(89), c = l(91), W = l(93), u = l(128), e = l(90), n = l(98), G = l(94), y = l(147), a = l(148), I = l(194), h = l(195).set, S = l(197)(), p = l(198), X = l(199), V = l(200), i = l(201), b = "Promise", t = c.TypeError, m = c.process, R = m && m.versions, x = R && R.v8 || "", C = c[b], T = u(m) == "process", K = function() {
      }, J, F, r, Y, H = F = p.f, Q = !!function() {
        try {
          var _ = C.resolve(1), bl = (_.constructor = {})[l(122)("species")] = function($) {
            $(K, K);
          };
          return (T || typeof PromiseRejectionEvent == "function") && _.then(K) instanceof bl && x.indexOf("6.6") !== 0 && V.indexOf("Chrome/66") === -1;
        } catch {
        }
      }(), w = function(_) {
        var bl;
        return n(_) && typeof (bl = _.then) == "function" ? bl : !1;
      }, O = function(_, bl) {
        if (!_._n) {
          _._n = !0;
          var $ = _._c;
          S(function() {
            for (var el = _._v, nl = _._s == 1, z = 0, M = function(E) {
              var B = nl ? E.ok : E.fail, g = E.resolve, U = E.reject, o = E.domain, L, N, v;
              try {
                B ? (nl || (_._h == 2 && P(_), _._h = 1), B === !0 ? L = el : (o && o.enter(), L = B(el), o && (o.exit(), v = !0)), L === E.promise ? U(t("Promise-chain cycle")) : (N = w(L)) ? N.call(L, g, U) : g(L)) : U(el);
              } catch (f) {
                o && !v && o.exit(), U(f);
              }
            }; $.length > z; )
              M($[z++]);
            _._c = [], _._n = !1, bl && !_._h && q(_);
          });
        }
      }, q = function(_) {
        h.call(c, function() {
          var bl = _._v, $ = k(_), el, nl, z;
          if ($ && (el = X(function() {
            T ? m.emit("unhandledRejection", bl, _) : (nl = c.onunhandledrejection) ? nl({ promise: _, reason: bl }) : (z = c.console) && z.error && z.error("Unhandled promise rejection", bl);
          }), _._h = T || k(_) ? 2 : 1), _._a = void 0, $ && el.e)
            throw el.v;
        });
      }, k = function(_) {
        return _._h !== 1 && (_._a || _._c).length === 0;
      }, P = function(_) {
        h.call(c, function() {
          var bl;
          T ? m.emit("rejectionHandled", _) : (bl = c.onrejectionhandled) && bl({ promise: _, reason: _._v });
        });
      }, D = function(_) {
        var bl = this;
        bl._d || (bl._d = !0, bl = bl._w || bl, bl._v = _, bl._s = 2, bl._a || (bl._a = bl._c.slice()), O(bl, !0));
      }, ll = function(_) {
        var bl = this, $;
        if (!bl._d) {
          bl._d = !0, bl = bl._w || bl;
          try {
            if (bl === _)
              throw t("Promise can't be resolved itself");
            ($ = w(_)) ? S(function() {
              var el = { _w: bl, _d: !1 };
              try {
                $.call(_, W(ll, el, 1), W(D, el, 1));
              } catch (nl) {
                D.call(el, nl);
              }
            }) : (bl._v = _, bl._s = 1, O(bl, !1));
          } catch (el) {
            D.call({ _w: bl, _d: !1 }, el);
          }
        }
      };
      Q || (C = function(bl) {
        y(this, C, b, "_h"), G(bl), J.call(this);
        try {
          bl(W(ll, this, 1), W(D, this, 1));
        } catch ($) {
          D.call(this, $);
        }
      }, J = function(bl) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
      }, J.prototype = l(146)(C.prototype, {
        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function(bl, $) {
          var el = H(I(this, C));
          return el.ok = typeof bl == "function" ? bl : !0, el.fail = typeof $ == "function" && $, el.domain = T ? m.domain : void 0, this._c.push(el), this._a && this._a.push(el), this._s && O(this, !1), el.promise;
        },
        // 25.4.5.1 Promise.prototype.catch(onRejected)
        catch: function(_) {
          return this.then(void 0, _);
        }
      }), r = function() {
        var _ = new J();
        this.promise = _, this.resolve = W(ll, _, 1), this.reject = W(D, _, 1);
      }, p.f = H = function(_) {
        return _ === C || _ === Y ? new r(_) : F(_);
      }), e(e.G + e.W + e.F * !Q, { Promise: C }), l(121)(C, b), l(149)(b), Y = l(92)[b], e(e.S + e.F * !Q, b, {
        // 25.4.4.5 Promise.reject(r)
        reject: function(bl) {
          var $ = H(this), el = $.reject;
          return el(bl), $.promise;
        }
      }), e(e.S + e.F * (s || !Q), b, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function(bl) {
          return i(s && this === Y ? C : this, bl);
        }
      }), e(e.S + e.F * !(Q && l(140)(function(_) {
        C.all(_).catch(K);
      })), b, {
        // 25.4.4.1 Promise.all(iterable)
        all: function(bl) {
          var $ = this, el = H($), nl = el.resolve, z = el.reject, M = X(function() {
            var E = [], B = 0, g = 1;
            a(bl, !1, function(U) {
              var o = B++, L = !1;
              E.push(void 0), g++, $.resolve(U).then(function(N) {
                L || (L = !0, E[o] = N, --g || nl(E));
              }, z);
            }), --g || nl(E);
          });
          return M.e && z(M.v), el.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function(bl) {
          var $ = this, el = H($), nl = el.reject, z = X(function() {
            a(bl, !1, function(M) {
              $.resolve(M).then(el.resolve, nl);
            });
          });
          return z.e && nl(z.v), el.promise;
        }
      });
    },
    /* 194 */
    /***/
    function(Z, d, l) {
      var s = l(97), c = l(94), W = l(122)("species");
      Z.exports = function(u, e) {
        var n = s(u).constructor, G;
        return n === void 0 || (G = s(n)[W]) == null ? e : c(G);
      };
    },
    /* 195 */
    /***/
    function(Z, d, l) {
      var s = l(93), c = l(196), W = l(120), u = l(102), e = l(91), n = e.process, G = e.setImmediate, y = e.clearImmediate, a = e.MessageChannel, I = e.Dispatch, h = 0, S = {}, p = "onreadystatechange", X, V, i, b = function() {
        var m = +this;
        if (S.hasOwnProperty(m)) {
          var R = S[m];
          delete S[m], R();
        }
      }, t = function(m) {
        b.call(m.data);
      };
      (!G || !y) && (G = function(R) {
        for (var x = [], C = 1; arguments.length > C; )
          x.push(arguments[C++]);
        return S[++h] = function() {
          c(typeof R == "function" ? R : Function(R), x);
        }, X(h), h;
      }, y = function(R) {
        delete S[R];
      }, l(86)(n) == "process" ? X = function(m) {
        n.nextTick(s(b, m, 1));
      } : I && I.now ? X = function(m) {
        I.now(s(b, m, 1));
      } : a ? (V = new a(), i = V.port2, V.port1.onmessage = t, X = s(i.postMessage, i, 1)) : e.addEventListener && typeof postMessage == "function" && !e.importScripts ? (X = function(m) {
        e.postMessage(m + "", "*");
      }, e.addEventListener("message", t, !1)) : p in u("script") ? X = function(m) {
        W.appendChild(u("script"))[p] = function() {
          W.removeChild(this), b.call(m);
        };
      } : X = function(m) {
        setTimeout(s(b, m, 1), 0);
      }), Z.exports = {
        set: G,
        clear: y
      };
    },
    /* 196 */
    /***/
    function(Z, d) {
      Z.exports = function(l, s, c) {
        var W = c === void 0;
        switch (s.length) {
          case 0:
            return W ? l() : l.call(c);
          case 1:
            return W ? l(s[0]) : l.call(c, s[0]);
          case 2:
            return W ? l(s[0], s[1]) : l.call(c, s[0], s[1]);
          case 3:
            return W ? l(s[0], s[1], s[2]) : l.call(c, s[0], s[1], s[2]);
          case 4:
            return W ? l(s[0], s[1], s[2], s[3]) : l.call(c, s[0], s[1], s[2], s[3]);
        }
        return l.apply(c, s);
      };
    },
    /* 197 */
    /***/
    function(Z, d, l) {
      var s = l(91), c = l(195).set, W = s.MutationObserver || s.WebKitMutationObserver, u = s.process, e = s.Promise, n = l(86)(u) == "process";
      Z.exports = function() {
        var G, y, a, I = function() {
          var X, V;
          for (n && (X = u.domain) && X.exit(); G; ) {
            V = G.fn, G = G.next;
            try {
              V();
            } catch (i) {
              throw G ? a() : y = void 0, i;
            }
          }
          y = void 0, X && X.enter();
        };
        if (n)
          a = function() {
            u.nextTick(I);
          };
        else if (W && !(s.navigator && s.navigator.standalone)) {
          var h = !0, S = document.createTextNode("");
          new W(I).observe(S, { characterData: !0 }), a = function() {
            S.data = h = !h;
          };
        } else if (e && e.resolve) {
          var p = e.resolve(void 0);
          a = function() {
            p.then(I);
          };
        } else
          a = function() {
            c.call(s, I);
          };
        return function(X) {
          var V = { fn: X, next: void 0 };
          y && (y.next = V), G || (G = V, a()), y = V;
        };
      };
    },
    /* 198 */
    /***/
    function(Z, d, l) {
      var s = l(94);
      function c(W) {
        var u, e;
        this.promise = new W(function(n, G) {
          if (u !== void 0 || e !== void 0)
            throw TypeError("Bad Promise constructor");
          u = n, e = G;
        }), this.resolve = s(u), this.reject = s(e);
      }
      Z.exports.f = function(W) {
        return new c(W);
      };
    },
    /* 199 */
    /***/
    function(Z, d) {
      Z.exports = function(l) {
        try {
          return { e: !1, v: l() };
        } catch (s) {
          return { e: !0, v: s };
        }
      };
    },
    /* 200 */
    /***/
    function(Z, d, l) {
      var s = l(91), c = s.navigator;
      Z.exports = c && c.userAgent || "";
    },
    /* 201 */
    /***/
    function(Z, d, l) {
      var s = l(97), c = l(98), W = l(198);
      Z.exports = function(u, e) {
        if (s(u), c(e) && e.constructor === u)
          return e;
        var n = W.f(u), G = n.resolve;
        return G(e), n.promise;
      };
    },
    /* 202 */
    /***/
    function(Z, d, l) {
      var s = l(90), c = l(92), W = l(91), u = l(194), e = l(201);
      s(s.P + s.R, "Promise", { finally: function(n) {
        var G = u(this, c.Promise || W.Promise), y = typeof n == "function";
        return this.then(
          y ? function(a) {
            return e(G, n()).then(function() {
              return a;
            });
          } : n,
          y ? function(a) {
            return e(G, n()).then(function() {
              throw a;
            });
          } : n
        );
      } });
    },
    /* 203 */
    /***/
    function(Z, d, l) {
      var s = l(90), c = l(198), W = l(199);
      s(s.S, "Promise", { try: function(u) {
        var e = c.f(this), n = W(u);
        return (n.e ? e.reject : e.resolve)(n.v), e.promise;
      } });
    },
    /* 204 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(205), __esModule: !0 };
    },
    /* 205 */
    /***/
    function(Z, d, l) {
      l(206), Z.exports = l(92).Object.keys;
    },
    /* 206 */
    /***/
    function(Z, d, l) {
      var s = l(124), c = l(110);
      l(207)("keys", function() {
        return function(u) {
          return c(s(u));
        };
      });
    },
    /* 207 */
    /***/
    function(Z, d, l) {
      var s = l(90), c = l(92), W = l(101);
      Z.exports = function(u, e) {
        var n = (c.Object || {})[u] || Object[u], G = {};
        G[u] = e(n), s(s.S + s.F * W(function() {
          n(1);
        }), "Object", G);
      };
    },
    /* 208 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", {
        value: !0
      });
      var s = l(76), c = S(s), W = l(209), u = S(W), e = l(164), n = S(e), G = l(191), y = S(G);
      d.defer = p, d.periodicity = X, d.calculateFramesOffset = V, d.getProgress = i, d.getCurrentFrame = t;
      var a = l(188), I = l(187), h = S(I);
      function S(m) {
        return m && m.__esModule ? m : { default: m };
      }
      function p() {
        var m = {};
        return m.promise = new y.default(function(R, x) {
          m.resolve = R, m.reject = x;
        }), m;
      }
      function X(m, R) {
        var x = Math.floor(m / R), C = m - x * R;
        return C === 0 && x > 0 && (C = R, x--), [x, C];
      }
      function V(m) {
        m = m.slice(0);
        var R = m[0], x = m[m.length - 1];
        x.offset = x.offset || 1, R.offset = R.offset || 0;
        for (var C = 0, T = -1, K = 0; K < m.length; K++) {
          var J = m[K];
          if (J.offset != null) {
            var F = K - T;
            if (F > 1)
              for (var r = (J.offset - C) / F, Y = 0; Y < F - 1; Y++)
                m[T + Y + 1].offset = C + r * (Y + 1);
            C = J.offset, T = K;
          }
          if (J.easing != null && (J.easing = (0, a.parseEasing)(J.easing)), K > 0) {
            var H = m[K].easing != null;
            m[K] = (0, n.default)({}, m[K - 1], m[K]), H || delete m[K].easing;
          }
        }
        return m;
      }
      function i(m, R, x) {
        var C = m.currentTime, T = R.direction, K = R.duration, J = !1;
        if (T === "reverse")
          x = 1 - x, J = !0;
        else if (T === "alternate" || T === "alternate-reverse") {
          var F = Math.floor(C / K);
          x === 1 && F--, F % 2 ^ T === "alternate-reverse" && (x = 1 - x, J = !0);
        }
        return { p: x, inverted: J };
      }
      function b(m, R, x, C) {
        var T = {};
        return (0, u.default)(R).forEach(function(K) {
          var J = (0, c.default)(K, 2), F = J[0], r = J[1];
          if (F !== "offset" && F !== "easing") {
            var Y = x[F] || x.default, H = Y(m[F], r, C, m.offset, R.offset);
            H != null && (T[F] = H);
          }
        }), T;
      }
      function t(m, R, x, C) {
        var T = m.easing, K = m.effect;
        K || (x = (0, n.default)({}, h.default, x));
        var J = {};
        C = T(C, R);
        for (var F = 1; F < R.length; F++) {
          var r = R[F], Y = r.offset;
          if (Y >= C || F === R.length - 1) {
            var H = R[F - 1], Q = H.offset, w = H.easing, O = C;
            if (w) {
              var q = Y - Q;
              O = w((C - Q) / q) * q + Q;
            }
            K ? J = K(H, r, O, Q, Y) : J = b(H, r, x, O);
            break;
          }
        }
        return J;
      }
    },
    /* 209 */
    /***/
    function(Z, d, l) {
      Z.exports = { default: l(210), __esModule: !0 };
    },
    /* 210 */
    /***/
    function(Z, d, l) {
      l(211), Z.exports = l(92).Object.entries;
    },
    /* 211 */
    /***/
    function(Z, d, l) {
      var s = l(90), c = l(212)(!0);
      s(s.S, "Object", {
        entries: function(u) {
          return c(u);
        }
      });
    },
    /* 212 */
    /***/
    function(Z, d, l) {
      var s = l(100), c = l(110), W = l(84), u = l(169).f;
      Z.exports = function(e) {
        return function(n) {
          for (var G = W(n), y = c(G), a = y.length, I = 0, h = [], S; a > I; )
            S = y[I++], (!s || u.call(G, S)) && h.push(e ? [S, G[S]] : G[S]);
          return h;
        };
      };
    },
    /* 213 */
    /***/
    function(Z, d, l) {
      l.r(d), l(1).glMatrix.setMatrixArrayType(Array);
      const s = /* @__PURE__ */ new Map();
      function c(u, e = {}, n = []) {
        u = u.toLowerCase();
        const G = s.get(u);
        if (!G)
          throw new TypeError(`Invalid node: ${u}`);
        const y = new G(e);
        return n.forEach((a) => {
          y.appendChild(a);
        }), y;
      }
      const W = {
        registerNode(u, e, n = 100) {
          if (e = e.toLowerCase(), s.has(e))
            throw new TypeError(`Cannot registerNode, ${e} has been taken.`);
          s.set(e, u), Object.defineProperties(u.prototype, {
            nodeType: {
              value: n
            },
            tagName: {
              value: e.toUpperCase()
            },
            nodeName: {
              value: e
            },
            ownerDocument: {
              value: W
            },
            namespaceURI: {
              value: `http://spritejs.com/${e}`
            }
          });
        },
        createElement: c,
        createElementNS(u, e) {
          return c(e);
        },
        isSpriteNode(u) {
          return s.has(u.toLowerCase());
        }
      };
      d.default = W;
    },
    /* 214 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      const s = Symbol("type"), c = Symbol("bubbles"), W = Symbol("originalEvent"), u = Symbol("detail");
      class e {
        constructor(G, {
          bubbles: y = null
        } = {}) {
          if (typeof G == "string" ? (this[s] = G, this[c] = !!y) : (this[s] = G.type, this[W] = G, this[c] = y != null ? !!y : !!G.bubbles, G.detail && (this[u] = G.detail)), !this[s])
            throw new TypeError("Invalid event type.");
          this.cancelBubble = !1;
        }
        setOriginalEvent(G) {
          this[W] = G;
        }
        get originalEvent() {
          return this[W];
        }
        get type() {
          return this[s];
        }
        get bubbles() {
          return this[c];
        }
        get detail() {
          return this[u];
        }
        stopPropagation() {
          this.cancelBubble = !0;
        }
      }
    },
    /* 215 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "parseFilterString", function() {
        return c;
      }), l.d(d, "applyFilters", function() {
        return W;
      });
      var s = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      function c(u) {
        if (u = u.trim(), !u || u === "none")
          return null;
        const e = /^(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+$/i, n = u.match(/(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+?/ig), G = [];
        return n && n.forEach((y) => {
          const a = y.match(e);
          if (!a)
            throw new TypeError("Invalid fitler string.");
          let [, I, h] = a;
          I = I.toLowerCase(), h = h.trim().match(/([^( )]+|([^( )]+\(.*\)))(?=\s|$)/g).map((S, p) => {
            let X;
            return I === "url" || I === "drop-shadow" && p === 3 ? X = S : X = Object(s.toNumber)(S), /%$/.test(S) && (X /= 100), X;
          }), G.push({
            type: I,
            args: h
          });
        }), G;
      }
      function W(u, e) {
        u.clearFilter(), e && e.forEach(({
          type: n,
          args: G
        }) => {
          let y = n;
          y === "drop-shadow" ? y = "dropShadow" : y === "hue-rotate" && (y = "hueRotate"), u[y](...G);
        });
      }
    },
    /* 216 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return s;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s(c, W) {
        if (!W)
          return;
        const u = c.getListeners("beforerender"), e = c.getListeners("afterrender");
        u.length && !W.beforeRender ? W.beforeRender = (n) => {
          c.dispatchEvent({
            type: "beforerender",
            detail: {
              context: n
            }
          });
        } : u.length || (W.beforeRender = null), e.length && !W.afterRender ? W.afterRender = (n) => {
          c.dispatchEvent({
            type: "afterrender",
            detail: {
              context: n
            }
          });
        } : e.length || (W.afterRender = null);
      }
    },
    /* 217 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var s = l(12), c = l(218), W = l(70), u = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      const e = Symbol("amount"), n = Symbol("meshCloud");
      class G extends W.default {
        constructor(a, I = 1) {
          super(), this.meshNode = a, a.connect(this), this[e] = I, this[n] = null;
        }
        get meshCloud() {
          const a = this.meshNode, I = this[e];
          return !this[n] && a.mesh && (this[n] = new s.MeshCloud(a.mesh, I)), this[n];
        }
        /* override */
        get isVisible() {
          return !!this.meshNode && this.meshNode.isVisible;
        }
        get amount() {
          return this[e];
        }
        set amount(a) {
          this[e] = a, this[n] && (this[n].amount = a);
        }
        brightness(a, I) {
          this.meshCloud && (this.meshCloud.brightness(a, I), this.forceUpdate());
        }
        contrast(a, I) {
          this.meshCloud && (this.meshCloud.contrast(a, I), this.forceUpdate());
        }
        delete(a) {
          this.meshCloud && (this.meshCloud.delete(a), this[e]--, this.forceUpdate());
        }
        /* override */
        draw(a = []) {
          if (super.draw(a), this.meshCloud) {
            if (this.program) {
              this.meshCloud.setProgram(this.program);
              const I = this.shaderAttrs;
              I && Object.entries(I).forEach(([S, p]) => {
                this.meshCloud.mesh.setAttribute(S, p);
              });
              const h = this.uniforms;
              if (this.uniforms) {
                const S = {};
                Object.entries(h).forEach(([p, X]) => {
                  typeof X == "function" && (X = X(this, p)), S[p] = X;
                }), this.meshCloud.mesh.setUniforms(S);
              }
            }
            this.meshNode.textureImage && Object(c.drawTexture)(this.meshNode, this.meshNode.mesh), a.push(this.meshCloud);
          }
          return a;
        }
        getTransform(a) {
          if (this.meshCloud)
            return this.meshCloud.getTransform(a);
        }
        grayscale(a, I) {
          this.meshCloud && (this.meshCloud.grayscale(a, I), this.forceUpdate());
        }
        hueRotate(a, I) {
          this.meshCloud && (this.meshCloud.hueRotate(a, I), this.forceUpdate());
        }
        invert(a, I) {
          this.meshCloud && (this.meshCloud.invert(a, I), this.forceUpdate());
        }
        /* override */
        isPointCollision(a, I) {
          if (!this.meshCloud)
            return !1;
          const h = this.attributes.pointerEvents;
          if (h === "none" || h !== "all" && !this.isVisible)
            return !1;
          let S = "both";
          h === "visibleFill" && (S = "fill"), h === "visibleStroke" && (S = "stroke");
          for (let p = 0; p < this[e]; p++)
            if (!this.meshCloud.isPointCollision(p, [a, I], S))
              return !1;
          return !0;
        }
        setOpacity(a, I) {
          this.meshCloud && (this.meshCloud.opacity(a, I), this.forceUpdate());
        }
        rotate(a, I, [h, S] = [0, 0]) {
          const p = Math.PI * I / 180;
          if (this.meshCloud) {
            const {
              x: X,
              y: V
            } = this.meshNode.attributes;
            this.meshCloud.rotate(a, p, [h + X, S + V]), this.forceUpdate();
          }
        }
        saturate(a, I) {
          this.meshCloud && (this.meshCloud.saturate(a, I), this.forceUpdate());
        }
        scale(a, [I, h = I], [S, p] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: X,
              y: V
            } = this.meshNode.attributes, i = 1e-5;
            Math.abs(I) < i && (I = 1 / I > 0 ? i : -i), Math.abs(h) < i && (h = 1 / h > 0 ? i : -i), this.meshCloud.scale(a, [I, h], [S + X, p + V]), this.forceUpdate();
          }
        }
        setColorTransform(a, I) {
          this.meshCloud && (this.meshCloud.setColorTransform(a, I), this.forceUpdate());
        }
        setFillColor(a, I) {
          this.meshCloud && (Array.isArray(I) && (I = [...I], I[0] /= 255, I[1] /= 255, I[2] /= 255), this.meshCloud.setFillColor(a, I), this.forceUpdate());
        }
        sepia(a, I) {
          this.meshCloud && (this.meshCloud.sepia(a, I), this.forceUpdate());
        }
        /* override */
        setResolution({
          width: a,
          height: I
        }) {
          super.setResolution({
            width: a,
            height: I
          }), this.meshNode.setResolution({
            width: a,
            height: I
          });
        }
        setStrokeColor(a, I) {
          this.meshCloud && (Array.isArray(I) && (I = [...I], I[0] /= 255, I[1] /= 255, I[2] /= 255), this.meshCloud.setStrokeColor(a, I), this.forceUpdate());
        }
        setTransform(a, I) {
          this.meshCloud && (this.meshCloud.setTransform(a, I), this.forceUpdate());
        }
        skew(a, [I, h = I], [S, p] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: X,
              y: V
            } = this.meshNode.attributes;
            this.meshCloud.skew(a, [I, h], [S + X, p + V]), this.forceUpdate();
          }
        }
        transform(a, I) {
          this.meshCloud && (this.meshCloud.transform(a, I), this.forceUpdate());
        }
        transformColor(a, I) {
          this.meshCloud && (this.meshCloud.transformColor(a, I), this.forceUpdate());
        }
        translate(a, [I, h]) {
          this.meshCloud && (this.meshCloud.translate(a, [I, h]), this.forceUpdate());
        }
        updateMesh() {
          this[n] && (this[n].mesh = this.meshNode.mesh, this.forceUpdate());
        }
      }
      u.default.registerNode(G, "cloud");
    },
    /* 218 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "loadTexture", function() {
        return u;
      }), l.d(d, "applyTexture", function() {
        return e;
      }), l.d(d, "createTexture", function() {
        return G;
      }), l.d(d, "deleteTexture", function() {
        return y;
      }), l.d(d, "drawTexture", function() {
        return I;
      }), l.d(d, "loadFrames", function() {
        return h;
      });
      var s = l(12), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const W = {};
      function u(S, p) {
        if (W[S])
          return W[S];
        const X = s.ENV.loadImage(S, {
          alias: p,
          useImageBitmap: !1
        });
        return X ?? S;
      }
      async function e(S, p, X) {
        let V = p;
        if (typeof p == "string" && (V = u(p)), V && typeof V.then == "function" && (V = await V), p === S.attributes.texture) {
          V && V.image && (V.sourceRect && (S.attributes.sourceRect = V.sourceRect), S.textureImageRotated = !!V.rotated, V = V.image);
          const {
            width: i,
            height: b,
            textureRect: t
          } = S.attributes, m = S.textureImage;
          S.textureImage = V, X && m !== V && !t && (i == null || b == null) && S.updateContours(), S.forceUpdate();
        }
        return V;
      }
      const n = Symbol("textureMap");
      function G(S, p) {
        if (p[n] = p[n] || /* @__PURE__ */ new Map(), p[n].has(S))
          return p[n].get(S);
        const X = p.createTexture(S);
        return !/^blob:/.test(S.src) && typeof S.getContext != "function" && p[n].set(S, X), X;
      }
      function y(S, p) {
        if (p[n] && p[n].has(S)) {
          const X = p[n].get(S);
          return p.deleteTexture(X), p[n].delete(S), !0;
        }
        return !1;
      }
      const a = Symbol("textureContext");
      function I(S, p) {
        const X = S.textureImage instanceof String ? String(S.textureImage) : S.textureImage, V = S.textureImageRotated, i = p.texture, b = S.renderer;
        if (X) {
          const t = S.originalContentRect;
          let m = S.attributes.textureRect;
          const R = S.attributes.textureRepeat, x = S.attributes.sourceRect;
          if (!i || S[a] && S[a] !== b || i.image !== X || i.options.repeat !== R || !Object(c.compareValue)(i.options.rect, m) || !Object(c.compareValue)(i.options.srcRect, x)) {
            const C = G(X, b);
            m ? (m[0] += t[0], m[1] += t[1]) : m = t;
            let T = null;
            i && !b[n].has(i.image) && (!i.options || !i.options.hidden) && (T = p.uniforms.u_texSampler), p.setTexture(C, {
              rect: m,
              repeat: R,
              srcRect: x,
              rotated: V
            }), T && T.delete && T.delete(), S[a] = b;
          }
        } else if (i) {
          let t = null;
          !b[n].has(i.image) && (!i.options || !i.options.hidden) && (t = p.uniforms.u_texSampler), p.setTexture(null), t && t.delete && t.delete();
        }
      }
      async function h(S, p) {
        typeof p == "string" && (p = await (await fetch(p, {
          method: "GET",
          mode: "cors",
          cache: "default"
        })).json());
        const X = await u(S), V = p.frames;
        return Object.entries(V).forEach(([i, b]) => {
          const {
            x: t,
            y: m,
            w: R,
            h: x
          } = b.frame;
          let C = [t, m, R, x];
          const T = b.rotated;
          T && (C = [C[0], C[1], C[3], C[2]]), W[i] = {
            image: X,
            sourceRect: C,
            rotated: T
          };
        }), X;
      }
    },
    /* 219 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return h;
      });
      var s = l(1), c = l(12), W = l(70), u = l(220), e = l(221), n = l(222), G = l(213), y = l(223);
      l(1).glMatrix.setMatrixArrayType(Array);
      function a(S, p, X) {
        return p in S ? Object.defineProperty(S, p, { value: X, enumerable: !0, configurable: !0, writable: !0 }) : S[p] = X, S;
      }
      const I = Symbol("mesh");
      class h extends W.default {
        constructor(p = {}) {
          super(p);
        }
        get borderSize() {
          const {
            paddingTop: p,
            paddingRight: X,
            paddingBottom: V,
            paddingLeft: i,
            borderWidth: b
          } = this.attributes, [t, m] = this.contentSize;
          return [i + t + X + b, p + m + V + b];
        }
        // content + padding
        get clientSize() {
          const {
            paddingTop: p,
            paddingRight: X,
            paddingBottom: V,
            paddingLeft: i
          } = this.attributes, [b, t] = this.contentSize;
          return [i + b + X, p + t + V];
        }
        get contentSize() {
          let {
            width: p,
            height: X,
            boxSizing: V,
            paddingTop: i,
            paddingRight: b,
            paddingBottom: t,
            paddingLeft: m
          } = this.attributes;
          if (p = p || 0, X = X || 0, V === "border-box") {
            const R = 2 * this.attributes.borderWidth;
            p -= R + b + m, X -= R + i + t, p = Math.max(0, p), X = Math.max(0, X);
          }
          return [p, X];
        }
        get hasBorder() {
          return this.attributes.borderWidth > 0;
        }
        /* override */
        get isVisible() {
          const [p, X] = this.borderSize;
          return p > 0 && X > 0;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const p = this.clientBox;
          if (p) {
            let X = this[I];
            if (X)
              X.box !== p && (X.contours = p.contours, X.box = p);
            else {
              X = new c.Mesh2D(p), X.box = p;
              const i = this.attributes.bgcolor;
              if (Object(e.setFillColor)(X, {
                color: i
              }), this.hasBorder) {
                const {
                  borderColor: t,
                  borderWidth: m,
                  borderDash: R,
                  borderDashOffset: x
                } = this.attributes;
                Object(e.setStrokeColor)(X, {
                  color: t,
                  lineWidth: m,
                  lineDash: R,
                  lineDashOffset: x
                });
              }
              this[I] = X;
              const b = this.attributes.clipPath;
              b && this[I].setClipPath(b);
            }
            const V = this.opacity;
            return X.getOpacity() !== V && X.setOpacity(V), X.setTransform(...this.renderMatrix), X;
          }
          return null;
        }
        // content + padding + border
        get offsetSize() {
          const {
            paddingTop: p,
            paddingRight: X,
            paddingBottom: V,
            paddingLeft: i,
            borderWidth: b
          } = this.attributes, [t, m] = this.contentSize, R = 2 * b;
          return [i + t + X + R, p + m + V + R];
        }
        get originalClientRect() {
          if (this.mesh) {
            const p = this.mesh.boundingBox;
            return [p[0][0], p[0][1], p[1][0] - p[0][0], p[1][1] - p[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalContentRect() {
          const [p, X, V, i] = this.originalClientRect, b = this.attributes.padding;
          return [p + b[0], X + b[1], V - b[0] - b[2], i - b[1] - b[3]];
        }
        getBoundingClientRect() {
          let p = this.renderMatrix;
          this.layer && this.layer.layerTransformInvert && (p = s.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), this.layer.transformMatrix, p));
          let X = null;
          if (this.mesh) {
            X = [...this.mesh.boundingBox];
            const V = this.attributes.borderWidth;
            V && (X[0] = [X[0][0] - V, X[0][1] - V], X[1] = [X[1][0] + V, X[1][1] + V]);
          }
          return Object(y.default)(X, p);
        }
        // transformPoint(x, y) {
        //   const m = mat2d.invert(this.renderMatrix);
        //   const newX = x * m[0] + y * m[2] + m[4];
        //   const newY = x * m[1] + y * m[3] + m[5];
        //   return [newX, newY];
        // }
        /* override */
        onPropertyChange(p, X, V) {
          if (super.onPropertyChange(p, X, V), (p === "anchorX" || p === "anchorY" || p === "boxSizing" || p === "width" || p === "height" || p === "borderWidth" || p === "paddingLeft" || p === "paddingRight" || p === "paddingTop" || p === "paddingBottom" || /^border(TopLeft|TopRight|BottomRight|BottomLeft)Radius$/.test(p)) && this.updateContours(), this[I] && p === "clipPath" && this[I].setClipPath(X), this[I] && p === "bgcolor" && Object(e.setFillColor)(this[I], {
            color: X
          }), this[I] && (p === "borderColor" || p === "borderWidth" || p === "borderDash" || p === "borderDashOffset")) {
            const {
              borderColor: i,
              borderWidth: b,
              borderDash: t,
              borderDashOffset: m
            } = this.attributes;
            Object(e.setStrokeColor)(this[I], {
              color: i,
              lineWidth: b,
              lineDash: b ? t : 0,
              lineDashOffset: m
            });
          }
        }
        /* override */
        updateContours() {
          const {
            anchorX: p,
            anchorY: X,
            borderWidth: V,
            borderRadius: i
          } = this.attributes, [b, t] = this.borderSize, m = this.offsetSize, R = 0.5 * V, x = -p * m[0] + R, C = -X * m[1] + R;
          this.clientBox = new c.Figure2D(), Object(n.createRadiusBox)(this.clientBox, [x, C, b, t], i);
        }
      }
      a(h, "Attr", u.default), G.default.registerNode(h, "block");
    },
    /* 220 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return y;
      });
      var s = l(71), c = l(72), W = l(221);
      l(1).glMatrix.setMatrixArrayType(Array);
      const u = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), n = Symbol.for("spritejs_setAttributeDefault"), G = Symbol.for("spritejs_declareAlias");
      class y extends s.default {
        constructor(I) {
          super(I), this[n]({
            anchorX: 0,
            anchorY: 0,
            /* anchor */
            width: void 0,
            height: void 0,
            /* size */
            borderWidth: 0,
            borderColor: "rgba(0,0,0,1)",
            /* border */
            borderDash: void 0,
            borderDashOffset: 0,
            borderTopLeftRadius: [0, 0],
            borderTopRightRadius: [0, 0],
            borderBottomRightRadius: [0, 0],
            borderBottomLeftRadius: [0, 0],
            /* borderRadius */
            bgcolor: "rgba(0,0,0,0)",
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            /* padding */
            boxSizing: "content-box",
            clipPath: void 0
          }), this[G]("anchor", "size", "border", "borderRadius", "padding");
        }
        get anchorX() {
          return this[e]("anchorX");
        }
        set anchorX(I) {
          this[u]("anchorX", Object(c.toNumber)(I));
        }
        get anchorY() {
          return this[e]("anchorY");
        }
        set anchorY(I) {
          this[u]("anchorY", Object(c.toNumber)(I));
        }
        get anchor() {
          return [this.anchorX, this.anchorY];
        }
        set anchor(I) {
          I = Object(c.toArray)(I), Array.isArray(I) || (I = [I, I]), this.anchorX = I[0], this.anchorY = I[1];
        }
        get width() {
          return this[e]("width");
        }
        set width(I) {
          this[u]("width", Object(c.toNumber)(I));
        }
        get height() {
          return this[e]("height");
        }
        set height(I) {
          this[u]("height", Object(c.toNumber)(I));
        }
        get size() {
          return [this.width, this.height];
        }
        set size(I) {
          I = Object(c.toArray)(I), Array.isArray(I) || (I = [I, I]), this.width = I[0], this.height = I[1];
        }
        get borderWidth() {
          return this[e]("borderWidth");
        }
        set borderWidth(I) {
          this[u]("borderWidth", Object(c.toNumber)(I));
        }
        get borderColor() {
          return this[e]("borderColor");
        }
        set borderColor(I) {
          this[u]("borderColor", Object(W.parseColor)(I));
        }
        get border() {
          return [this.borderWidth, this.borderColor];
        }
        set border(I) {
          I = Object(c.toArray)(I), Array.isArray(I) || (I = [I]), this.borderWidth = I[0], I[1] != null && (this.borderColor = I[1]);
        }
        get borderDash() {
          return this[e]("borderDash");
        }
        set borderDash(I) {
          I = Object(c.toArray)(I, !0), I != null && !Array.isArray(I) && (I = [I]), this[u]("borderDash", I ? I.map(c.toNumber) : null);
        }
        get borderDashOffset() {
          return this[e]("borderDashOffset");
        }
        set borderDashOffset(I) {
          this[u]("borderDashOffset", Object(c.toNumber)(I));
        }
        get borderTopLeftRadius() {
          return this[e]("borderTopLeftRadius");
        }
        set borderTopLeftRadius(I) {
          I = Object(c.toArray)(I, !0), Array.isArray(I) || (I = [I, I]), this[u]("borderTopLeftRadius", I.map(c.toNumber));
        }
        get borderTopRightRadius() {
          return this[e]("borderTopRightRadius");
        }
        set borderTopRightRadius(I) {
          I = Object(c.toArray)(I, !0), Array.isArray(I) || (I = [I, I]), this[u]("borderTopRightRadius", I.map(c.toNumber));
        }
        get borderBottomRightRadius() {
          return this[e]("borderBottomRightRadius");
        }
        set borderBottomRightRadius(I) {
          I = Object(c.toArray)(I, !0), Array.isArray(I) || (I = [I, I]), this[u]("borderBottomRightRadius", I.map(c.toNumber));
        }
        get borderBottomLeftRadius() {
          return this[e]("borderBottomLeftRadius");
        }
        set borderBottomLeftRadius(I) {
          I = Object(c.toArray)(I, !0), Array.isArray(I) || (I = [I, I]), this[u]("borderBottomLeftRadius", I.map(c.toNumber));
        }
        get borderRadius() {
          return [...this.borderTopLeftRadius, ...this.borderTopRightRadius, ...this.borderBottomRightRadius, ...this.borderBottomLeftRadius];
        }
        set borderRadius(I) {
          if (I = Object(c.toArray)(I), !Array.isArray(I))
            I = Array(8).fill(I);
          else if (I.length === 2)
            I = [I[0], I[1], I[0], I[1], I[0], I[1], I[0], I[1]];
          else if (I.length === 4)
            I = [I[0], I[1], I[2], I[3], I[0], I[1], I[2], I[3]];
          else if (I.length === 6)
            I = [I[0], I[1], I[2], I[3], I[4], I[5], I[2], I[3]];
          else if (I.length !== 8)
            throw new TypeError("Invalid borderRadius value.");
          this.borderTopLeftRadius = [I[0], I[1]], this.borderTopRightRadius = [I[2], I[3]], this.borderBottomRightRadius = [I[4], I[5]], this.borderBottomLeftRadius = [I[6], I[7]];
        }
        get bgcolor() {
          return this[e]("bgcolor");
        }
        set bgcolor(I) {
          this[u]("bgcolor", Object(W.parseColor)(I));
        }
        get paddingTop() {
          return this[e]("paddingTop");
        }
        set paddingTop(I) {
          this[u]("paddingTop", Object(c.toNumber)(I));
        }
        get paddingRight() {
          return this[e]("paddingRight");
        }
        set paddingRight(I) {
          this[u]("paddingRight", Object(c.toNumber)(I));
        }
        get paddingBottom() {
          return this[e]("paddingBottom");
        }
        set paddingBottom(I) {
          this[u]("paddingBottom", Object(c.toNumber)(I));
        }
        get paddingLeft() {
          return this[e]("paddingLeft");
        }
        set paddingLeft(I) {
          this[u]("paddingLeft", Object(c.toNumber)(I));
        }
        get padding() {
          return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
        }
        set padding(I) {
          I = Object(c.toArray)(I), Array.isArray(I) ? I.length === 2 ? I = [I[0], I[1], I[0], I[1]] : I.length === 3 && (I = [I[0], I[1], I[2], I[1]]) : I = [I, I, I, I], this.paddingTop = I[0], this.paddingRight = I[1], this.paddingBottom = I[2], this.paddingLeft = I[3];
        }
        get clipPath() {
          return this[e]("clipPath");
        }
        set clipPath(I) {
          this[u]("clipPath", I);
        }
        get boxSizing() {
          return this[e]("boxSizing");
        }
        set boxSizing(I) {
          if (I != null && I !== "border-box" && I !== "content-box")
            throw new TypeError("Invalid boxSizing type.");
          this[u]("boxSizing", I);
        }
      }
    },
    /* 221 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "Gradient", function() {
        return W;
      }), l.d(d, "isTransparent", function() {
        return u;
      }), l.d(d, "parseColor", function() {
        return e;
      }), l.d(d, "setFillColor", function() {
        return G;
      }), l.d(d, "setStrokeColor", function() {
        return y;
      }), l.d(d, "Color", function() {
        return a;
      });
      var s = l(32), c = /* @__PURE__ */ l.n(s);
      l(1).glMatrix.setMatrixArrayType(Array);
      class W {
        constructor({
          vector: h,
          colors: S
        }) {
          if (!Array.isArray(h) || h.length !== 4 && h.length !== 6 && h.length !== 3)
            throw new TypeError("Invalid gradient");
          this.vector = h, this.colors = S.map(({
            offset: p,
            color: X
          }) => ({
            offset: p,
            color: e(X)
          }));
        }
        toString() {
          return JSON.stringify({
            vector: this.vector,
            colors: this.colors
          });
        }
      }
      function u(I) {
        return I instanceof W ? !1 : I == null ? !0 : c()(I)[3] === 0;
      }
      function e(I) {
        if (I == null || (I || (I = "transparent"), I instanceof W))
          return I;
        const h = c()(I);
        if (!h || !h.length)
          throw new TypeError("Invalid color value.");
        return `rgba(${h.join()})`;
      }
      function n(I, h, S) {
        const p = I.boundingBox[0];
        if (S.vector) {
          let {
            vector: X,
            colors: V
          } = S;
          X.length === 4 ? (X = [X[0] + p[0], X[1] + p[1], X[2] + p[0], X[3] + p[1]], I.setLinearGradient({
            vector: X,
            colors: V,
            type: h
          })) : X.length === 3 ? (X = [X[0] + p[0], X[1] + p[1], X[2]], I.setCircularGradient({
            vector: X,
            colors: V,
            type: h
          })) : (X = [X[0] + p[0], X[1] + p[1], X[2], X[3] + p[0], X[4] + p[1], X[5]], I.setRadialGradient({
            vector: X,
            colors: V,
            type: h
          }));
        } else
          I.gradient && I.gradient[h] && (delete I.gradient[h], delete I.uniforms.u_radialGradientVector);
      }
      function G(I, {
        color: h,
        rule: S = "nonzero"
      }) {
        return n(I, "fill", h), h.vector || I.setFill({
          color: h,
          rule: S
        }), I;
      }
      function y(I, {
        color: h,
        lineWidth: S,
        lineCap: p,
        lineJoin: X,
        lineDash: V,
        lineDashOffset: i,
        miterLimit: b,
        roundSegments: t
      }) {
        n(I, "stroke", h), h.vector && (h = [0, 0, 0, 1]), I.setStroke({
          color: h,
          thickness: S,
          cap: p,
          join: X,
          miterLimit: b,
          lineDash: V,
          lineDashOffset: i,
          roundSegments: t
        });
      }
      class a extends Array {
        constructor(h = 0, S = 0, p = 0, X = 0) {
          return Array.isArray(h) && ([h, S, p, X] = h), typeof h == "string" && ([h, S, p, X] = c()(h), h /= 255, S /= 255, p /= 255), super(h, S, p, X), this;
        }
        get r() {
          return Math.round(this[0] * 255);
        }
        set r(h) {
          this[0] = h / 255;
        }
        get g() {
          return Math.round(this[1] * 255);
        }
        set g(h) {
          this[1] = h / 255;
        }
        get b() {
          return Math.round(this[2] * 255);
        }
        set b(h) {
          this[2] = h / 255;
        }
        get a() {
          return this[3];
        }
        set a(h) {
          this[3] = h;
        }
        get hex() {
          const h = `0${this.r.toString(16)}`.slice(-2), S = `0${this.g.toString(16)}`.slice(-2), p = `0${this.b.toString(16)}`.slice(-2);
          let X;
          return this.a < 1 && (X = Math.round(this[3] * 255), X = `0${X.toString(16)}`.slice(-2)), `#${h}${S}${p}${X || ""}`;
        }
        get rgba() {
          return `rgba(${this.r},${this.g},${this.b},${this.a})`;
        }
        fromColor(h) {
          return typeof h == "string" && (h = c()(h), h[0] /= 255, h[1] /= 255, h[2] /= 255), this[0] = h[0], this[1] = h[1], this[2] = h[2], this[3] = h[3], this;
        }
      }
    },
    /* 222 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "createRadiusBox", function() {
        return c;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s(W, u, e, n, G, y = "leftTop") {
        const a = 0.5522848, I = n / 2 * a, h = G / 2 * a, S = u + n, p = e + G, X = u + n / 2, V = e + G / 2;
        y === "leftTop" ? (W.moveTo(u, V), W.bezierCurveTo(u, V - h, X - I, e, X, e)) : y === "rightTop" ? W.bezierCurveTo(X + I, e, S, V - h, S, V) : y === "rightBottom" ? W.bezierCurveTo(S, V + h, X + I, p, X, p) : y === "leftBottom" && W.bezierCurveTo(X - I, p, u, V + h, u, V);
      }
      function c(W, [u, e, n, G], y) {
        if (!y || Array.isArray(y) && y.every((a) => a === 0))
          W.beginPath(), W.rect(u, e, n, G);
        else {
          typeof y == "number" && (y = Array(8).fill(y));
          const [a, I, h, S, p, X, V, i] = y.map((b, t) => t % 2 ? Math.min(b, G / 2) : Math.min(b, n / 2));
          W.beginPath(), W.moveTo(u, e + I), s(W, u, e, a * 2, I * 2, "leftTop"), W.lineTo(u + n - h, e), s(W, u + n - h * 2, e, h * 2, S * 2, "rightTop"), W.lineTo(u + n, e + G - X), s(W, u + n - p * 2, e + G - X * 2, p * 2, X * 2, "rightBottom"), W.lineTo(u + V, e + G), s(W, u, e + G - i * 2, V * 2, i * 2, "leftBottom"), W.closePath();
        }
        return W;
      }
    },
    /* 223 */
    /***/
    function(Z, d, l) {
      l.r(d), l(1).glMatrix.setMatrixArrayType(Array), d.default = function(s, c) {
        if (!s)
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
        const [[W, u], [e, n]] = s, G = W * c[0] + u * c[2] + c[4], y = W * c[1] + u * c[3] + c[5], a = e * c[0] + u * c[2] + c[4], I = e * c[1] + u * c[3] + c[5], h = e * c[0] + n * c[2] + c[4], S = e * c[1] + n * c[3] + c[5], p = W * c[0] + n * c[2] + c[4], X = W * c[1] + n * c[3] + c[5], V = Math.min(G, a, h, p), i = Math.min(y, I, S, X), b = Math.max(G, a, h, p), t = Math.max(y, I, S, X);
        return {
          x: V,
          y: i,
          width: b - V,
          height: t - i,
          left: V,
          top: i,
          right: b,
          bottom: t
        };
      };
    },
    /* 224 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var s = l(218), c = l(219), W = l(225), u = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      function e(y, a, I) {
        return a in y ? Object.defineProperty(y, a, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : y[a] = I, y;
      }
      const n = Symbol("textureTask");
      class G extends c.default {
        constructor(a = {}) {
          typeof a == "string" && (a = {
            texture: a
          }), super(a);
        }
        /* override */
        get contentSize() {
          let [a, I] = super.contentSize;
          const {
            width: h,
            height: S
          } = this.attributes;
          if (h == null || S == null) {
            const p = this.textureImage, X = this.attributes.textureRect, V = this.attributes.sourceRect;
            if (X)
              h == null && (a = X[0] + X[2]), S == null && (I = X[1] + X[3]);
            else if (V) {
              const i = this.layer ? this.layer.displayRatio : 1;
              h == null && (a = V[2] / i), S == null && (I = V[3] / i);
            } else if (p) {
              const i = this.layer ? this.layer.displayRatio : 1;
              h == null && (a = p.width / i), S == null && (I = p.height / i);
            }
          }
          return [a, I];
        }
        get textureImageReady() {
          return this[n] || Promise.resolve();
        }
        /* override */
        draw(a = []) {
          super.draw(a);
          const I = this.mesh;
          return I && Object(s.drawTexture)(this, I), a;
        }
        /* override */
        onPropertyChange(a, I, h) {
          if (super.onPropertyChange(a, I, h), a === "texture" && (this[n] = Object(s.applyTexture)(this, I, !0)), a === "textureRect") {
            const {
              width: S,
              height: p
            } = this.attributes;
            (S == null || p == null) && this.updateContours();
          }
        }
      }
      e(G, "Attr", W.default), u.default.registerNode(G, "sprite");
    },
    /* 225 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(220);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol.for("spritejs_setAttributeDefault"), W = Symbol.for("spritejs_setAttribute"), u = Symbol.for("spritejs_getAttribute");
      class e extends s.default {
        constructor(G) {
          super(G), this[c]({
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0
          });
        }
        get texture() {
          return this[u]("texture");
        }
        set texture(G) {
          this[W]("texture", G);
        }
        get textureRect() {
          return this[u]("textureRect");
        }
        set textureRect(G) {
          this[W]("textureRect", G);
        }
        get sourceRect() {
          return this[u]("sourceRect");
        }
        set sourceRect(G) {
          this[W]("sourceRect", G);
        }
        get textureRepeat() {
          return this[u]("textureRepeat");
        }
        set textureRepeat(G) {
          this[W]("textureRepeat", !!G);
        }
      }
    },
    /* 226 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return S;
      });
      var s = l(12), c = l(227), W = /* @__PURE__ */ l.n(c), u = l(70), e = l(228), n = l(221), G = l(218), y = l(213), a = l(223);
      l(1).glMatrix.setMatrixArrayType(Array);
      function I(p, X, V) {
        return X in p ? Object.defineProperty(p, X, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : p[X] = V, p;
      }
      const h = Symbol("mesh");
      class S extends u.default {
        constructor(X = {}) {
          typeof X == "string" && (X = {
            d: X
          }), super(X), this.effects = {
            d(V, i, b, t, m) {
              const R = (b - t) / (m - t);
              if (R <= 0)
                return V;
              if (R >= 1)
                return i;
              const x = W.a._preprocessing(W.a.path2shapes(V), W.a.path2shapes(i)), C = W.a._lerp(...x, R)[0];
              return C.reduce((K, J) => `${K}${J.slice(2).join(" ")} `, `M${C[0][0]} ${C[0][1]}C`).trim();
            }
          };
        }
        /* override */
        get isVisible() {
          return !!this.d;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const X = this.path;
          if (X) {
            let V = this[h];
            if (V)
              V.path !== X && (V.contours = X.contours, V.path = X);
            else {
              V = new s.Mesh2D(this.path), V.path = X;
              const b = this.attributes.fillColor, t = this.attributes.fillRule;
              b && Object(n.setFillColor)(V, {
                color: b,
                rule: t
              });
              const m = this.attributes.lineWidth, R = this.attributes.strokeColor;
              if (R && m > 0) {
                const {
                  lineCap: C,
                  lineJoin: T,
                  miterLimit: K,
                  lineDash: J,
                  lineDashOffset: F,
                  roundSegments: r
                } = this.attributes;
                Object(n.setStrokeColor)(V, {
                  color: R,
                  lineWidth: m,
                  lineCap: C,
                  lineJoin: T,
                  miterLimit: K,
                  lineDash: J,
                  lineDashOffset: F,
                  roundSegments: r
                });
              }
              this[h] = V;
              const x = this.attributes.clipPath;
              x && this[h].setClipPath(x);
            }
            const i = this.opacity;
            return V.getOpacity() !== i && V.setOpacity(i), V.setTransform(...this.renderMatrix), V;
          }
          return null;
        }
        get originalContentRect() {
          if (this.path) {
            const X = this.path.boundingBox;
            return [X[0][0], X[0][1], X[1][0] - X[0][0], X[1][1] - X[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientRect() {
          if (this.mesh) {
            const X = this.mesh.boundingBox;
            return [X[0][0], X[0][1], X[1][0] - X[0][0], X[1][1] - X[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientCenter() {
          return this.mesh ? this.mesh.boundingCenter : [0, 0];
        }
        set d(X) {
          this.attributes.d = X;
        }
        get d() {
          return this.attributes.d;
        }
        /* override */
        draw(X = []) {
          super.draw(X);
          const V = this.mesh;
          return V && Object(G.drawTexture)(this, V), X;
        }
        getBoundingClientRect() {
          let X = null;
          return this.mesh && (X = this.mesh.boundingBox), Object(a.default)(X, this.renderMatrix);
        }
        getPathLength() {
          return this.mesh ? this.mesh.getTotalLength() : 0;
        }
        getPointAtLength(X) {
          if (this.mesh) {
            const V = this.mesh.getPointAtLength(X);
            if (V)
              return [V.x, V.y];
          }
          return [0, 0];
        }
        /* override */
        onPropertyChange(X, V, i) {
          if (super.onPropertyChange(X, V, i), (X === "d" || X === "normalize") && this.updateContours(), this[h] && (X === "fillColor" || X === "fillRule")) {
            const {
              fillColor: b,
              fillRule: t
            } = this.attributes;
            Object(n.setFillColor)(this[h], {
              color: b,
              rule: t
            });
          }
          if (this[h] && (X === "strokeColor" || X === "lineWidth" || X === "lineCap" || X === "lineJoin" || X === "lineDash" || X === "lineDashOffset" || X === "roundSegments")) {
            const {
              strokeColor: b,
              lineWidth: t
            } = this.attributes;
            if (b && t > 0) {
              const {
                lineCap: m,
                lineJoin: R,
                lineDash: x,
                lineDashOffset: C,
                miterLimit: T,
                roundSegments: K
              } = this.attributes;
              Object(n.setStrokeColor)(this[h], {
                color: b,
                lineCap: m,
                lineJoin: R,
                lineWidth: t,
                lineDash: x,
                lineDashOffset: C,
                miterLimit: T,
                roundSegments: K
              });
            }
          }
          this[h] && X === "clipPath" && this[h].setClipPath(V), X === "texture" && Object(G.applyTexture)(this, V);
        }
        /* override */
        updateContours() {
          this.path = new s.Figure2D(), this.path.addPath(this.attributes.d), this.attributes.normalize && this.path.normalize(...this.path.boundingCenter);
        }
      }
      I(S, "Attr", e.default), y.default.registerNode(S, "path");
    },
    /* 227 */
    /***/
    function(Z, d, l) {
      (function(s, c) {
        Z.exports = c();
      })(this, function() {
        var s = /* @__PURE__ */ function() {
          function J(F, r) {
            var Y = [], H = !0, Q = !1, w = void 0;
            try {
              for (var O = F[Symbol.iterator](), q; !(H = (q = O.next()).done) && (Y.push(q.value), !(r && Y.length === r)); H = !0)
                ;
            } catch (k) {
              Q = !0, w = k;
            } finally {
              try {
                !H && O.return && O.return();
              } finally {
                if (Q)
                  throw w;
              }
            }
            return Y;
          }
          return function(F, r) {
            if (Array.isArray(F))
              return F;
            if (Symbol.iterator in Object(F))
              return J(F, r);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), c = Math.PI * 2, W = function(F, r, Y, H, Q, w, O) {
          var q = F.x, k = F.y;
          q *= r, k *= Y;
          var P = H * q - Q * k, D = Q * q + H * k;
          return {
            x: P + w,
            y: D + O
          };
        }, u = function(F, r) {
          var Y = 1.3333333333333333 * Math.tan(r / 4), H = Math.cos(F), Q = Math.sin(F), w = Math.cos(F + r), O = Math.sin(F + r);
          return [{
            x: H - Q * Y,
            y: Q + H * Y
          }, {
            x: w + O * Y,
            y: O - w * Y
          }, {
            x: w,
            y: O
          }];
        }, e = function(F, r, Y, H) {
          var Q = F * H - r * Y < 0 ? -1 : 1, w = Math.sqrt(F * F + r * r), O = Math.sqrt(F * F + r * r), q = F * Y + r * H, k = q / (w * O);
          return k > 1 && (k = 1), k < -1 && (k = -1), Q * Math.acos(k);
        }, n = function(F, r, Y, H, Q, w, O, q, k, P, D, ll) {
          var _ = Math.pow(Q, 2), bl = Math.pow(w, 2), $ = Math.pow(D, 2), el = Math.pow(ll, 2), nl = _ * bl - _ * el - bl * $;
          nl < 0 && (nl = 0), nl /= _ * el + bl * $, nl = Math.sqrt(nl) * (O === q ? -1 : 1);
          var z = nl * Q / w * ll, M = nl * -w / Q * D, E = P * z - k * M + (F + Y) / 2, B = k * z + P * M + (r + H) / 2, g = (D - z) / Q, U = (ll - M) / w, o = (-D - z) / Q, L = (-ll - M) / w, N = e(1, 0, g, U), v = e(g, U, o, L);
          return q === 0 && v > 0 && (v -= c), q === 1 && v < 0 && (v += c), [E, B, N, v];
        }, G = function(F) {
          var r = F.px, Y = F.py, H = F.cx, Q = F.cy, w = F.rx, O = F.ry, q = F.xAxisRotation, k = q === void 0 ? 0 : q, P = F.largeArcFlag, D = P === void 0 ? 0 : P, ll = F.sweepFlag, _ = ll === void 0 ? 0 : ll, bl = [];
          if (w === 0 || O === 0)
            return [];
          var $ = Math.sin(k * c / 360), el = Math.cos(k * c / 360), nl = el * (r - H) / 2 + $ * (Y - Q) / 2, z = -$ * (r - H) / 2 + el * (Y - Q) / 2;
          if (nl === 0 && z === 0)
            return [];
          w = Math.abs(w), O = Math.abs(O);
          var M = Math.pow(nl, 2) / Math.pow(w, 2) + Math.pow(z, 2) / Math.pow(O, 2);
          M > 1 && (w *= Math.sqrt(M), O *= Math.sqrt(M));
          var E = n(r, Y, H, Q, w, O, D, _, $, el, nl, z), B = s(E, 4), g = B[0], U = B[1], o = B[2], L = B[3], N = Math.max(Math.ceil(Math.abs(L) / (c / 4)), 1);
          L /= N;
          for (var v = 0; v < N; v++)
            bl.push(u(o, L)), o += L;
          return bl.map(function(f) {
            var j = W(f[0], w, O, el, $, g, U), A = j.x, dl = j.y, il = W(f[1], w, O, el, $, g, U), cl = il.x, ml = il.y, tl = W(f[2], w, O, el, $, g, U), sl = tl.x, Zl = tl.y;
            return { x1: A, y1: dl, x2: cl, y2: ml, x: sl, y: Zl };
          });
        }, y = {
          a: 7,
          c: 6,
          h: 1,
          l: 2,
          m: 2,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          z: 0
          /**
           * segment pattern
           * @type {RegExp}
           */
        }, a = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function I(J) {
          var F = [];
          return J.replace(a, function(r, Y, H) {
            var Q = Y.toLowerCase();
            for (H = S(H), Q == "m" && H.length > 2 && (F.push([Y].concat(H.splice(0, 2))), Q = "l", Y = Y == "m" ? "l" : "L"); ; ) {
              if (H.length == y[Q])
                return H.unshift(Y), F.push(H);
              if (H.length < y[Q])
                throw new Error("malformed path data");
              F.push([Y].concat(H.splice(0, y[Q])));
            }
          }), F;
        }
        var h = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function S(J) {
          var F = J.match(h);
          return F ? F.map(Number) : [];
        }
        function p(J) {
          var F = J[0][0], r = J[0][1], Y = F, H = r;
          return J.forEach(function(Q) {
            var w = Q[0], O = Q[2], q = Q[4], k = Q[6], P = Q[1], D = Q[3], ll = Q[5], _ = Q[7];
            F = Math.min(F, w, O, q, k), r = Math.min(r, P, D, ll, _), Y = Math.max(Y, w, O, q, k), H = Math.max(H, P, D, ll, _);
          }), [F, r, Y, H];
        }
        function X(J, F) {
          return Math.sqrt(Math.pow(J[0] - F[0], 2) + Math.pow(J[1] - F[1], 2)) + Math.sqrt(Math.pow(J[2] - F[2], 2) + Math.pow(J[3] - F[3], 2));
        }
        function V(J, F) {
          var r = J[0], Y = J[2], H = J[4], Q = J[6], w = J[1], O = J[3], q = J[5], k = J[7], P = F[0], D = F[2], ll = F[4], _ = F[6], bl = F[1], $ = F[3], el = F[5], nl = F[7];
          return Math.sqrt(Math.pow(P - r, 2) + Math.pow(bl - w, 2)) + Math.sqrt(Math.pow(D - Y, 2) + Math.pow($ - O, 2)) + Math.sqrt(Math.pow(ll - H, 2) + Math.pow(el - q, 2)) + Math.sqrt(Math.pow(_ - Q, 2) + Math.pow(nl - k, 2));
        }
        function i(J, F) {
          var r = t(J.length), Y = [];
          r.forEach(function(Q) {
            var w = 0, O = 0;
            Q.forEach(function(q) {
              w += V(J[q], F[O++]);
            }), Y.push({ index: Q, distance: w });
          }), Y.sort(function(Q, w) {
            return Q.distance - w.distance;
          });
          var H = [];
          return Y[0].index.forEach(function(Q) {
            H.push(J[Q]);
          }), H;
        }
        function b(J, F) {
          var r = m(J.length), Y = [];
          r.forEach(function(Q) {
            var w = 0;
            Q.forEach(function(O) {
              w += X(p(J[O]), p(F[O]));
            }), Y.push({ index: Q, distance: w });
          }), Y.sort(function(Q, w) {
            return Q.distance - w.distance;
          });
          var H = [];
          return Y[0].index.forEach(function(Q) {
            H.push(J[Q]);
          }), H;
        }
        function t(J) {
          for (var F = [], r = 0; r < J; r++) {
            for (var Y = [], H = 0; H < J; H++) {
              var Q = H + r;
              Q > J - 1 && (Q -= J), Y[Q] = H;
            }
            F.push(Y);
          }
          return F;
        }
        function m(J) {
          for (var F = [], r = 0; r < J; r++)
            F.push(r);
          return R(F);
        }
        function R(J) {
          var F = [], r = [];
          function Y(H) {
            var Q, w;
            for (Q = 0; Q < H.length; Q++)
              w = H.splice(Q, 1)[0], r.push(w), H.length == 0 && F.push(r.slice()), Y(H), H.splice(Q, 0, w), r.pop();
            return F;
          }
          return Y(J);
        }
        var x = {};
        x.parser = I, x.lerpCurve = function(J, F, r) {
          return x.lerpPoints(J[0], J[1], F[0], F[1], r).concat(x.lerpPoints(J[2], J[3], F[2], F[3], r)).concat(x.lerpPoints(J[4], J[5], F[4], F[5], r)).concat(x.lerpPoints(J[6], J[7], F[6], F[7], r));
        }, x.lerpPoints = function(J, F, r, Y, H) {
          return [J + (r - J) * H, F + (Y - F) * H];
        }, x.q2b = function(J, F, r, Y, H, Q) {
          return [J, F, (J + 2 * r) / 3, (F + 2 * Y) / 3, (H + 2 * r) / 3, (Q + 2 * Y) / 3, H, Q];
        }, x.path2shapes = function(J) {
          for (var F = x.parser(J), r = 0, Y = 0, H = 0, Q = F.length, w = [], O = null, q = void 0, k = void 0, P = void 0, D = void 0, ll = void 0, _ = void 0, bl = void 0; H < Q; H++) {
            var $ = F[H], el = $[0], nl = F[H - 1];
            switch (el) {
              case "m":
                ll = w.length, w[ll] = [], O = w[ll], r = r + $[1], Y = Y + $[2];
                break;
              case "M":
                ll = w.length, w[ll] = [], O = w[ll], r = $[1], Y = $[2];
                break;
              case "l":
                O.push([r, Y, r, Y, r, Y, r + $[1], Y + $[2]]), r += $[1], Y += $[2];
                break;
              case "L":
                O.push([r, Y, $[1], $[2], $[1], $[2], $[1], $[2]]), r = $[1], Y = $[2];
                break;
              case "h":
                O.push([r, Y, r, Y, r, Y, r + $[1], Y]), r += $[1];
                break;
              case "H":
                O.push([r, Y, $[1], Y, $[1], Y, $[1], Y]), r = $[1];
                break;
              case "v":
                O.push([r, Y, r, Y, r, Y, r, Y + $[1]]), Y += $[1];
                break;
              case "V":
                O.push([r, Y, r, $[1], r, $[1], r, $[1]]), Y = $[1];
                break;
              case "C":
                O.push([r, Y, $[1], $[2], $[3], $[4], $[5], $[6]]), r = $[5], Y = $[6];
                break;
              case "S":
                nl[0] === "C" || nl[0] === "c" ? O.push([r, Y, r + nl[5] - nl[3], Y + nl[6] - nl[4], $[1], $[2], $[3], $[4]]) : (nl[0] === "S" || nl[0] === "s") && O.push([r, Y, r + nl[3] - nl[1], Y + nl[4] - nl[2], $[1], $[2], $[3], $[4]]), r = $[3], Y = $[4];
                break;
              case "c":
                O.push([r, Y, r + $[1], Y + $[2], r + $[3], Y + $[4], r + $[5], Y + $[6]]), r = r + $[5], Y = Y + $[6];
                break;
              case "s":
                nl[0] === "C" || nl[0] === "c" ? O.push([r, Y, r + nl[5] - nl[3], Y + nl[6] - nl[4], r + $[1], Y + $[2], r + $[3], Y + $[4]]) : (nl[0] === "S" || nl[0] === "s") && O.push([r, Y, r + nl[3] - nl[1], Y + nl[4] - nl[2], r + $[1], Y + $[2], r + $[3], Y + $[4]]), r = r + $[3], Y = Y + $[4];
                break;
              case "a":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: r,
                  py: Y,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: r + $[6],
                  cy: Y + $[7]
                }), bl = _[_.length - 1], _.forEach(function(z, M) {
                  M === 0 ? O.push([r, Y, z.x1, z.y1, z.x2, z.y2, z.x, z.y]) : O.push([_[M - 1].x, _[M - 1].y, z.x1, z.y1, z.x2, z.y2, z.x, z.y]);
                }), r = bl.x, Y = bl.y;
                break;
              case "A":
                _ = G({
                  rx: $[1],
                  ry: $[2],
                  px: r,
                  py: Y,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: $[6],
                  cy: $[7]
                }), bl = _[_.length - 1], _.forEach(function(z, M) {
                  M === 0 ? O.push([r, Y, z.x1, z.y1, z.x2, z.y2, z.x, z.y]) : O.push([_[M - 1].x, _[M - 1].y, z.x1, z.y1, z.x2, z.y2, z.x, z.y]);
                }), r = bl.x, Y = bl.y;
                break;
              case "Q":
                O.push(x.q2b(r, Y, $[1], $[2], $[3], $[4])), r = $[3], Y = $[4];
                break;
              case "q":
                O.push(x.q2b(r, Y, r + $[1], Y + $[2], $[3] + r, $[4] + Y)), r += $[3], Y += $[4];
                break;
              case "T":
                nl[0] === "Q" || nl[0] === "q" ? (P = r + nl[3] - nl[1], D = Y + nl[4] - nl[2], O.push(x.q2b(r, Y, P, D, $[1], $[2]))) : (nl[0] === "T" || nl[0] === "t") && (O.push(x.q2b(r, Y, r + r - P, Y + Y - D, $[1], $[2])), P = r + r - P, D = Y + Y - D), r = $[1], Y = $[2];
                break;
              case "t":
                nl[0] === "Q" || nl[0] === "q" ? (P = r + nl[3] - nl[1], D = Y + nl[4] - nl[2], O.push(x.q2b(r, Y, P, D, r + $[1], Y + $[2]))) : (nl[0] === "T" || nl[0] === "t") && (O.push(x.q2b(r, Y, r + r - P, Y + Y - D, r + $[1], Y + $[2])), P = r + r - P, D = Y + Y - D), r += $[1], Y += $[2];
                break;
              case "Z":
                q = O[0][0], k = O[0][1], O.push([r, Y, q, k, q, k, q, k]);
                break;
              case "z":
                q = O[0][0], k = O[0][1], O.push([r, Y, q, k, q, k, q, k]);
                break;
            }
          }
          return w;
        }, x._upCurves = function(J, F) {
          for (var r = 0, Y = 0, H = J.length; r < F; r++)
            J.push(J[Y].slice(0)), Y++, Y > H - 1 && (Y -= H);
        };
        function C(J, F, r, Y, H, Q, w, O, q) {
          return {
            left: T(J, F, r, Y, H, Q, w, O, q),
            right: T(w, O, H, Q, r, Y, J, F, 1 - q, !0)
          };
        }
        function T(J, F, r, Y, H, Q, w, O, q, k) {
          var P = (r - J) * q + J, D = (Y - F) * q + F, ll = (H - r) * q + r, _ = (Q - Y) * q + Y, bl = (w - H) * q + H, $ = (O - Q) * q + Q, el = (ll - P) * q + P, nl = (_ - D) * q + D, z = (bl - ll) * q + ll, M = ($ - _) * q + _, E = (z - el) * q + el, B = (M - nl) * q + nl;
          return k ? [E, B, el, nl, P, D, J, F] : [J, F, P, D, el, nl, E, B];
        }
        x._splitCurves = function(J, F) {
          for (var r = 0, Y = 0; r < F; r++) {
            var H = J[Y], Q = C(H[0], H[1], H[2], H[3], H[4], H[5], H[6], H[7], 0.5);
            J.splice(Y, 1), J.splice(Y, 0, Q.left, Q.right), Y += 2, Y >= J.length - 1 && (Y = 0);
          }
        };
        function K(J, F) {
          for (var r = function(Q) {
            var w = J[J.length - 1], O = [];
            w.forEach(function(q) {
              O.push(q.slice(0));
            }), J.push(O);
          }, Y = 0; Y < F; Y++)
            r();
        }
        return x.lerp = function(J, F, r) {
          return x._lerp(x.path2shapes(J), x.path2shapes(F), r);
        }, x.MIM_CURVES_COUNT = 100, x._preprocessing = function(J, F) {
          var r = J.length, Y = F.length, H = JSON.parse(JSON.stringify(J)), Q = JSON.parse(JSON.stringify(F));
          return r > Y ? K(Q, r - Y) : r < Y && K(H, Y - r), H = b(H, Q), H.forEach(function(w, O) {
            var q = w.length, k = Q[O].length;
            q > k ? q < x.MIM_CURVES_COUNT ? (x._splitCurves(w, x.MIM_CURVES_COUNT - q), x._splitCurves(Q[O], x.MIM_CURVES_COUNT - k)) : x._splitCurves(Q[O], q - k) : q < k && (k < x.MIM_CURVES_COUNT ? (x._splitCurves(w, x.MIM_CURVES_COUNT - q), x._splitCurves(Q[O], x.MIM_CURVES_COUNT - k)) : x._splitCurves(w, k - q));
          }), H.forEach(function(w, O) {
            H[O] = i(w, Q[O]);
          }), [H, Q];
        }, x._lerp = function(J, F, r) {
          var Y = [];
          return J.forEach(function(H, Q) {
            var w = [];
            H.forEach(function(O, q) {
              w.push(x.lerpCurve(O, F[Q][q], r));
            }), Y.push(w);
          }), Y;
        }, x.animate = function(J) {
          var F = x.path2shapes(J.from), r = x.path2shapes(J.to), Y = x._preprocessing(F, r), H = /* @__PURE__ */ new Date(), Q = J.end || function() {
          }, w = J.progress || function() {
          }, O = J.begin || function() {
          }, q = J.easing || function(_) {
            return _;
          }, k = null, P = null, D = J.time;
          O(F);
          var ll = function _() {
            var bl = /* @__PURE__ */ new Date() - H;
            if (bl >= D) {
              P = r, w(P, 1), Q(P), cancelAnimationFrame(k);
              return;
            }
            var $ = q(bl / D);
            P = x._lerp(Y[0], Y[1], $), w(P, $), k = requestAnimationFrame(_);
          };
          ll();
        }, x;
      });
    },
    /* 228 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var s = l(71), c = l(221), W = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const u = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute");
      class G extends s.default {
        constructor(a) {
          super(a), this[u]({
            d: "",
            normalize: !1,
            fillColor: void 0,
            fillRule: "nonzero",
            strokeColor: void 0,
            lineWidth: 1,
            lineJoin: "miter",
            // 'miter' or 'bevel' or 'round'
            lineCap: "butt",
            // 'butt' or 'square' or 'round'
            roundSegments: 20,
            // default roundSegment if lineJoin or lineCap is round
            lineDash: void 0,
            lineDashOffset: 0,
            miterLimit: 10,
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0,
            clipPath: void 0
          });
        }
        get d() {
          return this[n]("d");
        }
        set d(a) {
          this[e]("d", a);
        }
        get normalize() {
          return this[n]("normalize");
        }
        set normalize(a) {
          this[e]("normalize", !!a);
        }
        get fillColor() {
          return this[n]("fillColor");
        }
        set fillColor(a) {
          this[e]("fillColor", Object(c.parseColor)(a));
        }
        get fillRule() {
          return this[n]("fillRule");
        }
        set fillRule(a) {
          if (a != null && a !== "nonzero" && a !== "evenodd")
            throw new TypeError("Invalid fill rule.");
          this[e]("fillRule", a);
        }
        get strokeColor() {
          return this[n]("strokeColor");
        }
        set strokeColor(a) {
          this[e]("strokeColor", Object(c.parseColor)(a));
        }
        get lineWidth() {
          return this[n]("lineWidth");
        }
        set lineWidth(a) {
          this[e]("lineWidth", Object(W.toNumber)(a));
        }
        get lineJoin() {
          return this[n]("lineJoin");
        }
        set lineJoin(a) {
          if (a != null && a !== "miter" && a !== "bevel" && a !== "round")
            throw new TypeError("Invalid lineJoin type.");
          this[e]("lineJoin", a);
        }
        get lineCap() {
          return this[n]("lineCap");
        }
        set lineCap(a) {
          if (a != null && a !== "butt" && a !== "square" && a !== "round")
            throw new TypeError("Invalid lineCap type.");
          this[e]("lineCap", a);
        }
        get lineDash() {
          return this[n]("lineDash");
        }
        set lineDash(a) {
          a = Object(W.toArray)(a, !0), a != null && !Array.isArray(a) && (a = [a]), this[e]("lineDash", a ? a.map(W.toNumber) : null);
        }
        get lineDashOffset() {
          return this[n]("lineDashOffset");
        }
        set lineDashOffset(a) {
          this[e]("lineDashOffset", Object(W.toNumber)(a));
        }
        get miterLimit() {
          return this[n]("miterLimit");
        }
        set miterLimit(a) {
          this[e]("miterLimit", Object(W.toNumber)(a));
        }
        get roundSegments() {
          return this[n]("roundSegments");
        }
        set roundSegments(a) {
          this[e]("roundSegments", a);
        }
        get texture() {
          return this[n]("texture");
        }
        set texture(a) {
          this[e]("texture", a);
        }
        get textureRect() {
          return this[n]("textureRect");
        }
        set textureRect(a) {
          this[e]("textureRect", a);
        }
        get sourceRect() {
          return this[n]("sourceRect");
        }
        set sourceRect(a) {
          this[e]("sourceRect", a);
        }
        get textureRepeat() {
          return this[n]("textureRepeat");
        }
        set textureRepeat(a) {
          this[e]("textureRepeat", !!a);
        }
        get clipPath() {
          return this[n]("clipPath");
        }
        set clipPath(a) {
          this[e]("clipPath", a);
        }
      }
    },
    /* 229 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(226), c = l(213), W = l(230);
      l(1).glMatrix.setMatrixArrayType(Array);
      function u(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            width: G,
            height: y
          } = this.attributes;
          return G > 0 && y > 0 && super.isVisible;
        }
      }
      u(e, "Attr", W.default), c.default.registerNode(e, "rect");
    },
    /* 230 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return y;
      });
      var s = l(228), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), n = Symbol.for("spritejs_declareAlias");
      function G(a) {
        const {
          width: I,
          height: h
        } = a;
        return `M0 0L${I} 0L${I} ${h}L0 ${h}Z`;
      }
      class y extends s.default {
        constructor(I) {
          super(I), this[W]({
            width: 0,
            height: 0
            /* size */
          }), this[n]("size");
        }
        // readonly
        get d() {
          return this[e]("d");
        }
        set d(I) {
        }
        // eslint-disable-line no-empty-function
        get width() {
          return this[e]("width");
        }
        set width(I) {
          if (I = Object(c.toNumber)(I), this[u]("width", I)) {
            const h = G(this);
            this[u]("d", h);
          }
        }
        get height() {
          return this[e]("height");
        }
        set height(I) {
          if (I = Object(c.toNumber)(I), this[u]("height", I)) {
            const h = G(this);
            this[u]("d", h);
          }
        }
        get size() {
          return [this.width, this.height];
        }
        set size(I) {
          I = Object(c.toArray)(I), Array.isArray(I) || (I = [I, I]), this.width = I[0], this.height = I[1];
        }
      }
    },
    /* 231 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(232), c = l(213), W = l(235);
      l(1).glMatrix.setMatrixArrayType(Array);
      function u(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends s.default {
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      u(e, "Attr", W.default), c.default.registerNode(e, "triangle");
    },
    /* 232 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(226), c = l(213), W = l(233);
      l(1).glMatrix.setMatrixArrayType(Array);
      function u(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            points: G
          } = this.attributes;
          return G.length > 0 && super.isVisible;
        }
      }
      u(e, "Attr", W.default), c.default.registerNode(e, "polyline");
    },
    /* 233 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return a;
      });
      var s = l(228), c = l(72), W = l(234);
      l(1).glMatrix.setMatrixArrayType(Array);
      const u = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(I) {
        const {
          points: h,
          smooth: S,
          smoothRange: p,
          close: X
        } = I, V = [];
        for (let b = 0; b < h.length; b += 2)
          V.push([h[b], h[b + 1]]);
        let i = "";
        return S ? i = Object(W.makeSmoothCurveLine)(V, p) : V.length && (i = `M${V.map((b) => b.join(" ")).join("L")}`), i && X && (i += "Z"), i;
      }
      class a extends s.default {
        constructor(h) {
          super(h), this[u]({
            points: [],
            smooth: !1,
            smoothRange: [0],
            closeType: "none"
            // none | normal
            /* close */
          }), this[G]("close");
        }
        // readonly
        get d() {
          return this[n]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get close() {
          return this.closeType !== "none";
        }
        set close(h) {
          h = h ? "normal" : "none", this.closeType = h;
        }
        get closeType() {
          return this[n]("closeType");
        }
        set closeType(h) {
          if (h != null && h !== "none" && h !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[e]("closeType", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get smooth() {
          return this[n]("smooth");
        }
        set smooth(h) {
          if (this[e]("smooth", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get smoothRange() {
          return this[n]("smoothRange");
        }
        set smoothRange(h) {
          if (h && !Array.isArray(h) && (h = [h]), this[e]("smoothRange", h) && this.smooth) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get points() {
          return this[n]("points");
        }
        set points(h) {
          if (h = Object(c.toArray)(h), Array.isArray(h) && (h = h.reduce((S, p) => Array.isArray(p) ? [...S, ...p.map((X) => Object(c.toNumber)(X))] : [...S, Object(c.toNumber)(p)], [])), this[e]("points", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
      }
    },
    /* 234 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "makeSmoothCurveLine", function() {
        return s;
      }), l(1).glMatrix.setMatrixArrayType(Array);
      function s(c, W = [0]) {
        function u(G, y = 0.168, a = 0.168) {
          let I, h, S, p;
          if ((c[G].x === c[G + 1].x || c[G].y === c[G + 1].y) && (y = 0, a = 0), G < 1 ? (I = c[0].x + (c[1].x - c[0].x) * y, h = c[0].y + (c[1].y - c[0].y) * y) : (I = c[G].x + (c[G + 1].x - c[G - 1].x) * y, h = c[G].y + (c[G + 1].y - c[G - 1].y) * y), G > c.length - 3) {
            const X = c.length - 1;
            S = c[X].x - (c[X].x - c[X - 1].x) * a, p = c[X].y - (c[X].y - c[X - 1].y) * a;
          } else
            S = c[G + 1].x - (c[G + 2].x - c[G].x) * a, p = c[G + 1].y - (c[G + 2].y - c[G].y) * a;
          return [{
            x: I,
            y: h
          }, {
            x: S,
            y: p
          }];
        }
        c = c.map(([G, y]) => ({
          x: G,
          y
        }));
        let e = "", n = 0;
        return c.forEach((G, y) => {
          if (y === 0)
            e += `M${G.x} ${G.y}`;
          else {
            for (; y > W[n]; )
              n++;
            if (n % 2) {
              const [a, I] = u(y - 1);
              e += `C${[a.x, a.y, I.x, I.y, G.x, G.y].join(" ")}`;
            } else
              e += `L${G.x} ${G.y}`;
          }
        }), e;
      }
    },
    /* 235 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var s = l(233), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function n(y) {
        const [a, I] = y.sides;
        let h = y.angle % 360;
        return h < 0 && (h += 360), h = Math.PI * h / 180, [0, 0, a, 0, I * Math.cos(h), I * Math.sin(h)];
      }
      class G extends s.default {
        constructor(a) {
          super(a), this[W]({
            sides: [0, 0],
            angle: 60,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(a) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[e]("sides");
        }
        set sides(a) {
          if (a = Object(c.toArray)(a, !0), a != null && !Array.isArray(a) && (a = [a, a]), this[u]("sides", a)) {
            const I = n(this);
            super.points = I;
          }
        }
        get angle() {
          return this[e]("angle");
        }
        set angle(a) {
          if (a = Object(c.toNumber)(a), this[u]("angle", a)) {
            const I = n(this);
            super.points = I;
          }
        }
      }
    },
    /* 236 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(232), c = l(213), W = l(237);
      l(1).glMatrix.setMatrixArrayType(Array);
      function u(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            sides: G
          } = this.attributes;
          return G[0] > 0 && G[1] > 0 && super.isVisible;
        }
      }
      u(e, "Attr", W.default), c.default.registerNode(e, "parallel");
    },
    /* 237 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var s = l(233), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function n(y) {
        const [a, I] = y.sides;
        let h = y.angle % 360;
        h < 0 && (h += 360), h = Math.PI * h / 180;
        const S = I * Math.cos(h), p = I * Math.sin(h);
        return [0, 0, a, 0, S + a, p, S, p];
      }
      class G extends s.default {
        constructor(a) {
          super(a), this[W]({
            sides: [0, 0],
            angle: 90,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(a) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[e]("sides");
        }
        set sides(a) {
          if (a = Object(c.toArray)(a, !0), a != null && !Array.isArray(a) && (a = [a, a]), this[u]("sides", a)) {
            const I = n(this);
            super.points = I;
          }
        }
        get angle() {
          return this[e]("angle");
        }
        set angle(a) {
          if (a = Object(c.toNumber)(a), this[u]("angle", a)) {
            const I = n(this);
            super.points = I;
          }
        }
      }
    },
    /* 238 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(232), c = l(213), W = l(239);
      l(1).glMatrix.setMatrixArrayType(Array);
      function u(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends s.default {
      }
      u(e, "Attr", W.default), c.default.registerNode(e, "regular");
    },
    /* 239 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var s = l(233), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function n(y) {
        const {
          edges: a,
          radius: I,
          offsetAngle: h
        } = y, S = Math.PI * h / 180 - 0.5 * Math.PI;
        if (a < 3 || I <= 0)
          return [];
        const p = [];
        for (let X = 0; X < a; X++) {
          const V = X * 2 * Math.PI / a + S, i = I * Math.cos(V), b = I * Math.sin(V);
          p.push(i, b);
        }
        return p;
      }
      class G extends s.default {
        constructor(a) {
          super(a), this[W]({
            edges: 3,
            radius: 0,
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(a) {
        }
        // eslint-disable-line no-empty-function
        get edges() {
          return this[e]("edges");
        }
        set edges(a) {
          if (a = Object(c.toNumber)(a), this[u]("edges", a)) {
            const I = n(this);
            super.points = I;
          }
        }
        get radius() {
          return this[e]("radius");
        }
        set radius(a) {
          if (a = Object(c.toNumber)(a), this[u]("radius", a)) {
            const I = n(this);
            super.points = I;
          }
        }
        get offsetAngle() {
          return this[e]("offsetAngle");
        }
        set offsetAngle(a) {
          if (a = Object(c.toNumber)(a), this[u]("offsetAngle", a)) {
            const I = n(this);
            super.points = I;
          }
        }
      }
    },
    /* 240 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(232), c = l(213), W = l(241);
      l(1).glMatrix.setMatrixArrayType(Array);
      function u(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends s.default {
      }
      u(e, "Attr", W.default), c.default.registerNode(e, "star");
    },
    /* 241 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return G;
      });
      var s = l(233), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const W = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute");
      function n(y) {
        const {
          angles: a,
          innerRadius: I,
          outerRadius: h,
          offsetAngle: S
        } = y, p = Math.PI * S / 180 - 0.5 * Math.PI;
        if (a < 3 || I <= 0 || h <= 0)
          return [];
        const X = [];
        for (let V = 0; V < a * 2; V++) {
          const i = V * Math.PI / a + p, b = V % 2 ? I : h, t = b * Math.cos(i), m = b * Math.sin(i);
          X.push(t, m);
        }
        return X;
      }
      class G extends s.default {
        constructor(a) {
          super(a), this[W]({
            angles: 5,
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(a) {
        }
        // eslint-disable-line no-empty-function
        get angles() {
          return this[e]("angles");
        }
        set angles(a) {
          if (a = Object(c.toNumber)(a), this[u]("angles", a)) {
            const I = n(this);
            super.points = I;
          }
        }
        get innerRadius() {
          return this[e]("innerRadius");
        }
        set innerRadius(a) {
          if (a = Object(c.toNumber)(a), this[u]("innerRadius", a)) {
            const I = n(this);
            super.points = I;
          }
        }
        get outerRadius() {
          return this[e]("outerRadius");
        }
        set outerRadius(a) {
          if (a = Object(c.toNumber)(a), this[u]("outerRadius", a)) {
            const I = n(this);
            super.points = I;
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(a) {
          a = Object(c.toArray)(a, !0), Array.isArray(a) || (a = [a, a]), this.innerRadius = a[0], this.outerRadius = a[1];
        }
        get offsetAngle() {
          return this[e]("offsetAngle");
        }
        set offsetAngle(a) {
          if (a = Object(c.toNumber)(a), this[u]("offsetAngle", a)) {
            const I = n(this);
            super.points = I;
          }
        }
      }
    },
    /* 242 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(226), c = l(213), W = l(243);
      l(1).glMatrix.setMatrixArrayType(Array);
      function u(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            radiusX: G,
            radiusY: y,
            startAngle: a,
            endAngle: I
          } = this.attributes;
          return G > 0 && y > 0 && a !== I && super.isVisible;
        }
      }
      u(e, "Attr", W.default), c.default.registerNode(e, "ellipse");
    },
    /* 243 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return a;
      });
      var s = l(12), c = l(228), W = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const u = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(I) {
        const {
          radiusX: h,
          radiusY: S,
          startAngle: p,
          endAngle: X,
          direction: V,
          closeType: i
        } = I, b = V === "anitclockwise", t = new s.Figure2D();
        return i === "sector" && t.moveTo(0, 0), t.ellipse(0, 0, h, S, 0, Math.PI * p / 180, Math.PI * X / 180, b), i !== "none" && t.closePath(), t.path.reduce((x, C) => x + C.join(" "), "");
      }
      class a extends c.default {
        constructor(h) {
          super(h), this[u]({
            radiusX: 0,
            radiusY: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360,
            /* angle */
            direction: "clockwise",
            // clockwise | anticlockwise
            closeType: "none"
            // none | sector | normal
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[n]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get radiusX() {
          return this[n]("radiusX");
        }
        set radiusX(h) {
          if (h = Object(W.toNumber)(h), this[e]("radiusX", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get radiusY() {
          return this[n]("radiusY");
        }
        set radiusY(h) {
          if (h = Object(W.toNumber)(h), this[e]("radiusY", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get radius() {
          return [this.radiusX, this.radiusY];
        }
        set radius(h) {
          h = Object(W.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this.radiusX = h[0], this.radiusY = h[1];
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(h) {
          h = Object(W.toArray)(h), Array.isArray(h) || (h = [h, h]), this.startAngle = h[0], this.endAngle = h[1];
        }
        get direction() {
          return this[n]("direction");
        }
        set direction(h) {
          if (h != null && h !== "clockwise" && h !== "anticlockwise")
            throw new TypeError("Invalid direction type.");
          this[e]("direction", h);
        }
        get startAngle() {
          return this[n]("startAngle");
        }
        set startAngle(h) {
          if (h = Object(W.toNumber)(h), this[e]("startAngle", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get endAngle() {
          return this[n]("endAngle");
        }
        set endAngle(h) {
          if (h = Object(W.toNumber)(h), this[e]("endAngle", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get closeType() {
          return this[n]("closeType");
        }
        set closeType(h) {
          if (h != null && h !== "none" && h !== "sector" && h !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[e]("closeType", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
      }
    },
    /* 244 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(242), c = l(213), W = l(245);
      l(1).glMatrix.setMatrixArrayType(Array);
      function u(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends s.default {
      }
      u(e, "Attr", W.default), c.default.registerNode(e, "arc");
    },
    /* 245 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return W;
      });
      var s = l(243), c = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      class W extends s.default {
        get radius() {
          return super.radiusX;
        }
        set radius(e) {
          e = Object(c.toNumber)(e), super.radiusX = e, super.radiusY = e;
        }
      }
    },
    /* 246 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(226), c = l(213), W = l(247);
      l(1).glMatrix.setMatrixArrayType(Array);
      function u(n, G, y) {
        return G in n ? Object.defineProperty(n, G, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : n[G] = y, n;
      }
      class e extends s.default {
        /* override */
        get isVisible() {
          const {
            innerRadius: G,
            outerRadius: y,
            startAngle: a,
            endAngle: I
          } = this.attributes;
          return (G > 0 || y > 0) && a !== I && super.isVisible;
        }
      }
      u(e, "Attr", W.default), c.default.registerNode(e, "ring");
    },
    /* 247 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return a;
      });
      var s = l(12), c = l(228), W = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      const u = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_setAttribute"), n = Symbol.for("spritejs_getAttribute"), G = Symbol.for("spritejs_declareAlias");
      function y(I) {
        let {
          innerRadius: h,
          outerRadius: S,
          startAngle: p,
          endAngle: X
        } = I;
        const V = new s.Figure2D();
        if (p = Math.PI * p / 180, X = Math.PI * X / 180, h > S && ([h, S] = [S, h]), h <= 0 && V.moveTo(0, 0), V.arc(0, 0, S, p, X, !1), h > 0) {
          const t = Math.PI * 2;
          X < p && (X = p + t + (X - p) % t), X - p >= t && (X = p + t - 1e-6), V.arc(0, 0, h, X, p, !0);
        }
        return V.closePath(), V.path.reduce((t, m) => t + m.join(" "), "");
      }
      class a extends c.default {
        constructor(h) {
          super(h), this[u]({
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360
            /* angle */
          }), this[G]("radius", "angle");
        }
        // readonly
        get d() {
          return this[n]("d");
        }
        set d(h) {
        }
        // eslint-disable-line no-empty-function
        get innerRadius() {
          return this[n]("innerRadius");
        }
        set innerRadius(h) {
          if (h = Object(W.toNumber)(h), this[e]("innerRadius", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get outerRadius() {
          return this[n]("outerRadius");
        }
        set outerRadius(h) {
          if (h = Object(W.toNumber)(h), this[e]("outerRadius", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(h) {
          h = Object(W.toArray)(h, !0), Array.isArray(h) || (h = [h, h]), this.innerRadius = h[0], this.outerRadius = h[1];
        }
        get startAngle() {
          return this[n]("startAngle");
        }
        set startAngle(h) {
          if (h = Object(W.toNumber)(h), this[e]("startAngle", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get endAngle() {
          return this[n]("endAngle");
        }
        set endAngle(h) {
          if (h = Object(W.toNumber)(h), this[e]("endAngle", h)) {
            const S = y(this);
            this[e]("d", S);
          }
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(h) {
          h = Object(W.toArray)(h), Array.isArray(h) || (h = [h, h]), this.startAngle = h[0], this.endAngle = h[1];
        }
      }
    },
    /* 248 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return S;
      });
      var s = l(12), c = l(218), W = l(219), u = l(249), e = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      function n(p, X, V) {
        return X in p ? Object.defineProperty(p, X, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : p[X] = V, p;
      }
      const G = Symbol("textImage"), y = Symbol("textImageTask"), a = Symbol("textureContext"), I = Symbol("updateTextureRect"), h = Symbol("textCanvas");
      class S extends W.default {
        constructor(X = {}) {
          typeof X == "string" && (X = {
            text: X
          }), super(X);
        }
        /* override */
        get contentSize() {
          let [X, V] = super.contentSize;
          const {
            width: i,
            height: b
          } = this.attributes;
          if (i == null || b == null) {
            const t = this[G];
            t && (i == null && (X = t.rect[2]), b == null && (V = t.rect[3]));
          }
          return [X, V];
        }
        get text() {
          return this.attributes.text;
        }
        set text(X) {
          this.attributes.text = X;
        }
        get textContent() {
          return this.attributes.text;
        }
        set textContent(X) {
          this.attributes.text = X;
        }
        get textImage() {
          return this[G] || {};
        }
        get textImageReady() {
          return this[y] || Promise.resolve();
        }
        /* override */
        draw(X) {
          super.draw(X);
          const V = this.mesh;
          if (V) {
            const i = this[G];
            if (i) {
              let b = V.texture;
              if (!b || this[a] && this[a] !== this.renderer || i.needsUpdate ? (i.needsUpdate = !1, Object(c.deleteTexture)(i.image, this.renderer), b = Object(c.createTexture)(i.image, this.renderer), this[I] = !0) : b = V.uniforms.u_texSampler, this[I]) {
                const [t, m] = i.rect.slice(2), [R, x] = this.contentSize, C = this.attributes.textAlign, T = this.attributes.verticalAlign;
                let K = 0;
                C === "center" ? K = (R - t) / 2 : (C === "right" || C === "end") && (K = R - t);
                const J = this.attributes.fontSize, F = this.attributes.lineHeight;
                let r = 0;
                T === "top" ? r = (J - F) / 2 : T === "bottom" && (r = (F - J) / 2);
                const {
                  paddingLeft: Y,
                  paddingTop: H
                } = this.attributes, {
                  borderWidth: Q
                } = this.attributes;
                K += Y + Q, r += H + Q;
                const {
                  anchorX: w,
                  anchorY: O
                } = this.attributes;
                K -= this.offsetSize[0] * w, r -= this.offsetSize[1] * O, V.setTexture(b, {
                  rect: [K, r, t, m]
                }), this[I] = !1, this[a] = this.renderer;
              }
            }
          }
          return X;
        }
        /* override */
        onPropertyChange(X, V, i) {
          X === "text" || X === "fontSize" || X === "fontFamily" || X === "fontStyle" || X === "fontVariant" || X === "fontWeight" || X === "fontStretch" || X === "lineHeight" || X === "strokeColor" || X === "fillColor" || X === "strokeWidth" ? this.updateText() : ((X === "textAlign" || X === "verticalAlign") && (this[I] = !0), super.onPropertyChange(X, V, i));
        }
        /* override */
        updateContours() {
          super.updateContours(), this[I] = !0;
        }
        updateText() {
          this[y] || (this[y] = Promise.resolve().then(() => {
            this[y] = null;
            const {
              text: X,
              font: V,
              fillColor: i,
              strokeColor: b,
              strokeWidth: t
            } = this.attributes, m = this.layer ? this.layer.displayRatio : 1;
            return this[h] = this[h] || s.ENV.createCanvas(1, 1), this[G] = s.ENV.createText(X, {
              font: V,
              fillColor: i,
              strokeColor: b,
              strokeWidth: t,
              parseFont: s.parseFont,
              ratio: m,
              textCanvas: this[h]
            }), this[G].needsUpdate = !0, this.updateContours(), this.forceUpdate(), this[G];
          }));
        }
      }
      n(S, "Attr", u.default), e.default.registerNode(S, "label");
    },
    /* 249 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return a;
      });
      var s = l(12), c = l(72), W = l(221), u = l(220);
      l(1).glMatrix.setMatrixArrayType(Array);
      const e = Symbol.for("spritejs_setAttributeDefault"), n = Symbol.for("spritejs_setAttribute"), G = Symbol.for("spritejs_getAttribute"), y = Symbol.for("spritejs_declareAlias");
      class a extends u.default {
        constructor(h) {
          super(h), this[e]({
            text: "",
            fontSize: 16,
            fontFamily: "Helvetica,Arial,sans-serif",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            fontStretch: "normal",
            lineHeight: "",
            /* font */
            textAlign: "left",
            strokeColor: void 0,
            strokeWidth: 1,
            fillColor: void 0,
            verticalAlign: "middle"
          }), this[y]("font");
        }
        get text() {
          return this[G]("text") || " ";
        }
        set text(h) {
          this[n]("text", h);
        }
        get fontSize() {
          return this[G]("fontSize");
        }
        set fontSize(h) {
          this[n]("fontSize", Object(c.toNumber)(h));
        }
        get fontFamily() {
          return this[G]("fontFamily");
        }
        set fontFamily(h) {
          this[n]("fontFamily", h);
        }
        get fontStyle() {
          return this[G]("fontStyle");
        }
        set fontStyle(h) {
          this[n]("fontStyle", h);
        }
        get fontVariant() {
          return this[G]("fontVariant");
        }
        set fontVariant(h) {
          this[n]("fontVariant", h);
        }
        get fontWeight() {
          return this[G]("fontWeight");
        }
        set fontWeight(h) {
          this[n]("fontWeight", h);
        }
        get fontStretch() {
          return this[G]("fontStretch");
        }
        set fontStretch(h) {
          this[n]("fontStretch", h);
        }
        get lineHeight() {
          return this[G]("lineHeight") || this.fontSize;
        }
        set lineHeight(h) {
          this[n]("lineHeight", Object(c.toNumber)(h));
        }
        get textAlign() {
          return this[G]("textAlign");
        }
        set textAlign(h) {
          this[n]("textAlign", h);
        }
        get strokeColor() {
          return this[G]("strokeColor");
        }
        set strokeColor(h) {
          this[n]("strokeColor", Object(W.parseColor)(h));
        }
        get strokeWidth() {
          return this[G]("strokeWidth");
        }
        set strokeWidth(h) {
          this[n]("strokeWidth", Object(c.toNumber)(h));
        }
        get verticalAlign() {
          return this[G]("verticalAlign");
        }
        set verticalAlign(h) {
          this[n]("verticalAlign", h);
        }
        get fillColor() {
          return this[G]("fillColor");
        }
        set fillColor(h) {
          this[n]("fillColor", Object(W.parseColor)(h));
        }
        get font() {
          const {
            fontStyle: h,
            fontVariant: S,
            fontWeight: p,
            fontStretch: X,
            fontSize: V,
            lineHeight: i,
            fontFamily: b
          } = this;
          return `${h} ${S} ${p} ${X} ${V}px/${i}px ${b}`;
        }
        set font(h) {
          if (h == null)
            this.fontStyle = null, this.fontVariant = null, this.fontWeight = null, this.fontStretch = null, this.fontSize = null, this.lineHeight = null, this.fontFamily = null;
          else {
            const S = Object(s.parseFont)(h);
            this.fontStyle = S.style, this.fontVariant = S.variant, this.fontWeight = S.weight, this.fontStretch = S.stretch, this.fontSize = Object(c.toNumber)(`${S.size}${S.unit}`), S.lineHeight && (this.lineHeight = S.pxLineHeight), this.fontFamily = S.family;
          }
        }
      }
    },
    /* 250 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return h;
      });
      var s = l(12), c = l(219), W = l(251), u = l(213), e = l(252);
      l(1).glMatrix.setMatrixArrayType(Array);
      function n(S, p, X) {
        return p in S ? Object.defineProperty(S, p, { value: X, enumerable: !0, configurable: !0, writable: !0 }) : S[p] = X, S;
      }
      const G = Symbol("zOrder"), y = Symbol("ordered"), a = Symbol("children"), I = Symbol("sealed");
      class h extends c.default {
        constructor(p = {}) {
          super(p), this[a] = [], this[y] = null, this[G] = 0;
        }
        get childNodes() {
          return this[a];
        }
        get children() {
          return this[a];
        }
        get orderedChildren() {
          return this[y] || (this[y] = [...this[a]], this[y].sort((p, X) => p.zIndex - X.zIndex || p.zOrder - X.zOrder)), this[y];
        }
        append(...p) {
          return p.map((X) => this.appendChild(X));
        }
        appendChild(p) {
          return p.remove(), this[a].push(p), p.connect(this, this[G]++), this[y] && (this[y].length && p.zIndex < this[y][this[y].length - 1].zIndex ? this.reorder() : this[y].push(p)), p;
        }
        /* override */
        // get isVisible() {
        //   return this.attributes.opacity > 0 && this[_children].length > 0;
        // }
        /* override */
        cloneNode(p = !1) {
          const X = super.cloneNode();
          return p && this[a].forEach((V) => {
            const i = V.cloneNode(p);
            X.appendChild(i);
          }), X;
        }
        /* override */
        dispatchPointerEvent(p) {
          const X = this.orderedChildren;
          for (let V = X.length - 1; V >= 0; V--)
            if (X[V].dispatchPointerEvent(p))
              return !0;
          return super.dispatchPointerEvent(p);
        }
        /* override */
        draw(p = []) {
          if (this.__cacheRenderMatrix = this.renderMatrix, super.draw(p), !this[I] && this.attributes.display !== "none") {
            const X = this.orderedChildren;
            for (let V = 0; V < X.length; V++)
              X[V].draw(p);
          }
          return this.__cacheRenderMatrix = null, p;
        }
        getElementById(p) {
          return Object(e.querySelector)(`#${p}`, this);
        }
        getElementsByClassName(p) {
          return Object(e.querySelectorAll)(`.${p}`, this);
        }
        getElementsByName(p) {
          return Object(e.querySelectorAll)(`[name="${p}"]`, this);
        }
        getElementsByTagName(p) {
          return Object(e.querySelectorAll)(p, this);
        }
        insertBefore(p, X) {
          if (X == null)
            return this.appendChild(p);
          p.remove();
          const V = this[a].indexOf(X);
          if (V < 0)
            throw new Error("Invalid reference node.");
          const i = X.zOrder;
          for (let b = V; b < this[a].length; b++) {
            const t = this[a][b].zOrder, m = this[a][b];
            delete m.zOrder, Object.defineProperty(m, "zOrder", {
              value: t + 1,
              writable: !1,
              configurable: !0
            });
          }
          if (this[a].splice(V, 0, p), p.connect(this, i), this[y])
            if (p.zIndex !== X.zIndex)
              this.reorder();
            else {
              const b = this[y].indexOf(X);
              this[y].splice(b, 0, p);
            }
          return p;
        }
        querySelector(p) {
          return Object(e.querySelector)(p, this);
        }
        querySelectorAll(p) {
          return Object(e.querySelectorAll)(p, this);
        }
        replaceChild(p, X) {
          p.remove();
          const V = this[a].indexOf(X);
          if (V < 0)
            throw new Error("Invalid reference node.");
          if (this[a][V] = p, p.connect(this, X.zOrder), this[y])
            if (p.zIndex !== X.zIndex)
              this.reorder();
            else {
              const i = this[y].indexOf(X);
              this[y][i] = p;
            }
          return X.disconnect(this), p;
        }
        removeAllChildren() {
          const p = this[a];
          for (let X = p.length - 1; X >= 0; X--)
            p[X].remove();
        }
        removeChild(p) {
          const X = this[a].indexOf(p);
          if (X >= 0) {
            if (this[a].splice(X, 1), this[y]) {
              const V = this[y].indexOf(p);
              this[y].splice(V, 1);
            }
            return p.disconnect(this), p;
          }
          return null;
        }
        reorder() {
          this[y] = null;
        }
        seal() {
          function p(b, t) {
            const m = [];
            for (let R = 0; R < b.length; R++) {
              const x = [...b[R]];
              for (let C = 1; C < x.length; C += 2) {
                const T = x[C], K = x[C + 1];
                x[C] = T * t[0] + K * t[2] + t[4], x[C + 1] = T * t[1] + K * t[3] + t[5];
              }
              m.push(x);
            }
            return m;
          }
          const X = this.orderedChildren, V = new s.Figure2D(), i = this.localMatrix;
          for (let b = 0; b < X.length; b++) {
            let t = X[b];
            if (t instanceof h && (t = t.seal()), t.clientBox) {
              let m = t.clientBox.contours.path;
              m = p(m, t.localMatrix), V.addPath(m);
            }
            if (t.path) {
              let m = t.path.contours.path;
              m = p(m, t.localMatrix), V.addPath(m);
            }
          }
          return this[I] = !0, this.clientBox = V, {
            clientBox: V,
            localMatrix: i
          };
        }
        /* override */
        setResolution({
          width: p,
          height: X
        }) {
          super.setResolution({
            width: p,
            height: X
          }), this[a].forEach((V) => {
            V.setResolution({
              width: p,
              height: X
            });
          });
        }
        /* override */
        updateContours() {
          this[I] || super.updateContours();
        }
      }
      n(h, "Attr", W.default), u.default.registerNode(h, "group");
    },
    /* 251 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return c;
      });
      var s = l(220);
      l(1).glMatrix.setMatrixArrayType(Array);
      class c extends s.default {
        // constructor(subject) {
        //   super(subject);
        //   this[setDefault]({
        //     pointerEvents: 'all',
        //   });
        // }
      }
    },
    /* 252 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "querySelectorAll", function() {
        return I;
      }), l.d(d, "querySelector", function() {
        return h;
      }), l.d(d, "isMatched", function() {
        return S;
      }), l.d(d, "compile", function() {
        return p;
      });
      var s = l(221), c = l(213);
      l(1).glMatrix.setMatrixArrayType(Array);
      const W = l(253);
      function u(X) {
        return X.nodeType === 1 || c.default.isSpriteNode(X.nodeName);
      }
      function e(X) {
        return Array.from(X.childNodes || []);
      }
      function n(X) {
        return c.default.isSpriteNode(X.nodeName) ? X.parent || X.canvas || X.container : X.parentElement;
      }
      function G(X) {
        let V = X.length, i, b, t;
        for (; --V > -1; ) {
          for (i = b = X[V], X[V] = null, t = !0; b; ) {
            if (X.indexOf(b) > -1) {
              t = !1, X.splice(V, 1);
              break;
            }
            b = n(b);
          }
          t && (X[V] = i);
        }
        return X;
      }
      const y = {
        isTag: u,
        existsOne(X, V) {
          return V.some((i) => u(i) ? X(i) || y.existsOne(X, e(i)) : !1);
        },
        getSiblings(X) {
          const V = n(X);
          return V && e(V);
        },
        getChildren: e,
        getParent: n,
        getAttributeValue(X, V) {
          if (X.nodeType === 1 && V === "class" || V === "id")
            return X[V];
          if (this.hasAttrib(X, V)) {
            let i = X.attributes[V];
            return Array.isArray(i) && (i = `[${i.join()}]`), String(i);
          }
        },
        hasAttrib(X, V) {
          return X.attributes[V] != null;
        },
        removeSubsets: G,
        getName(X) {
          return X.tagName ? X.tagName.toLowerCase() : null;
        },
        findOne: function X(V, i) {
          let b = null;
          for (let t = 0, m = i.length; t < m && !b; t++)
            if (V(i[t]))
              b = i[t];
            else {
              const R = e(i[t]);
              R && R.length > 0 && (b = X(V, R));
            }
          return b;
        },
        findAll: function X(V, i) {
          let b = [];
          for (let t = 0, m = i.length; t < m; t++) {
            if (!u(i[t]))
              continue;
            V(i[t]) && b.push(i[t]);
            const R = e(i[t]);
            R && (b = b.concat(X(V, R)));
          }
          return b;
        },
        getText: function X(V) {
          return Array.isArray(V) ? V.map(X).join("") : u(V) ? X(e(V)) : V.nodeType === 3 ? V.nodeValue : c.default.isSpriteNode(V.nodeName) ? V.text : "";
        }
      };
      function a(X) {
        if (typeof X != "string")
          return X;
        let V = X.match(/\[(bgcolor|fillColor|strokeColor|color)\s*=\s*['"]?\w+['"]?\]/g);
        return V && (V = V.map((i) => {
          const b = i.slice(1, -1).split("="), t = Object(s.parseColor)(b[1].replace(/['"]/g, ""));
          return [i, `[${b[0]}="${t}"]`];
        }), V.forEach(([i, b]) => {
          X = X.replace(i, b);
        })), V = X.match(/\[\w+\s*=\s*['"]\[.+?\]['"]\]/g), V && (V = V.map((i) => {
          const b = i.slice(1, -1).split("="), t = b[1].slice(2, -2).split(/,/g).map((m) => m.trim());
          return [i, `[${b[0]}="[${t}]"]`];
        }), V.forEach(([i, b]) => {
          X = X.replace(i, b);
        })), X;
      }
      function I(X, V) {
        return W.selectAll(a(X), V, {
          adapter: y
        });
      }
      function h(X, V) {
        return W.selectOne(a(X), V, {
          adapter: y
        });
      }
      function S(X, V) {
        return W.is(X, a(V), {
          adapter: y
        });
      }
      function p(X) {
        return W.compile(a(X), {
          adapter: y
        });
      }
    },
    /* 253 */
    /***/
    function(Z, d, l) {
      Z.exports = p;
      var s = l(254), c = l(273).falseFunc, W = l(274);
      function u(X) {
        return function(i, b, t) {
          return b = b || {}, b.adapter = b.adapter || s, X(i, b, t);
        };
      }
      var e = u(W), n = u(W.compileUnsafe);
      function G(X) {
        return function(i, b, t) {
          return t = t || {}, t.adapter = t.adapter || s, typeof i != "function" && (i = n(i, t, b)), i.shouldTestNextSiblings && (b = a(t && t.context || b, t.adapter)), Array.isArray(b) ? b = t.adapter.removeSubsets(b) : b = t.adapter.getChildren(b), X(i, b, t);
        };
      }
      function y(X, V) {
        var i = V.getSiblings(X);
        if (!Array.isArray(i))
          return [];
        for (i = i.slice(0); i.shift() !== X; )
          ;
        return i;
      }
      function a(X, V) {
        Array.isArray(X) || (X = [X]);
        for (var i = X.slice(0), b = 0, t = X.length; b < t; b++) {
          var m = y(i[b], V);
          i.push.apply(i, m);
        }
        return i;
      }
      var I = G(function(V, i, b) {
        return V === c || !i || i.length === 0 ? [] : b.adapter.findAll(V, i);
      }), h = G(function(V, i, b) {
        return V === c || !i || i.length === 0 ? null : b.adapter.findOne(V, i);
      });
      function S(X, V, i) {
        return i = i || {}, i.adapter = i.adapter || s, (typeof V == "function" ? V : e(V, i))(X);
      }
      function p(X, V, i) {
        return I(X, V, i);
      }
      p.compile = e, p.filters = W.Pseudos.filters, p.pseudos = W.Pseudos.pseudos, p.selectAll = I, p.selectOne = h, p.is = S, p.parse = e, p.iterate = I, p._compileUnsafe = n, p._compileToken = W.compileToken;
    },
    /* 254 */
    /***/
    function(Z, d, l) {
      var s = Z.exports;
      [
        l(255),
        l(268),
        l(269),
        l(270),
        l(271),
        l(272)
      ].forEach(function(c) {
        Object.keys(c).forEach(function(W) {
          s[W] = c[W].bind(s);
        });
      });
    },
    /* 255 */
    /***/
    function(Z, d, l) {
      var s = l(256), c = l(257), W = s.isTag;
      Z.exports = {
        getInnerHTML: u,
        getOuterHTML: c,
        getText: e
      };
      function u(n, G) {
        return n.children ? n.children.map(function(y) {
          return c(y, G);
        }).join("") : "";
      }
      function e(n) {
        return Array.isArray(n) ? n.map(e).join("") : W(n) ? n.name === "br" ? `
` : e(n.children) : n.type === s.CDATA ? e(n.children) : n.type === s.Text ? n.data : "";
      }
    },
    /* 256 */
    /***/
    function(Z, d) {
      Z.exports = {
        Text: "text",
        //Text
        Directive: "directive",
        //<? ... ?>
        Comment: "comment",
        //<!-- ... -->
        Script: "script",
        //<script> tags
        Style: "style",
        //<style> tags
        Tag: "tag",
        //Any tag
        CDATA: "cdata",
        //<![CDATA[ ... ]]>
        Doctype: "doctype",
        isTag: function(l) {
          return l.type === "tag" || l.type === "script" || l.type === "style";
        }
      };
    },
    /* 257 */
    /***/
    function(Z, d, l) {
      var s = l(258), c = l(259), W = l(267);
      W.elementNames.__proto__ = null, W.attributeNames.__proto__ = null;
      var u = {
        __proto__: null,
        style: !0,
        script: !0,
        xmp: !0,
        iframe: !0,
        noembed: !0,
        noframes: !0,
        plaintext: !0,
        noscript: !0
      };
      function e(X, V) {
        if (X) {
          var i = "", b;
          for (var t in X)
            b = X[t], i && (i += " "), V.xmlMode === "foreign" && (t = W.attributeNames[t] || t), i += t, (b !== null && b !== "" || V.xmlMode) && (i += '="' + (V.decodeEntities ? c.encodeXML(b) : b.replace(/\"/g, "&quot;")) + '"');
          return i;
        }
      }
      var n = {
        __proto__: null,
        area: !0,
        base: !0,
        basefont: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        isindex: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, G = Z.exports = function(X, V) {
        !Array.isArray(X) && !X.cheerio && (X = [X]), V = V || {};
        for (var i = "", b = 0; b < X.length; b++) {
          var t = X[b];
          t.type === "root" ? i += G(t.children, V) : s.isTag(t) ? i += a(t, V) : t.type === s.Directive ? i += I(t) : t.type === s.Comment ? i += p(t) : t.type === s.CDATA ? i += S(t) : i += h(t, V);
        }
        return i;
      }, y = [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ];
      function a(X, V) {
        V.xmlMode === "foreign" && (X.name = W.elementNames[X.name] || X.name, X.parent && y.indexOf(X.parent.name) >= 0 && (V = Object.assign({}, V, { xmlMode: !1 }))), !V.xmlMode && ["svg", "math"].indexOf(X.name) >= 0 && (V = Object.assign({}, V, { xmlMode: "foreign" }));
        var i = "<" + X.name, b = e(X.attribs, V);
        return b && (i += " " + b), V.xmlMode && (!X.children || X.children.length === 0) ? i += "/>" : (i += ">", X.children && (i += G(X.children, V)), (!n[X.name] || V.xmlMode) && (i += "</" + X.name + ">")), i;
      }
      function I(X) {
        return "<" + X.data + ">";
      }
      function h(X, V) {
        var i = X.data || "";
        return V.decodeEntities && !(X.parent && X.parent.name in u) && (i = c.encodeXML(i)), i;
      }
      function S(X) {
        return "<![CDATA[" + X.children[0].data + "]]>";
      }
      function p(X) {
        return "<!--" + X.data + "-->";
      }
    },
    /* 258 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 });
      function s(c) {
        return c.type === "tag" || c.type === "script" || c.type === "style";
      }
      d.isTag = s, d.Text = "text", d.Directive = "directive", d.Comment = "comment", d.Script = "script", d.Style = "style", d.Tag = "tag", d.CDATA = "cdata", d.Doctype = "doctype";
    },
    /* 259 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 }), d.encode = d.decodeStrict = d.decode = void 0;
      var s = l(260), c = l(266);
      function W(y, a) {
        return (!a || a <= 0 ? s.decodeXML : s.decodeHTML)(y);
      }
      d.decode = W;
      function u(y, a) {
        return (!a || a <= 0 ? s.decodeXML : s.decodeHTMLStrict)(y);
      }
      d.decodeStrict = u;
      function e(y, a) {
        return (!a || a <= 0 ? c.encodeXML : c.encodeHTML)(y);
      }
      d.encode = e;
      var n = l(266);
      Object.defineProperty(d, "encodeXML", { enumerable: !0, get: function() {
        return n.encodeXML;
      } }), Object.defineProperty(d, "encodeHTML", { enumerable: !0, get: function() {
        return n.encodeHTML;
      } }), Object.defineProperty(d, "escape", { enumerable: !0, get: function() {
        return n.escape;
      } }), Object.defineProperty(d, "encodeHTML4", { enumerable: !0, get: function() {
        return n.encodeHTML;
      } }), Object.defineProperty(d, "encodeHTML5", { enumerable: !0, get: function() {
        return n.encodeHTML;
      } });
      var G = l(260);
      Object.defineProperty(d, "decodeXML", { enumerable: !0, get: function() {
        return G.decodeXML;
      } }), Object.defineProperty(d, "decodeHTML", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(d, "decodeHTMLStrict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(d, "decodeHTML4", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(d, "decodeHTML5", { enumerable: !0, get: function() {
        return G.decodeHTML;
      } }), Object.defineProperty(d, "decodeHTML4Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(d, "decodeHTML5Strict", { enumerable: !0, get: function() {
        return G.decodeHTMLStrict;
      } }), Object.defineProperty(d, "decodeXMLStrict", { enumerable: !0, get: function() {
        return G.decodeXML;
      } });
    },
    /* 260 */
    /***/
    function(Z, d, l) {
      var s = this && this.__importDefault || function(a) {
        return a && a.__esModule ? a : { default: a };
      };
      Object.defineProperty(d, "__esModule", { value: !0 }), d.decodeHTML = d.decodeHTMLStrict = d.decodeXML = void 0;
      var c = s(l(261)), W = s(l(262)), u = s(l(263)), e = s(l(264));
      d.decodeXML = n(u.default), d.decodeHTMLStrict = n(c.default);
      function n(a) {
        var I = Object.keys(a).join("|"), h = y(a);
        I += "|#[xX][\\da-fA-F]+|#\\d+";
        var S = new RegExp("&(?:" + I + ");", "g");
        return function(p) {
          return String(p).replace(S, h);
        };
      }
      var G = function(a, I) {
        return a < I ? 1 : -1;
      };
      d.decodeHTML = function() {
        for (var a = Object.keys(W.default).sort(G), I = Object.keys(c.default).sort(G), h = 0, S = 0; h < I.length; h++)
          a[S] === I[h] ? (I[h] += ";?", S++) : I[h] += ";";
        var p = new RegExp("&(?:" + I.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), X = y(c.default);
        function V(i) {
          return i.substr(-1) !== ";" && (i += ";"), X(i);
        }
        return function(i) {
          return String(i).replace(p, V);
        };
      }();
      function y(a) {
        return function(h) {
          if (h.charAt(1) === "#") {
            var S = h.charAt(2);
            return S === "X" || S === "x" ? e.default(parseInt(h.substr(3), 16)) : e.default(parseInt(h.substr(2), 10));
          }
          return a[h.slice(1, -1)];
        };
      }
    },
    /* 261 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');
    },
    /* 262 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');
    },
    /* 263 */
    /***/
    function(Z) {
      Z.exports = JSON.parse(`{"amp":"&","apos":"'","gt":">","lt":"<","quot":"\\""}`);
    },
    /* 264 */
    /***/
    function(Z, d, l) {
      var s = this && this.__importDefault || function(u) {
        return u && u.__esModule ? u : { default: u };
      };
      Object.defineProperty(d, "__esModule", { value: !0 });
      var c = s(l(265));
      function W(u) {
        if (u >= 55296 && u <= 57343 || u > 1114111)
          return "�";
        u in c.default && (u = c.default[u]);
        var e = "";
        return u > 65535 && (u -= 65536, e += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), e += String.fromCharCode(u), e;
      }
      d.default = W;
    },
    /* 265 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');
    },
    /* 266 */
    /***/
    function(Z, d, l) {
      var s = this && this.__importDefault || function(V) {
        return V && V.__esModule ? V : { default: V };
      };
      Object.defineProperty(d, "__esModule", { value: !0 }), d.escape = d.encodeHTML = d.encodeXML = void 0;
      var c = s(l(263)), W = y(c.default), u = a(W);
      d.encodeXML = S(W, u);
      var e = s(l(261)), n = y(e.default), G = a(n);
      d.encodeHTML = S(n, G);
      function y(V) {
        return Object.keys(V).sort().reduce(function(i, b) {
          return i[V[b]] = "&" + b + ";", i;
        }, {});
      }
      function a(V) {
        for (var i = [], b = [], t = 0, m = Object.keys(V); t < m.length; t++) {
          var R = m[t];
          R.length === 1 ? i.push("\\" + R) : b.push(R);
        }
        i.sort();
        for (var x = 0; x < i.length - 1; x++) {
          for (var C = x; C < i.length - 1 && i[C].charCodeAt(1) + 1 === i[C + 1].charCodeAt(1); )
            C += 1;
          var T = 1 + C - x;
          T < 3 || i.splice(x, T, i[x] + "-" + i[C]);
        }
        return b.unshift("[" + i.join("") + "]"), new RegExp(b.join("|"), "g");
      }
      var I = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
      function h(V) {
        return "&#x" + V.codePointAt(0).toString(16).toUpperCase() + ";";
      }
      function S(V, i) {
        return function(b) {
          return b.replace(i, function(t) {
            return V[t];
          }).replace(I, h);
        };
      }
      var p = a(W);
      function X(V) {
        return V.replace(p, h).replace(I, h);
      }
      d.escape = X;
    },
    /* 267 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}}');
    },
    /* 268 */
    /***/
    function(Z, d) {
      var l = d.getChildren = function(c) {
        return c.children;
      }, s = d.getParent = function(c) {
        return c.parent;
      };
      d.getSiblings = function(c) {
        var W = s(c);
        return W ? l(W) : [c];
      }, d.getAttributeValue = function(c, W) {
        return c.attribs && c.attribs[W];
      }, d.hasAttrib = function(c, W) {
        return !!c.attribs && hasOwnProperty.call(c.attribs, W);
      }, d.getName = function(c) {
        return c.name;
      };
    },
    /* 269 */
    /***/
    function(Z, d) {
      d.removeElement = function(l) {
        if (l.prev && (l.prev.next = l.next), l.next && (l.next.prev = l.prev), l.parent) {
          var s = l.parent.children;
          s.splice(s.lastIndexOf(l), 1);
        }
      }, d.replaceElement = function(l, s) {
        var c = s.prev = l.prev;
        c && (c.next = s);
        var W = s.next = l.next;
        W && (W.prev = s);
        var u = s.parent = l.parent;
        if (u) {
          var e = u.children;
          e[e.lastIndexOf(l)] = s;
        }
      }, d.appendChild = function(l, s) {
        if (s.parent = l, l.children.push(s) !== 1) {
          var c = l.children[l.children.length - 2];
          c.next = s, s.prev = c, s.next = null;
        }
      }, d.append = function(l, s) {
        var c = l.parent, W = l.next;
        if (s.next = W, s.prev = l, l.next = s, s.parent = c, W) {
          if (W.prev = s, c) {
            var u = c.children;
            u.splice(u.lastIndexOf(W), 0, s);
          }
        } else
          c && c.children.push(s);
      }, d.prepend = function(l, s) {
        var c = l.parent;
        if (c) {
          var W = c.children;
          W.splice(W.lastIndexOf(l), 0, s);
        }
        l.prev && (l.prev.next = s), s.parent = c, s.prev = l.prev, s.next = l, l.prev = s;
      };
    },
    /* 270 */
    /***/
    function(Z, d, l) {
      var s = l(256).isTag;
      Z.exports = {
        filter: c,
        find: W,
        findOneChild: u,
        findOne: e,
        existsOne: n,
        findAll: G
      };
      function c(y, a, I, h) {
        return Array.isArray(a) || (a = [a]), (typeof h != "number" || !isFinite(h)) && (h = 1 / 0), W(y, a, I !== !1, h);
      }
      function W(y, a, I, h) {
        for (var S = [], p, X = 0, V = a.length; X < V && !(y(a[X]) && (S.push(a[X]), --h <= 0) || (p = a[X].children, I && p && p.length > 0 && (p = W(y, p, I, h), S = S.concat(p), h -= p.length, h <= 0))); X++)
          ;
        return S;
      }
      function u(y, a) {
        for (var I = 0, h = a.length; I < h; I++)
          if (y(a[I]))
            return a[I];
        return null;
      }
      function e(y, a) {
        for (var I = null, h = 0, S = a.length; h < S && !I; h++)
          if (s(a[h]))
            y(a[h]) ? I = a[h] : a[h].children.length > 0 && (I = e(y, a[h].children));
          else
            continue;
        return I;
      }
      function n(y, a) {
        for (var I = 0, h = a.length; I < h; I++)
          if (s(a[I]) && (y(a[I]) || a[I].children.length > 0 && n(y, a[I].children)))
            return !0;
        return !1;
      }
      function G(y, a) {
        for (var I = [], h = a.slice(); h.length; ) {
          var S = h.shift();
          s(S) && (S.children && S.children.length > 0 && h.unshift.apply(h, S.children), y(S) && I.push(S));
        }
        return I;
      }
    },
    /* 271 */
    /***/
    function(Z, d, l) {
      var s = l(256), c = d.isTag = s.isTag;
      d.testElement = function(n, G) {
        for (var y in n)
          if (n.hasOwnProperty(y)) {
            if (y === "tag_name") {
              if (!c(G) || !n.tag_name(G.name))
                return !1;
            } else if (y === "tag_type") {
              if (!n.tag_type(G.type))
                return !1;
            } else if (y === "tag_contains") {
              if (c(G) || !n.tag_contains(G.data))
                return !1;
            } else if (!G.attribs || !n[y](G.attribs[y]))
              return !1;
          }
        return !0;
      };
      var W = {
        tag_name: function(n) {
          return typeof n == "function" ? function(G) {
            return c(G) && n(G.name);
          } : n === "*" ? c : function(G) {
            return c(G) && G.name === n;
          };
        },
        tag_type: function(n) {
          return typeof n == "function" ? function(G) {
            return n(G.type);
          } : function(G) {
            return G.type === n;
          };
        },
        tag_contains: function(n) {
          return typeof n == "function" ? function(G) {
            return !c(G) && n(G.data);
          } : function(G) {
            return !c(G) && G.data === n;
          };
        }
      };
      function u(n, G) {
        return typeof G == "function" ? function(y) {
          return y.attribs && G(y.attribs[n]);
        } : function(y) {
          return y.attribs && y.attribs[n] === G;
        };
      }
      function e(n, G) {
        return function(y) {
          return n(y) || G(y);
        };
      }
      d.getElements = function(n, G, y, a) {
        var I = Object.keys(n).map(function(h) {
          var S = n[h];
          return h in W ? W[h](S) : u(h, S);
        });
        return I.length === 0 ? [] : this.filter(
          I.reduce(e),
          G,
          y,
          a
        );
      }, d.getElementById = function(n, G, y) {
        return Array.isArray(G) || (G = [G]), this.findOne(u("id", n), G, y !== !1);
      }, d.getElementsByTagName = function(n, G, y, a) {
        return this.filter(W.tag_name(n), G, y, a);
      }, d.getElementsByTagType = function(n, G, y, a) {
        return this.filter(W.tag_type(n), G, y, a);
      };
    },
    /* 272 */
    /***/
    function(Z, d) {
      d.removeSubsets = function(c) {
        for (var W = c.length, u, e, n; --W > -1; ) {
          for (u = e = c[W], c[W] = null, n = !0; e; ) {
            if (c.indexOf(e) > -1) {
              n = !1, c.splice(W, 1);
              break;
            }
            e = e.parent;
          }
          n && (c[W] = u);
        }
        return c;
      };
      var l = {
        DISCONNECTED: 1,
        PRECEDING: 2,
        FOLLOWING: 4,
        CONTAINS: 8,
        CONTAINED_BY: 16
      }, s = d.compareDocumentPosition = function(c, W) {
        var u = [], e = [], n, G, y, a, I, h;
        if (c === W)
          return 0;
        for (n = c; n; )
          u.unshift(n), n = n.parent;
        for (n = W; n; )
          e.unshift(n), n = n.parent;
        for (h = 0; u[h] === e[h]; )
          h++;
        return h === 0 ? l.DISCONNECTED : (G = u[h - 1], y = G.children, a = u[h], I = e[h], y.indexOf(a) > y.indexOf(I) ? G === W ? l.FOLLOWING | l.CONTAINED_BY : l.FOLLOWING : G === c ? l.PRECEDING | l.CONTAINS : l.PRECEDING);
      };
      d.uniqueSort = function(c) {
        var W = c.length, u, e;
        for (c = c.slice(); --W > -1; )
          u = c[W], e = c.indexOf(u), e > -1 && e < W && c.splice(W, 1);
        return c.sort(function(n, G) {
          var y = s(n, G);
          return y & l.PRECEDING ? -1 : y & l.FOLLOWING ? 1 : 0;
        }), c;
      };
    },
    /* 273 */
    /***/
    function(Z, d) {
      Z.exports = {
        trueFunc: function() {
          return !0;
        },
        falseFunc: function() {
          return !1;
        }
      };
    },
    /* 274 */
    /***/
    function(Z, d, l) {
      Z.exports = I;
      var s = l(275).parse, c = l(273), W = l(278), u = l(279), e = l(280), n = l(282), G = c.trueFunc, y = c.falseFunc, a = n.filters;
      function I(K, J, F) {
        var r = S(K, J, F);
        return h(r, J);
      }
      function h(K, J) {
        var F = J.adapter;
        return function(Y) {
          return F.isTag(Y) && K(Y);
        };
      }
      function S(K, J, F) {
        var r = s(K, J);
        return m(r, J, F);
      }
      function p(K) {
        return K.type === "pseudo" && (K.name === "scope" || Array.isArray(K.data) && K.data.some(function(J) {
          return J.some(p);
        }));
      }
      var X = { type: "descendant" }, V = { type: "_flexibleDescendant" }, i = { type: "pseudo", name: "scope" }, b = {};
      function t(K, J, F) {
        var r = J.adapter, Y = !!F && !!F.length && F.every(function(H) {
          return H === b || !!r.getParent(H);
        });
        K.forEach(function(H) {
          if (!(H.length > 0 && R(H[0]) && H[0].type !== "descendant"))
            if (Y && !(Array.isArray(H) ? H.some(p) : p(H)))
              H.unshift(X);
            else
              return;
          H.unshift(i);
        });
      }
      function m(K, J, F) {
        K = K.filter(function(Q) {
          return Q.length > 0;
        }), K.forEach(W);
        var r = Array.isArray(F);
        F = J && J.context || F, F && !r && (F = [F]), t(K, J, F);
        var Y = !1, H = K.map(function(Q) {
          if (Q[0] && Q[1] && Q[0].name === "scope") {
            var w = Q[1].type;
            r && w === "descendant" ? Q[1] = V : (w === "adjacent" || w === "sibling") && (Y = !0);
          }
          return x(Q, J, F);
        }).reduce(C, y);
        return H.shouldTestNextSiblings = Y, H;
      }
      function R(K) {
        return u[K.type] < 0;
      }
      function x(K, J, F) {
        return K.reduce(function(r, Y) {
          if (r === y)
            return r;
          if (!(Y.type in e))
            throw new Error("Rule type " + Y.type + " is not supported by css-select");
          return e[Y.type](r, Y, J, F);
        }, J && J.rootFunc || G);
      }
      function C(K, J) {
        return J === y || K === G ? K : K === y || J === G ? J : function(r) {
          return K(r) || J(r);
        };
      }
      function T(K) {
        return K.some(R);
      }
      a.not = function(K, J, F, r) {
        var Y = {
          xmlMode: !!(F && F.xmlMode),
          strict: !!(F && F.strict),
          adapter: F.adapter
        };
        if (Y.strict && (J.length > 1 || J.some(T)))
          throw new Error("complex selectors in :not aren't allowed in strict mode");
        var H = m(J, Y, r);
        return H === y ? K : H === G ? y : function(w) {
          return !H(w) && K(w);
        };
      }, a.has = function(K, J, F) {
        var r = F.adapter, Y = {
          xmlMode: !!(F && F.xmlMode),
          strict: !!(F && F.strict),
          adapter: r
        }, H = J.some(T) ? [b] : null, Q = m(J, Y, H);
        return Q === y ? y : Q === G ? function(O) {
          return r.getChildren(O).some(r.isTag) && K(O);
        } : (Q = h(Q, F), H ? function(O) {
          return K(O) && (H[0] = O, r.existsOne(Q, r.getChildren(O)));
        } : function(O) {
          return K(O) && r.existsOne(Q, r.getChildren(O));
        });
      }, a.matches = function(K, J, F, r) {
        var Y = {
          xmlMode: !!(F && F.xmlMode),
          strict: !!(F && F.strict),
          rootFunc: K,
          adapter: F.adapter
        };
        return m(J, Y, r);
      }, I.compileToken = m, I.compileUnsafe = S, I.Pseudos = n;
    },
    /* 275 */
    /***/
    function(Z, d, l) {
      var s = this && this.__createBinding || (Object.create ? function(e, n, G, y) {
        y === void 0 && (y = G), Object.defineProperty(e, y, { enumerable: !0, get: function() {
          return n[G];
        } });
      } : function(e, n, G, y) {
        y === void 0 && (y = G), e[y] = n[G];
      }), c = this && this.__exportStar || function(e, n) {
        for (var G in e)
          G !== "default" && !n.hasOwnProperty(G) && s(n, e, G);
      };
      Object.defineProperty(d, "__esModule", { value: !0 }), c(l(276), d);
      var W = l(276);
      Object.defineProperty(d, "parse", { enumerable: !0, get: function() {
        return W.default;
      } });
      var u = l(277);
      Object.defineProperty(d, "stringify", { enumerable: !0, get: function() {
        return u.default;
      } });
    },
    /* 276 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 }), d.default = p;
      var s = /^[^\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, c = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, W = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/, u = {
        undefined: "exists",
        "": "equals",
        "~": "element",
        "^": "start",
        $: "end",
        "*": "any",
        "!": "not",
        "|": "hyphen"
      }, e = {
        ">": "child",
        "<": "parent",
        "~": "sibling",
        "+": "adjacent"
      }, n = {
        "#": ["id", "equals"],
        ".": ["class", "element"]
      }, G = /* @__PURE__ */ new Set(["has", "not", "matches"]), y = /* @__PURE__ */ new Set(["contains", "icontains"]), a = /* @__PURE__ */ new Set(['"', "'"]);
      function I(i, b, t) {
        var m = parseInt(b, 16) - 65536;
        return m !== m || t ? b : m < 0 ? (
          // BMP codepoint
          String.fromCharCode(m + 65536)
        ) : (
          // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(m >> 10 | 55296, m & 1023 | 56320)
        );
      }
      function h(i) {
        return i.replace(c, I);
      }
      function S(i) {
        return i === " " || i === `
` || i === "	" || i === "\f" || i === "\r";
      }
      function p(i, b) {
        var t = [];
        if (i = X(t, "" + i, b), i !== "")
          throw new Error("Unmatched selector: " + i);
        return t;
      }
      function X(i, b, t) {
        var m = [], R = !1;
        function x() {
          var D = b.match(s);
          if (!D)
            throw new Error("Expected name, found " + b);
          var ll = D[0];
          return b = b.substr(ll.length), h(ll);
        }
        function C(D) {
          for (; S(b.charAt(D)); )
            D++;
          b = b.substr(D);
        }
        function T(D) {
          for (var ll = 0; b.charAt(--D) === "\\"; )
            ll++;
          return (ll & 1) === 1;
        }
        for (C(0); b !== ""; ) {
          var K = b.charAt(0);
          if (S(K))
            R = !0, C(1);
          else if (K in e)
            m.push({ type: e[K] }), R = !1, C(1);
          else if (K === ",") {
            if (m.length === 0)
              throw new Error("Empty sub-selector");
            i.push(m), m = [], R = !1, C(1);
          } else if (R && (m.length > 0 && m.push({ type: "descendant" }), R = !1), K === "*")
            b = b.substr(1), m.push({ type: "universal" });
          else if (K in n) {
            var J = n[K], F = J[0], r = J[1];
            b = b.substr(1), m.push({
              type: "attribute",
              name: F,
              action: r,
              value: x(),
              ignoreCase: !1
            });
          } else if (K === "[") {
            b = b.substr(1);
            var Y = b.match(W);
            if (!Y)
              throw new Error("Malformed attribute selector: " + b);
            b = b.substr(Y[0].length);
            var H = h(Y[1]);
            (!t || ("lowerCaseAttributeNames" in t ? t.lowerCaseAttributeNames : !t.xmlMode)) && (H = H.toLowerCase()), m.push({
              type: "attribute",
              name: H,
              action: u[Y[2]],
              value: h(Y[4] || Y[5] || ""),
              ignoreCase: !!Y[6]
            });
          } else if (K === ":") {
            if (b.charAt(1) === ":") {
              b = b.substr(2), m.push({
                type: "pseudo-element",
                name: x().toLowerCase()
              });
              continue;
            }
            b = b.substr(1);
            var Q = x().toLowerCase(), Y = null;
            if (b.charAt(0) === "(")
              if (G.has(Q)) {
                var w = b.charAt(1), O = a.has(w);
                if (b = b.substr(O ? 2 : 1), Y = [], b = X(Y, b, t), O) {
                  if (b.charAt(0) !== w)
                    throw new Error("Unmatched quotes in :" + Q);
                  b = b.substr(1);
                }
                if (b.charAt(0) !== ")")
                  throw new Error("Missing closing parenthesis in :" + Q + " (" + b + ")");
                b = b.substr(1);
              } else {
                for (var q = 1, k = 1; k > 0 && q < b.length; q++)
                  b.charAt(q) === "(" && !T(q) ? k++ : b.charAt(q) === ")" && !T(q) && k--;
                if (k)
                  throw new Error("Parenthesis not matched");
                if (Y = b.substr(1, q - 2), b = b.substr(q), y.has(Q)) {
                  var w = Y.charAt(0);
                  w === Y.slice(-1) && a.has(w) && (Y = Y.slice(1, -1)), Y = h(Y);
                }
              }
            m.push({ type: "pseudo", name: Q, data: Y });
          } else if (s.test(b)) {
            var P = x();
            (!t || ("lowerCaseTags" in t ? t.lowerCaseTags : !t.xmlMode)) && (P = P.toLowerCase()), m.push({ type: "tag", name: P });
          } else
            return m.length && m[m.length - 1].type === "descendant" && m.pop(), V(i, m), b;
        }
        return V(i, m), b;
      }
      function V(i, b) {
        if (i.length > 0 && b.length === 0)
          throw new Error("Empty sub-selector");
        i.push(b);
      }
    },
    /* 277 */
    /***/
    function(Z, d, l) {
      Object.defineProperty(d, "__esModule", { value: !0 });
      var s = {
        equals: "",
        element: "~",
        start: "^",
        end: "$",
        any: "*",
        not: "!",
        hyphen: "|"
      };
      function c(n) {
        return n.map(W).join(", ");
      }
      d.default = c;
      function W(n) {
        return n.map(u).join("");
      }
      function u(n) {
        switch (n.type) {
          case "child":
            return " > ";
          case "parent":
            return " < ";
          case "sibling":
            return " ~ ";
          case "adjacent":
            return " + ";
          case "descendant":
            return " ";
          case "universal":
            return "*";
          case "tag":
            return n.name;
          case "pseudo-element":
            return "::" + n.name;
          case "pseudo":
            return n.data === null ? ":" + n.name : typeof n.data == "string" ? ":" + n.name + "(" + n.data + ")" : ":" + n.name + "(" + c(n.data) + ")";
          case "attribute":
            return n.action === "exists" ? "[" + n.name + "]" : n.name === "id" && n.action === "equals" && !n.ignoreCase ? "#" + n.value : n.name === "class" && n.action === "element" && !n.ignoreCase ? "." + n.value : "[" + n.name + s[n.action] + "='" + n.value + "'" + (n.ignoreCase ? "i" : "") + "]";
          default:
            throw new Error("Unknown type");
        }
      }
      function e(n) {
        return n;
      }
    },
    /* 278 */
    /***/
    function(Z, d, l) {
      Z.exports = W;
      var s = l(279), c = {
        __proto__: null,
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4
      };
      function W(e) {
        for (var n = e.map(u), G = 1; G < e.length; G++) {
          var y = n[G];
          if (!(y < 0))
            for (var a = G - 1; a >= 0 && y < n[a]; a--) {
              var I = e[a + 1];
              e[a + 1] = e[a], e[a] = I, n[a + 1] = n[a], n[a] = y;
            }
        }
      }
      function u(e) {
        var n = s[e.type];
        if (n === s.attribute)
          n = c[e.action], n === c.equals && e.name === "id" && (n = 9), e.ignoreCase && (n >>= 1);
        else if (n === s.pseudo)
          if (!e.data)
            n = 3;
          else if (e.name === "has" || e.name === "contains")
            n = 0;
          else if (e.name === "matches" || e.name === "not") {
            n = 0;
            for (var G = 0; G < e.data.length; G++)
              if (e.data[G].length === 1) {
                var y = u(e.data[G][0]);
                if (y === 0) {
                  n = 0;
                  break;
                }
                y > n && (n = y);
              }
            e.data.length > 1 && n > 0 && (n -= 1);
          } else
            n = 1;
        return n;
      }
    },
    /* 279 */
    /***/
    function(Z) {
      Z.exports = JSON.parse('{"universal":50,"tag":30,"attribute":1,"pseudo":0,"descendant":-1,"child":-1,"parent":-1,"sibling":-1,"adjacent":-1}');
    },
    /* 280 */
    /***/
    function(Z, d, l) {
      var s = l(281), c = l(282);
      Z.exports = {
        __proto__: null,
        attribute: s.compile,
        pseudo: c.compile,
        //tags
        tag: function(W, u, e) {
          var n = u.name, G = e.adapter;
          return function(a) {
            return G.getName(a) === n && W(a);
          };
        },
        //traversal
        descendant: function(W, u, e) {
          var n = typeof WeakSet < "u" ? /* @__PURE__ */ new WeakSet() : null, G = e.adapter;
          return function(a) {
            for (var I = !1; !I && (a = G.getParent(a)); )
              (!n || !n.has(a)) && (I = W(a), !I && n && n.add(a));
            return I;
          };
        },
        _flexibleDescendant: function(W, u, e) {
          var n = e.adapter;
          return function(y) {
            for (var a = W(y); !a && (y = n.getParent(y)); )
              a = W(y);
            return a;
          };
        },
        parent: function(W, u, e) {
          if (e && e.strict)
            throw new Error("Parent selector isn't part of CSS3");
          var n = e.adapter;
          return function(a) {
            return n.getChildren(a).some(G);
          };
          function G(y) {
            return n.isTag(y) && W(y);
          }
        },
        child: function(W, u, e) {
          var n = e.adapter;
          return function(y) {
            var a = n.getParent(y);
            return !!a && W(a);
          };
        },
        sibling: function(W, u, e) {
          var n = e.adapter;
          return function(y) {
            for (var a = n.getSiblings(y), I = 0; I < a.length; I++)
              if (n.isTag(a[I])) {
                if (a[I] === y)
                  break;
                if (W(a[I]))
                  return !0;
              }
            return !1;
          };
        },
        adjacent: function(W, u, e) {
          var n = e.adapter;
          return function(y) {
            for (var a = n.getSiblings(y), I, h = 0; h < a.length; h++)
              if (n.isTag(a[h])) {
                if (a[h] === y)
                  break;
                I = a[h];
              }
            return !!I && W(I);
          };
        },
        universal: function(W) {
          return W;
        }
      };
    },
    /* 281 */
    /***/
    function(Z, d, l) {
      var s = l(273).falseFunc, c = /[-[\]{}()*+?.,\\^$|#\s]/g, W = {
        __proto__: null,
        equals: function(u, e, n) {
          var G = e.name, y = e.value, a = n.adapter;
          return e.ignoreCase ? (y = y.toLowerCase(), function(h) {
            var S = a.getAttributeValue(h, G);
            return S != null && S.toLowerCase() === y && u(h);
          }) : function(h) {
            return a.getAttributeValue(h, G) === y && u(h);
          };
        },
        hyphen: function(u, e, n) {
          var G = e.name, y = e.value, a = y.length, I = n.adapter;
          return e.ignoreCase ? (y = y.toLowerCase(), function(S) {
            var p = I.getAttributeValue(S, G);
            return p != null && (p.length === a || p.charAt(a) === "-") && p.substr(0, a).toLowerCase() === y && u(S);
          }) : function(S) {
            var p = I.getAttributeValue(S, G);
            return p != null && p.substr(0, a) === y && (p.length === a || p.charAt(a) === "-") && u(S);
          };
        },
        element: function(u, e, n) {
          var G = e.name, y = e.value, a = n.adapter;
          if (/\s/.test(y))
            return s;
          y = y.replace(c, "\\$&");
          var I = "(?:^|\\s)" + y + "(?:$|\\s)", h = e.ignoreCase ? "i" : "", S = new RegExp(I, h);
          return function(X) {
            var V = a.getAttributeValue(X, G);
            return V != null && S.test(V) && u(X);
          };
        },
        exists: function(u, e, n) {
          var G = e.name, y = n.adapter;
          return function(I) {
            return y.hasAttrib(I, G) && u(I);
          };
        },
        start: function(u, e, n) {
          var G = e.name, y = e.value, a = y.length, I = n.adapter;
          return a === 0 ? s : e.ignoreCase ? (y = y.toLowerCase(), function(S) {
            var p = I.getAttributeValue(S, G);
            return p != null && p.substr(0, a).toLowerCase() === y && u(S);
          }) : function(S) {
            var p = I.getAttributeValue(S, G);
            return p != null && p.substr(0, a) === y && u(S);
          };
        },
        end: function(u, e, n) {
          var G = e.name, y = e.value, a = -y.length, I = n.adapter;
          return a === 0 ? s : e.ignoreCase ? (y = y.toLowerCase(), function(S) {
            var p = I.getAttributeValue(S, G);
            return p != null && p.substr(a).toLowerCase() === y && u(S);
          }) : function(S) {
            var p = I.getAttributeValue(S, G);
            return p != null && p.substr(a) === y && u(S);
          };
        },
        any: function(u, e, n) {
          var G = e.name, y = e.value, a = n.adapter;
          if (y === "")
            return s;
          if (e.ignoreCase) {
            var I = new RegExp(y.replace(c, "\\$&"), "i");
            return function(S) {
              var p = a.getAttributeValue(S, G);
              return p != null && I.test(p) && u(S);
            };
          }
          return function(S) {
            var p = a.getAttributeValue(S, G);
            return p != null && p.indexOf(y) >= 0 && u(S);
          };
        },
        not: function(u, e, n) {
          var G = e.name, y = e.value, a = n.adapter;
          return y === "" ? function(h) {
            return !!a.getAttributeValue(h, G) && u(h);
          } : e.ignoreCase ? (y = y.toLowerCase(), function(h) {
            var S = a.getAttributeValue(h, G);
            return S != null && S.toLowerCase() !== y && u(h);
          }) : function(h) {
            return a.getAttributeValue(h, G) !== y && u(h);
          };
        }
      };
      Z.exports = {
        compile: function(u, e, n) {
          if (n && n.strict && (e.ignoreCase || e.action === "not"))
            throw new Error("Unsupported attribute selector");
          return W[e.action](u, e, n);
        },
        rules: W
      };
    },
    /* 282 */
    /***/
    function(Z, d, l) {
      var s = l(283), c = l(273), W = l(281), u = c.trueFunc, e = c.falseFunc, n = W.rules.equals;
      function G(V, i) {
        var b = { name: V, value: i };
        return function(m, R, x) {
          return n(m, b, x);
        };
      }
      function y(V, i) {
        return function(b) {
          return !!i.getParent(b) && V(b);
        };
      }
      var a = {
        contains: function(V, i, b) {
          var t = b.adapter;
          return function(R) {
            return V(R) && t.getText(R).indexOf(i) >= 0;
          };
        },
        icontains: function(V, i, b) {
          var t = i.toLowerCase(), m = b.adapter;
          return function(x) {
            return V(x) && m.getText(x).toLowerCase().indexOf(t) >= 0;
          };
        },
        //location specific methods
        "nth-child": function(V, i, b) {
          var t = s(i), m = b.adapter;
          return t === e ? t : t === u ? y(V, m) : function(x) {
            for (var C = m.getSiblings(x), T = 0, K = 0; T < C.length; T++)
              if (m.isTag(C[T])) {
                if (C[T] === x)
                  break;
                K++;
              }
            return t(K) && V(x);
          };
        },
        "nth-last-child": function(V, i, b) {
          var t = s(i), m = b.adapter;
          return t === e ? t : t === u ? y(V, m) : function(x) {
            for (var C = m.getSiblings(x), T = 0, K = C.length - 1; K >= 0; K--)
              if (m.isTag(C[K])) {
                if (C[K] === x)
                  break;
                T++;
              }
            return t(T) && V(x);
          };
        },
        "nth-of-type": function(V, i, b) {
          var t = s(i), m = b.adapter;
          return t === e ? t : t === u ? y(V, m) : function(x) {
            for (var C = m.getSiblings(x), T = 0, K = 0; K < C.length; K++)
              if (m.isTag(C[K])) {
                if (C[K] === x)
                  break;
                m.getName(C[K]) === m.getName(x) && T++;
              }
            return t(T) && V(x);
          };
        },
        "nth-last-of-type": function(V, i, b) {
          var t = s(i), m = b.adapter;
          return t === e ? t : t === u ? y(V, m) : function(x) {
            for (var C = m.getSiblings(x), T = 0, K = C.length - 1; K >= 0; K--)
              if (m.isTag(C[K])) {
                if (C[K] === x)
                  break;
                m.getName(C[K]) === m.getName(x) && T++;
              }
            return t(T) && V(x);
          };
        },
        //TODO determine the actual root element
        root: function(V, i, b) {
          var t = b.adapter;
          return function(m) {
            return !t.getParent(m) && V(m);
          };
        },
        scope: function(V, i, b, t) {
          var m = b.adapter;
          if (!t || t.length === 0)
            return a.root(V, i, b);
          function R(x, C) {
            return typeof m.equals == "function" ? m.equals(x, C) : x === C;
          }
          return t.length === 1 ? function(x) {
            return R(t[0], x) && V(x);
          } : function(x) {
            return t.indexOf(x) >= 0 && V(x);
          };
        },
        //jQuery extensions (others follow as pseudos)
        checkbox: G("type", "checkbox"),
        file: G("type", "file"),
        password: G("type", "password"),
        radio: G("type", "radio"),
        reset: G("type", "reset"),
        image: G("type", "image"),
        submit: G("type", "submit"),
        //dynamic state pseudos. These depend on optional Adapter methods.
        hover: function(V, i, b) {
          var t = b.adapter;
          return typeof t.isHovered == "function" ? function(R) {
            return V(R) && t.isHovered(R);
          } : e;
        },
        visited: function(V, i, b) {
          var t = b.adapter;
          return typeof t.isVisited == "function" ? function(R) {
            return V(R) && t.isVisited(R);
          } : e;
        },
        active: function(V, i, b) {
          var t = b.adapter;
          return typeof t.isActive == "function" ? function(R) {
            return V(R) && t.isActive(R);
          } : e;
        }
      };
      function I(V, i) {
        for (var b = 0; V && b < V.length; b++)
          if (i.isTag(V[b]))
            return V[b];
      }
      var h = {
        empty: function(V, i) {
          return !i.getChildren(V).some(function(b) {
            return i.isTag(b) || b.type === "text";
          });
        },
        "first-child": function(V, i) {
          return I(i.getSiblings(V), i) === V;
        },
        "last-child": function(V, i) {
          for (var b = i.getSiblings(V), t = b.length - 1; t >= 0; t--) {
            if (b[t] === V)
              return !0;
            if (i.isTag(b[t]))
              break;
          }
          return !1;
        },
        "first-of-type": function(V, i) {
          for (var b = i.getSiblings(V), t = 0; t < b.length; t++)
            if (i.isTag(b[t])) {
              if (b[t] === V)
                return !0;
              if (i.getName(b[t]) === i.getName(V))
                break;
            }
          return !1;
        },
        "last-of-type": function(V, i) {
          for (var b = i.getSiblings(V), t = b.length - 1; t >= 0; t--)
            if (i.isTag(b[t])) {
              if (b[t] === V)
                return !0;
              if (i.getName(b[t]) === i.getName(V))
                break;
            }
          return !1;
        },
        "only-of-type": function(V, i) {
          for (var b = i.getSiblings(V), t = 0, m = b.length; t < m; t++)
            if (i.isTag(b[t])) {
              if (b[t] === V)
                continue;
              if (i.getName(b[t]) === i.getName(V))
                return !1;
            }
          return !0;
        },
        "only-child": function(V, i) {
          for (var b = i.getSiblings(V), t = 0; t < b.length; t++)
            if (i.isTag(b[t]) && b[t] !== V)
              return !1;
          return !0;
        },
        //:matches(a, area, link)[href]
        link: function(V, i) {
          return i.hasAttrib(V, "href");
        },
        //TODO: :any-link once the name is finalized (as an alias of :link)
        //forms
        //to consider: :target
        //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
        selected: function(V, i) {
          if (i.hasAttrib(V, "selected"))
            return !0;
          if (i.getName(V) !== "option")
            return !1;
          var b = i.getParent(V);
          if (!b || i.getName(b) !== "select" || i.hasAttrib(b, "multiple"))
            return !1;
          for (var t = i.getChildren(b), m = !1, R = 0; R < t.length; R++)
            if (i.isTag(t[R]))
              if (t[R] === V)
                m = !0;
              else if (m) {
                if (i.hasAttrib(t[R], "selected"))
                  return !1;
              } else
                return !1;
          return m;
        },
        //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        //:matches(
        //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
        //  optgroup[disabled] > option),
        // fieldset[disabled] * //TODO not child of first <legend>
        //)
        disabled: function(V, i) {
          return i.hasAttrib(V, "disabled");
        },
        enabled: function(V, i) {
          return !i.hasAttrib(V, "disabled");
        },
        //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
        checked: function(V, i) {
          return i.hasAttrib(V, "checked") || h.selected(V, i);
        },
        //:matches(input, select, textarea)[required]
        required: function(V, i) {
          return i.hasAttrib(V, "required");
        },
        //:matches(input, select, textarea):not([required])
        optional: function(V, i) {
          return !i.hasAttrib(V, "required");
        },
        //jQuery extensions
        //:not(:empty)
        parent: function(V, i) {
          return !h.empty(V, i);
        },
        //:matches(h1, h2, h3, h4, h5, h6)
        header: S(["h1", "h2", "h3", "h4", "h5", "h6"]),
        //:matches(button, input[type=button])
        button: function(V, i) {
          var b = i.getName(V);
          return b === "button" || b === "input" && i.getAttributeValue(V, "type") === "button";
        },
        //:matches(input, textarea, select, button)
        input: S(["input", "textarea", "select", "button"]),
        //input:matches(:not([type!='']), [type='text' i])
        text: function(V, i) {
          var b;
          return i.getName(V) === "input" && (!(b = i.getAttributeValue(V, "type")) || b.toLowerCase() === "text");
        }
      };
      function S(V) {
        if (typeof Set < "u") {
          var i = new Set(V);
          return function(b, t) {
            return i.has(t.getName(b));
          };
        }
        return function(b, t) {
          return V.indexOf(t.getName(b)) >= 0;
        };
      }
      function p(V, i, b) {
        if (b === null) {
          if (V.length > 2 && i !== "scope")
            throw new Error("pseudo-selector :" + i + " requires an argument");
        } else if (V.length === 2)
          throw new Error("pseudo-selector :" + i + " doesn't have any arguments");
      }
      var X = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
      Z.exports = {
        compile: function(V, i, b, t) {
          var m = i.name, R = i.data, x = b.adapter;
          if (b && b.strict && !X.test(m))
            throw new Error(":" + m + " isn't part of CSS3");
          if (typeof a[m] == "function")
            return a[m](V, R, b, t);
          if (typeof h[m] == "function") {
            var C = h[m];
            return p(C, m, R), C === e ? C : V === u ? function(K) {
              return C(K, x, R);
            } : function(K) {
              return C(K, x, R) && V(K);
            };
          } else
            throw new Error("unmatched pseudo-class :" + m);
        },
        filters: a,
        pseudos: h
      };
    },
    /* 283 */
    /***/
    function(Z, d, l) {
      var s = l(284), c = l(285);
      Z.exports = function(u) {
        return c(s(u));
      }, Z.exports.parse = s, Z.exports.compile = c;
    },
    /* 284 */
    /***/
    function(Z, d) {
      Z.exports = s;
      var l = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
      function s(c) {
        if (c = c.trim().toLowerCase(), c === "even")
          return [2, 0];
        if (c === "odd")
          return [2, 1];
        var W = c.match(l);
        if (!W)
          throw new SyntaxError("n-th rule couldn't be parsed ('" + c + "')");
        var u;
        return W[1] ? (u = parseInt(W[1], 10), isNaN(u) && (W[1].charAt(0) === "-" ? u = -1 : u = 1)) : u = 0, [
          u,
          W[3] ? parseInt((W[2] || "") + W[3], 10) : 0
        ];
      }
    },
    /* 285 */
    /***/
    function(Z, d, l) {
      Z.exports = u;
      var s = l(273), c = s.trueFunc, W = s.falseFunc;
      function u(e) {
        var n = e[0], G = e[1] - 1;
        if (G < 0 && n <= 0)
          return W;
        if (n === -1)
          return function(a) {
            return a <= G;
          };
        if (n === 0)
          return function(a) {
            return a === G;
          };
        if (n === 1)
          return G < 0 ? c : function(a) {
            return a >= G;
          };
        var y = G % n;
        return y < 0 && (y += n), n > 1 ? function(a) {
          return a >= G && a % n === y;
        } : (n *= -1, function(a) {
          return a <= G && a % n === y;
        });
      }
    },
    /* 286 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return R;
      });
      var s = l(12), c = l(74), W = l(1), u = l(68), e = l(250), n = l(213), G = l(218);
      l(1).glMatrix.setMatrixArrayType(Array);
      function y(x, C) {
        if (x == null)
          return {};
        var T = a(x, C), K, J;
        if (Object.getOwnPropertySymbols) {
          var F = Object.getOwnPropertySymbols(x);
          for (J = 0; J < F.length; J++)
            K = F[J], !(C.indexOf(K) >= 0) && Object.prototype.propertyIsEnumerable.call(x, K) && (T[K] = x[K]);
        }
        return T;
      }
      function a(x, C) {
        if (x == null)
          return {};
        var T = {}, K = Object.keys(x), J, F;
        for (F = 0; F < K.length; F++)
          J = K[F], !(C.indexOf(J) >= 0) && (T[J] = x[J]);
        return T;
      }
      const I = {
        antialias: !0,
        autoRender: !0,
        alpha: !0
        // for wx-miniprogram
      }, h = Symbol("autoRender"), S = Symbol("renderer"), p = Symbol("timeline"), X = Symbol("prepareRender"), V = Symbol("tickRender"), i = Symbol("pass"), b = Symbol("fbo"), t = Symbol("tickers"), m = Symbol("layerTransformInvert");
      class R extends e.default {
        constructor(C = {}) {
          if (super(), !C.canvas) {
            const {
              width: F,
              height: r
            } = this.getResolution(), Y = s.ENV.createCanvas(F, r, {
              offscreen: !!C.offscreen,
              id: C.id,
              extra: C.extra
            });
            Y.style && (Y.style.position = "absolute"), Y.dataset && (Y.dataset.layerId = C.id), Y.contextType && (C.contextType = Y.contextType), C.canvas = Y;
          }
          const T = C.canvas, K = Object.assign({}, I, C);
          this[h] = K.autoRender, delete C.autoRender;
          const J = K.Renderer || s.Renderer;
          this[S] = new J(T, K), this.options = C, this.id = C.id, this[i] = [], this.setResolution(T), this.canvas = T, this[p] = new c.Timeline(), this.__mouseCapturedTarget = null, this[m] = null;
        }
        get autoRender() {
          return this[h];
        }
        get displayRatio() {
          return this.parent && this.parent.options ? this.parent.options.displayRatio : 1;
        }
        get height() {
          const {
            height: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get gl() {
          return this.renderer.glRenderer ? this.renderer.glRenderer.gl : null;
        }
        /* override */
        get layer() {
          return this;
        }
        get offscreen() {
          return !!this.options.offscreen || this.canvas._offscreen;
        }
        get pass() {
          return this[i];
        }
        get prepareRender() {
          return this[X] ? this[X] : Promise.resolve();
        }
        /* override */
        get renderer() {
          return this[S];
        }
        get renderOffset() {
          if (this.parent && this.parent.options) {
            const {
              left: C,
              top: T
            } = this.parent.options;
            return [C, T];
          }
          return [this.options.left | 0, this.options.top | 0];
        }
        get timeline() {
          return this[p];
        }
        get width() {
          const {
            width: C
          } = this.getResolution();
          return C / this.displayRatio;
        }
        get localMatrix() {
          const {
            x: C,
            y: T
          } = this.attributes;
          return [1, 0, 0, 1, C, T];
        }
        get layerTransformInvert() {
          if (this[m])
            return this[m];
          const C = this.transformMatrix;
          return C[0] === 1 && C[1] === 0 && C[2] === 0 && C[3] === 1 && C[4] === 0 && C[5] === 0 ? null : (this[m] = W.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), C), this[m]);
        }
        forceContextLoss() {
          const C = this.renderer.glRenderer;
          if (C) {
            const T = C.getExtension("WEBGL_lose_context");
            if (T)
              return T.loseContext(), !0;
          }
          return !1;
        }
        // isPointCollision(x, y) {
        //   return true;
        // }
        addPass({
          vertex: C,
          fragment: T,
          options: K,
          uniforms: J
        } = {}) {
          if (this.renderer.glRenderer) {
            const {
              width: F,
              height: r
            } = this.getResolution(), Y = this.renderer.createPassProgram({
              vertex: C,
              fragment: T,
              options: K
            }), H = new s.Figure2D();
            H.rect(0, 0, F / this.displayRatio, r / this.displayRatio);
            const Q = new s.Mesh2D(H);
            return Q.setUniforms(J), Q.setProgram(Y), this[i].push(Q), this.forceUpdate(), Q;
          }
          return null;
        }
        // delete unused texture to release memory.
        deleteTexture(C) {
          return Object(G.deleteTexture)(C, this.renderer);
        }
        /* override */
        dispatchPointerEvent(C) {
          const T = C.type;
          if (T === "mousedown" || T === "mouseup" || T === "mousemove") {
            const Y = this.__mouseCapturedTarget;
            if (Y) {
              if (Y.layer === this)
                return Y.dispatchEvent(C), !0;
              this.__mouseCapturedTarget = null;
            }
          }
          let K, J;
          const F = this.layerTransformInvert;
          if (F) {
            K = C.x, J = C.y;
            const Y = F, H = Y[0] * K + Y[2] * J + Y[4], Q = Y[1] * K + Y[3] * J + Y[5];
            delete C.x, delete C.y, delete C.layerX, delete C.layerY, Object.defineProperties(C, {
              layerX: {
                value: H,
                configurable: !0
              },
              layerY: {
                value: Q,
                configurable: !0
              },
              x: {
                value: H,
                configurable: !0
              },
              y: {
                value: Q,
                configurable: !0
              }
            });
          }
          const r = super.dispatchPointerEvent(C);
          return F && Object.defineProperties(C, {
            layerX: {
              value: K,
              configurable: !0
            },
            layerY: {
              value: J,
              configurable: !0
            },
            x: {
              value: K,
              configurable: !0
            },
            y: {
              value: J,
              configurable: !0
            }
          }), r;
        }
        /* override */
        forceUpdate() {
          if (!this[X])
            if (this.parent && this.parent.hasOffscreenCanvas) {
              this.parent.forceUpdate();
              let C = null;
              const T = new Promise((K) => {
                C = K;
              });
              T._resolve = C, this[X] = T;
            } else {
              let C = null, T = null;
              const K = new Promise((J) => {
                C = J, this[h] && (T = Object(u.requestAnimationFrame)(() => {
                  delete K._requestID, this.render();
                }));
              });
              K._resolve = C, K._requestID = T, this[X] = K;
            }
        }
        getFBO() {
          const C = this.renderer.glRenderer, {
            width: T,
            height: K
          } = this.getResolution();
          return C && (!this[b] || this[b].width !== T || this[b].height !== K) ? (this[b] = {
            width: T,
            height: K,
            target: C.createFBO(),
            buffer: C.createFBO(),
            swap() {
              [this.target, this.buffer] = [this.buffer, this.target];
            }
          }, this[b]) : this[b] ? this[b] : null;
        }
        updateGlobalTransform() {
          if (this.layerTransformInvert) {
            const C = this.renderer, T = C.__globalTransformMatrix || C.globalTransformMatrix;
            C.__globalTransformMatrix = T;
            const K = W.mat2d.fromValues(1, 0, 0, 1, 0, 0);
            C.setGlobalTransform(...W.mat2d.multiply(K, T, this.transformMatrix));
          }
        }
        /* override */
        onPropertyChange(C, T, K) {
          if (super.onPropertyChange(C, T, K), C === "zIndex" && (this.canvas.style.zIndex = T), C === "transform" || C === "translate" || C === "rotate" || C === "scale" || C === "skew") {
            const J = this[m];
            if (this[m] = null, this.updateGlobalTransform(), J && !this.layerTransformInvert) {
              const F = this.renderer, r = F.__globalTransformMatrix || F.globalTransformMatrix;
              F.setGlobalTransform(...r);
            }
          }
        }
        _prepareRenderFinished() {
          this[X] && (this[X]._requestID && Object(u.cancelAnimationFrame)(this[X]._requestID), this[X]._resolve(), delete this[X]);
        }
        render({
          clear: C = !0
        } = {}) {
          const T = this[i].length ? this.getFBO() : null;
          T && this.renderer.glRenderer.bindFBO(T.target), C && this[S].clear();
          const K = this.draw();
          if (K && K.length && (this.renderer.drawMeshes(K), this.canvas.draw && this.canvas.draw()), T) {
            const J = this.renderer.glRenderer, F = this[i].length, {
              width: r,
              height: Y
            } = this.getResolution(), H = [0, 0, r / this.displayRatio, Y / this.displayRatio];
            this[i].forEach((Q, w) => {
              Q.blend = !0, Q.setTexture(T.target.texture, {
                rect: H
              }), w === F - 1 ? J.bindFBO(null) : (T.swap(), J.bindFBO(T.target)), this[S].clear(), this.renderer.drawMeshes([Q]);
            });
          }
          this._prepareRenderFinished();
        }
        /* override */
        setResolution({
          width: C,
          height: T
        }) {
          const K = this.renderer, J = K.__globalTransformMatrix || K.globalTransformMatrix, F = J[4], r = J[5], Y = J[0], {
            width: H,
            height: Q
          } = this.getResolution();
          (H !== C || Q !== T) && (super.setResolution({
            width: C,
            height: T
          }), this.canvas && (this.canvas.width = C, this.canvas.height = T, K.updateResolution && K.updateResolution()), this.attributes.size = [C, T], this[i].length && this[i].forEach((k) => {
            const P = new s.Figure2D();
            P.rect(0, 0, C / this.displayRatio, T / this.displayRatio), k.contours = P.contours;
          }));
          const [w, O] = this.renderOffset, q = this.displayRatio;
          (F !== w || r !== O || Y !== q) && (K.setGlobalTransform(q, 0, 0, q, w, O), K.__globalTransformMatrix = null, this[m] = null, this.updateGlobalTransform(), this.forceUpdate());
        }
        /**
         * tick(handler, {originTime = 0, playbackRate = 1.0, duration = Infinity})
         * @param {*} handler
         * @param {*} options
         */
        tick(C = null, T = {}) {
          let {
            duration: K = 1 / 0
          } = T, J = y(T, ["duration"]);
          const F = this.timeline.fork(J), r = this;
          this[t] = this[t] || [], this[t].push({
            handler: C,
            duration: K
          });
          const Y = () => {
            let H = null, Q = null;
            const w = () => {
              const O = this[t].map(({
                handler: q,
                duration: k
              }) => {
                const P = Math.min(1, F.currentTime / k);
                return {
                  value: q ? q(F.currentTime, P) : null,
                  p: P
                };
              });
              r[V] || (r[V] = Promise.resolve().then(() => {
                r[h] && r.render(), delete r[V];
                for (let q = O.length - 1; q >= 0; q--) {
                  const {
                    value: k,
                    p: P
                  } = O[q];
                  (k === !1 || P >= 1) && this[t].splice(q, 1);
                }
                this[t].length > 0 && Y();
              }));
            };
            if (this[X] && this[X]._type !== "ticker" && (Object(u.cancelAnimationFrame)(this[X]._requestID), delete this[X]), !this[X]) {
              const O = new Promise((q) => {
                H = q, Q = Object(u.requestAnimationFrame)(w);
              });
              O._resolve = H, O._requestID = Q, O._type = "ticker", this[X] = O;
            }
          };
          Y();
        }
        toGlobalPos(C, T) {
          if (this.layerTransformInvert) {
            const H = this.transformMatrix;
            C = H[0] * C + H[2] * T + H[4], T = H[1] * C + H[3] * T + H[5];
          }
          const {
            width: K,
            height: J
          } = this.getResolution(), F = this.renderOffset, r = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * r[0] / K + F[0], T = T * r[1] / J + F[1];
          const Y = this.displayRatio;
          return C *= Y, T *= Y, [C, T];
        }
        toLocalPos(C, T) {
          const {
            width: K,
            height: J
          } = this.getResolution(), F = this.renderOffset, r = [this.canvas.clientWidth, this.canvas.clientHeight];
          C = C * K / r[0] - F[0], T = T * J / r[1] - F[1];
          const Y = this.displayRatio;
          C /= Y, T /= Y;
          const H = this.layerTransformInvert;
          return H && (C = H[0] * C + H[2] * T + H[4], T = H[1] * C + H[3] * T + H[5]), [C, T];
        }
      }
      n.default.registerNode(R, "layer");
    },
    /* 287 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return X;
      });
      var s = l(224), c = l(288), W = l(213), u = l(252), e = l(72);
      l(1).glMatrix.setMatrixArrayType(Array);
      function n(V, i) {
        if (V == null)
          return {};
        var b = G(V, i), t, m;
        if (Object.getOwnPropertySymbols) {
          var R = Object.getOwnPropertySymbols(V);
          for (m = 0; m < R.length; m++)
            t = R[m], !(i.indexOf(t) >= 0) && Object.prototype.propertyIsEnumerable.call(V, t) && (b[t] = V[t]);
        }
        return b;
      }
      function G(V, i) {
        if (V == null)
          return {};
        var b = {}, t = Object.keys(V), m, R;
        for (R = 0; R < t.length; R++)
          m = t[R], !(i.indexOf(m) >= 0) && (b[m] = V[m]);
        return b;
      }
      function y(V, i, b) {
        return i in V ? Object.defineProperty(V, i, { value: b, enumerable: !0, configurable: !0, writable: !0 }) : V[i] = b, V;
      }
      const a = "http://www.w3.org/2000/svg", I = Symbol.for("spritejs_setAttribute"), h = Symbol("root"), S = Symbol("task");
      function p(V, i = !0) {
        const b = V[h];
        if (b && b.children[0]) {
          const t = V.svg, m = V.layer ? V.layer.displayRatio : 1;
          if (!t.hasAttribute("data-original-width")) {
            let C = t.getAttribute("width");
            C = C ? Object(e.sizeToPixel)(C) : 300;
            let T = t.getAttribute("height");
            T = T ? Object(e.sizeToPixel)(T) : 150, t.hasAttribute("viewBox") || t.setAttribute("viewBox", `0 0 ${Math.round(C)} ${Math.round(T)}`), t.setAttribute("data-original-width", C), t.setAttribute("data-original-height", T);
          }
          let R = V.attributes.width || Number(t.getAttribute("data-original-width")), x = V.attributes.height || Number(t.getAttribute("data-original-height"));
          if (R *= m, x *= m, i && V.attributes.flexible) {
            const C = V.attributes.scale[0];
            if (R *= C, x *= C, t.setAttribute("width", R), t.setAttribute("height", x), R && x && V.textureImage) {
              const T = V.textureImage.width, K = V.textureImage.height, J = V.clientSize;
              V.attributes.textureRect = [0, 0, Math.round(J[0] * T / R), Math.round(J[1] * K / x)];
            }
          } else
            V[S] || (t.setAttribute("width", R), t.setAttribute("height", x), V[S] = Promise.resolve().then(() => {
              delete V[S];
              const C = b.innerHTML, T = new Blob([C], {
                type: "image/svg+xml"
              }), K = URL.createObjectURL(T), J = new Image();
              J.onload = function() {
                J.width && J.height ? (V.attributes[I]("texture", J), V.attributes.flexible && (V.attributes.textureRect = null)) : V.attributes[I]("texture", null);
              }, J.src = K;
            }));
        }
      }
      class X extends s.default {
        constructor(i = {}) {
          typeof i == "string" && (i = {
            svgText: i
          });
          let {
            svgText: b
          } = i, t = n(i, ["svgText"]);
          if (super(t), this[h] = document.createElement("div"), b) {
            this[h].innerHTML = b;
            const m = this[h].children[0];
            m ? m.setAttribute("xmlns", a) : (fetch(b).then((R) => R.text()).then((R) => {
              this[h].innerHTML = R, (!this.observer || this.attributes.flexible) && p(this);
            }), b = null);
          }
          if (!b) {
            const m = document.createElementNS(a, "svg");
            m.setAttribute("xmlns", a), this[h].appendChild(m);
          }
          if (typeof MutationObserver == "function") {
            const m = new MutationObserver((R) => {
              p(this, !1);
            });
            m.observe(this[h], {
              attributes: !0,
              subtree: !0,
              characterData: !0,
              childList: !0
            }), this.observer = m;
          }
        }
        get children() {
          return [this.svg];
        }
        get childNodes() {
          return [this.svg];
        }
        get svg() {
          return this[h] ? this[h].children[0] : null;
        }
        /* override */
        setResolution({
          width: i,
          height: b
        }) {
          super.setResolution({
            width: i,
            height: b
          }), p(this);
        }
        /* override */
        dispatchPointerEvent(i) {
          const b = super.dispatchPointerEvent(i);
          if (b && this.attributes.passEvents && typeof MouseEvent == "function") {
            const {
              x: t,
              y: m
            } = i;
            let [R, x] = this.getOffsetPosition(t, m);
            const C = i.originalEvent, T = this.attributes.anchor, K = this.clientSize;
            R = (R + T[0] * K[0]) / 2, x = (x + T[1] * K[1]) / 2;
            const J = i.type;
            if (J === C.type) {
              let F = null;
              if (C instanceof MouseEvent)
                F = new MouseEvent(J, {
                  screenX: R,
                  screenY: x,
                  clientX: R,
                  clientY: x,
                  bubbles: C.bubbles,
                  button: C.button,
                  buttons: C.buttons,
                  cancelBubble: C.cancelBubble,
                  cancelable: C.cancelable,
                  currentTarget: C.currentTarget,
                  fromElement: C.fromElement,
                  relatedTarget: C.relatedTarget,
                  returnValue: C.returnValue,
                  srcElement: C.srcElement,
                  target: C.target,
                  toElement: C.toElement,
                  // view: originalEvent.view,
                  which: C.witch
                });
              else if (C instanceof TouchEvent) {
                let r = null;
                const Y = C.changedTouches || [C];
                for (let H = 0; H < Y.length; H++) {
                  const Q = Y[H];
                  if (i.identifier === Q.identifier) {
                    r = Q;
                    break;
                  }
                }
                if (r) {
                  const H = new Touch({
                    identifier: r.identifier,
                    target: r.target,
                    clientX: R,
                    clientY: x,
                    screenX: R,
                    screenY: x,
                    pageX: R,
                    pageY: x,
                    radiusX: r.radiusX,
                    radiusY: r.radiusY,
                    rotationAngle: r.rotationAngle,
                    force: r.force
                  });
                  F = new TouchEvent(J, {
                    cancelable: C.cancelable,
                    bubbles: C.bubbles,
                    composed: C.composed,
                    touches: [H],
                    targetTouches: [H],
                    changedTouches: [H]
                  });
                }
              } else
                F = C;
              F && this.svg.dispatchEvent(F);
            }
          }
          return b;
        }
        getElementById(i) {
          return Object(u.querySelector)(`#${i}`, this);
        }
        getElementsByClassName(i) {
          return Object(u.querySelectorAll)(`.${i}`, this);
        }
        getElementsByName(i) {
          return Object(u.querySelectorAll)(`[name="${i}"]`, this);
        }
        getElementsByTagName(i) {
          return Object(u.querySelectorAll)(i, this);
        }
        querySelector(i) {
          return Object(u.querySelector)(i, this);
        }
        querySelectorAll(i) {
          return Object(u.querySelectorAll)(i, this);
        }
        /* override */
        onPropertyChange(i, b, t) {
          super.onPropertyChange(i, b, t), i === "flexible" && p(this), this.attributes.flexible && (i === "width" || i === "height" || i === "scale" || i === "transform") && p(this);
        }
      }
      y(X, "Attr", c.default), W.default.registerNode(X, "spritesvg");
    },
    /* 288 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return e;
      });
      var s = l(225);
      l(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol.for("spritejs_getAttribute"), W = Symbol.for("spritejs_setAttribute"), u = Symbol.for("spritejs_setAttributeDefault");
      class e extends s.default {
        constructor(G) {
          super(G), this[u]({
            passEvents: !1,
            flexible: !1
          });
        }
        // readonly
        get texture() {
          return this[c]("texture");
        }
        set texture(G) {
        }
        // eslint-disable-line no-empty-function
        get passEvents() {
          return this[c]("passEvents");
        }
        set passEvents(G) {
          return this[W]("passEvents", G);
        }
        get flexible() {
          return this[c]("flexible");
        }
        set flexible(G) {
          return this[W]("flexible", G);
        }
      }
    },
    /* 289 */
    /***/
    function(Z, d, l) {
      l.r(d);
      var s = l(12);
      l(1).glMatrix.setMatrixArrayType(Array);
      function c(G, y) {
        var a = Object.keys(G);
        if (Object.getOwnPropertySymbols) {
          var I = Object.getOwnPropertySymbols(G);
          y && (I = I.filter(function(h) {
            return Object.getOwnPropertyDescriptor(G, h).enumerable;
          })), a.push.apply(a, I);
        }
        return a;
      }
      function W(G) {
        for (var y = 1; y < arguments.length; y++) {
          var a = arguments[y] != null ? arguments[y] : {};
          y % 2 ? c(Object(a), !0).forEach(function(I) {
            u(G, I, a[I]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(G, Object.getOwnPropertyDescriptors(a)) : c(Object(a)).forEach(function(I) {
            Object.defineProperty(G, I, Object.getOwnPropertyDescriptor(a, I));
          });
        }
        return G;
      }
      function u(G, y, a) {
        return y in G ? Object.defineProperty(G, y, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : G[y] = a, G;
      }
      const e = Symbol("inited");
      let n = null;
      typeof Worker == "function" && (n = class extends Worker {
        constructor(G) {
          if (G.worker === !0 && (G.worker = `./${G.id}.worker.js`), super(G.worker), this.options = G, !G.canvas) {
            const {
              width: y,
              height: a
            } = this.getResolution(), I = s.ENV.createCanvas(y, a, {
              offscreen: !1
            });
            I.style && (I.style.position = "absolute"), I.dataset && (I.dataset.layerId = G.id), G.canvas = I;
          }
          this.canvas = G.canvas;
        }
        get id() {
          return this.options.id;
        }
        setResolution({
          width: G,
          height: y
        }) {
          if (this[e])
            this.postMessage({
              type: "resolution_change",
              width: G,
              height: y
            });
          else {
            this.canvas.width = G, this.canvas.height = y;
            const a = this.options, I = a.canvas.transferControlToOffscreen(), h = W({}, a);
            delete h.container, h.canvas = I, this.postMessage({
              type: "create",
              options: h
            }, [I]), this[e] = !0;
          }
        }
        getResolution() {
          if (this.canvas) {
            const {
              width: G,
              height: y
            } = this.canvas;
            return {
              width: G,
              height: y
            };
          }
          return {
            width: 300,
            height: 150
          };
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        connect(G, y) {
          Object.defineProperty(this, "parent", {
            value: G,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: y,
            writable: !1,
            configurable: !0
          });
        }
        disconnect() {
          delete this.parent, delete this.zOrder;
        }
        dispatchPointerEvent(G) {
          this.postMessage({
            type: "event",
            event: {
              cancelBubble: G.cancelBubble,
              bubbles: G.bubbles,
              detail: G.detail,
              identifier: G.identifier,
              layerX: G.layerX,
              layerY: G.layerY,
              originalX: G.originalX,
              originalY: G.originalY,
              type: G.type,
              x: G.x,
              y: G.y
            }
          });
        }
      }), d.default = n;
    },
    /* 290 */
    /***/
    function(Z, d, l) {
      l.r(d), (function(s) {
        l.d(d, "default", function() {
          return R;
        });
        var c = l(12), W = l(68), u = l(70), e = l(286), n = l(289), G = l(250), y = l(291), a = l(214), I = l(218), h = l(213);
        l(1).glMatrix.setMatrixArrayType(Array);
        const S = Symbol("enteredTargets");
        function p(x) {
          return x.id = x.id || `_layer${Math.random().toString(36).slice(2, 12)}`, x.dataset || (x.dataset = {}), x.dataset.layerId = x.id, x.connect = (C, T) => {
            x.parent = C, Object.defineProperty(x, "zOrder", {
              value: T,
              writable: !1,
              configurable: !0
            });
          }, x.disconnect = (C) => {
            delete x.zOrder;
          }, x.canvas = x, x.getResolution = () => ({
            width: 0,
            height: 0
          }), x.setResolution = () => !1, x.options = {
            handleEvent: !1
          }, x;
        }
        function X(x, C) {
          const T = x.children;
          let K = null;
          for (let J = 0; J < T.length; J++) {
            const F = T[J];
            if ((C === F || K != null) && (K = F), K && K !== C && !K.offscreen)
              return K.canvas;
          }
          return null;
        }
        function V(x, C) {
          const [T, K] = x.renderOffset, {
            width: J,
            height: F
          } = x.getResolution(), r = x.displayRatio;
          x.renderer.drawImage(C.canvas, -T / r, -K / r, J / r, F / r);
        }
        const i = {};
        function b(x) {
          const C = ["mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "touchstart", "touchend", "touchmove", "touchcancel", "click", "dblclick", "longpress", "tap", "contextmenu"], T = x.container;
          T.addEventListener("mouseleave", (K) => {
            const J = x[S];
            if (J.size) {
              const F = new a.default("mouseleave");
              F.setOriginalEvent(K), [...J].forEach((r) => {
                r.dispatchEvent(F);
              }), x[S].clear();
            }
          }, {
            passive: !0
          }), C.forEach((K) => {
            T.addEventListener(K, (J) => {
              const {
                left: F,
                top: r,
                displayRatio: Y
              } = x.options, H = x.orderedChildren;
              Object(y.default)(J, {
                offsetLeft: F,
                offsetTop: r,
                displayRatio: Y
              }).forEach((w) => {
                const O = w.identifier;
                if (w.type === "touchmove" || w.type === "touchend") {
                  const k = i[O];
                  k && k.dispatchEvent(w), w.type === "touchend" && delete i[O];
                } else {
                  for (let k = H.length - 1; k >= 0; k--) {
                    const P = H[k];
                    if (P.options.handleEvent !== !1) {
                      if (P.dispatchPointerEvent(w) && w.target !== P)
                        break;
                      w.cancelBubble = !1;
                    }
                  }
                  if (w.target === H[0])
                    for (let k = H.length - 1; k >= 0; k--) {
                      const P = H[k];
                      if (P.options.handleEvent !== !1) {
                        w.target = P;
                        break;
                      }
                    }
                }
                const q = w.target;
                if (w.type === "touchstart" && (i[O] = w.target), w.type === "mousemove") {
                  const k = x[S];
                  let P;
                  if (q) {
                    const _ = q.ancestors || [];
                    P = /* @__PURE__ */ new Set([q, ..._]);
                  } else
                    P = /* @__PURE__ */ new Set();
                  const D = Object.entries(J);
                  if (!k.has(q) && q) {
                    const _ = new a.default("mouseenter");
                    _.setOriginalEvent(J), D.forEach(([$, el]) => {
                      _[$] = el;
                    }), k.add(q), q.dispatchEvent(_);
                    const bl = q.ancestors;
                    bl && bl.forEach(($) => {
                      $ instanceof u.default && !k.has($) && (k.add($), $.dispatchEvent(_));
                    });
                  }
                  const ll = new a.default("mouseleave");
                  ll.setOriginalEvent(J), D.forEach(([_, bl]) => {
                    ll[_] = bl;
                  }), [...k].forEach((_) => {
                    P.has(_) || (k.delete(_), _.dispatchEvent(ll));
                  });
                }
              });
            }, {
              passive: K !== "contextmenu"
            });
          });
        }
        function t(x, C) {
          if (C && C.style) {
            let {
              width: T,
              height: K,
              mode: J,
              container: F
            } = x;
            const {
              clientWidth: r,
              clientHeight: Y
            } = F;
            T = T || r, K = K || Y, J === "static" ? (C.style.width = `${T}px`, C.style.height = `${K}px`) : (C.style.top = "0", C.style.left = "0", C.style.width = `${r}px`, C.style.height = `${Y}px`, C.style.transform = "", C.style.webkitTransform = "");
          }
        }
        const m = Symbol("offscreenLayerCount");
        class R extends G.default {
          /**
            width
            height
            mode: 'static', 'scale', 'stickyWidth', 'stickyHeight', 'stickyTop', 'stickyBottom', 'stickyLeft', 'stickyRight'
           */
          constructor(C = {}) {
            if (super(), !C.container)
              if (typeof c.ENV.Container == "function")
                C.container = new c.ENV.Container(C.width || 300, C.height || 150);
              else
                throw new Error("No container specified.");
            if (this.container = C.container, this.container.style && (this.container.style.overflow || (this.container.style.overflow = "hidden"), this.container.style.position || (this.container.style.position = "relative")), this.options = C, C.displayRatio = C.displayRatio || 1, C.mode = C.mode || "scale", C.left = 0, C.top = 0, C.autoResize = C.autoResize !== !1, C.autoResize) {
              let T;
              if (typeof globalThis < "u" ? T = globalThis : T = typeof window < "u" ? window : s, T.addEventListener) {
                const K = this;
                T.addEventListener("resize", function J() {
                  typeof document < "u" && document.contains(K.container) ? K.resize() : T.removeEventListener("resize", J);
                });
              }
            }
            this[S] = /* @__PURE__ */ new Set(), this.setResolution(C), b(this), this[m] = 0;
          }
          get hasOffscreenCanvas() {
            return this[m] > 0;
          }
          set displayRatio(C) {
            this.options.displayRatio !== C && (this.options.displayRatio = C, this.resize());
          }
          get displayRatio() {
            return this.options.displayRatio;
          }
          set height(C) {
            this.options.height !== C && (this.options.height = C, this.resize());
          }
          get height() {
            return this.options.height;
          }
          set mode(C) {
            this.options.mode !== C && (this.options.mode = C, this.resize());
          }
          get mode() {
            return this.options.mode;
          }
          set width(C) {
            this.options.width !== C && (this.options.width = C, this.resize());
          }
          get width() {
            return this.options.width;
          }
          /* override */
          appendChild(C) {
            !(C instanceof e.default) && !(C instanceof n.default) && p(C);
            const T = super.appendChild(C), K = C.canvas;
            return C.offscreen ? this[m]++ : this.container.appendChild(K), t(this.options, K), C.setResolution(this.getResolution()), T;
          }
          /* override */
          forceUpdate() {
            this.hasOffscreenCanvas && !this._requestID && (this._requestID = Object(W.requestAnimationFrame)(() => {
              delete this._requestID, this.render();
            }));
          }
          /* override */
          insertBefore(C, T) {
            !(C instanceof e.default) && !(C instanceof n.default) && p(C);
            const K = super.insertBefore(C, T), J = C.canvas;
            if (!C.offscreen) {
              const F = X(this, C);
              this.container.insertBefore(J, F);
            }
            return t(this.options, J), C.setResolution(this.getResolution()), K;
          }
          layer(C = "default", T = {}) {
            T = Object.assign({}, this.options, T), T.id = C;
            const K = this.orderedChildren;
            for (let r = 0; r < K.length; r++)
              if (K[r].id === C)
                return K[r];
            const J = T.worker;
            let F;
            return J ? F = new n.default(T) : F = new e.default(T), this.appendChild(F), F;
          }
          async preload(...C) {
            const T = [], K = [], J = [];
            for (let F = 0; F < C.length; F++) {
              const r = C[F];
              let Y;
              if (typeof r == "string")
                Y = Object(I.loadTexture)(r);
              else if (Array.isArray(r))
                Y = Object(I.loadFrames)(...r);
              else {
                const {
                  id: H,
                  src: Q
                } = r;
                Y = Object(I.loadTexture)(Q, H);
              }
              Y instanceof Promise || (Y = Promise.resolve(Y)), K.push(Y.then((H) => {
                T.push(H), J[F] = H;
                const Q = new a.default({
                  type: "preload",
                  detail: {
                    current: H,
                    loaded: T,
                    resources: C
                  }
                });
                this.dispatchEvent(Q);
              }));
            }
            return await Promise.all(K), J;
          }
          /* override */
          removeChild(C) {
            const T = super.removeChild(C);
            if (T) {
              C._prepareRenderFinished && C._prepareRenderFinished();
              const K = C.canvas;
              K && K.remove && K.remove(), C.offscreen && this[m]--;
            }
            return T;
          }
          // for offscreen mode rendering
          render() {
            const C = this.orderedChildren;
            let T = null;
            const K = [];
            for (let J = 0; J < C.length; J++) {
              const F = C[J], r = K.length > 0;
              if (F instanceof e.default && !F.offscreen)
                if (!F.autoRender)
                  r && (console.warn("Some offscreen canvas will not be rendered."), K.length = 0);
                else if (T = F, r) {
                  F.renderer.clear();
                  for (let Y = 0; Y < K.length; Y++) {
                    const H = K[Y];
                    H.render(), V(F, H);
                  }
                  K.length = 0, F.render({
                    clear: !1
                  });
                } else
                  F.prepareRender && F.render();
              else
                F.offscreen ? T ? (F.prepareRender && F.render(), V(T, F)) : K.push(F) : F instanceof n.default && r && (console.warn("Some offscreen canvas will not be rendered."), K.length = 0);
            }
          }
          /* override */
          replaceChild(C, T) {
            const K = super.replaceChild(C, T);
            T.canvas.remove && T.canvas.remove(), T.offscreen && this[m]--;
            const J = C.canvas;
            if (!C.offscreen) {
              const F = X(this, C);
              this.container.insertBefore(J, F);
            }
            return t(this.options, J), C.setResolution(this.getResolution()), K;
          }
          resize() {
            const C = this.options;
            this.children.forEach((T) => {
              t(C, T.canvas);
            }), this.setResolution(C), this.dispatchEvent({
              type: "resize"
            });
          }
          /* override */
          setResolution({
            width: C,
            height: T
          } = {}) {
            const K = this.container, {
              clientWidth: J,
              clientHeight: F
            } = K;
            (C == null || T == null) && (C = C ?? J, T = T ?? F);
            const {
              mode: r,
              displayRatio: Y
            } = this.options;
            if (C *= Y, T *= Y, this.options.left = 0, this.options.top = 0, r === "stickyHeight" || r === "stickyLeft" || r === "stickyRight") {
              const H = C;
              C = J * T / F, r === "stickyHeight" && (this.options.left = 0.5 * (C - H)), r === "stickyRight" && (this.options.left = C - H);
            } else if (r === "stickyWidth" || r === "stickyTop" || r === "stickyBottom") {
              const H = T;
              T = F * C / J, r === "stickyWidth" && (this.options.top = 0.5 * (T - H)), r === "stickyBottom" && (this.options.top = T - H);
            }
            super.setResolution({
              width: C,
              height: T
            });
          }
          snapshot({
            offscreen: C = !1,
            layers: T
          } = {}) {
            const K = C ? "snapshotOffScreenCanvas" : "snapshotCanvas", {
              width: J,
              height: F
            } = this.getResolution();
            this[K] = this[K] || c.ENV.createCanvas(J, F, {
              offscreen: C
            });
            const r = this[K].getContext("2d");
            T = T || this.orderedChildren, this[K].width = J, this[K].height = F;
            for (let Y = 0; Y < T.length; Y++) {
              const H = T[Y];
              if (!H.options.ignoreSnapshot) {
                H.render && H.render();
                const Q = H.canvas;
                Q && Q !== H && r.drawImage(Q, 0, 0, J, F);
              }
            }
            return this[K];
          }
        }
        typeof document < "u" && (R.prototype.layer3d = function(x, C = {}) {
          const T = C.url || "https://unpkg.com/sprite-extend-3d/dist/sprite-extend-3d.min.js";
          return new Promise((K, J) => {
            const F = document.createElement("script");
            F.async = !1, F.src = T, F.onload = () => {
              try {
                K(this.layer3d(x, C));
              } catch (r) {
                J(r);
              }
            }, document.documentElement.appendChild(F);
          });
        }), h.default.registerNode(R, "scene");
      }).call(this, l(22));
    },
    /* 291 */
    /***/
    function(Z, d, l) {
      l.r(d), l.d(d, "default", function() {
        return c;
      });
      var s = l(214);
      l(1).glMatrix.setMatrixArrayType(Array);
      function c(W, {
        offsetTop: u = 0,
        offsetLeft: e = 0,
        displayRatio: n = 1
      } = {}) {
        let G, y;
        const a = [], {
          left: I,
          top: h,
          width: S,
          height: p
        } = W.target.getBoundingClientRect(), X = W.target.width, V = W.target.height, i = W.changedTouches || [W];
        for (let t = 0; t < i.length; t++) {
          const m = i[t], R = m.identifier, {
            clientX: x,
            clientY: C
          } = m;
          x != null && C != null && a.push({
            x: Math.round((x | 0) - I),
            y: Math.round((C | 0) - h),
            identifier: R
          });
        }
        a.length <= 0 && a.push({
          x: G,
          y
        });
        const b = [];
        return a.forEach((t) => {
          t.x != null && t.y != null && (G = (t.x * X / S - e) / n, y = (t.y * V / p - u) / n);
          const m = new s.default(W);
          Object.defineProperties(m, {
            layerX: {
              value: G,
              configurable: !0
            },
            layerY: {
              value: y,
              configurable: !0
            },
            originalX: {
              value: t.x
            },
            originalY: {
              value: t.y
            },
            x: {
              value: G,
              configurable: !0
            },
            y: {
              value: y,
              configurable: !0
            },
            identifier: {
              value: t.identifier
            }
          }), b.push(m);
        }), b;
      }
    }
    /******/
  ])
);
Nl.version;
Nl.Arc;
Nl.Block;
Nl.Cloud;
Nl.Color;
Nl.Ellipse;
Nl.Gradient;
const st = Nl.Group;
Nl.Label;
Nl.Layer;
Nl.LayerWorker;
Nl.Node;
Nl.Parallel;
Nl.Path;
Nl.Polyline;
const pi = Nl.Rect;
Nl.Regular;
Nl.Ring;
Nl.Scene;
Nl.Sprite;
Nl.SpriteSvg;
Nl.Star;
Nl.Triangle;
Nl.helpers;
Nl.createElement;
Nl.isSpriteNode;
Nl.registerNode;
Nl.requestAnimationFrame;
Nl.cancelAnimationFrame;
Nl.ENV;
const tt = {
  linear: (Z) => Z,
  easeInQuad: (Z) => Z * Z,
  easeOutQuad: (Z) => Z * (2 - Z),
  easeInOutQuad: (Z) => Z < 0.5 ? 2 * Z * Z : -1 + (4 - 2 * Z) * Z,
  easeInCubic: (Z) => Z * Z * Z,
  easeOutCubic: (Z) => --Z * Z * Z + 1,
  easeInOutCubic: (Z) => Z < 0.5 ? 4 * Z * Z * Z : (Z - 1) * (2 * Z - 2) * (2 * Z - 2) + 1,
  easeInQuart: (Z) => Z * Z * Z * Z,
  easeOutQuart: (Z) => 1 - --Z * Z * Z * Z,
  easeInOutQuart: (Z) => Z < 0.5 ? 8 * Z * Z * Z * Z : 1 - 8 * --Z * Z * Z * Z,
  easeInQuint: (Z) => Z * Z * Z * Z * Z,
  easeOutQuint: (Z) => 1 + --Z * Z * Z * Z * Z,
  easeInOutQuint: (Z) => Z < 0.5 ? 16 * Z * Z * Z * Z * Z : 1 + 16 * --Z * Z * Z * Z * Z,
  easeInSine: (Z) => 1 - Math.cos(Z * Math.PI / 2),
  easeOutSine: (Z) => Math.sin(Z * Math.PI / 2),
  easeInOutSine: (Z) => -(Math.cos(Math.PI * Z) - 1) / 2,
  easeInExpo: (Z) => Z <= 0 ? 0 : Math.pow(2, 10 * Z - 10),
  easeOutExpo: (Z) => Z >= 1 ? 1 : 1 - Math.pow(2, -10 * Z),
  easeInOutExpo: (Z) => Z <= 0 ? 0 : Z >= 1 ? 1 : Z < 0.5 ? Math.pow(2, 20 * Z - 10) / 2 : (2 - Math.pow(2, -20 * Z + 10)) / 2
};
class Wl {
  constructor(d = 0, l = 0, s = 1) {
    Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    });
  }
  get XY() {
    return [this.x, this.y];
  }
  setz(d) {
    return this.z = d, this;
  }
  setXY(d = this.x, l = this.y) {
    return this.x = d, this.y = l, this;
  }
  set(d = this.x, l = this.y, s = this.z) {
    return this.x = d, this.y = l, this.z = s, this;
  }
  setTo({ x: d = 0, y: l = 0, z: s = 1 }) {
    return this.x = d, this.y = l, this.z = s, this;
  }
  rot(d) {
    if (d === 0)
      return this;
    const { x: l, y: s } = this, c = Math.sin(d), W = Math.cos(d);
    return this.x = l * W - s * c, this.y = l * c + s * W, this;
  }
  rotWith(d, l) {
    if (l === 0)
      return this;
    const s = this.x - d.x, c = this.y - d.y, W = Math.sin(l), u = Math.cos(l);
    return this.x = d.x + (s * u - c * W), this.y = d.y + (s * W + c * u), this;
  }
  clone() {
    const { x: d, y: l, z: s } = this;
    return new Wl(d, l, s);
  }
  sub(d) {
    return this.x -= d.x, this.y -= d.y, this;
  }
  subXY(d, l) {
    return this.x -= d, this.y -= l, this;
  }
  subScalar(d) {
    return this.x -= d, this.y -= d, this;
  }
  add(d) {
    return this.x += d.x, this.y += d.y, this;
  }
  addXY(d, l) {
    return this.x += d, this.y += l, this;
  }
  addScalar(d) {
    return this.x += d, this.y += d, this;
  }
  clamp(d, l) {
    return this.x = Math.max(this.x, d), this.y = Math.max(this.y, d), l !== void 0 && (this.x = Math.min(this.x, l), this.y = Math.min(this.y, l)), this;
  }
  div(d) {
    return this.x /= d, this.y /= d, this;
  }
  divV(d) {
    return this.x /= d.x, this.y /= d.y, this;
  }
  mul(d) {
    return this.x *= d, this.y *= d, this;
  }
  mulV(d) {
    return this.x *= d.x, this.y *= d.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(d, l) {
    const s = Wl.Tan(d, this);
    return this.add(s.mul(l));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(d) {
    return this.x = this.y * d.z - this.z * d.y, this.y = this.z * d.x - this.x * d.z, this;
  }
  dpr(d) {
    return Wl.Dpr(this, d);
  }
  cpr(d) {
    return Wl.Cpr(this, d);
  }
  len2() {
    return Wl.Len2(this);
  }
  len() {
    return Wl.Len(this);
  }
  pry(d) {
    return Wl.Pry(this, d);
  }
  per() {
    const { x: d, y: l } = this;
    return this.x = l, this.y = -d, this;
  }
  uni() {
    return Wl.Uni(this);
  }
  tan(d) {
    return Wl.Tan(this, d);
  }
  dist(d) {
    return Wl.Dist(this, d);
  }
  distanceToLineSegment(d, l) {
    return Wl.DistanceToLineSegment(d, l, this);
  }
  slope(d) {
    return Wl.Slope(this, d);
  }
  snapToGrid(d) {
    return this.x = Math.round(this.x / d) * d, this.y = Math.round(this.y / d) * d, this;
  }
  angle(d) {
    return Wl.Angle(this, d);
  }
  toAngle() {
    return Wl.ToAngle(this);
  }
  lrp(d, l) {
    return this.x = this.x + (d.x - this.x) * l, this.y = this.y + (d.y - this.y) * l, this;
  }
  equals(d, l) {
    return Wl.Equals(this, d, l);
  }
  equalsXY(d, l) {
    return Wl.EqualsXY(this, d, l);
  }
  norm() {
    const d = this.len();
    return this.x = d === 0 ? 0 : this.x / d, this.y = d === 0 ? 0 : this.y / d, this;
  }
  toFixed() {
    return Wl.ToFixed(this);
  }
  toString() {
    return Wl.ToString(Wl.ToFixed(this));
  }
  toJson() {
    return Wl.ToJson(this);
  }
  toArray() {
    return Wl.ToArray(this);
  }
  static Add(d, l) {
    return new Wl(d.x + l.x, d.y + l.y);
  }
  static AddXY(d, l, s) {
    return new Wl(d.x + l, d.y + s);
  }
  static Sub(d, l) {
    return new Wl(d.x - l.x, d.y - l.y);
  }
  static SubXY(d, l, s) {
    return new Wl(d.x - l, d.y - s);
  }
  static AddScalar(d, l) {
    return new Wl(d.x + l, d.y + l);
  }
  static SubScalar(d, l) {
    return new Wl(d.x - l, d.y - l);
  }
  static Div(d, l) {
    return new Wl(d.x / l, d.y / l);
  }
  static Mul(d, l) {
    return new Wl(d.x * l, d.y * l);
  }
  static DivV(d, l) {
    return new Wl(d.x / l.x, d.y / l.y);
  }
  static MulV(d, l) {
    return new Wl(d.x * l.x, d.y * l.y);
  }
  static Neg(d) {
    return new Wl(-d.x, -d.y);
  }
  static Per(d) {
    return new Wl(d.y, -d.x);
  }
  static Dist2(d, l) {
    return Wl.Sub(d, l).len2();
  }
  static Abs(d) {
    return new Wl(Math.abs(d.x), Math.abs(d.y));
  }
  static Dist(d, l) {
    return Math.hypot(d.y - l.y, d.x - l.x);
  }
  static Dpr(d, l) {
    return d.x * l.x + d.y * l.y;
  }
  static Cross(d, l) {
    return new Wl(
      d.y * l.z - d.z * l.y,
      d.z * l.x - d.x * l.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  static Cpr(d, l) {
    return d.x * l.y - l.x * d.y;
  }
  static Len2(d) {
    return d.x * d.x + d.y * d.y;
  }
  static Len(d) {
    return Math.hypot(d.x, d.y);
  }
  static Pry(d, l) {
    return Wl.Dpr(d, l) / Wl.Len(l);
  }
  static Uni(d) {
    return Wl.Div(d, Wl.Len(d));
  }
  static Tan(d, l) {
    return Wl.Uni(Wl.Sub(d, l));
  }
  static Min(d, l) {
    return new Wl(Math.min(d.x, l.x), Math.min(d.y, l.y));
  }
  static Max(d, l) {
    return new Wl(Math.max(d.x, l.x), Math.max(d.y, l.y));
  }
  static From(d) {
    return new Wl().add(d);
  }
  static FromArray(d) {
    return new Wl(d[0], d[1]);
  }
  static Rot(d, l = 0) {
    const s = Math.sin(l), c = Math.cos(l);
    return new Wl(d.x * c - d.y * s, d.x * s + d.y * c);
  }
  static RotWith(d, l, s) {
    const c = d.x - l.x, W = d.y - l.y, u = Math.sin(s), e = Math.cos(s);
    return new Wl(l.x + (c * e - W * u), l.y + (c * u + W * e));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(d, l, s) {
    return Wl.Mul(l, Wl.Sub(s, d).pry(l)).add(d);
  }
  static NearestPointOnLineSegment(d, l, s, c = !0) {
    const W = Wl.Tan(l, d), u = Wl.Add(d, Wl.Mul(W, Wl.Sub(s, d).pry(W)));
    if (c) {
      if (u.x < Math.min(d.x, l.x))
        return Wl.Cast(d.x < l.x ? d : l);
      if (u.x > Math.max(d.x, l.x))
        return Wl.Cast(d.x > l.x ? d : l);
      if (u.y < Math.min(d.y, l.y))
        return Wl.Cast(d.y < l.y ? d : l);
      if (u.y > Math.max(d.y, l.y))
        return Wl.Cast(d.y > l.y ? d : l);
    }
    return u;
  }
  static DistanceToLineThroughPoint(d, l, s) {
    return Wl.Dist(s, Wl.NearestPointOnLineThroughPoint(d, l, s));
  }
  static DistanceToLineSegment(d, l, s, c = !0) {
    return Wl.Dist(s, Wl.NearestPointOnLineSegment(d, l, s, c));
  }
  static Snap(d, l = 1) {
    return new Wl(Math.round(d.x / l) * l, Math.round(d.y / l) * l);
  }
  static Cast(d) {
    return d instanceof Wl ? d : Wl.From(d);
  }
  static Slope(d, l) {
    return d.x === l.y ? NaN : (d.y - l.y) / (d.x - l.x);
  }
  static Angle(d, l) {
    return Math.atan2(l.y - d.y, l.x - d.x);
  }
  static Lrp(d, l, s) {
    return Wl.Sub(l, d).mul(s).add(d);
  }
  static Med(d, l) {
    return new Wl((d.x + l.x) / 2, (d.y + l.y) / 2);
  }
  static Equals(d, l, s = 1e-4) {
    return Math.abs(d.x - l.x) < s && Math.abs(d.y - l.y) < s;
  }
  static EqualsXY(d, l, s) {
    return d.x === l && d.y === s;
  }
  static EqualsXYZ(d, l, s = 1e-4) {
    return Wl.Equals(d, l, s) && Math.abs((d.z || 0) - (l.z || 0)) < s;
  }
  static Clockwise(d, l, s) {
    return (s.x - d.x) * (l.y - d.y) - (l.x - d.x) * (s.y - d.y) < 0;
  }
  static Rescale(d, l) {
    const s = Wl.Len(d);
    return new Wl(l * d.x / s, l * d.y / s);
  }
  static ScaleWithOrigin(d, l, s) {
    return Wl.Sub(d, s).mul(l).add(s);
  }
  static ScaleWOrigin(d, l, s) {
    return Wl.Sub(d, s).mulV(l).add(s);
  }
  static ToFixed(d, l = 2) {
    return new Wl(+d.x.toFixed(l), +d.y.toFixed(l), +d.z.toFixed(l));
  }
  static Nudge(d, l, s) {
    return Wl.Add(d, Wl.Tan(l, d).mul(s));
  }
  static ToString(d) {
    return `${d.x}, ${d.y}`;
  }
  static ToAngle(d) {
    let l = Math.atan2(d.y, d.x);
    return l < 0 && (l += Math.PI * 2), l;
  }
  static FromAngle(d, l = 1) {
    return new Wl(Math.cos(d) * l, Math.sin(d) * l);
  }
  static ToArray(d) {
    return [d.x, d.y, d.z];
  }
  static ToJson(d) {
    const { x: l, y: s, z: c } = d;
    return { x: l, y: s, z: c };
  }
  static Average(d) {
    const l = d.length, s = new Wl(0, 0);
    for (let c = 0; c < l; c++)
      s.add(d[c]);
    return s.div(l);
  }
  static Clamp(d, l, s) {
    return s === void 0 ? new Wl(Math.min(Math.max(d.x, l)), Math.min(Math.max(d.y, l))) : new Wl(Math.min(Math.max(d.x, l), s), Math.min(Math.max(d.y, l), s));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(d, l, s = 6) {
    const c = [];
    for (let W = 0; W < s; W++) {
      const u = tt.easeInQuad(W / (s - 1)), e = Wl.Lrp(d, l, u);
      e.z = Math.min(1, 0.5 + Math.abs(0.5 - bt(u)) * 0.65), c.push(e);
    }
    return c;
  }
  static SnapToGrid(d, l = 8) {
    return new Wl(Math.round(d.x / l) * l, Math.round(d.y / l) * l);
  }
}
const bt = (Z) => Z < 0.5 ? 2 * Z * Z : -1 + (4 - 2 * Z) * Z;
class zl extends Wl {
  constructor(d = 0, l = 0, s = 0, c = { x: 0, y: 0 }, W = 0, u = 0) {
    super(d, l, s), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: d
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: l
    }), Object.defineProperty(this, "z", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "v", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: c
    }), Object.defineProperty(this, "t", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: W
    }), Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: u
    });
  }
  get timestamp() {
    return this.t;
  }
  get pressure() {
    return this.z;
  }
  get angleNum() {
    return this.a;
  }
  get XY() {
    return [this.x, this.y];
  }
  setA(d) {
    this.a = d;
  }
  setT(d) {
    this.t = d;
  }
  setv(d) {
    return this.v = { x: d.x, y: d.y }, this;
  }
  set(d = this.x, l = this.y, s = this.z, c = this.v, W = this.t, u = this.a) {
    return this.x = d, this.y = l, this.z = s, this.v = c, this.t = W, this.a = u, this;
  }
  clone() {
    const { x: d, y: l, z: s, v: c, t: W, a: u } = this, e = { x: c.x, y: c.y };
    return new zl(d, l, s, e, W, u);
  }
  distance(d) {
    return zl.GetDistance(this, d);
  }
  isNear(d, l) {
    return zl.IsNear(this, d, l);
  }
  getAngleByPoints(d, l) {
    return zl.GetAngleByPoints(d, this, l);
  }
  static Sub(d, l) {
    return new zl(d.x - l.x, d.y - l.y);
  }
  static Add(d, l) {
    return new zl(d.x + l.x, d.y + l.y);
  }
  static GetDistance(d, l) {
    return zl.Len(d.clone().sub(l));
  }
  static GetAngleByPoints(d, l, s) {
    const c = l.x - d.x, W = s.x - l.x, u = l.y - d.y, e = s.y - l.y;
    let n = 0;
    const G = Math.sqrt(c * c + u * u), y = Math.sqrt(W * W + e * e);
    if (G && y) {
      const a = c * W + u * e;
      n = Math.acos(a / (G * y)), n = n / Math.PI * 180;
      let I = c * e - u * W;
      I = I > 0 ? 1 : -1, n = 180 + I * n;
    }
    return n;
  }
  static IsNear(d, l, s) {
    return zl.Len(d.clone().sub(l)) < s;
  }
  static RotWith(d, l, s, c = 2) {
    const W = d.x - l.x, u = d.y - l.y, e = Math.sin(s), n = Math.cos(s), G = Math.pow(10, c), y = Math.floor((l.x + (W * n - u * e)) * G) / G, a = Math.floor((l.y + (W * e + u * n)) * G) / G;
    return new zl(y, a);
  }
  /**
   * 根据圆心和半径，获取圆上的等份点
   * @param o 圆心
   * @param radius 半径
   * @param average 均分数
   * @returns
   */
  static GetDotStroke(d, l, s = 16) {
    const c = new Wl(1, 1), W = Math.PI + 1e-3, u = zl.Add(d, zl.Sub(d, c).uni().per().mul(-l)), e = [];
    for (let n = 1 / s, G = n; G <= 1; G += n)
      e.push(zl.RotWith(u, d, W * 2 * G));
    return e;
  }
  /**
   * 根据圆心和园上的起始点，获取半圆上的等份点
   * @param o 圆心
   * @param p 圆弧起始点
   * @param radian 1，逆时针180度 -1，顺时针
   * @param average 均分数
   * @returns
   */
  static GetSemicircleStroke(d, l, s = -1, c = 8) {
    const W = s * (Math.PI + 1e-3), u = [];
    for (let e = 1 / c, n = e; n <= 1; n += e)
      u.push(zl.RotWith(l, d, W * n));
    return u;
  }
}
function El(Z, d) {
  if (Z && d) {
    const l = Math.min(Z == null ? void 0 : Z.x, d.x), s = Math.min(Z == null ? void 0 : Z.y, d.y), c = Math.max(Z.x + Z.w, d.x + d.w), W = Math.max(Z.y + Z.h, d.y + d.h), u = c - l, e = W - s;
    return { x: l, y: s, w: u, h: e };
  }
  return d || Z;
}
function ct(Z, d = 0) {
  const l = { x: 0, y: 0, w: 0, h: 0 };
  let s = 1 / 0, c = 1 / 0, W = -1 / 0, u = -1 / 0;
  return Z.forEach((e) => {
    const [n, G] = e.XY;
    s = Math.min(s, n - d), c = Math.min(c, G - d), W = Math.max(W, n + d), u = Math.max(u, G + d);
  }), l.x = s, l.y = c, l.w = W - s, l.h = u - c, l;
}
function Zt(Z, d) {
  return !(Z.x + Z.w < d.x || Z.x > d.x + d.w || Z.y + Z.h < d.y || Z.y > d.y + d.h);
}
function mt(Z, d) {
  return Z.length === d.length && Z.sort().toString() === d.sort().toString();
}
function Li(Z, d) {
  let l;
  return d == null || d.getElementsByName(Z).forEach((s) => {
    if (s.tagName === "PATH") {
      const c = s == null ? void 0 : s.getBoundingClientRect();
      c && (l = El(l, {
        x: Math.floor(c.x),
        y: Math.floor(c.y),
        w: Math.round(c.width),
        h: Math.round(c.height)
      }));
    } else if (s.tagName === "GROUP") {
      const c = s.className.split(",");
      if (c.length === 3 && Number(c[2]) === _l.Stroke) {
        const W = s == null ? void 0 : s.getBoundingClientRect();
        W && (l = El(l, {
          x: Math.floor(W.x),
          y: Math.floor(W.y),
          w: Math.round(W.width),
          h: Math.round(W.height)
        }));
      } else
        s.children.forEach((W) => {
          if (W.tagName === "PATH") {
            const u = W == null ? void 0 : W.getBoundingClientRect();
            u && (l = El(l, {
              x: Math.floor(u.x),
              y: Math.floor(u.y),
              w: Math.round(u.width),
              h: Math.round(u.height)
            }));
          }
        });
    }
  }), l;
}
const ii = (Z, d) => new Promise(function(l) {
  window.requestIdleCallback ? requestIdleCallback(() => {
    l(1);
  }, { timeout: d }) : setTimeout(() => {
    l(2);
  }, d);
}).then(function() {
  Z();
}, () => {
  Z();
});
function as(Z) {
  return JSON.parse(fs(Z));
}
function os(Z) {
  return ws(JSON.stringify(Z));
}
const Ld = Object.keys;
function si(Z, d, l) {
  return "#" + ((Z << 16) + (d << 8) + l).toString(16).padStart(6, "0");
}
function Yd(Z, d = 1) {
  return "rgba(" + parseInt("0x" + Z.slice(1, 3)) + "," + parseInt("0x" + Z.slice(3, 5)) + "," + parseInt("0x" + Z.slice(5, 7)) + "," + d + ")";
}
function nt(Z) {
  const d = Z.split(","), l = parseInt(d[0].split("(")[1]), s = parseInt(d[1]), c = parseInt(d[2]), W = parseInt(d[3].split(")")[0]);
  return [si(l, s, c), W];
}
class Il extends it {
  updataOptService() {
  }
  constructor(d, l, s) {
    super(l, s), Object.defineProperty(this, "tmpPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "toolsType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Jl.Selector
    }), Object.defineProperty(this, "workOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "syncTimestamp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "curNodeMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "selectIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nodeColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nodeOpactiy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldSelectRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.workOptions = d, this.syncTimestamp = 0;
  }
  computNodeMap(d) {
    this.curNodeMap.clear(), d.forEach((l) => {
      var c;
      const s = this.fullLayer.getElementsByName(l.name)[0] || ((c = this.drawLayer) == null ? void 0 : c.getElementsByName(l.name)[0]);
      if (s) {
        const W = s.worldPosition;
        let u = s.getAttribute("strokeColor");
        const e = s.className.split(",");
        s.tagName === "GROUP" && (Number(e[2]) === _l.Stroke ? u = s.getAttribute("bgcolor") : u = s.children[0].getAttribute("strokeColor")), this.curNodeMap.set(l.name, {
          name: l.name,
          rect: l.rect,
          color: nt(u)[0],
          pos: W,
          rotate: s.getAttribute("rotate") || 0,
          scale: s.getAttribute("scale") || [1, 1],
          opactiy: s.getAttribute("opacity") || 1
        });
      }
    });
  }
  computSelector() {
    let d;
    const l = [], s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set(), W = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Map();
    if (this.tmpPoints.length && this.curNodeMap.size) {
      const e = ct(this.tmpPoints);
      this.curNodeMap.forEach((n, G) => {
        const y = {
          x: n.rect.x,
          y: n.rect.y,
          w: n.rect.w,
          h: n.rect.h
        }, a = {
          x: e.x,
          y: e.y,
          w: e.w,
          h: e.h
        };
        Zt(a, y) && (l.push(G), d = El(d, y), s.set(G, y), c.add(n.color), u.set(G, [...n.pos, n.rotate]), W.add(n.opactiy));
      });
    }
    return {
      selectIds: l,
      intersectRect: d,
      subRects: s,
      nodeColors: c,
      subPos: u,
      opactiys: W
    };
  }
  updateTempPoints(d) {
    const l = this.tmpPoints.length, s = d.length;
    if (s > 1) {
      const c = new zl(d[s - 2] * this.fullLayer.worldScaling[0] + this.fullLayer.worldPosition[0], d[s - 1] * this.fullLayer.worldScaling[0] + this.fullLayer.worldPosition[1]);
      l === 2 ? this.tmpPoints.splice(1, 1, c) : this.tmpPoints.push(c);
    }
  }
  draw(d) {
    var W, u, e;
    const { intersectRect: l, subRects: s, subPos: c } = d;
    (e = (u = (W = this.drawLayer) == null ? void 0 : W.parent) == null ? void 0 : u.getElementById(Il.selectorId)) == null || e.remove(), l && this.drawLayer && this.drawSelector({
      drawRect: l,
      subRects: s,
      subPos: c,
      selectorId: Il.selectorId,
      layer: this.drawLayer
    });
  }
  consume(d) {
    const { op: l, workState: s } = d.data;
    if (s === Ll.Start && d.nodeMaps && (this.computNodeMap(d.nodeMaps), this.oldRect = this.backToFullLayer(d.nodeMaps)), !(l != null && l.length) || !this.curNodeMap.size)
      return { type: hl.None };
    this.updateTempPoints(l);
    const c = this.computSelector();
    if (this.selectIds && mt(this.selectIds, c.selectIds))
      return { type: hl.None };
    this.selectIds = c.selectIds;
    const W = this.drawLayer && this.getSelectorRect(this.drawLayer, Il.selectorId, !0), u = c.intersectRect && {
      x: c.intersectRect.x - Il.SelectBorderPadding,
      y: c.intersectRect.y - Il.SelectBorderPadding,
      w: c.intersectRect.w + Il.SelectBorderPadding * 2,
      h: c.intersectRect.h + Il.SelectBorderPadding * 2
    } || void 0;
    return this.oldRect = El(W, u), this.draw(c), this.nodeColor = c.nodeColors.size === 1 ? c.nodeColors.values().next().value : void 0, this.nodeOpactiy = c.opactiys.size === 1 ? c.opactiys.values().next().value : 1, this.oldSelectRect = u, {
      type: hl.Select,
      dataType: Fl.Local,
      rect: this.oldRect,
      selectIds: c.selectIds,
      opt: this.workOptions,
      padding: Il.SelectBorderPadding,
      selectRect: u,
      nodeColor: this.nodeColor,
      nodeOpactiy: this.nodeOpactiy,
      willSyncService: !0
    };
  }
  consumeAll() {
    var d;
    return (d = this.selectIds) != null && d.length && this.sealToDrawLayer(this.selectIds), this.oldSelectRect ? {
      type: hl.Select,
      dataType: Fl.Local,
      rect: this.oldRect,
      selectIds: this.selectIds,
      opt: this.workOptions,
      padding: Il.SelectBorderPadding,
      selectRect: this.oldSelectRect,
      nodeColor: this.nodeColor,
      nodeOpactiy: this.nodeOpactiy,
      willSyncService: !1
    } : {
      type: hl.None
    };
  }
  consumeService() {
  }
  combineConsume() {
  }
  clearTmpPoints() {
    this.tmpPoints.length = 0;
  }
  clearSelectData() {
    this.selectIds = void 0, this.oldRect = void 0, this.oldSelectRect = void 0;
  }
  backToFullLayer(d = /* @__PURE__ */ new Map(), l) {
    var u, e;
    let s;
    const c = [], W = [];
    for (const n of ((u = this.drawLayer) == null ? void 0 : u.children) || [])
      if (!(l != null && l.length && !l.includes(n.id)) && n.id !== Il.selectorId) {
        const G = n.cloneNode(!0);
        if (G.tagName === "GROUP") {
          const a = n.className.split(",");
          a.length === 3 && Number(a[2]) === _l.Stroke && G.seal();
        }
        c.push(G), W.push(n);
        const y = ((e = d.get(n.name)) == null ? void 0 : e.rect) || Li(n.name, this.drawLayer);
        y && (s = El(s, y));
      }
    return W.forEach((n) => n.remove()), c.length && this.fullLayer.append(...c), s && (s.x -= Il.SelectBorderPadding, s.y -= Il.SelectBorderPadding, s.w += Il.SelectBorderPadding * 2, s.h += Il.SelectBorderPadding * 2), s;
  }
  sealToDrawLayer(d) {
    var c;
    const l = [], s = [];
    d.forEach((W) => {
      this.fullLayer.getElementsByName(W.toString()).forEach((u) => {
        const e = u.cloneNode(!0);
        if (e.tagName === "GROUP") {
          const n = u.className.split(",");
          n.length === 3 && Number(n[2]) === _l.Stroke && e.seal();
        }
        l.push(e), s.push(u);
      });
    }), s.forEach((W) => W.remove()), l && ((c = this.drawLayer) == null || c.append(...l));
  }
  updateSelectorSize(d, l, s) {
    const c = /* @__PURE__ */ new Map(), W = d.getAttribute("pos"), u = d.className.split(","), e = l - Il.SelectBorderPadding * 2, n = s - Il.SelectBorderPadding * 2, G = u.length === 2 && [e / Number(u[0]), n / Number(u[1])] || [1, 1];
    return d.setAttribute("size", [e, n]), d.children.forEach((y) => {
      if (y.id === Il.selectorBorderId)
        y.setAttribute("pos", [e / 2, n / 2]), y.setAttribute("width", e), y.setAttribute("height", n);
      else if (G) {
        const a = y.className.split(","), I = [Number(a[0]) * G[0], Number(a[1]) * G[1]], h = y.getAttribute("width"), S = y.getAttribute("height"), p = Number(a[2]) * G[0], X = Number(a[3]) * G[1];
        y.setAttribute("pos", I), y.setAttribute("width", p), y.setAttribute("height", X);
        const V = y.id.split("selector-")[1];
        if (V) {
          const i = [I[0] + W[0], I[1] + W[1]], b = [
            p / h,
            X / S
          ];
          c.set(V, [
            i[0],
            i[1],
            b[0],
            b[1]
          ]);
        }
      }
    }), c;
  }
  updateSelectorRect(d, l) {
    const { w: s, h: c, x: W, y: u } = l, e = s - Il.SelectBorderPadding * 2, n = c - Il.SelectBorderPadding * 2, G = W + Il.SelectBorderPadding, y = u + Il.SelectBorderPadding;
    d.setAttribute("size", [s, c]), d.setAttribute("pos", [G, y]), d.setAttribute("className", `${l.w},${l.h}`), d.children.forEach((a) => {
      if (a.setAttribute("pos", [e / 2, n / 2]), a.setAttribute("width", e), a.setAttribute("height", n), a.id === Il.selectorBorderId)
        a.setAttribute("className", `${l.w / 2},${l.h / 2},${l.w},${l.h}`);
      else {
        const I = a.className.split(","), h = I && Number(I[4]) || 0;
        a.setAttribute("className", `${e / 2},${n / 2},${l.w},${l.h},${h}`);
      }
    });
  }
  getSelectorRect(d, l, s) {
    var n;
    let c;
    const W = (n = d.parent) == null ? void 0 : n.getElementById(l), u = W == null ? void 0 : W.getElementById(Il.selectorBorderId), e = u == null ? void 0 : u.getBoundingClientRect();
    return e && (c = El(c, {
      x: Math.floor(e.x),
      y: Math.floor(e.y),
      w: Math.round(e.width),
      h: Math.round(e.height)
    })), c && s ? {
      x: c.x - Il.SelectBorderPadding,
      y: c.y - Il.SelectBorderPadding,
      w: c.w + Il.SelectBorderPadding * 2,
      h: c.h + Il.SelectBorderPadding * 2
    } : c;
  }
  updateSelector(d) {
    var n, G, y;
    const { updateSelectorOpt: l, selectIds: s } = d;
    let c;
    const W = /* @__PURE__ */ new Map();
    let u;
    const e = (G = (n = this.drawLayer) == null ? void 0 : n.parent) == null ? void 0 : G.getElementById(Il.selectorId);
    if (e) {
      let a;
      if (l.pos) {
        const I = [
          l.pos[0] * this.fullLayer.worldScaling[0] + this.fullLayer.worldPosition[0],
          l.pos[1] * this.fullLayer.worldScaling[1] + this.fullLayer.worldPosition[1]
        ], h = e.getAttribute("pos");
        a = [I[0] - h[0], I[1] - h[1]], e.setAttribute("pos", I);
      }
      if (l.selectorColor && ((y = e.getElementById(Il.selectorBorderId)) == null || y.setAttribute("strokeColor", l.selectorColor)), l.size && (u = this.updateSelectorSize(e, l.size.width, l.size.height)), l.angle)
        s == null || s.forEach((I) => {
          var h;
          (h = this.drawLayer) == null || h.getElementsByName(I).forEach((S) => {
            if (S) {
              const p = {
                useAnimation: !1
              };
              l.angle && (p.angle = l.angle, p.originPos = S.className.split(",").map((V) => Number(V)), S.setAttribute("rotate", p.angle)), W.set(S.name, p);
              const X = Li(S.name, this.drawLayer);
              c = El(c, X);
            }
          });
        }, this);
      else {
        s == null || s.forEach((S) => {
          var p;
          (p = this.drawLayer) == null || p.getElementsByName(S).forEach((X) => {
            if (X) {
              const V = {
                useAnimation: !1
              };
              if (l.pos && a) {
                const b = X.getAttribute("pos");
                V.pos = [a[0] / this.fullLayer.worldScaling[0] + b[0], a[1] / this.fullLayer.worldScaling[0] + b[1]], V.originPos = X.className.split(",").map((t) => Number(t)), X.setAttribute("pos", V.pos);
              }
              if (l.zIndexDistance || l.zIndex) {
                if (l.zIndexDistance) {
                  const b = X.getAttribute("zIndex");
                  V.zIndex = b + l.zIndexDistance;
                } else
                  V.zIndex = l.zIndex;
                X.setAttribute("zIndex", V.zIndex);
              }
              if (l.color) {
                V.color = l.color;
                const b = X.className.split(",");
                X.tagName === "GROUP" ? Number(b[2]) === _l.Stroke ? X.setAttribute("bgcolor", V.color) : X.children.forEach((t) => {
                  t.setAttribute("strokeColor", V.color);
                }) : X.tagName === "PATH" && (X.setAttribute("strokeColor", V.color), X.getAttribute("fillColor") && X.setAttribute("fillColor", V.color));
              }
              l.opacity && (V.opacity = l.opacity, X.setAttribute("opacity", V.opacity));
              const i = u == null ? void 0 : u.get(X.name);
              if (i) {
                const b = X.getAttribute("scale"), t = [
                  i[2] * b[0],
                  i[3] * b[1]
                ];
                V.originPos = X.className.split(",").map((m) => Number(m)), V.pos = [(i[0] - this.fullLayer.worldPosition[0]) / this.fullLayer.worldScaling[0], (i[1] - this.fullLayer.worldPosition[1]) / this.fullLayer.worldScaling[1]], V.scale = t, X.setAttribute("pos", V.pos), X.setAttribute("scale", V.scale);
              }
              W.set(X.name, V);
            }
          });
        }, this);
        const I = e.getElementById(Il.selectorBorderId), h = I == null ? void 0 : I.getBoundingClientRect();
        h && (c = El(c, {
          x: Math.floor(h.x),
          y: Math.floor(h.y),
          w: Math.round(h.width),
          h: Math.round(h.height)
        }));
      }
    }
    if (c)
      return c.x -= Il.SelectBorderPadding, c.y -= Il.SelectBorderPadding, c.w += Il.SelectBorderPadding * 2, c.h += Il.SelectBorderPadding * 2, l.angle && this.updateSelectorRect(e, c), this.oldRect = El(this.oldRect, c), this.oldSelectRect = c, {
        type: hl.UpdateNode,
        dataType: Fl.Local,
        rect: c,
        updateNodeOpts: W
      };
  }
  blurSelector(d) {
    const l = this.backToFullLayer(d);
    return {
      type: hl.Select,
      dataType: Fl.Local,
      rect: l,
      selectIds: [],
      willSyncService: !0
    };
  }
  getRightServiceId(d) {
    return d.replace("++", "-");
  }
  drawSelector(d) {
    const { drawRect: l, subRects: s, subPos: c, selectorId: W, layer: u } = d, e = new st({
      pos: [l.x, l.y],
      anchor: [0, 0],
      size: [l.w, l.h],
      className: `${l.w},${l.h}`,
      id: W,
      name: Il.selectorId,
      zIndex: 1e3
    }), n = [], G = new pi({
      normalize: !0,
      pos: [l.w / 2, l.h / 2],
      lineWidth: 1,
      strokeColor: this.workOptions.color,
      width: l.w,
      height: l.h,
      className: `${l.w / 2},${l.h / 2},${l.w},${l.h}`,
      id: Il.selectorBorderId
    });
    n.push(G), s.forEach((y, a) => {
      const I = c == null ? void 0 : c.get(a);
      if (I) {
        const h = [I[0] - l.x, I[1] - l.y], S = `${h[0]},${h[1]},${y.w},${y.h},${I[2]}`, p = new pi({
          normalize: !0,
          pos: h,
          lineWidth: 1,
          strokeColor: s.size > 1 ? this.workOptions.color : void 0,
          width: y.w,
          height: y.h,
          className: S,
          id: `selector-${a}`,
          name: `selector-${a}`
        });
        n.push(p);
      }
    }), n && e.append(...n), (u == null ? void 0 : u.parent).appendChild(e);
  }
  selectServiceNode(d, l, s) {
    var y;
    const { selectIds: c } = l, W = this.getRightServiceId(d), u = this.getSelectorRect(this.fullLayer, W, !0);
    (y = this.fullLayer.parent.getElementById(W)) == null || y.remove();
    let e;
    const n = /* @__PURE__ */ new Map(), G = /* @__PURE__ */ new Map();
    return c == null || c.forEach((a) => {
      var S;
      const I = s.get(a), h = this.fullLayer.getElementsByName(a)[0];
      if (I && h) {
        e = El(e, I.rect), n.set(a, I.rect);
        const p = h.worldPosition, X = ((S = I.opt) == null ? void 0 : S.rotate) || h.getAttribute("rotate") || 0;
        G.set(a, [...p, X]);
      }
    }), e && this.fullLayer && this.drawSelector({
      drawRect: e,
      subRects: n,
      subPos: G,
      selectorId: W,
      layer: this.fullLayer
    }), e = El(e, u), e && (e.x -= Il.SelectBorderPadding, e.y -= Il.SelectBorderPadding, e.w += Il.SelectBorderPadding * 2, e.h += Il.SelectBorderPadding * 2), e;
  }
  removeService() {
    throw new Error("Method not implemented.");
  }
  getSelector(d) {
    var W;
    let l;
    const s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
    return (W = this.selectIds) == null || W.forEach((u) => {
      var G;
      const e = d.get(u), n = (G = this.drawLayer) == null ? void 0 : G.getElementsByName(u)[0];
      if (e && n) {
        const y = n.worldPosition, a = n.getAttribute("rotate") || 0;
        l = El(l, e.rect), s.set(u, e.rect), c.set(u, [...y, a]);
      }
    }, this), this.oldRect = El(l, this.oldRect), this.draw({
      intersectRect: l,
      subRects: s,
      subPos: c
    }), l && (l.x -= Il.SelectBorderPadding, l.y -= Il.SelectBorderPadding, l.w += Il.SelectBorderPadding * 2, l.h += Il.SelectBorderPadding * 2), this.oldSelectRect = l, l;
  }
  updateSelectIds(d, l) {
    var e, n;
    let s;
    const c = (e = this.selectIds) == null ? void 0 : e.filter((G) => !d.includes(G)), W = d.filter((G) => {
      var y;
      return !((y = this.selectIds) != null && y.includes(G));
    });
    if (c != null && c.length && (s = this.backToFullLayer(l, c)), W.length) {
      this.sealToDrawLayer(W);
      for (const G of W) {
        const y = (n = l.get(G)) == null ? void 0 : n.rect;
        y && (s = El(s, y));
      }
      s && (s.x -= Il.SelectBorderPadding, s.y -= Il.SelectBorderPadding, s.w += Il.SelectBorderPadding * 2, s.h += Il.SelectBorderPadding * 2);
    }
    this.selectIds = d;
    const u = this.getSelector(l);
    return {
      bgRect: s,
      selectRect: u
    };
  }
}
Object.defineProperty(Il, "selectorId", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "selector"
});
Object.defineProperty(Il, "selectorBorderId", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "selector-border"
});
Object.defineProperty(Il, "SelectBorderPadding", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 2
});
class Xt {
  constructor(d, l) {
    Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "displayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dustbin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), this.displayer = d, this.collector = l;
  }
  /** 设置当前选中的工具配置数据 */
  setCurrentToolsData(d) {
    this.currentToolsData = d;
  }
  /** 设置当前绘制任务数据 */
  setCurrentLocalWorkData(d) {
    this.currentLocalWorkData = d;
  }
  /** 设置相机参数 */
  setCameraOpt(d) {
    this.cameraOpt = d;
  }
  /** 获取当前绘制任务id */
  getWorkId() {
    return this.currentLocalWorkData.workId;
  }
}
const Ws = "dmFyIHVoPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgaGg9KFN0LFl0LEF0KT0+WXQgaW4gU3Q/dWgoU3QsWXQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkF0fSk6U3RbWXRdPUF0O3ZhciBWdD0oU3QsWXQsQXQpPT4oaGgoU3QsdHlwZW9mIFl0IT0ic3ltYm9sIj9ZdCsiIjpZdCxBdCksQXQpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgU3Q7KGZ1bmN0aW9uKGgpe2hbaC5QZW5jaWw9MV09IlBlbmNpbCIsaFtoLkVyYXNlcj0yXT0iRXJhc2VyIixoW2guU2VsZWN0b3I9M109IlNlbGVjdG9yIixoW2guQ2xpY2tlcj00XT0iQ2xpY2tlciIsaFtoLkFycm93PTVdPSJBcnJvdyIsaFtoLkhhbmQ9Nl09IkhhbmQiLGhbaC5MYXNlclBlbj03XT0iTGFzZXJQZW4ifSkoU3R8fChTdD17fSkpO3ZhciBZdDsoZnVuY3Rpb24oaCl7aFtoLlBhdGg9MF09IlBhdGgiLGhbaC5SZWN0PTFdPSJSZWN0In0pKFl0fHwoWXQ9e30pKTt2YXIgQXQ7KGZ1bmN0aW9uKGgpe2hbaC5Mb2NhbD0xXT0iTG9jYWwiLGhbaC5TZXJ2aWNlPTJdPSJTZXJ2aWNlIn0pKEF0fHwoQXQ9e30pKTt2YXIgR3Q7KGZ1bmN0aW9uKGgpe2hbaC5QZW5kaW5nPTBdPSJQZW5kaW5nIixoW2guU3RhcnQ9MV09IlN0YXJ0IixoW2guRG9pbmc9Ml09IkRvaW5nIixoW2guRG9uZT0zXT0iRG9uZSIsaFtoLkZyZWV6ZT00XT0iRnJlZXplIixoW2guVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KShHdHx8KEd0PXt9KSk7dmFyIHl0OyhmdW5jdGlvbihoKXtoW2guSW5pdD0wXT0iSW5pdCIsaFtoLlVwZGF0ZUNhbWVyYT0xXT0iVXBkYXRlQ2FtZXJhIixoW2guVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixoW2guQ3JlYXRlV29yaz0zXT0iQ3JlYXRlV29yayIsaFtoLkRyYXdXb3JrPTRdPSJEcmF3V29yayIsaFtoLkZ1bGxXb3JrPTVdPSJGdWxsV29yayIsaFtoLlVwZGF0ZU5vZGU9Nl09IlVwZGF0ZU5vZGUiLGhbaC5SZW1vdmVOb2RlPTddPSJSZW1vdmVOb2RlIixoW2guQ2xlYXI9OF09IkNsZWFyIixoW2guU2VsZWN0PTldPSJTZWxlY3QiLGhbaC5EZXN0cm95PTEwXT0iRGVzdHJveSIsaFtoLk5vbmU9MTFdPSJOb25lIixoW2guU25hcHNob3Q9MTJdPSJTbmFwc2hvdCJ9KSh5dHx8KHl0PXt9KSk7dmFyIF9lOyhmdW5jdGlvbihoKXtoW2guUGF0aD0wXT0iUGF0aCIsaFtoLlJlY3Q9MV09IlJlY3QiLGhbaC5UZXh0dXJlPTJdPSJUZXh0dXJlIn0pKF9lfHwoX2U9e30pKTt2YXIgdHI7KGZ1bmN0aW9uKGgpe2guV2ViZ2wyPSJ3ZWJnbDIiLGguV2ViZ2w9IndlYmdsIixoLkNhbnZhczJkPSIyZCJ9KSh0cnx8KHRyPXt9KSk7dmFyIHB0OyhmdW5jdGlvbihoKXtoW2guRmxvYXQ9MV09IkZsb2F0IixoW2guQmc9Ml09IkJnIixoW2guU2VsZWN0b3I9M109IlNlbGVjdG9yIixoW2guTm9uZT00XT0iTm9uZSJ9KShwdHx8KHB0PXt9KSk7dmFyIGVyOyhmdW5jdGlvbihoKXtoLkxUPSJ0b3BMZWZ0IixoLkxDPSJsZWZ0IixoLkxCPSJib3R0b21MZWZ0IixoLlRDPSJ0b3AiLGguUlQ9InRvcFJpZ2h0IixoLlJDPSJyaWdodCIsaC5SQj0iYm90dG9tUmlnaHQiLGguQkM9ImJvdHRvbSJ9KShlcnx8KGVyPXt9KSk7Y2xhc3MgZGV7Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1VuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MWUzfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5mdWxsTGF5ZXI9ZSx0aGlzLmRyYXdMYXllcj10fXNldFdvcmtJZChlKXt0aGlzLndvcmtJZD1lfWdldFdvcmtJZCgpe3JldHVybiB0aGlzLndvcmtJZH1nZXRXb3JrT3B0aW9ucygpe3JldHVybiB0aGlzLndvcmtPcHRpb25zfXNldFdvcmtPcHRpb25zKGUpe3RoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNVbml0VGltZT1lLnN5bmNVbml0VGltZXx8dGhpcy5zeW5jVW5pdFRpbWV9fXZhciBSdD1mdW5jdGlvbihoKXt2YXIgZT17fTtmdW5jdGlvbiB0KHIpe2lmKGVbcl0pcmV0dXJuIGVbcl0uZXhwb3J0czt2YXIgbj1lW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gaFtyXS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyx0KSxuLmw9ITAsbi5leHBvcnRzfXJldHVybiB0Lm09aCx0LmM9ZSx0LmQ9ZnVuY3Rpb24ocixuLGQpe3QubyhyLG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkocixuLHtlbnVtZXJhYmxlOiEwLGdldDpkfSl9LHQucj1mdW5jdGlvbihyKXt0eXBlb2YgU3ltYm9sPCJ1IiYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkocixTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOiJNb2R1bGUifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfSx0LnQ9ZnVuY3Rpb24ocixuKXtpZihuJjEmJihyPXQocikpLG4mOHx8biY0JiZ0eXBlb2Ygcj09Im9iamVjdCImJnImJnIuX19lc01vZHVsZSlyZXR1cm4gcjt2YXIgZD1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHQucihkKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZCwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsdmFsdWU6cn0pLG4mMiYmdHlwZW9mIHIhPSJzdHJpbmciKWZvcih2YXIgZyBpbiByKXQuZChkLGcsKGZ1bmN0aW9uKHUpe3JldHVybiByW3VdfSkuYmluZChudWxsLGcpKTtyZXR1cm4gZH0sdC5uPWZ1bmN0aW9uKHIpe3ZhciBuPXImJnIuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9O3JldHVybiB0LmQobiwiYSIsbiksbn0sdC5vPWZ1bmN0aW9uKHIsbil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLG4pfSx0LnA9Ii9qcy8iLHQodC5zPTApfShbZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwidmVyc2lvbiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJoZWxwZXJzIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImNyZWF0ZUVsZW1lbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiaXNTcHJpdGVOb2RlIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInJlZ2lzdGVyTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pO3ZhciByPXQoMTIpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIHIuRU5WfSk7dmFyIG49dCg2OCk7dC5kKGUsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV9KSx0LmQoZSwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uY2FuY2VsQW5pbWF0aW9uRnJhbWV9KTt2YXIgZD10KDcwKTt0LmQoZSwiTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gZC5kZWZhdWx0fSk7dmFyIGc9dCgyMTcpO3QuZChlLCJDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fSk7dmFyIHU9dCgyMTkpO3QuZChlLCJCbG9jayIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIG89dCgyMjQpO3QuZChlLCJTcHJpdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG8uZGVmYXVsdH0pO3ZhciBjPXQoMjI2KTt0LmQoZSwiUGF0aCIsZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWZhdWx0fSk7dmFyIHA9dCgyMjkpO3QuZChlLCJSZWN0IixmdW5jdGlvbigpe3JldHVybiBwLmRlZmF1bHR9KTt2YXIgbD10KDIzMSk7dC5kKGUsIlRyaWFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBsLmRlZmF1bHR9KTt2YXIgeT10KDIzNik7dC5kKGUsIlBhcmFsbGVsIixmdW5jdGlvbigpe3JldHVybiB5LmRlZmF1bHR9KTt2YXIgeD10KDIzOCk7dC5kKGUsIlJlZ3VsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHguZGVmYXVsdH0pO3ZhciBiPXQoMjQwKTt0LmQoZSwiU3RhciIsZnVuY3Rpb24oKXtyZXR1cm4gYi5kZWZhdWx0fSk7dmFyIEU9dCgyNDIpO3QuZChlLCJFbGxpcHNlIixmdW5jdGlvbigpe3JldHVybiBFLmRlZmF1bHR9KTt2YXIgdj10KDI0NCk7dC5kKGUsIkFyYyIsZnVuY3Rpb24oKXtyZXR1cm4gdi5kZWZhdWx0fSk7dmFyIE09dCgyNDYpO3QuZChlLCJSaW5nIixmdW5jdGlvbigpe3JldHVybiBNLmRlZmF1bHR9KTt2YXIgaT10KDIzMik7dC5kKGUsIlBvbHlsaW5lIixmdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHR9KTt2YXIgYT10KDI0OCk7dC5kKGUsIkxhYmVsIixmdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHR9KTt2YXIgcz10KDI1MCk7dC5kKGUsIkdyb3VwIixmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHR9KTt2YXIgZj10KDI4Nik7dC5kKGUsIkxheWVyIixmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9KTt2YXIgTz10KDI4Nyk7dC5kKGUsIlNwcml0ZVN2ZyIsZnVuY3Rpb24oKXtyZXR1cm4gTy5kZWZhdWx0fSk7dmFyIEE9dCgyODkpO3QuZChlLCJMYXllcldvcmtlciIsZnVuY3Rpb24oKXtyZXR1cm4gQS5kZWZhdWx0fSk7dmFyIFI9dCgyOTApO3QuZChlLCJTY2VuZSIsZnVuY3Rpb24oKXtyZXR1cm4gUi5kZWZhdWx0fSk7dmFyIEk9dCgyMTMpLFA9dCgyMjEpO3QuZChlLCJDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gUC5Db2xvcn0pLHQuZChlLCJHcmFkaWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gUC5HcmFkaWVudH0pO3ZhciBMPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBEPUkuZGVmYXVsdC5jcmVhdGVFbGVtZW50LEM9SS5kZWZhdWx0LmlzU3ByaXRlTm9kZSxTPUkuZGVmYXVsdC5yZWdpc3Rlck5vZGUsQj17cGFyc2VDb2xvcjpQLnBhcnNlQ29sb3Isc2l6ZVRvUGl4ZWw6TC5zaXplVG9QaXhlbCx0b0FycmF5OkwudG9BcnJheSx0b1N0cmluZzpMLnRvU3RyaW5nLHRvTnVtYmVyOkwudG9OdW1iZXJ9O2xldCB3O3c9IjMuOC4zIjtjb25zdCBIPXd9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCgyKTt0LmQoZSwiZ2xNYXRyaXgiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KTt2YXIgbj10KDMpO3QuZChlLCJtYXQyIixmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIGQ9dCg0KTt0LmQoZSwibWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgZz10KDUpO3QuZChlLCJtYXQzIixmdW5jdGlvbigpe3JldHVybiBnfSk7dmFyIHU9dCg2KTt0LmQoZSwibWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBvPXQoNyk7dC5kKGUsInF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KTt2YXIgYz10KDEwKTt0LmQoZSwicXVhdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcD10KDExKTt0LmQoZSwidmVjMiIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pO3ZhciBsPXQoOCk7dC5kKGUsInZlYzMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgeT10KDkpO3QuZChlLCJ2ZWM0IixmdW5jdGlvbigpe3JldHVybiB5fSl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsIkVQU0lMT04iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwiQVJSQVlfVFlQRSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJSQU5ET00iLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwic2V0TWF0cml4QXJyYXlUeXBlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInRvUmFkaWFuIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPTFlLTYsbj10eXBlb2YgRmxvYXQzMkFycmF5PCJ1Ij9GbG9hdDMyQXJyYXk6QXJyYXksZD1NYXRoLnJhbmRvbTtmdW5jdGlvbiBnKHApe249cH12YXIgdT1NYXRoLlBJLzE4MDtmdW5jdGlvbiBvKHApe3JldHVybiBwKnV9ZnVuY3Rpb24gYyhwLGwpe3JldHVybiBNYXRoLmFicyhwLWwpPD1yKk1hdGgubWF4KDEsTWF0aC5hYnMocCksTWF0aC5hYnMobCkpfU1hdGguaHlwb3R8fChNYXRoLmh5cG90PWZ1bmN0aW9uKCl7Zm9yKHZhciBwPTAsbD1hcmd1bWVudHMubGVuZ3RoO2wtLTspcCs9YXJndW1lbnRzW2xdKmFyZ3VtZW50c1tsXTtyZXR1cm4gTWF0aC5zcXJ0KHApfSl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsIkxEVSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgUz1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFNbMV09MCxTWzJdPTApLFNbMF09MSxTWzNdPTEsU31mdW5jdGlvbiBkKFMpe3ZhciBCPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIEJbMF09U1swXSxCWzFdPVNbMV0sQlsyXT1TWzJdLEJbM109U1szXSxCfWZ1bmN0aW9uIGcoUyxCKXtyZXR1cm4gU1swXT1CWzBdLFNbMV09QlsxXSxTWzJdPUJbMl0sU1szXT1CWzNdLFN9ZnVuY3Rpb24gdShTKXtyZXR1cm4gU1swXT0xLFNbMV09MCxTWzJdPTAsU1szXT0xLFN9ZnVuY3Rpb24gbyhTLEIsdyxIKXt2YXIgWj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBaWzBdPVMsWlsxXT1CLFpbMl09dyxaWzNdPUgsWn1mdW5jdGlvbiBjKFMsQix3LEgsWil7cmV0dXJuIFNbMF09QixTWzFdPXcsU1syXT1ILFNbM109WixTfWZ1bmN0aW9uIHAoUyxCKXtpZihTPT09Qil7dmFyIHc9QlsxXTtTWzFdPUJbMl0sU1syXT13fWVsc2UgU1swXT1CWzBdLFNbMV09QlsyXSxTWzJdPUJbMV0sU1szXT1CWzNdO3JldHVybiBTfWZ1bmN0aW9uIGwoUyxCKXt2YXIgdz1CWzBdLEg9QlsxXSxaPUJbMl0scT1CWzNdLFU9dypxLVoqSDtyZXR1cm4gVT8oVT0xL1UsU1swXT1xKlUsU1sxXT0tSCpVLFNbMl09LVoqVSxTWzNdPXcqVSxTKTpudWxsfWZ1bmN0aW9uIHkoUyxCKXt2YXIgdz1CWzBdO3JldHVybiBTWzBdPUJbM10sU1sxXT0tQlsxXSxTWzJdPS1CWzJdLFNbM109dyxTfWZ1bmN0aW9uIHgoUyl7cmV0dXJuIFNbMF0qU1szXS1TWzJdKlNbMV19ZnVuY3Rpb24gYihTLEIsdyl7dmFyIEg9QlswXSxaPUJbMV0scT1CWzJdLFU9QlszXSxHPXdbMF0sSj13WzFdLHR0PXdbMl0sXz13WzNdO3JldHVybiBTWzBdPUgqRytxKkosU1sxXT1aKkcrVSpKLFNbMl09SCp0dCtxKl8sU1szXT1aKnR0K1UqXyxTfWZ1bmN0aW9uIEUoUyxCLHcpe3ZhciBIPUJbMF0sWj1CWzFdLHE9QlsyXSxVPUJbM10sRz1NYXRoLnNpbih3KSxKPU1hdGguY29zKHcpO3JldHVybiBTWzBdPUgqSitxKkcsU1sxXT1aKkorVSpHLFNbMl09SCotRytxKkosU1szXT1aKi1HK1UqSixTfWZ1bmN0aW9uIHYoUyxCLHcpe3ZhciBIPUJbMF0sWj1CWzFdLHE9QlsyXSxVPUJbM10sRz13WzBdLEo9d1sxXTtyZXR1cm4gU1swXT1IKkcsU1sxXT1aKkcsU1syXT1xKkosU1szXT1VKkosU31mdW5jdGlvbiBNKFMsQil7dmFyIHc9TWF0aC5zaW4oQiksSD1NYXRoLmNvcyhCKTtyZXR1cm4gU1swXT1ILFNbMV09dyxTWzJdPS13LFNbM109SCxTfWZ1bmN0aW9uIGkoUyxCKXtyZXR1cm4gU1swXT1CWzBdLFNbMV09MCxTWzJdPTAsU1szXT1CWzFdLFN9ZnVuY3Rpb24gYShTKXtyZXR1cm4ibWF0MigiK1NbMF0rIiwgIitTWzFdKyIsICIrU1syXSsiLCAiK1NbM10rIikifWZ1bmN0aW9uIHMoUyl7cmV0dXJuIE1hdGguaHlwb3QoU1swXSxTWzFdLFNbMl0sU1szXSl9ZnVuY3Rpb24gZihTLEIsdyxIKXtyZXR1cm4gU1syXT1IWzJdL0hbMF0sd1swXT1IWzBdLHdbMV09SFsxXSx3WzNdPUhbM10tU1syXSp3WzFdLFtTLEIsd119ZnVuY3Rpb24gTyhTLEIsdyl7cmV0dXJuIFNbMF09QlswXSt3WzBdLFNbMV09QlsxXSt3WzFdLFNbMl09QlsyXSt3WzJdLFNbM109QlszXSt3WzNdLFN9ZnVuY3Rpb24gQShTLEIsdyl7cmV0dXJuIFNbMF09QlswXS13WzBdLFNbMV09QlsxXS13WzFdLFNbMl09QlsyXS13WzJdLFNbM109QlszXS13WzNdLFN9ZnVuY3Rpb24gUihTLEIpe3JldHVybiBTWzBdPT09QlswXSYmU1sxXT09PUJbMV0mJlNbMl09PT1CWzJdJiZTWzNdPT09QlszXX1mdW5jdGlvbiBJKFMsQil7dmFyIHc9U1swXSxIPVNbMV0sWj1TWzJdLHE9U1szXSxVPUJbMF0sRz1CWzFdLEo9QlsyXSx0dD1CWzNdO3JldHVybiBNYXRoLmFicyh3LVUpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhVKSkmJk1hdGguYWJzKEgtRyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEgpLE1hdGguYWJzKEcpKSYmTWF0aC5hYnMoWi1KKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWiksTWF0aC5hYnMoSikpJiZNYXRoLmFicyhxLXR0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocSksTWF0aC5hYnModHQpKX1mdW5jdGlvbiBQKFMsQix3KXtyZXR1cm4gU1swXT1CWzBdKncsU1sxXT1CWzFdKncsU1syXT1CWzJdKncsU1szXT1CWzNdKncsU31mdW5jdGlvbiBMKFMsQix3LEgpe3JldHVybiBTWzBdPUJbMF0rd1swXSpILFNbMV09QlsxXSt3WzFdKkgsU1syXT1CWzJdK3dbMl0qSCxTWzNdPUJbM10rd1szXSpILFN9dmFyIEQ9YixDPUF9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBEfSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBuKCl7dmFyIEM9bmV3IHIuQVJSQVlfVFlQRSg2KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihDWzFdPTAsQ1syXT0wLENbNF09MCxDWzVdPTApLENbMF09MSxDWzNdPTEsQ31mdW5jdGlvbiBkKEMpe3ZhciBTPW5ldyByLkFSUkFZX1RZUEUoNik7cmV0dXJuIFNbMF09Q1swXSxTWzFdPUNbMV0sU1syXT1DWzJdLFNbM109Q1szXSxTWzRdPUNbNF0sU1s1XT1DWzVdLFN9ZnVuY3Rpb24gZyhDLFMpe3JldHVybiBDWzBdPVNbMF0sQ1sxXT1TWzFdLENbMl09U1syXSxDWzNdPVNbM10sQ1s0XT1TWzRdLENbNV09U1s1XSxDfWZ1bmN0aW9uIHUoQyl7cmV0dXJuIENbMF09MSxDWzFdPTAsQ1syXT0wLENbM109MSxDWzRdPTAsQ1s1XT0wLEN9ZnVuY3Rpb24gbyhDLFMsQix3LEgsWil7dmFyIHE9bmV3IHIuQVJSQVlfVFlQRSg2KTtyZXR1cm4gcVswXT1DLHFbMV09UyxxWzJdPUIscVszXT13LHFbNF09SCxxWzVdPVoscX1mdW5jdGlvbiBjKEMsUyxCLHcsSCxaLHEpe3JldHVybiBDWzBdPVMsQ1sxXT1CLENbMl09dyxDWzNdPUgsQ1s0XT1aLENbNV09cSxDfWZ1bmN0aW9uIHAoQyxTKXt2YXIgQj1TWzBdLHc9U1sxXSxIPVNbMl0sWj1TWzNdLHE9U1s0XSxVPVNbNV0sRz1CKlotdypIO3JldHVybiBHPyhHPTEvRyxDWzBdPVoqRyxDWzFdPS13KkcsQ1syXT0tSCpHLENbM109QipHLENbNF09KEgqVS1aKnEpKkcsQ1s1XT0odypxLUIqVSkqRyxDKTpudWxsfWZ1bmN0aW9uIGwoQyl7cmV0dXJuIENbMF0qQ1szXS1DWzFdKkNbMl19ZnVuY3Rpb24geShDLFMsQil7dmFyIHc9U1swXSxIPVNbMV0sWj1TWzJdLHE9U1szXSxVPVNbNF0sRz1TWzVdLEo9QlswXSx0dD1CWzFdLF89QlsyXSxzdD1CWzNdLGs9Qls0XSxodD1CWzVdO3JldHVybiBDWzBdPXcqSitaKnR0LENbMV09SCpKK3EqdHQsQ1syXT13Kl8rWipzdCxDWzNdPUgqXytxKnN0LENbNF09dyprK1oqaHQrVSxDWzVdPUgqaytxKmh0K0csQ31mdW5jdGlvbiB4KEMsUyxCKXt2YXIgdz1TWzBdLEg9U1sxXSxaPVNbMl0scT1TWzNdLFU9U1s0XSxHPVNbNV0sSj1NYXRoLnNpbihCKSx0dD1NYXRoLmNvcyhCKTtyZXR1cm4gQ1swXT13KnR0K1oqSixDWzFdPUgqdHQrcSpKLENbMl09dyotSitaKnR0LENbM109SCotSitxKnR0LENbNF09VSxDWzVdPUcsQ31mdW5jdGlvbiBiKEMsUyxCKXt2YXIgdz1TWzBdLEg9U1sxXSxaPVNbMl0scT1TWzNdLFU9U1s0XSxHPVNbNV0sSj1CWzBdLHR0PUJbMV07cmV0dXJuIENbMF09dypKLENbMV09SCpKLENbMl09Wip0dCxDWzNdPXEqdHQsQ1s0XT1VLENbNV09RyxDfWZ1bmN0aW9uIEUoQyxTLEIpe3ZhciB3PVNbMF0sSD1TWzFdLFo9U1syXSxxPVNbM10sVT1TWzRdLEc9U1s1XSxKPUJbMF0sdHQ9QlsxXTtyZXR1cm4gQ1swXT13LENbMV09SCxDWzJdPVosQ1szXT1xLENbNF09dypKK1oqdHQrVSxDWzVdPUgqSitxKnR0K0csQ31mdW5jdGlvbiB2KEMsUyl7dmFyIEI9TWF0aC5zaW4oUyksdz1NYXRoLmNvcyhTKTtyZXR1cm4gQ1swXT13LENbMV09QixDWzJdPS1CLENbM109dyxDWzRdPTAsQ1s1XT0wLEN9ZnVuY3Rpb24gTShDLFMpe3JldHVybiBDWzBdPVNbMF0sQ1sxXT0wLENbMl09MCxDWzNdPVNbMV0sQ1s0XT0wLENbNV09MCxDfWZ1bmN0aW9uIGkoQyxTKXtyZXR1cm4gQ1swXT0xLENbMV09MCxDWzJdPTAsQ1szXT0xLENbNF09U1swXSxDWzVdPVNbMV0sQ31mdW5jdGlvbiBhKEMpe3JldHVybiJtYXQyZCgiK0NbMF0rIiwgIitDWzFdKyIsICIrQ1syXSsiLCAiK0NbM10rIiwgIitDWzRdKyIsICIrQ1s1XSsiKSJ9ZnVuY3Rpb24gcyhDKXtyZXR1cm4gTWF0aC5oeXBvdChDWzBdLENbMV0sQ1syXSxDWzNdLENbNF0sQ1s1XSwxKX1mdW5jdGlvbiBmKEMsUyxCKXtyZXR1cm4gQ1swXT1TWzBdK0JbMF0sQ1sxXT1TWzFdK0JbMV0sQ1syXT1TWzJdK0JbMl0sQ1szXT1TWzNdK0JbM10sQ1s0XT1TWzRdK0JbNF0sQ1s1XT1TWzVdK0JbNV0sQ31mdW5jdGlvbiBPKEMsUyxCKXtyZXR1cm4gQ1swXT1TWzBdLUJbMF0sQ1sxXT1TWzFdLUJbMV0sQ1syXT1TWzJdLUJbMl0sQ1szXT1TWzNdLUJbM10sQ1s0XT1TWzRdLUJbNF0sQ1s1XT1TWzVdLUJbNV0sQ31mdW5jdGlvbiBBKEMsUyxCKXtyZXR1cm4gQ1swXT1TWzBdKkIsQ1sxXT1TWzFdKkIsQ1syXT1TWzJdKkIsQ1szXT1TWzNdKkIsQ1s0XT1TWzRdKkIsQ1s1XT1TWzVdKkIsQ31mdW5jdGlvbiBSKEMsUyxCLHcpe3JldHVybiBDWzBdPVNbMF0rQlswXSp3LENbMV09U1sxXStCWzFdKncsQ1syXT1TWzJdK0JbMl0qdyxDWzNdPVNbM10rQlszXSp3LENbNF09U1s0XStCWzRdKncsQ1s1XT1TWzVdK0JbNV0qdyxDfWZ1bmN0aW9uIEkoQyxTKXtyZXR1cm4gQ1swXT09PVNbMF0mJkNbMV09PT1TWzFdJiZDWzJdPT09U1syXSYmQ1szXT09PVNbM10mJkNbNF09PT1TWzRdJiZDWzVdPT09U1s1XX1mdW5jdGlvbiBQKEMsUyl7dmFyIEI9Q1swXSx3PUNbMV0sSD1DWzJdLFo9Q1szXSxxPUNbNF0sVT1DWzVdLEc9U1swXSxKPVNbMV0sdHQ9U1syXSxfPVNbM10sc3Q9U1s0XSxrPVNbNV07cmV0dXJuIE1hdGguYWJzKEItRyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEIpLE1hdGguYWJzKEcpKSYmTWF0aC5hYnMody1KKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModyksTWF0aC5hYnMoSikpJiZNYXRoLmFicyhILXR0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSCksTWF0aC5hYnModHQpKSYmTWF0aC5hYnMoWi1fKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWiksTWF0aC5hYnMoXykpJiZNYXRoLmFicyhxLXN0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocSksTWF0aC5hYnMoc3QpKSYmTWF0aC5hYnMoVS1rKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoaykpfXZhciBMPXksRD1PfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJub3JtYWxGcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJwcm9qZWN0aW9uIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBVPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoVVsxXT0wLFVbMl09MCxVWzNdPTAsVVs1XT0wLFVbNl09MCxVWzddPTApLFVbMF09MSxVWzRdPTEsVVs4XT0xLFV9ZnVuY3Rpb24gZChVLEcpe3JldHVybiBVWzBdPUdbMF0sVVsxXT1HWzFdLFVbMl09R1syXSxVWzNdPUdbNF0sVVs0XT1HWzVdLFVbNV09R1s2XSxVWzZdPUdbOF0sVVs3XT1HWzldLFVbOF09R1sxMF0sVX1mdW5jdGlvbiBnKFUpe3ZhciBHPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIEdbMF09VVswXSxHWzFdPVVbMV0sR1syXT1VWzJdLEdbM109VVszXSxHWzRdPVVbNF0sR1s1XT1VWzVdLEdbNl09VVs2XSxHWzddPVVbN10sR1s4XT1VWzhdLEd9ZnVuY3Rpb24gdShVLEcpe3JldHVybiBVWzBdPUdbMF0sVVsxXT1HWzFdLFVbMl09R1syXSxVWzNdPUdbM10sVVs0XT1HWzRdLFVbNV09R1s1XSxVWzZdPUdbNl0sVVs3XT1HWzddLFVbOF09R1s4XSxVfWZ1bmN0aW9uIG8oVSxHLEosdHQsXyxzdCxrLGh0LGZ0KXt2YXIgVz1uZXcgci5BUlJBWV9UWVBFKDkpO3JldHVybiBXWzBdPVUsV1sxXT1HLFdbMl09SixXWzNdPXR0LFdbNF09XyxXWzVdPXN0LFdbNl09ayxXWzddPWh0LFdbOF09ZnQsV31mdW5jdGlvbiBjKFUsRyxKLHR0LF8sc3QsayxodCxmdCxXKXtyZXR1cm4gVVswXT1HLFVbMV09SixVWzJdPXR0LFVbM109XyxVWzRdPXN0LFVbNV09ayxVWzZdPWh0LFVbN109ZnQsVVs4XT1XLFV9ZnVuY3Rpb24gcChVKXtyZXR1cm4gVVswXT0xLFVbMV09MCxVWzJdPTAsVVszXT0wLFVbNF09MSxVWzVdPTAsVVs2XT0wLFVbN109MCxVWzhdPTEsVX1mdW5jdGlvbiBsKFUsRyl7aWYoVT09PUcpe3ZhciBKPUdbMV0sdHQ9R1syXSxfPUdbNV07VVsxXT1HWzNdLFVbMl09R1s2XSxVWzNdPUosVVs1XT1HWzddLFVbNl09dHQsVVs3XT1ffWVsc2UgVVswXT1HWzBdLFVbMV09R1szXSxVWzJdPUdbNl0sVVszXT1HWzFdLFVbNF09R1s0XSxVWzVdPUdbN10sVVs2XT1HWzJdLFVbN109R1s1XSxVWzhdPUdbOF07cmV0dXJuIFV9ZnVuY3Rpb24geShVLEcpe3ZhciBKPUdbMF0sdHQ9R1sxXSxfPUdbMl0sc3Q9R1szXSxrPUdbNF0saHQ9R1s1XSxmdD1HWzZdLFc9R1s3XSxGPUdbOF0sVj1GKmstaHQqVyxYPS1GKnN0K2h0KmZ0LGo9VypzdC1rKmZ0LCQ9SipWK3R0KlgrXypqO3JldHVybiAkPygkPTEvJCxVWzBdPVYqJCxVWzFdPSgtRip0dCtfKlcpKiQsVVsyXT0oaHQqdHQtXyprKSokLFVbM109WCokLFVbNF09KEYqSi1fKmZ0KSokLFVbNV09KC1odCpKK18qc3QpKiQsVVs2XT1qKiQsVVs3XT0oLVcqSit0dCpmdCkqJCxVWzhdPShrKkotdHQqc3QpKiQsVSk6bnVsbH1mdW5jdGlvbiB4KFUsRyl7dmFyIEo9R1swXSx0dD1HWzFdLF89R1syXSxzdD1HWzNdLGs9R1s0XSxodD1HWzVdLGZ0PUdbNl0sVz1HWzddLEY9R1s4XTtyZXR1cm4gVVswXT1rKkYtaHQqVyxVWzFdPV8qVy10dCpGLFVbMl09dHQqaHQtXyprLFVbM109aHQqZnQtc3QqRixVWzRdPUoqRi1fKmZ0LFVbNV09XypzdC1KKmh0LFVbNl09c3QqVy1rKmZ0LFVbN109dHQqZnQtSipXLFVbOF09SiprLXR0KnN0LFV9ZnVuY3Rpb24gYihVKXt2YXIgRz1VWzBdLEo9VVsxXSx0dD1VWzJdLF89VVszXSxzdD1VWzRdLGs9VVs1XSxodD1VWzZdLGZ0PVVbN10sVz1VWzhdO3JldHVybiBHKihXKnN0LWsqZnQpK0oqKC1XKl8raypodCkrdHQqKGZ0Kl8tc3QqaHQpfWZ1bmN0aW9uIEUoVSxHLEope3ZhciB0dD1HWzBdLF89R1sxXSxzdD1HWzJdLGs9R1szXSxodD1HWzRdLGZ0PUdbNV0sVz1HWzZdLEY9R1s3XSxWPUdbOF0sWD1KWzBdLGo9SlsxXSwkPUpbMl0sbT1KWzNdLFQ9Sls0XSxOPUpbNV0sej1KWzZdLEs9Sls3XSxZPUpbOF07cmV0dXJuIFVbMF09WCp0dCtqKmsrJCpXLFVbMV09WCpfK2oqaHQrJCpGLFVbMl09WCpzdCtqKmZ0KyQqVixVWzNdPW0qdHQrVCprK04qVyxVWzRdPW0qXytUKmh0K04qRixVWzVdPW0qc3QrVCpmdCtOKlYsVVs2XT16KnR0K0sqaytZKlcsVVs3XT16Kl8rSypodCtZKkYsVVs4XT16KnN0K0sqZnQrWSpWLFV9ZnVuY3Rpb24gdihVLEcsSil7dmFyIHR0PUdbMF0sXz1HWzFdLHN0PUdbMl0saz1HWzNdLGh0PUdbNF0sZnQ9R1s1XSxXPUdbNl0sRj1HWzddLFY9R1s4XSxYPUpbMF0saj1KWzFdO3JldHVybiBVWzBdPXR0LFVbMV09XyxVWzJdPXN0LFVbM109ayxVWzRdPWh0LFVbNV09ZnQsVVs2XT1YKnR0K2oqaytXLFVbN109WCpfK2oqaHQrRixVWzhdPVgqc3QraipmdCtWLFV9ZnVuY3Rpb24gTShVLEcsSil7dmFyIHR0PUdbMF0sXz1HWzFdLHN0PUdbMl0saz1HWzNdLGh0PUdbNF0sZnQ9R1s1XSxXPUdbNl0sRj1HWzddLFY9R1s4XSxYPU1hdGguc2luKEopLGo9TWF0aC5jb3MoSik7cmV0dXJuIFVbMF09aip0dCtYKmssVVsxXT1qKl8rWCpodCxVWzJdPWoqc3QrWCpmdCxVWzNdPWoqay1YKnR0LFVbNF09aipodC1YKl8sVVs1XT1qKmZ0LVgqc3QsVVs2XT1XLFVbN109RixVWzhdPVYsVX1mdW5jdGlvbiBpKFUsRyxKKXt2YXIgdHQ9SlswXSxfPUpbMV07cmV0dXJuIFVbMF09dHQqR1swXSxVWzFdPXR0KkdbMV0sVVsyXT10dCpHWzJdLFVbM109XypHWzNdLFVbNF09XypHWzRdLFVbNV09XypHWzVdLFVbNl09R1s2XSxVWzddPUdbN10sVVs4XT1HWzhdLFV9ZnVuY3Rpb24gYShVLEcpe3JldHVybiBVWzBdPTEsVVsxXT0wLFVbMl09MCxVWzNdPTAsVVs0XT0xLFVbNV09MCxVWzZdPUdbMF0sVVs3XT1HWzFdLFVbOF09MSxVfWZ1bmN0aW9uIHMoVSxHKXt2YXIgSj1NYXRoLnNpbihHKSx0dD1NYXRoLmNvcyhHKTtyZXR1cm4gVVswXT10dCxVWzFdPUosVVsyXT0wLFVbM109LUosVVs0XT10dCxVWzVdPTAsVVs2XT0wLFVbN109MCxVWzhdPTEsVX1mdW5jdGlvbiBmKFUsRyl7cmV0dXJuIFVbMF09R1swXSxVWzFdPTAsVVsyXT0wLFVbM109MCxVWzRdPUdbMV0sVVs1XT0wLFVbNl09MCxVWzddPTAsVVs4XT0xLFV9ZnVuY3Rpb24gTyhVLEcpe3JldHVybiBVWzBdPUdbMF0sVVsxXT1HWzFdLFVbMl09MCxVWzNdPUdbMl0sVVs0XT1HWzNdLFVbNV09MCxVWzZdPUdbNF0sVVs3XT1HWzVdLFVbOF09MSxVfWZ1bmN0aW9uIEEoVSxHKXt2YXIgSj1HWzBdLHR0PUdbMV0sXz1HWzJdLHN0PUdbM10saz1KK0osaHQ9dHQrdHQsZnQ9XytfLFc9SiprLEY9dHQqayxWPXR0Kmh0LFg9XyprLGo9XypodCwkPV8qZnQsbT1zdCprLFQ9c3QqaHQsTj1zdCpmdDtyZXR1cm4gVVswXT0xLVYtJCxVWzNdPUYtTixVWzZdPVgrVCxVWzFdPUYrTixVWzRdPTEtVy0kLFVbN109ai1tLFVbMl09WC1ULFVbNV09aittLFVbOF09MS1XLVYsVX1mdW5jdGlvbiBSKFUsRyl7dmFyIEo9R1swXSx0dD1HWzFdLF89R1syXSxzdD1HWzNdLGs9R1s0XSxodD1HWzVdLGZ0PUdbNl0sVz1HWzddLEY9R1s4XSxWPUdbOV0sWD1HWzEwXSxqPUdbMTFdLCQ9R1sxMl0sbT1HWzEzXSxUPUdbMTRdLE49R1sxNV0sej1KKmh0LXR0KmssSz1KKmZ0LV8qayxZPUoqVy1zdCprLFE9dHQqZnQtXypodCxldD10dCpXLXN0Kmh0LHJ0PV8qVy1zdCpmdCxvdD1GKm0tViokLGx0PUYqVC1YKiQsaXQ9RipOLWoqJCxudD1WKlQtWCptLGF0PVYqTi1qKm0sZHQ9WCpOLWoqVCxndD16KmR0LUsqYXQrWSpudCtRKml0LWV0Kmx0K3J0Km90O3JldHVybiBndD8oZ3Q9MS9ndCxVWzBdPShodCpkdC1mdCphdCtXKm50KSpndCxVWzFdPShmdCppdC1rKmR0LVcqbHQpKmd0LFVbMl09KGsqYXQtaHQqaXQrVypvdCkqZ3QsVVszXT0oXyphdC10dCpkdC1zdCpudCkqZ3QsVVs0XT0oSipkdC1fKml0K3N0Kmx0KSpndCxVWzVdPSh0dCppdC1KKmF0LXN0Km90KSpndCxVWzZdPShtKnJ0LVQqZXQrTipRKSpndCxVWzddPShUKlktJCpydC1OKkspKmd0LFVbOF09KCQqZXQtbSpZK04qeikqZ3QsVSk6bnVsbH1mdW5jdGlvbiBJKFUsRyxKKXtyZXR1cm4gVVswXT0yL0csVVsxXT0wLFVbMl09MCxVWzNdPTAsVVs0XT0tMi9KLFVbNV09MCxVWzZdPS0xLFVbN109MSxVWzhdPTEsVX1mdW5jdGlvbiBQKFUpe3JldHVybiJtYXQzKCIrVVswXSsiLCAiK1VbMV0rIiwgIitVWzJdKyIsICIrVVszXSsiLCAiK1VbNF0rIiwgIitVWzVdKyIsICIrVVs2XSsiLCAiK1VbN10rIiwgIitVWzhdKyIpIn1mdW5jdGlvbiBMKFUpe3JldHVybiBNYXRoLmh5cG90KFVbMF0sVVsxXSxVWzJdLFVbM10sVVs0XSxVWzVdLFVbNl0sVVs3XSxVWzhdKX1mdW5jdGlvbiBEKFUsRyxKKXtyZXR1cm4gVVswXT1HWzBdK0pbMF0sVVsxXT1HWzFdK0pbMV0sVVsyXT1HWzJdK0pbMl0sVVszXT1HWzNdK0pbM10sVVs0XT1HWzRdK0pbNF0sVVs1XT1HWzVdK0pbNV0sVVs2XT1HWzZdK0pbNl0sVVs3XT1HWzddK0pbN10sVVs4XT1HWzhdK0pbOF0sVX1mdW5jdGlvbiBDKFUsRyxKKXtyZXR1cm4gVVswXT1HWzBdLUpbMF0sVVsxXT1HWzFdLUpbMV0sVVsyXT1HWzJdLUpbMl0sVVszXT1HWzNdLUpbM10sVVs0XT1HWzRdLUpbNF0sVVs1XT1HWzVdLUpbNV0sVVs2XT1HWzZdLUpbNl0sVVs3XT1HWzddLUpbN10sVVs4XT1HWzhdLUpbOF0sVX1mdW5jdGlvbiBTKFUsRyxKKXtyZXR1cm4gVVswXT1HWzBdKkosVVsxXT1HWzFdKkosVVsyXT1HWzJdKkosVVszXT1HWzNdKkosVVs0XT1HWzRdKkosVVs1XT1HWzVdKkosVVs2XT1HWzZdKkosVVs3XT1HWzddKkosVVs4XT1HWzhdKkosVX1mdW5jdGlvbiBCKFUsRyxKLHR0KXtyZXR1cm4gVVswXT1HWzBdK0pbMF0qdHQsVVsxXT1HWzFdK0pbMV0qdHQsVVsyXT1HWzJdK0pbMl0qdHQsVVszXT1HWzNdK0pbM10qdHQsVVs0XT1HWzRdK0pbNF0qdHQsVVs1XT1HWzVdK0pbNV0qdHQsVVs2XT1HWzZdK0pbNl0qdHQsVVs3XT1HWzddK0pbN10qdHQsVVs4XT1HWzhdK0pbOF0qdHQsVX1mdW5jdGlvbiB3KFUsRyl7cmV0dXJuIFVbMF09PT1HWzBdJiZVWzFdPT09R1sxXSYmVVsyXT09PUdbMl0mJlVbM109PT1HWzNdJiZVWzRdPT09R1s0XSYmVVs1XT09PUdbNV0mJlVbNl09PT1HWzZdJiZVWzddPT09R1s3XSYmVVs4XT09PUdbOF19ZnVuY3Rpb24gSChVLEcpe3ZhciBKPVVbMF0sdHQ9VVsxXSxfPVVbMl0sc3Q9VVszXSxrPVVbNF0saHQ9VVs1XSxmdD1VWzZdLFc9VVs3XSxGPVVbOF0sVj1HWzBdLFg9R1sxXSxqPUdbMl0sJD1HWzNdLG09R1s0XSxUPUdbNV0sTj1HWzZdLHo9R1s3XSxLPUdbOF07cmV0dXJuIE1hdGguYWJzKEotVik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEopLE1hdGguYWJzKFYpKSYmTWF0aC5hYnModHQtWCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHR0KSxNYXRoLmFicyhYKSkmJk1hdGguYWJzKF8taik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKF8pLE1hdGguYWJzKGopKSYmTWF0aC5hYnMoc3QtJCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHN0KSxNYXRoLmFicygkKSkmJk1hdGguYWJzKGstbSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGspLE1hdGguYWJzKG0pKSYmTWF0aC5hYnMoaHQtVCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGh0KSxNYXRoLmFicyhUKSkmJk1hdGguYWJzKGZ0LU4pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhmdCksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhXLXopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhXKSxNYXRoLmFicyh6KSkmJk1hdGguYWJzKEYtSyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEYpLE1hdGguYWJzKEspKX12YXIgWj1FLHE9Q30sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJmcm9tWFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImZyb21ZUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiZnJvbVpSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJmcm9tUXVhdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiZ2V0VHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZ2V0U2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJnZXRSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwiZnJvbVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwiZnJ1c3R1bSIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJwZXJzcGVjdGl2ZSIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJvcnRobyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJsb29rQXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsInRhcmdldFRvIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBtPW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKG1bMV09MCxtWzJdPTAsbVszXT0wLG1bNF09MCxtWzZdPTAsbVs3XT0wLG1bOF09MCxtWzldPTAsbVsxMV09MCxtWzEyXT0wLG1bMTNdPTAsbVsxNF09MCksbVswXT0xLG1bNV09MSxtWzEwXT0xLG1bMTVdPTEsbX1mdW5jdGlvbiBkKG0pe3ZhciBUPW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiBUWzBdPW1bMF0sVFsxXT1tWzFdLFRbMl09bVsyXSxUWzNdPW1bM10sVFs0XT1tWzRdLFRbNV09bVs1XSxUWzZdPW1bNl0sVFs3XT1tWzddLFRbOF09bVs4XSxUWzldPW1bOV0sVFsxMF09bVsxMF0sVFsxMV09bVsxMV0sVFsxMl09bVsxMl0sVFsxM109bVsxM10sVFsxNF09bVsxNF0sVFsxNV09bVsxNV0sVH1mdW5jdGlvbiBnKG0sVCl7cmV0dXJuIG1bMF09VFswXSxtWzFdPVRbMV0sbVsyXT1UWzJdLG1bM109VFszXSxtWzRdPVRbNF0sbVs1XT1UWzVdLG1bNl09VFs2XSxtWzddPVRbN10sbVs4XT1UWzhdLG1bOV09VFs5XSxtWzEwXT1UWzEwXSxtWzExXT1UWzExXSxtWzEyXT1UWzEyXSxtWzEzXT1UWzEzXSxtWzE0XT1UWzE0XSxtWzE1XT1UWzE1XSxtfWZ1bmN0aW9uIHUobSxULE4seixLLFksUSxldCxydCxvdCxsdCxpdCxudCxhdCxkdCxndCl7dmFyIHV0PW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiB1dFswXT1tLHV0WzFdPVQsdXRbMl09Tix1dFszXT16LHV0WzRdPUssdXRbNV09WSx1dFs2XT1RLHV0WzddPWV0LHV0WzhdPXJ0LHV0WzldPW90LHV0WzEwXT1sdCx1dFsxMV09aXQsdXRbMTJdPW50LHV0WzEzXT1hdCx1dFsxNF09ZHQsdXRbMTVdPWd0LHV0fWZ1bmN0aW9uIG8obSxULE4seixLLFksUSxldCxydCxvdCxsdCxpdCxudCxhdCxkdCxndCx1dCl7cmV0dXJuIG1bMF09VCxtWzFdPU4sbVsyXT16LG1bM109SyxtWzRdPVksbVs1XT1RLG1bNl09ZXQsbVs3XT1ydCxtWzhdPW90LG1bOV09bHQsbVsxMF09aXQsbVsxMV09bnQsbVsxMl09YXQsbVsxM109ZHQsbVsxNF09Z3QsbVsxNV09dXQsbX1mdW5jdGlvbiBjKG0pe3JldHVybiBtWzBdPTEsbVsxXT0wLG1bMl09MCxtWzNdPTAsbVs0XT0wLG1bNV09MSxtWzZdPTAsbVs3XT0wLG1bOF09MCxtWzldPTAsbVsxMF09MSxtWzExXT0wLG1bMTJdPTAsbVsxM109MCxtWzE0XT0wLG1bMTVdPTEsbX1mdW5jdGlvbiBwKG0sVCl7aWYobT09PVQpe3ZhciBOPVRbMV0sej1UWzJdLEs9VFszXSxZPVRbNl0sUT1UWzddLGV0PVRbMTFdO21bMV09VFs0XSxtWzJdPVRbOF0sbVszXT1UWzEyXSxtWzRdPU4sbVs2XT1UWzldLG1bN109VFsxM10sbVs4XT16LG1bOV09WSxtWzExXT1UWzE0XSxtWzEyXT1LLG1bMTNdPVEsbVsxNF09ZXR9ZWxzZSBtWzBdPVRbMF0sbVsxXT1UWzRdLG1bMl09VFs4XSxtWzNdPVRbMTJdLG1bNF09VFsxXSxtWzVdPVRbNV0sbVs2XT1UWzldLG1bN109VFsxM10sbVs4XT1UWzJdLG1bOV09VFs2XSxtWzEwXT1UWzEwXSxtWzExXT1UWzE0XSxtWzEyXT1UWzNdLG1bMTNdPVRbN10sbVsxNF09VFsxMV0sbVsxNV09VFsxNV07cmV0dXJuIG19ZnVuY3Rpb24gbChtLFQpe3ZhciBOPVRbMF0sej1UWzFdLEs9VFsyXSxZPVRbM10sUT1UWzRdLGV0PVRbNV0scnQ9VFs2XSxvdD1UWzddLGx0PVRbOF0saXQ9VFs5XSxudD1UWzEwXSxhdD1UWzExXSxkdD1UWzEyXSxndD1UWzEzXSx1dD1UWzE0XSxtdD1UWzE1XSxQdD1OKmV0LXoqUSx4dD1OKnJ0LUsqUSxNdD1OKm90LVkqUSxFdD16KnJ0LUsqZXQsT3Q9eipvdC1ZKmV0LFV0PUsqb3QtWSpydCxCdD1sdCpndC1pdCpkdCxXdD1sdCp1dC1udCpkdCxGdD1sdCptdC1hdCpkdCx6dD1pdCp1dC1udCpndCwkdD1pdCptdC1hdCpndCx3dD1udCptdC1hdCp1dCxDdD1QdCp3dC14dCokdCtNdCp6dCtFdCpGdC1PdCpXdCtVdCpCdDtyZXR1cm4gQ3Q/KEN0PTEvQ3QsbVswXT0oZXQqd3QtcnQqJHQrb3QqenQpKkN0LG1bMV09KEsqJHQteip3dC1ZKnp0KSpDdCxtWzJdPShndCpVdC11dCpPdCttdCpFdCkqQ3QsbVszXT0obnQqT3QtaXQqVXQtYXQqRXQpKkN0LG1bNF09KHJ0KkZ0LVEqd3Qtb3QqV3QpKkN0LG1bNV09KE4qd3QtSypGdCtZKld0KSpDdCxtWzZdPSh1dCpNdC1kdCpVdC1tdCp4dCkqQ3QsbVs3XT0obHQqVXQtbnQqTXQrYXQqeHQpKkN0LG1bOF09KFEqJHQtZXQqRnQrb3QqQnQpKkN0LG1bOV09KHoqRnQtTiokdC1ZKkJ0KSpDdCxtWzEwXT0oZHQqT3QtZ3QqTXQrbXQqUHQpKkN0LG1bMTFdPShpdCpNdC1sdCpPdC1hdCpQdCkqQ3QsbVsxMl09KGV0Kld0LVEqenQtcnQqQnQpKkN0LG1bMTNdPShOKnp0LXoqV3QrSypCdCkqQ3QsbVsxNF09KGd0Knh0LWR0KkV0LXV0KlB0KSpDdCxtWzE1XT0obHQqRXQtaXQqeHQrbnQqUHQpKkN0LG0pOm51bGx9ZnVuY3Rpb24geShtLFQpe3ZhciBOPVRbMF0sej1UWzFdLEs9VFsyXSxZPVRbM10sUT1UWzRdLGV0PVRbNV0scnQ9VFs2XSxvdD1UWzddLGx0PVRbOF0saXQ9VFs5XSxudD1UWzEwXSxhdD1UWzExXSxkdD1UWzEyXSxndD1UWzEzXSx1dD1UWzE0XSxtdD1UWzE1XTtyZXR1cm4gbVswXT1ldCoobnQqbXQtYXQqdXQpLWl0KihydCptdC1vdCp1dCkrZ3QqKHJ0KmF0LW90Km50KSxtWzFdPS0oeioobnQqbXQtYXQqdXQpLWl0KihLKm10LVkqdXQpK2d0KihLKmF0LVkqbnQpKSxtWzJdPXoqKHJ0Km10LW90KnV0KS1ldCooSyptdC1ZKnV0KStndCooSypvdC1ZKnJ0KSxtWzNdPS0oeioocnQqYXQtb3QqbnQpLWV0KihLKmF0LVkqbnQpK2l0KihLKm90LVkqcnQpKSxtWzRdPS0oUSoobnQqbXQtYXQqdXQpLWx0KihydCptdC1vdCp1dCkrZHQqKHJ0KmF0LW90Km50KSksbVs1XT1OKihudCptdC1hdCp1dCktbHQqKEsqbXQtWSp1dCkrZHQqKEsqYXQtWSpudCksbVs2XT0tKE4qKHJ0Km10LW90KnV0KS1RKihLKm10LVkqdXQpK2R0KihLKm90LVkqcnQpKSxtWzddPU4qKHJ0KmF0LW90Km50KS1RKihLKmF0LVkqbnQpK2x0KihLKm90LVkqcnQpLG1bOF09USooaXQqbXQtYXQqZ3QpLWx0KihldCptdC1vdCpndCkrZHQqKGV0KmF0LW90Kml0KSxtWzldPS0oTiooaXQqbXQtYXQqZ3QpLWx0Kih6Km10LVkqZ3QpK2R0Kih6KmF0LVkqaXQpKSxtWzEwXT1OKihldCptdC1vdCpndCktUSooeiptdC1ZKmd0KStkdCooeipvdC1ZKmV0KSxtWzExXT0tKE4qKGV0KmF0LW90Kml0KS1RKih6KmF0LVkqaXQpK2x0Kih6Km90LVkqZXQpKSxtWzEyXT0tKFEqKGl0KnV0LW50Kmd0KS1sdCooZXQqdXQtcnQqZ3QpK2R0KihldCpudC1ydCppdCkpLG1bMTNdPU4qKGl0KnV0LW50Kmd0KS1sdCooeip1dC1LKmd0KStkdCooeipudC1LKml0KSxtWzE0XT0tKE4qKGV0KnV0LXJ0Kmd0KS1RKih6KnV0LUsqZ3QpK2R0Kih6KnJ0LUsqZXQpKSxtWzE1XT1OKihldCpudC1ydCppdCktUSooeipudC1LKml0KStsdCooeipydC1LKmV0KSxtfWZ1bmN0aW9uIHgobSl7dmFyIFQ9bVswXSxOPW1bMV0sej1tWzJdLEs9bVszXSxZPW1bNF0sUT1tWzVdLGV0PW1bNl0scnQ9bVs3XSxvdD1tWzhdLGx0PW1bOV0saXQ9bVsxMF0sbnQ9bVsxMV0sYXQ9bVsxMl0sZHQ9bVsxM10sZ3Q9bVsxNF0sdXQ9bVsxNV0sbXQ9VCpRLU4qWSxQdD1UKmV0LXoqWSx4dD1UKnJ0LUsqWSxNdD1OKmV0LXoqUSxFdD1OKnJ0LUsqUSxPdD16KnJ0LUsqZXQsVXQ9b3QqZHQtbHQqYXQsQnQ9b3QqZ3QtaXQqYXQsV3Q9b3QqdXQtbnQqYXQsRnQ9bHQqZ3QtaXQqZHQsenQ9bHQqdXQtbnQqZHQsJHQ9aXQqdXQtbnQqZ3Q7cmV0dXJuIG10KiR0LVB0Knp0K3h0KkZ0K010Kld0LUV0KkJ0K090KlV0fWZ1bmN0aW9uIGIobSxULE4pe3ZhciB6PVRbMF0sSz1UWzFdLFk9VFsyXSxRPVRbM10sZXQ9VFs0XSxydD1UWzVdLG90PVRbNl0sbHQ9VFs3XSxpdD1UWzhdLG50PVRbOV0sYXQ9VFsxMF0sZHQ9VFsxMV0sZ3Q9VFsxMl0sdXQ9VFsxM10sbXQ9VFsxNF0sUHQ9VFsxNV0seHQ9TlswXSxNdD1OWzFdLEV0PU5bMl0sT3Q9TlszXTtyZXR1cm4gbVswXT14dCp6K010KmV0K0V0Kml0K090Kmd0LG1bMV09eHQqSytNdCpydCtFdCpudCtPdCp1dCxtWzJdPXh0KlkrTXQqb3QrRXQqYXQrT3QqbXQsbVszXT14dCpRK010Kmx0K0V0KmR0K090KlB0LHh0PU5bNF0sTXQ9Tls1XSxFdD1OWzZdLE90PU5bN10sbVs0XT14dCp6K010KmV0K0V0Kml0K090Kmd0LG1bNV09eHQqSytNdCpydCtFdCpudCtPdCp1dCxtWzZdPXh0KlkrTXQqb3QrRXQqYXQrT3QqbXQsbVs3XT14dCpRK010Kmx0K0V0KmR0K090KlB0LHh0PU5bOF0sTXQ9Tls5XSxFdD1OWzEwXSxPdD1OWzExXSxtWzhdPXh0KnorTXQqZXQrRXQqaXQrT3QqZ3QsbVs5XT14dCpLK010KnJ0K0V0Km50K090KnV0LG1bMTBdPXh0KlkrTXQqb3QrRXQqYXQrT3QqbXQsbVsxMV09eHQqUStNdCpsdCtFdCpkdCtPdCpQdCx4dD1OWzEyXSxNdD1OWzEzXSxFdD1OWzE0XSxPdD1OWzE1XSxtWzEyXT14dCp6K010KmV0K0V0Kml0K090Kmd0LG1bMTNdPXh0KksrTXQqcnQrRXQqbnQrT3QqdXQsbVsxNF09eHQqWStNdCpvdCtFdCphdCtPdCptdCxtWzE1XT14dCpRK010Kmx0K0V0KmR0K090KlB0LG19ZnVuY3Rpb24gRShtLFQsTil7dmFyIHo9TlswXSxLPU5bMV0sWT1OWzJdLFEsZXQscnQsb3QsbHQsaXQsbnQsYXQsZHQsZ3QsdXQsbXQ7cmV0dXJuIFQ9PT1tPyhtWzEyXT1UWzBdKnorVFs0XSpLK1RbOF0qWStUWzEyXSxtWzEzXT1UWzFdKnorVFs1XSpLK1RbOV0qWStUWzEzXSxtWzE0XT1UWzJdKnorVFs2XSpLK1RbMTBdKlkrVFsxNF0sbVsxNV09VFszXSp6K1RbN10qSytUWzExXSpZK1RbMTVdKTooUT1UWzBdLGV0PVRbMV0scnQ9VFsyXSxvdD1UWzNdLGx0PVRbNF0saXQ9VFs1XSxudD1UWzZdLGF0PVRbN10sZHQ9VFs4XSxndD1UWzldLHV0PVRbMTBdLG10PVRbMTFdLG1bMF09USxtWzFdPWV0LG1bMl09cnQsbVszXT1vdCxtWzRdPWx0LG1bNV09aXQsbVs2XT1udCxtWzddPWF0LG1bOF09ZHQsbVs5XT1ndCxtWzEwXT11dCxtWzExXT1tdCxtWzEyXT1RKnorbHQqSytkdCpZK1RbMTJdLG1bMTNdPWV0KnoraXQqSytndCpZK1RbMTNdLG1bMTRdPXJ0KnorbnQqSyt1dCpZK1RbMTRdLG1bMTVdPW90KnorYXQqSyttdCpZK1RbMTVdKSxtfWZ1bmN0aW9uIHYobSxULE4pe3ZhciB6PU5bMF0sSz1OWzFdLFk9TlsyXTtyZXR1cm4gbVswXT1UWzBdKnosbVsxXT1UWzFdKnosbVsyXT1UWzJdKnosbVszXT1UWzNdKnosbVs0XT1UWzRdKkssbVs1XT1UWzVdKkssbVs2XT1UWzZdKkssbVs3XT1UWzddKkssbVs4XT1UWzhdKlksbVs5XT1UWzldKlksbVsxMF09VFsxMF0qWSxtWzExXT1UWzExXSpZLG1bMTJdPVRbMTJdLG1bMTNdPVRbMTNdLG1bMTRdPVRbMTRdLG1bMTVdPVRbMTVdLG19ZnVuY3Rpb24gTShtLFQsTix6KXt2YXIgSz16WzBdLFk9elsxXSxRPXpbMl0sZXQ9TWF0aC5oeXBvdChLLFksUSkscnQsb3QsbHQsaXQsbnQsYXQsZHQsZ3QsdXQsbXQsUHQseHQsTXQsRXQsT3QsVXQsQnQsV3QsRnQsenQsJHQsd3QsQ3QsSHQ7cmV0dXJuIGV0PHIuRVBTSUxPTj9udWxsOihldD0xL2V0LEsqPWV0LFkqPWV0LFEqPWV0LHJ0PU1hdGguc2luKE4pLG90PU1hdGguY29zKE4pLGx0PTEtb3QsaXQ9VFswXSxudD1UWzFdLGF0PVRbMl0sZHQ9VFszXSxndD1UWzRdLHV0PVRbNV0sbXQ9VFs2XSxQdD1UWzddLHh0PVRbOF0sTXQ9VFs5XSxFdD1UWzEwXSxPdD1UWzExXSxVdD1LKksqbHQrb3QsQnQ9WSpLKmx0K1EqcnQsV3Q9USpLKmx0LVkqcnQsRnQ9SypZKmx0LVEqcnQsenQ9WSpZKmx0K290LCR0PVEqWSpsdCtLKnJ0LHd0PUsqUSpsdCtZKnJ0LEN0PVkqUSpsdC1LKnJ0LEh0PVEqUSpsdCtvdCxtWzBdPWl0KlV0K2d0KkJ0K3h0Kld0LG1bMV09bnQqVXQrdXQqQnQrTXQqV3QsbVsyXT1hdCpVdCttdCpCdCtFdCpXdCxtWzNdPWR0KlV0K1B0KkJ0K090Kld0LG1bNF09aXQqRnQrZ3QqenQreHQqJHQsbVs1XT1udCpGdCt1dCp6dCtNdCokdCxtWzZdPWF0KkZ0K210Knp0K0V0KiR0LG1bN109ZHQqRnQrUHQqenQrT3QqJHQsbVs4XT1pdCp3dCtndCpDdCt4dCpIdCxtWzldPW50Knd0K3V0KkN0K010Kkh0LG1bMTBdPWF0Knd0K210KkN0K0V0Kkh0LG1bMTFdPWR0Knd0K1B0KkN0K090Kkh0LFQhPT1tJiYobVsxMl09VFsxMl0sbVsxM109VFsxM10sbVsxNF09VFsxNF0sbVsxNV09VFsxNV0pLG0pfWZ1bmN0aW9uIGkobSxULE4pe3ZhciB6PU1hdGguc2luKE4pLEs9TWF0aC5jb3MoTiksWT1UWzRdLFE9VFs1XSxldD1UWzZdLHJ0PVRbN10sb3Q9VFs4XSxsdD1UWzldLGl0PVRbMTBdLG50PVRbMTFdO3JldHVybiBUIT09bSYmKG1bMF09VFswXSxtWzFdPVRbMV0sbVsyXT1UWzJdLG1bM109VFszXSxtWzEyXT1UWzEyXSxtWzEzXT1UWzEzXSxtWzE0XT1UWzE0XSxtWzE1XT1UWzE1XSksbVs0XT1ZKksrb3QqeixtWzVdPVEqSytsdCp6LG1bNl09ZXQqSytpdCp6LG1bN109cnQqSytudCp6LG1bOF09b3QqSy1ZKnosbVs5XT1sdCpLLVEqeixtWzEwXT1pdCpLLWV0KnosbVsxMV09bnQqSy1ydCp6LG19ZnVuY3Rpb24gYShtLFQsTil7dmFyIHo9TWF0aC5zaW4oTiksSz1NYXRoLmNvcyhOKSxZPVRbMF0sUT1UWzFdLGV0PVRbMl0scnQ9VFszXSxvdD1UWzhdLGx0PVRbOV0saXQ9VFsxMF0sbnQ9VFsxMV07cmV0dXJuIFQhPT1tJiYobVs0XT1UWzRdLG1bNV09VFs1XSxtWzZdPVRbNl0sbVs3XT1UWzddLG1bMTJdPVRbMTJdLG1bMTNdPVRbMTNdLG1bMTRdPVRbMTRdLG1bMTVdPVRbMTVdKSxtWzBdPVkqSy1vdCp6LG1bMV09USpLLWx0KnosbVsyXT1ldCpLLWl0KnosbVszXT1ydCpLLW50KnosbVs4XT1ZKnorb3QqSyxtWzldPVEqeitsdCpLLG1bMTBdPWV0KnoraXQqSyxtWzExXT1ydCp6K250KkssbX1mdW5jdGlvbiBzKG0sVCxOKXt2YXIgej1NYXRoLnNpbihOKSxLPU1hdGguY29zKE4pLFk9VFswXSxRPVRbMV0sZXQ9VFsyXSxydD1UWzNdLG90PVRbNF0sbHQ9VFs1XSxpdD1UWzZdLG50PVRbN107cmV0dXJuIFQhPT1tJiYobVs4XT1UWzhdLG1bOV09VFs5XSxtWzEwXT1UWzEwXSxtWzExXT1UWzExXSxtWzEyXT1UWzEyXSxtWzEzXT1UWzEzXSxtWzE0XT1UWzE0XSxtWzE1XT1UWzE1XSksbVswXT1ZKksrb3QqeixtWzFdPVEqSytsdCp6LG1bMl09ZXQqSytpdCp6LG1bM109cnQqSytudCp6LG1bNF09b3QqSy1ZKnosbVs1XT1sdCpLLVEqeixtWzZdPWl0KkstZXQqeixtWzddPW50KkstcnQqeixtfWZ1bmN0aW9uIGYobSxUKXtyZXR1cm4gbVswXT0xLG1bMV09MCxtWzJdPTAsbVszXT0wLG1bNF09MCxtWzVdPTEsbVs2XT0wLG1bN109MCxtWzhdPTAsbVs5XT0wLG1bMTBdPTEsbVsxMV09MCxtWzEyXT1UWzBdLG1bMTNdPVRbMV0sbVsxNF09VFsyXSxtWzE1XT0xLG19ZnVuY3Rpb24gTyhtLFQpe3JldHVybiBtWzBdPVRbMF0sbVsxXT0wLG1bMl09MCxtWzNdPTAsbVs0XT0wLG1bNV09VFsxXSxtWzZdPTAsbVs3XT0wLG1bOF09MCxtWzldPTAsbVsxMF09VFsyXSxtWzExXT0wLG1bMTJdPTAsbVsxM109MCxtWzE0XT0wLG1bMTVdPTEsbX1mdW5jdGlvbiBBKG0sVCxOKXt2YXIgej1OWzBdLEs9TlsxXSxZPU5bMl0sUT1NYXRoLmh5cG90KHosSyxZKSxldCxydCxvdDtyZXR1cm4gUTxyLkVQU0lMT04/bnVsbDooUT0xL1Eseio9USxLKj1RLFkqPVEsZXQ9TWF0aC5zaW4oVCkscnQ9TWF0aC5jb3MoVCksb3Q9MS1ydCxtWzBdPXoqeipvdCtydCxtWzFdPUsqeipvdCtZKmV0LG1bMl09WSp6Km90LUsqZXQsbVszXT0wLG1bNF09eipLKm90LVkqZXQsbVs1XT1LKksqb3QrcnQsbVs2XT1ZKksqb3QreipldCxtWzddPTAsbVs4XT16Klkqb3QrSypldCxtWzldPUsqWSpvdC16KmV0LG1bMTBdPVkqWSpvdCtydCxtWzExXT0wLG1bMTJdPTAsbVsxM109MCxtWzE0XT0wLG1bMTVdPTEsbSl9ZnVuY3Rpb24gUihtLFQpe3ZhciBOPU1hdGguc2luKFQpLHo9TWF0aC5jb3MoVCk7cmV0dXJuIG1bMF09MSxtWzFdPTAsbVsyXT0wLG1bM109MCxtWzRdPTAsbVs1XT16LG1bNl09TixtWzddPTAsbVs4XT0wLG1bOV09LU4sbVsxMF09eixtWzExXT0wLG1bMTJdPTAsbVsxM109MCxtWzE0XT0wLG1bMTVdPTEsbX1mdW5jdGlvbiBJKG0sVCl7dmFyIE49TWF0aC5zaW4oVCksej1NYXRoLmNvcyhUKTtyZXR1cm4gbVswXT16LG1bMV09MCxtWzJdPS1OLG1bM109MCxtWzRdPTAsbVs1XT0xLG1bNl09MCxtWzddPTAsbVs4XT1OLG1bOV09MCxtWzEwXT16LG1bMTFdPTAsbVsxMl09MCxtWzEzXT0wLG1bMTRdPTAsbVsxNV09MSxtfWZ1bmN0aW9uIFAobSxUKXt2YXIgTj1NYXRoLnNpbihUKSx6PU1hdGguY29zKFQpO3JldHVybiBtWzBdPXosbVsxXT1OLG1bMl09MCxtWzNdPTAsbVs0XT0tTixtWzVdPXosbVs2XT0wLG1bN109MCxtWzhdPTAsbVs5XT0wLG1bMTBdPTEsbVsxMV09MCxtWzEyXT0wLG1bMTNdPTAsbVsxNF09MCxtWzE1XT0xLG19ZnVuY3Rpb24gTChtLFQsTil7dmFyIHo9VFswXSxLPVRbMV0sWT1UWzJdLFE9VFszXSxldD16K3oscnQ9SytLLG90PVkrWSxsdD16KmV0LGl0PXoqcnQsbnQ9eipvdCxhdD1LKnJ0LGR0PUsqb3QsZ3Q9WSpvdCx1dD1RKmV0LG10PVEqcnQsUHQ9USpvdDtyZXR1cm4gbVswXT0xLShhdCtndCksbVsxXT1pdCtQdCxtWzJdPW50LW10LG1bM109MCxtWzRdPWl0LVB0LG1bNV09MS0obHQrZ3QpLG1bNl09ZHQrdXQsbVs3XT0wLG1bOF09bnQrbXQsbVs5XT1kdC11dCxtWzEwXT0xLShsdCthdCksbVsxMV09MCxtWzEyXT1OWzBdLG1bMTNdPU5bMV0sbVsxNF09TlsyXSxtWzE1XT0xLG19ZnVuY3Rpb24gRChtLFQpe3ZhciBOPW5ldyByLkFSUkFZX1RZUEUoMyksej0tVFswXSxLPS1UWzFdLFk9LVRbMl0sUT1UWzNdLGV0PVRbNF0scnQ9VFs1XSxvdD1UWzZdLGx0PVRbN10saXQ9eip6K0sqSytZKlkrUSpRO3JldHVybiBpdD4wPyhOWzBdPShldCpRK2x0KnorcnQqWS1vdCpLKSoyL2l0LE5bMV09KHJ0KlErbHQqSytvdCp6LWV0KlkpKjIvaXQsTlsyXT0ob3QqUStsdCpZK2V0KkstcnQqeikqMi9pdCk6KE5bMF09KGV0KlErbHQqeitydCpZLW90KkspKjIsTlsxXT0ocnQqUStsdCpLK290KnotZXQqWSkqMixOWzJdPShvdCpRK2x0KlkrZXQqSy1ydCp6KSoyKSxMKG0sVCxOKSxtfWZ1bmN0aW9uIEMobSxUKXtyZXR1cm4gbVswXT1UWzEyXSxtWzFdPVRbMTNdLG1bMl09VFsxNF0sbX1mdW5jdGlvbiBTKG0sVCl7dmFyIE49VFswXSx6PVRbMV0sSz1UWzJdLFk9VFs0XSxRPVRbNV0sZXQ9VFs2XSxydD1UWzhdLG90PVRbOV0sbHQ9VFsxMF07cmV0dXJuIG1bMF09TWF0aC5oeXBvdChOLHosSyksbVsxXT1NYXRoLmh5cG90KFksUSxldCksbVsyXT1NYXRoLmh5cG90KHJ0LG90LGx0KSxtfWZ1bmN0aW9uIEIobSxUKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDMpO1MoTixUKTt2YXIgej0xL05bMF0sSz0xL05bMV0sWT0xL05bMl0sUT1UWzBdKnosZXQ9VFsxXSpLLHJ0PVRbMl0qWSxvdD1UWzRdKnosbHQ9VFs1XSpLLGl0PVRbNl0qWSxudD1UWzhdKnosYXQ9VFs5XSpLLGR0PVRbMTBdKlksZ3Q9UStsdCtkdCx1dD0wO3JldHVybiBndD4wPyh1dD1NYXRoLnNxcnQoZ3QrMSkqMixtWzNdPS4yNSp1dCxtWzBdPShpdC1hdCkvdXQsbVsxXT0obnQtcnQpL3V0LG1bMl09KGV0LW90KS91dCk6UT5sdCYmUT5kdD8odXQ9TWF0aC5zcXJ0KDErUS1sdC1kdCkqMixtWzNdPShpdC1hdCkvdXQsbVswXT0uMjUqdXQsbVsxXT0oZXQrb3QpL3V0LG1bMl09KG50K3J0KS91dCk6bHQ+ZHQ/KHV0PU1hdGguc3FydCgxK2x0LVEtZHQpKjIsbVszXT0obnQtcnQpL3V0LG1bMF09KGV0K290KS91dCxtWzFdPS4yNSp1dCxtWzJdPShpdCthdCkvdXQpOih1dD1NYXRoLnNxcnQoMStkdC1RLWx0KSoyLG1bM109KGV0LW90KS91dCxtWzBdPShudCtydCkvdXQsbVsxXT0oaXQrYXQpL3V0LG1bMl09LjI1KnV0KSxtfWZ1bmN0aW9uIHcobSxULE4seil7dmFyIEs9VFswXSxZPVRbMV0sUT1UWzJdLGV0PVRbM10scnQ9SytLLG90PVkrWSxsdD1RK1EsaXQ9SypydCxudD1LKm90LGF0PUsqbHQsZHQ9WSpvdCxndD1ZKmx0LHV0PVEqbHQsbXQ9ZXQqcnQsUHQ9ZXQqb3QseHQ9ZXQqbHQsTXQ9elswXSxFdD16WzFdLE90PXpbMl07cmV0dXJuIG1bMF09KDEtKGR0K3V0KSkqTXQsbVsxXT0obnQreHQpKk10LG1bMl09KGF0LVB0KSpNdCxtWzNdPTAsbVs0XT0obnQteHQpKkV0LG1bNV09KDEtKGl0K3V0KSkqRXQsbVs2XT0oZ3QrbXQpKkV0LG1bN109MCxtWzhdPShhdCtQdCkqT3QsbVs5XT0oZ3QtbXQpKk90LG1bMTBdPSgxLShpdCtkdCkpKk90LG1bMTFdPTAsbVsxMl09TlswXSxtWzEzXT1OWzFdLG1bMTRdPU5bMl0sbVsxNV09MSxtfWZ1bmN0aW9uIEgobSxULE4seixLKXt2YXIgWT1UWzBdLFE9VFsxXSxldD1UWzJdLHJ0PVRbM10sb3Q9WStZLGx0PVErUSxpdD1ldCtldCxudD1ZKm90LGF0PVkqbHQsZHQ9WSppdCxndD1RKmx0LHV0PVEqaXQsbXQ9ZXQqaXQsUHQ9cnQqb3QseHQ9cnQqbHQsTXQ9cnQqaXQsRXQ9elswXSxPdD16WzFdLFV0PXpbMl0sQnQ9S1swXSxXdD1LWzFdLEZ0PUtbMl0senQ9KDEtKGd0K210KSkqRXQsJHQ9KGF0K010KSpFdCx3dD0oZHQteHQpKkV0LEN0PShhdC1NdCkqT3QsSHQ9KDEtKG50K210KSkqT3QsdWU9KHV0K1B0KSpPdCxoZT0oZHQreHQpKlV0LGVuPSh1dC1QdCkqVXQscm49KDEtKG50K2d0KSkqVXQ7cmV0dXJuIG1bMF09enQsbVsxXT0kdCxtWzJdPXd0LG1bM109MCxtWzRdPUN0LG1bNV09SHQsbVs2XT11ZSxtWzddPTAsbVs4XT1oZSxtWzldPWVuLG1bMTBdPXJuLG1bMTFdPTAsbVsxMl09TlswXStCdC0oenQqQnQrQ3QqV3QraGUqRnQpLG1bMTNdPU5bMV0rV3QtKCR0KkJ0K0h0Kld0K2VuKkZ0KSxtWzE0XT1OWzJdK0Z0LSh3dCpCdCt1ZSpXdCtybipGdCksbVsxNV09MSxtfWZ1bmN0aW9uIFoobSxUKXt2YXIgTj1UWzBdLHo9VFsxXSxLPVRbMl0sWT1UWzNdLFE9TitOLGV0PXoreixydD1LK0ssb3Q9TipRLGx0PXoqUSxpdD16KmV0LG50PUsqUSxhdD1LKmV0LGR0PUsqcnQsZ3Q9WSpRLHV0PVkqZXQsbXQ9WSpydDtyZXR1cm4gbVswXT0xLWl0LWR0LG1bMV09bHQrbXQsbVsyXT1udC11dCxtWzNdPTAsbVs0XT1sdC1tdCxtWzVdPTEtb3QtZHQsbVs2XT1hdCtndCxtWzddPTAsbVs4XT1udCt1dCxtWzldPWF0LWd0LG1bMTBdPTEtb3QtaXQsbVsxMV09MCxtWzEyXT0wLG1bMTNdPTAsbVsxNF09MCxtWzE1XT0xLG19ZnVuY3Rpb24gcShtLFQsTix6LEssWSxRKXt2YXIgZXQ9MS8oTi1UKSxydD0xLyhLLXopLG90PTEvKFktUSk7cmV0dXJuIG1bMF09WSoyKmV0LG1bMV09MCxtWzJdPTAsbVszXT0wLG1bNF09MCxtWzVdPVkqMipydCxtWzZdPTAsbVs3XT0wLG1bOF09KE4rVCkqZXQsbVs5XT0oSyt6KSpydCxtWzEwXT0oUStZKSpvdCxtWzExXT0tMSxtWzEyXT0wLG1bMTNdPTAsbVsxNF09USpZKjIqb3QsbVsxNV09MCxtfWZ1bmN0aW9uIFUobSxULE4seixLKXt2YXIgWT0xL01hdGgudGFuKFQvMiksUTtyZXR1cm4gbVswXT1ZL04sbVsxXT0wLG1bMl09MCxtWzNdPTAsbVs0XT0wLG1bNV09WSxtWzZdPTAsbVs3XT0wLG1bOF09MCxtWzldPTAsbVsxMV09LTEsbVsxMl09MCxtWzEzXT0wLG1bMTVdPTAsSyE9bnVsbCYmSyE9PTEvMD8oUT0xLyh6LUspLG1bMTBdPShLK3opKlEsbVsxNF09MipLKnoqUSk6KG1bMTBdPS0xLG1bMTRdPS0yKnopLG19ZnVuY3Rpb24gRyhtLFQsTix6KXt2YXIgSz1NYXRoLnRhbihULnVwRGVncmVlcypNYXRoLlBJLzE4MCksWT1NYXRoLnRhbihULmRvd25EZWdyZWVzKk1hdGguUEkvMTgwKSxRPU1hdGgudGFuKFQubGVmdERlZ3JlZXMqTWF0aC5QSS8xODApLGV0PU1hdGgudGFuKFQucmlnaHREZWdyZWVzKk1hdGguUEkvMTgwKSxydD0yLyhRK2V0KSxvdD0yLyhLK1kpO3JldHVybiBtWzBdPXJ0LG1bMV09MCxtWzJdPTAsbVszXT0wLG1bNF09MCxtWzVdPW90LG1bNl09MCxtWzddPTAsbVs4XT0tKChRLWV0KSpydCouNSksbVs5XT0oSy1ZKSpvdCouNSxtWzEwXT16LyhOLXopLG1bMTFdPS0xLG1bMTJdPTAsbVsxM109MCxtWzE0XT16Kk4vKE4teiksbVsxNV09MCxtfWZ1bmN0aW9uIEoobSxULE4seixLLFksUSl7dmFyIGV0PTEvKFQtTikscnQ9MS8oei1LKSxvdD0xLyhZLVEpO3JldHVybiBtWzBdPS0yKmV0LG1bMV09MCxtWzJdPTAsbVszXT0wLG1bNF09MCxtWzVdPS0yKnJ0LG1bNl09MCxtWzddPTAsbVs4XT0wLG1bOV09MCxtWzEwXT0yKm90LG1bMTFdPTAsbVsxMl09KFQrTikqZXQsbVsxM109KEsreikqcnQsbVsxNF09KFErWSkqb3QsbVsxNV09MSxtfWZ1bmN0aW9uIHR0KG0sVCxOLHope3ZhciBLLFksUSxldCxydCxvdCxsdCxpdCxudCxhdCxkdD1UWzBdLGd0PVRbMV0sdXQ9VFsyXSxtdD16WzBdLFB0PXpbMV0seHQ9elsyXSxNdD1OWzBdLEV0PU5bMV0sT3Q9TlsyXTtyZXR1cm4gTWF0aC5hYnMoZHQtTXQpPHIuRVBTSUxPTiYmTWF0aC5hYnMoZ3QtRXQpPHIuRVBTSUxPTiYmTWF0aC5hYnModXQtT3QpPHIuRVBTSUxPTj9jKG0pOihsdD1kdC1NdCxpdD1ndC1FdCxudD11dC1PdCxhdD0xL01hdGguaHlwb3QobHQsaXQsbnQpLGx0Kj1hdCxpdCo9YXQsbnQqPWF0LEs9UHQqbnQteHQqaXQsWT14dCpsdC1tdCpudCxRPW10Kml0LVB0Kmx0LGF0PU1hdGguaHlwb3QoSyxZLFEpLGF0PyhhdD0xL2F0LEsqPWF0LFkqPWF0LFEqPWF0KTooSz0wLFk9MCxRPTApLGV0PWl0KlEtbnQqWSxydD1udCpLLWx0KlEsb3Q9bHQqWS1pdCpLLGF0PU1hdGguaHlwb3QoZXQscnQsb3QpLGF0PyhhdD0xL2F0LGV0Kj1hdCxydCo9YXQsb3QqPWF0KTooZXQ9MCxydD0wLG90PTApLG1bMF09SyxtWzFdPWV0LG1bMl09bHQsbVszXT0wLG1bNF09WSxtWzVdPXJ0LG1bNl09aXQsbVs3XT0wLG1bOF09USxtWzldPW90LG1bMTBdPW50LG1bMTFdPTAsbVsxMl09LShLKmR0K1kqZ3QrUSp1dCksbVsxM109LShldCpkdCtydCpndCtvdCp1dCksbVsxNF09LShsdCpkdCtpdCpndCtudCp1dCksbVsxNV09MSxtKX1mdW5jdGlvbiBfKG0sVCxOLHope3ZhciBLPVRbMF0sWT1UWzFdLFE9VFsyXSxldD16WzBdLHJ0PXpbMV0sb3Q9elsyXSxsdD1LLU5bMF0saXQ9WS1OWzFdLG50PVEtTlsyXSxhdD1sdCpsdCtpdCppdCtudCpudDthdD4wJiYoYXQ9MS9NYXRoLnNxcnQoYXQpLGx0Kj1hdCxpdCo9YXQsbnQqPWF0KTt2YXIgZHQ9cnQqbnQtb3QqaXQsZ3Q9b3QqbHQtZXQqbnQsdXQ9ZXQqaXQtcnQqbHQ7cmV0dXJuIGF0PWR0KmR0K2d0Kmd0K3V0KnV0LGF0PjAmJihhdD0xL01hdGguc3FydChhdCksZHQqPWF0LGd0Kj1hdCx1dCo9YXQpLG1bMF09ZHQsbVsxXT1ndCxtWzJdPXV0LG1bM109MCxtWzRdPWl0KnV0LW50Kmd0LG1bNV09bnQqZHQtbHQqdXQsbVs2XT1sdCpndC1pdCpkdCxtWzddPTAsbVs4XT1sdCxtWzldPWl0LG1bMTBdPW50LG1bMTFdPTAsbVsxMl09SyxtWzEzXT1ZLG1bMTRdPVEsbVsxNV09MSxtfWZ1bmN0aW9uIHN0KG0pe3JldHVybiJtYXQ0KCIrbVswXSsiLCAiK21bMV0rIiwgIittWzJdKyIsICIrbVszXSsiLCAiK21bNF0rIiwgIittWzVdKyIsICIrbVs2XSsiLCAiK21bN10rIiwgIittWzhdKyIsICIrbVs5XSsiLCAiK21bMTBdKyIsICIrbVsxMV0rIiwgIittWzEyXSsiLCAiK21bMTNdKyIsICIrbVsxNF0rIiwgIittWzE1XSsiKSJ9ZnVuY3Rpb24gayhtKXtyZXR1cm4gTWF0aC5oeXBvdChtWzBdLG1bMV0sbVsyXSxtWzNdLG1bNF0sbVs1XSxtWzZdLG1bN10sbVs4XSxtWzldLG1bMTBdLG1bMTFdLG1bMTJdLG1bMTNdLG1bMTRdLG1bMTVdKX1mdW5jdGlvbiBodChtLFQsTil7cmV0dXJuIG1bMF09VFswXStOWzBdLG1bMV09VFsxXStOWzFdLG1bMl09VFsyXStOWzJdLG1bM109VFszXStOWzNdLG1bNF09VFs0XStOWzRdLG1bNV09VFs1XStOWzVdLG1bNl09VFs2XStOWzZdLG1bN109VFs3XStOWzddLG1bOF09VFs4XStOWzhdLG1bOV09VFs5XStOWzldLG1bMTBdPVRbMTBdK05bMTBdLG1bMTFdPVRbMTFdK05bMTFdLG1bMTJdPVRbMTJdK05bMTJdLG1bMTNdPVRbMTNdK05bMTNdLG1bMTRdPVRbMTRdK05bMTRdLG1bMTVdPVRbMTVdK05bMTVdLG19ZnVuY3Rpb24gZnQobSxULE4pe3JldHVybiBtWzBdPVRbMF0tTlswXSxtWzFdPVRbMV0tTlsxXSxtWzJdPVRbMl0tTlsyXSxtWzNdPVRbM10tTlszXSxtWzRdPVRbNF0tTls0XSxtWzVdPVRbNV0tTls1XSxtWzZdPVRbNl0tTls2XSxtWzddPVRbN10tTls3XSxtWzhdPVRbOF0tTls4XSxtWzldPVRbOV0tTls5XSxtWzEwXT1UWzEwXS1OWzEwXSxtWzExXT1UWzExXS1OWzExXSxtWzEyXT1UWzEyXS1OWzEyXSxtWzEzXT1UWzEzXS1OWzEzXSxtWzE0XT1UWzE0XS1OWzE0XSxtWzE1XT1UWzE1XS1OWzE1XSxtfWZ1bmN0aW9uIFcobSxULE4pe3JldHVybiBtWzBdPVRbMF0qTixtWzFdPVRbMV0qTixtWzJdPVRbMl0qTixtWzNdPVRbM10qTixtWzRdPVRbNF0qTixtWzVdPVRbNV0qTixtWzZdPVRbNl0qTixtWzddPVRbN10qTixtWzhdPVRbOF0qTixtWzldPVRbOV0qTixtWzEwXT1UWzEwXSpOLG1bMTFdPVRbMTFdKk4sbVsxMl09VFsxMl0qTixtWzEzXT1UWzEzXSpOLG1bMTRdPVRbMTRdKk4sbVsxNV09VFsxNV0qTixtfWZ1bmN0aW9uIEYobSxULE4seil7cmV0dXJuIG1bMF09VFswXStOWzBdKnosbVsxXT1UWzFdK05bMV0qeixtWzJdPVRbMl0rTlsyXSp6LG1bM109VFszXStOWzNdKnosbVs0XT1UWzRdK05bNF0qeixtWzVdPVRbNV0rTls1XSp6LG1bNl09VFs2XStOWzZdKnosbVs3XT1UWzddK05bN10qeixtWzhdPVRbOF0rTls4XSp6LG1bOV09VFs5XStOWzldKnosbVsxMF09VFsxMF0rTlsxMF0qeixtWzExXT1UWzExXStOWzExXSp6LG1bMTJdPVRbMTJdK05bMTJdKnosbVsxM109VFsxM10rTlsxM10qeixtWzE0XT1UWzE0XStOWzE0XSp6LG1bMTVdPVRbMTVdK05bMTVdKnosbX1mdW5jdGlvbiBWKG0sVCl7cmV0dXJuIG1bMF09PT1UWzBdJiZtWzFdPT09VFsxXSYmbVsyXT09PVRbMl0mJm1bM109PT1UWzNdJiZtWzRdPT09VFs0XSYmbVs1XT09PVRbNV0mJm1bNl09PT1UWzZdJiZtWzddPT09VFs3XSYmbVs4XT09PVRbOF0mJm1bOV09PT1UWzldJiZtWzEwXT09PVRbMTBdJiZtWzExXT09PVRbMTFdJiZtWzEyXT09PVRbMTJdJiZtWzEzXT09PVRbMTNdJiZtWzE0XT09PVRbMTRdJiZtWzE1XT09PVRbMTVdfWZ1bmN0aW9uIFgobSxUKXt2YXIgTj1tWzBdLHo9bVsxXSxLPW1bMl0sWT1tWzNdLFE9bVs0XSxldD1tWzVdLHJ0PW1bNl0sb3Q9bVs3XSxsdD1tWzhdLGl0PW1bOV0sbnQ9bVsxMF0sYXQ9bVsxMV0sZHQ9bVsxMl0sZ3Q9bVsxM10sdXQ9bVsxNF0sbXQ9bVsxNV0sUHQ9VFswXSx4dD1UWzFdLE10PVRbMl0sRXQ9VFszXSxPdD1UWzRdLFV0PVRbNV0sQnQ9VFs2XSxXdD1UWzddLEZ0PVRbOF0senQ9VFs5XSwkdD1UWzEwXSx3dD1UWzExXSxDdD1UWzEyXSxIdD1UWzEzXSx1ZT1UWzE0XSxoZT1UWzE1XTtyZXR1cm4gTWF0aC5hYnMoTi1QdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKFB0KSkmJk1hdGguYWJzKHoteHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh6KSxNYXRoLmFicyh4dCkpJiZNYXRoLmFicyhLLU10KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSyksTWF0aC5hYnMoTXQpKSYmTWF0aC5hYnMoWS1FdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFkpLE1hdGguYWJzKEV0KSkmJk1hdGguYWJzKFEtT3QpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhRKSxNYXRoLmFicyhPdCkpJiZNYXRoLmFicyhldC1VdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGV0KSxNYXRoLmFicyhVdCkpJiZNYXRoLmFicyhydC1CdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHJ0KSxNYXRoLmFicyhCdCkpJiZNYXRoLmFicyhvdC1XdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG90KSxNYXRoLmFicyhXdCkpJiZNYXRoLmFicyhsdC1GdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGx0KSxNYXRoLmFicyhGdCkpJiZNYXRoLmFicyhpdC16dCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGl0KSxNYXRoLmFicyh6dCkpJiZNYXRoLmFicyhudC0kdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG50KSxNYXRoLmFicygkdCkpJiZNYXRoLmFicyhhdC13dCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGF0KSxNYXRoLmFicyh3dCkpJiZNYXRoLmFicyhkdC1DdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGR0KSxNYXRoLmFicyhDdCkpJiZNYXRoLmFicyhndC1IdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGd0KSxNYXRoLmFicyhIdCkpJiZNYXRoLmFicyh1dC11ZSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHV0KSxNYXRoLmFicyh1ZSkpJiZNYXRoLmFicyhtdC1oZSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG10KSxNYXRoLmFicyhoZSkpfXZhciBqPWIsJD1mdH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInNldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJnZXRBeGlzQW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZ2V0QW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiY2FsY3VsYXRlVyIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJleHAiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwibG4iLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwicG93IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNsZXJwIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiY29uanVnYXRlIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb21NYXQzIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImZyb21FdWxlciIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gWn0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsInJvdGF0aW9uVG8iLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsInNxbGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gZnR9KSx0LmQoZSwic2V0QXhlcyIsZnVuY3Rpb24oKXtyZXR1cm4gV30pO3ZhciByPXQoMiksbj10KDUpLGQ9dCg4KSxnPXQoOSk7ZnVuY3Rpb24gdSgpe3ZhciBGPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoRlswXT0wLEZbMV09MCxGWzJdPTApLEZbM109MSxGfWZ1bmN0aW9uIG8oRil7cmV0dXJuIEZbMF09MCxGWzFdPTAsRlsyXT0wLEZbM109MSxGfWZ1bmN0aW9uIGMoRixWLFgpe1g9WCouNTt2YXIgaj1NYXRoLnNpbihYKTtyZXR1cm4gRlswXT1qKlZbMF0sRlsxXT1qKlZbMV0sRlsyXT1qKlZbMl0sRlszXT1NYXRoLmNvcyhYKSxGfWZ1bmN0aW9uIHAoRixWKXt2YXIgWD1NYXRoLmFjb3MoVlszXSkqMixqPU1hdGguc2luKFgvMik7cmV0dXJuIGo+ci5FUFNJTE9OPyhGWzBdPVZbMF0vaixGWzFdPVZbMV0vaixGWzJdPVZbMl0vaik6KEZbMF09MSxGWzFdPTAsRlsyXT0wKSxYfWZ1bmN0aW9uIGwoRixWKXt2YXIgWD1aKEYsVik7cmV0dXJuIE1hdGguYWNvcygyKlgqWC0xKX1mdW5jdGlvbiB5KEYsVixYKXt2YXIgaj1WWzBdLCQ9VlsxXSxtPVZbMl0sVD1WWzNdLE49WFswXSx6PVhbMV0sSz1YWzJdLFk9WFszXTtyZXR1cm4gRlswXT1qKlkrVCpOKyQqSy1tKnosRlsxXT0kKlkrVCp6K20qTi1qKkssRlsyXT1tKlkrVCpLK2oqei0kKk4sRlszXT1UKlktaipOLSQqei1tKkssRn1mdW5jdGlvbiB4KEYsVixYKXtYKj0uNTt2YXIgaj1WWzBdLCQ9VlsxXSxtPVZbMl0sVD1WWzNdLE49TWF0aC5zaW4oWCksej1NYXRoLmNvcyhYKTtyZXR1cm4gRlswXT1qKnorVCpOLEZbMV09JCp6K20qTixGWzJdPW0qei0kKk4sRlszXT1UKnotaipOLEZ9ZnVuY3Rpb24gYihGLFYsWCl7WCo9LjU7dmFyIGo9VlswXSwkPVZbMV0sbT1WWzJdLFQ9VlszXSxOPU1hdGguc2luKFgpLHo9TWF0aC5jb3MoWCk7cmV0dXJuIEZbMF09aip6LW0qTixGWzFdPSQqeitUKk4sRlsyXT1tKnoraipOLEZbM109VCp6LSQqTixGfWZ1bmN0aW9uIEUoRixWLFgpe1gqPS41O3ZhciBqPVZbMF0sJD1WWzFdLG09VlsyXSxUPVZbM10sTj1NYXRoLnNpbihYKSx6PU1hdGguY29zKFgpO3JldHVybiBGWzBdPWoqeiskKk4sRlsxXT0kKnotaipOLEZbMl09bSp6K1QqTixGWzNdPVQqei1tKk4sRn1mdW5jdGlvbiB2KEYsVil7dmFyIFg9VlswXSxqPVZbMV0sJD1WWzJdO3JldHVybiBGWzBdPVgsRlsxXT1qLEZbMl09JCxGWzNdPU1hdGguc3FydChNYXRoLmFicygxLVgqWC1qKmotJCokKSksRn1mdW5jdGlvbiBNKEYsVil7dmFyIFg9VlswXSxqPVZbMV0sJD1WWzJdLG09VlszXSxUPU1hdGguc3FydChYKlgraipqKyQqJCksTj1NYXRoLmV4cChtKSx6PVQ+MD9OKk1hdGguc2luKFQpL1Q6MDtyZXR1cm4gRlswXT1YKnosRlsxXT1qKnosRlsyXT0kKnosRlszXT1OKk1hdGguY29zKFQpLEZ9ZnVuY3Rpb24gaShGLFYpe3ZhciBYPVZbMF0saj1WWzFdLCQ9VlsyXSxtPVZbM10sVD1NYXRoLnNxcnQoWCpYK2oqaiskKiQpLE49VD4wP01hdGguYXRhbjIoVCxtKS9UOjA7cmV0dXJuIEZbMF09WCpOLEZbMV09aipOLEZbMl09JCpOLEZbM109LjUqTWF0aC5sb2coWCpYK2oqaiskKiQrbSptKSxGfWZ1bmN0aW9uIGEoRixWLFgpe3JldHVybiBpKEYsViksSChGLEYsWCksTShGLEYpLEZ9ZnVuY3Rpb24gcyhGLFYsWCxqKXt2YXIgJD1WWzBdLG09VlsxXSxUPVZbMl0sTj1WWzNdLHo9WFswXSxLPVhbMV0sWT1YWzJdLFE9WFszXSxldCxydCxvdCxsdCxpdDtyZXR1cm4gcnQ9JCp6K20qSytUKlkrTipRLHJ0PDAmJihydD0tcnQsej0teixLPS1LLFk9LVksUT0tUSksMS1ydD5yLkVQU0lMT04/KGV0PU1hdGguYWNvcyhydCksb3Q9TWF0aC5zaW4oZXQpLGx0PU1hdGguc2luKCgxLWopKmV0KS9vdCxpdD1NYXRoLnNpbihqKmV0KS9vdCk6KGx0PTEtaixpdD1qKSxGWzBdPWx0KiQraXQqeixGWzFdPWx0Km0raXQqSyxGWzJdPWx0KlQraXQqWSxGWzNdPWx0Kk4raXQqUSxGfWZ1bmN0aW9uIGYoRil7dmFyIFY9ci5SQU5ET00oKSxYPXIuUkFORE9NKCksaj1yLlJBTkRPTSgpLCQ9TWF0aC5zcXJ0KDEtViksbT1NYXRoLnNxcnQoVik7cmV0dXJuIEZbMF09JCpNYXRoLnNpbigyKk1hdGguUEkqWCksRlsxXT0kKk1hdGguY29zKDIqTWF0aC5QSSpYKSxGWzJdPW0qTWF0aC5zaW4oMipNYXRoLlBJKmopLEZbM109bSpNYXRoLmNvcygyKk1hdGguUEkqaiksRn1mdW5jdGlvbiBPKEYsVil7dmFyIFg9VlswXSxqPVZbMV0sJD1WWzJdLG09VlszXSxUPVgqWCtqKmorJCokK20qbSxOPVQ/MS9UOjA7cmV0dXJuIEZbMF09LVgqTixGWzFdPS1qKk4sRlsyXT0tJCpOLEZbM109bSpOLEZ9ZnVuY3Rpb24gQShGLFYpe3JldHVybiBGWzBdPS1WWzBdLEZbMV09LVZbMV0sRlsyXT0tVlsyXSxGWzNdPVZbM10sRn1mdW5jdGlvbiBSKEYsVil7dmFyIFg9VlswXStWWzRdK1ZbOF0sajtpZihYPjApaj1NYXRoLnNxcnQoWCsxKSxGWzNdPS41Kmosaj0uNS9qLEZbMF09KFZbNV0tVls3XSkqaixGWzFdPShWWzZdLVZbMl0pKmosRlsyXT0oVlsxXS1WWzNdKSpqO2Vsc2V7dmFyICQ9MDtWWzRdPlZbMF0mJigkPTEpLFZbOF0+VlskKjMrJF0mJigkPTIpO3ZhciBtPSgkKzEpJTMsVD0oJCsyKSUzO2o9TWF0aC5zcXJ0KFZbJCozKyRdLVZbbSozK21dLVZbVCozK1RdKzEpLEZbJF09LjUqaixqPS41L2osRlszXT0oVlttKjMrVF0tVltUKjMrbV0pKmosRlttXT0oVlttKjMrJF0rVlskKjMrbV0pKmosRltUXT0oVltUKjMrJF0rVlskKjMrVF0pKmp9cmV0dXJuIEZ9ZnVuY3Rpb24gSShGLFYsWCxqKXt2YXIgJD0uNSpNYXRoLlBJLzE4MDtWKj0kLFgqPSQsaio9JDt2YXIgbT1NYXRoLnNpbihWKSxUPU1hdGguY29zKFYpLE49TWF0aC5zaW4oWCksej1NYXRoLmNvcyhYKSxLPU1hdGguc2luKGopLFk9TWF0aC5jb3Moaik7cmV0dXJuIEZbMF09bSp6KlktVCpOKkssRlsxXT1UKk4qWSttKnoqSyxGWzJdPVQqeipLLW0qTipZLEZbM109VCp6KlkrbSpOKkssRn1mdW5jdGlvbiBQKEYpe3JldHVybiJxdWF0KCIrRlswXSsiLCAiK0ZbMV0rIiwgIitGWzJdKyIsICIrRlszXSsiKSJ9dmFyIEw9Zy5jbG9uZSxEPWcuZnJvbVZhbHVlcyxDPWcuY29weSxTPWcuc2V0LEI9Zy5hZGQsdz15LEg9Zy5zY2FsZSxaPWcuZG90LHE9Zy5sZXJwLFU9Zy5sZW5ndGgsRz1VLEo9Zy5zcXVhcmVkTGVuZ3RoLHR0PUosXz1nLm5vcm1hbGl6ZSxzdD1nLmV4YWN0RXF1YWxzLGs9Zy5lcXVhbHMsaHQ9ZnVuY3Rpb24oKXt2YXIgRj1kLmNyZWF0ZSgpLFY9ZC5mcm9tVmFsdWVzKDEsMCwwKSxYPWQuZnJvbVZhbHVlcygwLDEsMCk7cmV0dXJuIGZ1bmN0aW9uKGosJCxtKXt2YXIgVD1kLmRvdCgkLG0pO3JldHVybiBUPC0uOTk5OTk5PyhkLmNyb3NzKEYsViwkKSxkLmxlbihGKTwxZS02JiZkLmNyb3NzKEYsWCwkKSxkLm5vcm1hbGl6ZShGLEYpLGMoaixGLE1hdGguUEkpLGopOlQ+Ljk5OTk5OT8oalswXT0wLGpbMV09MCxqWzJdPTAsalszXT0xLGopOihkLmNyb3NzKEYsJCxtKSxqWzBdPUZbMF0salsxXT1GWzFdLGpbMl09RlsyXSxqWzNdPTErVCxfKGosaikpfX0oKSxmdD1mdW5jdGlvbigpe3ZhciBGPXUoKSxWPXUoKTtyZXR1cm4gZnVuY3Rpb24oWCxqLCQsbSxULE4pe3JldHVybiBzKEYsaixULE4pLHMoViwkLG0sTikscyhYLEYsViwyKk4qKDEtTikpLFh9fSgpLFc9ZnVuY3Rpb24oKXt2YXIgRj1uLmNyZWF0ZSgpO3JldHVybiBmdW5jdGlvbihWLFgsaiwkKXtyZXR1cm4gRlswXT1qWzBdLEZbM109alsxXSxGWzZdPWpbMl0sRlsxXT0kWzBdLEZbNF09JFsxXSxGWzddPSRbMl0sRlsyXT0tWFswXSxGWzVdPS1YWzFdLEZbOF09LVhbMl0sXyhWLFIoVixGKSl9fSgpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImhlcm1pdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiYmV6aWVyIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsInRyYW5zZm9ybU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwidHJhbnNmb3JtUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiAkfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgVD1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFRbMF09MCxUWzFdPTAsVFsyXT0wKSxUfWZ1bmN0aW9uIGQoVCl7dmFyIE49bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gTlswXT1UWzBdLE5bMV09VFsxXSxOWzJdPVRbMl0sTn1mdW5jdGlvbiBnKFQpe3ZhciBOPVRbMF0sej1UWzFdLEs9VFsyXTtyZXR1cm4gTWF0aC5oeXBvdChOLHosSyl9ZnVuY3Rpb24gdShULE4seil7dmFyIEs9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gS1swXT1ULEtbMV09TixLWzJdPXosS31mdW5jdGlvbiBvKFQsTil7cmV0dXJuIFRbMF09TlswXSxUWzFdPU5bMV0sVFsyXT1OWzJdLFR9ZnVuY3Rpb24gYyhULE4seixLKXtyZXR1cm4gVFswXT1OLFRbMV09eixUWzJdPUssVH1mdW5jdGlvbiBwKFQsTix6KXtyZXR1cm4gVFswXT1OWzBdK3pbMF0sVFsxXT1OWzFdK3pbMV0sVFsyXT1OWzJdK3pbMl0sVH1mdW5jdGlvbiBsKFQsTix6KXtyZXR1cm4gVFswXT1OWzBdLXpbMF0sVFsxXT1OWzFdLXpbMV0sVFsyXT1OWzJdLXpbMl0sVH1mdW5jdGlvbiB5KFQsTix6KXtyZXR1cm4gVFswXT1OWzBdKnpbMF0sVFsxXT1OWzFdKnpbMV0sVFsyXT1OWzJdKnpbMl0sVH1mdW5jdGlvbiB4KFQsTix6KXtyZXR1cm4gVFswXT1OWzBdL3pbMF0sVFsxXT1OWzFdL3pbMV0sVFsyXT1OWzJdL3pbMl0sVH1mdW5jdGlvbiBiKFQsTil7cmV0dXJuIFRbMF09TWF0aC5jZWlsKE5bMF0pLFRbMV09TWF0aC5jZWlsKE5bMV0pLFRbMl09TWF0aC5jZWlsKE5bMl0pLFR9ZnVuY3Rpb24gRShULE4pe3JldHVybiBUWzBdPU1hdGguZmxvb3IoTlswXSksVFsxXT1NYXRoLmZsb29yKE5bMV0pLFRbMl09TWF0aC5mbG9vcihOWzJdKSxUfWZ1bmN0aW9uIHYoVCxOLHope3JldHVybiBUWzBdPU1hdGgubWluKE5bMF0selswXSksVFsxXT1NYXRoLm1pbihOWzFdLHpbMV0pLFRbMl09TWF0aC5taW4oTlsyXSx6WzJdKSxUfWZ1bmN0aW9uIE0oVCxOLHope3JldHVybiBUWzBdPU1hdGgubWF4KE5bMF0selswXSksVFsxXT1NYXRoLm1heChOWzFdLHpbMV0pLFRbMl09TWF0aC5tYXgoTlsyXSx6WzJdKSxUfWZ1bmN0aW9uIGkoVCxOKXtyZXR1cm4gVFswXT1NYXRoLnJvdW5kKE5bMF0pLFRbMV09TWF0aC5yb3VuZChOWzFdKSxUWzJdPU1hdGgucm91bmQoTlsyXSksVH1mdW5jdGlvbiBhKFQsTix6KXtyZXR1cm4gVFswXT1OWzBdKnosVFsxXT1OWzFdKnosVFsyXT1OWzJdKnosVH1mdW5jdGlvbiBzKFQsTix6LEspe3JldHVybiBUWzBdPU5bMF0relswXSpLLFRbMV09TlsxXSt6WzFdKkssVFsyXT1OWzJdK3pbMl0qSyxUfWZ1bmN0aW9uIGYoVCxOKXt2YXIgej1OWzBdLVRbMF0sSz1OWzFdLVRbMV0sWT1OWzJdLVRbMl07cmV0dXJuIE1hdGguaHlwb3QoeixLLFkpfWZ1bmN0aW9uIE8oVCxOKXt2YXIgej1OWzBdLVRbMF0sSz1OWzFdLVRbMV0sWT1OWzJdLVRbMl07cmV0dXJuIHoqeitLKksrWSpZfWZ1bmN0aW9uIEEoVCl7dmFyIE49VFswXSx6PVRbMV0sSz1UWzJdO3JldHVybiBOKk4reip6K0sqS31mdW5jdGlvbiBSKFQsTil7cmV0dXJuIFRbMF09LU5bMF0sVFsxXT0tTlsxXSxUWzJdPS1OWzJdLFR9ZnVuY3Rpb24gSShULE4pe3JldHVybiBUWzBdPTEvTlswXSxUWzFdPTEvTlsxXSxUWzJdPTEvTlsyXSxUfWZ1bmN0aW9uIFAoVCxOKXt2YXIgej1OWzBdLEs9TlsxXSxZPU5bMl0sUT16KnorSypLK1kqWTtyZXR1cm4gUT4wJiYoUT0xL01hdGguc3FydChRKSksVFswXT1OWzBdKlEsVFsxXT1OWzFdKlEsVFsyXT1OWzJdKlEsVH1mdW5jdGlvbiBMKFQsTil7cmV0dXJuIFRbMF0qTlswXStUWzFdKk5bMV0rVFsyXSpOWzJdfWZ1bmN0aW9uIEQoVCxOLHope3ZhciBLPU5bMF0sWT1OWzFdLFE9TlsyXSxldD16WzBdLHJ0PXpbMV0sb3Q9elsyXTtyZXR1cm4gVFswXT1ZKm90LVEqcnQsVFsxXT1RKmV0LUsqb3QsVFsyXT1LKnJ0LVkqZXQsVH1mdW5jdGlvbiBDKFQsTix6LEspe3ZhciBZPU5bMF0sUT1OWzFdLGV0PU5bMl07cmV0dXJuIFRbMF09WStLKih6WzBdLVkpLFRbMV09UStLKih6WzFdLVEpLFRbMl09ZXQrSyooelsyXS1ldCksVH1mdW5jdGlvbiBTKFQsTix6LEssWSxRKXt2YXIgZXQ9USpRLHJ0PWV0KigyKlEtMykrMSxvdD1ldCooUS0yKStRLGx0PWV0KihRLTEpLGl0PWV0KigzLTIqUSk7cmV0dXJuIFRbMF09TlswXSpydCt6WzBdKm90K0tbMF0qbHQrWVswXSppdCxUWzFdPU5bMV0qcnQrelsxXSpvdCtLWzFdKmx0K1lbMV0qaXQsVFsyXT1OWzJdKnJ0K3pbMl0qb3QrS1syXSpsdCtZWzJdKml0LFR9ZnVuY3Rpb24gQihULE4seixLLFksUSl7dmFyIGV0PTEtUSxydD1ldCpldCxvdD1RKlEsbHQ9cnQqZXQsaXQ9MypRKnJ0LG50PTMqb3QqZXQsYXQ9b3QqUTtyZXR1cm4gVFswXT1OWzBdKmx0K3pbMF0qaXQrS1swXSpudCtZWzBdKmF0LFRbMV09TlsxXSpsdCt6WzFdKml0K0tbMV0qbnQrWVsxXSphdCxUWzJdPU5bMl0qbHQrelsyXSppdCtLWzJdKm50K1lbMl0qYXQsVH1mdW5jdGlvbiB3KFQsTil7Tj1OfHwxO3ZhciB6PXIuUkFORE9NKCkqMipNYXRoLlBJLEs9ci5SQU5ET00oKSoyLTEsWT1NYXRoLnNxcnQoMS1LKkspKk47cmV0dXJuIFRbMF09TWF0aC5jb3MoeikqWSxUWzFdPU1hdGguc2luKHopKlksVFsyXT1LKk4sVH1mdW5jdGlvbiBIKFQsTix6KXt2YXIgSz1OWzBdLFk9TlsxXSxRPU5bMl0sZXQ9elszXSpLK3pbN10qWSt6WzExXSpRK3pbMTVdO3JldHVybiBldD1ldHx8MSxUWzBdPSh6WzBdKksrels0XSpZK3pbOF0qUSt6WzEyXSkvZXQsVFsxXT0oelsxXSpLK3pbNV0qWSt6WzldKlErelsxM10pL2V0LFRbMl09KHpbMl0qSyt6WzZdKlkrelsxMF0qUSt6WzE0XSkvZXQsVH1mdW5jdGlvbiBaKFQsTix6KXt2YXIgSz1OWzBdLFk9TlsxXSxRPU5bMl07cmV0dXJuIFRbMF09Syp6WzBdK1kqelszXStRKnpbNl0sVFsxXT1LKnpbMV0rWSp6WzRdK1Eqels3XSxUWzJdPUsqelsyXStZKnpbNV0rUSp6WzhdLFR9ZnVuY3Rpb24gcShULE4seil7dmFyIEs9elswXSxZPXpbMV0sUT16WzJdLGV0PXpbM10scnQ9TlswXSxvdD1OWzFdLGx0PU5bMl0saXQ9WSpsdC1RKm90LG50PVEqcnQtSypsdCxhdD1LKm90LVkqcnQsZHQ9WSphdC1RKm50LGd0PVEqaXQtSyphdCx1dD1LKm50LVkqaXQsbXQ9ZXQqMjtyZXR1cm4gaXQqPW10LG50Kj1tdCxhdCo9bXQsZHQqPTIsZ3QqPTIsdXQqPTIsVFswXT1ydCtpdCtkdCxUWzFdPW90K250K2d0LFRbMl09bHQrYXQrdXQsVH1mdW5jdGlvbiBVKFQsTix6LEspe3ZhciBZPVtdLFE9W107cmV0dXJuIFlbMF09TlswXS16WzBdLFlbMV09TlsxXS16WzFdLFlbMl09TlsyXS16WzJdLFFbMF09WVswXSxRWzFdPVlbMV0qTWF0aC5jb3MoSyktWVsyXSpNYXRoLnNpbihLKSxRWzJdPVlbMV0qTWF0aC5zaW4oSykrWVsyXSpNYXRoLmNvcyhLKSxUWzBdPVFbMF0relswXSxUWzFdPVFbMV0relsxXSxUWzJdPVFbMl0relsyXSxUfWZ1bmN0aW9uIEcoVCxOLHosSyl7dmFyIFk9W10sUT1bXTtyZXR1cm4gWVswXT1OWzBdLXpbMF0sWVsxXT1OWzFdLXpbMV0sWVsyXT1OWzJdLXpbMl0sUVswXT1ZWzJdKk1hdGguc2luKEspK1lbMF0qTWF0aC5jb3MoSyksUVsxXT1ZWzFdLFFbMl09WVsyXSpNYXRoLmNvcyhLKS1ZWzBdKk1hdGguc2luKEspLFRbMF09UVswXSt6WzBdLFRbMV09UVsxXSt6WzFdLFRbMl09UVsyXSt6WzJdLFR9ZnVuY3Rpb24gSihULE4seixLKXt2YXIgWT1bXSxRPVtdO3JldHVybiBZWzBdPU5bMF0telswXSxZWzFdPU5bMV0telsxXSxZWzJdPU5bMl0telsyXSxRWzBdPVlbMF0qTWF0aC5jb3MoSyktWVsxXSpNYXRoLnNpbihLKSxRWzFdPVlbMF0qTWF0aC5zaW4oSykrWVsxXSpNYXRoLmNvcyhLKSxRWzJdPVlbMl0sVFswXT1RWzBdK3pbMF0sVFsxXT1RWzFdK3pbMV0sVFsyXT1RWzJdK3pbMl0sVH1mdW5jdGlvbiB0dChULE4pe3ZhciB6PVRbMF0sSz1UWzFdLFk9VFsyXSxRPU5bMF0sZXQ9TlsxXSxydD1OWzJdLG90PU1hdGguc3FydCh6KnorSypLK1kqWSksbHQ9TWF0aC5zcXJ0KFEqUStldCpldCtydCpydCksaXQ9b3QqbHQsbnQ9aXQmJkwoVCxOKS9pdDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KG50LC0xKSwxKSl9ZnVuY3Rpb24gXyhUKXtyZXR1cm4gVFswXT0wLFRbMV09MCxUWzJdPTAsVH1mdW5jdGlvbiBzdChUKXtyZXR1cm4idmVjMygiK1RbMF0rIiwgIitUWzFdKyIsICIrVFsyXSsiKSJ9ZnVuY3Rpb24gayhULE4pe3JldHVybiBUWzBdPT09TlswXSYmVFsxXT09PU5bMV0mJlRbMl09PT1OWzJdfWZ1bmN0aW9uIGh0KFQsTil7dmFyIHo9VFswXSxLPVRbMV0sWT1UWzJdLFE9TlswXSxldD1OWzFdLHJ0PU5bMl07cmV0dXJuIE1hdGguYWJzKHotUSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKFEpKSYmTWF0aC5hYnMoSy1ldCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEspLE1hdGguYWJzKGV0KSkmJk1hdGguYWJzKFktcnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhZKSxNYXRoLmFicyhydCkpfXZhciBmdD1sLFc9eSxGPXgsVj1mLFg9TyxqPWcsJD1BLG09ZnVuY3Rpb24oKXt2YXIgVD1uKCk7cmV0dXJuIGZ1bmN0aW9uKE4seixLLFksUSxldCl7dmFyIHJ0LG90O2Zvcih6fHwoej0zKSxLfHwoSz0wKSxZP290PU1hdGgubWluKFkqeitLLE4ubGVuZ3RoKTpvdD1OLmxlbmd0aCxydD1LO3J0PG90O3J0Kz16KVRbMF09TltydF0sVFsxXT1OW3J0KzFdLFRbMl09TltydCsyXSxRKFQsVCxldCksTltydF09VFswXSxOW3J0KzFdPVRbMV0sTltydCsyXT1UWzJdO3JldHVybiBOfX0oKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwidHJhbnNmb3JtTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImRpdiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBodH0pLHQuZChlLCJmb3JFYWNoIixmdW5jdGlvbigpe3JldHVybiBmdH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gbigpe3ZhciBXPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoV1swXT0wLFdbMV09MCxXWzJdPTAsV1szXT0wKSxXfWZ1bmN0aW9uIGQoVyl7dmFyIEY9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gRlswXT1XWzBdLEZbMV09V1sxXSxGWzJdPVdbMl0sRlszXT1XWzNdLEZ9ZnVuY3Rpb24gZyhXLEYsVixYKXt2YXIgaj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBqWzBdPVcsalsxXT1GLGpbMl09VixqWzNdPVgsan1mdW5jdGlvbiB1KFcsRil7cmV0dXJuIFdbMF09RlswXSxXWzFdPUZbMV0sV1syXT1GWzJdLFdbM109RlszXSxXfWZ1bmN0aW9uIG8oVyxGLFYsWCxqKXtyZXR1cm4gV1swXT1GLFdbMV09VixXWzJdPVgsV1szXT1qLFd9ZnVuY3Rpb24gYyhXLEYsVil7cmV0dXJuIFdbMF09RlswXStWWzBdLFdbMV09RlsxXStWWzFdLFdbMl09RlsyXStWWzJdLFdbM109RlszXStWWzNdLFd9ZnVuY3Rpb24gcChXLEYsVil7cmV0dXJuIFdbMF09RlswXS1WWzBdLFdbMV09RlsxXS1WWzFdLFdbMl09RlsyXS1WWzJdLFdbM109RlszXS1WWzNdLFd9ZnVuY3Rpb24gbChXLEYsVil7cmV0dXJuIFdbMF09RlswXSpWWzBdLFdbMV09RlsxXSpWWzFdLFdbMl09RlsyXSpWWzJdLFdbM109RlszXSpWWzNdLFd9ZnVuY3Rpb24geShXLEYsVil7cmV0dXJuIFdbMF09RlswXS9WWzBdLFdbMV09RlsxXS9WWzFdLFdbMl09RlsyXS9WWzJdLFdbM109RlszXS9WWzNdLFd9ZnVuY3Rpb24geChXLEYpe3JldHVybiBXWzBdPU1hdGguY2VpbChGWzBdKSxXWzFdPU1hdGguY2VpbChGWzFdKSxXWzJdPU1hdGguY2VpbChGWzJdKSxXWzNdPU1hdGguY2VpbChGWzNdKSxXfWZ1bmN0aW9uIGIoVyxGKXtyZXR1cm4gV1swXT1NYXRoLmZsb29yKEZbMF0pLFdbMV09TWF0aC5mbG9vcihGWzFdKSxXWzJdPU1hdGguZmxvb3IoRlsyXSksV1szXT1NYXRoLmZsb29yKEZbM10pLFd9ZnVuY3Rpb24gRShXLEYsVil7cmV0dXJuIFdbMF09TWF0aC5taW4oRlswXSxWWzBdKSxXWzFdPU1hdGgubWluKEZbMV0sVlsxXSksV1syXT1NYXRoLm1pbihGWzJdLFZbMl0pLFdbM109TWF0aC5taW4oRlszXSxWWzNdKSxXfWZ1bmN0aW9uIHYoVyxGLFYpe3JldHVybiBXWzBdPU1hdGgubWF4KEZbMF0sVlswXSksV1sxXT1NYXRoLm1heChGWzFdLFZbMV0pLFdbMl09TWF0aC5tYXgoRlsyXSxWWzJdKSxXWzNdPU1hdGgubWF4KEZbM10sVlszXSksV31mdW5jdGlvbiBNKFcsRil7cmV0dXJuIFdbMF09TWF0aC5yb3VuZChGWzBdKSxXWzFdPU1hdGgucm91bmQoRlsxXSksV1syXT1NYXRoLnJvdW5kKEZbMl0pLFdbM109TWF0aC5yb3VuZChGWzNdKSxXfWZ1bmN0aW9uIGkoVyxGLFYpe3JldHVybiBXWzBdPUZbMF0qVixXWzFdPUZbMV0qVixXWzJdPUZbMl0qVixXWzNdPUZbM10qVixXfWZ1bmN0aW9uIGEoVyxGLFYsWCl7cmV0dXJuIFdbMF09RlswXStWWzBdKlgsV1sxXT1GWzFdK1ZbMV0qWCxXWzJdPUZbMl0rVlsyXSpYLFdbM109RlszXStWWzNdKlgsV31mdW5jdGlvbiBzKFcsRil7dmFyIFY9RlswXS1XWzBdLFg9RlsxXS1XWzFdLGo9RlsyXS1XWzJdLCQ9RlszXS1XWzNdO3JldHVybiBNYXRoLmh5cG90KFYsWCxqLCQpfWZ1bmN0aW9uIGYoVyxGKXt2YXIgVj1GWzBdLVdbMF0sWD1GWzFdLVdbMV0saj1GWzJdLVdbMl0sJD1GWzNdLVdbM107cmV0dXJuIFYqVitYKlgraipqKyQqJH1mdW5jdGlvbiBPKFcpe3ZhciBGPVdbMF0sVj1XWzFdLFg9V1syXSxqPVdbM107cmV0dXJuIE1hdGguaHlwb3QoRixWLFgsail9ZnVuY3Rpb24gQShXKXt2YXIgRj1XWzBdLFY9V1sxXSxYPVdbMl0saj1XWzNdO3JldHVybiBGKkYrVipWK1gqWCtqKmp9ZnVuY3Rpb24gUihXLEYpe3JldHVybiBXWzBdPS1GWzBdLFdbMV09LUZbMV0sV1syXT0tRlsyXSxXWzNdPS1GWzNdLFd9ZnVuY3Rpb24gSShXLEYpe3JldHVybiBXWzBdPTEvRlswXSxXWzFdPTEvRlsxXSxXWzJdPTEvRlsyXSxXWzNdPTEvRlszXSxXfWZ1bmN0aW9uIFAoVyxGKXt2YXIgVj1GWzBdLFg9RlsxXSxqPUZbMl0sJD1GWzNdLG09VipWK1gqWCtqKmorJCokO3JldHVybiBtPjAmJihtPTEvTWF0aC5zcXJ0KG0pKSxXWzBdPVYqbSxXWzFdPVgqbSxXWzJdPWoqbSxXWzNdPSQqbSxXfWZ1bmN0aW9uIEwoVyxGKXtyZXR1cm4gV1swXSpGWzBdK1dbMV0qRlsxXStXWzJdKkZbMl0rV1szXSpGWzNdfWZ1bmN0aW9uIEQoVyxGLFYsWCl7dmFyIGo9VlswXSpYWzFdLVZbMV0qWFswXSwkPVZbMF0qWFsyXS1WWzJdKlhbMF0sbT1WWzBdKlhbM10tVlszXSpYWzBdLFQ9VlsxXSpYWzJdLVZbMl0qWFsxXSxOPVZbMV0qWFszXS1WWzNdKlhbMV0sej1WWzJdKlhbM10tVlszXSpYWzJdLEs9RlswXSxZPUZbMV0sUT1GWzJdLGV0PUZbM107cmV0dXJuIFdbMF09WSp6LVEqTitldCpULFdbMV09LShLKnopK1EqbS1ldCokLFdbMl09SypOLVkqbStldCpqLFdbM109LShLKlQpK1kqJC1RKmosV31mdW5jdGlvbiBDKFcsRixWLFgpe3ZhciBqPUZbMF0sJD1GWzFdLG09RlsyXSxUPUZbM107cmV0dXJuIFdbMF09aitYKihWWzBdLWopLFdbMV09JCtYKihWWzFdLSQpLFdbMl09bStYKihWWzJdLW0pLFdbM109VCtYKihWWzNdLVQpLFd9ZnVuY3Rpb24gUyhXLEYpe0Y9Rnx8MTt2YXIgVixYLGosJCxtLFQ7ZG8gVj1yLlJBTkRPTSgpKjItMSxYPXIuUkFORE9NKCkqMi0xLG09VipWK1gqWDt3aGlsZShtPj0xKTtkbyBqPXIuUkFORE9NKCkqMi0xLCQ9ci5SQU5ET00oKSoyLTEsVD1qKmorJCokO3doaWxlKFQ+PTEpO3ZhciBOPU1hdGguc3FydCgoMS1tKS9UKTtyZXR1cm4gV1swXT1GKlYsV1sxXT1GKlgsV1syXT1GKmoqTixXWzNdPUYqJCpOLFd9ZnVuY3Rpb24gQihXLEYsVil7dmFyIFg9RlswXSxqPUZbMV0sJD1GWzJdLG09RlszXTtyZXR1cm4gV1swXT1WWzBdKlgrVls0XSpqK1ZbOF0qJCtWWzEyXSptLFdbMV09VlsxXSpYK1ZbNV0qaitWWzldKiQrVlsxM10qbSxXWzJdPVZbMl0qWCtWWzZdKmorVlsxMF0qJCtWWzE0XSptLFdbM109VlszXSpYK1ZbN10qaitWWzExXSokK1ZbMTVdKm0sV31mdW5jdGlvbiB3KFcsRixWKXt2YXIgWD1GWzBdLGo9RlsxXSwkPUZbMl0sbT1WWzBdLFQ9VlsxXSxOPVZbMl0sej1WWzNdLEs9eipYK1QqJC1OKmosWT16KmorTipYLW0qJCxRPXoqJCttKmotVCpYLGV0PS1tKlgtVCpqLU4qJDtyZXR1cm4gV1swXT1LKnorZXQqLW0rWSotTi1RKi1ULFdbMV09WSp6K2V0Ki1UK1EqLW0tSyotTixXWzJdPVEqeitldCotTitLKi1ULVkqLW0sV1szXT1GWzNdLFd9ZnVuY3Rpb24gSChXKXtyZXR1cm4gV1swXT0wLFdbMV09MCxXWzJdPTAsV1szXT0wLFd9ZnVuY3Rpb24gWihXKXtyZXR1cm4idmVjNCgiK1dbMF0rIiwgIitXWzFdKyIsICIrV1syXSsiLCAiK1dbM10rIikifWZ1bmN0aW9uIHEoVyxGKXtyZXR1cm4gV1swXT09PUZbMF0mJldbMV09PT1GWzFdJiZXWzJdPT09RlsyXSYmV1szXT09PUZbM119ZnVuY3Rpb24gVShXLEYpe3ZhciBWPVdbMF0sWD1XWzFdLGo9V1syXSwkPVdbM10sbT1GWzBdLFQ9RlsxXSxOPUZbMl0sej1GWzNdO3JldHVybiBNYXRoLmFicyhWLW0pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhWKSxNYXRoLmFicyhtKSkmJk1hdGguYWJzKFgtVCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFgpLE1hdGguYWJzKFQpKSYmTWF0aC5hYnMoai1OKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaiksTWF0aC5hYnMoTikpJiZNYXRoLmFicygkLXopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyh6KSl9dmFyIEc9cCxKPWwsdHQ9eSxfPXMsc3Q9ZixrPU8saHQ9QSxmdD1mdW5jdGlvbigpe3ZhciBXPW4oKTtyZXR1cm4gZnVuY3Rpb24oRixWLFgsaiwkLG0pe3ZhciBULE47Zm9yKFZ8fChWPTQpLFh8fChYPTApLGo/Tj1NYXRoLm1pbihqKlYrWCxGLmxlbmd0aCk6Tj1GLmxlbmd0aCxUPVg7VDxOO1QrPVYpV1swXT1GW1RdLFdbMV09RltUKzFdLFdbMl09RltUKzJdLFdbM109RltUKzNdLCQoVyxXLG0pLEZbVF09V1swXSxGW1QrMV09V1sxXSxGW1QrMl09V1syXSxGW1QrM109V1szXTtyZXR1cm4gRn19KCl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZ2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJnZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInNldFJlYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2V0RHVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwicm90YXRlQnlRdWF0QXBwZW5kIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInJvdGF0ZUJ5UXVhdFByZXBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwicm90YXRlQXJvdW5kQXhpcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGh0fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gZnR9KTt2YXIgcj10KDIpLG49dCg3KSxkPXQoNik7ZnVuY3Rpb24gZygpe3ZhciBXPW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoV1swXT0wLFdbMV09MCxXWzJdPTAsV1s0XT0wLFdbNV09MCxXWzZdPTAsV1s3XT0wKSxXWzNdPTEsV31mdW5jdGlvbiB1KFcpe3ZhciBGPW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIEZbMF09V1swXSxGWzFdPVdbMV0sRlsyXT1XWzJdLEZbM109V1szXSxGWzRdPVdbNF0sRls1XT1XWzVdLEZbNl09V1s2XSxGWzddPVdbN10sRn1mdW5jdGlvbiBvKFcsRixWLFgsaiwkLG0sVCl7dmFyIE49bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gTlswXT1XLE5bMV09RixOWzJdPVYsTlszXT1YLE5bNF09aixOWzVdPSQsTls2XT1tLE5bN109VCxOfWZ1bmN0aW9uIGMoVyxGLFYsWCxqLCQsbSl7dmFyIFQ9bmV3IHIuQVJSQVlfVFlQRSg4KTtUWzBdPVcsVFsxXT1GLFRbMl09VixUWzNdPVg7dmFyIE49aiouNSx6PSQqLjUsSz1tKi41O3JldHVybiBUWzRdPU4qWCt6KlYtSypGLFRbNV09eipYK0sqVy1OKlYsVFs2XT1LKlgrTipGLXoqVyxUWzddPS1OKlcteipGLUsqVixUfWZ1bmN0aW9uIHAoVyxGLFYpe3ZhciBYPVZbMF0qLjUsaj1WWzFdKi41LCQ9VlsyXSouNSxtPUZbMF0sVD1GWzFdLE49RlsyXSx6PUZbM107cmV0dXJuIFdbMF09bSxXWzFdPVQsV1syXT1OLFdbM109eixXWzRdPVgqeitqKk4tJCpULFdbNV09aip6KyQqbS1YKk4sV1s2XT0kKnorWCpULWoqbSxXWzddPS1YKm0taipULSQqTixXfWZ1bmN0aW9uIGwoVyxGKXtyZXR1cm4gV1swXT0wLFdbMV09MCxXWzJdPTAsV1szXT0xLFdbNF09RlswXSouNSxXWzVdPUZbMV0qLjUsV1s2XT1GWzJdKi41LFdbN109MCxXfWZ1bmN0aW9uIHkoVyxGKXtyZXR1cm4gV1swXT1GWzBdLFdbMV09RlsxXSxXWzJdPUZbMl0sV1szXT1GWzNdLFdbNF09MCxXWzVdPTAsV1s2XT0wLFdbN109MCxXfWZ1bmN0aW9uIHgoVyxGKXt2YXIgVj1uLmNyZWF0ZSgpO2QuZ2V0Um90YXRpb24oVixGKTt2YXIgWD1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBkLmdldFRyYW5zbGF0aW9uKFgsRikscChXLFYsWCksV31mdW5jdGlvbiBiKFcsRil7cmV0dXJuIFdbMF09RlswXSxXWzFdPUZbMV0sV1syXT1GWzJdLFdbM109RlszXSxXWzRdPUZbNF0sV1s1XT1GWzVdLFdbNl09Rls2XSxXWzddPUZbN10sV31mdW5jdGlvbiBFKFcpe3JldHVybiBXWzBdPTAsV1sxXT0wLFdbMl09MCxXWzNdPTEsV1s0XT0wLFdbNV09MCxXWzZdPTAsV1s3XT0wLFd9ZnVuY3Rpb24gdihXLEYsVixYLGosJCxtLFQsTil7cmV0dXJuIFdbMF09RixXWzFdPVYsV1syXT1YLFdbM109aixXWzRdPSQsV1s1XT1tLFdbNl09VCxXWzddPU4sV312YXIgTT1uLmNvcHk7ZnVuY3Rpb24gaShXLEYpe3JldHVybiBXWzBdPUZbNF0sV1sxXT1GWzVdLFdbMl09Rls2XSxXWzNdPUZbN10sV312YXIgYT1uLmNvcHk7ZnVuY3Rpb24gcyhXLEYpe3JldHVybiBXWzRdPUZbMF0sV1s1XT1GWzFdLFdbNl09RlsyXSxXWzddPUZbM10sV31mdW5jdGlvbiBmKFcsRil7dmFyIFY9Rls0XSxYPUZbNV0saj1GWzZdLCQ9Rls3XSxtPS1GWzBdLFQ9LUZbMV0sTj0tRlsyXSx6PUZbM107cmV0dXJuIFdbMF09KFYqeiskKm0rWCpOLWoqVCkqMixXWzFdPShYKnorJCpUK2oqbS1WKk4pKjIsV1syXT0oaip6KyQqTitWKlQtWCptKSoyLFd9ZnVuY3Rpb24gTyhXLEYsVil7dmFyIFg9RlswXSxqPUZbMV0sJD1GWzJdLG09RlszXSxUPVZbMF0qLjUsTj1WWzFdKi41LHo9VlsyXSouNSxLPUZbNF0sWT1GWzVdLFE9Rls2XSxldD1GWzddO3JldHVybiBXWzBdPVgsV1sxXT1qLFdbMl09JCxXWzNdPW0sV1s0XT1tKlQraip6LSQqTitLLFdbNV09bSpOKyQqVC1YKnorWSxXWzZdPW0qeitYKk4taipUK1EsV1s3XT0tWCpULWoqTi0kKnorZXQsV31mdW5jdGlvbiBBKFcsRixWKXt2YXIgWD0tRlswXSxqPS1GWzFdLCQ9LUZbMl0sbT1GWzNdLFQ9Rls0XSxOPUZbNV0sej1GWzZdLEs9Rls3XSxZPVQqbStLKlgrTiokLXoqaixRPU4qbStLKmoreipYLVQqJCxldD16Km0rSyokK1Qqai1OKlgscnQ9SyptLVQqWC1OKmoteiokO3JldHVybiBuLnJvdGF0ZVgoVyxGLFYpLFg9V1swXSxqPVdbMV0sJD1XWzJdLG09V1szXSxXWzRdPVkqbStydCpYK1EqJC1ldCpqLFdbNV09USptK3J0KmorZXQqWC1ZKiQsV1s2XT1ldCptK3J0KiQrWSpqLVEqWCxXWzddPXJ0Km0tWSpYLVEqai1ldCokLFd9ZnVuY3Rpb24gUihXLEYsVil7dmFyIFg9LUZbMF0saj0tRlsxXSwkPS1GWzJdLG09RlszXSxUPUZbNF0sTj1GWzVdLHo9Rls2XSxLPUZbN10sWT1UKm0rSypYK04qJC16KmosUT1OKm0rSypqK3oqWC1UKiQsZXQ9eiptK0sqJCtUKmotTipYLHJ0PUsqbS1UKlgtTipqLXoqJDtyZXR1cm4gbi5yb3RhdGVZKFcsRixWKSxYPVdbMF0saj1XWzFdLCQ9V1syXSxtPVdbM10sV1s0XT1ZKm0rcnQqWCtRKiQtZXQqaixXWzVdPVEqbStydCpqK2V0KlgtWSokLFdbNl09ZXQqbStydCokK1kqai1RKlgsV1s3XT1ydCptLVkqWC1RKmotZXQqJCxXfWZ1bmN0aW9uIEkoVyxGLFYpe3ZhciBYPS1GWzBdLGo9LUZbMV0sJD0tRlsyXSxtPUZbM10sVD1GWzRdLE49Rls1XSx6PUZbNl0sSz1GWzddLFk9VCptK0sqWCtOKiQteipqLFE9TiptK0sqait6KlgtVCokLGV0PXoqbStLKiQrVCpqLU4qWCxydD1LKm0tVCpYLU4qai16KiQ7cmV0dXJuIG4ucm90YXRlWihXLEYsViksWD1XWzBdLGo9V1sxXSwkPVdbMl0sbT1XWzNdLFdbNF09WSptK3J0KlgrUSokLWV0KmosV1s1XT1RKm0rcnQqaitldCpYLVkqJCxXWzZdPWV0Km0rcnQqJCtZKmotUSpYLFdbN109cnQqbS1ZKlgtUSpqLWV0KiQsV31mdW5jdGlvbiBQKFcsRixWKXt2YXIgWD1WWzBdLGo9VlsxXSwkPVZbMl0sbT1WWzNdLFQ9RlswXSxOPUZbMV0sej1GWzJdLEs9RlszXTtyZXR1cm4gV1swXT1UKm0rSypYK04qJC16KmosV1sxXT1OKm0rSypqK3oqWC1UKiQsV1syXT16Km0rSyokK1Qqai1OKlgsV1szXT1LKm0tVCpYLU4qai16KiQsVD1GWzRdLE49Rls1XSx6PUZbNl0sSz1GWzddLFdbNF09VCptK0sqWCtOKiQteipqLFdbNV09TiptK0sqait6KlgtVCokLFdbNl09eiptK0sqJCtUKmotTipYLFdbN109SyptLVQqWC1OKmoteiokLFd9ZnVuY3Rpb24gTChXLEYsVil7dmFyIFg9RlswXSxqPUZbMV0sJD1GWzJdLG09RlszXSxUPVZbMF0sTj1WWzFdLHo9VlsyXSxLPVZbM107cmV0dXJuIFdbMF09WCpLK20qVCtqKnotJCpOLFdbMV09aipLK20qTiskKlQtWCp6LFdbMl09JCpLK20qeitYKk4taipULFdbM109bSpLLVgqVC1qKk4tJCp6LFQ9Vls0XSxOPVZbNV0sej1WWzZdLEs9Vls3XSxXWzRdPVgqSyttKlQraip6LSQqTixXWzVdPWoqSyttKk4rJCpULVgqeixXWzZdPSQqSyttKnorWCpOLWoqVCxXWzddPW0qSy1YKlQtaipOLSQqeixXfWZ1bmN0aW9uIEQoVyxGLFYsWCl7aWYoTWF0aC5hYnMoWCk8ci5FUFNJTE9OKXJldHVybiBiKFcsRik7dmFyIGo9TWF0aC5oeXBvdChWWzBdLFZbMV0sVlsyXSk7WD1YKi41O3ZhciAkPU1hdGguc2luKFgpLG09JCpWWzBdL2osVD0kKlZbMV0vaixOPSQqVlsyXS9qLHo9TWF0aC5jb3MoWCksSz1GWzBdLFk9RlsxXSxRPUZbMl0sZXQ9RlszXTtXWzBdPUsqeitldCptK1kqTi1RKlQsV1sxXT1ZKnorZXQqVCtRKm0tSypOLFdbMl09USp6K2V0Kk4rSypULVkqbSxXWzNdPWV0KnotSyptLVkqVC1RKk47dmFyIHJ0PUZbNF0sb3Q9Rls1XSxsdD1GWzZdLGl0PUZbN107cmV0dXJuIFdbNF09cnQqeitpdCptK290Kk4tbHQqVCxXWzVdPW90KnoraXQqVCtsdCptLXJ0Kk4sV1s2XT1sdCp6K2l0Kk4rcnQqVC1vdCptLFdbN109aXQqei1ydCptLW90KlQtbHQqTixXfWZ1bmN0aW9uIEMoVyxGLFYpe3JldHVybiBXWzBdPUZbMF0rVlswXSxXWzFdPUZbMV0rVlsxXSxXWzJdPUZbMl0rVlsyXSxXWzNdPUZbM10rVlszXSxXWzRdPUZbNF0rVls0XSxXWzVdPUZbNV0rVls1XSxXWzZdPUZbNl0rVls2XSxXWzddPUZbN10rVls3XSxXfWZ1bmN0aW9uIFMoVyxGLFYpe3ZhciBYPUZbMF0saj1GWzFdLCQ9RlsyXSxtPUZbM10sVD1WWzRdLE49Vls1XSx6PVZbNl0sSz1WWzddLFk9Rls0XSxRPUZbNV0sZXQ9Rls2XSxydD1GWzddLG90PVZbMF0sbHQ9VlsxXSxpdD1WWzJdLG50PVZbM107cmV0dXJuIFdbMF09WCpudCttKm90K2oqaXQtJCpsdCxXWzFdPWoqbnQrbSpsdCskKm90LVgqaXQsV1syXT0kKm50K20qaXQrWCpsdC1qKm90LFdbM109bSpudC1YKm90LWoqbHQtJCppdCxXWzRdPVgqSyttKlQraip6LSQqTitZKm50K3J0Km90K1EqaXQtZXQqbHQsV1s1XT1qKksrbSpOKyQqVC1YKnorUSpudCtydCpsdCtldCpvdC1ZKml0LFdbNl09JCpLK20qeitYKk4taipUK2V0Km50K3J0Kml0K1kqbHQtUSpvdCxXWzddPW0qSy1YKlQtaipOLSQqeitydCpudC1ZKm90LVEqbHQtZXQqaXQsV312YXIgQj1TO2Z1bmN0aW9uIHcoVyxGLFYpe3JldHVybiBXWzBdPUZbMF0qVixXWzFdPUZbMV0qVixXWzJdPUZbMl0qVixXWzNdPUZbM10qVixXWzRdPUZbNF0qVixXWzVdPUZbNV0qVixXWzZdPUZbNl0qVixXWzddPUZbN10qVixXfXZhciBIPW4uZG90O2Z1bmN0aW9uIFooVyxGLFYsWCl7dmFyIGo9MS1YO3JldHVybiBIKEYsVik8MCYmKFg9LVgpLFdbMF09RlswXSpqK1ZbMF0qWCxXWzFdPUZbMV0qaitWWzFdKlgsV1syXT1GWzJdKmorVlsyXSpYLFdbM109RlszXSpqK1ZbM10qWCxXWzRdPUZbNF0qaitWWzRdKlgsV1s1XT1GWzVdKmorVls1XSpYLFdbNl09Rls2XSpqK1ZbNl0qWCxXWzddPUZbN10qaitWWzddKlgsV31mdW5jdGlvbiBxKFcsRil7dmFyIFY9dHQoRik7cmV0dXJuIFdbMF09LUZbMF0vVixXWzFdPS1GWzFdL1YsV1syXT0tRlsyXS9WLFdbM109RlszXS9WLFdbNF09LUZbNF0vVixXWzVdPS1GWzVdL1YsV1s2XT0tRls2XS9WLFdbN109Rls3XS9WLFd9ZnVuY3Rpb24gVShXLEYpe3JldHVybiBXWzBdPS1GWzBdLFdbMV09LUZbMV0sV1syXT0tRlsyXSxXWzNdPUZbM10sV1s0XT0tRls0XSxXWzVdPS1GWzVdLFdbNl09LUZbNl0sV1s3XT1GWzddLFd9dmFyIEc9bi5sZW5ndGgsSj1HLHR0PW4uc3F1YXJlZExlbmd0aCxfPXR0O2Z1bmN0aW9uIHN0KFcsRil7dmFyIFY9dHQoRik7aWYoVj4wKXtWPU1hdGguc3FydChWKTt2YXIgWD1GWzBdL1Ysaj1GWzFdL1YsJD1GWzJdL1YsbT1GWzNdL1YsVD1GWzRdLE49Rls1XSx6PUZbNl0sSz1GWzddLFk9WCpUK2oqTiskKnorbSpLO1dbMF09WCxXWzFdPWosV1syXT0kLFdbM109bSxXWzRdPShULVgqWSkvVixXWzVdPShOLWoqWSkvVixXWzZdPSh6LSQqWSkvVixXWzddPShLLW0qWSkvVn1yZXR1cm4gV31mdW5jdGlvbiBrKFcpe3JldHVybiJxdWF0MigiK1dbMF0rIiwgIitXWzFdKyIsICIrV1syXSsiLCAiK1dbM10rIiwgIitXWzRdKyIsICIrV1s1XSsiLCAiK1dbNl0rIiwgIitXWzddKyIpIn1mdW5jdGlvbiBodChXLEYpe3JldHVybiBXWzBdPT09RlswXSYmV1sxXT09PUZbMV0mJldbMl09PT1GWzJdJiZXWzNdPT09RlszXSYmV1s0XT09PUZbNF0mJldbNV09PT1GWzVdJiZXWzZdPT09Rls2XSYmV1s3XT09PUZbN119ZnVuY3Rpb24gZnQoVyxGKXt2YXIgVj1XWzBdLFg9V1sxXSxqPVdbMl0sJD1XWzNdLG09V1s0XSxUPVdbNV0sTj1XWzZdLHo9V1s3XSxLPUZbMF0sWT1GWzFdLFE9RlsyXSxldD1GWzNdLHJ0PUZbNF0sb3Q9Rls1XSxsdD1GWzZdLGl0PUZbN107cmV0dXJuIE1hdGguYWJzKFYtSyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKEspKSYmTWF0aC5hYnMoWC1ZKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMoWSkpJiZNYXRoLmFicyhqLVEpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhqKSxNYXRoLmFicyhRKSkmJk1hdGguYWJzKCQtZXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyhldCkpJiZNYXRoLmFicyhtLXJ0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobSksTWF0aC5hYnMocnQpKSYmTWF0aC5hYnMoVC1vdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFQpLE1hdGguYWJzKG90KSkmJk1hdGguYWJzKE4tbHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhOKSxNYXRoLmFicyhsdCkpJiZNYXRoLmFicyh6LWl0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeiksTWF0aC5hYnMoaXQpKX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJkaXZpZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY2VpbCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJmbG9vciIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibWF4IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInJvdW5kIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInNxdWFyZWREaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInRyYW5zZm9ybU1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwidHJhbnNmb3JtTWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gaHR9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIG4oKXt2YXIgaj1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKGpbMF09MCxqWzFdPTApLGp9ZnVuY3Rpb24gZChqKXt2YXIgJD1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiAkWzBdPWpbMF0sJFsxXT1qWzFdLCR9ZnVuY3Rpb24gZyhqLCQpe3ZhciBtPW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIG1bMF09aixtWzFdPSQsbX1mdW5jdGlvbiB1KGosJCl7cmV0dXJuIGpbMF09JFswXSxqWzFdPSRbMV0san1mdW5jdGlvbiBvKGosJCxtKXtyZXR1cm4galswXT0kLGpbMV09bSxqfWZ1bmN0aW9uIGMoaiwkLG0pe3JldHVybiBqWzBdPSRbMF0rbVswXSxqWzFdPSRbMV0rbVsxXSxqfWZ1bmN0aW9uIHAoaiwkLG0pe3JldHVybiBqWzBdPSRbMF0tbVswXSxqWzFdPSRbMV0tbVsxXSxqfWZ1bmN0aW9uIGwoaiwkLG0pe3JldHVybiBqWzBdPSRbMF0qbVswXSxqWzFdPSRbMV0qbVsxXSxqfWZ1bmN0aW9uIHkoaiwkLG0pe3JldHVybiBqWzBdPSRbMF0vbVswXSxqWzFdPSRbMV0vbVsxXSxqfWZ1bmN0aW9uIHgoaiwkKXtyZXR1cm4galswXT1NYXRoLmNlaWwoJFswXSksalsxXT1NYXRoLmNlaWwoJFsxXSksan1mdW5jdGlvbiBiKGosJCl7cmV0dXJuIGpbMF09TWF0aC5mbG9vcigkWzBdKSxqWzFdPU1hdGguZmxvb3IoJFsxXSksan1mdW5jdGlvbiBFKGosJCxtKXtyZXR1cm4galswXT1NYXRoLm1pbigkWzBdLG1bMF0pLGpbMV09TWF0aC5taW4oJFsxXSxtWzFdKSxqfWZ1bmN0aW9uIHYoaiwkLG0pe3JldHVybiBqWzBdPU1hdGgubWF4KCRbMF0sbVswXSksalsxXT1NYXRoLm1heCgkWzFdLG1bMV0pLGp9ZnVuY3Rpb24gTShqLCQpe3JldHVybiBqWzBdPU1hdGgucm91bmQoJFswXSksalsxXT1NYXRoLnJvdW5kKCRbMV0pLGp9ZnVuY3Rpb24gaShqLCQsbSl7cmV0dXJuIGpbMF09JFswXSptLGpbMV09JFsxXSptLGp9ZnVuY3Rpb24gYShqLCQsbSxUKXtyZXR1cm4galswXT0kWzBdK21bMF0qVCxqWzFdPSRbMV0rbVsxXSpULGp9ZnVuY3Rpb24gcyhqLCQpe3ZhciBtPSRbMF0talswXSxUPSRbMV0talsxXTtyZXR1cm4gTWF0aC5oeXBvdChtLFQpfWZ1bmN0aW9uIGYoaiwkKXt2YXIgbT0kWzBdLWpbMF0sVD0kWzFdLWpbMV07cmV0dXJuIG0qbStUKlR9ZnVuY3Rpb24gTyhqKXt2YXIgJD1qWzBdLG09alsxXTtyZXR1cm4gTWF0aC5oeXBvdCgkLG0pfWZ1bmN0aW9uIEEoail7dmFyICQ9alswXSxtPWpbMV07cmV0dXJuICQqJCttKm19ZnVuY3Rpb24gUihqLCQpe3JldHVybiBqWzBdPS0kWzBdLGpbMV09LSRbMV0san1mdW5jdGlvbiBJKGosJCl7cmV0dXJuIGpbMF09MS8kWzBdLGpbMV09MS8kWzFdLGp9ZnVuY3Rpb24gUChqLCQpe3ZhciBtPSRbMF0sVD0kWzFdLE49bSptK1QqVDtyZXR1cm4gTj4wJiYoTj0xL01hdGguc3FydChOKSksalswXT0kWzBdKk4salsxXT0kWzFdKk4san1mdW5jdGlvbiBMKGosJCl7cmV0dXJuIGpbMF0qJFswXStqWzFdKiRbMV19ZnVuY3Rpb24gRChqLCQsbSl7dmFyIFQ9JFswXSptWzFdLSRbMV0qbVswXTtyZXR1cm4galswXT1qWzFdPTAsalsyXT1ULGp9ZnVuY3Rpb24gQyhqLCQsbSxUKXt2YXIgTj0kWzBdLHo9JFsxXTtyZXR1cm4galswXT1OK1QqKG1bMF0tTiksalsxXT16K1QqKG1bMV0teiksan1mdW5jdGlvbiBTKGosJCl7JD0kfHwxO3ZhciBtPXIuUkFORE9NKCkqMipNYXRoLlBJO3JldHVybiBqWzBdPU1hdGguY29zKG0pKiQsalsxXT1NYXRoLnNpbihtKSokLGp9ZnVuY3Rpb24gQihqLCQsbSl7dmFyIFQ9JFswXSxOPSRbMV07cmV0dXJuIGpbMF09bVswXSpUK21bMl0qTixqWzFdPW1bMV0qVCttWzNdKk4san1mdW5jdGlvbiB3KGosJCxtKXt2YXIgVD0kWzBdLE49JFsxXTtyZXR1cm4galswXT1tWzBdKlQrbVsyXSpOK21bNF0salsxXT1tWzFdKlQrbVszXSpOK21bNV0san1mdW5jdGlvbiBIKGosJCxtKXt2YXIgVD0kWzBdLE49JFsxXTtyZXR1cm4galswXT1tWzBdKlQrbVszXSpOK21bNl0salsxXT1tWzFdKlQrbVs0XSpOK21bN10san1mdW5jdGlvbiBaKGosJCxtKXt2YXIgVD0kWzBdLE49JFsxXTtyZXR1cm4galswXT1tWzBdKlQrbVs0XSpOK21bMTJdLGpbMV09bVsxXSpUK21bNV0qTittWzEzXSxqfWZ1bmN0aW9uIHEoaiwkLG0sVCl7dmFyIE49JFswXS1tWzBdLHo9JFsxXS1tWzFdLEs9TWF0aC5zaW4oVCksWT1NYXRoLmNvcyhUKTtyZXR1cm4galswXT1OKlkteipLK21bMF0salsxXT1OKksreipZK21bMV0san1mdW5jdGlvbiBVKGosJCl7dmFyIG09alswXSxUPWpbMV0sTj0kWzBdLHo9JFsxXSxLPU1hdGguc3FydChtKm0rVCpUKSpNYXRoLnNxcnQoTipOK3oqeiksWT1LJiYobSpOK1QqeikvSztyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KFksLTEpLDEpKX1mdW5jdGlvbiBHKGope3JldHVybiBqWzBdPTAsalsxXT0wLGp9ZnVuY3Rpb24gSihqKXtyZXR1cm4idmVjMigiK2pbMF0rIiwgIitqWzFdKyIpIn1mdW5jdGlvbiB0dChqLCQpe3JldHVybiBqWzBdPT09JFswXSYmalsxXT09PSRbMV19ZnVuY3Rpb24gXyhqLCQpe3ZhciBtPWpbMF0sVD1qWzFdLE49JFswXSx6PSRbMV07cmV0dXJuIE1hdGguYWJzKG0tTik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG0pLE1hdGguYWJzKE4pKSYmTWF0aC5hYnMoVC16KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVCksTWF0aC5hYnMoeikpfXZhciBzdD1PLGs9cCxodD1sLGZ0PXksVz1zLEY9ZixWPUEsWD1mdW5jdGlvbigpe3ZhciBqPW4oKTtyZXR1cm4gZnVuY3Rpb24oJCxtLFQsTix6LEspe3ZhciBZLFE7Zm9yKG18fChtPTIpLFR8fChUPTApLE4/UT1NYXRoLm1pbihOKm0rVCwkLmxlbmd0aCk6UT0kLmxlbmd0aCxZPVQ7WTxRO1krPW0palswXT0kW1ldLGpbMV09JFtZKzFdLHooaixqLEspLCRbWV09alswXSwkW1krMV09alsxXTtyZXR1cm4gJH19KCl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMyk7dC5kKGUsIlJlbmRlcmVyIixmdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHR9KTt2YXIgbj10KDQwKTt0LmQoZSwiRmlndXJlMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH0pO3ZhciBkPXQoNTYpO3QuZChlLCJNZXNoMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVmYXVsdH0pO3ZhciBnPXQoMjkpO3QuZChlLCJNZXNoQ2xvdWQiLGZ1bmN0aW9uKCl7cmV0dXJuIGcuZGVmYXVsdH0pO3ZhciB1PXQoMjMpO3QuZChlLCJwYXJzZUZvbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVmYXVsdH0pO3ZhciBvPXQoMzEpO3QuZChlLCJwYXJzZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBvLmRlZmF1bHR9KTt2YXIgYz10KDIxKTt0LmQoZSwiRU5WIixmdW5jdGlvbigpe3JldHVybiBjLmRlZmF1bHR9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KTt2YXIgcj10KDE0KSxuPXQoMSksZD10KDIwKSxnPXQoMjcpLHU9dCgyNSksbz10KDQwKSxjPXQoNTYpLHA9dCgyOSksbD10KDU5KSx5PXQoMjEpLHg9dCg2Myk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGI9e2F1dG9VcGRhdGU6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGJ1ZmZlclNpemU6MTUwMH0sRT1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOyAgICAKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7ICAgICAgICAgICAgICAKfQpgLHY9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOwp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdlRleHR1cmVDb29yZC54eSk7Cn0KYCxNPVN5bWJvbCgiZ2xSZW5kZXJlciIpLGk9U3ltYm9sKCJjYW52YXNSZW5kZXJlciIpLGE9U3ltYm9sKCJvcHRpb25zIikscz1TeW1ib2woImdsb2JhbFRyYW5zZm9ybSIpLGY9U3ltYm9sKCJhcHBseUdsb2JhbFRyYW5zZm9ybSIpLE89U3ltYm9sKCJjYW52YXMiKTtmdW5jdGlvbiBBKFApe2NvbnN0IEw9UC5nbCxEPVAuZmJvO0QmJkwuYmluZEZyYW1lYnVmZmVyKEwuRlJBTUVCVUZGRVIsRCksUC5fZHJhdygpLEQmJkwuYmluZEZyYW1lYnVmZmVyKEwuRlJBTUVCVUZGRVIsbnVsbCl9ZnVuY3Rpb24gUihQLEwsRCxDKXtjb25zdCBTPVAuY3JlYXRlVGV4dHVyZShMLmNhbnZhcyksQj1bW1swLDBdLFtELDBdLFtELENdLFswLENdLFswLDBdXV07Qi5jbG9zZWQ9ITA7Y29uc3Qgdz1uZXcgYy5kZWZhdWx0KHtjb250b3VyczpCfSk7dy5zZXRUZXh0dXJlKFMpLFAuc2V0TWVzaERhdGEoW3cubWVzaERhdGFdKSxBKFApLFMuZGVsZXRlKCksTC5jbGVhclJlY3QoMCwwLEQsQyksZGVsZXRlIEwuX2ZpbHRlcn1jbGFzcyBJe2NvbnN0cnVjdG9yKEwsRD17fSl7bGV0IEM9RC5jb250ZXh0VHlwZTtpZihDfHwodHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Qz0id2ViZ2wyIjp0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0PT0iZnVuY3Rpb24iP0M9IndlYmdsIjpDPSIyZCIpLCFMLmdldENvbnRleHQpe2NvbnN0IFM9TDtMPXtnZXRDb250ZXh0KCl7cmV0dXJuIFN9LHdpZHRoOkQud2lkdGgsaGVpZ2h0OkQuaGVpZ2h0fSxTLmNhbnZhcz1MLEM9IjJkIn1pZih0aGlzW09dPUwsQyE9PSJ3ZWJnbCImJkMhPT0id2ViZ2wyIiYmQyE9PSIyZCIpdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbnRleHQgdHlwZSAke0N9YCk7aWYoRC5jb250ZXh0VHlwZT1DLHRoaXNbYV09T2JqZWN0LmFzc2lnbih7fSxiLEQpLEM9PT0id2ViZ2wifHxDPT09IndlYmdsMiIpe0M9PT0id2ViZ2wyIiYmKHRoaXNbYV0ud2ViZ2wyPSEwKTtjb25zdCBTPW5ldyByLmRlZmF1bHQoTCx0aGlzW2FdKTtDPT09IndlYmdsMiImJiFTLmlzV2ViR0wyJiYoRC5jb250ZXh0VHlwZT0id2ViZ2wiKSxPYmplY3QoeC5jcmVhdGVTaGFkZXJzKShTKSxPYmplY3QoeC5hcHBseVNoYWRlcikoUyksT2JqZWN0KHguY3JlYXRlQ2xvdWRTaGFkZXJzKShTKTtjb25zdCBCPVMuZ2w7Qi5jbGVhckNvbG9yKDAsMCwwLDApLEIuYmxlbmRGdW5jU2VwYXJhdGUoQi5TUkNfQUxQSEEsQi5PTkVfTUlOVVNfU1JDX0FMUEhBLEIuT05FLEIuT05FX01JTlVTX1NSQ19BTFBIQSksdGhpc1tNXT1TfWVsc2UgdGhpc1tpXT1uZXcgZC5kZWZhdWx0KEwsdGhpc1thXSk7dGhpc1tzXT1bMSwwLDAsMCwxLDAsMCwwLDFdLHRoaXMudXBkYXRlUmVzb2x1dGlvbigpfWdldCBjYW52YXMoKXtyZXR1cm4gdGhpc1tPXX1nZXQgY2FudmFzUmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tpXX1nZXQgZ2xSZW5kZXJlcigpe3JldHVybiB0aGlzW01dfWdldCBpc1dlYkdMMigpe3JldHVybiB0aGlzW01dJiZ0aGlzW01dLmlzV2ViR0wyfWdldCBvcHRpb25zKCl7cmV0dXJuIHRoaXNbYV19Z2V0IGdsb2JhbFRyYW5zZm9ybU1hdHJpeCgpe2NvbnN0IEw9dGhpc1tzXTtyZXR1cm5bTFswXSxMWzFdLExbM10sTFs0XSxMWzZdLExbN11dfWdldCB2aWV3TWF0cml4KCl7cmV0dXJuIHRoaXNbc119W2ZdKCl7Y29uc3QgTD10aGlzW01dfHx0aGlzW2ldO2lmKHRoaXNbTV0pe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OkN9PXRoaXMuY2FudmFzO0wudW5pZm9ybXMudmlld01hdHJpeD10aGlzLnZpZXdNYXRyaXgsTC51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4PXRoaXMucHJvamVjdGlvbk1hdHJpeCxMLnVuaWZvcm1zLnVfcmVzb2x1dGlvbj1bRCxDXX19dXBkYXRlUmVzb2x1dGlvbigpe2NvbnN0e3dpZHRoOkwsaGVpZ2h0OkR9PXRoaXMuY2FudmFzLEM9WzEsMCwwLDAsMSwwLC1MLzIsLUQvMiwxXSxTPVsyL0wsMCwwLDAsLTIvRCwwLDAsMCwxXSxCPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxDKTt0aGlzLnByb2plY3Rpb25NYXRyaXg9Qix0aGlzW01dJiZ0aGlzW01dLmdsLnZpZXdwb3J0KDAsMCxMLEQpfWNyZWF0ZVRleHR1cmUoTCxEKXtyZXR1cm4odGhpc1tNXXx8dGhpc1tpXSkuY3JlYXRlVGV4dHVyZShMLEQpfWxvYWRUZXh0dXJlKEwse3VzZUltYWdlQml0bWFwOkQ9ITF9PXt9KXtyZXR1cm4odGhpc1tNXXx8dGhpc1tpXSkubG9hZFRleHR1cmUoTCx7dXNlSW1hZ2VCaXRtYXA6RH0pfWNyZWF0ZVRleHQoTCx7Zm9udDpEPSIxNnB4IGFyaWFsIixmaWxsQ29sb3I6Qz1udWxsLHN0cm9rZUNvbG9yOlM9bnVsbCxzdHJva2VXaWR0aDpCPTF9PXt9KXtpZih0aGlzW01dKXtjb25zdCB3PXkuZGVmYXVsdC5jcmVhdGVUZXh0KEwse2ZvbnQ6RCxmaWxsQ29sb3I6QyxzdHJva2VDb2xvcjpTLHN0cm9rZVdpZHRoOkJ9KTtyZXR1cm57aW1hZ2U6dGhpcy5jcmVhdGVUZXh0dXJlKHcuaW1hZ2UpLHJlY3Q6dy5yZWN0fX1yZXR1cm57X2ltZzp7Zm9udDpELGZpbGxDb2xvcjpDLHN0cm9rZUNvbG9yOlMsc3Ryb2tlV2lkdGg6Qix0ZXh0Okx9fX1jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6TCxmcmFnbWVudDpELG9wdGlvbnM6Q309e30pe2lmKHRoaXNbTV0pe2NvbnN0IFM9dGhpc1tNXS5jb21waWxlU3luYyhELEwpO3JldHVybiBTLl9hdHRyaWJPcHRzPUMsU310aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IGNyZWF0ZSB3ZWJnbCBwcm9ncmFtLiIpfWNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6TD1FLGZyYWdtZW50OkQ9dixvcHRpb25zOkN9PXt9KXtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6TCxmcmFnbWVudDpELG9wdGlvbnM6Q30pfXVzZVByb2dyYW0oTCxEPXt9KXtpZih0aGlzW01dKXtjb25zdCBDPU9iamVjdC5hc3NpZ24oe30sTC5fYXR0cmliT3B0cyxEKTtyZXR1cm4gdGhpc1tNXS51c2VQcm9ncmFtKEwsQyl9dGhyb3cgbmV3IEVycm9yKCJDb250ZXh0IDJEIGNhbm5vdCB1c2Ugd2ViZ2wgcHJvZ3JhbS4iKX1kZWxldGVUZXh0dXJlKEwpe3JldHVybih0aGlzW01dfHx0aGlzW2ldKS5kZWxldGVUZXh0dXJlKEwpfWNsZWFyKC4uLkwpe2lmKHRoaXNbTV0pe2NvbnN0IEQ9dGhpc1tNXS5nbDtELmNsZWFyKEQuQ09MT1JfQlVGRkVSX0JJVCl9ZWxzZSB0aGlzW2ldLmNsZWFyKC4uLkwpfWRyYXdNZXNoQ2xvdWQoTCx7Y2xlYXI6RD0hMSxwcm9ncmFtOkM9bnVsbH09e30pe2NvbnN0IFM9dGhpc1tNXXx8dGhpc1tpXSxCPUN8fEwucHJvZ3JhbTtpZih0aGlzW01dKXtjb25zdCB3PVMuZ2w7aWYoRCYmdy5jbGVhcih3LkNPTE9SX0JVRkZFUl9CSVQpLEIpUy5wcm9ncmFtIT09QiYmdGhpcy51c2VQcm9ncmFtKEIse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSk7ZWxzZXtjb25zdCBIPUwubWVzaC5tZXNoRGF0YSxaPSEhSC51bmlmb3Jtcy51X3RleFNhbXBsZXIscT0hIUgudW5pZm9ybXMudV9maWx0ZXJGbGFnLFU9ISFILnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IsRz1MLmhhc0Nsb3VkQ29sb3IsSj1MLmhhc0Nsb3VkRmlsdGVyLHR0PSEhSC51bmlmb3Jtcy51X2NsaXBTYW1wbGVyO09iamVjdCh4LmFwcGx5Q2xvdWRTaGFkZXIpKFMse2hhc1RleHR1cmU6WixoYXNGaWx0ZXI6cSxoYXNHcmFkaWVudDpVLGhhc0Nsb3VkQ29sb3I6RyxoYXNDbG91ZEZpbHRlcjpKLGhhc0NsaXBQYXRoOnR0fSl9dGhpc1tmXSgpLFMuc2V0TWVzaERhdGEoW0wubWVzaERhdGFdKSxMLmJlZm9yZVJlbmRlciYmTC5iZWZvcmVSZW5kZXIodyxMKSxBKFMpLEwuYWZ0ZXJSZW5kZXImJkwuYWZ0ZXJSZW5kZXIodyxMKX1lbHNlIFMuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxTLmRyYXdNZXNoQ2xvdWQoTCx7Y2xlYXI6RCxob29rOiExfSl9ZHJhd01lc2hlcyhMLHtjbGVhcjpEPSExLHByb2dyYW06Qz1udWxsfT17fSl7Y29uc3QgUz10aGlzW01dfHx0aGlzW2ldO2lmKHRoaXNbTV0pe2NvbnN0IEI9Uy5mYm8sdz1PYmplY3QoZy5kZWZhdWx0KSh0aGlzLEwsQz09bnVsbCksSD1TLmdsO0QmJkguY2xlYXIoSC5DT0xPUl9CVUZGRVJfQklUKTtjb25zdCBaPSFPYmplY3QobC5pc1VuaXRUcmFuc2Zvcm0pKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KTt0aGlzLl9kcmF3Q2FsbHM9MDtmb3IoY29uc3QgcSBvZiB3KXt0aGlzLl9kcmF3Q2FsbHMrKztjb25zdCBVPUN8fHEucHJvZ3JhbTtpZihxIGluc3RhbmNlb2YgcC5kZWZhdWx0KXRoaXMuZHJhd01lc2hDbG91ZChxLHtjbGVhcjpELHByb2dyYW06VX0pO2Vsc2V7Y29uc3R7d2lkdGg6RyxoZWlnaHQ6Sn09dGhpcy5jYW52YXM7aWYocS5iZWZvcmVSZW5kZXImJnEuYmVmb3JlUmVuZGVyKEgscSkscS5wYXNzLmxlbmd0aCYmKCghdGhpcy5mYm98fHRoaXMuZmJvLndpZHRoIT09R3x8dGhpcy5mYm8uaGVpZ2h0IT09SikmJih0aGlzLmZibz17d2lkdGg6RyxoZWlnaHQ6Six0YXJnZXQ6Uy5jcmVhdGVGQk8oKSxidWZmZXI6Uy5jcmVhdGVGQk8oKSxzd2FwKCl7W3RoaXMudGFyZ2V0LHRoaXMuYnVmZmVyXT1bdGhpcy5idWZmZXIsdGhpcy50YXJnZXRdfX0pLFMuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSwhVSYmcS5maWx0ZXJDYW52YXMpe09iamVjdCh4LmFwcGx5U2hhZGVyKShTLHtoYXNUZXh0dXJlOiEwfSk7bGV0IHR0PXRoaXMuZmlsdGVyQ29udGV4dDt0dHx8KHR0PXkuZGVmYXVsdC5jcmVhdGVDYW52YXMoRyxKKS5nZXRDb250ZXh0KCIyZCIpLHRoaXMuZmlsdGVyQ29udGV4dD10dCk7Y29uc3QgXz1MW3EucGFja0luZGV4XSxzdD1fLmZpbHRlcixrPUxbcS5wYWNrSW5kZXgrMV0saHQ9TFtxLnBhY2tJbmRleC0xXTsoIWh0fHwhaHQuZmlsdGVyQ2FudmFzfHxodC5maWx0ZXIhPT1zdCkmJigha3x8IWsuZmlsdGVyQ2FudmFzfHxrLmZpbHRlciE9PXN0KT8oWj8odHQuc2F2ZSgpLE9iamVjdCh1LmRyYXdNZXNoMkQpKF8sdHQsITEpLHR0LnJlc3RvcmUoKSxPYmplY3QodS5hcHBseUZpbHRlcikodHQsc3QpKTpPYmplY3QodS5kcmF3TWVzaDJEKShfLHR0LCEwKSx0aGlzW2ZdKCksUihTLHR0LEcsSikpOihaJiZ0dC5zYXZlKCksT2JqZWN0KHUuZHJhd01lc2gyRCkoXyx0dCwhMSksWiYmdHQucmVzdG9yZSgpLCgha3x8IWsuZmlsdGVyQ2FudmFzfHxfLmZpbHRlciE9PWsuZmlsdGVyKSYmKE9iamVjdCh1LmFwcGx5RmlsdGVyKSh0dCxzdCksdGhpc1tmXSgpLFIoUyx0dCxHLEopKSl9ZWxzZXtpZihVKVMucHJvZ3JhbSE9PVUmJnRoaXMudXNlUHJvZ3JhbShVLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSk7ZWxzZXtjb25zdCB0dD0hIXEudW5pZm9ybXMudV90ZXhTYW1wbGVyLF89ISFxLnVuaWZvcm1zLnVfZmlsdGVyRmxhZyxzdD0hIXEudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3RvcixrPSEhcS51bmlmb3Jtcy51X2NsaXBTYW1wbGVyO09iamVjdCh4LmFwcGx5U2hhZGVyKShTLHtoYXNUZXh0dXJlOnR0LGhhc0ZpbHRlcjpfLGhhc0dyYWRpZW50OnN0LGhhc0NsaXBQYXRoOmt9KX1xLmZpbHRlckNhbnZhcyYmY29uc29sZS53YXJuKCJVc2VyIHByb2dyYW0gaWdub3JlZCBzb21lIGZpbHRlciBlZmZlY3RzLiIpLHRoaXNbZl0oKSxTLnNldE1lc2hEYXRhKFtxXSksQShTKX1pZihxLnBhc3MubGVuZ3RoKXtjb25zdCB0dD1xLnBhc3MubGVuZ3RoO3EucGFzcy5mb3JFYWNoKChfLHN0KT0+e18uYmxlbmQ9cS5lbmFibGVCbGVuZCxfLnNldFRleHR1cmUoUy5mYm8udGV4dHVyZSksc3Q9PT10dC0xP1MuYmluZEZCTyhCKToodGhpcy5mYm8uc3dhcCgpLFMuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSxfLnByb2dyYW0/Uy51c2VQcm9ncmFtKF8ucHJvZ3JhbSk6KHRoaXMuZGVmYXVsdFBhc3NQcm9ncmFtPXRoaXMuZGVmYXVsdFBhc3NQcm9ncmFtfHx0aGlzLmNyZWF0ZVBhc3NQcm9ncmFtKCksUy51c2VQcm9ncmFtKHRoaXMuZGVmYXVsdFBhc3NQcm9ncmFtKSksUy5zZXRNZXNoRGF0YShbXy5tZXNoRGF0YV0pLEguY2xlYXIoSC5DT0xPUl9CVUZGRVJfQklUKSxBKFMpfSl9cS5hZnRlclJlbmRlciYmcS5hZnRlclJlbmRlcihILHEpfX19ZWxzZSBTLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksUy5kcmF3TWVzaGVzKEwse2NsZWFyOkR9KX1kcmF3SW1hZ2UoTCwuLi5EKXtjb25zdCBDPUQubGVuZ3RoO2lmKEM8Mil0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiAzIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHtELmxlbmd0aCsxfSBwcmVzZW50LmApO2lmKEMhPT0yJiZDIT09NCYmQyE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ2RyYXdJbWFnZScgb24gJ1JlbmRlcmVyJzogVmFsaWQgYXJpdGllcyBhcmU6IFszLCA1LCA5XSwgYnV0ICR7RC5sZW5ndGgrMX0gYXJndW1lbnRzIHByb3ZpZGVkLmApO2xldCBTPW51bGwsQj1udWxsO0M9PT0yP1M9W0RbMF0sRFsxXSxMLndpZHRoLEwuaGVpZ2h0XTpDPT09ND9TPUQ6Qz09PTgmJihCPUQuc2xpY2UoMCw0KSxTPUQuc2xpY2UoNCkpO2NvbnN0IHc9dGhpcy5jcmVhdGVUZXh0dXJlKEwpLHt3aWR0aDpILGhlaWdodDpafT10aGlzLmNhbnZhcyxxPW5ldyBvLmRlZmF1bHQ7cS5yZWN0KFNbMF0sU1sxXSxILFopO2NvbnN0IFU9bmV3IGMuZGVmYXVsdChxLHt3aWR0aDpILGhlaWdodDpafSk7VS5zZXRUZXh0dXJlKHcse3JlY3Q6UyxzcmNSZWN0OkJ9KSx0aGlzLmRyYXdNZXNoZXMoW1VdKSx0aGlzLmRlbGV0ZVRleHR1cmUodyl9c2V0R2xvYmFsVHJhbnNmb3JtKC4uLkwpe3JldHVybiB0aGlzW3NdPVtMWzBdLExbMV0sMCxMWzJdLExbM10sMCxMWzRdLExbNV0sMV0sdGhpc31nbG9iYWxUcmFuc2Zvcm0oLi4uTCl7Y29uc3QgRD10aGlzW3NdO3JldHVybiB0aGlzW3NdPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksRCxMKSx0aGlzfWdsb2JhbFRyYW5zbGF0ZShMLEQpe2xldCBDPW4ubWF0My5jcmVhdGUoKTtyZXR1cm4gQz1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxDLFtMLERdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5DKX1nbG9iYWxSb3RhdGUoTCxbRCxDXT1bMCwwXSl7bGV0IFM9bi5tYXQzLmNyZWF0ZSgpO3JldHVybiBTPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFMsW0QsQ10pLFM9bi5tYXQzLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxMKSxTPW4ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFMsWy1ELC1DXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uUyl9Z2xvYmFsU2NhbGUoTCxEPUwsW0MsU109WzAsMF0pe2xldCBCPW4ubWF0My5jcmVhdGUoKTtyZXR1cm4gQj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFtDLFNdKSxCPW4ubWF0My5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQixbTCxEXSksQj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFstQywtU10pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLkIpfWdsb2JhbFNrZXcoTCxEPUwsW0MsU109WzAsMF0pe2xldCBCPW4ubWF0My5jcmVhdGUoKTtyZXR1cm4gQj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFtDLFNdKSxCPW4ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQixuLm1hdDMuZnJvbVZhbHVlcygxLE1hdGgudGFuKEQpLE1hdGgudGFuKEwpLDEsMCwwKSksQj1uLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFstQywtU10pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLkIpfXRyYW5zZm9ybVBvaW50KEwsRCxDKXtsZXQgUz10aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtDJiYoUz1uLm1hdDMubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFMsQykpO2NvbnN0IEI9TCpTWzBdK0QqU1syXStTWzRdLHc9TCpTWzFdK0QqU1szXStTWzVdO3JldHVybltCLHddfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCgxNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1yLmRlZmF1bHR9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDE2KSxuPXQoMTcpLGQ9dCgxOCksZz10KDE5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShiLEUsdil7cmV0dXJuIEUgaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixFLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltFXT12LGJ9Y29uc3Qgbz17fTtmdW5jdGlvbiBjKGIsRT0zKXtjb25zdCB2PVtdLE09Yi5sZW5ndGg7Zm9yKGxldCBpPTA7aTxNO2krKylpJUU8MiYmdi5wdXNoKC41KihiW2ldKzEpKTtyZXR1cm4gdn1mdW5jdGlvbiBwKGIsRSl7Y29uc3Qgdj1FLl9idWZmZXJzO09iamVjdC52YWx1ZXModikuZm9yRWFjaChNPT57Yi5kZWxldGVCdWZmZXIoTSl9KSxFLl9idWZmZXJzPXt9fWZ1bmN0aW9uIGwoYixFLHYpe3JldHVybiBiLmFjdGl2ZVRleHR1cmUoYi5URVhUVVJFMCt2KSxBcnJheS5pc0FycmF5KEUuX2ltZyk/Yi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfQ1VCRV9NQVAsRSk6Yi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfMkQsRSksRX1jb25zdCB5PXtpbnQ6IjFpIixpdmVjMjoiMmkiLGl2ZWMzOiIzaSIsaXZlYzQ6IjRpIixmbG9hdDoiMWYiLHZlYzI6IjJmIix2ZWMzOiIzZiIsdmVjNDoiNGYiLG1hdDI6Ik1hdHJpeDJmdiIsbWF0MzoiTWF0cml4M2Z2IixtYXQ0OiJNYXRyaXg0ZnYiLHNhbXBsZXIxRDoic2FtcGxlcjFEIixzYW1wbGVyMkQ6InNhbXBsZXIyRCIsc2FtcGxlcjNEOiJzYW1wbGVyM0QiLHNhbXBsZXJDdWJlOiJzYW1wbGVyQ3ViZSIsc2FtcGxlcjFEU2hhZG93OiJzYW1wbGVyMURTaGFkb3ciLHNhbXBsZXIyRFNoYWRvdzoic2FtcGxlcjJEU2hhZG93IixzYW1wbGVyMkRSZWN0OiJzYW1wbGVyMkRSZWN0IixzYW1wbGVyMkRSZWN0U2hhZG93OiJzYW1wbGVyMkRSZWN0U2hhZG93In07Y2xhc3MgeHtzdGF0aWMgYWRkTGlicyhFPXt9KXtPYmplY3QuYXNzaWduKG8sRSl9c3RhdGljIEZMT0FUKEUsdil7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShFLEZsb2F0MzJBcnJheSx2KX1zdGF0aWMgVU5TSUdORURfQllURShFLHYpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoRSxVaW50OEFycmF5LHYpfXN0YXRpYyBVTlNJR05FRF9TSE9SVChFLHYpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoRSxVaW50MTZBcnJheSx2KX1zdGF0aWMgQllURShFLHYpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoRSxJbnQ4QXJyYXksdil9c3RhdGljIFNIT1JUKEUsdil7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShFLEludDE2QXJyYXksdil9Y29uc3RydWN0b3IoRSx2PXt9KXt0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSx4LmRlZmF1bHRPcHRpb25zLHYpLHRoaXMuY2FudmFzPUU7bGV0IE07dGhpcy5vcHRpb25zLndlYmdsMiYmKE09RS5nZXRDb250ZXh0KCJ3ZWJnbDIiLHRoaXMub3B0aW9ucykpLE09PW51bGwmJihNPU9iamVjdChyLnNldHVwV2ViR0wpKEUsdGhpcy5vcHRpb25zKSx0aGlzLmFpYV9leHQ9TS5nZXRFeHRlbnNpb24oIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKSksdGhpcy5nbD1NLE0udmlld3BvcnQoMCwwLEUud2lkdGgsRS5oZWlnaHQpLE0uY2xlYXJDb2xvcigwLDAsMCwwKSxNLmJsZW5kRnVuY1NlcGFyYXRlKE0uU1JDX0FMUEhBLE0uT05FX01JTlVTX1NSQ19BTFBIQSxNLk9ORSxNLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXMucHJvZ3JhbXM9W10sdGhpcy5fZXZlbnRzPXt9fWdldCBwcm9ncmFtKCl7Y29uc3QgRT10aGlzLmdsO3JldHVybiBFLmdldFBhcmFtZXRlcihFLkNVUlJFTlRfUFJPR1JBTSl9X2RlY2xhcmVVbmlmb3JtKEUsdixNPSIxZiIpe2NvbnN0IGk9dGhpcy5nbCxhPWkuZ2V0VW5pZm9ybUxvY2F0aW9uKEUsdik7bGV0IHM7Y29uc3QgZj10aGlzO2lmKC9ec2FtcGxlci8udGVzdChNKSl7Y29uc3QgTz1FLl9zYW1wbGVyTWFwLEE9RS5fYmluZFRleHR1cmVzO09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLnVuaWZvcm1zLHYse2dldCgpe3JldHVybiBzfSxzZXQoUil7cz1SO2NvbnN0IEk9T1t2XSE9bnVsbD9PW3ZdOkEubGVuZ3RoO0FbSV09UixsKGksUixJKSxPW3ZdfHwoT1t2XT1JLGkudW5pZm9ybTFpKGEsSSkpLGYub3B0aW9ucy5hdXRvVXBkYXRlJiZmLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfWVsc2V7Y29uc3QgTz1NLmluZGV4T2YoIk1hdHJpeCIpPT09MCxBPSFPJiYvdiQvLnRlc3QoTSksUj1pW2B1bmlmb3JtJHtNfWBdLmJpbmQoaSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUudW5pZm9ybXMsdix7Z2V0KCl7cmV0dXJuIHN9LHNldChJKXtzPUksdHlwZW9mIEk9PSJudW1iZXIiJiYoST1bSV0pLE8/UihhLCExLEkpOkE/UihhLEkpOlIoYSwuLi5JKSxmLm9wdGlvbnMuYXV0b1VwZGF0ZSYmZi51cGRhdGUoKX0sY29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITB9KX19X2RyYXcoKXtjb25zdCBFPXRoaXMucHJvZ3JhbTtFLm1lc2hEYXRhLmZvckVhY2goKHYsTSk9Pntjb25zdHtwb3NpdGlvbnM6aSxjZWxsczphLGluc3RhbmNlQ291bnQ6cyxjZWxsc0NvdW50OmYsYXR0cmlidXRlczpPLHVuaWZvcm1zOkEsdGV4dHVyZUNvb3JkOlIsZW5hYmxlQmxlbmQ6SX09dixQPXRoaXMuZ2w7bGV0IEw9di5tb2RlIT1udWxsP3YubW9kZTpQLlRSSUFOR0xFUzt0eXBlb2YgTD09InN0cmluZyImJihMPVBbTF0pLEk/UC5lbmFibGUoUC5CTEVORCk6UC5kaXNhYmxlKFAuQkxFTkQpLFAuYmluZEJ1ZmZlcihQLkFSUkFZX0JVRkZFUixFLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKSxQLmJ1ZmZlckRhdGEoUC5BUlJBWV9CVUZGRVIsaSxQLlNUQVRJQ19EUkFXKSxhJiYoUC5iaW5kQnVmZmVyKFAuRUxFTUVOVF9BUlJBWV9CVUZGRVIsRS5fYnVmZmVycy5jZWxsc0J1ZmZlciksUC5idWZmZXJEYXRhKFAuRUxFTUVOVF9BUlJBWV9CVUZGRVIsYSxQLlNUQVRJQ19EUkFXKSk7Y29uc3QgRD1bXTtPJiZPYmplY3QudmFsdWVzKE8pLmZvckVhY2goKHtuYW1lOlMsZGF0YTpCLGRpdmlzb3I6d30pPT57aWYoUC5iaW5kQnVmZmVyKFAuQVJSQVlfQlVGRkVSLEUuX2J1ZmZlcnNbU10pLFAuYnVmZmVyRGF0YShQLkFSUkFZX0JVRkZFUixCLFAuU1RBVElDX0RSQVcpLHchPW51bGwpe2NvbnN0IEg9UC5nZXRBdHRyaWJMb2NhdGlvbihFLFMpO0g+PTAmJihQLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEgpLEQucHVzaChIKSxQLnZlcnRleEF0dHJpYkRpdmlzb3I/UC52ZXJ0ZXhBdHRyaWJEaXZpc29yKEgsdyk6dGhpcy5haWFfZXh0JiZ0aGlzLmFpYV9leHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKEgsdykpfX0pLEEmJk9iamVjdC5lbnRyaWVzKEEpLmZvckVhY2goKFtTLEJdKT0+e3RoaXMudW5pZm9ybXNbU109Qn0pO2xldCBDO2lmKCFhKXtjb25zdCBTPUUuX2RpbWVuc2lvbjtDPWkubGVuZ3RoL1N9aWYoRS5fZW5hYmxlVGV4dHVyZXMmJkUuX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpe2NvbnN0IFM9Unx8YyhpLEUuX2RpbWVuc2lvbik7UC5iaW5kQnVmZmVyKFAuQVJSQVlfQlVGRkVSLEUuX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpLFAuYnVmZmVyRGF0YShQLkFSUkFZX0JVRkZFUix4LkZMT0FUKFMpLFAuU1RBVElDX0RSQVcpfXMhPW51bGw/KGE/UC5kcmF3RWxlbWVudHNJbnN0YW5jZWQ/UC5kcmF3RWxlbWVudHNJbnN0YW5jZWQoTCxmLFAuVU5TSUdORURfU0hPUlQsMCxzKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShMLGYsUC5VTlNJR05FRF9TSE9SVCwwLHMpOlAuZHJhd0FycmF5c0luc3RhbmNlZD9QLmRyYXdBcnJheXNJbnN0YW5jZWQoTCwwLEMscyk6dGhpcy5haWFfZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShMLDAsQyxzKSxELmZvckVhY2goUz0+e1AudmVydGV4QXR0cmliRGl2aXNvcj9QLnZlcnRleEF0dHJpYkRpdmlzb3IoUyxudWxsKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoUyxudWxsKX0pKTphP1AuZHJhd0VsZW1lbnRzKEwsZixQLlVOU0lHTkVEX1NIT1JULDApOlAuZHJhd0FycmF5cyhMLDAsQyl9KX1nZXQgaXNXZWJHTDIoKXtyZXR1cm4gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ8InUiJiZ0aGlzLmdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH1nZXQgZW5hYmxlVGV4dHVyZXMoKXtyZXR1cm4gdGhpcy5wcm9ncmFtJiZ0aGlzLnByb2dyYW0uX2VuYWJsZVRleHR1cmVzfWdldCB1bmlmb3Jtcygpe2NvbnN0IEU9dGhpcy5wcm9ncmFtO2lmKCFFfHwhRS51bmlmb3Jtcyl0aHJvdyBFcnJvcigiTm8gYXZhbGlhYmxlIHByb2dyYW0uIik7cmV0dXJuIEUudW5pZm9ybXN9ZGVsZXRlUHJvZ3JhbShFKXtjb25zdCB2PXRoaXMuZ2w7dGhpcy5wcm9ncmFtPT09RSYmKHRoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKSx2LnVzZVByb2dyYW0obnVsbCkpO2NvbnN0IE09dGhpcy5wcm9ncmFtcy5pbmRleE9mKEUpO00+PTAmJnRoaXMucHJvZ3JhbXMuc3BsaWNlKE0sMSkscCh2LEUpLHYuZGVsZXRlUHJvZ3JhbShFKX1zZXRNZXNoRGF0YShFKXtBcnJheS5pc0FycmF5KEUpfHwoRT1bRV0pO2NvbnN0IHY9dGhpcy5wcm9ncmFtO3YubWVzaERhdGE9RS5tYXAoKHttb2RlOk0scG9zaXRpb25zOmksaW5zdGFuY2VDb3VudDphLGNlbGxzOnMsY2VsbHNDb3VudDpmLGF0dHJpYnV0ZXM6Tyx1bmlmb3JtczpBLHRleHR1cmVDb29yZDpSLGVuYWJsZUJsZW5kOkl9KT0+e2NvbnN0IFA9e3Bvc2l0aW9uczp4LkZMT0FUKGkpLHVuaWZvcm1zOkEsZW5hYmxlQmxlbmQ6ISFJLHRleHR1cmVDb29yZDp4LkZMT0FUKFIpfTtpZihzJiYoUC5jZWxscz14LlVTSE9SVChzKSxQLmNlbGxzQ291bnQ9Znx8UC5jZWxscy5sZW5ndGgpLE0hPW51bGwmJihQLm1vZGU9TSksYSE9bnVsbCl7aWYoIXRoaXMuaXNXZWJHTDImJiF0aGlzLmFpYV9leHQpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgdXNlIGluc3RhbmNlQ291bnQgaW4gdGhpcyByZW5kZXJpbmcgY29udGV4dCwgdXNlIHdlYmdsMiBjb250ZXh0IGluc3RlYWQuIik7UC5pbnN0YW5jZUNvdW50PWF9aWYoTyl7Y29uc3QgTD17fTtPYmplY3QuZW50cmllcyhPKS5mb3JFYWNoKChbRCxDXSk9PntpZighdi5fYXR0cmlidXRlW0RdKXYuX2F0dHJpYnV0ZVtEXT0iaWdub3JlZCI7ZWxzZSBpZih2Ll9hdHRyaWJ1dGVbRF0hPT0iaWdub3JlZCIpe2NvbnN0e25hbWU6Uyx0eXBlOkJ9PXYuX2F0dHJpYnV0ZVtEXTtsZXQgdz1DLmRhdGF8fEM7aWYoQXJyYXkuaXNBcnJheSh3KSYmKHc9eFtCXSh3KSksTFtEXT17bmFtZTpTLGRhdGE6d30sQy5kaXZpc29yIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgZGl2aXNvciBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtMW0RdLmRpdmlzb3I9Qy5kaXZpc29yfX19KSxQLmF0dHJpYnV0ZXM9TH1yZXR1cm4gUH0pLHRoaXMub3B0aW9ucy5hdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZSgpfWNyZWF0ZVByb2dyYW0oRSx2KXtjb25zdCBNPS9eXHMqdW5pZm9ybVxzK3NhbXBsZXIvbWcudGVzdChFKTtFPT1udWxsJiYoRT1kLmRlZmF1bHQpLHY9PW51bGwmJih2PU0/Zy5kZWZhdWx0Om4uZGVmYXVsdCk7Y29uc3QgaT10aGlzLmdsLGE9T2JqZWN0KHIuY3JlYXRlUHJvZ3JhbSkoaSx2LEUpO2Euc2hhZGVyVGV4dD17dmVydGV4U2hhZGVyOnYsZnJhZ21lbnRTaGFkZXI6RX0sYS5fYnVmZmVycz17fSxhLl9hdHRyaWJ1dGU9e30sYS51bmlmb3Jtcz17fSxhLl9zYW1wbGVyTWFwPXt9LGEuX2JpbmRUZXh0dXJlcz1bXTtjb25zdCBzPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb259YCwiaW0iKTtsZXQgZj12Lm1hdGNoKHMpO2YmJihhLl9kaW1lbnNpb249TnVtYmVyKGZbMV0pKTtjb25zdCBPPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkfWAsImltIik7Zj12Lm1hdGNoKE8pLGYmJihhLl90ZXhDb29yZFNpemU9TnVtYmVyKGZbMV0pKTtjb25zdCBBPS9eXHMqKD86YXR0cmlidXRlfGluKSAoXHcrPykoXGQqKSAoXHcrKS9naW07aWYoZj12Lm1hdGNoKEEpLGYpZm9yKGxldCBQPTA7UDxmLmxlbmd0aDtQKyspe2NvbnN0IEw9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2ltLEQ9ZltQXS5tYXRjaChMKTtpZihEJiZEWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uJiZEWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCl7bGV0WyxDLFMsQl09RDtDPT09Im1hdCImJihTKio9MiksYS5fYnVmZmVyc1tCXT1pLmNyZWF0ZUJ1ZmZlcigpLGEuX2F0dHJpYnV0ZVtCXT17bmFtZTpCLHR5cGU6QyxzaXplOk51bWJlcihTKXx8MX19fWNvbnN0IFI9L15ccyp1bmlmb3JtXHMrKFx3KylccysoXHcrKShcW1xkK1xdKT8vbWc7Zj12Lm1hdGNoKFIpfHxbXSxmPWYuY29uY2F0KEUubWF0Y2goUil8fFtdKSxmLmZvckVhY2goUD0+e2NvbnN0IEw9UC5tYXRjaCgvXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy8pO2xldFtELEMsU109TC5zbGljZSgxKTtEPXlbRF0sUz0hIVMsRC5pbmRleE9mKCJNYXRyaXgiKSE9PTAmJlMmJihEKz0idiIpLHRoaXMuX2RlY2xhcmVVbmlmb3JtKGEsQyxEKX0pLGEuX2J1ZmZlcnMudmVydGljZXNCdWZmZXI9aS5jcmVhdGVCdWZmZXIoKSxhLl9idWZmZXJzLmNlbGxzQnVmZmVyPWkuY3JlYXRlQnVmZmVyKCk7Y29uc3QgST1pLmdldEF0dHJpYkxvY2F0aW9uKGEsdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7cmV0dXJuIGEuX2VuYWJsZVRleHR1cmVzPUk+PTAsYS5fZW5hYmxlVGV4dHVyZXMmJihhLl9idWZmZXJzLnRleENvb3JkQnVmZmVyPWkuY3JlYXRlQnVmZmVyKCkpLHRoaXMucHJvZ3JhbXMucHVzaChhKSxhfXVzZVByb2dyYW0oRSx2PXt9KXt0aGlzLnN0YXJ0UmVuZGVyPSExLHRoaXMuX3JlbmRlckZyYW1lSUQmJihjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUlEKSxkZWxldGUgdGhpcy5fcmVuZGVyRnJhbWVJRCk7Y29uc3QgTT10aGlzLmdsO00udXNlUHJvZ3JhbShFKTtjb25zdCBpPUUuX2RpbWVuc2lvbjtNLmJpbmRCdWZmZXIoTS5BUlJBWV9CVUZGRVIsRS5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcik7Y29uc3QgYT1NLmdldEF0dHJpYkxvY2F0aW9uKEUsdGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uKTtpZihNLnZlcnRleEF0dHJpYlBvaW50ZXIoYSxpLE0uRkxPQVQsITEsMCwwKSxNLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGEpLEUuX2VuYWJsZVRleHR1cmVzKXtNLmJpbmRCdWZmZXIoTS5BUlJBWV9CVUZGRVIsRS5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcik7Y29uc3Qgcz1NLmdldEF0dHJpYkxvY2F0aW9uKEUsdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7TS52ZXJ0ZXhBdHRyaWJQb2ludGVyKHMsRS5fdGV4Q29vcmRTaXplfHwyLE0uRkxPQVQsITEsMCwwKSxNLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHMpfWlmKE9iamVjdC5lbnRyaWVzKEUuX2F0dHJpYnV0ZSkuZm9yRWFjaCgoW3MsZl0pPT57aWYoZiE9PSJpZ25vcmVkIil7Y29uc3QgTz1mLnNpemUsQT12W3NdfHx7fSxSPSEhQS5ub3JtYWxpemU7bGV0IEk9QS50eXBlfHwiRkxPQVQiO2NvbnN0IFA9QS5rZXl8fHM7ST09PSJVQllURSImJihJPSJVTlNJR05FRF9CWVRFIiksST09PSJVU0hPUlQiJiYoST0iVU5TSUdORURfU0hPUlQiKSxmLnR5cGU9SSxQJiZQIT09cyYmKEUuX2F0dHJpYnV0ZVtQXT1mKSxNLmJpbmRCdWZmZXIoTS5BUlJBWV9CVUZGRVIsRS5fYnVmZmVyc1tzXSk7Y29uc3QgTD1NLmdldEF0dHJpYkxvY2F0aW9uKEUscyk7TD49MCYmKE0udmVydGV4QXR0cmliUG9pbnRlcihMLE8sTVtJXSxSLDAsMCksTS5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShMKSl9fSksIUUubWVzaERhdGEpe2NvbnN0IHM9W1stMSwtMSwwLDFdLnNsaWNlKDAsaSksWzEsLTEsMCwxXS5zbGljZSgwLGkpLFsxLDEsMCwxXS5zbGljZSgwLGkpLFstMSwxLDAsMV0uc2xpY2UoMCxpKV0sZj1bWzAsMSwzXSxbMywxLDJdXTt0aGlzLnNldE1lc2hEYXRhKHtwb3NpdGlvbnM6cyxjZWxsczpmfSl9cmV0dXJuIEV9Y29tcGlsZVN5bmMoRSx2KXtFPUV8fGQuZGVmYXVsdDtjb25zdCBNPXt9O2Z1bmN0aW9uIGkoTyl7Tz1PLnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEE9W10sUj1PLm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoUil7Zm9yKGxldCBJPTA7STxSLmxlbmd0aDtJKyspe2NvbnN0IEw9UltJXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoTCl7Y29uc3QgRD1MWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBDPUxbMV07aWYoQz09PSJncmFwaCImJihDPSJncmFwaGljcyIpLE1bQ10pQS5wdXNoKGAvKiBpbmNsdWRlZCAke0N9ICovYCk7ZWxzZSBpZihNW0NdPSEwLEQ9PT0ibGliIil7Y29uc3QgUz1pKG9bQ10pO0EucHVzaChTKX1lbHNlIGlmKEQ9PT0ibGluayIpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCBleHRlcm5hbCBsaW5rcyBzeW5jaHJvbm91c2x5LiBVc2UgY29tcGlsZSBpbnN0ZWFkIG9mIGNvbXBpbGVTeW5jLiIpfX1BLmZvckVhY2goST0+e089Ty5yZXBsYWNlKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tLEkpfSl9cmV0dXJuIE99Y29uc3QgYT1pKEUpLHM9dj9pKHYpOm51bGw7cmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbShhLHMpfWFzeW5jIGNvbXBpbGUoRSx2KXtFPUV8fGQuZGVmYXVsdDtjb25zdCBNPXt9O2FzeW5jIGZ1bmN0aW9uIGkoTyl7Tz1PLnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEE9W10sUj1PLm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoUil7Zm9yKGxldCBJPTA7STxSLmxlbmd0aDtJKyspe2NvbnN0IEw9UltJXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoTCl7Y29uc3QgRD1MWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBDPUxbMV07aWYoQz09PSJncmFwaCImJihDPSJncmFwaGljcyIpLE1bQ10pQS5wdXNoKGAvKiBpbmNsdWRlZCAke0N9ICovYCk7ZWxzZSBpZihNW0NdPSEwLEQ9PT0ibGliIil7Y29uc3QgUz1hd2FpdCBpKG9bQ10pO0EucHVzaChTKX1lbHNlIGlmKEQ9PT0ibGluayIpe2xldCBTPWF3YWl0IHguZmV0Y2hTaGFkZXIoQyk7Uz1hd2FpdCBpKFMpLEEucHVzaChTKX19fUEuZm9yRWFjaChJPT57Tz1PLnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sSSl9KX1yZXR1cm4gT31jb25zdCBhPWF3YWl0IGkoRSkscz12P2F3YWl0IGkodik6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGEscyl9YXN5bmMgbG9hZChFLHY9bnVsbCl7cmV0dXJuIEU9YXdhaXQgeC5mZXRjaFNoYWRlcihFKSx2JiYodj1hd2FpdCB4LmZldGNoU2hhZGVyKHYpKSx0aGlzLmNvbXBpbGUoRSx2KX1jcmVhdGVUZXh0dXJlKEU9bnVsbCx7d3JhcFM6dj10aGlzLmdsLkNMQU1QX1RPX0VER0Usd3JhcFQ6TT10aGlzLmdsLkNMQU1QX1RPX0VER0UsbWluRmlsdGVyOmk9dGhpcy5nbC5MSU5FQVIsbWFnRmlsdGVyOmE9dGhpcy5nbC5MSU5FQVJ9PXt9KXtjb25zdCBzPXRoaXMuZ2wsZj1BcnJheS5pc0FycmF5KEUpP3MuVEVYVFVSRV9DVUJFX01BUDpzLlRFWFRVUkVfMkQ7dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHM9dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHN8fHMuZ2V0UGFyYW1ldGVyKHMuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLHMuYWN0aXZlVGV4dHVyZShzLlRFWFRVUkUwK3RoaXMuX21heF90ZXh0dXJlX2ltYWdlX3VuaXRzLTEpO2NvbnN0IE89cy5jcmVhdGVUZXh0dXJlKCk7cy5iaW5kVGV4dHVyZShmLE8pLHMucGl4ZWxTdG9yZWkocy5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCEwKTtjb25zdHt3aWR0aDpBLGhlaWdodDpSfT10aGlzLmNhbnZhcztpZihFKWlmKGY9PT1zLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBJPTA7STw2O0krKylzLnRleEltYWdlMkQocy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grSSwwLHMuUkdCQSxzLlJHQkEscy5VTlNJR05FRF9CWVRFLEVbSV0pO2Vsc2Ugcy50ZXhJbWFnZTJEKGYsMCxzLlJHQkEscy5SR0JBLHMuVU5TSUdORURfQllURSxFKTtlbHNlIGlmKGY9PT1zLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBJPTA7STw2O0krKyl0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grSSwwLHMuUkdCQSxBLFIsMCxzLlJHQkEscy5VTlNJR05FRF9CWVRFLG51bGwpO2Vsc2Ugcy50ZXhJbWFnZTJEKGYsMCxzLlJHQkEsQSxSLDAscy5SR0JBLHMuVU5TSUdORURfQllURSxudWxsKTtyZXR1cm4gcy50ZXhQYXJhbWV0ZXJpKGYscy5URVhUVVJFX01JTl9GSUxURVIsaSkscy50ZXhQYXJhbWV0ZXJpKGYscy5URVhUVVJFX01BR19GSUxURVIsYSkscy50ZXhQYXJhbWV0ZXJpKGYscy5URVhUVVJFX1dSQVBfUyx2KSxzLnRleFBhcmFtZXRlcmkoZixzLlRFWFRVUkVfV1JBUF9ULE0pLGY9PT1zLlRFWFRVUkVfQ1VCRV9NQVAmJihFLndpZHRoPUVbMF0ud2lkdGgsRS5oZWlnaHQ9RVswXS5oZWlnaHQpLHMuYmluZFRleHR1cmUoZixudWxsKSxPLl9pbWc9RXx8e3dpZHRoOkEsaGVpZ2h0OlJ9LE8uZGVsZXRlPSgpPT57dGhpcy5kZWxldGVUZXh0dXJlKE8pfSxPfWRlbGV0ZVRleHR1cmUoRSl7Y29uc3Qgdj1FLl9pbWc7dGhpcy5nbC5kZWxldGVUZXh0dXJlKEUpLHR5cGVvZiB2LmNsb3NlPT0iZnVuY3Rpb24iJiZ2LmNsb3NlKCl9YXN5bmMgbG9hZFRleHR1cmUoRSx7dXNlSW1hZ2VCaXRtYXA6dj0hMH09e30pe2NvbnN0IE09YXdhaXQgeC5sb2FkSW1hZ2UoRSx7dXNlSW1hZ2VCaXRtYXA6dn0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoTSl9Y3JlYXRlRkJPKHtjb2xvcjpFPTEsYmxlbmQ6dj0hMSxkZXB0aDpNPXRoaXMub3B0aW9ucy5kZXB0aCE9PSExLHN0ZW5jaWw6aT0hIXRoaXMub3B0aW9ucy5zdGVuY2lsfT17fSl7Y29uc3QgYT10aGlzLmdsLHM9YS5jcmVhdGVGcmFtZWJ1ZmZlcigpO2EuYmluZEZyYW1lYnVmZmVyKGEuRlJBTUVCVUZGRVIscyk7Y29uc3QgZj1bXTtmb3IobGV0IFI9MDtSPEU7UisrKXtjb25zdCBJPXRoaXMuY3JlYXRlVGV4dHVyZSgpO2EuZnJhbWVidWZmZXJUZXh0dXJlMkQoYS5GUkFNRUJVRkZFUixhLkNPTE9SX0FUVEFDSE1FTlQwK1IsYS5URVhUVVJFXzJELEksMCksZi5wdXNoKEkpfXMudGV4dHVyZXM9ZixzLnRleHR1cmU9ZlswXSxzLmJsZW5kPXY7Y29uc3R7d2lkdGg6TyxoZWlnaHQ6QX09dGhpcy5jYW52YXM7cmV0dXJuIE0mJiFpJiYocy5kZXB0aEJ1ZmZlcj1hLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLGEuYmluZFJlbmRlcmJ1ZmZlcihhLlJFTkRFUkJVRkZFUixzLmRlcHRoQnVmZmVyKSxhLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYS5SRU5ERVJCVUZGRVIsYS5ERVBUSF9DT01QT05FTlQxNixPLEEpLGEuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoYS5GUkFNRUJVRkZFUixhLkRFUFRIX0FUVEFDSE1FTlQsYS5SRU5ERVJCVUZGRVIscy5kZXB0aEJ1ZmZlcikpLGkmJiFNJiYocy5zdGVuY2lsQnVmZmVyPWEuY3JlYXRlUmVuZGVyYnVmZmVyKCksYS5iaW5kUmVuZGVyYnVmZmVyKGEuUkVOREVSQlVGRkVSLHMuc3RlbmNpbEJ1ZmZlciksYS5yZW5kZXJidWZmZXJTdG9yYWdlKGEuUkVOREVSQlVGRkVSLGEuU1RFTkNJTF9JTkRFWDgsTyxBKSxhLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGEuRlJBTUVCVUZGRVIsYS5TVEVOQ0lMX0FUVEFDSE1FTlQsYS5SRU5ERVJCVUZGRVIscy5zdGVuY2lsQnVmZmVyKSksTSYmaSYmKHMuZGVwdGhTdGVuY2lsQnVmZmVyPWEuY3JlYXRlUmVuZGVyYnVmZmVyKCksYS5iaW5kUmVuZGVyYnVmZmVyKGEuUkVOREVSQlVGRkVSLHMuZGVwdGhTdGVuY2lsQnVmZmVyKSxhLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYS5SRU5ERVJCVUZGRVIsYS5ERVBUSF9TVEVOQ0lMLE8sQSksYS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihhLkZSQU1FQlVGRkVSLGEuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULGEuUkVOREVSQlVGRkVSLHMuZGVwdGhTdGVuY2lsQnVmZmVyKSksYS5iaW5kRnJhbWVidWZmZXIoYS5GUkFNRUJVRkZFUixudWxsKSxzfWJpbmRGQk8oRT1udWxsKXt0aGlzLmZibz1FfXJlbmRlcih7Y2xlYXJCdWZmZXI6RT0hMH09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITA7Y29uc3Qgdj10aGlzLmdsO2xldCBNPXRoaXMucHJvZ3JhbTtNfHwoTT10aGlzLmNyZWF0ZVByb2dyYW0oKSx0aGlzLnVzZVByb2dyYW0oTSkpLHRoaXMuZmJvJiZ2LmJpbmRGcmFtZWJ1ZmZlcih2LkZSQU1FQlVGRkVSLHRoaXMuZmJvKTtjb25zdCBpPXRoaXMub3B0aW9ucy5kZXB0aDtpJiZ2LmVuYWJsZSh2LkRFUFRIX1RFU1QpLHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUfChpP3RoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVDowKXwodGhpcy5vcHRpb25zLnN0ZW5jaWw/dGhpcy5nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ6MCkpO2NvbnN0IGE9dGhpcy5fcmVuZGVyRnJhbWVJRDt0aGlzLl9kcmF3KCksdGhpcy5mYm8mJnYuYmluZEZyYW1lYnVmZmVyKHYuRlJBTUVCVUZGRVIsbnVsbCksdGhpcy5fcmVuZGVyRnJhbWVJRD09PWEmJih0aGlzLl9yZW5kZXJGcmFtZUlEPW51bGwpfXVwZGF0ZSgpe3RoaXMuc3RhcnRSZW5kZXImJnRoaXMuX3JlbmRlckZyYW1lSUQ9PW51bGwmJih0aGlzLl9yZW5kZXJGcmFtZUlEPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKSl9fXUoeCwiZGVmYXVsdE9wdGlvbnMiLHtwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITAsYXV0b1VwZGF0ZTohMCx2ZXJ0ZXhQb3NpdGlvbjoiYV92ZXJ0ZXhQb3NpdGlvbiIsdmVydGV4VGV4dHVyZUNvb3JkOiJhX3ZlcnRleFRleHR1cmVDb29yZCIsd2ViZ2wyOiExfSksdSh4LCJVQllURSIseC5VTlNJR05FRF9CWVRFKSx1KHgsIlVTSE9SVCIseC5VTlNJR05FRF9TSE9SVCksdSh4LCJmZXRjaFNoYWRlciIsci5mZXRjaFNoYWRlciksdSh4LCJsb2FkSW1hZ2UiLHIubG9hZEltYWdlKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwic2V0dXBXZWJHTCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJjcmVhdGVQcm9ncmFtIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsInBvaW50c1RvQnVmZmVyIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImxvYWRJbWFnZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJmZXRjaFNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGwseSl7Y29uc3QgeD1bIndlYmdsIiwiZXhwZXJpbWVudGFsLXdlYmdsIiwid2Via2l0LTNkIiwibW96LXdlYmdsIl07bGV0IGI9bnVsbDtmb3IobGV0IEU9MDtFPHgubGVuZ3RoOysrRSl7dHJ5e2I9bC5nZXRDb250ZXh0KHhbRV0seSl9Y2F0Y2h7fWlmKGIpYnJlYWt9cmV0dXJuIGJ9ZnVuY3Rpb24gbihsLHkpe2NvbnN0IHg9cihsLHkpO2lmKCF4KXRocm93IG5ldyBFcnJvcigiU29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgV2ViR0wuIik7cmV0dXJuIHh9ZnVuY3Rpb24gZChsLHkseCl7Y29uc3QgYj1sLmNyZWF0ZVNoYWRlcihsLlZFUlRFWF9TSEFERVIpO2lmKGwuc2hhZGVyU291cmNlKGIseSksbC5jb21waWxlU2hhZGVyKGIpLCFsLmdldFNoYWRlclBhcmFtZXRlcihiLGwuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBNPWBWZXJ0ZXggc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2wuZ2V0U2hhZGVySW5mb0xvZyhiKX1gO3Rocm93IG5ldyBFcnJvcihNKX1jb25zdCBFPWwuY3JlYXRlU2hhZGVyKGwuRlJBR01FTlRfU0hBREVSKTtpZihsLnNoYWRlclNvdXJjZShFLHgpLGwuY29tcGlsZVNoYWRlcihFKSwhbC5nZXRTaGFkZXJQYXJhbWV0ZXIoRSxsLkNPTVBJTEVfU1RBVFVTKSl7Y29uc3QgTT1gRnJhZ21lbnQgc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2wuZ2V0U2hhZGVySW5mb0xvZyhFKX1gO3Rocm93IG5ldyBFcnJvcihNKX1jb25zdCB2PWwuY3JlYXRlUHJvZ3JhbSgpO2lmKGwuYXR0YWNoU2hhZGVyKHYsYiksbC5hdHRhY2hTaGFkZXIodixFKSxsLmxpbmtQcm9ncmFtKHYpLCFsLmdldFByb2dyYW1QYXJhbWV0ZXIodixsLkxJTktfU1RBVFVTKSl7Y29uc3QgTT1gU2hhZGVyIHByb2dyYW0gZmFpbGVkIHRvIGxpbmsuICBUaGUgZXJyb3IgbG9nIGlzOiR7bC5nZXRQcm9ncmFtSW5mb0xvZyh2KX1gO3Rocm93IG5ldyBFcnJvcihNKX1yZXR1cm4gbC5kZWxldGVTaGFkZXIoYiksbC5kZWxldGVTaGFkZXIoRSksdn1mdW5jdGlvbiBnKGwseT1GbG9hdDMyQXJyYXkseD1udWxsKXtpZih4JiYhKHggaW5zdGFuY2VvZiB5KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJXcm9uZyBidWZmZXIgdHlwZS4iKTtpZihsPT1udWxsfHxsIGluc3RhbmNlb2YgeSlyZXR1cm4gbDtpZihsWzBdPT1udWxsfHxsWzBdLmxlbmd0aD09bnVsbClyZXR1cm4geD8oeC5zZXQobCwwKSx4KTpuZXcgeShsKTtjb25zdCBiPWxbMF0ubGVuZ3RoLEU9bC5sZW5ndGg7eHx8KHg9bmV3IHkoYipFKSk7bGV0IHY9MDtmb3IobGV0IE09MDtNPEU7TSsrKWZvcihsZXQgaT0wO2k8YjtpKyspeFt2KytdPWxbTV1baV07cmV0dXJuIHh9Y29uc3QgdT17fTtmdW5jdGlvbiBvKGwse3VzZUltYWdlQml0bWFwOnk9ITAsYWxpYXM6eD1udWxsfT17fSl7aWYoIXVbbF0pe2lmKHR5cGVvZiBJbWFnZT09ImZ1bmN0aW9uIil7Y29uc3QgYj1uZXcgSW1hZ2U7dHlwZW9mIGw9PSJzdHJpbmciJiYhKHR5cGVvZiBsb2NhdGlvbj09Im9iamVjdCImJi9eZmlsZTovLnRlc3QobG9jYXRpb24uaHJlZikpJiYhL15kYXRhOi8udGVzdChsKSYmKGIuY3Jvc3NPcmlnaW49ImFub255bW91cyIpLHVbbF09bmV3IFByb21pc2UoRT0+e2Iub25sb2FkPWZ1bmN0aW9uKCl7eSYmdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwPT0iZnVuY3Rpb24iP2NyZWF0ZUltYWdlQml0bWFwKGIse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4odj0+e3VbbF09dix4JiYodVt4XT12KSxFKHYpfSk6KHVbbF09Yix4JiYodVt4XT1iKSxFKGIpKX0sYi5zcmM9bH0pLHgmJih1W3hdPXVbbF0pfWVsc2UgaWYodHlwZW9mIGZldGNoPT0iZnVuY3Rpb24iKXJldHVybiBmZXRjaChsLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkudGhlbihiPT5iLmJsb2IoKSkudGhlbihiPT5jcmVhdGVJbWFnZUJpdG1hcChiLHtpbWFnZU9yaWVudGF0aW9uOiJmbGlwWSJ9KS50aGVuKEU9Pih1W2xdPUUseCYmKHVbeF09RSksRSkpKX1yZXR1cm4gdVtsXX1jb25zdCBjPXt9O2FzeW5jIGZ1bmN0aW9uIHAobCl7aWYoY1tsXSlyZXR1cm4gY1tsXTtjb25zdCB5PWF3YWl0IGZldGNoKGwpO2lmKHkuc3RhdHVzPj0yMDAmJnkuc3RhdHVzPDMwMCl7Y29uc3QgeD1hd2FpdCB5LnRleHQoKTtyZXR1cm4gY1tsXT14LHh9dGhyb3cgbmV3IEVycm9yKCJTaGFkZXIgbG9hZGVkIGVycm9yLiIpfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gdmVjNChhX3ZlcnRleFBvc2l0aW9uLCAxKTsKfWB9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWAjaWZkZWYgR0xfRVMKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4xKTsKfWB9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjNCBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gYV92ZXJ0ZXhQb3NpdGlvbjsKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7Cn1gfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBnfSk7dmFyIHI9dCgyMSksbj10KDI1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD1TeW1ib2woInRyYW5zZm9ybSIpO2NsYXNzIGd7Y29uc3RydWN0b3IobyxjKXt0aGlzLmNvbnRleHQ9by5nZXRDb250ZXh0KCIyZCIpLHRoaXMub3B0aW9ucz1jLHRoaXNbZF09WzEsMCwwLDEsMCwwXX1jcmVhdGVUZXh0dXJlKG8pe3JldHVybntfaW1nOm99fWFzeW5jIGxvYWRUZXh0dXJlKG8pe2NvbnN0IGM9YXdhaXQgci5kZWZhdWx0LmxvYWRJbWFnZShvLHt1c2VJbWFnZUJpdG1hcDohMX0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUoYyl9ZGVsZXRlVGV4dHVyZShvKXtyZXR1cm4gb31jbGVhcihvLGMscCxsKXtjb25zdCB5PXRoaXMuY29udGV4dDtvPW98fDAsYz1jfHwwLHA9cHx8eS5jYW52YXMud2lkdGgtbyxsPWx8fHkuY2FudmFzLmhlaWdodC1jLHkuY2xlYXJSZWN0KG8sYyxwLGwpfWRyYXdNZXNoQ2xvdWQobyx7Y2xlYXI6Yz0hMX09e30pe2NvbnN0IHA9W107Zm9yKGxldCBsPTA7bDxvLmFtb3VudDtsKyspe2NvbnN0IHk9by5nZXRUcmFuc2Zvcm0obCk7bGV0IHg9by5nZXRUZXh0dXJlRnJhbWUobCk7eCYmKHg9eC5faW1nKTtjb25zdCBiPW8uZ2V0RmlsdGVyKGwpLHtmaWxsOkUsc3Ryb2tlOnZ9PW8uZ2V0Q2xvdWRSR0JBKGwpO3AucHVzaCh7bWVzaDpvLm1lc2gsX2Nsb3VkT3B0aW9uczpbRSx2LHgseSxiXX0pfW8uYmVmb3JlUmVuZGVyJiZvLmJlZm9yZVJlbmRlcih0aGlzLmNvbnRleHQsbyksdGhpcy5kcmF3TWVzaGVzKHAse2NsZWFyOmMsaG9vazohMX0pLG8uYWZ0ZXJSZW5kZXImJm8uYWZ0ZXJSZW5kZXIodGhpcy5jb250ZXh0LG8pfWRyYXdNZXNoZXMobyx7Y2xlYXI6Yz0hMSxob29rOnA9ITB9PXt9KXtjb25zdCBsPXRoaXMuY29udGV4dDtjJiZsLmNsZWFyUmVjdCgwLDAsbC5jYW52YXMud2lkdGgsbC5jYW52YXMuaGVpZ2h0KTtsZXQgeT1udWxsO2NvbnN0e3dpZHRoOngsaGVpZ2h0OmJ9PWwuY2FudmFzLEU9by5sZW5ndGg7by5mb3JFYWNoKCh2LE0pPT57bGV0IGksYSxzLGYsTztwJiZ2LmJlZm9yZVJlbmRlciYmdi5iZWZvcmVSZW5kZXIobCx2KSx2Ll9jbG91ZE9wdGlvbnMmJihbaSxhLHMsZixPXT12Ll9jbG91ZE9wdGlvbnMsdj12Lm1lc2gpO2xldCBBPXYuZmlsdGVyO2lmKE8mJihBPUE/YCR7QX0gJHtPfWA6TyksQSYmIXRoaXMuZmlsdGVyQnVmZmVyJiZ0aGlzLmZpbHRlckJ1ZmZlciE9PSExKXtjb25zdCBSPXIuZGVmYXVsdC5jcmVhdGVDYW52YXMoeCxiKTtSP3RoaXMuZmlsdGVyQnVmZmVyPVIuZ2V0Q29udGV4dCgiMmQiKTp0aGlzLmZpbHRlckJ1ZmZlcj0hMX15JiZ5IT09QSYmKE9iamVjdChuLmFwcGx5RmlsdGVyKSh0aGlzLmZpbHRlckJ1ZmZlcix5KSxsLmRyYXdJbWFnZSh0aGlzLmZpbHRlckJ1ZmZlci5jYW52YXMsMCwwLHgsYiksdGhpcy5maWx0ZXJCdWZmZXIuY2xlYXJSZWN0KDAsMCx4LGIpLHk9bnVsbCksQSYmdGhpcy5maWx0ZXJCdWZmZXI/KHRoaXMuZmlsdGVyQnVmZmVyLnNhdmUoKSx0aGlzLmZpbHRlckJ1ZmZlci50cmFuc2Zvcm0oLi4udGhpc1tkXSksT2JqZWN0KG4uZHJhd01lc2gyRCkodix0aGlzLmZpbHRlckJ1ZmZlciwhMSxpLGEscyxmKSx0aGlzLmZpbHRlckJ1ZmZlci5yZXN0b3JlKCksTT09PUUtMT8oT2JqZWN0KG4uYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLEEpLGwuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAseCxiKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHgsYikpOnk9QSk6KGwuc2F2ZSgpLGwudHJhbnNmb3JtKC4uLnRoaXNbZF0pLE9iamVjdChuLmRyYXdNZXNoMkQpKHYsbCwhMSxpLGEscyxmKSxsLnJlc3RvcmUoKSkscCYmdi5hZnRlclJlbmRlciYmdi5hZnRlclJlbmRlcihsLHYpfSl9c2V0VHJhbnNmb3JtKG8pe3RoaXNbZF09b319fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLChmdW5jdGlvbihyKXt2YXIgbj10KDE0KSxkPXQoMjMpLGc9dCgyNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHU9e307ZnVuY3Rpb24gbyh4LGIpe2NvbnN0e3N0eWxlOkUsdmFyaWFudDp2LHdlaWdodDpNLHN0cmV0Y2g6aSxzaXplOmEscHhMaW5lSGVpZ2h0OnMsZmFtaWx5OmZ9PXg7cmV0dXJuIGk9PT0ibm9ybWFsIj9gJHtFfSAke3Z9ICR7TX0gJHthKmJ9cHgvJHtzKmJ9cHggJHtmfWA6YCR7RX0gJHt2fSAke019ICR7aX0gJHthKmJ9cHgvJHtzKmJ9cHggJHtmfWB9ZnVuY3Rpb24gYyh4LHtmb250OmIsZmlsbENvbG9yOkUsc3Ryb2tlQ29sb3I6dixzdHJva2VXaWR0aDpNLHJhdGlvOmk9MSx0ZXh0Q2FudmFzOmEsY2FjaGFibGU6cz0hMX0pe2xldCBmO2lmKHMpe2Y9W3gsYixTdHJpbmcoRSksU3RyaW5nKHYpLFN0cmluZyhNKV0uam9pbigiIyMjIik7Y29uc3Qgdz11W2ZdO2lmKHcpcmV0dXJuIHd9YXx8KGE9bCgxLDEpKTtjb25zdCBPPWEuZ2V0Q29udGV4dCgiMmQiKTtPLnNhdmUoKSxPLmZvbnQ9YjtsZXR7d2lkdGg6QX09Ty5tZWFzdXJlVGV4dCh4KTtPLnJlc3RvcmUoKTtjb25zdCBSPU9iamVjdChkLmRlZmF1bHQpKGIpLEk9TWF0aC5tYXgoUi5weExpbmVIZWlnaHQsUi5weEhlaWdodCoxLjEzKTsvaXRhbGljfG9ibGlxdWUvLnRlc3QoYikmJihBKz1JKk1hdGgudGFuKDE1Kk1hdGguUEkvMTgwKSksIUUmJiF2JiYoRT0iIzAwMCIpO2NvbnN0IFA9Ty5jYW52YXMsTD1NYXRoLmNlaWwoQSksRD1NYXRoLmNlaWwoSSk7UC53aWR0aD1NYXRoLnJvdW5kKEwqaSksUC5oZWlnaHQ9TWF0aC5yb3VuZChEKmkpLE8uc2F2ZSgpLE8uZm9udD1vKFIsaSksTy50ZXh0QWxpZ249ImNlbnRlciIsTy50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgQz1QLmhlaWdodCouNStSLnB4SGVpZ2h0Ki4wNSppLFM9UC53aWR0aCouNTtpZihFKXtpZihBcnJheS5pc0FycmF5KEUpKUU9T2JqZWN0KGcuZGVmYXVsdCkoRSk7ZWxzZSBpZihFLnZlY3Rvcil7bGV0IHc7Y29uc3R7dmVjdG9yOkgsY29sb3JzOlp9PUU7SC5sZW5ndGg9PT02P3c9Ty5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5IKTp3PU8uY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSCksWi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6VX0pPT57dy5hZGRDb2xvclN0b3AocSxVKX0pLEU9d31PLmZpbGxTdHlsZT1FLE8uZmlsbFRleHQoeCxTLEMpfWlmKHYpe2lmKE8ubGluZVdpZHRoPU0qaSxBcnJheS5pc0FycmF5KHYpKXY9T2JqZWN0KGcuZGVmYXVsdCkodik7ZWxzZSBpZih2LnZlY3Rvcil7bGV0IHc7Y29uc3R7dmVjdG9yOkgsY29sb3JzOlp9PXY7SC5sZW5ndGg9PT02P3c9Ty5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5IKTp3PU8uY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSCksWi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6VX0pPT57dy5hZGRDb2xvclN0b3AocSxVKX0pLHY9d31PLnN0cm9rZVN0eWxlPXYsTy5zdHJva2VUZXh0KHgsUyxDKX1PLnJlc3RvcmUoKTtjb25zdCBCPXtpbWFnZTphLHJlY3Q6WzAsMCxMLERdfTtyZXR1cm4gcyYmKHVbZl09QiksQn1sZXQgcD0hMTtpZih0eXBlb2YgbmF2aWdhdG9yPT0ib2JqZWN0IiYmdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQ9PSJzdHJpbmciKXtjb25zdCB4PW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvY2hyb21lXC8oXGQrKS8pO3gmJihwPU51bWJlcih4WzFdKTw3MCl9ZnVuY3Rpb24gbCh4LGIsRT17fSl7Y29uc3Qgdj1FLm9mZnNjcmVlbnx8IXAmJkUub2Zmc2NyZWVuIT09ITE7bGV0IE07cmV0dXJuIHR5cGVvZiByPCJ1IiYmdHlwZW9mIHIuY3JlYXRlQ2FudmFzPT0iZnVuY3Rpb24iP009ci5jcmVhdGVDYW52YXMoeCxiLEUpOnYmJnR5cGVvZiBPZmZzY3JlZW5DYW52YXM9PSJmdW5jdGlvbiI/TT1uZXcgT2Zmc2NyZWVuQ2FudmFzKHgsYik6KE09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIiksTS53aWR0aD14LE0uaGVpZ2h0PWIpLE19Y29uc3QgeT17Y3JlYXRlQ2FudmFzOmwsY3JlYXRlVGV4dDpjLGxvYWRJbWFnZTpuLmRlZmF1bHQubG9hZEltYWdlfTtlLmRlZmF1bHQ9eX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGgsZSl7dmFyIHQ7dD1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXt0PXR8fG5ldyBGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpfWNhdGNoe3R5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiYodD13aW5kb3cpfWguZXhwb3J0cz10fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBFfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIodixNKXtpZih0eXBlb2Ygdj09InN0cmluZyIpe2NvbnN0IHM9di50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSkkLyk7cz92PXtzaXplOnBhcnNlRmxvYXQoc1sxXSksdW5pdDpzWzJdfTp2PXtzaXplOnBhcnNlSW50KHYsMTApLHVuaXQ6InB4In19bGV0e3NpemU6aSx1bml0OmF9PXY7aWYoYT09PSJwdCIpaS89Ljc1O2Vsc2UgaWYoYT09PSJwYyIpaSo9MTY7ZWxzZSBpZihhPT09ImluIilpKj05NjtlbHNlIGlmKGE9PT0iY20iKWkqPTk2LzIuNTQ7ZWxzZSBpZihhPT09Im1tIilpKj05Ni8yNS40O2Vsc2UgaWYoYT09PSJlbSJ8fGE9PT0icmVtInx8YT09PSJleCIpe2lmKCFNJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3Qgcz1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7TT1yKHMsMTYpfWkqPU0sYT09PSJleCImJihpLz0yKX1lbHNlIGlmKGE9PT0icSIpaSo9OTYvMjUuNC80O2Vsc2UgaWYoYT09PSJ2dyJ8fGE9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBzPWE9PT0idnciP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2kqPXMvMTAwfX1lbHNlIGlmKChhPT09InZtYXgifHxhPT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3Qgcz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsZj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2E9PT0idm1heCI/aSo9TWF0aC5tYXgocyxmKS8xMDA6aSo9TWF0aC5taW4ocyxmKS8xMDB9cmV0dXJuIGl9Y29uc3Qgbj0iYm9sZHxib2xkZXJ8bGlnaHRlcnxbMS05XTAwIixkPSJpdGFsaWN8b2JsaXF1ZSIsZz0ic21hbGwtY2FwcyIsdT0idWx0cmEtY29uZGVuc2VkfGV4dHJhLWNvbmRlbnNlZHxjb25kZW5zZWR8c2VtaS1jb25kZW5zZWR8c2VtaS1leHBhbmRlZHxleHBhbmRlZHxleHRyYS1leHBhbmRlZHx1bHRyYS1leHBhbmRlZCIsbz0icHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWlufCUiLGM9YCcoW14nXSspJ3wiKFteIl0rKSJ8KFtcXHctXXxb5LiALem+pV0pK2AscD1uZXcgUmVnRXhwKGAoJHtufSkgK2AsImkiKSxsPW5ldyBSZWdFeHAoYCgke2R9KSArYCwiaSIpLHk9bmV3IFJlZ0V4cChgKCR7Z30pICtgLCJpIikseD1uZXcgUmVnRXhwKGAoJHt1fSkgK2AsImkiKSxiPW5ldyBSZWdFeHAoIihbXFxkXFwuXSspKCIrbysiKSg/OlxcLyhbXFxkXFwuXSspKCIrbysiKSk/ICooKD86IitjKyIpKCAqLCAqKD86IitjKyIpKSopIik7ZnVuY3Rpb24gRSh2LE0pe2NvbnN0IGk9Yi5leGVjKHYpO2lmKCFpKXJldHVybjtjb25zdCBhPXBhcnNlRmxvYXQoaVszXSkscz17d2VpZ2h0OiJub3JtYWwiLHN0eWxlOiJub3JtYWwiLHN0cmV0Y2g6Im5vcm1hbCIsdmFyaWFudDoibm9ybWFsIixzaXplOnBhcnNlRmxvYXQoaVsxXSksdW5pdDppWzJdLGxpbmVIZWlnaHQ6TnVtYmVyLmlzRmluaXRlKGEpP2E6dm9pZCAwLGxpbmVIZWlnaHRVbml0OmlbNF0sZmFtaWx5OmlbNV0ucmVwbGFjZSgvICosICovZywiLCIpfSxmPXYuc3Vic3RyaW5nKDAsaS5pbmRleCksTz1wLmV4ZWMoZiksQT1sLmV4ZWMoZiksUj15LmV4ZWMoZiksST14LmV4ZWMoZik7cmV0dXJuIE8mJihzLndlaWdodD1PWzFdKSxBJiYocy5zdHlsZT1BWzFdKSxSJiYocy52YXJpYW50PVJbMV0pLEkmJihzLnN0cmV0Y2g9SVsxXSkscy5weEhlaWdodD1yKHtzaXplOnMuc2l6ZSx1bml0OnMudW5pdH0sTSkscy5weExpbmVIZWlnaHQ9cih7c2l6ZTpzLmxpbmVIZWlnaHR8fHMuc2l6ZSx1bml0OnMubGluZUhlaWdodFVuaXR8fHMudW5pdH0sTSksc319LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihuKXtyZXR1cm5gcmdiYSgke24ubWFwKChkLGcpPT5nPDM/TWF0aC5yb3VuZChkKjI1NSk6ZCkuam9pbigpfSlgfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiYXBwbHlGaWx0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZHJhd01lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMSksbj10KDI0KSxkPXQoMjMpLGc9dCgyNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHUocCxsKXtjb25zdCB5PXAuY2FudmFzO3Auc2F2ZSgpLHAuZmlsdGVyPWwscC5kcmF3SW1hZ2UoeSwwLDAseS53aWR0aCx5LmhlaWdodCkscC5yZXN0b3JlKCl9ZnVuY3Rpb24gbyhwLGwpe2NvbnN0IHk9L3JnYmFcKChcZCspLChcZCspLChcZCspLChcZCspXCkvO3A9cC5tYXRjaCh5KS5zbGljZSgxLDUpLm1hcChOdW1iZXIpLGw9bC5tYXRjaCh5KS5zbGljZSgxLDUpLm1hcChOdW1iZXIpO2NvbnN0IHg9W10sYj1sWzNdO2ZvcihsZXQgRT0wO0U8NDtFKyspeFtFXT1PYmplY3QoZy5taXgpKHBbRV0sbFtFXSxiKTtyZXR1cm5gcmdiYSgke3guam9pbigpfSlgfWZ1bmN0aW9uIGMocCxsLHk9ITAseD1udWxsLGI9bnVsbCxFPW51bGwsdj1udWxsKXtsLnNhdmUoKTtsZXQgTT0hMSxpPSExO2lmKGwuZ2xvYmFsQWxwaGE9cC5nZXRPcGFjaXR5KCkscC5fdXBkYXRlTWF0cml4JiZwLnRyYW5zZm9ybVNjYWxlL3AuY29udG91cnMuc2NhbGU+MS41JiZwLmFjY3VyYXRlKHAudHJhbnNmb3JtU2NhbGUpLHAubGluZVdpZHRoKXtsZXQgZj1wLmdyYWRpZW50JiZwLmdyYWRpZW50LnN0cm9rZTtpZihmKXtjb25zdHt2ZWN0b3I6Tyxjb2xvcnM6QX09ZjtpZihPLmxlbmd0aD09PTYpZj1sLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLk8pO2Vsc2UgaWYoTy5sZW5ndGg9PT00KWY9bC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5PKTtlbHNlIGlmKE8ubGVuZ3RoPT09MylmPWwuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5PKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtBLmZvckVhY2goKHtvZmZzZXQ6Uixjb2xvcjpJfSk9PntsZXQgUD1PYmplY3Qobi5kZWZhdWx0KShJKTtiJiYoUD1vKFAsYikpLGYuYWRkQ29sb3JTdG9wKFIsUCl9KSxsLnN0cm9rZVN0eWxlPWYsTT0hMH1lbHNlIHAuc3Ryb2tlU3R5bGUmJihiP2wuc3Ryb2tlU3R5bGU9byhwLnN0cm9rZVN0eWxlLGIpOmwuc3Ryb2tlU3R5bGU9cC5zdHJva2VTdHlsZSxNPSEwKX1NJiYobC5saW5lV2lkdGg9cC5saW5lV2lkdGgsbC5saW5lSm9pbj1wLmxpbmVKb2luLGwubGluZUNhcD1wLmxpbmVDYXAsbC5taXRlckxpbWl0PXAubWl0ZXJMaW1pdCxwLmxpbmVEYXNoJiYobC5zZXRMaW5lRGFzaChwLmxpbmVEYXNoKSxwLmxpbmVEYXNoT2Zmc2V0JiYobC5saW5lRGFzaE9mZnNldD1wLmxpbmVEYXNoT2Zmc2V0KSkpO2xldCBhPXAuZ3JhZGllbnQmJnAuZ3JhZGllbnQuZmlsbDtpZihhKXtjb25zdHt2ZWN0b3I6Zixjb2xvcnM6T309YTtpZihmLmxlbmd0aD09PTYpYT1sLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLmYpO2Vsc2UgaWYoZi5sZW5ndGg9PT00KWE9bC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5mKTtlbHNlIGlmKGYubGVuZ3RoPT09MylhPWwuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5mKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtPLmZvckVhY2goKHtvZmZzZXQ6QSxjb2xvcjpSfSk9PntsZXQgST1PYmplY3Qobi5kZWZhdWx0KShSKTtiJiYoST1vKEksYikpLGEuYWRkQ29sb3JTdG9wKEEsSSl9KSxsLmZpbGxTdHlsZT1hLGk9ITB9ZWxzZSBwLmZpbGxTdHlsZSYmKHg/bC5maWxsU3R5bGU9byhwLmZpbGxTdHlsZSx4KTpsLmZpbGxTdHlsZT1wLmZpbGxTdHlsZSxpPSEwKTtpZih2JiZsLnRyYW5zZm9ybSguLi52KSxsLnRyYW5zZm9ybSguLi5wLnRyYW5zZm9ybU1hdHJpeCkscC5jbGlwUGF0aCl7Y29uc3QgZj1wLmNsaXBQYXRoLE89bmV3IFBhdGgyRChmKTtsLmNsaXAoTyl9Y29uc3Qgcz1wLmNvbnRvdXJzLmxlbmd0aDtpZihwLmNvbnRvdXJzLmZvckVhY2goKGYsTyk9Pntjb25zdCBBPWYubGVuZ3RoLFI9QT4xJiZyLnZlYzIuZXF1YWxzKGZbMF0sZltBLTFdKSxJPU89PT1zLTEmJnAudGV4dHVyZTtpZihmJiZBPjApe2lmKGl8fE18fEkpe2wuYmVnaW5QYXRoKCksbC5tb3ZlVG8oLi4uZlswXSk7Zm9yKGxldCBQPTE7UDxBO1ArKylQPT09QS0xJiZSP2wuY2xvc2VQYXRoKCk6bC5saW5lVG8oLi4uZltQXSl9aWYoaSYmbC5maWxsKHAuZmlsbFJ1bGUpLEkpe2wuc2F2ZSgpLGwuY2xpcCgpO2xldHtpbWFnZTpQLG9wdGlvbnM6TH09cC50ZXh0dXJlO2lmKEUmJihQPUUpLEwucmVwZWF0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCBpbWFnZSByZXBlYXQgeWV0LiIpLFAuZm9udCl7TC5zY2FsZSYmY29uc29sZS53YXJuKCJDb250ZXh0IDJEIG5vdCBzdXBwb3J0ZWQgdGV4dCBzY2FsZSB5ZXQuIiksTC5zcmNSZWN0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNyY1JlY3QgeWV0LiIpO2xldHtmb250OkQsZmlsbENvbG9yOkMsc3Ryb2tlQ29sb3I6UyxzdHJva2VXaWR0aDpCLHRleHQ6d309UDshQyYmIVMmJihDPSIjMDAwIiksQXJyYXkuaXNBcnJheShDKSYmKEM9T2JqZWN0KG4uZGVmYXVsdCkoQykpLEFycmF5LmlzQXJyYXkoUykmJihTPU9iamVjdChuLmRlZmF1bHQpKFMpKSxsLmZvbnQ9RDtjb25zdHt3aWR0aDpIfT1sLm1lYXN1cmVUZXh0KHcpLFo9T2JqZWN0KGQuZGVmYXVsdCkoRCkscT1NYXRoLm1heChaLnB4TGluZUhlaWdodCxaLnB4SGVpZ2h0KjEuMTMpO2wudGV4dEFsaWduPSJjZW50ZXIiLGwudGV4dEJhc2VsaW5lPSJtaWRkbGUiO2NvbnN0IFU9TC5yZWN0LEc9VVswXStxKi41K1oucHhIZWlnaHQqLjA2LEo9VVsxXStIKi41O1VbMl0hPW51bGwmJmwuc2NhbGUoVVsyXS9ILFVbM10vcSksQyYmKGwuZmlsbFN0eWxlPUMsbC5maWxsVGV4dCh3LEosRykpLFMmJihsLmxpbmVXaWR0aD1CLGwuc3Ryb2tlU3R5bGU9UyxsLnN0cm9rZVRleHQodyxKLEcpKX1lbHNle2xldCBEPUwucmVjdDtjb25zdCBDPUwuc3JjUmVjdDtMLnNjYWxlJiYoRD1bMCwwLGwuY2FudmFzLndpZHRoLGwuY2FudmFzLmhlaWdodF0pLEwucm90YXRlZCYmRCYmKEQ9Wy1EWzFdLERbMF0sRFszXSxEWzJdXSksQyYmKEQ9RHx8WzAsMCxDWzJdLENbM11dKSxMLnJvdGF0ZWQmJihsLnRyYW5zbGF0ZSgwLEQ/RFsyXTpQLndpZHRoKSxsLnJvdGF0ZSgtLjUqTWF0aC5QSSkpLEM/bC5kcmF3SW1hZ2UoUCwuLi5DLC4uLkQpOkQ/bC5kcmF3SW1hZ2UoUCwuLi5EKTpsLmRyYXdJbWFnZShQLDAsMCl9bC5yZXN0b3JlKCl9TSYmbC5zdHJva2UoKX19KSxsLnJlc3RvcmUoKSx5KXtjb25zdCBmPXAuZmlsdGVyO2YmJnUobCxmKX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjbGFtcCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJtaXgiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwidHJhbnNmb3JtUG9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihnLHUsbyl7cmV0dXJuIHU+byYmKFt1LG9dPVtvLHVdKSxnPHU/dTpnPm8/bzpnfWZ1bmN0aW9uIG4oZyx1LG8pe3JldHVybiBnKigxLW8pK3Uqb31mdW5jdGlvbiBkKGcsdSl7Y29uc3RbbyxjXT1nO3JldHVybltvKnVbMF0rYyp1WzJdK3VbNF0sbyp1WzFdK2MqdVszXSt1WzVdXX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KTt2YXIgcj10KDI4KSxuPXQoMjkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBkKGMscCxsKXtjb25zdCB5PWMudW5pZm9ybXN8fHt9LHg9cC51bmlmb3Jtc3x8e307aWYoeS51X3RleFNhbXBsZXImJngudV90ZXhTYW1wbGVyJiZ5LnVfdGV4U2FtcGxlciE9PXgudV90ZXhTYW1wbGVyKXJldHVybiExO2NvbnN0IGI9T2JqZWN0LmtleXMoeSksRT1PYmplY3Qua2V5cyh4KSx2PWIuaW5kZXhPZigidV90ZXhTYW1wbGVyIiksTT1FLmluZGV4T2YoInVfdGV4U2FtcGxlciIpO2lmKHY+PTAmJmIuc3BsaWNlKHYsMSksTT49MCYmRS5zcGxpY2UoTSwxKSxiLmxlbmd0aCE9PUUubGVuZ3RoKXJldHVybiExO2NvbnN0IGk9Yi5ldmVyeShhPT57Y29uc3Qgcz15W2FdLGY9eFthXTtpZihzPT09ZilyZXR1cm4hMDtpZihzLmxlbmd0aCYmZi5sZW5ndGgmJnMubGVuZ3RoPT09Zi5sZW5ndGgpe2ZvcihsZXQgTz0wO088cy5sZW5ndGg7TysrKWlmKHNbT10hPT1mW09dKXJldHVybiExO3JldHVybiEwfXJldHVybiExfSk7aWYoaSl7aWYoeS51X3RleFNhbXBsZXImJiF4LnVfdGV4U2FtcGxlcilwLnNldFRleHR1cmUoeS51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pO2Vsc2UgaWYoIXkudV90ZXhTYW1wbGVyJiZ4LnVfdGV4U2FtcGxlcilmb3IobGV0IGE9MDthPGwubGVuZ3RoO2ErKylsW2FdLnNldFRleHR1cmUoeC51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pfXJldHVybiBpfWNvbnN0IGc9e307ZnVuY3Rpb24gdShjLHApe2lmKGMubGVuZ3RoKXtjb25zdCBsPU9iamVjdChyLmRlZmF1bHQpKGMsZyk7cmV0dXJuIGwuZW5hYmxlQmxlbmQ9cCxjWzBdLmZpbHRlckNhbnZhcyYmKGwuZmlsdGVyQ2FudmFzPSEwKSxsLnBhY2tJbmRleD1jWzBdLnBhY2tJbmRleCxsLnBhY2tMZW5ndGg9Yy5sZW5ndGgsbC5iZWZvcmVSZW5kZXI9Y1swXS5iZWZvcmVSZW5kZXIsbC5wYXNzPWNbMF0ucGFzcyxsLmFmdGVyUmVuZGVyPWNbYy5sZW5ndGgtMV0uYWZ0ZXJSZW5kZXIsYy5sZW5ndGg9MCxsfX1mdW5jdGlvbipvKGMscCxsPSExKXtjb25zdCB5PVtdLHg9Yy5vcHRpb25zLmJ1ZmZlclNpemU7bGV0IGI9MCxFPSExO2ZvcihsZXQgdj0wO3Y8cC5sZW5ndGg7disrKXtjb25zdCBNPXBbdl07aWYoTSBpbnN0YW5jZW9mIG4uZGVmYXVsdCl5Lmxlbmd0aCYmKHlpZWxkIHUoeSxFKSksYj0wLEU9ITEseWllbGQgTTtlbHNle2NvbnN0IGk9TS5tZXNoRGF0YTtpZihpLmNsaXBQYXRoJiYhaS51bmlmb3Jtcy51X2NsaXBTYW1wbGVyKXtjb25zdCBzPWMuY3JlYXRlVGV4dHVyZShpLmNsaXBQYXRoKTtpLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI9c31sZXQgYT0wO2lmKCghbHx8IU0uY2FuSWdub3JlKCkpJiZpJiZpLnBvc2l0aW9ucy5sZW5ndGgpe00ucGFja0luZGV4PXY7Y29uc3Qgcz1NLmZpbHRlckNhbnZhcztpZihhPWkucG9zaXRpb25zLmxlbmd0aCxzfHxiK2E+eCl5Lmxlbmd0aCYmKHlpZWxkIHUoeSxFKSksYj0wLEU9ITE7ZWxzZSBpZihiKXtjb25zdCBmPXlbeS5sZW5ndGgtMV07ZiYmKGYuZmlsdGVyQ2FudmFzfHxmLmFmdGVyUmVuZGVyfHxNLmJlZm9yZVJlbmRlcnx8Zi5wYXNzLmxlbmd0aHx8TS5wYXNzLmxlbmd0aHx8Zi5wcm9ncmFtIT09TS5wcm9ncmFtfHwhZChmLE0seSkpJiYoeWllbGQgdSh5LEUpLGI9MCxFPSExKX15LnB1c2goTSksRT1FfHxNLmVuYWJsZUJsZW5kLGIrPWF9dj09PXAubGVuZ3RoLTEmJnkubGVuZ3RoJiYoeWllbGQgdSh5LEUpKX19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPXtVTlNJR05FRF9CWVRFOlVpbnQ4QXJyYXksVU5TSUdORURfU0hPUlQ6VWludDE2QXJyYXksQllURTpJbnQ4QXJyYXksU0hPUlQ6SW50MTZBcnJheSxGTE9BVDpGbG9hdDMyQXJyYXl9O2Z1bmN0aW9uIG4oZyx1KXtsZXQgbz0wLGM9MCxwPTAsbD0wLHk9MCx4PTAsYj0wO2NvbnN0IEU9Z1swXS5wcm9ncmFtO2ZvcihsZXQgdj0wO3Y8Zy5sZW5ndGg7disrKXtjb25zdCBNPWdbdl0ubWVzaERhdGE7aWYoTSl7Yis9TS5wb3NpdGlvbnMubGVuZ3RoO2NvbnN0IGk9TS5wb3NpdGlvbnNbMF0ubGVuZ3RoO28rPU0ucG9zaXRpb25zLmxlbmd0aCppLGMrPU0uY2VsbHMubGVuZ3RoKjMseCs9TS5hdHRyaWJ1dGVzLmFfY29sb3IubGVuZ3RoKjQ7Y29uc3QgYT1NLnRleHR1cmVDb29yZDthJiYocCs9YS5sZW5ndGgqYVswXS5sZW5ndGgpO2NvbnN0IHM9TS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDtzJiYobCs9cy5sZW5ndGgqNCk7Y29uc3QgZj1NLmF0dHJpYnV0ZXMuYV9jbGlwVVY7ZiYmKHkrPWYubGVuZ3RoKjIpfX1pZigoIXUucG9zaXRpb25zfHx1LnBvc2l0aW9ucy5sZW5ndGg8bykmJih1LnBvc2l0aW9ucz1uZXcgRmxvYXQzMkFycmF5KG8pKSwoIXUuY2VsbHN8fHUuY2VsbHMubGVuZ3RoPGMpJiYodS5jZWxscz1uZXcgVWludDE2QXJyYXkoYykpLHAmJighdS50ZXh0dXJlQ29vcmR8fHUudGV4dHVyZUNvb3JkLmxlbmd0aDxwKSYmKHUudGV4dHVyZUNvb3JkPW5ldyBGbG9hdDMyQXJyYXkocCkpLCghdS5hX2NvbG9yfHx1LmFfY29sb3IubGVuZ3RoPHgpJiYodS5hX2NvbG9yPW5ldyBVaW50OEFycmF5KHgpKSxsJiYoIXUuYV9zb3VyY2VSZWN0fHx1LmFfc291cmNlUmVjdC5sZW5ndGg8bCkmJih1LmFfc291cmNlUmVjdD1uZXcgRmxvYXQzMkFycmF5KGwpKSx5JiYoIXUuYV9jbGlwVVZ8fHUuYV9jbGlwVVYubGVuZ3RoPHkpJiYodS5hX2NsaXBVVj1uZXcgRmxvYXQzMkFycmF5KHkpKSxFKXtjb25zdCB2PU9iamVjdC5lbnRyaWVzKEUuX2F0dHJpYnV0ZSksTT1FLl9hdHRyaWJPcHRzfHx7fTtmb3IobGV0IGk9MDtpPHYubGVuZ3RoO2krKyl7Y29uc3RbYSxzXT12W2ldO2lmKGEhPT0iYV9jb2xvciImJmEhPT0iYV9zb3VyY2VSZWN0IiYmcyE9PSJpZ25vcmVkIil7Y29uc3QgZj1NW2FdP01bYV0udHlwZToiRkxPQVQiLE89cltmXSxBPXMuc2l6ZSpiOyghdVthXXx8dVthXS5sZW5ndGg8QSkmJih1W2FdPW5ldyBPKEEpKX19fXJldHVybiB1fWZ1bmN0aW9uIGQoZyx1KXtsZXQgbz1bXSxjPVtdLHA9W10sbD1bXSx5PVtdLHg9W10sYj0wLEU9MDtjb25zdCB2PWdbMF0/Z1swXS51bmlmb3Jtc3x8e306e30sTT1nWzBdP2dbMF0ucHJvZ3JhbTpudWxsO3UmJihuKGcsdSksYz11LmNlbGxzLG89dS5wb3NpdGlvbnMscD11LnRleHR1cmVDb29yZCxsPXUuYV9jb2xvcix5PXUuYV9zb3VyY2VSZWN0LHg9dS5hX2NsaXBVVik7bGV0IGk9ITEsYT0hMTtjb25zdCBzPXt9O2ZvcihsZXQgTz0wO088Zy5sZW5ndGg7TysrKXtsZXQgQT1nW09dO2lmKEEpe2lmKEEubWVzaERhdGEmJihBPUEubWVzaERhdGEpLHUpe2NvbnN0IEk9QS5wb3NpdGlvbnM7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEw9SVtQXSxEPTMqKGIrUCk7Zm9yKGxldCBDPTA7QzxMLmxlbmd0aDtDKyspb1tEK0NdPUxbQ119fWVsc2Ugby5wdXNoKC4uLkEucG9zaXRpb25zKTtjb25zdCBSPUEuY2VsbHM7Zm9yKGxldCBJPTA7STxSLmxlbmd0aDtJKyspe2NvbnN0IFA9UltJXTtpZih1KXtjb25zdCBMPTMqKEUrSSk7Y1tMXT1QWzBdK2IsY1tMKzFdPVBbMV0rYixjW0wrMl09UFsyXStifWVsc2UgYy5wdXNoKFtQWzBdK2IsUFsxXStiLFBbMl0rYl0pfWlmKHUpe2NvbnN0IEk9QS5hdHRyaWJ1dGVzLmFfY29sb3I7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEw9SVtQXSxEPTQqKGIrUCk7bFtEXT1MWzBdLGxbRCsxXT1MWzFdLGxbRCsyXT1MWzJdLGxbRCszXT1MWzNdfX1lbHNlIGwucHVzaCguLi5BLmF0dHJpYnV0ZXMuYV9jb2xvcik7aWYoQS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdClpZihpPSEwLHUpe2NvbnN0IEk9QS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDtmb3IobGV0IFA9MDtQPEkubGVuZ3RoO1ArKyl7Y29uc3QgTD1JW1BdLEQ9NCooYitQKTt5W0RdPUxbMF0seVtEKzFdPUxbMV0seVtEKzJdPUxbMl0seVtEKzNdPUxbM119fWVsc2UgeS5wdXNoKC4uLkEuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3QpO2lmKEEuYXR0cmlidXRlcy5hX2NsaXBVVilpZihhPSEwLHUpe2NvbnN0IEk9QS5hdHRyaWJ1dGVzLmFfY2xpcFVWO2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdCBMPUlbUF0sRD0yKihiK1ApO3hbRF09TFswXSx4W0QrMV09TFsxXX19ZWxzZSB4LnB1c2goLi4uQS5hdHRyaWJ1dGVzLmFfY2xpcFVWKTtpZihBLnRleHR1cmVDb29yZClpZih1KXtjb25zdCBJPUEudGV4dHVyZUNvb3JkO2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdCBMPUlbUF0sRD0zKihiK1ApO2ZvcihsZXQgQz0wO0M8TC5sZW5ndGg7QysrKXBbRCtDXT1MW0NdfX1lbHNlIHAucHVzaCguLi5BLnRleHR1cmVDb29yZCk7aWYoTSl7Y29uc3QgST1PYmplY3QuZW50cmllcyhNLl9hdHRyaWJ1dGUpO2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdFtMLERdPUlbUF07aWYoTCE9PSJhX2NvbG9yIiYmTCE9PSJhX3NvdXJjZVJlY3QiJiZEIT09Imlnbm9yZWQiKWlmKHNbTF09W10sdSl7c1tMXT11W0xdO2NvbnN0IEM9QS5hdHRyaWJ1dGVzW0xdLFM9Q1swXS5sZW5ndGg7Zm9yKGxldCBCPTA7QjxDLmxlbmd0aDtCKyspe2NvbnN0IHc9Q1tCXSxIPVMqKGIrQik7Zm9yKGxldCBaPTA7Wjx3Lmxlbmd0aDtaKyspc1tMXVtIK1pdPXdbWl19fWVsc2Ugc1tMXS5wdXNoKC4uLkEuYXR0cmlidXRlc1tMXSl9fWIrPUEucG9zaXRpb25zLmxlbmd0aCxFKz1BLmNlbGxzLmxlbmd0aH19cy5hX2NvbG9yPWwsaSYmeSYmeS5sZW5ndGg+MCYmKHMuYV9zb3VyY2VSZWN0PXkpO2NvbnN0IGY9e3Bvc2l0aW9uczpvLGNlbGxzOmMsYXR0cmlidXRlczpzLHVuaWZvcm1zOnYsY2VsbHNDb3VudDpFKjMscHJvZ3JhbTpNfTtyZXR1cm4gcCYmcC5sZW5ndGgmJihmLnRleHR1cmVDb29yZD1wKSxhJiZ4Lmxlbmd0aD4wJiYocy5hX2NsaXBVVj14KSxmfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKTt2YXIgcj10KDEpLG49dCgzMCksZD10KDI2KSxnPXQoMzEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KHMsZil7dmFyIE89T2JqZWN0LmtleXMocyk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEE9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTtmJiYoQT1BLmZpbHRlcihmdW5jdGlvbihSKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzLFIpLmVudW1lcmFibGV9KSksTy5wdXNoLmFwcGx5KE8sQSl9cmV0dXJuIE99ZnVuY3Rpb24gbyhzKXtmb3IodmFyIGY9MTtmPGFyZ3VtZW50cy5sZW5ndGg7ZisrKXt2YXIgTz1hcmd1bWVudHNbZl0hPW51bGw/YXJndW1lbnRzW2ZdOnt9O2YlMj91KE9iamVjdChPKSwhMCkuZm9yRWFjaChmdW5jdGlvbihBKXtjKHMsQSxPW0FdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHMsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoTykpOnUoT2JqZWN0KE8pKS5mb3JFYWNoKGZ1bmN0aW9uKEEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLEEsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLEEpKX0pfXJldHVybiBzfWZ1bmN0aW9uIGMocyxmLE8pe3JldHVybiBmIGluIHM/T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsZix7dmFsdWU6TyxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnNbZl09TyxzfWNvbnN0IHA9U3ltYm9sKCJtZXNoIiksbD1TeW1ib2woImNvdW50IikseT1TeW1ib2woImJsZW5kIikseD1TeW1ib2woImZpbHRlciIpLGI9U3ltYm9sKCJ0ZXh0dXJlcyIpLEU9U3ltYm9sKCJ0ZXh0dXJlT3B0aW9ucyIpLHY9U3ltYm9sKCJjbG91ZENvbG9yIiksTT1TeW1ib2woImNsb3VkRmlsdGVyIiksaT1TeW1ib2woImJ1ZmZlciIpO2Z1bmN0aW9uIGEocyxmPW51bGwpe2NvbnN0IE89bmV3IEZsb2F0MzJBcnJheSgzKnMpLEE9bmV3IEZsb2F0MzJBcnJheSgzKnMpLFI9bmV3IEZsb2F0MzJBcnJheSg0KnMpLEk9bmV3IEZsb2F0MzJBcnJheSg0KnMpLFA9bmV3IEZsb2F0MzJBcnJheSg0KnMpLEw9bmV3IEZsb2F0MzJBcnJheSg0KnMpLEQ9bmV3IEZsb2F0MzJBcnJheSg0KnMpLEM9bmV3IFVpbnQ4QXJyYXkocyksUz1uZXcgVWludDhBcnJheSg0KnMpLEI9bmV3IFVpbnQ4QXJyYXkoNCpzKTtyZXR1cm4gZiYmKE8uc2V0KGYudHJhbnNmb3JtMCwwKSxBLnNldChmLnRyYW5zZm9ybTEsMCksUi5zZXQoZi5jb2xvcjAsMCksSS5zZXQoZi5jb2xvcjEsMCksUC5zZXQoZi5jb2xvcjIsMCksTC5zZXQoZi5jb2xvcjMsMCksRC5zZXQoZi5jb2xvcjQsMCksQy5zZXQoZi5mcmFtZUluZGV4LDApLFMuc2V0KGYuZmlsbENvbG9yLDApLEIuc2V0KGYuc3Ryb2tlQ29sb3IsMCkpLHtidWZmZXJTaXplOnMsdHJhbnNmb3JtMDpPLHRyYW5zZm9ybTE6QSxjb2xvcjA6Uixjb2xvcjE6SSxjb2xvcjI6UCxjb2xvcjM6TCxjb2xvcjQ6RCxmcmFtZUluZGV4OkMsZmlsbENvbG9yOlMsc3Ryb2tlQ29sb3I6Qn19ZS5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKHMsZj0xLHtidWZmZXI6Tz0xZTN9PXt9KXtPPU1hdGgubWF4KE8sZiksdGhpc1tsXT1mLHRoaXNbcF09cyx0aGlzW2ldPWEoTyksdGhpc1tiXT1bXSx0aGlzW3hdPVtdLHRoaXNbdl09ITEsdGhpc1tNXT0hMSx0aGlzW3ldPSExLHRoaXMuaW5pdEJ1ZmZlcigpfWluaXRCdWZmZXIocz0wKXtjb25zdCBmPXRoaXNbbF07Zm9yKGxldCBPPXM7TzxmO08rKyl0aGlzW2ldLnRyYW5zZm9ybTAuc2V0KFsxLDAsMF0sTyozKSx0aGlzW2ldLnRyYW5zZm9ybTEuc2V0KFswLDEsMF0sTyozKSx0aGlzW2ldLmZyYW1lSW5kZXguc2V0KFstMV0sTyksdGhpc1tpXS5maWxsQ29sb3Iuc2V0KFswLDAsMCwwXSxPKjQpLHRoaXNbaV0uc3Ryb2tlQ29sb3Iuc2V0KFswLDAsMCwwXSxPKjQpLHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0oTyxudWxsKX1nZXQgYnVmZmVyU2l6ZSgpe3JldHVybiB0aGlzW2ldLmJ1ZmZlclNpemV9Z2V0IG1lc2goKXtyZXR1cm4gdGhpc1twXX1zZXQgbWVzaChzKXt0aGlzW3BdPXMsdGhpc1tiXSYmdGhpcy5zZXRUZXh0dXJlRnJhbWVzKHRoaXNbYl0sdGhpc1tFXSl9Z2V0IGhhc0Nsb3VkQ29sb3IoKXtyZXR1cm4gdGhpc1t2XX1nZXQgaGFzQ2xvdWRGaWx0ZXIoKXtyZXR1cm4gdGhpc1tNXX1fZ2V0RmlsdGVyKHMpe3JldHVybiB0aGlzW3hdW3NdPXRoaXNbeF1bc118fFtdLHRoaXNbeF1bc119Z2V0RmlsdGVyKHMpe3JldHVybiB0aGlzLl9nZXRGaWx0ZXIocykuam9pbigiICIpfWdldCBlbmFibGVCbGVuZCgpe3JldHVybiB0aGlzW3BdLmVuYWJsZUJsZW5kfHx0aGlzW3ldfWNhbklnbm9yZSgpe3JldHVybiB0aGlzW3BdLmNhbklnbm9yZSgpfWRlbGV0ZShzKXtpZihzPj10aGlzW2xdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Y29uc3R7dHJhbnNmb3JtMDpmLHRyYW5zZm9ybTE6Tyxjb2xvcjA6QSxjb2xvcjE6Uixjb2xvcjI6SSxjb2xvcjM6UCxjb2xvcjQ6TCxmcmFtZUluZGV4OkQsZmlsbENvbG9yOkMsc3Ryb2tlQ29sb3I6U309dGhpc1tpXTtmLnNldChmLnN1YmFycmF5KDMqKHMrMSkpLDMqcyksTy5zZXQoTy5zdWJhcnJheSgzKihzKzEpKSwzKnMpLEEuc2V0KEEuc3ViYXJyYXkoNCoocysxKSksNCpzKSxSLnNldChSLnN1YmFycmF5KDQqKHMrMSkpLDQqcyksSS5zZXQoSS5zdWJhcnJheSg0KihzKzEpKSw0KnMpLFAuc2V0KFAuc3ViYXJyYXkoNCoocysxKSksNCpzKSxMLnNldChMLnN1YmFycmF5KDQqKHMrMSkpLDQqcyksRC5zZXQoRC5zdWJhcnJheShzKzEpLHMpLEMuc2V0KEMuc3ViYXJyYXkoNCoocysxKSksNCpzKSxTLnNldChTLnN1YmFycmF5KDQqKHMrMSkpLDQqcyk7Zm9yKGNvbnN0IEIgaW4gdGhpc1t4XSlCPT09cz9kZWxldGUgdGhpc1t4XVtCXTpCPnMmJih0aGlzW3hdW0ItMV09dGhpc1t4XVtCXSxkZWxldGUgdGhpc1t4XVtCXSk7dGhpc1tsXS0tfXNldENvbG9yVHJhbnNmb3JtKHMsZil7aWYocz49dGhpc1tsXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3MqPTQ7Y29uc3R7Y29sb3IwOk8sY29sb3IxOkEsY29sb3IyOlIsY29sb3IzOkksY29sb3I0OlB9PXRoaXNbaV07cmV0dXJuIGYhPW51bGw/KE8uc2V0KFtmWzBdLGZbNV0sZlsxMF0sZlsxNV1dLHMpLEEuc2V0KFtmWzFdLGZbNl0sZlsxMV0sZlsxNl1dLHMpLFIuc2V0KFtmWzJdLGZbN10sZlsxMl0sZlsxN11dLHMpLEkuc2V0KFtmWzNdLGZbOF0sZlsxM10sZlsxOF1dLHMpLFAuc2V0KFtmWzRdLGZbOV0sZlsxNF0sZlsxOV1dLHMpLHRoaXNbeV09dGhpc1t5XXx8ZlsxOF08MSx0aGlzW01dPSEwKTooTy5zZXQoWzEsMCwwLDBdLHMpLEEuc2V0KFswLDEsMCwwXSxzKSxSLnNldChbMCwwLDEsMF0scyksSS5zZXQoWzAsMCwwLDFdLHMpLFAuc2V0KFswLDAsMCwwXSxzKSksdGhpc31nZXRDb2xvclRyYW5zZm9ybShzKXtpZihzPj10aGlzW2xdfHxzPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7cyo9NDtjb25zdHtjb2xvcjA6Zixjb2xvcjE6Tyxjb2xvcjI6QSxjb2xvcjM6Uixjb2xvcjQ6SX09dGhpc1tpXTtyZXR1cm5bZltzXSxPW3NdLEFbc10sUltzXSxJW3NdLGZbcysxXSxPW3MrMV0sQVtzKzFdLFJbcysxXSxJW3MrMV0sZltzKzJdLE9bcysyXSxBW3MrMl0sUltzKzJdLElbcysyXSxmW3MrM10sT1tzKzNdLEFbcyszXSxSW3MrM10sSVtzKzNdXX10cmFuc2Zvcm1Db2xvcihzLGYpe2xldCBPPXRoaXMuZ2V0Q29sb3JUcmFuc2Zvcm0ocyk7cmV0dXJuIE89T2JqZWN0KG4ubXVsdGlwbHkpKE8sZiksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShzLE8pLHRoaXN9c2V0RmlsbENvbG9yKHMsZil7aWYocz49dGhpc1tsXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBmPT0ic3RyaW5nIiYmKGY9T2JqZWN0KGcuZGVmYXVsdCkoZikpLGZbM10+MCYmKHRoaXNbdl09ITApLHRoaXNbaV0uZmlsbENvbG9yLnNldChmLm1hcChPPT5NYXRoLnJvdW5kKDI1NSpPKSksNCpzKX1zZXRTdHJva2VDb2xvcihzLGYpe2lmKHM+PXRoaXNbbF18fHM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTt0eXBlb2YgZj09InN0cmluZyImJihmPU9iamVjdChnLmRlZmF1bHQpKGYpKSxmWzNdPjAmJih0aGlzW3ZdPSEwKSx0aGlzW2ldLnN0cm9rZUNvbG9yLnNldChmLm1hcChPPT5NYXRoLnJvdW5kKDI1NSpPKSksNCpzKX1nZXRDbG91ZFJHQkEocyl7aWYocz49dGhpc1tsXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3MqPTQ7Y29uc3R7ZmlsbENvbG9yOmYsc3Ryb2tlQ29sb3I6T309dGhpc1tpXSxBPVtmW3NdLGZbcysxXSxmW3MrMl0sZltzKzNdXSxSPVtPW3NdLE9bcysxXSxPW3MrMl0sT1tzKzNdXTtyZXR1cm4gQVszXS89MjU1LFJbM10vPTI1NSx7ZmlsbDpgcmdiYSgke0Euam9pbigpfSlgLHN0cm9rZTpgcmdiYSgke1Iuam9pbigpfSlgfX1ncmF5c2NhbGUocyxmKXt0aGlzLnRyYW5zZm9ybUNvbG9yKHMsT2JqZWN0KG4uZ3JheXNjYWxlKShmKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYGdyYXlzY2FsZSgkezEwMCpmfSUpYCl9YnJpZ2h0bmVzcyhzLGYpe3RoaXMudHJhbnNmb3JtQ29sb3IocyxPYmplY3Qobi5icmlnaHRuZXNzKShmKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYGJyaWdodG5lc3MoJHsxMDAqZn0lKWApfXNhdHVyYXRlKHMsZil7dGhpcy50cmFuc2Zvcm1Db2xvcihzLE9iamVjdChuLnNhdHVyYXRlKShmKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYHNhdHVyYXRlKCR7MTAwKmZ9JSlgKX1jb250cmFzdChzLGYpe3RoaXMudHJhbnNmb3JtQ29sb3IocyxPYmplY3Qobi5jb250cmFzdCkoZikpLHRoaXMuX2dldEZpbHRlcihzKS5wdXNoKGBjb250cmFzdCgkezEwMCpmfSUpYCl9aW52ZXJ0KHMsZil7dGhpcy50cmFuc2Zvcm1Db2xvcihzLE9iamVjdChuLmludmVydCkoZikpLHRoaXMuX2dldEZpbHRlcihzKS5wdXNoKGBpbnZlcnQoJHsxMDAqZn0lKWApfXNlcGlhKHMsZil7dGhpcy50cmFuc2Zvcm1Db2xvcihzLE9iamVjdChuLnNlcGlhKShmKSksdGhpcy5fZ2V0RmlsdGVyKHMpLnB1c2goYHNlcGlhKCR7MTAwKmZ9JSlgKX1vcGFjaXR5KHMsZil7dGhpcy50cmFuc2Zvcm1Db2xvcihzLE9iamVjdChuLm9wYWNpdHkpKGYpKSx0aGlzLl9nZXRGaWx0ZXIocykucHVzaChgb3BhY2l0eSgkezEwMCpmfSUpYCl9aHVlUm90YXRlKHMsZil7dGhpcy50cmFuc2Zvcm1Db2xvcihzLE9iamVjdChuLmh1ZVJvdGF0ZSkoZikpLHRoaXMuX2dldEZpbHRlcihzKS5wdXNoKGBodWUtcm90YXRlKCR7Zn1kZWcpYCl9c2V0VHJhbnNmb3JtKHMsZil7aWYocz49dGhpc1tsXXx8czwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3MqPTMsZj09bnVsbCYmKGY9WzEsMCwwLDEsMCwwXSk7Y29uc3R7dHJhbnNmb3JtMDpPLHRyYW5zZm9ybTE6QX09dGhpc1tpXTtyZXR1cm4gTy5zZXQoW2ZbMF0sZlsyXSxmWzRdXSxzKSxBLnNldChbZlsxXSxmWzNdLGZbNV1dLHMpLHRoaXN9Z2V0VHJhbnNmb3JtKHMpe2lmKHM+PXRoaXNbbF18fHM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtzKj0zO2NvbnN0e3RyYW5zZm9ybTA6Zix0cmFuc2Zvcm0xOk99PXRoaXNbaV07cmV0dXJuW2Zbc10sT1tzXSxmW3MrMV0sT1tzKzFdLGZbcysyXSxPW3MrMl1dfWdldFRleHR1cmVGcmFtZShzKXtyZXR1cm4gdGhpc1tiXVt0aGlzW2ldLmZyYW1lSW5kZXhbc11dfXNldFRleHR1cmVGcmFtZXMocz1bXSxmPXt9KXtpZihzLmxlbmd0aD4xMil0aHJvdyBuZXcgRXJyb3IoIk1heCBmcmFtZXMgZXhjZWVkLiBBbGxvdyAxMiBmcmFtZXMuIik7cy5sZW5ndGgmJnRoaXNbcF0uc2V0VGV4dHVyZShzWzBdLGYpLHRoaXNbYl09cyx0aGlzW0VdPWZ9c2V0RnJhbWVJbmRleChzLGYpe2lmKHM+PXRoaXNbbF18fHM8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdCBPPXRoaXNbYl0ubGVuZ3RoO2lmKE88PTApdGhyb3cgbmV3IEVycm9yKCJObyBmcmFtZXMiKTt0aGlzW2ldLmZyYW1lSW5kZXhbc109ZiVPfWdldCBhbW91bnQoKXtyZXR1cm4gdGhpc1tsXX1zZXQgYW1vdW50KHMpe2NvbnN0IGY9dGhpc1tsXTtzIT09ZiYmKHM+dGhpc1tpXS5idWZmZXJTaXplJiYodGhpc1tpXT1hKE1hdGgubWF4KHMsdGhpc1tpXS5idWZmZXJTaXplKzFlMyksdGhpc1tpXSkpLHRoaXNbbF09cyxzPmYmJnRoaXMuaW5pdEJ1ZmZlcihmKSl9Z2V0IG1lc2hEYXRhKCl7Y29uc3R7YXR0cmlidXRlczpzLGNlbGxzOmYscG9zaXRpb25zOk8sdGV4dHVyZUNvb3JkOkEsdW5pZm9ybXM6Un09dGhpc1twXS5tZXNoRGF0YSxJPXRoaXNbYl0sUD17YXR0cmlidXRlczpvKHt9LHMpLGNlbGxzOmYscG9zaXRpb25zOk8sdGV4dHVyZUNvb3JkOkEsdW5pZm9ybXM6byh7fSxSKSxpbnN0YW5jZUNvdW50OnRoaXNbbF0sZW5hYmxlQmxlbmQ6dGhpcy5lbmFibGVCbGVuZH07SS5sZW5ndGgmJkkuZm9yRWFjaCgoRyxKKT0+e1AudW5pZm9ybXNbYHVfdGV4RnJhbWUke0p9YF09R30pO2NvbnN0e3RyYW5zZm9ybTA6TCx0cmFuc2Zvcm0xOkQsY29sb3IwOkMsY29sb3IxOlMsY29sb3IyOkIsY29sb3IzOncsY29sb3I0OkgsZmlsbENvbG9yOlosc3Ryb2tlQ29sb3I6cSxmcmFtZUluZGV4OlV9PXRoaXNbaV07cmV0dXJuIHRoaXNbcF0udW5pZm9ybXMudV90ZXhTYW1wbGVyJiYoUC5hdHRyaWJ1dGVzLmFfZnJhbWVJbmRleD17ZGF0YTpVLGRpdmlzb3I6MX0pLFAuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTA9e2RhdGE6TCxkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTE9e2RhdGE6RCxkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQwPXtkYXRhOkMsZGl2aXNvcjoxfSxQLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMT17ZGF0YTpTLGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDI9e2RhdGE6QixkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQzPXtkYXRhOncsZGl2aXNvcjoxfSxQLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkND17ZGF0YTpILGRpdmlzb3I6MX0sdGhpcy5oYXNDbG91ZENvbG9yJiYoUC5hdHRyaWJ1dGVzLmFfZmlsbENsb3VkQ29sb3I9e2RhdGE6WixkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX3N0cm9rZUNsb3VkQ29sb3I9e2RhdGE6cSxkaXZpc29yOjF9KSxQfXNldFByb2dyYW0ocyl7dGhpc1twXS5zZXRQcm9ncmFtKHMpfWdldCBwcm9ncmFtKCl7cmV0dXJuIHRoaXNbcF0ucHJvZ3JhbX10cmFuc2Zvcm0ocyxmKXtjb25zdCBPPXRoaXMuZ2V0VHJhbnNmb3JtKHMpO3JldHVybiBmPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLE8sZiksdGhpcy5zZXRUcmFuc2Zvcm0ocyxmKSx0aGlzfXRyYW5zbGF0ZShzLFtmLE9dKXtsZXQgQT1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBBPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxBLFtmLE9dKSx0aGlzLnRyYW5zZm9ybShzLEEpfXJvdGF0ZShzLGYsW08sQV09WzAsMF0pe2xldCBSPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFI9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFIsW08sQV0pLFI9ci5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFIsZiksUj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksUixbLU8sLUFdKSx0aGlzLnRyYW5zZm9ybShzLFIpfXNjYWxlKHMsW2YsTz1mXSxbQSxSXT1bMCwwXSl7bGV0IEk9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gST1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbQSxSXSksST1yLm1hdDJkLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLFtmLE9dKSxJPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLFstQSwtUl0pLHRoaXMudHJhbnNmb3JtKHMsSSl9c2tldyhzLFtmLE89Zl0sW0EsUl09WzAsMF0pe2xldCBJPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEk9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksW0EsUl0pLEk9ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxyLm1hdDJkLmZyb21WYWx1ZXMoMSxNYXRoLnRhbihPKSxNYXRoLnRhbihmKSwxLDAsMCkpLEk9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksWy1BLC1SXSksdGhpcy50cmFuc2Zvcm0ocyxJKX1pc1BvaW50Q29sbGlzaW9uKHMsW2YsT10sQT0iYm90aCIpe2NvbnN0IFI9dGhpcy5nZXRUcmFuc2Zvcm0ocyksST1PYmplY3QoZC50cmFuc2Zvcm1Qb2ludCkoW2YsT10sci5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLFIpKTtyZXR1cm4gdGhpc1twXS5pc1BvaW50Q29sbGlzaW9uKC4uLkksQSl9aXNQb2ludEluRmlsbChzLFtmLE9dKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKHMsW2YsT10sImZpbGwiKX1pc1BvaW50SW5TdHJva2UocyxbZixPXSl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihzLFtmLE9dLCJzdHJva2UiKX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJncmF5c2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiYnJpZ2h0bmVzcyIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJzYXR1cmF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJjb250cmFzdCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2VwaWEiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwib3BhY2l0eSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJodWVSb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbih4LGIpe2NvbnN0IEU9W10sdj14WzBdLE09eFsxXSxpPXhbMl0sYT14WzNdLHM9eFs0XSxmPXhbNV0sTz14WzZdLEE9eFs3XSxSPXhbOF0sST14WzldLFA9eFsxMF0sTD14WzExXSxEPXhbMTJdLEM9eFsxM10sUz14WzE0XSxCPXhbMTVdLHc9eFsxNl0sSD14WzE3XSxaPXhbMThdLHE9eFsxOV07bGV0IFU9YlswXSxHPWJbMV0sSj1iWzJdLHR0PWJbM10sXz1iWzRdO3JldHVybiBFWzBdPVUqditHKmYrSipQK3R0KkIsRVsxXT1VKk0rRypPK0oqTCt0dCp3LEVbMl09VSppK0cqQStKKkQrdHQqSCxFWzNdPVUqYStHKlIrSipDK3R0KlosRVs0XT1VKnMrRypJK0oqUyt0dCpxK18sVT1iWzVdLEc9Yls2XSxKPWJbN10sdHQ9Yls4XSxfPWJbOV0sRVs1XT1VKnYrRypmK0oqUCt0dCpCLEVbNl09VSpNK0cqTytKKkwrdHQqdyxFWzddPVUqaStHKkErSipEK3R0KkgsRVs4XT1VKmErRypSK0oqQyt0dCpaLEVbOV09VSpzK0cqSStKKlMrdHQqcStfLFU9YlsxMF0sRz1iWzExXSxKPWJbMTJdLHR0PWJbMTNdLF89YlsxNF0sRVsxMF09VSp2K0cqZitKKlArdHQqQixFWzExXT1VKk0rRypPK0oqTCt0dCp3LEVbMTJdPVUqaStHKkErSipEK3R0KkgsRVsxM109VSphK0cqUitKKkMrdHQqWixFWzE0XT1VKnMrRypJK0oqUyt0dCpxK18sVT1iWzE1XSxHPWJbMTZdLEo9YlsxN10sdHQ9YlsxOF0sXz1iWzE5XSxFWzE1XT1VKnYrRypmK0oqUCt0dCpCLEVbMTZdPVUqTStHKk8rSipMK3R0KncsRVsxN109VSppK0cqQStKKkQrdHQqSCxFWzE4XT1VKmErRypSK0oqQyt0dCpaLEVbMTldPVUqcytHKkkrSipTK3R0KnErXyxFfWZ1bmN0aW9uIGQoeCl7eD1PYmplY3Qoci5jbGFtcCkoMCwxLHgpO2NvbnN0IGI9LjIxMjYqeCxFPS43MTUyKngsdj0uMDcyMip4O3JldHVybltiKzEteCxFLHYsMCwwLGIsRSsxLXgsdiwwLDAsYixFLHYrMS14LDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIGcoeCl7cmV0dXJuW3gsMCwwLDAsMCwwLHgsMCwwLDAsMCwwLHgsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gdSh4KXtjb25zdCBiPS4yMTI2KigxLXgpLEU9LjcxNTIqKDEteCksdj0uMDcyMiooMS14KTtyZXR1cm5bYit4LEUsdiwwLDAsYixFK3gsdiwwLDAsYixFLHYreCwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBvKHgpe2NvbnN0IGI9LjUqKDEteCk7cmV0dXJuW3gsMCwwLDAsYiwwLHgsMCwwLGIsMCwwLHgsMCxiLDAsMCwwLDEsMF19ZnVuY3Rpb24gYyh4KXtjb25zdCBiPTEtMip4O3JldHVybltiLDAsMCwwLHgsMCxiLDAsMCx4LDAsMCxiLDAseCwwLDAsMCwxLDBdfWZ1bmN0aW9uIHAoeCl7cmV0dXJuWzEtLjYwNyp4LC43NjkqeCwuMTg5KngsMCwwLC4zNDkqeCwxLS4zMTQqeCwuMTY4KngsMCwwLC4yNzIqeCwuNTM0KngsMS0uODY5KngsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gbCh4KXtyZXR1cm5bMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAseCwwXX1mdW5jdGlvbiB5KHgpe2NvbnN0IGI9eC8xODAqTWF0aC5QSSxFPU1hdGguY29zKGIpLHY9TWF0aC5zaW4oYiksTT0uMjEyNixpPS43MTUyLGE9LjA3MjI7cmV0dXJuW00rRSooMS1NKSt2Ki1NLGkrRSotaSt2Ki1pLGErRSotYSt2KigxLWEpLDAsMCxNK0UqLU0rdiouMTQzLGkrRSooMS1pKSt2Ki4xNCxhK0UqLWErdiotLjI4MywwLDAsTStFKi1NK3YqLSgxLU0pLGkrRSotaSt2KmksYStFKigxLWEpK3YqYSwwLDAsMCwwLDAsMSwwXX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDMyKSxuPXQubihyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZChnKXtjb25zdCB1PW4oKShnKTtpZighdXx8IXUubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY29sb3IgdmFsdWUuIik7cmV0dXJuW3VbMF0vMjU1LHVbMV0vMjU1LHVbMl0vMjU1LHVbM11dfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMzMpLG49dCgzNyksZD10KDM5KTtoLmV4cG9ydHM9ZnVuY3Rpb24odSl7dmFyIG8sYz1yKHUpO3JldHVybiBjLnNwYWNlPyhvPUFycmF5KDMpLG9bMF09ZChjLnZhbHVlc1swXSwwLDI1NSksb1sxXT1kKGMudmFsdWVzWzFdLDAsMjU1KSxvWzJdPWQoYy52YWx1ZXNbMl0sMCwyNTUpLGMuc3BhY2VbMF09PT0iaCImJihvPW4ucmdiKG8pKSxvLnB1c2goZChjLmFscGhhLDAsMSkpLG8pOltdfX0sZnVuY3Rpb24oaCxlLHQpeyhmdW5jdGlvbihyKXt2YXIgbj10KDM0KSxkPXQoMzUpLGc9dCgzNik7aC5leHBvcnRzPW87dmFyIHU9e3JlZDowLG9yYW5nZTo2MCx5ZWxsb3c6MTIwLGdyZWVuOjE4MCxibHVlOjI0MCxwdXJwbGU6MzAwfTtmdW5jdGlvbiBvKGMpe3ZhciBwLGw9W10seT0xLHg7aWYodHlwZW9mIGM9PSJzdHJpbmciKWlmKG5bY10pbD1uW2NdLnNsaWNlKCkseD0icmdiIjtlbHNlIGlmKGM9PT0idHJhbnNwYXJlbnQiKXk9MCx4PSJyZ2IiLGw9WzAsMCwwXTtlbHNlIGlmKC9eI1tBLUZhLWYwLTldKyQvLnRlc3QoYykpe3ZhciBiPWMuc2xpY2UoMSksRT1iLmxlbmd0aCx2PUU8PTQ7eT0xLHY/KGw9W3BhcnNlSW50KGJbMF0rYlswXSwxNikscGFyc2VJbnQoYlsxXStiWzFdLDE2KSxwYXJzZUludChiWzJdK2JbMl0sMTYpXSxFPT09NCYmKHk9cGFyc2VJbnQoYlszXStiWzNdLDE2KS8yNTUpKToobD1bcGFyc2VJbnQoYlswXStiWzFdLDE2KSxwYXJzZUludChiWzJdK2JbM10sMTYpLHBhcnNlSW50KGJbNF0rYls1XSwxNildLEU9PT04JiYoeT1wYXJzZUludChiWzZdK2JbN10sMTYpLzI1NSkpLGxbMF18fChsWzBdPTApLGxbMV18fChsWzFdPTApLGxbMl18fChsWzJdPTApLHg9InJnYiJ9ZWxzZSBpZihwPS9eKCg/OnJnYnxoc1tsdmJdfGh3YnxjbXlrP3x4eVt6eV18Z3JheXxsYWJ8bGNodT92P3xbbHlddXZ8bG1zKWE/KVxzKlwoKFteXCldKilcKS8uZXhlYyhjKSl7dmFyIE09cFsxXSxpPU09PT0icmdiIixiPU0ucmVwbGFjZSgvYSQvLCIiKTt4PWI7dmFyIEU9Yj09PSJjbXlrIj80OmI9PT0iZ3JheSI/MTozO2w9cFsyXS50cmltKCkuc3BsaXQoL1xzKixccyovKS5tYXAoZnVuY3Rpb24oTyxBKXtpZigvJSQvLnRlc3QoTykpcmV0dXJuIEE9PT1FP3BhcnNlRmxvYXQoTykvMTAwOmI9PT0icmdiIj9wYXJzZUZsb2F0KE8pKjI1NS8xMDA6cGFyc2VGbG9hdChPKTtpZihiW0FdPT09ImgiKXtpZigvZGVnJC8udGVzdChPKSlyZXR1cm4gcGFyc2VGbG9hdChPKTtpZih1W09dIT09dm9pZCAwKXJldHVybiB1W09dfXJldHVybiBwYXJzZUZsb2F0KE8pfSksTT09PWImJmwucHVzaCgxKSx5PWl8fGxbRV09PT12b2lkIDA/MTpsW0VdLGw9bC5zbGljZSgwLEUpfWVsc2UgYy5sZW5ndGg+MTAmJi9bMC05XSg/OlxzfFwvKS8udGVzdChjKSYmKGw9Yy5tYXRjaCgvKFswLTldKykvZykubWFwKGZ1bmN0aW9uKHMpe3JldHVybiBwYXJzZUZsb2F0KHMpfSkseD1jLm1hdGNoKC8oW2Etel0pL2lnKS5qb2luKCIiKS50b0xvd2VyQ2FzZSgpKTtlbHNlIGlmKCFpc05hTihjKSl4PSJyZ2IiLGw9W2M+Pj4xNiwoYyY2NTI4MCk+Pj44LGMmMjU1XTtlbHNlIGlmKGQoYykpe3ZhciBhPWcoYy5yLGMucmVkLGMuUixudWxsKTthIT09bnVsbD8oeD0icmdiIixsPVthLGcoYy5nLGMuZ3JlZW4sYy5HKSxnKGMuYixjLmJsdWUsYy5CKV0pOih4PSJoc2wiLGw9W2coYy5oLGMuaHVlLGMuSCksZyhjLnMsYy5zYXR1cmF0aW9uLGMuUyksZyhjLmwsYy5saWdodG5lc3MsYy5MLGMuYixjLmJyaWdodG5lc3MpXSkseT1nKGMuYSxjLmFscGhhLGMub3BhY2l0eSwxKSxjLm9wYWNpdHkhPW51bGwmJih5Lz0xMDApfWVsc2UoQXJyYXkuaXNBcnJheShjKXx8ci5BcnJheUJ1ZmZlciYmQXJyYXlCdWZmZXIuaXNWaWV3JiZBcnJheUJ1ZmZlci5pc1ZpZXcoYykpJiYobD1bY1swXSxjWzFdLGNbMl1dLHg9InJnYiIseT1jLmxlbmd0aD09PTQ/Y1szXToxKTtyZXR1cm57c3BhY2U6eCx2YWx1ZXM6bCxhbHBoYTp5fX19KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXthbGljZWJsdWU6WzI0MCwyNDgsMjU1XSxhbnRpcXVld2hpdGU6WzI1MCwyMzUsMjE1XSxhcXVhOlswLDI1NSwyNTVdLGFxdWFtYXJpbmU6WzEyNywyNTUsMjEyXSxhenVyZTpbMjQwLDI1NSwyNTVdLGJlaWdlOlsyNDUsMjQ1LDIyMF0sYmlzcXVlOlsyNTUsMjI4LDE5Nl0sYmxhY2s6WzAsMCwwXSxibGFuY2hlZGFsbW9uZDpbMjU1LDIzNSwyMDVdLGJsdWU6WzAsMCwyNTVdLGJsdWV2aW9sZXQ6WzEzOCw0MywyMjZdLGJyb3duOlsxNjUsNDIsNDJdLGJ1cmx5d29vZDpbMjIyLDE4NCwxMzVdLGNhZGV0Ymx1ZTpbOTUsMTU4LDE2MF0sY2hhcnRyZXVzZTpbMTI3LDI1NSwwXSxjaG9jb2xhdGU6WzIxMCwxMDUsMzBdLGNvcmFsOlsyNTUsMTI3LDgwXSxjb3JuZmxvd2VyYmx1ZTpbMTAwLDE0OSwyMzddLGNvcm5zaWxrOlsyNTUsMjQ4LDIyMF0sY3JpbXNvbjpbMjIwLDIwLDYwXSxjeWFuOlswLDI1NSwyNTVdLGRhcmtibHVlOlswLDAsMTM5XSxkYXJrY3lhbjpbMCwxMzksMTM5XSxkYXJrZ29sZGVucm9kOlsxODQsMTM0LDExXSxkYXJrZ3JheTpbMTY5LDE2OSwxNjldLGRhcmtncmVlbjpbMCwxMDAsMF0sZGFya2dyZXk6WzE2OSwxNjksMTY5XSxkYXJra2hha2k6WzE4OSwxODMsMTA3XSxkYXJrbWFnZW50YTpbMTM5LDAsMTM5XSxkYXJrb2xpdmVncmVlbjpbODUsMTA3LDQ3XSxkYXJrb3JhbmdlOlsyNTUsMTQwLDBdLGRhcmtvcmNoaWQ6WzE1Myw1MCwyMDRdLGRhcmtyZWQ6WzEzOSwwLDBdLGRhcmtzYWxtb246WzIzMywxNTAsMTIyXSxkYXJrc2VhZ3JlZW46WzE0MywxODgsMTQzXSxkYXJrc2xhdGVibHVlOls3Miw2MSwxMzldLGRhcmtzbGF0ZWdyYXk6WzQ3LDc5LDc5XSxkYXJrc2xhdGVncmV5Ols0Nyw3OSw3OV0sZGFya3R1cnF1b2lzZTpbMCwyMDYsMjA5XSxkYXJrdmlvbGV0OlsxNDgsMCwyMTFdLGRlZXBwaW5rOlsyNTUsMjAsMTQ3XSxkZWVwc2t5Ymx1ZTpbMCwxOTEsMjU1XSxkaW1ncmF5OlsxMDUsMTA1LDEwNV0sZGltZ3JleTpbMTA1LDEwNSwxMDVdLGRvZGdlcmJsdWU6WzMwLDE0NCwyNTVdLGZpcmVicmljazpbMTc4LDM0LDM0XSxmbG9yYWx3aGl0ZTpbMjU1LDI1MCwyNDBdLGZvcmVzdGdyZWVuOlszNCwxMzksMzRdLGZ1Y2hzaWE6WzI1NSwwLDI1NV0sZ2FpbnNib3JvOlsyMjAsMjIwLDIyMF0sZ2hvc3R3aGl0ZTpbMjQ4LDI0OCwyNTVdLGdvbGQ6WzI1NSwyMTUsMF0sZ29sZGVucm9kOlsyMTgsMTY1LDMyXSxncmF5OlsxMjgsMTI4LDEyOF0sZ3JlZW46WzAsMTI4LDBdLGdyZWVueWVsbG93OlsxNzMsMjU1LDQ3XSxncmV5OlsxMjgsMTI4LDEyOF0saG9uZXlkZXc6WzI0MCwyNTUsMjQwXSxob3RwaW5rOlsyNTUsMTA1LDE4MF0saW5kaWFucmVkOlsyMDUsOTIsOTJdLGluZGlnbzpbNzUsMCwxMzBdLGl2b3J5OlsyNTUsMjU1LDI0MF0sa2hha2k6WzI0MCwyMzAsMTQwXSxsYXZlbmRlcjpbMjMwLDIzMCwyNTBdLGxhdmVuZGVyYmx1c2g6WzI1NSwyNDAsMjQ1XSxsYXduZ3JlZW46WzEyNCwyNTIsMF0sbGVtb25jaGlmZm9uOlsyNTUsMjUwLDIwNV0sbGlnaHRibHVlOlsxNzMsMjE2LDIzMF0sbGlnaHRjb3JhbDpbMjQwLDEyOCwxMjhdLGxpZ2h0Y3lhbjpbMjI0LDI1NSwyNTVdLGxpZ2h0Z29sZGVucm9keWVsbG93OlsyNTAsMjUwLDIxMF0sbGlnaHRncmF5OlsyMTEsMjExLDIxMV0sbGlnaHRncmVlbjpbMTQ0LDIzOCwxNDRdLGxpZ2h0Z3JleTpbMjExLDIxMSwyMTFdLGxpZ2h0cGluazpbMjU1LDE4MiwxOTNdLGxpZ2h0c2FsbW9uOlsyNTUsMTYwLDEyMl0sbGlnaHRzZWFncmVlbjpbMzIsMTc4LDE3MF0sbGlnaHRza3libHVlOlsxMzUsMjA2LDI1MF0sbGlnaHRzbGF0ZWdyYXk6WzExOSwxMzYsMTUzXSxsaWdodHNsYXRlZ3JleTpbMTE5LDEzNiwxNTNdLGxpZ2h0c3RlZWxibHVlOlsxNzYsMTk2LDIyMl0sbGlnaHR5ZWxsb3c6WzI1NSwyNTUsMjI0XSxsaW1lOlswLDI1NSwwXSxsaW1lZ3JlZW46WzUwLDIwNSw1MF0sbGluZW46WzI1MCwyNDAsMjMwXSxtYWdlbnRhOlsyNTUsMCwyNTVdLG1hcm9vbjpbMTI4LDAsMF0sbWVkaXVtYXF1YW1hcmluZTpbMTAyLDIwNSwxNzBdLG1lZGl1bWJsdWU6WzAsMCwyMDVdLG1lZGl1bW9yY2hpZDpbMTg2LDg1LDIxMV0sbWVkaXVtcHVycGxlOlsxNDcsMTEyLDIxOV0sbWVkaXVtc2VhZ3JlZW46WzYwLDE3OSwxMTNdLG1lZGl1bXNsYXRlYmx1ZTpbMTIzLDEwNCwyMzhdLG1lZGl1bXNwcmluZ2dyZWVuOlswLDI1MCwxNTRdLG1lZGl1bXR1cnF1b2lzZTpbNzIsMjA5LDIwNF0sbWVkaXVtdmlvbGV0cmVkOlsxOTksMjEsMTMzXSxtaWRuaWdodGJsdWU6WzI1LDI1LDExMl0sbWludGNyZWFtOlsyNDUsMjU1LDI1MF0sbWlzdHlyb3NlOlsyNTUsMjI4LDIyNV0sbW9jY2FzaW46WzI1NSwyMjgsMTgxXSxuYXZham93aGl0ZTpbMjU1LDIyMiwxNzNdLG5hdnk6WzAsMCwxMjhdLG9sZGxhY2U6WzI1MywyNDUsMjMwXSxvbGl2ZTpbMTI4LDEyOCwwXSxvbGl2ZWRyYWI6WzEwNywxNDIsMzVdLG9yYW5nZTpbMjU1LDE2NSwwXSxvcmFuZ2VyZWQ6WzI1NSw2OSwwXSxvcmNoaWQ6WzIxOCwxMTIsMjE0XSxwYWxlZ29sZGVucm9kOlsyMzgsMjMyLDE3MF0scGFsZWdyZWVuOlsxNTIsMjUxLDE1Ml0scGFsZXR1cnF1b2lzZTpbMTc1LDIzOCwyMzhdLHBhbGV2aW9sZXRyZWQ6WzIxOSwxMTIsMTQ3XSxwYXBheWF3aGlwOlsyNTUsMjM5LDIxM10scGVhY2hwdWZmOlsyNTUsMjE4LDE4NV0scGVydTpbMjA1LDEzMyw2M10scGluazpbMjU1LDE5MiwyMDNdLHBsdW06WzIyMSwxNjAsMjIxXSxwb3dkZXJibHVlOlsxNzYsMjI0LDIzMF0scHVycGxlOlsxMjgsMCwxMjhdLHJlYmVjY2FwdXJwbGU6WzEwMiw1MSwxNTNdLHJlZDpbMjU1LDAsMF0scm9zeWJyb3duOlsxODgsMTQzLDE0M10scm95YWxibHVlOls2NSwxMDUsMjI1XSxzYWRkbGVicm93bjpbMTM5LDY5LDE5XSxzYWxtb246WzI1MCwxMjgsMTE0XSxzYW5keWJyb3duOlsyNDQsMTY0LDk2XSxzZWFncmVlbjpbNDYsMTM5LDg3XSxzZWFzaGVsbDpbMjU1LDI0NSwyMzhdLHNpZW5uYTpbMTYwLDgyLDQ1XSxzaWx2ZXI6WzE5MiwxOTIsMTkyXSxza3libHVlOlsxMzUsMjA2LDIzNV0sc2xhdGVibHVlOlsxMDYsOTAsMjA1XSxzbGF0ZWdyYXk6WzExMiwxMjgsMTQ0XSxzbGF0ZWdyZXk6WzExMiwxMjgsMTQ0XSxzbm93OlsyNTUsMjUwLDI1MF0sc3ByaW5nZ3JlZW46WzAsMjU1LDEyN10sc3RlZWxibHVlOls3MCwxMzAsMTgwXSx0YW46WzIxMCwxODAsMTQwXSx0ZWFsOlswLDEyOCwxMjhdLHRoaXN0bGU6WzIxNiwxOTEsMjE2XSx0b21hdG86WzI1NSw5OSw3MV0sdHVycXVvaXNlOls2NCwyMjQsMjA4XSx2aW9sZXQ6WzIzOCwxMzAsMjM4XSx3aGVhdDpbMjQ1LDIyMiwxNzldLHdoaXRlOlsyNTUsMjU1LDI1NV0sd2hpdGVzbW9rZTpbMjQ1LDI0NSwyNDVdLHllbGxvdzpbMjU1LDI1NSwwXSx5ZWxsb3dncmVlbjpbMTU0LDIwNSw1MF19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztoLmV4cG9ydHM9ZnVuY3Rpb24obil7dmFyIGQ7cmV0dXJuIHIuY2FsbChuKT09PSJbb2JqZWN0IE9iamVjdF0iJiYoZD1PYmplY3QuZ2V0UHJvdG90eXBlT2YobiksZD09PW51bGx8fGQ9PT1PYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKylpZihhcmd1bWVudHNbdF0hPT12b2lkIDApcmV0dXJuIGFyZ3VtZW50c1t0XX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDM4KTtoLmV4cG9ydHM9e25hbWU6ImhzbCIsbWluOlswLDAsMF0sbWF4OlszNjAsMTAwLDEwMF0sY2hhbm5lbDpbImh1ZSIsInNhdHVyYXRpb24iLCJsaWdodG5lc3MiXSxhbGlhczpbIkhTTCJdLHJnYjpmdW5jdGlvbihuKXt2YXIgZD1uWzBdLzM2MCxnPW5bMV0vMTAwLHU9blsyXS8xMDAsbyxjLHAsbCx5O2lmKGc9PT0wKXJldHVybiB5PXUqMjU1LFt5LHkseV07dTwuNT9jPXUqKDErZyk6Yz11K2ctdSpnLG89Mip1LWMsbD1bMCwwLDBdO2Zvcih2YXIgeD0wO3g8Mzt4KyspcD1kKzEvMyotKHgtMSkscDwwP3ArKzpwPjEmJnAtLSw2KnA8MT95PW8rKGMtbykqNipwOjIqcDwxP3k9YzozKnA8Mj95PW8rKGMtbykqKDIvMy1wKSo2Onk9byxsW3hdPXkqMjU1O3JldHVybiBsfX0sci5oc2w9ZnVuY3Rpb24obil7dmFyIGQ9blswXS8yNTUsZz1uWzFdLzI1NSx1PW5bMl0vMjU1LG89TWF0aC5taW4oZCxnLHUpLGM9TWF0aC5tYXgoZCxnLHUpLHA9Yy1vLGwseSx4O3JldHVybiBjPT09bz9sPTA6ZD09PWM/bD0oZy11KS9wOmc9PT1jP2w9MisodS1kKS9wOnU9PT1jJiYobD00KyhkLWcpL3ApLGw9TWF0aC5taW4obCo2MCwzNjApLGw8MCYmKGwrPTM2MCkseD0obytjKS8yLGM9PT1vP3k9MDp4PD0uNT95PXAvKGMrbyk6eT1wLygyLWMtbyksW2wseSoxMDAseCoxMDBdfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17bmFtZToicmdiIixtaW46WzAsMCwwXSxtYXg6WzI1NSwyNTUsMjU1XSxjaGFubmVsOlsicmVkIiwiZ3JlZW4iLCJibHVlIl0sYWxpYXM6WyJSR0IiXX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPXQ7ZnVuY3Rpb24gdChyLG4sZCl7cmV0dXJuIG48ZD9yPG4/bjpyPmQ/ZDpyOnI8ZD9kOnI+bj9uOnJ9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBhfSk7dmFyIHI9dCg0MSksbj10Lm4ociksZD10KDQyKSxnPXQubihkKSx1PXQoNDMpLG89dC5uKHUpLGM9dCg0NCkscD10KDQ2KSxsPXQubihwKSx5PXQoNTMpLHg9dCg1NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGI9U3ltYm9sKCJjb250b3VycyIpLEU9U3ltYm9sKCJwYXRoIiksdj1TeW1ib2woInNpbXBsaWZ5IiksTT1TeW1ib2woInNjYWxlIiksaT0yKk1hdGguUEk7Y2xhc3MgYXtjb25zdHJ1Y3RvcihmPXt9KXt0eXBlb2YgZj09InN0cmluZyImJihmPXtwYXRoOmZ9KSxmLnBhdGg/dGhpc1tFXT1uKCkoZi5wYXRoKTp0aGlzW0VdPVtdLHRoaXNbYl09bnVsbCx0aGlzW3ZdPWYuc2ltcGxpZnkhPW51bGw/Zi5zaW1wbGlmeTowLHRoaXNbTV09Zi5zY2FsZSE9bnVsbD9mLnNjYWxlOjJ9Z2V0IGNvbnRvdXJzKCl7bGV0IGY9bnVsbDtpZighdGhpc1tiXSYmdGhpc1tFXSl7Y29uc3QgTz1PYmplY3QoYy5kZWZhdWx0KShvKCkodGhpc1tFXSkpO3RoaXNbYl09bCgpKE8sdGhpc1tNXSx0aGlzW3ZdKSx0aGlzW2JdLnBhdGg9Tyx0aGlzW2JdLnNpbXBsaWZ5PXRoaXNbdl0sdGhpc1tiXS5zY2FsZT10aGlzW01dfXJldHVybiB0aGlzW2JdJiYoZj10aGlzW2JdLm1hcChPPT5bLi4uT10pLGYucGF0aD10aGlzW2JdLnBhdGgsZi5zaW1wbGlmeT10aGlzW2JdLnNpbXBsaWZ5LGYuc2NhbGU9dGhpc1tiXS5zY2FsZSksZn1nZXQgcGF0aCgpe3JldHVybiB0aGlzW0VdfWdldCBzaW1wbGlmeSgpe3JldHVybiB0aGlzW3ZdfWdldCBib3VuZGluZ0JveCgpe2NvbnN0IGY9dGhpcy5jb250b3VycztpZihmJiZmLmxlbmd0aCl7Y29uc3QgTz1mLnJlZHVjZSgoQSxSKT0+Wy4uLkEsLi4uUl0pO3JldHVybiBnKCkoTyl9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBmPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIGY/Wy41KihmWzBdWzBdK2ZbMV1bMF0pLC41KihmWzBdWzFdK2ZbMV1bMV0pXTpbMCwwXX1ub3JtYWxpemUoZj0wLE89MCl7Y29uc3QgQT1PYmplY3QoYy5kZWZhdWx0KShvKCkodGhpc1tFXSkpLm1hcCgoW1IsLi4uSV0pPT57Y29uc3QgUD1bUl07Zm9yKGxldCBMPTA7TDxJLmxlbmd0aDtMKz0yKXtjb25zdCBEPUlbTF0tZixDPUlbTCsxXS1PO1AucHVzaChELEMpfXJldHVybiBQfSk7cmV0dXJuIHRoaXMuYmVnaW5QYXRoKCksdGhpc1tFXS5wdXNoKC4uLkEpLHRoaXN9Z2V0UG9pbnRBdExlbmd0aChmKXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3QoeS5nZXRQb2ludEF0TGVuZ3RoKSh0aGlzW2JdLGYpOm51bGx9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3QoeS5nZXRUb3RhbExlbmd0aCkodGhpc1tiXSk6MH1hZGRQYXRoKGYpe3RoaXNbYl09bnVsbCx0eXBlb2YgZj09InN0cmluZyImJihmPW4oKShmKSksdGhpc1tFXS5wdXNoKC4uLmYpfWJlZ2luUGF0aCgpe3RoaXNbRV09W10sdGhpc1tiXT1udWxsfWNsZWFyKCl7dGhpcy5iZWdpblBhdGgoKX1lbGxpcHNlKGYsTyxBLFIsSSxQLEwsRD0wKXtpZihQKz1JLEwrPUksQTw9MHx8Ujw9MHx8TD09PVApcmV0dXJuO0w8UCYmKEw9UCtpKyhMLVApJWkpLEwtUD5pJiYoTD1QK2kpO2NvbnN0IEM9TC1QO0M+PWkmJihMLT0uMDAxKTtsZXQgUz10aGlzW0VdLmxlbmd0aD4wJiZDPGk/IkwiOiJNIjtjb25zdCBCPU9iamVjdCh4LmdldFBvaW50KShmLE8sQSxSLFApLHc9T2JqZWN0KHguZ2V0UG9pbnQpKGYsTyxBLFIsTCksSD0rIUQ7bGV0IFo9Qz5NYXRoLlBJPzE6MDtEJiYoWj0xLVopLFMrPUIuam9pbigiICIpLFMrPWBBJHtBfSAke1J9IDAgJHtafSAke0h9ICR7dy5qb2luKCIgIil9YCxDPj1pJiYoUys9IloiKSx0aGlzLmFkZFBhdGgoUyl9YXJjKGYsTyxBLFIsSSxQPTApe3JldHVybiB0aGlzLmVsbGlwc2UoZixPLEEsQSwwLFIsSSxQKX1hcmNUbyhmLE8sQSxSLEksUCxMKXt0aGlzW2JdPW51bGwsdGhpc1tFXS5wdXNoKFsiQSIsZixPLEEsUixJLFAsTF0pfW1vdmVUbyhmLE8pe3RoaXNbYl09bnVsbCx0aGlzW0VdLnB1c2goWyJNIixmLE9dKX1saW5lVG8oZixPKXt0aGlzW2JdPW51bGwsdGhpc1tFXS5wdXNoKFsiTCIsZixPXSl9YmV6aWVyQ3VydmVUbyhmLE8sQSxSLEksUCl7dGhpc1tiXT1udWxsLHRoaXNbRV0ucHVzaChbIkMiLGYsTyxBLFIsSSxQXSl9cXVhZHJhdGljQ3VydmVUbyhmLE8sQSxSKXt0aGlzW2JdPW51bGwsdGhpc1tFXS5wdXNoKFsiUSIsZixPLEEsUl0pfXJlY3QoZixPLEEsUil7Y29uc3QgST1gTSR7Zn0gJHtPfUwke2YrQX0gJHtPfUwke2YrQX0gJHtPK1J9TCR7Zn0gJHtPK1J9WmA7dGhpcy5hZGRQYXRoKEkpfWNsb3NlUGF0aCgpe3RoaXNbYl09bnVsbDtsZXQgZj1bXTtjb25zdCBPPXRoaXNbRV0ubGVuZ3RoO08+MCYmKGY9dGhpc1tFXVtPLTFdKSxmWzBdIT09IloiJiZmWzBdIT09InoiJiZ0aGlzW0VdLnB1c2goWyJaIl0pfX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPW47dmFyIHQ9e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0scj0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIG4odSl7dmFyIG89W107cmV0dXJuIHUucmVwbGFjZShyLGZ1bmN0aW9uKGMscCxsKXt2YXIgeT1wLnRvTG93ZXJDYXNlKCk7Zm9yKGw9ZyhsKSx5PT0ibSImJmwubGVuZ3RoPjImJihvLnB1c2goW3BdLmNvbmNhdChsLnNwbGljZSgwLDIpKSkseT0ibCIscD1wPT0ibSI/ImwiOiJMIik7Oyl7aWYobC5sZW5ndGg9PXRbeV0pcmV0dXJuIGwudW5zaGlmdChwKSxvLnB1c2gobCk7aWYobC5sZW5ndGg8dFt5XSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTtvLnB1c2goW3BdLmNvbmNhdChsLnNwbGljZSgwLHRbeV0pKSl9fSksb312YXIgZD0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiBnKHUpe3ZhciBvPXUubWF0Y2goZCk7cmV0dXJuIG8/by5tYXAoTnVtYmVyKTpbXX19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9cjtmdW5jdGlvbiByKG4pe3ZhciBkPW4ubGVuZ3RoO2lmKGQ9PT0wKXJldHVybltbXSxbXV07Zm9yKHZhciBnPW5bMF0ubGVuZ3RoLHU9blswXS5zbGljZSgpLG89blswXS5zbGljZSgpLGM9MTtjPGQ7KytjKWZvcih2YXIgcD1uW2NdLGw9MDtsPGc7KytsKXt2YXIgeT1wW2xdO3VbbF09TWF0aC5taW4odVtsXSx5KSxvW2xdPU1hdGgubWF4KG9bbF0seSl9cmV0dXJuW3Usb119fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz10O2Z1bmN0aW9uIHQocil7dmFyIG49MCxkPTAsZz0wLHU9MDtyZXR1cm4gci5tYXAoZnVuY3Rpb24obyl7bz1vLnNsaWNlKCk7dmFyIGM9b1swXSxwPWMudG9VcHBlckNhc2UoKTtpZihjIT1wKXN3aXRjaChvWzBdPXAsYyl7Y2FzZSJhIjpvWzZdKz1nLG9bN10rPXU7YnJlYWs7Y2FzZSJ2IjpvWzFdKz11O2JyZWFrO2Nhc2UiaCI6b1sxXSs9ZzticmVhaztkZWZhdWx0OmZvcih2YXIgbD0xO2w8by5sZW5ndGg7KW9bbCsrXSs9ZyxvW2wrK10rPXV9c3dpdGNoKHApe2Nhc2UiWiI6Zz1uLHU9ZDticmVhaztjYXNlIkgiOmc9b1sxXTticmVhaztjYXNlIlYiOnU9b1sxXTticmVhaztjYXNlIk0iOmc9bj1vWzFdLHU9ZD1vWzJdO2JyZWFrO2RlZmF1bHQ6Zz1vW28ubGVuZ3RoLTJdLHU9b1tvLmxlbmd0aC0xXX1yZXR1cm4gb30pfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciByPXQoNDUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKHUpe2Zvcih2YXIgbyxjPVtdLHA9MCxsPTAseT0wLHg9MCxiPW51bGwsRT1udWxsLHY9MCxNPTAsaT0wLGE9dS5sZW5ndGg7aTxhO2krKyl7dmFyIHM9dVtpXSxmPXNbMF07c3dpdGNoKGYpe2Nhc2UiTSI6eT1zWzFdLHg9c1syXTticmVhaztjYXNlIkEiOnZhciBPPU9iamVjdChyLmRlZmF1bHQpKHYsTSxzWzZdLHNbN10sc1s0XSxzWzVdLHNbMV0sc1syXSxzWzNdKTtpZighTy5sZW5ndGgpY29udGludWU7Tz1PLm1hcChMPT57Y29uc3RbRCxDLFMsQix3LEgsWixxXT1MO3JldHVybnt4MTpTLHkxOkIseDI6dyx5MjpILHg6Wix5OnF9fSk7Zm9yKHZhciBBPTAsUjtBPE8ubGVuZ3RoO0ErKylSPU9bQV0scz1bIkMiLFIueDEsUi55MSxSLngyLFIueTIsUi54LFIueV0sQTxPLmxlbmd0aC0xJiZjLnB1c2gocyk7YnJlYWs7Y2FzZSJTIjp2YXIgST12LFA9TTsobz09IkMifHxvPT0iUyIpJiYoSSs9SS1wLFArPVAtbCkscz1bIkMiLEksUCxzWzFdLHNbMl0sc1szXSxzWzRdXTticmVhaztjYXNlIlQiOm89PSJRInx8bz09IlQiPyhiPXYqMi1iLEU9TSoyLUUpOihiPXYsRT1NKSxzPWcodixNLGIsRSxzWzFdLHNbMl0pO2JyZWFrO2Nhc2UiUSI6Yj1zWzFdLEU9c1syXSxzPWcodixNLHNbMV0sc1syXSxzWzNdLHNbNF0pO2JyZWFrO2Nhc2UiTCI6cz1kKHYsTSxzWzFdLHNbMl0pO2JyZWFrO2Nhc2UiSCI6cz1kKHYsTSxzWzFdLE0pO2JyZWFrO2Nhc2UiViI6cz1kKHYsTSx2LHNbMV0pO2JyZWFrO2Nhc2UiWiI6cz1kKHYsTSx5LHgpO2JyZWFrfW89Zix2PXNbcy5sZW5ndGgtMl0sTT1zW3MubGVuZ3RoLTFdLHMubGVuZ3RoPjQ/KHA9c1tzLmxlbmd0aC00XSxsPXNbcy5sZW5ndGgtM10pOihwPXYsbD1NKSxjLnB1c2gocyl9cmV0dXJuIGN9ZnVuY3Rpb24gZCh1LG8sYyxwKXtyZXR1cm5bIkMiLHUsbyxjLHAsYyxwXX1mdW5jdGlvbiBnKHUsbyxjLHAsbCx5KXtyZXR1cm5bIkMiLHUvMysyLzMqYyxvLzMrMi8zKnAsbC8zKzIvMypjLHkvMysyLzMqcCxsLHldfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPU1hdGguUEkqMjtmdW5jdGlvbiBuKG8sYyxwLGwpe2NvbnN0IHk9bypsLWMqcDwwPy0xOjE7bGV0IHg9bypwK2MqbDtyZXR1cm4geD4xJiYoeD0xKSx4PC0xJiYoeD0tMSkseSpNYXRoLmFjb3MoeCl9ZnVuY3Rpb24gZChvLGMscCxsLHkseCxiLEUsdixNKXtjb25zdCBpPU0qKG8tcCkvMit2KihjLWwpLzIsYT0tdiooby1wKS8yK00qKGMtbCkvMixzPWIqYixmPUUqRSxPPWkqaSxBPWEqYTtsZXQgUj1zKmYtcypBLWYqTztSPDAmJihSPTApLFIvPXMqQStmKk8sUj1NYXRoLnNxcnQoUikqKHk9PT14Py0xOjEpO2NvbnN0IEk9UipiL0UqYSxQPVIqLUUvYippLEw9TSpJLXYqUCsobytwKS8yLEQ9dipJK00qUCsoYytsKS8yLEM9KGktSSkvYixTPShhLVApL0UsQj0oLWktSSkvYix3PSgtYS1QKS9FLEg9bigxLDAsQyxTKTtsZXQgWj1uKEMsUyxCLHcpO3JldHVybiB4PT09MCYmWj4wJiYoWi09cikseD09PTEmJlo8MCYmKForPXIpLFtMLEQsSCxaXX1mdW5jdGlvbiBnKG8sYyl7Y29uc3QgcD0xLjMzMzMzMzMzMzMzMzMzMzMqTWF0aC50YW4oYy80KSxsPU1hdGguY29zKG8pLHk9TWF0aC5zaW4obykseD1NYXRoLmNvcyhvK2MpLGI9TWF0aC5zaW4obytjKTtyZXR1cm5bbCx5LGwteSpwLHkrbCpwLHgrYipwLGIteCpwLHgsYl19ZnVuY3Rpb24gdShvLGMscCxsLHkseCxiLEUsdil7Y29uc3QgTT1NYXRoLnNpbih2KnIvMzYwKSxpPU1hdGguY29zKHYqci8zNjApLGE9aSooby1wKS8yK00qKGMtbCkvMixzPS1NKihvLXApLzIraSooYy1sKS8yO2lmKGE9PT0wJiZzPT09MClyZXR1cm5bXTtpZihiPT09MHx8RT09PTApcmV0dXJuW107Yj1NYXRoLmFicyhiKSxFPU1hdGguYWJzKEUpO2NvbnN0IGY9YSphLyhiKmIpK3Mqcy8oRSpFKTtmPjEmJihiKj1NYXRoLnNxcnQoZiksRSo9TWF0aC5zcXJ0KGYpKTtjb25zdCBPPWQobyxjLHAsbCx5LHgsYixFLE0saSksQT1bXTtsZXQgUj1PWzJdLEk9T1szXTtjb25zdCBQPU1hdGgubWF4KE1hdGguY2VpbChNYXRoLmFicyhJKS8oci80KSksMSk7SS89UDtmb3IobGV0IEw9MDtMPFA7TCsrKUEucHVzaChnKFIsSSkpLFIrPUk7cmV0dXJuIEEubWFwKEw9Pntmb3IobGV0IEQ9MDtEPEwubGVuZ3RoO0QrPTIpe2xldCBDPUxbRCswXSxTPUxbRCsxXTtDKj1iLFMqPUU7Y29uc3QgQj1pKkMtTSpTLHc9TSpDK2kqUztMW0QrMF09QitPWzBdLExbRCsxXT13K09bMV19cmV0dXJuIEx9KX19LGZ1bmN0aW9uKGgsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9dCg0Nykse2NvcHk6bn09dCg0OSksZD10KDUwKTtmdW5jdGlvbiBnKGwseSx4KXtyZXR1cm4gbFswXT15LGxbMV09eCxsfXZhciB1PVswLDBdLG89WzAsMF0sYz1bMCwwXTtmdW5jdGlvbiBwKGwseSx4LGIpe3IoeCxnKHUsYlsxXSxiWzJdKSxnKG8sYlszXSxiWzRdKSxnKGMsYls1XSxiWzZdKSx5LGwpfWguZXhwb3J0cz1mdW5jdGlvbih5LHgsYil7dmFyIEU9W10sdj1bXSxNPVswLDBdO3JldHVybiB5LmZvckVhY2goZnVuY3Rpb24oaSxhLHMpe2lmKGlbMF09PT0iTSIpbihNLGkuc2xpY2UoMSkpLHYubGVuZ3RoPjAmJihFLnB1c2godiksdj1bXSk7ZWxzZSBpZihpWzBdPT09IkMiKXAodix4LE0saSksZyhNLGlbNV0saVs2XSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoImlsbGVnYWwgdHlwZSBpbiBTVkc6ICIraVswXSl9KSx2Lmxlbmd0aD4wJiZFLnB1c2godiksRS5tYXAoZnVuY3Rpb24oaSl7cmV0dXJuIGQoaSxifHwwKX0pfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz10KDQ4KSgpfSxmdW5jdGlvbihoLGUpe2Z1bmN0aW9uIHQobil7cmV0dXJuW25bMF0sblsxXV19ZnVuY3Rpb24gcihuLGQpe3JldHVybltuLGRdfWguZXhwb3J0cz1mdW5jdGlvbihkKXtkPWR8fHt9O3ZhciBnPXR5cGVvZiBkLnJlY3Vyc2lvbj09Im51bWJlciI/ZC5yZWN1cnNpb246OCx1PXR5cGVvZiBkLmVwc2lsb249PSJudW1iZXIiP2QuZXBzaWxvbjoxMTkyMDkyOWUtMTQsbz10eXBlb2YgZC5wYXRoRXBzaWxvbj09Im51bWJlciI/ZC5wYXRoRXBzaWxvbjoxLGM9dHlwZW9mIGQuYW5nbGVFcHNpbG9uPT0ibnVtYmVyIj9kLmFuZ2xlRXBzaWxvbjouMDEscD1kLmFuZ2xlVG9sZXJhbmNlfHwwLGw9ZC5jdXNwTGltaXR8fDA7cmV0dXJuIGZ1bmN0aW9uKEUsdixNLGksYSxzKXtzfHwocz1bXSksYT10eXBlb2YgYT09Im51bWJlciI/YToxO3ZhciBmPW8vYTtyZXR1cm4gZio9Zix5KEUsdixNLGkscyxmKSxzfTtmdW5jdGlvbiB5KGIsRSx2LE0saSxhKXtpLnB1c2godChiKSk7dmFyIHM9YlswXSxmPWJbMV0sTz1FWzBdLEE9RVsxXSxSPXZbMF0sST12WzFdLFA9TVswXSxMPU1bMV07eChzLGYsTyxBLFIsSSxQLEwsaSxhLDApLGkucHVzaCh0KE0pKX1mdW5jdGlvbiB4KGIsRSx2LE0saSxhLHMsZixPLEEsUil7aWYoIShSPmcpKXt2YXIgST1NYXRoLlBJLFA9KGIrdikvMixMPShFK00pLzIsRD0oditpKS8yLEM9KE0rYSkvMixTPShpK3MpLzIsQj0oYStmKS8yLHc9KFArRCkvMixIPShMK0MpLzIsWj0oRCtTKS8yLHE9KEMrQikvMixVPSh3K1opLzIsRz0oSCtxKS8yO2lmKFI+MCl7dmFyIEo9cy1iLHR0PWYtRSxfPU1hdGguYWJzKCh2LXMpKnR0LShNLWYpKkopLHN0PU1hdGguYWJzKChpLXMpKnR0LShhLWYpKkopLGssaHQ7aWYoXz51JiZzdD51KXtpZigoXytzdCkqKF8rc3QpPD1BKihKKkordHQqdHQpKXtpZihwPGMpe08ucHVzaChyKFUsRykpO3JldHVybn12YXIgZnQ9TWF0aC5hdGFuMihhLU0saS12KTtpZihrPU1hdGguYWJzKGZ0LU1hdGguYXRhbjIoTS1FLHYtYikpLGh0PU1hdGguYWJzKE1hdGguYXRhbjIoZi1hLHMtaSktZnQpLGs+PUkmJihrPTIqSS1rKSxodD49SSYmKGh0PTIqSS1odCksaytodDxwKXtPLnB1c2gocihVLEcpKTtyZXR1cm59aWYobCE9PTApe2lmKGs+bCl7Ty5wdXNoKHIodixNKSk7cmV0dXJufWlmKGh0Pmwpe08ucHVzaChyKGksYSkpO3JldHVybn19fX1lbHNlIGlmKF8+dSl7aWYoXypfPD1BKihKKkordHQqdHQpKXtpZihwPGMpe08ucHVzaChyKFUsRykpO3JldHVybn1pZihrPU1hdGguYWJzKE1hdGguYXRhbjIoYS1NLGktdiktTWF0aC5hdGFuMihNLUUsdi1iKSksaz49SSYmKGs9MipJLWspLGs8cCl7Ty5wdXNoKHIodixNKSksTy5wdXNoKHIoaSxhKSk7cmV0dXJufWlmKGwhPT0wJiZrPmwpe08ucHVzaChyKHYsTSkpO3JldHVybn19fWVsc2UgaWYoc3Q+dSl7aWYoc3Qqc3Q8PUEqKEoqSit0dCp0dCkpe2lmKHA8Yyl7Ty5wdXNoKHIoVSxHKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihmLWEscy1pKS1NYXRoLmF0YW4yKGEtTSxpLXYpKSxrPj1JJiYoaz0yKkktayksazxwKXtPLnB1c2gocih2LE0pKSxPLnB1c2gocihpLGEpKTtyZXR1cm59aWYobCE9PTAmJms+bCl7Ty5wdXNoKHIoaSxhKSk7cmV0dXJufX19ZWxzZSBpZihKPVUtKGIrcykvMix0dD1HLShFK2YpLzIsSipKK3R0KnR0PD1BKXtPLnB1c2gocihVLEcpKTtyZXR1cm59fXgoYixFLFAsTCx3LEgsVSxHLE8sQSxSKzEpLHgoVSxHLFoscSxTLEIscyxmLE8sQSxSKzEpfX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY29tcHV0ZU1pdGVyIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsIm5vcm1hbCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJkaXJlY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTt2YXIgcj10KDEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBuKGEpe3JldHVyblthWzBdLGFbMV1dfWZ1bmN0aW9uIGQoKXtyZXR1cm5bMCwwXX1jb25zdCBnPXIudmVjMi5jb3B5LHU9ci52ZWMyLnNjYWxlQW5kQWRkLG89ci52ZWMyLmRvdCxjPXIudmVjMi5yb3RhdGUscD1yLnZlYzIuY3Jvc3MsbD1yLnZlYzIuc3ViLHk9ci52ZWMyLmFkZCx4PXIudmVjMi5ub3JtYWxpemUsYj1yLnZlYzIuc2V0LEU9ZCgpO2Z1bmN0aW9uIHYoYSxzLGYsTyxBKXt5KGEsZixPKSx4KGEsYSksYihzLC1hWzFdLGFbMF0pLGIoRSwtZlsxXSxmWzBdKTtjb25zdCBSPUEvbyhzLEUpO3JldHVybiBNYXRoLmFicyhSKX1mdW5jdGlvbiBNKGEscyl7cmV0dXJuIGIoYSwtc1sxXSxzWzBdKSxhfWZ1bmN0aW9uIGkoYSxzLGYpe3JldHVybiBsKGEscyxmKSx4KGEsYSksYX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDUxKSxuPXQoNTIpO2guZXhwb3J0cz1mdW5jdGlvbihnLHUpe3JldHVybiBnPXIoZyx1KSxnPW4oZyx1KSxnfSxoLmV4cG9ydHMucmFkaWFsRGlzdGFuY2U9cixoLmV4cG9ydHMuZG91Z2xhc1BldWNrZXI9bn0sZnVuY3Rpb24oaCxlKXtmdW5jdGlvbiB0KHIsbil7dmFyIGQ9clswXS1uWzBdLGc9clsxXS1uWzFdO3JldHVybiBkKmQrZypnfWguZXhwb3J0cz1mdW5jdGlvbihuLGQpe2lmKG4ubGVuZ3RoPD0xKXJldHVybiBuO2Q9dHlwZW9mIGQ9PSJudW1iZXIiP2Q6MTtmb3IodmFyIGc9ZCpkLHU9blswXSxvPVt1XSxjLHA9MSxsPW4ubGVuZ3RoO3A8bDtwKyspYz1uW3BdLHQoYyx1KT5nJiYoby5wdXNoKGMpLHU9Yyk7cmV0dXJuIHUhPT1jJiZvLnB1c2goYyksb319LGZ1bmN0aW9uKGgsZSl7ZnVuY3Rpb24gdChuLGQsZyl7dmFyIHU9ZFswXSxvPWRbMV0sYz1nWzBdLXUscD1nWzFdLW87aWYoYyE9PTB8fHAhPT0wKXt2YXIgbD0oKG5bMF0tdSkqYysoblsxXS1vKSpwKS8oYypjK3AqcCk7bD4xPyh1PWdbMF0sbz1nWzFdKTpsPjAmJih1Kz1jKmwsbys9cCpsKX1yZXR1cm4gYz1uWzBdLXUscD1uWzFdLW8sYypjK3AqcH1mdW5jdGlvbiByKG4sZCxnLHUsbyl7Zm9yKHZhciBjPXUscCxsPWQrMTtsPGc7bCsrKXt2YXIgeT10KG5bbF0sbltkXSxuW2ddKTt5PmMmJihwPWwsYz15KX1jPnUmJihwLWQ+MSYmcihuLGQscCx1LG8pLG8ucHVzaChuW3BdKSxnLXA+MSYmcihuLHAsZyx1LG8pKX1oLmV4cG9ydHM9ZnVuY3Rpb24oZCxnKXtpZihkLmxlbmd0aDw9MSlyZXR1cm4gZDtnPXR5cGVvZiBnPT0ibnVtYmVyIj9nOjE7dmFyIHU9ZypnLG89ZC5sZW5ndGgtMSxjPVtkWzBdXTtyZXR1cm4gcihkLDAsbyx1LGMpLGMucHVzaChkW29dKSxjfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZ2V0VG90YWxMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZ2V0UG9pbnRBdExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJnZXREYXNoQ29udG91cnMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDU0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihvKXtpZihvLnRvdGFsTGVuZ3RoIT1udWxsKXJldHVybiBvLnRvdGFsTGVuZ3RoO2xldCBjPTA7cmV0dXJuIG8uZm9yRWFjaChwPT57bGV0IGw9cFswXTtmb3IobGV0IHk9MTt5PHAubGVuZ3RoO3krKyl7Y29uc3QgeD1wW3ldO2MrPU9iamVjdChyLmRpc3RhbmNlKShsLHgpLGw9eH19KSxvLnRvdGFsTGVuZ3RoPWMsY31mdW5jdGlvbiBkKG8sYyxwPSEwKXtpZihjPU51bWJlcihjKSwhTnVtYmVyLmlzRmluaXRlKGMpKXRocm93IG5ldyBUeXBlRXJyb3IoIkZhaWxlZCB0byBleGVjdXRlICdnZXRQb2ludEF0TGVuZ3RoJyBvbiBmaWd1cmU6IFRoZSBwcm92aWRlZCBmbG9hdCB2YWx1ZSBpcyBub24tZmluaXRlLiIpO2lmKGM8PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiTGVuZ3RoIG11c3QgPiAwIik7Y29uc3QgbD1uKG8pO2lmKGM+PWwpe2NvbnN0IHg9b1tvLmxlbmd0aC0xXSxiPXhbeC5sZW5ndGgtMl0sRT14W3gubGVuZ3RoLTFdLHY9TWF0aC5hdGFuMihFWzFdLWJbMV0sRVswXS1iWzBdKTtyZXR1cm57Y3VycmVudDpvLm1hcChNPT5bLi4uTV0pLHBvaW50Ont4OkVbMF0seTpFWzFdLGFuZ2xlOnZ9fX1jb25zdCB5PVtdO2ZvcihsZXQgeD0wO3g8by5sZW5ndGg7eCsrKXt5W3hdPVtdO2NvbnN0IGI9b1t4XTtsZXQgRT1iWzBdO2ZvcihsZXQgdj0xO3Y8Yi5sZW5ndGg7disrKXtjb25zdCBNPWJbdl0saT1PYmplY3Qoci5kaXN0YW5jZSkoRSxNKTtpZihjPGkpe2NvbnN0IGE9Yy9pLHM9TWF0aC5hdGFuMihNWzFdLUVbMV0sTVswXS1FWzBdKSxmPXt4OkVbMF0qKDEtYSkrTVswXSphLHk6RVsxXSooMS1hKStNWzFdKmEsYW5nbGU6c307aWYoeVt4XS5wdXNoKEUpLGM+MCYmeVt4XS5wdXNoKFtmLngsZi55XSksIXApcmV0dXJue2N1cnJlbnQ6eSxwb2ludDpmfTtjb25zdCBPPVtdLEE9eDtmb3IoO3g8by5sZW5ndGg7eCsrKXtmb3IoT1t4LUFdPVtdLHg9PT1BJiZPWzBdLnB1c2goW2YueCxmLnldKTt2PGIubGVuZ3RoO3YrKylPW3gtQV0ucHVzaChiW3ZdKTt2PTB9cmV0dXJue2N1cnJlbnQ6eSxwb2ludDpmLHJlc3Q6T319Yy09aSx5W3hdLnB1c2goRSksRT1NfX19ZnVuY3Rpb24gZyhvLGMpe2lmKGM9TnVtYmVyKGMpLCFOdW1iZXIuaXNGaW5pdGUoYykpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoby5sZW5ndGg8PTApcmV0dXJue3g6MCx5OjAsYW5nbGU6MH07aWYoYzw9MCl7Y29uc3QgcD1vWzBdWzBdLGw9b1swXVsxXSx5PU1hdGguYXRhbjIobFsxXS1wWzFdLGxbMF0tcFswXSk7cmV0dXJue3g6cFswXSx5OnBbMV0sYW5nbGU6eX19cmV0dXJuIGQobyxjLCExKS5wb2ludH1mdW5jdGlvbiB1KG8sYyxwKXtsZXQgbD0wLHk9Y1swXSx4PW87Y29uc3QgYj1bXSxFPWMubGVuZ3RoO2lmKHA+MCl7ZG8gcC09Y1tsJUVdLGwrKzt3aGlsZShwPjApO3A8MCYmKHk9LXAsbC0tKX1lbHNlIGlmKHA8MCl7bD0tMTtkbyBwKz1jW2wlRStFLTFdLGwtLTt3aGlsZShwPDApO3A+PTAmJihsKysseT1jW2wlRStFLTFdLXApfWRve2NvbnN0IHY9ZCh4LHkpO3g9di5yZXN0LCsrbCUyJiZiLnB1c2goLi4udi5jdXJyZW50KTtsZXQgTT1sJUU7TTwwJiYoTSs9RSkseT1jW01dfXdoaWxlKHgpO3JldHVybiBifX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBufSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoW2QsZyx1XSxvLGMscCl7cmV0dXJuIGQ9ZCoyL28tMSxnPTEtZyoyL2MsTnVtYmVyLmlzRmluaXRlKHApPyh1PXUqMi9wLTEsW2QsZyx1XSk6W2QsZ119ZnVuY3Rpb24gbihbZCxnLHU9MF0sW28sYyxwPTBdKXtyZXR1cm4gTWF0aC5oeXBvdChvLWQsYy1nLHAtdSl9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRQb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPU1hdGguUEkqMjtmdW5jdGlvbiBuKGQsZyx1LG8sYyl7YyU9cixjPDAmJihjKz1yKTtjb25zdCBwPU1hdGgudGFuKGMpO2lmKE1hdGguYWJzKHApPDFlNSl7Y29uc3QgbD1nLXAqZCx5PTEvdSoqMitwKioyL28qKjI7bGV0IHg9LTE7KGM8PU1hdGguUEkvMnx8Yz4zKk1hdGguUEkvMikmJih4PTEpO2NvbnN0IGI9eCpNYXRoLnNxcnQoMS95KStkLEU9cCpiK2w7cmV0dXJuW2IsRV19cmV0dXJuIGM8TWF0aC5QST9bZCxnK29dOltkLGctb119fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBWfSk7dmFyIHI9dCgxKSxuPXQoNDIpLGQ9dC5uKG4pLGc9dCg1NyksdT10KDI4KSxvPXQoMjQpLGM9dCgzMCkscD10KDU5KSxsPXQoNTMpLHk9dCg2MCkseD10Lm4oeSksYj10KDQ2KSxFPXQubihiKSx2PXQoMzEpLE09dCg0MCksaT10KDIxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShYLGope2lmKFg9PW51bGwpcmV0dXJue307dmFyICQ9cyhYLGopLG0sVDtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgTj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFgpO2ZvcihUPTA7VDxOLmxlbmd0aDtUKyspbT1OW1RdLCEoai5pbmRleE9mKG0pPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFgsbSkmJigkW21dPVhbbV0pfXJldHVybiAkfWZ1bmN0aW9uIHMoWCxqKXtpZihYPT1udWxsKXJldHVybnt9O3ZhciAkPXt9LG09T2JqZWN0LmtleXMoWCksVCxOO2ZvcihOPTA7TjxtLmxlbmd0aDtOKyspVD1tW05dLCEoai5pbmRleE9mKFQpPj0wKSYmKCRbVF09WFtUXSk7cmV0dXJuICR9Y29uc3QgZj1TeW1ib2woIm1lc2giKSxPPVN5bWJvbCgiY29udG91cnMiKSxBPVN5bWJvbCgic3Ryb2tlIiksUj1TeW1ib2woImZpbGwiKSxJPVN5bWJvbCgic3Ryb2tlQ29sb3IiKSxQPVN5bWJvbCgiZmlsbENvbG9yIiksTD1TeW1ib2woInRyYW5zZm9ybSIpLEQ9U3ltYm9sKCJpbnZlcnRUcmFuc2Zvcm0iKSxDPVN5bWJvbCgidW5pZm9ybXMiKSxTPVN5bWJvbCgidGV4T3B0aW9ucyIpLEI9U3ltYm9sKCJibGVuZCIpLHc9U3ltYm9sKCJhcHBseVRleHR1cmUiKSxIPVN5bWJvbCgiYXBwbHlUcmFuc2Zvcm0iKSxaPVN5bWJvbCgiYXBwbHlHcmFkaWVudFRyYW5zZm9ybSIpLHE9U3ltYm9sKCJhcHBseVByb2dyYW0iKSxVPVN5bWJvbCgiZ3JhZGllbnQiKSxHPVN5bWJvbCgiZmlsdGVyIiksSj1TeW1ib2woIm9wYWNpdHkiKSx0dD1TeW1ib2woInByb2dyYW0iKSxfPVN5bWJvbCgiYXR0cmlidXRlcyIpLHN0PVN5bWJvbCgicGFzcyIpLGs9U3ltYm9sKCJjbGlwQ29udGV4dCIpLGh0PVN5bWJvbCgiYXBwbHlDbGlwUGF0aCIpO2Z1bmN0aW9uIGZ0KFgsail7Y29uc3RbJCxtXT1bWFsxXVswXS1YWzBdWzBdLFhbMV1bMV0tWFswXVsxXV0sVD1bXTtmb3IobGV0IE49MDtOPGoubGVuZ3RoO04rKyl7Y29uc3Qgej1qW05dLEs9Wyh6WzBdLVhbMF1bMF0pLyQsMS0oelsxXS1YWzBdWzFdKS9tXTtULnB1c2goSyl9cmV0dXJuIFR9ZnVuY3Rpb24gVyhbWCxqXSxbJCxtLFQsTl0se3NjYWxlOnp9KXtyZXR1cm4genx8KFgvPVQsaj0xLWovTixYLT0kLGorPW0pLFtYLGosMF19ZnVuY3Rpb24gRihYLGosJCl7Y29uc3QgbT1FKCkoWCxqLCQpO3JldHVybiBtLnBhdGg9WCxtLnNpbXBsaWZ5PSQsbS5zY2FsZT1qLG19Y2xhc3MgVntjb25zdHJ1Y3RvcihqKXt0aGlzW0FdPW51bGwsdGhpc1tSXT1udWxsLHRoaXNbTF09WzEsMCwwLDEsMCwwXSx0aGlzW0pdPTEsdGhpc1tDXT17fSx0aGlzW0ddPVtdLHRoaXNbQl09bnVsbCx0aGlzW1NdPXt9LHRoaXMuY29udG91cnM9ai5jb250b3Vycyx0aGlzW3R0XT1udWxsLHRoaXNbX109e30sdGhpc1tzdF09W119Z2V0IGNvbnRvdXJzKCl7cmV0dXJuIHRoaXNbT119c2V0IGNvbnRvdXJzKGope3RoaXNbZl09bnVsbCx0aGlzW09dPWo7Y29uc3QgJD1qLnNjYWxlO3RoaXMudHJhbnNmb3JtU2NhbGUvJD4xLjUmJnRoaXMuYWNjdXJhdGUodGhpcy50cmFuc2Zvcm1TY2FsZSl9c2V0UHJvZ3JhbShqKXt0aGlzW3R0XT1qLHRoaXNbZl0mJnRoaXNbcV0oail9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1t0dF19c2V0QXR0cmlidXRlKGosJCl7JD09bnVsbD9kZWxldGUgdGhpc1tfXVtqXTp0aGlzW19dW2pdPSR9Z2V0T3BhY2l0eSgpe3JldHVybiB0aGlzW0pdfXNldE9wYWNpdHkoail7aWYoajwwfHxqPjEpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBvcGFjaXR5IHZhbHVlLiIpO3RoaXNbZl0mJnRoaXNbZl0ucG9zaXRpb25zLmZvckVhY2goJD0+eyRbMl09MS8kWzJdPjA/ajotan0pLHRoaXNbSl09an1zZXRDbGlwUGF0aChqKXt0aGlzLmNsaXBQYXRoPWosdGhpc1tDXS51X2NsaXBTYW1wbGVyJiZ0aGlzW0NdLnVfY2xpcFNhbXBsZXIuZGVsZXRlKCksdGhpcy5zZXRVbmlmb3Jtcyh7dV9jbGlwU2FtcGxlcjpudWxsfSksdGhpc1tmXSYmZGVsZXRlIHRoaXNbZl0uYXR0cmlidXRlcy5hX2NsaXBVVixqJiZ0aGlzW2ZdJiZ0aGlzW2h0XSgpfVtodF0oKXtpZih0aGlzLmNsaXBQYXRoKXt0aGlzW2tdfHwodGhpc1trXT1pLmRlZmF1bHQuY3JlYXRlQ2FudmFzKDEsMSkpO2NvbnN0W1tqLCRdLFttLFRdXT10aGlzLmJvdW5kaW5nQm94O20mJlQmJih0aGlzW2tdLndpZHRoPW0taix0aGlzW2tdLmhlaWdodD1ULSQpO2NvbnN0IE49dGhpc1trXS5nZXRDb250ZXh0KCIyZCIpLHo9bmV3IFBhdGgyRCh0aGlzLmNsaXBQYXRoKTtOLmNsZWFyUmVjdCgwLDAsdGhpc1trXS53aWR0aCx0aGlzW2tdLmhlaWdodCksTi5zYXZlKCksTi50cmFuc2xhdGUoLWosLSQpLE4uZmlsbFN0eWxlPSJ3aGl0ZSIsTi5maWxsKHopLE4ucmVzdG9yZSgpLHRoaXNbZl0uY2xpcFBhdGg9dGhpc1trXTtjb25zdCBLPWZ0KHRoaXMuYm91bmRpbmdCb3gsdGhpc1tmXS5wb3NpdGlvbjApO3RoaXNbZl0uYXR0cmlidXRlcy5hX2NsaXBVVj1LfX1nZXRQb2ludEF0TGVuZ3RoKGope3JldHVybiBPYmplY3QobC5nZXRQb2ludEF0TGVuZ3RoKSh0aGlzW09dLGopfWdldFRvdGFsTGVuZ3RoKCl7cmV0dXJuIE9iamVjdChsLmdldFRvdGFsTGVuZ3RoKSh0aGlzW09dKX1nZXQgYmxlbmQoKXtyZXR1cm4gdGhpc1tCXT09bnVsbD8iYXV0byI6dGhpc1tCXX1zZXQgYmxlbmQoail7dGhpc1tCXT1qLHRoaXNbZl0mJih0aGlzW2ZdLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQpfWdldCBib3VuZGluZ0JveCgpe2lmKHRoaXNbZl0mJnRoaXNbZl0uYm91bmRpbmdCb3gpcmV0dXJuIHRoaXNbZl0uYm91bmRpbmdCb3g7Y29uc3Qgaj10aGlzLm1lc2hEYXRhO2lmKGope2NvbnN0ICQ9ai5wb3NpdGlvbjA7aWYoJC5sZW5ndGgpai5ib3VuZGluZ0JveD1kKCkoJCk7ZWxzZSByZXR1cm5bWzAsMF0sWzAsMF1dO3JldHVybiBqLmJvdW5kaW5nQm94fXJldHVybltbMCwwXSxbMCwwXV19Z2V0IGJvdW5kaW5nQ2VudGVyKCl7Y29uc3Qgaj10aGlzLmJvdW5kaW5nQm94O3JldHVybiBqP1suNSooalswXVswXStqWzFdWzBdKSwuNSooalswXVsxXStqWzFdWzFdKV06WzAsMF19Z2V0IGZpbGxSdWxlKCl7cmV0dXJuIHRoaXNbUl0/dGhpc1tSXS5ydWxlOiJub256ZXJvIn1nZXQgbGluZVdpZHRoKCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5saW5lV2lkdGg6MH1nZXQgbGluZUNhcCgpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ubGluZUNhcDoiIn1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLmxpbmVKb2luOiIifWdldCBtaXRlckxpbWl0KCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5taXRlckxpbWl0OjB9Z2V0IHN0cm9rZVN0eWxlKCl7cmV0dXJuIHRoaXNbSV0mJnRoaXNbSV1bM10hPT0wP09iamVjdChvLmRlZmF1bHQpKHRoaXNbSV0pOiIifWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ubGluZURhc2g6bnVsbH1nZXQgbGluZURhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLmxpbmVEYXNoT2Zmc2V0OjB9Z2V0IGZpbGxTdHlsZSgpe3JldHVybiB0aGlzW1BdJiZ0aGlzW1BdWzNdIT09MD9PYmplY3Qoby5kZWZhdWx0KSh0aGlzW1BdKToiIn1nZXQgZ3JhZGllbnQoKXtyZXR1cm4gdGhpc1tVXX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW0NdLnVfdGV4U2FtcGxlcj97aW1hZ2U6dGhpc1tDXS51X3RleFNhbXBsZXIuX2ltZyxvcHRpb25zOnRoaXNbU119Om51bGx9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbQl09PT0hMHx8dGhpc1tCXT09PSExP3RoaXNbQl06dGhpc1tKXTwxfHx0aGlzW0ldIT1udWxsJiZ0aGlzW0ldWzNdPDF8fHRoaXNbUF0hPW51bGwmJnRoaXNbUF1bM108MXx8dGhpc1tDXS51X2NvbG9yTWF0cml4IT1udWxsJiZ0aGlzW0NdLnVfY29sb3JNYXRyaXhbMThdPDF8fHRoaXNbQ10udV9yYWRpYWxHcmFkaWVudFZlY3RvciE9bnVsbHx8dGhpcy5iZWZvcmVSZW5kZXJ8fHRoaXMuYWZ0ZXJSZW5kZXJ9Z2V0IGZpbHRlckNhbnZhcygpe3JldHVybi9ibHVyfGRyb3Atc2hhZG93fHVybC8udGVzdCh0aGlzLmZpbHRlcil9Z2V0IGZpbHRlcigpe3JldHVybiB0aGlzW0ddLmpvaW4oIiAiKX1nZXQgdHJhbnNmb3JtTWF0cml4KCl7cmV0dXJuIHRoaXNbTF19Z2V0IGludmVydE1hdHJpeCgpe2lmKCF0aGlzW0RdKXtjb25zdCBqPXIubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzW0xdKTt0aGlzW0RdPWp9cmV0dXJuIHRoaXNbRF19Z2V0IHRyYW5zZm9ybVNjYWxlKCl7Y29uc3Qgaj10aGlzW0xdO3JldHVybiBNYXRoLm1heChNYXRoLmh5cG90KGpbMF0salsxXSksTWF0aC5oeXBvdChqWzJdLGpbM10pKX1nZXQgdW5pZm9ybXMoKXtyZXR1cm4gdGhpc1tDXX1nZXQgcGFzcygpe3JldHVybiB0aGlzW3N0XX1bcV0oail7Y29uc3QgJD10aGlzW19dLG09dGhpc1tmXS5wb3NpdGlvbjAsVD1PYmplY3QuZW50cmllcyhqLl9hdHRyaWJ1dGUpO2ZvcihsZXQgTj0wO048VC5sZW5ndGg7TisrKXtjb25zdFt6LEtdPVRbTl07aWYoeiE9PSJhX2NvbG9yIiYmeiE9PSJhX3NvdXJjZVJlY3QiJiZLIT09Imlnbm9yZWQiKXtjb25zdCBZPSRbel07aWYoej09PSJ1diImJiFZKXtjb25zdCBRPXRoaXNbZl0uYm91bmRpbmdCb3h8fGQoKShtKTt0aGlzW2ZdLmF0dHJpYnV0ZXNbel09ZnQoUSxtKX1lbHNle3RoaXNbZl0uYXR0cmlidXRlc1t6XT1bXTtmb3IobGV0IFE9MDtRPG0ubGVuZ3RoO1ErKyl7Y29uc3QgZXQ9bVtRXTt0aGlzW2ZdLmF0dHJpYnV0ZXNbel0ucHVzaChZP1koZXQsTixtKTpBcnJheShLLnNpemUpLmZpbGwoMCkpfX19fX1nZXQgbWVzaERhdGEoKXtpZih0aGlzLl91cGRhdGVNYXRyaXgmJnRoaXMudHJhbnNmb3JtU2NhbGUvdGhpcy5jb250b3Vycy5zY2FsZT4xLjUmJnRoaXMuYWNjdXJhdGUodGhpcy50cmFuc2Zvcm1TY2FsZSksIXRoaXNbZl0peyF0aGlzW1JdJiYhdGhpc1tBXSYmdGhpcy5zZXRGaWxsKCk7Y29uc3Qgaj10aGlzW09dLCQ9e307aWYoaiYmai5sZW5ndGgpe2lmKHRoaXNbUl0pdHJ5e2NvbnN0IE49eCgpKGosdGhpc1tSXSk7Ti5wb3NpdGlvbnM9Ti5wb3NpdGlvbnMubWFwKHo9Pih6LnB1c2godGhpc1tKXSkseikpLE4uYXR0cmlidXRlcz17YV9jb2xvcjpBcnJheS5mcm9tKHtsZW5ndGg6Ti5wb3NpdGlvbnMubGVuZ3RofSkubWFwKCgpPT50aGlzW1BdLm1hcCh6PT5NYXRoLnJvdW5kKDI1NSp6KSkpfSwkLmZpbGw9Tn1jYXRjaHt9aWYodGhpc1tBXSl7Y29uc3QgTj10aGlzW0FdLmxpbmVEYXNoO2xldCB6PWo7aWYoTil7Y29uc3QgWT10aGlzW0FdLmxpbmVEYXNoT2Zmc2V0O3o9T2JqZWN0KGwuZ2V0RGFzaENvbnRvdXJzKShqLE4sWSl9Y29uc3QgSz16Lm1hcCgoWSxRKT0+e2NvbnN0IGV0PVkubGVuZ3RoPjEmJnIudmVjMi5lcXVhbHMoWVswXSxZW1kubGVuZ3RoLTFdKSxydD10aGlzW0FdLmJ1aWxkKFksZXQpO3JldHVybiB4KCkoW3J0XSl9KTtLLmZvckVhY2goWT0+e1kucG9zaXRpb25zPVkucG9zaXRpb25zLm1hcChRPT4oUS5wdXNoKC10aGlzW0pdKSxRKSksWS5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpZLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbSV0ubWFwKFE9Pk1hdGgucm91bmQoMjU1KlEpKSl9fSksJC5zdHJva2U9T2JqZWN0KHUuZGVmYXVsdCkoSyl9fWNvbnN0IG09T2JqZWN0KHUuZGVmYXVsdCkoWyQuZmlsbCwkLnN0cm9rZV0pO20uZmlsbFBvaW50Q291bnQ9JC5maWxsPyQuZmlsbC5wb3NpdGlvbnMubGVuZ3RoOjAsbS5lbmFibGVCbGVuZD10aGlzLmVuYWJsZUJsZW5kLG0ucG9zaXRpb24wPW0ucG9zaXRpb25zLm1hcCgoW04seixLXSk9PltOLHosS10pLG0udW5pZm9ybXM9dGhpc1tDXSx0aGlzW2ZdPW0sdGhpc1tDXS51X3RleFNhbXBsZXImJnRoaXNbd10obSx0aGlzW1NdKTtjb25zdCBUPXRoaXNbTF07T2JqZWN0KHAuaXNVbml0VHJhbnNmb3JtKShUKXx8KHRoaXNbSF0obSxUKSx0aGlzW0NdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3ImJnRoaXNbWl0oKSksdGhpcy5jbGlwUGF0aCYmdGhpc1todF0oKSx0aGlzW3R0XSYmdGhpc1txXSh0aGlzW3R0XSl9cmV0dXJuIHRoaXMuX3VwZGF0ZU1hdHJpeCYmKHRoaXNbZl0ubWF0cml4PXRoaXNbTF0sdGhpc1tIXSh0aGlzW2ZdLHRoaXNbTF0pLHRoaXNbQ10udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1taXSgpKSx0aGlzW2ZdfVtIXShqLCQpe2NvbnN0e3Bvc2l0aW9uczptLHBvc2l0aW9uMDpUfT1qO2ZvcihsZXQgTj0wO048bS5sZW5ndGg7TisrKXtjb25zdFt6LEtdPVRbTl0sWT1tW05dO1lbMF09eiokWzBdK0sqJFsyXSskWzRdLFlbMV09eiokWzFdK0sqJFszXSskWzVdfXRoaXMuX3VwZGF0ZU1hdHJpeD0hMX1bWl0oKXtjb25zdCBqPXRoaXNbTF0sJD1bLi4udGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3JdO2lmKCQpe2NvbnN0W20sVCwsTix6XT0kOyRbMF09bSpqWzBdK1QqalsyXStqWzRdLCRbMV09bSpqWzFdK1QqalszXStqWzVdLCRbM109TipqWzBdK3oqalsyXStqWzRdLCRbNF09TipqWzFdK3oqalszXStqWzVdLHRoaXNbQ10udV9yYWRpYWxHcmFkaWVudFZlY3Rvcj0kfX1bd10oaiwkKXtmdW5jdGlvbiBtKFEsZXQpe3JldHVybiBRPT1udWxsJiZldD09bnVsbD8hMDpRPT1udWxsfHxldD09bnVsbD8hMTpRWzBdPT09ZXRbMF0mJlFbMV09PT1ldFsxXSYmUVsyXT09PWV0WzJdJiZRWzNdPT09ZXRbM119Y29uc3QgVD10aGlzW0NdLnVfdGV4U2FtcGxlcjtpZighVClyZXR1cm47Y29uc3R7d2lkdGg6TixoZWlnaHQ6en09VC5faW1nLEs9JC5zcmNSZWN0O2xldCBZPSQucmVjdHx8WzAsMF07aWYoJC5yb3RhdGVkJiYoWT1bLVlbMV0sWVswXSxZWzNdLFlbMl1dKSxZWzJdPT1udWxsJiYoWVsyXT1LP0tbMl06TiksWVszXT09bnVsbCYmKFlbM109Sz9LWzNdOnopLCQuaGlkZGVuKWoudGV4dHVyZUNvb3JkPWoucG9zaXRpb25zLm1hcCgoKT0+Wy0xLC0xLC0xXSk7ZWxzZSBpZighai50ZXh0dXJlQ29vcmR8fCFtKHRoaXNbU10ucmVjdCwkLnJlY3QpfHx0aGlzW1NdLmhpZGRlbiE9PSQuaGlkZGVufHx0aGlzW1NdLnJvdGF0ZWQhPT0kLnJvdGF0ZWQpe2xldCBRPW51bGw7JC5yb3RhdGVkJiYoUT1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKSwuNSpNYXRoLlBJKSxRPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxRLFswLC1ZWzJdXSkpLGoudGV4dHVyZUNvb3JkPWoucG9zaXRpb24wLm1hcCgoW2V0LHJ0LG90XSk9PntpZigxL290PjApe2lmKCQucm90YXRlZCl7Y29uc3QgaXQ9ZXQqUVswXStydCpRWzJdK1FbNF0sbnQ9ZXQqUVsxXStydCpRWzNdK1FbNV07W2V0LHJ0XT1baXQsbnRdfWNvbnN0IGx0PVcoW2V0LHJ0XSxbWVswXS9ZWzJdLFlbMV0vWVszXSxZWzJdLFlbM11dLCQpO3JldHVybiAkLnJlcGVhdCYmKGx0WzJdPTEpLGx0fXJldHVyblstMSwtMSwtMV19KX1pZihLKXtjb25zdCBRPVtLWzBdL04sS1sxXS96LEtbMl0vTixLWzNdL3pdO2ouYXR0cmlidXRlcy5hX3NvdXJjZVJlY3Q9ai5wb3NpdGlvbnMubWFwKCgpPT5bLi4uUV0pfWVsc2Ugai5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1qLnBvc2l0aW9ucy5tYXAoKCk9PlswLDAsMCwwXSl9YWNjdXJhdGUoail7aWYoIXRoaXMuY29udG91cnMpcmV0dXJuO2lmKHRoaXMuY29udG91cnMucGF0aCl7Y29uc3QgbT10aGlzLmNvbnRvdXJzLnNpbXBsaWZ5LFQ9Rih0aGlzLmNvbnRvdXJzLnBhdGgsMipqLG0pO3RoaXNbZl09bnVsbCx0aGlzW09dPVR9fWNhbklnbm9yZSgpe2NvbnN0IGo9dGhpc1tBXT09bnVsbHx8dGhpc1tBXS5saW5lV2lkdGg9PT0wfHx0aGlzW0ldWzNdPT09MCwkPXRoaXNbUl09PW51bGx8fHRoaXNbUF1bM109PT0wLG09dGhpc1tDXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPT1udWxsLFQ9dGhpc1tDXS51X3RleFNhbXBsZXI9PW51bGw7cmV0dXJuIHRoaXNbSl09PT0wfHx0aGlzW3R0XT09bnVsbCYmaiYmJCYmbSYmVCYmIXRoaXMuYmVmb3JlUmVuZGVyJiYhdGhpcy5hZnRlclJlbmRlcn1zZXRTdHJva2Uoe3RoaWNrbmVzczpqPTEsY2FwOiQ9ImJ1dHQiLGpvaW46bT0ibWl0ZXIiLG1pdGVyTGltaXQ6VD0xMCxjb2xvcjpOPVswLDAsMCwwXSxsaW5lRGFzaDp6PW51bGwsbGluZURhc2hPZmZzZXQ6Sz0wLHJvdW5kU2VnbWVudHM6WT0yMH09e30pe3JldHVybiB0aGlzW2ZdPW51bGwsdGhpc1tBXT1uZXcgZy5kZWZhdWx0KHtsaW5lV2lkdGg6aixsaW5lQ2FwOiQsbGluZUpvaW46bSxtaXRlckxpbWl0OlQscm91bmRTZWdtZW50czpZfSksdHlwZW9mIE49PSJzdHJpbmciJiYoTj1PYmplY3Qodi5kZWZhdWx0KShOKSksdGhpc1tJXT1OLHRoaXNbQV0ubGluZURhc2g9eix0aGlzW0FdLmxpbmVEYXNoT2Zmc2V0PUssdGhpc31zZXRGaWxsKHtydWxlOmo9dGhpcy5maWxsUnVsZSxjb2xvcjokPVswLDAsMCwwXX09e30pe3JldHVybiB0aGlzW2ZdPW51bGwsdGhpc1tSXT17cnVsZTpqfSx0eXBlb2YgJD09InN0cmluZyImJigkPU9iamVjdCh2LmRlZmF1bHQpKCQpKSx0aGlzW1BdPSQsdGhpc31zZXRUZXh0dXJlKGosJD17fSl7aWYoaiYmai5pbWFnZSl7Y29uc3R7aW1hZ2U6bSxyZWN0OlR9PWo7aWYoaj1tLCQucmVjdClmb3IobGV0IE49MDtOPCQucmVjdC5sZW5ndGg7TisrKVRbTl09JC5yZWN0W05dOyQucmVjdD1UfXJldHVybiB0aGlzW1JdfHx0aGlzLnNldEZpbGwoKSx0aGlzLnNldFVuaWZvcm1zKHt1X3RleFNhbXBsZXI6an0pLHRoaXNbZl0mJnRoaXNbd10odGhpc1tmXSwkKSx0aGlzW1NdPSQsdGhpc31zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6JCx0eXBlOm09ImZpbGwifT17fSl7aWYoai5sZW5ndGghPT0zKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZWFyR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOiQsdHlwZTptfSl9c2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczokLHR5cGU6bT0iZmlsbCJ9PXt9KXtpZihqLmxlbmd0aCE9PTQpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6JCx0eXBlOm19KX1zZXRSYWRpYWxHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOiQsdHlwZTptPSJmaWxsIn09e30pe2lmKGoubGVuZ3RoIT09Nil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHJhZGlhbEdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczokLHR5cGU6bX0pfXNldEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6JCx0eXBlOm09ImZpbGwifT17fSl7JD0kLm1hcCgoe29mZnNldDp6LGNvbG9yOkt9KT0+KHR5cGVvZiBLPT0ic3RyaW5nIiYmKEs9T2JqZWN0KHYuZGVmYXVsdCkoSykpLHtvZmZzZXQ6eixjb2xvcjpLfSkpLHRoaXNbVV09dGhpc1tVXXx8e30sdGhpc1tVXVttXT17dmVjdG9yOmosY29sb3JzOiR9LCQuc29ydCgoeixLKT0+ei5vZmZzZXQtSy5vZmZzZXQpO2NvbnN0IFQ9W107JC5mb3JFYWNoKCh7b2Zmc2V0OnosY29sb3I6S30pPT57VC5wdXNoKHosLi4uSyl9KTtsZXQgTjtpZihqLmxlbmd0aD09PTQ/Tj1balswXSxqWzFdLDAsalsyXSxqWzNdLDBdOk49Wy4uLmpdLFQubGVuZ3RoPDQwJiZULnB1c2goLTEpLFQubGVuZ3RoPjQwKXRocm93IG5ldyBFcnJvcigiVG9vIG1hbnkgY29sb3JzLCBzaG91bGQgYmUgbGVzcyB0aGFuIDggY29sb3JzIik7cmV0dXJuIHRoaXMuX3JhZGlhbEdyYWRpZW50VmVjdG9yPU4sdGhpc1tDXS51X2NvbG9yU3RlcHM9VCxtPT09ImZpbGwiP3RoaXNbQ10udV9ncmFkaWVudFR5cGU9MTp0aGlzW0NdLnVfZ3JhZGllbnRUeXBlPTAsdGhpc1taXSgpLHRoaXN9c2V0VW5pZm9ybXMoaj17fSl7cmV0dXJuIE9iamVjdC5hc3NpZ24odGhpc1tDXSxqKSx0aGlzfXNldFRyYW5zZm9ybSguLi5qKXtjb25zdCAkPXRoaXNbTF07cmV0dXJuIHIubWF0MmQuZXF1YWxzKGosJCl8fCh0aGlzW0xdPWosZGVsZXRlIHRoaXNbRF0sdGhpcy5fdXBkYXRlTWF0cml4PSEwKSx0aGlzfXRyYW5zZm9ybSguLi5qKXtjb25zdCAkPXRoaXNbTF07cmV0dXJuIHRoaXNbTF09ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksJCxqKSxkZWxldGUgdGhpc1tEXSx0aGlzLl91cGRhdGVNYXRyaXg9ITAsdGhpc310cmFuc2xhdGUoaiwkKXtsZXQgbT1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBtPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxtLFtqLCRdKSx0aGlzLnRyYW5zZm9ybSguLi5tKX1yb3RhdGUoaixbJCxtXT1bMCwwXSl7bGV0IFQ9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gVD1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksVCxbJCxtXSksVD1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksVCxqKSxUPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxULFstJCwtbV0pLHRoaXMudHJhbnNmb3JtKC4uLlQpfXNjYWxlKGosJD1qLFttLFRdPVswLDBdKXtsZXQgTj1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBOPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFttLFRdKSxOPXIubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sW2osJF0pLE49ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sWy1tLC1UXSksdGhpcy50cmFuc2Zvcm0oLi4uTil9c2tldyhqLCQ9aixbbSxUXT1bMCwwXSl7bGV0IE49ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbbSxUXSksTj1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKCQpLE1hdGgudGFuKGopLDEsMCwwKSksTj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbLW0sLVRdKSx0aGlzLnRyYW5zZm9ybSguLi5OKX1jbGVhckZpbHRlcigpe3JldHVybiB0aGlzLnNldENvbG9yVHJhbnNmb3JtKG51bGwpLHRoaXNbR10ubGVuZ3RoPTAsdGhpc31zZXRDb2xvclRyYW5zZm9ybSguLi5qKXtyZXR1cm4galswXT09PW51bGw/dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjAsdV9jb2xvck1hdHJpeDowfSk6dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjEsdV9jb2xvck1hdHJpeDpqfSksdGhpc310cmFuc2Zvcm1Db2xvciguLi5qKXtsZXQgJD10aGlzLnVuaWZvcm1zLnVfY29sb3JNYXRyaXg7cmV0dXJuICQ/JD1PYmplY3QoYy5tdWx0aXBseSkoJCxqKTokPWosdGhpcy5zZXRDb2xvclRyYW5zZm9ybSguLi4kKSx0aGlzfWJsdXIoail7cmV0dXJuIHRoaXNbR10ucHVzaChgYmx1cigke2p9cHgpYCksdGhpc31icmlnaHRuZXNzKGo9MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgYnJpZ2h0bmVzcygkezEwMCpqfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoYy5icmlnaHRuZXNzKShqKSl9Y29udHJhc3Qoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBjb250cmFzdCgkezEwMCpqfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoYy5jb250cmFzdCkoaikpfWRyb3BTaGFkb3coaiwkLG09MCxUPVswLDAsMCwxXSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoVCkmJihUPU9iamVjdChvLmRlZmF1bHQpKFQpKSx0aGlzW0ddLnB1c2goYGRyb3Atc2hhZG93KCR7an1weCAkeyR9cHggJHttfXB4ICR7VH0pYCksdGhpc31ncmF5c2NhbGUoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBncmF5c2NhbGUoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMuZ3JheXNjYWxlKShqKSl9aHVlUm90YXRlKGo9MCl7cmV0dXJuIHRoaXNbR10ucHVzaChgaHVlLXJvdGF0ZSgke2p9ZGVnKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMuaHVlUm90YXRlKShqKSl9aW52ZXJ0KGo9MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgaW52ZXJ0KCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLmludmVydCkoaikpfW9wYWNpdHkoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBvcGFjaXR5KCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLm9wYWNpdHkpKGopKX1zYXR1cmF0ZShqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYHNhdHVyYXRlKCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLnNhdHVyYXRlKShqKSl9c2VwaWEoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBzZXBpYSgkezEwMCpqfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoYy5zZXBpYSkoaikpfXVybChqKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGB1cmwoJHtqfSlgKSx0aGlzfWlzUG9pbnRDb2xsaXNpb24oaiwkLG09ImJvdGgiKXtjb25zdCBUPXRoaXMubWVzaERhdGEse3Bvc2l0aW9uczpOLGNlbGxzOnp9PVQsSz10aGlzLmludmVydE1hdHJpeCxZPUtbMF0qaitLWzJdKiQrS1s0XSxRPUtbMV0qaitLWzNdKiQrS1s1XSxldD10aGlzLmJvdW5kaW5nQm94O2lmKFk8ZXRbMF1bMF18fFk+ZXRbMV1bMF18fFE8ZXRbMF1bMV18fFE+ZXRbMV1bMV0pcmV0dXJuITE7ZnVuY3Rpb24gcnQoW290LGx0XSxbaXQsbnRdLFthdCxkdF0pe2NvbnN0IGd0PWF0LWl0LHV0PWR0LW50LG10PSgob3QtaXQpKmd0KyhsdC1udCkqdXQpLyhndCoqMit1dCoqMik7cmV0dXJuIG10Pj0wJiZtdDw9MX1mb3IobGV0IG90PTA7b3Q8ei5sZW5ndGg7b3QrKyl7Y29uc3QgbHQ9eltvdF07aWYobT09PSJmaWxsIiYmbHRbMF0+PVQuZmlsbFBvaW50Q291bnQpYnJlYWs7aWYobT09PSJzdHJva2UiJiZsdFswXTxULmZpbGxQb2ludENvdW50KWNvbnRpbnVlO2NvbnN0W1tpdCxudF0sW2F0LGR0XSxbZ3QsdXRdXT1sdC5tYXAoTXQ9Pk5bTXRdKSxtdD1NYXRoLnNpZ24oKGotaXQpKihkdC1udCktKGF0LWl0KSooJC1udCkpO2lmKG10PT09MCYmcnQoW2osJF0sW2l0LG50XSxbYXQsZHRdKSlyZXR1cm4hMDtjb25zdCBQdD1NYXRoLnNpZ24oKGotYXQpKih1dC1kdCktKGd0LWF0KSooJC1kdCkpO2lmKFB0PT09MCYmcnQoW2osJF0sW2F0LGR0XSxbZ3QsdXRdKSlyZXR1cm4hMDtjb25zdCB4dD1NYXRoLnNpZ24oKGotZ3QpKihudC11dCktKGl0LWd0KSooJC11dCkpO2lmKHh0PT09MCYmcnQoW2osJF0sW2d0LHV0XSxbaXQsbnRdKXx8bXQ9PT0xJiZQdD09PTEmJnh0PT09MXx8bXQ9PT0tMSYmUHQ9PT0tMSYmeHQ9PT0tMSlyZXR1cm4hMH1yZXR1cm4hMX1pc1BvaW50SW5GaWxsKGosJCl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihqLCQsImZpbGwiKX1pc1BvaW50SW5TdHJva2UoaiwkKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGosJCwic3Ryb2tlIil9YWRkUGFzcyhqLCQ9e30pe2xldHt3aWR0aDptLGhlaWdodDpUfT0kLE49YSgkLFsid2lkdGgiLCJoZWlnaHQiXSk7Y29uc3Qgej1uZXcgTS5kZWZhdWx0O3oucmVjdCgwLDAsbSxUKTtjb25zdCBLPW5ldyBWKHose3dpZHRoOm0saGVpZ2h0OlR9KTtLLnNldFVuaWZvcm1zKE4pLEsuc2V0UHJvZ3JhbShqKSx0aGlzW3N0XS5wdXNoKEspfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCg1OCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1yLlN0cm9rZX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiU3Ryb2tlIixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIHI9dCg0OSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG49T2JqZWN0KHIuY3JlYXRlKSgpLGQ9T2JqZWN0KHIuY3JlYXRlKSgpLGc9T2JqZWN0KHIuY3JlYXRlKSgpLHU9T2JqZWN0KHIuY3JlYXRlKSgpLG89T2JqZWN0KHIuY3JlYXRlKSgpLGM9MWUyMDtjbGFzcyBwe2NvbnN0cnVjdG9yKHtsaW5lV2lkdGg6RT0xLGxpbmVKb2luOnY9Im1pdGVyIixtaXRlckxpbWl0Ok09MTAsbGluZUNhcDppPSJidXR0Iixyb3VuZFNlZ21lbnRzOmE9MjB9PXt9KXt0aGlzLmxpbmVXaWR0aD1FLHRoaXMubGluZUpvaW49dix0aGlzLm1pdGVyTGltaXQ9TSx0aGlzLmxpbmVDYXA9aSx0aGlzLnJvdW5kU2VnbWVudHM9YSx0aGlzLl9ub3JtYWw9bnVsbH1idWlsZChFLHY9ITEpe2xldCBNPUUubGVuZ3RoO2lmKEU9Wy4uLkVdLE08MilyZXR1cm4gRTt2JiYoKEVbMF1bMF0hPT1FW00tMV1bMF18fEVbMF1bMV0hPT1FW00tMV1bMV0pJiZFLnB1c2goWy4uLkVbMF1dKSxFLnB1c2goWy4uLkVbMV1dKSksTT1FLmxlbmd0aCx0aGlzLl9ub3JtYWw9bnVsbDtjb25zdCBpPXtsZWZ0OltdLHJpZ2h0OltdfSxhPXRoaXMubGluZVdpZHRoLzIscz10aGlzLmxpbmVDYXA7aWYoIXYmJnM9PT0ic3F1YXJlIil7T2JqZWN0KHIuZGlyZWN0aW9uKShkLEVbMF0sRVsxXSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKEVbMF0sRVswXSxkLGEpO2NvbnN0IE89RS5sZW5ndGgtMTtPYmplY3Qoci5kaXJlY3Rpb24pKGQsRVtPXSxFW08tMV0pLE9iamVjdChyLnNjYWxlQW5kQWRkKShFW09dLEVbT10sZCxhKX1mb3IobGV0IE89MTtPPE07TysrKXtjb25zdCBBPUVbTy0xXSxSPUVbT10sST1FW08rMV07dGhpcy5fc2VnKGksQSxSLEksYSx2KX1yZXR1cm4hdiYmcz09PSJyb3VuZCImJngoaSx0aGlzLnJvdW5kU2VnbWVudHMpLFsuLi5pLmxlZnQsLi4uaS5yaWdodC5yZXZlcnNlKCldfV9zZWcoRSx2LE0saSxhLHMpe2NvbnN0IGY9dGhpcy5saW5lSm9pbj09PSJiZXZlbCIsTz10aGlzLmxpbmVKb2luPT09InJvdW5kIjtpZihPYmplY3Qoci5kaXJlY3Rpb24pKGQsTSx2KSx0aGlzLl9ub3JtYWx8fCh0aGlzLl9ub3JtYWw9T2JqZWN0KHIuY3JlYXRlKSgpLE9iamVjdChyLm5vcm1hbCkodGhpcy5fbm9ybWFsLGQpKSxFLmxlZnQubGVuZ3RofHx5KEUsdix0aGlzLl9ub3JtYWwsYSksIWkpT2JqZWN0KHIubm9ybWFsKSh0aGlzLl9ub3JtYWwsZCkscz95KEUsdix0aGlzLl9ub3JtYWwsYSk6eShFLE0sdGhpcy5fbm9ybWFsLGEpO2Vsc2V7T2JqZWN0KHIuZGlyZWN0aW9uKShnLGksTSk7bGV0IEE9T2JqZWN0KHIuY29tcHV0ZU1pdGVyKSh1LG8sZCxnLGEpO0E9TWF0aC5taW4oQSxjKTtjb25zdCBSPU9iamVjdChyLmRvdCkodSx0aGlzLl9ub3JtYWwpPDA/LTE6MTtsZXQgST1mfHxPO2lmKCFJJiZ0aGlzLmxpbmVKb2luPT09Im1pdGVyIiYmQS9hPnRoaXMubWl0ZXJMaW1pdCYmKEk9ITApLEkpe09iamVjdChyLnNjYWxlQW5kQWRkKShuLE0sdGhpcy5fbm9ybWFsLC1hKlIpLGwoRSxuLFIpO2xldCBQPTEvMDt2JiYoUD1NYXRoLm1pbihQLE1hdGguaHlwb3QoTVswXS12WzBdLE1bMV0tdlsxXSkpKSxpJiYoUD1NYXRoLm1pbihQLE1hdGguaHlwb3QoaVswXS1NWzBdLGlbMV0tTVsxXSkpKTtjb25zdCBMPU1hdGgubWF4KGEsTWF0aC5taW4oQSxQKSk7aWYoT2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4sTSxvLEwqUiksbChFLG4sLVIpLGkpaWYoT2JqZWN0KHIubm9ybWFsKShuLGcpLE9iamVjdChyLmNvcHkpKHRoaXMuX25vcm1hbCxuKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkobixNLG4sLWEqUiksTyl7Y29uc3QgRD1PYmplY3Qoci5jbG9uZSkobiksQz1SPjA/RS5sZWZ0W0UubGVmdC5sZW5ndGgtMV06RS5yaWdodFtFLnJpZ2h0Lmxlbmd0aC0xXSxTPU9iamVjdChyLmNsb25lKShNKSxCPU9iamVjdChyLnN1YikoT2JqZWN0KHIuY3JlYXRlKSgpLEMsUyksdz1PYmplY3Qoci5zdWIpKE9iamVjdChyLmNyZWF0ZSkoKSxELFMpLEg9TWF0aC5QSS90aGlzLnJvdW5kU2VnbWVudHM7Zm9yKGxldCBaPTA7Wjx0aGlzLnJvdW5kU2VnbWVudHMmJihPYmplY3Qoci5yb3RhdGUpKEIsQixbMCwwXSxSKkgpLE1hdGguc2lnbihPYmplY3Qoci5jcm9zcykobixCLHcpWzJdKT09PVIpO1orKylPYmplY3Qoci5hZGQpKG4sQixTKSxsKEUsbixSKTtsKEUsRCxSKX1lbHNlIGwoRSxuLFIpfWVsc2UgeShFLE0sbyxBKSxPYmplY3Qoci5jb3B5KSh0aGlzLl9ub3JtYWwsbyl9fX1mdW5jdGlvbiBsKGIsRSx2KXt2PjA/Yi5sZWZ0LnB1c2goT2JqZWN0KHIuY2xvbmUpKEUpKTpiLnJpZ2h0LnB1c2goT2JqZWN0KHIuY2xvbmUpKEUpKX1mdW5jdGlvbiB5KGIsRSx2LE0saT0tMSl7T2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4sRSx2LC1NKSxsKGIsbiwtaSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKG4sRSx2LE0pLGwoYixuLGkpfWZ1bmN0aW9uIHgoe2xlZnQ6YixyaWdodDpFfSx2KXtjb25zdCBNPU9iamVjdChyLmNyZWF0ZSkoKSxpPU9iamVjdChyLmNyZWF0ZSkoKTtsZXQgYT1iWzBdLHM9RVswXSxmPVsuNSooYVswXStzWzBdKSwuNSooYVsxXStzWzFdKV07T2JqZWN0KHIuc3ViKShpLGEsZik7Zm9yKGxldCBPPTE7Tzw9djtPKyspe2NvbnN0IEE9LTEqTWF0aC5QSSpPL3Y7T2JqZWN0KHIucm90YXRlKShNLGksWzAsMF0sQSksT2JqZWN0KHIuYWRkKShuLGYsTSksYi51bnNoaWZ0KE9iamVjdChyLmNsb25lKShuKSl9YT1FW0UubGVuZ3RoLTFdLHM9YltiLmxlbmd0aC0xXSxmPVsuNSooYVswXStzWzBdKSwuNSooYVsxXStzWzFdKV0sT2JqZWN0KHIuc3ViKShpLGEsZik7Zm9yKGxldCBPPTE7Tzw9djtPKyspe2NvbnN0IEE9LTEqTWF0aC5QSSpPL3Y7T2JqZWN0KHIucm90YXRlKShNLGksWzAsMF0sQSksT2JqZWN0KHIuYWRkKShuLGYsTSksRS5wdXNoKE9iamVjdChyLmNsb25lKShuKSl9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiaXNVbml0VHJhbnNmb3JtIixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIobil7cmV0dXJuIG5bMF09PT0xJiZuWzFdPT09MCYmblsyXT09PTAmJm5bM109PT0xJiZuWzRdPT09MCYmbls1XT09PTB9fSxmdW5jdGlvbihoLGUsdCl7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO3ZhciByPXQoNjEpLG49dCg2Mik7aC5leHBvcnRzPWZ1bmN0aW9uKGQsZyl7aWYoZz1nfHx7fSxkPWQuZmlsdGVyKGZ1bmN0aW9uKHYpe3JldHVybiB2Lmxlbmd0aD4yfSksZC5sZW5ndGg9PT0wKXJldHVybntwb3NpdGlvbnM6W10sY2VsbHM6W119O3R5cGVvZiBnLnZlcnRleFNpemUhPSJudW1iZXIiJiYoZy52ZXJ0ZXhTaXplPWRbMF1bMF0ubGVuZ3RoKSxkPWQubWFwKGZ1bmN0aW9uKHYpe3JldHVybiB2LnJlZHVjZShmdW5jdGlvbihNLGkpe3JldHVybiBNLmNvbmNhdChpKX0pfSk7Y29uc3QgdT1nLnJ1bGU9PT0iZXZlbm9kZCI/ci5XSU5ESU5HX09ERDpyLldJTkRJTkdfTk9OWkVSTztmb3IodmFyIG89ci50ZXNzZWxhdGUobih7Y29udG91cnM6ZCx3aW5kaW5nUnVsZTp1LGVsZW1lbnRUeXBlOnIuUE9MWUdPTlMscG9seVNpemU6Myx2ZXJ0ZXhTaXplOjJ9LGcpKSxjPVtdLHA9MDtwPG8udmVydGljZXMubGVuZ3RoO3ArPWcudmVydGV4U2l6ZSl7dmFyIGw9by52ZXJ0aWNlcy5zbGljZShwLHArZy52ZXJ0ZXhTaXplKTtjLnB1c2gobCl9dmFyIHk9W107Zm9yKHA9MDtwPG8uZWxlbWVudHMubGVuZ3RoO3ArPTMpe3ZhciB4PW8uZWxlbWVudHNbcF0sYj1vLmVsZW1lbnRzW3ArMV0sRT1vLmVsZW1lbnRzW3ArMl07eS5wdXNoKFt4LGIsRV0pfXJldHVybntwb3NpdGlvbnM6YyxjZWxsczp5fX19LGZ1bmN0aW9uKGgsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9e30sbj17fTtoLmV4cG9ydHM9cixyLldJTkRJTkdfT0REPTAsci5XSU5ESU5HX05PTlpFUk89MSxyLldJTkRJTkdfUE9TSVRJVkU9MixyLldJTkRJTkdfTkVHQVRJVkU9MyxyLldJTkRJTkdfQUJTX0dFUV9UV089NCxyLlBPTFlHT05TPTAsci5DT05ORUNURURfUE9MWUdPTlM9MSxyLkJPVU5EQVJZX0NPTlRPVVJTPTIsci50ZXNzZWxhdGU9ZnVuY3Rpb24oaSl7Zm9yKHZhciBhPWkuZGVidWd8fCExLHM9bmV3IE0sZj0wO2Y8aS5jb250b3Vycy5sZW5ndGg7ZisrKXMuYWRkQ29udG91cihpLnZlcnRleFNpemV8fDIsaS5jb250b3Vyc1tmXSk7cmV0dXJuIHMudGVzc2VsYXRlKGkud2luZGluZ1J1bGV8fHIuV0lORElOR19PREQsaS5lbGVtZW50VHlwZXx8ci5QT0xZR09OUyxpLnBvbHlTaXplfHwzLGkudmVydGV4U2l6ZXx8MixpLm5vcm1hbHx8WzAsMCwxXSkse3ZlcnRpY2VzOnMudmVydGljZXMsdmVydGV4SW5kaWNlczpzLnZlcnRleEluZGljZXMsdmVydGV4Q291bnQ6cy52ZXJ0ZXhDb3VudCxlbGVtZW50czpzLmVsZW1lbnRzLGVsZW1lbnRDb3VudDpzLmVsZW1lbnRDb3VudCxtZXNoOmE/cy5tZXNoOnZvaWQgMH19O3ZhciBkPWZ1bmN0aW9uKGkpe2lmKCFpKXRocm93IkFzc2VydGlvbiBGYWlsZWQhIn07ZnVuY3Rpb24gZygpe3RoaXMubmV4dD1udWxsLHRoaXMucHJldj1udWxsLHRoaXMuYW5FZGdlPW51bGwsdGhpcy5jb29yZHM9WzAsMCwwXSx0aGlzLnM9MCx0aGlzLnQ9MCx0aGlzLnBxSGFuZGxlPTAsdGhpcy5uPTAsdGhpcy5pZHg9MH1mdW5jdGlvbiB1KCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLnRyYWlsPW51bGwsdGhpcy5uPTAsdGhpcy5tYXJrZWQ9ITEsdGhpcy5pbnNpZGU9ITF9ZnVuY3Rpb24gbyhpKXt0aGlzLm5leHQ9bnVsbCx0aGlzLlN5bT1udWxsLHRoaXMuT25leHQ9bnVsbCx0aGlzLkxuZXh0PW51bGwsdGhpcy5Pcmc9bnVsbCx0aGlzLkxmYWNlPW51bGwsdGhpcy5hY3RpdmVSZWdpb249bnVsbCx0aGlzLndpbmRpbmc9MCx0aGlzLnNpZGU9aX1vLnByb3RvdHlwZT17Z2V0IFJmYWNlKCl7cmV0dXJuIHRoaXMuU3ltLkxmYWNlfSxzZXQgUmZhY2UoaSl7dGhpcy5TeW0uTGZhY2U9aX0sZ2V0IERzdCgpe3JldHVybiB0aGlzLlN5bS5Pcmd9LHNldCBEc3QoaSl7dGhpcy5TeW0uT3JnPWl9LGdldCBPcHJldigpe3JldHVybiB0aGlzLlN5bS5MbmV4dH0sc2V0IE9wcmV2KGkpe3RoaXMuU3ltLkxuZXh0PWl9LGdldCBMcHJldigpe3JldHVybiB0aGlzLk9uZXh0LlN5bX0sc2V0IExwcmV2KGkpe3RoaXMuT25leHQuU3ltPWl9LGdldCBEcHJldigpe3JldHVybiB0aGlzLkxuZXh0LlN5bX0sc2V0IERwcmV2KGkpe3RoaXMuTG5leHQuU3ltPWl9LGdldCBScHJldigpe3JldHVybiB0aGlzLlN5bS5PbmV4dH0sc2V0IFJwcmV2KGkpe3RoaXMuU3ltLk9uZXh0PWl9LGdldCBEbmV4dCgpe3JldHVybiB0aGlzLlN5bS5PbmV4dC5TeW19LHNldCBEbmV4dChpKXt0aGlzLlN5bS5PbmV4dC5TeW09aX0sZ2V0IFJuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0LlN5bX0sc2V0IFJuZXh0KGkpe3RoaXMuU3ltLkxuZXh0LlN5bT1pfX07ZnVuY3Rpb24gYygpe3ZhciBpPW5ldyBnLGE9bmV3IHUscz1uZXcgbygwKSxmPW5ldyBvKDEpO2kubmV4dD1pLnByZXY9aSxpLmFuRWRnZT1udWxsLGEubmV4dD1hLnByZXY9YSxhLmFuRWRnZT1udWxsLGEudHJhaWw9bnVsbCxhLm1hcmtlZD0hMSxhLmluc2lkZT0hMSxzLm5leHQ9cyxzLlN5bT1mLHMuT25leHQ9bnVsbCxzLkxuZXh0PW51bGwscy5Pcmc9bnVsbCxzLkxmYWNlPW51bGwscy53aW5kaW5nPTAscy5hY3RpdmVSZWdpb249bnVsbCxmLm5leHQ9ZixmLlN5bT1zLGYuT25leHQ9bnVsbCxmLkxuZXh0PW51bGwsZi5Pcmc9bnVsbCxmLkxmYWNlPW51bGwsZi53aW5kaW5nPTAsZi5hY3RpdmVSZWdpb249bnVsbCx0aGlzLnZIZWFkPWksdGhpcy5mSGVhZD1hLHRoaXMuZUhlYWQ9cyx0aGlzLmVIZWFkU3ltPWZ9Yy5wcm90b3R5cGU9e21ha2VFZGdlXzpmdW5jdGlvbihpKXt2YXIgYT1uZXcgbygwKSxzPW5ldyBvKDEpO2kuU3ltLnNpZGU8aS5zaWRlJiYoaT1pLlN5bSk7dmFyIGY9aS5TeW0ubmV4dDtyZXR1cm4gcy5uZXh0PWYsZi5TeW0ubmV4dD1hLGEubmV4dD1pLGkuU3ltLm5leHQ9cyxhLlN5bT1zLGEuT25leHQ9YSxhLkxuZXh0PXMsYS5Pcmc9bnVsbCxhLkxmYWNlPW51bGwsYS53aW5kaW5nPTAsYS5hY3RpdmVSZWdpb249bnVsbCxzLlN5bT1hLHMuT25leHQ9cyxzLkxuZXh0PWEscy5Pcmc9bnVsbCxzLkxmYWNlPW51bGwscy53aW5kaW5nPTAscy5hY3RpdmVSZWdpb249bnVsbCxhfSxzcGxpY2VfOmZ1bmN0aW9uKGksYSl7dmFyIHM9aS5PbmV4dCxmPWEuT25leHQ7cy5TeW0uTG5leHQ9YSxmLlN5bS5MbmV4dD1pLGkuT25leHQ9ZixhLk9uZXh0PXN9LG1ha2VWZXJ0ZXhfOmZ1bmN0aW9uKGksYSxzKXt2YXIgZj1pO2QoZiE9PW51bGwpO3ZhciBPPXMucHJldjtmLnByZXY9TyxPLm5leHQ9ZixmLm5leHQ9cyxzLnByZXY9ZixmLmFuRWRnZT1hO3ZhciBBPWE7ZG8gQS5Pcmc9ZixBPUEuT25leHQ7d2hpbGUoQSE9PWEpfSxtYWtlRmFjZV86ZnVuY3Rpb24oaSxhLHMpe3ZhciBmPWk7ZChmIT09bnVsbCk7dmFyIE89cy5wcmV2O2YucHJldj1PLE8ubmV4dD1mLGYubmV4dD1zLHMucHJldj1mLGYuYW5FZGdlPWEsZi50cmFpbD1udWxsLGYubWFya2VkPSExLGYuaW5zaWRlPXMuaW5zaWRlO3ZhciBBPWE7ZG8gQS5MZmFjZT1mLEE9QS5MbmV4dDt3aGlsZShBIT09YSl9LGtpbGxFZGdlXzpmdW5jdGlvbihpKXtpLlN5bS5zaWRlPGkuc2lkZSYmKGk9aS5TeW0pO3ZhciBhPWkubmV4dCxzPWkuU3ltLm5leHQ7YS5TeW0ubmV4dD1zLHMuU3ltLm5leHQ9YX0sa2lsbFZlcnRleF86ZnVuY3Rpb24oaSxhKXt2YXIgcz1pLmFuRWRnZSxmPXM7ZG8gZi5Pcmc9YSxmPWYuT25leHQ7d2hpbGUoZiE9PXMpO3ZhciBPPWkucHJldixBPWkubmV4dDtBLnByZXY9TyxPLm5leHQ9QX0sa2lsbEZhY2VfOmZ1bmN0aW9uKGksYSl7dmFyIHM9aS5hbkVkZ2UsZj1zO2RvIGYuTGZhY2U9YSxmPWYuTG5leHQ7d2hpbGUoZiE9PXMpO3ZhciBPPWkucHJldixBPWkubmV4dDtBLnByZXY9TyxPLm5leHQ9QX0sbWFrZUVkZ2U6ZnVuY3Rpb24oKXt2YXIgaT1uZXcgZyxhPW5ldyBnLHM9bmV3IHUsZj10aGlzLm1ha2VFZGdlXyh0aGlzLmVIZWFkKTtyZXR1cm4gdGhpcy5tYWtlVmVydGV4XyhpLGYsdGhpcy52SGVhZCksdGhpcy5tYWtlVmVydGV4XyhhLGYuU3ltLHRoaXMudkhlYWQpLHRoaXMubWFrZUZhY2VfKHMsZix0aGlzLmZIZWFkKSxmfSxzcGxpY2U6ZnVuY3Rpb24oaSxhKXt2YXIgcz0hMSxmPSExO2lmKGkhPT1hKXtpZihhLk9yZyE9PWkuT3JnJiYoZj0hMCx0aGlzLmtpbGxWZXJ0ZXhfKGEuT3JnLGkuT3JnKSksYS5MZmFjZSE9PWkuTGZhY2UmJihzPSEwLHRoaXMua2lsbEZhY2VfKGEuTGZhY2UsaS5MZmFjZSkpLHRoaXMuc3BsaWNlXyhhLGkpLCFmKXt2YXIgTz1uZXcgZzt0aGlzLm1ha2VWZXJ0ZXhfKE8sYSxpLk9yZyksaS5PcmcuYW5FZGdlPWl9aWYoIXMpe3ZhciBBPW5ldyB1O3RoaXMubWFrZUZhY2VfKEEsYSxpLkxmYWNlKSxpLkxmYWNlLmFuRWRnZT1pfX19LGRlbGV0ZTpmdW5jdGlvbihpKXt2YXIgYT1pLlN5bSxzPSExO2lmKGkuTGZhY2UhPT1pLlJmYWNlJiYocz0hMCx0aGlzLmtpbGxGYWNlXyhpLkxmYWNlLGkuUmZhY2UpKSxpLk9uZXh0PT09aSl0aGlzLmtpbGxWZXJ0ZXhfKGkuT3JnLG51bGwpO2Vsc2UgaWYoaS5SZmFjZS5hbkVkZ2U9aS5PcHJldixpLk9yZy5hbkVkZ2U9aS5PbmV4dCx0aGlzLnNwbGljZV8oaSxpLk9wcmV2KSwhcyl7dmFyIGY9bmV3IHU7dGhpcy5tYWtlRmFjZV8oZixpLGkuTGZhY2UpfWEuT25leHQ9PT1hPyh0aGlzLmtpbGxWZXJ0ZXhfKGEuT3JnLG51bGwpLHRoaXMua2lsbEZhY2VfKGEuTGZhY2UsbnVsbCkpOihpLkxmYWNlLmFuRWRnZT1hLk9wcmV2LGEuT3JnLmFuRWRnZT1hLk9uZXh0LHRoaXMuc3BsaWNlXyhhLGEuT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhpKX0sYWRkRWRnZVZlcnRleDpmdW5jdGlvbihpKXt2YXIgYT10aGlzLm1ha2VFZGdlXyhpKSxzPWEuU3ltO3RoaXMuc3BsaWNlXyhhLGkuTG5leHQpLGEuT3JnPWkuRHN0O3ZhciBmPW5ldyBnO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKGYscyxhLk9yZyksYS5MZmFjZT1zLkxmYWNlPWkuTGZhY2UsYX0sc3BsaXRFZGdlOmZ1bmN0aW9uKGksYSl7dmFyIHM9dGhpcy5hZGRFZGdlVmVydGV4KGkpLGY9cy5TeW07cmV0dXJuIHRoaXMuc3BsaWNlXyhpLlN5bSxpLlN5bS5PcHJldiksdGhpcy5zcGxpY2VfKGkuU3ltLGYpLGkuRHN0PWYuT3JnLGYuRHN0LmFuRWRnZT1mLlN5bSxmLlJmYWNlPWkuUmZhY2UsZi53aW5kaW5nPWkud2luZGluZyxmLlN5bS53aW5kaW5nPWkuU3ltLndpbmRpbmcsZn0sY29ubmVjdDpmdW5jdGlvbihpLGEpe3ZhciBzPSExLGY9dGhpcy5tYWtlRWRnZV8oaSksTz1mLlN5bTtpZihhLkxmYWNlIT09aS5MZmFjZSYmKHM9ITAsdGhpcy5raWxsRmFjZV8oYS5MZmFjZSxpLkxmYWNlKSksdGhpcy5zcGxpY2VfKGYsaS5MbmV4dCksdGhpcy5zcGxpY2VfKE8sYSksZi5Pcmc9aS5Ec3QsTy5Pcmc9YS5PcmcsZi5MZmFjZT1PLkxmYWNlPWkuTGZhY2UsaS5MZmFjZS5hbkVkZ2U9Tywhcyl7dmFyIEE9bmV3IHU7dGhpcy5tYWtlRmFjZV8oQSxmLGkuTGZhY2UpfXJldHVybiBmfSx6YXBGYWNlOmZ1bmN0aW9uKGkpe3ZhciBhPWkuYW5FZGdlLHMsZixPLEEsUjtmPWEuTG5leHQ7ZG8gcz1mLGY9cy5MbmV4dCxzLkxmYWNlPW51bGwscy5SZmFjZT09PW51bGwmJihzLk9uZXh0PT09cz90aGlzLmtpbGxWZXJ0ZXhfKHMuT3JnLG51bGwpOihzLk9yZy5hbkVkZ2U9cy5PbmV4dCx0aGlzLnNwbGljZV8ocyxzLk9wcmV2KSksTz1zLlN5bSxPLk9uZXh0PT09Tz90aGlzLmtpbGxWZXJ0ZXhfKE8uT3JnLG51bGwpOihPLk9yZy5hbkVkZ2U9Ty5PbmV4dCx0aGlzLnNwbGljZV8oTyxPLk9wcmV2KSksdGhpcy5raWxsRWRnZV8ocykpO3doaWxlKHMhPWEpO0E9aS5wcmV2LFI9aS5uZXh0LFIucHJldj1BLEEubmV4dD1SfSxjb3VudEZhY2VWZXJ0c186ZnVuY3Rpb24oaSl7dmFyIGE9aS5hbkVkZ2Uscz0wO2RvIHMrKyxhPWEuTG5leHQ7d2hpbGUoYSE9PWkuYW5FZGdlKTtyZXR1cm4gc30sbWVyZ2VDb252ZXhGYWNlczpmdW5jdGlvbihpKXt2YXIgYSxzLGYsTyxBLFIsSTtmb3IoYT10aGlzLmZIZWFkLm5leHQ7YSE9PXRoaXMuZkhlYWQ7YT1hLm5leHQpaWYoYS5pbnNpZGUpZm9yKHM9YS5hbkVkZ2UsQT1zLk9yZztmPXMuTG5leHQsTz1zLlN5bSxPJiZPLkxmYWNlJiZPLkxmYWNlLmluc2lkZSYmKFI9dGhpcy5jb3VudEZhY2VWZXJ0c18oYSksST10aGlzLmNvdW50RmFjZVZlcnRzXyhPLkxmYWNlKSxSK0ktMjw9aSYmbi52ZXJ0Q0NXKHMuTHByZXYuT3JnLHMuT3JnLE8uTG5leHQuTG5leHQuT3JnKSYmbi52ZXJ0Q0NXKE8uTHByZXYuT3JnLE8uT3JnLHMuTG5leHQuTG5leHQuT3JnKSYmKGY9Ty5MbmV4dCx0aGlzLmRlbGV0ZShPKSxzPW51bGwsTz1udWxsKSksIShzJiZzLkxuZXh0Lk9yZz09PUEpOylzPWY7cmV0dXJuITB9LGNoZWNrOmZ1bmN0aW9uKCl7dmFyIGk9dGhpcy5mSGVhZCxhPXRoaXMudkhlYWQscz10aGlzLmVIZWFkLGYsTyxBLFIsSSxQO2ZvcihPPWksTz1pOyhmPU8ubmV4dCkhPT1pO089Zil7ZChmLnByZXY9PT1PKSxJPWYuYW5FZGdlO2RvIGQoSS5TeW0hPT1JKSxkKEkuU3ltLlN5bT09PUkpLGQoSS5MbmV4dC5PbmV4dC5TeW09PT1JKSxkKEkuT25leHQuU3ltLkxuZXh0PT09SSksZChJLkxmYWNlPT09ZiksST1JLkxuZXh0O3doaWxlKEkhPT1mLmFuRWRnZSl9Zm9yKGQoZi5wcmV2PT09TyYmZi5hbkVkZ2U9PT1udWxsKSxSPWEsUj1hOyhBPVIubmV4dCkhPT1hO1I9QSl7ZChBLnByZXY9PT1SKSxJPUEuYW5FZGdlO2RvIGQoSS5TeW0hPT1JKSxkKEkuU3ltLlN5bT09PUkpLGQoSS5MbmV4dC5PbmV4dC5TeW09PT1JKSxkKEkuT25leHQuU3ltLkxuZXh0PT09SSksZChJLk9yZz09PUEpLEk9SS5PbmV4dDt3aGlsZShJIT09QS5hbkVkZ2UpfWZvcihkKEEucHJldj09PVImJkEuYW5FZGdlPT09bnVsbCksUD1zLFA9czsoST1QLm5leHQpIT09cztQPUkpZChJLlN5bS5uZXh0PT09UC5TeW0pLGQoSS5TeW0hPT1JKSxkKEkuU3ltLlN5bT09PUkpLGQoSS5PcmchPT1udWxsKSxkKEkuRHN0IT09bnVsbCksZChJLkxuZXh0Lk9uZXh0LlN5bT09PUkpLGQoSS5PbmV4dC5TeW0uTG5leHQ9PT1JKTtkKEkuU3ltLm5leHQ9PT1QLlN5bSYmSS5TeW09PT10aGlzLmVIZWFkU3ltJiZJLlN5bS5TeW09PT1JJiZJLk9yZz09PW51bGwmJkkuRHN0PT09bnVsbCYmSS5MZmFjZT09PW51bGwmJkkuUmZhY2U9PT1udWxsKX19LG4udmVydEVxPWZ1bmN0aW9uKGksYSl7cmV0dXJuIGkucz09PWEucyYmaS50PT09YS50fSxuLnZlcnRMZXE9ZnVuY3Rpb24oaSxhKXtyZXR1cm4gaS5zPGEuc3x8aS5zPT09YS5zJiZpLnQ8PWEudH0sbi50cmFuc0xlcT1mdW5jdGlvbihpLGEpe3JldHVybiBpLnQ8YS50fHxpLnQ9PT1hLnQmJmkuczw9YS5zfSxuLmVkZ2VHb2VzTGVmdD1mdW5jdGlvbihpKXtyZXR1cm4gbi52ZXJ0TGVxKGkuRHN0LGkuT3JnKX0sbi5lZGdlR29lc1JpZ2h0PWZ1bmN0aW9uKGkpe3JldHVybiBuLnZlcnRMZXEoaS5PcmcsaS5Ec3QpfSxuLnZlcnRMMWRpc3Q9ZnVuY3Rpb24oaSxhKXtyZXR1cm4gTWF0aC5hYnMoaS5zLWEucykrTWF0aC5hYnMoaS50LWEudCl9LG4uZWRnZUV2YWw9ZnVuY3Rpb24oaSxhLHMpe2Qobi52ZXJ0TGVxKGksYSkmJm4udmVydExlcShhLHMpKTt2YXIgZj1hLnMtaS5zLE89cy5zLWEucztyZXR1cm4gZitPPjA/ZjxPP2EudC1pLnQrKGkudC1zLnQpKihmLyhmK08pKTphLnQtcy50KyhzLnQtaS50KSooTy8oZitPKSk6MH0sbi5lZGdlU2lnbj1mdW5jdGlvbihpLGEscyl7ZChuLnZlcnRMZXEoaSxhKSYmbi52ZXJ0TGVxKGEscykpO3ZhciBmPWEucy1pLnMsTz1zLnMtYS5zO3JldHVybiBmK08+MD8oYS50LXMudCkqZisoYS50LWkudCkqTzowfSxuLnRyYW5zRXZhbD1mdW5jdGlvbihpLGEscyl7ZChuLnRyYW5zTGVxKGksYSkmJm4udHJhbnNMZXEoYSxzKSk7dmFyIGY9YS50LWkudCxPPXMudC1hLnQ7cmV0dXJuIGYrTz4wP2Y8Tz9hLnMtaS5zKyhpLnMtcy5zKSooZi8oZitPKSk6YS5zLXMucysocy5zLWkucykqKE8vKGYrTykpOjB9LG4udHJhbnNTaWduPWZ1bmN0aW9uKGksYSxzKXtkKG4udHJhbnNMZXEoaSxhKSYmbi50cmFuc0xlcShhLHMpKTt2YXIgZj1hLnQtaS50LE89cy50LWEudDtyZXR1cm4gZitPPjA/KGEucy1zLnMpKmYrKGEucy1pLnMpKk86MH0sbi52ZXJ0Q0NXPWZ1bmN0aW9uKGksYSxzKXtyZXR1cm4gaS5zKihhLnQtcy50KSthLnMqKHMudC1pLnQpK3MucyooaS50LWEudCk+PTB9LG4uaW50ZXJwb2xhdGU9ZnVuY3Rpb24oaSxhLHMsZil7cmV0dXJuIGk9aTwwPzA6aSxzPXM8MD8wOnMsaTw9cz9zPT09MD8oYStmKS8yOmErKGYtYSkqKGkvKGkrcykpOmYrKGEtZikqKHMvKGkrcykpfSxuLmludGVyc2VjdD1mdW5jdGlvbihpLGEscyxmLE8pe3ZhciBBLFIsSTtuLnZlcnRMZXEoaSxhKXx8KEk9aSxpPWEsYT1JKSxuLnZlcnRMZXEocyxmKXx8KEk9cyxzPWYsZj1JKSxuLnZlcnRMZXEoaSxzKXx8KEk9aSxpPXMscz1JLEk9YSxhPWYsZj1JKSxuLnZlcnRMZXEocyxhKT9uLnZlcnRMZXEoYSxmKT8oQT1uLmVkZ2VFdmFsKGkscyxhKSxSPW4uZWRnZUV2YWwocyxhLGYpLEErUjwwJiYoQT0tQSxSPS1SKSxPLnM9bi5pbnRlcnBvbGF0ZShBLHMucyxSLGEucykpOihBPW4uZWRnZVNpZ24oaSxzLGEpLFI9LW4uZWRnZVNpZ24oaSxmLGEpLEErUjwwJiYoQT0tQSxSPS1SKSxPLnM9bi5pbnRlcnBvbGF0ZShBLHMucyxSLGYucykpOk8ucz0ocy5zK2EucykvMixuLnRyYW5zTGVxKGksYSl8fChJPWksaT1hLGE9SSksbi50cmFuc0xlcShzLGYpfHwoST1zLHM9ZixmPUkpLG4udHJhbnNMZXEoaSxzKXx8KEk9aSxpPXMscz1JLEk9YSxhPWYsZj1JKSxuLnRyYW5zTGVxKHMsYSk/bi50cmFuc0xlcShhLGYpPyhBPW4udHJhbnNFdmFsKGkscyxhKSxSPW4udHJhbnNFdmFsKHMsYSxmKSxBK1I8MCYmKEE9LUEsUj0tUiksTy50PW4uaW50ZXJwb2xhdGUoQSxzLnQsUixhLnQpKTooQT1uLnRyYW5zU2lnbihpLHMsYSksUj0tbi50cmFuc1NpZ24oaSxmLGEpLEErUjwwJiYoQT0tQSxSPS1SKSxPLnQ9bi5pbnRlcnBvbGF0ZShBLHMudCxSLGYudCkpOk8udD0ocy50K2EudCkvMn07ZnVuY3Rpb24gcCgpe3RoaXMua2V5PW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGx9ZnVuY3Rpb24gbChpLGEpe3RoaXMuaGVhZD1uZXcgcCx0aGlzLmhlYWQubmV4dD10aGlzLmhlYWQsdGhpcy5oZWFkLnByZXY9dGhpcy5oZWFkLHRoaXMuZnJhbWU9aSx0aGlzLmxlcT1hfWwucHJvdG90eXBlPXttaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkLm5leHR9LG1heDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQucHJldn0saW5zZXJ0OmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsaSl9LHNlYXJjaDpmdW5jdGlvbihpKXt2YXIgYT10aGlzLmhlYWQ7ZG8gYT1hLm5leHQ7d2hpbGUoYS5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxpLGEua2V5KSk7cmV0dXJuIGF9LGluc2VydEJlZm9yZTpmdW5jdGlvbihpLGEpe2RvIGk9aS5wcmV2O3doaWxlKGkua2V5IT09bnVsbCYmIXRoaXMubGVxKHRoaXMuZnJhbWUsaS5rZXksYSkpO3ZhciBzPW5ldyBwO3JldHVybiBzLmtleT1hLHMubmV4dD1pLm5leHQsaS5uZXh0LnByZXY9cyxzLnByZXY9aSxpLm5leHQ9cyxzfSxkZWxldGU6ZnVuY3Rpb24oaSl7aS5uZXh0LnByZXY9aS5wcmV2LGkucHJldi5uZXh0PWkubmV4dH19O2Z1bmN0aW9uIHkoKXt0aGlzLmhhbmRsZT1udWxsfWZ1bmN0aW9uIHgoKXt0aGlzLmtleT1udWxsLHRoaXMubm9kZT1udWxsfWZ1bmN0aW9uIGIoaSxhKXt0aGlzLnNpemU9MCx0aGlzLm1heD1pLHRoaXMubm9kZXM9W10sdGhpcy5ub2Rlcy5sZW5ndGg9aSsxO3ZhciBzO2ZvcihzPTA7czx0aGlzLm5vZGVzLmxlbmd0aDtzKyspdGhpcy5ub2Rlc1tzXT1uZXcgeTtmb3IodGhpcy5oYW5kbGVzPVtdLHRoaXMuaGFuZGxlcy5sZW5ndGg9aSsxLHM9MDtzPHRoaXMuaGFuZGxlcy5sZW5ndGg7cysrKXRoaXMuaGFuZGxlc1tzXT1uZXcgeDt0aGlzLmluaXRpYWxpemVkPSExLHRoaXMuZnJlZUxpc3Q9MCx0aGlzLmxlcT1hLHRoaXMubm9kZXNbMV0uaGFuZGxlPTEsdGhpcy5oYW5kbGVzWzFdLmtleT1udWxsfWIucHJvdG90eXBlPXtmbG9hdERvd25fOmZ1bmN0aW9uKGkpe3ZhciBhPXRoaXMubm9kZXMscz10aGlzLmhhbmRsZXMsZixPLEE7Zm9yKGY9YVtpXS5oYW5kbGU7Oyl7aWYoQT1pPDwxLEE8dGhpcy5zaXplJiZ0aGlzLmxlcShzW2FbQSsxXS5oYW5kbGVdLmtleSxzW2FbQV0uaGFuZGxlXS5rZXkpJiYrK0EsZChBPD10aGlzLm1heCksTz1hW0FdLmhhbmRsZSxBPnRoaXMuc2l6ZXx8dGhpcy5sZXEoc1tmXS5rZXksc1tPXS5rZXkpKXthW2ldLmhhbmRsZT1mLHNbZl0ubm9kZT1pO2JyZWFrfWFbaV0uaGFuZGxlPU8sc1tPXS5ub2RlPWksaT1BfX0sZmxvYXRVcF86ZnVuY3Rpb24oaSl7dmFyIGE9dGhpcy5ub2RlcyxzPXRoaXMuaGFuZGxlcyxmLE8sQTtmb3IoZj1hW2ldLmhhbmRsZTs7KXtpZihBPWk+PjEsTz1hW0FdLmhhbmRsZSxBPT09MHx8dGhpcy5sZXEoc1tPXS5rZXksc1tmXS5rZXkpKXthW2ldLmhhbmRsZT1mLHNbZl0ubm9kZT1pO2JyZWFrfWFbaV0uaGFuZGxlPU8sc1tPXS5ub2RlPWksaT1BfX0saW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgaT10aGlzLnNpemU7aT49MTstLWkpdGhpcy5mbG9hdERvd25fKGkpO3RoaXMuaW5pdGlhbGl6ZWQ9ITB9LG1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhbmRsZXNbdGhpcy5ub2Rlc1sxXS5oYW5kbGVdLmtleX0saW5zZXJ0OmZ1bmN0aW9uKGkpe3ZhciBhLHM7aWYoYT0rK3RoaXMuc2l6ZSxhKjI+dGhpcy5tYXgpe3RoaXMubWF4Kj0yO3ZhciBmLE87Zm9yKE89dGhpcy5ub2Rlcy5sZW5ndGgsdGhpcy5ub2Rlcy5sZW5ndGg9dGhpcy5tYXgrMSxmPU87Zjx0aGlzLm5vZGVzLmxlbmd0aDtmKyspdGhpcy5ub2Rlc1tmXT1uZXcgeTtmb3IoTz10aGlzLmhhbmRsZXMubGVuZ3RoLHRoaXMuaGFuZGxlcy5sZW5ndGg9dGhpcy5tYXgrMSxmPU87Zjx0aGlzLmhhbmRsZXMubGVuZ3RoO2YrKyl0aGlzLmhhbmRsZXNbZl09bmV3IHh9cmV0dXJuIHRoaXMuZnJlZUxpc3Q9PT0wP3M9YToocz10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9dGhpcy5oYW5kbGVzW3NdLm5vZGUpLHRoaXMubm9kZXNbYV0uaGFuZGxlPXMsdGhpcy5oYW5kbGVzW3NdLm5vZGU9YSx0aGlzLmhhbmRsZXNbc10ua2V5PWksdGhpcy5pbml0aWFsaXplZCYmdGhpcy5mbG9hdFVwXyhhKSxzfSxleHRyYWN0TWluOmZ1bmN0aW9uKCl7dmFyIGk9dGhpcy5ub2RlcyxhPXRoaXMuaGFuZGxlcyxzPWlbMV0uaGFuZGxlLGY9YVtzXS5rZXk7cmV0dXJuIHRoaXMuc2l6ZT4wJiYoaVsxXS5oYW5kbGU9aVt0aGlzLnNpemVdLmhhbmRsZSxhW2lbMV0uaGFuZGxlXS5ub2RlPTEsYVtzXS5rZXk9bnVsbCxhW3NdLm5vZGU9dGhpcy5mcmVlTGlzdCx0aGlzLmZyZWVMaXN0PXMsLS10aGlzLnNpemUsdGhpcy5zaXplPjAmJnRoaXMuZmxvYXREb3duXygxKSksZn0sZGVsZXRlOmZ1bmN0aW9uKGkpe3ZhciBhPXRoaXMubm9kZXMscz10aGlzLmhhbmRsZXMsZjtkKGk+PTEmJmk8PXRoaXMubWF4JiZzW2ldLmtleSE9PW51bGwpLGY9c1tpXS5ub2RlLGFbZl0uaGFuZGxlPWFbdGhpcy5zaXplXS5oYW5kbGUsc1thW2ZdLmhhbmRsZV0ubm9kZT1mLC0tdGhpcy5zaXplLGY8PXRoaXMuc2l6ZSYmKGY8PTF8fHRoaXMubGVxKHNbYVtmPj4xXS5oYW5kbGVdLmtleSxzW2FbZl0uaGFuZGxlXS5rZXkpP3RoaXMuZmxvYXREb3duXyhmKTp0aGlzLmZsb2F0VXBfKGYpKSxzW2ldLmtleT1udWxsLHNbaV0ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9aX19O2Z1bmN0aW9uIEUoKXt0aGlzLmVVcD1udWxsLHRoaXMubm9kZVVwPW51bGwsdGhpcy53aW5kaW5nTnVtYmVyPTAsdGhpcy5pbnNpZGU9ITEsdGhpcy5zZW50aW5lbD0hMSx0aGlzLmRpcnR5PSExLHRoaXMuZml4VXBwZXJFZGdlPSExfXZhciB2PXt9O3YucmVnaW9uQmVsb3c9ZnVuY3Rpb24oaSl7cmV0dXJuIGkubm9kZVVwLnByZXYua2V5fSx2LnJlZ2lvbkFib3ZlPWZ1bmN0aW9uKGkpe3JldHVybiBpLm5vZGVVcC5uZXh0LmtleX0sdi5kZWJ1Z0V2ZW50PWZ1bmN0aW9uKGkpe30sdi5hZGRXaW5kaW5nPWZ1bmN0aW9uKGksYSl7aS53aW5kaW5nKz1hLndpbmRpbmcsaS5TeW0ud2luZGluZys9YS5TeW0ud2luZGluZ30sdi5lZGdlTGVxPWZ1bmN0aW9uKGksYSxzKXt2YXIgZj1pLmV2ZW50LFIsSSxPPWEuZVVwLEE9cy5lVXA7aWYoTy5Ec3Q9PT1mKXJldHVybiBBLkRzdD09PWY/bi52ZXJ0TGVxKE8uT3JnLEEuT3JnKT9uLmVkZ2VTaWduKEEuRHN0LE8uT3JnLEEuT3JnKTw9MDpuLmVkZ2VTaWduKE8uRHN0LEEuT3JnLE8uT3JnKT49MDpuLmVkZ2VTaWduKEEuRHN0LGYsQS5PcmcpPD0wO2lmKEEuRHN0PT09ZilyZXR1cm4gbi5lZGdlU2lnbihPLkRzdCxmLE8uT3JnKT49MDt2YXIgUj1uLmVkZ2VFdmFsKE8uRHN0LGYsTy5PcmcpLEk9bi5lZGdlRXZhbChBLkRzdCxmLEEuT3JnKTtyZXR1cm4gUj49SX0sdi5kZWxldGVSZWdpb249ZnVuY3Rpb24oaSxhKXthLmZpeFVwcGVyRWRnZSYmZChhLmVVcC53aW5kaW5nPT09MCksYS5lVXAuYWN0aXZlUmVnaW9uPW51bGwsaS5kaWN0LmRlbGV0ZShhLm5vZGVVcCl9LHYuZml4VXBwZXJFZGdlPWZ1bmN0aW9uKGksYSxzKXtkKGEuZml4VXBwZXJFZGdlKSxpLm1lc2guZGVsZXRlKGEuZVVwKSxhLmZpeFVwcGVyRWRnZT0hMSxhLmVVcD1zLHMuYWN0aXZlUmVnaW9uPWF9LHYudG9wTGVmdFJlZ2lvbj1mdW5jdGlvbihpLGEpe3ZhciBzPWEuZVVwLk9yZyxmO2RvIGE9di5yZWdpb25BYm92ZShhKTt3aGlsZShhLmVVcC5Pcmc9PT1zKTtpZihhLmZpeFVwcGVyRWRnZSl7aWYoZj1pLm1lc2guY29ubmVjdCh2LnJlZ2lvbkJlbG93KGEpLmVVcC5TeW0sYS5lVXAuTG5leHQpLGY9PT1udWxsKXJldHVybiBudWxsO3YuZml4VXBwZXJFZGdlKGksYSxmKSxhPXYucmVnaW9uQWJvdmUoYSl9cmV0dXJuIGF9LHYudG9wUmlnaHRSZWdpb249ZnVuY3Rpb24oaSl7dmFyIGE9aS5lVXAuRHN0O2RvIGk9di5yZWdpb25BYm92ZShpKTt3aGlsZShpLmVVcC5Ec3Q9PT1hKTtyZXR1cm4gaX0sdi5hZGRSZWdpb25CZWxvdz1mdW5jdGlvbihpLGEscyl7dmFyIGY9bmV3IEU7cmV0dXJuIGYuZVVwPXMsZi5ub2RlVXA9aS5kaWN0Lmluc2VydEJlZm9yZShhLm5vZGVVcCxmKSxmLmZpeFVwcGVyRWRnZT0hMSxmLnNlbnRpbmVsPSExLGYuZGlydHk9ITEscy5hY3RpdmVSZWdpb249ZixmfSx2LmlzV2luZGluZ0luc2lkZT1mdW5jdGlvbihpLGEpe3N3aXRjaChpLndpbmRpbmdSdWxlKXtjYXNlIHIuV0lORElOR19PREQ6cmV0dXJuKGEmMSkhPT0wO2Nhc2Ugci5XSU5ESU5HX05PTlpFUk86cmV0dXJuIGEhPT0wO2Nhc2Ugci5XSU5ESU5HX1BPU0lUSVZFOnJldHVybiBhPjA7Y2FzZSByLldJTkRJTkdfTkVHQVRJVkU6cmV0dXJuIGE8MDtjYXNlIHIuV0lORElOR19BQlNfR0VRX1RXTzpyZXR1cm4gYT49Mnx8YTw9LTJ9cmV0dXJuIGQoITEpLCExfSx2LmNvbXB1dGVXaW5kaW5nPWZ1bmN0aW9uKGksYSl7YS53aW5kaW5nTnVtYmVyPXYucmVnaW9uQWJvdmUoYSkud2luZGluZ051bWJlcithLmVVcC53aW5kaW5nLGEuaW5zaWRlPXYuaXNXaW5kaW5nSW5zaWRlKGksYS53aW5kaW5nTnVtYmVyKX0sdi5maW5pc2hSZWdpb249ZnVuY3Rpb24oaSxhKXt2YXIgcz1hLmVVcCxmPXMuTGZhY2U7Zi5pbnNpZGU9YS5pbnNpZGUsZi5hbkVkZ2U9cyx2LmRlbGV0ZVJlZ2lvbihpLGEpfSx2LmZpbmlzaExlZnRSZWdpb25zPWZ1bmN0aW9uKGksYSxzKXtmb3IodmFyIGYsUixPPW51bGwsQT1hLFI9YS5lVXA7QSE9PXM7KXtpZihBLmZpeFVwcGVyRWRnZT0hMSxPPXYucmVnaW9uQmVsb3coQSksZj1PLmVVcCxmLk9yZyE9Ui5Pcmcpe2lmKCFPLmZpeFVwcGVyRWRnZSl7di5maW5pc2hSZWdpb24oaSxBKTticmVha31mPWkubWVzaC5jb25uZWN0KFIuTHByZXYsZi5TeW0pLHYuZml4VXBwZXJFZGdlKGksTyxmKX1SLk9uZXh0IT09ZiYmKGkubWVzaC5zcGxpY2UoZi5PcHJldixmKSxpLm1lc2guc3BsaWNlKFIsZikpLHYuZmluaXNoUmVnaW9uKGksQSksUj1PLmVVcCxBPU99cmV0dXJuIFJ9LHYuYWRkUmlnaHRFZGdlcz1mdW5jdGlvbihpLGEscyxmLE8sQSl7dmFyIFIsSSxQLEwsRD0hMDtQPXM7ZG8gZChuLnZlcnRMZXEoUC5PcmcsUC5Ec3QpKSx2LmFkZFJlZ2lvbkJlbG93KGksYSxQLlN5bSksUD1QLk9uZXh0O3doaWxlKFAhPT1mKTtmb3IoTz09PW51bGwmJihPPXYucmVnaW9uQmVsb3coYSkuZVVwLlJwcmV2KSxJPWEsTD1PO1I9di5yZWdpb25CZWxvdyhJKSxQPVIuZVVwLlN5bSxQLk9yZz09PUwuT3JnOylQLk9uZXh0IT09TCYmKGkubWVzaC5zcGxpY2UoUC5PcHJldixQKSxpLm1lc2guc3BsaWNlKEwuT3ByZXYsUCkpLFIud2luZGluZ051bWJlcj1JLndpbmRpbmdOdW1iZXItUC53aW5kaW5nLFIuaW5zaWRlPXYuaXNXaW5kaW5nSW5zaWRlKGksUi53aW5kaW5nTnVtYmVyKSxJLmRpcnR5PSEwLCFEJiZ2LmNoZWNrRm9yUmlnaHRTcGxpY2UoaSxJKSYmKHYuYWRkV2luZGluZyhQLEwpLHYuZGVsZXRlUmVnaW9uKGksSSksaS5tZXNoLmRlbGV0ZShMKSksRD0hMSxJPVIsTD1QO0kuZGlydHk9ITAsZChJLndpbmRpbmdOdW1iZXItUC53aW5kaW5nPT09Ui53aW5kaW5nTnVtYmVyKSxBJiZ2LndhbGtEaXJ0eVJlZ2lvbnMoaSxJKX0sdi5zcGxpY2VNZXJnZVZlcnRpY2VzPWZ1bmN0aW9uKGksYSxzKXtpLm1lc2guc3BsaWNlKGEscyl9LHYudmVydGV4V2VpZ2h0cz1mdW5jdGlvbihpLGEscyl7dmFyIGY9bi52ZXJ0TDFkaXN0KGEsaSksTz1uLnZlcnRMMWRpc3QocyxpKSxBPS41Kk8vKGYrTyksUj0uNSpmLyhmK08pO2kuY29vcmRzWzBdKz1BKmEuY29vcmRzWzBdK1Iqcy5jb29yZHNbMF0saS5jb29yZHNbMV0rPUEqYS5jb29yZHNbMV0rUipzLmNvb3Jkc1sxXSxpLmNvb3Jkc1syXSs9QSphLmNvb3Jkc1syXStSKnMuY29vcmRzWzJdfSx2LmdldEludGVyc2VjdERhdGE9ZnVuY3Rpb24oaSxhLHMsZixPLEEpe2EuY29vcmRzWzBdPWEuY29vcmRzWzFdPWEuY29vcmRzWzJdPTAsYS5pZHg9LTEsdi52ZXJ0ZXhXZWlnaHRzKGEscyxmKSx2LnZlcnRleFdlaWdodHMoYSxPLEEpfSx2LmNoZWNrRm9yUmlnaHRTcGxpY2U9ZnVuY3Rpb24oaSxhKXt2YXIgcz12LnJlZ2lvbkJlbG93KGEpLGY9YS5lVXAsTz1zLmVVcDtpZihuLnZlcnRMZXEoZi5PcmcsTy5PcmcpKXtpZihuLmVkZ2VTaWduKE8uRHN0LGYuT3JnLE8uT3JnKT4wKXJldHVybiExO24udmVydEVxKGYuT3JnLE8uT3JnKT9mLk9yZyE9PU8uT3JnJiYoaS5wcS5kZWxldGUoZi5PcmcucHFIYW5kbGUpLHYuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhpLE8uT3ByZXYsZikpOihpLm1lc2guc3BsaXRFZGdlKE8uU3ltKSxpLm1lc2guc3BsaWNlKGYsTy5PcHJldiksYS5kaXJ0eT1zLmRpcnR5PSEwKX1lbHNle2lmKG4uZWRnZVNpZ24oZi5Ec3QsTy5PcmcsZi5PcmcpPDApcmV0dXJuITE7di5yZWdpb25BYm92ZShhKS5kaXJ0eT1hLmRpcnR5PSEwLGkubWVzaC5zcGxpdEVkZ2UoZi5TeW0pLGkubWVzaC5zcGxpY2UoTy5PcHJldixmKX1yZXR1cm4hMH0sdi5jaGVja0ZvckxlZnRTcGxpY2U9ZnVuY3Rpb24oaSxhKXt2YXIgcz12LnJlZ2lvbkJlbG93KGEpLGY9YS5lVXAsTz1zLmVVcCxBO2lmKGQoIW4udmVydEVxKGYuRHN0LE8uRHN0KSksbi52ZXJ0TGVxKGYuRHN0LE8uRHN0KSl7aWYobi5lZGdlU2lnbihmLkRzdCxPLkRzdCxmLk9yZyk8MClyZXR1cm4hMTt2LnJlZ2lvbkFib3ZlKGEpLmRpcnR5PWEuZGlydHk9ITAsQT1pLm1lc2guc3BsaXRFZGdlKGYpLGkubWVzaC5zcGxpY2UoTy5TeW0sQSksQS5MZmFjZS5pbnNpZGU9YS5pbnNpZGV9ZWxzZXtpZihuLmVkZ2VTaWduKE8uRHN0LGYuRHN0LE8uT3JnKT4wKXJldHVybiExO2EuZGlydHk9cy5kaXJ0eT0hMCxBPWkubWVzaC5zcGxpdEVkZ2UoTyksaS5tZXNoLnNwbGljZShmLkxuZXh0LE8uU3ltKSxBLlJmYWNlLmluc2lkZT1hLmluc2lkZX1yZXR1cm4hMH0sdi5jaGVja0ZvckludGVyc2VjdD1mdW5jdGlvbihpLGEpe3ZhciBzPXYucmVnaW9uQmVsb3coYSksZj1hLmVVcCxPPXMuZVVwLEE9Zi5PcmcsUj1PLk9yZyxJPWYuRHN0LFA9Ty5Ec3QsTCxELEM9bmV3IGcsUyxCO2lmKGQoIW4udmVydEVxKFAsSSkpLGQobi5lZGdlU2lnbihJLGkuZXZlbnQsQSk8PTApLGQobi5lZGdlU2lnbihQLGkuZXZlbnQsUik+PTApLGQoQSE9PWkuZXZlbnQmJlIhPT1pLmV2ZW50KSxkKCFhLmZpeFVwcGVyRWRnZSYmIXMuZml4VXBwZXJFZGdlKSxBPT09Unx8KEw9TWF0aC5taW4oQS50LEkudCksRD1NYXRoLm1heChSLnQsUC50KSxMPkQpKXJldHVybiExO2lmKG4udmVydExlcShBLFIpKXtpZihuLmVkZ2VTaWduKFAsQSxSKT4wKXJldHVybiExfWVsc2UgaWYobi5lZGdlU2lnbihJLFIsQSk8MClyZXR1cm4hMTtyZXR1cm4gdi5kZWJ1Z0V2ZW50KGkpLG4uaW50ZXJzZWN0KEksQSxQLFIsQyksZChNYXRoLm1pbihBLnQsSS50KTw9Qy50KSxkKEMudDw9TWF0aC5tYXgoUi50LFAudCkpLGQoTWF0aC5taW4oUC5zLEkucyk8PUMucyksZChDLnM8PU1hdGgubWF4KFIucyxBLnMpKSxuLnZlcnRMZXEoQyxpLmV2ZW50KSYmKEMucz1pLmV2ZW50LnMsQy50PWkuZXZlbnQudCksUz1uLnZlcnRMZXEoQSxSKT9BOlIsbi52ZXJ0TGVxKFMsQykmJihDLnM9Uy5zLEMudD1TLnQpLG4udmVydEVxKEMsQSl8fG4udmVydEVxKEMsUik/KHYuY2hlY2tGb3JSaWdodFNwbGljZShpLGEpLCExKTohbi52ZXJ0RXEoSSxpLmV2ZW50KSYmbi5lZGdlU2lnbihJLGkuZXZlbnQsQyk+PTB8fCFuLnZlcnRFcShQLGkuZXZlbnQpJiZuLmVkZ2VTaWduKFAsaS5ldmVudCxDKTw9MD9QPT09aS5ldmVudD8oaS5tZXNoLnNwbGl0RWRnZShmLlN5bSksaS5tZXNoLnNwbGljZShPLlN5bSxmKSxhPXYudG9wTGVmdFJlZ2lvbihpLGEpLGY9di5yZWdpb25CZWxvdyhhKS5lVXAsdi5maW5pc2hMZWZ0UmVnaW9ucyhpLHYucmVnaW9uQmVsb3coYSkscyksdi5hZGRSaWdodEVkZ2VzKGksYSxmLk9wcmV2LGYsZiwhMCksITApOkk9PT1pLmV2ZW50PyhpLm1lc2guc3BsaXRFZGdlKE8uU3ltKSxpLm1lc2guc3BsaWNlKGYuTG5leHQsTy5PcHJldikscz1hLGE9di50b3BSaWdodFJlZ2lvbihhKSxCPXYucmVnaW9uQmVsb3coYSkuZVVwLlJwcmV2LHMuZVVwPU8uT3ByZXYsTz12LmZpbmlzaExlZnRSZWdpb25zKGkscyxudWxsKSx2LmFkZFJpZ2h0RWRnZXMoaSxhLE8uT25leHQsZi5ScHJldixCLCEwKSwhMCk6KG4uZWRnZVNpZ24oSSxpLmV2ZW50LEMpPj0wJiYodi5yZWdpb25BYm92ZShhKS5kaXJ0eT1hLmRpcnR5PSEwLGkubWVzaC5zcGxpdEVkZ2UoZi5TeW0pLGYuT3JnLnM9aS5ldmVudC5zLGYuT3JnLnQ9aS5ldmVudC50KSxuLmVkZ2VTaWduKFAsaS5ldmVudCxDKTw9MCYmKGEuZGlydHk9cy5kaXJ0eT0hMCxpLm1lc2guc3BsaXRFZGdlKE8uU3ltKSxPLk9yZy5zPWkuZXZlbnQucyxPLk9yZy50PWkuZXZlbnQudCksITEpOihpLm1lc2guc3BsaXRFZGdlKGYuU3ltKSxpLm1lc2guc3BsaXRFZGdlKE8uU3ltKSxpLm1lc2guc3BsaWNlKE8uT3ByZXYsZiksZi5Pcmcucz1DLnMsZi5PcmcudD1DLnQsZi5PcmcucHFIYW5kbGU9aS5wcS5pbnNlcnQoZi5PcmcpLHYuZ2V0SW50ZXJzZWN0RGF0YShpLGYuT3JnLEEsSSxSLFApLHYucmVnaW9uQWJvdmUoYSkuZGlydHk9YS5kaXJ0eT1zLmRpcnR5PSEwLCExKX0sdi53YWxrRGlydHlSZWdpb25zPWZ1bmN0aW9uKGksYSl7Zm9yKHZhciBzPXYucmVnaW9uQmVsb3coYSksZixPOzspe2Zvcig7cy5kaXJ0eTspYT1zLHM9di5yZWdpb25CZWxvdyhzKTtpZighYS5kaXJ0eSYmKHM9YSxhPXYucmVnaW9uQWJvdmUoYSksYT09PW51bGx8fCFhLmRpcnR5KSlyZXR1cm47aWYoYS5kaXJ0eT0hMSxmPWEuZVVwLE89cy5lVXAsZi5Ec3QhPT1PLkRzdCYmdi5jaGVja0ZvckxlZnRTcGxpY2UoaSxhKSYmKHMuZml4VXBwZXJFZGdlPyh2LmRlbGV0ZVJlZ2lvbihpLHMpLGkubWVzaC5kZWxldGUoTykscz12LnJlZ2lvbkJlbG93KGEpLE89cy5lVXApOmEuZml4VXBwZXJFZGdlJiYodi5kZWxldGVSZWdpb24oaSxhKSxpLm1lc2guZGVsZXRlKGYpLGE9di5yZWdpb25BYm92ZShzKSxmPWEuZVVwKSksZi5PcmchPT1PLk9yZylpZihmLkRzdCE9PU8uRHN0JiYhYS5maXhVcHBlckVkZ2UmJiFzLmZpeFVwcGVyRWRnZSYmKGYuRHN0PT09aS5ldmVudHx8Ty5Ec3Q9PT1pLmV2ZW50KSl7aWYodi5jaGVja0ZvckludGVyc2VjdChpLGEpKXJldHVybn1lbHNlIHYuY2hlY2tGb3JSaWdodFNwbGljZShpLGEpO2YuT3JnPT09Ty5PcmcmJmYuRHN0PT09Ty5Ec3QmJih2LmFkZFdpbmRpbmcoTyxmKSx2LmRlbGV0ZVJlZ2lvbihpLGEpLGkubWVzaC5kZWxldGUoZiksYT12LnJlZ2lvbkFib3ZlKHMpKX19LHYuY29ubmVjdFJpZ2h0VmVydGV4PWZ1bmN0aW9uKGksYSxzKXt2YXIgZixPPXMuT25leHQsQT12LnJlZ2lvbkJlbG93KGEpLFI9YS5lVXAsST1BLmVVcCxQPSExO2lmKFIuRHN0IT09SS5Ec3QmJnYuY2hlY2tGb3JJbnRlcnNlY3QoaSxhKSxuLnZlcnRFcShSLk9yZyxpLmV2ZW50KSYmKGkubWVzaC5zcGxpY2UoTy5PcHJldixSKSxhPXYudG9wTGVmdFJlZ2lvbihpLGEpLE89di5yZWdpb25CZWxvdyhhKS5lVXAsdi5maW5pc2hMZWZ0UmVnaW9ucyhpLHYucmVnaW9uQmVsb3coYSksQSksUD0hMCksbi52ZXJ0RXEoSS5PcmcsaS5ldmVudCkmJihpLm1lc2guc3BsaWNlKHMsSS5PcHJldikscz12LmZpbmlzaExlZnRSZWdpb25zKGksQSxudWxsKSxQPSEwKSxQKXt2LmFkZFJpZ2h0RWRnZXMoaSxhLHMuT25leHQsTyxPLCEwKTtyZXR1cm59bi52ZXJ0TGVxKEkuT3JnLFIuT3JnKT9mPUkuT3ByZXY6Zj1SLGY9aS5tZXNoLmNvbm5lY3Qocy5McHJldixmKSx2LmFkZFJpZ2h0RWRnZXMoaSxhLGYsZi5PbmV4dCxmLk9uZXh0LCExKSxmLlN5bS5hY3RpdmVSZWdpb24uZml4VXBwZXJFZGdlPSEwLHYud2Fsa0RpcnR5UmVnaW9ucyhpLGEpfSx2LmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZT1mdW5jdGlvbihpLGEscyl7dmFyIGYsTyxBLFIsSTtpZihmPWEuZVVwLG4udmVydEVxKGYuT3JnLHMpKXtkKCExKSx2LnNwbGljZU1lcmdlVmVydGljZXMoaSxmLHMuYW5FZGdlKTtyZXR1cm59aWYoIW4udmVydEVxKGYuRHN0LHMpKXtpLm1lc2guc3BsaXRFZGdlKGYuU3ltKSxhLmZpeFVwcGVyRWRnZSYmKGkubWVzaC5kZWxldGUoZi5PbmV4dCksYS5maXhVcHBlckVkZ2U9ITEpLGkubWVzaC5zcGxpY2Uocy5hbkVkZ2UsZiksdi5zd2VlcEV2ZW50KGkscyk7cmV0dXJufWQoITEpLGE9di50b3BSaWdodFJlZ2lvbihhKSxJPXYucmVnaW9uQmVsb3coYSksQT1JLmVVcC5TeW0sTz1SPUEuT25leHQsSS5maXhVcHBlckVkZ2UmJihkKE8hPT1BKSx2LmRlbGV0ZVJlZ2lvbihpLEkpLGkubWVzaC5kZWxldGUoQSksQT1PLk9wcmV2KSxpLm1lc2guc3BsaWNlKHMuYW5FZGdlLEEpLG4uZWRnZUdvZXNMZWZ0KE8pfHwoTz1udWxsKSx2LmFkZFJpZ2h0RWRnZXMoaSxhLEEuT25leHQsUixPLCEwKX0sdi5jb25uZWN0TGVmdFZlcnRleD1mdW5jdGlvbihpLGEpe3ZhciBzLGYsTyxBLFIsSSxQPW5ldyBFO2lmKFAuZVVwPWEuYW5FZGdlLlN5bSxzPWkuZGljdC5zZWFyY2goUCkua2V5LGY9di5yZWdpb25CZWxvdyhzKSwhIWYpe2lmKEE9cy5lVXAsUj1mLmVVcCxuLmVkZ2VTaWduKEEuRHN0LGEsQS5PcmcpPT09MCl7di5jb25uZWN0TGVmdERlZ2VuZXJhdGUoaSxzLGEpO3JldHVybn1pZihPPW4udmVydExlcShSLkRzdCxBLkRzdCk/czpmLHMuaW5zaWRlfHxPLmZpeFVwcGVyRWRnZSl7aWYoTz09PXMpST1pLm1lc2guY29ubmVjdChhLmFuRWRnZS5TeW0sQS5MbmV4dCk7ZWxzZXt2YXIgTD1pLm1lc2guY29ubmVjdChSLkRuZXh0LGEuYW5FZGdlKTtJPUwuU3ltfU8uZml4VXBwZXJFZGdlP3YuZml4VXBwZXJFZGdlKGksTyxJKTp2LmNvbXB1dGVXaW5kaW5nKGksdi5hZGRSZWdpb25CZWxvdyhpLHMsSSkpLHYuc3dlZXBFdmVudChpLGEpfWVsc2Ugdi5hZGRSaWdodEVkZ2VzKGkscyxhLmFuRWRnZSxhLmFuRWRnZSxudWxsLCEwKX19LHYuc3dlZXBFdmVudD1mdW5jdGlvbihpLGEpe2kuZXZlbnQ9YSx2LmRlYnVnRXZlbnQoaSk7Zm9yKHZhciBzPWEuYW5FZGdlO3MuYWN0aXZlUmVnaW9uPT09bnVsbDspaWYocz1zLk9uZXh0LHM9PT1hLmFuRWRnZSl7di5jb25uZWN0TGVmdFZlcnRleChpLGEpO3JldHVybn12YXIgZj12LnRvcExlZnRSZWdpb24oaSxzLmFjdGl2ZVJlZ2lvbik7ZChmIT09bnVsbCk7dmFyIE89di5yZWdpb25CZWxvdyhmKSxBPU8uZVVwLFI9di5maW5pc2hMZWZ0UmVnaW9ucyhpLE8sbnVsbCk7Ui5PbmV4dD09PUE/di5jb25uZWN0UmlnaHRWZXJ0ZXgoaSxmLFIpOnYuYWRkUmlnaHRFZGdlcyhpLGYsUi5PbmV4dCxBLEEsITApfSx2LmFkZFNlbnRpbmVsPWZ1bmN0aW9uKGksYSxzLGYpe3ZhciBPPW5ldyBFLEE9aS5tZXNoLm1ha2VFZGdlKCk7QS5Pcmcucz1zLEEuT3JnLnQ9ZixBLkRzdC5zPWEsQS5Ec3QudD1mLGkuZXZlbnQ9QS5Ec3QsTy5lVXA9QSxPLndpbmRpbmdOdW1iZXI9MCxPLmluc2lkZT0hMSxPLmZpeFVwcGVyRWRnZT0hMSxPLnNlbnRpbmVsPSEwLE8uZGlydHk9ITEsTy5ub2RlVXA9aS5kaWN0Lmluc2VydChPKX0sdi5pbml0RWRnZURpY3Q9ZnVuY3Rpb24oaSl7aS5kaWN0PW5ldyBsKGksdi5lZGdlTGVxKTt2YXIgYT1pLmJtYXhbMF0taS5ibWluWzBdLHM9aS5ibWF4WzFdLWkuYm1pblsxXSxmPWkuYm1pblswXS1hLE89aS5ibWF4WzBdK2EsQT1pLmJtaW5bMV0tcyxSPWkuYm1heFsxXStzO3YuYWRkU2VudGluZWwoaSxmLE8sQSksdi5hZGRTZW50aW5lbChpLGYsTyxSKX0sdi5kb25lRWRnZURpY3Q9ZnVuY3Rpb24oaSl7Zm9yKHZhciBhLHM9MDsoYT1pLmRpY3QubWluKCkua2V5KSE9PW51bGw7KWEuc2VudGluZWx8fChkKGEuZml4VXBwZXJFZGdlKSxkKCsrcz09PTEpKSxkKGEud2luZGluZ051bWJlcj09PTApLHYuZGVsZXRlUmVnaW9uKGksYSl9LHYucmVtb3ZlRGVnZW5lcmF0ZUVkZ2VzPWZ1bmN0aW9uKGkpe3ZhciBhLHMsZixPPWkubWVzaC5lSGVhZDtmb3IoYT1PLm5leHQ7YSE9PU87YT1zKXM9YS5uZXh0LGY9YS5MbmV4dCxuLnZlcnRFcShhLk9yZyxhLkRzdCkmJmEuTG5leHQuTG5leHQhPT1hJiYodi5zcGxpY2VNZXJnZVZlcnRpY2VzKGksZixhKSxpLm1lc2guZGVsZXRlKGEpLGE9ZixmPWEuTG5leHQpLGYuTG5leHQ9PT1hJiYoZiE9PWEmJigoZj09PXN8fGY9PT1zLlN5bSkmJihzPXMubmV4dCksaS5tZXNoLmRlbGV0ZShmKSksKGE9PT1zfHxhPT09cy5TeW0pJiYocz1zLm5leHQpLGkubWVzaC5kZWxldGUoYSkpfSx2LmluaXRQcmlvcml0eVE9ZnVuY3Rpb24oaSl7dmFyIGEscyxmLE89MDtmb3IoZj1pLm1lc2gudkhlYWQscz1mLm5leHQ7cyE9PWY7cz1zLm5leHQpTysrO2ZvcihPKz04LGE9aS5wcT1uZXcgYihPLG4udmVydExlcSksZj1pLm1lc2gudkhlYWQscz1mLm5leHQ7cyE9PWY7cz1zLm5leHQpcy5wcUhhbmRsZT1hLmluc2VydChzKTtyZXR1cm4gcyE9PWY/ITE6KGEuaW5pdCgpLCEwKX0sdi5kb25lUHJpb3JpdHlRPWZ1bmN0aW9uKGkpe2kucHE9bnVsbH0sdi5yZW1vdmVEZWdlbmVyYXRlRmFjZXM9ZnVuY3Rpb24oaSxhKXt2YXIgcyxmLE87Zm9yKHM9YS5mSGVhZC5uZXh0O3MhPT1hLmZIZWFkO3M9ZilmPXMubmV4dCxPPXMuYW5FZGdlLGQoTy5MbmV4dCE9PU8pLE8uTG5leHQuTG5leHQ9PT1PJiYodi5hZGRXaW5kaW5nKE8uT25leHQsTyksaS5tZXNoLmRlbGV0ZShPKSk7cmV0dXJuITB9LHYuY29tcHV0ZUludGVyaW9yPWZ1bmN0aW9uKGkpe3ZhciBhLHM7aWYodi5yZW1vdmVEZWdlbmVyYXRlRWRnZXMoaSksIXYuaW5pdFByaW9yaXR5UShpKSlyZXR1cm4hMTtmb3Iodi5pbml0RWRnZURpY3QoaSk7KGE9aS5wcS5leHRyYWN0TWluKCkpIT09bnVsbDspe2Zvcig7cz1pLnBxLm1pbigpLCEocz09PW51bGx8fCFuLnZlcnRFcShzLGEpKTspcz1pLnBxLmV4dHJhY3RNaW4oKSx2LnNwbGljZU1lcmdlVmVydGljZXMoaSxhLmFuRWRnZSxzLmFuRWRnZSk7di5zd2VlcEV2ZW50KGksYSl9cmV0dXJuIGkuZXZlbnQ9aS5kaWN0Lm1pbigpLmtleS5lVXAuT3JnLHYuZGVidWdFdmVudChpKSx2LmRvbmVFZGdlRGljdChpKSx2LmRvbmVQcmlvcml0eVEoaSksdi5yZW1vdmVEZWdlbmVyYXRlRmFjZXMoaSxpLm1lc2gpPyhpLm1lc2guY2hlY2soKSwhMCk6ITF9O2Z1bmN0aW9uIE0oKXt0aGlzLm1lc2g9bnVsbCx0aGlzLm5vcm1hbD1bMCwwLDBdLHRoaXMuc1VuaXQ9WzAsMCwwXSx0aGlzLnRVbml0PVswLDAsMF0sdGhpcy5ibWluPVswLDBdLHRoaXMuYm1heD1bMCwwXSx0aGlzLndpbmRpbmdSdWxlPXIuV0lORElOR19PREQsdGhpcy5kaWN0PW51bGwsdGhpcy5wcT1udWxsLHRoaXMuZXZlbnQ9bnVsbCx0aGlzLnZlcnRleEluZGV4Q291bnRlcj0wLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudENvdW50PTB9TS5wcm90b3R5cGU9e2RvdF86ZnVuY3Rpb24oaSxhKXtyZXR1cm4gaVswXSphWzBdK2lbMV0qYVsxXStpWzJdKmFbMl19LG5vcm1hbGl6ZV86ZnVuY3Rpb24oaSl7dmFyIGE9aVswXSppWzBdK2lbMV0qaVsxXStpWzJdKmlbMl07ZChhPjApLGE9TWF0aC5zcXJ0KGEpLGlbMF0vPWEsaVsxXS89YSxpWzJdLz1hfSxsb25nQXhpc186ZnVuY3Rpb24oaSl7dmFyIGE9MDtyZXR1cm4gTWF0aC5hYnMoaVsxXSk+TWF0aC5hYnMoaVswXSkmJihhPTEpLE1hdGguYWJzKGlbMl0pPk1hdGguYWJzKGlbYV0pJiYoYT0yKSxhfSxjb21wdXRlTm9ybWFsXzpmdW5jdGlvbihpKXt2YXIgYSxzLGYsTyxBLFIsST1bMCwwLDBdLFA9WzAsMCwwXSxMPVswLDAsMF0sRD1bMCwwLDBdLEM9WzAsMCwwXSxTPVtudWxsLG51bGwsbnVsbF0sQj1bbnVsbCxudWxsLG51bGxdLHc9dGhpcy5tZXNoLnZIZWFkLEg7Zm9yKGE9dy5uZXh0LEg9MDtIPDM7KytIKU89YS5jb29yZHNbSF0sUFtIXT1PLEJbSF09YSxJW0hdPU8sU1tIXT1hO2ZvcihhPXcubmV4dDthIT09dzthPWEubmV4dClmb3IoSD0wO0g8MzsrK0gpTz1hLmNvb3Jkc1tIXSxPPFBbSF0mJihQW0hdPU8sQltIXT1hKSxPPklbSF0mJihJW0hdPU8sU1tIXT1hKTtpZihIPTAsSVsxXS1QWzFdPklbMF0tUFswXSYmKEg9MSksSVsyXS1QWzJdPklbSF0tUFtIXSYmKEg9MiksUFtIXT49SVtIXSl7aVswXT0wLGlbMV09MCxpWzJdPTE7cmV0dXJufWZvcihSPTAscz1CW0hdLGY9U1tIXSxMWzBdPXMuY29vcmRzWzBdLWYuY29vcmRzWzBdLExbMV09cy5jb29yZHNbMV0tZi5jb29yZHNbMV0sTFsyXT1zLmNvb3Jkc1syXS1mLmNvb3Jkc1syXSxhPXcubmV4dDthIT09dzthPWEubmV4dClEWzBdPWEuY29vcmRzWzBdLWYuY29vcmRzWzBdLERbMV09YS5jb29yZHNbMV0tZi5jb29yZHNbMV0sRFsyXT1hLmNvb3Jkc1syXS1mLmNvb3Jkc1syXSxDWzBdPUxbMV0qRFsyXS1MWzJdKkRbMV0sQ1sxXT1MWzJdKkRbMF0tTFswXSpEWzJdLENbMl09TFswXSpEWzFdLUxbMV0qRFswXSxBPUNbMF0qQ1swXStDWzFdKkNbMV0rQ1syXSpDWzJdLEE+UiYmKFI9QSxpWzBdPUNbMF0saVsxXT1DWzFdLGlbMl09Q1syXSk7Ujw9MCYmKGlbMF09aVsxXT1pWzJdPTAsaVt0aGlzLmxvbmdBeGlzXyhMKV09MSl9LGNoZWNrT3JpZW50YXRpb25fOmZ1bmN0aW9uKCl7dmFyIGksYSxzPXRoaXMubWVzaC5mSGVhZCxmLE89dGhpcy5tZXNoLnZIZWFkLEE7Zm9yKGk9MCxhPXMubmV4dDthIT09czthPWEubmV4dClpZihBPWEuYW5FZGdlLCEoQS53aW5kaW5nPD0wKSlkbyBpKz0oQS5Pcmcucy1BLkRzdC5zKSooQS5PcmcudCtBLkRzdC50KSxBPUEuTG5leHQ7d2hpbGUoQSE9PWEuYW5FZGdlKTtpZihpPDApe2ZvcihmPU8ubmV4dDtmIT09TztmPWYubmV4dClmLnQ9LWYudDt0aGlzLnRVbml0WzBdPS10aGlzLnRVbml0WzBdLHRoaXMudFVuaXRbMV09LXRoaXMudFVuaXRbMV0sdGhpcy50VW5pdFsyXT0tdGhpcy50VW5pdFsyXX19LHByb2plY3RQb2x5Z29uXzpmdW5jdGlvbigpe3ZhciBpLGE9dGhpcy5tZXNoLnZIZWFkLHM9WzAsMCwwXSxmLE8sQSxSLEk9ITE7Zm9yKHNbMF09dGhpcy5ub3JtYWxbMF0sc1sxXT10aGlzLm5vcm1hbFsxXSxzWzJdPXRoaXMubm9ybWFsWzJdLHNbMF09PT0wJiZzWzFdPT09MCYmc1syXT09PTAmJih0aGlzLmNvbXB1dGVOb3JtYWxfKHMpLEk9ITApLGY9dGhpcy5zVW5pdCxPPXRoaXMudFVuaXQsQT10aGlzLmxvbmdBeGlzXyhzKSxmW0FdPTAsZlsoQSsxKSUzXT0xLGZbKEErMiklM109MCxPW0FdPTAsT1soQSsxKSUzXT0wLE9bKEErMiklM109c1tBXT4wPzE6LTEsaT1hLm5leHQ7aSE9PWE7aT1pLm5leHQpaS5zPXRoaXMuZG90XyhpLmNvb3JkcyxmKSxpLnQ9dGhpcy5kb3RfKGkuY29vcmRzLE8pO2ZvcihJJiZ0aGlzLmNoZWNrT3JpZW50YXRpb25fKCksUj0hMCxpPWEubmV4dDtpIT09YTtpPWkubmV4dClSPyh0aGlzLmJtaW5bMF09dGhpcy5ibWF4WzBdPWkucyx0aGlzLmJtaW5bMV09dGhpcy5ibWF4WzFdPWkudCxSPSExKTooaS5zPHRoaXMuYm1pblswXSYmKHRoaXMuYm1pblswXT1pLnMpLGkucz50aGlzLmJtYXhbMF0mJih0aGlzLmJtYXhbMF09aS5zKSxpLnQ8dGhpcy5ibWluWzFdJiYodGhpcy5ibWluWzFdPWkudCksaS50PnRoaXMuYm1heFsxXSYmKHRoaXMuYm1heFsxXT1pLnQpKX0sYWRkV2luZGluZ186ZnVuY3Rpb24oaSxhKXtpLndpbmRpbmcrPWEud2luZGluZyxpLlN5bS53aW5kaW5nKz1hLlN5bS53aW5kaW5nfSx0ZXNzZWxsYXRlTW9ub1JlZ2lvbl86ZnVuY3Rpb24oaSxhKXt2YXIgcyxmO2ZvcihzPWEuYW5FZGdlLGQocy5MbmV4dCE9PXMmJnMuTG5leHQuTG5leHQhPT1zKTtuLnZlcnRMZXEocy5Ec3Qscy5PcmcpO3M9cy5McHJldik7Zm9yKDtuLnZlcnRMZXEocy5Pcmcscy5Ec3QpO3M9cy5MbmV4dCk7Zm9yKGY9cy5McHJldjtzLkxuZXh0IT09ZjspaWYobi52ZXJ0TGVxKHMuRHN0LGYuT3JnKSl7Zm9yKDtmLkxuZXh0IT09cyYmKG4uZWRnZUdvZXNMZWZ0KGYuTG5leHQpfHxuLmVkZ2VTaWduKGYuT3JnLGYuRHN0LGYuTG5leHQuRHN0KTw9MCk7KXt2YXIgTz1pLmNvbm5lY3QoZi5MbmV4dCxmKTtmPU8uU3ltfWY9Zi5McHJldn1lbHNle2Zvcig7Zi5MbmV4dCE9PXMmJihuLmVkZ2VHb2VzUmlnaHQocy5McHJldil8fG4uZWRnZVNpZ24ocy5Ec3Qscy5Pcmcscy5McHJldi5PcmcpPj0wKTspe3ZhciBPPWkuY29ubmVjdChzLHMuTHByZXYpO3M9Ty5TeW19cz1zLkxuZXh0fWZvcihkKGYuTG5leHQhPT1zKTtmLkxuZXh0LkxuZXh0IT09czspe3ZhciBPPWkuY29ubmVjdChmLkxuZXh0LGYpO2Y9Ty5TeW19cmV0dXJuITB9LHRlc3NlbGxhdGVJbnRlcmlvcl86ZnVuY3Rpb24oaSl7dmFyIGEscztmb3IoYT1pLmZIZWFkLm5leHQ7YSE9PWkuZkhlYWQ7YT1zKWlmKHM9YS5uZXh0LGEuaW5zaWRlJiYhdGhpcy50ZXNzZWxsYXRlTW9ub1JlZ2lvbl8oaSxhKSlyZXR1cm4hMTtyZXR1cm4hMH0sZGlzY2FyZEV4dGVyaW9yXzpmdW5jdGlvbihpKXt2YXIgYSxzO2ZvcihhPWkuZkhlYWQubmV4dDthIT09aS5mSGVhZDthPXMpcz1hLm5leHQsYS5pbnNpZGV8fGkuemFwRmFjZShhKX0sc2V0V2luZGluZ051bWJlcl86ZnVuY3Rpb24oaSxhLHMpe3ZhciBmLE87Zm9yKGY9aS5lSGVhZC5uZXh0O2YhPT1pLmVIZWFkO2Y9TylPPWYubmV4dCxmLlJmYWNlLmluc2lkZSE9PWYuTGZhY2UuaW5zaWRlP2Yud2luZGluZz1mLkxmYWNlLmluc2lkZT9hOi1hOnM/aS5kZWxldGUoZik6Zi53aW5kaW5nPTB9LGdldE5laWdoYm91ckZhY2VfOmZ1bmN0aW9uKGkpe3JldHVybiFpLlJmYWNlfHwhaS5SZmFjZS5pbnNpZGU/LTE6aS5SZmFjZS5ufSxvdXRwdXRQb2x5bWVzaF86ZnVuY3Rpb24oaSxhLHMsZil7dmFyIE8sQSxSLEk9MCxQPTAsTCxEO2ZvcihzPjMmJmkubWVyZ2VDb252ZXhGYWNlcyhzKSxPPWkudkhlYWQubmV4dDtPIT09aS52SGVhZDtPPU8ubmV4dClPLm49LTE7Zm9yKEE9aS5mSGVhZC5uZXh0O0EhPT1pLmZIZWFkO0E9QS5uZXh0KWlmKEEubj0tMSwhIUEuaW5zaWRlKXtSPUEuYW5FZGdlLEw9MDtkbyBPPVIuT3JnLE8ubj09PS0xJiYoTy5uPVAsUCsrKSxMKyssUj1SLkxuZXh0O3doaWxlKFIhPT1BLmFuRWRnZSk7ZChMPD1zKSxBLm49SSwrK0l9Zm9yKHRoaXMuZWxlbWVudENvdW50PUksYT09PXIuQ09OTkVDVEVEX1BPTFlHT05TJiYoSSo9MiksdGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD1JKnMsdGhpcy52ZXJ0ZXhDb3VudD1QLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9UCpmLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPVAsTz1pLnZIZWFkLm5leHQ7TyE9PWkudkhlYWQ7Tz1PLm5leHQpaWYoTy5uIT09LTEpe3ZhciBDPU8ubipmO3RoaXMudmVydGljZXNbQyswXT1PLmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW0MrMV09Ty5jb29yZHNbMV0sZj4yJiYodGhpcy52ZXJ0aWNlc1tDKzJdPU8uY29vcmRzWzJdKSx0aGlzLnZlcnRleEluZGljZXNbTy5uXT1PLmlkeH12YXIgUz0wO2ZvcihBPWkuZkhlYWQubmV4dDtBIT09aS5mSGVhZDtBPUEubmV4dClpZihBLmluc2lkZSl7Uj1BLmFuRWRnZSxMPTA7ZG8gTz1SLk9yZyx0aGlzLmVsZW1lbnRzW1MrK109Ty5uLEwrKyxSPVIuTG5leHQ7d2hpbGUoUiE9PUEuYW5FZGdlKTtmb3IoRD1MO0Q8czsrK0QpdGhpcy5lbGVtZW50c1tTKytdPS0xO2lmKGE9PT1yLkNPTk5FQ1RFRF9QT0xZR09OUyl7Uj1BLmFuRWRnZTtkbyB0aGlzLmVsZW1lbnRzW1MrK109dGhpcy5nZXROZWlnaGJvdXJGYWNlXyhSKSxSPVIuTG5leHQ7d2hpbGUoUiE9PUEuYW5FZGdlKTtmb3IoRD1MO0Q8czsrK0QpdGhpcy5lbGVtZW50c1tTKytdPS0xfX19LG91dHB1dENvbnRvdXJzXzpmdW5jdGlvbihpLGEpe3ZhciBzLGYsTyxBPTAsUj0wO2Zvcih0aGlzLnZlcnRleENvdW50PTAsdGhpcy5lbGVtZW50Q291bnQ9MCxzPWkuZkhlYWQubmV4dDtzIT09aS5mSGVhZDtzPXMubmV4dClpZihzLmluc2lkZSl7Tz1mPXMuYW5FZGdlO2RvIHRoaXMudmVydGV4Q291bnQrKyxmPWYuTG5leHQ7d2hpbGUoZiE9PU8pO3RoaXMuZWxlbWVudENvdW50Kyt9dGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD10aGlzLmVsZW1lbnRDb3VudCoyLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudCphLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPXRoaXMudmVydGV4Q291bnQ7dmFyIEk9MCxQPTAsTD0wO2ZvcihBPTAscz1pLmZIZWFkLm5leHQ7cyE9PWkuZkhlYWQ7cz1zLm5leHQpaWYocy5pbnNpZGUpe1I9MCxPPWY9cy5hbkVkZ2U7ZG8gdGhpcy52ZXJ0aWNlc1tJKytdPWYuT3JnLmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW0krK109Zi5PcmcuY29vcmRzWzFdLGE+MiYmKHRoaXMudmVydGljZXNbSSsrXT1mLk9yZy5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tQKytdPWYuT3JnLmlkeCxSKyssZj1mLkxuZXh0O3doaWxlKGYhPT1PKTt0aGlzLmVsZW1lbnRzW0wrK109QSx0aGlzLmVsZW1lbnRzW0wrK109UixBKz1SfX0sYWRkQ29udG91cjpmdW5jdGlvbihpLGEpe3ZhciBzLGY7Zm9yKHRoaXMubWVzaD09PW51bGwmJih0aGlzLm1lc2g9bmV3IGMpLGk8MiYmKGk9MiksaT4zJiYoaT0zKSxzPW51bGwsZj0wO2Y8YS5sZW5ndGg7Zis9aSlzPT09bnVsbD8ocz10aGlzLm1lc2gubWFrZUVkZ2UoKSx0aGlzLm1lc2guc3BsaWNlKHMscy5TeW0pKToodGhpcy5tZXNoLnNwbGl0RWRnZShzKSxzPXMuTG5leHQpLHMuT3JnLmNvb3Jkc1swXT1hW2YrMF0scy5PcmcuY29vcmRzWzFdPWFbZisxXSxpPjI/cy5PcmcuY29vcmRzWzJdPWFbZisyXTpzLk9yZy5jb29yZHNbMl09MCxzLk9yZy5pZHg9dGhpcy52ZXJ0ZXhJbmRleENvdW50ZXIrKyxzLndpbmRpbmc9MSxzLlN5bS53aW5kaW5nPS0xfSx0ZXNzZWxhdGU6ZnVuY3Rpb24oaSxhLHMsZixPKXtpZih0aGlzLnZlcnRpY2VzPVtdLHRoaXMuZWxlbWVudHM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsTyYmKHRoaXMubm9ybWFsWzBdPU9bMF0sdGhpcy5ub3JtYWxbMV09T1sxXSx0aGlzLm5vcm1hbFsyXT1PWzJdKSx0aGlzLndpbmRpbmdSdWxlPWksZjwyJiYoZj0yKSxmPjMmJihmPTMpLCF0aGlzLm1lc2gpcmV0dXJuITE7dGhpcy5wcm9qZWN0UG9seWdvbl8oKSx2LmNvbXB1dGVJbnRlcmlvcih0aGlzKTt2YXIgQT10aGlzLm1lc2g7cmV0dXJuIGE9PT1yLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMuc2V0V2luZGluZ051bWJlcl8oQSwxLCEwKTp0aGlzLnRlc3NlbGxhdGVJbnRlcmlvcl8oQSksQS5jaGVjaygpLGE9PT1yLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMub3V0cHV0Q29udG91cnNfKEEsZik6dGhpcy5vdXRwdXRQb2x5bWVzaF8oQSxhLHMsZiksITB9fX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9cjt2YXIgdD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHIoKXtmb3IodmFyIG49e30sZD0wO2Q8YXJndW1lbnRzLmxlbmd0aDtkKyspe3ZhciBnPWFyZ3VtZW50c1tkXTtmb3IodmFyIHUgaW4gZyl0LmNhbGwoZyx1KSYmKG5bdV09Z1t1XSl9cmV0dXJuIG59fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImFwcGx5U2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImNyZWF0ZUNsb3VkU2hhZGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJhcHBseUNsb3VkU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiB5fSk7dmFyIHI9dCg2NCksbj10KDY1KSxkPXQoNjYpLGc9dCg2Nyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHU9U3ltYm9sKCJzaGFkZXJzIik7ZnVuY3Rpb24gbyh4KXt4W3VdPVtdO2ZvcihsZXQgYj0wO2I8MTY7YisrKXtjb25zdCBFPVtdLHY9ISEoYiYxKSxNPSEhKGImMiksaT0hIShiJjQpLGE9ISEoYiY4KTt2JiZFLnB1c2goIiNkZWZpbmUgVEVYVFVSRSAxIiksTSYmRS5wdXNoKCIjZGVmaW5lIEZJTFRFUiAxIiksaSYmRS5wdXNoKCIjZGVmaW5lIEdSQURJRU5UIDEiKSxhJiZFLnB1c2goIiNkZWZpbmUgQ0xJUFBBVEggMSIpO2NvbnN0IHM9YCR7RS5qb2luKGAKYCl9CmAsZj1bXTt2JiZmLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U2FtcGxlcjsiKSxhJiZmLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IikseFt1XVtiXT1bcytmLmpvaW4oYApgKStuLmRlZmF1bHQscytyLmRlZmF1bHRdfX1mdW5jdGlvbiBjKHgse2hhc1RleHR1cmU6Yj0hMSxoYXNGaWx0ZXI6RT0hMSxoYXNHcmFkaWVudDp2PSExLGhhc0NsaXBQYXRoOk09ITF9PXt9KXtjb25zdCBpPWJ8RTw8MXx2PDwyfE08PDM7bGV0IGE9eFt1XVtpXTtBcnJheS5pc0FycmF5KGEpJiYoYT14LmNyZWF0ZVByb2dyYW0oLi4uYSkseFt1XVtpXT1hKSx4LnByb2dyYW0hPT1hJiZ4LnVzZVByb2dyYW0oYSx7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pfWNvbnN0IHA9W107ZnVuY3Rpb24gbCh4KXtmb3IobGV0IGI9MDtiPDY0O2IrKyl7Y29uc3QgRT1bXSx2PSEhKGImMSksTT0hIShiJjIpLGk9ISEoYiY0KSxhPSEhKGImOCkscz0hIShiJjE2KSxmPSEhKGImMzIpO3YmJkUucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxNJiZFLnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxpJiZFLnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLGEmJkUucHVzaCgiI2RlZmluZSBDTE9VRENPTE9SIDEiKSxzJiZFLnB1c2goIiNkZWZpbmUgQ0xPVURGSUxURVIgMSIpLGYmJkUucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3QgTz1gJHtFLmpvaW4oYApgKX0KYCxBPVtdO2lmKHYpe0EucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpO2ZvcihsZXQgUj0wO1I8MTI7UisrKUEucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhGcmFtZSR7Un07YCl9ZiYmQS5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X2NsaXBTYW1wbGVyOyIpLHBbYl09W08rQS5qb2luKGAKYCkrZy5kZWZhdWx0LE8rZC5kZWZhdWx0XX19ZnVuY3Rpb24geSh4LHtoYXNUZXh0dXJlOmI9ITEsaGFzRmlsdGVyOkU9ITEsaGFzR3JhZGllbnQ6dj0hMSxoYXNDbG91ZENvbG9yOk09ITEsaGFzQ2xvdWRGaWx0ZXI6aT0hMSxoYXNDbGlwUGF0aDphPSExfT17fSl7Y29uc3Qgcz1ifEU8PDF8djw8MnxNPDwzfGk8PDR8YTw8NTtsZXQgZj1wW3NdO0FycmF5LmlzQXJyYXkoZikmJihmPXguY3JlYXRlUHJvZ3JhbSguLi5mKSxwW3NdPWYpLHgucHJvZ3JhbSE9PWYmJngudXNlUHJvZ3JhbShmLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZmlsbENsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9zdHJva2VDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZnJhbWVJbmRleDp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiExfX0pfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX1BvaW50U2l6ZSA9IDEuMDsKCiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwogIHZDb2xvciA9IGFfY29sb3I7CgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgp9YH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKCiNpZmRlZiBURVhUVVJFCnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CnVuaWZvcm0gZmxvYXQgdV9jb2xvclN0ZXBzWzQwXTsKdW5pZm9ybSBpbnQgdV9ncmFkaWVudFR5cGU7Ci8vIHVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIHZlYzQgY29sb3IgPSB2Q29sb3I7CiAgZmxvYXQgb3BhY2l0eSA9IGFicyhmbGFnQmFja2dyb3VuZCk7CgojaWZkZWYgR1JBRElFTlQKICBpZih1X2dyYWRpZW50VHlwZSA+IDAgJiYgZmxhZ0JhY2tncm91bmQgPiAwLjAgfHwgdV9ncmFkaWVudFR5cGUgPT0gMCAmJiBmbGFnQmFja2dyb3VuZCA8PSAwLjApIHsKICAgIGdyYWRpZW50KGNvbG9yLCB2R3JhZGllbnRWZWN0b3IxLCB2R3JhZGllbnRWZWN0b3IyLCB1X2NvbG9yU3RlcHMpOwogIH0KI2VuZGlmCgogIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgIGNvbG9yLmEgKj0gb3BhY2l0eTsKICB9CgojaWZkZWYgVEVYVFVSRQogIGlmKGZsYWdCYWNrZ3JvdW5kID4gMC4wKSB7CiAgICB2ZWMzIHRleENvb3JkID0gdlRleHR1cmVDb29yZDsKCiAgICBpZih0ZXhDb29yZC56ID09IDEuMCkgewogICAgICB0ZXhDb29yZCA9IGZyYWN0KHRleENvb3JkKTsKICAgIH0KCiAgICBpZih0ZXhDb29yZC54IDw9IDEuMCAmJiB0ZXhDb29yZC54ID49IDAuMAogICAgICAmJiB0ZXhDb29yZC55IDw9IDEuMCAmJiB0ZXhDb29yZC55ID49IDAuMCkgewogICAgICBpZih2U291cmNlUmVjdC56ID4gMC4wKSB7CiAgICAgICAgdGV4Q29vcmQueCA9IHZTb3VyY2VSZWN0LnggKyB0ZXhDb29yZC54ICogdlNvdXJjZVJlY3QuejsKICAgICAgICB0ZXhDb29yZC55ID0gMS4wIC0gKHZTb3VyY2VSZWN0LnkgKyAoMS4wIC0gdGV4Q29vcmQueSkgKiB2U291cmNlUmVjdC53KTsKICAgICAgfQogICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICB9CiAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAvLyBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNvbG9yLmEpOwogICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgfQogIH0KI2VuZGlmCgojaWZkZWYgRklMVEVSCiAgaWYodV9maWx0ZXJGbGFnID4gMCkgewogICAgdHJhbnNmb3JtQ29sb3IoY29sb3IsIHVfY29sb3JNYXRyaXgpOwogIH0KI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CmF0dHJpYnV0ZSB2ZWMzIGFfdHJhbnNmb3JtMDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0xOwp1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7CgojaWZkZWYgVEVYVFVSRQphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CmF0dHJpYnV0ZSBmbG9hdCBhX2ZyYW1lSW5kZXg7CnZhcnlpbmcgZmxvYXQgZnJhbWVJbmRleDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMDsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMTsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMzsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkNDsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIENMT1VEQ09MT1IKYXR0cmlidXRlIHZlYzQgYV9maWxsQ2xvdWRDb2xvcjsKYXR0cmlidXRlIHZlYzQgYV9zdHJva2VDbG91ZENvbG9yOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICBtYXQzIG1vZGVsTWF0cml4ID0gbWF0MygKICAgIGFfdHJhbnNmb3JtMC54LCBhX3RyYW5zZm9ybTEueCwgMCwgCiAgICBhX3RyYW5zZm9ybTAueSwgYV90cmFuc2Zvcm0xLnksIDAsCiAgICBhX3RyYW5zZm9ybTAueiwgYV90cmFuc2Zvcm0xLnosIDEKICApOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOwoKI2lmZGVmIEdSQURJRU5UCiAgdmVjMyB2ZzEgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzBdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzFdLCAxLjApOwogIHZlYzMgdmcyID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclszXSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls0XSwgMS4wKTsKICBmbG9hdCBoID0gdV9yZXNvbHV0aW9uLnk7CiAgdmcxLnkgPSBoIC0gdmcxLnk7CiAgdmcyLnkgPSBoIC0gdmcyLnk7CiAgdkdyYWRpZW50VmVjdG9yMSA9IHZlYzModmcxLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzJdKTsKICB2R3JhZGllbnRWZWN0b3IyID0gdmVjMyh2ZzIueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNV0pOwojZW5kaWYKICAKICBmbGFnQmFja2dyb3VuZCA9IGFfdmVydGV4UG9zaXRpb24uejsKCiNpZmRlZiBDTE9VRENPTE9SCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLmEpOwogIH0gZWxzZSB7CiAgICB2Q29sb3IgPSBtaXgoYV9jb2xvciwgYV9zdHJva2VDbG91ZENvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IuYSk7CiAgfQojZWxzZQogIHZDb2xvciA9IGFfY29sb3I7CiNlbmRpZgoKI2lmZGVmIFRFWFRVUkUKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CiAgZnJhbWVJbmRleCA9IGFfZnJhbWVJbmRleDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgY29sb3JDbG91ZDAgPSBhX2NvbG9yQ2xvdWQwOwogIGNvbG9yQ2xvdWQxID0gYV9jb2xvckNsb3VkMTsKICBjb2xvckNsb3VkMiA9IGFfY29sb3JDbG91ZDI7CiAgY29sb3JDbG91ZDMgPSBhX2NvbG9yQ2xvdWQzOwogIGNvbG9yQ2xvdWQ0ID0gYV9jb2xvckNsb3VkNDsKI2VuZGlmCn1gfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgRklMVEVSCnVuaWZvcm0gaW50IHVfZmlsdGVyRmxhZzsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yTWF0cml4WzIwXTsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKdm9pZCB0cmFuc2Zvcm1Db2xvcihpbm91dCB2ZWM0IGNvbG9yLCBpbiBmbG9hdCBjb2xvck1hdHJpeFsyMF0pIHsKICBmbG9hdCByID0gY29sb3IuciwgZyA9IGNvbG9yLmcsIGIgPSBjb2xvci5iLCBhID0gY29sb3IuYTsKICBjb2xvclswXSA9IGNvbG9yTWF0cml4WzBdICogciArIGNvbG9yTWF0cml4WzFdICogZyArIGNvbG9yTWF0cml4WzJdICogYiArIGNvbG9yTWF0cml4WzNdICogYSArIGNvbG9yTWF0cml4WzRdOwogIGNvbG9yWzFdID0gY29sb3JNYXRyaXhbNV0gKiByICsgY29sb3JNYXRyaXhbNl0gKiBnICsgY29sb3JNYXRyaXhbN10gKiBiICsgY29sb3JNYXRyaXhbOF0gKiBhICsgY29sb3JNYXRyaXhbOV07CiAgY29sb3JbMl0gPSBjb2xvck1hdHJpeFsxMF0gKiByICsgY29sb3JNYXRyaXhbMTFdICogZyArIGNvbG9yTWF0cml4WzEyXSAqIGIgKyBjb2xvck1hdHJpeFsxM10gKiBhICsgY29sb3JNYXRyaXhbMTRdOwogIGNvbG9yWzNdID0gY29sb3JNYXRyaXhbMTVdICogciArIGNvbG9yTWF0cml4WzE2XSAqIGcgKyBjb2xvck1hdHJpeFsxN10gKiBiICsgY29sb3JNYXRyaXhbMThdICogYSArIGNvbG9yTWF0cml4WzE5XTsKfQoKI2lmZGVmIENMT1VERklMVEVSCnZvaWQgYnVpbGRDbG91ZENvbG9yKGlub3V0IGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdKSB7CiAgY29sb3JDbG91ZE1hdHJpeFswXSA9IGNvbG9yQ2xvdWQwWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMV0gPSBjb2xvckNsb3VkMVswXTsKICBjb2xvckNsb3VkTWF0cml4WzJdID0gY29sb3JDbG91ZDJbMF07CiAgY29sb3JDbG91ZE1hdHJpeFszXSA9IGNvbG9yQ2xvdWQzWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNF0gPSBjb2xvckNsb3VkNFswXTsKCiAgY29sb3JDbG91ZE1hdHJpeFs1XSA9IGNvbG9yQ2xvdWQwWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNl0gPSBjb2xvckNsb3VkMVsxXTsKICBjb2xvckNsb3VkTWF0cml4WzddID0gY29sb3JDbG91ZDJbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs4XSA9IGNvbG9yQ2xvdWQzWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbOV0gPSBjb2xvckNsb3VkNFsxXTsKCiAgY29sb3JDbG91ZE1hdHJpeFsxMF0gPSBjb2xvckNsb3VkMFsyXTsKICBjb2xvckNsb3VkTWF0cml4WzExXSA9IGNvbG9yQ2xvdWQxWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTJdID0gY29sb3JDbG91ZDJbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxM10gPSBjb2xvckNsb3VkM1syXTsKICBjb2xvckNsb3VkTWF0cml4WzE0XSA9IGNvbG9yQ2xvdWQ0WzJdOwoKICBjb2xvckNsb3VkTWF0cml4WzE1XSA9IGNvbG9yQ2xvdWQwWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTZdID0gY29sb3JDbG91ZDFbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxN10gPSBjb2xvckNsb3VkMlszXTsKICBjb2xvckNsb3VkTWF0cml4WzE4XSA9IGNvbG9yQ2xvdWQzWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTldID0gY29sb3JDbG91ZDRbM107Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIGlmKGZyYW1lSW5kZXggPCAwLjApIHsKICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW50IGluZGV4ID0gaW50KGZsb29yKGNsYW1wKDAuMCwgMTEuMCwgZnJhbWVJbmRleCkpKTsKICAgICAgICB2ZWM0IHRleENvbG9yOwogICAgICAgIGlmKGluZGV4ID09IDApIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTIsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDMpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUzLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA0KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTUsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDYpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU2LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA3KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNywgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTgsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDkpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU5LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTEwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTEsIHRleENvb3JkLnh5KTsKICAgICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgICAgdGV4Q29sb3IuYSAqPSBvcGFjaXR5OwogICAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICAgIH0KICAgICAgICAvLyBjb2xvciA9IG1peChjb2xvciwgdGV4Q29sb3IsIHRleENvbG9yLmEpOwogICAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjbGFtcChjb2xvci5hIC8gbWF4KDAuMDAwMSwgdGV4Q29sb3IuYSksIDAuMCwgMS4wKSk7CiAgICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgICB9CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgogIGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdOwogIGJ1aWxkQ2xvdWRDb2xvcihjb2xvckNsb3VkTWF0cml4KTsKICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgY29sb3JDbG91ZE1hdHJpeCk7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgZmxvYXQgY2xpcCA9IHRleHR1cmUyRCh1X2NsaXBTYW1wbGVyLCB2Q2xpcFVWKS5yOwogIGNvbG9yICo9IGNsaXA7CiNlbmRpZgoKICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsKfWB9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKHIsbil7dC5kKGUsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBkKCl7aWYodHlwZW9mIHBlcmZvcm1hbmNlPCJ1IiYmcGVyZm9ybWFuY2Uubm93KXJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtpZih0eXBlb2YgcjwidSImJnIuaHJ0aW1lKXtjb25zdFtvLGNdPXIuaHJ0aW1lKCk7cmV0dXJuIG8qMWUzK2MqMWUtNn1yZXR1cm4gRGF0ZS5ub3c/RGF0ZS5ub3coKTpuZXcgRGF0ZSgpLmdldFRpbWUoKX1sZXQgZyx1O3R5cGVvZiBuPCJ1IiYmdHlwZW9mIG4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lPT0iZnVuY3Rpb24iPyhnPW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lLHU9bi5jYW5jZWxBbmltYXRpb25GcmFtZSk6KGc9ZnVuY3Rpb24obyl7cmV0dXJuIHNldFRpbWVvdXQoKCk9PntvKGQoKSl9LDE2KX0sdT1mdW5jdGlvbihvKXtyZXR1cm4gY2xlYXJUaW1lb3V0KG8pfSl9KS5jYWxsKHRoaXMsdCg2OSksdCgyMikpfSxmdW5jdGlvbihoLGUpe3ZhciB0PWguZXhwb3J0cz17fSxyLG47ZnVuY3Rpb24gZCgpe3Rocm93IG5ldyBFcnJvcigic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfWZ1bmN0aW9uIGcoKXt0aHJvdyBuZXcgRXJyb3IoImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfShmdW5jdGlvbigpe3RyeXt0eXBlb2Ygc2V0VGltZW91dD09ImZ1bmN0aW9uIj9yPXNldFRpbWVvdXQ6cj1kfWNhdGNoe3I9ZH10cnl7dHlwZW9mIGNsZWFyVGltZW91dD09ImZ1bmN0aW9uIj9uPWNsZWFyVGltZW91dDpuPWd9Y2F0Y2h7bj1nfX0pKCk7ZnVuY3Rpb24gdShNKXtpZihyPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dChNLDApO2lmKChyPT09ZHx8IXIpJiZzZXRUaW1lb3V0KXJldHVybiByPXNldFRpbWVvdXQsc2V0VGltZW91dChNLDApO3RyeXtyZXR1cm4gcihNLDApfWNhdGNoe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsTSwwKX1jYXRjaHtyZXR1cm4gci5jYWxsKHRoaXMsTSwwKX19fWZ1bmN0aW9uIG8oTSl7aWYobj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KE0pO2lmKChuPT09Z3x8IW4pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG49Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChNKTt0cnl7cmV0dXJuIG4oTSl9Y2F0Y2h7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxNKX1jYXRjaHtyZXR1cm4gbi5jYWxsKHRoaXMsTSl9fX12YXIgYz1bXSxwPSExLGwseT0tMTtmdW5jdGlvbiB4KCl7IXB8fCFsfHwocD0hMSxsLmxlbmd0aD9jPWwuY29uY2F0KGMpOnk9LTEsYy5sZW5ndGgmJmIoKSl9ZnVuY3Rpb24gYigpe2lmKCFwKXt2YXIgTT11KHgpO3A9ITA7Zm9yKHZhciBpPWMubGVuZ3RoO2k7KXtmb3IobD1jLGM9W107Kyt5PGk7KWwmJmxbeV0ucnVuKCk7eT0tMSxpPWMubGVuZ3RofWw9bnVsbCxwPSExLG8oTSl9fXQubmV4dFRpY2s9ZnVuY3Rpb24oTSl7dmFyIGk9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgYT0xO2E8YXJndW1lbnRzLmxlbmd0aDthKyspaVthLTFdPWFyZ3VtZW50c1thXTtjLnB1c2gobmV3IEUoTSxpKSksYy5sZW5ndGg9PT0xJiYhcCYmdShiKX07ZnVuY3Rpb24gRShNLGkpe3RoaXMuZnVuPU0sdGhpcy5hcnJheT1pfUUucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LHQudGl0bGU9ImJyb3dzZXIiLHQuYnJvd3Nlcj0hMCx0LmVudj17fSx0LmFyZ3Y9W10sdC52ZXJzaW9uPSIiLHQudmVyc2lvbnM9e307ZnVuY3Rpb24gdigpe310Lm9uPXYsdC5hZGRMaXN0ZW5lcj12LHQub25jZT12LHQub2ZmPXYsdC5yZW1vdmVMaXN0ZW5lcj12LHQucmVtb3ZlQWxsTGlzdGVuZXJzPXYsdC5lbWl0PXYsdC5wcmVwZW5kTGlzdGVuZXI9dix0LnByZXBlbmRPbmNlTGlzdGVuZXI9dix0Lmxpc3RlbmVycz1mdW5jdGlvbihNKXtyZXR1cm5bXX0sdC5iaW5kaW5nPWZ1bmN0aW9uKE0pe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm4iLyJ9LHQuY2hkaXI9ZnVuY3Rpb24oTSl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pO3ZhciByPXQoMSksbj10KDcxKSxkPXQoNzMpLGc9dCgyMTMpLHU9dCgyMTQpLG89dCgyMTUpLGM9dCgyMTYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBwKEksUCl7dmFyIEw9T2JqZWN0LmtleXMoSSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhJKTtQJiYoRD1ELmZpbHRlcihmdW5jdGlvbihDKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihJLEMpLmVudW1lcmFibGV9KSksTC5wdXNoLmFwcGx5KEwsRCl9cmV0dXJuIEx9ZnVuY3Rpb24gbChJKXtmb3IodmFyIFA9MTtQPGFyZ3VtZW50cy5sZW5ndGg7UCsrKXt2YXIgTD1hcmd1bWVudHNbUF0hPW51bGw/YXJndW1lbnRzW1BdOnt9O1AlMj9wKE9iamVjdChMKSwhMCkuZm9yRWFjaChmdW5jdGlvbihEKXt5KEksRCxMW0RdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEksT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoTCkpOnAoT2JqZWN0KEwpKS5mb3JFYWNoKGZ1bmN0aW9uKEQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLEQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihMLEQpKX0pfXJldHVybiBJfWZ1bmN0aW9uIHkoSSxQLEwpe3JldHVybiBQIGluIEk/T2JqZWN0LmRlZmluZVByb3BlcnR5KEksUCx7dmFsdWU6TCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOklbUF09TCxJfWNvbnN0IHg9U3ltYm9sLmZvcigic3ByaXRlanNfY2hhbmdlZEF0dHJzIiksYj1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIiksRT1TeW1ib2woInJlc29sdXRpb24iKSx2PVN5bWJvbCgiYW5pbWF0aW9ucyIpLE09U3ltYm9sKCJldmVudExpc3RlbmVycyIpLGk9U3ltYm9sKCJjYXB0dXJlRXZlbnRMaXN0ZW5lcnMiKSxhPVN5bWJvbCgiZmlsdGVycyIpLHM9U3ltYm9sKCJkaXNwbGF5IiksZj1TeW1ib2woInByb2dyYW0iKSxPPVN5bWJvbCgic2hhZGVyQXR0cnMiKSxBPVN5bWJvbCgidW5pZm9ybXMiKTtjbGFzcyBSe2NvbnN0cnVjdG9yKFA9e30pe3RoaXMuYXR0cmlidXRlcz1uZXcgdGhpcy5jb25zdHJ1Y3Rvci5BdHRyKHRoaXMpLHRoaXNbRV09e3dpZHRoOjMwMCxoZWlnaHQ6MTUwfSxPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxQKSx0aGlzW3ZdPW5ldyBTZXQsdGhpc1tNXT17fSx0aGlzW2ldPXt9fWdldCBhbmNlc3RvcnMoKXtsZXQgUD10aGlzLnBhcmVudDtjb25zdCBMPVtdO2Zvcig7UDspTC5wdXNoKFApLFA9UC5wYXJlbnQ7cmV0dXJuIEx9Z2V0IGFuaW1hdGlvbnMoKXtyZXR1cm4gdGhpc1t2XX1nZXQgZmlsdGVycygpe3JldHVybiB0aGlzW2FdfHx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZmlsdGVyc31nZXQgaXNWaXNpYmxlKCl7cmV0dXJuITF9Z2V0IGxheWVyKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50LmxheWVyOm51bGx9Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3QgUD10aGlzLnRyYW5zZm9ybU1hdHJpeCx7eDpMLHk6RH09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBQWzRdKz1MLFBbNV0rPUQsUH1nZXQgb3BhY2l0eSgpe2xldCBQPXRoaXMuYXR0cmlidXRlcy5vcGFjaXR5O3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3BhY2l0eSE9bnVsbCYmKFAqPXRoaXMucGFyZW50Lm9wYWNpdHkpLFB9Z2V0IHBhcmVudE5vZGUoKXtyZXR1cm4gdGhpcy5wYXJlbnR9Z2V0IG5leHRTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgxKX1nZXQgcHJldmlvdXNTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgtMSl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1tmXX1nZXQgcmVuZGVyZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQucmVuZGVyZXI6bnVsbH1nZXQgcmVuZGVyTWF0cml4KCl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4KXJldHVybiB0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg7bGV0IFA9dGhpcy5sb2NhbE1hdHJpeDtjb25zdCBMPXRoaXMucGFyZW50O2lmKEwpe2NvbnN0IEQ9TC5fX2NhY2hlUmVuZGVyTWF0cml4fHxMLnJlbmRlck1hdHJpeDtEJiYoUD1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELFApKX1yZXR1cm4gUH1nZXQgd29ybGRTY2FsaW5nKCl7Y29uc3QgUD10aGlzLnJlbmRlck1hdHJpeDtyZXR1cm5bTWF0aC5oeXBvdChQWzBdLFBbMV0pLE1hdGguaHlwb3QoUFsyXSxQWzNdKV19Z2V0IHdvcmxkUm90YXRpb24oKXtjb25zdCBQPXRoaXMucmVuZGVyTWF0cml4O3JldHVybiBNYXRoLmF0YW4yKFBbMV0sUFszXSl9Z2V0IHdvcmxkUG9zaXRpb24oKXtjb25zdCBQPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltQWzRdLFBbNV1dfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW0FdfWdldCBjbGFzc05hbWUoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZX1zZXQgY2xhc3NOYW1lKFApe3RoaXMuYXR0cmlidXRlcy5jbGFzc05hbWU9UH1nZXQgaWQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmlkfXNldCBpZChQKXt0aGlzLmF0dHJpYnV0ZXMuaWQ9UH1nZXQgbmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMubmFtZX1zZXQgbmFtZShQKXt0aGlzLmF0dHJpYnV0ZXMubmFtZT1QfWdldCB6SW5kZXgoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnpJbmRleH1zZXQgekluZGV4KFApe3RoaXMuYXR0cmlidXRlcy56SW5kZXg9UH1nZXQgbWVzaCgpe3JldHVybiBudWxsfWdldCBzaGFkZXJBdHRycygpe3JldHVybiB0aGlzW09dfHx7fX1hY3RpdmF0ZUFuaW1hdGlvbnMoKXtjb25zdCBQPXRoaXMubGF5ZXI7aWYoUCl7Y29uc3QgTD10aGlzW3ZdO0wuZm9yRWFjaChDPT57Qy5iYXNlVGltZWxpbmU9UC50aW1lbGluZSxDLnBsYXkoKSxDLmZpbmlzaGVkLnRoZW4oKCk9PntMLmRlbGV0ZShDKX0pfSk7Y29uc3QgRD10aGlzLmNoaWxkcmVuO0QmJkQuZm9yRWFjaChDPT57Qy5hY3RpdmF0ZUFuaW1hdGlvbnMmJkMuYWN0aXZhdGVBbmltYXRpb25zKCl9KX19YWRkRXZlbnRMaXN0ZW5lcihQLEwsRD17fSl7UD09PSJtb3VzZXdoZWVsIiYmKFA9IndoZWVsIiksdHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0e2NhcHR1cmU6QyxvbmNlOlN9PUQsQj1DP2k6TTtyZXR1cm4gdGhpc1tCXVtQXT10aGlzW0JdW1BdfHxbXSx0aGlzW0JdW1BdLnB1c2goe2xpc3RlbmVyOkwsb25jZTpTfSksdGhpc31hbmltYXRlKFAsTCl7Y29uc3QgRD1uZXcgZC5kZWZhdWx0KHRoaXMsUCxMKTtyZXR1cm4gdGhpcy5lZmZlY3RzJiZELmFwcGx5RWZmZWN0cyh0aGlzLmVmZmVjdHMpLHRoaXMubGF5ZXImJihELmJhc2VUaW1lbGluZT10aGlzLmxheWVyLnRpbWVsaW5lLEQucGxheSgpLEQuZmluaXNoZWQudGhlbigoKT0+e3RoaXNbdl0uZGVsZXRlKEQpfSkpLHRoaXNbdl0uYWRkKEQpLER9YXR0ciguLi5QKXtpZihQLmxlbmd0aD09PTApcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tiXTtpZihQLmxlbmd0aD4xKXtsZXRbTCxEXT1QO3JldHVybiB0eXBlb2YgRD09ImZ1bmN0aW9uIiYmKEQ9RCh0aGlzLmF0dHIoTCkpKSx0aGlzLnNldEF0dHJpYnV0ZShMLEQpLHRoaXN9cmV0dXJuIHR5cGVvZiBQWzBdPT0ic3RyaW5nIj90aGlzLmdldEF0dHJpYnV0ZShQWzBdKTooT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsUFswXSksdGhpcyl9Y2xvbmVOb2RlKCl7Y29uc3QgUD1uZXcgdGhpcy5jb25zdHJ1Y3RvcixMPXRoaXMuYXR0cmlidXRlc1t4XTtyZXR1cm4gUC5hdHRyKEwpLFB9Y29ubmVjdChQLEwpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYXJlbnQiLHt2YWx1ZTpQLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6T3JkZXIiLHt2YWx1ZTpMLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLFAudGltZWxpbmUmJnRoaXMuYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5zZXRSZXNvbHV0aW9uKFAuZ2V0UmVzb2x1dGlvbigpKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhcHBlbmQiLGRldGFpbDp7cGFyZW50OlAsek9yZGVyOkx9fSl9Y29udGFpbnMoUCl7Zm9yKDtQJiZ0aGlzIT09UDspUD1QLnBhcmVudDtyZXR1cm4hIVB9ZGVhY3RpdmF0ZUFuaW1hdGlvbnMoKXt0aGlzW3ZdLmZvckVhY2goTD0+TC5jYW5jZWwoKSk7Y29uc3QgUD10aGlzLmNoaWxkcmVuO1AmJlAuZm9yRWFjaChMPT57TC5kZWFjdGl2YXRlQW5pbWF0aW9ucyYmTC5kZWFjdGl2YXRlQW5pbWF0aW9ucygpfSl9ZGlzY29ubmVjdCgpe2NvbnN0e3BhcmVudDpQLHpPcmRlcjpMfT10aGlzO2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXIsdGhpcy5kZWFjdGl2YXRlQW5pbWF0aW9ucygpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVtb3ZlIixkZXRhaWw6e3BhcmVudDpQLHpPcmRlcjpMfX0pLFAmJlAuZm9yY2VVcGRhdGUoKX1kaXNwYXRjaEV2ZW50KFApe1AgaW5zdGFuY2VvZiB1LmRlZmF1bHR8fChQPW5ldyB1LmRlZmF1bHQoUCkpLFAudGFyZ2V0PXRoaXM7bGV0IEw9UC50eXBlO0w9PT0ibW91c2V3aGVlbCImJihMPSJ3aGVlbCIpO2NvbnN0IEQ9W3RoaXNdO2xldCBDPXRoaXMucGFyZW50O2Zvcig7UC5idWJibGVzJiZDOylELnB1c2goQyksQz1DLnBhcmVudDtmb3IobGV0IFM9RC5sZW5ndGgtMTtTPj0wO1MtLSl7Y29uc3QgQj1EW1NdLHc9QltpXSYmQltpXVtMXTtpZih3JiZ3Lmxlbmd0aCYmKFAuY3VycmVudFRhcmdldD1CLHcuZm9yRWFjaCgoe2xpc3RlbmVyOkgsb25jZTpafSk9PntILmNhbGwodGhpcyxQKSxaJiZELnJlbW92ZUV2ZW50TGlzdGVuZXIoSCl9KSxkZWxldGUgUC5jdXJyZW50VGFyZ2V0KSwhUC5idWJibGVzJiZQLmNhbmNlbEJ1YmJsZSlicmVha31pZighUC5jYW5jZWxCdWJibGUpZm9yKGxldCBTPTA7UzxELmxlbmd0aDtTKyspe2NvbnN0IEI9RFtTXSx3PUJbTV0mJkJbTV1bTF07aWYodyYmdy5sZW5ndGgmJihQLmN1cnJlbnRUYXJnZXQ9Qix3LmZvckVhY2goKHtsaXN0ZW5lcjpILG9uY2U6Wn0pPT57SC5jYWxsKHRoaXMsUCksWiYmRC5yZW1vdmVFdmVudExpc3RlbmVyKEgpfSksZGVsZXRlIFAuY3VycmVudFRhcmdldCksIVAuYnViYmxlc3x8UC5jYW5jZWxCdWJibGUpYnJlYWt9fWRpc3BhdGNoUG9pbnRlckV2ZW50KFApe2NvbnN0e2xheWVyWDpMLGxheWVyWTpEfT1QO3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oTCxEKT8odGhpcy5kaXNwYXRjaEV2ZW50KFApLCEwKTohMX1kcmF3KFA9W10pe2NvbnN0IEw9dGhpcy5tZXNoO2lmKEwpe2lmKE9iamVjdChvLmFwcGx5RmlsdGVycykoTCx0aGlzLmZpbHRlcnMpLFAucHVzaChMKSx0aGlzW2ZdKXtMLnNldFByb2dyYW0odGhpc1tmXSk7Y29uc3QgRD10aGlzW09dO0QmJk9iamVjdC5lbnRyaWVzKEQpLmZvckVhY2goKFtTLEJdKT0+e0wuc2V0QXR0cmlidXRlKFMsQil9KTtjb25zdCBDPXRoaXNbQV07aWYodGhpc1tBXSl7Y29uc3QgUz17fTtPYmplY3QuZW50cmllcyhDKS5mb3JFYWNoKChbQix3XSk9Pnt0eXBlb2Ygdz09ImZ1bmN0aW9uIiYmKHc9dyh0aGlzLEIpKSxTW0JdPXd9KSxMLnNldFVuaWZvcm1zKFMpfX1PYmplY3QoYy5kZWZhdWx0KSh0aGlzLEwpfXJldHVybiBQfWZvcmNlVXBkYXRlKCl7dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmZvcmNlVXBkYXRlKCl9Z2V0QXR0cmlidXRlKFApe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbUF19Z2V0TGlzdGVuZXJzKFAse2NhcHR1cmU6TD0hMX09e30pe3JldHVyblsuLi50aGlzW0w/aTpNXVtQXXx8W11dfWdldE5vZGVOZWFyQnkoUD0xKXtpZighdGhpcy5wYXJlbnQpcmV0dXJuIG51bGw7aWYoUD09PTApcmV0dXJuIHRoaXM7Y29uc3QgTD10aGlzLnBhcmVudC5jaGlsZHJlbixEPUwuaW5kZXhPZih0aGlzKTtyZXR1cm4gTFtEK1BdfWdldFdvcmxkUG9zaXRpb24oUCxMKXtjb25zdCBEPXRoaXMucmVuZGVyTWF0cml4LEM9UCpEWzBdK0wqRFsyXStEWzRdLFM9UCpEWzFdK0wqRFszXStEWzVdO3JldHVybltDLFNdfWdldE9mZnNldFBvc2l0aW9uKFAsTCl7Y29uc3QgRD1yLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpcy5yZW5kZXJNYXRyaXgpLEM9UCpEWzBdK0wqRFsyXStEWzRdLFM9UCpEWzFdK0wqRFszXStEWzVdO3JldHVybltDLFNdfWdldFJlc29sdXRpb24oKXtyZXR1cm4gbCh7fSx0aGlzW0VdKX1pc1BvaW50Q29sbGlzaW9uKFAsTCl7aWYoIXRoaXMubWVzaClyZXR1cm4hMTtjb25zdCBEPXRoaXMuYXR0cmlidXRlcy5wb2ludGVyRXZlbnRzO2lmKEQ9PT0ibm9uZSJ8fEQhPT0iYWxsIiYmIXRoaXMuaXNWaXNpYmxlKXJldHVybiExO2xldCBDPSJib3RoIjtyZXR1cm4gRD09PSJ2aXNpYmxlRmlsbCImJihDPSJmaWxsIiksRD09PSJ2aXNpYmxlU3Ryb2tlIiYmKEM9InN0cm9rZSIpLHRoaXMubWVzaC5pc1BvaW50Q29sbGlzaW9uKFAsTCxDKX1vblByb3BlcnR5Q2hhbmdlKFAsTCxEKXtQIT09ImlkIiYmUCE9PSJuYW1lIiYmUCE9PSJjbGFzc05hbWUiJiZQIT09InBvaW50ZXJFdmVudHMiJiZQIT09InBhc3NFdmVudHMiJiZ0aGlzLmZvcmNlVXBkYXRlKCksUD09PSJmaWx0ZXIiJiYodGhpc1thXT1PYmplY3Qoby5wYXJzZUZpbHRlclN0cmluZykoTCkpLFA9PT0iekluZGV4IiYmdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlb3JkZXIoKX1zZXRBdHRyaWJ1dGUoUCxMKXtQPT09ImF0dHJzIiYmdGhpcy5hdHRyKEwpLHRoaXMuYXR0cmlidXRlc1tQXT1MfXNldE1vdXNlQ2FwdHVyZSgpe3RoaXMubGF5ZXImJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD10aGlzKX1zZXRQcm9ncmFtKFApe3RoaXNbZl09UCx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0U2hhZGVyQXR0cmlidXRlKFAsTCl7dGhpc1tPXT10aGlzW09dfHx7fSx0aGlzW09dW1BdPUwsdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFVuaWZvcm1zKFApe3RoaXNbQV09dGhpc1tBXXx8e30sT2JqZWN0LmFzc2lnbih0aGlzW0FdLFApLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpQLGhlaWdodDpMfSl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Q309dGhpc1tFXTsoRCE9PVB8fEMhPT1MKSYmKHRoaXNbRV09e3dpZHRoOlAsaGVpZ2h0Okx9LHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc29sdXRpb25jaGFuZ2UiLGRldGFpbDp7d2lkdGg6UCxoZWlnaHQ6TH19KSl9c2hvdygpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiJiYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9dGhpc1tzXXx8IiIpfWhpZGUoKXt0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSE9PSJub25lIiYmKHRoaXNbc109dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXksdGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9Im5vbmUiKX1yZWxlYXNlTW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmdGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9PT10aGlzJiYodGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbCl9cmVtb3ZlKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZD8odGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksITApOiExfXJlbW92ZUFsbExpc3RlbmVycyhQLEw9e30pe3R5cGVvZiBMPT0iYm9vbGVhbiImJihMPXtjYXB0dXJlOkx9KTtjb25zdCBDPUwuY2FwdHVyZT9pOk07cmV0dXJuIHRoaXNbQ11bUF0mJih0aGlzW0NdW1BdPVtdKSx0aGlzfXJlbW92ZUF0dHJpYnV0ZShQKXt0aGlzLnNldEF0dHJpYnV0ZShQLG51bGwpfXJlbW92ZUV2ZW50TGlzdGVuZXIoUCxMLEQ9e30pe3R5cGVvZiBEPT0iYm9vbGVhbiImJihEPXtjYXB0dXJlOkR9KTtjb25zdCBTPUQuY2FwdHVyZT9pOk07aWYodGhpc1tTXVtQXSl7Y29uc3QgQj10aGlzW1NdW1BdO2lmKEIpZm9yKGxldCB3PTA7dzxCLmxlbmd0aDt3Kyspe2NvbnN0e2xpc3RlbmVyOkh9PUJbd107aWYoSD09PUwpe3RoaXNbU11bUF0uc3BsaWNlKHcsMSk7YnJlYWt9fX1yZXR1cm4gdGhpc310cmFuc2l0aW9uKFAsTD0ibGluZWFyIil7Y29uc3QgRD10aGlzLEM9U3ltYm9sKCJhbmltYXRpb24iKTtMPUx8fCJsaW5lYXIiO2xldCBTPTA7cmV0dXJuIHR5cGVvZiBQPT0ib2JqZWN0IiYmKFM9UC5kZWxheXx8MCxQPVAuZHVyYXRpb24pLHtbQ106bnVsbCxjYW5jZWwoQj0hMSl7Y29uc3Qgdz10aGlzW0NdO3cmJncuY2FuY2VsKEIpfSxlbmQoKXtjb25zdCBCPXRoaXNbQ107QiYmKEIucGxheVN0YXRlPT09InJ1bm5pbmcifHxCLnBsYXlTdGF0ZT09PSJwZW5kaW5nIikmJkIuZmluaXNoKCl9LHJldmVyc2UoKXtjb25zdCBCPXRoaXNbQ107aWYoQilpZihCLnBsYXlTdGF0ZT09PSJydW5uaW5nInx8Qi5wbGF5U3RhdGU9PT0icGVuZGluZyIpQi5wbGF5YmFja1JhdGU9LUIucGxheWJhY2tSYXRlO2Vsc2V7Y29uc3Qgdz1CLnRpbWluZy5kaXJlY3Rpb247Qi50aW1pbmcuZGlyZWN0aW9uPXc9PT0icmV2ZXJzZSI/Im5vcm1hbCI6InJldmVyc2UiLEIucGxheSgpfXJldHVybiBCLmZpbmlzaGVkfSxhdHRyKEIsdyl7cmV0dXJuIHRoaXMuZW5kKCksdHlwZW9mIEI9PSJzdHJpbmciJiYoQj17W0JdOnd9KSxPYmplY3QuZW50cmllcyhCKS5mb3JFYWNoKChbSCxaXSk9Pnt0eXBlb2YgWj09ImZ1bmN0aW9uIiYmKEJbSF09WihELmF0dHIoSCkpKX0pLHRoaXNbQ109RC5hbmltYXRlKFtCXSx7ZHVyYXRpb246UCoxZTMsZGVsYXk6UyoxZTMsZmlsbDoiZm9yd2FyZHMiLGVhc2luZzpMfSksdGhpc1tDXS5maW5pc2hlZH19fXVwZGF0ZUNvbnRvdXJzKCl7fX15KFIsIkF0dHIiLG4uZGVmYXVsdCksZy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShSLCJub2RlIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KTt2YXIgcj10KDEpLG49dCgxMiksZD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIikscD1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSx5PVN5bWJvbCgic3ViamVjdCIpLHg9U3ltYm9sKCJhdHRyIiksYj1TeW1ib2woImRlZmF1bHQiKSxFPVN5bWJvbCgiYWxpYXMiKTtmdW5jdGlvbiB2KEksW1AsTF0pe2xldCBEPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7cmV0dXJuWy4uLkldLmZvckVhY2goKFtDLFNdKT0+e2lmKChQfHxMKSYmKEQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsW1AsTF0pKSxDPT09Im1hdHJpeCIpRD1yLm1hdDJkLm11bHRpcGx5KEQsRCxTKTtlbHNlIGlmKEM9PT0ib2Zmc2V0VHJhbnNsYXRlIilEWzRdKz1TWzBdLERbNV0rPVNbMV07ZWxzZSBpZihDPT09Im9mZnNldFJvdGF0ZSIpRD1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRCxTKTtlbHNlIGlmKEM9PT0ic2tldyIpe2NvbnN0W0Isd109UztEPXIubWF0MmQubXVsdGlwbHkoRCxELHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKHcpLE1hdGgudGFuKEIpLDEsMCwwKSl9ZWxzZSByLm1hdDJkW0NdKEQsRCxTKTsoUHx8TCkmJihEPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELFstUCwtTF0pKX0pLER9Y29uc3QgTT1TeW1ib2woInRyYW5zZm9ybU1hdHJpeCIpLGk9U3ltYm9sKCJ0cmFuc2Zvcm1zIiksYT1TeW1ib2woImNoYW5nZWRBdHRycyIpLHM9U3ltYm9sKCJsYXN0Q2hhbmdlZEF0dHIiKSxmPVN5bWJvbCgib2Zmc2V0RmlndXJlIik7ZnVuY3Rpb24gTyhJLFAsTCl7Y29uc3QgRD1JW3hdW1BdO2lmKElbb10oUCxMLCExKXx8SVtzXSE9PVApe2NvbnN0IFM9SVtpXTtTLmhhcyhQKSYmUy5kZWxldGUoUCksTCYmKFA9PT0icm90YXRlIiYmKEw9TWF0aC5QSSpMLzE4MCksUD09PSJzY2FsZSImJihMPUwubWFwKEI9Pk1hdGguYWJzKEIpPjFlLTU/QjoxL0I+MD8xZS01Oi0xZS01KSksUy5zZXQoUCxMKSksSVtNXT1udWxsLElbeV0ub25Qcm9wZXJ0eUNoYW5nZShQLEwsRCxJKX19ZnVuY3Rpb24gQShJKXtjb25zdCBQPUlbZl0sTD1JLm9mZnNldERpc3RhbmNlKlAuZ2V0VG90YWxMZW5ndGgoKSxEPVAuZ2V0UG9pbnRBdExlbmd0aChMKTtpZihEKXtjb25zdCBDPUlbaV07bGV0IFM9SS5vZmZzZXRSb3RhdGU7Uz09PSJhdXRvIj9TPUQuYW5nbGU6Uz09PSJyZXZlcnNlIj9TPU1hdGguUEkrRC5hbmdsZTpTPU1hdGguUEkqUy8xODAsQy5zZXQoIm9mZnNldFJvdGF0ZSIsUyksQy5zZXQoIm9mZnNldFRyYW5zbGF0ZSIsW0QueCxELnldKSxJW01dPW51bGx9fWNsYXNzIFJ7c3RhdGljIHNldERlZmF1bHQoUCwuLi5MKXtyZXR1cm4gUFtnXSguLi5MKX1zdGF0aWMgZGVjbGFyZUFsaWFzKFAsLi4uTCl7cmV0dXJuIFBbdV0oLi4uTCl9c3RhdGljIHNldEF0dHJpYnV0ZShQLC4uLkwpe3JldHVybiBQW29dKC4uLkwpfXN0YXRpYyBnZXRBdHRyaWJ1dGUoUCwuLi5MKXtyZXR1cm4gUFtjXSguLi5MKX1zdGF0aWMgZ2V0QXR0cmlidXRlcyhQKXtyZXR1cm4gUFtwXX1zdGF0aWMgZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoUCl7cmV0dXJuIFBbbF19Y29uc3RydWN0b3IoUCl7dGhpc1t5XT1QLHRoaXNbeF09e30sdGhpc1tNXT1yLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLHRoaXNbaV09bmV3IE1hcCx0aGlzW2JdPXt9LHRoaXNbRV09W10sT2JqZWN0LmRlZmluZVByb3BlcnR5KFAsInRyYW5zZm9ybU1hdHJpeCIse2dldDooKT0+KHRoaXNbTV18fCh0aGlzW01dPXYodGhpc1tpXSx0aGlzLnRyYW5zZm9ybU9yaWdpbikpLFsuLi50aGlzW01dXSl9KSx0aGlzW2ddKHtpZDoiIixuYW1lOiIiLGNsYXNzTmFtZToiIix4OjAseTowLHRyYW5zZm9ybU9yaWdpbjpbMCwwXSx0cmFuc2Zvcm06IiIsdHJhbnNsYXRlOlswLDBdLHJvdGF0ZTowLHNjYWxlOlsxLDFdLHNrZXc6WzAsMF0sb3BhY2l0eToxLHpJbmRleDowLG9mZnNldFBhdGg6dm9pZCAwLG9mZnNldERpc3RhbmNlOjAsb2Zmc2V0Um90YXRlOiJhdXRvIixwb2ludGVyRXZlbnRzOiJ2aXNpYmxlIixmaWx0ZXI6Im5vbmUiLGRpc3BsYXk6IiJ9KSx0aGlzW3VdKCJjbGFzcyIsInBvcyIpLHRoaXNbYV09bmV3IFNldCx0aGlzW2ZdPW5ldyBuLkZpZ3VyZTJEKHtzY2FsZTo1LHNpbXBsaWZ5OjB9KX1nZXRbbF0oKXtjb25zdCBQPXt9O3JldHVyblsuLi50aGlzW2FdXS5mb3JFYWNoKEw9PntQW0xdPXRoaXNbeF1bTF19KSxQfWdldFtwXSgpe2NvbnN0IFA9T2JqZWN0LmFzc2lnbih7fSx0aGlzW3hdKTtmb3IobGV0IEw9MDtMPHRoaXNbRV0ubGVuZ3RoO0wrKyl7Y29uc3QgRD10aGlzW0VdW0xdO1BbRF09dGhpc1tEXX1yZXR1cm4gUH1bZ10oUCl7T2JqZWN0LmFzc2lnbih0aGlzW2JdLFApLE9iamVjdC5hc3NpZ24odGhpc1t4XSxQKX1bdV0oLi4uUCl7dGhpc1tFXS5wdXNoKC4uLlApfVtvXShQLEwsRD0hMCl7Y29uc3QgQz10aGlzW3hdW1BdLFM9dGhpc1t5XTtyZXR1cm4gTD09bnVsbCYmKEw9dGhpc1tiXVtQXSksT2JqZWN0KGQuY29tcGFyZVZhbHVlKShDLEwpPyExOih0aGlzW3hdW1BdPUwsdGhpc1thXS5oYXMoUCkmJnRoaXNbYV0uZGVsZXRlKFApLHRoaXNbYV0uYWRkKFApLHRoaXNbc109UCxEJiZTLm9uUHJvcGVydHlDaGFuZ2UoUCxMLEMsdGhpcyksITApfVtjXShQKXtyZXR1cm4gdGhpc1t4XVtQXX1zZXQgaWQoUCl7dGhpc1tvXSgiaWQiLFApfWdldCBpZCgpe3JldHVybiB0aGlzW2NdKCJpZCIpfXNldCBuYW1lKFApe3RoaXNbb10oIm5hbWUiLFApfWdldCBuYW1lKCl7cmV0dXJuIHRoaXNbY10oIm5hbWUiKX1zZXQgY2xhc3NOYW1lKFApe3RoaXNbb10oImNsYXNzTmFtZSIsUCl9Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzW2NdKCJjbGFzc05hbWUiKX1zZXQgY2xhc3MoUCl7dGhpcy5jbGFzc05hbWU9UH1nZXQgY2xhc3MoKXtyZXR1cm4gdGhpcy5jbGFzc05hbWV9Z2V0IHgoKXtyZXR1cm4gdGhpc1tjXSgieCIpfXNldCB4KFApe3RoaXNbb10oIngiLE9iamVjdChkLnRvTnVtYmVyKShQKSl9Z2V0IHkoKXtyZXR1cm4gdGhpc1tjXSgieSIpfXNldCB5KFApe3RoaXNbb10oInkiLE9iamVjdChkLnRvTnVtYmVyKShQKSl9Z2V0IHBvcygpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXQgcG9zKFApe1A9T2JqZWN0KGQudG9BcnJheSkoUCksQXJyYXkuaXNBcnJheShQKXx8KFA9W1AsUF0pLHRoaXMueD1QWzBdLHRoaXMueT1QWzFdfWdldCB0cmFuc2Zvcm0oKXtyZXR1cm4gdGhpc1tjXSgidHJhbnNmb3JtIil9c2V0IHRyYW5zZm9ybShQKXtsZXQgTD1udWxsO2lmKEFycmF5LmlzQXJyYXkoUCkmJihMPVAsUD1gbWF0cml4KCR7UC5tYXAoZC50b051bWJlcikuam9pbigpfSlgKSx0eXBlb2YgUD09InN0cmluZyIpUD1QLnJlcGxhY2UoL1xzKixccyovZywiLCIpO2Vsc2UgaWYoUCE9bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHRyYW5zZm9ybSB2YWx1ZS4iKTtjb25zdCBEPXRoaXNbeF0udHJhbnNmb3JtO2lmKHRoaXNbb10oInRyYW5zZm9ybSIsUCwhMSkpe2NvbnN0IEM9dGhpc1tpXTtpZihDLmhhcygibWF0cml4IikmJkMuZGVsZXRlKCJtYXRyaXgiKSxMKUMuc2V0KCJtYXRyaXgiLEwpO2Vsc2UgaWYoUCl7Y29uc3QgUz1QLm1hdGNoKC8obWF0cml4fHRyYW5zbGF0ZXxyb3RhdGV8c2NhbGV8c2tldylcKFteKCldK1wpL2cpO2lmKFMpe2xldCBCPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7Zm9yKGxldCB3PTA7dzxTLmxlbmd0aDt3Kyspe2NvbnN0IFo9U1t3XS5tYXRjaCgvXihtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoKFteKCldKylcKS8pO2lmKFope2xldFsscSxVXT1aO3E9PT0icm90YXRlIj9VPU1hdGguUEkqcGFyc2VGbG9hdChVKS8xODA6VT1VLnRyaW0oKS5zcGxpdCgvW1xzLF0rLykubWFwKEc9Pk9iamVjdChkLnRvTnVtYmVyKShHKSkscT09PSJtYXRyaXgiP0I9ci5tYXQyZC5tdWx0aXBseShCLEIsVSk6cT09PSJza2V3Ij9CPXIubWF0MmQubXVsdGlwbHkoQixCLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKFVbMV0pLE1hdGgudGFuKFVbMF0pLDEsMCwwKSk6ci5tYXQyZFtxXShCLEIsVSksQy5zZXQoIm1hdHJpeCIsQil9fX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpfXRoaXNbTV09bnVsbCx0aGlzW3ldLm9uUHJvcGVydHlDaGFuZ2UoInRyYW5zZm9ybSIsUCxELHRoaXMpfX1nZXQgdHJhbnNmb3JtT3JpZ2luKCl7cmV0dXJuIHRoaXNbY10oInRyYW5zZm9ybU9yaWdpbiIpfXNldCB0cmFuc2Zvcm1PcmlnaW4oUCl7UD1PYmplY3QoZC50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLHRoaXNbb10oInRyYW5zZm9ybU9yaWdpbiIsUCkmJih0aGlzW01dPW51bGwpfWdldCByb3RhdGUoKXtyZXR1cm4gdGhpc1tjXSgicm90YXRlIil9c2V0IHJvdGF0ZShQKXtPKHRoaXMsInJvdGF0ZSIsUCl9Z2V0IHRyYW5zbGF0ZSgpe3JldHVybiB0aGlzW2NdKCJ0cmFuc2xhdGUiKX1zZXQgdHJhbnNsYXRlKFApe1A9T2JqZWN0KGQudG9BcnJheSkoUCwhMCksUCE9bnVsbCYmIUFycmF5LmlzQXJyYXkoUCkmJihQPVtQLFBdKSxPKHRoaXMsInRyYW5zbGF0ZSIsUCl9Z2V0IHNjYWxlKCl7cmV0dXJuIHRoaXNbY10oInNjYWxlIil9c2V0IHNjYWxlKFApe1A9T2JqZWN0KGQudG9BcnJheSkoUCwhMCksUCE9bnVsbCYmIUFycmF5LmlzQXJyYXkoUCkmJihQPVtQLFBdKSxPKHRoaXMsInNjYWxlIixQKX1nZXQgc2tldygpe3JldHVybiB0aGlzW2NdKCJza2V3Iil9c2V0IHNrZXcoUCl7UD1PYmplY3QoZC50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLE8odGhpcywic2tldyIsUCl9Z2V0IG9wYWNpdHkoKXtyZXR1cm4gdGhpc1tjXSgib3BhY2l0eSIpfXNldCBvcGFjaXR5KFApe1AhPW51bGwmJihQPU51bWJlcihQKSksdGhpc1tvXSgib3BhY2l0eSIsUCl9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzW2NdKCJ6SW5kZXgiKX1zZXQgekluZGV4KFApe1AhPW51bGwmJihQPU51bWJlcihQKSksdGhpc1tvXSgiekluZGV4IixQKX1nZXQgb2Zmc2V0UGF0aCgpe3JldHVybiB0aGlzW2NdKCJvZmZzZXRQYXRoIil9c2V0IG9mZnNldFBhdGgoUCl7dGhpc1tvXSgib2Zmc2V0UGF0aCIsUCkmJih0aGlzW2ZdLmJlZ2luUGF0aCgpLFAhPW51bGwmJnRoaXNbZl0uYWRkUGF0aChQKSxBKHRoaXMpKX1nZXQgb2Zmc2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpc1tjXSgib2Zmc2V0RGlzdGFuY2UiKX1zZXQgb2Zmc2V0RGlzdGFuY2UoUCl7dGhpc1tvXSgib2Zmc2V0RGlzdGFuY2UiLE9iamVjdChkLnRvTnVtYmVyKShQKSkmJkEodGhpcyl9Z2V0IG9mZnNldFJvdGF0ZSgpe3JldHVybiB0aGlzW2NdKCJvZmZzZXRSb3RhdGUiKX1zZXQgb2Zmc2V0Um90YXRlKFApe3RoaXNbb10oIm9mZnNldFJvdGF0ZSIsUCksQSh0aGlzKX1nZXQgcG9pbnRlckV2ZW50cygpe3JldHVybiB0aGlzW2NdKCJwb2ludGVyRXZlbnRzIil9c2V0IHBvaW50ZXJFdmVudHMoUCl7aWYoUCE9bnVsbCYmUCE9PSJub25lIiYmUCE9PSJ2aXNpYmxlIiYmUCE9PSJ2aXNpYmxlRmlsbCImJlAhPT0idmlzaWJsZVN0cm9rZSImJlAhPT0iYWxsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHBvaW50ZXJFdmVudHMgdHlwZS4iKTt0aGlzW29dKCJwb2ludGVyRXZlbnRzIixQKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbY10oImZpbHRlciIpfXNldCBmaWx0ZXIoUCl7dGhpc1tvXSgiZmlsdGVyIixQKX1nZXQgZGlzcGxheSgpe3JldHVybiB0aGlzW2NdKCJkaXNwbGF5Iil9c2V0IGRpc3BsYXkoUCl7dGhpc1tvXSgiZGlzcGxheSIsUCl9c2V0IG9mZnNldChQKXt9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwic2l6ZVRvUGl4ZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwidG9OdW1iZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwidG9BcnJheSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjb21wYXJlVmFsdWUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihvLGMpe2NvbnN0IHA9by50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW4pJC8pO3A/bz17c2l6ZTpwYXJzZUZsb2F0KHBbMV0pLHVuaXQ6cFsyXX06bz17c2l6ZTpwYXJzZUZsb2F0KG8pLHVuaXQ6InB4In07bGV0e3NpemU6bCx1bml0Onl9PW87aWYoeT09PSJwdCIpbC89Ljc1O2Vsc2UgaWYoeT09PSJwYyIpbCo9MTY7ZWxzZSBpZih5PT09ImluIilsKj05NjtlbHNlIGlmKHk9PT0iY20iKWwqPTk2LzIuNTQ7ZWxzZSBpZih5PT09Im1tIilsKj05Ni8yNS40O2Vsc2UgaWYoeT09PSJlbSJ8fHk9PT0icmVtInx8eT09PSJleCIpe2lmKCFjJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeD1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7eD9jPXIoeCwxNik6Yz0xNn1sKj1jLHk9PT0iZXgiJiYobC89Mil9ZWxzZSBpZih5PT09InEiKWwqPTk2LzI1LjQvNDtlbHNlIGlmKHk9PT0idncifHx5PT09InZoIil7aWYodHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeD15PT09InZ3Ij93aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOndpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtsKj14LzEwMH19ZWxzZSBpZigoeT09PSJ2bWF4Inx8eT09PSJ2bWluIikmJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IHg9d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxiPXdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDt5PT09InZtYXgiP2wqPU1hdGgubWF4KHgsYikvMTAwOmwqPU1hdGgubWluKHgsYikvMTAwfXJldHVybiBsfWZ1bmN0aW9uIG4obyl7cmV0dXJuIG89PW51bGw/bzpTdHJpbmcobyl9ZnVuY3Rpb24gZChvKXtpZihvPT1udWxsKXJldHVybiBvO2lmKHR5cGVvZiBvPT0ic3RyaW5nIiYmKG89cihvKSksIU51bWJlci5pc0Zpbml0ZShvKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZhbHVlIik7cmV0dXJuIG99ZnVuY3Rpb24gZyhvLGM9ITEpe3JldHVybiBvPT09IiI/bnVsbDoodHlwZW9mIG89PSJzdHJpbmciJiYobz1vLnNwbGl0KC9bXHMsXSsvZykpLEFycmF5LmlzQXJyYXkobykmJihjJiYobz1vLm1hcChkKSksby5sZW5ndGg9PT0xKT9vWzBdOm8pfWZ1bmN0aW9uIHUobyxjKXtpZihBcnJheS5pc0FycmF5KG8pJiZBcnJheS5pc0FycmF5KGMpKXtpZihvLmxlbmd0aCE9PWMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcD0wO3A8by5sZW5ndGg7cCsrKWlmKG9bcF0hPT1jW3BdKXJldHVybiExO3JldHVybiEwfXJldHVybiBvPT1udWxsJiZjPT1udWxsfHxvPT09Y319LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgcj10KDc0KSxuPXQoMzIpLGQ9dC5uKG4pLGc9dCg2OCksdT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbygpe3JldHVybiBvPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHgpe2Zvcih2YXIgYj0xO2I8YXJndW1lbnRzLmxlbmd0aDtiKyspe3ZhciBFPWFyZ3VtZW50c1tiXTtmb3IodmFyIHYgaW4gRSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoRSx2KSYmKHhbdl09RVt2XSl9cmV0dXJuIHh9LG8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGMoeCl7aWYodHlwZW9mIHg9PSJzdHJpbmciKXtpZih4PXgudHJpbSgpLC9eWzAtOS5dKyUkLy50ZXN0KHgpKXJldHVybiBwYXJzZUZsb2F0KHgpLzEwMDtpZigvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLy50ZXN0KHgpKXJldHVybiBPYmplY3QodS5zaXplVG9QaXhlbCkoeCl9cmV0dXJuIHh9ZnVuY3Rpb24gcCh4LGIsRSx2LE0pe3JldHVybiB0eXBlb2YgeD09InN0cmluZyImJih4PWQoKSh4KSksdHlwZW9mIGI9PSJzdHJpbmciJiYoYj1kKCkoYikpLHIuRWZmZWN0cy5kZWZhdWx0KHgsYixFLHYsTSl9ZnVuY3Rpb24gbCh4LGIsRSx2LE0pe3JldHVybiByLkVmZmVjdHMuZGVmYXVsdCh4LGIsRSx2LE0pfXIuRWZmZWN0cy5kZWZhdWx0PWZ1bmN0aW9uKHgsYixFLHYsTSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoeCkmJkFycmF5LmlzQXJyYXkoYik/eC5tYXAoKGksYSk9PmkrKEUtdikvKE0tdikqKGJbYV0taSkpOnR5cGVvZiB4PT0ibnVtYmVyIiYmdHlwZW9mIGI9PSJudW1iZXIiP3grKEUtdikvKE0tdikqKGIteCk6RS12Pk0tRT9iOnh9LHIuRWZmZWN0cy5maWxsQ29sb3I9cCxyLkVmZmVjdHMuc3Ryb2tlQ29sb3I9cCxyLkVmZmVjdHMuYmdjb2xvcj1wLHIuRWZmZWN0cy5ib3JkZXJDb2xvcj1wLHIuRWZmZWN0cy50ZXh0PWw7Y2xhc3MgeSBleHRlbmRzIHIuQW5pbWF0b3J7Y29uc3RydWN0b3IoYixFLHYpe2NvbnN0IE09Yi5hdHRyKCk7T2JqZWN0LmVudHJpZXMoTSkuZm9yRWFjaCgoW2ksYV0pPT57TVtpXT1yLkVmZmVjdHNbaV0/YTpjKGEpfSksRT1FLm1hcChpPT57bGV0IGE9byh7fSxpKTtjb25zdCBzPXt9O3JldHVybiBPYmplY3QuZW50cmllcyhhKS5mb3JFYWNoKChbZixPXSk9PntzW2ZdPXIuRWZmZWN0c1tmXT9POmMoTyl9KSxzfSksc3VwZXIoTSxFLHYpLHRoaXMudGFyZ2V0PWIsdGhpcy5zZXR0ZXI9ZnVuY3Rpb24oaSxhKXthLmF0dHIoaSl9fWdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy50YXJnZXQucGFyZW50P3N1cGVyLnBsYXlTdGF0ZToiaWRsZSJ9Z2V0IGZpbmlzaGVkKCl7cmV0dXJuIHN1cGVyLmZpbmlzaGVkLnRoZW4oKCk9Pntjb25zdCBiPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKEU9PntmdW5jdGlvbiB2KCl7Yi5zZXR0ZXIoYi5mcmFtZSxiLnRhcmdldCk7Y29uc3QgTT1iLnBsYXlTdGF0ZTtNPT09ImZpbmlzaGVkInx8TT09PSJpZGxlIj8oT2JqZWN0KGcuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKGIucmVxdWVzdElkKSxFKCkpOk9iamVjdChnLnJlcXVlc3RBbmltYXRpb25GcmFtZSkodil9digpfSl9KX1maW5pc2goKXtzdXBlci5maW5pc2goKSxPYmplY3QoZy5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpfXBsYXkoKXtpZighdGhpcy50YXJnZXQucGFyZW50fHx0aGlzLnBsYXlTdGF0ZT09PSJydW5uaW5nIilyZXR1cm47c3VwZXIucGxheSgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpO2NvbnN0IGI9dGhpczt0aGlzLnJlYWR5LnRoZW4oKCk9PntiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KSxiLnJlcXVlc3RJZD1PYmplY3QoZy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGZ1bmN0aW9uIEUoKXtjb25zdCB2PWIudGFyZ2V0O2lmKHR5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zJiZ2LmxheWVyJiZ2LmxheWVyLmNhbnZhcyYmIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh2LmxheWVyLmNhbnZhcykpe2IuY2FuY2VsKCk7cmV0dXJufWNvbnN0IE09Yi5wbGF5U3RhdGU7Yi5zZXR0ZXIoYi5mcmFtZSxiLnRhcmdldCksTSE9PSJpZGxlIiYmKE09PT0icnVubmluZyI/Yi5yZXF1ZXN0SWQ9T2JqZWN0KGcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShFKTooTT09PSJwYXVzZWQifHxNPT09InBlbmRpbmciJiZiLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDApJiZiLnJlYWR5LnRoZW4oKCk9PntiLnNldHRlcihiLmZyYW1lLGIudGFyZ2V0KSxiLnJlcXVlc3RJZD1PYmplY3QoZy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKEUpfSkpfSl9KX1jYW5jZWwoYj0hMSl7T2JqZWN0KGcuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXMucmVxdWVzdElkKSxiPyh0aGlzLnNldHRlcih0aGlzLmZyYW1lLHRoaXMudGFyZ2V0KSxzdXBlci5jYW5jZWwoKSk6KHN1cGVyLmNhbmNlbCgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpKX19fSxmdW5jdGlvbihoLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuVGltZWxpbmU9ZS5FZmZlY3RzPWUuRWFzaW5ncz1lLkFuaW1hdG9yPXZvaWQgMDt2YXIgcj10KDc1KSxuPXAociksZD10KDE4NyksZz1wKGQpLHU9dCgxODgpLG89dCgxOTApLGM9cChvKTtmdW5jdGlvbiBwKGwpe3JldHVybiBsJiZsLl9fZXNNb2R1bGU/bDp7ZGVmYXVsdDpsfX1lLkFuaW1hdG9yPWMuZGVmYXVsdCxlLkVhc2luZ3M9dS5FYXNpbmdzLGUuRWZmZWN0cz1nLmRlZmF1bHQsZS5UaW1lbGluZT1uLmRlZmF1bHR9LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9dCg3Niksbj1pKHIpLGQ9dCgxMzMpLGc9aShkKSx1PXQoMTQxKSxvPWkodSksYz10KDE2NCkscD1pKGMpLGw9dCgxNzApLHk9aShsKSx4PXQoMTcxKSxiPWkoeCksRT10KDE3NSksdj1pKEUpLE09dCgxODYpO2Z1bmN0aW9uIGkoRCl7cmV0dXJuIEQmJkQuX19lc01vZHVsZT9EOntkZWZhdWx0OkR9fXZhciBhPSgwLE0uY3JlYXRlTm93VGltZSkoKSxzPXtvcmlnaW5UaW1lOjAscGxheWJhY2tSYXRlOjF9LGY9KDAsdi5kZWZhdWx0KSgidGltZU1hcmsiKSxPPSgwLHYuZGVmYXVsdCkoInBsYXliYWNrUmF0ZSIpLEE9KDAsdi5kZWZhdWx0KSgidGltZXJzIiksUj0oMCx2LmRlZmF1bHQpKCJvcmlnaW5UaW1lIiksST0oMCx2LmRlZmF1bHQpKCJzZXRUaW1lciIpLFA9KDAsdi5kZWZhdWx0KSgicGFyZW50IiksTD1mdW5jdGlvbigpe2Z1bmN0aW9uIEQoQyxTKXsoMCx5LmRlZmF1bHQpKHRoaXMsRCksQyBpbnN0YW5jZW9mIEQmJihTPUMsQz17fSksQz0oMCxwLmRlZmF1bHQpKHt9LHMsQyksUyYmKHRoaXNbUF09Uyk7dmFyIEI9Qy5ub3d0aW1lfHxhO2lmKFMpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImdsb2JhbFRpbWUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUy5jdXJyZW50VGltZX19KTtlbHNle3ZhciB3PUIoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBCKCktd319KX10aGlzW2ZdPVt7Z2xvYmFsVGltZTp0aGlzLmdsb2JhbFRpbWUsbG9jYWxUaW1lOi1DLm9yaWdpblRpbWUsZW50cm9weTotQy5vcmlnaW5UaW1lLHBsYXliYWNrUmF0ZTpDLnBsYXliYWNrUmF0ZSxnbG9iYWxFbnRyb3B5OjB9XSx0aGlzW1BdJiYodGhpc1tmXVswXS5nbG9iYWxFbnRyb3B5PXRoaXNbUF0uZW50cm9weSksdGhpc1tSXT1DLm9yaWdpblRpbWUsdGhpc1tPXT1DLnBsYXliYWNrUmF0ZSx0aGlzW0FdPW5ldyBvLmRlZmF1bHR9cmV0dXJuKDAsYi5kZWZhdWx0KShELFt7a2V5OiJtYXJrVGltZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgUz1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXZvaWQgMD9hcmd1bWVudHNbMF06e30sQj1TLnRpbWUsdz1CPT09dm9pZCAwP3RoaXMuY3VycmVudFRpbWU6QixIPVMuZW50cm9weSxaPUg9PT12b2lkIDA/dGhpcy5lbnRyb3B5OkgscT1TLnBsYXliYWNrUmF0ZSxVPXE9PT12b2lkIDA/dGhpcy5wbGF5YmFja1JhdGU6cSxHPXtnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6dyxlbnRyb3B5OloscGxheWJhY2tSYXRlOlUsZ2xvYmFsRW50cm9weTp0aGlzLmdsb2JhbEVudHJvcHl9O3RoaXNbZl0ucHVzaChHKX19LHtrZXk6ImZvcmsiLHZhbHVlOmZ1bmN0aW9uKFMpe3JldHVybiBuZXcgRChTLHRoaXMpfX0se2tleToic2Vla0dsb2JhbFRpbWUiLHZhbHVlOmZ1bmN0aW9uKFMpe3ZhciBCPXRoaXMuc2Vla1RpbWVNYXJrKFMpLHc9dGhpc1tmXVtCXSxIPXcuZW50cm9weSxaPXcucGxheWJhY2tSYXRlLHE9dy5nbG9iYWxUaW1lO3JldHVybiBxKyhTLUgpL01hdGguYWJzKFopfX0se2tleToic2Vla0xvY2FsVGltZSIsdmFsdWU6ZnVuY3Rpb24oUyl7dmFyIEI9dGhpcy5zZWVrVGltZU1hcmsoUyksdz10aGlzW2ZdW0JdLEg9dy5sb2NhbFRpbWUsWj13LmVudHJvcHkscT13LnBsYXliYWNrUmF0ZTtyZXR1cm4gcT4wP0grKFMtWik6SC0oUy1aKX19LHtrZXk6InNlZWtUaW1lTWFyayIsdmFsdWU6ZnVuY3Rpb24oUyl7dmFyIEI9dGhpc1tmXSx3PTAsSD1CLmxlbmd0aC0xO2lmKFM8PUJbd10uZW50cm9weSlyZXR1cm4gdztpZihTPj1CW0hdLmVudHJvcHkpcmV0dXJuIEg7Zm9yKHZhciBaPU1hdGguZmxvb3IoKHcrSCkvMik7Wj53JiZaPEg7KXtpZihTPT09QltaXS5lbnRyb3B5KXJldHVybiBaO1M8QltaXS5lbnRyb3B5P0g9WjpTPkJbWl0uZW50cm9weSYmKHc9WiksWj1NYXRoLmZsb29yKCh3K0gpLzIpfXJldHVybiB3fX0se2tleToidXBkYXRlVGltZXJzIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBTPXRoaXMsQj1bXS5jb25jYXQoKDAsZy5kZWZhdWx0KSh0aGlzW0FdKSk7Qi5mb3JFYWNoKGZ1bmN0aW9uKHcpe3ZhciBIPSgwLG4uZGVmYXVsdCkodywyKSxaPUhbMF0scT1IWzFdO1NbSV0ocS5oYW5kbGVyLHEudGltZSxaKX0pfX0se2tleToiY2xlYXJUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihDKXtmdW5jdGlvbiBTKEIpe3JldHVybiBDLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gUy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBDLnRvU3RyaW5nKCl9LFN9KGZ1bmN0aW9uKEMpe3ZhciBTPXRoaXNbQV0uZ2V0KEMpO1MmJlMudGltZXJJRCE9bnVsbCYmKHRoaXNbUF0/dGhpc1tQXS5jbGVhclRpbWVvdXQoUy50aW1lcklEKTpjbGVhclRpbWVvdXQoUy50aW1lcklEKSksdGhpc1tBXS5kZWxldGUoQyl9KX0se2tleToiY2xlYXJJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oUyl7cmV0dXJuIHRoaXMuY2xlYXJUaW1lb3V0KFMpfX0se2tleToiY2xlYXIiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIFM9dGhpcyxCPXRoaXNbQV07W10uY29uY2F0KCgwLGcuZGVmYXVsdCkoQi5rZXlzKCkpKS5mb3JFYWNoKGZ1bmN0aW9uKHcpe1MuY2xlYXJUaW1lb3V0KHcpfSl9fSx7a2V5OiJzZXRUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihTKXt2YXIgQj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9O3JldHVybiB0aGlzW0ldKFMsQil9fSx7a2V5OiJzZXRJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oUyl7dmFyIEI9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOntkZWxheTowfSx3PXRoaXMsSD10aGlzW0ldKGZ1bmN0aW9uIFooKXt3W0ldKFosQixIKSxTKCl9LEIpO3JldHVybiBIfX0se2tleTpJLHZhbHVlOmZ1bmN0aW9uKFMsQil7dmFyIHc9dGhpcyxIPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTooMCx2LmRlZmF1bHQpKCJ0aW1lcklEIik7Qj0oMCxNLmZvcm1hdERlbGF5KShCKTt2YXIgWj10aGlzW0FdLmdldChIKSxxPXZvaWQgMCxVPW51bGwsRz12b2lkIDAsSj12b2lkIDA7Wj8odGhpcy5jbGVhclRpbWVvdXQoSCksQi5pc0VudHJvcHk/cT0oQi5kZWxheS0odGhpcy5lbnRyb3B5LVouc3RhcnRFbnRyb3B5KSkvTWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnE9KEIuZGVsYXktKHRoaXMuY3VycmVudFRpbWUtWi5zdGFydFRpbWUpKS90aGlzLnBsYXliYWNrUmF0ZSxHPVouc3RhcnRUaW1lLEo9Wi5zdGFydEVudHJvcHkpOihxPUIuZGVsYXkvKEIuaXNFbnRyb3B5P01hdGguYWJzKHRoaXMucGxheWJhY2tSYXRlKTp0aGlzLnBsYXliYWNrUmF0ZSksRz10aGlzLmN1cnJlbnRUaW1lLEo9dGhpcy5lbnRyb3B5KTt2YXIgdHQ9dGhpc1tQXSxfPXR0P3R0LnNldFRpbWVvdXQuYmluZCh0dCk6c2V0VGltZW91dCxzdD1CLmhlYWRpbmc7cmV0dXJuIXR0JiZzdD09PSExJiZxPDAmJihxPTEvMCksKGlzRmluaXRlKHEpfHx0dCkmJihxPU1hdGguY2VpbChxKSxfIT09c2V0VGltZW91dCYmKHE9e2RlbGF5OnEsaGVhZGluZzpzdH0pLFU9XyhmdW5jdGlvbigpe3dbQV0uZGVsZXRlKEgpLFMoKX0scSkpLHRoaXNbQV0uc2V0KEgse3RpbWVySUQ6VSxoYW5kbGVyOlMsdGltZTpCLHN0YXJ0VGltZTpHLHN0YXJ0RW50cm9weTpKfSksSH19LHtrZXk6InBhcmVudCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbUF19fSx7a2V5OiJsYXN0VGltZU1hcmsiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2ZdW3RoaXNbZl0ubGVuZ3RoLTFdfX0se2tleToiY3VycmVudFRpbWUiLGdldDpmdW5jdGlvbigpe3ZhciBTPXRoaXMubGFzdFRpbWVNYXJrLEI9Uy5sb2NhbFRpbWUsdz1TLmdsb2JhbFRpbWU7cmV0dXJuIEIrKHRoaXMuZ2xvYmFsVGltZS13KSp0aGlzLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKFMpe3ZhciBCPXRoaXMsdz10aGlzLmN1cnJlbnRUaW1lLEg9UyxaPXRoaXNbQV07dGhpcy5tYXJrVGltZSh7dGltZTpTfSksW10uY29uY2F0KCgwLGcuZGVmYXVsdCkoWikpLmZvckVhY2goZnVuY3Rpb24ocSl7dmFyIFU9KDAsbi5kZWZhdWx0KShxLDIpLEc9VVswXSxKPVVbMV07aWYoWi5oYXMoRykpe3ZhciB0dD1KLnRpbWUsXz10dC5pc0VudHJvcHksc3Q9dHQuZGVsYXksaz10dC5oZWFkaW5nLGh0PUouaGFuZGxlcixmdD1KLnN0YXJ0VGltZTtpZihfKXN0PT09MCYmKGh0KCksQi5jbGVhclRpbWVvdXQoRykpO2Vsc2V7dmFyIFc9ZnQrc3Q7KHN0PT09MHx8ayE9PSExJiYoSC13KSpzdDw9MHx8dzw9VyYmVzw9SHx8dz49VyYmVz49SCkmJihodCgpLEIuY2xlYXJUaW1lb3V0KEcpKX19fSksdGhpcy51cGRhdGVUaW1lcnMoKX19LHtrZXk6ImVudHJvcHkiLGdldDpmdW5jdGlvbigpe3ZhciBTPXRoaXMubGFzdFRpbWVNYXJrLEI9Uy5lbnRyb3B5LHc9Uy5nbG9iYWxFbnRyb3B5O3JldHVybiBCK01hdGguYWJzKCh0aGlzLmdsb2JhbEVudHJvcHktdykqdGhpcy5wbGF5YmFja1JhdGUpfSxzZXQ6ZnVuY3Rpb24oUyl7aWYodGhpcy5lbnRyb3B5PlMpe3ZhciBCPXRoaXMuc2Vla1RpbWVNYXJrKFMpO3RoaXNbZl0ubGVuZ3RoPUIrMX10aGlzLm1hcmtUaW1lKHtlbnRyb3B5OlN9KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZ2xvYmFsRW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5lbnRyb3B5OnRoaXMuZ2xvYmFsVGltZX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbT119LHNldDpmdW5jdGlvbihTKXtTIT09dGhpcy5wbGF5YmFja1JhdGUmJih0aGlzLm1hcmtUaW1lKHtwbGF5YmFja1JhdGU6U30pLHRoaXNbT109Uyx0aGlzLnVwZGF0ZVRpbWVycygpKX19LHtrZXk6InBhdXNlZCIsZ2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO2Zvcih2YXIgUz10aGlzLnBhcmVudDtTOyl7aWYoUy5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO1M9Uy5wYXJlbnR9cmV0dXJuITF9fV0pLER9KCk7ZS5kZWZhdWx0PUx9LGZ1bmN0aW9uKGgsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIHI9dCg3Nyksbj11KHIpLGQ9dCgxMjkpLGc9dShkKTtmdW5jdGlvbiB1KG8pe3JldHVybiBvJiZvLl9fZXNNb2R1bGU/bzp7ZGVmYXVsdDpvfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBvKGMscCl7dmFyIGw9W10seT0hMCx4PSExLGI9dm9pZCAwO3RyeXtmb3IodmFyIEU9KDAsZy5kZWZhdWx0KShjKSx2OyEoeT0odj1FLm5leHQoKSkuZG9uZSkmJihsLnB1c2godi52YWx1ZSksIShwJiZsLmxlbmd0aD09PXApKTt5PSEwKTt9Y2F0Y2goTSl7eD0hMCxiPU19ZmluYWxseXt0cnl7IXkmJkUucmV0dXJuJiZFLnJldHVybigpfWZpbmFsbHl7aWYoeCl0aHJvdyBifX1yZXR1cm4gbH1yZXR1cm4gZnVuY3Rpb24oYyxwKXtpZihBcnJheS5pc0FycmF5KGMpKXJldHVybiBjO2lmKCgwLG4uZGVmYXVsdCkoT2JqZWN0KGMpKSlyZXR1cm4gbyhjLHApO3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UiKX19KCl9LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCg3OCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDc5KSx0KDEyNSksaC5leHBvcnRzPXQoMTI3KX0sZnVuY3Rpb24oaCxlLHQpe3QoODApO2Zvcih2YXIgcj10KDkxKSxuPXQoOTUpLGQ9dCg4MyksZz10KDEyMikoInRvU3RyaW5nVGFnIiksdT0iQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCxET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LE1lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QiLnNwbGl0KCIsIiksbz0wO288dS5sZW5ndGg7bysrKXt2YXIgYz11W29dLHA9cltjXSxsPXAmJnAucHJvdG90eXBlO2wmJiFsW2ddJiZuKGwsZyxjKSxkW2NdPWQuQXJyYXl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4MSksbj10KDgyKSxkPXQoODMpLGc9dCg4NCk7aC5leHBvcnRzPXQoODgpKEFycmF5LCJBcnJheSIsZnVuY3Rpb24odSxvKXt0aGlzLl90PWcodSksdGhpcy5faT0wLHRoaXMuX2s9b30sZnVuY3Rpb24oKXt2YXIgdT10aGlzLl90LG89dGhpcy5fayxjPXRoaXMuX2krKztyZXR1cm4hdXx8Yz49dS5sZW5ndGg/KHRoaXMuX3Q9dm9pZCAwLG4oMSkpOm89PSJrZXlzIj9uKDAsYyk6bz09InZhbHVlcyI/bigwLHVbY10pOm4oMCxbYyx1W2NdXSl9LCJ2YWx1ZXMiKSxkLkFyZ3VtZW50cz1kLkFycmF5LHIoImtleXMiKSxyKCJ2YWx1ZXMiKSxyKCJlbnRyaWVzIil9LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKCl7fX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCxyKXtyZXR1cm57dmFsdWU6cixkb25lOiEhdH19fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz17fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoODUpLG49dCg4Nyk7aC5leHBvcnRzPWZ1bmN0aW9uKGQpe3JldHVybiByKG4oZCkpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoODYpO2guZXhwb3J0cz1PYmplY3QoInoiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKT9PYmplY3Q6ZnVuY3Rpb24obil7cmV0dXJuIHIobik9PSJTdHJpbmciP24uc3BsaXQoIiIpOk9iamVjdChuKX19LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9e30udG9TdHJpbmc7aC5leHBvcnRzPWZ1bmN0aW9uKHIpe3JldHVybiB0LmNhbGwocikuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0PT1udWxsKXRocm93IFR5cGVFcnJvcigiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gICIrdCk7cmV0dXJuIHR9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4OSksbj10KDkwKSxkPXQoMTA2KSxnPXQoOTUpLHU9dCg4Myksbz10KDEwNyksYz10KDEyMSkscD10KDEyMyksbD10KDEyMikoIml0ZXJhdG9yIikseT0hKFtdLmtleXMmJiJuZXh0ImluW10ua2V5cygpKSx4PSJAQGl0ZXJhdG9yIixiPSJrZXlzIixFPSJ2YWx1ZXMiLHY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307aC5leHBvcnRzPWZ1bmN0aW9uKE0saSxhLHMsZixPLEEpe28oYSxpLHMpO3ZhciBSPWZ1bmN0aW9uKFUpe2lmKCF5JiZVIGluIEQpcmV0dXJuIERbVV07c3dpdGNoKFUpe2Nhc2UgYjpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEodGhpcyxVKX07Y2FzZSBFOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgYSh0aGlzLFUpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEodGhpcyxVKX19LEk9aSsiIEl0ZXJhdG9yIixQPWY9PUUsTD0hMSxEPU0ucHJvdG90eXBlLEM9RFtsXXx8RFt4XXx8ZiYmRFtmXSxTPUN8fFIoZiksQj1mP1A/UigiZW50cmllcyIpOlM6dm9pZCAwLHc9aT09IkFycmF5IiYmRC5lbnRyaWVzfHxDLEgsWixxO2lmKHcmJihxPXAody5jYWxsKG5ldyBNKSkscSE9PU9iamVjdC5wcm90b3R5cGUmJnEubmV4dCYmKGMocSxJLCEwKSwhciYmdHlwZW9mIHFbbF0hPSJmdW5jdGlvbiImJmcocSxsLHYpKSksUCYmQyYmQy5uYW1lIT09RSYmKEw9ITAsUz1mdW5jdGlvbigpe3JldHVybiBDLmNhbGwodGhpcyl9KSwoIXJ8fEEpJiYoeXx8THx8IURbbF0pJiZnKEQsbCxTKSx1W2ldPVMsdVtJXT12LGYpaWYoSD17dmFsdWVzOlA/UzpSKEUpLGtleXM6Tz9TOlIoYiksZW50cmllczpCfSxBKWZvcihaIGluIEgpWiBpbiBEfHxkKEQsWixIW1pdKTtlbHNlIG4obi5QK24uRiooeXx8TCksaSxIKTtyZXR1cm4gSH19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPSEwfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MSksbj10KDkyKSxkPXQoOTMpLGc9dCg5NSksdT10KDEwNSksbz0icHJvdG90eXBlIixjPWZ1bmN0aW9uKHAsbCx5KXt2YXIgeD1wJmMuRixiPXAmYy5HLEU9cCZjLlMsdj1wJmMuUCxNPXAmYy5CLGk9cCZjLlcsYT1iP246bltsXXx8KG5bbF09e30pLHM9YVtvXSxmPWI/cjpFP3JbbF06KHJbbF18fHt9KVtvXSxPLEEsUjtiJiYoeT1sKTtmb3IoTyBpbiB5KUE9IXgmJmYmJmZbT10hPT12b2lkIDAsIShBJiZ1KGEsTykpJiYoUj1BP2ZbT106eVtPXSxhW09dPWImJnR5cGVvZiBmW09dIT0iZnVuY3Rpb24iP3lbT106TSYmQT9kKFIscik6aSYmZltPXT09Uj9mdW5jdGlvbihJKXt2YXIgUD1mdW5jdGlvbihMLEQsQyl7aWYodGhpcyBpbnN0YW5jZW9mIEkpe3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyBJO2Nhc2UgMTpyZXR1cm4gbmV3IEkoTCk7Y2FzZSAyOnJldHVybiBuZXcgSShMLEQpfXJldHVybiBuZXcgSShMLEQsQyl9cmV0dXJuIEkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtyZXR1cm4gUFtvXT1JW29dLFB9KFIpOnYmJnR5cGVvZiBSPT0iZnVuY3Rpb24iP2QoRnVuY3Rpb24uY2FsbCxSKTpSLHYmJigoYS52aXJ0dWFsfHwoYS52aXJ0dWFsPXt9KSlbT109UixwJmMuUiYmcyYmIXNbT10mJmcocyxPLFIpKSl9O2MuRj0xLGMuRz0yLGMuUz00LGMuUD04LGMuQj0xNixjLlc9MzIsYy5VPTY0LGMuUj0xMjgsaC5leHBvcnRzPWN9LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9aC5leHBvcnRzPXR5cGVvZiB3aW5kb3c8InUiJiZ3aW5kb3cuTWF0aD09TWF0aD93aW5kb3c6dHlwZW9mIHNlbGY8InUiJiZzZWxmLk1hdGg9PU1hdGg/c2VsZjpGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpO3R5cGVvZiBfX2c9PSJudW1iZXIiJiYoX19nPXQpfSxmdW5jdGlvbihoLGUpe3ZhciB0PWguZXhwb3J0cz17dmVyc2lvbjoiMi42LjExIn07dHlwZW9mIF9fZT09Im51bWJlciImJihfX2U9dCl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk0KTtoLmV4cG9ydHM9ZnVuY3Rpb24obixkLGcpe2lmKHIobiksZD09PXZvaWQgMClyZXR1cm4gbjtzd2l0Y2goZyl7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih1KXtyZXR1cm4gbi5jYWxsKGQsdSl9O2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24odSxvKXtyZXR1cm4gbi5jYWxsKGQsdSxvKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbih1LG8sYyl7cmV0dXJuIG4uY2FsbChkLHUsbyxjKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG4uYXBwbHkoZCxhcmd1bWVudHMpfX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHR5cGVvZiB0IT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcih0KyIgaXMgbm90IGEgZnVuY3Rpb24hIik7cmV0dXJuIHR9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Niksbj10KDEwNCk7aC5leHBvcnRzPXQoMTAwKT9mdW5jdGlvbihkLGcsdSl7cmV0dXJuIHIuZihkLGcsbigxLHUpKX06ZnVuY3Rpb24oZCxnLHUpe3JldHVybiBkW2ddPXUsZH19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk3KSxuPXQoOTkpLGQ9dCgxMDMpLGc9T2JqZWN0LmRlZmluZVByb3BlcnR5O2UuZj10KDEwMCk/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKG8sYyxwKXtpZihyKG8pLGM9ZChjLCEwKSxyKHApLG4pdHJ5e3JldHVybiBnKG8sYyxwKX1jYXRjaHt9aWYoImdldCJpbiBwfHwic2V0ImluIHApdGhyb3cgVHlwZUVycm9yKCJBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEiKTtyZXR1cm4idmFsdWUiaW4gcCYmKG9bY109cC52YWx1ZSksb319LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk4KTtoLmV4cG9ydHM9ZnVuY3Rpb24obil7aWYoIXIobikpdGhyb3cgVHlwZUVycm9yKG4rIiBpcyBub3QgYW4gb2JqZWN0ISIpO3JldHVybiBufX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ib2JqZWN0Ij90IT09bnVsbDp0eXBlb2YgdD09ImZ1bmN0aW9uIn19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9IXQoMTAwKSYmIXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCgxMDIpKCJkaXYiKSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmEhPTd9KX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz0hdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmEhPTd9KX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhdCgpfWNhdGNoe3JldHVybiEwfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk4KSxuPXQoOTEpLmRvY3VtZW50LGQ9cihuKSYmcihuLmNyZWF0ZUVsZW1lbnQpO2guZXhwb3J0cz1mdW5jdGlvbihnKXtyZXR1cm4gZD9uLmNyZWF0ZUVsZW1lbnQoZyk6e319fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5OCk7aC5leHBvcnRzPWZ1bmN0aW9uKG4sZCl7aWYoIXIobikpcmV0dXJuIG47dmFyIGcsdTtpZihkJiZ0eXBlb2YoZz1uLnRvU3RyaW5nKT09ImZ1bmN0aW9uIiYmIXIodT1nLmNhbGwobikpfHx0eXBlb2YoZz1uLnZhbHVlT2YpPT0iZnVuY3Rpb24iJiYhcih1PWcuY2FsbChuKSl8fCFkJiZ0eXBlb2YoZz1uLnRvU3RyaW5nKT09ImZ1bmN0aW9uIiYmIXIodT1nLmNhbGwobikpKXJldHVybiB1O3Rocm93IFR5cGVFcnJvcigiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlIil9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1mdW5jdGlvbih0LHIpe3JldHVybntlbnVtZXJhYmxlOiEodCYxKSxjb25maWd1cmFibGU6ISh0JjIpLHdyaXRhYmxlOiEodCY0KSx2YWx1ZTpyfX19LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9e30uaGFzT3duUHJvcGVydHk7aC5leHBvcnRzPWZ1bmN0aW9uKHIsbil7cmV0dXJuIHQuY2FsbChyLG4pfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz10KDk1KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTA4KSxuPXQoMTA0KSxkPXQoMTIxKSxnPXt9O3QoOTUpKGcsdCgxMjIpKCJpdGVyYXRvciIpLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxoLmV4cG9ydHM9ZnVuY3Rpb24odSxvLGMpe3UucHJvdG90eXBlPXIoZyx7bmV4dDpuKDEsYyl9KSxkKHUsbysiIEl0ZXJhdG9yIil9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nyksbj10KDEwOSksZD10KDExOSksZz10KDExNikoIklFX1BST1RPIiksdT1mdW5jdGlvbigpe30sbz0icHJvdG90eXBlIixjPWZ1bmN0aW9uKCl7dmFyIHA9dCgxMDIpKCJpZnJhbWUiKSxsPWQubGVuZ3RoLHk9IjwiLHg9Ij4iLGI7Zm9yKHAuc3R5bGUuZGlzcGxheT0ibm9uZSIsdCgxMjApLmFwcGVuZENoaWxkKHApLHAuc3JjPSJqYXZhc2NyaXB0OiIsYj1wLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsYi5vcGVuKCksYi53cml0ZSh5KyJzY3JpcHQiK3grImRvY3VtZW50LkY9T2JqZWN0Iit5KyIvc2NyaXB0Iit4KSxiLmNsb3NlKCksYz1iLkY7bC0tOylkZWxldGUgY1tvXVtkW2xdXTtyZXR1cm4gYygpfTtoLmV4cG9ydHM9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24obCx5KXt2YXIgeDtyZXR1cm4gbCE9PW51bGw/KHVbb109cihsKSx4PW5ldyB1LHVbb109bnVsbCx4W2ddPWwpOng9YygpLHk9PT12b2lkIDA/eDpuKHgseSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Niksbj10KDk3KSxkPXQoMTEwKTtoLmV4cG9ydHM9dCgxMDApP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzOmZ1bmN0aW9uKHUsbyl7bih1KTtmb3IodmFyIGM9ZChvKSxwPWMubGVuZ3RoLGw9MCx5O3A+bDspci5mKHUseT1jW2wrK10sb1t5XSk7cmV0dXJuIHV9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMTEpLG49dCgxMTkpO2guZXhwb3J0cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZyl7cmV0dXJuIHIoZyxuKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEwNSksbj10KDg0KSxkPXQoMTEyKSghMSksZz10KDExNikoIklFX1BST1RPIik7aC5leHBvcnRzPWZ1bmN0aW9uKHUsbyl7dmFyIGM9bih1KSxwPTAsbD1bXSx5O2Zvcih5IGluIGMpeSE9ZyYmcihjLHkpJiZsLnB1c2goeSk7Zm9yKDtvLmxlbmd0aD5wOylyKGMseT1vW3ArK10pJiYofmQobCx5KXx8bC5wdXNoKHkpKTtyZXR1cm4gbH19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg0KSxuPXQoMTEzKSxkPXQoMTE1KTtoLmV4cG9ydHM9ZnVuY3Rpb24oZyl7cmV0dXJuIGZ1bmN0aW9uKHUsbyxjKXt2YXIgcD1yKHUpLGw9bihwLmxlbmd0aCkseT1kKGMsbCkseDtpZihnJiZvIT1vKXtmb3IoO2w+eTspaWYoeD1wW3krK10seCE9eClyZXR1cm4hMH1lbHNlIGZvcig7bD55O3krKylpZigoZ3x8eSBpbiBwKSYmcFt5XT09PW8pcmV0dXJuIGd8fHl8fDA7cmV0dXJuIWcmJi0xfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExNCksbj1NYXRoLm1pbjtoLmV4cG9ydHM9ZnVuY3Rpb24oZCl7cmV0dXJuIGQ+MD9uKHIoZCksOTAwNzE5OTI1NDc0MDk5MSk6MH19LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9TWF0aC5jZWlsLHI9TWF0aC5mbG9vcjtoLmV4cG9ydHM9ZnVuY3Rpb24obil7cmV0dXJuIGlzTmFOKG49K24pPzA6KG4+MD9yOnQpKG4pfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTE0KSxuPU1hdGgubWF4LGQ9TWF0aC5taW47aC5leHBvcnRzPWZ1bmN0aW9uKGcsdSl7cmV0dXJuIGc9cihnKSxnPDA/bihnK3UsMCk6ZChnLHUpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTE3KSgia2V5cyIpLG49dCgxMTgpO2guZXhwb3J0cz1mdW5jdGlvbihkKXtyZXR1cm4gcltkXXx8KHJbZF09bihkKSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Miksbj10KDkxKSxkPSJfX2NvcmUtanNfc2hhcmVkX18iLGc9bltkXXx8KG5bZF09e30pOyhoLmV4cG9ydHM9ZnVuY3Rpb24odSxvKXtyZXR1cm4gZ1t1XXx8KGdbdV09byE9PXZvaWQgMD9vOnt9KX0pKCJ2ZXJzaW9ucyIsW10pLnB1c2goe3ZlcnNpb246ci52ZXJzaW9uLG1vZGU6dCg4OSk/InB1cmUiOiJnbG9iYWwiLGNvcHlyaWdodDoiwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSJ9KX0sZnVuY3Rpb24oaCxlKXt2YXIgdD0wLHI9TWF0aC5yYW5kb20oKTtoLmV4cG9ydHM9ZnVuY3Rpb24obil7cmV0dXJuIlN5bWJvbCgiLmNvbmNhdChuPT09dm9pZCAwPyIiOm4sIilfIiwoKyt0K3IpLnRvU3RyaW5nKDM2KSl9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz0iY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mIi5zcGxpdCgiLCIpfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MSkuZG9jdW1lbnQ7aC5leHBvcnRzPXImJnIuZG9jdW1lbnRFbGVtZW50fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5NikuZixuPXQoMTA1KSxkPXQoMTIyKSgidG9TdHJpbmdUYWciKTtoLmV4cG9ydHM9ZnVuY3Rpb24oZyx1LG8pe2cmJiFuKGc9bz9nOmcucHJvdG90eXBlLGQpJiZyKGcsZCx7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnV9KX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExNykoIndrcyIpLG49dCgxMTgpLGQ9dCg5MSkuU3ltYm9sLGc9dHlwZW9mIGQ9PSJmdW5jdGlvbiIsdT1oLmV4cG9ydHM9ZnVuY3Rpb24obyl7cmV0dXJuIHJbb118fChyW29dPWcmJmRbb118fChnP2Q6bikoIlN5bWJvbC4iK28pKX07dS5zdG9yZT1yfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMDUpLG49dCgxMjQpLGQ9dCgxMTYpKCJJRV9QUk9UTyIpLGc9T2JqZWN0LnByb3RvdHlwZTtoLmV4cG9ydHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHxmdW5jdGlvbih1KXtyZXR1cm4gdT1uKHUpLHIodSxkKT91W2RdOnR5cGVvZiB1LmNvbnN0cnVjdG9yPT0iZnVuY3Rpb24iJiZ1IGluc3RhbmNlb2YgdS5jb25zdHJ1Y3Rvcj91LmNvbnN0cnVjdG9yLnByb3RvdHlwZTp1IGluc3RhbmNlb2YgT2JqZWN0P2c6bnVsbH19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg3KTtoLmV4cG9ydHM9ZnVuY3Rpb24obil7cmV0dXJuIE9iamVjdChyKG4pKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEyNikoITApO3QoODgpKFN0cmluZywiU3RyaW5nIixmdW5jdGlvbihuKXt0aGlzLl90PVN0cmluZyhuKSx0aGlzLl9pPTB9LGZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fdCxkPXRoaXMuX2ksZztyZXR1cm4gZD49bi5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfTooZz1yKG4sZCksdGhpcy5faSs9Zy5sZW5ndGgse3ZhbHVlOmcsZG9uZTohMX0pfSl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExNCksbj10KDg3KTtoLmV4cG9ydHM9ZnVuY3Rpb24oZCl7cmV0dXJuIGZ1bmN0aW9uKGcsdSl7dmFyIG89U3RyaW5nKG4oZykpLGM9cih1KSxwPW8ubGVuZ3RoLGwseTtyZXR1cm4gYzwwfHxjPj1wP2Q/IiI6dm9pZCAwOihsPW8uY2hhckNvZGVBdChjKSxsPDU1Mjk2fHxsPjU2MzE5fHxjKzE9PT1wfHwoeT1vLmNoYXJDb2RlQXQoYysxKSk8NTYzMjB8fHk+NTczNDM/ZD9vLmNoYXJBdChjKTpsOmQ/by5zbGljZShjLGMrMik6KGwtNTUyOTY8PDEwKSsoeS01NjMyMCkrNjU1MzYpfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEyOCksbj10KDEyMikoIml0ZXJhdG9yIiksZD10KDgzKTtoLmV4cG9ydHM9dCg5MikuaXNJdGVyYWJsZT1mdW5jdGlvbihnKXt2YXIgdT1PYmplY3QoZyk7cmV0dXJuIHVbbl0hPT12b2lkIDB8fCJAQGl0ZXJhdG9yImluIHV8fGQuaGFzT3duUHJvcGVydHkocih1KSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4Niksbj10KDEyMikoInRvU3RyaW5nVGFnIiksZD1yKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSk9PSJBcmd1bWVudHMiLGc9ZnVuY3Rpb24odSxvKXt0cnl7cmV0dXJuIHVbb119Y2F0Y2h7fX07aC5leHBvcnRzPWZ1bmN0aW9uKHUpe3ZhciBvLGMscDtyZXR1cm4gdT09PXZvaWQgMD8iVW5kZWZpbmVkIjp1PT09bnVsbD8iTnVsbCI6dHlwZW9mKGM9ZyhvPU9iamVjdCh1KSxuKSk9PSJzdHJpbmciP2M6ZD9yKG8pOihwPXIobykpPT0iT2JqZWN0IiYmdHlwZW9mIG8uY2FsbGVlPT0iZnVuY3Rpb24iPyJBcmd1bWVudHMiOnB9fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMTMwKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoNzkpLHQoMTI1KSxoLmV4cG9ydHM9dCgxMzEpfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nyksbj10KDEzMik7aC5leHBvcnRzPXQoOTIpLmdldEl0ZXJhdG9yPWZ1bmN0aW9uKGQpe3ZhciBnPW4oZCk7aWYodHlwZW9mIGchPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKGQrIiBpcyBub3QgaXRlcmFibGUhIik7cmV0dXJuIHIoZy5jYWxsKGQpKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEyOCksbj10KDEyMikoIml0ZXJhdG9yIiksZD10KDgzKTtoLmV4cG9ydHM9dCg5MikuZ2V0SXRlcmF0b3JNZXRob2Q9ZnVuY3Rpb24oZyl7aWYoZyE9bnVsbClyZXR1cm4gZ1tuXXx8Z1siQEBpdGVyYXRvciJdfHxkW3IoZyldfX0sZnVuY3Rpb24oaCxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgcj10KDEzNCksbj1kKHIpO2Z1bmN0aW9uIGQoZyl7cmV0dXJuIGcmJmcuX19lc01vZHVsZT9nOntkZWZhdWx0Omd9fWUuZGVmYXVsdD1mdW5jdGlvbihnKXtpZihBcnJheS5pc0FycmF5KGcpKXtmb3IodmFyIHU9MCxvPUFycmF5KGcubGVuZ3RoKTt1PGcubGVuZ3RoO3UrKylvW3VdPWdbdV07cmV0dXJuIG99ZWxzZSByZXR1cm4oMCxuLmRlZmF1bHQpKGcpfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17ZGVmYXVsdDp0KDEzNSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDEyNSksdCgxMzYpLGguZXhwb3J0cz10KDkyKS5BcnJheS5mcm9tfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Myksbj10KDkwKSxkPXQoMTI0KSxnPXQoMTM3KSx1PXQoMTM4KSxvPXQoMTEzKSxjPXQoMTM5KSxwPXQoMTMyKTtuKG4uUytuLkYqIXQoMTQwKShmdW5jdGlvbihsKXtBcnJheS5mcm9tKGwpfSksIkFycmF5Iix7ZnJvbTpmdW5jdGlvbih5KXt2YXIgeD1kKHkpLGI9dHlwZW9mIHRoaXM9PSJmdW5jdGlvbiI/dGhpczpBcnJheSxFPWFyZ3VtZW50cy5sZW5ndGgsdj1FPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxNPXYhPT12b2lkIDAsaT0wLGE9cCh4KSxzLGYsTyxBO2lmKE0mJih2PXIodixFPjI/YXJndW1lbnRzWzJdOnZvaWQgMCwyKSksYSE9bnVsbCYmIShiPT1BcnJheSYmdShhKSkpZm9yKEE9YS5jYWxsKHgpLGY9bmV3IGI7IShPPUEubmV4dCgpKS5kb25lO2krKyljKGYsaSxNP2coQSx2LFtPLnZhbHVlLGldLCEwKTpPLnZhbHVlKTtlbHNlIGZvcihzPW8oeC5sZW5ndGgpLGY9bmV3IGIocyk7cz5pO2krKyljKGYsaSxNP3YoeFtpXSxpKTp4W2ldKTtyZXR1cm4gZi5sZW5ndGg9aSxmfX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nyk7aC5leHBvcnRzPWZ1bmN0aW9uKG4sZCxnLHUpe3RyeXtyZXR1cm4gdT9kKHIoZylbMF0sZ1sxXSk6ZChnKX1jYXRjaChjKXt2YXIgbz1uLnJldHVybjt0aHJvdyBvIT09dm9pZCAwJiZyKG8uY2FsbChuKSksY319fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4Myksbj10KDEyMikoIml0ZXJhdG9yIiksZD1BcnJheS5wcm90b3R5cGU7aC5leHBvcnRzPWZ1bmN0aW9uKGcpe3JldHVybiBnIT09dm9pZCAwJiYoci5BcnJheT09PWd8fGRbbl09PT1nKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk2KSxuPXQoMTA0KTtoLmV4cG9ydHM9ZnVuY3Rpb24oZCxnLHUpe2cgaW4gZD9yLmYoZCxnLG4oMCx1KSk6ZFtnXT11fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTIyKSgiaXRlcmF0b3IiKSxuPSExO3RyeXt2YXIgZD1bN11bcl0oKTtkLnJldHVybj1mdW5jdGlvbigpe249ITB9LEFycmF5LmZyb20oZCxmdW5jdGlvbigpe3Rocm93IDJ9KX1jYXRjaHt9aC5leHBvcnRzPWZ1bmN0aW9uKGcsdSl7aWYoIXUmJiFuKXJldHVybiExO3ZhciBvPSExO3RyeXt2YXIgYz1bN10scD1jW3JdKCk7cC5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6bz0hMH19LGNbcl09ZnVuY3Rpb24oKXtyZXR1cm4gcH0sZyhjKX1jYXRjaHt9cmV0dXJuIG99fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMTQyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxNDQpLHQoMTU3KSx0KDE2MCksdCgxNjIpLGguZXhwb3J0cz10KDkyKS5NYXB9LGZ1bmN0aW9uKGgsZSl7fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxNDUpLG49dCgxNTEpLGQ9Ik1hcCI7aC5leHBvcnRzPXQoMTUyKShkLGZ1bmN0aW9uKGcpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBnKHRoaXMsYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApfX0se2dldDpmdW5jdGlvbih1KXt2YXIgbz1yLmdldEVudHJ5KG4odGhpcyxkKSx1KTtyZXR1cm4gbyYmby52fSxzZXQ6ZnVuY3Rpb24odSxvKXtyZXR1cm4gci5kZWYobih0aGlzLGQpLHU9PT0wPzA6dSxvKX19LHIsITApfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5NikuZixuPXQoMTA4KSxkPXQoMTQ2KSxnPXQoOTMpLHU9dCgxNDcpLG89dCgxNDgpLGM9dCg4OCkscD10KDgyKSxsPXQoMTQ5KSx5PXQoMTAwKSx4PXQoMTUwKS5mYXN0S2V5LGI9dCgxNTEpLEU9eT8iX3MiOiJzaXplIix2PWZ1bmN0aW9uKE0saSl7dmFyIGE9eChpKSxzO2lmKGEhPT0iRiIpcmV0dXJuIE0uX2lbYV07Zm9yKHM9TS5fZjtzO3M9cy5uKWlmKHMuaz09aSlyZXR1cm4gc307aC5leHBvcnRzPXtnZXRDb25zdHJ1Y3RvcjpmdW5jdGlvbihNLGksYSxzKXt2YXIgZj1NKGZ1bmN0aW9uKE8sQSl7dShPLGYsaSwiX2kiKSxPLl90PWksTy5faT1uKG51bGwpLE8uX2Y9dm9pZCAwLE8uX2w9dm9pZCAwLE9bRV09MCxBIT1udWxsJiZvKEEsYSxPW3NdLE8pfSk7cmV0dXJuIGQoZi5wcm90b3R5cGUse2NsZWFyOmZ1bmN0aW9uKCl7Zm9yKHZhciBBPWIodGhpcyxpKSxSPUEuX2ksST1BLl9mO0k7ST1JLm4pSS5yPSEwLEkucCYmKEkucD1JLnAubj12b2lkIDApLGRlbGV0ZSBSW0kuaV07QS5fZj1BLl9sPXZvaWQgMCxBW0VdPTB9LGRlbGV0ZTpmdW5jdGlvbihPKXt2YXIgQT1iKHRoaXMsaSksUj12KEEsTyk7aWYoUil7dmFyIEk9Ui5uLFA9Ui5wO2RlbGV0ZSBBLl9pW1IuaV0sUi5yPSEwLFAmJihQLm49SSksSSYmKEkucD1QKSxBLl9mPT1SJiYoQS5fZj1JKSxBLl9sPT1SJiYoQS5fbD1QKSxBW0VdLS19cmV0dXJuISFSfSxmb3JFYWNoOmZ1bmN0aW9uKEEpe2IodGhpcyxpKTtmb3IodmFyIFI9ZyhBLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLDMpLEk7ST1JP0kubjp0aGlzLl9mOylmb3IoUihJLnYsSS5rLHRoaXMpO0kmJkkucjspST1JLnB9LGhhczpmdW5jdGlvbihBKXtyZXR1cm4hIXYoYih0aGlzLGkpLEEpfX0pLHkmJnIoZi5wcm90b3R5cGUsInNpemUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYih0aGlzLGkpW0VdfX0pLGZ9LGRlZjpmdW5jdGlvbihNLGksYSl7dmFyIHM9dihNLGkpLGYsTztyZXR1cm4gcz9zLnY9YTooTS5fbD1zPXtpOk89eChpLCEwKSxrOmksdjphLHA6Zj1NLl9sLG46dm9pZCAwLHI6ITF9LE0uX2Z8fChNLl9mPXMpLGYmJihmLm49cyksTVtFXSsrLE8hPT0iRiImJihNLl9pW09dPXMpKSxNfSxnZXRFbnRyeTp2LHNldFN0cm9uZzpmdW5jdGlvbihNLGksYSl7YyhNLGksZnVuY3Rpb24ocyxmKXt0aGlzLl90PWIocyxpKSx0aGlzLl9rPWYsdGhpcy5fbD12b2lkIDB9LGZ1bmN0aW9uKCl7Zm9yKHZhciBzPXRoaXMsZj1zLl9rLE89cy5fbDtPJiZPLnI7KU89Ty5wO3JldHVybiFzLl90fHwhKHMuX2w9Tz1PP08ubjpzLl90Ll9mKT8ocy5fdD12b2lkIDAscCgxKSk6Zj09ImtleXMiP3AoMCxPLmspOmY9PSJ2YWx1ZXMiP3AoMCxPLnYpOnAoMCxbTy5rLE8udl0pfSxhPyJlbnRyaWVzIjoidmFsdWVzIiwhYSwhMCksbChpKX19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5NSk7aC5leHBvcnRzPWZ1bmN0aW9uKG4sZCxnKXtmb3IodmFyIHUgaW4gZClnJiZuW3VdP25bdV09ZFt1XTpyKG4sdSxkW3VdKTtyZXR1cm4gbn19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKHQscixuLGQpe2lmKCEodCBpbnN0YW5jZW9mIHIpfHxkIT09dm9pZCAwJiZkIGluIHQpdGhyb3cgVHlwZUVycm9yKG4rIjogaW5jb3JyZWN0IGludm9jYXRpb24hIik7cmV0dXJuIHR9fSxmdW5jdGlvbihoLGwsdCl7dmFyIHI9dCg5Myksbj10KDEzNyksZD10KDEzOCksZz10KDk3KSx1PXQoMTEzKSxvPXQoMTMyKSxjPXt9LHA9e30sbD1oLmV4cG9ydHM9ZnVuY3Rpb24oeSx4LGIsRSx2KXt2YXIgTT12P2Z1bmN0aW9uKCl7cmV0dXJuIHl9Om8oeSksaT1yKGIsRSx4PzI6MSksYT0wLHMsZixPLEE7aWYodHlwZW9mIE0hPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKHkrIiBpcyBub3QgaXRlcmFibGUhIik7aWYoZChNKSl7Zm9yKHM9dSh5Lmxlbmd0aCk7cz5hO2ErKylpZihBPXg/aShnKGY9eVthXSlbMF0sZlsxXSk6aSh5W2FdKSxBPT09Y3x8QT09PXApcmV0dXJuIEF9ZWxzZSBmb3IoTz1NLmNhbGwoeSk7IShmPU8ubmV4dCgpKS5kb25lOylpZihBPW4oTyxpLGYudmFsdWUseCksQT09PWN8fEE9PT1wKXJldHVybiBBfTtsLkJSRUFLPWMsbC5SRVRVUk49cH0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTEpLG49dCg5MiksZD10KDk2KSxnPXQoMTAwKSx1PXQoMTIyKSgic3BlY2llcyIpO2guZXhwb3J0cz1mdW5jdGlvbihvKXt2YXIgYz10eXBlb2YgbltvXT09ImZ1bmN0aW9uIj9uW29dOnJbb107ZyYmYyYmIWNbdV0mJmQuZihjLHUse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExOCkoIm1ldGEiKSxuPXQoOTgpLGQ9dCgxMDUpLGc9dCg5NikuZix1PTAsbz1PYmplY3QuaXNFeHRlbnNpYmxlfHxmdW5jdGlvbigpe3JldHVybiEwfSxjPSF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gbyhPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKX0pLHA9ZnVuY3Rpb24oRSl7ZyhFLHIse3ZhbHVlOntpOiJPIisgKyt1LHc6e319fSl9LGw9ZnVuY3Rpb24oRSx2KXtpZighbihFKSlyZXR1cm4gdHlwZW9mIEU9PSJzeW1ib2wiP0U6KHR5cGVvZiBFPT0ic3RyaW5nIj8iUyI6IlAiKStFO2lmKCFkKEUscikpe2lmKCFvKEUpKXJldHVybiJGIjtpZighdilyZXR1cm4iRSI7cChFKX1yZXR1cm4gRVtyXS5pfSx5PWZ1bmN0aW9uKEUsdil7aWYoIWQoRSxyKSl7aWYoIW8oRSkpcmV0dXJuITA7aWYoIXYpcmV0dXJuITE7cChFKX1yZXR1cm4gRVtyXS53fSx4PWZ1bmN0aW9uKEUpe3JldHVybiBjJiZiLk5FRUQmJm8oRSkmJiFkKEUscikmJnAoRSksRX0sYj1oLmV4cG9ydHM9e0tFWTpyLE5FRUQ6ITEsZmFzdEtleTpsLGdldFdlYWs6eSxvbkZyZWV6ZTp4fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTgpO2guZXhwb3J0cz1mdW5jdGlvbihuLGQpe2lmKCFyKG4pfHxuLl90IT09ZCl0aHJvdyBUeXBlRXJyb3IoIkluY29tcGF0aWJsZSByZWNlaXZlciwgIitkKyIgcmVxdWlyZWQhIik7cmV0dXJuIG59fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MSksbj10KDkwKSxkPXQoMTUwKSxnPXQoMTAxKSx1PXQoOTUpLG89dCgxNDYpLGM9dCgxNDgpLHA9dCgxNDcpLGw9dCg5OCkseT10KDEyMSkseD10KDk2KS5mLGI9dCgxNTMpKDApLEU9dCgxMDApO2guZXhwb3J0cz1mdW5jdGlvbih2LE0saSxhLHMsZil7dmFyIE89clt2XSxBPU8sUj1zPyJzZXQiOiJhZGQiLEk9QSYmQS5wcm90b3R5cGUsUD17fTtyZXR1cm4hRXx8dHlwZW9mIEEhPSJmdW5jdGlvbiJ8fCEoZnx8SS5mb3JFYWNoJiYhZyhmdW5jdGlvbigpe25ldyBBKCkuZW50cmllcygpLm5leHQoKX0pKT8oQT1hLmdldENvbnN0cnVjdG9yKE0sdixzLFIpLG8oQS5wcm90b3R5cGUsaSksZC5ORUVEPSEwKTooQT1NKGZ1bmN0aW9uKEwsRCl7cChMLEEsdiwiX2MiKSxMLl9jPW5ldyBPLEQhPW51bGwmJmMoRCxzLExbUl0sTCl9KSxiKCJhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04iLnNwbGl0KCIsIiksZnVuY3Rpb24oTCl7dmFyIEQ9TD09ImFkZCJ8fEw9PSJzZXQiO0wgaW4gSSYmIShmJiZMPT0iY2xlYXIiKSYmdShBLnByb3RvdHlwZSxMLGZ1bmN0aW9uKEMsUyl7aWYocCh0aGlzLEEsTCksIUQmJmYmJiFsKEMpKXJldHVybiBMPT0iZ2V0Ij92b2lkIDA6ITE7dmFyIEI9dGhpcy5fY1tMXShDPT09MD8wOkMsUyk7cmV0dXJuIEQ/dGhpczpCfSl9KSxmfHx4KEEucHJvdG90eXBlLCJzaXplIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Muc2l6ZX19KSkseShBLHYpLFBbdl09QSxuKG4uRytuLlcrbi5GLFApLGZ8fGEuc2V0U3Ryb25nKEEsdixzKSxBfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTMpLG49dCg4NSksZD10KDEyNCksZz10KDExMyksdT10KDE1NCk7aC5leHBvcnRzPWZ1bmN0aW9uKG8sYyl7dmFyIHA9bz09MSxsPW89PTIseT1vPT0zLHg9bz09NCxiPW89PTYsRT1vPT01fHxiLHY9Y3x8dTtyZXR1cm4gZnVuY3Rpb24oTSxpLGEpe2Zvcih2YXIgcz1kKE0pLGY9bihzKSxPPXIoaSxhLDMpLEE9ZyhmLmxlbmd0aCksUj0wLEk9cD92KE0sQSk6bD92KE0sMCk6dm9pZCAwLFAsTDtBPlI7UisrKWlmKChFfHxSIGluIGYpJiYoUD1mW1JdLEw9TyhQLFIscyksbykpe2lmKHApSVtSXT1MO2Vsc2UgaWYoTClzd2l0Y2gobyl7Y2FzZSAzOnJldHVybiEwO2Nhc2UgNTpyZXR1cm4gUDtjYXNlIDY6cmV0dXJuIFI7Y2FzZSAyOkkucHVzaChQKX1lbHNlIGlmKHgpcmV0dXJuITF9cmV0dXJuIGI/LTE6eXx8eD94Okl9fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTU1KTtoLmV4cG9ydHM9ZnVuY3Rpb24obixkKXtyZXR1cm4gbmV3KHIobikpKGQpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTgpLG49dCgxNTYpLGQ9dCgxMjIpKCJzcGVjaWVzIik7aC5leHBvcnRzPWZ1bmN0aW9uKGcpe3ZhciB1O3JldHVybiBuKGcpJiYodT1nLmNvbnN0cnVjdG9yLHR5cGVvZiB1PT0iZnVuY3Rpb24iJiYodT09PUFycmF5fHxuKHUucHJvdG90eXBlKSkmJih1PXZvaWQgMCkscih1KSYmKHU9dVtkXSx1PT09bnVsbCYmKHU9dm9pZCAwKSkpLHU9PT12b2lkIDA/QXJyYXk6dX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg2KTtoLmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZCl7cmV0dXJuIHIoZCk9PSJBcnJheSJ9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCk7cihyLlArci5SLCJNYXAiLHt0b0pTT046dCgxNTgpKCJNYXAiKX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMjgpLG49dCgxNTkpO2guZXhwb3J0cz1mdW5jdGlvbihkKXtyZXR1cm4gZnVuY3Rpb24oKXtpZihyKHRoaXMpIT1kKXRocm93IFR5cGVFcnJvcihkKyIjdG9KU09OIGlzbid0IGdlbmVyaWMiKTtyZXR1cm4gbih0aGlzKX19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxNDgpO2guZXhwb3J0cz1mdW5jdGlvbihuLGQpe3ZhciBnPVtdO3JldHVybiByKG4sITEsZy5wdXNoLGcsZCksZ319LGZ1bmN0aW9uKGgsZSx0KXt0KDE2MSkoIk1hcCIpfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCk7aC5leHBvcnRzPWZ1bmN0aW9uKG4pe3Ioci5TLG4se29mOmZ1bmN0aW9uKCl7Zm9yKHZhciBnPWFyZ3VtZW50cy5sZW5ndGgsdT1uZXcgQXJyYXkoZyk7Zy0tOyl1W2ddPWFyZ3VtZW50c1tnXTtyZXR1cm4gbmV3IHRoaXModSl9fSl9fSxmdW5jdGlvbihoLGUsdCl7dCgxNjMpKCJNYXAiKX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApLG49dCg5NCksZD10KDkzKSxnPXQoMTQ4KTtoLmV4cG9ydHM9ZnVuY3Rpb24odSl7cihyLlMsdSx7ZnJvbTpmdW5jdGlvbihjKXt2YXIgcD1hcmd1bWVudHNbMV0sbCx5LHgsYjtyZXR1cm4gbih0aGlzKSxsPXAhPT12b2lkIDAsbCYmbihwKSxjPT1udWxsP25ldyB0aGlzOih5PVtdLGw/KHg9MCxiPWQocCxhcmd1bWVudHNbMl0sMiksZyhjLCExLGZ1bmN0aW9uKEUpe3kucHVzaChiKEUseCsrKSl9KSk6ZyhjLCExLHkucHVzaCx5KSxuZXcgdGhpcyh5KSl9fSl9fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMTY1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTY2KSxoLmV4cG9ydHM9dCg5MikuT2JqZWN0LmFzc2lnbn0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApO3Ioci5TK3IuRiwiT2JqZWN0Iix7YXNzaWduOnQoMTY3KX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMDApLG49dCgxMTApLGQ9dCgxNjgpLGc9dCgxNjkpLHU9dCgxMjQpLG89dCg4NSksYz1PYmplY3QuYXNzaWduO2guZXhwb3J0cz0hY3x8dCgxMDEpKGZ1bmN0aW9uKCl7dmFyIHA9e30sbD17fSx5PVN5bWJvbCgpLHg9ImFiY2RlZmdoaWprbG1ub3BxcnN0IjtyZXR1cm4gcFt5XT03LHguc3BsaXQoIiIpLmZvckVhY2goZnVuY3Rpb24oYil7bFtiXT1ifSksYyh7fSxwKVt5XSE9N3x8T2JqZWN0LmtleXMoYyh7fSxsKSkuam9pbigiIikhPXh9KT9mdW5jdGlvbihsLHkpe2Zvcih2YXIgeD11KGwpLGI9YXJndW1lbnRzLmxlbmd0aCxFPTEsdj1kLmYsTT1nLmY7Yj5FOylmb3IodmFyIGk9byhhcmd1bWVudHNbRSsrXSksYT12P24oaSkuY29uY2F0KHYoaSkpOm4oaSkscz1hLmxlbmd0aCxmPTAsTztzPmY7KU89YVtmKytdLCghcnx8TS5jYWxsKGksTykpJiYoeFtPXT1pW09dKTtyZXR1cm4geH06Y30sZnVuY3Rpb24oaCxlKXtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc30sZnVuY3Rpb24oaCxlKXtlLmY9e30ucHJvcGVydHlJc0VudW1lcmFibGV9LGZ1bmN0aW9uKGgsZSx0KXtlLl9fZXNNb2R1bGU9ITAsZS5kZWZhdWx0PWZ1bmN0aW9uKHIsbil7aWYoIShyIGluc3RhbmNlb2YgbikpdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIil9fSxmdW5jdGlvbihoLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPXQoMTcyKSxuPWQocik7ZnVuY3Rpb24gZChnKXtyZXR1cm4gZyYmZy5fX2VzTW9kdWxlP2c6e2RlZmF1bHQ6Z319ZS5kZWZhdWx0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyh1LG8pe2Zvcih2YXIgYz0wO2M8by5sZW5ndGg7YysrKXt2YXIgcD1vW2NdO3AuZW51bWVyYWJsZT1wLmVudW1lcmFibGV8fCExLHAuY29uZmlndXJhYmxlPSEwLCJ2YWx1ZSJpbiBwJiYocC53cml0YWJsZT0hMCksKDAsbi5kZWZhdWx0KSh1LHAua2V5LHApfX1yZXR1cm4gZnVuY3Rpb24odSxvLGMpe3JldHVybiBvJiZnKHUucHJvdG90eXBlLG8pLGMmJmcodSxjKSx1fX0oKX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17ZGVmYXVsdDp0KDE3MyksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDE3NCk7dmFyIHI9dCg5MikuT2JqZWN0O2guZXhwb3J0cz1mdW5jdGlvbihkLGcsdSl7cmV0dXJuIHIuZGVmaW5lUHJvcGVydHkoZCxnLHUpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApO3Ioci5TK3IuRiohdCgxMDApLCJPYmplY3QiLHtkZWZpbmVQcm9wZXJ0eTp0KDk2KS5mfSl9LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNzYpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihoLGUsdCl7dCgxNzcpLHQoMTQzKSx0KDE4NCksdCgxODUpLGguZXhwb3J0cz10KDkyKS5TeW1ib2x9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkxKSxuPXQoMTA1KSxkPXQoMTAwKSxnPXQoOTApLHU9dCgxMDYpLG89dCgxNTApLktFWSxjPXQoMTAxKSxwPXQoMTE3KSxsPXQoMTIxKSx5PXQoMTE4KSx4PXQoMTIyKSxiPXQoMTc4KSxFPXQoMTc5KSx2PXQoMTgwKSxNPXQoMTU2KSxpPXQoOTcpLGE9dCg5OCkscz10KDEyNCksZj10KDg0KSxPPXQoMTAzKSxBPXQoMTA0KSxSPXQoMTA4KSxJPXQoMTgxKSxQPXQoMTgzKSxMPXQoMTY4KSxEPXQoOTYpLEM9dCgxMTApLFM9UC5mLEI9RC5mLHc9SS5mLEg9ci5TeW1ib2wsWj1yLkpTT04scT1aJiZaLnN0cmluZ2lmeSxVPSJwcm90b3R5cGUiLEc9eCgiX2hpZGRlbiIpLEo9eCgidG9QcmltaXRpdmUiKSx0dD17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxfPXAoInN5bWJvbC1yZWdpc3RyeSIpLHN0PXAoInN5bWJvbHMiKSxrPXAoIm9wLXN5bWJvbHMiKSxodD1PYmplY3RbVV0sZnQ9dHlwZW9mIEg9PSJmdW5jdGlvbiImJiEhTC5mLFc9ci5RT2JqZWN0LEY9IVd8fCFXW1VdfHwhV1tVXS5maW5kQ2hpbGQsVj1kJiZjKGZ1bmN0aW9uKCl7cmV0dXJuIFIoQih7fSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiBCKHRoaXMsImEiLHt2YWx1ZTo3fSkuYX19KSkuYSE9N30pP2Z1bmN0aW9uKGl0LG50LGF0KXt2YXIgZHQ9UyhodCxudCk7ZHQmJmRlbGV0ZSBodFtudF0sQihpdCxudCxhdCksZHQmJml0IT09aHQmJkIoaHQsbnQsZHQpfTpCLFg9ZnVuY3Rpb24oaXQpe3ZhciBudD1zdFtpdF09UihIW1VdKTtyZXR1cm4gbnQuX2s9aXQsbnR9LGo9ZnQmJnR5cGVvZiBILml0ZXJhdG9yPT0ic3ltYm9sIj9mdW5jdGlvbihpdCl7cmV0dXJuIHR5cGVvZiBpdD09InN5bWJvbCJ9OmZ1bmN0aW9uKGl0KXtyZXR1cm4gaXQgaW5zdGFuY2VvZiBIfSwkPWZ1bmN0aW9uKG50LGF0LGR0KXtyZXR1cm4gbnQ9PT1odCYmJChrLGF0LGR0KSxpKG50KSxhdD1PKGF0LCEwKSxpKGR0KSxuKHN0LGF0KT8oZHQuZW51bWVyYWJsZT8obihudCxHKSYmbnRbR11bYXRdJiYobnRbR11bYXRdPSExKSxkdD1SKGR0LHtlbnVtZXJhYmxlOkEoMCwhMSl9KSk6KG4obnQsRyl8fEIobnQsRyxBKDEse30pKSxudFtHXVthdF09ITApLFYobnQsYXQsZHQpKTpCKG50LGF0LGR0KX0sbT1mdW5jdGlvbihudCxhdCl7aShudCk7Zm9yKHZhciBkdD12KGF0PWYoYXQpKSxndD0wLHV0PWR0Lmxlbmd0aCxtdDt1dD5ndDspJChudCxtdD1kdFtndCsrXSxhdFttdF0pO3JldHVybiBudH0sVD1mdW5jdGlvbihudCxhdCl7cmV0dXJuIGF0PT09dm9pZCAwP1IobnQpOm0oUihudCksYXQpfSxOPWZ1bmN0aW9uKG50KXt2YXIgYXQ9dHQuY2FsbCh0aGlzLG50PU8obnQsITApKTtyZXR1cm4gdGhpcz09PWh0JiZuKHN0LG50KSYmIW4oayxudCk/ITE6YXR8fCFuKHRoaXMsbnQpfHwhbihzdCxudCl8fG4odGhpcyxHKSYmdGhpc1tHXVtudF0/YXQ6ITB9LHo9ZnVuY3Rpb24obnQsYXQpe2lmKG50PWYobnQpLGF0PU8oYXQsITApLCEobnQ9PT1odCYmbihzdCxhdCkmJiFuKGssYXQpKSl7dmFyIGR0PVMobnQsYXQpO3JldHVybiBkdCYmbihzdCxhdCkmJiEobihudCxHKSYmbnRbR11bYXRdKSYmKGR0LmVudW1lcmFibGU9ITApLGR0fX0sSz1mdW5jdGlvbihudCl7Zm9yKHZhciBhdD13KGYobnQpKSxkdD1bXSxndD0wLHV0O2F0Lmxlbmd0aD5ndDspIW4oc3QsdXQ9YXRbZ3QrK10pJiZ1dCE9RyYmdXQhPW8mJmR0LnB1c2godXQpO3JldHVybiBkdH0sWT1mdW5jdGlvbihudCl7Zm9yKHZhciBhdD1udD09PWh0LGR0PXcoYXQ/azpmKG50KSksZ3Q9W10sdXQ9MCxtdDtkdC5sZW5ndGg+dXQ7KW4oc3QsbXQ9ZHRbdXQrK10pJiYoIWF0fHxuKGh0LG10KSkmJmd0LnB1c2goc3RbbXRdKTtyZXR1cm4gZ3R9O2Z0fHwoSD1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBIKXRocm93IFR5cGVFcnJvcigiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yISIpO3ZhciBudD15KGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKSxhdD1mdW5jdGlvbihkdCl7dGhpcz09PWh0JiZhdC5jYWxsKGssZHQpLG4odGhpcyxHKSYmbih0aGlzW0ddLG50KSYmKHRoaXNbR11bbnRdPSExKSxWKHRoaXMsbnQsQSgxLGR0KSl9O3JldHVybiBkJiZGJiZWKGh0LG50LHtjb25maWd1cmFibGU6ITAsc2V0OmF0fSksWChudCl9LHUoSFtVXSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2t9KSxQLmY9eixELmY9JCx0KDE4MikuZj1JLmY9Syx0KDE2OSkuZj1OLEwuZj1ZLGQmJiF0KDg5KSYmdShodCwicHJvcGVydHlJc0VudW1lcmFibGUiLE4sITApLGIuZj1mdW5jdGlvbihpdCl7cmV0dXJuIFgoeChpdCkpfSksZyhnLkcrZy5XK2cuRiohZnQse1N5bWJvbDpIfSk7Zm9yKHZhciBRPSJoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcyIuc3BsaXQoIiwiKSxldD0wO1EubGVuZ3RoPmV0Oyl4KFFbZXQrK10pO2Zvcih2YXIgcnQ9Qyh4LnN0b3JlKSxvdD0wO3J0Lmxlbmd0aD5vdDspRShydFtvdCsrXSk7ZyhnLlMrZy5GKiFmdCwiU3ltYm9sIix7Zm9yOmZ1bmN0aW9uKGl0KXtyZXR1cm4gbihfLGl0Kz0iIik/X1tpdF06X1tpdF09SChpdCl9LGtleUZvcjpmdW5jdGlvbihudCl7aWYoIWoobnQpKXRocm93IFR5cGVFcnJvcihudCsiIGlzIG5vdCBhIHN5bWJvbCEiKTtmb3IodmFyIGF0IGluIF8paWYoX1thdF09PT1udClyZXR1cm4gYXR9LHVzZVNldHRlcjpmdW5jdGlvbigpe0Y9ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpe0Y9ITF9fSksZyhnLlMrZy5GKiFmdCwiT2JqZWN0Iix7Y3JlYXRlOlQsZGVmaW5lUHJvcGVydHk6JCxkZWZpbmVQcm9wZXJ0aWVzOm0sZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOnosZ2V0T3duUHJvcGVydHlOYW1lczpLLGdldE93blByb3BlcnR5U3ltYm9sczpZfSk7dmFyIGx0PWMoZnVuY3Rpb24oKXtMLmYoMSl9KTtnKGcuUytnLkYqbHQsIk9iamVjdCIse2dldE93blByb3BlcnR5U3ltYm9sczpmdW5jdGlvbihudCl7cmV0dXJuIEwuZihzKG50KSl9fSksWiYmZyhnLlMrZy5GKighZnR8fGMoZnVuY3Rpb24oKXt2YXIgaXQ9SCgpO3JldHVybiBxKFtpdF0pIT0iW251bGxdInx8cSh7YTppdH0pIT0ie30ifHxxKE9iamVjdChpdCkpIT0ie30ifSkpLCJKU09OIix7c3RyaW5naWZ5OmZ1bmN0aW9uKG50KXtmb3IodmFyIGF0PVtudF0sZHQ9MSxndCx1dDthcmd1bWVudHMubGVuZ3RoPmR0OylhdC5wdXNoKGFyZ3VtZW50c1tkdCsrXSk7aWYodXQ9Z3Q9YXRbMV0sISghYShndCkmJm50PT09dm9pZCAwfHxqKG50KSkpcmV0dXJuIE0oZ3QpfHwoZ3Q9ZnVuY3Rpb24obXQsUHQpe2lmKHR5cGVvZiB1dD09ImZ1bmN0aW9uIiYmKFB0PXV0LmNhbGwodGhpcyxtdCxQdCkpLCFqKFB0KSlyZXR1cm4gUHR9KSxhdFsxXT1ndCxxLmFwcGx5KFosYXQpfX0pLEhbVV1bSl18fHQoOTUpKEhbVV0sSixIW1VdLnZhbHVlT2YpLGwoSCwiU3ltYm9sIiksbChNYXRoLCJNYXRoIiwhMCksbChyLkpTT04sIkpTT04iLCEwKX0sZnVuY3Rpb24oaCxlLHQpe2UuZj10KDEyMil9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkxKSxuPXQoOTIpLGQ9dCg4OSksZz10KDE3OCksdT10KDk2KS5mO2guZXhwb3J0cz1mdW5jdGlvbihvKXt2YXIgYz1uLlN5bWJvbHx8KG4uU3ltYm9sPWQ/e306ci5TeW1ib2x8fHt9KTtvLmNoYXJBdCgwKSE9Il8iJiYhKG8gaW4gYykmJnUoYyxvLHt2YWx1ZTpnLmYobyl9KX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExMCksbj10KDE2OCksZD10KDE2OSk7aC5leHBvcnRzPWZ1bmN0aW9uKGcpe3ZhciB1PXIoZyksbz1uLmY7aWYobylmb3IodmFyIGM9byhnKSxwPWQuZixsPTAseTtjLmxlbmd0aD5sOylwLmNhbGwoZyx5PWNbbCsrXSkmJnUucHVzaCh5KTtyZXR1cm4gdX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg0KSxuPXQoMTgyKS5mLGQ9e30udG9TdHJpbmcsZz10eXBlb2Ygd2luZG93PT0ib2JqZWN0IiYmd2luZG93JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpOltdLHU9ZnVuY3Rpb24obyl7dHJ5e3JldHVybiBuKG8pfWNhdGNoe3JldHVybiBnLnNsaWNlKCl9fTtoLmV4cG9ydHMuZj1mdW5jdGlvbihjKXtyZXR1cm4gZyYmZC5jYWxsKGMpPT0iW29iamVjdCBXaW5kb3ddIj91KGMpOm4ocihjKSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMTEpLG49dCgxMTkpLmNvbmNhdCgibGVuZ3RoIiwicHJvdG90eXBlIik7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbihnKXtyZXR1cm4gcihnLG4pfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTY5KSxuPXQoMTA0KSxkPXQoODQpLGc9dCgxMDMpLHU9dCgxMDUpLG89dCg5OSksYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2UuZj10KDEwMCk/YzpmdW5jdGlvbihsLHkpe2lmKGw9ZChsKSx5PWcoeSwhMCksbyl0cnl7cmV0dXJuIGMobCx5KX1jYXRjaHt9aWYodShsLHkpKXJldHVybiBuKCFyLmYuY2FsbChsLHkpLGxbeV0pfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTc5KSgiYXN5bmNJdGVyYXRvciIpfSxmdW5jdGlvbihoLGUsdCl7dCgxNzkpKCJvYnNlcnZhYmxlIil9LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5jcmVhdGVOb3dUaW1lPXIsZS5mb3JtYXREZWxheT1uO2Z1bmN0aW9uIHIoKXt2YXIgZD1udWxsO3JldHVybiBEYXRlLm5vdz9kPURhdGUubm93OmQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCl9LGR9ZnVuY3Rpb24gbihkKXtyZXR1cm4gdHlwZW9mIGQ9PSJudW1iZXIiP2Q9e2RlbGF5OmR9OiJlbnRyb3B5ImluIGQmJihkPXtkZWxheTpkLmVudHJvcHksaXNFbnRyb3B5OiEwfSksZH19LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PXtkZWZhdWx0OmZ1bmN0aW9uKG4sZCxnLHUsbyl7cmV0dXJuIHR5cGVvZiBuPT0ibnVtYmVyIiYmdHlwZW9mIGQ9PSJudW1iZXIiP24rKGctdSkvKG8tdSkqKGQtbik6Zy11Pm8tZz9kOm59fX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLnBhcnNlRWFzaW5nPWUuRWFzaW5ncz12b2lkIDA7dmFyIHI9dCg3Niksbj1jKHIpLGQ9dCgxMzMpLGc9YyhkKSx1PXQoMTQxKSxvPWModSk7ZnVuY3Rpb24gYyhNKXtyZXR1cm4gTSYmTS5fX2VzTW9kdWxlP006e2RlZmF1bHQ6TX19dmFyIHA9dCgxODkpLGw9bmV3IG8uZGVmYXVsdDtmdW5jdGlvbiB5KCl7Zm9yKHZhciBNPWFyZ3VtZW50cy5sZW5ndGgsaT1BcnJheShNKSxhPTA7YTxNO2ErKylpW2FdPWFyZ3VtZW50c1thXTt2YXIgcz1sLmdldChpKTtyZXR1cm4gc3x8KHM9cC5hcHBseSh2b2lkIDAsaSksbC5zZXQoaSxzKSxzKX1mdW5jdGlvbiB4KE0pe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXToiZW5kIjtyZXR1cm4gZnVuY3Rpb24oYSxzKXtmb3IodmFyIGY9MTtmPHMubGVuZ3RoO2YrKyl7dmFyIE89c1tmXS5vZmZzZXQ7aWYoYTw9Tyl7dmFyIEE9c1tmLTFdLm9mZnNldCxSPU8sST0oYS1BKS8oUi1BKSxQPTEvTSxMPUkvUDtyZXR1cm4gaT09PSJlbmQiP0w9TWF0aC5mbG9vcihMKTpMPU1hdGguY2VpbChMKSxQKkwqKFItQSkrQX19cmV0dXJuIDB9fWZ1bmN0aW9uIGIoTSl7dmFyIGk9L15jdWJpYy1iZXppZXJcKCguKilcKS8sYT1NLm1hdGNoKGkpO2lmKGEpe3ZhciBzPWFbMV0udHJpbSgpO3JldHVybiBzPXMuc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oUCl7cmV0dXJuIHBhcnNlRmxvYXQoUC50cmltKCkpfSkseS5hcHBseSh2b2lkIDAsKDAsZy5kZWZhdWx0KShzKSl9aWYoaT0vXnN0ZXBzXCgoLiopXCkvLGE9TS5tYXRjaChpKSxhKXt2YXIgZj1hWzFdLnRyaW0oKTtmPWYuc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oUCl7cmV0dXJuIFAudHJpbSgpfSk7dmFyIE89ZixBPSgwLG4uZGVmYXVsdCkoTywyKSxSPUFbMF0sST1BWzFdO3JldHVybiB4KHBhcnNlSW50KFIsMTApLEkpfXJldHVybiBNfXZhciBFPXtsaW5lYXI6ZnVuY3Rpb24oaSl7cmV0dXJuIGl9LGVhc2U6eSguMjUsLjEsLjI1LDEpLCJlYXNlLWluIjp5KC40MiwwLDEsMSksImVhc2Utb3V0Ijp5KDAsMCwuNTgsMSksImVhc2UtaW4tb3V0Ijp5KC40MiwwLC41OCwxKSwic3RlcC1zdGFydCI6eCgxLCJzdGFydCIpLCJzdGVwLWVuZCI6eCgxLCJlbmQiKX07ZnVuY3Rpb24gdihNKXtyZXR1cm4gdHlwZW9mIE09PSJzdHJpbmciP0VbTV0/TT1FW01dOk09YihNKTpNLnR5cGU9PT0iY3ViaWMtYmV6aWVyIj9NPXkuYXBwbHkodm9pZCAwLCgwLGcuZGVmYXVsdCkoTS52YWx1ZSkpOk0udHlwZT09PSJzdGVwcyImJihNPXgoTS5zdGVwLE0ucG9zKSksTX1lLkVhc2luZ3M9RSxlLnBhcnNlRWFzaW5nPXZ9LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9NCxyPS4wMDEsbj0xZS03LGQ9MTAsZz0xMSx1PTEvKGctMSksbz10eXBlb2YgRmxvYXQzMkFycmF5PT0iZnVuY3Rpb24iO2Z1bmN0aW9uIGMoTSxpKXtyZXR1cm4gMS0zKmkrMypNfWZ1bmN0aW9uIHAoTSxpKXtyZXR1cm4gMyppLTYqTX1mdW5jdGlvbiBsKE0pe3JldHVybiAzKk19ZnVuY3Rpb24geShNLGksYSl7cmV0dXJuKChjKGksYSkqTStwKGksYSkpKk0rbChpKSkqTX1mdW5jdGlvbiB4KE0saSxhKXtyZXR1cm4gMypjKGksYSkqTSpNKzIqcChpLGEpKk0rbChpKX1mdW5jdGlvbiBiKE0saSxhLHMsZil7dmFyIE8sQSxSPTA7ZG8gQT1pKyhhLWkpLzIsTz15KEEscyxmKS1NLE8+MD9hPUE6aT1BO3doaWxlKE1hdGguYWJzKE8pPm4mJisrUjxkKTtyZXR1cm4gQX1mdW5jdGlvbiBFKE0saSxhLHMpe2Zvcih2YXIgZj0wO2Y8dDsrK2Ype3ZhciBPPXgoaSxhLHMpO2lmKE89PT0wKXJldHVybiBpO3ZhciBBPXkoaSxhLHMpLU07aS09QS9PfXJldHVybiBpfWZ1bmN0aW9uIHYoTSl7cmV0dXJuIE19aC5leHBvcnRzPWZ1bmN0aW9uKGksYSxzLGYpe2lmKCEoMDw9aSYmaTw9MSYmMDw9cyYmczw9MSkpdGhyb3cgbmV3IEVycm9yKCJiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2UiKTtpZihpPT09YSYmcz09PWYpcmV0dXJuIHY7Zm9yKHZhciBPPW8/bmV3IEZsb2F0MzJBcnJheShnKTpuZXcgQXJyYXkoZyksQT0wO0E8ZzsrK0EpT1tBXT15KEEqdSxpLHMpO2Z1bmN0aW9uIFIoSSl7Zm9yKHZhciBQPTAsTD0xLEQ9Zy0xO0whPT1EJiZPW0xdPD1JOysrTClQKz11Oy0tTDt2YXIgQz0oSS1PW0xdKS8oT1tMKzFdLU9bTF0pLFM9UCtDKnUsQj14KFMsaSxzKTtyZXR1cm4gQj49cj9FKEksUyxpLHMpOkI9PT0wP1M6YihJLFAsUCt1LGkscyl9cmV0dXJuIGZ1bmN0aW9uKFApe3JldHVybiBQPT09MD8wOlA9PT0xPzE6eShSKFApLGEsZil9fX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDE5MSksbj1hKHIpLGQ9dCgyMDQpLGc9YShkKSx1PXQoMTY0KSxvPWEodSksYz10KDE3MCkscD1hKGMpLGw9dCgxNzEpLHk9YShsKSx4PXQoMTc1KSxiPWEoeCksRT10KDc1KSx2PWEoRSksTT10KDIwOCksaT10KDE4OCk7ZnVuY3Rpb24gYShCKXtyZXR1cm4gQiYmQi5fX2VzTW9kdWxlP0I6e2RlZmF1bHQ6Qn19dmFyIHM9KDAsYi5kZWZhdWx0KSgidGltaW5nIiksZj0oMCxiLmRlZmF1bHQpKCJrZXlmcmFtZXMiKSxPPSgwLGIuZGVmYXVsdCkoImluaXRTdGF0ZSIpLEE9KDAsYi5kZWZhdWx0KSgicmVhZHlEZWZlciIpLFI9KDAsYi5kZWZhdWx0KSgiZmluaXNoZWREZWZlciIpLEk9KDAsYi5kZWZhdWx0KSgiZWZmZWN0cyIpLFA9KDAsYi5kZWZhdWx0KSgiYWN0aXZlUmVhZHlUaW1lciIpLEw9KDAsYi5kZWZhdWx0KSgiYWN0aXZlRmluaXNoVGltZXIiKSxEPSgwLGIuZGVmYXVsdCkoInJlbW92ZURlZmVyIiksQz17ZGVsYXk6MCxlbmREZWxheTowLGZpbGw6ImF1dG8iLGl0ZXJhdGlvbnM6MSxwbGF5YmFja1JhdGU6MSxkaXJlY3Rpb246Im5vcm1hbCIsZWFzaW5nOiJsaW5lYXIiLGVmZmVjdDpudWxsfSxTPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gQih3LEgsWil7dmFyIHE9dGhpcztpZigoMCxwLmRlZmF1bHQpKHRoaXMsQiksQXJyYXkuaXNBcnJheSh3KSl7dmFyIFU9W3dbMF0sdyxIXTt3PVVbMF0sSD1VWzFdLFo9VVsyXX10eXBlb2YgWj09Im51bWJlciImJihaPXtkdXJhdGlvbjpafSksdGhpc1tzXT0oMCxvLmRlZmF1bHQpKHt9LEMsWiksdGhpc1tzXS5lYXNpbmc9KDAsaS5wYXJzZUVhc2luZykodGhpc1tzXS5lYXNpbmcpLHRoaXNbZl09KDAsTS5jYWxjdWxhdGVGcmFtZXNPZmZzZXQpKEgpO3ZhciBHPXRoaXNbZl1bdGhpc1tmXS5sZW5ndGgtMV07dGhpc1tPXT17fSwoMCxnLmRlZmF1bHQpKEcpLmZvckVhY2goZnVuY3Rpb24oSil7T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHcsSikmJkohPT0iZWFzaW5nIiYmSiE9PSJvZmZzZXQiJiYocVtPXVtKXT13W0pdKX0pLHRoaXNbZl09dGhpc1tmXS5tYXAoZnVuY3Rpb24oSil7cmV0dXJuKDAsby5kZWZhdWx0KSh7fSxxW09dLEopfSksdGhpc1tmXVswXS5vZmZzZXQhPT0wJiZ0aGlzW2ZdLnVuc2hpZnQoKDAsby5kZWZhdWx0KSh7fSx0aGlzW09dLHtvZmZzZXQ6MH0pKSxHLm9mZnNldDwxJiZ0aGlzW2ZdLnB1c2goKDAsby5kZWZhdWx0KSh7fSxHLHtvZmZzZXQ6MX0pKSx0aGlzW0ldPXt9LHRoaXMudGltZWxpbmU9bnVsbH1yZXR1cm4oMCx5LmRlZmF1bHQpKEIsW3trZXk6InBhdXNlIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPTB9fSx7a2V5OlAsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgSD10aGlzO3RoaXNbQV0mJiF0aGlzW0FdLnRpbWVySUQmJih0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDA/dGhpc1tBXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbQV0ucmVzb2x2ZSgpLGRlbGV0ZSBIW0FdfSx7ZGVsYXk6LXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUsaGVhZGluZzohMX0pOnRoaXNbQV0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIW0FdLnJlc29sdmUoKSxkZWxldGUgSFtBXX0se2RlbGF5OjAsaXNFbnRyb3B5OiEwfSkpfX0se2tleTpMLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEg9dGhpcyxaPXRoaXNbc10scT1aLmR1cmF0aW9uLFU9Wi5pdGVyYXRpb25zLEc9Wi5lbmREZWxheSxKPU1hdGguY2VpbChxKlUrRy10aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lKSsxO3RoaXNbUl0mJiF0aGlzW1JdLnRpbWVySUQmJih0aGlzW1JdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SFtSXS5yZXNvbHZlKCksSFtEXShBKSxIW0RdKFIpfSx7ZGVsYXk6SixoZWFkaW5nOiExfSksdGhpc1tSXS5yZXZlcnNlVGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIW1JdLnJlc29sdmUoKSxIW0RdKEEpLEhbRF0oUiksSC50aW1lbGluZT1udWxsfSx7ZGVsYXk6LXRoaXNbc10uZGVsYXktMSxoZWFkaW5nOiExfSkpfX0se2tleToicGxheSIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXlTdGF0ZT09PSJmaW5pc2hlZCImJnRoaXMuY2FuY2VsKCksdGhpcy5wbGF5U3RhdGU9PT0iaWRsZSIpe2lmKHRoaXMucGxheWJhY2tSYXRlPD0wKXJldHVybjt2YXIgSD10aGlzW3NdLFo9SC5kZWxheSxxPUgucGxheWJhY2tSYXRlLFU9SC50aW1lbGluZTt0aGlzLnRpbWVsaW5lPW5ldyB2LmRlZmF1bHQoe29yaWdpblRpbWU6WixwbGF5YmFja1JhdGU6cX0sVSksdGhpc1tQXSgpLHRoaXNbTF0oKX1lbHNlIHRoaXMucGxheVN0YXRlPT09InBhdXNlZCImJih0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT10aGlzLnBsYXliYWNrUmF0ZSx0aGlzW1BdKCkpfX0se2tleTpELHZhbHVlOmZ1bmN0aW9uKEgpe3ZhciBaPXRoaXNbSF0scT10aGlzLnRpbWVsaW5lO1omJnEmJihxLmNsZWFyVGltZW91dChaLnRpbWVySUQpLFoucmV2ZXJzZVRpbWVySUQmJnEuY2xlYXJUaW1lb3V0KFoucmV2ZXJzZVRpbWVySUQpKSxkZWxldGUgdGhpc1tIXX19LHtrZXk6ImNhbmNlbCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzW0RdKEEpLHRoaXNbRF0oUiksdGhpcy50aW1lbGluZT1udWxsfX0se2tleToiZmluaXNoIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPTEvMC90aGlzLnBsYXliYWNrUmF0ZSksdGhpc1tEXShBKSx0aGlzW0RdKFIpfX0se2tleToiYXBwbHlFZmZlY3RzIix2YWx1ZTpmdW5jdGlvbihIKXtyZXR1cm4oMCxvLmRlZmF1bHQpKHRoaXNbSV0sSCl9fSx7a2V5OiJwbGF5YmFja1JhdGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW3NdLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKEgpe3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT1IKSx0aGlzW3NdLnBsYXliYWNrUmF0ZT1IfX0se2tleToicGxheVN0YXRlIixnZXQ6ZnVuY3Rpb24oKXt2YXIgSD10aGlzLnRpbWVsaW5lLFo9dGhpc1tzXSxxPVouaXRlcmF0aW9ucyxVPVouZHVyYXRpb24sRz1aLmVuZERlbGF5LEo9InJ1bm5pbmciO2lmKEg9PW51bGwpSj0iaWRsZSI7ZWxzZSBpZihILnBhdXNlZClKPSJwYXVzZWQiO2Vsc2UgaWYoSC5jdXJyZW50VGltZTwwKUo9InBlbmRpbmciO2Vsc2V7dmFyIHR0PUguY3VycmVudFRpbWUtcSpVO3R0PjAmJnR0PEc/Sj0icGVuZGluZyI6dHQ+PUcmJihKPSJmaW5pc2hlZCIpfXJldHVybiBKfX0se2tleToicHJvZ3Jlc3MiLGdldDpmdW5jdGlvbigpe2lmKCF0aGlzLnRpbWVsaW5lKXJldHVybiAwO3ZhciBIPXRoaXNbc10sWj1ILmR1cmF0aW9uLHE9SC5pdGVyYXRpb25zLFU9dGhpcy50aW1lbGluZSxHPXRoaXMucGxheVN0YXRlLEo9dm9pZCAwO2lmKEc9PT0iaWRsZSIpSj0wO2Vsc2UgaWYoRz09PSJwYXVzZWQiJiZVLmN1cnJlbnRUaW1lPDApSj0wO2Vsc2UgaWYoRz09PSJwZW5kaW5nIilpZihVLmN1cnJlbnRUaW1lPDApSj0wO2Vsc2V7dmFyIHR0PVUuc2Vla0xvY2FsVGltZShxKlopO0o9KDAsTS5wZXJpb2RpY2l0eSkodHQsWilbMV0vWn1lbHNlKEc9PT0icnVubmluZyJ8fEc9PT0icGF1c2VkIikmJihKPSgwLE0ucGVyaW9kaWNpdHkpKFUuY3VycmVudFRpbWUsWilbMV0vWik7cmV0dXJuIEc9PT0iZmluaXNoZWQiJiYoSj0oMCxNLnBlcmlvZGljaXR5KShxLDEpWzFdKSxKfX0se2tleToiZnJhbWUiLGdldDpmdW5jdGlvbigpe3ZhciBIPXRoaXMucGxheVN0YXRlLFo9dGhpc1tPXSxxPXRoaXNbc10uZmlsbDtpZihIPT09ImlkbGUiKXJldHVybiBaO3ZhciBVPXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUsRz10aGlzW2ZdLnNsaWNlKDApLEo9KDAsTS5nZXRQcm9ncmVzcykodGhpcy50aW1lbGluZSx0aGlzW3NdLHRoaXMucHJvZ3Jlc3MpLHR0PUoucCxfPUouaW52ZXJ0ZWQsc3Q9WjtyZXR1cm4gVTwwJiZIPT09InBlbmRpbmciPyhxPT09ImJhY2t3YXJkcyJ8fHE9PT0iYm90aCIpJiYoc3Q9Xz9HW0cubGVuZ3RoLTFdOkdbMF0pOihIIT09InBlbmRpbmciJiZIIT09ImZpbmlzaGVkInx8cT09PSJmb3J3YXJkcyJ8fHE9PT0iYm90aCIpJiYoc3Q9KDAsTS5nZXRDdXJyZW50RnJhbWUpKHRoaXNbc10sRyx0aGlzW0ldLHR0KSksc3R9fSx7a2V5OiJ0aW1pbmciLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW3NdfX0se2tleToiZWZmZWN0cyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbSV19fSx7a2V5OiJiYXNlVGltZWxpbmUiLHNldDpmdW5jdGlvbihIKXt0aGlzW3NdLnRpbWVsaW5lPUh9LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW3NdLnRpbWVsaW5lfX0se2tleToicmVhZHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ucHJvbWlzZTp0aGlzLnRpbWVsaW5lJiZ0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPj0wJiZ0aGlzLnBsYXlTdGF0ZSE9PSJwYXVzZWQiP24uZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbQV09KDAsTS5kZWZlcikoKSx0aGlzLnRpbWVsaW5lJiZ0aGlzW1BdKCksdGhpc1tBXT90aGlzW0FdLnByb21pc2U6bi5kZWZhdWx0LnJlc29sdmUoKSl9fSx7a2V5OiJmaW5pc2hlZCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIj9uLmRlZmF1bHQucmVzb2x2ZSgpOih0aGlzW1JdfHwodGhpc1tSXT0oMCxNLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbTF0oKSksdGhpc1tSXS5wcm9taXNlKX19XSksQn0oKTtlLmRlZmF1bHQ9U30sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17ZGVmYXVsdDp0KDE5MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTkzKSx0KDIwMiksdCgyMDMpLGguZXhwb3J0cz10KDkyKS5Qcm9taXNlfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4OSksbj10KDkxKSxkPXQoOTMpLGc9dCgxMjgpLHU9dCg5MCksbz10KDk4KSxjPXQoOTQpLHA9dCgxNDcpLGw9dCgxNDgpLHk9dCgxOTQpLHg9dCgxOTUpLnNldCxiPXQoMTk3KSgpLEU9dCgxOTgpLHY9dCgxOTkpLE09dCgyMDApLGk9dCgyMDEpLGE9IlByb21pc2UiLHM9bi5UeXBlRXJyb3IsZj1uLnByb2Nlc3MsTz1mJiZmLnZlcnNpb25zLEE9TyYmTy52OHx8IiIsUj1uW2FdLEk9ZyhmKT09InByb2Nlc3MiLFA9ZnVuY3Rpb24oKXt9LEwsRCxDLFMsQj1EPUUuZix3PSEhZnVuY3Rpb24oKXt0cnl7dmFyIF89Ui5yZXNvbHZlKDEpLHN0PShfLmNvbnN0cnVjdG9yPXt9KVt0KDEyMikoInNwZWNpZXMiKV09ZnVuY3Rpb24oayl7ayhQLFApfTtyZXR1cm4oSXx8dHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudD09ImZ1bmN0aW9uIikmJl8udGhlbihQKWluc3RhbmNlb2Ygc3QmJkEuaW5kZXhPZigiNi42IikhPT0wJiZNLmluZGV4T2YoIkNocm9tZS82NiIpPT09LTF9Y2F0Y2h7fX0oKSxIPWZ1bmN0aW9uKF8pe3ZhciBzdDtyZXR1cm4gbyhfKSYmdHlwZW9mKHN0PV8udGhlbik9PSJmdW5jdGlvbiI/c3Q6ITF9LFo9ZnVuY3Rpb24oXyxzdCl7aWYoIV8uX24pe18uX249ITA7dmFyIGs9Xy5fYztiKGZ1bmN0aW9uKCl7Zm9yKHZhciBodD1fLl92LGZ0PV8uX3M9PTEsVz0wLEY9ZnVuY3Rpb24oVil7dmFyIFg9ZnQ/Vi5vazpWLmZhaWwsaj1WLnJlc29sdmUsJD1WLnJlamVjdCxtPVYuZG9tYWluLFQsTix6O3RyeXtYPyhmdHx8KF8uX2g9PTImJkcoXyksXy5faD0xKSxYPT09ITA/VD1odDoobSYmbS5lbnRlcigpLFQ9WChodCksbSYmKG0uZXhpdCgpLHo9ITApKSxUPT09Vi5wcm9taXNlPyQocygiUHJvbWlzZS1jaGFpbiBjeWNsZSIpKTooTj1IKFQpKT9OLmNhbGwoVCxqLCQpOmooVCkpOiQoaHQpfWNhdGNoKEspe20mJiF6JiZtLmV4aXQoKSwkKEspfX07ay5sZW5ndGg+VzspRihrW1crK10pO18uX2M9W10sXy5fbj0hMSxzdCYmIV8uX2gmJnEoXyl9KX19LHE9ZnVuY3Rpb24oXyl7eC5jYWxsKG4sZnVuY3Rpb24oKXt2YXIgc3Q9Xy5fdixrPVUoXyksaHQsZnQsVztpZihrJiYoaHQ9dihmdW5jdGlvbigpe0k/Zi5lbWl0KCJ1bmhhbmRsZWRSZWplY3Rpb24iLHN0LF8pOihmdD1uLm9udW5oYW5kbGVkcmVqZWN0aW9uKT9mdCh7cHJvbWlzZTpfLHJlYXNvbjpzdH0pOihXPW4uY29uc29sZSkmJlcuZXJyb3ImJlcuZXJyb3IoIlVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbiIsc3QpfSksXy5faD1JfHxVKF8pPzI6MSksXy5fYT12b2lkIDAsayYmaHQuZSl0aHJvdyBodC52fSl9LFU9ZnVuY3Rpb24oXyl7cmV0dXJuIF8uX2ghPT0xJiYoXy5fYXx8Xy5fYykubGVuZ3RoPT09MH0sRz1mdW5jdGlvbihfKXt4LmNhbGwobixmdW5jdGlvbigpe3ZhciBzdDtJP2YuZW1pdCgicmVqZWN0aW9uSGFuZGxlZCIsXyk6KHN0PW4ub25yZWplY3Rpb25oYW5kbGVkKSYmc3Qoe3Byb21pc2U6XyxyZWFzb246Xy5fdn0pfSl9LEo9ZnVuY3Rpb24oXyl7dmFyIHN0PXRoaXM7c3QuX2R8fChzdC5fZD0hMCxzdD1zdC5fd3x8c3Qsc3QuX3Y9XyxzdC5fcz0yLHN0Ll9hfHwoc3QuX2E9c3QuX2Muc2xpY2UoKSksWihzdCwhMCkpfSx0dD1mdW5jdGlvbihfKXt2YXIgc3Q9dGhpcyxrO2lmKCFzdC5fZCl7c3QuX2Q9ITAsc3Q9c3QuX3d8fHN0O3RyeXtpZihzdD09PV8pdGhyb3cgcygiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGYiKTsoaz1IKF8pKT9iKGZ1bmN0aW9uKCl7dmFyIGh0PXtfdzpzdCxfZDohMX07dHJ5e2suY2FsbChfLGQodHQsaHQsMSksZChKLGh0LDEpKX1jYXRjaChmdCl7Si5jYWxsKGh0LGZ0KX19KTooc3QuX3Y9XyxzdC5fcz0xLFooc3QsITEpKX1jYXRjaChodCl7Si5jYWxsKHtfdzpzdCxfZDohMX0saHQpfX19O3d8fChSPWZ1bmN0aW9uKHN0KXtwKHRoaXMsUixhLCJfaCIpLGMoc3QpLEwuY2FsbCh0aGlzKTt0cnl7c3QoZCh0dCx0aGlzLDEpLGQoSix0aGlzLDEpKX1jYXRjaChrKXtKLmNhbGwodGhpcyxrKX19LEw9ZnVuY3Rpb24oc3Qpe3RoaXMuX2M9W10sdGhpcy5fYT12b2lkIDAsdGhpcy5fcz0wLHRoaXMuX2Q9ITEsdGhpcy5fdj12b2lkIDAsdGhpcy5faD0wLHRoaXMuX249ITF9LEwucHJvdG90eXBlPXQoMTQ2KShSLnByb3RvdHlwZSx7dGhlbjpmdW5jdGlvbihzdCxrKXt2YXIgaHQ9Qih5KHRoaXMsUikpO3JldHVybiBodC5vaz10eXBlb2Ygc3Q9PSJmdW5jdGlvbiI/c3Q6ITAsaHQuZmFpbD10eXBlb2Ygaz09ImZ1bmN0aW9uIiYmayxodC5kb21haW49ST9mLmRvbWFpbjp2b2lkIDAsdGhpcy5fYy5wdXNoKGh0KSx0aGlzLl9hJiZ0aGlzLl9hLnB1c2goaHQpLHRoaXMuX3MmJloodGhpcywhMSksaHQucHJvbWlzZX0sY2F0Y2g6ZnVuY3Rpb24oXyl7cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsXyl9fSksQz1mdW5jdGlvbigpe3ZhciBfPW5ldyBMO3RoaXMucHJvbWlzZT1fLHRoaXMucmVzb2x2ZT1kKHR0LF8sMSksdGhpcy5yZWplY3Q9ZChKLF8sMSl9LEUuZj1CPWZ1bmN0aW9uKF8pe3JldHVybiBfPT09Unx8Xz09PVM/bmV3IEMoXyk6RChfKX0pLHUodS5HK3UuVyt1LkYqIXcse1Byb21pc2U6Un0pLHQoMTIxKShSLGEpLHQoMTQ5KShhKSxTPXQoOTIpW2FdLHUodS5TK3UuRiohdyxhLHtyZWplY3Q6ZnVuY3Rpb24oc3Qpe3ZhciBrPUIodGhpcyksaHQ9ay5yZWplY3Q7cmV0dXJuIGh0KHN0KSxrLnByb21pc2V9fSksdSh1LlMrdS5GKihyfHwhdyksYSx7cmVzb2x2ZTpmdW5jdGlvbihzdCl7cmV0dXJuIGkociYmdGhpcz09PVM/Ujp0aGlzLHN0KX19KSx1KHUuUyt1LkYqISh3JiZ0KDE0MCkoZnVuY3Rpb24oXyl7Ui5hbGwoXykuY2F0Y2goUCl9KSksYSx7YWxsOmZ1bmN0aW9uKHN0KXt2YXIgaz10aGlzLGh0PUIoayksZnQ9aHQucmVzb2x2ZSxXPWh0LnJlamVjdCxGPXYoZnVuY3Rpb24oKXt2YXIgVj1bXSxYPTAsaj0xO2woc3QsITEsZnVuY3Rpb24oJCl7dmFyIG09WCsrLFQ9ITE7Vi5wdXNoKHZvaWQgMCksaisrLGsucmVzb2x2ZSgkKS50aGVuKGZ1bmN0aW9uKE4pe1R8fChUPSEwLFZbbV09TiwtLWp8fGZ0KFYpKX0sVyl9KSwtLWp8fGZ0KFYpfSk7cmV0dXJuIEYuZSYmVyhGLnYpLGh0LnByb21pc2V9LHJhY2U6ZnVuY3Rpb24oc3Qpe3ZhciBrPXRoaXMsaHQ9QihrKSxmdD1odC5yZWplY3QsVz12KGZ1bmN0aW9uKCl7bChzdCwhMSxmdW5jdGlvbihGKXtrLnJlc29sdmUoRikudGhlbihodC5yZXNvbHZlLGZ0KX0pfSk7cmV0dXJuIFcuZSYmZnQoVy52KSxodC5wcm9taXNlfX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nyksbj10KDk0KSxkPXQoMTIyKSgic3BlY2llcyIpO2guZXhwb3J0cz1mdW5jdGlvbihnLHUpe3ZhciBvPXIoZykuY29uc3RydWN0b3IsYztyZXR1cm4gbz09PXZvaWQgMHx8KGM9cihvKVtkXSk9PW51bGw/dTpuKGMpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTMpLG49dCgxOTYpLGQ9dCgxMjApLGc9dCgxMDIpLHU9dCg5MSksbz11LnByb2Nlc3MsYz11LnNldEltbWVkaWF0ZSxwPXUuY2xlYXJJbW1lZGlhdGUsbD11Lk1lc3NhZ2VDaGFubmVsLHk9dS5EaXNwYXRjaCx4PTAsYj17fSxFPSJvbnJlYWR5c3RhdGVjaGFuZ2UiLHYsTSxpLGE9ZnVuY3Rpb24oKXt2YXIgZj0rdGhpcztpZihiLmhhc093blByb3BlcnR5KGYpKXt2YXIgTz1iW2ZdO2RlbGV0ZSBiW2ZdLE8oKX19LHM9ZnVuY3Rpb24oZil7YS5jYWxsKGYuZGF0YSl9OyghY3x8IXApJiYoYz1mdW5jdGlvbihPKXtmb3IodmFyIEE9W10sUj0xO2FyZ3VtZW50cy5sZW5ndGg+UjspQS5wdXNoKGFyZ3VtZW50c1tSKytdKTtyZXR1cm4gYlsrK3hdPWZ1bmN0aW9uKCl7bih0eXBlb2YgTz09ImZ1bmN0aW9uIj9POkZ1bmN0aW9uKE8pLEEpfSx2KHgpLHh9LHA9ZnVuY3Rpb24oTyl7ZGVsZXRlIGJbT119LHQoODYpKG8pPT0icHJvY2VzcyI/dj1mdW5jdGlvbihmKXtvLm5leHRUaWNrKHIoYSxmLDEpKX06eSYmeS5ub3c/dj1mdW5jdGlvbihmKXt5Lm5vdyhyKGEsZiwxKSl9Omw/KE09bmV3IGwsaT1NLnBvcnQyLE0ucG9ydDEub25tZXNzYWdlPXMsdj1yKGkucG9zdE1lc3NhZ2UsaSwxKSk6dS5hZGRFdmVudExpc3RlbmVyJiZ0eXBlb2YgcG9zdE1lc3NhZ2U9PSJmdW5jdGlvbiImJiF1LmltcG9ydFNjcmlwdHM/KHY9ZnVuY3Rpb24oZil7dS5wb3N0TWVzc2FnZShmKyIiLCIqIil9LHUuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIscywhMSkpOkUgaW4gZygic2NyaXB0Iik/dj1mdW5jdGlvbihmKXtkLmFwcGVuZENoaWxkKGcoInNjcmlwdCIpKVtFXT1mdW5jdGlvbigpe2QucmVtb3ZlQ2hpbGQodGhpcyksYS5jYWxsKGYpfX06dj1mdW5jdGlvbihmKXtzZXRUaW1lb3V0KHIoYSxmLDEpLDApfSksaC5leHBvcnRzPXtzZXQ6YyxjbGVhcjpwfX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCxyLG4pe3ZhciBkPW49PT12b2lkIDA7c3dpdGNoKHIubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGQ/dCgpOnQuY2FsbChuKTtjYXNlIDE6cmV0dXJuIGQ/dChyWzBdKTp0LmNhbGwobixyWzBdKTtjYXNlIDI6cmV0dXJuIGQ/dChyWzBdLHJbMV0pOnQuY2FsbChuLHJbMF0sclsxXSk7Y2FzZSAzOnJldHVybiBkP3QoclswXSxyWzFdLHJbMl0pOnQuY2FsbChuLHJbMF0sclsxXSxyWzJdKTtjYXNlIDQ6cmV0dXJuIGQ/dChyWzBdLHJbMV0sclsyXSxyWzNdKTp0LmNhbGwobixyWzBdLHJbMV0sclsyXSxyWzNdKX1yZXR1cm4gdC5hcHBseShuLHIpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTEpLG49dCgxOTUpLnNldCxkPXIuTXV0YXRpb25PYnNlcnZlcnx8ci5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLGc9ci5wcm9jZXNzLHU9ci5Qcm9taXNlLG89dCg4NikoZyk9PSJwcm9jZXNzIjtoLmV4cG9ydHM9ZnVuY3Rpb24oKXt2YXIgYyxwLGwseT1mdW5jdGlvbigpe3ZhciB2LE07Zm9yKG8mJih2PWcuZG9tYWluKSYmdi5leGl0KCk7Yzspe009Yy5mbixjPWMubmV4dDt0cnl7TSgpfWNhdGNoKGkpe3Rocm93IGM/bCgpOnA9dm9pZCAwLGl9fXA9dm9pZCAwLHYmJnYuZW50ZXIoKX07aWYobylsPWZ1bmN0aW9uKCl7Zy5uZXh0VGljayh5KX07ZWxzZSBpZihkJiYhKHIubmF2aWdhdG9yJiZyLm5hdmlnYXRvci5zdGFuZGFsb25lKSl7dmFyIHg9ITAsYj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiIik7bmV3IGQoeSkub2JzZXJ2ZShiLHtjaGFyYWN0ZXJEYXRhOiEwfSksbD1mdW5jdGlvbigpe2IuZGF0YT14PSF4fX1lbHNlIGlmKHUmJnUucmVzb2x2ZSl7dmFyIEU9dS5yZXNvbHZlKHZvaWQgMCk7bD1mdW5jdGlvbigpe0UudGhlbih5KX19ZWxzZSBsPWZ1bmN0aW9uKCl7bi5jYWxsKHIseSl9O3JldHVybiBmdW5jdGlvbih2KXt2YXIgTT17Zm46dixuZXh0OnZvaWQgMH07cCYmKHAubmV4dD1NKSxjfHwoYz1NLGwoKSkscD1NfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk0KTtmdW5jdGlvbiBuKGQpe3ZhciBnLHU7dGhpcy5wcm9taXNlPW5ldyBkKGZ1bmN0aW9uKG8sYyl7aWYoZyE9PXZvaWQgMHx8dSE9PXZvaWQgMCl0aHJvdyBUeXBlRXJyb3IoIkJhZCBQcm9taXNlIGNvbnN0cnVjdG9yIik7Zz1vLHU9Y30pLHRoaXMucmVzb2x2ZT1yKGcpLHRoaXMucmVqZWN0PXIodSl9aC5leHBvcnRzLmY9ZnVuY3Rpb24oZCl7cmV0dXJuIG5ldyBuKGQpfX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybntlOiExLHY6dCgpfX1jYXRjaChyKXtyZXR1cm57ZTohMCx2OnJ9fX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkxKSxuPXIubmF2aWdhdG9yO2guZXhwb3J0cz1uJiZuLnVzZXJBZ2VudHx8IiJ9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk3KSxuPXQoOTgpLGQ9dCgxOTgpO2guZXhwb3J0cz1mdW5jdGlvbihnLHUpe2lmKHIoZyksbih1KSYmdS5jb25zdHJ1Y3Rvcj09PWcpcmV0dXJuIHU7dmFyIG89ZC5mKGcpLGM9by5yZXNvbHZlO3JldHVybiBjKHUpLG8ucHJvbWlzZX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkwKSxuPXQoOTIpLGQ9dCg5MSksZz10KDE5NCksdT10KDIwMSk7cihyLlArci5SLCJQcm9taXNlIix7ZmluYWxseTpmdW5jdGlvbihvKXt2YXIgYz1nKHRoaXMsbi5Qcm9taXNlfHxkLlByb21pc2UpLHA9dHlwZW9mIG89PSJmdW5jdGlvbiI7cmV0dXJuIHRoaXMudGhlbihwP2Z1bmN0aW9uKGwpe3JldHVybiB1KGMsbygpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGx9KX06byxwP2Z1bmN0aW9uKGwpe3JldHVybiB1KGMsbygpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgbH0pfTpvKX19KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApLG49dCgxOTgpLGQ9dCgxOTkpO3Ioci5TLCJQcm9taXNlIix7dHJ5OmZ1bmN0aW9uKGcpe3ZhciB1PW4uZih0aGlzKSxvPWQoZyk7cmV0dXJuKG8uZT91LnJlamVjdDp1LnJlc29sdmUpKG8udiksdS5wcm9taXNlfX0pfSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMjA1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoMjA2KSxoLmV4cG9ydHM9dCg5MikuT2JqZWN0LmtleXN9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEyNCksbj10KDExMCk7dCgyMDcpKCJrZXlzIixmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihnKXtyZXR1cm4gbihyKGcpKX19KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApLG49dCg5MiksZD10KDEwMSk7aC5leHBvcnRzPWZ1bmN0aW9uKGcsdSl7dmFyIG89KG4uT2JqZWN0fHx7fSlbZ118fE9iamVjdFtnXSxjPXt9O2NbZ109dShvKSxyKHIuUytyLkYqZChmdW5jdGlvbigpe28oMSl9KSwiT2JqZWN0IixjKX19LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9dCg3Niksbj1iKHIpLGQ9dCgyMDkpLGc9YihkKSx1PXQoMTY0KSxvPWIodSksYz10KDE5MSkscD1iKGMpO2UuZGVmZXI9RSxlLnBlcmlvZGljaXR5PXYsZS5jYWxjdWxhdGVGcmFtZXNPZmZzZXQ9TSxlLmdldFByb2dyZXNzPWksZS5nZXRDdXJyZW50RnJhbWU9czt2YXIgbD10KDE4OCkseT10KDE4NykseD1iKHkpO2Z1bmN0aW9uIGIoZil7cmV0dXJuIGYmJmYuX19lc01vZHVsZT9mOntkZWZhdWx0OmZ9fWZ1bmN0aW9uIEUoKXt2YXIgZj17fTtyZXR1cm4gZi5wcm9taXNlPW5ldyBwLmRlZmF1bHQoZnVuY3Rpb24oTyxBKXtmLnJlc29sdmU9TyxmLnJlamVjdD1BfSksZn1mdW5jdGlvbiB2KGYsTyl7dmFyIEE9TWF0aC5mbG9vcihmL08pLFI9Zi1BKk87cmV0dXJuIFI9PT0wJiZBPjAmJihSPU8sQS0tKSxbQSxSXX1mdW5jdGlvbiBNKGYpe2Y9Zi5zbGljZSgwKTt2YXIgTz1mWzBdLEE9ZltmLmxlbmd0aC0xXTtBLm9mZnNldD1BLm9mZnNldHx8MSxPLm9mZnNldD1PLm9mZnNldHx8MDtmb3IodmFyIFI9MCxJPS0xLFA9MDtQPGYubGVuZ3RoO1ArKyl7dmFyIEw9ZltQXTtpZihMLm9mZnNldCE9bnVsbCl7dmFyIEQ9UC1JO2lmKEQ+MSlmb3IodmFyIEM9KEwub2Zmc2V0LVIpL0QsUz0wO1M8RC0xO1MrKylmW0krUysxXS5vZmZzZXQ9UitDKihTKzEpO1I9TC5vZmZzZXQsST1QfWlmKEwuZWFzaW5nIT1udWxsJiYoTC5lYXNpbmc9KDAsbC5wYXJzZUVhc2luZykoTC5lYXNpbmcpKSxQPjApe3ZhciBCPWZbUF0uZWFzaW5nIT1udWxsO2ZbUF09KDAsby5kZWZhdWx0KSh7fSxmW1AtMV0sZltQXSksQnx8ZGVsZXRlIGZbUF0uZWFzaW5nfX1yZXR1cm4gZn1mdW5jdGlvbiBpKGYsTyxBKXt2YXIgUj1mLmN1cnJlbnRUaW1lLEk9Ty5kaXJlY3Rpb24sUD1PLmR1cmF0aW9uLEw9ITE7aWYoST09PSJyZXZlcnNlIilBPTEtQSxMPSEwO2Vsc2UgaWYoST09PSJhbHRlcm5hdGUifHxJPT09ImFsdGVybmF0ZS1yZXZlcnNlIil7dmFyIEQ9TWF0aC5mbG9vcihSL1ApO0E9PT0xJiZELS0sRCUyXkk9PT0iYWx0ZXJuYXRlLXJldmVyc2UiJiYoQT0xLUEsTD0hMCl9cmV0dXJue3A6QSxpbnZlcnRlZDpMfX1mdW5jdGlvbiBhKGYsTyxBLFIpe3ZhciBJPXt9O3JldHVybigwLGcuZGVmYXVsdCkoTykuZm9yRWFjaChmdW5jdGlvbihQKXt2YXIgTD0oMCxuLmRlZmF1bHQpKFAsMiksRD1MWzBdLEM9TFsxXTtpZihEIT09Im9mZnNldCImJkQhPT0iZWFzaW5nIil7dmFyIFM9QVtEXXx8QS5kZWZhdWx0LEI9UyhmW0RdLEMsUixmLm9mZnNldCxPLm9mZnNldCk7QiE9bnVsbCYmKElbRF09Qil9fSksSX1mdW5jdGlvbiBzKGYsTyxBLFIpe3ZhciBJPWYuZWFzaW5nLFA9Zi5lZmZlY3Q7UHx8KEE9KDAsby5kZWZhdWx0KSh7fSx4LmRlZmF1bHQsQSkpO3ZhciBMPXt9O1I9SShSLE8pO2Zvcih2YXIgRD0xO0Q8Ty5sZW5ndGg7RCsrKXt2YXIgQz1PW0RdLFM9Qy5vZmZzZXQ7aWYoUz49Unx8RD09PU8ubGVuZ3RoLTEpe3ZhciBCPU9bRC0xXSx3PUIub2Zmc2V0LEg9Qi5lYXNpbmcsWj1SO2lmKEgpe3ZhciBxPVMtdztaPUgoKFItdykvcSkqcSt3fVA/TD1QKEIsQyxaLHcsUyk6TD1hKEIsQyxBLFopO2JyZWFrfX1yZXR1cm4gTH19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMTApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihoLGUsdCl7dCgyMTEpLGguZXhwb3J0cz10KDkyKS5PYmplY3QuZW50cmllc30sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApLG49dCgyMTIpKCEwKTtyKHIuUywiT2JqZWN0Iix7ZW50cmllczpmdW5jdGlvbihnKXtyZXR1cm4gbihnKX19KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTAwKSxuPXQoMTEwKSxkPXQoODQpLGc9dCgxNjkpLmY7aC5leHBvcnRzPWZ1bmN0aW9uKHUpe3JldHVybiBmdW5jdGlvbihvKXtmb3IodmFyIGM9ZChvKSxwPW4oYyksbD1wLmxlbmd0aCx5PTAseD1bXSxiO2w+eTspYj1wW3krK10sKCFyfHxnLmNhbGwoYyxiKSkmJngucHVzaCh1P1tiLGNbYl1dOmNbYl0pO3JldHVybiB4fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9bmV3IE1hcDtmdW5jdGlvbiBuKGcsdT17fSxvPVtdKXtnPWcudG9Mb3dlckNhc2UoKTtjb25zdCBjPXIuZ2V0KGcpO2lmKCFjKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgbm9kZTogJHtnfWApO2NvbnN0IHA9bmV3IGModSk7cmV0dXJuIG8uZm9yRWFjaChsPT57cC5hcHBlbmRDaGlsZChsKX0pLHB9Y29uc3QgZD17cmVnaXN0ZXJOb2RlKGcsdSxvPTEwMCl7aWYodT11LnRvTG93ZXJDYXNlKCksci5oYXModSkpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IHJlZ2lzdGVyTm9kZSwgJHt1fSBoYXMgYmVlbiB0YWtlbi5gKTtyLnNldCh1LGcpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGcucHJvdG90eXBlLHtub2RlVHlwZTp7dmFsdWU6b30sdGFnTmFtZTp7dmFsdWU6dS50b1VwcGVyQ2FzZSgpfSxub2RlTmFtZTp7dmFsdWU6dX0sb3duZXJEb2N1bWVudDp7dmFsdWU6ZH0sbmFtZXNwYWNlVVJJOnt2YWx1ZTpgaHR0cDovL3Nwcml0ZWpzLmNvbS8ke3V9YH19KX0sY3JlYXRlRWxlbWVudDpuLGNyZWF0ZUVsZW1lbnROUyhnLHUpe3JldHVybiBuKHUpfSxpc1Nwcml0ZU5vZGUoZyl7cmV0dXJuIHIuaGFzKGcudG9Mb3dlckNhc2UoKSl9fTtlLmRlZmF1bHQ9ZH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPVN5bWJvbCgidHlwZSIpLG49U3ltYm9sKCJidWJibGVzIiksZD1TeW1ib2woIm9yaWdpbmFsRXZlbnQiKSxnPVN5bWJvbCgiZGV0YWlsIik7Y2xhc3MgdXtjb25zdHJ1Y3RvcihjLHtidWJibGVzOnA9bnVsbH09e30pe2lmKHR5cGVvZiBjPT0ic3RyaW5nIj8odGhpc1tyXT1jLHRoaXNbbl09ISFwKToodGhpc1tyXT1jLnR5cGUsdGhpc1tkXT1jLHRoaXNbbl09cCE9bnVsbD8hIXA6ISFjLmJ1YmJsZXMsYy5kZXRhaWwmJih0aGlzW2ddPWMuZGV0YWlsKSksIXRoaXNbcl0pdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBldmVudCB0eXBlLiIpO3RoaXMuY2FuY2VsQnViYmxlPSExfXNldE9yaWdpbmFsRXZlbnQoYyl7dGhpc1tkXT1jfWdldCBvcmlnaW5hbEV2ZW50KCl7cmV0dXJuIHRoaXNbZF19Z2V0IHR5cGUoKXtyZXR1cm4gdGhpc1tyXX1nZXQgYnViYmxlcygpe3JldHVybiB0aGlzW25dfWdldCBkZXRhaWwoKXtyZXR1cm4gdGhpc1tnXX1zdG9wUHJvcGFnYXRpb24oKXt0aGlzLmNhbmNlbEJ1YmJsZT0hMH19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJwYXJzZUZpbHRlclN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJhcHBseUZpbHRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbihnKXtpZihnPWcudHJpbSgpLCFnfHxnPT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IHU9L14oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrJC9pLG89Zy5tYXRjaCgvKD86KHVybHxibHVyfGJyaWdodG5lc3N8Y29udHJhc3R8ZHJvcC1zaGFkb3d8Z3JheXNjYWxlfGh1ZS1yb3RhdGV8aW52ZXJ0fG9wYWNpdHl8c2F0dXJhdGV8c2VwaWEpXCgoW14oKV0qKD86XCguKlwpKSpbXigpXSopXCkpKz8vaWcpLGM9W107cmV0dXJuIG8mJm8uZm9yRWFjaChwPT57Y29uc3QgbD1wLm1hdGNoKHUpO2lmKCFsKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZml0bGVyIHN0cmluZy4iKTtsZXRbLHkseF09bDt5PXkudG9Mb3dlckNhc2UoKSx4PXgudHJpbSgpLm1hdGNoKC8oW14oICldK3woW14oICldK1woLipcKSkpKD89XHN8JCkvZykubWFwKChiLEUpPT57bGV0IHY7cmV0dXJuIHk9PT0idXJsInx8eT09PSJkcm9wLXNoYWRvdyImJkU9PT0zP3Y9Yjp2PU9iamVjdChyLnRvTnVtYmVyKShiKSwvJSQvLnRlc3QoYikmJih2Lz0xMDApLHZ9KSxjLnB1c2goe3R5cGU6eSxhcmdzOnh9KX0pLGN9ZnVuY3Rpb24gZChnLHUpe2cuY2xlYXJGaWx0ZXIoKSx1JiZ1LmZvckVhY2goKHt0eXBlOm8sYXJnczpjfSk9PntsZXQgcD1vO3A9PT0iZHJvcC1zaGFkb3ciP3A9ImRyb3BTaGFkb3ciOnA9PT0iaHVlLXJvdGF0ZSImJihwPSJodWVSb3RhdGUiKSxnW3BdKC4uLmMpfSl9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIobixkKXtpZighZClyZXR1cm47Y29uc3QgZz1uLmdldExpc3RlbmVycygiYmVmb3JlcmVuZGVyIiksdT1uLmdldExpc3RlbmVycygiYWZ0ZXJyZW5kZXIiKTtnLmxlbmd0aCYmIWQuYmVmb3JlUmVuZGVyP2QuYmVmb3JlUmVuZGVyPW89PntuLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImJlZm9yZXJlbmRlciIsZGV0YWlsOntjb250ZXh0Om99fSl9OmcubGVuZ3RofHwoZC5iZWZvcmVSZW5kZXI9bnVsbCksdS5sZW5ndGgmJiFkLmFmdGVyUmVuZGVyP2QuYWZ0ZXJSZW5kZXI9bz0+e24uZGlzcGF0Y2hFdmVudCh7dHlwZToiYWZ0ZXJyZW5kZXIiLGRldGFpbDp7Y29udGV4dDpvfX0pfTp1Lmxlbmd0aHx8KGQuYWZ0ZXJSZW5kZXI9bnVsbCl9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgxMiksbj10KDIxOCksZD10KDcwKSxnPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgdT1TeW1ib2woImFtb3VudCIpLG89U3ltYm9sKCJtZXNoQ2xvdWQiKTtjbGFzcyBjIGV4dGVuZHMgZC5kZWZhdWx0e2NvbnN0cnVjdG9yKGwseT0xKXtzdXBlcigpLHRoaXMubWVzaE5vZGU9bCxsLmNvbm5lY3QodGhpcyksdGhpc1t1XT15LHRoaXNbb109bnVsbH1nZXQgbWVzaENsb3VkKCl7Y29uc3QgbD10aGlzLm1lc2hOb2RlLHk9dGhpc1t1XTtyZXR1cm4hdGhpc1tvXSYmbC5tZXNoJiYodGhpc1tvXT1uZXcgci5NZXNoQ2xvdWQobC5tZXNoLHkpKSx0aGlzW29dfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hIXRoaXMubWVzaE5vZGUmJnRoaXMubWVzaE5vZGUuaXNWaXNpYmxlfWdldCBhbW91bnQoKXtyZXR1cm4gdGhpc1t1XX1zZXQgYW1vdW50KGwpe3RoaXNbdV09bCx0aGlzW29dJiYodGhpc1tvXS5hbW91bnQ9bCl9YnJpZ2h0bmVzcyhsLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuYnJpZ2h0bmVzcyhsLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9Y29udHJhc3QobCx5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmNvbnRyYXN0KGwseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1kZWxldGUobCl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5kZWxldGUobCksdGhpc1t1XS0tLHRoaXMuZm9yY2VVcGRhdGUoKSl9ZHJhdyhsPVtdKXtpZihzdXBlci5kcmF3KGwpLHRoaXMubWVzaENsb3VkKXtpZih0aGlzLnByb2dyYW0pe3RoaXMubWVzaENsb3VkLnNldFByb2dyYW0odGhpcy5wcm9ncmFtKTtjb25zdCB5PXRoaXMuc2hhZGVyQXR0cnM7eSYmT2JqZWN0LmVudHJpZXMoeSkuZm9yRWFjaCgoW2IsRV0pPT57dGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRBdHRyaWJ1dGUoYixFKX0pO2NvbnN0IHg9dGhpcy51bmlmb3JtcztpZih0aGlzLnVuaWZvcm1zKXtjb25zdCBiPXt9O09iamVjdC5lbnRyaWVzKHgpLmZvckVhY2goKFtFLHZdKT0+e3R5cGVvZiB2PT0iZnVuY3Rpb24iJiYodj12KHRoaXMsRSkpLGJbRV09dn0pLHRoaXMubWVzaENsb3VkLm1lc2guc2V0VW5pZm9ybXMoYil9fXRoaXMubWVzaE5vZGUudGV4dHVyZUltYWdlJiZPYmplY3Qobi5kcmF3VGV4dHVyZSkodGhpcy5tZXNoTm9kZSx0aGlzLm1lc2hOb2RlLm1lc2gpLGwucHVzaCh0aGlzLm1lc2hDbG91ZCl9cmV0dXJuIGx9Z2V0VHJhbnNmb3JtKGwpe2lmKHRoaXMubWVzaENsb3VkKXJldHVybiB0aGlzLm1lc2hDbG91ZC5nZXRUcmFuc2Zvcm0obCl9Z3JheXNjYWxlKGwseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5ncmF5c2NhbGUobCx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWh1ZVJvdGF0ZShsLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaHVlUm90YXRlKGwseSksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pbnZlcnQobCx5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmludmVydChsLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9aXNQb2ludENvbGxpc2lvbihsLHkpe2lmKCF0aGlzLm1lc2hDbG91ZClyZXR1cm4hMTtjb25zdCB4PXRoaXMuYXR0cmlidXRlcy5wb2ludGVyRXZlbnRzO2lmKHg9PT0ibm9uZSJ8fHghPT0iYWxsIiYmIXRoaXMuaXNWaXNpYmxlKXJldHVybiExO2xldCBiPSJib3RoIjt4PT09InZpc2libGVGaWxsIiYmKGI9ImZpbGwiKSx4PT09InZpc2libGVTdHJva2UiJiYoYj0ic3Ryb2tlIik7Zm9yKGxldCBFPTA7RTx0aGlzW3VdO0UrKylpZighdGhpcy5tZXNoQ2xvdWQuaXNQb2ludENvbGxpc2lvbihFLFtsLHldLGIpKXJldHVybiExO3JldHVybiEwfXNldE9wYWNpdHkobCx5KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLm9wYWNpdHkobCx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXJvdGF0ZShsLHksW3gsYl09WzAsMF0pe2NvbnN0IEU9TWF0aC5QSSp5LzE4MDtpZih0aGlzLm1lc2hDbG91ZCl7Y29uc3R7eDp2LHk6TX09dGhpcy5tZXNoTm9kZS5hdHRyaWJ1dGVzO3RoaXMubWVzaENsb3VkLnJvdGF0ZShsLEUsW3grdixiK01dKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNhdHVyYXRlKGwseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zYXR1cmF0ZShsLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2NhbGUobCxbeSx4PXldLFtiLEVdPVswLDBdKXtpZih0aGlzLm1lc2hDbG91ZCl7Y29uc3R7eDp2LHk6TX09dGhpcy5tZXNoTm9kZS5hdHRyaWJ1dGVzLGk9MWUtNTtNYXRoLmFicyh5KTxpJiYoeT0xL3k+MD9pOi1pKSxNYXRoLmFicyh4KTxpJiYoeD0xL3g+MD9pOi1pKSx0aGlzLm1lc2hDbG91ZC5zY2FsZShsLFt5LHhdLFtiK3YsRStNXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX1zZXRDb2xvclRyYW5zZm9ybShsLHkpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2V0Q29sb3JUcmFuc2Zvcm0obCx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNldEZpbGxDb2xvcihsLHkpe3RoaXMubWVzaENsb3VkJiYoQXJyYXkuaXNBcnJheSh5KSYmKHk9Wy4uLnldLHlbMF0vPTI1NSx5WzFdLz0yNTUseVsyXS89MjU1KSx0aGlzLm1lc2hDbG91ZC5zZXRGaWxsQ29sb3IobCx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNlcGlhKGwseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXBpYShsLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0UmVzb2x1dGlvbih7d2lkdGg6bCxoZWlnaHQ6eX0pe3N1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOmwsaGVpZ2h0Onl9KSx0aGlzLm1lc2hOb2RlLnNldFJlc29sdXRpb24oe3dpZHRoOmwsaGVpZ2h0Onl9KX1zZXRTdHJva2VDb2xvcihsLHkpe3RoaXMubWVzaENsb3VkJiYoQXJyYXkuaXNBcnJheSh5KSYmKHk9Wy4uLnldLHlbMF0vPTI1NSx5WzFdLz0yNTUseVsyXS89MjU1KSx0aGlzLm1lc2hDbG91ZC5zZXRTdHJva2VDb2xvcihsLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0VHJhbnNmb3JtKGwseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRUcmFuc2Zvcm0obCx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNrZXcobCxbeSx4PXldLFtiLEVdPVswLDBdKXtpZih0aGlzLm1lc2hDbG91ZCl7Y29uc3R7eDp2LHk6TX09dGhpcy5tZXNoTm9kZS5hdHRyaWJ1dGVzO3RoaXMubWVzaENsb3VkLnNrZXcobCxbeSx4XSxbYit2LEUrTV0pLHRoaXMuZm9yY2VVcGRhdGUoKX19dHJhbnNmb3JtKGwseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2Zvcm0obCx5KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRyYW5zZm9ybUNvbG9yKGwseSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2Zvcm1Db2xvcihsLHkpLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNsYXRlKGwsW3kseF0pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQudHJhbnNsYXRlKGwsW3kseF0pLHRoaXMuZm9yY2VVcGRhdGUoKSl9dXBkYXRlTWVzaCgpe3RoaXNbb10mJih0aGlzW29dLm1lc2g9dGhpcy5tZXNoTm9kZS5tZXNoLHRoaXMuZm9yY2VVcGRhdGUoKSl9fWcuZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywiY2xvdWQiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwibG9hZFRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiYXBwbHlUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImNyZWF0ZVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZGVsZXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJkcmF3VGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJsb2FkRnJhbWVzIixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIHI9dCgxMiksbj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD17fTtmdW5jdGlvbiBnKGIsRSl7aWYoZFtiXSlyZXR1cm4gZFtiXTtjb25zdCB2PXIuRU5WLmxvYWRJbWFnZShiLHthbGlhczpFLHVzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIHY/P2J9YXN5bmMgZnVuY3Rpb24gdShiLEUsdil7bGV0IE09RTtpZih0eXBlb2YgRT09InN0cmluZyImJihNPWcoRSkpLE0mJnR5cGVvZiBNLnRoZW49PSJmdW5jdGlvbiImJihNPWF3YWl0IE0pLEU9PT1iLmF0dHJpYnV0ZXMudGV4dHVyZSl7TSYmTS5pbWFnZSYmKE0uc291cmNlUmVjdCYmKGIuYXR0cmlidXRlcy5zb3VyY2VSZWN0PU0uc291cmNlUmVjdCksYi50ZXh0dXJlSW1hZ2VSb3RhdGVkPSEhTS5yb3RhdGVkLE09TS5pbWFnZSk7Y29uc3R7d2lkdGg6aSxoZWlnaHQ6YSx0ZXh0dXJlUmVjdDpzfT1iLmF0dHJpYnV0ZXMsZj1iLnRleHR1cmVJbWFnZTtiLnRleHR1cmVJbWFnZT1NLHYmJmYhPT1NJiYhcyYmKGk9PW51bGx8fGE9PW51bGwpJiZiLnVwZGF0ZUNvbnRvdXJzKCksYi5mb3JjZVVwZGF0ZSgpfXJldHVybiBNfWNvbnN0IG89U3ltYm9sKCJ0ZXh0dXJlTWFwIik7ZnVuY3Rpb24gYyhiLEUpe2lmKEVbb109RVtvXXx8bmV3IE1hcCxFW29dLmhhcyhiKSlyZXR1cm4gRVtvXS5nZXQoYik7Y29uc3Qgdj1FLmNyZWF0ZVRleHR1cmUoYik7cmV0dXJuIS9eYmxvYjovLnRlc3QoYi5zcmMpJiZ0eXBlb2YgYi5nZXRDb250ZXh0IT0iZnVuY3Rpb24iJiZFW29dLnNldChiLHYpLHZ9ZnVuY3Rpb24gcChiLEUpe2lmKEVbb10mJkVbb10uaGFzKGIpKXtjb25zdCB2PUVbb10uZ2V0KGIpO3JldHVybiBFLmRlbGV0ZVRleHR1cmUodiksRVtvXS5kZWxldGUoYiksITB9cmV0dXJuITF9Y29uc3QgbD1TeW1ib2woInRleHR1cmVDb250ZXh0Iik7ZnVuY3Rpb24geShiLEUpe2NvbnN0IHY9Yi50ZXh0dXJlSW1hZ2UgaW5zdGFuY2VvZiBTdHJpbmc/U3RyaW5nKGIudGV4dHVyZUltYWdlKTpiLnRleHR1cmVJbWFnZSxNPWIudGV4dHVyZUltYWdlUm90YXRlZCxpPUUudGV4dHVyZSxhPWIucmVuZGVyZXI7aWYodil7Y29uc3Qgcz1iLm9yaWdpbmFsQ29udGVudFJlY3Q7bGV0IGY9Yi5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0O2NvbnN0IE89Yi5hdHRyaWJ1dGVzLnRleHR1cmVSZXBlYXQsQT1iLmF0dHJpYnV0ZXMuc291cmNlUmVjdDtpZighaXx8YltsXSYmYltsXSE9PWF8fGkuaW1hZ2UhPT12fHxpLm9wdGlvbnMucmVwZWF0IT09T3x8IU9iamVjdChuLmNvbXBhcmVWYWx1ZSkoaS5vcHRpb25zLnJlY3QsZil8fCFPYmplY3Qobi5jb21wYXJlVmFsdWUpKGkub3B0aW9ucy5zcmNSZWN0LEEpKXtjb25zdCBSPWModixhKTtmPyhmWzBdKz1zWzBdLGZbMV0rPXNbMV0pOmY9cztsZXQgST1udWxsO2kmJiFhW29dLmhhcyhpLmltYWdlKSYmKCFpLm9wdGlvbnN8fCFpLm9wdGlvbnMuaGlkZGVuKSYmKEk9RS51bmlmb3Jtcy51X3RleFNhbXBsZXIpLEUuc2V0VGV4dHVyZShSLHtyZWN0OmYscmVwZWF0Ok8sc3JjUmVjdDpBLHJvdGF0ZWQ6TX0pLEkmJkkuZGVsZXRlJiZJLmRlbGV0ZSgpLGJbbF09YX19ZWxzZSBpZihpKXtsZXQgcz1udWxsOyFhW29dLmhhcyhpLmltYWdlKSYmKCFpLm9wdGlvbnN8fCFpLm9wdGlvbnMuaGlkZGVuKSYmKHM9RS51bmlmb3Jtcy51X3RleFNhbXBsZXIpLEUuc2V0VGV4dHVyZShudWxsKSxzJiZzLmRlbGV0ZSYmcy5kZWxldGUoKX19YXN5bmMgZnVuY3Rpb24geChiLEUpe3R5cGVvZiBFPT0ic3RyaW5nIiYmKEU9YXdhaXQoYXdhaXQgZmV0Y2goRSx7bWV0aG9kOiJHRVQiLG1vZGU6ImNvcnMiLGNhY2hlOiJkZWZhdWx0In0pKS5qc29uKCkpO2NvbnN0IHY9YXdhaXQgZyhiKSxNPUUuZnJhbWVzO3JldHVybiBPYmplY3QuZW50cmllcyhNKS5mb3JFYWNoKChbaSxhXSk9Pntjb25zdHt4OnMseTpmLHc6TyxoOkF9PWEuZnJhbWU7bGV0IFI9W3MsZixPLEFdO2NvbnN0IEk9YS5yb3RhdGVkO0kmJihSPVtSWzBdLFJbMV0sUlszXSxSWzJdXSksZFtpXT17aW1hZ2U6dixzb3VyY2VSZWN0OlIscm90YXRlZDpJfX0pLHZ9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIHI9dCgxKSxuPXQoMTIpLGQ9dCg3MCksZz10KDIyMCksdT10KDIyMSksbz10KDIyMiksYz10KDIxMykscD10KDIyMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwoYixFLHYpe3JldHVybiBFIGluIGI/T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsRSx7dmFsdWU6dixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmJbRV09dixifWNvbnN0IHk9U3ltYm9sKCJtZXNoIik7Y2xhc3MgeCBleHRlbmRzIGQuZGVmYXVsdHtjb25zdHJ1Y3RvcihFPXt9KXtzdXBlcihFKX1nZXQgYm9yZGVyU2l6ZSgpe2NvbnN0e3BhZGRpbmdUb3A6RSxwYWRkaW5nUmlnaHQ6dixwYWRkaW5nQm90dG9tOk0scGFkZGluZ0xlZnQ6aSxib3JkZXJXaWR0aDphfT10aGlzLmF0dHJpYnV0ZXMsW3MsZl09dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5baStzK3YrYSxFK2YrTSthXX1nZXQgY2xpZW50U2l6ZSgpe2NvbnN0e3BhZGRpbmdUb3A6RSxwYWRkaW5nUmlnaHQ6dixwYWRkaW5nQm90dG9tOk0scGFkZGluZ0xlZnQ6aX09dGhpcy5hdHRyaWJ1dGVzLFthLHNdPXRoaXMuY29udGVudFNpemU7cmV0dXJuW2krYSt2LEUrcytNXX1nZXQgY29udGVudFNpemUoKXtsZXR7d2lkdGg6RSxoZWlnaHQ6dixib3hTaXppbmc6TSxwYWRkaW5nVG9wOmkscGFkZGluZ1JpZ2h0OmEscGFkZGluZ0JvdHRvbTpzLHBhZGRpbmdMZWZ0OmZ9PXRoaXMuYXR0cmlidXRlcztpZihFPUV8fDAsdj12fHwwLE09PT0iYm9yZGVyLWJveCIpe2NvbnN0IE89Mip0aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7RS09TythK2Ysdi09TytpK3MsRT1NYXRoLm1heCgwLEUpLHY9TWF0aC5tYXgoMCx2KX1yZXR1cm5bRSx2XX1nZXQgaGFzQm9yZGVyKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aD4wfWdldCBpc1Zpc2libGUoKXtjb25zdFtFLHZdPXRoaXMuYm9yZGVyU2l6ZTtyZXR1cm4gRT4wJiZ2PjB9Z2V0IG1lc2goKXtpZih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT09PSJub25lIilyZXR1cm4gbnVsbDtjb25zdCBFPXRoaXMuY2xpZW50Qm94O2lmKEUpe2xldCB2PXRoaXNbeV07aWYodil2LmJveCE9PUUmJih2LmNvbnRvdXJzPUUuY29udG91cnMsdi5ib3g9RSk7ZWxzZXt2PW5ldyBuLk1lc2gyRChFKSx2LmJveD1FO2NvbnN0IGk9dGhpcy5hdHRyaWJ1dGVzLmJnY29sb3I7aWYoT2JqZWN0KHUuc2V0RmlsbENvbG9yKSh2LHtjb2xvcjppfSksdGhpcy5oYXNCb3JkZXIpe2NvbnN0e2JvcmRlckNvbG9yOnMsYm9yZGVyV2lkdGg6Zixib3JkZXJEYXNoOk8sYm9yZGVyRGFzaE9mZnNldDpBfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHUuc2V0U3Ryb2tlQ29sb3IpKHYse2NvbG9yOnMsbGluZVdpZHRoOmYsbGluZURhc2g6TyxsaW5lRGFzaE9mZnNldDpBfSl9dGhpc1t5XT12O2NvbnN0IGE9dGhpcy5hdHRyaWJ1dGVzLmNsaXBQYXRoO2EmJnRoaXNbeV0uc2V0Q2xpcFBhdGgoYSl9Y29uc3QgTT10aGlzLm9wYWNpdHk7cmV0dXJuIHYuZ2V0T3BhY2l0eSgpIT09TSYmdi5zZXRPcGFjaXR5KE0pLHYuc2V0VHJhbnNmb3JtKC4uLnRoaXMucmVuZGVyTWF0cml4KSx2fXJldHVybiBudWxsfWdldCBvZmZzZXRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpFLHBhZGRpbmdSaWdodDp2LHBhZGRpbmdCb3R0b206TSxwYWRkaW5nTGVmdDppLGJvcmRlcldpZHRoOmF9PXRoaXMuYXR0cmlidXRlcyxbcyxmXT10aGlzLmNvbnRlbnRTaXplLE89MiphO3JldHVybltpK3MrditPLEUrZitNK09dfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IEU9dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVybltFWzBdWzBdLEVbMF1bMV0sRVsxXVswXS1FWzBdWzBdLEVbMV1bMV0tRVswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENvbnRlbnRSZWN0KCl7Y29uc3RbRSx2LE0saV09dGhpcy5vcmlnaW5hbENsaWVudFJlY3QsYT10aGlzLmF0dHJpYnV0ZXMucGFkZGluZztyZXR1cm5bRSthWzBdLHYrYVsxXSxNLWFbMF0tYVsyXSxpLWFbMV0tYVszXV19Z2V0Qm91bmRpbmdDbGllbnRSZWN0KCl7bGV0IEU9dGhpcy5yZW5kZXJNYXRyaXg7dGhpcy5sYXllciYmdGhpcy5sYXllci5sYXllclRyYW5zZm9ybUludmVydCYmKEU9ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpcy5sYXllci50cmFuc2Zvcm1NYXRyaXgsRSkpO2xldCB2PW51bGw7aWYodGhpcy5tZXNoKXt2PVsuLi50aGlzLm1lc2guYm91bmRpbmdCb3hdO2NvbnN0IE09dGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoO00mJih2WzBdPVt2WzBdWzBdLU0sdlswXVsxXS1NXSx2WzFdPVt2WzFdWzBdK00sdlsxXVsxXStNXSl9cmV0dXJuIE9iamVjdChwLmRlZmF1bHQpKHYsRSl9b25Qcm9wZXJ0eUNoYW5nZShFLHYsTSl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShFLHYsTSksKEU9PT0iYW5jaG9yWCJ8fEU9PT0iYW5jaG9yWSJ8fEU9PT0iYm94U2l6aW5nInx8RT09PSJ3aWR0aCJ8fEU9PT0iaGVpZ2h0Inx8RT09PSJib3JkZXJXaWR0aCJ8fEU9PT0icGFkZGluZ0xlZnQifHxFPT09InBhZGRpbmdSaWdodCJ8fEU9PT0icGFkZGluZ1RvcCJ8fEU9PT0icGFkZGluZ0JvdHRvbSJ8fC9eYm9yZGVyKFRvcExlZnR8VG9wUmlnaHR8Qm90dG9tUmlnaHR8Qm90dG9tTGVmdClSYWRpdXMkLy50ZXN0KEUpKSYmdGhpcy51cGRhdGVDb250b3VycygpLHRoaXNbeV0mJkU9PT0iY2xpcFBhdGgiJiZ0aGlzW3ldLnNldENsaXBQYXRoKHYpLHRoaXNbeV0mJkU9PT0iYmdjb2xvciImJk9iamVjdCh1LnNldEZpbGxDb2xvcikodGhpc1t5XSx7Y29sb3I6dn0pLHRoaXNbeV0mJihFPT09ImJvcmRlckNvbG9yInx8RT09PSJib3JkZXJXaWR0aCJ8fEU9PT0iYm9yZGVyRGFzaCJ8fEU9PT0iYm9yZGVyRGFzaE9mZnNldCIpKXtjb25zdHtib3JkZXJDb2xvcjppLGJvcmRlcldpZHRoOmEsYm9yZGVyRGFzaDpzLGJvcmRlckRhc2hPZmZzZXQ6Zn09dGhpcy5hdHRyaWJ1dGVzO09iamVjdCh1LnNldFN0cm9rZUNvbG9yKSh0aGlzW3ldLHtjb2xvcjppLGxpbmVXaWR0aDphLGxpbmVEYXNoOmE/czowLGxpbmVEYXNoT2Zmc2V0OmZ9KX19dXBkYXRlQ29udG91cnMoKXtjb25zdHthbmNob3JYOkUsYW5jaG9yWTp2LGJvcmRlcldpZHRoOk0sYm9yZGVyUmFkaXVzOml9PXRoaXMuYXR0cmlidXRlcyxbYSxzXT10aGlzLmJvcmRlclNpemUsZj10aGlzLm9mZnNldFNpemUsTz0uNSpNLEE9LUUqZlswXStPLFI9LXYqZlsxXStPO3RoaXMuY2xpZW50Qm94PW5ldyBuLkZpZ3VyZTJELE9iamVjdChvLmNyZWF0ZVJhZGl1c0JveCkodGhpcy5jbGllbnRCb3gsW0EsUixhLHNdLGkpfX1sKHgsIkF0dHIiLGcuZGVmYXVsdCksYy5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh4LCJibG9jayIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIHI9dCg3MSksbj10KDcyKSxkPXQoMjIxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7Y2xhc3MgcCBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3Rvcih5KXtzdXBlcih5KSx0aGlzW29dKHthbmNob3JYOjAsYW5jaG9yWTowLHdpZHRoOnZvaWQgMCxoZWlnaHQ6dm9pZCAwLGJvcmRlcldpZHRoOjAsYm9yZGVyQ29sb3I6InJnYmEoMCwwLDAsMSkiLGJvcmRlckRhc2g6dm9pZCAwLGJvcmRlckRhc2hPZmZzZXQ6MCxib3JkZXJUb3BMZWZ0UmFkaXVzOlswLDBdLGJvcmRlclRvcFJpZ2h0UmFkaXVzOlswLDBdLGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOlswLDBdLGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6WzAsMF0sYmdjb2xvcjoicmdiYSgwLDAsMCwwKSIscGFkZGluZ1RvcDowLHBhZGRpbmdSaWdodDowLHBhZGRpbmdCb3R0b206MCxwYWRkaW5nTGVmdDowLGJveFNpemluZzoiY29udGVudC1ib3giLGNsaXBQYXRoOnZvaWQgMH0pLHRoaXNbY10oImFuY2hvciIsInNpemUiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJwYWRkaW5nIil9Z2V0IGFuY2hvclgoKXtyZXR1cm4gdGhpc1t1XSgiYW5jaG9yWCIpfXNldCBhbmNob3JYKHkpe3RoaXNbZ10oImFuY2hvclgiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IGFuY2hvclkoKXtyZXR1cm4gdGhpc1t1XSgiYW5jaG9yWSIpfXNldCBhbmNob3JZKHkpe3RoaXNbZ10oImFuY2hvclkiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IGFuY2hvcigpe3JldHVyblt0aGlzLmFuY2hvclgsdGhpcy5hbmNob3JZXX1zZXQgYW5jaG9yKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMuYW5jaG9yWD15WzBdLHRoaXMuYW5jaG9yWT15WzFdfWdldCB3aWR0aCgpe3JldHVybiB0aGlzW3VdKCJ3aWR0aCIpfXNldCB3aWR0aCh5KXt0aGlzW2ddKCJ3aWR0aCIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbdV0oImhlaWdodCIpfXNldCBoZWlnaHQoeSl7dGhpc1tnXSgiaGVpZ2h0IixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCBzaXplKCl7cmV0dXJuW3RoaXMud2lkdGgsdGhpcy5oZWlnaHRdfXNldCBzaXplKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMud2lkdGg9eVswXSx0aGlzLmhlaWdodD15WzFdfWdldCBib3JkZXJXaWR0aCgpe3JldHVybiB0aGlzW3VdKCJib3JkZXJXaWR0aCIpfXNldCBib3JkZXJXaWR0aCh5KXt0aGlzW2ddKCJib3JkZXJXaWR0aCIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgYm9yZGVyQ29sb3IoKXtyZXR1cm4gdGhpc1t1XSgiYm9yZGVyQ29sb3IiKX1zZXQgYm9yZGVyQ29sb3IoeSl7dGhpc1tnXSgiYm9yZGVyQ29sb3IiLE9iamVjdChkLnBhcnNlQ29sb3IpKHkpKX1nZXQgYm9yZGVyKCl7cmV0dXJuW3RoaXMuYm9yZGVyV2lkdGgsdGhpcy5ib3JkZXJDb2xvcl19c2V0IGJvcmRlcih5KXt5PU9iamVjdChuLnRvQXJyYXkpKHkpLEFycmF5LmlzQXJyYXkoeSl8fCh5PVt5XSksdGhpcy5ib3JkZXJXaWR0aD15WzBdLHlbMV0hPW51bGwmJih0aGlzLmJvcmRlckNvbG9yPXlbMV0pfWdldCBib3JkZXJEYXNoKCl7cmV0dXJuIHRoaXNbdV0oImJvcmRlckRhc2giKX1zZXQgYm9yZGVyRGFzaCh5KXt5PU9iamVjdChuLnRvQXJyYXkpKHksITApLHkhPW51bGwmJiFBcnJheS5pc0FycmF5KHkpJiYoeT1beV0pLHRoaXNbZ10oImJvcmRlckRhc2giLHk/eS5tYXAobi50b051bWJlcik6bnVsbCl9Z2V0IGJvcmRlckRhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1t1XSgiYm9yZGVyRGFzaE9mZnNldCIpfXNldCBib3JkZXJEYXNoT2Zmc2V0KHkpe3RoaXNbZ10oImJvcmRlckRhc2hPZmZzZXQiLE9iamVjdChuLnRvTnVtYmVyKSh5KSl9Z2V0IGJvcmRlclRvcExlZnRSYWRpdXMoKXtyZXR1cm4gdGhpc1t1XSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIpfXNldCBib3JkZXJUb3BMZWZ0UmFkaXVzKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXNbZ10oImJvcmRlclRvcExlZnRSYWRpdXMiLHkubWFwKG4udG9OdW1iZXIpKX1nZXQgYm9yZGVyVG9wUmlnaHRSYWRpdXMoKXtyZXR1cm4gdGhpc1t1XSgiYm9yZGVyVG9wUmlnaHRSYWRpdXMiKX1zZXQgYm9yZGVyVG9wUmlnaHRSYWRpdXMoeSl7eT1PYmplY3Qobi50b0FycmF5KSh5LCEwKSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpc1tnXSgiYm9yZGVyVG9wUmlnaHRSYWRpdXMiLHkubWFwKG4udG9OdW1iZXIpKX1nZXQgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMoKXtyZXR1cm4gdGhpc1t1XSgiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMoeSl7eT1PYmplY3Qobi50b0FycmF5KSh5LCEwKSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpc1tnXSgiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMiLHkubWFwKG4udG9OdW1iZXIpKX1nZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIil9c2V0IGJvcmRlckJvdHRvbUxlZnRSYWRpdXMoeSl7eT1PYmplY3Qobi50b0FycmF5KSh5LCEwKSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpc1tnXSgiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIseS5tYXAobi50b051bWJlcikpfWdldCBib3JkZXJSYWRpdXMoKXtyZXR1cm5bLi4udGhpcy5ib3JkZXJUb3BMZWZ0UmFkaXVzLC4uLnRoaXMuYm9yZGVyVG9wUmlnaHRSYWRpdXMsLi4udGhpcy5ib3JkZXJCb3R0b21SaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbUxlZnRSYWRpdXNdfXNldCBib3JkZXJSYWRpdXMoeSl7aWYoeT1PYmplY3Qobi50b0FycmF5KSh5KSwhQXJyYXkuaXNBcnJheSh5KSl5PUFycmF5KDgpLmZpbGwoeSk7ZWxzZSBpZih5Lmxlbmd0aD09PTIpeT1beVswXSx5WzFdLHlbMF0seVsxXSx5WzBdLHlbMV0seVswXSx5WzFdXTtlbHNlIGlmKHkubGVuZ3RoPT09NCl5PVt5WzBdLHlbMV0seVsyXSx5WzNdLHlbMF0seVsxXSx5WzJdLHlbM11dO2Vsc2UgaWYoeS5sZW5ndGg9PT02KXk9W3lbMF0seVsxXSx5WzJdLHlbM10seVs0XSx5WzVdLHlbMl0seVszXV07ZWxzZSBpZih5Lmxlbmd0aCE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3JkZXJSYWRpdXMgdmFsdWUuIik7dGhpcy5ib3JkZXJUb3BMZWZ0UmFkaXVzPVt5WzBdLHlbMV1dLHRoaXMuYm9yZGVyVG9wUmlnaHRSYWRpdXM9W3lbMl0seVszXV0sdGhpcy5ib3JkZXJCb3R0b21SaWdodFJhZGl1cz1beVs0XSx5WzVdXSx0aGlzLmJvcmRlckJvdHRvbUxlZnRSYWRpdXM9W3lbNl0seVs3XV19Z2V0IGJnY29sb3IoKXtyZXR1cm4gdGhpc1t1XSgiYmdjb2xvciIpfXNldCBiZ2NvbG9yKHkpe3RoaXNbZ10oImJnY29sb3IiLE9iamVjdChkLnBhcnNlQ29sb3IpKHkpKX1nZXQgcGFkZGluZ1RvcCgpe3JldHVybiB0aGlzW3VdKCJwYWRkaW5nVG9wIil9c2V0IHBhZGRpbmdUb3AoeSl7dGhpc1tnXSgicGFkZGluZ1RvcCIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgcGFkZGluZ1JpZ2h0KCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdSaWdodCIpfXNldCBwYWRkaW5nUmlnaHQoeSl7dGhpc1tnXSgicGFkZGluZ1JpZ2h0IixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCBwYWRkaW5nQm90dG9tKCl7cmV0dXJuIHRoaXNbdV0oInBhZGRpbmdCb3R0b20iKX1zZXQgcGFkZGluZ0JvdHRvbSh5KXt0aGlzW2ddKCJwYWRkaW5nQm90dG9tIixPYmplY3Qobi50b051bWJlcikoeSkpfWdldCBwYWRkaW5nTGVmdCgpe3JldHVybiB0aGlzW3VdKCJwYWRkaW5nTGVmdCIpfXNldCBwYWRkaW5nTGVmdCh5KXt0aGlzW2ddKCJwYWRkaW5nTGVmdCIsT2JqZWN0KG4udG9OdW1iZXIpKHkpKX1nZXQgcGFkZGluZygpe3JldHVyblt0aGlzLnBhZGRpbmdUb3AsdGhpcy5wYWRkaW5nUmlnaHQsdGhpcy5wYWRkaW5nQm90dG9tLHRoaXMucGFkZGluZ0xlZnRdfXNldCBwYWRkaW5nKHkpe3k9T2JqZWN0KG4udG9BcnJheSkoeSksQXJyYXkuaXNBcnJheSh5KT95Lmxlbmd0aD09PTI/eT1beVswXSx5WzFdLHlbMF0seVsxXV06eS5sZW5ndGg9PT0zJiYoeT1beVswXSx5WzFdLHlbMl0seVsxXV0pOnk9W3kseSx5LHldLHRoaXMucGFkZGluZ1RvcD15WzBdLHRoaXMucGFkZGluZ1JpZ2h0PXlbMV0sdGhpcy5wYWRkaW5nQm90dG9tPXlbMl0sdGhpcy5wYWRkaW5nTGVmdD15WzNdfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW3VdKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aCh5KXt0aGlzW2ddKCJjbGlwUGF0aCIseSl9Z2V0IGJveFNpemluZygpe3JldHVybiB0aGlzW3VdKCJib3hTaXppbmciKX1zZXQgYm94U2l6aW5nKHkpe2lmKHkhPW51bGwmJnkhPT0iYm9yZGVyLWJveCImJnkhPT0iY29udGVudC1ib3giKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYm94U2l6aW5nIHR5cGUuIik7dGhpc1tnXSgiYm94U2l6aW5nIix5KX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJHcmFkaWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJpc1RyYW5zcGFyZW50IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0RmlsbENvbG9yIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInNldFN0cm9rZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIHI9dCgzMiksbj10Lm4ocik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIGR7Y29uc3RydWN0b3Ioe3ZlY3Rvcjp4LGNvbG9yczpifSl7aWYoIUFycmF5LmlzQXJyYXkoeCl8fHgubGVuZ3RoIT09NCYmeC5sZW5ndGghPT02JiZ4Lmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBncmFkaWVudCIpO3RoaXMudmVjdG9yPXgsdGhpcy5jb2xvcnM9Yi5tYXAoKHtvZmZzZXQ6RSxjb2xvcjp2fSk9Pih7b2Zmc2V0OkUsY29sb3I6dSh2KX0pKX10b1N0cmluZygpe3JldHVybiBKU09OLnN0cmluZ2lmeSh7dmVjdG9yOnRoaXMudmVjdG9yLGNvbG9yczp0aGlzLmNvbG9yc30pfX1mdW5jdGlvbiBnKHkpe3JldHVybiB5IGluc3RhbmNlb2YgZD8hMTp5PT1udWxsPyEwOm4oKSh5KVszXT09PTB9ZnVuY3Rpb24gdSh5KXtpZih5PT1udWxsfHwoeXx8KHk9InRyYW5zcGFyZW50IikseSBpbnN0YW5jZW9mIGQpKXJldHVybiB5O2NvbnN0IHg9bigpKHkpO2lmKCF4fHwheC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5gcmdiYSgke3guam9pbigpfSlgfWZ1bmN0aW9uIG8oeSx4LGIpe2NvbnN0IEU9eS5ib3VuZGluZ0JveFswXTtpZihiLnZlY3Rvcil7bGV0e3ZlY3Rvcjp2LGNvbG9yczpNfT1iO3YubGVuZ3RoPT09ND8odj1bdlswXStFWzBdLHZbMV0rRVsxXSx2WzJdK0VbMF0sdlszXStFWzFdXSx5LnNldExpbmVhckdyYWRpZW50KHt2ZWN0b3I6dixjb2xvcnM6TSx0eXBlOnh9KSk6di5sZW5ndGg9PT0zPyh2PVt2WzBdK0VbMF0sdlsxXStFWzFdLHZbMl1dLHkuc2V0Q2lyY3VsYXJHcmFkaWVudCh7dmVjdG9yOnYsY29sb3JzOk0sdHlwZTp4fSkpOih2PVt2WzBdK0VbMF0sdlsxXStFWzFdLHZbMl0sdlszXStFWzBdLHZbNF0rRVsxXSx2WzVdXSx5LnNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6dixjb2xvcnM6TSx0eXBlOnh9KSl9ZWxzZSB5LmdyYWRpZW50JiZ5LmdyYWRpZW50W3hdJiYoZGVsZXRlIHkuZ3JhZGllbnRbeF0sZGVsZXRlIHkudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3Rvcil9ZnVuY3Rpb24gYyh5LHtjb2xvcjp4LHJ1bGU6Yj0ibm9uemVybyJ9KXtyZXR1cm4gbyh5LCJmaWxsIix4KSx4LnZlY3Rvcnx8eS5zZXRGaWxsKHtjb2xvcjp4LHJ1bGU6Yn0pLHl9ZnVuY3Rpb24gcCh5LHtjb2xvcjp4LGxpbmVXaWR0aDpiLGxpbmVDYXA6RSxsaW5lSm9pbjp2LGxpbmVEYXNoOk0sbGluZURhc2hPZmZzZXQ6aSxtaXRlckxpbWl0OmEscm91bmRTZWdtZW50czpzfSl7byh5LCJzdHJva2UiLHgpLHgudmVjdG9yJiYoeD1bMCwwLDAsMV0pLHkuc2V0U3Ryb2tlKHtjb2xvcjp4LHRoaWNrbmVzczpiLGNhcDpFLGpvaW46dixtaXRlckxpbWl0OmEsbGluZURhc2g6TSxsaW5lRGFzaE9mZnNldDppLHJvdW5kU2VnbWVudHM6c30pfWNsYXNzIGwgZXh0ZW5kcyBBcnJheXtjb25zdHJ1Y3Rvcih4PTAsYj0wLEU9MCx2PTApe3JldHVybiBBcnJheS5pc0FycmF5KHgpJiYoW3gsYixFLHZdPXgpLHR5cGVvZiB4PT0ic3RyaW5nIiYmKFt4LGIsRSx2XT1uKCkoeCkseC89MjU1LGIvPTI1NSxFLz0yNTUpLHN1cGVyKHgsYixFLHYpLHRoaXN9Z2V0IHIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzBdKjI1NSl9c2V0IHIoeCl7dGhpc1swXT14LzI1NX1nZXQgZygpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMV0qMjU1KX1zZXQgZyh4KXt0aGlzWzFdPXgvMjU1fWdldCBiKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1syXSoyNTUpfXNldCBiKHgpe3RoaXNbMl09eC8yNTV9Z2V0IGEoKXtyZXR1cm4gdGhpc1szXX1zZXQgYSh4KXt0aGlzWzNdPXh9Z2V0IGhleCgpe2NvbnN0IHg9YDAke3RoaXMuci50b1N0cmluZygxNil9YC5zbGljZSgtMiksYj1gMCR7dGhpcy5nLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxFPWAwJHt0aGlzLmIudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpO2xldCB2O3JldHVybiB0aGlzLmE8MSYmKHY9TWF0aC5yb3VuZCh0aGlzWzNdKjI1NSksdj1gMCR7di50b1N0cmluZygxNil9YC5zbGljZSgtMikpLGAjJHt4fSR7Yn0ke0V9JHt2fHwiIn1gfWdldCByZ2JhKCl7cmV0dXJuYHJnYmEoJHt0aGlzLnJ9LCR7dGhpcy5nfSwke3RoaXMuYn0sJHt0aGlzLmF9KWB9ZnJvbUNvbG9yKHgpe3JldHVybiB0eXBlb2YgeD09InN0cmluZyImJih4PW4oKSh4KSx4WzBdLz0yNTUseFsxXS89MjU1LHhbMl0vPTI1NSksdGhpc1swXT14WzBdLHRoaXNbMV09eFsxXSx0aGlzWzJdPXhbMl0sdGhpc1szXT14WzNdLHRoaXN9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlUmFkaXVzQm94IixmdW5jdGlvbigpe3JldHVybiBufSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoZCxnLHUsbyxjLHA9ImxlZnRUb3AiKXtjb25zdCBsPS41NTIyODQ4LHk9by8yKmwseD1jLzIqbCxiPWcrbyxFPXUrYyx2PWcrby8yLE09dStjLzI7cD09PSJsZWZ0VG9wIj8oZC5tb3ZlVG8oZyxNKSxkLmJlemllckN1cnZlVG8oZyxNLXgsdi15LHUsdix1KSk6cD09PSJyaWdodFRvcCI/ZC5iZXppZXJDdXJ2ZVRvKHYreSx1LGIsTS14LGIsTSk6cD09PSJyaWdodEJvdHRvbSI/ZC5iZXppZXJDdXJ2ZVRvKGIsTSt4LHYreSxFLHYsRSk6cD09PSJsZWZ0Qm90dG9tIiYmZC5iZXppZXJDdXJ2ZVRvKHYteSxFLGcsTSt4LGcsTSl9ZnVuY3Rpb24gbihkLFtnLHUsbyxjXSxwKXtpZighcHx8QXJyYXkuaXNBcnJheShwKSYmcC5ldmVyeShsPT5sPT09MCkpZC5iZWdpblBhdGgoKSxkLnJlY3QoZyx1LG8sYyk7ZWxzZXt0eXBlb2YgcD09Im51bWJlciImJihwPUFycmF5KDgpLmZpbGwocCkpO2NvbnN0W2wseSx4LGIsRSx2LE0saV09cC5tYXAoKGEscyk9PnMlMj9NYXRoLm1pbihhLGMvMik6TWF0aC5taW4oYSxvLzIpKTtkLmJlZ2luUGF0aCgpLGQubW92ZVRvKGcsdSt5KSxyKGQsZyx1LGwqMix5KjIsImxlZnRUb3AiKSxkLmxpbmVUbyhnK28teCx1KSxyKGQsZytvLXgqMix1LHgqMixiKjIsInJpZ2h0VG9wIiksZC5saW5lVG8oZytvLHUrYy12KSxyKGQsZytvLUUqMix1K2MtdioyLEUqMix2KjIsInJpZ2h0Qm90dG9tIiksZC5saW5lVG8oZytNLHUrYykscihkLGcsdStjLWkqMixNKjIsaSoyLCJsZWZ0Qm90dG9tIiksZC5jbG9zZVBhdGgoKX1yZXR1cm4gZH19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1mdW5jdGlvbihyLG4pe2lmKCFyKXJldHVybnt4OjAseTowLHdpZHRoOjAsaGVpZ2h0OjAsbGVmdDowLHRvcDowLHJpZ2h0OjAsYm90dG9tOjB9O2NvbnN0W1tkLGddLFt1LG9dXT1yLGM9ZCpuWzBdK2cqblsyXStuWzRdLHA9ZCpuWzFdK2cqblszXStuWzVdLGw9dSpuWzBdK2cqblsyXStuWzRdLHk9dSpuWzFdK2cqblszXStuWzVdLHg9dSpuWzBdK28qblsyXStuWzRdLGI9dSpuWzFdK28qblszXStuWzVdLEU9ZCpuWzBdK28qblsyXStuWzRdLHY9ZCpuWzFdK28qblszXStuWzVdLE09TWF0aC5taW4oYyxsLHgsRSksaT1NYXRoLm1pbihwLHksYix2KSxhPU1hdGgubWF4KGMsbCx4LEUpLHM9TWF0aC5tYXgocCx5LGIsdik7cmV0dXJue3g6TSx5Omksd2lkdGg6YS1NLGhlaWdodDpzLWksbGVmdDpNLHRvcDppLHJpZ2h0OmEsYm90dG9tOnN9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjE4KSxuPXQoMjE5KSxkPXQoMjI1KSxnPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShwLGwseSl7cmV0dXJuIGwgaW4gcD9PYmplY3QuZGVmaW5lUHJvcGVydHkocCxsLHt2YWx1ZTp5LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6cFtsXT15LHB9Y29uc3Qgbz1TeW1ib2woInRleHR1cmVUYXNrIik7Y2xhc3MgYyBleHRlbmRzIG4uZGVmYXVsdHtjb25zdHJ1Y3RvcihsPXt9KXt0eXBlb2YgbD09InN0cmluZyImJihsPXt0ZXh0dXJlOmx9KSxzdXBlcihsKX1nZXQgY29udGVudFNpemUoKXtsZXRbbCx5XT1zdXBlci5jb250ZW50U2l6ZTtjb25zdHt3aWR0aDp4LGhlaWdodDpifT10aGlzLmF0dHJpYnV0ZXM7aWYoeD09bnVsbHx8Yj09bnVsbCl7Y29uc3QgRT10aGlzLnRleHR1cmVJbWFnZSx2PXRoaXMuYXR0cmlidXRlcy50ZXh0dXJlUmVjdCxNPXRoaXMuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKHYpeD09bnVsbCYmKGw9dlswXSt2WzJdKSxiPT1udWxsJiYoeT12WzFdK3ZbM10pO2Vsc2UgaWYoTSl7Y29uc3QgaT10aGlzLmxheWVyP3RoaXMubGF5ZXIuZGlzcGxheVJhdGlvOjE7eD09bnVsbCYmKGw9TVsyXS9pKSxiPT1udWxsJiYoeT1NWzNdL2kpfWVsc2UgaWYoRSl7Y29uc3QgaT10aGlzLmxheWVyP3RoaXMubGF5ZXIuZGlzcGxheVJhdGlvOjE7eD09bnVsbCYmKGw9RS53aWR0aC9pKSxiPT1udWxsJiYoeT1FLmhlaWdodC9pKX19cmV0dXJuW2wseV19Z2V0IHRleHR1cmVJbWFnZVJlYWR5KCl7cmV0dXJuIHRoaXNbb118fFByb21pc2UucmVzb2x2ZSgpfWRyYXcobD1bXSl7c3VwZXIuZHJhdyhsKTtjb25zdCB5PXRoaXMubWVzaDtyZXR1cm4geSYmT2JqZWN0KHIuZHJhd1RleHR1cmUpKHRoaXMseSksbH1vblByb3BlcnR5Q2hhbmdlKGwseSx4KXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKGwseSx4KSxsPT09InRleHR1cmUiJiYodGhpc1tvXT1PYmplY3Qoci5hcHBseVRleHR1cmUpKHRoaXMseSwhMCkpLGw9PT0idGV4dHVyZVJlY3QiKXtjb25zdHt3aWR0aDpiLGhlaWdodDpFfT10aGlzLmF0dHJpYnV0ZXM7KGI9PW51bGx8fEU9PW51bGwpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCl9fX11KGMsIkF0dHIiLGQuZGVmYXVsdCksZy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJzcHJpdGUiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxnPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoYyl7c3VwZXIoYyksdGhpc1tuXSh7dGV4dHVyZTp2b2lkIDAsdGV4dHVyZVJlY3Q6dm9pZCAwLHRleHR1cmVSZXBlYXQ6ITEsc291cmNlUmVjdDp2b2lkIDB9KX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW2ddKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUoYyl7dGhpc1tkXSgidGV4dHVyZSIsYyl9Z2V0IHRleHR1cmVSZWN0KCl7cmV0dXJuIHRoaXNbZ10oInRleHR1cmVSZWN0Iil9c2V0IHRleHR1cmVSZWN0KGMpe3RoaXNbZF0oInRleHR1cmVSZWN0IixjKX1nZXQgc291cmNlUmVjdCgpe3JldHVybiB0aGlzW2ddKCJzb3VyY2VSZWN0Iil9c2V0IHNvdXJjZVJlY3QoYyl7dGhpc1tkXSgic291cmNlUmVjdCIsYyl9Z2V0IHRleHR1cmVSZXBlYXQoKXtyZXR1cm4gdGhpc1tnXSgidGV4dHVyZVJlcGVhdCIpfXNldCB0ZXh0dXJlUmVwZWF0KGMpe3RoaXNbZF0oInRleHR1cmVSZXBlYXQiLCEhYyl9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciByPXQoMTIpLG49dCgyMjcpLGQ9dC5uKG4pLGc9dCg3MCksdT10KDIyOCksbz10KDIyMSksYz10KDIxOCkscD10KDIxMyksbD10KDIyMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHkoRSx2LE0pe3JldHVybiB2IGluIEU/T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsdix7dmFsdWU6TSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOkVbdl09TSxFfWNvbnN0IHg9U3ltYm9sKCJtZXNoIik7Y2xhc3MgYiBleHRlbmRzIGcuZGVmYXVsdHtjb25zdHJ1Y3Rvcih2PXt9KXt0eXBlb2Ygdj09InN0cmluZyImJih2PXtkOnZ9KSxzdXBlcih2KSx0aGlzLmVmZmVjdHM9e2QoTSxpLGEscyxmKXtjb25zdCBPPShhLXMpLyhmLXMpO2lmKE88PTApcmV0dXJuIE07aWYoTz49MSlyZXR1cm4gaTtjb25zdCBBPWQuYS5fcHJlcHJvY2Vzc2luZyhkLmEucGF0aDJzaGFwZXMoTSksZC5hLnBhdGgyc2hhcGVzKGkpKSxSPWQuYS5fbGVycCguLi5BLE8pWzBdO3JldHVybiBSLnJlZHVjZSgoUCxMKT0+YCR7UH0ke0wuc2xpY2UoMikuam9pbigiICIpfSBgLGBNJHtSWzBdWzBdfSAke1JbMF1bMV19Q2ApLnRyaW0oKX19fWdldCBpc1Zpc2libGUoKXtyZXR1cm4hIXRoaXMuZH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IHY9dGhpcy5wYXRoO2lmKHYpe2xldCBNPXRoaXNbeF07aWYoTSlNLnBhdGghPT12JiYoTS5jb250b3Vycz12LmNvbnRvdXJzLE0ucGF0aD12KTtlbHNle009bmV3IHIuTWVzaDJEKHRoaXMucGF0aCksTS5wYXRoPXY7Y29uc3QgYT10aGlzLmF0dHJpYnV0ZXMuZmlsbENvbG9yLHM9dGhpcy5hdHRyaWJ1dGVzLmZpbGxSdWxlO2EmJk9iamVjdChvLnNldEZpbGxDb2xvcikoTSx7Y29sb3I6YSxydWxlOnN9KTtjb25zdCBmPXRoaXMuYXR0cmlidXRlcy5saW5lV2lkdGgsTz10aGlzLmF0dHJpYnV0ZXMuc3Ryb2tlQ29sb3I7aWYoTyYmZj4wKXtjb25zdHtsaW5lQ2FwOlIsbGluZUpvaW46SSxtaXRlckxpbWl0OlAsbGluZURhc2g6TCxsaW5lRGFzaE9mZnNldDpELHJvdW5kU2VnbWVudHM6Q309dGhpcy5hdHRyaWJ1dGVzO09iamVjdChvLnNldFN0cm9rZUNvbG9yKShNLHtjb2xvcjpPLGxpbmVXaWR0aDpmLGxpbmVDYXA6UixsaW5lSm9pbjpJLG1pdGVyTGltaXQ6UCxsaW5lRGFzaDpMLGxpbmVEYXNoT2Zmc2V0OkQscm91bmRTZWdtZW50czpDfSl9dGhpc1t4XT1NO2NvbnN0IEE9dGhpcy5hdHRyaWJ1dGVzLmNsaXBQYXRoO0EmJnRoaXNbeF0uc2V0Q2xpcFBhdGgoQSl9Y29uc3QgaT10aGlzLm9wYWNpdHk7cmV0dXJuIE0uZ2V0T3BhY2l0eSgpIT09aSYmTS5zZXRPcGFjaXR5KGkpLE0uc2V0VHJhbnNmb3JtKC4uLnRoaXMucmVuZGVyTWF0cml4KSxNfXJldHVybiBudWxsfWdldCBvcmlnaW5hbENvbnRlbnRSZWN0KCl7aWYodGhpcy5wYXRoKXtjb25zdCB2PXRoaXMucGF0aC5ib3VuZGluZ0JveDtyZXR1cm5bdlswXVswXSx2WzBdWzFdLHZbMV1bMF0tdlswXVswXSx2WzFdWzFdLXZbMF1bMV1dfXJldHVyblswLDAsMCwwXX1nZXQgb3JpZ2luYWxDbGllbnRSZWN0KCl7aWYodGhpcy5tZXNoKXtjb25zdCB2PXRoaXMubWVzaC5ib3VuZGluZ0JveDtyZXR1cm5bdlswXVswXSx2WzBdWzFdLHZbMV1bMF0tdlswXVswXSx2WzFdWzFdLXZbMF1bMV1dfXJldHVyblswLDAsMCwwXX1nZXQgb3JpZ2luYWxDbGllbnRDZW50ZXIoKXtyZXR1cm4gdGhpcy5tZXNoP3RoaXMubWVzaC5ib3VuZGluZ0NlbnRlcjpbMCwwXX1zZXQgZCh2KXt0aGlzLmF0dHJpYnV0ZXMuZD12fWdldCBkKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5kfWRyYXcodj1bXSl7c3VwZXIuZHJhdyh2KTtjb25zdCBNPXRoaXMubWVzaDtyZXR1cm4gTSYmT2JqZWN0KGMuZHJhd1RleHR1cmUpKHRoaXMsTSksdn1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgdj1udWxsO3JldHVybiB0aGlzLm1lc2gmJih2PXRoaXMubWVzaC5ib3VuZGluZ0JveCksT2JqZWN0KGwuZGVmYXVsdCkodix0aGlzLnJlbmRlck1hdHJpeCl9Z2V0UGF0aExlbmd0aCgpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmdldFRvdGFsTGVuZ3RoKCk6MH1nZXRQb2ludEF0TGVuZ3RoKHYpe2lmKHRoaXMubWVzaCl7Y29uc3QgTT10aGlzLm1lc2guZ2V0UG9pbnRBdExlbmd0aCh2KTtpZihNKXJldHVybltNLngsTS55XX1yZXR1cm5bMCwwXX1vblByb3BlcnR5Q2hhbmdlKHYsTSxpKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKHYsTSxpKSwodj09PSJkInx8dj09PSJub3JtYWxpemUiKSYmdGhpcy51cGRhdGVDb250b3VycygpLHRoaXNbeF0mJih2PT09ImZpbGxDb2xvciJ8fHY9PT0iZmlsbFJ1bGUiKSl7Y29uc3R7ZmlsbENvbG9yOmEsZmlsbFJ1bGU6c309dGhpcy5hdHRyaWJ1dGVzO09iamVjdChvLnNldEZpbGxDb2xvcikodGhpc1t4XSx7Y29sb3I6YSxydWxlOnN9KX1pZih0aGlzW3hdJiYodj09PSJzdHJva2VDb2xvciJ8fHY9PT0ibGluZVdpZHRoInx8dj09PSJsaW5lQ2FwInx8dj09PSJsaW5lSm9pbiJ8fHY9PT0ibGluZURhc2gifHx2PT09ImxpbmVEYXNoT2Zmc2V0Inx8dj09PSJyb3VuZFNlZ21lbnRzIikpe2NvbnN0e3N0cm9rZUNvbG9yOmEsbGluZVdpZHRoOnN9PXRoaXMuYXR0cmlidXRlcztpZihhJiZzPjApe2NvbnN0e2xpbmVDYXA6ZixsaW5lSm9pbjpPLGxpbmVEYXNoOkEsbGluZURhc2hPZmZzZXQ6UixtaXRlckxpbWl0Okkscm91bmRTZWdtZW50czpQfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KG8uc2V0U3Ryb2tlQ29sb3IpKHRoaXNbeF0se2NvbG9yOmEsbGluZUNhcDpmLGxpbmVKb2luOk8sbGluZVdpZHRoOnMsbGluZURhc2g6QSxsaW5lRGFzaE9mZnNldDpSLG1pdGVyTGltaXQ6SSxyb3VuZFNlZ21lbnRzOlB9KX19dGhpc1t4XSYmdj09PSJjbGlwUGF0aCImJnRoaXNbeF0uc2V0Q2xpcFBhdGgoTSksdj09PSJ0ZXh0dXJlIiYmT2JqZWN0KGMuYXBwbHlUZXh0dXJlKSh0aGlzLE0pfXVwZGF0ZUNvbnRvdXJzKCl7dGhpcy5wYXRoPW5ldyByLkZpZ3VyZTJELHRoaXMucGF0aC5hZGRQYXRoKHRoaXMuYXR0cmlidXRlcy5kKSx0aGlzLmF0dHJpYnV0ZXMubm9ybWFsaXplJiZ0aGlzLnBhdGgubm9ybWFsaXplKC4uLnRoaXMucGF0aC5ib3VuZGluZ0NlbnRlcil9fXkoYiwiQXR0ciIsdS5kZWZhdWx0KSxwLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGIsInBhdGgiKX0sZnVuY3Rpb24oaCxlLHQpeyhmdW5jdGlvbihyLG4pe2guZXhwb3J0cz1uKCl9KSh0aGlzLGZ1bmN0aW9uKCl7dmFyIHI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBMKEQsQyl7dmFyIFM9W10sQj0hMCx3PSExLEg9dm9pZCAwO3RyeXtmb3IodmFyIFo9RFtTeW1ib2wuaXRlcmF0b3JdKCkscTshKEI9KHE9Wi5uZXh0KCkpLmRvbmUpJiYoUy5wdXNoKHEudmFsdWUpLCEoQyYmUy5sZW5ndGg9PT1DKSk7Qj0hMCk7fWNhdGNoKFUpe3c9ITAsSD1VfWZpbmFsbHl7dHJ5eyFCJiZaLnJldHVybiYmWi5yZXR1cm4oKX1maW5hbGx5e2lmKHcpdGhyb3cgSH19cmV0dXJuIFN9cmV0dXJuIGZ1bmN0aW9uKEQsQyl7aWYoQXJyYXkuaXNBcnJheShEKSlyZXR1cm4gRDtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KEQpKXJldHVybiBMKEQsQyk7dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZSIpfX0oKSxuPU1hdGguUEkqMixkPWZ1bmN0aW9uKEQsQyxTLEIsdyxILFope3ZhciBxPUQueCxVPUQueTtxKj1DLFUqPVM7dmFyIEc9QipxLXcqVSxKPXcqcStCKlU7cmV0dXJue3g6RytILHk6SitafX0sZz1mdW5jdGlvbihELEMpe3ZhciBTPTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihDLzQpLEI9TWF0aC5jb3MoRCksdz1NYXRoLnNpbihEKSxIPU1hdGguY29zKEQrQyksWj1NYXRoLnNpbihEK0MpO3JldHVyblt7eDpCLXcqUyx5OncrQipTfSx7eDpIK1oqUyx5OlotSCpTfSx7eDpILHk6Wn1dfSx1PWZ1bmN0aW9uKEQsQyxTLEIpe3ZhciB3PUQqQi1DKlM8MD8tMToxLEg9TWF0aC5zcXJ0KEQqRCtDKkMpLFo9TWF0aC5zcXJ0KEQqRCtDKkMpLHE9RCpTK0MqQixVPXEvKEgqWik7cmV0dXJuIFU+MSYmKFU9MSksVTwtMSYmKFU9LTEpLHcqTWF0aC5hY29zKFUpfSxvPWZ1bmN0aW9uKEQsQyxTLEIsdyxILFoscSxVLEcsSix0dCl7dmFyIF89TWF0aC5wb3codywyKSxzdD1NYXRoLnBvdyhILDIpLGs9TWF0aC5wb3coSiwyKSxodD1NYXRoLnBvdyh0dCwyKSxmdD1fKnN0LV8qaHQtc3QqaztmdDwwJiYoZnQ9MCksZnQvPV8qaHQrc3QqayxmdD1NYXRoLnNxcnQoZnQpKihaPT09cT8tMToxKTt2YXIgVz1mdCp3L0gqdHQsRj1mdCotSC93KkosVj1HKlctVSpGKyhEK1MpLzIsWD1VKlcrRypGKyhDK0IpLzIsaj0oSi1XKS93LCQ9KHR0LUYpL0gsbT0oLUotVykvdyxUPSgtdHQtRikvSCxOPXUoMSwwLGosJCksej11KGosJCxtLFQpO3JldHVybiBxPT09MCYmej4wJiYoei09bikscT09PTEmJno8MCYmKHorPW4pLFtWLFgsTix6XX0sYz1mdW5jdGlvbihEKXt2YXIgQz1ELnB4LFM9RC5weSxCPUQuY3gsdz1ELmN5LEg9RC5yeCxaPUQucnkscT1ELnhBeGlzUm90YXRpb24sVT1xPT09dm9pZCAwPzA6cSxHPUQubGFyZ2VBcmNGbGFnLEo9Rz09PXZvaWQgMD8wOkcsdHQ9RC5zd2VlcEZsYWcsXz10dD09PXZvaWQgMD8wOnR0LHN0PVtdO2lmKEg9PT0wfHxaPT09MClyZXR1cm5bXTt2YXIgaz1NYXRoLnNpbihVKm4vMzYwKSxodD1NYXRoLmNvcyhVKm4vMzYwKSxmdD1odCooQy1CKS8yK2sqKFMtdykvMixXPS1rKihDLUIpLzIraHQqKFMtdykvMjtpZihmdD09PTAmJlc9PT0wKXJldHVybltdO0g9TWF0aC5hYnMoSCksWj1NYXRoLmFicyhaKTt2YXIgRj1NYXRoLnBvdyhmdCwyKS9NYXRoLnBvdyhILDIpK01hdGgucG93KFcsMikvTWF0aC5wb3coWiwyKTtGPjEmJihIKj1NYXRoLnNxcnQoRiksWio9TWF0aC5zcXJ0KEYpKTt2YXIgVj1vKEMsUyxCLHcsSCxaLEosXyxrLGh0LGZ0LFcpLFg9cihWLDQpLGo9WFswXSwkPVhbMV0sbT1YWzJdLFQ9WFszXSxOPU1hdGgubWF4KE1hdGguY2VpbChNYXRoLmFicyhUKS8obi80KSksMSk7VC89Tjtmb3IodmFyIHo9MDt6PE47eisrKXN0LnB1c2goZyhtLFQpKSxtKz1UO3JldHVybiBzdC5tYXAoZnVuY3Rpb24oSyl7dmFyIFk9ZChLWzBdLEgsWixodCxrLGosJCksUT1ZLngsZXQ9WS55LHJ0PWQoS1sxXSxILFosaHQsayxqLCQpLG90PXJ0LngsbHQ9cnQueSxpdD1kKEtbMl0sSCxaLGh0LGssaiwkKSxudD1pdC54LGF0PWl0Lnk7cmV0dXJue3gxOlEseTE6ZXQseDI6b3QseTI6bHQseDpudCx5OmF0fX0pfSxwPXthOjcsYzo2LGg6MSxsOjIsbToyLHE6NCxzOjQsdDoyLHY6MSx6OjB9LGw9LyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9pZztmdW5jdGlvbiB5KEwpe3ZhciBEPVtdO3JldHVybiBMLnJlcGxhY2UobCxmdW5jdGlvbihDLFMsQil7dmFyIHc9Uy50b0xvd2VyQ2FzZSgpO2ZvcihCPWIoQiksdz09Im0iJiZCLmxlbmd0aD4yJiYoRC5wdXNoKFtTXS5jb25jYXQoQi5zcGxpY2UoMCwyKSkpLHc9ImwiLFM9Uz09Im0iPyJsIjoiTCIpOzspe2lmKEIubGVuZ3RoPT1wW3ddKXJldHVybiBCLnVuc2hpZnQoUyksRC5wdXNoKEIpO2lmKEIubGVuZ3RoPHBbd10pdGhyb3cgbmV3IEVycm9yKCJtYWxmb3JtZWQgcGF0aCBkYXRhIik7RC5wdXNoKFtTXS5jb25jYXQoQi5zcGxpY2UoMCxwW3ddKSkpfX0pLER9dmFyIHg9Ly0/WzAtOV0qXC4/WzAtOV0rKD86ZVstK10/XGQrKT8vaWc7ZnVuY3Rpb24gYihMKXt2YXIgRD1MLm1hdGNoKHgpO3JldHVybiBEP0QubWFwKE51bWJlcik6W119ZnVuY3Rpb24gRShMKXt2YXIgRD1MWzBdWzBdLEM9TFswXVsxXSxTPUQsQj1DO3JldHVybiBMLmZvckVhY2goZnVuY3Rpb24odyl7dmFyIEg9d1swXSxaPXdbMl0scT13WzRdLFU9d1s2XSxHPXdbMV0sSj13WzNdLHR0PXdbNV0sXz13WzddO0Q9TWF0aC5taW4oRCxILFoscSxVKSxDPU1hdGgubWluKEMsRyxKLHR0LF8pLFM9TWF0aC5tYXgoUyxILFoscSxVKSxCPU1hdGgubWF4KEIsRyxKLHR0LF8pfSksW0QsQyxTLEJdfWZ1bmN0aW9uIHYoTCxEKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KExbMF0tRFswXSwyKStNYXRoLnBvdyhMWzFdLURbMV0sMikpK01hdGguc3FydChNYXRoLnBvdyhMWzJdLURbMl0sMikrTWF0aC5wb3coTFszXS1EWzNdLDIpKX1mdW5jdGlvbiBNKEwsRCl7dmFyIEM9TFswXSxTPUxbMl0sQj1MWzRdLHc9TFs2XSxIPUxbMV0sWj1MWzNdLHE9TFs1XSxVPUxbN10sRz1EWzBdLEo9RFsyXSx0dD1EWzRdLF89RFs2XSxzdD1EWzFdLGs9RFszXSxodD1EWzVdLGZ0PURbN107cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhHLUMsMikrTWF0aC5wb3coc3QtSCwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KEotUywyKStNYXRoLnBvdyhrLVosMikpK01hdGguc3FydChNYXRoLnBvdyh0dC1CLDIpK01hdGgucG93KGh0LXEsMikpK01hdGguc3FydChNYXRoLnBvdyhfLXcsMikrTWF0aC5wb3coZnQtVSwyKSl9ZnVuY3Rpb24gaShMLEQpe3ZhciBDPXMoTC5sZW5ndGgpLFM9W107Qy5mb3JFYWNoKGZ1bmN0aW9uKHcpe3ZhciBIPTAsWj0wO3cuZm9yRWFjaChmdW5jdGlvbihxKXtIKz1NKExbcV0sRFtaKytdKX0pLFMucHVzaCh7aW5kZXg6dyxkaXN0YW5jZTpIfSl9KSxTLnNvcnQoZnVuY3Rpb24odyxIKXtyZXR1cm4gdy5kaXN0YW5jZS1ILmRpc3RhbmNlfSk7dmFyIEI9W107cmV0dXJuIFNbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbih3KXtCLnB1c2goTFt3XSl9KSxCfWZ1bmN0aW9uIGEoTCxEKXt2YXIgQz1mKEwubGVuZ3RoKSxTPVtdO0MuZm9yRWFjaChmdW5jdGlvbih3KXt2YXIgSD0wO3cuZm9yRWFjaChmdW5jdGlvbihaKXtIKz12KEUoTFtaXSksRShEW1pdKSl9KSxTLnB1c2goe2luZGV4OncsZGlzdGFuY2U6SH0pfSksUy5zb3J0KGZ1bmN0aW9uKHcsSCl7cmV0dXJuIHcuZGlzdGFuY2UtSC5kaXN0YW5jZX0pO3ZhciBCPVtdO3JldHVybiBTWzBdLmluZGV4LmZvckVhY2goZnVuY3Rpb24odyl7Qi5wdXNoKExbd10pfSksQn1mdW5jdGlvbiBzKEwpe2Zvcih2YXIgRD1bXSxDPTA7QzxMO0MrKyl7Zm9yKHZhciBTPVtdLEI9MDtCPEw7QisrKXt2YXIgdz1CK0M7dz5MLTEmJih3LT1MKSxTW3ddPUJ9RC5wdXNoKFMpfXJldHVybiBEfWZ1bmN0aW9uIGYoTCl7Zm9yKHZhciBEPVtdLEM9MDtDPEw7QysrKUQucHVzaChDKTtyZXR1cm4gTyhEKX1mdW5jdGlvbiBPKEwpe3ZhciBEPVtdLEM9W107ZnVuY3Rpb24gUyhCKXt2YXIgdyxIO2Zvcih3PTA7dzxCLmxlbmd0aDt3KyspSD1CLnNwbGljZSh3LDEpWzBdLEMucHVzaChIKSxCLmxlbmd0aD09MCYmRC5wdXNoKEMuc2xpY2UoKSksUyhCKSxCLnNwbGljZSh3LDAsSCksQy5wb3AoKTtyZXR1cm4gRH1yZXR1cm4gUyhMKX12YXIgQT17fTtBLnBhcnNlcj15LEEubGVycEN1cnZlPWZ1bmN0aW9uKEwsRCxDKXtyZXR1cm4gQS5sZXJwUG9pbnRzKExbMF0sTFsxXSxEWzBdLERbMV0sQykuY29uY2F0KEEubGVycFBvaW50cyhMWzJdLExbM10sRFsyXSxEWzNdLEMpKS5jb25jYXQoQS5sZXJwUG9pbnRzKExbNF0sTFs1XSxEWzRdLERbNV0sQykpLmNvbmNhdChBLmxlcnBQb2ludHMoTFs2XSxMWzddLERbNl0sRFs3XSxDKSl9LEEubGVycFBvaW50cz1mdW5jdGlvbihMLEQsQyxTLEIpe3JldHVybltMKyhDLUwpKkIsRCsoUy1EKSpCXX0sQS5xMmI9ZnVuY3Rpb24oTCxELEMsUyxCLHcpe3JldHVybltMLEQsKEwrMipDKS8zLChEKzIqUykvMywoQisyKkMpLzMsKHcrMipTKS8zLEIsd119LEEucGF0aDJzaGFwZXM9ZnVuY3Rpb24oTCl7Zm9yKHZhciBEPUEucGFyc2VyKEwpLEM9MCxTPTAsQj0wLHc9RC5sZW5ndGgsSD1bXSxaPW51bGwscT12b2lkIDAsVT12b2lkIDAsRz12b2lkIDAsSj12b2lkIDAsdHQ9dm9pZCAwLF89dm9pZCAwLHN0PXZvaWQgMDtCPHc7QisrKXt2YXIgaz1EW0JdLGh0PWtbMF0sZnQ9RFtCLTFdO3N3aXRjaChodCl7Y2FzZSJtIjp0dD1ILmxlbmd0aCxIW3R0XT1bXSxaPUhbdHRdLEM9QytrWzFdLFM9UytrWzJdO2JyZWFrO2Nhc2UiTSI6dHQ9SC5sZW5ndGgsSFt0dF09W10sWj1IW3R0XSxDPWtbMV0sUz1rWzJdO2JyZWFrO2Nhc2UibCI6Wi5wdXNoKFtDLFMsQyxTLEMsUyxDK2tbMV0sUytrWzJdXSksQys9a1sxXSxTKz1rWzJdO2JyZWFrO2Nhc2UiTCI6Wi5wdXNoKFtDLFMsa1sxXSxrWzJdLGtbMV0sa1syXSxrWzFdLGtbMl1dKSxDPWtbMV0sUz1rWzJdO2JyZWFrO2Nhc2UiaCI6Wi5wdXNoKFtDLFMsQyxTLEMsUyxDK2tbMV0sU10pLEMrPWtbMV07YnJlYWs7Y2FzZSJIIjpaLnB1c2goW0MsUyxrWzFdLFMsa1sxXSxTLGtbMV0sU10pLEM9a1sxXTticmVhaztjYXNlInYiOloucHVzaChbQyxTLEMsUyxDLFMsQyxTK2tbMV1dKSxTKz1rWzFdO2JyZWFrO2Nhc2UiViI6Wi5wdXNoKFtDLFMsQyxrWzFdLEMsa1sxXSxDLGtbMV1dKSxTPWtbMV07YnJlYWs7Y2FzZSJDIjpaLnB1c2goW0MsUyxrWzFdLGtbMl0sa1szXSxrWzRdLGtbNV0sa1s2XV0pLEM9a1s1XSxTPWtbNl07YnJlYWs7Y2FzZSJTIjpmdFswXT09PSJDInx8ZnRbMF09PT0iYyI/Wi5wdXNoKFtDLFMsQytmdFs1XS1mdFszXSxTK2Z0WzZdLWZ0WzRdLGtbMV0sa1syXSxrWzNdLGtbNF1dKTooZnRbMF09PT0iUyJ8fGZ0WzBdPT09InMiKSYmWi5wdXNoKFtDLFMsQytmdFszXS1mdFsxXSxTK2Z0WzRdLWZ0WzJdLGtbMV0sa1syXSxrWzNdLGtbNF1dKSxDPWtbM10sUz1rWzRdO2JyZWFrO2Nhc2UiYyI6Wi5wdXNoKFtDLFMsQytrWzFdLFMra1syXSxDK2tbM10sUytrWzRdLEMra1s1XSxTK2tbNl1dKSxDPUMra1s1XSxTPVMra1s2XTticmVhaztjYXNlInMiOmZ0WzBdPT09IkMifHxmdFswXT09PSJjIj9aLnB1c2goW0MsUyxDK2Z0WzVdLWZ0WzNdLFMrZnRbNl0tZnRbNF0sQytrWzFdLFMra1syXSxDK2tbM10sUytrWzRdXSk6KGZ0WzBdPT09IlMifHxmdFswXT09PSJzIikmJloucHVzaChbQyxTLEMrZnRbM10tZnRbMV0sUytmdFs0XS1mdFsyXSxDK2tbMV0sUytrWzJdLEMra1szXSxTK2tbNF1dKSxDPUMra1szXSxTPVMra1s0XTticmVhaztjYXNlImEiOl89Yyh7cng6a1sxXSxyeTprWzJdLHB4OkMscHk6Uyx4QXhpc1JvdGF0aW9uOmtbM10sbGFyZ2VBcmNGbGFnOmtbNF0sc3dlZXBGbGFnOmtbNV0sY3g6QytrWzZdLGN5OlMra1s3XX0pLHN0PV9bXy5sZW5ndGgtMV0sXy5mb3JFYWNoKGZ1bmN0aW9uKFcsRil7Rj09PTA/Wi5wdXNoKFtDLFMsVy54MSxXLnkxLFcueDIsVy55MixXLngsVy55XSk6Wi5wdXNoKFtfW0YtMV0ueCxfW0YtMV0ueSxXLngxLFcueTEsVy54MixXLnkyLFcueCxXLnldKX0pLEM9c3QueCxTPXN0Lnk7YnJlYWs7Y2FzZSJBIjpfPWMoe3J4OmtbMV0scnk6a1syXSxweDpDLHB5OlMseEF4aXNSb3RhdGlvbjprWzNdLGxhcmdlQXJjRmxhZzprWzRdLHN3ZWVwRmxhZzprWzVdLGN4OmtbNl0sY3k6a1s3XX0pLHN0PV9bXy5sZW5ndGgtMV0sXy5mb3JFYWNoKGZ1bmN0aW9uKFcsRil7Rj09PTA/Wi5wdXNoKFtDLFMsVy54MSxXLnkxLFcueDIsVy55MixXLngsVy55XSk6Wi5wdXNoKFtfW0YtMV0ueCxfW0YtMV0ueSxXLngxLFcueTEsVy54MixXLnkyLFcueCxXLnldKX0pLEM9c3QueCxTPXN0Lnk7YnJlYWs7Y2FzZSJRIjpaLnB1c2goQS5xMmIoQyxTLGtbMV0sa1syXSxrWzNdLGtbNF0pKSxDPWtbM10sUz1rWzRdO2JyZWFrO2Nhc2UicSI6Wi5wdXNoKEEucTJiKEMsUyxDK2tbMV0sUytrWzJdLGtbM10rQyxrWzRdK1MpKSxDKz1rWzNdLFMrPWtbNF07YnJlYWs7Y2FzZSJUIjpmdFswXT09PSJRInx8ZnRbMF09PT0icSI/KEc9QytmdFszXS1mdFsxXSxKPVMrZnRbNF0tZnRbMl0sWi5wdXNoKEEucTJiKEMsUyxHLEosa1sxXSxrWzJdKSkpOihmdFswXT09PSJUInx8ZnRbMF09PT0idCIpJiYoWi5wdXNoKEEucTJiKEMsUyxDK0MtRyxTK1MtSixrWzFdLGtbMl0pKSxHPUMrQy1HLEo9UytTLUopLEM9a1sxXSxTPWtbMl07YnJlYWs7Y2FzZSJ0IjpmdFswXT09PSJRInx8ZnRbMF09PT0icSI/KEc9QytmdFszXS1mdFsxXSxKPVMrZnRbNF0tZnRbMl0sWi5wdXNoKEEucTJiKEMsUyxHLEosQytrWzFdLFMra1syXSkpKTooZnRbMF09PT0iVCJ8fGZ0WzBdPT09InQiKSYmKFoucHVzaChBLnEyYihDLFMsQytDLUcsUytTLUosQytrWzFdLFMra1syXSkpLEc9QytDLUcsSj1TK1MtSiksQys9a1sxXSxTKz1rWzJdO2JyZWFrO2Nhc2UiWiI6cT1aWzBdWzBdLFU9WlswXVsxXSxaLnB1c2goW0MsUyxxLFUscSxVLHEsVV0pO2JyZWFrO2Nhc2UieiI6cT1aWzBdWzBdLFU9WlswXVsxXSxaLnB1c2goW0MsUyxxLFUscSxVLHEsVV0pO2JyZWFrfX1yZXR1cm4gSH0sQS5fdXBDdXJ2ZXM9ZnVuY3Rpb24oTCxEKXtmb3IodmFyIEM9MCxTPTAsQj1MLmxlbmd0aDtDPEQ7QysrKUwucHVzaChMW1NdLnNsaWNlKDApKSxTKyssUz5CLTEmJihTLT1CKX07ZnVuY3Rpb24gUihMLEQsQyxTLEIsdyxILFoscSl7cmV0dXJue2xlZnQ6SShMLEQsQyxTLEIsdyxILFoscSkscmlnaHQ6SShILFosQix3LEMsUyxMLEQsMS1xLCEwKX19ZnVuY3Rpb24gSShMLEQsQyxTLEIsdyxILFoscSxVKXt2YXIgRz0oQy1MKSpxK0wsSj0oUy1EKSpxK0QsdHQ9KEItQykqcStDLF89KHctUykqcStTLHN0PShILUIpKnErQixrPShaLXcpKnErdyxodD0odHQtRykqcStHLGZ0PShfLUopKnErSixXPShzdC10dCkqcSt0dCxGPShrLV8pKnErXyxWPShXLWh0KSpxK2h0LFg9KEYtZnQpKnErZnQ7cmV0dXJuIFU/W1YsWCxodCxmdCxHLEosTCxEXTpbTCxELEcsSixodCxmdCxWLFhdfUEuX3NwbGl0Q3VydmVzPWZ1bmN0aW9uKEwsRCl7Zm9yKHZhciBDPTAsUz0wO0M8RDtDKyspe3ZhciBCPUxbU10sdz1SKEJbMF0sQlsxXSxCWzJdLEJbM10sQls0XSxCWzVdLEJbNl0sQls3XSwuNSk7TC5zcGxpY2UoUywxKSxMLnNwbGljZShTLDAsdy5sZWZ0LHcucmlnaHQpLFMrPTIsUz49TC5sZW5ndGgtMSYmKFM9MCl9fTtmdW5jdGlvbiBQKEwsRCl7Zm9yKHZhciBDPWZ1bmN0aW9uKHcpe3ZhciBIPUxbTC5sZW5ndGgtMV0sWj1bXTtILmZvckVhY2goZnVuY3Rpb24ocSl7Wi5wdXNoKHEuc2xpY2UoMCkpfSksTC5wdXNoKFopfSxTPTA7UzxEO1MrKylDKCl9cmV0dXJuIEEubGVycD1mdW5jdGlvbihMLEQsQyl7cmV0dXJuIEEuX2xlcnAoQS5wYXRoMnNoYXBlcyhMKSxBLnBhdGgyc2hhcGVzKEQpLEMpfSxBLk1JTV9DVVJWRVNfQ09VTlQ9MTAwLEEuX3ByZXByb2Nlc3Npbmc9ZnVuY3Rpb24oTCxEKXt2YXIgQz1MLmxlbmd0aCxTPUQubGVuZ3RoLEI9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShMKSksdz1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEQpKTtyZXR1cm4gQz5TP1AodyxDLVMpOkM8UyYmUChCLFMtQyksQj1hKEIsdyksQi5mb3JFYWNoKGZ1bmN0aW9uKEgsWil7dmFyIHE9SC5sZW5ndGgsVT13W1pdLmxlbmd0aDtxPlU/cTxBLk1JTV9DVVJWRVNfQ09VTlQ/KEEuX3NwbGl0Q3VydmVzKEgsQS5NSU1fQ1VSVkVTX0NPVU5ULXEpLEEuX3NwbGl0Q3VydmVzKHdbWl0sQS5NSU1fQ1VSVkVTX0NPVU5ULVUpKTpBLl9zcGxpdEN1cnZlcyh3W1pdLHEtVSk6cTxVJiYoVTxBLk1JTV9DVVJWRVNfQ09VTlQ/KEEuX3NwbGl0Q3VydmVzKEgsQS5NSU1fQ1VSVkVTX0NPVU5ULXEpLEEuX3NwbGl0Q3VydmVzKHdbWl0sQS5NSU1fQ1VSVkVTX0NPVU5ULVUpKTpBLl9zcGxpdEN1cnZlcyhILFUtcSkpfSksQi5mb3JFYWNoKGZ1bmN0aW9uKEgsWil7QltaXT1pKEgsd1taXSl9KSxbQix3XX0sQS5fbGVycD1mdW5jdGlvbihMLEQsQyl7dmFyIFM9W107cmV0dXJuIEwuZm9yRWFjaChmdW5jdGlvbihCLHcpe3ZhciBIPVtdO0IuZm9yRWFjaChmdW5jdGlvbihaLHEpe0gucHVzaChBLmxlcnBDdXJ2ZShaLERbd11bcV0sQykpfSksUy5wdXNoKEgpfSksU30sQS5hbmltYXRlPWZ1bmN0aW9uKEwpe3ZhciBEPUEucGF0aDJzaGFwZXMoTC5mcm9tKSxDPUEucGF0aDJzaGFwZXMoTC50byksUz1BLl9wcmVwcm9jZXNzaW5nKEQsQyksQj1uZXcgRGF0ZSx3PUwuZW5kfHxmdW5jdGlvbigpe30sSD1MLnByb2dyZXNzfHxmdW5jdGlvbigpe30sWj1MLmJlZ2lufHxmdW5jdGlvbigpe30scT1MLmVhc2luZ3x8ZnVuY3Rpb24oXyl7cmV0dXJuIF99LFU9bnVsbCxHPW51bGwsSj1MLnRpbWU7WihEKTt2YXIgdHQ9ZnVuY3Rpb24gXygpe3ZhciBzdD1uZXcgRGF0ZS1CO2lmKHN0Pj1KKXtHPUMsSChHLDEpLHcoRyksY2FuY2VsQW5pbWF0aW9uRnJhbWUoVSk7cmV0dXJufXZhciBrPXEoc3QvSik7Rz1BLl9sZXJwKFNbMF0sU1sxXSxrKSxIKEcsayksVT1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXyl9O3R0KCl9LEF9KX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoNzEpLG49dCgyMjEpLGQ9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtjbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGwpe3N1cGVyKGwpLHRoaXNbZ10oe2Q6IiIsbm9ybWFsaXplOiExLGZpbGxDb2xvcjp2b2lkIDAsZmlsbFJ1bGU6Im5vbnplcm8iLHN0cm9rZUNvbG9yOnZvaWQgMCxsaW5lV2lkdGg6MSxsaW5lSm9pbjoibWl0ZXIiLGxpbmVDYXA6ImJ1dHQiLHJvdW5kU2VnbWVudHM6MjAsbGluZURhc2g6dm9pZCAwLGxpbmVEYXNoT2Zmc2V0OjAsbWl0ZXJMaW1pdDoxMCx0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMCxjbGlwUGF0aDp2b2lkIDB9KX1nZXQgZCgpe3JldHVybiB0aGlzW29dKCJkIil9c2V0IGQobCl7dGhpc1t1XSgiZCIsbCl9Z2V0IG5vcm1hbGl6ZSgpe3JldHVybiB0aGlzW29dKCJub3JtYWxpemUiKX1zZXQgbm9ybWFsaXplKGwpe3RoaXNbdV0oIm5vcm1hbGl6ZSIsISFsKX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbb10oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IobCl7dGhpc1t1XSgiZmlsbENvbG9yIixPYmplY3Qobi5wYXJzZUNvbG9yKShsKSl9Z2V0IGZpbGxSdWxlKCl7cmV0dXJuIHRoaXNbb10oImZpbGxSdWxlIil9c2V0IGZpbGxSdWxlKGwpe2lmKGwhPW51bGwmJmwhPT0ibm9uemVybyImJmwhPT0iZXZlbm9kZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaWxsIHJ1bGUuIik7dGhpc1t1XSgiZmlsbFJ1bGUiLGwpfWdldCBzdHJva2VDb2xvcigpe3JldHVybiB0aGlzW29dKCJzdHJva2VDb2xvciIpfXNldCBzdHJva2VDb2xvcihsKXt0aGlzW3VdKCJzdHJva2VDb2xvciIsT2JqZWN0KG4ucGFyc2VDb2xvcikobCkpfWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tvXSgibGluZVdpZHRoIil9c2V0IGxpbmVXaWR0aChsKXt0aGlzW3VdKCJsaW5lV2lkdGgiLE9iamVjdChkLnRvTnVtYmVyKShsKSl9Z2V0IGxpbmVKb2luKCl7cmV0dXJuIHRoaXNbb10oImxpbmVKb2luIil9c2V0IGxpbmVKb2luKGwpe2lmKGwhPW51bGwmJmwhPT0ibWl0ZXIiJiZsIT09ImJldmVsIiYmbCE9PSJyb3VuZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lSm9pbiB0eXBlLiIpO3RoaXNbdV0oImxpbmVKb2luIixsKX1nZXQgbGluZUNhcCgpe3JldHVybiB0aGlzW29dKCJsaW5lQ2FwIil9c2V0IGxpbmVDYXAobCl7aWYobCE9bnVsbCYmbCE9PSJidXR0IiYmbCE9PSJzcXVhcmUiJiZsIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVDYXAgdHlwZS4iKTt0aGlzW3VdKCJsaW5lQ2FwIixsKX1nZXQgbGluZURhc2goKXtyZXR1cm4gdGhpc1tvXSgibGluZURhc2giKX1zZXQgbGluZURhc2gobCl7bD1PYmplY3QoZC50b0FycmF5KShsLCEwKSxsIT1udWxsJiYhQXJyYXkuaXNBcnJheShsKSYmKGw9W2xdKSx0aGlzW3VdKCJsaW5lRGFzaCIsbD9sLm1hcChkLnRvTnVtYmVyKTpudWxsKX1nZXQgbGluZURhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1tvXSgibGluZURhc2hPZmZzZXQiKX1zZXQgbGluZURhc2hPZmZzZXQobCl7dGhpc1t1XSgibGluZURhc2hPZmZzZXQiLE9iamVjdChkLnRvTnVtYmVyKShsKSl9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tvXSgibWl0ZXJMaW1pdCIpfXNldCBtaXRlckxpbWl0KGwpe3RoaXNbdV0oIm1pdGVyTGltaXQiLE9iamVjdChkLnRvTnVtYmVyKShsKSl9Z2V0IHJvdW5kU2VnbWVudHMoKXtyZXR1cm4gdGhpc1tvXSgicm91bmRTZWdtZW50cyIpfXNldCByb3VuZFNlZ21lbnRzKGwpe3RoaXNbdV0oInJvdW5kU2VnbWVudHMiLGwpfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbb10oInRleHR1cmUiKX1zZXQgdGV4dHVyZShsKXt0aGlzW3VdKCJ0ZXh0dXJlIixsKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1tvXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QobCl7dGhpc1t1XSgidGV4dHVyZVJlY3QiLGwpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbb10oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChsKXt0aGlzW3VdKCJzb3VyY2VSZWN0IixsKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW29dKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQobCl7dGhpc1t1XSgidGV4dHVyZVJlcGVhdCIsISFsKX1nZXQgY2xpcFBhdGgoKXtyZXR1cm4gdGhpc1tvXSgiY2xpcFBhdGgiKX1zZXQgY2xpcFBhdGgobCl7dGhpc1t1XSgiY2xpcFBhdGgiLGwpfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIyNiksbj10KDIxMyksZD10KDIzMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcobyxjLHApe3JldHVybiBjIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sYyx7dmFsdWU6cCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bY109cCxvfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3dpZHRoOmMsaGVpZ2h0OnB9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gYz4wJiZwPjAmJnN1cGVyLmlzVmlzaWJsZX19Zyh1LCJBdHRyIixkLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwicmVjdCIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBwfSk7dmFyIHI9dCgyMjgpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIGMobCl7Y29uc3R7d2lkdGg6eSxoZWlnaHQ6eH09bDtyZXR1cm5gTTAgMEwke3l9IDBMJHt5fSAke3h9TDAgJHt4fVpgfWNsYXNzIHAgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tkXSh7d2lkdGg6MCxoZWlnaHQ6MH0pLHRoaXNbb10oInNpemUiKX1nZXQgZCgpe3JldHVybiB0aGlzW3VdKCJkIil9c2V0IGQoeSl7fWdldCB3aWR0aCgpe3JldHVybiB0aGlzW3VdKCJ3aWR0aCIpfXNldCB3aWR0aCh5KXtpZih5PU9iamVjdChuLnRvTnVtYmVyKSh5KSx0aGlzW2ddKCJ3aWR0aCIseSkpe2NvbnN0IHg9Yyh0aGlzKTt0aGlzW2ddKCJkIix4KX19Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzW3VdKCJoZWlnaHQiKX1zZXQgaGVpZ2h0KHkpe2lmKHk9T2JqZWN0KG4udG9OdW1iZXIpKHkpLHRoaXNbZ10oImhlaWdodCIseSkpe2NvbnN0IHg9Yyh0aGlzKTt0aGlzW2ddKCJkIix4KX19Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUoeSl7eT1PYmplY3Qobi50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpcy53aWR0aD15WzBdLHRoaXMuaGVpZ2h0PXlbMV19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxkPXQoMjM1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhvLGMscCl7cmV0dXJuIGMgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxjLHt2YWx1ZTpwLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tjXT1wLG99Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6Y309dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBjWzBdPjAmJmNbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX1nKHUsIkF0dHIiLGQuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJ0cmlhbmdsZSIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLGQ9dCgyMzMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKG8sYyxwKXtyZXR1cm4gYyBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGMse3ZhbHVlOnAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2NdPXAsb31jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtwb2ludHM6Y309dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBjLmxlbmd0aD4wJiZzdXBlci5pc1Zpc2libGV9fWcodSwiQXR0ciIsZC5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInBvbHlsaW5lIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDIyOCksbj10KDcyKSxkPXQoMjM0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxvPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gcCh5KXtjb25zdHtwb2ludHM6eCxzbW9vdGg6YixzbW9vdGhSYW5nZTpFLGNsb3NlOnZ9PXksTT1bXTtmb3IobGV0IGE9MDthPHgubGVuZ3RoO2ErPTIpTS5wdXNoKFt4W2FdLHhbYSsxXV0pO2xldCBpPSIiO3JldHVybiBiP2k9T2JqZWN0KGQubWFrZVNtb290aEN1cnZlTGluZSkoTSxFKTpNLmxlbmd0aCYmKGk9YE0ke00ubWFwKGE9PmEuam9pbigiICIpKS5qb2luKCJMIil9YCksaSYmdiYmKGkrPSJaIiksaX1jbGFzcyBsIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKHgpe3N1cGVyKHgpLHRoaXNbZ10oe3BvaW50czpbXSxzbW9vdGg6ITEsc21vb3RoUmFuZ2U6WzBdLGNsb3NlVHlwZToibm9uZSJ9KSx0aGlzW2NdKCJjbG9zZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbb10oImQiKX1zZXQgZCh4KXt9Z2V0IGNsb3NlKCl7cmV0dXJuIHRoaXMuY2xvc2VUeXBlIT09Im5vbmUifXNldCBjbG9zZSh4KXt4PXg/Im5vcm1hbCI6Im5vbmUiLHRoaXMuY2xvc2VUeXBlPXh9Z2V0IGNsb3NlVHlwZSgpe3JldHVybiB0aGlzW29dKCJjbG9zZVR5cGUiKX1zZXQgY2xvc2VUeXBlKHgpe2lmKHghPW51bGwmJnghPT0ibm9uZSImJnghPT0ibm9ybWFsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNsb3NlVHlwZSB0eXBlLiIpO2lmKHRoaXNbdV0oImNsb3NlVHlwZSIseCkpe2NvbnN0IGI9cCh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IHNtb290aCgpe3JldHVybiB0aGlzW29dKCJzbW9vdGgiKX1zZXQgc21vb3RoKHgpe2lmKHRoaXNbdV0oInNtb290aCIseCkpe2NvbnN0IGI9cCh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IHNtb290aFJhbmdlKCl7cmV0dXJuIHRoaXNbb10oInNtb290aFJhbmdlIil9c2V0IHNtb290aFJhbmdlKHgpe2lmKHgmJiFBcnJheS5pc0FycmF5KHgpJiYoeD1beF0pLHRoaXNbdV0oInNtb290aFJhbmdlIix4KSYmdGhpcy5zbW9vdGgpe2NvbnN0IGI9cCh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IHBvaW50cygpe3JldHVybiB0aGlzW29dKCJwb2ludHMiKX1zZXQgcG9pbnRzKHgpe2lmKHg9T2JqZWN0KG4udG9BcnJheSkoeCksQXJyYXkuaXNBcnJheSh4KSYmKHg9eC5yZWR1Y2UoKGIsRSk9PkFycmF5LmlzQXJyYXkoRSk/Wy4uLmIsLi4uRS5tYXAodj0+T2JqZWN0KG4udG9OdW1iZXIpKHYpKV06Wy4uLmIsT2JqZWN0KG4udG9OdW1iZXIpKEUpXSxbXSkpLHRoaXNbdV0oInBvaW50cyIseCkpe2NvbnN0IGI9cCh0aGlzKTt0aGlzW3VdKCJkIixiKX19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwibWFrZVNtb290aEN1cnZlTGluZSIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKG4sZD1bMF0pe2Z1bmN0aW9uIGcoYyxwPS4xNjgsbD0uMTY4KXtsZXQgeSx4LGIsRTtpZigobltjXS54PT09bltjKzFdLnh8fG5bY10ueT09PW5bYysxXS55KSYmKHA9MCxsPTApLGM8MT8oeT1uWzBdLngrKG5bMV0ueC1uWzBdLngpKnAseD1uWzBdLnkrKG5bMV0ueS1uWzBdLnkpKnApOih5PW5bY10ueCsobltjKzFdLngtbltjLTFdLngpKnAseD1uW2NdLnkrKG5bYysxXS55LW5bYy0xXS55KSpwKSxjPm4ubGVuZ3RoLTMpe2NvbnN0IHY9bi5sZW5ndGgtMTtiPW5bdl0ueC0oblt2XS54LW5bdi0xXS54KSpsLEU9blt2XS55LShuW3ZdLnktblt2LTFdLnkpKmx9ZWxzZSBiPW5bYysxXS54LShuW2MrMl0ueC1uW2NdLngpKmwsRT1uW2MrMV0ueS0obltjKzJdLnktbltjXS55KSpsO3JldHVyblt7eDp5LHk6eH0se3g6Yix5OkV9XX1uPW4ubWFwKChbYyxwXSk9Pih7eDpjLHk6cH0pKTtsZXQgdT0iIixvPTA7cmV0dXJuIG4uZm9yRWFjaCgoYyxwKT0+e2lmKHA9PT0wKXUrPWBNJHtjLnh9ICR7Yy55fWA7ZWxzZXtmb3IoO3A+ZFtvXTspbysrO2lmKG8lMil7Y29uc3RbbCx5XT1nKHAtMSk7dSs9YEMke1tsLngsbC55LHkueCx5LnksYy54LGMueV0uam9pbigiICIpfWB9ZWxzZSB1Kz1gTCR7Yy54fSAke2MueX1gfX0pLHV9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHApe2NvbnN0W2wseV09cC5zaWRlcztsZXQgeD1wLmFuZ2xlJTM2MDtyZXR1cm4geDwwJiYoeCs9MzYwKSx4PU1hdGguUEkqeC8xODAsWzAsMCxsLDAseSpNYXRoLmNvcyh4KSx5Kk1hdGguc2luKHgpXX1jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGwpe3N1cGVyKGwpLHRoaXNbZF0oe3NpZGVzOlswLDBdLGFuZ2xlOjYwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMobCl7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW3VdKCJzaWRlcyIpfXNldCBzaWRlcyhsKXtpZihsPU9iamVjdChuLnRvQXJyYXkpKGwsITApLGwhPW51bGwmJiFBcnJheS5pc0FycmF5KGwpJiYobD1bbCxsXSksdGhpc1tnXSgic2lkZXMiLGwpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW3VdKCJhbmdsZSIpfXNldCBhbmdsZShsKXtpZihsPU9iamVjdChuLnRvTnVtYmVyKShsKSx0aGlzW2ddKCJhbmdsZSIsbCkpe2NvbnN0IHk9byh0aGlzKTtzdXBlci5wb2ludHM9eX19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxkPXQoMjM3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhvLGMscCl7cmV0dXJuIGMgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxjLHt2YWx1ZTpwLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tjXT1wLG99Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6Y309dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBjWzBdPjAmJmNbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX1nKHUsIkF0dHIiLGQuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJwYXJhbGxlbCIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHApe2NvbnN0W2wseV09cC5zaWRlcztsZXQgeD1wLmFuZ2xlJTM2MDt4PDAmJih4Kz0zNjApLHg9TWF0aC5QSSp4LzE4MDtjb25zdCBiPXkqTWF0aC5jb3MoeCksRT15Kk1hdGguc2luKHgpO3JldHVyblswLDAsbCwwLGIrbCxFLGIsRV19Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihsKXtzdXBlcihsKSx0aGlzW2RdKHtzaWRlczpbMCwwXSxhbmdsZTo5MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGwpe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1t1XSgic2lkZXMiKX1zZXQgc2lkZXMobCl7aWYobD1PYmplY3Qobi50b0FycmF5KShsLCEwKSxsIT1udWxsJiYhQXJyYXkuaXNBcnJheShsKSYmKGw9W2wsbF0pLHRoaXNbZ10oInNpZGVzIixsKSl7Y29uc3QgeT1vKHRoaXMpO3N1cGVyLnBvaW50cz15fX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1t1XSgiYW5nbGUiKX1zZXQgYW5nbGUobCl7aWYobD1PYmplY3Qobi50b051bWJlcikobCksdGhpc1tnXSgiYW5nbGUiLGwpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDIzMiksbj10KDIxMyksZD10KDIzOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcobyxjLHApe3JldHVybiBjIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sYyx7dmFsdWU6cCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bY109cCxvfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7fWcodSwiQXR0ciIsZC5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsInJlZ3VsYXIiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMzKSxuPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBkPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gbyhwKXtjb25zdHtlZGdlczpsLHJhZGl1czp5LG9mZnNldEFuZ2xlOnh9PXAsYj1NYXRoLlBJKngvMTgwLS41Kk1hdGguUEk7aWYobDwzfHx5PD0wKXJldHVybltdO2NvbnN0IEU9W107Zm9yKGxldCB2PTA7djxsO3YrKyl7Y29uc3QgTT12KjIqTWF0aC5QSS9sK2IsaT15Kk1hdGguY29zKE0pLGE9eSpNYXRoLnNpbihNKTtFLnB1c2goaSxhKX1yZXR1cm4gRX1jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGwpe3N1cGVyKGwpLHRoaXNbZF0oe2VkZ2VzOjMscmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGwpe31nZXQgZWRnZXMoKXtyZXR1cm4gdGhpc1t1XSgiZWRnZXMiKX1zZXQgZWRnZXMobCl7aWYobD1PYmplY3Qobi50b051bWJlcikobCksdGhpc1tnXSgiZWRnZXMiLGwpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCByYWRpdXMoKXtyZXR1cm4gdGhpc1t1XSgicmFkaXVzIil9c2V0IHJhZGl1cyhsKXtpZihsPU9iamVjdChuLnRvTnVtYmVyKShsKSx0aGlzW2ddKCJyYWRpdXMiLGwpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW3VdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShsKXtpZihsPU9iamVjdChuLnRvTnVtYmVyKShsKSx0aGlzW2ddKCJvZmZzZXRBbmdsZSIsbCkpe2NvbnN0IHk9byh0aGlzKTtzdXBlci5wb2ludHM9eX19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjMyKSxuPXQoMjEzKSxkPXQoMjQxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhvLGMscCl7cmV0dXJuIGMgaW4gbz9PYmplY3QuZGVmaW5lUHJvcGVydHkobyxjLHt2YWx1ZTpwLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6b1tjXT1wLG99Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHt9Zyh1LCJBdHRyIixkLmRlZmF1bHQpLG4uZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwic3RhciIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMzMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBvKHApe2NvbnN0e2FuZ2xlczpsLGlubmVyUmFkaXVzOnksb3V0ZXJSYWRpdXM6eCxvZmZzZXRBbmdsZTpifT1wLEU9TWF0aC5QSSpiLzE4MC0uNSpNYXRoLlBJO2lmKGw8M3x8eTw9MHx8eDw9MClyZXR1cm5bXTtjb25zdCB2PVtdO2ZvcihsZXQgTT0wO008bCoyO00rKyl7Y29uc3QgaT1NKk1hdGguUEkvbCtFLGE9TSUyP3k6eCxzPWEqTWF0aC5jb3MoaSksZj1hKk1hdGguc2luKGkpO3YucHVzaChzLGYpfXJldHVybiB2fWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IobCl7c3VwZXIobCksdGhpc1tkXSh7YW5nbGVzOjUsaW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhsKXt9Z2V0IGFuZ2xlcygpe3JldHVybiB0aGlzW3VdKCJhbmdsZXMiKX1zZXQgYW5nbGVzKGwpe2lmKGw9T2JqZWN0KG4udG9OdW1iZXIpKGwpLHRoaXNbZ10oImFuZ2xlcyIsbCkpe2NvbnN0IHk9byh0aGlzKTtzdXBlci5wb2ludHM9eX19Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKGwpe2lmKGw9T2JqZWN0KG4udG9OdW1iZXIpKGwpLHRoaXNbZ10oImlubmVyUmFkaXVzIixsKSl7Y29uc3QgeT1vKHRoaXMpO3N1cGVyLnBvaW50cz15fX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1t1XSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMobCl7aWYobD1PYmplY3Qobi50b051bWJlcikobCksdGhpc1tnXSgib3V0ZXJSYWRpdXMiLGwpKXtjb25zdCB5PW8odGhpcyk7c3VwZXIucG9pbnRzPXl9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKGwpe2w9T2JqZWN0KG4udG9BcnJheSkobCwhMCksQXJyYXkuaXNBcnJheShsKXx8KGw9W2wsbF0pLHRoaXMuaW5uZXJSYWRpdXM9bFswXSx0aGlzLm91dGVyUmFkaXVzPWxbMV19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGwpe2lmKGw9T2JqZWN0KG4udG9OdW1iZXIpKGwpLHRoaXNbZ10oIm9mZnNldEFuZ2xlIixsKSl7Y29uc3QgeT1vKHRoaXMpO3N1cGVyLnBvaW50cz15fX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLGQ9dCgyNDMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKG8sYyxwKXtyZXR1cm4gYyBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGMse3ZhbHVlOnAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2NdPXAsb31jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtyYWRpdXNYOmMscmFkaXVzWTpwLHN0YXJ0QW5nbGU6bCxlbmRBbmdsZTp5fT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGM+MCYmcD4wJiZsIT09eSYmc3VwZXIuaXNWaXNpYmxlfX1nKHUsIkF0dHIiLGQuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJlbGxpcHNlIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxkPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBwKHkpe2NvbnN0e3JhZGl1c1g6eCxyYWRpdXNZOmIsc3RhcnRBbmdsZTpFLGVuZEFuZ2xlOnYsZGlyZWN0aW9uOk0sY2xvc2VUeXBlOml9PXksYT1NPT09ImFuaXRjbG9ja3dpc2UiLHM9bmV3IHIuRmlndXJlMkQ7cmV0dXJuIGk9PT0ic2VjdG9yIiYmcy5tb3ZlVG8oMCwwKSxzLmVsbGlwc2UoMCwwLHgsYiwwLE1hdGguUEkqRS8xODAsTWF0aC5QSSp2LzE4MCxhKSxpIT09Im5vbmUiJiZzLmNsb3NlUGF0aCgpLHMucGF0aC5yZWR1Y2UoKEEsUik9PkErUi5qb2luKCIgIiksIiIpfWNsYXNzIGwgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoeCl7c3VwZXIoeCksdGhpc1tnXSh7cmFkaXVzWDowLHJhZGl1c1k6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwLGRpcmVjdGlvbjoiY2xvY2t3aXNlIixjbG9zZVR5cGU6Im5vbmUifSksdGhpc1tjXSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW29dKCJkIil9c2V0IGQoeCl7fWdldCByYWRpdXNYKCl7cmV0dXJuIHRoaXNbb10oInJhZGl1c1giKX1zZXQgcmFkaXVzWCh4KXtpZih4PU9iamVjdChkLnRvTnVtYmVyKSh4KSx0aGlzW3VdKCJyYWRpdXNYIix4KSl7Y29uc3QgYj1wKHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgcmFkaXVzWSgpe3JldHVybiB0aGlzW29dKCJyYWRpdXNZIil9c2V0IHJhZGl1c1koeCl7aWYoeD1PYmplY3QoZC50b051bWJlcikoeCksdGhpc1t1XSgicmFkaXVzWSIseCkpe2NvbnN0IGI9cCh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLnJhZGl1c1gsdGhpcy5yYWRpdXNZXX1zZXQgcmFkaXVzKHgpe3g9T2JqZWN0KGQudG9BcnJheSkoeCwhMCksQXJyYXkuaXNBcnJheSh4KXx8KHg9W3gseF0pLHRoaXMucmFkaXVzWD14WzBdLHRoaXMucmFkaXVzWT14WzFdfWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKHgpe3g9T2JqZWN0KGQudG9BcnJheSkoeCksQXJyYXkuaXNBcnJheSh4KXx8KHg9W3gseF0pLHRoaXMuc3RhcnRBbmdsZT14WzBdLHRoaXMuZW5kQW5nbGU9eFsxXX1nZXQgZGlyZWN0aW9uKCl7cmV0dXJuIHRoaXNbb10oImRpcmVjdGlvbiIpfXNldCBkaXJlY3Rpb24oeCl7aWYoeCE9bnVsbCYmeCE9PSJjbG9ja3dpc2UiJiZ4IT09ImFudGljbG9ja3dpc2UiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZGlyZWN0aW9uIHR5cGUuIik7dGhpc1t1XSgiZGlyZWN0aW9uIix4KX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW29dKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUoeCl7aWYoeD1PYmplY3QoZC50b051bWJlcikoeCksdGhpc1t1XSgic3RhcnRBbmdsZSIseCkpe2NvbnN0IGI9cCh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbb10oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKHgpe2lmKHg9T2JqZWN0KGQudG9OdW1iZXIpKHgpLHRoaXNbdV0oImVuZEFuZ2xlIix4KSl7Y29uc3QgYj1wKHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbb10oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUoeCl7aWYoeCE9bnVsbCYmeCE9PSJub25lIiYmeCE9PSJzZWN0b3IiJiZ4IT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW3VdKCJjbG9zZVR5cGUiLHgpKXtjb25zdCBiPXAodGhpcyk7dGhpc1t1XSgiZCIsYil9fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgcj10KDI0Miksbj10KDIxMyksZD10KDI0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGcobyxjLHApe3JldHVybiBjIGluIG8/T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sYyx7dmFsdWU6cCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOm9bY109cCxvfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7fWcodSwiQXR0ciIsZC5kZWZhdWx0KSxuLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHUsImFyYyIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIHI9dCgyNDMpLG49dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIGQgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IHJhZGl1cygpe3JldHVybiBzdXBlci5yYWRpdXNYfXNldCByYWRpdXModSl7dT1PYmplY3Qobi50b051bWJlcikodSksc3VwZXIucmFkaXVzWD11LHN1cGVyLnJhZGl1c1k9dX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMjYpLG49dCgyMTMpLGQ9dCgyNDcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBnKG8sYyxwKXtyZXR1cm4gYyBpbiBvP09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGMse3ZhbHVlOnAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpvW2NdPXAsb31jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtpbm5lclJhZGl1czpjLG91dGVyUmFkaXVzOnAsc3RhcnRBbmdsZTpsLGVuZEFuZ2xlOnl9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4oYz4wfHxwPjApJiZsIT09eSYmc3VwZXIuaXNWaXNpYmxlfX1nKHUsIkF0dHIiLGQuZGVmYXVsdCksbi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJyaW5nIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDEyKSxuPXQoMjI4KSxkPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBnPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBwKHkpe2xldHtpbm5lclJhZGl1czp4LG91dGVyUmFkaXVzOmIsc3RhcnRBbmdsZTpFLGVuZEFuZ2xlOnZ9PXk7Y29uc3QgTT1uZXcgci5GaWd1cmUyRDtpZihFPU1hdGguUEkqRS8xODAsdj1NYXRoLlBJKnYvMTgwLHg+YiYmKFt4LGJdPVtiLHhdKSx4PD0wJiZNLm1vdmVUbygwLDApLE0uYXJjKDAsMCxiLEUsdiwhMSkseD4wKXtjb25zdCBzPU1hdGguUEkqMjt2PEUmJih2PUUrcysodi1FKSVzKSx2LUU+PXMmJih2PUUrcy0xZS02KSxNLmFyYygwLDAseCx2LEUsITApfXJldHVybiBNLmNsb3NlUGF0aCgpLE0ucGF0aC5yZWR1Y2UoKHMsZik9PnMrZi5qb2luKCIgIiksIiIpfWNsYXNzIGwgZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoeCl7c3VwZXIoeCksdGhpc1tnXSh7aW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjB9KSx0aGlzW2NdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbb10oImQiKX1zZXQgZCh4KXt9Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbb10oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKHgpe2lmKHg9T2JqZWN0KGQudG9OdW1iZXIpKHgpLHRoaXNbdV0oImlubmVyUmFkaXVzIix4KSl7Y29uc3QgYj1wKHRoaXMpO3RoaXNbdV0oImQiLGIpfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tvXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoeCl7aWYoeD1PYmplY3QoZC50b051bWJlcikoeCksdGhpc1t1XSgib3V0ZXJSYWRpdXMiLHgpKXtjb25zdCBiPXAodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKHgpe3g9T2JqZWN0KGQudG9BcnJheSkoeCwhMCksQXJyYXkuaXNBcnJheSh4KXx8KHg9W3gseF0pLHRoaXMuaW5uZXJSYWRpdXM9eFswXSx0aGlzLm91dGVyUmFkaXVzPXhbMV19Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1tvXSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKHgpe2lmKHg9T2JqZWN0KGQudG9OdW1iZXIpKHgpLHRoaXNbdV0oInN0YXJ0QW5nbGUiLHgpKXtjb25zdCBiPXAodGhpcyk7dGhpc1t1XSgiZCIsYil9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW29dKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZSh4KXtpZih4PU9iamVjdChkLnRvTnVtYmVyKSh4KSx0aGlzW3VdKCJlbmRBbmdsZSIseCkpe2NvbnN0IGI9cCh0aGlzKTt0aGlzW3VdKCJkIixiKX19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUoeCl7eD1PYmplY3QoZC50b0FycmF5KSh4KSxBcnJheS5pc0FycmF5KHgpfHwoeD1beCx4XSksdGhpcy5zdGFydEFuZ2xlPXhbMF0sdGhpcy5lbmRBbmdsZT14WzFdfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KTt2YXIgcj10KDEyKSxuPXQoMjE4KSxkPXQoMjE5KSxnPXQoMjQ5KSx1PXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhFLHYsTSl7cmV0dXJuIHYgaW4gRT9PYmplY3QuZGVmaW5lUHJvcGVydHkoRSx2LHt2YWx1ZTpNLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6RVt2XT1NLEV9Y29uc3QgYz1TeW1ib2woInRleHRJbWFnZSIpLHA9U3ltYm9sKCJ0ZXh0SW1hZ2VUYXNrIiksbD1TeW1ib2woInRleHR1cmVDb250ZXh0IikseT1TeW1ib2woInVwZGF0ZVRleHR1cmVSZWN0IikseD1TeW1ib2woInRleHRDYW52YXMiKTtjbGFzcyBiIGV4dGVuZHMgZC5kZWZhdWx0e2NvbnN0cnVjdG9yKHY9e30pe3R5cGVvZiB2PT0ic3RyaW5nIiYmKHY9e3RleHQ6dn0pLHN1cGVyKHYpfWdldCBjb250ZW50U2l6ZSgpe2xldFt2LE1dPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOmksaGVpZ2h0OmF9PXRoaXMuYXR0cmlidXRlcztpZihpPT1udWxsfHxhPT1udWxsKXtjb25zdCBzPXRoaXNbY107cyYmKGk9PW51bGwmJih2PXMucmVjdFsyXSksYT09bnVsbCYmKE09cy5yZWN0WzNdKSl9cmV0dXJuW3YsTV19Z2V0IHRleHQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHQodil7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9dn1nZXQgdGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHRDb250ZW50KHYpe3RoaXMuYXR0cmlidXRlcy50ZXh0PXZ9Z2V0IHRleHRJbWFnZSgpe3JldHVybiB0aGlzW2NdfHx7fX1nZXQgdGV4dEltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1twXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyh2KXtzdXBlci5kcmF3KHYpO2NvbnN0IE09dGhpcy5tZXNoO2lmKE0pe2NvbnN0IGk9dGhpc1tjXTtpZihpKXtsZXQgYT1NLnRleHR1cmU7aWYoIWF8fHRoaXNbbF0mJnRoaXNbbF0hPT10aGlzLnJlbmRlcmVyfHxpLm5lZWRzVXBkYXRlPyhpLm5lZWRzVXBkYXRlPSExLE9iamVjdChuLmRlbGV0ZVRleHR1cmUpKGkuaW1hZ2UsdGhpcy5yZW5kZXJlciksYT1PYmplY3Qobi5jcmVhdGVUZXh0dXJlKShpLmltYWdlLHRoaXMucmVuZGVyZXIpLHRoaXNbeV09ITApOmE9TS51bmlmb3Jtcy51X3RleFNhbXBsZXIsdGhpc1t5XSl7Y29uc3RbcyxmXT1pLnJlY3Quc2xpY2UoMiksW08sQV09dGhpcy5jb250ZW50U2l6ZSxSPXRoaXMuYXR0cmlidXRlcy50ZXh0QWxpZ24sST10aGlzLmF0dHJpYnV0ZXMudmVydGljYWxBbGlnbjtsZXQgUD0wO1I9PT0iY2VudGVyIj9QPShPLXMpLzI6KFI9PT0icmlnaHQifHxSPT09ImVuZCIpJiYoUD1PLXMpO2NvbnN0IEw9dGhpcy5hdHRyaWJ1dGVzLmZvbnRTaXplLEQ9dGhpcy5hdHRyaWJ1dGVzLmxpbmVIZWlnaHQ7bGV0IEM9MDtJPT09InRvcCI/Qz0oTC1EKS8yOkk9PT0iYm90dG9tIiYmKEM9KEQtTCkvMik7Y29uc3R7cGFkZGluZ0xlZnQ6UyxwYWRkaW5nVG9wOkJ9PXRoaXMuYXR0cmlidXRlcyx7Ym9yZGVyV2lkdGg6d309dGhpcy5hdHRyaWJ1dGVzO1ArPVMrdyxDKz1CK3c7Y29uc3R7YW5jaG9yWDpILGFuY2hvclk6Wn09dGhpcy5hdHRyaWJ1dGVzO1AtPXRoaXMub2Zmc2V0U2l6ZVswXSpILEMtPXRoaXMub2Zmc2V0U2l6ZVsxXSpaLE0uc2V0VGV4dHVyZShhLHtyZWN0OltQLEMscyxmXX0pLHRoaXNbeV09ITEsdGhpc1tsXT10aGlzLnJlbmRlcmVyfX19cmV0dXJuIHZ9b25Qcm9wZXJ0eUNoYW5nZSh2LE0saSl7dj09PSJ0ZXh0Inx8dj09PSJmb250U2l6ZSJ8fHY9PT0iZm9udEZhbWlseSJ8fHY9PT0iZm9udFN0eWxlInx8dj09PSJmb250VmFyaWFudCJ8fHY9PT0iZm9udFdlaWdodCJ8fHY9PT0iZm9udFN0cmV0Y2gifHx2PT09ImxpbmVIZWlnaHQifHx2PT09InN0cm9rZUNvbG9yInx8dj09PSJmaWxsQ29sb3IifHx2PT09InN0cm9rZVdpZHRoIj90aGlzLnVwZGF0ZVRleHQoKTooKHY9PT0idGV4dEFsaWduInx8dj09PSJ2ZXJ0aWNhbEFsaWduIikmJih0aGlzW3ldPSEwKSxzdXBlci5vblByb3BlcnR5Q2hhbmdlKHYsTSxpKSl9dXBkYXRlQ29udG91cnMoKXtzdXBlci51cGRhdGVDb250b3VycygpLHRoaXNbeV09ITB9dXBkYXRlVGV4dCgpe3RoaXNbcF18fCh0aGlzW3BdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzW3BdPW51bGw7Y29uc3R7dGV4dDp2LGZvbnQ6TSxmaWxsQ29sb3I6aSxzdHJva2VDb2xvcjphLHN0cm9rZVdpZHRoOnN9PXRoaXMuYXR0cmlidXRlcyxmPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtyZXR1cm4gdGhpc1t4XT10aGlzW3hdfHxyLkVOVi5jcmVhdGVDYW52YXMoMSwxKSx0aGlzW2NdPXIuRU5WLmNyZWF0ZVRleHQodix7Zm9udDpNLGZpbGxDb2xvcjppLHN0cm9rZUNvbG9yOmEsc3Ryb2tlV2lkdGg6cyxwYXJzZUZvbnQ6ci5wYXJzZUZvbnQscmF0aW86Zix0ZXh0Q2FudmFzOnRoaXNbeF19KSx0aGlzW2NdLm5lZWRzVXBkYXRlPSEwLHRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpc1tjXX0pKX19byhiLCJBdHRyIixnLmRlZmF1bHQpLHUuZGVmYXVsdC5yZWdpc3Rlck5vZGUoYiwibGFiZWwiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciByPXQoMTIpLG49dCg3MiksZD10KDIyMSksZz10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLG89U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxwPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2NsYXNzIGwgZXh0ZW5kcyBnLmRlZmF1bHR7Y29uc3RydWN0b3IoeCl7c3VwZXIoeCksdGhpc1t1XSh7dGV4dDoiIixmb250U2l6ZToxNixmb250RmFtaWx5OiJIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZiIsZm9udFN0eWxlOiJub3JtYWwiLGZvbnRWYXJpYW50OiJub3JtYWwiLGZvbnRXZWlnaHQ6Im5vcm1hbCIsZm9udFN0cmV0Y2g6Im5vcm1hbCIsbGluZUhlaWdodDoiIix0ZXh0QWxpZ246ImxlZnQiLHN0cm9rZUNvbG9yOnZvaWQgMCxzdHJva2VXaWR0aDoxLGZpbGxDb2xvcjp2b2lkIDAsdmVydGljYWxBbGlnbjoibWlkZGxlIn0pLHRoaXNbcF0oImZvbnQiKX1nZXQgdGV4dCgpe3JldHVybiB0aGlzW2NdKCJ0ZXh0Iil8fCIgIn1zZXQgdGV4dCh4KXt0aGlzW29dKCJ0ZXh0Iix4KX1nZXQgZm9udFNpemUoKXtyZXR1cm4gdGhpc1tjXSgiZm9udFNpemUiKX1zZXQgZm9udFNpemUoeCl7dGhpc1tvXSgiZm9udFNpemUiLE9iamVjdChuLnRvTnVtYmVyKSh4KSl9Z2V0IGZvbnRGYW1pbHkoKXtyZXR1cm4gdGhpc1tjXSgiZm9udEZhbWlseSIpfXNldCBmb250RmFtaWx5KHgpe3RoaXNbb10oImZvbnRGYW1pbHkiLHgpfWdldCBmb250U3R5bGUoKXtyZXR1cm4gdGhpc1tjXSgiZm9udFN0eWxlIil9c2V0IGZvbnRTdHlsZSh4KXt0aGlzW29dKCJmb250U3R5bGUiLHgpfWdldCBmb250VmFyaWFudCgpe3JldHVybiB0aGlzW2NdKCJmb250VmFyaWFudCIpfXNldCBmb250VmFyaWFudCh4KXt0aGlzW29dKCJmb250VmFyaWFudCIseCl9Z2V0IGZvbnRXZWlnaHQoKXtyZXR1cm4gdGhpc1tjXSgiZm9udFdlaWdodCIpfXNldCBmb250V2VpZ2h0KHgpe3RoaXNbb10oImZvbnRXZWlnaHQiLHgpfWdldCBmb250U3RyZXRjaCgpe3JldHVybiB0aGlzW2NdKCJmb250U3RyZXRjaCIpfXNldCBmb250U3RyZXRjaCh4KXt0aGlzW29dKCJmb250U3RyZXRjaCIseCl9Z2V0IGxpbmVIZWlnaHQoKXtyZXR1cm4gdGhpc1tjXSgibGluZUhlaWdodCIpfHx0aGlzLmZvbnRTaXplfXNldCBsaW5lSGVpZ2h0KHgpe3RoaXNbb10oImxpbmVIZWlnaHQiLE9iamVjdChuLnRvTnVtYmVyKSh4KSl9Z2V0IHRleHRBbGlnbigpe3JldHVybiB0aGlzW2NdKCJ0ZXh0QWxpZ24iKX1zZXQgdGV4dEFsaWduKHgpe3RoaXNbb10oInRleHRBbGlnbiIseCl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbY10oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKHgpe3RoaXNbb10oInN0cm9rZUNvbG9yIixPYmplY3QoZC5wYXJzZUNvbG9yKSh4KSl9Z2V0IHN0cm9rZVdpZHRoKCl7cmV0dXJuIHRoaXNbY10oInN0cm9rZVdpZHRoIil9c2V0IHN0cm9rZVdpZHRoKHgpe3RoaXNbb10oInN0cm9rZVdpZHRoIixPYmplY3Qobi50b051bWJlcikoeCkpfWdldCB2ZXJ0aWNhbEFsaWduKCl7cmV0dXJuIHRoaXNbY10oInZlcnRpY2FsQWxpZ24iKX1zZXQgdmVydGljYWxBbGlnbih4KXt0aGlzW29dKCJ2ZXJ0aWNhbEFsaWduIix4KX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbY10oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IoeCl7dGhpc1tvXSgiZmlsbENvbG9yIixPYmplY3QoZC5wYXJzZUNvbG9yKSh4KSl9Z2V0IGZvbnQoKXtjb25zdHtmb250U3R5bGU6eCxmb250VmFyaWFudDpiLGZvbnRXZWlnaHQ6RSxmb250U3RyZXRjaDp2LGZvbnRTaXplOk0sbGluZUhlaWdodDppLGZvbnRGYW1pbHk6YX09dGhpcztyZXR1cm5gJHt4fSAke2J9ICR7RX0gJHt2fSAke019cHgvJHtpfXB4ICR7YX1gfXNldCBmb250KHgpe2lmKHg9PW51bGwpdGhpcy5mb250U3R5bGU9bnVsbCx0aGlzLmZvbnRWYXJpYW50PW51bGwsdGhpcy5mb250V2VpZ2h0PW51bGwsdGhpcy5mb250U3RyZXRjaD1udWxsLHRoaXMuZm9udFNpemU9bnVsbCx0aGlzLmxpbmVIZWlnaHQ9bnVsbCx0aGlzLmZvbnRGYW1pbHk9bnVsbDtlbHNle2NvbnN0IGI9T2JqZWN0KHIucGFyc2VGb250KSh4KTt0aGlzLmZvbnRTdHlsZT1iLnN0eWxlLHRoaXMuZm9udFZhcmlhbnQ9Yi52YXJpYW50LHRoaXMuZm9udFdlaWdodD1iLndlaWdodCx0aGlzLmZvbnRTdHJldGNoPWIuc3RyZXRjaCx0aGlzLmZvbnRTaXplPU9iamVjdChuLnRvTnVtYmVyKShgJHtiLnNpemV9JHtiLnVuaXR9YCksYi5saW5lSGVpZ2h0JiYodGhpcy5saW5lSGVpZ2h0PWIucHhMaW5lSGVpZ2h0KSx0aGlzLmZvbnRGYW1pbHk9Yi5mYW1pbHl9fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDEyKSxuPXQoMjE5KSxkPXQoMjUxKSxnPXQoMjEzKSx1PXQoMjUyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhiLEUsdil7cmV0dXJuIEUgaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixFLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltFXT12LGJ9Y29uc3QgYz1TeW1ib2woInpPcmRlciIpLHA9U3ltYm9sKCJvcmRlcmVkIiksbD1TeW1ib2woImNoaWxkcmVuIikseT1TeW1ib2woInNlYWxlZCIpO2NsYXNzIHggZXh0ZW5kcyBuLmRlZmF1bHR7Y29uc3RydWN0b3IoRT17fSl7c3VwZXIoRSksdGhpc1tsXT1bXSx0aGlzW3BdPW51bGwsdGhpc1tjXT0wfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuIHRoaXNbbF19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXNbbF19Z2V0IG9yZGVyZWRDaGlsZHJlbigpe3JldHVybiB0aGlzW3BdfHwodGhpc1twXT1bLi4udGhpc1tsXV0sdGhpc1twXS5zb3J0KChFLHYpPT5FLnpJbmRleC12LnpJbmRleHx8RS56T3JkZXItdi56T3JkZXIpKSx0aGlzW3BdfWFwcGVuZCguLi5FKXtyZXR1cm4gRS5tYXAodj0+dGhpcy5hcHBlbmRDaGlsZCh2KSl9YXBwZW5kQ2hpbGQoRSl7cmV0dXJuIEUucmVtb3ZlKCksdGhpc1tsXS5wdXNoKEUpLEUuY29ubmVjdCh0aGlzLHRoaXNbY10rKyksdGhpc1twXSYmKHRoaXNbcF0ubGVuZ3RoJiZFLnpJbmRleDx0aGlzW3BdW3RoaXNbcF0ubGVuZ3RoLTFdLnpJbmRleD90aGlzLnJlb3JkZXIoKTp0aGlzW3BdLnB1c2goRSkpLEV9Y2xvbmVOb2RlKEU9ITEpe2NvbnN0IHY9c3VwZXIuY2xvbmVOb2RlKCk7cmV0dXJuIEUmJnRoaXNbbF0uZm9yRWFjaChNPT57Y29uc3QgaT1NLmNsb25lTm9kZShFKTt2LmFwcGVuZENoaWxkKGkpfSksdn1kaXNwYXRjaFBvaW50ZXJFdmVudChFKXtjb25zdCB2PXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgTT12Lmxlbmd0aC0xO00+PTA7TS0tKWlmKHZbTV0uZGlzcGF0Y2hQb2ludGVyRXZlbnQoRSkpcmV0dXJuITA7cmV0dXJuIHN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KEUpfWRyYXcoRT1bXSl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PXRoaXMucmVuZGVyTWF0cml4LHN1cGVyLmRyYXcoRSksIXRoaXNbeV0mJnRoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiKXtjb25zdCB2PXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgTT0wO008di5sZW5ndGg7TSsrKXZbTV0uZHJhdyhFKX1yZXR1cm4gdGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PW51bGwsRX1nZXRFbGVtZW50QnlJZChFKXtyZXR1cm4gT2JqZWN0KHUucXVlcnlTZWxlY3RvcikoYCMke0V9YCx0aGlzKX1nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKEUpe3JldHVybiBPYmplY3QodS5xdWVyeVNlbGVjdG9yQWxsKShgLiR7RX1gLHRoaXMpfWdldEVsZW1lbnRzQnlOYW1lKEUpe3JldHVybiBPYmplY3QodS5xdWVyeVNlbGVjdG9yQWxsKShgW25hbWU9IiR7RX0iXWAsdGhpcyl9Z2V0RWxlbWVudHNCeVRhZ05hbWUoRSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3JBbGwpKEUsdGhpcyl9aW5zZXJ0QmVmb3JlKEUsdil7aWYodj09bnVsbClyZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChFKTtFLnJlbW92ZSgpO2NvbnN0IE09dGhpc1tsXS5pbmRleE9mKHYpO2lmKE08MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7Y29uc3QgaT12LnpPcmRlcjtmb3IobGV0IGE9TTthPHRoaXNbbF0ubGVuZ3RoO2ErKyl7Y29uc3Qgcz10aGlzW2xdW2FdLnpPcmRlcixmPXRoaXNbbF1bYV07ZGVsZXRlIGYuek9yZGVyLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCJ6T3JkZXIiLHt2YWx1ZTpzKzEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9aWYodGhpc1tsXS5zcGxpY2UoTSwwLEUpLEUuY29ubmVjdCh0aGlzLGkpLHRoaXNbcF0paWYoRS56SW5kZXghPT12LnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IGE9dGhpc1twXS5pbmRleE9mKHYpO3RoaXNbcF0uc3BsaWNlKGEsMCxFKX1yZXR1cm4gRX1xdWVyeVNlbGVjdG9yKEUpe3JldHVybiBPYmplY3QodS5xdWVyeVNlbGVjdG9yKShFLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoRSl7cmV0dXJuIE9iamVjdCh1LnF1ZXJ5U2VsZWN0b3JBbGwpKEUsdGhpcyl9cmVwbGFjZUNoaWxkKEUsdil7RS5yZW1vdmUoKTtjb25zdCBNPXRoaXNbbF0uaW5kZXhPZih2KTtpZihNPDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2lmKHRoaXNbbF1bTV09RSxFLmNvbm5lY3QodGhpcyx2LnpPcmRlciksdGhpc1twXSlpZihFLnpJbmRleCE9PXYuekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3QgaT10aGlzW3BdLmluZGV4T2Yodik7dGhpc1twXVtpXT1FfXJldHVybiB2LmRpc2Nvbm5lY3QodGhpcyksRX1yZW1vdmVBbGxDaGlsZHJlbigpe2NvbnN0IEU9dGhpc1tsXTtmb3IobGV0IHY9RS5sZW5ndGgtMTt2Pj0wO3YtLSlFW3ZdLnJlbW92ZSgpfXJlbW92ZUNoaWxkKEUpe2NvbnN0IHY9dGhpc1tsXS5pbmRleE9mKEUpO2lmKHY+PTApe2lmKHRoaXNbbF0uc3BsaWNlKHYsMSksdGhpc1twXSl7Y29uc3QgTT10aGlzW3BdLmluZGV4T2YoRSk7dGhpc1twXS5zcGxpY2UoTSwxKX1yZXR1cm4gRS5kaXNjb25uZWN0KHRoaXMpLEV9cmV0dXJuIG51bGx9cmVvcmRlcigpe3RoaXNbcF09bnVsbH1zZWFsKCl7ZnVuY3Rpb24gRShhLHMpe2NvbnN0IGY9W107Zm9yKGxldCBPPTA7TzxhLmxlbmd0aDtPKyspe2NvbnN0IEE9Wy4uLmFbT11dO2ZvcihsZXQgUj0xO1I8QS5sZW5ndGg7Uis9Mil7Y29uc3QgST1BW1JdLFA9QVtSKzFdO0FbUl09SSpzWzBdK1Aqc1syXStzWzRdLEFbUisxXT1JKnNbMV0rUCpzWzNdK3NbNV19Zi5wdXNoKEEpfXJldHVybiBmfWNvbnN0IHY9dGhpcy5vcmRlcmVkQ2hpbGRyZW4sTT1uZXcgci5GaWd1cmUyRCxpPXRoaXMubG9jYWxNYXRyaXg7Zm9yKGxldCBhPTA7YTx2Lmxlbmd0aDthKyspe2xldCBzPXZbYV07aWYocyBpbnN0YW5jZW9mIHgmJihzPXMuc2VhbCgpKSxzLmNsaWVudEJveCl7bGV0IGY9cy5jbGllbnRCb3guY29udG91cnMucGF0aDtmPUUoZixzLmxvY2FsTWF0cml4KSxNLmFkZFBhdGgoZil9aWYocy5wYXRoKXtsZXQgZj1zLnBhdGguY29udG91cnMucGF0aDtmPUUoZixzLmxvY2FsTWF0cml4KSxNLmFkZFBhdGgoZil9fXJldHVybiB0aGlzW3ldPSEwLHRoaXMuY2xpZW50Qm94PU0se2NsaWVudEJveDpNLGxvY2FsTWF0cml4Oml9fXNldFJlc29sdXRpb24oe3dpZHRoOkUsaGVpZ2h0OnZ9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpFLGhlaWdodDp2fSksdGhpc1tsXS5mb3JFYWNoKE09PntNLnNldFJlc29sdXRpb24oe3dpZHRoOkUsaGVpZ2h0OnZ9KX0pfXVwZGF0ZUNvbnRvdXJzKCl7dGhpc1t5XXx8c3VwZXIudXBkYXRlQ29udG91cnMoKX19byh4LCJBdHRyIixkLmRlZmF1bHQpLGcuZGVmYXVsdC5yZWdpc3Rlck5vZGUoeCwiZ3JvdXAiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pO3ZhciByPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgbiBleHRlbmRzIHIuZGVmYXVsdHt9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJxdWVyeVNlbGVjdG9yQWxsIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInF1ZXJ5U2VsZWN0b3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiaXNNYXRjaGVkIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImNvbXBpbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KTt2YXIgcj10KDIyMSksbj10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGQ9dCgyNTMpO2Z1bmN0aW9uIGcodil7cmV0dXJuIHYubm9kZVR5cGU9PT0xfHxuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKHYubm9kZU5hbWUpfWZ1bmN0aW9uIHUodil7cmV0dXJuIEFycmF5LmZyb20odi5jaGlsZE5vZGVzfHxbXSl9ZnVuY3Rpb24gbyh2KXtyZXR1cm4gbi5kZWZhdWx0LmlzU3ByaXRlTm9kZSh2Lm5vZGVOYW1lKT92LnBhcmVudHx8di5jYW52YXN8fHYuY29udGFpbmVyOnYucGFyZW50RWxlbWVudH1mdW5jdGlvbiBjKHYpe2xldCBNPXYubGVuZ3RoLGksYSxzO2Zvcig7LS1NPi0xOyl7Zm9yKGk9YT12W01dLHZbTV09bnVsbCxzPSEwO2E7KXtpZih2LmluZGV4T2YoYSk+LTEpe3M9ITEsdi5zcGxpY2UoTSwxKTticmVha31hPW8oYSl9cyYmKHZbTV09aSl9cmV0dXJuIHZ9Y29uc3QgcD17aXNUYWc6ZyxleGlzdHNPbmUodixNKXtyZXR1cm4gTS5zb21lKGk9PmcoaSk/dihpKXx8cC5leGlzdHNPbmUodix1KGkpKTohMSl9LGdldFNpYmxpbmdzKHYpe2NvbnN0IE09byh2KTtyZXR1cm4gTSYmdShNKX0sZ2V0Q2hpbGRyZW46dSxnZXRQYXJlbnQ6byxnZXRBdHRyaWJ1dGVWYWx1ZSh2LE0pe2lmKHYubm9kZVR5cGU9PT0xJiZNPT09ImNsYXNzInx8TT09PSJpZCIpcmV0dXJuIHZbTV07aWYodGhpcy5oYXNBdHRyaWIodixNKSl7bGV0IGk9di5hdHRyaWJ1dGVzW01dO3JldHVybiBBcnJheS5pc0FycmF5KGkpJiYoaT1gWyR7aS5qb2luKCl9XWApLFN0cmluZyhpKX19LGhhc0F0dHJpYih2LE0pe3JldHVybiB2LmF0dHJpYnV0ZXNbTV0hPW51bGx9LHJlbW92ZVN1YnNldHM6YyxnZXROYW1lKHYpe3JldHVybiB2LnRhZ05hbWU/di50YWdOYW1lLnRvTG93ZXJDYXNlKCk6bnVsbH0sZmluZE9uZTpmdW5jdGlvbiB2KE0saSl7bGV0IGE9bnVsbDtmb3IobGV0IHM9MCxmPWkubGVuZ3RoO3M8ZiYmIWE7cysrKWlmKE0oaVtzXSkpYT1pW3NdO2Vsc2V7Y29uc3QgTz11KGlbc10pO08mJk8ubGVuZ3RoPjAmJihhPXYoTSxPKSl9cmV0dXJuIGF9LGZpbmRBbGw6ZnVuY3Rpb24gdihNLGkpe2xldCBhPVtdO2ZvcihsZXQgcz0wLGY9aS5sZW5ndGg7czxmO3MrKyl7aWYoIWcoaVtzXSkpY29udGludWU7TShpW3NdKSYmYS5wdXNoKGlbc10pO2NvbnN0IE89dShpW3NdKTtPJiYoYT1hLmNvbmNhdCh2KE0sTykpKX1yZXR1cm4gYX0sZ2V0VGV4dDpmdW5jdGlvbiB2KE0pe3JldHVybiBBcnJheS5pc0FycmF5KE0pP00ubWFwKHYpLmpvaW4oIiIpOmcoTSk/dih1KE0pKTpNLm5vZGVUeXBlPT09Mz9NLm5vZGVWYWx1ZTpuLmRlZmF1bHQuaXNTcHJpdGVOb2RlKE0ubm9kZU5hbWUpP00udGV4dDoiIn19O2Z1bmN0aW9uIGwodil7aWYodHlwZW9mIHYhPSJzdHJpbmciKXJldHVybiB2O2xldCBNPXYubWF0Y2goL1xbKGJnY29sb3J8ZmlsbENvbG9yfHN0cm9rZUNvbG9yfGNvbG9yKVxzKj1ccypbJyJdP1x3K1snIl0/XF0vZyk7cmV0dXJuIE0mJihNPU0ubWFwKGk9Pntjb25zdCBhPWkuc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxzPU9iamVjdChyLnBhcnNlQ29sb3IpKGFbMV0ucmVwbGFjZSgvWyciXS9nLCIiKSk7cmV0dXJuW2ksYFske2FbMF19PSIke3N9Il1gXX0pLE0uZm9yRWFjaCgoW2ksYV0pPT57dj12LnJlcGxhY2UoaSxhKX0pKSxNPXYubWF0Y2goL1xbXHcrXHMqPVxzKlsnIl1cWy4rP1xdWyciXVxdL2cpLE0mJihNPU0ubWFwKGk9Pntjb25zdCBhPWkuc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxzPWFbMV0uc2xpY2UoMiwtMikuc3BsaXQoLywvZykubWFwKGY9PmYudHJpbSgpKTtyZXR1cm5baSxgWyR7YVswXX09Ilske3N9XSJdYF19KSxNLmZvckVhY2goKFtpLGFdKT0+e3Y9di5yZXBsYWNlKGksYSl9KSksdn1mdW5jdGlvbiB5KHYsTSl7cmV0dXJuIGQuc2VsZWN0QWxsKGwodiksTSx7YWRhcHRlcjpwfSl9ZnVuY3Rpb24geCh2LE0pe3JldHVybiBkLnNlbGVjdE9uZShsKHYpLE0se2FkYXB0ZXI6cH0pfWZ1bmN0aW9uIGIodixNKXtyZXR1cm4gZC5pcyh2LGwoTSkse2FkYXB0ZXI6cH0pfWZ1bmN0aW9uIEUodil7cmV0dXJuIGQuY29tcGlsZShsKHYpLHthZGFwdGVyOnB9KX19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9RTt2YXIgcj10KDI1NCksbj10KDI3MykuZmFsc2VGdW5jLGQ9dCgyNzQpO2Z1bmN0aW9uIGcodil7cmV0dXJuIGZ1bmN0aW9uKGksYSxzKXtyZXR1cm4gYT1hfHx7fSxhLmFkYXB0ZXI9YS5hZGFwdGVyfHxyLHYoaSxhLHMpfX12YXIgdT1nKGQpLG89ZyhkLmNvbXBpbGVVbnNhZmUpO2Z1bmN0aW9uIGModil7cmV0dXJuIGZ1bmN0aW9uKGksYSxzKXtyZXR1cm4gcz1zfHx7fSxzLmFkYXB0ZXI9cy5hZGFwdGVyfHxyLHR5cGVvZiBpIT0iZnVuY3Rpb24iJiYoaT1vKGkscyxhKSksaS5zaG91bGRUZXN0TmV4dFNpYmxpbmdzJiYoYT1sKHMmJnMuY29udGV4dHx8YSxzLmFkYXB0ZXIpKSxBcnJheS5pc0FycmF5KGEpP2E9cy5hZGFwdGVyLnJlbW92ZVN1YnNldHMoYSk6YT1zLmFkYXB0ZXIuZ2V0Q2hpbGRyZW4oYSksdihpLGEscyl9fWZ1bmN0aW9uIHAodixNKXt2YXIgaT1NLmdldFNpYmxpbmdzKHYpO2lmKCFBcnJheS5pc0FycmF5KGkpKXJldHVybltdO2ZvcihpPWkuc2xpY2UoMCk7aS5zaGlmdCgpIT09djspO3JldHVybiBpfWZ1bmN0aW9uIGwodixNKXtBcnJheS5pc0FycmF5KHYpfHwodj1bdl0pO2Zvcih2YXIgaT12LnNsaWNlKDApLGE9MCxzPXYubGVuZ3RoO2E8czthKyspe3ZhciBmPXAoaVthXSxNKTtpLnB1c2guYXBwbHkoaSxmKX1yZXR1cm4gaX12YXIgeT1jKGZ1bmN0aW9uKE0saSxhKXtyZXR1cm4gTT09PW58fCFpfHxpLmxlbmd0aD09PTA/W106YS5hZGFwdGVyLmZpbmRBbGwoTSxpKX0pLHg9YyhmdW5jdGlvbihNLGksYSl7cmV0dXJuIE09PT1ufHwhaXx8aS5sZW5ndGg9PT0wP251bGw6YS5hZGFwdGVyLmZpbmRPbmUoTSxpKX0pO2Z1bmN0aW9uIGIodixNLGkpe3JldHVybiBpPWl8fHt9LGkuYWRhcHRlcj1pLmFkYXB0ZXJ8fHIsKHR5cGVvZiBNPT0iZnVuY3Rpb24iP006dShNLGkpKSh2KX1mdW5jdGlvbiBFKHYsTSxpKXtyZXR1cm4geSh2LE0saSl9RS5jb21waWxlPXUsRS5maWx0ZXJzPWQuUHNldWRvcy5maWx0ZXJzLEUucHNldWRvcz1kLlBzZXVkb3MucHNldWRvcyxFLnNlbGVjdEFsbD15LEUuc2VsZWN0T25lPXgsRS5pcz1iLEUucGFyc2U9dSxFLml0ZXJhdGU9eSxFLl9jb21waWxlVW5zYWZlPW8sRS5fY29tcGlsZVRva2VuPWQuY29tcGlsZVRva2VufSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9aC5leHBvcnRzO1t0KDI1NSksdCgyNjgpLHQoMjY5KSx0KDI3MCksdCgyNzEpLHQoMjcyKV0uZm9yRWFjaChmdW5jdGlvbihuKXtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKGQpe3JbZF09bltkXS5iaW5kKHIpfSl9KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjU2KSxuPXQoMjU3KSxkPXIuaXNUYWc7aC5leHBvcnRzPXtnZXRJbm5lckhUTUw6ZyxnZXRPdXRlckhUTUw6bixnZXRUZXh0OnV9O2Z1bmN0aW9uIGcobyxjKXtyZXR1cm4gby5jaGlsZHJlbj9vLmNoaWxkcmVuLm1hcChmdW5jdGlvbihwKXtyZXR1cm4gbihwLGMpfSkuam9pbigiIik6IiJ9ZnVuY3Rpb24gdShvKXtyZXR1cm4gQXJyYXkuaXNBcnJheShvKT9vLm1hcCh1KS5qb2luKCIiKTpkKG8pP28ubmFtZT09PSJiciI/YApgOnUoby5jaGlsZHJlbik6by50eXBlPT09ci5DREFUQT91KG8uY2hpbGRyZW4pOm8udHlwZT09PXIuVGV4dD9vLmRhdGE6IiJ9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz17VGV4dDoidGV4dCIsRGlyZWN0aXZlOiJkaXJlY3RpdmUiLENvbW1lbnQ6ImNvbW1lbnQiLFNjcmlwdDoic2NyaXB0IixTdHlsZToic3R5bGUiLFRhZzoidGFnIixDREFUQToiY2RhdGEiLERvY3R5cGU6ImRvY3R5cGUiLGlzVGFnOmZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGU9PT0idGFnInx8dC50eXBlPT09InNjcmlwdCJ8fHQudHlwZT09PSJzdHlsZSJ9fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjU4KSxuPXQoMjU5KSxkPXQoMjY3KTtkLmVsZW1lbnROYW1lcy5fX3Byb3RvX189bnVsbCxkLmF0dHJpYnV0ZU5hbWVzLl9fcHJvdG9fXz1udWxsO3ZhciBnPXtfX3Byb3RvX186bnVsbCxzdHlsZTohMCxzY3JpcHQ6ITAseG1wOiEwLGlmcmFtZTohMCxub2VtYmVkOiEwLG5vZnJhbWVzOiEwLHBsYWludGV4dDohMCxub3NjcmlwdDohMH07ZnVuY3Rpb24gdSh2LE0pe2lmKHYpe3ZhciBpPSIiLGE7Zm9yKHZhciBzIGluIHYpYT12W3NdLGkmJihpKz0iICIpLE0ueG1sTW9kZT09PSJmb3JlaWduIiYmKHM9ZC5hdHRyaWJ1dGVOYW1lc1tzXXx8cyksaSs9cywoYSE9PW51bGwmJmEhPT0iInx8TS54bWxNb2RlKSYmKGkrPSc9IicrKE0uZGVjb2RlRW50aXRpZXM/bi5lbmNvZGVYTUwoYSk6YS5yZXBsYWNlKC9cIi9nLCImcXVvdDsiKSkrJyInKTtyZXR1cm4gaX19dmFyIG89e19fcHJvdG9fXzpudWxsLGFyZWE6ITAsYmFzZTohMCxiYXNlZm9udDohMCxicjohMCxjb2w6ITAsY29tbWFuZDohMCxlbWJlZDohMCxmcmFtZTohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsaXNpbmRleDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9LGM9aC5leHBvcnRzPWZ1bmN0aW9uKHYsTSl7IUFycmF5LmlzQXJyYXkodikmJiF2LmNoZWVyaW8mJih2PVt2XSksTT1NfHx7fTtmb3IodmFyIGk9IiIsYT0wO2E8di5sZW5ndGg7YSsrKXt2YXIgcz12W2FdO3MudHlwZT09PSJyb290Ij9pKz1jKHMuY2hpbGRyZW4sTSk6ci5pc1RhZyhzKT9pKz1sKHMsTSk6cy50eXBlPT09ci5EaXJlY3RpdmU/aSs9eShzKTpzLnR5cGU9PT1yLkNvbW1lbnQ/aSs9RShzKTpzLnR5cGU9PT1yLkNEQVRBP2krPWIocyk6aSs9eChzLE0pfXJldHVybiBpfSxwPVsibWkiLCJtbyIsIm1uIiwibXMiLCJtdGV4dCIsImFubm90YXRpb24teG1sIiwiZm9yZWlnbk9iamVjdCIsImRlc2MiLCJ0aXRsZSJdO2Z1bmN0aW9uIGwodixNKXtNLnhtbE1vZGU9PT0iZm9yZWlnbiImJih2Lm5hbWU9ZC5lbGVtZW50TmFtZXNbdi5uYW1lXXx8di5uYW1lLHYucGFyZW50JiZwLmluZGV4T2Yodi5wYXJlbnQubmFtZSk+PTAmJihNPU9iamVjdC5hc3NpZ24oe30sTSx7eG1sTW9kZTohMX0pKSksIU0ueG1sTW9kZSYmWyJzdmciLCJtYXRoIl0uaW5kZXhPZih2Lm5hbWUpPj0wJiYoTT1PYmplY3QuYXNzaWduKHt9LE0se3htbE1vZGU6ImZvcmVpZ24ifSkpO3ZhciBpPSI8Iit2Lm5hbWUsYT11KHYuYXR0cmlicyxNKTtyZXR1cm4gYSYmKGkrPSIgIithKSxNLnhtbE1vZGUmJighdi5jaGlsZHJlbnx8di5jaGlsZHJlbi5sZW5ndGg9PT0wKT9pKz0iLz4iOihpKz0iPiIsdi5jaGlsZHJlbiYmKGkrPWModi5jaGlsZHJlbixNKSksKCFvW3YubmFtZV18fE0ueG1sTW9kZSkmJihpKz0iPC8iK3YubmFtZSsiPiIpKSxpfWZ1bmN0aW9uIHkodil7cmV0dXJuIjwiK3YuZGF0YSsiPiJ9ZnVuY3Rpb24geCh2LE0pe3ZhciBpPXYuZGF0YXx8IiI7cmV0dXJuIE0uZGVjb2RlRW50aXRpZXMmJiEodi5wYXJlbnQmJnYucGFyZW50Lm5hbWUgaW4gZykmJihpPW4uZW5jb2RlWE1MKGkpKSxpfWZ1bmN0aW9uIGIodil7cmV0dXJuIjwhW0NEQVRBWyIrdi5jaGlsZHJlblswXS5kYXRhKyJdXT4ifWZ1bmN0aW9uIEUodil7cmV0dXJuIjwhLS0iK3YuZGF0YSsiLS0+In19LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gcihuKXtyZXR1cm4gbi50eXBlPT09InRhZyJ8fG4udHlwZT09PSJzY3JpcHQifHxuLnR5cGU9PT0ic3R5bGUifWUuaXNUYWc9cixlLlRleHQ9InRleHQiLGUuRGlyZWN0aXZlPSJkaXJlY3RpdmUiLGUuQ29tbWVudD0iY29tbWVudCIsZS5TY3JpcHQ9InNjcmlwdCIsZS5TdHlsZT0ic3R5bGUiLGUuVGFnPSJ0YWciLGUuQ0RBVEE9ImNkYXRhIixlLkRvY3R5cGU9ImRvY3R5cGUifSxmdW5jdGlvbihoLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZW5jb2RlPWUuZGVjb2RlU3RyaWN0PWUuZGVjb2RlPXZvaWQgMDt2YXIgcj10KDI2MCksbj10KDI2Nik7ZnVuY3Rpb24gZChwLGwpe3JldHVybighbHx8bDw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUwpKHApfWUuZGVjb2RlPWQ7ZnVuY3Rpb24gZyhwLGwpe3JldHVybighbHx8bDw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUxTdHJpY3QpKHApfWUuZGVjb2RlU3RyaWN0PWc7ZnVuY3Rpb24gdShwLGwpe3JldHVybighbHx8bDw9MD9uLmVuY29kZVhNTDpuLmVuY29kZUhUTUwpKHApfWUuZW5jb2RlPXU7dmFyIG89dCgyNjYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLmVuY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZXNjYXBlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5lc2NhcGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5jb2RlSFRNTH19KTt2YXIgYz10KDI2MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVjb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNVN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVYTUx9fSl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24obCl7cmV0dXJuIGwmJmwuX19lc01vZHVsZT9sOntkZWZhdWx0Omx9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWNvZGVIVE1MPWUuZGVjb2RlSFRNTFN0cmljdD1lLmRlY29kZVhNTD12b2lkIDA7dmFyIG49cih0KDI2MSkpLGQ9cih0KDI2MikpLGc9cih0KDI2MykpLHU9cih0KDI2NCkpO2UuZGVjb2RlWE1MPW8oZy5kZWZhdWx0KSxlLmRlY29kZUhUTUxTdHJpY3Q9byhuLmRlZmF1bHQpO2Z1bmN0aW9uIG8obCl7dmFyIHk9T2JqZWN0LmtleXMobCkuam9pbigifCIpLHg9cChsKTt5Kz0ifCNbeFhdW1xcZGEtZkEtRl0rfCNcXGQrIjt2YXIgYj1uZXcgUmVnRXhwKCImKD86Iit5KyIpOyIsImciKTtyZXR1cm4gZnVuY3Rpb24oRSl7cmV0dXJuIFN0cmluZyhFKS5yZXBsYWNlKGIseCl9fXZhciBjPWZ1bmN0aW9uKGwseSl7cmV0dXJuIGw8eT8xOi0xfTtlLmRlY29kZUhUTUw9ZnVuY3Rpb24oKXtmb3IodmFyIGw9T2JqZWN0LmtleXMoZC5kZWZhdWx0KS5zb3J0KGMpLHk9T2JqZWN0LmtleXMobi5kZWZhdWx0KS5zb3J0KGMpLHg9MCxiPTA7eDx5Lmxlbmd0aDt4KyspbFtiXT09PXlbeF0/KHlbeF0rPSI7PyIsYisrKTp5W3hdKz0iOyI7dmFyIEU9bmV3IFJlZ0V4cCgiJig/OiIreS5qb2luKCJ8IikrInwjW3hYXVtcXGRhLWZBLUZdKzs/fCNcXGQrOz8pIiwiZyIpLHY9cChuLmRlZmF1bHQpO2Z1bmN0aW9uIE0oaSl7cmV0dXJuIGkuc3Vic3RyKC0xKSE9PSI7IiYmKGkrPSI7IiksdihpKX1yZXR1cm4gZnVuY3Rpb24oaSl7cmV0dXJuIFN0cmluZyhpKS5yZXBsYWNlKEUsTSl9fSgpO2Z1bmN0aW9uIHAobCl7cmV0dXJuIGZ1bmN0aW9uKHgpe2lmKHguY2hhckF0KDEpPT09IiMiKXt2YXIgYj14LmNoYXJBdCgyKTtyZXR1cm4gYj09PSJYInx8Yj09PSJ4Ij91LmRlZmF1bHQocGFyc2VJbnQoeC5zdWJzdHIoMyksMTYpKTp1LmRlZmF1bHQocGFyc2VJbnQoeC5zdWJzdHIoMiksMTApKX1yZXR1cm4gbFt4LnNsaWNlKDEsLTEpXX19fSxmdW5jdGlvbihoKXtoLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWJyZXZlIjoixIIiLCJhYnJldmUiOiLEgyIsImFjIjoi4oi+IiwiYWNkIjoi4oi/IiwiYWNFIjoi4oi+zLMiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBY3kiOiLQkCIsImFjeSI6ItCwIiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJhZiI6IuKBoSIsIkFmciI6IvCdlIQiLCJhZnIiOiLwnZSeIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFsZWZzeW0iOiLihLUiLCJhbGVwaCI6IuKEtSIsIkFscGhhIjoizpEiLCJhbHBoYSI6Is6xIiwiQW1hY3IiOiLEgCIsImFtYWNyIjoixIEiLCJhbWFsZyI6IuKovyIsImFtcCI6IiYiLCJBTVAiOiImIiwiYW5kYW5kIjoi4qmVIiwiQW5kIjoi4qmTIiwiYW5kIjoi4oinIiwiYW5kZCI6IuKpnCIsImFuZHNsb3BlIjoi4qmYIiwiYW5kdiI6IuKpmiIsImFuZyI6IuKIoCIsImFuZ2UiOiLipqQiLCJhbmdsZSI6IuKIoCIsImFuZ21zZGFhIjoi4qaoIiwiYW5nbXNkYWIiOiLipqkiLCJhbmdtc2RhYyI6IuKmqiIsImFuZ21zZGFkIjoi4qarIiwiYW5nbXNkYWUiOiLipqwiLCJhbmdtc2RhZiI6IuKmrSIsImFuZ21zZGFnIjoi4qauIiwiYW5nbXNkYWgiOiLipq8iLCJhbmdtc2QiOiLiiKEiLCJhbmdydCI6IuKInyIsImFuZ3J0dmIiOiLiir4iLCJhbmdydHZiZCI6IuKmnSIsImFuZ3NwaCI6IuKIoiIsImFuZ3N0Ijoiw4UiLCJhbmd6YXJyIjoi4o28IiwiQW9nb24iOiLEhCIsImFvZ29uIjoixIUiLCJBb3BmIjoi8J2UuCIsImFvcGYiOiLwnZWSIiwiYXBhY2lyIjoi4qmvIiwiYXAiOiLiiYgiLCJhcEUiOiLiqbAiLCJhcGUiOiLiiYoiLCJhcGlkIjoi4omLIiwiYXBvcyI6IlwnIiwiQXBwbHlGdW5jdGlvbiI6IuKBoSIsImFwcHJveCI6IuKJiCIsImFwcHJveGVxIjoi4omKIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBc2NyIjoi8J2SnCIsImFzY3IiOiLwnZK2IiwiQXNzaWduIjoi4omUIiwiYXN0IjoiKiIsImFzeW1wIjoi4omIIiwiYXN5bXBlcSI6IuKJjSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJhd2NvbmludCI6IuKIsyIsImF3aW50Ijoi4qiRIiwiYmFja2NvbmciOiLiiYwiLCJiYWNrZXBzaWxvbiI6Is+2IiwiYmFja3ByaW1lIjoi4oC1IiwiYmFja3NpbSI6IuKIvSIsImJhY2tzaW1lcSI6IuKLjSIsIkJhY2tzbGFzaCI6IuKIliIsIkJhcnYiOiLiq6ciLCJiYXJ2ZWUiOiLiir0iLCJiYXJ3ZWQiOiLijIUiLCJCYXJ3ZWQiOiLijIYiLCJiYXJ3ZWRnZSI6IuKMhSIsImJicmsiOiLijrUiLCJiYnJrdGJyayI6IuKOtiIsImJjb25nIjoi4omMIiwiQmN5Ijoi0JEiLCJiY3kiOiLQsSIsImJkcXVvIjoi4oCeIiwiYmVjYXVzIjoi4oi1IiwiYmVjYXVzZSI6IuKItSIsIkJlY2F1c2UiOiLiiLUiLCJiZW1wdHl2Ijoi4qawIiwiYmVwc2kiOiLPtiIsImJlcm5vdSI6IuKErCIsIkJlcm5vdWxsaXMiOiLihKwiLCJCZXRhIjoizpIiLCJiZXRhIjoizrIiLCJiZXRoIjoi4oS2IiwiYmV0d2VlbiI6IuKJrCIsIkJmciI6IvCdlIUiLCJiZnIiOiLwnZSfIiwiYmlnY2FwIjoi4ouCIiwiYmlnY2lyYyI6IuKXryIsImJpZ2N1cCI6IuKLgyIsImJpZ29kb3QiOiLiqIAiLCJiaWdvcGx1cyI6IuKogSIsImJpZ290aW1lcyI6IuKogiIsImJpZ3NxY3VwIjoi4qiGIiwiYmlnc3RhciI6IuKYhSIsImJpZ3RyaWFuZ2xlZG93biI6IuKWvSIsImJpZ3RyaWFuZ2xldXAiOiLilrMiLCJiaWd1cGx1cyI6IuKohCIsImJpZ3ZlZSI6IuKLgSIsImJpZ3dlZGdlIjoi4ouAIiwiYmthcm93Ijoi4qSNIiwiYmxhY2tsb3plbmdlIjoi4qerIiwiYmxhY2tzcXVhcmUiOiLilqoiLCJibGFja3RyaWFuZ2xlIjoi4pa0IiwiYmxhY2t0cmlhbmdsZWRvd24iOiLilr4iLCJibGFja3RyaWFuZ2xlbGVmdCI6IuKXgiIsImJsYWNrdHJpYW5nbGVyaWdodCI6IuKWuCIsImJsYW5rIjoi4pCjIiwiYmxrMTIiOiLilpIiLCJibGsxNCI6IuKWkSIsImJsazM0Ijoi4paTIiwiYmxvY2siOiLilogiLCJibmUiOiI94oOlIiwiYm5lcXVpdiI6IuKJoeKDpSIsImJOb3QiOiLiq60iLCJibm90Ijoi4oyQIiwiQm9wZiI6IvCdlLkiLCJib3BmIjoi8J2VkyIsImJvdCI6IuKKpSIsImJvdHRvbSI6IuKKpSIsImJvd3RpZSI6IuKLiCIsImJveGJveCI6IuKniSIsImJveGRsIjoi4pSQIiwiYm94ZEwiOiLilZUiLCJib3hEbCI6IuKVliIsImJveERMIjoi4pWXIiwiYm94ZHIiOiLilIwiLCJib3hkUiI6IuKVkiIsImJveERyIjoi4pWTIiwiYm94RFIiOiLilZQiLCJib3hoIjoi4pSAIiwiYm94SCI6IuKVkCIsImJveGhkIjoi4pSsIiwiYm94SGQiOiLilaQiLCJib3hoRCI6IuKVpSIsImJveEhEIjoi4pWmIiwiYm94aHUiOiLilLQiLCJib3hIdSI6IuKVpyIsImJveGhVIjoi4pWoIiwiYm94SFUiOiLilakiLCJib3htaW51cyI6IuKKnyIsImJveHBsdXMiOiLiip4iLCJib3h0aW1lcyI6IuKKoCIsImJveHVsIjoi4pSYIiwiYm94dUwiOiLilZsiLCJib3hVbCI6IuKVnCIsImJveFVMIjoi4pWdIiwiYm94dXIiOiLilJQiLCJib3h1UiI6IuKVmCIsImJveFVyIjoi4pWZIiwiYm94VVIiOiLilZoiLCJib3h2Ijoi4pSCIiwiYm94ViI6IuKVkSIsImJveHZoIjoi4pS8IiwiYm94dkgiOiLilaoiLCJib3hWaCI6IuKVqyIsImJveFZIIjoi4pWsIiwiYm94dmwiOiLilKQiLCJib3h2TCI6IuKVoSIsImJveFZsIjoi4pWiIiwiYm94VkwiOiLilaMiLCJib3h2ciI6IuKUnCIsImJveHZSIjoi4pWeIiwiYm94VnIiOiLilZ8iLCJib3hWUiI6IuKVoCIsImJwcmltZSI6IuKAtSIsImJyZXZlIjoiy5giLCJCcmV2ZSI6IsuYIiwiYnJ2YmFyIjoiwqYiLCJic2NyIjoi8J2StyIsIkJzY3IiOiLihKwiLCJic2VtaSI6IuKBjyIsImJzaW0iOiLiiL0iLCJic2ltZSI6IuKLjSIsImJzb2xiIjoi4qeFIiwiYnNvbCI6IlxcXFwiLCJic29saHN1YiI6IuKfiCIsImJ1bGwiOiLigKIiLCJidWxsZXQiOiLigKIiLCJidW1wIjoi4omOIiwiYnVtcEUiOiLiqq4iLCJidW1wZSI6IuKJjyIsIkJ1bXBlcSI6IuKJjiIsImJ1bXBlcSI6IuKJjyIsIkNhY3V0ZSI6IsSGIiwiY2FjdXRlIjoixIciLCJjYXBhbmQiOiLiqYQiLCJjYXBicmN1cCI6IuKpiSIsImNhcGNhcCI6IuKpiyIsImNhcCI6IuKIqSIsIkNhcCI6IuKLkiIsImNhcGN1cCI6IuKphyIsImNhcGRvdCI6IuKpgCIsIkNhcGl0YWxEaWZmZXJlbnRpYWxEIjoi4oWFIiwiY2FwcyI6IuKIqe+4gCIsImNhcmV0Ijoi4oGBIiwiY2Fyb24iOiLLhyIsIkNheWxleXMiOiLihK0iLCJjY2FwcyI6IuKpjSIsIkNjYXJvbiI6IsSMIiwiY2Nhcm9uIjoixI0iLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiQ2NpcmMiOiLEiCIsImNjaXJjIjoixIkiLCJDY29uaW50Ijoi4oiwIiwiY2N1cHMiOiLiqYwiLCJjY3Vwc3NtIjoi4qmQIiwiQ2RvdCI6IsSKIiwiY2RvdCI6IsSLIiwiY2VkaWwiOiLCuCIsIkNlZGlsbGEiOiLCuCIsImNlbXB0eXYiOiLiprIiLCJjZW50IjoiwqIiLCJjZW50ZXJkb3QiOiLCtyIsIkNlbnRlckRvdCI6IsK3IiwiY2ZyIjoi8J2UoCIsIkNmciI6IuKErSIsIkNIY3kiOiLQpyIsImNoY3kiOiLRhyIsImNoZWNrIjoi4pyTIiwiY2hlY2ttYXJrIjoi4pyTIiwiQ2hpIjoizqciLCJjaGkiOiLPhyIsImNpcmMiOiLLhiIsImNpcmNlcSI6IuKJlyIsImNpcmNsZWFycm93bGVmdCI6IuKGuiIsImNpcmNsZWFycm93cmlnaHQiOiLihrsiLCJjaXJjbGVkYXN0Ijoi4oqbIiwiY2lyY2xlZGNpcmMiOiLiipoiLCJjaXJjbGVkZGFzaCI6IuKKnSIsIkNpcmNsZURvdCI6IuKKmSIsImNpcmNsZWRSIjoiwq4iLCJjaXJjbGVkUyI6IuKTiCIsIkNpcmNsZU1pbnVzIjoi4oqWIiwiQ2lyY2xlUGx1cyI6IuKKlSIsIkNpcmNsZVRpbWVzIjoi4oqXIiwiY2lyIjoi4peLIiwiY2lyRSI6IuKngyIsImNpcmUiOiLiiZciLCJjaXJmbmludCI6IuKokCIsImNpcm1pZCI6IuKrryIsImNpcnNjaXIiOiLip4IiLCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLIiLCJDbG9zZUN1cmx5RG91YmxlUXVvdGUiOiLigJ0iLCJDbG9zZUN1cmx5UXVvdGUiOiLigJkiLCJjbHVicyI6IuKZoyIsImNsdWJzdWl0Ijoi4pmjIiwiY29sb24iOiI6IiwiQ29sb24iOiLiiLciLCJDb2xvbmUiOiLiqbQiLCJjb2xvbmUiOiLiiZQiLCJjb2xvbmVxIjoi4omUIiwiY29tbWEiOiIsIiwiY29tbWF0IjoiQCIsImNvbXAiOiLiiIEiLCJjb21wZm4iOiLiiJgiLCJjb21wbGVtZW50Ijoi4oiBIiwiY29tcGxleGVzIjoi4oSCIiwiY29uZyI6IuKJhSIsImNvbmdkb3QiOiLiqa0iLCJDb25ncnVlbnQiOiLiiaEiLCJjb25pbnQiOiLiiK4iLCJDb25pbnQiOiLiiK8iLCJDb250b3VySW50ZWdyYWwiOiLiiK4iLCJjb3BmIjoi8J2VlCIsIkNvcGYiOiLihIIiLCJjb3Byb2QiOiLiiJAiLCJDb3Byb2R1Y3QiOiLiiJAiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjb3B5c3IiOiLihJciLCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oizIiwiY3JhcnIiOiLihrUiLCJjcm9zcyI6IuKclyIsIkNyb3NzIjoi4qivIiwiQ3NjciI6IvCdkp4iLCJjc2NyIjoi8J2SuCIsImNzdWIiOiLiq48iLCJjc3ViZSI6IuKrkSIsImNzdXAiOiLiq5AiLCJjc3VwZSI6IuKrkiIsImN0ZG90Ijoi4ouvIiwiY3VkYXJybCI6IuKkuCIsImN1ZGFycnIiOiLipLUiLCJjdWVwciI6IuKLniIsImN1ZXNjIjoi4oufIiwiY3VsYXJyIjoi4oa2IiwiY3VsYXJycCI6IuKkvSIsImN1cGJyY2FwIjoi4qmIIiwiY3VwY2FwIjoi4qmGIiwiQ3VwQ2FwIjoi4omNIiwiY3VwIjoi4oiqIiwiQ3VwIjoi4ouTIiwiY3VwY3VwIjoi4qmKIiwiY3VwZG90Ijoi4oqNIiwiY3Vwb3IiOiLiqYUiLCJjdXBzIjoi4oiq77iAIiwiY3VyYXJyIjoi4oa3IiwiY3VyYXJybSI6IuKkvCIsImN1cmx5ZXFwcmVjIjoi4oueIiwiY3VybHllcXN1Y2MiOiLii58iLCJjdXJseXZlZSI6IuKLjiIsImN1cmx5d2VkZ2UiOiLii48iLCJjdXJyZW4iOiLCpCIsImN1cnZlYXJyb3dsZWZ0Ijoi4oa2IiwiY3VydmVhcnJvd3JpZ2h0Ijoi4oa3IiwiY3V2ZWUiOiLii44iLCJjdXdlZCI6IuKLjyIsImN3Y29uaW50Ijoi4oiyIiwiY3dpbnQiOiLiiLEiLCJjeWxjdHkiOiLijK0iLCJkYWdnZXIiOiLigKAiLCJEYWdnZXIiOiLigKEiLCJkYWxldGgiOiLihLgiLCJkYXJyIjoi4oaTIiwiRGFyciI6IuKGoSIsImRBcnIiOiLih5MiLCJkYXNoIjoi4oCQIiwiRGFzaHYiOiLiq6QiLCJkYXNodiI6IuKKoyIsImRia2Fyb3ciOiLipI8iLCJkYmxhYyI6IsudIiwiRGNhcm9uIjoixI4iLCJkY2Fyb24iOiLEjyIsIkRjeSI6ItCUIiwiZGN5Ijoi0LQiLCJkZGFnZ2VyIjoi4oChIiwiZGRhcnIiOiLih4oiLCJERCI6IuKFhSIsImRkIjoi4oWGIiwiRERvdHJhaGQiOiLipJEiLCJkZG90c2VxIjoi4qm3IiwiZGVnIjoiwrAiLCJEZWwiOiLiiIciLCJEZWx0YSI6Is6UIiwiZGVsdGEiOiLOtCIsImRlbXB0eXYiOiLiprEiLCJkZmlzaHQiOiLipb8iLCJEZnIiOiLwnZSHIiwiZGZyIjoi8J2UoSIsImRIYXIiOiLipaUiLCJkaGFybCI6IuKHgyIsImRoYXJyIjoi4oeCIiwiRGlhY3JpdGljYWxBY3V0ZSI6IsK0IiwiRGlhY3JpdGljYWxEb3QiOiLLmSIsIkRpYWNyaXRpY2FsRG91YmxlQWN1dGUiOiLLnSIsIkRpYWNyaXRpY2FsR3JhdmUiOiJgIiwiRGlhY3JpdGljYWxUaWxkZSI6IsucIiwiZGlhbSI6IuKLhCIsImRpYW1vbmQiOiLii4QiLCJEaWFtb25kIjoi4ouEIiwiZGlhbW9uZHN1aXQiOiLimaYiLCJkaWFtcyI6IuKZpiIsImRpZSI6IsKoIiwiRGlmZmVyZW50aWFsRCI6IuKFhiIsImRpZ2FtbWEiOiLPnSIsImRpc2luIjoi4ouyIiwiZGl2Ijoiw7ciLCJkaXZpZGUiOiLDtyIsImRpdmlkZW9udGltZXMiOiLii4ciLCJkaXZvbngiOiLii4ciLCJESmN5Ijoi0IIiLCJkamN5Ijoi0ZIiLCJkbGNvcm4iOiLijJ4iLCJkbGNyb3AiOiLijI0iLCJkb2xsYXIiOiIkIiwiRG9wZiI6IvCdlLsiLCJkb3BmIjoi8J2VlSIsIkRvdCI6IsKoIiwiZG90Ijoiy5kiLCJEb3REb3QiOiLig5wiLCJkb3RlcSI6IuKJkCIsImRvdGVxZG90Ijoi4omRIiwiRG90RXF1YWwiOiLiiZAiLCJkb3RtaW51cyI6IuKIuCIsImRvdHBsdXMiOiLiiJQiLCJkb3RzcXVhcmUiOiLiiqEiLCJkb3VibGViYXJ3ZWRnZSI6IuKMhiIsIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbCI6IuKIryIsIkRvdWJsZURvdCI6IsKoIiwiRG91YmxlRG93bkFycm93Ijoi4oeTIiwiRG91YmxlTGVmdEFycm93Ijoi4oeQIiwiRG91YmxlTGVmdFJpZ2h0QXJyb3ciOiLih5QiLCJEb3VibGVMZWZ0VGVlIjoi4qukIiwiRG91YmxlTG9uZ0xlZnRBcnJvdyI6IuKfuCIsIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKfuiIsIkRvdWJsZUxvbmdSaWdodEFycm93Ijoi4p+5IiwiRG91YmxlUmlnaHRBcnJvdyI6IuKHkiIsIkRvdWJsZVJpZ2h0VGVlIjoi4oqoIiwiRG91YmxlVXBBcnJvdyI6IuKHkSIsIkRvdWJsZVVwRG93bkFycm93Ijoi4oeVIiwiRG91YmxlVmVydGljYWxCYXIiOiLiiKUiLCJEb3duQXJyb3dCYXIiOiLipJMiLCJkb3duYXJyb3ciOiLihpMiLCJEb3duQXJyb3ciOiLihpMiLCJEb3duYXJyb3ciOiLih5MiLCJEb3duQXJyb3dVcEFycm93Ijoi4oe1IiwiRG93bkJyZXZlIjoizJEiLCJkb3duZG93bmFycm93cyI6IuKHiiIsImRvd25oYXJwb29ubGVmdCI6IuKHgyIsImRvd25oYXJwb29ucmlnaHQiOiLih4IiLCJEb3duTGVmdFJpZ2h0VmVjdG9yIjoi4qWQIiwiRG93bkxlZnRUZWVWZWN0b3IiOiLipZ4iLCJEb3duTGVmdFZlY3RvckJhciI6IuKlliIsIkRvd25MZWZ0VmVjdG9yIjoi4oa9IiwiRG93blJpZ2h0VGVlVmVjdG9yIjoi4qWfIiwiRG93blJpZ2h0VmVjdG9yQmFyIjoi4qWXIiwiRG93blJpZ2h0VmVjdG9yIjoi4oeBIiwiRG93blRlZUFycm93Ijoi4oanIiwiRG93blRlZSI6IuKKpCIsImRyYmthcm93Ijoi4qSQIiwiZHJjb3JuIjoi4oyfIiwiZHJjcm9wIjoi4oyMIiwiRHNjciI6IvCdkp8iLCJkc2NyIjoi8J2SuSIsIkRTY3kiOiLQhSIsImRzY3kiOiLRlSIsImRzb2wiOiLip7YiLCJEc3Ryb2siOiLEkCIsImRzdHJvayI6IsSRIiwiZHRkb3QiOiLii7EiLCJkdHJpIjoi4pa/IiwiZHRyaWYiOiLilr4iLCJkdWFyciI6IuKHtSIsImR1aGFyIjoi4qWvIiwiZHdhbmdsZSI6IuKmpiIsIkRaY3kiOiLQjyIsImR6Y3kiOiLRnyIsImR6aWdyYXJyIjoi4p+/IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsImVhc3RlciI6IuKpriIsIkVjYXJvbiI6IsSaIiwiZWNhcm9uIjoixJsiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsImVjaXIiOiLiiZYiLCJlY29sb24iOiLiiZUiLCJFY3kiOiLQrSIsImVjeSI6ItGNIiwiZUREb3QiOiLiqbciLCJFZG90IjoixJYiLCJlZG90IjoixJciLCJlRG90Ijoi4omRIiwiZWUiOiLihYciLCJlZkRvdCI6IuKJkiIsIkVmciI6IvCdlIgiLCJlZnIiOiLwnZSiIiwiZWciOiLiqpoiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiZWdzIjoi4qqWIiwiZWdzZG90Ijoi4qqYIiwiZWwiOiLiqpkiLCJFbGVtZW50Ijoi4oiIIiwiZWxpbnRlcnMiOiLij6ciLCJlbGwiOiLihJMiLCJlbHMiOiLiqpUiLCJlbHNkb3QiOiLiqpciLCJFbWFjciI6IsSSIiwiZW1hY3IiOiLEkyIsImVtcHR5Ijoi4oiFIiwiZW1wdHlzZXQiOiLiiIUiLCJFbXB0eVNtYWxsU3F1YXJlIjoi4pe7IiwiZW1wdHl2Ijoi4oiFIiwiRW1wdHlWZXJ5U21hbGxTcXVhcmUiOiLilqsiLCJlbXNwMTMiOiLigIQiLCJlbXNwMTQiOiLigIUiLCJlbXNwIjoi4oCDIiwiRU5HIjoixYoiLCJlbmciOiLFiyIsImVuc3AiOiLigIIiLCJFb2dvbiI6IsSYIiwiZW9nb24iOiLEmSIsIkVvcGYiOiLwnZS8IiwiZW9wZiI6IvCdlZYiLCJlcGFyIjoi4ouVIiwiZXBhcnNsIjoi4qejIiwiZXBsdXMiOiLiqbEiLCJlcHNpIjoizrUiLCJFcHNpbG9uIjoizpUiLCJlcHNpbG9uIjoizrUiLCJlcHNpdiI6Is+1IiwiZXFjaXJjIjoi4omWIiwiZXFjb2xvbiI6IuKJlSIsImVxc2ltIjoi4omCIiwiZXFzbGFudGd0ciI6IuKqliIsImVxc2xhbnRsZXNzIjoi4qqVIiwiRXF1YWwiOiLiqbUiLCJlcXVhbHMiOiI9IiwiRXF1YWxUaWxkZSI6IuKJgiIsImVxdWVzdCI6IuKJnyIsIkVxdWlsaWJyaXVtIjoi4oeMIiwiZXF1aXYiOiLiiaEiLCJlcXVpdkREIjoi4qm4IiwiZXF2cGFyc2wiOiLip6UiLCJlcmFyciI6IuKlsSIsImVyRG90Ijoi4omTIiwiZXNjciI6IuKEryIsIkVzY3IiOiLihLAiLCJlc2RvdCI6IuKJkCIsIkVzaW0iOiLiqbMiLCJlc2ltIjoi4omCIiwiRXRhIjoizpciLCJldGEiOiLOtyIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJldXJvIjoi4oKsIiwiZXhjbCI6IiEiLCJleGlzdCI6IuKIgyIsIkV4aXN0cyI6IuKIgyIsImV4cGVjdGF0aW9uIjoi4oSwIiwiZXhwb25lbnRpYWxlIjoi4oWHIiwiRXhwb25lbnRpYWxFIjoi4oWHIiwiZmFsbGluZ2RvdHNlcSI6IuKJkiIsIkZjeSI6ItCkIiwiZmN5Ijoi0YQiLCJmZW1hbGUiOiLimYAiLCJmZmlsaWciOiLvrIMiLCJmZmxpZyI6Iu+sgCIsImZmbGxpZyI6Iu+shCIsIkZmciI6IvCdlIkiLCJmZnIiOiLwnZSjIiwiZmlsaWciOiLvrIEiLCJGaWxsZWRTbWFsbFNxdWFyZSI6IuKXvCIsIkZpbGxlZFZlcnlTbWFsbFNxdWFyZSI6IuKWqiIsImZqbGlnIjoiZmoiLCJmbGF0Ijoi4pmtIiwiZmxsaWciOiLvrIIiLCJmbHRucyI6IuKWsSIsImZub2YiOiLGkiIsIkZvcGYiOiLwnZS9IiwiZm9wZiI6IvCdlZciLCJmb3JhbGwiOiLiiIAiLCJGb3JBbGwiOiLiiIAiLCJmb3JrIjoi4ouUIiwiZm9ya3YiOiLiq5kiLCJGb3VyaWVydHJmIjoi4oSxIiwiZnBhcnRpbnQiOiLiqI0iLCJmcmFjMTIiOiLCvSIsImZyYWMxMyI6IuKFkyIsImZyYWMxNCI6IsK8IiwiZnJhYzE1Ijoi4oWVIiwiZnJhYzE2Ijoi4oWZIiwiZnJhYzE4Ijoi4oWbIiwiZnJhYzIzIjoi4oWUIiwiZnJhYzI1Ijoi4oWWIiwiZnJhYzM0Ijoiwr4iLCJmcmFjMzUiOiLihZciLCJmcmFjMzgiOiLihZwiLCJmcmFjNDUiOiLihZgiLCJmcmFjNTYiOiLihZoiLCJmcmFjNTgiOiLihZ0iLCJmcmFjNzgiOiLihZ4iLCJmcmFzbCI6IuKBhCIsImZyb3duIjoi4oyiIiwiZnNjciI6IvCdkrsiLCJGc2NyIjoi4oSxIiwiZ2FjdXRlIjoix7UiLCJHYW1tYSI6Is6TIiwiZ2FtbWEiOiLOsyIsIkdhbW1hZCI6Is+cIiwiZ2FtbWFkIjoiz50iLCJnYXAiOiLiqoYiLCJHYnJldmUiOiLEniIsImdicmV2ZSI6IsSfIiwiR2NlZGlsIjoixKIiLCJHY2lyYyI6IsScIiwiZ2NpcmMiOiLEnSIsIkdjeSI6ItCTIiwiZ2N5Ijoi0LMiLCJHZG90IjoixKAiLCJnZG90IjoixKEiLCJnZSI6IuKJpSIsImdFIjoi4omnIiwiZ0VsIjoi4qqMIiwiZ2VsIjoi4oubIiwiZ2VxIjoi4omlIiwiZ2VxcSI6IuKJpyIsImdlcXNsYW50Ijoi4qm+IiwiZ2VzY2MiOiLiqqkiLCJnZXMiOiLiqb4iLCJnZXNkb3QiOiLiqoAiLCJnZXNkb3RvIjoi4qqCIiwiZ2VzZG90b2wiOiLiqoQiLCJnZXNsIjoi4oub77iAIiwiZ2VzbGVzIjoi4qqUIiwiR2ZyIjoi8J2UiiIsImdmciI6IvCdlKQiLCJnZyI6IuKJqyIsIkdnIjoi4ouZIiwiZ2dnIjoi4ouZIiwiZ2ltZWwiOiLihLciLCJHSmN5Ijoi0IMiLCJnamN5Ijoi0ZMiLCJnbGEiOiLiqqUiLCJnbCI6IuKJtyIsImdsRSI6IuKqkiIsImdsaiI6IuKqpCIsImduYXAiOiLiqooiLCJnbmFwcHJveCI6IuKqiiIsImduZSI6IuKqiCIsImduRSI6IuKJqSIsImduZXEiOiLiqogiLCJnbmVxcSI6IuKJqSIsImduc2ltIjoi4ounIiwiR29wZiI6IvCdlL4iLCJnb3BmIjoi8J2VmCIsImdyYXZlIjoiYCIsIkdyZWF0ZXJFcXVhbCI6IuKJpSIsIkdyZWF0ZXJFcXVhbExlc3MiOiLii5siLCJHcmVhdGVyRnVsbEVxdWFsIjoi4omnIiwiR3JlYXRlckdyZWF0ZXIiOiLiqqIiLCJHcmVhdGVyTGVzcyI6IuKJtyIsIkdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+IiwiR3JlYXRlclRpbGRlIjoi4omzIiwiR3NjciI6IvCdkqIiLCJnc2NyIjoi4oSKIiwiZ3NpbSI6IuKJsyIsImdzaW1lIjoi4qqOIiwiZ3NpbWwiOiLiqpAiLCJndGNjIjoi4qqnIiwiZ3RjaXIiOiLiqboiLCJndCI6Ij4iLCJHVCI6Ij4iLCJHdCI6IuKJqyIsImd0ZG90Ijoi4ouXIiwiZ3RsUGFyIjoi4qaVIiwiZ3RxdWVzdCI6IuKpvCIsImd0cmFwcHJveCI6IuKqhiIsImd0cmFyciI6IuKluCIsImd0cmRvdCI6IuKLlyIsImd0cmVxbGVzcyI6IuKLmyIsImd0cmVxcWxlc3MiOiLiqowiLCJndHJsZXNzIjoi4om3IiwiZ3Ryc2ltIjoi4omzIiwiZ3ZlcnRuZXFxIjoi4omp77iAIiwiZ3ZuRSI6IuKJqe+4gCIsIkhhY2VrIjoiy4ciLCJoYWlyc3AiOiLigIoiLCJoYWxmIjoiwr0iLCJoYW1pbHQiOiLihIsiLCJIQVJEY3kiOiLQqiIsImhhcmRjeSI6ItGKIiwiaGFycmNpciI6IuKliCIsImhhcnIiOiLihpQiLCJoQXJyIjoi4oeUIiwiaGFycnciOiLihq0iLCJIYXQiOiJeIiwiaGJhciI6IuKEjyIsIkhjaXJjIjoixKQiLCJoY2lyYyI6IsSlIiwiaGVhcnRzIjoi4pmlIiwiaGVhcnRzdWl0Ijoi4pmlIiwiaGVsbGlwIjoi4oCmIiwiaGVyY29uIjoi4oq5IiwiaGZyIjoi8J2UpSIsIkhmciI6IuKEjCIsIkhpbGJlcnRTcGFjZSI6IuKEiyIsImhrc2Vhcm93Ijoi4qSlIiwiaGtzd2Fyb3ciOiLipKYiLCJob2FyciI6IuKHvyIsImhvbXRodCI6IuKIuyIsImhvb2tsZWZ0YXJyb3ciOiLihqkiLCJob29rcmlnaHRhcnJvdyI6IuKGqiIsImhvcGYiOiLwnZWZIiwiSG9wZiI6IuKEjSIsImhvcmJhciI6IuKAlSIsIkhvcml6b250YWxMaW5lIjoi4pSAIiwiaHNjciI6IvCdkr0iLCJIc2NyIjoi4oSLIiwiaHNsYXNoIjoi4oSPIiwiSHN0cm9rIjoixKYiLCJoc3Ryb2siOiLEpyIsIkh1bXBEb3duSHVtcCI6IuKJjiIsIkh1bXBFcXVhbCI6IuKJjyIsImh5YnVsbCI6IuKBgyIsImh5cGhlbiI6IuKAkCIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJpYyI6IuKBoyIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiSWN5Ijoi0JgiLCJpY3kiOiLQuCIsIklkb3QiOiLEsCIsIklFY3kiOiLQlSIsImllY3kiOiLQtSIsImlleGNsIjoiwqEiLCJpZmYiOiLih5QiLCJpZnIiOiLwnZSmIiwiSWZyIjoi4oSRIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlpIjoi4oWIIiwiaWlpaW50Ijoi4qiMIiwiaWlpbnQiOiLiiK0iLCJpaW5maW4iOiLip5wiLCJpaW90YSI6IuKEqSIsIklKbGlnIjoixLIiLCJpamxpZyI6IsSzIiwiSW1hY3IiOiLEqiIsImltYWNyIjoixKsiLCJpbWFnZSI6IuKEkSIsIkltYWdpbmFyeUkiOiLihYgiLCJpbWFnbGluZSI6IuKEkCIsImltYWdwYXJ0Ijoi4oSRIiwiaW1hdGgiOiLEsSIsIkltIjoi4oSRIiwiaW1vZiI6IuKKtyIsImltcGVkIjoixrUiLCJJbXBsaWVzIjoi4oeSIiwiaW5jYXJlIjoi4oSFIiwiaW4iOiLiiIgiLCJpbmZpbiI6IuKIniIsImluZmludGllIjoi4qedIiwiaW5vZG90IjoixLEiLCJpbnRjYWwiOiLiiroiLCJpbnQiOiLiiKsiLCJJbnQiOiLiiKwiLCJpbnRlZ2VycyI6IuKEpCIsIkludGVncmFsIjoi4oirIiwiaW50ZXJjYWwiOiLiiroiLCJJbnRlcnNlY3Rpb24iOiLii4IiLCJpbnRsYXJoayI6IuKolyIsImludHByb2QiOiLiqLwiLCJJbnZpc2libGVDb21tYSI6IuKBoyIsIkludmlzaWJsZVRpbWVzIjoi4oGiIiwiSU9jeSI6ItCBIiwiaW9jeSI6ItGRIiwiSW9nb24iOiLEriIsImlvZ29uIjoixK8iLCJJb3BmIjoi8J2VgCIsImlvcGYiOiLwnZWaIiwiSW90YSI6Is6ZIiwiaW90YSI6Is65IiwiaXByb2QiOiLiqLwiLCJpcXVlc3QiOiLCvyIsImlzY3IiOiLwnZK+IiwiSXNjciI6IuKEkCIsImlzaW4iOiLiiIgiLCJpc2luZG90Ijoi4ou1IiwiaXNpbkUiOiLii7kiLCJpc2lucyI6IuKLtCIsImlzaW5zdiI6IuKLsyIsImlzaW52Ijoi4oiIIiwiaXQiOiLigaIiLCJJdGlsZGUiOiLEqCIsIml0aWxkZSI6IsSpIiwiSXVrY3kiOiLQhiIsIml1a2N5Ijoi0ZYiLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJKY2lyYyI6IsS0IiwiamNpcmMiOiLEtSIsIkpjeSI6ItCZIiwiamN5Ijoi0LkiLCJKZnIiOiLwnZSNIiwiamZyIjoi8J2UpyIsImptYXRoIjoiyLciLCJKb3BmIjoi8J2VgSIsImpvcGYiOiLwnZWbIiwiSnNjciI6IvCdkqUiLCJqc2NyIjoi8J2SvyIsIkpzZXJjeSI6ItCIIiwianNlcmN5Ijoi0ZgiLCJKdWtjeSI6ItCEIiwianVrY3kiOiLRlCIsIkthcHBhIjoizpoiLCJrYXBwYSI6Is66Iiwia2FwcGF2Ijoiz7AiLCJLY2VkaWwiOiLEtiIsImtjZWRpbCI6IsS3IiwiS2N5Ijoi0JoiLCJrY3kiOiLQuiIsIktmciI6IvCdlI4iLCJrZnIiOiLwnZSoIiwia2dyZWVuIjoixLgiLCJLSGN5Ijoi0KUiLCJraGN5Ijoi0YUiLCJLSmN5Ijoi0IwiLCJramN5Ijoi0ZwiLCJLb3BmIjoi8J2VgiIsImtvcGYiOiLwnZWcIiwiS3NjciI6IvCdkqYiLCJrc2NyIjoi8J2TgCIsImxBYXJyIjoi4oeaIiwiTGFjdXRlIjoixLkiLCJsYWN1dGUiOiLEuiIsImxhZW1wdHl2Ijoi4qa0IiwibGFncmFuIjoi4oSSIiwiTGFtYmRhIjoizpsiLCJsYW1iZGEiOiLOuyIsImxhbmciOiLin6giLCJMYW5nIjoi4p+qIiwibGFuZ2QiOiLippEiLCJsYW5nbGUiOiLin6giLCJsYXAiOiLiqoUiLCJMYXBsYWNldHJmIjoi4oSSIiwibGFxdW8iOiLCqyIsImxhcnJiIjoi4oekIiwibGFycmJmcyI6IuKknyIsImxhcnIiOiLihpAiLCJMYXJyIjoi4oaeIiwibEFyciI6IuKHkCIsImxhcnJmcyI6IuKknSIsImxhcnJoayI6IuKGqSIsImxhcnJscCI6IuKGqyIsImxhcnJwbCI6IuKkuSIsImxhcnJzaW0iOiLipbMiLCJsYXJydGwiOiLihqIiLCJsYXRhaWwiOiLipJkiLCJsQXRhaWwiOiLipJsiLCJsYXQiOiLiqqsiLCJsYXRlIjoi4qqtIiwibGF0ZXMiOiLiqq3vuIAiLCJsYmFyciI6IuKkjCIsImxCYXJyIjoi4qSOIiwibGJicmsiOiLinbIiLCJsYnJhY2UiOiJ7IiwibGJyYWNrIjoiWyIsImxicmtlIjoi4qaLIiwibGJya3NsZCI6IuKmjyIsImxicmtzbHUiOiLipo0iLCJMY2Fyb24iOiLEvSIsImxjYXJvbiI6IsS+IiwiTGNlZGlsIjoixLsiLCJsY2VkaWwiOiLEvCIsImxjZWlsIjoi4oyIIiwibGN1YiI6InsiLCJMY3kiOiLQmyIsImxjeSI6ItC7IiwibGRjYSI6IuKktiIsImxkcXVvIjoi4oCcIiwibGRxdW9yIjoi4oCeIiwibGRyZGhhciI6IuKlpyIsImxkcnVzaGFyIjoi4qWLIiwibGRzaCI6IuKGsiIsImxlIjoi4omkIiwibEUiOiLiiaYiLCJMZWZ0QW5nbGVCcmFja2V0Ijoi4p+oIiwiTGVmdEFycm93QmFyIjoi4oekIiwibGVmdGFycm93Ijoi4oaQIiwiTGVmdEFycm93Ijoi4oaQIiwiTGVmdGFycm93Ijoi4oeQIiwiTGVmdEFycm93UmlnaHRBcnJvdyI6IuKHhiIsImxlZnRhcnJvd3RhaWwiOiLihqIiLCJMZWZ0Q2VpbGluZyI6IuKMiCIsIkxlZnREb3VibGVCcmFja2V0Ijoi4p+mIiwiTGVmdERvd25UZWVWZWN0b3IiOiLipaEiLCJMZWZ0RG93blZlY3RvckJhciI6IuKlmSIsIkxlZnREb3duVmVjdG9yIjoi4oeDIiwiTGVmdEZsb29yIjoi4oyKIiwibGVmdGhhcnBvb25kb3duIjoi4oa9IiwibGVmdGhhcnBvb251cCI6IuKGvCIsImxlZnRsZWZ0YXJyb3dzIjoi4oeHIiwibGVmdHJpZ2h0YXJyb3ciOiLihpQiLCJMZWZ0UmlnaHRBcnJvdyI6IuKGlCIsIkxlZnRyaWdodGFycm93Ijoi4oeUIiwibGVmdHJpZ2h0YXJyb3dzIjoi4oeGIiwibGVmdHJpZ2h0aGFycG9vbnMiOiLih4siLCJsZWZ0cmlnaHRzcXVpZ2Fycm93Ijoi4oatIiwiTGVmdFJpZ2h0VmVjdG9yIjoi4qWOIiwiTGVmdFRlZUFycm93Ijoi4oakIiwiTGVmdFRlZSI6IuKKoyIsIkxlZnRUZWVWZWN0b3IiOiLipZoiLCJsZWZ0dGhyZWV0aW1lcyI6IuKLiyIsIkxlZnRUcmlhbmdsZUJhciI6IuKnjyIsIkxlZnRUcmlhbmdsZSI6IuKKsiIsIkxlZnRUcmlhbmdsZUVxdWFsIjoi4oq0IiwiTGVmdFVwRG93blZlY3RvciI6IuKlkSIsIkxlZnRVcFRlZVZlY3RvciI6IuKloCIsIkxlZnRVcFZlY3RvckJhciI6IuKlmCIsIkxlZnRVcFZlY3RvciI6IuKGvyIsIkxlZnRWZWN0b3JCYXIiOiLipZIiLCJMZWZ0VmVjdG9yIjoi4oa8IiwibEVnIjoi4qqLIiwibGVnIjoi4ouaIiwibGVxIjoi4omkIiwibGVxcSI6IuKJpiIsImxlcXNsYW50Ijoi4qm9IiwibGVzY2MiOiLiqqgiLCJsZXMiOiLiqb0iLCJsZXNkb3QiOiLiqb8iLCJsZXNkb3RvIjoi4qqBIiwibGVzZG90b3IiOiLiqoMiLCJsZXNnIjoi4oua77iAIiwibGVzZ2VzIjoi4qqTIiwibGVzc2FwcHJveCI6IuKqhSIsImxlc3Nkb3QiOiLii5YiLCJsZXNzZXFndHIiOiLii5oiLCJsZXNzZXFxZ3RyIjoi4qqLIiwiTGVzc0VxdWFsR3JlYXRlciI6IuKLmiIsIkxlc3NGdWxsRXF1YWwiOiLiiaYiLCJMZXNzR3JlYXRlciI6IuKJtiIsImxlc3NndHIiOiLiibYiLCJMZXNzTGVzcyI6IuKqoSIsImxlc3NzaW0iOiLiibIiLCJMZXNzU2xhbnRFcXVhbCI6IuKpvSIsIkxlc3NUaWxkZSI6IuKJsiIsImxmaXNodCI6IuKlvCIsImxmbG9vciI6IuKMiiIsIkxmciI6IvCdlI8iLCJsZnIiOiLwnZSpIiwibGciOiLiibYiLCJsZ0UiOiLiqpEiLCJsSGFyIjoi4qWiIiwibGhhcmQiOiLihr0iLCJsaGFydSI6IuKGvCIsImxoYXJ1bCI6IuKlqiIsImxoYmxrIjoi4paEIiwiTEpjeSI6ItCJIiwibGpjeSI6ItGZIiwibGxhcnIiOiLih4ciLCJsbCI6IuKJqiIsIkxsIjoi4ouYIiwibGxjb3JuZXIiOiLijJ4iLCJMbGVmdGFycm93Ijoi4oeaIiwibGxoYXJkIjoi4qWrIiwibGx0cmkiOiLil7oiLCJMbWlkb3QiOiLEvyIsImxtaWRvdCI6IsWAIiwibG1vdXN0YWNoZSI6IuKOsCIsImxtb3VzdCI6IuKOsCIsImxuYXAiOiLiqokiLCJsbmFwcHJveCI6IuKqiSIsImxuZSI6IuKqhyIsImxuRSI6IuKJqCIsImxuZXEiOiLiqociLCJsbmVxcSI6IuKJqCIsImxuc2ltIjoi4oumIiwibG9hbmciOiLin6wiLCJsb2FyciI6IuKHvSIsImxvYnJrIjoi4p+mIiwibG9uZ2xlZnRhcnJvdyI6IuKftSIsIkxvbmdMZWZ0QXJyb3ciOiLin7UiLCJMb25nbGVmdGFycm93Ijoi4p+4IiwibG9uZ2xlZnRyaWdodGFycm93Ijoi4p+3IiwiTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+3IiwiTG9uZ2xlZnRyaWdodGFycm93Ijoi4p+6IiwibG9uZ21hcHN0byI6IuKfvCIsImxvbmdyaWdodGFycm93Ijoi4p+2IiwiTG9uZ1JpZ2h0QXJyb3ciOiLin7YiLCJMb25ncmlnaHRhcnJvdyI6IuKfuSIsImxvb3BhcnJvd2xlZnQiOiLihqsiLCJsb29wYXJyb3dyaWdodCI6IuKGrCIsImxvcGFyIjoi4qaFIiwiTG9wZiI6IvCdlYMiLCJsb3BmIjoi8J2VnSIsImxvcGx1cyI6IuKorSIsImxvdGltZXMiOiLiqLQiLCJsb3dhc3QiOiLiiJciLCJsb3diYXIiOiJfIiwiTG93ZXJMZWZ0QXJyb3ciOiLihpkiLCJMb3dlclJpZ2h0QXJyb3ciOiLihpgiLCJsb3oiOiLil4oiLCJsb3plbmdlIjoi4peKIiwibG96ZiI6IuKnqyIsImxwYXIiOiIoIiwibHBhcmx0Ijoi4qaTIiwibHJhcnIiOiLih4YiLCJscmNvcm5lciI6IuKMnyIsImxyaGFyIjoi4oeLIiwibHJoYXJkIjoi4qWtIiwibHJtIjoi4oCOIiwibHJ0cmkiOiLiir8iLCJsc2FxdW8iOiLigLkiLCJsc2NyIjoi8J2TgSIsIkxzY3IiOiLihJIiLCJsc2giOiLihrAiLCJMc2giOiLihrAiLCJsc2ltIjoi4omyIiwibHNpbWUiOiLiqo0iLCJsc2ltZyI6IuKqjyIsImxzcWIiOiJbIiwibHNxdW8iOiLigJgiLCJsc3F1b3IiOiLigJoiLCJMc3Ryb2siOiLFgSIsImxzdHJvayI6IsWCIiwibHRjYyI6IuKqpiIsImx0Y2lyIjoi4qm5IiwibHQiOiI8IiwiTFQiOiI8IiwiTHQiOiLiiaoiLCJsdGRvdCI6IuKLliIsImx0aHJlZSI6IuKLiyIsImx0aW1lcyI6IuKLiSIsImx0bGFyciI6IuKltiIsImx0cXVlc3QiOiLiqbsiLCJsdHJpIjoi4peDIiwibHRyaWUiOiLiirQiLCJsdHJpZiI6IuKXgiIsImx0clBhciI6IuKmliIsImx1cmRzaGFyIjoi4qWKIiwibHVydWhhciI6IuKlpiIsImx2ZXJ0bmVxcSI6IuKJqO+4gCIsImx2bkUiOiLiiajvuIAiLCJtYWNyIjoiwq8iLCJtYWxlIjoi4pmCIiwibWFsdCI6IuKcoCIsIm1hbHRlc2UiOiLinKAiLCJNYXAiOiLipIUiLCJtYXAiOiLihqYiLCJtYXBzdG8iOiLihqYiLCJtYXBzdG9kb3duIjoi4oanIiwibWFwc3RvbGVmdCI6IuKGpCIsIm1hcHN0b3VwIjoi4oalIiwibWFya2VyIjoi4pauIiwibWNvbW1hIjoi4qipIiwiTWN5Ijoi0JwiLCJtY3kiOiLQvCIsIm1kYXNoIjoi4oCUIiwibUREb3QiOiLiiLoiLCJtZWFzdXJlZGFuZ2xlIjoi4oihIiwiTWVkaXVtU3BhY2UiOiLigZ8iLCJNZWxsaW50cmYiOiLihLMiLCJNZnIiOiLwnZSQIiwibWZyIjoi8J2UqiIsIm1obyI6IuKEpyIsIm1pY3JvIjoiwrUiLCJtaWRhc3QiOiIqIiwibWlkY2lyIjoi4quwIiwibWlkIjoi4oijIiwibWlkZG90IjoiwrciLCJtaW51c2IiOiLiip8iLCJtaW51cyI6IuKIkiIsIm1pbnVzZCI6IuKIuCIsIm1pbnVzZHUiOiLiqKoiLCJNaW51c1BsdXMiOiLiiJMiLCJtbGNwIjoi4qubIiwibWxkciI6IuKApiIsIm1ucGx1cyI6IuKIkyIsIm1vZGVscyI6IuKKpyIsIk1vcGYiOiLwnZWEIiwibW9wZiI6IvCdlZ4iLCJtcCI6IuKIkyIsIm1zY3IiOiLwnZOCIiwiTXNjciI6IuKEsyIsIm1zdHBvcyI6IuKIviIsIk11IjoizpwiLCJtdSI6Is68IiwibXVsdGltYXAiOiLiirgiLCJtdW1hcCI6IuKKuCIsIm5hYmxhIjoi4oiHIiwiTmFjdXRlIjoixYMiLCJuYWN1dGUiOiLFhCIsIm5hbmciOiLiiKDig5IiLCJuYXAiOiLiiYkiLCJuYXBFIjoi4qmwzLgiLCJuYXBpZCI6IuKJi8y4IiwibmFwb3MiOiLFiSIsIm5hcHByb3giOiLiiYkiLCJuYXR1cmFsIjoi4pmuIiwibmF0dXJhbHMiOiLihJUiLCJuYXR1ciI6IuKZriIsIm5ic3AiOiLCoCIsIm5idW1wIjoi4omOzLgiLCJuYnVtcGUiOiLiiY/MuCIsIm5jYXAiOiLiqYMiLCJOY2Fyb24iOiLFhyIsIm5jYXJvbiI6IsWIIiwiTmNlZGlsIjoixYUiLCJuY2VkaWwiOiLFhiIsIm5jb25nIjoi4omHIiwibmNvbmdkb3QiOiLiqa3MuCIsIm5jdXAiOiLiqYIiLCJOY3kiOiLQnSIsIm5jeSI6ItC9IiwibmRhc2giOiLigJMiLCJuZWFyaGsiOiLipKQiLCJuZWFyciI6IuKGlyIsIm5lQXJyIjoi4oeXIiwibmVhcnJvdyI6IuKGlyIsIm5lIjoi4omgIiwibmVkb3QiOiLiiZDMuCIsIk5lZ2F0aXZlTWVkaXVtU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaWNrU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaW5TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZSI6IuKAiyIsIm5lcXVpdiI6IuKJoiIsIm5lc2VhciI6IuKkqCIsIm5lc2ltIjoi4omCzLgiLCJOZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKJqyIsIk5lc3RlZExlc3NMZXNzIjoi4omqIiwiTmV3TGluZSI6IlxcbiIsIm5leGlzdCI6IuKIhCIsIm5leGlzdHMiOiLiiIQiLCJOZnIiOiLwnZSRIiwibmZyIjoi8J2UqyIsIm5nRSI6IuKJp8y4IiwibmdlIjoi4omxIiwibmdlcSI6IuKJsSIsIm5nZXFxIjoi4omnzLgiLCJuZ2Vxc2xhbnQiOiLiqb7MuCIsIm5nZXMiOiLiqb7MuCIsIm5HZyI6IuKLmcy4IiwibmdzaW0iOiLiibUiLCJuR3QiOiLiiavig5IiLCJuZ3QiOiLiia8iLCJuZ3RyIjoi4omvIiwibkd0diI6IuKJq8y4IiwibmhhcnIiOiLihq4iLCJuaEFyciI6IuKHjiIsIm5ocGFyIjoi4quyIiwibmkiOiLiiIsiLCJuaXMiOiLii7wiLCJuaXNkIjoi4ou6Iiwibml2Ijoi4oiLIiwiTkpjeSI6ItCKIiwibmpjeSI6ItGaIiwibmxhcnIiOiLihpoiLCJubEFyciI6IuKHjSIsIm5sZHIiOiLigKUiLCJubEUiOiLiiabMuCIsIm5sZSI6IuKJsCIsIm5sZWZ0YXJyb3ciOiLihpoiLCJuTGVmdGFycm93Ijoi4oeNIiwibmxlZnRyaWdodGFycm93Ijoi4oauIiwibkxlZnRyaWdodGFycm93Ijoi4oeOIiwibmxlcSI6IuKJsCIsIm5sZXFxIjoi4ommzLgiLCJubGVxc2xhbnQiOiLiqb3MuCIsIm5sZXMiOiLiqb3MuCIsIm5sZXNzIjoi4omuIiwibkxsIjoi4ouYzLgiLCJubHNpbSI6IuKJtCIsIm5MdCI6IuKJquKDkiIsIm5sdCI6IuKJriIsIm5sdHJpIjoi4ouqIiwibmx0cmllIjoi4ousIiwibkx0diI6IuKJqsy4Iiwibm1pZCI6IuKIpCIsIk5vQnJlYWsiOiLigaAiLCJOb25CcmVha2luZ1NwYWNlIjoiwqAiLCJub3BmIjoi8J2VnyIsIk5vcGYiOiLihJUiLCJOb3QiOiLiq6wiLCJub3QiOiLCrCIsIk5vdENvbmdydWVudCI6IuKJoiIsIk5vdEN1cENhcCI6IuKJrSIsIk5vdERvdWJsZVZlcnRpY2FsQmFyIjoi4oimIiwiTm90RWxlbWVudCI6IuKIiSIsIk5vdEVxdWFsIjoi4omgIiwiTm90RXF1YWxUaWxkZSI6IuKJgsy4IiwiTm90RXhpc3RzIjoi4oiEIiwiTm90R3JlYXRlciI6IuKJryIsIk5vdEdyZWF0ZXJFcXVhbCI6IuKJsSIsIk5vdEdyZWF0ZXJGdWxsRXF1YWwiOiLiiafMuCIsIk5vdEdyZWF0ZXJHcmVhdGVyIjoi4omrzLgiLCJOb3RHcmVhdGVyTGVzcyI6IuKJuSIsIk5vdEdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+zLgiLCJOb3RHcmVhdGVyVGlsZGUiOiLiibUiLCJOb3RIdW1wRG93bkh1bXAiOiLiiY7MuCIsIk5vdEh1bXBFcXVhbCI6IuKJj8y4Iiwibm90aW4iOiLiiIkiLCJub3RpbmRvdCI6IuKLtcy4Iiwibm90aW5FIjoi4ou5zLgiLCJub3RpbnZhIjoi4oiJIiwibm90aW52YiI6IuKLtyIsIm5vdGludmMiOiLii7YiLCJOb3RMZWZ0VHJpYW5nbGVCYXIiOiLip4/MuCIsIk5vdExlZnRUcmlhbmdsZSI6IuKLqiIsIk5vdExlZnRUcmlhbmdsZUVxdWFsIjoi4ousIiwiTm90TGVzcyI6IuKJriIsIk5vdExlc3NFcXVhbCI6IuKJsCIsIk5vdExlc3NHcmVhdGVyIjoi4om4IiwiTm90TGVzc0xlc3MiOiLiiarMuCIsIk5vdExlc3NTbGFudEVxdWFsIjoi4qm9zLgiLCJOb3RMZXNzVGlsZGUiOiLiibQiLCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKqosy4IiwiTm90TmVzdGVkTGVzc0xlc3MiOiLiqqHMuCIsIm5vdG5pIjoi4oiMIiwibm90bml2YSI6IuKIjCIsIm5vdG5pdmIiOiLii74iLCJub3RuaXZjIjoi4ou9IiwiTm90UHJlY2VkZXMiOiLiioAiLCJOb3RQcmVjZWRlc0VxdWFsIjoi4qqvzLgiLCJOb3RQcmVjZWRlc1NsYW50RXF1YWwiOiLii6AiLCJOb3RSZXZlcnNlRWxlbWVudCI6IuKIjCIsIk5vdFJpZ2h0VHJpYW5nbGVCYXIiOiLip5DMuCIsIk5vdFJpZ2h0VHJpYW5nbGUiOiLii6siLCJOb3RSaWdodFRyaWFuZ2xlRXF1YWwiOiLii60iLCJOb3RTcXVhcmVTdWJzZXQiOiLiio/MuCIsIk5vdFNxdWFyZVN1YnNldEVxdWFsIjoi4ouiIiwiTm90U3F1YXJlU3VwZXJzZXQiOiLiipDMuCIsIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWwiOiLii6MiLCJOb3RTdWJzZXQiOiLiioLig5IiLCJOb3RTdWJzZXRFcXVhbCI6IuKKiCIsIk5vdFN1Y2NlZWRzIjoi4oqBIiwiTm90U3VjY2VlZHNFcXVhbCI6IuKqsMy4IiwiTm90U3VjY2VlZHNTbGFudEVxdWFsIjoi4ouhIiwiTm90U3VjY2VlZHNUaWxkZSI6IuKJv8y4IiwiTm90U3VwZXJzZXQiOiLiioPig5IiLCJOb3RTdXBlcnNldEVxdWFsIjoi4oqJIiwiTm90VGlsZGUiOiLiiYEiLCJOb3RUaWxkZUVxdWFsIjoi4omEIiwiTm90VGlsZGVGdWxsRXF1YWwiOiLiiYciLCJOb3RUaWxkZVRpbGRlIjoi4omJIiwiTm90VmVydGljYWxCYXIiOiLiiKQiLCJucGFyYWxsZWwiOiLiiKYiLCJucGFyIjoi4oimIiwibnBhcnNsIjoi4qu94oOlIiwibnBhcnQiOiLiiILMuCIsIm5wb2xpbnQiOiLiqJQiLCJucHIiOiLiioAiLCJucHJjdWUiOiLii6AiLCJucHJlYyI6IuKKgCIsIm5wcmVjZXEiOiLiqq/MuCIsIm5wcmUiOiLiqq/MuCIsIm5yYXJyYyI6IuKks8y4IiwibnJhcnIiOiLihpsiLCJuckFyciI6IuKHjyIsIm5yYXJydyI6IuKGncy4IiwibnJpZ2h0YXJyb3ciOiLihpsiLCJuUmlnaHRhcnJvdyI6IuKHjyIsIm5ydHJpIjoi4ourIiwibnJ0cmllIjoi4outIiwibnNjIjoi4oqBIiwibnNjY3VlIjoi4ouhIiwibnNjZSI6IuKqsMy4IiwiTnNjciI6IvCdkqkiLCJuc2NyIjoi8J2TgyIsIm5zaG9ydG1pZCI6IuKIpCIsIm5zaG9ydHBhcmFsbGVsIjoi4oimIiwibnNpbSI6IuKJgSIsIm5zaW1lIjoi4omEIiwibnNpbWVxIjoi4omEIiwibnNtaWQiOiLiiKQiLCJuc3BhciI6IuKIpiIsIm5zcXN1YmUiOiLii6IiLCJuc3FzdXBlIjoi4oujIiwibnN1YiI6IuKKhCIsIm5zdWJFIjoi4quFzLgiLCJuc3ViZSI6IuKKiCIsIm5zdWJzZXQiOiLiioLig5IiLCJuc3Vic2V0ZXEiOiLiiogiLCJuc3Vic2V0ZXFxIjoi4quFzLgiLCJuc3VjYyI6IuKKgSIsIm5zdWNjZXEiOiLiqrDMuCIsIm5zdXAiOiLiioUiLCJuc3VwRSI6IuKrhsy4IiwibnN1cGUiOiLiiokiLCJuc3Vwc2V0Ijoi4oqD4oOSIiwibnN1cHNldGVxIjoi4oqJIiwibnN1cHNldGVxcSI6IuKrhsy4IiwibnRnbCI6IuKJuSIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJudGxnIjoi4om4IiwibnRyaWFuZ2xlbGVmdCI6IuKLqiIsIm50cmlhbmdsZWxlZnRlcSI6IuKLrCIsIm50cmlhbmdsZXJpZ2h0Ijoi4ourIiwibnRyaWFuZ2xlcmlnaHRlcSI6IuKLrSIsIk51Ijoizp0iLCJudSI6Is69IiwibnVtIjoiIyIsIm51bWVybyI6IuKEliIsIm51bXNwIjoi4oCHIiwibnZhcCI6IuKJjeKDkiIsIm52ZGFzaCI6IuKKrCIsIm52RGFzaCI6IuKKrSIsIm5WZGFzaCI6IuKKriIsIm5WRGFzaCI6IuKKryIsIm52Z2UiOiLiiaXig5IiLCJudmd0IjoiPuKDkiIsIm52SGFyciI6IuKkhCIsIm52aW5maW4iOiLip54iLCJudmxBcnIiOiLipIIiLCJudmxlIjoi4omk4oOSIiwibnZsdCI6Ijzig5IiLCJudmx0cmllIjoi4oq04oOSIiwibnZyQXJyIjoi4qSDIiwibnZydHJpZSI6IuKKteKDkiIsIm52c2ltIjoi4oi84oOSIiwibndhcmhrIjoi4qSjIiwibndhcnIiOiLihpYiLCJud0FyciI6IuKHliIsIm53YXJyb3ciOiLihpYiLCJud25lYXIiOiLipKciLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwib2FzdCI6IuKKmyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0Iiwib2NpciI6IuKKmiIsIk9jeSI6ItCeIiwib2N5Ijoi0L4iLCJvZGFzaCI6IuKKnSIsIk9kYmxhYyI6IsWQIiwib2RibGFjIjoixZEiLCJvZGl2Ijoi4qi4Iiwib2RvdCI6IuKKmSIsIm9kc29sZCI6IuKmvCIsIk9FbGlnIjoixZIiLCJvZWxpZyI6IsWTIiwib2ZjaXIiOiLipr8iLCJPZnIiOiLwnZSSIiwib2ZyIjoi8J2UrCIsIm9nb24iOiLLmyIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvZ3QiOiLip4EiLCJvaGJhciI6IuKmtSIsIm9obSI6Is6pIiwib2ludCI6IuKIriIsIm9sYXJyIjoi4oa6Iiwib2xjaXIiOiLipr4iLCJvbGNyb3NzIjoi4qa7Iiwib2xpbmUiOiLigL4iLCJvbHQiOiLip4AiLCJPbWFjciI6IsWMIiwib21hY3IiOiLFjSIsIk9tZWdhIjoizqkiLCJvbWVnYSI6Is+JIiwiT21pY3JvbiI6Is6fIiwib21pY3JvbiI6Is6/Iiwib21pZCI6IuKmtiIsIm9taW51cyI6IuKKliIsIk9vcGYiOiLwnZWGIiwib29wZiI6IvCdlaAiLCJvcGFyIjoi4qa3IiwiT3BlbkN1cmx5RG91YmxlUXVvdGUiOiLigJwiLCJPcGVuQ3VybHlRdW90ZSI6IuKAmCIsIm9wZXJwIjoi4qa5Iiwib3BsdXMiOiLiipUiLCJvcmFyciI6IuKGuyIsIk9yIjoi4qmUIiwib3IiOiLiiKgiLCJvcmQiOiLiqZ0iLCJvcmRlciI6IuKEtCIsIm9yZGVyb2YiOiLihLQiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJvcmlnb2YiOiLiirYiLCJvcm9yIjoi4qmWIiwib3JzbG9wZSI6IuKplyIsIm9ydiI6IuKpmyIsIm9TIjoi4pOIIiwiT3NjciI6IvCdkqoiLCJvc2NyIjoi4oS0IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIm9zb2wiOiLiipgiLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1Iiwib3RpbWVzYXMiOiLiqLYiLCJPdGltZXMiOiLiqLciLCJvdGltZXMiOiLiipciLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJvdmJhciI6IuKMvSIsIk92ZXJCYXIiOiLigL4iLCJPdmVyQnJhY2UiOiLij54iLCJPdmVyQnJhY2tldCI6IuKOtCIsIk92ZXJQYXJlbnRoZXNpcyI6IuKPnCIsInBhcmEiOiLCtiIsInBhcmFsbGVsIjoi4oilIiwicGFyIjoi4oilIiwicGFyc2ltIjoi4quzIiwicGFyc2wiOiLiq70iLCJwYXJ0Ijoi4oiCIiwiUGFydGlhbEQiOiLiiIIiLCJQY3kiOiLQnyIsInBjeSI6ItC/IiwicGVyY250IjoiJSIsInBlcmlvZCI6Ii4iLCJwZXJtaWwiOiLigLAiLCJwZXJwIjoi4oqlIiwicGVydGVuayI6IuKAsSIsIlBmciI6IvCdlJMiLCJwZnIiOiLwnZStIiwiUGhpIjoizqYiLCJwaGkiOiLPhiIsInBoaXYiOiLPlSIsInBobW1hdCI6IuKEsyIsInBob25lIjoi4piOIiwiUGkiOiLOoCIsInBpIjoiz4AiLCJwaXRjaGZvcmsiOiLii5QiLCJwaXYiOiLPliIsInBsYW5jayI6IuKEjyIsInBsYW5ja2giOiLihI4iLCJwbGFua3YiOiLihI8iLCJwbHVzYWNpciI6IuKooyIsInBsdXNiIjoi4oqeIiwicGx1c2NpciI6IuKooiIsInBsdXMiOiIrIiwicGx1c2RvIjoi4oiUIiwicGx1c2R1Ijoi4qilIiwicGx1c2UiOiLiqbIiLCJQbHVzTWludXMiOiLCsSIsInBsdXNtbiI6IsKxIiwicGx1c3NpbSI6IuKopiIsInBsdXN0d28iOiLiqKciLCJwbSI6IsKxIiwiUG9pbmNhcmVwbGFuZSI6IuKEjCIsInBvaW50aW50Ijoi4qiVIiwicG9wZiI6IvCdlaEiLCJQb3BmIjoi4oSZIiwicG91bmQiOiLCoyIsInByYXAiOiLiqrciLCJQciI6IuKquyIsInByIjoi4om6IiwicHJjdWUiOiLiibwiLCJwcmVjYXBwcm94Ijoi4qq3IiwicHJlYyI6IuKJuiIsInByZWNjdXJseWVxIjoi4om8IiwiUHJlY2VkZXMiOiLiiboiLCJQcmVjZWRlc0VxdWFsIjoi4qqvIiwiUHJlY2VkZXNTbGFudEVxdWFsIjoi4om8IiwiUHJlY2VkZXNUaWxkZSI6IuKJviIsInByZWNlcSI6IuKqryIsInByZWNuYXBwcm94Ijoi4qq5IiwicHJlY25lcXEiOiLiqrUiLCJwcmVjbnNpbSI6IuKLqCIsInByZSI6IuKqryIsInByRSI6IuKqsyIsInByZWNzaW0iOiLiib4iLCJwcmltZSI6IuKAsiIsIlByaW1lIjoi4oCzIiwicHJpbWVzIjoi4oSZIiwicHJuYXAiOiLiqrkiLCJwcm5FIjoi4qq1IiwicHJuc2ltIjoi4ouoIiwicHJvZCI6IuKIjyIsIlByb2R1Y3QiOiLiiI8iLCJwcm9mYWxhciI6IuKMriIsInByb2ZsaW5lIjoi4oySIiwicHJvZnN1cmYiOiLijJMiLCJwcm9wIjoi4oidIiwiUHJvcG9ydGlvbmFsIjoi4oidIiwiUHJvcG9ydGlvbiI6IuKItyIsInByb3B0byI6IuKInSIsInByc2ltIjoi4om+IiwicHJ1cmVsIjoi4oqwIiwiUHNjciI6IvCdkqsiLCJwc2NyIjoi8J2ThSIsIlBzaSI6Is6oIiwicHNpIjoiz4giLCJwdW5jc3AiOiLigIgiLCJRZnIiOiLwnZSUIiwicWZyIjoi8J2UriIsInFpbnQiOiLiqIwiLCJxb3BmIjoi8J2VoiIsIlFvcGYiOiLihJoiLCJxcHJpbWUiOiLigZciLCJRc2NyIjoi8J2SrCIsInFzY3IiOiLwnZOGIiwicXVhdGVybmlvbnMiOiLihI0iLCJxdWF0aW50Ijoi4qiWIiwicXVlc3QiOiI/IiwicXVlc3RlcSI6IuKJnyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwickFhcnIiOiLih5siLCJyYWNlIjoi4oi9zLEiLCJSYWN1dGUiOiLFlCIsInJhY3V0ZSI6IsWVIiwicmFkaWMiOiLiiJoiLCJyYWVtcHR5diI6IuKmsyIsInJhbmciOiLin6kiLCJSYW5nIjoi4p+rIiwicmFuZ2QiOiLippIiLCJyYW5nZSI6IuKmpSIsInJhbmdsZSI6IuKfqSIsInJhcXVvIjoiwrsiLCJyYXJyYXAiOiLipbUiLCJyYXJyYiI6IuKHpSIsInJhcnJiZnMiOiLipKAiLCJyYXJyYyI6IuKksyIsInJhcnIiOiLihpIiLCJSYXJyIjoi4oagIiwickFyciI6IuKHkiIsInJhcnJmcyI6IuKkniIsInJhcnJoayI6IuKGqiIsInJhcnJscCI6IuKGrCIsInJhcnJwbCI6IuKlhSIsInJhcnJzaW0iOiLipbQiLCJSYXJydGwiOiLipJYiLCJyYXJydGwiOiLihqMiLCJyYXJydyI6IuKGnSIsInJhdGFpbCI6IuKkmiIsInJBdGFpbCI6IuKknCIsInJhdGlvIjoi4oi2IiwicmF0aW9uYWxzIjoi4oSaIiwicmJhcnIiOiLipI0iLCJyQmFyciI6IuKkjyIsIlJCYXJyIjoi4qSQIiwicmJicmsiOiLinbMiLCJyYnJhY2UiOiJ9IiwicmJyYWNrIjoiXSIsInJicmtlIjoi4qaMIiwicmJya3NsZCI6IuKmjiIsInJicmtzbHUiOiLippAiLCJSY2Fyb24iOiLFmCIsInJjYXJvbiI6IsWZIiwiUmNlZGlsIjoixZYiLCJyY2VkaWwiOiLFlyIsInJjZWlsIjoi4oyJIiwicmN1YiI6In0iLCJSY3kiOiLQoCIsInJjeSI6ItGAIiwicmRjYSI6IuKktyIsInJkbGRoYXIiOiLipakiLCJyZHF1byI6IuKAnSIsInJkcXVvciI6IuKAnSIsInJkc2giOiLihrMiLCJyZWFsIjoi4oScIiwicmVhbGluZSI6IuKEmyIsInJlYWxwYXJ0Ijoi4oScIiwicmVhbHMiOiLihJ0iLCJSZSI6IuKEnCIsInJlY3QiOiLilq0iLCJyZWciOiLCriIsIlJFRyI6IsKuIiwiUmV2ZXJzZUVsZW1lbnQiOiLiiIsiLCJSZXZlcnNlRXF1aWxpYnJpdW0iOiLih4siLCJSZXZlcnNlVXBFcXVpbGlicml1bSI6IuKlryIsInJmaXNodCI6IuKlvSIsInJmbG9vciI6IuKMiyIsInJmciI6IvCdlK8iLCJSZnIiOiLihJwiLCJySGFyIjoi4qWkIiwicmhhcmQiOiLih4EiLCJyaGFydSI6IuKHgCIsInJoYXJ1bCI6IuKlrCIsIlJobyI6Is6hIiwicmhvIjoiz4EiLCJyaG92Ijoiz7EiLCJSaWdodEFuZ2xlQnJhY2tldCI6IuKfqSIsIlJpZ2h0QXJyb3dCYXIiOiLih6UiLCJyaWdodGFycm93Ijoi4oaSIiwiUmlnaHRBcnJvdyI6IuKGkiIsIlJpZ2h0YXJyb3ciOiLih5IiLCJSaWdodEFycm93TGVmdEFycm93Ijoi4oeEIiwicmlnaHRhcnJvd3RhaWwiOiLihqMiLCJSaWdodENlaWxpbmciOiLijIkiLCJSaWdodERvdWJsZUJyYWNrZXQiOiLin6ciLCJSaWdodERvd25UZWVWZWN0b3IiOiLipZ0iLCJSaWdodERvd25WZWN0b3JCYXIiOiLipZUiLCJSaWdodERvd25WZWN0b3IiOiLih4IiLCJSaWdodEZsb29yIjoi4oyLIiwicmlnaHRoYXJwb29uZG93biI6IuKHgSIsInJpZ2h0aGFycG9vbnVwIjoi4oeAIiwicmlnaHRsZWZ0YXJyb3dzIjoi4oeEIiwicmlnaHRsZWZ0aGFycG9vbnMiOiLih4wiLCJyaWdodHJpZ2h0YXJyb3dzIjoi4oeJIiwicmlnaHRzcXVpZ2Fycm93Ijoi4oadIiwiUmlnaHRUZWVBcnJvdyI6IuKGpiIsIlJpZ2h0VGVlIjoi4oqiIiwiUmlnaHRUZWVWZWN0b3IiOiLipZsiLCJyaWdodHRocmVldGltZXMiOiLii4wiLCJSaWdodFRyaWFuZ2xlQmFyIjoi4qeQIiwiUmlnaHRUcmlhbmdsZSI6IuKKsyIsIlJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKKtSIsIlJpZ2h0VXBEb3duVmVjdG9yIjoi4qWPIiwiUmlnaHRVcFRlZVZlY3RvciI6IuKlnCIsIlJpZ2h0VXBWZWN0b3JCYXIiOiLipZQiLCJSaWdodFVwVmVjdG9yIjoi4oa+IiwiUmlnaHRWZWN0b3JCYXIiOiLipZMiLCJSaWdodFZlY3RvciI6IuKHgCIsInJpbmciOiLLmiIsInJpc2luZ2RvdHNlcSI6IuKJkyIsInJsYXJyIjoi4oeEIiwicmxoYXIiOiLih4wiLCJybG0iOiLigI8iLCJybW91c3RhY2hlIjoi4o6xIiwicm1vdXN0Ijoi4o6xIiwicm5taWQiOiLiq64iLCJyb2FuZyI6IuKfrSIsInJvYXJyIjoi4oe+Iiwicm9icmsiOiLin6ciLCJyb3BhciI6IuKmhiIsInJvcGYiOiLwnZWjIiwiUm9wZiI6IuKEnSIsInJvcGx1cyI6IuKoriIsInJvdGltZXMiOiLiqLUiLCJSb3VuZEltcGxpZXMiOiLipbAiLCJycGFyIjoiKSIsInJwYXJndCI6IuKmlCIsInJwcG9saW50Ijoi4qiSIiwicnJhcnIiOiLih4kiLCJScmlnaHRhcnJvdyI6IuKHmyIsInJzYXF1byI6IuKAuiIsInJzY3IiOiLwnZOHIiwiUnNjciI6IuKEmyIsInJzaCI6IuKGsSIsIlJzaCI6IuKGsSIsInJzcWIiOiJdIiwicnNxdW8iOiLigJkiLCJyc3F1b3IiOiLigJkiLCJydGhyZWUiOiLii4wiLCJydGltZXMiOiLii4oiLCJydHJpIjoi4pa5IiwicnRyaWUiOiLiirUiLCJydHJpZiI6IuKWuCIsInJ0cmlsdHJpIjoi4qeOIiwiUnVsZURlbGF5ZWQiOiLip7QiLCJydWx1aGFyIjoi4qWoIiwicngiOiLihJ4iLCJTYWN1dGUiOiLFmiIsInNhY3V0ZSI6IsWbIiwic2JxdW8iOiLigJoiLCJzY2FwIjoi4qq4IiwiU2Nhcm9uIjoixaAiLCJzY2Fyb24iOiLFoSIsIlNjIjoi4qq8Iiwic2MiOiLiibsiLCJzY2N1ZSI6IuKJvSIsInNjZSI6IuKqsCIsInNjRSI6IuKqtCIsIlNjZWRpbCI6IsWeIiwic2NlZGlsIjoixZ8iLCJTY2lyYyI6IsWcIiwic2NpcmMiOiLFnSIsInNjbmFwIjoi4qq6Iiwic2NuRSI6IuKqtiIsInNjbnNpbSI6IuKLqSIsInNjcG9saW50Ijoi4qiTIiwic2NzaW0iOiLiib8iLCJTY3kiOiLQoSIsInNjeSI6ItGBIiwic2RvdGIiOiLiiqEiLCJzZG90Ijoi4ouFIiwic2RvdGUiOiLiqaYiLCJzZWFyaGsiOiLipKUiLCJzZWFyciI6IuKGmCIsInNlQXJyIjoi4oeYIiwic2VhcnJvdyI6IuKGmCIsInNlY3QiOiLCpyIsInNlbWkiOiI7Iiwic2Vzd2FyIjoi4qSpIiwic2V0bWludXMiOiLiiJYiLCJzZXRtbiI6IuKIliIsInNleHQiOiLinLYiLCJTZnIiOiLwnZSWIiwic2ZyIjoi8J2UsCIsInNmcm93biI6IuKMoiIsInNoYXJwIjoi4pmvIiwiU0hDSGN5Ijoi0KkiLCJzaGNoY3kiOiLRiSIsIlNIY3kiOiLQqCIsInNoY3kiOiLRiCIsIlNob3J0RG93bkFycm93Ijoi4oaTIiwiU2hvcnRMZWZ0QXJyb3ciOiLihpAiLCJzaG9ydG1pZCI6IuKIoyIsInNob3J0cGFyYWxsZWwiOiLiiKUiLCJTaG9ydFJpZ2h0QXJyb3ciOiLihpIiLCJTaG9ydFVwQXJyb3ciOiLihpEiLCJzaHkiOiLCrSIsIlNpZ21hIjoizqMiLCJzaWdtYSI6Is+DIiwic2lnbWFmIjoiz4IiLCJzaWdtYXYiOiLPgiIsInNpbSI6IuKIvCIsInNpbWRvdCI6IuKpqiIsInNpbWUiOiLiiYMiLCJzaW1lcSI6IuKJgyIsInNpbWciOiLiqp4iLCJzaW1nRSI6IuKqoCIsInNpbWwiOiLiqp0iLCJzaW1sRSI6IuKqnyIsInNpbW5lIjoi4omGIiwic2ltcGx1cyI6IuKopCIsInNpbXJhcnIiOiLipbIiLCJzbGFyciI6IuKGkCIsIlNtYWxsQ2lyY2xlIjoi4oiYIiwic21hbGxzZXRtaW51cyI6IuKIliIsInNtYXNocCI6IuKosyIsInNtZXBhcnNsIjoi4qekIiwic21pZCI6IuKIoyIsInNtaWxlIjoi4oyjIiwic210Ijoi4qqqIiwic210ZSI6IuKqrCIsInNtdGVzIjoi4qqs77iAIiwiU09GVGN5Ijoi0KwiLCJzb2Z0Y3kiOiLRjCIsInNvbGJhciI6IuKMvyIsInNvbGIiOiLip4QiLCJzb2wiOiIvIiwiU29wZiI6IvCdlYoiLCJzb3BmIjoi8J2VpCIsInNwYWRlcyI6IuKZoCIsInNwYWRlc3VpdCI6IuKZoCIsInNwYXIiOiLiiKUiLCJzcWNhcCI6IuKKkyIsInNxY2FwcyI6IuKKk++4gCIsInNxY3VwIjoi4oqUIiwic3FjdXBzIjoi4oqU77iAIiwiU3FydCI6IuKImiIsInNxc3ViIjoi4oqPIiwic3FzdWJlIjoi4oqRIiwic3FzdWJzZXQiOiLiio8iLCJzcXN1YnNldGVxIjoi4oqRIiwic3FzdXAiOiLiipAiLCJzcXN1cGUiOiLiipIiLCJzcXN1cHNldCI6IuKKkCIsInNxc3Vwc2V0ZXEiOiLiipIiLCJzcXVhcmUiOiLilqEiLCJTcXVhcmUiOiLilqEiLCJTcXVhcmVJbnRlcnNlY3Rpb24iOiLiipMiLCJTcXVhcmVTdWJzZXQiOiLiio8iLCJTcXVhcmVTdWJzZXRFcXVhbCI6IuKKkSIsIlNxdWFyZVN1cGVyc2V0Ijoi4oqQIiwiU3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKKkiIsIlNxdWFyZVVuaW9uIjoi4oqUIiwic3F1YXJmIjoi4paqIiwic3F1Ijoi4pahIiwic3F1ZiI6IuKWqiIsInNyYXJyIjoi4oaSIiwiU3NjciI6IvCdkq4iLCJzc2NyIjoi8J2TiCIsInNzZXRtbiI6IuKIliIsInNzbWlsZSI6IuKMoyIsInNzdGFyZiI6IuKLhiIsIlN0YXIiOiLii4YiLCJzdGFyIjoi4piGIiwic3RhcmYiOiLimIUiLCJzdHJhaWdodGVwc2lsb24iOiLPtSIsInN0cmFpZ2h0cGhpIjoiz5UiLCJzdHJucyI6IsKvIiwic3ViIjoi4oqCIiwiU3ViIjoi4ouQIiwic3ViZG90Ijoi4qq9Iiwic3ViRSI6IuKrhSIsInN1YmUiOiLiioYiLCJzdWJlZG90Ijoi4quDIiwic3VibXVsdCI6IuKrgSIsInN1Ym5FIjoi4quLIiwic3VibmUiOiLiiooiLCJzdWJwbHVzIjoi4qq/Iiwic3VicmFyciI6IuKluSIsInN1YnNldCI6IuKKgiIsIlN1YnNldCI6IuKLkCIsInN1YnNldGVxIjoi4oqGIiwic3Vic2V0ZXFxIjoi4quFIiwiU3Vic2V0RXF1YWwiOiLiioYiLCJzdWJzZXRuZXEiOiLiiooiLCJzdWJzZXRuZXFxIjoi4quLIiwic3Vic2ltIjoi4quHIiwic3Vic3ViIjoi4quVIiwic3Vic3VwIjoi4quTIiwic3VjY2FwcHJveCI6IuKquCIsInN1Y2MiOiLiibsiLCJzdWNjY3VybHllcSI6IuKJvSIsIlN1Y2NlZWRzIjoi4om7IiwiU3VjY2VlZHNFcXVhbCI6IuKqsCIsIlN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKJvSIsIlN1Y2NlZWRzVGlsZGUiOiLiib8iLCJzdWNjZXEiOiLiqrAiLCJzdWNjbmFwcHJveCI6IuKquiIsInN1Y2NuZXFxIjoi4qq2Iiwic3VjY25zaW0iOiLii6kiLCJzdWNjc2ltIjoi4om/IiwiU3VjaFRoYXQiOiLiiIsiLCJzdW0iOiLiiJEiLCJTdW0iOiLiiJEiLCJzdW5nIjoi4pmqIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3VwIjoi4oqDIiwiU3VwIjoi4ouRIiwic3VwZG90Ijoi4qq+Iiwic3VwZHN1YiI6IuKrmCIsInN1cEUiOiLiq4YiLCJzdXBlIjoi4oqHIiwic3VwZWRvdCI6IuKrhCIsIlN1cGVyc2V0Ijoi4oqDIiwiU3VwZXJzZXRFcXVhbCI6IuKKhyIsInN1cGhzb2wiOiLin4kiLCJzdXBoc3ViIjoi4quXIiwic3VwbGFyciI6IuKluyIsInN1cG11bHQiOiLiq4IiLCJzdXBuRSI6IuKrjCIsInN1cG5lIjoi4oqLIiwic3VwcGx1cyI6IuKrgCIsInN1cHNldCI6IuKKgyIsIlN1cHNldCI6IuKLkSIsInN1cHNldGVxIjoi4oqHIiwic3Vwc2V0ZXFxIjoi4quGIiwic3Vwc2V0bmVxIjoi4oqLIiwic3Vwc2V0bmVxcSI6IuKrjCIsInN1cHNpbSI6IuKriCIsInN1cHN1YiI6IuKrlCIsInN1cHN1cCI6IuKrliIsInN3YXJoayI6IuKkpiIsInN3YXJyIjoi4oaZIiwic3dBcnIiOiLih5kiLCJzd2Fycm93Ijoi4oaZIiwic3dud2FyIjoi4qSqIiwic3psaWciOiLDnyIsIlRhYiI6IlxcdCIsInRhcmdldCI6IuKMliIsIlRhdSI6Is6kIiwidGF1Ijoiz4QiLCJ0YnJrIjoi4o60IiwiVGNhcm9uIjoixaQiLCJ0Y2Fyb24iOiLFpSIsIlRjZWRpbCI6IsWiIiwidGNlZGlsIjoixaMiLCJUY3kiOiLQoiIsInRjeSI6ItGCIiwidGRvdCI6IuKDmyIsInRlbHJlYyI6IuKMlSIsIlRmciI6IvCdlJciLCJ0ZnIiOiLwnZSxIiwidGhlcmU0Ijoi4oi0IiwidGhlcmVmb3JlIjoi4oi0IiwiVGhlcmVmb3JlIjoi4oi0IiwiVGhldGEiOiLOmCIsInRoZXRhIjoizrgiLCJ0aGV0YXN5bSI6Is+RIiwidGhldGF2Ijoiz5EiLCJ0aGlja2FwcHJveCI6IuKJiCIsInRoaWNrc2ltIjoi4oi8IiwiVGhpY2tTcGFjZSI6IuKBn+KAiiIsIlRoaW5TcGFjZSI6IuKAiSIsInRoaW5zcCI6IuKAiSIsInRoa2FwIjoi4omIIiwidGhrc2ltIjoi4oi8IiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aWxkZSI6IsucIiwiVGlsZGUiOiLiiLwiLCJUaWxkZUVxdWFsIjoi4omDIiwiVGlsZGVGdWxsRXF1YWwiOiLiiYUiLCJUaWxkZVRpbGRlIjoi4omIIiwidGltZXNiYXIiOiLiqLEiLCJ0aW1lc2IiOiLiiqAiLCJ0aW1lcyI6IsOXIiwidGltZXNkIjoi4qiwIiwidGludCI6IuKIrSIsInRvZWEiOiLipKgiLCJ0b3Bib3QiOiLijLYiLCJ0b3BjaXIiOiLiq7EiLCJ0b3AiOiLiiqQiLCJUb3BmIjoi8J2ViyIsInRvcGYiOiLwnZWlIiwidG9wZm9yayI6IuKrmiIsInRvc2EiOiLipKkiLCJ0cHJpbWUiOiLigLQiLCJ0cmFkZSI6IuKEoiIsIlRSQURFIjoi4oSiIiwidHJpYW5nbGUiOiLilrUiLCJ0cmlhbmdsZWRvd24iOiLilr8iLCJ0cmlhbmdsZWxlZnQiOiLil4MiLCJ0cmlhbmdsZWxlZnRlcSI6IuKKtCIsInRyaWFuZ2xlcSI6IuKJnCIsInRyaWFuZ2xlcmlnaHQiOiLilrkiLCJ0cmlhbmdsZXJpZ2h0ZXEiOiLiirUiLCJ0cmlkb3QiOiLil6wiLCJ0cmllIjoi4omcIiwidHJpbWludXMiOiLiqLoiLCJUcmlwbGVEb3QiOiLig5siLCJ0cmlwbHVzIjoi4qi5IiwidHJpc2IiOiLip40iLCJ0cml0aW1lIjoi4qi7IiwidHJwZXppdW0iOiLij6IiLCJUc2NyIjoi8J2SryIsInRzY3IiOiLwnZOJIiwiVFNjeSI6ItCmIiwidHNjeSI6ItGGIiwiVFNIY3kiOiLQiyIsInRzaGN5Ijoi0ZsiLCJUc3Ryb2siOiLFpiIsInRzdHJvayI6IsWnIiwidHdpeHQiOiLiiawiLCJ0d29oZWFkbGVmdGFycm93Ijoi4oaeIiwidHdvaGVhZHJpZ2h0YXJyb3ciOiLihqAiLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwidWFyciI6IuKGkSIsIlVhcnIiOiLihp8iLCJ1QXJyIjoi4oeRIiwiVWFycm9jaXIiOiLipYkiLCJVYnJjeSI6ItCOIiwidWJyY3kiOiLRniIsIlVicmV2ZSI6IsWsIiwidWJyZXZlIjoixa0iLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVjeSI6ItCjIiwidWN5Ijoi0YMiLCJ1ZGFyciI6IuKHhSIsIlVkYmxhYyI6IsWwIiwidWRibGFjIjoixbEiLCJ1ZGhhciI6IuKlriIsInVmaXNodCI6IuKlviIsIlVmciI6IvCdlJgiLCJ1ZnIiOiLwnZSyIiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVIYXIiOiLipaMiLCJ1aGFybCI6IuKGvyIsInVoYXJyIjoi4oa+IiwidWhibGsiOiLiloAiLCJ1bGNvcm4iOiLijJwiLCJ1bGNvcm5lciI6IuKMnCIsInVsY3JvcCI6IuKMjyIsInVsdHJpIjoi4pe4IiwiVW1hY3IiOiLFqiIsInVtYWNyIjoixasiLCJ1bWwiOiLCqCIsIlVuZGVyQmFyIjoiXyIsIlVuZGVyQnJhY2UiOiLij58iLCJVbmRlckJyYWNrZXQiOiLijrUiLCJVbmRlclBhcmVudGhlc2lzIjoi4o+dIiwiVW5pb24iOiLii4MiLCJVbmlvblBsdXMiOiLiio4iLCJVb2dvbiI6IsWyIiwidW9nb24iOiLFsyIsIlVvcGYiOiLwnZWMIiwidW9wZiI6IvCdlaYiLCJVcEFycm93QmFyIjoi4qSSIiwidXBhcnJvdyI6IuKGkSIsIlVwQXJyb3ciOiLihpEiLCJVcGFycm93Ijoi4oeRIiwiVXBBcnJvd0Rvd25BcnJvdyI6IuKHhSIsInVwZG93bmFycm93Ijoi4oaVIiwiVXBEb3duQXJyb3ciOiLihpUiLCJVcGRvd25hcnJvdyI6IuKHlSIsIlVwRXF1aWxpYnJpdW0iOiLipa4iLCJ1cGhhcnBvb25sZWZ0Ijoi4oa/IiwidXBoYXJwb29ucmlnaHQiOiLihr4iLCJ1cGx1cyI6IuKKjiIsIlVwcGVyTGVmdEFycm93Ijoi4oaWIiwiVXBwZXJSaWdodEFycm93Ijoi4oaXIiwidXBzaSI6Is+FIiwiVXBzaSI6Is+SIiwidXBzaWgiOiLPkiIsIlVwc2lsb24iOiLOpSIsInVwc2lsb24iOiLPhSIsIlVwVGVlQXJyb3ciOiLihqUiLCJVcFRlZSI6IuKKpSIsInVwdXBhcnJvd3MiOiLih4giLCJ1cmNvcm4iOiLijJ0iLCJ1cmNvcm5lciI6IuKMnSIsInVyY3JvcCI6IuKMjiIsIlVyaW5nIjoixa4iLCJ1cmluZyI6IsWvIiwidXJ0cmkiOiLil7kiLCJVc2NyIjoi8J2SsCIsInVzY3IiOiLwnZOKIiwidXRkb3QiOiLii7AiLCJVdGlsZGUiOiLFqCIsInV0aWxkZSI6IsWpIiwidXRyaSI6IuKWtSIsInV0cmlmIjoi4pa0IiwidXVhcnIiOiLih4giLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJ1d2FuZ2xlIjoi4qanIiwidmFuZ3J0Ijoi4qacIiwidmFyZXBzaWxvbiI6Is+1IiwidmFya2FwcGEiOiLPsCIsInZhcm5vdGhpbmciOiLiiIUiLCJ2YXJwaGkiOiLPlSIsInZhcnBpIjoiz5YiLCJ2YXJwcm9wdG8iOiLiiJ0iLCJ2YXJyIjoi4oaVIiwidkFyciI6IuKHlSIsInZhcnJobyI6Is+xIiwidmFyc2lnbWEiOiLPgiIsInZhcnN1YnNldG5lcSI6IuKKiu+4gCIsInZhcnN1YnNldG5lcXEiOiLiq4vvuIAiLCJ2YXJzdXBzZXRuZXEiOiLiiovvuIAiLCJ2YXJzdXBzZXRuZXFxIjoi4quM77iAIiwidmFydGhldGEiOiLPkSIsInZhcnRyaWFuZ2xlbGVmdCI6IuKKsiIsInZhcnRyaWFuZ2xlcmlnaHQiOiLiirMiLCJ2QmFyIjoi4quoIiwiVmJhciI6IuKrqyIsInZCYXJ2Ijoi4qupIiwiVmN5Ijoi0JIiLCJ2Y3kiOiLQsiIsInZkYXNoIjoi4oqiIiwidkRhc2giOiLiiqgiLCJWZGFzaCI6IuKKqSIsIlZEYXNoIjoi4oqrIiwiVmRhc2hsIjoi4qumIiwidmVlYmFyIjoi4oq7IiwidmVlIjoi4oioIiwiVmVlIjoi4ouBIiwidmVlZXEiOiLiiZoiLCJ2ZWxsaXAiOiLii64iLCJ2ZXJiYXIiOiJ8IiwiVmVyYmFyIjoi4oCWIiwidmVydCI6InwiLCJWZXJ0Ijoi4oCWIiwiVmVydGljYWxCYXIiOiLiiKMiLCJWZXJ0aWNhbExpbmUiOiJ8IiwiVmVydGljYWxTZXBhcmF0b3IiOiLinZgiLCJWZXJ0aWNhbFRpbGRlIjoi4omAIiwiVmVyeVRoaW5TcGFjZSI6IuKAiiIsIlZmciI6IvCdlJkiLCJ2ZnIiOiLwnZSzIiwidmx0cmkiOiLiirIiLCJ2bnN1YiI6IuKKguKDkiIsInZuc3VwIjoi4oqD4oOSIiwiVm9wZiI6IvCdlY0iLCJ2b3BmIjoi8J2VpyIsInZwcm9wIjoi4oidIiwidnJ0cmkiOiLiirMiLCJWc2NyIjoi8J2SsSIsInZzY3IiOiLwnZOLIiwidnN1Ym5FIjoi4quL77iAIiwidnN1Ym5lIjoi4oqK77iAIiwidnN1cG5FIjoi4quM77iAIiwidnN1cG5lIjoi4oqL77iAIiwiVnZkYXNoIjoi4oqqIiwidnppZ3phZyI6IuKmmiIsIldjaXJjIjoixbQiLCJ3Y2lyYyI6IsW1Iiwid2VkYmFyIjoi4qmfIiwid2VkZ2UiOiLiiKciLCJXZWRnZSI6IuKLgCIsIndlZGdlcSI6IuKJmSIsIndlaWVycCI6IuKEmCIsIldmciI6IvCdlJoiLCJ3ZnIiOiLwnZS0IiwiV29wZiI6IvCdlY4iLCJ3b3BmIjoi8J2VqCIsIndwIjoi4oSYIiwid3IiOiLiiYAiLCJ3cmVhdGgiOiLiiYAiLCJXc2NyIjoi8J2SsiIsIndzY3IiOiLwnZOMIiwieGNhcCI6IuKLgiIsInhjaXJjIjoi4pevIiwieGN1cCI6IuKLgyIsInhkdHJpIjoi4pa9IiwiWGZyIjoi8J2UmyIsInhmciI6IvCdlLUiLCJ4aGFyciI6IuKftyIsInhoQXJyIjoi4p+6IiwiWGkiOiLOniIsInhpIjoizr4iLCJ4bGFyciI6IuKftSIsInhsQXJyIjoi4p+4IiwieG1hcCI6IuKfvCIsInhuaXMiOiLii7siLCJ4b2RvdCI6IuKogCIsIlhvcGYiOiLwnZWPIiwieG9wZiI6IvCdlakiLCJ4b3BsdXMiOiLiqIEiLCJ4b3RpbWUiOiLiqIIiLCJ4cmFyciI6IuKftiIsInhyQXJyIjoi4p+5IiwiWHNjciI6IvCdkrMiLCJ4c2NyIjoi8J2TjSIsInhzcWN1cCI6IuKohiIsInh1cGx1cyI6IuKohCIsInh1dHJpIjoi4pazIiwieHZlZSI6IuKLgSIsInh3ZWRnZSI6IuKLgCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJZQWN5Ijoi0K8iLCJ5YWN5Ijoi0Y8iLCJZY2lyYyI6IsW2IiwieWNpcmMiOiLFtyIsIlljeSI6ItCrIiwieWN5Ijoi0YsiLCJ5ZW4iOiLCpSIsIllmciI6IvCdlJwiLCJ5ZnIiOiLwnZS2IiwiWUljeSI6ItCHIiwieWljeSI6ItGXIiwiWW9wZiI6IvCdlZAiLCJ5b3BmIjoi8J2VqiIsIllzY3IiOiLwnZK0IiwieXNjciI6IvCdk44iLCJZVWN5Ijoi0K4iLCJ5dWN5Ijoi0Y4iLCJ5dW1sIjoiw78iLCJZdW1sIjoixbgiLCJaYWN1dGUiOiLFuSIsInphY3V0ZSI6IsW6IiwiWmNhcm9uIjoixb0iLCJ6Y2Fyb24iOiLFviIsIlpjeSI6ItCXIiwiemN5Ijoi0LciLCJaZG90IjoixbsiLCJ6ZG90IjoixbwiLCJ6ZWV0cmYiOiLihKgiLCJaZXJvV2lkdGhTcGFjZSI6IuKAiyIsIlpldGEiOiLOliIsInpldGEiOiLOtiIsInpmciI6IvCdlLciLCJaZnIiOiLihKgiLCJaSGN5Ijoi0JYiLCJ6aGN5Ijoi0LYiLCJ6aWdyYXJyIjoi4oedIiwiem9wZiI6IvCdlasiLCJab3BmIjoi4oSkIiwiWnNjciI6IvCdkrUiLCJ6c2NyIjoi8J2TjyIsInp3aiI6IuKAjSIsInp3bmoiOiLigIwifScpfSxmdW5jdGlvbihoKXtoLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJicnZiYXIiOiLCpiIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJjZWRpbCI6IsK4IiwiY2VudCI6IsKiIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY3VycmVuIjoiwqQiLCJkZWciOiLCsCIsImRpdmlkZSI6IsO3IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJmcmFjMTIiOiLCvSIsImZyYWMxNCI6IsK8IiwiZnJhYzM0Ijoiwr4iLCJndCI6Ij4iLCJHVCI6Ij4iLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJpZXhjbCI6IsKhIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlxdWVzdCI6IsK/IiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwibGFxdW8iOiLCqyIsImx0IjoiPCIsIkxUIjoiPCIsIm1hY3IiOiLCryIsIm1pY3JvIjoiwrUiLCJtaWRkb3QiOiLCtyIsIm5ic3AiOiLCoCIsIm5vdCI6IsKsIiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4IiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsInBhcmEiOiLCtiIsInBsdXNtbiI6IsKxIiwicG91bmQiOiLCoyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwicmFxdW8iOiLCuyIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJzZWN0IjoiwqciLCJzaHkiOiLCrSIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN6bGlnIjoiw58iLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbWVzIjoiw5ciLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidW1sIjoiwqgiLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwieWVuIjoiwqUiLCJ5dW1sIjoiw78ifScpfSxmdW5jdGlvbihoKXtoLmV4cG9ydHM9SlNPTi5wYXJzZShgeyJhbXAiOiImIiwiYXBvcyI6IiciLCJndCI6Ij4iLCJsdCI6IjwiLCJxdW90IjoiXFwiIn1gKX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihnKXtyZXR1cm4gZyYmZy5fX2VzTW9kdWxlP2c6e2RlZmF1bHQ6Z319O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbj1yKHQoMjY1KSk7ZnVuY3Rpb24gZChnKXtpZihnPj01NTI5NiYmZzw9NTczNDN8fGc+MTExNDExMSlyZXR1cm4i77+9IjtnIGluIG4uZGVmYXVsdCYmKGc9bi5kZWZhdWx0W2ddKTt2YXIgdT0iIjtyZXR1cm4gZz42NTUzNSYmKGctPTY1NTM2LHUrPVN0cmluZy5mcm9tQ2hhckNvZGUoZz4+PjEwJjEwMjN8NTUyOTYpLGc9NTYzMjB8ZyYxMDIzKSx1Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpLHV9ZS5kZWZhdWx0PWR9LGZ1bmN0aW9uKGgpe2guZXhwb3J0cz1KU09OLnBhcnNlKCd7IjAiOjY1NTMzLCIxMjgiOjgzNjQsIjEzMCI6ODIxOCwiMTMxIjo0MDIsIjEzMiI6ODIyMiwiMTMzIjo4MjMwLCIxMzQiOjgyMjQsIjEzNSI6ODIyNSwiMTM2Ijo3MTAsIjEzNyI6ODI0MCwiMTM4IjozNTIsIjEzOSI6ODI0OSwiMTQwIjozMzgsIjE0MiI6MzgxLCIxNDUiOjgyMTYsIjE0NiI6ODIxNywiMTQ3Ijo4MjIwLCIxNDgiOjgyMjEsIjE0OSI6ODIyNiwiMTUwIjo4MjExLCIxNTEiOjgyMTIsIjE1MiI6NzMyLCIxNTMiOjg0ODIsIjE1NCI6MzUzLCIxNTUiOjgyNTAsIjE1NiI6MzM5LCIxNTgiOjM4MiwiMTU5IjozNzZ9Jyl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oTSl7cmV0dXJuIE0mJk0uX19lc01vZHVsZT9NOntkZWZhdWx0Ok19fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lc2NhcGU9ZS5lbmNvZGVIVE1MPWUuZW5jb2RlWE1MPXZvaWQgMDt2YXIgbj1yKHQoMjYzKSksZD1wKG4uZGVmYXVsdCksZz1sKGQpO2UuZW5jb2RlWE1MPWIoZCxnKTt2YXIgdT1yKHQoMjYxKSksbz1wKHUuZGVmYXVsdCksYz1sKG8pO2UuZW5jb2RlSFRNTD1iKG8sYyk7ZnVuY3Rpb24gcChNKXtyZXR1cm4gT2JqZWN0LmtleXMoTSkuc29ydCgpLnJlZHVjZShmdW5jdGlvbihpLGEpe3JldHVybiBpW01bYV1dPSImIithKyI7IixpfSx7fSl9ZnVuY3Rpb24gbChNKXtmb3IodmFyIGk9W10sYT1bXSxzPTAsZj1PYmplY3Qua2V5cyhNKTtzPGYubGVuZ3RoO3MrKyl7dmFyIE89ZltzXTtPLmxlbmd0aD09PTE/aS5wdXNoKCJcXCIrTyk6YS5wdXNoKE8pfWkuc29ydCgpO2Zvcih2YXIgQT0wO0E8aS5sZW5ndGgtMTtBKyspe2Zvcih2YXIgUj1BO1I8aS5sZW5ndGgtMSYmaVtSXS5jaGFyQ29kZUF0KDEpKzE9PT1pW1IrMV0uY2hhckNvZGVBdCgxKTspUis9MTt2YXIgST0xK1ItQTtJPDN8fGkuc3BsaWNlKEEsSSxpW0FdKyItIitpW1JdKX1yZXR1cm4gYS51bnNoaWZ0KCJbIitpLmpvaW4oIiIpKyJdIiksbmV3IFJlZ0V4cChhLmpvaW4oInwiKSwiZyIpfXZhciB5PS8oPzpbXHg4MC1cdUQ3RkZcdUUwMDAtXHVGRkZGXXxbXHVEODAwLVx1REJGRl1bXHVEQzAwLVx1REZGRl18W1x1RDgwMC1cdURCRkZdKD8hW1x1REMwMC1cdURGRkZdKXwoPzpbXlx1RDgwMC1cdURCRkZdfF4pW1x1REMwMC1cdURGRkZdKS9nO2Z1bmN0aW9uIHgoTSl7cmV0dXJuIiYjeCIrTS5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSsiOyJ9ZnVuY3Rpb24gYihNLGkpe3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKGksZnVuY3Rpb24ocyl7cmV0dXJuIE1bc119KS5yZXBsYWNlKHkseCl9fXZhciBFPWwoZCk7ZnVuY3Rpb24gdihNKXtyZXR1cm4gTS5yZXBsYWNlKEUseCkucmVwbGFjZSh5LHgpfWUuZXNjYXBlPXZ9LGZ1bmN0aW9uKGgpe2guZXhwb3J0cz1KU09OLnBhcnNlKCd7ImVsZW1lbnROYW1lcyI6eyJhbHRnbHlwaCI6ImFsdEdseXBoIiwiYWx0Z2x5cGhkZWYiOiJhbHRHbHlwaERlZiIsImFsdGdseXBoaXRlbSI6ImFsdEdseXBoSXRlbSIsImFuaW1hdGVjb2xvciI6ImFuaW1hdGVDb2xvciIsImFuaW1hdGVtb3Rpb24iOiJhbmltYXRlTW90aW9uIiwiYW5pbWF0ZXRyYW5zZm9ybSI6ImFuaW1hdGVUcmFuc2Zvcm0iLCJjbGlwcGF0aCI6ImNsaXBQYXRoIiwiZmVibGVuZCI6ImZlQmxlbmQiLCJmZWNvbG9ybWF0cml4IjoiZmVDb2xvck1hdHJpeCIsImZlY29tcG9uZW50dHJhbnNmZXIiOiJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVjb21wb3NpdGUiOiJmZUNvbXBvc2l0ZSIsImZlY29udm9sdmVtYXRyaXgiOiJmZUNvbnZvbHZlTWF0cml4IiwiZmVkaWZmdXNlbGlnaHRpbmciOiJmZURpZmZ1c2VMaWdodGluZyIsImZlZGlzcGxhY2VtZW50bWFwIjoiZmVEaXNwbGFjZW1lbnRNYXAiLCJmZWRpc3RhbnRsaWdodCI6ImZlRGlzdGFudExpZ2h0IiwiZmVkcm9wc2hhZG93IjoiZmVEcm9wU2hhZG93IiwiZmVmbG9vZCI6ImZlRmxvb2QiLCJmZWZ1bmNhIjoiZmVGdW5jQSIsImZlZnVuY2IiOiJmZUZ1bmNCIiwiZmVmdW5jZyI6ImZlRnVuY0ciLCJmZWZ1bmNyIjoiZmVGdW5jUiIsImZlZ2F1c3NpYW5ibHVyIjoiZmVHYXVzc2lhbkJsdXIiLCJmZWltYWdlIjoiZmVJbWFnZSIsImZlbWVyZ2UiOiJmZU1lcmdlIiwiZmVtZXJnZW5vZGUiOiJmZU1lcmdlTm9kZSIsImZlbW9ycGhvbG9neSI6ImZlTW9ycGhvbG9neSIsImZlb2Zmc2V0IjoiZmVPZmZzZXQiLCJmZXBvaW50bGlnaHQiOiJmZVBvaW50TGlnaHQiLCJmZXNwZWN1bGFybGlnaHRpbmciOiJmZVNwZWN1bGFyTGlnaHRpbmciLCJmZXNwb3RsaWdodCI6ImZlU3BvdExpZ2h0IiwiZmV0aWxlIjoiZmVUaWxlIiwiZmV0dXJidWxlbmNlIjoiZmVUdXJidWxlbmNlIiwiZm9yZWlnbm9iamVjdCI6ImZvcmVpZ25PYmplY3QiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwibGluZWFyZ3JhZGllbnQiOiJsaW5lYXJHcmFkaWVudCIsInJhZGlhbGdyYWRpZW50IjoicmFkaWFsR3JhZGllbnQiLCJ0ZXh0cGF0aCI6InRleHRQYXRoIn0sImF0dHJpYnV0ZU5hbWVzIjp7ImRlZmluaXRpb251cmwiOiJkZWZpbml0aW9uVVJMIiwiYXR0cmlidXRlbmFtZSI6ImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGV0eXBlIjoiYXR0cmlidXRlVHlwZSIsImJhc2VmcmVxdWVuY3kiOiJiYXNlRnJlcXVlbmN5IiwiYmFzZXByb2ZpbGUiOiJiYXNlUHJvZmlsZSIsImNhbGNtb2RlIjoiY2FsY01vZGUiLCJjbGlwcGF0aHVuaXRzIjoiY2xpcFBhdGhVbml0cyIsImRpZmZ1c2Vjb25zdGFudCI6ImRpZmZ1c2VDb25zdGFudCIsImVkZ2Vtb2RlIjoiZWRnZU1vZGUiLCJmaWx0ZXJ1bml0cyI6ImZpbHRlclVuaXRzIiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImdyYWRpZW50dHJhbnNmb3JtIjoiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIjoiZ3JhZGllbnRVbml0cyIsImtlcm5lbG1hdHJpeCI6Imtlcm5lbE1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiOiJrZXJuZWxVbml0TGVuZ3RoIiwia2V5cG9pbnRzIjoia2V5UG9pbnRzIiwia2V5c3BsaW5lcyI6ImtleVNwbGluZXMiLCJrZXl0aW1lcyI6ImtleVRpbWVzIiwibGVuZ3RoYWRqdXN0IjoibGVuZ3RoQWRqdXN0IiwibGltaXRpbmdjb25lYW5nbGUiOiJsaW1pdGluZ0NvbmVBbmdsZSIsIm1hcmtlcmhlaWdodCI6Im1hcmtlckhlaWdodCIsIm1hcmtlcnVuaXRzIjoibWFya2VyVW5pdHMiLCJtYXJrZXJ3aWR0aCI6Im1hcmtlcldpZHRoIiwibWFza2NvbnRlbnR1bml0cyI6Im1hc2tDb250ZW50VW5pdHMiLCJtYXNrdW5pdHMiOiJtYXNrVW5pdHMiLCJudW1vY3RhdmVzIjoibnVtT2N0YXZlcyIsInBhdGhsZW5ndGgiOiJwYXRoTGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyI6InBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIjoicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm51bml0cyI6InBhdHRlcm5Vbml0cyIsInBvaW50c2F0eCI6InBvaW50c0F0WCIsInBvaW50c2F0eSI6InBvaW50c0F0WSIsInBvaW50c2F0eiI6InBvaW50c0F0WiIsInByZXNlcnZlYWxwaGEiOiJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyI6InByZXNlcnZlQXNwZWN0UmF0aW8iLCJwcmltaXRpdmV1bml0cyI6InByaW1pdGl2ZVVuaXRzIiwicmVmeCI6InJlZlgiLCJyZWZ5IjoicmVmWSIsInJlcGVhdGNvdW50IjoicmVwZWF0Q291bnQiLCJyZXBlYXRkdXIiOiJyZXBlYXREdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiOiJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIjoicmVxdWlyZWRGZWF0dXJlcyIsInNwZWN1bGFyY29uc3RhbnQiOiJzcGVjdWxhckNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCI6InNwZWN1bGFyRXhwb25lbnQiLCJzcHJlYWRtZXRob2QiOiJzcHJlYWRNZXRob2QiLCJzdGFydG9mZnNldCI6InN0YXJ0T2Zmc2V0Iiwic3RkZGV2aWF0aW9uIjoic3RkRGV2aWF0aW9uIiwic3RpdGNodGlsZXMiOiJzdGl0Y2hUaWxlcyIsInN1cmZhY2VzY2FsZSI6InN1cmZhY2VTY2FsZSIsInN5c3RlbWxhbmd1YWdlIjoic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyI6InRhYmxlVmFsdWVzIiwidGFyZ2V0eCI6InRhcmdldFgiLCJ0YXJnZXR5IjoidGFyZ2V0WSIsInRleHRsZW5ndGgiOiJ0ZXh0TGVuZ3RoIiwidmlld2JveCI6InZpZXdCb3giLCJ2aWV3dGFyZ2V0Ijoidmlld1RhcmdldCIsInhjaGFubmVsc2VsZWN0b3IiOiJ4Q2hhbm5lbFNlbGVjdG9yIiwieWNoYW5uZWxzZWxlY3RvciI6InlDaGFubmVsU2VsZWN0b3IiLCJ6b29tYW5kcGFuIjoiem9vbUFuZFBhbiJ9fScpfSxmdW5jdGlvbihoLGUpe3ZhciB0PWUuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24obil7cmV0dXJuIG4uY2hpbGRyZW59LHI9ZS5nZXRQYXJlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIG4ucGFyZW50fTtlLmdldFNpYmxpbmdzPWZ1bmN0aW9uKG4pe3ZhciBkPXIobik7cmV0dXJuIGQ/dChkKTpbbl19LGUuZ2V0QXR0cmlidXRlVmFsdWU9ZnVuY3Rpb24obixkKXtyZXR1cm4gbi5hdHRyaWJzJiZuLmF0dHJpYnNbZF19LGUuaGFzQXR0cmliPWZ1bmN0aW9uKG4sZCl7cmV0dXJuISFuLmF0dHJpYnMmJmhhc093blByb3BlcnR5LmNhbGwobi5hdHRyaWJzLGQpfSxlLmdldE5hbWU9ZnVuY3Rpb24obil7cmV0dXJuIG4ubmFtZX19LGZ1bmN0aW9uKGgsZSl7ZS5yZW1vdmVFbGVtZW50PWZ1bmN0aW9uKHQpe2lmKHQucHJldiYmKHQucHJldi5uZXh0PXQubmV4dCksdC5uZXh0JiYodC5uZXh0LnByZXY9dC5wcmV2KSx0LnBhcmVudCl7dmFyIHI9dC5wYXJlbnQuY2hpbGRyZW47ci5zcGxpY2Uoci5sYXN0SW5kZXhPZih0KSwxKX19LGUucmVwbGFjZUVsZW1lbnQ9ZnVuY3Rpb24odCxyKXt2YXIgbj1yLnByZXY9dC5wcmV2O24mJihuLm5leHQ9cik7dmFyIGQ9ci5uZXh0PXQubmV4dDtkJiYoZC5wcmV2PXIpO3ZhciBnPXIucGFyZW50PXQucGFyZW50O2lmKGcpe3ZhciB1PWcuY2hpbGRyZW47dVt1Lmxhc3RJbmRleE9mKHQpXT1yfX0sZS5hcHBlbmRDaGlsZD1mdW5jdGlvbih0LHIpe2lmKHIucGFyZW50PXQsdC5jaGlsZHJlbi5wdXNoKHIpIT09MSl7dmFyIG49dC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aC0yXTtuLm5leHQ9cixyLnByZXY9bixyLm5leHQ9bnVsbH19LGUuYXBwZW5kPWZ1bmN0aW9uKHQscil7dmFyIG49dC5wYXJlbnQsZD10Lm5leHQ7aWYoci5uZXh0PWQsci5wcmV2PXQsdC5uZXh0PXIsci5wYXJlbnQ9bixkKXtpZihkLnByZXY9cixuKXt2YXIgZz1uLmNoaWxkcmVuO2cuc3BsaWNlKGcubGFzdEluZGV4T2YoZCksMCxyKX19ZWxzZSBuJiZuLmNoaWxkcmVuLnB1c2gocil9LGUucHJlcGVuZD1mdW5jdGlvbih0LHIpe3ZhciBuPXQucGFyZW50O2lmKG4pe3ZhciBkPW4uY2hpbGRyZW47ZC5zcGxpY2UoZC5sYXN0SW5kZXhPZih0KSwwLHIpfXQucHJldiYmKHQucHJldi5uZXh0PXIpLHIucGFyZW50PW4sci5wcmV2PXQucHJldixyLm5leHQ9dCx0LnByZXY9cn19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDI1NikuaXNUYWc7aC5leHBvcnRzPXtmaWx0ZXI6bixmaW5kOmQsZmluZE9uZUNoaWxkOmcsZmluZE9uZTp1LGV4aXN0c09uZTpvLGZpbmRBbGw6Y307ZnVuY3Rpb24gbihwLGwseSx4KXtyZXR1cm4gQXJyYXkuaXNBcnJheShsKXx8KGw9W2xdKSwodHlwZW9mIHghPSJudW1iZXIifHwhaXNGaW5pdGUoeCkpJiYoeD0xLzApLGQocCxsLHkhPT0hMSx4KX1mdW5jdGlvbiBkKHAsbCx5LHgpe2Zvcih2YXIgYj1bXSxFLHY9MCxNPWwubGVuZ3RoO3Y8TSYmIShwKGxbdl0pJiYoYi5wdXNoKGxbdl0pLC0teDw9MCl8fChFPWxbdl0uY2hpbGRyZW4seSYmRSYmRS5sZW5ndGg+MCYmKEU9ZChwLEUseSx4KSxiPWIuY29uY2F0KEUpLHgtPUUubGVuZ3RoLHg8PTApKSk7disrKTtyZXR1cm4gYn1mdW5jdGlvbiBnKHAsbCl7Zm9yKHZhciB5PTAseD1sLmxlbmd0aDt5PHg7eSsrKWlmKHAobFt5XSkpcmV0dXJuIGxbeV07cmV0dXJuIG51bGx9ZnVuY3Rpb24gdShwLGwpe2Zvcih2YXIgeT1udWxsLHg9MCxiPWwubGVuZ3RoO3g8YiYmIXk7eCsrKWlmKHIobFt4XSkpcChsW3hdKT95PWxbeF06bFt4XS5jaGlsZHJlbi5sZW5ndGg+MCYmKHk9dShwLGxbeF0uY2hpbGRyZW4pKTtlbHNlIGNvbnRpbnVlO3JldHVybiB5fWZ1bmN0aW9uIG8ocCxsKXtmb3IodmFyIHk9MCx4PWwubGVuZ3RoO3k8eDt5KyspaWYocihsW3ldKSYmKHAobFt5XSl8fGxbeV0uY2hpbGRyZW4ubGVuZ3RoPjAmJm8ocCxsW3ldLmNoaWxkcmVuKSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gYyhwLGwpe2Zvcih2YXIgeT1bXSx4PWwuc2xpY2UoKTt4Lmxlbmd0aDspe3ZhciBiPXguc2hpZnQoKTtyKGIpJiYoYi5jaGlsZHJlbiYmYi5jaGlsZHJlbi5sZW5ndGg+MCYmeC51bnNoaWZ0LmFwcGx5KHgsYi5jaGlsZHJlbikscChiKSYmeS5wdXNoKGIpKX1yZXR1cm4geX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDI1Niksbj1lLmlzVGFnPXIuaXNUYWc7ZS50ZXN0RWxlbWVudD1mdW5jdGlvbihvLGMpe2Zvcih2YXIgcCBpbiBvKWlmKG8uaGFzT3duUHJvcGVydHkocCkpe2lmKHA9PT0idGFnX25hbWUiKXtpZighbihjKXx8IW8udGFnX25hbWUoYy5uYW1lKSlyZXR1cm4hMX1lbHNlIGlmKHA9PT0idGFnX3R5cGUiKXtpZighby50YWdfdHlwZShjLnR5cGUpKXJldHVybiExfWVsc2UgaWYocD09PSJ0YWdfY29udGFpbnMiKXtpZihuKGMpfHwhby50YWdfY29udGFpbnMoYy5kYXRhKSlyZXR1cm4hMX1lbHNlIGlmKCFjLmF0dHJpYnN8fCFvW3BdKGMuYXR0cmlic1twXSkpcmV0dXJuITF9cmV0dXJuITB9O3ZhciBkPXt0YWdfbmFtZTpmdW5jdGlvbihvKXtyZXR1cm4gdHlwZW9mIG89PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYyl7cmV0dXJuIG4oYykmJm8oYy5uYW1lKX06bz09PSIqIj9uOmZ1bmN0aW9uKGMpe3JldHVybiBuKGMpJiZjLm5hbWU9PT1vfX0sdGFnX3R5cGU6ZnVuY3Rpb24obyl7cmV0dXJuIHR5cGVvZiBvPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGMpe3JldHVybiBvKGMudHlwZSl9OmZ1bmN0aW9uKGMpe3JldHVybiBjLnR5cGU9PT1vfX0sdGFnX2NvbnRhaW5zOmZ1bmN0aW9uKG8pe3JldHVybiB0eXBlb2Ygbz09ImZ1bmN0aW9uIj9mdW5jdGlvbihjKXtyZXR1cm4hbihjKSYmbyhjLmRhdGEpfTpmdW5jdGlvbihjKXtyZXR1cm4hbihjKSYmYy5kYXRhPT09b319fTtmdW5jdGlvbiBnKG8sYyl7cmV0dXJuIHR5cGVvZiBjPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKHApe3JldHVybiBwLmF0dHJpYnMmJmMocC5hdHRyaWJzW29dKX06ZnVuY3Rpb24ocCl7cmV0dXJuIHAuYXR0cmlicyYmcC5hdHRyaWJzW29dPT09Y319ZnVuY3Rpb24gdShvLGMpe3JldHVybiBmdW5jdGlvbihwKXtyZXR1cm4gbyhwKXx8YyhwKX19ZS5nZXRFbGVtZW50cz1mdW5jdGlvbihvLGMscCxsKXt2YXIgeT1PYmplY3Qua2V5cyhvKS5tYXAoZnVuY3Rpb24oeCl7dmFyIGI9b1t4XTtyZXR1cm4geCBpbiBkP2RbeF0oYik6Zyh4LGIpfSk7cmV0dXJuIHkubGVuZ3RoPT09MD9bXTp0aGlzLmZpbHRlcih5LnJlZHVjZSh1KSxjLHAsbCl9LGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24obyxjLHApe3JldHVybiBBcnJheS5pc0FycmF5KGMpfHwoYz1bY10pLHRoaXMuZmluZE9uZShnKCJpZCIsbyksYyxwIT09ITEpfSxlLmdldEVsZW1lbnRzQnlUYWdOYW1lPWZ1bmN0aW9uKG8sYyxwLGwpe3JldHVybiB0aGlzLmZpbHRlcihkLnRhZ19uYW1lKG8pLGMscCxsKX0sZS5nZXRFbGVtZW50c0J5VGFnVHlwZT1mdW5jdGlvbihvLGMscCxsKXtyZXR1cm4gdGhpcy5maWx0ZXIoZC50YWdfdHlwZShvKSxjLHAsbCl9fSxmdW5jdGlvbihoLGUpe2UucmVtb3ZlU3Vic2V0cz1mdW5jdGlvbihuKXtmb3IodmFyIGQ9bi5sZW5ndGgsZyx1LG87LS1kPi0xOyl7Zm9yKGc9dT1uW2RdLG5bZF09bnVsbCxvPSEwO3U7KXtpZihuLmluZGV4T2YodSk+LTEpe289ITEsbi5zcGxpY2UoZCwxKTticmVha311PXUucGFyZW50fW8mJihuW2RdPWcpfXJldHVybiBufTt2YXIgdD17RElTQ09OTkVDVEVEOjEsUFJFQ0VESU5HOjIsRk9MTE9XSU5HOjQsQ09OVEFJTlM6OCxDT05UQUlORURfQlk6MTZ9LHI9ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj1mdW5jdGlvbihuLGQpe3ZhciBnPVtdLHU9W10sbyxjLHAsbCx5LHg7aWYobj09PWQpcmV0dXJuIDA7Zm9yKG89bjtvOylnLnVuc2hpZnQobyksbz1vLnBhcmVudDtmb3Iobz1kO287KXUudW5zaGlmdChvKSxvPW8ucGFyZW50O2Zvcih4PTA7Z1t4XT09PXVbeF07KXgrKztyZXR1cm4geD09PTA/dC5ESVNDT05ORUNURUQ6KGM9Z1t4LTFdLHA9Yy5jaGlsZHJlbixsPWdbeF0seT11W3hdLHAuaW5kZXhPZihsKT5wLmluZGV4T2YoeSk/Yz09PWQ/dC5GT0xMT1dJTkd8dC5DT05UQUlORURfQlk6dC5GT0xMT1dJTkc6Yz09PW4/dC5QUkVDRURJTkd8dC5DT05UQUlOUzp0LlBSRUNFRElORyl9O2UudW5pcXVlU29ydD1mdW5jdGlvbihuKXt2YXIgZD1uLmxlbmd0aCxnLHU7Zm9yKG49bi5zbGljZSgpOy0tZD4tMTspZz1uW2RdLHU9bi5pbmRleE9mKGcpLHU+LTEmJnU8ZCYmbi5zcGxpY2UoZCwxKTtyZXR1cm4gbi5zb3J0KGZ1bmN0aW9uKG8sYyl7dmFyIHA9cihvLGMpO3JldHVybiBwJnQuUFJFQ0VESU5HPy0xOnAmdC5GT0xMT1dJTkc/MTowfSksbn19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPXt0cnVlRnVuYzpmdW5jdGlvbigpe3JldHVybiEwfSxmYWxzZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMX19fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXk7dmFyIHI9dCgyNzUpLnBhcnNlLG49dCgyNzMpLGQ9dCgyNzgpLGc9dCgyNzkpLHU9dCgyODApLG89dCgyODIpLGM9bi50cnVlRnVuYyxwPW4uZmFsc2VGdW5jLGw9by5maWx0ZXJzO2Z1bmN0aW9uIHkoUCxMLEQpe3ZhciBDPWIoUCxMLEQpO3JldHVybiB4KEMsTCl9ZnVuY3Rpb24geChQLEwpe3ZhciBEPUwuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oUyl7cmV0dXJuIEQuaXNUYWcoUykmJlAoUyl9fWZ1bmN0aW9uIGIoUCxMLEQpe3ZhciBDPXIoUCxMKTtyZXR1cm4gZihDLEwsRCl9ZnVuY3Rpb24gRShQKXtyZXR1cm4gUC50eXBlPT09InBzZXVkbyImJihQLm5hbWU9PT0ic2NvcGUifHxBcnJheS5pc0FycmF5KFAuZGF0YSkmJlAuZGF0YS5zb21lKGZ1bmN0aW9uKEwpe3JldHVybiBMLnNvbWUoRSl9KSl9dmFyIHY9e3R5cGU6ImRlc2NlbmRhbnQifSxNPXt0eXBlOiJfZmxleGlibGVEZXNjZW5kYW50In0saT17dHlwZToicHNldWRvIixuYW1lOiJzY29wZSJ9LGE9e307ZnVuY3Rpb24gcyhQLEwsRCl7dmFyIEM9TC5hZGFwdGVyLFM9ISFEJiYhIUQubGVuZ3RoJiZELmV2ZXJ5KGZ1bmN0aW9uKEIpe3JldHVybiBCPT09YXx8ISFDLmdldFBhcmVudChCKX0pO1AuZm9yRWFjaChmdW5jdGlvbihCKXtpZighKEIubGVuZ3RoPjAmJk8oQlswXSkmJkJbMF0udHlwZSE9PSJkZXNjZW5kYW50IikpaWYoUyYmIShBcnJheS5pc0FycmF5KEIpP0Iuc29tZShFKTpFKEIpKSlCLnVuc2hpZnQodik7ZWxzZSByZXR1cm47Qi51bnNoaWZ0KGkpfSl9ZnVuY3Rpb24gZihQLEwsRCl7UD1QLmZpbHRlcihmdW5jdGlvbih3KXtyZXR1cm4gdy5sZW5ndGg+MH0pLFAuZm9yRWFjaChkKTt2YXIgQz1BcnJheS5pc0FycmF5KEQpO0Q9TCYmTC5jb250ZXh0fHxELEQmJiFDJiYoRD1bRF0pLHMoUCxMLEQpO3ZhciBTPSExLEI9UC5tYXAoZnVuY3Rpb24odyl7aWYod1swXSYmd1sxXSYmd1swXS5uYW1lPT09InNjb3BlIil7dmFyIEg9d1sxXS50eXBlO0MmJkg9PT0iZGVzY2VuZGFudCI/d1sxXT1NOihIPT09ImFkamFjZW50Inx8SD09PSJzaWJsaW5nIikmJihTPSEwKX1yZXR1cm4gQSh3LEwsRCl9KS5yZWR1Y2UoUixwKTtyZXR1cm4gQi5zaG91bGRUZXN0TmV4dFNpYmxpbmdzPVMsQn1mdW5jdGlvbiBPKFApe3JldHVybiBnW1AudHlwZV08MH1mdW5jdGlvbiBBKFAsTCxEKXtyZXR1cm4gUC5yZWR1Y2UoZnVuY3Rpb24oQyxTKXtpZihDPT09cClyZXR1cm4gQztpZighKFMudHlwZSBpbiB1KSl0aHJvdyBuZXcgRXJyb3IoIlJ1bGUgdHlwZSAiK1MudHlwZSsiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgY3NzLXNlbGVjdCIpO3JldHVybiB1W1MudHlwZV0oQyxTLEwsRCl9LEwmJkwucm9vdEZ1bmN8fGMpfWZ1bmN0aW9uIFIoUCxMKXtyZXR1cm4gTD09PXB8fFA9PT1jP1A6UD09PXB8fEw9PT1jP0w6ZnVuY3Rpb24oQyl7cmV0dXJuIFAoQyl8fEwoQyl9fWZ1bmN0aW9uIEkoUCl7cmV0dXJuIFAuc29tZShPKX1sLm5vdD1mdW5jdGlvbihQLEwsRCxDKXt2YXIgUz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCksYWRhcHRlcjpELmFkYXB0ZXJ9O2lmKFMuc3RyaWN0JiYoTC5sZW5ndGg+MXx8TC5zb21lKEkpKSl0aHJvdyBuZXcgRXJyb3IoImNvbXBsZXggc2VsZWN0b3JzIGluIDpub3QgYXJlbid0IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUiKTt2YXIgQj1mKEwsUyxDKTtyZXR1cm4gQj09PXA/UDpCPT09Yz9wOmZ1bmN0aW9uKEgpe3JldHVybiFCKEgpJiZQKEgpfX0sbC5oYXM9ZnVuY3Rpb24oUCxMLEQpe3ZhciBDPUQuYWRhcHRlcixTPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxhZGFwdGVyOkN9LEI9TC5zb21lKEkpP1thXTpudWxsLHc9ZihMLFMsQik7cmV0dXJuIHc9PT1wP3A6dz09PWM/ZnVuY3Rpb24oWil7cmV0dXJuIEMuZ2V0Q2hpbGRyZW4oWikuc29tZShDLmlzVGFnKSYmUChaKX06KHc9eCh3LEQpLEI/ZnVuY3Rpb24oWil7cmV0dXJuIFAoWikmJihCWzBdPVosQy5leGlzdHNPbmUodyxDLmdldENoaWxkcmVuKFopKSl9OmZ1bmN0aW9uKFope3JldHVybiBQKFopJiZDLmV4aXN0c09uZSh3LEMuZ2V0Q2hpbGRyZW4oWikpfSl9LGwubWF0Y2hlcz1mdW5jdGlvbihQLEwsRCxDKXt2YXIgUz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCkscm9vdEZ1bmM6UCxhZGFwdGVyOkQuYWRhcHRlcn07cmV0dXJuIGYoTCxTLEMpfSx5LmNvbXBpbGVUb2tlbj1mLHkuY29tcGlsZVVuc2FmZT1iLHkuUHNldWRvcz1vfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHUsbyxjLHApe3A9PT12b2lkIDAmJihwPWMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LHAse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG9bY119fSl9OmZ1bmN0aW9uKHUsbyxjLHApe3A9PT12b2lkIDAmJihwPWMpLHVbcF09b1tjXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKHUsbyl7Zm9yKHZhciBjIGluIHUpYyE9PSJkZWZhdWx0IiYmIW8uaGFzT3duUHJvcGVydHkoYykmJnIobyx1LGMpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksbih0KDI3NiksZSk7dmFyIGQ9dCgyNzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJwYXJzZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuZGVmYXVsdH19KTt2YXIgZz10KDI3Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInN0cmluZ2lmeSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGcuZGVmYXVsdH19KX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9RTt2YXIgcj0vXlteXFxdPyg/OlxcKD86W1xkYS1mXXsxLDZ9XHM/fC4pfFtcd1wtXHUwMGIwLVx1RkZGRl0pKy8sbj0vXFwoW1xkYS1mXXsxLDZ9XHM/fChccyl8LikvZ2ksZD0vXlxzKigoPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSspXHMqKD86KFxTPyk9XHMqKD86KFsnIl0pKFteXSo/KVwzfCgjPyg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKil8KXwpXHMqKGkpP1xdLyxnPXt1bmRlZmluZWQ6ImV4aXN0cyIsIiI6ImVxdWFscyIsIn4iOiJlbGVtZW50IiwiXiI6InN0YXJ0IiwkOiJlbmQiLCIqIjoiYW55IiwiISI6Im5vdCIsInwiOiJoeXBoZW4ifSx1PXsiPiI6ImNoaWxkIiwiPCI6InBhcmVudCIsIn4iOiJzaWJsaW5nIiwiKyI6ImFkamFjZW50In0sbz17IiMiOlsiaWQiLCJlcXVhbHMiXSwiLiI6WyJjbGFzcyIsImVsZW1lbnQiXX0sYz1uZXcgU2V0KFsiaGFzIiwibm90IiwibWF0Y2hlcyJdKSxwPW5ldyBTZXQoWyJjb250YWlucyIsImljb250YWlucyJdKSxsPW5ldyBTZXQoWyciJywiJyJdKTtmdW5jdGlvbiB5KGksYSxzKXt2YXIgZj1wYXJzZUludChhLDE2KS02NTUzNjtyZXR1cm4gZiE9PWZ8fHM/YTpmPDA/U3RyaW5nLmZyb21DaGFyQ29kZShmKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKGY+PjEwfDU1Mjk2LGYmMTAyM3w1NjMyMCl9ZnVuY3Rpb24geChpKXtyZXR1cm4gaS5yZXBsYWNlKG4seSl9ZnVuY3Rpb24gYihpKXtyZXR1cm4gaT09PSIgInx8aT09PWAKYHx8aT09PSIJInx8aT09PSJcZiJ8fGk9PT0iXHIifWZ1bmN0aW9uIEUoaSxhKXt2YXIgcz1bXTtpZihpPXYocywiIitpLGEpLGkhPT0iIil0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBzZWxlY3RvcjogIitpKTtyZXR1cm4gc31mdW5jdGlvbiB2KGksYSxzKXt2YXIgZj1bXSxPPSExO2Z1bmN0aW9uIEEoKXt2YXIgSj1hLm1hdGNoKHIpO2lmKCFKKXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbmFtZSwgZm91bmQgIithKTt2YXIgdHQ9SlswXTtyZXR1cm4gYT1hLnN1YnN0cih0dC5sZW5ndGgpLHgodHQpfWZ1bmN0aW9uIFIoSil7Zm9yKDtiKGEuY2hhckF0KEopKTspSisrO2E9YS5zdWJzdHIoSil9ZnVuY3Rpb24gSShKKXtmb3IodmFyIHR0PTA7YS5jaGFyQXQoLS1KKT09PSJcXCI7KXR0Kys7cmV0dXJuKHR0JjEpPT09MX1mb3IoUigwKTthIT09IiI7KXt2YXIgUD1hLmNoYXJBdCgwKTtpZihiKFApKU89ITAsUigxKTtlbHNlIGlmKFAgaW4gdSlmLnB1c2goe3R5cGU6dVtQXX0pLE89ITEsUigxKTtlbHNlIGlmKFA9PT0iLCIpe2lmKGYubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO2kucHVzaChmKSxmPVtdLE89ITEsUigxKX1lbHNlIGlmKE8mJihmLmxlbmd0aD4wJiZmLnB1c2goe3R5cGU6ImRlc2NlbmRhbnQifSksTz0hMSksUD09PSIqIilhPWEuc3Vic3RyKDEpLGYucHVzaCh7dHlwZToidW5pdmVyc2FsIn0pO2Vsc2UgaWYoUCBpbiBvKXt2YXIgTD1vW1BdLEQ9TFswXSxDPUxbMV07YT1hLnN1YnN0cigxKSxmLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpELGFjdGlvbjpDLHZhbHVlOkEoKSxpZ25vcmVDYXNlOiExfSl9ZWxzZSBpZihQPT09IlsiKXthPWEuc3Vic3RyKDEpO3ZhciBTPWEubWF0Y2goZCk7aWYoIVMpdGhyb3cgbmV3IEVycm9yKCJNYWxmb3JtZWQgYXR0cmlidXRlIHNlbGVjdG9yOiAiK2EpO2E9YS5zdWJzdHIoU1swXS5sZW5ndGgpO3ZhciBCPXgoU1sxXSk7KCFzfHwoImxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzImluIHM/cy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lczohcy54bWxNb2RlKSkmJihCPUIudG9Mb3dlckNhc2UoKSksZi5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6QixhY3Rpb246Z1tTWzJdXSx2YWx1ZTp4KFNbNF18fFNbNV18fCIiKSxpZ25vcmVDYXNlOiEhU1s2XX0pfWVsc2UgaWYoUD09PSI6Iil7aWYoYS5jaGFyQXQoMSk9PT0iOiIpe2E9YS5zdWJzdHIoMiksZi5wdXNoKHt0eXBlOiJwc2V1ZG8tZWxlbWVudCIsbmFtZTpBKCkudG9Mb3dlckNhc2UoKX0pO2NvbnRpbnVlfWE9YS5zdWJzdHIoMSk7dmFyIHc9QSgpLnRvTG93ZXJDYXNlKCksUz1udWxsO2lmKGEuY2hhckF0KDApPT09IigiKWlmKGMuaGFzKHcpKXt2YXIgSD1hLmNoYXJBdCgxKSxaPWwuaGFzKEgpO2lmKGE9YS5zdWJzdHIoWj8yOjEpLFM9W10sYT12KFMsYSxzKSxaKXtpZihhLmNoYXJBdCgwKSE9PUgpdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgcXVvdGVzIGluIDoiK3cpO2E9YS5zdWJzdHIoMSl9aWYoYS5jaGFyQXQoMCkhPT0iKSIpdGhyb3cgbmV3IEVycm9yKCJNaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMgaW4gOiIrdysiICgiK2ErIikiKTthPWEuc3Vic3RyKDEpfWVsc2V7Zm9yKHZhciBxPTEsVT0xO1U+MCYmcTxhLmxlbmd0aDtxKyspYS5jaGFyQXQocSk9PT0iKCImJiFJKHEpP1UrKzphLmNoYXJBdChxKT09PSIpIiYmIUkocSkmJlUtLTtpZihVKXRocm93IG5ldyBFcnJvcigiUGFyZW50aGVzaXMgbm90IG1hdGNoZWQiKTtpZihTPWEuc3Vic3RyKDEscS0yKSxhPWEuc3Vic3RyKHEpLHAuaGFzKHcpKXt2YXIgSD1TLmNoYXJBdCgwKTtIPT09Uy5zbGljZSgtMSkmJmwuaGFzKEgpJiYoUz1TLnNsaWNlKDEsLTEpKSxTPXgoUyl9fWYucHVzaCh7dHlwZToicHNldWRvIixuYW1lOncsZGF0YTpTfSl9ZWxzZSBpZihyLnRlc3QoYSkpe3ZhciBHPUEoKTsoIXN8fCgibG93ZXJDYXNlVGFncyJpbiBzP3MubG93ZXJDYXNlVGFnczohcy54bWxNb2RlKSkmJihHPUcudG9Mb3dlckNhc2UoKSksZi5wdXNoKHt0eXBlOiJ0YWciLG5hbWU6R30pfWVsc2UgcmV0dXJuIGYubGVuZ3RoJiZmW2YubGVuZ3RoLTFdLnR5cGU9PT0iZGVzY2VuZGFudCImJmYucG9wKCksTShpLGYpLGF9cmV0dXJuIE0oaSxmKSxhfWZ1bmN0aW9uIE0oaSxhKXtpZihpLmxlbmd0aD4wJiZhLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtpLnB1c2goYSl9fSxmdW5jdGlvbihoLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXtlcXVhbHM6IiIsZWxlbWVudDoifiIsc3RhcnQ6Il4iLGVuZDoiJCIsYW55OiIqIixub3Q6IiEiLGh5cGhlbjoifCJ9O2Z1bmN0aW9uIG4obyl7cmV0dXJuIG8ubWFwKGQpLmpvaW4oIiwgIil9ZS5kZWZhdWx0PW47ZnVuY3Rpb24gZChvKXtyZXR1cm4gby5tYXAoZykuam9pbigiIil9ZnVuY3Rpb24gZyhvKXtzd2l0Y2goby50eXBlKXtjYXNlImNoaWxkIjpyZXR1cm4iID4gIjtjYXNlInBhcmVudCI6cmV0dXJuIiA8ICI7Y2FzZSJzaWJsaW5nIjpyZXR1cm4iIH4gIjtjYXNlImFkamFjZW50IjpyZXR1cm4iICsgIjtjYXNlImRlc2NlbmRhbnQiOnJldHVybiIgIjtjYXNlInVuaXZlcnNhbCI6cmV0dXJuIioiO2Nhc2UidGFnIjpyZXR1cm4gby5uYW1lO2Nhc2UicHNldWRvLWVsZW1lbnQiOnJldHVybiI6OiIrby5uYW1lO2Nhc2UicHNldWRvIjpyZXR1cm4gby5kYXRhPT09bnVsbD8iOiIrby5uYW1lOnR5cGVvZiBvLmRhdGE9PSJzdHJpbmciPyI6IitvLm5hbWUrIigiK28uZGF0YSsiKSI6IjoiK28ubmFtZSsiKCIrbihvLmRhdGEpKyIpIjtjYXNlImF0dHJpYnV0ZSI6cmV0dXJuIG8uYWN0aW9uPT09ImV4aXN0cyI/IlsiK28ubmFtZSsiXSI6by5uYW1lPT09ImlkIiYmby5hY3Rpb249PT0iZXF1YWxzIiYmIW8uaWdub3JlQ2FzZT8iIyIrby52YWx1ZTpvLm5hbWU9PT0iY2xhc3MiJiZvLmFjdGlvbj09PSJlbGVtZW50IiYmIW8uaWdub3JlQ2FzZT8iLiIrby52YWx1ZToiWyIrby5uYW1lK3Jbby5hY3Rpb25dKyI9JyIrby52YWx1ZSsiJyIrKG8uaWdub3JlQ2FzZT8iaSI6IiIpKyJdIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5rbm93biB0eXBlIil9fWZ1bmN0aW9uIHUobyl7cmV0dXJuIG99fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPWQ7dmFyIHI9dCgyNzkpLG49e19fcHJvdG9fXzpudWxsLGV4aXN0czoxMCxlcXVhbHM6OCxub3Q6NyxzdGFydDo2LGVuZDo2LGFueTo1LGh5cGhlbjo0LGVsZW1lbnQ6NH07ZnVuY3Rpb24gZCh1KXtmb3IodmFyIG89dS5tYXAoZyksYz0xO2M8dS5sZW5ndGg7YysrKXt2YXIgcD1vW2NdO2lmKCEocDwwKSlmb3IodmFyIGw9Yy0xO2w+PTAmJnA8b1tsXTtsLS0pe3ZhciB5PXVbbCsxXTt1W2wrMV09dVtsXSx1W2xdPXksb1tsKzFdPW9bbF0sb1tsXT1wfX19ZnVuY3Rpb24gZyh1KXt2YXIgbz1yW3UudHlwZV07aWYobz09PXIuYXR0cmlidXRlKW89blt1LmFjdGlvbl0sbz09PW4uZXF1YWxzJiZ1Lm5hbWU9PT0iaWQiJiYobz05KSx1Lmlnbm9yZUNhc2UmJihvPj49MSk7ZWxzZSBpZihvPT09ci5wc2V1ZG8paWYoIXUuZGF0YSlvPTM7ZWxzZSBpZih1Lm5hbWU9PT0iaGFzInx8dS5uYW1lPT09ImNvbnRhaW5zIilvPTA7ZWxzZSBpZih1Lm5hbWU9PT0ibWF0Y2hlcyJ8fHUubmFtZT09PSJub3QiKXtvPTA7Zm9yKHZhciBjPTA7Yzx1LmRhdGEubGVuZ3RoO2MrKylpZih1LmRhdGFbY10ubGVuZ3RoPT09MSl7dmFyIHA9Zyh1LmRhdGFbY11bMF0pO2lmKHA9PT0wKXtvPTA7YnJlYWt9cD5vJiYobz1wKX11LmRhdGEubGVuZ3RoPjEmJm8+MCYmKG8tPTEpfWVsc2Ugbz0xO3JldHVybiBvfX0sZnVuY3Rpb24oaCl7aC5leHBvcnRzPUpTT04ucGFyc2UoJ3sidW5pdmVyc2FsIjo1MCwidGFnIjozMCwiYXR0cmlidXRlIjoxLCJwc2V1ZG8iOjAsImRlc2NlbmRhbnQiOi0xLCJjaGlsZCI6LTEsInBhcmVudCI6LTEsInNpYmxpbmciOi0xLCJhZGphY2VudCI6LTF9Jyl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDI4MSksbj10KDI4Mik7aC5leHBvcnRzPXtfX3Byb3RvX186bnVsbCxhdHRyaWJ1dGU6ci5jb21waWxlLHBzZXVkbzpuLmNvbXBpbGUsdGFnOmZ1bmN0aW9uKGQsZyx1KXt2YXIgbz1nLm5hbWUsYz11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGwpe3JldHVybiBjLmdldE5hbWUobCk9PT1vJiZkKGwpfX0sZGVzY2VuZGFudDpmdW5jdGlvbihkLGcsdSl7dmFyIG89dHlwZW9mIFdlYWtTZXQ8InUiP25ldyBXZWFrU2V0Om51bGwsYz11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGwpe2Zvcih2YXIgeT0hMTsheSYmKGw9Yy5nZXRQYXJlbnQobCkpOykoIW98fCFvLmhhcyhsKSkmJih5PWQobCksIXkmJm8mJm8uYWRkKGwpKTtyZXR1cm4geX19LF9mbGV4aWJsZURlc2NlbmRhbnQ6ZnVuY3Rpb24oZCxnLHUpe3ZhciBvPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24ocCl7Zm9yKHZhciBsPWQocCk7IWwmJihwPW8uZ2V0UGFyZW50KHApKTspbD1kKHApO3JldHVybiBsfX0scGFyZW50OmZ1bmN0aW9uKGQsZyx1KXtpZih1JiZ1LnN0cmljdCl0aHJvdyBuZXcgRXJyb3IoIlBhcmVudCBzZWxlY3RvciBpc24ndCBwYXJ0IG9mIENTUzMiKTt2YXIgbz11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGwpe3JldHVybiBvLmdldENoaWxkcmVuKGwpLnNvbWUoYyl9O2Z1bmN0aW9uIGMocCl7cmV0dXJuIG8uaXNUYWcocCkmJmQocCl9fSxjaGlsZDpmdW5jdGlvbihkLGcsdSl7dmFyIG89dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihwKXt2YXIgbD1vLmdldFBhcmVudChwKTtyZXR1cm4hIWwmJmQobCl9fSxzaWJsaW5nOmZ1bmN0aW9uKGQsZyx1KXt2YXIgbz11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHApe2Zvcih2YXIgbD1vLmdldFNpYmxpbmdzKHApLHk9MDt5PGwubGVuZ3RoO3krKylpZihvLmlzVGFnKGxbeV0pKXtpZihsW3ldPT09cClicmVhaztpZihkKGxbeV0pKXJldHVybiEwfXJldHVybiExfX0sYWRqYWNlbnQ6ZnVuY3Rpb24oZCxnLHUpe3ZhciBvPXUuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24ocCl7Zm9yKHZhciBsPW8uZ2V0U2libGluZ3MocCkseSx4PTA7eDxsLmxlbmd0aDt4KyspaWYoby5pc1RhZyhsW3hdKSl7aWYobFt4XT09PXApYnJlYWs7eT1sW3hdfXJldHVybiEheSYmZCh5KX19LHVuaXZlcnNhbDpmdW5jdGlvbihkKXtyZXR1cm4gZH19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgyNzMpLmZhbHNlRnVuYyxuPS9bLVtcXXt9KCkqKz8uLFxcXiR8I1xzXS9nLGQ9e19fcHJvdG9fXzpudWxsLGVxdWFsczpmdW5jdGlvbihnLHUsbyl7dmFyIGM9dS5uYW1lLHA9dS52YWx1ZSxsPW8uYWRhcHRlcjtyZXR1cm4gdS5pZ25vcmVDYXNlPyhwPXAudG9Mb3dlckNhc2UoKSxmdW5jdGlvbih4KXt2YXIgYj1sLmdldEF0dHJpYnV0ZVZhbHVlKHgsYyk7cmV0dXJuIGIhPW51bGwmJmIudG9Mb3dlckNhc2UoKT09PXAmJmcoeCl9KTpmdW5jdGlvbih4KXtyZXR1cm4gbC5nZXRBdHRyaWJ1dGVWYWx1ZSh4LGMpPT09cCYmZyh4KX19LGh5cGhlbjpmdW5jdGlvbihnLHUsbyl7dmFyIGM9dS5uYW1lLHA9dS52YWx1ZSxsPXAubGVuZ3RoLHk9by5hZGFwdGVyO3JldHVybiB1Lmlnbm9yZUNhc2U/KHA9cC50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKGIpe3ZhciBFPXkuZ2V0QXR0cmlidXRlVmFsdWUoYixjKTtyZXR1cm4gRSE9bnVsbCYmKEUubGVuZ3RoPT09bHx8RS5jaGFyQXQobCk9PT0iLSIpJiZFLnN1YnN0cigwLGwpLnRvTG93ZXJDYXNlKCk9PT1wJiZnKGIpfSk6ZnVuY3Rpb24oYil7dmFyIEU9eS5nZXRBdHRyaWJ1dGVWYWx1ZShiLGMpO3JldHVybiBFIT1udWxsJiZFLnN1YnN0cigwLGwpPT09cCYmKEUubGVuZ3RoPT09bHx8RS5jaGFyQXQobCk9PT0iLSIpJiZnKGIpfX0sZWxlbWVudDpmdW5jdGlvbihnLHUsbyl7dmFyIGM9dS5uYW1lLHA9dS52YWx1ZSxsPW8uYWRhcHRlcjtpZigvXHMvLnRlc3QocCkpcmV0dXJuIHI7cD1wLnJlcGxhY2UobiwiXFwkJiIpO3ZhciB5PSIoPzpefFxccykiK3ArIig/OiR8XFxzKSIseD11Lmlnbm9yZUNhc2U/ImkiOiIiLGI9bmV3IFJlZ0V4cCh5LHgpO3JldHVybiBmdW5jdGlvbih2KXt2YXIgTT1sLmdldEF0dHJpYnV0ZVZhbHVlKHYsYyk7cmV0dXJuIE0hPW51bGwmJmIudGVzdChNKSYmZyh2KX19LGV4aXN0czpmdW5jdGlvbihnLHUsbyl7dmFyIGM9dS5uYW1lLHA9by5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih5KXtyZXR1cm4gcC5oYXNBdHRyaWIoeSxjKSYmZyh5KX19LHN0YXJ0OmZ1bmN0aW9uKGcsdSxvKXt2YXIgYz11Lm5hbWUscD11LnZhbHVlLGw9cC5sZW5ndGgseT1vLmFkYXB0ZXI7cmV0dXJuIGw9PT0wP3I6dS5pZ25vcmVDYXNlPyhwPXAudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihiKXt2YXIgRT15LmdldEF0dHJpYnV0ZVZhbHVlKGIsYyk7cmV0dXJuIEUhPW51bGwmJkUuc3Vic3RyKDAsbCkudG9Mb3dlckNhc2UoKT09PXAmJmcoYil9KTpmdW5jdGlvbihiKXt2YXIgRT15LmdldEF0dHJpYnV0ZVZhbHVlKGIsYyk7cmV0dXJuIEUhPW51bGwmJkUuc3Vic3RyKDAsbCk9PT1wJiZnKGIpfX0sZW5kOmZ1bmN0aW9uKGcsdSxvKXt2YXIgYz11Lm5hbWUscD11LnZhbHVlLGw9LXAubGVuZ3RoLHk9by5hZGFwdGVyO3JldHVybiBsPT09MD9yOnUuaWdub3JlQ2FzZT8ocD1wLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oYil7dmFyIEU9eS5nZXRBdHRyaWJ1dGVWYWx1ZShiLGMpO3JldHVybiBFIT1udWxsJiZFLnN1YnN0cihsKS50b0xvd2VyQ2FzZSgpPT09cCYmZyhiKX0pOmZ1bmN0aW9uKGIpe3ZhciBFPXkuZ2V0QXR0cmlidXRlVmFsdWUoYixjKTtyZXR1cm4gRSE9bnVsbCYmRS5zdWJzdHIobCk9PT1wJiZnKGIpfX0sYW55OmZ1bmN0aW9uKGcsdSxvKXt2YXIgYz11Lm5hbWUscD11LnZhbHVlLGw9by5hZGFwdGVyO2lmKHA9PT0iIilyZXR1cm4gcjtpZih1Lmlnbm9yZUNhc2Upe3ZhciB5PW5ldyBSZWdFeHAocC5yZXBsYWNlKG4sIlxcJCYiKSwiaSIpO3JldHVybiBmdW5jdGlvbihiKXt2YXIgRT1sLmdldEF0dHJpYnV0ZVZhbHVlKGIsYyk7cmV0dXJuIEUhPW51bGwmJnkudGVzdChFKSYmZyhiKX19cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBFPWwuZ2V0QXR0cmlidXRlVmFsdWUoYixjKTtyZXR1cm4gRSE9bnVsbCYmRS5pbmRleE9mKHApPj0wJiZnKGIpfX0sbm90OmZ1bmN0aW9uKGcsdSxvKXt2YXIgYz11Lm5hbWUscD11LnZhbHVlLGw9by5hZGFwdGVyO3JldHVybiBwPT09IiI/ZnVuY3Rpb24oeCl7cmV0dXJuISFsLmdldEF0dHJpYnV0ZVZhbHVlKHgsYykmJmcoeCl9OnUuaWdub3JlQ2FzZT8ocD1wLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oeCl7dmFyIGI9bC5nZXRBdHRyaWJ1dGVWYWx1ZSh4LGMpO3JldHVybiBiIT1udWxsJiZiLnRvTG93ZXJDYXNlKCkhPT1wJiZnKHgpfSk6ZnVuY3Rpb24oeCl7cmV0dXJuIGwuZ2V0QXR0cmlidXRlVmFsdWUoeCxjKSE9PXAmJmcoeCl9fX07aC5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKGcsdSxvKXtpZihvJiZvLnN0cmljdCYmKHUuaWdub3JlQ2FzZXx8dS5hY3Rpb249PT0ibm90IikpdGhyb3cgbmV3IEVycm9yKCJVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgc2VsZWN0b3IiKTtyZXR1cm4gZFt1LmFjdGlvbl0oZyx1LG8pfSxydWxlczpkfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjgzKSxuPXQoMjczKSxkPXQoMjgxKSxnPW4udHJ1ZUZ1bmMsdT1uLmZhbHNlRnVuYyxvPWQucnVsZXMuZXF1YWxzO2Z1bmN0aW9uIGMoTSxpKXt2YXIgYT17bmFtZTpNLHZhbHVlOml9O3JldHVybiBmdW5jdGlvbihmLE8sQSl7cmV0dXJuIG8oZixhLEEpfX1mdW5jdGlvbiBwKE0saSl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiEhaS5nZXRQYXJlbnQoYSkmJk0oYSl9fXZhciBsPXtjb250YWluczpmdW5jdGlvbihNLGksYSl7dmFyIHM9YS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihPKXtyZXR1cm4gTShPKSYmcy5nZXRUZXh0KE8pLmluZGV4T2YoaSk+PTB9fSxpY29udGFpbnM6ZnVuY3Rpb24oTSxpLGEpe3ZhciBzPWkudG9Mb3dlckNhc2UoKSxmPWEuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oQSl7cmV0dXJuIE0oQSkmJmYuZ2V0VGV4dChBKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yocyk+PTB9fSwibnRoLWNoaWxkIjpmdW5jdGlvbihNLGksYSl7dmFyIHM9cihpKSxmPWEuYWRhcHRlcjtyZXR1cm4gcz09PXU/czpzPT09Zz9wKE0sZik6ZnVuY3Rpb24oQSl7Zm9yKHZhciBSPWYuZ2V0U2libGluZ3MoQSksST0wLFA9MDtJPFIubGVuZ3RoO0krKylpZihmLmlzVGFnKFJbSV0pKXtpZihSW0ldPT09QSlicmVhaztQKyt9cmV0dXJuIHMoUCkmJk0oQSl9fSwibnRoLWxhc3QtY2hpbGQiOmZ1bmN0aW9uKE0saSxhKXt2YXIgcz1yKGkpLGY9YS5hZGFwdGVyO3JldHVybiBzPT09dT9zOnM9PT1nP3AoTSxmKTpmdW5jdGlvbihBKXtmb3IodmFyIFI9Zi5nZXRTaWJsaW5ncyhBKSxJPTAsUD1SLmxlbmd0aC0xO1A+PTA7UC0tKWlmKGYuaXNUYWcoUltQXSkpe2lmKFJbUF09PT1BKWJyZWFrO0krK31yZXR1cm4gcyhJKSYmTShBKX19LCJudGgtb2YtdHlwZSI6ZnVuY3Rpb24oTSxpLGEpe3ZhciBzPXIoaSksZj1hLmFkYXB0ZXI7cmV0dXJuIHM9PT11P3M6cz09PWc/cChNLGYpOmZ1bmN0aW9uKEEpe2Zvcih2YXIgUj1mLmdldFNpYmxpbmdzKEEpLEk9MCxQPTA7UDxSLmxlbmd0aDtQKyspaWYoZi5pc1RhZyhSW1BdKSl7aWYoUltQXT09PUEpYnJlYWs7Zi5nZXROYW1lKFJbUF0pPT09Zi5nZXROYW1lKEEpJiZJKyt9cmV0dXJuIHMoSSkmJk0oQSl9fSwibnRoLWxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24oTSxpLGEpe3ZhciBzPXIoaSksZj1hLmFkYXB0ZXI7cmV0dXJuIHM9PT11P3M6cz09PWc/cChNLGYpOmZ1bmN0aW9uKEEpe2Zvcih2YXIgUj1mLmdldFNpYmxpbmdzKEEpLEk9MCxQPVIubGVuZ3RoLTE7UD49MDtQLS0paWYoZi5pc1RhZyhSW1BdKSl7aWYoUltQXT09PUEpYnJlYWs7Zi5nZXROYW1lKFJbUF0pPT09Zi5nZXROYW1lKEEpJiZJKyt9cmV0dXJuIHMoSSkmJk0oQSl9fSxyb290OmZ1bmN0aW9uKE0saSxhKXt2YXIgcz1hLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiFzLmdldFBhcmVudChmKSYmTShmKX19LHNjb3BlOmZ1bmN0aW9uKE0saSxhLHMpe3ZhciBmPWEuYWRhcHRlcjtpZighc3x8cy5sZW5ndGg9PT0wKXJldHVybiBsLnJvb3QoTSxpLGEpO2Z1bmN0aW9uIE8oQSxSKXtyZXR1cm4gdHlwZW9mIGYuZXF1YWxzPT0iZnVuY3Rpb24iP2YuZXF1YWxzKEEsUik6QT09PVJ9cmV0dXJuIHMubGVuZ3RoPT09MT9mdW5jdGlvbihBKXtyZXR1cm4gTyhzWzBdLEEpJiZNKEEpfTpmdW5jdGlvbihBKXtyZXR1cm4gcy5pbmRleE9mKEEpPj0wJiZNKEEpfX0sY2hlY2tib3g6YygidHlwZSIsImNoZWNrYm94IiksZmlsZTpjKCJ0eXBlIiwiZmlsZSIpLHBhc3N3b3JkOmMoInR5cGUiLCJwYXNzd29yZCIpLHJhZGlvOmMoInR5cGUiLCJyYWRpbyIpLHJlc2V0OmMoInR5cGUiLCJyZXNldCIpLGltYWdlOmMoInR5cGUiLCJpbWFnZSIpLHN1Ym1pdDpjKCJ0eXBlIiwic3VibWl0IiksaG92ZXI6ZnVuY3Rpb24oTSxpLGEpe3ZhciBzPWEuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIHMuaXNIb3ZlcmVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKE8pe3JldHVybiBNKE8pJiZzLmlzSG92ZXJlZChPKX06dX0sdmlzaXRlZDpmdW5jdGlvbihNLGksYSl7dmFyIHM9YS5hZGFwdGVyO3JldHVybiB0eXBlb2Ygcy5pc1Zpc2l0ZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oTyl7cmV0dXJuIE0oTykmJnMuaXNWaXNpdGVkKE8pfTp1fSxhY3RpdmU6ZnVuY3Rpb24oTSxpLGEpe3ZhciBzPWEuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIHMuaXNBY3RpdmU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oTyl7cmV0dXJuIE0oTykmJnMuaXNBY3RpdmUoTyl9OnV9fTtmdW5jdGlvbiB5KE0saSl7Zm9yKHZhciBhPTA7TSYmYTxNLmxlbmd0aDthKyspaWYoaS5pc1RhZyhNW2FdKSlyZXR1cm4gTVthXX12YXIgeD17ZW1wdHk6ZnVuY3Rpb24oTSxpKXtyZXR1cm4haS5nZXRDaGlsZHJlbihNKS5zb21lKGZ1bmN0aW9uKGEpe3JldHVybiBpLmlzVGFnKGEpfHxhLnR5cGU9PT0idGV4dCJ9KX0sImZpcnN0LWNoaWxkIjpmdW5jdGlvbihNLGkpe3JldHVybiB5KGkuZ2V0U2libGluZ3MoTSksaSk9PT1NfSwibGFzdC1jaGlsZCI6ZnVuY3Rpb24oTSxpKXtmb3IodmFyIGE9aS5nZXRTaWJsaW5ncyhNKSxzPWEubGVuZ3RoLTE7cz49MDtzLS0pe2lmKGFbc109PT1NKXJldHVybiEwO2lmKGkuaXNUYWcoYVtzXSkpYnJlYWt9cmV0dXJuITF9LCJmaXJzdC1vZi10eXBlIjpmdW5jdGlvbihNLGkpe2Zvcih2YXIgYT1pLmdldFNpYmxpbmdzKE0pLHM9MDtzPGEubGVuZ3RoO3MrKylpZihpLmlzVGFnKGFbc10pKXtpZihhW3NdPT09TSlyZXR1cm4hMDtpZihpLmdldE5hbWUoYVtzXSk9PT1pLmdldE5hbWUoTSkpYnJlYWt9cmV0dXJuITF9LCJsYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKE0saSl7Zm9yKHZhciBhPWkuZ2V0U2libGluZ3MoTSkscz1hLmxlbmd0aC0xO3M+PTA7cy0tKWlmKGkuaXNUYWcoYVtzXSkpe2lmKGFbc109PT1NKXJldHVybiEwO2lmKGkuZ2V0TmFtZShhW3NdKT09PWkuZ2V0TmFtZShNKSlicmVha31yZXR1cm4hMX0sIm9ubHktb2YtdHlwZSI6ZnVuY3Rpb24oTSxpKXtmb3IodmFyIGE9aS5nZXRTaWJsaW5ncyhNKSxzPTAsZj1hLmxlbmd0aDtzPGY7cysrKWlmKGkuaXNUYWcoYVtzXSkpe2lmKGFbc109PT1NKWNvbnRpbnVlO2lmKGkuZ2V0TmFtZShhW3NdKT09PWkuZ2V0TmFtZShNKSlyZXR1cm4hMX1yZXR1cm4hMH0sIm9ubHktY2hpbGQiOmZ1bmN0aW9uKE0saSl7Zm9yKHZhciBhPWkuZ2V0U2libGluZ3MoTSkscz0wO3M8YS5sZW5ndGg7cysrKWlmKGkuaXNUYWcoYVtzXSkmJmFbc10hPT1NKXJldHVybiExO3JldHVybiEwfSxsaW5rOmZ1bmN0aW9uKE0saSl7cmV0dXJuIGkuaGFzQXR0cmliKE0sImhyZWYiKX0sc2VsZWN0ZWQ6ZnVuY3Rpb24oTSxpKXtpZihpLmhhc0F0dHJpYihNLCJzZWxlY3RlZCIpKXJldHVybiEwO2lmKGkuZ2V0TmFtZShNKSE9PSJvcHRpb24iKXJldHVybiExO3ZhciBhPWkuZ2V0UGFyZW50KE0pO2lmKCFhfHxpLmdldE5hbWUoYSkhPT0ic2VsZWN0Inx8aS5oYXNBdHRyaWIoYSwibXVsdGlwbGUiKSlyZXR1cm4hMTtmb3IodmFyIHM9aS5nZXRDaGlsZHJlbihhKSxmPSExLE89MDtPPHMubGVuZ3RoO08rKylpZihpLmlzVGFnKHNbT10pKWlmKHNbT109PT1NKWY9ITA7ZWxzZSBpZihmKXtpZihpLmhhc0F0dHJpYihzW09dLCJzZWxlY3RlZCIpKXJldHVybiExfWVsc2UgcmV0dXJuITE7cmV0dXJuIGZ9LGRpc2FibGVkOmZ1bmN0aW9uKE0saSl7cmV0dXJuIGkuaGFzQXR0cmliKE0sImRpc2FibGVkIil9LGVuYWJsZWQ6ZnVuY3Rpb24oTSxpKXtyZXR1cm4haS5oYXNBdHRyaWIoTSwiZGlzYWJsZWQiKX0sY2hlY2tlZDpmdW5jdGlvbihNLGkpe3JldHVybiBpLmhhc0F0dHJpYihNLCJjaGVja2VkIil8fHguc2VsZWN0ZWQoTSxpKX0scmVxdWlyZWQ6ZnVuY3Rpb24oTSxpKXtyZXR1cm4gaS5oYXNBdHRyaWIoTSwicmVxdWlyZWQiKX0sb3B0aW9uYWw6ZnVuY3Rpb24oTSxpKXtyZXR1cm4haS5oYXNBdHRyaWIoTSwicmVxdWlyZWQiKX0scGFyZW50OmZ1bmN0aW9uKE0saSl7cmV0dXJuIXguZW1wdHkoTSxpKX0saGVhZGVyOmIoWyJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiXSksYnV0dG9uOmZ1bmN0aW9uKE0saSl7dmFyIGE9aS5nZXROYW1lKE0pO3JldHVybiBhPT09ImJ1dHRvbiJ8fGE9PT0iaW5wdXQiJiZpLmdldEF0dHJpYnV0ZVZhbHVlKE0sInR5cGUiKT09PSJidXR0b24ifSxpbnB1dDpiKFsiaW5wdXQiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsImJ1dHRvbiJdKSx0ZXh0OmZ1bmN0aW9uKE0saSl7dmFyIGE7cmV0dXJuIGkuZ2V0TmFtZShNKT09PSJpbnB1dCImJighKGE9aS5nZXRBdHRyaWJ1dGVWYWx1ZShNLCJ0eXBlIikpfHxhLnRvTG93ZXJDYXNlKCk9PT0idGV4dCIpfX07ZnVuY3Rpb24gYihNKXtpZih0eXBlb2YgU2V0PCJ1Iil7dmFyIGk9bmV3IFNldChNKTtyZXR1cm4gZnVuY3Rpb24oYSxzKXtyZXR1cm4gaS5oYXMocy5nZXROYW1lKGEpKX19cmV0dXJuIGZ1bmN0aW9uKGEscyl7cmV0dXJuIE0uaW5kZXhPZihzLmdldE5hbWUoYSkpPj0wfX1mdW5jdGlvbiBFKE0saSxhKXtpZihhPT09bnVsbCl7aWYoTS5sZW5ndGg+MiYmaSE9PSJzY29wZSIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIraSsiIHJlcXVpcmVzIGFuIGFyZ3VtZW50Iil9ZWxzZSBpZihNLmxlbmd0aD09PTIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIraSsiIGRvZXNuJ3QgaGF2ZSBhbnkgYXJndW1lbnRzIil9dmFyIHY9L14oPzooPzpudGh8bGFzdHxmaXJzdHxvbmx5KS0oPzpjaGlsZHxvZi10eXBlKXxyb290fGVtcHR5fCg/OmVufGRpcylhYmxlZHxjaGVja2VkfG5vdCkkLztoLmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24oTSxpLGEscyl7dmFyIGY9aS5uYW1lLE89aS5kYXRhLEE9YS5hZGFwdGVyO2lmKGEmJmEuc3RyaWN0JiYhdi50ZXN0KGYpKXRocm93IG5ldyBFcnJvcigiOiIrZisiIGlzbid0IHBhcnQgb2YgQ1NTMyIpO2lmKHR5cGVvZiBsW2ZdPT0iZnVuY3Rpb24iKXJldHVybiBsW2ZdKE0sTyxhLHMpO2lmKHR5cGVvZiB4W2ZdPT0iZnVuY3Rpb24iKXt2YXIgUj14W2ZdO3JldHVybiBFKFIsZixPKSxSPT09dT9SOk09PT1nP2Z1bmN0aW9uKFApe3JldHVybiBSKFAsQSxPKX06ZnVuY3Rpb24oUCl7cmV0dXJuIFIoUCxBLE8pJiZNKFApfX1lbHNlIHRocm93IG5ldyBFcnJvcigidW5tYXRjaGVkIHBzZXVkby1jbGFzcyA6IitmKX0sZmlsdGVyczpsLHBzZXVkb3M6eH19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDI4NCksbj10KDI4NSk7aC5leHBvcnRzPWZ1bmN0aW9uKGcpe3JldHVybiBuKHIoZykpfSxoLmV4cG9ydHMucGFyc2U9cixoLmV4cG9ydHMuY29tcGlsZT1ufSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1yO3ZhciB0PS9eKFsrXC1dP1xkKm4pP1xzKig/OihbK1wtXT8pXHMqKFxkKykpPyQvO2Z1bmN0aW9uIHIobil7aWYobj1uLnRyaW0oKS50b0xvd2VyQ2FzZSgpLG49PT0iZXZlbiIpcmV0dXJuWzIsMF07aWYobj09PSJvZGQiKXJldHVyblsyLDFdO3ZhciBkPW4ubWF0Y2godCk7aWYoIWQpdGhyb3cgbmV3IFN5bnRheEVycm9yKCJuLXRoIHJ1bGUgY291bGRuJ3QgYmUgcGFyc2VkICgnIituKyInKSIpO3ZhciBnO3JldHVybiBkWzFdPyhnPXBhcnNlSW50KGRbMV0sMTApLGlzTmFOKGcpJiYoZFsxXS5jaGFyQXQoMCk9PT0iLSI/Zz0tMTpnPTEpKTpnPTAsW2csZFszXT9wYXJzZUludCgoZFsyXXx8IiIpK2RbM10sMTApOjBdfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz1nO3ZhciByPXQoMjczKSxuPXIudHJ1ZUZ1bmMsZD1yLmZhbHNlRnVuYztmdW5jdGlvbiBnKHUpe3ZhciBvPXVbMF0sYz11WzFdLTE7aWYoYzwwJiZvPD0wKXJldHVybiBkO2lmKG89PT0tMSlyZXR1cm4gZnVuY3Rpb24obCl7cmV0dXJuIGw8PWN9O2lmKG89PT0wKXJldHVybiBmdW5jdGlvbihsKXtyZXR1cm4gbD09PWN9O2lmKG89PT0xKXJldHVybiBjPDA/bjpmdW5jdGlvbihsKXtyZXR1cm4gbD49Y307dmFyIHA9YyVvO3JldHVybiBwPDAmJihwKz1vKSxvPjE/ZnVuY3Rpb24obCl7cmV0dXJuIGw+PWMmJmwlbz09PXB9OihvKj0tMSxmdW5jdGlvbihsKXtyZXR1cm4gbDw9YyYmbCVvPT09cH0pfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gT30pO3ZhciByPXQoMTIpLG49dCg3NCksZD10KDEpLGc9dCg2OCksdT10KDI1MCksbz10KDIxMyksYz10KDIxOCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHAoQSxSKXtpZihBPT1udWxsKXJldHVybnt9O3ZhciBJPWwoQSxSKSxQLEw7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhBKTtmb3IoTD0wO0w8RC5sZW5ndGg7TCsrKVA9RFtMXSwhKFIuaW5kZXhPZihQKT49MCkmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChBLFApJiYoSVtQXT1BW1BdKX1yZXR1cm4gSX1mdW5jdGlvbiBsKEEsUil7aWYoQT09bnVsbClyZXR1cm57fTt2YXIgST17fSxQPU9iamVjdC5rZXlzKEEpLEwsRDtmb3IoRD0wO0Q8UC5sZW5ndGg7RCsrKUw9UFtEXSwhKFIuaW5kZXhPZihMKT49MCkmJihJW0xdPUFbTF0pO3JldHVybiBJfWNvbnN0IHk9e2FudGlhbGlhczohMCxhdXRvUmVuZGVyOiEwLGFscGhhOiEwfSx4PVN5bWJvbCgiYXV0b1JlbmRlciIpLGI9U3ltYm9sKCJyZW5kZXJlciIpLEU9U3ltYm9sKCJ0aW1lbGluZSIpLHY9U3ltYm9sKCJwcmVwYXJlUmVuZGVyIiksTT1TeW1ib2woInRpY2tSZW5kZXIiKSxpPVN5bWJvbCgicGFzcyIpLGE9U3ltYm9sKCJmYm8iKSxzPVN5bWJvbCgidGlja2VycyIpLGY9U3ltYm9sKCJsYXllclRyYW5zZm9ybUludmVydCIpO2NsYXNzIE8gZXh0ZW5kcyB1LmRlZmF1bHR7Y29uc3RydWN0b3IoUj17fSl7aWYoc3VwZXIoKSwhUi5jYW52YXMpe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OkN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLFM9ci5FTlYuY3JlYXRlQ2FudmFzKEQsQyx7b2Zmc2NyZWVuOiEhUi5vZmZzY3JlZW4saWQ6Ui5pZCxleHRyYTpSLmV4dHJhfSk7Uy5zdHlsZSYmKFMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIiksUy5kYXRhc2V0JiYoUy5kYXRhc2V0LmxheWVySWQ9Ui5pZCksUy5jb250ZXh0VHlwZSYmKFIuY29udGV4dFR5cGU9Uy5jb250ZXh0VHlwZSksUi5jYW52YXM9U31jb25zdCBJPVIuY2FudmFzLFA9T2JqZWN0LmFzc2lnbih7fSx5LFIpO3RoaXNbeF09UC5hdXRvUmVuZGVyLGRlbGV0ZSBSLmF1dG9SZW5kZXI7Y29uc3QgTD1QLlJlbmRlcmVyfHxyLlJlbmRlcmVyO3RoaXNbYl09bmV3IEwoSSxQKSx0aGlzLm9wdGlvbnM9Uix0aGlzLmlkPVIuaWQsdGhpc1tpXT1bXSx0aGlzLnNldFJlc29sdXRpb24oSSksdGhpcy5jYW52YXM9SSx0aGlzW0VdPW5ldyBuLlRpbWVsaW5lLHRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGwsdGhpc1tmXT1udWxsfWdldCBhdXRvUmVuZGVyKCl7cmV0dXJuIHRoaXNbeF19Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucz90aGlzLnBhcmVudC5vcHRpb25zLmRpc3BsYXlSYXRpbzoxfWdldCBoZWlnaHQoKXtjb25zdHtoZWlnaHQ6Un09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIFIvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGdsKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcj90aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuZ2w6bnVsbH1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpc31nZXQgb2Zmc2NyZWVuKCl7cmV0dXJuISF0aGlzLm9wdGlvbnMub2Zmc2NyZWVufHx0aGlzLmNhbnZhcy5fb2Zmc2NyZWVufWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbaV19Z2V0IHByZXBhcmVSZW5kZXIoKXtyZXR1cm4gdGhpc1t2XT90aGlzW3ZdOlByb21pc2UucmVzb2x2ZSgpfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzW2JdfWdldCByZW5kZXJPZmZzZXQoKXtpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucyl7Y29uc3R7bGVmdDpSLHRvcDpJfT10aGlzLnBhcmVudC5vcHRpb25zO3JldHVybltSLEldfXJldHVyblt0aGlzLm9wdGlvbnMubGVmdHwwLHRoaXMub3B0aW9ucy50b3B8MF19Z2V0IHRpbWVsaW5lKCl7cmV0dXJuIHRoaXNbRV19Z2V0IHdpZHRoKCl7Y29uc3R7d2lkdGg6Un09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIFIvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3R7eDpSLHk6SX09dGhpcy5hdHRyaWJ1dGVzO3JldHVyblsxLDAsMCwxLFIsSV19Z2V0IGxheWVyVHJhbnNmb3JtSW52ZXJ0KCl7aWYodGhpc1tmXSlyZXR1cm4gdGhpc1tmXTtjb25zdCBSPXRoaXMudHJhbnNmb3JtTWF0cml4O3JldHVybiBSWzBdPT09MSYmUlsxXT09PTAmJlJbMl09PT0wJiZSWzNdPT09MSYmUls0XT09PTAmJlJbNV09PT0wP251bGw6KHRoaXNbZl09ZC5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLFIpLHRoaXNbZl0pfWZvcmNlQ29udGV4dExvc3MoKXtjb25zdCBSPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcjtpZihSKXtjb25zdCBJPVIuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9sb3NlX2NvbnRleHQiKTtpZihJKXJldHVybiBJLmxvc2VDb250ZXh0KCksITB9cmV0dXJuITF9YWRkUGFzcyh7dmVydGV4OlIsZnJhZ21lbnQ6SSxvcHRpb25zOlAsdW5pZm9ybXM6TH09e30pe2lmKHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcil7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Q309dGhpcy5nZXRSZXNvbHV0aW9uKCksUz10aGlzLnJlbmRlcmVyLmNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6UixmcmFnbWVudDpJLG9wdGlvbnM6UH0pLEI9bmV3IHIuRmlndXJlMkQ7Qi5yZWN0KDAsMCxEL3RoaXMuZGlzcGxheVJhdGlvLEMvdGhpcy5kaXNwbGF5UmF0aW8pO2NvbnN0IHc9bmV3IHIuTWVzaDJEKEIpO3JldHVybiB3LnNldFVuaWZvcm1zKEwpLHcuc2V0UHJvZ3JhbShTKSx0aGlzW2ldLnB1c2godyksdGhpcy5mb3JjZVVwZGF0ZSgpLHd9cmV0dXJuIG51bGx9ZGVsZXRlVGV4dHVyZShSKXtyZXR1cm4gT2JqZWN0KGMuZGVsZXRlVGV4dHVyZSkoUix0aGlzLnJlbmRlcmVyKX1kaXNwYXRjaFBvaW50ZXJFdmVudChSKXtjb25zdCBJPVIudHlwZTtpZihJPT09Im1vdXNlZG93biJ8fEk9PT0ibW91c2V1cCJ8fEk9PT0ibW91c2Vtb3ZlIil7Y29uc3QgUz10aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldDtpZihTKXtpZihTLmxheWVyPT09dGhpcylyZXR1cm4gUy5kaXNwYXRjaEV2ZW50KFIpLCEwO3RoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGx9fWxldCBQLEw7Y29uc3QgRD10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O2lmKEQpe1A9Ui54LEw9Ui55O2NvbnN0IFM9RCxCPVNbMF0qUCtTWzJdKkwrU1s0XSx3PVNbMV0qUCtTWzNdKkwrU1s1XTtkZWxldGUgUi54LGRlbGV0ZSBSLnksZGVsZXRlIFIubGF5ZXJYLGRlbGV0ZSBSLmxheWVyWSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSLHtsYXllclg6e3ZhbHVlOkIsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOncsY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpCLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6dyxjb25maWd1cmFibGU6ITB9fSl9Y29uc3QgQz1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChSKTtyZXR1cm4gRCYmT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUix7bGF5ZXJYOnt2YWx1ZTpQLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpMLGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6UCxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOkwsY29uZmlndXJhYmxlOiEwfX0pLEN9Zm9yY2VVcGRhdGUoKXtpZighdGhpc1t2XSlpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuaGFzT2Zmc2NyZWVuQ2FudmFzKXt0aGlzLnBhcmVudC5mb3JjZVVwZGF0ZSgpO2xldCBSPW51bGw7Y29uc3QgST1uZXcgUHJvbWlzZShQPT57Uj1QfSk7SS5fcmVzb2x2ZT1SLHRoaXNbdl09SX1lbHNle2xldCBSPW51bGwsST1udWxsO2NvbnN0IFA9bmV3IFByb21pc2UoTD0+e1I9TCx0aGlzW3hdJiYoST1PYmplY3QoZy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIFAuX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfSk7UC5fcmVzb2x2ZT1SLFAuX3JlcXVlc3RJRD1JLHRoaXNbdl09UH19Z2V0RkJPKCl7Y29uc3QgUj10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIse3dpZHRoOkksaGVpZ2h0OlB9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBSJiYoIXRoaXNbYV18fHRoaXNbYV0ud2lkdGghPT1JfHx0aGlzW2FdLmhlaWdodCE9PVApPyh0aGlzW2FdPXt3aWR0aDpJLGhlaWdodDpQLHRhcmdldDpSLmNyZWF0ZUZCTygpLGJ1ZmZlcjpSLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSx0aGlzW2FdKTp0aGlzW2FdP3RoaXNbYV06bnVsbH11cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBSPXRoaXMucmVuZGVyZXIsST1SLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxSLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtSLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PUk7Y29uc3QgUD1kLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO1Iuc2V0R2xvYmFsVHJhbnNmb3JtKC4uLmQubWF0MmQubXVsdGlwbHkoUCxJLHRoaXMudHJhbnNmb3JtTWF0cml4KSl9fW9uUHJvcGVydHlDaGFuZ2UoUixJLFApe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoUixJLFApLFI9PT0iekluZGV4IiYmKHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleD1JKSxSPT09InRyYW5zZm9ybSJ8fFI9PT0idHJhbnNsYXRlInx8Uj09PSJyb3RhdGUifHxSPT09InNjYWxlInx8Uj09PSJza2V3Iil7Y29uc3QgTD10aGlzW2ZdO2lmKHRoaXNbZl09bnVsbCx0aGlzLnVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpLEwmJiF0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBEPXRoaXMucmVuZGVyZXIsQz1ELl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxELmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtELnNldEdsb2JhbFRyYW5zZm9ybSguLi5DKX19fV9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKXt0aGlzW3ZdJiYodGhpc1t2XS5fcmVxdWVzdElEJiZPYmplY3QoZy5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1t2XS5fcmVxdWVzdElEKSx0aGlzW3ZdLl9yZXNvbHZlKCksZGVsZXRlIHRoaXNbdl0pfXJlbmRlcih7Y2xlYXI6Uj0hMH09e30pe2NvbnN0IEk9dGhpc1tpXS5sZW5ndGg/dGhpcy5nZXRGQk8oKTpudWxsO0kmJnRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5iaW5kRkJPKEkudGFyZ2V0KSxSJiZ0aGlzW2JdLmNsZWFyKCk7Y29uc3QgUD10aGlzLmRyYXcoKTtpZihQJiZQLmxlbmd0aCYmKHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhQKSx0aGlzLmNhbnZhcy5kcmF3JiZ0aGlzLmNhbnZhcy5kcmF3KCkpLEkpe2NvbnN0IEw9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLEQ9dGhpc1tpXS5sZW5ndGgse3dpZHRoOkMsaGVpZ2h0OlN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEI9WzAsMCxDL3RoaXMuZGlzcGxheVJhdGlvLFMvdGhpcy5kaXNwbGF5UmF0aW9dO3RoaXNbaV0uZm9yRWFjaCgodyxIKT0+e3cuYmxlbmQ9ITAsdy5zZXRUZXh0dXJlKEkudGFyZ2V0LnRleHR1cmUse3JlY3Q6Qn0pLEg9PT1ELTE/TC5iaW5kRkJPKG51bGwpOihJLnN3YXAoKSxMLmJpbmRGQk8oSS50YXJnZXQpKSx0aGlzW2JdLmNsZWFyKCksdGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKFt3XSl9KX10aGlzLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpSLGhlaWdodDpJfSl7Y29uc3QgUD10aGlzLnJlbmRlcmVyLEw9UC5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8UC5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgsRD1MWzRdLEM9TFs1XSxTPUxbMF0se3dpZHRoOkIsaGVpZ2h0Ond9PXRoaXMuZ2V0UmVzb2x1dGlvbigpOyhCIT09Unx8dyE9PUkpJiYoc3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6UixoZWlnaHQ6SX0pLHRoaXMuY2FudmFzJiYodGhpcy5jYW52YXMud2lkdGg9Uix0aGlzLmNhbnZhcy5oZWlnaHQ9SSxQLnVwZGF0ZVJlc29sdXRpb24mJlAudXBkYXRlUmVzb2x1dGlvbigpKSx0aGlzLmF0dHJpYnV0ZXMuc2l6ZT1bUixJXSx0aGlzW2ldLmxlbmd0aCYmdGhpc1tpXS5mb3JFYWNoKFU9Pntjb25zdCBHPW5ldyByLkZpZ3VyZTJEO0cucmVjdCgwLDAsUi90aGlzLmRpc3BsYXlSYXRpbyxJL3RoaXMuZGlzcGxheVJhdGlvKSxVLmNvbnRvdXJzPUcuY29udG91cnN9KSk7Y29uc3RbSCxaXT10aGlzLnJlbmRlck9mZnNldCxxPXRoaXMuZGlzcGxheVJhdGlvOyhEIT09SHx8QyE9PVp8fFMhPT1xKSYmKFAuc2V0R2xvYmFsVHJhbnNmb3JtKHEsMCwwLHEsSCxaKSxQLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PW51bGwsdGhpc1tmXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksdGhpcy5mb3JjZVVwZGF0ZSgpKX10aWNrKFI9bnVsbCxJPXt9KXtsZXR7ZHVyYXRpb246UD0xLzB9PUksTD1wKEksWyJkdXJhdGlvbiJdKTtjb25zdCBEPXRoaXMudGltZWxpbmUuZm9yayhMKSxDPXRoaXM7dGhpc1tzXT10aGlzW3NdfHxbXSx0aGlzW3NdLnB1c2goe2hhbmRsZXI6UixkdXJhdGlvbjpQfSk7Y29uc3QgUz0oKT0+e2xldCBCPW51bGwsdz1udWxsO2NvbnN0IEg9KCk9Pntjb25zdCBaPXRoaXNbc10ubWFwKCh7aGFuZGxlcjpxLGR1cmF0aW9uOlV9KT0+e2NvbnN0IEc9TWF0aC5taW4oMSxELmN1cnJlbnRUaW1lL1UpO3JldHVybnt2YWx1ZTpxP3EoRC5jdXJyZW50VGltZSxHKTpudWxsLHA6R319KTtDW01dfHwoQ1tNXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57Q1t4XSYmQy5yZW5kZXIoKSxkZWxldGUgQ1tNXTtmb3IobGV0IHE9Wi5sZW5ndGgtMTtxPj0wO3EtLSl7Y29uc3R7dmFsdWU6VSxwOkd9PVpbcV07KFU9PT0hMXx8Rz49MSkmJnRoaXNbc10uc3BsaWNlKHEsMSl9dGhpc1tzXS5sZW5ndGg+MCYmUygpfSkpfTtpZih0aGlzW3ZdJiZ0aGlzW3ZdLl90eXBlIT09InRpY2tlciImJihPYmplY3QoZy5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1t2XS5fcmVxdWVzdElEKSxkZWxldGUgdGhpc1t2XSksIXRoaXNbdl0pe2NvbnN0IFo9bmV3IFByb21pc2UocT0+e0I9cSx3PU9iamVjdChnLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoSCl9KTtaLl9yZXNvbHZlPUIsWi5fcmVxdWVzdElEPXcsWi5fdHlwZT0idGlja2VyIix0aGlzW3ZdPVp9fTtTKCl9dG9HbG9iYWxQb3MoUixJKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBCPXRoaXMudHJhbnNmb3JtTWF0cml4O1I9QlswXSpSK0JbMl0qSStCWzRdLEk9QlsxXSpSK0JbM10qSStCWzVdfWNvbnN0e3dpZHRoOlAsaGVpZ2h0Okx9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEQ9dGhpcy5yZW5kZXJPZmZzZXQsQz1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtSPVIqQ1swXS9QK0RbMF0sST1JKkNbMV0vTCtEWzFdO2NvbnN0IFM9dGhpcy5kaXNwbGF5UmF0aW87cmV0dXJuIFIqPVMsSSo9UyxbUixJXX10b0xvY2FsUG9zKFIsSSl7Y29uc3R7d2lkdGg6UCxoZWlnaHQ6TH09dGhpcy5nZXRSZXNvbHV0aW9uKCksRD10aGlzLnJlbmRlck9mZnNldCxDPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO1I9UipQL0NbMF0tRFswXSxJPUkqTC9DWzFdLURbMV07Y29uc3QgUz10aGlzLmRpc3BsYXlSYXRpbztSLz1TLEkvPVM7Y29uc3QgQj10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O3JldHVybiBCJiYoUj1CWzBdKlIrQlsyXSpJK0JbNF0sST1CWzFdKlIrQlszXSpJK0JbNV0pLFtSLEldfX1vLmRlZmF1bHQucmVnaXN0ZXJOb2RlKE8sImxheWVyIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDIyNCksbj10KDI4OCksZD10KDIxMyksZz10KDI1MiksdT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbyhNLGkpe2lmKE09PW51bGwpcmV0dXJue307dmFyIGE9YyhNLGkpLHMsZjtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgTz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE0pO2ZvcihmPTA7ZjxPLmxlbmd0aDtmKyspcz1PW2ZdLCEoaS5pbmRleE9mKHMpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKE0scykmJihhW3NdPU1bc10pfXJldHVybiBhfWZ1bmN0aW9uIGMoTSxpKXtpZihNPT1udWxsKXJldHVybnt9O3ZhciBhPXt9LHM9T2JqZWN0LmtleXMoTSksZixPO2ZvcihPPTA7TzxzLmxlbmd0aDtPKyspZj1zW09dLCEoaS5pbmRleE9mKGYpPj0wKSYmKGFbZl09TVtmXSk7cmV0dXJuIGF9ZnVuY3Rpb24gcChNLGksYSl7cmV0dXJuIGkgaW4gTT9PYmplY3QuZGVmaW5lUHJvcGVydHkoTSxpLHt2YWx1ZTphLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6TVtpXT1hLE19Y29uc3QgbD0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLHk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIikseD1TeW1ib2woInJvb3QiKSxiPVN5bWJvbCgidGFzayIpO2Z1bmN0aW9uIEUoTSxpPSEwKXtjb25zdCBhPU1beF07aWYoYSYmYS5jaGlsZHJlblswXSl7Y29uc3Qgcz1NLnN2ZyxmPU0ubGF5ZXI/TS5sYXllci5kaXNwbGF5UmF0aW86MTtpZighcy5oYXNBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSl7bGV0IFI9cy5nZXRBdHRyaWJ1dGUoIndpZHRoIik7Uj1SP09iamVjdCh1LnNpemVUb1BpeGVsKShSKTozMDA7bGV0IEk9cy5nZXRBdHRyaWJ1dGUoImhlaWdodCIpO0k9ST9PYmplY3QodS5zaXplVG9QaXhlbCkoSSk6MTUwLHMuaGFzQXR0cmlidXRlKCJ2aWV3Qm94Iil8fHMuc2V0QXR0cmlidXRlKCJ2aWV3Qm94IixgMCAwICR7TWF0aC5yb3VuZChSKX0gJHtNYXRoLnJvdW5kKEkpfWApLHMuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIixSKSxzLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiLEkpfWxldCBPPU0uYXR0cmlidXRlcy53aWR0aHx8TnVtYmVyKHMuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpLEE9TS5hdHRyaWJ1dGVzLmhlaWdodHx8TnVtYmVyKHMuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIpKTtpZihPKj1mLEEqPWYsaSYmTS5hdHRyaWJ1dGVzLmZsZXhpYmxlKXtjb25zdCBSPU0uYXR0cmlidXRlcy5zY2FsZVswXTtpZihPKj1SLEEqPVIscy5zZXRBdHRyaWJ1dGUoIndpZHRoIixPKSxzLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixBKSxPJiZBJiZNLnRleHR1cmVJbWFnZSl7Y29uc3QgST1NLnRleHR1cmVJbWFnZS53aWR0aCxQPU0udGV4dHVyZUltYWdlLmhlaWdodCxMPU0uY2xpZW50U2l6ZTtNLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9WzAsMCxNYXRoLnJvdW5kKExbMF0qSS9PKSxNYXRoLnJvdW5kKExbMV0qUC9BKV19fWVsc2UgTVtiXXx8KHMuc2V0QXR0cmlidXRlKCJ3aWR0aCIsTykscy5zZXRBdHRyaWJ1dGUoImhlaWdodCIsQSksTVtiXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57ZGVsZXRlIE1bYl07Y29uc3QgUj1hLmlubmVySFRNTCxJPW5ldyBCbG9iKFtSXSx7dHlwZToiaW1hZ2Uvc3ZnK3htbCJ9KSxQPVVSTC5jcmVhdGVPYmplY3RVUkwoSSksTD1uZXcgSW1hZ2U7TC5vbmxvYWQ9ZnVuY3Rpb24oKXtMLndpZHRoJiZMLmhlaWdodD8oTS5hdHRyaWJ1dGVzW3ldKCJ0ZXh0dXJlIixMKSxNLmF0dHJpYnV0ZXMuZmxleGlibGUmJihNLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9bnVsbCkpOk0uYXR0cmlidXRlc1t5XSgidGV4dHVyZSIsbnVsbCl9LEwuc3JjPVB9KSl9fWNsYXNzIHYgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoaT17fSl7dHlwZW9mIGk9PSJzdHJpbmciJiYoaT17c3ZnVGV4dDppfSk7bGV0e3N2Z1RleHQ6YX09aSxzPW8oaSxbInN2Z1RleHQiXSk7aWYoc3VwZXIocyksdGhpc1t4XT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxhKXt0aGlzW3hdLmlubmVySFRNTD1hO2NvbnN0IGY9dGhpc1t4XS5jaGlsZHJlblswXTtmP2Yuc2V0QXR0cmlidXRlKCJ4bWxucyIsbCk6KGZldGNoKGEpLnRoZW4oTz0+Ty50ZXh0KCkpLnRoZW4oTz0+e3RoaXNbeF0uaW5uZXJIVE1MPU8sKCF0aGlzLm9ic2VydmVyfHx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUpJiZFKHRoaXMpfSksYT1udWxsKX1pZighYSl7Y29uc3QgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobCwic3ZnIik7Zi5zZXRBdHRyaWJ1dGUoInhtbG5zIixsKSx0aGlzW3hdLmFwcGVuZENoaWxkKGYpfWlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPT0iZnVuY3Rpb24iKXtjb25zdCBmPW5ldyBNdXRhdGlvbk9ic2VydmVyKE89PntFKHRoaXMsITEpfSk7Zi5vYnNlcnZlKHRoaXNbeF0se2F0dHJpYnV0ZXM6ITAsc3VidHJlZTohMCxjaGFyYWN0ZXJEYXRhOiEwLGNoaWxkTGlzdDohMH0pLHRoaXMub2JzZXJ2ZXI9Zn19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgY2hpbGROb2Rlcygpe3JldHVyblt0aGlzLnN2Z119Z2V0IHN2Zygpe3JldHVybiB0aGlzW3hdP3RoaXNbeF0uY2hpbGRyZW5bMF06bnVsbH1zZXRSZXNvbHV0aW9uKHt3aWR0aDppLGhlaWdodDphfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6aSxoZWlnaHQ6YX0pLEUodGhpcyl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoaSl7Y29uc3QgYT1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChpKTtpZihhJiZ0aGlzLmF0dHJpYnV0ZXMucGFzc0V2ZW50cyYmdHlwZW9mIE1vdXNlRXZlbnQ9PSJmdW5jdGlvbiIpe2NvbnN0e3g6cyx5OmZ9PWk7bGV0W08sQV09dGhpcy5nZXRPZmZzZXRQb3NpdGlvbihzLGYpO2NvbnN0IFI9aS5vcmlnaW5hbEV2ZW50LEk9dGhpcy5hdHRyaWJ1dGVzLmFuY2hvcixQPXRoaXMuY2xpZW50U2l6ZTtPPShPK0lbMF0qUFswXSkvMixBPShBK0lbMV0qUFsxXSkvMjtjb25zdCBMPWkudHlwZTtpZihMPT09Ui50eXBlKXtsZXQgRD1udWxsO2lmKFIgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KUQ9bmV3IE1vdXNlRXZlbnQoTCx7c2NyZWVuWDpPLHNjcmVlblk6QSxjbGllbnRYOk8sY2xpZW50WTpBLGJ1YmJsZXM6Ui5idWJibGVzLGJ1dHRvbjpSLmJ1dHRvbixidXR0b25zOlIuYnV0dG9ucyxjYW5jZWxCdWJibGU6Ui5jYW5jZWxCdWJibGUsY2FuY2VsYWJsZTpSLmNhbmNlbGFibGUsY3VycmVudFRhcmdldDpSLmN1cnJlbnRUYXJnZXQsZnJvbUVsZW1lbnQ6Ui5mcm9tRWxlbWVudCxyZWxhdGVkVGFyZ2V0OlIucmVsYXRlZFRhcmdldCxyZXR1cm5WYWx1ZTpSLnJldHVyblZhbHVlLHNyY0VsZW1lbnQ6Ui5zcmNFbGVtZW50LHRhcmdldDpSLnRhcmdldCx0b0VsZW1lbnQ6Ui50b0VsZW1lbnQsd2hpY2g6Ui53aXRjaH0pO2Vsc2UgaWYoUiBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpe2xldCBDPW51bGw7Y29uc3QgUz1SLmNoYW5nZWRUb3VjaGVzfHxbUl07Zm9yKGxldCBCPTA7QjxTLmxlbmd0aDtCKyspe2NvbnN0IHc9U1tCXTtpZihpLmlkZW50aWZpZXI9PT13LmlkZW50aWZpZXIpe0M9dzticmVha319aWYoQyl7Y29uc3QgQj1uZXcgVG91Y2goe2lkZW50aWZpZXI6Qy5pZGVudGlmaWVyLHRhcmdldDpDLnRhcmdldCxjbGllbnRYOk8sY2xpZW50WTpBLHNjcmVlblg6TyxzY3JlZW5ZOkEscGFnZVg6TyxwYWdlWTpBLHJhZGl1c1g6Qy5yYWRpdXNYLHJhZGl1c1k6Qy5yYWRpdXNZLHJvdGF0aW9uQW5nbGU6Qy5yb3RhdGlvbkFuZ2xlLGZvcmNlOkMuZm9yY2V9KTtEPW5ldyBUb3VjaEV2ZW50KEwse2NhbmNlbGFibGU6Ui5jYW5jZWxhYmxlLGJ1YmJsZXM6Ui5idWJibGVzLGNvbXBvc2VkOlIuY29tcG9zZWQsdG91Y2hlczpbQl0sdGFyZ2V0VG91Y2hlczpbQl0sY2hhbmdlZFRvdWNoZXM6W0JdfSl9fWVsc2UgRD1SO0QmJnRoaXMuc3ZnLmRpc3BhdGNoRXZlbnQoRCl9fXJldHVybiBhfWdldEVsZW1lbnRCeUlkKGkpe3JldHVybiBPYmplY3QoZy5xdWVyeVNlbGVjdG9yKShgIyR7aX1gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUoaSl7cmV0dXJuIE9iamVjdChnLnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtpfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUoaSl7cmV0dXJuIE9iamVjdChnLnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtpfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShpKXtyZXR1cm4gT2JqZWN0KGcucXVlcnlTZWxlY3RvckFsbCkoaSx0aGlzKX1xdWVyeVNlbGVjdG9yKGkpe3JldHVybiBPYmplY3QoZy5xdWVyeVNlbGVjdG9yKShpLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoaSl7cmV0dXJuIE9iamVjdChnLnF1ZXJ5U2VsZWN0b3JBbGwpKGksdGhpcyl9b25Qcm9wZXJ0eUNoYW5nZShpLGEscyl7c3VwZXIub25Qcm9wZXJ0eUNoYW5nZShpLGEscyksaT09PSJmbGV4aWJsZSImJkUodGhpcyksdGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYoaT09PSJ3aWR0aCJ8fGk9PT0iaGVpZ2h0Inx8aT09PSJzY2FsZSJ8fGk9PT0idHJhbnNmb3JtIikmJkUodGhpcyl9fXAodiwiQXR0ciIsbi5kZWZhdWx0KSxkLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHYsInNwcml0ZXN2ZyIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBuPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iik7Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihjKXtzdXBlcihjKSx0aGlzW2ddKHtwYXNzRXZlbnRzOiExLGZsZXhpYmxlOiExfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tuXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGMpe31nZXQgcGFzc0V2ZW50cygpe3JldHVybiB0aGlzW25dKCJwYXNzRXZlbnRzIil9c2V0IHBhc3NFdmVudHMoYyl7cmV0dXJuIHRoaXNbZF0oInBhc3NFdmVudHMiLGMpfWdldCBmbGV4aWJsZSgpe3JldHVybiB0aGlzW25dKCJmbGV4aWJsZSIpfXNldCBmbGV4aWJsZShjKXtyZXR1cm4gdGhpc1tkXSgiZmxleGlibGUiLGMpfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oYyxwKXt2YXIgbD1PYmplY3Qua2V5cyhjKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgeT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGMpO3AmJih5PXkuZmlsdGVyKGZ1bmN0aW9uKHgpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGMseCkuZW51bWVyYWJsZX0pKSxsLnB1c2guYXBwbHkobCx5KX1yZXR1cm4gbH1mdW5jdGlvbiBkKGMpe2Zvcih2YXIgcD0xO3A8YXJndW1lbnRzLmxlbmd0aDtwKyspe3ZhciBsPWFyZ3VtZW50c1twXSE9bnVsbD9hcmd1bWVudHNbcF06e307cCUyP24oT2JqZWN0KGwpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHkpe2coYyx5LGxbeV0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhsKSk6bihPYmplY3QobCkpLmZvckVhY2goZnVuY3Rpb24oeSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGMseSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGwseSkpfSl9cmV0dXJuIGN9ZnVuY3Rpb24gZyhjLHAsbCl7cmV0dXJuIHAgaW4gYz9PYmplY3QuZGVmaW5lUHJvcGVydHkoYyxwLHt2YWx1ZTpsLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Y1twXT1sLGN9Y29uc3QgdT1TeW1ib2woImluaXRlZCIpO2xldCBvPW51bGw7dHlwZW9mIFdvcmtlcj09ImZ1bmN0aW9uIiYmKG89Y2xhc3MgZXh0ZW5kcyBXb3JrZXJ7Y29uc3RydWN0b3IoYyl7aWYoYy53b3JrZXI9PT0hMCYmKGMud29ya2VyPWAuLyR7Yy5pZH0ud29ya2VyLmpzYCksc3VwZXIoYy53b3JrZXIpLHRoaXMub3B0aW9ucz1jLCFjLmNhbnZhcyl7Y29uc3R7d2lkdGg6cCxoZWlnaHQ6bH09dGhpcy5nZXRSZXNvbHV0aW9uKCkseT1yLkVOVi5jcmVhdGVDYW52YXMocCxsLHtvZmZzY3JlZW46ITF9KTt5LnN0eWxlJiYoeS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSx5LmRhdGFzZXQmJih5LmRhdGFzZXQubGF5ZXJJZD1jLmlkKSxjLmNhbnZhcz15fXRoaXMuY2FudmFzPWMuY2FudmFzfWdldCBpZCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaWR9c2V0UmVzb2x1dGlvbih7d2lkdGg6YyxoZWlnaHQ6cH0pe2lmKHRoaXNbdV0pdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToicmVzb2x1dGlvbl9jaGFuZ2UiLHdpZHRoOmMsaGVpZ2h0OnB9KTtlbHNle3RoaXMuY2FudmFzLndpZHRoPWMsdGhpcy5jYW52YXMuaGVpZ2h0PXA7Y29uc3QgbD10aGlzLm9wdGlvbnMseT1sLmNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpLHg9ZCh7fSxsKTtkZWxldGUgeC5jb250YWluZXIseC5jYW52YXM9eSx0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJjcmVhdGUiLG9wdGlvbnM6eH0sW3ldKSx0aGlzW3VdPSEwfX1nZXRSZXNvbHV0aW9uKCl7aWYodGhpcy5jYW52YXMpe2NvbnN0e3dpZHRoOmMsaGVpZ2h0OnB9PXRoaXMuY2FudmFzO3JldHVybnt3aWR0aDpjLGhlaWdodDpwfX1yZXR1cm57d2lkdGg6MzAwLGhlaWdodDoxNTB9fXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1jb25uZWN0KGMscCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOmMsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOnAsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9ZGlzY29ubmVjdCgpe2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXJ9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoYyl7dGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiZXZlbnQiLGV2ZW50OntjYW5jZWxCdWJibGU6Yy5jYW5jZWxCdWJibGUsYnViYmxlczpjLmJ1YmJsZXMsZGV0YWlsOmMuZGV0YWlsLGlkZW50aWZpZXI6Yy5pZGVudGlmaWVyLGxheWVyWDpjLmxheWVyWCxsYXllclk6Yy5sYXllclksb3JpZ2luYWxYOmMub3JpZ2luYWxYLG9yaWdpbmFsWTpjLm9yaWdpbmFsWSx0eXBlOmMudHlwZSx4OmMueCx5OmMueX19KX19KSxlLmRlZmF1bHQ9b30sZnVuY3Rpb24oaCxlLHQpe3QucihlKSwoZnVuY3Rpb24ocil7dC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgbj10KDEyKSxkPXQoNjgpLGc9dCg3MCksdT10KDI4Niksbz10KDI4OSksYz10KDI1MCkscD10KDI5MSksbD10KDIxNCkseT10KDIxOCkseD10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGI9U3ltYm9sKCJlbnRlcmVkVGFyZ2V0cyIpO2Z1bmN0aW9uIEUoQSl7cmV0dXJuIEEuaWQ9QS5pZHx8YF9sYXllciR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwxMil9YCxBLmRhdGFzZXR8fChBLmRhdGFzZXQ9e30pLEEuZGF0YXNldC5sYXllcklkPUEuaWQsQS5jb25uZWN0PShSLEkpPT57QS5wYXJlbnQ9UixPYmplY3QuZGVmaW5lUHJvcGVydHkoQSwiek9yZGVyIix7dmFsdWU6SSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX0sQS5kaXNjb25uZWN0PVI9PntkZWxldGUgQS56T3JkZXJ9LEEuY2FudmFzPUEsQS5nZXRSZXNvbHV0aW9uPSgpPT4oe3dpZHRoOjAsaGVpZ2h0OjB9KSxBLnNldFJlc29sdXRpb249KCk9PiExLEEub3B0aW9ucz17aGFuZGxlRXZlbnQ6ITF9LEF9ZnVuY3Rpb24gdihBLFIpe2NvbnN0IEk9QS5jaGlsZHJlbjtsZXQgUD1udWxsO2ZvcihsZXQgTD0wO0w8SS5sZW5ndGg7TCsrKXtjb25zdCBEPUlbTF07aWYoKFI9PT1EfHxQIT1udWxsKSYmKFA9RCksUCYmUCE9PVImJiFQLm9mZnNjcmVlbilyZXR1cm4gUC5jYW52YXN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gTShBLFIpe2NvbnN0W0ksUF09QS5yZW5kZXJPZmZzZXQse3dpZHRoOkwsaGVpZ2h0OkR9PUEuZ2V0UmVzb2x1dGlvbigpLEM9QS5kaXNwbGF5UmF0aW87QS5yZW5kZXJlci5kcmF3SW1hZ2UoUi5jYW52YXMsLUkvQywtUC9DLEwvQyxEL0MpfWNvbnN0IGk9e307ZnVuY3Rpb24gYShBKXtjb25zdCBSPVsibW91c2Vkb3duIiwibW91c2V1cCIsIm1vdXNlbW92ZSIsIm1vdXNld2hlZWwiLCJ3aGVlbCIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoY2FuY2VsIiwiY2xpY2siLCJkYmxjbGljayIsImxvbmdwcmVzcyIsInRhcCIsImNvbnRleHRtZW51Il0sST1BLmNvbnRhaW5lcjtJLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLFA9Pntjb25zdCBMPUFbYl07aWYoTC5zaXplKXtjb25zdCBEPW5ldyBsLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTtELnNldE9yaWdpbmFsRXZlbnQoUCksWy4uLkxdLmZvckVhY2goQz0+e0MuZGlzcGF0Y2hFdmVudChEKX0pLEFbYl0uY2xlYXIoKX19LHtwYXNzaXZlOiEwfSksUi5mb3JFYWNoKFA9PntJLmFkZEV2ZW50TGlzdGVuZXIoUCxMPT57Y29uc3R7bGVmdDpELHRvcDpDLGRpc3BsYXlSYXRpbzpTfT1BLm9wdGlvbnMsQj1BLm9yZGVyZWRDaGlsZHJlbjtPYmplY3QocC5kZWZhdWx0KShMLHtvZmZzZXRMZWZ0OkQsb2Zmc2V0VG9wOkMsZGlzcGxheVJhdGlvOlN9KS5mb3JFYWNoKEg9Pntjb25zdCBaPUguaWRlbnRpZmllcjtpZihILnR5cGU9PT0idG91Y2htb3ZlInx8SC50eXBlPT09InRvdWNoZW5kIil7Y29uc3QgVT1pW1pdO1UmJlUuZGlzcGF0Y2hFdmVudChIKSxILnR5cGU9PT0idG91Y2hlbmQiJiZkZWxldGUgaVtaXX1lbHNle2ZvcihsZXQgVT1CLmxlbmd0aC0xO1U+PTA7VS0tKXtjb25zdCBHPUJbVV07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe2lmKEcuZGlzcGF0Y2hQb2ludGVyRXZlbnQoSCkmJkgudGFyZ2V0IT09RylicmVhaztILmNhbmNlbEJ1YmJsZT0hMX19aWYoSC50YXJnZXQ9PT1CWzBdKWZvcihsZXQgVT1CLmxlbmd0aC0xO1U+PTA7VS0tKXtjb25zdCBHPUJbVV07aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe0gudGFyZ2V0PUc7YnJlYWt9fX1jb25zdCBxPUgudGFyZ2V0O2lmKEgudHlwZT09PSJ0b3VjaHN0YXJ0IiYmKGlbWl09SC50YXJnZXQpLEgudHlwZT09PSJtb3VzZW1vdmUiKXtjb25zdCBVPUFbYl07bGV0IEc7aWYocSl7Y29uc3QgXz1xLmFuY2VzdG9yc3x8W107Rz1uZXcgU2V0KFtxLC4uLl9dKX1lbHNlIEc9bmV3IFNldDtjb25zdCBKPU9iamVjdC5lbnRyaWVzKEwpO2lmKCFVLmhhcyhxKSYmcSl7Y29uc3QgXz1uZXcgbC5kZWZhdWx0KCJtb3VzZWVudGVyIik7Xy5zZXRPcmlnaW5hbEV2ZW50KEwpLEouZm9yRWFjaCgoW2ssaHRdKT0+e19ba109aHR9KSxVLmFkZChxKSxxLmRpc3BhdGNoRXZlbnQoXyk7Y29uc3Qgc3Q9cS5hbmNlc3RvcnM7c3QmJnN0LmZvckVhY2goaz0+e2sgaW5zdGFuY2VvZiBnLmRlZmF1bHQmJiFVLmhhcyhrKSYmKFUuYWRkKGspLGsuZGlzcGF0Y2hFdmVudChfKSl9KX1jb25zdCB0dD1uZXcgbC5kZWZhdWx0KCJtb3VzZWxlYXZlIik7dHQuc2V0T3JpZ2luYWxFdmVudChMKSxKLmZvckVhY2goKFtfLHN0XSk9Pnt0dFtfXT1zdH0pLFsuLi5VXS5mb3JFYWNoKF89PntHLmhhcyhfKXx8KFUuZGVsZXRlKF8pLF8uZGlzcGF0Y2hFdmVudCh0dCkpfSl9fSl9LHtwYXNzaXZlOlAhPT0iY29udGV4dG1lbnUifSl9KX1mdW5jdGlvbiBzKEEsUil7aWYoUiYmUi5zdHlsZSl7bGV0e3dpZHRoOkksaGVpZ2h0OlAsbW9kZTpMLGNvbnRhaW5lcjpEfT1BO2NvbnN0e2NsaWVudFdpZHRoOkMsY2xpZW50SGVpZ2h0OlN9PUQ7ST1JfHxDLFA9UHx8UyxMPT09InN0YXRpYyI/KFIuc3R5bGUud2lkdGg9YCR7SX1weGAsUi5zdHlsZS5oZWlnaHQ9YCR7UH1weGApOihSLnN0eWxlLnRvcD0iMCIsUi5zdHlsZS5sZWZ0PSIwIixSLnN0eWxlLndpZHRoPWAke0N9cHhgLFIuc3R5bGUuaGVpZ2h0PWAke1N9cHhgLFIuc3R5bGUudHJhbnNmb3JtPSIiLFIuc3R5bGUud2Via2l0VHJhbnNmb3JtPSIiKX19Y29uc3QgZj1TeW1ib2woIm9mZnNjcmVlbkxheWVyQ291bnQiKTtjbGFzcyBPIGV4dGVuZHMgYy5kZWZhdWx0e2NvbnN0cnVjdG9yKFI9e30pe2lmKHN1cGVyKCksIVIuY29udGFpbmVyKWlmKHR5cGVvZiBuLkVOVi5Db250YWluZXI9PSJmdW5jdGlvbiIpUi5jb250YWluZXI9bmV3IG4uRU5WLkNvbnRhaW5lcihSLndpZHRofHwzMDAsUi5oZWlnaHR8fDE1MCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIk5vIGNvbnRhaW5lciBzcGVjaWZpZWQuIik7aWYodGhpcy5jb250YWluZXI9Ui5jb250YWluZXIsdGhpcy5jb250YWluZXIuc3R5bGUmJih0aGlzLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd3x8KHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iKSx0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbnx8KHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSIpKSx0aGlzLm9wdGlvbnM9UixSLmRpc3BsYXlSYXRpbz1SLmRpc3BsYXlSYXRpb3x8MSxSLm1vZGU9Ui5tb2RlfHwic2NhbGUiLFIubGVmdD0wLFIudG9wPTAsUi5hdXRvUmVzaXplPVIuYXV0b1Jlc2l6ZSE9PSExLFIuYXV0b1Jlc2l6ZSl7bGV0IEk7aWYodHlwZW9mIGdsb2JhbFRoaXM8InUiP0k9Z2xvYmFsVGhpczpJPXR5cGVvZiB3aW5kb3c8InUiP3dpbmRvdzpyLEkuYWRkRXZlbnRMaXN0ZW5lcil7Y29uc3QgUD10aGlzO0kuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIixmdW5jdGlvbiBMKCl7dHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuY29udGFpbnMoUC5jb250YWluZXIpP1AucmVzaXplKCk6SS5yZW1vdmVFdmVudExpc3RlbmVyKCJyZXNpemUiLEwpfSl9fXRoaXNbYl09bmV3IFNldCx0aGlzLnNldFJlc29sdXRpb24oUiksYSh0aGlzKSx0aGlzW2ZdPTB9Z2V0IGhhc09mZnNjcmVlbkNhbnZhcygpe3JldHVybiB0aGlzW2ZdPjB9c2V0IGRpc3BsYXlSYXRpbyhSKXt0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvIT09UiYmKHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW89Uix0aGlzLnJlc2l6ZSgpKX1nZXQgZGlzcGxheVJhdGlvKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW99c2V0IGhlaWdodChSKXt0aGlzLm9wdGlvbnMuaGVpZ2h0IT09UiYmKHRoaXMub3B0aW9ucy5oZWlnaHQ9Uix0aGlzLnJlc2l6ZSgpKX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXMub3B0aW9ucy5oZWlnaHR9c2V0IG1vZGUoUil7dGhpcy5vcHRpb25zLm1vZGUhPT1SJiYodGhpcy5vcHRpb25zLm1vZGU9Uix0aGlzLnJlc2l6ZSgpKX1nZXQgbW9kZSgpe3JldHVybiB0aGlzLm9wdGlvbnMubW9kZX1zZXQgd2lkdGgoUil7dGhpcy5vcHRpb25zLndpZHRoIT09UiYmKHRoaXMub3B0aW9ucy53aWR0aD1SLHRoaXMucmVzaXplKCkpfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLm9wdGlvbnMud2lkdGh9YXBwZW5kQ2hpbGQoUil7IShSIGluc3RhbmNlb2YgdS5kZWZhdWx0KSYmIShSIGluc3RhbmNlb2Ygby5kZWZhdWx0KSYmRShSKTtjb25zdCBJPXN1cGVyLmFwcGVuZENoaWxkKFIpLFA9Ui5jYW52YXM7cmV0dXJuIFIub2Zmc2NyZWVuP3RoaXNbZl0rKzp0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChQKSxzKHRoaXMub3B0aW9ucyxQKSxSLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLEl9Zm9yY2VVcGRhdGUoKXt0aGlzLmhhc09mZnNjcmVlbkNhbnZhcyYmIXRoaXMuX3JlcXVlc3RJRCYmKHRoaXMuX3JlcXVlc3RJRD1PYmplY3QoZC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIHRoaXMuX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfWluc2VydEJlZm9yZShSLEkpeyEoUiBpbnN0YW5jZW9mIHUuZGVmYXVsdCkmJiEoUiBpbnN0YW5jZW9mIG8uZGVmYXVsdCkmJkUoUik7Y29uc3QgUD1zdXBlci5pbnNlcnRCZWZvcmUoUixJKSxMPVIuY2FudmFzO2lmKCFSLm9mZnNjcmVlbil7Y29uc3QgRD12KHRoaXMsUik7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEwsRCl9cmV0dXJuIHModGhpcy5vcHRpb25zLEwpLFIuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksUH1sYXllcihSPSJkZWZhdWx0IixJPXt9KXtJPU9iamVjdC5hc3NpZ24oe30sdGhpcy5vcHRpb25zLEkpLEkuaWQ9Ujtjb25zdCBQPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgQz0wO0M8UC5sZW5ndGg7QysrKWlmKFBbQ10uaWQ9PT1SKXJldHVybiBQW0NdO2NvbnN0IEw9SS53b3JrZXI7bGV0IEQ7cmV0dXJuIEw/RD1uZXcgby5kZWZhdWx0KEkpOkQ9bmV3IHUuZGVmYXVsdChJKSx0aGlzLmFwcGVuZENoaWxkKEQpLER9YXN5bmMgcHJlbG9hZCguLi5SKXtjb25zdCBJPVtdLFA9W10sTD1bXTtmb3IobGV0IEQ9MDtEPFIubGVuZ3RoO0QrKyl7Y29uc3QgQz1SW0RdO2xldCBTO2lmKHR5cGVvZiBDPT0ic3RyaW5nIilTPU9iamVjdCh5LmxvYWRUZXh0dXJlKShDKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoQykpUz1PYmplY3QoeS5sb2FkRnJhbWVzKSguLi5DKTtlbHNle2NvbnN0e2lkOkIsc3JjOnd9PUM7Uz1PYmplY3QoeS5sb2FkVGV4dHVyZSkodyxCKX1TIGluc3RhbmNlb2YgUHJvbWlzZXx8KFM9UHJvbWlzZS5yZXNvbHZlKFMpKSxQLnB1c2goUy50aGVuKEI9PntJLnB1c2goQiksTFtEXT1CO2NvbnN0IHc9bmV3IGwuZGVmYXVsdCh7dHlwZToicHJlbG9hZCIsZGV0YWlsOntjdXJyZW50OkIsbG9hZGVkOkkscmVzb3VyY2VzOlJ9fSk7dGhpcy5kaXNwYXRjaEV2ZW50KHcpfSkpfXJldHVybiBhd2FpdCBQcm9taXNlLmFsbChQKSxMfXJlbW92ZUNoaWxkKFIpe2NvbnN0IEk9c3VwZXIucmVtb3ZlQ2hpbGQoUik7aWYoSSl7Ui5fcHJlcGFyZVJlbmRlckZpbmlzaGVkJiZSLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKTtjb25zdCBQPVIuY2FudmFzO1AmJlAucmVtb3ZlJiZQLnJlbW92ZSgpLFIub2Zmc2NyZWVuJiZ0aGlzW2ZdLS19cmV0dXJuIEl9cmVuZGVyKCl7Y29uc3QgUj10aGlzLm9yZGVyZWRDaGlsZHJlbjtsZXQgST1udWxsO2NvbnN0IFA9W107Zm9yKGxldCBMPTA7TDxSLmxlbmd0aDtMKyspe2NvbnN0IEQ9UltMXSxDPVAubGVuZ3RoPjA7aWYoRCBpbnN0YW5jZW9mIHUuZGVmYXVsdCYmIUQub2Zmc2NyZWVuKWlmKCFELmF1dG9SZW5kZXIpQyYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLFAubGVuZ3RoPTApO2Vsc2UgaWYoST1ELEMpe0QucmVuZGVyZXIuY2xlYXIoKTtmb3IobGV0IFM9MDtTPFAubGVuZ3RoO1MrKyl7Y29uc3QgQj1QW1NdO0IucmVuZGVyKCksTShELEIpfVAubGVuZ3RoPTAsRC5yZW5kZXIoe2NsZWFyOiExfSl9ZWxzZSBELnByZXBhcmVSZW5kZXImJkQucmVuZGVyKCk7ZWxzZSBELm9mZnNjcmVlbj9JPyhELnByZXBhcmVSZW5kZXImJkQucmVuZGVyKCksTShJLEQpKTpQLnB1c2goRCk6RCBpbnN0YW5jZW9mIG8uZGVmYXVsdCYmQyYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLFAubGVuZ3RoPTApfX1yZXBsYWNlQ2hpbGQoUixJKXtjb25zdCBQPXN1cGVyLnJlcGxhY2VDaGlsZChSLEkpO0kuY2FudmFzLnJlbW92ZSYmSS5jYW52YXMucmVtb3ZlKCksSS5vZmZzY3JlZW4mJnRoaXNbZl0tLTtjb25zdCBMPVIuY2FudmFzO2lmKCFSLm9mZnNjcmVlbil7Y29uc3QgRD12KHRoaXMsUik7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEwsRCl9cmV0dXJuIHModGhpcy5vcHRpb25zLEwpLFIuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksUH1yZXNpemUoKXtjb25zdCBSPXRoaXMub3B0aW9uczt0aGlzLmNoaWxkcmVuLmZvckVhY2goST0+e3MoUixJLmNhbnZhcyl9KSx0aGlzLnNldFJlc29sdXRpb24oUiksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZXNpemUifSl9c2V0UmVzb2x1dGlvbih7d2lkdGg6UixoZWlnaHQ6SX09e30pe2NvbnN0IFA9dGhpcy5jb250YWluZXIse2NsaWVudFdpZHRoOkwsY2xpZW50SGVpZ2h0OkR9PVA7KFI9PW51bGx8fEk9PW51bGwpJiYoUj1SPz9MLEk9ST8/RCk7Y29uc3R7bW9kZTpDLGRpc3BsYXlSYXRpbzpTfT10aGlzLm9wdGlvbnM7aWYoUio9UyxJKj1TLHRoaXMub3B0aW9ucy5sZWZ0PTAsdGhpcy5vcHRpb25zLnRvcD0wLEM9PT0ic3RpY2t5SGVpZ2h0Inx8Qz09PSJzdGlja3lMZWZ0Inx8Qz09PSJzdGlja3lSaWdodCIpe2NvbnN0IEI9UjtSPUwqSS9ELEM9PT0ic3RpY2t5SGVpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PS41KihSLUIpKSxDPT09InN0aWNreVJpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PVItQil9ZWxzZSBpZihDPT09InN0aWNreVdpZHRoInx8Qz09PSJzdGlja3lUb3AifHxDPT09InN0aWNreUJvdHRvbSIpe2NvbnN0IEI9STtJPUQqUi9MLEM9PT0ic3RpY2t5V2lkdGgiJiYodGhpcy5vcHRpb25zLnRvcD0uNSooSS1CKSksQz09PSJzdGlja3lCb3R0b20iJiYodGhpcy5vcHRpb25zLnRvcD1JLUIpfXN1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOlIsaGVpZ2h0Okl9KX1zbmFwc2hvdCh7b2Zmc2NyZWVuOlI9ITEsbGF5ZXJzOkl9PXt9KXtjb25zdCBQPVI/InNuYXBzaG90T2ZmU2NyZWVuQ2FudmFzIjoic25hcHNob3RDYW52YXMiLHt3aWR0aDpMLGhlaWdodDpEfT10aGlzLmdldFJlc29sdXRpb24oKTt0aGlzW1BdPXRoaXNbUF18fG4uRU5WLmNyZWF0ZUNhbnZhcyhMLEQse29mZnNjcmVlbjpSfSk7Y29uc3QgQz10aGlzW1BdLmdldENvbnRleHQoIjJkIik7ST1JfHx0aGlzLm9yZGVyZWRDaGlsZHJlbix0aGlzW1BdLndpZHRoPUwsdGhpc1tQXS5oZWlnaHQ9RDtmb3IobGV0IFM9MDtTPEkubGVuZ3RoO1MrKyl7Y29uc3QgQj1JW1NdO2lmKCFCLm9wdGlvbnMuaWdub3JlU25hcHNob3Qpe0IucmVuZGVyJiZCLnJlbmRlcigpO2NvbnN0IHc9Qi5jYW52YXM7dyYmdyE9PUImJkMuZHJhd0ltYWdlKHcsMCwwLEwsRCl9fXJldHVybiB0aGlzW1BdfX10eXBlb2YgZG9jdW1lbnQ8InUiJiYoTy5wcm90b3R5cGUubGF5ZXIzZD1mdW5jdGlvbihBLFI9e30pe2NvbnN0IEk9Ui51cmx8fCJodHRwczovL3VucGtnLmNvbS9zcHJpdGUtZXh0ZW5kLTNkL2Rpc3Qvc3ByaXRlLWV4dGVuZC0zZC5taW4uanMiO3JldHVybiBuZXcgUHJvbWlzZSgoUCxMKT0+e2NvbnN0IEQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0Iik7RC5hc3luYz0hMSxELnNyYz1JLEQub25sb2FkPSgpPT57dHJ5e1AodGhpcy5sYXllcjNkKEEsUikpfWNhdGNoKEMpe0woQyl9fSxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoRCl9KX0pLHguZGVmYXVsdC5yZWdpc3Rlck5vZGUoTywic2NlbmUiKX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgcj10KDIxNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG4oZCx7b2Zmc2V0VG9wOmc9MCxvZmZzZXRMZWZ0OnU9MCxkaXNwbGF5UmF0aW86bz0xfT17fSl7bGV0IGMscDtjb25zdCBsPVtdLHtsZWZ0OnksdG9wOngsd2lkdGg6YixoZWlnaHQ6RX09ZC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksdj1kLnRhcmdldC53aWR0aCxNPWQudGFyZ2V0LmhlaWdodCxpPWQuY2hhbmdlZFRvdWNoZXN8fFtkXTtmb3IobGV0IHM9MDtzPGkubGVuZ3RoO3MrKyl7Y29uc3QgZj1pW3NdLE89Zi5pZGVudGlmaWVyLHtjbGllbnRYOkEsY2xpZW50WTpSfT1mO0EhPW51bGwmJlIhPW51bGwmJmwucHVzaCh7eDpNYXRoLnJvdW5kKChBfDApLXkpLHk6TWF0aC5yb3VuZCgoUnwwKS14KSxpZGVudGlmaWVyOk99KX1sLmxlbmd0aDw9MCYmbC5wdXNoKHt4OmMseTpwfSk7Y29uc3QgYT1bXTtyZXR1cm4gbC5mb3JFYWNoKHM9PntzLnghPW51bGwmJnMueSE9bnVsbCYmKGM9KHMueCp2L2ItdSkvbyxwPShzLnkqTS9FLWcpL28pO2NvbnN0IGY9bmV3IHIuZGVmYXVsdChkKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhmLHtsYXllclg6e3ZhbHVlOmMsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOnAsY29uZmlndXJhYmxlOiEwfSxvcmlnaW5hbFg6e3ZhbHVlOnMueH0sb3JpZ2luYWxZOnt2YWx1ZTpzLnl9LHg6e3ZhbHVlOmMsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTpwLGNvbmZpZ3VyYWJsZTohMH0saWRlbnRpZmllcjp7dmFsdWU6cy5pZGVudGlmaWVyfX0pLGEucHVzaChmKX0pLGF9fV0pO1J0LnZlcnNpb24sUnQuQXJjLFJ0LkJsb2NrLFJ0LkNsb3VkLFJ0LkNvbG9yLFJ0LkVsbGlwc2UsUnQuR3JhZGllbnQ7Y29uc3QgTGU9UnQuR3JvdXA7UnQuTGFiZWwsUnQuTGF5ZXIsUnQuTGF5ZXJXb3JrZXIsUnQuTm9kZSxSdC5QYXJhbGxlbDtjb25zdCBEZT1SdC5QYXRoO1J0LlBvbHlsaW5lO2NvbnN0IHJyPVJ0LlJlY3Q7UnQuUmVndWxhcixSdC5SaW5nO2NvbnN0IG5uPVJ0LlNjZW5lO1J0LlNwcml0ZSxSdC5TcHJpdGVTdmcsUnQuU3RhcixSdC5UcmlhbmdsZSxSdC5oZWxwZXJzLFJ0LmNyZWF0ZUVsZW1lbnQsUnQuaXNTcHJpdGVOb2RlLFJ0LnJlZ2lzdGVyTm9kZSxSdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsUnQuY2FuY2VsQW5pbWF0aW9uRnJhbWUsUnQuRU5WO2NvbnN0IHNuPXtsaW5lYXI6aD0+aCxlYXNlSW5RdWFkOmg9PmgqaCxlYXNlT3V0UXVhZDpoPT5oKigyLWgpLGVhc2VJbk91dFF1YWQ6aD0+aDwuNT8yKmgqaDotMSsoNC0yKmgpKmgsZWFzZUluQ3ViaWM6aD0+aCpoKmgsZWFzZU91dEN1YmljOmg9Pi0taCpoKmgrMSxlYXNlSW5PdXRDdWJpYzpoPT5oPC41PzQqaCpoKmg6KGgtMSkqKDIqaC0yKSooMipoLTIpKzEsZWFzZUluUXVhcnQ6aD0+aCpoKmgqaCxlYXNlT3V0UXVhcnQ6aD0+MS0gLS1oKmgqaCpoLGVhc2VJbk91dFF1YXJ0Omg9Pmg8LjU/OCpoKmgqaCpoOjEtOCotLWgqaCpoKmgsZWFzZUluUXVpbnQ6aD0+aCpoKmgqaCpoLGVhc2VPdXRRdWludDpoPT4xKy0taCpoKmgqaCpoLGVhc2VJbk91dFF1aW50Omg9Pmg8LjU/MTYqaCpoKmgqaCpoOjErMTYqLS1oKmgqaCpoKmgsZWFzZUluU2luZTpoPT4xLU1hdGguY29zKGgqTWF0aC5QSS8yKSxlYXNlT3V0U2luZTpoPT5NYXRoLnNpbihoKk1hdGguUEkvMiksZWFzZUluT3V0U2luZTpoPT4tKE1hdGguY29zKE1hdGguUEkqaCktMSkvMixlYXNlSW5FeHBvOmg9Pmg8PTA/MDpNYXRoLnBvdygyLDEwKmgtMTApLGVhc2VPdXRFeHBvOmg9Pmg+PTE/MToxLU1hdGgucG93KDIsLTEwKmgpLGVhc2VJbk91dEV4cG86aD0+aDw9MD8wOmg+PTE/MTpoPC41P01hdGgucG93KDIsMjAqaC0xMCkvMjooMi1NYXRoLnBvdygyLC0yMCpoKzEwKSkvMn07Y2xhc3MgY3R7Y29uc3RydWN0b3IoZT0wLHQ9MCxyPTEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6cn0pfWdldCBYWSgpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXR6KGUpe3JldHVybiB0aGlzLno9ZSx0aGlzfXNldFhZKGU9dGhpcy54LHQ9dGhpcy55KXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpc31zZXQoZT10aGlzLngsdD10aGlzLnkscj10aGlzLnope3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9cix0aGlzfXNldFRvKHt4OmU9MCx5OnQ9MCx6OnI9MX0pe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9cix0aGlzfXJvdChlKXtpZihlPT09MClyZXR1cm4gdGhpcztjb25zdHt4OnQseTpyfT10aGlzLG49TWF0aC5zaW4oZSksZD1NYXRoLmNvcyhlKTtyZXR1cm4gdGhpcy54PXQqZC1yKm4sdGhpcy55PXQqbityKmQsdGhpc31yb3RXaXRoKGUsdCl7aWYodD09PTApcmV0dXJuIHRoaXM7Y29uc3Qgcj10aGlzLngtZS54LG49dGhpcy55LWUueSxkPU1hdGguc2luKHQpLGc9TWF0aC5jb3ModCk7cmV0dXJuIHRoaXMueD1lLngrKHIqZy1uKmQpLHRoaXMueT1lLnkrKHIqZCtuKmcpLHRoaXN9Y2xvbmUoKXtjb25zdHt4OmUseTp0LHo6cn09dGhpcztyZXR1cm4gbmV3IGN0KGUsdCxyKX1zdWIoZSl7cmV0dXJuIHRoaXMueC09ZS54LHRoaXMueS09ZS55LHRoaXN9c3ViWFkoZSx0KXtyZXR1cm4gdGhpcy54LT1lLHRoaXMueS09dCx0aGlzfXN1YlNjYWxhcihlKXtyZXR1cm4gdGhpcy54LT1lLHRoaXMueS09ZSx0aGlzfWFkZChlKXtyZXR1cm4gdGhpcy54Kz1lLngsdGhpcy55Kz1lLnksdGhpc31hZGRYWShlLHQpe3JldHVybiB0aGlzLngrPWUsdGhpcy55Kz10LHRoaXN9YWRkU2NhbGFyKGUpe3JldHVybiB0aGlzLngrPWUsdGhpcy55Kz1lLHRoaXN9Y2xhbXAoZSx0KXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHRoaXMueCxlKSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LGUpLHQhPT12b2lkIDAmJih0aGlzLng9TWF0aC5taW4odGhpcy54LHQpLHRoaXMueT1NYXRoLm1pbih0aGlzLnksdCkpLHRoaXN9ZGl2KGUpe3JldHVybiB0aGlzLngvPWUsdGhpcy55Lz1lLHRoaXN9ZGl2VihlKXtyZXR1cm4gdGhpcy54Lz1lLngsdGhpcy55Lz1lLnksdGhpc31tdWwoZSl7cmV0dXJuIHRoaXMueCo9ZSx0aGlzLnkqPWUsdGhpc31tdWxWKGUpe3JldHVybiB0aGlzLngqPWUueCx0aGlzLnkqPWUueSx0aGlzfWFicygpe3JldHVybiB0aGlzLng9TWF0aC5hYnModGhpcy54KSx0aGlzLnk9TWF0aC5hYnModGhpcy55KSx0aGlzfW51ZGdlKGUsdCl7Y29uc3Qgcj1jdC5UYW4oZSx0aGlzKTtyZXR1cm4gdGhpcy5hZGQoci5tdWwodCkpfW5lZygpe3JldHVybiB0aGlzLngqPS0xLHRoaXMueSo9LTEsdGhpc31jcm9zcyhlKXtyZXR1cm4gdGhpcy54PXRoaXMueSplLnotdGhpcy56KmUueSx0aGlzLnk9dGhpcy56KmUueC10aGlzLngqZS56LHRoaXN9ZHByKGUpe3JldHVybiBjdC5EcHIodGhpcyxlKX1jcHIoZSl7cmV0dXJuIGN0LkNwcih0aGlzLGUpfWxlbjIoKXtyZXR1cm4gY3QuTGVuMih0aGlzKX1sZW4oKXtyZXR1cm4gY3QuTGVuKHRoaXMpfXByeShlKXtyZXR1cm4gY3QuUHJ5KHRoaXMsZSl9cGVyKCl7Y29uc3R7eDplLHk6dH09dGhpcztyZXR1cm4gdGhpcy54PXQsdGhpcy55PS1lLHRoaXN9dW5pKCl7cmV0dXJuIGN0LlVuaSh0aGlzKX10YW4oZSl7cmV0dXJuIGN0LlRhbih0aGlzLGUpfWRpc3QoZSl7cmV0dXJuIGN0LkRpc3QodGhpcyxlKX1kaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0KXtyZXR1cm4gY3QuRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCx0aGlzKX1zbG9wZShlKXtyZXR1cm4gY3QuU2xvcGUodGhpcyxlKX1zbmFwVG9HcmlkKGUpe3JldHVybiB0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngvZSkqZSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkvZSkqZSx0aGlzfWFuZ2xlKGUpe3JldHVybiBjdC5BbmdsZSh0aGlzLGUpfXRvQW5nbGUoKXtyZXR1cm4gY3QuVG9BbmdsZSh0aGlzKX1scnAoZSx0KXtyZXR1cm4gdGhpcy54PXRoaXMueCsoZS54LXRoaXMueCkqdCx0aGlzLnk9dGhpcy55KyhlLnktdGhpcy55KSp0LHRoaXN9ZXF1YWxzKGUsdCl7cmV0dXJuIGN0LkVxdWFscyh0aGlzLGUsdCl9ZXF1YWxzWFkoZSx0KXtyZXR1cm4gY3QuRXF1YWxzWFkodGhpcyxlLHQpfW5vcm0oKXtjb25zdCBlPXRoaXMubGVuKCk7cmV0dXJuIHRoaXMueD1lPT09MD8wOnRoaXMueC9lLHRoaXMueT1lPT09MD8wOnRoaXMueS9lLHRoaXN9dG9GaXhlZCgpe3JldHVybiBjdC5Ub0ZpeGVkKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuIGN0LlRvU3RyaW5nKGN0LlRvRml4ZWQodGhpcykpfXRvSnNvbigpe3JldHVybiBjdC5Ub0pzb24odGhpcyl9dG9BcnJheSgpe3JldHVybiBjdC5Ub0FycmF5KHRoaXMpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IGN0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEFkZFhZKGUsdCxyKXtyZXR1cm4gbmV3IGN0KGUueCt0LGUueStyKX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBjdChlLngtdC54LGUueS10LnkpfXN0YXRpYyBTdWJYWShlLHQscil7cmV0dXJuIG5ldyBjdChlLngtdCxlLnktcil9c3RhdGljIEFkZFNjYWxhcihlLHQpe3JldHVybiBuZXcgY3QoZS54K3QsZS55K3QpfXN0YXRpYyBTdWJTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IGN0KGUueC10LGUueS10KX1zdGF0aWMgRGl2KGUsdCl7cmV0dXJuIG5ldyBjdChlLngvdCxlLnkvdCl9c3RhdGljIE11bChlLHQpe3JldHVybiBuZXcgY3QoZS54KnQsZS55KnQpfXN0YXRpYyBEaXZWKGUsdCl7cmV0dXJuIG5ldyBjdChlLngvdC54LGUueS90LnkpfXN0YXRpYyBNdWxWKGUsdCl7cmV0dXJuIG5ldyBjdChlLngqdC54LGUueSp0LnkpfXN0YXRpYyBOZWcoZSl7cmV0dXJuIG5ldyBjdCgtZS54LC1lLnkpfXN0YXRpYyBQZXIoZSl7cmV0dXJuIG5ldyBjdChlLnksLWUueCl9c3RhdGljIERpc3QyKGUsdCl7cmV0dXJuIGN0LlN1YihlLHQpLmxlbjIoKX1zdGF0aWMgQWJzKGUpe3JldHVybiBuZXcgY3QoTWF0aC5hYnMoZS54KSxNYXRoLmFicyhlLnkpKX1zdGF0aWMgRGlzdChlLHQpe3JldHVybiBNYXRoLmh5cG90KGUueS10LnksZS54LXQueCl9c3RhdGljIERwcihlLHQpe3JldHVybiBlLngqdC54K2UueSp0Lnl9c3RhdGljIENyb3NzKGUsdCl7cmV0dXJuIG5ldyBjdChlLnkqdC56LWUueip0LnksZS56KnQueC1lLngqdC56KX1zdGF0aWMgQ3ByKGUsdCl7cmV0dXJuIGUueCp0LnktdC54KmUueX1zdGF0aWMgTGVuMihlKXtyZXR1cm4gZS54KmUueCtlLnkqZS55fXN0YXRpYyBMZW4oZSl7cmV0dXJuIE1hdGguaHlwb3QoZS54LGUueSl9c3RhdGljIFByeShlLHQpe3JldHVybiBjdC5EcHIoZSx0KS9jdC5MZW4odCl9c3RhdGljIFVuaShlKXtyZXR1cm4gY3QuRGl2KGUsY3QuTGVuKGUpKX1zdGF0aWMgVGFuKGUsdCl7cmV0dXJuIGN0LlVuaShjdC5TdWIoZSx0KSl9c3RhdGljIE1pbihlLHQpe3JldHVybiBuZXcgY3QoTWF0aC5taW4oZS54LHQueCksTWF0aC5taW4oZS55LHQueSkpfXN0YXRpYyBNYXgoZSx0KXtyZXR1cm4gbmV3IGN0KE1hdGgubWF4KGUueCx0LngpLE1hdGgubWF4KGUueSx0LnkpKX1zdGF0aWMgRnJvbShlKXtyZXR1cm4gbmV3IGN0KCkuYWRkKGUpfXN0YXRpYyBGcm9tQXJyYXkoZSl7cmV0dXJuIG5ldyBjdChlWzBdLGVbMV0pfXN0YXRpYyBSb3QoZSx0PTApe2NvbnN0IHI9TWF0aC5zaW4odCksbj1NYXRoLmNvcyh0KTtyZXR1cm4gbmV3IGN0KGUueCpuLWUueSpyLGUueCpyK2UueSpuKX1zdGF0aWMgUm90V2l0aChlLHQscil7Y29uc3Qgbj1lLngtdC54LGQ9ZS55LXQueSxnPU1hdGguc2luKHIpLHU9TWF0aC5jb3Mocik7cmV0dXJuIG5ldyBjdCh0LngrKG4qdS1kKmcpLHQueSsobipnK2QqdSkpfXN0YXRpYyBOZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LHIpe3JldHVybiBjdC5NdWwodCxjdC5TdWIocixlKS5wcnkodCkpLmFkZChlKX1zdGF0aWMgTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQscixuPSEwKXtjb25zdCBkPWN0LlRhbih0LGUpLGc9Y3QuQWRkKGUsY3QuTXVsKGQsY3QuU3ViKHIsZSkucHJ5KGQpKSk7aWYobil7aWYoZy54PE1hdGgubWluKGUueCx0LngpKXJldHVybiBjdC5DYXN0KGUueDx0Lng/ZTp0KTtpZihnLng+TWF0aC5tYXgoZS54LHQueCkpcmV0dXJuIGN0LkNhc3QoZS54PnQueD9lOnQpO2lmKGcueTxNYXRoLm1pbihlLnksdC55KSlyZXR1cm4gY3QuQ2FzdChlLnk8dC55P2U6dCk7aWYoZy55Pk1hdGgubWF4KGUueSx0LnkpKXJldHVybiBjdC5DYXN0KGUueT50Lnk/ZTp0KX1yZXR1cm4gZ31zdGF0aWMgRGlzdGFuY2VUb0xpbmVUaHJvdWdoUG9pbnQoZSx0LHIpe3JldHVybiBjdC5EaXN0KHIsY3QuTmVhcmVzdFBvaW50T25MaW5lVGhyb3VnaFBvaW50KGUsdCxyKSl9c3RhdGljIERpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQscixuPSEwKXtyZXR1cm4gY3QuRGlzdChyLGN0Lk5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoZSx0LHIsbikpfXN0YXRpYyBTbmFwKGUsdD0xKXtyZXR1cm4gbmV3IGN0KE1hdGgucm91bmQoZS54L3QpKnQsTWF0aC5yb3VuZChlLnkvdCkqdCl9c3RhdGljIENhc3QoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBjdD9lOmN0LkZyb20oZSl9c3RhdGljIFNsb3BlKGUsdCl7cmV0dXJuIGUueD09PXQueT9OYU46KGUueS10LnkpLyhlLngtdC54KX1zdGF0aWMgQW5nbGUoZSx0KXtyZXR1cm4gTWF0aC5hdGFuMih0LnktZS55LHQueC1lLngpfXN0YXRpYyBMcnAoZSx0LHIpe3JldHVybiBjdC5TdWIodCxlKS5tdWwocikuYWRkKGUpfXN0YXRpYyBNZWQoZSx0KXtyZXR1cm4gbmV3IGN0KChlLngrdC54KS8yLChlLnkrdC55KS8yKX1zdGF0aWMgRXF1YWxzKGUsdCxyPTFlLTQpe3JldHVybiBNYXRoLmFicyhlLngtdC54KTxyJiZNYXRoLmFicyhlLnktdC55KTxyfXN0YXRpYyBFcXVhbHNYWShlLHQscil7cmV0dXJuIGUueD09PXQmJmUueT09PXJ9c3RhdGljIEVxdWFsc1hZWihlLHQscj0xZS00KXtyZXR1cm4gY3QuRXF1YWxzKGUsdCxyKSYmTWF0aC5hYnMoKGUuenx8MCktKHQuenx8MCkpPHJ9c3RhdGljIENsb2Nrd2lzZShlLHQscil7cmV0dXJuKHIueC1lLngpKih0LnktZS55KS0odC54LWUueCkqKHIueS1lLnkpPDB9c3RhdGljIFJlc2NhbGUoZSx0KXtjb25zdCByPWN0LkxlbihlKTtyZXR1cm4gbmV3IGN0KHQqZS54L3IsdCplLnkvcil9c3RhdGljIFNjYWxlV2l0aE9yaWdpbihlLHQscil7cmV0dXJuIGN0LlN1YihlLHIpLm11bCh0KS5hZGQocil9c3RhdGljIFNjYWxlV09yaWdpbihlLHQscil7cmV0dXJuIGN0LlN1YihlLHIpLm11bFYodCkuYWRkKHIpfXN0YXRpYyBUb0ZpeGVkKGUsdD0yKXtyZXR1cm4gbmV3IGN0KCtlLngudG9GaXhlZCh0KSwrZS55LnRvRml4ZWQodCksK2Uuei50b0ZpeGVkKHQpKX1zdGF0aWMgTnVkZ2UoZSx0LHIpe3JldHVybiBjdC5BZGQoZSxjdC5UYW4odCxlKS5tdWwocikpfXN0YXRpYyBUb1N0cmluZyhlKXtyZXR1cm5gJHtlLnh9LCAke2UueX1gfXN0YXRpYyBUb0FuZ2xlKGUpe2xldCB0PU1hdGguYXRhbjIoZS55LGUueCk7cmV0dXJuIHQ8MCYmKHQrPU1hdGguUEkqMiksdH1zdGF0aWMgRnJvbUFuZ2xlKGUsdD0xKXtyZXR1cm4gbmV3IGN0KE1hdGguY29zKGUpKnQsTWF0aC5zaW4oZSkqdCl9c3RhdGljIFRvQXJyYXkoZSl7cmV0dXJuW2UueCxlLnksZS56XX1zdGF0aWMgVG9Kc29uKGUpe2NvbnN0e3g6dCx5OnIsejpufT1lO3JldHVybnt4OnQseTpyLHo6bn19c3RhdGljIEF2ZXJhZ2UoZSl7Y29uc3QgdD1lLmxlbmd0aCxyPW5ldyBjdCgwLDApO2ZvcihsZXQgbj0wO248dDtuKyspci5hZGQoZVtuXSk7cmV0dXJuIHIuZGl2KHQpfXN0YXRpYyBDbGFtcChlLHQscil7cmV0dXJuIHI9PT12b2lkIDA/bmV3IGN0KE1hdGgubWluKE1hdGgubWF4KGUueCx0KSksTWF0aC5taW4oTWF0aC5tYXgoZS55LHQpKSk6bmV3IGN0KE1hdGgubWluKE1hdGgubWF4KGUueCx0KSxyKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkscikpfXN0YXRpYyBQb2ludHNCZXR3ZWVuKGUsdCxyPTYpe2NvbnN0IG49W107Zm9yKGxldCBkPTA7ZDxyO2QrKyl7Y29uc3QgZz1zbi5lYXNlSW5RdWFkKGQvKHItMSkpLHU9Y3QuTHJwKGUsdCxnKTt1Lno9TWF0aC5taW4oMSwuNStNYXRoLmFicyguNS1vbihnKSkqLjY1KSxuLnB1c2godSl9cmV0dXJuIG59c3RhdGljIFNuYXBUb0dyaWQoZSx0PTgpe3JldHVybiBuZXcgY3QoTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX19Y29uc3Qgb249aD0+aDwuNT8yKmgqaDotMSsoNC0yKmgpKmg7Y2xhc3MgTHQgZXh0ZW5kcyBjdHtjb25zdHJ1Y3RvcihlPTAsdD0wLHI9MCxuPXt4OjAseTowfSxkPTAsZz0wKXtzdXBlcihlLHQsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInYiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpufSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpkfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImEiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpnfSl9Z2V0IHRpbWVzdGFtcCgpe3JldHVybiB0aGlzLnR9Z2V0IHByZXNzdXJlKCl7cmV0dXJuIHRoaXMuen1nZXQgYW5nbGVOdW0oKXtyZXR1cm4gdGhpcy5hfWdldCBYWSgpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXRBKGUpe3RoaXMuYT1lfXNldFQoZSl7dGhpcy50PWV9c2V0dihlKXtyZXR1cm4gdGhpcy52PXt4OmUueCx5OmUueX0sdGhpc31zZXQoZT10aGlzLngsdD10aGlzLnkscj10aGlzLnosbj10aGlzLnYsZD10aGlzLnQsZz10aGlzLmEpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9cix0aGlzLnY9bix0aGlzLnQ9ZCx0aGlzLmE9Zyx0aGlzfWNsb25lKCl7Y29uc3R7eDplLHk6dCx6OnIsdjpuLHQ6ZCxhOmd9PXRoaXMsdT17eDpuLngseTpuLnl9O3JldHVybiBuZXcgTHQoZSx0LHIsdSxkLGcpfWRpc3RhbmNlKGUpe3JldHVybiBMdC5HZXREaXN0YW5jZSh0aGlzLGUpfWlzTmVhcihlLHQpe3JldHVybiBMdC5Jc05lYXIodGhpcyxlLHQpfWdldEFuZ2xlQnlQb2ludHMoZSx0KXtyZXR1cm4gTHQuR2V0QW5nbGVCeVBvaW50cyhlLHRoaXMsdCl9c3RhdGljIFN1YihlLHQpe3JldHVybiBuZXcgTHQoZS54LXQueCxlLnktdC55KX1zdGF0aWMgQWRkKGUsdCl7cmV0dXJuIG5ldyBMdChlLngrdC54LGUueSt0LnkpfXN0YXRpYyBHZXREaXN0YW5jZShlLHQpe3JldHVybiBMdC5MZW4oZS5jbG9uZSgpLnN1Yih0KSl9c3RhdGljIEdldEFuZ2xlQnlQb2ludHMoZSx0LHIpe2NvbnN0IG49dC54LWUueCxkPXIueC10LngsZz10LnktZS55LHU9ci55LXQueTtsZXQgbz0wO2NvbnN0IGM9TWF0aC5zcXJ0KG4qbitnKmcpLHA9TWF0aC5zcXJ0KGQqZCt1KnUpO2lmKGMmJnApe2NvbnN0IGw9bipkK2cqdTtvPU1hdGguYWNvcyhsLyhjKnApKSxvPW8vTWF0aC5QSSoxODA7bGV0IHk9bip1LWcqZDt5PXk+MD8xOi0xLG89MTgwK3kqb31yZXR1cm4gb31zdGF0aWMgSXNOZWFyKGUsdCxyKXtyZXR1cm4gTHQuTGVuKGUuY2xvbmUoKS5zdWIodCkpPHJ9c3RhdGljIFJvdFdpdGgoZSx0LHIsbj0yKXtjb25zdCBkPWUueC10LngsZz1lLnktdC55LHU9TWF0aC5zaW4ociksbz1NYXRoLmNvcyhyKSxjPU1hdGgucG93KDEwLG4pLHA9TWF0aC5mbG9vcigodC54KyhkKm8tZyp1KSkqYykvYyxsPU1hdGguZmxvb3IoKHQueSsoZCp1K2cqbykpKmMpL2M7cmV0dXJuIG5ldyBMdChwLGwpfXN0YXRpYyBHZXREb3RTdHJva2UoZSx0LHI9MTYpe2NvbnN0IG49bmV3IGN0KDEsMSksZD1NYXRoLlBJKy4wMDEsZz1MdC5BZGQoZSxMdC5TdWIoZSxuKS51bmkoKS5wZXIoKS5tdWwoLXQpKSx1PVtdO2ZvcihsZXQgbz0xL3IsYz1vO2M8PTE7Yys9byl1LnB1c2goTHQuUm90V2l0aChnLGUsZCoyKmMpKTtyZXR1cm4gdX1zdGF0aWMgR2V0U2VtaWNpcmNsZVN0cm9rZShlLHQscj0tMSxuPTgpe2NvbnN0IGQ9ciooTWF0aC5QSSsuMDAxKSxnPVtdO2ZvcihsZXQgdT0xL24sbz11O288PTE7bys9dSlnLnB1c2goTHQuUm90V2l0aCh0LGUsZCpvKSk7cmV0dXJuIGd9fXZhciBucjsoZnVuY3Rpb24oaCl7aFtoLnBlZGRpbmc9MF09InBlZGRpbmciLGhbaC5tb3VudGVkPTFdPSJtb3VudGVkIixoW2gudXBkYXRlPTJdPSJ1cGRhdGUiLGhbaC51bm1vdW50ZWQ9M109InVubW91bnRlZCJ9KShucnx8KG5yPXt9KSk7dmFyIER0OyhmdW5jdGlvbihoKXtoW2guTm9ybWFsPTBdPSJOb3JtYWwiLGhbaC5TdHJva2U9MV09IlN0cm9rZSIsaFtoLkRvdHRlZD0yXT0iRG90dGVkIixoW2guTG9uZ0RvdHRlZD0zXT0iTG9uZ0RvdHRlZCJ9KShEdHx8KER0PXt9KSk7dmFyIGJ0OyhmdW5jdGlvbihoKXtoLlNob3dGbG9hdEJhcj0iU2hvd0Zsb2F0QmFyIixoLlpJbmRleEZsb2F0QmFyPSJaSW5kZXhGbG9hdEJhciIsaC5EZWxldGVOb2RlPSJEZWxldGVOb2RlIixoLkNvcHlOb2RlPSJDb3B5Tm9kZSIsaC5aSW5kZXhBY3RpdmU9IlpJbmRleEFjdGl2ZSIsaC5aSW5kZXhOb2RlPSJaSW5kZXhOb2RlIixoLlJvdGF0ZU5vZGU9IlJvdGF0ZU5vZGUiLGguU2V0Q29sb3JOb2RlPSJTZXRDb2xvck5vZGUiLGguVHJhbnNsYXRlTm9kZT0iVHJhbnNsYXRlTm9kZSIsaC5TY2FsZU5vZGU9IlNjYWxlTm9kZSIsaC5PcmlnaW5hbEV2ZW50PSJPcmlnaW5hbEV2ZW50IixoLkNyZWF0ZVNjZW5lPSJjcmVhdGVTY2VuZSJ9KShidHx8KGJ0PXt9KSk7dmFyIGlyOyhmdW5jdGlvbihoKXtoLkRpc3BsYXlTdGF0ZT0iRGlzcGxheVN0YXRlIixoLkZsb2F0QmFyPSJGbG9hdEJhciIsaC5DYW52YXNTZWxlY3Rvcj0iQ2FudmFzU2VsZWN0b3IiLGguTWFpbkVuZ2luZT0iTWFpbkVuZ2luZSIsaC5EaXNwbGF5Q29udGFpbmVyPSJEaXNwbGF5Q29udGFpbmVyIn0pKGlyfHwoaXI9e30pKTtmdW5jdGlvbiBUdChoLGUpe2lmKGgmJmUpe2NvbnN0IHQ9TWF0aC5taW4oaD09bnVsbD92b2lkIDA6aC54LGUueCkscj1NYXRoLm1pbihoPT1udWxsP3ZvaWQgMDpoLnksZS55KSxuPU1hdGgubWF4KGgueCtoLncsZS54K2UudyksZD1NYXRoLm1heChoLnkraC5oLGUueStlLmgpLGc9bi10LHU9ZC1yO3JldHVybnt4OnQseTpyLHc6ZyxoOnV9fXJldHVybiBlfHxofWZ1bmN0aW9uIEp0KGgsZT0wKXtjb25zdCB0PXt4OjAseTowLHc6MCxoOjB9O2xldCByPTEvMCxuPTEvMCxkPS0xLzAsZz0tMS8wO3JldHVybiBoLmZvckVhY2godT0+e2NvbnN0W28sY109dS5YWTtyPU1hdGgubWluKHIsby1lKSxuPU1hdGgubWluKG4sYy1lKSxkPU1hdGgubWF4KGQsbytlKSxnPU1hdGgubWF4KGcsYytlKX0pLHQueD1yLHQueT1uLHQudz1kLXIsdC5oPWctbix0fWZ1bmN0aW9uIEllKGgsZSl7cmV0dXJuIShoLngraC53PGUueHx8aC54PmUueCtlLnd8fGgueStoLmg8ZS55fHxoLnk+ZS55K2UuaCl9ZnVuY3Rpb24gYW4oaCxlKXtyZXR1cm4gaC5sZW5ndGg9PT1lLmxlbmd0aCYmaC5zb3J0KCkudG9TdHJpbmcoKT09PWUuc29ydCgpLnRvU3RyaW5nKCl9ZnVuY3Rpb24gbG4oaCxlPTEwKXtyZXR1cm57eDpNYXRoLmZsb29yKGgueC1lKSx5Ok1hdGguZmxvb3IoaC55LWUpLHc6TWF0aC5mbG9vcihoLncrZSoyKSxoOk1hdGguZmxvb3IoaC5oK2UqMil9fWZ1bmN0aW9uIGZuKGgsZSl7Y29uc3QgdD1uZXcgY3QoaC54LGgueSkscj1uZXcgY3QoaC54K2gudyxoLnkpLG49bmV3IGN0KGgueCtoLncsaC55K2guaCksZD1uZXcgY3QoaC54LGgueStoLmgpLGc9bmV3IGN0KGgueCtoLncvMixoLnkraC5oLzIpLHU9TWF0aC5QSSplLzE4MCxvPWN0LlJvdFdpdGgodCxnLHUpLGM9Y3QuUm90V2l0aChyLGcsdSkscD1jdC5Sb3RXaXRoKG4sZyx1KSxsPWN0LlJvdFdpdGgoZCxnLHUpO3JldHVybiBKdChbbyxjLHAsbF0pfWZ1bmN0aW9uIGNuKGgsZSl7Y29uc3QgdD1uZXcgY3QoaC54LGgueSkscj1uZXcgY3QoaC54K2gudyxoLnkpLG49bmV3IGN0KGgueCtoLncsaC55K2guaCksZD1uZXcgY3QoaC54LGgueStoLmgpLGc9bmV3IGN0KGgueCtoLncvMixoLnkraC5oLzIpLHU9bmV3IGN0KGVbMF0sZVsxXSksbz1jdC5TY2FsZVdPcmlnaW4odCx1LGcpLGM9Y3QuU2NhbGVXT3JpZ2luKHIsdSxnKSxwPWN0LlNjYWxlV09yaWdpbihuLHUsZyksbD1jdC5TY2FsZVdPcmlnaW4oZCx1LGcpO3JldHVybiBKdChbbyxjLHAsbF0pfWZ1bmN0aW9uIHVuKGgsZSx0KXtjb25zdCByPW5ldyBjdChlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248aC5sZW5ndGg7bis9Myl7Y29uc3QgZD1uZXcgY3QoaFtuXSxoW24rMV0pLGc9TWF0aC5QSSp0LzE4MCx1PWN0LlJvdFdpdGgoZCxyLGcpO2hbbl09dS54LGhbbisxXT11Lnl9fWZ1bmN0aW9uIGhuKGgsZSx0KXtjb25zdCByPW5ldyBjdChlWzBdLGVbMV0pO2ZvcihsZXQgbj0wO248aC5sZW5ndGg7bis9Myl7Y29uc3QgZD1uZXcgY3QoaFtuXSxoW24rMV0pLGc9bmV3IGN0KHRbMF0sdFsxXSk7aWYobjxoLmxlbmd0aC0zKXtjb25zdCBvPW5ldyBjdChoW24rM10saFtuKzRdKSxjPWN0LlRhbihvLGQpLnBlcigpLm11bChoW24rMl0pLm11bFYoZykubGVuKCk7aFtuKzJdPWN9ZWxzZSBpZihuPT09aC5sZW5ndGgtMyl7Y29uc3Qgbz1uZXcgY3QoaFtuLTNdLGhbbi0yXSksYz1jdC5UYW4oZCxvKS5wZXIoKS5tdWwoaFtuKzJdKS5tdWxWKGcpLmxlbigpO2hbbisyXT1jfWNvbnN0IHU9Y3QuU2NhbGVXT3JpZ2luKGQsZyxyKTtoW25dPXUueCxoW24rMV09dS55fX1mdW5jdGlvbiBYdChoLGUpe2xldCB0O3JldHVybiBlPT1udWxsfHxlLmdldEVsZW1lbnRzQnlOYW1lKGgpLmZvckVhY2gocj0+e2lmKHIudGFnTmFtZT09PSJQQVRIIil7Y29uc3Qgbj1yPT1udWxsP3ZvaWQgMDpyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO24mJih0PVR0KHQse3g6TWF0aC5mbG9vcihuLngpLHk6TWF0aC5mbG9vcihuLnkpLHc6TWF0aC5yb3VuZChuLndpZHRoKSxoOk1hdGgucm91bmQobi5oZWlnaHQpfSkpfWVsc2UgaWYoci50YWdOYW1lPT09IkdST1VQIil7Y29uc3Qgbj1yLmNsYXNzTmFtZS5zcGxpdCgiLCIpO2lmKG4ubGVuZ3RoPT09MyYmTnVtYmVyKG5bMl0pPT09RHQuU3Ryb2tlKXtjb25zdCBkPXI9PW51bGw/dm9pZCAwOnIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7ZCYmKHQ9VHQodCx7eDpNYXRoLmZsb29yKGQueCkseTpNYXRoLmZsb29yKGQueSksdzpNYXRoLnJvdW5kKGQud2lkdGgpLGg6TWF0aC5yb3VuZChkLmhlaWdodCl9KSl9ZWxzZSByLmNoaWxkcmVuLmZvckVhY2goZD0+e2lmKGQudGFnTmFtZT09PSJQQVRIIil7Y29uc3QgZz1kPT1udWxsP3ZvaWQgMDpkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2cmJih0PVR0KHQse3g6TWF0aC5mbG9vcihnLngpLHk6TWF0aC5mbG9vcihnLnkpLHc6TWF0aC5yb3VuZChnLndpZHRoKSxoOk1hdGgucm91bmQoZy5oZWlnaHQpfSkpfX0pfX0pLHR9ZnVuY3Rpb24gX3QoaCl7cmV0dXJuYCR7Z2UoaC54KX0sJHtnZShoLnkpfSBgfWZ1bmN0aW9uIHRlKGgsZSl7cmV0dXJuYCR7Z2UoKGgueCtlLngpLzIpfSwke2dlKChoLnkrZS55KS8yKX0gYH1mdW5jdGlvbiBnZShoKXtyZXR1cm4raC50b0ZpeGVkKDQpfWZ1bmN0aW9uIG1lKGgsZT0hMCl7Y29uc3QgdD1oLmxlbmd0aDtpZih0PDIpcmV0dXJuIiI7bGV0IHI9aFswXSxuPWhbMV07aWYodD09PTIpcmV0dXJuYE0ke190KHIpfUwke190KG4pfWA7bGV0IGQ9IiI7Zm9yKGxldCBnPTIsdT10LTE7Zzx1O2crKylyPWhbZ10sbj1oW2crMV0sZCs9dGUocixuKTtyZXR1cm4gZT9gTSR7dGUoaFswXSxoWzFdKX1RJHtfdChoWzFdKX0ke3RlKGhbMV0saFsyXSl9VCR7ZH0ke3RlKGhbdC0xXSxoWzBdKX0ke3RlKGhbMF0saFsxXSl9WmA6YE0ke190KGhbMF0pfVEke190KGhbMV0pfSR7dGUoaFsxXSxoWzJdKX0ke2gubGVuZ3RoPjM/IlQiOiIifSR7ZH1MJHtfdChoW3QtMV0pfWB9dmFyIHZlPXR5cGVvZiBnbG9iYWxUaGlzPCJ1Ij9nbG9iYWxUaGlzOnR5cGVvZiB3aW5kb3c8InUiP3dpbmRvdzp0eXBlb2YgZ2xvYmFsPCJ1Ij9nbG9iYWw6dHlwZW9mIHNlbGY8InUiP3NlbGY6e307ZnVuY3Rpb24gc3IoaCl7cmV0dXJuIGgmJmguX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGgsImRlZmF1bHQiKT9oLmRlZmF1bHQ6aH12YXIgTmU9e2V4cG9ydHM6e319O05lLmV4cG9ydHMsZnVuY3Rpb24oaCl7dmFyIGU9ZnVuY3Rpb24oKXt2YXIgdD1TdHJpbmcuZnJvbUNoYXJDb2RlLHI9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89IixuPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSstJCIsZD17fTtmdW5jdGlvbiBnKG8sYyl7aWYoIWRbb10pe2Rbb109e307Zm9yKHZhciBwPTA7cDxvLmxlbmd0aDtwKyspZFtvXVtvLmNoYXJBdChwKV09cH1yZXR1cm4gZFtvXVtjXX12YXIgdT17Y29tcHJlc3NUb0Jhc2U2NDpmdW5jdGlvbihvKXtpZihvPT1udWxsKXJldHVybiIiO3ZhciBjPXUuX2NvbXByZXNzKG8sNixmdW5jdGlvbihwKXtyZXR1cm4gci5jaGFyQXQocCl9KTtzd2l0Y2goYy5sZW5ndGglNCl7ZGVmYXVsdDpjYXNlIDA6cmV0dXJuIGM7Y2FzZSAxOnJldHVybiBjKyI9PT0iO2Nhc2UgMjpyZXR1cm4gYysiPT0iO2Nhc2UgMzpyZXR1cm4gYysiPSJ9fSxkZWNvbXByZXNzRnJvbUJhc2U2NDpmdW5jdGlvbihvKXtyZXR1cm4gbz09bnVsbD8iIjpvPT0iIj9udWxsOnUuX2RlY29tcHJlc3Moby5sZW5ndGgsMzIsZnVuY3Rpb24oYyl7cmV0dXJuIGcocixvLmNoYXJBdChjKSl9KX0sY29tcHJlc3NUb1VURjE2OmZ1bmN0aW9uKG8pe3JldHVybiBvPT1udWxsPyIiOnUuX2NvbXByZXNzKG8sMTUsZnVuY3Rpb24oYyl7cmV0dXJuIHQoYyszMil9KSsiICJ9LGRlY29tcHJlc3NGcm9tVVRGMTY6ZnVuY3Rpb24obyl7cmV0dXJuIG89PW51bGw/IiI6bz09IiI/bnVsbDp1Ll9kZWNvbXByZXNzKG8ubGVuZ3RoLDE2Mzg0LGZ1bmN0aW9uKGMpe3JldHVybiBvLmNoYXJDb2RlQXQoYyktMzJ9KX0sY29tcHJlc3NUb1VpbnQ4QXJyYXk6ZnVuY3Rpb24obyl7Zm9yKHZhciBjPXUuY29tcHJlc3MobykscD1uZXcgVWludDhBcnJheShjLmxlbmd0aCoyKSxsPTAseT1jLmxlbmd0aDtsPHk7bCsrKXt2YXIgeD1jLmNoYXJDb2RlQXQobCk7cFtsKjJdPXg+Pj44LHBbbCoyKzFdPXglMjU2fXJldHVybiBwfSxkZWNvbXByZXNzRnJvbVVpbnQ4QXJyYXk6ZnVuY3Rpb24obyl7aWYobz09bnVsbClyZXR1cm4gdS5kZWNvbXByZXNzKG8pO2Zvcih2YXIgYz1uZXcgQXJyYXkoby5sZW5ndGgvMikscD0wLGw9Yy5sZW5ndGg7cDxsO3ArKyljW3BdPW9bcCoyXSoyNTYrb1twKjIrMV07dmFyIHk9W107cmV0dXJuIGMuZm9yRWFjaChmdW5jdGlvbih4KXt5LnB1c2godCh4KSl9KSx1LmRlY29tcHJlc3MoeS5qb2luKCIiKSl9LGNvbXByZXNzVG9FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKG8pe3JldHVybiBvPT1udWxsPyIiOnUuX2NvbXByZXNzKG8sNixmdW5jdGlvbihjKXtyZXR1cm4gbi5jaGFyQXQoYyl9KX0sZGVjb21wcmVzc0Zyb21FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKG8pe3JldHVybiBvPT1udWxsPyIiOm89PSIiP251bGw6KG89by5yZXBsYWNlKC8gL2csIisiKSx1Ll9kZWNvbXByZXNzKG8ubGVuZ3RoLDMyLGZ1bmN0aW9uKGMpe3JldHVybiBnKG4sby5jaGFyQXQoYykpfSkpfSxjb21wcmVzczpmdW5jdGlvbihvKXtyZXR1cm4gdS5fY29tcHJlc3MobywxNixmdW5jdGlvbihjKXtyZXR1cm4gdChjKX0pfSxfY29tcHJlc3M6ZnVuY3Rpb24obyxjLHApe2lmKG89PW51bGwpcmV0dXJuIiI7dmFyIGwseSx4PXt9LGI9e30sRT0iIix2PSIiLE09IiIsaT0yLGE9MyxzPTIsZj1bXSxPPTAsQT0wLFI7Zm9yKFI9MDtSPG8ubGVuZ3RoO1IrPTEpaWYoRT1vLmNoYXJBdChSKSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCxFKXx8KHhbRV09YSsrLGJbRV09ITApLHY9TStFLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LHYpKU09djtlbHNle2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLE0pKXtpZihNLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IobD0wO2w8cztsKyspTz1PPDwxLEE9PWMtMT8oQT0wLGYucHVzaChwKE8pKSxPPTApOkErKztmb3IoeT1NLmNoYXJDb2RlQXQoMCksbD0wO2w8ODtsKyspTz1PPDwxfHkmMSxBPT1jLTE/KEE9MCxmLnB1c2gocChPKSksTz0wKTpBKysseT15Pj4xfWVsc2V7Zm9yKHk9MSxsPTA7bDxzO2wrKylPPU88PDF8eSxBPT1jLTE/KEE9MCxmLnB1c2gocChPKSksTz0wKTpBKysseT0wO2Zvcih5PU0uY2hhckNvZGVBdCgwKSxsPTA7bDwxNjtsKyspTz1PPDwxfHkmMSxBPT1jLTE/KEE9MCxmLnB1c2gocChPKSksTz0wKTpBKysseT15Pj4xfWktLSxpPT0wJiYoaT1NYXRoLnBvdygyLHMpLHMrKyksZGVsZXRlIGJbTV19ZWxzZSBmb3IoeT14W01dLGw9MDtsPHM7bCsrKU89Tzw8MXx5JjEsQT09Yy0xPyhBPTAsZi5wdXNoKHAoTykpLE89MCk6QSsrLHk9eT4+MTtpLS0saT09MCYmKGk9TWF0aC5wb3coMixzKSxzKyspLHhbdl09YSsrLE09U3RyaW5nKEUpfWlmKE0hPT0iIil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsTSkpe2lmKE0uY2hhckNvZGVBdCgwKTwyNTYpe2ZvcihsPTA7bDxzO2wrKylPPU88PDEsQT09Yy0xPyhBPTAsZi5wdXNoKHAoTykpLE89MCk6QSsrO2Zvcih5PU0uY2hhckNvZGVBdCgwKSxsPTA7bDw4O2wrKylPPU88PDF8eSYxLEE9PWMtMT8oQT0wLGYucHVzaChwKE8pKSxPPTApOkErKyx5PXk+PjF9ZWxzZXtmb3IoeT0xLGw9MDtsPHM7bCsrKU89Tzw8MXx5LEE9PWMtMT8oQT0wLGYucHVzaChwKE8pKSxPPTApOkErKyx5PTA7Zm9yKHk9TS5jaGFyQ29kZUF0KDApLGw9MDtsPDE2O2wrKylPPU88PDF8eSYxLEE9PWMtMT8oQT0wLGYucHVzaChwKE8pKSxPPTApOkErKyx5PXk+PjF9aS0tLGk9PTAmJihpPU1hdGgucG93KDIscykscysrKSxkZWxldGUgYltNXX1lbHNlIGZvcih5PXhbTV0sbD0wO2w8cztsKyspTz1PPDwxfHkmMSxBPT1jLTE/KEE9MCxmLnB1c2gocChPKSksTz0wKTpBKysseT15Pj4xO2ktLSxpPT0wJiYoaT1NYXRoLnBvdygyLHMpLHMrKyl9Zm9yKHk9MixsPTA7bDxzO2wrKylPPU88PDF8eSYxLEE9PWMtMT8oQT0wLGYucHVzaChwKE8pKSxPPTApOkErKyx5PXk+PjE7Zm9yKDs7KWlmKE89Tzw8MSxBPT1jLTEpe2YucHVzaChwKE8pKTticmVha31lbHNlIEErKztyZXR1cm4gZi5qb2luKCIiKX0sZGVjb21wcmVzczpmdW5jdGlvbihvKXtyZXR1cm4gbz09bnVsbD8iIjpvPT0iIj9udWxsOnUuX2RlY29tcHJlc3Moby5sZW5ndGgsMzI3NjgsZnVuY3Rpb24oYyl7cmV0dXJuIG8uY2hhckNvZGVBdChjKX0pfSxfZGVjb21wcmVzczpmdW5jdGlvbihvLGMscCl7dmFyIGw9W10seT00LHg9NCxiPTMsRT0iIix2PVtdLE0saSxhLHMsZixPLEEsUj17dmFsOnAoMCkscG9zaXRpb246YyxpbmRleDoxfTtmb3IoTT0wO008MztNKz0xKWxbTV09TTtmb3IoYT0wLGY9TWF0aC5wb3coMiwyKSxPPTE7TyE9Zjspcz1SLnZhbCZSLnBvc2l0aW9uLFIucG9zaXRpb24+Pj0xLFIucG9zaXRpb249PTAmJihSLnBvc2l0aW9uPWMsUi52YWw9cChSLmluZGV4KyspKSxhfD0ocz4wPzE6MCkqTyxPPDw9MTtzd2l0Y2goYSl7Y2FzZSAwOmZvcihhPTAsZj1NYXRoLnBvdygyLDgpLE89MTtPIT1mOylzPVIudmFsJlIucG9zaXRpb24sUi5wb3NpdGlvbj4+PTEsUi5wb3NpdGlvbj09MCYmKFIucG9zaXRpb249YyxSLnZhbD1wKFIuaW5kZXgrKykpLGF8PShzPjA/MTowKSpPLE88PD0xO0E9dChhKTticmVhaztjYXNlIDE6Zm9yKGE9MCxmPU1hdGgucG93KDIsMTYpLE89MTtPIT1mOylzPVIudmFsJlIucG9zaXRpb24sUi5wb3NpdGlvbj4+PTEsUi5wb3NpdGlvbj09MCYmKFIucG9zaXRpb249YyxSLnZhbD1wKFIuaW5kZXgrKykpLGF8PShzPjA/MTowKSpPLE88PD0xO0E9dChhKTticmVhaztjYXNlIDI6cmV0dXJuIiJ9Zm9yKGxbM109QSxpPUEsdi5wdXNoKEEpOzspe2lmKFIuaW5kZXg+bylyZXR1cm4iIjtmb3IoYT0wLGY9TWF0aC5wb3coMixiKSxPPTE7TyE9Zjspcz1SLnZhbCZSLnBvc2l0aW9uLFIucG9zaXRpb24+Pj0xLFIucG9zaXRpb249PTAmJihSLnBvc2l0aW9uPWMsUi52YWw9cChSLmluZGV4KyspKSxhfD0ocz4wPzE6MCkqTyxPPDw9MTtzd2l0Y2goQT1hKXtjYXNlIDA6Zm9yKGE9MCxmPU1hdGgucG93KDIsOCksTz0xO08hPWY7KXM9Ui52YWwmUi5wb3NpdGlvbixSLnBvc2l0aW9uPj49MSxSLnBvc2l0aW9uPT0wJiYoUi5wb3NpdGlvbj1jLFIudmFsPXAoUi5pbmRleCsrKSksYXw9KHM+MD8xOjApKk8sTzw8PTE7bFt4KytdPXQoYSksQT14LTEseS0tO2JyZWFrO2Nhc2UgMTpmb3IoYT0wLGY9TWF0aC5wb3coMiwxNiksTz0xO08hPWY7KXM9Ui52YWwmUi5wb3NpdGlvbixSLnBvc2l0aW9uPj49MSxSLnBvc2l0aW9uPT0wJiYoUi5wb3NpdGlvbj1jLFIudmFsPXAoUi5pbmRleCsrKSksYXw9KHM+MD8xOjApKk8sTzw8PTE7bFt4KytdPXQoYSksQT14LTEseS0tO2JyZWFrO2Nhc2UgMjpyZXR1cm4gdi5qb2luKCIiKX1pZih5PT0wJiYoeT1NYXRoLnBvdygyLGIpLGIrKyksbFtBXSlFPWxbQV07ZWxzZSBpZihBPT09eClFPWkraS5jaGFyQXQoMCk7ZWxzZSByZXR1cm4gbnVsbDt2LnB1c2goRSksbFt4KytdPWkrRS5jaGFyQXQoMCkseS0tLGk9RSx5PT0wJiYoeT1NYXRoLnBvdygyLGIpLGIrKyl9fX07cmV0dXJuIHV9KCk7aCE9bnVsbD9oLmV4cG9ydHM9ZTp0eXBlb2YgYW5ndWxhcjwidSImJmFuZ3VsYXIhPW51bGwmJmFuZ3VsYXIubW9kdWxlKCJMWlN0cmluZyIsW10pLmZhY3RvcnkoIkxaU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBlfSl9KE5lKTt2YXIgb3I9TmUuZXhwb3J0cztmdW5jdGlvbiBlZShoKXtyZXR1cm4gSlNPTi5wYXJzZShvci5kZWNvbXByZXNzKGgpKX1mdW5jdGlvbiB5ZShoKXtyZXR1cm4gb3IuY29tcHJlc3MoSlNPTi5zdHJpbmdpZnkoaCkpfWNsYXNzIGp0IGV4dGVuZHMgZGV7Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKHQsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlN0LlBlbmNpbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiTUFYX1JFUEVBUiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInVuaVRoaWNrbmVzcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjZW50ZXJQb3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbMCwwXX0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnVuaVRoaWNrbmVzcz10aGlzLk1BWF9SRVBFQVIvZS50aGlja25lc3MvMTAsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tYmluZUNvbnN1bWUoKXt2YXIgZDtjb25zdCBlPShkPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6ZC50b1N0cmluZygpLHQ9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCEwKSxyPXtuYW1lOmUsY2xhc3NOYW1lOiJwZW5jaWwifTtsZXQgbjtyZXR1cm4gdC5sZW5ndGgmJihuPXRoaXMuZHJhdyh7YXR0cnM6cix0YXNrczp0LHJlcGxhY2VJZDplLGlzRnVsbFdvcms6ITEsbm9ybWFsaXplOiEwLGlzQ2xlYXJBbGw6ITB9KSkse3JlY3Q6bix0eXBlOnl0LkRyYXdXb3JrLGRhdGFUeXBlOkF0LkxvY2FsfX1zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe3ZhciBFO2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnIsaXNDbGVhckFsbDpuLGlzU3ViV29ya2VyOmR9PWU7aWYoKChFPXQub3ApPT1udWxsP3ZvaWQgMDpFLmxlbmd0aCk9PT0wKXJldHVybnt0eXBlOnl0Lk5vbmV9O2NvbnN0e3dvcmtJZDpnfT10LHt0YXNrczp1LGVmZmVjdHM6byxjb25zdW1lSW5kZXg6Y309dGhpcy50cmFuc2Zvcm1EYXRhKHQsITEpO3RoaXMuc3luY0luZGV4PU1hdGgubWluKHRoaXMuc3luY0luZGV4LGMpO2NvbnN0IHA9e25hbWU6Zz09bnVsbD92b2lkIDA6Zy50b1N0cmluZygpLGNsYXNzTmFtZToicGVuY2lsIn07bGV0IGwseT0hMTtjb25zdCB4PXRoaXMuc3luY0luZGV4O2lmKHRoaXMuc3luY1RpbWVzdGFtcD09PTAmJih0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKSksdS5sZW5ndGgmJih1WzBdLnRhc2tJZC10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWUmJih5PSEwLHRoaXMuc3luY1RpbWVzdGFtcD11WzBdLnRhc2tJZCx0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLGw9dGhpcy5kcmF3KHthdHRyczpwLHRhc2tzOnUsZWZmZWN0czpvLGlzRnVsbFdvcms6cixpc0NsZWFyQWxsOm59KSksZClyZXR1cm4gYz4xMCYmdGhpcy50bXBQb2ludHMuc3BsaWNlKDAsYy0xMCkse3JlY3Q6bCx0eXBlOnl0LkRyYXdXb3JrLGRhdGFUeXBlOkF0LkxvY2FsfTtjb25zdCBiPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh4KS5mb3JFYWNoKHY9PntiLnB1c2godi54LHYueSx0aGlzLmNvbXB1dFJhZGl1cyh2LnosdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MpKX0pLHtyZWN0OmwsdHlwZTp5dC5EcmF3V29yayxkYXRhVHlwZTpBdC5Mb2NhbCx3b3JrSWQ6eT9nOnZvaWQgMCxvcDp5P2I6dm9pZCAwLGluZGV4Onk/eCozOnZvaWQgMH19Y29uc3VtZUFsbChlKXt2YXIgdSxvO2lmKGUuZGF0YSl7Y29uc3R7b3A6Yyx3b3JrU3RhdGU6cH09ZS5kYXRhO2MhPW51bGwmJmMubGVuZ3RoJiZwPT09R3QuRG9uZSYmdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09RHQuU3Ryb2tlJiZ0aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShjKX1jb25zdCB0PSh1PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6dS50b1N0cmluZygpLHI9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCEwKSxuPXtuYW1lOnQsY2xhc3NOYW1lOiJwZW5jaWwifTtsZXQgZDtyLmxlbmd0aCYmKGQ9dGhpcy5kcmF3KHthdHRyczpuLHRhc2tzOnIscmVwbGFjZUlkOnQsaXNGdWxsV29yazohMCxub3JtYWxpemU6ITAsaXNDbGVhckFsbDohMX0pKTtjb25zdCBnPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5tYXAoYz0+e2cucHVzaChjLngsYy55LHRoaXMuY29tcHV0UmFkaXVzKGMueix0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcykpfSksdGhpcy5zeW5jVGltZXN0YW1wPTAse3JlY3Q6ZCx0eXBlOnl0LkZ1bGxXb3JrLGRhdGFUeXBlOkF0LkxvY2FsLHdvcmtJZDp0LG9wczp5ZShnKSx1cGRhdGVOb2RlT3B0Ontwb3M6dGhpcy5jZW50ZXJQb3MsdXNlQW5pbWF0aW9uOiEwfSx1bmRvVGlja2VySWQ6KG89ZS5kYXRhKT09bnVsbD92b2lkIDA6by51bmRvVGlja2VySWR9fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jSW5kZXg9MH1jb25zdW1lU2VydmljZShlKXt2YXIgcDtjb25zdHtvcDp0LGlzRnVsbFdvcms6cixyZXBsYWNlSWQ6bixpc0NsZWFyQWxsOmR9PWU7dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBsPTA7bDx0Lmxlbmd0aDtsKz0zKXtjb25zdCB5PW5ldyBMdCh0W2xdLHRbbCsxXSx0W2wrMl0pO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD4wKXtjb25zdCB4PXRoaXMudG1wUG9pbnRzW3RoaXMudG1wUG9pbnRzLmxlbmd0aC0xXSxiPWN0LlN1Yih5LHgpLnVuaSgpO3kuc2V0dihiKX10aGlzLnRtcFBvaW50cy5wdXNoKHkpfWNvbnN0IGc9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCExKSxvPXtuYW1lOihwPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6cC50b1N0cmluZygpLGNsYXNzTmFtZToicGVuY2lsIn07bGV0IGM7cmV0dXJuIGcubGVuZ3RoJiYoYz10aGlzLmRyYXcoe2F0dHJzOm8sdGFza3M6ZyxyZXBsYWNlSWQ6bixpc0Z1bGxXb3JrOnIsbm9ybWFsaXplOiEwLGlzQ2xlYXJBbGw6ZH0pKSxjfXRyYW5zZm9ybURhdGFBbGwoZT0hMCl7cmV0dXJuIHRoaXMuZ2V0VGFza1BvaW50cyh0aGlzLnRtcFBvaW50cyxlJiZ0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc3x8dm9pZCAwKX1kcmF3KGUpe3ZhciBmO2NvbnN0e2F0dHJzOnQsdGFza3M6cixyZXBsYWNlSWQ6bixlZmZlY3RzOmQsaXNGdWxsV29yazpnLG5vcm1hbGl6ZTp1LGlzQ2xlYXJBbGw6b309ZSxjPWc/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLHtjb2xvcjpwLHN0cm9rZVR5cGU6bCx0aGlja25lc3M6eSxvcGFjaXR5OngsekluZGV4OmIsc2NhbGU6RSxyb3RhdGU6dn09dGhpcy53b3JrT3B0aW9ucztvP2MucmVtb3ZlQWxsQ2hpbGRyZW4oKToobiYmKGMuZ2V0RWxlbWVudHNCeU5hbWUobisiIikubWFwKE89Pk8ucmVtb3ZlKCkpLChmPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8Zi5nZXRFbGVtZW50c0J5TmFtZShuKyIiKS5tYXAoTz0+Ty5yZW1vdmUoKSkpLGQhPW51bGwmJmQuc2l6ZSYmKGQuZm9yRWFjaChPPT57dmFyIEE7KEE9Yy5nZXRFbGVtZW50QnlJZChPKyIiKSk9PW51bGx8fEEucmVtb3ZlKCl9KSxkLmNsZWFyKCkpKTtsZXQgTTtjb25zdCBpPVtdLGE9Yy53b3JsZFBvc2l0aW9uLHM9Yy53b3JsZFNjYWxpbmc7Zm9yKGxldCBPPTA7TzxyLmxlbmd0aDtPKyspe2NvbnN0e3BvczpBLHBvaW50czpSLHRhc2tJZDpJfT1yW09dO3QuaWQ9SS50b1N0cmluZygpO2NvbnN0e3BzOlAscmVjdDpMfT10aGlzLmNvbXB1dERyYXdQb2ludHMoUik7bGV0IEQ7Y29uc3QgQz1SLmxlbmd0aD09PTE7bD09PUR0LlN0cm9rZXx8Qz9EPW1lKFAsITApOkQ9bWUoUCwhMSk7Y29uc3QgUz17cG9zOkEsZDpELGZpbGxDb2xvcjpsPT09RHQuU3Ryb2tlfHxDP3A6dm9pZCAwLGxpbmVEYXNoOmw9PT1EdC5Eb3R0ZWQmJiFDP1sxLHkqMl06bD09PUR0LkxvbmdEb3R0ZWQmJiFDP1t5LHkqMl06dm9pZCAwLHN0cm9rZUNvbG9yOnAsb3BhY2l0eTp4LGxpbmVDYXA6bD09PUR0LlN0cm9rZXx8Qz92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6bD09PUR0LlN0cm9rZXx8Qz8wOnksY2xhc3NOYW1lOmAke0FbMF19LCR7QVsxXX0sJHtsfWB9O2lmKHIubGVuZ3RoPT09MSYmdSl7Y29uc3QgQj1bTC54K0wudy8yLEwueStMLmgvMl07aWYodGhpcy5jZW50ZXJQb3M9W0JbMF0rQVswXSxCWzFdK0FbMV1dLFMubm9ybWFsaXplPSEwLFMucG9zPXRoaXMuY2VudGVyUG9zLFMuY2xhc3NOYW1lPWAke3RoaXMuY2VudGVyUG9zWzBdfSwke3RoaXMuY2VudGVyUG9zWzFdfSwke2x9YCxTLmlkPXQubmFtZSxTLnpJbmRleD1iLEUpe1Muc2NhbGU9RTtjb25zdCB3PWNuKHt4Ok1hdGguZmxvb3IoTC54K0FbMF0rYVswXS1qdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoTC55K0FbMV0rYVsxXS1qdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoTC53KzIqanQuUGVuY2lsQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKEwuaCsyKmp0LlBlbmNpbEJvcmRlclBhZGRpbmcpfSxFKTtNPVR0KE0sdyl9aWYodil7Uy5yb3RhdGU9djtjb25zdCB3PWZuKHt4Ok1hdGguZmxvb3IoTC54K0FbMF0rYVswXS1qdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoTC55K0FbMV0rYVsxXS1qdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoTC53KzIqanQuUGVuY2lsQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKEwuaCsyKmp0LlBlbmNpbEJvcmRlclBhZGRpbmcpfSx2KTtNPVR0KE0sdyl9fU09VHQoTSx7eDpNYXRoLmZsb29yKChMLngrQVswXSkqc1swXSthWzBdLWp0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHk6TWF0aC5mbG9vcigoTC55K0FbMV0pKnNbMV0rYVsxXS1qdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoTC53KnNbMF0rMipqdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSxoOk1hdGguZmxvb3IoTC5oKnNbMV0rMipqdC5QZW5jaWxCb3JkZXJQYWRkaW5nKX0pLGkucHVzaChTKX1pZih1JiZpLmxlbmd0aD4xJiZNKXtjb25zdCBPPW5ldyBMZTt0aGlzLmNlbnRlclBvcz1bKE0ueCtNLncvMi1hWzBdKS9zWzBdLChNLnkrTS5oLzItYVsxXSkvc1sxXV0sTy5hdHRyKHsuLi50LGlkOnQubmFtZSxhbmNob3I6Wy41LC41XSxiZ2NvbG9yOmw9PT1EdC5TdHJva2U/cDp2b2lkIDAsc2NhbGU6RSxvcGFjaXR5OngscG9zOnRoaXMuY2VudGVyUG9zLHJvdGF0ZTp2LGNsYXNzTmFtZTpgJHt0aGlzLmNlbnRlclBvc1swXX0sJHt0aGlzLmNlbnRlclBvc1sxXX0sJHtsfWAsc2l6ZTpbTS53LE0uaF0sekluZGV4OmJ9KSxpLmZvckVhY2goQT0+e0EucG9zPVtBLnBvc1swXS10aGlzLmNlbnRlclBvc1swXSxBLnBvc1sxXS10aGlzLmNlbnRlclBvc1sxXV0sQS5vcGFjaXR5PTE7Y29uc3QgUj1uZXcgRGUoQSk7Ty5hcHBlbmRDaGlsZChSKX0pLGw9PT1EdC5TdHJva2UmJk8uc2VhbCgpLGMuYXBwZW5kKE8pfWVsc2V7Y29uc3QgTz1pLm1hcChBPT5uZXcgRGUoey4uLnQsLi4uQX0pKTtjLmFwcGVuZCguLi5PKX1yZXR1cm4gTX1jb21wdXREcmF3UG9pbnRzKGUpe3JldHVybiB0aGlzLndvcmtPcHRpb25zLnN0cm9rZVR5cGU9PT1EdC5TdHJva2V8fGUubGVuZ3RoPT09MT90aGlzLmNvbXB1dFN0cm9rZShlKTp0aGlzLmNvbXB1dE5vbWFsKGUpfWNvbXB1dE5vbWFsKGUpe2xldCB0PXRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzO2NvbnN0IHI9ZS5tYXAobj0+KHQ9TWF0aC5tYXgodCxuLnJhZGl1cyksbi5wb2ludCkpO3JldHVybntwczpyLHJlY3Q6SnQocix0KX19Y29tcHV0U3Ryb2tlKGUpe3JldHVybiBlLmxlbmd0aD09PTE/dGhpcy5jb21wdXREb3RTdHJva2UoZVswXSk6dGhpcy5jb21wdXRMaW5lU3Ryb2tlKGUpfWNvbXB1dExpbmVTdHJva2UoZSl7Y29uc3QgdD1bXSxyPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7bysrKXtjb25zdHtwb2ludDpjLHJhZGl1czpwfT1lW29dO2xldCBsPWMudjtvPT09MCYmZS5sZW5ndGg+MSYmKGw9ZVtvKzFdLnBvaW50LnYpO2NvbnN0IHk9Y3QuUGVyKGwpLm11bChwKTt0LnB1c2goTHQuU3ViKGMseSkpLHIucHVzaChMdC5BZGQoYyx5KSl9Y29uc3Qgbj1lW2UubGVuZ3RoLTFdLGQ9THQuR2V0U2VtaWNpcmNsZVN0cm9rZShuLnBvaW50LHRbdC5sZW5ndGgtMV0sLTEsOCksZz1MdC5HZXRTZW1pY2lyY2xlU3Ryb2tlKGVbMF0ucG9pbnQsclswXSwtMSw4KSx1PXQuY29uY2F0KGQsci5yZXZlcnNlKCksZyk7cmV0dXJue3BzOnUscmVjdDpKdCh1KX19Y29tcHV0RG90U3Ryb2tlKGUpe2NvbnN0e3BvaW50OnQscmFkaXVzOnJ9PWUsbj17eDp0Lngtcix5OnQueS1yLHc6cioyLGg6cioyfTtyZXR1cm57cHM6THQuR2V0RG90U3Ryb2tlKHQsciw4KSxyZWN0Om59fXRyYW5zZm9ybURhdGEoZSx0KXtjb25zdHtvcDpyLHdvcmtTdGF0ZTpufT1lO2xldCBkPXRoaXMudG1wUG9pbnRzLmxlbmd0aC0xLGc9W107aWYociE9bnVsbCYmci5sZW5ndGgmJm4pe2NvbnN0e3N0cm9rZVR5cGU6dSx0aGlja25lc3M6b309dGhpcy53b3JrT3B0aW9ucyxjPW5ldyBTZXQ7ZD11PT09RHQuU3Ryb2tlP3RoaXMudXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShyLG8sYyk6dGhpcy51cGRhdGVUZW1wUG9pbnRzKHIsbyxjKTtjb25zdCBwPXQ/dGhpcy50bXBQb2ludHM6dGhpcy50bXBQb2ludHMuc2xpY2UoZCk7cmV0dXJuIGc9dGhpcy5nZXRUYXNrUG9pbnRzKHAsbykse3Rhc2tzOmcsZWZmZWN0czpjLGNvbnN1bWVJbmRleDpkfX1yZXR1cm57dGFza3M6Zyxjb25zdW1lSW5kZXg6ZH19Y29tcHV0UmFkaXVzKGUsdCl7cmV0dXJuIGUqLjAzKnQrdCouNX1nZXRNaW5aKGUsdCl7cmV0dXJuKCh0fHxNYXRoLm1heCgxLE1hdGguZmxvb3IoZSouMykpKS1lKi41KSoxMDAvZS8zfWdldFRhc2tQb2ludHMoZSx0KXt2YXIgcDtjb25zdCByPVtdO2lmKGUubGVuZ3RoPT09MClyZXR1cm5bXTtsZXQgbj0wLGQ9ZVswXS54LGc9ZVswXS55LHU9W2QsZ10sbz1bXSxjPWVbMF0udDtmb3IoO248ZS5sZW5ndGg7KXtjb25zdCBsPWVbbl0seT1sLngtZCx4PWwueS1nLGI9bC56LEU9dD90aGlzLmNvbXB1dFJhZGl1cyhiLHQpOmI7aWYoby5wdXNoKHtwb2ludDpuZXcgTHQoeSx4LGIsZVtuXS52KSxyYWRpdXM6RX0pLG4+MCYmbjxlLmxlbmd0aC0xKXtjb25zdCB2PWVbbl0uZ2V0QW5nbGVCeVBvaW50cyhlW24tMV0sZVtuKzFdKTtpZih2PDkwfHx2PjI3MCl7Y29uc3QgTT0ocD1vLnBvcCgpKT09bnVsbD92b2lkIDA6cC5wb2ludC5jbG9uZSgpO00mJnIucHVzaCh7dGFza0lkOmMscG9zOnUscG9pbnRzOlsuLi5vLHtwb2ludDpNLHJhZGl1czpFfV19KSxkPWVbbl0ueCxnPWVbbl0ueSx1PVtkLGddO2NvbnN0IGk9bC54LWQsYT1sLnktZztvPVt7cG9pbnQ6bmV3IEx0KGksYSxiKSxyYWRpdXM6RX1dLGM9RGF0ZS5ub3coKX19bisrfXJldHVybiByLnB1c2goe3Rhc2tJZDpjLHBvczp1LHBvaW50czpvfSkscn11cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlKGUsdCxyKXtjb25zdCBuPURhdGUubm93KCksZD10aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGc9ZDtmb3IobGV0IG89MDtvPGUubGVuZ3RoO28rPTIpe2c9TWF0aC5taW4oZyxkKTtjb25zdCBjPXRoaXMudG1wUG9pbnRzLmxlbmd0aCxwPW5ldyBMdChlW29dLGVbbysxXSk7aWYoYz09PTApe3RoaXMudG1wUG9pbnRzLnB1c2gocCk7Y29udGludWV9Y29uc3QgbD1jLTEseT10aGlzLnRtcFBvaW50c1tsXSx4PWN0LlN1YihwLHkpLnVuaSgpO2lmKHAuaXNOZWFyKHksdCkpe2lmKHkuejx0aGlzLk1BWF9SRVBFQVIpe2lmKHkuc2V0eihNYXRoLm1pbih5LnorMSx0aGlzLk1BWF9SRVBFQVIpKSxnPU1hdGgubWluKGcsbCksYz4xKXtsZXQgdj1jLTE7Zm9yKDt2PjA7KXtjb25zdCBNPXRoaXMudG1wUG9pbnRzW3ZdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzW3YtMV0pLGk9TWF0aC5tYXgodGhpcy50bXBQb2ludHNbdl0uei10aGlzLnVuaVRoaWNrbmVzcypNLDApO2lmKHRoaXMudG1wUG9pbnRzW3YtMV0uej49aSlicmVhazt0aGlzLnRtcFBvaW50c1t2LTFdLnNldHooaSksZz1NYXRoLm1pbihnLHYtMSksdi0tfX19ZWxzZSBnPTEvMDtjb250aW51ZX1wLnNldHYoeCk7Y29uc3QgYj1wLmRpc3RhbmNlKHkpLEU9TWF0aC5tYXgoeS56LXRoaXMudW5pVGhpY2tuZXNzKmIsMCk7Yz4xJiZjdC5FcXVhbHMoeCx5LnYsLjAyKSYmKEU+MHx8eS56PD0wKSYmKHImJnkudCYmci5hZGQoeS50KSx0aGlzLnRtcFBvaW50cy5wb3AoKSxnPU1hdGgubWluKGwsZykpLHAuc2V0eihFKSx0aGlzLnRtcFBvaW50cy5wdXNoKHApfWlmKGc9PT0xLzApcmV0dXJuIHRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgdT1kO2lmKGc9PT1kKXt1PU1hdGgubWF4KHUtMSwwKTtjb25zdCBvPXRoaXMudG1wUG9pbnRzW3VdLnQ7byYmKHI9PW51bGx8fHIuYWRkKG8pKX1lbHNle2xldCBvPWQtMTtmb3IodT1nO28+PTA7KXtjb25zdCBjPXRoaXMudG1wUG9pbnRzW29dLnQ7aWYoYyYmKHI9PW51bGx8fHIuYWRkKGMpLG88PWcpKXt1PW8sbz0tMTticmVha31vLS19fXJldHVybiB0aGlzLnRtcFBvaW50c1t1XS5zZXRUKG4pLHV9dXBkYXRlVGVtcFBvaW50cyhlLHQscil7dmFyIG87Y29uc3Qgbj1EYXRlLm5vdygpLGQ9dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBnPWQ7Zm9yKGxldCBjPTA7YzxlLmxlbmd0aDtjKz0yKXtjb25zdCBwPXRoaXMudG1wUG9pbnRzLmxlbmd0aCxsPW5ldyBMdChlW2NdLGVbYysxXSk7aWYocD09PTApe3RoaXMudG1wUG9pbnRzLnB1c2gobCk7Y29udGludWV9Y29uc3QgeT1wLTEseD10aGlzLnRtcFBvaW50c1t5XSxiPWN0LlN1YihsLHgpLnVuaSgpO2lmKGN0LkVxdWFscyhiLHgudiwuMDIpKXtyJiZ4LnQmJnIuYWRkKHgudCksdGhpcy50bXBQb2ludHMucG9wKCksZz1NYXRoLm1pbih5LGcpO2NvbnRpbnVlfWlmKGwuaXNOZWFyKHgsdC8yKSl7Zz1NYXRoLm1pbih5LGcpO2NvbnRpbnVlfWwuc2V0dihiKSx0aGlzLnRtcFBvaW50cy5wdXNoKGwpfWxldCB1PWQ7aWYoZz09PWQpe3U9TWF0aC5tYXgodS0xLDApO2NvbnN0IGM9dGhpcy50bXBQb2ludHNbdV0udDtjJiYocj09bnVsbHx8ci5hZGQoYykpfWVsc2V7bGV0IGM9TWF0aC5taW4oZC0xLGcpO2Zvcih1PWc7Yz49MDspe2NvbnN0IHA9KG89dGhpcy50bXBQb2ludHNbY10pPT1udWxsP3ZvaWQgMDpvLnQ7aWYocCYmKHI9PW51bGx8fHIuYWRkKHApLGM8PWcpKXt1PWMsYz0tMTticmVha31jLS19fXJldHVybiB0aGlzLnRtcFBvaW50c1t1XS5zZXRUKG4pLHV9dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZVdoZW5Eb25lKGUpe2NvbnN0e3RoaWNrbmVzczp0fT10aGlzLndvcmtPcHRpb25zLHI9ZS5sZW5ndGgsbj10aGlzLmdldE1pbloodCk7Zm9yKGxldCBkPTA7ZDxyO2QrPTIpe2NvbnN0IGc9dGhpcy50bXBQb2ludHMubGVuZ3RoLHU9bmV3IEx0KGVbZF0sZVtkKzFdKTtpZihnPT09MCl7dGhpcy50bXBQb2ludHMucHVzaCh1KTtjb250aW51ZX1jb25zdCBvPWctMSxjPXRoaXMudG1wUG9pbnRzW29dLHA9Y3QuU3ViKHUsYykudW5pKCksbD11LmRpc3RhbmNlKGMpO2lmKGc+MSYmYy56PT09bilicmVhaztpZih1LmlzTmVhcihjLHQvMikpe2lmKHI8MyYmYy56PHRoaXMuTUFYX1JFUEVBUiYmKGMuc2V0eihNYXRoLm1pbihjLnorMSx0aGlzLk1BWF9SRVBFQVIpKSxnPjEpKXtsZXQgeD1nLTE7Zm9yKDt4PjA7KXtjb25zdCBiPXRoaXMudG1wUG9pbnRzW3hdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzW3gtMV0pLEU9TWF0aC5tYXgodGhpcy50bXBQb2ludHNbeF0uei10aGlzLnVuaVRoaWNrbmVzcypiLC10LzQpO2lmKHRoaXMudG1wUG9pbnRzW3gtMV0uej49RSlicmVhazt0aGlzLnRtcFBvaW50c1t4LTFdLnNldHooRSkseC0tfX1jb250aW51ZX11LnNldHYocCk7Y29uc3QgeT1NYXRoLm1heChjLnotdGhpcy51bmlUaGlja25lc3MqbCxuKTtnPjEmJmN0LkVxdWFscyhwLGMudiwuMDIpJiZjLno8PTAmJnRoaXMudG1wUG9pbnRzLnBvcCgpLHUuc2V0eih5KSx0aGlzLnRtcFBvaW50cy5wdXNoKHUpfX11cGRhdGFPcHRTZXJ2aWNlKGUpe3ZhciBuO2xldCB0O2NvbnN0IHI9KG49dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpuLnRvU3RyaW5nKCk7aWYociYmZSl7Y29uc3QgZD10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShyKSx7cG9zOmcsekluZGV4OnUsY29sb3I6byxzY2FsZTpjLGFuZ2xlOnAsb3BhY2l0eTpsfT1lLHk9e307aWYodHlwZW9mIHU9PSJudW1iZXIiJiYoeS56SW5kZXg9dSksZyYmKHkucG9zPVtnWzBdLGdbMV1dLGRbMF0pKXtjb25zdCB4PWRbMF0uY2xhc3NOYW1lLnNwbGl0KCIsIik7eS5jbGFzc05hbWU9YCR7Z1swXX0sJHtnWzFdfSwke3hbMl19YH1yZXR1cm4gbyYmKHkuc3Ryb2tlQ29sb3I9byksYyYmKHkuc2NhbGU9YyksbCYmKHkub3BhY2l0eT1sKSxwJiYoeS5yb3RhdGU9cCksT2JqZWN0LmtleXMoeSkubGVuZ3RoJiZkLmZvckVhY2goeD0+e2NvbnN0IGI9eC5hdHRyKCJmaWxsQ29sb3IiKTtvJiZiP3guYXR0cih7Li4ueSxmaWxsQ29sb3I6b30pOnguYXR0cih5KTtjb25zdCBFPXg9PW51bGw/dm9pZCAwOnguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7RSYmKHQ9VHQodCx7eDpNYXRoLmZsb29yKEUueC1qdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoRS55LWp0LlBlbmNpbEJvcmRlclBhZGRpbmcpLHc6TWF0aC5mbG9vcihFLndpZHRoK2p0LlBlbmNpbEJvcmRlclBhZGRpbmcqMiksaDpNYXRoLmZsb29yKEUuaGVpZ2h0K2p0LlBlbmNpbEJvcmRlclBhZGRpbmcqMil9KSl9KSx0fX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGp0LCJQZW5jaWxCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KTt2YXIgZG49cGU7cGUucG9seWxpbmU9cGUscGUucG9seWdvbj1nbjtmdW5jdGlvbiBwZShoLGUsdCl7dmFyIHI9aC5sZW5ndGgsbj1yZShoWzBdLGUpLGQ9W10sZyx1LG8sYyxwO2Zvcih0fHwodD1bXSksZz0xO2c8cjtnKyspe2Zvcih1PWhbZy0xXSxvPWhbZ10sYz1wPXJlKG8sZSk7OylpZihufGMpe2lmKG4mYylicmVhaztuPyh1PWplKHUsbyxuLGUpLG49cmUodSxlKSk6KG89amUodSxvLGMsZSksYz1yZShvLGUpKX1lbHNle2QucHVzaCh1KSxjIT09cD8oZC5wdXNoKG8pLGc8ci0xJiYodC5wdXNoKGQpLGQ9W10pKTpnPT09ci0xJiZkLnB1c2gobyk7YnJlYWt9bj1wfXJldHVybiBkLmxlbmd0aCYmdC5wdXNoKGQpLHR9ZnVuY3Rpb24gZ24oaCxlKXt2YXIgdCxyLG4sZCxnLHUsbztmb3Iocj0xO3I8PTg7cio9Mil7Zm9yKHQ9W10sbj1oW2gubGVuZ3RoLTFdLGQ9IShyZShuLGUpJnIpLGc9MDtnPGgubGVuZ3RoO2crKyl1PWhbZ10sbz0hKHJlKHUsZSkmciksbyE9PWQmJnQucHVzaChqZShuLHUscixlKSksbyYmdC5wdXNoKHUpLG49dSxkPW87aWYoaD10LCFoLmxlbmd0aClicmVha31yZXR1cm4gdH1mdW5jdGlvbiBqZShoLGUsdCxyKXtyZXR1cm4gdCY4P1toWzBdKyhlWzBdLWhbMF0pKihyWzNdLWhbMV0pLyhlWzFdLWhbMV0pLHJbM11dOnQmND9baFswXSsoZVswXS1oWzBdKSooclsxXS1oWzFdKS8oZVsxXS1oWzFdKSxyWzFdXTp0JjI/W3JbMl0saFsxXSsoZVsxXS1oWzFdKSooclsyXS1oWzBdKS8oZVswXS1oWzBdKV06dCYxP1tyWzBdLGhbMV0rKGVbMV0taFsxXSkqKHJbMF0taFswXSkvKGVbMF0taFswXSldOm51bGx9ZnVuY3Rpb24gcmUoaCxlKXt2YXIgdD0wO3JldHVybiBoWzBdPGVbMF0/dHw9MTpoWzBdPmVbMl0mJih0fD0yKSxoWzFdPGVbMV0/dHw9NDpoWzFdPmVbM10mJih0fD04KSx0fXZhciBtbj1zcihkbik7Y2xhc3MgS3QgZXh0ZW5kcyBkZXt1cGRhdGFPcHRTZXJ2aWNlKCl7fWNvbnN0cnVjdG9yKGUsdCl7c3VwZXIodCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6U3QuRXJhc2VyfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmxkUG9zaXRpb24iLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ybGRTY2FsaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVyYXNlclJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZXJhc2VyUG9seWxpbmUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy53b3JsZFBvc2l0aW9uPXRoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb24sdGhpcy53b3JsZFNjYWxpbmc9dGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nfWNvbXB1dE5vZGVNYXAoZSl7dGhpcy5jdXJOb2RlTWFwLmNsZWFyKCksZS5mb3JFYWNoKHQ9Pntjb25zdCByPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQubmFtZSlbMF0sbj10Lm9wcyYmZWUodC5vcHMpO2lmKHImJm4ubGVuZ3RoKXtjb25zdCBkPVtdO2ZvcihsZXQgdT0wO3U8bi5sZW5ndGg7dSs9Myl7Y29uc3Qgbz1uZXcgY3Qoblt1XSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0sblt1KzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSxuW3UrMl0pO2QucHVzaChvKX1sZXQgZz10Lm9wdDtpZighZyl7bGV0IHU9ci5nZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIik7Y29uc3Qgbz1yLmNsYXNzTmFtZS5zcGxpdCgiLCIpLGM9TnVtYmVyKG9bMl0pO3IudGFnTmFtZT09PSJHUk9VUCImJihjPT09RHQuU3Ryb2tlP3U9ci5nZXRBdHRyaWJ1dGUoImJnY29sb3IiKTp1PXIuY2hpbGRyZW5bMF0uZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpKTtjb25zdCBwPXIuZ2V0QXR0cmlidXRlKCJvcGFjaXR5IiksbD1yLmdldEF0dHJpYnV0ZSgic2NhbGUiKSx5PXIuZ2V0QXR0cmlidXRlKCJ6SW5kZXgiKSx4PXIuZ2V0QXR0cmlidXRlKCJyb3RhdGUiKSxiPXRoaXMud29ya09wdGlvbnMuc3luY1VuaXRUaW1lO2c9e2NvbG9yOnUsb3BhY2l0eTpwLHN5bmNVbml0VGltZTpiLHpJbmRleDp5LHNjYWxlOmwscm90YXRlOngsc3Ryb2tlVHlwZTpjfX10aGlzLmN1ck5vZGVNYXAuc2V0KHQubmFtZSx7bmFtZTp0Lm5hbWUscmVjdDp0LnJlY3QscG9seWxpbmU6ZCxvcHQ6Zyx0b29sc1R5cGU6dC50b29sc1R5cGV8fFN0LlBlbmNpbH0pfX0pfXVwZGF0YU5vZGVNYXAoZSx0KXtjb25zdCByPXQub3Asbj1bXTtmb3IobGV0IGQ9MDtkPHIubGVuZ3RoO2QrPTMpe2NvbnN0IGc9bmV3IGN0KHJbZF0qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLHJbZCsxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0scltkKzJdKTtuLnB1c2goZyl9dGhpcy5jdXJOb2RlTWFwLnNldChlLHtuYW1lOnQubmFtZSxyZWN0OnQucmVjdCxwb2x5bGluZTpuLG9wdDp0Lm9wdCx0b29sc1R5cGU6dC50b29sc1R5cGV8fFN0LlBlbmNpbH0pfWNvbWJpbmVDb25zdW1lKCl7fWNyZWF0ZUVyYXNlclJlY3QoZSl7Y29uc3QgdD1lWzBdKnRoaXMud29ybGRTY2FsaW5nWzBdK3RoaXMud29ybGRQb3NpdGlvblswXSxyPWVbMV0qdGhpcy53b3JsZFNjYWxpbmdbMV0rdGhpcy53b3JsZFBvc2l0aW9uWzFdLHt3aWR0aDpuLGhlaWdodDpkfT1LdC5lcmFzZXJTaXplc1t0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzc107dGhpcy5lcmFzZXJSZWN0PXt4OnQtbiouNSx5OnItZCouNSx3Om4saDpkfSx0aGlzLmVyYXNlclBvbHlsaW5lPVt0aGlzLmVyYXNlclJlY3QueCx0aGlzLmVyYXNlclJlY3QueSx0aGlzLmVyYXNlclJlY3QueCt0aGlzLmVyYXNlclJlY3Qudyx0aGlzLmVyYXNlclJlY3QueSt0aGlzLmVyYXNlclJlY3QuaF19Y29uc3VtZVNlcnZpY2UoKXt9c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29tcHV0UmVjdENlbnRlclBvaW50cygpe2NvbnN0IGU9dGhpcy50bXBQb2ludHMuc2xpY2UoLTIpO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD09PTQpe2NvbnN0IHQ9bmV3IGN0KHRoaXMudG1wUG9pbnRzWzBdLHRoaXMudG1wUG9pbnRzWzFdKSxyPW5ldyBjdCh0aGlzLnRtcFBvaW50c1syXSx0aGlzLnRtcFBvaW50c1szXSksbj1jdC5TdWIocix0KS51bmkoKSxkPWN0LkRpc3QodCxyKSx7d2lkdGg6ZyxoZWlnaHQ6dX09S3QuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdLG89TWF0aC5taW4oZyx1KSxjPU1hdGgucm91bmQoZC9vKTtpZihjPjEpe2NvbnN0IHA9W107Zm9yKGxldCBsPTA7bDxjO2wrKyl7Y29uc3QgeT1jdC5NdWwobixsKm8pO3AucHVzaCh0aGlzLnRtcFBvaW50c1swXSt5LngsdGhpcy50bXBQb2ludHNbMV0reS55KX1yZXR1cm4gcC5jb25jYXQoZSl9fXJldHVybiBlfWlzTmVhcihlLHQpe2NvbnN0IHI9bmV3IGN0KGVbMF0sZVsxXSksbj1uZXcgY3QodFswXSx0WzFdKSx7d2lkdGg6ZCxoZWlnaHQ6Z309S3QuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdO3JldHVybiBjdC5EaXN0KHIsbik8TWF0aC5oeXBvdChkLGcpKi41fWNvbnN1bWUoZSl7Y29uc3R7b3A6dCx3b3JrU3RhdGU6cn09ZS5kYXRhO2lmKCF0fHx0Lmxlbmd0aD09PTApcmV0dXJue3R5cGU6eXQuTm9uZX07cj09PUd0LlN0YXJ0JiZlLm5vZGVNYXBzJiZ0aGlzLmNvbXB1dE5vZGVNYXAoZS5ub2RlTWFwcyk7Y29uc3Qgbj10aGlzLnRtcFBvaW50cy5sZW5ndGg7aWYobj4xJiZ0aGlzLmlzTmVhcihbdFswXSx0WzFdXSxbdGhpcy50bXBQb2ludHNbbi0yXSx0aGlzLnRtcFBvaW50c1tuLTFdXSkpcmV0dXJue3R5cGU6eXQuTm9uZX07aWYoZS5ub2RlTWFwcyl7bj09PTQmJih0aGlzLnRtcFBvaW50cy5zaGlmdCgpLHRoaXMudG1wUG9pbnRzLnNoaWZ0KCkpLHRoaXMudG1wUG9pbnRzLnB1c2godFswXSx0WzFdKTtjb25zdCBkPXRoaXMuY29tcHV0UmVjdENlbnRlclBvaW50cygpO2xldCBnO2NvbnN0IHU9bmV3IFNldCxvPW5ldyBNYXA7Zm9yKGxldCBjPTA7YzxkLmxlbmd0aC0xO2MrPTIpe3RoaXMuY3JlYXRlRXJhc2VyUmVjdChkLnNsaWNlKGMsYysyKSk7Y29uc3R7cmVjdDpwLHJlbW92ZUlkczpsLG5ld1dvcmtEYXRhczp5fT10aGlzLnJlbW92ZSgpO2c9VHQoZyxwKSxsLmZvckVhY2goeD0+dS5hZGQoeCkpLHk9PW51bGx8fHkuZm9yRWFjaCh4PT57dS5oYXMoeC53b3JrSWQpfHxvLnNldCh4LndvcmtJZCx4KX0pfWlmKGcmJnUuc2l6ZSl7Y29uc3QgYz1bXTtmb3IoY29uc3QgcCBvZiBvLnZhbHVlcygpKXUuaGFzKHAud29ya0lkKXx8Yy5wdXNoKHApO3JldHVybnt0eXBlOnl0LlJlbW92ZU5vZGUsZGF0YVR5cGU6QXQuTG9jYWwscmVjdDpnLHJlbW92ZUlkczpbLi4udV0sbmV3V29ya0RhdGFzOmN9fX1yZXR1cm57dHlwZTp5dC5Ob25lfX1jdXRQb2x5bGluZShlLHQpe2xldCByPVt0XSxuPTA7Zm9yKDtuPGUubGVuZ3RoOyl7Y29uc3QgdT1lW25dO2lmKHUubGVuZ3RoPDIpYnJlYWs7cj1kKHIsdSksbisrfXJldHVybiByO2Z1bmN0aW9uIGQodSxvKXtjb25zdCBjPXU7Zm9yKGxldCBwPTA7cDx1Lmxlbmd0aDtwKyspe2NvbnN0IGw9dVtwXSx5PWwuZmluZEluZGV4KCh4LGIpPT5iPGwubGVuZ3RoLTE/ZyhbeCxsW2IrMV1dLFtvWzBdLG9bMV1dKTohMSk7aWYoeSE9PS0xJiZ5Pi0xKXtjb25zdCB4PVtdLGI9bC5zbGljZSgwLHkrMSk7aWYoY3QuRXF1YWxzKGxbeV0sb1swXSl8fGIucHVzaChvWzBdLmNsb25lKCkuc2V0eihsW3ldLnopKSxiLmxlbmd0aD4xJiZ4LnB1c2goYikseStvLmxlbmd0aC0xPGwubGVuZ3RoLTEpe2NvbnN0IEU9eStvLmxlbmd0aC0xLHY9bC5zbGljZShFKSxNPW9bby5sZW5ndGgtMV07Y3QuRXF1YWxzKGxbRV0sTSl8fHYudW5zaGlmdChNLmNsb25lKCkuc2V0eihsW0VdLnopKSx2Lmxlbmd0aD4xJiZ4LnB1c2godil9cmV0dXJuIGMuc3BsaWNlKHAsMSwuLi54KSxjfX1yZXR1cm4gY31mdW5jdGlvbiBnKHUsbyl7Y29uc3QgYz1jdC5TdWIodVsxXSx1WzBdKSxwPWN0LlN1YihvWzFdLG9bMF0pLGw9Y3QuU3ViKG9bMF0sdVswXSk7cmV0dXJuIE1hdGguYWJzKGN0LkNwcihjLHApKTwuMSYmTWF0aC5hYnMoY3QuQ3ByKGMsbCkpPC4xfX1pc1NhbWVQb2ludChlLHQpe3JldHVybiBlWzBdPT09dFswXSYmZVsxXT09PXRbMV19dHJhbnNsYXRlSW50ZXJzZWN0KGUpe2NvbnN0IHQ9W107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IG49ZVtyXS5maWx0ZXIoKHUsbyxjKT0+IShvPjAmJnRoaXMuaXNTYW1lUG9pbnQodSxjW28tMV0pKSksZD1bXTtsZXQgZz0wO2Zvcig7ZzxuLmxlbmd0aDspe2NvbnN0IHU9bltnXSxvPW5ldyBjdCh1WzBdLHVbMV0pO2QucHVzaChvKSxnKyt9dC5wdXNoKGQpfXJldHVybiB0fXJlbW92ZSgpe2NvbnN0e2lzTGluZTplfT10aGlzLndvcmtPcHRpb25zO2xldCB0O2NvbnN0IHI9W10sbj1bXSxkPVtdO3JldHVybiB0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaCgoZyx1KT0+e2NvbnN0IG89dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZy5uYW1lKVswXTtpZihvJiZnLnJlY3QmJnRoaXMuZXJhc2VyUmVjdCYmdGhpcy5lcmFzZXJQb2x5bGluZSYmSWUodGhpcy5lcmFzZXJSZWN0LGcucmVjdCkpe2lmKGcucG9seWxpbmUubGVuZ3RoPjEpe2NvbnN0IGM9bW4ucG9seWxpbmUoZy5wb2x5bGluZS5tYXAocD0+cC5YWSksdGhpcy5lcmFzZXJQb2x5bGluZSk7aWYoYy5sZW5ndGgmJihuLnB1c2gobyksci5wdXNoKGcubmFtZSksIWUpKXtjb25zdCBwPXRoaXMudHJhbnNsYXRlSW50ZXJzZWN0KGMpLGw9dGhpcy5jdXRQb2x5bGluZShwLGcucG9seWxpbmUpO2ZvcihsZXQgeT0wO3k8bC5sZW5ndGg7eSsrKXtjb25zdCB4PWAke3V9X3NfJHt5fWAsYj1bXTtsW3ldLmZvckVhY2goRT0+e2IucHVzaCgoRS54LXRoaXMud29ybGRQb3NpdGlvblswXSkvdGhpcy53b3JsZFNjYWxpbmdbMF0sKEUueS10aGlzLndvcmxkUG9zaXRpb25bMV0pL3RoaXMud29ybGRTY2FsaW5nWzFdLEUueil9KSxkLnB1c2goe3dvcmtJZDp4LG9wOmIsb3B0Omcub3B0LHRvb2xzVHlwZTpnLnRvb2xzVHlwZX0pfX19ZWxzZSBuLnB1c2gobyksci5wdXNoKGcubmFtZSk7dD1UdCh0LGcucmVjdCl9fSksbi5mb3JFYWNoKGc9PmcucmVtb3ZlKCkpLHQmJih0LngtPUt0LlNhZmVCb3JkZXJQYWRkaW5nLHQueS09S3QuU2FmZUJvcmRlclBhZGRpbmcsdC53Kz1LdC5TYWZlQm9yZGVyUGFkZGluZyoyLHQuaCs9S3QuU2FmZUJvcmRlclBhZGRpbmcqMikse3JlY3Q6dCxyZW1vdmVJZHM6cixuZXdXb3JrRGF0YXM6ZH19Y29uc3VtZUFsbChlKXtyZXR1cm4gdGhpcy5jb25zdW1lKGUpfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTB9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShLdCwiU2FmZUJvcmRlclBhZGRpbmciLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLdCwiZXJhc2VyU2l6ZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpPYmplY3QuZnJlZXplKFtPYmplY3QuZnJlZXplKHt3aWR0aDoxOCxoZWlnaHQ6MjZ9KSxPYmplY3QuZnJlZXplKHt3aWR0aDoyNixoZWlnaHQ6MzR9KSxPYmplY3QuZnJlZXplKHt3aWR0aDozNCxoZWlnaHQ6NTB9KV0pfSk7ZnVuY3Rpb24gdm4oaCxlLHQpe3JldHVybiIjIisoKGg8PDE2KSsoZTw8OCkrdCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDYsIjAiKX1mdW5jdGlvbiB5bihoKXtjb25zdCBlPWguc3BsaXQoIiwiKSx0PXBhcnNlSW50KGVbMF0uc3BsaXQoIigiKVsxXSkscj1wYXJzZUludChlWzFdKSxuPXBhcnNlSW50KGVbMl0pLGQ9cGFyc2VJbnQoZVszXS5zcGxpdCgiKSIpWzBdKTtyZXR1cm5bdm4odCxyLG4pLGRdfWNsYXNzIHZ0IGV4dGVuZHMgZGV7dXBkYXRhT3B0U2VydmljZSgpe31jb25zdHJ1Y3RvcihlLHQscil7c3VwZXIodCxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6U3QuU2VsZWN0b3J9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzZWxlY3RJZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkUmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJub2RlQ29sb3IiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibm9kZU9wYWN0aXkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2xkU2VsZWN0UmVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21wdXROb2RlTWFwKGUpe3RoaXMuY3VyTm9kZU1hcC5jbGVhcigpLGUuZm9yRWFjaCh0PT57dmFyIG47Y29uc3Qgcj10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0Lm5hbWUpWzBdfHwoKG49dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpuLmdldEVsZW1lbnRzQnlOYW1lKHQubmFtZSlbMF0pO2lmKHIpe2NvbnN0IGQ9ci53b3JsZFBvc2l0aW9uO2xldCBnPXIuZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpO2NvbnN0IHU9ci5jbGFzc05hbWUuc3BsaXQoIiwiKTtyLnRhZ05hbWU9PT0iR1JPVVAiJiYoTnVtYmVyKHVbMl0pPT09RHQuU3Ryb2tlP2c9ci5nZXRBdHRyaWJ1dGUoImJnY29sb3IiKTpnPXIuY2hpbGRyZW5bMF0uZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpKSx0aGlzLmN1ck5vZGVNYXAuc2V0KHQubmFtZSx7bmFtZTp0Lm5hbWUscmVjdDp0LnJlY3QsY29sb3I6eW4oZylbMF0scG9zOmQscm90YXRlOnIuZ2V0QXR0cmlidXRlKCJyb3RhdGUiKXx8MCxzY2FsZTpyLmdldEF0dHJpYnV0ZSgic2NhbGUiKXx8WzEsMV0sb3BhY3RpeTpyLmdldEF0dHJpYnV0ZSgib3BhY2l0eSIpfHwxfSl9fSl9Y29tcHV0U2VsZWN0b3IoKXtsZXQgZTtjb25zdCB0PVtdLHI9bmV3IE1hcCxuPW5ldyBTZXQsZD1uZXcgU2V0LGc9bmV3IE1hcDtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGgmJnRoaXMuY3VyTm9kZU1hcC5zaXplKXtjb25zdCB1PUp0KHRoaXMudG1wUG9pbnRzKTt0aGlzLmN1ck5vZGVNYXAuZm9yRWFjaCgobyxjKT0+e2NvbnN0IHA9e3g6by5yZWN0LngseTpvLnJlY3QueSx3Om8ucmVjdC53LGg6by5yZWN0Lmh9LGw9e3g6dS54LHk6dS55LHc6dS53LGg6dS5ofTtJZShsLHApJiYodC5wdXNoKGMpLGU9VHQoZSxwKSxyLnNldChjLHApLG4uYWRkKG8uY29sb3IpLGcuc2V0KGMsWy4uLm8ucG9zLG8ucm90YXRlXSksZC5hZGQoby5vcGFjdGl5KSl9KX1yZXR1cm57c2VsZWN0SWRzOnQsaW50ZXJzZWN0UmVjdDplLHN1YlJlY3RzOnIsbm9kZUNvbG9yczpuLHN1YlBvczpnLG9wYWN0aXlzOmR9fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGgscj1lLmxlbmd0aDtpZihyPjEpe2NvbnN0IG49bmV3IEx0KGVbci0yXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSxlW3ItMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0pO3Q9PT0yP3RoaXMudG1wUG9pbnRzLnNwbGljZSgxLDEsbik6dGhpcy50bXBQb2ludHMucHVzaChuKX19ZHJhdyhlKXt2YXIgZCxnLHU7Y29uc3R7aW50ZXJzZWN0UmVjdDp0LHN1YlJlY3RzOnIsc3ViUG9zOm59PWU7KHU9KGc9KGQ9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpkLnBhcmVudCk9PW51bGw/dm9pZCAwOmcuZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JJZCkpPT1udWxsfHx1LnJlbW92ZSgpLHQmJnRoaXMuZHJhd0xheWVyJiZ0aGlzLmRyYXdTZWxlY3Rvcih7ZHJhd1JlY3Q6dCxzdWJSZWN0czpyLHN1YlBvczpuLHNlbGVjdG9ySWQ6dnQuc2VsZWN0b3JJZCxsYXllcjp0aGlzLmRyYXdMYXllcn0pfWNvbnN1bWUoZSl7Y29uc3R7b3A6dCx3b3JrU3RhdGU6cn09ZS5kYXRhO2lmKHI9PT1HdC5TdGFydCYmZS5ub2RlTWFwcyYmKHRoaXMuY29tcHV0Tm9kZU1hcChlLm5vZGVNYXBzKSx0aGlzLm9sZFJlY3Q9dGhpcy5iYWNrVG9GdWxsTGF5ZXIoZS5ub2RlTWFwcykpLCEodCE9bnVsbCYmdC5sZW5ndGgpfHwhdGhpcy5jdXJOb2RlTWFwLnNpemUpcmV0dXJue3R5cGU6eXQuTm9uZX07dGhpcy51cGRhdGVUZW1wUG9pbnRzKHQpO2NvbnN0IG49dGhpcy5jb21wdXRTZWxlY3RvcigpO2lmKHRoaXMuc2VsZWN0SWRzJiZhbih0aGlzLnNlbGVjdElkcyxuLnNlbGVjdElkcykpcmV0dXJue3R5cGU6eXQuTm9uZX07dGhpcy5zZWxlY3RJZHM9bi5zZWxlY3RJZHM7Y29uc3QgZD10aGlzLmRyYXdMYXllciYmdGhpcy5nZXRTZWxlY3RvclJlY3QodGhpcy5kcmF3TGF5ZXIsdnQuc2VsZWN0b3JJZCwhMCksZz1uLmludGVyc2VjdFJlY3QmJnt4Om4uaW50ZXJzZWN0UmVjdC54LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcseTpuLmludGVyc2VjdFJlY3QueS12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHc6bi5pbnRlcnNlY3RSZWN0LncrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGg6bi5pbnRlcnNlY3RSZWN0LmgrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyfXx8dm9pZCAwO3JldHVybiB0aGlzLm9sZFJlY3Q9VHQoZCxnKSx0aGlzLmRyYXcobiksdGhpcy5ub2RlQ29sb3I9bi5ub2RlQ29sb3JzLnNpemU9PT0xP24ubm9kZUNvbG9ycy52YWx1ZXMoKS5uZXh0KCkudmFsdWU6dm9pZCAwLHRoaXMubm9kZU9wYWN0aXk9bi5vcGFjdGl5cy5zaXplPT09MT9uLm9wYWN0aXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZToxLHRoaXMub2xkU2VsZWN0UmVjdD1nLHt0eXBlOnl0LlNlbGVjdCxkYXRhVHlwZTpBdC5Mb2NhbCxyZWN0OnRoaXMub2xkUmVjdCxzZWxlY3RJZHM6bi5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMscGFkZGluZzp2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHNlbGVjdFJlY3Q6Zyxub2RlQ29sb3I6dGhpcy5ub2RlQ29sb3Isbm9kZU9wYWN0aXk6dGhpcy5ub2RlT3BhY3RpeSx3aWxsU3luY1NlcnZpY2U6ITB9fWNvbnN1bWVBbGwoKXt2YXIgZTtyZXR1cm4oZT10aGlzLnNlbGVjdElkcykhPW51bGwmJmUubGVuZ3RoJiZ0aGlzLnNlYWxUb0RyYXdMYXllcih0aGlzLnNlbGVjdElkcyksdGhpcy5vbGRTZWxlY3RSZWN0P3t0eXBlOnl0LlNlbGVjdCxkYXRhVHlwZTpBdC5Mb2NhbCxyZWN0OnRoaXMub2xkUmVjdCxzZWxlY3RJZHM6dGhpcy5zZWxlY3RJZHMsb3B0OnRoaXMud29ya09wdGlvbnMscGFkZGluZzp2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHNlbGVjdFJlY3Q6dGhpcy5vbGRTZWxlY3RSZWN0LG5vZGVDb2xvcjp0aGlzLm5vZGVDb2xvcixub2RlT3BhY3RpeTp0aGlzLm5vZGVPcGFjdGl5LHdpbGxTeW5jU2VydmljZTohMX06e3R5cGU6eXQuTm9uZX19Y29uc3VtZVNlcnZpY2UoKXt9Y29tYmluZUNvbnN1bWUoKXt9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MH1jbGVhclNlbGVjdERhdGEoKXt0aGlzLnNlbGVjdElkcz12b2lkIDAsdGhpcy5vbGRSZWN0PXZvaWQgMCx0aGlzLm9sZFNlbGVjdFJlY3Q9dm9pZCAwfWJhY2tUb0Z1bGxMYXllcihlPW5ldyBNYXAsdCl7dmFyIGcsdTtsZXQgcjtjb25zdCBuPVtdLGQ9W107Zm9yKGNvbnN0IG8gb2YoKGc9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpnLmNoaWxkcmVuKXx8W10paWYoISh0IT1udWxsJiZ0Lmxlbmd0aCYmIXQuaW5jbHVkZXMoby5pZCkpJiZvLmlkIT09dnQuc2VsZWN0b3JJZCl7Y29uc3QgYz1vLmNsb25lTm9kZSghMCk7aWYoYy50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgbD1vLmNsYXNzTmFtZS5zcGxpdCgiLCIpO2wubGVuZ3RoPT09MyYmTnVtYmVyKGxbMl0pPT09RHQuU3Ryb2tlJiZjLnNlYWwoKX1uLnB1c2goYyksZC5wdXNoKG8pO2NvbnN0IHA9KCh1PWUuZ2V0KG8ubmFtZSkpPT1udWxsP3ZvaWQgMDp1LnJlY3QpfHxYdChvLm5hbWUsdGhpcy5kcmF3TGF5ZXIpO3AmJihyPVR0KHIscCkpfXJldHVybiBkLmZvckVhY2gobz0+by5yZW1vdmUoKSksbi5sZW5ndGgmJnRoaXMuZnVsbExheWVyLmFwcGVuZCguLi5uKSxyJiYoci54LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHIueS09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxyLncrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixyLmgrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMikscn1zZWFsVG9EcmF3TGF5ZXIoZSl7dmFyIG47Y29uc3QgdD1bXSxyPVtdO2UuZm9yRWFjaChkPT57dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZC50b1N0cmluZygpKS5mb3JFYWNoKGc9Pntjb25zdCB1PWcuY2xvbmVOb2RlKCEwKTtpZih1LnRhZ05hbWU9PT0iR1JPVVAiKXtjb25zdCBvPWcuY2xhc3NOYW1lLnNwbGl0KCIsIik7by5sZW5ndGg9PT0zJiZOdW1iZXIob1syXSk9PT1EdC5TdHJva2UmJnUuc2VhbCgpfXQucHVzaCh1KSxyLnB1c2goZyl9KX0pLHIuZm9yRWFjaChkPT5kLnJlbW92ZSgpKSx0JiYoKG49dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxuLmFwcGVuZCguLi50KSl9dXBkYXRlU2VsZWN0b3JTaXplKGUsdCxyKXtjb25zdCBuPW5ldyBNYXAsZD1lLmdldEF0dHJpYnV0ZSgicG9zIiksZz1lLmNsYXNzTmFtZS5zcGxpdCgiLCIpLHU9dC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsbz1yLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixjPWcubGVuZ3RoPT09MiYmW3UvTnVtYmVyKGdbMF0pLG8vTnVtYmVyKGdbMV0pXXx8WzEsMV07cmV0dXJuIGUuc2V0QXR0cmlidXRlKCJzaXplIixbdSxvXSksZS5jaGlsZHJlbi5mb3JFYWNoKHA9PntpZihwLmlkPT09dnQuc2VsZWN0b3JCb3JkZXJJZClwLnNldEF0dHJpYnV0ZSgicG9zIixbdS8yLG8vMl0pLHAuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdSkscC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsbyk7ZWxzZSBpZihjKXtjb25zdCBsPXAuY2xhc3NOYW1lLnNwbGl0KCIsIikseT1bTnVtYmVyKGxbMF0pKmNbMF0sTnVtYmVyKGxbMV0pKmNbMV1dLHg9cC5nZXRBdHRyaWJ1dGUoIndpZHRoIiksYj1wLmdldEF0dHJpYnV0ZSgiaGVpZ2h0IiksRT1OdW1iZXIobFsyXSkqY1swXSx2PU51bWJlcihsWzNdKSpjWzFdO3Auc2V0QXR0cmlidXRlKCJwb3MiLHkpLHAuc2V0QXR0cmlidXRlKCJ3aWR0aCIsRSkscC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsdik7Y29uc3QgTT1wLmlkLnNwbGl0KCJzZWxlY3Rvci0iKVsxXTtpZihNKXtjb25zdCBpPVt5WzBdK2RbMF0seVsxXStkWzFdXSxhPVtFL3gsdi9iXTtuLnNldChNLFtpWzBdLGlbMV0sYVswXSxhWzFdXSl9fX0pLG59dXBkYXRlU2VsZWN0b3JSZWN0KGUsdCl7Y29uc3R7dzpyLGg6bix4OmQseTpnfT10LHU9ci12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsbz1uLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixjPWQrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxwPWcrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZztlLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Isbl0pLGUuc2V0QXR0cmlidXRlKCJwb3MiLFtjLHBdKSxlLnNldEF0dHJpYnV0ZSgiY2xhc3NOYW1lIixgJHt0Lnd9LCR7dC5ofWApLGUuY2hpbGRyZW4uZm9yRWFjaChsPT57aWYobC5zZXRBdHRyaWJ1dGUoInBvcyIsW3UvMixvLzJdKSxsLnNldEF0dHJpYnV0ZSgid2lkdGgiLHUpLGwuc2V0QXR0cmlidXRlKCJoZWlnaHQiLG8pLGwuaWQ9PT12dC5zZWxlY3RvckJvcmRlcklkKWwuc2V0QXR0cmlidXRlKCJjbGFzc05hbWUiLGAke3Qudy8yfSwke3QuaC8yfSwke3Qud30sJHt0Lmh9YCk7ZWxzZXtjb25zdCB5PWwuY2xhc3NOYW1lLnNwbGl0KCIsIikseD15JiZOdW1iZXIoeVs0XSl8fDA7bC5zZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIsYCR7dS8yfSwke28vMn0sJHt0Lnd9LCR7dC5ofSwke3h9YCl9fSl9Z2V0U2VsZWN0b3JSZWN0KGUsdCxyKXt2YXIgbztsZXQgbjtjb25zdCBkPShvPWUucGFyZW50KT09bnVsbD92b2lkIDA6by5nZXRFbGVtZW50QnlJZCh0KSxnPWQ9PW51bGw/dm9pZCAwOmQuZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JCb3JkZXJJZCksdT1nPT1udWxsP3ZvaWQgMDpnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiB1JiYobj1UdChuLHt4Ok1hdGguZmxvb3IodS54KSx5Ok1hdGguZmxvb3IodS55KSx3Ok1hdGgucm91bmQodS53aWR0aCksaDpNYXRoLnJvdW5kKHUuaGVpZ2h0KX0pKSxuJiZyP3t4Om4ueC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHk6bi55LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdzpuLncrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGg6bi5oK3Z0LlNlbGVjdEJvcmRlclBhZGRpbmcqMn06bn11cGRhdGVTZWxlY3RvcihlKXt2YXIgbyxjLHA7Y29uc3R7dXBkYXRlU2VsZWN0b3JPcHQ6dCxzZWxlY3RJZHM6cn09ZTtsZXQgbjtjb25zdCBkPW5ldyBNYXA7bGV0IGc7Y29uc3QgdT0oYz0obz10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOm8ucGFyZW50KT09bnVsbD92b2lkIDA6Yy5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvcklkKTtpZih1KXtsZXQgbDtpZih0LnBvcyl7Y29uc3QgeT1bdC5wb3NbMF0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0sdC5wb3NbMV0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV1dLHg9dS5nZXRBdHRyaWJ1dGUoInBvcyIpO2w9W3lbMF0teFswXSx5WzFdLXhbMV1dLHUuc2V0QXR0cmlidXRlKCJwb3MiLHkpfWlmKHQuc2VsZWN0b3JDb2xvciYmKChwPXUuZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JCb3JkZXJJZCkpPT1udWxsfHxwLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHQuc2VsZWN0b3JDb2xvcikpLHQuc2l6ZSYmKGc9dGhpcy51cGRhdGVTZWxlY3RvclNpemUodSx0LnNpemUud2lkdGgsdC5zaXplLmhlaWdodCkpLHQuYW5nbGUpcj09bnVsbHx8ci5mb3JFYWNoKHk9Pnt2YXIgeDsoeD10aGlzLmRyYXdMYXllcik9PW51bGx8fHguZ2V0RWxlbWVudHNCeU5hbWUoeSkuZm9yRWFjaChiPT57aWYoYil7Y29uc3QgRT17dXNlQW5pbWF0aW9uOiExfTt0LmFuZ2xlJiYoRS5hbmdsZT10LmFuZ2xlLEUub3JpZ2luUG9zPWIuY2xhc3NOYW1lLnNwbGl0KCIsIikubWFwKE09Pk51bWJlcihNKSksYi5zZXRBdHRyaWJ1dGUoInJvdGF0ZSIsRS5hbmdsZSkpLGQuc2V0KGIubmFtZSxFKTtjb25zdCB2PVh0KGIubmFtZSx0aGlzLmRyYXdMYXllcik7bj1UdChuLHYpfX0pfSx0aGlzKTtlbHNle3I9PW51bGx8fHIuZm9yRWFjaChiPT57dmFyIEU7KEU9dGhpcy5kcmF3TGF5ZXIpPT1udWxsfHxFLmdldEVsZW1lbnRzQnlOYW1lKGIpLmZvckVhY2godj0+e2lmKHYpe2NvbnN0IE09e3VzZUFuaW1hdGlvbjohMX07aWYodC5wb3MmJmwpe2NvbnN0IGE9di5nZXRBdHRyaWJ1dGUoInBvcyIpO00ucG9zPVtsWzBdL3RoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSthWzBdLGxbMV0vdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK2FbMV1dLE0ub3JpZ2luUG9zPXYuY2xhc3NOYW1lLnNwbGl0KCIsIikubWFwKHM9Pk51bWJlcihzKSksdi5zZXRBdHRyaWJ1dGUoInBvcyIsTS5wb3MpfWlmKHQuekluZGV4RGlzdGFuY2V8fHQuekluZGV4KXtpZih0LnpJbmRleERpc3RhbmNlKXtjb25zdCBhPXYuZ2V0QXR0cmlidXRlKCJ6SW5kZXgiKTtNLnpJbmRleD1hK3QuekluZGV4RGlzdGFuY2V9ZWxzZSBNLnpJbmRleD10LnpJbmRleDt2LnNldEF0dHJpYnV0ZSgiekluZGV4IixNLnpJbmRleCl9aWYodC5jb2xvcil7TS5jb2xvcj10LmNvbG9yO2NvbnN0IGE9di5jbGFzc05hbWUuc3BsaXQoIiwiKTt2LnRhZ05hbWU9PT0iR1JPVVAiP051bWJlcihhWzJdKT09PUR0LlN0cm9rZT92LnNldEF0dHJpYnV0ZSgiYmdjb2xvciIsTS5jb2xvcik6di5jaGlsZHJlbi5mb3JFYWNoKHM9PntzLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLE0uY29sb3IpfSk6di50YWdOYW1lPT09IlBBVEgiJiYodi5zZXRBdHRyaWJ1dGUoInN0cm9rZUNvbG9yIixNLmNvbG9yKSx2LmdldEF0dHJpYnV0ZSgiZmlsbENvbG9yIikmJnYuc2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiLE0uY29sb3IpKX10Lm9wYWNpdHkmJihNLm9wYWNpdHk9dC5vcGFjaXR5LHYuc2V0QXR0cmlidXRlKCJvcGFjaXR5IixNLm9wYWNpdHkpKTtjb25zdCBpPWc9PW51bGw/dm9pZCAwOmcuZ2V0KHYubmFtZSk7aWYoaSl7Y29uc3QgYT12LmdldEF0dHJpYnV0ZSgic2NhbGUiKSxzPVtpWzJdKmFbMF0saVszXSphWzFdXTtNLm9yaWdpblBvcz12LmNsYXNzTmFtZS5zcGxpdCgiLCIpLm1hcChmPT5OdW1iZXIoZikpLE0ucG9zPVsoaVswXS10aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdKS90aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0sKGlbMV0tdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSkvdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdXSxNLnNjYWxlPXMsdi5zZXRBdHRyaWJ1dGUoInBvcyIsTS5wb3MpLHYuc2V0QXR0cmlidXRlKCJzY2FsZSIsTS5zY2FsZSl9ZC5zZXQodi5uYW1lLE0pfX0pfSx0aGlzKTtjb25zdCB5PXUuZ2V0RWxlbWVudEJ5SWQodnQuc2VsZWN0b3JCb3JkZXJJZCkseD15PT1udWxsP3ZvaWQgMDp5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3gmJihuPVR0KG4se3g6TWF0aC5mbG9vcih4LngpLHk6TWF0aC5mbG9vcih4LnkpLHc6TWF0aC5yb3VuZCh4LndpZHRoKSxoOk1hdGgucm91bmQoeC5oZWlnaHQpfSkpfX1pZihuKXJldHVybiBuLngtPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsbi55LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLG4udys9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLG4uaCs9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLHQuYW5nbGUmJnRoaXMudXBkYXRlU2VsZWN0b3JSZWN0KHUsbiksdGhpcy5vbGRSZWN0PVR0KHRoaXMub2xkUmVjdCxuKSx0aGlzLm9sZFNlbGVjdFJlY3Q9bix7dHlwZTp5dC5VcGRhdGVOb2RlLGRhdGFUeXBlOkF0LkxvY2FsLHJlY3Q6bix1cGRhdGVOb2RlT3B0czpkfX1ibHVyU2VsZWN0b3IoZSl7Y29uc3QgdD10aGlzLmJhY2tUb0Z1bGxMYXllcihlKTtyZXR1cm57dHlwZTp5dC5TZWxlY3QsZGF0YVR5cGU6QXQuTG9jYWwscmVjdDp0LHNlbGVjdElkczpbXSx3aWxsU3luY1NlcnZpY2U6ITB9fWdldFJpZ2h0U2VydmljZUlkKGUpe3JldHVybiBlLnJlcGxhY2UoIisrIiwiLSIpfWRyYXdTZWxlY3RvcihlKXtjb25zdHtkcmF3UmVjdDp0LHN1YlJlY3RzOnIsc3ViUG9zOm4sc2VsZWN0b3JJZDpkLGxheWVyOmd9PWUsdT1uZXcgTGUoe3BvczpbdC54LHQueV0sYW5jaG9yOlswLDBdLHNpemU6W3Qudyx0LmhdLGNsYXNzTmFtZTpgJHt0Lnd9LCR7dC5ofWAsaWQ6ZCxuYW1lOnZ0LnNlbGVjdG9ySWQsekluZGV4OjFlM30pLG89W10sYz1uZXcgcnIoe25vcm1hbGl6ZTohMCxwb3M6W3Qudy8yLHQuaC8yXSxsaW5lV2lkdGg6MSxzdHJva2VDb2xvcjp0aGlzLndvcmtPcHRpb25zLmNvbG9yLHdpZHRoOnQudyxoZWlnaHQ6dC5oLGNsYXNzTmFtZTpgJHt0LncvMn0sJHt0LmgvMn0sJHt0Lnd9LCR7dC5ofWAsaWQ6dnQuc2VsZWN0b3JCb3JkZXJJZH0pO28ucHVzaChjKSxyLmZvckVhY2goKHAsbCk9Pntjb25zdCB5PW49PW51bGw/dm9pZCAwOm4uZ2V0KGwpO2lmKHkpe2NvbnN0IHg9W3lbMF0tdC54LHlbMV0tdC55XSxiPWAke3hbMF19LCR7eFsxXX0sJHtwLnd9LCR7cC5ofSwke3lbMl19YCxFPW5ldyBycih7bm9ybWFsaXplOiEwLHBvczp4LGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOnIuc2l6ZT4xP3RoaXMud29ya09wdGlvbnMuY29sb3I6dm9pZCAwLHdpZHRoOnAudyxoZWlnaHQ6cC5oLGNsYXNzTmFtZTpiLGlkOmBzZWxlY3Rvci0ke2x9YCxuYW1lOmBzZWxlY3Rvci0ke2x9YH0pO28ucHVzaChFKX19KSxvJiZ1LmFwcGVuZCguLi5vKSwoZz09bnVsbD92b2lkIDA6Zy5wYXJlbnQpLmFwcGVuZENoaWxkKHUpfXNlbGVjdFNlcnZpY2VOb2RlKGUsdCxyKXt2YXIgcDtjb25zdHtzZWxlY3RJZHM6bn09dCxkPXRoaXMuZ2V0UmlnaHRTZXJ2aWNlSWQoZSksZz10aGlzLmdldFNlbGVjdG9yUmVjdCh0aGlzLmZ1bGxMYXllcixkLCEwKTsocD10aGlzLmZ1bGxMYXllci5wYXJlbnQuZ2V0RWxlbWVudEJ5SWQoZCkpPT1udWxsfHxwLnJlbW92ZSgpO2xldCB1O2NvbnN0IG89bmV3IE1hcCxjPW5ldyBNYXA7cmV0dXJuIG49PW51bGx8fG4uZm9yRWFjaChsPT57dmFyIGI7Y29uc3QgeT1yLmdldChsKSx4PXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGwpWzBdO2lmKHkmJngpe3U9VHQodSx5LnJlY3QpLG8uc2V0KGwseS5yZWN0KTtjb25zdCBFPXgud29ybGRQb3NpdGlvbix2PSgoYj15Lm9wdCk9PW51bGw/dm9pZCAwOmIucm90YXRlKXx8eC5nZXRBdHRyaWJ1dGUoInJvdGF0ZSIpfHwwO2Muc2V0KGwsWy4uLkUsdl0pfX0pLHUmJnRoaXMuZnVsbExheWVyJiZ0aGlzLmRyYXdTZWxlY3Rvcih7ZHJhd1JlY3Q6dSxzdWJSZWN0czpvLHN1YlBvczpjLHNlbGVjdG9ySWQ6ZCxsYXllcjp0aGlzLmZ1bGxMYXllcn0pLHU9VHQodSxnKSx1JiYodS54LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHUueS09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx1LncrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMix1LmgrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMiksdX1yZW1vdmVTZXJ2aWNlKCl7dGhyb3cgbmV3IEVycm9yKCJNZXRob2Qgbm90IGltcGxlbWVudGVkLiIpfWdldFNlbGVjdG9yKGUpe3ZhciBkO2xldCB0O2NvbnN0IHI9bmV3IE1hcCxuPW5ldyBNYXA7cmV0dXJuKGQ9dGhpcy5zZWxlY3RJZHMpPT1udWxsfHxkLmZvckVhY2goZz0+e3ZhciBjO2NvbnN0IHU9ZS5nZXQoZyksbz0oYz10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmMuZ2V0RWxlbWVudHNCeU5hbWUoZylbMF07aWYodSYmbyl7Y29uc3QgcD1vLndvcmxkUG9zaXRpb24sbD1vLmdldEF0dHJpYnV0ZSgicm90YXRlIil8fDA7dD1UdCh0LHUucmVjdCksci5zZXQoZyx1LnJlY3QpLG4uc2V0KGcsWy4uLnAsbF0pfX0sdGhpcyksdGhpcy5vbGRSZWN0PVR0KHQsdGhpcy5vbGRSZWN0KSx0aGlzLmRyYXcoe2ludGVyc2VjdFJlY3Q6dCxzdWJSZWN0czpyLHN1YlBvczpufSksdCYmKHQueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx0LnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsdC53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsdC5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIpLHRoaXMub2xkU2VsZWN0UmVjdD10LHR9dXBkYXRlU2VsZWN0SWRzKGUsdCl7dmFyIHUsbztsZXQgcjtjb25zdCBuPSh1PXRoaXMuc2VsZWN0SWRzKT09bnVsbD92b2lkIDA6dS5maWx0ZXIoYz0+IWUuaW5jbHVkZXMoYykpLGQ9ZS5maWx0ZXIoYz0+e3ZhciBwO3JldHVybiEoKHA9dGhpcy5zZWxlY3RJZHMpIT1udWxsJiZwLmluY2x1ZGVzKGMpKX0pO2lmKG4hPW51bGwmJm4ubGVuZ3RoJiYocj10aGlzLmJhY2tUb0Z1bGxMYXllcih0LG4pKSxkLmxlbmd0aCl7dGhpcy5zZWFsVG9EcmF3TGF5ZXIoZCk7Zm9yKGNvbnN0IGMgb2YgZCl7Y29uc3QgcD0obz10LmdldChjKSk9PW51bGw/dm9pZCAwOm8ucmVjdDtwJiYocj1UdChyLHApKX1yJiYoci54LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHIueS09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxyLncrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixyLmgrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMil9dGhpcy5zZWxlY3RJZHM9ZTtjb25zdCBnPXRoaXMuZ2V0U2VsZWN0b3IodCk7cmV0dXJue2JnUmVjdDpyLHNlbGVjdFJlY3Q6Z319fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2dCwic2VsZWN0b3JJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiJzZWxlY3RvciJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodnQsInNlbGVjdG9yQm9yZGVySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToic2VsZWN0b3ItYm9yZGVyIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2dCwiU2VsZWN0Qm9yZGVyUGFkZGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjJ9KTtjbGFzcyBhciBleHRlbmRzIGRle3VwZGF0YU9wdFNlcnZpY2UoKXt9Y29uc3RydWN0b3IoZSx0KXtzdXBlcih0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlN0Lkxhc2VyUGVufSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbnN1bWVJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tYmluZUNvbnN1bWUoKXt9c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlKXtjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyfT1lLHt3b3JrSWQ6bixvcDpkfT10O2lmKChkPT1udWxsP3ZvaWQgMDpkLmxlbmd0aCk9PT0wKXJldHVybnt0eXBlOnl0Lk5vbmV9O2lmKHRoaXMudXBkYXRlVGVtcFBvaW50cyhkfHxbXSksdGhpcy5jb25zdW1lSW5kZXg+dGhpcy50bXBQb2ludHMubGVuZ3RoLTQpcmV0dXJue3R5cGU6eXQuTm9uZX07Y29uc3R7Y29sb3I6Zyx0aGlja25lc3M6dSxzdHJva2VUeXBlOm8sb3BhY2l0eTpjfT10aGlzLndvcmtPcHRpb25zLHA9SnQodGhpcy50bXBQb2ludHMsdSk7bGV0IGw9ITE7Y29uc3QgeT10aGlzLnN5bmNJbmRleCx4PXRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuY29uc3VtZUluZGV4KTt0aGlzLmNvbnN1bWVJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSx0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpO2NvbnN0IGI9e25hbWU6bj09bnVsbD92b2lkIDA6bi50b1N0cmluZygpLGNsYXNzTmFtZToiTGFzZXJQZW4iLG9wYWNpdHk6Y3x8MSxsaW5lRGFzaDpvPT09RHQuRG90dGVkP1sxLHUqMl06bz09PUR0LkxvbmdEb3R0ZWQ/W3UsdSoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6ZyxsaW5lQ2FwOiJyb3VuZCIsbGluZVdpZHRoOnUsYW5jaG9yOlsuNSwuNV19LEU9dGhpcy5nZXRUYXNrUG9pbnRzKHgpO2lmKEUubGVuZ3RoKXtjb25zdCBNPURhdGUubm93KCk7TS10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWUmJihsPSEwLHRoaXMuc3luY1RpbWVzdGFtcD1NLHRoaXMuc3luY0luZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aCksIXImJnRoaXMuZHJhdyh7YXR0cnM6Yix0YXNrczpFLGlzRG90OiExfSl9Y29uc3Qgdj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UoeSkuZm9yRWFjaChNPT57di5wdXNoKE0ueCxNLnkpfSkse3JlY3Q6e3g6cC54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6cC55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6cC53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOnAuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19LHR5cGU6eXQuRHJhd1dvcmssZGF0YVR5cGU6QXQuTG9jYWwsd29ya0lkOmw/bjp2b2lkIDAsb3A6bD92OnZvaWQgMCxpbmRleDpsP3kqMjp2b2lkIDB9fWNvbnN1bWVBbGwoKXt2YXIgbjtjb25zdCBlPShuPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6bi50b1N0cmluZygpO2xldCB0O2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xPnRoaXMuY29uc3VtZUluZGV4KXtsZXQgZD10aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLmNvbnN1bWVJbmRleCk7Y29uc3QgZz1kLmxlbmd0aD09PTEse2NvbG9yOnUsdGhpY2tuZXNzOm8sc3Ryb2tlVHlwZTpjLG9wYWNpdHk6cH09dGhpcy53b3JrT3B0aW9ucztpZihnKXtjb25zdCB4PXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDpkWzBdLHJhZGl1czpvLzJ9KTtkPXgucHMsdD14LnJlY3R9ZWxzZSB0PUp0KHRoaXMudG1wUG9pbnRzLG8pO2NvbnN0IGw9e25hbWU6ZT09bnVsbD92b2lkIDA6ZS50b1N0cmluZygpLGNsYXNzTmFtZToiTGFzZXJQZW4iLGZpbGxDb2xvcjpnP3U6dm9pZCAwLG9wYWNpdHk6cHx8MSxsaW5lRGFzaDpjPT09RHQuRG90dGVkJiYhZz9bMSxvKjJdOmM9PT1EdC5Mb25nRG90dGVkJiYhZz9bbyxvKjJdOnZvaWQgMCxzdHJva2VDb2xvcjp1LGxpbmVDYXA6Zz92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6Zz8wOm8sYW5jaG9yOlsuNSwuNV19LHk9dGhpcy5nZXRUYXNrUG9pbnRzKGQpO3kubGVuZ3RoJiZ0aGlzLmRyYXcoe2F0dHJzOmwsdGFza3M6eSxpc0RvdDpnfSl9Y29uc3Qgcj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5zeW5jSW5kZXgpLmZvckVhY2goZD0+e3IucHVzaChkLngsZC55KX0pLHtyZWN0OnQmJnt4OnQueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OnQueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3OnQudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDp0LmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfSx0eXBlOnl0LkRyYXdXb3JrLGRhdGFUeXBlOkF0LkxvY2FsLHdvcmtJZDplLG9wOnIsaW5kZXg6dGhpcy5zeW5jSW5kZXgqMn19Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNJbmRleD0wfWNvbnN1bWVTZXJ2aWNlKGUpe3ZhciB4O2NvbnN0e29wOnR9PWUse2NvbG9yOnIsdGhpY2tuZXNzOm4sc3Ryb2tlVHlwZTpkLG9wYWNpdHk6Z309dGhpcy53b3JrT3B0aW9ucztpZighdC5sZW5ndGgpe2NvbnN0IGI9SnQodGhpcy50bXBQb2ludHMsbik7cmV0dXJue3g6Yi54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6Yi55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6Yi53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOmIuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19fWNvbnN0IHU9TWF0aC5tYXgoMCx0aGlzLnRtcFBvaW50cy5sZW5ndGgtMSk7dGhpcy51cGRhdGVUZW1wUG9pbnRzKHR8fFtdKTtsZXQgbyxjPXRoaXMudG1wUG9pbnRzLnNsaWNlKHUpO2NvbnN0IHA9Yy5sZW5ndGg9PT0xO2lmKHApe2NvbnN0IGI9dGhpcy5jb21wdXREb3RTdHJva2Uoe3BvaW50OmNbMF0scmFkaXVzOm4vMn0pO2M9Yi5wcyxvPWIucmVjdH1lbHNlIG89SnQodGhpcy50bXBQb2ludHMsbik7Y29uc3QgbD17bmFtZTooeD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOngudG9TdHJpbmcoKSxjbGFzc05hbWU6Ikxhc2VyUGVuIixmaWxsQ29sb3I6cD9yOnZvaWQgMCxvcGFjaXR5Omd8fDEsbGluZURhc2g6ZD09PUR0LkRvdHRlZCYmIXA/WzEsbioyXTpkPT09RHQuTG9uZ0RvdHRlZCYmIXA/W24sbioyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6cixsaW5lQ2FwOnA/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOnA/MDpuLGFuY2hvcjpbLjUsLjVdfSx5PXRoaXMuZ2V0VGFza1BvaW50cyhjKTtyZXR1cm4geS5sZW5ndGgmJnRoaXMuZHJhdyh7YXR0cnM6bCx0YXNrczp5LGlzRG90OnB9KSx7eDpvLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTpvLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzpvLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6by5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX19Y29tcHV0RG90U3Ryb2tlKGUpe2NvbnN0e3BvaW50OnQscmFkaXVzOnJ9PWUsbj17eDp0Lngtcix5OnQueS1yLHc6cioyLGg6cioyfTtyZXR1cm57cHM6THQuR2V0RG90U3Ryb2tlKHQsciw4KSxyZWN0Om59fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGg7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKz0yKXtpZih0KXtjb25zdCBuPXRoaXMudG1wUG9pbnRzLnNsaWNlKC0xKVswXTtuJiZuLng9PT1lW3JdJiZuLnk9PT1lW3IrMV0mJnRoaXMudG1wUG9pbnRzLnBvcCgpfXRoaXMudG1wUG9pbnRzLnB1c2gobmV3IEx0KGVbcl0sZVtyKzFdKSl9fWFzeW5jIGRyYXcoZSl7Y29uc3R7YXR0cnM6dCx0YXNrczpyLGlzRG90Om59PWUsZD10aGlzLmZ1bGxMYXllcix7ZHVyYXRpb246Z309dGhpcy53b3JrT3B0aW9ucyx1PW5ldyBEZTtmb3IobGV0IG89MDtvPHIubGVuZ3RoO28rKyl7Y29uc3R7cG9zOmMscG9pbnRzOnB9PXJbb107bGV0IGw7bj9sPW1lKHAsITApOmw9bWUocCwhMSksdS5hdHRyKHsuLi50LHBvczpjLGQ6bH0pO2NvbnN0e3ZlcnRleDp5LGZyYWdtZW50Onh9PXRoaXMud29ya09wdGlvbnM7aWYoeSYmeCl7Y29uc3QgYj1kLnJlbmRlcmVyLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDp5LGZyYWdtZW50Onh9KSx7d2lkdGg6RSxoZWlnaHQ6dn09ZC5nZXRSZXNvbHV0aW9uKCk7dS5zZXRVbmlmb3Jtcyh7dV90aW1lOjAsdV9yZXNvbHV0aW9uOltFLHZdfSksdS5zZXRQcm9ncmFtKGIpfWQuYXBwZW5kQ2hpbGQodSksYXdhaXQgdS50cmFuc2l0aW9uKGcpLmF0dHIoe3NjYWxlOm4/Wy4xLC4xXTpbMSwxXSxsaW5lV2lkdGg6bj8wOjF9KSx1LnJlbW92ZSgpfX1nZXRUYXNrUG9pbnRzKGUpe3ZhciBvO2NvbnN0IHQ9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCByPTAsbj1lWzBdLngsZD1lWzBdLnksZz1bbixkXSx1PVtdO2Zvcig7cjxlLmxlbmd0aDspe2NvbnN0IGM9ZVtyXSxwPWMueC1uLGw9Yy55LWQ7aWYodS5wdXNoKG5ldyBMdChwLGwpKSxyPjAmJnI8ZS5sZW5ndGgtMSl7Y29uc3QgeT1lW3JdLmdldEFuZ2xlQnlQb2ludHMoZVtyLTFdLGVbcisxXSk7aWYoeTw5MHx8eT4yNzApe2NvbnN0IHg9KG89dS5wb3AoKSk9PW51bGw/dm9pZCAwOm8uY2xvbmUoKTt4JiZ0LnB1c2goe3BvczpnLHBvaW50czpbLi4udSx4XX0pLG49ZVtyXS54LGQ9ZVtyXS55LGc9W24sZF07Y29uc3QgYj1jLngtbixFPWMueS1kO3U9W25ldyBMdChiLEUpXX19cisrfXJldHVybiB0LnB1c2goe3BvczpnLHBvaW50czp1fSksdH1yZW1vdmVMb2NhbCgpe31yZW1vdmVTZXJ2aWNlKGUpe2xldCB0O2NvbnN0IHI9W107cmV0dXJuIHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmZvckVhY2gobj0+e2lmKG4ubmFtZT09PWUpe2NvbnN0IGQ9bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0PVR0KHQse3g6ZC54LHk6ZC55LHc6ZC53aWR0aCxoOmQuaGVpZ2h0fSksci5wdXNoKG4pfX0pLHIubGVuZ3RoJiZyLmZvckVhY2gobj0+bi5yZW1vdmUoKSksdH19Y2xhc3MgcG57Y29uc3RydWN0b3IoKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KX11cGRhdGVTY2VuZShlKXt0aGlzLnNjZW5lLmF0dHIoey4uLmV9KTtjb25zdHt3aWR0aDp0LGhlaWdodDpyfT1lO3RoaXMuc2NlbmUuY29udGFpbmVyLndpZHRoPXQsdGhpcy5zY2VuZS5jb250YWluZXIuaGVpZ2h0PXIsdGhpcy5zY2VuZS53aWR0aD10LHRoaXMuc2NlbmUuaGVpZ2h0PXIsdGhpcy51cGRhdGVMYXllcih7d2lkdGg6dCxoZWlnaHQ6cn0pfXVwZGF0ZUxheWVyKGUpe2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWU7dGhpcy5mdWxsTGF5ZXImJih0aGlzLmZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdCksdGhpcy5mdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixyKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LHJdKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInBvcyIsW3QqLjUsciouNV0pKSx0aGlzLmRyYXdMYXllciYmKHRoaXMuZHJhd0xheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLmRyYXdMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHIpLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXImJih0aGlzLnNuYXBzaG90RnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsciksdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNpemUiLFt0LHJdKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpfWNyZWF0ZVNjZW5lKGUpe2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWUsbj1uZXcgT2Zmc2NyZWVuQ2FudmFzKHQscik7cmV0dXJuIG5ldyBubih7Y29udGFpbmVyOm4sZGlzcGxheVJhdGlvOnRoaXMuZHByLGRlcHRoOiExLGRlc3luY2hyb25pemVkOiEwLC4uLmV9KX1jcmVhdGVMYXllcihlLHQpe2NvbnN0e3dpZHRoOnIsaGVpZ2h0Om59PXQsZD0ib2Zmc2NyZWVuIitEYXRlLm5vdygpLGc9ZS5sYXllcihkLHQpLHU9bmV3IExlKHthbmNob3I6Wy41LC41XSxwb3M6W3IqLjUsbiouNV0sc2l6ZTpbcixuXSxuYW1lOiJ2aWV3cG9ydCJ9KTtyZXR1cm4gZy5hcHBlbmQodSksdX1nZXROb2RlcyhlKXtyZXR1cm4gdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSsiIikuY29uY2F0KHRoaXMuZHJhd0xheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUrIiIpKX19Y2xhc3MgeG57Y29uc3RydWN0b3IoZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wV29ya1NoYXBlTm9kZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZWZmZWN0V29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5jdXJOb2RlTWFwPWUsdGhpcy5mdWxsTGF5ZXI9dCx0aGlzLmRyYXdMYXllcj1yfWdldFdvcmtTaGFwZShlKXtyZXR1cm4gdGhpcy53b3JrU2hhcGVzLmdldChlKX1nZXRUbXBXb3JrU2hhcGVOb2RlKCl7cmV0dXJuIHRoaXMudG1wV29ya1NoYXBlTm9kZX1zZXRUbXBXb3JrSWQoZSl7aWYoZSYmdGhpcy50bXBXb3JrU2hhcGVOb2RlKXt0aGlzLnRtcFdvcmtTaGFwZU5vZGUuc2V0V29ya0lkKGUpLHRoaXMud29ya1NoYXBlcy5zZXQoZSx0aGlzLnRtcFdvcmtTaGFwZU5vZGUpLHRoaXMudG1wT3B0JiZ0aGlzLnNldFRvb2xzT3B0KHRoaXMudG1wT3B0KTtyZXR1cm59fXNldFRtcFdvcmtPcHRpb25zKGUpe3ZhciB0Oyh0PXRoaXMudG1wV29ya1NoYXBlTm9kZSk9PW51bGx8fHQuc2V0V29ya09wdGlvbnMoZSl9c2V0V29ya09wdGlvbnMoZSx0KXt2YXIgbjt0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfHx0aGlzLnNldFRtcFdvcmtJZChlKSwobj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbHx8bi5zZXRXb3JrT3B0aW9ucyh0KX1jcmVhdGVXb3JrU2hhcGVOb2RlKGUpe2xldCB0O3N3aXRjaChlLnRvb2xzVHlwZSl7Y2FzZSBTdC5QZW5jaWw6dD1uZXcganQoZS50b29sc09wdCx0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcik7YnJlYWs7Y2FzZSBTdC5MYXNlclBlbjp0PW5ldyBhcihlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztjYXNlIFN0LkVyYXNlcjp0PW5ldyBLdChlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztjYXNlIFN0LlNlbGVjdG9yOnQ9bmV3IHZ0KGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpO2JyZWFrO2RlZmF1bHQ6dD12b2lkIDA7YnJlYWt9cmV0dXJuIHR9c2V0VG9vbHNPcHQoZSl7dmFyIHQscixuOygodD10aGlzLnRtcE9wdCk9PW51bGw/dm9pZCAwOnQudG9vbHNUeXBlKSE9PWUudG9vbHNUeXBlJiYoKChyPXRoaXMudG1wT3B0KT09bnVsbD92b2lkIDA6ci50b29sc1R5cGUpPT09U3QuU2VsZWN0b3ImJnRoaXMuYmx1clNlbGVjdG9yKCksKG49dGhpcy50bXBPcHQpIT1udWxsJiZuLnRvb2xzVHlwZSYmdGhpcy5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpKSx0aGlzLnRtcE9wdD1lLHRoaXMudG1wV29ya1NoYXBlTm9kZT10aGlzLmNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl9Y2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoZSl7dmFyIHQ7KHQ9dGhpcy5nZXRXb3JrU2hhcGUoZSkpPT1udWxsfHx0LmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKGU9PmUuY2xlYXJUbXBQb2ludHMoKSksdGhpcy53b3JrU2hhcGVzLmNsZWFyKCl9cnVuRWZmZWN0V29yayhlKXt0aGlzLmVmZmVjdFdvcmtJZCYmKGNsZWFyVGltZW91dCh0aGlzLmVmZmVjdFdvcmtJZCksdGhpcy5lZmZlY3RXb3JrSWQ9dm9pZCAwKSx0aGlzLmVmZmVjdFdvcmtJZD1zZXRUaW1lb3V0KCgpPT57dGhpcy5lZmZlY3RXb3JrSWQ9dm9pZCAwLHRoaXMuY29tcHV0Tm9kZU1hcCgpLHRoaXMucmVyUmVuZGVyU2VsZWN0b3IoKSxlJiZlKCl9LDUwKX1jb21wdXROb2RlTWFwKCl7dmFyIHQscjtjb25zdCBlPW5ldyBTZXQodGhpcy5jdXJOb2RlTWFwLmtleXMoKSk7aWYodGhpcy5mdWxsTGF5ZXIuY2hpbGRyZW4uZm9yRWFjaChuPT57aWYobi5uYW1lIT09dnQuc2VsZWN0b3JJZCl7Y29uc3QgZD1YdChuLm5hbWUsdGhpcy5mdWxsTGF5ZXIpO2lmKGQpe2NvbnN0IGc9dGhpcy5jdXJOb2RlTWFwLmdldChuLm5hbWUpO2c/KGcucmVjdD1kLGUuZGVsZXRlKG4ubmFtZSkpOnRoaXMuY3VyTm9kZU1hcC5zZXQobi5uYW1lLHtuYW1lOm4ubmFtZSxyZWN0OmR9KX19fSksKHI9KHQ9dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDp0LmNoaWxkcmVuKT09bnVsbHx8ci5mb3JFYWNoKG49PntpZihuLm5hbWUhPT12dC5zZWxlY3RvcklkKXtjb25zdCBkPVh0KG4ubmFtZSx0aGlzLmRyYXdMYXllcik7aWYoZCl7Y29uc3QgZz10aGlzLmN1ck5vZGVNYXAuZ2V0KG4ubmFtZSk7Zz8oZy5yZWN0PWQsZS5kZWxldGUobi5uYW1lKSk6dGhpcy5jdXJOb2RlTWFwLnNldChuLm5hbWUse25hbWU6bi5uYW1lLHJlY3Q6ZH0pfX19KSxlLnNpemUpZm9yKGNvbnN0IG4gb2YgZS5rZXlzKCkpdGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShuKX11cGRhdGFOb2RlTWFwKGUpe2NvbnN0e2tleTp0LG9wczpyLG9wdDpuLHRvb2xzVHlwZTpkfT1lO2xldCBnPVh0KHQsdGhpcy5mdWxsTGF5ZXIpO2NvbnN0IHU9dGhpcy5jdXJOb2RlTWFwLmdldCh0KXx8e25hbWU6dCxyZWN0Omd9O3ImJih1Lm9wcz1yKSxuJiYodS5vcHQ9biksZyYmKHUucmVjdD1nKSxkJiYodS50b29sc1R5cGU9ZCksdGhpcy5kcmF3TGF5ZXImJihnPVh0KHQsdGhpcy5kcmF3TGF5ZXIpLGcmJnRoaXMuZHJhd0xheWVyJiYodS5yZWN0PWcpKSx1LnJlY3Q/dGhpcy5jdXJOb2RlTWFwLnNldCh0LHUpOnRoaXMuY3VyTm9kZU1hcC5kZWxldGUodCl9cmVyUmVuZGVyU2VsZWN0b3IoKXt2YXIgdDtjb25zdCBlPXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCk7aWYoKHQ9ZT09bnVsbD92b2lkIDA6ZS5zZWxlY3RJZHMpIT1udWxsJiZ0Lmxlbmd0aCYmdGhpcy5kcmF3TGF5ZXIpe2NvbnN0IHI9ZS5nZXRTZWxlY3Rvcih0aGlzLmN1ck5vZGVNYXApO3ImJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6cixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6cHQuU2VsZWN0b3IsZHJhd0NhbnZhczpwdC5TZWxlY3Rvcn1dLHNwOlt7dHlwZTp5dC5TZWxlY3Qsc2VsZWN0SWRzOmUuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6cix3aWxsU3luY1NlcnZpY2U6ITF9XX0pfX19Y2xhc3MgTW57Y29uc3RydWN0b3IoZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLmN1ck5vZGVNYXA9ZSx0aGlzLmZ1bGxMYXllcj10LHRoaXMuZHJhd0xheWVyPXJ9dXBkYXRhTm9kZU1hcChlLHQscil7bGV0IG49WHQoZSx0aGlzLmZ1bGxMYXllcik7Y29uc3QgZD10aGlzLmN1ck5vZGVNYXAuZ2V0KGUpfHx7bmFtZTplLHJlY3Q6bn07dCYmKGQub3BzPXQpLHImJihkLm9wdD1yKSxuJiYoZC5yZWN0PW4pLHRoaXMuZHJhd0xheWVyJiYobj1YdChlLHRoaXMuZHJhd0xheWVyKSxuJiZ0aGlzLmRyYXdMYXllciYmKGQucmVjdD1uKSksZC5yZWN0P3RoaXMuY3VyTm9kZU1hcC5zZXQoZSxkKTp0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKGUpfX1jbGFzcyBFbiBleHRlbmRzIHhue2NvbnN0cnVjdG9yKGUsdCxyLG4pe3N1cGVyKGUsdCxyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3Bvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZVVuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6NjAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbWJpbmVUaW1lcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdDb3VudCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZWZmZWN0U2VsZWN0Tm9kZURhdGEiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgU2V0fSksdGhpcy5fcG9zdD1ufWRyYXdQZW5jaWxDb21iaW5lKGUpe3ZhciByLG47Y29uc3QgdD0ocj10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbD92b2lkIDA6ci5jb21iaW5lQ29uc3VtZSgpO2lmKHQpe2NvbnN0IGQ9e3JlbmRlcjpbXSxkcmF3Q291bnQ6dGhpcy5kcmF3Q291bnR9OyhuPWQucmVuZGVyKT09bnVsbHx8bi5wdXNoKHtyZWN0OnQ9PW51bGw/dm9pZCAwOnQucmVjdCxpc0NsZWFyOiEwLGRyYXdDYW52YXM6cHQuRmxvYXQsY2xlYXJDYW52YXM6cHQuRmxvYXQsaXNGdWxsV29yazohMX0pLHRoaXMuX3Bvc3QoZCl9fWRyYXdTZWxlY3RvcihlLHQpe3ZhciBuLGQsZztjb25zdCByPXtyZW5kZXI6W10sc3A6W2VdfTsobj1lLnNlbGVjdElkcykhPW51bGwmJm4ubGVuZ3RoJiYhdCYmKChkPXIucmVuZGVyKT09bnVsbHx8ZC5wdXNoKHtyZWN0OmUuc2VsZWN0UmVjdCxkcmF3Q2FudmFzOnB0LlNlbGVjdG9yLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6cHQuU2VsZWN0b3IsaXNGdWxsV29yazohMX0se3JlY3Q6ZS5zZWxlY3RSZWN0fHxlLnJlY3QsaXNDbGVhcjohMCxjbGVhckNhbnZhczpwdC5GbG9hdCxpc0Z1bGxXb3JrOiExfSx7cmVjdDplLnJlY3QsZHJhd0NhbnZhczpwdC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnB0LkJnLGlzRnVsbFdvcms6ITB9KSksdCYmKChnPXIucmVuZGVyKT09bnVsbHx8Zy5wdXNoKHtyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnB0LkZsb2F0LGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6cHQuRmxvYXQsaXNGdWxsV29yazohMX0se3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6cHQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpwdC5CZyxpc0Z1bGxXb3JrOiEwfSkpLHRoaXMuX3Bvc3Qocil9YXN5bmMgZHJhd0VyYXNlcihlLHQpe3ZhciBuLGQsZyx1O2NvbnN0IHI9W107KG49ZS5uZXdXb3JrRGF0YXMpIT1udWxsJiZuLmxlbmd0aCYmKHIucHVzaCguLi5lLm5ld1dvcmtEYXRhcy5tYXAobz0+KHt0eXBlOnl0LkZ1bGxXb3JrLHdvcmtJZDpvLndvcmtJZCxvcHM6eWUoby5vcCksb3B0Om8ub3B0LHRvb2xzVHlwZTpvLnRvb2xzVHlwZSx1cGRhdGVOb2RlT3B0Ont1c2VBbmltYXRpb246ITF9fSkpKSxkZWxldGUgZS5uZXdXb3JrRGF0YXMpLHIucHVzaChlKSxhd2FpdCB0aGlzLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmUucmVjdCxkcmF3Q2FudmFzOnB0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6cHQuQmcsaXNGdWxsV29yazohMH1dLHNwOnJ9KTtmb3IobGV0IG89MDtvPHIubGVuZ3RoO28rKylpZigoZD1yW29dLnJlbW92ZUlkcykhPW51bGwmJmQubGVuZ3RoKShnPXJbb10ucmVtb3ZlSWRzKT09bnVsbHx8Zy5mb3JFYWNoKGM9Pnt0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKGMpLHQuY3VyTm9kZU1hcC5kZWxldGUoYyl9KTtlbHNlIGlmKHJbb10udHlwZT09PXl0LkZ1bGxXb3JrKXtjb25zdCBjPSh1PXJbb10ud29ya0lkKT09bnVsbD92b2lkIDA6dS50b1N0cmluZygpO2lmKGMpe2NvbnN0IHA9cltvXS5vcHMsbD1yW29dLm9wdCx5PXJbb10udG9vbHNUeXBlO3RoaXMudXBkYXRhTm9kZU1hcCh7a2V5OmMsb3BzOnAsb3B0OmwsdG9vbHNUeXBlOnl9KX19fWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHNwOihlPT1udWxsP3ZvaWQgMDplLm9wKSYmW2VdfSl9ZHJhd1BlbmNpbEZ1bGwoZSx0KXt2YXIgbjtjb25zdCByPXtkcmF3Q291bnQ6MS8wLHJlbmRlcjpbe3JlY3Q6ZS5yZWN0LGRyYXdDYW52YXM6cHQuQmcsaXNDbGVhcjoodC5vcGFjaXR5fHwxKTwxLGNsZWFyQ2FudmFzOnB0LkJnLGlzRnVsbFdvcms6ITB9XSxzcDpbZV19OyhuPXIucmVuZGVyKT09bnVsbHx8bi5wdXNoKHtpc0NsZWFyQWxsOiEwLGNsZWFyQ2FudmFzOnB0LkZsb2F0LGlzRnVsbFdvcms6ITF9KSx0aGlzLl9wb3N0KHIpLnRoZW4oKCk9PntlLndvcmtJZCYmdGhpcy51cGRhdGFOb2RlTWFwKHtrZXk6ZS53b3JrSWQudG9TdHJpbmcoKSxvcHM6ZS5vcHMsdG9vbHNUeXBlOlN0LlBlbmNpbCxvcHQ6dH0pfSl9Y29uc3VtZURyYXcoZSx0KXt2YXIgZDtjb25zdHtvcDpyLHdvcmtJZDpufT1lO2lmKHIhPW51bGwmJnIubGVuZ3RoJiZuKXtjb25zdCBnPXRoaXMud29ya1NoYXBlcy5nZXQobik7aWYoIWcpcmV0dXJuO2NvbnN0IHU9Zy50b29sc1R5cGU7aWYodT09PVN0Lkxhc2VyUGVuKXJldHVybjtjb25zdCBvPWcuY29uc3VtZSh7ZGF0YTplLGlzRnVsbFdvcms6ITAsbm9kZU1hcHM6dGhpcy5jdXJOb2RlTWFwfSk7aWYodT09PVN0LlNlbGVjdG9yKXtvLnR5cGU9PT15dC5TZWxlY3QmJihvLnNlbGVjdElkcyYmdC5ydW5SZXZlcnNlU2VsZWN0V29yayhvLnNlbGVjdElkcyksdGhpcy5kcmF3U2VsZWN0b3IobywhMCkpO3JldHVybn1pZih1PT09U3QuRXJhc2VyKXtpZigoZD1vLm5ld1dvcmtEYXRhcykhPW51bGwmJmQubGVuZ3RoKXtsZXQgYz1vPT1udWxsP3ZvaWQgMDpvLnJlY3Q7by5uZXdXb3JrRGF0YXMuZm9yRWFjaChwPT57Y29uc3QgbD10aGlzLnNldEZ1bGxXb3JrKHApLHk9bCYmbC5jb25zdW1lU2VydmljZSh7b3A6cC5vcCxpc0Z1bGxXb3JrOiEwfSkseD1wLndvcmtJZC50b1N0cmluZygpO3kmJihnLnVwZGF0YU5vZGVNYXAoeCx7bmFtZTp4LHJlY3Q6eSxvcHQ6cC5vcHQsdG9vbHNUeXBlOnAudG9vbHNUeXBlLG9wOnAub3B9KSxjPVR0KGMseSkpfSksYyYmKG8ucmVjdD1jKX1vIT1udWxsJiZvLnJlY3QmJnRoaXMuZHJhd0VyYXNlcihvLGcpO3JldHVybn11PT09U3QuUGVuY2lsJiYodGhpcy5jb21iaW5lVGltZXJJZHx8KHRoaXMuY29tYmluZVRpbWVySWQ9c2V0VGltZW91dCgoKT0+e3RoaXMuY29tYmluZVRpbWVySWQ9dm9pZCAwLHRoaXMuZHJhd1BlbmNpbENvbWJpbmUobil9LE1hdGguZmxvb3IoZy5nZXRXb3JrT3B0aW9ucygpLnN5bmNVbml0VGltZXx8dGhpcy5jb21iaW5lVW5pdFRpbWUvMikpKSxvJiYodGhpcy5kcmF3Q291bnQrKyx0aGlzLmRyYXdQZW5jaWwobykpKX19Y29uc3VtZURyYXdBbGwoZSx0KXt2YXIgZDt0aGlzLmNvbWJpbmVUaW1lcklkJiYoY2xlYXJUaW1lb3V0KHRoaXMuY29tYmluZVRpbWVySWQpLHRoaXMuY29tYmluZVRpbWVySWQ9dm9pZCAwKTtjb25zdHt3b3JrSWQ6cix1bmRvVGlja2VySWQ6bn09ZTtpZihyKXtuJiZzZXRUaW1lb3V0KCgpPT57dGhpcy5fcG9zdCh7c3A6W3t0eXBlOnl0Lk5vbmUsdW5kb1RpY2tlcklkOm59XX0pfSwwKTtjb25zdCBnPXRoaXMud29ya1NoYXBlcy5nZXQocik7aWYoIWcpcmV0dXJuO2NvbnN0IHU9Zy50b29sc1R5cGU7aWYodT09PVN0Lkxhc2VyUGVuKXJldHVybjtjb25zdCBvPWcuY29uc3VtZUFsbCh7ZGF0YTplLG5vZGVNYXBzOnRoaXMuY3VyTm9kZU1hcH0pO2lmKHU9PT1TdC5TZWxlY3Rvcil7by5zZWxlY3RJZHMmJnQucnVuUmV2ZXJzZVNlbGVjdFdvcmsoby5zZWxlY3RJZHMpLHRoaXMuZHJhd1NlbGVjdG9yKG8sITEpLChkPWcuc2VsZWN0SWRzKSE9bnVsbCYmZC5sZW5ndGg/Zy5jbGVhclRtcFBvaW50cygpOnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUocik7cmV0dXJufWlmKHU9PT1TdC5FcmFzZXIpe28hPW51bGwmJm8ucmVjdCYmdGhpcy5kcmF3RXJhc2VyKG8sZyksZy5jbGVhclRtcFBvaW50cygpO3JldHVybn11PT09U3QuUGVuY2lsJiYobyE9bnVsbCYmby5yZWN0JiYodGhpcy5kcmF3UGVuY2lsRnVsbChvLGcuZ2V0V29ya09wdGlvbnMoKSksdGhpcy5kcmF3Q291bnQ9MCksdGhpcy5jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShyKSl9fWFzeW5jIHVwZGF0ZVNlbGVjdG9yKGUpe3ZhciBFLHYsTSxpO2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldCh2dC5zZWxlY3RvcklkKTtpZighKChFPXQuc2VsZWN0SWRzKSE9bnVsbCYmRS5sZW5ndGgpKXJldHVybjtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6ZCx3aWxsU2VyaWFsaXplRGF0YTpnLGVtaXRFdmVudFR5cGU6dSxzZWxlY3RTdG9yZTpvLGlzU3luYzpjfT1lLHA9ci53b3JrU3RhdGUsbD0odT09PWJ0LlJvdGF0ZU5vZGV8fHU9PT1idC5TY2FsZU5vZGUpJiZwPT09R3QuRG9uZSYmZyx5PXQ9PW51bGw/dm9pZCAwOnQudXBkYXRlU2VsZWN0b3Ioe3VwZGF0ZVNlbGVjdG9yT3B0OnIsc2VsZWN0SWRzOnQuc2VsZWN0SWRzfSk7bGV0IHg9W107dT09PWJ0LlNjYWxlTm9kZSYmeC5wdXNoKHtpc0NsZWFyQWxsOiEwLGlzRnVsbFdvcms6ITEsY2xlYXJDYW52YXM6cHQuU2VsZWN0b3J9KSx5JiZuJiZ4LnB1c2goe3JlY3Q6eS5yZWN0LGlzQ2xlYXI6dSE9PWJ0LlNjYWxlTm9kZSxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOnB0LlNlbGVjdG9yLGRyYXdDYW52YXM6cHQuU2VsZWN0b3J9KSx5JiZuJiZnJiZ4JiYhbCYmKGF3YWl0IHRoaXMuX3Bvc3Qoe3JlbmRlcjp4fSkseD12b2lkIDApO2NvbnN0IGI9bmV3IE1hcDtpZihnJiZ5IT1udWxsJiZ5LnVwZGF0ZU5vZGVPcHRzJiZvKWZvcihjb25zdFthLHNdb2Ygby5lbnRyaWVzKCkpe2NvbnN0e29wczpmLG9wdDpPLHVwZGF0ZU5vZGVPcHQ6QSx0b29sc1R5cGU6Un09cztsZXQgSTtjb25zdCBQPU8sTD17Li4uQSwuLi55LnVwZGF0ZU5vZGVPcHRzLmdldChhKX07bGV0IEQ9W107aWYoUCYmTC5jb2xvciYmKFAuY29sb3I9TC5jb2xvcixkZWxldGUgTC5jb2xvciksUCYmTC56SW5kZXgmJihQLnpJbmRleD1MLnpJbmRleCxkZWxldGUgTC56SW5kZXgpLFAmJkwub3BhY2l0eSYmKFAub3BhY2l0eT1MLm9wYWNpdHksZGVsZXRlIEwub3BhY2l0eSksZiYmKEwhPW51bGwmJkwucG9zKSYmKEwhPW51bGwmJkwub3JpZ2luUG9zKSl7Y29uc3QgQz1bTC5wb3NbMF0tTC5vcmlnaW5Qb3NbMF0sTC5wb3NbMV0tTC5vcmlnaW5Qb3NbMV1dLFM9ZWUoZikubWFwKChCLHcpPT57Y29uc3QgSD13JTM7cmV0dXJuIEg9PT0wP0IrQ1swXTpIPT09MT9CK0NbMV06Qn0pO0wuc2NhbGUmJihobihTLEwucG9zLEwuc2NhbGUpLEQ9UyxkZWxldGUgTC5zY2FsZSksST15ZShTKSwodj10aGlzLmRyYXdMYXllcik9PW51bGx8fHYuZ2V0RWxlbWVudHNCeU5hbWUoYSkuZm9yRWFjaChCPT57aWYoTC5wb3Mpe2NvbnN0IHc9Qi5jbGFzc05hbWUuc3BsaXQoIiwiKTtCLnNldEF0dHJpYnV0ZSgiY2xhc3NOYW1lIixgJHtMLnBvc1swXX0sICR7TC5wb3NbMV19LCAke3dbMl19YCl9fSksZGVsZXRlIEwub3JpZ2luUG9zfWlmKGYmJkwuYW5nbGUmJkwub3JpZ2luUG9zKXtjb25zdCBDPWVlKGYpO3VuKEMsTC5vcmlnaW5Qb3MsTC5hbmdsZSksRD1DLEk9eWUoQyksZGVsZXRlIEwuYW5nbGUsZGVsZXRlIEwub3JpZ2luUG9zfWlmKFImJmYmJk8mJkQubGVuZ3RoKXtjb25zdCBDPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNUeXBlOlIsdG9vbHNPcHQ6T30pO0M9PW51bGx8fEMuc2V0V29ya0lkKGEpLEM9PW51bGx8fEMuY29uc3VtZVNlcnZpY2Uoe29wOkQsaXNGdWxsV29yazohMSxyZXBsYWNlSWQ6YSxpc0NsZWFyQWxsOiExfSl9Yi5zZXQoYSx7b3BzOkksdXBkYXRlTm9kZU9wdDpMLG9wdDpQLHRvb2xzVHlwZTpSfSl9aWYoeSYmKChNPXkudXBkYXRlTm9kZU9wdHMpIT1udWxsJiZNLnNpemUpKXtkZWxldGUgci53b3JrU3RhdGU7Y29uc3QgYT1bXTtpZihkKXtpZihnKXt1PT09YnQuUm90YXRlTm9kZSYmcD09PUd0LkRvbmUmJmEucHVzaCh7dHlwZTp5dC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eS5yZWN0LGlzU3luYzpjfSksdT09PWJ0LlNjYWxlTm9kZSYmcD09PUd0LkRvbmUmJmEucHVzaCh7dHlwZTp5dC5TZWxlY3Qsc2VsZWN0SWRzOnQuc2VsZWN0SWRzLHNlbGVjdFJlY3Q6eS5yZWN0LHdpbGxTeW5jU2VydmljZTohMX0pO2Zvcihjb25zdFtzLGZdb2YgYi5lbnRyaWVzKCkpYS5wdXNoKHsuLi5mLHdvcmtJZDpzLHR5cGU6eXQuVXBkYXRlTm9kZSxpc1N5bmM6Y30pfWVsc2V7dT09PWJ0LlNjYWxlTm9kZSYmcD09PUd0LlN0YXJ0JiZhLnB1c2goe3R5cGU6eXQuU2VsZWN0LHNlbGVjdElkczp0LnNlbGVjdElkcyxzZWxlY3RSZWN0OnkucmVjdCxjYW52YXNXaWR0aDp0aGlzLmZ1bGxMYXllci5wYXJlbnQud2lkdGgsY2FudmFzSGVpZ2h0OnRoaXMuZnVsbExheWVyLnBhcmVudC5oZWlnaHQsd2lsbFN5bmNTZXJ2aWNlOiExfSk7Zm9yKGNvbnN0W3MsZl1vZiB5LnVwZGF0ZU5vZGVPcHRzLmVudHJpZXMoKSlhLnB1c2goe3dvcmtJZDpzLHR5cGU6eXQuVXBkYXRlTm9kZSx1cGRhdGVOb2RlT3B0OmYsaXNTeW5jOmN9KX1hd2FpdCB0aGlzLl9wb3N0KHtyZW5kZXI6IWwmJnh8fHZvaWQgMCxzcDphfSl9IWwmJnA9PT1HdC5Eb25lJiYoKGk9dC5zZWxlY3RJZHMpPT1udWxsfHxpLmZvckVhY2gocz0+e2NvbnN0IGY9YT09bnVsbD92b2lkIDA6YS5maW5kKE89PihPPT1udWxsP3ZvaWQgMDpPLndvcmtJZCkmJk8ud29ya0lkPT09cyk7dGhpcy51cGRhdGFOb2RlTWFwKHtrZXk6cyxvcHM6Zj09bnVsbD92b2lkIDA6Zi5vcHMsb3B0OmY9PW51bGw/dm9pZCAwOmYub3B0fSl9KSksbCYmKHghPW51bGwmJngubGVuZ3RoKSYmc2V0VGltZW91dCgoKT0+e3RoaXMuX3Bvc3Qoe3JlbmRlcjp4fSkudGhlbigoKT0+e3ZhciBzO3A9PT1HdC5Eb25lJiYoKHM9dC5zZWxlY3RJZHMpPT1udWxsfHxzLmZvckVhY2goZj0+e2NvbnN0IE89YT09bnVsbD92b2lkIDA6YS5maW5kKEE9PihBPT1udWxsP3ZvaWQgMDpBLndvcmtJZCkmJkEud29ya0lkPT09Zik7dGhpcy51cGRhdGFOb2RlTWFwKHtrZXk6ZixvcHM6Tz09bnVsbD92b2lkIDA6Ty5vcHMsb3B0Ok89PW51bGw/dm9pZCAwOk8ub3B0fSl9KSl9KX0sMjApfX1ibHVyU2VsZWN0b3IoKXtjb25zdCBlPXRoaXMud29ya1NoYXBlcy5nZXQodnQuc2VsZWN0b3JJZCk7aWYoZSl7Y29uc3QgdD1lPT1udWxsP3ZvaWQgMDplLmJsdXJTZWxlY3Rvcih0aGlzLmN1ck5vZGVNYXApO3RoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodnQuc2VsZWN0b3JJZCksdGhpcy5fcG9zdCh7cmVuZGVyOih0PT1udWxsP3ZvaWQgMDp0LnJlY3QpJiZbe3JlY3Q6dC5yZWN0LGRyYXdDYW52YXM6cHQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpwdC5CZyxpc0Z1bGxXb3JrOiEwfV0sc3A6W3RdfSl9fXNldEZ1bGxXb3JrKGUpe2NvbnN0e3dvcmtJZDp0LG9wdDpyLHRvb2xzVHlwZTpufT1lO2lmKHQmJnImJm4pe2NvbnN0IGQ9dCYmdGhpcy53b3JrU2hhcGVzLmdldCh0KXx8dGhpcy5jcmVhdGVXb3JrU2hhcGVOb2RlKHt0b29sc09wdDpyLHRvb2xzVHlwZTpufSk7cmV0dXJuIGQ/KGQuc2V0V29ya0lkKHQpLHRoaXMud29ya1NoYXBlcy5zZXQodCxkKSxkKTp2b2lkIDB9fWNvbnN1bWVGdWxsKGUpe3ZhciBuO2NvbnN0IHQ9dGhpcy5zZXRGdWxsV29yayhlKSxyPWUub3BzJiZlZShlLm9wcyk7aWYodCl7bGV0IGQ9dC5jb25zdW1lU2VydmljZSh7b3A6cixpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDoobj10LmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6bi50b1N0cmluZygpfSk7ZD1UdChkLChlPT1udWxsP3ZvaWQgMDplLnVwZGF0ZU5vZGVPcHQpJiZ0LnVwZGF0YU9wdFNlcnZpY2UoZS51cGRhdGVOb2RlT3B0KSksZCYmZS53aWxsUmVmcmVzaCYmdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDpkLGRyYXdDYW52YXM6cHQuQmcsaXNGdWxsV29yazohMH1dLHNwOmUud2lsbFN5bmNTZXJ2aWNlJiZbe29wdDplLm9wdCx0b29sc1R5cGU6ZS50b29sc1R5cGUsdHlwZTp5dC5GdWxsV29yayx3b3JrSWQ6ZS53b3JrSWQsb3BzOmUub3BzLHVwZGF0ZU5vZGVPcHQ6ZS51cGRhdGVOb2RlT3B0LHVuZG9UaWNrZXJJZDplLnVuZG9UaWNrZXJJZH1dfHx2b2lkIDB9KS50aGVuKCgpPT57dmFyIGc7ZS53b3JrSWQmJnRoaXMudXBkYXRhTm9kZU1hcCh7a2V5OihnPWUud29ya0lkKT09bnVsbD92b2lkIDA6Zy50b1N0cmluZygpLG9wczplLm9wcyxvcHQ6ZS5vcHQsdG9vbHNUeXBlOmUudG9vbHNUeXBlfSl9KSxlLndvcmtJZCYmdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlLndvcmtJZCl9fXVwZGF0ZU5vZGUoZSl7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoOm4sd2lsbFN5bmNTZXJ2aWNlOmR9PWU7aWYodCl7Y29uc3QgZz10LnRvU3RyaW5nKCk7bGV0IHU7Y29uc3Qgbz17fTt0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShnKS5mb3JFYWNoKGM9PntpZihuKXtjb25zdCBwPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dT1UdCh1LHt4Ok1hdGguZmxvb3IocC54LTEwKSx5Ok1hdGguZmxvb3IocC55LTEwKSx3Ok1hdGguZmxvb3IocC53aWR0aCsyMCksaDpNYXRoLmZsb29yKHAuaGVpZ2h0KzIwKX0pfWlmKHIucG9zJiYoby5wb3M9ci5wb3MsYy5zZXRBdHRyaWJ1dGUoInBvcyIsci5wb3MpKSxyLnpJbmRleERpc3RhbmNlfHxyLnpJbmRleCl7aWYoci56SW5kZXhEaXN0YW5jZSl7Y29uc3QgcD1jLmdldEF0dHJpYnV0ZSgiekluZGV4Iik7by56SW5kZXg9cCtyLnpJbmRleH1lbHNlIG8uekluZGV4PXIuekluZGV4O2Muc2V0QXR0cmlidXRlKCJ6SW5kZXgiLG8uekluZGV4KX1pZihyLmNvbG9yJiYoby5jb2xvcj1yLmNvbG9yLGMuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsby5jb2xvciksYy5nZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIpJiZjLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLG8uY29sb3IpKSxuKXtjb25zdCBwPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dT1UdCh1LHt4Ok1hdGguZmxvb3IocC54LTEwKSx5Ok1hdGguZmxvb3IocC55LTEwKSx3Ok1hdGguZmxvb3IocC53aWR0aCsyMCksaDpNYXRoLmZsb29yKHAuaGVpZ2h0KzIwKX0pfX0pLCh1fHxkKSYmdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDp1LGRyYXdDYW52YXM6cHQuQmcsaXNDbGVhcjohMCxjbGVhckNhbnZhczpwdC5CZyxpc0Z1bGxXb3JrOiEwfV0sc3A6ZCYmW3t0eXBlOnl0LlVwZGF0ZU5vZGUsd29ya0lkOnQsdXBkYXRlTm9kZU9wdDpvfV18fHZvaWQgMH0pfX1yZW1vdmVXb3JrKGUpe3ZhciBuO2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO2lmKHIpe3RoaXMud29ya1NoYXBlcy5oYXMocikmJnRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUocik7bGV0IGQ7Y29uc3QgZz1bXSx1PXRoaXMuY3VyTm9kZU1hcC5nZXQocik7dSYmdGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShyKSx0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShyKS5jb25jYXQoKChuPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bi5nZXRFbGVtZW50c0J5TmFtZShyKSl8fFtdKS5mb3JFYWNoKG89PntpZih1KWQ9VHQoZCx1LnJlY3QpO2Vsc2V7Y29uc3QgYz1vLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2Q9VHQoZCx7eDpjLngseTpjLnksdzpjLndpZHRoLGg6Yy5oZWlnaHR9KX1nLnB1c2gobyl9KSxnLmxlbmd0aCYmZy5mb3JFYWNoKG89Pm8ucmVtb3ZlKCkpLGQmJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6ZCxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6cHQuQmcsZHJhd0NhbnZhczpwdC5CZ31dfSksdGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShyKX19cnVuUmV2ZXJzZVNlbGVjdFdvcmsoZSl7Y29uc3QgdD10aGlzLndvcmtTaGFwZXMuZ2V0KHZ0LnNlbGVjdG9ySWQpLHtzZWxlY3RJZHM6cn09ZSxuPVtdO2lmKHQmJnImJnQuc2VsZWN0SWRzKXtmb3IoY29uc3QgZCBvZiByKXtjb25zdCBnPXQuc2VsZWN0SWRzLmZpbmRJbmRleCh1PT51PT09ZCk7Zz4tMSYmKHQuc2VsZWN0SWRzLnNwbGljZShnLDEpLG4ucHVzaChkKSl9aWYobi5sZW5ndGgpe2NvbnN0IGQ9W107dC5zZWxlY3RJZHMubGVuZ3RoIT09MCYmdGhpcy5yZXJSZW5kZXJTZWxlY3RvcigpO2xldCBnO24uZm9yRWFjaCh1PT57dmFyIGM7Y29uc3Qgbz0oYz10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmMuZ2V0RWxlbWVudHNCeU5hbWUodSlbMF07aWYobyl7Y29uc3QgcD1vLmNsb25lTm9kZSghMCk7aWYocC50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgeT1vLmNsYXNzTmFtZS5zcGxpdCgiLCIpO3kubGVuZ3RoPT09MyYmTnVtYmVyKHlbMl0pPT09RHQuU3Ryb2tlJiZwLnNlYWwoKX1kLnB1c2gocCksby5yZW1vdmUoKTtjb25zdCBsPXRoaXMuY3VyTm9kZU1hcC5nZXQodSk7bCYmKGc9VHQoZyxsLnJlY3QpKX19KSxkLmxlbmd0aCYmdGhpcy5mdWxsTGF5ZXIuYXBwZW5kKC4uLmQpLGcmJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6Zyxpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITAsY2xlYXJDYW52YXM6cHQuQmcsZHJhd0NhbnZhczpwdC5CZ31dLHNwOnQuc2VsZWN0SWRzLmxlbmd0aD09PTAmJlt7dHlwZTp5dC5TZWxlY3Qsc2VsZWN0SWRzOltdLHdpbGxTeW5jU2VydmljZTohMX1dfHx2b2lkIDB9KX19fXVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpe3ZhciBuLGQsZyx1LG87Y29uc3QgdD10aGlzLndvcmtTaGFwZXMuZ2V0KHZ0LnNlbGVjdG9ySWQpLHtzZWxlY3RJZHM6cn09ZTtpZihyIT1udWxsJiZyLmxlbmd0aHx8dGhpcy5ibHVyU2VsZWN0b3IoKSwhdCl7dGhpcy5zZXRGdWxsV29yayhlKSx0aGlzLnVwZGF0ZUZ1bGxTZWxlY3RXb3JrKGUpO3JldHVybn1pZih0JiYociE9bnVsbCYmci5sZW5ndGgpKXtjb25zdHtiZ1JlY3Q6YyxzZWxlY3RSZWN0OnB9PXQudXBkYXRlU2VsZWN0SWRzKHIsdGhpcy5jdXJOb2RlTWFwKSxsPXtyZW5kZXI6W10sc3A6W119O2MmJigobj1sLnJlbmRlcik9PW51bGx8fG4ucHVzaCh7cmVjdDpjLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMCxjbGVhckNhbnZhczpwdC5CZyxkcmF3Q2FudmFzOnB0LkJnfSkpLChkPWwucmVuZGVyKT09bnVsbHx8ZC5wdXNoKHtyZWN0OmN8fHAsaXNDbGVhcjohMCxpc0Z1bGxXb3JrOiExLGNsZWFyQ2FudmFzOnB0LlNlbGVjdG9yLGRyYXdDYW52YXM6cHQuU2VsZWN0b3J9KSwobz1sLnNwKT09bnVsbHx8by5wdXNoKHsuLi5lLG5vZGVPcGFjdGl5OihnPWUub3B0KT09bnVsbD92b2lkIDA6Zy5vcGFjaXR5LG5vZGVDb2xvcjoodT1lLm9wdCk9PW51bGw/dm9pZCAwOnUuY29sb3IsdHlwZTp5dC5TZWxlY3Qsc2VsZWN0UmVjdDpjfHxwLHdpbGxTeW5jU2VydmljZTohMX0pLHRoaXMuX3Bvc3QobCl9fWNvbGxvY3RFZmZlY3RTZWxlY3RXb3JrKGUpe2NvbnN0IHQ9dGhpcy53b3JrU2hhcGVzLmdldCh2dC5zZWxlY3RvcklkKSx7d29ya0lkOnJ9PWU7aWYodCYmciYmdC5zZWxlY3RJZHMmJnQuc2VsZWN0SWRzLmluY2x1ZGVzKHIudG9TdHJpbmcoKSkpe3RoaXMuZWZmZWN0U2VsZWN0Tm9kZURhdGEuYWRkKGUpLHNldFRpbWVvdXQoKCk9Pnt2YXIgbjt0aGlzLnJ1bkVmZmVjdFNlbGVjdFdvcmsoKSwobj10aGlzLmVmZmVjdFNlbGVjdE5vZGVEYXRhKT09bnVsbHx8bi5jbGVhcigpfSwwKTtyZXR1cm59cmV0dXJuIGV9cnVuRWZmZWN0U2VsZWN0V29yaygpe3ZhciBlLHQ7Zm9yKGNvbnN0IHIgb2YgdGhpcy5lZmZlY3RTZWxlY3ROb2RlRGF0YS52YWx1ZXMoKSl7Y29uc3Qgbj10aGlzLnNldEZ1bGxXb3JrKHIpLGQ9ci5vcHMmJmVlKHIub3BzKTtpZihuKXtsZXQgZz1uLmNvbnN1bWVTZXJ2aWNlKHtvcDpkLGlzRnVsbFdvcms6ITEscmVwbGFjZUlkOihlPW4uZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDplLnRvU3RyaW5nKCl9KTtnPVR0KGcsKHI9PW51bGw/dm9pZCAwOnIudXBkYXRlTm9kZU9wdCkmJm4udXBkYXRhT3B0U2VydmljZShyLnVwZGF0ZU5vZGVPcHQpKSxnJiZyLndvcmtJZCYmdGhpcy51cGRhdGFOb2RlTWFwKHtrZXk6KHQ9ci53b3JrSWQpPT1udWxsP3ZvaWQgMDp0LnRvU3RyaW5nKCksb3BzOnIub3BzLG9wdDpyLm9wdCx0b29sc1R5cGU6ci50b29sc1R5cGV9KSxyLndvcmtJZCYmdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShyLndvcmtJZCl9fXRoaXMucmVyUmVuZGVyU2VsZWN0b3IoKX19Y2xhc3MgT24gZXh0ZW5kcyBNbntjb25zdHJ1Y3RvcihlLHQscixuKXtzdXBlcihlLHQsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtTaGFwZXMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFuaW1hdGlvbklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNlbGVjdG9yV29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3Bvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IFNldH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJydW5FZmZlY3RJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJub0FuaW1hdGlvblJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLl9wb3N0PW59YWN0aXZlV29ya1NoYXBlKGUpe3ZhciB4LGIsRTtjb25zdHt3b3JrSWQ6dCxvcHQ6cix0b29sc1R5cGU6bix0eXBlOmQsdXBkYXRlTm9kZU9wdDpnLG9wczp1LG9wOm8sdXNlQW5pbWF0aW9uOmMsbm9SZW5kZXI6cH09ZTtpZighdClyZXR1cm47Y29uc3QgbD10LnRvU3RyaW5nKCk7aWYoISgoeD10aGlzLndvcmtTaGFwZXMpIT1udWxsJiZ4LmhhcyhsKSkpe2xldCB2PXt0b29sc1R5cGU6bixhbmltYXRpb25Xb3JrRGF0YTpvfHxbXSxhbmltYXRpb25JbmRleDowLHR5cGU6ZCx1cGRhdGVOb2RlT3B0Omcsb3BzOnUsdXNlQW5pbWF0aW9uOnR5cGVvZiBjPCJ1Ij9jOnR5cGVvZihnPT1udWxsP3ZvaWQgMDpnLnVzZUFuaW1hdGlvbik8InUiP2c9PW51bGw/dm9pZCAwOmcudXNlQW5pbWF0aW9uOiEwLG9sZFJlY3Q6dGhpcy5nZXROb2RlUmVjdChsKSxub1JlbmRlcjpwfTtuJiZyJiYodj10aGlzLnNldE5vZGVLZXkodixuLHIpKSwoYj10aGlzLndvcmtTaGFwZXMpPT1udWxsfHxiLnNldChsLHYpfWNvbnN0IHk9KEU9dGhpcy53b3JrU2hhcGVzKT09bnVsbD92b2lkIDA6RS5nZXQobCk7ZCYmKHkudHlwZT1kKSx1JiYoeS5hbmltYXRpb25Xb3JrRGF0YT1lZSh1KSx5Lm9wcz11KSxnJiYoeS51cGRhdGVOb2RlT3B0PWcpLG8mJih5LmFuaW1hdGlvbldvcmtEYXRhPW8pLHAmJih5Lm5vUmVuZGVyPXApLHkubm9kZSYmeS5ub2RlLmdldFdvcmtJZCgpIT09bCYmeS5ub2RlLnNldFdvcmtJZChsKSx5LnRvb2xzVHlwZSE9PW4mJm4mJnImJnRoaXMuc2V0Tm9kZUtleSh5LG4scil9YWN0aXZlU2VsZWN0b3JTaGFwZShlKXt2YXIgYyxwLGw7Y29uc3R7d29ya0lkOnQsb3B0OnIsdG9vbHNUeXBlOm4sdHlwZTpkLHNlbGVjdElkczpnfT1lO2lmKCF0KXJldHVybjtjb25zdCB1PXQudG9TdHJpbmcoKTtpZighKChjPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzKSE9bnVsbCYmYy5oYXModSkpKXtsZXQgeT17dG9vbHNUeXBlOm4sc2VsZWN0SWRzOmcsdHlwZTpkLG9wdDpyfTtuJiZyJiYoeT10aGlzLnNldE5vZGVLZXkoeSxuLHIpKSwocD10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGx8fHAuc2V0KHUseSl9Y29uc3Qgbz0obD10aGlzLnNlbGVjdG9yV29ya1NoYXBlcyk9PW51bGw/dm9pZCAwOmwuZ2V0KHUpO2QmJihvLnR5cGU9ZCksby5ub2RlJiZvLm5vZGUuZ2V0V29ya0lkKCkhPT11JiZvLm5vZGUuc2V0V29ya0lkKHUpLG8uc2VsZWN0SWRzPWd8fFtdfXNldE5vZGVLZXkoZSx0LHIpe3N3aXRjaChlLnRvb2xzVHlwZT10LHQpe2Nhc2UgU3QuUGVuY2lsOmUubm9kZT1uZXcganQocix0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcik7YnJlYWs7Y2FzZSBTdC5MYXNlclBlbjplLm5vZGU9bmV3IGFyKHIsdGhpcy5kcmF3TGF5ZXIpO2JyZWFrO2Nhc2UgU3QuU2VsZWN0b3I6ZS5ub2RlPW5ldyB2dChyLHRoaXMuZnVsbExheWVyKTticmVhaztkZWZhdWx0OmUubm9kZT12b2lkIDA7YnJlYWt9cmV0dXJuIGV9Y29tcHV0TmV4dEFuaW1hdGlvbkluZGV4KGUsdCl7dmFyIG47Y29uc3Qgcj1NYXRoLmZsb29yKChlLmFuaW1hdGlvbldvcmtEYXRhfHxbXSkuc2xpY2UoZS5hbmltYXRpb25JbmRleCkubGVuZ3RoKjMyL3QvKCgobj1lLm5vZGUpPT1udWxsP3ZvaWQgMDpuLnN5bmNVbml0VGltZSl8fDFlMykpKnQ7cmV0dXJuIE1hdGgubWluKChlLmFuaW1hdGlvbkluZGV4fHwwKSsocnx8dCksKGUuYW5pbWF0aW9uV29ya0RhdGF8fFtdKS5sZW5ndGgpfWFuaW1hdGlvbkRyYXcoKXt2YXIgdSxvLGMscDt0aGlzLmFuaW1hdGlvbklkPXZvaWQgMDtsZXQgZSx0LHI9ITEsbj0hMSxkO3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKChsLHkpPT57dmFyIHgsYixFLHYsTSxpLGEscyxmLE8sQTtpZihsLnVzZUFuaW1hdGlvbil7Y29uc3QgUj1sLnRvb2xzVHlwZT09PVN0LlBlbmNpbD8zOjIsST10aGlzLmNvbXB1dE5leHRBbmltYXRpb25JbmRleChsLFIpLFA9TWF0aC5tYXgoMCwobC5hbmltYXRpb25JbmRleHx8MCktUiksTD0obC5hbmltYXRpb25Xb3JrRGF0YXx8W10pLnNsaWNlKFAsSSk7bGV0IEQ7KGwuYW5pbWF0aW9uSW5kZXh8fDApPEk/KEQ9KE09bC5ub2RlKT09bnVsbD92b2lkIDA6TS5jb25zdW1lU2VydmljZSh7b3A6TCxpc0Z1bGxXb3JrOiExLHJlcGxhY2VJZDoodj1sLm5vZGUuZ2V0V29ya0lkKCkpPT1udWxsP3ZvaWQgMDp2LnRvU3RyaW5nKCl9KSxsLnRvb2xzVHlwZT09PVN0Lkxhc2VyUGVuPyh0PVR0KHQsRCksbC50aW1lciYmKGNsZWFyVGltZW91dChsLnRpbWVyKSxsLnRpbWVyPXZvaWQgMCkpOmwubm9SZW5kZXJ8fChlPVR0KGUsRCksbC50b3RhbFJlY3Q9VHQobC50b3RhbFJlY3QsRCkpLHI9ITAsbC5hbmltYXRpb25JbmRleD1JKTpsLmlzRGVsP2wuaXNEZWwmJihsLnRvb2xzVHlwZT09PVN0Lkxhc2VyUGVuJiYoRD0oTz1sLm5vZGUpPT1udWxsP3ZvaWQgMDpPLmNvbnN1bWVTZXJ2aWNlKHtvcDpbXSxpc0Z1bGxXb3JrOiExfSksbC5ub1JlbmRlcnx8KHQ9VHQodCxEKSkpLHRoaXMudXBkYXRhTm9kZU1hcCh5LGwub3BzLChBPWwubm9kZSk9PW51bGw/dm9pZCAwOkEuZ2V0V29ya09wdGlvbnMoKSksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZSh5KSk6KGwudG9vbHNUeXBlPT09U3QuUGVuY2lsJiZsLm9wcyYmKEQ9KGE9bC5ub2RlKT09bnVsbD92b2lkIDA6YS5jb25zdW1lU2VydmljZSh7b3A6bC5hbmltYXRpb25Xb3JrRGF0YXx8W10saXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KGk9bC5ub2RlLmdldFdvcmtJZCgpKT09bnVsbD92b2lkIDA6aS50b1N0cmluZygpfSksbC5pc0RlbD0hMCxuPSEwLGwubm9SZW5kZXJ8fCh0PVR0KHQsRCksbC50b3RhbFJlY3Q9dCkpLGwudG9vbHNUeXBlPT09U3QuTGFzZXJQZW4mJihsLnRpbWVyfHwobC50aW1lcj1zZXRUaW1lb3V0KCgpPT57bC50aW1lcj12b2lkIDAsbC5pc0RlbD0hMCx0aGlzLnJ1bkFuaW1hdGlvbigpfSwoKHM9bC5ub2RlKT09bnVsbD92b2lkIDA6cy5nZXRXb3JrT3B0aW9ucygpKS5kdXJhdGlvbioxZTMrMTAwKSksbj0hMSxEPShmPWwubm9kZSk9PW51bGw/dm9pZCAwOmYuY29uc3VtZVNlcnZpY2Uoe29wOltdLGlzRnVsbFdvcms6ITF9KSx0PVR0KHQsRCkpLHI9ITApfWVsc2UgaWYobC50b29sc1R5cGU9PT1TdC5QZW5jaWwmJmwub3BzKXtsZXQgUj0oeD1sLm5vZGUpPT1udWxsP3ZvaWQgMDp4LmNvbnN1bWVTZXJ2aWNlKHtvcDpsLmFuaW1hdGlvbldvcmtEYXRhfHxbXSxpc0Z1bGxXb3JrOiEwLHJlcGxhY2VJZDp5fSk7Uj1UdChsLm9sZFJlY3QsUiksUj1UdChSLChiPWwubm9kZSk9PW51bGw/dm9pZCAwOmIudXBkYXRhT3B0U2VydmljZShsLnVwZGF0ZU5vZGVPcHQpKSxsLm5vUmVuZGVyfHwoZD1UdChkLFIpKSx0aGlzLnNlbGVjdG9yV29ya1NoYXBlcy5mb3JFYWNoKChJLFApPT57dmFyIEw7KEw9SS5zZWxlY3RJZHMpIT1udWxsJiZMLmluY2x1ZGVzKHkpJiYodGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKFApLHRoaXMubm9BbmltYXRpb25SZWN0PVR0KHRoaXMubm9BbmltYXRpb25SZWN0LGQpLGQ9dm9pZCAwLHRoaXMucnVuRWZmZWN0KCkpfSksdGhpcy51cGRhdGFOb2RlTWFwKHksbC5vcHMsKEU9bC5ub2RlKT09bnVsbD92b2lkIDA6RS5nZXRXb3JrT3B0aW9ucygpKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHkpfX0pLHImJnRoaXMucnVuQW5pbWF0aW9uKCk7Y29uc3QgZz17cmVuZGVyOltdfTtlJiYoKHU9Zy5yZW5kZXIpPT1udWxsfHx1LnB1c2goe3JlY3Q6ZSxkcmF3Q2FudmFzOm4/cHQuQmc6cHQuRmxvYXQsaXNDbGVhcjpuLGNsZWFyQ2FudmFzOnB0LkZsb2F0LGlzRnVsbFdvcms6bn0pKSx0JiYoKG89Zy5yZW5kZXIpPT1udWxsfHxvLnB1c2goe3JlY3Q6dCxkcmF3Q2FudmFzOm4/cHQuQmc6cHQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczpwdC5GbG9hdCxpc0Z1bGxXb3JrOm59KSksZCYmKChjPWcucmVuZGVyKT09bnVsbHx8Yy5wdXNoKHtyZWN0OmQsZHJhd0NhbnZhczpwdC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOnB0LkJnLGlzRnVsbFdvcms6ITB9KSksKHA9Zy5yZW5kZXIpIT1udWxsJiZwLmxlbmd0aCYmdGhpcy5fcG9zdChnKX1ydW5FZmZlY3QoKXt0aGlzLnJ1bkVmZmVjdElkfHwodGhpcy5ydW5FZmZlY3RJZD1zZXRUaW1lb3V0KHRoaXMuZWZmZWN0UnVuU2VsZWN0b3IuYmluZCh0aGlzKSwwKSl9cnVuQW5pbWF0aW9uKCl7dGhpcy5hbmltYXRpb25JZHx8KHRoaXMuYW5pbWF0aW9uSWQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRHJhdy5iaW5kKHRoaXMpKSl9Y29uc3VtZURyYXcoZSl7dGhpcy5hY3RpdmVXb3JrU2hhcGUoZSksdGhpcy5ydW5BbmltYXRpb24oKX1jb25zdW1lRnVsbChlKXt0aGlzLmFjdGl2ZVdvcmtTaGFwZShlKSx0aGlzLnJ1bkFuaW1hdGlvbigpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goKGUsdCk9PntlLnRvb2xzVHlwZT09PVN0Lkxhc2VyUGVuP3NldFRpbWVvdXQoKCk9Pnt0aGlzLndvcmtTaGFwZXMuZGVsZXRlKHQpfSwyZTMpOnRoaXMud29ya1NoYXBlcy5kZWxldGUodCl9KX1ydW5TZWxlY3RXb3JrKGUpe3RoaXMuYWN0aXZlU2VsZWN0b3JTaGFwZShlKTtjb25zdHt3b3JrSWQ6dH09ZSxyPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtyJiZ0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5hZGQociksdGhpcy5ydW5FZmZlY3QoKX1yZW1vdmVTZWxlY3RXb3JrKGUpe2NvbnN0e3dvcmtJZDp0fT1lLHI9dD09bnVsbD92b2lkIDA6dC50b1N0cmluZygpO3ImJih0aGlzLmFjdGl2ZVNlbGVjdG9yU2hhcGUoZSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuYWRkKHIpKSx0aGlzLnJ1bkVmZmVjdCgpfWVmZmVjdFJ1blNlbGVjdG9yKCl7dGhpcy5ydW5FZmZlY3RJZD12b2lkIDA7bGV0IGU9dGhpcy5ub0FuaW1hdGlvblJlY3Q7dGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuZm9yRWFjaCh0PT57dmFyIGQsZztjb25zdCByPXRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmdldCh0KSxuPXImJnIuc2VsZWN0SWRzJiYoKGQ9ci5ub2RlKT09bnVsbD92b2lkIDA6ZC5zZWxlY3RTZXJ2aWNlTm9kZSh0LHIsdGhpcy5jdXJOb2RlTWFwKSk7ZT1UdChlLG4pLChnPXI9PW51bGw/dm9pZCAwOnIuc2VsZWN0SWRzKSE9bnVsbCYmZy5sZW5ndGh8fHRoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmRlbGV0ZSh0KX0pLGUmJnRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6ZSxkcmF3Q2FudmFzOnB0LkJnLGlzQ2xlYXI6ITAsY2xlYXJDYW52YXM6cHQuQmcsaXNGdWxsV29yazohMH1dfSksdGhpcy53aWxsUnVuRWZmZWN0U2VsZWN0b3JJZHMuY2xlYXIoKSx0aGlzLm5vQW5pbWF0aW9uUmVjdD12b2lkIDB9cmVtb3ZlV29yayhlKXtjb25zdHt3b3JrSWQ6dH09ZSxyPXQ9PW51bGw/dm9pZCAwOnQudG9TdHJpbmcoKTtpZihyKXtjb25zdCBuPXRoaXMud29ya1NoYXBlcy5nZXQocik7aWYobil7dGhpcy53b3JrU2hhcGVzLmRlbGV0ZShyKSx0aGlzLnJlbW92ZU5vZGUocixlLG49PW51bGw/dm9pZCAwOm4udG90YWxSZWN0LCExKTtyZXR1cm59dGhpcy5yZW1vdmVOb2RlKHIsZSl9fXJlbW92ZU5vZGUoZSx0LHIsbj0hMCl7dmFyIG87Y29uc3QgZD10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKS5jb25jYXQoKG89dGhpcy5kcmF3TGF5ZXIpPT1udWxsP3ZvaWQgMDpvLmdldEVsZW1lbnRzQnlOYW1lKGUpKTtlLmluZGV4T2YodnQuc2VsZWN0b3JJZCk+LTEmJnRoaXMucmVtb3ZlU2VsZWN0V29yayh0KTtjb25zdCBnPVtdO2xldCB1PXI7ZC5mb3JFYWNoKGM9Pntjb25zdCBwPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dT1UdCh1LHt4Ok1hdGguZmxvb3IocC54LTEwKSx5Ok1hdGguZmxvb3IocC55LTEwKSx3Ok1hdGguZmxvb3IocC53aWR0aCsyMCksaDpNYXRoLmZsb29yKHAuaGVpZ2h0KzIwKX0pLGcucHVzaChjKX0pLGcubGVuZ3RoJiZnLmZvckVhY2goYz0+Yy5yZW1vdmUoKSksdSYmKHRoaXMuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6dSxpc0NsZWFyOiEwLGlzRnVsbFdvcms6bixjbGVhckNhbnZhczpuP3B0LkJnOnB0LkZsb2F0LGRyYXdDYW52YXM6bj9wdC5CZzpwdC5GbG9hdH1dfSksdGhpcy5jdXJOb2RlTWFwLmRlbGV0ZShlKSl9Z2V0Tm9kZVJlY3QoZSl7bGV0IHQ7cmV0dXJuIHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUpLmZvckVhY2gocj0+e2NvbnN0IG49ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxkPU1hdGguZmxvb3Iobi5sZWZ0LWp0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGc9TWF0aC5mbG9vcihuLnRvcC1qdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx1PU1hdGguY2VpbChuLndpZHRoK2p0LlBlbmNpbEJvcmRlclBhZGRpbmcqMiksbz1NYXRoLmNlaWwobi5oZWlnaHQranQuUGVuY2lsQm9yZGVyUGFkZGluZyoyKTt0PVR0KHQse3g6ZCx5Omcsdzp1LGg6b30pfSksdH1ydW5SZXZlcnNlU2VsZWN0V29yayhlKXtlLmZvckVhY2godD0+e3RoaXMuc2VsZWN0b3JXb3JrU2hhcGVzLmZvckVhY2goKHIsbik9Pnt2YXIgZDtpZigoZD1yLnNlbGVjdElkcykhPW51bGwmJmQubGVuZ3RoKXtjb25zdCBnPXIuc2VsZWN0SWRzLmluZGV4T2YodCk7Zz4tMSYmKHIuc2VsZWN0SWRzLnNwbGljZShnLDEpLHRoaXMud2lsbFJ1bkVmZmVjdFNlbGVjdG9ySWRzLmFkZChuKSl9fSl9KSx0aGlzLndpbGxSdW5FZmZlY3RTZWxlY3Rvcklkcy5zaXplJiZ0aGlzLnJ1bkVmZmVjdCgpfX1jbGFzcyBRdHtjb25zdHJ1Y3Rvcigpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsb2NhbFdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VydmljZVdvcmsiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KX1yZWdpc3RlckZvcldvcmtlcihlLHQpe3JldHVybiB0aGlzLmxvY2FsV29yaz1lLHRoaXMuc2VydmljZVdvcms9dCx0aGlzfX1jbGFzcyBUbiBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmJ0LlpJbmRleEFjdGl2ZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT15dC5VcGRhdGVOb2RlJiZyPT09QXQuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgdSxvLGMscCxsLHkseCxiO2NvbnN0e3dvcmtJZDp0LGlzQWN0aXZlWkluZGV4OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpufT1lO2lmKHQhPT12dC5zZWxlY3RvcklkKXJldHVybjtjb25zdCBkPSh1PXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6dS53b3JrU2hhcGVzLmdldCh2dC5zZWxlY3RvcklkKTtpZighZClyZXR1cm47Y29uc3QgZz1kLm9sZFJlY3Q7aWYociYmZyl7Y29uc3QgRT1bXSx2PVtdO2QuY3VyTm9kZU1hcC5mb3JFYWNoKChNLGkpPT57dmFyIGE7SWUoZyxNLnJlY3QpJiYoKGE9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxhLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShpKS5mb3JFYWNoKHM9PntpZihzKXtjb25zdCBmPXMuY2xvbmVOb2RlKCEwKTtFLnB1c2gocyksdi5wdXNoKGYpfX0pKX0pLEUubGVuZ3RoJiYodi5mb3JFYWNoKE09Pk0ucmVtb3ZlKCkpLChjPShvPXRoaXMubG9jYWxXb3JrKT09bnVsbD92b2lkIDA6by5kcmF3TGF5ZXIpPT1udWxsfHxjLmFwcGVuZCguLi5FKSl9ZWxzZXtjb25zdCBFPVtdLHY9W107KGw9KHA9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDpwLmRyYXdMYXllcik9PW51bGx8fGwuY2hpbGRyZW4uZmlsdGVyKE09Pnt2YXIgaTtyZXR1cm4gTS5uYW1lIT09dnQuc2VsZWN0b3JJZCYmISgoaT1kLnNlbGVjdElkcykhPW51bGwmJmkuaW5jbHVkZXMoTS5uYW1lKSl9KS5mb3JFYWNoKE09Pntjb25zdCBpPU0uY2xvbmVOb2RlKCEwKTtFLnB1c2goaSksdi5wdXNoKE0pfSksRS5sZW5ndGgmJih2LmZvckVhY2goTT0+TS5yZW1vdmUoKSksKHg9KHk9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDp5LmZ1bGxMYXllcik9PW51bGx8fHguYXBwZW5kKC4uLkUpKX1uJiYoKGI9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxiLl9wb3N0KHtyZW5kZXI6W3tyZWN0OmcsZHJhd0NhbnZhczpwdC5TZWxlY3RvcixjbGVhckNhbnZhczpwdC5TZWxlY3Rvcixpc0NsZWFyOiEwLGlzRnVsbFdvcms6ITF9XSxzcDpbe3R5cGU6eXQuU2VsZWN0LHNlbGVjdElkczpkLnNlbGVjdElkcyxvcHQ6ZC5nZXRXb3JrT3B0aW9ucygpLHBhZGRpbmc6dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxzZWxlY3RSZWN0OmQub2xkU2VsZWN0UmVjdCxub2RlQ29sb3I6ZC5ub2RlQ29sb3Isd2lsbFN5bmNTZXJ2aWNlOiExLGlzU3luYzohMH1dfSkpfX1jbGFzcyBQbiBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmJ0LkNvcHlOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm59PWU7aWYodD09PXl0LkZ1bGxXb3JrJiZyPT09QXQuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgcjtjb25zdHt3b3JrSWQ6dH09ZTt0JiYoKHI9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxyLmNvbnN1bWVGdWxsKGUpKX19Y2xhc3MgQW4gZXh0ZW5kcyBRdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpidC5TZXRDb2xvck5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6ZH09ZTtpZih0PT09eXQuVXBkYXRlTm9kZSYmcj09PUF0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxkJiZzZXRUaW1lb3V0KCgpPT57dmFyIGc7KGc9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxnLl9wb3N0KHtzcDpbe3R5cGU6eXQuTm9uZSx1bmRvVGlja2VySWQ6ZH1dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgYyxwO2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsd2lsbFJlZnJlc2g6ZyxzZWxlY3RTdG9yZTp1LHdpbGxTZXJpYWxpemVEYXRhOm99PWU7dD09PXZ0LnNlbGVjdG9ySWQmJnI/KGM9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxjLnVwZGF0ZVNlbGVjdG9yKHt1cGRhdGVTZWxlY3Rvck9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6ZCxzZWxlY3RTdG9yZTp1LHdpbGxTZXJpYWxpemVEYXRhOm99KTp0JiZyJiYoKHA9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxwLnVwZGF0ZU5vZGUoe3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaDpnLHdpbGxTeW5jU2VydmljZTpkfSkpfX1jbGFzcyBTbiBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmJ0LlpJbmRleE5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bn09ZTtpZih0PT09eXQuVXBkYXRlTm9kZSYmcj09PUF0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGMscDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpkLHdpbGxSZWZyZXNoOmcsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvfT1lO3Q9PT12dC5zZWxlY3RvcklkJiZyPyhjPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8Yy51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvfSk6dCYmciYmKChwPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8cC51cGRhdGVOb2RlKHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2g6Zyx3aWxsU3luY1NlcnZpY2U6ZH0pKX19Y2xhc3MgYm4gZXh0ZW5kcyBRdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVtaXRFdmVudFR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpidC5UcmFuc2xhdGVOb2RlfSl9Y29uc3VtZShlKXtjb25zdHttc2dUeXBlOnQsZGF0YVR5cGU6cixlbWl0RXZlbnRUeXBlOm4sdW5kb1RpY2tlcklkOmR9PWU7aWYodD09PXl0LlVwZGF0ZU5vZGUmJnI9PT1BdC5Mb2NhbCYmbj09PXRoaXMuZW1pdEV2ZW50VHlwZSlyZXR1cm4gdGhpcy5jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSksZCYmc2V0VGltZW91dCgoKT0+e3ZhciBnOyhnPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8Zy5fcG9zdCh7c3A6W3t0eXBlOnl0Lk5vbmUsdW5kb1RpY2tlcklkOmR9XX0pfSwwKSwhMH1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGMscDtjb25zdHt3b3JrSWQ6dCx1cGRhdGVOb2RlT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpkLHdpbGxSZWZyZXNoOmcsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvfT1lO3Q9PT12dC5zZWxlY3RvcklkJiZyPyhjPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8Yy51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvLGlzU3luYzohMH0pOnQmJnImJigocD10aGlzLmxvY2FsV29yayk9PW51bGx8fHAudXBkYXRlTm9kZSh7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoOmcsd2lsbFN5bmNTZXJ2aWNlOmR9KSl9fWNsYXNzIENuIGV4dGVuZHMgUXR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlbWl0RXZlbnRUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6YnQuRGVsZXRlTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpufT1lO2lmKHQ9PT15dC5SZW1vdmVOb2RlKXtpZihyPT09QXQuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLCEwO2lmKHI9PT1BdC5TZXJ2aWNlJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JTZXJ2aWNlV29ya2VyKGUpLCEwfX1jb25zdW1lRm9yTG9jYWxXb3JrZXIoZSl7dmFyIGcsdSxvLGMscDtpZighdGhpcy5sb2NhbFdvcmspcmV0dXJuO2NvbnN0e3dvcmtJZDp0LHdpbGxSZWZyZXNoOnJ9PWU7aWYoIXQpcmV0dXJuO2xldCBuO2NvbnN0IGQ9dGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5nZXQodCk7aWYoZCYmdD09PXZ0LnNlbGVjdG9ySWQpe2NvbnN0IGw9ZC5zZWxlY3RJZHM7bD09bnVsbHx8bC5mb3JFYWNoKHk9Pnt2YXIgeCxiLEU7KGI9KHg9dGhpcy5sb2NhbFdvcmspPT1udWxsP3ZvaWQgMDp4LmRyYXdMYXllcik9PW51bGx8fGIuZ2V0RWxlbWVudHNCeU5hbWUoeSkuZm9yRWFjaCh2PT57di5yZW1vdmUoKX0pLChFPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8RS5jdXJOb2RlTWFwLmRlbGV0ZSh5KX0pLG49ZC5vbGRSZWN0LChvPSh1PShnPXRoaXMubG9jYWxXb3JrLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOmcucGFyZW50KT09bnVsbD92b2lkIDA6dS5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvcklkKSk9PW51bGx8fG8ucmVtb3ZlKCksdGhpcy5sb2NhbFdvcmsud29ya1NoYXBlcy5kZWxldGUodnQuc2VsZWN0b3JJZCl9ZWxzZSBpZih0KXtjb25zdCBsPXQudG9TdHJpbmcoKTtsZXQgeT1YdChsLHRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcik7eSYmdGhpcy5sb2NhbFdvcmsuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKGwpLmZvckVhY2goYj0+Yi5yZW1vdmUoKSk7Y29uc3QgeD1YdChsLHRoaXMubG9jYWxXb3JrLmRyYXdMYXllcik7eCYmKHk9VHQoeSx4KSwoYz10aGlzLmxvY2FsV29yay5kcmF3TGF5ZXIpPT1udWxsfHxjLmdldEVsZW1lbnRzQnlOYW1lKGwpLmZvckVhY2goYj0+Yi5yZW1vdmUoKSkpLHkmJih5PWxuKHkpKSwocD10aGlzLmxvY2FsV29yayk9PW51bGx8fHAuY3VyTm9kZU1hcC5kZWxldGUobCl9biYmciYmdGhpcy5sb2NhbFdvcmsuX3Bvc3Qoe3JlbmRlcjpbe3JlY3Q6bixkcmF3Q2FudmFzOnB0LkJnLGNsZWFyQ2FudmFzOnB0LkJnLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMH1dfSl9Y29uc3VtZUZvclNlcnZpY2VXb3JrZXIoZSl7dGhpcy5zZXJ2aWNlV29yayYmdGhpcy5zZXJ2aWNlV29yay5yZW1vdmVTZWxlY3RXb3JrKGUpfX1jbGFzcyBSbiBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmJ0LlNjYWxlTm9kZX0pfWNvbnN1bWUoZSl7Y29uc3R7bXNnVHlwZTp0LGRhdGFUeXBlOnIsZW1pdEV2ZW50VHlwZTpuLHVuZG9UaWNrZXJJZDpkfT1lO2lmKHQ9PT15dC5VcGRhdGVOb2RlJiZyPT09QXQuTG9jYWwmJm49PT10aGlzLmVtaXRFdmVudFR5cGUpcmV0dXJuIHRoaXMuY29uc3VtZUZvckxvY2FsV29ya2VyKGUpLGQmJnNldFRpbWVvdXQoKCk9Pnt2YXIgZzsoZz10aGlzLmxvY2FsV29yayk9PW51bGx8fGcuX3Bvc3Qoe3NwOlt7dHlwZTp5dC5Ob25lLHVuZG9UaWNrZXJJZDpkfV19KX0sMCksITB9Y29uc3VtZUZvckxvY2FsV29ya2VyKGUpe3ZhciBjLHA7Y29uc3R7d29ya0lkOnQsdXBkYXRlTm9kZU9wdDpyLHdpbGxSZWZyZXNoU2VsZWN0b3I6bix3aWxsU3luY1NlcnZpY2U6ZCx3aWxsUmVmcmVzaDpnLHNlbGVjdFN0b3JlOnUsd2lsbFNlcmlhbGl6ZURhdGE6b309ZTt0PT09dnQuc2VsZWN0b3JJZCYmcj8oYz10aGlzLmxvY2FsV29yayk9PW51bGx8fGMudXBkYXRlU2VsZWN0b3Ioe3VwZGF0ZVNlbGVjdG9yT3B0OnIsd2lsbFJlZnJlc2hTZWxlY3RvcjpuLHdpbGxTeW5jU2VydmljZTpkLGVtaXRFdmVudFR5cGU6dGhpcy5lbWl0RXZlbnRUeXBlLHNlbGVjdFN0b3JlOnUsd2lsbFNlcmlhbGl6ZURhdGE6byxpc1N5bmM6ITB9KTp0JiZyJiYoKHA9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxwLnVwZGF0ZU5vZGUoe3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaDpnLHdpbGxTeW5jU2VydmljZTpkfSkpfX1jbGFzcyBMbiBleHRlbmRzIFF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZW1pdEV2ZW50VHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmJ0LlJvdGF0ZU5vZGV9KX1jb25zdW1lKGUpe2NvbnN0e21zZ1R5cGU6dCxkYXRhVHlwZTpyLGVtaXRFdmVudFR5cGU6bix1bmRvVGlja2VySWQ6ZH09ZTtpZih0PT09eXQuVXBkYXRlTm9kZSYmcj09PUF0LkxvY2FsJiZuPT09dGhpcy5lbWl0RXZlbnRUeXBlKXJldHVybiB0aGlzLmNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKSxkJiZzZXRUaW1lb3V0KCgpPT57dmFyIGc7KGc9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxnLl9wb3N0KHtzcDpbe3R5cGU6eXQuTm9uZSx1bmRvVGlja2VySWQ6ZH1dfSl9LDApLCEwfWNvbnN1bWVGb3JMb2NhbFdvcmtlcihlKXt2YXIgcCxsO2NvbnN0e3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsd2lsbFJlZnJlc2g6ZyxzZWxlY3RTdG9yZTp1LHdpbGxTZXJpYWxpemVEYXRhOm8sZW1pdEV2ZW50VHlwZTpjfT1lO3Q9PT12dC5zZWxlY3RvcklkJiZyPyhwPXRoaXMubG9jYWxXb3JrKT09bnVsbHx8cC51cGRhdGVTZWxlY3Rvcih7dXBkYXRlU2VsZWN0b3JPcHQ6cix3aWxsUmVmcmVzaFNlbGVjdG9yOm4sd2lsbFN5bmNTZXJ2aWNlOmQsc2VsZWN0U3RvcmU6dSx3aWxsU2VyaWFsaXplRGF0YTpvLGVtaXRFdmVudFR5cGU6Yyxpc1N5bmM6ITB9KTp0JiZyJiYoKGw9dGhpcy5sb2NhbFdvcmspPT1udWxsfHxsLnVwZGF0ZU5vZGUoe3dvcmtJZDp0LHVwZGF0ZU5vZGVPcHQ6cix3aWxsUmVmcmVzaDpnLHdpbGxTeW5jU2VydmljZTpkfSkpfX1jbGFzcyBEbntjb25zdHJ1Y3RvcihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYnVpbGRlcnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksdGhpcy5idWlsZGVycz1uZXcgTWFwKGUubWFwKHQ9Plt0LHRoaXMuYnVpbGQodCldKSl9YnVpbGQoZSl7c3dpdGNoKGUpe2Nhc2UgYnQuVHJhbnNsYXRlTm9kZTpyZXR1cm4gbmV3IGJuO2Nhc2UgYnQuWkluZGV4Tm9kZTpyZXR1cm4gbmV3IFNuO2Nhc2UgYnQuWkluZGV4QWN0aXZlOnJldHVybiBuZXcgVG47Y2FzZSBidC5Db3B5Tm9kZTpyZXR1cm4gbmV3IFBuO2Nhc2UgYnQuU2V0Q29sb3JOb2RlOnJldHVybiBuZXcgQW47Y2FzZSBidC5EZWxldGVOb2RlOnJldHVybiBuZXcgQ247Y2FzZSBidC5TY2FsZU5vZGU6cmV0dXJuIG5ldyBSbjtjYXNlIGJ0LlJvdGF0ZU5vZGU6cmV0dXJuIG5ldyBMbn19cmVnaXN0ZXJGb3JXb3JrZXIoZSx0KXtyZXR1cm4gdGhpcy5idWlsZGVycy5mb3JFYWNoKHI9PntyJiZyLnJlZ2lzdGVyRm9yV29ya2VyKGUsdCl9KSx0aGlzfWNvbnN1bWVGb3JXb3JrZXIoZSl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5idWlsZGVycy52YWx1ZXMoKSlpZih0IT1udWxsJiZ0LmNvbnN1bWUoZSkpcmV0dXJuITA7cmV0dXJuITF9fWZ1bmN0aW9uIEluKCl7dGhpcy5fX2RhdGFfXz1bXSx0aGlzLnNpemU9MH12YXIgTm49SW47ZnVuY3Rpb24gam4oaCxlKXtyZXR1cm4gaD09PWV8fGghPT1oJiZlIT09ZX12YXIgbHI9am4sQm49bHI7ZnVuY3Rpb24gV24oaCxlKXtmb3IodmFyIHQ9aC5sZW5ndGg7dC0tOylpZihCbihoW3RdWzBdLGUpKXJldHVybiB0O3JldHVybi0xfXZhciB4ZT1XbixGbj14ZSxVbj1BcnJheS5wcm90b3R5cGUsem49VW4uc3BsaWNlO2Z1bmN0aW9uICRuKGgpe3ZhciBlPXRoaXMuX19kYXRhX18sdD1GbihlLGgpO2lmKHQ8MClyZXR1cm4hMTt2YXIgcj1lLmxlbmd0aC0xO3JldHVybiB0PT1yP2UucG9wKCk6em4uY2FsbChlLHQsMSksLS10aGlzLnNpemUsITB9dmFyIHduPSRuLEduPXhlO2Z1bmN0aW9uIEtuKGgpe3ZhciBlPXRoaXMuX19kYXRhX18sdD1HbihlLGgpO3JldHVybiB0PDA/dm9pZCAwOmVbdF1bMV19dmFyIEhuPUtuLFZuPXhlO2Z1bmN0aW9uIFluKGgpe3JldHVybiBWbih0aGlzLl9fZGF0YV9fLGgpPi0xfXZhciBYbj1Zbixabj14ZTtmdW5jdGlvbiBKbihoLGUpe3ZhciB0PXRoaXMuX19kYXRhX18scj1abih0LGgpO3JldHVybiByPDA/KCsrdGhpcy5zaXplLHQucHVzaChbaCxlXSkpOnRbcl1bMV09ZSx0aGlzfXZhciBRbj1Kbixxbj1Obixrbj13bixfbj1Ibix0aT1YbixlaT1RbjtmdW5jdGlvbiBuZShoKXt2YXIgZT0tMSx0PWg9PW51bGw/MDpoLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9aFtlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1uZS5wcm90b3R5cGUuY2xlYXI9cW4sbmUucHJvdG90eXBlLmRlbGV0ZT1rbixuZS5wcm90b3R5cGUuZ2V0PV9uLG5lLnByb3RvdHlwZS5oYXM9dGksbmUucHJvdG90eXBlLnNldD1laTt2YXIgTWU9bmUscmk9TWU7ZnVuY3Rpb24gbmkoKXt0aGlzLl9fZGF0YV9fPW5ldyByaSx0aGlzLnNpemU9MH12YXIgaWk9bmk7ZnVuY3Rpb24gc2koaCl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PWUuZGVsZXRlKGgpO3JldHVybiB0aGlzLnNpemU9ZS5zaXplLHR9dmFyIG9pPXNpO2Z1bmN0aW9uIGFpKGgpe3JldHVybiB0aGlzLl9fZGF0YV9fLmdldChoKX12YXIgbGk9YWk7ZnVuY3Rpb24gZmkoaCl7cmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGgpfXZhciBjaT1maSx1aT10eXBlb2YgdmU9PSJvYmplY3QiJiZ2ZSYmdmUuT2JqZWN0PT09T2JqZWN0JiZ2ZSxmcj11aSxoaT1mcixkaT10eXBlb2Ygc2VsZj09Im9iamVjdCImJnNlbGYmJnNlbGYuT2JqZWN0PT09T2JqZWN0JiZzZWxmLGdpPWhpfHxkaXx8RnVuY3Rpb24oInJldHVybiB0aGlzIikoKSxadD1naSxtaT1adCx2aT1taS5TeW1ib2wsQmU9dmksY3I9QmUsdXI9T2JqZWN0LnByb3RvdHlwZSx5aT11ci5oYXNPd25Qcm9wZXJ0eSxwaT11ci50b1N0cmluZyxsZT1jcj9jci50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24geGkoaCl7dmFyIGU9eWkuY2FsbChoLGxlKSx0PWhbbGVdO3RyeXtoW2xlXT12b2lkIDA7dmFyIHI9ITB9Y2F0Y2h7fXZhciBuPXBpLmNhbGwoaCk7cmV0dXJuIHImJihlP2hbbGVdPXQ6ZGVsZXRlIGhbbGVdKSxufXZhciBNaT14aSxFaT1PYmplY3QucHJvdG90eXBlLE9pPUVpLnRvU3RyaW5nO2Z1bmN0aW9uIFRpKGgpe3JldHVybiBPaS5jYWxsKGgpfXZhciBQaT1UaSxocj1CZSxBaT1NaSxTaT1QaSxiaT0iW29iamVjdCBOdWxsXSIsQ2k9IltvYmplY3QgVW5kZWZpbmVkXSIsZHI9aHI/aHIudG9TdHJpbmdUYWc6dm9pZCAwO2Z1bmN0aW9uIFJpKGgpe3JldHVybiBoPT1udWxsP2g9PT12b2lkIDA/Q2k6Ymk6ZHImJmRyIGluIE9iamVjdChoKT9BaShoKTpTaShoKX12YXIgRWU9Umk7ZnVuY3Rpb24gTGkoaCl7dmFyIGU9dHlwZW9mIGg7cmV0dXJuIGghPW51bGwmJihlPT0ib2JqZWN0Inx8ZT09ImZ1bmN0aW9uIil9dmFyIGZlPUxpLERpPUVlLElpPWZlLE5pPSJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dIixqaT0iW29iamVjdCBGdW5jdGlvbl0iLEJpPSJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSIsV2k9IltvYmplY3QgUHJveHldIjtmdW5jdGlvbiBGaShoKXtpZighSWkoaCkpcmV0dXJuITE7dmFyIGU9RGkoaCk7cmV0dXJuIGU9PWppfHxlPT1CaXx8ZT09Tml8fGU9PVdpfXZhciBncj1GaSxVaT1adCx6aT1VaVsiX19jb3JlLWpzX3NoYXJlZF9fIl0sJGk9emksV2U9JGksbXI9ZnVuY3Rpb24oKXt2YXIgaD0vW14uXSskLy5leGVjKFdlJiZXZS5rZXlzJiZXZS5rZXlzLklFX1BST1RPfHwiIik7cmV0dXJuIGg/IlN5bWJvbChzcmMpXzEuIitoOiIifSgpO2Z1bmN0aW9uIHdpKGgpe3JldHVybiEhbXImJm1yIGluIGh9dmFyIEdpPXdpLEtpPUZ1bmN0aW9uLnByb3RvdHlwZSxIaT1LaS50b1N0cmluZztmdW5jdGlvbiBWaShoKXtpZihoIT1udWxsKXt0cnl7cmV0dXJuIEhpLmNhbGwoaCl9Y2F0Y2h7fXRyeXtyZXR1cm4gaCsiIn1jYXRjaHt9fXJldHVybiIifXZhciB2cj1WaSxZaT1ncixYaT1HaSxaaT1mZSxKaT12cixRaT0vW1xcXiQuKis/KClbXF17fXxdL2cscWk9L15cW29iamVjdCAuKz9Db25zdHJ1Y3RvclxdJC8sa2k9RnVuY3Rpb24ucHJvdG90eXBlLF9pPU9iamVjdC5wcm90b3R5cGUsdHM9a2kudG9TdHJpbmcsZXM9X2kuaGFzT3duUHJvcGVydHkscnM9UmVnRXhwKCJeIit0cy5jYWxsKGVzKS5yZXBsYWNlKFFpLCJcXCQmIikucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXCgpfCBmb3IgLis/KD89XFxcXSkvZywiJDEuKj8iKSsiJCIpO2Z1bmN0aW9uIG5zKGgpe2lmKCFaaShoKXx8WGkoaCkpcmV0dXJuITE7dmFyIGU9WWkoaCk/cnM6cWk7cmV0dXJuIGUudGVzdChKaShoKSl9dmFyIGlzPW5zO2Z1bmN0aW9uIHNzKGgsZSl7cmV0dXJuIGg9PW51bGw/dm9pZCAwOmhbZV19dmFyIG9zPXNzLGFzPWlzLGxzPW9zO2Z1bmN0aW9uIGZzKGgsZSl7dmFyIHQ9bHMoaCxlKTtyZXR1cm4gYXModCk/dDp2b2lkIDB9dmFyIHF0PWZzLGNzPXF0LHVzPVp0LGhzPWNzKHVzLCJNYXAiKSxGZT1ocyxkcz1xdCxncz1kcyhPYmplY3QsImNyZWF0ZSIpLE9lPWdzLHlyPU9lO2Z1bmN0aW9uIG1zKCl7dGhpcy5fX2RhdGFfXz15cj95cihudWxsKTp7fSx0aGlzLnNpemU9MH12YXIgdnM9bXM7ZnVuY3Rpb24geXMoaCl7dmFyIGU9dGhpcy5oYXMoaCkmJmRlbGV0ZSB0aGlzLl9fZGF0YV9fW2hdO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIHBzPXlzLHhzPU9lLE1zPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIixFcz1PYmplY3QucHJvdG90eXBlLE9zPUVzLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIFRzKGgpe3ZhciBlPXRoaXMuX19kYXRhX187aWYoeHMpe3ZhciB0PWVbaF07cmV0dXJuIHQ9PT1Ncz92b2lkIDA6dH1yZXR1cm4gT3MuY2FsbChlLGgpP2VbaF06dm9pZCAwfXZhciBQcz1UcyxBcz1PZSxTcz1PYmplY3QucHJvdG90eXBlLGJzPVNzLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIENzKGgpe3ZhciBlPXRoaXMuX19kYXRhX187cmV0dXJuIEFzP2VbaF0hPT12b2lkIDA6YnMuY2FsbChlLGgpfXZhciBScz1DcyxMcz1PZSxEcz0iX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyI7ZnVuY3Rpb24gSXMoaCxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO3JldHVybiB0aGlzLnNpemUrPXRoaXMuaGFzKGgpPzA6MSx0W2hdPUxzJiZlPT09dm9pZCAwP0RzOmUsdGhpc312YXIgTnM9SXMsanM9dnMsQnM9cHMsV3M9UHMsRnM9UnMsVXM9TnM7ZnVuY3Rpb24gaWUoaCl7dmFyIGU9LTEsdD1oPT1udWxsPzA6aC5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK2U8dDspe3ZhciByPWhbZV07dGhpcy5zZXQoclswXSxyWzFdKX19aWUucHJvdG90eXBlLmNsZWFyPWpzLGllLnByb3RvdHlwZS5kZWxldGU9QnMsaWUucHJvdG90eXBlLmdldD1XcyxpZS5wcm90b3R5cGUuaGFzPUZzLGllLnByb3RvdHlwZS5zZXQ9VXM7dmFyIHpzPWllLHByPXpzLCRzPU1lLHdzPUZlO2Z1bmN0aW9uIEdzKCl7dGhpcy5zaXplPTAsdGhpcy5fX2RhdGFfXz17aGFzaDpuZXcgcHIsbWFwOm5ldyh3c3x8JHMpLHN0cmluZzpuZXcgcHJ9fXZhciBLcz1HcztmdW5jdGlvbiBIcyhoKXt2YXIgZT10eXBlb2YgaDtyZXR1cm4gZT09InN0cmluZyJ8fGU9PSJudW1iZXIifHxlPT0ic3ltYm9sInx8ZT09ImJvb2xlYW4iP2ghPT0iX19wcm90b19fIjpoPT09bnVsbH12YXIgVnM9SHMsWXM9VnM7ZnVuY3Rpb24gWHMoaCxlKXt2YXIgdD1oLl9fZGF0YV9fO3JldHVybiBZcyhlKT90W3R5cGVvZiBlPT0ic3RyaW5nIj8ic3RyaW5nIjoiaGFzaCJdOnQubWFwfXZhciBUZT1Ycyxacz1UZTtmdW5jdGlvbiBKcyhoKXt2YXIgZT1acyh0aGlzLGgpLmRlbGV0ZShoKTtyZXR1cm4gdGhpcy5zaXplLT1lPzE6MCxlfXZhciBRcz1Kcyxxcz1UZTtmdW5jdGlvbiBrcyhoKXtyZXR1cm4gcXModGhpcyxoKS5nZXQoaCl9dmFyIF9zPWtzLHRvPVRlO2Z1bmN0aW9uIGVvKGgpe3JldHVybiB0byh0aGlzLGgpLmhhcyhoKX12YXIgcm89ZW8sbm89VGU7ZnVuY3Rpb24gaW8oaCxlKXt2YXIgdD1ubyh0aGlzLGgpLHI9dC5zaXplO3JldHVybiB0LnNldChoLGUpLHRoaXMuc2l6ZSs9dC5zaXplPT1yPzA6MSx0aGlzfXZhciBzbz1pbyxvbz1Lcyxhbz1Rcyxsbz1fcyxmbz1ybyxjbz1zbztmdW5jdGlvbiBzZShoKXt2YXIgZT0tMSx0PWg9PW51bGw/MDpoLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9aFtlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1zZS5wcm90b3R5cGUuY2xlYXI9b28sc2UucHJvdG90eXBlLmRlbGV0ZT1hbyxzZS5wcm90b3R5cGUuZ2V0PWxvLHNlLnByb3RvdHlwZS5oYXM9Zm8sc2UucHJvdG90eXBlLnNldD1jbzt2YXIgdW89c2UsaG89TWUsZ289RmUsbW89dW8sdm89MjAwO2Z1bmN0aW9uIHlvKGgsZSl7dmFyIHQ9dGhpcy5fX2RhdGFfXztpZih0IGluc3RhbmNlb2YgaG8pe3ZhciByPXQuX19kYXRhX187aWYoIWdvfHxyLmxlbmd0aDx2by0xKXJldHVybiByLnB1c2goW2gsZV0pLHRoaXMuc2l6ZT0rK3Quc2l6ZSx0aGlzO3Q9dGhpcy5fX2RhdGFfXz1uZXcgbW8ocil9cmV0dXJuIHQuc2V0KGgsZSksdGhpcy5zaXplPXQuc2l6ZSx0aGlzfXZhciBwbz15byx4bz1NZSxNbz1paSxFbz1vaSxPbz1saSxUbz1jaSxQbz1wbztmdW5jdGlvbiBvZShoKXt2YXIgZT10aGlzLl9fZGF0YV9fPW5ldyB4byhoKTt0aGlzLnNpemU9ZS5zaXplfW9lLnByb3RvdHlwZS5jbGVhcj1NbyxvZS5wcm90b3R5cGUuZGVsZXRlPUVvLG9lLnByb3RvdHlwZS5nZXQ9T28sb2UucHJvdG90eXBlLmhhcz1UbyxvZS5wcm90b3R5cGUuc2V0PVBvO3ZhciBBbz1vZTtmdW5jdGlvbiBTbyhoLGUpe2Zvcih2YXIgdD0tMSxyPWg9PW51bGw/MDpoLmxlbmd0aDsrK3Q8ciYmZShoW3RdLHQsaCkhPT0hMTspO3JldHVybiBofXZhciBibz1TbyxDbz1xdCxSbz1mdW5jdGlvbigpe3RyeXt2YXIgaD1DbyhPYmplY3QsImRlZmluZVByb3BlcnR5Iik7cmV0dXJuIGgoe30sIiIse30pLGh9Y2F0Y2h7fX0oKSxMbz1Sbyx4cj1MbztmdW5jdGlvbiBEbyhoLGUsdCl7ZT09Il9fcHJvdG9fXyImJnhyP3hyKGgsZSx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6dCx3cml0YWJsZTohMH0pOmhbZV09dH12YXIgTXI9RG8sSW89TXIsTm89bHIsam89T2JqZWN0LnByb3RvdHlwZSxCbz1qby5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBXbyhoLGUsdCl7dmFyIHI9aFtlXTsoIShCby5jYWxsKGgsZSkmJk5vKHIsdCkpfHx0PT09dm9pZCAwJiYhKGUgaW4gaCkpJiZJbyhoLGUsdCl9dmFyIEVyPVdvLEZvPUVyLFVvPU1yO2Z1bmN0aW9uIHpvKGgsZSx0LHIpe3ZhciBuPSF0O3R8fCh0PXt9KTtmb3IodmFyIGQ9LTEsZz1lLmxlbmd0aDsrK2Q8Zzspe3ZhciB1PWVbZF0sbz1yP3IodFt1XSxoW3VdLHUsdCxoKTp2b2lkIDA7bz09PXZvaWQgMCYmKG89aFt1XSksbj9Vbyh0LHUsbyk6Rm8odCx1LG8pfXJldHVybiB0fXZhciBQZT16bztmdW5jdGlvbiAkbyhoLGUpe2Zvcih2YXIgdD0tMSxyPUFycmF5KGgpOysrdDxoOylyW3RdPWUodCk7cmV0dXJuIHJ9dmFyIHdvPSRvO2Z1bmN0aW9uIEdvKGgpe3JldHVybiBoIT1udWxsJiZ0eXBlb2YgaD09Im9iamVjdCJ9dmFyIGNlPUdvLEtvPUVlLEhvPWNlLFZvPSJbb2JqZWN0IEFyZ3VtZW50c10iO2Z1bmN0aW9uIFlvKGgpe3JldHVybiBIbyhoKSYmS28oaCk9PVZvfXZhciBYbz1ZbyxPcj1Ybyxabz1jZSxUcj1PYmplY3QucHJvdG90eXBlLEpvPVRyLmhhc093blByb3BlcnR5LFFvPVRyLnByb3BlcnR5SXNFbnVtZXJhYmxlLHFvPU9yKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSk/T3I6ZnVuY3Rpb24oaCl7cmV0dXJuIFpvKGgpJiZKby5jYWxsKGgsImNhbGxlZSIpJiYhUW8uY2FsbChoLCJjYWxsZWUiKX0sa289cW8sX289QXJyYXkuaXNBcnJheSxVZT1fbyxBZT17ZXhwb3J0czp7fX07ZnVuY3Rpb24gdGEoKXtyZXR1cm4hMX12YXIgZWE9dGE7QWUuZXhwb3J0cyxmdW5jdGlvbihoLGUpe3ZhciB0PVp0LHI9ZWEsbj1lJiYhZS5ub2RlVHlwZSYmZSxkPW4mJiEwJiZoJiYhaC5ub2RlVHlwZSYmaCxnPWQmJmQuZXhwb3J0cz09PW4sdT1nP3QuQnVmZmVyOnZvaWQgMCxvPXU/dS5pc0J1ZmZlcjp2b2lkIDAsYz1vfHxyO2guZXhwb3J0cz1jfShBZSxBZS5leHBvcnRzKTt2YXIgUHI9QWUuZXhwb3J0cyxyYT05MDA3MTk5MjU0NzQwOTkxLG5hPS9eKD86MHxbMS05XVxkKikkLztmdW5jdGlvbiBpYShoLGUpe3ZhciB0PXR5cGVvZiBoO3JldHVybiBlPWU/P3JhLCEhZSYmKHQ9PSJudW1iZXIifHx0IT0ic3ltYm9sIiYmbmEudGVzdChoKSkmJmg+LTEmJmglMT09MCYmaDxlfXZhciBzYT1pYSxvYT05MDA3MTk5MjU0NzQwOTkxO2Z1bmN0aW9uIGFhKGgpe3JldHVybiB0eXBlb2YgaD09Im51bWJlciImJmg+LTEmJmglMT09MCYmaDw9b2F9dmFyIEFyPWFhLGxhPUVlLGZhPUFyLGNhPWNlLHVhPSJbb2JqZWN0IEFyZ3VtZW50c10iLGhhPSJbb2JqZWN0IEFycmF5XSIsZGE9IltvYmplY3QgQm9vbGVhbl0iLGdhPSJbb2JqZWN0IERhdGVdIixtYT0iW29iamVjdCBFcnJvcl0iLHZhPSJbb2JqZWN0IEZ1bmN0aW9uXSIseWE9IltvYmplY3QgTWFwXSIscGE9IltvYmplY3QgTnVtYmVyXSIseGE9IltvYmplY3QgT2JqZWN0XSIsTWE9IltvYmplY3QgUmVnRXhwXSIsRWE9IltvYmplY3QgU2V0XSIsT2E9IltvYmplY3QgU3RyaW5nXSIsVGE9IltvYmplY3QgV2Vha01hcF0iLFBhPSJbb2JqZWN0IEFycmF5QnVmZmVyXSIsQWE9IltvYmplY3QgRGF0YVZpZXddIixTYT0iW29iamVjdCBGbG9hdDMyQXJyYXldIixiYT0iW29iamVjdCBGbG9hdDY0QXJyYXldIixDYT0iW29iamVjdCBJbnQ4QXJyYXldIixSYT0iW29iamVjdCBJbnQxNkFycmF5XSIsTGE9IltvYmplY3QgSW50MzJBcnJheV0iLERhPSJbb2JqZWN0IFVpbnQ4QXJyYXldIixJYT0iW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0iLE5hPSJbb2JqZWN0IFVpbnQxNkFycmF5XSIsamE9IltvYmplY3QgVWludDMyQXJyYXldIixOdD17fTtOdFtTYV09TnRbYmFdPU50W0NhXT1OdFtSYV09TnRbTGFdPU50W0RhXT1OdFtJYV09TnRbTmFdPU50W2phXT0hMCxOdFt1YV09TnRbaGFdPU50W1BhXT1OdFtkYV09TnRbQWFdPU50W2dhXT1OdFttYV09TnRbdmFdPU50W3lhXT1OdFtwYV09TnRbeGFdPU50W01hXT1OdFtFYV09TnRbT2FdPU50W1RhXT0hMTtmdW5jdGlvbiBCYShoKXtyZXR1cm4gY2EoaCkmJmZhKGgubGVuZ3RoKSYmISFOdFtsYShoKV19dmFyIFdhPUJhO2Z1bmN0aW9uIEZhKGgpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gaChlKX19dmFyIHplPUZhLFNlPXtleHBvcnRzOnt9fTtTZS5leHBvcnRzLGZ1bmN0aW9uKGgsZSl7dmFyIHQ9ZnIscj1lJiYhZS5ub2RlVHlwZSYmZSxuPXImJiEwJiZoJiYhaC5ub2RlVHlwZSYmaCxkPW4mJm4uZXhwb3J0cz09PXIsZz1kJiZ0LnByb2Nlc3MsdT1mdW5jdGlvbigpe3RyeXt2YXIgbz1uJiZuLnJlcXVpcmUmJm4ucmVxdWlyZSgidXRpbCIpLnR5cGVzO3JldHVybiBvfHxnJiZnLmJpbmRpbmcmJmcuYmluZGluZygidXRpbCIpfWNhdGNoe319KCk7aC5leHBvcnRzPXV9KFNlLFNlLmV4cG9ydHMpO3ZhciAkZT1TZS5leHBvcnRzLFVhPVdhLHphPXplLFNyPSRlLGJyPVNyJiZTci5pc1R5cGVkQXJyYXksJGE9YnI/emEoYnIpOlVhLHdhPSRhLEdhPXdvLEthPWtvLEhhPVVlLFZhPVByLFlhPXNhLFhhPXdhLFphPU9iamVjdC5wcm90b3R5cGUsSmE9WmEuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gUWEoaCxlKXt2YXIgdD1IYShoKSxyPSF0JiZLYShoKSxuPSF0JiYhciYmVmEoaCksZD0hdCYmIXImJiFuJiZYYShoKSxnPXR8fHJ8fG58fGQsdT1nP0dhKGgubGVuZ3RoLFN0cmluZyk6W10sbz11Lmxlbmd0aDtmb3IodmFyIGMgaW4gaCkoZXx8SmEuY2FsbChoLGMpKSYmIShnJiYoYz09Imxlbmd0aCJ8fG4mJihjPT0ib2Zmc2V0Inx8Yz09InBhcmVudCIpfHxkJiYoYz09ImJ1ZmZlciJ8fGM9PSJieXRlTGVuZ3RoInx8Yz09ImJ5dGVPZmZzZXQiKXx8WWEoYyxvKSkpJiZ1LnB1c2goYyk7cmV0dXJuIHV9dmFyIENyPVFhLHFhPU9iamVjdC5wcm90b3R5cGU7ZnVuY3Rpb24ga2EoaCl7dmFyIGU9aCYmaC5jb25zdHJ1Y3Rvcix0PXR5cGVvZiBlPT0iZnVuY3Rpb24iJiZlLnByb3RvdHlwZXx8cWE7cmV0dXJuIGg9PT10fXZhciB3ZT1rYTtmdW5jdGlvbiBfYShoLGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gaChlKHQpKX19dmFyIFJyPV9hLHRsPVJyLGVsPXRsKE9iamVjdC5rZXlzLE9iamVjdCkscmw9ZWwsbmw9d2UsaWw9cmwsc2w9T2JqZWN0LnByb3RvdHlwZSxvbD1zbC5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBhbChoKXtpZighbmwoaCkpcmV0dXJuIGlsKGgpO3ZhciBlPVtdO2Zvcih2YXIgdCBpbiBPYmplY3QoaCkpb2wuY2FsbChoLHQpJiZ0IT0iY29uc3RydWN0b3IiJiZlLnB1c2godCk7cmV0dXJuIGV9dmFyIGxsPWFsLGZsPWdyLGNsPUFyO2Z1bmN0aW9uIHVsKGgpe3JldHVybiBoIT1udWxsJiZjbChoLmxlbmd0aCkmJiFmbChoKX12YXIgTHI9dWwsaGw9Q3IsZGw9bGwsZ2w9THI7ZnVuY3Rpb24gbWwoaCl7cmV0dXJuIGdsKGgpP2hsKGgpOmRsKGgpfXZhciBHZT1tbCx2bD1QZSx5bD1HZTtmdW5jdGlvbiBwbChoLGUpe3JldHVybiBoJiZ2bChlLHlsKGUpLGgpfXZhciB4bD1wbDtmdW5jdGlvbiBNbChoKXt2YXIgZT1bXTtpZihoIT1udWxsKWZvcih2YXIgdCBpbiBPYmplY3QoaCkpZS5wdXNoKHQpO3JldHVybiBlfXZhciBFbD1NbCxPbD1mZSxUbD13ZSxQbD1FbCxBbD1PYmplY3QucHJvdG90eXBlLFNsPUFsLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIGJsKGgpe2lmKCFPbChoKSlyZXR1cm4gUGwoaCk7dmFyIGU9VGwoaCksdD1bXTtmb3IodmFyIHIgaW4gaClyPT0iY29uc3RydWN0b3IiJiYoZXx8IVNsLmNhbGwoaCxyKSl8fHQucHVzaChyKTtyZXR1cm4gdH12YXIgQ2w9YmwsUmw9Q3IsTGw9Q2wsRGw9THI7ZnVuY3Rpb24gSWwoaCl7cmV0dXJuIERsKGgpP1JsKGgsITApOkxsKGgpfXZhciBLZT1JbCxObD1QZSxqbD1LZTtmdW5jdGlvbiBCbChoLGUpe3JldHVybiBoJiZObChlLGpsKGUpLGgpfXZhciBXbD1CbCxiZT17ZXhwb3J0czp7fX07YmUuZXhwb3J0cyxmdW5jdGlvbihoLGUpe3ZhciB0PVp0LHI9ZSYmIWUubm9kZVR5cGUmJmUsbj1yJiYhMCYmaCYmIWgubm9kZVR5cGUmJmgsZD1uJiZuLmV4cG9ydHM9PT1yLGc9ZD90LkJ1ZmZlcjp2b2lkIDAsdT1nP2cuYWxsb2NVbnNhZmU6dm9pZCAwO2Z1bmN0aW9uIG8oYyxwKXtpZihwKXJldHVybiBjLnNsaWNlKCk7dmFyIGw9Yy5sZW5ndGgseT11P3UobCk6bmV3IGMuY29uc3RydWN0b3IobCk7cmV0dXJuIGMuY29weSh5KSx5fWguZXhwb3J0cz1vfShiZSxiZS5leHBvcnRzKTt2YXIgRmw9YmUuZXhwb3J0cztmdW5jdGlvbiBVbChoLGUpe3ZhciB0PS0xLHI9aC5sZW5ndGg7Zm9yKGV8fChlPUFycmF5KHIpKTsrK3Q8cjspZVt0XT1oW3RdO3JldHVybiBlfXZhciB6bD1VbDtmdW5jdGlvbiAkbChoLGUpe2Zvcih2YXIgdD0tMSxyPWg9PW51bGw/MDpoLmxlbmd0aCxuPTAsZD1bXTsrK3Q8cjspe3ZhciBnPWhbdF07ZShnLHQsaCkmJihkW24rK109Zyl9cmV0dXJuIGR9dmFyIHdsPSRsO2Z1bmN0aW9uIEdsKCl7cmV0dXJuW119dmFyIERyPUdsLEtsPXdsLEhsPURyLFZsPU9iamVjdC5wcm90b3R5cGUsWWw9VmwucHJvcGVydHlJc0VudW1lcmFibGUsSXI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxYbD1Jcj9mdW5jdGlvbihoKXtyZXR1cm4gaD09bnVsbD9bXTooaD1PYmplY3QoaCksS2woSXIoaCksZnVuY3Rpb24oZSl7cmV0dXJuIFlsLmNhbGwoaCxlKX0pKX06SGwsSGU9WGwsWmw9UGUsSmw9SGU7ZnVuY3Rpb24gUWwoaCxlKXtyZXR1cm4gWmwoaCxKbChoKSxlKX12YXIgcWw9UWw7ZnVuY3Rpb24ga2woaCxlKXtmb3IodmFyIHQ9LTEscj1lLmxlbmd0aCxuPWgubGVuZ3RoOysrdDxyOyloW24rdF09ZVt0XTtyZXR1cm4gaH12YXIgTnI9a2wsX2w9UnIsdGY9X2woT2JqZWN0LmdldFByb3RvdHlwZU9mLE9iamVjdCksanI9dGYsZWY9TnIscmY9anIsbmY9SGUsc2Y9RHIsb2Y9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxhZj1vZj9mdW5jdGlvbihoKXtmb3IodmFyIGU9W107aDspZWYoZSxuZihoKSksaD1yZihoKTtyZXR1cm4gZX06c2YsQnI9YWYsbGY9UGUsZmY9QnI7ZnVuY3Rpb24gY2YoaCxlKXtyZXR1cm4gbGYoaCxmZihoKSxlKX12YXIgdWY9Y2YsaGY9TnIsZGY9VWU7ZnVuY3Rpb24gZ2YoaCxlLHQpe3ZhciByPWUoaCk7cmV0dXJuIGRmKGgpP3I6aGYocix0KGgpKX12YXIgV3I9Z2YsbWY9V3IsdmY9SGUseWY9R2U7ZnVuY3Rpb24gcGYoaCl7cmV0dXJuIG1mKGgseWYsdmYpfXZhciB4Zj1wZixNZj1XcixFZj1CcixPZj1LZTtmdW5jdGlvbiBUZihoKXtyZXR1cm4gTWYoaCxPZixFZil9dmFyIFBmPVRmLEFmPXF0LFNmPVp0LGJmPUFmKFNmLCJEYXRhVmlldyIpLENmPWJmLFJmPXF0LExmPVp0LERmPVJmKExmLCJQcm9taXNlIiksSWY9RGYsTmY9cXQsamY9WnQsQmY9TmYoamYsIlNldCIpLFdmPUJmLEZmPXF0LFVmPVp0LHpmPUZmKFVmLCJXZWFrTWFwIiksJGY9emYsVmU9Q2YsWWU9RmUsWGU9SWYsWmU9V2YsSmU9JGYsRnI9RWUsYWU9dnIsVXI9IltvYmplY3QgTWFwXSIsd2Y9IltvYmplY3QgT2JqZWN0XSIsenI9IltvYmplY3QgUHJvbWlzZV0iLCRyPSJbb2JqZWN0IFNldF0iLHdyPSJbb2JqZWN0IFdlYWtNYXBdIixHcj0iW29iamVjdCBEYXRhVmlld10iLEdmPWFlKFZlKSxLZj1hZShZZSksSGY9YWUoWGUpLFZmPWFlKFplKSxZZj1hZShKZSksa3Q9RnI7KFZlJiZrdChuZXcgVmUobmV3IEFycmF5QnVmZmVyKDEpKSkhPUdyfHxZZSYma3QobmV3IFllKSE9VXJ8fFhlJiZrdChYZS5yZXNvbHZlKCkpIT16cnx8WmUmJmt0KG5ldyBaZSkhPSRyfHxKZSYma3QobmV3IEplKSE9d3IpJiYoa3Q9ZnVuY3Rpb24oaCl7dmFyIGU9RnIoaCksdD1lPT13Zj9oLmNvbnN0cnVjdG9yOnZvaWQgMCxyPXQ/YWUodCk6IiI7aWYocilzd2l0Y2gocil7Y2FzZSBHZjpyZXR1cm4gR3I7Y2FzZSBLZjpyZXR1cm4gVXI7Y2FzZSBIZjpyZXR1cm4genI7Y2FzZSBWZjpyZXR1cm4gJHI7Y2FzZSBZZjpyZXR1cm4gd3J9cmV0dXJuIGV9KTt2YXIgUWU9a3QsWGY9T2JqZWN0LnByb3RvdHlwZSxaZj1YZi5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBKZihoKXt2YXIgZT1oLmxlbmd0aCx0PW5ldyBoLmNvbnN0cnVjdG9yKGUpO3JldHVybiBlJiZ0eXBlb2YgaFswXT09InN0cmluZyImJlpmLmNhbGwoaCwiaW5kZXgiKSYmKHQuaW5kZXg9aC5pbmRleCx0LmlucHV0PWguaW5wdXQpLHR9dmFyIFFmPUpmLHFmPVp0LGtmPXFmLlVpbnQ4QXJyYXksX2Y9a2YsS3I9X2Y7ZnVuY3Rpb24gdGMoaCl7dmFyIGU9bmV3IGguY29uc3RydWN0b3IoaC5ieXRlTGVuZ3RoKTtyZXR1cm4gbmV3IEtyKGUpLnNldChuZXcgS3IoaCkpLGV9dmFyIHFlPXRjLGVjPXFlO2Z1bmN0aW9uIHJjKGgsZSl7dmFyIHQ9ZT9lYyhoLmJ1ZmZlcik6aC5idWZmZXI7cmV0dXJuIG5ldyBoLmNvbnN0cnVjdG9yKHQsaC5ieXRlT2Zmc2V0LGguYnl0ZUxlbmd0aCl9dmFyIG5jPXJjLGljPS9cdyokLztmdW5jdGlvbiBzYyhoKXt2YXIgZT1uZXcgaC5jb25zdHJ1Y3RvcihoLnNvdXJjZSxpYy5leGVjKGgpKTtyZXR1cm4gZS5sYXN0SW5kZXg9aC5sYXN0SW5kZXgsZX12YXIgb2M9c2MsSHI9QmUsVnI9SHI/SHIucHJvdG90eXBlOnZvaWQgMCxZcj1Wcj9Wci52YWx1ZU9mOnZvaWQgMDtmdW5jdGlvbiBhYyhoKXtyZXR1cm4gWXI/T2JqZWN0KFlyLmNhbGwoaCkpOnt9fXZhciBsYz1hYyxmYz1xZTtmdW5jdGlvbiBjYyhoLGUpe3ZhciB0PWU/ZmMoaC5idWZmZXIpOmguYnVmZmVyO3JldHVybiBuZXcgaC5jb25zdHJ1Y3Rvcih0LGguYnl0ZU9mZnNldCxoLmxlbmd0aCl9dmFyIHVjPWNjLGhjPXFlLGRjPW5jLGdjPW9jLG1jPWxjLHZjPXVjLHljPSJbb2JqZWN0IEJvb2xlYW5dIixwYz0iW29iamVjdCBEYXRlXSIseGM9IltvYmplY3QgTWFwXSIsTWM9IltvYmplY3QgTnVtYmVyXSIsRWM9IltvYmplY3QgUmVnRXhwXSIsT2M9IltvYmplY3QgU2V0XSIsVGM9IltvYmplY3QgU3RyaW5nXSIsUGM9IltvYmplY3QgU3ltYm9sXSIsQWM9IltvYmplY3QgQXJyYXlCdWZmZXJdIixTYz0iW29iamVjdCBEYXRhVmlld10iLGJjPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLENjPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLFJjPSJbb2JqZWN0IEludDhBcnJheV0iLExjPSJbb2JqZWN0IEludDE2QXJyYXldIixEYz0iW29iamVjdCBJbnQzMkFycmF5XSIsSWM9IltvYmplY3QgVWludDhBcnJheV0iLE5jPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsamM9IltvYmplY3QgVWludDE2QXJyYXldIixCYz0iW29iamVjdCBVaW50MzJBcnJheV0iO2Z1bmN0aW9uIFdjKGgsZSx0KXt2YXIgcj1oLmNvbnN0cnVjdG9yO3N3aXRjaChlKXtjYXNlIEFjOnJldHVybiBoYyhoKTtjYXNlIHljOmNhc2UgcGM6cmV0dXJuIG5ldyByKCtoKTtjYXNlIFNjOnJldHVybiBkYyhoLHQpO2Nhc2UgYmM6Y2FzZSBDYzpjYXNlIFJjOmNhc2UgTGM6Y2FzZSBEYzpjYXNlIEljOmNhc2UgTmM6Y2FzZSBqYzpjYXNlIEJjOnJldHVybiB2YyhoLHQpO2Nhc2UgeGM6cmV0dXJuIG5ldyByO2Nhc2UgTWM6Y2FzZSBUYzpyZXR1cm4gbmV3IHIoaCk7Y2FzZSBFYzpyZXR1cm4gZ2MoaCk7Y2FzZSBPYzpyZXR1cm4gbmV3IHI7Y2FzZSBQYzpyZXR1cm4gbWMoaCl9fXZhciBGYz1XYyxVYz1mZSxYcj1PYmplY3QuY3JlYXRlLHpjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaCgpe31yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIVVjKGUpKXJldHVybnt9O2lmKFhyKXJldHVybiBYcihlKTtoLnByb3RvdHlwZT1lO3ZhciB0PW5ldyBoO3JldHVybiBoLnByb3RvdHlwZT12b2lkIDAsdH19KCksJGM9emMsd2M9JGMsR2M9anIsS2M9d2U7ZnVuY3Rpb24gSGMoaCl7cmV0dXJuIHR5cGVvZiBoLmNvbnN0cnVjdG9yPT0iZnVuY3Rpb24iJiYhS2MoaCk/d2MoR2MoaCkpOnt9fXZhciBWYz1IYyxZYz1RZSxYYz1jZSxaYz0iW29iamVjdCBNYXBdIjtmdW5jdGlvbiBKYyhoKXtyZXR1cm4gWGMoaCkmJlljKGgpPT1aY312YXIgUWM9SmMscWM9UWMsa2M9emUsWnI9JGUsSnI9WnImJlpyLmlzTWFwLF9jPUpyP2tjKEpyKTpxYyx0dT1fYyxldT1RZSxydT1jZSxudT0iW29iamVjdCBTZXRdIjtmdW5jdGlvbiBpdShoKXtyZXR1cm4gcnUoaCkmJmV1KGgpPT1udX12YXIgc3U9aXUsb3U9c3UsYXU9emUsUXI9JGUscXI9UXImJlFyLmlzU2V0LGx1PXFyP2F1KHFyKTpvdSxmdT1sdSxjdT1Bbyx1dT1ibyxodT1FcixkdT14bCxndT1XbCxtdT1GbCx2dT16bCx5dT1xbCxwdT11Zix4dT14ZixNdT1QZixFdT1RZSxPdT1RZixUdT1GYyxQdT1WYyxBdT1VZSxTdT1QcixidT10dSxDdT1mZSxSdT1mdSxMdT1HZSxEdT1LZSxJdT0xLE51PTIsanU9NCxrcj0iW29iamVjdCBBcmd1bWVudHNdIixCdT0iW29iamVjdCBBcnJheV0iLFd1PSJbb2JqZWN0IEJvb2xlYW5dIixGdT0iW29iamVjdCBEYXRlXSIsVXU9IltvYmplY3QgRXJyb3JdIixfcj0iW29iamVjdCBGdW5jdGlvbl0iLHp1PSJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSIsJHU9IltvYmplY3QgTWFwXSIsd3U9IltvYmplY3QgTnVtYmVyXSIsdG49IltvYmplY3QgT2JqZWN0XSIsR3U9IltvYmplY3QgUmVnRXhwXSIsS3U9IltvYmplY3QgU2V0XSIsSHU9IltvYmplY3QgU3RyaW5nXSIsVnU9IltvYmplY3QgU3ltYm9sXSIsWXU9IltvYmplY3QgV2Vha01hcF0iLFh1PSJbb2JqZWN0IEFycmF5QnVmZmVyXSIsWnU9IltvYmplY3QgRGF0YVZpZXddIixKdT0iW29iamVjdCBGbG9hdDMyQXJyYXldIixRdT0iW29iamVjdCBGbG9hdDY0QXJyYXldIixxdT0iW29iamVjdCBJbnQ4QXJyYXldIixrdT0iW29iamVjdCBJbnQxNkFycmF5XSIsX3U9IltvYmplY3QgSW50MzJBcnJheV0iLHRoPSJbb2JqZWN0IFVpbnQ4QXJyYXldIixlaD0iW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0iLHJoPSJbb2JqZWN0IFVpbnQxNkFycmF5XSIsbmg9IltvYmplY3QgVWludDMyQXJyYXldIixJdD17fTtJdFtrcl09SXRbQnVdPUl0W1h1XT1JdFtadV09SXRbV3VdPUl0W0Z1XT1JdFtKdV09SXRbUXVdPUl0W3F1XT1JdFtrdV09SXRbX3VdPUl0WyR1XT1JdFt3dV09SXRbdG5dPUl0W0d1XT1JdFtLdV09SXRbSHVdPUl0W1Z1XT1JdFt0aF09SXRbZWhdPUl0W3JoXT1JdFtuaF09ITAsSXRbVXVdPUl0W19yXT1JdFtZdV09ITE7ZnVuY3Rpb24gQ2UoaCxlLHQscixuLGQpe3ZhciBnLHU9ZSZJdSxvPWUmTnUsYz1lJmp1O2lmKHQmJihnPW4/dChoLHIsbixkKTp0KGgpKSxnIT09dm9pZCAwKXJldHVybiBnO2lmKCFDdShoKSlyZXR1cm4gaDt2YXIgcD1BdShoKTtpZihwKXtpZihnPU91KGgpLCF1KXJldHVybiB2dShoLGcpfWVsc2V7dmFyIGw9RXUoaCkseT1sPT1fcnx8bD09enU7aWYoU3UoaCkpcmV0dXJuIG11KGgsdSk7aWYobD09dG58fGw9PWtyfHx5JiYhbil7aWYoZz1vfHx5P3t9OlB1KGgpLCF1KXJldHVybiBvP3B1KGgsZ3UoZyxoKSk6eXUoaCxkdShnLGgpKX1lbHNle2lmKCFJdFtsXSlyZXR1cm4gbj9oOnt9O2c9VHUoaCxsLHUpfX1kfHwoZD1uZXcgY3UpO3ZhciB4PWQuZ2V0KGgpO2lmKHgpcmV0dXJuIHg7ZC5zZXQoaCxnKSxSdShoKT9oLmZvckVhY2goZnVuY3Rpb24odil7Zy5hZGQoQ2UodixlLHQsdixoLGQpKX0pOmJ1KGgpJiZoLmZvckVhY2goZnVuY3Rpb24odixNKXtnLnNldChNLENlKHYsZSx0LE0saCxkKSl9KTt2YXIgYj1jP28/TXU6eHU6bz9EdTpMdSxFPXA/dm9pZCAwOmIoaCk7cmV0dXJuIHV1KEV8fGgsZnVuY3Rpb24odixNKXtFJiYoTT12LHY9aFtNXSksaHUoZyxNLENlKHYsZSx0LE0saCxkKSl9KSxnfXZhciBpaD1DZSxzaD1paCxvaD0xLGFoPTQ7ZnVuY3Rpb24gbGgoaCl7cmV0dXJuIHNoKGgsb2h8YWgpfXZhciBmaD1saCxjaD1zcihmaCk7Y29uc3QgUmU9Y2xhc3MgUmUgZXh0ZW5kcyBwbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCk7VnQodGhpcywiY2FtZXJhT3B0Iik7VnQodGhpcywiZHByIik7VnQodGhpcywic2NlbmUiKTtWdCh0aGlzLCJkcmF3TGF5ZXIiKTtWdCh0aGlzLCJmdWxsTGF5ZXIiKTtWdCh0aGlzLCJzbmFwc2hvdEZ1bGxMYXllciIpO1Z0KHRoaXMsImxvY2FsV29yayIpO1Z0KHRoaXMsInNlcnZpY2VXb3JrIik7VnQodGhpcywibWV0aG9kQnVpbGRlciIpO3RoaXMucmVnaXN0ZXIoKX1pbml0KHQscixuKXt0aGlzLmRwcj10LHRoaXMuc2NlbmU9dGhpcy5jcmVhdGVTY2VuZShyKSx0aGlzLmRyYXdMYXllcj10aGlzLmNyZWF0ZUxheWVyKHRoaXMuc2NlbmUsey4uLm4sd2lkdGg6ci53aWR0aCxoZWlnaHQ6ci5oZWlnaHR9KSx0aGlzLmZ1bGxMYXllcj10aGlzLmNyZWF0ZUxheWVyKHRoaXMuc2NlbmUsey4uLm4sd2lkdGg6ci53aWR0aCxoZWlnaHQ6ci5oZWlnaHQsYnVmZmVyU2l6ZTo1ZTN9KSx0aGlzLmxvY2FsV29yaz1uZXcgRW4odGhpcy5jdXJOb2RlTWFwLHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyLHRoaXMucG9zdC5iaW5kKHRoaXMpKSx0aGlzLnNlcnZpY2VXb3JrPW5ldyBPbih0aGlzLmN1ck5vZGVNYXAsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIsdGhpcy5wb3N0LmJpbmQodGhpcykpLHRoaXMubWV0aG9kQnVpbGRlcj1uZXcgRG4oW2J0LkNvcHlOb2RlLGJ0LlNldENvbG9yTm9kZSxidC5EZWxldGVOb2RlLGJ0LlJvdGF0ZU5vZGUsYnQuU2NhbGVOb2RlLGJ0LlRyYW5zbGF0ZU5vZGUsYnQuWkluZGV4QWN0aXZlLGJ0LlpJbmRleE5vZGVdKS5yZWdpc3RlckZvcldvcmtlcih0aGlzLmxvY2FsV29yayx0aGlzLnNlcnZpY2VXb3JrKX1nZXRPZmZzY3JlZW4odCl7cmV0dXJuKHQ/dGhpcy5mdWxsTGF5ZXIucGFyZW50OnRoaXMuZHJhd0xheWVyLnBhcmVudCkuY2FudmFzfXJlZ2lzdGVyKCl7dGhpcy5vbih0PT57dmFyIHI7Zm9yKGNvbnN0IG4gb2YgdCl7Y29uc3R7d29ya1N0YXRlOmQsZGF0YVR5cGU6Zyxtc2dUeXBlOnUsd29ya0lkOm8sdG9vbHNUeXBlOmMsb3B0OnB9PW47aWYoISgocj10aGlzLm1ldGhvZEJ1aWxkZXIpIT1udWxsJiZyLmNvbnN1bWVGb3JXb3JrZXIobikpKXN3aXRjaCh1KXtjYXNlIHl0LlVwZGF0ZVRvb2xzOmMmJnAmJnRoaXMuc2V0VG9vbHNPcHQoe3Rvb2xzVHlwZTpjLHRvb2xzT3B0OnB9KTticmVhaztjYXNlIHl0LkNyZWF0ZVdvcms6byYmcCYmKCF0aGlzLmxvY2FsV29yay5nZXRUbXBXb3JrU2hhcGVOb2RlKCkmJmMmJnRoaXMuc2V0VG9vbHNPcHQoe3Rvb2xzVHlwZTpjLHRvb2xzT3B0OnB9KSx0aGlzLnNldFdvcmtPcHQoe3dvcmtJZDpvLHRvb2xzT3B0OnB9KSk7YnJlYWs7Y2FzZSB5dC5TZWxlY3Q6Zz09PUF0LlNlcnZpY2UmJihvPT09dnQuc2VsZWN0b3JJZD90aGlzLmxvY2FsV29yay51cGRhdGVGdWxsU2VsZWN0V29yayhuKTp0aGlzLnNlcnZpY2VXb3JrLnJ1blNlbGVjdFdvcmsobikpO2JyZWFrO2Nhc2UgeXQuVXBkYXRlTm9kZTp0aGlzLnVwZGF0ZU5vZGUobik7YnJlYWs7Y2FzZSB5dC5GdWxsV29yazp0aGlzLmNvbnN1bWVGdWxsKGcsbik7YnJlYWs7Y2FzZSB5dC5EcmF3V29yazpkPT09R3QuRG9uZSYmZz09PUF0LkxvY2FsP3RoaXMuY29uc3VtZURyYXdBbGwoZyxuKTp0aGlzLmNvbnN1bWVEcmF3KGcsbik7YnJlYWs7Y2FzZSB5dC5SZW1vdmVOb2RlOnRoaXMucmVtb3ZlTm9kZShuKTticmVha319fSl9dXBkYXRlTm9kZSh0KXtjb25zdHtkYXRhVHlwZTpyfT10LG49dGhpcy5sb2NhbFdvcmsuY29sbG9jdEVmZmVjdFNlbGVjdFdvcmsodCk7biYmcj09PUF0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZUZ1bGwobil9c2V0VG9vbHNPcHQodCl7dGhpcy5sb2NhbFdvcmsuc2V0VG9vbHNPcHQodCl9c2V0V29ya09wdCh0KXtjb25zdHt3b3JrSWQ6cix0b29sc09wdDpufT10O3ImJm4mJnRoaXMubG9jYWxXb3JrLnNldFdvcmtPcHRpb25zKHIsbil9Y2xlYXJBbGwoKXtjb25zdCB0PVtdO3RoaXMubG9jYWxXb3JrLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCksdGhpcy5zZXJ2aWNlV29yay5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLHRoaXMuZnVsbExheWVyLnBhcmVudC5jaGlsZHJlbi5mb3JFYWNoKHI9PntyLm5hbWUhPT0idmlld3BvcnQiJiZ0LnB1c2gocil9KSx0aGlzLmRyYXdMYXllci5wYXJlbnQuY2hpbGRyZW4uZm9yRWFjaChyPT57ci5uYW1lIT09InZpZXdwb3J0IiYmdC5wdXNoKHIpfSksdC5mb3JFYWNoKHI9PntyLnJlbW92ZSgpfSksdGhpcy5mdWxsTGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLmRyYXdMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMubG9jYWxXb3JrLnJ1bkVmZmVjdFdvcmsoKX1zZXRDYW1lcmFPcHQodCl7dGhpcy5jYW1lcmFPcHQ9dDtjb25zdHtzY2FsZTpyLGNlbnRlclg6bixjZW50ZXJZOmQsd2lkdGg6ZyxoZWlnaHQ6dX09dDsoZyE9PXRoaXMuc2NlbmUud2lkdGh8fHUhPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOmcsaGVpZ2h0OnV9KSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInNjYWxlIixbcixyXSksdGhpcy5mdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLFstbiwtZF0pLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFtyLHJdKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsWy1uLC1kXSksdGhpcy5sb2NhbFdvcmsucnVuRWZmZWN0V29yaygoKT0+e2lmKHRoaXMuc2VydmljZVdvcmsuc2VsZWN0b3JXb3JrU2hhcGVzLnNpemUpZm9yKGNvbnN0W28sY11vZiB0aGlzLnNlcnZpY2VXb3JrLnNlbGVjdG9yV29ya1NoYXBlcy5lbnRyaWVzKCkpdGhpcy5zZXJ2aWNlV29yay5ydW5TZWxlY3RXb3JrKHt3b3JrSWQ6byxzZWxlY3RJZHM6Yy5zZWxlY3RJZHMsbXNnVHlwZTp5dC5TZWxlY3QsZGF0YVR5cGU6QXQuU2VydmljZX0pfSl9Z2V0UmVjdEltYWdlQml0bWFwKHQscil7Y29uc3Qgbj10LngqdGhpcy5kcHIsZD10LnkqdGhpcy5kcHIsZz10LncqdGhpcy5kcHIsdT10LmgqdGhpcy5kcHI7cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKHRoaXMuZ2V0T2Zmc2NyZWVuKHIpLG4sZCxnLHUpfXNhZmFyaUZpeFJlY3QodCl7aWYoISh0LncrdC54PD0wfHx0LmgrdC55PD0wKSYmKHQudyt0Lng+dGhpcy5zY2VuZS53aWR0aCYmKHQudz10aGlzLnNjZW5lLndpZHRoLU1hdGgubWF4KHQueCwwKSksdC5oK3QueT50aGlzLnNjZW5lLndpZHRoJiYodC5oPXRoaXMuc2NlbmUuaGVpZ2h0LU1hdGgubWF4KHQueSwwKSksISh0Lnc8PTB8fHQuaDw9MCkpKXJldHVybiB0Lng8MCYmKHQudz10LncrdC54LHQueD0wKSx0Lnk8MCYmKHQuaD10LmgrdC55LHQueT0wKSx0fWFzeW5jIHBvc3QodCl7dmFyIGcsdTtjb25zdCByPXQucmVuZGVyLG49W107aWYociE9bnVsbCYmci5sZW5ndGgpe2Zvcihjb25zdCBvIG9mIHIpaWYoby5kcmF3Q2FudmFzJiYoby5pc0Z1bGxXb3JrP3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyKS5wYXJlbnQucmVuZGVyKCksby5pc0NsZWFyQWxsJiYoby5yZWN0PXt4OjAseTowLHc6dGhpcy5zY2VuZS53aWR0aCxoOnRoaXMuc2NlbmUuaGVpZ2h0fSxvLmlzQ2xlYXI9ITAsZGVsZXRlIG8uaXNDbGVhckFsbCksby5yZWN0KXtjb25zdCBjPW8ucmVjdDtpZihvLnJlY3Q9dGhpcy5zYWZhcmlGaXhSZWN0KGNoKG8ucmVjdCkpLCFvLnJlY3QpY29udGludWU7aWYoby5kcmF3Q2FudmFzPT09cHQuU2VsZWN0b3ImJm8uY2xlYXJDYW52YXM9PT1wdC5TZWxlY3Rvcil7Y29uc3QgcD0oZz10LnNwKT09bnVsbD92b2lkIDA6Zy5maW5kKGw9PmwudHlwZT09PXl0LlNlbGVjdCk7cCYmKHAucmVjdD1vLnJlY3QpLG8ub2Zmc2V0PXt4Om8ucmVjdC54LWMueCx5Om8ucmVjdC55LWMueX19aWYoby5kcmF3Q2FudmFzKXtjb25zdCBwPWF3YWl0IHRoaXMuZ2V0UmVjdEltYWdlQml0bWFwKG8ucmVjdCwhIW8uaXNGdWxsV29yayk7by5pbWFnZUJpdG1hcD1wfW4ucHVzaChvKX10LnJlbmRlcj1ufWNvbnN0IGQ9KHU9dC5zcCk9PW51bGw/dm9pZCAwOnUuZmlsdGVyKG89Pm8udHlwZSE9PXl0Lk5vbmV8fE9iamVjdC5rZXlzKG8pLmZpbHRlcihjPT5jPT09InR5cGUiKS5sZW5ndGgpO2lmKGQhPW51bGwmJmQubGVuZ3RoJiYodC5zcD1kKSwodC5kcmF3Q291bnR8fGQhPW51bGwmJmQubGVuZ3RofHxuIT1udWxsJiZuLmxlbmd0aCkmJihSZS5fc2VsZi5wb3N0TWVzc2FnZSh0KSxuLmxlbmd0aCkpZm9yKGNvbnN0IG8gb2YgbilvLmltYWdlQml0bWFwJiZvLmltYWdlQml0bWFwLmNsb3NlKCl9b24odCl7b25tZXNzYWdlPXI9PntpZihyLmRhdGEpe2NvbnN0IG49ci5kYXRhLmdldCgiSW5pdCIpO2lmKG4pe2NvbnN0e2RwcjpvLG9mZnNjcmVlbkNhbnZhc09wdDpjLGxheWVyT3B0OnB9PW47YyYmcCYmbyYmdGhpcy5pbml0KG8sYyxwKX10KHIuZGF0YS52YWx1ZXMoKSk7Y29uc3QgZD1yLmRhdGEuaGFzKCJDbGVhckFsbCIpLGc9ci5kYXRhLmdldCgiVXBkYXRlQ2FtZXJhIik7bGV0IHU9ISFnO2lmKGcpe2NvbnN0e2NhbWVyYU9wdDpvfT1nO28mJnRoaXMuc2V0Q2FtZXJhT3B0KG8pLHRoaXMuZnVsbExheWVyLmNoaWxkcmVuLmxlbmd0aD09PTAmJih1PSExKX0hZCYmdSYmdGhpcy5wb3N0KHtyZW5kZXI6W3tyZWN0Ont4OjAseTowLHc6dGhpcy5zY2VuZS53aWR0aCxoOnRoaXMuc2NlbmUuaGVpZ2h0fSxkcmF3Q2FudmFzOnB0LkJnLGNsZWFyQ2FudmFzOnB0LkJnLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMH1dfSksZCYmdGhpcy5jbGVhckFsbCgpfX19Y29uc3VtZURyYXcodCxyKXt0PT09QXQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3KHIsdGhpcy5zZXJ2aWNlV29yayksdD09PUF0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZURyYXcocil9Y29uc3VtZURyYXdBbGwodCxyKXt0PT09QXQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3QWxsKHIsdGhpcy5zZXJ2aWNlV29yayl9Y29uc3VtZUZ1bGwodCxyKXt0PT09QXQuTG9jYWwmJnRoaXMubG9jYWxXb3JrLmNvbnN1bWVGdWxsKHIpO2NvbnN0IG49dGhpcy5sb2NhbFdvcmsuY29sbG9jdEVmZmVjdFNlbGVjdFdvcmsocik7biYmdD09PUF0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZUZ1bGwobil9cmVtb3ZlTm9kZSh0KXtjb25zdHtkYXRhVHlwZTpyLHdvcmtJZDpufT10O249PT12dC5zZWxlY3RvcklkJiZ0aGlzLmxvY2FsV29yay5ibHVyU2VsZWN0b3IoKSxyPT09QXQuU2VydmljZSYmdGhpcy5zZXJ2aWNlV29yay5yZW1vdmVXb3JrKHQpLHI9PT1BdC5Mb2NhbCYmdGhpcy5sb2NhbFdvcmsucmVtb3ZlV29yayh0KX19O1Z0KFJlLCJfc2VsZiIsc2VsZik7bGV0IGtlPVJlO25ldyBrZX0pKCk7Cg==", yi = typeof window < "u" && window.Blob && new Blob([atob(Ws)], { type: "text/javascript;charset=utf-8" });
function et(Z) {
  let d;
  try {
    if (d = yi && (window.URL || window.webkitURL).createObjectURL(yi), !d)
      throw "";
    const l = new Worker(d, {
      name: Z == null ? void 0 : Z.name
    });
    return l.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(d);
    }), l;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + Ws,
      {
        name: Z == null ? void 0 : Z.name
      }
    );
  } finally {
    d && (window.URL || window.webkitURL).revokeObjectURL(d);
  }
}
const Gs = "dmFyIFpjPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgcWM9KER0LEd0LEN0KT0+R3QgaW4gRHQ/WmMoRHQsR3Qse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkN0fSk6RHRbR3RdPUN0O3ZhciBWdD0oRHQsR3QsQ3QpPT4ocWMoRHQsdHlwZW9mIEd0IT0ic3ltYm9sIj9HdCsiIjpHdCxDdCksQ3QpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgRHQ7KGZ1bmN0aW9uKGgpe2hbaC5QZW5jaWw9MV09IlBlbmNpbCIsaFtoLkVyYXNlcj0yXT0iRXJhc2VyIixoW2guU2VsZWN0b3I9M109IlNlbGVjdG9yIixoW2guQ2xpY2tlcj00XT0iQ2xpY2tlciIsaFtoLkFycm93PTVdPSJBcnJvdyIsaFtoLkhhbmQ9Nl09IkhhbmQiLGhbaC5MYXNlclBlbj03XT0iTGFzZXJQZW4ifSkoRHR8fChEdD17fSkpO3ZhciBHdDsoZnVuY3Rpb24oaCl7aFtoLlBhdGg9MF09IlBhdGgiLGhbaC5SZWN0PTFdPSJSZWN0In0pKEd0fHwoR3Q9e30pKTt2YXIgQ3Q7KGZ1bmN0aW9uKGgpe2hbaC5Mb2NhbD0xXT0iTG9jYWwiLGhbaC5TZXJ2aWNlPTJdPSJTZXJ2aWNlIn0pKEN0fHwoQ3Q9e30pKTt2YXIgUXQ7KGZ1bmN0aW9uKGgpe2hbaC5QZW5kaW5nPTBdPSJQZW5kaW5nIixoW2guU3RhcnQ9MV09IlN0YXJ0IixoW2guRG9pbmc9Ml09IkRvaW5nIixoW2guRG9uZT0zXT0iRG9uZSIsaFtoLkZyZWV6ZT00XT0iRnJlZXplIixoW2guVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KShRdHx8KFF0PXt9KSk7dmFyIEV0OyhmdW5jdGlvbihoKXtoW2guSW5pdD0wXT0iSW5pdCIsaFtoLlVwZGF0ZUNhbWVyYT0xXT0iVXBkYXRlQ2FtZXJhIixoW2guVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixoW2guQ3JlYXRlV29yaz0zXT0iQ3JlYXRlV29yayIsaFtoLkRyYXdXb3JrPTRdPSJEcmF3V29yayIsaFtoLkZ1bGxXb3JrPTVdPSJGdWxsV29yayIsaFtoLlVwZGF0ZU5vZGU9Nl09IlVwZGF0ZU5vZGUiLGhbaC5SZW1vdmVOb2RlPTddPSJSZW1vdmVOb2RlIixoW2guQ2xlYXI9OF09IkNsZWFyIixoW2guU2VsZWN0PTldPSJTZWxlY3QiLGhbaC5EZXN0cm95PTEwXT0iRGVzdHJveSIsaFtoLk5vbmU9MTFdPSJOb25lIixoW2guU25hcHNob3Q9MTJdPSJTbmFwc2hvdCJ9KShFdHx8KEV0PXt9KSk7dmFyIEplOyhmdW5jdGlvbihoKXtoW2guUGF0aD0wXT0iUGF0aCIsaFtoLlJlY3Q9MV09IlJlY3QiLGhbaC5UZXh0dXJlPTJdPSJUZXh0dXJlIn0pKEplfHwoSmU9e30pKTt2YXIgUWU7KGZ1bmN0aW9uKGgpe2guV2ViZ2wyPSJ3ZWJnbDIiLGguV2ViZ2w9IndlYmdsIixoLkNhbnZhczJkPSIyZCJ9KShRZXx8KFFlPXt9KSk7dmFyIFl0OyhmdW5jdGlvbihoKXtoW2guRmxvYXQ9MV09IkZsb2F0IixoW2guQmc9Ml09IkJnIixoW2guU2VsZWN0b3I9M109IlNlbGVjdG9yIixoW2guTm9uZT00XT0iTm9uZSJ9KShZdHx8KFl0PXt9KSk7dmFyIFplOyhmdW5jdGlvbihoKXtoLkxUPSJ0b3BMZWZ0IixoLkxDPSJsZWZ0IixoLkxCPSJib3R0b21MZWZ0IixoLlRDPSJ0b3AiLGguUlQ9InRvcFJpZ2h0IixoLlJDPSJyaWdodCIsaC5SQj0iYm90dG9tUmlnaHQiLGguQkM9ImJvdHRvbSJ9KShaZXx8KFplPXt9KSk7Y2xhc3MgY2V7Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1VuaXRUaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MWUzfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya0lkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5mdWxsTGF5ZXI9ZSx0aGlzLmRyYXdMYXllcj10fXNldFdvcmtJZChlKXt0aGlzLndvcmtJZD1lfWdldFdvcmtJZCgpe3JldHVybiB0aGlzLndvcmtJZH1nZXRXb3JrT3B0aW9ucygpe3JldHVybiB0aGlzLndvcmtPcHRpb25zfXNldFdvcmtPcHRpb25zKGUpe3RoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNVbml0VGltZT1lLnN5bmNVbml0VGltZXx8dGhpcy5zeW5jVW5pdFRpbWV9fXZhciBQdD1mdW5jdGlvbihoKXt2YXIgZT17fTtmdW5jdGlvbiB0KHIpe2lmKGVbcl0pcmV0dXJuIGVbcl0uZXhwb3J0czt2YXIgcz1lW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gaFtyXS5jYWxsKHMuZXhwb3J0cyxzLHMuZXhwb3J0cyx0KSxzLmw9ITAscy5leHBvcnRzfXJldHVybiB0Lm09aCx0LmM9ZSx0LmQ9ZnVuY3Rpb24ocixzLG0pe3QubyhyLHMpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkocixzLHtlbnVtZXJhYmxlOiEwLGdldDptfSl9LHQucj1mdW5jdGlvbihyKXt0eXBlb2YgU3ltYm9sPCJ1IiYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkocixTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOiJNb2R1bGUifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfSx0LnQ9ZnVuY3Rpb24ocixzKXtpZihzJjEmJihyPXQocikpLHMmOHx8cyY0JiZ0eXBlb2Ygcj09Im9iamVjdCImJnImJnIuX19lc01vZHVsZSlyZXR1cm4gcjt2YXIgbT1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHQucihtKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobSwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsdmFsdWU6cn0pLHMmMiYmdHlwZW9mIHIhPSJzdHJpbmciKWZvcih2YXIgeSBpbiByKXQuZChtLHksKGZ1bmN0aW9uKGMpe3JldHVybiByW2NdfSkuYmluZChudWxsLHkpKTtyZXR1cm4gbX0sdC5uPWZ1bmN0aW9uKHIpe3ZhciBzPXImJnIuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9O3JldHVybiB0LmQocywiYSIscyksc30sdC5vPWZ1bmN0aW9uKHIscyl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLHMpfSx0LnA9Ii9qcy8iLHQodC5zPTApfShbZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwidmVyc2lvbiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJoZWxwZXJzIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsImNyZWF0ZUVsZW1lbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiaXNTcHJpdGVOb2RlIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInJlZ2lzdGVyTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pO3ZhciByPXQoMTIpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIHIuRU5WfSk7dmFyIHM9dCg2OCk7dC5kKGUsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV9KSx0LmQoZSwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLGZ1bmN0aW9uKCl7cmV0dXJuIHMuY2FuY2VsQW5pbWF0aW9uRnJhbWV9KTt2YXIgbT10KDcwKTt0LmQoZSwiTm9kZSIsZnVuY3Rpb24oKXtyZXR1cm4gbS5kZWZhdWx0fSk7dmFyIHk9dCgyMTcpO3QuZChlLCJDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4geS5kZWZhdWx0fSk7dmFyIGM9dCgyMTkpO3QuZChlLCJCbG9jayIsZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWZhdWx0fSk7dmFyIGw9dCgyMjQpO3QuZChlLCJTcHJpdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGwuZGVmYXVsdH0pO3ZhciB1PXQoMjI2KTt0LmQoZSwiUGF0aCIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIE09dCgyMjkpO3QuZChlLCJSZWN0IixmdW5jdGlvbigpe3JldHVybiBNLmRlZmF1bHR9KTt2YXIgZj10KDIzMSk7dC5kKGUsIlRyaWFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBmLmRlZmF1bHR9KTt2YXIgdj10KDIzNik7dC5kKGUsIlBhcmFsbGVsIixmdW5jdGlvbigpe3JldHVybiB2LmRlZmF1bHR9KTt2YXIgeD10KDIzOCk7dC5kKGUsIlJlZ3VsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHguZGVmYXVsdH0pO3ZhciBSPXQoMjQwKTt0LmQoZSwiU3RhciIsZnVuY3Rpb24oKXtyZXR1cm4gUi5kZWZhdWx0fSk7dmFyIE89dCgyNDIpO3QuZChlLCJFbGxpcHNlIixmdW5jdGlvbigpe3JldHVybiBPLmRlZmF1bHR9KTt2YXIgZz10KDI0NCk7dC5kKGUsIkFyYyIsZnVuY3Rpb24oKXtyZXR1cm4gZy5kZWZhdWx0fSk7dmFyIHA9dCgyNDYpO3QuZChlLCJSaW5nIixmdW5jdGlvbigpe3JldHVybiBwLmRlZmF1bHR9KTt2YXIgbj10KDIzMik7dC5kKGUsIlBvbHlsaW5lIixmdW5jdGlvbigpe3JldHVybiBuLmRlZmF1bHR9KTt2YXIgYT10KDI0OCk7dC5kKGUsIkxhYmVsIixmdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHR9KTt2YXIgaT10KDI1MCk7dC5kKGUsIkdyb3VwIixmdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHR9KTt2YXIgbz10KDI4Nik7dC5kKGUsIkxheWVyIixmdW5jdGlvbigpe3JldHVybiBvLmRlZmF1bHR9KTt2YXIgVD10KDI4Nyk7dC5kKGUsIlNwcml0ZVN2ZyIsZnVuY3Rpb24oKXtyZXR1cm4gVC5kZWZhdWx0fSk7dmFyIEE9dCgyODkpO3QuZChlLCJMYXllcldvcmtlciIsZnVuY3Rpb24oKXtyZXR1cm4gQS5kZWZhdWx0fSk7dmFyIEM9dCgyOTApO3QuZChlLCJTY2VuZSIsZnVuY3Rpb24oKXtyZXR1cm4gQy5kZWZhdWx0fSk7dmFyIEk9dCgyMTMpLFA9dCgyMjEpO3QuZChlLCJDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gUC5Db2xvcn0pLHQuZChlLCJHcmFkaWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gUC5HcmFkaWVudH0pO3ZhciBMPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBEPUkuZGVmYXVsdC5jcmVhdGVFbGVtZW50LGI9SS5kZWZhdWx0LmlzU3ByaXRlTm9kZSxTPUkuZGVmYXVsdC5yZWdpc3Rlck5vZGUsQj17cGFyc2VDb2xvcjpQLnBhcnNlQ29sb3Isc2l6ZVRvUGl4ZWw6TC5zaXplVG9QaXhlbCx0b0FycmF5OkwudG9BcnJheSx0b1N0cmluZzpMLnRvU3RyaW5nLHRvTnVtYmVyOkwudG9OdW1iZXJ9O2xldCB3O3c9IjMuOC4zIjtjb25zdCBIPXd9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCgyKTt0LmQoZSwiZ2xNYXRyaXgiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KTt2YXIgcz10KDMpO3QuZChlLCJtYXQyIixmdW5jdGlvbigpe3JldHVybiBzfSk7dmFyIG09dCg0KTt0LmQoZSwibWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgeT10KDUpO3QuZChlLCJtYXQzIixmdW5jdGlvbigpe3JldHVybiB5fSk7dmFyIGM9dCg2KTt0LmQoZSwibWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBsPXQoNyk7dC5kKGUsInF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgdT10KDEwKTt0LmQoZSwicXVhdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KTt2YXIgTT10KDExKTt0LmQoZSwidmVjMiIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pO3ZhciBmPXQoOCk7dC5kKGUsInZlYzMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgdj10KDkpO3QuZChlLCJ2ZWM0IixmdW5jdGlvbigpe3JldHVybiB2fSl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsIkVQU0lMT04iLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwiQVJSQVlfVFlQRSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJSQU5ET00iLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwic2V0TWF0cml4QXJyYXlUeXBlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInRvUmFkaWFuIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPTFlLTYscz10eXBlb2YgRmxvYXQzMkFycmF5PCJ1Ij9GbG9hdDMyQXJyYXk6QXJyYXksbT1NYXRoLnJhbmRvbTtmdW5jdGlvbiB5KE0pe3M9TX12YXIgYz1NYXRoLlBJLzE4MDtmdW5jdGlvbiBsKE0pe3JldHVybiBNKmN9ZnVuY3Rpb24gdShNLGYpe3JldHVybiBNYXRoLmFicyhNLWYpPD1yKk1hdGgubWF4KDEsTWF0aC5hYnMoTSksTWF0aC5hYnMoZikpfU1hdGguaHlwb3R8fChNYXRoLmh5cG90PWZ1bmN0aW9uKCl7Zm9yKHZhciBNPTAsZj1hcmd1bWVudHMubGVuZ3RoO2YtLTspTSs9YXJndW1lbnRzW2ZdKmFyZ3VtZW50c1tmXTtyZXR1cm4gTWF0aC5zcXJ0KE0pfSl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsIkxEVSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIHMoKXt2YXIgUz1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFNbMV09MCxTWzJdPTApLFNbMF09MSxTWzNdPTEsU31mdW5jdGlvbiBtKFMpe3ZhciBCPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIEJbMF09U1swXSxCWzFdPVNbMV0sQlsyXT1TWzJdLEJbM109U1szXSxCfWZ1bmN0aW9uIHkoUyxCKXtyZXR1cm4gU1swXT1CWzBdLFNbMV09QlsxXSxTWzJdPUJbMl0sU1szXT1CWzNdLFN9ZnVuY3Rpb24gYyhTKXtyZXR1cm4gU1swXT0xLFNbMV09MCxTWzJdPTAsU1szXT0xLFN9ZnVuY3Rpb24gbChTLEIsdyxIKXt2YXIgSj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBKWzBdPVMsSlsxXT1CLEpbMl09dyxKWzNdPUgsSn1mdW5jdGlvbiB1KFMsQix3LEgsSil7cmV0dXJuIFNbMF09QixTWzFdPXcsU1syXT1ILFNbM109SixTfWZ1bmN0aW9uIE0oUyxCKXtpZihTPT09Qil7dmFyIHc9QlsxXTtTWzFdPUJbMl0sU1syXT13fWVsc2UgU1swXT1CWzBdLFNbMV09QlsyXSxTWzJdPUJbMV0sU1szXT1CWzNdO3JldHVybiBTfWZ1bmN0aW9uIGYoUyxCKXt2YXIgdz1CWzBdLEg9QlsxXSxKPUJbMl0scT1CWzNdLFc9dypxLUoqSDtyZXR1cm4gVz8oVz0xL1csU1swXT1xKlcsU1sxXT0tSCpXLFNbMl09LUoqVyxTWzNdPXcqVyxTKTpudWxsfWZ1bmN0aW9uIHYoUyxCKXt2YXIgdz1CWzBdO3JldHVybiBTWzBdPUJbM10sU1sxXT0tQlsxXSxTWzJdPS1CWzJdLFNbM109dyxTfWZ1bmN0aW9uIHgoUyl7cmV0dXJuIFNbMF0qU1szXS1TWzJdKlNbMV19ZnVuY3Rpb24gUihTLEIsdyl7dmFyIEg9QlswXSxKPUJbMV0scT1CWzJdLFc9QlszXSxHPXdbMF0sUT13WzFdLHR0PXdbMl0sXz13WzNdO3JldHVybiBTWzBdPUgqRytxKlEsU1sxXT1KKkcrVypRLFNbMl09SCp0dCtxKl8sU1szXT1KKnR0K1cqXyxTfWZ1bmN0aW9uIE8oUyxCLHcpe3ZhciBIPUJbMF0sSj1CWzFdLHE9QlsyXSxXPUJbM10sRz1NYXRoLnNpbih3KSxRPU1hdGguY29zKHcpO3JldHVybiBTWzBdPUgqUStxKkcsU1sxXT1KKlErVypHLFNbMl09SCotRytxKlEsU1szXT1KKi1HK1cqUSxTfWZ1bmN0aW9uIGcoUyxCLHcpe3ZhciBIPUJbMF0sSj1CWzFdLHE9QlsyXSxXPUJbM10sRz13WzBdLFE9d1sxXTtyZXR1cm4gU1swXT1IKkcsU1sxXT1KKkcsU1syXT1xKlEsU1szXT1XKlEsU31mdW5jdGlvbiBwKFMsQil7dmFyIHc9TWF0aC5zaW4oQiksSD1NYXRoLmNvcyhCKTtyZXR1cm4gU1swXT1ILFNbMV09dyxTWzJdPS13LFNbM109SCxTfWZ1bmN0aW9uIG4oUyxCKXtyZXR1cm4gU1swXT1CWzBdLFNbMV09MCxTWzJdPTAsU1szXT1CWzFdLFN9ZnVuY3Rpb24gYShTKXtyZXR1cm4ibWF0MigiK1NbMF0rIiwgIitTWzFdKyIsICIrU1syXSsiLCAiK1NbM10rIikifWZ1bmN0aW9uIGkoUyl7cmV0dXJuIE1hdGguaHlwb3QoU1swXSxTWzFdLFNbMl0sU1szXSl9ZnVuY3Rpb24gbyhTLEIsdyxIKXtyZXR1cm4gU1syXT1IWzJdL0hbMF0sd1swXT1IWzBdLHdbMV09SFsxXSx3WzNdPUhbM10tU1syXSp3WzFdLFtTLEIsd119ZnVuY3Rpb24gVChTLEIsdyl7cmV0dXJuIFNbMF09QlswXSt3WzBdLFNbMV09QlsxXSt3WzFdLFNbMl09QlsyXSt3WzJdLFNbM109QlszXSt3WzNdLFN9ZnVuY3Rpb24gQShTLEIsdyl7cmV0dXJuIFNbMF09QlswXS13WzBdLFNbMV09QlsxXS13WzFdLFNbMl09QlsyXS13WzJdLFNbM109QlszXS13WzNdLFN9ZnVuY3Rpb24gQyhTLEIpe3JldHVybiBTWzBdPT09QlswXSYmU1sxXT09PUJbMV0mJlNbMl09PT1CWzJdJiZTWzNdPT09QlszXX1mdW5jdGlvbiBJKFMsQil7dmFyIHc9U1swXSxIPVNbMV0sSj1TWzJdLHE9U1szXSxXPUJbMF0sRz1CWzFdLFE9QlsyXSx0dD1CWzNdO3JldHVybiBNYXRoLmFicyh3LVcpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh3KSxNYXRoLmFicyhXKSkmJk1hdGguYWJzKEgtRyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEgpLE1hdGguYWJzKEcpKSYmTWF0aC5hYnMoSi1RKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMoUSkpJiZNYXRoLmFicyhxLXR0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocSksTWF0aC5hYnModHQpKX1mdW5jdGlvbiBQKFMsQix3KXtyZXR1cm4gU1swXT1CWzBdKncsU1sxXT1CWzFdKncsU1syXT1CWzJdKncsU1szXT1CWzNdKncsU31mdW5jdGlvbiBMKFMsQix3LEgpe3JldHVybiBTWzBdPUJbMF0rd1swXSpILFNbMV09QlsxXSt3WzFdKkgsU1syXT1CWzJdK3dbMl0qSCxTWzNdPUJbM10rd1szXSpILFN9dmFyIEQ9UixiPUF9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tU2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBEfSk7dmFyIHI9dCgyKTtmdW5jdGlvbiBzKCl7dmFyIGI9bmV3IHIuQVJSQVlfVFlQRSg2KTtyZXR1cm4gci5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihiWzFdPTAsYlsyXT0wLGJbNF09MCxiWzVdPTApLGJbMF09MSxiWzNdPTEsYn1mdW5jdGlvbiBtKGIpe3ZhciBTPW5ldyByLkFSUkFZX1RZUEUoNik7cmV0dXJuIFNbMF09YlswXSxTWzFdPWJbMV0sU1syXT1iWzJdLFNbM109YlszXSxTWzRdPWJbNF0sU1s1XT1iWzVdLFN9ZnVuY3Rpb24geShiLFMpe3JldHVybiBiWzBdPVNbMF0sYlsxXT1TWzFdLGJbMl09U1syXSxiWzNdPVNbM10sYls0XT1TWzRdLGJbNV09U1s1XSxifWZ1bmN0aW9uIGMoYil7cmV0dXJuIGJbMF09MSxiWzFdPTAsYlsyXT0wLGJbM109MSxiWzRdPTAsYls1XT0wLGJ9ZnVuY3Rpb24gbChiLFMsQix3LEgsSil7dmFyIHE9bmV3IHIuQVJSQVlfVFlQRSg2KTtyZXR1cm4gcVswXT1iLHFbMV09UyxxWzJdPUIscVszXT13LHFbNF09SCxxWzVdPUoscX1mdW5jdGlvbiB1KGIsUyxCLHcsSCxKLHEpe3JldHVybiBiWzBdPVMsYlsxXT1CLGJbMl09dyxiWzNdPUgsYls0XT1KLGJbNV09cSxifWZ1bmN0aW9uIE0oYixTKXt2YXIgQj1TWzBdLHc9U1sxXSxIPVNbMl0sSj1TWzNdLHE9U1s0XSxXPVNbNV0sRz1CKkotdypIO3JldHVybiBHPyhHPTEvRyxiWzBdPUoqRyxiWzFdPS13KkcsYlsyXT0tSCpHLGJbM109QipHLGJbNF09KEgqVy1KKnEpKkcsYls1XT0odypxLUIqVykqRyxiKTpudWxsfWZ1bmN0aW9uIGYoYil7cmV0dXJuIGJbMF0qYlszXS1iWzFdKmJbMl19ZnVuY3Rpb24gdihiLFMsQil7dmFyIHc9U1swXSxIPVNbMV0sSj1TWzJdLHE9U1szXSxXPVNbNF0sRz1TWzVdLFE9QlswXSx0dD1CWzFdLF89QlsyXSxzdD1CWzNdLGs9Qls0XSxjdD1CWzVdO3JldHVybiBiWzBdPXcqUStKKnR0LGJbMV09SCpRK3EqdHQsYlsyXT13Kl8rSipzdCxiWzNdPUgqXytxKnN0LGJbNF09dyprK0oqY3QrVyxiWzVdPUgqaytxKmN0K0csYn1mdW5jdGlvbiB4KGIsUyxCKXt2YXIgdz1TWzBdLEg9U1sxXSxKPVNbMl0scT1TWzNdLFc9U1s0XSxHPVNbNV0sUT1NYXRoLnNpbihCKSx0dD1NYXRoLmNvcyhCKTtyZXR1cm4gYlswXT13KnR0K0oqUSxiWzFdPUgqdHQrcSpRLGJbMl09dyotUStKKnR0LGJbM109SCotUStxKnR0LGJbNF09VyxiWzVdPUcsYn1mdW5jdGlvbiBSKGIsUyxCKXt2YXIgdz1TWzBdLEg9U1sxXSxKPVNbMl0scT1TWzNdLFc9U1s0XSxHPVNbNV0sUT1CWzBdLHR0PUJbMV07cmV0dXJuIGJbMF09dypRLGJbMV09SCpRLGJbMl09Sip0dCxiWzNdPXEqdHQsYls0XT1XLGJbNV09RyxifWZ1bmN0aW9uIE8oYixTLEIpe3ZhciB3PVNbMF0sSD1TWzFdLEo9U1syXSxxPVNbM10sVz1TWzRdLEc9U1s1XSxRPUJbMF0sdHQ9QlsxXTtyZXR1cm4gYlswXT13LGJbMV09SCxiWzJdPUosYlszXT1xLGJbNF09dypRK0oqdHQrVyxiWzVdPUgqUStxKnR0K0csYn1mdW5jdGlvbiBnKGIsUyl7dmFyIEI9TWF0aC5zaW4oUyksdz1NYXRoLmNvcyhTKTtyZXR1cm4gYlswXT13LGJbMV09QixiWzJdPS1CLGJbM109dyxiWzRdPTAsYls1XT0wLGJ9ZnVuY3Rpb24gcChiLFMpe3JldHVybiBiWzBdPVNbMF0sYlsxXT0wLGJbMl09MCxiWzNdPVNbMV0sYls0XT0wLGJbNV09MCxifWZ1bmN0aW9uIG4oYixTKXtyZXR1cm4gYlswXT0xLGJbMV09MCxiWzJdPTAsYlszXT0xLGJbNF09U1swXSxiWzVdPVNbMV0sYn1mdW5jdGlvbiBhKGIpe3JldHVybiJtYXQyZCgiK2JbMF0rIiwgIitiWzFdKyIsICIrYlsyXSsiLCAiK2JbM10rIiwgIitiWzRdKyIsICIrYls1XSsiKSJ9ZnVuY3Rpb24gaShiKXtyZXR1cm4gTWF0aC5oeXBvdChiWzBdLGJbMV0sYlsyXSxiWzNdLGJbNF0sYls1XSwxKX1mdW5jdGlvbiBvKGIsUyxCKXtyZXR1cm4gYlswXT1TWzBdK0JbMF0sYlsxXT1TWzFdK0JbMV0sYlsyXT1TWzJdK0JbMl0sYlszXT1TWzNdK0JbM10sYls0XT1TWzRdK0JbNF0sYls1XT1TWzVdK0JbNV0sYn1mdW5jdGlvbiBUKGIsUyxCKXtyZXR1cm4gYlswXT1TWzBdLUJbMF0sYlsxXT1TWzFdLUJbMV0sYlsyXT1TWzJdLUJbMl0sYlszXT1TWzNdLUJbM10sYls0XT1TWzRdLUJbNF0sYls1XT1TWzVdLUJbNV0sYn1mdW5jdGlvbiBBKGIsUyxCKXtyZXR1cm4gYlswXT1TWzBdKkIsYlsxXT1TWzFdKkIsYlsyXT1TWzJdKkIsYlszXT1TWzNdKkIsYls0XT1TWzRdKkIsYls1XT1TWzVdKkIsYn1mdW5jdGlvbiBDKGIsUyxCLHcpe3JldHVybiBiWzBdPVNbMF0rQlswXSp3LGJbMV09U1sxXStCWzFdKncsYlsyXT1TWzJdK0JbMl0qdyxiWzNdPVNbM10rQlszXSp3LGJbNF09U1s0XStCWzRdKncsYls1XT1TWzVdK0JbNV0qdyxifWZ1bmN0aW9uIEkoYixTKXtyZXR1cm4gYlswXT09PVNbMF0mJmJbMV09PT1TWzFdJiZiWzJdPT09U1syXSYmYlszXT09PVNbM10mJmJbNF09PT1TWzRdJiZiWzVdPT09U1s1XX1mdW5jdGlvbiBQKGIsUyl7dmFyIEI9YlswXSx3PWJbMV0sSD1iWzJdLEo9YlszXSxxPWJbNF0sVz1iWzVdLEc9U1swXSxRPVNbMV0sdHQ9U1syXSxfPVNbM10sc3Q9U1s0XSxrPVNbNV07cmV0dXJuIE1hdGguYWJzKEItRyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEIpLE1hdGguYWJzKEcpKSYmTWF0aC5hYnMody1RKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModyksTWF0aC5hYnMoUSkpJiZNYXRoLmFicyhILXR0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSCksTWF0aC5hYnModHQpKSYmTWF0aC5hYnMoSi1fKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMoXykpJiZNYXRoLmFicyhxLXN0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocSksTWF0aC5hYnMoc3QpKSYmTWF0aC5hYnMoVy1rKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVyksTWF0aC5hYnMoaykpfXZhciBMPXYsRD1UfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImZyb21NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJub3JtYWxGcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJwcm9qZWN0aW9uIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pO3ZhciByPXQoMik7ZnVuY3Rpb24gcygpe3ZhciBXPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoV1sxXT0wLFdbMl09MCxXWzNdPTAsV1s1XT0wLFdbNl09MCxXWzddPTApLFdbMF09MSxXWzRdPTEsV1s4XT0xLFd9ZnVuY3Rpb24gbShXLEcpe3JldHVybiBXWzBdPUdbMF0sV1sxXT1HWzFdLFdbMl09R1syXSxXWzNdPUdbNF0sV1s0XT1HWzVdLFdbNV09R1s2XSxXWzZdPUdbOF0sV1s3XT1HWzldLFdbOF09R1sxMF0sV31mdW5jdGlvbiB5KFcpe3ZhciBHPW5ldyByLkFSUkFZX1RZUEUoOSk7cmV0dXJuIEdbMF09V1swXSxHWzFdPVdbMV0sR1syXT1XWzJdLEdbM109V1szXSxHWzRdPVdbNF0sR1s1XT1XWzVdLEdbNl09V1s2XSxHWzddPVdbN10sR1s4XT1XWzhdLEd9ZnVuY3Rpb24gYyhXLEcpe3JldHVybiBXWzBdPUdbMF0sV1sxXT1HWzFdLFdbMl09R1syXSxXWzNdPUdbM10sV1s0XT1HWzRdLFdbNV09R1s1XSxXWzZdPUdbNl0sV1s3XT1HWzddLFdbOF09R1s4XSxXfWZ1bmN0aW9uIGwoVyxHLFEsdHQsXyxzdCxrLGN0LGZ0KXt2YXIgVT1uZXcgci5BUlJBWV9UWVBFKDkpO3JldHVybiBVWzBdPVcsVVsxXT1HLFVbMl09USxVWzNdPXR0LFVbNF09XyxVWzVdPXN0LFVbNl09ayxVWzddPWN0LFVbOF09ZnQsVX1mdW5jdGlvbiB1KFcsRyxRLHR0LF8sc3QsayxjdCxmdCxVKXtyZXR1cm4gV1swXT1HLFdbMV09USxXWzJdPXR0LFdbM109XyxXWzRdPXN0LFdbNV09ayxXWzZdPWN0LFdbN109ZnQsV1s4XT1VLFd9ZnVuY3Rpb24gTShXKXtyZXR1cm4gV1swXT0xLFdbMV09MCxXWzJdPTAsV1szXT0wLFdbNF09MSxXWzVdPTAsV1s2XT0wLFdbN109MCxXWzhdPTEsV31mdW5jdGlvbiBmKFcsRyl7aWYoVz09PUcpe3ZhciBRPUdbMV0sdHQ9R1syXSxfPUdbNV07V1sxXT1HWzNdLFdbMl09R1s2XSxXWzNdPVEsV1s1XT1HWzddLFdbNl09dHQsV1s3XT1ffWVsc2UgV1swXT1HWzBdLFdbMV09R1szXSxXWzJdPUdbNl0sV1szXT1HWzFdLFdbNF09R1s0XSxXWzVdPUdbN10sV1s2XT1HWzJdLFdbN109R1s1XSxXWzhdPUdbOF07cmV0dXJuIFd9ZnVuY3Rpb24gdihXLEcpe3ZhciBRPUdbMF0sdHQ9R1sxXSxfPUdbMl0sc3Q9R1szXSxrPUdbNF0sY3Q9R1s1XSxmdD1HWzZdLFU9R1s3XSxGPUdbOF0sVj1GKmstY3QqVSxYPS1GKnN0K2N0KmZ0LGo9VSpzdC1rKmZ0LHo9USpWK3R0KlgrXypqO3JldHVybiB6Pyh6PTEveixXWzBdPVYqeixXWzFdPSgtRip0dCtfKlUpKnosV1syXT0oY3QqdHQtXyprKSp6LFdbM109WCp6LFdbNF09KEYqUS1fKmZ0KSp6LFdbNV09KC1jdCpRK18qc3QpKnosV1s2XT1qKnosV1s3XT0oLVUqUSt0dCpmdCkqeixXWzhdPShrKlEtdHQqc3QpKnosVyk6bnVsbH1mdW5jdGlvbiB4KFcsRyl7dmFyIFE9R1swXSx0dD1HWzFdLF89R1syXSxzdD1HWzNdLGs9R1s0XSxjdD1HWzVdLGZ0PUdbNl0sVT1HWzddLEY9R1s4XTtyZXR1cm4gV1swXT1rKkYtY3QqVSxXWzFdPV8qVS10dCpGLFdbMl09dHQqY3QtXyprLFdbM109Y3QqZnQtc3QqRixXWzRdPVEqRi1fKmZ0LFdbNV09XypzdC1RKmN0LFdbNl09c3QqVS1rKmZ0LFdbN109dHQqZnQtUSpVLFdbOF09USprLXR0KnN0LFd9ZnVuY3Rpb24gUihXKXt2YXIgRz1XWzBdLFE9V1sxXSx0dD1XWzJdLF89V1szXSxzdD1XWzRdLGs9V1s1XSxjdD1XWzZdLGZ0PVdbN10sVT1XWzhdO3JldHVybiBHKihVKnN0LWsqZnQpK1EqKC1VKl8raypjdCkrdHQqKGZ0Kl8tc3QqY3QpfWZ1bmN0aW9uIE8oVyxHLFEpe3ZhciB0dD1HWzBdLF89R1sxXSxzdD1HWzJdLGs9R1szXSxjdD1HWzRdLGZ0PUdbNV0sVT1HWzZdLEY9R1s3XSxWPUdbOF0sWD1RWzBdLGo9UVsxXSx6PVFbMl0sZD1RWzNdLEU9UVs0XSxOPVFbNV0sJD1RWzZdLEs9UVs3XSxZPVFbOF07cmV0dXJuIFdbMF09WCp0dCtqKmsreipVLFdbMV09WCpfK2oqY3QreipGLFdbMl09WCpzdCtqKmZ0K3oqVixXWzNdPWQqdHQrRSprK04qVSxXWzRdPWQqXytFKmN0K04qRixXWzVdPWQqc3QrRSpmdCtOKlYsV1s2XT0kKnR0K0sqaytZKlUsV1s3XT0kKl8rSypjdCtZKkYsV1s4XT0kKnN0K0sqZnQrWSpWLFd9ZnVuY3Rpb24gZyhXLEcsUSl7dmFyIHR0PUdbMF0sXz1HWzFdLHN0PUdbMl0saz1HWzNdLGN0PUdbNF0sZnQ9R1s1XSxVPUdbNl0sRj1HWzddLFY9R1s4XSxYPVFbMF0saj1RWzFdO3JldHVybiBXWzBdPXR0LFdbMV09XyxXWzJdPXN0LFdbM109ayxXWzRdPWN0LFdbNV09ZnQsV1s2XT1YKnR0K2oqaytVLFdbN109WCpfK2oqY3QrRixXWzhdPVgqc3QraipmdCtWLFd9ZnVuY3Rpb24gcChXLEcsUSl7dmFyIHR0PUdbMF0sXz1HWzFdLHN0PUdbMl0saz1HWzNdLGN0PUdbNF0sZnQ9R1s1XSxVPUdbNl0sRj1HWzddLFY9R1s4XSxYPU1hdGguc2luKFEpLGo9TWF0aC5jb3MoUSk7cmV0dXJuIFdbMF09aip0dCtYKmssV1sxXT1qKl8rWCpjdCxXWzJdPWoqc3QrWCpmdCxXWzNdPWoqay1YKnR0LFdbNF09aipjdC1YKl8sV1s1XT1qKmZ0LVgqc3QsV1s2XT1VLFdbN109RixXWzhdPVYsV31mdW5jdGlvbiBuKFcsRyxRKXt2YXIgdHQ9UVswXSxfPVFbMV07cmV0dXJuIFdbMF09dHQqR1swXSxXWzFdPXR0KkdbMV0sV1syXT10dCpHWzJdLFdbM109XypHWzNdLFdbNF09XypHWzRdLFdbNV09XypHWzVdLFdbNl09R1s2XSxXWzddPUdbN10sV1s4XT1HWzhdLFd9ZnVuY3Rpb24gYShXLEcpe3JldHVybiBXWzBdPTEsV1sxXT0wLFdbMl09MCxXWzNdPTAsV1s0XT0xLFdbNV09MCxXWzZdPUdbMF0sV1s3XT1HWzFdLFdbOF09MSxXfWZ1bmN0aW9uIGkoVyxHKXt2YXIgUT1NYXRoLnNpbihHKSx0dD1NYXRoLmNvcyhHKTtyZXR1cm4gV1swXT10dCxXWzFdPVEsV1syXT0wLFdbM109LVEsV1s0XT10dCxXWzVdPTAsV1s2XT0wLFdbN109MCxXWzhdPTEsV31mdW5jdGlvbiBvKFcsRyl7cmV0dXJuIFdbMF09R1swXSxXWzFdPTAsV1syXT0wLFdbM109MCxXWzRdPUdbMV0sV1s1XT0wLFdbNl09MCxXWzddPTAsV1s4XT0xLFd9ZnVuY3Rpb24gVChXLEcpe3JldHVybiBXWzBdPUdbMF0sV1sxXT1HWzFdLFdbMl09MCxXWzNdPUdbMl0sV1s0XT1HWzNdLFdbNV09MCxXWzZdPUdbNF0sV1s3XT1HWzVdLFdbOF09MSxXfWZ1bmN0aW9uIEEoVyxHKXt2YXIgUT1HWzBdLHR0PUdbMV0sXz1HWzJdLHN0PUdbM10saz1RK1EsY3Q9dHQrdHQsZnQ9XytfLFU9USprLEY9dHQqayxWPXR0KmN0LFg9XyprLGo9XypjdCx6PV8qZnQsZD1zdCprLEU9c3QqY3QsTj1zdCpmdDtyZXR1cm4gV1swXT0xLVYteixXWzNdPUYtTixXWzZdPVgrRSxXWzFdPUYrTixXWzRdPTEtVS16LFdbN109ai1kLFdbMl09WC1FLFdbNV09aitkLFdbOF09MS1VLVYsV31mdW5jdGlvbiBDKFcsRyl7dmFyIFE9R1swXSx0dD1HWzFdLF89R1syXSxzdD1HWzNdLGs9R1s0XSxjdD1HWzVdLGZ0PUdbNl0sVT1HWzddLEY9R1s4XSxWPUdbOV0sWD1HWzEwXSxqPUdbMTFdLHo9R1sxMl0sZD1HWzEzXSxFPUdbMTRdLE49R1sxNV0sJD1RKmN0LXR0KmssSz1RKmZ0LV8qayxZPVEqVS1zdCprLFo9dHQqZnQtXypjdCxldD10dCpVLXN0KmN0LHJ0PV8qVS1zdCpmdCxhdD1GKmQtVip6LGx0PUYqRS1YKnosaXQ9RipOLWoqeixudD1WKkUtWCpkLG90PVYqTi1qKmQsZHQ9WCpOLWoqRSxndD0kKmR0LUsqb3QrWSpudCtaKml0LWV0Kmx0K3J0KmF0O3JldHVybiBndD8oZ3Q9MS9ndCxXWzBdPShjdCpkdC1mdCpvdCtVKm50KSpndCxXWzFdPShmdCppdC1rKmR0LVUqbHQpKmd0LFdbMl09KGsqb3QtY3QqaXQrVSphdCkqZ3QsV1szXT0oXypvdC10dCpkdC1zdCpudCkqZ3QsV1s0XT0oUSpkdC1fKml0K3N0Kmx0KSpndCxXWzVdPSh0dCppdC1RKm90LXN0KmF0KSpndCxXWzZdPShkKnJ0LUUqZXQrTipaKSpndCxXWzddPShFKlkteipydC1OKkspKmd0LFdbOF09KHoqZXQtZCpZK04qJCkqZ3QsVyk6bnVsbH1mdW5jdGlvbiBJKFcsRyxRKXtyZXR1cm4gV1swXT0yL0csV1sxXT0wLFdbMl09MCxXWzNdPTAsV1s0XT0tMi9RLFdbNV09MCxXWzZdPS0xLFdbN109MSxXWzhdPTEsV31mdW5jdGlvbiBQKFcpe3JldHVybiJtYXQzKCIrV1swXSsiLCAiK1dbMV0rIiwgIitXWzJdKyIsICIrV1szXSsiLCAiK1dbNF0rIiwgIitXWzVdKyIsICIrV1s2XSsiLCAiK1dbN10rIiwgIitXWzhdKyIpIn1mdW5jdGlvbiBMKFcpe3JldHVybiBNYXRoLmh5cG90KFdbMF0sV1sxXSxXWzJdLFdbM10sV1s0XSxXWzVdLFdbNl0sV1s3XSxXWzhdKX1mdW5jdGlvbiBEKFcsRyxRKXtyZXR1cm4gV1swXT1HWzBdK1FbMF0sV1sxXT1HWzFdK1FbMV0sV1syXT1HWzJdK1FbMl0sV1szXT1HWzNdK1FbM10sV1s0XT1HWzRdK1FbNF0sV1s1XT1HWzVdK1FbNV0sV1s2XT1HWzZdK1FbNl0sV1s3XT1HWzddK1FbN10sV1s4XT1HWzhdK1FbOF0sV31mdW5jdGlvbiBiKFcsRyxRKXtyZXR1cm4gV1swXT1HWzBdLVFbMF0sV1sxXT1HWzFdLVFbMV0sV1syXT1HWzJdLVFbMl0sV1szXT1HWzNdLVFbM10sV1s0XT1HWzRdLVFbNF0sV1s1XT1HWzVdLVFbNV0sV1s2XT1HWzZdLVFbNl0sV1s3XT1HWzddLVFbN10sV1s4XT1HWzhdLVFbOF0sV31mdW5jdGlvbiBTKFcsRyxRKXtyZXR1cm4gV1swXT1HWzBdKlEsV1sxXT1HWzFdKlEsV1syXT1HWzJdKlEsV1szXT1HWzNdKlEsV1s0XT1HWzRdKlEsV1s1XT1HWzVdKlEsV1s2XT1HWzZdKlEsV1s3XT1HWzddKlEsV1s4XT1HWzhdKlEsV31mdW5jdGlvbiBCKFcsRyxRLHR0KXtyZXR1cm4gV1swXT1HWzBdK1FbMF0qdHQsV1sxXT1HWzFdK1FbMV0qdHQsV1syXT1HWzJdK1FbMl0qdHQsV1szXT1HWzNdK1FbM10qdHQsV1s0XT1HWzRdK1FbNF0qdHQsV1s1XT1HWzVdK1FbNV0qdHQsV1s2XT1HWzZdK1FbNl0qdHQsV1s3XT1HWzddK1FbN10qdHQsV1s4XT1HWzhdK1FbOF0qdHQsV31mdW5jdGlvbiB3KFcsRyl7cmV0dXJuIFdbMF09PT1HWzBdJiZXWzFdPT09R1sxXSYmV1syXT09PUdbMl0mJldbM109PT1HWzNdJiZXWzRdPT09R1s0XSYmV1s1XT09PUdbNV0mJldbNl09PT1HWzZdJiZXWzddPT09R1s3XSYmV1s4XT09PUdbOF19ZnVuY3Rpb24gSChXLEcpe3ZhciBRPVdbMF0sdHQ9V1sxXSxfPVdbMl0sc3Q9V1szXSxrPVdbNF0sY3Q9V1s1XSxmdD1XWzZdLFU9V1s3XSxGPVdbOF0sVj1HWzBdLFg9R1sxXSxqPUdbMl0sej1HWzNdLGQ9R1s0XSxFPUdbNV0sTj1HWzZdLCQ9R1s3XSxLPUdbOF07cmV0dXJuIE1hdGguYWJzKFEtVik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFEpLE1hdGguYWJzKFYpKSYmTWF0aC5hYnModHQtWCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHR0KSxNYXRoLmFicyhYKSkmJk1hdGguYWJzKF8taik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKF8pLE1hdGguYWJzKGopKSYmTWF0aC5hYnMoc3Qteik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHN0KSxNYXRoLmFicyh6KSkmJk1hdGguYWJzKGstZCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGspLE1hdGguYWJzKGQpKSYmTWF0aC5hYnMoY3QtRSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGN0KSxNYXRoLmFicyhFKSkmJk1hdGguYWJzKGZ0LU4pPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhmdCksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhVLSQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhVKSxNYXRoLmFicygkKSkmJk1hdGguYWJzKEYtSyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEYpLE1hdGguYWJzKEspKX12YXIgSj1PLHE9Yn0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJmcm9tWFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImZyb21ZUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwiZnJvbVpSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJmcm9tUXVhdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiZ2V0VHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZ2V0U2NhbGluZyIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJnZXRSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwiZnJvbVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiZnJ1c3R1bSIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJwZXJzcGVjdGl2ZSIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyIsZnVuY3Rpb24oKXtyZXR1cm4gR30pLHQuZChlLCJvcnRobyIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJsb29rQXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsInRhcmdldFRvIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWx0aXBseVNjYWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJtdWx0aXBseVNjYWxhckFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBqfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gen0pO3ZhciByPXQoMik7ZnVuY3Rpb24gcygpe3ZhciBkPW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKGRbMV09MCxkWzJdPTAsZFszXT0wLGRbNF09MCxkWzZdPTAsZFs3XT0wLGRbOF09MCxkWzldPTAsZFsxMV09MCxkWzEyXT0wLGRbMTNdPTAsZFsxNF09MCksZFswXT0xLGRbNV09MSxkWzEwXT0xLGRbMTVdPTEsZH1mdW5jdGlvbiBtKGQpe3ZhciBFPW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiBFWzBdPWRbMF0sRVsxXT1kWzFdLEVbMl09ZFsyXSxFWzNdPWRbM10sRVs0XT1kWzRdLEVbNV09ZFs1XSxFWzZdPWRbNl0sRVs3XT1kWzddLEVbOF09ZFs4XSxFWzldPWRbOV0sRVsxMF09ZFsxMF0sRVsxMV09ZFsxMV0sRVsxMl09ZFsxMl0sRVsxM109ZFsxM10sRVsxNF09ZFsxNF0sRVsxNV09ZFsxNV0sRX1mdW5jdGlvbiB5KGQsRSl7cmV0dXJuIGRbMF09RVswXSxkWzFdPUVbMV0sZFsyXT1FWzJdLGRbM109RVszXSxkWzRdPUVbNF0sZFs1XT1FWzVdLGRbNl09RVs2XSxkWzddPUVbN10sZFs4XT1FWzhdLGRbOV09RVs5XSxkWzEwXT1FWzEwXSxkWzExXT1FWzExXSxkWzEyXT1FWzEyXSxkWzEzXT1FWzEzXSxkWzE0XT1FWzE0XSxkWzE1XT1FWzE1XSxkfWZ1bmN0aW9uIGMoZCxFLE4sJCxLLFksWixldCxydCxhdCxsdCxpdCxudCxvdCxkdCxndCl7dmFyIHV0PW5ldyByLkFSUkFZX1RZUEUoMTYpO3JldHVybiB1dFswXT1kLHV0WzFdPUUsdXRbMl09Tix1dFszXT0kLHV0WzRdPUssdXRbNV09WSx1dFs2XT1aLHV0WzddPWV0LHV0WzhdPXJ0LHV0WzldPWF0LHV0WzEwXT1sdCx1dFsxMV09aXQsdXRbMTJdPW50LHV0WzEzXT1vdCx1dFsxNF09ZHQsdXRbMTVdPWd0LHV0fWZ1bmN0aW9uIGwoZCxFLE4sJCxLLFksWixldCxydCxhdCxsdCxpdCxudCxvdCxkdCxndCx1dCl7cmV0dXJuIGRbMF09RSxkWzFdPU4sZFsyXT0kLGRbM109SyxkWzRdPVksZFs1XT1aLGRbNl09ZXQsZFs3XT1ydCxkWzhdPWF0LGRbOV09bHQsZFsxMF09aXQsZFsxMV09bnQsZFsxMl09b3QsZFsxM109ZHQsZFsxNF09Z3QsZFsxNV09dXQsZH1mdW5jdGlvbiB1KGQpe3JldHVybiBkWzBdPTEsZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09MSxkWzZdPTAsZFs3XT0wLGRbOF09MCxkWzldPTAsZFsxMF09MSxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wLGRbMTVdPTEsZH1mdW5jdGlvbiBNKGQsRSl7aWYoZD09PUUpe3ZhciBOPUVbMV0sJD1FWzJdLEs9RVszXSxZPUVbNl0sWj1FWzddLGV0PUVbMTFdO2RbMV09RVs0XSxkWzJdPUVbOF0sZFszXT1FWzEyXSxkWzRdPU4sZFs2XT1FWzldLGRbN109RVsxM10sZFs4XT0kLGRbOV09WSxkWzExXT1FWzE0XSxkWzEyXT1LLGRbMTNdPVosZFsxNF09ZXR9ZWxzZSBkWzBdPUVbMF0sZFsxXT1FWzRdLGRbMl09RVs4XSxkWzNdPUVbMTJdLGRbNF09RVsxXSxkWzVdPUVbNV0sZFs2XT1FWzldLGRbN109RVsxM10sZFs4XT1FWzJdLGRbOV09RVs2XSxkWzEwXT1FWzEwXSxkWzExXT1FWzE0XSxkWzEyXT1FWzNdLGRbMTNdPUVbN10sZFsxNF09RVsxMV0sZFsxNV09RVsxNV07cmV0dXJuIGR9ZnVuY3Rpb24gZihkLEUpe3ZhciBOPUVbMF0sJD1FWzFdLEs9RVsyXSxZPUVbM10sWj1FWzRdLGV0PUVbNV0scnQ9RVs2XSxhdD1FWzddLGx0PUVbOF0saXQ9RVs5XSxudD1FWzEwXSxvdD1FWzExXSxkdD1FWzEyXSxndD1FWzEzXSx1dD1FWzE0XSxtdD1FWzE1XSxPdD1OKmV0LSQqWix5dD1OKnJ0LUsqWixwdD1OKmF0LVkqWix4dD0kKnJ0LUsqZXQsTXQ9JCphdC1ZKmV0LEJ0PUsqYXQtWSpydCxJdD1sdCpndC1pdCpkdCxOdD1sdCp1dC1udCpkdCxqdD1sdCptdC1vdCpkdCxGdD1pdCp1dC1udCpndCxXdD1pdCptdC1vdCpndCwkdD1udCptdC1vdCp1dCxUdD1PdCokdC15dCpXdCtwdCpGdCt4dCpqdC1NdCpOdCtCdCpJdDtyZXR1cm4gVHQ/KFR0PTEvVHQsZFswXT0oZXQqJHQtcnQqV3QrYXQqRnQpKlR0LGRbMV09KEsqV3QtJCokdC1ZKkZ0KSpUdCxkWzJdPShndCpCdC11dCpNdCttdCp4dCkqVHQsZFszXT0obnQqTXQtaXQqQnQtb3QqeHQpKlR0LGRbNF09KHJ0Kmp0LVoqJHQtYXQqTnQpKlR0LGRbNV09KE4qJHQtSypqdCtZKk50KSpUdCxkWzZdPSh1dCpwdC1kdCpCdC1tdCp5dCkqVHQsZFs3XT0obHQqQnQtbnQqcHQrb3QqeXQpKlR0LGRbOF09KFoqV3QtZXQqanQrYXQqSXQpKlR0LGRbOV09KCQqanQtTipXdC1ZKkl0KSpUdCxkWzEwXT0oZHQqTXQtZ3QqcHQrbXQqT3QpKlR0LGRbMTFdPShpdCpwdC1sdCpNdC1vdCpPdCkqVHQsZFsxMl09KGV0Kk50LVoqRnQtcnQqSXQpKlR0LGRbMTNdPShOKkZ0LSQqTnQrSypJdCkqVHQsZFsxNF09KGd0Knl0LWR0Knh0LXV0Kk90KSpUdCxkWzE1XT0obHQqeHQtaXQqeXQrbnQqT3QpKlR0LGQpOm51bGx9ZnVuY3Rpb24gdihkLEUpe3ZhciBOPUVbMF0sJD1FWzFdLEs9RVsyXSxZPUVbM10sWj1FWzRdLGV0PUVbNV0scnQ9RVs2XSxhdD1FWzddLGx0PUVbOF0saXQ9RVs5XSxudD1FWzEwXSxvdD1FWzExXSxkdD1FWzEyXSxndD1FWzEzXSx1dD1FWzE0XSxtdD1FWzE1XTtyZXR1cm4gZFswXT1ldCoobnQqbXQtb3QqdXQpLWl0KihydCptdC1hdCp1dCkrZ3QqKHJ0Km90LWF0Km50KSxkWzFdPS0oJCoobnQqbXQtb3QqdXQpLWl0KihLKm10LVkqdXQpK2d0KihLKm90LVkqbnQpKSxkWzJdPSQqKHJ0Km10LWF0KnV0KS1ldCooSyptdC1ZKnV0KStndCooSyphdC1ZKnJ0KSxkWzNdPS0oJCoocnQqb3QtYXQqbnQpLWV0KihLKm90LVkqbnQpK2l0KihLKmF0LVkqcnQpKSxkWzRdPS0oWioobnQqbXQtb3QqdXQpLWx0KihydCptdC1hdCp1dCkrZHQqKHJ0Km90LWF0Km50KSksZFs1XT1OKihudCptdC1vdCp1dCktbHQqKEsqbXQtWSp1dCkrZHQqKEsqb3QtWSpudCksZFs2XT0tKE4qKHJ0Km10LWF0KnV0KS1aKihLKm10LVkqdXQpK2R0KihLKmF0LVkqcnQpKSxkWzddPU4qKHJ0Km90LWF0Km50KS1aKihLKm90LVkqbnQpK2x0KihLKmF0LVkqcnQpLGRbOF09WiooaXQqbXQtb3QqZ3QpLWx0KihldCptdC1hdCpndCkrZHQqKGV0Km90LWF0Kml0KSxkWzldPS0oTiooaXQqbXQtb3QqZ3QpLWx0KigkKm10LVkqZ3QpK2R0KigkKm90LVkqaXQpKSxkWzEwXT1OKihldCptdC1hdCpndCktWiooJCptdC1ZKmd0KStkdCooJCphdC1ZKmV0KSxkWzExXT0tKE4qKGV0Km90LWF0Kml0KS1aKigkKm90LVkqaXQpK2x0KigkKmF0LVkqZXQpKSxkWzEyXT0tKFoqKGl0KnV0LW50Kmd0KS1sdCooZXQqdXQtcnQqZ3QpK2R0KihldCpudC1ydCppdCkpLGRbMTNdPU4qKGl0KnV0LW50Kmd0KS1sdCooJCp1dC1LKmd0KStkdCooJCpudC1LKml0KSxkWzE0XT0tKE4qKGV0KnV0LXJ0Kmd0KS1aKigkKnV0LUsqZ3QpK2R0KigkKnJ0LUsqZXQpKSxkWzE1XT1OKihldCpudC1ydCppdCktWiooJCpudC1LKml0KStsdCooJCpydC1LKmV0KSxkfWZ1bmN0aW9uIHgoZCl7dmFyIEU9ZFswXSxOPWRbMV0sJD1kWzJdLEs9ZFszXSxZPWRbNF0sWj1kWzVdLGV0PWRbNl0scnQ9ZFs3XSxhdD1kWzhdLGx0PWRbOV0saXQ9ZFsxMF0sbnQ9ZFsxMV0sb3Q9ZFsxMl0sZHQ9ZFsxM10sZ3Q9ZFsxNF0sdXQ9ZFsxNV0sbXQ9RSpaLU4qWSxPdD1FKmV0LSQqWSx5dD1FKnJ0LUsqWSxwdD1OKmV0LSQqWix4dD1OKnJ0LUsqWixNdD0kKnJ0LUsqZXQsQnQ9YXQqZHQtbHQqb3QsSXQ9YXQqZ3QtaXQqb3QsTnQ9YXQqdXQtbnQqb3QsanQ9bHQqZ3QtaXQqZHQsRnQ9bHQqdXQtbnQqZHQsV3Q9aXQqdXQtbnQqZ3Q7cmV0dXJuIG10Kld0LU90KkZ0K3l0Kmp0K3B0Kk50LXh0Kkl0K010KkJ0fWZ1bmN0aW9uIFIoZCxFLE4pe3ZhciAkPUVbMF0sSz1FWzFdLFk9RVsyXSxaPUVbM10sZXQ9RVs0XSxydD1FWzVdLGF0PUVbNl0sbHQ9RVs3XSxpdD1FWzhdLG50PUVbOV0sb3Q9RVsxMF0sZHQ9RVsxMV0sZ3Q9RVsxMl0sdXQ9RVsxM10sbXQ9RVsxNF0sT3Q9RVsxNV0seXQ9TlswXSxwdD1OWzFdLHh0PU5bMl0sTXQ9TlszXTtyZXR1cm4gZFswXT15dCokK3B0KmV0K3h0Kml0K010Kmd0LGRbMV09eXQqSytwdCpydCt4dCpudCtNdCp1dCxkWzJdPXl0KlkrcHQqYXQreHQqb3QrTXQqbXQsZFszXT15dCpaK3B0Kmx0K3h0KmR0K010Kk90LHl0PU5bNF0scHQ9Tls1XSx4dD1OWzZdLE10PU5bN10sZFs0XT15dCokK3B0KmV0K3h0Kml0K010Kmd0LGRbNV09eXQqSytwdCpydCt4dCpudCtNdCp1dCxkWzZdPXl0KlkrcHQqYXQreHQqb3QrTXQqbXQsZFs3XT15dCpaK3B0Kmx0K3h0KmR0K010Kk90LHl0PU5bOF0scHQ9Tls5XSx4dD1OWzEwXSxNdD1OWzExXSxkWzhdPXl0KiQrcHQqZXQreHQqaXQrTXQqZ3QsZFs5XT15dCpLK3B0KnJ0K3h0Km50K010KnV0LGRbMTBdPXl0KlkrcHQqYXQreHQqb3QrTXQqbXQsZFsxMV09eXQqWitwdCpsdCt4dCpkdCtNdCpPdCx5dD1OWzEyXSxwdD1OWzEzXSx4dD1OWzE0XSxNdD1OWzE1XSxkWzEyXT15dCokK3B0KmV0K3h0Kml0K010Kmd0LGRbMTNdPXl0KksrcHQqcnQreHQqbnQrTXQqdXQsZFsxNF09eXQqWStwdCphdCt4dCpvdCtNdCptdCxkWzE1XT15dCpaK3B0Kmx0K3h0KmR0K010Kk90LGR9ZnVuY3Rpb24gTyhkLEUsTil7dmFyICQ9TlswXSxLPU5bMV0sWT1OWzJdLFosZXQscnQsYXQsbHQsaXQsbnQsb3QsZHQsZ3QsdXQsbXQ7cmV0dXJuIEU9PT1kPyhkWzEyXT1FWzBdKiQrRVs0XSpLK0VbOF0qWStFWzEyXSxkWzEzXT1FWzFdKiQrRVs1XSpLK0VbOV0qWStFWzEzXSxkWzE0XT1FWzJdKiQrRVs2XSpLK0VbMTBdKlkrRVsxNF0sZFsxNV09RVszXSokK0VbN10qSytFWzExXSpZK0VbMTVdKTooWj1FWzBdLGV0PUVbMV0scnQ9RVsyXSxhdD1FWzNdLGx0PUVbNF0saXQ9RVs1XSxudD1FWzZdLG90PUVbN10sZHQ9RVs4XSxndD1FWzldLHV0PUVbMTBdLG10PUVbMTFdLGRbMF09WixkWzFdPWV0LGRbMl09cnQsZFszXT1hdCxkWzRdPWx0LGRbNV09aXQsZFs2XT1udCxkWzddPW90LGRbOF09ZHQsZFs5XT1ndCxkWzEwXT11dCxkWzExXT1tdCxkWzEyXT1aKiQrbHQqSytkdCpZK0VbMTJdLGRbMTNdPWV0KiQraXQqSytndCpZK0VbMTNdLGRbMTRdPXJ0KiQrbnQqSyt1dCpZK0VbMTRdLGRbMTVdPWF0KiQrb3QqSyttdCpZK0VbMTVdKSxkfWZ1bmN0aW9uIGcoZCxFLE4pe3ZhciAkPU5bMF0sSz1OWzFdLFk9TlsyXTtyZXR1cm4gZFswXT1FWzBdKiQsZFsxXT1FWzFdKiQsZFsyXT1FWzJdKiQsZFszXT1FWzNdKiQsZFs0XT1FWzRdKkssZFs1XT1FWzVdKkssZFs2XT1FWzZdKkssZFs3XT1FWzddKkssZFs4XT1FWzhdKlksZFs5XT1FWzldKlksZFsxMF09RVsxMF0qWSxkWzExXT1FWzExXSpZLGRbMTJdPUVbMTJdLGRbMTNdPUVbMTNdLGRbMTRdPUVbMTRdLGRbMTVdPUVbMTVdLGR9ZnVuY3Rpb24gcChkLEUsTiwkKXt2YXIgSz0kWzBdLFk9JFsxXSxaPSRbMl0sZXQ9TWF0aC5oeXBvdChLLFksWikscnQsYXQsbHQsaXQsbnQsb3QsZHQsZ3QsdXQsbXQsT3QseXQscHQseHQsTXQsQnQsSXQsTnQsanQsRnQsV3QsJHQsVHQsd3Q7cmV0dXJuIGV0PHIuRVBTSUxPTj9udWxsOihldD0xL2V0LEsqPWV0LFkqPWV0LFoqPWV0LHJ0PU1hdGguc2luKE4pLGF0PU1hdGguY29zKE4pLGx0PTEtYXQsaXQ9RVswXSxudD1FWzFdLG90PUVbMl0sZHQ9RVszXSxndD1FWzRdLHV0PUVbNV0sbXQ9RVs2XSxPdD1FWzddLHl0PUVbOF0scHQ9RVs5XSx4dD1FWzEwXSxNdD1FWzExXSxCdD1LKksqbHQrYXQsSXQ9WSpLKmx0K1oqcnQsTnQ9WipLKmx0LVkqcnQsanQ9SypZKmx0LVoqcnQsRnQ9WSpZKmx0K2F0LFd0PVoqWSpsdCtLKnJ0LCR0PUsqWipsdCtZKnJ0LFR0PVkqWipsdC1LKnJ0LHd0PVoqWipsdCthdCxkWzBdPWl0KkJ0K2d0Kkl0K3l0Kk50LGRbMV09bnQqQnQrdXQqSXQrcHQqTnQsZFsyXT1vdCpCdCttdCpJdCt4dCpOdCxkWzNdPWR0KkJ0K090Kkl0K010Kk50LGRbNF09aXQqanQrZ3QqRnQreXQqV3QsZFs1XT1udCpqdCt1dCpGdCtwdCpXdCxkWzZdPW90Kmp0K210KkZ0K3h0Kld0LGRbN109ZHQqanQrT3QqRnQrTXQqV3QsZFs4XT1pdCokdCtndCpUdCt5dCp3dCxkWzldPW50KiR0K3V0KlR0K3B0Knd0LGRbMTBdPW90KiR0K210KlR0K3h0Knd0LGRbMTFdPWR0KiR0K090KlR0K010Knd0LEUhPT1kJiYoZFsxMl09RVsxMl0sZFsxM109RVsxM10sZFsxNF09RVsxNF0sZFsxNV09RVsxNV0pLGQpfWZ1bmN0aW9uIG4oZCxFLE4pe3ZhciAkPU1hdGguc2luKE4pLEs9TWF0aC5jb3MoTiksWT1FWzRdLFo9RVs1XSxldD1FWzZdLHJ0PUVbN10sYXQ9RVs4XSxsdD1FWzldLGl0PUVbMTBdLG50PUVbMTFdO3JldHVybiBFIT09ZCYmKGRbMF09RVswXSxkWzFdPUVbMV0sZFsyXT1FWzJdLGRbM109RVszXSxkWzEyXT1FWzEyXSxkWzEzXT1FWzEzXSxkWzE0XT1FWzE0XSxkWzE1XT1FWzE1XSksZFs0XT1ZKksrYXQqJCxkWzVdPVoqSytsdCokLGRbNl09ZXQqSytpdCokLGRbN109cnQqSytudCokLGRbOF09YXQqSy1ZKiQsZFs5XT1sdCpLLVoqJCxkWzEwXT1pdCpLLWV0KiQsZFsxMV09bnQqSy1ydCokLGR9ZnVuY3Rpb24gYShkLEUsTil7dmFyICQ9TWF0aC5zaW4oTiksSz1NYXRoLmNvcyhOKSxZPUVbMF0sWj1FWzFdLGV0PUVbMl0scnQ9RVszXSxhdD1FWzhdLGx0PUVbOV0saXQ9RVsxMF0sbnQ9RVsxMV07cmV0dXJuIEUhPT1kJiYoZFs0XT1FWzRdLGRbNV09RVs1XSxkWzZdPUVbNl0sZFs3XT1FWzddLGRbMTJdPUVbMTJdLGRbMTNdPUVbMTNdLGRbMTRdPUVbMTRdLGRbMTVdPUVbMTVdKSxkWzBdPVkqSy1hdCokLGRbMV09WipLLWx0KiQsZFsyXT1ldCpLLWl0KiQsZFszXT1ydCpLLW50KiQsZFs4XT1ZKiQrYXQqSyxkWzldPVoqJCtsdCpLLGRbMTBdPWV0KiQraXQqSyxkWzExXT1ydCokK250KkssZH1mdW5jdGlvbiBpKGQsRSxOKXt2YXIgJD1NYXRoLnNpbihOKSxLPU1hdGguY29zKE4pLFk9RVswXSxaPUVbMV0sZXQ9RVsyXSxydD1FWzNdLGF0PUVbNF0sbHQ9RVs1XSxpdD1FWzZdLG50PUVbN107cmV0dXJuIEUhPT1kJiYoZFs4XT1FWzhdLGRbOV09RVs5XSxkWzEwXT1FWzEwXSxkWzExXT1FWzExXSxkWzEyXT1FWzEyXSxkWzEzXT1FWzEzXSxkWzE0XT1FWzE0XSxkWzE1XT1FWzE1XSksZFswXT1ZKksrYXQqJCxkWzFdPVoqSytsdCokLGRbMl09ZXQqSytpdCokLGRbM109cnQqSytudCokLGRbNF09YXQqSy1ZKiQsZFs1XT1sdCpLLVoqJCxkWzZdPWl0KkstZXQqJCxkWzddPW50KkstcnQqJCxkfWZ1bmN0aW9uIG8oZCxFKXtyZXR1cm4gZFswXT0xLGRbMV09MCxkWzJdPTAsZFszXT0wLGRbNF09MCxkWzVdPTEsZFs2XT0wLGRbN109MCxkWzhdPTAsZFs5XT0wLGRbMTBdPTEsZFsxMV09MCxkWzEyXT1FWzBdLGRbMTNdPUVbMV0sZFsxNF09RVsyXSxkWzE1XT0xLGR9ZnVuY3Rpb24gVChkLEUpe3JldHVybiBkWzBdPUVbMF0sZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09RVsxXSxkWzZdPTAsZFs3XT0wLGRbOF09MCxkWzldPTAsZFsxMF09RVsyXSxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wLGRbMTVdPTEsZH1mdW5jdGlvbiBBKGQsRSxOKXt2YXIgJD1OWzBdLEs9TlsxXSxZPU5bMl0sWj1NYXRoLmh5cG90KCQsSyxZKSxldCxydCxhdDtyZXR1cm4gWjxyLkVQU0lMT04/bnVsbDooWj0xL1osJCo9WixLKj1aLFkqPVosZXQ9TWF0aC5zaW4oRSkscnQ9TWF0aC5jb3MoRSksYXQ9MS1ydCxkWzBdPSQqJCphdCtydCxkWzFdPUsqJCphdCtZKmV0LGRbMl09WSokKmF0LUsqZXQsZFszXT0wLGRbNF09JCpLKmF0LVkqZXQsZFs1XT1LKksqYXQrcnQsZFs2XT1ZKksqYXQrJCpldCxkWzddPTAsZFs4XT0kKlkqYXQrSypldCxkWzldPUsqWSphdC0kKmV0LGRbMTBdPVkqWSphdCtydCxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wLGRbMTVdPTEsZCl9ZnVuY3Rpb24gQyhkLEUpe3ZhciBOPU1hdGguc2luKEUpLCQ9TWF0aC5jb3MoRSk7cmV0dXJuIGRbMF09MSxkWzFdPTAsZFsyXT0wLGRbM109MCxkWzRdPTAsZFs1XT0kLGRbNl09TixkWzddPTAsZFs4XT0wLGRbOV09LU4sZFsxMF09JCxkWzExXT0wLGRbMTJdPTAsZFsxM109MCxkWzE0XT0wLGRbMTVdPTEsZH1mdW5jdGlvbiBJKGQsRSl7dmFyIE49TWF0aC5zaW4oRSksJD1NYXRoLmNvcyhFKTtyZXR1cm4gZFswXT0kLGRbMV09MCxkWzJdPS1OLGRbM109MCxkWzRdPTAsZFs1XT0xLGRbNl09MCxkWzddPTAsZFs4XT1OLGRbOV09MCxkWzEwXT0kLGRbMTFdPTAsZFsxMl09MCxkWzEzXT0wLGRbMTRdPTAsZFsxNV09MSxkfWZ1bmN0aW9uIFAoZCxFKXt2YXIgTj1NYXRoLnNpbihFKSwkPU1hdGguY29zKEUpO3JldHVybiBkWzBdPSQsZFsxXT1OLGRbMl09MCxkWzNdPTAsZFs0XT0tTixkWzVdPSQsZFs2XT0wLGRbN109MCxkWzhdPTAsZFs5XT0wLGRbMTBdPTEsZFsxMV09MCxkWzEyXT0wLGRbMTNdPTAsZFsxNF09MCxkWzE1XT0xLGR9ZnVuY3Rpb24gTChkLEUsTil7dmFyICQ9RVswXSxLPUVbMV0sWT1FWzJdLFo9RVszXSxldD0kKyQscnQ9SytLLGF0PVkrWSxsdD0kKmV0LGl0PSQqcnQsbnQ9JCphdCxvdD1LKnJ0LGR0PUsqYXQsZ3Q9WSphdCx1dD1aKmV0LG10PVoqcnQsT3Q9WiphdDtyZXR1cm4gZFswXT0xLShvdCtndCksZFsxXT1pdCtPdCxkWzJdPW50LW10LGRbM109MCxkWzRdPWl0LU90LGRbNV09MS0obHQrZ3QpLGRbNl09ZHQrdXQsZFs3XT0wLGRbOF09bnQrbXQsZFs5XT1kdC11dCxkWzEwXT0xLShsdCtvdCksZFsxMV09MCxkWzEyXT1OWzBdLGRbMTNdPU5bMV0sZFsxNF09TlsyXSxkWzE1XT0xLGR9ZnVuY3Rpb24gRChkLEUpe3ZhciBOPW5ldyByLkFSUkFZX1RZUEUoMyksJD0tRVswXSxLPS1FWzFdLFk9LUVbMl0sWj1FWzNdLGV0PUVbNF0scnQ9RVs1XSxhdD1FWzZdLGx0PUVbN10saXQ9JCokK0sqSytZKlkrWipaO3JldHVybiBpdD4wPyhOWzBdPShldCpaK2x0KiQrcnQqWS1hdCpLKSoyL2l0LE5bMV09KHJ0KlorbHQqSythdCokLWV0KlkpKjIvaXQsTlsyXT0oYXQqWitsdCpZK2V0KkstcnQqJCkqMi9pdCk6KE5bMF09KGV0KlorbHQqJCtydCpZLWF0KkspKjIsTlsxXT0ocnQqWitsdCpLK2F0KiQtZXQqWSkqMixOWzJdPShhdCpaK2x0KlkrZXQqSy1ydCokKSoyKSxMKGQsRSxOKSxkfWZ1bmN0aW9uIGIoZCxFKXtyZXR1cm4gZFswXT1FWzEyXSxkWzFdPUVbMTNdLGRbMl09RVsxNF0sZH1mdW5jdGlvbiBTKGQsRSl7dmFyIE49RVswXSwkPUVbMV0sSz1FWzJdLFk9RVs0XSxaPUVbNV0sZXQ9RVs2XSxydD1FWzhdLGF0PUVbOV0sbHQ9RVsxMF07cmV0dXJuIGRbMF09TWF0aC5oeXBvdChOLCQsSyksZFsxXT1NYXRoLmh5cG90KFksWixldCksZFsyXT1NYXRoLmh5cG90KHJ0LGF0LGx0KSxkfWZ1bmN0aW9uIEIoZCxFKXt2YXIgTj1uZXcgci5BUlJBWV9UWVBFKDMpO1MoTixFKTt2YXIgJD0xL05bMF0sSz0xL05bMV0sWT0xL05bMl0sWj1FWzBdKiQsZXQ9RVsxXSpLLHJ0PUVbMl0qWSxhdD1FWzRdKiQsbHQ9RVs1XSpLLGl0PUVbNl0qWSxudD1FWzhdKiQsb3Q9RVs5XSpLLGR0PUVbMTBdKlksZ3Q9WitsdCtkdCx1dD0wO3JldHVybiBndD4wPyh1dD1NYXRoLnNxcnQoZ3QrMSkqMixkWzNdPS4yNSp1dCxkWzBdPShpdC1vdCkvdXQsZFsxXT0obnQtcnQpL3V0LGRbMl09KGV0LWF0KS91dCk6Wj5sdCYmWj5kdD8odXQ9TWF0aC5zcXJ0KDErWi1sdC1kdCkqMixkWzNdPShpdC1vdCkvdXQsZFswXT0uMjUqdXQsZFsxXT0oZXQrYXQpL3V0LGRbMl09KG50K3J0KS91dCk6bHQ+ZHQ/KHV0PU1hdGguc3FydCgxK2x0LVotZHQpKjIsZFszXT0obnQtcnQpL3V0LGRbMF09KGV0K2F0KS91dCxkWzFdPS4yNSp1dCxkWzJdPShpdCtvdCkvdXQpOih1dD1NYXRoLnNxcnQoMStkdC1aLWx0KSoyLGRbM109KGV0LWF0KS91dCxkWzBdPShudCtydCkvdXQsZFsxXT0oaXQrb3QpL3V0LGRbMl09LjI1KnV0KSxkfWZ1bmN0aW9uIHcoZCxFLE4sJCl7dmFyIEs9RVswXSxZPUVbMV0sWj1FWzJdLGV0PUVbM10scnQ9SytLLGF0PVkrWSxsdD1aK1osaXQ9SypydCxudD1LKmF0LG90PUsqbHQsZHQ9WSphdCxndD1ZKmx0LHV0PVoqbHQsbXQ9ZXQqcnQsT3Q9ZXQqYXQseXQ9ZXQqbHQscHQ9JFswXSx4dD0kWzFdLE10PSRbMl07cmV0dXJuIGRbMF09KDEtKGR0K3V0KSkqcHQsZFsxXT0obnQreXQpKnB0LGRbMl09KG90LU90KSpwdCxkWzNdPTAsZFs0XT0obnQteXQpKnh0LGRbNV09KDEtKGl0K3V0KSkqeHQsZFs2XT0oZ3QrbXQpKnh0LGRbN109MCxkWzhdPShvdCtPdCkqTXQsZFs5XT0oZ3QtbXQpKk10LGRbMTBdPSgxLShpdCtkdCkpKk10LGRbMTFdPTAsZFsxMl09TlswXSxkWzEzXT1OWzFdLGRbMTRdPU5bMl0sZFsxNV09MSxkfWZ1bmN0aW9uIEgoZCxFLE4sJCxLKXt2YXIgWT1FWzBdLFo9RVsxXSxldD1FWzJdLHJ0PUVbM10sYXQ9WStZLGx0PVorWixpdD1ldCtldCxudD1ZKmF0LG90PVkqbHQsZHQ9WSppdCxndD1aKmx0LHV0PVoqaXQsbXQ9ZXQqaXQsT3Q9cnQqYXQseXQ9cnQqbHQscHQ9cnQqaXQseHQ9JFswXSxNdD0kWzFdLEJ0PSRbMl0sSXQ9S1swXSxOdD1LWzFdLGp0PUtbMl0sRnQ9KDEtKGd0K210KSkqeHQsV3Q9KG90K3B0KSp4dCwkdD0oZHQteXQpKnh0LFR0PShvdC1wdCkqTXQsd3Q9KDEtKG50K210KSkqTXQsZmU9KHV0K090KSpNdCx1ZT0oZHQreXQpKkJ0LF9yPSh1dC1PdCkqQnQsdG49KDEtKG50K2d0KSkqQnQ7cmV0dXJuIGRbMF09RnQsZFsxXT1XdCxkWzJdPSR0LGRbM109MCxkWzRdPVR0LGRbNV09d3QsZFs2XT1mZSxkWzddPTAsZFs4XT11ZSxkWzldPV9yLGRbMTBdPXRuLGRbMTFdPTAsZFsxMl09TlswXStJdC0oRnQqSXQrVHQqTnQrdWUqanQpLGRbMTNdPU5bMV0rTnQtKFd0Kkl0K3d0Kk50K19yKmp0KSxkWzE0XT1OWzJdK2p0LSgkdCpJdCtmZSpOdCt0bipqdCksZFsxNV09MSxkfWZ1bmN0aW9uIEooZCxFKXt2YXIgTj1FWzBdLCQ9RVsxXSxLPUVbMl0sWT1FWzNdLFo9TitOLGV0PSQrJCxydD1LK0ssYXQ9TipaLGx0PSQqWixpdD0kKmV0LG50PUsqWixvdD1LKmV0LGR0PUsqcnQsZ3Q9WSpaLHV0PVkqZXQsbXQ9WSpydDtyZXR1cm4gZFswXT0xLWl0LWR0LGRbMV09bHQrbXQsZFsyXT1udC11dCxkWzNdPTAsZFs0XT1sdC1tdCxkWzVdPTEtYXQtZHQsZFs2XT1vdCtndCxkWzddPTAsZFs4XT1udCt1dCxkWzldPW90LWd0LGRbMTBdPTEtYXQtaXQsZFsxMV09MCxkWzEyXT0wLGRbMTNdPTAsZFsxNF09MCxkWzE1XT0xLGR9ZnVuY3Rpb24gcShkLEUsTiwkLEssWSxaKXt2YXIgZXQ9MS8oTi1FKSxydD0xLyhLLSQpLGF0PTEvKFktWik7cmV0dXJuIGRbMF09WSoyKmV0LGRbMV09MCxkWzJdPTAsZFszXT0wLGRbNF09MCxkWzVdPVkqMipydCxkWzZdPTAsZFs3XT0wLGRbOF09KE4rRSkqZXQsZFs5XT0oSyskKSpydCxkWzEwXT0oWitZKSphdCxkWzExXT0tMSxkWzEyXT0wLGRbMTNdPTAsZFsxNF09WipZKjIqYXQsZFsxNV09MCxkfWZ1bmN0aW9uIFcoZCxFLE4sJCxLKXt2YXIgWT0xL01hdGgudGFuKEUvMiksWjtyZXR1cm4gZFswXT1ZL04sZFsxXT0wLGRbMl09MCxkWzNdPTAsZFs0XT0wLGRbNV09WSxkWzZdPTAsZFs3XT0wLGRbOF09MCxkWzldPTAsZFsxMV09LTEsZFsxMl09MCxkWzEzXT0wLGRbMTVdPTAsSyE9bnVsbCYmSyE9PTEvMD8oWj0xLygkLUspLGRbMTBdPShLKyQpKlosZFsxNF09MipLKiQqWik6KGRbMTBdPS0xLGRbMTRdPS0yKiQpLGR9ZnVuY3Rpb24gRyhkLEUsTiwkKXt2YXIgSz1NYXRoLnRhbihFLnVwRGVncmVlcypNYXRoLlBJLzE4MCksWT1NYXRoLnRhbihFLmRvd25EZWdyZWVzKk1hdGguUEkvMTgwKSxaPU1hdGgudGFuKEUubGVmdERlZ3JlZXMqTWF0aC5QSS8xODApLGV0PU1hdGgudGFuKEUucmlnaHREZWdyZWVzKk1hdGguUEkvMTgwKSxydD0yLyhaK2V0KSxhdD0yLyhLK1kpO3JldHVybiBkWzBdPXJ0LGRbMV09MCxkWzJdPTAsZFszXT0wLGRbNF09MCxkWzVdPWF0LGRbNl09MCxkWzddPTAsZFs4XT0tKChaLWV0KSpydCouNSksZFs5XT0oSy1ZKSphdCouNSxkWzEwXT0kLyhOLSQpLGRbMTFdPS0xLGRbMTJdPTAsZFsxM109MCxkWzE0XT0kKk4vKE4tJCksZFsxNV09MCxkfWZ1bmN0aW9uIFEoZCxFLE4sJCxLLFksWil7dmFyIGV0PTEvKEUtTikscnQ9MS8oJC1LKSxhdD0xLyhZLVopO3JldHVybiBkWzBdPS0yKmV0LGRbMV09MCxkWzJdPTAsZFszXT0wLGRbNF09MCxkWzVdPS0yKnJ0LGRbNl09MCxkWzddPTAsZFs4XT0wLGRbOV09MCxkWzEwXT0yKmF0LGRbMTFdPTAsZFsxMl09KEUrTikqZXQsZFsxM109KEsrJCkqcnQsZFsxNF09KForWSkqYXQsZFsxNV09MSxkfWZ1bmN0aW9uIHR0KGQsRSxOLCQpe3ZhciBLLFksWixldCxydCxhdCxsdCxpdCxudCxvdCxkdD1FWzBdLGd0PUVbMV0sdXQ9RVsyXSxtdD0kWzBdLE90PSRbMV0seXQ9JFsyXSxwdD1OWzBdLHh0PU5bMV0sTXQ9TlsyXTtyZXR1cm4gTWF0aC5hYnMoZHQtcHQpPHIuRVBTSUxPTiYmTWF0aC5hYnMoZ3QteHQpPHIuRVBTSUxPTiYmTWF0aC5hYnModXQtTXQpPHIuRVBTSUxPTj91KGQpOihsdD1kdC1wdCxpdD1ndC14dCxudD11dC1NdCxvdD0xL01hdGguaHlwb3QobHQsaXQsbnQpLGx0Kj1vdCxpdCo9b3QsbnQqPW90LEs9T3QqbnQteXQqaXQsWT15dCpsdC1tdCpudCxaPW10Kml0LU90Kmx0LG90PU1hdGguaHlwb3QoSyxZLFopLG90PyhvdD0xL290LEsqPW90LFkqPW90LFoqPW90KTooSz0wLFk9MCxaPTApLGV0PWl0KlotbnQqWSxydD1udCpLLWx0KlosYXQ9bHQqWS1pdCpLLG90PU1hdGguaHlwb3QoZXQscnQsYXQpLG90PyhvdD0xL290LGV0Kj1vdCxydCo9b3QsYXQqPW90KTooZXQ9MCxydD0wLGF0PTApLGRbMF09SyxkWzFdPWV0LGRbMl09bHQsZFszXT0wLGRbNF09WSxkWzVdPXJ0LGRbNl09aXQsZFs3XT0wLGRbOF09WixkWzldPWF0LGRbMTBdPW50LGRbMTFdPTAsZFsxMl09LShLKmR0K1kqZ3QrWip1dCksZFsxM109LShldCpkdCtydCpndCthdCp1dCksZFsxNF09LShsdCpkdCtpdCpndCtudCp1dCksZFsxNV09MSxkKX1mdW5jdGlvbiBfKGQsRSxOLCQpe3ZhciBLPUVbMF0sWT1FWzFdLFo9RVsyXSxldD0kWzBdLHJ0PSRbMV0sYXQ9JFsyXSxsdD1LLU5bMF0saXQ9WS1OWzFdLG50PVotTlsyXSxvdD1sdCpsdCtpdCppdCtudCpudDtvdD4wJiYob3Q9MS9NYXRoLnNxcnQob3QpLGx0Kj1vdCxpdCo9b3QsbnQqPW90KTt2YXIgZHQ9cnQqbnQtYXQqaXQsZ3Q9YXQqbHQtZXQqbnQsdXQ9ZXQqaXQtcnQqbHQ7cmV0dXJuIG90PWR0KmR0K2d0Kmd0K3V0KnV0LG90PjAmJihvdD0xL01hdGguc3FydChvdCksZHQqPW90LGd0Kj1vdCx1dCo9b3QpLGRbMF09ZHQsZFsxXT1ndCxkWzJdPXV0LGRbM109MCxkWzRdPWl0KnV0LW50Kmd0LGRbNV09bnQqZHQtbHQqdXQsZFs2XT1sdCpndC1pdCpkdCxkWzddPTAsZFs4XT1sdCxkWzldPWl0LGRbMTBdPW50LGRbMTFdPTAsZFsxMl09SyxkWzEzXT1ZLGRbMTRdPVosZFsxNV09MSxkfWZ1bmN0aW9uIHN0KGQpe3JldHVybiJtYXQ0KCIrZFswXSsiLCAiK2RbMV0rIiwgIitkWzJdKyIsICIrZFszXSsiLCAiK2RbNF0rIiwgIitkWzVdKyIsICIrZFs2XSsiLCAiK2RbN10rIiwgIitkWzhdKyIsICIrZFs5XSsiLCAiK2RbMTBdKyIsICIrZFsxMV0rIiwgIitkWzEyXSsiLCAiK2RbMTNdKyIsICIrZFsxNF0rIiwgIitkWzE1XSsiKSJ9ZnVuY3Rpb24gayhkKXtyZXR1cm4gTWF0aC5oeXBvdChkWzBdLGRbMV0sZFsyXSxkWzNdLGRbNF0sZFs1XSxkWzZdLGRbN10sZFs4XSxkWzldLGRbMTBdLGRbMTFdLGRbMTJdLGRbMTNdLGRbMTRdLGRbMTVdKX1mdW5jdGlvbiBjdChkLEUsTil7cmV0dXJuIGRbMF09RVswXStOWzBdLGRbMV09RVsxXStOWzFdLGRbMl09RVsyXStOWzJdLGRbM109RVszXStOWzNdLGRbNF09RVs0XStOWzRdLGRbNV09RVs1XStOWzVdLGRbNl09RVs2XStOWzZdLGRbN109RVs3XStOWzddLGRbOF09RVs4XStOWzhdLGRbOV09RVs5XStOWzldLGRbMTBdPUVbMTBdK05bMTBdLGRbMTFdPUVbMTFdK05bMTFdLGRbMTJdPUVbMTJdK05bMTJdLGRbMTNdPUVbMTNdK05bMTNdLGRbMTRdPUVbMTRdK05bMTRdLGRbMTVdPUVbMTVdK05bMTVdLGR9ZnVuY3Rpb24gZnQoZCxFLE4pe3JldHVybiBkWzBdPUVbMF0tTlswXSxkWzFdPUVbMV0tTlsxXSxkWzJdPUVbMl0tTlsyXSxkWzNdPUVbM10tTlszXSxkWzRdPUVbNF0tTls0XSxkWzVdPUVbNV0tTls1XSxkWzZdPUVbNl0tTls2XSxkWzddPUVbN10tTls3XSxkWzhdPUVbOF0tTls4XSxkWzldPUVbOV0tTls5XSxkWzEwXT1FWzEwXS1OWzEwXSxkWzExXT1FWzExXS1OWzExXSxkWzEyXT1FWzEyXS1OWzEyXSxkWzEzXT1FWzEzXS1OWzEzXSxkWzE0XT1FWzE0XS1OWzE0XSxkWzE1XT1FWzE1XS1OWzE1XSxkfWZ1bmN0aW9uIFUoZCxFLE4pe3JldHVybiBkWzBdPUVbMF0qTixkWzFdPUVbMV0qTixkWzJdPUVbMl0qTixkWzNdPUVbM10qTixkWzRdPUVbNF0qTixkWzVdPUVbNV0qTixkWzZdPUVbNl0qTixkWzddPUVbN10qTixkWzhdPUVbOF0qTixkWzldPUVbOV0qTixkWzEwXT1FWzEwXSpOLGRbMTFdPUVbMTFdKk4sZFsxMl09RVsxMl0qTixkWzEzXT1FWzEzXSpOLGRbMTRdPUVbMTRdKk4sZFsxNV09RVsxNV0qTixkfWZ1bmN0aW9uIEYoZCxFLE4sJCl7cmV0dXJuIGRbMF09RVswXStOWzBdKiQsZFsxXT1FWzFdK05bMV0qJCxkWzJdPUVbMl0rTlsyXSokLGRbM109RVszXStOWzNdKiQsZFs0XT1FWzRdK05bNF0qJCxkWzVdPUVbNV0rTls1XSokLGRbNl09RVs2XStOWzZdKiQsZFs3XT1FWzddK05bN10qJCxkWzhdPUVbOF0rTls4XSokLGRbOV09RVs5XStOWzldKiQsZFsxMF09RVsxMF0rTlsxMF0qJCxkWzExXT1FWzExXStOWzExXSokLGRbMTJdPUVbMTJdK05bMTJdKiQsZFsxM109RVsxM10rTlsxM10qJCxkWzE0XT1FWzE0XStOWzE0XSokLGRbMTVdPUVbMTVdK05bMTVdKiQsZH1mdW5jdGlvbiBWKGQsRSl7cmV0dXJuIGRbMF09PT1FWzBdJiZkWzFdPT09RVsxXSYmZFsyXT09PUVbMl0mJmRbM109PT1FWzNdJiZkWzRdPT09RVs0XSYmZFs1XT09PUVbNV0mJmRbNl09PT1FWzZdJiZkWzddPT09RVs3XSYmZFs4XT09PUVbOF0mJmRbOV09PT1FWzldJiZkWzEwXT09PUVbMTBdJiZkWzExXT09PUVbMTFdJiZkWzEyXT09PUVbMTJdJiZkWzEzXT09PUVbMTNdJiZkWzE0XT09PUVbMTRdJiZkWzE1XT09PUVbMTVdfWZ1bmN0aW9uIFgoZCxFKXt2YXIgTj1kWzBdLCQ9ZFsxXSxLPWRbMl0sWT1kWzNdLFo9ZFs0XSxldD1kWzVdLHJ0PWRbNl0sYXQ9ZFs3XSxsdD1kWzhdLGl0PWRbOV0sbnQ9ZFsxMF0sb3Q9ZFsxMV0sZHQ9ZFsxMl0sZ3Q9ZFsxM10sdXQ9ZFsxNF0sbXQ9ZFsxNV0sT3Q9RVswXSx5dD1FWzFdLHB0PUVbMl0seHQ9RVszXSxNdD1FWzRdLEJ0PUVbNV0sSXQ9RVs2XSxOdD1FWzddLGp0PUVbOF0sRnQ9RVs5XSxXdD1FWzEwXSwkdD1FWzExXSxUdD1FWzEyXSx3dD1FWzEzXSxmZT1FWzE0XSx1ZT1FWzE1XTtyZXR1cm4gTWF0aC5hYnMoTi1PdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKE90KSkmJk1hdGguYWJzKCQteXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyh5dCkpJiZNYXRoLmFicyhLLXB0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSyksTWF0aC5hYnMocHQpKSYmTWF0aC5hYnMoWS14dCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFkpLE1hdGguYWJzKHh0KSkmJk1hdGguYWJzKFotTXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhaKSxNYXRoLmFicyhNdCkpJiZNYXRoLmFicyhldC1CdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGV0KSxNYXRoLmFicyhCdCkpJiZNYXRoLmFicyhydC1JdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHJ0KSxNYXRoLmFicyhJdCkpJiZNYXRoLmFicyhhdC1OdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGF0KSxNYXRoLmFicyhOdCkpJiZNYXRoLmFicyhsdC1qdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGx0KSxNYXRoLmFicyhqdCkpJiZNYXRoLmFicyhpdC1GdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGl0KSxNYXRoLmFicyhGdCkpJiZNYXRoLmFicyhudC1XdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG50KSxNYXRoLmFicyhXdCkpJiZNYXRoLmFicyhvdC0kdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG90KSxNYXRoLmFicygkdCkpJiZNYXRoLmFicyhkdC1UdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGR0KSxNYXRoLmFicyhUdCkpJiZNYXRoLmFicyhndC13dCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGd0KSxNYXRoLmFicyh3dCkpJiZNYXRoLmFicyh1dC1mZSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHV0KSxNYXRoLmFicyhmZSkpJiZNYXRoLmFicyhtdC11ZSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG10KSxNYXRoLmFicyh1ZSkpfXZhciBqPVIsej1mdH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsInNldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJnZXRBeGlzQW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZ2V0QW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiY2FsY3VsYXRlVyIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJleHAiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwibG4iLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwicG93IixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsInNsZXJwIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiY29uanVnYXRlIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImZyb21NYXQzIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImZyb21FdWxlciIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsInJvdGF0aW9uVG8iLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsInNxbGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gZnR9KSx0LmQoZSwic2V0QXhlcyIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pO3ZhciByPXQoMikscz10KDUpLG09dCg4KSx5PXQoOSk7ZnVuY3Rpb24gYygpe3ZhciBGPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoRlswXT0wLEZbMV09MCxGWzJdPTApLEZbM109MSxGfWZ1bmN0aW9uIGwoRil7cmV0dXJuIEZbMF09MCxGWzFdPTAsRlsyXT0wLEZbM109MSxGfWZ1bmN0aW9uIHUoRixWLFgpe1g9WCouNTt2YXIgaj1NYXRoLnNpbihYKTtyZXR1cm4gRlswXT1qKlZbMF0sRlsxXT1qKlZbMV0sRlsyXT1qKlZbMl0sRlszXT1NYXRoLmNvcyhYKSxGfWZ1bmN0aW9uIE0oRixWKXt2YXIgWD1NYXRoLmFjb3MoVlszXSkqMixqPU1hdGguc2luKFgvMik7cmV0dXJuIGo+ci5FUFNJTE9OPyhGWzBdPVZbMF0vaixGWzFdPVZbMV0vaixGWzJdPVZbMl0vaik6KEZbMF09MSxGWzFdPTAsRlsyXT0wKSxYfWZ1bmN0aW9uIGYoRixWKXt2YXIgWD1KKEYsVik7cmV0dXJuIE1hdGguYWNvcygyKlgqWC0xKX1mdW5jdGlvbiB2KEYsVixYKXt2YXIgaj1WWzBdLHo9VlsxXSxkPVZbMl0sRT1WWzNdLE49WFswXSwkPVhbMV0sSz1YWzJdLFk9WFszXTtyZXR1cm4gRlswXT1qKlkrRSpOK3oqSy1kKiQsRlsxXT16KlkrRSokK2QqTi1qKkssRlsyXT1kKlkrRSpLK2oqJC16Kk4sRlszXT1FKlktaipOLXoqJC1kKkssRn1mdW5jdGlvbiB4KEYsVixYKXtYKj0uNTt2YXIgaj1WWzBdLHo9VlsxXSxkPVZbMl0sRT1WWzNdLE49TWF0aC5zaW4oWCksJD1NYXRoLmNvcyhYKTtyZXR1cm4gRlswXT1qKiQrRSpOLEZbMV09eiokK2QqTixGWzJdPWQqJC16Kk4sRlszXT1FKiQtaipOLEZ9ZnVuY3Rpb24gUihGLFYsWCl7WCo9LjU7dmFyIGo9VlswXSx6PVZbMV0sZD1WWzJdLEU9VlszXSxOPU1hdGguc2luKFgpLCQ9TWF0aC5jb3MoWCk7cmV0dXJuIEZbMF09aiokLWQqTixGWzFdPXoqJCtFKk4sRlsyXT1kKiQraipOLEZbM109RSokLXoqTixGfWZ1bmN0aW9uIE8oRixWLFgpe1gqPS41O3ZhciBqPVZbMF0sej1WWzFdLGQ9VlsyXSxFPVZbM10sTj1NYXRoLnNpbihYKSwkPU1hdGguY29zKFgpO3JldHVybiBGWzBdPWoqJCt6Kk4sRlsxXT16KiQtaipOLEZbMl09ZCokK0UqTixGWzNdPUUqJC1kKk4sRn1mdW5jdGlvbiBnKEYsVil7dmFyIFg9VlswXSxqPVZbMV0sej1WWzJdO3JldHVybiBGWzBdPVgsRlsxXT1qLEZbMl09eixGWzNdPU1hdGguc3FydChNYXRoLmFicygxLVgqWC1qKmoteip6KSksRn1mdW5jdGlvbiBwKEYsVil7dmFyIFg9VlswXSxqPVZbMV0sej1WWzJdLGQ9VlszXSxFPU1hdGguc3FydChYKlgraipqK3oqeiksTj1NYXRoLmV4cChkKSwkPUU+MD9OKk1hdGguc2luKEUpL0U6MDtyZXR1cm4gRlswXT1YKiQsRlsxXT1qKiQsRlsyXT16KiQsRlszXT1OKk1hdGguY29zKEUpLEZ9ZnVuY3Rpb24gbihGLFYpe3ZhciBYPVZbMF0saj1WWzFdLHo9VlsyXSxkPVZbM10sRT1NYXRoLnNxcnQoWCpYK2oqait6KnopLE49RT4wP01hdGguYXRhbjIoRSxkKS9FOjA7cmV0dXJuIEZbMF09WCpOLEZbMV09aipOLEZbMl09eipOLEZbM109LjUqTWF0aC5sb2coWCpYK2oqait6KnorZCpkKSxGfWZ1bmN0aW9uIGEoRixWLFgpe3JldHVybiBuKEYsViksSChGLEYsWCkscChGLEYpLEZ9ZnVuY3Rpb24gaShGLFYsWCxqKXt2YXIgej1WWzBdLGQ9VlsxXSxFPVZbMl0sTj1WWzNdLCQ9WFswXSxLPVhbMV0sWT1YWzJdLFo9WFszXSxldCxydCxhdCxsdCxpdDtyZXR1cm4gcnQ9eiokK2QqSytFKlkrTipaLHJ0PDAmJihydD0tcnQsJD0tJCxLPS1LLFk9LVksWj0tWiksMS1ydD5yLkVQU0lMT04/KGV0PU1hdGguYWNvcyhydCksYXQ9TWF0aC5zaW4oZXQpLGx0PU1hdGguc2luKCgxLWopKmV0KS9hdCxpdD1NYXRoLnNpbihqKmV0KS9hdCk6KGx0PTEtaixpdD1qKSxGWzBdPWx0KnoraXQqJCxGWzFdPWx0KmQraXQqSyxGWzJdPWx0KkUraXQqWSxGWzNdPWx0Kk4raXQqWixGfWZ1bmN0aW9uIG8oRil7dmFyIFY9ci5SQU5ET00oKSxYPXIuUkFORE9NKCksaj1yLlJBTkRPTSgpLHo9TWF0aC5zcXJ0KDEtViksZD1NYXRoLnNxcnQoVik7cmV0dXJuIEZbMF09eipNYXRoLnNpbigyKk1hdGguUEkqWCksRlsxXT16Kk1hdGguY29zKDIqTWF0aC5QSSpYKSxGWzJdPWQqTWF0aC5zaW4oMipNYXRoLlBJKmopLEZbM109ZCpNYXRoLmNvcygyKk1hdGguUEkqaiksRn1mdW5jdGlvbiBUKEYsVil7dmFyIFg9VlswXSxqPVZbMV0sej1WWzJdLGQ9VlszXSxFPVgqWCtqKmoreip6K2QqZCxOPUU/MS9FOjA7cmV0dXJuIEZbMF09LVgqTixGWzFdPS1qKk4sRlsyXT0teipOLEZbM109ZCpOLEZ9ZnVuY3Rpb24gQShGLFYpe3JldHVybiBGWzBdPS1WWzBdLEZbMV09LVZbMV0sRlsyXT0tVlsyXSxGWzNdPVZbM10sRn1mdW5jdGlvbiBDKEYsVil7dmFyIFg9VlswXStWWzRdK1ZbOF0sajtpZihYPjApaj1NYXRoLnNxcnQoWCsxKSxGWzNdPS41Kmosaj0uNS9qLEZbMF09KFZbNV0tVls3XSkqaixGWzFdPShWWzZdLVZbMl0pKmosRlsyXT0oVlsxXS1WWzNdKSpqO2Vsc2V7dmFyIHo9MDtWWzRdPlZbMF0mJih6PTEpLFZbOF0+Vlt6KjMrel0mJih6PTIpO3ZhciBkPSh6KzEpJTMsRT0oeisyKSUzO2o9TWF0aC5zcXJ0KFZbeiozK3pdLVZbZCozK2RdLVZbRSozK0VdKzEpLEZbel09LjUqaixqPS41L2osRlszXT0oVltkKjMrRV0tVltFKjMrZF0pKmosRltkXT0oVltkKjMrel0rVlt6KjMrZF0pKmosRltFXT0oVltFKjMrel0rVlt6KjMrRV0pKmp9cmV0dXJuIEZ9ZnVuY3Rpb24gSShGLFYsWCxqKXt2YXIgej0uNSpNYXRoLlBJLzE4MDtWKj16LFgqPXosaio9ejt2YXIgZD1NYXRoLnNpbihWKSxFPU1hdGguY29zKFYpLE49TWF0aC5zaW4oWCksJD1NYXRoLmNvcyhYKSxLPU1hdGguc2luKGopLFk9TWF0aC5jb3Moaik7cmV0dXJuIEZbMF09ZCokKlktRSpOKkssRlsxXT1FKk4qWStkKiQqSyxGWzJdPUUqJCpLLWQqTipZLEZbM109RSokKlkrZCpOKkssRn1mdW5jdGlvbiBQKEYpe3JldHVybiJxdWF0KCIrRlswXSsiLCAiK0ZbMV0rIiwgIitGWzJdKyIsICIrRlszXSsiKSJ9dmFyIEw9eS5jbG9uZSxEPXkuZnJvbVZhbHVlcyxiPXkuY29weSxTPXkuc2V0LEI9eS5hZGQsdz12LEg9eS5zY2FsZSxKPXkuZG90LHE9eS5sZXJwLFc9eS5sZW5ndGgsRz1XLFE9eS5zcXVhcmVkTGVuZ3RoLHR0PVEsXz15Lm5vcm1hbGl6ZSxzdD15LmV4YWN0RXF1YWxzLGs9eS5lcXVhbHMsY3Q9ZnVuY3Rpb24oKXt2YXIgRj1tLmNyZWF0ZSgpLFY9bS5mcm9tVmFsdWVzKDEsMCwwKSxYPW0uZnJvbVZhbHVlcygwLDEsMCk7cmV0dXJuIGZ1bmN0aW9uKGoseixkKXt2YXIgRT1tLmRvdCh6LGQpO3JldHVybiBFPC0uOTk5OTk5PyhtLmNyb3NzKEYsVix6KSxtLmxlbihGKTwxZS02JiZtLmNyb3NzKEYsWCx6KSxtLm5vcm1hbGl6ZShGLEYpLHUoaixGLE1hdGguUEkpLGopOkU+Ljk5OTk5OT8oalswXT0wLGpbMV09MCxqWzJdPTAsalszXT0xLGopOihtLmNyb3NzKEYseixkKSxqWzBdPUZbMF0salsxXT1GWzFdLGpbMl09RlsyXSxqWzNdPTErRSxfKGosaikpfX0oKSxmdD1mdW5jdGlvbigpe3ZhciBGPWMoKSxWPWMoKTtyZXR1cm4gZnVuY3Rpb24oWCxqLHosZCxFLE4pe3JldHVybiBpKEYsaixFLE4pLGkoVix6LGQsTiksaShYLEYsViwyKk4qKDEtTikpLFh9fSgpLFU9ZnVuY3Rpb24oKXt2YXIgRj1zLmNyZWF0ZSgpO3JldHVybiBmdW5jdGlvbihWLFgsaix6KXtyZXR1cm4gRlswXT1qWzBdLEZbM109alsxXSxGWzZdPWpbMl0sRlsxXT16WzBdLEZbNF09elsxXSxGWzddPXpbMl0sRlsyXT0tWFswXSxGWzVdPS1YWzFdLEZbOF09LVhbMl0sXyhWLEMoVixGKSl9fSgpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gTH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsImhlcm1pdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiYmV6aWVyIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gd30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsInRyYW5zZm9ybU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwidHJhbnNmb3JtUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiB6fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIHMoKXt2YXIgRT1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKEVbMF09MCxFWzFdPTAsRVsyXT0wKSxFfWZ1bmN0aW9uIG0oRSl7dmFyIE49bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gTlswXT1FWzBdLE5bMV09RVsxXSxOWzJdPUVbMl0sTn1mdW5jdGlvbiB5KEUpe3ZhciBOPUVbMF0sJD1FWzFdLEs9RVsyXTtyZXR1cm4gTWF0aC5oeXBvdChOLCQsSyl9ZnVuY3Rpb24gYyhFLE4sJCl7dmFyIEs9bmV3IHIuQVJSQVlfVFlQRSgzKTtyZXR1cm4gS1swXT1FLEtbMV09TixLWzJdPSQsS31mdW5jdGlvbiBsKEUsTil7cmV0dXJuIEVbMF09TlswXSxFWzFdPU5bMV0sRVsyXT1OWzJdLEV9ZnVuY3Rpb24gdShFLE4sJCxLKXtyZXR1cm4gRVswXT1OLEVbMV09JCxFWzJdPUssRX1mdW5jdGlvbiBNKEUsTiwkKXtyZXR1cm4gRVswXT1OWzBdKyRbMF0sRVsxXT1OWzFdKyRbMV0sRVsyXT1OWzJdKyRbMl0sRX1mdW5jdGlvbiBmKEUsTiwkKXtyZXR1cm4gRVswXT1OWzBdLSRbMF0sRVsxXT1OWzFdLSRbMV0sRVsyXT1OWzJdLSRbMl0sRX1mdW5jdGlvbiB2KEUsTiwkKXtyZXR1cm4gRVswXT1OWzBdKiRbMF0sRVsxXT1OWzFdKiRbMV0sRVsyXT1OWzJdKiRbMl0sRX1mdW5jdGlvbiB4KEUsTiwkKXtyZXR1cm4gRVswXT1OWzBdLyRbMF0sRVsxXT1OWzFdLyRbMV0sRVsyXT1OWzJdLyRbMl0sRX1mdW5jdGlvbiBSKEUsTil7cmV0dXJuIEVbMF09TWF0aC5jZWlsKE5bMF0pLEVbMV09TWF0aC5jZWlsKE5bMV0pLEVbMl09TWF0aC5jZWlsKE5bMl0pLEV9ZnVuY3Rpb24gTyhFLE4pe3JldHVybiBFWzBdPU1hdGguZmxvb3IoTlswXSksRVsxXT1NYXRoLmZsb29yKE5bMV0pLEVbMl09TWF0aC5mbG9vcihOWzJdKSxFfWZ1bmN0aW9uIGcoRSxOLCQpe3JldHVybiBFWzBdPU1hdGgubWluKE5bMF0sJFswXSksRVsxXT1NYXRoLm1pbihOWzFdLCRbMV0pLEVbMl09TWF0aC5taW4oTlsyXSwkWzJdKSxFfWZ1bmN0aW9uIHAoRSxOLCQpe3JldHVybiBFWzBdPU1hdGgubWF4KE5bMF0sJFswXSksRVsxXT1NYXRoLm1heChOWzFdLCRbMV0pLEVbMl09TWF0aC5tYXgoTlsyXSwkWzJdKSxFfWZ1bmN0aW9uIG4oRSxOKXtyZXR1cm4gRVswXT1NYXRoLnJvdW5kKE5bMF0pLEVbMV09TWF0aC5yb3VuZChOWzFdKSxFWzJdPU1hdGgucm91bmQoTlsyXSksRX1mdW5jdGlvbiBhKEUsTiwkKXtyZXR1cm4gRVswXT1OWzBdKiQsRVsxXT1OWzFdKiQsRVsyXT1OWzJdKiQsRX1mdW5jdGlvbiBpKEUsTiwkLEspe3JldHVybiBFWzBdPU5bMF0rJFswXSpLLEVbMV09TlsxXSskWzFdKkssRVsyXT1OWzJdKyRbMl0qSyxFfWZ1bmN0aW9uIG8oRSxOKXt2YXIgJD1OWzBdLUVbMF0sSz1OWzFdLUVbMV0sWT1OWzJdLUVbMl07cmV0dXJuIE1hdGguaHlwb3QoJCxLLFkpfWZ1bmN0aW9uIFQoRSxOKXt2YXIgJD1OWzBdLUVbMF0sSz1OWzFdLUVbMV0sWT1OWzJdLUVbMl07cmV0dXJuICQqJCtLKksrWSpZfWZ1bmN0aW9uIEEoRSl7dmFyIE49RVswXSwkPUVbMV0sSz1FWzJdO3JldHVybiBOKk4rJCokK0sqS31mdW5jdGlvbiBDKEUsTil7cmV0dXJuIEVbMF09LU5bMF0sRVsxXT0tTlsxXSxFWzJdPS1OWzJdLEV9ZnVuY3Rpb24gSShFLE4pe3JldHVybiBFWzBdPTEvTlswXSxFWzFdPTEvTlsxXSxFWzJdPTEvTlsyXSxFfWZ1bmN0aW9uIFAoRSxOKXt2YXIgJD1OWzBdLEs9TlsxXSxZPU5bMl0sWj0kKiQrSypLK1kqWTtyZXR1cm4gWj4wJiYoWj0xL01hdGguc3FydChaKSksRVswXT1OWzBdKlosRVsxXT1OWzFdKlosRVsyXT1OWzJdKlosRX1mdW5jdGlvbiBMKEUsTil7cmV0dXJuIEVbMF0qTlswXStFWzFdKk5bMV0rRVsyXSpOWzJdfWZ1bmN0aW9uIEQoRSxOLCQpe3ZhciBLPU5bMF0sWT1OWzFdLFo9TlsyXSxldD0kWzBdLHJ0PSRbMV0sYXQ9JFsyXTtyZXR1cm4gRVswXT1ZKmF0LVoqcnQsRVsxXT1aKmV0LUsqYXQsRVsyXT1LKnJ0LVkqZXQsRX1mdW5jdGlvbiBiKEUsTiwkLEspe3ZhciBZPU5bMF0sWj1OWzFdLGV0PU5bMl07cmV0dXJuIEVbMF09WStLKigkWzBdLVkpLEVbMV09WitLKigkWzFdLVopLEVbMl09ZXQrSyooJFsyXS1ldCksRX1mdW5jdGlvbiBTKEUsTiwkLEssWSxaKXt2YXIgZXQ9WipaLHJ0PWV0KigyKlotMykrMSxhdD1ldCooWi0yKStaLGx0PWV0KihaLTEpLGl0PWV0KigzLTIqWik7cmV0dXJuIEVbMF09TlswXSpydCskWzBdKmF0K0tbMF0qbHQrWVswXSppdCxFWzFdPU5bMV0qcnQrJFsxXSphdCtLWzFdKmx0K1lbMV0qaXQsRVsyXT1OWzJdKnJ0KyRbMl0qYXQrS1syXSpsdCtZWzJdKml0LEV9ZnVuY3Rpb24gQihFLE4sJCxLLFksWil7dmFyIGV0PTEtWixydD1ldCpldCxhdD1aKlosbHQ9cnQqZXQsaXQ9MypaKnJ0LG50PTMqYXQqZXQsb3Q9YXQqWjtyZXR1cm4gRVswXT1OWzBdKmx0KyRbMF0qaXQrS1swXSpudCtZWzBdKm90LEVbMV09TlsxXSpsdCskWzFdKml0K0tbMV0qbnQrWVsxXSpvdCxFWzJdPU5bMl0qbHQrJFsyXSppdCtLWzJdKm50K1lbMl0qb3QsRX1mdW5jdGlvbiB3KEUsTil7Tj1OfHwxO3ZhciAkPXIuUkFORE9NKCkqMipNYXRoLlBJLEs9ci5SQU5ET00oKSoyLTEsWT1NYXRoLnNxcnQoMS1LKkspKk47cmV0dXJuIEVbMF09TWF0aC5jb3MoJCkqWSxFWzFdPU1hdGguc2luKCQpKlksRVsyXT1LKk4sRX1mdW5jdGlvbiBIKEUsTiwkKXt2YXIgSz1OWzBdLFk9TlsxXSxaPU5bMl0sZXQ9JFszXSpLKyRbN10qWSskWzExXSpaKyRbMTVdO3JldHVybiBldD1ldHx8MSxFWzBdPSgkWzBdKksrJFs0XSpZKyRbOF0qWiskWzEyXSkvZXQsRVsxXT0oJFsxXSpLKyRbNV0qWSskWzldKlorJFsxM10pL2V0LEVbMl09KCRbMl0qSyskWzZdKlkrJFsxMF0qWiskWzE0XSkvZXQsRX1mdW5jdGlvbiBKKEUsTiwkKXt2YXIgSz1OWzBdLFk9TlsxXSxaPU5bMl07cmV0dXJuIEVbMF09SyokWzBdK1kqJFszXStaKiRbNl0sRVsxXT1LKiRbMV0rWSokWzRdK1oqJFs3XSxFWzJdPUsqJFsyXStZKiRbNV0rWiokWzhdLEV9ZnVuY3Rpb24gcShFLE4sJCl7dmFyIEs9JFswXSxZPSRbMV0sWj0kWzJdLGV0PSRbM10scnQ9TlswXSxhdD1OWzFdLGx0PU5bMl0saXQ9WSpsdC1aKmF0LG50PVoqcnQtSypsdCxvdD1LKmF0LVkqcnQsZHQ9WSpvdC1aKm50LGd0PVoqaXQtSypvdCx1dD1LKm50LVkqaXQsbXQ9ZXQqMjtyZXR1cm4gaXQqPW10LG50Kj1tdCxvdCo9bXQsZHQqPTIsZ3QqPTIsdXQqPTIsRVswXT1ydCtpdCtkdCxFWzFdPWF0K250K2d0LEVbMl09bHQrb3QrdXQsRX1mdW5jdGlvbiBXKEUsTiwkLEspe3ZhciBZPVtdLFo9W107cmV0dXJuIFlbMF09TlswXS0kWzBdLFlbMV09TlsxXS0kWzFdLFlbMl09TlsyXS0kWzJdLFpbMF09WVswXSxaWzFdPVlbMV0qTWF0aC5jb3MoSyktWVsyXSpNYXRoLnNpbihLKSxaWzJdPVlbMV0qTWF0aC5zaW4oSykrWVsyXSpNYXRoLmNvcyhLKSxFWzBdPVpbMF0rJFswXSxFWzFdPVpbMV0rJFsxXSxFWzJdPVpbMl0rJFsyXSxFfWZ1bmN0aW9uIEcoRSxOLCQsSyl7dmFyIFk9W10sWj1bXTtyZXR1cm4gWVswXT1OWzBdLSRbMF0sWVsxXT1OWzFdLSRbMV0sWVsyXT1OWzJdLSRbMl0sWlswXT1ZWzJdKk1hdGguc2luKEspK1lbMF0qTWF0aC5jb3MoSyksWlsxXT1ZWzFdLFpbMl09WVsyXSpNYXRoLmNvcyhLKS1ZWzBdKk1hdGguc2luKEspLEVbMF09WlswXSskWzBdLEVbMV09WlsxXSskWzFdLEVbMl09WlsyXSskWzJdLEV9ZnVuY3Rpb24gUShFLE4sJCxLKXt2YXIgWT1bXSxaPVtdO3JldHVybiBZWzBdPU5bMF0tJFswXSxZWzFdPU5bMV0tJFsxXSxZWzJdPU5bMl0tJFsyXSxaWzBdPVlbMF0qTWF0aC5jb3MoSyktWVsxXSpNYXRoLnNpbihLKSxaWzFdPVlbMF0qTWF0aC5zaW4oSykrWVsxXSpNYXRoLmNvcyhLKSxaWzJdPVlbMl0sRVswXT1aWzBdKyRbMF0sRVsxXT1aWzFdKyRbMV0sRVsyXT1aWzJdKyRbMl0sRX1mdW5jdGlvbiB0dChFLE4pe3ZhciAkPUVbMF0sSz1FWzFdLFk9RVsyXSxaPU5bMF0sZXQ9TlsxXSxydD1OWzJdLGF0PU1hdGguc3FydCgkKiQrSypLK1kqWSksbHQ9TWF0aC5zcXJ0KFoqWitldCpldCtydCpydCksaXQ9YXQqbHQsbnQ9aXQmJkwoRSxOKS9pdDtyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KG50LC0xKSwxKSl9ZnVuY3Rpb24gXyhFKXtyZXR1cm4gRVswXT0wLEVbMV09MCxFWzJdPTAsRX1mdW5jdGlvbiBzdChFKXtyZXR1cm4idmVjMygiK0VbMF0rIiwgIitFWzFdKyIsICIrRVsyXSsiKSJ9ZnVuY3Rpb24gayhFLE4pe3JldHVybiBFWzBdPT09TlswXSYmRVsxXT09PU5bMV0mJkVbMl09PT1OWzJdfWZ1bmN0aW9uIGN0KEUsTil7dmFyICQ9RVswXSxLPUVbMV0sWT1FWzJdLFo9TlswXSxldD1OWzFdLHJ0PU5bMl07cmV0dXJuIE1hdGguYWJzKCQtWik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKCQpLE1hdGguYWJzKFopKSYmTWF0aC5hYnMoSy1ldCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEspLE1hdGguYWJzKGV0KSkmJk1hdGguYWJzKFktcnQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhZKSxNYXRoLmFicyhydCkpfXZhciBmdD1mLFU9dixGPXgsVj1vLFg9VCxqPXksej1BLGQ9ZnVuY3Rpb24oKXt2YXIgRT1zKCk7cmV0dXJuIGZ1bmN0aW9uKE4sJCxLLFksWixldCl7dmFyIHJ0LGF0O2ZvcigkfHwoJD0zKSxLfHwoSz0wKSxZP2F0PU1hdGgubWluKFkqJCtLLE4ubGVuZ3RoKTphdD1OLmxlbmd0aCxydD1LO3J0PGF0O3J0Kz0kKUVbMF09TltydF0sRVsxXT1OW3J0KzFdLEVbMl09TltydCsyXSxaKEUsRSxldCksTltydF09RVswXSxOW3J0KzFdPUVbMV0sTltydCsyXT1FWzJdO3JldHVybiBOfX0oKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwidHJhbnNmb3JtTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImRpdiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJsZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJmb3JFYWNoIixmdW5jdGlvbigpe3JldHVybiBmdH0pO3ZhciByPXQoMik7ZnVuY3Rpb24gcygpe3ZhciBVPW5ldyByLkFSUkFZX1RZUEUoNCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoVVswXT0wLFVbMV09MCxVWzJdPTAsVVszXT0wKSxVfWZ1bmN0aW9uIG0oVSl7dmFyIEY9bmV3IHIuQVJSQVlfVFlQRSg0KTtyZXR1cm4gRlswXT1VWzBdLEZbMV09VVsxXSxGWzJdPVVbMl0sRlszXT1VWzNdLEZ9ZnVuY3Rpb24geShVLEYsVixYKXt2YXIgaj1uZXcgci5BUlJBWV9UWVBFKDQpO3JldHVybiBqWzBdPVUsalsxXT1GLGpbMl09VixqWzNdPVgsan1mdW5jdGlvbiBjKFUsRil7cmV0dXJuIFVbMF09RlswXSxVWzFdPUZbMV0sVVsyXT1GWzJdLFVbM109RlszXSxVfWZ1bmN0aW9uIGwoVSxGLFYsWCxqKXtyZXR1cm4gVVswXT1GLFVbMV09VixVWzJdPVgsVVszXT1qLFV9ZnVuY3Rpb24gdShVLEYsVil7cmV0dXJuIFVbMF09RlswXStWWzBdLFVbMV09RlsxXStWWzFdLFVbMl09RlsyXStWWzJdLFVbM109RlszXStWWzNdLFV9ZnVuY3Rpb24gTShVLEYsVil7cmV0dXJuIFVbMF09RlswXS1WWzBdLFVbMV09RlsxXS1WWzFdLFVbMl09RlsyXS1WWzJdLFVbM109RlszXS1WWzNdLFV9ZnVuY3Rpb24gZihVLEYsVil7cmV0dXJuIFVbMF09RlswXSpWWzBdLFVbMV09RlsxXSpWWzFdLFVbMl09RlsyXSpWWzJdLFVbM109RlszXSpWWzNdLFV9ZnVuY3Rpb24gdihVLEYsVil7cmV0dXJuIFVbMF09RlswXS9WWzBdLFVbMV09RlsxXS9WWzFdLFVbMl09RlsyXS9WWzJdLFVbM109RlszXS9WWzNdLFV9ZnVuY3Rpb24geChVLEYpe3JldHVybiBVWzBdPU1hdGguY2VpbChGWzBdKSxVWzFdPU1hdGguY2VpbChGWzFdKSxVWzJdPU1hdGguY2VpbChGWzJdKSxVWzNdPU1hdGguY2VpbChGWzNdKSxVfWZ1bmN0aW9uIFIoVSxGKXtyZXR1cm4gVVswXT1NYXRoLmZsb29yKEZbMF0pLFVbMV09TWF0aC5mbG9vcihGWzFdKSxVWzJdPU1hdGguZmxvb3IoRlsyXSksVVszXT1NYXRoLmZsb29yKEZbM10pLFV9ZnVuY3Rpb24gTyhVLEYsVil7cmV0dXJuIFVbMF09TWF0aC5taW4oRlswXSxWWzBdKSxVWzFdPU1hdGgubWluKEZbMV0sVlsxXSksVVsyXT1NYXRoLm1pbihGWzJdLFZbMl0pLFVbM109TWF0aC5taW4oRlszXSxWWzNdKSxVfWZ1bmN0aW9uIGcoVSxGLFYpe3JldHVybiBVWzBdPU1hdGgubWF4KEZbMF0sVlswXSksVVsxXT1NYXRoLm1heChGWzFdLFZbMV0pLFVbMl09TWF0aC5tYXgoRlsyXSxWWzJdKSxVWzNdPU1hdGgubWF4KEZbM10sVlszXSksVX1mdW5jdGlvbiBwKFUsRil7cmV0dXJuIFVbMF09TWF0aC5yb3VuZChGWzBdKSxVWzFdPU1hdGgucm91bmQoRlsxXSksVVsyXT1NYXRoLnJvdW5kKEZbMl0pLFVbM109TWF0aC5yb3VuZChGWzNdKSxVfWZ1bmN0aW9uIG4oVSxGLFYpe3JldHVybiBVWzBdPUZbMF0qVixVWzFdPUZbMV0qVixVWzJdPUZbMl0qVixVWzNdPUZbM10qVixVfWZ1bmN0aW9uIGEoVSxGLFYsWCl7cmV0dXJuIFVbMF09RlswXStWWzBdKlgsVVsxXT1GWzFdK1ZbMV0qWCxVWzJdPUZbMl0rVlsyXSpYLFVbM109RlszXStWWzNdKlgsVX1mdW5jdGlvbiBpKFUsRil7dmFyIFY9RlswXS1VWzBdLFg9RlsxXS1VWzFdLGo9RlsyXS1VWzJdLHo9RlszXS1VWzNdO3JldHVybiBNYXRoLmh5cG90KFYsWCxqLHopfWZ1bmN0aW9uIG8oVSxGKXt2YXIgVj1GWzBdLVVbMF0sWD1GWzFdLVVbMV0saj1GWzJdLVVbMl0sej1GWzNdLVVbM107cmV0dXJuIFYqVitYKlgraipqK3oqen1mdW5jdGlvbiBUKFUpe3ZhciBGPVVbMF0sVj1VWzFdLFg9VVsyXSxqPVVbM107cmV0dXJuIE1hdGguaHlwb3QoRixWLFgsail9ZnVuY3Rpb24gQShVKXt2YXIgRj1VWzBdLFY9VVsxXSxYPVVbMl0saj1VWzNdO3JldHVybiBGKkYrVipWK1gqWCtqKmp9ZnVuY3Rpb24gQyhVLEYpe3JldHVybiBVWzBdPS1GWzBdLFVbMV09LUZbMV0sVVsyXT0tRlsyXSxVWzNdPS1GWzNdLFV9ZnVuY3Rpb24gSShVLEYpe3JldHVybiBVWzBdPTEvRlswXSxVWzFdPTEvRlsxXSxVWzJdPTEvRlsyXSxVWzNdPTEvRlszXSxVfWZ1bmN0aW9uIFAoVSxGKXt2YXIgVj1GWzBdLFg9RlsxXSxqPUZbMl0sej1GWzNdLGQ9VipWK1gqWCtqKmoreip6O3JldHVybiBkPjAmJihkPTEvTWF0aC5zcXJ0KGQpKSxVWzBdPVYqZCxVWzFdPVgqZCxVWzJdPWoqZCxVWzNdPXoqZCxVfWZ1bmN0aW9uIEwoVSxGKXtyZXR1cm4gVVswXSpGWzBdK1VbMV0qRlsxXStVWzJdKkZbMl0rVVszXSpGWzNdfWZ1bmN0aW9uIEQoVSxGLFYsWCl7dmFyIGo9VlswXSpYWzFdLVZbMV0qWFswXSx6PVZbMF0qWFsyXS1WWzJdKlhbMF0sZD1WWzBdKlhbM10tVlszXSpYWzBdLEU9VlsxXSpYWzJdLVZbMl0qWFsxXSxOPVZbMV0qWFszXS1WWzNdKlhbMV0sJD1WWzJdKlhbM10tVlszXSpYWzJdLEs9RlswXSxZPUZbMV0sWj1GWzJdLGV0PUZbM107cmV0dXJuIFVbMF09WSokLVoqTitldCpFLFVbMV09LShLKiQpK1oqZC1ldCp6LFVbMl09SypOLVkqZCtldCpqLFVbM109LShLKkUpK1kqei1aKmosVX1mdW5jdGlvbiBiKFUsRixWLFgpe3ZhciBqPUZbMF0sej1GWzFdLGQ9RlsyXSxFPUZbM107cmV0dXJuIFVbMF09aitYKihWWzBdLWopLFVbMV09eitYKihWWzFdLXopLFVbMl09ZCtYKihWWzJdLWQpLFVbM109RStYKihWWzNdLUUpLFV9ZnVuY3Rpb24gUyhVLEYpe0Y9Rnx8MTt2YXIgVixYLGoseixkLEU7ZG8gVj1yLlJBTkRPTSgpKjItMSxYPXIuUkFORE9NKCkqMi0xLGQ9VipWK1gqWDt3aGlsZShkPj0xKTtkbyBqPXIuUkFORE9NKCkqMi0xLHo9ci5SQU5ET00oKSoyLTEsRT1qKmoreip6O3doaWxlKEU+PTEpO3ZhciBOPU1hdGguc3FydCgoMS1kKS9FKTtyZXR1cm4gVVswXT1GKlYsVVsxXT1GKlgsVVsyXT1GKmoqTixVWzNdPUYqeipOLFV9ZnVuY3Rpb24gQihVLEYsVil7dmFyIFg9RlswXSxqPUZbMV0sej1GWzJdLGQ9RlszXTtyZXR1cm4gVVswXT1WWzBdKlgrVls0XSpqK1ZbOF0qeitWWzEyXSpkLFVbMV09VlsxXSpYK1ZbNV0qaitWWzldKnorVlsxM10qZCxVWzJdPVZbMl0qWCtWWzZdKmorVlsxMF0qeitWWzE0XSpkLFVbM109VlszXSpYK1ZbN10qaitWWzExXSp6K1ZbMTVdKmQsVX1mdW5jdGlvbiB3KFUsRixWKXt2YXIgWD1GWzBdLGo9RlsxXSx6PUZbMl0sZD1WWzBdLEU9VlsxXSxOPVZbMl0sJD1WWzNdLEs9JCpYK0Uqei1OKmosWT0kKmorTipYLWQqeixaPSQqeitkKmotRSpYLGV0PS1kKlgtRSpqLU4qejtyZXR1cm4gVVswXT1LKiQrZXQqLWQrWSotTi1aKi1FLFVbMV09WSokK2V0Ki1FK1oqLWQtSyotTixVWzJdPVoqJCtldCotTitLKi1FLVkqLWQsVVszXT1GWzNdLFV9ZnVuY3Rpb24gSChVKXtyZXR1cm4gVVswXT0wLFVbMV09MCxVWzJdPTAsVVszXT0wLFV9ZnVuY3Rpb24gSihVKXtyZXR1cm4idmVjNCgiK1VbMF0rIiwgIitVWzFdKyIsICIrVVsyXSsiLCAiK1VbM10rIikifWZ1bmN0aW9uIHEoVSxGKXtyZXR1cm4gVVswXT09PUZbMF0mJlVbMV09PT1GWzFdJiZVWzJdPT09RlsyXSYmVVszXT09PUZbM119ZnVuY3Rpb24gVyhVLEYpe3ZhciBWPVVbMF0sWD1VWzFdLGo9VVsyXSx6PVVbM10sZD1GWzBdLEU9RlsxXSxOPUZbMl0sJD1GWzNdO3JldHVybiBNYXRoLmFicyhWLWQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhWKSxNYXRoLmFicyhkKSkmJk1hdGguYWJzKFgtRSk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFgpLE1hdGguYWJzKEUpKSYmTWF0aC5hYnMoai1OKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaiksTWF0aC5hYnMoTikpJiZNYXRoLmFicyh6LSQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh6KSxNYXRoLmFicygkKSl9dmFyIEc9TSxRPWYsdHQ9dixfPWksc3Q9byxrPVQsY3Q9QSxmdD1mdW5jdGlvbigpe3ZhciBVPXMoKTtyZXR1cm4gZnVuY3Rpb24oRixWLFgsaix6LGQpe3ZhciBFLE47Zm9yKFZ8fChWPTQpLFh8fChYPTApLGo/Tj1NYXRoLm1pbihqKlYrWCxGLmxlbmd0aCk6Tj1GLmxlbmd0aCxFPVg7RTxOO0UrPVYpVVswXT1GW0VdLFVbMV09RltFKzFdLFVbMl09RltFKzJdLFVbM109RltFKzNdLHooVSxVLGQpLEZbRV09VVswXSxGW0UrMV09VVsxXSxGW0UrMl09VVsyXSxGW0UrM109VVszXTtyZXR1cm4gRn19KCl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZ2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJnZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsInNldFJlYWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwic2V0RHVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwicm90YXRlWCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJyb3RhdGVZIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInJvdGF0ZVoiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwicm90YXRlQnlRdWF0QXBwZW5kIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInJvdGF0ZUJ5UXVhdFByZXBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIEx9KSx0LmQoZSwicm90YXRlQXJvdW5kQXhpcyIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiB3fSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gZnR9KTt2YXIgcj10KDIpLHM9dCg3KSxtPXQoNik7ZnVuY3Rpb24geSgpe3ZhciBVPW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIHIuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoVVswXT0wLFVbMV09MCxVWzJdPTAsVVs0XT0wLFVbNV09MCxVWzZdPTAsVVs3XT0wKSxVWzNdPTEsVX1mdW5jdGlvbiBjKFUpe3ZhciBGPW5ldyByLkFSUkFZX1RZUEUoOCk7cmV0dXJuIEZbMF09VVswXSxGWzFdPVVbMV0sRlsyXT1VWzJdLEZbM109VVszXSxGWzRdPVVbNF0sRls1XT1VWzVdLEZbNl09VVs2XSxGWzddPVVbN10sRn1mdW5jdGlvbiBsKFUsRixWLFgsaix6LGQsRSl7dmFyIE49bmV3IHIuQVJSQVlfVFlQRSg4KTtyZXR1cm4gTlswXT1VLE5bMV09RixOWzJdPVYsTlszXT1YLE5bNF09aixOWzVdPXosTls2XT1kLE5bN109RSxOfWZ1bmN0aW9uIHUoVSxGLFYsWCxqLHosZCl7dmFyIEU9bmV3IHIuQVJSQVlfVFlQRSg4KTtFWzBdPVUsRVsxXT1GLEVbMl09VixFWzNdPVg7dmFyIE49aiouNSwkPXoqLjUsSz1kKi41O3JldHVybiBFWzRdPU4qWCskKlYtSypGLEVbNV09JCpYK0sqVS1OKlYsRVs2XT1LKlgrTipGLSQqVSxFWzddPS1OKlUtJCpGLUsqVixFfWZ1bmN0aW9uIE0oVSxGLFYpe3ZhciBYPVZbMF0qLjUsaj1WWzFdKi41LHo9VlsyXSouNSxkPUZbMF0sRT1GWzFdLE49RlsyXSwkPUZbM107cmV0dXJuIFVbMF09ZCxVWzFdPUUsVVsyXT1OLFVbM109JCxVWzRdPVgqJCtqKk4teipFLFVbNV09aiokK3oqZC1YKk4sVVs2XT16KiQrWCpFLWoqZCxVWzddPS1YKmQtaipFLXoqTixVfWZ1bmN0aW9uIGYoVSxGKXtyZXR1cm4gVVswXT0wLFVbMV09MCxVWzJdPTAsVVszXT0xLFVbNF09RlswXSouNSxVWzVdPUZbMV0qLjUsVVs2XT1GWzJdKi41LFVbN109MCxVfWZ1bmN0aW9uIHYoVSxGKXtyZXR1cm4gVVswXT1GWzBdLFVbMV09RlsxXSxVWzJdPUZbMl0sVVszXT1GWzNdLFVbNF09MCxVWzVdPTAsVVs2XT0wLFVbN109MCxVfWZ1bmN0aW9uIHgoVSxGKXt2YXIgVj1zLmNyZWF0ZSgpO20uZ2V0Um90YXRpb24oVixGKTt2YXIgWD1uZXcgci5BUlJBWV9UWVBFKDMpO3JldHVybiBtLmdldFRyYW5zbGF0aW9uKFgsRiksTShVLFYsWCksVX1mdW5jdGlvbiBSKFUsRil7cmV0dXJuIFVbMF09RlswXSxVWzFdPUZbMV0sVVsyXT1GWzJdLFVbM109RlszXSxVWzRdPUZbNF0sVVs1XT1GWzVdLFVbNl09Rls2XSxVWzddPUZbN10sVX1mdW5jdGlvbiBPKFUpe3JldHVybiBVWzBdPTAsVVsxXT0wLFVbMl09MCxVWzNdPTEsVVs0XT0wLFVbNV09MCxVWzZdPTAsVVs3XT0wLFV9ZnVuY3Rpb24gZyhVLEYsVixYLGoseixkLEUsTil7cmV0dXJuIFVbMF09RixVWzFdPVYsVVsyXT1YLFVbM109aixVWzRdPXosVVs1XT1kLFVbNl09RSxVWzddPU4sVX12YXIgcD1zLmNvcHk7ZnVuY3Rpb24gbihVLEYpe3JldHVybiBVWzBdPUZbNF0sVVsxXT1GWzVdLFVbMl09Rls2XSxVWzNdPUZbN10sVX12YXIgYT1zLmNvcHk7ZnVuY3Rpb24gaShVLEYpe3JldHVybiBVWzRdPUZbMF0sVVs1XT1GWzFdLFVbNl09RlsyXSxVWzddPUZbM10sVX1mdW5jdGlvbiBvKFUsRil7dmFyIFY9Rls0XSxYPUZbNV0saj1GWzZdLHo9Rls3XSxkPS1GWzBdLEU9LUZbMV0sTj0tRlsyXSwkPUZbM107cmV0dXJuIFVbMF09KFYqJCt6KmQrWCpOLWoqRSkqMixVWzFdPShYKiQreipFK2oqZC1WKk4pKjIsVVsyXT0oaiokK3oqTitWKkUtWCpkKSoyLFV9ZnVuY3Rpb24gVChVLEYsVil7dmFyIFg9RlswXSxqPUZbMV0sej1GWzJdLGQ9RlszXSxFPVZbMF0qLjUsTj1WWzFdKi41LCQ9VlsyXSouNSxLPUZbNF0sWT1GWzVdLFo9Rls2XSxldD1GWzddO3JldHVybiBVWzBdPVgsVVsxXT1qLFVbMl09eixVWzNdPWQsVVs0XT1kKkUraiokLXoqTitLLFVbNV09ZCpOK3oqRS1YKiQrWSxVWzZdPWQqJCtYKk4taipFK1osVVs3XT0tWCpFLWoqTi16KiQrZXQsVX1mdW5jdGlvbiBBKFUsRixWKXt2YXIgWD0tRlswXSxqPS1GWzFdLHo9LUZbMl0sZD1GWzNdLEU9Rls0XSxOPUZbNV0sJD1GWzZdLEs9Rls3XSxZPUUqZCtLKlgrTip6LSQqaixaPU4qZCtLKmorJCpYLUUqeixldD0kKmQrSyp6K0Uqai1OKlgscnQ9SypkLUUqWC1OKmotJCp6O3JldHVybiBzLnJvdGF0ZVgoVSxGLFYpLFg9VVswXSxqPVVbMV0sej1VWzJdLGQ9VVszXSxVWzRdPVkqZCtydCpYK1oqei1ldCpqLFVbNV09WipkK3J0KmorZXQqWC1ZKnosVVs2XT1ldCpkK3J0KnorWSpqLVoqWCxVWzddPXJ0KmQtWSpYLVoqai1ldCp6LFV9ZnVuY3Rpb24gQyhVLEYsVil7dmFyIFg9LUZbMF0saj0tRlsxXSx6PS1GWzJdLGQ9RlszXSxFPUZbNF0sTj1GWzVdLCQ9Rls2XSxLPUZbN10sWT1FKmQrSypYK04qei0kKmosWj1OKmQrSypqKyQqWC1FKnosZXQ9JCpkK0sqeitFKmotTipYLHJ0PUsqZC1FKlgtTipqLSQqejtyZXR1cm4gcy5yb3RhdGVZKFUsRixWKSxYPVVbMF0saj1VWzFdLHo9VVsyXSxkPVVbM10sVVs0XT1ZKmQrcnQqWCtaKnotZXQqaixVWzVdPVoqZCtydCpqK2V0KlgtWSp6LFVbNl09ZXQqZCtydCp6K1kqai1aKlgsVVs3XT1ydCpkLVkqWC1aKmotZXQqeixVfWZ1bmN0aW9uIEkoVSxGLFYpe3ZhciBYPS1GWzBdLGo9LUZbMV0sej0tRlsyXSxkPUZbM10sRT1GWzRdLE49Rls1XSwkPUZbNl0sSz1GWzddLFk9RSpkK0sqWCtOKnotJCpqLFo9TipkK0sqaiskKlgtRSp6LGV0PSQqZCtLKnorRSpqLU4qWCxydD1LKmQtRSpYLU4qai0kKno7cmV0dXJuIHMucm90YXRlWihVLEYsViksWD1VWzBdLGo9VVsxXSx6PVVbMl0sZD1VWzNdLFVbNF09WSpkK3J0KlgrWip6LWV0KmosVVs1XT1aKmQrcnQqaitldCpYLVkqeixVWzZdPWV0KmQrcnQqeitZKmotWipYLFVbN109cnQqZC1ZKlgtWipqLWV0KnosVX1mdW5jdGlvbiBQKFUsRixWKXt2YXIgWD1WWzBdLGo9VlsxXSx6PVZbMl0sZD1WWzNdLEU9RlswXSxOPUZbMV0sJD1GWzJdLEs9RlszXTtyZXR1cm4gVVswXT1FKmQrSypYK04qei0kKmosVVsxXT1OKmQrSypqKyQqWC1FKnosVVsyXT0kKmQrSyp6K0Uqai1OKlgsVVszXT1LKmQtRSpYLU4qai0kKnosRT1GWzRdLE49Rls1XSwkPUZbNl0sSz1GWzddLFVbNF09RSpkK0sqWCtOKnotJCpqLFVbNV09TipkK0sqaiskKlgtRSp6LFVbNl09JCpkK0sqeitFKmotTipYLFVbN109SypkLUUqWC1OKmotJCp6LFV9ZnVuY3Rpb24gTChVLEYsVil7dmFyIFg9RlswXSxqPUZbMV0sej1GWzJdLGQ9RlszXSxFPVZbMF0sTj1WWzFdLCQ9VlsyXSxLPVZbM107cmV0dXJuIFVbMF09WCpLK2QqRStqKiQteipOLFVbMV09aipLK2QqTit6KkUtWCokLFVbMl09eipLK2QqJCtYKk4taipFLFVbM109ZCpLLVgqRS1qKk4teiokLEU9Vls0XSxOPVZbNV0sJD1WWzZdLEs9Vls3XSxVWzRdPVgqSytkKkUraiokLXoqTixVWzVdPWoqSytkKk4reipFLVgqJCxVWzZdPXoqSytkKiQrWCpOLWoqRSxVWzddPWQqSy1YKkUtaipOLXoqJCxVfWZ1bmN0aW9uIEQoVSxGLFYsWCl7aWYoTWF0aC5hYnMoWCk8ci5FUFNJTE9OKXJldHVybiBSKFUsRik7dmFyIGo9TWF0aC5oeXBvdChWWzBdLFZbMV0sVlsyXSk7WD1YKi41O3ZhciB6PU1hdGguc2luKFgpLGQ9eipWWzBdL2osRT16KlZbMV0vaixOPXoqVlsyXS9qLCQ9TWF0aC5jb3MoWCksSz1GWzBdLFk9RlsxXSxaPUZbMl0sZXQ9RlszXTtVWzBdPUsqJCtldCpkK1kqTi1aKkUsVVsxXT1ZKiQrZXQqRStaKmQtSypOLFVbMl09WiokK2V0Kk4rSypFLVkqZCxVWzNdPWV0KiQtSypkLVkqRS1aKk47dmFyIHJ0PUZbNF0sYXQ9Rls1XSxsdD1GWzZdLGl0PUZbN107cmV0dXJuIFVbNF09cnQqJCtpdCpkK2F0Kk4tbHQqRSxVWzVdPWF0KiQraXQqRStsdCpkLXJ0Kk4sVVs2XT1sdCokK2l0Kk4rcnQqRS1hdCpkLFVbN109aXQqJC1ydCpkLWF0KkUtbHQqTixVfWZ1bmN0aW9uIGIoVSxGLFYpe3JldHVybiBVWzBdPUZbMF0rVlswXSxVWzFdPUZbMV0rVlsxXSxVWzJdPUZbMl0rVlsyXSxVWzNdPUZbM10rVlszXSxVWzRdPUZbNF0rVls0XSxVWzVdPUZbNV0rVls1XSxVWzZdPUZbNl0rVls2XSxVWzddPUZbN10rVls3XSxVfWZ1bmN0aW9uIFMoVSxGLFYpe3ZhciBYPUZbMF0saj1GWzFdLHo9RlsyXSxkPUZbM10sRT1WWzRdLE49Vls1XSwkPVZbNl0sSz1WWzddLFk9Rls0XSxaPUZbNV0sZXQ9Rls2XSxydD1GWzddLGF0PVZbMF0sbHQ9VlsxXSxpdD1WWzJdLG50PVZbM107cmV0dXJuIFVbMF09WCpudCtkKmF0K2oqaXQteipsdCxVWzFdPWoqbnQrZCpsdCt6KmF0LVgqaXQsVVsyXT16Km50K2QqaXQrWCpsdC1qKmF0LFVbM109ZCpudC1YKmF0LWoqbHQteippdCxVWzRdPVgqSytkKkUraiokLXoqTitZKm50K3J0KmF0K1oqaXQtZXQqbHQsVVs1XT1qKksrZCpOK3oqRS1YKiQrWipudCtydCpsdCtldCphdC1ZKml0LFVbNl09eipLK2QqJCtYKk4taipFK2V0Km50K3J0Kml0K1kqbHQtWiphdCxVWzddPWQqSy1YKkUtaipOLXoqJCtydCpudC1ZKmF0LVoqbHQtZXQqaXQsVX12YXIgQj1TO2Z1bmN0aW9uIHcoVSxGLFYpe3JldHVybiBVWzBdPUZbMF0qVixVWzFdPUZbMV0qVixVWzJdPUZbMl0qVixVWzNdPUZbM10qVixVWzRdPUZbNF0qVixVWzVdPUZbNV0qVixVWzZdPUZbNl0qVixVWzddPUZbN10qVixVfXZhciBIPXMuZG90O2Z1bmN0aW9uIEooVSxGLFYsWCl7dmFyIGo9MS1YO3JldHVybiBIKEYsVik8MCYmKFg9LVgpLFVbMF09RlswXSpqK1ZbMF0qWCxVWzFdPUZbMV0qaitWWzFdKlgsVVsyXT1GWzJdKmorVlsyXSpYLFVbM109RlszXSpqK1ZbM10qWCxVWzRdPUZbNF0qaitWWzRdKlgsVVs1XT1GWzVdKmorVls1XSpYLFVbNl09Rls2XSpqK1ZbNl0qWCxVWzddPUZbN10qaitWWzddKlgsVX1mdW5jdGlvbiBxKFUsRil7dmFyIFY9dHQoRik7cmV0dXJuIFVbMF09LUZbMF0vVixVWzFdPS1GWzFdL1YsVVsyXT0tRlsyXS9WLFVbM109RlszXS9WLFVbNF09LUZbNF0vVixVWzVdPS1GWzVdL1YsVVs2XT0tRls2XS9WLFVbN109Rls3XS9WLFV9ZnVuY3Rpb24gVyhVLEYpe3JldHVybiBVWzBdPS1GWzBdLFVbMV09LUZbMV0sVVsyXT0tRlsyXSxVWzNdPUZbM10sVVs0XT0tRls0XSxVWzVdPS1GWzVdLFVbNl09LUZbNl0sVVs3XT1GWzddLFV9dmFyIEc9cy5sZW5ndGgsUT1HLHR0PXMuc3F1YXJlZExlbmd0aCxfPXR0O2Z1bmN0aW9uIHN0KFUsRil7dmFyIFY9dHQoRik7aWYoVj4wKXtWPU1hdGguc3FydChWKTt2YXIgWD1GWzBdL1Ysaj1GWzFdL1Ysej1GWzJdL1YsZD1GWzNdL1YsRT1GWzRdLE49Rls1XSwkPUZbNl0sSz1GWzddLFk9WCpFK2oqTit6KiQrZCpLO1VbMF09WCxVWzFdPWosVVsyXT16LFVbM109ZCxVWzRdPShFLVgqWSkvVixVWzVdPShOLWoqWSkvVixVWzZdPSgkLXoqWSkvVixVWzddPShLLWQqWSkvVn1yZXR1cm4gVX1mdW5jdGlvbiBrKFUpe3JldHVybiJxdWF0MigiK1VbMF0rIiwgIitVWzFdKyIsICIrVVsyXSsiLCAiK1VbM10rIiwgIitVWzRdKyIsICIrVVs1XSsiLCAiK1VbNl0rIiwgIitVWzddKyIpIn1mdW5jdGlvbiBjdChVLEYpe3JldHVybiBVWzBdPT09RlswXSYmVVsxXT09PUZbMV0mJlVbMl09PT1GWzJdJiZVWzNdPT09RlszXSYmVVs0XT09PUZbNF0mJlVbNV09PT1GWzVdJiZVWzZdPT09Rls2XSYmVVs3XT09PUZbN119ZnVuY3Rpb24gZnQoVSxGKXt2YXIgVj1VWzBdLFg9VVsxXSxqPVVbMl0sej1VWzNdLGQ9VVs0XSxFPVVbNV0sTj1VWzZdLCQ9VVs3XSxLPUZbMF0sWT1GWzFdLFo9RlsyXSxldD1GWzNdLHJ0PUZbNF0sYXQ9Rls1XSxsdD1GWzZdLGl0PUZbN107cmV0dXJuIE1hdGguYWJzKFYtSyk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFYpLE1hdGguYWJzKEspKSYmTWF0aC5hYnMoWC1ZKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMoWSkpJiZNYXRoLmFicyhqLVopPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhqKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKHotZXQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh6KSxNYXRoLmFicyhldCkpJiZNYXRoLmFicyhkLXJ0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZCksTWF0aC5hYnMocnQpKSYmTWF0aC5hYnMoRS1hdCk8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEUpLE1hdGguYWJzKGF0KSkmJk1hdGguYWJzKE4tbHQpPD1yLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhOKSxNYXRoLmFicyhsdCkpJiZNYXRoLmFicygkLWl0KTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoJCksTWF0aC5hYnMoaXQpKX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJkaXZpZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiY2VpbCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJmbG9vciIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJtaW4iLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwibWF4IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInJvdW5kIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsInNxdWFyZWREaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBMfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInRyYW5zZm9ybU1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwidHJhbnNmb3JtTWF0MmQiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcX0pLHQuZChlLCJhbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBHfSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwic3FyTGVuIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KTt2YXIgcj10KDIpO2Z1bmN0aW9uIHMoKXt2YXIgaj1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiByLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKGpbMF09MCxqWzFdPTApLGp9ZnVuY3Rpb24gbShqKXt2YXIgej1uZXcgci5BUlJBWV9UWVBFKDIpO3JldHVybiB6WzBdPWpbMF0selsxXT1qWzFdLHp9ZnVuY3Rpb24geShqLHope3ZhciBkPW5ldyByLkFSUkFZX1RZUEUoMik7cmV0dXJuIGRbMF09aixkWzFdPXosZH1mdW5jdGlvbiBjKGoseil7cmV0dXJuIGpbMF09elswXSxqWzFdPXpbMV0san1mdW5jdGlvbiBsKGoseixkKXtyZXR1cm4galswXT16LGpbMV09ZCxqfWZ1bmN0aW9uIHUoaix6LGQpe3JldHVybiBqWzBdPXpbMF0rZFswXSxqWzFdPXpbMV0rZFsxXSxqfWZ1bmN0aW9uIE0oaix6LGQpe3JldHVybiBqWzBdPXpbMF0tZFswXSxqWzFdPXpbMV0tZFsxXSxqfWZ1bmN0aW9uIGYoaix6LGQpe3JldHVybiBqWzBdPXpbMF0qZFswXSxqWzFdPXpbMV0qZFsxXSxqfWZ1bmN0aW9uIHYoaix6LGQpe3JldHVybiBqWzBdPXpbMF0vZFswXSxqWzFdPXpbMV0vZFsxXSxqfWZ1bmN0aW9uIHgoaix6KXtyZXR1cm4galswXT1NYXRoLmNlaWwoelswXSksalsxXT1NYXRoLmNlaWwoelsxXSksan1mdW5jdGlvbiBSKGoseil7cmV0dXJuIGpbMF09TWF0aC5mbG9vcih6WzBdKSxqWzFdPU1hdGguZmxvb3IoelsxXSksan1mdW5jdGlvbiBPKGoseixkKXtyZXR1cm4galswXT1NYXRoLm1pbih6WzBdLGRbMF0pLGpbMV09TWF0aC5taW4oelsxXSxkWzFdKSxqfWZ1bmN0aW9uIGcoaix6LGQpe3JldHVybiBqWzBdPU1hdGgubWF4KHpbMF0sZFswXSksalsxXT1NYXRoLm1heCh6WzFdLGRbMV0pLGp9ZnVuY3Rpb24gcChqLHope3JldHVybiBqWzBdPU1hdGgucm91bmQoelswXSksalsxXT1NYXRoLnJvdW5kKHpbMV0pLGp9ZnVuY3Rpb24gbihqLHosZCl7cmV0dXJuIGpbMF09elswXSpkLGpbMV09elsxXSpkLGp9ZnVuY3Rpb24gYShqLHosZCxFKXtyZXR1cm4galswXT16WzBdK2RbMF0qRSxqWzFdPXpbMV0rZFsxXSpFLGp9ZnVuY3Rpb24gaShqLHope3ZhciBkPXpbMF0talswXSxFPXpbMV0talsxXTtyZXR1cm4gTWF0aC5oeXBvdChkLEUpfWZ1bmN0aW9uIG8oaix6KXt2YXIgZD16WzBdLWpbMF0sRT16WzFdLWpbMV07cmV0dXJuIGQqZCtFKkV9ZnVuY3Rpb24gVChqKXt2YXIgej1qWzBdLGQ9alsxXTtyZXR1cm4gTWF0aC5oeXBvdCh6LGQpfWZ1bmN0aW9uIEEoail7dmFyIHo9alswXSxkPWpbMV07cmV0dXJuIHoqeitkKmR9ZnVuY3Rpb24gQyhqLHope3JldHVybiBqWzBdPS16WzBdLGpbMV09LXpbMV0san1mdW5jdGlvbiBJKGoseil7cmV0dXJuIGpbMF09MS96WzBdLGpbMV09MS96WzFdLGp9ZnVuY3Rpb24gUChqLHope3ZhciBkPXpbMF0sRT16WzFdLE49ZCpkK0UqRTtyZXR1cm4gTj4wJiYoTj0xL01hdGguc3FydChOKSksalswXT16WzBdKk4salsxXT16WzFdKk4san1mdW5jdGlvbiBMKGoseil7cmV0dXJuIGpbMF0qelswXStqWzFdKnpbMV19ZnVuY3Rpb24gRChqLHosZCl7dmFyIEU9elswXSpkWzFdLXpbMV0qZFswXTtyZXR1cm4galswXT1qWzFdPTAsalsyXT1FLGp9ZnVuY3Rpb24gYihqLHosZCxFKXt2YXIgTj16WzBdLCQ9elsxXTtyZXR1cm4galswXT1OK0UqKGRbMF0tTiksalsxXT0kK0UqKGRbMV0tJCksan1mdW5jdGlvbiBTKGoseil7ej16fHwxO3ZhciBkPXIuUkFORE9NKCkqMipNYXRoLlBJO3JldHVybiBqWzBdPU1hdGguY29zKGQpKnosalsxXT1NYXRoLnNpbihkKSp6LGp9ZnVuY3Rpb24gQihqLHosZCl7dmFyIEU9elswXSxOPXpbMV07cmV0dXJuIGpbMF09ZFswXSpFK2RbMl0qTixqWzFdPWRbMV0qRStkWzNdKk4san1mdW5jdGlvbiB3KGoseixkKXt2YXIgRT16WzBdLE49elsxXTtyZXR1cm4galswXT1kWzBdKkUrZFsyXSpOK2RbNF0salsxXT1kWzFdKkUrZFszXSpOK2RbNV0san1mdW5jdGlvbiBIKGoseixkKXt2YXIgRT16WzBdLE49elsxXTtyZXR1cm4galswXT1kWzBdKkUrZFszXSpOK2RbNl0salsxXT1kWzFdKkUrZFs0XSpOK2RbN10san1mdW5jdGlvbiBKKGoseixkKXt2YXIgRT16WzBdLE49elsxXTtyZXR1cm4galswXT1kWzBdKkUrZFs0XSpOK2RbMTJdLGpbMV09ZFsxXSpFK2RbNV0qTitkWzEzXSxqfWZ1bmN0aW9uIHEoaix6LGQsRSl7dmFyIE49elswXS1kWzBdLCQ9elsxXS1kWzFdLEs9TWF0aC5zaW4oRSksWT1NYXRoLmNvcyhFKTtyZXR1cm4galswXT1OKlktJCpLK2RbMF0salsxXT1OKksrJCpZK2RbMV0san1mdW5jdGlvbiBXKGoseil7dmFyIGQ9alswXSxFPWpbMV0sTj16WzBdLCQ9elsxXSxLPU1hdGguc3FydChkKmQrRSpFKSpNYXRoLnNxcnQoTipOKyQqJCksWT1LJiYoZCpOK0UqJCkvSztyZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KFksLTEpLDEpKX1mdW5jdGlvbiBHKGope3JldHVybiBqWzBdPTAsalsxXT0wLGp9ZnVuY3Rpb24gUShqKXtyZXR1cm4idmVjMigiK2pbMF0rIiwgIitqWzFdKyIpIn1mdW5jdGlvbiB0dChqLHope3JldHVybiBqWzBdPT09elswXSYmalsxXT09PXpbMV19ZnVuY3Rpb24gXyhqLHope3ZhciBkPWpbMF0sRT1qWzFdLE49elswXSwkPXpbMV07cmV0dXJuIE1hdGguYWJzKGQtTik8PXIuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGQpLE1hdGguYWJzKE4pKSYmTWF0aC5hYnMoRS0kKTw9ci5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoRSksTWF0aC5hYnMoJCkpfXZhciBzdD1ULGs9TSxjdD1mLGZ0PXYsVT1pLEY9byxWPUEsWD1mdW5jdGlvbigpe3ZhciBqPXMoKTtyZXR1cm4gZnVuY3Rpb24oeixkLEUsTiwkLEspe3ZhciBZLFo7Zm9yKGR8fChkPTIpLEV8fChFPTApLE4/Wj1NYXRoLm1pbihOKmQrRSx6Lmxlbmd0aCk6Wj16Lmxlbmd0aCxZPUU7WTxaO1krPWQpalswXT16W1ldLGpbMV09eltZKzFdLCQoaixqLEspLHpbWV09alswXSx6W1krMV09alsxXTtyZXR1cm4gen19KCl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMyk7dC5kKGUsIlJlbmRlcmVyIixmdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHR9KTt2YXIgcz10KDQwKTt0LmQoZSwiRmlndXJlMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdH0pO3ZhciBtPXQoNTYpO3QuZChlLCJNZXNoMkQiLGZ1bmN0aW9uKCl7cmV0dXJuIG0uZGVmYXVsdH0pO3ZhciB5PXQoMjkpO3QuZChlLCJNZXNoQ2xvdWQiLGZ1bmN0aW9uKCl7cmV0dXJuIHkuZGVmYXVsdH0pO3ZhciBjPXQoMjMpO3QuZChlLCJwYXJzZUZvbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pO3ZhciBsPXQoMzEpO3QuZChlLCJwYXJzZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBsLmRlZmF1bHR9KTt2YXIgdT10KDIxKTt0LmQoZSwiRU5WIixmdW5jdGlvbigpe3JldHVybiB1LmRlZmF1bHR9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KTt2YXIgcj10KDE0KSxzPXQoMSksbT10KDIwKSx5PXQoMjcpLGM9dCgyNSksbD10KDQwKSx1PXQoNTYpLE09dCgyOSksZj10KDU5KSx2PXQoMjEpLHg9dCg2Myk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFI9e2F1dG9VcGRhdGU6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGJ1ZmZlclNpemU6MTUwMH0sTz1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOyAgICAKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7ICAgICAgICAgICAgICAKfQpgLGc9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOwp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdlRleHR1cmVDb29yZC54eSk7Cn0KYCxwPVN5bWJvbCgiZ2xSZW5kZXJlciIpLG49U3ltYm9sKCJjYW52YXNSZW5kZXJlciIpLGE9U3ltYm9sKCJvcHRpb25zIiksaT1TeW1ib2woImdsb2JhbFRyYW5zZm9ybSIpLG89U3ltYm9sKCJhcHBseUdsb2JhbFRyYW5zZm9ybSIpLFQ9U3ltYm9sKCJjYW52YXMiKTtmdW5jdGlvbiBBKFApe2NvbnN0IEw9UC5nbCxEPVAuZmJvO0QmJkwuYmluZEZyYW1lYnVmZmVyKEwuRlJBTUVCVUZGRVIsRCksUC5fZHJhdygpLEQmJkwuYmluZEZyYW1lYnVmZmVyKEwuRlJBTUVCVUZGRVIsbnVsbCl9ZnVuY3Rpb24gQyhQLEwsRCxiKXtjb25zdCBTPVAuY3JlYXRlVGV4dHVyZShMLmNhbnZhcyksQj1bW1swLDBdLFtELDBdLFtELGJdLFswLGJdLFswLDBdXV07Qi5jbG9zZWQ9ITA7Y29uc3Qgdz1uZXcgdS5kZWZhdWx0KHtjb250b3VyczpCfSk7dy5zZXRUZXh0dXJlKFMpLFAuc2V0TWVzaERhdGEoW3cubWVzaERhdGFdKSxBKFApLFMuZGVsZXRlKCksTC5jbGVhclJlY3QoMCwwLEQsYiksZGVsZXRlIEwuX2ZpbHRlcn1jbGFzcyBJe2NvbnN0cnVjdG9yKEwsRD17fSl7bGV0IGI9RC5jb250ZXh0VHlwZTtpZihifHwodHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Yj0id2ViZ2wyIjp0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0PT0iZnVuY3Rpb24iP2I9IndlYmdsIjpiPSIyZCIpLCFMLmdldENvbnRleHQpe2NvbnN0IFM9TDtMPXtnZXRDb250ZXh0KCl7cmV0dXJuIFN9LHdpZHRoOkQud2lkdGgsaGVpZ2h0OkQuaGVpZ2h0fSxTLmNhbnZhcz1MLGI9IjJkIn1pZih0aGlzW1RdPUwsYiE9PSJ3ZWJnbCImJmIhPT0id2ViZ2wyIiYmYiE9PSIyZCIpdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbnRleHQgdHlwZSAke2J9YCk7aWYoRC5jb250ZXh0VHlwZT1iLHRoaXNbYV09T2JqZWN0LmFzc2lnbih7fSxSLEQpLGI9PT0id2ViZ2wifHxiPT09IndlYmdsMiIpe2I9PT0id2ViZ2wyIiYmKHRoaXNbYV0ud2ViZ2wyPSEwKTtjb25zdCBTPW5ldyByLmRlZmF1bHQoTCx0aGlzW2FdKTtiPT09IndlYmdsMiImJiFTLmlzV2ViR0wyJiYoRC5jb250ZXh0VHlwZT0id2ViZ2wiKSxPYmplY3QoeC5jcmVhdGVTaGFkZXJzKShTKSxPYmplY3QoeC5hcHBseVNoYWRlcikoUyksT2JqZWN0KHguY3JlYXRlQ2xvdWRTaGFkZXJzKShTKTtjb25zdCBCPVMuZ2w7Qi5jbGVhckNvbG9yKDAsMCwwLDApLEIuYmxlbmRGdW5jU2VwYXJhdGUoQi5TUkNfQUxQSEEsQi5PTkVfTUlOVVNfU1JDX0FMUEhBLEIuT05FLEIuT05FX01JTlVTX1NSQ19BTFBIQSksdGhpc1twXT1TfWVsc2UgdGhpc1tuXT1uZXcgbS5kZWZhdWx0KEwsdGhpc1thXSk7dGhpc1tpXT1bMSwwLDAsMCwxLDAsMCwwLDFdLHRoaXMudXBkYXRlUmVzb2x1dGlvbigpfWdldCBjYW52YXMoKXtyZXR1cm4gdGhpc1tUXX1nZXQgY2FudmFzUmVuZGVyZXIoKXtyZXR1cm4gdGhpc1tuXX1nZXQgZ2xSZW5kZXJlcigpe3JldHVybiB0aGlzW3BdfWdldCBpc1dlYkdMMigpe3JldHVybiB0aGlzW3BdJiZ0aGlzW3BdLmlzV2ViR0wyfWdldCBvcHRpb25zKCl7cmV0dXJuIHRoaXNbYV19Z2V0IGdsb2JhbFRyYW5zZm9ybU1hdHJpeCgpe2NvbnN0IEw9dGhpc1tpXTtyZXR1cm5bTFswXSxMWzFdLExbM10sTFs0XSxMWzZdLExbN11dfWdldCB2aWV3TWF0cml4KCl7cmV0dXJuIHRoaXNbaV19W29dKCl7Y29uc3QgTD10aGlzW3BdfHx0aGlzW25dO2lmKHRoaXNbcF0pe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OmJ9PXRoaXMuY2FudmFzO0wudW5pZm9ybXMudmlld01hdHJpeD10aGlzLnZpZXdNYXRyaXgsTC51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4PXRoaXMucHJvamVjdGlvbk1hdHJpeCxMLnVuaWZvcm1zLnVfcmVzb2x1dGlvbj1bRCxiXX19dXBkYXRlUmVzb2x1dGlvbigpe2NvbnN0e3dpZHRoOkwsaGVpZ2h0OkR9PXRoaXMuY2FudmFzLGI9WzEsMCwwLDAsMSwwLC1MLzIsLUQvMiwxXSxTPVsyL0wsMCwwLDAsLTIvRCwwLDAsMCwxXSxCPXMubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxiKTt0aGlzLnByb2plY3Rpb25NYXRyaXg9Qix0aGlzW3BdJiZ0aGlzW3BdLmdsLnZpZXdwb3J0KDAsMCxMLEQpfWNyZWF0ZVRleHR1cmUoTCxEKXtyZXR1cm4odGhpc1twXXx8dGhpc1tuXSkuY3JlYXRlVGV4dHVyZShMLEQpfWxvYWRUZXh0dXJlKEwse3VzZUltYWdlQml0bWFwOkQ9ITF9PXt9KXtyZXR1cm4odGhpc1twXXx8dGhpc1tuXSkubG9hZFRleHR1cmUoTCx7dXNlSW1hZ2VCaXRtYXA6RH0pfWNyZWF0ZVRleHQoTCx7Zm9udDpEPSIxNnB4IGFyaWFsIixmaWxsQ29sb3I6Yj1udWxsLHN0cm9rZUNvbG9yOlM9bnVsbCxzdHJva2VXaWR0aDpCPTF9PXt9KXtpZih0aGlzW3BdKXtjb25zdCB3PXYuZGVmYXVsdC5jcmVhdGVUZXh0KEwse2ZvbnQ6RCxmaWxsQ29sb3I6YixzdHJva2VDb2xvcjpTLHN0cm9rZVdpZHRoOkJ9KTtyZXR1cm57aW1hZ2U6dGhpcy5jcmVhdGVUZXh0dXJlKHcuaW1hZ2UpLHJlY3Q6dy5yZWN0fX1yZXR1cm57X2ltZzp7Zm9udDpELGZpbGxDb2xvcjpiLHN0cm9rZUNvbG9yOlMsc3Ryb2tlV2lkdGg6Qix0ZXh0Okx9fX1jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6TCxmcmFnbWVudDpELG9wdGlvbnM6Yn09e30pe2lmKHRoaXNbcF0pe2NvbnN0IFM9dGhpc1twXS5jb21waWxlU3luYyhELEwpO3JldHVybiBTLl9hdHRyaWJPcHRzPWIsU310aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IGNyZWF0ZSB3ZWJnbCBwcm9ncmFtLiIpfWNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6TD1PLGZyYWdtZW50OkQ9ZyxvcHRpb25zOmJ9PXt9KXtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6TCxmcmFnbWVudDpELG9wdGlvbnM6Yn0pfXVzZVByb2dyYW0oTCxEPXt9KXtpZih0aGlzW3BdKXtjb25zdCBiPU9iamVjdC5hc3NpZ24oe30sTC5fYXR0cmliT3B0cyxEKTtyZXR1cm4gdGhpc1twXS51c2VQcm9ncmFtKEwsYil9dGhyb3cgbmV3IEVycm9yKCJDb250ZXh0IDJEIGNhbm5vdCB1c2Ugd2ViZ2wgcHJvZ3JhbS4iKX1kZWxldGVUZXh0dXJlKEwpe3JldHVybih0aGlzW3BdfHx0aGlzW25dKS5kZWxldGVUZXh0dXJlKEwpfWNsZWFyKC4uLkwpe2lmKHRoaXNbcF0pe2NvbnN0IEQ9dGhpc1twXS5nbDtELmNsZWFyKEQuQ09MT1JfQlVGRkVSX0JJVCl9ZWxzZSB0aGlzW25dLmNsZWFyKC4uLkwpfWRyYXdNZXNoQ2xvdWQoTCx7Y2xlYXI6RD0hMSxwcm9ncmFtOmI9bnVsbH09e30pe2NvbnN0IFM9dGhpc1twXXx8dGhpc1tuXSxCPWJ8fEwucHJvZ3JhbTtpZih0aGlzW3BdKXtjb25zdCB3PVMuZ2w7aWYoRCYmdy5jbGVhcih3LkNPTE9SX0JVRkZFUl9CSVQpLEIpUy5wcm9ncmFtIT09QiYmdGhpcy51c2VQcm9ncmFtKEIse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSk7ZWxzZXtjb25zdCBIPUwubWVzaC5tZXNoRGF0YSxKPSEhSC51bmlmb3Jtcy51X3RleFNhbXBsZXIscT0hIUgudW5pZm9ybXMudV9maWx0ZXJGbGFnLFc9ISFILnVuaWZvcm1zLnVfcmFkaWFsR3JhZGllbnRWZWN0b3IsRz1MLmhhc0Nsb3VkQ29sb3IsUT1MLmhhc0Nsb3VkRmlsdGVyLHR0PSEhSC51bmlmb3Jtcy51X2NsaXBTYW1wbGVyO09iamVjdCh4LmFwcGx5Q2xvdWRTaGFkZXIpKFMse2hhc1RleHR1cmU6SixoYXNGaWx0ZXI6cSxoYXNHcmFkaWVudDpXLGhhc0Nsb3VkQ29sb3I6RyxoYXNDbG91ZEZpbHRlcjpRLGhhc0NsaXBQYXRoOnR0fSl9dGhpc1tvXSgpLFMuc2V0TWVzaERhdGEoW0wubWVzaERhdGFdKSxMLmJlZm9yZVJlbmRlciYmTC5iZWZvcmVSZW5kZXIodyxMKSxBKFMpLEwuYWZ0ZXJSZW5kZXImJkwuYWZ0ZXJSZW5kZXIodyxMKX1lbHNlIFMuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxTLmRyYXdNZXNoQ2xvdWQoTCx7Y2xlYXI6RCxob29rOiExfSl9ZHJhd01lc2hlcyhMLHtjbGVhcjpEPSExLHByb2dyYW06Yj1udWxsfT17fSl7Y29uc3QgUz10aGlzW3BdfHx0aGlzW25dO2lmKHRoaXNbcF0pe2NvbnN0IEI9Uy5mYm8sdz1PYmplY3QoeS5kZWZhdWx0KSh0aGlzLEwsYj09bnVsbCksSD1TLmdsO0QmJkguY2xlYXIoSC5DT0xPUl9CVUZGRVJfQklUKTtjb25zdCBKPSFPYmplY3QoZi5pc1VuaXRUcmFuc2Zvcm0pKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KTt0aGlzLl9kcmF3Q2FsbHM9MDtmb3IoY29uc3QgcSBvZiB3KXt0aGlzLl9kcmF3Q2FsbHMrKztjb25zdCBXPWJ8fHEucHJvZ3JhbTtpZihxIGluc3RhbmNlb2YgTS5kZWZhdWx0KXRoaXMuZHJhd01lc2hDbG91ZChxLHtjbGVhcjpELHByb2dyYW06V30pO2Vsc2V7Y29uc3R7d2lkdGg6RyxoZWlnaHQ6UX09dGhpcy5jYW52YXM7aWYocS5iZWZvcmVSZW5kZXImJnEuYmVmb3JlUmVuZGVyKEgscSkscS5wYXNzLmxlbmd0aCYmKCghdGhpcy5mYm98fHRoaXMuZmJvLndpZHRoIT09R3x8dGhpcy5mYm8uaGVpZ2h0IT09USkmJih0aGlzLmZibz17d2lkdGg6RyxoZWlnaHQ6USx0YXJnZXQ6Uy5jcmVhdGVGQk8oKSxidWZmZXI6Uy5jcmVhdGVGQk8oKSxzd2FwKCl7W3RoaXMudGFyZ2V0LHRoaXMuYnVmZmVyXT1bdGhpcy5idWZmZXIsdGhpcy50YXJnZXRdfX0pLFMuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSwhVyYmcS5maWx0ZXJDYW52YXMpe09iamVjdCh4LmFwcGx5U2hhZGVyKShTLHtoYXNUZXh0dXJlOiEwfSk7bGV0IHR0PXRoaXMuZmlsdGVyQ29udGV4dDt0dHx8KHR0PXYuZGVmYXVsdC5jcmVhdGVDYW52YXMoRyxRKS5nZXRDb250ZXh0KCIyZCIpLHRoaXMuZmlsdGVyQ29udGV4dD10dCk7Y29uc3QgXz1MW3EucGFja0luZGV4XSxzdD1fLmZpbHRlcixrPUxbcS5wYWNrSW5kZXgrMV0sY3Q9TFtxLnBhY2tJbmRleC0xXTsoIWN0fHwhY3QuZmlsdGVyQ2FudmFzfHxjdC5maWx0ZXIhPT1zdCkmJigha3x8IWsuZmlsdGVyQ2FudmFzfHxrLmZpbHRlciE9PXN0KT8oSj8odHQuc2F2ZSgpLE9iamVjdChjLmRyYXdNZXNoMkQpKF8sdHQsITEpLHR0LnJlc3RvcmUoKSxPYmplY3QoYy5hcHBseUZpbHRlcikodHQsc3QpKTpPYmplY3QoYy5kcmF3TWVzaDJEKShfLHR0LCEwKSx0aGlzW29dKCksQyhTLHR0LEcsUSkpOihKJiZ0dC5zYXZlKCksT2JqZWN0KGMuZHJhd01lc2gyRCkoXyx0dCwhMSksSiYmdHQucmVzdG9yZSgpLCgha3x8IWsuZmlsdGVyQ2FudmFzfHxfLmZpbHRlciE9PWsuZmlsdGVyKSYmKE9iamVjdChjLmFwcGx5RmlsdGVyKSh0dCxzdCksdGhpc1tvXSgpLEMoUyx0dCxHLFEpKSl9ZWxzZXtpZihXKVMucHJvZ3JhbSE9PVcmJnRoaXMudXNlUHJvZ3JhbShXLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSk7ZWxzZXtjb25zdCB0dD0hIXEudW5pZm9ybXMudV90ZXhTYW1wbGVyLF89ISFxLnVuaWZvcm1zLnVfZmlsdGVyRmxhZyxzdD0hIXEudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3RvcixrPSEhcS51bmlmb3Jtcy51X2NsaXBTYW1wbGVyO09iamVjdCh4LmFwcGx5U2hhZGVyKShTLHtoYXNUZXh0dXJlOnR0LGhhc0ZpbHRlcjpfLGhhc0dyYWRpZW50OnN0LGhhc0NsaXBQYXRoOmt9KX1xLmZpbHRlckNhbnZhcyYmY29uc29sZS53YXJuKCJVc2VyIHByb2dyYW0gaWdub3JlZCBzb21lIGZpbHRlciBlZmZlY3RzLiIpLHRoaXNbb10oKSxTLnNldE1lc2hEYXRhKFtxXSksQShTKX1pZihxLnBhc3MubGVuZ3RoKXtjb25zdCB0dD1xLnBhc3MubGVuZ3RoO3EucGFzcy5mb3JFYWNoKChfLHN0KT0+e18uYmxlbmQ9cS5lbmFibGVCbGVuZCxfLnNldFRleHR1cmUoUy5mYm8udGV4dHVyZSksc3Q9PT10dC0xP1MuYmluZEZCTyhCKToodGhpcy5mYm8uc3dhcCgpLFMuYmluZEZCTyh0aGlzLmZiby50YXJnZXQpKSxfLnByb2dyYW0/Uy51c2VQcm9ncmFtKF8ucHJvZ3JhbSk6KHRoaXMuZGVmYXVsdFBhc3NQcm9ncmFtPXRoaXMuZGVmYXVsdFBhc3NQcm9ncmFtfHx0aGlzLmNyZWF0ZVBhc3NQcm9ncmFtKCksUy51c2VQcm9ncmFtKHRoaXMuZGVmYXVsdFBhc3NQcm9ncmFtKSksUy5zZXRNZXNoRGF0YShbXy5tZXNoRGF0YV0pLEguY2xlYXIoSC5DT0xPUl9CVUZGRVJfQklUKSxBKFMpfSl9cS5hZnRlclJlbmRlciYmcS5hZnRlclJlbmRlcihILHEpfX19ZWxzZSBTLnNldFRyYW5zZm9ybSh0aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCksUy5kcmF3TWVzaGVzKEwse2NsZWFyOkR9KX1kcmF3SW1hZ2UoTCwuLi5EKXtjb25zdCBiPUQubGVuZ3RoO2lmKGI8Mil0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiAzIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHtELmxlbmd0aCsxfSBwcmVzZW50LmApO2lmKGIhPT0yJiZiIT09NCYmYiE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ2RyYXdJbWFnZScgb24gJ1JlbmRlcmVyJzogVmFsaWQgYXJpdGllcyBhcmU6IFszLCA1LCA5XSwgYnV0ICR7RC5sZW5ndGgrMX0gYXJndW1lbnRzIHByb3ZpZGVkLmApO2xldCBTPW51bGwsQj1udWxsO2I9PT0yP1M9W0RbMF0sRFsxXSxMLndpZHRoLEwuaGVpZ2h0XTpiPT09ND9TPUQ6Yj09PTgmJihCPUQuc2xpY2UoMCw0KSxTPUQuc2xpY2UoNCkpO2NvbnN0IHc9dGhpcy5jcmVhdGVUZXh0dXJlKEwpLHt3aWR0aDpILGhlaWdodDpKfT10aGlzLmNhbnZhcyxxPW5ldyBsLmRlZmF1bHQ7cS5yZWN0KFNbMF0sU1sxXSxILEopO2NvbnN0IFc9bmV3IHUuZGVmYXVsdChxLHt3aWR0aDpILGhlaWdodDpKfSk7Vy5zZXRUZXh0dXJlKHcse3JlY3Q6UyxzcmNSZWN0OkJ9KSx0aGlzLmRyYXdNZXNoZXMoW1ddKSx0aGlzLmRlbGV0ZVRleHR1cmUodyl9c2V0R2xvYmFsVHJhbnNmb3JtKC4uLkwpe3JldHVybiB0aGlzW2ldPVtMWzBdLExbMV0sMCxMWzJdLExbM10sMCxMWzRdLExbNV0sMV0sdGhpc31nbG9iYWxUcmFuc2Zvcm0oLi4uTCl7Y29uc3QgRD10aGlzW2ldO3JldHVybiB0aGlzW2ldPXMubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksRCxMKSx0aGlzfWdsb2JhbFRyYW5zbGF0ZShMLEQpe2xldCBiPXMubWF0My5jcmVhdGUoKTtyZXR1cm4gYj1zLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxiLFtMLERdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5iKX1nbG9iYWxSb3RhdGUoTCxbRCxiXT1bMCwwXSl7bGV0IFM9cy5tYXQzLmNyZWF0ZSgpO3JldHVybiBTPXMubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFMsW0QsYl0pLFM9cy5tYXQzLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksUyxMKSxTPXMubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFMsWy1ELC1iXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uUyl9Z2xvYmFsU2NhbGUoTCxEPUwsW2IsU109WzAsMF0pe2xldCBCPXMubWF0My5jcmVhdGUoKTtyZXR1cm4gQj1zLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFtiLFNdKSxCPXMubWF0My5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQixbTCxEXSksQj1zLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFstYiwtU10pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLkIpfWdsb2JhbFNrZXcoTCxEPUwsW2IsU109WzAsMF0pe2xldCBCPXMubWF0My5jcmVhdGUoKTtyZXR1cm4gQj1zLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFtiLFNdKSxCPXMubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQixzLm1hdDMuZnJvbVZhbHVlcygxLE1hdGgudGFuKEQpLE1hdGgudGFuKEwpLDEsMCwwKSksQj1zLm1hdDMudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxCLFstYiwtU10pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLkIpfXRyYW5zZm9ybVBvaW50KEwsRCxiKXtsZXQgUz10aGlzLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtiJiYoUz1zLm1hdDMubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFMsYikpO2NvbnN0IEI9TCpTWzBdK0QqU1syXStTWzRdLHc9TCpTWzFdK0QqU1szXStTWzVdO3JldHVybltCLHddfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCgxNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1yLmRlZmF1bHR9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDE2KSxzPXQoMTcpLG09dCgxOCkseT10KDE5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYyhSLE8sZyl7cmV0dXJuIE8gaW4gUj9PYmplY3QuZGVmaW5lUHJvcGVydHkoUixPLHt2YWx1ZTpnLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6UltPXT1nLFJ9Y29uc3QgbD17fTtmdW5jdGlvbiB1KFIsTz0zKXtjb25zdCBnPVtdLHA9Ui5sZW5ndGg7Zm9yKGxldCBuPTA7bjxwO24rKyluJU88MiYmZy5wdXNoKC41KihSW25dKzEpKTtyZXR1cm4gZ31mdW5jdGlvbiBNKFIsTyl7Y29uc3QgZz1PLl9idWZmZXJzO09iamVjdC52YWx1ZXMoZykuZm9yRWFjaChwPT57Ui5kZWxldGVCdWZmZXIocCl9KSxPLl9idWZmZXJzPXt9fWZ1bmN0aW9uIGYoUixPLGcpe3JldHVybiBSLmFjdGl2ZVRleHR1cmUoUi5URVhUVVJFMCtnKSxBcnJheS5pc0FycmF5KE8uX2ltZyk/Ui5iaW5kVGV4dHVyZShSLlRFWFRVUkVfQ1VCRV9NQVAsTyk6Ui5iaW5kVGV4dHVyZShSLlRFWFRVUkVfMkQsTyksT31jb25zdCB2PXtpbnQ6IjFpIixpdmVjMjoiMmkiLGl2ZWMzOiIzaSIsaXZlYzQ6IjRpIixmbG9hdDoiMWYiLHZlYzI6IjJmIix2ZWMzOiIzZiIsdmVjNDoiNGYiLG1hdDI6Ik1hdHJpeDJmdiIsbWF0MzoiTWF0cml4M2Z2IixtYXQ0OiJNYXRyaXg0ZnYiLHNhbXBsZXIxRDoic2FtcGxlcjFEIixzYW1wbGVyMkQ6InNhbXBsZXIyRCIsc2FtcGxlcjNEOiJzYW1wbGVyM0QiLHNhbXBsZXJDdWJlOiJzYW1wbGVyQ3ViZSIsc2FtcGxlcjFEU2hhZG93OiJzYW1wbGVyMURTaGFkb3ciLHNhbXBsZXIyRFNoYWRvdzoic2FtcGxlcjJEU2hhZG93IixzYW1wbGVyMkRSZWN0OiJzYW1wbGVyMkRSZWN0IixzYW1wbGVyMkRSZWN0U2hhZG93OiJzYW1wbGVyMkRSZWN0U2hhZG93In07Y2xhc3MgeHtzdGF0aWMgYWRkTGlicyhPPXt9KXtPYmplY3QuYXNzaWduKGwsTyl9c3RhdGljIEZMT0FUKE8sZyl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShPLEZsb2F0MzJBcnJheSxnKX1zdGF0aWMgVU5TSUdORURfQllURShPLGcpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoTyxVaW50OEFycmF5LGcpfXN0YXRpYyBVTlNJR05FRF9TSE9SVChPLGcpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoTyxVaW50MTZBcnJheSxnKX1zdGF0aWMgQllURShPLGcpe3JldHVybiBPYmplY3Qoci5wb2ludHNUb0J1ZmZlcikoTyxJbnQ4QXJyYXksZyl9c3RhdGljIFNIT1JUKE8sZyl7cmV0dXJuIE9iamVjdChyLnBvaW50c1RvQnVmZmVyKShPLEludDE2QXJyYXksZyl9Y29uc3RydWN0b3IoTyxnPXt9KXt0aGlzLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSx4LmRlZmF1bHRPcHRpb25zLGcpLHRoaXMuY2FudmFzPU87bGV0IHA7dGhpcy5vcHRpb25zLndlYmdsMiYmKHA9Ty5nZXRDb250ZXh0KCJ3ZWJnbDIiLHRoaXMub3B0aW9ucykpLHA9PW51bGwmJihwPU9iamVjdChyLnNldHVwV2ViR0wpKE8sdGhpcy5vcHRpb25zKSx0aGlzLmFpYV9leHQ9cC5nZXRFeHRlbnNpb24oIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKSksdGhpcy5nbD1wLHAudmlld3BvcnQoMCwwLE8ud2lkdGgsTy5oZWlnaHQpLHAuY2xlYXJDb2xvcigwLDAsMCwwKSxwLmJsZW5kRnVuY1NlcGFyYXRlKHAuU1JDX0FMUEhBLHAuT05FX01JTlVTX1NSQ19BTFBIQSxwLk9ORSxwLk9ORV9NSU5VU19TUkNfQUxQSEEpLHRoaXMucHJvZ3JhbXM9W10sdGhpcy5fZXZlbnRzPXt9fWdldCBwcm9ncmFtKCl7Y29uc3QgTz10aGlzLmdsO3JldHVybiBPLmdldFBhcmFtZXRlcihPLkNVUlJFTlRfUFJPR1JBTSl9X2RlY2xhcmVVbmlmb3JtKE8sZyxwPSIxZiIpe2NvbnN0IG49dGhpcy5nbCxhPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKE8sZyk7bGV0IGk7Y29uc3Qgbz10aGlzO2lmKC9ec2FtcGxlci8udGVzdChwKSl7Y29uc3QgVD1PLl9zYW1wbGVyTWFwLEE9Ty5fYmluZFRleHR1cmVzO09iamVjdC5kZWZpbmVQcm9wZXJ0eShPLnVuaWZvcm1zLGcse2dldCgpe3JldHVybiBpfSxzZXQoQyl7aT1DO2NvbnN0IEk9VFtnXSE9bnVsbD9UW2ddOkEubGVuZ3RoO0FbSV09QyxmKG4sQyxJKSxUW2ddfHwoVFtnXT1JLG4udW5pZm9ybTFpKGEsSSkpLG8ub3B0aW9ucy5hdXRvVXBkYXRlJiZvLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfWVsc2V7Y29uc3QgVD1wLmluZGV4T2YoIk1hdHJpeCIpPT09MCxBPSFUJiYvdiQvLnRlc3QocCksQz1uW2B1bmlmb3JtJHtwfWBdLmJpbmQobik7T2JqZWN0LmRlZmluZVByb3BlcnR5KE8udW5pZm9ybXMsZyx7Z2V0KCl7cmV0dXJuIGl9LHNldChJKXtpPUksdHlwZW9mIEk9PSJudW1iZXIiJiYoST1bSV0pLFQ/QyhhLCExLEkpOkE/QyhhLEkpOkMoYSwuLi5JKSxvLm9wdGlvbnMuYXV0b1VwZGF0ZSYmby51cGRhdGUoKX0sY29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITB9KX19X2RyYXcoKXtjb25zdCBPPXRoaXMucHJvZ3JhbTtPLm1lc2hEYXRhLmZvckVhY2goKGcscCk9Pntjb25zdHtwb3NpdGlvbnM6bixjZWxsczphLGluc3RhbmNlQ291bnQ6aSxjZWxsc0NvdW50Om8sYXR0cmlidXRlczpULHVuaWZvcm1zOkEsdGV4dHVyZUNvb3JkOkMsZW5hYmxlQmxlbmQ6SX09ZyxQPXRoaXMuZ2w7bGV0IEw9Zy5tb2RlIT1udWxsP2cubW9kZTpQLlRSSUFOR0xFUzt0eXBlb2YgTD09InN0cmluZyImJihMPVBbTF0pLEk/UC5lbmFibGUoUC5CTEVORCk6UC5kaXNhYmxlKFAuQkxFTkQpLFAuYmluZEJ1ZmZlcihQLkFSUkFZX0JVRkZFUixPLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKSxQLmJ1ZmZlckRhdGEoUC5BUlJBWV9CVUZGRVIsbixQLlNUQVRJQ19EUkFXKSxhJiYoUC5iaW5kQnVmZmVyKFAuRUxFTUVOVF9BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy5jZWxsc0J1ZmZlciksUC5idWZmZXJEYXRhKFAuRUxFTUVOVF9BUlJBWV9CVUZGRVIsYSxQLlNUQVRJQ19EUkFXKSk7Y29uc3QgRD1bXTtUJiZPYmplY3QudmFsdWVzKFQpLmZvckVhY2goKHtuYW1lOlMsZGF0YTpCLGRpdmlzb3I6d30pPT57aWYoUC5iaW5kQnVmZmVyKFAuQVJSQVlfQlVGRkVSLE8uX2J1ZmZlcnNbU10pLFAuYnVmZmVyRGF0YShQLkFSUkFZX0JVRkZFUixCLFAuU1RBVElDX0RSQVcpLHchPW51bGwpe2NvbnN0IEg9UC5nZXRBdHRyaWJMb2NhdGlvbihPLFMpO0g+PTAmJihQLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEgpLEQucHVzaChIKSxQLnZlcnRleEF0dHJpYkRpdmlzb3I/UC52ZXJ0ZXhBdHRyaWJEaXZpc29yKEgsdyk6dGhpcy5haWFfZXh0JiZ0aGlzLmFpYV9leHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKEgsdykpfX0pLEEmJk9iamVjdC5lbnRyaWVzKEEpLmZvckVhY2goKFtTLEJdKT0+e3RoaXMudW5pZm9ybXNbU109Qn0pO2xldCBiO2lmKCFhKXtjb25zdCBTPU8uX2RpbWVuc2lvbjtiPW4ubGVuZ3RoL1N9aWYoTy5fZW5hYmxlVGV4dHVyZXMmJk8uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpe2NvbnN0IFM9Q3x8dShuLE8uX2RpbWVuc2lvbik7UC5iaW5kQnVmZmVyKFAuQVJSQVlfQlVGRkVSLE8uX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXIpLFAuYnVmZmVyRGF0YShQLkFSUkFZX0JVRkZFUix4LkZMT0FUKFMpLFAuU1RBVElDX0RSQVcpfWkhPW51bGw/KGE/UC5kcmF3RWxlbWVudHNJbnN0YW5jZWQ/UC5kcmF3RWxlbWVudHNJbnN0YW5jZWQoTCxvLFAuVU5TSUdORURfU0hPUlQsMCxpKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShMLG8sUC5VTlNJR05FRF9TSE9SVCwwLGkpOlAuZHJhd0FycmF5c0luc3RhbmNlZD9QLmRyYXdBcnJheXNJbnN0YW5jZWQoTCwwLGIsaSk6dGhpcy5haWFfZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShMLDAsYixpKSxELmZvckVhY2goUz0+e1AudmVydGV4QXR0cmliRGl2aXNvcj9QLnZlcnRleEF0dHJpYkRpdmlzb3IoUyxudWxsKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoUyxudWxsKX0pKTphP1AuZHJhd0VsZW1lbnRzKEwsbyxQLlVOU0lHTkVEX1NIT1JULDApOlAuZHJhd0FycmF5cyhMLDAsYil9KX1nZXQgaXNXZWJHTDIoKXtyZXR1cm4gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ8InUiJiZ0aGlzLmdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH1nZXQgZW5hYmxlVGV4dHVyZXMoKXtyZXR1cm4gdGhpcy5wcm9ncmFtJiZ0aGlzLnByb2dyYW0uX2VuYWJsZVRleHR1cmVzfWdldCB1bmlmb3Jtcygpe2NvbnN0IE89dGhpcy5wcm9ncmFtO2lmKCFPfHwhTy51bmlmb3Jtcyl0aHJvdyBFcnJvcigiTm8gYXZhbGlhYmxlIHByb2dyYW0uIik7cmV0dXJuIE8udW5pZm9ybXN9ZGVsZXRlUHJvZ3JhbShPKXtjb25zdCBnPXRoaXMuZ2w7dGhpcy5wcm9ncmFtPT09TyYmKHRoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKSxnLnVzZVByb2dyYW0obnVsbCkpO2NvbnN0IHA9dGhpcy5wcm9ncmFtcy5pbmRleE9mKE8pO3A+PTAmJnRoaXMucHJvZ3JhbXMuc3BsaWNlKHAsMSksTShnLE8pLGcuZGVsZXRlUHJvZ3JhbShPKX1zZXRNZXNoRGF0YShPKXtBcnJheS5pc0FycmF5KE8pfHwoTz1bT10pO2NvbnN0IGc9dGhpcy5wcm9ncmFtO2cubWVzaERhdGE9Ty5tYXAoKHttb2RlOnAscG9zaXRpb25zOm4saW5zdGFuY2VDb3VudDphLGNlbGxzOmksY2VsbHNDb3VudDpvLGF0dHJpYnV0ZXM6VCx1bmlmb3JtczpBLHRleHR1cmVDb29yZDpDLGVuYWJsZUJsZW5kOkl9KT0+e2NvbnN0IFA9e3Bvc2l0aW9uczp4LkZMT0FUKG4pLHVuaWZvcm1zOkEsZW5hYmxlQmxlbmQ6ISFJLHRleHR1cmVDb29yZDp4LkZMT0FUKEMpfTtpZihpJiYoUC5jZWxscz14LlVTSE9SVChpKSxQLmNlbGxzQ291bnQ9b3x8UC5jZWxscy5sZW5ndGgpLHAhPW51bGwmJihQLm1vZGU9cCksYSE9bnVsbCl7aWYoIXRoaXMuaXNXZWJHTDImJiF0aGlzLmFpYV9leHQpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgdXNlIGluc3RhbmNlQ291bnQgaW4gdGhpcyByZW5kZXJpbmcgY29udGV4dCwgdXNlIHdlYmdsMiBjb250ZXh0IGluc3RlYWQuIik7UC5pbnN0YW5jZUNvdW50PWF9aWYoVCl7Y29uc3QgTD17fTtPYmplY3QuZW50cmllcyhUKS5mb3JFYWNoKChbRCxiXSk9PntpZighZy5fYXR0cmlidXRlW0RdKWcuX2F0dHJpYnV0ZVtEXT0iaWdub3JlZCI7ZWxzZSBpZihnLl9hdHRyaWJ1dGVbRF0hPT0iaWdub3JlZCIpe2NvbnN0e25hbWU6Uyx0eXBlOkJ9PWcuX2F0dHJpYnV0ZVtEXTtsZXQgdz1iLmRhdGF8fGI7aWYoQXJyYXkuaXNBcnJheSh3KSYmKHc9eFtCXSh3KSksTFtEXT17bmFtZTpTLGRhdGE6d30sYi5kaXZpc29yIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgZGl2aXNvciBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtMW0RdLmRpdmlzb3I9Yi5kaXZpc29yfX19KSxQLmF0dHJpYnV0ZXM9TH1yZXR1cm4gUH0pLHRoaXMub3B0aW9ucy5hdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZSgpfWNyZWF0ZVByb2dyYW0oTyxnKXtjb25zdCBwPS9eXHMqdW5pZm9ybVxzK3NhbXBsZXIvbWcudGVzdChPKTtPPT1udWxsJiYoTz1tLmRlZmF1bHQpLGc9PW51bGwmJihnPXA/eS5kZWZhdWx0OnMuZGVmYXVsdCk7Y29uc3Qgbj10aGlzLmdsLGE9T2JqZWN0KHIuY3JlYXRlUHJvZ3JhbSkobixnLE8pO2Euc2hhZGVyVGV4dD17dmVydGV4U2hhZGVyOmcsZnJhZ21lbnRTaGFkZXI6T30sYS5fYnVmZmVycz17fSxhLl9hdHRyaWJ1dGU9e30sYS51bmlmb3Jtcz17fSxhLl9zYW1wbGVyTWFwPXt9LGEuX2JpbmRUZXh0dXJlcz1bXTtjb25zdCBpPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb259YCwiaW0iKTtsZXQgbz1nLm1hdGNoKGkpO28mJihhLl9kaW1lbnNpb249TnVtYmVyKG9bMV0pKTtjb25zdCBUPW5ldyBSZWdFeHAoYCg/OmF0dHJpYnV0ZXxpbikgdmVjKFxcZCkgJHt0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkfWAsImltIik7bz1nLm1hdGNoKFQpLG8mJihhLl90ZXhDb29yZFNpemU9TnVtYmVyKG9bMV0pKTtjb25zdCBBPS9eXHMqKD86YXR0cmlidXRlfGluKSAoXHcrPykoXGQqKSAoXHcrKS9naW07aWYobz1nLm1hdGNoKEEpLG8pZm9yKGxldCBQPTA7UDxvLmxlbmd0aDtQKyspe2NvbnN0IEw9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2ltLEQ9b1tQXS5tYXRjaChMKTtpZihEJiZEWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uJiZEWzNdIT09dGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCl7bGV0WyxiLFMsQl09RDtiPT09Im1hdCImJihTKio9MiksYS5fYnVmZmVyc1tCXT1uLmNyZWF0ZUJ1ZmZlcigpLGEuX2F0dHJpYnV0ZVtCXT17bmFtZTpCLHR5cGU6YixzaXplOk51bWJlcihTKXx8MX19fWNvbnN0IEM9L15ccyp1bmlmb3JtXHMrKFx3KylccysoXHcrKShcW1xkK1xdKT8vbWc7bz1nLm1hdGNoKEMpfHxbXSxvPW8uY29uY2F0KE8ubWF0Y2goQyl8fFtdKSxvLmZvckVhY2goUD0+e2NvbnN0IEw9UC5tYXRjaCgvXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy8pO2xldFtELGIsU109TC5zbGljZSgxKTtEPXZbRF0sUz0hIVMsRC5pbmRleE9mKCJNYXRyaXgiKSE9PTAmJlMmJihEKz0idiIpLHRoaXMuX2RlY2xhcmVVbmlmb3JtKGEsYixEKX0pLGEuX2J1ZmZlcnMudmVydGljZXNCdWZmZXI9bi5jcmVhdGVCdWZmZXIoKSxhLl9idWZmZXJzLmNlbGxzQnVmZmVyPW4uY3JlYXRlQnVmZmVyKCk7Y29uc3QgST1uLmdldEF0dHJpYkxvY2F0aW9uKGEsdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7cmV0dXJuIGEuX2VuYWJsZVRleHR1cmVzPUk+PTAsYS5fZW5hYmxlVGV4dHVyZXMmJihhLl9idWZmZXJzLnRleENvb3JkQnVmZmVyPW4uY3JlYXRlQnVmZmVyKCkpLHRoaXMucHJvZ3JhbXMucHVzaChhKSxhfXVzZVByb2dyYW0oTyxnPXt9KXt0aGlzLnN0YXJ0UmVuZGVyPSExLHRoaXMuX3JlbmRlckZyYW1lSUQmJihjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUlEKSxkZWxldGUgdGhpcy5fcmVuZGVyRnJhbWVJRCk7Y29uc3QgcD10aGlzLmdsO3AudXNlUHJvZ3JhbShPKTtjb25zdCBuPU8uX2RpbWVuc2lvbjtwLmJpbmRCdWZmZXIocC5BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcik7Y29uc3QgYT1wLmdldEF0dHJpYkxvY2F0aW9uKE8sdGhpcy5vcHRpb25zLnZlcnRleFBvc2l0aW9uKTtpZihwLnZlcnRleEF0dHJpYlBvaW50ZXIoYSxuLHAuRkxPQVQsITEsMCwwKSxwLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGEpLE8uX2VuYWJsZVRleHR1cmVzKXtwLmJpbmRCdWZmZXIocC5BUlJBWV9CVUZGRVIsTy5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcik7Y29uc3QgaT1wLmdldEF0dHJpYkxvY2F0aW9uKE8sdGhpcy5vcHRpb25zLnZlcnRleFRleHR1cmVDb29yZCk7cC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGksTy5fdGV4Q29vcmRTaXplfHwyLHAuRkxPQVQsITEsMCwwKSxwLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpfWlmKE9iamVjdC5lbnRyaWVzKE8uX2F0dHJpYnV0ZSkuZm9yRWFjaCgoW2ksb10pPT57aWYobyE9PSJpZ25vcmVkIil7Y29uc3QgVD1vLnNpemUsQT1nW2ldfHx7fSxDPSEhQS5ub3JtYWxpemU7bGV0IEk9QS50eXBlfHwiRkxPQVQiO2NvbnN0IFA9QS5rZXl8fGk7ST09PSJVQllURSImJihJPSJVTlNJR05FRF9CWVRFIiksST09PSJVU0hPUlQiJiYoST0iVU5TSUdORURfU0hPUlQiKSxvLnR5cGU9SSxQJiZQIT09aSYmKE8uX2F0dHJpYnV0ZVtQXT1vKSxwLmJpbmRCdWZmZXIocC5BUlJBWV9CVUZGRVIsTy5fYnVmZmVyc1tpXSk7Y29uc3QgTD1wLmdldEF0dHJpYkxvY2F0aW9uKE8saSk7TD49MCYmKHAudmVydGV4QXR0cmliUG9pbnRlcihMLFQscFtJXSxDLDAsMCkscC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShMKSl9fSksIU8ubWVzaERhdGEpe2NvbnN0IGk9W1stMSwtMSwwLDFdLnNsaWNlKDAsbiksWzEsLTEsMCwxXS5zbGljZSgwLG4pLFsxLDEsMCwxXS5zbGljZSgwLG4pLFstMSwxLDAsMV0uc2xpY2UoMCxuKV0sbz1bWzAsMSwzXSxbMywxLDJdXTt0aGlzLnNldE1lc2hEYXRhKHtwb3NpdGlvbnM6aSxjZWxsczpvfSl9cmV0dXJuIE99Y29tcGlsZVN5bmMoTyxnKXtPPU98fG0uZGVmYXVsdDtjb25zdCBwPXt9O2Z1bmN0aW9uIG4oVCl7VD1ULnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEE9W10sQz1ULm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoQyl7Zm9yKGxldCBJPTA7STxDLmxlbmd0aDtJKyspe2NvbnN0IEw9Q1tJXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoTCl7Y29uc3QgRD1MWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBiPUxbMV07aWYoYj09PSJncmFwaCImJihiPSJncmFwaGljcyIpLHBbYl0pQS5wdXNoKGAvKiBpbmNsdWRlZCAke2J9ICovYCk7ZWxzZSBpZihwW2JdPSEwLEQ9PT0ibGliIil7Y29uc3QgUz1uKGxbYl0pO0EucHVzaChTKX1lbHNlIGlmKEQ9PT0ibGluayIpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCBleHRlcm5hbCBsaW5rcyBzeW5jaHJvbm91c2x5LiBVc2UgY29tcGlsZSBpbnN0ZWFkIG9mIGNvbXBpbGVTeW5jLiIpfX1BLmZvckVhY2goST0+e1Q9VC5yZXBsYWNlKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tLEkpfSl9cmV0dXJuIFR9Y29uc3QgYT1uKE8pLGk9Zz9uKGcpOm51bGw7cmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbShhLGkpfWFzeW5jIGNvbXBpbGUoTyxnKXtPPU98fG0uZGVmYXVsdDtjb25zdCBwPXt9O2FzeW5jIGZ1bmN0aW9uIG4oVCl7VD1ULnJlcGxhY2UoL15ccyovbWcsIiIpO2NvbnN0IEE9W10sQz1ULm1hdGNoKC9eI3ByYWdtYVxzK2luY2x1ZGVccysuKi9tZyk7aWYoQyl7Zm9yKGxldCBJPTA7STxDLmxlbmd0aDtJKyspe2NvbnN0IEw9Q1tJXS5tYXRjaCgvKD86PHwiKSguKikoPzo+fCIpLyk7aWYoTCl7Y29uc3QgRD1MWzBdLmluZGV4T2YoIjwiKT09PTA/ImxpYiI6ImxpbmsiO2xldCBiPUxbMV07aWYoYj09PSJncmFwaCImJihiPSJncmFwaGljcyIpLHBbYl0pQS5wdXNoKGAvKiBpbmNsdWRlZCAke2J9ICovYCk7ZWxzZSBpZihwW2JdPSEwLEQ9PT0ibGliIil7Y29uc3QgUz1hd2FpdCBuKGxbYl0pO0EucHVzaChTKX1lbHNlIGlmKEQ9PT0ibGluayIpe2xldCBTPWF3YWl0IHguZmV0Y2hTaGFkZXIoYik7Uz1hd2FpdCBuKFMpLEEucHVzaChTKX19fUEuZm9yRWFjaChJPT57VD1ULnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sSSl9KX1yZXR1cm4gVH1jb25zdCBhPWF3YWl0IG4oTyksaT1nP2F3YWl0IG4oZyk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGEsaSl9YXN5bmMgbG9hZChPLGc9bnVsbCl7cmV0dXJuIE89YXdhaXQgeC5mZXRjaFNoYWRlcihPKSxnJiYoZz1hd2FpdCB4LmZldGNoU2hhZGVyKGcpKSx0aGlzLmNvbXBpbGUoTyxnKX1jcmVhdGVUZXh0dXJlKE89bnVsbCx7d3JhcFM6Zz10aGlzLmdsLkNMQU1QX1RPX0VER0Usd3JhcFQ6cD10aGlzLmdsLkNMQU1QX1RPX0VER0UsbWluRmlsdGVyOm49dGhpcy5nbC5MSU5FQVIsbWFnRmlsdGVyOmE9dGhpcy5nbC5MSU5FQVJ9PXt9KXtjb25zdCBpPXRoaXMuZ2wsbz1BcnJheS5pc0FycmF5KE8pP2kuVEVYVFVSRV9DVUJFX01BUDppLlRFWFRVUkVfMkQ7dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHM9dGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHN8fGkuZ2V0UGFyYW1ldGVyKGkuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLGkuYWN0aXZlVGV4dHVyZShpLlRFWFRVUkUwK3RoaXMuX21heF90ZXh0dXJlX2ltYWdlX3VuaXRzLTEpO2NvbnN0IFQ9aS5jcmVhdGVUZXh0dXJlKCk7aS5iaW5kVGV4dHVyZShvLFQpLGkucGl4ZWxTdG9yZWkoaS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCEwKTtjb25zdHt3aWR0aDpBLGhlaWdodDpDfT10aGlzLmNhbnZhcztpZihPKWlmKG89PT1pLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBJPTA7STw2O0krKylpLnRleEltYWdlMkQoaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grSSwwLGkuUkdCQSxpLlJHQkEsaS5VTlNJR05FRF9CWVRFLE9bSV0pO2Vsc2UgaS50ZXhJbWFnZTJEKG8sMCxpLlJHQkEsaS5SR0JBLGkuVU5TSUdORURfQllURSxPKTtlbHNlIGlmKG89PT1pLlRFWFRVUkVfQ1VCRV9NQVApZm9yKGxldCBJPTA7STw2O0krKyl0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grSSwwLGkuUkdCQSxBLEMsMCxpLlJHQkEsaS5VTlNJR05FRF9CWVRFLG51bGwpO2Vsc2UgaS50ZXhJbWFnZTJEKG8sMCxpLlJHQkEsQSxDLDAsaS5SR0JBLGkuVU5TSUdORURfQllURSxudWxsKTtyZXR1cm4gaS50ZXhQYXJhbWV0ZXJpKG8saS5URVhUVVJFX01JTl9GSUxURVIsbiksaS50ZXhQYXJhbWV0ZXJpKG8saS5URVhUVVJFX01BR19GSUxURVIsYSksaS50ZXhQYXJhbWV0ZXJpKG8saS5URVhUVVJFX1dSQVBfUyxnKSxpLnRleFBhcmFtZXRlcmkobyxpLlRFWFRVUkVfV1JBUF9ULHApLG89PT1pLlRFWFRVUkVfQ1VCRV9NQVAmJihPLndpZHRoPU9bMF0ud2lkdGgsTy5oZWlnaHQ9T1swXS5oZWlnaHQpLGkuYmluZFRleHR1cmUobyxudWxsKSxULl9pbWc9T3x8e3dpZHRoOkEsaGVpZ2h0OkN9LFQuZGVsZXRlPSgpPT57dGhpcy5kZWxldGVUZXh0dXJlKFQpfSxUfWRlbGV0ZVRleHR1cmUoTyl7Y29uc3QgZz1PLl9pbWc7dGhpcy5nbC5kZWxldGVUZXh0dXJlKE8pLHR5cGVvZiBnLmNsb3NlPT0iZnVuY3Rpb24iJiZnLmNsb3NlKCl9YXN5bmMgbG9hZFRleHR1cmUoTyx7dXNlSW1hZ2VCaXRtYXA6Zz0hMH09e30pe2NvbnN0IHA9YXdhaXQgeC5sb2FkSW1hZ2UoTyx7dXNlSW1hZ2VCaXRtYXA6Z30pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUocCl9Y3JlYXRlRkJPKHtjb2xvcjpPPTEsYmxlbmQ6Zz0hMSxkZXB0aDpwPXRoaXMub3B0aW9ucy5kZXB0aCE9PSExLHN0ZW5jaWw6bj0hIXRoaXMub3B0aW9ucy5zdGVuY2lsfT17fSl7Y29uc3QgYT10aGlzLmdsLGk9YS5jcmVhdGVGcmFtZWJ1ZmZlcigpO2EuYmluZEZyYW1lYnVmZmVyKGEuRlJBTUVCVUZGRVIsaSk7Y29uc3Qgbz1bXTtmb3IobGV0IEM9MDtDPE87QysrKXtjb25zdCBJPXRoaXMuY3JlYXRlVGV4dHVyZSgpO2EuZnJhbWVidWZmZXJUZXh0dXJlMkQoYS5GUkFNRUJVRkZFUixhLkNPTE9SX0FUVEFDSE1FTlQwK0MsYS5URVhUVVJFXzJELEksMCksby5wdXNoKEkpfWkudGV4dHVyZXM9byxpLnRleHR1cmU9b1swXSxpLmJsZW5kPWc7Y29uc3R7d2lkdGg6VCxoZWlnaHQ6QX09dGhpcy5jYW52YXM7cmV0dXJuIHAmJiFuJiYoaS5kZXB0aEJ1ZmZlcj1hLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLGEuYmluZFJlbmRlcmJ1ZmZlcihhLlJFTkRFUkJVRkZFUixpLmRlcHRoQnVmZmVyKSxhLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYS5SRU5ERVJCVUZGRVIsYS5ERVBUSF9DT01QT05FTlQxNixULEEpLGEuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoYS5GUkFNRUJVRkZFUixhLkRFUFRIX0FUVEFDSE1FTlQsYS5SRU5ERVJCVUZGRVIsaS5kZXB0aEJ1ZmZlcikpLG4mJiFwJiYoaS5zdGVuY2lsQnVmZmVyPWEuY3JlYXRlUmVuZGVyYnVmZmVyKCksYS5iaW5kUmVuZGVyYnVmZmVyKGEuUkVOREVSQlVGRkVSLGkuc3RlbmNpbEJ1ZmZlciksYS5yZW5kZXJidWZmZXJTdG9yYWdlKGEuUkVOREVSQlVGRkVSLGEuU1RFTkNJTF9JTkRFWDgsVCxBKSxhLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGEuRlJBTUVCVUZGRVIsYS5TVEVOQ0lMX0FUVEFDSE1FTlQsYS5SRU5ERVJCVUZGRVIsaS5zdGVuY2lsQnVmZmVyKSkscCYmbiYmKGkuZGVwdGhTdGVuY2lsQnVmZmVyPWEuY3JlYXRlUmVuZGVyYnVmZmVyKCksYS5iaW5kUmVuZGVyYnVmZmVyKGEuUkVOREVSQlVGRkVSLGkuZGVwdGhTdGVuY2lsQnVmZmVyKSxhLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYS5SRU5ERVJCVUZGRVIsYS5ERVBUSF9TVEVOQ0lMLFQsQSksYS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihhLkZSQU1FQlVGRkVSLGEuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULGEuUkVOREVSQlVGRkVSLGkuZGVwdGhTdGVuY2lsQnVmZmVyKSksYS5iaW5kRnJhbWVidWZmZXIoYS5GUkFNRUJVRkZFUixudWxsKSxpfWJpbmRGQk8oTz1udWxsKXt0aGlzLmZibz1PfXJlbmRlcih7Y2xlYXJCdWZmZXI6Tz0hMH09e30pe3RoaXMuc3RhcnRSZW5kZXI9ITA7Y29uc3QgZz10aGlzLmdsO2xldCBwPXRoaXMucHJvZ3JhbTtwfHwocD10aGlzLmNyZWF0ZVByb2dyYW0oKSx0aGlzLnVzZVByb2dyYW0ocCkpLHRoaXMuZmJvJiZnLmJpbmRGcmFtZWJ1ZmZlcihnLkZSQU1FQlVGRkVSLHRoaXMuZmJvKTtjb25zdCBuPXRoaXMub3B0aW9ucy5kZXB0aDtuJiZnLmVuYWJsZShnLkRFUFRIX1RFU1QpLHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUfChuP3RoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVDowKXwodGhpcy5vcHRpb25zLnN0ZW5jaWw/dGhpcy5nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ6MCkpO2NvbnN0IGE9dGhpcy5fcmVuZGVyRnJhbWVJRDt0aGlzLl9kcmF3KCksdGhpcy5mYm8mJmcuYmluZEZyYW1lYnVmZmVyKGcuRlJBTUVCVUZGRVIsbnVsbCksdGhpcy5fcmVuZGVyRnJhbWVJRD09PWEmJih0aGlzLl9yZW5kZXJGcmFtZUlEPW51bGwpfXVwZGF0ZSgpe3RoaXMuc3RhcnRSZW5kZXImJnRoaXMuX3JlbmRlckZyYW1lSUQ9PW51bGwmJih0aGlzLl9yZW5kZXJGcmFtZUlEPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKSl9fWMoeCwiZGVmYXVsdE9wdGlvbnMiLHtwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITAsYXV0b1VwZGF0ZTohMCx2ZXJ0ZXhQb3NpdGlvbjoiYV92ZXJ0ZXhQb3NpdGlvbiIsdmVydGV4VGV4dHVyZUNvb3JkOiJhX3ZlcnRleFRleHR1cmVDb29yZCIsd2ViZ2wyOiExfSksYyh4LCJVQllURSIseC5VTlNJR05FRF9CWVRFKSxjKHgsIlVTSE9SVCIseC5VTlNJR05FRF9TSE9SVCksYyh4LCJmZXRjaFNoYWRlciIsci5mZXRjaFNoYWRlciksYyh4LCJsb2FkSW1hZ2UiLHIubG9hZEltYWdlKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwic2V0dXBXZWJHTCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJjcmVhdGVQcm9ncmFtIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInBvaW50c1RvQnVmZmVyIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImxvYWRJbWFnZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmZXRjaFNoYWRlciIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKGYsdil7Y29uc3QgeD1bIndlYmdsIiwiZXhwZXJpbWVudGFsLXdlYmdsIiwid2Via2l0LTNkIiwibW96LXdlYmdsIl07bGV0IFI9bnVsbDtmb3IobGV0IE89MDtPPHgubGVuZ3RoOysrTyl7dHJ5e1I9Zi5nZXRDb250ZXh0KHhbT10sdil9Y2F0Y2h7fWlmKFIpYnJlYWt9cmV0dXJuIFJ9ZnVuY3Rpb24gcyhmLHYpe2NvbnN0IHg9cihmLHYpO2lmKCF4KXRocm93IG5ldyBFcnJvcigiU29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgV2ViR0wuIik7cmV0dXJuIHh9ZnVuY3Rpb24gbShmLHYseCl7Y29uc3QgUj1mLmNyZWF0ZVNoYWRlcihmLlZFUlRFWF9TSEFERVIpO2lmKGYuc2hhZGVyU291cmNlKFIsdiksZi5jb21waWxlU2hhZGVyKFIpLCFmLmdldFNoYWRlclBhcmFtZXRlcihSLGYuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBwPWBWZXJ0ZXggc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2YuZ2V0U2hhZGVySW5mb0xvZyhSKX1gO3Rocm93IG5ldyBFcnJvcihwKX1jb25zdCBPPWYuY3JlYXRlU2hhZGVyKGYuRlJBR01FTlRfU0hBREVSKTtpZihmLnNoYWRlclNvdXJjZShPLHgpLGYuY29tcGlsZVNoYWRlcihPKSwhZi5nZXRTaGFkZXJQYXJhbWV0ZXIoTyxmLkNPTVBJTEVfU1RBVFVTKSl7Y29uc3QgcD1gRnJhZ21lbnQgc2hhZGVyIGZhaWxlZCB0byBjb21waWxlLiAgVGhlIGVycm9yIGxvZyBpczoke2YuZ2V0U2hhZGVySW5mb0xvZyhPKX1gO3Rocm93IG5ldyBFcnJvcihwKX1jb25zdCBnPWYuY3JlYXRlUHJvZ3JhbSgpO2lmKGYuYXR0YWNoU2hhZGVyKGcsUiksZi5hdHRhY2hTaGFkZXIoZyxPKSxmLmxpbmtQcm9ncmFtKGcpLCFmLmdldFByb2dyYW1QYXJhbWV0ZXIoZyxmLkxJTktfU1RBVFVTKSl7Y29uc3QgcD1gU2hhZGVyIHByb2dyYW0gZmFpbGVkIHRvIGxpbmsuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zi5nZXRQcm9ncmFtSW5mb0xvZyhnKX1gO3Rocm93IG5ldyBFcnJvcihwKX1yZXR1cm4gZi5kZWxldGVTaGFkZXIoUiksZi5kZWxldGVTaGFkZXIoTyksZ31mdW5jdGlvbiB5KGYsdj1GbG9hdDMyQXJyYXkseD1udWxsKXtpZih4JiYhKHggaW5zdGFuY2VvZiB2KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJXcm9uZyBidWZmZXIgdHlwZS4iKTtpZihmPT1udWxsfHxmIGluc3RhbmNlb2YgdilyZXR1cm4gZjtpZihmWzBdPT1udWxsfHxmWzBdLmxlbmd0aD09bnVsbClyZXR1cm4geD8oeC5zZXQoZiwwKSx4KTpuZXcgdihmKTtjb25zdCBSPWZbMF0ubGVuZ3RoLE89Zi5sZW5ndGg7eHx8KHg9bmV3IHYoUipPKSk7bGV0IGc9MDtmb3IobGV0IHA9MDtwPE87cCsrKWZvcihsZXQgbj0wO248UjtuKyspeFtnKytdPWZbcF1bbl07cmV0dXJuIHh9Y29uc3QgYz17fTtmdW5jdGlvbiBsKGYse3VzZUltYWdlQml0bWFwOnY9ITAsYWxpYXM6eD1udWxsfT17fSl7aWYoIWNbZl0pe2lmKHR5cGVvZiBJbWFnZT09ImZ1bmN0aW9uIil7Y29uc3QgUj1uZXcgSW1hZ2U7dHlwZW9mIGY9PSJzdHJpbmciJiYhKHR5cGVvZiBsb2NhdGlvbj09Im9iamVjdCImJi9eZmlsZTovLnRlc3QobG9jYXRpb24uaHJlZikpJiYhL15kYXRhOi8udGVzdChmKSYmKFIuY3Jvc3NPcmlnaW49ImFub255bW91cyIpLGNbZl09bmV3IFByb21pc2UoTz0+e1Iub25sb2FkPWZ1bmN0aW9uKCl7diYmdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwPT0iZnVuY3Rpb24iP2NyZWF0ZUltYWdlQml0bWFwKFIse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oZz0+e2NbZl09Zyx4JiYoY1t4XT1nKSxPKGcpfSk6KGNbZl09Uix4JiYoY1t4XT1SKSxPKFIpKX0sUi5zcmM9Zn0pLHgmJihjW3hdPWNbZl0pfWVsc2UgaWYodHlwZW9mIGZldGNoPT0iZnVuY3Rpb24iKXJldHVybiBmZXRjaChmLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkudGhlbihSPT5SLmJsb2IoKSkudGhlbihSPT5jcmVhdGVJbWFnZUJpdG1hcChSLHtpbWFnZU9yaWVudGF0aW9uOiJmbGlwWSJ9KS50aGVuKE89PihjW2ZdPU8seCYmKGNbeF09TyksTykpKX1yZXR1cm4gY1tmXX1jb25zdCB1PXt9O2FzeW5jIGZ1bmN0aW9uIE0oZil7aWYodVtmXSlyZXR1cm4gdVtmXTtjb25zdCB2PWF3YWl0IGZldGNoKGYpO2lmKHYuc3RhdHVzPj0yMDAmJnYuc3RhdHVzPDMwMCl7Y29uc3QgeD1hd2FpdCB2LnRleHQoKTtyZXR1cm4gdVtmXT14LHh9dGhyb3cgbmV3IEVycm9yKCJTaGFkZXIgbG9hZGVkIGVycm9yLiIpfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gdmVjNChhX3ZlcnRleFBvc2l0aW9uLCAxKTsKfWB9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWAjaWZkZWYgR0xfRVMKcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4xKTsKfWB9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBhdHRyaWJ1dGUgdmVjNCBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7Cgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwogIGdsX1Bvc2l0aW9uID0gYV92ZXJ0ZXhQb3NpdGlvbjsKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7Cn1gfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB5fSk7dmFyIHI9dCgyMSkscz10KDI1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgbT1TeW1ib2woInRyYW5zZm9ybSIpO2NsYXNzIHl7Y29uc3RydWN0b3IobCx1KXt0aGlzLmNvbnRleHQ9bC5nZXRDb250ZXh0KCIyZCIpLHRoaXMub3B0aW9ucz11LHRoaXNbbV09WzEsMCwwLDEsMCwwXX1jcmVhdGVUZXh0dXJlKGwpe3JldHVybntfaW1nOmx9fWFzeW5jIGxvYWRUZXh0dXJlKGwpe2NvbnN0IHU9YXdhaXQgci5kZWZhdWx0LmxvYWRJbWFnZShsLHt1c2VJbWFnZUJpdG1hcDohMX0pO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmUodSl9ZGVsZXRlVGV4dHVyZShsKXtyZXR1cm4gbH1jbGVhcihsLHUsTSxmKXtjb25zdCB2PXRoaXMuY29udGV4dDtsPWx8fDAsdT11fHwwLE09TXx8di5jYW52YXMud2lkdGgtbCxmPWZ8fHYuY2FudmFzLmhlaWdodC11LHYuY2xlYXJSZWN0KGwsdSxNLGYpfWRyYXdNZXNoQ2xvdWQobCx7Y2xlYXI6dT0hMX09e30pe2NvbnN0IE09W107Zm9yKGxldCBmPTA7ZjxsLmFtb3VudDtmKyspe2NvbnN0IHY9bC5nZXRUcmFuc2Zvcm0oZik7bGV0IHg9bC5nZXRUZXh0dXJlRnJhbWUoZik7eCYmKHg9eC5faW1nKTtjb25zdCBSPWwuZ2V0RmlsdGVyKGYpLHtmaWxsOk8sc3Ryb2tlOmd9PWwuZ2V0Q2xvdWRSR0JBKGYpO00ucHVzaCh7bWVzaDpsLm1lc2gsX2Nsb3VkT3B0aW9uczpbTyxnLHgsdixSXX0pfWwuYmVmb3JlUmVuZGVyJiZsLmJlZm9yZVJlbmRlcih0aGlzLmNvbnRleHQsbCksdGhpcy5kcmF3TWVzaGVzKE0se2NsZWFyOnUsaG9vazohMX0pLGwuYWZ0ZXJSZW5kZXImJmwuYWZ0ZXJSZW5kZXIodGhpcy5jb250ZXh0LGwpfWRyYXdNZXNoZXMobCx7Y2xlYXI6dT0hMSxob29rOk09ITB9PXt9KXtjb25zdCBmPXRoaXMuY29udGV4dDt1JiZmLmNsZWFyUmVjdCgwLDAsZi5jYW52YXMud2lkdGgsZi5jYW52YXMuaGVpZ2h0KTtsZXQgdj1udWxsO2NvbnN0e3dpZHRoOngsaGVpZ2h0OlJ9PWYuY2FudmFzLE89bC5sZW5ndGg7bC5mb3JFYWNoKChnLHApPT57bGV0IG4sYSxpLG8sVDtNJiZnLmJlZm9yZVJlbmRlciYmZy5iZWZvcmVSZW5kZXIoZixnKSxnLl9jbG91ZE9wdGlvbnMmJihbbixhLGksbyxUXT1nLl9jbG91ZE9wdGlvbnMsZz1nLm1lc2gpO2xldCBBPWcuZmlsdGVyO2lmKFQmJihBPUE/YCR7QX0gJHtUfWA6VCksQSYmIXRoaXMuZmlsdGVyQnVmZmVyJiZ0aGlzLmZpbHRlckJ1ZmZlciE9PSExKXtjb25zdCBDPXIuZGVmYXVsdC5jcmVhdGVDYW52YXMoeCxSKTtDP3RoaXMuZmlsdGVyQnVmZmVyPUMuZ2V0Q29udGV4dCgiMmQiKTp0aGlzLmZpbHRlckJ1ZmZlcj0hMX12JiZ2IT09QSYmKE9iamVjdChzLmFwcGx5RmlsdGVyKSh0aGlzLmZpbHRlckJ1ZmZlcix2KSxmLmRyYXdJbWFnZSh0aGlzLmZpbHRlckJ1ZmZlci5jYW52YXMsMCwwLHgsUiksdGhpcy5maWx0ZXJCdWZmZXIuY2xlYXJSZWN0KDAsMCx4LFIpLHY9bnVsbCksQSYmdGhpcy5maWx0ZXJCdWZmZXI/KHRoaXMuZmlsdGVyQnVmZmVyLnNhdmUoKSx0aGlzLmZpbHRlckJ1ZmZlci50cmFuc2Zvcm0oLi4udGhpc1ttXSksT2JqZWN0KHMuZHJhd01lc2gyRCkoZyx0aGlzLmZpbHRlckJ1ZmZlciwhMSxuLGEsaSxvKSx0aGlzLmZpbHRlckJ1ZmZlci5yZXN0b3JlKCkscD09PU8tMT8oT2JqZWN0KHMuYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLEEpLGYuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAseCxSKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHgsUikpOnY9QSk6KGYuc2F2ZSgpLGYudHJhbnNmb3JtKC4uLnRoaXNbbV0pLE9iamVjdChzLmRyYXdNZXNoMkQpKGcsZiwhMSxuLGEsaSxvKSxmLnJlc3RvcmUoKSksTSYmZy5hZnRlclJlbmRlciYmZy5hZnRlclJlbmRlcihmLGcpfSl9c2V0VHJhbnNmb3JtKGwpe3RoaXNbbV09bH19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLChmdW5jdGlvbihyKXt2YXIgcz10KDE0KSxtPXQoMjMpLHk9dCgyNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9e307ZnVuY3Rpb24gbCh4LFIpe2NvbnN0e3N0eWxlOk8sdmFyaWFudDpnLHdlaWdodDpwLHN0cmV0Y2g6bixzaXplOmEscHhMaW5lSGVpZ2h0OmksZmFtaWx5Om99PXg7cmV0dXJuIG49PT0ibm9ybWFsIj9gJHtPfSAke2d9ICR7cH0gJHthKlJ9cHgvJHtpKlJ9cHggJHtvfWA6YCR7T30gJHtnfSAke3B9ICR7bn0gJHthKlJ9cHgvJHtpKlJ9cHggJHtvfWB9ZnVuY3Rpb24gdSh4LHtmb250OlIsZmlsbENvbG9yOk8sc3Ryb2tlQ29sb3I6ZyxzdHJva2VXaWR0aDpwLHJhdGlvOm49MSx0ZXh0Q2FudmFzOmEsY2FjaGFibGU6aT0hMX0pe2xldCBvO2lmKGkpe289W3gsUixTdHJpbmcoTyksU3RyaW5nKGcpLFN0cmluZyhwKV0uam9pbigiIyMjIik7Y29uc3Qgdz1jW29dO2lmKHcpcmV0dXJuIHd9YXx8KGE9ZigxLDEpKTtjb25zdCBUPWEuZ2V0Q29udGV4dCgiMmQiKTtULnNhdmUoKSxULmZvbnQ9UjtsZXR7d2lkdGg6QX09VC5tZWFzdXJlVGV4dCh4KTtULnJlc3RvcmUoKTtjb25zdCBDPU9iamVjdChtLmRlZmF1bHQpKFIpLEk9TWF0aC5tYXgoQy5weExpbmVIZWlnaHQsQy5weEhlaWdodCoxLjEzKTsvaXRhbGljfG9ibGlxdWUvLnRlc3QoUikmJihBKz1JKk1hdGgudGFuKDE1Kk1hdGguUEkvMTgwKSksIU8mJiFnJiYoTz0iIzAwMCIpO2NvbnN0IFA9VC5jYW52YXMsTD1NYXRoLmNlaWwoQSksRD1NYXRoLmNlaWwoSSk7UC53aWR0aD1NYXRoLnJvdW5kKEwqbiksUC5oZWlnaHQ9TWF0aC5yb3VuZChEKm4pLFQuc2F2ZSgpLFQuZm9udD1sKEMsbiksVC50ZXh0QWxpZ249ImNlbnRlciIsVC50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgYj1QLmhlaWdodCouNStDLnB4SGVpZ2h0Ki4wNSpuLFM9UC53aWR0aCouNTtpZihPKXtpZihBcnJheS5pc0FycmF5KE8pKU89T2JqZWN0KHkuZGVmYXVsdCkoTyk7ZWxzZSBpZihPLnZlY3Rvcil7bGV0IHc7Y29uc3R7dmVjdG9yOkgsY29sb3JzOkp9PU87SC5sZW5ndGg9PT02P3c9VC5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5IKTp3PVQuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSCksSi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6V30pPT57dy5hZGRDb2xvclN0b3AocSxXKX0pLE89d31ULmZpbGxTdHlsZT1PLFQuZmlsbFRleHQoeCxTLGIpfWlmKGcpe2lmKFQubGluZVdpZHRoPXAqbixBcnJheS5pc0FycmF5KGcpKWc9T2JqZWN0KHkuZGVmYXVsdCkoZyk7ZWxzZSBpZihnLnZlY3Rvcil7bGV0IHc7Y29uc3R7dmVjdG9yOkgsY29sb3JzOkp9PWc7SC5sZW5ndGg9PT02P3c9VC5jcmVhdGVSYWRpYWxHcmFkaWVudCguLi5IKTp3PVQuY3JlYXRlTGluZWFyR3JhZGllbnQoLi4uSCksSi5mb3JFYWNoKCh7b2Zmc2V0OnEsY29sb3I6V30pPT57dy5hZGRDb2xvclN0b3AocSxXKX0pLGc9d31ULnN0cm9rZVN0eWxlPWcsVC5zdHJva2VUZXh0KHgsUyxiKX1ULnJlc3RvcmUoKTtjb25zdCBCPXtpbWFnZTphLHJlY3Q6WzAsMCxMLERdfTtyZXR1cm4gaSYmKGNbb109QiksQn1sZXQgTT0hMTtpZih0eXBlb2YgbmF2aWdhdG9yPT0ib2JqZWN0IiYmdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQ9PSJzdHJpbmciKXtjb25zdCB4PW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvY2hyb21lXC8oXGQrKS8pO3gmJihNPU51bWJlcih4WzFdKTw3MCl9ZnVuY3Rpb24gZih4LFIsTz17fSl7Y29uc3QgZz1PLm9mZnNjcmVlbnx8IU0mJk8ub2Zmc2NyZWVuIT09ITE7bGV0IHA7cmV0dXJuIHR5cGVvZiByPCJ1IiYmdHlwZW9mIHIuY3JlYXRlQ2FudmFzPT0iZnVuY3Rpb24iP3A9ci5jcmVhdGVDYW52YXMoeCxSLE8pOmcmJnR5cGVvZiBPZmZzY3JlZW5DYW52YXM9PSJmdW5jdGlvbiI/cD1uZXcgT2Zmc2NyZWVuQ2FudmFzKHgsUik6KHA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIikscC53aWR0aD14LHAuaGVpZ2h0PVIpLHB9Y29uc3Qgdj17Y3JlYXRlQ2FudmFzOmYsY3JlYXRlVGV4dDp1LGxvYWRJbWFnZTpzLmRlZmF1bHQubG9hZEltYWdlfTtlLmRlZmF1bHQ9dn0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGgsZSl7dmFyIHQ7dD1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXt0PXR8fG5ldyBGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpfWNhdGNoe3R5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiYodD13aW5kb3cpfWguZXhwb3J0cz10fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBPfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoZyxwKXtpZih0eXBlb2YgZz09InN0cmluZyIpe2NvbnN0IGk9Zy50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSkkLyk7aT9nPXtzaXplOnBhcnNlRmxvYXQoaVsxXSksdW5pdDppWzJdfTpnPXtzaXplOnBhcnNlSW50KGcsMTApLHVuaXQ6InB4In19bGV0e3NpemU6bix1bml0OmF9PWc7aWYoYT09PSJwdCIpbi89Ljc1O2Vsc2UgaWYoYT09PSJwYyIpbio9MTY7ZWxzZSBpZihhPT09ImluIiluKj05NjtlbHNlIGlmKGE9PT0iY20iKW4qPTk2LzIuNTQ7ZWxzZSBpZihhPT09Im1tIiluKj05Ni8yNS40O2Vsc2UgaWYoYT09PSJlbSJ8fGE9PT0icmVtInx8YT09PSJleCIpe2lmKCFwJiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgaT1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7cD1yKGksMTYpfW4qPXAsYT09PSJleCImJihuLz0yKX1lbHNlIGlmKGE9PT0icSIpbio9OTYvMjUuNC80O2Vsc2UgaWYoYT09PSJ2dyJ8fGE9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBpPWE9PT0idnciP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O24qPWkvMTAwfX1lbHNlIGlmKChhPT09InZtYXgifHxhPT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgaT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsbz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2E9PT0idm1heCI/bio9TWF0aC5tYXgoaSxvKS8xMDA6bio9TWF0aC5taW4oaSxvKS8xMDB9cmV0dXJuIG59Y29uc3Qgcz0iYm9sZHxib2xkZXJ8bGlnaHRlcnxbMS05XTAwIixtPSJpdGFsaWN8b2JsaXF1ZSIseT0ic21hbGwtY2FwcyIsYz0idWx0cmEtY29uZGVuc2VkfGV4dHJhLWNvbmRlbnNlZHxjb25kZW5zZWR8c2VtaS1jb25kZW5zZWR8c2VtaS1leHBhbmRlZHxleHBhbmRlZHxleHRyYS1leHBhbmRlZHx1bHRyYS1leHBhbmRlZCIsbD0icHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWlufCUiLHU9YCcoW14nXSspJ3wiKFteIl0rKSJ8KFtcXHctXXxb5LiALem+pV0pK2AsTT1uZXcgUmVnRXhwKGAoJHtzfSkgK2AsImkiKSxmPW5ldyBSZWdFeHAoYCgke219KSArYCwiaSIpLHY9bmV3IFJlZ0V4cChgKCR7eX0pICtgLCJpIikseD1uZXcgUmVnRXhwKGAoJHtjfSkgK2AsImkiKSxSPW5ldyBSZWdFeHAoIihbXFxkXFwuXSspKCIrbCsiKSg/OlxcLyhbXFxkXFwuXSspKCIrbCsiKSk/ICooKD86Iit1KyIpKCAqLCAqKD86Iit1KyIpKSopIik7ZnVuY3Rpb24gTyhnLHApe2NvbnN0IG49Ui5leGVjKGcpO2lmKCFuKXJldHVybjtjb25zdCBhPXBhcnNlRmxvYXQoblszXSksaT17d2VpZ2h0OiJub3JtYWwiLHN0eWxlOiJub3JtYWwiLHN0cmV0Y2g6Im5vcm1hbCIsdmFyaWFudDoibm9ybWFsIixzaXplOnBhcnNlRmxvYXQoblsxXSksdW5pdDpuWzJdLGxpbmVIZWlnaHQ6TnVtYmVyLmlzRmluaXRlKGEpP2E6dm9pZCAwLGxpbmVIZWlnaHRVbml0Om5bNF0sZmFtaWx5Om5bNV0ucmVwbGFjZSgvICosICovZywiLCIpfSxvPWcuc3Vic3RyaW5nKDAsbi5pbmRleCksVD1NLmV4ZWMobyksQT1mLmV4ZWMobyksQz12LmV4ZWMobyksST14LmV4ZWMobyk7cmV0dXJuIFQmJihpLndlaWdodD1UWzFdKSxBJiYoaS5zdHlsZT1BWzFdKSxDJiYoaS52YXJpYW50PUNbMV0pLEkmJihpLnN0cmV0Y2g9SVsxXSksaS5weEhlaWdodD1yKHtzaXplOmkuc2l6ZSx1bml0OmkudW5pdH0scCksaS5weExpbmVIZWlnaHQ9cih7c2l6ZTppLmxpbmVIZWlnaHR8fGkuc2l6ZSx1bml0OmkubGluZUhlaWdodFVuaXR8fGkudW5pdH0scCksaX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihzKXtyZXR1cm5gcmdiYSgke3MubWFwKChtLHkpPT55PDM/TWF0aC5yb3VuZChtKjI1NSk6bSkuam9pbigpfSlgfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiYXBwbHlGaWx0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZHJhd01lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMSkscz10KDI0KSxtPXQoMjMpLHk9dCgyNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGMoTSxmKXtjb25zdCB2PU0uY2FudmFzO00uc2F2ZSgpLE0uZmlsdGVyPWYsTS5kcmF3SW1hZ2UodiwwLDAsdi53aWR0aCx2LmhlaWdodCksTS5yZXN0b3JlKCl9ZnVuY3Rpb24gbChNLGYpe2NvbnN0IHY9L3JnYmFcKChcZCspLChcZCspLChcZCspLChcZCspXCkvO009TS5tYXRjaCh2KS5zbGljZSgxLDUpLm1hcChOdW1iZXIpLGY9Zi5tYXRjaCh2KS5zbGljZSgxLDUpLm1hcChOdW1iZXIpO2NvbnN0IHg9W10sUj1mWzNdO2ZvcihsZXQgTz0wO088NDtPKyspeFtPXT1PYmplY3QoeS5taXgpKE1bT10sZltPXSxSKTtyZXR1cm5gcmdiYSgke3guam9pbigpfSlgfWZ1bmN0aW9uIHUoTSxmLHY9ITAseD1udWxsLFI9bnVsbCxPPW51bGwsZz1udWxsKXtmLnNhdmUoKTtsZXQgcD0hMSxuPSExO2lmKGYuZ2xvYmFsQWxwaGE9TS5nZXRPcGFjaXR5KCksTS5fdXBkYXRlTWF0cml4JiZNLnRyYW5zZm9ybVNjYWxlL00uY29udG91cnMuc2NhbGU+MS41JiZNLmFjY3VyYXRlKE0udHJhbnNmb3JtU2NhbGUpLE0ubGluZVdpZHRoKXtsZXQgbz1NLmdyYWRpZW50JiZNLmdyYWRpZW50LnN0cm9rZTtpZihvKXtjb25zdHt2ZWN0b3I6VCxjb2xvcnM6QX09bztpZihULmxlbmd0aD09PTYpbz1mLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLlQpO2Vsc2UgaWYoVC5sZW5ndGg9PT00KW89Zi5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5UKTtlbHNlIGlmKFQubGVuZ3RoPT09MylvPWYuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5UKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtBLmZvckVhY2goKHtvZmZzZXQ6Qyxjb2xvcjpJfSk9PntsZXQgUD1PYmplY3Qocy5kZWZhdWx0KShJKTtSJiYoUD1sKFAsUikpLG8uYWRkQ29sb3JTdG9wKEMsUCl9KSxmLnN0cm9rZVN0eWxlPW8scD0hMH1lbHNlIE0uc3Ryb2tlU3R5bGUmJihSP2Yuc3Ryb2tlU3R5bGU9bChNLnN0cm9rZVN0eWxlLFIpOmYuc3Ryb2tlU3R5bGU9TS5zdHJva2VTdHlsZSxwPSEwKX1wJiYoZi5saW5lV2lkdGg9TS5saW5lV2lkdGgsZi5saW5lSm9pbj1NLmxpbmVKb2luLGYubGluZUNhcD1NLmxpbmVDYXAsZi5taXRlckxpbWl0PU0ubWl0ZXJMaW1pdCxNLmxpbmVEYXNoJiYoZi5zZXRMaW5lRGFzaChNLmxpbmVEYXNoKSxNLmxpbmVEYXNoT2Zmc2V0JiYoZi5saW5lRGFzaE9mZnNldD1NLmxpbmVEYXNoT2Zmc2V0KSkpO2xldCBhPU0uZ3JhZGllbnQmJk0uZ3JhZGllbnQuZmlsbDtpZihhKXtjb25zdHt2ZWN0b3I6byxjb2xvcnM6VH09YTtpZihvLmxlbmd0aD09PTYpYT1mLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLm8pO2Vsc2UgaWYoby5sZW5ndGg9PT00KWE9Zi5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5vKTtlbHNlIGlmKG8ubGVuZ3RoPT09MylhPWYuY3JlYXRlQ2lyY3VsYXJHcmFkaWVudCguLi5vKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmVjdG9yIGRpbWVuc2lvbi4iKTtULmZvckVhY2goKHtvZmZzZXQ6QSxjb2xvcjpDfSk9PntsZXQgST1PYmplY3Qocy5kZWZhdWx0KShDKTtSJiYoST1sKEksUikpLGEuYWRkQ29sb3JTdG9wKEEsSSl9KSxmLmZpbGxTdHlsZT1hLG49ITB9ZWxzZSBNLmZpbGxTdHlsZSYmKHg/Zi5maWxsU3R5bGU9bChNLmZpbGxTdHlsZSx4KTpmLmZpbGxTdHlsZT1NLmZpbGxTdHlsZSxuPSEwKTtpZihnJiZmLnRyYW5zZm9ybSguLi5nKSxmLnRyYW5zZm9ybSguLi5NLnRyYW5zZm9ybU1hdHJpeCksTS5jbGlwUGF0aCl7Y29uc3Qgbz1NLmNsaXBQYXRoLFQ9bmV3IFBhdGgyRChvKTtmLmNsaXAoVCl9Y29uc3QgaT1NLmNvbnRvdXJzLmxlbmd0aDtpZihNLmNvbnRvdXJzLmZvckVhY2goKG8sVCk9Pntjb25zdCBBPW8ubGVuZ3RoLEM9QT4xJiZyLnZlYzIuZXF1YWxzKG9bMF0sb1tBLTFdKSxJPVQ9PT1pLTEmJk0udGV4dHVyZTtpZihvJiZBPjApe2lmKG58fHB8fEkpe2YuYmVnaW5QYXRoKCksZi5tb3ZlVG8oLi4ub1swXSk7Zm9yKGxldCBQPTE7UDxBO1ArKylQPT09QS0xJiZDP2YuY2xvc2VQYXRoKCk6Zi5saW5lVG8oLi4ub1tQXSl9aWYobiYmZi5maWxsKE0uZmlsbFJ1bGUpLEkpe2Yuc2F2ZSgpLGYuY2xpcCgpO2xldHtpbWFnZTpQLG9wdGlvbnM6TH09TS50ZXh0dXJlO2lmKE8mJihQPU8pLEwucmVwZWF0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCBpbWFnZSByZXBlYXQgeWV0LiIpLFAuZm9udCl7TC5zY2FsZSYmY29uc29sZS53YXJuKCJDb250ZXh0IDJEIG5vdCBzdXBwb3J0ZWQgdGV4dCBzY2FsZSB5ZXQuIiksTC5zcmNSZWN0JiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNyY1JlY3QgeWV0LiIpO2xldHtmb250OkQsZmlsbENvbG9yOmIsc3Ryb2tlQ29sb3I6UyxzdHJva2VXaWR0aDpCLHRleHQ6d309UDshYiYmIVMmJihiPSIjMDAwIiksQXJyYXkuaXNBcnJheShiKSYmKGI9T2JqZWN0KHMuZGVmYXVsdCkoYikpLEFycmF5LmlzQXJyYXkoUykmJihTPU9iamVjdChzLmRlZmF1bHQpKFMpKSxmLmZvbnQ9RDtjb25zdHt3aWR0aDpIfT1mLm1lYXN1cmVUZXh0KHcpLEo9T2JqZWN0KG0uZGVmYXVsdCkoRCkscT1NYXRoLm1heChKLnB4TGluZUhlaWdodCxKLnB4SGVpZ2h0KjEuMTMpO2YudGV4dEFsaWduPSJjZW50ZXIiLGYudGV4dEJhc2VsaW5lPSJtaWRkbGUiO2NvbnN0IFc9TC5yZWN0LEc9V1swXStxKi41K0oucHhIZWlnaHQqLjA2LFE9V1sxXStIKi41O1dbMl0hPW51bGwmJmYuc2NhbGUoV1syXS9ILFdbM10vcSksYiYmKGYuZmlsbFN0eWxlPWIsZi5maWxsVGV4dCh3LFEsRykpLFMmJihmLmxpbmVXaWR0aD1CLGYuc3Ryb2tlU3R5bGU9UyxmLnN0cm9rZVRleHQodyxRLEcpKX1lbHNle2xldCBEPUwucmVjdDtjb25zdCBiPUwuc3JjUmVjdDtMLnNjYWxlJiYoRD1bMCwwLGYuY2FudmFzLndpZHRoLGYuY2FudmFzLmhlaWdodF0pLEwucm90YXRlZCYmRCYmKEQ9Wy1EWzFdLERbMF0sRFszXSxEWzJdXSksYiYmKEQ9RHx8WzAsMCxiWzJdLGJbM11dKSxMLnJvdGF0ZWQmJihmLnRyYW5zbGF0ZSgwLEQ/RFsyXTpQLndpZHRoKSxmLnJvdGF0ZSgtLjUqTWF0aC5QSSkpLGI/Zi5kcmF3SW1hZ2UoUCwuLi5iLC4uLkQpOkQ/Zi5kcmF3SW1hZ2UoUCwuLi5EKTpmLmRyYXdJbWFnZShQLDAsMCl9Zi5yZXN0b3JlKCl9cCYmZi5zdHJva2UoKX19KSxmLnJlc3RvcmUoKSx2KXtjb25zdCBvPU0uZmlsdGVyO28mJmMoZixvKX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjbGFtcCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJtaXgiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwidHJhbnNmb3JtUG9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcih5LGMsbCl7cmV0dXJuIGM+bCYmKFtjLGxdPVtsLGNdKSx5PGM/Yzp5Pmw/bDp5fWZ1bmN0aW9uIHMoeSxjLGwpe3JldHVybiB5KigxLWwpK2MqbH1mdW5jdGlvbiBtKHksYyl7Y29uc3RbbCx1XT15O3JldHVybltsKmNbMF0rdSpjWzJdK2NbNF0sbCpjWzFdK3UqY1szXStjWzVdXX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgcj10KDI4KSxzPXQoMjkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBtKHUsTSxmKXtjb25zdCB2PXUudW5pZm9ybXN8fHt9LHg9TS51bmlmb3Jtc3x8e307aWYodi51X3RleFNhbXBsZXImJngudV90ZXhTYW1wbGVyJiZ2LnVfdGV4U2FtcGxlciE9PXgudV90ZXhTYW1wbGVyKXJldHVybiExO2NvbnN0IFI9T2JqZWN0LmtleXModiksTz1PYmplY3Qua2V5cyh4KSxnPVIuaW5kZXhPZigidV90ZXhTYW1wbGVyIikscD1PLmluZGV4T2YoInVfdGV4U2FtcGxlciIpO2lmKGc+PTAmJlIuc3BsaWNlKGcsMSkscD49MCYmTy5zcGxpY2UocCwxKSxSLmxlbmd0aCE9PU8ubGVuZ3RoKXJldHVybiExO2NvbnN0IG49Ui5ldmVyeShhPT57Y29uc3QgaT12W2FdLG89eFthXTtpZihpPT09bylyZXR1cm4hMDtpZihpLmxlbmd0aCYmby5sZW5ndGgmJmkubGVuZ3RoPT09by5sZW5ndGgpe2ZvcihsZXQgVD0wO1Q8aS5sZW5ndGg7VCsrKWlmKGlbVF0hPT1vW1RdKXJldHVybiExO3JldHVybiEwfXJldHVybiExfSk7aWYobil7aWYodi51X3RleFNhbXBsZXImJiF4LnVfdGV4U2FtcGxlcilNLnNldFRleHR1cmUodi51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pO2Vsc2UgaWYoIXYudV90ZXhTYW1wbGVyJiZ4LnVfdGV4U2FtcGxlcilmb3IobGV0IGE9MDthPGYubGVuZ3RoO2ErKylmW2FdLnNldFRleHR1cmUoeC51X3RleFNhbXBsZXIse2hpZGRlbjohMH0pfXJldHVybiBufWNvbnN0IHk9e307ZnVuY3Rpb24gYyh1LE0pe2lmKHUubGVuZ3RoKXtjb25zdCBmPU9iamVjdChyLmRlZmF1bHQpKHUseSk7cmV0dXJuIGYuZW5hYmxlQmxlbmQ9TSx1WzBdLmZpbHRlckNhbnZhcyYmKGYuZmlsdGVyQ2FudmFzPSEwKSxmLnBhY2tJbmRleD11WzBdLnBhY2tJbmRleCxmLnBhY2tMZW5ndGg9dS5sZW5ndGgsZi5iZWZvcmVSZW5kZXI9dVswXS5iZWZvcmVSZW5kZXIsZi5wYXNzPXVbMF0ucGFzcyxmLmFmdGVyUmVuZGVyPXVbdS5sZW5ndGgtMV0uYWZ0ZXJSZW5kZXIsdS5sZW5ndGg9MCxmfX1mdW5jdGlvbipsKHUsTSxmPSExKXtjb25zdCB2PVtdLHg9dS5vcHRpb25zLmJ1ZmZlclNpemU7bGV0IFI9MCxPPSExO2ZvcihsZXQgZz0wO2c8TS5sZW5ndGg7ZysrKXtjb25zdCBwPU1bZ107aWYocCBpbnN0YW5jZW9mIHMuZGVmYXVsdCl2Lmxlbmd0aCYmKHlpZWxkIGModixPKSksUj0wLE89ITEseWllbGQgcDtlbHNle2NvbnN0IG49cC5tZXNoRGF0YTtpZihuLmNsaXBQYXRoJiYhbi51bmlmb3Jtcy51X2NsaXBTYW1wbGVyKXtjb25zdCBpPXUuY3JlYXRlVGV4dHVyZShuLmNsaXBQYXRoKTtuLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI9aX1sZXQgYT0wO2lmKCghZnx8IXAuY2FuSWdub3JlKCkpJiZuJiZuLnBvc2l0aW9ucy5sZW5ndGgpe3AucGFja0luZGV4PWc7Y29uc3QgaT1wLmZpbHRlckNhbnZhcztpZihhPW4ucG9zaXRpb25zLmxlbmd0aCxpfHxSK2E+eCl2Lmxlbmd0aCYmKHlpZWxkIGModixPKSksUj0wLE89ITE7ZWxzZSBpZihSKXtjb25zdCBvPXZbdi5sZW5ndGgtMV07byYmKG8uZmlsdGVyQ2FudmFzfHxvLmFmdGVyUmVuZGVyfHxwLmJlZm9yZVJlbmRlcnx8by5wYXNzLmxlbmd0aHx8cC5wYXNzLmxlbmd0aHx8by5wcm9ncmFtIT09cC5wcm9ncmFtfHwhbShvLHAsdikpJiYoeWllbGQgYyh2LE8pLFI9MCxPPSExKX12LnB1c2gocCksTz1PfHxwLmVuYWJsZUJsZW5kLFIrPWF9Zz09PU0ubGVuZ3RoLTEmJnYubGVuZ3RoJiYoeWllbGQgYyh2LE8pKX19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPXtVTlNJR05FRF9CWVRFOlVpbnQ4QXJyYXksVU5TSUdORURfU0hPUlQ6VWludDE2QXJyYXksQllURTpJbnQ4QXJyYXksU0hPUlQ6SW50MTZBcnJheSxGTE9BVDpGbG9hdDMyQXJyYXl9O2Z1bmN0aW9uIHMoeSxjKXtsZXQgbD0wLHU9MCxNPTAsZj0wLHY9MCx4PTAsUj0wO2NvbnN0IE89eVswXS5wcm9ncmFtO2ZvcihsZXQgZz0wO2c8eS5sZW5ndGg7ZysrKXtjb25zdCBwPXlbZ10ubWVzaERhdGE7aWYocCl7Uis9cC5wb3NpdGlvbnMubGVuZ3RoO2NvbnN0IG49cC5wb3NpdGlvbnNbMF0ubGVuZ3RoO2wrPXAucG9zaXRpb25zLmxlbmd0aCpuLHUrPXAuY2VsbHMubGVuZ3RoKjMseCs9cC5hdHRyaWJ1dGVzLmFfY29sb3IubGVuZ3RoKjQ7Y29uc3QgYT1wLnRleHR1cmVDb29yZDthJiYoTSs9YS5sZW5ndGgqYVswXS5sZW5ndGgpO2NvbnN0IGk9cC5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDtpJiYoZis9aS5sZW5ndGgqNCk7Y29uc3Qgbz1wLmF0dHJpYnV0ZXMuYV9jbGlwVVY7byYmKHYrPW8ubGVuZ3RoKjIpfX1pZigoIWMucG9zaXRpb25zfHxjLnBvc2l0aW9ucy5sZW5ndGg8bCkmJihjLnBvc2l0aW9ucz1uZXcgRmxvYXQzMkFycmF5KGwpKSwoIWMuY2VsbHN8fGMuY2VsbHMubGVuZ3RoPHUpJiYoYy5jZWxscz1uZXcgVWludDE2QXJyYXkodSkpLE0mJighYy50ZXh0dXJlQ29vcmR8fGMudGV4dHVyZUNvb3JkLmxlbmd0aDxNKSYmKGMudGV4dHVyZUNvb3JkPW5ldyBGbG9hdDMyQXJyYXkoTSkpLCghYy5hX2NvbG9yfHxjLmFfY29sb3IubGVuZ3RoPHgpJiYoYy5hX2NvbG9yPW5ldyBVaW50OEFycmF5KHgpKSxmJiYoIWMuYV9zb3VyY2VSZWN0fHxjLmFfc291cmNlUmVjdC5sZW5ndGg8ZikmJihjLmFfc291cmNlUmVjdD1uZXcgRmxvYXQzMkFycmF5KGYpKSx2JiYoIWMuYV9jbGlwVVZ8fGMuYV9jbGlwVVYubGVuZ3RoPHYpJiYoYy5hX2NsaXBVVj1uZXcgRmxvYXQzMkFycmF5KHYpKSxPKXtjb25zdCBnPU9iamVjdC5lbnRyaWVzKE8uX2F0dHJpYnV0ZSkscD1PLl9hdHRyaWJPcHRzfHx7fTtmb3IobGV0IG49MDtuPGcubGVuZ3RoO24rKyl7Y29uc3RbYSxpXT1nW25dO2lmKGEhPT0iYV9jb2xvciImJmEhPT0iYV9zb3VyY2VSZWN0IiYmaSE9PSJpZ25vcmVkIil7Y29uc3Qgbz1wW2FdP3BbYV0udHlwZToiRkxPQVQiLFQ9cltvXSxBPWkuc2l6ZSpSOyghY1thXXx8Y1thXS5sZW5ndGg8QSkmJihjW2FdPW5ldyBUKEEpKX19fXJldHVybiBjfWZ1bmN0aW9uIG0oeSxjKXtsZXQgbD1bXSx1PVtdLE09W10sZj1bXSx2PVtdLHg9W10sUj0wLE89MDtjb25zdCBnPXlbMF0/eVswXS51bmlmb3Jtc3x8e306e30scD15WzBdP3lbMF0ucHJvZ3JhbTpudWxsO2MmJihzKHksYyksdT1jLmNlbGxzLGw9Yy5wb3NpdGlvbnMsTT1jLnRleHR1cmVDb29yZCxmPWMuYV9jb2xvcix2PWMuYV9zb3VyY2VSZWN0LHg9Yy5hX2NsaXBVVik7bGV0IG49ITEsYT0hMTtjb25zdCBpPXt9O2ZvcihsZXQgVD0wO1Q8eS5sZW5ndGg7VCsrKXtsZXQgQT15W1RdO2lmKEEpe2lmKEEubWVzaERhdGEmJihBPUEubWVzaERhdGEpLGMpe2NvbnN0IEk9QS5wb3NpdGlvbnM7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEw9SVtQXSxEPTMqKFIrUCk7Zm9yKGxldCBiPTA7YjxMLmxlbmd0aDtiKyspbFtEK2JdPUxbYl19fWVsc2UgbC5wdXNoKC4uLkEucG9zaXRpb25zKTtjb25zdCBDPUEuY2VsbHM7Zm9yKGxldCBJPTA7STxDLmxlbmd0aDtJKyspe2NvbnN0IFA9Q1tJXTtpZihjKXtjb25zdCBMPTMqKE8rSSk7dVtMXT1QWzBdK1IsdVtMKzFdPVBbMV0rUix1W0wrMl09UFsyXStSfWVsc2UgdS5wdXNoKFtQWzBdK1IsUFsxXStSLFBbMl0rUl0pfWlmKGMpe2NvbnN0IEk9QS5hdHRyaWJ1dGVzLmFfY29sb3I7Zm9yKGxldCBQPTA7UDxJLmxlbmd0aDtQKyspe2NvbnN0IEw9SVtQXSxEPTQqKFIrUCk7ZltEXT1MWzBdLGZbRCsxXT1MWzFdLGZbRCsyXT1MWzJdLGZbRCszXT1MWzNdfX1lbHNlIGYucHVzaCguLi5BLmF0dHJpYnV0ZXMuYV9jb2xvcik7aWYoQS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdClpZihuPSEwLGMpe2NvbnN0IEk9QS5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdDtmb3IobGV0IFA9MDtQPEkubGVuZ3RoO1ArKyl7Y29uc3QgTD1JW1BdLEQ9NCooUitQKTt2W0RdPUxbMF0sdltEKzFdPUxbMV0sdltEKzJdPUxbMl0sdltEKzNdPUxbM119fWVsc2Ugdi5wdXNoKC4uLkEuYXR0cmlidXRlcy5hX3NvdXJjZVJlY3QpO2lmKEEuYXR0cmlidXRlcy5hX2NsaXBVVilpZihhPSEwLGMpe2NvbnN0IEk9QS5hdHRyaWJ1dGVzLmFfY2xpcFVWO2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdCBMPUlbUF0sRD0yKihSK1ApO3hbRF09TFswXSx4W0QrMV09TFsxXX19ZWxzZSB4LnB1c2goLi4uQS5hdHRyaWJ1dGVzLmFfY2xpcFVWKTtpZihBLnRleHR1cmVDb29yZClpZihjKXtjb25zdCBJPUEudGV4dHVyZUNvb3JkO2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdCBMPUlbUF0sRD0zKihSK1ApO2ZvcihsZXQgYj0wO2I8TC5sZW5ndGg7YisrKU1bRCtiXT1MW2JdfX1lbHNlIE0ucHVzaCguLi5BLnRleHR1cmVDb29yZCk7aWYocCl7Y29uc3QgST1PYmplY3QuZW50cmllcyhwLl9hdHRyaWJ1dGUpO2ZvcihsZXQgUD0wO1A8SS5sZW5ndGg7UCsrKXtjb25zdFtMLERdPUlbUF07aWYoTCE9PSJhX2NvbG9yIiYmTCE9PSJhX3NvdXJjZVJlY3QiJiZEIT09Imlnbm9yZWQiKWlmKGlbTF09W10sYyl7aVtMXT1jW0xdO2NvbnN0IGI9QS5hdHRyaWJ1dGVzW0xdLFM9YlswXS5sZW5ndGg7Zm9yKGxldCBCPTA7QjxiLmxlbmd0aDtCKyspe2NvbnN0IHc9YltCXSxIPVMqKFIrQik7Zm9yKGxldCBKPTA7Sjx3Lmxlbmd0aDtKKyspaVtMXVtIK0pdPXdbSl19fWVsc2UgaVtMXS5wdXNoKC4uLkEuYXR0cmlidXRlc1tMXSl9fVIrPUEucG9zaXRpb25zLmxlbmd0aCxPKz1BLmNlbGxzLmxlbmd0aH19aS5hX2NvbG9yPWYsbiYmdiYmdi5sZW5ndGg+MCYmKGkuYV9zb3VyY2VSZWN0PXYpO2NvbnN0IG89e3Bvc2l0aW9uczpsLGNlbGxzOnUsYXR0cmlidXRlczppLHVuaWZvcm1zOmcsY2VsbHNDb3VudDpPKjMscHJvZ3JhbTpwfTtyZXR1cm4gTSYmTS5sZW5ndGgmJihvLnRleHR1cmVDb29yZD1NKSxhJiZ4Lmxlbmd0aD4wJiYoaS5hX2NsaXBVVj14KSxvfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKTt2YXIgcj10KDEpLHM9dCgzMCksbT10KDI2KSx5PXQoMzEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBjKGksbyl7dmFyIFQ9T2JqZWN0LmtleXMoaSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEE9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhpKTtvJiYoQT1BLmZpbHRlcihmdW5jdGlvbihDKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLEMpLmVudW1lcmFibGV9KSksVC5wdXNoLmFwcGx5KFQsQSl9cmV0dXJuIFR9ZnVuY3Rpb24gbChpKXtmb3IodmFyIG89MTtvPGFyZ3VtZW50cy5sZW5ndGg7bysrKXt2YXIgVD1hcmd1bWVudHNbb10hPW51bGw/YXJndW1lbnRzW29dOnt9O28lMj9jKE9iamVjdChUKSwhMCkuZm9yRWFjaChmdW5jdGlvbihBKXt1KGksQSxUW0FdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGksT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoVCkpOmMoT2JqZWN0KFQpKS5mb3JFYWNoKGZ1bmN0aW9uKEEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShpLEEsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihULEEpKX0pfXJldHVybiBpfWZ1bmN0aW9uIHUoaSxvLFQpe3JldHVybiBvIGluIGk/T2JqZWN0LmRlZmluZVByb3BlcnR5KGksbyx7dmFsdWU6VCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmlbb109VCxpfWNvbnN0IE09U3ltYm9sKCJtZXNoIiksZj1TeW1ib2woImNvdW50Iiksdj1TeW1ib2woImJsZW5kIikseD1TeW1ib2woImZpbHRlciIpLFI9U3ltYm9sKCJ0ZXh0dXJlcyIpLE89U3ltYm9sKCJ0ZXh0dXJlT3B0aW9ucyIpLGc9U3ltYm9sKCJjbG91ZENvbG9yIikscD1TeW1ib2woImNsb3VkRmlsdGVyIiksbj1TeW1ib2woImJ1ZmZlciIpO2Z1bmN0aW9uIGEoaSxvPW51bGwpe2NvbnN0IFQ9bmV3IEZsb2F0MzJBcnJheSgzKmkpLEE9bmV3IEZsb2F0MzJBcnJheSgzKmkpLEM9bmV3IEZsb2F0MzJBcnJheSg0KmkpLEk9bmV3IEZsb2F0MzJBcnJheSg0KmkpLFA9bmV3IEZsb2F0MzJBcnJheSg0KmkpLEw9bmV3IEZsb2F0MzJBcnJheSg0KmkpLEQ9bmV3IEZsb2F0MzJBcnJheSg0KmkpLGI9bmV3IFVpbnQ4QXJyYXkoaSksUz1uZXcgVWludDhBcnJheSg0KmkpLEI9bmV3IFVpbnQ4QXJyYXkoNCppKTtyZXR1cm4gbyYmKFQuc2V0KG8udHJhbnNmb3JtMCwwKSxBLnNldChvLnRyYW5zZm9ybTEsMCksQy5zZXQoby5jb2xvcjAsMCksSS5zZXQoby5jb2xvcjEsMCksUC5zZXQoby5jb2xvcjIsMCksTC5zZXQoby5jb2xvcjMsMCksRC5zZXQoby5jb2xvcjQsMCksYi5zZXQoby5mcmFtZUluZGV4LDApLFMuc2V0KG8uZmlsbENvbG9yLDApLEIuc2V0KG8uc3Ryb2tlQ29sb3IsMCkpLHtidWZmZXJTaXplOmksdHJhbnNmb3JtMDpULHRyYW5zZm9ybTE6QSxjb2xvcjA6Qyxjb2xvcjE6SSxjb2xvcjI6UCxjb2xvcjM6TCxjb2xvcjQ6RCxmcmFtZUluZGV4OmIsZmlsbENvbG9yOlMsc3Ryb2tlQ29sb3I6Qn19ZS5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKGksbz0xLHtidWZmZXI6VD0xZTN9PXt9KXtUPU1hdGgubWF4KFQsbyksdGhpc1tmXT1vLHRoaXNbTV09aSx0aGlzW25dPWEoVCksdGhpc1tSXT1bXSx0aGlzW3hdPVtdLHRoaXNbZ109ITEsdGhpc1twXT0hMSx0aGlzW3ZdPSExLHRoaXMuaW5pdEJ1ZmZlcigpfWluaXRCdWZmZXIoaT0wKXtjb25zdCBvPXRoaXNbZl07Zm9yKGxldCBUPWk7VDxvO1QrKyl0aGlzW25dLnRyYW5zZm9ybTAuc2V0KFsxLDAsMF0sVCozKSx0aGlzW25dLnRyYW5zZm9ybTEuc2V0KFswLDEsMF0sVCozKSx0aGlzW25dLmZyYW1lSW5kZXguc2V0KFstMV0sVCksdGhpc1tuXS5maWxsQ29sb3Iuc2V0KFswLDAsMCwwXSxUKjQpLHRoaXNbbl0uc3Ryb2tlQ29sb3Iuc2V0KFswLDAsMCwwXSxUKjQpLHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0oVCxudWxsKX1nZXQgYnVmZmVyU2l6ZSgpe3JldHVybiB0aGlzW25dLmJ1ZmZlclNpemV9Z2V0IG1lc2goKXtyZXR1cm4gdGhpc1tNXX1zZXQgbWVzaChpKXt0aGlzW01dPWksdGhpc1tSXSYmdGhpcy5zZXRUZXh0dXJlRnJhbWVzKHRoaXNbUl0sdGhpc1tPXSl9Z2V0IGhhc0Nsb3VkQ29sb3IoKXtyZXR1cm4gdGhpc1tnXX1nZXQgaGFzQ2xvdWRGaWx0ZXIoKXtyZXR1cm4gdGhpc1twXX1fZ2V0RmlsdGVyKGkpe3JldHVybiB0aGlzW3hdW2ldPXRoaXNbeF1baV18fFtdLHRoaXNbeF1baV19Z2V0RmlsdGVyKGkpe3JldHVybiB0aGlzLl9nZXRGaWx0ZXIoaSkuam9pbigiICIpfWdldCBlbmFibGVCbGVuZCgpe3JldHVybiB0aGlzW01dLmVuYWJsZUJsZW5kfHx0aGlzW3ZdfWNhbklnbm9yZSgpe3JldHVybiB0aGlzW01dLmNhbklnbm9yZSgpfWRlbGV0ZShpKXtpZihpPj10aGlzW2ZdfHxpPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7Y29uc3R7dHJhbnNmb3JtMDpvLHRyYW5zZm9ybTE6VCxjb2xvcjA6QSxjb2xvcjE6Qyxjb2xvcjI6SSxjb2xvcjM6UCxjb2xvcjQ6TCxmcmFtZUluZGV4OkQsZmlsbENvbG9yOmIsc3Ryb2tlQ29sb3I6U309dGhpc1tuXTtvLnNldChvLnN1YmFycmF5KDMqKGkrMSkpLDMqaSksVC5zZXQoVC5zdWJhcnJheSgzKihpKzEpKSwzKmkpLEEuc2V0KEEuc3ViYXJyYXkoNCooaSsxKSksNCppKSxDLnNldChDLnN1YmFycmF5KDQqKGkrMSkpLDQqaSksSS5zZXQoSS5zdWJhcnJheSg0KihpKzEpKSw0KmkpLFAuc2V0KFAuc3ViYXJyYXkoNCooaSsxKSksNCppKSxMLnNldChMLnN1YmFycmF5KDQqKGkrMSkpLDQqaSksRC5zZXQoRC5zdWJhcnJheShpKzEpLGkpLGIuc2V0KGIuc3ViYXJyYXkoNCooaSsxKSksNCppKSxTLnNldChTLnN1YmFycmF5KDQqKGkrMSkpLDQqaSk7Zm9yKGNvbnN0IEIgaW4gdGhpc1t4XSlCPT09aT9kZWxldGUgdGhpc1t4XVtCXTpCPmkmJih0aGlzW3hdW0ItMV09dGhpc1t4XVtCXSxkZWxldGUgdGhpc1t4XVtCXSk7dGhpc1tmXS0tfXNldENvbG9yVHJhbnNmb3JtKGksbyl7aWYoaT49dGhpc1tmXXx8aTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2kqPTQ7Y29uc3R7Y29sb3IwOlQsY29sb3IxOkEsY29sb3IyOkMsY29sb3IzOkksY29sb3I0OlB9PXRoaXNbbl07cmV0dXJuIG8hPW51bGw/KFQuc2V0KFtvWzBdLG9bNV0sb1sxMF0sb1sxNV1dLGkpLEEuc2V0KFtvWzFdLG9bNl0sb1sxMV0sb1sxNl1dLGkpLEMuc2V0KFtvWzJdLG9bN10sb1sxMl0sb1sxN11dLGkpLEkuc2V0KFtvWzNdLG9bOF0sb1sxM10sb1sxOF1dLGkpLFAuc2V0KFtvWzRdLG9bOV0sb1sxNF0sb1sxOV1dLGkpLHRoaXNbdl09dGhpc1t2XXx8b1sxOF08MSx0aGlzW3BdPSEwKTooVC5zZXQoWzEsMCwwLDBdLGkpLEEuc2V0KFswLDEsMCwwXSxpKSxDLnNldChbMCwwLDEsMF0saSksSS5zZXQoWzAsMCwwLDFdLGkpLFAuc2V0KFswLDAsMCwwXSxpKSksdGhpc31nZXRDb2xvclRyYW5zZm9ybShpKXtpZihpPj10aGlzW2ZdfHxpPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7aSo9NDtjb25zdHtjb2xvcjA6byxjb2xvcjE6VCxjb2xvcjI6QSxjb2xvcjM6Qyxjb2xvcjQ6SX09dGhpc1tuXTtyZXR1cm5bb1tpXSxUW2ldLEFbaV0sQ1tpXSxJW2ldLG9baSsxXSxUW2krMV0sQVtpKzFdLENbaSsxXSxJW2krMV0sb1tpKzJdLFRbaSsyXSxBW2krMl0sQ1tpKzJdLElbaSsyXSxvW2krM10sVFtpKzNdLEFbaSszXSxDW2krM10sSVtpKzNdXX10cmFuc2Zvcm1Db2xvcihpLG8pe2xldCBUPXRoaXMuZ2V0Q29sb3JUcmFuc2Zvcm0oaSk7cmV0dXJuIFQ9T2JqZWN0KHMubXVsdGlwbHkpKFQsbyksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShpLFQpLHRoaXN9c2V0RmlsbENvbG9yKGksbyl7aWYoaT49dGhpc1tmXXx8aTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBvPT0ic3RyaW5nIiYmKG89T2JqZWN0KHkuZGVmYXVsdCkobykpLG9bM10+MCYmKHRoaXNbZ109ITApLHRoaXNbbl0uZmlsbENvbG9yLnNldChvLm1hcChUPT5NYXRoLnJvdW5kKDI1NSpUKSksNCppKX1zZXRTdHJva2VDb2xvcihpLG8pe2lmKGk+PXRoaXNbZl18fGk8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTt0eXBlb2Ygbz09InN0cmluZyImJihvPU9iamVjdCh5LmRlZmF1bHQpKG8pKSxvWzNdPjAmJih0aGlzW2ddPSEwKSx0aGlzW25dLnN0cm9rZUNvbG9yLnNldChvLm1hcChUPT5NYXRoLnJvdW5kKDI1NSpUKSksNCppKX1nZXRDbG91ZFJHQkEoaSl7aWYoaT49dGhpc1tmXXx8aTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2kqPTQ7Y29uc3R7ZmlsbENvbG9yOm8sc3Ryb2tlQ29sb3I6VH09dGhpc1tuXSxBPVtvW2ldLG9baSsxXSxvW2krMl0sb1tpKzNdXSxDPVtUW2ldLFRbaSsxXSxUW2krMl0sVFtpKzNdXTtyZXR1cm4gQVszXS89MjU1LENbM10vPTI1NSx7ZmlsbDpgcmdiYSgke0Euam9pbigpfSlgLHN0cm9rZTpgcmdiYSgke0Muam9pbigpfSlgfX1ncmF5c2NhbGUoaSxvKXt0aGlzLnRyYW5zZm9ybUNvbG9yKGksT2JqZWN0KHMuZ3JheXNjYWxlKShvKSksdGhpcy5fZ2V0RmlsdGVyKGkpLnB1c2goYGdyYXlzY2FsZSgkezEwMCpvfSUpYCl9YnJpZ2h0bmVzcyhpLG8pe3RoaXMudHJhbnNmb3JtQ29sb3IoaSxPYmplY3Qocy5icmlnaHRuZXNzKShvKSksdGhpcy5fZ2V0RmlsdGVyKGkpLnB1c2goYGJyaWdodG5lc3MoJHsxMDAqb30lKWApfXNhdHVyYXRlKGksbyl7dGhpcy50cmFuc2Zvcm1Db2xvcihpLE9iamVjdChzLnNhdHVyYXRlKShvKSksdGhpcy5fZ2V0RmlsdGVyKGkpLnB1c2goYHNhdHVyYXRlKCR7MTAwKm99JSlgKX1jb250cmFzdChpLG8pe3RoaXMudHJhbnNmb3JtQ29sb3IoaSxPYmplY3Qocy5jb250cmFzdCkobykpLHRoaXMuX2dldEZpbHRlcihpKS5wdXNoKGBjb250cmFzdCgkezEwMCpvfSUpYCl9aW52ZXJ0KGksbyl7dGhpcy50cmFuc2Zvcm1Db2xvcihpLE9iamVjdChzLmludmVydCkobykpLHRoaXMuX2dldEZpbHRlcihpKS5wdXNoKGBpbnZlcnQoJHsxMDAqb30lKWApfXNlcGlhKGksbyl7dGhpcy50cmFuc2Zvcm1Db2xvcihpLE9iamVjdChzLnNlcGlhKShvKSksdGhpcy5fZ2V0RmlsdGVyKGkpLnB1c2goYHNlcGlhKCR7MTAwKm99JSlgKX1vcGFjaXR5KGksbyl7dGhpcy50cmFuc2Zvcm1Db2xvcihpLE9iamVjdChzLm9wYWNpdHkpKG8pKSx0aGlzLl9nZXRGaWx0ZXIoaSkucHVzaChgb3BhY2l0eSgkezEwMCpvfSUpYCl9aHVlUm90YXRlKGksbyl7dGhpcy50cmFuc2Zvcm1Db2xvcihpLE9iamVjdChzLmh1ZVJvdGF0ZSkobykpLHRoaXMuX2dldEZpbHRlcihpKS5wdXNoKGBodWUtcm90YXRlKCR7b31kZWcpYCl9c2V0VHJhbnNmb3JtKGksbyl7aWYoaT49dGhpc1tmXXx8aTwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2kqPTMsbz09bnVsbCYmKG89WzEsMCwwLDEsMCwwXSk7Y29uc3R7dHJhbnNmb3JtMDpULHRyYW5zZm9ybTE6QX09dGhpc1tuXTtyZXR1cm4gVC5zZXQoW29bMF0sb1syXSxvWzRdXSxpKSxBLnNldChbb1sxXSxvWzNdLG9bNV1dLGkpLHRoaXN9Z2V0VHJhbnNmb3JtKGkpe2lmKGk+PXRoaXNbZl18fGk8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtpKj0zO2NvbnN0e3RyYW5zZm9ybTA6byx0cmFuc2Zvcm0xOlR9PXRoaXNbbl07cmV0dXJuW29baV0sVFtpXSxvW2krMV0sVFtpKzFdLG9baSsyXSxUW2krMl1dfWdldFRleHR1cmVGcmFtZShpKXtyZXR1cm4gdGhpc1tSXVt0aGlzW25dLmZyYW1lSW5kZXhbaV1dfXNldFRleHR1cmVGcmFtZXMoaT1bXSxvPXt9KXtpZihpLmxlbmd0aD4xMil0aHJvdyBuZXcgRXJyb3IoIk1heCBmcmFtZXMgZXhjZWVkLiBBbGxvdyAxMiBmcmFtZXMuIik7aS5sZW5ndGgmJnRoaXNbTV0uc2V0VGV4dHVyZShpWzBdLG8pLHRoaXNbUl09aSx0aGlzW09dPW99c2V0RnJhbWVJbmRleChpLG8pe2lmKGk+PXRoaXNbZl18fGk8MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdCBUPXRoaXNbUl0ubGVuZ3RoO2lmKFQ8PTApdGhyb3cgbmV3IEVycm9yKCJObyBmcmFtZXMiKTt0aGlzW25dLmZyYW1lSW5kZXhbaV09byVUfWdldCBhbW91bnQoKXtyZXR1cm4gdGhpc1tmXX1zZXQgYW1vdW50KGkpe2NvbnN0IG89dGhpc1tmXTtpIT09byYmKGk+dGhpc1tuXS5idWZmZXJTaXplJiYodGhpc1tuXT1hKE1hdGgubWF4KGksdGhpc1tuXS5idWZmZXJTaXplKzFlMyksdGhpc1tuXSkpLHRoaXNbZl09aSxpPm8mJnRoaXMuaW5pdEJ1ZmZlcihvKSl9Z2V0IG1lc2hEYXRhKCl7Y29uc3R7YXR0cmlidXRlczppLGNlbGxzOm8scG9zaXRpb25zOlQsdGV4dHVyZUNvb3JkOkEsdW5pZm9ybXM6Q309dGhpc1tNXS5tZXNoRGF0YSxJPXRoaXNbUl0sUD17YXR0cmlidXRlczpsKHt9LGkpLGNlbGxzOm8scG9zaXRpb25zOlQsdGV4dHVyZUNvb3JkOkEsdW5pZm9ybXM6bCh7fSxDKSxpbnN0YW5jZUNvdW50OnRoaXNbZl0sZW5hYmxlQmxlbmQ6dGhpcy5lbmFibGVCbGVuZH07SS5sZW5ndGgmJkkuZm9yRWFjaCgoRyxRKT0+e1AudW5pZm9ybXNbYHVfdGV4RnJhbWUke1F9YF09R30pO2NvbnN0e3RyYW5zZm9ybTA6TCx0cmFuc2Zvcm0xOkQsY29sb3IwOmIsY29sb3IxOlMsY29sb3IyOkIsY29sb3IzOncsY29sb3I0OkgsZmlsbENvbG9yOkosc3Ryb2tlQ29sb3I6cSxmcmFtZUluZGV4Old9PXRoaXNbbl07cmV0dXJuIHRoaXNbTV0udW5pZm9ybXMudV90ZXhTYW1wbGVyJiYoUC5hdHRyaWJ1dGVzLmFfZnJhbWVJbmRleD17ZGF0YTpXLGRpdmlzb3I6MX0pLFAuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTA9e2RhdGE6TCxkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX3RyYW5zZm9ybTE9e2RhdGE6RCxkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQwPXtkYXRhOmIsZGl2aXNvcjoxfSxQLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMT17ZGF0YTpTLGRpdmlzb3I6MX0sUC5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDI9e2RhdGE6QixkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQzPXtkYXRhOncsZGl2aXNvcjoxfSxQLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkND17ZGF0YTpILGRpdmlzb3I6MX0sdGhpcy5oYXNDbG91ZENvbG9yJiYoUC5hdHRyaWJ1dGVzLmFfZmlsbENsb3VkQ29sb3I9e2RhdGE6SixkaXZpc29yOjF9LFAuYXR0cmlidXRlcy5hX3N0cm9rZUNsb3VkQ29sb3I9e2RhdGE6cSxkaXZpc29yOjF9KSxQfXNldFByb2dyYW0oaSl7dGhpc1tNXS5zZXRQcm9ncmFtKGkpfWdldCBwcm9ncmFtKCl7cmV0dXJuIHRoaXNbTV0ucHJvZ3JhbX10cmFuc2Zvcm0oaSxvKXtjb25zdCBUPXRoaXMuZ2V0VHJhbnNmb3JtKGkpO3JldHVybiBvPXIubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLFQsbyksdGhpcy5zZXRUcmFuc2Zvcm0oaSxvKSx0aGlzfXRyYW5zbGF0ZShpLFtvLFRdKXtsZXQgQT1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBBPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxBLFtvLFRdKSx0aGlzLnRyYW5zZm9ybShpLEEpfXJvdGF0ZShpLG8sW1QsQV09WzAsMF0pe2xldCBDPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEM9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEMsW1QsQV0pLEM9ci5tYXQyZC5yb3RhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEMsbyksQz1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksQyxbLVQsLUFdKSx0aGlzLnRyYW5zZm9ybShpLEMpfXNjYWxlKGksW28sVD1vXSxbQSxDXT1bMCwwXSl7bGV0IEk9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gST1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbQSxDXSksST1yLm1hdDJkLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLFtvLFRdKSxJPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLFstQSwtQ10pLHRoaXMudHJhbnNmb3JtKGksSSl9c2tldyhpLFtvLFQ9b10sW0EsQ109WzAsMF0pe2xldCBJPXIubWF0MmQuY3JlYXRlKCk7cmV0dXJuIEk9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksW0EsQ10pLEk9ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxyLm1hdDJkLmZyb21WYWx1ZXMoMSxNYXRoLnRhbihUKSxNYXRoLnRhbihvKSwxLDAsMCkpLEk9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksWy1BLC1DXSksdGhpcy50cmFuc2Zvcm0oaSxJKX1pc1BvaW50Q29sbGlzaW9uKGksW28sVF0sQT0iYm90aCIpe2NvbnN0IEM9dGhpcy5nZXRUcmFuc2Zvcm0oaSksST1PYmplY3QobS50cmFuc2Zvcm1Qb2ludCkoW28sVF0sci5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLEMpKTtyZXR1cm4gdGhpc1tNXS5pc1BvaW50Q29sbGlzaW9uKC4uLkksQSl9aXNQb2ludEluRmlsbChpLFtvLFRdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGksW28sVF0sImZpbGwiKX1pc1BvaW50SW5TdHJva2UoaSxbbyxUXSl7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihpLFtvLFRdLCJzdHJva2UiKX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJncmF5c2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiYnJpZ2h0bmVzcyIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJzYXR1cmF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJjb250cmFzdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2VwaWEiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwib3BhY2l0eSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJodWVSb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyh4LFIpe2NvbnN0IE89W10sZz14WzBdLHA9eFsxXSxuPXhbMl0sYT14WzNdLGk9eFs0XSxvPXhbNV0sVD14WzZdLEE9eFs3XSxDPXhbOF0sST14WzldLFA9eFsxMF0sTD14WzExXSxEPXhbMTJdLGI9eFsxM10sUz14WzE0XSxCPXhbMTVdLHc9eFsxNl0sSD14WzE3XSxKPXhbMThdLHE9eFsxOV07bGV0IFc9UlswXSxHPVJbMV0sUT1SWzJdLHR0PVJbM10sXz1SWzRdO3JldHVybiBPWzBdPVcqZytHKm8rUSpQK3R0KkIsT1sxXT1XKnArRypUK1EqTCt0dCp3LE9bMl09VypuK0cqQStRKkQrdHQqSCxPWzNdPVcqYStHKkMrUSpiK3R0KkosT1s0XT1XKmkrRypJK1EqUyt0dCpxK18sVz1SWzVdLEc9Uls2XSxRPVJbN10sdHQ9Uls4XSxfPVJbOV0sT1s1XT1XKmcrRypvK1EqUCt0dCpCLE9bNl09VypwK0cqVCtRKkwrdHQqdyxPWzddPVcqbitHKkErUSpEK3R0KkgsT1s4XT1XKmErRypDK1EqYit0dCpKLE9bOV09VyppK0cqSStRKlMrdHQqcStfLFc9UlsxMF0sRz1SWzExXSxRPVJbMTJdLHR0PVJbMTNdLF89UlsxNF0sT1sxMF09VypnK0cqbytRKlArdHQqQixPWzExXT1XKnArRypUK1EqTCt0dCp3LE9bMTJdPVcqbitHKkErUSpEK3R0KkgsT1sxM109VyphK0cqQytRKmIrdHQqSixPWzE0XT1XKmkrRypJK1EqUyt0dCpxK18sVz1SWzE1XSxHPVJbMTZdLFE9UlsxN10sdHQ9UlsxOF0sXz1SWzE5XSxPWzE1XT1XKmcrRypvK1EqUCt0dCpCLE9bMTZdPVcqcCtHKlQrUSpMK3R0KncsT1sxN109VypuK0cqQStRKkQrdHQqSCxPWzE4XT1XKmErRypDK1EqYit0dCpKLE9bMTldPVcqaStHKkkrUSpTK3R0KnErXyxPfWZ1bmN0aW9uIG0oeCl7eD1PYmplY3Qoci5jbGFtcCkoMCwxLHgpO2NvbnN0IFI9LjIxMjYqeCxPPS43MTUyKngsZz0uMDcyMip4O3JldHVybltSKzEteCxPLGcsMCwwLFIsTysxLXgsZywwLDAsUixPLGcrMS14LDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIHkoeCl7cmV0dXJuW3gsMCwwLDAsMCwwLHgsMCwwLDAsMCwwLHgsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gYyh4KXtjb25zdCBSPS4yMTI2KigxLXgpLE89LjcxNTIqKDEteCksZz0uMDcyMiooMS14KTtyZXR1cm5bUit4LE8sZywwLDAsUixPK3gsZywwLDAsUixPLGcreCwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBsKHgpe2NvbnN0IFI9LjUqKDEteCk7cmV0dXJuW3gsMCwwLDAsUiwwLHgsMCwwLFIsMCwwLHgsMCxSLDAsMCwwLDEsMF19ZnVuY3Rpb24gdSh4KXtjb25zdCBSPTEtMip4O3JldHVybltSLDAsMCwwLHgsMCxSLDAsMCx4LDAsMCxSLDAseCwwLDAsMCwxLDBdfWZ1bmN0aW9uIE0oeCl7cmV0dXJuWzEtLjYwNyp4LC43NjkqeCwuMTg5KngsMCwwLC4zNDkqeCwxLS4zMTQqeCwuMTY4KngsMCwwLC4yNzIqeCwuNTM0KngsMS0uODY5KngsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gZih4KXtyZXR1cm5bMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAseCwwXX1mdW5jdGlvbiB2KHgpe2NvbnN0IFI9eC8xODAqTWF0aC5QSSxPPU1hdGguY29zKFIpLGc9TWF0aC5zaW4oUikscD0uMjEyNixuPS43MTUyLGE9LjA3MjI7cmV0dXJuW3ArTyooMS1wKStnKi1wLG4rTyotbitnKi1uLGErTyotYStnKigxLWEpLDAsMCxwK08qLXArZyouMTQzLG4rTyooMS1uKStnKi4xNCxhK08qLWErZyotLjI4MywwLDAscCtPKi1wK2cqLSgxLXApLG4rTyotbitnKm4sYStPKigxLWEpK2cqYSwwLDAsMCwwLDAsMSwwXX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgcj10KDMyKSxzPXQubihyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbSh5KXtjb25zdCBjPXMoKSh5KTtpZighY3x8IWMubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY29sb3IgdmFsdWUuIik7cmV0dXJuW2NbMF0vMjU1LGNbMV0vMjU1LGNbMl0vMjU1LGNbM11dfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMzMpLHM9dCgzNyksbT10KDM5KTtoLmV4cG9ydHM9ZnVuY3Rpb24oYyl7dmFyIGwsdT1yKGMpO3JldHVybiB1LnNwYWNlPyhsPUFycmF5KDMpLGxbMF09bSh1LnZhbHVlc1swXSwwLDI1NSksbFsxXT1tKHUudmFsdWVzWzFdLDAsMjU1KSxsWzJdPW0odS52YWx1ZXNbMl0sMCwyNTUpLHUuc3BhY2VbMF09PT0iaCImJihsPXMucmdiKGwpKSxsLnB1c2gobSh1LmFscGhhLDAsMSkpLGwpOltdfX0sZnVuY3Rpb24oaCxlLHQpeyhmdW5jdGlvbihyKXt2YXIgcz10KDM0KSxtPXQoMzUpLHk9dCgzNik7aC5leHBvcnRzPWw7dmFyIGM9e3JlZDowLG9yYW5nZTo2MCx5ZWxsb3c6MTIwLGdyZWVuOjE4MCxibHVlOjI0MCxwdXJwbGU6MzAwfTtmdW5jdGlvbiBsKHUpe3ZhciBNLGY9W10sdj0xLHg7aWYodHlwZW9mIHU9PSJzdHJpbmciKWlmKHNbdV0pZj1zW3VdLnNsaWNlKCkseD0icmdiIjtlbHNlIGlmKHU9PT0idHJhbnNwYXJlbnQiKXY9MCx4PSJyZ2IiLGY9WzAsMCwwXTtlbHNlIGlmKC9eI1tBLUZhLWYwLTldKyQvLnRlc3QodSkpe3ZhciBSPXUuc2xpY2UoMSksTz1SLmxlbmd0aCxnPU88PTQ7dj0xLGc/KGY9W3BhcnNlSW50KFJbMF0rUlswXSwxNikscGFyc2VJbnQoUlsxXStSWzFdLDE2KSxwYXJzZUludChSWzJdK1JbMl0sMTYpXSxPPT09NCYmKHY9cGFyc2VJbnQoUlszXStSWzNdLDE2KS8yNTUpKTooZj1bcGFyc2VJbnQoUlswXStSWzFdLDE2KSxwYXJzZUludChSWzJdK1JbM10sMTYpLHBhcnNlSW50KFJbNF0rUls1XSwxNildLE89PT04JiYodj1wYXJzZUludChSWzZdK1JbN10sMTYpLzI1NSkpLGZbMF18fChmWzBdPTApLGZbMV18fChmWzFdPTApLGZbMl18fChmWzJdPTApLHg9InJnYiJ9ZWxzZSBpZihNPS9eKCg/OnJnYnxoc1tsdmJdfGh3YnxjbXlrP3x4eVt6eV18Z3JheXxsYWJ8bGNodT92P3xbbHlddXZ8bG1zKWE/KVxzKlwoKFteXCldKilcKS8uZXhlYyh1KSl7dmFyIHA9TVsxXSxuPXA9PT0icmdiIixSPXAucmVwbGFjZSgvYSQvLCIiKTt4PVI7dmFyIE89Uj09PSJjbXlrIj80OlI9PT0iZ3JheSI/MTozO2Y9TVsyXS50cmltKCkuc3BsaXQoL1xzKixccyovKS5tYXAoZnVuY3Rpb24oVCxBKXtpZigvJSQvLnRlc3QoVCkpcmV0dXJuIEE9PT1PP3BhcnNlRmxvYXQoVCkvMTAwOlI9PT0icmdiIj9wYXJzZUZsb2F0KFQpKjI1NS8xMDA6cGFyc2VGbG9hdChUKTtpZihSW0FdPT09ImgiKXtpZigvZGVnJC8udGVzdChUKSlyZXR1cm4gcGFyc2VGbG9hdChUKTtpZihjW1RdIT09dm9pZCAwKXJldHVybiBjW1RdfXJldHVybiBwYXJzZUZsb2F0KFQpfSkscD09PVImJmYucHVzaCgxKSx2PW58fGZbT109PT12b2lkIDA/MTpmW09dLGY9Zi5zbGljZSgwLE8pfWVsc2UgdS5sZW5ndGg+MTAmJi9bMC05XSg/OlxzfFwvKS8udGVzdCh1KSYmKGY9dS5tYXRjaCgvKFswLTldKykvZykubWFwKGZ1bmN0aW9uKGkpe3JldHVybiBwYXJzZUZsb2F0KGkpfSkseD11Lm1hdGNoKC8oW2Etel0pL2lnKS5qb2luKCIiKS50b0xvd2VyQ2FzZSgpKTtlbHNlIGlmKCFpc05hTih1KSl4PSJyZ2IiLGY9W3U+Pj4xNiwodSY2NTI4MCk+Pj44LHUmMjU1XTtlbHNlIGlmKG0odSkpe3ZhciBhPXkodS5yLHUucmVkLHUuUixudWxsKTthIT09bnVsbD8oeD0icmdiIixmPVthLHkodS5nLHUuZ3JlZW4sdS5HKSx5KHUuYix1LmJsdWUsdS5CKV0pOih4PSJoc2wiLGY9W3kodS5oLHUuaHVlLHUuSCkseSh1LnMsdS5zYXR1cmF0aW9uLHUuUykseSh1LmwsdS5saWdodG5lc3MsdS5MLHUuYix1LmJyaWdodG5lc3MpXSksdj15KHUuYSx1LmFscGhhLHUub3BhY2l0eSwxKSx1Lm9wYWNpdHkhPW51bGwmJih2Lz0xMDApfWVsc2UoQXJyYXkuaXNBcnJheSh1KXx8ci5BcnJheUJ1ZmZlciYmQXJyYXlCdWZmZXIuaXNWaWV3JiZBcnJheUJ1ZmZlci5pc1ZpZXcodSkpJiYoZj1bdVswXSx1WzFdLHVbMl1dLHg9InJnYiIsdj11Lmxlbmd0aD09PTQ/dVszXToxKTtyZXR1cm57c3BhY2U6eCx2YWx1ZXM6ZixhbHBoYTp2fX19KS5jYWxsKHRoaXMsdCgyMikpfSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXthbGljZWJsdWU6WzI0MCwyNDgsMjU1XSxhbnRpcXVld2hpdGU6WzI1MCwyMzUsMjE1XSxhcXVhOlswLDI1NSwyNTVdLGFxdWFtYXJpbmU6WzEyNywyNTUsMjEyXSxhenVyZTpbMjQwLDI1NSwyNTVdLGJlaWdlOlsyNDUsMjQ1LDIyMF0sYmlzcXVlOlsyNTUsMjI4LDE5Nl0sYmxhY2s6WzAsMCwwXSxibGFuY2hlZGFsbW9uZDpbMjU1LDIzNSwyMDVdLGJsdWU6WzAsMCwyNTVdLGJsdWV2aW9sZXQ6WzEzOCw0MywyMjZdLGJyb3duOlsxNjUsNDIsNDJdLGJ1cmx5d29vZDpbMjIyLDE4NCwxMzVdLGNhZGV0Ymx1ZTpbOTUsMTU4LDE2MF0sY2hhcnRyZXVzZTpbMTI3LDI1NSwwXSxjaG9jb2xhdGU6WzIxMCwxMDUsMzBdLGNvcmFsOlsyNTUsMTI3LDgwXSxjb3JuZmxvd2VyYmx1ZTpbMTAwLDE0OSwyMzddLGNvcm5zaWxrOlsyNTUsMjQ4LDIyMF0sY3JpbXNvbjpbMjIwLDIwLDYwXSxjeWFuOlswLDI1NSwyNTVdLGRhcmtibHVlOlswLDAsMTM5XSxkYXJrY3lhbjpbMCwxMzksMTM5XSxkYXJrZ29sZGVucm9kOlsxODQsMTM0LDExXSxkYXJrZ3JheTpbMTY5LDE2OSwxNjldLGRhcmtncmVlbjpbMCwxMDAsMF0sZGFya2dyZXk6WzE2OSwxNjksMTY5XSxkYXJra2hha2k6WzE4OSwxODMsMTA3XSxkYXJrbWFnZW50YTpbMTM5LDAsMTM5XSxkYXJrb2xpdmVncmVlbjpbODUsMTA3LDQ3XSxkYXJrb3JhbmdlOlsyNTUsMTQwLDBdLGRhcmtvcmNoaWQ6WzE1Myw1MCwyMDRdLGRhcmtyZWQ6WzEzOSwwLDBdLGRhcmtzYWxtb246WzIzMywxNTAsMTIyXSxkYXJrc2VhZ3JlZW46WzE0MywxODgsMTQzXSxkYXJrc2xhdGVibHVlOls3Miw2MSwxMzldLGRhcmtzbGF0ZWdyYXk6WzQ3LDc5LDc5XSxkYXJrc2xhdGVncmV5Ols0Nyw3OSw3OV0sZGFya3R1cnF1b2lzZTpbMCwyMDYsMjA5XSxkYXJrdmlvbGV0OlsxNDgsMCwyMTFdLGRlZXBwaW5rOlsyNTUsMjAsMTQ3XSxkZWVwc2t5Ymx1ZTpbMCwxOTEsMjU1XSxkaW1ncmF5OlsxMDUsMTA1LDEwNV0sZGltZ3JleTpbMTA1LDEwNSwxMDVdLGRvZGdlcmJsdWU6WzMwLDE0NCwyNTVdLGZpcmVicmljazpbMTc4LDM0LDM0XSxmbG9yYWx3aGl0ZTpbMjU1LDI1MCwyNDBdLGZvcmVzdGdyZWVuOlszNCwxMzksMzRdLGZ1Y2hzaWE6WzI1NSwwLDI1NV0sZ2FpbnNib3JvOlsyMjAsMjIwLDIyMF0sZ2hvc3R3aGl0ZTpbMjQ4LDI0OCwyNTVdLGdvbGQ6WzI1NSwyMTUsMF0sZ29sZGVucm9kOlsyMTgsMTY1LDMyXSxncmF5OlsxMjgsMTI4LDEyOF0sZ3JlZW46WzAsMTI4LDBdLGdyZWVueWVsbG93OlsxNzMsMjU1LDQ3XSxncmV5OlsxMjgsMTI4LDEyOF0saG9uZXlkZXc6WzI0MCwyNTUsMjQwXSxob3RwaW5rOlsyNTUsMTA1LDE4MF0saW5kaWFucmVkOlsyMDUsOTIsOTJdLGluZGlnbzpbNzUsMCwxMzBdLGl2b3J5OlsyNTUsMjU1LDI0MF0sa2hha2k6WzI0MCwyMzAsMTQwXSxsYXZlbmRlcjpbMjMwLDIzMCwyNTBdLGxhdmVuZGVyYmx1c2g6WzI1NSwyNDAsMjQ1XSxsYXduZ3JlZW46WzEyNCwyNTIsMF0sbGVtb25jaGlmZm9uOlsyNTUsMjUwLDIwNV0sbGlnaHRibHVlOlsxNzMsMjE2LDIzMF0sbGlnaHRjb3JhbDpbMjQwLDEyOCwxMjhdLGxpZ2h0Y3lhbjpbMjI0LDI1NSwyNTVdLGxpZ2h0Z29sZGVucm9keWVsbG93OlsyNTAsMjUwLDIxMF0sbGlnaHRncmF5OlsyMTEsMjExLDIxMV0sbGlnaHRncmVlbjpbMTQ0LDIzOCwxNDRdLGxpZ2h0Z3JleTpbMjExLDIxMSwyMTFdLGxpZ2h0cGluazpbMjU1LDE4MiwxOTNdLGxpZ2h0c2FsbW9uOlsyNTUsMTYwLDEyMl0sbGlnaHRzZWFncmVlbjpbMzIsMTc4LDE3MF0sbGlnaHRza3libHVlOlsxMzUsMjA2LDI1MF0sbGlnaHRzbGF0ZWdyYXk6WzExOSwxMzYsMTUzXSxsaWdodHNsYXRlZ3JleTpbMTE5LDEzNiwxNTNdLGxpZ2h0c3RlZWxibHVlOlsxNzYsMTk2LDIyMl0sbGlnaHR5ZWxsb3c6WzI1NSwyNTUsMjI0XSxsaW1lOlswLDI1NSwwXSxsaW1lZ3JlZW46WzUwLDIwNSw1MF0sbGluZW46WzI1MCwyNDAsMjMwXSxtYWdlbnRhOlsyNTUsMCwyNTVdLG1hcm9vbjpbMTI4LDAsMF0sbWVkaXVtYXF1YW1hcmluZTpbMTAyLDIwNSwxNzBdLG1lZGl1bWJsdWU6WzAsMCwyMDVdLG1lZGl1bW9yY2hpZDpbMTg2LDg1LDIxMV0sbWVkaXVtcHVycGxlOlsxNDcsMTEyLDIxOV0sbWVkaXVtc2VhZ3JlZW46WzYwLDE3OSwxMTNdLG1lZGl1bXNsYXRlYmx1ZTpbMTIzLDEwNCwyMzhdLG1lZGl1bXNwcmluZ2dyZWVuOlswLDI1MCwxNTRdLG1lZGl1bXR1cnF1b2lzZTpbNzIsMjA5LDIwNF0sbWVkaXVtdmlvbGV0cmVkOlsxOTksMjEsMTMzXSxtaWRuaWdodGJsdWU6WzI1LDI1LDExMl0sbWludGNyZWFtOlsyNDUsMjU1LDI1MF0sbWlzdHlyb3NlOlsyNTUsMjI4LDIyNV0sbW9jY2FzaW46WzI1NSwyMjgsMTgxXSxuYXZham93aGl0ZTpbMjU1LDIyMiwxNzNdLG5hdnk6WzAsMCwxMjhdLG9sZGxhY2U6WzI1MywyNDUsMjMwXSxvbGl2ZTpbMTI4LDEyOCwwXSxvbGl2ZWRyYWI6WzEwNywxNDIsMzVdLG9yYW5nZTpbMjU1LDE2NSwwXSxvcmFuZ2VyZWQ6WzI1NSw2OSwwXSxvcmNoaWQ6WzIxOCwxMTIsMjE0XSxwYWxlZ29sZGVucm9kOlsyMzgsMjMyLDE3MF0scGFsZWdyZWVuOlsxNTIsMjUxLDE1Ml0scGFsZXR1cnF1b2lzZTpbMTc1LDIzOCwyMzhdLHBhbGV2aW9sZXRyZWQ6WzIxOSwxMTIsMTQ3XSxwYXBheWF3aGlwOlsyNTUsMjM5LDIxM10scGVhY2hwdWZmOlsyNTUsMjE4LDE4NV0scGVydTpbMjA1LDEzMyw2M10scGluazpbMjU1LDE5MiwyMDNdLHBsdW06WzIyMSwxNjAsMjIxXSxwb3dkZXJibHVlOlsxNzYsMjI0LDIzMF0scHVycGxlOlsxMjgsMCwxMjhdLHJlYmVjY2FwdXJwbGU6WzEwMiw1MSwxNTNdLHJlZDpbMjU1LDAsMF0scm9zeWJyb3duOlsxODgsMTQzLDE0M10scm95YWxibHVlOls2NSwxMDUsMjI1XSxzYWRkbGVicm93bjpbMTM5LDY5LDE5XSxzYWxtb246WzI1MCwxMjgsMTE0XSxzYW5keWJyb3duOlsyNDQsMTY0LDk2XSxzZWFncmVlbjpbNDYsMTM5LDg3XSxzZWFzaGVsbDpbMjU1LDI0NSwyMzhdLHNpZW5uYTpbMTYwLDgyLDQ1XSxzaWx2ZXI6WzE5MiwxOTIsMTkyXSxza3libHVlOlsxMzUsMjA2LDIzNV0sc2xhdGVibHVlOlsxMDYsOTAsMjA1XSxzbGF0ZWdyYXk6WzExMiwxMjgsMTQ0XSxzbGF0ZWdyZXk6WzExMiwxMjgsMTQ0XSxzbm93OlsyNTUsMjUwLDI1MF0sc3ByaW5nZ3JlZW46WzAsMjU1LDEyN10sc3RlZWxibHVlOls3MCwxMzAsMTgwXSx0YW46WzIxMCwxODAsMTQwXSx0ZWFsOlswLDEyOCwxMjhdLHRoaXN0bGU6WzIxNiwxOTEsMjE2XSx0b21hdG86WzI1NSw5OSw3MV0sdHVycXVvaXNlOls2NCwyMjQsMjA4XSx2aW9sZXQ6WzIzOCwxMzAsMjM4XSx3aGVhdDpbMjQ1LDIyMiwxNzldLHdoaXRlOlsyNTUsMjU1LDI1NV0sd2hpdGVzbW9rZTpbMjQ1LDI0NSwyNDVdLHllbGxvdzpbMjU1LDI1NSwwXSx5ZWxsb3dncmVlbjpbMTU0LDIwNSw1MF19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztoLmV4cG9ydHM9ZnVuY3Rpb24ocyl7dmFyIG07cmV0dXJuIHIuY2FsbChzKT09PSJbb2JqZWN0IE9iamVjdF0iJiYobT1PYmplY3QuZ2V0UHJvdG90eXBlT2YocyksbT09PW51bGx8fG09PT1PYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKylpZihhcmd1bWVudHNbdF0hPT12b2lkIDApcmV0dXJuIGFyZ3VtZW50c1t0XX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDM4KTtoLmV4cG9ydHM9e25hbWU6ImhzbCIsbWluOlswLDAsMF0sbWF4OlszNjAsMTAwLDEwMF0sY2hhbm5lbDpbImh1ZSIsInNhdHVyYXRpb24iLCJsaWdodG5lc3MiXSxhbGlhczpbIkhTTCJdLHJnYjpmdW5jdGlvbihzKXt2YXIgbT1zWzBdLzM2MCx5PXNbMV0vMTAwLGM9c1syXS8xMDAsbCx1LE0sZix2O2lmKHk9PT0wKXJldHVybiB2PWMqMjU1LFt2LHYsdl07YzwuNT91PWMqKDEreSk6dT1jK3ktYyp5LGw9MipjLXUsZj1bMCwwLDBdO2Zvcih2YXIgeD0wO3g8Mzt4KyspTT1tKzEvMyotKHgtMSksTTwwP00rKzpNPjEmJk0tLSw2Kk08MT92PWwrKHUtbCkqNipNOjIqTTwxP3Y9dTozKk08Mj92PWwrKHUtbCkqKDIvMy1NKSo2OnY9bCxmW3hdPXYqMjU1O3JldHVybiBmfX0sci5oc2w9ZnVuY3Rpb24ocyl7dmFyIG09c1swXS8yNTUseT1zWzFdLzI1NSxjPXNbMl0vMjU1LGw9TWF0aC5taW4obSx5LGMpLHU9TWF0aC5tYXgobSx5LGMpLE09dS1sLGYsdix4O3JldHVybiB1PT09bD9mPTA6bT09PXU/Zj0oeS1jKS9NOnk9PT11P2Y9MisoYy1tKS9NOmM9PT11JiYoZj00KyhtLXkpL00pLGY9TWF0aC5taW4oZio2MCwzNjApLGY8MCYmKGYrPTM2MCkseD0obCt1KS8yLHU9PT1sP3Y9MDp4PD0uNT92PU0vKHUrbCk6dj1NLygyLXUtbCksW2YsdioxMDAseCoxMDBdfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17bmFtZToicmdiIixtaW46WzAsMCwwXSxtYXg6WzI1NSwyNTUsMjU1XSxjaGFubmVsOlsicmVkIiwiZ3JlZW4iLCJibHVlIl0sYWxpYXM6WyJSR0IiXX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPXQ7ZnVuY3Rpb24gdChyLHMsbSl7cmV0dXJuIHM8bT9yPHM/czpyPm0/bTpyOnI8bT9tOnI+cz9zOnJ9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBhfSk7dmFyIHI9dCg0MSkscz10Lm4ociksbT10KDQyKSx5PXQubihtKSxjPXQoNDMpLGw9dC5uKGMpLHU9dCg0NCksTT10KDQ2KSxmPXQubihNKSx2PXQoNTMpLHg9dCg1NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFI9U3ltYm9sKCJjb250b3VycyIpLE89U3ltYm9sKCJwYXRoIiksZz1TeW1ib2woInNpbXBsaWZ5IikscD1TeW1ib2woInNjYWxlIiksbj0yKk1hdGguUEk7Y2xhc3MgYXtjb25zdHJ1Y3RvcihvPXt9KXt0eXBlb2Ygbz09InN0cmluZyImJihvPXtwYXRoOm99KSxvLnBhdGg/dGhpc1tPXT1zKCkoby5wYXRoKTp0aGlzW09dPVtdLHRoaXNbUl09bnVsbCx0aGlzW2ddPW8uc2ltcGxpZnkhPW51bGw/by5zaW1wbGlmeTowLHRoaXNbcF09by5zY2FsZSE9bnVsbD9vLnNjYWxlOjJ9Z2V0IGNvbnRvdXJzKCl7bGV0IG89bnVsbDtpZighdGhpc1tSXSYmdGhpc1tPXSl7Y29uc3QgVD1PYmplY3QodS5kZWZhdWx0KShsKCkodGhpc1tPXSkpO3RoaXNbUl09ZigpKFQsdGhpc1twXSx0aGlzW2ddKSx0aGlzW1JdLnBhdGg9VCx0aGlzW1JdLnNpbXBsaWZ5PXRoaXNbZ10sdGhpc1tSXS5zY2FsZT10aGlzW3BdfXJldHVybiB0aGlzW1JdJiYobz10aGlzW1JdLm1hcChUPT5bLi4uVF0pLG8ucGF0aD10aGlzW1JdLnBhdGgsby5zaW1wbGlmeT10aGlzW1JdLnNpbXBsaWZ5LG8uc2NhbGU9dGhpc1tSXS5zY2FsZSksb31nZXQgcGF0aCgpe3JldHVybiB0aGlzW09dfWdldCBzaW1wbGlmeSgpe3JldHVybiB0aGlzW2ddfWdldCBib3VuZGluZ0JveCgpe2NvbnN0IG89dGhpcy5jb250b3VycztpZihvJiZvLmxlbmd0aCl7Y29uc3QgVD1vLnJlZHVjZSgoQSxDKT0+Wy4uLkEsLi4uQ10pO3JldHVybiB5KCkoVCl9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBvPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIG8/Wy41KihvWzBdWzBdK29bMV1bMF0pLC41KihvWzBdWzFdK29bMV1bMV0pXTpbMCwwXX1ub3JtYWxpemUobz0wLFQ9MCl7Y29uc3QgQT1PYmplY3QodS5kZWZhdWx0KShsKCkodGhpc1tPXSkpLm1hcCgoW0MsLi4uSV0pPT57Y29uc3QgUD1bQ107Zm9yKGxldCBMPTA7TDxJLmxlbmd0aDtMKz0yKXtjb25zdCBEPUlbTF0tbyxiPUlbTCsxXS1UO1AucHVzaChELGIpfXJldHVybiBQfSk7cmV0dXJuIHRoaXMuYmVnaW5QYXRoKCksdGhpc1tPXS5wdXNoKC4uLkEpLHRoaXN9Z2V0UG9pbnRBdExlbmd0aChvKXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3Qodi5nZXRQb2ludEF0TGVuZ3RoKSh0aGlzW1JdLG8pOm51bGx9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gdGhpcy5jb250b3Vycz9PYmplY3Qodi5nZXRUb3RhbExlbmd0aCkodGhpc1tSXSk6MH1hZGRQYXRoKG8pe3RoaXNbUl09bnVsbCx0eXBlb2Ygbz09InN0cmluZyImJihvPXMoKShvKSksdGhpc1tPXS5wdXNoKC4uLm8pfWJlZ2luUGF0aCgpe3RoaXNbT109W10sdGhpc1tSXT1udWxsfWNsZWFyKCl7dGhpcy5iZWdpblBhdGgoKX1lbGxpcHNlKG8sVCxBLEMsSSxQLEwsRD0wKXtpZihQKz1JLEwrPUksQTw9MHx8Qzw9MHx8TD09PVApcmV0dXJuO0w8UCYmKEw9UCtuKyhMLVApJW4pLEwtUD5uJiYoTD1QK24pO2NvbnN0IGI9TC1QO2I+PW4mJihMLT0uMDAxKTtsZXQgUz10aGlzW09dLmxlbmd0aD4wJiZiPG4/IkwiOiJNIjtjb25zdCBCPU9iamVjdCh4LmdldFBvaW50KShvLFQsQSxDLFApLHc9T2JqZWN0KHguZ2V0UG9pbnQpKG8sVCxBLEMsTCksSD0rIUQ7bGV0IEo9Yj5NYXRoLlBJPzE6MDtEJiYoSj0xLUopLFMrPUIuam9pbigiICIpLFMrPWBBJHtBfSAke0N9IDAgJHtKfSAke0h9ICR7dy5qb2luKCIgIil9YCxiPj1uJiYoUys9IloiKSx0aGlzLmFkZFBhdGgoUyl9YXJjKG8sVCxBLEMsSSxQPTApe3JldHVybiB0aGlzLmVsbGlwc2UobyxULEEsQSwwLEMsSSxQKX1hcmNUbyhvLFQsQSxDLEksUCxMKXt0aGlzW1JdPW51bGwsdGhpc1tPXS5wdXNoKFsiQSIsbyxULEEsQyxJLFAsTF0pfW1vdmVUbyhvLFQpe3RoaXNbUl09bnVsbCx0aGlzW09dLnB1c2goWyJNIixvLFRdKX1saW5lVG8obyxUKXt0aGlzW1JdPW51bGwsdGhpc1tPXS5wdXNoKFsiTCIsbyxUXSl9YmV6aWVyQ3VydmVUbyhvLFQsQSxDLEksUCl7dGhpc1tSXT1udWxsLHRoaXNbT10ucHVzaChbIkMiLG8sVCxBLEMsSSxQXSl9cXVhZHJhdGljQ3VydmVUbyhvLFQsQSxDKXt0aGlzW1JdPW51bGwsdGhpc1tPXS5wdXNoKFsiUSIsbyxULEEsQ10pfXJlY3QobyxULEEsQyl7Y29uc3QgST1gTSR7b30gJHtUfUwke28rQX0gJHtUfUwke28rQX0gJHtUK0N9TCR7b30gJHtUK0N9WmA7dGhpcy5hZGRQYXRoKEkpfWNsb3NlUGF0aCgpe3RoaXNbUl09bnVsbDtsZXQgbz1bXTtjb25zdCBUPXRoaXNbT10ubGVuZ3RoO1Q+MCYmKG89dGhpc1tPXVtULTFdKSxvWzBdIT09IloiJiZvWzBdIT09InoiJiZ0aGlzW09dLnB1c2goWyJaIl0pfX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPXM7dmFyIHQ9e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0scj0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIHMoYyl7dmFyIGw9W107cmV0dXJuIGMucmVwbGFjZShyLGZ1bmN0aW9uKHUsTSxmKXt2YXIgdj1NLnRvTG93ZXJDYXNlKCk7Zm9yKGY9eShmKSx2PT0ibSImJmYubGVuZ3RoPjImJihsLnB1c2goW01dLmNvbmNhdChmLnNwbGljZSgwLDIpKSksdj0ibCIsTT1NPT0ibSI/ImwiOiJMIik7Oyl7aWYoZi5sZW5ndGg9PXRbdl0pcmV0dXJuIGYudW5zaGlmdChNKSxsLnB1c2goZik7aWYoZi5sZW5ndGg8dFt2XSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTtsLnB1c2goW01dLmNvbmNhdChmLnNwbGljZSgwLHRbdl0pKSl9fSksbH12YXIgbT0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiB5KGMpe3ZhciBsPWMubWF0Y2gobSk7cmV0dXJuIGw/bC5tYXAoTnVtYmVyKTpbXX19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9cjtmdW5jdGlvbiByKHMpe3ZhciBtPXMubGVuZ3RoO2lmKG09PT0wKXJldHVybltbXSxbXV07Zm9yKHZhciB5PXNbMF0ubGVuZ3RoLGM9c1swXS5zbGljZSgpLGw9c1swXS5zbGljZSgpLHU9MTt1PG07Kyt1KWZvcih2YXIgTT1zW3VdLGY9MDtmPHk7KytmKXt2YXIgdj1NW2ZdO2NbZl09TWF0aC5taW4oY1tmXSx2KSxsW2ZdPU1hdGgubWF4KGxbZl0sdil9cmV0dXJuW2MsbF19fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz10O2Z1bmN0aW9uIHQocil7dmFyIHM9MCxtPTAseT0wLGM9MDtyZXR1cm4gci5tYXAoZnVuY3Rpb24obCl7bD1sLnNsaWNlKCk7dmFyIHU9bFswXSxNPXUudG9VcHBlckNhc2UoKTtpZih1IT1NKXN3aXRjaChsWzBdPU0sdSl7Y2FzZSJhIjpsWzZdKz15LGxbN10rPWM7YnJlYWs7Y2FzZSJ2IjpsWzFdKz1jO2JyZWFrO2Nhc2UiaCI6bFsxXSs9eTticmVhaztkZWZhdWx0OmZvcih2YXIgZj0xO2Y8bC5sZW5ndGg7KWxbZisrXSs9eSxsW2YrK10rPWN9c3dpdGNoKE0pe2Nhc2UiWiI6eT1zLGM9bTticmVhaztjYXNlIkgiOnk9bFsxXTticmVhaztjYXNlIlYiOmM9bFsxXTticmVhaztjYXNlIk0iOnk9cz1sWzFdLGM9bT1sWzJdO2JyZWFrO2RlZmF1bHQ6eT1sW2wubGVuZ3RoLTJdLGM9bFtsLmxlbmd0aC0xXX1yZXR1cm4gbH0pfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciByPXQoNDUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBzKGMpe2Zvcih2YXIgbCx1PVtdLE09MCxmPTAsdj0wLHg9MCxSPW51bGwsTz1udWxsLGc9MCxwPTAsbj0wLGE9Yy5sZW5ndGg7bjxhO24rKyl7dmFyIGk9Y1tuXSxvPWlbMF07c3dpdGNoKG8pe2Nhc2UiTSI6dj1pWzFdLHg9aVsyXTticmVhaztjYXNlIkEiOnZhciBUPU9iamVjdChyLmRlZmF1bHQpKGcscCxpWzZdLGlbN10saVs0XSxpWzVdLGlbMV0saVsyXSxpWzNdKTtpZighVC5sZW5ndGgpY29udGludWU7VD1ULm1hcChMPT57Y29uc3RbRCxiLFMsQix3LEgsSixxXT1MO3JldHVybnt4MTpTLHkxOkIseDI6dyx5MjpILHg6Six5OnF9fSk7Zm9yKHZhciBBPTAsQztBPFQubGVuZ3RoO0ErKylDPVRbQV0saT1bIkMiLEMueDEsQy55MSxDLngyLEMueTIsQy54LEMueV0sQTxULmxlbmd0aC0xJiZ1LnB1c2goaSk7YnJlYWs7Y2FzZSJTIjp2YXIgST1nLFA9cDsobD09IkMifHxsPT0iUyIpJiYoSSs9SS1NLFArPVAtZiksaT1bIkMiLEksUCxpWzFdLGlbMl0saVszXSxpWzRdXTticmVhaztjYXNlIlQiOmw9PSJRInx8bD09IlQiPyhSPWcqMi1SLE89cCoyLU8pOihSPWcsTz1wKSxpPXkoZyxwLFIsTyxpWzFdLGlbMl0pO2JyZWFrO2Nhc2UiUSI6Uj1pWzFdLE89aVsyXSxpPXkoZyxwLGlbMV0saVsyXSxpWzNdLGlbNF0pO2JyZWFrO2Nhc2UiTCI6aT1tKGcscCxpWzFdLGlbMl0pO2JyZWFrO2Nhc2UiSCI6aT1tKGcscCxpWzFdLHApO2JyZWFrO2Nhc2UiViI6aT1tKGcscCxnLGlbMV0pO2JyZWFrO2Nhc2UiWiI6aT1tKGcscCx2LHgpO2JyZWFrfWw9byxnPWlbaS5sZW5ndGgtMl0scD1pW2kubGVuZ3RoLTFdLGkubGVuZ3RoPjQ/KE09aVtpLmxlbmd0aC00XSxmPWlbaS5sZW5ndGgtM10pOihNPWcsZj1wKSx1LnB1c2goaSl9cmV0dXJuIHV9ZnVuY3Rpb24gbShjLGwsdSxNKXtyZXR1cm5bIkMiLGMsbCx1LE0sdSxNXX1mdW5jdGlvbiB5KGMsbCx1LE0sZix2KXtyZXR1cm5bIkMiLGMvMysyLzMqdSxsLzMrMi8zKk0sZi8zKzIvMyp1LHYvMysyLzMqTSxmLHZdfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPU1hdGguUEkqMjtmdW5jdGlvbiBzKGwsdSxNLGYpe2NvbnN0IHY9bCpmLXUqTTwwPy0xOjE7bGV0IHg9bCpNK3UqZjtyZXR1cm4geD4xJiYoeD0xKSx4PC0xJiYoeD0tMSksdipNYXRoLmFjb3MoeCl9ZnVuY3Rpb24gbShsLHUsTSxmLHYseCxSLE8sZyxwKXtjb25zdCBuPXAqKGwtTSkvMitnKih1LWYpLzIsYT0tZyoobC1NKS8yK3AqKHUtZikvMixpPVIqUixvPU8qTyxUPW4qbixBPWEqYTtsZXQgQz1pKm8taSpBLW8qVDtDPDAmJihDPTApLEMvPWkqQStvKlQsQz1NYXRoLnNxcnQoQykqKHY9PT14Py0xOjEpO2NvbnN0IEk9QypSL08qYSxQPUMqLU8vUipuLEw9cCpJLWcqUCsobCtNKS8yLEQ9ZypJK3AqUCsodStmKS8yLGI9KG4tSSkvUixTPShhLVApL08sQj0oLW4tSSkvUix3PSgtYS1QKS9PLEg9cygxLDAsYixTKTtsZXQgSj1zKGIsUyxCLHcpO3JldHVybiB4PT09MCYmSj4wJiYoSi09cikseD09PTEmJko8MCYmKEorPXIpLFtMLEQsSCxKXX1mdW5jdGlvbiB5KGwsdSl7Y29uc3QgTT0xLjMzMzMzMzMzMzMzMzMzMzMqTWF0aC50YW4odS80KSxmPU1hdGguY29zKGwpLHY9TWF0aC5zaW4obCkseD1NYXRoLmNvcyhsK3UpLFI9TWF0aC5zaW4obCt1KTtyZXR1cm5bZix2LGYtdipNLHYrZipNLHgrUipNLFIteCpNLHgsUl19ZnVuY3Rpb24gYyhsLHUsTSxmLHYseCxSLE8sZyl7Y29uc3QgcD1NYXRoLnNpbihnKnIvMzYwKSxuPU1hdGguY29zKGcqci8zNjApLGE9bioobC1NKS8yK3AqKHUtZikvMixpPS1wKihsLU0pLzIrbioodS1mKS8yO2lmKGE9PT0wJiZpPT09MClyZXR1cm5bXTtpZihSPT09MHx8Tz09PTApcmV0dXJuW107Uj1NYXRoLmFicyhSKSxPPU1hdGguYWJzKE8pO2NvbnN0IG89YSphLyhSKlIpK2kqaS8oTypPKTtvPjEmJihSKj1NYXRoLnNxcnQobyksTyo9TWF0aC5zcXJ0KG8pKTtjb25zdCBUPW0obCx1LE0sZix2LHgsUixPLHAsbiksQT1bXTtsZXQgQz1UWzJdLEk9VFszXTtjb25zdCBQPU1hdGgubWF4KE1hdGguY2VpbChNYXRoLmFicyhJKS8oci80KSksMSk7SS89UDtmb3IobGV0IEw9MDtMPFA7TCsrKUEucHVzaCh5KEMsSSkpLEMrPUk7cmV0dXJuIEEubWFwKEw9Pntmb3IobGV0IEQ9MDtEPEwubGVuZ3RoO0QrPTIpe2xldCBiPUxbRCswXSxTPUxbRCsxXTtiKj1SLFMqPU87Y29uc3QgQj1uKmItcCpTLHc9cCpiK24qUztMW0QrMF09QitUWzBdLExbRCsxXT13K1RbMV19cmV0dXJuIEx9KX19LGZ1bmN0aW9uKGgsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9dCg0Nykse2NvcHk6c309dCg0OSksbT10KDUwKTtmdW5jdGlvbiB5KGYsdix4KXtyZXR1cm4gZlswXT12LGZbMV09eCxmfXZhciBjPVswLDBdLGw9WzAsMF0sdT1bMCwwXTtmdW5jdGlvbiBNKGYsdix4LFIpe3IoeCx5KGMsUlsxXSxSWzJdKSx5KGwsUlszXSxSWzRdKSx5KHUsUls1XSxSWzZdKSx2LGYpfWguZXhwb3J0cz1mdW5jdGlvbih2LHgsUil7dmFyIE89W10sZz1bXSxwPVswLDBdO3JldHVybiB2LmZvckVhY2goZnVuY3Rpb24obixhLGkpe2lmKG5bMF09PT0iTSIpcyhwLG4uc2xpY2UoMSkpLGcubGVuZ3RoPjAmJihPLnB1c2goZyksZz1bXSk7ZWxzZSBpZihuWzBdPT09IkMiKU0oZyx4LHAsbikseShwLG5bNV0sbls2XSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoImlsbGVnYWwgdHlwZSBpbiBTVkc6ICIrblswXSl9KSxnLmxlbmd0aD4wJiZPLnB1c2goZyksTy5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG0obixSfHwwKX0pfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz10KDQ4KSgpfSxmdW5jdGlvbihoLGUpe2Z1bmN0aW9uIHQocyl7cmV0dXJuW3NbMF0sc1sxXV19ZnVuY3Rpb24gcihzLG0pe3JldHVybltzLG1dfWguZXhwb3J0cz1mdW5jdGlvbihtKXttPW18fHt9O3ZhciB5PXR5cGVvZiBtLnJlY3Vyc2lvbj09Im51bWJlciI/bS5yZWN1cnNpb246OCxjPXR5cGVvZiBtLmVwc2lsb249PSJudW1iZXIiP20uZXBzaWxvbjoxMTkyMDkyOWUtMTQsbD10eXBlb2YgbS5wYXRoRXBzaWxvbj09Im51bWJlciI/bS5wYXRoRXBzaWxvbjoxLHU9dHlwZW9mIG0uYW5nbGVFcHNpbG9uPT0ibnVtYmVyIj9tLmFuZ2xlRXBzaWxvbjouMDEsTT1tLmFuZ2xlVG9sZXJhbmNlfHwwLGY9bS5jdXNwTGltaXR8fDA7cmV0dXJuIGZ1bmN0aW9uKE8sZyxwLG4sYSxpKXtpfHwoaT1bXSksYT10eXBlb2YgYT09Im51bWJlciI/YToxO3ZhciBvPWwvYTtyZXR1cm4gbyo9byx2KE8sZyxwLG4saSxvKSxpfTtmdW5jdGlvbiB2KFIsTyxnLHAsbixhKXtuLnB1c2godChSKSk7dmFyIGk9UlswXSxvPVJbMV0sVD1PWzBdLEE9T1sxXSxDPWdbMF0sST1nWzFdLFA9cFswXSxMPXBbMV07eChpLG8sVCxBLEMsSSxQLEwsbixhLDApLG4ucHVzaCh0KHApKX1mdW5jdGlvbiB4KFIsTyxnLHAsbixhLGksbyxULEEsQyl7aWYoIShDPnkpKXt2YXIgST1NYXRoLlBJLFA9KFIrZykvMixMPShPK3ApLzIsRD0oZytuKS8yLGI9KHArYSkvMixTPShuK2kpLzIsQj0oYStvKS8yLHc9KFArRCkvMixIPShMK2IpLzIsSj0oRCtTKS8yLHE9KGIrQikvMixXPSh3K0opLzIsRz0oSCtxKS8yO2lmKEM+MCl7dmFyIFE9aS1SLHR0PW8tTyxfPU1hdGguYWJzKChnLWkpKnR0LShwLW8pKlEpLHN0PU1hdGguYWJzKChuLWkpKnR0LShhLW8pKlEpLGssY3Q7aWYoXz5jJiZzdD5jKXtpZigoXytzdCkqKF8rc3QpPD1BKihRKlErdHQqdHQpKXtpZihNPHUpe1QucHVzaChyKFcsRykpO3JldHVybn12YXIgZnQ9TWF0aC5hdGFuMihhLXAsbi1nKTtpZihrPU1hdGguYWJzKGZ0LU1hdGguYXRhbjIocC1PLGctUikpLGN0PU1hdGguYWJzKE1hdGguYXRhbjIoby1hLGktbiktZnQpLGs+PUkmJihrPTIqSS1rKSxjdD49SSYmKGN0PTIqSS1jdCksaytjdDxNKXtULnB1c2gocihXLEcpKTtyZXR1cm59aWYoZiE9PTApe2lmKGs+Zil7VC5wdXNoKHIoZyxwKSk7cmV0dXJufWlmKGN0PmYpe1QucHVzaChyKG4sYSkpO3JldHVybn19fX1lbHNlIGlmKF8+Yyl7aWYoXypfPD1BKihRKlErdHQqdHQpKXtpZihNPHUpe1QucHVzaChyKFcsRykpO3JldHVybn1pZihrPU1hdGguYWJzKE1hdGguYXRhbjIoYS1wLG4tZyktTWF0aC5hdGFuMihwLU8sZy1SKSksaz49SSYmKGs9MipJLWspLGs8TSl7VC5wdXNoKHIoZyxwKSksVC5wdXNoKHIobixhKSk7cmV0dXJufWlmKGYhPT0wJiZrPmYpe1QucHVzaChyKGcscCkpO3JldHVybn19fWVsc2UgaWYoc3Q+Yyl7aWYoc3Qqc3Q8PUEqKFEqUSt0dCp0dCkpe2lmKE08dSl7VC5wdXNoKHIoVyxHKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihvLWEsaS1uKS1NYXRoLmF0YW4yKGEtcCxuLWcpKSxrPj1JJiYoaz0yKkktayksazxNKXtULnB1c2gocihnLHApKSxULnB1c2gocihuLGEpKTtyZXR1cm59aWYoZiE9PTAmJms+Zil7VC5wdXNoKHIobixhKSk7cmV0dXJufX19ZWxzZSBpZihRPVctKFIraSkvMix0dD1HLShPK28pLzIsUSpRK3R0KnR0PD1BKXtULnB1c2gocihXLEcpKTtyZXR1cm59fXgoUixPLFAsTCx3LEgsVyxHLFQsQSxDKzEpLHgoVyxHLEoscSxTLEIsaSxvLFQsQSxDKzEpfX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiY29tcHV0ZU1pdGVyIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsIm5vcm1hbCIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJkaXJlY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgcj10KDEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBzKGEpe3JldHVyblthWzBdLGFbMV1dfWZ1bmN0aW9uIG0oKXtyZXR1cm5bMCwwXX1jb25zdCB5PXIudmVjMi5jb3B5LGM9ci52ZWMyLnNjYWxlQW5kQWRkLGw9ci52ZWMyLmRvdCx1PXIudmVjMi5yb3RhdGUsTT1yLnZlYzIuY3Jvc3MsZj1yLnZlYzIuc3ViLHY9ci52ZWMyLmFkZCx4PXIudmVjMi5ub3JtYWxpemUsUj1yLnZlYzIuc2V0LE89bSgpO2Z1bmN0aW9uIGcoYSxpLG8sVCxBKXt2KGEsbyxUKSx4KGEsYSksUihpLC1hWzFdLGFbMF0pLFIoTywtb1sxXSxvWzBdKTtjb25zdCBDPUEvbChpLE8pO3JldHVybiBNYXRoLmFicyhDKX1mdW5jdGlvbiBwKGEsaSl7cmV0dXJuIFIoYSwtaVsxXSxpWzBdKSxhfWZ1bmN0aW9uIG4oYSxpLG8pe3JldHVybiBmKGEsaSxvKSx4KGEsYSksYX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDUxKSxzPXQoNTIpO2guZXhwb3J0cz1mdW5jdGlvbih5LGMpe3JldHVybiB5PXIoeSxjKSx5PXMoeSxjKSx5fSxoLmV4cG9ydHMucmFkaWFsRGlzdGFuY2U9cixoLmV4cG9ydHMuZG91Z2xhc1BldWNrZXI9c30sZnVuY3Rpb24oaCxlKXtmdW5jdGlvbiB0KHIscyl7dmFyIG09clswXS1zWzBdLHk9clsxXS1zWzFdO3JldHVybiBtKm0reSp5fWguZXhwb3J0cz1mdW5jdGlvbihzLG0pe2lmKHMubGVuZ3RoPD0xKXJldHVybiBzO209dHlwZW9mIG09PSJudW1iZXIiP206MTtmb3IodmFyIHk9bSptLGM9c1swXSxsPVtjXSx1LE09MSxmPXMubGVuZ3RoO008ZjtNKyspdT1zW01dLHQodSxjKT55JiYobC5wdXNoKHUpLGM9dSk7cmV0dXJuIGMhPT11JiZsLnB1c2godSksbH19LGZ1bmN0aW9uKGgsZSl7ZnVuY3Rpb24gdChzLG0seSl7dmFyIGM9bVswXSxsPW1bMV0sdT15WzBdLWMsTT15WzFdLWw7aWYodSE9PTB8fE0hPT0wKXt2YXIgZj0oKHNbMF0tYykqdSsoc1sxXS1sKSpNKS8odSp1K00qTSk7Zj4xPyhjPXlbMF0sbD15WzFdKTpmPjAmJihjKz11KmYsbCs9TSpmKX1yZXR1cm4gdT1zWzBdLWMsTT1zWzFdLWwsdSp1K00qTX1mdW5jdGlvbiByKHMsbSx5LGMsbCl7Zm9yKHZhciB1PWMsTSxmPW0rMTtmPHk7ZisrKXt2YXIgdj10KHNbZl0sc1ttXSxzW3ldKTt2PnUmJihNPWYsdT12KX11PmMmJihNLW0+MSYmcihzLG0sTSxjLGwpLGwucHVzaChzW01dKSx5LU0+MSYmcihzLE0seSxjLGwpKX1oLmV4cG9ydHM9ZnVuY3Rpb24obSx5KXtpZihtLmxlbmd0aDw9MSlyZXR1cm4gbTt5PXR5cGVvZiB5PT0ibnVtYmVyIj95OjE7dmFyIGM9eSp5LGw9bS5sZW5ndGgtMSx1PVttWzBdXTtyZXR1cm4gcihtLDAsbCxjLHUpLHUucHVzaChtW2xdKSx1fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZ2V0VG90YWxMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZ2V0UG9pbnRBdExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJnZXREYXNoQ29udG91cnMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDU0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyhsKXtpZihsLnRvdGFsTGVuZ3RoIT1udWxsKXJldHVybiBsLnRvdGFsTGVuZ3RoO2xldCB1PTA7cmV0dXJuIGwuZm9yRWFjaChNPT57bGV0IGY9TVswXTtmb3IobGV0IHY9MTt2PE0ubGVuZ3RoO3YrKyl7Y29uc3QgeD1NW3ZdO3UrPU9iamVjdChyLmRpc3RhbmNlKShmLHgpLGY9eH19KSxsLnRvdGFsTGVuZ3RoPXUsdX1mdW5jdGlvbiBtKGwsdSxNPSEwKXtpZih1PU51bWJlcih1KSwhTnVtYmVyLmlzRmluaXRlKHUpKXRocm93IG5ldyBUeXBlRXJyb3IoIkZhaWxlZCB0byBleGVjdXRlICdnZXRQb2ludEF0TGVuZ3RoJyBvbiBmaWd1cmU6IFRoZSBwcm92aWRlZCBmbG9hdCB2YWx1ZSBpcyBub24tZmluaXRlLiIpO2lmKHU8PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiTGVuZ3RoIG11c3QgPiAwIik7Y29uc3QgZj1zKGwpO2lmKHU+PWYpe2NvbnN0IHg9bFtsLmxlbmd0aC0xXSxSPXhbeC5sZW5ndGgtMl0sTz14W3gubGVuZ3RoLTFdLGc9TWF0aC5hdGFuMihPWzFdLVJbMV0sT1swXS1SWzBdKTtyZXR1cm57Y3VycmVudDpsLm1hcChwPT5bLi4ucF0pLHBvaW50Ont4Ok9bMF0seTpPWzFdLGFuZ2xlOmd9fX1jb25zdCB2PVtdO2ZvcihsZXQgeD0wO3g8bC5sZW5ndGg7eCsrKXt2W3hdPVtdO2NvbnN0IFI9bFt4XTtsZXQgTz1SWzBdO2ZvcihsZXQgZz0xO2c8Ui5sZW5ndGg7ZysrKXtjb25zdCBwPVJbZ10sbj1PYmplY3Qoci5kaXN0YW5jZSkoTyxwKTtpZih1PG4pe2NvbnN0IGE9dS9uLGk9TWF0aC5hdGFuMihwWzFdLU9bMV0scFswXS1PWzBdKSxvPXt4Ok9bMF0qKDEtYSkrcFswXSphLHk6T1sxXSooMS1hKStwWzFdKmEsYW5nbGU6aX07aWYodlt4XS5wdXNoKE8pLHU+MCYmdlt4XS5wdXNoKFtvLngsby55XSksIU0pcmV0dXJue2N1cnJlbnQ6dixwb2ludDpvfTtjb25zdCBUPVtdLEE9eDtmb3IoO3g8bC5sZW5ndGg7eCsrKXtmb3IoVFt4LUFdPVtdLHg9PT1BJiZUWzBdLnB1c2goW28ueCxvLnldKTtnPFIubGVuZ3RoO2crKylUW3gtQV0ucHVzaChSW2ddKTtnPTB9cmV0dXJue2N1cnJlbnQ6dixwb2ludDpvLHJlc3Q6VH19dS09bix2W3hdLnB1c2goTyksTz1wfX19ZnVuY3Rpb24geShsLHUpe2lmKHU9TnVtYmVyKHUpLCFOdW1iZXIuaXNGaW5pdGUodSkpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYobC5sZW5ndGg8PTApcmV0dXJue3g6MCx5OjAsYW5nbGU6MH07aWYodTw9MCl7Y29uc3QgTT1sWzBdWzBdLGY9bFswXVsxXSx2PU1hdGguYXRhbjIoZlsxXS1NWzFdLGZbMF0tTVswXSk7cmV0dXJue3g6TVswXSx5Ok1bMV0sYW5nbGU6dn19cmV0dXJuIG0obCx1LCExKS5wb2ludH1mdW5jdGlvbiBjKGwsdSxNKXtsZXQgZj0wLHY9dVswXSx4PWw7Y29uc3QgUj1bXSxPPXUubGVuZ3RoO2lmKE0+MCl7ZG8gTS09dVtmJU9dLGYrKzt3aGlsZShNPjApO008MCYmKHY9LU0sZi0tKX1lbHNlIGlmKE08MCl7Zj0tMTtkbyBNKz11W2YlTytPLTFdLGYtLTt3aGlsZShNPDApO00+PTAmJihmKyssdj11W2YlTytPLTFdLU0pfWRve2NvbnN0IGc9bSh4LHYpO3g9Zy5yZXN0LCsrZiUyJiZSLnB1c2goLi4uZy5jdXJyZW50KTtsZXQgcD1mJU87cDwwJiYocCs9Tyksdj11W3BdfXdoaWxlKHgpO3JldHVybiBSfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsImRpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBzfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIoW20seSxjXSxsLHUsTSl7cmV0dXJuIG09bSoyL2wtMSx5PTEteSoyL3UsTnVtYmVyLmlzRmluaXRlKE0pPyhjPWMqMi9NLTEsW20seSxjXSk6W20seV19ZnVuY3Rpb24gcyhbbSx5LGM9MF0sW2wsdSxNPTBdKXtyZXR1cm4gTWF0aC5oeXBvdChsLW0sdS15LE0tYyl9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRQb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPU1hdGguUEkqMjtmdW5jdGlvbiBzKG0seSxjLGwsdSl7dSU9cix1PDAmJih1Kz1yKTtjb25zdCBNPU1hdGgudGFuKHUpO2lmKE1hdGguYWJzKE0pPDFlNSl7Y29uc3QgZj15LU0qbSx2PTEvYyoqMitNKioyL2wqKjI7bGV0IHg9LTE7KHU8PU1hdGguUEkvMnx8dT4zKk1hdGguUEkvMikmJih4PTEpO2NvbnN0IFI9eCpNYXRoLnNxcnQoMS92KSttLE89TSpSK2Y7cmV0dXJuW1IsT119cmV0dXJuIHU8TWF0aC5QST9bbSx5K2xdOlttLHktbF19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBWfSk7dmFyIHI9dCgxKSxzPXQoNDIpLG09dC5uKHMpLHk9dCg1NyksYz10KDI4KSxsPXQoMjQpLHU9dCgzMCksTT10KDU5KSxmPXQoNTMpLHY9dCg2MCkseD10Lm4odiksUj10KDQ2KSxPPXQubihSKSxnPXQoMzEpLHA9dCg0MCksbj10KDIxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShYLGope2lmKFg9PW51bGwpcmV0dXJue307dmFyIHo9aShYLGopLGQsRTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgTj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFgpO2ZvcihFPTA7RTxOLmxlbmd0aDtFKyspZD1OW0VdLCEoai5pbmRleE9mKGQpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFgsZCkmJih6W2RdPVhbZF0pfXJldHVybiB6fWZ1bmN0aW9uIGkoWCxqKXtpZihYPT1udWxsKXJldHVybnt9O3ZhciB6PXt9LGQ9T2JqZWN0LmtleXMoWCksRSxOO2ZvcihOPTA7TjxkLmxlbmd0aDtOKyspRT1kW05dLCEoai5pbmRleE9mKEUpPj0wKSYmKHpbRV09WFtFXSk7cmV0dXJuIHp9Y29uc3Qgbz1TeW1ib2woIm1lc2giKSxUPVN5bWJvbCgiY29udG91cnMiKSxBPVN5bWJvbCgic3Ryb2tlIiksQz1TeW1ib2woImZpbGwiKSxJPVN5bWJvbCgic3Ryb2tlQ29sb3IiKSxQPVN5bWJvbCgiZmlsbENvbG9yIiksTD1TeW1ib2woInRyYW5zZm9ybSIpLEQ9U3ltYm9sKCJpbnZlcnRUcmFuc2Zvcm0iKSxiPVN5bWJvbCgidW5pZm9ybXMiKSxTPVN5bWJvbCgidGV4T3B0aW9ucyIpLEI9U3ltYm9sKCJibGVuZCIpLHc9U3ltYm9sKCJhcHBseVRleHR1cmUiKSxIPVN5bWJvbCgiYXBwbHlUcmFuc2Zvcm0iKSxKPVN5bWJvbCgiYXBwbHlHcmFkaWVudFRyYW5zZm9ybSIpLHE9U3ltYm9sKCJhcHBseVByb2dyYW0iKSxXPVN5bWJvbCgiZ3JhZGllbnQiKSxHPVN5bWJvbCgiZmlsdGVyIiksUT1TeW1ib2woIm9wYWNpdHkiKSx0dD1TeW1ib2woInByb2dyYW0iKSxfPVN5bWJvbCgiYXR0cmlidXRlcyIpLHN0PVN5bWJvbCgicGFzcyIpLGs9U3ltYm9sKCJjbGlwQ29udGV4dCIpLGN0PVN5bWJvbCgiYXBwbHlDbGlwUGF0aCIpO2Z1bmN0aW9uIGZ0KFgsail7Y29uc3RbeixkXT1bWFsxXVswXS1YWzBdWzBdLFhbMV1bMV0tWFswXVsxXV0sRT1bXTtmb3IobGV0IE49MDtOPGoubGVuZ3RoO04rKyl7Y29uc3QgJD1qW05dLEs9WygkWzBdLVhbMF1bMF0pL3osMS0oJFsxXS1YWzBdWzFdKS9kXTtFLnB1c2goSyl9cmV0dXJuIEV9ZnVuY3Rpb24gVShbWCxqXSxbeixkLEUsTl0se3NjYWxlOiR9KXtyZXR1cm4gJHx8KFgvPUUsaj0xLWovTixYLT16LGorPWQpLFtYLGosMF19ZnVuY3Rpb24gRihYLGoseil7Y29uc3QgZD1PKCkoWCxqLHopO3JldHVybiBkLnBhdGg9WCxkLnNpbXBsaWZ5PXosZC5zY2FsZT1qLGR9Y2xhc3MgVntjb25zdHJ1Y3RvcihqKXt0aGlzW0FdPW51bGwsdGhpc1tDXT1udWxsLHRoaXNbTF09WzEsMCwwLDEsMCwwXSx0aGlzW1FdPTEsdGhpc1tiXT17fSx0aGlzW0ddPVtdLHRoaXNbQl09bnVsbCx0aGlzW1NdPXt9LHRoaXMuY29udG91cnM9ai5jb250b3Vycyx0aGlzW3R0XT1udWxsLHRoaXNbX109e30sdGhpc1tzdF09W119Z2V0IGNvbnRvdXJzKCl7cmV0dXJuIHRoaXNbVF19c2V0IGNvbnRvdXJzKGope3RoaXNbb109bnVsbCx0aGlzW1RdPWo7Y29uc3Qgej1qLnNjYWxlO3RoaXMudHJhbnNmb3JtU2NhbGUvej4xLjUmJnRoaXMuYWNjdXJhdGUodGhpcy50cmFuc2Zvcm1TY2FsZSl9c2V0UHJvZ3JhbShqKXt0aGlzW3R0XT1qLHRoaXNbb10mJnRoaXNbcV0oail9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1t0dF19c2V0QXR0cmlidXRlKGoseil7ej09bnVsbD9kZWxldGUgdGhpc1tfXVtqXTp0aGlzW19dW2pdPXp9Z2V0T3BhY2l0eSgpe3JldHVybiB0aGlzW1FdfXNldE9wYWNpdHkoail7aWYoajwwfHxqPjEpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBvcGFjaXR5IHZhbHVlLiIpO3RoaXNbb10mJnRoaXNbb10ucG9zaXRpb25zLmZvckVhY2goej0+e3pbMl09MS96WzJdPjA/ajotan0pLHRoaXNbUV09an1zZXRDbGlwUGF0aChqKXt0aGlzLmNsaXBQYXRoPWosdGhpc1tiXS51X2NsaXBTYW1wbGVyJiZ0aGlzW2JdLnVfY2xpcFNhbXBsZXIuZGVsZXRlKCksdGhpcy5zZXRVbmlmb3Jtcyh7dV9jbGlwU2FtcGxlcjpudWxsfSksdGhpc1tvXSYmZGVsZXRlIHRoaXNbb10uYXR0cmlidXRlcy5hX2NsaXBVVixqJiZ0aGlzW29dJiZ0aGlzW2N0XSgpfVtjdF0oKXtpZih0aGlzLmNsaXBQYXRoKXt0aGlzW2tdfHwodGhpc1trXT1uLmRlZmF1bHQuY3JlYXRlQ2FudmFzKDEsMSkpO2NvbnN0W1tqLHpdLFtkLEVdXT10aGlzLmJvdW5kaW5nQm94O2QmJkUmJih0aGlzW2tdLndpZHRoPWQtaix0aGlzW2tdLmhlaWdodD1FLXopO2NvbnN0IE49dGhpc1trXS5nZXRDb250ZXh0KCIyZCIpLCQ9bmV3IFBhdGgyRCh0aGlzLmNsaXBQYXRoKTtOLmNsZWFyUmVjdCgwLDAsdGhpc1trXS53aWR0aCx0aGlzW2tdLmhlaWdodCksTi5zYXZlKCksTi50cmFuc2xhdGUoLWosLXopLE4uZmlsbFN0eWxlPSJ3aGl0ZSIsTi5maWxsKCQpLE4ucmVzdG9yZSgpLHRoaXNbb10uY2xpcFBhdGg9dGhpc1trXTtjb25zdCBLPWZ0KHRoaXMuYm91bmRpbmdCb3gsdGhpc1tvXS5wb3NpdGlvbjApO3RoaXNbb10uYXR0cmlidXRlcy5hX2NsaXBVVj1LfX1nZXRQb2ludEF0TGVuZ3RoKGope3JldHVybiBPYmplY3QoZi5nZXRQb2ludEF0TGVuZ3RoKSh0aGlzW1RdLGopfWdldFRvdGFsTGVuZ3RoKCl7cmV0dXJuIE9iamVjdChmLmdldFRvdGFsTGVuZ3RoKSh0aGlzW1RdKX1nZXQgYmxlbmQoKXtyZXR1cm4gdGhpc1tCXT09bnVsbD8iYXV0byI6dGhpc1tCXX1zZXQgYmxlbmQoail7dGhpc1tCXT1qLHRoaXNbb10mJih0aGlzW29dLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQpfWdldCBib3VuZGluZ0JveCgpe2lmKHRoaXNbb10mJnRoaXNbb10uYm91bmRpbmdCb3gpcmV0dXJuIHRoaXNbb10uYm91bmRpbmdCb3g7Y29uc3Qgaj10aGlzLm1lc2hEYXRhO2lmKGope2NvbnN0IHo9ai5wb3NpdGlvbjA7aWYoei5sZW5ndGgpai5ib3VuZGluZ0JveD1tKCkoeik7ZWxzZSByZXR1cm5bWzAsMF0sWzAsMF1dO3JldHVybiBqLmJvdW5kaW5nQm94fXJldHVybltbMCwwXSxbMCwwXV19Z2V0IGJvdW5kaW5nQ2VudGVyKCl7Y29uc3Qgaj10aGlzLmJvdW5kaW5nQm94O3JldHVybiBqP1suNSooalswXVswXStqWzFdWzBdKSwuNSooalswXVsxXStqWzFdWzFdKV06WzAsMF19Z2V0IGZpbGxSdWxlKCl7cmV0dXJuIHRoaXNbQ10/dGhpc1tDXS5ydWxlOiJub256ZXJvIn1nZXQgbGluZVdpZHRoKCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5saW5lV2lkdGg6MH1nZXQgbGluZUNhcCgpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ubGluZUNhcDoiIn1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLmxpbmVKb2luOiIifWdldCBtaXRlckxpbWl0KCl7cmV0dXJuIHRoaXNbQV0/dGhpc1tBXS5taXRlckxpbWl0OjB9Z2V0IHN0cm9rZVN0eWxlKCl7cmV0dXJuIHRoaXNbSV0mJnRoaXNbSV1bM10hPT0wP09iamVjdChsLmRlZmF1bHQpKHRoaXNbSV0pOiIifWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ubGluZURhc2g6bnVsbH1nZXQgbGluZURhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1tBXT90aGlzW0FdLmxpbmVEYXNoT2Zmc2V0OjB9Z2V0IGZpbGxTdHlsZSgpe3JldHVybiB0aGlzW1BdJiZ0aGlzW1BdWzNdIT09MD9PYmplY3QobC5kZWZhdWx0KSh0aGlzW1BdKToiIn1nZXQgZ3JhZGllbnQoKXtyZXR1cm4gdGhpc1tXXX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW2JdLnVfdGV4U2FtcGxlcj97aW1hZ2U6dGhpc1tiXS51X3RleFNhbXBsZXIuX2ltZyxvcHRpb25zOnRoaXNbU119Om51bGx9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbQl09PT0hMHx8dGhpc1tCXT09PSExP3RoaXNbQl06dGhpc1tRXTwxfHx0aGlzW0ldIT1udWxsJiZ0aGlzW0ldWzNdPDF8fHRoaXNbUF0hPW51bGwmJnRoaXNbUF1bM108MXx8dGhpc1tiXS51X2NvbG9yTWF0cml4IT1udWxsJiZ0aGlzW2JdLnVfY29sb3JNYXRyaXhbMThdPDF8fHRoaXNbYl0udV9yYWRpYWxHcmFkaWVudFZlY3RvciE9bnVsbHx8dGhpcy5iZWZvcmVSZW5kZXJ8fHRoaXMuYWZ0ZXJSZW5kZXJ9Z2V0IGZpbHRlckNhbnZhcygpe3JldHVybi9ibHVyfGRyb3Atc2hhZG93fHVybC8udGVzdCh0aGlzLmZpbHRlcil9Z2V0IGZpbHRlcigpe3JldHVybiB0aGlzW0ddLmpvaW4oIiAiKX1nZXQgdHJhbnNmb3JtTWF0cml4KCl7cmV0dXJuIHRoaXNbTF19Z2V0IGludmVydE1hdHJpeCgpe2lmKCF0aGlzW0RdKXtjb25zdCBqPXIubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzW0xdKTt0aGlzW0RdPWp9cmV0dXJuIHRoaXNbRF19Z2V0IHRyYW5zZm9ybVNjYWxlKCl7Y29uc3Qgaj10aGlzW0xdO3JldHVybiBNYXRoLm1heChNYXRoLmh5cG90KGpbMF0salsxXSksTWF0aC5oeXBvdChqWzJdLGpbM10pKX1nZXQgdW5pZm9ybXMoKXtyZXR1cm4gdGhpc1tiXX1nZXQgcGFzcygpe3JldHVybiB0aGlzW3N0XX1bcV0oail7Y29uc3Qgej10aGlzW19dLGQ9dGhpc1tvXS5wb3NpdGlvbjAsRT1PYmplY3QuZW50cmllcyhqLl9hdHRyaWJ1dGUpO2ZvcihsZXQgTj0wO048RS5sZW5ndGg7TisrKXtjb25zdFskLEtdPUVbTl07aWYoJCE9PSJhX2NvbG9yIiYmJCE9PSJhX3NvdXJjZVJlY3QiJiZLIT09Imlnbm9yZWQiKXtjb25zdCBZPXpbJF07aWYoJD09PSJ1diImJiFZKXtjb25zdCBaPXRoaXNbb10uYm91bmRpbmdCb3h8fG0oKShkKTt0aGlzW29dLmF0dHJpYnV0ZXNbJF09ZnQoWixkKX1lbHNle3RoaXNbb10uYXR0cmlidXRlc1skXT1bXTtmb3IobGV0IFo9MDtaPGQubGVuZ3RoO1orKyl7Y29uc3QgZXQ9ZFtaXTt0aGlzW29dLmF0dHJpYnV0ZXNbJF0ucHVzaChZP1koZXQsTixkKTpBcnJheShLLnNpemUpLmZpbGwoMCkpfX19fX1nZXQgbWVzaERhdGEoKXtpZih0aGlzLl91cGRhdGVNYXRyaXgmJnRoaXMudHJhbnNmb3JtU2NhbGUvdGhpcy5jb250b3Vycy5zY2FsZT4xLjUmJnRoaXMuYWNjdXJhdGUodGhpcy50cmFuc2Zvcm1TY2FsZSksIXRoaXNbb10peyF0aGlzW0NdJiYhdGhpc1tBXSYmdGhpcy5zZXRGaWxsKCk7Y29uc3Qgaj10aGlzW1RdLHo9e307aWYoaiYmai5sZW5ndGgpe2lmKHRoaXNbQ10pdHJ5e2NvbnN0IE49eCgpKGosdGhpc1tDXSk7Ti5wb3NpdGlvbnM9Ti5wb3NpdGlvbnMubWFwKCQ9PigkLnB1c2godGhpc1tRXSksJCkpLE4uYXR0cmlidXRlcz17YV9jb2xvcjpBcnJheS5mcm9tKHtsZW5ndGg6Ti5wb3NpdGlvbnMubGVuZ3RofSkubWFwKCgpPT50aGlzW1BdLm1hcCgkPT5NYXRoLnJvdW5kKDI1NSokKSkpfSx6LmZpbGw9Tn1jYXRjaHt9aWYodGhpc1tBXSl7Y29uc3QgTj10aGlzW0FdLmxpbmVEYXNoO2xldCAkPWo7aWYoTil7Y29uc3QgWT10aGlzW0FdLmxpbmVEYXNoT2Zmc2V0OyQ9T2JqZWN0KGYuZ2V0RGFzaENvbnRvdXJzKShqLE4sWSl9Y29uc3QgSz0kLm1hcCgoWSxaKT0+e2NvbnN0IGV0PVkubGVuZ3RoPjEmJnIudmVjMi5lcXVhbHMoWVswXSxZW1kubGVuZ3RoLTFdKSxydD10aGlzW0FdLmJ1aWxkKFksZXQpO3JldHVybiB4KCkoW3J0XSl9KTtLLmZvckVhY2goWT0+e1kucG9zaXRpb25zPVkucG9zaXRpb25zLm1hcChaPT4oWi5wdXNoKC10aGlzW1FdKSxaKSksWS5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpZLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbSV0ubWFwKFo9Pk1hdGgucm91bmQoMjU1KlopKSl9fSksei5zdHJva2U9T2JqZWN0KGMuZGVmYXVsdCkoSyl9fWNvbnN0IGQ9T2JqZWN0KGMuZGVmYXVsdCkoW3ouZmlsbCx6LnN0cm9rZV0pO2QuZmlsbFBvaW50Q291bnQ9ei5maWxsP3ouZmlsbC5wb3NpdGlvbnMubGVuZ3RoOjAsZC5lbmFibGVCbGVuZD10aGlzLmVuYWJsZUJsZW5kLGQucG9zaXRpb24wPWQucG9zaXRpb25zLm1hcCgoW04sJCxLXSk9PltOLCQsS10pLGQudW5pZm9ybXM9dGhpc1tiXSx0aGlzW29dPWQsdGhpc1tiXS51X3RleFNhbXBsZXImJnRoaXNbd10oZCx0aGlzW1NdKTtjb25zdCBFPXRoaXNbTF07T2JqZWN0KE0uaXNVbml0VHJhbnNmb3JtKShFKXx8KHRoaXNbSF0oZCxFKSx0aGlzW2JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3ImJnRoaXNbSl0oKSksdGhpcy5jbGlwUGF0aCYmdGhpc1tjdF0oKSx0aGlzW3R0XSYmdGhpc1txXSh0aGlzW3R0XSl9cmV0dXJuIHRoaXMuX3VwZGF0ZU1hdHJpeCYmKHRoaXNbb10ubWF0cml4PXRoaXNbTF0sdGhpc1tIXSh0aGlzW29dLHRoaXNbTF0pLHRoaXNbYl0udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1tKXSgpKSx0aGlzW29dfVtIXShqLHope2NvbnN0e3Bvc2l0aW9uczpkLHBvc2l0aW9uMDpFfT1qO2ZvcihsZXQgTj0wO048ZC5sZW5ndGg7TisrKXtjb25zdFskLEtdPUVbTl0sWT1kW05dO1lbMF09JCp6WzBdK0sqelsyXSt6WzRdLFlbMV09JCp6WzFdK0sqelszXSt6WzVdfXRoaXMuX3VwZGF0ZU1hdHJpeD0hMX1bSl0oKXtjb25zdCBqPXRoaXNbTF0sej1bLi4udGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3JdO2lmKHope2NvbnN0W2QsRSwsTiwkXT16O3pbMF09ZCpqWzBdK0UqalsyXStqWzRdLHpbMV09ZCpqWzFdK0UqalszXStqWzVdLHpbM109TipqWzBdKyQqalsyXStqWzRdLHpbNF09TipqWzFdKyQqalszXStqWzVdLHRoaXNbYl0udV9yYWRpYWxHcmFkaWVudFZlY3Rvcj16fX1bd10oaix6KXtmdW5jdGlvbiBkKFosZXQpe3JldHVybiBaPT1udWxsJiZldD09bnVsbD8hMDpaPT1udWxsfHxldD09bnVsbD8hMTpaWzBdPT09ZXRbMF0mJlpbMV09PT1ldFsxXSYmWlsyXT09PWV0WzJdJiZaWzNdPT09ZXRbM119Y29uc3QgRT10aGlzW2JdLnVfdGV4U2FtcGxlcjtpZighRSlyZXR1cm47Y29uc3R7d2lkdGg6TixoZWlnaHQ6JH09RS5faW1nLEs9ei5zcmNSZWN0O2xldCBZPXoucmVjdHx8WzAsMF07aWYoei5yb3RhdGVkJiYoWT1bLVlbMV0sWVswXSxZWzNdLFlbMl1dKSxZWzJdPT1udWxsJiYoWVsyXT1LP0tbMl06TiksWVszXT09bnVsbCYmKFlbM109Sz9LWzNdOiQpLHouaGlkZGVuKWoudGV4dHVyZUNvb3JkPWoucG9zaXRpb25zLm1hcCgoKT0+Wy0xLC0xLC0xXSk7ZWxzZSBpZighai50ZXh0dXJlQ29vcmR8fCFkKHRoaXNbU10ucmVjdCx6LnJlY3QpfHx0aGlzW1NdLmhpZGRlbiE9PXouaGlkZGVufHx0aGlzW1NdLnJvdGF0ZWQhPT16LnJvdGF0ZWQpe2xldCBaPW51bGw7ei5yb3RhdGVkJiYoWj1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksci5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKSwuNSpNYXRoLlBJKSxaPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxaLFswLC1ZWzJdXSkpLGoudGV4dHVyZUNvb3JkPWoucG9zaXRpb24wLm1hcCgoW2V0LHJ0LGF0XSk9PntpZigxL2F0PjApe2lmKHoucm90YXRlZCl7Y29uc3QgaXQ9ZXQqWlswXStydCpaWzJdK1pbNF0sbnQ9ZXQqWlsxXStydCpaWzNdK1pbNV07W2V0LHJ0XT1baXQsbnRdfWNvbnN0IGx0PVUoW2V0LHJ0XSxbWVswXS9ZWzJdLFlbMV0vWVszXSxZWzJdLFlbM11dLHopO3JldHVybiB6LnJlcGVhdCYmKGx0WzJdPTEpLGx0fXJldHVyblstMSwtMSwtMV19KX1pZihLKXtjb25zdCBaPVtLWzBdL04sS1sxXS8kLEtbMl0vTixLWzNdLyRdO2ouYXR0cmlidXRlcy5hX3NvdXJjZVJlY3Q9ai5wb3NpdGlvbnMubWFwKCgpPT5bLi4uWl0pfWVsc2Ugai5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1qLnBvc2l0aW9ucy5tYXAoKCk9PlswLDAsMCwwXSl9YWNjdXJhdGUoail7aWYoIXRoaXMuY29udG91cnMpcmV0dXJuO2lmKHRoaXMuY29udG91cnMucGF0aCl7Y29uc3QgZD10aGlzLmNvbnRvdXJzLnNpbXBsaWZ5LEU9Rih0aGlzLmNvbnRvdXJzLnBhdGgsMipqLGQpO3RoaXNbb109bnVsbCx0aGlzW1RdPUV9fWNhbklnbm9yZSgpe2NvbnN0IGo9dGhpc1tBXT09bnVsbHx8dGhpc1tBXS5saW5lV2lkdGg9PT0wfHx0aGlzW0ldWzNdPT09MCx6PXRoaXNbQ109PW51bGx8fHRoaXNbUF1bM109PT0wLGQ9dGhpc1tiXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPT1udWxsLEU9dGhpc1tiXS51X3RleFNhbXBsZXI9PW51bGw7cmV0dXJuIHRoaXNbUV09PT0wfHx0aGlzW3R0XT09bnVsbCYmaiYmeiYmZCYmRSYmIXRoaXMuYmVmb3JlUmVuZGVyJiYhdGhpcy5hZnRlclJlbmRlcn1zZXRTdHJva2Uoe3RoaWNrbmVzczpqPTEsY2FwOno9ImJ1dHQiLGpvaW46ZD0ibWl0ZXIiLG1pdGVyTGltaXQ6RT0xMCxjb2xvcjpOPVswLDAsMCwwXSxsaW5lRGFzaDokPW51bGwsbGluZURhc2hPZmZzZXQ6Sz0wLHJvdW5kU2VnbWVudHM6WT0yMH09e30pe3JldHVybiB0aGlzW29dPW51bGwsdGhpc1tBXT1uZXcgeS5kZWZhdWx0KHtsaW5lV2lkdGg6aixsaW5lQ2FwOnosbGluZUpvaW46ZCxtaXRlckxpbWl0OkUscm91bmRTZWdtZW50czpZfSksdHlwZW9mIE49PSJzdHJpbmciJiYoTj1PYmplY3QoZy5kZWZhdWx0KShOKSksdGhpc1tJXT1OLHRoaXNbQV0ubGluZURhc2g9JCx0aGlzW0FdLmxpbmVEYXNoT2Zmc2V0PUssdGhpc31zZXRGaWxsKHtydWxlOmo9dGhpcy5maWxsUnVsZSxjb2xvcjp6PVswLDAsMCwwXX09e30pe3JldHVybiB0aGlzW29dPW51bGwsdGhpc1tDXT17cnVsZTpqfSx0eXBlb2Ygej09InN0cmluZyImJih6PU9iamVjdChnLmRlZmF1bHQpKHopKSx0aGlzW1BdPXosdGhpc31zZXRUZXh0dXJlKGosej17fSl7aWYoaiYmai5pbWFnZSl7Y29uc3R7aW1hZ2U6ZCxyZWN0OkV9PWo7aWYoaj1kLHoucmVjdClmb3IobGV0IE49MDtOPHoucmVjdC5sZW5ndGg7TisrKUVbTl09ei5yZWN0W05dO3oucmVjdD1FfXJldHVybiB0aGlzW0NdfHx0aGlzLnNldEZpbGwoKSx0aGlzLnNldFVuaWZvcm1zKHt1X3RleFNhbXBsZXI6an0pLHRoaXNbb10mJnRoaXNbd10odGhpc1tvXSx6KSx0aGlzW1NdPXosdGhpc31zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6eix0eXBlOmQ9ImZpbGwifT17fSl7aWYoai5sZW5ndGghPT0zKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZWFyR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOnosdHlwZTpkfSl9c2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczp6LHR5cGU6ZD0iZmlsbCJ9PXt9KXtpZihqLmxlbmd0aCE9PTQpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6eix0eXBlOmR9KX1zZXRSYWRpYWxHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOnosdHlwZTpkPSJmaWxsIn09e30pe2lmKGoubGVuZ3RoIT09Nil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHJhZGlhbEdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczp6LHR5cGU6ZH0pfXNldEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6eix0eXBlOmQ9ImZpbGwifT17fSl7ej16Lm1hcCgoe29mZnNldDokLGNvbG9yOkt9KT0+KHR5cGVvZiBLPT0ic3RyaW5nIiYmKEs9T2JqZWN0KGcuZGVmYXVsdCkoSykpLHtvZmZzZXQ6JCxjb2xvcjpLfSkpLHRoaXNbV109dGhpc1tXXXx8e30sdGhpc1tXXVtkXT17dmVjdG9yOmosY29sb3JzOnp9LHouc29ydCgoJCxLKT0+JC5vZmZzZXQtSy5vZmZzZXQpO2NvbnN0IEU9W107ei5mb3JFYWNoKCh7b2Zmc2V0OiQsY29sb3I6S30pPT57RS5wdXNoKCQsLi4uSyl9KTtsZXQgTjtpZihqLmxlbmd0aD09PTQ/Tj1balswXSxqWzFdLDAsalsyXSxqWzNdLDBdOk49Wy4uLmpdLEUubGVuZ3RoPDQwJiZFLnB1c2goLTEpLEUubGVuZ3RoPjQwKXRocm93IG5ldyBFcnJvcigiVG9vIG1hbnkgY29sb3JzLCBzaG91bGQgYmUgbGVzcyB0aGFuIDggY29sb3JzIik7cmV0dXJuIHRoaXMuX3JhZGlhbEdyYWRpZW50VmVjdG9yPU4sdGhpc1tiXS51X2NvbG9yU3RlcHM9RSxkPT09ImZpbGwiP3RoaXNbYl0udV9ncmFkaWVudFR5cGU9MTp0aGlzW2JdLnVfZ3JhZGllbnRUeXBlPTAsdGhpc1tKXSgpLHRoaXN9c2V0VW5pZm9ybXMoaj17fSl7cmV0dXJuIE9iamVjdC5hc3NpZ24odGhpc1tiXSxqKSx0aGlzfXNldFRyYW5zZm9ybSguLi5qKXtjb25zdCB6PXRoaXNbTF07cmV0dXJuIHIubWF0MmQuZXF1YWxzKGoseil8fCh0aGlzW0xdPWosZGVsZXRlIHRoaXNbRF0sdGhpcy5fdXBkYXRlTWF0cml4PSEwKSx0aGlzfXRyYW5zZm9ybSguLi5qKXtjb25zdCB6PXRoaXNbTF07cmV0dXJuIHRoaXNbTF09ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCkseixqKSxkZWxldGUgdGhpc1tEXSx0aGlzLl91cGRhdGVNYXRyaXg9ITAsdGhpc310cmFuc2xhdGUoaix6KXtsZXQgZD1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBkPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxkLFtqLHpdKSx0aGlzLnRyYW5zZm9ybSguLi5kKX1yb3RhdGUoaixbeixkXT1bMCwwXSl7bGV0IEU9ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gRT1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRSxbeixkXSksRT1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRSxqKSxFPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxFLFsteiwtZF0pLHRoaXMudHJhbnNmb3JtKC4uLkUpfXNjYWxlKGosej1qLFtkLEVdPVswLDBdKXtsZXQgTj1yLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBOPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFtkLEVdKSxOPXIubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sW2osel0pLE49ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sWy1kLC1FXSksdGhpcy50cmFuc2Zvcm0oLi4uTil9c2tldyhqLHo9aixbZCxFXT1bMCwwXSl7bGV0IE49ci5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gTj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbZCxFXSksTj1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKHopLE1hdGgudGFuKGopLDEsMCwwKSksTj1yLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbLWQsLUVdKSx0aGlzLnRyYW5zZm9ybSguLi5OKX1jbGVhckZpbHRlcigpe3JldHVybiB0aGlzLnNldENvbG9yVHJhbnNmb3JtKG51bGwpLHRoaXNbR10ubGVuZ3RoPTAsdGhpc31zZXRDb2xvclRyYW5zZm9ybSguLi5qKXtyZXR1cm4galswXT09PW51bGw/dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjAsdV9jb2xvck1hdHJpeDowfSk6dGhpcy5zZXRVbmlmb3Jtcyh7dV9maWx0ZXJGbGFnOjEsdV9jb2xvck1hdHJpeDpqfSksdGhpc310cmFuc2Zvcm1Db2xvciguLi5qKXtsZXQgej10aGlzLnVuaWZvcm1zLnVfY29sb3JNYXRyaXg7cmV0dXJuIHo/ej1PYmplY3QodS5tdWx0aXBseSkoeixqKTp6PWosdGhpcy5zZXRDb2xvclRyYW5zZm9ybSguLi56KSx0aGlzfWJsdXIoail7cmV0dXJuIHRoaXNbR10ucHVzaChgYmx1cigke2p9cHgpYCksdGhpc31icmlnaHRuZXNzKGo9MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgYnJpZ2h0bmVzcygkezEwMCpqfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QodS5icmlnaHRuZXNzKShqKSl9Y29udHJhc3Qoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBjb250cmFzdCgkezEwMCpqfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QodS5jb250cmFzdCkoaikpfWRyb3BTaGFkb3coaix6LGQ9MCxFPVswLDAsMCwxXSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoRSkmJihFPU9iamVjdChsLmRlZmF1bHQpKEUpKSx0aGlzW0ddLnB1c2goYGRyb3Atc2hhZG93KCR7an1weCAke3p9cHggJHtkfXB4ICR7RX0pYCksdGhpc31ncmF5c2NhbGUoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBncmF5c2NhbGUoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KHUuZ3JheXNjYWxlKShqKSl9aHVlUm90YXRlKGo9MCl7cmV0dXJuIHRoaXNbR10ucHVzaChgaHVlLXJvdGF0ZSgke2p9ZGVnKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KHUuaHVlUm90YXRlKShqKSl9aW52ZXJ0KGo9MSl7cmV0dXJuIHRoaXNbR10ucHVzaChgaW52ZXJ0KCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdCh1LmludmVydCkoaikpfW9wYWNpdHkoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBvcGFjaXR5KCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdCh1Lm9wYWNpdHkpKGopKX1zYXR1cmF0ZShqPTEpe3JldHVybiB0aGlzW0ddLnB1c2goYHNhdHVyYXRlKCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdCh1LnNhdHVyYXRlKShqKSl9c2VwaWEoaj0xKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGBzZXBpYSgkezEwMCpqfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QodS5zZXBpYSkoaikpfXVybChqKXtyZXR1cm4gdGhpc1tHXS5wdXNoKGB1cmwoJHtqfSlgKSx0aGlzfWlzUG9pbnRDb2xsaXNpb24oaix6LGQ9ImJvdGgiKXtjb25zdCBFPXRoaXMubWVzaERhdGEse3Bvc2l0aW9uczpOLGNlbGxzOiR9PUUsSz10aGlzLmludmVydE1hdHJpeCxZPUtbMF0qaitLWzJdKnorS1s0XSxaPUtbMV0qaitLWzNdKnorS1s1XSxldD10aGlzLmJvdW5kaW5nQm94O2lmKFk8ZXRbMF1bMF18fFk+ZXRbMV1bMF18fFo8ZXRbMF1bMV18fFo+ZXRbMV1bMV0pcmV0dXJuITE7ZnVuY3Rpb24gcnQoW2F0LGx0XSxbaXQsbnRdLFtvdCxkdF0pe2NvbnN0IGd0PW90LWl0LHV0PWR0LW50LG10PSgoYXQtaXQpKmd0KyhsdC1udCkqdXQpLyhndCoqMit1dCoqMik7cmV0dXJuIG10Pj0wJiZtdDw9MX1mb3IobGV0IGF0PTA7YXQ8JC5sZW5ndGg7YXQrKyl7Y29uc3QgbHQ9JFthdF07aWYoZD09PSJmaWxsIiYmbHRbMF0+PUUuZmlsbFBvaW50Q291bnQpYnJlYWs7aWYoZD09PSJzdHJva2UiJiZsdFswXTxFLmZpbGxQb2ludENvdW50KWNvbnRpbnVlO2NvbnN0W1tpdCxudF0sW290LGR0XSxbZ3QsdXRdXT1sdC5tYXAocHQ9Pk5bcHRdKSxtdD1NYXRoLnNpZ24oKGotaXQpKihkdC1udCktKG90LWl0KSooei1udCkpO2lmKG10PT09MCYmcnQoW2osel0sW2l0LG50XSxbb3QsZHRdKSlyZXR1cm4hMDtjb25zdCBPdD1NYXRoLnNpZ24oKGotb3QpKih1dC1kdCktKGd0LW90KSooei1kdCkpO2lmKE90PT09MCYmcnQoW2osel0sW290LGR0XSxbZ3QsdXRdKSlyZXR1cm4hMDtjb25zdCB5dD1NYXRoLnNpZ24oKGotZ3QpKihudC11dCktKGl0LWd0KSooei11dCkpO2lmKHl0PT09MCYmcnQoW2osel0sW2d0LHV0XSxbaXQsbnRdKXx8bXQ9PT0xJiZPdD09PTEmJnl0PT09MXx8bXQ9PT0tMSYmT3Q9PT0tMSYmeXQ9PT0tMSlyZXR1cm4hMH1yZXR1cm4hMX1pc1BvaW50SW5GaWxsKGoseil7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihqLHosImZpbGwiKX1pc1BvaW50SW5TdHJva2Uoaix6KXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGoseiwic3Ryb2tlIil9YWRkUGFzcyhqLHo9e30pe2xldHt3aWR0aDpkLGhlaWdodDpFfT16LE49YSh6LFsid2lkdGgiLCJoZWlnaHQiXSk7Y29uc3QgJD1uZXcgcC5kZWZhdWx0OyQucmVjdCgwLDAsZCxFKTtjb25zdCBLPW5ldyBWKCQse3dpZHRoOmQsaGVpZ2h0OkV9KTtLLnNldFVuaWZvcm1zKE4pLEsuc2V0UHJvZ3JhbShqKSx0aGlzW3N0XS5wdXNoKEspfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCg1OCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1yLlN0cm9rZX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiU3Ryb2tlIixmdW5jdGlvbigpe3JldHVybiBNfSk7dmFyIHI9dCg0OSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHM9T2JqZWN0KHIuY3JlYXRlKSgpLG09T2JqZWN0KHIuY3JlYXRlKSgpLHk9T2JqZWN0KHIuY3JlYXRlKSgpLGM9T2JqZWN0KHIuY3JlYXRlKSgpLGw9T2JqZWN0KHIuY3JlYXRlKSgpLHU9MWUyMDtjbGFzcyBNe2NvbnN0cnVjdG9yKHtsaW5lV2lkdGg6Tz0xLGxpbmVKb2luOmc9Im1pdGVyIixtaXRlckxpbWl0OnA9MTAsbGluZUNhcDpuPSJidXR0Iixyb3VuZFNlZ21lbnRzOmE9MjB9PXt9KXt0aGlzLmxpbmVXaWR0aD1PLHRoaXMubGluZUpvaW49Zyx0aGlzLm1pdGVyTGltaXQ9cCx0aGlzLmxpbmVDYXA9bix0aGlzLnJvdW5kU2VnbWVudHM9YSx0aGlzLl9ub3JtYWw9bnVsbH1idWlsZChPLGc9ITEpe2xldCBwPU8ubGVuZ3RoO2lmKE89Wy4uLk9dLHA8MilyZXR1cm4gTztnJiYoKE9bMF1bMF0hPT1PW3AtMV1bMF18fE9bMF1bMV0hPT1PW3AtMV1bMV0pJiZPLnB1c2goWy4uLk9bMF1dKSxPLnB1c2goWy4uLk9bMV1dKSkscD1PLmxlbmd0aCx0aGlzLl9ub3JtYWw9bnVsbDtjb25zdCBuPXtsZWZ0OltdLHJpZ2h0OltdfSxhPXRoaXMubGluZVdpZHRoLzIsaT10aGlzLmxpbmVDYXA7aWYoIWcmJmk9PT0ic3F1YXJlIil7T2JqZWN0KHIuZGlyZWN0aW9uKShtLE9bMF0sT1sxXSksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKE9bMF0sT1swXSxtLGEpO2NvbnN0IFQ9Ty5sZW5ndGgtMTtPYmplY3Qoci5kaXJlY3Rpb24pKG0sT1tUXSxPW1QtMV0pLE9iamVjdChyLnNjYWxlQW5kQWRkKShPW1RdLE9bVF0sbSxhKX1mb3IobGV0IFQ9MTtUPHA7VCsrKXtjb25zdCBBPU9bVC0xXSxDPU9bVF0sST1PW1QrMV07dGhpcy5fc2VnKG4sQSxDLEksYSxnKX1yZXR1cm4hZyYmaT09PSJyb3VuZCImJngobix0aGlzLnJvdW5kU2VnbWVudHMpLFsuLi5uLmxlZnQsLi4ubi5yaWdodC5yZXZlcnNlKCldfV9zZWcoTyxnLHAsbixhLGkpe2NvbnN0IG89dGhpcy5saW5lSm9pbj09PSJiZXZlbCIsVD10aGlzLmxpbmVKb2luPT09InJvdW5kIjtpZihPYmplY3Qoci5kaXJlY3Rpb24pKG0scCxnKSx0aGlzLl9ub3JtYWx8fCh0aGlzLl9ub3JtYWw9T2JqZWN0KHIuY3JlYXRlKSgpLE9iamVjdChyLm5vcm1hbCkodGhpcy5fbm9ybWFsLG0pKSxPLmxlZnQubGVuZ3RofHx2KE8sZyx0aGlzLl9ub3JtYWwsYSksIW4pT2JqZWN0KHIubm9ybWFsKSh0aGlzLl9ub3JtYWwsbSksaT92KE8sZyx0aGlzLl9ub3JtYWwsYSk6dihPLHAsdGhpcy5fbm9ybWFsLGEpO2Vsc2V7T2JqZWN0KHIuZGlyZWN0aW9uKSh5LG4scCk7bGV0IEE9T2JqZWN0KHIuY29tcHV0ZU1pdGVyKShjLGwsbSx5LGEpO0E9TWF0aC5taW4oQSx1KTtjb25zdCBDPU9iamVjdChyLmRvdCkoYyx0aGlzLl9ub3JtYWwpPDA/LTE6MTtsZXQgST1vfHxUO2lmKCFJJiZ0aGlzLmxpbmVKb2luPT09Im1pdGVyIiYmQS9hPnRoaXMubWl0ZXJMaW1pdCYmKEk9ITApLEkpe09iamVjdChyLnNjYWxlQW5kQWRkKShzLHAsdGhpcy5fbm9ybWFsLC1hKkMpLGYoTyxzLEMpO2xldCBQPTEvMDtnJiYoUD1NYXRoLm1pbihQLE1hdGguaHlwb3QocFswXS1nWzBdLHBbMV0tZ1sxXSkpKSxuJiYoUD1NYXRoLm1pbihQLE1hdGguaHlwb3QoblswXS1wWzBdLG5bMV0tcFsxXSkpKTtjb25zdCBMPU1hdGgubWF4KGEsTWF0aC5taW4oQSxQKSk7aWYoT2JqZWN0KHIuc2NhbGVBbmRBZGQpKHMscCxsLEwqQyksZihPLHMsLUMpLG4paWYoT2JqZWN0KHIubm9ybWFsKShzLHkpLE9iamVjdChyLmNvcHkpKHRoaXMuX25vcm1hbCxzKSxPYmplY3Qoci5zY2FsZUFuZEFkZCkocyxwLHMsLWEqQyksVCl7Y29uc3QgRD1PYmplY3Qoci5jbG9uZSkocyksYj1DPjA/Ty5sZWZ0W08ubGVmdC5sZW5ndGgtMV06Ty5yaWdodFtPLnJpZ2h0Lmxlbmd0aC0xXSxTPU9iamVjdChyLmNsb25lKShwKSxCPU9iamVjdChyLnN1YikoT2JqZWN0KHIuY3JlYXRlKSgpLGIsUyksdz1PYmplY3Qoci5zdWIpKE9iamVjdChyLmNyZWF0ZSkoKSxELFMpLEg9TWF0aC5QSS90aGlzLnJvdW5kU2VnbWVudHM7Zm9yKGxldCBKPTA7Sjx0aGlzLnJvdW5kU2VnbWVudHMmJihPYmplY3Qoci5yb3RhdGUpKEIsQixbMCwwXSxDKkgpLE1hdGguc2lnbihPYmplY3Qoci5jcm9zcykocyxCLHcpWzJdKT09PUMpO0orKylPYmplY3Qoci5hZGQpKHMsQixTKSxmKE8scyxDKTtmKE8sRCxDKX1lbHNlIGYoTyxzLEMpfWVsc2UgdihPLHAsbCxBKSxPYmplY3Qoci5jb3B5KSh0aGlzLl9ub3JtYWwsbCl9fX1mdW5jdGlvbiBmKFIsTyxnKXtnPjA/Ui5sZWZ0LnB1c2goT2JqZWN0KHIuY2xvbmUpKE8pKTpSLnJpZ2h0LnB1c2goT2JqZWN0KHIuY2xvbmUpKE8pKX1mdW5jdGlvbiB2KFIsTyxnLHAsbj0tMSl7T2JqZWN0KHIuc2NhbGVBbmRBZGQpKHMsTyxnLC1wKSxmKFIscywtbiksT2JqZWN0KHIuc2NhbGVBbmRBZGQpKHMsTyxnLHApLGYoUixzLG4pfWZ1bmN0aW9uIHgoe2xlZnQ6UixyaWdodDpPfSxnKXtjb25zdCBwPU9iamVjdChyLmNyZWF0ZSkoKSxuPU9iamVjdChyLmNyZWF0ZSkoKTtsZXQgYT1SWzBdLGk9T1swXSxvPVsuNSooYVswXStpWzBdKSwuNSooYVsxXStpWzFdKV07T2JqZWN0KHIuc3ViKShuLGEsbyk7Zm9yKGxldCBUPTE7VDw9ZztUKyspe2NvbnN0IEE9LTEqTWF0aC5QSSpUL2c7T2JqZWN0KHIucm90YXRlKShwLG4sWzAsMF0sQSksT2JqZWN0KHIuYWRkKShzLG8scCksUi51bnNoaWZ0KE9iamVjdChyLmNsb25lKShzKSl9YT1PW08ubGVuZ3RoLTFdLGk9UltSLmxlbmd0aC0xXSxvPVsuNSooYVswXStpWzBdKSwuNSooYVsxXStpWzFdKV0sT2JqZWN0KHIuc3ViKShuLGEsbyk7Zm9yKGxldCBUPTE7VDw9ZztUKyspe2NvbnN0IEE9LTEqTWF0aC5QSSpUL2c7T2JqZWN0KHIucm90YXRlKShwLG4sWzAsMF0sQSksT2JqZWN0KHIuYWRkKShzLG8scCksTy5wdXNoKE9iamVjdChyLmNsb25lKShzKSl9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiaXNVbml0VHJhbnNmb3JtIixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIocyl7cmV0dXJuIHNbMF09PT0xJiZzWzFdPT09MCYmc1syXT09PTAmJnNbM109PT0xJiZzWzRdPT09MCYmc1s1XT09PTB9fSxmdW5jdGlvbihoLGUsdCl7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO3ZhciByPXQoNjEpLHM9dCg2Mik7aC5leHBvcnRzPWZ1bmN0aW9uKG0seSl7aWYoeT15fHx7fSxtPW0uZmlsdGVyKGZ1bmN0aW9uKGcpe3JldHVybiBnLmxlbmd0aD4yfSksbS5sZW5ndGg9PT0wKXJldHVybntwb3NpdGlvbnM6W10sY2VsbHM6W119O3R5cGVvZiB5LnZlcnRleFNpemUhPSJudW1iZXIiJiYoeS52ZXJ0ZXhTaXplPW1bMF1bMF0ubGVuZ3RoKSxtPW0ubWFwKGZ1bmN0aW9uKGcpe3JldHVybiBnLnJlZHVjZShmdW5jdGlvbihwLG4pe3JldHVybiBwLmNvbmNhdChuKX0pfSk7Y29uc3QgYz15LnJ1bGU9PT0iZXZlbm9kZCI/ci5XSU5ESU5HX09ERDpyLldJTkRJTkdfTk9OWkVSTztmb3IodmFyIGw9ci50ZXNzZWxhdGUocyh7Y29udG91cnM6bSx3aW5kaW5nUnVsZTpjLGVsZW1lbnRUeXBlOnIuUE9MWUdPTlMscG9seVNpemU6Myx2ZXJ0ZXhTaXplOjJ9LHkpKSx1PVtdLE09MDtNPGwudmVydGljZXMubGVuZ3RoO00rPXkudmVydGV4U2l6ZSl7dmFyIGY9bC52ZXJ0aWNlcy5zbGljZShNLE0reS52ZXJ0ZXhTaXplKTt1LnB1c2goZil9dmFyIHY9W107Zm9yKE09MDtNPGwuZWxlbWVudHMubGVuZ3RoO00rPTMpe3ZhciB4PWwuZWxlbWVudHNbTV0sUj1sLmVsZW1lbnRzW00rMV0sTz1sLmVsZW1lbnRzW00rMl07di5wdXNoKFt4LFIsT10pfXJldHVybntwb3NpdGlvbnM6dSxjZWxsczp2fX19LGZ1bmN0aW9uKGgsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIHI9e30scz17fTtoLmV4cG9ydHM9cixyLldJTkRJTkdfT0REPTAsci5XSU5ESU5HX05PTlpFUk89MSxyLldJTkRJTkdfUE9TSVRJVkU9MixyLldJTkRJTkdfTkVHQVRJVkU9MyxyLldJTkRJTkdfQUJTX0dFUV9UV089NCxyLlBPTFlHT05TPTAsci5DT05ORUNURURfUE9MWUdPTlM9MSxyLkJPVU5EQVJZX0NPTlRPVVJTPTIsci50ZXNzZWxhdGU9ZnVuY3Rpb24obil7Zm9yKHZhciBhPW4uZGVidWd8fCExLGk9bmV3IHAsbz0wO288bi5jb250b3Vycy5sZW5ndGg7bysrKWkuYWRkQ29udG91cihuLnZlcnRleFNpemV8fDIsbi5jb250b3Vyc1tvXSk7cmV0dXJuIGkudGVzc2VsYXRlKG4ud2luZGluZ1J1bGV8fHIuV0lORElOR19PREQsbi5lbGVtZW50VHlwZXx8ci5QT0xZR09OUyxuLnBvbHlTaXplfHwzLG4udmVydGV4U2l6ZXx8MixuLm5vcm1hbHx8WzAsMCwxXSkse3ZlcnRpY2VzOmkudmVydGljZXMsdmVydGV4SW5kaWNlczppLnZlcnRleEluZGljZXMsdmVydGV4Q291bnQ6aS52ZXJ0ZXhDb3VudCxlbGVtZW50czppLmVsZW1lbnRzLGVsZW1lbnRDb3VudDppLmVsZW1lbnRDb3VudCxtZXNoOmE/aS5tZXNoOnZvaWQgMH19O3ZhciBtPWZ1bmN0aW9uKG4pe2lmKCFuKXRocm93IkFzc2VydGlvbiBGYWlsZWQhIn07ZnVuY3Rpb24geSgpe3RoaXMubmV4dD1udWxsLHRoaXMucHJldj1udWxsLHRoaXMuYW5FZGdlPW51bGwsdGhpcy5jb29yZHM9WzAsMCwwXSx0aGlzLnM9MCx0aGlzLnQ9MCx0aGlzLnBxSGFuZGxlPTAsdGhpcy5uPTAsdGhpcy5pZHg9MH1mdW5jdGlvbiBjKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLnRyYWlsPW51bGwsdGhpcy5uPTAsdGhpcy5tYXJrZWQ9ITEsdGhpcy5pbnNpZGU9ITF9ZnVuY3Rpb24gbChuKXt0aGlzLm5leHQ9bnVsbCx0aGlzLlN5bT1udWxsLHRoaXMuT25leHQ9bnVsbCx0aGlzLkxuZXh0PW51bGwsdGhpcy5Pcmc9bnVsbCx0aGlzLkxmYWNlPW51bGwsdGhpcy5hY3RpdmVSZWdpb249bnVsbCx0aGlzLndpbmRpbmc9MCx0aGlzLnNpZGU9bn1sLnByb3RvdHlwZT17Z2V0IFJmYWNlKCl7cmV0dXJuIHRoaXMuU3ltLkxmYWNlfSxzZXQgUmZhY2Uobil7dGhpcy5TeW0uTGZhY2U9bn0sZ2V0IERzdCgpe3JldHVybiB0aGlzLlN5bS5Pcmd9LHNldCBEc3Qobil7dGhpcy5TeW0uT3JnPW59LGdldCBPcHJldigpe3JldHVybiB0aGlzLlN5bS5MbmV4dH0sc2V0IE9wcmV2KG4pe3RoaXMuU3ltLkxuZXh0PW59LGdldCBMcHJldigpe3JldHVybiB0aGlzLk9uZXh0LlN5bX0sc2V0IExwcmV2KG4pe3RoaXMuT25leHQuU3ltPW59LGdldCBEcHJldigpe3JldHVybiB0aGlzLkxuZXh0LlN5bX0sc2V0IERwcmV2KG4pe3RoaXMuTG5leHQuU3ltPW59LGdldCBScHJldigpe3JldHVybiB0aGlzLlN5bS5PbmV4dH0sc2V0IFJwcmV2KG4pe3RoaXMuU3ltLk9uZXh0PW59LGdldCBEbmV4dCgpe3JldHVybiB0aGlzLlN5bS5PbmV4dC5TeW19LHNldCBEbmV4dChuKXt0aGlzLlN5bS5PbmV4dC5TeW09bn0sZ2V0IFJuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0LlN5bX0sc2V0IFJuZXh0KG4pe3RoaXMuU3ltLkxuZXh0LlN5bT1ufX07ZnVuY3Rpb24gdSgpe3ZhciBuPW5ldyB5LGE9bmV3IGMsaT1uZXcgbCgwKSxvPW5ldyBsKDEpO24ubmV4dD1uLnByZXY9bixuLmFuRWRnZT1udWxsLGEubmV4dD1hLnByZXY9YSxhLmFuRWRnZT1udWxsLGEudHJhaWw9bnVsbCxhLm1hcmtlZD0hMSxhLmluc2lkZT0hMSxpLm5leHQ9aSxpLlN5bT1vLGkuT25leHQ9bnVsbCxpLkxuZXh0PW51bGwsaS5Pcmc9bnVsbCxpLkxmYWNlPW51bGwsaS53aW5kaW5nPTAsaS5hY3RpdmVSZWdpb249bnVsbCxvLm5leHQ9byxvLlN5bT1pLG8uT25leHQ9bnVsbCxvLkxuZXh0PW51bGwsby5Pcmc9bnVsbCxvLkxmYWNlPW51bGwsby53aW5kaW5nPTAsby5hY3RpdmVSZWdpb249bnVsbCx0aGlzLnZIZWFkPW4sdGhpcy5mSGVhZD1hLHRoaXMuZUhlYWQ9aSx0aGlzLmVIZWFkU3ltPW99dS5wcm90b3R5cGU9e21ha2VFZGdlXzpmdW5jdGlvbihuKXt2YXIgYT1uZXcgbCgwKSxpPW5ldyBsKDEpO24uU3ltLnNpZGU8bi5zaWRlJiYobj1uLlN5bSk7dmFyIG89bi5TeW0ubmV4dDtyZXR1cm4gaS5uZXh0PW8sby5TeW0ubmV4dD1hLGEubmV4dD1uLG4uU3ltLm5leHQ9aSxhLlN5bT1pLGEuT25leHQ9YSxhLkxuZXh0PWksYS5Pcmc9bnVsbCxhLkxmYWNlPW51bGwsYS53aW5kaW5nPTAsYS5hY3RpdmVSZWdpb249bnVsbCxpLlN5bT1hLGkuT25leHQ9aSxpLkxuZXh0PWEsaS5Pcmc9bnVsbCxpLkxmYWNlPW51bGwsaS53aW5kaW5nPTAsaS5hY3RpdmVSZWdpb249bnVsbCxhfSxzcGxpY2VfOmZ1bmN0aW9uKG4sYSl7dmFyIGk9bi5PbmV4dCxvPWEuT25leHQ7aS5TeW0uTG5leHQ9YSxvLlN5bS5MbmV4dD1uLG4uT25leHQ9byxhLk9uZXh0PWl9LG1ha2VWZXJ0ZXhfOmZ1bmN0aW9uKG4sYSxpKXt2YXIgbz1uO20obyE9PW51bGwpO3ZhciBUPWkucHJldjtvLnByZXY9VCxULm5leHQ9byxvLm5leHQ9aSxpLnByZXY9byxvLmFuRWRnZT1hO3ZhciBBPWE7ZG8gQS5Pcmc9byxBPUEuT25leHQ7d2hpbGUoQSE9PWEpfSxtYWtlRmFjZV86ZnVuY3Rpb24obixhLGkpe3ZhciBvPW47bShvIT09bnVsbCk7dmFyIFQ9aS5wcmV2O28ucHJldj1ULFQubmV4dD1vLG8ubmV4dD1pLGkucHJldj1vLG8uYW5FZGdlPWEsby50cmFpbD1udWxsLG8ubWFya2VkPSExLG8uaW5zaWRlPWkuaW5zaWRlO3ZhciBBPWE7ZG8gQS5MZmFjZT1vLEE9QS5MbmV4dDt3aGlsZShBIT09YSl9LGtpbGxFZGdlXzpmdW5jdGlvbihuKXtuLlN5bS5zaWRlPG4uc2lkZSYmKG49bi5TeW0pO3ZhciBhPW4ubmV4dCxpPW4uU3ltLm5leHQ7YS5TeW0ubmV4dD1pLGkuU3ltLm5leHQ9YX0sa2lsbFZlcnRleF86ZnVuY3Rpb24obixhKXt2YXIgaT1uLmFuRWRnZSxvPWk7ZG8gby5Pcmc9YSxvPW8uT25leHQ7d2hpbGUobyE9PWkpO3ZhciBUPW4ucHJldixBPW4ubmV4dDtBLnByZXY9VCxULm5leHQ9QX0sa2lsbEZhY2VfOmZ1bmN0aW9uKG4sYSl7dmFyIGk9bi5hbkVkZ2Usbz1pO2RvIG8uTGZhY2U9YSxvPW8uTG5leHQ7d2hpbGUobyE9PWkpO3ZhciBUPW4ucHJldixBPW4ubmV4dDtBLnByZXY9VCxULm5leHQ9QX0sbWFrZUVkZ2U6ZnVuY3Rpb24oKXt2YXIgbj1uZXcgeSxhPW5ldyB5LGk9bmV3IGMsbz10aGlzLm1ha2VFZGdlXyh0aGlzLmVIZWFkKTtyZXR1cm4gdGhpcy5tYWtlVmVydGV4XyhuLG8sdGhpcy52SGVhZCksdGhpcy5tYWtlVmVydGV4XyhhLG8uU3ltLHRoaXMudkhlYWQpLHRoaXMubWFrZUZhY2VfKGksbyx0aGlzLmZIZWFkKSxvfSxzcGxpY2U6ZnVuY3Rpb24obixhKXt2YXIgaT0hMSxvPSExO2lmKG4hPT1hKXtpZihhLk9yZyE9PW4uT3JnJiYobz0hMCx0aGlzLmtpbGxWZXJ0ZXhfKGEuT3JnLG4uT3JnKSksYS5MZmFjZSE9PW4uTGZhY2UmJihpPSEwLHRoaXMua2lsbEZhY2VfKGEuTGZhY2Usbi5MZmFjZSkpLHRoaXMuc3BsaWNlXyhhLG4pLCFvKXt2YXIgVD1uZXcgeTt0aGlzLm1ha2VWZXJ0ZXhfKFQsYSxuLk9yZyksbi5PcmcuYW5FZGdlPW59aWYoIWkpe3ZhciBBPW5ldyBjO3RoaXMubWFrZUZhY2VfKEEsYSxuLkxmYWNlKSxuLkxmYWNlLmFuRWRnZT1ufX19LGRlbGV0ZTpmdW5jdGlvbihuKXt2YXIgYT1uLlN5bSxpPSExO2lmKG4uTGZhY2UhPT1uLlJmYWNlJiYoaT0hMCx0aGlzLmtpbGxGYWNlXyhuLkxmYWNlLG4uUmZhY2UpKSxuLk9uZXh0PT09bil0aGlzLmtpbGxWZXJ0ZXhfKG4uT3JnLG51bGwpO2Vsc2UgaWYobi5SZmFjZS5hbkVkZ2U9bi5PcHJldixuLk9yZy5hbkVkZ2U9bi5PbmV4dCx0aGlzLnNwbGljZV8obixuLk9wcmV2KSwhaSl7dmFyIG89bmV3IGM7dGhpcy5tYWtlRmFjZV8obyxuLG4uTGZhY2UpfWEuT25leHQ9PT1hPyh0aGlzLmtpbGxWZXJ0ZXhfKGEuT3JnLG51bGwpLHRoaXMua2lsbEZhY2VfKGEuTGZhY2UsbnVsbCkpOihuLkxmYWNlLmFuRWRnZT1hLk9wcmV2LGEuT3JnLmFuRWRnZT1hLk9uZXh0LHRoaXMuc3BsaWNlXyhhLGEuT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhuKX0sYWRkRWRnZVZlcnRleDpmdW5jdGlvbihuKXt2YXIgYT10aGlzLm1ha2VFZGdlXyhuKSxpPWEuU3ltO3RoaXMuc3BsaWNlXyhhLG4uTG5leHQpLGEuT3JnPW4uRHN0O3ZhciBvPW5ldyB5O3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKG8saSxhLk9yZyksYS5MZmFjZT1pLkxmYWNlPW4uTGZhY2UsYX0sc3BsaXRFZGdlOmZ1bmN0aW9uKG4sYSl7dmFyIGk9dGhpcy5hZGRFZGdlVmVydGV4KG4pLG89aS5TeW07cmV0dXJuIHRoaXMuc3BsaWNlXyhuLlN5bSxuLlN5bS5PcHJldiksdGhpcy5zcGxpY2VfKG4uU3ltLG8pLG4uRHN0PW8uT3JnLG8uRHN0LmFuRWRnZT1vLlN5bSxvLlJmYWNlPW4uUmZhY2Usby53aW5kaW5nPW4ud2luZGluZyxvLlN5bS53aW5kaW5nPW4uU3ltLndpbmRpbmcsb30sY29ubmVjdDpmdW5jdGlvbihuLGEpe3ZhciBpPSExLG89dGhpcy5tYWtlRWRnZV8obiksVD1vLlN5bTtpZihhLkxmYWNlIT09bi5MZmFjZSYmKGk9ITAsdGhpcy5raWxsRmFjZV8oYS5MZmFjZSxuLkxmYWNlKSksdGhpcy5zcGxpY2VfKG8sbi5MbmV4dCksdGhpcy5zcGxpY2VfKFQsYSksby5Pcmc9bi5Ec3QsVC5Pcmc9YS5Pcmcsby5MZmFjZT1ULkxmYWNlPW4uTGZhY2Usbi5MZmFjZS5hbkVkZ2U9VCwhaSl7dmFyIEE9bmV3IGM7dGhpcy5tYWtlRmFjZV8oQSxvLG4uTGZhY2UpfXJldHVybiBvfSx6YXBGYWNlOmZ1bmN0aW9uKG4pe3ZhciBhPW4uYW5FZGdlLGksbyxULEEsQztvPWEuTG5leHQ7ZG8gaT1vLG89aS5MbmV4dCxpLkxmYWNlPW51bGwsaS5SZmFjZT09PW51bGwmJihpLk9uZXh0PT09aT90aGlzLmtpbGxWZXJ0ZXhfKGkuT3JnLG51bGwpOihpLk9yZy5hbkVkZ2U9aS5PbmV4dCx0aGlzLnNwbGljZV8oaSxpLk9wcmV2KSksVD1pLlN5bSxULk9uZXh0PT09VD90aGlzLmtpbGxWZXJ0ZXhfKFQuT3JnLG51bGwpOihULk9yZy5hbkVkZ2U9VC5PbmV4dCx0aGlzLnNwbGljZV8oVCxULk9wcmV2KSksdGhpcy5raWxsRWRnZV8oaSkpO3doaWxlKGkhPWEpO0E9bi5wcmV2LEM9bi5uZXh0LEMucHJldj1BLEEubmV4dD1DfSxjb3VudEZhY2VWZXJ0c186ZnVuY3Rpb24obil7dmFyIGE9bi5hbkVkZ2UsaT0wO2RvIGkrKyxhPWEuTG5leHQ7d2hpbGUoYSE9PW4uYW5FZGdlKTtyZXR1cm4gaX0sbWVyZ2VDb252ZXhGYWNlczpmdW5jdGlvbihuKXt2YXIgYSxpLG8sVCxBLEMsSTtmb3IoYT10aGlzLmZIZWFkLm5leHQ7YSE9PXRoaXMuZkhlYWQ7YT1hLm5leHQpaWYoYS5pbnNpZGUpZm9yKGk9YS5hbkVkZ2UsQT1pLk9yZztvPWkuTG5leHQsVD1pLlN5bSxUJiZULkxmYWNlJiZULkxmYWNlLmluc2lkZSYmKEM9dGhpcy5jb3VudEZhY2VWZXJ0c18oYSksST10aGlzLmNvdW50RmFjZVZlcnRzXyhULkxmYWNlKSxDK0ktMjw9biYmcy52ZXJ0Q0NXKGkuTHByZXYuT3JnLGkuT3JnLFQuTG5leHQuTG5leHQuT3JnKSYmcy52ZXJ0Q0NXKFQuTHByZXYuT3JnLFQuT3JnLGkuTG5leHQuTG5leHQuT3JnKSYmKG89VC5MbmV4dCx0aGlzLmRlbGV0ZShUKSxpPW51bGwsVD1udWxsKSksIShpJiZpLkxuZXh0Lk9yZz09PUEpOylpPW87cmV0dXJuITB9LGNoZWNrOmZ1bmN0aW9uKCl7dmFyIG49dGhpcy5mSGVhZCxhPXRoaXMudkhlYWQsaT10aGlzLmVIZWFkLG8sVCxBLEMsSSxQO2ZvcihUPW4sVD1uOyhvPVQubmV4dCkhPT1uO1Q9byl7bShvLnByZXY9PT1UKSxJPW8uYW5FZGdlO2RvIG0oSS5TeW0hPT1JKSxtKEkuU3ltLlN5bT09PUkpLG0oSS5MbmV4dC5PbmV4dC5TeW09PT1JKSxtKEkuT25leHQuU3ltLkxuZXh0PT09SSksbShJLkxmYWNlPT09byksST1JLkxuZXh0O3doaWxlKEkhPT1vLmFuRWRnZSl9Zm9yKG0oby5wcmV2PT09VCYmby5hbkVkZ2U9PT1udWxsKSxDPWEsQz1hOyhBPUMubmV4dCkhPT1hO0M9QSl7bShBLnByZXY9PT1DKSxJPUEuYW5FZGdlO2RvIG0oSS5TeW0hPT1JKSxtKEkuU3ltLlN5bT09PUkpLG0oSS5MbmV4dC5PbmV4dC5TeW09PT1JKSxtKEkuT25leHQuU3ltLkxuZXh0PT09SSksbShJLk9yZz09PUEpLEk9SS5PbmV4dDt3aGlsZShJIT09QS5hbkVkZ2UpfWZvcihtKEEucHJldj09PUMmJkEuYW5FZGdlPT09bnVsbCksUD1pLFA9aTsoST1QLm5leHQpIT09aTtQPUkpbShJLlN5bS5uZXh0PT09UC5TeW0pLG0oSS5TeW0hPT1JKSxtKEkuU3ltLlN5bT09PUkpLG0oSS5PcmchPT1udWxsKSxtKEkuRHN0IT09bnVsbCksbShJLkxuZXh0Lk9uZXh0LlN5bT09PUkpLG0oSS5PbmV4dC5TeW0uTG5leHQ9PT1JKTttKEkuU3ltLm5leHQ9PT1QLlN5bSYmSS5TeW09PT10aGlzLmVIZWFkU3ltJiZJLlN5bS5TeW09PT1JJiZJLk9yZz09PW51bGwmJkkuRHN0PT09bnVsbCYmSS5MZmFjZT09PW51bGwmJkkuUmZhY2U9PT1udWxsKX19LHMudmVydEVxPWZ1bmN0aW9uKG4sYSl7cmV0dXJuIG4ucz09PWEucyYmbi50PT09YS50fSxzLnZlcnRMZXE9ZnVuY3Rpb24obixhKXtyZXR1cm4gbi5zPGEuc3x8bi5zPT09YS5zJiZuLnQ8PWEudH0scy50cmFuc0xlcT1mdW5jdGlvbihuLGEpe3JldHVybiBuLnQ8YS50fHxuLnQ9PT1hLnQmJm4uczw9YS5zfSxzLmVkZ2VHb2VzTGVmdD1mdW5jdGlvbihuKXtyZXR1cm4gcy52ZXJ0TGVxKG4uRHN0LG4uT3JnKX0scy5lZGdlR29lc1JpZ2h0PWZ1bmN0aW9uKG4pe3JldHVybiBzLnZlcnRMZXEobi5Pcmcsbi5Ec3QpfSxzLnZlcnRMMWRpc3Q9ZnVuY3Rpb24obixhKXtyZXR1cm4gTWF0aC5hYnMobi5zLWEucykrTWF0aC5hYnMobi50LWEudCl9LHMuZWRnZUV2YWw9ZnVuY3Rpb24obixhLGkpe20ocy52ZXJ0TGVxKG4sYSkmJnMudmVydExlcShhLGkpKTt2YXIgbz1hLnMtbi5zLFQ9aS5zLWEucztyZXR1cm4gbytUPjA/bzxUP2EudC1uLnQrKG4udC1pLnQpKihvLyhvK1QpKTphLnQtaS50KyhpLnQtbi50KSooVC8obytUKSk6MH0scy5lZGdlU2lnbj1mdW5jdGlvbihuLGEsaSl7bShzLnZlcnRMZXEobixhKSYmcy52ZXJ0TGVxKGEsaSkpO3ZhciBvPWEucy1uLnMsVD1pLnMtYS5zO3JldHVybiBvK1Q+MD8oYS50LWkudCkqbysoYS50LW4udCkqVDowfSxzLnRyYW5zRXZhbD1mdW5jdGlvbihuLGEsaSl7bShzLnRyYW5zTGVxKG4sYSkmJnMudHJhbnNMZXEoYSxpKSk7dmFyIG89YS50LW4udCxUPWkudC1hLnQ7cmV0dXJuIG8rVD4wP288VD9hLnMtbi5zKyhuLnMtaS5zKSooby8obytUKSk6YS5zLWkucysoaS5zLW4ucykqKFQvKG8rVCkpOjB9LHMudHJhbnNTaWduPWZ1bmN0aW9uKG4sYSxpKXttKHMudHJhbnNMZXEobixhKSYmcy50cmFuc0xlcShhLGkpKTt2YXIgbz1hLnQtbi50LFQ9aS50LWEudDtyZXR1cm4gbytUPjA/KGEucy1pLnMpKm8rKGEucy1uLnMpKlQ6MH0scy52ZXJ0Q0NXPWZ1bmN0aW9uKG4sYSxpKXtyZXR1cm4gbi5zKihhLnQtaS50KSthLnMqKGkudC1uLnQpK2kucyoobi50LWEudCk+PTB9LHMuaW50ZXJwb2xhdGU9ZnVuY3Rpb24obixhLGksbyl7cmV0dXJuIG49bjwwPzA6bixpPWk8MD8wOmksbjw9aT9pPT09MD8oYStvKS8yOmErKG8tYSkqKG4vKG4raSkpOm8rKGEtbykqKGkvKG4raSkpfSxzLmludGVyc2VjdD1mdW5jdGlvbihuLGEsaSxvLFQpe3ZhciBBLEMsSTtzLnZlcnRMZXEobixhKXx8KEk9bixuPWEsYT1JKSxzLnZlcnRMZXEoaSxvKXx8KEk9aSxpPW8sbz1JKSxzLnZlcnRMZXEobixpKXx8KEk9bixuPWksaT1JLEk9YSxhPW8sbz1JKSxzLnZlcnRMZXEoaSxhKT9zLnZlcnRMZXEoYSxvKT8oQT1zLmVkZ2VFdmFsKG4saSxhKSxDPXMuZWRnZUV2YWwoaSxhLG8pLEErQzwwJiYoQT0tQSxDPS1DKSxULnM9cy5pbnRlcnBvbGF0ZShBLGkucyxDLGEucykpOihBPXMuZWRnZVNpZ24obixpLGEpLEM9LXMuZWRnZVNpZ24obixvLGEpLEErQzwwJiYoQT0tQSxDPS1DKSxULnM9cy5pbnRlcnBvbGF0ZShBLGkucyxDLG8ucykpOlQucz0oaS5zK2EucykvMixzLnRyYW5zTGVxKG4sYSl8fChJPW4sbj1hLGE9SSkscy50cmFuc0xlcShpLG8pfHwoST1pLGk9byxvPUkpLHMudHJhbnNMZXEobixpKXx8KEk9bixuPWksaT1JLEk9YSxhPW8sbz1JKSxzLnRyYW5zTGVxKGksYSk/cy50cmFuc0xlcShhLG8pPyhBPXMudHJhbnNFdmFsKG4saSxhKSxDPXMudHJhbnNFdmFsKGksYSxvKSxBK0M8MCYmKEE9LUEsQz0tQyksVC50PXMuaW50ZXJwb2xhdGUoQSxpLnQsQyxhLnQpKTooQT1zLnRyYW5zU2lnbihuLGksYSksQz0tcy50cmFuc1NpZ24obixvLGEpLEErQzwwJiYoQT0tQSxDPS1DKSxULnQ9cy5pbnRlcnBvbGF0ZShBLGkudCxDLG8udCkpOlQudD0oaS50K2EudCkvMn07ZnVuY3Rpb24gTSgpe3RoaXMua2V5PW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGx9ZnVuY3Rpb24gZihuLGEpe3RoaXMuaGVhZD1uZXcgTSx0aGlzLmhlYWQubmV4dD10aGlzLmhlYWQsdGhpcy5oZWFkLnByZXY9dGhpcy5oZWFkLHRoaXMuZnJhbWU9bix0aGlzLmxlcT1hfWYucHJvdG90eXBlPXttaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkLm5leHR9LG1heDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQucHJldn0saW5zZXJ0OmZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsbil9LHNlYXJjaDpmdW5jdGlvbihuKXt2YXIgYT10aGlzLmhlYWQ7ZG8gYT1hLm5leHQ7d2hpbGUoYS5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxuLGEua2V5KSk7cmV0dXJuIGF9LGluc2VydEJlZm9yZTpmdW5jdGlvbihuLGEpe2RvIG49bi5wcmV2O3doaWxlKG4ua2V5IT09bnVsbCYmIXRoaXMubGVxKHRoaXMuZnJhbWUsbi5rZXksYSkpO3ZhciBpPW5ldyBNO3JldHVybiBpLmtleT1hLGkubmV4dD1uLm5leHQsbi5uZXh0LnByZXY9aSxpLnByZXY9bixuLm5leHQ9aSxpfSxkZWxldGU6ZnVuY3Rpb24obil7bi5uZXh0LnByZXY9bi5wcmV2LG4ucHJldi5uZXh0PW4ubmV4dH19O2Z1bmN0aW9uIHYoKXt0aGlzLmhhbmRsZT1udWxsfWZ1bmN0aW9uIHgoKXt0aGlzLmtleT1udWxsLHRoaXMubm9kZT1udWxsfWZ1bmN0aW9uIFIobixhKXt0aGlzLnNpemU9MCx0aGlzLm1heD1uLHRoaXMubm9kZXM9W10sdGhpcy5ub2Rlcy5sZW5ndGg9bisxO3ZhciBpO2ZvcihpPTA7aTx0aGlzLm5vZGVzLmxlbmd0aDtpKyspdGhpcy5ub2Rlc1tpXT1uZXcgdjtmb3IodGhpcy5oYW5kbGVzPVtdLHRoaXMuaGFuZGxlcy5sZW5ndGg9bisxLGk9MDtpPHRoaXMuaGFuZGxlcy5sZW5ndGg7aSsrKXRoaXMuaGFuZGxlc1tpXT1uZXcgeDt0aGlzLmluaXRpYWxpemVkPSExLHRoaXMuZnJlZUxpc3Q9MCx0aGlzLmxlcT1hLHRoaXMubm9kZXNbMV0uaGFuZGxlPTEsdGhpcy5oYW5kbGVzWzFdLmtleT1udWxsfVIucHJvdG90eXBlPXtmbG9hdERvd25fOmZ1bmN0aW9uKG4pe3ZhciBhPXRoaXMubm9kZXMsaT10aGlzLmhhbmRsZXMsbyxULEE7Zm9yKG89YVtuXS5oYW5kbGU7Oyl7aWYoQT1uPDwxLEE8dGhpcy5zaXplJiZ0aGlzLmxlcShpW2FbQSsxXS5oYW5kbGVdLmtleSxpW2FbQV0uaGFuZGxlXS5rZXkpJiYrK0EsbShBPD10aGlzLm1heCksVD1hW0FdLmhhbmRsZSxBPnRoaXMuc2l6ZXx8dGhpcy5sZXEoaVtvXS5rZXksaVtUXS5rZXkpKXthW25dLmhhbmRsZT1vLGlbb10ubm9kZT1uO2JyZWFrfWFbbl0uaGFuZGxlPVQsaVtUXS5ub2RlPW4sbj1BfX0sZmxvYXRVcF86ZnVuY3Rpb24obil7dmFyIGE9dGhpcy5ub2RlcyxpPXRoaXMuaGFuZGxlcyxvLFQsQTtmb3Iobz1hW25dLmhhbmRsZTs7KXtpZihBPW4+PjEsVD1hW0FdLmhhbmRsZSxBPT09MHx8dGhpcy5sZXEoaVtUXS5rZXksaVtvXS5rZXkpKXthW25dLmhhbmRsZT1vLGlbb10ubm9kZT1uO2JyZWFrfWFbbl0uaGFuZGxlPVQsaVtUXS5ub2RlPW4sbj1BfX0saW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgbj10aGlzLnNpemU7bj49MTstLW4pdGhpcy5mbG9hdERvd25fKG4pO3RoaXMuaW5pdGlhbGl6ZWQ9ITB9LG1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhbmRsZXNbdGhpcy5ub2Rlc1sxXS5oYW5kbGVdLmtleX0saW5zZXJ0OmZ1bmN0aW9uKG4pe3ZhciBhLGk7aWYoYT0rK3RoaXMuc2l6ZSxhKjI+dGhpcy5tYXgpe3RoaXMubWF4Kj0yO3ZhciBvLFQ7Zm9yKFQ9dGhpcy5ub2Rlcy5sZW5ndGgsdGhpcy5ub2Rlcy5sZW5ndGg9dGhpcy5tYXgrMSxvPVQ7bzx0aGlzLm5vZGVzLmxlbmd0aDtvKyspdGhpcy5ub2Rlc1tvXT1uZXcgdjtmb3IoVD10aGlzLmhhbmRsZXMubGVuZ3RoLHRoaXMuaGFuZGxlcy5sZW5ndGg9dGhpcy5tYXgrMSxvPVQ7bzx0aGlzLmhhbmRsZXMubGVuZ3RoO28rKyl0aGlzLmhhbmRsZXNbb109bmV3IHh9cmV0dXJuIHRoaXMuZnJlZUxpc3Q9PT0wP2k9YTooaT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9dGhpcy5oYW5kbGVzW2ldLm5vZGUpLHRoaXMubm9kZXNbYV0uaGFuZGxlPWksdGhpcy5oYW5kbGVzW2ldLm5vZGU9YSx0aGlzLmhhbmRsZXNbaV0ua2V5PW4sdGhpcy5pbml0aWFsaXplZCYmdGhpcy5mbG9hdFVwXyhhKSxpfSxleHRyYWN0TWluOmZ1bmN0aW9uKCl7dmFyIG49dGhpcy5ub2RlcyxhPXRoaXMuaGFuZGxlcyxpPW5bMV0uaGFuZGxlLG89YVtpXS5rZXk7cmV0dXJuIHRoaXMuc2l6ZT4wJiYoblsxXS5oYW5kbGU9blt0aGlzLnNpemVdLmhhbmRsZSxhW25bMV0uaGFuZGxlXS5ub2RlPTEsYVtpXS5rZXk9bnVsbCxhW2ldLm5vZGU9dGhpcy5mcmVlTGlzdCx0aGlzLmZyZWVMaXN0PWksLS10aGlzLnNpemUsdGhpcy5zaXplPjAmJnRoaXMuZmxvYXREb3duXygxKSksb30sZGVsZXRlOmZ1bmN0aW9uKG4pe3ZhciBhPXRoaXMubm9kZXMsaT10aGlzLmhhbmRsZXMsbzttKG4+PTEmJm48PXRoaXMubWF4JiZpW25dLmtleSE9PW51bGwpLG89aVtuXS5ub2RlLGFbb10uaGFuZGxlPWFbdGhpcy5zaXplXS5oYW5kbGUsaVthW29dLmhhbmRsZV0ubm9kZT1vLC0tdGhpcy5zaXplLG88PXRoaXMuc2l6ZSYmKG88PTF8fHRoaXMubGVxKGlbYVtvPj4xXS5oYW5kbGVdLmtleSxpW2Fbb10uaGFuZGxlXS5rZXkpP3RoaXMuZmxvYXREb3duXyhvKTp0aGlzLmZsb2F0VXBfKG8pKSxpW25dLmtleT1udWxsLGlbbl0ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9bn19O2Z1bmN0aW9uIE8oKXt0aGlzLmVVcD1udWxsLHRoaXMubm9kZVVwPW51bGwsdGhpcy53aW5kaW5nTnVtYmVyPTAsdGhpcy5pbnNpZGU9ITEsdGhpcy5zZW50aW5lbD0hMSx0aGlzLmRpcnR5PSExLHRoaXMuZml4VXBwZXJFZGdlPSExfXZhciBnPXt9O2cucmVnaW9uQmVsb3c9ZnVuY3Rpb24obil7cmV0dXJuIG4ubm9kZVVwLnByZXYua2V5fSxnLnJlZ2lvbkFib3ZlPWZ1bmN0aW9uKG4pe3JldHVybiBuLm5vZGVVcC5uZXh0LmtleX0sZy5kZWJ1Z0V2ZW50PWZ1bmN0aW9uKG4pe30sZy5hZGRXaW5kaW5nPWZ1bmN0aW9uKG4sYSl7bi53aW5kaW5nKz1hLndpbmRpbmcsbi5TeW0ud2luZGluZys9YS5TeW0ud2luZGluZ30sZy5lZGdlTGVxPWZ1bmN0aW9uKG4sYSxpKXt2YXIgbz1uLmV2ZW50LEMsSSxUPWEuZVVwLEE9aS5lVXA7aWYoVC5Ec3Q9PT1vKXJldHVybiBBLkRzdD09PW8/cy52ZXJ0TGVxKFQuT3JnLEEuT3JnKT9zLmVkZ2VTaWduKEEuRHN0LFQuT3JnLEEuT3JnKTw9MDpzLmVkZ2VTaWduKFQuRHN0LEEuT3JnLFQuT3JnKT49MDpzLmVkZ2VTaWduKEEuRHN0LG8sQS5PcmcpPD0wO2lmKEEuRHN0PT09bylyZXR1cm4gcy5lZGdlU2lnbihULkRzdCxvLFQuT3JnKT49MDt2YXIgQz1zLmVkZ2VFdmFsKFQuRHN0LG8sVC5PcmcpLEk9cy5lZGdlRXZhbChBLkRzdCxvLEEuT3JnKTtyZXR1cm4gQz49SX0sZy5kZWxldGVSZWdpb249ZnVuY3Rpb24obixhKXthLmZpeFVwcGVyRWRnZSYmbShhLmVVcC53aW5kaW5nPT09MCksYS5lVXAuYWN0aXZlUmVnaW9uPW51bGwsbi5kaWN0LmRlbGV0ZShhLm5vZGVVcCl9LGcuZml4VXBwZXJFZGdlPWZ1bmN0aW9uKG4sYSxpKXttKGEuZml4VXBwZXJFZGdlKSxuLm1lc2guZGVsZXRlKGEuZVVwKSxhLmZpeFVwcGVyRWRnZT0hMSxhLmVVcD1pLGkuYWN0aXZlUmVnaW9uPWF9LGcudG9wTGVmdFJlZ2lvbj1mdW5jdGlvbihuLGEpe3ZhciBpPWEuZVVwLk9yZyxvO2RvIGE9Zy5yZWdpb25BYm92ZShhKTt3aGlsZShhLmVVcC5Pcmc9PT1pKTtpZihhLmZpeFVwcGVyRWRnZSl7aWYobz1uLm1lc2guY29ubmVjdChnLnJlZ2lvbkJlbG93KGEpLmVVcC5TeW0sYS5lVXAuTG5leHQpLG89PT1udWxsKXJldHVybiBudWxsO2cuZml4VXBwZXJFZGdlKG4sYSxvKSxhPWcucmVnaW9uQWJvdmUoYSl9cmV0dXJuIGF9LGcudG9wUmlnaHRSZWdpb249ZnVuY3Rpb24obil7dmFyIGE9bi5lVXAuRHN0O2RvIG49Zy5yZWdpb25BYm92ZShuKTt3aGlsZShuLmVVcC5Ec3Q9PT1hKTtyZXR1cm4gbn0sZy5hZGRSZWdpb25CZWxvdz1mdW5jdGlvbihuLGEsaSl7dmFyIG89bmV3IE87cmV0dXJuIG8uZVVwPWksby5ub2RlVXA9bi5kaWN0Lmluc2VydEJlZm9yZShhLm5vZGVVcCxvKSxvLmZpeFVwcGVyRWRnZT0hMSxvLnNlbnRpbmVsPSExLG8uZGlydHk9ITEsaS5hY3RpdmVSZWdpb249byxvfSxnLmlzV2luZGluZ0luc2lkZT1mdW5jdGlvbihuLGEpe3N3aXRjaChuLndpbmRpbmdSdWxlKXtjYXNlIHIuV0lORElOR19PREQ6cmV0dXJuKGEmMSkhPT0wO2Nhc2Ugci5XSU5ESU5HX05PTlpFUk86cmV0dXJuIGEhPT0wO2Nhc2Ugci5XSU5ESU5HX1BPU0lUSVZFOnJldHVybiBhPjA7Y2FzZSByLldJTkRJTkdfTkVHQVRJVkU6cmV0dXJuIGE8MDtjYXNlIHIuV0lORElOR19BQlNfR0VRX1RXTzpyZXR1cm4gYT49Mnx8YTw9LTJ9cmV0dXJuIG0oITEpLCExfSxnLmNvbXB1dGVXaW5kaW5nPWZ1bmN0aW9uKG4sYSl7YS53aW5kaW5nTnVtYmVyPWcucmVnaW9uQWJvdmUoYSkud2luZGluZ051bWJlcithLmVVcC53aW5kaW5nLGEuaW5zaWRlPWcuaXNXaW5kaW5nSW5zaWRlKG4sYS53aW5kaW5nTnVtYmVyKX0sZy5maW5pc2hSZWdpb249ZnVuY3Rpb24obixhKXt2YXIgaT1hLmVVcCxvPWkuTGZhY2U7by5pbnNpZGU9YS5pbnNpZGUsby5hbkVkZ2U9aSxnLmRlbGV0ZVJlZ2lvbihuLGEpfSxnLmZpbmlzaExlZnRSZWdpb25zPWZ1bmN0aW9uKG4sYSxpKXtmb3IodmFyIG8sQyxUPW51bGwsQT1hLEM9YS5lVXA7QSE9PWk7KXtpZihBLmZpeFVwcGVyRWRnZT0hMSxUPWcucmVnaW9uQmVsb3coQSksbz1ULmVVcCxvLk9yZyE9Qy5Pcmcpe2lmKCFULmZpeFVwcGVyRWRnZSl7Zy5maW5pc2hSZWdpb24obixBKTticmVha31vPW4ubWVzaC5jb25uZWN0KEMuTHByZXYsby5TeW0pLGcuZml4VXBwZXJFZGdlKG4sVCxvKX1DLk9uZXh0IT09byYmKG4ubWVzaC5zcGxpY2Uoby5PcHJldixvKSxuLm1lc2guc3BsaWNlKEMsbykpLGcuZmluaXNoUmVnaW9uKG4sQSksQz1ULmVVcCxBPVR9cmV0dXJuIEN9LGcuYWRkUmlnaHRFZGdlcz1mdW5jdGlvbihuLGEsaSxvLFQsQSl7dmFyIEMsSSxQLEwsRD0hMDtQPWk7ZG8gbShzLnZlcnRMZXEoUC5PcmcsUC5Ec3QpKSxnLmFkZFJlZ2lvbkJlbG93KG4sYSxQLlN5bSksUD1QLk9uZXh0O3doaWxlKFAhPT1vKTtmb3IoVD09PW51bGwmJihUPWcucmVnaW9uQmVsb3coYSkuZVVwLlJwcmV2KSxJPWEsTD1UO0M9Zy5yZWdpb25CZWxvdyhJKSxQPUMuZVVwLlN5bSxQLk9yZz09PUwuT3JnOylQLk9uZXh0IT09TCYmKG4ubWVzaC5zcGxpY2UoUC5PcHJldixQKSxuLm1lc2guc3BsaWNlKEwuT3ByZXYsUCkpLEMud2luZGluZ051bWJlcj1JLndpbmRpbmdOdW1iZXItUC53aW5kaW5nLEMuaW5zaWRlPWcuaXNXaW5kaW5nSW5zaWRlKG4sQy53aW5kaW5nTnVtYmVyKSxJLmRpcnR5PSEwLCFEJiZnLmNoZWNrRm9yUmlnaHRTcGxpY2UobixJKSYmKGcuYWRkV2luZGluZyhQLEwpLGcuZGVsZXRlUmVnaW9uKG4sSSksbi5tZXNoLmRlbGV0ZShMKSksRD0hMSxJPUMsTD1QO0kuZGlydHk9ITAsbShJLndpbmRpbmdOdW1iZXItUC53aW5kaW5nPT09Qy53aW5kaW5nTnVtYmVyKSxBJiZnLndhbGtEaXJ0eVJlZ2lvbnMobixJKX0sZy5zcGxpY2VNZXJnZVZlcnRpY2VzPWZ1bmN0aW9uKG4sYSxpKXtuLm1lc2guc3BsaWNlKGEsaSl9LGcudmVydGV4V2VpZ2h0cz1mdW5jdGlvbihuLGEsaSl7dmFyIG89cy52ZXJ0TDFkaXN0KGEsbiksVD1zLnZlcnRMMWRpc3QoaSxuKSxBPS41KlQvKG8rVCksQz0uNSpvLyhvK1QpO24uY29vcmRzWzBdKz1BKmEuY29vcmRzWzBdK0MqaS5jb29yZHNbMF0sbi5jb29yZHNbMV0rPUEqYS5jb29yZHNbMV0rQyppLmNvb3Jkc1sxXSxuLmNvb3Jkc1syXSs9QSphLmNvb3Jkc1syXStDKmkuY29vcmRzWzJdfSxnLmdldEludGVyc2VjdERhdGE9ZnVuY3Rpb24obixhLGksbyxULEEpe2EuY29vcmRzWzBdPWEuY29vcmRzWzFdPWEuY29vcmRzWzJdPTAsYS5pZHg9LTEsZy52ZXJ0ZXhXZWlnaHRzKGEsaSxvKSxnLnZlcnRleFdlaWdodHMoYSxULEEpfSxnLmNoZWNrRm9yUmlnaHRTcGxpY2U9ZnVuY3Rpb24obixhKXt2YXIgaT1nLnJlZ2lvbkJlbG93KGEpLG89YS5lVXAsVD1pLmVVcDtpZihzLnZlcnRMZXEoby5PcmcsVC5PcmcpKXtpZihzLmVkZ2VTaWduKFQuRHN0LG8uT3JnLFQuT3JnKT4wKXJldHVybiExO3MudmVydEVxKG8uT3JnLFQuT3JnKT9vLk9yZyE9PVQuT3JnJiYobi5wcS5kZWxldGUoby5PcmcucHFIYW5kbGUpLGcuc3BsaWNlTWVyZ2VWZXJ0aWNlcyhuLFQuT3ByZXYsbykpOihuLm1lc2guc3BsaXRFZGdlKFQuU3ltKSxuLm1lc2guc3BsaWNlKG8sVC5PcHJldiksYS5kaXJ0eT1pLmRpcnR5PSEwKX1lbHNle2lmKHMuZWRnZVNpZ24oby5Ec3QsVC5Pcmcsby5PcmcpPDApcmV0dXJuITE7Zy5yZWdpb25BYm92ZShhKS5kaXJ0eT1hLmRpcnR5PSEwLG4ubWVzaC5zcGxpdEVkZ2Uoby5TeW0pLG4ubWVzaC5zcGxpY2UoVC5PcHJldixvKX1yZXR1cm4hMH0sZy5jaGVja0ZvckxlZnRTcGxpY2U9ZnVuY3Rpb24obixhKXt2YXIgaT1nLnJlZ2lvbkJlbG93KGEpLG89YS5lVXAsVD1pLmVVcCxBO2lmKG0oIXMudmVydEVxKG8uRHN0LFQuRHN0KSkscy52ZXJ0TGVxKG8uRHN0LFQuRHN0KSl7aWYocy5lZGdlU2lnbihvLkRzdCxULkRzdCxvLk9yZyk8MClyZXR1cm4hMTtnLnJlZ2lvbkFib3ZlKGEpLmRpcnR5PWEuZGlydHk9ITAsQT1uLm1lc2guc3BsaXRFZGdlKG8pLG4ubWVzaC5zcGxpY2UoVC5TeW0sQSksQS5MZmFjZS5pbnNpZGU9YS5pbnNpZGV9ZWxzZXtpZihzLmVkZ2VTaWduKFQuRHN0LG8uRHN0LFQuT3JnKT4wKXJldHVybiExO2EuZGlydHk9aS5kaXJ0eT0hMCxBPW4ubWVzaC5zcGxpdEVkZ2UoVCksbi5tZXNoLnNwbGljZShvLkxuZXh0LFQuU3ltKSxBLlJmYWNlLmluc2lkZT1hLmluc2lkZX1yZXR1cm4hMH0sZy5jaGVja0ZvckludGVyc2VjdD1mdW5jdGlvbihuLGEpe3ZhciBpPWcucmVnaW9uQmVsb3coYSksbz1hLmVVcCxUPWkuZVVwLEE9by5PcmcsQz1ULk9yZyxJPW8uRHN0LFA9VC5Ec3QsTCxELGI9bmV3IHksUyxCO2lmKG0oIXMudmVydEVxKFAsSSkpLG0ocy5lZGdlU2lnbihJLG4uZXZlbnQsQSk8PTApLG0ocy5lZGdlU2lnbihQLG4uZXZlbnQsQyk+PTApLG0oQSE9PW4uZXZlbnQmJkMhPT1uLmV2ZW50KSxtKCFhLmZpeFVwcGVyRWRnZSYmIWkuZml4VXBwZXJFZGdlKSxBPT09Q3x8KEw9TWF0aC5taW4oQS50LEkudCksRD1NYXRoLm1heChDLnQsUC50KSxMPkQpKXJldHVybiExO2lmKHMudmVydExlcShBLEMpKXtpZihzLmVkZ2VTaWduKFAsQSxDKT4wKXJldHVybiExfWVsc2UgaWYocy5lZGdlU2lnbihJLEMsQSk8MClyZXR1cm4hMTtyZXR1cm4gZy5kZWJ1Z0V2ZW50KG4pLHMuaW50ZXJzZWN0KEksQSxQLEMsYiksbShNYXRoLm1pbihBLnQsSS50KTw9Yi50KSxtKGIudDw9TWF0aC5tYXgoQy50LFAudCkpLG0oTWF0aC5taW4oUC5zLEkucyk8PWIucyksbShiLnM8PU1hdGgubWF4KEMucyxBLnMpKSxzLnZlcnRMZXEoYixuLmV2ZW50KSYmKGIucz1uLmV2ZW50LnMsYi50PW4uZXZlbnQudCksUz1zLnZlcnRMZXEoQSxDKT9BOkMscy52ZXJ0TGVxKFMsYikmJihiLnM9Uy5zLGIudD1TLnQpLHMudmVydEVxKGIsQSl8fHMudmVydEVxKGIsQyk/KGcuY2hlY2tGb3JSaWdodFNwbGljZShuLGEpLCExKTohcy52ZXJ0RXEoSSxuLmV2ZW50KSYmcy5lZGdlU2lnbihJLG4uZXZlbnQsYik+PTB8fCFzLnZlcnRFcShQLG4uZXZlbnQpJiZzLmVkZ2VTaWduKFAsbi5ldmVudCxiKTw9MD9QPT09bi5ldmVudD8obi5tZXNoLnNwbGl0RWRnZShvLlN5bSksbi5tZXNoLnNwbGljZShULlN5bSxvKSxhPWcudG9wTGVmdFJlZ2lvbihuLGEpLG89Zy5yZWdpb25CZWxvdyhhKS5lVXAsZy5maW5pc2hMZWZ0UmVnaW9ucyhuLGcucmVnaW9uQmVsb3coYSksaSksZy5hZGRSaWdodEVkZ2VzKG4sYSxvLk9wcmV2LG8sbywhMCksITApOkk9PT1uLmV2ZW50PyhuLm1lc2guc3BsaXRFZGdlKFQuU3ltKSxuLm1lc2guc3BsaWNlKG8uTG5leHQsVC5PcHJldiksaT1hLGE9Zy50b3BSaWdodFJlZ2lvbihhKSxCPWcucmVnaW9uQmVsb3coYSkuZVVwLlJwcmV2LGkuZVVwPVQuT3ByZXYsVD1nLmZpbmlzaExlZnRSZWdpb25zKG4saSxudWxsKSxnLmFkZFJpZ2h0RWRnZXMobixhLFQuT25leHQsby5ScHJldixCLCEwKSwhMCk6KHMuZWRnZVNpZ24oSSxuLmV2ZW50LGIpPj0wJiYoZy5yZWdpb25BYm92ZShhKS5kaXJ0eT1hLmRpcnR5PSEwLG4ubWVzaC5zcGxpdEVkZ2Uoby5TeW0pLG8uT3JnLnM9bi5ldmVudC5zLG8uT3JnLnQ9bi5ldmVudC50KSxzLmVkZ2VTaWduKFAsbi5ldmVudCxiKTw9MCYmKGEuZGlydHk9aS5kaXJ0eT0hMCxuLm1lc2guc3BsaXRFZGdlKFQuU3ltKSxULk9yZy5zPW4uZXZlbnQucyxULk9yZy50PW4uZXZlbnQudCksITEpOihuLm1lc2guc3BsaXRFZGdlKG8uU3ltKSxuLm1lc2guc3BsaXRFZGdlKFQuU3ltKSxuLm1lc2guc3BsaWNlKFQuT3ByZXYsbyksby5Pcmcucz1iLnMsby5PcmcudD1iLnQsby5PcmcucHFIYW5kbGU9bi5wcS5pbnNlcnQoby5PcmcpLGcuZ2V0SW50ZXJzZWN0RGF0YShuLG8uT3JnLEEsSSxDLFApLGcucmVnaW9uQWJvdmUoYSkuZGlydHk9YS5kaXJ0eT1pLmRpcnR5PSEwLCExKX0sZy53YWxrRGlydHlSZWdpb25zPWZ1bmN0aW9uKG4sYSl7Zm9yKHZhciBpPWcucmVnaW9uQmVsb3coYSksbyxUOzspe2Zvcig7aS5kaXJ0eTspYT1pLGk9Zy5yZWdpb25CZWxvdyhpKTtpZighYS5kaXJ0eSYmKGk9YSxhPWcucmVnaW9uQWJvdmUoYSksYT09PW51bGx8fCFhLmRpcnR5KSlyZXR1cm47aWYoYS5kaXJ0eT0hMSxvPWEuZVVwLFQ9aS5lVXAsby5Ec3QhPT1ULkRzdCYmZy5jaGVja0ZvckxlZnRTcGxpY2UobixhKSYmKGkuZml4VXBwZXJFZGdlPyhnLmRlbGV0ZVJlZ2lvbihuLGkpLG4ubWVzaC5kZWxldGUoVCksaT1nLnJlZ2lvbkJlbG93KGEpLFQ9aS5lVXApOmEuZml4VXBwZXJFZGdlJiYoZy5kZWxldGVSZWdpb24obixhKSxuLm1lc2guZGVsZXRlKG8pLGE9Zy5yZWdpb25BYm92ZShpKSxvPWEuZVVwKSksby5PcmchPT1ULk9yZylpZihvLkRzdCE9PVQuRHN0JiYhYS5maXhVcHBlckVkZ2UmJiFpLmZpeFVwcGVyRWRnZSYmKG8uRHN0PT09bi5ldmVudHx8VC5Ec3Q9PT1uLmV2ZW50KSl7aWYoZy5jaGVja0ZvckludGVyc2VjdChuLGEpKXJldHVybn1lbHNlIGcuY2hlY2tGb3JSaWdodFNwbGljZShuLGEpO28uT3JnPT09VC5PcmcmJm8uRHN0PT09VC5Ec3QmJihnLmFkZFdpbmRpbmcoVCxvKSxnLmRlbGV0ZVJlZ2lvbihuLGEpLG4ubWVzaC5kZWxldGUobyksYT1nLnJlZ2lvbkFib3ZlKGkpKX19LGcuY29ubmVjdFJpZ2h0VmVydGV4PWZ1bmN0aW9uKG4sYSxpKXt2YXIgbyxUPWkuT25leHQsQT1nLnJlZ2lvbkJlbG93KGEpLEM9YS5lVXAsST1BLmVVcCxQPSExO2lmKEMuRHN0IT09SS5Ec3QmJmcuY2hlY2tGb3JJbnRlcnNlY3QobixhKSxzLnZlcnRFcShDLk9yZyxuLmV2ZW50KSYmKG4ubWVzaC5zcGxpY2UoVC5PcHJldixDKSxhPWcudG9wTGVmdFJlZ2lvbihuLGEpLFQ9Zy5yZWdpb25CZWxvdyhhKS5lVXAsZy5maW5pc2hMZWZ0UmVnaW9ucyhuLGcucmVnaW9uQmVsb3coYSksQSksUD0hMCkscy52ZXJ0RXEoSS5Pcmcsbi5ldmVudCkmJihuLm1lc2guc3BsaWNlKGksSS5PcHJldiksaT1nLmZpbmlzaExlZnRSZWdpb25zKG4sQSxudWxsKSxQPSEwKSxQKXtnLmFkZFJpZ2h0RWRnZXMobixhLGkuT25leHQsVCxULCEwKTtyZXR1cm59cy52ZXJ0TGVxKEkuT3JnLEMuT3JnKT9vPUkuT3ByZXY6bz1DLG89bi5tZXNoLmNvbm5lY3QoaS5McHJldixvKSxnLmFkZFJpZ2h0RWRnZXMobixhLG8sby5PbmV4dCxvLk9uZXh0LCExKSxvLlN5bS5hY3RpdmVSZWdpb24uZml4VXBwZXJFZGdlPSEwLGcud2Fsa0RpcnR5UmVnaW9ucyhuLGEpfSxnLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZT1mdW5jdGlvbihuLGEsaSl7dmFyIG8sVCxBLEMsSTtpZihvPWEuZVVwLHMudmVydEVxKG8uT3JnLGkpKXttKCExKSxnLnNwbGljZU1lcmdlVmVydGljZXMobixvLGkuYW5FZGdlKTtyZXR1cm59aWYoIXMudmVydEVxKG8uRHN0LGkpKXtuLm1lc2guc3BsaXRFZGdlKG8uU3ltKSxhLmZpeFVwcGVyRWRnZSYmKG4ubWVzaC5kZWxldGUoby5PbmV4dCksYS5maXhVcHBlckVkZ2U9ITEpLG4ubWVzaC5zcGxpY2UoaS5hbkVkZ2UsbyksZy5zd2VlcEV2ZW50KG4saSk7cmV0dXJufW0oITEpLGE9Zy50b3BSaWdodFJlZ2lvbihhKSxJPWcucmVnaW9uQmVsb3coYSksQT1JLmVVcC5TeW0sVD1DPUEuT25leHQsSS5maXhVcHBlckVkZ2UmJihtKFQhPT1BKSxnLmRlbGV0ZVJlZ2lvbihuLEkpLG4ubWVzaC5kZWxldGUoQSksQT1ULk9wcmV2KSxuLm1lc2guc3BsaWNlKGkuYW5FZGdlLEEpLHMuZWRnZUdvZXNMZWZ0KFQpfHwoVD1udWxsKSxnLmFkZFJpZ2h0RWRnZXMobixhLEEuT25leHQsQyxULCEwKX0sZy5jb25uZWN0TGVmdFZlcnRleD1mdW5jdGlvbihuLGEpe3ZhciBpLG8sVCxBLEMsSSxQPW5ldyBPO2lmKFAuZVVwPWEuYW5FZGdlLlN5bSxpPW4uZGljdC5zZWFyY2goUCkua2V5LG89Zy5yZWdpb25CZWxvdyhpKSwhIW8pe2lmKEE9aS5lVXAsQz1vLmVVcCxzLmVkZ2VTaWduKEEuRHN0LGEsQS5PcmcpPT09MCl7Zy5jb25uZWN0TGVmdERlZ2VuZXJhdGUobixpLGEpO3JldHVybn1pZihUPXMudmVydExlcShDLkRzdCxBLkRzdCk/aTpvLGkuaW5zaWRlfHxULmZpeFVwcGVyRWRnZSl7aWYoVD09PWkpST1uLm1lc2guY29ubmVjdChhLmFuRWRnZS5TeW0sQS5MbmV4dCk7ZWxzZXt2YXIgTD1uLm1lc2guY29ubmVjdChDLkRuZXh0LGEuYW5FZGdlKTtJPUwuU3ltfVQuZml4VXBwZXJFZGdlP2cuZml4VXBwZXJFZGdlKG4sVCxJKTpnLmNvbXB1dGVXaW5kaW5nKG4sZy5hZGRSZWdpb25CZWxvdyhuLGksSSkpLGcuc3dlZXBFdmVudChuLGEpfWVsc2UgZy5hZGRSaWdodEVkZ2VzKG4saSxhLmFuRWRnZSxhLmFuRWRnZSxudWxsLCEwKX19LGcuc3dlZXBFdmVudD1mdW5jdGlvbihuLGEpe24uZXZlbnQ9YSxnLmRlYnVnRXZlbnQobik7Zm9yKHZhciBpPWEuYW5FZGdlO2kuYWN0aXZlUmVnaW9uPT09bnVsbDspaWYoaT1pLk9uZXh0LGk9PT1hLmFuRWRnZSl7Zy5jb25uZWN0TGVmdFZlcnRleChuLGEpO3JldHVybn12YXIgbz1nLnRvcExlZnRSZWdpb24obixpLmFjdGl2ZVJlZ2lvbik7bShvIT09bnVsbCk7dmFyIFQ9Zy5yZWdpb25CZWxvdyhvKSxBPVQuZVVwLEM9Zy5maW5pc2hMZWZ0UmVnaW9ucyhuLFQsbnVsbCk7Qy5PbmV4dD09PUE/Zy5jb25uZWN0UmlnaHRWZXJ0ZXgobixvLEMpOmcuYWRkUmlnaHRFZGdlcyhuLG8sQy5PbmV4dCxBLEEsITApfSxnLmFkZFNlbnRpbmVsPWZ1bmN0aW9uKG4sYSxpLG8pe3ZhciBUPW5ldyBPLEE9bi5tZXNoLm1ha2VFZGdlKCk7QS5Pcmcucz1pLEEuT3JnLnQ9byxBLkRzdC5zPWEsQS5Ec3QudD1vLG4uZXZlbnQ9QS5Ec3QsVC5lVXA9QSxULndpbmRpbmdOdW1iZXI9MCxULmluc2lkZT0hMSxULmZpeFVwcGVyRWRnZT0hMSxULnNlbnRpbmVsPSEwLFQuZGlydHk9ITEsVC5ub2RlVXA9bi5kaWN0Lmluc2VydChUKX0sZy5pbml0RWRnZURpY3Q9ZnVuY3Rpb24obil7bi5kaWN0PW5ldyBmKG4sZy5lZGdlTGVxKTt2YXIgYT1uLmJtYXhbMF0tbi5ibWluWzBdLGk9bi5ibWF4WzFdLW4uYm1pblsxXSxvPW4uYm1pblswXS1hLFQ9bi5ibWF4WzBdK2EsQT1uLmJtaW5bMV0taSxDPW4uYm1heFsxXStpO2cuYWRkU2VudGluZWwobixvLFQsQSksZy5hZGRTZW50aW5lbChuLG8sVCxDKX0sZy5kb25lRWRnZURpY3Q9ZnVuY3Rpb24obil7Zm9yKHZhciBhLGk9MDsoYT1uLmRpY3QubWluKCkua2V5KSE9PW51bGw7KWEuc2VudGluZWx8fChtKGEuZml4VXBwZXJFZGdlKSxtKCsraT09PTEpKSxtKGEud2luZGluZ051bWJlcj09PTApLGcuZGVsZXRlUmVnaW9uKG4sYSl9LGcucmVtb3ZlRGVnZW5lcmF0ZUVkZ2VzPWZ1bmN0aW9uKG4pe3ZhciBhLGksbyxUPW4ubWVzaC5lSGVhZDtmb3IoYT1ULm5leHQ7YSE9PVQ7YT1pKWk9YS5uZXh0LG89YS5MbmV4dCxzLnZlcnRFcShhLk9yZyxhLkRzdCkmJmEuTG5leHQuTG5leHQhPT1hJiYoZy5zcGxpY2VNZXJnZVZlcnRpY2VzKG4sbyxhKSxuLm1lc2guZGVsZXRlKGEpLGE9byxvPWEuTG5leHQpLG8uTG5leHQ9PT1hJiYobyE9PWEmJigobz09PWl8fG89PT1pLlN5bSkmJihpPWkubmV4dCksbi5tZXNoLmRlbGV0ZShvKSksKGE9PT1pfHxhPT09aS5TeW0pJiYoaT1pLm5leHQpLG4ubWVzaC5kZWxldGUoYSkpfSxnLmluaXRQcmlvcml0eVE9ZnVuY3Rpb24obil7dmFyIGEsaSxvLFQ9MDtmb3Iobz1uLm1lc2gudkhlYWQsaT1vLm5leHQ7aSE9PW87aT1pLm5leHQpVCsrO2ZvcihUKz04LGE9bi5wcT1uZXcgUihULHMudmVydExlcSksbz1uLm1lc2gudkhlYWQsaT1vLm5leHQ7aSE9PW87aT1pLm5leHQpaS5wcUhhbmRsZT1hLmluc2VydChpKTtyZXR1cm4gaSE9PW8/ITE6KGEuaW5pdCgpLCEwKX0sZy5kb25lUHJpb3JpdHlRPWZ1bmN0aW9uKG4pe24ucHE9bnVsbH0sZy5yZW1vdmVEZWdlbmVyYXRlRmFjZXM9ZnVuY3Rpb24obixhKXt2YXIgaSxvLFQ7Zm9yKGk9YS5mSGVhZC5uZXh0O2khPT1hLmZIZWFkO2k9bylvPWkubmV4dCxUPWkuYW5FZGdlLG0oVC5MbmV4dCE9PVQpLFQuTG5leHQuTG5leHQ9PT1UJiYoZy5hZGRXaW5kaW5nKFQuT25leHQsVCksbi5tZXNoLmRlbGV0ZShUKSk7cmV0dXJuITB9LGcuY29tcHV0ZUludGVyaW9yPWZ1bmN0aW9uKG4pe3ZhciBhLGk7aWYoZy5yZW1vdmVEZWdlbmVyYXRlRWRnZXMobiksIWcuaW5pdFByaW9yaXR5UShuKSlyZXR1cm4hMTtmb3IoZy5pbml0RWRnZURpY3Qobik7KGE9bi5wcS5leHRyYWN0TWluKCkpIT09bnVsbDspe2Zvcig7aT1uLnBxLm1pbigpLCEoaT09PW51bGx8fCFzLnZlcnRFcShpLGEpKTspaT1uLnBxLmV4dHJhY3RNaW4oKSxnLnNwbGljZU1lcmdlVmVydGljZXMobixhLmFuRWRnZSxpLmFuRWRnZSk7Zy5zd2VlcEV2ZW50KG4sYSl9cmV0dXJuIG4uZXZlbnQ9bi5kaWN0Lm1pbigpLmtleS5lVXAuT3JnLGcuZGVidWdFdmVudChuKSxnLmRvbmVFZGdlRGljdChuKSxnLmRvbmVQcmlvcml0eVEobiksZy5yZW1vdmVEZWdlbmVyYXRlRmFjZXMobixuLm1lc2gpPyhuLm1lc2guY2hlY2soKSwhMCk6ITF9O2Z1bmN0aW9uIHAoKXt0aGlzLm1lc2g9bnVsbCx0aGlzLm5vcm1hbD1bMCwwLDBdLHRoaXMuc1VuaXQ9WzAsMCwwXSx0aGlzLnRVbml0PVswLDAsMF0sdGhpcy5ibWluPVswLDBdLHRoaXMuYm1heD1bMCwwXSx0aGlzLndpbmRpbmdSdWxlPXIuV0lORElOR19PREQsdGhpcy5kaWN0PW51bGwsdGhpcy5wcT1udWxsLHRoaXMuZXZlbnQ9bnVsbCx0aGlzLnZlcnRleEluZGV4Q291bnRlcj0wLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudENvdW50PTB9cC5wcm90b3R5cGU9e2RvdF86ZnVuY3Rpb24obixhKXtyZXR1cm4gblswXSphWzBdK25bMV0qYVsxXStuWzJdKmFbMl19LG5vcm1hbGl6ZV86ZnVuY3Rpb24obil7dmFyIGE9blswXSpuWzBdK25bMV0qblsxXStuWzJdKm5bMl07bShhPjApLGE9TWF0aC5zcXJ0KGEpLG5bMF0vPWEsblsxXS89YSxuWzJdLz1hfSxsb25nQXhpc186ZnVuY3Rpb24obil7dmFyIGE9MDtyZXR1cm4gTWF0aC5hYnMoblsxXSk+TWF0aC5hYnMoblswXSkmJihhPTEpLE1hdGguYWJzKG5bMl0pPk1hdGguYWJzKG5bYV0pJiYoYT0yKSxhfSxjb21wdXRlTm9ybWFsXzpmdW5jdGlvbihuKXt2YXIgYSxpLG8sVCxBLEMsST1bMCwwLDBdLFA9WzAsMCwwXSxMPVswLDAsMF0sRD1bMCwwLDBdLGI9WzAsMCwwXSxTPVtudWxsLG51bGwsbnVsbF0sQj1bbnVsbCxudWxsLG51bGxdLHc9dGhpcy5tZXNoLnZIZWFkLEg7Zm9yKGE9dy5uZXh0LEg9MDtIPDM7KytIKVQ9YS5jb29yZHNbSF0sUFtIXT1ULEJbSF09YSxJW0hdPVQsU1tIXT1hO2ZvcihhPXcubmV4dDthIT09dzthPWEubmV4dClmb3IoSD0wO0g8MzsrK0gpVD1hLmNvb3Jkc1tIXSxUPFBbSF0mJihQW0hdPVQsQltIXT1hKSxUPklbSF0mJihJW0hdPVQsU1tIXT1hKTtpZihIPTAsSVsxXS1QWzFdPklbMF0tUFswXSYmKEg9MSksSVsyXS1QWzJdPklbSF0tUFtIXSYmKEg9MiksUFtIXT49SVtIXSl7blswXT0wLG5bMV09MCxuWzJdPTE7cmV0dXJufWZvcihDPTAsaT1CW0hdLG89U1tIXSxMWzBdPWkuY29vcmRzWzBdLW8uY29vcmRzWzBdLExbMV09aS5jb29yZHNbMV0tby5jb29yZHNbMV0sTFsyXT1pLmNvb3Jkc1syXS1vLmNvb3Jkc1syXSxhPXcubmV4dDthIT09dzthPWEubmV4dClEWzBdPWEuY29vcmRzWzBdLW8uY29vcmRzWzBdLERbMV09YS5jb29yZHNbMV0tby5jb29yZHNbMV0sRFsyXT1hLmNvb3Jkc1syXS1vLmNvb3Jkc1syXSxiWzBdPUxbMV0qRFsyXS1MWzJdKkRbMV0sYlsxXT1MWzJdKkRbMF0tTFswXSpEWzJdLGJbMl09TFswXSpEWzFdLUxbMV0qRFswXSxBPWJbMF0qYlswXStiWzFdKmJbMV0rYlsyXSpiWzJdLEE+QyYmKEM9QSxuWzBdPWJbMF0sblsxXT1iWzFdLG5bMl09YlsyXSk7Qzw9MCYmKG5bMF09blsxXT1uWzJdPTAsblt0aGlzLmxvbmdBeGlzXyhMKV09MSl9LGNoZWNrT3JpZW50YXRpb25fOmZ1bmN0aW9uKCl7dmFyIG4sYSxpPXRoaXMubWVzaC5mSGVhZCxvLFQ9dGhpcy5tZXNoLnZIZWFkLEE7Zm9yKG49MCxhPWkubmV4dDthIT09aTthPWEubmV4dClpZihBPWEuYW5FZGdlLCEoQS53aW5kaW5nPD0wKSlkbyBuKz0oQS5Pcmcucy1BLkRzdC5zKSooQS5PcmcudCtBLkRzdC50KSxBPUEuTG5leHQ7d2hpbGUoQSE9PWEuYW5FZGdlKTtpZihuPDApe2ZvcihvPVQubmV4dDtvIT09VDtvPW8ubmV4dClvLnQ9LW8udDt0aGlzLnRVbml0WzBdPS10aGlzLnRVbml0WzBdLHRoaXMudFVuaXRbMV09LXRoaXMudFVuaXRbMV0sdGhpcy50VW5pdFsyXT0tdGhpcy50VW5pdFsyXX19LHByb2plY3RQb2x5Z29uXzpmdW5jdGlvbigpe3ZhciBuLGE9dGhpcy5tZXNoLnZIZWFkLGk9WzAsMCwwXSxvLFQsQSxDLEk9ITE7Zm9yKGlbMF09dGhpcy5ub3JtYWxbMF0saVsxXT10aGlzLm5vcm1hbFsxXSxpWzJdPXRoaXMubm9ybWFsWzJdLGlbMF09PT0wJiZpWzFdPT09MCYmaVsyXT09PTAmJih0aGlzLmNvbXB1dGVOb3JtYWxfKGkpLEk9ITApLG89dGhpcy5zVW5pdCxUPXRoaXMudFVuaXQsQT10aGlzLmxvbmdBeGlzXyhpKSxvW0FdPTAsb1soQSsxKSUzXT0xLG9bKEErMiklM109MCxUW0FdPTAsVFsoQSsxKSUzXT0wLFRbKEErMiklM109aVtBXT4wPzE6LTEsbj1hLm5leHQ7biE9PWE7bj1uLm5leHQpbi5zPXRoaXMuZG90XyhuLmNvb3JkcyxvKSxuLnQ9dGhpcy5kb3RfKG4uY29vcmRzLFQpO2ZvcihJJiZ0aGlzLmNoZWNrT3JpZW50YXRpb25fKCksQz0hMCxuPWEubmV4dDtuIT09YTtuPW4ubmV4dClDPyh0aGlzLmJtaW5bMF09dGhpcy5ibWF4WzBdPW4ucyx0aGlzLmJtaW5bMV09dGhpcy5ibWF4WzFdPW4udCxDPSExKToobi5zPHRoaXMuYm1pblswXSYmKHRoaXMuYm1pblswXT1uLnMpLG4ucz50aGlzLmJtYXhbMF0mJih0aGlzLmJtYXhbMF09bi5zKSxuLnQ8dGhpcy5ibWluWzFdJiYodGhpcy5ibWluWzFdPW4udCksbi50PnRoaXMuYm1heFsxXSYmKHRoaXMuYm1heFsxXT1uLnQpKX0sYWRkV2luZGluZ186ZnVuY3Rpb24obixhKXtuLndpbmRpbmcrPWEud2luZGluZyxuLlN5bS53aW5kaW5nKz1hLlN5bS53aW5kaW5nfSx0ZXNzZWxsYXRlTW9ub1JlZ2lvbl86ZnVuY3Rpb24obixhKXt2YXIgaSxvO2ZvcihpPWEuYW5FZGdlLG0oaS5MbmV4dCE9PWkmJmkuTG5leHQuTG5leHQhPT1pKTtzLnZlcnRMZXEoaS5Ec3QsaS5PcmcpO2k9aS5McHJldik7Zm9yKDtzLnZlcnRMZXEoaS5PcmcsaS5Ec3QpO2k9aS5MbmV4dCk7Zm9yKG89aS5McHJldjtpLkxuZXh0IT09bzspaWYocy52ZXJ0TGVxKGkuRHN0LG8uT3JnKSl7Zm9yKDtvLkxuZXh0IT09aSYmKHMuZWRnZUdvZXNMZWZ0KG8uTG5leHQpfHxzLmVkZ2VTaWduKG8uT3JnLG8uRHN0LG8uTG5leHQuRHN0KTw9MCk7KXt2YXIgVD1uLmNvbm5lY3Qoby5MbmV4dCxvKTtvPVQuU3ltfW89by5McHJldn1lbHNle2Zvcig7by5MbmV4dCE9PWkmJihzLmVkZ2VHb2VzUmlnaHQoaS5McHJldil8fHMuZWRnZVNpZ24oaS5Ec3QsaS5PcmcsaS5McHJldi5PcmcpPj0wKTspe3ZhciBUPW4uY29ubmVjdChpLGkuTHByZXYpO2k9VC5TeW19aT1pLkxuZXh0fWZvcihtKG8uTG5leHQhPT1pKTtvLkxuZXh0LkxuZXh0IT09aTspe3ZhciBUPW4uY29ubmVjdChvLkxuZXh0LG8pO289VC5TeW19cmV0dXJuITB9LHRlc3NlbGxhdGVJbnRlcmlvcl86ZnVuY3Rpb24obil7dmFyIGEsaTtmb3IoYT1uLmZIZWFkLm5leHQ7YSE9PW4uZkhlYWQ7YT1pKWlmKGk9YS5uZXh0LGEuaW5zaWRlJiYhdGhpcy50ZXNzZWxsYXRlTW9ub1JlZ2lvbl8obixhKSlyZXR1cm4hMTtyZXR1cm4hMH0sZGlzY2FyZEV4dGVyaW9yXzpmdW5jdGlvbihuKXt2YXIgYSxpO2ZvcihhPW4uZkhlYWQubmV4dDthIT09bi5mSGVhZDthPWkpaT1hLm5leHQsYS5pbnNpZGV8fG4uemFwRmFjZShhKX0sc2V0V2luZGluZ051bWJlcl86ZnVuY3Rpb24obixhLGkpe3ZhciBvLFQ7Zm9yKG89bi5lSGVhZC5uZXh0O28hPT1uLmVIZWFkO289VClUPW8ubmV4dCxvLlJmYWNlLmluc2lkZSE9PW8uTGZhY2UuaW5zaWRlP28ud2luZGluZz1vLkxmYWNlLmluc2lkZT9hOi1hOmk/bi5kZWxldGUobyk6by53aW5kaW5nPTB9LGdldE5laWdoYm91ckZhY2VfOmZ1bmN0aW9uKG4pe3JldHVybiFuLlJmYWNlfHwhbi5SZmFjZS5pbnNpZGU/LTE6bi5SZmFjZS5ufSxvdXRwdXRQb2x5bWVzaF86ZnVuY3Rpb24obixhLGksbyl7dmFyIFQsQSxDLEk9MCxQPTAsTCxEO2ZvcihpPjMmJm4ubWVyZ2VDb252ZXhGYWNlcyhpKSxUPW4udkhlYWQubmV4dDtUIT09bi52SGVhZDtUPVQubmV4dClULm49LTE7Zm9yKEE9bi5mSGVhZC5uZXh0O0EhPT1uLmZIZWFkO0E9QS5uZXh0KWlmKEEubj0tMSwhIUEuaW5zaWRlKXtDPUEuYW5FZGdlLEw9MDtkbyBUPUMuT3JnLFQubj09PS0xJiYoVC5uPVAsUCsrKSxMKyssQz1DLkxuZXh0O3doaWxlKEMhPT1BLmFuRWRnZSk7bShMPD1pKSxBLm49SSwrK0l9Zm9yKHRoaXMuZWxlbWVudENvdW50PUksYT09PXIuQ09OTkVDVEVEX1BPTFlHT05TJiYoSSo9MiksdGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD1JKmksdGhpcy52ZXJ0ZXhDb3VudD1QLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9UCpvLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPVAsVD1uLnZIZWFkLm5leHQ7VCE9PW4udkhlYWQ7VD1ULm5leHQpaWYoVC5uIT09LTEpe3ZhciBiPVQubipvO3RoaXMudmVydGljZXNbYiswXT1ULmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW2IrMV09VC5jb29yZHNbMV0sbz4yJiYodGhpcy52ZXJ0aWNlc1tiKzJdPVQuY29vcmRzWzJdKSx0aGlzLnZlcnRleEluZGljZXNbVC5uXT1ULmlkeH12YXIgUz0wO2ZvcihBPW4uZkhlYWQubmV4dDtBIT09bi5mSGVhZDtBPUEubmV4dClpZihBLmluc2lkZSl7Qz1BLmFuRWRnZSxMPTA7ZG8gVD1DLk9yZyx0aGlzLmVsZW1lbnRzW1MrK109VC5uLEwrKyxDPUMuTG5leHQ7d2hpbGUoQyE9PUEuYW5FZGdlKTtmb3IoRD1MO0Q8aTsrK0QpdGhpcy5lbGVtZW50c1tTKytdPS0xO2lmKGE9PT1yLkNPTk5FQ1RFRF9QT0xZR09OUyl7Qz1BLmFuRWRnZTtkbyB0aGlzLmVsZW1lbnRzW1MrK109dGhpcy5nZXROZWlnaGJvdXJGYWNlXyhDKSxDPUMuTG5leHQ7d2hpbGUoQyE9PUEuYW5FZGdlKTtmb3IoRD1MO0Q8aTsrK0QpdGhpcy5lbGVtZW50c1tTKytdPS0xfX19LG91dHB1dENvbnRvdXJzXzpmdW5jdGlvbihuLGEpe3ZhciBpLG8sVCxBPTAsQz0wO2Zvcih0aGlzLnZlcnRleENvdW50PTAsdGhpcy5lbGVtZW50Q291bnQ9MCxpPW4uZkhlYWQubmV4dDtpIT09bi5mSGVhZDtpPWkubmV4dClpZihpLmluc2lkZSl7VD1vPWkuYW5FZGdlO2RvIHRoaXMudmVydGV4Q291bnQrKyxvPW8uTG5leHQ7d2hpbGUobyE9PVQpO3RoaXMuZWxlbWVudENvdW50Kyt9dGhpcy5lbGVtZW50cz1bXSx0aGlzLmVsZW1lbnRzLmxlbmd0aD10aGlzLmVsZW1lbnRDb3VudCoyLHRoaXMudmVydGljZXM9W10sdGhpcy52ZXJ0aWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudCphLHRoaXMudmVydGV4SW5kaWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoPXRoaXMudmVydGV4Q291bnQ7dmFyIEk9MCxQPTAsTD0wO2ZvcihBPTAsaT1uLmZIZWFkLm5leHQ7aSE9PW4uZkhlYWQ7aT1pLm5leHQpaWYoaS5pbnNpZGUpe0M9MCxUPW89aS5hbkVkZ2U7ZG8gdGhpcy52ZXJ0aWNlc1tJKytdPW8uT3JnLmNvb3Jkc1swXSx0aGlzLnZlcnRpY2VzW0krK109by5PcmcuY29vcmRzWzFdLGE+MiYmKHRoaXMudmVydGljZXNbSSsrXT1vLk9yZy5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tQKytdPW8uT3JnLmlkeCxDKyssbz1vLkxuZXh0O3doaWxlKG8hPT1UKTt0aGlzLmVsZW1lbnRzW0wrK109QSx0aGlzLmVsZW1lbnRzW0wrK109QyxBKz1DfX0sYWRkQ29udG91cjpmdW5jdGlvbihuLGEpe3ZhciBpLG87Zm9yKHRoaXMubWVzaD09PW51bGwmJih0aGlzLm1lc2g9bmV3IHUpLG48MiYmKG49Miksbj4zJiYobj0zKSxpPW51bGwsbz0wO288YS5sZW5ndGg7bys9bilpPT09bnVsbD8oaT10aGlzLm1lc2gubWFrZUVkZ2UoKSx0aGlzLm1lc2guc3BsaWNlKGksaS5TeW0pKToodGhpcy5tZXNoLnNwbGl0RWRnZShpKSxpPWkuTG5leHQpLGkuT3JnLmNvb3Jkc1swXT1hW28rMF0saS5PcmcuY29vcmRzWzFdPWFbbysxXSxuPjI/aS5PcmcuY29vcmRzWzJdPWFbbysyXTppLk9yZy5jb29yZHNbMl09MCxpLk9yZy5pZHg9dGhpcy52ZXJ0ZXhJbmRleENvdW50ZXIrKyxpLndpbmRpbmc9MSxpLlN5bS53aW5kaW5nPS0xfSx0ZXNzZWxhdGU6ZnVuY3Rpb24obixhLGksbyxUKXtpZih0aGlzLnZlcnRpY2VzPVtdLHRoaXMuZWxlbWVudHM9W10sdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsVCYmKHRoaXMubm9ybWFsWzBdPVRbMF0sdGhpcy5ub3JtYWxbMV09VFsxXSx0aGlzLm5vcm1hbFsyXT1UWzJdKSx0aGlzLndpbmRpbmdSdWxlPW4sbzwyJiYobz0yKSxvPjMmJihvPTMpLCF0aGlzLm1lc2gpcmV0dXJuITE7dGhpcy5wcm9qZWN0UG9seWdvbl8oKSxnLmNvbXB1dGVJbnRlcmlvcih0aGlzKTt2YXIgQT10aGlzLm1lc2g7cmV0dXJuIGE9PT1yLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMuc2V0V2luZGluZ051bWJlcl8oQSwxLCEwKTp0aGlzLnRlc3NlbGxhdGVJbnRlcmlvcl8oQSksQS5jaGVjaygpLGE9PT1yLkJPVU5EQVJZX0NPTlRPVVJTP3RoaXMub3V0cHV0Q29udG91cnNfKEEsbyk6dGhpcy5vdXRwdXRQb2x5bWVzaF8oQSxhLGksbyksITB9fX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9cjt2YXIgdD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIHIoKXtmb3IodmFyIHM9e30sbT0wO208YXJndW1lbnRzLmxlbmd0aDttKyspe3ZhciB5PWFyZ3VtZW50c1ttXTtmb3IodmFyIGMgaW4geSl0LmNhbGwoeSxjKSYmKHNbY109eVtjXSl9cmV0dXJuIHN9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImFwcGx5U2hhZGVyIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImNyZWF0ZUNsb3VkU2hhZGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhcHBseUNsb3VkU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiB2fSk7dmFyIHI9dCg2NCkscz10KDY1KSxtPXQoNjYpLHk9dCg2Nyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9U3ltYm9sKCJzaGFkZXJzIik7ZnVuY3Rpb24gbCh4KXt4W2NdPVtdO2ZvcihsZXQgUj0wO1I8MTY7UisrKXtjb25zdCBPPVtdLGc9ISEoUiYxKSxwPSEhKFImMiksbj0hIShSJjQpLGE9ISEoUiY4KTtnJiZPLnB1c2goIiNkZWZpbmUgVEVYVFVSRSAxIikscCYmTy5wdXNoKCIjZGVmaW5lIEZJTFRFUiAxIiksbiYmTy5wdXNoKCIjZGVmaW5lIEdSQURJRU5UIDEiKSxhJiZPLnB1c2goIiNkZWZpbmUgQ0xJUFBBVEggMSIpO2NvbnN0IGk9YCR7Ty5qb2luKGAKYCl9CmAsbz1bXTtnJiZvLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U2FtcGxlcjsiKSxhJiZvLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IikseFtjXVtSXT1baStvLmpvaW4oYApgKStzLmRlZmF1bHQsaStyLmRlZmF1bHRdfX1mdW5jdGlvbiB1KHgse2hhc1RleHR1cmU6Uj0hMSxoYXNGaWx0ZXI6Tz0hMSxoYXNHcmFkaWVudDpnPSExLGhhc0NsaXBQYXRoOnA9ITF9PXt9KXtjb25zdCBuPVJ8Tzw8MXxnPDwyfHA8PDM7bGV0IGE9eFtjXVtuXTtBcnJheS5pc0FycmF5KGEpJiYoYT14LmNyZWF0ZVByb2dyYW0oLi4uYSkseFtjXVtuXT1hKSx4LnByb2dyYW0hPT1hJiZ4LnVzZVByb2dyYW0oYSx7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfX0pfWNvbnN0IE09W107ZnVuY3Rpb24gZih4KXtmb3IobGV0IFI9MDtSPDY0O1IrKyl7Y29uc3QgTz1bXSxnPSEhKFImMSkscD0hIShSJjIpLG49ISEoUiY0KSxhPSEhKFImOCksaT0hIShSJjE2KSxvPSEhKFImMzIpO2cmJk8ucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxwJiZPLnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxuJiZPLnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLGEmJk8ucHVzaCgiI2RlZmluZSBDTE9VRENPTE9SIDEiKSxpJiZPLnB1c2goIiNkZWZpbmUgQ0xPVURGSUxURVIgMSIpLG8mJk8ucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3QgVD1gJHtPLmpvaW4oYApgKX0KYCxBPVtdO2lmKGcpe0EucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpO2ZvcihsZXQgQz0wO0M8MTI7QysrKUEucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhGcmFtZSR7Q307YCl9byYmQS5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X2NsaXBTYW1wbGVyOyIpLE1bUl09W1QrQS5qb2luKGAKYCkreS5kZWZhdWx0LFQrbS5kZWZhdWx0XX19ZnVuY3Rpb24gdih4LHtoYXNUZXh0dXJlOlI9ITEsaGFzRmlsdGVyOk89ITEsaGFzR3JhZGllbnQ6Zz0hMSxoYXNDbG91ZENvbG9yOnA9ITEsaGFzQ2xvdWRGaWx0ZXI6bj0hMSxoYXNDbGlwUGF0aDphPSExfT17fSl7Y29uc3QgaT1SfE88PDF8Zzw8MnxwPDwzfG48PDR8YTw8NTtsZXQgbz1NW2ldO0FycmF5LmlzQXJyYXkobykmJihvPXguY3JlYXRlUHJvZ3JhbSguLi5vKSxNW2ldPW8pLHgucHJvZ3JhbSE9PW8mJngudXNlUHJvZ3JhbShvLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZmlsbENsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9zdHJva2VDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfZnJhbWVJbmRleDp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiExfX0pfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIGdsX1BvaW50U2l6ZSA9IDEuMDsKCiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwogIHZDb2xvciA9IGFfY29sb3I7CgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgp9YH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwoKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKCiNpZmRlZiBURVhUVVJFCnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjI7CnVuaWZvcm0gZmxvYXQgdV9jb2xvclN0ZXBzWzQwXTsKdW5pZm9ybSBpbnQgdV9ncmFkaWVudFR5cGU7Ci8vIHVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CiNlbmRpZgoKdm9pZCBtYWluKCkgewogIHZlYzQgY29sb3IgPSB2Q29sb3I7CiAgZmxvYXQgb3BhY2l0eSA9IGFicyhmbGFnQmFja2dyb3VuZCk7CgojaWZkZWYgR1JBRElFTlQKICBpZih1X2dyYWRpZW50VHlwZSA+IDAgJiYgZmxhZ0JhY2tncm91bmQgPiAwLjAgfHwgdV9ncmFkaWVudFR5cGUgPT0gMCAmJiBmbGFnQmFja2dyb3VuZCA8PSAwLjApIHsKICAgIGdyYWRpZW50KGNvbG9yLCB2R3JhZGllbnRWZWN0b3IxLCB2R3JhZGllbnRWZWN0b3IyLCB1X2NvbG9yU3RlcHMpOwogIH0KI2VuZGlmCgogIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgIGNvbG9yLmEgKj0gb3BhY2l0eTsKICB9CgojaWZkZWYgVEVYVFVSRQogIGlmKGZsYWdCYWNrZ3JvdW5kID4gMC4wKSB7CiAgICB2ZWMzIHRleENvb3JkID0gdlRleHR1cmVDb29yZDsKCiAgICBpZih0ZXhDb29yZC56ID09IDEuMCkgewogICAgICB0ZXhDb29yZCA9IGZyYWN0KHRleENvb3JkKTsKICAgIH0KCiAgICBpZih0ZXhDb29yZC54IDw9IDEuMCAmJiB0ZXhDb29yZC54ID49IDAuMAogICAgICAmJiB0ZXhDb29yZC55IDw9IDEuMCAmJiB0ZXhDb29yZC55ID49IDAuMCkgewogICAgICBpZih2U291cmNlUmVjdC56ID4gMC4wKSB7CiAgICAgICAgdGV4Q29vcmQueCA9IHZTb3VyY2VSZWN0LnggKyB0ZXhDb29yZC54ICogdlNvdXJjZVJlY3QuejsKICAgICAgICB0ZXhDb29yZC55ID0gMS4wIC0gKHZTb3VyY2VSZWN0LnkgKyAoMS4wIC0gdGV4Q29vcmQueSkgKiB2U291cmNlUmVjdC53KTsKICAgICAgfQogICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgIGlmKG9wYWNpdHkgPCAxLjApIHsKICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICB9CiAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAvLyBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNvbG9yLmEpOwogICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgfQogIH0KI2VuZGlmCgojaWZkZWYgRklMVEVSCiAgaWYodV9maWx0ZXJGbGFnID4gMCkgewogICAgdHJhbnNmb3JtQ29sb3IoY29sb3IsIHVfY29sb3JNYXRyaXgpOwogIH0KI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7CnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CmF0dHJpYnV0ZSB2ZWMzIGFfdHJhbnNmb3JtMDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0xOwp1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOwp1bmlmb3JtIG1hdDMgdmlld01hdHJpeDsKdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7CgojaWZkZWYgVEVYVFVSRQphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CmF0dHJpYnV0ZSBmbG9hdCBhX2ZyYW1lSW5kZXg7CnZhcnlpbmcgZmxvYXQgZnJhbWVJbmRleDsKYXR0cmlidXRlIHZlYzQgYV9zb3VyY2VSZWN0Owp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICmF0dHJpYnV0ZSB2ZWMyIGFfY2xpcFVWOwp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMDsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMTsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkMzsKYXR0cmlidXRlIHZlYzQgYV9jb2xvckNsb3VkNDsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIENMT1VEQ09MT1IKYXR0cmlidXRlIHZlYzQgYV9maWxsQ2xvdWRDb2xvcjsKYXR0cmlidXRlIHZlYzQgYV9zdHJva2VDbG91ZENvbG9yOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICBtYXQzIG1vZGVsTWF0cml4ID0gbWF0MygKICAgIGFfdHJhbnNmb3JtMC54LCBhX3RyYW5zZm9ybTEueCwgMCwgCiAgICBhX3RyYW5zZm9ybTAueSwgYV90cmFuc2Zvcm0xLnksIDAsCiAgICBhX3RyYW5zZm9ybTAueiwgYV90cmFuc2Zvcm0xLnosIDEKICApOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWMzKGFfdmVydGV4UG9zaXRpb24ueHksIDEuMCk7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgMS4wLCAxLjApOwoKI2lmZGVmIEdSQURJRU5UCiAgdmVjMyB2ZzEgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzBdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzFdLCAxLjApOwogIHZlYzMgdmcyID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclszXSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls0XSwgMS4wKTsKICBmbG9hdCBoID0gdV9yZXNvbHV0aW9uLnk7CiAgdmcxLnkgPSBoIC0gdmcxLnk7CiAgdmcyLnkgPSBoIC0gdmcyLnk7CiAgdkdyYWRpZW50VmVjdG9yMSA9IHZlYzModmcxLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzJdKTsKICB2R3JhZGllbnRWZWN0b3IyID0gdmVjMyh2ZzIueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNV0pOwojZW5kaWYKICAKICBmbGFnQmFja2dyb3VuZCA9IGFfdmVydGV4UG9zaXRpb24uejsKCiNpZmRlZiBDTE9VRENPTE9SCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLCBhX2ZpbGxDbG91ZENvbG9yLmEpOwogIH0gZWxzZSB7CiAgICB2Q29sb3IgPSBtaXgoYV9jb2xvciwgYV9zdHJva2VDbG91ZENvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IuYSk7CiAgfQojZWxzZQogIHZDb2xvciA9IGFfY29sb3I7CiNlbmRpZgoKI2lmZGVmIFRFWFRVUkUKICB2VGV4dHVyZUNvb3JkID0gYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CiAgZnJhbWVJbmRleCA9IGFfZnJhbWVJbmRleDsKICB2U291cmNlUmVjdCA9IGFfc291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICB2Q2xpcFVWID0gYV9jbGlwVVY7CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgY29sb3JDbG91ZDAgPSBhX2NvbG9yQ2xvdWQwOwogIGNvbG9yQ2xvdWQxID0gYV9jb2xvckNsb3VkMTsKICBjb2xvckNsb3VkMiA9IGFfY29sb3JDbG91ZDI7CiAgY29sb3JDbG91ZDMgPSBhX2NvbG9yQ2xvdWQzOwogIGNvbG9yQ2xvdWQ0ID0gYV9jb2xvckNsb3VkNDsKI2VuZGlmCn1gfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4Owp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWM0IHZTb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAp2YXJ5aW5nIHZlYzIgdkNsaXBVVjsKI2VuZGlmCgojaWZkZWYgRklMVEVSCnVuaWZvcm0gaW50IHVfZmlsdGVyRmxhZzsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yTWF0cml4WzIwXTsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQwOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDE7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMjsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQzOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDQ7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKCnZvaWQgZ3JhZGllbnQoaW5vdXQgdmVjNCBjb2xvciwgdmVjMyBndjEsIHZlYzMgZ3YyLCBmbG9hdCBjb2xvclN0ZXBzWzQwXSkgewogIGZsb2F0IHQ7CiAgLy8gY2VudGVyIGNpcmNsZSByYWRpdXMKICBmbG9hdCBjciA9IGd2MS56OwogIC8vIGZvY2FsIGNpcmNsZSByYWRpdXMKICBmbG9hdCBmciA9IGd2Mi56OwoKICBpZihjciA+IDAuMCB8fCBmciA+IDAuMCkgewogICAgLy8gcmFkaWFsIGdyYWRpZW50CiAgICB2ZWMyIGNlbnRlciA9IGd2MS54eTsKICAgIHZlYzIgZm9jYWwgPSBndjIueHk7CiAgICBmbG9hdCB4ID0gZm9jYWwueCAtIGdsX0ZyYWdDb29yZC54OwogICAgZmxvYXQgeSA9IGZvY2FsLnkgLSBnbF9GcmFnQ29vcmQueTsKICAgIGZsb2F0IGR4ID0gZm9jYWwueCAtIGNlbnRlci54OwogICAgZmxvYXQgZHkgPSBmb2NhbC55IC0gY2VudGVyLnk7CiAgICBmbG9hdCBkciA9IGNyIC0gZnI7CiAgICBmbG9hdCBhID0gZHggKiBkeCArIGR5ICogZHkgLSBkciAqIGRyOwogICAgZmxvYXQgYiA9IC0yLjAgKiAoeSAqIGR5ICsgeCAqIGR4ICsgZnIgKiBkcik7CiAgICBmbG9hdCBjID0geCAqIHggKyB5ICogeSAtIGZyICogZnI7CiAgICB0ID0gMS4wIC0gMC41ICogKDEuMCAvIGEpICogKC1iICsgc3FydChiICogYiAtIDQuMCAqIGEgKiBjKSk7CiAgfSBlbHNlIHsKICAgIC8vIGxpbmVhciBncmFkaWVudAogICAgdmVjMiB2MSA9IGdsX0ZyYWdDb29yZC54eSAtIGd2MS54eTsKICAgIHZlYzIgdjIgPSBndjIueHkgLSBndjEueHk7CiAgICB0ID0gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYyLnggKiB2Mi54ICsgdjIueSAqIHYyLnkpOwogIH0KCiAgdmVjNCBjb2xvcnNbOF07CiAgY29sb3JzWzBdID0gdmVjNChjb2xvclN0ZXBzWzFdLCBjb2xvclN0ZXBzWzJdLCBjb2xvclN0ZXBzWzNdLCBjb2xvclN0ZXBzWzRdKTsKICBjb2xvcnNbMV0gPSB2ZWM0KGNvbG9yU3RlcHNbNl0sIGNvbG9yU3RlcHNbN10sIGNvbG9yU3RlcHNbOF0sIGNvbG9yU3RlcHNbOV0pOwogIGNvbG9yc1syXSA9IHZlYzQoY29sb3JTdGVwc1sxMV0sIGNvbG9yU3RlcHNbMTJdLCBjb2xvclN0ZXBzWzEzXSwgY29sb3JTdGVwc1sxNF0pOwogIGNvbG9yc1szXSA9IHZlYzQoY29sb3JTdGVwc1sxNl0sIGNvbG9yU3RlcHNbMTddLCBjb2xvclN0ZXBzWzE4XSwgY29sb3JTdGVwc1sxOV0pOwogIGNvbG9yc1s0XSA9IHZlYzQoY29sb3JTdGVwc1syMV0sIGNvbG9yU3RlcHNbMjJdLCBjb2xvclN0ZXBzWzIzXSwgY29sb3JTdGVwc1syNF0pOwogIGNvbG9yc1s1XSA9IHZlYzQoY29sb3JTdGVwc1syNl0sIGNvbG9yU3RlcHNbMjddLCBjb2xvclN0ZXBzWzI4XSwgY29sb3JTdGVwc1syOV0pOwogIGNvbG9yc1s2XSA9IHZlYzQoY29sb3JTdGVwc1szMV0sIGNvbG9yU3RlcHNbMzJdLCBjb2xvclN0ZXBzWzMzXSwgY29sb3JTdGVwc1szNF0pOwogIGNvbG9yc1s3XSA9IHZlYzQoY29sb3JTdGVwc1szNl0sIGNvbG9yU3RlcHNbMzddLCBjb2xvclN0ZXBzWzM4XSwgY29sb3JTdGVwc1szOV0pOwogIAogIGZsb2F0IHN0ZXBzWzhdOwogIHN0ZXBzWzBdID0gY29sb3JTdGVwc1swXTsKICBzdGVwc1sxXSA9IGNvbG9yU3RlcHNbNV07CiAgc3RlcHNbMl0gPSBjb2xvclN0ZXBzWzEwXTsKICBzdGVwc1szXSA9IGNvbG9yU3RlcHNbMTVdOwogIHN0ZXBzWzRdID0gY29sb3JTdGVwc1syMF07CiAgc3RlcHNbNV0gPSBjb2xvclN0ZXBzWzI1XTsKICBzdGVwc1s2XSA9IGNvbG9yU3RlcHNbMzBdOwogIHN0ZXBzWzddID0gY29sb3JTdGVwc1szNV07CgogIGNvbG9yID0gY29sb3JzWzBdOwogIGZvciAoaW50IGkgPSAxOyBpIDwgODsgaSsrKSB7CiAgICBpZiAoc3RlcHNbaV0gPCAwLjAgfHwgc3RlcHNbaV0gPiAxLjApIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBpZihzdGVwc1tpXSA9PSBzdGVwc1tpIC0gMV0pIHsKICAgICAgY29sb3IgPSBjb2xvcnNbaV07CiAgICB9IGVsc2UgewogICAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3JzW2ldLCBjbGFtcCgodCAtIHN0ZXBzW2kgLSAxXSkgLyAoc3RlcHNbaV0gLSBzdGVwc1tpIC0gMV0pLCAwLjAsIDEuMCkpOwogICAgfQogICAgaWYgKHN0ZXBzW2ldID49IHQpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQp9CiNlbmRpZgoKdm9pZCB0cmFuc2Zvcm1Db2xvcihpbm91dCB2ZWM0IGNvbG9yLCBpbiBmbG9hdCBjb2xvck1hdHJpeFsyMF0pIHsKICBmbG9hdCByID0gY29sb3IuciwgZyA9IGNvbG9yLmcsIGIgPSBjb2xvci5iLCBhID0gY29sb3IuYTsKICBjb2xvclswXSA9IGNvbG9yTWF0cml4WzBdICogciArIGNvbG9yTWF0cml4WzFdICogZyArIGNvbG9yTWF0cml4WzJdICogYiArIGNvbG9yTWF0cml4WzNdICogYSArIGNvbG9yTWF0cml4WzRdOwogIGNvbG9yWzFdID0gY29sb3JNYXRyaXhbNV0gKiByICsgY29sb3JNYXRyaXhbNl0gKiBnICsgY29sb3JNYXRyaXhbN10gKiBiICsgY29sb3JNYXRyaXhbOF0gKiBhICsgY29sb3JNYXRyaXhbOV07CiAgY29sb3JbMl0gPSBjb2xvck1hdHJpeFsxMF0gKiByICsgY29sb3JNYXRyaXhbMTFdICogZyArIGNvbG9yTWF0cml4WzEyXSAqIGIgKyBjb2xvck1hdHJpeFsxM10gKiBhICsgY29sb3JNYXRyaXhbMTRdOwogIGNvbG9yWzNdID0gY29sb3JNYXRyaXhbMTVdICogciArIGNvbG9yTWF0cml4WzE2XSAqIGcgKyBjb2xvck1hdHJpeFsxN10gKiBiICsgY29sb3JNYXRyaXhbMThdICogYSArIGNvbG9yTWF0cml4WzE5XTsKfQoKI2lmZGVmIENMT1VERklMVEVSCnZvaWQgYnVpbGRDbG91ZENvbG9yKGlub3V0IGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdKSB7CiAgY29sb3JDbG91ZE1hdHJpeFswXSA9IGNvbG9yQ2xvdWQwWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMV0gPSBjb2xvckNsb3VkMVswXTsKICBjb2xvckNsb3VkTWF0cml4WzJdID0gY29sb3JDbG91ZDJbMF07CiAgY29sb3JDbG91ZE1hdHJpeFszXSA9IGNvbG9yQ2xvdWQzWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNF0gPSBjb2xvckNsb3VkNFswXTsKCiAgY29sb3JDbG91ZE1hdHJpeFs1XSA9IGNvbG9yQ2xvdWQwWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbNl0gPSBjb2xvckNsb3VkMVsxXTsKICBjb2xvckNsb3VkTWF0cml4WzddID0gY29sb3JDbG91ZDJbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs4XSA9IGNvbG9yQ2xvdWQzWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbOV0gPSBjb2xvckNsb3VkNFsxXTsKCiAgY29sb3JDbG91ZE1hdHJpeFsxMF0gPSBjb2xvckNsb3VkMFsyXTsKICBjb2xvckNsb3VkTWF0cml4WzExXSA9IGNvbG9yQ2xvdWQxWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTJdID0gY29sb3JDbG91ZDJbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxM10gPSBjb2xvckNsb3VkM1syXTsKICBjb2xvckNsb3VkTWF0cml4WzE0XSA9IGNvbG9yQ2xvdWQ0WzJdOwoKICBjb2xvckNsb3VkTWF0cml4WzE1XSA9IGNvbG9yQ2xvdWQwWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTZdID0gY29sb3JDbG91ZDFbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxN10gPSBjb2xvckNsb3VkMlszXTsKICBjb2xvckNsb3VkTWF0cml4WzE4XSA9IGNvbG9yQ2xvdWQzWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTldID0gY29sb3JDbG91ZDRbM107Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIGlmKGZyYW1lSW5kZXggPCAwLjApIHsKICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4U2FtcGxlciwgdGV4Q29vcmQueHkpOwogICAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW50IGluZGV4ID0gaW50KGZsb29yKGNsYW1wKDAuMCwgMTEuMCwgZnJhbWVJbmRleCkpKTsKICAgICAgICB2ZWM0IHRleENvbG9yOwogICAgICAgIGlmKGluZGV4ID09IDApIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTIsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDMpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUzLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA0KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTUsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDYpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU2LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA3KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNywgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTgsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDkpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU5LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAxMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTEwLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTEsIHRleENvb3JkLnh5KTsKICAgICAgICBmbG9hdCBhbHBoYSA9IHRleENvbG9yLmE7CiAgICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgICAgdGV4Q29sb3IuYSAqPSBvcGFjaXR5OwogICAgICAgICAgYWxwaGEgKj0gbWl4KDAuNDY1LCAxLjAsIG9wYWNpdHkpOwogICAgICAgIH0KICAgICAgICAvLyBjb2xvciA9IG1peChjb2xvciwgdGV4Q29sb3IsIHRleENvbG9yLmEpOwogICAgICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHRleENvbG9yLnJnYiwgYWxwaGEpOwogICAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjbGFtcChjb2xvci5hIC8gbWF4KDAuMDAwMSwgdGV4Q29sb3IuYSksIDAuMCwgMS4wKSk7CiAgICAgICAgY29sb3IuYSA9IHRleENvbG9yLmEgKyAoMS4wIC0gdGV4Q29sb3IuYSkgKiBjb2xvci5hOwogICAgICB9CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgogIGZsb2F0IGNvbG9yQ2xvdWRNYXRyaXhbMjBdOwogIGJ1aWxkQ2xvdWRDb2xvcihjb2xvckNsb3VkTWF0cml4KTsKICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgY29sb3JDbG91ZE1hdHJpeCk7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICiAgZmxvYXQgY2xpcCA9IHRleHR1cmUyRCh1X2NsaXBTYW1wbGVyLCB2Q2xpcFVWKS5yOwogIGNvbG9yICo9IGNsaXA7CiNlbmRpZgoKICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsKfWB9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKHIscyl7dC5kKGUsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBtKCl7aWYodHlwZW9mIHBlcmZvcm1hbmNlPCJ1IiYmcGVyZm9ybWFuY2Uubm93KXJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtpZih0eXBlb2YgcjwidSImJnIuaHJ0aW1lKXtjb25zdFtsLHVdPXIuaHJ0aW1lKCk7cmV0dXJuIGwqMWUzK3UqMWUtNn1yZXR1cm4gRGF0ZS5ub3c/RGF0ZS5ub3coKTpuZXcgRGF0ZSgpLmdldFRpbWUoKX1sZXQgeSxjO3R5cGVvZiBzPCJ1IiYmdHlwZW9mIHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lPT0iZnVuY3Rpb24iPyh5PXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lLGM9cy5jYW5jZWxBbmltYXRpb25GcmFtZSk6KHk9ZnVuY3Rpb24obCl7cmV0dXJuIHNldFRpbWVvdXQoKCk9PntsKG0oKSl9LDE2KX0sYz1mdW5jdGlvbihsKXtyZXR1cm4gY2xlYXJUaW1lb3V0KGwpfSl9KS5jYWxsKHRoaXMsdCg2OSksdCgyMikpfSxmdW5jdGlvbihoLGUpe3ZhciB0PWguZXhwb3J0cz17fSxyLHM7ZnVuY3Rpb24gbSgpe3Rocm93IG5ldyBFcnJvcigic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfWZ1bmN0aW9uIHkoKXt0aHJvdyBuZXcgRXJyb3IoImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfShmdW5jdGlvbigpe3RyeXt0eXBlb2Ygc2V0VGltZW91dD09ImZ1bmN0aW9uIj9yPXNldFRpbWVvdXQ6cj1tfWNhdGNoe3I9bX10cnl7dHlwZW9mIGNsZWFyVGltZW91dD09ImZ1bmN0aW9uIj9zPWNsZWFyVGltZW91dDpzPXl9Y2F0Y2h7cz15fX0pKCk7ZnVuY3Rpb24gYyhwKXtpZihyPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dChwLDApO2lmKChyPT09bXx8IXIpJiZzZXRUaW1lb3V0KXJldHVybiByPXNldFRpbWVvdXQsc2V0VGltZW91dChwLDApO3RyeXtyZXR1cm4gcihwLDApfWNhdGNoe3RyeXtyZXR1cm4gci5jYWxsKG51bGwscCwwKX1jYXRjaHtyZXR1cm4gci5jYWxsKHRoaXMscCwwKX19fWZ1bmN0aW9uIGwocCl7aWYocz09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KHApO2lmKChzPT09eXx8IXMpJiZjbGVhclRpbWVvdXQpcmV0dXJuIHM9Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChwKTt0cnl7cmV0dXJuIHMocCl9Y2F0Y2h7dHJ5e3JldHVybiBzLmNhbGwobnVsbCxwKX1jYXRjaHtyZXR1cm4gcy5jYWxsKHRoaXMscCl9fX12YXIgdT1bXSxNPSExLGYsdj0tMTtmdW5jdGlvbiB4KCl7IU18fCFmfHwoTT0hMSxmLmxlbmd0aD91PWYuY29uY2F0KHUpOnY9LTEsdS5sZW5ndGgmJlIoKSl9ZnVuY3Rpb24gUigpe2lmKCFNKXt2YXIgcD1jKHgpO009ITA7Zm9yKHZhciBuPXUubGVuZ3RoO247KXtmb3IoZj11LHU9W107Kyt2PG47KWYmJmZbdl0ucnVuKCk7dj0tMSxuPXUubGVuZ3RofWY9bnVsbCxNPSExLGwocCl9fXQubmV4dFRpY2s9ZnVuY3Rpb24ocCl7dmFyIG49bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgYT0xO2E8YXJndW1lbnRzLmxlbmd0aDthKyspblthLTFdPWFyZ3VtZW50c1thXTt1LnB1c2gobmV3IE8ocCxuKSksdS5sZW5ndGg9PT0xJiYhTSYmYyhSKX07ZnVuY3Rpb24gTyhwLG4pe3RoaXMuZnVuPXAsdGhpcy5hcnJheT1ufU8ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LHQudGl0bGU9ImJyb3dzZXIiLHQuYnJvd3Nlcj0hMCx0LmVudj17fSx0LmFyZ3Y9W10sdC52ZXJzaW9uPSIiLHQudmVyc2lvbnM9e307ZnVuY3Rpb24gZygpe310Lm9uPWcsdC5hZGRMaXN0ZW5lcj1nLHQub25jZT1nLHQub2ZmPWcsdC5yZW1vdmVMaXN0ZW5lcj1nLHQucmVtb3ZlQWxsTGlzdGVuZXJzPWcsdC5lbWl0PWcsdC5wcmVwZW5kTGlzdGVuZXI9Zyx0LnByZXBlbmRPbmNlTGlzdGVuZXI9Zyx0Lmxpc3RlbmVycz1mdW5jdGlvbihwKXtyZXR1cm5bXX0sdC5iaW5kaW5nPWZ1bmN0aW9uKHApe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm4iLyJ9LHQuY2hkaXI9ZnVuY3Rpb24ocCl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQiKX0sdC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pO3ZhciByPXQoMSkscz10KDcxKSxtPXQoNzMpLHk9dCgyMTMpLGM9dCgyMTQpLGw9dCgyMTUpLHU9dCgyMTYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBNKEksUCl7dmFyIEw9T2JqZWN0LmtleXMoSSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhJKTtQJiYoRD1ELmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihJLGIpLmVudW1lcmFibGV9KSksTC5wdXNoLmFwcGx5KEwsRCl9cmV0dXJuIEx9ZnVuY3Rpb24gZihJKXtmb3IodmFyIFA9MTtQPGFyZ3VtZW50cy5sZW5ndGg7UCsrKXt2YXIgTD1hcmd1bWVudHNbUF0hPW51bGw/YXJndW1lbnRzW1BdOnt9O1AlMj9NKE9iamVjdChMKSwhMCkuZm9yRWFjaChmdW5jdGlvbihEKXt2KEksRCxMW0RdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEksT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoTCkpOk0oT2JqZWN0KEwpKS5mb3JFYWNoKGZ1bmN0aW9uKEQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLEQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihMLEQpKX0pfXJldHVybiBJfWZ1bmN0aW9uIHYoSSxQLEwpe3JldHVybiBQIGluIEk/T2JqZWN0LmRlZmluZVByb3BlcnR5KEksUCx7dmFsdWU6TCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOklbUF09TCxJfWNvbnN0IHg9U3ltYm9sLmZvcigic3ByaXRlanNfY2hhbmdlZEF0dHJzIiksUj1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIiksTz1TeW1ib2woInJlc29sdXRpb24iKSxnPVN5bWJvbCgiYW5pbWF0aW9ucyIpLHA9U3ltYm9sKCJldmVudExpc3RlbmVycyIpLG49U3ltYm9sKCJjYXB0dXJlRXZlbnRMaXN0ZW5lcnMiKSxhPVN5bWJvbCgiZmlsdGVycyIpLGk9U3ltYm9sKCJkaXNwbGF5Iiksbz1TeW1ib2woInByb2dyYW0iKSxUPVN5bWJvbCgic2hhZGVyQXR0cnMiKSxBPVN5bWJvbCgidW5pZm9ybXMiKTtjbGFzcyBDe2NvbnN0cnVjdG9yKFA9e30pe3RoaXMuYXR0cmlidXRlcz1uZXcgdGhpcy5jb25zdHJ1Y3Rvci5BdHRyKHRoaXMpLHRoaXNbT109e3dpZHRoOjMwMCxoZWlnaHQ6MTUwfSxPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxQKSx0aGlzW2ddPW5ldyBTZXQsdGhpc1twXT17fSx0aGlzW25dPXt9fWdldCBhbmNlc3RvcnMoKXtsZXQgUD10aGlzLnBhcmVudDtjb25zdCBMPVtdO2Zvcig7UDspTC5wdXNoKFApLFA9UC5wYXJlbnQ7cmV0dXJuIEx9Z2V0IGFuaW1hdGlvbnMoKXtyZXR1cm4gdGhpc1tnXX1nZXQgZmlsdGVycygpe3JldHVybiB0aGlzW2FdfHx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZmlsdGVyc31nZXQgaXNWaXNpYmxlKCl7cmV0dXJuITF9Z2V0IGxheWVyKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50LmxheWVyOm51bGx9Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3QgUD10aGlzLnRyYW5zZm9ybU1hdHJpeCx7eDpMLHk6RH09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBQWzRdKz1MLFBbNV0rPUQsUH1nZXQgb3BhY2l0eSgpe2xldCBQPXRoaXMuYXR0cmlidXRlcy5vcGFjaXR5O3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3BhY2l0eSE9bnVsbCYmKFAqPXRoaXMucGFyZW50Lm9wYWNpdHkpLFB9Z2V0IHBhcmVudE5vZGUoKXtyZXR1cm4gdGhpcy5wYXJlbnR9Z2V0IG5leHRTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgxKX1nZXQgcHJldmlvdXNTaWJsaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZU5lYXJCeSgtMSl9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1tvXX1nZXQgcmVuZGVyZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQucmVuZGVyZXI6bnVsbH1nZXQgcmVuZGVyTWF0cml4KCl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4KXJldHVybiB0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg7bGV0IFA9dGhpcy5sb2NhbE1hdHJpeDtjb25zdCBMPXRoaXMucGFyZW50O2lmKEwpe2NvbnN0IEQ9TC5fX2NhY2hlUmVuZGVyTWF0cml4fHxMLnJlbmRlck1hdHJpeDtEJiYoUD1yLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELFApKX1yZXR1cm4gUH1nZXQgd29ybGRTY2FsaW5nKCl7Y29uc3QgUD10aGlzLnJlbmRlck1hdHJpeDtyZXR1cm5bTWF0aC5oeXBvdChQWzBdLFBbMV0pLE1hdGguaHlwb3QoUFsyXSxQWzNdKV19Z2V0IHdvcmxkUm90YXRpb24oKXtjb25zdCBQPXRoaXMucmVuZGVyTWF0cml4O3JldHVybiBNYXRoLmF0YW4yKFBbMV0sUFszXSl9Z2V0IHdvcmxkUG9zaXRpb24oKXtjb25zdCBQPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltQWzRdLFBbNV1dfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW0FdfWdldCBjbGFzc05hbWUoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZX1zZXQgY2xhc3NOYW1lKFApe3RoaXMuYXR0cmlidXRlcy5jbGFzc05hbWU9UH1nZXQgaWQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmlkfXNldCBpZChQKXt0aGlzLmF0dHJpYnV0ZXMuaWQ9UH1nZXQgbmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMubmFtZX1zZXQgbmFtZShQKXt0aGlzLmF0dHJpYnV0ZXMubmFtZT1QfWdldCB6SW5kZXgoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnpJbmRleH1zZXQgekluZGV4KFApe3RoaXMuYXR0cmlidXRlcy56SW5kZXg9UH1nZXQgbWVzaCgpe3JldHVybiBudWxsfWdldCBzaGFkZXJBdHRycygpe3JldHVybiB0aGlzW1RdfHx7fX1hY3RpdmF0ZUFuaW1hdGlvbnMoKXtjb25zdCBQPXRoaXMubGF5ZXI7aWYoUCl7Y29uc3QgTD10aGlzW2ddO0wuZm9yRWFjaChiPT57Yi5iYXNlVGltZWxpbmU9UC50aW1lbGluZSxiLnBsYXkoKSxiLmZpbmlzaGVkLnRoZW4oKCk9PntMLmRlbGV0ZShiKX0pfSk7Y29uc3QgRD10aGlzLmNoaWxkcmVuO0QmJkQuZm9yRWFjaChiPT57Yi5hY3RpdmF0ZUFuaW1hdGlvbnMmJmIuYWN0aXZhdGVBbmltYXRpb25zKCl9KX19YWRkRXZlbnRMaXN0ZW5lcihQLEwsRD17fSl7UD09PSJtb3VzZXdoZWVsIiYmKFA9IndoZWVsIiksdHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0e2NhcHR1cmU6YixvbmNlOlN9PUQsQj1iP246cDtyZXR1cm4gdGhpc1tCXVtQXT10aGlzW0JdW1BdfHxbXSx0aGlzW0JdW1BdLnB1c2goe2xpc3RlbmVyOkwsb25jZTpTfSksdGhpc31hbmltYXRlKFAsTCl7Y29uc3QgRD1uZXcgbS5kZWZhdWx0KHRoaXMsUCxMKTtyZXR1cm4gdGhpcy5lZmZlY3RzJiZELmFwcGx5RWZmZWN0cyh0aGlzLmVmZmVjdHMpLHRoaXMubGF5ZXImJihELmJhc2VUaW1lbGluZT10aGlzLmxheWVyLnRpbWVsaW5lLEQucGxheSgpLEQuZmluaXNoZWQudGhlbigoKT0+e3RoaXNbZ10uZGVsZXRlKEQpfSkpLHRoaXNbZ10uYWRkKEQpLER9YXR0ciguLi5QKXtpZihQLmxlbmd0aD09PTApcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tSXTtpZihQLmxlbmd0aD4xKXtsZXRbTCxEXT1QO3JldHVybiB0eXBlb2YgRD09ImZ1bmN0aW9uIiYmKEQ9RCh0aGlzLmF0dHIoTCkpKSx0aGlzLnNldEF0dHJpYnV0ZShMLEQpLHRoaXN9cmV0dXJuIHR5cGVvZiBQWzBdPT0ic3RyaW5nIj90aGlzLmdldEF0dHJpYnV0ZShQWzBdKTooT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsUFswXSksdGhpcyl9Y2xvbmVOb2RlKCl7Y29uc3QgUD1uZXcgdGhpcy5jb25zdHJ1Y3RvcixMPXRoaXMuYXR0cmlidXRlc1t4XTtyZXR1cm4gUC5hdHRyKEwpLFB9Y29ubmVjdChQLEwpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYXJlbnQiLHt2YWx1ZTpQLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6T3JkZXIiLHt2YWx1ZTpMLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLFAudGltZWxpbmUmJnRoaXMuYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5zZXRSZXNvbHV0aW9uKFAuZ2V0UmVzb2x1dGlvbigpKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhcHBlbmQiLGRldGFpbDp7cGFyZW50OlAsek9yZGVyOkx9fSl9Y29udGFpbnMoUCl7Zm9yKDtQJiZ0aGlzIT09UDspUD1QLnBhcmVudDtyZXR1cm4hIVB9ZGVhY3RpdmF0ZUFuaW1hdGlvbnMoKXt0aGlzW2ddLmZvckVhY2goTD0+TC5jYW5jZWwoKSk7Y29uc3QgUD10aGlzLmNoaWxkcmVuO1AmJlAuZm9yRWFjaChMPT57TC5kZWFjdGl2YXRlQW5pbWF0aW9ucyYmTC5kZWFjdGl2YXRlQW5pbWF0aW9ucygpfSl9ZGlzY29ubmVjdCgpe2NvbnN0e3BhcmVudDpQLHpPcmRlcjpMfT10aGlzO2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXIsdGhpcy5kZWFjdGl2YXRlQW5pbWF0aW9ucygpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVtb3ZlIixkZXRhaWw6e3BhcmVudDpQLHpPcmRlcjpMfX0pLFAmJlAuZm9yY2VVcGRhdGUoKX1kaXNwYXRjaEV2ZW50KFApe1AgaW5zdGFuY2VvZiBjLmRlZmF1bHR8fChQPW5ldyBjLmRlZmF1bHQoUCkpLFAudGFyZ2V0PXRoaXM7bGV0IEw9UC50eXBlO0w9PT0ibW91c2V3aGVlbCImJihMPSJ3aGVlbCIpO2NvbnN0IEQ9W3RoaXNdO2xldCBiPXRoaXMucGFyZW50O2Zvcig7UC5idWJibGVzJiZiOylELnB1c2goYiksYj1iLnBhcmVudDtmb3IobGV0IFM9RC5sZW5ndGgtMTtTPj0wO1MtLSl7Y29uc3QgQj1EW1NdLHc9QltuXSYmQltuXVtMXTtpZih3JiZ3Lmxlbmd0aCYmKFAuY3VycmVudFRhcmdldD1CLHcuZm9yRWFjaCgoe2xpc3RlbmVyOkgsb25jZTpKfSk9PntILmNhbGwodGhpcyxQKSxKJiZELnJlbW92ZUV2ZW50TGlzdGVuZXIoSCl9KSxkZWxldGUgUC5jdXJyZW50VGFyZ2V0KSwhUC5idWJibGVzJiZQLmNhbmNlbEJ1YmJsZSlicmVha31pZighUC5jYW5jZWxCdWJibGUpZm9yKGxldCBTPTA7UzxELmxlbmd0aDtTKyspe2NvbnN0IEI9RFtTXSx3PUJbcF0mJkJbcF1bTF07aWYodyYmdy5sZW5ndGgmJihQLmN1cnJlbnRUYXJnZXQ9Qix3LmZvckVhY2goKHtsaXN0ZW5lcjpILG9uY2U6Sn0pPT57SC5jYWxsKHRoaXMsUCksSiYmRC5yZW1vdmVFdmVudExpc3RlbmVyKEgpfSksZGVsZXRlIFAuY3VycmVudFRhcmdldCksIVAuYnViYmxlc3x8UC5jYW5jZWxCdWJibGUpYnJlYWt9fWRpc3BhdGNoUG9pbnRlckV2ZW50KFApe2NvbnN0e2xheWVyWDpMLGxheWVyWTpEfT1QO3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oTCxEKT8odGhpcy5kaXNwYXRjaEV2ZW50KFApLCEwKTohMX1kcmF3KFA9W10pe2NvbnN0IEw9dGhpcy5tZXNoO2lmKEwpe2lmKE9iamVjdChsLmFwcGx5RmlsdGVycykoTCx0aGlzLmZpbHRlcnMpLFAucHVzaChMKSx0aGlzW29dKXtMLnNldFByb2dyYW0odGhpc1tvXSk7Y29uc3QgRD10aGlzW1RdO0QmJk9iamVjdC5lbnRyaWVzKEQpLmZvckVhY2goKFtTLEJdKT0+e0wuc2V0QXR0cmlidXRlKFMsQil9KTtjb25zdCBiPXRoaXNbQV07aWYodGhpc1tBXSl7Y29uc3QgUz17fTtPYmplY3QuZW50cmllcyhiKS5mb3JFYWNoKChbQix3XSk9Pnt0eXBlb2Ygdz09ImZ1bmN0aW9uIiYmKHc9dyh0aGlzLEIpKSxTW0JdPXd9KSxMLnNldFVuaWZvcm1zKFMpfX1PYmplY3QodS5kZWZhdWx0KSh0aGlzLEwpfXJldHVybiBQfWZvcmNlVXBkYXRlKCl7dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmZvcmNlVXBkYXRlKCl9Z2V0QXR0cmlidXRlKFApe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbUF19Z2V0TGlzdGVuZXJzKFAse2NhcHR1cmU6TD0hMX09e30pe3JldHVyblsuLi50aGlzW0w/bjpwXVtQXXx8W11dfWdldE5vZGVOZWFyQnkoUD0xKXtpZighdGhpcy5wYXJlbnQpcmV0dXJuIG51bGw7aWYoUD09PTApcmV0dXJuIHRoaXM7Y29uc3QgTD10aGlzLnBhcmVudC5jaGlsZHJlbixEPUwuaW5kZXhPZih0aGlzKTtyZXR1cm4gTFtEK1BdfWdldFdvcmxkUG9zaXRpb24oUCxMKXtjb25zdCBEPXRoaXMucmVuZGVyTWF0cml4LGI9UCpEWzBdK0wqRFsyXStEWzRdLFM9UCpEWzFdK0wqRFszXStEWzVdO3JldHVybltiLFNdfWdldE9mZnNldFBvc2l0aW9uKFAsTCl7Y29uc3QgRD1yLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpcy5yZW5kZXJNYXRyaXgpLGI9UCpEWzBdK0wqRFsyXStEWzRdLFM9UCpEWzFdK0wqRFszXStEWzVdO3JldHVybltiLFNdfWdldFJlc29sdXRpb24oKXtyZXR1cm4gZih7fSx0aGlzW09dKX1pc1BvaW50Q29sbGlzaW9uKFAsTCl7aWYoIXRoaXMubWVzaClyZXR1cm4hMTtjb25zdCBEPXRoaXMuYXR0cmlidXRlcy5wb2ludGVyRXZlbnRzO2lmKEQ9PT0ibm9uZSJ8fEQhPT0iYWxsIiYmIXRoaXMuaXNWaXNpYmxlKXJldHVybiExO2xldCBiPSJib3RoIjtyZXR1cm4gRD09PSJ2aXNpYmxlRmlsbCImJihiPSJmaWxsIiksRD09PSJ2aXNpYmxlU3Ryb2tlIiYmKGI9InN0cm9rZSIpLHRoaXMubWVzaC5pc1BvaW50Q29sbGlzaW9uKFAsTCxiKX1vblByb3BlcnR5Q2hhbmdlKFAsTCxEKXtQIT09ImlkIiYmUCE9PSJuYW1lIiYmUCE9PSJjbGFzc05hbWUiJiZQIT09InBvaW50ZXJFdmVudHMiJiZQIT09InBhc3NFdmVudHMiJiZ0aGlzLmZvcmNlVXBkYXRlKCksUD09PSJmaWx0ZXIiJiYodGhpc1thXT1PYmplY3QobC5wYXJzZUZpbHRlclN0cmluZykoTCkpLFA9PT0iekluZGV4IiYmdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlb3JkZXIoKX1zZXRBdHRyaWJ1dGUoUCxMKXtQPT09ImF0dHJzIiYmdGhpcy5hdHRyKEwpLHRoaXMuYXR0cmlidXRlc1tQXT1MfXNldE1vdXNlQ2FwdHVyZSgpe3RoaXMubGF5ZXImJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD10aGlzKX1zZXRQcm9ncmFtKFApe3RoaXNbb109UCx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0U2hhZGVyQXR0cmlidXRlKFAsTCl7dGhpc1tUXT10aGlzW1RdfHx7fSx0aGlzW1RdW1BdPUwsdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFVuaWZvcm1zKFApe3RoaXNbQV09dGhpc1tBXXx8e30sT2JqZWN0LmFzc2lnbih0aGlzW0FdLFApLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpQLGhlaWdodDpMfSl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Yn09dGhpc1tPXTsoRCE9PVB8fGIhPT1MKSYmKHRoaXNbT109e3dpZHRoOlAsaGVpZ2h0Okx9LHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc29sdXRpb25jaGFuZ2UiLGRldGFpbDp7d2lkdGg6UCxoZWlnaHQ6TH19KSl9c2hvdygpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiJiYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9dGhpc1tpXXx8IiIpfWhpZGUoKXt0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSE9PSJub25lIiYmKHRoaXNbaV09dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXksdGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9Im5vbmUiKX1yZWxlYXNlTW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmdGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9PT10aGlzJiYodGhpcy5sYXllci5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbCl9cmVtb3ZlKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZD8odGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksITApOiExfXJlbW92ZUFsbExpc3RlbmVycyhQLEw9e30pe3R5cGVvZiBMPT0iYm9vbGVhbiImJihMPXtjYXB0dXJlOkx9KTtjb25zdCBiPUwuY2FwdHVyZT9uOnA7cmV0dXJuIHRoaXNbYl1bUF0mJih0aGlzW2JdW1BdPVtdKSx0aGlzfXJlbW92ZUF0dHJpYnV0ZShQKXt0aGlzLnNldEF0dHJpYnV0ZShQLG51bGwpfXJlbW92ZUV2ZW50TGlzdGVuZXIoUCxMLEQ9e30pe3R5cGVvZiBEPT0iYm9vbGVhbiImJihEPXtjYXB0dXJlOkR9KTtjb25zdCBTPUQuY2FwdHVyZT9uOnA7aWYodGhpc1tTXVtQXSl7Y29uc3QgQj10aGlzW1NdW1BdO2lmKEIpZm9yKGxldCB3PTA7dzxCLmxlbmd0aDt3Kyspe2NvbnN0e2xpc3RlbmVyOkh9PUJbd107aWYoSD09PUwpe3RoaXNbU11bUF0uc3BsaWNlKHcsMSk7YnJlYWt9fX1yZXR1cm4gdGhpc310cmFuc2l0aW9uKFAsTD0ibGluZWFyIil7Y29uc3QgRD10aGlzLGI9U3ltYm9sKCJhbmltYXRpb24iKTtMPUx8fCJsaW5lYXIiO2xldCBTPTA7cmV0dXJuIHR5cGVvZiBQPT0ib2JqZWN0IiYmKFM9UC5kZWxheXx8MCxQPVAuZHVyYXRpb24pLHtbYl06bnVsbCxjYW5jZWwoQj0hMSl7Y29uc3Qgdz10aGlzW2JdO3cmJncuY2FuY2VsKEIpfSxlbmQoKXtjb25zdCBCPXRoaXNbYl07QiYmKEIucGxheVN0YXRlPT09InJ1bm5pbmcifHxCLnBsYXlTdGF0ZT09PSJwZW5kaW5nIikmJkIuZmluaXNoKCl9LHJldmVyc2UoKXtjb25zdCBCPXRoaXNbYl07aWYoQilpZihCLnBsYXlTdGF0ZT09PSJydW5uaW5nInx8Qi5wbGF5U3RhdGU9PT0icGVuZGluZyIpQi5wbGF5YmFja1JhdGU9LUIucGxheWJhY2tSYXRlO2Vsc2V7Y29uc3Qgdz1CLnRpbWluZy5kaXJlY3Rpb247Qi50aW1pbmcuZGlyZWN0aW9uPXc9PT0icmV2ZXJzZSI/Im5vcm1hbCI6InJldmVyc2UiLEIucGxheSgpfXJldHVybiBCLmZpbmlzaGVkfSxhdHRyKEIsdyl7cmV0dXJuIHRoaXMuZW5kKCksdHlwZW9mIEI9PSJzdHJpbmciJiYoQj17W0JdOnd9KSxPYmplY3QuZW50cmllcyhCKS5mb3JFYWNoKChbSCxKXSk9Pnt0eXBlb2YgSj09ImZ1bmN0aW9uIiYmKEJbSF09SihELmF0dHIoSCkpKX0pLHRoaXNbYl09RC5hbmltYXRlKFtCXSx7ZHVyYXRpb246UCoxZTMsZGVsYXk6UyoxZTMsZmlsbDoiZm9yd2FyZHMiLGVhc2luZzpMfSksdGhpc1tiXS5maW5pc2hlZH19fXVwZGF0ZUNvbnRvdXJzKCl7fX12KEMsIkF0dHIiLHMuZGVmYXVsdCkseS5kZWZhdWx0LnJlZ2lzdGVyTm9kZShDLCJub2RlIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KTt2YXIgcj10KDEpLHM9dCgxMiksbT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgeT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksTT1TeW1ib2wuZm9yKCJzcHJpdGVqc19hdHRyaWJ1dGVzIiksZj1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSx2PVN5bWJvbCgic3ViamVjdCIpLHg9U3ltYm9sKCJhdHRyIiksUj1TeW1ib2woImRlZmF1bHQiKSxPPVN5bWJvbCgiYWxpYXMiKTtmdW5jdGlvbiBnKEksW1AsTF0pe2xldCBEPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7cmV0dXJuWy4uLkldLmZvckVhY2goKFtiLFNdKT0+e2lmKChQfHxMKSYmKEQ9ci5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEQsW1AsTF0pKSxiPT09Im1hdHJpeCIpRD1yLm1hdDJkLm11bHRpcGx5KEQsRCxTKTtlbHNlIGlmKGI9PT0ib2Zmc2V0VHJhbnNsYXRlIilEWzRdKz1TWzBdLERbNV0rPVNbMV07ZWxzZSBpZihiPT09Im9mZnNldFJvdGF0ZSIpRD1yLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksRCxTKTtlbHNlIGlmKGI9PT0ic2tldyIpe2NvbnN0W0Isd109UztEPXIubWF0MmQubXVsdGlwbHkoRCxELHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKHcpLE1hdGgudGFuKEIpLDEsMCwwKSl9ZWxzZSByLm1hdDJkW2JdKEQsRCxTKTsoUHx8TCkmJihEPXIubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxELFstUCwtTF0pKX0pLER9Y29uc3QgcD1TeW1ib2woInRyYW5zZm9ybU1hdHJpeCIpLG49U3ltYm9sKCJ0cmFuc2Zvcm1zIiksYT1TeW1ib2woImNoYW5nZWRBdHRycyIpLGk9U3ltYm9sKCJsYXN0Q2hhbmdlZEF0dHIiKSxvPVN5bWJvbCgib2Zmc2V0RmlndXJlIik7ZnVuY3Rpb24gVChJLFAsTCl7Y29uc3QgRD1JW3hdW1BdO2lmKElbbF0oUCxMLCExKXx8SVtpXSE9PVApe2NvbnN0IFM9SVtuXTtTLmhhcyhQKSYmUy5kZWxldGUoUCksTCYmKFA9PT0icm90YXRlIiYmKEw9TWF0aC5QSSpMLzE4MCksUD09PSJzY2FsZSImJihMPUwubWFwKEI9Pk1hdGguYWJzKEIpPjFlLTU/QjoxL0I+MD8xZS01Oi0xZS01KSksUy5zZXQoUCxMKSksSVtwXT1udWxsLElbdl0ub25Qcm9wZXJ0eUNoYW5nZShQLEwsRCxJKX19ZnVuY3Rpb24gQShJKXtjb25zdCBQPUlbb10sTD1JLm9mZnNldERpc3RhbmNlKlAuZ2V0VG90YWxMZW5ndGgoKSxEPVAuZ2V0UG9pbnRBdExlbmd0aChMKTtpZihEKXtjb25zdCBiPUlbbl07bGV0IFM9SS5vZmZzZXRSb3RhdGU7Uz09PSJhdXRvIj9TPUQuYW5nbGU6Uz09PSJyZXZlcnNlIj9TPU1hdGguUEkrRC5hbmdsZTpTPU1hdGguUEkqUy8xODAsYi5zZXQoIm9mZnNldFJvdGF0ZSIsUyksYi5zZXQoIm9mZnNldFRyYW5zbGF0ZSIsW0QueCxELnldKSxJW3BdPW51bGx9fWNsYXNzIEN7c3RhdGljIHNldERlZmF1bHQoUCwuLi5MKXtyZXR1cm4gUFt5XSguLi5MKX1zdGF0aWMgZGVjbGFyZUFsaWFzKFAsLi4uTCl7cmV0dXJuIFBbY10oLi4uTCl9c3RhdGljIHNldEF0dHJpYnV0ZShQLC4uLkwpe3JldHVybiBQW2xdKC4uLkwpfXN0YXRpYyBnZXRBdHRyaWJ1dGUoUCwuLi5MKXtyZXR1cm4gUFt1XSguLi5MKX1zdGF0aWMgZ2V0QXR0cmlidXRlcyhQKXtyZXR1cm4gUFtNXX1zdGF0aWMgZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoUCl7cmV0dXJuIFBbZl19Y29uc3RydWN0b3IoUCl7dGhpc1t2XT1QLHRoaXNbeF09e30sdGhpc1twXT1yLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLHRoaXNbbl09bmV3IE1hcCx0aGlzW1JdPXt9LHRoaXNbT109W10sT2JqZWN0LmRlZmluZVByb3BlcnR5KFAsInRyYW5zZm9ybU1hdHJpeCIse2dldDooKT0+KHRoaXNbcF18fCh0aGlzW3BdPWcodGhpc1tuXSx0aGlzLnRyYW5zZm9ybU9yaWdpbikpLFsuLi50aGlzW3BdXSl9KSx0aGlzW3ldKHtpZDoiIixuYW1lOiIiLGNsYXNzTmFtZToiIix4OjAseTowLHRyYW5zZm9ybU9yaWdpbjpbMCwwXSx0cmFuc2Zvcm06IiIsdHJhbnNsYXRlOlswLDBdLHJvdGF0ZTowLHNjYWxlOlsxLDFdLHNrZXc6WzAsMF0sb3BhY2l0eToxLHpJbmRleDowLG9mZnNldFBhdGg6dm9pZCAwLG9mZnNldERpc3RhbmNlOjAsb2Zmc2V0Um90YXRlOiJhdXRvIixwb2ludGVyRXZlbnRzOiJ2aXNpYmxlIixmaWx0ZXI6Im5vbmUiLGRpc3BsYXk6IiJ9KSx0aGlzW2NdKCJjbGFzcyIsInBvcyIpLHRoaXNbYV09bmV3IFNldCx0aGlzW29dPW5ldyBzLkZpZ3VyZTJEKHtzY2FsZTo1LHNpbXBsaWZ5OjB9KX1nZXRbZl0oKXtjb25zdCBQPXt9O3JldHVyblsuLi50aGlzW2FdXS5mb3JFYWNoKEw9PntQW0xdPXRoaXNbeF1bTF19KSxQfWdldFtNXSgpe2NvbnN0IFA9T2JqZWN0LmFzc2lnbih7fSx0aGlzW3hdKTtmb3IobGV0IEw9MDtMPHRoaXNbT10ubGVuZ3RoO0wrKyl7Y29uc3QgRD10aGlzW09dW0xdO1BbRF09dGhpc1tEXX1yZXR1cm4gUH1beV0oUCl7T2JqZWN0LmFzc2lnbih0aGlzW1JdLFApLE9iamVjdC5hc3NpZ24odGhpc1t4XSxQKX1bY10oLi4uUCl7dGhpc1tPXS5wdXNoKC4uLlApfVtsXShQLEwsRD0hMCl7Y29uc3QgYj10aGlzW3hdW1BdLFM9dGhpc1t2XTtyZXR1cm4gTD09bnVsbCYmKEw9dGhpc1tSXVtQXSksT2JqZWN0KG0uY29tcGFyZVZhbHVlKShiLEwpPyExOih0aGlzW3hdW1BdPUwsdGhpc1thXS5oYXMoUCkmJnRoaXNbYV0uZGVsZXRlKFApLHRoaXNbYV0uYWRkKFApLHRoaXNbaV09UCxEJiZTLm9uUHJvcGVydHlDaGFuZ2UoUCxMLGIsdGhpcyksITApfVt1XShQKXtyZXR1cm4gdGhpc1t4XVtQXX1zZXQgaWQoUCl7dGhpc1tsXSgiaWQiLFApfWdldCBpZCgpe3JldHVybiB0aGlzW3VdKCJpZCIpfXNldCBuYW1lKFApe3RoaXNbbF0oIm5hbWUiLFApfWdldCBuYW1lKCl7cmV0dXJuIHRoaXNbdV0oIm5hbWUiKX1zZXQgY2xhc3NOYW1lKFApe3RoaXNbbF0oImNsYXNzTmFtZSIsUCl9Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzW3VdKCJjbGFzc05hbWUiKX1zZXQgY2xhc3MoUCl7dGhpcy5jbGFzc05hbWU9UH1nZXQgY2xhc3MoKXtyZXR1cm4gdGhpcy5jbGFzc05hbWV9Z2V0IHgoKXtyZXR1cm4gdGhpc1t1XSgieCIpfXNldCB4KFApe3RoaXNbbF0oIngiLE9iamVjdChtLnRvTnVtYmVyKShQKSl9Z2V0IHkoKXtyZXR1cm4gdGhpc1t1XSgieSIpfXNldCB5KFApe3RoaXNbbF0oInkiLE9iamVjdChtLnRvTnVtYmVyKShQKSl9Z2V0IHBvcygpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXQgcG9zKFApe1A9T2JqZWN0KG0udG9BcnJheSkoUCksQXJyYXkuaXNBcnJheShQKXx8KFA9W1AsUF0pLHRoaXMueD1QWzBdLHRoaXMueT1QWzFdfWdldCB0cmFuc2Zvcm0oKXtyZXR1cm4gdGhpc1t1XSgidHJhbnNmb3JtIil9c2V0IHRyYW5zZm9ybShQKXtsZXQgTD1udWxsO2lmKEFycmF5LmlzQXJyYXkoUCkmJihMPVAsUD1gbWF0cml4KCR7UC5tYXAobS50b051bWJlcikuam9pbigpfSlgKSx0eXBlb2YgUD09InN0cmluZyIpUD1QLnJlcGxhY2UoL1xzKixccyovZywiLCIpO2Vsc2UgaWYoUCE9bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHRyYW5zZm9ybSB2YWx1ZS4iKTtjb25zdCBEPXRoaXNbeF0udHJhbnNmb3JtO2lmKHRoaXNbbF0oInRyYW5zZm9ybSIsUCwhMSkpe2NvbnN0IGI9dGhpc1tuXTtpZihiLmhhcygibWF0cml4IikmJmIuZGVsZXRlKCJtYXRyaXgiKSxMKWIuc2V0KCJtYXRyaXgiLEwpO2Vsc2UgaWYoUCl7Y29uc3QgUz1QLm1hdGNoKC8obWF0cml4fHRyYW5zbGF0ZXxyb3RhdGV8c2NhbGV8c2tldylcKFteKCldK1wpL2cpO2lmKFMpe2xldCBCPXIubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7Zm9yKGxldCB3PTA7dzxTLmxlbmd0aDt3Kyspe2NvbnN0IEo9U1t3XS5tYXRjaCgvXihtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoKFteKCldKylcKS8pO2lmKEope2xldFsscSxXXT1KO3E9PT0icm90YXRlIj9XPU1hdGguUEkqcGFyc2VGbG9hdChXKS8xODA6Vz1XLnRyaW0oKS5zcGxpdCgvW1xzLF0rLykubWFwKEc9Pk9iamVjdChtLnRvTnVtYmVyKShHKSkscT09PSJtYXRyaXgiP0I9ci5tYXQyZC5tdWx0aXBseShCLEIsVyk6cT09PSJza2V3Ij9CPXIubWF0MmQubXVsdGlwbHkoQixCLHIubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKFdbMV0pLE1hdGgudGFuKFdbMF0pLDEsMCwwKSk6ci5tYXQyZFtxXShCLEIsVyksYi5zZXQoIm1hdHJpeCIsQil9fX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpfXRoaXNbcF09bnVsbCx0aGlzW3ZdLm9uUHJvcGVydHlDaGFuZ2UoInRyYW5zZm9ybSIsUCxELHRoaXMpfX1nZXQgdHJhbnNmb3JtT3JpZ2luKCl7cmV0dXJuIHRoaXNbdV0oInRyYW5zZm9ybU9yaWdpbiIpfXNldCB0cmFuc2Zvcm1PcmlnaW4oUCl7UD1PYmplY3QobS50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLHRoaXNbbF0oInRyYW5zZm9ybU9yaWdpbiIsUCkmJih0aGlzW3BdPW51bGwpfWdldCByb3RhdGUoKXtyZXR1cm4gdGhpc1t1XSgicm90YXRlIil9c2V0IHJvdGF0ZShQKXtUKHRoaXMsInJvdGF0ZSIsUCl9Z2V0IHRyYW5zbGF0ZSgpe3JldHVybiB0aGlzW3VdKCJ0cmFuc2xhdGUiKX1zZXQgdHJhbnNsYXRlKFApe1A9T2JqZWN0KG0udG9BcnJheSkoUCwhMCksUCE9bnVsbCYmIUFycmF5LmlzQXJyYXkoUCkmJihQPVtQLFBdKSxUKHRoaXMsInRyYW5zbGF0ZSIsUCl9Z2V0IHNjYWxlKCl7cmV0dXJuIHRoaXNbdV0oInNjYWxlIil9c2V0IHNjYWxlKFApe1A9T2JqZWN0KG0udG9BcnJheSkoUCwhMCksUCE9bnVsbCYmIUFycmF5LmlzQXJyYXkoUCkmJihQPVtQLFBdKSxUKHRoaXMsInNjYWxlIixQKX1nZXQgc2tldygpe3JldHVybiB0aGlzW3VdKCJza2V3Iil9c2V0IHNrZXcoUCl7UD1PYmplY3QobS50b0FycmF5KShQLCEwKSxQIT1udWxsJiYhQXJyYXkuaXNBcnJheShQKSYmKFA9W1AsUF0pLFQodGhpcywic2tldyIsUCl9Z2V0IG9wYWNpdHkoKXtyZXR1cm4gdGhpc1t1XSgib3BhY2l0eSIpfXNldCBvcGFjaXR5KFApe1AhPW51bGwmJihQPU51bWJlcihQKSksdGhpc1tsXSgib3BhY2l0eSIsUCl9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzW3VdKCJ6SW5kZXgiKX1zZXQgekluZGV4KFApe1AhPW51bGwmJihQPU51bWJlcihQKSksdGhpc1tsXSgiekluZGV4IixQKX1nZXQgb2Zmc2V0UGF0aCgpe3JldHVybiB0aGlzW3VdKCJvZmZzZXRQYXRoIil9c2V0IG9mZnNldFBhdGgoUCl7dGhpc1tsXSgib2Zmc2V0UGF0aCIsUCkmJih0aGlzW29dLmJlZ2luUGF0aCgpLFAhPW51bGwmJnRoaXNbb10uYWRkUGF0aChQKSxBKHRoaXMpKX1nZXQgb2Zmc2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpc1t1XSgib2Zmc2V0RGlzdGFuY2UiKX1zZXQgb2Zmc2V0RGlzdGFuY2UoUCl7dGhpc1tsXSgib2Zmc2V0RGlzdGFuY2UiLE9iamVjdChtLnRvTnVtYmVyKShQKSkmJkEodGhpcyl9Z2V0IG9mZnNldFJvdGF0ZSgpe3JldHVybiB0aGlzW3VdKCJvZmZzZXRSb3RhdGUiKX1zZXQgb2Zmc2V0Um90YXRlKFApe3RoaXNbbF0oIm9mZnNldFJvdGF0ZSIsUCksQSh0aGlzKX1nZXQgcG9pbnRlckV2ZW50cygpe3JldHVybiB0aGlzW3VdKCJwb2ludGVyRXZlbnRzIil9c2V0IHBvaW50ZXJFdmVudHMoUCl7aWYoUCE9bnVsbCYmUCE9PSJub25lIiYmUCE9PSJ2aXNpYmxlIiYmUCE9PSJ2aXNpYmxlRmlsbCImJlAhPT0idmlzaWJsZVN0cm9rZSImJlAhPT0iYWxsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHBvaW50ZXJFdmVudHMgdHlwZS4iKTt0aGlzW2xdKCJwb2ludGVyRXZlbnRzIixQKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbdV0oImZpbHRlciIpfXNldCBmaWx0ZXIoUCl7dGhpc1tsXSgiZmlsdGVyIixQKX1nZXQgZGlzcGxheSgpe3JldHVybiB0aGlzW3VdKCJkaXNwbGF5Iil9c2V0IGRpc3BsYXkoUCl7dGhpc1tsXSgiZGlzcGxheSIsUCl9c2V0IG9mZnNldChQKXt9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwic2l6ZVRvUGl4ZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwidG9OdW1iZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwidG9BcnJheSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjb21wYXJlVmFsdWUiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcihsLHUpe2NvbnN0IE09bC50cmltKCkubWF0Y2goL14oW1xkLl0rKShweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW4pJC8pO00/bD17c2l6ZTpwYXJzZUZsb2F0KE1bMV0pLHVuaXQ6TVsyXX06bD17c2l6ZTpwYXJzZUZsb2F0KGwpLHVuaXQ6InB4In07bGV0e3NpemU6Zix1bml0OnZ9PWw7aWYodj09PSJwdCIpZi89Ljc1O2Vsc2UgaWYodj09PSJwYyIpZio9MTY7ZWxzZSBpZih2PT09ImluIilmKj05NjtlbHNlIGlmKHY9PT0iY20iKWYqPTk2LzIuNTQ7ZWxzZSBpZih2PT09Im1tIilmKj05Ni8yNS40O2Vsc2UgaWYodj09PSJlbSJ8fHY9PT0icmVtInx8dj09PSJleCIpe2lmKCF1JiZ0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZT09ImZ1bmN0aW9uIiYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeD1nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7eD91PXIoeCwxNik6dT0xNn1mKj11LHY9PT0iZXgiJiYoZi89Mil9ZWxzZSBpZih2PT09InEiKWYqPTk2LzI1LjQvNDtlbHNlIGlmKHY9PT0idncifHx2PT09InZoIil7aWYodHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeD12PT09InZ3Ij93aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOndpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtmKj14LzEwMH19ZWxzZSBpZigodj09PSJ2bWF4Inx8dj09PSJ2bWluIikmJnR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IHg9d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxSPXdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDt2PT09InZtYXgiP2YqPU1hdGgubWF4KHgsUikvMTAwOmYqPU1hdGgubWluKHgsUikvMTAwfXJldHVybiBmfWZ1bmN0aW9uIHMobCl7cmV0dXJuIGw9PW51bGw/bDpTdHJpbmcobCl9ZnVuY3Rpb24gbShsKXtpZihsPT1udWxsKXJldHVybiBsO2lmKHR5cGVvZiBsPT0ic3RyaW5nIiYmKGw9cihsKSksIU51bWJlci5pc0Zpbml0ZShsKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIHZhbHVlIik7cmV0dXJuIGx9ZnVuY3Rpb24geShsLHU9ITEpe3JldHVybiBsPT09IiI/bnVsbDoodHlwZW9mIGw9PSJzdHJpbmciJiYobD1sLnNwbGl0KC9bXHMsXSsvZykpLEFycmF5LmlzQXJyYXkobCkmJih1JiYobD1sLm1hcChtKSksbC5sZW5ndGg9PT0xKT9sWzBdOmwpfWZ1bmN0aW9uIGMobCx1KXtpZihBcnJheS5pc0FycmF5KGwpJiZBcnJheS5pc0FycmF5KHUpKXtpZihsLmxlbmd0aCE9PXUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgTT0wO008bC5sZW5ndGg7TSsrKWlmKGxbTV0hPT11W01dKXJldHVybiExO3JldHVybiEwfXJldHVybiBsPT1udWxsJiZ1PT1udWxsfHxsPT09dX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgcj10KDc0KSxzPXQoMzIpLG09dC5uKHMpLHk9dCg2OCksYz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbCgpe3JldHVybiBsPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHgpe2Zvcih2YXIgUj0xO1I8YXJndW1lbnRzLmxlbmd0aDtSKyspe3ZhciBPPWFyZ3VtZW50c1tSXTtmb3IodmFyIGcgaW4gTylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTyxnKSYmKHhbZ109T1tnXSl9cmV0dXJuIHh9LGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIHUoeCl7aWYodHlwZW9mIHg9PSJzdHJpbmciKXtpZih4PXgudHJpbSgpLC9eWzAtOS5dKyUkLy50ZXN0KHgpKXJldHVybiBwYXJzZUZsb2F0KHgpLzEwMDtpZigvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLy50ZXN0KHgpKXJldHVybiBPYmplY3QoYy5zaXplVG9QaXhlbCkoeCl9cmV0dXJuIHh9ZnVuY3Rpb24gTSh4LFIsTyxnLHApe3JldHVybiB0eXBlb2YgeD09InN0cmluZyImJih4PW0oKSh4KSksdHlwZW9mIFI9PSJzdHJpbmciJiYoUj1tKCkoUikpLHIuRWZmZWN0cy5kZWZhdWx0KHgsUixPLGcscCl9ZnVuY3Rpb24gZih4LFIsTyxnLHApe3JldHVybiByLkVmZmVjdHMuZGVmYXVsdCh4LFIsTyxnLHApfXIuRWZmZWN0cy5kZWZhdWx0PWZ1bmN0aW9uKHgsUixPLGcscCl7cmV0dXJuIEFycmF5LmlzQXJyYXkoeCkmJkFycmF5LmlzQXJyYXkoUik/eC5tYXAoKG4sYSk9Pm4rKE8tZykvKHAtZykqKFJbYV0tbikpOnR5cGVvZiB4PT0ibnVtYmVyIiYmdHlwZW9mIFI9PSJudW1iZXIiP3grKE8tZykvKHAtZykqKFIteCk6Ty1nPnAtTz9SOnh9LHIuRWZmZWN0cy5maWxsQ29sb3I9TSxyLkVmZmVjdHMuc3Ryb2tlQ29sb3I9TSxyLkVmZmVjdHMuYmdjb2xvcj1NLHIuRWZmZWN0cy5ib3JkZXJDb2xvcj1NLHIuRWZmZWN0cy50ZXh0PWY7Y2xhc3MgdiBleHRlbmRzIHIuQW5pbWF0b3J7Y29uc3RydWN0b3IoUixPLGcpe2NvbnN0IHA9Ui5hdHRyKCk7T2JqZWN0LmVudHJpZXMocCkuZm9yRWFjaCgoW24sYV0pPT57cFtuXT1yLkVmZmVjdHNbbl0/YTp1KGEpfSksTz1PLm1hcChuPT57bGV0IGE9bCh7fSxuKTtjb25zdCBpPXt9O3JldHVybiBPYmplY3QuZW50cmllcyhhKS5mb3JFYWNoKChbbyxUXSk9PntpW29dPXIuRWZmZWN0c1tvXT9UOnUoVCl9KSxpfSksc3VwZXIocCxPLGcpLHRoaXMudGFyZ2V0PVIsdGhpcy5zZXR0ZXI9ZnVuY3Rpb24obixhKXthLmF0dHIobil9fWdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy50YXJnZXQucGFyZW50P3N1cGVyLnBsYXlTdGF0ZToiaWRsZSJ9Z2V0IGZpbmlzaGVkKCl7cmV0dXJuIHN1cGVyLmZpbmlzaGVkLnRoZW4oKCk9Pntjb25zdCBSPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKE89PntmdW5jdGlvbiBnKCl7Ui5zZXR0ZXIoUi5mcmFtZSxSLnRhcmdldCk7Y29uc3QgcD1SLnBsYXlTdGF0ZTtwPT09ImZpbmlzaGVkInx8cD09PSJpZGxlIj8oT2JqZWN0KHkuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKFIucmVxdWVzdElkKSxPKCkpOk9iamVjdCh5LnJlcXVlc3RBbmltYXRpb25GcmFtZSkoZyl9ZygpfSl9KX1maW5pc2goKXtzdXBlci5maW5pc2goKSxPYmplY3QoeS5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpfXBsYXkoKXtpZighdGhpcy50YXJnZXQucGFyZW50fHx0aGlzLnBsYXlTdGF0ZT09PSJydW5uaW5nIilyZXR1cm47c3VwZXIucGxheSgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpO2NvbnN0IFI9dGhpczt0aGlzLnJlYWR5LnRoZW4oKCk9PntSLnNldHRlcihSLmZyYW1lLFIudGFyZ2V0KSxSLnJlcXVlc3RJZD1PYmplY3QoeS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGZ1bmN0aW9uIE8oKXtjb25zdCBnPVIudGFyZ2V0O2lmKHR5cGVvZiBkb2N1bWVudDwidSImJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zJiZnLmxheWVyJiZnLmxheWVyLmNhbnZhcyYmIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhnLmxheWVyLmNhbnZhcykpe1IuY2FuY2VsKCk7cmV0dXJufWNvbnN0IHA9Ui5wbGF5U3RhdGU7Ui5zZXR0ZXIoUi5mcmFtZSxSLnRhcmdldCkscCE9PSJpZGxlIiYmKHA9PT0icnVubmluZyI/Ui5yZXF1ZXN0SWQ9T2JqZWN0KHkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShPKToocD09PSJwYXVzZWQifHxwPT09InBlbmRpbmciJiZSLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDApJiZSLnJlYWR5LnRoZW4oKCk9PntSLnNldHRlcihSLmZyYW1lLFIudGFyZ2V0KSxSLnJlcXVlc3RJZD1PYmplY3QoeS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKE8pfSkpfSl9KX1jYW5jZWwoUj0hMSl7T2JqZWN0KHkuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKHRoaXMucmVxdWVzdElkKSxSPyh0aGlzLnNldHRlcih0aGlzLmZyYW1lLHRoaXMudGFyZ2V0KSxzdXBlci5jYW5jZWwoKSk6KHN1cGVyLmNhbmNlbCgpLHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpKX19fSxmdW5jdGlvbihoLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuVGltZWxpbmU9ZS5FZmZlY3RzPWUuRWFzaW5ncz1lLkFuaW1hdG9yPXZvaWQgMDt2YXIgcj10KDc1KSxzPU0ociksbT10KDE4NykseT1NKG0pLGM9dCgxODgpLGw9dCgxOTApLHU9TShsKTtmdW5jdGlvbiBNKGYpe3JldHVybiBmJiZmLl9fZXNNb2R1bGU/Zjp7ZGVmYXVsdDpmfX1lLkFuaW1hdG9yPXUuZGVmYXVsdCxlLkVhc2luZ3M9Yy5FYXNpbmdzLGUuRWZmZWN0cz15LmRlZmF1bHQsZS5UaW1lbGluZT1zLmRlZmF1bHR9LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9dCg3Nikscz1uKHIpLG09dCgxMzMpLHk9bihtKSxjPXQoMTQxKSxsPW4oYyksdT10KDE2NCksTT1uKHUpLGY9dCgxNzApLHY9bihmKSx4PXQoMTcxKSxSPW4oeCksTz10KDE3NSksZz1uKE8pLHA9dCgxODYpO2Z1bmN0aW9uIG4oRCl7cmV0dXJuIEQmJkQuX19lc01vZHVsZT9EOntkZWZhdWx0OkR9fXZhciBhPSgwLHAuY3JlYXRlTm93VGltZSkoKSxpPXtvcmlnaW5UaW1lOjAscGxheWJhY2tSYXRlOjF9LG89KDAsZy5kZWZhdWx0KSgidGltZU1hcmsiKSxUPSgwLGcuZGVmYXVsdCkoInBsYXliYWNrUmF0ZSIpLEE9KDAsZy5kZWZhdWx0KSgidGltZXJzIiksQz0oMCxnLmRlZmF1bHQpKCJvcmlnaW5UaW1lIiksST0oMCxnLmRlZmF1bHQpKCJzZXRUaW1lciIpLFA9KDAsZy5kZWZhdWx0KSgicGFyZW50IiksTD1mdW5jdGlvbigpe2Z1bmN0aW9uIEQoYixTKXsoMCx2LmRlZmF1bHQpKHRoaXMsRCksYiBpbnN0YW5jZW9mIEQmJihTPWIsYj17fSksYj0oMCxNLmRlZmF1bHQpKHt9LGksYiksUyYmKHRoaXNbUF09Uyk7dmFyIEI9Yi5ub3d0aW1lfHxhO2lmKFMpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImdsb2JhbFRpbWUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUy5jdXJyZW50VGltZX19KTtlbHNle3ZhciB3PUIoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBCKCktd319KX10aGlzW29dPVt7Z2xvYmFsVGltZTp0aGlzLmdsb2JhbFRpbWUsbG9jYWxUaW1lOi1iLm9yaWdpblRpbWUsZW50cm9weTotYi5vcmlnaW5UaW1lLHBsYXliYWNrUmF0ZTpiLnBsYXliYWNrUmF0ZSxnbG9iYWxFbnRyb3B5OjB9XSx0aGlzW1BdJiYodGhpc1tvXVswXS5nbG9iYWxFbnRyb3B5PXRoaXNbUF0uZW50cm9weSksdGhpc1tDXT1iLm9yaWdpblRpbWUsdGhpc1tUXT1iLnBsYXliYWNrUmF0ZSx0aGlzW0FdPW5ldyBsLmRlZmF1bHR9cmV0dXJuKDAsUi5kZWZhdWx0KShELFt7a2V5OiJtYXJrVGltZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgUz1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXZvaWQgMD9hcmd1bWVudHNbMF06e30sQj1TLnRpbWUsdz1CPT09dm9pZCAwP3RoaXMuY3VycmVudFRpbWU6QixIPVMuZW50cm9weSxKPUg9PT12b2lkIDA/dGhpcy5lbnRyb3B5OkgscT1TLnBsYXliYWNrUmF0ZSxXPXE9PT12b2lkIDA/dGhpcy5wbGF5YmFja1JhdGU6cSxHPXtnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6dyxlbnRyb3B5OkoscGxheWJhY2tSYXRlOlcsZ2xvYmFsRW50cm9weTp0aGlzLmdsb2JhbEVudHJvcHl9O3RoaXNbb10ucHVzaChHKX19LHtrZXk6ImZvcmsiLHZhbHVlOmZ1bmN0aW9uKFMpe3JldHVybiBuZXcgRChTLHRoaXMpfX0se2tleToic2Vla0dsb2JhbFRpbWUiLHZhbHVlOmZ1bmN0aW9uKFMpe3ZhciBCPXRoaXMuc2Vla1RpbWVNYXJrKFMpLHc9dGhpc1tvXVtCXSxIPXcuZW50cm9weSxKPXcucGxheWJhY2tSYXRlLHE9dy5nbG9iYWxUaW1lO3JldHVybiBxKyhTLUgpL01hdGguYWJzKEopfX0se2tleToic2Vla0xvY2FsVGltZSIsdmFsdWU6ZnVuY3Rpb24oUyl7dmFyIEI9dGhpcy5zZWVrVGltZU1hcmsoUyksdz10aGlzW29dW0JdLEg9dy5sb2NhbFRpbWUsSj13LmVudHJvcHkscT13LnBsYXliYWNrUmF0ZTtyZXR1cm4gcT4wP0grKFMtSik6SC0oUy1KKX19LHtrZXk6InNlZWtUaW1lTWFyayIsdmFsdWU6ZnVuY3Rpb24oUyl7dmFyIEI9dGhpc1tvXSx3PTAsSD1CLmxlbmd0aC0xO2lmKFM8PUJbd10uZW50cm9weSlyZXR1cm4gdztpZihTPj1CW0hdLmVudHJvcHkpcmV0dXJuIEg7Zm9yKHZhciBKPU1hdGguZmxvb3IoKHcrSCkvMik7Sj53JiZKPEg7KXtpZihTPT09QltKXS5lbnRyb3B5KXJldHVybiBKO1M8QltKXS5lbnRyb3B5P0g9SjpTPkJbSl0uZW50cm9weSYmKHc9SiksSj1NYXRoLmZsb29yKCh3K0gpLzIpfXJldHVybiB3fX0se2tleToidXBkYXRlVGltZXJzIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBTPXRoaXMsQj1bXS5jb25jYXQoKDAseS5kZWZhdWx0KSh0aGlzW0FdKSk7Qi5mb3JFYWNoKGZ1bmN0aW9uKHcpe3ZhciBIPSgwLHMuZGVmYXVsdCkodywyKSxKPUhbMF0scT1IWzFdO1NbSV0ocS5oYW5kbGVyLHEudGltZSxKKX0pfX0se2tleToiY2xlYXJUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihiKXtmdW5jdGlvbiBTKEIpe3JldHVybiBiLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gUy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBiLnRvU3RyaW5nKCl9LFN9KGZ1bmN0aW9uKGIpe3ZhciBTPXRoaXNbQV0uZ2V0KGIpO1MmJlMudGltZXJJRCE9bnVsbCYmKHRoaXNbUF0/dGhpc1tQXS5jbGVhclRpbWVvdXQoUy50aW1lcklEKTpjbGVhclRpbWVvdXQoUy50aW1lcklEKSksdGhpc1tBXS5kZWxldGUoYil9KX0se2tleToiY2xlYXJJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oUyl7cmV0dXJuIHRoaXMuY2xlYXJUaW1lb3V0KFMpfX0se2tleToiY2xlYXIiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIFM9dGhpcyxCPXRoaXNbQV07W10uY29uY2F0KCgwLHkuZGVmYXVsdCkoQi5rZXlzKCkpKS5mb3JFYWNoKGZ1bmN0aW9uKHcpe1MuY2xlYXJUaW1lb3V0KHcpfSl9fSx7a2V5OiJzZXRUaW1lb3V0Iix2YWx1ZTpmdW5jdGlvbihTKXt2YXIgQj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9O3JldHVybiB0aGlzW0ldKFMsQil9fSx7a2V5OiJzZXRJbnRlcnZhbCIsdmFsdWU6ZnVuY3Rpb24oUyl7dmFyIEI9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOntkZWxheTowfSx3PXRoaXMsSD10aGlzW0ldKGZ1bmN0aW9uIEooKXt3W0ldKEosQixIKSxTKCl9LEIpO3JldHVybiBIfX0se2tleTpJLHZhbHVlOmZ1bmN0aW9uKFMsQil7dmFyIHc9dGhpcyxIPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTooMCxnLmRlZmF1bHQpKCJ0aW1lcklEIik7Qj0oMCxwLmZvcm1hdERlbGF5KShCKTt2YXIgSj10aGlzW0FdLmdldChIKSxxPXZvaWQgMCxXPW51bGwsRz12b2lkIDAsUT12b2lkIDA7Sj8odGhpcy5jbGVhclRpbWVvdXQoSCksQi5pc0VudHJvcHk/cT0oQi5kZWxheS0odGhpcy5lbnRyb3B5LUouc3RhcnRFbnRyb3B5KSkvTWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnE9KEIuZGVsYXktKHRoaXMuY3VycmVudFRpbWUtSi5zdGFydFRpbWUpKS90aGlzLnBsYXliYWNrUmF0ZSxHPUouc3RhcnRUaW1lLFE9Si5zdGFydEVudHJvcHkpOihxPUIuZGVsYXkvKEIuaXNFbnRyb3B5P01hdGguYWJzKHRoaXMucGxheWJhY2tSYXRlKTp0aGlzLnBsYXliYWNrUmF0ZSksRz10aGlzLmN1cnJlbnRUaW1lLFE9dGhpcy5lbnRyb3B5KTt2YXIgdHQ9dGhpc1tQXSxfPXR0P3R0LnNldFRpbWVvdXQuYmluZCh0dCk6c2V0VGltZW91dCxzdD1CLmhlYWRpbmc7cmV0dXJuIXR0JiZzdD09PSExJiZxPDAmJihxPTEvMCksKGlzRmluaXRlKHEpfHx0dCkmJihxPU1hdGguY2VpbChxKSxfIT09c2V0VGltZW91dCYmKHE9e2RlbGF5OnEsaGVhZGluZzpzdH0pLFc9XyhmdW5jdGlvbigpe3dbQV0uZGVsZXRlKEgpLFMoKX0scSkpLHRoaXNbQV0uc2V0KEgse3RpbWVySUQ6VyxoYW5kbGVyOlMsdGltZTpCLHN0YXJ0VGltZTpHLHN0YXJ0RW50cm9weTpRfSksSH19LHtrZXk6InBhcmVudCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbUF19fSx7a2V5OiJsYXN0VGltZU1hcmsiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW29dW3RoaXNbb10ubGVuZ3RoLTFdfX0se2tleToiY3VycmVudFRpbWUiLGdldDpmdW5jdGlvbigpe3ZhciBTPXRoaXMubGFzdFRpbWVNYXJrLEI9Uy5sb2NhbFRpbWUsdz1TLmdsb2JhbFRpbWU7cmV0dXJuIEIrKHRoaXMuZ2xvYmFsVGltZS13KSp0aGlzLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKFMpe3ZhciBCPXRoaXMsdz10aGlzLmN1cnJlbnRUaW1lLEg9UyxKPXRoaXNbQV07dGhpcy5tYXJrVGltZSh7dGltZTpTfSksW10uY29uY2F0KCgwLHkuZGVmYXVsdCkoSikpLmZvckVhY2goZnVuY3Rpb24ocSl7dmFyIFc9KDAscy5kZWZhdWx0KShxLDIpLEc9V1swXSxRPVdbMV07aWYoSi5oYXMoRykpe3ZhciB0dD1RLnRpbWUsXz10dC5pc0VudHJvcHksc3Q9dHQuZGVsYXksaz10dC5oZWFkaW5nLGN0PVEuaGFuZGxlcixmdD1RLnN0YXJ0VGltZTtpZihfKXN0PT09MCYmKGN0KCksQi5jbGVhclRpbWVvdXQoRykpO2Vsc2V7dmFyIFU9ZnQrc3Q7KHN0PT09MHx8ayE9PSExJiYoSC13KSpzdDw9MHx8dzw9VSYmVTw9SHx8dz49VSYmVT49SCkmJihjdCgpLEIuY2xlYXJUaW1lb3V0KEcpKX19fSksdGhpcy51cGRhdGVUaW1lcnMoKX19LHtrZXk6ImVudHJvcHkiLGdldDpmdW5jdGlvbigpe3ZhciBTPXRoaXMubGFzdFRpbWVNYXJrLEI9Uy5lbnRyb3B5LHc9Uy5nbG9iYWxFbnRyb3B5O3JldHVybiBCK01hdGguYWJzKCh0aGlzLmdsb2JhbEVudHJvcHktdykqdGhpcy5wbGF5YmFja1JhdGUpfSxzZXQ6ZnVuY3Rpb24oUyl7aWYodGhpcy5lbnRyb3B5PlMpe3ZhciBCPXRoaXMuc2Vla1RpbWVNYXJrKFMpO3RoaXNbb10ubGVuZ3RoPUIrMX10aGlzLm1hcmtUaW1lKHtlbnRyb3B5OlN9KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZ2xvYmFsRW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5lbnRyb3B5OnRoaXMuZ2xvYmFsVGltZX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbVF19LHNldDpmdW5jdGlvbihTKXtTIT09dGhpcy5wbGF5YmFja1JhdGUmJih0aGlzLm1hcmtUaW1lKHtwbGF5YmFja1JhdGU6U30pLHRoaXNbVF09Uyx0aGlzLnVwZGF0ZVRpbWVycygpKX19LHtrZXk6InBhdXNlZCIsZ2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO2Zvcih2YXIgUz10aGlzLnBhcmVudDtTOyl7aWYoUy5wbGF5YmFja1JhdGU9PT0wKXJldHVybiEwO1M9Uy5wYXJlbnR9cmV0dXJuITF9fV0pLER9KCk7ZS5kZWZhdWx0PUx9LGZ1bmN0aW9uKGgsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIHI9dCg3Nykscz1jKHIpLG09dCgxMjkpLHk9YyhtKTtmdW5jdGlvbiBjKGwpe3JldHVybiBsJiZsLl9fZXNNb2R1bGU/bDp7ZGVmYXVsdDpsfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBsKHUsTSl7dmFyIGY9W10sdj0hMCx4PSExLFI9dm9pZCAwO3RyeXtmb3IodmFyIE89KDAseS5kZWZhdWx0KSh1KSxnOyEodj0oZz1PLm5leHQoKSkuZG9uZSkmJihmLnB1c2goZy52YWx1ZSksIShNJiZmLmxlbmd0aD09PU0pKTt2PSEwKTt9Y2F0Y2gocCl7eD0hMCxSPXB9ZmluYWxseXt0cnl7IXYmJk8ucmV0dXJuJiZPLnJldHVybigpfWZpbmFsbHl7aWYoeCl0aHJvdyBSfX1yZXR1cm4gZn1yZXR1cm4gZnVuY3Rpb24odSxNKXtpZihBcnJheS5pc0FycmF5KHUpKXJldHVybiB1O2lmKCgwLHMuZGVmYXVsdCkoT2JqZWN0KHUpKSlyZXR1cm4gbCh1LE0pO3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UiKX19KCl9LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCg3OCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDc5KSx0KDEyNSksaC5leHBvcnRzPXQoMTI3KX0sZnVuY3Rpb24oaCxlLHQpe3QoODApO2Zvcih2YXIgcj10KDkxKSxzPXQoOTUpLG09dCg4MykseT10KDEyMikoInRvU3RyaW5nVGFnIiksYz0iQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCxET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LE1lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QiLnNwbGl0KCIsIiksbD0wO2w8Yy5sZW5ndGg7bCsrKXt2YXIgdT1jW2xdLE09clt1XSxmPU0mJk0ucHJvdG90eXBlO2YmJiFmW3ldJiZzKGYseSx1KSxtW3VdPW0uQXJyYXl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4MSkscz10KDgyKSxtPXQoODMpLHk9dCg4NCk7aC5leHBvcnRzPXQoODgpKEFycmF5LCJBcnJheSIsZnVuY3Rpb24oYyxsKXt0aGlzLl90PXkoYyksdGhpcy5faT0wLHRoaXMuX2s9bH0sZnVuY3Rpb24oKXt2YXIgYz10aGlzLl90LGw9dGhpcy5fayx1PXRoaXMuX2krKztyZXR1cm4hY3x8dT49Yy5sZW5ndGg/KHRoaXMuX3Q9dm9pZCAwLHMoMSkpOmw9PSJrZXlzIj9zKDAsdSk6bD09InZhbHVlcyI/cygwLGNbdV0pOnMoMCxbdSxjW3VdXSl9LCJ2YWx1ZXMiKSxtLkFyZ3VtZW50cz1tLkFycmF5LHIoImtleXMiKSxyKCJ2YWx1ZXMiKSxyKCJlbnRyaWVzIil9LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKCl7fX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCxyKXtyZXR1cm57dmFsdWU6cixkb25lOiEhdH19fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz17fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoODUpLHM9dCg4Nyk7aC5leHBvcnRzPWZ1bmN0aW9uKG0pe3JldHVybiByKHMobSkpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoODYpO2guZXhwb3J0cz1PYmplY3QoInoiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKT9PYmplY3Q6ZnVuY3Rpb24ocyl7cmV0dXJuIHIocyk9PSJTdHJpbmciP3Muc3BsaXQoIiIpOk9iamVjdChzKX19LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9e30udG9TdHJpbmc7aC5leHBvcnRzPWZ1bmN0aW9uKHIpe3JldHVybiB0LmNhbGwocikuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1mdW5jdGlvbih0KXtpZih0PT1udWxsKXRocm93IFR5cGVFcnJvcigiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gICIrdCk7cmV0dXJuIHR9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4OSkscz10KDkwKSxtPXQoMTA2KSx5PXQoOTUpLGM9dCg4MyksbD10KDEwNyksdT10KDEyMSksTT10KDEyMyksZj10KDEyMikoIml0ZXJhdG9yIiksdj0hKFtdLmtleXMmJiJuZXh0ImluW10ua2V5cygpKSx4PSJAQGl0ZXJhdG9yIixSPSJrZXlzIixPPSJ2YWx1ZXMiLGc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307aC5leHBvcnRzPWZ1bmN0aW9uKHAsbixhLGksbyxULEEpe2woYSxuLGkpO3ZhciBDPWZ1bmN0aW9uKFcpe2lmKCF2JiZXIGluIEQpcmV0dXJuIERbV107c3dpdGNoKFcpe2Nhc2UgUjpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEodGhpcyxXKX07Y2FzZSBPOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgYSh0aGlzLFcpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEodGhpcyxXKX19LEk9bisiIEl0ZXJhdG9yIixQPW89PU8sTD0hMSxEPXAucHJvdG90eXBlLGI9RFtmXXx8RFt4XXx8byYmRFtvXSxTPWJ8fEMobyksQj1vP1A/QygiZW50cmllcyIpOlM6dm9pZCAwLHc9bj09IkFycmF5IiYmRC5lbnRyaWVzfHxiLEgsSixxO2lmKHcmJihxPU0ody5jYWxsKG5ldyBwKSkscSE9PU9iamVjdC5wcm90b3R5cGUmJnEubmV4dCYmKHUocSxJLCEwKSwhciYmdHlwZW9mIHFbZl0hPSJmdW5jdGlvbiImJnkocSxmLGcpKSksUCYmYiYmYi5uYW1lIT09TyYmKEw9ITAsUz1mdW5jdGlvbigpe3JldHVybiBiLmNhbGwodGhpcyl9KSwoIXJ8fEEpJiYodnx8THx8IURbZl0pJiZ5KEQsZixTKSxjW25dPVMsY1tJXT1nLG8paWYoSD17dmFsdWVzOlA/UzpDKE8pLGtleXM6VD9TOkMoUiksZW50cmllczpCfSxBKWZvcihKIGluIEgpSiBpbiBEfHxtKEQsSixIW0pdKTtlbHNlIHMocy5QK3MuRioodnx8TCksbixIKTtyZXR1cm4gSH19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPSEwfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MSkscz10KDkyKSxtPXQoOTMpLHk9dCg5NSksYz10KDEwNSksbD0icHJvdG90eXBlIix1PWZ1bmN0aW9uKE0sZix2KXt2YXIgeD1NJnUuRixSPU0mdS5HLE89TSZ1LlMsZz1NJnUuUCxwPU0mdS5CLG49TSZ1LlcsYT1SP3M6c1tmXXx8KHNbZl09e30pLGk9YVtsXSxvPVI/cjpPP3JbZl06KHJbZl18fHt9KVtsXSxULEEsQztSJiYodj1mKTtmb3IoVCBpbiB2KUE9IXgmJm8mJm9bVF0hPT12b2lkIDAsIShBJiZjKGEsVCkpJiYoQz1BP29bVF06dltUXSxhW1RdPVImJnR5cGVvZiBvW1RdIT0iZnVuY3Rpb24iP3ZbVF06cCYmQT9tKEMscik6biYmb1tUXT09Qz9mdW5jdGlvbihJKXt2YXIgUD1mdW5jdGlvbihMLEQsYil7aWYodGhpcyBpbnN0YW5jZW9mIEkpe3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyBJO2Nhc2UgMTpyZXR1cm4gbmV3IEkoTCk7Y2FzZSAyOnJldHVybiBuZXcgSShMLEQpfXJldHVybiBuZXcgSShMLEQsYil9cmV0dXJuIEkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtyZXR1cm4gUFtsXT1JW2xdLFB9KEMpOmcmJnR5cGVvZiBDPT0iZnVuY3Rpb24iP20oRnVuY3Rpb24uY2FsbCxDKTpDLGcmJigoYS52aXJ0dWFsfHwoYS52aXJ0dWFsPXt9KSlbVF09QyxNJnUuUiYmaSYmIWlbVF0mJnkoaSxULEMpKSl9O3UuRj0xLHUuRz0yLHUuUz00LHUuUD04LHUuQj0xNix1Llc9MzIsdS5VPTY0LHUuUj0xMjgsaC5leHBvcnRzPXV9LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9aC5leHBvcnRzPXR5cGVvZiB3aW5kb3c8InUiJiZ3aW5kb3cuTWF0aD09TWF0aD93aW5kb3c6dHlwZW9mIHNlbGY8InUiJiZzZWxmLk1hdGg9PU1hdGg/c2VsZjpGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpO3R5cGVvZiBfX2c9PSJudW1iZXIiJiYoX19nPXQpfSxmdW5jdGlvbihoLGUpe3ZhciB0PWguZXhwb3J0cz17dmVyc2lvbjoiMi42LjExIn07dHlwZW9mIF9fZT09Im51bWJlciImJihfX2U9dCl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk0KTtoLmV4cG9ydHM9ZnVuY3Rpb24ocyxtLHkpe2lmKHIocyksbT09PXZvaWQgMClyZXR1cm4gcztzd2l0Y2goeSl7Y2FzZSAxOnJldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gcy5jYWxsKG0sYyl9O2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24oYyxsKXtyZXR1cm4gcy5jYWxsKG0sYyxsKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihjLGwsdSl7cmV0dXJuIHMuY2FsbChtLGMsbCx1KX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHMuYXBwbHkobSxhcmd1bWVudHMpfX19LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHR5cGVvZiB0IT0iZnVuY3Rpb24iKXRocm93IFR5cGVFcnJvcih0KyIgaXMgbm90IGEgZnVuY3Rpb24hIik7cmV0dXJuIHR9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nikscz10KDEwNCk7aC5leHBvcnRzPXQoMTAwKT9mdW5jdGlvbihtLHksYyl7cmV0dXJuIHIuZihtLHkscygxLGMpKX06ZnVuY3Rpb24obSx5LGMpe3JldHVybiBtW3ldPWMsbX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk3KSxzPXQoOTkpLG09dCgxMDMpLHk9T2JqZWN0LmRlZmluZVByb3BlcnR5O2UuZj10KDEwMCk/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKGwsdSxNKXtpZihyKGwpLHU9bSh1LCEwKSxyKE0pLHMpdHJ5e3JldHVybiB5KGwsdSxNKX1jYXRjaHt9aWYoImdldCJpbiBNfHwic2V0ImluIE0pdGhyb3cgVHlwZUVycm9yKCJBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEiKTtyZXR1cm4idmFsdWUiaW4gTSYmKGxbdV09TS52YWx1ZSksbH19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk4KTtoLmV4cG9ydHM9ZnVuY3Rpb24ocyl7aWYoIXIocykpdGhyb3cgVHlwZUVycm9yKHMrIiBpcyBub3QgYW4gb2JqZWN0ISIpO3JldHVybiBzfX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ib2JqZWN0Ij90IT09bnVsbDp0eXBlb2YgdD09ImZ1bmN0aW9uIn19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9IXQoMTAwKSYmIXQoMTAxKShmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCgxMDIpKCJkaXYiKSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmEhPTd9KX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz0hdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmEhPTd9KX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhdCgpfWNhdGNoe3JldHVybiEwfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk4KSxzPXQoOTEpLmRvY3VtZW50LG09cihzKSYmcihzLmNyZWF0ZUVsZW1lbnQpO2guZXhwb3J0cz1mdW5jdGlvbih5KXtyZXR1cm4gbT9zLmNyZWF0ZUVsZW1lbnQoeSk6e319fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5OCk7aC5leHBvcnRzPWZ1bmN0aW9uKHMsbSl7aWYoIXIocykpcmV0dXJuIHM7dmFyIHksYztpZihtJiZ0eXBlb2YoeT1zLnRvU3RyaW5nKT09ImZ1bmN0aW9uIiYmIXIoYz15LmNhbGwocykpfHx0eXBlb2YoeT1zLnZhbHVlT2YpPT0iZnVuY3Rpb24iJiYhcihjPXkuY2FsbChzKSl8fCFtJiZ0eXBlb2YoeT1zLnRvU3RyaW5nKT09ImZ1bmN0aW9uIiYmIXIoYz15LmNhbGwocykpKXJldHVybiBjO3Rocm93IFR5cGVFcnJvcigiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlIil9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1mdW5jdGlvbih0LHIpe3JldHVybntlbnVtZXJhYmxlOiEodCYxKSxjb25maWd1cmFibGU6ISh0JjIpLHdyaXRhYmxlOiEodCY0KSx2YWx1ZTpyfX19LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9e30uaGFzT3duUHJvcGVydHk7aC5leHBvcnRzPWZ1bmN0aW9uKHIscyl7cmV0dXJuIHQuY2FsbChyLHMpfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz10KDk1KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTA4KSxzPXQoMTA0KSxtPXQoMTIxKSx5PXt9O3QoOTUpKHksdCgxMjIpKCJpdGVyYXRvciIpLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxoLmV4cG9ydHM9ZnVuY3Rpb24oYyxsLHUpe2MucHJvdG90eXBlPXIoeSx7bmV4dDpzKDEsdSl9KSxtKGMsbCsiIEl0ZXJhdG9yIil9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nykscz10KDEwOSksbT10KDExOSkseT10KDExNikoIklFX1BST1RPIiksYz1mdW5jdGlvbigpe30sbD0icHJvdG90eXBlIix1PWZ1bmN0aW9uKCl7dmFyIE09dCgxMDIpKCJpZnJhbWUiKSxmPW0ubGVuZ3RoLHY9IjwiLHg9Ij4iLFI7Zm9yKE0uc3R5bGUuZGlzcGxheT0ibm9uZSIsdCgxMjApLmFwcGVuZENoaWxkKE0pLE0uc3JjPSJqYXZhc2NyaXB0OiIsUj1NLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsUi5vcGVuKCksUi53cml0ZSh2KyJzY3JpcHQiK3grImRvY3VtZW50LkY9T2JqZWN0Iit2KyIvc2NyaXB0Iit4KSxSLmNsb3NlKCksdT1SLkY7Zi0tOylkZWxldGUgdVtsXVttW2ZdXTtyZXR1cm4gdSgpfTtoLmV4cG9ydHM9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24oZix2KXt2YXIgeDtyZXR1cm4gZiE9PW51bGw/KGNbbF09cihmKSx4PW5ldyBjLGNbbF09bnVsbCx4W3ldPWYpOng9dSgpLHY9PT12b2lkIDA/eDpzKHgsdil9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nikscz10KDk3KSxtPXQoMTEwKTtoLmV4cG9ydHM9dCgxMDApP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzOmZ1bmN0aW9uKGMsbCl7cyhjKTtmb3IodmFyIHU9bShsKSxNPXUubGVuZ3RoLGY9MCx2O00+Zjspci5mKGMsdj11W2YrK10sbFt2XSk7cmV0dXJuIGN9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMTEpLHM9dCgxMTkpO2guZXhwb3J0cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oeSl7cmV0dXJuIHIoeSxzKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEwNSkscz10KDg0KSxtPXQoMTEyKSghMSkseT10KDExNikoIklFX1BST1RPIik7aC5leHBvcnRzPWZ1bmN0aW9uKGMsbCl7dmFyIHU9cyhjKSxNPTAsZj1bXSx2O2Zvcih2IGluIHUpdiE9eSYmcih1LHYpJiZmLnB1c2godik7Zm9yKDtsLmxlbmd0aD5NOylyKHUsdj1sW00rK10pJiYofm0oZix2KXx8Zi5wdXNoKHYpKTtyZXR1cm4gZn19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg0KSxzPXQoMTEzKSxtPXQoMTE1KTtoLmV4cG9ydHM9ZnVuY3Rpb24oeSl7cmV0dXJuIGZ1bmN0aW9uKGMsbCx1KXt2YXIgTT1yKGMpLGY9cyhNLmxlbmd0aCksdj1tKHUsZikseDtpZih5JiZsIT1sKXtmb3IoO2Y+djspaWYoeD1NW3YrK10seCE9eClyZXR1cm4hMH1lbHNlIGZvcig7Zj52O3YrKylpZigoeXx8diBpbiBNKSYmTVt2XT09PWwpcmV0dXJuIHl8fHZ8fDA7cmV0dXJuIXkmJi0xfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExNCkscz1NYXRoLm1pbjtoLmV4cG9ydHM9ZnVuY3Rpb24obSl7cmV0dXJuIG0+MD9zKHIobSksOTAwNzE5OTI1NDc0MDk5MSk6MH19LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9TWF0aC5jZWlsLHI9TWF0aC5mbG9vcjtoLmV4cG9ydHM9ZnVuY3Rpb24ocyl7cmV0dXJuIGlzTmFOKHM9K3MpPzA6KHM+MD9yOnQpKHMpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTE0KSxzPU1hdGgubWF4LG09TWF0aC5taW47aC5leHBvcnRzPWZ1bmN0aW9uKHksYyl7cmV0dXJuIHk9cih5KSx5PDA/cyh5K2MsMCk6bSh5LGMpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTE3KSgia2V5cyIpLHM9dCgxMTgpO2guZXhwb3J0cz1mdW5jdGlvbihtKXtyZXR1cm4gclttXXx8KHJbbV09cyhtKSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Mikscz10KDkxKSxtPSJfX2NvcmUtanNfc2hhcmVkX18iLHk9c1ttXXx8KHNbbV09e30pOyhoLmV4cG9ydHM9ZnVuY3Rpb24oYyxsKXtyZXR1cm4geVtjXXx8KHlbY109bCE9PXZvaWQgMD9sOnt9KX0pKCJ2ZXJzaW9ucyIsW10pLnB1c2goe3ZlcnNpb246ci52ZXJzaW9uLG1vZGU6dCg4OSk/InB1cmUiOiJnbG9iYWwiLGNvcHlyaWdodDoiwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSJ9KX0sZnVuY3Rpb24oaCxlKXt2YXIgdD0wLHI9TWF0aC5yYW5kb20oKTtoLmV4cG9ydHM9ZnVuY3Rpb24ocyl7cmV0dXJuIlN5bWJvbCgiLmNvbmNhdChzPT09dm9pZCAwPyIiOnMsIilfIiwoKyt0K3IpLnRvU3RyaW5nKDM2KSl9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz0iY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mIi5zcGxpdCgiLCIpfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MSkuZG9jdW1lbnQ7aC5leHBvcnRzPXImJnIuZG9jdW1lbnRFbGVtZW50fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5NikuZixzPXQoMTA1KSxtPXQoMTIyKSgidG9TdHJpbmdUYWciKTtoLmV4cG9ydHM9ZnVuY3Rpb24oeSxjLGwpe3kmJiFzKHk9bD95OnkucHJvdG90eXBlLG0pJiZyKHksbSx7Y29uZmlndXJhYmxlOiEwLHZhbHVlOmN9KX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExNykoIndrcyIpLHM9dCgxMTgpLG09dCg5MSkuU3ltYm9sLHk9dHlwZW9mIG09PSJmdW5jdGlvbiIsYz1oLmV4cG9ydHM9ZnVuY3Rpb24obCl7cmV0dXJuIHJbbF18fChyW2xdPXkmJm1bbF18fCh5P206cykoIlN5bWJvbC4iK2wpKX07Yy5zdG9yZT1yfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMDUpLHM9dCgxMjQpLG09dCgxMTYpKCJJRV9QUk9UTyIpLHk9T2JqZWN0LnByb3RvdHlwZTtoLmV4cG9ydHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHxmdW5jdGlvbihjKXtyZXR1cm4gYz1zKGMpLHIoYyxtKT9jW21dOnR5cGVvZiBjLmNvbnN0cnVjdG9yPT0iZnVuY3Rpb24iJiZjIGluc3RhbmNlb2YgYy5jb25zdHJ1Y3Rvcj9jLmNvbnN0cnVjdG9yLnByb3RvdHlwZTpjIGluc3RhbmNlb2YgT2JqZWN0P3k6bnVsbH19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg3KTtoLmV4cG9ydHM9ZnVuY3Rpb24ocyl7cmV0dXJuIE9iamVjdChyKHMpKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEyNikoITApO3QoODgpKFN0cmluZywiU3RyaW5nIixmdW5jdGlvbihzKXt0aGlzLl90PVN0cmluZyhzKSx0aGlzLl9pPTB9LGZ1bmN0aW9uKCl7dmFyIHM9dGhpcy5fdCxtPXRoaXMuX2kseTtyZXR1cm4gbT49cy5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfTooeT1yKHMsbSksdGhpcy5faSs9eS5sZW5ndGgse3ZhbHVlOnksZG9uZTohMX0pfSl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExNCkscz10KDg3KTtoLmV4cG9ydHM9ZnVuY3Rpb24obSl7cmV0dXJuIGZ1bmN0aW9uKHksYyl7dmFyIGw9U3RyaW5nKHMoeSkpLHU9cihjKSxNPWwubGVuZ3RoLGYsdjtyZXR1cm4gdTwwfHx1Pj1NP20/IiI6dm9pZCAwOihmPWwuY2hhckNvZGVBdCh1KSxmPDU1Mjk2fHxmPjU2MzE5fHx1KzE9PT1NfHwodj1sLmNoYXJDb2RlQXQodSsxKSk8NTYzMjB8fHY+NTczNDM/bT9sLmNoYXJBdCh1KTpmOm0/bC5zbGljZSh1LHUrMik6KGYtNTUyOTY8PDEwKSsodi01NjMyMCkrNjU1MzYpfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEyOCkscz10KDEyMikoIml0ZXJhdG9yIiksbT10KDgzKTtoLmV4cG9ydHM9dCg5MikuaXNJdGVyYWJsZT1mdW5jdGlvbih5KXt2YXIgYz1PYmplY3QoeSk7cmV0dXJuIGNbc10hPT12b2lkIDB8fCJAQGl0ZXJhdG9yImluIGN8fG0uaGFzT3duUHJvcGVydHkocihjKSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4Nikscz10KDEyMikoInRvU3RyaW5nVGFnIiksbT1yKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSk9PSJBcmd1bWVudHMiLHk9ZnVuY3Rpb24oYyxsKXt0cnl7cmV0dXJuIGNbbF19Y2F0Y2h7fX07aC5leHBvcnRzPWZ1bmN0aW9uKGMpe3ZhciBsLHUsTTtyZXR1cm4gYz09PXZvaWQgMD8iVW5kZWZpbmVkIjpjPT09bnVsbD8iTnVsbCI6dHlwZW9mKHU9eShsPU9iamVjdChjKSxzKSk9PSJzdHJpbmciP3U6bT9yKGwpOihNPXIobCkpPT0iT2JqZWN0IiYmdHlwZW9mIGwuY2FsbGVlPT0iZnVuY3Rpb24iPyJBcmd1bWVudHMiOk19fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMTMwKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoNzkpLHQoMTI1KSxoLmV4cG9ydHM9dCgxMzEpfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nykscz10KDEzMik7aC5leHBvcnRzPXQoOTIpLmdldEl0ZXJhdG9yPWZ1bmN0aW9uKG0pe3ZhciB5PXMobSk7aWYodHlwZW9mIHkhPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKG0rIiBpcyBub3QgaXRlcmFibGUhIik7cmV0dXJuIHIoeS5jYWxsKG0pKX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEyOCkscz10KDEyMikoIml0ZXJhdG9yIiksbT10KDgzKTtoLmV4cG9ydHM9dCg5MikuZ2V0SXRlcmF0b3JNZXRob2Q9ZnVuY3Rpb24oeSl7aWYoeSE9bnVsbClyZXR1cm4geVtzXXx8eVsiQEBpdGVyYXRvciJdfHxtW3IoeSldfX0sZnVuY3Rpb24oaCxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgcj10KDEzNCkscz1tKHIpO2Z1bmN0aW9uIG0oeSl7cmV0dXJuIHkmJnkuX19lc01vZHVsZT95OntkZWZhdWx0Onl9fWUuZGVmYXVsdD1mdW5jdGlvbih5KXtpZihBcnJheS5pc0FycmF5KHkpKXtmb3IodmFyIGM9MCxsPUFycmF5KHkubGVuZ3RoKTtjPHkubGVuZ3RoO2MrKylsW2NdPXlbY107cmV0dXJuIGx9ZWxzZSByZXR1cm4oMCxzLmRlZmF1bHQpKHkpfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17ZGVmYXVsdDp0KDEzNSksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDEyNSksdCgxMzYpLGguZXhwb3J0cz10KDkyKS5BcnJheS5mcm9tfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Mykscz10KDkwKSxtPXQoMTI0KSx5PXQoMTM3KSxjPXQoMTM4KSxsPXQoMTEzKSx1PXQoMTM5KSxNPXQoMTMyKTtzKHMuUytzLkYqIXQoMTQwKShmdW5jdGlvbihmKXtBcnJheS5mcm9tKGYpfSksIkFycmF5Iix7ZnJvbTpmdW5jdGlvbih2KXt2YXIgeD1tKHYpLFI9dHlwZW9mIHRoaXM9PSJmdW5jdGlvbiI/dGhpczpBcnJheSxPPWFyZ3VtZW50cy5sZW5ndGgsZz1PPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxwPWchPT12b2lkIDAsbj0wLGE9TSh4KSxpLG8sVCxBO2lmKHAmJihnPXIoZyxPPjI/YXJndW1lbnRzWzJdOnZvaWQgMCwyKSksYSE9bnVsbCYmIShSPT1BcnJheSYmYyhhKSkpZm9yKEE9YS5jYWxsKHgpLG89bmV3IFI7IShUPUEubmV4dCgpKS5kb25lO24rKyl1KG8sbixwP3koQSxnLFtULnZhbHVlLG5dLCEwKTpULnZhbHVlKTtlbHNlIGZvcihpPWwoeC5sZW5ndGgpLG89bmV3IFIoaSk7aT5uO24rKyl1KG8sbixwP2coeFtuXSxuKTp4W25dKTtyZXR1cm4gby5sZW5ndGg9bixvfX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nyk7aC5leHBvcnRzPWZ1bmN0aW9uKHMsbSx5LGMpe3RyeXtyZXR1cm4gYz9tKHIoeSlbMF0seVsxXSk6bSh5KX1jYXRjaCh1KXt2YXIgbD1zLnJldHVybjt0aHJvdyBsIT09dm9pZCAwJiZyKGwuY2FsbChzKSksdX19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4Mykscz10KDEyMikoIml0ZXJhdG9yIiksbT1BcnJheS5wcm90b3R5cGU7aC5leHBvcnRzPWZ1bmN0aW9uKHkpe3JldHVybiB5IT09dm9pZCAwJiYoci5BcnJheT09PXl8fG1bc109PT15KX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk2KSxzPXQoMTA0KTtoLmV4cG9ydHM9ZnVuY3Rpb24obSx5LGMpe3kgaW4gbT9yLmYobSx5LHMoMCxjKSk6bVt5XT1jfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTIyKSgiaXRlcmF0b3IiKSxzPSExO3RyeXt2YXIgbT1bN11bcl0oKTttLnJldHVybj1mdW5jdGlvbigpe3M9ITB9LEFycmF5LmZyb20obSxmdW5jdGlvbigpe3Rocm93IDJ9KX1jYXRjaHt9aC5leHBvcnRzPWZ1bmN0aW9uKHksYyl7aWYoIWMmJiFzKXJldHVybiExO3ZhciBsPSExO3RyeXt2YXIgdT1bN10sTT11W3JdKCk7TS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6bD0hMH19LHVbcl09ZnVuY3Rpb24oKXtyZXR1cm4gTX0seSh1KX1jYXRjaHt9cmV0dXJuIGx9fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMTQyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxNDQpLHQoMTU3KSx0KDE2MCksdCgxNjIpLGguZXhwb3J0cz10KDkyKS5NYXB9LGZ1bmN0aW9uKGgsZSl7fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxNDUpLHM9dCgxNTEpLG09Ik1hcCI7aC5leHBvcnRzPXQoMTUyKShtLGZ1bmN0aW9uKHkpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB5KHRoaXMsYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApfX0se2dldDpmdW5jdGlvbihjKXt2YXIgbD1yLmdldEVudHJ5KHModGhpcyxtKSxjKTtyZXR1cm4gbCYmbC52fSxzZXQ6ZnVuY3Rpb24oYyxsKXtyZXR1cm4gci5kZWYocyh0aGlzLG0pLGM9PT0wPzA6YyxsKX19LHIsITApfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5NikuZixzPXQoMTA4KSxtPXQoMTQ2KSx5PXQoOTMpLGM9dCgxNDcpLGw9dCgxNDgpLHU9dCg4OCksTT10KDgyKSxmPXQoMTQ5KSx2PXQoMTAwKSx4PXQoMTUwKS5mYXN0S2V5LFI9dCgxNTEpLE89dj8iX3MiOiJzaXplIixnPWZ1bmN0aW9uKHAsbil7dmFyIGE9eChuKSxpO2lmKGEhPT0iRiIpcmV0dXJuIHAuX2lbYV07Zm9yKGk9cC5fZjtpO2k9aS5uKWlmKGkuaz09bilyZXR1cm4gaX07aC5leHBvcnRzPXtnZXRDb25zdHJ1Y3RvcjpmdW5jdGlvbihwLG4sYSxpKXt2YXIgbz1wKGZ1bmN0aW9uKFQsQSl7YyhULG8sbiwiX2kiKSxULl90PW4sVC5faT1zKG51bGwpLFQuX2Y9dm9pZCAwLFQuX2w9dm9pZCAwLFRbT109MCxBIT1udWxsJiZsKEEsYSxUW2ldLFQpfSk7cmV0dXJuIG0oby5wcm90b3R5cGUse2NsZWFyOmZ1bmN0aW9uKCl7Zm9yKHZhciBBPVIodGhpcyxuKSxDPUEuX2ksST1BLl9mO0k7ST1JLm4pSS5yPSEwLEkucCYmKEkucD1JLnAubj12b2lkIDApLGRlbGV0ZSBDW0kuaV07QS5fZj1BLl9sPXZvaWQgMCxBW09dPTB9LGRlbGV0ZTpmdW5jdGlvbihUKXt2YXIgQT1SKHRoaXMsbiksQz1nKEEsVCk7aWYoQyl7dmFyIEk9Qy5uLFA9Qy5wO2RlbGV0ZSBBLl9pW0MuaV0sQy5yPSEwLFAmJihQLm49SSksSSYmKEkucD1QKSxBLl9mPT1DJiYoQS5fZj1JKSxBLl9sPT1DJiYoQS5fbD1QKSxBW09dLS19cmV0dXJuISFDfSxmb3JFYWNoOmZ1bmN0aW9uKEEpe1IodGhpcyxuKTtmb3IodmFyIEM9eShBLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLDMpLEk7ST1JP0kubjp0aGlzLl9mOylmb3IoQyhJLnYsSS5rLHRoaXMpO0kmJkkucjspST1JLnB9LGhhczpmdW5jdGlvbihBKXtyZXR1cm4hIWcoUih0aGlzLG4pLEEpfX0pLHYmJnIoby5wcm90b3R5cGUsInNpemUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUih0aGlzLG4pW09dfX0pLG99LGRlZjpmdW5jdGlvbihwLG4sYSl7dmFyIGk9ZyhwLG4pLG8sVDtyZXR1cm4gaT9pLnY9YToocC5fbD1pPXtpOlQ9eChuLCEwKSxrOm4sdjphLHA6bz1wLl9sLG46dm9pZCAwLHI6ITF9LHAuX2Z8fChwLl9mPWkpLG8mJihvLm49aSkscFtPXSsrLFQhPT0iRiImJihwLl9pW1RdPWkpKSxwfSxnZXRFbnRyeTpnLHNldFN0cm9uZzpmdW5jdGlvbihwLG4sYSl7dShwLG4sZnVuY3Rpb24oaSxvKXt0aGlzLl90PVIoaSxuKSx0aGlzLl9rPW8sdGhpcy5fbD12b2lkIDB9LGZ1bmN0aW9uKCl7Zm9yKHZhciBpPXRoaXMsbz1pLl9rLFQ9aS5fbDtUJiZULnI7KVQ9VC5wO3JldHVybiFpLl90fHwhKGkuX2w9VD1UP1QubjppLl90Ll9mKT8oaS5fdD12b2lkIDAsTSgxKSk6bz09ImtleXMiP00oMCxULmspOm89PSJ2YWx1ZXMiP00oMCxULnYpOk0oMCxbVC5rLFQudl0pfSxhPyJlbnRyaWVzIjoidmFsdWVzIiwhYSwhMCksZihuKX19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5NSk7aC5leHBvcnRzPWZ1bmN0aW9uKHMsbSx5KXtmb3IodmFyIGMgaW4gbSl5JiZzW2NdP3NbY109bVtjXTpyKHMsYyxtW2NdKTtyZXR1cm4gc319LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPWZ1bmN0aW9uKHQscixzLG0pe2lmKCEodCBpbnN0YW5jZW9mIHIpfHxtIT09dm9pZCAwJiZtIGluIHQpdGhyb3cgVHlwZUVycm9yKHMrIjogaW5jb3JyZWN0IGludm9jYXRpb24hIik7cmV0dXJuIHR9fSxmdW5jdGlvbihoLGYsdCl7dmFyIHI9dCg5Mykscz10KDEzNyksbT10KDEzOCkseT10KDk3KSxjPXQoMTEzKSxsPXQoMTMyKSx1PXt9LE09e30sZj1oLmV4cG9ydHM9ZnVuY3Rpb24odix4LFIsTyxnKXt2YXIgcD1nP2Z1bmN0aW9uKCl7cmV0dXJuIHZ9Omwodiksbj1yKFIsTyx4PzI6MSksYT0wLGksbyxULEE7aWYodHlwZW9mIHAhPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKHYrIiBpcyBub3QgaXRlcmFibGUhIik7aWYobShwKSl7Zm9yKGk9Yyh2Lmxlbmd0aCk7aT5hO2ErKylpZihBPXg/bih5KG89dlthXSlbMF0sb1sxXSk6bih2W2FdKSxBPT09dXx8QT09PU0pcmV0dXJuIEF9ZWxzZSBmb3IoVD1wLmNhbGwodik7IShvPVQubmV4dCgpKS5kb25lOylpZihBPXMoVCxuLG8udmFsdWUseCksQT09PXV8fEE9PT1NKXJldHVybiBBfTtmLkJSRUFLPXUsZi5SRVRVUk49TX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTEpLHM9dCg5MiksbT10KDk2KSx5PXQoMTAwKSxjPXQoMTIyKSgic3BlY2llcyIpO2guZXhwb3J0cz1mdW5jdGlvbihsKXt2YXIgdT10eXBlb2Ygc1tsXT09ImZ1bmN0aW9uIj9zW2xdOnJbbF07eSYmdSYmIXVbY10mJm0uZih1LGMse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExOCkoIm1ldGEiKSxzPXQoOTgpLG09dCgxMDUpLHk9dCg5NikuZixjPTAsbD1PYmplY3QuaXNFeHRlbnNpYmxlfHxmdW5jdGlvbigpe3JldHVybiEwfSx1PSF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gbChPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKX0pLE09ZnVuY3Rpb24oTyl7eShPLHIse3ZhbHVlOntpOiJPIisgKytjLHc6e319fSl9LGY9ZnVuY3Rpb24oTyxnKXtpZighcyhPKSlyZXR1cm4gdHlwZW9mIE89PSJzeW1ib2wiP086KHR5cGVvZiBPPT0ic3RyaW5nIj8iUyI6IlAiKStPO2lmKCFtKE8scikpe2lmKCFsKE8pKXJldHVybiJGIjtpZighZylyZXR1cm4iRSI7TShPKX1yZXR1cm4gT1tyXS5pfSx2PWZ1bmN0aW9uKE8sZyl7aWYoIW0oTyxyKSl7aWYoIWwoTykpcmV0dXJuITA7aWYoIWcpcmV0dXJuITE7TShPKX1yZXR1cm4gT1tyXS53fSx4PWZ1bmN0aW9uKE8pe3JldHVybiB1JiZSLk5FRUQmJmwoTykmJiFtKE8scikmJk0oTyksT30sUj1oLmV4cG9ydHM9e0tFWTpyLE5FRUQ6ITEsZmFzdEtleTpmLGdldFdlYWs6dixvbkZyZWV6ZTp4fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTgpO2guZXhwb3J0cz1mdW5jdGlvbihzLG0pe2lmKCFyKHMpfHxzLl90IT09bSl0aHJvdyBUeXBlRXJyb3IoIkluY29tcGF0aWJsZSByZWNlaXZlciwgIittKyIgcmVxdWlyZWQhIik7cmV0dXJuIHN9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MSkscz10KDkwKSxtPXQoMTUwKSx5PXQoMTAxKSxjPXQoOTUpLGw9dCgxNDYpLHU9dCgxNDgpLE09dCgxNDcpLGY9dCg5OCksdj10KDEyMSkseD10KDk2KS5mLFI9dCgxNTMpKDApLE89dCgxMDApO2guZXhwb3J0cz1mdW5jdGlvbihnLHAsbixhLGksbyl7dmFyIFQ9cltnXSxBPVQsQz1pPyJzZXQiOiJhZGQiLEk9QSYmQS5wcm90b3R5cGUsUD17fTtyZXR1cm4hT3x8dHlwZW9mIEEhPSJmdW5jdGlvbiJ8fCEob3x8SS5mb3JFYWNoJiYheShmdW5jdGlvbigpe25ldyBBKCkuZW50cmllcygpLm5leHQoKX0pKT8oQT1hLmdldENvbnN0cnVjdG9yKHAsZyxpLEMpLGwoQS5wcm90b3R5cGUsbiksbS5ORUVEPSEwKTooQT1wKGZ1bmN0aW9uKEwsRCl7TShMLEEsZywiX2MiKSxMLl9jPW5ldyBULEQhPW51bGwmJnUoRCxpLExbQ10sTCl9KSxSKCJhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04iLnNwbGl0KCIsIiksZnVuY3Rpb24oTCl7dmFyIEQ9TD09ImFkZCJ8fEw9PSJzZXQiO0wgaW4gSSYmIShvJiZMPT0iY2xlYXIiKSYmYyhBLnByb3RvdHlwZSxMLGZ1bmN0aW9uKGIsUyl7aWYoTSh0aGlzLEEsTCksIUQmJm8mJiFmKGIpKXJldHVybiBMPT0iZ2V0Ij92b2lkIDA6ITE7dmFyIEI9dGhpcy5fY1tMXShiPT09MD8wOmIsUyk7cmV0dXJuIEQ/dGhpczpCfSl9KSxvfHx4KEEucHJvdG90eXBlLCJzaXplIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Muc2l6ZX19KSksdihBLGcpLFBbZ109QSxzKHMuRytzLlcrcy5GLFApLG98fGEuc2V0U3Ryb25nKEEsZyxpKSxBfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTMpLHM9dCg4NSksbT10KDEyNCkseT10KDExMyksYz10KDE1NCk7aC5leHBvcnRzPWZ1bmN0aW9uKGwsdSl7dmFyIE09bD09MSxmPWw9PTIsdj1sPT0zLHg9bD09NCxSPWw9PTYsTz1sPT01fHxSLGc9dXx8YztyZXR1cm4gZnVuY3Rpb24ocCxuLGEpe2Zvcih2YXIgaT1tKHApLG89cyhpKSxUPXIobixhLDMpLEE9eShvLmxlbmd0aCksQz0wLEk9TT9nKHAsQSk6Zj9nKHAsMCk6dm9pZCAwLFAsTDtBPkM7QysrKWlmKChPfHxDIGluIG8pJiYoUD1vW0NdLEw9VChQLEMsaSksbCkpe2lmKE0pSVtDXT1MO2Vsc2UgaWYoTClzd2l0Y2gobCl7Y2FzZSAzOnJldHVybiEwO2Nhc2UgNTpyZXR1cm4gUDtjYXNlIDY6cmV0dXJuIEM7Y2FzZSAyOkkucHVzaChQKX1lbHNlIGlmKHgpcmV0dXJuITF9cmV0dXJuIFI/LTE6dnx8eD94Okl9fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTU1KTtoLmV4cG9ydHM9ZnVuY3Rpb24ocyxtKXtyZXR1cm4gbmV3KHIocykpKG0pfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTgpLHM9dCgxNTYpLG09dCgxMjIpKCJzcGVjaWVzIik7aC5leHBvcnRzPWZ1bmN0aW9uKHkpe3ZhciBjO3JldHVybiBzKHkpJiYoYz15LmNvbnN0cnVjdG9yLHR5cGVvZiBjPT0iZnVuY3Rpb24iJiYoYz09PUFycmF5fHxzKGMucHJvdG90eXBlKSkmJihjPXZvaWQgMCkscihjKSYmKGM9Y1ttXSxjPT09bnVsbCYmKGM9dm9pZCAwKSkpLGM9PT12b2lkIDA/QXJyYXk6Y319LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg2KTtoLmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24obSl7cmV0dXJuIHIobSk9PSJBcnJheSJ9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCk7cihyLlArci5SLCJNYXAiLHt0b0pTT046dCgxNTgpKCJNYXAiKX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMjgpLHM9dCgxNTkpO2guZXhwb3J0cz1mdW5jdGlvbihtKXtyZXR1cm4gZnVuY3Rpb24oKXtpZihyKHRoaXMpIT1tKXRocm93IFR5cGVFcnJvcihtKyIjdG9KU09OIGlzbid0IGdlbmVyaWMiKTtyZXR1cm4gcyh0aGlzKX19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxNDgpO2guZXhwb3J0cz1mdW5jdGlvbihzLG0pe3ZhciB5PVtdO3JldHVybiByKHMsITEseS5wdXNoLHksbSkseX19LGZ1bmN0aW9uKGgsZSx0KXt0KDE2MSkoIk1hcCIpfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5MCk7aC5leHBvcnRzPWZ1bmN0aW9uKHMpe3Ioci5TLHMse29mOmZ1bmN0aW9uKCl7Zm9yKHZhciB5PWFyZ3VtZW50cy5sZW5ndGgsYz1uZXcgQXJyYXkoeSk7eS0tOyljW3ldPWFyZ3VtZW50c1t5XTtyZXR1cm4gbmV3IHRoaXMoYyl9fSl9fSxmdW5jdGlvbihoLGUsdCl7dCgxNjMpKCJNYXAiKX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApLHM9dCg5NCksbT10KDkzKSx5PXQoMTQ4KTtoLmV4cG9ydHM9ZnVuY3Rpb24oYyl7cihyLlMsYyx7ZnJvbTpmdW5jdGlvbih1KXt2YXIgTT1hcmd1bWVudHNbMV0sZix2LHgsUjtyZXR1cm4gcyh0aGlzKSxmPU0hPT12b2lkIDAsZiYmcyhNKSx1PT1udWxsP25ldyB0aGlzOih2PVtdLGY/KHg9MCxSPW0oTSxhcmd1bWVudHNbMl0sMikseSh1LCExLGZ1bmN0aW9uKE8pe3YucHVzaChSKE8seCsrKSl9KSk6eSh1LCExLHYucHVzaCx2KSxuZXcgdGhpcyh2KSl9fSl9fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMTY1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTY2KSxoLmV4cG9ydHM9dCg5MikuT2JqZWN0LmFzc2lnbn0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApO3Ioci5TK3IuRiwiT2JqZWN0Iix7YXNzaWduOnQoMTY3KX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMDApLHM9dCgxMTApLG09dCgxNjgpLHk9dCgxNjkpLGM9dCgxMjQpLGw9dCg4NSksdT1PYmplY3QuYXNzaWduO2guZXhwb3J0cz0hdXx8dCgxMDEpKGZ1bmN0aW9uKCl7dmFyIE09e30sZj17fSx2PVN5bWJvbCgpLHg9ImFiY2RlZmdoaWprbG1ub3BxcnN0IjtyZXR1cm4gTVt2XT03LHguc3BsaXQoIiIpLmZvckVhY2goZnVuY3Rpb24oUil7ZltSXT1SfSksdSh7fSxNKVt2XSE9N3x8T2JqZWN0LmtleXModSh7fSxmKSkuam9pbigiIikhPXh9KT9mdW5jdGlvbihmLHYpe2Zvcih2YXIgeD1jKGYpLFI9YXJndW1lbnRzLmxlbmd0aCxPPTEsZz1tLmYscD15LmY7Uj5POylmb3IodmFyIG49bChhcmd1bWVudHNbTysrXSksYT1nP3MobikuY29uY2F0KGcobikpOnMobiksaT1hLmxlbmd0aCxvPTAsVDtpPm87KVQ9YVtvKytdLCghcnx8cC5jYWxsKG4sVCkpJiYoeFtUXT1uW1RdKTtyZXR1cm4geH06dX0sZnVuY3Rpb24oaCxlKXtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc30sZnVuY3Rpb24oaCxlKXtlLmY9e30ucHJvcGVydHlJc0VudW1lcmFibGV9LGZ1bmN0aW9uKGgsZSx0KXtlLl9fZXNNb2R1bGU9ITAsZS5kZWZhdWx0PWZ1bmN0aW9uKHIscyl7aWYoIShyIGluc3RhbmNlb2YgcykpdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIil9fSxmdW5jdGlvbihoLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciByPXQoMTcyKSxzPW0ocik7ZnVuY3Rpb24gbSh5KXtyZXR1cm4geSYmeS5fX2VzTW9kdWxlP3k6e2RlZmF1bHQ6eX19ZS5kZWZhdWx0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24geShjLGwpe2Zvcih2YXIgdT0wO3U8bC5sZW5ndGg7dSsrKXt2YXIgTT1sW3VdO00uZW51bWVyYWJsZT1NLmVudW1lcmFibGV8fCExLE0uY29uZmlndXJhYmxlPSEwLCJ2YWx1ZSJpbiBNJiYoTS53cml0YWJsZT0hMCksKDAscy5kZWZhdWx0KShjLE0ua2V5LE0pfX1yZXR1cm4gZnVuY3Rpb24oYyxsLHUpe3JldHVybiBsJiZ5KGMucHJvdG90eXBlLGwpLHUmJnkoYyx1KSxjfX0oKX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17ZGVmYXVsdDp0KDE3MyksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDE3NCk7dmFyIHI9dCg5MikuT2JqZWN0O2guZXhwb3J0cz1mdW5jdGlvbihtLHksYyl7cmV0dXJuIHIuZGVmaW5lUHJvcGVydHkobSx5LGMpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApO3Ioci5TK3IuRiohdCgxMDApLCJPYmplY3QiLHtkZWZpbmVQcm9wZXJ0eTp0KDk2KS5mfSl9LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNzYpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihoLGUsdCl7dCgxNzcpLHQoMTQzKSx0KDE4NCksdCgxODUpLGguZXhwb3J0cz10KDkyKS5TeW1ib2x9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkxKSxzPXQoMTA1KSxtPXQoMTAwKSx5PXQoOTApLGM9dCgxMDYpLGw9dCgxNTApLktFWSx1PXQoMTAxKSxNPXQoMTE3KSxmPXQoMTIxKSx2PXQoMTE4KSx4PXQoMTIyKSxSPXQoMTc4KSxPPXQoMTc5KSxnPXQoMTgwKSxwPXQoMTU2KSxuPXQoOTcpLGE9dCg5OCksaT10KDEyNCksbz10KDg0KSxUPXQoMTAzKSxBPXQoMTA0KSxDPXQoMTA4KSxJPXQoMTgxKSxQPXQoMTgzKSxMPXQoMTY4KSxEPXQoOTYpLGI9dCgxMTApLFM9UC5mLEI9RC5mLHc9SS5mLEg9ci5TeW1ib2wsSj1yLkpTT04scT1KJiZKLnN0cmluZ2lmeSxXPSJwcm90b3R5cGUiLEc9eCgiX2hpZGRlbiIpLFE9eCgidG9QcmltaXRpdmUiKSx0dD17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxfPU0oInN5bWJvbC1yZWdpc3RyeSIpLHN0PU0oInN5bWJvbHMiKSxrPU0oIm9wLXN5bWJvbHMiKSxjdD1PYmplY3RbV10sZnQ9dHlwZW9mIEg9PSJmdW5jdGlvbiImJiEhTC5mLFU9ci5RT2JqZWN0LEY9IVV8fCFVW1ddfHwhVVtXXS5maW5kQ2hpbGQsVj1tJiZ1KGZ1bmN0aW9uKCl7cmV0dXJuIEMoQih7fSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiBCKHRoaXMsImEiLHt2YWx1ZTo3fSkuYX19KSkuYSE9N30pP2Z1bmN0aW9uKGl0LG50LG90KXt2YXIgZHQ9UyhjdCxudCk7ZHQmJmRlbGV0ZSBjdFtudF0sQihpdCxudCxvdCksZHQmJml0IT09Y3QmJkIoY3QsbnQsZHQpfTpCLFg9ZnVuY3Rpb24oaXQpe3ZhciBudD1zdFtpdF09QyhIW1ddKTtyZXR1cm4gbnQuX2s9aXQsbnR9LGo9ZnQmJnR5cGVvZiBILml0ZXJhdG9yPT0ic3ltYm9sIj9mdW5jdGlvbihpdCl7cmV0dXJuIHR5cGVvZiBpdD09InN5bWJvbCJ9OmZ1bmN0aW9uKGl0KXtyZXR1cm4gaXQgaW5zdGFuY2VvZiBIfSx6PWZ1bmN0aW9uKG50LG90LGR0KXtyZXR1cm4gbnQ9PT1jdCYmeihrLG90LGR0KSxuKG50KSxvdD1UKG90LCEwKSxuKGR0KSxzKHN0LG90KT8oZHQuZW51bWVyYWJsZT8ocyhudCxHKSYmbnRbR11bb3RdJiYobnRbR11bb3RdPSExKSxkdD1DKGR0LHtlbnVtZXJhYmxlOkEoMCwhMSl9KSk6KHMobnQsRyl8fEIobnQsRyxBKDEse30pKSxudFtHXVtvdF09ITApLFYobnQsb3QsZHQpKTpCKG50LG90LGR0KX0sZD1mdW5jdGlvbihudCxvdCl7bihudCk7Zm9yKHZhciBkdD1nKG90PW8ob3QpKSxndD0wLHV0PWR0Lmxlbmd0aCxtdDt1dD5ndDspeihudCxtdD1kdFtndCsrXSxvdFttdF0pO3JldHVybiBudH0sRT1mdW5jdGlvbihudCxvdCl7cmV0dXJuIG90PT09dm9pZCAwP0MobnQpOmQoQyhudCksb3QpfSxOPWZ1bmN0aW9uKG50KXt2YXIgb3Q9dHQuY2FsbCh0aGlzLG50PVQobnQsITApKTtyZXR1cm4gdGhpcz09PWN0JiZzKHN0LG50KSYmIXMoayxudCk/ITE6b3R8fCFzKHRoaXMsbnQpfHwhcyhzdCxudCl8fHModGhpcyxHKSYmdGhpc1tHXVtudF0/b3Q6ITB9LCQ9ZnVuY3Rpb24obnQsb3Qpe2lmKG50PW8obnQpLG90PVQob3QsITApLCEobnQ9PT1jdCYmcyhzdCxvdCkmJiFzKGssb3QpKSl7dmFyIGR0PVMobnQsb3QpO3JldHVybiBkdCYmcyhzdCxvdCkmJiEocyhudCxHKSYmbnRbR11bb3RdKSYmKGR0LmVudW1lcmFibGU9ITApLGR0fX0sSz1mdW5jdGlvbihudCl7Zm9yKHZhciBvdD13KG8obnQpKSxkdD1bXSxndD0wLHV0O290Lmxlbmd0aD5ndDspIXMoc3QsdXQ9b3RbZ3QrK10pJiZ1dCE9RyYmdXQhPWwmJmR0LnB1c2godXQpO3JldHVybiBkdH0sWT1mdW5jdGlvbihudCl7Zm9yKHZhciBvdD1udD09PWN0LGR0PXcob3Q/azpvKG50KSksZ3Q9W10sdXQ9MCxtdDtkdC5sZW5ndGg+dXQ7KXMoc3QsbXQ9ZHRbdXQrK10pJiYoIW90fHxzKGN0LG10KSkmJmd0LnB1c2goc3RbbXRdKTtyZXR1cm4gZ3R9O2Z0fHwoSD1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBIKXRocm93IFR5cGVFcnJvcigiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yISIpO3ZhciBudD12KGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKSxvdD1mdW5jdGlvbihkdCl7dGhpcz09PWN0JiZvdC5jYWxsKGssZHQpLHModGhpcyxHKSYmcyh0aGlzW0ddLG50KSYmKHRoaXNbR11bbnRdPSExKSxWKHRoaXMsbnQsQSgxLGR0KSl9O3JldHVybiBtJiZGJiZWKGN0LG50LHtjb25maWd1cmFibGU6ITAsc2V0Om90fSksWChudCl9LGMoSFtXXSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2t9KSxQLmY9JCxELmY9eix0KDE4MikuZj1JLmY9Syx0KDE2OSkuZj1OLEwuZj1ZLG0mJiF0KDg5KSYmYyhjdCwicHJvcGVydHlJc0VudW1lcmFibGUiLE4sITApLFIuZj1mdW5jdGlvbihpdCl7cmV0dXJuIFgoeChpdCkpfSkseSh5LkcreS5XK3kuRiohZnQse1N5bWJvbDpIfSk7Zm9yKHZhciBaPSJoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcyIuc3BsaXQoIiwiKSxldD0wO1oubGVuZ3RoPmV0Oyl4KFpbZXQrK10pO2Zvcih2YXIgcnQ9Yih4LnN0b3JlKSxhdD0wO3J0Lmxlbmd0aD5hdDspTyhydFthdCsrXSk7eSh5LlMreS5GKiFmdCwiU3ltYm9sIix7Zm9yOmZ1bmN0aW9uKGl0KXtyZXR1cm4gcyhfLGl0Kz0iIik/X1tpdF06X1tpdF09SChpdCl9LGtleUZvcjpmdW5jdGlvbihudCl7aWYoIWoobnQpKXRocm93IFR5cGVFcnJvcihudCsiIGlzIG5vdCBhIHN5bWJvbCEiKTtmb3IodmFyIG90IGluIF8paWYoX1tvdF09PT1udClyZXR1cm4gb3R9LHVzZVNldHRlcjpmdW5jdGlvbigpe0Y9ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpe0Y9ITF9fSkseSh5LlMreS5GKiFmdCwiT2JqZWN0Iix7Y3JlYXRlOkUsZGVmaW5lUHJvcGVydHk6eixkZWZpbmVQcm9wZXJ0aWVzOmQsZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiQsZ2V0T3duUHJvcGVydHlOYW1lczpLLGdldE93blByb3BlcnR5U3ltYm9sczpZfSk7dmFyIGx0PXUoZnVuY3Rpb24oKXtMLmYoMSl9KTt5KHkuUyt5LkYqbHQsIk9iamVjdCIse2dldE93blByb3BlcnR5U3ltYm9sczpmdW5jdGlvbihudCl7cmV0dXJuIEwuZihpKG50KSl9fSksSiYmeSh5LlMreS5GKighZnR8fHUoZnVuY3Rpb24oKXt2YXIgaXQ9SCgpO3JldHVybiBxKFtpdF0pIT0iW251bGxdInx8cSh7YTppdH0pIT0ie30ifHxxKE9iamVjdChpdCkpIT0ie30ifSkpLCJKU09OIix7c3RyaW5naWZ5OmZ1bmN0aW9uKG50KXtmb3IodmFyIG90PVtudF0sZHQ9MSxndCx1dDthcmd1bWVudHMubGVuZ3RoPmR0OylvdC5wdXNoKGFyZ3VtZW50c1tkdCsrXSk7aWYodXQ9Z3Q9b3RbMV0sISghYShndCkmJm50PT09dm9pZCAwfHxqKG50KSkpcmV0dXJuIHAoZ3QpfHwoZ3Q9ZnVuY3Rpb24obXQsT3Qpe2lmKHR5cGVvZiB1dD09ImZ1bmN0aW9uIiYmKE90PXV0LmNhbGwodGhpcyxtdCxPdCkpLCFqKE90KSlyZXR1cm4gT3R9KSxvdFsxXT1ndCxxLmFwcGx5KEosb3QpfX0pLEhbV11bUV18fHQoOTUpKEhbV10sUSxIW1ddLnZhbHVlT2YpLGYoSCwiU3ltYm9sIiksZihNYXRoLCJNYXRoIiwhMCksZihyLkpTT04sIkpTT04iLCEwKX0sZnVuY3Rpb24oaCxlLHQpe2UuZj10KDEyMil9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkxKSxzPXQoOTIpLG09dCg4OSkseT10KDE3OCksYz10KDk2KS5mO2guZXhwb3J0cz1mdW5jdGlvbihsKXt2YXIgdT1zLlN5bWJvbHx8KHMuU3ltYm9sPW0/e306ci5TeW1ib2x8fHt9KTtsLmNoYXJBdCgwKSE9Il8iJiYhKGwgaW4gdSkmJmModSxsLHt2YWx1ZTp5LmYobCl9KX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDExMCkscz10KDE2OCksbT10KDE2OSk7aC5leHBvcnRzPWZ1bmN0aW9uKHkpe3ZhciBjPXIoeSksbD1zLmY7aWYobClmb3IodmFyIHU9bCh5KSxNPW0uZixmPTAsdjt1Lmxlbmd0aD5mOylNLmNhbGwoeSx2PXVbZisrXSkmJmMucHVzaCh2KTtyZXR1cm4gY319LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDg0KSxzPXQoMTgyKS5mLG09e30udG9TdHJpbmcseT10eXBlb2Ygd2luZG93PT0ib2JqZWN0IiYmd2luZG93JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpOltdLGM9ZnVuY3Rpb24obCl7dHJ5e3JldHVybiBzKGwpfWNhdGNoe3JldHVybiB5LnNsaWNlKCl9fTtoLmV4cG9ydHMuZj1mdW5jdGlvbih1KXtyZXR1cm4geSYmbS5jYWxsKHUpPT0iW29iamVjdCBXaW5kb3ddIj9jKHUpOnMocih1KSl9fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgxMTEpLHM9dCgxMTkpLmNvbmNhdCgibGVuZ3RoIiwicHJvdG90eXBlIik7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbih5KXtyZXR1cm4gcih5LHMpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTY5KSxzPXQoMTA0KSxtPXQoODQpLHk9dCgxMDMpLGM9dCgxMDUpLGw9dCg5OSksdT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2UuZj10KDEwMCk/dTpmdW5jdGlvbihmLHYpe2lmKGY9bShmKSx2PXkodiwhMCksbCl0cnl7cmV0dXJuIHUoZix2KX1jYXRjaHt9aWYoYyhmLHYpKXJldHVybiBzKCFyLmYuY2FsbChmLHYpLGZbdl0pfX0sZnVuY3Rpb24oaCxlLHQpe3QoMTc5KSgiYXN5bmNJdGVyYXRvciIpfSxmdW5jdGlvbihoLGUsdCl7dCgxNzkpKCJvYnNlcnZhYmxlIil9LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5jcmVhdGVOb3dUaW1lPXIsZS5mb3JtYXREZWxheT1zO2Z1bmN0aW9uIHIoKXt2YXIgbT1udWxsO3JldHVybiBEYXRlLm5vdz9tPURhdGUubm93Om09ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCl9LG19ZnVuY3Rpb24gcyhtKXtyZXR1cm4gdHlwZW9mIG09PSJudW1iZXIiP209e2RlbGF5Om19OiJlbnRyb3B5ImluIG0mJihtPXtkZWxheTptLmVudHJvcHksaXNFbnRyb3B5OiEwfSksbX19LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PXtkZWZhdWx0OmZ1bmN0aW9uKHMsbSx5LGMsbCl7cmV0dXJuIHR5cGVvZiBzPT0ibnVtYmVyIiYmdHlwZW9mIG09PSJudW1iZXIiP3MrKHktYykvKGwtYykqKG0tcyk6eS1jPmwteT9tOnN9fX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLnBhcnNlRWFzaW5nPWUuRWFzaW5ncz12b2lkIDA7dmFyIHI9dCg3Nikscz11KHIpLG09dCgxMzMpLHk9dShtKSxjPXQoMTQxKSxsPXUoYyk7ZnVuY3Rpb24gdShwKXtyZXR1cm4gcCYmcC5fX2VzTW9kdWxlP3A6e2RlZmF1bHQ6cH19dmFyIE09dCgxODkpLGY9bmV3IGwuZGVmYXVsdDtmdW5jdGlvbiB2KCl7Zm9yKHZhciBwPWFyZ3VtZW50cy5sZW5ndGgsbj1BcnJheShwKSxhPTA7YTxwO2ErKyluW2FdPWFyZ3VtZW50c1thXTt2YXIgaT1mLmdldChuKTtyZXR1cm4gaXx8KGk9TS5hcHBseSh2b2lkIDAsbiksZi5zZXQobixpKSxpKX1mdW5jdGlvbiB4KHApe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXToiZW5kIjtyZXR1cm4gZnVuY3Rpb24oYSxpKXtmb3IodmFyIG89MTtvPGkubGVuZ3RoO28rKyl7dmFyIFQ9aVtvXS5vZmZzZXQ7aWYoYTw9VCl7dmFyIEE9aVtvLTFdLm9mZnNldCxDPVQsST0oYS1BKS8oQy1BKSxQPTEvcCxMPUkvUDtyZXR1cm4gbj09PSJlbmQiP0w9TWF0aC5mbG9vcihMKTpMPU1hdGguY2VpbChMKSxQKkwqKEMtQSkrQX19cmV0dXJuIDB9fWZ1bmN0aW9uIFIocCl7dmFyIG49L15jdWJpYy1iZXppZXJcKCguKilcKS8sYT1wLm1hdGNoKG4pO2lmKGEpe3ZhciBpPWFbMV0udHJpbSgpO3JldHVybiBpPWkuc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oUCl7cmV0dXJuIHBhcnNlRmxvYXQoUC50cmltKCkpfSksdi5hcHBseSh2b2lkIDAsKDAseS5kZWZhdWx0KShpKSl9aWYobj0vXnN0ZXBzXCgoLiopXCkvLGE9cC5tYXRjaChuKSxhKXt2YXIgbz1hWzFdLnRyaW0oKTtvPW8uc3BsaXQoIiwiKS5tYXAoZnVuY3Rpb24oUCl7cmV0dXJuIFAudHJpbSgpfSk7dmFyIFQ9byxBPSgwLHMuZGVmYXVsdCkoVCwyKSxDPUFbMF0sST1BWzFdO3JldHVybiB4KHBhcnNlSW50KEMsMTApLEkpfXJldHVybiBwfXZhciBPPXtsaW5lYXI6ZnVuY3Rpb24obil7cmV0dXJuIG59LGVhc2U6diguMjUsLjEsLjI1LDEpLCJlYXNlLWluIjp2KC40MiwwLDEsMSksImVhc2Utb3V0Ijp2KDAsMCwuNTgsMSksImVhc2UtaW4tb3V0Ijp2KC40MiwwLC41OCwxKSwic3RlcC1zdGFydCI6eCgxLCJzdGFydCIpLCJzdGVwLWVuZCI6eCgxLCJlbmQiKX07ZnVuY3Rpb24gZyhwKXtyZXR1cm4gdHlwZW9mIHA9PSJzdHJpbmciP09bcF0/cD1PW3BdOnA9UihwKTpwLnR5cGU9PT0iY3ViaWMtYmV6aWVyIj9wPXYuYXBwbHkodm9pZCAwLCgwLHkuZGVmYXVsdCkocC52YWx1ZSkpOnAudHlwZT09PSJzdGVwcyImJihwPXgocC5zdGVwLHAucG9zKSkscH1lLkVhc2luZ3M9TyxlLnBhcnNlRWFzaW5nPWd9LGZ1bmN0aW9uKGgsZSl7dmFyIHQ9NCxyPS4wMDEscz0xZS03LG09MTAseT0xMSxjPTEvKHktMSksbD10eXBlb2YgRmxvYXQzMkFycmF5PT0iZnVuY3Rpb24iO2Z1bmN0aW9uIHUocCxuKXtyZXR1cm4gMS0zKm4rMypwfWZ1bmN0aW9uIE0ocCxuKXtyZXR1cm4gMypuLTYqcH1mdW5jdGlvbiBmKHApe3JldHVybiAzKnB9ZnVuY3Rpb24gdihwLG4sYSl7cmV0dXJuKCh1KG4sYSkqcCtNKG4sYSkpKnArZihuKSkqcH1mdW5jdGlvbiB4KHAsbixhKXtyZXR1cm4gMyp1KG4sYSkqcCpwKzIqTShuLGEpKnArZihuKX1mdW5jdGlvbiBSKHAsbixhLGksbyl7dmFyIFQsQSxDPTA7ZG8gQT1uKyhhLW4pLzIsVD12KEEsaSxvKS1wLFQ+MD9hPUE6bj1BO3doaWxlKE1hdGguYWJzKFQpPnMmJisrQzxtKTtyZXR1cm4gQX1mdW5jdGlvbiBPKHAsbixhLGkpe2Zvcih2YXIgbz0wO288dDsrK28pe3ZhciBUPXgobixhLGkpO2lmKFQ9PT0wKXJldHVybiBuO3ZhciBBPXYobixhLGkpLXA7bi09QS9UfXJldHVybiBufWZ1bmN0aW9uIGcocCl7cmV0dXJuIHB9aC5leHBvcnRzPWZ1bmN0aW9uKG4sYSxpLG8pe2lmKCEoMDw9biYmbjw9MSYmMDw9aSYmaTw9MSkpdGhyb3cgbmV3IEVycm9yKCJiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2UiKTtpZihuPT09YSYmaT09PW8pcmV0dXJuIGc7Zm9yKHZhciBUPWw/bmV3IEZsb2F0MzJBcnJheSh5KTpuZXcgQXJyYXkoeSksQT0wO0E8eTsrK0EpVFtBXT12KEEqYyxuLGkpO2Z1bmN0aW9uIEMoSSl7Zm9yKHZhciBQPTAsTD0xLEQ9eS0xO0whPT1EJiZUW0xdPD1JOysrTClQKz1jOy0tTDt2YXIgYj0oSS1UW0xdKS8oVFtMKzFdLVRbTF0pLFM9UCtiKmMsQj14KFMsbixpKTtyZXR1cm4gQj49cj9PKEksUyxuLGkpOkI9PT0wP1M6UihJLFAsUCtjLG4saSl9cmV0dXJuIGZ1bmN0aW9uKFApe3JldHVybiBQPT09MD8wOlA9PT0xPzE6dihDKFApLGEsbyl9fX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj10KDE5MSkscz1hKHIpLG09dCgyMDQpLHk9YShtKSxjPXQoMTY0KSxsPWEoYyksdT10KDE3MCksTT1hKHUpLGY9dCgxNzEpLHY9YShmKSx4PXQoMTc1KSxSPWEoeCksTz10KDc1KSxnPWEoTykscD10KDIwOCksbj10KDE4OCk7ZnVuY3Rpb24gYShCKXtyZXR1cm4gQiYmQi5fX2VzTW9kdWxlP0I6e2RlZmF1bHQ6Qn19dmFyIGk9KDAsUi5kZWZhdWx0KSgidGltaW5nIiksbz0oMCxSLmRlZmF1bHQpKCJrZXlmcmFtZXMiKSxUPSgwLFIuZGVmYXVsdCkoImluaXRTdGF0ZSIpLEE9KDAsUi5kZWZhdWx0KSgicmVhZHlEZWZlciIpLEM9KDAsUi5kZWZhdWx0KSgiZmluaXNoZWREZWZlciIpLEk9KDAsUi5kZWZhdWx0KSgiZWZmZWN0cyIpLFA9KDAsUi5kZWZhdWx0KSgiYWN0aXZlUmVhZHlUaW1lciIpLEw9KDAsUi5kZWZhdWx0KSgiYWN0aXZlRmluaXNoVGltZXIiKSxEPSgwLFIuZGVmYXVsdCkoInJlbW92ZURlZmVyIiksYj17ZGVsYXk6MCxlbmREZWxheTowLGZpbGw6ImF1dG8iLGl0ZXJhdGlvbnM6MSxwbGF5YmFja1JhdGU6MSxkaXJlY3Rpb246Im5vcm1hbCIsZWFzaW5nOiJsaW5lYXIiLGVmZmVjdDpudWxsfSxTPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gQih3LEgsSil7dmFyIHE9dGhpcztpZigoMCxNLmRlZmF1bHQpKHRoaXMsQiksQXJyYXkuaXNBcnJheSh3KSl7dmFyIFc9W3dbMF0sdyxIXTt3PVdbMF0sSD1XWzFdLEo9V1syXX10eXBlb2YgSj09Im51bWJlciImJihKPXtkdXJhdGlvbjpKfSksdGhpc1tpXT0oMCxsLmRlZmF1bHQpKHt9LGIsSiksdGhpc1tpXS5lYXNpbmc9KDAsbi5wYXJzZUVhc2luZykodGhpc1tpXS5lYXNpbmcpLHRoaXNbb109KDAscC5jYWxjdWxhdGVGcmFtZXNPZmZzZXQpKEgpO3ZhciBHPXRoaXNbb11bdGhpc1tvXS5sZW5ndGgtMV07dGhpc1tUXT17fSwoMCx5LmRlZmF1bHQpKEcpLmZvckVhY2goZnVuY3Rpb24oUSl7T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHcsUSkmJlEhPT0iZWFzaW5nIiYmUSE9PSJvZmZzZXQiJiYocVtUXVtRXT13W1FdKX0pLHRoaXNbb109dGhpc1tvXS5tYXAoZnVuY3Rpb24oUSl7cmV0dXJuKDAsbC5kZWZhdWx0KSh7fSxxW1RdLFEpfSksdGhpc1tvXVswXS5vZmZzZXQhPT0wJiZ0aGlzW29dLnVuc2hpZnQoKDAsbC5kZWZhdWx0KSh7fSx0aGlzW1RdLHtvZmZzZXQ6MH0pKSxHLm9mZnNldDwxJiZ0aGlzW29dLnB1c2goKDAsbC5kZWZhdWx0KSh7fSxHLHtvZmZzZXQ6MX0pKSx0aGlzW0ldPXt9LHRoaXMudGltZWxpbmU9bnVsbH1yZXR1cm4oMCx2LmRlZmF1bHQpKEIsW3trZXk6InBhdXNlIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPTB9fSx7a2V5OlAsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgSD10aGlzO3RoaXNbQV0mJiF0aGlzW0FdLnRpbWVySUQmJih0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPDA/dGhpc1tBXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe0hbQV0ucmVzb2x2ZSgpLGRlbGV0ZSBIW0FdfSx7ZGVsYXk6LXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUsaGVhZGluZzohMX0pOnRoaXNbQV0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIW0FdLnJlc29sdmUoKSxkZWxldGUgSFtBXX0se2RlbGF5OjAsaXNFbnRyb3B5OiEwfSkpfX0se2tleTpMLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEg9dGhpcyxKPXRoaXNbaV0scT1KLmR1cmF0aW9uLFc9Si5pdGVyYXRpb25zLEc9Si5lbmREZWxheSxRPU1hdGguY2VpbChxKlcrRy10aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lKSsxO3RoaXNbQ10mJiF0aGlzW0NdLnRpbWVySUQmJih0aGlzW0NdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SFtDXS5yZXNvbHZlKCksSFtEXShBKSxIW0RdKEMpfSx7ZGVsYXk6USxoZWFkaW5nOiExfSksdGhpc1tDXS5yZXZlcnNlVGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtIW0NdLnJlc29sdmUoKSxIW0RdKEEpLEhbRF0oQyksSC50aW1lbGluZT1udWxsfSx7ZGVsYXk6LXRoaXNbaV0uZGVsYXktMSxoZWFkaW5nOiExfSkpfX0se2tleToicGxheSIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXlTdGF0ZT09PSJmaW5pc2hlZCImJnRoaXMuY2FuY2VsKCksdGhpcy5wbGF5U3RhdGU9PT0iaWRsZSIpe2lmKHRoaXMucGxheWJhY2tSYXRlPD0wKXJldHVybjt2YXIgSD10aGlzW2ldLEo9SC5kZWxheSxxPUgucGxheWJhY2tSYXRlLFc9SC50aW1lbGluZTt0aGlzLnRpbWVsaW5lPW5ldyBnLmRlZmF1bHQoe29yaWdpblRpbWU6SixwbGF5YmFja1JhdGU6cX0sVyksdGhpc1tQXSgpLHRoaXNbTF0oKX1lbHNlIHRoaXMucGxheVN0YXRlPT09InBhdXNlZCImJih0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT10aGlzLnBsYXliYWNrUmF0ZSx0aGlzW1BdKCkpfX0se2tleTpELHZhbHVlOmZ1bmN0aW9uKEgpe3ZhciBKPXRoaXNbSF0scT10aGlzLnRpbWVsaW5lO0omJnEmJihxLmNsZWFyVGltZW91dChKLnRpbWVySUQpLEoucmV2ZXJzZVRpbWVySUQmJnEuY2xlYXJUaW1lb3V0KEoucmV2ZXJzZVRpbWVySUQpKSxkZWxldGUgdGhpc1tIXX19LHtrZXk6ImNhbmNlbCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzW0RdKEEpLHRoaXNbRF0oQyksdGhpcy50aW1lbGluZT1udWxsfX0se2tleToiZmluaXNoIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPTEvMC90aGlzLnBsYXliYWNrUmF0ZSksdGhpc1tEXShBKSx0aGlzW0RdKEMpfX0se2tleToiYXBwbHlFZmZlY3RzIix2YWx1ZTpmdW5jdGlvbihIKXtyZXR1cm4oMCxsLmRlZmF1bHQpKHRoaXNbSV0sSCl9fSx7a2V5OiJwbGF5YmFja1JhdGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2ldLnBsYXliYWNrUmF0ZX0sc2V0OmZ1bmN0aW9uKEgpe3RoaXMudGltZWxpbmUmJih0aGlzLnRpbWVsaW5lLnBsYXliYWNrUmF0ZT1IKSx0aGlzW2ldLnBsYXliYWNrUmF0ZT1IfX0se2tleToicGxheVN0YXRlIixnZXQ6ZnVuY3Rpb24oKXt2YXIgSD10aGlzLnRpbWVsaW5lLEo9dGhpc1tpXSxxPUouaXRlcmF0aW9ucyxXPUouZHVyYXRpb24sRz1KLmVuZERlbGF5LFE9InJ1bm5pbmciO2lmKEg9PW51bGwpUT0iaWRsZSI7ZWxzZSBpZihILnBhdXNlZClRPSJwYXVzZWQiO2Vsc2UgaWYoSC5jdXJyZW50VGltZTwwKVE9InBlbmRpbmciO2Vsc2V7dmFyIHR0PUguY3VycmVudFRpbWUtcSpXO3R0PjAmJnR0PEc/UT0icGVuZGluZyI6dHQ+PUcmJihRPSJmaW5pc2hlZCIpfXJldHVybiBRfX0se2tleToicHJvZ3Jlc3MiLGdldDpmdW5jdGlvbigpe2lmKCF0aGlzLnRpbWVsaW5lKXJldHVybiAwO3ZhciBIPXRoaXNbaV0sSj1ILmR1cmF0aW9uLHE9SC5pdGVyYXRpb25zLFc9dGhpcy50aW1lbGluZSxHPXRoaXMucGxheVN0YXRlLFE9dm9pZCAwO2lmKEc9PT0iaWRsZSIpUT0wO2Vsc2UgaWYoRz09PSJwYXVzZWQiJiZXLmN1cnJlbnRUaW1lPDApUT0wO2Vsc2UgaWYoRz09PSJwZW5kaW5nIilpZihXLmN1cnJlbnRUaW1lPDApUT0wO2Vsc2V7dmFyIHR0PVcuc2Vla0xvY2FsVGltZShxKkopO1E9KDAscC5wZXJpb2RpY2l0eSkodHQsSilbMV0vSn1lbHNlKEc9PT0icnVubmluZyJ8fEc9PT0icGF1c2VkIikmJihRPSgwLHAucGVyaW9kaWNpdHkpKFcuY3VycmVudFRpbWUsSilbMV0vSik7cmV0dXJuIEc9PT0iZmluaXNoZWQiJiYoUT0oMCxwLnBlcmlvZGljaXR5KShxLDEpWzFdKSxRfX0se2tleToiZnJhbWUiLGdldDpmdW5jdGlvbigpe3ZhciBIPXRoaXMucGxheVN0YXRlLEo9dGhpc1tUXSxxPXRoaXNbaV0uZmlsbDtpZihIPT09ImlkbGUiKXJldHVybiBKO3ZhciBXPXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUsRz10aGlzW29dLnNsaWNlKDApLFE9KDAscC5nZXRQcm9ncmVzcykodGhpcy50aW1lbGluZSx0aGlzW2ldLHRoaXMucHJvZ3Jlc3MpLHR0PVEucCxfPVEuaW52ZXJ0ZWQsc3Q9SjtyZXR1cm4gVzwwJiZIPT09InBlbmRpbmciPyhxPT09ImJhY2t3YXJkcyJ8fHE9PT0iYm90aCIpJiYoc3Q9Xz9HW0cubGVuZ3RoLTFdOkdbMF0pOihIIT09InBlbmRpbmciJiZIIT09ImZpbmlzaGVkInx8cT09PSJmb3J3YXJkcyJ8fHE9PT0iYm90aCIpJiYoc3Q9KDAscC5nZXRDdXJyZW50RnJhbWUpKHRoaXNbaV0sRyx0aGlzW0ldLHR0KSksc3R9fSx7a2V5OiJ0aW1pbmciLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2ldfX0se2tleToiZWZmZWN0cyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbSV19fSx7a2V5OiJiYXNlVGltZWxpbmUiLHNldDpmdW5jdGlvbihIKXt0aGlzW2ldLnRpbWVsaW5lPUh9LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2ldLnRpbWVsaW5lfX0se2tleToicmVhZHkiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW0FdP3RoaXNbQV0ucHJvbWlzZTp0aGlzLnRpbWVsaW5lJiZ0aGlzLnRpbWVsaW5lLmN1cnJlbnRUaW1lPj0wJiZ0aGlzLnBsYXlTdGF0ZSE9PSJwYXVzZWQiP3MuZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbQV09KDAscC5kZWZlcikoKSx0aGlzLnRpbWVsaW5lJiZ0aGlzW1BdKCksdGhpc1tBXT90aGlzW0FdLnByb21pc2U6cy5kZWZhdWx0LnJlc29sdmUoKSl9fSx7a2V5OiJmaW5pc2hlZCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIj9zLmRlZmF1bHQucmVzb2x2ZSgpOih0aGlzW0NdfHwodGhpc1tDXT0oMCxwLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbTF0oKSksdGhpc1tDXS5wcm9taXNlKX19XSksQn0oKTtlLmRlZmF1bHQ9U30sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz17ZGVmYXVsdDp0KDE5MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKGgsZSx0KXt0KDE0MyksdCgxMjUpLHQoNzkpLHQoMTkzKSx0KDIwMiksdCgyMDMpLGguZXhwb3J0cz10KDkyKS5Qcm9taXNlfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg4OSkscz10KDkxKSxtPXQoOTMpLHk9dCgxMjgpLGM9dCg5MCksbD10KDk4KSx1PXQoOTQpLE09dCgxNDcpLGY9dCgxNDgpLHY9dCgxOTQpLHg9dCgxOTUpLnNldCxSPXQoMTk3KSgpLE89dCgxOTgpLGc9dCgxOTkpLHA9dCgyMDApLG49dCgyMDEpLGE9IlByb21pc2UiLGk9cy5UeXBlRXJyb3Isbz1zLnByb2Nlc3MsVD1vJiZvLnZlcnNpb25zLEE9VCYmVC52OHx8IiIsQz1zW2FdLEk9eShvKT09InByb2Nlc3MiLFA9ZnVuY3Rpb24oKXt9LEwsRCxiLFMsQj1EPU8uZix3PSEhZnVuY3Rpb24oKXt0cnl7dmFyIF89Qy5yZXNvbHZlKDEpLHN0PShfLmNvbnN0cnVjdG9yPXt9KVt0KDEyMikoInNwZWNpZXMiKV09ZnVuY3Rpb24oayl7ayhQLFApfTtyZXR1cm4oSXx8dHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudD09ImZ1bmN0aW9uIikmJl8udGhlbihQKWluc3RhbmNlb2Ygc3QmJkEuaW5kZXhPZigiNi42IikhPT0wJiZwLmluZGV4T2YoIkNocm9tZS82NiIpPT09LTF9Y2F0Y2h7fX0oKSxIPWZ1bmN0aW9uKF8pe3ZhciBzdDtyZXR1cm4gbChfKSYmdHlwZW9mKHN0PV8udGhlbik9PSJmdW5jdGlvbiI/c3Q6ITF9LEo9ZnVuY3Rpb24oXyxzdCl7aWYoIV8uX24pe18uX249ITA7dmFyIGs9Xy5fYztSKGZ1bmN0aW9uKCl7Zm9yKHZhciBjdD1fLl92LGZ0PV8uX3M9PTEsVT0wLEY9ZnVuY3Rpb24oVil7dmFyIFg9ZnQ/Vi5vazpWLmZhaWwsaj1WLnJlc29sdmUsej1WLnJlamVjdCxkPVYuZG9tYWluLEUsTiwkO3RyeXtYPyhmdHx8KF8uX2g9PTImJkcoXyksXy5faD0xKSxYPT09ITA/RT1jdDooZCYmZC5lbnRlcigpLEU9WChjdCksZCYmKGQuZXhpdCgpLCQ9ITApKSxFPT09Vi5wcm9taXNlP3ooaSgiUHJvbWlzZS1jaGFpbiBjeWNsZSIpKTooTj1IKEUpKT9OLmNhbGwoRSxqLHopOmooRSkpOnooY3QpfWNhdGNoKEspe2QmJiEkJiZkLmV4aXQoKSx6KEspfX07ay5sZW5ndGg+VTspRihrW1UrK10pO18uX2M9W10sXy5fbj0hMSxzdCYmIV8uX2gmJnEoXyl9KX19LHE9ZnVuY3Rpb24oXyl7eC5jYWxsKHMsZnVuY3Rpb24oKXt2YXIgc3Q9Xy5fdixrPVcoXyksY3QsZnQsVTtpZihrJiYoY3Q9ZyhmdW5jdGlvbigpe0k/by5lbWl0KCJ1bmhhbmRsZWRSZWplY3Rpb24iLHN0LF8pOihmdD1zLm9udW5oYW5kbGVkcmVqZWN0aW9uKT9mdCh7cHJvbWlzZTpfLHJlYXNvbjpzdH0pOihVPXMuY29uc29sZSkmJlUuZXJyb3ImJlUuZXJyb3IoIlVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbiIsc3QpfSksXy5faD1JfHxXKF8pPzI6MSksXy5fYT12b2lkIDAsayYmY3QuZSl0aHJvdyBjdC52fSl9LFc9ZnVuY3Rpb24oXyl7cmV0dXJuIF8uX2ghPT0xJiYoXy5fYXx8Xy5fYykubGVuZ3RoPT09MH0sRz1mdW5jdGlvbihfKXt4LmNhbGwocyxmdW5jdGlvbigpe3ZhciBzdDtJP28uZW1pdCgicmVqZWN0aW9uSGFuZGxlZCIsXyk6KHN0PXMub25yZWplY3Rpb25oYW5kbGVkKSYmc3Qoe3Byb21pc2U6XyxyZWFzb246Xy5fdn0pfSl9LFE9ZnVuY3Rpb24oXyl7dmFyIHN0PXRoaXM7c3QuX2R8fChzdC5fZD0hMCxzdD1zdC5fd3x8c3Qsc3QuX3Y9XyxzdC5fcz0yLHN0Ll9hfHwoc3QuX2E9c3QuX2Muc2xpY2UoKSksSihzdCwhMCkpfSx0dD1mdW5jdGlvbihfKXt2YXIgc3Q9dGhpcyxrO2lmKCFzdC5fZCl7c3QuX2Q9ITAsc3Q9c3QuX3d8fHN0O3RyeXtpZihzdD09PV8pdGhyb3cgaSgiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGYiKTsoaz1IKF8pKT9SKGZ1bmN0aW9uKCl7dmFyIGN0PXtfdzpzdCxfZDohMX07dHJ5e2suY2FsbChfLG0odHQsY3QsMSksbShRLGN0LDEpKX1jYXRjaChmdCl7US5jYWxsKGN0LGZ0KX19KTooc3QuX3Y9XyxzdC5fcz0xLEooc3QsITEpKX1jYXRjaChjdCl7US5jYWxsKHtfdzpzdCxfZDohMX0sY3QpfX19O3d8fChDPWZ1bmN0aW9uKHN0KXtNKHRoaXMsQyxhLCJfaCIpLHUoc3QpLEwuY2FsbCh0aGlzKTt0cnl7c3QobSh0dCx0aGlzLDEpLG0oUSx0aGlzLDEpKX1jYXRjaChrKXtRLmNhbGwodGhpcyxrKX19LEw9ZnVuY3Rpb24oc3Qpe3RoaXMuX2M9W10sdGhpcy5fYT12b2lkIDAsdGhpcy5fcz0wLHRoaXMuX2Q9ITEsdGhpcy5fdj12b2lkIDAsdGhpcy5faD0wLHRoaXMuX249ITF9LEwucHJvdG90eXBlPXQoMTQ2KShDLnByb3RvdHlwZSx7dGhlbjpmdW5jdGlvbihzdCxrKXt2YXIgY3Q9Qih2KHRoaXMsQykpO3JldHVybiBjdC5vaz10eXBlb2Ygc3Q9PSJmdW5jdGlvbiI/c3Q6ITAsY3QuZmFpbD10eXBlb2Ygaz09ImZ1bmN0aW9uIiYmayxjdC5kb21haW49ST9vLmRvbWFpbjp2b2lkIDAsdGhpcy5fYy5wdXNoKGN0KSx0aGlzLl9hJiZ0aGlzLl9hLnB1c2goY3QpLHRoaXMuX3MmJkoodGhpcywhMSksY3QucHJvbWlzZX0sY2F0Y2g6ZnVuY3Rpb24oXyl7cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsXyl9fSksYj1mdW5jdGlvbigpe3ZhciBfPW5ldyBMO3RoaXMucHJvbWlzZT1fLHRoaXMucmVzb2x2ZT1tKHR0LF8sMSksdGhpcy5yZWplY3Q9bShRLF8sMSl9LE8uZj1CPWZ1bmN0aW9uKF8pe3JldHVybiBfPT09Q3x8Xz09PVM/bmV3IGIoXyk6RChfKX0pLGMoYy5HK2MuVytjLkYqIXcse1Byb21pc2U6Q30pLHQoMTIxKShDLGEpLHQoMTQ5KShhKSxTPXQoOTIpW2FdLGMoYy5TK2MuRiohdyxhLHtyZWplY3Q6ZnVuY3Rpb24oc3Qpe3ZhciBrPUIodGhpcyksY3Q9ay5yZWplY3Q7cmV0dXJuIGN0KHN0KSxrLnByb21pc2V9fSksYyhjLlMrYy5GKihyfHwhdyksYSx7cmVzb2x2ZTpmdW5jdGlvbihzdCl7cmV0dXJuIG4ociYmdGhpcz09PVM/Qzp0aGlzLHN0KX19KSxjKGMuUytjLkYqISh3JiZ0KDE0MCkoZnVuY3Rpb24oXyl7Qy5hbGwoXykuY2F0Y2goUCl9KSksYSx7YWxsOmZ1bmN0aW9uKHN0KXt2YXIgaz10aGlzLGN0PUIoayksZnQ9Y3QucmVzb2x2ZSxVPWN0LnJlamVjdCxGPWcoZnVuY3Rpb24oKXt2YXIgVj1bXSxYPTAsaj0xO2Yoc3QsITEsZnVuY3Rpb24oeil7dmFyIGQ9WCsrLEU9ITE7Vi5wdXNoKHZvaWQgMCksaisrLGsucmVzb2x2ZSh6KS50aGVuKGZ1bmN0aW9uKE4pe0V8fChFPSEwLFZbZF09TiwtLWp8fGZ0KFYpKX0sVSl9KSwtLWp8fGZ0KFYpfSk7cmV0dXJuIEYuZSYmVShGLnYpLGN0LnByb21pc2V9LHJhY2U6ZnVuY3Rpb24oc3Qpe3ZhciBrPXRoaXMsY3Q9QihrKSxmdD1jdC5yZWplY3QsVT1nKGZ1bmN0aW9uKCl7ZihzdCwhMSxmdW5jdGlvbihGKXtrLnJlc29sdmUoRikudGhlbihjdC5yZXNvbHZlLGZ0KX0pfSk7cmV0dXJuIFUuZSYmZnQoVS52KSxjdC5wcm9taXNlfX0pfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCg5Nykscz10KDk0KSxtPXQoMTIyKSgic3BlY2llcyIpO2guZXhwb3J0cz1mdW5jdGlvbih5LGMpe3ZhciBsPXIoeSkuY29uc3RydWN0b3IsdTtyZXR1cm4gbD09PXZvaWQgMHx8KHU9cihsKVttXSk9PW51bGw/YzpzKHUpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTMpLHM9dCgxOTYpLG09dCgxMjApLHk9dCgxMDIpLGM9dCg5MSksbD1jLnByb2Nlc3MsdT1jLnNldEltbWVkaWF0ZSxNPWMuY2xlYXJJbW1lZGlhdGUsZj1jLk1lc3NhZ2VDaGFubmVsLHY9Yy5EaXNwYXRjaCx4PTAsUj17fSxPPSJvbnJlYWR5c3RhdGVjaGFuZ2UiLGcscCxuLGE9ZnVuY3Rpb24oKXt2YXIgbz0rdGhpcztpZihSLmhhc093blByb3BlcnR5KG8pKXt2YXIgVD1SW29dO2RlbGV0ZSBSW29dLFQoKX19LGk9ZnVuY3Rpb24obyl7YS5jYWxsKG8uZGF0YSl9OyghdXx8IU0pJiYodT1mdW5jdGlvbihUKXtmb3IodmFyIEE9W10sQz0xO2FyZ3VtZW50cy5sZW5ndGg+QzspQS5wdXNoKGFyZ3VtZW50c1tDKytdKTtyZXR1cm4gUlsrK3hdPWZ1bmN0aW9uKCl7cyh0eXBlb2YgVD09ImZ1bmN0aW9uIj9UOkZ1bmN0aW9uKFQpLEEpfSxnKHgpLHh9LE09ZnVuY3Rpb24oVCl7ZGVsZXRlIFJbVF19LHQoODYpKGwpPT0icHJvY2VzcyI/Zz1mdW5jdGlvbihvKXtsLm5leHRUaWNrKHIoYSxvLDEpKX06diYmdi5ub3c/Zz1mdW5jdGlvbihvKXt2Lm5vdyhyKGEsbywxKSl9OmY/KHA9bmV3IGYsbj1wLnBvcnQyLHAucG9ydDEub25tZXNzYWdlPWksZz1yKG4ucG9zdE1lc3NhZ2UsbiwxKSk6Yy5hZGRFdmVudExpc3RlbmVyJiZ0eXBlb2YgcG9zdE1lc3NhZ2U9PSJmdW5jdGlvbiImJiFjLmltcG9ydFNjcmlwdHM/KGc9ZnVuY3Rpb24obyl7Yy5wb3N0TWVzc2FnZShvKyIiLCIqIil9LGMuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsaSwhMSkpOk8gaW4geSgic2NyaXB0Iik/Zz1mdW5jdGlvbihvKXttLmFwcGVuZENoaWxkKHkoInNjcmlwdCIpKVtPXT1mdW5jdGlvbigpe20ucmVtb3ZlQ2hpbGQodGhpcyksYS5jYWxsKG8pfX06Zz1mdW5jdGlvbihvKXtzZXRUaW1lb3V0KHIoYSxvLDEpLDApfSksaC5leHBvcnRzPXtzZXQ6dSxjbGVhcjpNfX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCxyLHMpe3ZhciBtPXM9PT12b2lkIDA7c3dpdGNoKHIubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG0/dCgpOnQuY2FsbChzKTtjYXNlIDE6cmV0dXJuIG0/dChyWzBdKTp0LmNhbGwocyxyWzBdKTtjYXNlIDI6cmV0dXJuIG0/dChyWzBdLHJbMV0pOnQuY2FsbChzLHJbMF0sclsxXSk7Y2FzZSAzOnJldHVybiBtP3QoclswXSxyWzFdLHJbMl0pOnQuY2FsbChzLHJbMF0sclsxXSxyWzJdKTtjYXNlIDQ6cmV0dXJuIG0/dChyWzBdLHJbMV0sclsyXSxyWzNdKTp0LmNhbGwocyxyWzBdLHJbMV0sclsyXSxyWzNdKX1yZXR1cm4gdC5hcHBseShzLHIpfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTEpLHM9dCgxOTUpLnNldCxtPXIuTXV0YXRpb25PYnNlcnZlcnx8ci5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLHk9ci5wcm9jZXNzLGM9ci5Qcm9taXNlLGw9dCg4NikoeSk9PSJwcm9jZXNzIjtoLmV4cG9ydHM9ZnVuY3Rpb24oKXt2YXIgdSxNLGYsdj1mdW5jdGlvbigpe3ZhciBnLHA7Zm9yKGwmJihnPXkuZG9tYWluKSYmZy5leGl0KCk7dTspe3A9dS5mbix1PXUubmV4dDt0cnl7cCgpfWNhdGNoKG4pe3Rocm93IHU/ZigpOk09dm9pZCAwLG59fU09dm9pZCAwLGcmJmcuZW50ZXIoKX07aWYobClmPWZ1bmN0aW9uKCl7eS5uZXh0VGljayh2KX07ZWxzZSBpZihtJiYhKHIubmF2aWdhdG9yJiZyLm5hdmlnYXRvci5zdGFuZGFsb25lKSl7dmFyIHg9ITAsUj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiIik7bmV3IG0odikub2JzZXJ2ZShSLHtjaGFyYWN0ZXJEYXRhOiEwfSksZj1mdW5jdGlvbigpe1IuZGF0YT14PSF4fX1lbHNlIGlmKGMmJmMucmVzb2x2ZSl7dmFyIE89Yy5yZXNvbHZlKHZvaWQgMCk7Zj1mdW5jdGlvbigpe08udGhlbih2KX19ZWxzZSBmPWZ1bmN0aW9uKCl7cy5jYWxsKHIsdil9O3JldHVybiBmdW5jdGlvbihnKXt2YXIgcD17Zm46ZyxuZXh0OnZvaWQgMH07TSYmKE0ubmV4dD1wKSx1fHwodT1wLGYoKSksTT1wfX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk0KTtmdW5jdGlvbiBzKG0pe3ZhciB5LGM7dGhpcy5wcm9taXNlPW5ldyBtKGZ1bmN0aW9uKGwsdSl7aWYoeSE9PXZvaWQgMHx8YyE9PXZvaWQgMCl0aHJvdyBUeXBlRXJyb3IoIkJhZCBQcm9taXNlIGNvbnN0cnVjdG9yIik7eT1sLGM9dX0pLHRoaXMucmVzb2x2ZT1yKHkpLHRoaXMucmVqZWN0PXIoYyl9aC5leHBvcnRzLmY9ZnVuY3Rpb24obSl7cmV0dXJuIG5ldyBzKG0pfX0sZnVuY3Rpb24oaCxlKXtoLmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybntlOiExLHY6dCgpfX1jYXRjaChyKXtyZXR1cm57ZTohMCx2OnJ9fX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkxKSxzPXIubmF2aWdhdG9yO2guZXhwb3J0cz1zJiZzLnVzZXJBZ2VudHx8IiJ9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDk3KSxzPXQoOTgpLG09dCgxOTgpO2guZXhwb3J0cz1mdW5jdGlvbih5LGMpe2lmKHIoeSkscyhjKSYmYy5jb25zdHJ1Y3Rvcj09PXkpcmV0dXJuIGM7dmFyIGw9bS5mKHkpLHU9bC5yZXNvbHZlO3JldHVybiB1KGMpLGwucHJvbWlzZX19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDkwKSxzPXQoOTIpLG09dCg5MSkseT10KDE5NCksYz10KDIwMSk7cihyLlArci5SLCJQcm9taXNlIix7ZmluYWxseTpmdW5jdGlvbihsKXt2YXIgdT15KHRoaXMscy5Qcm9taXNlfHxtLlByb21pc2UpLE09dHlwZW9mIGw9PSJmdW5jdGlvbiI7cmV0dXJuIHRoaXMudGhlbihNP2Z1bmN0aW9uKGYpe3JldHVybiBjKHUsbCgpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KX06bCxNP2Z1bmN0aW9uKGYpe3JldHVybiBjKHUsbCgpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgZn0pfTpsKX19KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApLHM9dCgxOTgpLG09dCgxOTkpO3Ioci5TLCJQcm9taXNlIix7dHJ5OmZ1bmN0aW9uKHkpe3ZhciBjPXMuZih0aGlzKSxsPW0oeSk7cmV0dXJuKGwuZT9jLnJlamVjdDpjLnJlc29sdmUpKGwudiksYy5wcm9taXNlfX0pfSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXtkZWZhdWx0OnQoMjA1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oaCxlLHQpe3QoMjA2KSxoLmV4cG9ydHM9dCg5MikuT2JqZWN0LmtleXN9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDEyNCkscz10KDExMCk7dCgyMDcpKCJrZXlzIixmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih5KXtyZXR1cm4gcyhyKHkpKX19KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApLHM9dCg5MiksbT10KDEwMSk7aC5leHBvcnRzPWZ1bmN0aW9uKHksYyl7dmFyIGw9KHMuT2JqZWN0fHx7fSlbeV18fE9iamVjdFt5XSx1PXt9O3VbeV09YyhsKSxyKHIuUytyLkYqbShmdW5jdGlvbigpe2woMSl9KSwiT2JqZWN0Iix1KX19LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIHI9dCg3Nikscz1SKHIpLG09dCgyMDkpLHk9UihtKSxjPXQoMTY0KSxsPVIoYyksdT10KDE5MSksTT1SKHUpO2UuZGVmZXI9TyxlLnBlcmlvZGljaXR5PWcsZS5jYWxjdWxhdGVGcmFtZXNPZmZzZXQ9cCxlLmdldFByb2dyZXNzPW4sZS5nZXRDdXJyZW50RnJhbWU9aTt2YXIgZj10KDE4OCksdj10KDE4NykseD1SKHYpO2Z1bmN0aW9uIFIobyl7cmV0dXJuIG8mJm8uX19lc01vZHVsZT9vOntkZWZhdWx0Om99fWZ1bmN0aW9uIE8oKXt2YXIgbz17fTtyZXR1cm4gby5wcm9taXNlPW5ldyBNLmRlZmF1bHQoZnVuY3Rpb24oVCxBKXtvLnJlc29sdmU9VCxvLnJlamVjdD1BfSksb31mdW5jdGlvbiBnKG8sVCl7dmFyIEE9TWF0aC5mbG9vcihvL1QpLEM9by1BKlQ7cmV0dXJuIEM9PT0wJiZBPjAmJihDPVQsQS0tKSxbQSxDXX1mdW5jdGlvbiBwKG8pe289by5zbGljZSgwKTt2YXIgVD1vWzBdLEE9b1tvLmxlbmd0aC0xXTtBLm9mZnNldD1BLm9mZnNldHx8MSxULm9mZnNldD1ULm9mZnNldHx8MDtmb3IodmFyIEM9MCxJPS0xLFA9MDtQPG8ubGVuZ3RoO1ArKyl7dmFyIEw9b1tQXTtpZihMLm9mZnNldCE9bnVsbCl7dmFyIEQ9UC1JO2lmKEQ+MSlmb3IodmFyIGI9KEwub2Zmc2V0LUMpL0QsUz0wO1M8RC0xO1MrKylvW0krUysxXS5vZmZzZXQ9QytiKihTKzEpO0M9TC5vZmZzZXQsST1QfWlmKEwuZWFzaW5nIT1udWxsJiYoTC5lYXNpbmc9KDAsZi5wYXJzZUVhc2luZykoTC5lYXNpbmcpKSxQPjApe3ZhciBCPW9bUF0uZWFzaW5nIT1udWxsO29bUF09KDAsbC5kZWZhdWx0KSh7fSxvW1AtMV0sb1tQXSksQnx8ZGVsZXRlIG9bUF0uZWFzaW5nfX1yZXR1cm4gb31mdW5jdGlvbiBuKG8sVCxBKXt2YXIgQz1vLmN1cnJlbnRUaW1lLEk9VC5kaXJlY3Rpb24sUD1ULmR1cmF0aW9uLEw9ITE7aWYoST09PSJyZXZlcnNlIilBPTEtQSxMPSEwO2Vsc2UgaWYoST09PSJhbHRlcm5hdGUifHxJPT09ImFsdGVybmF0ZS1yZXZlcnNlIil7dmFyIEQ9TWF0aC5mbG9vcihDL1ApO0E9PT0xJiZELS0sRCUyXkk9PT0iYWx0ZXJuYXRlLXJldmVyc2UiJiYoQT0xLUEsTD0hMCl9cmV0dXJue3A6QSxpbnZlcnRlZDpMfX1mdW5jdGlvbiBhKG8sVCxBLEMpe3ZhciBJPXt9O3JldHVybigwLHkuZGVmYXVsdCkoVCkuZm9yRWFjaChmdW5jdGlvbihQKXt2YXIgTD0oMCxzLmRlZmF1bHQpKFAsMiksRD1MWzBdLGI9TFsxXTtpZihEIT09Im9mZnNldCImJkQhPT0iZWFzaW5nIil7dmFyIFM9QVtEXXx8QS5kZWZhdWx0LEI9UyhvW0RdLGIsQyxvLm9mZnNldCxULm9mZnNldCk7QiE9bnVsbCYmKElbRF09Qil9fSksSX1mdW5jdGlvbiBpKG8sVCxBLEMpe3ZhciBJPW8uZWFzaW5nLFA9by5lZmZlY3Q7UHx8KEE9KDAsbC5kZWZhdWx0KSh7fSx4LmRlZmF1bHQsQSkpO3ZhciBMPXt9O0M9SShDLFQpO2Zvcih2YXIgRD0xO0Q8VC5sZW5ndGg7RCsrKXt2YXIgYj1UW0RdLFM9Yi5vZmZzZXQ7aWYoUz49Q3x8RD09PVQubGVuZ3RoLTEpe3ZhciBCPVRbRC0xXSx3PUIub2Zmc2V0LEg9Qi5lYXNpbmcsSj1DO2lmKEgpe3ZhciBxPVMtdztKPUgoKEMtdykvcSkqcSt3fVA/TD1QKEIsYixKLHcsUyk6TD1hKEIsYixBLEopO2JyZWFrfX1yZXR1cm4gTH19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMTApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihoLGUsdCl7dCgyMTEpLGguZXhwb3J0cz10KDkyKS5PYmplY3QuZW50cmllc30sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoOTApLHM9dCgyMTIpKCEwKTtyKHIuUywiT2JqZWN0Iix7ZW50cmllczpmdW5jdGlvbih5KXtyZXR1cm4gcyh5KX19KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMTAwKSxzPXQoMTEwKSxtPXQoODQpLHk9dCgxNjkpLmY7aC5leHBvcnRzPWZ1bmN0aW9uKGMpe3JldHVybiBmdW5jdGlvbihsKXtmb3IodmFyIHU9bShsKSxNPXModSksZj1NLmxlbmd0aCx2PTAseD1bXSxSO2Y+djspUj1NW3YrK10sKCFyfHx5LmNhbGwodSxSKSkmJngucHVzaChjP1tSLHVbUl1dOnVbUl0pO3JldHVybiB4fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHI9bmV3IE1hcDtmdW5jdGlvbiBzKHksYz17fSxsPVtdKXt5PXkudG9Mb3dlckNhc2UoKTtjb25zdCB1PXIuZ2V0KHkpO2lmKCF1KXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgbm9kZTogJHt5fWApO2NvbnN0IE09bmV3IHUoYyk7cmV0dXJuIGwuZm9yRWFjaChmPT57TS5hcHBlbmRDaGlsZChmKX0pLE19Y29uc3QgbT17cmVnaXN0ZXJOb2RlKHksYyxsPTEwMCl7aWYoYz1jLnRvTG93ZXJDYXNlKCksci5oYXMoYykpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IHJlZ2lzdGVyTm9kZSwgJHtjfSBoYXMgYmVlbiB0YWtlbi5gKTtyLnNldChjLHkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHkucHJvdG90eXBlLHtub2RlVHlwZTp7dmFsdWU6bH0sdGFnTmFtZTp7dmFsdWU6Yy50b1VwcGVyQ2FzZSgpfSxub2RlTmFtZTp7dmFsdWU6Y30sb3duZXJEb2N1bWVudDp7dmFsdWU6bX0sbmFtZXNwYWNlVVJJOnt2YWx1ZTpgaHR0cDovL3Nwcml0ZWpzLmNvbS8ke2N9YH19KX0sY3JlYXRlRWxlbWVudDpzLGNyZWF0ZUVsZW1lbnROUyh5LGMpe3JldHVybiBzKGMpfSxpc1Nwcml0ZU5vZGUoeSl7cmV0dXJuIHIuaGFzKHkudG9Mb3dlckNhc2UoKSl9fTtlLmRlZmF1bHQ9bX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCByPVN5bWJvbCgidHlwZSIpLHM9U3ltYm9sKCJidWJibGVzIiksbT1TeW1ib2woIm9yaWdpbmFsRXZlbnQiKSx5PVN5bWJvbCgiZGV0YWlsIik7Y2xhc3MgY3tjb25zdHJ1Y3Rvcih1LHtidWJibGVzOk09bnVsbH09e30pe2lmKHR5cGVvZiB1PT0ic3RyaW5nIj8odGhpc1tyXT11LHRoaXNbc109ISFNKToodGhpc1tyXT11LnR5cGUsdGhpc1ttXT11LHRoaXNbc109TSE9bnVsbD8hIU06ISF1LmJ1YmJsZXMsdS5kZXRhaWwmJih0aGlzW3ldPXUuZGV0YWlsKSksIXRoaXNbcl0pdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBldmVudCB0eXBlLiIpO3RoaXMuY2FuY2VsQnViYmxlPSExfXNldE9yaWdpbmFsRXZlbnQodSl7dGhpc1ttXT11fWdldCBvcmlnaW5hbEV2ZW50KCl7cmV0dXJuIHRoaXNbbV19Z2V0IHR5cGUoKXtyZXR1cm4gdGhpc1tyXX1nZXQgYnViYmxlcygpe3JldHVybiB0aGlzW3NdfWdldCBkZXRhaWwoKXtyZXR1cm4gdGhpc1t5XX1zdG9wUHJvcGFnYXRpb24oKXt0aGlzLmNhbmNlbEJ1YmJsZT0hMH19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJwYXJzZUZpbHRlclN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJhcHBseUZpbHRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgcj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gcyh5KXtpZih5PXkudHJpbSgpLCF5fHx5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IGM9L14oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrJC9pLGw9eS5tYXRjaCgvKD86KHVybHxibHVyfGJyaWdodG5lc3N8Y29udHJhc3R8ZHJvcC1zaGFkb3d8Z3JheXNjYWxlfGh1ZS1yb3RhdGV8aW52ZXJ0fG9wYWNpdHl8c2F0dXJhdGV8c2VwaWEpXCgoW14oKV0qKD86XCguKlwpKSpbXigpXSopXCkpKz8vaWcpLHU9W107cmV0dXJuIGwmJmwuZm9yRWFjaChNPT57Y29uc3QgZj1NLm1hdGNoKGMpO2lmKCFmKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZml0bGVyIHN0cmluZy4iKTtsZXRbLHYseF09Zjt2PXYudG9Mb3dlckNhc2UoKSx4PXgudHJpbSgpLm1hdGNoKC8oW14oICldK3woW14oICldK1woLipcKSkpKD89XHN8JCkvZykubWFwKChSLE8pPT57bGV0IGc7cmV0dXJuIHY9PT0idXJsInx8dj09PSJkcm9wLXNoYWRvdyImJk89PT0zP2c9UjpnPU9iamVjdChyLnRvTnVtYmVyKShSKSwvJSQvLnRlc3QoUikmJihnLz0xMDApLGd9KSx1LnB1c2goe3R5cGU6dixhcmdzOnh9KX0pLHV9ZnVuY3Rpb24gbSh5LGMpe3kuY2xlYXJGaWx0ZXIoKSxjJiZjLmZvckVhY2goKHt0eXBlOmwsYXJnczp1fSk9PntsZXQgTT1sO009PT0iZHJvcC1zaGFkb3ciP009ImRyb3BTaGFkb3ciOk09PT0iaHVlLXJvdGF0ZSImJihNPSJodWVSb3RhdGUiKSx5W01dKC4uLnUpfSl9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiByfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIocyxtKXtpZighbSlyZXR1cm47Y29uc3QgeT1zLmdldExpc3RlbmVycygiYmVmb3JlcmVuZGVyIiksYz1zLmdldExpc3RlbmVycygiYWZ0ZXJyZW5kZXIiKTt5Lmxlbmd0aCYmIW0uYmVmb3JlUmVuZGVyP20uYmVmb3JlUmVuZGVyPWw9PntzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImJlZm9yZXJlbmRlciIsZGV0YWlsOntjb250ZXh0Omx9fSl9OnkubGVuZ3RofHwobS5iZWZvcmVSZW5kZXI9bnVsbCksYy5sZW5ndGgmJiFtLmFmdGVyUmVuZGVyP20uYWZ0ZXJSZW5kZXI9bD0+e3MuZGlzcGF0Y2hFdmVudCh7dHlwZToiYWZ0ZXJyZW5kZXIiLGRldGFpbDp7Y29udGV4dDpsfX0pfTpjLmxlbmd0aHx8KG0uYWZ0ZXJSZW5kZXI9bnVsbCl9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgxMikscz10KDIxOCksbT10KDcwKSx5PXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYz1TeW1ib2woImFtb3VudCIpLGw9U3ltYm9sKCJtZXNoQ2xvdWQiKTtjbGFzcyB1IGV4dGVuZHMgbS5kZWZhdWx0e2NvbnN0cnVjdG9yKGYsdj0xKXtzdXBlcigpLHRoaXMubWVzaE5vZGU9ZixmLmNvbm5lY3QodGhpcyksdGhpc1tjXT12LHRoaXNbbF09bnVsbH1nZXQgbWVzaENsb3VkKCl7Y29uc3QgZj10aGlzLm1lc2hOb2RlLHY9dGhpc1tjXTtyZXR1cm4hdGhpc1tsXSYmZi5tZXNoJiYodGhpc1tsXT1uZXcgci5NZXNoQ2xvdWQoZi5tZXNoLHYpKSx0aGlzW2xdfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hIXRoaXMubWVzaE5vZGUmJnRoaXMubWVzaE5vZGUuaXNWaXNpYmxlfWdldCBhbW91bnQoKXtyZXR1cm4gdGhpc1tjXX1zZXQgYW1vdW50KGYpe3RoaXNbY109Zix0aGlzW2xdJiYodGhpc1tsXS5hbW91bnQ9Zil9YnJpZ2h0bmVzcyhmLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuYnJpZ2h0bmVzcyhmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9Y29udHJhc3QoZix2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmNvbnRyYXN0KGYsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1kZWxldGUoZil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5kZWxldGUoZiksdGhpc1tjXS0tLHRoaXMuZm9yY2VVcGRhdGUoKSl9ZHJhdyhmPVtdKXtpZihzdXBlci5kcmF3KGYpLHRoaXMubWVzaENsb3VkKXtpZih0aGlzLnByb2dyYW0pe3RoaXMubWVzaENsb3VkLnNldFByb2dyYW0odGhpcy5wcm9ncmFtKTtjb25zdCB2PXRoaXMuc2hhZGVyQXR0cnM7diYmT2JqZWN0LmVudHJpZXModikuZm9yRWFjaCgoW1IsT10pPT57dGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRBdHRyaWJ1dGUoUixPKX0pO2NvbnN0IHg9dGhpcy51bmlmb3JtcztpZih0aGlzLnVuaWZvcm1zKXtjb25zdCBSPXt9O09iamVjdC5lbnRyaWVzKHgpLmZvckVhY2goKFtPLGddKT0+e3R5cGVvZiBnPT0iZnVuY3Rpb24iJiYoZz1nKHRoaXMsTykpLFJbT109Z30pLHRoaXMubWVzaENsb3VkLm1lc2guc2V0VW5pZm9ybXMoUil9fXRoaXMubWVzaE5vZGUudGV4dHVyZUltYWdlJiZPYmplY3Qocy5kcmF3VGV4dHVyZSkodGhpcy5tZXNoTm9kZSx0aGlzLm1lc2hOb2RlLm1lc2gpLGYucHVzaCh0aGlzLm1lc2hDbG91ZCl9cmV0dXJuIGZ9Z2V0VHJhbnNmb3JtKGYpe2lmKHRoaXMubWVzaENsb3VkKXJldHVybiB0aGlzLm1lc2hDbG91ZC5nZXRUcmFuc2Zvcm0oZil9Z3JheXNjYWxlKGYsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5ncmF5c2NhbGUoZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfWh1ZVJvdGF0ZShmLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaHVlUm90YXRlKGYsdiksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pbnZlcnQoZix2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmludmVydChmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9aXNQb2ludENvbGxpc2lvbihmLHYpe2lmKCF0aGlzLm1lc2hDbG91ZClyZXR1cm4hMTtjb25zdCB4PXRoaXMuYXR0cmlidXRlcy5wb2ludGVyRXZlbnRzO2lmKHg9PT0ibm9uZSJ8fHghPT0iYWxsIiYmIXRoaXMuaXNWaXNpYmxlKXJldHVybiExO2xldCBSPSJib3RoIjt4PT09InZpc2libGVGaWxsIiYmKFI9ImZpbGwiKSx4PT09InZpc2libGVTdHJva2UiJiYoUj0ic3Ryb2tlIik7Zm9yKGxldCBPPTA7Tzx0aGlzW2NdO08rKylpZighdGhpcy5tZXNoQ2xvdWQuaXNQb2ludENvbGxpc2lvbihPLFtmLHZdLFIpKXJldHVybiExO3JldHVybiEwfXNldE9wYWNpdHkoZix2KXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLm9wYWNpdHkoZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXJvdGF0ZShmLHYsW3gsUl09WzAsMF0pe2NvbnN0IE89TWF0aC5QSSp2LzE4MDtpZih0aGlzLm1lc2hDbG91ZCl7Y29uc3R7eDpnLHk6cH09dGhpcy5tZXNoTm9kZS5hdHRyaWJ1dGVzO3RoaXMubWVzaENsb3VkLnJvdGF0ZShmLE8sW3grZyxSK3BdKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNhdHVyYXRlKGYsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zYXR1cmF0ZShmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2NhbGUoZixbdix4PXZdLFtSLE9dPVswLDBdKXtpZih0aGlzLm1lc2hDbG91ZCl7Y29uc3R7eDpnLHk6cH09dGhpcy5tZXNoTm9kZS5hdHRyaWJ1dGVzLG49MWUtNTtNYXRoLmFicyh2KTxuJiYodj0xL3Y+MD9uOi1uKSxNYXRoLmFicyh4KTxuJiYoeD0xL3g+MD9uOi1uKSx0aGlzLm1lc2hDbG91ZC5zY2FsZShmLFt2LHhdLFtSK2csTytwXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX1zZXRDb2xvclRyYW5zZm9ybShmLHYpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuc2V0Q29sb3JUcmFuc2Zvcm0oZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNldEZpbGxDb2xvcihmLHYpe3RoaXMubWVzaENsb3VkJiYoQXJyYXkuaXNBcnJheSh2KSYmKHY9Wy4uLnZdLHZbMF0vPTI1NSx2WzFdLz0yNTUsdlsyXS89MjU1KSx0aGlzLm1lc2hDbG91ZC5zZXRGaWxsQ29sb3IoZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNlcGlhKGYsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXBpYShmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6dn0pe3N1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOmYsaGVpZ2h0OnZ9KSx0aGlzLm1lc2hOb2RlLnNldFJlc29sdXRpb24oe3dpZHRoOmYsaGVpZ2h0OnZ9KX1zZXRTdHJva2VDb2xvcihmLHYpe3RoaXMubWVzaENsb3VkJiYoQXJyYXkuaXNBcnJheSh2KSYmKHY9Wy4uLnZdLHZbMF0vPTI1NSx2WzFdLz0yNTUsdlsyXS89MjU1KSx0aGlzLm1lc2hDbG91ZC5zZXRTdHJva2VDb2xvcihmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0VHJhbnNmb3JtKGYsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRUcmFuc2Zvcm0oZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXNrZXcoZixbdix4PXZdLFtSLE9dPVswLDBdKXtpZih0aGlzLm1lc2hDbG91ZCl7Y29uc3R7eDpnLHk6cH09dGhpcy5tZXNoTm9kZS5hdHRyaWJ1dGVzO3RoaXMubWVzaENsb3VkLnNrZXcoZixbdix4XSxbUitnLE8rcF0pLHRoaXMuZm9yY2VVcGRhdGUoKX19dHJhbnNmb3JtKGYsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2Zvcm0oZix2KSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRyYW5zZm9ybUNvbG9yKGYsdil7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2Zvcm1Db2xvcihmLHYpLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNsYXRlKGYsW3YseF0pe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQudHJhbnNsYXRlKGYsW3YseF0pLHRoaXMuZm9yY2VVcGRhdGUoKSl9dXBkYXRlTWVzaCgpe3RoaXNbbF0mJih0aGlzW2xdLm1lc2g9dGhpcy5tZXNoTm9kZS5tZXNoLHRoaXMuZm9yY2VVcGRhdGUoKSl9fXkuZGVmYXVsdC5yZWdpc3Rlck5vZGUodSwiY2xvdWQiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwibG9hZFRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiYXBwbHlUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImNyZWF0ZVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZGVsZXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJkcmF3VGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJsb2FkRnJhbWVzIixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIHI9dCgxMikscz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgbT17fTtmdW5jdGlvbiB5KFIsTyl7aWYobVtSXSlyZXR1cm4gbVtSXTtjb25zdCBnPXIuRU5WLmxvYWRJbWFnZShSLHthbGlhczpPLHVzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIGc/P1J9YXN5bmMgZnVuY3Rpb24gYyhSLE8sZyl7bGV0IHA9TztpZih0eXBlb2YgTz09InN0cmluZyImJihwPXkoTykpLHAmJnR5cGVvZiBwLnRoZW49PSJmdW5jdGlvbiImJihwPWF3YWl0IHApLE89PT1SLmF0dHJpYnV0ZXMudGV4dHVyZSl7cCYmcC5pbWFnZSYmKHAuc291cmNlUmVjdCYmKFIuYXR0cmlidXRlcy5zb3VyY2VSZWN0PXAuc291cmNlUmVjdCksUi50ZXh0dXJlSW1hZ2VSb3RhdGVkPSEhcC5yb3RhdGVkLHA9cC5pbWFnZSk7Y29uc3R7d2lkdGg6bixoZWlnaHQ6YSx0ZXh0dXJlUmVjdDppfT1SLmF0dHJpYnV0ZXMsbz1SLnRleHR1cmVJbWFnZTtSLnRleHR1cmVJbWFnZT1wLGcmJm8hPT1wJiYhaSYmKG49PW51bGx8fGE9PW51bGwpJiZSLnVwZGF0ZUNvbnRvdXJzKCksUi5mb3JjZVVwZGF0ZSgpfXJldHVybiBwfWNvbnN0IGw9U3ltYm9sKCJ0ZXh0dXJlTWFwIik7ZnVuY3Rpb24gdShSLE8pe2lmKE9bbF09T1tsXXx8bmV3IE1hcCxPW2xdLmhhcyhSKSlyZXR1cm4gT1tsXS5nZXQoUik7Y29uc3QgZz1PLmNyZWF0ZVRleHR1cmUoUik7cmV0dXJuIS9eYmxvYjovLnRlc3QoUi5zcmMpJiZ0eXBlb2YgUi5nZXRDb250ZXh0IT0iZnVuY3Rpb24iJiZPW2xdLnNldChSLGcpLGd9ZnVuY3Rpb24gTShSLE8pe2lmKE9bbF0mJk9bbF0uaGFzKFIpKXtjb25zdCBnPU9bbF0uZ2V0KFIpO3JldHVybiBPLmRlbGV0ZVRleHR1cmUoZyksT1tsXS5kZWxldGUoUiksITB9cmV0dXJuITF9Y29uc3QgZj1TeW1ib2woInRleHR1cmVDb250ZXh0Iik7ZnVuY3Rpb24gdihSLE8pe2NvbnN0IGc9Ui50ZXh0dXJlSW1hZ2UgaW5zdGFuY2VvZiBTdHJpbmc/U3RyaW5nKFIudGV4dHVyZUltYWdlKTpSLnRleHR1cmVJbWFnZSxwPVIudGV4dHVyZUltYWdlUm90YXRlZCxuPU8udGV4dHVyZSxhPVIucmVuZGVyZXI7aWYoZyl7Y29uc3QgaT1SLm9yaWdpbmFsQ29udGVudFJlY3Q7bGV0IG89Ui5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0O2NvbnN0IFQ9Ui5hdHRyaWJ1dGVzLnRleHR1cmVSZXBlYXQsQT1SLmF0dHJpYnV0ZXMuc291cmNlUmVjdDtpZighbnx8UltmXSYmUltmXSE9PWF8fG4uaW1hZ2UhPT1nfHxuLm9wdGlvbnMucmVwZWF0IT09VHx8IU9iamVjdChzLmNvbXBhcmVWYWx1ZSkobi5vcHRpb25zLnJlY3Qsbyl8fCFPYmplY3Qocy5jb21wYXJlVmFsdWUpKG4ub3B0aW9ucy5zcmNSZWN0LEEpKXtjb25zdCBDPXUoZyxhKTtvPyhvWzBdKz1pWzBdLG9bMV0rPWlbMV0pOm89aTtsZXQgST1udWxsO24mJiFhW2xdLmhhcyhuLmltYWdlKSYmKCFuLm9wdGlvbnN8fCFuLm9wdGlvbnMuaGlkZGVuKSYmKEk9Ty51bmlmb3Jtcy51X3RleFNhbXBsZXIpLE8uc2V0VGV4dHVyZShDLHtyZWN0Om8scmVwZWF0OlQsc3JjUmVjdDpBLHJvdGF0ZWQ6cH0pLEkmJkkuZGVsZXRlJiZJLmRlbGV0ZSgpLFJbZl09YX19ZWxzZSBpZihuKXtsZXQgaT1udWxsOyFhW2xdLmhhcyhuLmltYWdlKSYmKCFuLm9wdGlvbnN8fCFuLm9wdGlvbnMuaGlkZGVuKSYmKGk9Ty51bmlmb3Jtcy51X3RleFNhbXBsZXIpLE8uc2V0VGV4dHVyZShudWxsKSxpJiZpLmRlbGV0ZSYmaS5kZWxldGUoKX19YXN5bmMgZnVuY3Rpb24geChSLE8pe3R5cGVvZiBPPT0ic3RyaW5nIiYmKE89YXdhaXQoYXdhaXQgZmV0Y2goTyx7bWV0aG9kOiJHRVQiLG1vZGU6ImNvcnMiLGNhY2hlOiJkZWZhdWx0In0pKS5qc29uKCkpO2NvbnN0IGc9YXdhaXQgeShSKSxwPU8uZnJhbWVzO3JldHVybiBPYmplY3QuZW50cmllcyhwKS5mb3JFYWNoKChbbixhXSk9Pntjb25zdHt4OmkseTpvLHc6VCxoOkF9PWEuZnJhbWU7bGV0IEM9W2ksbyxULEFdO2NvbnN0IEk9YS5yb3RhdGVkO0kmJihDPVtDWzBdLENbMV0sQ1szXSxDWzJdXSksbVtuXT17aW1hZ2U6Zyxzb3VyY2VSZWN0OkMscm90YXRlZDpJfX0pLGd9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIHI9dCgxKSxzPXQoMTIpLG09dCg3MCkseT10KDIyMCksYz10KDIyMSksbD10KDIyMiksdT10KDIxMyksTT10KDIyMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGYoUixPLGcpe3JldHVybiBPIGluIFI/T2JqZWN0LmRlZmluZVByb3BlcnR5KFIsTyx7dmFsdWU6ZyxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOlJbT109ZyxSfWNvbnN0IHY9U3ltYm9sKCJtZXNoIik7Y2xhc3MgeCBleHRlbmRzIG0uZGVmYXVsdHtjb25zdHJ1Y3RvcihPPXt9KXtzdXBlcihPKX1nZXQgYm9yZGVyU2l6ZSgpe2NvbnN0e3BhZGRpbmdUb3A6TyxwYWRkaW5nUmlnaHQ6ZyxwYWRkaW5nQm90dG9tOnAscGFkZGluZ0xlZnQ6bixib3JkZXJXaWR0aDphfT10aGlzLmF0dHJpYnV0ZXMsW2ksb109dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bbitpK2crYSxPK28rcCthXX1nZXQgY2xpZW50U2l6ZSgpe2NvbnN0e3BhZGRpbmdUb3A6TyxwYWRkaW5nUmlnaHQ6ZyxwYWRkaW5nQm90dG9tOnAscGFkZGluZ0xlZnQ6bn09dGhpcy5hdHRyaWJ1dGVzLFthLGldPXRoaXMuY29udGVudFNpemU7cmV0dXJuW24rYStnLE8raStwXX1nZXQgY29udGVudFNpemUoKXtsZXR7d2lkdGg6TyxoZWlnaHQ6Zyxib3hTaXppbmc6cCxwYWRkaW5nVG9wOm4scGFkZGluZ1JpZ2h0OmEscGFkZGluZ0JvdHRvbTppLHBhZGRpbmdMZWZ0Om99PXRoaXMuYXR0cmlidXRlcztpZihPPU98fDAsZz1nfHwwLHA9PT0iYm9yZGVyLWJveCIpe2NvbnN0IFQ9Mip0aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7Ty09VCthK28sZy09VCtuK2ksTz1NYXRoLm1heCgwLE8pLGc9TWF0aC5tYXgoMCxnKX1yZXR1cm5bTyxnXX1nZXQgaGFzQm9yZGVyKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aD4wfWdldCBpc1Zpc2libGUoKXtjb25zdFtPLGddPXRoaXMuYm9yZGVyU2l6ZTtyZXR1cm4gTz4wJiZnPjB9Z2V0IG1lc2goKXtpZih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT09PSJub25lIilyZXR1cm4gbnVsbDtjb25zdCBPPXRoaXMuY2xpZW50Qm94O2lmKE8pe2xldCBnPXRoaXNbdl07aWYoZylnLmJveCE9PU8mJihnLmNvbnRvdXJzPU8uY29udG91cnMsZy5ib3g9Tyk7ZWxzZXtnPW5ldyBzLk1lc2gyRChPKSxnLmJveD1PO2NvbnN0IG49dGhpcy5hdHRyaWJ1dGVzLmJnY29sb3I7aWYoT2JqZWN0KGMuc2V0RmlsbENvbG9yKShnLHtjb2xvcjpufSksdGhpcy5oYXNCb3JkZXIpe2NvbnN0e2JvcmRlckNvbG9yOmksYm9yZGVyV2lkdGg6byxib3JkZXJEYXNoOlQsYm9yZGVyRGFzaE9mZnNldDpBfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGMuc2V0U3Ryb2tlQ29sb3IpKGcse2NvbG9yOmksbGluZVdpZHRoOm8sbGluZURhc2g6VCxsaW5lRGFzaE9mZnNldDpBfSl9dGhpc1t2XT1nO2NvbnN0IGE9dGhpcy5hdHRyaWJ1dGVzLmNsaXBQYXRoO2EmJnRoaXNbdl0uc2V0Q2xpcFBhdGgoYSl9Y29uc3QgcD10aGlzLm9wYWNpdHk7cmV0dXJuIGcuZ2V0T3BhY2l0eSgpIT09cCYmZy5zZXRPcGFjaXR5KHApLGcuc2V0VHJhbnNmb3JtKC4uLnRoaXMucmVuZGVyTWF0cml4KSxnfXJldHVybiBudWxsfWdldCBvZmZzZXRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpPLHBhZGRpbmdSaWdodDpnLHBhZGRpbmdCb3R0b206cCxwYWRkaW5nTGVmdDpuLGJvcmRlcldpZHRoOmF9PXRoaXMuYXR0cmlidXRlcyxbaSxvXT10aGlzLmNvbnRlbnRTaXplLFQ9MiphO3JldHVybltuK2krZytULE8rbytwK1RdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IE89dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVybltPWzBdWzBdLE9bMF1bMV0sT1sxXVswXS1PWzBdWzBdLE9bMV1bMV0tT1swXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENvbnRlbnRSZWN0KCl7Y29uc3RbTyxnLHAsbl09dGhpcy5vcmlnaW5hbENsaWVudFJlY3QsYT10aGlzLmF0dHJpYnV0ZXMucGFkZGluZztyZXR1cm5bTythWzBdLGcrYVsxXSxwLWFbMF0tYVsyXSxuLWFbMV0tYVszXV19Z2V0Qm91bmRpbmdDbGllbnRSZWN0KCl7bGV0IE89dGhpcy5yZW5kZXJNYXRyaXg7dGhpcy5sYXllciYmdGhpcy5sYXllci5sYXllclRyYW5zZm9ybUludmVydCYmKE89ci5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksdGhpcy5sYXllci50cmFuc2Zvcm1NYXRyaXgsTykpO2xldCBnPW51bGw7aWYodGhpcy5tZXNoKXtnPVsuLi50aGlzLm1lc2guYm91bmRpbmdCb3hdO2NvbnN0IHA9dGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoO3AmJihnWzBdPVtnWzBdWzBdLXAsZ1swXVsxXS1wXSxnWzFdPVtnWzFdWzBdK3AsZ1sxXVsxXStwXSl9cmV0dXJuIE9iamVjdChNLmRlZmF1bHQpKGcsTyl9b25Qcm9wZXJ0eUNoYW5nZShPLGcscCl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShPLGcscCksKE89PT0iYW5jaG9yWCJ8fE89PT0iYW5jaG9yWSJ8fE89PT0iYm94U2l6aW5nInx8Tz09PSJ3aWR0aCJ8fE89PT0iaGVpZ2h0Inx8Tz09PSJib3JkZXJXaWR0aCJ8fE89PT0icGFkZGluZ0xlZnQifHxPPT09InBhZGRpbmdSaWdodCJ8fE89PT0icGFkZGluZ1RvcCJ8fE89PT0icGFkZGluZ0JvdHRvbSJ8fC9eYm9yZGVyKFRvcExlZnR8VG9wUmlnaHR8Qm90dG9tUmlnaHR8Qm90dG9tTGVmdClSYWRpdXMkLy50ZXN0KE8pKSYmdGhpcy51cGRhdGVDb250b3VycygpLHRoaXNbdl0mJk89PT0iY2xpcFBhdGgiJiZ0aGlzW3ZdLnNldENsaXBQYXRoKGcpLHRoaXNbdl0mJk89PT0iYmdjb2xvciImJk9iamVjdChjLnNldEZpbGxDb2xvcikodGhpc1t2XSx7Y29sb3I6Z30pLHRoaXNbdl0mJihPPT09ImJvcmRlckNvbG9yInx8Tz09PSJib3JkZXJXaWR0aCJ8fE89PT0iYm9yZGVyRGFzaCJ8fE89PT0iYm9yZGVyRGFzaE9mZnNldCIpKXtjb25zdHtib3JkZXJDb2xvcjpuLGJvcmRlcldpZHRoOmEsYm9yZGVyRGFzaDppLGJvcmRlckRhc2hPZmZzZXQ6b309dGhpcy5hdHRyaWJ1dGVzO09iamVjdChjLnNldFN0cm9rZUNvbG9yKSh0aGlzW3ZdLHtjb2xvcjpuLGxpbmVXaWR0aDphLGxpbmVEYXNoOmE/aTowLGxpbmVEYXNoT2Zmc2V0Om99KX19dXBkYXRlQ29udG91cnMoKXtjb25zdHthbmNob3JYOk8sYW5jaG9yWTpnLGJvcmRlcldpZHRoOnAsYm9yZGVyUmFkaXVzOm59PXRoaXMuYXR0cmlidXRlcyxbYSxpXT10aGlzLmJvcmRlclNpemUsbz10aGlzLm9mZnNldFNpemUsVD0uNSpwLEE9LU8qb1swXStULEM9LWcqb1sxXStUO3RoaXMuY2xpZW50Qm94PW5ldyBzLkZpZ3VyZTJELE9iamVjdChsLmNyZWF0ZVJhZGl1c0JveCkodGhpcy5jbGllbnRCb3gsW0EsQyxhLGldLG4pfX1mKHgsIkF0dHIiLHkuZGVmYXVsdCksdS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh4LCJibG9jayIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBNfSk7dmFyIHI9dCg3MSkscz10KDcyKSxtPXQoMjIxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgeT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7Y2xhc3MgTSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3Rvcih2KXtzdXBlcih2KSx0aGlzW2xdKHthbmNob3JYOjAsYW5jaG9yWTowLHdpZHRoOnZvaWQgMCxoZWlnaHQ6dm9pZCAwLGJvcmRlcldpZHRoOjAsYm9yZGVyQ29sb3I6InJnYmEoMCwwLDAsMSkiLGJvcmRlckRhc2g6dm9pZCAwLGJvcmRlckRhc2hPZmZzZXQ6MCxib3JkZXJUb3BMZWZ0UmFkaXVzOlswLDBdLGJvcmRlclRvcFJpZ2h0UmFkaXVzOlswLDBdLGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOlswLDBdLGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6WzAsMF0sYmdjb2xvcjoicmdiYSgwLDAsMCwwKSIscGFkZGluZ1RvcDowLHBhZGRpbmdSaWdodDowLHBhZGRpbmdCb3R0b206MCxwYWRkaW5nTGVmdDowLGJveFNpemluZzoiY29udGVudC1ib3giLGNsaXBQYXRoOnZvaWQgMH0pLHRoaXNbdV0oImFuY2hvciIsInNpemUiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJwYWRkaW5nIil9Z2V0IGFuY2hvclgoKXtyZXR1cm4gdGhpc1tjXSgiYW5jaG9yWCIpfXNldCBhbmNob3JYKHYpe3RoaXNbeV0oImFuY2hvclgiLE9iamVjdChzLnRvTnVtYmVyKSh2KSl9Z2V0IGFuY2hvclkoKXtyZXR1cm4gdGhpc1tjXSgiYW5jaG9yWSIpfXNldCBhbmNob3JZKHYpe3RoaXNbeV0oImFuY2hvclkiLE9iamVjdChzLnRvTnVtYmVyKSh2KSl9Z2V0IGFuY2hvcigpe3JldHVyblt0aGlzLmFuY2hvclgsdGhpcy5hbmNob3JZXX1zZXQgYW5jaG9yKHYpe3Y9T2JqZWN0KHMudG9BcnJheSkodiksQXJyYXkuaXNBcnJheSh2KXx8KHY9W3Ysdl0pLHRoaXMuYW5jaG9yWD12WzBdLHRoaXMuYW5jaG9yWT12WzFdfWdldCB3aWR0aCgpe3JldHVybiB0aGlzW2NdKCJ3aWR0aCIpfXNldCB3aWR0aCh2KXt0aGlzW3ldKCJ3aWR0aCIsT2JqZWN0KHMudG9OdW1iZXIpKHYpKX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbY10oImhlaWdodCIpfXNldCBoZWlnaHQodil7dGhpc1t5XSgiaGVpZ2h0IixPYmplY3Qocy50b051bWJlcikodikpfWdldCBzaXplKCl7cmV0dXJuW3RoaXMud2lkdGgsdGhpcy5oZWlnaHRdfXNldCBzaXplKHYpe3Y9T2JqZWN0KHMudG9BcnJheSkodiksQXJyYXkuaXNBcnJheSh2KXx8KHY9W3Ysdl0pLHRoaXMud2lkdGg9dlswXSx0aGlzLmhlaWdodD12WzFdfWdldCBib3JkZXJXaWR0aCgpe3JldHVybiB0aGlzW2NdKCJib3JkZXJXaWR0aCIpfXNldCBib3JkZXJXaWR0aCh2KXt0aGlzW3ldKCJib3JkZXJXaWR0aCIsT2JqZWN0KHMudG9OdW1iZXIpKHYpKX1nZXQgYm9yZGVyQ29sb3IoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyQ29sb3IiKX1zZXQgYm9yZGVyQ29sb3Iodil7dGhpc1t5XSgiYm9yZGVyQ29sb3IiLE9iamVjdChtLnBhcnNlQ29sb3IpKHYpKX1nZXQgYm9yZGVyKCl7cmV0dXJuW3RoaXMuYm9yZGVyV2lkdGgsdGhpcy5ib3JkZXJDb2xvcl19c2V0IGJvcmRlcih2KXt2PU9iamVjdChzLnRvQXJyYXkpKHYpLEFycmF5LmlzQXJyYXkodil8fCh2PVt2XSksdGhpcy5ib3JkZXJXaWR0aD12WzBdLHZbMV0hPW51bGwmJih0aGlzLmJvcmRlckNvbG9yPXZbMV0pfWdldCBib3JkZXJEYXNoKCl7cmV0dXJuIHRoaXNbY10oImJvcmRlckRhc2giKX1zZXQgYm9yZGVyRGFzaCh2KXt2PU9iamVjdChzLnRvQXJyYXkpKHYsITApLHYhPW51bGwmJiFBcnJheS5pc0FycmF5KHYpJiYodj1bdl0pLHRoaXNbeV0oImJvcmRlckRhc2giLHY/di5tYXAocy50b051bWJlcik6bnVsbCl9Z2V0IGJvcmRlckRhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyRGFzaE9mZnNldCIpfXNldCBib3JkZXJEYXNoT2Zmc2V0KHYpe3RoaXNbeV0oImJvcmRlckRhc2hPZmZzZXQiLE9iamVjdChzLnRvTnVtYmVyKSh2KSl9Z2V0IGJvcmRlclRvcExlZnRSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIpfXNldCBib3JkZXJUb3BMZWZ0UmFkaXVzKHYpe3Y9T2JqZWN0KHMudG9BcnJheSkodiwhMCksQXJyYXkuaXNBcnJheSh2KXx8KHY9W3Ysdl0pLHRoaXNbeV0oImJvcmRlclRvcExlZnRSYWRpdXMiLHYubWFwKHMudG9OdW1iZXIpKX1nZXQgYm9yZGVyVG9wUmlnaHRSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyVG9wUmlnaHRSYWRpdXMiKX1zZXQgYm9yZGVyVG9wUmlnaHRSYWRpdXModil7dj1PYmplY3Qocy50b0FycmF5KSh2LCEwKSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpc1t5XSgiYm9yZGVyVG9wUmlnaHRSYWRpdXMiLHYubWFwKHMudG9OdW1iZXIpKX1nZXQgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXModil7dj1PYmplY3Qocy50b0FycmF5KSh2LCEwKSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpc1t5XSgiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMiLHYubWFwKHMudG9OdW1iZXIpKX1nZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW2NdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIil9c2V0IGJvcmRlckJvdHRvbUxlZnRSYWRpdXModil7dj1PYmplY3Qocy50b0FycmF5KSh2LCEwKSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpc1t5XSgiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIsdi5tYXAocy50b051bWJlcikpfWdldCBib3JkZXJSYWRpdXMoKXtyZXR1cm5bLi4udGhpcy5ib3JkZXJUb3BMZWZ0UmFkaXVzLC4uLnRoaXMuYm9yZGVyVG9wUmlnaHRSYWRpdXMsLi4udGhpcy5ib3JkZXJCb3R0b21SaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbUxlZnRSYWRpdXNdfXNldCBib3JkZXJSYWRpdXModil7aWYodj1PYmplY3Qocy50b0FycmF5KSh2KSwhQXJyYXkuaXNBcnJheSh2KSl2PUFycmF5KDgpLmZpbGwodik7ZWxzZSBpZih2Lmxlbmd0aD09PTIpdj1bdlswXSx2WzFdLHZbMF0sdlsxXSx2WzBdLHZbMV0sdlswXSx2WzFdXTtlbHNlIGlmKHYubGVuZ3RoPT09NCl2PVt2WzBdLHZbMV0sdlsyXSx2WzNdLHZbMF0sdlsxXSx2WzJdLHZbM11dO2Vsc2UgaWYodi5sZW5ndGg9PT02KXY9W3ZbMF0sdlsxXSx2WzJdLHZbM10sdls0XSx2WzVdLHZbMl0sdlszXV07ZWxzZSBpZih2Lmxlbmd0aCE9PTgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3JkZXJSYWRpdXMgdmFsdWUuIik7dGhpcy5ib3JkZXJUb3BMZWZ0UmFkaXVzPVt2WzBdLHZbMV1dLHRoaXMuYm9yZGVyVG9wUmlnaHRSYWRpdXM9W3ZbMl0sdlszXV0sdGhpcy5ib3JkZXJCb3R0b21SaWdodFJhZGl1cz1bdls0XSx2WzVdXSx0aGlzLmJvcmRlckJvdHRvbUxlZnRSYWRpdXM9W3ZbNl0sdls3XV19Z2V0IGJnY29sb3IoKXtyZXR1cm4gdGhpc1tjXSgiYmdjb2xvciIpfXNldCBiZ2NvbG9yKHYpe3RoaXNbeV0oImJnY29sb3IiLE9iamVjdChtLnBhcnNlQ29sb3IpKHYpKX1nZXQgcGFkZGluZ1RvcCgpe3JldHVybiB0aGlzW2NdKCJwYWRkaW5nVG9wIil9c2V0IHBhZGRpbmdUb3Aodil7dGhpc1t5XSgicGFkZGluZ1RvcCIsT2JqZWN0KHMudG9OdW1iZXIpKHYpKX1nZXQgcGFkZGluZ1JpZ2h0KCl7cmV0dXJuIHRoaXNbY10oInBhZGRpbmdSaWdodCIpfXNldCBwYWRkaW5nUmlnaHQodil7dGhpc1t5XSgicGFkZGluZ1JpZ2h0IixPYmplY3Qocy50b051bWJlcikodikpfWdldCBwYWRkaW5nQm90dG9tKCl7cmV0dXJuIHRoaXNbY10oInBhZGRpbmdCb3R0b20iKX1zZXQgcGFkZGluZ0JvdHRvbSh2KXt0aGlzW3ldKCJwYWRkaW5nQm90dG9tIixPYmplY3Qocy50b051bWJlcikodikpfWdldCBwYWRkaW5nTGVmdCgpe3JldHVybiB0aGlzW2NdKCJwYWRkaW5nTGVmdCIpfXNldCBwYWRkaW5nTGVmdCh2KXt0aGlzW3ldKCJwYWRkaW5nTGVmdCIsT2JqZWN0KHMudG9OdW1iZXIpKHYpKX1nZXQgcGFkZGluZygpe3JldHVyblt0aGlzLnBhZGRpbmdUb3AsdGhpcy5wYWRkaW5nUmlnaHQsdGhpcy5wYWRkaW5nQm90dG9tLHRoaXMucGFkZGluZ0xlZnRdfXNldCBwYWRkaW5nKHYpe3Y9T2JqZWN0KHMudG9BcnJheSkodiksQXJyYXkuaXNBcnJheSh2KT92Lmxlbmd0aD09PTI/dj1bdlswXSx2WzFdLHZbMF0sdlsxXV06di5sZW5ndGg9PT0zJiYodj1bdlswXSx2WzFdLHZbMl0sdlsxXV0pOnY9W3Ysdix2LHZdLHRoaXMucGFkZGluZ1RvcD12WzBdLHRoaXMucGFkZGluZ1JpZ2h0PXZbMV0sdGhpcy5wYWRkaW5nQm90dG9tPXZbMl0sdGhpcy5wYWRkaW5nTGVmdD12WzNdfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW2NdKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aCh2KXt0aGlzW3ldKCJjbGlwUGF0aCIsdil9Z2V0IGJveFNpemluZygpe3JldHVybiB0aGlzW2NdKCJib3hTaXppbmciKX1zZXQgYm94U2l6aW5nKHYpe2lmKHYhPW51bGwmJnYhPT0iYm9yZGVyLWJveCImJnYhPT0iY29udGVudC1ib3giKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYm94U2l6aW5nIHR5cGUuIik7dGhpc1t5XSgiYm94U2l6aW5nIix2KX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJHcmFkaWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJpc1RyYW5zcGFyZW50IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2V0RmlsbENvbG9yIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldFN0cm9rZUNvbG9yIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIHI9dCgzMikscz10Lm4ocik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIG17Y29uc3RydWN0b3Ioe3ZlY3Rvcjp4LGNvbG9yczpSfSl7aWYoIUFycmF5LmlzQXJyYXkoeCl8fHgubGVuZ3RoIT09NCYmeC5sZW5ndGghPT02JiZ4Lmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBncmFkaWVudCIpO3RoaXMudmVjdG9yPXgsdGhpcy5jb2xvcnM9Ui5tYXAoKHtvZmZzZXQ6Tyxjb2xvcjpnfSk9Pih7b2Zmc2V0Ok8sY29sb3I6YyhnKX0pKX10b1N0cmluZygpe3JldHVybiBKU09OLnN0cmluZ2lmeSh7dmVjdG9yOnRoaXMudmVjdG9yLGNvbG9yczp0aGlzLmNvbG9yc30pfX1mdW5jdGlvbiB5KHYpe3JldHVybiB2IGluc3RhbmNlb2YgbT8hMTp2PT1udWxsPyEwOnMoKSh2KVszXT09PTB9ZnVuY3Rpb24gYyh2KXtpZih2PT1udWxsfHwodnx8KHY9InRyYW5zcGFyZW50IiksdiBpbnN0YW5jZW9mIG0pKXJldHVybiB2O2NvbnN0IHg9cygpKHYpO2lmKCF4fHwheC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5gcmdiYSgke3guam9pbigpfSlgfWZ1bmN0aW9uIGwodix4LFIpe2NvbnN0IE89di5ib3VuZGluZ0JveFswXTtpZihSLnZlY3Rvcil7bGV0e3ZlY3RvcjpnLGNvbG9yczpwfT1SO2cubGVuZ3RoPT09ND8oZz1bZ1swXStPWzBdLGdbMV0rT1sxXSxnWzJdK09bMF0sZ1szXStPWzFdXSx2LnNldExpbmVhckdyYWRpZW50KHt2ZWN0b3I6Zyxjb2xvcnM6cCx0eXBlOnh9KSk6Zy5sZW5ndGg9PT0zPyhnPVtnWzBdK09bMF0sZ1sxXStPWzFdLGdbMl1dLHYuc2V0Q2lyY3VsYXJHcmFkaWVudCh7dmVjdG9yOmcsY29sb3JzOnAsdHlwZTp4fSkpOihnPVtnWzBdK09bMF0sZ1sxXStPWzFdLGdbMl0sZ1szXStPWzBdLGdbNF0rT1sxXSxnWzVdXSx2LnNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6Zyxjb2xvcnM6cCx0eXBlOnh9KSl9ZWxzZSB2LmdyYWRpZW50JiZ2LmdyYWRpZW50W3hdJiYoZGVsZXRlIHYuZ3JhZGllbnRbeF0sZGVsZXRlIHYudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3Rvcil9ZnVuY3Rpb24gdSh2LHtjb2xvcjp4LHJ1bGU6Uj0ibm9uemVybyJ9KXtyZXR1cm4gbCh2LCJmaWxsIix4KSx4LnZlY3Rvcnx8di5zZXRGaWxsKHtjb2xvcjp4LHJ1bGU6Un0pLHZ9ZnVuY3Rpb24gTSh2LHtjb2xvcjp4LGxpbmVXaWR0aDpSLGxpbmVDYXA6TyxsaW5lSm9pbjpnLGxpbmVEYXNoOnAsbGluZURhc2hPZmZzZXQ6bixtaXRlckxpbWl0OmEscm91bmRTZWdtZW50czppfSl7bCh2LCJzdHJva2UiLHgpLHgudmVjdG9yJiYoeD1bMCwwLDAsMV0pLHYuc2V0U3Ryb2tlKHtjb2xvcjp4LHRoaWNrbmVzczpSLGNhcDpPLGpvaW46ZyxtaXRlckxpbWl0OmEsbGluZURhc2g6cCxsaW5lRGFzaE9mZnNldDpuLHJvdW5kU2VnbWVudHM6aX0pfWNsYXNzIGYgZXh0ZW5kcyBBcnJheXtjb25zdHJ1Y3Rvcih4PTAsUj0wLE89MCxnPTApe3JldHVybiBBcnJheS5pc0FycmF5KHgpJiYoW3gsUixPLGddPXgpLHR5cGVvZiB4PT0ic3RyaW5nIiYmKFt4LFIsTyxnXT1zKCkoeCkseC89MjU1LFIvPTI1NSxPLz0yNTUpLHN1cGVyKHgsUixPLGcpLHRoaXN9Z2V0IHIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzBdKjI1NSl9c2V0IHIoeCl7dGhpc1swXT14LzI1NX1nZXQgZygpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMV0qMjU1KX1zZXQgZyh4KXt0aGlzWzFdPXgvMjU1fWdldCBiKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1syXSoyNTUpfXNldCBiKHgpe3RoaXNbMl09eC8yNTV9Z2V0IGEoKXtyZXR1cm4gdGhpc1szXX1zZXQgYSh4KXt0aGlzWzNdPXh9Z2V0IGhleCgpe2NvbnN0IHg9YDAke3RoaXMuci50b1N0cmluZygxNil9YC5zbGljZSgtMiksUj1gMCR7dGhpcy5nLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxPPWAwJHt0aGlzLmIudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpO2xldCBnO3JldHVybiB0aGlzLmE8MSYmKGc9TWF0aC5yb3VuZCh0aGlzWzNdKjI1NSksZz1gMCR7Zy50b1N0cmluZygxNil9YC5zbGljZSgtMikpLGAjJHt4fSR7Un0ke099JHtnfHwiIn1gfWdldCByZ2JhKCl7cmV0dXJuYHJnYmEoJHt0aGlzLnJ9LCR7dGhpcy5nfSwke3RoaXMuYn0sJHt0aGlzLmF9KWB9ZnJvbUNvbG9yKHgpe3JldHVybiB0eXBlb2YgeD09InN0cmluZyImJih4PXMoKSh4KSx4WzBdLz0yNTUseFsxXS89MjU1LHhbMl0vPTI1NSksdGhpc1swXT14WzBdLHRoaXNbMV09eFsxXSx0aGlzWzJdPXhbMl0sdGhpc1szXT14WzNdLHRoaXN9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlUmFkaXVzQm94IixmdW5jdGlvbigpe3JldHVybiBzfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHIobSx5LGMsbCx1LE09ImxlZnRUb3AiKXtjb25zdCBmPS41NTIyODQ4LHY9bC8yKmYseD11LzIqZixSPXkrbCxPPWMrdSxnPXkrbC8yLHA9Yyt1LzI7TT09PSJsZWZ0VG9wIj8obS5tb3ZlVG8oeSxwKSxtLmJlemllckN1cnZlVG8oeSxwLXgsZy12LGMsZyxjKSk6TT09PSJyaWdodFRvcCI/bS5iZXppZXJDdXJ2ZVRvKGcrdixjLFIscC14LFIscCk6TT09PSJyaWdodEJvdHRvbSI/bS5iZXppZXJDdXJ2ZVRvKFIscCt4LGcrdixPLGcsTyk6TT09PSJsZWZ0Qm90dG9tIiYmbS5iZXppZXJDdXJ2ZVRvKGctdixPLHkscCt4LHkscCl9ZnVuY3Rpb24gcyhtLFt5LGMsbCx1XSxNKXtpZighTXx8QXJyYXkuaXNBcnJheShNKSYmTS5ldmVyeShmPT5mPT09MCkpbS5iZWdpblBhdGgoKSxtLnJlY3QoeSxjLGwsdSk7ZWxzZXt0eXBlb2YgTT09Im51bWJlciImJihNPUFycmF5KDgpLmZpbGwoTSkpO2NvbnN0W2Ysdix4LFIsTyxnLHAsbl09TS5tYXAoKGEsaSk9PmklMj9NYXRoLm1pbihhLHUvMik6TWF0aC5taW4oYSxsLzIpKTttLmJlZ2luUGF0aCgpLG0ubW92ZVRvKHksYyt2KSxyKG0seSxjLGYqMix2KjIsImxlZnRUb3AiKSxtLmxpbmVUbyh5K2wteCxjKSxyKG0seStsLXgqMixjLHgqMixSKjIsInJpZ2h0VG9wIiksbS5saW5lVG8oeStsLGMrdS1nKSxyKG0seStsLU8qMixjK3UtZyoyLE8qMixnKjIsInJpZ2h0Qm90dG9tIiksbS5saW5lVG8oeStwLGMrdSkscihtLHksYyt1LW4qMixwKjIsbioyLCJsZWZ0Qm90dG9tIiksbS5jbG9zZVBhdGgoKX1yZXR1cm4gbX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpLGUuZGVmYXVsdD1mdW5jdGlvbihyLHMpe2lmKCFyKXJldHVybnt4OjAseTowLHdpZHRoOjAsaGVpZ2h0OjAsbGVmdDowLHRvcDowLHJpZ2h0OjAsYm90dG9tOjB9O2NvbnN0W1ttLHldLFtjLGxdXT1yLHU9bSpzWzBdK3kqc1syXStzWzRdLE09bSpzWzFdK3kqc1szXStzWzVdLGY9YypzWzBdK3kqc1syXStzWzRdLHY9YypzWzFdK3kqc1szXStzWzVdLHg9YypzWzBdK2wqc1syXStzWzRdLFI9YypzWzFdK2wqc1szXStzWzVdLE89bSpzWzBdK2wqc1syXStzWzRdLGc9bSpzWzFdK2wqc1szXStzWzVdLHA9TWF0aC5taW4odSxmLHgsTyksbj1NYXRoLm1pbihNLHYsUixnKSxhPU1hdGgubWF4KHUsZix4LE8pLGk9TWF0aC5tYXgoTSx2LFIsZyk7cmV0dXJue3g6cCx5Om4sd2lkdGg6YS1wLGhlaWdodDppLW4sbGVmdDpwLHRvcDpuLHJpZ2h0OmEsYm90dG9tOml9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjE4KSxzPXQoMjE5KSxtPXQoMjI1KSx5PXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYyhNLGYsdil7cmV0dXJuIGYgaW4gTT9PYmplY3QuZGVmaW5lUHJvcGVydHkoTSxmLHt2YWx1ZTp2LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6TVtmXT12LE19Y29uc3QgbD1TeW1ib2woInRleHR1cmVUYXNrIik7Y2xhc3MgdSBleHRlbmRzIHMuZGVmYXVsdHtjb25zdHJ1Y3RvcihmPXt9KXt0eXBlb2YgZj09InN0cmluZyImJihmPXt0ZXh0dXJlOmZ9KSxzdXBlcihmKX1nZXQgY29udGVudFNpemUoKXtsZXRbZix2XT1zdXBlci5jb250ZW50U2l6ZTtjb25zdHt3aWR0aDp4LGhlaWdodDpSfT10aGlzLmF0dHJpYnV0ZXM7aWYoeD09bnVsbHx8Uj09bnVsbCl7Y29uc3QgTz10aGlzLnRleHR1cmVJbWFnZSxnPXRoaXMuYXR0cmlidXRlcy50ZXh0dXJlUmVjdCxwPXRoaXMuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKGcpeD09bnVsbCYmKGY9Z1swXStnWzJdKSxSPT1udWxsJiYodj1nWzFdK2dbM10pO2Vsc2UgaWYocCl7Y29uc3Qgbj10aGlzLmxheWVyP3RoaXMubGF5ZXIuZGlzcGxheVJhdGlvOjE7eD09bnVsbCYmKGY9cFsyXS9uKSxSPT1udWxsJiYodj1wWzNdL24pfWVsc2UgaWYoTyl7Y29uc3Qgbj10aGlzLmxheWVyP3RoaXMubGF5ZXIuZGlzcGxheVJhdGlvOjE7eD09bnVsbCYmKGY9Ty53aWR0aC9uKSxSPT1udWxsJiYodj1PLmhlaWdodC9uKX19cmV0dXJuW2Ysdl19Z2V0IHRleHR1cmVJbWFnZVJlYWR5KCl7cmV0dXJuIHRoaXNbbF18fFByb21pc2UucmVzb2x2ZSgpfWRyYXcoZj1bXSl7c3VwZXIuZHJhdyhmKTtjb25zdCB2PXRoaXMubWVzaDtyZXR1cm4gdiYmT2JqZWN0KHIuZHJhd1RleHR1cmUpKHRoaXMsdiksZn1vblByb3BlcnR5Q2hhbmdlKGYsdix4KXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKGYsdix4KSxmPT09InRleHR1cmUiJiYodGhpc1tsXT1PYmplY3Qoci5hcHBseVRleHR1cmUpKHRoaXMsdiwhMCkpLGY9PT0idGV4dHVyZVJlY3QiKXtjb25zdHt3aWR0aDpSLGhlaWdodDpPfT10aGlzLmF0dHJpYnV0ZXM7KFI9PW51bGx8fE89PW51bGwpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCl9fX1jKHUsIkF0dHIiLG0uZGVmYXVsdCkseS5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh1LCJzcHJpdGUiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgcz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksbT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx5PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IodSl7c3VwZXIodSksdGhpc1tzXSh7dGV4dHVyZTp2b2lkIDAsdGV4dHVyZVJlY3Q6dm9pZCAwLHRleHR1cmVSZXBlYXQ6ITEsc291cmNlUmVjdDp2b2lkIDB9KX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW3ldKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUodSl7dGhpc1ttXSgidGV4dHVyZSIsdSl9Z2V0IHRleHR1cmVSZWN0KCl7cmV0dXJuIHRoaXNbeV0oInRleHR1cmVSZWN0Iil9c2V0IHRleHR1cmVSZWN0KHUpe3RoaXNbbV0oInRleHR1cmVSZWN0Iix1KX1nZXQgc291cmNlUmVjdCgpe3JldHVybiB0aGlzW3ldKCJzb3VyY2VSZWN0Iil9c2V0IHNvdXJjZVJlY3QodSl7dGhpc1ttXSgic291cmNlUmVjdCIsdSl9Z2V0IHRleHR1cmVSZXBlYXQoKXtyZXR1cm4gdGhpc1t5XSgidGV4dHVyZVJlcGVhdCIpfXNldCB0ZXh0dXJlUmVwZWF0KHUpe3RoaXNbbV0oInRleHR1cmVSZXBlYXQiLCEhdSl9fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pO3ZhciByPXQoMTIpLHM9dCgyMjcpLG09dC5uKHMpLHk9dCg3MCksYz10KDIyOCksbD10KDIyMSksdT10KDIxOCksTT10KDIxMyksZj10KDIyMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYoTyxnLHApe3JldHVybiBnIGluIE8/T2JqZWN0LmRlZmluZVByb3BlcnR5KE8sZyx7dmFsdWU6cCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOk9bZ109cCxPfWNvbnN0IHg9U3ltYm9sKCJtZXNoIik7Y2xhc3MgUiBleHRlbmRzIHkuZGVmYXVsdHtjb25zdHJ1Y3RvcihnPXt9KXt0eXBlb2YgZz09InN0cmluZyImJihnPXtkOmd9KSxzdXBlcihnKSx0aGlzLmVmZmVjdHM9e2QocCxuLGEsaSxvKXtjb25zdCBUPShhLWkpLyhvLWkpO2lmKFQ8PTApcmV0dXJuIHA7aWYoVD49MSlyZXR1cm4gbjtjb25zdCBBPW0uYS5fcHJlcHJvY2Vzc2luZyhtLmEucGF0aDJzaGFwZXMocCksbS5hLnBhdGgyc2hhcGVzKG4pKSxDPW0uYS5fbGVycCguLi5BLFQpWzBdO3JldHVybiBDLnJlZHVjZSgoUCxMKT0+YCR7UH0ke0wuc2xpY2UoMikuam9pbigiICIpfSBgLGBNJHtDWzBdWzBdfSAke0NbMF1bMV19Q2ApLnRyaW0oKX19fWdldCBpc1Zpc2libGUoKXtyZXR1cm4hIXRoaXMuZH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IGc9dGhpcy5wYXRoO2lmKGcpe2xldCBwPXRoaXNbeF07aWYocClwLnBhdGghPT1nJiYocC5jb250b3Vycz1nLmNvbnRvdXJzLHAucGF0aD1nKTtlbHNle3A9bmV3IHIuTWVzaDJEKHRoaXMucGF0aCkscC5wYXRoPWc7Y29uc3QgYT10aGlzLmF0dHJpYnV0ZXMuZmlsbENvbG9yLGk9dGhpcy5hdHRyaWJ1dGVzLmZpbGxSdWxlO2EmJk9iamVjdChsLnNldEZpbGxDb2xvcikocCx7Y29sb3I6YSxydWxlOml9KTtjb25zdCBvPXRoaXMuYXR0cmlidXRlcy5saW5lV2lkdGgsVD10aGlzLmF0dHJpYnV0ZXMuc3Ryb2tlQ29sb3I7aWYoVCYmbz4wKXtjb25zdHtsaW5lQ2FwOkMsbGluZUpvaW46SSxtaXRlckxpbWl0OlAsbGluZURhc2g6TCxsaW5lRGFzaE9mZnNldDpELHJvdW5kU2VnbWVudHM6Yn09dGhpcy5hdHRyaWJ1dGVzO09iamVjdChsLnNldFN0cm9rZUNvbG9yKShwLHtjb2xvcjpULGxpbmVXaWR0aDpvLGxpbmVDYXA6QyxsaW5lSm9pbjpJLG1pdGVyTGltaXQ6UCxsaW5lRGFzaDpMLGxpbmVEYXNoT2Zmc2V0OkQscm91bmRTZWdtZW50czpifSl9dGhpc1t4XT1wO2NvbnN0IEE9dGhpcy5hdHRyaWJ1dGVzLmNsaXBQYXRoO0EmJnRoaXNbeF0uc2V0Q2xpcFBhdGgoQSl9Y29uc3Qgbj10aGlzLm9wYWNpdHk7cmV0dXJuIHAuZ2V0T3BhY2l0eSgpIT09biYmcC5zZXRPcGFjaXR5KG4pLHAuc2V0VHJhbnNmb3JtKC4uLnRoaXMucmVuZGVyTWF0cml4KSxwfXJldHVybiBudWxsfWdldCBvcmlnaW5hbENvbnRlbnRSZWN0KCl7aWYodGhpcy5wYXRoKXtjb25zdCBnPXRoaXMucGF0aC5ib3VuZGluZ0JveDtyZXR1cm5bZ1swXVswXSxnWzBdWzFdLGdbMV1bMF0tZ1swXVswXSxnWzFdWzFdLWdbMF1bMV1dfXJldHVyblswLDAsMCwwXX1nZXQgb3JpZ2luYWxDbGllbnRSZWN0KCl7aWYodGhpcy5tZXNoKXtjb25zdCBnPXRoaXMubWVzaC5ib3VuZGluZ0JveDtyZXR1cm5bZ1swXVswXSxnWzBdWzFdLGdbMV1bMF0tZ1swXVswXSxnWzFdWzFdLWdbMF1bMV1dfXJldHVyblswLDAsMCwwXX1nZXQgb3JpZ2luYWxDbGllbnRDZW50ZXIoKXtyZXR1cm4gdGhpcy5tZXNoP3RoaXMubWVzaC5ib3VuZGluZ0NlbnRlcjpbMCwwXX1zZXQgZChnKXt0aGlzLmF0dHJpYnV0ZXMuZD1nfWdldCBkKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5kfWRyYXcoZz1bXSl7c3VwZXIuZHJhdyhnKTtjb25zdCBwPXRoaXMubWVzaDtyZXR1cm4gcCYmT2JqZWN0KHUuZHJhd1RleHR1cmUpKHRoaXMscCksZ31nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgZz1udWxsO3JldHVybiB0aGlzLm1lc2gmJihnPXRoaXMubWVzaC5ib3VuZGluZ0JveCksT2JqZWN0KGYuZGVmYXVsdCkoZyx0aGlzLnJlbmRlck1hdHJpeCl9Z2V0UGF0aExlbmd0aCgpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmdldFRvdGFsTGVuZ3RoKCk6MH1nZXRQb2ludEF0TGVuZ3RoKGcpe2lmKHRoaXMubWVzaCl7Y29uc3QgcD10aGlzLm1lc2guZ2V0UG9pbnRBdExlbmd0aChnKTtpZihwKXJldHVybltwLngscC55XX1yZXR1cm5bMCwwXX1vblByb3BlcnR5Q2hhbmdlKGcscCxuKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKGcscCxuKSwoZz09PSJkInx8Zz09PSJub3JtYWxpemUiKSYmdGhpcy51cGRhdGVDb250b3VycygpLHRoaXNbeF0mJihnPT09ImZpbGxDb2xvciJ8fGc9PT0iZmlsbFJ1bGUiKSl7Y29uc3R7ZmlsbENvbG9yOmEsZmlsbFJ1bGU6aX09dGhpcy5hdHRyaWJ1dGVzO09iamVjdChsLnNldEZpbGxDb2xvcikodGhpc1t4XSx7Y29sb3I6YSxydWxlOml9KX1pZih0aGlzW3hdJiYoZz09PSJzdHJva2VDb2xvciJ8fGc9PT0ibGluZVdpZHRoInx8Zz09PSJsaW5lQ2FwInx8Zz09PSJsaW5lSm9pbiJ8fGc9PT0ibGluZURhc2gifHxnPT09ImxpbmVEYXNoT2Zmc2V0Inx8Zz09PSJyb3VuZFNlZ21lbnRzIikpe2NvbnN0e3N0cm9rZUNvbG9yOmEsbGluZVdpZHRoOml9PXRoaXMuYXR0cmlidXRlcztpZihhJiZpPjApe2NvbnN0e2xpbmVDYXA6byxsaW5lSm9pbjpULGxpbmVEYXNoOkEsbGluZURhc2hPZmZzZXQ6QyxtaXRlckxpbWl0Okkscm91bmRTZWdtZW50czpQfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGwuc2V0U3Ryb2tlQ29sb3IpKHRoaXNbeF0se2NvbG9yOmEsbGluZUNhcDpvLGxpbmVKb2luOlQsbGluZVdpZHRoOmksbGluZURhc2g6QSxsaW5lRGFzaE9mZnNldDpDLG1pdGVyTGltaXQ6SSxyb3VuZFNlZ21lbnRzOlB9KX19dGhpc1t4XSYmZz09PSJjbGlwUGF0aCImJnRoaXNbeF0uc2V0Q2xpcFBhdGgocCksZz09PSJ0ZXh0dXJlIiYmT2JqZWN0KHUuYXBwbHlUZXh0dXJlKSh0aGlzLHApfXVwZGF0ZUNvbnRvdXJzKCl7dGhpcy5wYXRoPW5ldyByLkZpZ3VyZTJELHRoaXMucGF0aC5hZGRQYXRoKHRoaXMuYXR0cmlidXRlcy5kKSx0aGlzLmF0dHJpYnV0ZXMubm9ybWFsaXplJiZ0aGlzLnBhdGgubm9ybWFsaXplKC4uLnRoaXMucGF0aC5ib3VuZGluZ0NlbnRlcil9fXYoUiwiQXR0ciIsYy5kZWZhdWx0KSxNLmRlZmF1bHQucmVnaXN0ZXJOb2RlKFIsInBhdGgiKX0sZnVuY3Rpb24oaCxlLHQpeyhmdW5jdGlvbihyLHMpe2guZXhwb3J0cz1zKCl9KSh0aGlzLGZ1bmN0aW9uKCl7dmFyIHI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBMKEQsYil7dmFyIFM9W10sQj0hMCx3PSExLEg9dm9pZCAwO3RyeXtmb3IodmFyIEo9RFtTeW1ib2wuaXRlcmF0b3JdKCkscTshKEI9KHE9Si5uZXh0KCkpLmRvbmUpJiYoUy5wdXNoKHEudmFsdWUpLCEoYiYmUy5sZW5ndGg9PT1iKSk7Qj0hMCk7fWNhdGNoKFcpe3c9ITAsSD1XfWZpbmFsbHl7dHJ5eyFCJiZKLnJldHVybiYmSi5yZXR1cm4oKX1maW5hbGx5e2lmKHcpdGhyb3cgSH19cmV0dXJuIFN9cmV0dXJuIGZ1bmN0aW9uKEQsYil7aWYoQXJyYXkuaXNBcnJheShEKSlyZXR1cm4gRDtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KEQpKXJldHVybiBMKEQsYik7dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZSIpfX0oKSxzPU1hdGguUEkqMixtPWZ1bmN0aW9uKEQsYixTLEIsdyxILEope3ZhciBxPUQueCxXPUQueTtxKj1iLFcqPVM7dmFyIEc9QipxLXcqVyxRPXcqcStCKlc7cmV0dXJue3g6RytILHk6UStKfX0seT1mdW5jdGlvbihELGIpe3ZhciBTPTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihiLzQpLEI9TWF0aC5jb3MoRCksdz1NYXRoLnNpbihEKSxIPU1hdGguY29zKEQrYiksSj1NYXRoLnNpbihEK2IpO3JldHVyblt7eDpCLXcqUyx5OncrQipTfSx7eDpIK0oqUyx5OkotSCpTfSx7eDpILHk6Sn1dfSxjPWZ1bmN0aW9uKEQsYixTLEIpe3ZhciB3PUQqQi1iKlM8MD8tMToxLEg9TWF0aC5zcXJ0KEQqRCtiKmIpLEo9TWF0aC5zcXJ0KEQqRCtiKmIpLHE9RCpTK2IqQixXPXEvKEgqSik7cmV0dXJuIFc+MSYmKFc9MSksVzwtMSYmKFc9LTEpLHcqTWF0aC5hY29zKFcpfSxsPWZ1bmN0aW9uKEQsYixTLEIsdyxILEoscSxXLEcsUSx0dCl7dmFyIF89TWF0aC5wb3codywyKSxzdD1NYXRoLnBvdyhILDIpLGs9TWF0aC5wb3coUSwyKSxjdD1NYXRoLnBvdyh0dCwyKSxmdD1fKnN0LV8qY3Qtc3QqaztmdDwwJiYoZnQ9MCksZnQvPV8qY3Qrc3QqayxmdD1NYXRoLnNxcnQoZnQpKihKPT09cT8tMToxKTt2YXIgVT1mdCp3L0gqdHQsRj1mdCotSC93KlEsVj1HKlUtVypGKyhEK1MpLzIsWD1XKlUrRypGKyhiK0IpLzIsaj0oUS1VKS93LHo9KHR0LUYpL0gsZD0oLVEtVSkvdyxFPSgtdHQtRikvSCxOPWMoMSwwLGoseiksJD1jKGoseixkLEUpO3JldHVybiBxPT09MCYmJD4wJiYoJC09cykscT09PTEmJiQ8MCYmKCQrPXMpLFtWLFgsTiwkXX0sdT1mdW5jdGlvbihEKXt2YXIgYj1ELnB4LFM9RC5weSxCPUQuY3gsdz1ELmN5LEg9RC5yeCxKPUQucnkscT1ELnhBeGlzUm90YXRpb24sVz1xPT09dm9pZCAwPzA6cSxHPUQubGFyZ2VBcmNGbGFnLFE9Rz09PXZvaWQgMD8wOkcsdHQ9RC5zd2VlcEZsYWcsXz10dD09PXZvaWQgMD8wOnR0LHN0PVtdO2lmKEg9PT0wfHxKPT09MClyZXR1cm5bXTt2YXIgaz1NYXRoLnNpbihXKnMvMzYwKSxjdD1NYXRoLmNvcyhXKnMvMzYwKSxmdD1jdCooYi1CKS8yK2sqKFMtdykvMixVPS1rKihiLUIpLzIrY3QqKFMtdykvMjtpZihmdD09PTAmJlU9PT0wKXJldHVybltdO0g9TWF0aC5hYnMoSCksSj1NYXRoLmFicyhKKTt2YXIgRj1NYXRoLnBvdyhmdCwyKS9NYXRoLnBvdyhILDIpK01hdGgucG93KFUsMikvTWF0aC5wb3coSiwyKTtGPjEmJihIKj1NYXRoLnNxcnQoRiksSio9TWF0aC5zcXJ0KEYpKTt2YXIgVj1sKGIsUyxCLHcsSCxKLFEsXyxrLGN0LGZ0LFUpLFg9cihWLDQpLGo9WFswXSx6PVhbMV0sZD1YWzJdLEU9WFszXSxOPU1hdGgubWF4KE1hdGguY2VpbChNYXRoLmFicyhFKS8ocy80KSksMSk7RS89Tjtmb3IodmFyICQ9MDskPE47JCsrKXN0LnB1c2goeShkLEUpKSxkKz1FO3JldHVybiBzdC5tYXAoZnVuY3Rpb24oSyl7dmFyIFk9bShLWzBdLEgsSixjdCxrLGoseiksWj1ZLngsZXQ9WS55LHJ0PW0oS1sxXSxILEosY3QsayxqLHopLGF0PXJ0LngsbHQ9cnQueSxpdD1tKEtbMl0sSCxKLGN0LGssaix6KSxudD1pdC54LG90PWl0Lnk7cmV0dXJue3gxOloseTE6ZXQseDI6YXQseTI6bHQseDpudCx5Om90fX0pfSxNPXthOjcsYzo2LGg6MSxsOjIsbToyLHE6NCxzOjQsdDoyLHY6MSx6OjB9LGY9LyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9pZztmdW5jdGlvbiB2KEwpe3ZhciBEPVtdO3JldHVybiBMLnJlcGxhY2UoZixmdW5jdGlvbihiLFMsQil7dmFyIHc9Uy50b0xvd2VyQ2FzZSgpO2ZvcihCPVIoQiksdz09Im0iJiZCLmxlbmd0aD4yJiYoRC5wdXNoKFtTXS5jb25jYXQoQi5zcGxpY2UoMCwyKSkpLHc9ImwiLFM9Uz09Im0iPyJsIjoiTCIpOzspe2lmKEIubGVuZ3RoPT1NW3ddKXJldHVybiBCLnVuc2hpZnQoUyksRC5wdXNoKEIpO2lmKEIubGVuZ3RoPE1bd10pdGhyb3cgbmV3IEVycm9yKCJtYWxmb3JtZWQgcGF0aCBkYXRhIik7RC5wdXNoKFtTXS5jb25jYXQoQi5zcGxpY2UoMCxNW3ddKSkpfX0pLER9dmFyIHg9Ly0/WzAtOV0qXC4/WzAtOV0rKD86ZVstK10/XGQrKT8vaWc7ZnVuY3Rpb24gUihMKXt2YXIgRD1MLm1hdGNoKHgpO3JldHVybiBEP0QubWFwKE51bWJlcik6W119ZnVuY3Rpb24gTyhMKXt2YXIgRD1MWzBdWzBdLGI9TFswXVsxXSxTPUQsQj1iO3JldHVybiBMLmZvckVhY2goZnVuY3Rpb24odyl7dmFyIEg9d1swXSxKPXdbMl0scT13WzRdLFc9d1s2XSxHPXdbMV0sUT13WzNdLHR0PXdbNV0sXz13WzddO0Q9TWF0aC5taW4oRCxILEoscSxXKSxiPU1hdGgubWluKGIsRyxRLHR0LF8pLFM9TWF0aC5tYXgoUyxILEoscSxXKSxCPU1hdGgubWF4KEIsRyxRLHR0LF8pfSksW0QsYixTLEJdfWZ1bmN0aW9uIGcoTCxEKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KExbMF0tRFswXSwyKStNYXRoLnBvdyhMWzFdLURbMV0sMikpK01hdGguc3FydChNYXRoLnBvdyhMWzJdLURbMl0sMikrTWF0aC5wb3coTFszXS1EWzNdLDIpKX1mdW5jdGlvbiBwKEwsRCl7dmFyIGI9TFswXSxTPUxbMl0sQj1MWzRdLHc9TFs2XSxIPUxbMV0sSj1MWzNdLHE9TFs1XSxXPUxbN10sRz1EWzBdLFE9RFsyXSx0dD1EWzRdLF89RFs2XSxzdD1EWzFdLGs9RFszXSxjdD1EWzVdLGZ0PURbN107cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhHLWIsMikrTWF0aC5wb3coc3QtSCwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KFEtUywyKStNYXRoLnBvdyhrLUosMikpK01hdGguc3FydChNYXRoLnBvdyh0dC1CLDIpK01hdGgucG93KGN0LXEsMikpK01hdGguc3FydChNYXRoLnBvdyhfLXcsMikrTWF0aC5wb3coZnQtVywyKSl9ZnVuY3Rpb24gbihMLEQpe3ZhciBiPWkoTC5sZW5ndGgpLFM9W107Yi5mb3JFYWNoKGZ1bmN0aW9uKHcpe3ZhciBIPTAsSj0wO3cuZm9yRWFjaChmdW5jdGlvbihxKXtIKz1wKExbcV0sRFtKKytdKX0pLFMucHVzaCh7aW5kZXg6dyxkaXN0YW5jZTpIfSl9KSxTLnNvcnQoZnVuY3Rpb24odyxIKXtyZXR1cm4gdy5kaXN0YW5jZS1ILmRpc3RhbmNlfSk7dmFyIEI9W107cmV0dXJuIFNbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbih3KXtCLnB1c2goTFt3XSl9KSxCfWZ1bmN0aW9uIGEoTCxEKXt2YXIgYj1vKEwubGVuZ3RoKSxTPVtdO2IuZm9yRWFjaChmdW5jdGlvbih3KXt2YXIgSD0wO3cuZm9yRWFjaChmdW5jdGlvbihKKXtIKz1nKE8oTFtKXSksTyhEW0pdKSl9KSxTLnB1c2goe2luZGV4OncsZGlzdGFuY2U6SH0pfSksUy5zb3J0KGZ1bmN0aW9uKHcsSCl7cmV0dXJuIHcuZGlzdGFuY2UtSC5kaXN0YW5jZX0pO3ZhciBCPVtdO3JldHVybiBTWzBdLmluZGV4LmZvckVhY2goZnVuY3Rpb24odyl7Qi5wdXNoKExbd10pfSksQn1mdW5jdGlvbiBpKEwpe2Zvcih2YXIgRD1bXSxiPTA7YjxMO2IrKyl7Zm9yKHZhciBTPVtdLEI9MDtCPEw7QisrKXt2YXIgdz1CK2I7dz5MLTEmJih3LT1MKSxTW3ddPUJ9RC5wdXNoKFMpfXJldHVybiBEfWZ1bmN0aW9uIG8oTCl7Zm9yKHZhciBEPVtdLGI9MDtiPEw7YisrKUQucHVzaChiKTtyZXR1cm4gVChEKX1mdW5jdGlvbiBUKEwpe3ZhciBEPVtdLGI9W107ZnVuY3Rpb24gUyhCKXt2YXIgdyxIO2Zvcih3PTA7dzxCLmxlbmd0aDt3KyspSD1CLnNwbGljZSh3LDEpWzBdLGIucHVzaChIKSxCLmxlbmd0aD09MCYmRC5wdXNoKGIuc2xpY2UoKSksUyhCKSxCLnNwbGljZSh3LDAsSCksYi5wb3AoKTtyZXR1cm4gRH1yZXR1cm4gUyhMKX12YXIgQT17fTtBLnBhcnNlcj12LEEubGVycEN1cnZlPWZ1bmN0aW9uKEwsRCxiKXtyZXR1cm4gQS5sZXJwUG9pbnRzKExbMF0sTFsxXSxEWzBdLERbMV0sYikuY29uY2F0KEEubGVycFBvaW50cyhMWzJdLExbM10sRFsyXSxEWzNdLGIpKS5jb25jYXQoQS5sZXJwUG9pbnRzKExbNF0sTFs1XSxEWzRdLERbNV0sYikpLmNvbmNhdChBLmxlcnBQb2ludHMoTFs2XSxMWzddLERbNl0sRFs3XSxiKSl9LEEubGVycFBvaW50cz1mdW5jdGlvbihMLEQsYixTLEIpe3JldHVybltMKyhiLUwpKkIsRCsoUy1EKSpCXX0sQS5xMmI9ZnVuY3Rpb24oTCxELGIsUyxCLHcpe3JldHVybltMLEQsKEwrMipiKS8zLChEKzIqUykvMywoQisyKmIpLzMsKHcrMipTKS8zLEIsd119LEEucGF0aDJzaGFwZXM9ZnVuY3Rpb24oTCl7Zm9yKHZhciBEPUEucGFyc2VyKEwpLGI9MCxTPTAsQj0wLHc9RC5sZW5ndGgsSD1bXSxKPW51bGwscT12b2lkIDAsVz12b2lkIDAsRz12b2lkIDAsUT12b2lkIDAsdHQ9dm9pZCAwLF89dm9pZCAwLHN0PXZvaWQgMDtCPHc7QisrKXt2YXIgaz1EW0JdLGN0PWtbMF0sZnQ9RFtCLTFdO3N3aXRjaChjdCl7Y2FzZSJtIjp0dD1ILmxlbmd0aCxIW3R0XT1bXSxKPUhbdHRdLGI9YitrWzFdLFM9UytrWzJdO2JyZWFrO2Nhc2UiTSI6dHQ9SC5sZW5ndGgsSFt0dF09W10sSj1IW3R0XSxiPWtbMV0sUz1rWzJdO2JyZWFrO2Nhc2UibCI6Si5wdXNoKFtiLFMsYixTLGIsUyxiK2tbMV0sUytrWzJdXSksYis9a1sxXSxTKz1rWzJdO2JyZWFrO2Nhc2UiTCI6Si5wdXNoKFtiLFMsa1sxXSxrWzJdLGtbMV0sa1syXSxrWzFdLGtbMl1dKSxiPWtbMV0sUz1rWzJdO2JyZWFrO2Nhc2UiaCI6Si5wdXNoKFtiLFMsYixTLGIsUyxiK2tbMV0sU10pLGIrPWtbMV07YnJlYWs7Y2FzZSJIIjpKLnB1c2goW2IsUyxrWzFdLFMsa1sxXSxTLGtbMV0sU10pLGI9a1sxXTticmVhaztjYXNlInYiOkoucHVzaChbYixTLGIsUyxiLFMsYixTK2tbMV1dKSxTKz1rWzFdO2JyZWFrO2Nhc2UiViI6Si5wdXNoKFtiLFMsYixrWzFdLGIsa1sxXSxiLGtbMV1dKSxTPWtbMV07YnJlYWs7Y2FzZSJDIjpKLnB1c2goW2IsUyxrWzFdLGtbMl0sa1szXSxrWzRdLGtbNV0sa1s2XV0pLGI9a1s1XSxTPWtbNl07YnJlYWs7Y2FzZSJTIjpmdFswXT09PSJDInx8ZnRbMF09PT0iYyI/Si5wdXNoKFtiLFMsYitmdFs1XS1mdFszXSxTK2Z0WzZdLWZ0WzRdLGtbMV0sa1syXSxrWzNdLGtbNF1dKTooZnRbMF09PT0iUyJ8fGZ0WzBdPT09InMiKSYmSi5wdXNoKFtiLFMsYitmdFszXS1mdFsxXSxTK2Z0WzRdLWZ0WzJdLGtbMV0sa1syXSxrWzNdLGtbNF1dKSxiPWtbM10sUz1rWzRdO2JyZWFrO2Nhc2UiYyI6Si5wdXNoKFtiLFMsYitrWzFdLFMra1syXSxiK2tbM10sUytrWzRdLGIra1s1XSxTK2tbNl1dKSxiPWIra1s1XSxTPVMra1s2XTticmVhaztjYXNlInMiOmZ0WzBdPT09IkMifHxmdFswXT09PSJjIj9KLnB1c2goW2IsUyxiK2Z0WzVdLWZ0WzNdLFMrZnRbNl0tZnRbNF0sYitrWzFdLFMra1syXSxiK2tbM10sUytrWzRdXSk6KGZ0WzBdPT09IlMifHxmdFswXT09PSJzIikmJkoucHVzaChbYixTLGIrZnRbM10tZnRbMV0sUytmdFs0XS1mdFsyXSxiK2tbMV0sUytrWzJdLGIra1szXSxTK2tbNF1dKSxiPWIra1szXSxTPVMra1s0XTticmVhaztjYXNlImEiOl89dSh7cng6a1sxXSxyeTprWzJdLHB4OmIscHk6Uyx4QXhpc1JvdGF0aW9uOmtbM10sbGFyZ2VBcmNGbGFnOmtbNF0sc3dlZXBGbGFnOmtbNV0sY3g6YitrWzZdLGN5OlMra1s3XX0pLHN0PV9bXy5sZW5ndGgtMV0sXy5mb3JFYWNoKGZ1bmN0aW9uKFUsRil7Rj09PTA/Si5wdXNoKFtiLFMsVS54MSxVLnkxLFUueDIsVS55MixVLngsVS55XSk6Si5wdXNoKFtfW0YtMV0ueCxfW0YtMV0ueSxVLngxLFUueTEsVS54MixVLnkyLFUueCxVLnldKX0pLGI9c3QueCxTPXN0Lnk7YnJlYWs7Y2FzZSJBIjpfPXUoe3J4OmtbMV0scnk6a1syXSxweDpiLHB5OlMseEF4aXNSb3RhdGlvbjprWzNdLGxhcmdlQXJjRmxhZzprWzRdLHN3ZWVwRmxhZzprWzVdLGN4OmtbNl0sY3k6a1s3XX0pLHN0PV9bXy5sZW5ndGgtMV0sXy5mb3JFYWNoKGZ1bmN0aW9uKFUsRil7Rj09PTA/Si5wdXNoKFtiLFMsVS54MSxVLnkxLFUueDIsVS55MixVLngsVS55XSk6Si5wdXNoKFtfW0YtMV0ueCxfW0YtMV0ueSxVLngxLFUueTEsVS54MixVLnkyLFUueCxVLnldKX0pLGI9c3QueCxTPXN0Lnk7YnJlYWs7Y2FzZSJRIjpKLnB1c2goQS5xMmIoYixTLGtbMV0sa1syXSxrWzNdLGtbNF0pKSxiPWtbM10sUz1rWzRdO2JyZWFrO2Nhc2UicSI6Si5wdXNoKEEucTJiKGIsUyxiK2tbMV0sUytrWzJdLGtbM10rYixrWzRdK1MpKSxiKz1rWzNdLFMrPWtbNF07YnJlYWs7Y2FzZSJUIjpmdFswXT09PSJRInx8ZnRbMF09PT0icSI/KEc9YitmdFszXS1mdFsxXSxRPVMrZnRbNF0tZnRbMl0sSi5wdXNoKEEucTJiKGIsUyxHLFEsa1sxXSxrWzJdKSkpOihmdFswXT09PSJUInx8ZnRbMF09PT0idCIpJiYoSi5wdXNoKEEucTJiKGIsUyxiK2ItRyxTK1MtUSxrWzFdLGtbMl0pKSxHPWIrYi1HLFE9UytTLVEpLGI9a1sxXSxTPWtbMl07YnJlYWs7Y2FzZSJ0IjpmdFswXT09PSJRInx8ZnRbMF09PT0icSI/KEc9YitmdFszXS1mdFsxXSxRPVMrZnRbNF0tZnRbMl0sSi5wdXNoKEEucTJiKGIsUyxHLFEsYitrWzFdLFMra1syXSkpKTooZnRbMF09PT0iVCJ8fGZ0WzBdPT09InQiKSYmKEoucHVzaChBLnEyYihiLFMsYitiLUcsUytTLVEsYitrWzFdLFMra1syXSkpLEc9YitiLUcsUT1TK1MtUSksYis9a1sxXSxTKz1rWzJdO2JyZWFrO2Nhc2UiWiI6cT1KWzBdWzBdLFc9SlswXVsxXSxKLnB1c2goW2IsUyxxLFcscSxXLHEsV10pO2JyZWFrO2Nhc2UieiI6cT1KWzBdWzBdLFc9SlswXVsxXSxKLnB1c2goW2IsUyxxLFcscSxXLHEsV10pO2JyZWFrfX1yZXR1cm4gSH0sQS5fdXBDdXJ2ZXM9ZnVuY3Rpb24oTCxEKXtmb3IodmFyIGI9MCxTPTAsQj1MLmxlbmd0aDtiPEQ7YisrKUwucHVzaChMW1NdLnNsaWNlKDApKSxTKyssUz5CLTEmJihTLT1CKX07ZnVuY3Rpb24gQyhMLEQsYixTLEIsdyxILEoscSl7cmV0dXJue2xlZnQ6SShMLEQsYixTLEIsdyxILEoscSkscmlnaHQ6SShILEosQix3LGIsUyxMLEQsMS1xLCEwKX19ZnVuY3Rpb24gSShMLEQsYixTLEIsdyxILEoscSxXKXt2YXIgRz0oYi1MKSpxK0wsUT0oUy1EKSpxK0QsdHQ9KEItYikqcStiLF89KHctUykqcStTLHN0PShILUIpKnErQixrPShKLXcpKnErdyxjdD0odHQtRykqcStHLGZ0PShfLVEpKnErUSxVPShzdC10dCkqcSt0dCxGPShrLV8pKnErXyxWPShVLWN0KSpxK2N0LFg9KEYtZnQpKnErZnQ7cmV0dXJuIFc/W1YsWCxjdCxmdCxHLFEsTCxEXTpbTCxELEcsUSxjdCxmdCxWLFhdfUEuX3NwbGl0Q3VydmVzPWZ1bmN0aW9uKEwsRCl7Zm9yKHZhciBiPTAsUz0wO2I8RDtiKyspe3ZhciBCPUxbU10sdz1DKEJbMF0sQlsxXSxCWzJdLEJbM10sQls0XSxCWzVdLEJbNl0sQls3XSwuNSk7TC5zcGxpY2UoUywxKSxMLnNwbGljZShTLDAsdy5sZWZ0LHcucmlnaHQpLFMrPTIsUz49TC5sZW5ndGgtMSYmKFM9MCl9fTtmdW5jdGlvbiBQKEwsRCl7Zm9yKHZhciBiPWZ1bmN0aW9uKHcpe3ZhciBIPUxbTC5sZW5ndGgtMV0sSj1bXTtILmZvckVhY2goZnVuY3Rpb24ocSl7Si5wdXNoKHEuc2xpY2UoMCkpfSksTC5wdXNoKEopfSxTPTA7UzxEO1MrKyliKCl9cmV0dXJuIEEubGVycD1mdW5jdGlvbihMLEQsYil7cmV0dXJuIEEuX2xlcnAoQS5wYXRoMnNoYXBlcyhMKSxBLnBhdGgyc2hhcGVzKEQpLGIpfSxBLk1JTV9DVVJWRVNfQ09VTlQ9MTAwLEEuX3ByZXByb2Nlc3Npbmc9ZnVuY3Rpb24oTCxEKXt2YXIgYj1MLmxlbmd0aCxTPUQubGVuZ3RoLEI9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShMKSksdz1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEQpKTtyZXR1cm4gYj5TP1AodyxiLVMpOmI8UyYmUChCLFMtYiksQj1hKEIsdyksQi5mb3JFYWNoKGZ1bmN0aW9uKEgsSil7dmFyIHE9SC5sZW5ndGgsVz13W0pdLmxlbmd0aDtxPlc/cTxBLk1JTV9DVVJWRVNfQ09VTlQ/KEEuX3NwbGl0Q3VydmVzKEgsQS5NSU1fQ1VSVkVTX0NPVU5ULXEpLEEuX3NwbGl0Q3VydmVzKHdbSl0sQS5NSU1fQ1VSVkVTX0NPVU5ULVcpKTpBLl9zcGxpdEN1cnZlcyh3W0pdLHEtVyk6cTxXJiYoVzxBLk1JTV9DVVJWRVNfQ09VTlQ/KEEuX3NwbGl0Q3VydmVzKEgsQS5NSU1fQ1VSVkVTX0NPVU5ULXEpLEEuX3NwbGl0Q3VydmVzKHdbSl0sQS5NSU1fQ1VSVkVTX0NPVU5ULVcpKTpBLl9zcGxpdEN1cnZlcyhILFctcSkpfSksQi5mb3JFYWNoKGZ1bmN0aW9uKEgsSil7QltKXT1uKEgsd1tKXSl9KSxbQix3XX0sQS5fbGVycD1mdW5jdGlvbihMLEQsYil7dmFyIFM9W107cmV0dXJuIEwuZm9yRWFjaChmdW5jdGlvbihCLHcpe3ZhciBIPVtdO0IuZm9yRWFjaChmdW5jdGlvbihKLHEpe0gucHVzaChBLmxlcnBDdXJ2ZShKLERbd11bcV0sYikpfSksUy5wdXNoKEgpfSksU30sQS5hbmltYXRlPWZ1bmN0aW9uKEwpe3ZhciBEPUEucGF0aDJzaGFwZXMoTC5mcm9tKSxiPUEucGF0aDJzaGFwZXMoTC50byksUz1BLl9wcmVwcm9jZXNzaW5nKEQsYiksQj1uZXcgRGF0ZSx3PUwuZW5kfHxmdW5jdGlvbigpe30sSD1MLnByb2dyZXNzfHxmdW5jdGlvbigpe30sSj1MLmJlZ2lufHxmdW5jdGlvbigpe30scT1MLmVhc2luZ3x8ZnVuY3Rpb24oXyl7cmV0dXJuIF99LFc9bnVsbCxHPW51bGwsUT1MLnRpbWU7SihEKTt2YXIgdHQ9ZnVuY3Rpb24gXygpe3ZhciBzdD1uZXcgRGF0ZS1CO2lmKHN0Pj1RKXtHPWIsSChHLDEpLHcoRyksY2FuY2VsQW5pbWF0aW9uRnJhbWUoVyk7cmV0dXJufXZhciBrPXEoc3QvUSk7Rz1BLl9sZXJwKFNbMF0sU1sxXSxrKSxIKEcsayksVz1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXyl9O3R0KCl9LEF9KX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoNzEpLHM9dCgyMjEpLG09dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksbD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtjbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbeV0oe2Q6IiIsbm9ybWFsaXplOiExLGZpbGxDb2xvcjp2b2lkIDAsZmlsbFJ1bGU6Im5vbnplcm8iLHN0cm9rZUNvbG9yOnZvaWQgMCxsaW5lV2lkdGg6MSxsaW5lSm9pbjoibWl0ZXIiLGxpbmVDYXA6ImJ1dHQiLHJvdW5kU2VnbWVudHM6MjAsbGluZURhc2g6dm9pZCAwLGxpbmVEYXNoT2Zmc2V0OjAsbWl0ZXJMaW1pdDoxMCx0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMCxjbGlwUGF0aDp2b2lkIDB9KX1nZXQgZCgpe3JldHVybiB0aGlzW2xdKCJkIil9c2V0IGQoZil7dGhpc1tjXSgiZCIsZil9Z2V0IG5vcm1hbGl6ZSgpe3JldHVybiB0aGlzW2xdKCJub3JtYWxpemUiKX1zZXQgbm9ybWFsaXplKGYpe3RoaXNbY10oIm5vcm1hbGl6ZSIsISFmKX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbbF0oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IoZil7dGhpc1tjXSgiZmlsbENvbG9yIixPYmplY3Qocy5wYXJzZUNvbG9yKShmKSl9Z2V0IGZpbGxSdWxlKCl7cmV0dXJuIHRoaXNbbF0oImZpbGxSdWxlIil9c2V0IGZpbGxSdWxlKGYpe2lmKGYhPW51bGwmJmYhPT0ibm9uemVybyImJmYhPT0iZXZlbm9kZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaWxsIHJ1bGUuIik7dGhpc1tjXSgiZmlsbFJ1bGUiLGYpfWdldCBzdHJva2VDb2xvcigpe3JldHVybiB0aGlzW2xdKCJzdHJva2VDb2xvciIpfXNldCBzdHJva2VDb2xvcihmKXt0aGlzW2NdKCJzdHJva2VDb2xvciIsT2JqZWN0KHMucGFyc2VDb2xvcikoZikpfWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tsXSgibGluZVdpZHRoIil9c2V0IGxpbmVXaWR0aChmKXt0aGlzW2NdKCJsaW5lV2lkdGgiLE9iamVjdChtLnRvTnVtYmVyKShmKSl9Z2V0IGxpbmVKb2luKCl7cmV0dXJuIHRoaXNbbF0oImxpbmVKb2luIil9c2V0IGxpbmVKb2luKGYpe2lmKGYhPW51bGwmJmYhPT0ibWl0ZXIiJiZmIT09ImJldmVsIiYmZiE9PSJyb3VuZCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lSm9pbiB0eXBlLiIpO3RoaXNbY10oImxpbmVKb2luIixmKX1nZXQgbGluZUNhcCgpe3JldHVybiB0aGlzW2xdKCJsaW5lQ2FwIil9c2V0IGxpbmVDYXAoZil7aWYoZiE9bnVsbCYmZiE9PSJidXR0IiYmZiE9PSJzcXVhcmUiJiZmIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVDYXAgdHlwZS4iKTt0aGlzW2NdKCJsaW5lQ2FwIixmKX1nZXQgbGluZURhc2goKXtyZXR1cm4gdGhpc1tsXSgibGluZURhc2giKX1zZXQgbGluZURhc2goZil7Zj1PYmplY3QobS50b0FycmF5KShmLCEwKSxmIT1udWxsJiYhQXJyYXkuaXNBcnJheShmKSYmKGY9W2ZdKSx0aGlzW2NdKCJsaW5lRGFzaCIsZj9mLm1hcChtLnRvTnVtYmVyKTpudWxsKX1nZXQgbGluZURhc2hPZmZzZXQoKXtyZXR1cm4gdGhpc1tsXSgibGluZURhc2hPZmZzZXQiKX1zZXQgbGluZURhc2hPZmZzZXQoZil7dGhpc1tjXSgibGluZURhc2hPZmZzZXQiLE9iamVjdChtLnRvTnVtYmVyKShmKSl9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tsXSgibWl0ZXJMaW1pdCIpfXNldCBtaXRlckxpbWl0KGYpe3RoaXNbY10oIm1pdGVyTGltaXQiLE9iamVjdChtLnRvTnVtYmVyKShmKSl9Z2V0IHJvdW5kU2VnbWVudHMoKXtyZXR1cm4gdGhpc1tsXSgicm91bmRTZWdtZW50cyIpfXNldCByb3VuZFNlZ21lbnRzKGYpe3RoaXNbY10oInJvdW5kU2VnbWVudHMiLGYpfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbbF0oInRleHR1cmUiKX1zZXQgdGV4dHVyZShmKXt0aGlzW2NdKCJ0ZXh0dXJlIixmKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1tsXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoZil7dGhpc1tjXSgidGV4dHVyZVJlY3QiLGYpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbbF0oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChmKXt0aGlzW2NdKCJzb3VyY2VSZWN0IixmKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW2xdKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoZil7dGhpc1tjXSgidGV4dHVyZVJlcGVhdCIsISFmKX1nZXQgY2xpcFBhdGgoKXtyZXR1cm4gdGhpc1tsXSgiY2xpcFBhdGgiKX1zZXQgY2xpcFBhdGgoZil7dGhpc1tjXSgiY2xpcFBhdGgiLGYpfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIyNikscz10KDIxMyksbT10KDIzMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHkobCx1LE0pe3JldHVybiB1IGluIGw/T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsdSx7dmFsdWU6TSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmxbdV09TSxsfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3dpZHRoOnUsaGVpZ2h0Ok19PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gdT4wJiZNPjAmJnN1cGVyLmlzVmlzaWJsZX19eShjLCJBdHRyIixtLmRlZmF1bHQpLHMuZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywicmVjdCIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBNfSk7dmFyIHI9dCgyMjgpLHM9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG09U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIHUoZil7Y29uc3R7d2lkdGg6dixoZWlnaHQ6eH09ZjtyZXR1cm5gTTAgMEwke3Z9IDBMJHt2fSAke3h9TDAgJHt4fVpgfWNsYXNzIE0gZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3Iodil7c3VwZXIodiksdGhpc1ttXSh7d2lkdGg6MCxoZWlnaHQ6MH0pLHRoaXNbbF0oInNpemUiKX1nZXQgZCgpe3JldHVybiB0aGlzW2NdKCJkIil9c2V0IGQodil7fWdldCB3aWR0aCgpe3JldHVybiB0aGlzW2NdKCJ3aWR0aCIpfXNldCB3aWR0aCh2KXtpZih2PU9iamVjdChzLnRvTnVtYmVyKSh2KSx0aGlzW3ldKCJ3aWR0aCIsdikpe2NvbnN0IHg9dSh0aGlzKTt0aGlzW3ldKCJkIix4KX19Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzW2NdKCJoZWlnaHQiKX1zZXQgaGVpZ2h0KHYpe2lmKHY9T2JqZWN0KHMudG9OdW1iZXIpKHYpLHRoaXNbeV0oImhlaWdodCIsdikpe2NvbnN0IHg9dSh0aGlzKTt0aGlzW3ldKCJkIix4KX19Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUodil7dj1PYmplY3Qocy50b0FycmF5KSh2KSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpcy53aWR0aD12WzBdLHRoaXMuaGVpZ2h0PXZbMV19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMyKSxzPXQoMjEzKSxtPXQoMjM1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24geShsLHUsTSl7cmV0dXJuIHUgaW4gbD9PYmplY3QuZGVmaW5lUHJvcGVydHkobCx1LHt2YWx1ZTpNLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6bFt1XT1NLGx9Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6dX09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiB1WzBdPjAmJnVbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX15KGMsIkF0dHIiLG0uZGVmYXVsdCkscy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJ0cmlhbmdsZSIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjYpLHM9dCgyMTMpLG09dCgyMzMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB5KGwsdSxNKXtyZXR1cm4gdSBpbiBsP09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHUse3ZhbHVlOk0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpsW3VdPU0sbH1jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtwb2ludHM6dX09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiB1Lmxlbmd0aD4wJiZzdXBlci5pc1Zpc2libGV9fXkoYywiQXR0ciIsbS5kZWZhdWx0KSxzLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInBvbHlsaW5lIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDIyOCkscz10KDcyKSxtPXQoMjM0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgeT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxsPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gTSh2KXtjb25zdHtwb2ludHM6eCxzbW9vdGg6UixzbW9vdGhSYW5nZTpPLGNsb3NlOmd9PXYscD1bXTtmb3IobGV0IGE9MDthPHgubGVuZ3RoO2ErPTIpcC5wdXNoKFt4W2FdLHhbYSsxXV0pO2xldCBuPSIiO3JldHVybiBSP249T2JqZWN0KG0ubWFrZVNtb290aEN1cnZlTGluZSkocCxPKTpwLmxlbmd0aCYmKG49YE0ke3AubWFwKGE9PmEuam9pbigiICIpKS5qb2luKCJMIil9YCksbiYmZyYmKG4rPSJaIiksbn1jbGFzcyBmIGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKHgpe3N1cGVyKHgpLHRoaXNbeV0oe3BvaW50czpbXSxzbW9vdGg6ITEsc21vb3RoUmFuZ2U6WzBdLGNsb3NlVHlwZToibm9uZSJ9KSx0aGlzW3VdKCJjbG9zZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbbF0oImQiKX1zZXQgZCh4KXt9Z2V0IGNsb3NlKCl7cmV0dXJuIHRoaXMuY2xvc2VUeXBlIT09Im5vbmUifXNldCBjbG9zZSh4KXt4PXg/Im5vcm1hbCI6Im5vbmUiLHRoaXMuY2xvc2VUeXBlPXh9Z2V0IGNsb3NlVHlwZSgpe3JldHVybiB0aGlzW2xdKCJjbG9zZVR5cGUiKX1zZXQgY2xvc2VUeXBlKHgpe2lmKHghPW51bGwmJnghPT0ibm9uZSImJnghPT0ibm9ybWFsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNsb3NlVHlwZSB0eXBlLiIpO2lmKHRoaXNbY10oImNsb3NlVHlwZSIseCkpe2NvbnN0IFI9TSh0aGlzKTt0aGlzW2NdKCJkIixSKX19Z2V0IHNtb290aCgpe3JldHVybiB0aGlzW2xdKCJzbW9vdGgiKX1zZXQgc21vb3RoKHgpe2lmKHRoaXNbY10oInNtb290aCIseCkpe2NvbnN0IFI9TSh0aGlzKTt0aGlzW2NdKCJkIixSKX19Z2V0IHNtb290aFJhbmdlKCl7cmV0dXJuIHRoaXNbbF0oInNtb290aFJhbmdlIil9c2V0IHNtb290aFJhbmdlKHgpe2lmKHgmJiFBcnJheS5pc0FycmF5KHgpJiYoeD1beF0pLHRoaXNbY10oInNtb290aFJhbmdlIix4KSYmdGhpcy5zbW9vdGgpe2NvbnN0IFI9TSh0aGlzKTt0aGlzW2NdKCJkIixSKX19Z2V0IHBvaW50cygpe3JldHVybiB0aGlzW2xdKCJwb2ludHMiKX1zZXQgcG9pbnRzKHgpe2lmKHg9T2JqZWN0KHMudG9BcnJheSkoeCksQXJyYXkuaXNBcnJheSh4KSYmKHg9eC5yZWR1Y2UoKFIsTyk9PkFycmF5LmlzQXJyYXkoTyk/Wy4uLlIsLi4uTy5tYXAoZz0+T2JqZWN0KHMudG9OdW1iZXIpKGcpKV06Wy4uLlIsT2JqZWN0KHMudG9OdW1iZXIpKE8pXSxbXSkpLHRoaXNbY10oInBvaW50cyIseCkpe2NvbnN0IFI9TSh0aGlzKTt0aGlzW2NdKCJkIixSKX19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwibWFrZVNtb290aEN1cnZlTGluZSIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiByKHMsbT1bMF0pe2Z1bmN0aW9uIHkodSxNPS4xNjgsZj0uMTY4KXtsZXQgdix4LFIsTztpZigoc1t1XS54PT09c1t1KzFdLnh8fHNbdV0ueT09PXNbdSsxXS55KSYmKE09MCxmPTApLHU8MT8odj1zWzBdLngrKHNbMV0ueC1zWzBdLngpKk0seD1zWzBdLnkrKHNbMV0ueS1zWzBdLnkpKk0pOih2PXNbdV0ueCsoc1t1KzFdLngtc1t1LTFdLngpKk0seD1zW3VdLnkrKHNbdSsxXS55LXNbdS0xXS55KSpNKSx1PnMubGVuZ3RoLTMpe2NvbnN0IGc9cy5sZW5ndGgtMTtSPXNbZ10ueC0oc1tnXS54LXNbZy0xXS54KSpmLE89c1tnXS55LShzW2ddLnktc1tnLTFdLnkpKmZ9ZWxzZSBSPXNbdSsxXS54LShzW3UrMl0ueC1zW3VdLngpKmYsTz1zW3UrMV0ueS0oc1t1KzJdLnktc1t1XS55KSpmO3JldHVyblt7eDp2LHk6eH0se3g6Uix5Ok99XX1zPXMubWFwKChbdSxNXSk9Pih7eDp1LHk6TX0pKTtsZXQgYz0iIixsPTA7cmV0dXJuIHMuZm9yRWFjaCgodSxNKT0+e2lmKE09PT0wKWMrPWBNJHt1Lnh9ICR7dS55fWA7ZWxzZXtmb3IoO00+bVtsXTspbCsrO2lmKGwlMil7Y29uc3RbZix2XT15KE0tMSk7Yys9YEMke1tmLngsZi55LHYueCx2LnksdS54LHUueV0uam9pbigiICIpfWB9ZWxzZSBjKz1gTCR7dS54fSAke3UueX1gfX0pLGN9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzMpLHM9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG09U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBsKE0pe2NvbnN0W2Ysdl09TS5zaWRlcztsZXQgeD1NLmFuZ2xlJTM2MDtyZXR1cm4geDwwJiYoeCs9MzYwKSx4PU1hdGguUEkqeC8xODAsWzAsMCxmLDAsdipNYXRoLmNvcyh4KSx2Kk1hdGguc2luKHgpXX1jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbbV0oe3NpZGVzOlswLDBdLGFuZ2xlOjYwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZil7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW2NdKCJzaWRlcyIpfXNldCBzaWRlcyhmKXtpZihmPU9iamVjdChzLnRvQXJyYXkpKGYsITApLGYhPW51bGwmJiFBcnJheS5pc0FycmF5KGYpJiYoZj1bZixmXSksdGhpc1t5XSgic2lkZXMiLGYpKXtjb25zdCB2PWwodGhpcyk7c3VwZXIucG9pbnRzPXZ9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW2NdKCJhbmdsZSIpfXNldCBhbmdsZShmKXtpZihmPU9iamVjdChzLnRvTnVtYmVyKShmKSx0aGlzW3ldKCJhbmdsZSIsZikpe2NvbnN0IHY9bCh0aGlzKTtzdXBlci5wb2ludHM9dn19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMyKSxzPXQoMjEzKSxtPXQoMjM3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24geShsLHUsTSl7cmV0dXJuIHUgaW4gbD9PYmplY3QuZGVmaW5lUHJvcGVydHkobCx1LHt2YWx1ZTpNLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6bFt1XT1NLGx9Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6dX09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiB1WzBdPjAmJnVbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX15KGMsIkF0dHIiLG0uZGVmYXVsdCkscy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJwYXJhbGxlbCIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzMpLHM9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG09U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBsKE0pe2NvbnN0W2Ysdl09TS5zaWRlcztsZXQgeD1NLmFuZ2xlJTM2MDt4PDAmJih4Kz0zNjApLHg9TWF0aC5QSSp4LzE4MDtjb25zdCBSPXYqTWF0aC5jb3MoeCksTz12Kk1hdGguc2luKHgpO3JldHVyblswLDAsZiwwLFIrZixPLFIsT119Y2xhc3MgdSBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW21dKHtzaWRlczpbMCwwXSxhbmdsZTo5MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGYpe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1tjXSgic2lkZXMiKX1zZXQgc2lkZXMoZil7aWYoZj1PYmplY3Qocy50b0FycmF5KShmLCEwKSxmIT1udWxsJiYhQXJyYXkuaXNBcnJheShmKSYmKGY9W2YsZl0pLHRoaXNbeV0oInNpZGVzIixmKSl7Y29uc3Qgdj1sKHRoaXMpO3N1cGVyLnBvaW50cz12fX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1tjXSgiYW5nbGUiKX1zZXQgYW5nbGUoZil7aWYoZj1PYmplY3Qocy50b051bWJlcikoZiksdGhpc1t5XSgiYW5nbGUiLGYpKXtjb25zdCB2PWwodGhpcyk7c3VwZXIucG9pbnRzPXZ9fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDIzMikscz10KDIxMyksbT10KDIzOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHkobCx1LE0pe3JldHVybiB1IGluIGw/T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsdSx7dmFsdWU6TSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmxbdV09TSxsfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7fXkoYywiQXR0ciIsbS5kZWZhdWx0KSxzLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInJlZ3VsYXIiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciByPXQoMjMzKSxzPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBtPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx5PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGM9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gbChNKXtjb25zdHtlZGdlczpmLHJhZGl1czp2LG9mZnNldEFuZ2xlOnh9PU0sUj1NYXRoLlBJKngvMTgwLS41Kk1hdGguUEk7aWYoZjwzfHx2PD0wKXJldHVybltdO2NvbnN0IE89W107Zm9yKGxldCBnPTA7ZzxmO2crKyl7Y29uc3QgcD1nKjIqTWF0aC5QSS9mK1Isbj12Kk1hdGguY29zKHApLGE9dipNYXRoLnNpbihwKTtPLnB1c2gobixhKX1yZXR1cm4gT31jbGFzcyB1IGV4dGVuZHMgci5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbbV0oe2VkZ2VzOjMscmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGYpe31nZXQgZWRnZXMoKXtyZXR1cm4gdGhpc1tjXSgiZWRnZXMiKX1zZXQgZWRnZXMoZil7aWYoZj1PYmplY3Qocy50b051bWJlcikoZiksdGhpc1t5XSgiZWRnZXMiLGYpKXtjb25zdCB2PWwodGhpcyk7c3VwZXIucG9pbnRzPXZ9fWdldCByYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgicmFkaXVzIil9c2V0IHJhZGl1cyhmKXtpZihmPU9iamVjdChzLnRvTnVtYmVyKShmKSx0aGlzW3ldKCJyYWRpdXMiLGYpKXtjb25zdCB2PWwodGhpcyk7c3VwZXIucG9pbnRzPXZ9fWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW2NdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShmKXtpZihmPU9iamVjdChzLnRvTnVtYmVyKShmKSx0aGlzW3ldKCJvZmZzZXRBbmdsZSIsZikpe2NvbnN0IHY9bCh0aGlzKTtzdXBlci5wb2ludHM9dn19fX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciByPXQoMjMyKSxzPXQoMjEzKSxtPXQoMjQxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24geShsLHUsTSl7cmV0dXJuIHUgaW4gbD9PYmplY3QuZGVmaW5lUHJvcGVydHkobCx1LHt2YWx1ZTpNLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6bFt1XT1NLGx9Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHt9eShjLCJBdHRyIixtLmRlZmF1bHQpLHMuZGVmYXVsdC5yZWdpc3Rlck5vZGUoYywic3RhciIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB1fSk7dmFyIHI9dCgyMzMpLHM9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG09U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHk9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiBsKE0pe2NvbnN0e2FuZ2xlczpmLGlubmVyUmFkaXVzOnYsb3V0ZXJSYWRpdXM6eCxvZmZzZXRBbmdsZTpSfT1NLE89TWF0aC5QSSpSLzE4MC0uNSpNYXRoLlBJO2lmKGY8M3x8djw9MHx8eDw9MClyZXR1cm5bXTtjb25zdCBnPVtdO2ZvcihsZXQgcD0wO3A8ZioyO3ArKyl7Y29uc3Qgbj1wKk1hdGguUEkvZitPLGE9cCUyP3Y6eCxpPWEqTWF0aC5jb3Mobiksbz1hKk1hdGguc2luKG4pO2cucHVzaChpLG8pfXJldHVybiBnfWNsYXNzIHUgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1ttXSh7YW5nbGVzOjUsaW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhmKXt9Z2V0IGFuZ2xlcygpe3JldHVybiB0aGlzW2NdKCJhbmdsZXMiKX1zZXQgYW5nbGVzKGYpe2lmKGY9T2JqZWN0KHMudG9OdW1iZXIpKGYpLHRoaXNbeV0oImFuZ2xlcyIsZikpe2NvbnN0IHY9bCh0aGlzKTtzdXBlci5wb2ludHM9dn19Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbY10oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKGYpe2lmKGY9T2JqZWN0KHMudG9OdW1iZXIpKGYpLHRoaXNbeV0oImlubmVyUmFkaXVzIixmKSl7Y29uc3Qgdj1sKHRoaXMpO3N1cGVyLnBvaW50cz12fX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tjXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoZil7aWYoZj1PYmplY3Qocy50b051bWJlcikoZiksdGhpc1t5XSgib3V0ZXJSYWRpdXMiLGYpKXtjb25zdCB2PWwodGhpcyk7c3VwZXIucG9pbnRzPXZ9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKGYpe2Y9T2JqZWN0KHMudG9BcnJheSkoZiwhMCksQXJyYXkuaXNBcnJheShmKXx8KGY9W2YsZl0pLHRoaXMuaW5uZXJSYWRpdXM9ZlswXSx0aGlzLm91dGVyUmFkaXVzPWZbMV19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbY10oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGYpe2lmKGY9T2JqZWN0KHMudG9OdW1iZXIpKGYpLHRoaXNbeV0oIm9mZnNldEFuZ2xlIixmKSl7Y29uc3Qgdj1sKHRoaXMpO3N1cGVyLnBvaW50cz12fX19fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjYpLHM9dCgyMTMpLG09dCgyNDMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB5KGwsdSxNKXtyZXR1cm4gdSBpbiBsP09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHUse3ZhbHVlOk0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpsW3VdPU0sbH1jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtyYWRpdXNYOnUscmFkaXVzWTpNLHN0YXJ0QW5nbGU6ZixlbmRBbmdsZTp2fT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIHU+MCYmTT4wJiZmIT09diYmc3VwZXIuaXNWaXNpYmxlfX15KGMsIkF0dHIiLG0uZGVmYXVsdCkscy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJlbGxpcHNlIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDEyKSxzPXQoMjI4KSxtPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB5PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBNKHYpe2NvbnN0e3JhZGl1c1g6eCxyYWRpdXNZOlIsc3RhcnRBbmdsZTpPLGVuZEFuZ2xlOmcsZGlyZWN0aW9uOnAsY2xvc2VUeXBlOm59PXYsYT1wPT09ImFuaXRjbG9ja3dpc2UiLGk9bmV3IHIuRmlndXJlMkQ7cmV0dXJuIG49PT0ic2VjdG9yIiYmaS5tb3ZlVG8oMCwwKSxpLmVsbGlwc2UoMCwwLHgsUiwwLE1hdGguUEkqTy8xODAsTWF0aC5QSSpnLzE4MCxhKSxuIT09Im5vbmUiJiZpLmNsb3NlUGF0aCgpLGkucGF0aC5yZWR1Y2UoKEEsQyk9PkErQy5qb2luKCIgIiksIiIpfWNsYXNzIGYgZXh0ZW5kcyBzLmRlZmF1bHR7Y29uc3RydWN0b3IoeCl7c3VwZXIoeCksdGhpc1t5XSh7cmFkaXVzWDowLHJhZGl1c1k6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwLGRpcmVjdGlvbjoiY2xvY2t3aXNlIixjbG9zZVR5cGU6Im5vbmUifSksdGhpc1t1XSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW2xdKCJkIil9c2V0IGQoeCl7fWdldCByYWRpdXNYKCl7cmV0dXJuIHRoaXNbbF0oInJhZGl1c1giKX1zZXQgcmFkaXVzWCh4KXtpZih4PU9iamVjdChtLnRvTnVtYmVyKSh4KSx0aGlzW2NdKCJyYWRpdXNYIix4KSl7Y29uc3QgUj1NKHRoaXMpO3RoaXNbY10oImQiLFIpfX1nZXQgcmFkaXVzWSgpe3JldHVybiB0aGlzW2xdKCJyYWRpdXNZIil9c2V0IHJhZGl1c1koeCl7aWYoeD1PYmplY3QobS50b051bWJlcikoeCksdGhpc1tjXSgicmFkaXVzWSIseCkpe2NvbnN0IFI9TSh0aGlzKTt0aGlzW2NdKCJkIixSKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLnJhZGl1c1gsdGhpcy5yYWRpdXNZXX1zZXQgcmFkaXVzKHgpe3g9T2JqZWN0KG0udG9BcnJheSkoeCwhMCksQXJyYXkuaXNBcnJheSh4KXx8KHg9W3gseF0pLHRoaXMucmFkaXVzWD14WzBdLHRoaXMucmFkaXVzWT14WzFdfWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKHgpe3g9T2JqZWN0KG0udG9BcnJheSkoeCksQXJyYXkuaXNBcnJheSh4KXx8KHg9W3gseF0pLHRoaXMuc3RhcnRBbmdsZT14WzBdLHRoaXMuZW5kQW5nbGU9eFsxXX1nZXQgZGlyZWN0aW9uKCl7cmV0dXJuIHRoaXNbbF0oImRpcmVjdGlvbiIpfXNldCBkaXJlY3Rpb24oeCl7aWYoeCE9bnVsbCYmeCE9PSJjbG9ja3dpc2UiJiZ4IT09ImFudGljbG9ja3dpc2UiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZGlyZWN0aW9uIHR5cGUuIik7dGhpc1tjXSgiZGlyZWN0aW9uIix4KX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW2xdKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUoeCl7aWYoeD1PYmplY3QobS50b051bWJlcikoeCksdGhpc1tjXSgic3RhcnRBbmdsZSIseCkpe2NvbnN0IFI9TSh0aGlzKTt0aGlzW2NdKCJkIixSKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbbF0oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKHgpe2lmKHg9T2JqZWN0KG0udG9OdW1iZXIpKHgpLHRoaXNbY10oImVuZEFuZ2xlIix4KSl7Y29uc3QgUj1NKHRoaXMpO3RoaXNbY10oImQiLFIpfX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbbF0oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUoeCl7aWYoeCE9bnVsbCYmeCE9PSJub25lIiYmeCE9PSJzZWN0b3IiJiZ4IT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW2NdKCJjbG9zZVR5cGUiLHgpKXtjb25zdCBSPU0odGhpcyk7dGhpc1tjXSgiZCIsUil9fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgcj10KDI0Mikscz10KDIxMyksbT10KDI0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHkobCx1LE0pe3JldHVybiB1IGluIGw/T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsdSx7dmFsdWU6TSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmxbdV09TSxsfWNsYXNzIGMgZXh0ZW5kcyByLmRlZmF1bHR7fXkoYywiQXR0ciIsbS5kZWZhdWx0KSxzLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsImFyYyIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBtfSk7dmFyIHI9dCgyNDMpLHM9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIG0gZXh0ZW5kcyByLmRlZmF1bHR7Z2V0IHJhZGl1cygpe3JldHVybiBzdXBlci5yYWRpdXNYfXNldCByYWRpdXMoYyl7Yz1PYmplY3Qocy50b051bWJlcikoYyksc3VwZXIucmFkaXVzWD1jLHN1cGVyLnJhZGl1c1k9Y319fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjYpLHM9dCgyMTMpLG09dCgyNDcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB5KGwsdSxNKXtyZXR1cm4gdSBpbiBsP09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLHUse3ZhbHVlOk0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpsW3VdPU0sbH1jbGFzcyBjIGV4dGVuZHMgci5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtpbm5lclJhZGl1czp1LG91dGVyUmFkaXVzOk0sc3RhcnRBbmdsZTpmLGVuZEFuZ2xlOnZ9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4odT4wfHxNPjApJiZmIT09diYmc3VwZXIuaXNWaXNpYmxlfX15KGMsIkF0dHIiLG0uZGVmYXVsdCkscy5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJyaW5nIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgcj10KDEyKSxzPXQoMjI4KSxtPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB5PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBNKHYpe2xldHtpbm5lclJhZGl1czp4LG91dGVyUmFkaXVzOlIsc3RhcnRBbmdsZTpPLGVuZEFuZ2xlOmd9PXY7Y29uc3QgcD1uZXcgci5GaWd1cmUyRDtpZihPPU1hdGguUEkqTy8xODAsZz1NYXRoLlBJKmcvMTgwLHg+UiYmKFt4LFJdPVtSLHhdKSx4PD0wJiZwLm1vdmVUbygwLDApLHAuYXJjKDAsMCxSLE8sZywhMSkseD4wKXtjb25zdCBpPU1hdGguUEkqMjtnPE8mJihnPU8raSsoZy1PKSVpKSxnLU8+PWkmJihnPU8raS0xZS02KSxwLmFyYygwLDAseCxnLE8sITApfXJldHVybiBwLmNsb3NlUGF0aCgpLHAucGF0aC5yZWR1Y2UoKGksbyk9Pmkrby5qb2luKCIgIiksIiIpfWNsYXNzIGYgZXh0ZW5kcyBzLmRlZmF1bHR7Y29uc3RydWN0b3IoeCl7c3VwZXIoeCksdGhpc1t5XSh7aW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjB9KSx0aGlzW3VdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbbF0oImQiKX1zZXQgZCh4KXt9Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbbF0oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKHgpe2lmKHg9T2JqZWN0KG0udG9OdW1iZXIpKHgpLHRoaXNbY10oImlubmVyUmFkaXVzIix4KSl7Y29uc3QgUj1NKHRoaXMpO3RoaXNbY10oImQiLFIpfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tsXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoeCl7aWYoeD1PYmplY3QobS50b051bWJlcikoeCksdGhpc1tjXSgib3V0ZXJSYWRpdXMiLHgpKXtjb25zdCBSPU0odGhpcyk7dGhpc1tjXSgiZCIsUil9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKHgpe3g9T2JqZWN0KG0udG9BcnJheSkoeCwhMCksQXJyYXkuaXNBcnJheSh4KXx8KHg9W3gseF0pLHRoaXMuaW5uZXJSYWRpdXM9eFswXSx0aGlzLm91dGVyUmFkaXVzPXhbMV19Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1tsXSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKHgpe2lmKHg9T2JqZWN0KG0udG9OdW1iZXIpKHgpLHRoaXNbY10oInN0YXJ0QW5nbGUiLHgpKXtjb25zdCBSPU0odGhpcyk7dGhpc1tjXSgiZCIsUil9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW2xdKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZSh4KXtpZih4PU9iamVjdChtLnRvTnVtYmVyKSh4KSx0aGlzW2NdKCJlbmRBbmdsZSIseCkpe2NvbnN0IFI9TSh0aGlzKTt0aGlzW2NdKCJkIixSKX19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUoeCl7eD1PYmplY3QobS50b0FycmF5KSh4KSxBcnJheS5pc0FycmF5KHgpfHwoeD1beCx4XSksdGhpcy5zdGFydEFuZ2xlPXhbMF0sdGhpcy5lbmRBbmdsZT14WzFdfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KTt2YXIgcj10KDEyKSxzPXQoMjE4KSxtPXQoMjE5KSx5PXQoMjQ5KSxjPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChPLGcscCl7cmV0dXJuIGcgaW4gTz9PYmplY3QuZGVmaW5lUHJvcGVydHkoTyxnLHt2YWx1ZTpwLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6T1tnXT1wLE99Y29uc3QgdT1TeW1ib2woInRleHRJbWFnZSIpLE09U3ltYm9sKCJ0ZXh0SW1hZ2VUYXNrIiksZj1TeW1ib2woInRleHR1cmVDb250ZXh0Iiksdj1TeW1ib2woInVwZGF0ZVRleHR1cmVSZWN0IikseD1TeW1ib2woInRleHRDYW52YXMiKTtjbGFzcyBSIGV4dGVuZHMgbS5kZWZhdWx0e2NvbnN0cnVjdG9yKGc9e30pe3R5cGVvZiBnPT0ic3RyaW5nIiYmKGc9e3RleHQ6Z30pLHN1cGVyKGcpfWdldCBjb250ZW50U2l6ZSgpe2xldFtnLHBdPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOm4saGVpZ2h0OmF9PXRoaXMuYXR0cmlidXRlcztpZihuPT1udWxsfHxhPT1udWxsKXtjb25zdCBpPXRoaXNbdV07aSYmKG49PW51bGwmJihnPWkucmVjdFsyXSksYT09bnVsbCYmKHA9aS5yZWN0WzNdKSl9cmV0dXJuW2cscF19Z2V0IHRleHQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHQoZyl7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9Z31nZXQgdGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHRDb250ZW50KGcpe3RoaXMuYXR0cmlidXRlcy50ZXh0PWd9Z2V0IHRleHRJbWFnZSgpe3JldHVybiB0aGlzW3VdfHx7fX1nZXQgdGV4dEltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1tNXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhnKXtzdXBlci5kcmF3KGcpO2NvbnN0IHA9dGhpcy5tZXNoO2lmKHApe2NvbnN0IG49dGhpc1t1XTtpZihuKXtsZXQgYT1wLnRleHR1cmU7aWYoIWF8fHRoaXNbZl0mJnRoaXNbZl0hPT10aGlzLnJlbmRlcmVyfHxuLm5lZWRzVXBkYXRlPyhuLm5lZWRzVXBkYXRlPSExLE9iamVjdChzLmRlbGV0ZVRleHR1cmUpKG4uaW1hZ2UsdGhpcy5yZW5kZXJlciksYT1PYmplY3Qocy5jcmVhdGVUZXh0dXJlKShuLmltYWdlLHRoaXMucmVuZGVyZXIpLHRoaXNbdl09ITApOmE9cC51bmlmb3Jtcy51X3RleFNhbXBsZXIsdGhpc1t2XSl7Y29uc3RbaSxvXT1uLnJlY3Quc2xpY2UoMiksW1QsQV09dGhpcy5jb250ZW50U2l6ZSxDPXRoaXMuYXR0cmlidXRlcy50ZXh0QWxpZ24sST10aGlzLmF0dHJpYnV0ZXMudmVydGljYWxBbGlnbjtsZXQgUD0wO0M9PT0iY2VudGVyIj9QPShULWkpLzI6KEM9PT0icmlnaHQifHxDPT09ImVuZCIpJiYoUD1ULWkpO2NvbnN0IEw9dGhpcy5hdHRyaWJ1dGVzLmZvbnRTaXplLEQ9dGhpcy5hdHRyaWJ1dGVzLmxpbmVIZWlnaHQ7bGV0IGI9MDtJPT09InRvcCI/Yj0oTC1EKS8yOkk9PT0iYm90dG9tIiYmKGI9KEQtTCkvMik7Y29uc3R7cGFkZGluZ0xlZnQ6UyxwYWRkaW5nVG9wOkJ9PXRoaXMuYXR0cmlidXRlcyx7Ym9yZGVyV2lkdGg6d309dGhpcy5hdHRyaWJ1dGVzO1ArPVMrdyxiKz1CK3c7Y29uc3R7YW5jaG9yWDpILGFuY2hvclk6Sn09dGhpcy5hdHRyaWJ1dGVzO1AtPXRoaXMub2Zmc2V0U2l6ZVswXSpILGItPXRoaXMub2Zmc2V0U2l6ZVsxXSpKLHAuc2V0VGV4dHVyZShhLHtyZWN0OltQLGIsaSxvXX0pLHRoaXNbdl09ITEsdGhpc1tmXT10aGlzLnJlbmRlcmVyfX19cmV0dXJuIGd9b25Qcm9wZXJ0eUNoYW5nZShnLHAsbil7Zz09PSJ0ZXh0Inx8Zz09PSJmb250U2l6ZSJ8fGc9PT0iZm9udEZhbWlseSJ8fGc9PT0iZm9udFN0eWxlInx8Zz09PSJmb250VmFyaWFudCJ8fGc9PT0iZm9udFdlaWdodCJ8fGc9PT0iZm9udFN0cmV0Y2gifHxnPT09ImxpbmVIZWlnaHQifHxnPT09InN0cm9rZUNvbG9yInx8Zz09PSJmaWxsQ29sb3IifHxnPT09InN0cm9rZVdpZHRoIj90aGlzLnVwZGF0ZVRleHQoKTooKGc9PT0idGV4dEFsaWduInx8Zz09PSJ2ZXJ0aWNhbEFsaWduIikmJih0aGlzW3ZdPSEwKSxzdXBlci5vblByb3BlcnR5Q2hhbmdlKGcscCxuKSl9dXBkYXRlQ29udG91cnMoKXtzdXBlci51cGRhdGVDb250b3VycygpLHRoaXNbdl09ITB9dXBkYXRlVGV4dCgpe3RoaXNbTV18fCh0aGlzW01dPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzW01dPW51bGw7Y29uc3R7dGV4dDpnLGZvbnQ6cCxmaWxsQ29sb3I6bixzdHJva2VDb2xvcjphLHN0cm9rZVdpZHRoOml9PXRoaXMuYXR0cmlidXRlcyxvPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtyZXR1cm4gdGhpc1t4XT10aGlzW3hdfHxyLkVOVi5jcmVhdGVDYW52YXMoMSwxKSx0aGlzW3VdPXIuRU5WLmNyZWF0ZVRleHQoZyx7Zm9udDpwLGZpbGxDb2xvcjpuLHN0cm9rZUNvbG9yOmEsc3Ryb2tlV2lkdGg6aSxwYXJzZUZvbnQ6ci5wYXJzZUZvbnQscmF0aW86byx0ZXh0Q2FudmFzOnRoaXNbeF19KSx0aGlzW3VdLm5lZWRzVXBkYXRlPSEwLHRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpc1t1XX0pKX19bChSLCJBdHRyIix5LmRlZmF1bHQpLGMuZGVmYXVsdC5yZWdpc3Rlck5vZGUoUiwibGFiZWwiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciByPXQoMTIpLHM9dCg3MiksbT10KDIyMSkseT10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGM9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGw9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxNPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2NsYXNzIGYgZXh0ZW5kcyB5LmRlZmF1bHR7Y29uc3RydWN0b3IoeCl7c3VwZXIoeCksdGhpc1tjXSh7dGV4dDoiIixmb250U2l6ZToxNixmb250RmFtaWx5OiJIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZiIsZm9udFN0eWxlOiJub3JtYWwiLGZvbnRWYXJpYW50OiJub3JtYWwiLGZvbnRXZWlnaHQ6Im5vcm1hbCIsZm9udFN0cmV0Y2g6Im5vcm1hbCIsbGluZUhlaWdodDoiIix0ZXh0QWxpZ246ImxlZnQiLHN0cm9rZUNvbG9yOnZvaWQgMCxzdHJva2VXaWR0aDoxLGZpbGxDb2xvcjp2b2lkIDAsdmVydGljYWxBbGlnbjoibWlkZGxlIn0pLHRoaXNbTV0oImZvbnQiKX1nZXQgdGV4dCgpe3JldHVybiB0aGlzW3VdKCJ0ZXh0Iil8fCIgIn1zZXQgdGV4dCh4KXt0aGlzW2xdKCJ0ZXh0Iix4KX1nZXQgZm9udFNpemUoKXtyZXR1cm4gdGhpc1t1XSgiZm9udFNpemUiKX1zZXQgZm9udFNpemUoeCl7dGhpc1tsXSgiZm9udFNpemUiLE9iamVjdChzLnRvTnVtYmVyKSh4KSl9Z2V0IGZvbnRGYW1pbHkoKXtyZXR1cm4gdGhpc1t1XSgiZm9udEZhbWlseSIpfXNldCBmb250RmFtaWx5KHgpe3RoaXNbbF0oImZvbnRGYW1pbHkiLHgpfWdldCBmb250U3R5bGUoKXtyZXR1cm4gdGhpc1t1XSgiZm9udFN0eWxlIil9c2V0IGZvbnRTdHlsZSh4KXt0aGlzW2xdKCJmb250U3R5bGUiLHgpfWdldCBmb250VmFyaWFudCgpe3JldHVybiB0aGlzW3VdKCJmb250VmFyaWFudCIpfXNldCBmb250VmFyaWFudCh4KXt0aGlzW2xdKCJmb250VmFyaWFudCIseCl9Z2V0IGZvbnRXZWlnaHQoKXtyZXR1cm4gdGhpc1t1XSgiZm9udFdlaWdodCIpfXNldCBmb250V2VpZ2h0KHgpe3RoaXNbbF0oImZvbnRXZWlnaHQiLHgpfWdldCBmb250U3RyZXRjaCgpe3JldHVybiB0aGlzW3VdKCJmb250U3RyZXRjaCIpfXNldCBmb250U3RyZXRjaCh4KXt0aGlzW2xdKCJmb250U3RyZXRjaCIseCl9Z2V0IGxpbmVIZWlnaHQoKXtyZXR1cm4gdGhpc1t1XSgibGluZUhlaWdodCIpfHx0aGlzLmZvbnRTaXplfXNldCBsaW5lSGVpZ2h0KHgpe3RoaXNbbF0oImxpbmVIZWlnaHQiLE9iamVjdChzLnRvTnVtYmVyKSh4KSl9Z2V0IHRleHRBbGlnbigpe3JldHVybiB0aGlzW3VdKCJ0ZXh0QWxpZ24iKX1zZXQgdGV4dEFsaWduKHgpe3RoaXNbbF0oInRleHRBbGlnbiIseCl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbdV0oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKHgpe3RoaXNbbF0oInN0cm9rZUNvbG9yIixPYmplY3QobS5wYXJzZUNvbG9yKSh4KSl9Z2V0IHN0cm9rZVdpZHRoKCl7cmV0dXJuIHRoaXNbdV0oInN0cm9rZVdpZHRoIil9c2V0IHN0cm9rZVdpZHRoKHgpe3RoaXNbbF0oInN0cm9rZVdpZHRoIixPYmplY3Qocy50b051bWJlcikoeCkpfWdldCB2ZXJ0aWNhbEFsaWduKCl7cmV0dXJuIHRoaXNbdV0oInZlcnRpY2FsQWxpZ24iKX1zZXQgdmVydGljYWxBbGlnbih4KXt0aGlzW2xdKCJ2ZXJ0aWNhbEFsaWduIix4KX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbdV0oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IoeCl7dGhpc1tsXSgiZmlsbENvbG9yIixPYmplY3QobS5wYXJzZUNvbG9yKSh4KSl9Z2V0IGZvbnQoKXtjb25zdHtmb250U3R5bGU6eCxmb250VmFyaWFudDpSLGZvbnRXZWlnaHQ6Tyxmb250U3RyZXRjaDpnLGZvbnRTaXplOnAsbGluZUhlaWdodDpuLGZvbnRGYW1pbHk6YX09dGhpcztyZXR1cm5gJHt4fSAke1J9ICR7T30gJHtnfSAke3B9cHgvJHtufXB4ICR7YX1gfXNldCBmb250KHgpe2lmKHg9PW51bGwpdGhpcy5mb250U3R5bGU9bnVsbCx0aGlzLmZvbnRWYXJpYW50PW51bGwsdGhpcy5mb250V2VpZ2h0PW51bGwsdGhpcy5mb250U3RyZXRjaD1udWxsLHRoaXMuZm9udFNpemU9bnVsbCx0aGlzLmxpbmVIZWlnaHQ9bnVsbCx0aGlzLmZvbnRGYW1pbHk9bnVsbDtlbHNle2NvbnN0IFI9T2JqZWN0KHIucGFyc2VGb250KSh4KTt0aGlzLmZvbnRTdHlsZT1SLnN0eWxlLHRoaXMuZm9udFZhcmlhbnQ9Ui52YXJpYW50LHRoaXMuZm9udFdlaWdodD1SLndlaWdodCx0aGlzLmZvbnRTdHJldGNoPVIuc3RyZXRjaCx0aGlzLmZvbnRTaXplPU9iamVjdChzLnRvTnVtYmVyKShgJHtSLnNpemV9JHtSLnVuaXR9YCksUi5saW5lSGVpZ2h0JiYodGhpcy5saW5lSGVpZ2h0PVIucHhMaW5lSGVpZ2h0KSx0aGlzLmZvbnRGYW1pbHk9Ui5mYW1pbHl9fX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgcj10KDEyKSxzPXQoMjE5KSxtPXQoMjUxKSx5PXQoMjEzKSxjPXQoMjUyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChSLE8sZyl7cmV0dXJuIE8gaW4gUj9PYmplY3QuZGVmaW5lUHJvcGVydHkoUixPLHt2YWx1ZTpnLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6UltPXT1nLFJ9Y29uc3QgdT1TeW1ib2woInpPcmRlciIpLE09U3ltYm9sKCJvcmRlcmVkIiksZj1TeW1ib2woImNoaWxkcmVuIiksdj1TeW1ib2woInNlYWxlZCIpO2NsYXNzIHggZXh0ZW5kcyBzLmRlZmF1bHR7Y29uc3RydWN0b3IoTz17fSl7c3VwZXIoTyksdGhpc1tmXT1bXSx0aGlzW01dPW51bGwsdGhpc1t1XT0wfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuIHRoaXNbZl19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXNbZl19Z2V0IG9yZGVyZWRDaGlsZHJlbigpe3JldHVybiB0aGlzW01dfHwodGhpc1tNXT1bLi4udGhpc1tmXV0sdGhpc1tNXS5zb3J0KChPLGcpPT5PLnpJbmRleC1nLnpJbmRleHx8Ty56T3JkZXItZy56T3JkZXIpKSx0aGlzW01dfWFwcGVuZCguLi5PKXtyZXR1cm4gTy5tYXAoZz0+dGhpcy5hcHBlbmRDaGlsZChnKSl9YXBwZW5kQ2hpbGQoTyl7cmV0dXJuIE8ucmVtb3ZlKCksdGhpc1tmXS5wdXNoKE8pLE8uY29ubmVjdCh0aGlzLHRoaXNbdV0rKyksdGhpc1tNXSYmKHRoaXNbTV0ubGVuZ3RoJiZPLnpJbmRleDx0aGlzW01dW3RoaXNbTV0ubGVuZ3RoLTFdLnpJbmRleD90aGlzLnJlb3JkZXIoKTp0aGlzW01dLnB1c2goTykpLE99Y2xvbmVOb2RlKE89ITEpe2NvbnN0IGc9c3VwZXIuY2xvbmVOb2RlKCk7cmV0dXJuIE8mJnRoaXNbZl0uZm9yRWFjaChwPT57Y29uc3Qgbj1wLmNsb25lTm9kZShPKTtnLmFwcGVuZENoaWxkKG4pfSksZ31kaXNwYXRjaFBvaW50ZXJFdmVudChPKXtjb25zdCBnPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgcD1nLmxlbmd0aC0xO3A+PTA7cC0tKWlmKGdbcF0uZGlzcGF0Y2hQb2ludGVyRXZlbnQoTykpcmV0dXJuITA7cmV0dXJuIHN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KE8pfWRyYXcoTz1bXSl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PXRoaXMucmVuZGVyTWF0cml4LHN1cGVyLmRyYXcoTyksIXRoaXNbdl0mJnRoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiKXtjb25zdCBnPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgcD0wO3A8Zy5sZW5ndGg7cCsrKWdbcF0uZHJhdyhPKX1yZXR1cm4gdGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PW51bGwsT31nZXRFbGVtZW50QnlJZChPKXtyZXR1cm4gT2JqZWN0KGMucXVlcnlTZWxlY3RvcikoYCMke099YCx0aGlzKX1nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKE8pe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yQWxsKShgLiR7T31gLHRoaXMpfWdldEVsZW1lbnRzQnlOYW1lKE8pe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yQWxsKShgW25hbWU9IiR7T30iXWAsdGhpcyl9Z2V0RWxlbWVudHNCeVRhZ05hbWUoTyl7cmV0dXJuIE9iamVjdChjLnF1ZXJ5U2VsZWN0b3JBbGwpKE8sdGhpcyl9aW5zZXJ0QmVmb3JlKE8sZyl7aWYoZz09bnVsbClyZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChPKTtPLnJlbW92ZSgpO2NvbnN0IHA9dGhpc1tmXS5pbmRleE9mKGcpO2lmKHA8MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7Y29uc3Qgbj1nLnpPcmRlcjtmb3IobGV0IGE9cDthPHRoaXNbZl0ubGVuZ3RoO2ErKyl7Y29uc3QgaT10aGlzW2ZdW2FdLnpPcmRlcixvPXRoaXNbZl1bYV07ZGVsZXRlIG8uek9yZGVyLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCJ6T3JkZXIiLHt2YWx1ZTppKzEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9aWYodGhpc1tmXS5zcGxpY2UocCwwLE8pLE8uY29ubmVjdCh0aGlzLG4pLHRoaXNbTV0paWYoTy56SW5kZXghPT1nLnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IGE9dGhpc1tNXS5pbmRleE9mKGcpO3RoaXNbTV0uc3BsaWNlKGEsMCxPKX1yZXR1cm4gT31xdWVyeVNlbGVjdG9yKE8pe3JldHVybiBPYmplY3QoYy5xdWVyeVNlbGVjdG9yKShPLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoTyl7cmV0dXJuIE9iamVjdChjLnF1ZXJ5U2VsZWN0b3JBbGwpKE8sdGhpcyl9cmVwbGFjZUNoaWxkKE8sZyl7Ty5yZW1vdmUoKTtjb25zdCBwPXRoaXNbZl0uaW5kZXhPZihnKTtpZihwPDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2lmKHRoaXNbZl1bcF09TyxPLmNvbm5lY3QodGhpcyxnLnpPcmRlciksdGhpc1tNXSlpZihPLnpJbmRleCE9PWcuekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3Qgbj10aGlzW01dLmluZGV4T2YoZyk7dGhpc1tNXVtuXT1PfXJldHVybiBnLmRpc2Nvbm5lY3QodGhpcyksT31yZW1vdmVBbGxDaGlsZHJlbigpe2NvbnN0IE89dGhpc1tmXTtmb3IobGV0IGc9Ty5sZW5ndGgtMTtnPj0wO2ctLSlPW2ddLnJlbW92ZSgpfXJlbW92ZUNoaWxkKE8pe2NvbnN0IGc9dGhpc1tmXS5pbmRleE9mKE8pO2lmKGc+PTApe2lmKHRoaXNbZl0uc3BsaWNlKGcsMSksdGhpc1tNXSl7Y29uc3QgcD10aGlzW01dLmluZGV4T2YoTyk7dGhpc1tNXS5zcGxpY2UocCwxKX1yZXR1cm4gTy5kaXNjb25uZWN0KHRoaXMpLE99cmV0dXJuIG51bGx9cmVvcmRlcigpe3RoaXNbTV09bnVsbH1zZWFsKCl7ZnVuY3Rpb24gTyhhLGkpe2NvbnN0IG89W107Zm9yKGxldCBUPTA7VDxhLmxlbmd0aDtUKyspe2NvbnN0IEE9Wy4uLmFbVF1dO2ZvcihsZXQgQz0xO0M8QS5sZW5ndGg7Qys9Mil7Y29uc3QgST1BW0NdLFA9QVtDKzFdO0FbQ109SSppWzBdK1AqaVsyXStpWzRdLEFbQysxXT1JKmlbMV0rUCppWzNdK2lbNV19by5wdXNoKEEpfXJldHVybiBvfWNvbnN0IGc9dGhpcy5vcmRlcmVkQ2hpbGRyZW4scD1uZXcgci5GaWd1cmUyRCxuPXRoaXMubG9jYWxNYXRyaXg7Zm9yKGxldCBhPTA7YTxnLmxlbmd0aDthKyspe2xldCBpPWdbYV07aWYoaSBpbnN0YW5jZW9mIHgmJihpPWkuc2VhbCgpKSxpLmNsaWVudEJveCl7bGV0IG89aS5jbGllbnRCb3guY29udG91cnMucGF0aDtvPU8obyxpLmxvY2FsTWF0cml4KSxwLmFkZFBhdGgobyl9aWYoaS5wYXRoKXtsZXQgbz1pLnBhdGguY29udG91cnMucGF0aDtvPU8obyxpLmxvY2FsTWF0cml4KSxwLmFkZFBhdGgobyl9fXJldHVybiB0aGlzW3ZdPSEwLHRoaXMuY2xpZW50Qm94PXAse2NsaWVudEJveDpwLGxvY2FsTWF0cml4Om59fXNldFJlc29sdXRpb24oe3dpZHRoOk8saGVpZ2h0Omd9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpPLGhlaWdodDpnfSksdGhpc1tmXS5mb3JFYWNoKHA9PntwLnNldFJlc29sdXRpb24oe3dpZHRoOk8saGVpZ2h0Omd9KX0pfXVwZGF0ZUNvbnRvdXJzKCl7dGhpc1t2XXx8c3VwZXIudXBkYXRlQ29udG91cnMoKX19bCh4LCJBdHRyIixtLmRlZmF1bHQpLHkuZGVmYXVsdC5yZWdpc3Rlck5vZGUoeCwiZ3JvdXAiKX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciByPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgcyBleHRlbmRzIHIuZGVmYXVsdHt9fSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJxdWVyeVNlbGVjdG9yQWxsIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInF1ZXJ5U2VsZWN0b3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiaXNNYXRjaGVkIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImNvbXBpbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgcj10KDIyMSkscz10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IG09dCgyNTMpO2Z1bmN0aW9uIHkoZyl7cmV0dXJuIGcubm9kZVR5cGU9PT0xfHxzLmRlZmF1bHQuaXNTcHJpdGVOb2RlKGcubm9kZU5hbWUpfWZ1bmN0aW9uIGMoZyl7cmV0dXJuIEFycmF5LmZyb20oZy5jaGlsZE5vZGVzfHxbXSl9ZnVuY3Rpb24gbChnKXtyZXR1cm4gcy5kZWZhdWx0LmlzU3ByaXRlTm9kZShnLm5vZGVOYW1lKT9nLnBhcmVudHx8Zy5jYW52YXN8fGcuY29udGFpbmVyOmcucGFyZW50RWxlbWVudH1mdW5jdGlvbiB1KGcpe2xldCBwPWcubGVuZ3RoLG4sYSxpO2Zvcig7LS1wPi0xOyl7Zm9yKG49YT1nW3BdLGdbcF09bnVsbCxpPSEwO2E7KXtpZihnLmluZGV4T2YoYSk+LTEpe2k9ITEsZy5zcGxpY2UocCwxKTticmVha31hPWwoYSl9aSYmKGdbcF09bil9cmV0dXJuIGd9Y29uc3QgTT17aXNUYWc6eSxleGlzdHNPbmUoZyxwKXtyZXR1cm4gcC5zb21lKG49Pnkobik/ZyhuKXx8TS5leGlzdHNPbmUoZyxjKG4pKTohMSl9LGdldFNpYmxpbmdzKGcpe2NvbnN0IHA9bChnKTtyZXR1cm4gcCYmYyhwKX0sZ2V0Q2hpbGRyZW46YyxnZXRQYXJlbnQ6bCxnZXRBdHRyaWJ1dGVWYWx1ZShnLHApe2lmKGcubm9kZVR5cGU9PT0xJiZwPT09ImNsYXNzInx8cD09PSJpZCIpcmV0dXJuIGdbcF07aWYodGhpcy5oYXNBdHRyaWIoZyxwKSl7bGV0IG49Zy5hdHRyaWJ1dGVzW3BdO3JldHVybiBBcnJheS5pc0FycmF5KG4pJiYobj1gWyR7bi5qb2luKCl9XWApLFN0cmluZyhuKX19LGhhc0F0dHJpYihnLHApe3JldHVybiBnLmF0dHJpYnV0ZXNbcF0hPW51bGx9LHJlbW92ZVN1YnNldHM6dSxnZXROYW1lKGcpe3JldHVybiBnLnRhZ05hbWU/Zy50YWdOYW1lLnRvTG93ZXJDYXNlKCk6bnVsbH0sZmluZE9uZTpmdW5jdGlvbiBnKHAsbil7bGV0IGE9bnVsbDtmb3IobGV0IGk9MCxvPW4ubGVuZ3RoO2k8byYmIWE7aSsrKWlmKHAobltpXSkpYT1uW2ldO2Vsc2V7Y29uc3QgVD1jKG5baV0pO1QmJlQubGVuZ3RoPjAmJihhPWcocCxUKSl9cmV0dXJuIGF9LGZpbmRBbGw6ZnVuY3Rpb24gZyhwLG4pe2xldCBhPVtdO2ZvcihsZXQgaT0wLG89bi5sZW5ndGg7aTxvO2krKyl7aWYoIXkobltpXSkpY29udGludWU7cChuW2ldKSYmYS5wdXNoKG5baV0pO2NvbnN0IFQ9YyhuW2ldKTtUJiYoYT1hLmNvbmNhdChnKHAsVCkpKX1yZXR1cm4gYX0sZ2V0VGV4dDpmdW5jdGlvbiBnKHApe3JldHVybiBBcnJheS5pc0FycmF5KHApP3AubWFwKGcpLmpvaW4oIiIpOnkocCk/ZyhjKHApKTpwLm5vZGVUeXBlPT09Mz9wLm5vZGVWYWx1ZTpzLmRlZmF1bHQuaXNTcHJpdGVOb2RlKHAubm9kZU5hbWUpP3AudGV4dDoiIn19O2Z1bmN0aW9uIGYoZyl7aWYodHlwZW9mIGchPSJzdHJpbmciKXJldHVybiBnO2xldCBwPWcubWF0Y2goL1xbKGJnY29sb3J8ZmlsbENvbG9yfHN0cm9rZUNvbG9yfGNvbG9yKVxzKj1ccypbJyJdP1x3K1snIl0/XF0vZyk7cmV0dXJuIHAmJihwPXAubWFwKG49Pntjb25zdCBhPW4uc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxpPU9iamVjdChyLnBhcnNlQ29sb3IpKGFbMV0ucmVwbGFjZSgvWyciXS9nLCIiKSk7cmV0dXJuW24sYFske2FbMF19PSIke2l9Il1gXX0pLHAuZm9yRWFjaCgoW24sYV0pPT57Zz1nLnJlcGxhY2UobixhKX0pKSxwPWcubWF0Y2goL1xbXHcrXHMqPVxzKlsnIl1cWy4rP1xdWyciXVxdL2cpLHAmJihwPXAubWFwKG49Pntjb25zdCBhPW4uc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxpPWFbMV0uc2xpY2UoMiwtMikuc3BsaXQoLywvZykubWFwKG89Pm8udHJpbSgpKTtyZXR1cm5bbixgWyR7YVswXX09Ilske2l9XSJdYF19KSxwLmZvckVhY2goKFtuLGFdKT0+e2c9Zy5yZXBsYWNlKG4sYSl9KSksZ31mdW5jdGlvbiB2KGcscCl7cmV0dXJuIG0uc2VsZWN0QWxsKGYoZykscCx7YWRhcHRlcjpNfSl9ZnVuY3Rpb24geChnLHApe3JldHVybiBtLnNlbGVjdE9uZShmKGcpLHAse2FkYXB0ZXI6TX0pfWZ1bmN0aW9uIFIoZyxwKXtyZXR1cm4gbS5pcyhnLGYocCkse2FkYXB0ZXI6TX0pfWZ1bmN0aW9uIE8oZyl7cmV0dXJuIG0uY29tcGlsZShmKGcpLHthZGFwdGVyOk19KX19LGZ1bmN0aW9uKGgsZSx0KXtoLmV4cG9ydHM9Tzt2YXIgcj10KDI1NCkscz10KDI3MykuZmFsc2VGdW5jLG09dCgyNzQpO2Z1bmN0aW9uIHkoZyl7cmV0dXJuIGZ1bmN0aW9uKG4sYSxpKXtyZXR1cm4gYT1hfHx7fSxhLmFkYXB0ZXI9YS5hZGFwdGVyfHxyLGcobixhLGkpfX12YXIgYz15KG0pLGw9eShtLmNvbXBpbGVVbnNhZmUpO2Z1bmN0aW9uIHUoZyl7cmV0dXJuIGZ1bmN0aW9uKG4sYSxpKXtyZXR1cm4gaT1pfHx7fSxpLmFkYXB0ZXI9aS5hZGFwdGVyfHxyLHR5cGVvZiBuIT0iZnVuY3Rpb24iJiYobj1sKG4saSxhKSksbi5zaG91bGRUZXN0TmV4dFNpYmxpbmdzJiYoYT1mKGkmJmkuY29udGV4dHx8YSxpLmFkYXB0ZXIpKSxBcnJheS5pc0FycmF5KGEpP2E9aS5hZGFwdGVyLnJlbW92ZVN1YnNldHMoYSk6YT1pLmFkYXB0ZXIuZ2V0Q2hpbGRyZW4oYSksZyhuLGEsaSl9fWZ1bmN0aW9uIE0oZyxwKXt2YXIgbj1wLmdldFNpYmxpbmdzKGcpO2lmKCFBcnJheS5pc0FycmF5KG4pKXJldHVybltdO2ZvcihuPW4uc2xpY2UoMCk7bi5zaGlmdCgpIT09ZzspO3JldHVybiBufWZ1bmN0aW9uIGYoZyxwKXtBcnJheS5pc0FycmF5KGcpfHwoZz1bZ10pO2Zvcih2YXIgbj1nLnNsaWNlKDApLGE9MCxpPWcubGVuZ3RoO2E8aTthKyspe3ZhciBvPU0oblthXSxwKTtuLnB1c2guYXBwbHkobixvKX1yZXR1cm4gbn12YXIgdj11KGZ1bmN0aW9uKHAsbixhKXtyZXR1cm4gcD09PXN8fCFufHxuLmxlbmd0aD09PTA/W106YS5hZGFwdGVyLmZpbmRBbGwocCxuKX0pLHg9dShmdW5jdGlvbihwLG4sYSl7cmV0dXJuIHA9PT1zfHwhbnx8bi5sZW5ndGg9PT0wP251bGw6YS5hZGFwdGVyLmZpbmRPbmUocCxuKX0pO2Z1bmN0aW9uIFIoZyxwLG4pe3JldHVybiBuPW58fHt9LG4uYWRhcHRlcj1uLmFkYXB0ZXJ8fHIsKHR5cGVvZiBwPT0iZnVuY3Rpb24iP3A6YyhwLG4pKShnKX1mdW5jdGlvbiBPKGcscCxuKXtyZXR1cm4gdihnLHAsbil9Ty5jb21waWxlPWMsTy5maWx0ZXJzPW0uUHNldWRvcy5maWx0ZXJzLE8ucHNldWRvcz1tLlBzZXVkb3MucHNldWRvcyxPLnNlbGVjdEFsbD12LE8uc2VsZWN0T25lPXgsTy5pcz1SLE8ucGFyc2U9YyxPLml0ZXJhdGU9dixPLl9jb21waWxlVW5zYWZlPWwsTy5fY29tcGlsZVRva2VuPW0uY29tcGlsZVRva2VufSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9aC5leHBvcnRzO1t0KDI1NSksdCgyNjgpLHQoMjY5KSx0KDI3MCksdCgyNzEpLHQoMjcyKV0uZm9yRWFjaChmdW5jdGlvbihzKXtPYmplY3Qua2V5cyhzKS5mb3JFYWNoKGZ1bmN0aW9uKG0pe3JbbV09c1ttXS5iaW5kKHIpfSl9KX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjU2KSxzPXQoMjU3KSxtPXIuaXNUYWc7aC5leHBvcnRzPXtnZXRJbm5lckhUTUw6eSxnZXRPdXRlckhUTUw6cyxnZXRUZXh0OmN9O2Z1bmN0aW9uIHkobCx1KXtyZXR1cm4gbC5jaGlsZHJlbj9sLmNoaWxkcmVuLm1hcChmdW5jdGlvbihNKXtyZXR1cm4gcyhNLHUpfSkuam9pbigiIik6IiJ9ZnVuY3Rpb24gYyhsKXtyZXR1cm4gQXJyYXkuaXNBcnJheShsKT9sLm1hcChjKS5qb2luKCIiKTptKGwpP2wubmFtZT09PSJiciI/YApgOmMobC5jaGlsZHJlbik6bC50eXBlPT09ci5DREFUQT9jKGwuY2hpbGRyZW4pOmwudHlwZT09PXIuVGV4dD9sLmRhdGE6IiJ9fSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz17VGV4dDoidGV4dCIsRGlyZWN0aXZlOiJkaXJlY3RpdmUiLENvbW1lbnQ6ImNvbW1lbnQiLFNjcmlwdDoic2NyaXB0IixTdHlsZToic3R5bGUiLFRhZzoidGFnIixDREFUQToiY2RhdGEiLERvY3R5cGU6ImRvY3R5cGUiLGlzVGFnOmZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGU9PT0idGFnInx8dC50eXBlPT09InNjcmlwdCJ8fHQudHlwZT09PSJzdHlsZSJ9fX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjU4KSxzPXQoMjU5KSxtPXQoMjY3KTttLmVsZW1lbnROYW1lcy5fX3Byb3RvX189bnVsbCxtLmF0dHJpYnV0ZU5hbWVzLl9fcHJvdG9fXz1udWxsO3ZhciB5PXtfX3Byb3RvX186bnVsbCxzdHlsZTohMCxzY3JpcHQ6ITAseG1wOiEwLGlmcmFtZTohMCxub2VtYmVkOiEwLG5vZnJhbWVzOiEwLHBsYWludGV4dDohMCxub3NjcmlwdDohMH07ZnVuY3Rpb24gYyhnLHApe2lmKGcpe3ZhciBuPSIiLGE7Zm9yKHZhciBpIGluIGcpYT1nW2ldLG4mJihuKz0iICIpLHAueG1sTW9kZT09PSJmb3JlaWduIiYmKGk9bS5hdHRyaWJ1dGVOYW1lc1tpXXx8aSksbis9aSwoYSE9PW51bGwmJmEhPT0iInx8cC54bWxNb2RlKSYmKG4rPSc9IicrKHAuZGVjb2RlRW50aXRpZXM/cy5lbmNvZGVYTUwoYSk6YS5yZXBsYWNlKC9cIi9nLCImcXVvdDsiKSkrJyInKTtyZXR1cm4gbn19dmFyIGw9e19fcHJvdG9fXzpudWxsLGFyZWE6ITAsYmFzZTohMCxiYXNlZm9udDohMCxicjohMCxjb2w6ITAsY29tbWFuZDohMCxlbWJlZDohMCxmcmFtZTohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsaXNpbmRleDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9LHU9aC5leHBvcnRzPWZ1bmN0aW9uKGcscCl7IUFycmF5LmlzQXJyYXkoZykmJiFnLmNoZWVyaW8mJihnPVtnXSkscD1wfHx7fTtmb3IodmFyIG49IiIsYT0wO2E8Zy5sZW5ndGg7YSsrKXt2YXIgaT1nW2FdO2kudHlwZT09PSJyb290Ij9uKz11KGkuY2hpbGRyZW4scCk6ci5pc1RhZyhpKT9uKz1mKGkscCk6aS50eXBlPT09ci5EaXJlY3RpdmU/bis9dihpKTppLnR5cGU9PT1yLkNvbW1lbnQ/bis9TyhpKTppLnR5cGU9PT1yLkNEQVRBP24rPVIoaSk6bis9eChpLHApfXJldHVybiBufSxNPVsibWkiLCJtbyIsIm1uIiwibXMiLCJtdGV4dCIsImFubm90YXRpb24teG1sIiwiZm9yZWlnbk9iamVjdCIsImRlc2MiLCJ0aXRsZSJdO2Z1bmN0aW9uIGYoZyxwKXtwLnhtbE1vZGU9PT0iZm9yZWlnbiImJihnLm5hbWU9bS5lbGVtZW50TmFtZXNbZy5uYW1lXXx8Zy5uYW1lLGcucGFyZW50JiZNLmluZGV4T2YoZy5wYXJlbnQubmFtZSk+PTAmJihwPU9iamVjdC5hc3NpZ24oe30scCx7eG1sTW9kZTohMX0pKSksIXAueG1sTW9kZSYmWyJzdmciLCJtYXRoIl0uaW5kZXhPZihnLm5hbWUpPj0wJiYocD1PYmplY3QuYXNzaWduKHt9LHAse3htbE1vZGU6ImZvcmVpZ24ifSkpO3ZhciBuPSI8IitnLm5hbWUsYT1jKGcuYXR0cmlicyxwKTtyZXR1cm4gYSYmKG4rPSIgIithKSxwLnhtbE1vZGUmJighZy5jaGlsZHJlbnx8Zy5jaGlsZHJlbi5sZW5ndGg9PT0wKT9uKz0iLz4iOihuKz0iPiIsZy5jaGlsZHJlbiYmKG4rPXUoZy5jaGlsZHJlbixwKSksKCFsW2cubmFtZV18fHAueG1sTW9kZSkmJihuKz0iPC8iK2cubmFtZSsiPiIpKSxufWZ1bmN0aW9uIHYoZyl7cmV0dXJuIjwiK2cuZGF0YSsiPiJ9ZnVuY3Rpb24geChnLHApe3ZhciBuPWcuZGF0YXx8IiI7cmV0dXJuIHAuZGVjb2RlRW50aXRpZXMmJiEoZy5wYXJlbnQmJmcucGFyZW50Lm5hbWUgaW4geSkmJihuPXMuZW5jb2RlWE1MKG4pKSxufWZ1bmN0aW9uIFIoZyl7cmV0dXJuIjwhW0NEQVRBWyIrZy5jaGlsZHJlblswXS5kYXRhKyJdXT4ifWZ1bmN0aW9uIE8oZyl7cmV0dXJuIjwhLS0iK2cuZGF0YSsiLS0+In19LGZ1bmN0aW9uKGgsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gcihzKXtyZXR1cm4gcy50eXBlPT09InRhZyJ8fHMudHlwZT09PSJzY3JpcHQifHxzLnR5cGU9PT0ic3R5bGUifWUuaXNUYWc9cixlLlRleHQ9InRleHQiLGUuRGlyZWN0aXZlPSJkaXJlY3RpdmUiLGUuQ29tbWVudD0iY29tbWVudCIsZS5TY3JpcHQ9InNjcmlwdCIsZS5TdHlsZT0ic3R5bGUiLGUuVGFnPSJ0YWciLGUuQ0RBVEE9ImNkYXRhIixlLkRvY3R5cGU9ImRvY3R5cGUifSxmdW5jdGlvbihoLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZW5jb2RlPWUuZGVjb2RlU3RyaWN0PWUuZGVjb2RlPXZvaWQgMDt2YXIgcj10KDI2MCkscz10KDI2Nik7ZnVuY3Rpb24gbShNLGYpe3JldHVybighZnx8Zjw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUwpKE0pfWUuZGVjb2RlPW07ZnVuY3Rpb24geShNLGYpe3JldHVybighZnx8Zjw9MD9yLmRlY29kZVhNTDpyLmRlY29kZUhUTUxTdHJpY3QpKE0pfWUuZGVjb2RlU3RyaWN0PXk7ZnVuY3Rpb24gYyhNLGYpe3JldHVybighZnx8Zjw9MD9zLmVuY29kZVhNTDpzLmVuY29kZUhUTUwpKE0pfWUuZW5jb2RlPWM7dmFyIGw9dCgyNjYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsLmVuY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZXNjYXBlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbC5lc2NhcGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbC5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuZW5jb2RlSFRNTH19KTt2YXIgdT10KDI2MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVjb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNVN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWNvZGVYTUx9fSl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZil7cmV0dXJuIGYmJmYuX19lc01vZHVsZT9mOntkZWZhdWx0OmZ9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWNvZGVIVE1MPWUuZGVjb2RlSFRNTFN0cmljdD1lLmRlY29kZVhNTD12b2lkIDA7dmFyIHM9cih0KDI2MSkpLG09cih0KDI2MikpLHk9cih0KDI2MykpLGM9cih0KDI2NCkpO2UuZGVjb2RlWE1MPWwoeS5kZWZhdWx0KSxlLmRlY29kZUhUTUxTdHJpY3Q9bChzLmRlZmF1bHQpO2Z1bmN0aW9uIGwoZil7dmFyIHY9T2JqZWN0LmtleXMoZikuam9pbigifCIpLHg9TShmKTt2Kz0ifCNbeFhdW1xcZGEtZkEtRl0rfCNcXGQrIjt2YXIgUj1uZXcgUmVnRXhwKCImKD86Iit2KyIpOyIsImciKTtyZXR1cm4gZnVuY3Rpb24oTyl7cmV0dXJuIFN0cmluZyhPKS5yZXBsYWNlKFIseCl9fXZhciB1PWZ1bmN0aW9uKGYsdil7cmV0dXJuIGY8dj8xOi0xfTtlLmRlY29kZUhUTUw9ZnVuY3Rpb24oKXtmb3IodmFyIGY9T2JqZWN0LmtleXMobS5kZWZhdWx0KS5zb3J0KHUpLHY9T2JqZWN0LmtleXMocy5kZWZhdWx0KS5zb3J0KHUpLHg9MCxSPTA7eDx2Lmxlbmd0aDt4KyspZltSXT09PXZbeF0/KHZbeF0rPSI7PyIsUisrKTp2W3hdKz0iOyI7dmFyIE89bmV3IFJlZ0V4cCgiJig/OiIrdi5qb2luKCJ8IikrInwjW3hYXVtcXGRhLWZBLUZdKzs/fCNcXGQrOz8pIiwiZyIpLGc9TShzLmRlZmF1bHQpO2Z1bmN0aW9uIHAobil7cmV0dXJuIG4uc3Vic3RyKC0xKSE9PSI7IiYmKG4rPSI7IiksZyhuKX1yZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIFN0cmluZyhuKS5yZXBsYWNlKE8scCl9fSgpO2Z1bmN0aW9uIE0oZil7cmV0dXJuIGZ1bmN0aW9uKHgpe2lmKHguY2hhckF0KDEpPT09IiMiKXt2YXIgUj14LmNoYXJBdCgyKTtyZXR1cm4gUj09PSJYInx8Uj09PSJ4Ij9jLmRlZmF1bHQocGFyc2VJbnQoeC5zdWJzdHIoMyksMTYpKTpjLmRlZmF1bHQocGFyc2VJbnQoeC5zdWJzdHIoMiksMTApKX1yZXR1cm4gZlt4LnNsaWNlKDEsLTEpXX19fSxmdW5jdGlvbihoKXtoLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWJyZXZlIjoixIIiLCJhYnJldmUiOiLEgyIsImFjIjoi4oi+IiwiYWNkIjoi4oi/IiwiYWNFIjoi4oi+zLMiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBY3kiOiLQkCIsImFjeSI6ItCwIiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJhZiI6IuKBoSIsIkFmciI6IvCdlIQiLCJhZnIiOiLwnZSeIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFsZWZzeW0iOiLihLUiLCJhbGVwaCI6IuKEtSIsIkFscGhhIjoizpEiLCJhbHBoYSI6Is6xIiwiQW1hY3IiOiLEgCIsImFtYWNyIjoixIEiLCJhbWFsZyI6IuKovyIsImFtcCI6IiYiLCJBTVAiOiImIiwiYW5kYW5kIjoi4qmVIiwiQW5kIjoi4qmTIiwiYW5kIjoi4oinIiwiYW5kZCI6IuKpnCIsImFuZHNsb3BlIjoi4qmYIiwiYW5kdiI6IuKpmiIsImFuZyI6IuKIoCIsImFuZ2UiOiLipqQiLCJhbmdsZSI6IuKIoCIsImFuZ21zZGFhIjoi4qaoIiwiYW5nbXNkYWIiOiLipqkiLCJhbmdtc2RhYyI6IuKmqiIsImFuZ21zZGFkIjoi4qarIiwiYW5nbXNkYWUiOiLipqwiLCJhbmdtc2RhZiI6IuKmrSIsImFuZ21zZGFnIjoi4qauIiwiYW5nbXNkYWgiOiLipq8iLCJhbmdtc2QiOiLiiKEiLCJhbmdydCI6IuKInyIsImFuZ3J0dmIiOiLiir4iLCJhbmdydHZiZCI6IuKmnSIsImFuZ3NwaCI6IuKIoiIsImFuZ3N0Ijoiw4UiLCJhbmd6YXJyIjoi4o28IiwiQW9nb24iOiLEhCIsImFvZ29uIjoixIUiLCJBb3BmIjoi8J2UuCIsImFvcGYiOiLwnZWSIiwiYXBhY2lyIjoi4qmvIiwiYXAiOiLiiYgiLCJhcEUiOiLiqbAiLCJhcGUiOiLiiYoiLCJhcGlkIjoi4omLIiwiYXBvcyI6IlwnIiwiQXBwbHlGdW5jdGlvbiI6IuKBoSIsImFwcHJveCI6IuKJiCIsImFwcHJveGVxIjoi4omKIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBc2NyIjoi8J2SnCIsImFzY3IiOiLwnZK2IiwiQXNzaWduIjoi4omUIiwiYXN0IjoiKiIsImFzeW1wIjoi4omIIiwiYXN5bXBlcSI6IuKJjSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJhd2NvbmludCI6IuKIsyIsImF3aW50Ijoi4qiRIiwiYmFja2NvbmciOiLiiYwiLCJiYWNrZXBzaWxvbiI6Is+2IiwiYmFja3ByaW1lIjoi4oC1IiwiYmFja3NpbSI6IuKIvSIsImJhY2tzaW1lcSI6IuKLjSIsIkJhY2tzbGFzaCI6IuKIliIsIkJhcnYiOiLiq6ciLCJiYXJ2ZWUiOiLiir0iLCJiYXJ3ZWQiOiLijIUiLCJCYXJ3ZWQiOiLijIYiLCJiYXJ3ZWRnZSI6IuKMhSIsImJicmsiOiLijrUiLCJiYnJrdGJyayI6IuKOtiIsImJjb25nIjoi4omMIiwiQmN5Ijoi0JEiLCJiY3kiOiLQsSIsImJkcXVvIjoi4oCeIiwiYmVjYXVzIjoi4oi1IiwiYmVjYXVzZSI6IuKItSIsIkJlY2F1c2UiOiLiiLUiLCJiZW1wdHl2Ijoi4qawIiwiYmVwc2kiOiLPtiIsImJlcm5vdSI6IuKErCIsIkJlcm5vdWxsaXMiOiLihKwiLCJCZXRhIjoizpIiLCJiZXRhIjoizrIiLCJiZXRoIjoi4oS2IiwiYmV0d2VlbiI6IuKJrCIsIkJmciI6IvCdlIUiLCJiZnIiOiLwnZSfIiwiYmlnY2FwIjoi4ouCIiwiYmlnY2lyYyI6IuKXryIsImJpZ2N1cCI6IuKLgyIsImJpZ29kb3QiOiLiqIAiLCJiaWdvcGx1cyI6IuKogSIsImJpZ290aW1lcyI6IuKogiIsImJpZ3NxY3VwIjoi4qiGIiwiYmlnc3RhciI6IuKYhSIsImJpZ3RyaWFuZ2xlZG93biI6IuKWvSIsImJpZ3RyaWFuZ2xldXAiOiLilrMiLCJiaWd1cGx1cyI6IuKohCIsImJpZ3ZlZSI6IuKLgSIsImJpZ3dlZGdlIjoi4ouAIiwiYmthcm93Ijoi4qSNIiwiYmxhY2tsb3plbmdlIjoi4qerIiwiYmxhY2tzcXVhcmUiOiLilqoiLCJibGFja3RyaWFuZ2xlIjoi4pa0IiwiYmxhY2t0cmlhbmdsZWRvd24iOiLilr4iLCJibGFja3RyaWFuZ2xlbGVmdCI6IuKXgiIsImJsYWNrdHJpYW5nbGVyaWdodCI6IuKWuCIsImJsYW5rIjoi4pCjIiwiYmxrMTIiOiLilpIiLCJibGsxNCI6IuKWkSIsImJsazM0Ijoi4paTIiwiYmxvY2siOiLilogiLCJibmUiOiI94oOlIiwiYm5lcXVpdiI6IuKJoeKDpSIsImJOb3QiOiLiq60iLCJibm90Ijoi4oyQIiwiQm9wZiI6IvCdlLkiLCJib3BmIjoi8J2VkyIsImJvdCI6IuKKpSIsImJvdHRvbSI6IuKKpSIsImJvd3RpZSI6IuKLiCIsImJveGJveCI6IuKniSIsImJveGRsIjoi4pSQIiwiYm94ZEwiOiLilZUiLCJib3hEbCI6IuKVliIsImJveERMIjoi4pWXIiwiYm94ZHIiOiLilIwiLCJib3hkUiI6IuKVkiIsImJveERyIjoi4pWTIiwiYm94RFIiOiLilZQiLCJib3hoIjoi4pSAIiwiYm94SCI6IuKVkCIsImJveGhkIjoi4pSsIiwiYm94SGQiOiLilaQiLCJib3hoRCI6IuKVpSIsImJveEhEIjoi4pWmIiwiYm94aHUiOiLilLQiLCJib3hIdSI6IuKVpyIsImJveGhVIjoi4pWoIiwiYm94SFUiOiLilakiLCJib3htaW51cyI6IuKKnyIsImJveHBsdXMiOiLiip4iLCJib3h0aW1lcyI6IuKKoCIsImJveHVsIjoi4pSYIiwiYm94dUwiOiLilZsiLCJib3hVbCI6IuKVnCIsImJveFVMIjoi4pWdIiwiYm94dXIiOiLilJQiLCJib3h1UiI6IuKVmCIsImJveFVyIjoi4pWZIiwiYm94VVIiOiLilZoiLCJib3h2Ijoi4pSCIiwiYm94ViI6IuKVkSIsImJveHZoIjoi4pS8IiwiYm94dkgiOiLilaoiLCJib3hWaCI6IuKVqyIsImJveFZIIjoi4pWsIiwiYm94dmwiOiLilKQiLCJib3h2TCI6IuKVoSIsImJveFZsIjoi4pWiIiwiYm94VkwiOiLilaMiLCJib3h2ciI6IuKUnCIsImJveHZSIjoi4pWeIiwiYm94VnIiOiLilZ8iLCJib3hWUiI6IuKVoCIsImJwcmltZSI6IuKAtSIsImJyZXZlIjoiy5giLCJCcmV2ZSI6IsuYIiwiYnJ2YmFyIjoiwqYiLCJic2NyIjoi8J2StyIsIkJzY3IiOiLihKwiLCJic2VtaSI6IuKBjyIsImJzaW0iOiLiiL0iLCJic2ltZSI6IuKLjSIsImJzb2xiIjoi4qeFIiwiYnNvbCI6IlxcXFwiLCJic29saHN1YiI6IuKfiCIsImJ1bGwiOiLigKIiLCJidWxsZXQiOiLigKIiLCJidW1wIjoi4omOIiwiYnVtcEUiOiLiqq4iLCJidW1wZSI6IuKJjyIsIkJ1bXBlcSI6IuKJjiIsImJ1bXBlcSI6IuKJjyIsIkNhY3V0ZSI6IsSGIiwiY2FjdXRlIjoixIciLCJjYXBhbmQiOiLiqYQiLCJjYXBicmN1cCI6IuKpiSIsImNhcGNhcCI6IuKpiyIsImNhcCI6IuKIqSIsIkNhcCI6IuKLkiIsImNhcGN1cCI6IuKphyIsImNhcGRvdCI6IuKpgCIsIkNhcGl0YWxEaWZmZXJlbnRpYWxEIjoi4oWFIiwiY2FwcyI6IuKIqe+4gCIsImNhcmV0Ijoi4oGBIiwiY2Fyb24iOiLLhyIsIkNheWxleXMiOiLihK0iLCJjY2FwcyI6IuKpjSIsIkNjYXJvbiI6IsSMIiwiY2Nhcm9uIjoixI0iLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiQ2NpcmMiOiLEiCIsImNjaXJjIjoixIkiLCJDY29uaW50Ijoi4oiwIiwiY2N1cHMiOiLiqYwiLCJjY3Vwc3NtIjoi4qmQIiwiQ2RvdCI6IsSKIiwiY2RvdCI6IsSLIiwiY2VkaWwiOiLCuCIsIkNlZGlsbGEiOiLCuCIsImNlbXB0eXYiOiLiprIiLCJjZW50IjoiwqIiLCJjZW50ZXJkb3QiOiLCtyIsIkNlbnRlckRvdCI6IsK3IiwiY2ZyIjoi8J2UoCIsIkNmciI6IuKErSIsIkNIY3kiOiLQpyIsImNoY3kiOiLRhyIsImNoZWNrIjoi4pyTIiwiY2hlY2ttYXJrIjoi4pyTIiwiQ2hpIjoizqciLCJjaGkiOiLPhyIsImNpcmMiOiLLhiIsImNpcmNlcSI6IuKJlyIsImNpcmNsZWFycm93bGVmdCI6IuKGuiIsImNpcmNsZWFycm93cmlnaHQiOiLihrsiLCJjaXJjbGVkYXN0Ijoi4oqbIiwiY2lyY2xlZGNpcmMiOiLiipoiLCJjaXJjbGVkZGFzaCI6IuKKnSIsIkNpcmNsZURvdCI6IuKKmSIsImNpcmNsZWRSIjoiwq4iLCJjaXJjbGVkUyI6IuKTiCIsIkNpcmNsZU1pbnVzIjoi4oqWIiwiQ2lyY2xlUGx1cyI6IuKKlSIsIkNpcmNsZVRpbWVzIjoi4oqXIiwiY2lyIjoi4peLIiwiY2lyRSI6IuKngyIsImNpcmUiOiLiiZciLCJjaXJmbmludCI6IuKokCIsImNpcm1pZCI6IuKrryIsImNpcnNjaXIiOiLip4IiLCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLIiLCJDbG9zZUN1cmx5RG91YmxlUXVvdGUiOiLigJ0iLCJDbG9zZUN1cmx5UXVvdGUiOiLigJkiLCJjbHVicyI6IuKZoyIsImNsdWJzdWl0Ijoi4pmjIiwiY29sb24iOiI6IiwiQ29sb24iOiLiiLciLCJDb2xvbmUiOiLiqbQiLCJjb2xvbmUiOiLiiZQiLCJjb2xvbmVxIjoi4omUIiwiY29tbWEiOiIsIiwiY29tbWF0IjoiQCIsImNvbXAiOiLiiIEiLCJjb21wZm4iOiLiiJgiLCJjb21wbGVtZW50Ijoi4oiBIiwiY29tcGxleGVzIjoi4oSCIiwiY29uZyI6IuKJhSIsImNvbmdkb3QiOiLiqa0iLCJDb25ncnVlbnQiOiLiiaEiLCJjb25pbnQiOiLiiK4iLCJDb25pbnQiOiLiiK8iLCJDb250b3VySW50ZWdyYWwiOiLiiK4iLCJjb3BmIjoi8J2VlCIsIkNvcGYiOiLihIIiLCJjb3Byb2QiOiLiiJAiLCJDb3Byb2R1Y3QiOiLiiJAiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjb3B5c3IiOiLihJciLCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oizIiwiY3JhcnIiOiLihrUiLCJjcm9zcyI6IuKclyIsIkNyb3NzIjoi4qivIiwiQ3NjciI6IvCdkp4iLCJjc2NyIjoi8J2SuCIsImNzdWIiOiLiq48iLCJjc3ViZSI6IuKrkSIsImNzdXAiOiLiq5AiLCJjc3VwZSI6IuKrkiIsImN0ZG90Ijoi4ouvIiwiY3VkYXJybCI6IuKkuCIsImN1ZGFycnIiOiLipLUiLCJjdWVwciI6IuKLniIsImN1ZXNjIjoi4oufIiwiY3VsYXJyIjoi4oa2IiwiY3VsYXJycCI6IuKkvSIsImN1cGJyY2FwIjoi4qmIIiwiY3VwY2FwIjoi4qmGIiwiQ3VwQ2FwIjoi4omNIiwiY3VwIjoi4oiqIiwiQ3VwIjoi4ouTIiwiY3VwY3VwIjoi4qmKIiwiY3VwZG90Ijoi4oqNIiwiY3Vwb3IiOiLiqYUiLCJjdXBzIjoi4oiq77iAIiwiY3VyYXJyIjoi4oa3IiwiY3VyYXJybSI6IuKkvCIsImN1cmx5ZXFwcmVjIjoi4oueIiwiY3VybHllcXN1Y2MiOiLii58iLCJjdXJseXZlZSI6IuKLjiIsImN1cmx5d2VkZ2UiOiLii48iLCJjdXJyZW4iOiLCpCIsImN1cnZlYXJyb3dsZWZ0Ijoi4oa2IiwiY3VydmVhcnJvd3JpZ2h0Ijoi4oa3IiwiY3V2ZWUiOiLii44iLCJjdXdlZCI6IuKLjyIsImN3Y29uaW50Ijoi4oiyIiwiY3dpbnQiOiLiiLEiLCJjeWxjdHkiOiLijK0iLCJkYWdnZXIiOiLigKAiLCJEYWdnZXIiOiLigKEiLCJkYWxldGgiOiLihLgiLCJkYXJyIjoi4oaTIiwiRGFyciI6IuKGoSIsImRBcnIiOiLih5MiLCJkYXNoIjoi4oCQIiwiRGFzaHYiOiLiq6QiLCJkYXNodiI6IuKKoyIsImRia2Fyb3ciOiLipI8iLCJkYmxhYyI6IsudIiwiRGNhcm9uIjoixI4iLCJkY2Fyb24iOiLEjyIsIkRjeSI6ItCUIiwiZGN5Ijoi0LQiLCJkZGFnZ2VyIjoi4oChIiwiZGRhcnIiOiLih4oiLCJERCI6IuKFhSIsImRkIjoi4oWGIiwiRERvdHJhaGQiOiLipJEiLCJkZG90c2VxIjoi4qm3IiwiZGVnIjoiwrAiLCJEZWwiOiLiiIciLCJEZWx0YSI6Is6UIiwiZGVsdGEiOiLOtCIsImRlbXB0eXYiOiLiprEiLCJkZmlzaHQiOiLipb8iLCJEZnIiOiLwnZSHIiwiZGZyIjoi8J2UoSIsImRIYXIiOiLipaUiLCJkaGFybCI6IuKHgyIsImRoYXJyIjoi4oeCIiwiRGlhY3JpdGljYWxBY3V0ZSI6IsK0IiwiRGlhY3JpdGljYWxEb3QiOiLLmSIsIkRpYWNyaXRpY2FsRG91YmxlQWN1dGUiOiLLnSIsIkRpYWNyaXRpY2FsR3JhdmUiOiJgIiwiRGlhY3JpdGljYWxUaWxkZSI6IsucIiwiZGlhbSI6IuKLhCIsImRpYW1vbmQiOiLii4QiLCJEaWFtb25kIjoi4ouEIiwiZGlhbW9uZHN1aXQiOiLimaYiLCJkaWFtcyI6IuKZpiIsImRpZSI6IsKoIiwiRGlmZmVyZW50aWFsRCI6IuKFhiIsImRpZ2FtbWEiOiLPnSIsImRpc2luIjoi4ouyIiwiZGl2Ijoiw7ciLCJkaXZpZGUiOiLDtyIsImRpdmlkZW9udGltZXMiOiLii4ciLCJkaXZvbngiOiLii4ciLCJESmN5Ijoi0IIiLCJkamN5Ijoi0ZIiLCJkbGNvcm4iOiLijJ4iLCJkbGNyb3AiOiLijI0iLCJkb2xsYXIiOiIkIiwiRG9wZiI6IvCdlLsiLCJkb3BmIjoi8J2VlSIsIkRvdCI6IsKoIiwiZG90Ijoiy5kiLCJEb3REb3QiOiLig5wiLCJkb3RlcSI6IuKJkCIsImRvdGVxZG90Ijoi4omRIiwiRG90RXF1YWwiOiLiiZAiLCJkb3RtaW51cyI6IuKIuCIsImRvdHBsdXMiOiLiiJQiLCJkb3RzcXVhcmUiOiLiiqEiLCJkb3VibGViYXJ3ZWRnZSI6IuKMhiIsIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbCI6IuKIryIsIkRvdWJsZURvdCI6IsKoIiwiRG91YmxlRG93bkFycm93Ijoi4oeTIiwiRG91YmxlTGVmdEFycm93Ijoi4oeQIiwiRG91YmxlTGVmdFJpZ2h0QXJyb3ciOiLih5QiLCJEb3VibGVMZWZ0VGVlIjoi4qukIiwiRG91YmxlTG9uZ0xlZnRBcnJvdyI6IuKfuCIsIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKfuiIsIkRvdWJsZUxvbmdSaWdodEFycm93Ijoi4p+5IiwiRG91YmxlUmlnaHRBcnJvdyI6IuKHkiIsIkRvdWJsZVJpZ2h0VGVlIjoi4oqoIiwiRG91YmxlVXBBcnJvdyI6IuKHkSIsIkRvdWJsZVVwRG93bkFycm93Ijoi4oeVIiwiRG91YmxlVmVydGljYWxCYXIiOiLiiKUiLCJEb3duQXJyb3dCYXIiOiLipJMiLCJkb3duYXJyb3ciOiLihpMiLCJEb3duQXJyb3ciOiLihpMiLCJEb3duYXJyb3ciOiLih5MiLCJEb3duQXJyb3dVcEFycm93Ijoi4oe1IiwiRG93bkJyZXZlIjoizJEiLCJkb3duZG93bmFycm93cyI6IuKHiiIsImRvd25oYXJwb29ubGVmdCI6IuKHgyIsImRvd25oYXJwb29ucmlnaHQiOiLih4IiLCJEb3duTGVmdFJpZ2h0VmVjdG9yIjoi4qWQIiwiRG93bkxlZnRUZWVWZWN0b3IiOiLipZ4iLCJEb3duTGVmdFZlY3RvckJhciI6IuKlliIsIkRvd25MZWZ0VmVjdG9yIjoi4oa9IiwiRG93blJpZ2h0VGVlVmVjdG9yIjoi4qWfIiwiRG93blJpZ2h0VmVjdG9yQmFyIjoi4qWXIiwiRG93blJpZ2h0VmVjdG9yIjoi4oeBIiwiRG93blRlZUFycm93Ijoi4oanIiwiRG93blRlZSI6IuKKpCIsImRyYmthcm93Ijoi4qSQIiwiZHJjb3JuIjoi4oyfIiwiZHJjcm9wIjoi4oyMIiwiRHNjciI6IvCdkp8iLCJkc2NyIjoi8J2SuSIsIkRTY3kiOiLQhSIsImRzY3kiOiLRlSIsImRzb2wiOiLip7YiLCJEc3Ryb2siOiLEkCIsImRzdHJvayI6IsSRIiwiZHRkb3QiOiLii7EiLCJkdHJpIjoi4pa/IiwiZHRyaWYiOiLilr4iLCJkdWFyciI6IuKHtSIsImR1aGFyIjoi4qWvIiwiZHdhbmdsZSI6IuKmpiIsIkRaY3kiOiLQjyIsImR6Y3kiOiLRnyIsImR6aWdyYXJyIjoi4p+/IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsImVhc3RlciI6IuKpriIsIkVjYXJvbiI6IsSaIiwiZWNhcm9uIjoixJsiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsImVjaXIiOiLiiZYiLCJlY29sb24iOiLiiZUiLCJFY3kiOiLQrSIsImVjeSI6ItGNIiwiZUREb3QiOiLiqbciLCJFZG90IjoixJYiLCJlZG90IjoixJciLCJlRG90Ijoi4omRIiwiZWUiOiLihYciLCJlZkRvdCI6IuKJkiIsIkVmciI6IvCdlIgiLCJlZnIiOiLwnZSiIiwiZWciOiLiqpoiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiZWdzIjoi4qqWIiwiZWdzZG90Ijoi4qqYIiwiZWwiOiLiqpkiLCJFbGVtZW50Ijoi4oiIIiwiZWxpbnRlcnMiOiLij6ciLCJlbGwiOiLihJMiLCJlbHMiOiLiqpUiLCJlbHNkb3QiOiLiqpciLCJFbWFjciI6IsSSIiwiZW1hY3IiOiLEkyIsImVtcHR5Ijoi4oiFIiwiZW1wdHlzZXQiOiLiiIUiLCJFbXB0eVNtYWxsU3F1YXJlIjoi4pe7IiwiZW1wdHl2Ijoi4oiFIiwiRW1wdHlWZXJ5U21hbGxTcXVhcmUiOiLilqsiLCJlbXNwMTMiOiLigIQiLCJlbXNwMTQiOiLigIUiLCJlbXNwIjoi4oCDIiwiRU5HIjoixYoiLCJlbmciOiLFiyIsImVuc3AiOiLigIIiLCJFb2dvbiI6IsSYIiwiZW9nb24iOiLEmSIsIkVvcGYiOiLwnZS8IiwiZW9wZiI6IvCdlZYiLCJlcGFyIjoi4ouVIiwiZXBhcnNsIjoi4qejIiwiZXBsdXMiOiLiqbEiLCJlcHNpIjoizrUiLCJFcHNpbG9uIjoizpUiLCJlcHNpbG9uIjoizrUiLCJlcHNpdiI6Is+1IiwiZXFjaXJjIjoi4omWIiwiZXFjb2xvbiI6IuKJlSIsImVxc2ltIjoi4omCIiwiZXFzbGFudGd0ciI6IuKqliIsImVxc2xhbnRsZXNzIjoi4qqVIiwiRXF1YWwiOiLiqbUiLCJlcXVhbHMiOiI9IiwiRXF1YWxUaWxkZSI6IuKJgiIsImVxdWVzdCI6IuKJnyIsIkVxdWlsaWJyaXVtIjoi4oeMIiwiZXF1aXYiOiLiiaEiLCJlcXVpdkREIjoi4qm4IiwiZXF2cGFyc2wiOiLip6UiLCJlcmFyciI6IuKlsSIsImVyRG90Ijoi4omTIiwiZXNjciI6IuKEryIsIkVzY3IiOiLihLAiLCJlc2RvdCI6IuKJkCIsIkVzaW0iOiLiqbMiLCJlc2ltIjoi4omCIiwiRXRhIjoizpciLCJldGEiOiLOtyIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJldXJvIjoi4oKsIiwiZXhjbCI6IiEiLCJleGlzdCI6IuKIgyIsIkV4aXN0cyI6IuKIgyIsImV4cGVjdGF0aW9uIjoi4oSwIiwiZXhwb25lbnRpYWxlIjoi4oWHIiwiRXhwb25lbnRpYWxFIjoi4oWHIiwiZmFsbGluZ2RvdHNlcSI6IuKJkiIsIkZjeSI6ItCkIiwiZmN5Ijoi0YQiLCJmZW1hbGUiOiLimYAiLCJmZmlsaWciOiLvrIMiLCJmZmxpZyI6Iu+sgCIsImZmbGxpZyI6Iu+shCIsIkZmciI6IvCdlIkiLCJmZnIiOiLwnZSjIiwiZmlsaWciOiLvrIEiLCJGaWxsZWRTbWFsbFNxdWFyZSI6IuKXvCIsIkZpbGxlZFZlcnlTbWFsbFNxdWFyZSI6IuKWqiIsImZqbGlnIjoiZmoiLCJmbGF0Ijoi4pmtIiwiZmxsaWciOiLvrIIiLCJmbHRucyI6IuKWsSIsImZub2YiOiLGkiIsIkZvcGYiOiLwnZS9IiwiZm9wZiI6IvCdlZciLCJmb3JhbGwiOiLiiIAiLCJGb3JBbGwiOiLiiIAiLCJmb3JrIjoi4ouUIiwiZm9ya3YiOiLiq5kiLCJGb3VyaWVydHJmIjoi4oSxIiwiZnBhcnRpbnQiOiLiqI0iLCJmcmFjMTIiOiLCvSIsImZyYWMxMyI6IuKFkyIsImZyYWMxNCI6IsK8IiwiZnJhYzE1Ijoi4oWVIiwiZnJhYzE2Ijoi4oWZIiwiZnJhYzE4Ijoi4oWbIiwiZnJhYzIzIjoi4oWUIiwiZnJhYzI1Ijoi4oWWIiwiZnJhYzM0Ijoiwr4iLCJmcmFjMzUiOiLihZciLCJmcmFjMzgiOiLihZwiLCJmcmFjNDUiOiLihZgiLCJmcmFjNTYiOiLihZoiLCJmcmFjNTgiOiLihZ0iLCJmcmFjNzgiOiLihZ4iLCJmcmFzbCI6IuKBhCIsImZyb3duIjoi4oyiIiwiZnNjciI6IvCdkrsiLCJGc2NyIjoi4oSxIiwiZ2FjdXRlIjoix7UiLCJHYW1tYSI6Is6TIiwiZ2FtbWEiOiLOsyIsIkdhbW1hZCI6Is+cIiwiZ2FtbWFkIjoiz50iLCJnYXAiOiLiqoYiLCJHYnJldmUiOiLEniIsImdicmV2ZSI6IsSfIiwiR2NlZGlsIjoixKIiLCJHY2lyYyI6IsScIiwiZ2NpcmMiOiLEnSIsIkdjeSI6ItCTIiwiZ2N5Ijoi0LMiLCJHZG90IjoixKAiLCJnZG90IjoixKEiLCJnZSI6IuKJpSIsImdFIjoi4omnIiwiZ0VsIjoi4qqMIiwiZ2VsIjoi4oubIiwiZ2VxIjoi4omlIiwiZ2VxcSI6IuKJpyIsImdlcXNsYW50Ijoi4qm+IiwiZ2VzY2MiOiLiqqkiLCJnZXMiOiLiqb4iLCJnZXNkb3QiOiLiqoAiLCJnZXNkb3RvIjoi4qqCIiwiZ2VzZG90b2wiOiLiqoQiLCJnZXNsIjoi4oub77iAIiwiZ2VzbGVzIjoi4qqUIiwiR2ZyIjoi8J2UiiIsImdmciI6IvCdlKQiLCJnZyI6IuKJqyIsIkdnIjoi4ouZIiwiZ2dnIjoi4ouZIiwiZ2ltZWwiOiLihLciLCJHSmN5Ijoi0IMiLCJnamN5Ijoi0ZMiLCJnbGEiOiLiqqUiLCJnbCI6IuKJtyIsImdsRSI6IuKqkiIsImdsaiI6IuKqpCIsImduYXAiOiLiqooiLCJnbmFwcHJveCI6IuKqiiIsImduZSI6IuKqiCIsImduRSI6IuKJqSIsImduZXEiOiLiqogiLCJnbmVxcSI6IuKJqSIsImduc2ltIjoi4ounIiwiR29wZiI6IvCdlL4iLCJnb3BmIjoi8J2VmCIsImdyYXZlIjoiYCIsIkdyZWF0ZXJFcXVhbCI6IuKJpSIsIkdyZWF0ZXJFcXVhbExlc3MiOiLii5siLCJHcmVhdGVyRnVsbEVxdWFsIjoi4omnIiwiR3JlYXRlckdyZWF0ZXIiOiLiqqIiLCJHcmVhdGVyTGVzcyI6IuKJtyIsIkdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+IiwiR3JlYXRlclRpbGRlIjoi4omzIiwiR3NjciI6IvCdkqIiLCJnc2NyIjoi4oSKIiwiZ3NpbSI6IuKJsyIsImdzaW1lIjoi4qqOIiwiZ3NpbWwiOiLiqpAiLCJndGNjIjoi4qqnIiwiZ3RjaXIiOiLiqboiLCJndCI6Ij4iLCJHVCI6Ij4iLCJHdCI6IuKJqyIsImd0ZG90Ijoi4ouXIiwiZ3RsUGFyIjoi4qaVIiwiZ3RxdWVzdCI6IuKpvCIsImd0cmFwcHJveCI6IuKqhiIsImd0cmFyciI6IuKluCIsImd0cmRvdCI6IuKLlyIsImd0cmVxbGVzcyI6IuKLmyIsImd0cmVxcWxlc3MiOiLiqowiLCJndHJsZXNzIjoi4om3IiwiZ3Ryc2ltIjoi4omzIiwiZ3ZlcnRuZXFxIjoi4omp77iAIiwiZ3ZuRSI6IuKJqe+4gCIsIkhhY2VrIjoiy4ciLCJoYWlyc3AiOiLigIoiLCJoYWxmIjoiwr0iLCJoYW1pbHQiOiLihIsiLCJIQVJEY3kiOiLQqiIsImhhcmRjeSI6ItGKIiwiaGFycmNpciI6IuKliCIsImhhcnIiOiLihpQiLCJoQXJyIjoi4oeUIiwiaGFycnciOiLihq0iLCJIYXQiOiJeIiwiaGJhciI6IuKEjyIsIkhjaXJjIjoixKQiLCJoY2lyYyI6IsSlIiwiaGVhcnRzIjoi4pmlIiwiaGVhcnRzdWl0Ijoi4pmlIiwiaGVsbGlwIjoi4oCmIiwiaGVyY29uIjoi4oq5IiwiaGZyIjoi8J2UpSIsIkhmciI6IuKEjCIsIkhpbGJlcnRTcGFjZSI6IuKEiyIsImhrc2Vhcm93Ijoi4qSlIiwiaGtzd2Fyb3ciOiLipKYiLCJob2FyciI6IuKHvyIsImhvbXRodCI6IuKIuyIsImhvb2tsZWZ0YXJyb3ciOiLihqkiLCJob29rcmlnaHRhcnJvdyI6IuKGqiIsImhvcGYiOiLwnZWZIiwiSG9wZiI6IuKEjSIsImhvcmJhciI6IuKAlSIsIkhvcml6b250YWxMaW5lIjoi4pSAIiwiaHNjciI6IvCdkr0iLCJIc2NyIjoi4oSLIiwiaHNsYXNoIjoi4oSPIiwiSHN0cm9rIjoixKYiLCJoc3Ryb2siOiLEpyIsIkh1bXBEb3duSHVtcCI6IuKJjiIsIkh1bXBFcXVhbCI6IuKJjyIsImh5YnVsbCI6IuKBgyIsImh5cGhlbiI6IuKAkCIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJpYyI6IuKBoyIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiSWN5Ijoi0JgiLCJpY3kiOiLQuCIsIklkb3QiOiLEsCIsIklFY3kiOiLQlSIsImllY3kiOiLQtSIsImlleGNsIjoiwqEiLCJpZmYiOiLih5QiLCJpZnIiOiLwnZSmIiwiSWZyIjoi4oSRIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlpIjoi4oWIIiwiaWlpaW50Ijoi4qiMIiwiaWlpbnQiOiLiiK0iLCJpaW5maW4iOiLip5wiLCJpaW90YSI6IuKEqSIsIklKbGlnIjoixLIiLCJpamxpZyI6IsSzIiwiSW1hY3IiOiLEqiIsImltYWNyIjoixKsiLCJpbWFnZSI6IuKEkSIsIkltYWdpbmFyeUkiOiLihYgiLCJpbWFnbGluZSI6IuKEkCIsImltYWdwYXJ0Ijoi4oSRIiwiaW1hdGgiOiLEsSIsIkltIjoi4oSRIiwiaW1vZiI6IuKKtyIsImltcGVkIjoixrUiLCJJbXBsaWVzIjoi4oeSIiwiaW5jYXJlIjoi4oSFIiwiaW4iOiLiiIgiLCJpbmZpbiI6IuKIniIsImluZmludGllIjoi4qedIiwiaW5vZG90IjoixLEiLCJpbnRjYWwiOiLiiroiLCJpbnQiOiLiiKsiLCJJbnQiOiLiiKwiLCJpbnRlZ2VycyI6IuKEpCIsIkludGVncmFsIjoi4oirIiwiaW50ZXJjYWwiOiLiiroiLCJJbnRlcnNlY3Rpb24iOiLii4IiLCJpbnRsYXJoayI6IuKolyIsImludHByb2QiOiLiqLwiLCJJbnZpc2libGVDb21tYSI6IuKBoyIsIkludmlzaWJsZVRpbWVzIjoi4oGiIiwiSU9jeSI6ItCBIiwiaW9jeSI6ItGRIiwiSW9nb24iOiLEriIsImlvZ29uIjoixK8iLCJJb3BmIjoi8J2VgCIsImlvcGYiOiLwnZWaIiwiSW90YSI6Is6ZIiwiaW90YSI6Is65IiwiaXByb2QiOiLiqLwiLCJpcXVlc3QiOiLCvyIsImlzY3IiOiLwnZK+IiwiSXNjciI6IuKEkCIsImlzaW4iOiLiiIgiLCJpc2luZG90Ijoi4ou1IiwiaXNpbkUiOiLii7kiLCJpc2lucyI6IuKLtCIsImlzaW5zdiI6IuKLsyIsImlzaW52Ijoi4oiIIiwiaXQiOiLigaIiLCJJdGlsZGUiOiLEqCIsIml0aWxkZSI6IsSpIiwiSXVrY3kiOiLQhiIsIml1a2N5Ijoi0ZYiLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJKY2lyYyI6IsS0IiwiamNpcmMiOiLEtSIsIkpjeSI6ItCZIiwiamN5Ijoi0LkiLCJKZnIiOiLwnZSNIiwiamZyIjoi8J2UpyIsImptYXRoIjoiyLciLCJKb3BmIjoi8J2VgSIsImpvcGYiOiLwnZWbIiwiSnNjciI6IvCdkqUiLCJqc2NyIjoi8J2SvyIsIkpzZXJjeSI6ItCIIiwianNlcmN5Ijoi0ZgiLCJKdWtjeSI6ItCEIiwianVrY3kiOiLRlCIsIkthcHBhIjoizpoiLCJrYXBwYSI6Is66Iiwia2FwcGF2Ijoiz7AiLCJLY2VkaWwiOiLEtiIsImtjZWRpbCI6IsS3IiwiS2N5Ijoi0JoiLCJrY3kiOiLQuiIsIktmciI6IvCdlI4iLCJrZnIiOiLwnZSoIiwia2dyZWVuIjoixLgiLCJLSGN5Ijoi0KUiLCJraGN5Ijoi0YUiLCJLSmN5Ijoi0IwiLCJramN5Ijoi0ZwiLCJLb3BmIjoi8J2VgiIsImtvcGYiOiLwnZWcIiwiS3NjciI6IvCdkqYiLCJrc2NyIjoi8J2TgCIsImxBYXJyIjoi4oeaIiwiTGFjdXRlIjoixLkiLCJsYWN1dGUiOiLEuiIsImxhZW1wdHl2Ijoi4qa0IiwibGFncmFuIjoi4oSSIiwiTGFtYmRhIjoizpsiLCJsYW1iZGEiOiLOuyIsImxhbmciOiLin6giLCJMYW5nIjoi4p+qIiwibGFuZ2QiOiLippEiLCJsYW5nbGUiOiLin6giLCJsYXAiOiLiqoUiLCJMYXBsYWNldHJmIjoi4oSSIiwibGFxdW8iOiLCqyIsImxhcnJiIjoi4oekIiwibGFycmJmcyI6IuKknyIsImxhcnIiOiLihpAiLCJMYXJyIjoi4oaeIiwibEFyciI6IuKHkCIsImxhcnJmcyI6IuKknSIsImxhcnJoayI6IuKGqSIsImxhcnJscCI6IuKGqyIsImxhcnJwbCI6IuKkuSIsImxhcnJzaW0iOiLipbMiLCJsYXJydGwiOiLihqIiLCJsYXRhaWwiOiLipJkiLCJsQXRhaWwiOiLipJsiLCJsYXQiOiLiqqsiLCJsYXRlIjoi4qqtIiwibGF0ZXMiOiLiqq3vuIAiLCJsYmFyciI6IuKkjCIsImxCYXJyIjoi4qSOIiwibGJicmsiOiLinbIiLCJsYnJhY2UiOiJ7IiwibGJyYWNrIjoiWyIsImxicmtlIjoi4qaLIiwibGJya3NsZCI6IuKmjyIsImxicmtzbHUiOiLipo0iLCJMY2Fyb24iOiLEvSIsImxjYXJvbiI6IsS+IiwiTGNlZGlsIjoixLsiLCJsY2VkaWwiOiLEvCIsImxjZWlsIjoi4oyIIiwibGN1YiI6InsiLCJMY3kiOiLQmyIsImxjeSI6ItC7IiwibGRjYSI6IuKktiIsImxkcXVvIjoi4oCcIiwibGRxdW9yIjoi4oCeIiwibGRyZGhhciI6IuKlpyIsImxkcnVzaGFyIjoi4qWLIiwibGRzaCI6IuKGsiIsImxlIjoi4omkIiwibEUiOiLiiaYiLCJMZWZ0QW5nbGVCcmFja2V0Ijoi4p+oIiwiTGVmdEFycm93QmFyIjoi4oekIiwibGVmdGFycm93Ijoi4oaQIiwiTGVmdEFycm93Ijoi4oaQIiwiTGVmdGFycm93Ijoi4oeQIiwiTGVmdEFycm93UmlnaHRBcnJvdyI6IuKHhiIsImxlZnRhcnJvd3RhaWwiOiLihqIiLCJMZWZ0Q2VpbGluZyI6IuKMiCIsIkxlZnREb3VibGVCcmFja2V0Ijoi4p+mIiwiTGVmdERvd25UZWVWZWN0b3IiOiLipaEiLCJMZWZ0RG93blZlY3RvckJhciI6IuKlmSIsIkxlZnREb3duVmVjdG9yIjoi4oeDIiwiTGVmdEZsb29yIjoi4oyKIiwibGVmdGhhcnBvb25kb3duIjoi4oa9IiwibGVmdGhhcnBvb251cCI6IuKGvCIsImxlZnRsZWZ0YXJyb3dzIjoi4oeHIiwibGVmdHJpZ2h0YXJyb3ciOiLihpQiLCJMZWZ0UmlnaHRBcnJvdyI6IuKGlCIsIkxlZnRyaWdodGFycm93Ijoi4oeUIiwibGVmdHJpZ2h0YXJyb3dzIjoi4oeGIiwibGVmdHJpZ2h0aGFycG9vbnMiOiLih4siLCJsZWZ0cmlnaHRzcXVpZ2Fycm93Ijoi4oatIiwiTGVmdFJpZ2h0VmVjdG9yIjoi4qWOIiwiTGVmdFRlZUFycm93Ijoi4oakIiwiTGVmdFRlZSI6IuKKoyIsIkxlZnRUZWVWZWN0b3IiOiLipZoiLCJsZWZ0dGhyZWV0aW1lcyI6IuKLiyIsIkxlZnRUcmlhbmdsZUJhciI6IuKnjyIsIkxlZnRUcmlhbmdsZSI6IuKKsiIsIkxlZnRUcmlhbmdsZUVxdWFsIjoi4oq0IiwiTGVmdFVwRG93blZlY3RvciI6IuKlkSIsIkxlZnRVcFRlZVZlY3RvciI6IuKloCIsIkxlZnRVcFZlY3RvckJhciI6IuKlmCIsIkxlZnRVcFZlY3RvciI6IuKGvyIsIkxlZnRWZWN0b3JCYXIiOiLipZIiLCJMZWZ0VmVjdG9yIjoi4oa8IiwibEVnIjoi4qqLIiwibGVnIjoi4ouaIiwibGVxIjoi4omkIiwibGVxcSI6IuKJpiIsImxlcXNsYW50Ijoi4qm9IiwibGVzY2MiOiLiqqgiLCJsZXMiOiLiqb0iLCJsZXNkb3QiOiLiqb8iLCJsZXNkb3RvIjoi4qqBIiwibGVzZG90b3IiOiLiqoMiLCJsZXNnIjoi4oua77iAIiwibGVzZ2VzIjoi4qqTIiwibGVzc2FwcHJveCI6IuKqhSIsImxlc3Nkb3QiOiLii5YiLCJsZXNzZXFndHIiOiLii5oiLCJsZXNzZXFxZ3RyIjoi4qqLIiwiTGVzc0VxdWFsR3JlYXRlciI6IuKLmiIsIkxlc3NGdWxsRXF1YWwiOiLiiaYiLCJMZXNzR3JlYXRlciI6IuKJtiIsImxlc3NndHIiOiLiibYiLCJMZXNzTGVzcyI6IuKqoSIsImxlc3NzaW0iOiLiibIiLCJMZXNzU2xhbnRFcXVhbCI6IuKpvSIsIkxlc3NUaWxkZSI6IuKJsiIsImxmaXNodCI6IuKlvCIsImxmbG9vciI6IuKMiiIsIkxmciI6IvCdlI8iLCJsZnIiOiLwnZSpIiwibGciOiLiibYiLCJsZ0UiOiLiqpEiLCJsSGFyIjoi4qWiIiwibGhhcmQiOiLihr0iLCJsaGFydSI6IuKGvCIsImxoYXJ1bCI6IuKlqiIsImxoYmxrIjoi4paEIiwiTEpjeSI6ItCJIiwibGpjeSI6ItGZIiwibGxhcnIiOiLih4ciLCJsbCI6IuKJqiIsIkxsIjoi4ouYIiwibGxjb3JuZXIiOiLijJ4iLCJMbGVmdGFycm93Ijoi4oeaIiwibGxoYXJkIjoi4qWrIiwibGx0cmkiOiLil7oiLCJMbWlkb3QiOiLEvyIsImxtaWRvdCI6IsWAIiwibG1vdXN0YWNoZSI6IuKOsCIsImxtb3VzdCI6IuKOsCIsImxuYXAiOiLiqokiLCJsbmFwcHJveCI6IuKqiSIsImxuZSI6IuKqhyIsImxuRSI6IuKJqCIsImxuZXEiOiLiqociLCJsbmVxcSI6IuKJqCIsImxuc2ltIjoi4oumIiwibG9hbmciOiLin6wiLCJsb2FyciI6IuKHvSIsImxvYnJrIjoi4p+mIiwibG9uZ2xlZnRhcnJvdyI6IuKftSIsIkxvbmdMZWZ0QXJyb3ciOiLin7UiLCJMb25nbGVmdGFycm93Ijoi4p+4IiwibG9uZ2xlZnRyaWdodGFycm93Ijoi4p+3IiwiTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+3IiwiTG9uZ2xlZnRyaWdodGFycm93Ijoi4p+6IiwibG9uZ21hcHN0byI6IuKfvCIsImxvbmdyaWdodGFycm93Ijoi4p+2IiwiTG9uZ1JpZ2h0QXJyb3ciOiLin7YiLCJMb25ncmlnaHRhcnJvdyI6IuKfuSIsImxvb3BhcnJvd2xlZnQiOiLihqsiLCJsb29wYXJyb3dyaWdodCI6IuKGrCIsImxvcGFyIjoi4qaFIiwiTG9wZiI6IvCdlYMiLCJsb3BmIjoi8J2VnSIsImxvcGx1cyI6IuKorSIsImxvdGltZXMiOiLiqLQiLCJsb3dhc3QiOiLiiJciLCJsb3diYXIiOiJfIiwiTG93ZXJMZWZ0QXJyb3ciOiLihpkiLCJMb3dlclJpZ2h0QXJyb3ciOiLihpgiLCJsb3oiOiLil4oiLCJsb3plbmdlIjoi4peKIiwibG96ZiI6IuKnqyIsImxwYXIiOiIoIiwibHBhcmx0Ijoi4qaTIiwibHJhcnIiOiLih4YiLCJscmNvcm5lciI6IuKMnyIsImxyaGFyIjoi4oeLIiwibHJoYXJkIjoi4qWtIiwibHJtIjoi4oCOIiwibHJ0cmkiOiLiir8iLCJsc2FxdW8iOiLigLkiLCJsc2NyIjoi8J2TgSIsIkxzY3IiOiLihJIiLCJsc2giOiLihrAiLCJMc2giOiLihrAiLCJsc2ltIjoi4omyIiwibHNpbWUiOiLiqo0iLCJsc2ltZyI6IuKqjyIsImxzcWIiOiJbIiwibHNxdW8iOiLigJgiLCJsc3F1b3IiOiLigJoiLCJMc3Ryb2siOiLFgSIsImxzdHJvayI6IsWCIiwibHRjYyI6IuKqpiIsImx0Y2lyIjoi4qm5IiwibHQiOiI8IiwiTFQiOiI8IiwiTHQiOiLiiaoiLCJsdGRvdCI6IuKLliIsImx0aHJlZSI6IuKLiyIsImx0aW1lcyI6IuKLiSIsImx0bGFyciI6IuKltiIsImx0cXVlc3QiOiLiqbsiLCJsdHJpIjoi4peDIiwibHRyaWUiOiLiirQiLCJsdHJpZiI6IuKXgiIsImx0clBhciI6IuKmliIsImx1cmRzaGFyIjoi4qWKIiwibHVydWhhciI6IuKlpiIsImx2ZXJ0bmVxcSI6IuKJqO+4gCIsImx2bkUiOiLiiajvuIAiLCJtYWNyIjoiwq8iLCJtYWxlIjoi4pmCIiwibWFsdCI6IuKcoCIsIm1hbHRlc2UiOiLinKAiLCJNYXAiOiLipIUiLCJtYXAiOiLihqYiLCJtYXBzdG8iOiLihqYiLCJtYXBzdG9kb3duIjoi4oanIiwibWFwc3RvbGVmdCI6IuKGpCIsIm1hcHN0b3VwIjoi4oalIiwibWFya2VyIjoi4pauIiwibWNvbW1hIjoi4qipIiwiTWN5Ijoi0JwiLCJtY3kiOiLQvCIsIm1kYXNoIjoi4oCUIiwibUREb3QiOiLiiLoiLCJtZWFzdXJlZGFuZ2xlIjoi4oihIiwiTWVkaXVtU3BhY2UiOiLigZ8iLCJNZWxsaW50cmYiOiLihLMiLCJNZnIiOiLwnZSQIiwibWZyIjoi8J2UqiIsIm1obyI6IuKEpyIsIm1pY3JvIjoiwrUiLCJtaWRhc3QiOiIqIiwibWlkY2lyIjoi4quwIiwibWlkIjoi4oijIiwibWlkZG90IjoiwrciLCJtaW51c2IiOiLiip8iLCJtaW51cyI6IuKIkiIsIm1pbnVzZCI6IuKIuCIsIm1pbnVzZHUiOiLiqKoiLCJNaW51c1BsdXMiOiLiiJMiLCJtbGNwIjoi4qubIiwibWxkciI6IuKApiIsIm1ucGx1cyI6IuKIkyIsIm1vZGVscyI6IuKKpyIsIk1vcGYiOiLwnZWEIiwibW9wZiI6IvCdlZ4iLCJtcCI6IuKIkyIsIm1zY3IiOiLwnZOCIiwiTXNjciI6IuKEsyIsIm1zdHBvcyI6IuKIviIsIk11IjoizpwiLCJtdSI6Is68IiwibXVsdGltYXAiOiLiirgiLCJtdW1hcCI6IuKKuCIsIm5hYmxhIjoi4oiHIiwiTmFjdXRlIjoixYMiLCJuYWN1dGUiOiLFhCIsIm5hbmciOiLiiKDig5IiLCJuYXAiOiLiiYkiLCJuYXBFIjoi4qmwzLgiLCJuYXBpZCI6IuKJi8y4IiwibmFwb3MiOiLFiSIsIm5hcHByb3giOiLiiYkiLCJuYXR1cmFsIjoi4pmuIiwibmF0dXJhbHMiOiLihJUiLCJuYXR1ciI6IuKZriIsIm5ic3AiOiLCoCIsIm5idW1wIjoi4omOzLgiLCJuYnVtcGUiOiLiiY/MuCIsIm5jYXAiOiLiqYMiLCJOY2Fyb24iOiLFhyIsIm5jYXJvbiI6IsWIIiwiTmNlZGlsIjoixYUiLCJuY2VkaWwiOiLFhiIsIm5jb25nIjoi4omHIiwibmNvbmdkb3QiOiLiqa3MuCIsIm5jdXAiOiLiqYIiLCJOY3kiOiLQnSIsIm5jeSI6ItC9IiwibmRhc2giOiLigJMiLCJuZWFyaGsiOiLipKQiLCJuZWFyciI6IuKGlyIsIm5lQXJyIjoi4oeXIiwibmVhcnJvdyI6IuKGlyIsIm5lIjoi4omgIiwibmVkb3QiOiLiiZDMuCIsIk5lZ2F0aXZlTWVkaXVtU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaWNrU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaW5TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZSI6IuKAiyIsIm5lcXVpdiI6IuKJoiIsIm5lc2VhciI6IuKkqCIsIm5lc2ltIjoi4omCzLgiLCJOZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKJqyIsIk5lc3RlZExlc3NMZXNzIjoi4omqIiwiTmV3TGluZSI6IlxcbiIsIm5leGlzdCI6IuKIhCIsIm5leGlzdHMiOiLiiIQiLCJOZnIiOiLwnZSRIiwibmZyIjoi8J2UqyIsIm5nRSI6IuKJp8y4IiwibmdlIjoi4omxIiwibmdlcSI6IuKJsSIsIm5nZXFxIjoi4omnzLgiLCJuZ2Vxc2xhbnQiOiLiqb7MuCIsIm5nZXMiOiLiqb7MuCIsIm5HZyI6IuKLmcy4IiwibmdzaW0iOiLiibUiLCJuR3QiOiLiiavig5IiLCJuZ3QiOiLiia8iLCJuZ3RyIjoi4omvIiwibkd0diI6IuKJq8y4IiwibmhhcnIiOiLihq4iLCJuaEFyciI6IuKHjiIsIm5ocGFyIjoi4quyIiwibmkiOiLiiIsiLCJuaXMiOiLii7wiLCJuaXNkIjoi4ou6Iiwibml2Ijoi4oiLIiwiTkpjeSI6ItCKIiwibmpjeSI6ItGaIiwibmxhcnIiOiLihpoiLCJubEFyciI6IuKHjSIsIm5sZHIiOiLigKUiLCJubEUiOiLiiabMuCIsIm5sZSI6IuKJsCIsIm5sZWZ0YXJyb3ciOiLihpoiLCJuTGVmdGFycm93Ijoi4oeNIiwibmxlZnRyaWdodGFycm93Ijoi4oauIiwibkxlZnRyaWdodGFycm93Ijoi4oeOIiwibmxlcSI6IuKJsCIsIm5sZXFxIjoi4ommzLgiLCJubGVxc2xhbnQiOiLiqb3MuCIsIm5sZXMiOiLiqb3MuCIsIm5sZXNzIjoi4omuIiwibkxsIjoi4ouYzLgiLCJubHNpbSI6IuKJtCIsIm5MdCI6IuKJquKDkiIsIm5sdCI6IuKJriIsIm5sdHJpIjoi4ouqIiwibmx0cmllIjoi4ousIiwibkx0diI6IuKJqsy4Iiwibm1pZCI6IuKIpCIsIk5vQnJlYWsiOiLigaAiLCJOb25CcmVha2luZ1NwYWNlIjoiwqAiLCJub3BmIjoi8J2VnyIsIk5vcGYiOiLihJUiLCJOb3QiOiLiq6wiLCJub3QiOiLCrCIsIk5vdENvbmdydWVudCI6IuKJoiIsIk5vdEN1cENhcCI6IuKJrSIsIk5vdERvdWJsZVZlcnRpY2FsQmFyIjoi4oimIiwiTm90RWxlbWVudCI6IuKIiSIsIk5vdEVxdWFsIjoi4omgIiwiTm90RXF1YWxUaWxkZSI6IuKJgsy4IiwiTm90RXhpc3RzIjoi4oiEIiwiTm90R3JlYXRlciI6IuKJryIsIk5vdEdyZWF0ZXJFcXVhbCI6IuKJsSIsIk5vdEdyZWF0ZXJGdWxsRXF1YWwiOiLiiafMuCIsIk5vdEdyZWF0ZXJHcmVhdGVyIjoi4omrzLgiLCJOb3RHcmVhdGVyTGVzcyI6IuKJuSIsIk5vdEdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+zLgiLCJOb3RHcmVhdGVyVGlsZGUiOiLiibUiLCJOb3RIdW1wRG93bkh1bXAiOiLiiY7MuCIsIk5vdEh1bXBFcXVhbCI6IuKJj8y4Iiwibm90aW4iOiLiiIkiLCJub3RpbmRvdCI6IuKLtcy4Iiwibm90aW5FIjoi4ou5zLgiLCJub3RpbnZhIjoi4oiJIiwibm90aW52YiI6IuKLtyIsIm5vdGludmMiOiLii7YiLCJOb3RMZWZ0VHJpYW5nbGVCYXIiOiLip4/MuCIsIk5vdExlZnRUcmlhbmdsZSI6IuKLqiIsIk5vdExlZnRUcmlhbmdsZUVxdWFsIjoi4ousIiwiTm90TGVzcyI6IuKJriIsIk5vdExlc3NFcXVhbCI6IuKJsCIsIk5vdExlc3NHcmVhdGVyIjoi4om4IiwiTm90TGVzc0xlc3MiOiLiiarMuCIsIk5vdExlc3NTbGFudEVxdWFsIjoi4qm9zLgiLCJOb3RMZXNzVGlsZGUiOiLiibQiLCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKqosy4IiwiTm90TmVzdGVkTGVzc0xlc3MiOiLiqqHMuCIsIm5vdG5pIjoi4oiMIiwibm90bml2YSI6IuKIjCIsIm5vdG5pdmIiOiLii74iLCJub3RuaXZjIjoi4ou9IiwiTm90UHJlY2VkZXMiOiLiioAiLCJOb3RQcmVjZWRlc0VxdWFsIjoi4qqvzLgiLCJOb3RQcmVjZWRlc1NsYW50RXF1YWwiOiLii6AiLCJOb3RSZXZlcnNlRWxlbWVudCI6IuKIjCIsIk5vdFJpZ2h0VHJpYW5nbGVCYXIiOiLip5DMuCIsIk5vdFJpZ2h0VHJpYW5nbGUiOiLii6siLCJOb3RSaWdodFRyaWFuZ2xlRXF1YWwiOiLii60iLCJOb3RTcXVhcmVTdWJzZXQiOiLiio/MuCIsIk5vdFNxdWFyZVN1YnNldEVxdWFsIjoi4ouiIiwiTm90U3F1YXJlU3VwZXJzZXQiOiLiipDMuCIsIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWwiOiLii6MiLCJOb3RTdWJzZXQiOiLiioLig5IiLCJOb3RTdWJzZXRFcXVhbCI6IuKKiCIsIk5vdFN1Y2NlZWRzIjoi4oqBIiwiTm90U3VjY2VlZHNFcXVhbCI6IuKqsMy4IiwiTm90U3VjY2VlZHNTbGFudEVxdWFsIjoi4ouhIiwiTm90U3VjY2VlZHNUaWxkZSI6IuKJv8y4IiwiTm90U3VwZXJzZXQiOiLiioPig5IiLCJOb3RTdXBlcnNldEVxdWFsIjoi4oqJIiwiTm90VGlsZGUiOiLiiYEiLCJOb3RUaWxkZUVxdWFsIjoi4omEIiwiTm90VGlsZGVGdWxsRXF1YWwiOiLiiYciLCJOb3RUaWxkZVRpbGRlIjoi4omJIiwiTm90VmVydGljYWxCYXIiOiLiiKQiLCJucGFyYWxsZWwiOiLiiKYiLCJucGFyIjoi4oimIiwibnBhcnNsIjoi4qu94oOlIiwibnBhcnQiOiLiiILMuCIsIm5wb2xpbnQiOiLiqJQiLCJucHIiOiLiioAiLCJucHJjdWUiOiLii6AiLCJucHJlYyI6IuKKgCIsIm5wcmVjZXEiOiLiqq/MuCIsIm5wcmUiOiLiqq/MuCIsIm5yYXJyYyI6IuKks8y4IiwibnJhcnIiOiLihpsiLCJuckFyciI6IuKHjyIsIm5yYXJydyI6IuKGncy4IiwibnJpZ2h0YXJyb3ciOiLihpsiLCJuUmlnaHRhcnJvdyI6IuKHjyIsIm5ydHJpIjoi4ourIiwibnJ0cmllIjoi4outIiwibnNjIjoi4oqBIiwibnNjY3VlIjoi4ouhIiwibnNjZSI6IuKqsMy4IiwiTnNjciI6IvCdkqkiLCJuc2NyIjoi8J2TgyIsIm5zaG9ydG1pZCI6IuKIpCIsIm5zaG9ydHBhcmFsbGVsIjoi4oimIiwibnNpbSI6IuKJgSIsIm5zaW1lIjoi4omEIiwibnNpbWVxIjoi4omEIiwibnNtaWQiOiLiiKQiLCJuc3BhciI6IuKIpiIsIm5zcXN1YmUiOiLii6IiLCJuc3FzdXBlIjoi4oujIiwibnN1YiI6IuKKhCIsIm5zdWJFIjoi4quFzLgiLCJuc3ViZSI6IuKKiCIsIm5zdWJzZXQiOiLiioLig5IiLCJuc3Vic2V0ZXEiOiLiiogiLCJuc3Vic2V0ZXFxIjoi4quFzLgiLCJuc3VjYyI6IuKKgSIsIm5zdWNjZXEiOiLiqrDMuCIsIm5zdXAiOiLiioUiLCJuc3VwRSI6IuKrhsy4IiwibnN1cGUiOiLiiokiLCJuc3Vwc2V0Ijoi4oqD4oOSIiwibnN1cHNldGVxIjoi4oqJIiwibnN1cHNldGVxcSI6IuKrhsy4IiwibnRnbCI6IuKJuSIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJudGxnIjoi4om4IiwibnRyaWFuZ2xlbGVmdCI6IuKLqiIsIm50cmlhbmdsZWxlZnRlcSI6IuKLrCIsIm50cmlhbmdsZXJpZ2h0Ijoi4ourIiwibnRyaWFuZ2xlcmlnaHRlcSI6IuKLrSIsIk51Ijoizp0iLCJudSI6Is69IiwibnVtIjoiIyIsIm51bWVybyI6IuKEliIsIm51bXNwIjoi4oCHIiwibnZhcCI6IuKJjeKDkiIsIm52ZGFzaCI6IuKKrCIsIm52RGFzaCI6IuKKrSIsIm5WZGFzaCI6IuKKriIsIm5WRGFzaCI6IuKKryIsIm52Z2UiOiLiiaXig5IiLCJudmd0IjoiPuKDkiIsIm52SGFyciI6IuKkhCIsIm52aW5maW4iOiLip54iLCJudmxBcnIiOiLipIIiLCJudmxlIjoi4omk4oOSIiwibnZsdCI6Ijzig5IiLCJudmx0cmllIjoi4oq04oOSIiwibnZyQXJyIjoi4qSDIiwibnZydHJpZSI6IuKKteKDkiIsIm52c2ltIjoi4oi84oOSIiwibndhcmhrIjoi4qSjIiwibndhcnIiOiLihpYiLCJud0FyciI6IuKHliIsIm53YXJyb3ciOiLihpYiLCJud25lYXIiOiLipKciLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwib2FzdCI6IuKKmyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0Iiwib2NpciI6IuKKmiIsIk9jeSI6ItCeIiwib2N5Ijoi0L4iLCJvZGFzaCI6IuKKnSIsIk9kYmxhYyI6IsWQIiwib2RibGFjIjoixZEiLCJvZGl2Ijoi4qi4Iiwib2RvdCI6IuKKmSIsIm9kc29sZCI6IuKmvCIsIk9FbGlnIjoixZIiLCJvZWxpZyI6IsWTIiwib2ZjaXIiOiLipr8iLCJPZnIiOiLwnZSSIiwib2ZyIjoi8J2UrCIsIm9nb24iOiLLmyIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvZ3QiOiLip4EiLCJvaGJhciI6IuKmtSIsIm9obSI6Is6pIiwib2ludCI6IuKIriIsIm9sYXJyIjoi4oa6Iiwib2xjaXIiOiLipr4iLCJvbGNyb3NzIjoi4qa7Iiwib2xpbmUiOiLigL4iLCJvbHQiOiLip4AiLCJPbWFjciI6IsWMIiwib21hY3IiOiLFjSIsIk9tZWdhIjoizqkiLCJvbWVnYSI6Is+JIiwiT21pY3JvbiI6Is6fIiwib21pY3JvbiI6Is6/Iiwib21pZCI6IuKmtiIsIm9taW51cyI6IuKKliIsIk9vcGYiOiLwnZWGIiwib29wZiI6IvCdlaAiLCJvcGFyIjoi4qa3IiwiT3BlbkN1cmx5RG91YmxlUXVvdGUiOiLigJwiLCJPcGVuQ3VybHlRdW90ZSI6IuKAmCIsIm9wZXJwIjoi4qa5Iiwib3BsdXMiOiLiipUiLCJvcmFyciI6IuKGuyIsIk9yIjoi4qmUIiwib3IiOiLiiKgiLCJvcmQiOiLiqZ0iLCJvcmRlciI6IuKEtCIsIm9yZGVyb2YiOiLihLQiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJvcmlnb2YiOiLiirYiLCJvcm9yIjoi4qmWIiwib3JzbG9wZSI6IuKplyIsIm9ydiI6IuKpmyIsIm9TIjoi4pOIIiwiT3NjciI6IvCdkqoiLCJvc2NyIjoi4oS0IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIm9zb2wiOiLiipgiLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1Iiwib3RpbWVzYXMiOiLiqLYiLCJPdGltZXMiOiLiqLciLCJvdGltZXMiOiLiipciLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJvdmJhciI6IuKMvSIsIk92ZXJCYXIiOiLigL4iLCJPdmVyQnJhY2UiOiLij54iLCJPdmVyQnJhY2tldCI6IuKOtCIsIk92ZXJQYXJlbnRoZXNpcyI6IuKPnCIsInBhcmEiOiLCtiIsInBhcmFsbGVsIjoi4oilIiwicGFyIjoi4oilIiwicGFyc2ltIjoi4quzIiwicGFyc2wiOiLiq70iLCJwYXJ0Ijoi4oiCIiwiUGFydGlhbEQiOiLiiIIiLCJQY3kiOiLQnyIsInBjeSI6ItC/IiwicGVyY250IjoiJSIsInBlcmlvZCI6Ii4iLCJwZXJtaWwiOiLigLAiLCJwZXJwIjoi4oqlIiwicGVydGVuayI6IuKAsSIsIlBmciI6IvCdlJMiLCJwZnIiOiLwnZStIiwiUGhpIjoizqYiLCJwaGkiOiLPhiIsInBoaXYiOiLPlSIsInBobW1hdCI6IuKEsyIsInBob25lIjoi4piOIiwiUGkiOiLOoCIsInBpIjoiz4AiLCJwaXRjaGZvcmsiOiLii5QiLCJwaXYiOiLPliIsInBsYW5jayI6IuKEjyIsInBsYW5ja2giOiLihI4iLCJwbGFua3YiOiLihI8iLCJwbHVzYWNpciI6IuKooyIsInBsdXNiIjoi4oqeIiwicGx1c2NpciI6IuKooiIsInBsdXMiOiIrIiwicGx1c2RvIjoi4oiUIiwicGx1c2R1Ijoi4qilIiwicGx1c2UiOiLiqbIiLCJQbHVzTWludXMiOiLCsSIsInBsdXNtbiI6IsKxIiwicGx1c3NpbSI6IuKopiIsInBsdXN0d28iOiLiqKciLCJwbSI6IsKxIiwiUG9pbmNhcmVwbGFuZSI6IuKEjCIsInBvaW50aW50Ijoi4qiVIiwicG9wZiI6IvCdlaEiLCJQb3BmIjoi4oSZIiwicG91bmQiOiLCoyIsInByYXAiOiLiqrciLCJQciI6IuKquyIsInByIjoi4om6IiwicHJjdWUiOiLiibwiLCJwcmVjYXBwcm94Ijoi4qq3IiwicHJlYyI6IuKJuiIsInByZWNjdXJseWVxIjoi4om8IiwiUHJlY2VkZXMiOiLiiboiLCJQcmVjZWRlc0VxdWFsIjoi4qqvIiwiUHJlY2VkZXNTbGFudEVxdWFsIjoi4om8IiwiUHJlY2VkZXNUaWxkZSI6IuKJviIsInByZWNlcSI6IuKqryIsInByZWNuYXBwcm94Ijoi4qq5IiwicHJlY25lcXEiOiLiqrUiLCJwcmVjbnNpbSI6IuKLqCIsInByZSI6IuKqryIsInByRSI6IuKqsyIsInByZWNzaW0iOiLiib4iLCJwcmltZSI6IuKAsiIsIlByaW1lIjoi4oCzIiwicHJpbWVzIjoi4oSZIiwicHJuYXAiOiLiqrkiLCJwcm5FIjoi4qq1IiwicHJuc2ltIjoi4ouoIiwicHJvZCI6IuKIjyIsIlByb2R1Y3QiOiLiiI8iLCJwcm9mYWxhciI6IuKMriIsInByb2ZsaW5lIjoi4oySIiwicHJvZnN1cmYiOiLijJMiLCJwcm9wIjoi4oidIiwiUHJvcG9ydGlvbmFsIjoi4oidIiwiUHJvcG9ydGlvbiI6IuKItyIsInByb3B0byI6IuKInSIsInByc2ltIjoi4om+IiwicHJ1cmVsIjoi4oqwIiwiUHNjciI6IvCdkqsiLCJwc2NyIjoi8J2ThSIsIlBzaSI6Is6oIiwicHNpIjoiz4giLCJwdW5jc3AiOiLigIgiLCJRZnIiOiLwnZSUIiwicWZyIjoi8J2UriIsInFpbnQiOiLiqIwiLCJxb3BmIjoi8J2VoiIsIlFvcGYiOiLihJoiLCJxcHJpbWUiOiLigZciLCJRc2NyIjoi8J2SrCIsInFzY3IiOiLwnZOGIiwicXVhdGVybmlvbnMiOiLihI0iLCJxdWF0aW50Ijoi4qiWIiwicXVlc3QiOiI/IiwicXVlc3RlcSI6IuKJnyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwickFhcnIiOiLih5siLCJyYWNlIjoi4oi9zLEiLCJSYWN1dGUiOiLFlCIsInJhY3V0ZSI6IsWVIiwicmFkaWMiOiLiiJoiLCJyYWVtcHR5diI6IuKmsyIsInJhbmciOiLin6kiLCJSYW5nIjoi4p+rIiwicmFuZ2QiOiLippIiLCJyYW5nZSI6IuKmpSIsInJhbmdsZSI6IuKfqSIsInJhcXVvIjoiwrsiLCJyYXJyYXAiOiLipbUiLCJyYXJyYiI6IuKHpSIsInJhcnJiZnMiOiLipKAiLCJyYXJyYyI6IuKksyIsInJhcnIiOiLihpIiLCJSYXJyIjoi4oagIiwickFyciI6IuKHkiIsInJhcnJmcyI6IuKkniIsInJhcnJoayI6IuKGqiIsInJhcnJscCI6IuKGrCIsInJhcnJwbCI6IuKlhSIsInJhcnJzaW0iOiLipbQiLCJSYXJydGwiOiLipJYiLCJyYXJydGwiOiLihqMiLCJyYXJydyI6IuKGnSIsInJhdGFpbCI6IuKkmiIsInJBdGFpbCI6IuKknCIsInJhdGlvIjoi4oi2IiwicmF0aW9uYWxzIjoi4oSaIiwicmJhcnIiOiLipI0iLCJyQmFyciI6IuKkjyIsIlJCYXJyIjoi4qSQIiwicmJicmsiOiLinbMiLCJyYnJhY2UiOiJ9IiwicmJyYWNrIjoiXSIsInJicmtlIjoi4qaMIiwicmJya3NsZCI6IuKmjiIsInJicmtzbHUiOiLippAiLCJSY2Fyb24iOiLFmCIsInJjYXJvbiI6IsWZIiwiUmNlZGlsIjoixZYiLCJyY2VkaWwiOiLFlyIsInJjZWlsIjoi4oyJIiwicmN1YiI6In0iLCJSY3kiOiLQoCIsInJjeSI6ItGAIiwicmRjYSI6IuKktyIsInJkbGRoYXIiOiLipakiLCJyZHF1byI6IuKAnSIsInJkcXVvciI6IuKAnSIsInJkc2giOiLihrMiLCJyZWFsIjoi4oScIiwicmVhbGluZSI6IuKEmyIsInJlYWxwYXJ0Ijoi4oScIiwicmVhbHMiOiLihJ0iLCJSZSI6IuKEnCIsInJlY3QiOiLilq0iLCJyZWciOiLCriIsIlJFRyI6IsKuIiwiUmV2ZXJzZUVsZW1lbnQiOiLiiIsiLCJSZXZlcnNlRXF1aWxpYnJpdW0iOiLih4siLCJSZXZlcnNlVXBFcXVpbGlicml1bSI6IuKlryIsInJmaXNodCI6IuKlvSIsInJmbG9vciI6IuKMiyIsInJmciI6IvCdlK8iLCJSZnIiOiLihJwiLCJySGFyIjoi4qWkIiwicmhhcmQiOiLih4EiLCJyaGFydSI6IuKHgCIsInJoYXJ1bCI6IuKlrCIsIlJobyI6Is6hIiwicmhvIjoiz4EiLCJyaG92Ijoiz7EiLCJSaWdodEFuZ2xlQnJhY2tldCI6IuKfqSIsIlJpZ2h0QXJyb3dCYXIiOiLih6UiLCJyaWdodGFycm93Ijoi4oaSIiwiUmlnaHRBcnJvdyI6IuKGkiIsIlJpZ2h0YXJyb3ciOiLih5IiLCJSaWdodEFycm93TGVmdEFycm93Ijoi4oeEIiwicmlnaHRhcnJvd3RhaWwiOiLihqMiLCJSaWdodENlaWxpbmciOiLijIkiLCJSaWdodERvdWJsZUJyYWNrZXQiOiLin6ciLCJSaWdodERvd25UZWVWZWN0b3IiOiLipZ0iLCJSaWdodERvd25WZWN0b3JCYXIiOiLipZUiLCJSaWdodERvd25WZWN0b3IiOiLih4IiLCJSaWdodEZsb29yIjoi4oyLIiwicmlnaHRoYXJwb29uZG93biI6IuKHgSIsInJpZ2h0aGFycG9vbnVwIjoi4oeAIiwicmlnaHRsZWZ0YXJyb3dzIjoi4oeEIiwicmlnaHRsZWZ0aGFycG9vbnMiOiLih4wiLCJyaWdodHJpZ2h0YXJyb3dzIjoi4oeJIiwicmlnaHRzcXVpZ2Fycm93Ijoi4oadIiwiUmlnaHRUZWVBcnJvdyI6IuKGpiIsIlJpZ2h0VGVlIjoi4oqiIiwiUmlnaHRUZWVWZWN0b3IiOiLipZsiLCJyaWdodHRocmVldGltZXMiOiLii4wiLCJSaWdodFRyaWFuZ2xlQmFyIjoi4qeQIiwiUmlnaHRUcmlhbmdsZSI6IuKKsyIsIlJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKKtSIsIlJpZ2h0VXBEb3duVmVjdG9yIjoi4qWPIiwiUmlnaHRVcFRlZVZlY3RvciI6IuKlnCIsIlJpZ2h0VXBWZWN0b3JCYXIiOiLipZQiLCJSaWdodFVwVmVjdG9yIjoi4oa+IiwiUmlnaHRWZWN0b3JCYXIiOiLipZMiLCJSaWdodFZlY3RvciI6IuKHgCIsInJpbmciOiLLmiIsInJpc2luZ2RvdHNlcSI6IuKJkyIsInJsYXJyIjoi4oeEIiwicmxoYXIiOiLih4wiLCJybG0iOiLigI8iLCJybW91c3RhY2hlIjoi4o6xIiwicm1vdXN0Ijoi4o6xIiwicm5taWQiOiLiq64iLCJyb2FuZyI6IuKfrSIsInJvYXJyIjoi4oe+Iiwicm9icmsiOiLin6ciLCJyb3BhciI6IuKmhiIsInJvcGYiOiLwnZWjIiwiUm9wZiI6IuKEnSIsInJvcGx1cyI6IuKoriIsInJvdGltZXMiOiLiqLUiLCJSb3VuZEltcGxpZXMiOiLipbAiLCJycGFyIjoiKSIsInJwYXJndCI6IuKmlCIsInJwcG9saW50Ijoi4qiSIiwicnJhcnIiOiLih4kiLCJScmlnaHRhcnJvdyI6IuKHmyIsInJzYXF1byI6IuKAuiIsInJzY3IiOiLwnZOHIiwiUnNjciI6IuKEmyIsInJzaCI6IuKGsSIsIlJzaCI6IuKGsSIsInJzcWIiOiJdIiwicnNxdW8iOiLigJkiLCJyc3F1b3IiOiLigJkiLCJydGhyZWUiOiLii4wiLCJydGltZXMiOiLii4oiLCJydHJpIjoi4pa5IiwicnRyaWUiOiLiirUiLCJydHJpZiI6IuKWuCIsInJ0cmlsdHJpIjoi4qeOIiwiUnVsZURlbGF5ZWQiOiLip7QiLCJydWx1aGFyIjoi4qWoIiwicngiOiLihJ4iLCJTYWN1dGUiOiLFmiIsInNhY3V0ZSI6IsWbIiwic2JxdW8iOiLigJoiLCJzY2FwIjoi4qq4IiwiU2Nhcm9uIjoixaAiLCJzY2Fyb24iOiLFoSIsIlNjIjoi4qq8Iiwic2MiOiLiibsiLCJzY2N1ZSI6IuKJvSIsInNjZSI6IuKqsCIsInNjRSI6IuKqtCIsIlNjZWRpbCI6IsWeIiwic2NlZGlsIjoixZ8iLCJTY2lyYyI6IsWcIiwic2NpcmMiOiLFnSIsInNjbmFwIjoi4qq6Iiwic2NuRSI6IuKqtiIsInNjbnNpbSI6IuKLqSIsInNjcG9saW50Ijoi4qiTIiwic2NzaW0iOiLiib8iLCJTY3kiOiLQoSIsInNjeSI6ItGBIiwic2RvdGIiOiLiiqEiLCJzZG90Ijoi4ouFIiwic2RvdGUiOiLiqaYiLCJzZWFyaGsiOiLipKUiLCJzZWFyciI6IuKGmCIsInNlQXJyIjoi4oeYIiwic2VhcnJvdyI6IuKGmCIsInNlY3QiOiLCpyIsInNlbWkiOiI7Iiwic2Vzd2FyIjoi4qSpIiwic2V0bWludXMiOiLiiJYiLCJzZXRtbiI6IuKIliIsInNleHQiOiLinLYiLCJTZnIiOiLwnZSWIiwic2ZyIjoi8J2UsCIsInNmcm93biI6IuKMoiIsInNoYXJwIjoi4pmvIiwiU0hDSGN5Ijoi0KkiLCJzaGNoY3kiOiLRiSIsIlNIY3kiOiLQqCIsInNoY3kiOiLRiCIsIlNob3J0RG93bkFycm93Ijoi4oaTIiwiU2hvcnRMZWZ0QXJyb3ciOiLihpAiLCJzaG9ydG1pZCI6IuKIoyIsInNob3J0cGFyYWxsZWwiOiLiiKUiLCJTaG9ydFJpZ2h0QXJyb3ciOiLihpIiLCJTaG9ydFVwQXJyb3ciOiLihpEiLCJzaHkiOiLCrSIsIlNpZ21hIjoizqMiLCJzaWdtYSI6Is+DIiwic2lnbWFmIjoiz4IiLCJzaWdtYXYiOiLPgiIsInNpbSI6IuKIvCIsInNpbWRvdCI6IuKpqiIsInNpbWUiOiLiiYMiLCJzaW1lcSI6IuKJgyIsInNpbWciOiLiqp4iLCJzaW1nRSI6IuKqoCIsInNpbWwiOiLiqp0iLCJzaW1sRSI6IuKqnyIsInNpbW5lIjoi4omGIiwic2ltcGx1cyI6IuKopCIsInNpbXJhcnIiOiLipbIiLCJzbGFyciI6IuKGkCIsIlNtYWxsQ2lyY2xlIjoi4oiYIiwic21hbGxzZXRtaW51cyI6IuKIliIsInNtYXNocCI6IuKosyIsInNtZXBhcnNsIjoi4qekIiwic21pZCI6IuKIoyIsInNtaWxlIjoi4oyjIiwic210Ijoi4qqqIiwic210ZSI6IuKqrCIsInNtdGVzIjoi4qqs77iAIiwiU09GVGN5Ijoi0KwiLCJzb2Z0Y3kiOiLRjCIsInNvbGJhciI6IuKMvyIsInNvbGIiOiLip4QiLCJzb2wiOiIvIiwiU29wZiI6IvCdlYoiLCJzb3BmIjoi8J2VpCIsInNwYWRlcyI6IuKZoCIsInNwYWRlc3VpdCI6IuKZoCIsInNwYXIiOiLiiKUiLCJzcWNhcCI6IuKKkyIsInNxY2FwcyI6IuKKk++4gCIsInNxY3VwIjoi4oqUIiwic3FjdXBzIjoi4oqU77iAIiwiU3FydCI6IuKImiIsInNxc3ViIjoi4oqPIiwic3FzdWJlIjoi4oqRIiwic3FzdWJzZXQiOiLiio8iLCJzcXN1YnNldGVxIjoi4oqRIiwic3FzdXAiOiLiipAiLCJzcXN1cGUiOiLiipIiLCJzcXN1cHNldCI6IuKKkCIsInNxc3Vwc2V0ZXEiOiLiipIiLCJzcXVhcmUiOiLilqEiLCJTcXVhcmUiOiLilqEiLCJTcXVhcmVJbnRlcnNlY3Rpb24iOiLiipMiLCJTcXVhcmVTdWJzZXQiOiLiio8iLCJTcXVhcmVTdWJzZXRFcXVhbCI6IuKKkSIsIlNxdWFyZVN1cGVyc2V0Ijoi4oqQIiwiU3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKKkiIsIlNxdWFyZVVuaW9uIjoi4oqUIiwic3F1YXJmIjoi4paqIiwic3F1Ijoi4pahIiwic3F1ZiI6IuKWqiIsInNyYXJyIjoi4oaSIiwiU3NjciI6IvCdkq4iLCJzc2NyIjoi8J2TiCIsInNzZXRtbiI6IuKIliIsInNzbWlsZSI6IuKMoyIsInNzdGFyZiI6IuKLhiIsIlN0YXIiOiLii4YiLCJzdGFyIjoi4piGIiwic3RhcmYiOiLimIUiLCJzdHJhaWdodGVwc2lsb24iOiLPtSIsInN0cmFpZ2h0cGhpIjoiz5UiLCJzdHJucyI6IsKvIiwic3ViIjoi4oqCIiwiU3ViIjoi4ouQIiwic3ViZG90Ijoi4qq9Iiwic3ViRSI6IuKrhSIsInN1YmUiOiLiioYiLCJzdWJlZG90Ijoi4quDIiwic3VibXVsdCI6IuKrgSIsInN1Ym5FIjoi4quLIiwic3VibmUiOiLiiooiLCJzdWJwbHVzIjoi4qq/Iiwic3VicmFyciI6IuKluSIsInN1YnNldCI6IuKKgiIsIlN1YnNldCI6IuKLkCIsInN1YnNldGVxIjoi4oqGIiwic3Vic2V0ZXFxIjoi4quFIiwiU3Vic2V0RXF1YWwiOiLiioYiLCJzdWJzZXRuZXEiOiLiiooiLCJzdWJzZXRuZXFxIjoi4quLIiwic3Vic2ltIjoi4quHIiwic3Vic3ViIjoi4quVIiwic3Vic3VwIjoi4quTIiwic3VjY2FwcHJveCI6IuKquCIsInN1Y2MiOiLiibsiLCJzdWNjY3VybHllcSI6IuKJvSIsIlN1Y2NlZWRzIjoi4om7IiwiU3VjY2VlZHNFcXVhbCI6IuKqsCIsIlN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKJvSIsIlN1Y2NlZWRzVGlsZGUiOiLiib8iLCJzdWNjZXEiOiLiqrAiLCJzdWNjbmFwcHJveCI6IuKquiIsInN1Y2NuZXFxIjoi4qq2Iiwic3VjY25zaW0iOiLii6kiLCJzdWNjc2ltIjoi4om/IiwiU3VjaFRoYXQiOiLiiIsiLCJzdW0iOiLiiJEiLCJTdW0iOiLiiJEiLCJzdW5nIjoi4pmqIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3VwIjoi4oqDIiwiU3VwIjoi4ouRIiwic3VwZG90Ijoi4qq+Iiwic3VwZHN1YiI6IuKrmCIsInN1cEUiOiLiq4YiLCJzdXBlIjoi4oqHIiwic3VwZWRvdCI6IuKrhCIsIlN1cGVyc2V0Ijoi4oqDIiwiU3VwZXJzZXRFcXVhbCI6IuKKhyIsInN1cGhzb2wiOiLin4kiLCJzdXBoc3ViIjoi4quXIiwic3VwbGFyciI6IuKluyIsInN1cG11bHQiOiLiq4IiLCJzdXBuRSI6IuKrjCIsInN1cG5lIjoi4oqLIiwic3VwcGx1cyI6IuKrgCIsInN1cHNldCI6IuKKgyIsIlN1cHNldCI6IuKLkSIsInN1cHNldGVxIjoi4oqHIiwic3Vwc2V0ZXFxIjoi4quGIiwic3Vwc2V0bmVxIjoi4oqLIiwic3Vwc2V0bmVxcSI6IuKrjCIsInN1cHNpbSI6IuKriCIsInN1cHN1YiI6IuKrlCIsInN1cHN1cCI6IuKrliIsInN3YXJoayI6IuKkpiIsInN3YXJyIjoi4oaZIiwic3dBcnIiOiLih5kiLCJzd2Fycm93Ijoi4oaZIiwic3dud2FyIjoi4qSqIiwic3psaWciOiLDnyIsIlRhYiI6IlxcdCIsInRhcmdldCI6IuKMliIsIlRhdSI6Is6kIiwidGF1Ijoiz4QiLCJ0YnJrIjoi4o60IiwiVGNhcm9uIjoixaQiLCJ0Y2Fyb24iOiLFpSIsIlRjZWRpbCI6IsWiIiwidGNlZGlsIjoixaMiLCJUY3kiOiLQoiIsInRjeSI6ItGCIiwidGRvdCI6IuKDmyIsInRlbHJlYyI6IuKMlSIsIlRmciI6IvCdlJciLCJ0ZnIiOiLwnZSxIiwidGhlcmU0Ijoi4oi0IiwidGhlcmVmb3JlIjoi4oi0IiwiVGhlcmVmb3JlIjoi4oi0IiwiVGhldGEiOiLOmCIsInRoZXRhIjoizrgiLCJ0aGV0YXN5bSI6Is+RIiwidGhldGF2Ijoiz5EiLCJ0aGlja2FwcHJveCI6IuKJiCIsInRoaWNrc2ltIjoi4oi8IiwiVGhpY2tTcGFjZSI6IuKBn+KAiiIsIlRoaW5TcGFjZSI6IuKAiSIsInRoaW5zcCI6IuKAiSIsInRoa2FwIjoi4omIIiwidGhrc2ltIjoi4oi8IiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aWxkZSI6IsucIiwiVGlsZGUiOiLiiLwiLCJUaWxkZUVxdWFsIjoi4omDIiwiVGlsZGVGdWxsRXF1YWwiOiLiiYUiLCJUaWxkZVRpbGRlIjoi4omIIiwidGltZXNiYXIiOiLiqLEiLCJ0aW1lc2IiOiLiiqAiLCJ0aW1lcyI6IsOXIiwidGltZXNkIjoi4qiwIiwidGludCI6IuKIrSIsInRvZWEiOiLipKgiLCJ0b3Bib3QiOiLijLYiLCJ0b3BjaXIiOiLiq7EiLCJ0b3AiOiLiiqQiLCJUb3BmIjoi8J2ViyIsInRvcGYiOiLwnZWlIiwidG9wZm9yayI6IuKrmiIsInRvc2EiOiLipKkiLCJ0cHJpbWUiOiLigLQiLCJ0cmFkZSI6IuKEoiIsIlRSQURFIjoi4oSiIiwidHJpYW5nbGUiOiLilrUiLCJ0cmlhbmdsZWRvd24iOiLilr8iLCJ0cmlhbmdsZWxlZnQiOiLil4MiLCJ0cmlhbmdsZWxlZnRlcSI6IuKKtCIsInRyaWFuZ2xlcSI6IuKJnCIsInRyaWFuZ2xlcmlnaHQiOiLilrkiLCJ0cmlhbmdsZXJpZ2h0ZXEiOiLiirUiLCJ0cmlkb3QiOiLil6wiLCJ0cmllIjoi4omcIiwidHJpbWludXMiOiLiqLoiLCJUcmlwbGVEb3QiOiLig5siLCJ0cmlwbHVzIjoi4qi5IiwidHJpc2IiOiLip40iLCJ0cml0aW1lIjoi4qi7IiwidHJwZXppdW0iOiLij6IiLCJUc2NyIjoi8J2SryIsInRzY3IiOiLwnZOJIiwiVFNjeSI6ItCmIiwidHNjeSI6ItGGIiwiVFNIY3kiOiLQiyIsInRzaGN5Ijoi0ZsiLCJUc3Ryb2siOiLFpiIsInRzdHJvayI6IsWnIiwidHdpeHQiOiLiiawiLCJ0d29oZWFkbGVmdGFycm93Ijoi4oaeIiwidHdvaGVhZHJpZ2h0YXJyb3ciOiLihqAiLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwidWFyciI6IuKGkSIsIlVhcnIiOiLihp8iLCJ1QXJyIjoi4oeRIiwiVWFycm9jaXIiOiLipYkiLCJVYnJjeSI6ItCOIiwidWJyY3kiOiLRniIsIlVicmV2ZSI6IsWsIiwidWJyZXZlIjoixa0iLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVjeSI6ItCjIiwidWN5Ijoi0YMiLCJ1ZGFyciI6IuKHhSIsIlVkYmxhYyI6IsWwIiwidWRibGFjIjoixbEiLCJ1ZGhhciI6IuKlriIsInVmaXNodCI6IuKlviIsIlVmciI6IvCdlJgiLCJ1ZnIiOiLwnZSyIiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVIYXIiOiLipaMiLCJ1aGFybCI6IuKGvyIsInVoYXJyIjoi4oa+IiwidWhibGsiOiLiloAiLCJ1bGNvcm4iOiLijJwiLCJ1bGNvcm5lciI6IuKMnCIsInVsY3JvcCI6IuKMjyIsInVsdHJpIjoi4pe4IiwiVW1hY3IiOiLFqiIsInVtYWNyIjoixasiLCJ1bWwiOiLCqCIsIlVuZGVyQmFyIjoiXyIsIlVuZGVyQnJhY2UiOiLij58iLCJVbmRlckJyYWNrZXQiOiLijrUiLCJVbmRlclBhcmVudGhlc2lzIjoi4o+dIiwiVW5pb24iOiLii4MiLCJVbmlvblBsdXMiOiLiio4iLCJVb2dvbiI6IsWyIiwidW9nb24iOiLFsyIsIlVvcGYiOiLwnZWMIiwidW9wZiI6IvCdlaYiLCJVcEFycm93QmFyIjoi4qSSIiwidXBhcnJvdyI6IuKGkSIsIlVwQXJyb3ciOiLihpEiLCJVcGFycm93Ijoi4oeRIiwiVXBBcnJvd0Rvd25BcnJvdyI6IuKHhSIsInVwZG93bmFycm93Ijoi4oaVIiwiVXBEb3duQXJyb3ciOiLihpUiLCJVcGRvd25hcnJvdyI6IuKHlSIsIlVwRXF1aWxpYnJpdW0iOiLipa4iLCJ1cGhhcnBvb25sZWZ0Ijoi4oa/IiwidXBoYXJwb29ucmlnaHQiOiLihr4iLCJ1cGx1cyI6IuKKjiIsIlVwcGVyTGVmdEFycm93Ijoi4oaWIiwiVXBwZXJSaWdodEFycm93Ijoi4oaXIiwidXBzaSI6Is+FIiwiVXBzaSI6Is+SIiwidXBzaWgiOiLPkiIsIlVwc2lsb24iOiLOpSIsInVwc2lsb24iOiLPhSIsIlVwVGVlQXJyb3ciOiLihqUiLCJVcFRlZSI6IuKKpSIsInVwdXBhcnJvd3MiOiLih4giLCJ1cmNvcm4iOiLijJ0iLCJ1cmNvcm5lciI6IuKMnSIsInVyY3JvcCI6IuKMjiIsIlVyaW5nIjoixa4iLCJ1cmluZyI6IsWvIiwidXJ0cmkiOiLil7kiLCJVc2NyIjoi8J2SsCIsInVzY3IiOiLwnZOKIiwidXRkb3QiOiLii7AiLCJVdGlsZGUiOiLFqCIsInV0aWxkZSI6IsWpIiwidXRyaSI6IuKWtSIsInV0cmlmIjoi4pa0IiwidXVhcnIiOiLih4giLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJ1d2FuZ2xlIjoi4qanIiwidmFuZ3J0Ijoi4qacIiwidmFyZXBzaWxvbiI6Is+1IiwidmFya2FwcGEiOiLPsCIsInZhcm5vdGhpbmciOiLiiIUiLCJ2YXJwaGkiOiLPlSIsInZhcnBpIjoiz5YiLCJ2YXJwcm9wdG8iOiLiiJ0iLCJ2YXJyIjoi4oaVIiwidkFyciI6IuKHlSIsInZhcnJobyI6Is+xIiwidmFyc2lnbWEiOiLPgiIsInZhcnN1YnNldG5lcSI6IuKKiu+4gCIsInZhcnN1YnNldG5lcXEiOiLiq4vvuIAiLCJ2YXJzdXBzZXRuZXEiOiLiiovvuIAiLCJ2YXJzdXBzZXRuZXFxIjoi4quM77iAIiwidmFydGhldGEiOiLPkSIsInZhcnRyaWFuZ2xlbGVmdCI6IuKKsiIsInZhcnRyaWFuZ2xlcmlnaHQiOiLiirMiLCJ2QmFyIjoi4quoIiwiVmJhciI6IuKrqyIsInZCYXJ2Ijoi4qupIiwiVmN5Ijoi0JIiLCJ2Y3kiOiLQsiIsInZkYXNoIjoi4oqiIiwidkRhc2giOiLiiqgiLCJWZGFzaCI6IuKKqSIsIlZEYXNoIjoi4oqrIiwiVmRhc2hsIjoi4qumIiwidmVlYmFyIjoi4oq7IiwidmVlIjoi4oioIiwiVmVlIjoi4ouBIiwidmVlZXEiOiLiiZoiLCJ2ZWxsaXAiOiLii64iLCJ2ZXJiYXIiOiJ8IiwiVmVyYmFyIjoi4oCWIiwidmVydCI6InwiLCJWZXJ0Ijoi4oCWIiwiVmVydGljYWxCYXIiOiLiiKMiLCJWZXJ0aWNhbExpbmUiOiJ8IiwiVmVydGljYWxTZXBhcmF0b3IiOiLinZgiLCJWZXJ0aWNhbFRpbGRlIjoi4omAIiwiVmVyeVRoaW5TcGFjZSI6IuKAiiIsIlZmciI6IvCdlJkiLCJ2ZnIiOiLwnZSzIiwidmx0cmkiOiLiirIiLCJ2bnN1YiI6IuKKguKDkiIsInZuc3VwIjoi4oqD4oOSIiwiVm9wZiI6IvCdlY0iLCJ2b3BmIjoi8J2VpyIsInZwcm9wIjoi4oidIiwidnJ0cmkiOiLiirMiLCJWc2NyIjoi8J2SsSIsInZzY3IiOiLwnZOLIiwidnN1Ym5FIjoi4quL77iAIiwidnN1Ym5lIjoi4oqK77iAIiwidnN1cG5FIjoi4quM77iAIiwidnN1cG5lIjoi4oqL77iAIiwiVnZkYXNoIjoi4oqqIiwidnppZ3phZyI6IuKmmiIsIldjaXJjIjoixbQiLCJ3Y2lyYyI6IsW1Iiwid2VkYmFyIjoi4qmfIiwid2VkZ2UiOiLiiKciLCJXZWRnZSI6IuKLgCIsIndlZGdlcSI6IuKJmSIsIndlaWVycCI6IuKEmCIsIldmciI6IvCdlJoiLCJ3ZnIiOiLwnZS0IiwiV29wZiI6IvCdlY4iLCJ3b3BmIjoi8J2VqCIsIndwIjoi4oSYIiwid3IiOiLiiYAiLCJ3cmVhdGgiOiLiiYAiLCJXc2NyIjoi8J2SsiIsIndzY3IiOiLwnZOMIiwieGNhcCI6IuKLgiIsInhjaXJjIjoi4pevIiwieGN1cCI6IuKLgyIsInhkdHJpIjoi4pa9IiwiWGZyIjoi8J2UmyIsInhmciI6IvCdlLUiLCJ4aGFyciI6IuKftyIsInhoQXJyIjoi4p+6IiwiWGkiOiLOniIsInhpIjoizr4iLCJ4bGFyciI6IuKftSIsInhsQXJyIjoi4p+4IiwieG1hcCI6IuKfvCIsInhuaXMiOiLii7siLCJ4b2RvdCI6IuKogCIsIlhvcGYiOiLwnZWPIiwieG9wZiI6IvCdlakiLCJ4b3BsdXMiOiLiqIEiLCJ4b3RpbWUiOiLiqIIiLCJ4cmFyciI6IuKftiIsInhyQXJyIjoi4p+5IiwiWHNjciI6IvCdkrMiLCJ4c2NyIjoi8J2TjSIsInhzcWN1cCI6IuKohiIsInh1cGx1cyI6IuKohCIsInh1dHJpIjoi4pazIiwieHZlZSI6IuKLgSIsInh3ZWRnZSI6IuKLgCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJZQWN5Ijoi0K8iLCJ5YWN5Ijoi0Y8iLCJZY2lyYyI6IsW2IiwieWNpcmMiOiLFtyIsIlljeSI6ItCrIiwieWN5Ijoi0YsiLCJ5ZW4iOiLCpSIsIllmciI6IvCdlJwiLCJ5ZnIiOiLwnZS2IiwiWUljeSI6ItCHIiwieWljeSI6ItGXIiwiWW9wZiI6IvCdlZAiLCJ5b3BmIjoi8J2VqiIsIllzY3IiOiLwnZK0IiwieXNjciI6IvCdk44iLCJZVWN5Ijoi0K4iLCJ5dWN5Ijoi0Y4iLCJ5dW1sIjoiw78iLCJZdW1sIjoixbgiLCJaYWN1dGUiOiLFuSIsInphY3V0ZSI6IsW6IiwiWmNhcm9uIjoixb0iLCJ6Y2Fyb24iOiLFviIsIlpjeSI6ItCXIiwiemN5Ijoi0LciLCJaZG90IjoixbsiLCJ6ZG90IjoixbwiLCJ6ZWV0cmYiOiLihKgiLCJaZXJvV2lkdGhTcGFjZSI6IuKAiyIsIlpldGEiOiLOliIsInpldGEiOiLOtiIsInpmciI6IvCdlLciLCJaZnIiOiLihKgiLCJaSGN5Ijoi0JYiLCJ6aGN5Ijoi0LYiLCJ6aWdyYXJyIjoi4oedIiwiem9wZiI6IvCdlasiLCJab3BmIjoi4oSkIiwiWnNjciI6IvCdkrUiLCJ6c2NyIjoi8J2TjyIsInp3aiI6IuKAjSIsInp3bmoiOiLigIwifScpfSxmdW5jdGlvbihoKXtoLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJicnZiYXIiOiLCpiIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJjZWRpbCI6IsK4IiwiY2VudCI6IsKiIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY3VycmVuIjoiwqQiLCJkZWciOiLCsCIsImRpdmlkZSI6IsO3IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJmcmFjMTIiOiLCvSIsImZyYWMxNCI6IsK8IiwiZnJhYzM0Ijoiwr4iLCJndCI6Ij4iLCJHVCI6Ij4iLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJpZXhjbCI6IsKhIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlxdWVzdCI6IsK/IiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwibGFxdW8iOiLCqyIsImx0IjoiPCIsIkxUIjoiPCIsIm1hY3IiOiLCryIsIm1pY3JvIjoiwrUiLCJtaWRkb3QiOiLCtyIsIm5ic3AiOiLCoCIsIm5vdCI6IsKsIiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4IiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsInBhcmEiOiLCtiIsInBsdXNtbiI6IsKxIiwicG91bmQiOiLCoyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwicmFxdW8iOiLCuyIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJzZWN0IjoiwqciLCJzaHkiOiLCrSIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN6bGlnIjoiw58iLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbWVzIjoiw5ciLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidW1sIjoiwqgiLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwieWVuIjoiwqUiLCJ5dW1sIjoiw78ifScpfSxmdW5jdGlvbihoKXtoLmV4cG9ydHM9SlNPTi5wYXJzZShgeyJhbXAiOiImIiwiYXBvcyI6IiciLCJndCI6Ij4iLCJsdCI6IjwiLCJxdW90IjoiXFwiIn1gKX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih5KXtyZXR1cm4geSYmeS5fX2VzTW9kdWxlP3k6e2RlZmF1bHQ6eX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcz1yKHQoMjY1KSk7ZnVuY3Rpb24gbSh5KXtpZih5Pj01NTI5NiYmeTw9NTczNDN8fHk+MTExNDExMSlyZXR1cm4i77+9Ijt5IGluIHMuZGVmYXVsdCYmKHk9cy5kZWZhdWx0W3ldKTt2YXIgYz0iIjtyZXR1cm4geT42NTUzNSYmKHktPTY1NTM2LGMrPVN0cmluZy5mcm9tQ2hhckNvZGUoeT4+PjEwJjEwMjN8NTUyOTYpLHk9NTYzMjB8eSYxMDIzKSxjKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHkpLGN9ZS5kZWZhdWx0PW19LGZ1bmN0aW9uKGgpe2guZXhwb3J0cz1KU09OLnBhcnNlKCd7IjAiOjY1NTMzLCIxMjgiOjgzNjQsIjEzMCI6ODIxOCwiMTMxIjo0MDIsIjEzMiI6ODIyMiwiMTMzIjo4MjMwLCIxMzQiOjgyMjQsIjEzNSI6ODIyNSwiMTM2Ijo3MTAsIjEzNyI6ODI0MCwiMTM4IjozNTIsIjEzOSI6ODI0OSwiMTQwIjozMzgsIjE0MiI6MzgxLCIxNDUiOjgyMTYsIjE0NiI6ODIxNywiMTQ3Ijo4MjIwLCIxNDgiOjgyMjEsIjE0OSI6ODIyNiwiMTUwIjo4MjExLCIxNTEiOjgyMTIsIjE1MiI6NzMyLCIxNTMiOjg0ODIsIjE1NCI6MzUzLCIxNTUiOjgyNTAsIjE1NiI6MzM5LCIxNTgiOjM4MiwiMTU5IjozNzZ9Jyl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24ocCl7cmV0dXJuIHAmJnAuX19lc01vZHVsZT9wOntkZWZhdWx0OnB9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lc2NhcGU9ZS5lbmNvZGVIVE1MPWUuZW5jb2RlWE1MPXZvaWQgMDt2YXIgcz1yKHQoMjYzKSksbT1NKHMuZGVmYXVsdCkseT1mKG0pO2UuZW5jb2RlWE1MPVIobSx5KTt2YXIgYz1yKHQoMjYxKSksbD1NKGMuZGVmYXVsdCksdT1mKGwpO2UuZW5jb2RlSFRNTD1SKGwsdSk7ZnVuY3Rpb24gTShwKXtyZXR1cm4gT2JqZWN0LmtleXMocCkuc29ydCgpLnJlZHVjZShmdW5jdGlvbihuLGEpe3JldHVybiBuW3BbYV1dPSImIithKyI7IixufSx7fSl9ZnVuY3Rpb24gZihwKXtmb3IodmFyIG49W10sYT1bXSxpPTAsbz1PYmplY3Qua2V5cyhwKTtpPG8ubGVuZ3RoO2krKyl7dmFyIFQ9b1tpXTtULmxlbmd0aD09PTE/bi5wdXNoKCJcXCIrVCk6YS5wdXNoKFQpfW4uc29ydCgpO2Zvcih2YXIgQT0wO0E8bi5sZW5ndGgtMTtBKyspe2Zvcih2YXIgQz1BO0M8bi5sZW5ndGgtMSYmbltDXS5jaGFyQ29kZUF0KDEpKzE9PT1uW0MrMV0uY2hhckNvZGVBdCgxKTspQys9MTt2YXIgST0xK0MtQTtJPDN8fG4uc3BsaWNlKEEsSSxuW0FdKyItIituW0NdKX1yZXR1cm4gYS51bnNoaWZ0KCJbIituLmpvaW4oIiIpKyJdIiksbmV3IFJlZ0V4cChhLmpvaW4oInwiKSwiZyIpfXZhciB2PS8oPzpbXHg4MC1cdUQ3RkZcdUUwMDAtXHVGRkZGXXxbXHVEODAwLVx1REJGRl1bXHVEQzAwLVx1REZGRl18W1x1RDgwMC1cdURCRkZdKD8hW1x1REMwMC1cdURGRkZdKXwoPzpbXlx1RDgwMC1cdURCRkZdfF4pW1x1REMwMC1cdURGRkZdKS9nO2Z1bmN0aW9uIHgocCl7cmV0dXJuIiYjeCIrcC5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSsiOyJ9ZnVuY3Rpb24gUihwLG4pe3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKG4sZnVuY3Rpb24oaSl7cmV0dXJuIHBbaV19KS5yZXBsYWNlKHYseCl9fXZhciBPPWYobSk7ZnVuY3Rpb24gZyhwKXtyZXR1cm4gcC5yZXBsYWNlKE8seCkucmVwbGFjZSh2LHgpfWUuZXNjYXBlPWd9LGZ1bmN0aW9uKGgpe2guZXhwb3J0cz1KU09OLnBhcnNlKCd7ImVsZW1lbnROYW1lcyI6eyJhbHRnbHlwaCI6ImFsdEdseXBoIiwiYWx0Z2x5cGhkZWYiOiJhbHRHbHlwaERlZiIsImFsdGdseXBoaXRlbSI6ImFsdEdseXBoSXRlbSIsImFuaW1hdGVjb2xvciI6ImFuaW1hdGVDb2xvciIsImFuaW1hdGVtb3Rpb24iOiJhbmltYXRlTW90aW9uIiwiYW5pbWF0ZXRyYW5zZm9ybSI6ImFuaW1hdGVUcmFuc2Zvcm0iLCJjbGlwcGF0aCI6ImNsaXBQYXRoIiwiZmVibGVuZCI6ImZlQmxlbmQiLCJmZWNvbG9ybWF0cml4IjoiZmVDb2xvck1hdHJpeCIsImZlY29tcG9uZW50dHJhbnNmZXIiOiJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVjb21wb3NpdGUiOiJmZUNvbXBvc2l0ZSIsImZlY29udm9sdmVtYXRyaXgiOiJmZUNvbnZvbHZlTWF0cml4IiwiZmVkaWZmdXNlbGlnaHRpbmciOiJmZURpZmZ1c2VMaWdodGluZyIsImZlZGlzcGxhY2VtZW50bWFwIjoiZmVEaXNwbGFjZW1lbnRNYXAiLCJmZWRpc3RhbnRsaWdodCI6ImZlRGlzdGFudExpZ2h0IiwiZmVkcm9wc2hhZG93IjoiZmVEcm9wU2hhZG93IiwiZmVmbG9vZCI6ImZlRmxvb2QiLCJmZWZ1bmNhIjoiZmVGdW5jQSIsImZlZnVuY2IiOiJmZUZ1bmNCIiwiZmVmdW5jZyI6ImZlRnVuY0ciLCJmZWZ1bmNyIjoiZmVGdW5jUiIsImZlZ2F1c3NpYW5ibHVyIjoiZmVHYXVzc2lhbkJsdXIiLCJmZWltYWdlIjoiZmVJbWFnZSIsImZlbWVyZ2UiOiJmZU1lcmdlIiwiZmVtZXJnZW5vZGUiOiJmZU1lcmdlTm9kZSIsImZlbW9ycGhvbG9neSI6ImZlTW9ycGhvbG9neSIsImZlb2Zmc2V0IjoiZmVPZmZzZXQiLCJmZXBvaW50bGlnaHQiOiJmZVBvaW50TGlnaHQiLCJmZXNwZWN1bGFybGlnaHRpbmciOiJmZVNwZWN1bGFyTGlnaHRpbmciLCJmZXNwb3RsaWdodCI6ImZlU3BvdExpZ2h0IiwiZmV0aWxlIjoiZmVUaWxlIiwiZmV0dXJidWxlbmNlIjoiZmVUdXJidWxlbmNlIiwiZm9yZWlnbm9iamVjdCI6ImZvcmVpZ25PYmplY3QiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwibGluZWFyZ3JhZGllbnQiOiJsaW5lYXJHcmFkaWVudCIsInJhZGlhbGdyYWRpZW50IjoicmFkaWFsR3JhZGllbnQiLCJ0ZXh0cGF0aCI6InRleHRQYXRoIn0sImF0dHJpYnV0ZU5hbWVzIjp7ImRlZmluaXRpb251cmwiOiJkZWZpbml0aW9uVVJMIiwiYXR0cmlidXRlbmFtZSI6ImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGV0eXBlIjoiYXR0cmlidXRlVHlwZSIsImJhc2VmcmVxdWVuY3kiOiJiYXNlRnJlcXVlbmN5IiwiYmFzZXByb2ZpbGUiOiJiYXNlUHJvZmlsZSIsImNhbGNtb2RlIjoiY2FsY01vZGUiLCJjbGlwcGF0aHVuaXRzIjoiY2xpcFBhdGhVbml0cyIsImRpZmZ1c2Vjb25zdGFudCI6ImRpZmZ1c2VDb25zdGFudCIsImVkZ2Vtb2RlIjoiZWRnZU1vZGUiLCJmaWx0ZXJ1bml0cyI6ImZpbHRlclVuaXRzIiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImdyYWRpZW50dHJhbnNmb3JtIjoiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIjoiZ3JhZGllbnRVbml0cyIsImtlcm5lbG1hdHJpeCI6Imtlcm5lbE1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiOiJrZXJuZWxVbml0TGVuZ3RoIiwia2V5cG9pbnRzIjoia2V5UG9pbnRzIiwia2V5c3BsaW5lcyI6ImtleVNwbGluZXMiLCJrZXl0aW1lcyI6ImtleVRpbWVzIiwibGVuZ3RoYWRqdXN0IjoibGVuZ3RoQWRqdXN0IiwibGltaXRpbmdjb25lYW5nbGUiOiJsaW1pdGluZ0NvbmVBbmdsZSIsIm1hcmtlcmhlaWdodCI6Im1hcmtlckhlaWdodCIsIm1hcmtlcnVuaXRzIjoibWFya2VyVW5pdHMiLCJtYXJrZXJ3aWR0aCI6Im1hcmtlcldpZHRoIiwibWFza2NvbnRlbnR1bml0cyI6Im1hc2tDb250ZW50VW5pdHMiLCJtYXNrdW5pdHMiOiJtYXNrVW5pdHMiLCJudW1vY3RhdmVzIjoibnVtT2N0YXZlcyIsInBhdGhsZW5ndGgiOiJwYXRoTGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyI6InBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIjoicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm51bml0cyI6InBhdHRlcm5Vbml0cyIsInBvaW50c2F0eCI6InBvaW50c0F0WCIsInBvaW50c2F0eSI6InBvaW50c0F0WSIsInBvaW50c2F0eiI6InBvaW50c0F0WiIsInByZXNlcnZlYWxwaGEiOiJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyI6InByZXNlcnZlQXNwZWN0UmF0aW8iLCJwcmltaXRpdmV1bml0cyI6InByaW1pdGl2ZVVuaXRzIiwicmVmeCI6InJlZlgiLCJyZWZ5IjoicmVmWSIsInJlcGVhdGNvdW50IjoicmVwZWF0Q291bnQiLCJyZXBlYXRkdXIiOiJyZXBlYXREdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiOiJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIjoicmVxdWlyZWRGZWF0dXJlcyIsInNwZWN1bGFyY29uc3RhbnQiOiJzcGVjdWxhckNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCI6InNwZWN1bGFyRXhwb25lbnQiLCJzcHJlYWRtZXRob2QiOiJzcHJlYWRNZXRob2QiLCJzdGFydG9mZnNldCI6InN0YXJ0T2Zmc2V0Iiwic3RkZGV2aWF0aW9uIjoic3RkRGV2aWF0aW9uIiwic3RpdGNodGlsZXMiOiJzdGl0Y2hUaWxlcyIsInN1cmZhY2VzY2FsZSI6InN1cmZhY2VTY2FsZSIsInN5c3RlbWxhbmd1YWdlIjoic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyI6InRhYmxlVmFsdWVzIiwidGFyZ2V0eCI6InRhcmdldFgiLCJ0YXJnZXR5IjoidGFyZ2V0WSIsInRleHRsZW5ndGgiOiJ0ZXh0TGVuZ3RoIiwidmlld2JveCI6InZpZXdCb3giLCJ2aWV3dGFyZ2V0Ijoidmlld1RhcmdldCIsInhjaGFubmVsc2VsZWN0b3IiOiJ4Q2hhbm5lbFNlbGVjdG9yIiwieWNoYW5uZWxzZWxlY3RvciI6InlDaGFubmVsU2VsZWN0b3IiLCJ6b29tYW5kcGFuIjoiem9vbUFuZFBhbiJ9fScpfSxmdW5jdGlvbihoLGUpe3ZhciB0PWUuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24ocyl7cmV0dXJuIHMuY2hpbGRyZW59LHI9ZS5nZXRQYXJlbnQ9ZnVuY3Rpb24ocyl7cmV0dXJuIHMucGFyZW50fTtlLmdldFNpYmxpbmdzPWZ1bmN0aW9uKHMpe3ZhciBtPXIocyk7cmV0dXJuIG0/dChtKTpbc119LGUuZ2V0QXR0cmlidXRlVmFsdWU9ZnVuY3Rpb24ocyxtKXtyZXR1cm4gcy5hdHRyaWJzJiZzLmF0dHJpYnNbbV19LGUuaGFzQXR0cmliPWZ1bmN0aW9uKHMsbSl7cmV0dXJuISFzLmF0dHJpYnMmJmhhc093blByb3BlcnR5LmNhbGwocy5hdHRyaWJzLG0pfSxlLmdldE5hbWU9ZnVuY3Rpb24ocyl7cmV0dXJuIHMubmFtZX19LGZ1bmN0aW9uKGgsZSl7ZS5yZW1vdmVFbGVtZW50PWZ1bmN0aW9uKHQpe2lmKHQucHJldiYmKHQucHJldi5uZXh0PXQubmV4dCksdC5uZXh0JiYodC5uZXh0LnByZXY9dC5wcmV2KSx0LnBhcmVudCl7dmFyIHI9dC5wYXJlbnQuY2hpbGRyZW47ci5zcGxpY2Uoci5sYXN0SW5kZXhPZih0KSwxKX19LGUucmVwbGFjZUVsZW1lbnQ9ZnVuY3Rpb24odCxyKXt2YXIgcz1yLnByZXY9dC5wcmV2O3MmJihzLm5leHQ9cik7dmFyIG09ci5uZXh0PXQubmV4dDttJiYobS5wcmV2PXIpO3ZhciB5PXIucGFyZW50PXQucGFyZW50O2lmKHkpe3ZhciBjPXkuY2hpbGRyZW47Y1tjLmxhc3RJbmRleE9mKHQpXT1yfX0sZS5hcHBlbmRDaGlsZD1mdW5jdGlvbih0LHIpe2lmKHIucGFyZW50PXQsdC5jaGlsZHJlbi5wdXNoKHIpIT09MSl7dmFyIHM9dC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aC0yXTtzLm5leHQ9cixyLnByZXY9cyxyLm5leHQ9bnVsbH19LGUuYXBwZW5kPWZ1bmN0aW9uKHQscil7dmFyIHM9dC5wYXJlbnQsbT10Lm5leHQ7aWYoci5uZXh0PW0sci5wcmV2PXQsdC5uZXh0PXIsci5wYXJlbnQ9cyxtKXtpZihtLnByZXY9cixzKXt2YXIgeT1zLmNoaWxkcmVuO3kuc3BsaWNlKHkubGFzdEluZGV4T2YobSksMCxyKX19ZWxzZSBzJiZzLmNoaWxkcmVuLnB1c2gocil9LGUucHJlcGVuZD1mdW5jdGlvbih0LHIpe3ZhciBzPXQucGFyZW50O2lmKHMpe3ZhciBtPXMuY2hpbGRyZW47bS5zcGxpY2UobS5sYXN0SW5kZXhPZih0KSwwLHIpfXQucHJldiYmKHQucHJldi5uZXh0PXIpLHIucGFyZW50PXMsci5wcmV2PXQucHJldixyLm5leHQ9dCx0LnByZXY9cn19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDI1NikuaXNUYWc7aC5leHBvcnRzPXtmaWx0ZXI6cyxmaW5kOm0sZmluZE9uZUNoaWxkOnksZmluZE9uZTpjLGV4aXN0c09uZTpsLGZpbmRBbGw6dX07ZnVuY3Rpb24gcyhNLGYsdix4KXtyZXR1cm4gQXJyYXkuaXNBcnJheShmKXx8KGY9W2ZdKSwodHlwZW9mIHghPSJudW1iZXIifHwhaXNGaW5pdGUoeCkpJiYoeD0xLzApLG0oTSxmLHYhPT0hMSx4KX1mdW5jdGlvbiBtKE0sZix2LHgpe2Zvcih2YXIgUj1bXSxPLGc9MCxwPWYubGVuZ3RoO2c8cCYmIShNKGZbZ10pJiYoUi5wdXNoKGZbZ10pLC0teDw9MCl8fChPPWZbZ10uY2hpbGRyZW4sdiYmTyYmTy5sZW5ndGg+MCYmKE89bShNLE8sdix4KSxSPVIuY29uY2F0KE8pLHgtPU8ubGVuZ3RoLHg8PTApKSk7ZysrKTtyZXR1cm4gUn1mdW5jdGlvbiB5KE0sZil7Zm9yKHZhciB2PTAseD1mLmxlbmd0aDt2PHg7disrKWlmKE0oZlt2XSkpcmV0dXJuIGZbdl07cmV0dXJuIG51bGx9ZnVuY3Rpb24gYyhNLGYpe2Zvcih2YXIgdj1udWxsLHg9MCxSPWYubGVuZ3RoO3g8UiYmIXY7eCsrKWlmKHIoZlt4XSkpTShmW3hdKT92PWZbeF06Zlt4XS5jaGlsZHJlbi5sZW5ndGg+MCYmKHY9YyhNLGZbeF0uY2hpbGRyZW4pKTtlbHNlIGNvbnRpbnVlO3JldHVybiB2fWZ1bmN0aW9uIGwoTSxmKXtmb3IodmFyIHY9MCx4PWYubGVuZ3RoO3Y8eDt2KyspaWYocihmW3ZdKSYmKE0oZlt2XSl8fGZbdl0uY2hpbGRyZW4ubGVuZ3RoPjAmJmwoTSxmW3ZdLmNoaWxkcmVuKSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gdShNLGYpe2Zvcih2YXIgdj1bXSx4PWYuc2xpY2UoKTt4Lmxlbmd0aDspe3ZhciBSPXguc2hpZnQoKTtyKFIpJiYoUi5jaGlsZHJlbiYmUi5jaGlsZHJlbi5sZW5ndGg+MCYmeC51bnNoaWZ0LmFwcGx5KHgsUi5jaGlsZHJlbiksTShSKSYmdi5wdXNoKFIpKX1yZXR1cm4gdn19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDI1Nikscz1lLmlzVGFnPXIuaXNUYWc7ZS50ZXN0RWxlbWVudD1mdW5jdGlvbihsLHUpe2Zvcih2YXIgTSBpbiBsKWlmKGwuaGFzT3duUHJvcGVydHkoTSkpe2lmKE09PT0idGFnX25hbWUiKXtpZighcyh1KXx8IWwudGFnX25hbWUodS5uYW1lKSlyZXR1cm4hMX1lbHNlIGlmKE09PT0idGFnX3R5cGUiKXtpZighbC50YWdfdHlwZSh1LnR5cGUpKXJldHVybiExfWVsc2UgaWYoTT09PSJ0YWdfY29udGFpbnMiKXtpZihzKHUpfHwhbC50YWdfY29udGFpbnModS5kYXRhKSlyZXR1cm4hMX1lbHNlIGlmKCF1LmF0dHJpYnN8fCFsW01dKHUuYXR0cmlic1tNXSkpcmV0dXJuITF9cmV0dXJuITB9O3ZhciBtPXt0YWdfbmFtZTpmdW5jdGlvbihsKXtyZXR1cm4gdHlwZW9mIGw9PSJmdW5jdGlvbiI/ZnVuY3Rpb24odSl7cmV0dXJuIHModSkmJmwodS5uYW1lKX06bD09PSIqIj9zOmZ1bmN0aW9uKHUpe3JldHVybiBzKHUpJiZ1Lm5hbWU9PT1sfX0sdGFnX3R5cGU6ZnVuY3Rpb24obCl7cmV0dXJuIHR5cGVvZiBsPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKHUpe3JldHVybiBsKHUudHlwZSl9OmZ1bmN0aW9uKHUpe3JldHVybiB1LnR5cGU9PT1sfX0sdGFnX2NvbnRhaW5zOmZ1bmN0aW9uKGwpe3JldHVybiB0eXBlb2YgbD09ImZ1bmN0aW9uIj9mdW5jdGlvbih1KXtyZXR1cm4hcyh1KSYmbCh1LmRhdGEpfTpmdW5jdGlvbih1KXtyZXR1cm4hcyh1KSYmdS5kYXRhPT09bH19fTtmdW5jdGlvbiB5KGwsdSl7cmV0dXJuIHR5cGVvZiB1PT0iZnVuY3Rpb24iP2Z1bmN0aW9uKE0pe3JldHVybiBNLmF0dHJpYnMmJnUoTS5hdHRyaWJzW2xdKX06ZnVuY3Rpb24oTSl7cmV0dXJuIE0uYXR0cmlicyYmTS5hdHRyaWJzW2xdPT09dX19ZnVuY3Rpb24gYyhsLHUpe3JldHVybiBmdW5jdGlvbihNKXtyZXR1cm4gbChNKXx8dShNKX19ZS5nZXRFbGVtZW50cz1mdW5jdGlvbihsLHUsTSxmKXt2YXIgdj1PYmplY3Qua2V5cyhsKS5tYXAoZnVuY3Rpb24oeCl7dmFyIFI9bFt4XTtyZXR1cm4geCBpbiBtP21beF0oUik6eSh4LFIpfSk7cmV0dXJuIHYubGVuZ3RoPT09MD9bXTp0aGlzLmZpbHRlcih2LnJlZHVjZShjKSx1LE0sZil9LGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24obCx1LE0pe3JldHVybiBBcnJheS5pc0FycmF5KHUpfHwodT1bdV0pLHRoaXMuZmluZE9uZSh5KCJpZCIsbCksdSxNIT09ITEpfSxlLmdldEVsZW1lbnRzQnlUYWdOYW1lPWZ1bmN0aW9uKGwsdSxNLGYpe3JldHVybiB0aGlzLmZpbHRlcihtLnRhZ19uYW1lKGwpLHUsTSxmKX0sZS5nZXRFbGVtZW50c0J5VGFnVHlwZT1mdW5jdGlvbihsLHUsTSxmKXtyZXR1cm4gdGhpcy5maWx0ZXIobS50YWdfdHlwZShsKSx1LE0sZil9fSxmdW5jdGlvbihoLGUpe2UucmVtb3ZlU3Vic2V0cz1mdW5jdGlvbihzKXtmb3IodmFyIG09cy5sZW5ndGgseSxjLGw7LS1tPi0xOyl7Zm9yKHk9Yz1zW21dLHNbbV09bnVsbCxsPSEwO2M7KXtpZihzLmluZGV4T2YoYyk+LTEpe2w9ITEscy5zcGxpY2UobSwxKTticmVha31jPWMucGFyZW50fWwmJihzW21dPXkpfXJldHVybiBzfTt2YXIgdD17RElTQ09OTkVDVEVEOjEsUFJFQ0VESU5HOjIsRk9MTE9XSU5HOjQsQ09OVEFJTlM6OCxDT05UQUlORURfQlk6MTZ9LHI9ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj1mdW5jdGlvbihzLG0pe3ZhciB5PVtdLGM9W10sbCx1LE0sZix2LHg7aWYocz09PW0pcmV0dXJuIDA7Zm9yKGw9cztsOyl5LnVuc2hpZnQobCksbD1sLnBhcmVudDtmb3IobD1tO2w7KWMudW5zaGlmdChsKSxsPWwucGFyZW50O2Zvcih4PTA7eVt4XT09PWNbeF07KXgrKztyZXR1cm4geD09PTA/dC5ESVNDT05ORUNURUQ6KHU9eVt4LTFdLE09dS5jaGlsZHJlbixmPXlbeF0sdj1jW3hdLE0uaW5kZXhPZihmKT5NLmluZGV4T2Yodik/dT09PW0/dC5GT0xMT1dJTkd8dC5DT05UQUlORURfQlk6dC5GT0xMT1dJTkc6dT09PXM/dC5QUkVDRURJTkd8dC5DT05UQUlOUzp0LlBSRUNFRElORyl9O2UudW5pcXVlU29ydD1mdW5jdGlvbihzKXt2YXIgbT1zLmxlbmd0aCx5LGM7Zm9yKHM9cy5zbGljZSgpOy0tbT4tMTspeT1zW21dLGM9cy5pbmRleE9mKHkpLGM+LTEmJmM8bSYmcy5zcGxpY2UobSwxKTtyZXR1cm4gcy5zb3J0KGZ1bmN0aW9uKGwsdSl7dmFyIE09cihsLHUpO3JldHVybiBNJnQuUFJFQ0VESU5HPy0xOk0mdC5GT0xMT1dJTkc/MTowfSksc319LGZ1bmN0aW9uKGgsZSl7aC5leHBvcnRzPXt0cnVlRnVuYzpmdW5jdGlvbigpe3JldHVybiEwfSxmYWxzZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMX19fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPXY7dmFyIHI9dCgyNzUpLnBhcnNlLHM9dCgyNzMpLG09dCgyNzgpLHk9dCgyNzkpLGM9dCgyODApLGw9dCgyODIpLHU9cy50cnVlRnVuYyxNPXMuZmFsc2VGdW5jLGY9bC5maWx0ZXJzO2Z1bmN0aW9uIHYoUCxMLEQpe3ZhciBiPVIoUCxMLEQpO3JldHVybiB4KGIsTCl9ZnVuY3Rpb24geChQLEwpe3ZhciBEPUwuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oUyl7cmV0dXJuIEQuaXNUYWcoUykmJlAoUyl9fWZ1bmN0aW9uIFIoUCxMLEQpe3ZhciBiPXIoUCxMKTtyZXR1cm4gbyhiLEwsRCl9ZnVuY3Rpb24gTyhQKXtyZXR1cm4gUC50eXBlPT09InBzZXVkbyImJihQLm5hbWU9PT0ic2NvcGUifHxBcnJheS5pc0FycmF5KFAuZGF0YSkmJlAuZGF0YS5zb21lKGZ1bmN0aW9uKEwpe3JldHVybiBMLnNvbWUoTyl9KSl9dmFyIGc9e3R5cGU6ImRlc2NlbmRhbnQifSxwPXt0eXBlOiJfZmxleGlibGVEZXNjZW5kYW50In0sbj17dHlwZToicHNldWRvIixuYW1lOiJzY29wZSJ9LGE9e307ZnVuY3Rpb24gaShQLEwsRCl7dmFyIGI9TC5hZGFwdGVyLFM9ISFEJiYhIUQubGVuZ3RoJiZELmV2ZXJ5KGZ1bmN0aW9uKEIpe3JldHVybiBCPT09YXx8ISFiLmdldFBhcmVudChCKX0pO1AuZm9yRWFjaChmdW5jdGlvbihCKXtpZighKEIubGVuZ3RoPjAmJlQoQlswXSkmJkJbMF0udHlwZSE9PSJkZXNjZW5kYW50IikpaWYoUyYmIShBcnJheS5pc0FycmF5KEIpP0Iuc29tZShPKTpPKEIpKSlCLnVuc2hpZnQoZyk7ZWxzZSByZXR1cm47Qi51bnNoaWZ0KG4pfSl9ZnVuY3Rpb24gbyhQLEwsRCl7UD1QLmZpbHRlcihmdW5jdGlvbih3KXtyZXR1cm4gdy5sZW5ndGg+MH0pLFAuZm9yRWFjaChtKTt2YXIgYj1BcnJheS5pc0FycmF5KEQpO0Q9TCYmTC5jb250ZXh0fHxELEQmJiFiJiYoRD1bRF0pLGkoUCxMLEQpO3ZhciBTPSExLEI9UC5tYXAoZnVuY3Rpb24odyl7aWYod1swXSYmd1sxXSYmd1swXS5uYW1lPT09InNjb3BlIil7dmFyIEg9d1sxXS50eXBlO2ImJkg9PT0iZGVzY2VuZGFudCI/d1sxXT1wOihIPT09ImFkamFjZW50Inx8SD09PSJzaWJsaW5nIikmJihTPSEwKX1yZXR1cm4gQSh3LEwsRCl9KS5yZWR1Y2UoQyxNKTtyZXR1cm4gQi5zaG91bGRUZXN0TmV4dFNpYmxpbmdzPVMsQn1mdW5jdGlvbiBUKFApe3JldHVybiB5W1AudHlwZV08MH1mdW5jdGlvbiBBKFAsTCxEKXtyZXR1cm4gUC5yZWR1Y2UoZnVuY3Rpb24oYixTKXtpZihiPT09TSlyZXR1cm4gYjtpZighKFMudHlwZSBpbiBjKSl0aHJvdyBuZXcgRXJyb3IoIlJ1bGUgdHlwZSAiK1MudHlwZSsiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgY3NzLXNlbGVjdCIpO3JldHVybiBjW1MudHlwZV0oYixTLEwsRCl9LEwmJkwucm9vdEZ1bmN8fHUpfWZ1bmN0aW9uIEMoUCxMKXtyZXR1cm4gTD09PU18fFA9PT11P1A6UD09PU18fEw9PT11P0w6ZnVuY3Rpb24oYil7cmV0dXJuIFAoYil8fEwoYil9fWZ1bmN0aW9uIEkoUCl7cmV0dXJuIFAuc29tZShUKX1mLm5vdD1mdW5jdGlvbihQLEwsRCxiKXt2YXIgUz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCksYWRhcHRlcjpELmFkYXB0ZXJ9O2lmKFMuc3RyaWN0JiYoTC5sZW5ndGg+MXx8TC5zb21lKEkpKSl0aHJvdyBuZXcgRXJyb3IoImNvbXBsZXggc2VsZWN0b3JzIGluIDpub3QgYXJlbid0IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUiKTt2YXIgQj1vKEwsUyxiKTtyZXR1cm4gQj09PU0/UDpCPT09dT9NOmZ1bmN0aW9uKEgpe3JldHVybiFCKEgpJiZQKEgpfX0sZi5oYXM9ZnVuY3Rpb24oUCxMLEQpe3ZhciBiPUQuYWRhcHRlcixTPXt4bWxNb2RlOiEhKEQmJkQueG1sTW9kZSksc3RyaWN0OiEhKEQmJkQuc3RyaWN0KSxhZGFwdGVyOmJ9LEI9TC5zb21lKEkpP1thXTpudWxsLHc9byhMLFMsQik7cmV0dXJuIHc9PT1NP006dz09PXU/ZnVuY3Rpb24oSil7cmV0dXJuIGIuZ2V0Q2hpbGRyZW4oSikuc29tZShiLmlzVGFnKSYmUChKKX06KHc9eCh3LEQpLEI/ZnVuY3Rpb24oSil7cmV0dXJuIFAoSikmJihCWzBdPUosYi5leGlzdHNPbmUodyxiLmdldENoaWxkcmVuKEopKSl9OmZ1bmN0aW9uKEope3JldHVybiBQKEopJiZiLmV4aXN0c09uZSh3LGIuZ2V0Q2hpbGRyZW4oSikpfSl9LGYubWF0Y2hlcz1mdW5jdGlvbihQLEwsRCxiKXt2YXIgUz17eG1sTW9kZTohIShEJiZELnhtbE1vZGUpLHN0cmljdDohIShEJiZELnN0cmljdCkscm9vdEZ1bmM6UCxhZGFwdGVyOkQuYWRhcHRlcn07cmV0dXJuIG8oTCxTLGIpfSx2LmNvbXBpbGVUb2tlbj1vLHYuY29tcGlsZVVuc2FmZT1SLHYuUHNldWRvcz1sfSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGMsbCx1LE0pe009PT12b2lkIDAmJihNPXUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLE0se2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGxbdV19fSl9OmZ1bmN0aW9uKGMsbCx1LE0pe009PT12b2lkIDAmJihNPXUpLGNbTV09bFt1XX0pLHM9dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGMsbCl7Zm9yKHZhciB1IGluIGMpdSE9PSJkZWZhdWx0IiYmIWwuaGFzT3duUHJvcGVydHkodSkmJnIobCxjLHUpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSkscyh0KDI3NiksZSk7dmFyIG09dCgyNzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJwYXJzZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG0uZGVmYXVsdH19KTt2YXIgeT10KDI3Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInN0cmluZ2lmeSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHkuZGVmYXVsdH19KX0sZnVuY3Rpb24oaCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9Tzt2YXIgcj0vXlteXFxdPyg/OlxcKD86W1xkYS1mXXsxLDZ9XHM/fC4pfFtcd1wtXHUwMGIwLVx1RkZGRl0pKy8scz0vXFwoW1xkYS1mXXsxLDZ9XHM/fChccyl8LikvZ2ksbT0vXlxzKigoPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSspXHMqKD86KFxTPyk9XHMqKD86KFsnIl0pKFteXSo/KVwzfCgjPyg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKil8KXwpXHMqKGkpP1xdLyx5PXt1bmRlZmluZWQ6ImV4aXN0cyIsIiI6ImVxdWFscyIsIn4iOiJlbGVtZW50IiwiXiI6InN0YXJ0IiwkOiJlbmQiLCIqIjoiYW55IiwiISI6Im5vdCIsInwiOiJoeXBoZW4ifSxjPXsiPiI6ImNoaWxkIiwiPCI6InBhcmVudCIsIn4iOiJzaWJsaW5nIiwiKyI6ImFkamFjZW50In0sbD17IiMiOlsiaWQiLCJlcXVhbHMiXSwiLiI6WyJjbGFzcyIsImVsZW1lbnQiXX0sdT1uZXcgU2V0KFsiaGFzIiwibm90IiwibWF0Y2hlcyJdKSxNPW5ldyBTZXQoWyJjb250YWlucyIsImljb250YWlucyJdKSxmPW5ldyBTZXQoWyciJywiJyJdKTtmdW5jdGlvbiB2KG4sYSxpKXt2YXIgbz1wYXJzZUludChhLDE2KS02NTUzNjtyZXR1cm4gbyE9PW98fGk/YTpvPDA/U3RyaW5nLmZyb21DaGFyQ29kZShvKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKG8+PjEwfDU1Mjk2LG8mMTAyM3w1NjMyMCl9ZnVuY3Rpb24geChuKXtyZXR1cm4gbi5yZXBsYWNlKHMsdil9ZnVuY3Rpb24gUihuKXtyZXR1cm4gbj09PSIgInx8bj09PWAKYHx8bj09PSIJInx8bj09PSJcZiJ8fG49PT0iXHIifWZ1bmN0aW9uIE8obixhKXt2YXIgaT1bXTtpZihuPWcoaSwiIituLGEpLG4hPT0iIil0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBzZWxlY3RvcjogIituKTtyZXR1cm4gaX1mdW5jdGlvbiBnKG4sYSxpKXt2YXIgbz1bXSxUPSExO2Z1bmN0aW9uIEEoKXt2YXIgUT1hLm1hdGNoKHIpO2lmKCFRKXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbmFtZSwgZm91bmQgIithKTt2YXIgdHQ9UVswXTtyZXR1cm4gYT1hLnN1YnN0cih0dC5sZW5ndGgpLHgodHQpfWZ1bmN0aW9uIEMoUSl7Zm9yKDtSKGEuY2hhckF0KFEpKTspUSsrO2E9YS5zdWJzdHIoUSl9ZnVuY3Rpb24gSShRKXtmb3IodmFyIHR0PTA7YS5jaGFyQXQoLS1RKT09PSJcXCI7KXR0Kys7cmV0dXJuKHR0JjEpPT09MX1mb3IoQygwKTthIT09IiI7KXt2YXIgUD1hLmNoYXJBdCgwKTtpZihSKFApKVQ9ITAsQygxKTtlbHNlIGlmKFAgaW4gYylvLnB1c2goe3R5cGU6Y1tQXX0pLFQ9ITEsQygxKTtlbHNlIGlmKFA9PT0iLCIpe2lmKG8ubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO24ucHVzaChvKSxvPVtdLFQ9ITEsQygxKX1lbHNlIGlmKFQmJihvLmxlbmd0aD4wJiZvLnB1c2goe3R5cGU6ImRlc2NlbmRhbnQifSksVD0hMSksUD09PSIqIilhPWEuc3Vic3RyKDEpLG8ucHVzaCh7dHlwZToidW5pdmVyc2FsIn0pO2Vsc2UgaWYoUCBpbiBsKXt2YXIgTD1sW1BdLEQ9TFswXSxiPUxbMV07YT1hLnN1YnN0cigxKSxvLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpELGFjdGlvbjpiLHZhbHVlOkEoKSxpZ25vcmVDYXNlOiExfSl9ZWxzZSBpZihQPT09IlsiKXthPWEuc3Vic3RyKDEpO3ZhciBTPWEubWF0Y2gobSk7aWYoIVMpdGhyb3cgbmV3IEVycm9yKCJNYWxmb3JtZWQgYXR0cmlidXRlIHNlbGVjdG9yOiAiK2EpO2E9YS5zdWJzdHIoU1swXS5sZW5ndGgpO3ZhciBCPXgoU1sxXSk7KCFpfHwoImxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzImluIGk/aS5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lczohaS54bWxNb2RlKSkmJihCPUIudG9Mb3dlckNhc2UoKSksby5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6QixhY3Rpb246eVtTWzJdXSx2YWx1ZTp4KFNbNF18fFNbNV18fCIiKSxpZ25vcmVDYXNlOiEhU1s2XX0pfWVsc2UgaWYoUD09PSI6Iil7aWYoYS5jaGFyQXQoMSk9PT0iOiIpe2E9YS5zdWJzdHIoMiksby5wdXNoKHt0eXBlOiJwc2V1ZG8tZWxlbWVudCIsbmFtZTpBKCkudG9Mb3dlckNhc2UoKX0pO2NvbnRpbnVlfWE9YS5zdWJzdHIoMSk7dmFyIHc9QSgpLnRvTG93ZXJDYXNlKCksUz1udWxsO2lmKGEuY2hhckF0KDApPT09IigiKWlmKHUuaGFzKHcpKXt2YXIgSD1hLmNoYXJBdCgxKSxKPWYuaGFzKEgpO2lmKGE9YS5zdWJzdHIoSj8yOjEpLFM9W10sYT1nKFMsYSxpKSxKKXtpZihhLmNoYXJBdCgwKSE9PUgpdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgcXVvdGVzIGluIDoiK3cpO2E9YS5zdWJzdHIoMSl9aWYoYS5jaGFyQXQoMCkhPT0iKSIpdGhyb3cgbmV3IEVycm9yKCJNaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMgaW4gOiIrdysiICgiK2ErIikiKTthPWEuc3Vic3RyKDEpfWVsc2V7Zm9yKHZhciBxPTEsVz0xO1c+MCYmcTxhLmxlbmd0aDtxKyspYS5jaGFyQXQocSk9PT0iKCImJiFJKHEpP1crKzphLmNoYXJBdChxKT09PSIpIiYmIUkocSkmJlctLTtpZihXKXRocm93IG5ldyBFcnJvcigiUGFyZW50aGVzaXMgbm90IG1hdGNoZWQiKTtpZihTPWEuc3Vic3RyKDEscS0yKSxhPWEuc3Vic3RyKHEpLE0uaGFzKHcpKXt2YXIgSD1TLmNoYXJBdCgwKTtIPT09Uy5zbGljZSgtMSkmJmYuaGFzKEgpJiYoUz1TLnNsaWNlKDEsLTEpKSxTPXgoUyl9fW8ucHVzaCh7dHlwZToicHNldWRvIixuYW1lOncsZGF0YTpTfSl9ZWxzZSBpZihyLnRlc3QoYSkpe3ZhciBHPUEoKTsoIWl8fCgibG93ZXJDYXNlVGFncyJpbiBpP2kubG93ZXJDYXNlVGFnczohaS54bWxNb2RlKSkmJihHPUcudG9Mb3dlckNhc2UoKSksby5wdXNoKHt0eXBlOiJ0YWciLG5hbWU6R30pfWVsc2UgcmV0dXJuIG8ubGVuZ3RoJiZvW28ubGVuZ3RoLTFdLnR5cGU9PT0iZGVzY2VuZGFudCImJm8ucG9wKCkscChuLG8pLGF9cmV0dXJuIHAobixvKSxhfWZ1bmN0aW9uIHAobixhKXtpZihuLmxlbmd0aD4wJiZhLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtuLnB1c2goYSl9fSxmdW5jdGlvbihoLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXtlcXVhbHM6IiIsZWxlbWVudDoifiIsc3RhcnQ6Il4iLGVuZDoiJCIsYW55OiIqIixub3Q6IiEiLGh5cGhlbjoifCJ9O2Z1bmN0aW9uIHMobCl7cmV0dXJuIGwubWFwKG0pLmpvaW4oIiwgIil9ZS5kZWZhdWx0PXM7ZnVuY3Rpb24gbShsKXtyZXR1cm4gbC5tYXAoeSkuam9pbigiIil9ZnVuY3Rpb24geShsKXtzd2l0Y2gobC50eXBlKXtjYXNlImNoaWxkIjpyZXR1cm4iID4gIjtjYXNlInBhcmVudCI6cmV0dXJuIiA8ICI7Y2FzZSJzaWJsaW5nIjpyZXR1cm4iIH4gIjtjYXNlImFkamFjZW50IjpyZXR1cm4iICsgIjtjYXNlImRlc2NlbmRhbnQiOnJldHVybiIgIjtjYXNlInVuaXZlcnNhbCI6cmV0dXJuIioiO2Nhc2UidGFnIjpyZXR1cm4gbC5uYW1lO2Nhc2UicHNldWRvLWVsZW1lbnQiOnJldHVybiI6OiIrbC5uYW1lO2Nhc2UicHNldWRvIjpyZXR1cm4gbC5kYXRhPT09bnVsbD8iOiIrbC5uYW1lOnR5cGVvZiBsLmRhdGE9PSJzdHJpbmciPyI6IitsLm5hbWUrIigiK2wuZGF0YSsiKSI6IjoiK2wubmFtZSsiKCIrcyhsLmRhdGEpKyIpIjtjYXNlImF0dHJpYnV0ZSI6cmV0dXJuIGwuYWN0aW9uPT09ImV4aXN0cyI/IlsiK2wubmFtZSsiXSI6bC5uYW1lPT09ImlkIiYmbC5hY3Rpb249PT0iZXF1YWxzIiYmIWwuaWdub3JlQ2FzZT8iIyIrbC52YWx1ZTpsLm5hbWU9PT0iY2xhc3MiJiZsLmFjdGlvbj09PSJlbGVtZW50IiYmIWwuaWdub3JlQ2FzZT8iLiIrbC52YWx1ZToiWyIrbC5uYW1lK3JbbC5hY3Rpb25dKyI9JyIrbC52YWx1ZSsiJyIrKGwuaWdub3JlQ2FzZT8iaSI6IiIpKyJdIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5rbm93biB0eXBlIil9fWZ1bmN0aW9uIGMobCl7cmV0dXJuIGx9fSxmdW5jdGlvbihoLGUsdCl7aC5leHBvcnRzPW07dmFyIHI9dCgyNzkpLHM9e19fcHJvdG9fXzpudWxsLGV4aXN0czoxMCxlcXVhbHM6OCxub3Q6NyxzdGFydDo2LGVuZDo2LGFueTo1LGh5cGhlbjo0LGVsZW1lbnQ6NH07ZnVuY3Rpb24gbShjKXtmb3IodmFyIGw9Yy5tYXAoeSksdT0xO3U8Yy5sZW5ndGg7dSsrKXt2YXIgTT1sW3VdO2lmKCEoTTwwKSlmb3IodmFyIGY9dS0xO2Y+PTAmJk08bFtmXTtmLS0pe3ZhciB2PWNbZisxXTtjW2YrMV09Y1tmXSxjW2ZdPXYsbFtmKzFdPWxbZl0sbFtmXT1NfX19ZnVuY3Rpb24geShjKXt2YXIgbD1yW2MudHlwZV07aWYobD09PXIuYXR0cmlidXRlKWw9c1tjLmFjdGlvbl0sbD09PXMuZXF1YWxzJiZjLm5hbWU9PT0iaWQiJiYobD05KSxjLmlnbm9yZUNhc2UmJihsPj49MSk7ZWxzZSBpZihsPT09ci5wc2V1ZG8paWYoIWMuZGF0YSlsPTM7ZWxzZSBpZihjLm5hbWU9PT0iaGFzInx8Yy5uYW1lPT09ImNvbnRhaW5zIilsPTA7ZWxzZSBpZihjLm5hbWU9PT0ibWF0Y2hlcyJ8fGMubmFtZT09PSJub3QiKXtsPTA7Zm9yKHZhciB1PTA7dTxjLmRhdGEubGVuZ3RoO3UrKylpZihjLmRhdGFbdV0ubGVuZ3RoPT09MSl7dmFyIE09eShjLmRhdGFbdV1bMF0pO2lmKE09PT0wKXtsPTA7YnJlYWt9TT5sJiYobD1NKX1jLmRhdGEubGVuZ3RoPjEmJmw+MCYmKGwtPTEpfWVsc2UgbD0xO3JldHVybiBsfX0sZnVuY3Rpb24oaCl7aC5leHBvcnRzPUpTT04ucGFyc2UoJ3sidW5pdmVyc2FsIjo1MCwidGFnIjozMCwiYXR0cmlidXRlIjoxLCJwc2V1ZG8iOjAsImRlc2NlbmRhbnQiOi0xLCJjaGlsZCI6LTEsInBhcmVudCI6LTEsInNpYmxpbmciOi0xLCJhZGphY2VudCI6LTF9Jyl9LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDI4MSkscz10KDI4Mik7aC5leHBvcnRzPXtfX3Byb3RvX186bnVsbCxhdHRyaWJ1dGU6ci5jb21waWxlLHBzZXVkbzpzLmNvbXBpbGUsdGFnOmZ1bmN0aW9uKG0seSxjKXt2YXIgbD15Lm5hbWUsdT1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiB1LmdldE5hbWUoZik9PT1sJiZtKGYpfX0sZGVzY2VuZGFudDpmdW5jdGlvbihtLHksYyl7dmFyIGw9dHlwZW9mIFdlYWtTZXQ8InUiP25ldyBXZWFrU2V0Om51bGwsdT1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGYpe2Zvcih2YXIgdj0hMTshdiYmKGY9dS5nZXRQYXJlbnQoZikpOykoIWx8fCFsLmhhcyhmKSkmJih2PW0oZiksIXYmJmwmJmwuYWRkKGYpKTtyZXR1cm4gdn19LF9mbGV4aWJsZURlc2NlbmRhbnQ6ZnVuY3Rpb24obSx5LGMpe3ZhciBsPWMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oTSl7Zm9yKHZhciBmPW0oTSk7IWYmJihNPWwuZ2V0UGFyZW50KE0pKTspZj1tKE0pO3JldHVybiBmfX0scGFyZW50OmZ1bmN0aW9uKG0seSxjKXtpZihjJiZjLnN0cmljdCl0aHJvdyBuZXcgRXJyb3IoIlBhcmVudCBzZWxlY3RvciBpc24ndCBwYXJ0IG9mIENTUzMiKTt2YXIgbD1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiBsLmdldENoaWxkcmVuKGYpLnNvbWUodSl9O2Z1bmN0aW9uIHUoTSl7cmV0dXJuIGwuaXNUYWcoTSkmJm0oTSl9fSxjaGlsZDpmdW5jdGlvbihtLHksYyl7dmFyIGw9Yy5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihNKXt2YXIgZj1sLmdldFBhcmVudChNKTtyZXR1cm4hIWYmJm0oZil9fSxzaWJsaW5nOmZ1bmN0aW9uKG0seSxjKXt2YXIgbD1jLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKE0pe2Zvcih2YXIgZj1sLmdldFNpYmxpbmdzKE0pLHY9MDt2PGYubGVuZ3RoO3YrKylpZihsLmlzVGFnKGZbdl0pKXtpZihmW3ZdPT09TSlicmVhaztpZihtKGZbdl0pKXJldHVybiEwfXJldHVybiExfX0sYWRqYWNlbnQ6ZnVuY3Rpb24obSx5LGMpe3ZhciBsPWMuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oTSl7Zm9yKHZhciBmPWwuZ2V0U2libGluZ3MoTSksdix4PTA7eDxmLmxlbmd0aDt4KyspaWYobC5pc1RhZyhmW3hdKSl7aWYoZlt4XT09PU0pYnJlYWs7dj1mW3hdfXJldHVybiEhdiYmbSh2KX19LHVuaXZlcnNhbDpmdW5jdGlvbihtKXtyZXR1cm4gbX19fSxmdW5jdGlvbihoLGUsdCl7dmFyIHI9dCgyNzMpLmZhbHNlRnVuYyxzPS9bLVtcXXt9KCkqKz8uLFxcXiR8I1xzXS9nLG09e19fcHJvdG9fXzpudWxsLGVxdWFsczpmdW5jdGlvbih5LGMsbCl7dmFyIHU9Yy5uYW1lLE09Yy52YWx1ZSxmPWwuYWRhcHRlcjtyZXR1cm4gYy5pZ25vcmVDYXNlPyhNPU0udG9Mb3dlckNhc2UoKSxmdW5jdGlvbih4KXt2YXIgUj1mLmdldEF0dHJpYnV0ZVZhbHVlKHgsdSk7cmV0dXJuIFIhPW51bGwmJlIudG9Mb3dlckNhc2UoKT09PU0mJnkoeCl9KTpmdW5jdGlvbih4KXtyZXR1cm4gZi5nZXRBdHRyaWJ1dGVWYWx1ZSh4LHUpPT09TSYmeSh4KX19LGh5cGhlbjpmdW5jdGlvbih5LGMsbCl7dmFyIHU9Yy5uYW1lLE09Yy52YWx1ZSxmPU0ubGVuZ3RoLHY9bC5hZGFwdGVyO3JldHVybiBjLmlnbm9yZUNhc2U/KE09TS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKFIpe3ZhciBPPXYuZ2V0QXR0cmlidXRlVmFsdWUoUix1KTtyZXR1cm4gTyE9bnVsbCYmKE8ubGVuZ3RoPT09Znx8Ty5jaGFyQXQoZik9PT0iLSIpJiZPLnN1YnN0cigwLGYpLnRvTG93ZXJDYXNlKCk9PT1NJiZ5KFIpfSk6ZnVuY3Rpb24oUil7dmFyIE89di5nZXRBdHRyaWJ1dGVWYWx1ZShSLHUpO3JldHVybiBPIT1udWxsJiZPLnN1YnN0cigwLGYpPT09TSYmKE8ubGVuZ3RoPT09Znx8Ty5jaGFyQXQoZik9PT0iLSIpJiZ5KFIpfX0sZWxlbWVudDpmdW5jdGlvbih5LGMsbCl7dmFyIHU9Yy5uYW1lLE09Yy52YWx1ZSxmPWwuYWRhcHRlcjtpZigvXHMvLnRlc3QoTSkpcmV0dXJuIHI7TT1NLnJlcGxhY2UocywiXFwkJiIpO3ZhciB2PSIoPzpefFxccykiK00rIig/OiR8XFxzKSIseD1jLmlnbm9yZUNhc2U/ImkiOiIiLFI9bmV3IFJlZ0V4cCh2LHgpO3JldHVybiBmdW5jdGlvbihnKXt2YXIgcD1mLmdldEF0dHJpYnV0ZVZhbHVlKGcsdSk7cmV0dXJuIHAhPW51bGwmJlIudGVzdChwKSYmeShnKX19LGV4aXN0czpmdW5jdGlvbih5LGMsbCl7dmFyIHU9Yy5uYW1lLE09bC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbih2KXtyZXR1cm4gTS5oYXNBdHRyaWIodix1KSYmeSh2KX19LHN0YXJ0OmZ1bmN0aW9uKHksYyxsKXt2YXIgdT1jLm5hbWUsTT1jLnZhbHVlLGY9TS5sZW5ndGgsdj1sLmFkYXB0ZXI7cmV0dXJuIGY9PT0wP3I6Yy5pZ25vcmVDYXNlPyhNPU0udG9Mb3dlckNhc2UoKSxmdW5jdGlvbihSKXt2YXIgTz12LmdldEF0dHJpYnV0ZVZhbHVlKFIsdSk7cmV0dXJuIE8hPW51bGwmJk8uc3Vic3RyKDAsZikudG9Mb3dlckNhc2UoKT09PU0mJnkoUil9KTpmdW5jdGlvbihSKXt2YXIgTz12LmdldEF0dHJpYnV0ZVZhbHVlKFIsdSk7cmV0dXJuIE8hPW51bGwmJk8uc3Vic3RyKDAsZik9PT1NJiZ5KFIpfX0sZW5kOmZ1bmN0aW9uKHksYyxsKXt2YXIgdT1jLm5hbWUsTT1jLnZhbHVlLGY9LU0ubGVuZ3RoLHY9bC5hZGFwdGVyO3JldHVybiBmPT09MD9yOmMuaWdub3JlQ2FzZT8oTT1NLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oUil7dmFyIE89di5nZXRBdHRyaWJ1dGVWYWx1ZShSLHUpO3JldHVybiBPIT1udWxsJiZPLnN1YnN0cihmKS50b0xvd2VyQ2FzZSgpPT09TSYmeShSKX0pOmZ1bmN0aW9uKFIpe3ZhciBPPXYuZ2V0QXR0cmlidXRlVmFsdWUoUix1KTtyZXR1cm4gTyE9bnVsbCYmTy5zdWJzdHIoZik9PT1NJiZ5KFIpfX0sYW55OmZ1bmN0aW9uKHksYyxsKXt2YXIgdT1jLm5hbWUsTT1jLnZhbHVlLGY9bC5hZGFwdGVyO2lmKE09PT0iIilyZXR1cm4gcjtpZihjLmlnbm9yZUNhc2Upe3ZhciB2PW5ldyBSZWdFeHAoTS5yZXBsYWNlKHMsIlxcJCYiKSwiaSIpO3JldHVybiBmdW5jdGlvbihSKXt2YXIgTz1mLmdldEF0dHJpYnV0ZVZhbHVlKFIsdSk7cmV0dXJuIE8hPW51bGwmJnYudGVzdChPKSYmeShSKX19cmV0dXJuIGZ1bmN0aW9uKFIpe3ZhciBPPWYuZ2V0QXR0cmlidXRlVmFsdWUoUix1KTtyZXR1cm4gTyE9bnVsbCYmTy5pbmRleE9mKE0pPj0wJiZ5KFIpfX0sbm90OmZ1bmN0aW9uKHksYyxsKXt2YXIgdT1jLm5hbWUsTT1jLnZhbHVlLGY9bC5hZGFwdGVyO3JldHVybiBNPT09IiI/ZnVuY3Rpb24oeCl7cmV0dXJuISFmLmdldEF0dHJpYnV0ZVZhbHVlKHgsdSkmJnkoeCl9OmMuaWdub3JlQ2FzZT8oTT1NLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oeCl7dmFyIFI9Zi5nZXRBdHRyaWJ1dGVWYWx1ZSh4LHUpO3JldHVybiBSIT1udWxsJiZSLnRvTG93ZXJDYXNlKCkhPT1NJiZ5KHgpfSk6ZnVuY3Rpb24oeCl7cmV0dXJuIGYuZ2V0QXR0cmlidXRlVmFsdWUoeCx1KSE9PU0mJnkoeCl9fX07aC5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKHksYyxsKXtpZihsJiZsLnN0cmljdCYmKGMuaWdub3JlQ2FzZXx8Yy5hY3Rpb249PT0ibm90IikpdGhyb3cgbmV3IEVycm9yKCJVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgc2VsZWN0b3IiKTtyZXR1cm4gbVtjLmFjdGlvbl0oeSxjLGwpfSxydWxlczptfX0sZnVuY3Rpb24oaCxlLHQpe3ZhciByPXQoMjgzKSxzPXQoMjczKSxtPXQoMjgxKSx5PXMudHJ1ZUZ1bmMsYz1zLmZhbHNlRnVuYyxsPW0ucnVsZXMuZXF1YWxzO2Z1bmN0aW9uIHUocCxuKXt2YXIgYT17bmFtZTpwLHZhbHVlOm59O3JldHVybiBmdW5jdGlvbihvLFQsQSl7cmV0dXJuIGwobyxhLEEpfX1mdW5jdGlvbiBNKHAsbil7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiEhbi5nZXRQYXJlbnQoYSkmJnAoYSl9fXZhciBmPXtjb250YWluczpmdW5jdGlvbihwLG4sYSl7dmFyIGk9YS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihUKXtyZXR1cm4gcChUKSYmaS5nZXRUZXh0KFQpLmluZGV4T2Yobik+PTB9fSxpY29udGFpbnM6ZnVuY3Rpb24ocCxuLGEpe3ZhciBpPW4udG9Mb3dlckNhc2UoKSxvPWEuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oQSl7cmV0dXJuIHAoQSkmJm8uZ2V0VGV4dChBKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoaSk+PTB9fSwibnRoLWNoaWxkIjpmdW5jdGlvbihwLG4sYSl7dmFyIGk9cihuKSxvPWEuYWRhcHRlcjtyZXR1cm4gaT09PWM/aTppPT09eT9NKHAsbyk6ZnVuY3Rpb24oQSl7Zm9yKHZhciBDPW8uZ2V0U2libGluZ3MoQSksST0wLFA9MDtJPEMubGVuZ3RoO0krKylpZihvLmlzVGFnKENbSV0pKXtpZihDW0ldPT09QSlicmVhaztQKyt9cmV0dXJuIGkoUCkmJnAoQSl9fSwibnRoLWxhc3QtY2hpbGQiOmZ1bmN0aW9uKHAsbixhKXt2YXIgaT1yKG4pLG89YS5hZGFwdGVyO3JldHVybiBpPT09Yz9pOmk9PT15P00ocCxvKTpmdW5jdGlvbihBKXtmb3IodmFyIEM9by5nZXRTaWJsaW5ncyhBKSxJPTAsUD1DLmxlbmd0aC0xO1A+PTA7UC0tKWlmKG8uaXNUYWcoQ1tQXSkpe2lmKENbUF09PT1BKWJyZWFrO0krK31yZXR1cm4gaShJKSYmcChBKX19LCJudGgtb2YtdHlwZSI6ZnVuY3Rpb24ocCxuLGEpe3ZhciBpPXIobiksbz1hLmFkYXB0ZXI7cmV0dXJuIGk9PT1jP2k6aT09PXk/TShwLG8pOmZ1bmN0aW9uKEEpe2Zvcih2YXIgQz1vLmdldFNpYmxpbmdzKEEpLEk9MCxQPTA7UDxDLmxlbmd0aDtQKyspaWYoby5pc1RhZyhDW1BdKSl7aWYoQ1tQXT09PUEpYnJlYWs7by5nZXROYW1lKENbUF0pPT09by5nZXROYW1lKEEpJiZJKyt9cmV0dXJuIGkoSSkmJnAoQSl9fSwibnRoLWxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24ocCxuLGEpe3ZhciBpPXIobiksbz1hLmFkYXB0ZXI7cmV0dXJuIGk9PT1jP2k6aT09PXk/TShwLG8pOmZ1bmN0aW9uKEEpe2Zvcih2YXIgQz1vLmdldFNpYmxpbmdzKEEpLEk9MCxQPUMubGVuZ3RoLTE7UD49MDtQLS0paWYoby5pc1RhZyhDW1BdKSl7aWYoQ1tQXT09PUEpYnJlYWs7by5nZXROYW1lKENbUF0pPT09by5nZXROYW1lKEEpJiZJKyt9cmV0dXJuIGkoSSkmJnAoQSl9fSxyb290OmZ1bmN0aW9uKHAsbixhKXt2YXIgaT1hLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKG8pe3JldHVybiFpLmdldFBhcmVudChvKSYmcChvKX19LHNjb3BlOmZ1bmN0aW9uKHAsbixhLGkpe3ZhciBvPWEuYWRhcHRlcjtpZighaXx8aS5sZW5ndGg9PT0wKXJldHVybiBmLnJvb3QocCxuLGEpO2Z1bmN0aW9uIFQoQSxDKXtyZXR1cm4gdHlwZW9mIG8uZXF1YWxzPT0iZnVuY3Rpb24iP28uZXF1YWxzKEEsQyk6QT09PUN9cmV0dXJuIGkubGVuZ3RoPT09MT9mdW5jdGlvbihBKXtyZXR1cm4gVChpWzBdLEEpJiZwKEEpfTpmdW5jdGlvbihBKXtyZXR1cm4gaS5pbmRleE9mKEEpPj0wJiZwKEEpfX0sY2hlY2tib3g6dSgidHlwZSIsImNoZWNrYm94IiksZmlsZTp1KCJ0eXBlIiwiZmlsZSIpLHBhc3N3b3JkOnUoInR5cGUiLCJwYXNzd29yZCIpLHJhZGlvOnUoInR5cGUiLCJyYWRpbyIpLHJlc2V0OnUoInR5cGUiLCJyZXNldCIpLGltYWdlOnUoInR5cGUiLCJpbWFnZSIpLHN1Ym1pdDp1KCJ0eXBlIiwic3VibWl0IiksaG92ZXI6ZnVuY3Rpb24ocCxuLGEpe3ZhciBpPWEuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGkuaXNIb3ZlcmVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKFQpe3JldHVybiBwKFQpJiZpLmlzSG92ZXJlZChUKX06Y30sdmlzaXRlZDpmdW5jdGlvbihwLG4sYSl7dmFyIGk9YS5hZGFwdGVyO3JldHVybiB0eXBlb2YgaS5pc1Zpc2l0ZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oVCl7cmV0dXJuIHAoVCkmJmkuaXNWaXNpdGVkKFQpfTpjfSxhY3RpdmU6ZnVuY3Rpb24ocCxuLGEpe3ZhciBpPWEuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIGkuaXNBY3RpdmU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oVCl7cmV0dXJuIHAoVCkmJmkuaXNBY3RpdmUoVCl9OmN9fTtmdW5jdGlvbiB2KHAsbil7Zm9yKHZhciBhPTA7cCYmYTxwLmxlbmd0aDthKyspaWYobi5pc1RhZyhwW2FdKSlyZXR1cm4gcFthXX12YXIgeD17ZW1wdHk6ZnVuY3Rpb24ocCxuKXtyZXR1cm4hbi5nZXRDaGlsZHJlbihwKS5zb21lKGZ1bmN0aW9uKGEpe3JldHVybiBuLmlzVGFnKGEpfHxhLnR5cGU9PT0idGV4dCJ9KX0sImZpcnN0LWNoaWxkIjpmdW5jdGlvbihwLG4pe3JldHVybiB2KG4uZ2V0U2libGluZ3MocCksbik9PT1wfSwibGFzdC1jaGlsZCI6ZnVuY3Rpb24ocCxuKXtmb3IodmFyIGE9bi5nZXRTaWJsaW5ncyhwKSxpPWEubGVuZ3RoLTE7aT49MDtpLS0pe2lmKGFbaV09PT1wKXJldHVybiEwO2lmKG4uaXNUYWcoYVtpXSkpYnJlYWt9cmV0dXJuITF9LCJmaXJzdC1vZi10eXBlIjpmdW5jdGlvbihwLG4pe2Zvcih2YXIgYT1uLmdldFNpYmxpbmdzKHApLGk9MDtpPGEubGVuZ3RoO2krKylpZihuLmlzVGFnKGFbaV0pKXtpZihhW2ldPT09cClyZXR1cm4hMDtpZihuLmdldE5hbWUoYVtpXSk9PT1uLmdldE5hbWUocCkpYnJlYWt9cmV0dXJuITF9LCJsYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKHAsbil7Zm9yKHZhciBhPW4uZ2V0U2libGluZ3MocCksaT1hLmxlbmd0aC0xO2k+PTA7aS0tKWlmKG4uaXNUYWcoYVtpXSkpe2lmKGFbaV09PT1wKXJldHVybiEwO2lmKG4uZ2V0TmFtZShhW2ldKT09PW4uZ2V0TmFtZShwKSlicmVha31yZXR1cm4hMX0sIm9ubHktb2YtdHlwZSI6ZnVuY3Rpb24ocCxuKXtmb3IodmFyIGE9bi5nZXRTaWJsaW5ncyhwKSxpPTAsbz1hLmxlbmd0aDtpPG87aSsrKWlmKG4uaXNUYWcoYVtpXSkpe2lmKGFbaV09PT1wKWNvbnRpbnVlO2lmKG4uZ2V0TmFtZShhW2ldKT09PW4uZ2V0TmFtZShwKSlyZXR1cm4hMX1yZXR1cm4hMH0sIm9ubHktY2hpbGQiOmZ1bmN0aW9uKHAsbil7Zm9yKHZhciBhPW4uZ2V0U2libGluZ3MocCksaT0wO2k8YS5sZW5ndGg7aSsrKWlmKG4uaXNUYWcoYVtpXSkmJmFbaV0hPT1wKXJldHVybiExO3JldHVybiEwfSxsaW5rOmZ1bmN0aW9uKHAsbil7cmV0dXJuIG4uaGFzQXR0cmliKHAsImhyZWYiKX0sc2VsZWN0ZWQ6ZnVuY3Rpb24ocCxuKXtpZihuLmhhc0F0dHJpYihwLCJzZWxlY3RlZCIpKXJldHVybiEwO2lmKG4uZ2V0TmFtZShwKSE9PSJvcHRpb24iKXJldHVybiExO3ZhciBhPW4uZ2V0UGFyZW50KHApO2lmKCFhfHxuLmdldE5hbWUoYSkhPT0ic2VsZWN0Inx8bi5oYXNBdHRyaWIoYSwibXVsdGlwbGUiKSlyZXR1cm4hMTtmb3IodmFyIGk9bi5nZXRDaGlsZHJlbihhKSxvPSExLFQ9MDtUPGkubGVuZ3RoO1QrKylpZihuLmlzVGFnKGlbVF0pKWlmKGlbVF09PT1wKW89ITA7ZWxzZSBpZihvKXtpZihuLmhhc0F0dHJpYihpW1RdLCJzZWxlY3RlZCIpKXJldHVybiExfWVsc2UgcmV0dXJuITE7cmV0dXJuIG99LGRpc2FibGVkOmZ1bmN0aW9uKHAsbil7cmV0dXJuIG4uaGFzQXR0cmliKHAsImRpc2FibGVkIil9LGVuYWJsZWQ6ZnVuY3Rpb24ocCxuKXtyZXR1cm4hbi5oYXNBdHRyaWIocCwiZGlzYWJsZWQiKX0sY2hlY2tlZDpmdW5jdGlvbihwLG4pe3JldHVybiBuLmhhc0F0dHJpYihwLCJjaGVja2VkIil8fHguc2VsZWN0ZWQocCxuKX0scmVxdWlyZWQ6ZnVuY3Rpb24ocCxuKXtyZXR1cm4gbi5oYXNBdHRyaWIocCwicmVxdWlyZWQiKX0sb3B0aW9uYWw6ZnVuY3Rpb24ocCxuKXtyZXR1cm4hbi5oYXNBdHRyaWIocCwicmVxdWlyZWQiKX0scGFyZW50OmZ1bmN0aW9uKHAsbil7cmV0dXJuIXguZW1wdHkocCxuKX0saGVhZGVyOlIoWyJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiXSksYnV0dG9uOmZ1bmN0aW9uKHAsbil7dmFyIGE9bi5nZXROYW1lKHApO3JldHVybiBhPT09ImJ1dHRvbiJ8fGE9PT0iaW5wdXQiJiZuLmdldEF0dHJpYnV0ZVZhbHVlKHAsInR5cGUiKT09PSJidXR0b24ifSxpbnB1dDpSKFsiaW5wdXQiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsImJ1dHRvbiJdKSx0ZXh0OmZ1bmN0aW9uKHAsbil7dmFyIGE7cmV0dXJuIG4uZ2V0TmFtZShwKT09PSJpbnB1dCImJighKGE9bi5nZXRBdHRyaWJ1dGVWYWx1ZShwLCJ0eXBlIikpfHxhLnRvTG93ZXJDYXNlKCk9PT0idGV4dCIpfX07ZnVuY3Rpb24gUihwKXtpZih0eXBlb2YgU2V0PCJ1Iil7dmFyIG49bmV3IFNldChwKTtyZXR1cm4gZnVuY3Rpb24oYSxpKXtyZXR1cm4gbi5oYXMoaS5nZXROYW1lKGEpKX19cmV0dXJuIGZ1bmN0aW9uKGEsaSl7cmV0dXJuIHAuaW5kZXhPZihpLmdldE5hbWUoYSkpPj0wfX1mdW5jdGlvbiBPKHAsbixhKXtpZihhPT09bnVsbCl7aWYocC5sZW5ndGg+MiYmbiE9PSJzY29wZSIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIrbisiIHJlcXVpcmVzIGFuIGFyZ3VtZW50Iil9ZWxzZSBpZihwLmxlbmd0aD09PTIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIrbisiIGRvZXNuJ3QgaGF2ZSBhbnkgYXJndW1lbnRzIil9dmFyIGc9L14oPzooPzpudGh8bGFzdHxmaXJzdHxvbmx5KS0oPzpjaGlsZHxvZi10eXBlKXxyb290fGVtcHR5fCg/OmVufGRpcylhYmxlZHxjaGVja2VkfG5vdCkkLztoLmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24ocCxuLGEsaSl7dmFyIG89bi5uYW1lLFQ9bi5kYXRhLEE9YS5hZGFwdGVyO2lmKGEmJmEuc3RyaWN0JiYhZy50ZXN0KG8pKXRocm93IG5ldyBFcnJvcigiOiIrbysiIGlzbid0IHBhcnQgb2YgQ1NTMyIpO2lmKHR5cGVvZiBmW29dPT0iZnVuY3Rpb24iKXJldHVybiBmW29dKHAsVCxhLGkpO2lmKHR5cGVvZiB4W29dPT0iZnVuY3Rpb24iKXt2YXIgQz14W29dO3JldHVybiBPKEMsbyxUKSxDPT09Yz9DOnA9PT15P2Z1bmN0aW9uKFApe3JldHVybiBDKFAsQSxUKX06ZnVuY3Rpb24oUCl7cmV0dXJuIEMoUCxBLFQpJiZwKFApfX1lbHNlIHRocm93IG5ldyBFcnJvcigidW5tYXRjaGVkIHBzZXVkby1jbGFzcyA6IitvKX0sZmlsdGVyczpmLHBzZXVkb3M6eH19LGZ1bmN0aW9uKGgsZSx0KXt2YXIgcj10KDI4NCkscz10KDI4NSk7aC5leHBvcnRzPWZ1bmN0aW9uKHkpe3JldHVybiBzKHIoeSkpfSxoLmV4cG9ydHMucGFyc2U9cixoLmV4cG9ydHMuY29tcGlsZT1zfSxmdW5jdGlvbihoLGUpe2guZXhwb3J0cz1yO3ZhciB0PS9eKFsrXC1dP1xkKm4pP1xzKig/OihbK1wtXT8pXHMqKFxkKykpPyQvO2Z1bmN0aW9uIHIocyl7aWYocz1zLnRyaW0oKS50b0xvd2VyQ2FzZSgpLHM9PT0iZXZlbiIpcmV0dXJuWzIsMF07aWYocz09PSJvZGQiKXJldHVyblsyLDFdO3ZhciBtPXMubWF0Y2godCk7aWYoIW0pdGhyb3cgbmV3IFN5bnRheEVycm9yKCJuLXRoIHJ1bGUgY291bGRuJ3QgYmUgcGFyc2VkICgnIitzKyInKSIpO3ZhciB5O3JldHVybiBtWzFdPyh5PXBhcnNlSW50KG1bMV0sMTApLGlzTmFOKHkpJiYobVsxXS5jaGFyQXQoMCk9PT0iLSI/eT0tMTp5PTEpKTp5PTAsW3ksbVszXT9wYXJzZUludCgobVsyXXx8IiIpK21bM10sMTApOjBdfX0sZnVuY3Rpb24oaCxlLHQpe2guZXhwb3J0cz15O3ZhciByPXQoMjczKSxzPXIudHJ1ZUZ1bmMsbT1yLmZhbHNlRnVuYztmdW5jdGlvbiB5KGMpe3ZhciBsPWNbMF0sdT1jWzFdLTE7aWYodTwwJiZsPD0wKXJldHVybiBtO2lmKGw9PT0tMSlyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIGY8PXV9O2lmKGw9PT0wKXJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gZj09PXV9O2lmKGw9PT0xKXJldHVybiB1PDA/czpmdW5jdGlvbihmKXtyZXR1cm4gZj49dX07dmFyIE09dSVsO3JldHVybiBNPDAmJihNKz1sKSxsPjE/ZnVuY3Rpb24oZil7cmV0dXJuIGY+PXUmJmYlbD09PU19OihsKj0tMSxmdW5jdGlvbihmKXtyZXR1cm4gZjw9dSYmZiVsPT09TX0pfX0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pO3ZhciByPXQoMTIpLHM9dCg3NCksbT10KDEpLHk9dCg2OCksYz10KDI1MCksbD10KDIxMyksdT10KDIxOCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIE0oQSxDKXtpZihBPT1udWxsKXJldHVybnt9O3ZhciBJPWYoQSxDKSxQLEw7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhBKTtmb3IoTD0wO0w8RC5sZW5ndGg7TCsrKVA9RFtMXSwhKEMuaW5kZXhPZihQKT49MCkmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChBLFApJiYoSVtQXT1BW1BdKX1yZXR1cm4gSX1mdW5jdGlvbiBmKEEsQyl7aWYoQT09bnVsbClyZXR1cm57fTt2YXIgST17fSxQPU9iamVjdC5rZXlzKEEpLEwsRDtmb3IoRD0wO0Q8UC5sZW5ndGg7RCsrKUw9UFtEXSwhKEMuaW5kZXhPZihMKT49MCkmJihJW0xdPUFbTF0pO3JldHVybiBJfWNvbnN0IHY9e2FudGlhbGlhczohMCxhdXRvUmVuZGVyOiEwLGFscGhhOiEwfSx4PVN5bWJvbCgiYXV0b1JlbmRlciIpLFI9U3ltYm9sKCJyZW5kZXJlciIpLE89U3ltYm9sKCJ0aW1lbGluZSIpLGc9U3ltYm9sKCJwcmVwYXJlUmVuZGVyIikscD1TeW1ib2woInRpY2tSZW5kZXIiKSxuPVN5bWJvbCgicGFzcyIpLGE9U3ltYm9sKCJmYm8iKSxpPVN5bWJvbCgidGlja2VycyIpLG89U3ltYm9sKCJsYXllclRyYW5zZm9ybUludmVydCIpO2NsYXNzIFQgZXh0ZW5kcyBjLmRlZmF1bHR7Y29uc3RydWN0b3IoQz17fSl7aWYoc3VwZXIoKSwhQy5jYW52YXMpe2NvbnN0e3dpZHRoOkQsaGVpZ2h0OmJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLFM9ci5FTlYuY3JlYXRlQ2FudmFzKEQsYix7b2Zmc2NyZWVuOiEhQy5vZmZzY3JlZW4saWQ6Qy5pZCxleHRyYTpDLmV4dHJhfSk7Uy5zdHlsZSYmKFMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIiksUy5kYXRhc2V0JiYoUy5kYXRhc2V0LmxheWVySWQ9Qy5pZCksUy5jb250ZXh0VHlwZSYmKEMuY29udGV4dFR5cGU9Uy5jb250ZXh0VHlwZSksQy5jYW52YXM9U31jb25zdCBJPUMuY2FudmFzLFA9T2JqZWN0LmFzc2lnbih7fSx2LEMpO3RoaXNbeF09UC5hdXRvUmVuZGVyLGRlbGV0ZSBDLmF1dG9SZW5kZXI7Y29uc3QgTD1QLlJlbmRlcmVyfHxyLlJlbmRlcmVyO3RoaXNbUl09bmV3IEwoSSxQKSx0aGlzLm9wdGlvbnM9Qyx0aGlzLmlkPUMuaWQsdGhpc1tuXT1bXSx0aGlzLnNldFJlc29sdXRpb24oSSksdGhpcy5jYW52YXM9SSx0aGlzW09dPW5ldyBzLlRpbWVsaW5lLHRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGwsdGhpc1tvXT1udWxsfWdldCBhdXRvUmVuZGVyKCl7cmV0dXJuIHRoaXNbeF19Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucz90aGlzLnBhcmVudC5vcHRpb25zLmRpc3BsYXlSYXRpbzoxfWdldCBoZWlnaHQoKXtjb25zdHtoZWlnaHQ6Q309dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEMvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGdsKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcj90aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuZ2w6bnVsbH1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpc31nZXQgb2Zmc2NyZWVuKCl7cmV0dXJuISF0aGlzLm9wdGlvbnMub2Zmc2NyZWVufHx0aGlzLmNhbnZhcy5fb2Zmc2NyZWVufWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbbl19Z2V0IHByZXBhcmVSZW5kZXIoKXtyZXR1cm4gdGhpc1tnXT90aGlzW2ddOlByb21pc2UucmVzb2x2ZSgpfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzW1JdfWdldCByZW5kZXJPZmZzZXQoKXtpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucyl7Y29uc3R7bGVmdDpDLHRvcDpJfT10aGlzLnBhcmVudC5vcHRpb25zO3JldHVybltDLEldfXJldHVyblt0aGlzLm9wdGlvbnMubGVmdHwwLHRoaXMub3B0aW9ucy50b3B8MF19Z2V0IHRpbWVsaW5lKCl7cmV0dXJuIHRoaXNbT119Z2V0IHdpZHRoKCl7Y29uc3R7d2lkdGg6Q309dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIEMvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3R7eDpDLHk6SX09dGhpcy5hdHRyaWJ1dGVzO3JldHVyblsxLDAsMCwxLEMsSV19Z2V0IGxheWVyVHJhbnNmb3JtSW52ZXJ0KCl7aWYodGhpc1tvXSlyZXR1cm4gdGhpc1tvXTtjb25zdCBDPXRoaXMudHJhbnNmb3JtTWF0cml4O3JldHVybiBDWzBdPT09MSYmQ1sxXT09PTAmJkNbMl09PT0wJiZDWzNdPT09MSYmQ1s0XT09PTAmJkNbNV09PT0wP251bGw6KHRoaXNbb109bS5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLEMpLHRoaXNbb10pfWZvcmNlQ29udGV4dExvc3MoKXtjb25zdCBDPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcjtpZihDKXtjb25zdCBJPUMuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9sb3NlX2NvbnRleHQiKTtpZihJKXJldHVybiBJLmxvc2VDb250ZXh0KCksITB9cmV0dXJuITF9YWRkUGFzcyh7dmVydGV4OkMsZnJhZ21lbnQ6SSxvcHRpb25zOlAsdW5pZm9ybXM6TH09e30pe2lmKHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcil7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6Yn09dGhpcy5nZXRSZXNvbHV0aW9uKCksUz10aGlzLnJlbmRlcmVyLmNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6QyxmcmFnbWVudDpJLG9wdGlvbnM6UH0pLEI9bmV3IHIuRmlndXJlMkQ7Qi5yZWN0KDAsMCxEL3RoaXMuZGlzcGxheVJhdGlvLGIvdGhpcy5kaXNwbGF5UmF0aW8pO2NvbnN0IHc9bmV3IHIuTWVzaDJEKEIpO3JldHVybiB3LnNldFVuaWZvcm1zKEwpLHcuc2V0UHJvZ3JhbShTKSx0aGlzW25dLnB1c2godyksdGhpcy5mb3JjZVVwZGF0ZSgpLHd9cmV0dXJuIG51bGx9ZGVsZXRlVGV4dHVyZShDKXtyZXR1cm4gT2JqZWN0KHUuZGVsZXRlVGV4dHVyZSkoQyx0aGlzLnJlbmRlcmVyKX1kaXNwYXRjaFBvaW50ZXJFdmVudChDKXtjb25zdCBJPUMudHlwZTtpZihJPT09Im1vdXNlZG93biJ8fEk9PT0ibW91c2V1cCJ8fEk9PT0ibW91c2Vtb3ZlIil7Y29uc3QgUz10aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldDtpZihTKXtpZihTLmxheWVyPT09dGhpcylyZXR1cm4gUy5kaXNwYXRjaEV2ZW50KEMpLCEwO3RoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGx9fWxldCBQLEw7Y29uc3QgRD10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O2lmKEQpe1A9Qy54LEw9Qy55O2NvbnN0IFM9RCxCPVNbMF0qUCtTWzJdKkwrU1s0XSx3PVNbMV0qUCtTWzNdKkwrU1s1XTtkZWxldGUgQy54LGRlbGV0ZSBDLnksZGVsZXRlIEMubGF5ZXJYLGRlbGV0ZSBDLmxheWVyWSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDLHtsYXllclg6e3ZhbHVlOkIsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOncsY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpCLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6dyxjb25maWd1cmFibGU6ITB9fSl9Y29uc3QgYj1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChDKTtyZXR1cm4gRCYmT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQyx7bGF5ZXJYOnt2YWx1ZTpQLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpMLGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6UCxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOkwsY29uZmlndXJhYmxlOiEwfX0pLGJ9Zm9yY2VVcGRhdGUoKXtpZighdGhpc1tnXSlpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuaGFzT2Zmc2NyZWVuQ2FudmFzKXt0aGlzLnBhcmVudC5mb3JjZVVwZGF0ZSgpO2xldCBDPW51bGw7Y29uc3QgST1uZXcgUHJvbWlzZShQPT57Qz1QfSk7SS5fcmVzb2x2ZT1DLHRoaXNbZ109SX1lbHNle2xldCBDPW51bGwsST1udWxsO2NvbnN0IFA9bmV3IFByb21pc2UoTD0+e0M9TCx0aGlzW3hdJiYoST1PYmplY3QoeS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIFAuX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfSk7UC5fcmVzb2x2ZT1DLFAuX3JlcXVlc3RJRD1JLHRoaXNbZ109UH19Z2V0RkJPKCl7Y29uc3QgQz10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIse3dpZHRoOkksaGVpZ2h0OlB9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBDJiYoIXRoaXNbYV18fHRoaXNbYV0ud2lkdGghPT1JfHx0aGlzW2FdLmhlaWdodCE9PVApPyh0aGlzW2FdPXt3aWR0aDpJLGhlaWdodDpQLHRhcmdldDpDLmNyZWF0ZUZCTygpLGJ1ZmZlcjpDLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSx0aGlzW2FdKTp0aGlzW2FdP3RoaXNbYV06bnVsbH11cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBDPXRoaXMucmVuZGVyZXIsST1DLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxDLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtDLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PUk7Y29uc3QgUD1tLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO0Muc2V0R2xvYmFsVHJhbnNmb3JtKC4uLm0ubWF0MmQubXVsdGlwbHkoUCxJLHRoaXMudHJhbnNmb3JtTWF0cml4KSl9fW9uUHJvcGVydHlDaGFuZ2UoQyxJLFApe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoQyxJLFApLEM9PT0iekluZGV4IiYmKHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleD1JKSxDPT09InRyYW5zZm9ybSJ8fEM9PT0idHJhbnNsYXRlInx8Qz09PSJyb3RhdGUifHxDPT09InNjYWxlInx8Qz09PSJza2V3Iil7Y29uc3QgTD10aGlzW29dO2lmKHRoaXNbb109bnVsbCx0aGlzLnVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpLEwmJiF0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBEPXRoaXMucmVuZGVyZXIsYj1ELl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxELmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtELnNldEdsb2JhbFRyYW5zZm9ybSguLi5iKX19fV9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKXt0aGlzW2ddJiYodGhpc1tnXS5fcmVxdWVzdElEJiZPYmplY3QoeS5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1tnXS5fcmVxdWVzdElEKSx0aGlzW2ddLl9yZXNvbHZlKCksZGVsZXRlIHRoaXNbZ10pfXJlbmRlcih7Y2xlYXI6Qz0hMH09e30pe2NvbnN0IEk9dGhpc1tuXS5sZW5ndGg/dGhpcy5nZXRGQk8oKTpudWxsO0kmJnRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5iaW5kRkJPKEkudGFyZ2V0KSxDJiZ0aGlzW1JdLmNsZWFyKCk7Y29uc3QgUD10aGlzLmRyYXcoKTtpZihQJiZQLmxlbmd0aCYmKHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhQKSx0aGlzLmNhbnZhcy5kcmF3JiZ0aGlzLmNhbnZhcy5kcmF3KCkpLEkpe2NvbnN0IEw9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLEQ9dGhpc1tuXS5sZW5ndGgse3dpZHRoOmIsaGVpZ2h0OlN9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEI9WzAsMCxiL3RoaXMuZGlzcGxheVJhdGlvLFMvdGhpcy5kaXNwbGF5UmF0aW9dO3RoaXNbbl0uZm9yRWFjaCgodyxIKT0+e3cuYmxlbmQ9ITAsdy5zZXRUZXh0dXJlKEkudGFyZ2V0LnRleHR1cmUse3JlY3Q6Qn0pLEg9PT1ELTE/TC5iaW5kRkJPKG51bGwpOihJLnN3YXAoKSxMLmJpbmRGQk8oSS50YXJnZXQpKSx0aGlzW1JdLmNsZWFyKCksdGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKFt3XSl9KX10aGlzLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpDLGhlaWdodDpJfSl7Y29uc3QgUD10aGlzLnJlbmRlcmVyLEw9UC5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8UC5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgsRD1MWzRdLGI9TFs1XSxTPUxbMF0se3dpZHRoOkIsaGVpZ2h0Ond9PXRoaXMuZ2V0UmVzb2x1dGlvbigpOyhCIT09Q3x8dyE9PUkpJiYoc3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6QyxoZWlnaHQ6SX0pLHRoaXMuY2FudmFzJiYodGhpcy5jYW52YXMud2lkdGg9Qyx0aGlzLmNhbnZhcy5oZWlnaHQ9SSxQLnVwZGF0ZVJlc29sdXRpb24mJlAudXBkYXRlUmVzb2x1dGlvbigpKSx0aGlzLmF0dHJpYnV0ZXMuc2l6ZT1bQyxJXSx0aGlzW25dLmxlbmd0aCYmdGhpc1tuXS5mb3JFYWNoKFc9Pntjb25zdCBHPW5ldyByLkZpZ3VyZTJEO0cucmVjdCgwLDAsQy90aGlzLmRpc3BsYXlSYXRpbyxJL3RoaXMuZGlzcGxheVJhdGlvKSxXLmNvbnRvdXJzPUcuY29udG91cnN9KSk7Y29uc3RbSCxKXT10aGlzLnJlbmRlck9mZnNldCxxPXRoaXMuZGlzcGxheVJhdGlvOyhEIT09SHx8YiE9PUp8fFMhPT1xKSYmKFAuc2V0R2xvYmFsVHJhbnNmb3JtKHEsMCwwLHEsSCxKKSxQLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PW51bGwsdGhpc1tvXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksdGhpcy5mb3JjZVVwZGF0ZSgpKX10aWNrKEM9bnVsbCxJPXt9KXtsZXR7ZHVyYXRpb246UD0xLzB9PUksTD1NKEksWyJkdXJhdGlvbiJdKTtjb25zdCBEPXRoaXMudGltZWxpbmUuZm9yayhMKSxiPXRoaXM7dGhpc1tpXT10aGlzW2ldfHxbXSx0aGlzW2ldLnB1c2goe2hhbmRsZXI6QyxkdXJhdGlvbjpQfSk7Y29uc3QgUz0oKT0+e2xldCBCPW51bGwsdz1udWxsO2NvbnN0IEg9KCk9Pntjb25zdCBKPXRoaXNbaV0ubWFwKCh7aGFuZGxlcjpxLGR1cmF0aW9uOld9KT0+e2NvbnN0IEc9TWF0aC5taW4oMSxELmN1cnJlbnRUaW1lL1cpO3JldHVybnt2YWx1ZTpxP3EoRC5jdXJyZW50VGltZSxHKTpudWxsLHA6R319KTtiW3BdfHwoYltwXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57Ylt4XSYmYi5yZW5kZXIoKSxkZWxldGUgYltwXTtmb3IobGV0IHE9Si5sZW5ndGgtMTtxPj0wO3EtLSl7Y29uc3R7dmFsdWU6VyxwOkd9PUpbcV07KFc9PT0hMXx8Rz49MSkmJnRoaXNbaV0uc3BsaWNlKHEsMSl9dGhpc1tpXS5sZW5ndGg+MCYmUygpfSkpfTtpZih0aGlzW2ddJiZ0aGlzW2ddLl90eXBlIT09InRpY2tlciImJihPYmplY3QoeS5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1tnXS5fcmVxdWVzdElEKSxkZWxldGUgdGhpc1tnXSksIXRoaXNbZ10pe2NvbnN0IEo9bmV3IFByb21pc2UocT0+e0I9cSx3PU9iamVjdCh5LnJlcXVlc3RBbmltYXRpb25GcmFtZSkoSCl9KTtKLl9yZXNvbHZlPUIsSi5fcmVxdWVzdElEPXcsSi5fdHlwZT0idGlja2VyIix0aGlzW2ddPUp9fTtTKCl9dG9HbG9iYWxQb3MoQyxJKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBCPXRoaXMudHJhbnNmb3JtTWF0cml4O0M9QlswXSpDK0JbMl0qSStCWzRdLEk9QlsxXSpDK0JbM10qSStCWzVdfWNvbnN0e3dpZHRoOlAsaGVpZ2h0Okx9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEQ9dGhpcy5yZW5kZXJPZmZzZXQsYj1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtDPUMqYlswXS9QK0RbMF0sST1JKmJbMV0vTCtEWzFdO2NvbnN0IFM9dGhpcy5kaXNwbGF5UmF0aW87cmV0dXJuIEMqPVMsSSo9UyxbQyxJXX10b0xvY2FsUG9zKEMsSSl7Y29uc3R7d2lkdGg6UCxoZWlnaHQ6TH09dGhpcy5nZXRSZXNvbHV0aW9uKCksRD10aGlzLnJlbmRlck9mZnNldCxiPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO0M9QypQL2JbMF0tRFswXSxJPUkqTC9iWzFdLURbMV07Y29uc3QgUz10aGlzLmRpc3BsYXlSYXRpbztDLz1TLEkvPVM7Y29uc3QgQj10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O3JldHVybiBCJiYoQz1CWzBdKkMrQlsyXSpJK0JbNF0sST1CWzFdKkMrQlszXSpJK0JbNV0pLFtDLEldfX1sLmRlZmF1bHQucmVnaXN0ZXJOb2RlKFQsImxheWVyIil9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgcj10KDIyNCkscz10KDI4OCksbT10KDIxMykseT10KDI1MiksYz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChwLG4pe2lmKHA9PW51bGwpcmV0dXJue307dmFyIGE9dShwLG4pLGksbztpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgVD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHApO2ZvcihvPTA7bzxULmxlbmd0aDtvKyspaT1UW29dLCEobi5pbmRleE9mKGkpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHAsaSkmJihhW2ldPXBbaV0pfXJldHVybiBhfWZ1bmN0aW9uIHUocCxuKXtpZihwPT1udWxsKXJldHVybnt9O3ZhciBhPXt9LGk9T2JqZWN0LmtleXMocCksbyxUO2ZvcihUPTA7VDxpLmxlbmd0aDtUKyspbz1pW1RdLCEobi5pbmRleE9mKG8pPj0wKSYmKGFbb109cFtvXSk7cmV0dXJuIGF9ZnVuY3Rpb24gTShwLG4sYSl7cmV0dXJuIG4gaW4gcD9PYmplY3QuZGVmaW5lUHJvcGVydHkocCxuLHt2YWx1ZTphLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6cFtuXT1hLHB9Y29uc3QgZj0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIikseD1TeW1ib2woInJvb3QiKSxSPVN5bWJvbCgidGFzayIpO2Z1bmN0aW9uIE8ocCxuPSEwKXtjb25zdCBhPXBbeF07aWYoYSYmYS5jaGlsZHJlblswXSl7Y29uc3QgaT1wLnN2ZyxvPXAubGF5ZXI/cC5sYXllci5kaXNwbGF5UmF0aW86MTtpZighaS5oYXNBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSl7bGV0IEM9aS5nZXRBdHRyaWJ1dGUoIndpZHRoIik7Qz1DP09iamVjdChjLnNpemVUb1BpeGVsKShDKTozMDA7bGV0IEk9aS5nZXRBdHRyaWJ1dGUoImhlaWdodCIpO0k9ST9PYmplY3QoYy5zaXplVG9QaXhlbCkoSSk6MTUwLGkuaGFzQXR0cmlidXRlKCJ2aWV3Qm94Iil8fGkuc2V0QXR0cmlidXRlKCJ2aWV3Qm94IixgMCAwICR7TWF0aC5yb3VuZChDKX0gJHtNYXRoLnJvdW5kKEkpfWApLGkuc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIixDKSxpLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiLEkpfWxldCBUPXAuYXR0cmlidXRlcy53aWR0aHx8TnVtYmVyKGkuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpLEE9cC5hdHRyaWJ1dGVzLmhlaWdodHx8TnVtYmVyKGkuZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIpKTtpZihUKj1vLEEqPW8sbiYmcC5hdHRyaWJ1dGVzLmZsZXhpYmxlKXtjb25zdCBDPXAuYXR0cmlidXRlcy5zY2FsZVswXTtpZihUKj1DLEEqPUMsaS5zZXRBdHRyaWJ1dGUoIndpZHRoIixUKSxpLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixBKSxUJiZBJiZwLnRleHR1cmVJbWFnZSl7Y29uc3QgST1wLnRleHR1cmVJbWFnZS53aWR0aCxQPXAudGV4dHVyZUltYWdlLmhlaWdodCxMPXAuY2xpZW50U2l6ZTtwLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9WzAsMCxNYXRoLnJvdW5kKExbMF0qSS9UKSxNYXRoLnJvdW5kKExbMV0qUC9BKV19fWVsc2UgcFtSXXx8KGkuc2V0QXR0cmlidXRlKCJ3aWR0aCIsVCksaS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsQSkscFtSXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57ZGVsZXRlIHBbUl07Y29uc3QgQz1hLmlubmVySFRNTCxJPW5ldyBCbG9iKFtDXSx7dHlwZToiaW1hZ2Uvc3ZnK3htbCJ9KSxQPVVSTC5jcmVhdGVPYmplY3RVUkwoSSksTD1uZXcgSW1hZ2U7TC5vbmxvYWQ9ZnVuY3Rpb24oKXtMLndpZHRoJiZMLmhlaWdodD8ocC5hdHRyaWJ1dGVzW3ZdKCJ0ZXh0dXJlIixMKSxwLmF0dHJpYnV0ZXMuZmxleGlibGUmJihwLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9bnVsbCkpOnAuYXR0cmlidXRlc1t2XSgidGV4dHVyZSIsbnVsbCl9LEwuc3JjPVB9KSl9fWNsYXNzIGcgZXh0ZW5kcyByLmRlZmF1bHR7Y29uc3RydWN0b3Iobj17fSl7dHlwZW9mIG49PSJzdHJpbmciJiYobj17c3ZnVGV4dDpufSk7bGV0e3N2Z1RleHQ6YX09bixpPWwobixbInN2Z1RleHQiXSk7aWYoc3VwZXIoaSksdGhpc1t4XT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxhKXt0aGlzW3hdLmlubmVySFRNTD1hO2NvbnN0IG89dGhpc1t4XS5jaGlsZHJlblswXTtvP28uc2V0QXR0cmlidXRlKCJ4bWxucyIsZik6KGZldGNoKGEpLnRoZW4oVD0+VC50ZXh0KCkpLnRoZW4oVD0+e3RoaXNbeF0uaW5uZXJIVE1MPVQsKCF0aGlzLm9ic2VydmVyfHx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUpJiZPKHRoaXMpfSksYT1udWxsKX1pZighYSl7Y29uc3Qgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZiwic3ZnIik7by5zZXRBdHRyaWJ1dGUoInhtbG5zIixmKSx0aGlzW3hdLmFwcGVuZENoaWxkKG8pfWlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPT0iZnVuY3Rpb24iKXtjb25zdCBvPW5ldyBNdXRhdGlvbk9ic2VydmVyKFQ9PntPKHRoaXMsITEpfSk7by5vYnNlcnZlKHRoaXNbeF0se2F0dHJpYnV0ZXM6ITAsc3VidHJlZTohMCxjaGFyYWN0ZXJEYXRhOiEwLGNoaWxkTGlzdDohMH0pLHRoaXMub2JzZXJ2ZXI9b319Z2V0IGNoaWxkcmVuKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgY2hpbGROb2Rlcygpe3JldHVyblt0aGlzLnN2Z119Z2V0IHN2Zygpe3JldHVybiB0aGlzW3hdP3RoaXNbeF0uY2hpbGRyZW5bMF06bnVsbH1zZXRSZXNvbHV0aW9uKHt3aWR0aDpuLGhlaWdodDphfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6bixoZWlnaHQ6YX0pLE8odGhpcyl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQobil7Y29uc3QgYT1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChuKTtpZihhJiZ0aGlzLmF0dHJpYnV0ZXMucGFzc0V2ZW50cyYmdHlwZW9mIE1vdXNlRXZlbnQ9PSJmdW5jdGlvbiIpe2NvbnN0e3g6aSx5Om99PW47bGV0W1QsQV09dGhpcy5nZXRPZmZzZXRQb3NpdGlvbihpLG8pO2NvbnN0IEM9bi5vcmlnaW5hbEV2ZW50LEk9dGhpcy5hdHRyaWJ1dGVzLmFuY2hvcixQPXRoaXMuY2xpZW50U2l6ZTtUPShUK0lbMF0qUFswXSkvMixBPShBK0lbMV0qUFsxXSkvMjtjb25zdCBMPW4udHlwZTtpZihMPT09Qy50eXBlKXtsZXQgRD1udWxsO2lmKEMgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KUQ9bmV3IE1vdXNlRXZlbnQoTCx7c2NyZWVuWDpULHNjcmVlblk6QSxjbGllbnRYOlQsY2xpZW50WTpBLGJ1YmJsZXM6Qy5idWJibGVzLGJ1dHRvbjpDLmJ1dHRvbixidXR0b25zOkMuYnV0dG9ucyxjYW5jZWxCdWJibGU6Qy5jYW5jZWxCdWJibGUsY2FuY2VsYWJsZTpDLmNhbmNlbGFibGUsY3VycmVudFRhcmdldDpDLmN1cnJlbnRUYXJnZXQsZnJvbUVsZW1lbnQ6Qy5mcm9tRWxlbWVudCxyZWxhdGVkVGFyZ2V0OkMucmVsYXRlZFRhcmdldCxyZXR1cm5WYWx1ZTpDLnJldHVyblZhbHVlLHNyY0VsZW1lbnQ6Qy5zcmNFbGVtZW50LHRhcmdldDpDLnRhcmdldCx0b0VsZW1lbnQ6Qy50b0VsZW1lbnQsd2hpY2g6Qy53aXRjaH0pO2Vsc2UgaWYoQyBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpe2xldCBiPW51bGw7Y29uc3QgUz1DLmNoYW5nZWRUb3VjaGVzfHxbQ107Zm9yKGxldCBCPTA7QjxTLmxlbmd0aDtCKyspe2NvbnN0IHc9U1tCXTtpZihuLmlkZW50aWZpZXI9PT13LmlkZW50aWZpZXIpe2I9dzticmVha319aWYoYil7Y29uc3QgQj1uZXcgVG91Y2goe2lkZW50aWZpZXI6Yi5pZGVudGlmaWVyLHRhcmdldDpiLnRhcmdldCxjbGllbnRYOlQsY2xpZW50WTpBLHNjcmVlblg6VCxzY3JlZW5ZOkEscGFnZVg6VCxwYWdlWTpBLHJhZGl1c1g6Yi5yYWRpdXNYLHJhZGl1c1k6Yi5yYWRpdXNZLHJvdGF0aW9uQW5nbGU6Yi5yb3RhdGlvbkFuZ2xlLGZvcmNlOmIuZm9yY2V9KTtEPW5ldyBUb3VjaEV2ZW50KEwse2NhbmNlbGFibGU6Qy5jYW5jZWxhYmxlLGJ1YmJsZXM6Qy5idWJibGVzLGNvbXBvc2VkOkMuY29tcG9zZWQsdG91Y2hlczpbQl0sdGFyZ2V0VG91Y2hlczpbQl0sY2hhbmdlZFRvdWNoZXM6W0JdfSl9fWVsc2UgRD1DO0QmJnRoaXMuc3ZnLmRpc3BhdGNoRXZlbnQoRCl9fXJldHVybiBhfWdldEVsZW1lbnRCeUlkKG4pe3JldHVybiBPYmplY3QoeS5xdWVyeVNlbGVjdG9yKShgIyR7bn1gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUobil7cmV0dXJuIE9iamVjdCh5LnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtufWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUobil7cmV0dXJuIE9iamVjdCh5LnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtufSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShuKXtyZXR1cm4gT2JqZWN0KHkucXVlcnlTZWxlY3RvckFsbCkobix0aGlzKX1xdWVyeVNlbGVjdG9yKG4pe3JldHVybiBPYmplY3QoeS5xdWVyeVNlbGVjdG9yKShuLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwobil7cmV0dXJuIE9iamVjdCh5LnF1ZXJ5U2VsZWN0b3JBbGwpKG4sdGhpcyl9b25Qcm9wZXJ0eUNoYW5nZShuLGEsaSl7c3VwZXIub25Qcm9wZXJ0eUNoYW5nZShuLGEsaSksbj09PSJmbGV4aWJsZSImJk8odGhpcyksdGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYobj09PSJ3aWR0aCJ8fG49PT0iaGVpZ2h0Inx8bj09PSJzY2FsZSJ8fG49PT0idHJhbnNmb3JtIikmJk8odGhpcyl9fU0oZywiQXR0ciIscy5kZWZhdWx0KSxtLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGcsInNwcml0ZXN2ZyIpfSxmdW5jdGlvbihoLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIHI9dCgyMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBzPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLG09U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIikseT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iik7Y2xhc3MgYyBleHRlbmRzIHIuZGVmYXVsdHtjb25zdHJ1Y3Rvcih1KXtzdXBlcih1KSx0aGlzW3ldKHtwYXNzRXZlbnRzOiExLGZsZXhpYmxlOiExfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tzXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKHUpe31nZXQgcGFzc0V2ZW50cygpe3JldHVybiB0aGlzW3NdKCJwYXNzRXZlbnRzIil9c2V0IHBhc3NFdmVudHModSl7cmV0dXJuIHRoaXNbbV0oInBhc3NFdmVudHMiLHUpfWdldCBmbGV4aWJsZSgpe3JldHVybiB0aGlzW3NdKCJmbGV4aWJsZSIpfXNldCBmbGV4aWJsZSh1KXtyZXR1cm4gdGhpc1ttXSgiZmxleGlibGUiLHUpfX19LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSk7dmFyIHI9dCgxMik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHModSxNKXt2YXIgZj1PYmplY3Qua2V5cyh1KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgdj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHUpO00mJih2PXYuZmlsdGVyKGZ1bmN0aW9uKHgpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHUseCkuZW51bWVyYWJsZX0pKSxmLnB1c2guYXBwbHkoZix2KX1yZXR1cm4gZn1mdW5jdGlvbiBtKHUpe2Zvcih2YXIgTT0xO008YXJndW1lbnRzLmxlbmd0aDtNKyspe3ZhciBmPWFyZ3VtZW50c1tNXSE9bnVsbD9hcmd1bWVudHNbTV06e307TSUyP3MoT2JqZWN0KGYpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHYpe3kodSx2LGZbdl0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXModSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhmKSk6cyhPYmplY3QoZikpLmZvckVhY2goZnVuY3Rpb24odil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHUsdixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGYsdikpfSl9cmV0dXJuIHV9ZnVuY3Rpb24geSh1LE0sZil7cmV0dXJuIE0gaW4gdT9PYmplY3QuZGVmaW5lUHJvcGVydHkodSxNLHt2YWx1ZTpmLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dVtNXT1mLHV9Y29uc3QgYz1TeW1ib2woImluaXRlZCIpO2xldCBsPW51bGw7dHlwZW9mIFdvcmtlcj09ImZ1bmN0aW9uIiYmKGw9Y2xhc3MgZXh0ZW5kcyBXb3JrZXJ7Y29uc3RydWN0b3IodSl7aWYodS53b3JrZXI9PT0hMCYmKHUud29ya2VyPWAuLyR7dS5pZH0ud29ya2VyLmpzYCksc3VwZXIodS53b3JrZXIpLHRoaXMub3B0aW9ucz11LCF1LmNhbnZhcyl7Y29uc3R7d2lkdGg6TSxoZWlnaHQ6Zn09dGhpcy5nZXRSZXNvbHV0aW9uKCksdj1yLkVOVi5jcmVhdGVDYW52YXMoTSxmLHtvZmZzY3JlZW46ITF9KTt2LnN0eWxlJiYodi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSx2LmRhdGFzZXQmJih2LmRhdGFzZXQubGF5ZXJJZD11LmlkKSx1LmNhbnZhcz12fXRoaXMuY2FudmFzPXUuY2FudmFzfWdldCBpZCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaWR9c2V0UmVzb2x1dGlvbih7d2lkdGg6dSxoZWlnaHQ6TX0pe2lmKHRoaXNbY10pdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToicmVzb2x1dGlvbl9jaGFuZ2UiLHdpZHRoOnUsaGVpZ2h0Ok19KTtlbHNle3RoaXMuY2FudmFzLndpZHRoPXUsdGhpcy5jYW52YXMuaGVpZ2h0PU07Y29uc3QgZj10aGlzLm9wdGlvbnMsdj1mLmNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpLHg9bSh7fSxmKTtkZWxldGUgeC5jb250YWluZXIseC5jYW52YXM9dix0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJjcmVhdGUiLG9wdGlvbnM6eH0sW3ZdKSx0aGlzW2NdPSEwfX1nZXRSZXNvbHV0aW9uKCl7aWYodGhpcy5jYW52YXMpe2NvbnN0e3dpZHRoOnUsaGVpZ2h0Ok19PXRoaXMuY2FudmFzO3JldHVybnt3aWR0aDp1LGhlaWdodDpNfX1yZXR1cm57d2lkdGg6MzAwLGhlaWdodDoxNTB9fXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1jb25uZWN0KHUsTSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOnUsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOk0sd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9ZGlzY29ubmVjdCgpe2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXJ9ZGlzcGF0Y2hQb2ludGVyRXZlbnQodSl7dGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiZXZlbnQiLGV2ZW50OntjYW5jZWxCdWJibGU6dS5jYW5jZWxCdWJibGUsYnViYmxlczp1LmJ1YmJsZXMsZGV0YWlsOnUuZGV0YWlsLGlkZW50aWZpZXI6dS5pZGVudGlmaWVyLGxheWVyWDp1LmxheWVyWCxsYXllclk6dS5sYXllclksb3JpZ2luYWxYOnUub3JpZ2luYWxYLG9yaWdpbmFsWTp1Lm9yaWdpbmFsWSx0eXBlOnUudHlwZSx4OnUueCx5OnUueX19KX19KSxlLmRlZmF1bHQ9bH0sZnVuY3Rpb24oaCxlLHQpe3QucihlKSwoZnVuY3Rpb24ocil7dC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgcz10KDEyKSxtPXQoNjgpLHk9dCg3MCksYz10KDI4NiksbD10KDI4OSksdT10KDI1MCksTT10KDI5MSksZj10KDIxNCksdj10KDIxOCkseD10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFI9U3ltYm9sKCJlbnRlcmVkVGFyZ2V0cyIpO2Z1bmN0aW9uIE8oQSl7cmV0dXJuIEEuaWQ9QS5pZHx8YF9sYXllciR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwxMil9YCxBLmRhdGFzZXR8fChBLmRhdGFzZXQ9e30pLEEuZGF0YXNldC5sYXllcklkPUEuaWQsQS5jb25uZWN0PShDLEkpPT57QS5wYXJlbnQ9QyxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSwiek9yZGVyIix7dmFsdWU6SSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX0sQS5kaXNjb25uZWN0PUM9PntkZWxldGUgQS56T3JkZXJ9LEEuY2FudmFzPUEsQS5nZXRSZXNvbHV0aW9uPSgpPT4oe3dpZHRoOjAsaGVpZ2h0OjB9KSxBLnNldFJlc29sdXRpb249KCk9PiExLEEub3B0aW9ucz17aGFuZGxlRXZlbnQ6ITF9LEF9ZnVuY3Rpb24gZyhBLEMpe2NvbnN0IEk9QS5jaGlsZHJlbjtsZXQgUD1udWxsO2ZvcihsZXQgTD0wO0w8SS5sZW5ndGg7TCsrKXtjb25zdCBEPUlbTF07aWYoKEM9PT1EfHxQIT1udWxsKSYmKFA9RCksUCYmUCE9PUMmJiFQLm9mZnNjcmVlbilyZXR1cm4gUC5jYW52YXN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gcChBLEMpe2NvbnN0W0ksUF09QS5yZW5kZXJPZmZzZXQse3dpZHRoOkwsaGVpZ2h0OkR9PUEuZ2V0UmVzb2x1dGlvbigpLGI9QS5kaXNwbGF5UmF0aW87QS5yZW5kZXJlci5kcmF3SW1hZ2UoQy5jYW52YXMsLUkvYiwtUC9iLEwvYixEL2IpfWNvbnN0IG49e307ZnVuY3Rpb24gYShBKXtjb25zdCBDPVsibW91c2Vkb3duIiwibW91c2V1cCIsIm1vdXNlbW92ZSIsIm1vdXNld2hlZWwiLCJ3aGVlbCIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoY2FuY2VsIiwiY2xpY2siLCJkYmxjbGljayIsImxvbmdwcmVzcyIsInRhcCIsImNvbnRleHRtZW51Il0sST1BLmNvbnRhaW5lcjtJLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLFA9Pntjb25zdCBMPUFbUl07aWYoTC5zaXplKXtjb25zdCBEPW5ldyBmLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTtELnNldE9yaWdpbmFsRXZlbnQoUCksWy4uLkxdLmZvckVhY2goYj0+e2IuZGlzcGF0Y2hFdmVudChEKX0pLEFbUl0uY2xlYXIoKX19LHtwYXNzaXZlOiEwfSksQy5mb3JFYWNoKFA9PntJLmFkZEV2ZW50TGlzdGVuZXIoUCxMPT57Y29uc3R7bGVmdDpELHRvcDpiLGRpc3BsYXlSYXRpbzpTfT1BLm9wdGlvbnMsQj1BLm9yZGVyZWRDaGlsZHJlbjtPYmplY3QoTS5kZWZhdWx0KShMLHtvZmZzZXRMZWZ0OkQsb2Zmc2V0VG9wOmIsZGlzcGxheVJhdGlvOlN9KS5mb3JFYWNoKEg9Pntjb25zdCBKPUguaWRlbnRpZmllcjtpZihILnR5cGU9PT0idG91Y2htb3ZlInx8SC50eXBlPT09InRvdWNoZW5kIil7Y29uc3QgVz1uW0pdO1cmJlcuZGlzcGF0Y2hFdmVudChIKSxILnR5cGU9PT0idG91Y2hlbmQiJiZkZWxldGUgbltKXX1lbHNle2ZvcihsZXQgVz1CLmxlbmd0aC0xO1c+PTA7Vy0tKXtjb25zdCBHPUJbV107aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe2lmKEcuZGlzcGF0Y2hQb2ludGVyRXZlbnQoSCkmJkgudGFyZ2V0IT09RylicmVhaztILmNhbmNlbEJ1YmJsZT0hMX19aWYoSC50YXJnZXQ9PT1CWzBdKWZvcihsZXQgVz1CLmxlbmd0aC0xO1c+PTA7Vy0tKXtjb25zdCBHPUJbV107aWYoRy5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe0gudGFyZ2V0PUc7YnJlYWt9fX1jb25zdCBxPUgudGFyZ2V0O2lmKEgudHlwZT09PSJ0b3VjaHN0YXJ0IiYmKG5bSl09SC50YXJnZXQpLEgudHlwZT09PSJtb3VzZW1vdmUiKXtjb25zdCBXPUFbUl07bGV0IEc7aWYocSl7Y29uc3QgXz1xLmFuY2VzdG9yc3x8W107Rz1uZXcgU2V0KFtxLC4uLl9dKX1lbHNlIEc9bmV3IFNldDtjb25zdCBRPU9iamVjdC5lbnRyaWVzKEwpO2lmKCFXLmhhcyhxKSYmcSl7Y29uc3QgXz1uZXcgZi5kZWZhdWx0KCJtb3VzZWVudGVyIik7Xy5zZXRPcmlnaW5hbEV2ZW50KEwpLFEuZm9yRWFjaCgoW2ssY3RdKT0+e19ba109Y3R9KSxXLmFkZChxKSxxLmRpc3BhdGNoRXZlbnQoXyk7Y29uc3Qgc3Q9cS5hbmNlc3RvcnM7c3QmJnN0LmZvckVhY2goaz0+e2sgaW5zdGFuY2VvZiB5LmRlZmF1bHQmJiFXLmhhcyhrKSYmKFcuYWRkKGspLGsuZGlzcGF0Y2hFdmVudChfKSl9KX1jb25zdCB0dD1uZXcgZi5kZWZhdWx0KCJtb3VzZWxlYXZlIik7dHQuc2V0T3JpZ2luYWxFdmVudChMKSxRLmZvckVhY2goKFtfLHN0XSk9Pnt0dFtfXT1zdH0pLFsuLi5XXS5mb3JFYWNoKF89PntHLmhhcyhfKXx8KFcuZGVsZXRlKF8pLF8uZGlzcGF0Y2hFdmVudCh0dCkpfSl9fSl9LHtwYXNzaXZlOlAhPT0iY29udGV4dG1lbnUifSl9KX1mdW5jdGlvbiBpKEEsQyl7aWYoQyYmQy5zdHlsZSl7bGV0e3dpZHRoOkksaGVpZ2h0OlAsbW9kZTpMLGNvbnRhaW5lcjpEfT1BO2NvbnN0e2NsaWVudFdpZHRoOmIsY2xpZW50SGVpZ2h0OlN9PUQ7ST1JfHxiLFA9UHx8UyxMPT09InN0YXRpYyI/KEMuc3R5bGUud2lkdGg9YCR7SX1weGAsQy5zdHlsZS5oZWlnaHQ9YCR7UH1weGApOihDLnN0eWxlLnRvcD0iMCIsQy5zdHlsZS5sZWZ0PSIwIixDLnN0eWxlLndpZHRoPWAke2J9cHhgLEMuc3R5bGUuaGVpZ2h0PWAke1N9cHhgLEMuc3R5bGUudHJhbnNmb3JtPSIiLEMuc3R5bGUud2Via2l0VHJhbnNmb3JtPSIiKX19Y29uc3Qgbz1TeW1ib2woIm9mZnNjcmVlbkxheWVyQ291bnQiKTtjbGFzcyBUIGV4dGVuZHMgdS5kZWZhdWx0e2NvbnN0cnVjdG9yKEM9e30pe2lmKHN1cGVyKCksIUMuY29udGFpbmVyKWlmKHR5cGVvZiBzLkVOVi5Db250YWluZXI9PSJmdW5jdGlvbiIpQy5jb250YWluZXI9bmV3IHMuRU5WLkNvbnRhaW5lcihDLndpZHRofHwzMDAsQy5oZWlnaHR8fDE1MCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIk5vIGNvbnRhaW5lciBzcGVjaWZpZWQuIik7aWYodGhpcy5jb250YWluZXI9Qy5jb250YWluZXIsdGhpcy5jb250YWluZXIuc3R5bGUmJih0aGlzLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd3x8KHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iKSx0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbnx8KHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSIpKSx0aGlzLm9wdGlvbnM9QyxDLmRpc3BsYXlSYXRpbz1DLmRpc3BsYXlSYXRpb3x8MSxDLm1vZGU9Qy5tb2RlfHwic2NhbGUiLEMubGVmdD0wLEMudG9wPTAsQy5hdXRvUmVzaXplPUMuYXV0b1Jlc2l6ZSE9PSExLEMuYXV0b1Jlc2l6ZSl7bGV0IEk7aWYodHlwZW9mIGdsb2JhbFRoaXM8InUiP0k9Z2xvYmFsVGhpczpJPXR5cGVvZiB3aW5kb3c8InUiP3dpbmRvdzpyLEkuYWRkRXZlbnRMaXN0ZW5lcil7Y29uc3QgUD10aGlzO0kuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIixmdW5jdGlvbiBMKCl7dHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuY29udGFpbnMoUC5jb250YWluZXIpP1AucmVzaXplKCk6SS5yZW1vdmVFdmVudExpc3RlbmVyKCJyZXNpemUiLEwpfSl9fXRoaXNbUl09bmV3IFNldCx0aGlzLnNldFJlc29sdXRpb24oQyksYSh0aGlzKSx0aGlzW29dPTB9Z2V0IGhhc09mZnNjcmVlbkNhbnZhcygpe3JldHVybiB0aGlzW29dPjB9c2V0IGRpc3BsYXlSYXRpbyhDKXt0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvIT09QyYmKHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW89Qyx0aGlzLnJlc2l6ZSgpKX1nZXQgZGlzcGxheVJhdGlvKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW99c2V0IGhlaWdodChDKXt0aGlzLm9wdGlvbnMuaGVpZ2h0IT09QyYmKHRoaXMub3B0aW9ucy5oZWlnaHQ9Qyx0aGlzLnJlc2l6ZSgpKX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXMub3B0aW9ucy5oZWlnaHR9c2V0IG1vZGUoQyl7dGhpcy5vcHRpb25zLm1vZGUhPT1DJiYodGhpcy5vcHRpb25zLm1vZGU9Qyx0aGlzLnJlc2l6ZSgpKX1nZXQgbW9kZSgpe3JldHVybiB0aGlzLm9wdGlvbnMubW9kZX1zZXQgd2lkdGgoQyl7dGhpcy5vcHRpb25zLndpZHRoIT09QyYmKHRoaXMub3B0aW9ucy53aWR0aD1DLHRoaXMucmVzaXplKCkpfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLm9wdGlvbnMud2lkdGh9YXBwZW5kQ2hpbGQoQyl7IShDIGluc3RhbmNlb2YgYy5kZWZhdWx0KSYmIShDIGluc3RhbmNlb2YgbC5kZWZhdWx0KSYmTyhDKTtjb25zdCBJPXN1cGVyLmFwcGVuZENoaWxkKEMpLFA9Qy5jYW52YXM7cmV0dXJuIEMub2Zmc2NyZWVuP3RoaXNbb10rKzp0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChQKSxpKHRoaXMub3B0aW9ucyxQKSxDLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLEl9Zm9yY2VVcGRhdGUoKXt0aGlzLmhhc09mZnNjcmVlbkNhbnZhcyYmIXRoaXMuX3JlcXVlc3RJRCYmKHRoaXMuX3JlcXVlc3RJRD1PYmplY3QobS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIHRoaXMuX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfWluc2VydEJlZm9yZShDLEkpeyEoQyBpbnN0YW5jZW9mIGMuZGVmYXVsdCkmJiEoQyBpbnN0YW5jZW9mIGwuZGVmYXVsdCkmJk8oQyk7Y29uc3QgUD1zdXBlci5pbnNlcnRCZWZvcmUoQyxJKSxMPUMuY2FudmFzO2lmKCFDLm9mZnNjcmVlbil7Y29uc3QgRD1nKHRoaXMsQyk7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEwsRCl9cmV0dXJuIGkodGhpcy5vcHRpb25zLEwpLEMuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksUH1sYXllcihDPSJkZWZhdWx0IixJPXt9KXtJPU9iamVjdC5hc3NpZ24oe30sdGhpcy5vcHRpb25zLEkpLEkuaWQ9Qztjb25zdCBQPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgYj0wO2I8UC5sZW5ndGg7YisrKWlmKFBbYl0uaWQ9PT1DKXJldHVybiBQW2JdO2NvbnN0IEw9SS53b3JrZXI7bGV0IEQ7cmV0dXJuIEw/RD1uZXcgbC5kZWZhdWx0KEkpOkQ9bmV3IGMuZGVmYXVsdChJKSx0aGlzLmFwcGVuZENoaWxkKEQpLER9YXN5bmMgcHJlbG9hZCguLi5DKXtjb25zdCBJPVtdLFA9W10sTD1bXTtmb3IobGV0IEQ9MDtEPEMubGVuZ3RoO0QrKyl7Y29uc3QgYj1DW0RdO2xldCBTO2lmKHR5cGVvZiBiPT0ic3RyaW5nIilTPU9iamVjdCh2LmxvYWRUZXh0dXJlKShiKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoYikpUz1PYmplY3Qodi5sb2FkRnJhbWVzKSguLi5iKTtlbHNle2NvbnN0e2lkOkIsc3JjOnd9PWI7Uz1PYmplY3Qodi5sb2FkVGV4dHVyZSkodyxCKX1TIGluc3RhbmNlb2YgUHJvbWlzZXx8KFM9UHJvbWlzZS5yZXNvbHZlKFMpKSxQLnB1c2goUy50aGVuKEI9PntJLnB1c2goQiksTFtEXT1CO2NvbnN0IHc9bmV3IGYuZGVmYXVsdCh7dHlwZToicHJlbG9hZCIsZGV0YWlsOntjdXJyZW50OkIsbG9hZGVkOkkscmVzb3VyY2VzOkN9fSk7dGhpcy5kaXNwYXRjaEV2ZW50KHcpfSkpfXJldHVybiBhd2FpdCBQcm9taXNlLmFsbChQKSxMfXJlbW92ZUNoaWxkKEMpe2NvbnN0IEk9c3VwZXIucmVtb3ZlQ2hpbGQoQyk7aWYoSSl7Qy5fcHJlcGFyZVJlbmRlckZpbmlzaGVkJiZDLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKTtjb25zdCBQPUMuY2FudmFzO1AmJlAucmVtb3ZlJiZQLnJlbW92ZSgpLEMub2Zmc2NyZWVuJiZ0aGlzW29dLS19cmV0dXJuIEl9cmVuZGVyKCl7Y29uc3QgQz10aGlzLm9yZGVyZWRDaGlsZHJlbjtsZXQgST1udWxsO2NvbnN0IFA9W107Zm9yKGxldCBMPTA7TDxDLmxlbmd0aDtMKyspe2NvbnN0IEQ9Q1tMXSxiPVAubGVuZ3RoPjA7aWYoRCBpbnN0YW5jZW9mIGMuZGVmYXVsdCYmIUQub2Zmc2NyZWVuKWlmKCFELmF1dG9SZW5kZXIpYiYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLFAubGVuZ3RoPTApO2Vsc2UgaWYoST1ELGIpe0QucmVuZGVyZXIuY2xlYXIoKTtmb3IobGV0IFM9MDtTPFAubGVuZ3RoO1MrKyl7Y29uc3QgQj1QW1NdO0IucmVuZGVyKCkscChELEIpfVAubGVuZ3RoPTAsRC5yZW5kZXIoe2NsZWFyOiExfSl9ZWxzZSBELnByZXBhcmVSZW5kZXImJkQucmVuZGVyKCk7ZWxzZSBELm9mZnNjcmVlbj9JPyhELnByZXBhcmVSZW5kZXImJkQucmVuZGVyKCkscChJLEQpKTpQLnB1c2goRCk6RCBpbnN0YW5jZW9mIGwuZGVmYXVsdCYmYiYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLFAubGVuZ3RoPTApfX1yZXBsYWNlQ2hpbGQoQyxJKXtjb25zdCBQPXN1cGVyLnJlcGxhY2VDaGlsZChDLEkpO0kuY2FudmFzLnJlbW92ZSYmSS5jYW52YXMucmVtb3ZlKCksSS5vZmZzY3JlZW4mJnRoaXNbb10tLTtjb25zdCBMPUMuY2FudmFzO2lmKCFDLm9mZnNjcmVlbil7Y29uc3QgRD1nKHRoaXMsQyk7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEwsRCl9cmV0dXJuIGkodGhpcy5vcHRpb25zLEwpLEMuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksUH1yZXNpemUoKXtjb25zdCBDPXRoaXMub3B0aW9uczt0aGlzLmNoaWxkcmVuLmZvckVhY2goST0+e2koQyxJLmNhbnZhcyl9KSx0aGlzLnNldFJlc29sdXRpb24oQyksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZXNpemUifSl9c2V0UmVzb2x1dGlvbih7d2lkdGg6QyxoZWlnaHQ6SX09e30pe2NvbnN0IFA9dGhpcy5jb250YWluZXIse2NsaWVudFdpZHRoOkwsY2xpZW50SGVpZ2h0OkR9PVA7KEM9PW51bGx8fEk9PW51bGwpJiYoQz1DPz9MLEk9ST8/RCk7Y29uc3R7bW9kZTpiLGRpc3BsYXlSYXRpbzpTfT10aGlzLm9wdGlvbnM7aWYoQyo9UyxJKj1TLHRoaXMub3B0aW9ucy5sZWZ0PTAsdGhpcy5vcHRpb25zLnRvcD0wLGI9PT0ic3RpY2t5SGVpZ2h0Inx8Yj09PSJzdGlja3lMZWZ0Inx8Yj09PSJzdGlja3lSaWdodCIpe2NvbnN0IEI9QztDPUwqSS9ELGI9PT0ic3RpY2t5SGVpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PS41KihDLUIpKSxiPT09InN0aWNreVJpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PUMtQil9ZWxzZSBpZihiPT09InN0aWNreVdpZHRoInx8Yj09PSJzdGlja3lUb3AifHxiPT09InN0aWNreUJvdHRvbSIpe2NvbnN0IEI9STtJPUQqQy9MLGI9PT0ic3RpY2t5V2lkdGgiJiYodGhpcy5vcHRpb25zLnRvcD0uNSooSS1CKSksYj09PSJzdGlja3lCb3R0b20iJiYodGhpcy5vcHRpb25zLnRvcD1JLUIpfXN1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOkMsaGVpZ2h0Okl9KX1zbmFwc2hvdCh7b2Zmc2NyZWVuOkM9ITEsbGF5ZXJzOkl9PXt9KXtjb25zdCBQPUM/InNuYXBzaG90T2ZmU2NyZWVuQ2FudmFzIjoic25hcHNob3RDYW52YXMiLHt3aWR0aDpMLGhlaWdodDpEfT10aGlzLmdldFJlc29sdXRpb24oKTt0aGlzW1BdPXRoaXNbUF18fHMuRU5WLmNyZWF0ZUNhbnZhcyhMLEQse29mZnNjcmVlbjpDfSk7Y29uc3QgYj10aGlzW1BdLmdldENvbnRleHQoIjJkIik7ST1JfHx0aGlzLm9yZGVyZWRDaGlsZHJlbix0aGlzW1BdLndpZHRoPUwsdGhpc1tQXS5oZWlnaHQ9RDtmb3IobGV0IFM9MDtTPEkubGVuZ3RoO1MrKyl7Y29uc3QgQj1JW1NdO2lmKCFCLm9wdGlvbnMuaWdub3JlU25hcHNob3Qpe0IucmVuZGVyJiZCLnJlbmRlcigpO2NvbnN0IHc9Qi5jYW52YXM7dyYmdyE9PUImJmIuZHJhd0ltYWdlKHcsMCwwLEwsRCl9fXJldHVybiB0aGlzW1BdfX10eXBlb2YgZG9jdW1lbnQ8InUiJiYoVC5wcm90b3R5cGUubGF5ZXIzZD1mdW5jdGlvbihBLEM9e30pe2NvbnN0IEk9Qy51cmx8fCJodHRwczovL3VucGtnLmNvbS9zcHJpdGUtZXh0ZW5kLTNkL2Rpc3Qvc3ByaXRlLWV4dGVuZC0zZC5taW4uanMiO3JldHVybiBuZXcgUHJvbWlzZSgoUCxMKT0+e2NvbnN0IEQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0Iik7RC5hc3luYz0hMSxELnNyYz1JLEQub25sb2FkPSgpPT57dHJ5e1AodGhpcy5sYXllcjNkKEEsQykpfWNhdGNoKGIpe0woYil9fSxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoRCl9KX0pLHguZGVmYXVsdC5yZWdpc3Rlck5vZGUoVCwic2NlbmUiKX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKGgsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KTt2YXIgcj10KDIxNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHMobSx7b2Zmc2V0VG9wOnk9MCxvZmZzZXRMZWZ0OmM9MCxkaXNwbGF5UmF0aW86bD0xfT17fSl7bGV0IHUsTTtjb25zdCBmPVtdLHtsZWZ0OnYsdG9wOngsd2lkdGg6UixoZWlnaHQ6T309bS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZz1tLnRhcmdldC53aWR0aCxwPW0udGFyZ2V0LmhlaWdodCxuPW0uY2hhbmdlZFRvdWNoZXN8fFttXTtmb3IobGV0IGk9MDtpPG4ubGVuZ3RoO2krKyl7Y29uc3Qgbz1uW2ldLFQ9by5pZGVudGlmaWVyLHtjbGllbnRYOkEsY2xpZW50WTpDfT1vO0EhPW51bGwmJkMhPW51bGwmJmYucHVzaCh7eDpNYXRoLnJvdW5kKChBfDApLXYpLHk6TWF0aC5yb3VuZCgoQ3wwKS14KSxpZGVudGlmaWVyOlR9KX1mLmxlbmd0aDw9MCYmZi5wdXNoKHt4OnUseTpNfSk7Y29uc3QgYT1bXTtyZXR1cm4gZi5mb3JFYWNoKGk9PntpLnghPW51bGwmJmkueSE9bnVsbCYmKHU9KGkueCpnL1ItYykvbCxNPShpLnkqcC9PLXkpL2wpO2NvbnN0IG89bmV3IHIuZGVmYXVsdChtKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvLHtsYXllclg6e3ZhbHVlOnUsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOk0sY29uZmlndXJhYmxlOiEwfSxvcmlnaW5hbFg6e3ZhbHVlOmkueH0sb3JpZ2luYWxZOnt2YWx1ZTppLnl9LHg6e3ZhbHVlOnUsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTpNLGNvbmZpZ3VyYWJsZTohMH0saWRlbnRpZmllcjp7dmFsdWU6aS5pZGVudGlmaWVyfX0pLGEucHVzaChvKX0pLGF9fV0pO1B0LnZlcnNpb24sUHQuQXJjLFB0LkJsb2NrLFB0LkNsb3VkLFB0LkNvbG9yLFB0LkVsbGlwc2UsUHQuR3JhZGllbnQ7Y29uc3QgU2U9UHQuR3JvdXA7UHQuTGFiZWwsUHQuTGF5ZXIsUHQuTGF5ZXJXb3JrZXIsUHQuTm9kZSxQdC5QYXJhbGxlbDtjb25zdCBiZT1QdC5QYXRoO1B0LlBvbHlsaW5lO2NvbnN0IHFlPVB0LlJlY3Q7UHQuUmVndWxhcixQdC5SaW5nO2NvbnN0IGVuPVB0LlNjZW5lO1B0LlNwcml0ZSxQdC5TcHJpdGVTdmcsUHQuU3RhcixQdC5UcmlhbmdsZSxQdC5oZWxwZXJzLFB0LmNyZWF0ZUVsZW1lbnQsUHQuaXNTcHJpdGVOb2RlLFB0LnJlZ2lzdGVyTm9kZSxQdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsUHQuY2FuY2VsQW5pbWF0aW9uRnJhbWUsUHQuRU5WO2NvbnN0IHJuPXtsaW5lYXI6aD0+aCxlYXNlSW5RdWFkOmg9PmgqaCxlYXNlT3V0UXVhZDpoPT5oKigyLWgpLGVhc2VJbk91dFF1YWQ6aD0+aDwuNT8yKmgqaDotMSsoNC0yKmgpKmgsZWFzZUluQ3ViaWM6aD0+aCpoKmgsZWFzZU91dEN1YmljOmg9Pi0taCpoKmgrMSxlYXNlSW5PdXRDdWJpYzpoPT5oPC41PzQqaCpoKmg6KGgtMSkqKDIqaC0yKSooMipoLTIpKzEsZWFzZUluUXVhcnQ6aD0+aCpoKmgqaCxlYXNlT3V0UXVhcnQ6aD0+MS0gLS1oKmgqaCpoLGVhc2VJbk91dFF1YXJ0Omg9Pmg8LjU/OCpoKmgqaCpoOjEtOCotLWgqaCpoKmgsZWFzZUluUXVpbnQ6aD0+aCpoKmgqaCpoLGVhc2VPdXRRdWludDpoPT4xKy0taCpoKmgqaCpoLGVhc2VJbk91dFF1aW50Omg9Pmg8LjU/MTYqaCpoKmgqaCpoOjErMTYqLS1oKmgqaCpoKmgsZWFzZUluU2luZTpoPT4xLU1hdGguY29zKGgqTWF0aC5QSS8yKSxlYXNlT3V0U2luZTpoPT5NYXRoLnNpbihoKk1hdGguUEkvMiksZWFzZUluT3V0U2luZTpoPT4tKE1hdGguY29zKE1hdGguUEkqaCktMSkvMixlYXNlSW5FeHBvOmg9Pmg8PTA/MDpNYXRoLnBvdygyLDEwKmgtMTApLGVhc2VPdXRFeHBvOmg9Pmg+PTE/MToxLU1hdGgucG93KDIsLTEwKmgpLGVhc2VJbk91dEV4cG86aD0+aDw9MD8wOmg+PTE/MTpoPC41P01hdGgucG93KDIsMjAqaC0xMCkvMjooMi1NYXRoLnBvdygyLC0yMCpoKzEwKSkvMn07Y2xhc3MgaHR7Y29uc3RydWN0b3IoZT0wLHQ9MCxyPTEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6cn0pfWdldCBYWSgpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXR6KGUpe3JldHVybiB0aGlzLno9ZSx0aGlzfXNldFhZKGU9dGhpcy54LHQ9dGhpcy55KXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpc31zZXQoZT10aGlzLngsdD10aGlzLnkscj10aGlzLnope3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9cix0aGlzfXNldFRvKHt4OmU9MCx5OnQ9MCx6OnI9MX0pe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9cix0aGlzfXJvdChlKXtpZihlPT09MClyZXR1cm4gdGhpcztjb25zdHt4OnQseTpyfT10aGlzLHM9TWF0aC5zaW4oZSksbT1NYXRoLmNvcyhlKTtyZXR1cm4gdGhpcy54PXQqbS1yKnMsdGhpcy55PXQqcytyKm0sdGhpc31yb3RXaXRoKGUsdCl7aWYodD09PTApcmV0dXJuIHRoaXM7Y29uc3Qgcj10aGlzLngtZS54LHM9dGhpcy55LWUueSxtPU1hdGguc2luKHQpLHk9TWF0aC5jb3ModCk7cmV0dXJuIHRoaXMueD1lLngrKHIqeS1zKm0pLHRoaXMueT1lLnkrKHIqbStzKnkpLHRoaXN9Y2xvbmUoKXtjb25zdHt4OmUseTp0LHo6cn09dGhpcztyZXR1cm4gbmV3IGh0KGUsdCxyKX1zdWIoZSl7cmV0dXJuIHRoaXMueC09ZS54LHRoaXMueS09ZS55LHRoaXN9c3ViWFkoZSx0KXtyZXR1cm4gdGhpcy54LT1lLHRoaXMueS09dCx0aGlzfXN1YlNjYWxhcihlKXtyZXR1cm4gdGhpcy54LT1lLHRoaXMueS09ZSx0aGlzfWFkZChlKXtyZXR1cm4gdGhpcy54Kz1lLngsdGhpcy55Kz1lLnksdGhpc31hZGRYWShlLHQpe3JldHVybiB0aGlzLngrPWUsdGhpcy55Kz10LHRoaXN9YWRkU2NhbGFyKGUpe3JldHVybiB0aGlzLngrPWUsdGhpcy55Kz1lLHRoaXN9Y2xhbXAoZSx0KXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHRoaXMueCxlKSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LGUpLHQhPT12b2lkIDAmJih0aGlzLng9TWF0aC5taW4odGhpcy54LHQpLHRoaXMueT1NYXRoLm1pbih0aGlzLnksdCkpLHRoaXN9ZGl2KGUpe3JldHVybiB0aGlzLngvPWUsdGhpcy55Lz1lLHRoaXN9ZGl2VihlKXtyZXR1cm4gdGhpcy54Lz1lLngsdGhpcy55Lz1lLnksdGhpc31tdWwoZSl7cmV0dXJuIHRoaXMueCo9ZSx0aGlzLnkqPWUsdGhpc31tdWxWKGUpe3JldHVybiB0aGlzLngqPWUueCx0aGlzLnkqPWUueSx0aGlzfWFicygpe3JldHVybiB0aGlzLng9TWF0aC5hYnModGhpcy54KSx0aGlzLnk9TWF0aC5hYnModGhpcy55KSx0aGlzfW51ZGdlKGUsdCl7Y29uc3Qgcj1odC5UYW4oZSx0aGlzKTtyZXR1cm4gdGhpcy5hZGQoci5tdWwodCkpfW5lZygpe3JldHVybiB0aGlzLngqPS0xLHRoaXMueSo9LTEsdGhpc31jcm9zcyhlKXtyZXR1cm4gdGhpcy54PXRoaXMueSplLnotdGhpcy56KmUueSx0aGlzLnk9dGhpcy56KmUueC10aGlzLngqZS56LHRoaXN9ZHByKGUpe3JldHVybiBodC5EcHIodGhpcyxlKX1jcHIoZSl7cmV0dXJuIGh0LkNwcih0aGlzLGUpfWxlbjIoKXtyZXR1cm4gaHQuTGVuMih0aGlzKX1sZW4oKXtyZXR1cm4gaHQuTGVuKHRoaXMpfXByeShlKXtyZXR1cm4gaHQuUHJ5KHRoaXMsZSl9cGVyKCl7Y29uc3R7eDplLHk6dH09dGhpcztyZXR1cm4gdGhpcy54PXQsdGhpcy55PS1lLHRoaXN9dW5pKCl7cmV0dXJuIGh0LlVuaSh0aGlzKX10YW4oZSl7cmV0dXJuIGh0LlRhbih0aGlzLGUpfWRpc3QoZSl7cmV0dXJuIGh0LkRpc3QodGhpcyxlKX1kaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0KXtyZXR1cm4gaHQuRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCx0aGlzKX1zbG9wZShlKXtyZXR1cm4gaHQuU2xvcGUodGhpcyxlKX1zbmFwVG9HcmlkKGUpe3JldHVybiB0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngvZSkqZSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkvZSkqZSx0aGlzfWFuZ2xlKGUpe3JldHVybiBodC5BbmdsZSh0aGlzLGUpfXRvQW5nbGUoKXtyZXR1cm4gaHQuVG9BbmdsZSh0aGlzKX1scnAoZSx0KXtyZXR1cm4gdGhpcy54PXRoaXMueCsoZS54LXRoaXMueCkqdCx0aGlzLnk9dGhpcy55KyhlLnktdGhpcy55KSp0LHRoaXN9ZXF1YWxzKGUsdCl7cmV0dXJuIGh0LkVxdWFscyh0aGlzLGUsdCl9ZXF1YWxzWFkoZSx0KXtyZXR1cm4gaHQuRXF1YWxzWFkodGhpcyxlLHQpfW5vcm0oKXtjb25zdCBlPXRoaXMubGVuKCk7cmV0dXJuIHRoaXMueD1lPT09MD8wOnRoaXMueC9lLHRoaXMueT1lPT09MD8wOnRoaXMueS9lLHRoaXN9dG9GaXhlZCgpe3JldHVybiBodC5Ub0ZpeGVkKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuIGh0LlRvU3RyaW5nKGh0LlRvRml4ZWQodGhpcykpfXRvSnNvbigpe3JldHVybiBodC5Ub0pzb24odGhpcyl9dG9BcnJheSgpe3JldHVybiBodC5Ub0FycmF5KHRoaXMpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IGh0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEFkZFhZKGUsdCxyKXtyZXR1cm4gbmV3IGh0KGUueCt0LGUueStyKX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBodChlLngtdC54LGUueS10LnkpfXN0YXRpYyBTdWJYWShlLHQscil7cmV0dXJuIG5ldyBodChlLngtdCxlLnktcil9c3RhdGljIEFkZFNjYWxhcihlLHQpe3JldHVybiBuZXcgaHQoZS54K3QsZS55K3QpfXN0YXRpYyBTdWJTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IGh0KGUueC10LGUueS10KX1zdGF0aWMgRGl2KGUsdCl7cmV0dXJuIG5ldyBodChlLngvdCxlLnkvdCl9c3RhdGljIE11bChlLHQpe3JldHVybiBuZXcgaHQoZS54KnQsZS55KnQpfXN0YXRpYyBEaXZWKGUsdCl7cmV0dXJuIG5ldyBodChlLngvdC54LGUueS90LnkpfXN0YXRpYyBNdWxWKGUsdCl7cmV0dXJuIG5ldyBodChlLngqdC54LGUueSp0LnkpfXN0YXRpYyBOZWcoZSl7cmV0dXJuIG5ldyBodCgtZS54LC1lLnkpfXN0YXRpYyBQZXIoZSl7cmV0dXJuIG5ldyBodChlLnksLWUueCl9c3RhdGljIERpc3QyKGUsdCl7cmV0dXJuIGh0LlN1YihlLHQpLmxlbjIoKX1zdGF0aWMgQWJzKGUpe3JldHVybiBuZXcgaHQoTWF0aC5hYnMoZS54KSxNYXRoLmFicyhlLnkpKX1zdGF0aWMgRGlzdChlLHQpe3JldHVybiBNYXRoLmh5cG90KGUueS10LnksZS54LXQueCl9c3RhdGljIERwcihlLHQpe3JldHVybiBlLngqdC54K2UueSp0Lnl9c3RhdGljIENyb3NzKGUsdCl7cmV0dXJuIG5ldyBodChlLnkqdC56LWUueip0LnksZS56KnQueC1lLngqdC56KX1zdGF0aWMgQ3ByKGUsdCl7cmV0dXJuIGUueCp0LnktdC54KmUueX1zdGF0aWMgTGVuMihlKXtyZXR1cm4gZS54KmUueCtlLnkqZS55fXN0YXRpYyBMZW4oZSl7cmV0dXJuIE1hdGguaHlwb3QoZS54LGUueSl9c3RhdGljIFByeShlLHQpe3JldHVybiBodC5EcHIoZSx0KS9odC5MZW4odCl9c3RhdGljIFVuaShlKXtyZXR1cm4gaHQuRGl2KGUsaHQuTGVuKGUpKX1zdGF0aWMgVGFuKGUsdCl7cmV0dXJuIGh0LlVuaShodC5TdWIoZSx0KSl9c3RhdGljIE1pbihlLHQpe3JldHVybiBuZXcgaHQoTWF0aC5taW4oZS54LHQueCksTWF0aC5taW4oZS55LHQueSkpfXN0YXRpYyBNYXgoZSx0KXtyZXR1cm4gbmV3IGh0KE1hdGgubWF4KGUueCx0LngpLE1hdGgubWF4KGUueSx0LnkpKX1zdGF0aWMgRnJvbShlKXtyZXR1cm4gbmV3IGh0KCkuYWRkKGUpfXN0YXRpYyBGcm9tQXJyYXkoZSl7cmV0dXJuIG5ldyBodChlWzBdLGVbMV0pfXN0YXRpYyBSb3QoZSx0PTApe2NvbnN0IHI9TWF0aC5zaW4odCkscz1NYXRoLmNvcyh0KTtyZXR1cm4gbmV3IGh0KGUueCpzLWUueSpyLGUueCpyK2UueSpzKX1zdGF0aWMgUm90V2l0aChlLHQscil7Y29uc3Qgcz1lLngtdC54LG09ZS55LXQueSx5PU1hdGguc2luKHIpLGM9TWF0aC5jb3Mocik7cmV0dXJuIG5ldyBodCh0LngrKHMqYy1tKnkpLHQueSsocyp5K20qYykpfXN0YXRpYyBOZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LHIpe3JldHVybiBodC5NdWwodCxodC5TdWIocixlKS5wcnkodCkpLmFkZChlKX1zdGF0aWMgTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQscixzPSEwKXtjb25zdCBtPWh0LlRhbih0LGUpLHk9aHQuQWRkKGUsaHQuTXVsKG0saHQuU3ViKHIsZSkucHJ5KG0pKSk7aWYocyl7aWYoeS54PE1hdGgubWluKGUueCx0LngpKXJldHVybiBodC5DYXN0KGUueDx0Lng/ZTp0KTtpZih5Lng+TWF0aC5tYXgoZS54LHQueCkpcmV0dXJuIGh0LkNhc3QoZS54PnQueD9lOnQpO2lmKHkueTxNYXRoLm1pbihlLnksdC55KSlyZXR1cm4gaHQuQ2FzdChlLnk8dC55P2U6dCk7aWYoeS55Pk1hdGgubWF4KGUueSx0LnkpKXJldHVybiBodC5DYXN0KGUueT50Lnk/ZTp0KX1yZXR1cm4geX1zdGF0aWMgRGlzdGFuY2VUb0xpbmVUaHJvdWdoUG9pbnQoZSx0LHIpe3JldHVybiBodC5EaXN0KHIsaHQuTmVhcmVzdFBvaW50T25MaW5lVGhyb3VnaFBvaW50KGUsdCxyKSl9c3RhdGljIERpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQscixzPSEwKXtyZXR1cm4gaHQuRGlzdChyLGh0Lk5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoZSx0LHIscykpfXN0YXRpYyBTbmFwKGUsdD0xKXtyZXR1cm4gbmV3IGh0KE1hdGgucm91bmQoZS54L3QpKnQsTWF0aC5yb3VuZChlLnkvdCkqdCl9c3RhdGljIENhc3QoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBodD9lOmh0LkZyb20oZSl9c3RhdGljIFNsb3BlKGUsdCl7cmV0dXJuIGUueD09PXQueT9OYU46KGUueS10LnkpLyhlLngtdC54KX1zdGF0aWMgQW5nbGUoZSx0KXtyZXR1cm4gTWF0aC5hdGFuMih0LnktZS55LHQueC1lLngpfXN0YXRpYyBMcnAoZSx0LHIpe3JldHVybiBodC5TdWIodCxlKS5tdWwocikuYWRkKGUpfXN0YXRpYyBNZWQoZSx0KXtyZXR1cm4gbmV3IGh0KChlLngrdC54KS8yLChlLnkrdC55KS8yKX1zdGF0aWMgRXF1YWxzKGUsdCxyPTFlLTQpe3JldHVybiBNYXRoLmFicyhlLngtdC54KTxyJiZNYXRoLmFicyhlLnktdC55KTxyfXN0YXRpYyBFcXVhbHNYWShlLHQscil7cmV0dXJuIGUueD09PXQmJmUueT09PXJ9c3RhdGljIEVxdWFsc1hZWihlLHQscj0xZS00KXtyZXR1cm4gaHQuRXF1YWxzKGUsdCxyKSYmTWF0aC5hYnMoKGUuenx8MCktKHQuenx8MCkpPHJ9c3RhdGljIENsb2Nrd2lzZShlLHQscil7cmV0dXJuKHIueC1lLngpKih0LnktZS55KS0odC54LWUueCkqKHIueS1lLnkpPDB9c3RhdGljIFJlc2NhbGUoZSx0KXtjb25zdCByPWh0LkxlbihlKTtyZXR1cm4gbmV3IGh0KHQqZS54L3IsdCplLnkvcil9c3RhdGljIFNjYWxlV2l0aE9yaWdpbihlLHQscil7cmV0dXJuIGh0LlN1YihlLHIpLm11bCh0KS5hZGQocil9c3RhdGljIFNjYWxlV09yaWdpbihlLHQscil7cmV0dXJuIGh0LlN1YihlLHIpLm11bFYodCkuYWRkKHIpfXN0YXRpYyBUb0ZpeGVkKGUsdD0yKXtyZXR1cm4gbmV3IGh0KCtlLngudG9GaXhlZCh0KSwrZS55LnRvRml4ZWQodCksK2Uuei50b0ZpeGVkKHQpKX1zdGF0aWMgTnVkZ2UoZSx0LHIpe3JldHVybiBodC5BZGQoZSxodC5UYW4odCxlKS5tdWwocikpfXN0YXRpYyBUb1N0cmluZyhlKXtyZXR1cm5gJHtlLnh9LCAke2UueX1gfXN0YXRpYyBUb0FuZ2xlKGUpe2xldCB0PU1hdGguYXRhbjIoZS55LGUueCk7cmV0dXJuIHQ8MCYmKHQrPU1hdGguUEkqMiksdH1zdGF0aWMgRnJvbUFuZ2xlKGUsdD0xKXtyZXR1cm4gbmV3IGh0KE1hdGguY29zKGUpKnQsTWF0aC5zaW4oZSkqdCl9c3RhdGljIFRvQXJyYXkoZSl7cmV0dXJuW2UueCxlLnksZS56XX1zdGF0aWMgVG9Kc29uKGUpe2NvbnN0e3g6dCx5OnIsejpzfT1lO3JldHVybnt4OnQseTpyLHo6c319c3RhdGljIEF2ZXJhZ2UoZSl7Y29uc3QgdD1lLmxlbmd0aCxyPW5ldyBodCgwLDApO2ZvcihsZXQgcz0wO3M8dDtzKyspci5hZGQoZVtzXSk7cmV0dXJuIHIuZGl2KHQpfXN0YXRpYyBDbGFtcChlLHQscil7cmV0dXJuIHI9PT12b2lkIDA/bmV3IGh0KE1hdGgubWluKE1hdGgubWF4KGUueCx0KSksTWF0aC5taW4oTWF0aC5tYXgoZS55LHQpKSk6bmV3IGh0KE1hdGgubWluKE1hdGgubWF4KGUueCx0KSxyKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkscikpfXN0YXRpYyBQb2ludHNCZXR3ZWVuKGUsdCxyPTYpe2NvbnN0IHM9W107Zm9yKGxldCBtPTA7bTxyO20rKyl7Y29uc3QgeT1ybi5lYXNlSW5RdWFkKG0vKHItMSkpLGM9aHQuTHJwKGUsdCx5KTtjLno9TWF0aC5taW4oMSwuNStNYXRoLmFicyguNS1ubih5KSkqLjY1KSxzLnB1c2goYyl9cmV0dXJuIHN9c3RhdGljIFNuYXBUb0dyaWQoZSx0PTgpe3JldHVybiBuZXcgaHQoTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX19Y29uc3Qgbm49aD0+aDwuNT8yKmgqaDotMSsoNC0yKmgpKmg7Y2xhc3MgQXQgZXh0ZW5kcyBodHtjb25zdHJ1Y3RvcihlPTAsdD0wLHI9MCxzPXt4OjAseTowfSxtPTAseT0wKXtzdXBlcihlLHQsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInYiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpzfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTptfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImEiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp5fSl9Z2V0IHRpbWVzdGFtcCgpe3JldHVybiB0aGlzLnR9Z2V0IHByZXNzdXJlKCl7cmV0dXJuIHRoaXMuen1nZXQgYW5nbGVOdW0oKXtyZXR1cm4gdGhpcy5hfWdldCBYWSgpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXRBKGUpe3RoaXMuYT1lfXNldFQoZSl7dGhpcy50PWV9c2V0dihlKXtyZXR1cm4gdGhpcy52PXt4OmUueCx5OmUueX0sdGhpc31zZXQoZT10aGlzLngsdD10aGlzLnkscj10aGlzLnoscz10aGlzLnYsbT10aGlzLnQseT10aGlzLmEpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9cix0aGlzLnY9cyx0aGlzLnQ9bSx0aGlzLmE9eSx0aGlzfWNsb25lKCl7Y29uc3R7eDplLHk6dCx6OnIsdjpzLHQ6bSxhOnl9PXRoaXMsYz17eDpzLngseTpzLnl9O3JldHVybiBuZXcgQXQoZSx0LHIsYyxtLHkpfWRpc3RhbmNlKGUpe3JldHVybiBBdC5HZXREaXN0YW5jZSh0aGlzLGUpfWlzTmVhcihlLHQpe3JldHVybiBBdC5Jc05lYXIodGhpcyxlLHQpfWdldEFuZ2xlQnlQb2ludHMoZSx0KXtyZXR1cm4gQXQuR2V0QW5nbGVCeVBvaW50cyhlLHRoaXMsdCl9c3RhdGljIFN1YihlLHQpe3JldHVybiBuZXcgQXQoZS54LXQueCxlLnktdC55KX1zdGF0aWMgQWRkKGUsdCl7cmV0dXJuIG5ldyBBdChlLngrdC54LGUueSt0LnkpfXN0YXRpYyBHZXREaXN0YW5jZShlLHQpe3JldHVybiBBdC5MZW4oZS5jbG9uZSgpLnN1Yih0KSl9c3RhdGljIEdldEFuZ2xlQnlQb2ludHMoZSx0LHIpe2NvbnN0IHM9dC54LWUueCxtPXIueC10LngseT10LnktZS55LGM9ci55LXQueTtsZXQgbD0wO2NvbnN0IHU9TWF0aC5zcXJ0KHMqcyt5KnkpLE09TWF0aC5zcXJ0KG0qbStjKmMpO2lmKHUmJk0pe2NvbnN0IGY9cyptK3kqYztsPU1hdGguYWNvcyhmLyh1Kk0pKSxsPWwvTWF0aC5QSSoxODA7bGV0IHY9cypjLXkqbTt2PXY+MD8xOi0xLGw9MTgwK3YqbH1yZXR1cm4gbH1zdGF0aWMgSXNOZWFyKGUsdCxyKXtyZXR1cm4gQXQuTGVuKGUuY2xvbmUoKS5zdWIodCkpPHJ9c3RhdGljIFJvdFdpdGgoZSx0LHIscz0yKXtjb25zdCBtPWUueC10LngseT1lLnktdC55LGM9TWF0aC5zaW4ociksbD1NYXRoLmNvcyhyKSx1PU1hdGgucG93KDEwLHMpLE09TWF0aC5mbG9vcigodC54KyhtKmwteSpjKSkqdSkvdSxmPU1hdGguZmxvb3IoKHQueSsobSpjK3kqbCkpKnUpL3U7cmV0dXJuIG5ldyBBdChNLGYpfXN0YXRpYyBHZXREb3RTdHJva2UoZSx0LHI9MTYpe2NvbnN0IHM9bmV3IGh0KDEsMSksbT1NYXRoLlBJKy4wMDEseT1BdC5BZGQoZSxBdC5TdWIoZSxzKS51bmkoKS5wZXIoKS5tdWwoLXQpKSxjPVtdO2ZvcihsZXQgbD0xL3IsdT1sO3U8PTE7dSs9bCljLnB1c2goQXQuUm90V2l0aCh5LGUsbSoyKnUpKTtyZXR1cm4gY31zdGF0aWMgR2V0U2VtaWNpcmNsZVN0cm9rZShlLHQscj0tMSxzPTgpe2NvbnN0IG09ciooTWF0aC5QSSsuMDAxKSx5PVtdO2ZvcihsZXQgYz0xL3MsbD1jO2w8PTE7bCs9Yyl5LnB1c2goQXQuUm90V2l0aCh0LGUsbSpsKSk7cmV0dXJuIHl9fXZhciBrZTsoZnVuY3Rpb24oaCl7aFtoLnBlZGRpbmc9MF09InBlZGRpbmciLGhbaC5tb3VudGVkPTFdPSJtb3VudGVkIixoW2gudXBkYXRlPTJdPSJ1cGRhdGUiLGhbaC51bm1vdW50ZWQ9M109InVubW91bnRlZCJ9KShrZXx8KGtlPXt9KSk7dmFyIGJ0OyhmdW5jdGlvbihoKXtoW2guTm9ybWFsPTBdPSJOb3JtYWwiLGhbaC5TdHJva2U9MV09IlN0cm9rZSIsaFtoLkRvdHRlZD0yXT0iRG90dGVkIixoW2guTG9uZ0RvdHRlZD0zXT0iTG9uZ0RvdHRlZCJ9KShidHx8KGJ0PXt9KSk7dmFyIF9lOyhmdW5jdGlvbihoKXtoLlNob3dGbG9hdEJhcj0iU2hvd0Zsb2F0QmFyIixoLlpJbmRleEZsb2F0QmFyPSJaSW5kZXhGbG9hdEJhciIsaC5EZWxldGVOb2RlPSJEZWxldGVOb2RlIixoLkNvcHlOb2RlPSJDb3B5Tm9kZSIsaC5aSW5kZXhBY3RpdmU9IlpJbmRleEFjdGl2ZSIsaC5aSW5kZXhOb2RlPSJaSW5kZXhOb2RlIixoLlJvdGF0ZU5vZGU9IlJvdGF0ZU5vZGUiLGguU2V0Q29sb3JOb2RlPSJTZXRDb2xvck5vZGUiLGguVHJhbnNsYXRlTm9kZT0iVHJhbnNsYXRlTm9kZSIsaC5TY2FsZU5vZGU9IlNjYWxlTm9kZSIsaC5PcmlnaW5hbEV2ZW50PSJPcmlnaW5hbEV2ZW50IixoLkNyZWF0ZVNjZW5lPSJjcmVhdGVTY2VuZSJ9KShfZXx8KF9lPXt9KSk7dmFyIHRyOyhmdW5jdGlvbihoKXtoLkRpc3BsYXlTdGF0ZT0iRGlzcGxheVN0YXRlIixoLkZsb2F0QmFyPSJGbG9hdEJhciIsaC5DYW52YXNTZWxlY3Rvcj0iQ2FudmFzU2VsZWN0b3IiLGguTWFpbkVuZ2luZT0iTWFpbkVuZ2luZSIsaC5EaXNwbGF5Q29udGFpbmVyPSJEaXNwbGF5Q29udGFpbmVyIn0pKHRyfHwodHI9e30pKTtmdW5jdGlvbiBMdChoLGUpe2lmKGgmJmUpe2NvbnN0IHQ9TWF0aC5taW4oaD09bnVsbD92b2lkIDA6aC54LGUueCkscj1NYXRoLm1pbihoPT1udWxsP3ZvaWQgMDpoLnksZS55KSxzPU1hdGgubWF4KGgueCtoLncsZS54K2UudyksbT1NYXRoLm1heChoLnkraC5oLGUueStlLmgpLHk9cy10LGM9bS1yO3JldHVybnt4OnQseTpyLHc6eSxoOmN9fXJldHVybiBlfHxofWZ1bmN0aW9uIEh0KGgsZT0wKXtjb25zdCB0PXt4OjAseTowLHc6MCxoOjB9O2xldCByPTEvMCxzPTEvMCxtPS0xLzAseT0tMS8wO3JldHVybiBoLmZvckVhY2goYz0+e2NvbnN0W2wsdV09Yy5YWTtyPU1hdGgubWluKHIsbC1lKSxzPU1hdGgubWluKHMsdS1lKSxtPU1hdGgubWF4KG0sbCtlKSx5PU1hdGgubWF4KHksdStlKX0pLHQueD1yLHQueT1zLHQudz1tLXIsdC5oPXktcyx0fWZ1bmN0aW9uIGVyKGgsZSl7cmV0dXJuIShoLngraC53PGUueHx8aC54PmUueCtlLnd8fGgueStoLmg8ZS55fHxoLnk+ZS55K2UuaCl9ZnVuY3Rpb24gc24oaCxlKXtyZXR1cm4gaC5sZW5ndGg9PT1lLmxlbmd0aCYmaC5zb3J0KCkudG9TdHJpbmcoKT09PWUuc29ydCgpLnRvU3RyaW5nKCl9ZnVuY3Rpb24gYW4oaCxlKXtjb25zdCB0PW5ldyBodChoLngsaC55KSxyPW5ldyBodChoLngraC53LGgueSkscz1uZXcgaHQoaC54K2gudyxoLnkraC5oKSxtPW5ldyBodChoLngsaC55K2guaCkseT1uZXcgaHQoaC54K2gudy8yLGgueStoLmgvMiksYz1NYXRoLlBJKmUvMTgwLGw9aHQuUm90V2l0aCh0LHksYyksdT1odC5Sb3RXaXRoKHIseSxjKSxNPWh0LlJvdFdpdGgocyx5LGMpLGY9aHQuUm90V2l0aChtLHksYyk7cmV0dXJuIEh0KFtsLHUsTSxmXSl9ZnVuY3Rpb24gb24oaCxlKXtjb25zdCB0PW5ldyBodChoLngsaC55KSxyPW5ldyBodChoLngraC53LGgueSkscz1uZXcgaHQoaC54K2gudyxoLnkraC5oKSxtPW5ldyBodChoLngsaC55K2guaCkseT1uZXcgaHQoaC54K2gudy8yLGgueStoLmgvMiksYz1uZXcgaHQoZVswXSxlWzFdKSxsPWh0LlNjYWxlV09yaWdpbih0LGMseSksdT1odC5TY2FsZVdPcmlnaW4ocixjLHkpLE09aHQuU2NhbGVXT3JpZ2luKHMsYyx5KSxmPWh0LlNjYWxlV09yaWdpbihtLGMseSk7cmV0dXJuIEh0KFtsLHUsTSxmXSl9ZnVuY3Rpb24gWnQoaCxlKXtsZXQgdDtyZXR1cm4gZT09bnVsbHx8ZS5nZXRFbGVtZW50c0J5TmFtZShoKS5mb3JFYWNoKHI9PntpZihyLnRhZ05hbWU9PT0iUEFUSCIpe2NvbnN0IHM9cj09bnVsbD92b2lkIDA6ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtzJiYodD1MdCh0LHt4Ok1hdGguZmxvb3Iocy54KSx5Ok1hdGguZmxvb3Iocy55KSx3Ok1hdGgucm91bmQocy53aWR0aCksaDpNYXRoLnJvdW5kKHMuaGVpZ2h0KX0pKX1lbHNlIGlmKHIudGFnTmFtZT09PSJHUk9VUCIpe2NvbnN0IHM9ci5jbGFzc05hbWUuc3BsaXQoIiwiKTtpZihzLmxlbmd0aD09PTMmJk51bWJlcihzWzJdKT09PWJ0LlN0cm9rZSl7Y29uc3QgbT1yPT1udWxsP3ZvaWQgMDpyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO20mJih0PUx0KHQse3g6TWF0aC5mbG9vcihtLngpLHk6TWF0aC5mbG9vcihtLnkpLHc6TWF0aC5yb3VuZChtLndpZHRoKSxoOk1hdGgucm91bmQobS5oZWlnaHQpfSkpfWVsc2Ugci5jaGlsZHJlbi5mb3JFYWNoKG09PntpZihtLnRhZ05hbWU9PT0iUEFUSCIpe2NvbnN0IHk9bT09bnVsbD92b2lkIDA6bS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt5JiYodD1MdCh0LHt4Ok1hdGguZmxvb3IoeS54KSx5Ok1hdGguZmxvb3IoeS55KSx3Ok1hdGgucm91bmQoeS53aWR0aCksaDpNYXRoLnJvdW5kKHkuaGVpZ2h0KX0pKX19KX19KSx0fWZ1bmN0aW9uIHF0KGgpe3JldHVybmAke2hlKGgueCl9LCR7aGUoaC55KX0gYH1mdW5jdGlvbiBrdChoLGUpe3JldHVybmAke2hlKChoLngrZS54KS8yKX0sJHtoZSgoaC55K2UueSkvMil9IGB9ZnVuY3Rpb24gaGUoaCl7cmV0dXJuK2gudG9GaXhlZCg0KX1mdW5jdGlvbiBkZShoLGU9ITApe2NvbnN0IHQ9aC5sZW5ndGg7aWYodDwyKXJldHVybiIiO2xldCByPWhbMF0scz1oWzFdO2lmKHQ9PT0yKXJldHVybmBNJHtxdChyKX1MJHtxdChzKX1gO2xldCBtPSIiO2ZvcihsZXQgeT0yLGM9dC0xO3k8Yzt5Kyspcj1oW3ldLHM9aFt5KzFdLG0rPWt0KHIscyk7cmV0dXJuIGU/YE0ke2t0KGhbMF0saFsxXSl9USR7cXQoaFsxXSl9JHtrdChoWzFdLGhbMl0pfVQke219JHtrdChoW3QtMV0saFswXSl9JHtrdChoWzBdLGhbMV0pfVpgOmBNJHtxdChoWzBdKX1RJHtxdChoWzFdKX0ke2t0KGhbMV0saFsyXSl9JHtoLmxlbmd0aD4zPyJUIjoiIn0ke219TCR7cXQoaFt0LTFdKX1gfXZhciBnZT10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIHJyKGgpe3JldHVybiBoJiZoLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoLCJkZWZhdWx0Iik/aC5kZWZhdWx0Omh9dmFyIFJlPXtleHBvcnRzOnt9fTtSZS5leHBvcnRzLGZ1bmN0aW9uKGgpe3ZhciBlPWZ1bmN0aW9uKCl7dmFyIHQ9U3RyaW5nLmZyb21DaGFyQ29kZSxyPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSIscz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLSQiLG09e307ZnVuY3Rpb24geShsLHUpe2lmKCFtW2xdKXttW2xdPXt9O2Zvcih2YXIgTT0wO008bC5sZW5ndGg7TSsrKW1bbF1bbC5jaGFyQXQoTSldPU19cmV0dXJuIG1bbF1bdV19dmFyIGM9e2NvbXByZXNzVG9CYXNlNjQ6ZnVuY3Rpb24obCl7aWYobD09bnVsbClyZXR1cm4iIjt2YXIgdT1jLl9jb21wcmVzcyhsLDYsZnVuY3Rpb24oTSl7cmV0dXJuIHIuY2hhckF0KE0pfSk7c3dpdGNoKHUubGVuZ3RoJTQpe2RlZmF1bHQ6Y2FzZSAwOnJldHVybiB1O2Nhc2UgMTpyZXR1cm4gdSsiPT09IjtjYXNlIDI6cmV0dXJuIHUrIj09IjtjYXNlIDM6cmV0dXJuIHUrIj0ifX0sZGVjb21wcmVzc0Zyb21CYXNlNjQ6ZnVuY3Rpb24obCl7cmV0dXJuIGw9PW51bGw/IiI6bD09IiI/bnVsbDpjLl9kZWNvbXByZXNzKGwubGVuZ3RoLDMyLGZ1bmN0aW9uKHUpe3JldHVybiB5KHIsbC5jaGFyQXQodSkpfSl9LGNvbXByZXNzVG9VVEYxNjpmdW5jdGlvbihsKXtyZXR1cm4gbD09bnVsbD8iIjpjLl9jb21wcmVzcyhsLDE1LGZ1bmN0aW9uKHUpe3JldHVybiB0KHUrMzIpfSkrIiAifSxkZWNvbXByZXNzRnJvbVVURjE2OmZ1bmN0aW9uKGwpe3JldHVybiBsPT1udWxsPyIiOmw9PSIiP251bGw6Yy5fZGVjb21wcmVzcyhsLmxlbmd0aCwxNjM4NCxmdW5jdGlvbih1KXtyZXR1cm4gbC5jaGFyQ29kZUF0KHUpLTMyfSl9LGNvbXByZXNzVG9VaW50OEFycmF5OmZ1bmN0aW9uKGwpe2Zvcih2YXIgdT1jLmNvbXByZXNzKGwpLE09bmV3IFVpbnQ4QXJyYXkodS5sZW5ndGgqMiksZj0wLHY9dS5sZW5ndGg7Zjx2O2YrKyl7dmFyIHg9dS5jaGFyQ29kZUF0KGYpO01bZioyXT14Pj4+OCxNW2YqMisxXT14JTI1Nn1yZXR1cm4gTX0sZGVjb21wcmVzc0Zyb21VaW50OEFycmF5OmZ1bmN0aW9uKGwpe2lmKGw9PW51bGwpcmV0dXJuIGMuZGVjb21wcmVzcyhsKTtmb3IodmFyIHU9bmV3IEFycmF5KGwubGVuZ3RoLzIpLE09MCxmPXUubGVuZ3RoO008ZjtNKyspdVtNXT1sW00qMl0qMjU2K2xbTSoyKzFdO3ZhciB2PVtdO3JldHVybiB1LmZvckVhY2goZnVuY3Rpb24oeCl7di5wdXNoKHQoeCkpfSksYy5kZWNvbXByZXNzKHYuam9pbigiIikpfSxjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihsKXtyZXR1cm4gbD09bnVsbD8iIjpjLl9jb21wcmVzcyhsLDYsZnVuY3Rpb24odSl7cmV0dXJuIHMuY2hhckF0KHUpfSl9LGRlY29tcHJlc3NGcm9tRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbihsKXtyZXR1cm4gbD09bnVsbD8iIjpsPT0iIj9udWxsOihsPWwucmVwbGFjZSgvIC9nLCIrIiksYy5fZGVjb21wcmVzcyhsLmxlbmd0aCwzMixmdW5jdGlvbih1KXtyZXR1cm4geShzLGwuY2hhckF0KHUpKX0pKX0sY29tcHJlc3M6ZnVuY3Rpb24obCl7cmV0dXJuIGMuX2NvbXByZXNzKGwsMTYsZnVuY3Rpb24odSl7cmV0dXJuIHQodSl9KX0sX2NvbXByZXNzOmZ1bmN0aW9uKGwsdSxNKXtpZihsPT1udWxsKXJldHVybiIiO3ZhciBmLHYseD17fSxSPXt9LE89IiIsZz0iIixwPSIiLG49MixhPTMsaT0yLG89W10sVD0wLEE9MCxDO2ZvcihDPTA7QzxsLmxlbmd0aDtDKz0xKWlmKE89bC5jaGFyQXQoQyksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsTyl8fCh4W09dPWErKyxSW09dPSEwKSxnPXArTyxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCxnKSlwPWc7ZWxzZXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUixwKSl7aWYocC5jaGFyQ29kZUF0KDApPDI1Nil7Zm9yKGY9MDtmPGk7ZisrKVQ9VDw8MSxBPT11LTE/KEE9MCxvLnB1c2goTShUKSksVD0wKTpBKys7Zm9yKHY9cC5jaGFyQ29kZUF0KDApLGY9MDtmPDg7ZisrKVQ9VDw8MXx2JjEsQT09dS0xPyhBPTAsby5wdXNoKE0oVCkpLFQ9MCk6QSsrLHY9dj4+MX1lbHNle2Zvcih2PTEsZj0wO2Y8aTtmKyspVD1UPDwxfHYsQT09dS0xPyhBPTAsby5wdXNoKE0oVCkpLFQ9MCk6QSsrLHY9MDtmb3Iodj1wLmNoYXJDb2RlQXQoMCksZj0wO2Y8MTY7ZisrKVQ9VDw8MXx2JjEsQT09dS0xPyhBPTAsby5wdXNoKE0oVCkpLFQ9MCk6QSsrLHY9dj4+MX1uLS0sbj09MCYmKG49TWF0aC5wb3coMixpKSxpKyspLGRlbGV0ZSBSW3BdfWVsc2UgZm9yKHY9eFtwXSxmPTA7ZjxpO2YrKylUPVQ8PDF8diYxLEE9PXUtMT8oQT0wLG8ucHVzaChNKFQpKSxUPTApOkErKyx2PXY+PjE7bi0tLG49PTAmJihuPU1hdGgucG93KDIsaSksaSsrKSx4W2ddPWErKyxwPVN0cmluZyhPKX1pZihwIT09IiIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChSLHApKXtpZihwLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IoZj0wO2Y8aTtmKyspVD1UPDwxLEE9PXUtMT8oQT0wLG8ucHVzaChNKFQpKSxUPTApOkErKztmb3Iodj1wLmNoYXJDb2RlQXQoMCksZj0wO2Y8ODtmKyspVD1UPDwxfHYmMSxBPT11LTE/KEE9MCxvLnB1c2goTShUKSksVD0wKTpBKyssdj12Pj4xfWVsc2V7Zm9yKHY9MSxmPTA7ZjxpO2YrKylUPVQ8PDF8dixBPT11LTE/KEE9MCxvLnB1c2goTShUKSksVD0wKTpBKyssdj0wO2Zvcih2PXAuY2hhckNvZGVBdCgwKSxmPTA7ZjwxNjtmKyspVD1UPDwxfHYmMSxBPT11LTE/KEE9MCxvLnB1c2goTShUKSksVD0wKTpBKyssdj12Pj4xfW4tLSxuPT0wJiYobj1NYXRoLnBvdygyLGkpLGkrKyksZGVsZXRlIFJbcF19ZWxzZSBmb3Iodj14W3BdLGY9MDtmPGk7ZisrKVQ9VDw8MXx2JjEsQT09dS0xPyhBPTAsby5wdXNoKE0oVCkpLFQ9MCk6QSsrLHY9dj4+MTtuLS0sbj09MCYmKG49TWF0aC5wb3coMixpKSxpKyspfWZvcih2PTIsZj0wO2Y8aTtmKyspVD1UPDwxfHYmMSxBPT11LTE/KEE9MCxvLnB1c2goTShUKSksVD0wKTpBKyssdj12Pj4xO2Zvcig7OylpZihUPVQ8PDEsQT09dS0xKXtvLnB1c2goTShUKSk7YnJlYWt9ZWxzZSBBKys7cmV0dXJuIG8uam9pbigiIil9LGRlY29tcHJlc3M6ZnVuY3Rpb24obCl7cmV0dXJuIGw9PW51bGw/IiI6bD09IiI/bnVsbDpjLl9kZWNvbXByZXNzKGwubGVuZ3RoLDMyNzY4LGZ1bmN0aW9uKHUpe3JldHVybiBsLmNoYXJDb2RlQXQodSl9KX0sX2RlY29tcHJlc3M6ZnVuY3Rpb24obCx1LE0pe3ZhciBmPVtdLHY9NCx4PTQsUj0zLE89IiIsZz1bXSxwLG4sYSxpLG8sVCxBLEM9e3ZhbDpNKDApLHBvc2l0aW9uOnUsaW5kZXg6MX07Zm9yKHA9MDtwPDM7cCs9MSlmW3BdPXA7Zm9yKGE9MCxvPU1hdGgucG93KDIsMiksVD0xO1QhPW87KWk9Qy52YWwmQy5wb3NpdGlvbixDLnBvc2l0aW9uPj49MSxDLnBvc2l0aW9uPT0wJiYoQy5wb3NpdGlvbj11LEMudmFsPU0oQy5pbmRleCsrKSksYXw9KGk+MD8xOjApKlQsVDw8PTE7c3dpdGNoKGEpe2Nhc2UgMDpmb3IoYT0wLG89TWF0aC5wb3coMiw4KSxUPTE7VCE9bzspaT1DLnZhbCZDLnBvc2l0aW9uLEMucG9zaXRpb24+Pj0xLEMucG9zaXRpb249PTAmJihDLnBvc2l0aW9uPXUsQy52YWw9TShDLmluZGV4KyspKSxhfD0oaT4wPzE6MCkqVCxUPDw9MTtBPXQoYSk7YnJlYWs7Y2FzZSAxOmZvcihhPTAsbz1NYXRoLnBvdygyLDE2KSxUPTE7VCE9bzspaT1DLnZhbCZDLnBvc2l0aW9uLEMucG9zaXRpb24+Pj0xLEMucG9zaXRpb249PTAmJihDLnBvc2l0aW9uPXUsQy52YWw9TShDLmluZGV4KyspKSxhfD0oaT4wPzE6MCkqVCxUPDw9MTtBPXQoYSk7YnJlYWs7Y2FzZSAyOnJldHVybiIifWZvcihmWzNdPUEsbj1BLGcucHVzaChBKTs7KXtpZihDLmluZGV4PmwpcmV0dXJuIiI7Zm9yKGE9MCxvPU1hdGgucG93KDIsUiksVD0xO1QhPW87KWk9Qy52YWwmQy5wb3NpdGlvbixDLnBvc2l0aW9uPj49MSxDLnBvc2l0aW9uPT0wJiYoQy5wb3NpdGlvbj11LEMudmFsPU0oQy5pbmRleCsrKSksYXw9KGk+MD8xOjApKlQsVDw8PTE7c3dpdGNoKEE9YSl7Y2FzZSAwOmZvcihhPTAsbz1NYXRoLnBvdygyLDgpLFQ9MTtUIT1vOylpPUMudmFsJkMucG9zaXRpb24sQy5wb3NpdGlvbj4+PTEsQy5wb3NpdGlvbj09MCYmKEMucG9zaXRpb249dSxDLnZhbD1NKEMuaW5kZXgrKykpLGF8PShpPjA/MTowKSpULFQ8PD0xO2ZbeCsrXT10KGEpLEE9eC0xLHYtLTticmVhaztjYXNlIDE6Zm9yKGE9MCxvPU1hdGgucG93KDIsMTYpLFQ9MTtUIT1vOylpPUMudmFsJkMucG9zaXRpb24sQy5wb3NpdGlvbj4+PTEsQy5wb3NpdGlvbj09MCYmKEMucG9zaXRpb249dSxDLnZhbD1NKEMuaW5kZXgrKykpLGF8PShpPjA/MTowKSpULFQ8PD0xO2ZbeCsrXT10KGEpLEE9eC0xLHYtLTticmVhaztjYXNlIDI6cmV0dXJuIGcuam9pbigiIil9aWYodj09MCYmKHY9TWF0aC5wb3coMixSKSxSKyspLGZbQV0pTz1mW0FdO2Vsc2UgaWYoQT09PXgpTz1uK24uY2hhckF0KDApO2Vsc2UgcmV0dXJuIG51bGw7Zy5wdXNoKE8pLGZbeCsrXT1uK08uY2hhckF0KDApLHYtLSxuPU8sdj09MCYmKHY9TWF0aC5wb3coMixSKSxSKyspfX19O3JldHVybiBjfSgpO2ghPW51bGw/aC5leHBvcnRzPWU6dHlwZW9mIGFuZ3VsYXI8InUiJiZhbmd1bGFyIT1udWxsJiZhbmd1bGFyLm1vZHVsZSgiTFpTdHJpbmciLFtdKS5mYWN0b3J5KCJMWlN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gZX0pfShSZSk7dmFyIG5yPVJlLmV4cG9ydHM7ZnVuY3Rpb24gaXIoaCl7cmV0dXJuIEpTT04ucGFyc2UobnIuZGVjb21wcmVzcyhoKSl9ZnVuY3Rpb24gbG4oaCl7cmV0dXJuIG5yLmNvbXByZXNzKEpTT04uc3RyaW5naWZ5KGgpKX1jbGFzcyBVdCBleHRlbmRzIGNle2NvbnN0cnVjdG9yKGUsdCxyKXtzdXBlcih0LHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpEdC5QZW5jaWx9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIk1BWF9SRVBFQVIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ1bmlUaGlja25lc3MiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2VudGVyUG9zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6WzAsMF19KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy51bmlUaGlja25lc3M9dGhpcy5NQVhfUkVQRUFSL2UudGhpY2tuZXNzLzEwLHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7dmFyIG07Y29uc3QgZT0obT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOm0udG9TdHJpbmcoKSx0PXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCkscj17bmFtZTplLGNsYXNzTmFtZToicGVuY2lsIn07bGV0IHM7cmV0dXJuIHQubGVuZ3RoJiYocz10aGlzLmRyYXcoe2F0dHJzOnIsdGFza3M6dCxyZXBsYWNlSWQ6ZSxpc0Z1bGxXb3JrOiExLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOiEwfSkpLHtyZWN0OnMsdHlwZTpFdC5EcmF3V29yayxkYXRhVHlwZTpDdC5Mb2NhbH19c2V0V29ya09wdGlvbnMoZSl7c3VwZXIuc2V0V29ya09wdGlvbnMoZSksdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlKXt2YXIgTztjb25zdHtkYXRhOnQsaXNGdWxsV29yazpyLGlzQ2xlYXJBbGw6cyxpc1N1YldvcmtlcjptfT1lO2lmKCgoTz10Lm9wKT09bnVsbD92b2lkIDA6Ty5sZW5ndGgpPT09MClyZXR1cm57dHlwZTpFdC5Ob25lfTtjb25zdHt3b3JrSWQ6eX09dCx7dGFza3M6YyxlZmZlY3RzOmwsY29uc3VtZUluZGV4OnV9PXRoaXMudHJhbnNmb3JtRGF0YSh0LCExKTt0aGlzLnN5bmNJbmRleD1NYXRoLm1pbih0aGlzLnN5bmNJbmRleCx1KTtjb25zdCBNPXtuYW1lOnk9PW51bGw/dm9pZCAwOnkudG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCBmLHY9ITE7Y29uc3QgeD10aGlzLnN5bmNJbmRleDtpZih0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpLGMubGVuZ3RoJiYoY1swXS50YXNrSWQtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYodj0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9Y1swXS50YXNrSWQsdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSxmPXRoaXMuZHJhdyh7YXR0cnM6TSx0YXNrczpjLGVmZmVjdHM6bCxpc0Z1bGxXb3JrOnIsaXNDbGVhckFsbDpzfSkpLG0pcmV0dXJuIHU+MTAmJnRoaXMudG1wUG9pbnRzLnNwbGljZSgwLHUtMTApLHtyZWN0OmYsdHlwZTpFdC5EcmF3V29yayxkYXRhVHlwZTpDdC5Mb2NhbH07Y29uc3QgUj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UoeCkuZm9yRWFjaChnPT57Ui5wdXNoKGcueCxnLnksdGhpcy5jb21wdXRSYWRpdXMoZy56LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKSl9KSx7cmVjdDpmLHR5cGU6RXQuRHJhd1dvcmssZGF0YVR5cGU6Q3QuTG9jYWwsd29ya0lkOnY/eTp2b2lkIDAsb3A6dj9SOnZvaWQgMCxpbmRleDp2P3gqMzp2b2lkIDB9fWNvbnN1bWVBbGwoZSl7dmFyIGMsbDtpZihlLmRhdGEpe2NvbnN0e29wOnUsd29ya1N0YXRlOk19PWUuZGF0YTt1IT1udWxsJiZ1Lmxlbmd0aCYmTT09PVF0LkRvbmUmJnRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PWJ0LlN0cm9rZSYmdGhpcy51cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlV2hlbkRvbmUodSl9Y29uc3QgdD0oYz10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmMudG9TdHJpbmcoKSxyPXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMCkscz17bmFtZTp0LGNsYXNzTmFtZToicGVuY2lsIn07bGV0IG07ci5sZW5ndGgmJihtPXRoaXMuZHJhdyh7YXR0cnM6cyx0YXNrczpyLHJlcGxhY2VJZDp0LGlzRnVsbFdvcms6ITAsbm9ybWFsaXplOiEwLGlzQ2xlYXJBbGw6ITF9KSk7Y29uc3QgeT1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMubWFwKHU9Pnt5LnB1c2godS54LHUueSx0aGlzLmNvbXB1dFJhZGl1cyh1LnosdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3MpKX0pLHRoaXMuc3luY1RpbWVzdGFtcD0wLHtyZWN0Om0sdHlwZTpFdC5GdWxsV29yayxkYXRhVHlwZTpDdC5Mb2NhbCx3b3JrSWQ6dCxvcHM6bG4oeSksdXBkYXRlTm9kZU9wdDp7cG9zOnRoaXMuY2VudGVyUG9zLHVzZUFuaW1hdGlvbjohMH0sdW5kb1RpY2tlcklkOihsPWUuZGF0YSk9PW51bGw/dm9pZCAwOmwudW5kb1RpY2tlcklkfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIE07Y29uc3R7b3A6dCxpc0Z1bGxXb3JrOnIscmVwbGFjZUlkOnMsaXNDbGVhckFsbDptfT1lO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgZj0wO2Y8dC5sZW5ndGg7Zis9Myl7Y29uc3Qgdj1uZXcgQXQodFtmXSx0W2YrMV0sdFtmKzJdKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg+MCl7Y29uc3QgeD10aGlzLnRtcFBvaW50c1t0aGlzLnRtcFBvaW50cy5sZW5ndGgtMV0sUj1odC5TdWIodix4KS51bmkoKTt2LnNldHYoUil9dGhpcy50bXBQb2ludHMucHVzaCh2KX1jb25zdCB5PXRoaXMudHJhbnNmb3JtRGF0YUFsbCghMSksbD17bmFtZTooTT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOk0udG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCB1O3JldHVybiB5Lmxlbmd0aCYmKHU9dGhpcy5kcmF3KHthdHRyczpsLHRhc2tzOnkscmVwbGFjZUlkOnMsaXNGdWxsV29yazpyLG5vcm1hbGl6ZTohMCxpc0NsZWFyQWxsOm19KSksdX10cmFuc2Zvcm1EYXRhQWxsKGU9ITApe3JldHVybiB0aGlzLmdldFRhc2tQb2ludHModGhpcy50bXBQb2ludHMsZSYmdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3N8fHZvaWQgMCl9ZHJhdyhlKXt2YXIgbztjb25zdHthdHRyczp0LHRhc2tzOnIscmVwbGFjZUlkOnMsZWZmZWN0czptLGlzRnVsbFdvcms6eSxub3JtYWxpemU6Yyxpc0NsZWFyQWxsOmx9PWUsdT15P3RoaXMuZnVsbExheWVyOnRoaXMuZHJhd0xheWVyfHx0aGlzLmZ1bGxMYXllcix7Y29sb3I6TSxzdHJva2VUeXBlOmYsdGhpY2tuZXNzOnYsb3BhY2l0eTp4LHpJbmRleDpSLHNjYWxlOk8scm90YXRlOmd9PXRoaXMud29ya09wdGlvbnM7bD91LnJlbW92ZUFsbENoaWxkcmVuKCk6KHMmJih1LmdldEVsZW1lbnRzQnlOYW1lKHMrIiIpLm1hcChUPT5ULnJlbW92ZSgpKSwobz10aGlzLmRyYXdMYXllcik9PW51bGx8fG8uZ2V0RWxlbWVudHNCeU5hbWUocysiIikubWFwKFQ9PlQucmVtb3ZlKCkpKSxtIT1udWxsJiZtLnNpemUmJihtLmZvckVhY2goVD0+e3ZhciBBOyhBPXUuZ2V0RWxlbWVudEJ5SWQoVCsiIikpPT1udWxsfHxBLnJlbW92ZSgpfSksbS5jbGVhcigpKSk7bGV0IHA7Y29uc3Qgbj1bXSxhPXUud29ybGRQb3NpdGlvbixpPXUud29ybGRTY2FsaW5nO2ZvcihsZXQgVD0wO1Q8ci5sZW5ndGg7VCsrKXtjb25zdHtwb3M6QSxwb2ludHM6Qyx0YXNrSWQ6SX09cltUXTt0LmlkPUkudG9TdHJpbmcoKTtjb25zdHtwczpQLHJlY3Q6TH09dGhpcy5jb21wdXREcmF3UG9pbnRzKEMpO2xldCBEO2NvbnN0IGI9Qy5sZW5ndGg9PT0xO2Y9PT1idC5TdHJva2V8fGI/RD1kZShQLCEwKTpEPWRlKFAsITEpO2NvbnN0IFM9e3BvczpBLGQ6RCxmaWxsQ29sb3I6Zj09PWJ0LlN0cm9rZXx8Yj9NOnZvaWQgMCxsaW5lRGFzaDpmPT09YnQuRG90dGVkJiYhYj9bMSx2KjJdOmY9PT1idC5Mb25nRG90dGVkJiYhYj9bdix2KjJdOnZvaWQgMCxzdHJva2VDb2xvcjpNLG9wYWNpdHk6eCxsaW5lQ2FwOmY9PT1idC5TdHJva2V8fGI/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmY9PT1idC5TdHJva2V8fGI/MDp2LGNsYXNzTmFtZTpgJHtBWzBdfSwke0FbMV19LCR7Zn1gfTtpZihyLmxlbmd0aD09PTEmJmMpe2NvbnN0IEI9W0wueCtMLncvMixMLnkrTC5oLzJdO2lmKHRoaXMuY2VudGVyUG9zPVtCWzBdK0FbMF0sQlsxXStBWzFdXSxTLm5vcm1hbGl6ZT0hMCxTLnBvcz10aGlzLmNlbnRlclBvcyxTLmNsYXNzTmFtZT1gJHt0aGlzLmNlbnRlclBvc1swXX0sJHt0aGlzLmNlbnRlclBvc1sxXX0sJHtmfWAsUy5pZD10Lm5hbWUsUy56SW5kZXg9UixPKXtTLnNjYWxlPU87Y29uc3Qgdz1vbih7eDpNYXRoLmZsb29yKEwueCtBWzBdK2FbMF0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEwueStBWzFdK2FbMV0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwudysyKlV0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmgrMipVdC5QZW5jaWxCb3JkZXJQYWRkaW5nKX0sTyk7cD1MdChwLHcpfWlmKGcpe1Mucm90YXRlPWc7Y29uc3Qgdz1hbih7eDpNYXRoLmZsb29yKEwueCtBWzBdK2FbMF0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKEwueStBWzFdK2FbMV0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwudysyKlV0LlBlbmNpbEJvcmRlclBhZGRpbmcpLGg6TWF0aC5mbG9vcihMLmgrMipVdC5QZW5jaWxCb3JkZXJQYWRkaW5nKX0sZyk7cD1MdChwLHcpfX1wPUx0KHAse3g6TWF0aC5mbG9vcigoTC54K0FbMF0pKmlbMF0rYVswXS1VdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx5Ok1hdGguZmxvb3IoKEwueStBWzFdKSppWzFdK2FbMV0tVXQuUGVuY2lsQm9yZGVyUGFkZGluZyksdzpNYXRoLmZsb29yKEwudyppWzBdKzIqVXQuUGVuY2lsQm9yZGVyUGFkZGluZyksaDpNYXRoLmZsb29yKEwuaCppWzFdKzIqVXQuUGVuY2lsQm9yZGVyUGFkZGluZyl9KSxuLnB1c2goUyl9aWYoYyYmbi5sZW5ndGg+MSYmcCl7Y29uc3QgVD1uZXcgU2U7dGhpcy5jZW50ZXJQb3M9WyhwLngrcC53LzItYVswXSkvaVswXSwocC55K3AuaC8yLWFbMV0pL2lbMV1dLFQuYXR0cih7Li4udCxpZDp0Lm5hbWUsYW5jaG9yOlsuNSwuNV0sYmdjb2xvcjpmPT09YnQuU3Ryb2tlP006dm9pZCAwLHNjYWxlOk8sb3BhY2l0eTp4LHBvczp0aGlzLmNlbnRlclBvcyxyb3RhdGU6ZyxjbGFzc05hbWU6YCR7dGhpcy5jZW50ZXJQb3NbMF19LCR7dGhpcy5jZW50ZXJQb3NbMV19LCR7Zn1gLHNpemU6W3AudyxwLmhdLHpJbmRleDpSfSksbi5mb3JFYWNoKEE9PntBLnBvcz1bQS5wb3NbMF0tdGhpcy5jZW50ZXJQb3NbMF0sQS5wb3NbMV0tdGhpcy5jZW50ZXJQb3NbMV1dLEEub3BhY2l0eT0xO2NvbnN0IEM9bmV3IGJlKEEpO1QuYXBwZW5kQ2hpbGQoQyl9KSxmPT09YnQuU3Ryb2tlJiZULnNlYWwoKSx1LmFwcGVuZChUKX1lbHNle2NvbnN0IFQ9bi5tYXAoQT0+bmV3IGJlKHsuLi50LC4uLkF9KSk7dS5hcHBlbmQoLi4uVCl9cmV0dXJuIHB9Y29tcHV0RHJhd1BvaW50cyhlKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09YnQuU3Ryb2tlfHxlLmxlbmd0aD09PTE/dGhpcy5jb21wdXRTdHJva2UoZSk6dGhpcy5jb21wdXROb21hbChlKX1jb21wdXROb21hbChlKXtsZXQgdD10aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcztjb25zdCByPWUubWFwKHM9Pih0PU1hdGgubWF4KHQscy5yYWRpdXMpLHMucG9pbnQpKTtyZXR1cm57cHM6cixyZWN0Okh0KHIsdCl9fWNvbXB1dFN0cm9rZShlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0RG90U3Ryb2tlKGVbMF0pOnRoaXMuY29tcHV0TGluZVN0cm9rZShlKX1jb21wdXRMaW5lU3Ryb2tlKGUpe2NvbnN0IHQ9W10scj1bXTtmb3IobGV0IGw9MDtsPGUubGVuZ3RoO2wrKyl7Y29uc3R7cG9pbnQ6dSxyYWRpdXM6TX09ZVtsXTtsZXQgZj11LnY7bD09PTAmJmUubGVuZ3RoPjEmJihmPWVbbCsxXS5wb2ludC52KTtjb25zdCB2PWh0LlBlcihmKS5tdWwoTSk7dC5wdXNoKEF0LlN1Yih1LHYpKSxyLnB1c2goQXQuQWRkKHUsdikpfWNvbnN0IHM9ZVtlLmxlbmd0aC0xXSxtPUF0LkdldFNlbWljaXJjbGVTdHJva2Uocy5wb2ludCx0W3QubGVuZ3RoLTFdLC0xLDgpLHk9QXQuR2V0U2VtaWNpcmNsZVN0cm9rZShlWzBdLnBvaW50LHJbMF0sLTEsOCksYz10LmNvbmNhdChtLHIucmV2ZXJzZSgpLHkpO3JldHVybntwczpjLHJlY3Q6SHQoYyl9fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czpyfT1lLHM9e3g6dC54LXIseTp0Lnktcix3OnIqMixoOnIqMn07cmV0dXJue3BzOkF0LkdldERvdFN0cm9rZSh0LHIsOCkscmVjdDpzfX10cmFuc2Zvcm1EYXRhKGUsdCl7Y29uc3R7b3A6cix3b3JrU3RhdGU6c309ZTtsZXQgbT10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSx5PVtdO2lmKHIhPW51bGwmJnIubGVuZ3RoJiZzKXtjb25zdHtzdHJva2VUeXBlOmMsdGhpY2tuZXNzOmx9PXRoaXMud29ya09wdGlvbnMsdT1uZXcgU2V0O209Yz09PWJ0LlN0cm9rZT90aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUocixsLHUpOnRoaXMudXBkYXRlVGVtcFBvaW50cyhyLGwsdSk7Y29uc3QgTT10P3RoaXMudG1wUG9pbnRzOnRoaXMudG1wUG9pbnRzLnNsaWNlKG0pO3JldHVybiB5PXRoaXMuZ2V0VGFza1BvaW50cyhNLGwpLHt0YXNrczp5LGVmZmVjdHM6dSxjb25zdW1lSW5kZXg6bX19cmV0dXJue3Rhc2tzOnksY29uc3VtZUluZGV4Om19fWNvbXB1dFJhZGl1cyhlLHQpe3JldHVybiBlKi4wMyp0K3QqLjV9Z2V0TWluWihlLHQpe3JldHVybigodHx8TWF0aC5tYXgoMSxNYXRoLmZsb29yKGUqLjMpKSktZSouNSkqMTAwL2UvM31nZXRUYXNrUG9pbnRzKGUsdCl7dmFyIE07Y29uc3Qgcj1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IHM9MCxtPWVbMF0ueCx5PWVbMF0ueSxjPVttLHldLGw9W10sdT1lWzBdLnQ7Zm9yKDtzPGUubGVuZ3RoOyl7Y29uc3QgZj1lW3NdLHY9Zi54LW0seD1mLnkteSxSPWYueixPPXQ/dGhpcy5jb21wdXRSYWRpdXMoUix0KTpSO2lmKGwucHVzaCh7cG9pbnQ6bmV3IEF0KHYseCxSLGVbc10udikscmFkaXVzOk99KSxzPjAmJnM8ZS5sZW5ndGgtMSl7Y29uc3QgZz1lW3NdLmdldEFuZ2xlQnlQb2ludHMoZVtzLTFdLGVbcysxXSk7aWYoZzw5MHx8Zz4yNzApe2NvbnN0IHA9KE09bC5wb3AoKSk9PW51bGw/dm9pZCAwOk0ucG9pbnQuY2xvbmUoKTtwJiZyLnB1c2goe3Rhc2tJZDp1LHBvczpjLHBvaW50czpbLi4ubCx7cG9pbnQ6cCxyYWRpdXM6T31dfSksbT1lW3NdLngseT1lW3NdLnksYz1bbSx5XTtjb25zdCBuPWYueC1tLGE9Zi55LXk7bD1be3BvaW50Om5ldyBBdChuLGEsUikscmFkaXVzOk99XSx1PURhdGUubm93KCl9fXMrK31yZXR1cm4gci5wdXNoKHt0YXNrSWQ6dSxwb3M6Yyxwb2ludHM6bH0pLHJ9dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShlLHQscil7Y29uc3Qgcz1EYXRlLm5vdygpLG09dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCB5PW07Zm9yKGxldCBsPTA7bDxlLmxlbmd0aDtsKz0yKXt5PU1hdGgubWluKHksbSk7Y29uc3QgdT10aGlzLnRtcFBvaW50cy5sZW5ndGgsTT1uZXcgQXQoZVtsXSxlW2wrMV0pO2lmKHU9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKE0pO2NvbnRpbnVlfWNvbnN0IGY9dS0xLHY9dGhpcy50bXBQb2ludHNbZl0seD1odC5TdWIoTSx2KS51bmkoKTtpZihNLmlzTmVhcih2LHQpKXtpZih2Lno8dGhpcy5NQVhfUkVQRUFSKXtpZih2LnNldHooTWF0aC5taW4odi56KzEsdGhpcy5NQVhfUkVQRUFSKSkseT1NYXRoLm1pbih5LGYpLHU+MSl7bGV0IGc9dS0xO2Zvcig7Zz4wOyl7Y29uc3QgcD10aGlzLnRtcFBvaW50c1tnXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1tnLTFdKSxuPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW2ddLnotdGhpcy51bmlUaGlja25lc3MqcCwwKTtpZih0aGlzLnRtcFBvaW50c1tnLTFdLno+PW4pYnJlYWs7dGhpcy50bXBQb2ludHNbZy0xXS5zZXR6KG4pLHk9TWF0aC5taW4oeSxnLTEpLGctLX19fWVsc2UgeT0xLzA7Y29udGludWV9TS5zZXR2KHgpO2NvbnN0IFI9TS5kaXN0YW5jZSh2KSxPPU1hdGgubWF4KHYuei10aGlzLnVuaVRoaWNrbmVzcypSLDApO3U+MSYmaHQuRXF1YWxzKHgsdi52LC4wMikmJihPPjB8fHYuejw9MCkmJihyJiZ2LnQmJnIuYWRkKHYudCksdGhpcy50bXBQb2ludHMucG9wKCkseT1NYXRoLm1pbihmLHkpKSxNLnNldHooTyksdGhpcy50bXBQb2ludHMucHVzaChNKX1pZih5PT09MS8wKXJldHVybiB0aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGM9bTtpZih5PT09bSl7Yz1NYXRoLm1heChjLTEsMCk7Y29uc3QgbD10aGlzLnRtcFBvaW50c1tjXS50O2wmJihyPT1udWxsfHxyLmFkZChsKSl9ZWxzZXtsZXQgbD1tLTE7Zm9yKGM9eTtsPj0wOyl7Y29uc3QgdT10aGlzLnRtcFBvaW50c1tsXS50O2lmKHUmJihyPT1udWxsfHxyLmFkZCh1KSxsPD15KSl7Yz1sLGw9LTE7YnJlYWt9bC0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbY10uc2V0VChzKSxjfXVwZGF0ZVRlbXBQb2ludHMoZSx0LHIpe3ZhciBsO2NvbnN0IHM9RGF0ZS5ub3coKSxtPXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgeT1tO2ZvcihsZXQgdT0wO3U8ZS5sZW5ndGg7dSs9Mil7Y29uc3QgTT10aGlzLnRtcFBvaW50cy5sZW5ndGgsZj1uZXcgQXQoZVt1XSxlW3UrMV0pO2lmKE09PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKGYpO2NvbnRpbnVlfWNvbnN0IHY9TS0xLHg9dGhpcy50bXBQb2ludHNbdl0sUj1odC5TdWIoZix4KS51bmkoKTtpZihodC5FcXVhbHMoUix4LnYsLjAyKSl7ciYmeC50JiZyLmFkZCh4LnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLHk9TWF0aC5taW4odix5KTtjb250aW51ZX1pZihmLmlzTmVhcih4LHQvMikpe3k9TWF0aC5taW4odix5KTtjb250aW51ZX1mLnNldHYoUiksdGhpcy50bXBQb2ludHMucHVzaChmKX1sZXQgYz1tO2lmKHk9PT1tKXtjPU1hdGgubWF4KGMtMSwwKTtjb25zdCB1PXRoaXMudG1wUG9pbnRzW2NdLnQ7dSYmKHI9PW51bGx8fHIuYWRkKHUpKX1lbHNle2xldCB1PU1hdGgubWluKG0tMSx5KTtmb3IoYz15O3U+PTA7KXtjb25zdCBNPShsPXRoaXMudG1wUG9pbnRzW3VdKT09bnVsbD92b2lkIDA6bC50O2lmKE0mJihyPT1udWxsfHxyLmFkZChNKSx1PD15KSl7Yz11LHU9LTE7YnJlYWt9dS0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbY10uc2V0VChzKSxjfXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucyxyPWUubGVuZ3RoLHM9dGhpcy5nZXRNaW5aKHQpO2ZvcihsZXQgbT0wO208cjttKz0yKXtjb25zdCB5PXRoaXMudG1wUG9pbnRzLmxlbmd0aCxjPW5ldyBBdChlW21dLGVbbSsxXSk7aWYoeT09PTApe3RoaXMudG1wUG9pbnRzLnB1c2goYyk7Y29udGludWV9Y29uc3QgbD15LTEsdT10aGlzLnRtcFBvaW50c1tsXSxNPWh0LlN1YihjLHUpLnVuaSgpLGY9Yy5kaXN0YW5jZSh1KTtpZih5PjEmJnUuej09PXMpYnJlYWs7aWYoYy5pc05lYXIodSx0LzIpKXtpZihyPDMmJnUuejx0aGlzLk1BWF9SRVBFQVImJih1LnNldHooTWF0aC5taW4odS56KzEsdGhpcy5NQVhfUkVQRUFSKSkseT4xKSl7bGV0IHg9eS0xO2Zvcig7eD4wOyl7Y29uc3QgUj10aGlzLnRtcFBvaW50c1t4XS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1t4LTFdKSxPPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW3hdLnotdGhpcy51bmlUaGlja25lc3MqUiwtdC80KTtpZih0aGlzLnRtcFBvaW50c1t4LTFdLno+PU8pYnJlYWs7dGhpcy50bXBQb2ludHNbeC0xXS5zZXR6KE8pLHgtLX19Y29udGludWV9Yy5zZXR2KE0pO2NvbnN0IHY9TWF0aC5tYXgodS56LXRoaXMudW5pVGhpY2tuZXNzKmYscyk7eT4xJiZodC5FcXVhbHMoTSx1LnYsLjAyKSYmdS56PD0wJiZ0aGlzLnRtcFBvaW50cy5wb3AoKSxjLnNldHoodiksdGhpcy50bXBQb2ludHMucHVzaChjKX19dXBkYXRhT3B0U2VydmljZShlKXt2YXIgcztsZXQgdDtjb25zdCByPShzPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6cy50b1N0cmluZygpO2lmKHImJmUpe2NvbnN0IG09dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUocikse3Bvczp5LHpJbmRleDpjLGNvbG9yOmwsc2NhbGU6dSxhbmdsZTpNLG9wYWNpdHk6Zn09ZSx2PXt9O2lmKHR5cGVvZiBjPT0ibnVtYmVyIiYmKHYuekluZGV4PWMpLHkmJih2LnBvcz1beVswXSx5WzFdXSxtWzBdKSl7Y29uc3QgeD1tWzBdLmNsYXNzTmFtZS5zcGxpdCgiLCIpO3YuY2xhc3NOYW1lPWAke3lbMF19LCR7eVsxXX0sJHt4WzJdfWB9cmV0dXJuIGwmJih2LnN0cm9rZUNvbG9yPWwpLHUmJih2LnNjYWxlPXUpLGYmJih2Lm9wYWNpdHk9ZiksTSYmKHYucm90YXRlPU0pLE9iamVjdC5rZXlzKHYpLmxlbmd0aCYmbS5mb3JFYWNoKHg9Pntjb25zdCBSPXguYXR0cigiZmlsbENvbG9yIik7bCYmUj94LmF0dHIoey4uLnYsZmlsbENvbG9yOmx9KTp4LmF0dHIodik7Y29uc3QgTz14PT1udWxsP3ZvaWQgMDp4LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO08mJih0PUx0KHQse3g6TWF0aC5mbG9vcihPLngtVXQuUGVuY2lsQm9yZGVyUGFkZGluZykseTpNYXRoLmZsb29yKE8ueS1VdC5QZW5jaWxCb3JkZXJQYWRkaW5nKSx3Ok1hdGguZmxvb3IoTy53aWR0aCtVdC5QZW5jaWxCb3JkZXJQYWRkaW5nKjIpLGg6TWF0aC5mbG9vcihPLmhlaWdodCtVdC5QZW5jaWxCb3JkZXJQYWRkaW5nKjIpfSkpfSksdH19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShVdCwiUGVuY2lsQm9yZGVyUGFkZGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSk7dmFyIGZuPW1lO21lLnBvbHlsaW5lPW1lLG1lLnBvbHlnb249dW47ZnVuY3Rpb24gbWUoaCxlLHQpe3ZhciByPWgubGVuZ3RoLHM9X3QoaFswXSxlKSxtPVtdLHksYyxsLHUsTTtmb3IodHx8KHQ9W10pLHk9MTt5PHI7eSsrKXtmb3IoYz1oW3ktMV0sbD1oW3ldLHU9TT1fdChsLGUpOzspaWYoc3x1KXtpZihzJnUpYnJlYWs7cz8oYz1DZShjLGwscyxlKSxzPV90KGMsZSkpOihsPUNlKGMsbCx1LGUpLHU9X3QobCxlKSl9ZWxzZXttLnB1c2goYyksdSE9PU0/KG0ucHVzaChsKSx5PHItMSYmKHQucHVzaChtKSxtPVtdKSk6eT09PXItMSYmbS5wdXNoKGwpO2JyZWFrfXM9TX1yZXR1cm4gbS5sZW5ndGgmJnQucHVzaChtKSx0fWZ1bmN0aW9uIHVuKGgsZSl7dmFyIHQscixzLG0seSxjLGw7Zm9yKHI9MTtyPD04O3IqPTIpe2Zvcih0PVtdLHM9aFtoLmxlbmd0aC0xXSxtPSEoX3QocyxlKSZyKSx5PTA7eTxoLmxlbmd0aDt5KyspYz1oW3ldLGw9IShfdChjLGUpJnIpLGwhPT1tJiZ0LnB1c2goQ2UocyxjLHIsZSkpLGwmJnQucHVzaChjKSxzPWMsbT1sO2lmKGg9dCwhaC5sZW5ndGgpYnJlYWt9cmV0dXJuIHR9ZnVuY3Rpb24gQ2UoaCxlLHQscil7cmV0dXJuIHQmOD9baFswXSsoZVswXS1oWzBdKSooclszXS1oWzFdKS8oZVsxXS1oWzFdKSxyWzNdXTp0JjQ/W2hbMF0rKGVbMF0taFswXSkqKHJbMV0taFsxXSkvKGVbMV0taFsxXSksclsxXV06dCYyP1tyWzJdLGhbMV0rKGVbMV0taFsxXSkqKHJbMl0taFswXSkvKGVbMF0taFswXSldOnQmMT9bclswXSxoWzFdKyhlWzFdLWhbMV0pKihyWzBdLWhbMF0pLyhlWzBdLWhbMF0pXTpudWxsfWZ1bmN0aW9uIF90KGgsZSl7dmFyIHQ9MDtyZXR1cm4gaFswXTxlWzBdP3R8PTE6aFswXT5lWzJdJiYodHw9MiksaFsxXTxlWzFdP3R8PTQ6aFsxXT5lWzNdJiYodHw9OCksdH12YXIgY249cnIoZm4pO2NsYXNzIHp0IGV4dGVuZHMgY2V7dXBkYXRhT3B0U2VydmljZSgpe31jb25zdHJ1Y3RvcihlLHQpe3N1cGVyKHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkR0LkVyYXNlcn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JsZFBvc2l0aW9uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmxkU2NhbGluZyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlcmFzZXJSZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVyYXNlclBvbHlsaW5lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImN1ck5vZGVNYXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgTWFwfSksdGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMud29ybGRQb3NpdGlvbj10aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uLHRoaXMud29ybGRTY2FsaW5nPXRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ31jb21wdXROb2RlTWFwKGUpe3RoaXMuY3VyTm9kZU1hcC5jbGVhcigpLGUuZm9yRWFjaCh0PT57Y29uc3Qgcj10aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh0Lm5hbWUpWzBdLHM9dC5vcHMmJmlyKHQub3BzKTtpZihyJiZzLmxlbmd0aCl7Y29uc3QgbT1bXTtmb3IobGV0IGM9MDtjPHMubGVuZ3RoO2MrPTMpe2NvbnN0IGw9bmV3IGh0KHNbY10qdGhpcy53b3JsZFNjYWxpbmdbMF0rdGhpcy53b3JsZFBvc2l0aW9uWzBdLHNbYysxXSp0aGlzLndvcmxkU2NhbGluZ1sxXSt0aGlzLndvcmxkUG9zaXRpb25bMV0sc1tjKzJdKTttLnB1c2gobCl9bGV0IHk9dC5vcHQ7aWYoIXkpe2xldCBjPXIuZ2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIpO2NvbnN0IGw9ci5jbGFzc05hbWUuc3BsaXQoIiwiKSx1PU51bWJlcihsWzJdKTtyLnRhZ05hbWU9PT0iR1JPVVAiJiYodT09PWJ0LlN0cm9rZT9jPXIuZ2V0QXR0cmlidXRlKCJiZ2NvbG9yIik6Yz1yLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiKSk7Y29uc3QgTT1yLmdldEF0dHJpYnV0ZSgib3BhY2l0eSIpLGY9ci5nZXRBdHRyaWJ1dGUoInNjYWxlIiksdj1yLmdldEF0dHJpYnV0ZSgiekluZGV4IikseD1yLmdldEF0dHJpYnV0ZSgicm90YXRlIiksUj10aGlzLndvcmtPcHRpb25zLnN5bmNVbml0VGltZTt5PXtjb2xvcjpjLG9wYWNpdHk6TSxzeW5jVW5pdFRpbWU6Uix6SW5kZXg6dixzY2FsZTpmLHJvdGF0ZTp4LHN0cm9rZVR5cGU6dX19dGhpcy5jdXJOb2RlTWFwLnNldCh0Lm5hbWUse25hbWU6dC5uYW1lLHJlY3Q6dC5yZWN0LHBvbHlsaW5lOm0sb3B0OnksdG9vbHNUeXBlOnQudG9vbHNUeXBlfHxEdC5QZW5jaWx9KX19KX11cGRhdGFOb2RlTWFwKGUsdCl7Y29uc3Qgcj10Lm9wLHM9W107Zm9yKGxldCBtPTA7bTxyLmxlbmd0aDttKz0zKXtjb25zdCB5PW5ldyBodChyW21dKnRoaXMud29ybGRTY2FsaW5nWzBdK3RoaXMud29ybGRQb3NpdGlvblswXSxyW20rMV0qdGhpcy53b3JsZFNjYWxpbmdbMV0rdGhpcy53b3JsZFBvc2l0aW9uWzFdLHJbbSsyXSk7cy5wdXNoKHkpfXRoaXMuY3VyTm9kZU1hcC5zZXQoZSx7bmFtZTp0Lm5hbWUscmVjdDp0LnJlY3QscG9seWxpbmU6cyxvcHQ6dC5vcHQsdG9vbHNUeXBlOnQudG9vbHNUeXBlfHxEdC5QZW5jaWx9KX1jb21iaW5lQ29uc3VtZSgpe31jcmVhdGVFcmFzZXJSZWN0KGUpe2NvbnN0IHQ9ZVswXSp0aGlzLndvcmxkU2NhbGluZ1swXSt0aGlzLndvcmxkUG9zaXRpb25bMF0scj1lWzFdKnRoaXMud29ybGRTY2FsaW5nWzFdK3RoaXMud29ybGRQb3NpdGlvblsxXSx7d2lkdGg6cyxoZWlnaHQ6bX09enQuZXJhc2VyU2l6ZXNbdGhpcy53b3JrT3B0aW9ucy50aGlja25lc3NdO3RoaXMuZXJhc2VyUmVjdD17eDp0LXMqLjUseTpyLW0qLjUsdzpzLGg6bX0sdGhpcy5lcmFzZXJQb2x5bGluZT1bdGhpcy5lcmFzZXJSZWN0LngsdGhpcy5lcmFzZXJSZWN0LnksdGhpcy5lcmFzZXJSZWN0LngrdGhpcy5lcmFzZXJSZWN0LncsdGhpcy5lcmFzZXJSZWN0LnkrdGhpcy5lcmFzZXJSZWN0LmhdfWNvbnN1bWVTZXJ2aWNlKCl7fXNldFdvcmtPcHRpb25zKGUpe3N1cGVyLnNldFdvcmtPcHRpb25zKGUpLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKXtjb25zdCBlPXRoaXMudG1wUG9pbnRzLnNsaWNlKC0yKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg9PT00KXtjb25zdCB0PW5ldyBodCh0aGlzLnRtcFBvaW50c1swXSx0aGlzLnRtcFBvaW50c1sxXSkscj1uZXcgaHQodGhpcy50bXBQb2ludHNbMl0sdGhpcy50bXBQb2ludHNbM10pLHM9aHQuU3ViKHIsdCkudW5pKCksbT1odC5EaXN0KHQscikse3dpZHRoOnksaGVpZ2h0OmN9PXp0LmVyYXNlclNpemVzW3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzXSxsPU1hdGgubWluKHksYyksdT1NYXRoLnJvdW5kKG0vbCk7aWYodT4xKXtjb25zdCBNPVtdO2ZvcihsZXQgZj0wO2Y8dTtmKyspe2NvbnN0IHY9aHQuTXVsKHMsZipsKTtNLnB1c2godGhpcy50bXBQb2ludHNbMF0rdi54LHRoaXMudG1wUG9pbnRzWzFdK3YueSl9cmV0dXJuIE0uY29uY2F0KGUpfX1yZXR1cm4gZX1pc05lYXIoZSx0KXtjb25zdCByPW5ldyBodChlWzBdLGVbMV0pLHM9bmV3IGh0KHRbMF0sdFsxXSkse3dpZHRoOm0saGVpZ2h0Onl9PXp0LmVyYXNlclNpemVzW3RoaXMud29ya09wdGlvbnMudGhpY2tuZXNzXTtyZXR1cm4gaHQuRGlzdChyLHMpPE1hdGguaHlwb3QobSx5KSouNX1jb25zdW1lKGUpe2NvbnN0e29wOnQsd29ya1N0YXRlOnJ9PWUuZGF0YTtpZighdHx8dC5sZW5ndGg9PT0wKXJldHVybnt0eXBlOkV0Lk5vbmV9O3I9PT1RdC5TdGFydCYmZS5ub2RlTWFwcyYmdGhpcy5jb21wdXROb2RlTWFwKGUubm9kZU1hcHMpO2NvbnN0IHM9dGhpcy50bXBQb2ludHMubGVuZ3RoO2lmKHM+MSYmdGhpcy5pc05lYXIoW3RbMF0sdFsxXV0sW3RoaXMudG1wUG9pbnRzW3MtMl0sdGhpcy50bXBQb2ludHNbcy0xXV0pKXJldHVybnt0eXBlOkV0Lk5vbmV9O2lmKGUubm9kZU1hcHMpe3M9PT00JiYodGhpcy50bXBQb2ludHMuc2hpZnQoKSx0aGlzLnRtcFBvaW50cy5zaGlmdCgpKSx0aGlzLnRtcFBvaW50cy5wdXNoKHRbMF0sdFsxXSk7Y29uc3QgbT10aGlzLmNvbXB1dFJlY3RDZW50ZXJQb2ludHMoKTtsZXQgeTtjb25zdCBjPW5ldyBTZXQsbD1uZXcgTWFwO2ZvcihsZXQgdT0wO3U8bS5sZW5ndGgtMTt1Kz0yKXt0aGlzLmNyZWF0ZUVyYXNlclJlY3QobS5zbGljZSh1LHUrMikpO2NvbnN0e3JlY3Q6TSxyZW1vdmVJZHM6ZixuZXdXb3JrRGF0YXM6dn09dGhpcy5yZW1vdmUoKTt5PUx0KHksTSksZi5mb3JFYWNoKHg9PmMuYWRkKHgpKSx2PT1udWxsfHx2LmZvckVhY2goeD0+e2MuaGFzKHgud29ya0lkKXx8bC5zZXQoeC53b3JrSWQseCl9KX1pZih5JiZjLnNpemUpe2NvbnN0IHU9W107Zm9yKGNvbnN0IE0gb2YgbC52YWx1ZXMoKSljLmhhcyhNLndvcmtJZCl8fHUucHVzaChNKTtyZXR1cm57dHlwZTpFdC5SZW1vdmVOb2RlLGRhdGFUeXBlOkN0LkxvY2FsLHJlY3Q6eSxyZW1vdmVJZHM6Wy4uLmNdLG5ld1dvcmtEYXRhczp1fX19cmV0dXJue3R5cGU6RXQuTm9uZX19Y3V0UG9seWxpbmUoZSx0KXtsZXQgcj1bdF0scz0wO2Zvcig7czxlLmxlbmd0aDspe2NvbnN0IGM9ZVtzXTtpZihjLmxlbmd0aDwyKWJyZWFrO3I9bShyLGMpLHMrK31yZXR1cm4gcjtmdW5jdGlvbiBtKGMsbCl7Y29uc3QgdT1jO2ZvcihsZXQgTT0wO008Yy5sZW5ndGg7TSsrKXtjb25zdCBmPWNbTV0sdj1mLmZpbmRJbmRleCgoeCxSKT0+UjxmLmxlbmd0aC0xP3koW3gsZltSKzFdXSxbbFswXSxsWzFdXSk6ITEpO2lmKHYhPT0tMSYmdj4tMSl7Y29uc3QgeD1bXSxSPWYuc2xpY2UoMCx2KzEpO2lmKGh0LkVxdWFscyhmW3ZdLGxbMF0pfHxSLnB1c2gobFswXS5jbG9uZSgpLnNldHooZlt2XS56KSksUi5sZW5ndGg+MSYmeC5wdXNoKFIpLHYrbC5sZW5ndGgtMTxmLmxlbmd0aC0xKXtjb25zdCBPPXYrbC5sZW5ndGgtMSxnPWYuc2xpY2UoTykscD1sW2wubGVuZ3RoLTFdO2h0LkVxdWFscyhmW09dLHApfHxnLnVuc2hpZnQocC5jbG9uZSgpLnNldHooZltPXS56KSksZy5sZW5ndGg+MSYmeC5wdXNoKGcpfXJldHVybiB1LnNwbGljZShNLDEsLi4ueCksdX19cmV0dXJuIHV9ZnVuY3Rpb24geShjLGwpe2NvbnN0IHU9aHQuU3ViKGNbMV0sY1swXSksTT1odC5TdWIobFsxXSxsWzBdKSxmPWh0LlN1YihsWzBdLGNbMF0pO3JldHVybiBNYXRoLmFicyhodC5DcHIodSxNKSk8LjEmJk1hdGguYWJzKGh0LkNwcih1LGYpKTwuMX19aXNTYW1lUG9pbnQoZSx0KXtyZXR1cm4gZVswXT09PXRbMF0mJmVbMV09PT10WzFdfXRyYW5zbGF0ZUludGVyc2VjdChlKXtjb25zdCB0PVtdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtjb25zdCBzPWVbcl0uZmlsdGVyKChjLGwsdSk9PiEobD4wJiZ0aGlzLmlzU2FtZVBvaW50KGMsdVtsLTFdKSkpLG09W107bGV0IHk9MDtmb3IoO3k8cy5sZW5ndGg7KXtjb25zdCBjPXNbeV0sbD1uZXcgaHQoY1swXSxjWzFdKTttLnB1c2gobCkseSsrfXQucHVzaChtKX1yZXR1cm4gdH1yZW1vdmUoKXtjb25zdHtpc0xpbmU6ZX09dGhpcy53b3JrT3B0aW9ucztsZXQgdDtjb25zdCByPVtdLHM9W10sbT1bXTtyZXR1cm4gdGhpcy5jdXJOb2RlTWFwLmZvckVhY2goKHksYyk9Pntjb25zdCBsPXRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHkubmFtZSlbMF07aWYobCYmeS5yZWN0JiZ0aGlzLmVyYXNlclJlY3QmJnRoaXMuZXJhc2VyUG9seWxpbmUmJmVyKHRoaXMuZXJhc2VyUmVjdCx5LnJlY3QpKXtpZih5LnBvbHlsaW5lLmxlbmd0aD4xKXtjb25zdCB1PWNuLnBvbHlsaW5lKHkucG9seWxpbmUubWFwKE09Pk0uWFkpLHRoaXMuZXJhc2VyUG9seWxpbmUpO2lmKHUubGVuZ3RoJiYocy5wdXNoKGwpLHIucHVzaCh5Lm5hbWUpLCFlKSl7Y29uc3QgTT10aGlzLnRyYW5zbGF0ZUludGVyc2VjdCh1KSxmPXRoaXMuY3V0UG9seWxpbmUoTSx5LnBvbHlsaW5lKTtmb3IobGV0IHY9MDt2PGYubGVuZ3RoO3YrKyl7Y29uc3QgeD1gJHtjfV9zXyR7dn1gLFI9W107Zlt2XS5mb3JFYWNoKE89PntSLnB1c2goKE8ueC10aGlzLndvcmxkUG9zaXRpb25bMF0pL3RoaXMud29ybGRTY2FsaW5nWzBdLChPLnktdGhpcy53b3JsZFBvc2l0aW9uWzFdKS90aGlzLndvcmxkU2NhbGluZ1sxXSxPLnopfSksbS5wdXNoKHt3b3JrSWQ6eCxvcDpSLG9wdDp5Lm9wdCx0b29sc1R5cGU6eS50b29sc1R5cGV9KX19fWVsc2Ugcy5wdXNoKGwpLHIucHVzaCh5Lm5hbWUpO3Q9THQodCx5LnJlY3QpfX0pLHMuZm9yRWFjaCh5PT55LnJlbW92ZSgpKSx0JiYodC54LT16dC5TYWZlQm9yZGVyUGFkZGluZyx0LnktPXp0LlNhZmVCb3JkZXJQYWRkaW5nLHQudys9enQuU2FmZUJvcmRlclBhZGRpbmcqMix0LmgrPXp0LlNhZmVCb3JkZXJQYWRkaW5nKjIpLHtyZWN0OnQscmVtb3ZlSWRzOnIsbmV3V29ya0RhdGFzOm19fWNvbnN1bWVBbGwoZSl7cmV0dXJuIHRoaXMuY29uc3VtZShlKX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoenQsIlNhZmVCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoenQsImVyYXNlclNpemVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6T2JqZWN0LmZyZWV6ZShbT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MTgsaGVpZ2h0OjI2fSksT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MjYsaGVpZ2h0OjM0fSksT2JqZWN0LmZyZWV6ZSh7d2lkdGg6MzQsaGVpZ2h0OjUwfSldKX0pO2Z1bmN0aW9uIGhuKGgsZSx0KXtyZXR1cm4iIyIrKChoPDwxNikrKGU8PDgpK3QpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2LCIwIil9ZnVuY3Rpb24gZG4oaCl7Y29uc3QgZT1oLnNwbGl0KCIsIiksdD1wYXJzZUludChlWzBdLnNwbGl0KCIoIilbMV0pLHI9cGFyc2VJbnQoZVsxXSkscz1wYXJzZUludChlWzJdKSxtPXBhcnNlSW50KGVbM10uc3BsaXQoIikiKVswXSk7cmV0dXJuW2huKHQscixzKSxtXX1jbGFzcyB2dCBleHRlbmRzIGNle3VwZGF0YU9wdFNlcnZpY2UoKXt9Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKHQsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkR0LlNlbGVjdG9yfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2VsZWN0SWRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibm9kZUNvbG9yIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm5vZGVPcGFjdGl5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9sZFNlbGVjdFJlY3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tcHV0Tm9kZU1hcChlKXt0aGlzLmN1ck5vZGVNYXAuY2xlYXIoKSxlLmZvckVhY2godD0+e3ZhciBzO2NvbnN0IHI9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUodC5uYW1lKVswXXx8KChzPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6cy5nZXRFbGVtZW50c0J5TmFtZSh0Lm5hbWUpWzBdKTtpZihyKXtjb25zdCBtPXIud29ybGRQb3NpdGlvbjtsZXQgeT1yLmdldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiKTtjb25zdCBjPXIuY2xhc3NOYW1lLnNwbGl0KCIsIik7ci50YWdOYW1lPT09IkdST1VQIiYmKE51bWJlcihjWzJdKT09PWJ0LlN0cm9rZT95PXIuZ2V0QXR0cmlidXRlKCJiZ2NvbG9yIik6eT1yLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiKSksdGhpcy5jdXJOb2RlTWFwLnNldCh0Lm5hbWUse25hbWU6dC5uYW1lLHJlY3Q6dC5yZWN0LGNvbG9yOmRuKHkpWzBdLHBvczptLHJvdGF0ZTpyLmdldEF0dHJpYnV0ZSgicm90YXRlIil8fDAsc2NhbGU6ci5nZXRBdHRyaWJ1dGUoInNjYWxlIil8fFsxLDFdLG9wYWN0aXk6ci5nZXRBdHRyaWJ1dGUoIm9wYWNpdHkiKXx8MX0pfX0pfWNvbXB1dFNlbGVjdG9yKCl7bGV0IGU7Y29uc3QgdD1bXSxyPW5ldyBNYXAscz1uZXcgU2V0LG09bmV3IFNldCx5PW5ldyBNYXA7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoJiZ0aGlzLmN1ck5vZGVNYXAuc2l6ZSl7Y29uc3QgYz1IdCh0aGlzLnRtcFBvaW50cyk7dGhpcy5jdXJOb2RlTWFwLmZvckVhY2goKGwsdSk9Pntjb25zdCBNPXt4OmwucmVjdC54LHk6bC5yZWN0LnksdzpsLnJlY3QudyxoOmwucmVjdC5ofSxmPXt4OmMueCx5OmMueSx3OmMudyxoOmMuaH07ZXIoZixNKSYmKHQucHVzaCh1KSxlPUx0KGUsTSksci5zZXQodSxNKSxzLmFkZChsLmNvbG9yKSx5LnNldCh1LFsuLi5sLnBvcyxsLnJvdGF0ZV0pLG0uYWRkKGwub3BhY3RpeSkpfSl9cmV0dXJue3NlbGVjdElkczp0LGludGVyc2VjdFJlY3Q6ZSxzdWJSZWN0czpyLG5vZGVDb2xvcnM6cyxzdWJQb3M6eSxvcGFjdGl5czptfX11cGRhdGVUZW1wUG9pbnRzKGUpe2NvbnN0IHQ9dGhpcy50bXBQb2ludHMubGVuZ3RoLHI9ZS5sZW5ndGg7aWYocj4xKXtjb25zdCBzPW5ldyBBdChlW3ItMl0qdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0sZVtyLTFdKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdKTt0PT09Mj90aGlzLnRtcFBvaW50cy5zcGxpY2UoMSwxLHMpOnRoaXMudG1wUG9pbnRzLnB1c2gocyl9fWRyYXcoZSl7dmFyIG0seSxjO2NvbnN0e2ludGVyc2VjdFJlY3Q6dCxzdWJSZWN0czpyLHN1YlBvczpzfT1lOyhjPSh5PShtPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bS5wYXJlbnQpPT1udWxsP3ZvaWQgMDp5LmdldEVsZW1lbnRCeUlkKHZ0LnNlbGVjdG9ySWQpKT09bnVsbHx8Yy5yZW1vdmUoKSx0JiZ0aGlzLmRyYXdMYXllciYmdGhpcy5kcmF3U2VsZWN0b3Ioe2RyYXdSZWN0OnQsc3ViUmVjdHM6cixzdWJQb3M6cyxzZWxlY3RvcklkOnZ0LnNlbGVjdG9ySWQsbGF5ZXI6dGhpcy5kcmF3TGF5ZXJ9KX1jb25zdW1lKGUpe2NvbnN0e29wOnQsd29ya1N0YXRlOnJ9PWUuZGF0YTtpZihyPT09UXQuU3RhcnQmJmUubm9kZU1hcHMmJih0aGlzLmNvbXB1dE5vZGVNYXAoZS5ub2RlTWFwcyksdGhpcy5vbGRSZWN0PXRoaXMuYmFja1RvRnVsbExheWVyKGUubm9kZU1hcHMpKSwhKHQhPW51bGwmJnQubGVuZ3RoKXx8IXRoaXMuY3VyTm9kZU1hcC5zaXplKXJldHVybnt0eXBlOkV0Lk5vbmV9O3RoaXMudXBkYXRlVGVtcFBvaW50cyh0KTtjb25zdCBzPXRoaXMuY29tcHV0U2VsZWN0b3IoKTtpZih0aGlzLnNlbGVjdElkcyYmc24odGhpcy5zZWxlY3RJZHMscy5zZWxlY3RJZHMpKXJldHVybnt0eXBlOkV0Lk5vbmV9O3RoaXMuc2VsZWN0SWRzPXMuc2VsZWN0SWRzO2NvbnN0IG09dGhpcy5kcmF3TGF5ZXImJnRoaXMuZ2V0U2VsZWN0b3JSZWN0KHRoaXMuZHJhd0xheWVyLHZ0LnNlbGVjdG9ySWQsITApLHk9cy5pbnRlcnNlY3RSZWN0JiZ7eDpzLmludGVyc2VjdFJlY3QueC12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHk6cy5pbnRlcnNlY3RSZWN0LnktdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx3OnMuaW50ZXJzZWN0UmVjdC53K3Z0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixoOnMuaW50ZXJzZWN0UmVjdC5oK3Z0LlNlbGVjdEJvcmRlclBhZGRpbmcqMn18fHZvaWQgMDtyZXR1cm4gdGhpcy5vbGRSZWN0PUx0KG0seSksdGhpcy5kcmF3KHMpLHRoaXMubm9kZUNvbG9yPXMubm9kZUNvbG9ycy5zaXplPT09MT9zLm5vZGVDb2xvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlOnZvaWQgMCx0aGlzLm5vZGVPcGFjdGl5PXMub3BhY3RpeXMuc2l6ZT09PTE/cy5vcGFjdGl5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWU6MSx0aGlzLm9sZFNlbGVjdFJlY3Q9eSx7dHlwZTpFdC5TZWxlY3QsZGF0YVR5cGU6Q3QuTG9jYWwscmVjdDp0aGlzLm9sZFJlY3Qsc2VsZWN0SWRzOnMuc2VsZWN0SWRzLG9wdDp0aGlzLndvcmtPcHRpb25zLHBhZGRpbmc6dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxzZWxlY3RSZWN0Onksbm9kZUNvbG9yOnRoaXMubm9kZUNvbG9yLG5vZGVPcGFjdGl5OnRoaXMubm9kZU9wYWN0aXksd2lsbFN5bmNTZXJ2aWNlOiEwfX1jb25zdW1lQWxsKCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5zZWxlY3RJZHMpIT1udWxsJiZlLmxlbmd0aCYmdGhpcy5zZWFsVG9EcmF3TGF5ZXIodGhpcy5zZWxlY3RJZHMpLHRoaXMub2xkU2VsZWN0UmVjdD97dHlwZTpFdC5TZWxlY3QsZGF0YVR5cGU6Q3QuTG9jYWwscmVjdDp0aGlzLm9sZFJlY3Qsc2VsZWN0SWRzOnRoaXMuc2VsZWN0SWRzLG9wdDp0aGlzLndvcmtPcHRpb25zLHBhZGRpbmc6dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxzZWxlY3RSZWN0OnRoaXMub2xkU2VsZWN0UmVjdCxub2RlQ29sb3I6dGhpcy5ub2RlQ29sb3Isbm9kZU9wYWN0aXk6dGhpcy5ub2RlT3BhY3RpeSx3aWxsU3luY1NlcnZpY2U6ITF9Ont0eXBlOkV0Lk5vbmV9fWNvbnN1bWVTZXJ2aWNlKCl7fWNvbWJpbmVDb25zdW1lKCl7fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTB9Y2xlYXJTZWxlY3REYXRhKCl7dGhpcy5zZWxlY3RJZHM9dm9pZCAwLHRoaXMub2xkUmVjdD12b2lkIDAsdGhpcy5vbGRTZWxlY3RSZWN0PXZvaWQgMH1iYWNrVG9GdWxsTGF5ZXIoZT1uZXcgTWFwLHQpe3ZhciB5LGM7bGV0IHI7Y29uc3Qgcz1bXSxtPVtdO2Zvcihjb25zdCBsIG9mKCh5PXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6eS5jaGlsZHJlbil8fFtdKWlmKCEodCE9bnVsbCYmdC5sZW5ndGgmJiF0LmluY2x1ZGVzKGwuaWQpKSYmbC5pZCE9PXZ0LnNlbGVjdG9ySWQpe2NvbnN0IHU9bC5jbG9uZU5vZGUoITApO2lmKHUudGFnTmFtZT09PSJHUk9VUCIpe2NvbnN0IGY9bC5jbGFzc05hbWUuc3BsaXQoIiwiKTtmLmxlbmd0aD09PTMmJk51bWJlcihmWzJdKT09PWJ0LlN0cm9rZSYmdS5zZWFsKCl9cy5wdXNoKHUpLG0ucHVzaChsKTtjb25zdCBNPSgoYz1lLmdldChsLm5hbWUpKT09bnVsbD92b2lkIDA6Yy5yZWN0KXx8WnQobC5uYW1lLHRoaXMuZHJhd0xheWVyKTtNJiYocj1MdChyLE0pKX1yZXR1cm4gbS5mb3JFYWNoKGw9PmwucmVtb3ZlKCkpLHMubGVuZ3RoJiZ0aGlzLmZ1bGxMYXllci5hcHBlbmQoLi4ucyksciYmKHIueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxyLnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsci53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsci5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIpLHJ9c2VhbFRvRHJhd0xheWVyKGUpe3ZhciBzO2NvbnN0IHQ9W10scj1bXTtlLmZvckVhY2gobT0+e3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKG0udG9TdHJpbmcoKSkuZm9yRWFjaCh5PT57Y29uc3QgYz15LmNsb25lTm9kZSghMCk7aWYoYy50YWdOYW1lPT09IkdST1VQIil7Y29uc3QgbD15LmNsYXNzTmFtZS5zcGxpdCgiLCIpO2wubGVuZ3RoPT09MyYmTnVtYmVyKGxbMl0pPT09YnQuU3Ryb2tlJiZjLnNlYWwoKX10LnB1c2goYyksci5wdXNoKHkpfSl9KSxyLmZvckVhY2gobT0+bS5yZW1vdmUoKSksdCYmKChzPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8cy5hcHBlbmQoLi4udCkpfXVwZGF0ZVNlbGVjdG9yU2l6ZShlLHQscil7Y29uc3Qgcz1uZXcgTWFwLG09ZS5nZXRBdHRyaWJ1dGUoInBvcyIpLHk9ZS5jbGFzc05hbWUuc3BsaXQoIiwiKSxjPXQtdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGw9ci12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsdT15Lmxlbmd0aD09PTImJltjL051bWJlcih5WzBdKSxsL051bWJlcih5WzFdKV18fFsxLDFdO3JldHVybiBlLnNldEF0dHJpYnV0ZSgic2l6ZSIsW2MsbF0pLGUuY2hpbGRyZW4uZm9yRWFjaChNPT57aWYoTS5pZD09PXZ0LnNlbGVjdG9yQm9yZGVySWQpTS5zZXRBdHRyaWJ1dGUoInBvcyIsW2MvMixsLzJdKSxNLnNldEF0dHJpYnV0ZSgid2lkdGgiLGMpLE0uc2V0QXR0cmlidXRlKCJoZWlnaHQiLGwpO2Vsc2UgaWYodSl7Y29uc3QgZj1NLmNsYXNzTmFtZS5zcGxpdCgiLCIpLHY9W051bWJlcihmWzBdKSp1WzBdLE51bWJlcihmWzFdKSp1WzFdXSx4PU0uZ2V0QXR0cmlidXRlKCJ3aWR0aCIpLFI9TS5nZXRBdHRyaWJ1dGUoImhlaWdodCIpLE89TnVtYmVyKGZbMl0pKnVbMF0sZz1OdW1iZXIoZlszXSkqdVsxXTtNLnNldEF0dHJpYnV0ZSgicG9zIix2KSxNLnNldEF0dHJpYnV0ZSgid2lkdGgiLE8pLE0uc2V0QXR0cmlidXRlKCJoZWlnaHQiLGcpO2NvbnN0IHA9TS5pZC5zcGxpdCgic2VsZWN0b3ItIilbMV07aWYocCl7Y29uc3Qgbj1bdlswXSttWzBdLHZbMV0rbVsxXV0sYT1bTy94LGcvUl07cy5zZXQocCxbblswXSxuWzFdLGFbMF0sYVsxXV0pfX19KSxzfXVwZGF0ZVNlbGVjdG9yUmVjdChlLHQpe2NvbnN0e3c6cixoOnMseDptLHl9PXQsYz1yLXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMixsPXMtdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLHU9bSt2dC5TZWxlY3RCb3JkZXJQYWRkaW5nLE09eSt2dC5TZWxlY3RCb3JkZXJQYWRkaW5nO2Uuc2V0QXR0cmlidXRlKCJzaXplIixbcixzXSksZS5zZXRBdHRyaWJ1dGUoInBvcyIsW3UsTV0pLGUuc2V0QXR0cmlidXRlKCJjbGFzc05hbWUiLGAke3Qud30sJHt0Lmh9YCksZS5jaGlsZHJlbi5mb3JFYWNoKGY9PntpZihmLnNldEF0dHJpYnV0ZSgicG9zIixbYy8yLGwvMl0pLGYuc2V0QXR0cmlidXRlKCJ3aWR0aCIsYyksZi5zZXRBdHRyaWJ1dGUoImhlaWdodCIsbCksZi5pZD09PXZ0LnNlbGVjdG9yQm9yZGVySWQpZi5zZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIsYCR7dC53LzJ9LCR7dC5oLzJ9LCR7dC53fSwke3QuaH1gKTtlbHNle2NvbnN0IHY9Zi5jbGFzc05hbWUuc3BsaXQoIiwiKSx4PXYmJk51bWJlcih2WzRdKXx8MDtmLnNldEF0dHJpYnV0ZSgiY2xhc3NOYW1lIixgJHtjLzJ9LCR7bC8yfSwke3Qud30sJHt0Lmh9LCR7eH1gKX19KX1nZXRTZWxlY3RvclJlY3QoZSx0LHIpe3ZhciBsO2xldCBzO2NvbnN0IG09KGw9ZS5wYXJlbnQpPT1udWxsP3ZvaWQgMDpsLmdldEVsZW1lbnRCeUlkKHQpLHk9bT09bnVsbD92b2lkIDA6bS5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvckJvcmRlcklkKSxjPXk9PW51bGw/dm9pZCAwOnkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJuIGMmJihzPUx0KHMse3g6TWF0aC5mbG9vcihjLngpLHk6TWF0aC5mbG9vcihjLnkpLHc6TWF0aC5yb3VuZChjLndpZHRoKSxoOk1hdGgucm91bmQoYy5oZWlnaHQpfSkpLHMmJnI/e3g6cy54LXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcseTpzLnktdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx3OnMudyt2dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsaDpzLmgrdnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyfTpzfXVwZGF0ZVNlbGVjdG9yKGUpe3ZhciBsLHUsTTtjb25zdHt1cGRhdGVTZWxlY3Rvck9wdDp0LHNlbGVjdElkczpyfT1lO2xldCBzO2NvbnN0IG09bmV3IE1hcDtsZXQgeTtjb25zdCBjPSh1PShsPXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6bC5wYXJlbnQpPT1udWxsP3ZvaWQgMDp1LmdldEVsZW1lbnRCeUlkKHZ0LnNlbGVjdG9ySWQpO2lmKGMpe2xldCBmO2lmKHQucG9zKXtjb25zdCB2PVt0LnBvc1swXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx0LnBvc1sxXSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXV0seD1jLmdldEF0dHJpYnV0ZSgicG9zIik7Zj1bdlswXS14WzBdLHZbMV0teFsxXV0sYy5zZXRBdHRyaWJ1dGUoInBvcyIsdil9aWYodC5zZWxlY3RvckNvbG9yJiYoKE09Yy5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvckJvcmRlcklkKSk9PW51bGx8fE0uc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIsdC5zZWxlY3RvckNvbG9yKSksdC5zaXplJiYoeT10aGlzLnVwZGF0ZVNlbGVjdG9yU2l6ZShjLHQuc2l6ZS53aWR0aCx0LnNpemUuaGVpZ2h0KSksdC5hbmdsZSlyPT1udWxsfHxyLmZvckVhY2godj0+e3ZhciB4Oyh4PXRoaXMuZHJhd0xheWVyKT09bnVsbHx8eC5nZXRFbGVtZW50c0J5TmFtZSh2KS5mb3JFYWNoKFI9PntpZihSKXtjb25zdCBPPXt1c2VBbmltYXRpb246ITF9O3QuYW5nbGUmJihPLmFuZ2xlPXQuYW5nbGUsTy5vcmlnaW5Qb3M9Ui5jbGFzc05hbWUuc3BsaXQoIiwiKS5tYXAocD0+TnVtYmVyKHApKSxSLnNldEF0dHJpYnV0ZSgicm90YXRlIixPLmFuZ2xlKSksbS5zZXQoUi5uYW1lLE8pO2NvbnN0IGc9WnQoUi5uYW1lLHRoaXMuZHJhd0xheWVyKTtzPUx0KHMsZyl9fSl9LHRoaXMpO2Vsc2V7cj09bnVsbHx8ci5mb3JFYWNoKFI9Pnt2YXIgTzsoTz10aGlzLmRyYXdMYXllcik9PW51bGx8fE8uZ2V0RWxlbWVudHNCeU5hbWUoUikuZm9yRWFjaChnPT57aWYoZyl7Y29uc3QgcD17dXNlQW5pbWF0aW9uOiExfTtpZih0LnBvcyYmZil7Y29uc3QgYT1nLmdldEF0dHJpYnV0ZSgicG9zIik7cC5wb3M9W2ZbMF0vdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK2FbMF0sZlsxXS90aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rYVsxXV0scC5vcmlnaW5Qb3M9Zy5jbGFzc05hbWUuc3BsaXQoIiwiKS5tYXAoaT0+TnVtYmVyKGkpKSxnLnNldEF0dHJpYnV0ZSgicG9zIixwLnBvcyl9aWYodC56SW5kZXhEaXN0YW5jZXx8dC56SW5kZXgpe2lmKHQuekluZGV4RGlzdGFuY2Upe2NvbnN0IGE9Zy5nZXRBdHRyaWJ1dGUoInpJbmRleCIpO3AuekluZGV4PWErdC56SW5kZXhEaXN0YW5jZX1lbHNlIHAuekluZGV4PXQuekluZGV4O2cuc2V0QXR0cmlidXRlKCJ6SW5kZXgiLHAuekluZGV4KX1pZih0LmNvbG9yKXtwLmNvbG9yPXQuY29sb3I7Y29uc3QgYT1nLmNsYXNzTmFtZS5zcGxpdCgiLCIpO2cudGFnTmFtZT09PSJHUk9VUCI/TnVtYmVyKGFbMl0pPT09YnQuU3Ryb2tlP2cuc2V0QXR0cmlidXRlKCJiZ2NvbG9yIixwLmNvbG9yKTpnLmNoaWxkcmVuLmZvckVhY2goaT0+e2kuc2V0QXR0cmlidXRlKCJzdHJva2VDb2xvciIscC5jb2xvcil9KTpnLnRhZ05hbWU9PT0iUEFUSCImJihnLnNldEF0dHJpYnV0ZSgic3Ryb2tlQ29sb3IiLHAuY29sb3IpLGcuZ2V0QXR0cmlidXRlKCJmaWxsQ29sb3IiKSYmZy5zZXRBdHRyaWJ1dGUoImZpbGxDb2xvciIscC5jb2xvcikpfXQub3BhY2l0eSYmKHAub3BhY2l0eT10Lm9wYWNpdHksZy5zZXRBdHRyaWJ1dGUoIm9wYWNpdHkiLHAub3BhY2l0eSkpO2NvbnN0IG49eT09bnVsbD92b2lkIDA6eS5nZXQoZy5uYW1lKTtpZihuKXtjb25zdCBhPWcuZ2V0QXR0cmlidXRlKCJzY2FsZSIpLGk9W25bMl0qYVswXSxuWzNdKmFbMV1dO3Aub3JpZ2luUG9zPWcuY2xhc3NOYW1lLnNwbGl0KCIsIikubWFwKG89Pk51bWJlcihvKSkscC5wb3M9WyhuWzBdLXRoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0pL3RoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSwoblsxXS10aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdKS90aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV1dLHAuc2NhbGU9aSxnLnNldEF0dHJpYnV0ZSgicG9zIixwLnBvcyksZy5zZXRBdHRyaWJ1dGUoInNjYWxlIixwLnNjYWxlKX1tLnNldChnLm5hbWUscCl9fSl9LHRoaXMpO2NvbnN0IHY9Yy5nZXRFbGVtZW50QnlJZCh2dC5zZWxlY3RvckJvcmRlcklkKSx4PXY9PW51bGw/dm9pZCAwOnYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7eCYmKHM9THQocyx7eDpNYXRoLmZsb29yKHgueCkseTpNYXRoLmZsb29yKHgueSksdzpNYXRoLnJvdW5kKHgud2lkdGgpLGg6TWF0aC5yb3VuZCh4LmhlaWdodCl9KSl9fWlmKHMpcmV0dXJuIHMueC09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyxzLnktPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcscy53Kz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIscy5oKz12dC5TZWxlY3RCb3JkZXJQYWRkaW5nKjIsdC5hbmdsZSYmdGhpcy51cGRhdGVTZWxlY3RvclJlY3QoYyxzKSx0aGlzLm9sZFJlY3Q9THQodGhpcy5vbGRSZWN0LHMpLHRoaXMub2xkU2VsZWN0UmVjdD1zLHt0eXBlOkV0LlVwZGF0ZU5vZGUsZGF0YVR5cGU6Q3QuTG9jYWwscmVjdDpzLHVwZGF0ZU5vZGVPcHRzOm19fWJsdXJTZWxlY3RvcihlKXtjb25zdCB0PXRoaXMuYmFja1RvRnVsbExheWVyKGUpO3JldHVybnt0eXBlOkV0LlNlbGVjdCxkYXRhVHlwZTpDdC5Mb2NhbCxyZWN0OnQsc2VsZWN0SWRzOltdLHdpbGxTeW5jU2VydmljZTohMH19Z2V0UmlnaHRTZXJ2aWNlSWQoZSl7cmV0dXJuIGUucmVwbGFjZSgiKysiLCItIil9ZHJhd1NlbGVjdG9yKGUpe2NvbnN0e2RyYXdSZWN0OnQsc3ViUmVjdHM6cixzdWJQb3M6cyxzZWxlY3RvcklkOm0sbGF5ZXI6eX09ZSxjPW5ldyBTZSh7cG9zOlt0LngsdC55XSxhbmNob3I6WzAsMF0sc2l6ZTpbdC53LHQuaF0sY2xhc3NOYW1lOmAke3Qud30sJHt0Lmh9YCxpZDptLG5hbWU6dnQuc2VsZWN0b3JJZCx6SW5kZXg6MWUzfSksbD1bXSx1PW5ldyBxZSh7bm9ybWFsaXplOiEwLHBvczpbdC53LzIsdC5oLzJdLGxpbmVXaWR0aDoxLHN0cm9rZUNvbG9yOnRoaXMud29ya09wdGlvbnMuY29sb3Isd2lkdGg6dC53LGhlaWdodDp0LmgsY2xhc3NOYW1lOmAke3Qudy8yfSwke3QuaC8yfSwke3Qud30sJHt0Lmh9YCxpZDp2dC5zZWxlY3RvckJvcmRlcklkfSk7bC5wdXNoKHUpLHIuZm9yRWFjaCgoTSxmKT0+e2NvbnN0IHY9cz09bnVsbD92b2lkIDA6cy5nZXQoZik7aWYodil7Y29uc3QgeD1bdlswXS10LngsdlsxXS10LnldLFI9YCR7eFswXX0sJHt4WzFdfSwke00ud30sJHtNLmh9LCR7dlsyXX1gLE89bmV3IHFlKHtub3JtYWxpemU6ITAscG9zOngsbGluZVdpZHRoOjEsc3Ryb2tlQ29sb3I6ci5zaXplPjE/dGhpcy53b3JrT3B0aW9ucy5jb2xvcjp2b2lkIDAsd2lkdGg6TS53LGhlaWdodDpNLmgsY2xhc3NOYW1lOlIsaWQ6YHNlbGVjdG9yLSR7Zn1gLG5hbWU6YHNlbGVjdG9yLSR7Zn1gfSk7bC5wdXNoKE8pfX0pLGwmJmMuYXBwZW5kKC4uLmwpLCh5PT1udWxsP3ZvaWQgMDp5LnBhcmVudCkuYXBwZW5kQ2hpbGQoYyl9c2VsZWN0U2VydmljZU5vZGUoZSx0LHIpe3ZhciBNO2NvbnN0e3NlbGVjdElkczpzfT10LG09dGhpcy5nZXRSaWdodFNlcnZpY2VJZChlKSx5PXRoaXMuZ2V0U2VsZWN0b3JSZWN0KHRoaXMuZnVsbExheWVyLG0sITApOyhNPXRoaXMuZnVsbExheWVyLnBhcmVudC5nZXRFbGVtZW50QnlJZChtKSk9PW51bGx8fE0ucmVtb3ZlKCk7bGV0IGM7Y29uc3QgbD1uZXcgTWFwLHU9bmV3IE1hcDtyZXR1cm4gcz09bnVsbHx8cy5mb3JFYWNoKGY9Pnt2YXIgUjtjb25zdCB2PXIuZ2V0KGYpLHg9dGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZilbMF07aWYodiYmeCl7Yz1MdChjLHYucmVjdCksbC5zZXQoZix2LnJlY3QpO2NvbnN0IE89eC53b3JsZFBvc2l0aW9uLGc9KChSPXYub3B0KT09bnVsbD92b2lkIDA6Ui5yb3RhdGUpfHx4LmdldEF0dHJpYnV0ZSgicm90YXRlIil8fDA7dS5zZXQoZixbLi4uTyxnXSl9fSksYyYmdGhpcy5mdWxsTGF5ZXImJnRoaXMuZHJhd1NlbGVjdG9yKHtkcmF3UmVjdDpjLHN1YlJlY3RzOmwsc3ViUG9zOnUsc2VsZWN0b3JJZDptLGxheWVyOnRoaXMuZnVsbExheWVyfSksYz1MdChjLHkpLGMmJihjLngtPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsYy55LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLGMudys9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLGMuaCs9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyKSxjfXJlbW92ZVNlcnZpY2UoKXt0aHJvdyBuZXcgRXJyb3IoIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuIil9Z2V0U2VsZWN0b3IoZSl7dmFyIG07bGV0IHQ7Y29uc3Qgcj1uZXcgTWFwLHM9bmV3IE1hcDtyZXR1cm4obT10aGlzLnNlbGVjdElkcyk9PW51bGx8fG0uZm9yRWFjaCh5PT57dmFyIHU7Y29uc3QgYz1lLmdldCh5KSxsPSh1PXRoaXMuZHJhd0xheWVyKT09bnVsbD92b2lkIDA6dS5nZXRFbGVtZW50c0J5TmFtZSh5KVswXTtpZihjJiZsKXtjb25zdCBNPWwud29ybGRQb3NpdGlvbixmPWwuZ2V0QXR0cmlidXRlKCJyb3RhdGUiKXx8MDt0PUx0KHQsYy5yZWN0KSxyLnNldCh5LGMucmVjdCkscy5zZXQoeSxbLi4uTSxmXSl9fSx0aGlzKSx0aGlzLm9sZFJlY3Q9THQodCx0aGlzLm9sZFJlY3QpLHRoaXMuZHJhdyh7aW50ZXJzZWN0UmVjdDp0LHN1YlJlY3RzOnIsc3ViUG9zOnN9KSx0JiYodC54LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHQueS09dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyx0LncrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMix0LmgrPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcqMiksdGhpcy5vbGRTZWxlY3RSZWN0PXQsdH11cGRhdGVTZWxlY3RJZHMoZSx0KXt2YXIgYyxsO2xldCByO2NvbnN0IHM9KGM9dGhpcy5zZWxlY3RJZHMpPT1udWxsP3ZvaWQgMDpjLmZpbHRlcih1PT4hZS5pbmNsdWRlcyh1KSksbT1lLmZpbHRlcih1PT57dmFyIE07cmV0dXJuISgoTT10aGlzLnNlbGVjdElkcykhPW51bGwmJk0uaW5jbHVkZXModSkpfSk7aWYocyE9bnVsbCYmcy5sZW5ndGgmJihyPXRoaXMuYmFja1RvRnVsbExheWVyKHQscykpLG0ubGVuZ3RoKXt0aGlzLnNlYWxUb0RyYXdMYXllcihtKTtmb3IoY29uc3QgdSBvZiBtKXtjb25zdCBNPShsPXQuZ2V0KHUpKT09bnVsbD92b2lkIDA6bC5yZWN0O00mJihyPUx0KHIsTSkpfXImJihyLngtPXZ0LlNlbGVjdEJvcmRlclBhZGRpbmcsci55LT12dC5TZWxlY3RCb3JkZXJQYWRkaW5nLHIudys9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyLHIuaCs9dnQuU2VsZWN0Qm9yZGVyUGFkZGluZyoyKX10aGlzLnNlbGVjdElkcz1lO2NvbnN0IHk9dGhpcy5nZXRTZWxlY3Rvcih0KTtyZXR1cm57YmdSZWN0OnIsc2VsZWN0UmVjdDp5fX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHZ0LCJzZWxlY3RvcklkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6InNlbGVjdG9yIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2dCwic2VsZWN0b3JCb3JkZXJJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOiJzZWxlY3Rvci1ib3JkZXIifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHZ0LCJTZWxlY3RCb3JkZXJQYWRkaW5nIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Mn0pO2NsYXNzIGduIGV4dGVuZHMgY2V7dXBkYXRhT3B0U2VydmljZSgpe31jb25zdHJ1Y3RvcihlLHQpe3N1cGVyKHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6RHQuTGFzZXJQZW59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29uc3VtZUluZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe31zZXRXb3JrT3B0aW9ucyhlKXtzdXBlci5zZXRXb3JrT3B0aW9ucyhlKSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe2NvbnN0e2RhdGE6dCxpc0Z1bGxXb3JrOnJ9PWUse3dvcmtJZDpzLG9wOm19PXQ7aWYoKG09PW51bGw/dm9pZCAwOm0ubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6RXQuTm9uZX07aWYodGhpcy51cGRhdGVUZW1wUG9pbnRzKG18fFtdKSx0aGlzLmNvbnN1bWVJbmRleD50aGlzLnRtcFBvaW50cy5sZW5ndGgtNClyZXR1cm57dHlwZTpFdC5Ob25lfTtjb25zdHtjb2xvcjp5LHRoaWNrbmVzczpjLHN0cm9rZVR5cGU6bCxvcGFjaXR5OnV9PXRoaXMud29ya09wdGlvbnMsTT1IdCh0aGlzLnRtcFBvaW50cyxjKTtsZXQgZj0hMTtjb25zdCB2PXRoaXMuc3luY0luZGV4LHg9dGhpcy50bXBQb2ludHMuc2xpY2UodGhpcy5jb25zdW1lSW5kZXgpO3RoaXMuY29uc3VtZUluZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aC0xLHRoaXMuc3luY1RpbWVzdGFtcD09PTAmJih0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKSk7Y29uc3QgUj17bmFtZTpzPT1udWxsP3ZvaWQgMDpzLnRvU3RyaW5nKCksY2xhc3NOYW1lOiJMYXNlclBlbiIsb3BhY2l0eTp1fHwxLGxpbmVEYXNoOmw9PT1idC5Eb3R0ZWQ/WzEsYyoyXTpsPT09YnQuTG9uZ0RvdHRlZD9bYyxjKjJdOnZvaWQgMCxzdHJva2VDb2xvcjp5LGxpbmVDYXA6InJvdW5kIixsaW5lV2lkdGg6YyxhbmNob3I6Wy41LC41XX0sTz10aGlzLmdldFRhc2tQb2ludHMoeCk7aWYoTy5sZW5ndGgpe2NvbnN0IHA9RGF0ZS5ub3coKTtwLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZSYmKGY9ITAsdGhpcy5zeW5jVGltZXN0YW1wPXAsdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSwhciYmdGhpcy5kcmF3KHthdHRyczpSLHRhc2tzOk8saXNEb3Q6ITF9KX1jb25zdCBnPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh2KS5mb3JFYWNoKHA9PntnLnB1c2gocC54LHAueSl9KSx7cmVjdDp7eDpNLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTpNLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzpNLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6TS5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX0sdHlwZTpFdC5EcmF3V29yayxkYXRhVHlwZTpDdC5Mb2NhbCx3b3JrSWQ6Zj9zOnZvaWQgMCxvcDpmP2c6dm9pZCAwLGluZGV4OmY/dioyOnZvaWQgMH19Y29uc3VtZUFsbCgpe3ZhciBzO2NvbnN0IGU9KHM9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpzLnRvU3RyaW5nKCk7bGV0IHQ7aWYodGhpcy50bXBQb2ludHMubGVuZ3RoLTE+dGhpcy5jb25zdW1lSW5kZXgpe2xldCBtPXRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuY29uc3VtZUluZGV4KTtjb25zdCB5PW0ubGVuZ3RoPT09MSx7Y29sb3I6Yyx0aGlja25lc3M6bCxzdHJva2VUeXBlOnUsb3BhY2l0eTpNfT10aGlzLndvcmtPcHRpb25zO2lmKHkpe2NvbnN0IHg9dGhpcy5jb21wdXREb3RTdHJva2Uoe3BvaW50Om1bMF0scmFkaXVzOmwvMn0pO209eC5wcyx0PXgucmVjdH1lbHNlIHQ9SHQodGhpcy50bXBQb2ludHMsbCk7Y29uc3QgZj17bmFtZTplPT1udWxsP3ZvaWQgMDplLnRvU3RyaW5nKCksY2xhc3NOYW1lOiJMYXNlclBlbiIsZmlsbENvbG9yOnk/Yzp2b2lkIDAsb3BhY2l0eTpNfHwxLGxpbmVEYXNoOnU9PT1idC5Eb3R0ZWQmJiF5P1sxLGwqMl06dT09PWJ0LkxvbmdEb3R0ZWQmJiF5P1tsLGwqMl06dm9pZCAwLHN0cm9rZUNvbG9yOmMsbGluZUNhcDp5P3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDp5PzA6bCxhbmNob3I6Wy41LC41XX0sdj10aGlzLmdldFRhc2tQb2ludHMobSk7di5sZW5ndGgmJnRoaXMuZHJhdyh7YXR0cnM6Zix0YXNrczp2LGlzRG90Onl9KX1jb25zdCByPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLnN5bmNJbmRleCkuZm9yRWFjaChtPT57ci5wdXNoKG0ueCxtLnkpfSkse3JlY3Q6dCYme3g6dC54KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzBdLHk6dC55KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXSt0aGlzLmZ1bGxMYXllci53b3JsZFBvc2l0aW9uWzFdLHc6dC53KnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1swXSxoOnQuaCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV19LHR5cGU6RXQuRHJhd1dvcmssZGF0YVR5cGU6Q3QuTG9jYWwsd29ya0lkOmUsb3A6cixpbmRleDp0aGlzLnN5bmNJbmRleCoyfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIHg7Y29uc3R7b3A6dH09ZSx7Y29sb3I6cix0aGlja25lc3M6cyxzdHJva2VUeXBlOm0sb3BhY2l0eTp5fT10aGlzLndvcmtPcHRpb25zO2lmKCF0Lmxlbmd0aCl7Y29uc3QgUj1IdCh0aGlzLnRtcFBvaW50cyxzKTtyZXR1cm57eDpSLngqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMF0seTpSLnkqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdK3RoaXMuZnVsbExheWVyLndvcmxkUG9zaXRpb25bMV0sdzpSLncqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzBdLGg6Ui5oKnRoaXMuZnVsbExheWVyLndvcmxkU2NhbGluZ1sxXX19Y29uc3QgYz1NYXRoLm1heCgwLHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xKTt0aGlzLnVwZGF0ZVRlbXBQb2ludHModHx8W10pO2xldCBsLHU9dGhpcy50bXBQb2ludHMuc2xpY2UoYyk7Y29uc3QgTT11Lmxlbmd0aD09PTE7aWYoTSl7Y29uc3QgUj10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6dVswXSxyYWRpdXM6cy8yfSk7dT1SLnBzLGw9Ui5yZWN0fWVsc2UgbD1IdCh0aGlzLnRtcFBvaW50cyxzKTtjb25zdCBmPXtuYW1lOih4PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6eC50b1N0cmluZygpLGNsYXNzTmFtZToiTGFzZXJQZW4iLGZpbGxDb2xvcjpNP3I6dm9pZCAwLG9wYWNpdHk6eXx8MSxsaW5lRGFzaDptPT09YnQuRG90dGVkJiYhTT9bMSxzKjJdOm09PT1idC5Mb25nRG90dGVkJiYhTT9bcyxzKjJdOnZvaWQgMCxzdHJva2VDb2xvcjpyLGxpbmVDYXA6TT92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6TT8wOnMsYW5jaG9yOlsuNSwuNV19LHY9dGhpcy5nZXRUYXNrUG9pbnRzKHUpO3JldHVybiB2Lmxlbmd0aCYmdGhpcy5kcmF3KHthdHRyczpmLHRhc2tzOnYsaXNEb3Q6TX0pLHt4OmwueCp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblswXSx5OmwueSp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMV0rdGhpcy5mdWxsTGF5ZXIud29ybGRQb3NpdGlvblsxXSx3Omwudyp0aGlzLmZ1bGxMYXllci53b3JsZFNjYWxpbmdbMF0saDpsLmgqdGhpcy5mdWxsTGF5ZXIud29ybGRTY2FsaW5nWzFdfX1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6cn09ZSxzPXt4OnQueC1yLHk6dC55LXIsdzpyKjIsaDpyKjJ9O3JldHVybntwczpBdC5HZXREb3RTdHJva2UodCxyLDgpLHJlY3Q6c319dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aDtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrPTIpe2lmKHQpe2NvbnN0IHM9dGhpcy50bXBQb2ludHMuc2xpY2UoLTEpWzBdO3MmJnMueD09PWVbcl0mJnMueT09PWVbcisxXSYmdGhpcy50bXBQb2ludHMucG9wKCl9dGhpcy50bXBQb2ludHMucHVzaChuZXcgQXQoZVtyXSxlW3IrMV0pKX19YXN5bmMgZHJhdyhlKXtjb25zdHthdHRyczp0LHRhc2tzOnIsaXNEb3Q6c309ZSxtPXRoaXMuZnVsbExheWVyLHtkdXJhdGlvbjp5fT10aGlzLndvcmtPcHRpb25zLGM9bmV3IGJlO2ZvcihsZXQgbD0wO2w8ci5sZW5ndGg7bCsrKXtjb25zdHtwb3M6dSxwb2ludHM6TX09cltsXTtsZXQgZjtzP2Y9ZGUoTSwhMCk6Zj1kZShNLCExKSxjLmF0dHIoey4uLnQscG9zOnUsZDpmfSk7Y29uc3R7dmVydGV4OnYsZnJhZ21lbnQ6eH09dGhpcy53b3JrT3B0aW9ucztpZih2JiZ4KXtjb25zdCBSPW0ucmVuZGVyZXIuY3JlYXRlUHJvZ3JhbSh7dmVydGV4OnYsZnJhZ21lbnQ6eH0pLHt3aWR0aDpPLGhlaWdodDpnfT1tLmdldFJlc29sdXRpb24oKTtjLnNldFVuaWZvcm1zKHt1X3RpbWU6MCx1X3Jlc29sdXRpb246W08sZ119KSxjLnNldFByb2dyYW0oUil9bS5hcHBlbmRDaGlsZChjKSxhd2FpdCBjLnRyYW5zaXRpb24oeSkuYXR0cih7c2NhbGU6cz9bLjEsLjFdOlsxLDFdLGxpbmVXaWR0aDpzPzA6MX0pLGMucmVtb3ZlKCl9fWdldFRhc2tQb2ludHMoZSl7dmFyIGw7Y29uc3QgdD1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IHI9MCxzPWVbMF0ueCxtPWVbMF0ueSx5PVtzLG1dLGM9W107Zm9yKDtyPGUubGVuZ3RoOyl7Y29uc3QgdT1lW3JdLE09dS54LXMsZj11LnktbTtpZihjLnB1c2gobmV3IEF0KE0sZikpLHI+MCYmcjxlLmxlbmd0aC0xKXtjb25zdCB2PWVbcl0uZ2V0QW5nbGVCeVBvaW50cyhlW3ItMV0sZVtyKzFdKTtpZih2PDkwfHx2PjI3MCl7Y29uc3QgeD0obD1jLnBvcCgpKT09bnVsbD92b2lkIDA6bC5jbG9uZSgpO3gmJnQucHVzaCh7cG9zOnkscG9pbnRzOlsuLi5jLHhdfSkscz1lW3JdLngsbT1lW3JdLnkseT1bcyxtXTtjb25zdCBSPXUueC1zLE89dS55LW07Yz1bbmV3IEF0KFIsTyldfX1yKyt9cmV0dXJuIHQucHVzaCh7cG9zOnkscG9pbnRzOmN9KSx0fXJlbW92ZUxvY2FsKCl7fXJlbW92ZVNlcnZpY2UoZSl7bGV0IHQ7Y29uc3Qgcj1bXTtyZXR1cm4gdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSkuZm9yRWFjaChzPT57aWYocy5uYW1lPT09ZSl7Y29uc3QgbT1zLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3Q9THQodCx7eDptLngseTptLnksdzptLndpZHRoLGg6bS5oZWlnaHR9KSxyLnB1c2gocyl9fSksci5sZW5ndGgmJnIuZm9yRWFjaChzPT5zLnJlbW92ZSgpKSx0fX1jbGFzcyBtbntjb25zdHJ1Y3Rvcigpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdXJOb2RlTWFwIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pfXVwZGF0ZVNjZW5lKGUpe3RoaXMuc2NlbmUuYXR0cih7Li4uZX0pO2NvbnN0e3dpZHRoOnQsaGVpZ2h0OnJ9PWU7dGhpcy5zY2VuZS5jb250YWluZXIud2lkdGg9dCx0aGlzLnNjZW5lLmNvbnRhaW5lci5oZWlnaHQ9cix0aGlzLnNjZW5lLndpZHRoPXQsdGhpcy5zY2VuZS5oZWlnaHQ9cix0aGlzLnVwZGF0ZUxheWVyKHt3aWR0aDp0LGhlaWdodDpyfSl9dXBkYXRlTGF5ZXIoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZTt0aGlzLmZ1bGxMYXllciYmKHRoaXMuZnVsbExheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoIndpZHRoIix0KSx0aGlzLmZ1bGxMYXllci5wYXJlbnQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHIpLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgicG9zIixbdCouNSxyKi41XSkpLHRoaXMuZHJhd0xheWVyJiYodGhpcy5kcmF3TGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuZHJhd0xheWVyLnBhcmVudC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsciksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJzaXplIixbdCxyXSksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllciYmKHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgid2lkdGgiLHQpLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIucGFyZW50LnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixyKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnNldEF0dHJpYnV0ZSgic2l6ZSIsW3Qscl0pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXIuc2V0QXR0cmlidXRlKCJwb3MiLFt0Ki41LHIqLjVdKSl9Y3JlYXRlU2NlbmUoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6cn09ZSxzPW5ldyBPZmZzY3JlZW5DYW52YXModCxyKTtyZXR1cm4gbmV3IGVuKHtjb250YWluZXI6cyxkaXNwbGF5UmF0aW86dGhpcy5kcHIsZGVwdGg6ITEsZGVzeW5jaHJvbml6ZWQ6ITAsLi4uZX0pfWNyZWF0ZUxheWVyKGUsdCl7Y29uc3R7d2lkdGg6cixoZWlnaHQ6c309dCxtPSJvZmZzY3JlZW4iK0RhdGUubm93KCkseT1lLmxheWVyKG0sdCksYz1uZXcgU2Uoe2FuY2hvcjpbLjUsLjVdLHBvczpbciouNSxzKi41XSxzaXplOltyLHNdLG5hbWU6InZpZXdwb3J0In0pO3JldHVybiB5LmFwcGVuZChjKSxjfWdldE5vZGVzKGUpe3JldHVybiB0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKyIiKS5jb25jYXQodGhpcy5kcmF3TGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSsiIikpfX1jbGFzcyB2bntjb25zdHJ1Y3RvcihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZ1bGxMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3VyTm9kZU1hcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBXb3JrU2hhcGVOb2RlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcE9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlZmZlY3RXb3JrSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLmN1ck5vZGVNYXA9ZSx0aGlzLmZ1bGxMYXllcj10LHRoaXMuZHJhd0xheWVyPXJ9Z2V0V29ya1NoYXBlKGUpe3JldHVybiB0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfWdldFRtcFdvcmtTaGFwZU5vZGUoKXtyZXR1cm4gdGhpcy50bXBXb3JrU2hhcGVOb2RlfXNldFRtcFdvcmtJZChlKXtpZihlJiZ0aGlzLnRtcFdvcmtTaGFwZU5vZGUpe3RoaXMudG1wV29ya1NoYXBlTm9kZS5zZXRXb3JrSWQoZSksdGhpcy53b3JrU2hhcGVzLnNldChlLHRoaXMudG1wV29ya1NoYXBlTm9kZSksdGhpcy50bXBPcHQmJnRoaXMuc2V0VG9vbHNPcHQodGhpcy50bXBPcHQpO3JldHVybn19c2V0VG1wV29ya09wdGlvbnMoZSl7dmFyIHQ7KHQ9dGhpcy50bXBXb3JrU2hhcGVOb2RlKT09bnVsbHx8dC5zZXRXb3JrT3B0aW9ucyhlKX1zZXRXb3JrT3B0aW9ucyhlLHQpe3ZhciBzO3RoaXMud29ya1NoYXBlcy5nZXQoZSl8fHRoaXMuc2V0VG1wV29ya0lkKGUpLChzPXRoaXMud29ya1NoYXBlcy5nZXQoZSkpPT1udWxsfHxzLnNldFdvcmtPcHRpb25zKHQpfWNyZWF0ZVdvcmtTaGFwZU5vZGUoZSl7bGV0IHQ7c3dpdGNoKGUudG9vbHNUeXBlKXtjYXNlIER0LlBlbmNpbDp0PW5ldyBVdChlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyKTticmVhaztjYXNlIER0Lkxhc2VyUGVuOnQ9bmV3IGduKGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIpO2JyZWFrO2Nhc2UgRHQuRXJhc2VyOnQ9bmV3IHp0KGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIpO2JyZWFrO2Nhc2UgRHQuU2VsZWN0b3I6dD1uZXcgdnQoZS50b29sc09wdCx0aGlzLmZ1bGxMYXllcix0aGlzLmRyYXdMYXllcik7YnJlYWs7ZGVmYXVsdDp0PXZvaWQgMDticmVha31yZXR1cm4gdH1zZXRUb29sc09wdChlKXt2YXIgdCxyLHM7KCh0PXRoaXMudG1wT3B0KT09bnVsbD92b2lkIDA6dC50b29sc1R5cGUpIT09ZS50b29sc1R5cGUmJigoKHI9dGhpcy50bXBPcHQpPT1udWxsP3ZvaWQgMDpyLnRvb2xzVHlwZSk9PT1EdC5TZWxlY3RvciYmdGhpcy5ibHVyU2VsZWN0b3IoKSwocz10aGlzLnRtcE9wdCkhPW51bGwmJnMudG9vbHNUeXBlJiZ0aGlzLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCkpLHRoaXMudG1wT3B0PWUsdGhpcy50bXBXb3JrU2hhcGVOb2RlPXRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZShlKX1jbGVhcldvcmtTaGFwZU5vZGVDYWNoZShlKXt2YXIgdDsodD10aGlzLmdldFdvcmtTaGFwZShlKSk9PW51bGx8fHQuY2xlYXJUbXBQb2ludHMoKSx0aGlzLndvcmtTaGFwZXMuZGVsZXRlKGUpfWNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl7dGhpcy53b3JrU2hhcGVzLmZvckVhY2goZT0+ZS5jbGVhclRtcFBvaW50cygpKSx0aGlzLndvcmtTaGFwZXMuY2xlYXIoKX1ydW5FZmZlY3RXb3JrKGUpe3RoaXMuZWZmZWN0V29ya0lkJiYoY2xlYXJUaW1lb3V0KHRoaXMuZWZmZWN0V29ya0lkKSx0aGlzLmVmZmVjdFdvcmtJZD12b2lkIDApLHRoaXMuZWZmZWN0V29ya0lkPXNldFRpbWVvdXQoKCk9Pnt0aGlzLmVmZmVjdFdvcmtJZD12b2lkIDAsdGhpcy5jb21wdXROb2RlTWFwKCksdGhpcy5yZXJSZW5kZXJTZWxlY3RvcigpLGUmJmUoKX0sNTApfWNvbXB1dE5vZGVNYXAoKXt2YXIgdCxyO2NvbnN0IGU9bmV3IFNldCh0aGlzLmN1ck5vZGVNYXAua2V5cygpKTtpZih0aGlzLmZ1bGxMYXllci5jaGlsZHJlbi5mb3JFYWNoKHM9PntpZihzLm5hbWUhPT12dC5zZWxlY3RvcklkKXtjb25zdCBtPVp0KHMubmFtZSx0aGlzLmZ1bGxMYXllcik7aWYobSl7Y29uc3QgeT10aGlzLmN1ck5vZGVNYXAuZ2V0KHMubmFtZSk7eT8oeS5yZWN0PW0sZS5kZWxldGUocy5uYW1lKSk6dGhpcy5jdXJOb2RlTWFwLnNldChzLm5hbWUse25hbWU6cy5uYW1lLHJlY3Q6bX0pfX19KSwocj0odD10aGlzLmRyYXdMYXllcik9PW51bGw/dm9pZCAwOnQuY2hpbGRyZW4pPT1udWxsfHxyLmZvckVhY2gocz0+e2lmKHMubmFtZSE9PXZ0LnNlbGVjdG9ySWQpe2NvbnN0IG09WnQocy5uYW1lLHRoaXMuZHJhd0xheWVyKTtpZihtKXtjb25zdCB5PXRoaXMuY3VyTm9kZU1hcC5nZXQocy5uYW1lKTt5Pyh5LnJlY3Q9bSxlLmRlbGV0ZShzLm5hbWUpKTp0aGlzLmN1ck5vZGVNYXAuc2V0KHMubmFtZSx7bmFtZTpzLm5hbWUscmVjdDptfSl9fX0pLGUuc2l6ZSlmb3IoY29uc3QgcyBvZiBlLmtleXMoKSl0aGlzLmN1ck5vZGVNYXAuZGVsZXRlKHMpfXVwZGF0YU5vZGVNYXAoZSl7Y29uc3R7a2V5OnQsb3BzOnIsb3B0OnMsdG9vbHNUeXBlOm19PWU7bGV0IHk9WnQodCx0aGlzLmZ1bGxMYXllcik7Y29uc3QgYz10aGlzLmN1ck5vZGVNYXAuZ2V0KHQpfHx7bmFtZTp0LHJlY3Q6eX07ciYmKGMub3BzPXIpLHMmJihjLm9wdD1zKSx5JiYoYy5yZWN0PXkpLG0mJihjLnRvb2xzVHlwZT1tKSx0aGlzLmRyYXdMYXllciYmKHk9WnQodCx0aGlzLmRyYXdMYXllcikseSYmdGhpcy5kcmF3TGF5ZXImJihjLnJlY3Q9eSkpLGMucmVjdD90aGlzLmN1ck5vZGVNYXAuc2V0KHQsYyk6dGhpcy5jdXJOb2RlTWFwLmRlbGV0ZSh0KX1yZXJSZW5kZXJTZWxlY3Rvcigpe3ZhciB0O2NvbnN0IGU9dGhpcy53b3JrU2hhcGVzLmdldCh2dC5zZWxlY3RvcklkKTtpZigodD1lPT1udWxsP3ZvaWQgMDplLnNlbGVjdElkcykhPW51bGwmJnQubGVuZ3RoJiZ0aGlzLmRyYXdMYXllcil7Y29uc3Qgcj1lLmdldFNlbGVjdG9yKHRoaXMuY3VyTm9kZU1hcCk7ciYmdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDpyLGlzQ2xlYXI6ITAsaXNGdWxsV29yazohMSxjbGVhckNhbnZhczpZdC5TZWxlY3RvcixkcmF3Q2FudmFzOll0LlNlbGVjdG9yfV0sc3A6W3t0eXBlOkV0LlNlbGVjdCxzZWxlY3RJZHM6ZS5zZWxlY3RJZHMsc2VsZWN0UmVjdDpyLHdpbGxTeW5jU2VydmljZTohMX1dfSl9fX1jbGFzcyB5biBleHRlbmRzIHZue2NvbnN0cnVjdG9yKGUsdCxyKXtzdXBlcihlLHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfcG9zdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb21iaW5lRHJhd1RpbWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdDb3VudCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uV29ya1JlY3RzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbmltYXRpb25JZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjbG9zZUFuaW1hdGlvblRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxMTAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJ1bkxhc2VyUGVuU3RlcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSx0aGlzLl9wb3N0PXJ9Ymx1clNlbGVjdG9yKCl7fXJ1bkxhc2VyUGVuQW5pbWF0aW9uKCl7dGhpcy5hbmltYXRpb25JZHx8KHRoaXMuYW5pbWF0aW9uSWQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57dmFyIHIscztpZih0aGlzLmFuaW1hdGlvbklkPXZvaWQgMCx0aGlzLnJ1bkxhc2VyUGVuU3RlcCsrLHRoaXMucnVuTGFzZXJQZW5TdGVwPjEpe3RoaXMucnVuTGFzZXJQZW5TdGVwPTAsdGhpcy5ydW5MYXNlclBlbkFuaW1hdGlvbigpO3JldHVybn1sZXQgZTtjb25zdCB0PVtdOyhyPXRoaXMuYW5pbWF0aW9uV29ya1JlY3RzKT09bnVsbHx8ci5mb3JFYWNoKChtLHksYyk9PnttLmlzUmVjdCYmKGU9THQoZSxtLnJlcy5yZWN0KSksbS5yZXMud29ya0lkJiZ0LnB1c2gobS5yZXMpLHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHkudG9TdHJpbmcoKSkubGVuZ3RoP20uaXNSZWN0PSEwOm0uaXNSZWN0PSExLG0uY2FuRGVsJiZjLmRlbGV0ZSh5KX0pLChzPXRoaXMuYW5pbWF0aW9uV29ya1JlY3RzKSE9bnVsbCYmcy5zaXplJiZ0aGlzLnJ1bkxhc2VyUGVuQW5pbWF0aW9uKCksZSYmdGhpcy5fcG9zdCh7cmVuZGVyOlt7cmVjdDplLGRyYXdDYW52YXM6WXQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczpZdC5GbG9hdCxpc0Z1bGxXb3JrOiExfV0sc3A6dH0pfSkpfWRyYXdQZW5jaWwoZSl7dGhpcy5fcG9zdCh7ZHJhd0NvdW50OnRoaXMuZHJhd0NvdW50LHJlbmRlcjpbe3JlY3Q6ZT09bnVsbD92b2lkIDA6ZS5yZWN0LGRyYXdDYW52YXM6WXQuRmxvYXQsaXNDbGVhcjohMSxpc0Z1bGxXb3JrOiExfV0sc3A6KGU9PW51bGw/dm9pZCAwOmUub3ApJiZbZV19KX1jb25zdW1lRHJhdyhlKXt2YXIgcztjb25zdHtvcDp0LHdvcmtJZDpyfT1lO2lmKHQhPW51bGwmJnQubGVuZ3RoJiZyKXtjb25zdCBtPXRoaXMud29ya1NoYXBlcy5nZXQocik7aWYoIW0pcmV0dXJuO2NvbnN0IHk9bS50b29sc1R5cGUsYz1tLmNvbnN1bWUoe2RhdGE6ZSxpc0Z1bGxXb3JrOiExLGlzQ2xlYXJBbGw6ITAsaXNTdWJXb3JrZXI6ITB9KTtpZih5PT09RHQuTGFzZXJQZW4pe2MhPW51bGwmJmMucmVjdCYmKChzPXRoaXMuYW5pbWF0aW9uV29ya1JlY3RzKT09bnVsbHx8cy5zZXQocix7cmVzOmMsY2FuRGVsOiExLGlzUmVjdDohMH0pKSx0aGlzLnJ1bkxhc2VyUGVuQW5pbWF0aW9uKCk7cmV0dXJufWMmJih0aGlzLmRyYXdDb3VudCsrLHRoaXMuZHJhd1BlbmNpbChjKSl9fWNvbnN1bWVEcmF3QWxsKGUpe3ZhciByLHM7Y29uc3R7d29ya0lkOnR9PWU7aWYodCl7Y29uc3QgbT10aGlzLndvcmtTaGFwZXMuZ2V0KHQpO2lmKCFtKXJldHVybjtjb25zdCB5PW0udG9vbHNUeXBlO2lmKHk9PT1EdC5MYXNlclBlbiYmdGhpcy5hbmltYXRpb25JZCl7Y29uc3QgYz1tLmNvbnN1bWVBbGwoe2RhdGE6ZX0pO2MhPW51bGwmJmMub3AmJihjIT1udWxsJiZjLnJlY3QmJigocj10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fHIuc2V0KHQse3JlczpjLGNhbkRlbDohMSxpc1JlY3Q6ITB9KSx0aGlzLnJ1bkxhc2VyUGVuQW5pbWF0aW9uKCkpLHRoaXMuX3Bvc3Qoe3NwOltjXX0pKTtjb25zdCBsPShzPW0uZ2V0V29ya09wdGlvbnMoKSk9PW51bGw/dm9pZCAwOnMuZHVyYXRpb247dGhpcy5jbG9zZUFuaW1hdGlvblRpbWU9bD9sKjFlMysxMDA6dGhpcy5jbG9zZUFuaW1hdGlvblRpbWUsc2V0VGltZW91dCgoKT0+e3ZhciBNO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQudG9TdHJpbmcoKSkubWFwKGY9PmYucmVtb3ZlKCkpLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodCk7Y29uc3QgdT0oTT10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGw/dm9pZCAwOk0uZ2V0KHQpO3UmJih1LmNhbkRlbD0hMCksc2V0VGltZW91dCgoKT0+e3RoaXMuX3Bvc3Qoe3NwOlt7cmVtb3ZlSWRzOlt0LnRvU3RyaW5nKCldLHR5cGU6RXQuUmVtb3ZlTm9kZX1dfSl9LG0uZ2V0V29ya09wdGlvbnMoKS5zeW5jVW5pdFRpbWV8fHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKX0sdGhpcy5jbG9zZUFuaW1hdGlvblRpbWUpO3JldHVybn15PT09RHQuUGVuY2lsJiYodGhpcy5kcmF3Q291bnQ9MCx0aGlzLmZ1bGxMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodCkpfX1zZXRGdWxsV29yayhlKXtjb25zdHt3b3JrSWQ6dCxvcHQ6cix0b29sc1R5cGU6c309ZTtpZih0JiZyJiZzKXtjb25zdCBtPXQmJnRoaXMud29ya1NoYXBlcy5nZXQodCl8fHRoaXMuY3JlYXRlV29ya1NoYXBlTm9kZSh7dG9vbHNPcHQ6cix0b29sc1R5cGU6c30pO3JldHVybiBtPyhtLnNldFdvcmtJZCh0KSx0aGlzLndvcmtTaGFwZXMuc2V0KHQsbSksbSk6dm9pZCAwfX1ydW5GdWxsV29yayhlKXt2YXIgcyxtO2NvbnN0IHQ9dGhpcy5zZXRGdWxsV29yayhlKSxyPWUub3BzJiZpcihlLm9wcyk7dCYmKHQuY29uc3VtZVNlcnZpY2Uoe29wOnIsaXNGdWxsV29yazohMCxyZXBsYWNlSWQ6KHM9dC5nZXRXb3JrSWQoKSk9PW51bGw/dm9pZCAwOnMudG9TdHJpbmcoKX0pLGUhPW51bGwmJmUudXBkYXRlTm9kZU9wdCYmdC51cGRhdGFPcHRTZXJ2aWNlKGUudXBkYXRlTm9kZU9wdCksZS53b3JrSWQmJnRoaXMudXBkYXRhTm9kZU1hcCh7a2V5OihtPWUud29ya0lkKT09bnVsbD92b2lkIDA6bS50b1N0cmluZygpLG9wczplLm9wcyxvcHQ6ZS5vcHQsdG9vbHNUeXBlOmUudG9vbHNUeXBlfSksZS53b3JrSWQmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoZS53b3JrSWQpKX1ydW5TZWxlY3RXb3JrKGUpe3ZhciByO2NvbnN0IHQ9dGhpcy5zZXRGdWxsV29yayhlKTt0JiYoKHI9ZS5zZWxlY3RJZHMpIT1udWxsJiZyLmxlbmd0aCkmJmUud29ya0lkJiZ0LnNlbGVjdFNlcnZpY2VOb2RlKGUud29ya0lkLnRvU3RyaW5nKCkse3NlbGVjdElkczplLnNlbGVjdElkc30sdGhpcy5jdXJOb2RlTWFwKX19ZnVuY3Rpb24gcG4oKXt0aGlzLl9fZGF0YV9fPVtdLHRoaXMuc2l6ZT0wfXZhciB4bj1wbjtmdW5jdGlvbiBNbihoLGUpe3JldHVybiBoPT09ZXx8aCE9PWgmJmUhPT1lfXZhciBzcj1NbixPbj1zcjtmdW5jdGlvbiBFbihoLGUpe2Zvcih2YXIgdD1oLmxlbmd0aDt0LS07KWlmKE9uKGhbdF1bMF0sZSkpcmV0dXJuIHQ7cmV0dXJuLTF9dmFyIHZlPUVuLFRuPXZlLFBuPUFycmF5LnByb3RvdHlwZSxBbj1Qbi5zcGxpY2U7ZnVuY3Rpb24gU24oaCl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PVRuKGUsaCk7aWYodDwwKXJldHVybiExO3ZhciByPWUubGVuZ3RoLTE7cmV0dXJuIHQ9PXI/ZS5wb3AoKTpBbi5jYWxsKGUsdCwxKSwtLXRoaXMuc2l6ZSwhMH12YXIgYm49U24sUm49dmU7ZnVuY3Rpb24gQ24oaCl7dmFyIGU9dGhpcy5fX2RhdGFfXyx0PVJuKGUsaCk7cmV0dXJuIHQ8MD92b2lkIDA6ZVt0XVsxXX12YXIgTG49Q24sRG49dmU7ZnVuY3Rpb24gSW4oaCl7cmV0dXJuIERuKHRoaXMuX19kYXRhX18saCk+LTF9dmFyIE5uPUluLGpuPXZlO2Z1bmN0aW9uIEJuKGgsZSl7dmFyIHQ9dGhpcy5fX2RhdGFfXyxyPWpuKHQsaCk7cmV0dXJuIHI8MD8oKyt0aGlzLnNpemUsdC5wdXNoKFtoLGVdKSk6dFtyXVsxXT1lLHRoaXN9dmFyIFVuPUJuLEZuPXhuLFduPWJuLCRuPUxuLHpuPU5uLHduPVVuO2Z1bmN0aW9uIHRlKGgpe3ZhciBlPS0xLHQ9aD09bnVsbD8wOmgubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj1oW2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fXRlLnByb3RvdHlwZS5jbGVhcj1Gbix0ZS5wcm90b3R5cGUuZGVsZXRlPVduLHRlLnByb3RvdHlwZS5nZXQ9JG4sdGUucHJvdG90eXBlLmhhcz16bix0ZS5wcm90b3R5cGUuc2V0PXduO3ZhciB5ZT10ZSxHbj15ZTtmdW5jdGlvbiBLbigpe3RoaXMuX19kYXRhX189bmV3IEduLHRoaXMuc2l6ZT0wfXZhciBIbj1LbjtmdW5jdGlvbiBWbihoKXt2YXIgZT10aGlzLl9fZGF0YV9fLHQ9ZS5kZWxldGUoaCk7cmV0dXJuIHRoaXMuc2l6ZT1lLnNpemUsdH12YXIgWW49Vm47ZnVuY3Rpb24gWG4oaCl7cmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGgpfXZhciBKbj1YbjtmdW5jdGlvbiBRbihoKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoaCl9dmFyIFpuPVFuLHFuPXR5cGVvZiBnZT09Im9iamVjdCImJmdlJiZnZS5PYmplY3Q9PT1PYmplY3QmJmdlLGFyPXFuLGtuPWFyLF9uPXR5cGVvZiBzZWxmPT0ib2JqZWN0IiYmc2VsZiYmc2VsZi5PYmplY3Q9PT1PYmplY3QmJnNlbGYsdGk9a258fF9ufHxGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpLEt0PXRpLGVpPUt0LHJpPWVpLlN5bWJvbCxMZT1yaSxvcj1MZSxscj1PYmplY3QucHJvdG90eXBlLG5pPWxyLmhhc093blByb3BlcnR5LGlpPWxyLnRvU3RyaW5nLHNlPW9yP29yLnRvU3RyaW5nVGFnOnZvaWQgMDtmdW5jdGlvbiBzaShoKXt2YXIgZT1uaS5jYWxsKGgsc2UpLHQ9aFtzZV07dHJ5e2hbc2VdPXZvaWQgMDt2YXIgcj0hMH1jYXRjaHt9dmFyIHM9aWkuY2FsbChoKTtyZXR1cm4gciYmKGU/aFtzZV09dDpkZWxldGUgaFtzZV0pLHN9dmFyIGFpPXNpLG9pPU9iamVjdC5wcm90b3R5cGUsbGk9b2kudG9TdHJpbmc7ZnVuY3Rpb24gZmkoaCl7cmV0dXJuIGxpLmNhbGwoaCl9dmFyIHVpPWZpLGZyPUxlLGNpPWFpLGhpPXVpLGRpPSJbb2JqZWN0IE51bGxdIixnaT0iW29iamVjdCBVbmRlZmluZWRdIix1cj1mcj9mci50b1N0cmluZ1RhZzp2b2lkIDA7ZnVuY3Rpb24gbWkoaCl7cmV0dXJuIGg9PW51bGw/aD09PXZvaWQgMD9naTpkaTp1ciYmdXIgaW4gT2JqZWN0KGgpP2NpKGgpOmhpKGgpfXZhciBwZT1taTtmdW5jdGlvbiB2aShoKXt2YXIgZT10eXBlb2YgaDtyZXR1cm4gaCE9bnVsbCYmKGU9PSJvYmplY3QifHxlPT0iZnVuY3Rpb24iKX12YXIgYWU9dmkseWk9cGUscGk9YWUseGk9IltvYmplY3QgQXN5bmNGdW5jdGlvbl0iLE1pPSJbb2JqZWN0IEZ1bmN0aW9uXSIsT2k9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixFaT0iW29iamVjdCBQcm94eV0iO2Z1bmN0aW9uIFRpKGgpe2lmKCFwaShoKSlyZXR1cm4hMTt2YXIgZT15aShoKTtyZXR1cm4gZT09TWl8fGU9PU9pfHxlPT14aXx8ZT09RWl9dmFyIGNyPVRpLFBpPUt0LEFpPVBpWyJfX2NvcmUtanNfc2hhcmVkX18iXSxTaT1BaSxEZT1TaSxocj1mdW5jdGlvbigpe3ZhciBoPS9bXi5dKyQvLmV4ZWMoRGUmJkRlLmtleXMmJkRlLmtleXMuSUVfUFJPVE98fCIiKTtyZXR1cm4gaD8iU3ltYm9sKHNyYylfMS4iK2g6IiJ9KCk7ZnVuY3Rpb24gYmkoaCl7cmV0dXJuISFociYmaHIgaW4gaH12YXIgUmk9YmksQ2k9RnVuY3Rpb24ucHJvdG90eXBlLExpPUNpLnRvU3RyaW5nO2Z1bmN0aW9uIERpKGgpe2lmKGghPW51bGwpe3RyeXtyZXR1cm4gTGkuY2FsbChoKX1jYXRjaHt9dHJ5e3JldHVybiBoKyIifWNhdGNoe319cmV0dXJuIiJ9dmFyIGRyPURpLElpPWNyLE5pPVJpLGppPWFlLEJpPWRyLFVpPS9bXFxeJC4qKz8oKVtcXXt9fF0vZyxGaT0vXlxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXF0kLyxXaT1GdW5jdGlvbi5wcm90b3R5cGUsJGk9T2JqZWN0LnByb3RvdHlwZSx6aT1XaS50b1N0cmluZyx3aT0kaS5oYXNPd25Qcm9wZXJ0eSxHaT1SZWdFeHAoIl4iK3ppLmNhbGwod2kpLnJlcGxhY2UoVWksIlxcJCYiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcKCl8IGZvciAuKz8oPz1cXFxdKS9nLCIkMS4qPyIpKyIkIik7ZnVuY3Rpb24gS2koaCl7aWYoIWppKGgpfHxOaShoKSlyZXR1cm4hMTt2YXIgZT1JaShoKT9HaTpGaTtyZXR1cm4gZS50ZXN0KEJpKGgpKX12YXIgSGk9S2k7ZnVuY3Rpb24gVmkoaCxlKXtyZXR1cm4gaD09bnVsbD92b2lkIDA6aFtlXX12YXIgWWk9VmksWGk9SGksSmk9WWk7ZnVuY3Rpb24gUWkoaCxlKXt2YXIgdD1KaShoLGUpO3JldHVybiBYaSh0KT90OnZvaWQgMH12YXIgWHQ9UWksWmk9WHQscWk9S3Qsa2k9WmkocWksIk1hcCIpLEllPWtpLF9pPVh0LHRzPV9pKE9iamVjdCwiY3JlYXRlIikseGU9dHMsZ3I9eGU7ZnVuY3Rpb24gZXMoKXt0aGlzLl9fZGF0YV9fPWdyP2dyKG51bGwpOnt9LHRoaXMuc2l6ZT0wfXZhciBycz1lcztmdW5jdGlvbiBucyhoKXt2YXIgZT10aGlzLmhhcyhoKSYmZGVsZXRlIHRoaXMuX19kYXRhX19baF07cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX12YXIgaXM9bnMsc3M9eGUsYXM9Il9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18iLG9zPU9iamVjdC5wcm90b3R5cGUsbHM9b3MuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gZnMoaCl7dmFyIGU9dGhpcy5fX2RhdGFfXztpZihzcyl7dmFyIHQ9ZVtoXTtyZXR1cm4gdD09PWFzP3ZvaWQgMDp0fXJldHVybiBscy5jYWxsKGUsaCk/ZVtoXTp2b2lkIDB9dmFyIHVzPWZzLGNzPXhlLGhzPU9iamVjdC5wcm90b3R5cGUsZHM9aHMuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gZ3MoaCl7dmFyIGU9dGhpcy5fX2RhdGFfXztyZXR1cm4gY3M/ZVtoXSE9PXZvaWQgMDpkcy5jYWxsKGUsaCl9dmFyIG1zPWdzLHZzPXhlLHlzPSJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fIjtmdW5jdGlvbiBwcyhoLGUpe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXMoaCk/MDoxLHRbaF09dnMmJmU9PT12b2lkIDA/eXM6ZSx0aGlzfXZhciB4cz1wcyxNcz1ycyxPcz1pcyxFcz11cyxUcz1tcyxQcz14cztmdW5jdGlvbiBlZShoKXt2YXIgZT0tMSx0PWg9PW51bGw/MDpoLmxlbmd0aDtmb3IodGhpcy5jbGVhcigpOysrZTx0Oyl7dmFyIHI9aFtlXTt0aGlzLnNldChyWzBdLHJbMV0pfX1lZS5wcm90b3R5cGUuY2xlYXI9TXMsZWUucHJvdG90eXBlLmRlbGV0ZT1PcyxlZS5wcm90b3R5cGUuZ2V0PUVzLGVlLnByb3RvdHlwZS5oYXM9VHMsZWUucHJvdG90eXBlLnNldD1Qczt2YXIgQXM9ZWUsbXI9QXMsU3M9eWUsYnM9SWU7ZnVuY3Rpb24gUnMoKXt0aGlzLnNpemU9MCx0aGlzLl9fZGF0YV9fPXtoYXNoOm5ldyBtcixtYXA6bmV3KGJzfHxTcyksc3RyaW5nOm5ldyBtcn19dmFyIENzPVJzO2Z1bmN0aW9uIExzKGgpe3ZhciBlPXR5cGVvZiBoO3JldHVybiBlPT0ic3RyaW5nInx8ZT09Im51bWJlciJ8fGU9PSJzeW1ib2wifHxlPT0iYm9vbGVhbiI/aCE9PSJfX3Byb3RvX18iOmg9PT1udWxsfXZhciBEcz1McyxJcz1EcztmdW5jdGlvbiBOcyhoLGUpe3ZhciB0PWguX19kYXRhX187cmV0dXJuIElzKGUpP3RbdHlwZW9mIGU9PSJzdHJpbmciPyJzdHJpbmciOiJoYXNoIl06dC5tYXB9dmFyIE1lPU5zLGpzPU1lO2Z1bmN0aW9uIEJzKGgpe3ZhciBlPWpzKHRoaXMsaCkuZGVsZXRlKGgpO3JldHVybiB0aGlzLnNpemUtPWU/MTowLGV9dmFyIFVzPUJzLEZzPU1lO2Z1bmN0aW9uIFdzKGgpe3JldHVybiBGcyh0aGlzLGgpLmdldChoKX12YXIgJHM9V3MsenM9TWU7ZnVuY3Rpb24gd3MoaCl7cmV0dXJuIHpzKHRoaXMsaCkuaGFzKGgpfXZhciBHcz13cyxLcz1NZTtmdW5jdGlvbiBIcyhoLGUpe3ZhciB0PUtzKHRoaXMsaCkscj10LnNpemU7cmV0dXJuIHQuc2V0KGgsZSksdGhpcy5zaXplKz10LnNpemU9PXI/MDoxLHRoaXN9dmFyIFZzPUhzLFlzPUNzLFhzPVVzLEpzPSRzLFFzPUdzLFpzPVZzO2Z1bmN0aW9uIHJlKGgpe3ZhciBlPS0xLHQ9aD09bnVsbD8wOmgubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPHQ7KXt2YXIgcj1oW2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fXJlLnByb3RvdHlwZS5jbGVhcj1ZcyxyZS5wcm90b3R5cGUuZGVsZXRlPVhzLHJlLnByb3RvdHlwZS5nZXQ9SnMscmUucHJvdG90eXBlLmhhcz1RcyxyZS5wcm90b3R5cGUuc2V0PVpzO3ZhciBxcz1yZSxrcz15ZSxfcz1JZSx0YT1xcyxlYT0yMDA7ZnVuY3Rpb24gcmEoaCxlKXt2YXIgdD10aGlzLl9fZGF0YV9fO2lmKHQgaW5zdGFuY2VvZiBrcyl7dmFyIHI9dC5fX2RhdGFfXztpZighX3N8fHIubGVuZ3RoPGVhLTEpcmV0dXJuIHIucHVzaChbaCxlXSksdGhpcy5zaXplPSsrdC5zaXplLHRoaXM7dD10aGlzLl9fZGF0YV9fPW5ldyB0YShyKX1yZXR1cm4gdC5zZXQoaCxlKSx0aGlzLnNpemU9dC5zaXplLHRoaXN9dmFyIG5hPXJhLGlhPXllLHNhPUhuLGFhPVluLG9hPUpuLGxhPVpuLGZhPW5hO2Z1bmN0aW9uIG5lKGgpe3ZhciBlPXRoaXMuX19kYXRhX189bmV3IGlhKGgpO3RoaXMuc2l6ZT1lLnNpemV9bmUucHJvdG90eXBlLmNsZWFyPXNhLG5lLnByb3RvdHlwZS5kZWxldGU9YWEsbmUucHJvdG90eXBlLmdldD1vYSxuZS5wcm90b3R5cGUuaGFzPWxhLG5lLnByb3RvdHlwZS5zZXQ9ZmE7dmFyIHVhPW5lO2Z1bmN0aW9uIGNhKGgsZSl7Zm9yKHZhciB0PS0xLHI9aD09bnVsbD8wOmgubGVuZ3RoOysrdDxyJiZlKGhbdF0sdCxoKSE9PSExOyk7cmV0dXJuIGh9dmFyIGhhPWNhLGRhPVh0LGdhPWZ1bmN0aW9uKCl7dHJ5e3ZhciBoPWRhKE9iamVjdCwiZGVmaW5lUHJvcGVydHkiKTtyZXR1cm4gaCh7fSwiIix7fSksaH1jYXRjaHt9fSgpLG1hPWdhLHZyPW1hO2Z1bmN0aW9uIHZhKGgsZSx0KXtlPT0iX19wcm90b19fIiYmdnI/dnIoaCxlLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0LHdyaXRhYmxlOiEwfSk6aFtlXT10fXZhciB5cj12YSx5YT15cixwYT1zcix4YT1PYmplY3QucHJvdG90eXBlLE1hPXhhLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIE9hKGgsZSx0KXt2YXIgcj1oW2VdOyghKE1hLmNhbGwoaCxlKSYmcGEocix0KSl8fHQ9PT12b2lkIDAmJiEoZSBpbiBoKSkmJnlhKGgsZSx0KX12YXIgcHI9T2EsRWE9cHIsVGE9eXI7ZnVuY3Rpb24gUGEoaCxlLHQscil7dmFyIHM9IXQ7dHx8KHQ9e30pO2Zvcih2YXIgbT0tMSx5PWUubGVuZ3RoOysrbTx5Oyl7dmFyIGM9ZVttXSxsPXI/cih0W2NdLGhbY10sYyx0LGgpOnZvaWQgMDtsPT09dm9pZCAwJiYobD1oW2NdKSxzP1RhKHQsYyxsKTpFYSh0LGMsbCl9cmV0dXJuIHR9dmFyIE9lPVBhO2Z1bmN0aW9uIEFhKGgsZSl7Zm9yKHZhciB0PS0xLHI9QXJyYXkoaCk7Kyt0PGg7KXJbdF09ZSh0KTtyZXR1cm4gcn12YXIgU2E9QWE7ZnVuY3Rpb24gYmEoaCl7cmV0dXJuIGghPW51bGwmJnR5cGVvZiBoPT0ib2JqZWN0In12YXIgb2U9YmEsUmE9cGUsQ2E9b2UsTGE9IltvYmplY3QgQXJndW1lbnRzXSI7ZnVuY3Rpb24gRGEoaCl7cmV0dXJuIENhKGgpJiZSYShoKT09TGF9dmFyIElhPURhLHhyPUlhLE5hPW9lLE1yPU9iamVjdC5wcm90b3R5cGUsamE9TXIuaGFzT3duUHJvcGVydHksQmE9TXIucHJvcGVydHlJc0VudW1lcmFibGUsVWE9eHIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT94cjpmdW5jdGlvbihoKXtyZXR1cm4gTmEoaCkmJmphLmNhbGwoaCwiY2FsbGVlIikmJiFCYS5jYWxsKGgsImNhbGxlZSIpfSxGYT1VYSxXYT1BcnJheS5pc0FycmF5LE5lPVdhLEVlPXtleHBvcnRzOnt9fTtmdW5jdGlvbiAkYSgpe3JldHVybiExfXZhciB6YT0kYTtFZS5leHBvcnRzLGZ1bmN0aW9uKGgsZSl7dmFyIHQ9S3Qscj16YSxzPWUmJiFlLm5vZGVUeXBlJiZlLG09cyYmITAmJmgmJiFoLm5vZGVUeXBlJiZoLHk9bSYmbS5leHBvcnRzPT09cyxjPXk/dC5CdWZmZXI6dm9pZCAwLGw9Yz9jLmlzQnVmZmVyOnZvaWQgMCx1PWx8fHI7aC5leHBvcnRzPXV9KEVlLEVlLmV4cG9ydHMpO3ZhciBPcj1FZS5leHBvcnRzLHdhPTkwMDcxOTkyNTQ3NDA5OTEsR2E9L14oPzowfFsxLTldXGQqKSQvO2Z1bmN0aW9uIEthKGgsZSl7dmFyIHQ9dHlwZW9mIGg7cmV0dXJuIGU9ZT8/d2EsISFlJiYodD09Im51bWJlciJ8fHQhPSJzeW1ib2wiJiZHYS50ZXN0KGgpKSYmaD4tMSYmaCUxPT0wJiZoPGV9dmFyIEhhPUthLFZhPTkwMDcxOTkyNTQ3NDA5OTE7ZnVuY3Rpb24gWWEoaCl7cmV0dXJuIHR5cGVvZiBoPT0ibnVtYmVyIiYmaD4tMSYmaCUxPT0wJiZoPD1WYX12YXIgRXI9WWEsWGE9cGUsSmE9RXIsUWE9b2UsWmE9IltvYmplY3QgQXJndW1lbnRzXSIscWE9IltvYmplY3QgQXJyYXldIixrYT0iW29iamVjdCBCb29sZWFuXSIsX2E9IltvYmplY3QgRGF0ZV0iLHRvPSJbb2JqZWN0IEVycm9yXSIsZW89IltvYmplY3QgRnVuY3Rpb25dIixybz0iW29iamVjdCBNYXBdIixubz0iW29iamVjdCBOdW1iZXJdIixpbz0iW29iamVjdCBPYmplY3RdIixzbz0iW29iamVjdCBSZWdFeHBdIixhbz0iW29iamVjdCBTZXRdIixvbz0iW29iamVjdCBTdHJpbmddIixsbz0iW29iamVjdCBXZWFrTWFwXSIsZm89IltvYmplY3QgQXJyYXlCdWZmZXJdIix1bz0iW29iamVjdCBEYXRhVmlld10iLGNvPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLGhvPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLGdvPSJbb2JqZWN0IEludDhBcnJheV0iLG1vPSJbb2JqZWN0IEludDE2QXJyYXldIix2bz0iW29iamVjdCBJbnQzMkFycmF5XSIseW89IltvYmplY3QgVWludDhBcnJheV0iLHBvPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIseG89IltvYmplY3QgVWludDE2QXJyYXldIixNbz0iW29iamVjdCBVaW50MzJBcnJheV0iLFJ0PXt9O1J0W2NvXT1SdFtob109UnRbZ29dPVJ0W21vXT1SdFt2b109UnRbeW9dPVJ0W3BvXT1SdFt4b109UnRbTW9dPSEwLFJ0W1phXT1SdFtxYV09UnRbZm9dPVJ0W2thXT1SdFt1b109UnRbX2FdPVJ0W3RvXT1SdFtlb109UnRbcm9dPVJ0W25vXT1SdFtpb109UnRbc29dPVJ0W2FvXT1SdFtvb109UnRbbG9dPSExO2Z1bmN0aW9uIE9vKGgpe3JldHVybiBRYShoKSYmSmEoaC5sZW5ndGgpJiYhIVJ0W1hhKGgpXX12YXIgRW89T287ZnVuY3Rpb24gVG8oaCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBoKGUpfX12YXIgamU9VG8sVGU9e2V4cG9ydHM6e319O1RlLmV4cG9ydHMsZnVuY3Rpb24oaCxlKXt2YXIgdD1hcixyPWUmJiFlLm5vZGVUeXBlJiZlLHM9ciYmITAmJmgmJiFoLm5vZGVUeXBlJiZoLG09cyYmcy5leHBvcnRzPT09cix5PW0mJnQucHJvY2VzcyxjPWZ1bmN0aW9uKCl7dHJ5e3ZhciBsPXMmJnMucmVxdWlyZSYmcy5yZXF1aXJlKCJ1dGlsIikudHlwZXM7cmV0dXJuIGx8fHkmJnkuYmluZGluZyYmeS5iaW5kaW5nKCJ1dGlsIil9Y2F0Y2h7fX0oKTtoLmV4cG9ydHM9Y30oVGUsVGUuZXhwb3J0cyk7dmFyIEJlPVRlLmV4cG9ydHMsUG89RW8sQW89amUsVHI9QmUsUHI9VHImJlRyLmlzVHlwZWRBcnJheSxTbz1Qcj9BbyhQcik6UG8sYm89U28sUm89U2EsQ289RmEsTG89TmUsRG89T3IsSW89SGEsTm89Ym8sam89T2JqZWN0LnByb3RvdHlwZSxCbz1qby5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBVbyhoLGUpe3ZhciB0PUxvKGgpLHI9IXQmJkNvKGgpLHM9IXQmJiFyJiZEbyhoKSxtPSF0JiYhciYmIXMmJk5vKGgpLHk9dHx8cnx8c3x8bSxjPXk/Um8oaC5sZW5ndGgsU3RyaW5nKTpbXSxsPWMubGVuZ3RoO2Zvcih2YXIgdSBpbiBoKShlfHxCby5jYWxsKGgsdSkpJiYhKHkmJih1PT0ibGVuZ3RoInx8cyYmKHU9PSJvZmZzZXQifHx1PT0icGFyZW50Iil8fG0mJih1PT0iYnVmZmVyInx8dT09ImJ5dGVMZW5ndGgifHx1PT0iYnl0ZU9mZnNldCIpfHxJbyh1LGwpKSkmJmMucHVzaCh1KTtyZXR1cm4gY312YXIgQXI9VW8sRm89T2JqZWN0LnByb3RvdHlwZTtmdW5jdGlvbiBXbyhoKXt2YXIgZT1oJiZoLmNvbnN0cnVjdG9yLHQ9dHlwZW9mIGU9PSJmdW5jdGlvbiImJmUucHJvdG90eXBlfHxGbztyZXR1cm4gaD09PXR9dmFyIFVlPVdvO2Z1bmN0aW9uICRvKGgsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBoKGUodCkpfX12YXIgU3I9JG8sem89U3Isd289em8oT2JqZWN0LmtleXMsT2JqZWN0KSxHbz13byxLbz1VZSxIbz1HbyxWbz1PYmplY3QucHJvdG90eXBlLFlvPVZvLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIFhvKGgpe2lmKCFLbyhoKSlyZXR1cm4gSG8oaCk7dmFyIGU9W107Zm9yKHZhciB0IGluIE9iamVjdChoKSlZby5jYWxsKGgsdCkmJnQhPSJjb25zdHJ1Y3RvciImJmUucHVzaCh0KTtyZXR1cm4gZX12YXIgSm89WG8sUW89Y3IsWm89RXI7ZnVuY3Rpb24gcW8oaCl7cmV0dXJuIGghPW51bGwmJlpvKGgubGVuZ3RoKSYmIVFvKGgpfXZhciBicj1xbyxrbz1Bcixfbz1Kbyx0bD1icjtmdW5jdGlvbiBlbChoKXtyZXR1cm4gdGwoaCk/a28oaCk6X28oaCl9dmFyIEZlPWVsLHJsPU9lLG5sPUZlO2Z1bmN0aW9uIGlsKGgsZSl7cmV0dXJuIGgmJnJsKGUsbmwoZSksaCl9dmFyIHNsPWlsO2Z1bmN0aW9uIGFsKGgpe3ZhciBlPVtdO2lmKGghPW51bGwpZm9yKHZhciB0IGluIE9iamVjdChoKSllLnB1c2godCk7cmV0dXJuIGV9dmFyIG9sPWFsLGxsPWFlLGZsPVVlLHVsPW9sLGNsPU9iamVjdC5wcm90b3R5cGUsaGw9Y2wuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gZGwoaCl7aWYoIWxsKGgpKXJldHVybiB1bChoKTt2YXIgZT1mbChoKSx0PVtdO2Zvcih2YXIgciBpbiBoKXI9PSJjb25zdHJ1Y3RvciImJihlfHwhaGwuY2FsbChoLHIpKXx8dC5wdXNoKHIpO3JldHVybiB0fXZhciBnbD1kbCxtbD1Bcix2bD1nbCx5bD1icjtmdW5jdGlvbiBwbChoKXtyZXR1cm4geWwoaCk/bWwoaCwhMCk6dmwoaCl9dmFyIFdlPXBsLHhsPU9lLE1sPVdlO2Z1bmN0aW9uIE9sKGgsZSl7cmV0dXJuIGgmJnhsKGUsTWwoZSksaCl9dmFyIEVsPU9sLFBlPXtleHBvcnRzOnt9fTtQZS5leHBvcnRzLGZ1bmN0aW9uKGgsZSl7dmFyIHQ9S3Qscj1lJiYhZS5ub2RlVHlwZSYmZSxzPXImJiEwJiZoJiYhaC5ub2RlVHlwZSYmaCxtPXMmJnMuZXhwb3J0cz09PXIseT1tP3QuQnVmZmVyOnZvaWQgMCxjPXk/eS5hbGxvY1Vuc2FmZTp2b2lkIDA7ZnVuY3Rpb24gbCh1LE0pe2lmKE0pcmV0dXJuIHUuc2xpY2UoKTt2YXIgZj11Lmxlbmd0aCx2PWM/YyhmKTpuZXcgdS5jb25zdHJ1Y3RvcihmKTtyZXR1cm4gdS5jb3B5KHYpLHZ9aC5leHBvcnRzPWx9KFBlLFBlLmV4cG9ydHMpO3ZhciBUbD1QZS5leHBvcnRzO2Z1bmN0aW9uIFBsKGgsZSl7dmFyIHQ9LTEscj1oLmxlbmd0aDtmb3IoZXx8KGU9QXJyYXkocikpOysrdDxyOyllW3RdPWhbdF07cmV0dXJuIGV9dmFyIEFsPVBsO2Z1bmN0aW9uIFNsKGgsZSl7Zm9yKHZhciB0PS0xLHI9aD09bnVsbD8wOmgubGVuZ3RoLHM9MCxtPVtdOysrdDxyOyl7dmFyIHk9aFt0XTtlKHksdCxoKSYmKG1bcysrXT15KX1yZXR1cm4gbX12YXIgYmw9U2w7ZnVuY3Rpb24gUmwoKXtyZXR1cm5bXX12YXIgUnI9UmwsQ2w9YmwsTGw9UnIsRGw9T2JqZWN0LnByb3RvdHlwZSxJbD1EbC5wcm9wZXJ0eUlzRW51bWVyYWJsZSxDcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLE5sPUNyP2Z1bmN0aW9uKGgpe3JldHVybiBoPT1udWxsP1tdOihoPU9iamVjdChoKSxDbChDcihoKSxmdW5jdGlvbihlKXtyZXR1cm4gSWwuY2FsbChoLGUpfSkpfTpMbCwkZT1ObCxqbD1PZSxCbD0kZTtmdW5jdGlvbiBVbChoLGUpe3JldHVybiBqbChoLEJsKGgpLGUpfXZhciBGbD1VbDtmdW5jdGlvbiBXbChoLGUpe2Zvcih2YXIgdD0tMSxyPWUubGVuZ3RoLHM9aC5sZW5ndGg7Kyt0PHI7KWhbcyt0XT1lW3RdO3JldHVybiBofXZhciBMcj1XbCwkbD1Tcix6bD0kbChPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KSxEcj16bCx3bD1McixHbD1EcixLbD0kZSxIbD1ScixWbD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFlsPVZsP2Z1bmN0aW9uKGgpe2Zvcih2YXIgZT1bXTtoOyl3bChlLEtsKGgpKSxoPUdsKGgpO3JldHVybiBlfTpIbCxJcj1ZbCxYbD1PZSxKbD1JcjtmdW5jdGlvbiBRbChoLGUpe3JldHVybiBYbChoLEpsKGgpLGUpfXZhciBabD1RbCxxbD1McixrbD1OZTtmdW5jdGlvbiBfbChoLGUsdCl7dmFyIHI9ZShoKTtyZXR1cm4ga2woaCk/cjpxbChyLHQoaCkpfXZhciBOcj1fbCx0Zj1OcixlZj0kZSxyZj1GZTtmdW5jdGlvbiBuZihoKXtyZXR1cm4gdGYoaCxyZixlZil9dmFyIHNmPW5mLGFmPU5yLG9mPUlyLGxmPVdlO2Z1bmN0aW9uIGZmKGgpe3JldHVybiBhZihoLGxmLG9mKX12YXIgdWY9ZmYsY2Y9WHQsaGY9S3QsZGY9Y2YoaGYsIkRhdGFWaWV3IiksZ2Y9ZGYsbWY9WHQsdmY9S3QseWY9bWYodmYsIlByb21pc2UiKSxwZj15Zix4Zj1YdCxNZj1LdCxPZj14ZihNZiwiU2V0IiksRWY9T2YsVGY9WHQsUGY9S3QsQWY9VGYoUGYsIldlYWtNYXAiKSxTZj1BZix6ZT1nZix3ZT1JZSxHZT1wZixLZT1FZixIZT1TZixqcj1wZSxpZT1kcixCcj0iW29iamVjdCBNYXBdIixiZj0iW29iamVjdCBPYmplY3RdIixVcj0iW29iamVjdCBQcm9taXNlXSIsRnI9IltvYmplY3QgU2V0XSIsV3I9IltvYmplY3QgV2Vha01hcF0iLCRyPSJbb2JqZWN0IERhdGFWaWV3XSIsUmY9aWUoemUpLENmPWllKHdlKSxMZj1pZShHZSksRGY9aWUoS2UpLElmPWllKEhlKSxKdD1qcjsoemUmJkp0KG5ldyB6ZShuZXcgQXJyYXlCdWZmZXIoMSkpKSE9JHJ8fHdlJiZKdChuZXcgd2UpIT1Ccnx8R2UmJkp0KEdlLnJlc29sdmUoKSkhPVVyfHxLZSYmSnQobmV3IEtlKSE9RnJ8fEhlJiZKdChuZXcgSGUpIT1XcikmJihKdD1mdW5jdGlvbihoKXt2YXIgZT1qcihoKSx0PWU9PWJmP2guY29uc3RydWN0b3I6dm9pZCAwLHI9dD9pZSh0KToiIjtpZihyKXN3aXRjaChyKXtjYXNlIFJmOnJldHVybiAkcjtjYXNlIENmOnJldHVybiBCcjtjYXNlIExmOnJldHVybiBVcjtjYXNlIERmOnJldHVybiBGcjtjYXNlIElmOnJldHVybiBXcn1yZXR1cm4gZX0pO3ZhciBWZT1KdCxOZj1PYmplY3QucHJvdG90eXBlLGpmPU5mLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIEJmKGgpe3ZhciBlPWgubGVuZ3RoLHQ9bmV3IGguY29uc3RydWN0b3IoZSk7cmV0dXJuIGUmJnR5cGVvZiBoWzBdPT0ic3RyaW5nIiYmamYuY2FsbChoLCJpbmRleCIpJiYodC5pbmRleD1oLmluZGV4LHQuaW5wdXQ9aC5pbnB1dCksdH12YXIgVWY9QmYsRmY9S3QsV2Y9RmYuVWludDhBcnJheSwkZj1XZix6cj0kZjtmdW5jdGlvbiB6ZihoKXt2YXIgZT1uZXcgaC5jb25zdHJ1Y3RvcihoLmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgenIoZSkuc2V0KG5ldyB6cihoKSksZX12YXIgWWU9emYsd2Y9WWU7ZnVuY3Rpb24gR2YoaCxlKXt2YXIgdD1lP3dmKGguYnVmZmVyKTpoLmJ1ZmZlcjtyZXR1cm4gbmV3IGguY29uc3RydWN0b3IodCxoLmJ5dGVPZmZzZXQsaC5ieXRlTGVuZ3RoKX12YXIgS2Y9R2YsSGY9L1x3KiQvO2Z1bmN0aW9uIFZmKGgpe3ZhciBlPW5ldyBoLmNvbnN0cnVjdG9yKGguc291cmNlLEhmLmV4ZWMoaCkpO3JldHVybiBlLmxhc3RJbmRleD1oLmxhc3RJbmRleCxlfXZhciBZZj1WZix3cj1MZSxHcj13cj93ci5wcm90b3R5cGU6dm9pZCAwLEtyPUdyP0dyLnZhbHVlT2Y6dm9pZCAwO2Z1bmN0aW9uIFhmKGgpe3JldHVybiBLcj9PYmplY3QoS3IuY2FsbChoKSk6e319dmFyIEpmPVhmLFFmPVllO2Z1bmN0aW9uIFpmKGgsZSl7dmFyIHQ9ZT9RZihoLmJ1ZmZlcik6aC5idWZmZXI7cmV0dXJuIG5ldyBoLmNvbnN0cnVjdG9yKHQsaC5ieXRlT2Zmc2V0LGgubGVuZ3RoKX12YXIgcWY9WmYsa2Y9WWUsX2Y9S2YsdHU9WWYsZXU9SmYscnU9cWYsbnU9IltvYmplY3QgQm9vbGVhbl0iLGl1PSJbb2JqZWN0IERhdGVdIixzdT0iW29iamVjdCBNYXBdIixhdT0iW29iamVjdCBOdW1iZXJdIixvdT0iW29iamVjdCBSZWdFeHBdIixsdT0iW29iamVjdCBTZXRdIixmdT0iW29iamVjdCBTdHJpbmddIix1dT0iW29iamVjdCBTeW1ib2xdIixjdT0iW29iamVjdCBBcnJheUJ1ZmZlcl0iLGh1PSJbb2JqZWN0IERhdGFWaWV3XSIsZHU9IltvYmplY3QgRmxvYXQzMkFycmF5XSIsZ3U9IltvYmplY3QgRmxvYXQ2NEFycmF5XSIsbXU9IltvYmplY3QgSW50OEFycmF5XSIsdnU9IltvYmplY3QgSW50MTZBcnJheV0iLHl1PSJbb2JqZWN0IEludDMyQXJyYXldIixwdT0iW29iamVjdCBVaW50OEFycmF5XSIseHU9IltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIixNdT0iW29iamVjdCBVaW50MTZBcnJheV0iLE91PSJbb2JqZWN0IFVpbnQzMkFycmF5XSI7ZnVuY3Rpb24gRXUoaCxlLHQpe3ZhciByPWguY29uc3RydWN0b3I7c3dpdGNoKGUpe2Nhc2UgY3U6cmV0dXJuIGtmKGgpO2Nhc2UgbnU6Y2FzZSBpdTpyZXR1cm4gbmV3IHIoK2gpO2Nhc2UgaHU6cmV0dXJuIF9mKGgsdCk7Y2FzZSBkdTpjYXNlIGd1OmNhc2UgbXU6Y2FzZSB2dTpjYXNlIHl1OmNhc2UgcHU6Y2FzZSB4dTpjYXNlIE11OmNhc2UgT3U6cmV0dXJuIHJ1KGgsdCk7Y2FzZSBzdTpyZXR1cm4gbmV3IHI7Y2FzZSBhdTpjYXNlIGZ1OnJldHVybiBuZXcgcihoKTtjYXNlIG91OnJldHVybiB0dShoKTtjYXNlIGx1OnJldHVybiBuZXcgcjtjYXNlIHV1OnJldHVybiBldShoKX19dmFyIFR1PUV1LFB1PWFlLEhyPU9iamVjdC5jcmVhdGUsQXU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBoKCl7fXJldHVybiBmdW5jdGlvbihlKXtpZighUHUoZSkpcmV0dXJue307aWYoSHIpcmV0dXJuIEhyKGUpO2gucHJvdG90eXBlPWU7dmFyIHQ9bmV3IGg7cmV0dXJuIGgucHJvdG90eXBlPXZvaWQgMCx0fX0oKSxTdT1BdSxidT1TdSxSdT1EcixDdT1VZTtmdW5jdGlvbiBMdShoKXtyZXR1cm4gdHlwZW9mIGguY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJiFDdShoKT9idShSdShoKSk6e319dmFyIER1PUx1LEl1PVZlLE51PW9lLGp1PSJbb2JqZWN0IE1hcF0iO2Z1bmN0aW9uIEJ1KGgpe3JldHVybiBOdShoKSYmSXUoaCk9PWp1fXZhciBVdT1CdSxGdT1VdSxXdT1qZSxWcj1CZSxZcj1WciYmVnIuaXNNYXAsJHU9WXI/V3UoWXIpOkZ1LHp1PSR1LHd1PVZlLEd1PW9lLEt1PSJbb2JqZWN0IFNldF0iO2Z1bmN0aW9uIEh1KGgpe3JldHVybiBHdShoKSYmd3UoaCk9PUt1fXZhciBWdT1IdSxZdT1WdSxYdT1qZSxYcj1CZSxKcj1YciYmWHIuaXNTZXQsSnU9SnI/WHUoSnIpOll1LFF1PUp1LFp1PXVhLHF1PWhhLGt1PXByLF91PXNsLHRjPUVsLGVjPVRsLHJjPUFsLG5jPUZsLGljPVpsLHNjPXNmLGFjPXVmLG9jPVZlLGxjPVVmLGZjPVR1LHVjPUR1LGNjPU5lLGhjPU9yLGRjPXp1LGdjPWFlLG1jPVF1LHZjPUZlLHljPVdlLHBjPTEseGM9MixNYz00LFFyPSJbb2JqZWN0IEFyZ3VtZW50c10iLE9jPSJbb2JqZWN0IEFycmF5XSIsRWM9IltvYmplY3QgQm9vbGVhbl0iLFRjPSJbb2JqZWN0IERhdGVdIixQYz0iW29iamVjdCBFcnJvcl0iLFpyPSJbb2JqZWN0IEZ1bmN0aW9uXSIsQWM9IltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dIixTYz0iW29iamVjdCBNYXBdIixiYz0iW29iamVjdCBOdW1iZXJdIixxcj0iW29iamVjdCBPYmplY3RdIixSYz0iW29iamVjdCBSZWdFeHBdIixDYz0iW29iamVjdCBTZXRdIixMYz0iW29iamVjdCBTdHJpbmddIixEYz0iW29iamVjdCBTeW1ib2xdIixJYz0iW29iamVjdCBXZWFrTWFwXSIsTmM9IltvYmplY3QgQXJyYXlCdWZmZXJdIixqYz0iW29iamVjdCBEYXRhVmlld10iLEJjPSJbb2JqZWN0IEZsb2F0MzJBcnJheV0iLFVjPSJbb2JqZWN0IEZsb2F0NjRBcnJheV0iLEZjPSJbb2JqZWN0IEludDhBcnJheV0iLFdjPSJbb2JqZWN0IEludDE2QXJyYXldIiwkYz0iW29iamVjdCBJbnQzMkFycmF5XSIsemM9IltvYmplY3QgVWludDhBcnJheV0iLHdjPSJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSIsR2M9IltvYmplY3QgVWludDE2QXJyYXldIixLYz0iW29iamVjdCBVaW50MzJBcnJheV0iLFN0PXt9O1N0W1FyXT1TdFtPY109U3RbTmNdPVN0W2pjXT1TdFtFY109U3RbVGNdPVN0W0JjXT1TdFtVY109U3RbRmNdPVN0W1djXT1TdFskY109U3RbU2NdPVN0W2JjXT1TdFtxcl09U3RbUmNdPVN0W0NjXT1TdFtMY109U3RbRGNdPVN0W3pjXT1TdFt3Y109U3RbR2NdPVN0W0tjXT0hMCxTdFtQY109U3RbWnJdPVN0W0ljXT0hMTtmdW5jdGlvbiBBZShoLGUsdCxyLHMsbSl7dmFyIHksYz1lJnBjLGw9ZSZ4Yyx1PWUmTWM7aWYodCYmKHk9cz90KGgscixzLG0pOnQoaCkpLHkhPT12b2lkIDApcmV0dXJuIHk7aWYoIWdjKGgpKXJldHVybiBoO3ZhciBNPWNjKGgpO2lmKE0pe2lmKHk9bGMoaCksIWMpcmV0dXJuIHJjKGgseSl9ZWxzZXt2YXIgZj1vYyhoKSx2PWY9PVpyfHxmPT1BYztpZihoYyhoKSlyZXR1cm4gZWMoaCxjKTtpZihmPT1xcnx8Zj09UXJ8fHYmJiFzKXtpZih5PWx8fHY/e306dWMoaCksIWMpcmV0dXJuIGw/aWMoaCx0Yyh5LGgpKTpuYyhoLF91KHksaCkpfWVsc2V7aWYoIVN0W2ZdKXJldHVybiBzP2g6e307eT1mYyhoLGYsYyl9fW18fChtPW5ldyBadSk7dmFyIHg9bS5nZXQoaCk7aWYoeClyZXR1cm4geDttLnNldChoLHkpLG1jKGgpP2guZm9yRWFjaChmdW5jdGlvbihnKXt5LmFkZChBZShnLGUsdCxnLGgsbSkpfSk6ZGMoaCkmJmguZm9yRWFjaChmdW5jdGlvbihnLHApe3kuc2V0KHAsQWUoZyxlLHQscCxoLG0pKX0pO3ZhciBSPXU/bD9hYzpzYzpsP3ljOnZjLE89TT92b2lkIDA6UihoKTtyZXR1cm4gcXUoT3x8aCxmdW5jdGlvbihnLHApe08mJihwPWcsZz1oW3BdKSxrdSh5LHAsQWUoZyxlLHQscCxoLG0pKX0pLHl9dmFyIEhjPUFlLFZjPUhjLFljPTEsWGM9NDtmdW5jdGlvbiBKYyhoKXtyZXR1cm4gVmMoaCxZY3xYYyl9dmFyIFFjPUpjLGtyPXJyKFFjKTtjb25zdCBsZT1jbGFzcyBsZSBleHRlbmRzIG1ue2NvbnN0cnVjdG9yKCl7c3VwZXIoKTtWdCh0aGlzLCJjYW1lcmFPcHQiKTtWdCh0aGlzLCJkcHIiKTtWdCh0aGlzLCJzY2VuZSIpO1Z0KHRoaXMsImRyYXdMYXllciIpO1Z0KHRoaXMsImZ1bGxMYXllciIpO1Z0KHRoaXMsInNuYXBzaG90RnVsbExheWVyIik7VnQodGhpcywibG9jYWxXb3JrIik7dGhpcy5yZWdpc3RlcigpfWluaXQodCxyLHMpe3RoaXMuZHByPXQsdGhpcy5zY2VuZT10aGlzLmNyZWF0ZVNjZW5lKHIpLHRoaXMuZHJhd0xheWVyPXRoaXMuY3JlYXRlTGF5ZXIodGhpcy5zY2VuZSx7Li4ucyx3aWR0aDpyLndpZHRoLGhlaWdodDpyLmhlaWdodH0pLHRoaXMuc25hcHNob3RGdWxsTGF5ZXI9dGhpcy5jcmVhdGVMYXllcih0aGlzLnNjZW5lLHsuLi5zLHdpZHRoOnIud2lkdGgsaGVpZ2h0OnIuaGVpZ2h0LGJ1ZmZlclNpemU6NWUzfSksdGhpcy5sb2NhbFdvcms9bmV3IHluKHRoaXMuY3VyTm9kZU1hcCx0aGlzLmRyYXdMYXllcix0aGlzLnBvc3QuYmluZCh0aGlzKSl9Z2V0T2Zmc2NyZWVuKHQpe3ZhciByO3JldHVybihyPSh0JiZ0aGlzLnNuYXBzaG90RnVsbExheWVyfHx0aGlzLmRyYXdMYXllcikucGFyZW50KT09bnVsbD92b2lkIDA6ci5jYW52YXN9cmVnaXN0ZXIoKXt0aGlzLm9uKGFzeW5jIHQ9Pntmb3IoY29uc3QgciBvZiB0KXtjb25zdHt3b3JrU3RhdGU6cyxkYXRhVHlwZTptLG1zZ1R5cGU6eSx3b3JrSWQ6Yyx0b29sc1R5cGU6bCxvcHQ6dX09cjtzd2l0Y2goeSl7Y2FzZSBFdC5TbmFwc2hvdDphd2FpdCB0aGlzLmdldFNuYXBzaG90KHIpO2JyZWFrO2Nhc2UgRXQuVXBkYXRlVG9vbHM6bCYmdSYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOmwsdG9vbHNPcHQ6dX0pO2JyZWFrO2Nhc2UgRXQuQ3JlYXRlV29yazpjJiZ1JiYoIXRoaXMubG9jYWxXb3JrLmdldFRtcFdvcmtTaGFwZU5vZGUoKSYmbCYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOmwsdG9vbHNPcHQ6dX0pLHRoaXMuc2V0V29ya09wdCh7d29ya0lkOmMsdG9vbHNPcHQ6dX0pKTticmVhaztjYXNlIEV0LkRyYXdXb3JrOnM9PT1RdC5Eb25lJiZtPT09Q3QuTG9jYWw/dGhpcy5jb25zdW1lRHJhd0FsbChtLHIpOnRoaXMuY29uc3VtZURyYXcobSxyKTticmVha319fSl9c2V0VG9vbHNPcHQodCl7dGhpcy5sb2NhbFdvcmsuc2V0VG9vbHNPcHQodCl9c2V0V29ya09wdCh0KXtjb25zdHt3b3JrSWQ6cix0b29sc09wdDpzfT10O3ImJnMmJnRoaXMubG9jYWxXb3JrLnNldFdvcmtPcHRpb25zKHIscyl9Y2xlYXJBbGwoKXt0aGlzLmRyYXdMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMubG9jYWxXb3JrLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCl9c2V0Q2FtZXJhT3B0KHQscil7dGhpcy5jYW1lcmFPcHQ9dDtjb25zdHtzY2FsZTpzLGNlbnRlclg6bSxjZW50ZXJZOnksd2lkdGg6YyxoZWlnaHQ6bH09dDsoYyE9PXRoaXMuc2NlbmUud2lkdGh8fGwhPT10aGlzLnNjZW5lLmhlaWdodCkmJnRoaXMudXBkYXRlU2NlbmUoe3dpZHRoOmMsaGVpZ2h0Omx9KSxyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFtzLHNdKSxyLnNldEF0dHJpYnV0ZSgidHJhbnNsYXRlIixbLW0sLXldKX1nZXRSZWN0SW1hZ2VCaXRtYXAodCxyPSExLHMpe2NvbnN0IG09dC54KnRoaXMuZHByLHk9dC55KnRoaXMuZHByLGM9dC53KnRoaXMuZHByLGw9dC5oKnRoaXMuZHByO3JldHVybiBjcmVhdGVJbWFnZUJpdG1hcCh0aGlzLmdldE9mZnNjcmVlbihyKSxtLHksYyxsLHMpfXNhZmFyaUZpeFJlY3QodCl7aWYoISh0LncrdC54PD0wfHx0LmgrdC55PD0wKSYmKHQudyt0Lng+dGhpcy5zY2VuZS53aWR0aCYmKHQudz10aGlzLnNjZW5lLndpZHRoLU1hdGgubWF4KHQueCwwKSksdC5oK3QueT50aGlzLnNjZW5lLndpZHRoJiYodC5oPXRoaXMuc2NlbmUuaGVpZ2h0LU1hdGgubWF4KHQueSwwKSksISh0Lnc8PTB8fHQuaDw9MCkpKXJldHVybiB0Lng8MCYmKHQueD0wKSx0Lnk8MCYmKHQueT0wKSx0fWFzeW5jIHBvc3QodCl7dmFyIG07Y29uc3Qgcj10LnJlbmRlcixzPVtdO2lmKHIhPW51bGwmJnIubGVuZ3RoKXtmb3IoY29uc3QgeSBvZiByKWlmKHkuZHJhd0NhbnZhcyYmdGhpcy5kcmF3TGF5ZXIucGFyZW50LnJlbmRlcigpLHkucmVjdCl7aWYoeS5yZWN0PXRoaXMuc2FmYXJpRml4UmVjdChrcih5LnJlY3QpKSwheS5yZWN0KWNvbnRpbnVlO2lmKHkuZHJhd0NhbnZhcyl7Y29uc3QgYz1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcCh5LnJlY3QsISF5LmlzRnVsbFdvcmspO3kuaW1hZ2VCaXRtYXA9Y31zLnB1c2goeSl9dC5yZW5kZXI9c31pZigoKG09dC5zcCkhPW51bGwmJm0ubGVuZ3RofHx0LmRyYXdDb3VudHx8cyE9bnVsbCYmcy5sZW5ndGgpJiYobGUuX3NlbGYucG9zdE1lc3NhZ2UodCkscy5sZW5ndGgpKWZvcihjb25zdCB5IG9mIHMpeS5pbWFnZUJpdG1hcCYmeS5pbWFnZUJpdG1hcC5jbG9zZSgpfW9uKHQpe29ubWVzc2FnZT1yPT57aWYoci5kYXRhKXtjb25zdCBzPXIuZGF0YS5nZXQoIkluaXQiKTtpZihzKXtjb25zdHtkcHI6YyxvZmZzY3JlZW5DYW52YXNPcHQ6bCxsYXllck9wdDp1fT1zO2wmJnUmJmMmJnRoaXMuaW5pdChjLGwsdSl9dChyLmRhdGEudmFsdWVzKCkpO2NvbnN0IG09ci5kYXRhLmhhcygiQ2xlYXJBbGwiKSx5PXIuZGF0YS5nZXQoIlVwZGF0ZUNhbWVyYSIpO2lmKHkpe2NvbnN0e2NhbWVyYU9wdDpjfT15O2MmJnRoaXMuc2V0Q2FtZXJhT3B0KGMsdGhpcy5kcmF3TGF5ZXIpfW0mJnRoaXMuY2xlYXJBbGwoKX19fWNvbnN1bWVEcmF3KHQscil7dD09PUN0LkxvY2FsJiZ0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhdyhyKX1jb25zdW1lRHJhd0FsbCh0LHIpe3RoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3QWxsKHIpfWFzeW5jIGdldFNuYXBzaG90KHQpe2NvbnN0e3NjZW5lUGF0aDpyLHNjZW5lczpzLGNhbWVyYU9wdDptLHc6eSxoOmN9PXQ7aWYociYmcyYmbSl7Y29uc3QgbD1rcih0aGlzLmNhbWVyYU9wdCk7dGhpcy5zZXRDYW1lcmFPcHQobSx0aGlzLnNuYXBzaG90RnVsbExheWVyKSx0aGlzLmxvY2FsV29yay5mdWxsTGF5ZXI9dGhpcy5zbmFwc2hvdEZ1bGxMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dGhpcy5kcmF3TGF5ZXI7Zm9yKGNvbnN0W2Ysdl1vZiBPYmplY3QuZW50cmllcyhzKSlpZih2IT1udWxsJiZ2LnR5cGUpc3dpdGNoKHY9PW51bGw/dm9pZCAwOnYudHlwZSl7Y2FzZSBFdC5GdWxsV29yazp0aGlzLmxvY2FsV29yay5ydW5GdWxsV29yayh7Li4udix3b3JrSWQ6Zixtc2dUeXBlOkV0LkZ1bGxXb3JrLGRhdGFUeXBlOkN0LlNlcnZpY2V9KTticmVhaztjYXNlIEV0LlNlbGVjdDp0aGlzLmxvY2FsV29yay5ydW5TZWxlY3RXb3JrKHsuLi52LHdvcmtJZDpmLG1zZ1R5cGU6RXQuRnVsbFdvcmssZGF0YVR5cGU6Q3QuU2VydmljZX0pO2JyZWFrfXRoaXMubG9jYWxXb3JrLmZ1bGxMYXllcj10aGlzLmRyYXdMYXllcix0aGlzLmxvY2FsV29yay5kcmF3TGF5ZXI9dm9pZCAwO2xldCB1O3kmJmMmJih1PXtyZXNpemVXaWR0aDp5LHJlc2l6ZUhlaWdodDpjfSksdGhpcy5zbmFwc2hvdEZ1bGxMYXllci5wYXJlbnQucmVuZGVyKCk7Y29uc3QgTT1hd2FpdCB0aGlzLmdldFJlY3RJbWFnZUJpdG1hcCh7eDowLHk6MCx3OnRoaXMuc2NlbmUud2lkdGgsaDp0aGlzLnNjZW5lLmhlaWdodH0sITAsdSk7TSYmKGxlLl9zZWxmLnBvc3RNZXNzYWdlKHtzcDpbe3R5cGU6RXQuU25hcHNob3Qsc2NlbmVQYXRoOnIsaW1hZ2VCaXRtYXA6TX1dfSxbTV0pLE0uY2xvc2UoKSx0aGlzLnNuYXBzaG90RnVsbExheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5zZXRDYW1lcmFPcHQobCx0aGlzLmRyYXdMYXllcikpfX19O1Z0KGxlLCJfc2VsZiIsc2VsZik7bGV0IFhlPWxlO25ldyBYZX0pKCk7Cg==", Ki = typeof window < "u" && window.Blob && new Blob([atob(Gs)], { type: "text/javascript;charset=utf-8" });
function at(Z) {
  let d;
  try {
    if (d = Ki && (window.URL || window.webkitURL).createObjectURL(Ki), !d)
      throw "";
    const l = new Worker(d, {
      name: Z == null ? void 0 : Z.name
    });
    return l.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(d);
    }), l;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + Gs,
      {
        name: Z == null ? void 0 : Z.name
      }
    );
  } finally {
    d && (window.URL || window.webkitURL).revokeObjectURL(d);
  }
}
const ot = "index-module__Container__nLsM3", Wt = "index-module__CanvasBox__j2Xe-", Gt = "index-module__FloatCanvas__d1YR7", ut = "index-module__FloatBar__cm-EL", Vt = "index-module__RotateBtn__HSSkf", yd = {
  Container: ot,
  CanvasBox: Wt,
  FloatCanvas: Gt,
  FloatBar: ut,
  RotateBtn: Vt
};
var rd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ti(Z) {
  return Z && Z.__esModule && Object.prototype.hasOwnProperty.call(Z, "default") ? Z.default : Z;
}
function ht(Z) {
  var d = typeof Z;
  return Z != null && (d == "object" || d == "function");
}
var bd = ht, It = typeof rd == "object" && rd && rd.Object === Object && rd, us = It, pt = us, Lt = typeof self == "object" && self && self.Object === Object && self, yt = pt || Lt || Function("return this")(), Al = yt, Kt = Al, Rt = function() {
  return Kt.Date.now();
}, Yt = Rt, St = /\s/;
function xt(Z) {
  for (var d = Z.length; d-- && St.test(Z.charAt(d)); )
    ;
  return d;
}
var rt = xt, Ct = rt, Jt = /^\s+/;
function Tt(Z) {
  return Z && Z.slice(0, Ct(Z) + 1).replace(Jt, "");
}
var Ft = Tt, Nt = Al, gt = Nt.Symbol, zd = gt, Ri = zd, Vs = Object.prototype, Ht = Vs.hasOwnProperty, zt = Vs.toString, Kd = Ri ? Ri.toStringTag : void 0;
function Mt(Z) {
  var d = Ht.call(Z, Kd), l = Z[Kd];
  try {
    Z[Kd] = void 0;
    var s = !0;
  } catch {
  }
  var c = zt.call(Z);
  return s && (d ? Z[Kd] = l : delete Z[Kd]), c;
}
var kt = Mt, vt = Object.prototype, Ut = vt.toString;
function Qt(Z) {
  return Ut.call(Z);
}
var Pt = Qt, Yi = zd, ft = kt, wt = Pt, Et = "[object Null]", jt = "[object Undefined]", Si = Yi ? Yi.toStringTag : void 0;
function Bt(Z) {
  return Z == null ? Z === void 0 ? jt : Et : Si && Si in Object(Z) ? ft(Z) : wt(Z);
}
var xd = Bt;
function Ot(Z) {
  return Z != null && typeof Z == "object";
}
var nd = Ot, Dt = xd, At = nd, qt = "[object Symbol]";
function $t(Z) {
  return typeof Z == "symbol" || At(Z) && Dt(Z) == qt;
}
var _t = $t, lb = Ft, xi = bd, db = _t, ri = NaN, ib = /^[-+]0x[0-9a-f]+$/i, sb = /^0b[01]+$/i, tb = /^0o[0-7]+$/i, bb = parseInt;
function cb(Z) {
  if (typeof Z == "number")
    return Z;
  if (db(Z))
    return ri;
  if (xi(Z)) {
    var d = typeof Z.valueOf == "function" ? Z.valueOf() : Z;
    Z = xi(d) ? d + "" : d;
  }
  if (typeof Z != "string")
    return Z === 0 ? Z : +Z;
  Z = lb(Z);
  var l = sb.test(Z);
  return l || tb.test(Z) ? bb(Z.slice(2), l ? 2 : 8) : ib.test(Z) ? ri : +Z;
}
var Zb = cb, mb = bd, wd = Yt, Ci = Zb, nb = "Expected a function", Xb = Math.max, eb = Math.min;
function ab(Z, d, l) {
  var s, c, W, u, e, n, G = 0, y = !1, a = !1, I = !0;
  if (typeof Z != "function")
    throw new TypeError(nb);
  d = Ci(d) || 0, mb(l) && (y = !!l.leading, a = "maxWait" in l, W = a ? Xb(Ci(l.maxWait) || 0, d) : W, I = "trailing" in l ? !!l.trailing : I);
  function h(R) {
    var x = s, C = c;
    return s = c = void 0, G = R, u = Z.apply(C, x), u;
  }
  function S(R) {
    return G = R, e = setTimeout(V, d), y ? h(R) : u;
  }
  function p(R) {
    var x = R - n, C = R - G, T = d - x;
    return a ? eb(T, W - C) : T;
  }
  function X(R) {
    var x = R - n, C = R - G;
    return n === void 0 || x >= d || x < 0 || a && C >= W;
  }
  function V() {
    var R = wd();
    if (X(R))
      return i(R);
    e = setTimeout(V, p(R));
  }
  function i(R) {
    return e = void 0, I && s ? h(R) : (s = c = void 0, u);
  }
  function b() {
    e !== void 0 && clearTimeout(e), G = 0, s = n = c = e = void 0;
  }
  function t() {
    return e === void 0 ? u : i(wd());
  }
  function m() {
    var R = wd(), x = X(R);
    if (s = arguments, c = this, n = R, x) {
      if (e === void 0)
        return S(n);
      if (a)
        return clearTimeout(e), e = setTimeout(V, d), h(n);
    }
    return e === void 0 && (e = setTimeout(V, d)), u;
  }
  return m.cancel = b, m.flush = t, m;
}
var ob = ab, Wb = ob, Gb = bd, ub = "Expected a function";
function Vb(Z, d, l) {
  var s = !0, c = !0;
  if (typeof Z != "function")
    throw new TypeError(ub);
  return Gb(l) && (s = "leading" in l ? !!l.leading : s, c = "trailing" in l ? !!l.trailing : c), Wb(Z, d, {
    leading: s,
    maxWait: d,
    trailing: c
  });
}
var hb = Vb;
const ql = /* @__PURE__ */ ti(hb), Ib = {
  delete: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDZ2NmEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2aDBtMS0yYTIgMiAwIDAgMSAyLTJoMmEyIDIgMCAwIDEgMiAyaDBNMyA0aDEwIiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==",
  duplicate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0xMSAySDZhMSAxIDAgMCAwLTEgMXY4YTEgMSAwIDAgMCAxIDFoNmExIDEgMCAwIDAgMS0xVjRoMGwtMi0yeiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTExIDJ2MWExIDEgMCAwIDAgMSAxaDFsLTItMnoiLz48cGF0aCBkPSJNOSAxNEg0YTEgMSAwIDAgMS0xLTFWNWgwIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48L2c+PC9zdmc+",
  "layer-pressed": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzMzODFGRiIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  layer: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE2IDEwLTYgNCA2IDQgNi00em0tNiA4IDYgNCA2LTQiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  rotate: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTEzIDZhNiA2IDAgMSAxLTMuNzA5IDEuMjgzIi8+PHBhdGggZD0ibTEzIDYgMS40MTQgMi40NUwxMyA2bDIuNDUtMS40MTQiLz48L2c+PC9zdmc+",
  "rotation-button": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  rotation: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBmaWxsPSIjRkZGIiBvcGFjaXR5PSIuMDEiIGQ9Ik0wIDI0VjBoMjR2MjR6Ii8+PHBhdGggZD0iTTUuNzI0IDUuNzI0QTguODQ3IDguODQ3IDAgMCAxIDEyIDMuMTI1YzIuMjcxIDAgNC41NDMuODY2IDYuMjc2IDIuNmE4Ljg0NiA4Ljg0NiAwIDAgMSAyLjU5OCA2LjE0IDguODQ5IDguODQ5IDAgMCAxLTIuNTU5IDYuMzdsLTEuNS0uOTgzQTcuMTA1IDcuMTA1IDAgMCAwIDE5LjEyNSAxMmE3LjEwMyA3LjEwMyAwIDAgMC0yLjA4Ny01LjAzOEE3LjEwMyA3LjEwMyAwIDAgMCAxMiA0Ljg3NWE3LjEwMyA3LjEwMyAwIDAgMC01LjAzOCAyLjA4NyA3LjEwMSA3LjEwMSAwIDAgMC0yLjA4NiA0LjkyIDcuMTAzIDcuMTAzIDAgMCAwIDEuNzY2IDQuODE1bDEuOTQ1LTEuNTg0IDIuMzk0IDcuMTgyLTcuMjIyLTIuNDA4IDEuNzkxLTEuNzlBOC44NDYgOC44NDYgMCAwIDEgMy4xMjUgMTJjMC0yLjI3MS44NjYtNC41NDMgMi42LTYuMjc2eiIgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9Ii41IiBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L2c+PC9zdmc+",
  "font-colors-active": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjMzM4MUZGIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "font-colors": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTQgMTEgNC05IDQgOU02IDdoNCIgc3Ryb2tlPSIjNDQ0RTYwIiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=",
  "to-bottom": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDEwdjhtMCAwLTItMm0yIDIgMi0ybS00IDZoMTJtLTYtNGg2bS02LTRoNm0tNi00aDYiIHN0cm9rZT0iIzQ0NEU2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+",
  "to-top": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDIydi04bTAgMC0yIDJtMi0yIDIgMm0tNC02aDEybS02IDRoNm0tNiA0aDZtLTYgNGg2IiBzdHJva2U9IiM0NDRFNjAiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg=="
};
function md(Z) {
  return Ib[Z];
}
var jl;
(function(Z) {
  Z[Z.sdk = 1] = "sdk", Z[Z.plugin = 2] = "plugin", Z[Z.both = 3] = "both";
})(jl || (jl = {}));
var id;
(function(Z) {
  Z[Z.Draw = 1] = "Draw", Z[Z.Delete = 2] = "Delete", Z[Z.Update = 3] = "Update";
})(id || (id = {}));
class rl {
  constructor(d, l, s) {
    Object.defineProperty(this, "undoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "redoStack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "colloctor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "isTicking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tickStartStorerCache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "excludeIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "undoTickerEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: $s((c) => {
        if (c === this.undoTickerId && this.tickStartStorerCache) {
          this.isTicking = !1;
          const W = this.diffFun(this.tickStartStorerCache, new Map(Object.entries(this.colloctor.storage))), u = this.undoStack.find((e) => e.id === this.undoTickerId);
          u ? u.data = W : W.size && (this.undoStack.push({
            id: c,
            type: jl.plugin,
            data: W
          }), this.undoStack.length > rl.MaxStackLength && this.undoStack.shift(), rl.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length)), this.redoStack.length && (this.redoStack.length = 0, rl.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length)), this.tickStartStorerCache = void 0, this.undoTickerId = void 0, this.excludeIds.clear();
        }
      }, rl.waitTime)
    }), this.undoStack = [], this.redoStack = [], this.room = d, this.worker = l, this.colloctor = s, this.isTicking = !1, rl.emitter.on("undoTickerStart", this.undoTickerStart.bind(this)), rl.emitter.on("undoTickerEnd", this.undoTickerEnd.bind(this)), rl.emitter.on("excludeIds", this.addExcludeIds.bind(this));
  }
  addExcludeIds(d) {
    if (this.isTicking)
      for (const l of d)
        this.excludeIds.add(l);
  }
  addSdkUndoData(d) {
    const l = this.undoStack.findIndex((s) => (s == null ? void 0 : s.sdkStep) && s.sdkStep > d);
    if (l > -1)
      this.undoStack.splice(l);
    else if (d > 0 && this.undoStack.findIndex((c) => (c == null ? void 0 : c.sdkStep) && c.sdkStep === d) === -1)
      if (this.isTicking && this.undoTickerId) {
        const c = this.undoStack.find((W) => W.id === this.undoTickerId);
        c ? (c.type = jl.both, c.sdkStep = d) : (this.undoStack.push({
          id: this.undoTickerId,
          type: jl.both,
          sdkStep: d
        }), this.undoStack.length > rl.MaxStackLength && this.undoStack.shift(), rl.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length));
      } else
        this.undoStack.push({
          type: jl.sdk,
          sdkStep: d
        }), this.undoStack.length > rl.MaxStackLength && this.undoStack.shift(), rl.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length);
  }
  diffFun(d, l) {
    const s = /* @__PURE__ */ new Set(), c = d.keys(), W = l.keys();
    for (const u of c) {
      if (this.excludeIds.has(u))
        continue;
      const e = d.get(u), n = l.get(u);
      if (e && n) {
        if (_s(n, e))
          continue;
        s.add({
          dataType: id.Update,
          key: u,
          data: [e, n]
        });
        continue;
      }
      e && s.add({
        dataType: id.Delete,
        key: u,
        data: e
      });
    }
    for (const u of W) {
      const e = l.get(u);
      e && !d.has(u) && s.add({
        dataType: id.Draw,
        key: u,
        data: e
      });
    }
    return s;
  }
  undoTickerStart(d) {
    this.excludeIds.clear(), this.isTicking = !0, this.undoTickerId = d, this.tickStartStorerCache = new Map(Object.entries(lt(this.colloctor.storage)));
  }
  isDrawEffectiveScene(d, l) {
    const { key: s } = d;
    return !l.includes(s);
  }
  isDeleteEffectiveScene(d, l) {
    var W;
    const { key: s } = d;
    if (!l.includes(s))
      return !1;
    const c = l.filter((u) => this.colloctor.getLocalId(u) === "selector" && !this.colloctor.isOwn(u)).map((u) => this.colloctor.storage[u]);
    for (const u of c)
      if ((W = u == null ? void 0 : u.selectIds) != null && W.includes(s))
        return !1;
    return !0;
  }
  isOldEffectiveScene(d, l) {
    var W;
    const { key: s } = d;
    if (!l.includes(s))
      return !1;
    const c = l.filter((u) => this.colloctor.getLocalId(u) === "selector" && !this.colloctor.isOwn(u)).map((u) => this.colloctor.storage[u]);
    for (const u of c)
      if ((W = u == null ? void 0 : u.selectIds) != null && W.includes(s))
        return !1;
    return !0;
  }
  isNewEffectiveScene(d, l) {
    const { key: s } = d;
    return !!l.includes(s);
  }
  refreshPlugin(d, l = !1) {
    var W, u, e, n, G, y, a, I;
    let s;
    const c = Object.keys(this.colloctor.storage);
    for (const h of d.values())
      switch (h.dataType) {
        case id.Draw:
          if (s = l ? this.isDrawEffectiveScene(h, c) : this.isDeleteEffectiveScene(h, c), s)
            if (l && !Array.isArray(h.data)) {
              if ((W = h.data.updateNodeOpt) != null && W.useAnimation && (h.data.updateNodeOpt.useAnimation = !1), this.colloctor.getLocalId(h.key) === "selector" && this.colloctor.isOwn(h.key)) {
                const S = h.data.selectIds;
                if (S) {
                  const p = c.filter((V) => this.colloctor.getLocalId(V) === "selector" && !this.colloctor.isOwn(V)).map((V) => this.colloctor.storage[V]);
                  let X = !1;
                  for (const V of p)
                    for (let i = 0; i < S.length; i++)
                      (u = V == null ? void 0 : V.selectIds) != null && u.includes(S[i]) && (delete S[i], X = !0);
                  X && (h.data.selectIds = S.filter((V) => !!V));
                }
              }
              this.colloctor.updateValue(h.key, h.data, { isAfterUpdate: !0 });
            } else
              !l && !Array.isArray(h.data) && this.colloctor.updateValue(h.key, void 0, { isAfterUpdate: !0 });
          break;
        case id.Delete:
          if (s = l ? this.isDeleteEffectiveScene(h, c) : this.isDrawEffectiveScene(h, c), s) {
            if (l && !Array.isArray(h.data))
              this.colloctor.updateValue(h.key, void 0, { isAfterUpdate: !0 });
            else if (!l && !Array.isArray(h.data)) {
              if ((e = h.data.updateNodeOpt) != null && e.useAnimation && (h.data.updateNodeOpt.useAnimation = !1), this.colloctor.getLocalId(h.key) === "selector" && this.colloctor.isOwn(h.key)) {
                const S = h.data.selectIds;
                if (S) {
                  const p = c.filter((V) => this.colloctor.getLocalId(V) === "selector" && !this.colloctor.isOwn(V)).map((V) => this.colloctor.storage[V]);
                  let X = !1;
                  for (const V of p)
                    for (let i = 0; i < S.length; i++)
                      (n = V == null ? void 0 : V.selectIds) != null && n.includes(S[i]) && (delete S[i], X = !0);
                  X && (h.data.selectIds = S.filter((V) => !!V));
                }
              }
              this.colloctor.updateValue(h.key, h.data, { isAfterUpdate: !0 });
            }
          }
          break;
        case id.Update:
          if (s = l ? this.isNewEffectiveScene(h, c) : this.isOldEffectiveScene(h, c), s) {
            if (l && Array.isArray(h.data) && h.data.length === 2) {
              const S = h.data[1];
              if ((G = S.updateNodeOpt) != null && G.useAnimation && (S.updateNodeOpt.useAnimation = !1), this.colloctor.getLocalId(h.key) === "selector" && this.colloctor.isOwn(h.key)) {
                const p = S.selectIds;
                if (p) {
                  const X = c.filter((i) => this.colloctor.getLocalId(i) === "selector" && !this.colloctor.isOwn(i)).map((i) => this.colloctor.storage[i]);
                  let V = !1;
                  for (const i of X)
                    for (let b = 0; b < p.length; b++)
                      (y = i == null ? void 0 : i.selectIds) != null && y.includes(p[b]) && (delete p[b], V = !0);
                  V && (S.selectIds = p.filter((i) => !!i));
                }
              }
              this.colloctor.updateValue(h.key, S, { isAfterUpdate: !0 });
            } else if (!l && Array.isArray(h.data) && h.data.length === 2) {
              const S = h.data[0];
              if ((a = S.updateNodeOpt) != null && a.useAnimation && (S.updateNodeOpt.useAnimation = !1), this.colloctor.getLocalId(h.key) === "selector" && this.colloctor.isOwn(h.key)) {
                const p = S.selectIds;
                if (p) {
                  const X = c.filter((i) => this.colloctor.getLocalId(i) === "selector" && !this.colloctor.isOwn(i)).map((i) => this.colloctor.storage[i]);
                  let V = !1;
                  for (const i of X)
                    for (let b = 0; b < p.length; b++)
                      (I = i == null ? void 0 : i.selectIds) != null && I.includes(p[b]) && (delete p[b], V = !0);
                  V && (S.selectIds = p.filter((i) => !!i));
                }
              }
              this.colloctor.updateValue(h.key, S, { isAfterUpdate: !0 });
            }
          }
          break;
      }
  }
  undo(d) {
    const l = this.undoStack.pop();
    return l && (this.redoStack.push(l), (l.type === jl.sdk || l.type === jl.both) && l.sdkStep && d.call(this.room), (l.type === jl.plugin || l.type === jl.both) && l.data && this.refreshPlugin(l.data)), rl.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length), rl.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length), this.undoStack.length;
  }
  redo(d) {
    const l = this.redoStack.pop();
    return l && (this.undoStack.push(l), (l.type === jl.plugin || l.type === jl.both) && l.data && this.refreshPlugin(l.data, !0), (l.type === jl.sdk || l.type === jl.both) && l.sdkStep && d.call(this.room)), rl.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length), rl.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length), this.redoStack.length;
  }
  clear() {
    this.clearUndo(), this.clearRedo();
  }
  clearUndo() {
    this.undoStack.length = 0, rl.emitter.emit("onCanUndoStepsUpdate", this.undoStack.length);
  }
  clearRedo() {
    this.redoStack.length = 0, rl.emitter.emit("onCanRedoStepsUpdate", this.redoStack.length);
  }
  canUndo() {
    return !!this.undoStack.length;
  }
  canRedo() {
    return !!this.redoStack.length;
  }
  destroy() {
    rl.emitter.removeAllListeners();
  }
}
Object.defineProperty(rl, "MaxStackLength", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 20
});
Object.defineProperty(rl, "emitter", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: new As()
});
Object.defineProperty(rl, "waitTime", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 100
});
class ld {
  constructor() {
    Object.defineProperty(this, "emtType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mainEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serviceColloctor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  static dispatch(d, l, s) {
    var c;
    (c = yl.InternalMsgEmitter) == null || c.emit([d, l], s);
  }
  registerForMainEngine(d, l, s) {
    var c;
    return this.emtType = d, this.mainEngine = l, this.serviceColloctor = s, (c = yl.InternalMsgEmitter) == null || c.on([this.emtType, this.emitEventType], this.collect.bind(this)), this;
  }
  destroy() {
    var d;
    this.emtType && ((d = yl.InternalMsgEmitter) == null || d.off([this.emtType, this.emitEventType], this.collect.bind(this)));
  }
  collectForLocalWorker(d) {
    var l;
    d.forEach((s) => {
      var c;
      (c = this.mainEngine) == null || c.taskBatchData.set(`${s.msgType},${s.workId}`, s);
    }), (l = this.mainEngine) == null || l.runAnimation();
  }
  collectForServiceWorker(d) {
    ii(() => {
      d.forEach((l) => {
        var s;
        (s = this.serviceColloctor) == null || s.dispatch(l), l.undoTickerId && rl.emitter.emit("undoTickerEnd", l.undoTickerId);
      });
    }, Bl.maxLastSyncTime);
  }
}
class pb extends ld {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.ZIndexActive
    });
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workId: l, isActive: s } = d, c = [], W = [];
    l === Il.selectorId && c.push({
      workId: l,
      msgType: hl.UpdateNode,
      dataType: Fl.Local,
      isActiveZIndex: s,
      emitEventType: this.emitEventType,
      willRefreshSelector: !0,
      willSyncService: !1
    }), c.length && this.collectForLocalWorker(c), W.length && this.collectForServiceWorker(W);
  }
}
function Lb() {
  this.__data__ = [], this.size = 0;
}
var yb = Lb;
function Kb(Z, d) {
  return Z === d || Z !== Z && d !== d;
}
var bi = Kb, Rb = bi;
function Yb(Z, d) {
  for (var l = Z.length; l--; )
    if (Rb(Z[l][0], d))
      return l;
  return -1;
}
var Md = Yb, Sb = Md, xb = Array.prototype, rb = xb.splice;
function Cb(Z) {
  var d = this.__data__, l = Sb(d, Z);
  if (l < 0)
    return !1;
  var s = d.length - 1;
  return l == s ? d.pop() : rb.call(d, l, 1), --this.size, !0;
}
var Jb = Cb, Tb = Md;
function Fb(Z) {
  var d = this.__data__, l = Tb(d, Z);
  return l < 0 ? void 0 : d[l][1];
}
var Nb = Fb, gb = Md;
function Hb(Z) {
  return gb(this.__data__, Z) > -1;
}
var zb = Hb, Mb = Md;
function kb(Z, d) {
  var l = this.__data__, s = Mb(l, Z);
  return s < 0 ? (++this.size, l.push([Z, d])) : l[s][1] = d, this;
}
var vb = kb, Ub = yb, Qb = Jb, Pb = Nb, fb = zb, wb = vb;
function Wd(Z) {
  var d = -1, l = Z == null ? 0 : Z.length;
  for (this.clear(); ++d < l; ) {
    var s = Z[d];
    this.set(s[0], s[1]);
  }
}
Wd.prototype.clear = Ub;
Wd.prototype.delete = Qb;
Wd.prototype.get = Pb;
Wd.prototype.has = fb;
Wd.prototype.set = wb;
var kd = Wd, Eb = kd;
function jb() {
  this.__data__ = new Eb(), this.size = 0;
}
var Bb = jb;
function Ob(Z) {
  var d = this.__data__, l = d.delete(Z);
  return this.size = d.size, l;
}
var Db = Ob;
function Ab(Z) {
  return this.__data__.get(Z);
}
var qb = Ab;
function $b(Z) {
  return this.__data__.has(Z);
}
var _b = $b, lc = xd, dc = bd, ic = "[object AsyncFunction]", sc = "[object Function]", tc = "[object GeneratorFunction]", bc = "[object Proxy]";
function cc(Z) {
  if (!dc(Z))
    return !1;
  var d = lc(Z);
  return d == sc || d == tc || d == ic || d == bc;
}
var hs = cc, Zc = Al, mc = Zc["__core-js_shared__"], nc = mc, Ed = nc, Ji = function() {
  var Z = /[^.]+$/.exec(Ed && Ed.keys && Ed.keys.IE_PROTO || "");
  return Z ? "Symbol(src)_1." + Z : "";
}();
function Xc(Z) {
  return !!Ji && Ji in Z;
}
var ec = Xc, ac = Function.prototype, oc = ac.toString;
function Wc(Z) {
  if (Z != null) {
    try {
      return oc.call(Z);
    } catch {
    }
    try {
      return Z + "";
    } catch {
    }
  }
  return "";
}
var Is = Wc, Gc = hs, uc = ec, Vc = bd, hc = Is, Ic = /[\\^$.*+?()[\]{}|]/g, pc = /^\[object .+?Constructor\]$/, Lc = Function.prototype, yc = Object.prototype, Kc = Lc.toString, Rc = yc.hasOwnProperty, Yc = RegExp(
  "^" + Kc.call(Rc).replace(Ic, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Sc(Z) {
  if (!Vc(Z) || uc(Z))
    return !1;
  var d = Gc(Z) ? Yc : pc;
  return d.test(hc(Z));
}
var xc = Sc;
function rc(Z, d) {
  return Z == null ? void 0 : Z[d];
}
var Cc = rc, Jc = xc, Tc = Cc;
function Fc(Z, d) {
  var l = Tc(Z, d);
  return Jc(l) ? l : void 0;
}
var Xd = Fc, Nc = Xd, gc = Al, Hc = Nc(gc, "Map"), ci = Hc, zc = Xd, Mc = zc(Object, "create"), vd = Mc, Ti = vd;
function kc() {
  this.__data__ = Ti ? Ti(null) : {}, this.size = 0;
}
var vc = kc;
function Uc(Z) {
  var d = this.has(Z) && delete this.__data__[Z];
  return this.size -= d ? 1 : 0, d;
}
var Qc = Uc, Pc = vd, fc = "__lodash_hash_undefined__", wc = Object.prototype, Ec = wc.hasOwnProperty;
function jc(Z) {
  var d = this.__data__;
  if (Pc) {
    var l = d[Z];
    return l === fc ? void 0 : l;
  }
  return Ec.call(d, Z) ? d[Z] : void 0;
}
var Bc = jc, Oc = vd, Dc = Object.prototype, Ac = Dc.hasOwnProperty;
function qc(Z) {
  var d = this.__data__;
  return Oc ? d[Z] !== void 0 : Ac.call(d, Z);
}
var $c = qc, _c = vd, lZ = "__lodash_hash_undefined__";
function dZ(Z, d) {
  var l = this.__data__;
  return this.size += this.has(Z) ? 0 : 1, l[Z] = _c && d === void 0 ? lZ : d, this;
}
var iZ = dZ, sZ = vc, tZ = Qc, bZ = Bc, cZ = $c, ZZ = iZ;
function Gd(Z) {
  var d = -1, l = Z == null ? 0 : Z.length;
  for (this.clear(); ++d < l; ) {
    var s = Z[d];
    this.set(s[0], s[1]);
  }
}
Gd.prototype.clear = sZ;
Gd.prototype.delete = tZ;
Gd.prototype.get = bZ;
Gd.prototype.has = cZ;
Gd.prototype.set = ZZ;
var mZ = Gd, Fi = mZ, nZ = kd, XZ = ci;
function eZ() {
  this.size = 0, this.__data__ = {
    hash: new Fi(),
    map: new (XZ || nZ)(),
    string: new Fi()
  };
}
var aZ = eZ;
function oZ(Z) {
  var d = typeof Z;
  return d == "string" || d == "number" || d == "symbol" || d == "boolean" ? Z !== "__proto__" : Z === null;
}
var WZ = oZ, GZ = WZ;
function uZ(Z, d) {
  var l = Z.__data__;
  return GZ(d) ? l[typeof d == "string" ? "string" : "hash"] : l.map;
}
var Ud = uZ, VZ = Ud;
function hZ(Z) {
  var d = VZ(this, Z).delete(Z);
  return this.size -= d ? 1 : 0, d;
}
var IZ = hZ, pZ = Ud;
function LZ(Z) {
  return pZ(this, Z).get(Z);
}
var yZ = LZ, KZ = Ud;
function RZ(Z) {
  return KZ(this, Z).has(Z);
}
var YZ = RZ, SZ = Ud;
function xZ(Z, d) {
  var l = SZ(this, Z), s = l.size;
  return l.set(Z, d), this.size += l.size == s ? 0 : 1, this;
}
var rZ = xZ, CZ = aZ, JZ = IZ, TZ = yZ, FZ = YZ, NZ = rZ;
function ud(Z) {
  var d = -1, l = Z == null ? 0 : Z.length;
  for (this.clear(); ++d < l; ) {
    var s = Z[d];
    this.set(s[0], s[1]);
  }
}
ud.prototype.clear = CZ;
ud.prototype.delete = JZ;
ud.prototype.get = TZ;
ud.prototype.has = FZ;
ud.prototype.set = NZ;
var ps = ud, gZ = kd, HZ = ci, zZ = ps, MZ = 200;
function kZ(Z, d) {
  var l = this.__data__;
  if (l instanceof gZ) {
    var s = l.__data__;
    if (!HZ || s.length < MZ - 1)
      return s.push([Z, d]), this.size = ++l.size, this;
    l = this.__data__ = new zZ(s);
  }
  return l.set(Z, d), this.size = l.size, this;
}
var vZ = kZ, UZ = kd, QZ = Bb, PZ = Db, fZ = qb, wZ = _b, EZ = vZ;
function Vd(Z) {
  var d = this.__data__ = new UZ(Z);
  this.size = d.size;
}
Vd.prototype.clear = QZ;
Vd.prototype.delete = PZ;
Vd.prototype.get = fZ;
Vd.prototype.has = wZ;
Vd.prototype.set = EZ;
var Ls = Vd;
function jZ(Z, d) {
  for (var l = -1, s = Z == null ? 0 : Z.length; ++l < s && d(Z[l], l, Z) !== !1; )
    ;
  return Z;
}
var BZ = jZ, OZ = Xd, DZ = function() {
  try {
    var Z = OZ(Object, "defineProperty");
    return Z({}, "", {}), Z;
  } catch {
  }
}(), AZ = DZ, Ni = AZ;
function qZ(Z, d, l) {
  d == "__proto__" && Ni ? Ni(Z, d, {
    configurable: !0,
    enumerable: !0,
    value: l,
    writable: !0
  }) : Z[d] = l;
}
var ys = qZ, $Z = ys, _Z = bi, lm = Object.prototype, dm = lm.hasOwnProperty;
function im(Z, d, l) {
  var s = Z[d];
  (!(dm.call(Z, d) && _Z(s, l)) || l === void 0 && !(d in Z)) && $Z(Z, d, l);
}
var Ks = im, sm = Ks, tm = ys;
function bm(Z, d, l, s) {
  var c = !l;
  l || (l = {});
  for (var W = -1, u = d.length; ++W < u; ) {
    var e = d[W], n = s ? s(l[e], Z[e], e, l, Z) : void 0;
    n === void 0 && (n = Z[e]), c ? tm(l, e, n) : sm(l, e, n);
  }
  return l;
}
var Qd = bm;
function cm(Z, d) {
  for (var l = -1, s = Array(Z); ++l < Z; )
    s[l] = d(l);
  return s;
}
var Zm = cm, mm = xd, nm = nd, Xm = "[object Arguments]";
function em(Z) {
  return nm(Z) && mm(Z) == Xm;
}
var am = em, gi = am, om = nd, Rs = Object.prototype, Wm = Rs.hasOwnProperty, Gm = Rs.propertyIsEnumerable, um = gi(/* @__PURE__ */ function() {
  return arguments;
}()) ? gi : function(Z) {
  return om(Z) && Wm.call(Z, "callee") && !Gm.call(Z, "callee");
}, Vm = um, hm = Array.isArray, Pd = hm, Td = { exports: {} };
function Im() {
  return !1;
}
var pm = Im;
Td.exports;
(function(Z, d) {
  var l = Al, s = pm, c = d && !d.nodeType && d, W = c && !0 && Z && !Z.nodeType && Z, u = W && W.exports === c, e = u ? l.Buffer : void 0, n = e ? e.isBuffer : void 0, G = n || s;
  Z.exports = G;
})(Td, Td.exports);
var Zi = Td.exports, Lm = 9007199254740991, ym = /^(?:0|[1-9]\d*)$/;
function Km(Z, d) {
  var l = typeof Z;
  return d = d ?? Lm, !!d && (l == "number" || l != "symbol" && ym.test(Z)) && Z > -1 && Z % 1 == 0 && Z < d;
}
var Rm = Km, Ym = 9007199254740991;
function Sm(Z) {
  return typeof Z == "number" && Z > -1 && Z % 1 == 0 && Z <= Ym;
}
var Ys = Sm, xm = xd, rm = Ys, Cm = nd, Jm = "[object Arguments]", Tm = "[object Array]", Fm = "[object Boolean]", Nm = "[object Date]", gm = "[object Error]", Hm = "[object Function]", zm = "[object Map]", Mm = "[object Number]", km = "[object Object]", vm = "[object RegExp]", Um = "[object Set]", Qm = "[object String]", Pm = "[object WeakMap]", fm = "[object ArrayBuffer]", wm = "[object DataView]", Em = "[object Float32Array]", jm = "[object Float64Array]", Bm = "[object Int8Array]", Om = "[object Int16Array]", Dm = "[object Int32Array]", Am = "[object Uint8Array]", qm = "[object Uint8ClampedArray]", $m = "[object Uint16Array]", _m = "[object Uint32Array]", Hl = {};
Hl[Em] = Hl[jm] = Hl[Bm] = Hl[Om] = Hl[Dm] = Hl[Am] = Hl[qm] = Hl[$m] = Hl[_m] = !0;
Hl[Jm] = Hl[Tm] = Hl[fm] = Hl[Fm] = Hl[wm] = Hl[Nm] = Hl[gm] = Hl[Hm] = Hl[zm] = Hl[Mm] = Hl[km] = Hl[vm] = Hl[Um] = Hl[Qm] = Hl[Pm] = !1;
function l0(Z) {
  return Cm(Z) && rm(Z.length) && !!Hl[xm(Z)];
}
var d0 = l0;
function i0(Z) {
  return function(d) {
    return Z(d);
  };
}
var mi = i0, Fd = { exports: {} };
Fd.exports;
(function(Z, d) {
  var l = us, s = d && !d.nodeType && d, c = s && !0 && Z && !Z.nodeType && Z, W = c && c.exports === s, u = W && l.process, e = function() {
    try {
      var n = c && c.require && c.require("util").types;
      return n || u && u.binding && u.binding("util");
    } catch {
    }
  }();
  Z.exports = e;
})(Fd, Fd.exports);
var ni = Fd.exports, s0 = d0, t0 = mi, Hi = ni, zi = Hi && Hi.isTypedArray, b0 = zi ? t0(zi) : s0, Ss = b0, c0 = Zm, Z0 = Vm, m0 = Pd, n0 = Zi, X0 = Rm, e0 = Ss, a0 = Object.prototype, o0 = a0.hasOwnProperty;
function W0(Z, d) {
  var l = m0(Z), s = !l && Z0(Z), c = !l && !s && n0(Z), W = !l && !s && !c && e0(Z), u = l || s || c || W, e = u ? c0(Z.length, String) : [], n = e.length;
  for (var G in Z)
    (d || o0.call(Z, G)) && !(u && // Safari 9 has enumerable `arguments.length` in strict mode.
    (G == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    c && (G == "offset" || G == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    W && (G == "buffer" || G == "byteLength" || G == "byteOffset") || // Skip index properties.
    X0(G, n))) && e.push(G);
  return e;
}
var xs = W0, G0 = Object.prototype;
function u0(Z) {
  var d = Z && Z.constructor, l = typeof d == "function" && d.prototype || G0;
  return Z === l;
}
var Xi = u0;
function V0(Z, d) {
  return function(l) {
    return Z(d(l));
  };
}
var rs = V0, h0 = rs, I0 = h0(Object.keys, Object), p0 = I0, L0 = Xi, y0 = p0, K0 = Object.prototype, R0 = K0.hasOwnProperty;
function Y0(Z) {
  if (!L0(Z))
    return y0(Z);
  var d = [];
  for (var l in Object(Z))
    R0.call(Z, l) && l != "constructor" && d.push(l);
  return d;
}
var S0 = Y0, x0 = hs, r0 = Ys;
function C0(Z) {
  return Z != null && r0(Z.length) && !x0(Z);
}
var Cs = C0, J0 = xs, T0 = S0, F0 = Cs;
function N0(Z) {
  return F0(Z) ? J0(Z) : T0(Z);
}
var ei = N0, g0 = Qd, H0 = ei;
function z0(Z, d) {
  return Z && g0(d, H0(d), Z);
}
var M0 = z0;
function k0(Z) {
  var d = [];
  if (Z != null)
    for (var l in Object(Z))
      d.push(l);
  return d;
}
var v0 = k0, U0 = bd, Q0 = Xi, P0 = v0, f0 = Object.prototype, w0 = f0.hasOwnProperty;
function E0(Z) {
  if (!U0(Z))
    return P0(Z);
  var d = Q0(Z), l = [];
  for (var s in Z)
    s == "constructor" && (d || !w0.call(Z, s)) || l.push(s);
  return l;
}
var j0 = E0, B0 = xs, O0 = j0, D0 = Cs;
function A0(Z) {
  return D0(Z) ? B0(Z, !0) : O0(Z);
}
var ai = A0, q0 = Qd, $0 = ai;
function _0(Z, d) {
  return Z && q0(d, $0(d), Z);
}
var ln = _0, Nd = { exports: {} };
Nd.exports;
(function(Z, d) {
  var l = Al, s = d && !d.nodeType && d, c = s && !0 && Z && !Z.nodeType && Z, W = c && c.exports === s, u = W ? l.Buffer : void 0, e = u ? u.allocUnsafe : void 0;
  function n(G, y) {
    if (y)
      return G.slice();
    var a = G.length, I = e ? e(a) : new G.constructor(a);
    return G.copy(I), I;
  }
  Z.exports = n;
})(Nd, Nd.exports);
var dn = Nd.exports;
function sn(Z, d) {
  var l = -1, s = Z.length;
  for (d || (d = Array(s)); ++l < s; )
    d[l] = Z[l];
  return d;
}
var tn = sn;
function bn(Z, d) {
  for (var l = -1, s = Z == null ? 0 : Z.length, c = 0, W = []; ++l < s; ) {
    var u = Z[l];
    d(u, l, Z) && (W[c++] = u);
  }
  return W;
}
var cn = bn;
function Zn() {
  return [];
}
var Js = Zn, mn = cn, nn = Js, Xn = Object.prototype, en = Xn.propertyIsEnumerable, Mi = Object.getOwnPropertySymbols, an = Mi ? function(Z) {
  return Z == null ? [] : (Z = Object(Z), mn(Mi(Z), function(d) {
    return en.call(Z, d);
  }));
} : nn, oi = an, on = Qd, Wn = oi;
function Gn(Z, d) {
  return on(Z, Wn(Z), d);
}
var un = Gn;
function Vn(Z, d) {
  for (var l = -1, s = d.length, c = Z.length; ++l < s; )
    Z[c + l] = d[l];
  return Z;
}
var Ts = Vn, hn = rs, In = hn(Object.getPrototypeOf, Object), Fs = In, pn = Ts, Ln = Fs, yn = oi, Kn = Js, Rn = Object.getOwnPropertySymbols, Yn = Rn ? function(Z) {
  for (var d = []; Z; )
    pn(d, yn(Z)), Z = Ln(Z);
  return d;
} : Kn, Ns = Yn, Sn = Qd, xn = Ns;
function rn(Z, d) {
  return Sn(Z, xn(Z), d);
}
var Cn = rn, Jn = Ts, Tn = Pd;
function Fn(Z, d, l) {
  var s = d(Z);
  return Tn(Z) ? s : Jn(s, l(Z));
}
var gs = Fn, Nn = gs, gn = oi, Hn = ei;
function zn(Z) {
  return Nn(Z, Hn, gn);
}
var Hs = zn, Mn = gs, kn = Ns, vn = ai;
function Un(Z) {
  return Mn(Z, vn, kn);
}
var Qn = Un, Pn = Xd, fn = Al, wn = Pn(fn, "DataView"), En = wn, jn = Xd, Bn = Al, On = jn(Bn, "Promise"), Dn = On, An = Xd, qn = Al, $n = An(qn, "Set"), _n = $n, lX = Xd, dX = Al, iX = lX(dX, "WeakMap"), sX = iX, Dd = En, Ad = ci, qd = Dn, $d = _n, _d = sX, zs = xd, hd = Is, ki = "[object Map]", tX = "[object Object]", vi = "[object Promise]", Ui = "[object Set]", Qi = "[object WeakMap]", Pi = "[object DataView]", bX = hd(Dd), cX = hd(Ad), ZX = hd(qd), mX = hd($d), nX = hd(_d), cd = zs;
(Dd && cd(new Dd(new ArrayBuffer(1))) != Pi || Ad && cd(new Ad()) != ki || qd && cd(qd.resolve()) != vi || $d && cd(new $d()) != Ui || _d && cd(new _d()) != Qi) && (cd = function(Z) {
  var d = zs(Z), l = d == tX ? Z.constructor : void 0, s = l ? hd(l) : "";
  if (s)
    switch (s) {
      case bX:
        return Pi;
      case cX:
        return ki;
      case ZX:
        return vi;
      case mX:
        return Ui;
      case nX:
        return Qi;
    }
  return d;
});
var fd = cd, XX = Object.prototype, eX = XX.hasOwnProperty;
function aX(Z) {
  var d = Z.length, l = new Z.constructor(d);
  return d && typeof Z[0] == "string" && eX.call(Z, "index") && (l.index = Z.index, l.input = Z.input), l;
}
var oX = aX, WX = Al, GX = WX.Uint8Array, Ms = GX, fi = Ms;
function uX(Z) {
  var d = new Z.constructor(Z.byteLength);
  return new fi(d).set(new fi(Z)), d;
}
var Wi = uX, VX = Wi;
function hX(Z, d) {
  var l = d ? VX(Z.buffer) : Z.buffer;
  return new Z.constructor(l, Z.byteOffset, Z.byteLength);
}
var IX = hX, pX = /\w*$/;
function LX(Z) {
  var d = new Z.constructor(Z.source, pX.exec(Z));
  return d.lastIndex = Z.lastIndex, d;
}
var yX = LX, wi = zd, Ei = wi ? wi.prototype : void 0, ji = Ei ? Ei.valueOf : void 0;
function KX(Z) {
  return ji ? Object(ji.call(Z)) : {};
}
var RX = KX, YX = Wi;
function SX(Z, d) {
  var l = d ? YX(Z.buffer) : Z.buffer;
  return new Z.constructor(l, Z.byteOffset, Z.length);
}
var xX = SX, rX = Wi, CX = IX, JX = yX, TX = RX, FX = xX, NX = "[object Boolean]", gX = "[object Date]", HX = "[object Map]", zX = "[object Number]", MX = "[object RegExp]", kX = "[object Set]", vX = "[object String]", UX = "[object Symbol]", QX = "[object ArrayBuffer]", PX = "[object DataView]", fX = "[object Float32Array]", wX = "[object Float64Array]", EX = "[object Int8Array]", jX = "[object Int16Array]", BX = "[object Int32Array]", OX = "[object Uint8Array]", DX = "[object Uint8ClampedArray]", AX = "[object Uint16Array]", qX = "[object Uint32Array]";
function $X(Z, d, l) {
  var s = Z.constructor;
  switch (d) {
    case QX:
      return rX(Z);
    case NX:
    case gX:
      return new s(+Z);
    case PX:
      return CX(Z, l);
    case fX:
    case wX:
    case EX:
    case jX:
    case BX:
    case OX:
    case DX:
    case AX:
    case qX:
      return FX(Z, l);
    case HX:
      return new s();
    case zX:
    case vX:
      return new s(Z);
    case MX:
      return JX(Z);
    case kX:
      return new s();
    case UX:
      return TX(Z);
  }
}
var _X = $X, le = bd, Bi = Object.create, de = /* @__PURE__ */ function() {
  function Z() {
  }
  return function(d) {
    if (!le(d))
      return {};
    if (Bi)
      return Bi(d);
    Z.prototype = d;
    var l = new Z();
    return Z.prototype = void 0, l;
  };
}(), ie = de, se = ie, te = Fs, be = Xi;
function ce(Z) {
  return typeof Z.constructor == "function" && !be(Z) ? se(te(Z)) : {};
}
var Ze = ce, me = fd, ne = nd, Xe = "[object Map]";
function ee(Z) {
  return ne(Z) && me(Z) == Xe;
}
var ae = ee, oe = ae, We = mi, Oi = ni, Di = Oi && Oi.isMap, Ge = Di ? We(Di) : oe, ue = Ge, Ve = fd, he = nd, Ie = "[object Set]";
function pe(Z) {
  return he(Z) && Ve(Z) == Ie;
}
var Le = pe, ye = Le, Ke = mi, Ai = ni, qi = Ai && Ai.isSet, Re = qi ? Ke(qi) : ye, Ye = Re, Se = Ls, xe = BZ, re = Ks, Ce = M0, Je = ln, Te = dn, Fe = tn, Ne = un, ge = Cn, He = Hs, ze = Qn, Me = fd, ke = oX, ve = _X, Ue = Ze, Qe = Pd, Pe = Zi, fe = ue, we = bd, Ee = Ye, je = ei, Be = ai, Oe = 1, De = 2, Ae = 4, ks = "[object Arguments]", qe = "[object Array]", $e = "[object Boolean]", _e = "[object Date]", la = "[object Error]", vs = "[object Function]", da = "[object GeneratorFunction]", ia = "[object Map]", sa = "[object Number]", Us = "[object Object]", ta = "[object RegExp]", ba = "[object Set]", ca = "[object String]", Za = "[object Symbol]", ma = "[object WeakMap]", na = "[object ArrayBuffer]", Xa = "[object DataView]", ea = "[object Float32Array]", aa = "[object Float64Array]", oa = "[object Int8Array]", Wa = "[object Int16Array]", Ga = "[object Int32Array]", ua = "[object Uint8Array]", Va = "[object Uint8ClampedArray]", ha = "[object Uint16Array]", Ia = "[object Uint32Array]", gl = {};
gl[ks] = gl[qe] = gl[na] = gl[Xa] = gl[$e] = gl[_e] = gl[ea] = gl[aa] = gl[oa] = gl[Wa] = gl[Ga] = gl[ia] = gl[sa] = gl[Us] = gl[ta] = gl[ba] = gl[ca] = gl[Za] = gl[ua] = gl[Va] = gl[ha] = gl[Ia] = !0;
gl[la] = gl[vs] = gl[ma] = !1;
function Jd(Z, d, l, s, c, W) {
  var u, e = d & Oe, n = d & De, G = d & Ae;
  if (l && (u = c ? l(Z, s, c, W) : l(Z)), u !== void 0)
    return u;
  if (!we(Z))
    return Z;
  var y = Qe(Z);
  if (y) {
    if (u = ke(Z), !e)
      return Fe(Z, u);
  } else {
    var a = Me(Z), I = a == vs || a == da;
    if (Pe(Z))
      return Te(Z, e);
    if (a == Us || a == ks || I && !c) {
      if (u = n || I ? {} : Ue(Z), !e)
        return n ? ge(Z, Je(u, Z)) : Ne(Z, Ce(u, Z));
    } else {
      if (!gl[a])
        return c ? Z : {};
      u = ve(Z, a, e);
    }
  }
  W || (W = new Se());
  var h = W.get(Z);
  if (h)
    return h;
  W.set(Z, u), Ee(Z) ? Z.forEach(function(X) {
    u.add(Jd(X, d, l, X, Z, W));
  }) : fe(Z) && Z.forEach(function(X, V) {
    u.set(V, Jd(X, d, l, V, Z, W));
  });
  var S = G ? n ? ze : He : n ? Be : je, p = y ? void 0 : S(Z);
  return xe(p || Z, function(X, V) {
    p && (V = X, X = Z[V]), re(u, V, Jd(X, d, l, V, Z, W));
  }), u;
}
var pa = Jd, La = pa, ya = 1, Ka = 4;
function Ra(Z) {
  return La(Z, ya | Ka);
}
var Ya = Ra;
const Ol = /* @__PURE__ */ ti(Ya);
class Sa extends ld {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.CopyNode
    });
  }
  collect(d) {
    var y;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l } = d, s = [...l], c = (y = this.serviceColloctor) == null ? void 0 : y.storage, W = [], u = [], e = Math.floor(Math.random() * 20 + 10);
    let n;
    const G = Date.now();
    for (; s.length; ) {
      const a = s.pop();
      if (!a)
        continue;
      const I = a.toString(), h = this.serviceColloctor.isLocalId(I), S = h ? this.serviceColloctor.transformKey(a) : I, p = Ol(c[S]);
      let X = I;
      if (!h && this.serviceColloctor.isOwn(X) && (X = this.serviceColloctor.getLocalId(X)), p && X === Il.selectorId) {
        p.selectIds && s.push(...p.selectIds);
        continue;
      }
      if (p) {
        const V = Date.now(), i = (h ? a : this.serviceColloctor.getLocalId(a.toString())) + "-" + V, b = p.updateNodeOpt || {}, t = b.pos || [0, 0];
        n || (n = [-t[0], -t[1]]), b.pos = [t[0] + n[0] + e, t[1] + n[1] + e], b.useAnimation = !1;
        const m = [b.pos[0] - t[0], b.pos[1] - t[1]];
        if (p.ops) {
          const R = as(p.ops).map((C, T) => {
            const K = T % 3;
            return K === 0 ? C + m[0] : K === 1 ? C + m[1] : C;
          }), x = os(R);
          p.ops = x, u.push({
            ...p,
            updateNodeOpt: b,
            type: hl.FullWork,
            workId: i,
            undoTickerId: G
          }), W.push({
            ...p,
            workId: i,
            msgType: hl.FullWork,
            dataType: Fl.Local,
            updateNodeOpt: b,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    rl.emitter.emit("undoTickerStart", G), W.length && this.collectForLocalWorker(W), u.length && this.collectForServiceWorker(u);
  }
}
class xa extends ld {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.SetColorNode
    });
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, color: s, opacity: c } = d, W = [...l], u = this.serviceColloctor.storage, e = [], n = [], G = [], y = Date.now();
    for (; W.length; ) {
      const a = W.pop();
      if (!a)
        continue;
      const I = a.toString(), h = this.serviceColloctor.isLocalId(I), S = h ? this.serviceColloctor.transformKey(a) : I, p = Ol(u[S]);
      let X = I;
      if (!h && this.serviceColloctor.isOwn(X) && (X = this.serviceColloctor.getLocalId(X)), p && X === Il.selectorId) {
        if (p.selectIds) {
          G.push(...p.selectIds);
          const V = p.updateNodeOpt || {};
          V.color = s, c && (V.opacity = c);
          const i = {
            workId: a,
            msgType: hl.UpdateNode,
            dataType: Fl.Local,
            updateNodeOpt: V,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0
          }, b = /* @__PURE__ */ new Map();
          G.forEach((t) => {
            var C, T, K;
            const m = (C = this.serviceColloctor) == null ? void 0 : C.isLocalId(t);
            let R = m && ((T = this.serviceColloctor) == null ? void 0 : T.transformKey(t)) || t;
            const x = u[R];
            !m && ((K = this.serviceColloctor) != null && K.isOwn(R)) && (R = this.serviceColloctor.getLocalId(R)), x != null && x.opt && b.set(R, {
              updateNodeOpt: x.updateNodeOpt,
              opt: x.opt
            });
          }), i.selectStore = b, i.willSerializeData = !0, i.undoTickerId = y, e.push(i);
        }
        continue;
      }
      if (p) {
        const V = p.opt, i = p.updateNodeOpt || {};
        if (V && (i.color = s, i.opacity = c, n.push({
          ...p,
          type: hl.UpdateNode,
          updateNodeOpt: i
        }), !G.includes(I))) {
          let b = I;
          !h && this.serviceColloctor.isOwn(b) && (b = this.serviceColloctor.getLocalId(b)), e.push({
            workId: b,
            msgType: hl.UpdateNode,
            dataType: Fl.Local,
            updateNodeOpt: i,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    rl.emitter.emit("undoTickerStart", y), e.length && this.collectForLocalWorker(e), n.length && this.collectForServiceWorker(n);
  }
}
class ra extends ld {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.ZIndexNode
    });
  }
  collect(d) {
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, num: s } = d, c = [...l], W = this.serviceColloctor.storage, u = [], e = [], n = [];
    for (; c.length; ) {
      const G = c.pop();
      if (!G)
        continue;
      const y = G.toString(), a = this.serviceColloctor.isLocalId(y), I = a ? this.serviceColloctor.transformKey(G) : y, h = Ol(W[I]);
      let S = y;
      if (!a && this.serviceColloctor.isOwn(S) && (S = this.serviceColloctor.getLocalId(S)), h && S === Il.selectorId) {
        if (h.selectIds) {
          n.push(...h.selectIds);
          const p = h.updateNodeOpt || {};
          p.zIndexDistance = s;
          const X = {
            workId: G,
            msgType: hl.UpdateNode,
            dataType: Fl.Local,
            updateNodeOpt: p,
            emitEventType: this.emitEventType,
            willRefreshSelector: !0,
            willSyncService: !0
          }, V = /* @__PURE__ */ new Map();
          n.forEach((i) => {
            var R, x, C;
            const b = (R = this.serviceColloctor) == null ? void 0 : R.isLocalId(i);
            let t = b && ((x = this.serviceColloctor) == null ? void 0 : x.transformKey(i)) || i;
            const m = W[t];
            !b && ((C = this.serviceColloctor) != null && C.isOwn(t)) && (t = this.serviceColloctor.getLocalId(t)), m != null && m.opt && V.set(t, {
              updateNodeOpt: m.updateNodeOpt,
              opt: m.opt
            });
          }), X.selectStore = V, X.willSerializeData = !0, u.push(X);
        }
        continue;
      }
      if (h) {
        const p = h.opt, X = h.updateNodeOpt || {};
        let V = X.zIndex || (p == null ? void 0 : p.zIndex) || 0;
        if (p && (V = V + s, X.zIndex = V, e.push({
          ...h,
          type: hl.UpdateNode,
          updateNodeOpt: X
        }), !n.includes(y))) {
          let i = y;
          !a && this.serviceColloctor.isOwn(i) && (i = this.serviceColloctor.getLocalId(i)), u.push({
            workId: i,
            msgType: hl.UpdateNode,
            dataType: Fl.Local,
            updateNodeOpt: X,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    u.length && this.collectForLocalWorker(u), e.length && this.collectForServiceWorker(e);
  }
}
class Ca extends ld {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.TranslateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oldRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(d) {
    var S, p, X, V, i;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, position: s, workState: c } = d, W = [...l], u = (S = this.serviceColloctor) == null ? void 0 : S.storage, e = [], n = [], G = [], y = (X = (p = this.mainEngine.displayer) == null ? void 0 : p.canvasBgRef) == null ? void 0 : X.getBoundingClientRect(), a = (i = (V = this.mainEngine.displayer) == null ? void 0 : V.floatBarCanvasRef.current) == null ? void 0 : i.getBoundingClientRect();
    let I = !1;
    const h = c === Ll.Start && Date.now() || void 0;
    for (h && (this.undoTickerId = h, rl.emitter.emit("undoTickerStart", h)), y && a && this.oldRect && (this.oldRect.x < y.x && a.x > this.oldRect.x || this.oldRect.y < y.y && a.y > this.oldRect.y || this.oldRect.x + this.oldRect.width > y.x + y.width && a.x < this.oldRect.x || this.oldRect.y + this.oldRect.height > y.y + y.height && a.y < this.oldRect.y) && (I = !0), a && (this.oldRect = a); W.length; ) {
      const b = W.pop();
      if (!b)
        continue;
      const t = b.toString(), m = this.serviceColloctor.isLocalId(t), R = m && this.serviceColloctor.transformKey(b) || t, x = Ol(u[R]);
      let C = t;
      if (!m && this.serviceColloctor.isOwn(C) && (C = this.serviceColloctor.getLocalId(C)), x && C === Il.selectorId) {
        if (x.selectIds && (G.push(...x.selectIds), c !== Ll.Start)) {
          const T = x.updateNodeOpt || {};
          T.pos = this.mainEngine.transformToScenePoint([s.x, s.y]), T.workState = c;
          const K = {
            workId: b,
            msgType: hl.UpdateNode,
            dataType: Fl.Local,
            updateNodeOpt: T,
            emitEventType: this.emitEventType,
            willRefreshSelector: I,
            willSyncService: !0
          };
          if (c === Ll.Done) {
            const J = /* @__PURE__ */ new Map();
            G.forEach((F) => {
              var Q, w, O;
              const r = (Q = this.serviceColloctor) == null ? void 0 : Q.isLocalId(F);
              let Y = r && ((w = this.serviceColloctor) == null ? void 0 : w.transformKey(F)) || F;
              const H = u[Y];
              !r && ((O = this.serviceColloctor) != null && O.isOwn(Y)) && (Y = this.serviceColloctor.getLocalId(Y)), H != null && H.ops && J.set(Y, {
                ops: H.ops,
                updateNodeOpt: H.updateNodeOpt
              });
            }), K.selectStore = J, K.willSerializeData = !0, K.undoTickerId = this.undoTickerId;
          }
          e.push(K);
        }
        continue;
      }
      if (x) {
        const T = x.opt, K = x.updateNodeOpt || {};
        if (T && (K.pos = this.mainEngine.transformToScenePoint([s.x, s.y]), n.push({
          ...x,
          type: hl.UpdateNode,
          updateNodeOpt: K
        }), !G.includes(t))) {
          let J = t;
          !m && this.serviceColloctor.isOwn(J) && (J = this.serviceColloctor.getLocalId(J)), e.push({
            workId: J,
            msgType: hl.UpdateNode,
            dataType: Fl.Local,
            updateNodeOpt: K,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), n.length && this.collectForServiceWorker(n);
  }
}
class Ja extends ld {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.DeleteNode
    });
  }
  collect(d) {
    var G;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l } = d, s = this.serviceColloctor.storage, c = [...l], W = [], u = [], e = [], n = Date.now();
    for (; c.length; ) {
      const y = c.pop();
      if (!y)
        continue;
      const a = y.toString(), I = this.serviceColloctor.isLocalId(a), h = I ? this.serviceColloctor.transformKey(y) : a, S = s[h];
      let p = a;
      if (!I && this.serviceColloctor.isOwn(p) && (p = this.serviceColloctor.getLocalId(p)), S && p === Il.selectorId) {
        e.push(h), (G = yl.InternalMsgEmitter) == null || G.emit([pl.FloatBar, ul.ShowFloatBar], !1), S.selectIds && (e.push(...S.selectIds), W.push({
          msgType: hl.RemoveNode,
          workId: p,
          dataType: Fl.Local,
          emitEventType: ul.DeleteNode
        }));
        continue;
      }
      S && e.push(h), W.push({
        msgType: hl.RemoveNode,
        emitEventType: ul.DeleteNode,
        workId: y,
        dataType: Fl.Local,
        willSyncService: !1,
        willRefresh: !0
      });
    }
    rl.emitter.emit("undoTickerStart", n), W.length && this.collectForLocalWorker(W), e.length && (u.push({
      type: hl.RemoveNode,
      removeIds: e,
      undoTickerId: n
    }), this.collectForServiceWorker(u));
  }
}
class Ta extends ld {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.ScaleNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(d) {
    var a;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, size: s, workState: c } = d, W = [...l], u = (a = this.serviceColloctor) == null ? void 0 : a.storage, e = [], n = [], G = [], y = c === Ll.Start && Date.now() || void 0;
    for (y && (this.undoTickerId = y, rl.emitter.emit("undoTickerStart", y)); W.length; ) {
      const I = W.pop();
      if (!I)
        continue;
      const h = I.toString(), S = this.serviceColloctor.isLocalId(h), p = S ? this.serviceColloctor.transformKey(I) : h, X = Ol(u[p]);
      let V = h;
      if (!S && this.serviceColloctor.isOwn(V) && (V = this.serviceColloctor.getLocalId(V)), X && V === Il.selectorId && X.selectIds) {
        G.push(...X.selectIds);
        const i = X.updateNodeOpt || {};
        i.size = s, i.workState = c;
        const b = {
          workId: I,
          msgType: hl.UpdateNode,
          dataType: Fl.Local,
          updateNodeOpt: i,
          emitEventType: this.emitEventType,
          willRefreshSelector: !0,
          willSyncService: !0
        };
        if (c === Ll.Done) {
          const t = /* @__PURE__ */ new Map();
          G.forEach((m) => {
            var T, K, J;
            const R = (T = this.serviceColloctor) == null ? void 0 : T.isLocalId(m);
            let x = R && ((K = this.serviceColloctor) == null ? void 0 : K.transformKey(m)) || m;
            const C = u[x];
            !R && ((J = this.serviceColloctor) != null && J.isOwn(x)) && (x = this.serviceColloctor.getLocalId(x)), C != null && C.ops && t.set(x, {
              ops: C.ops,
              updateNodeOpt: C.updateNodeOpt,
              opt: C.opt,
              toolsType: C.toolsType
            });
          }), b.selectStore = t, b.willSerializeData = !0, b.undoTickerId = this.undoTickerId;
        }
        e.push(b);
        continue;
      }
      if (X) {
        const i = X.opt, b = X.updateNodeOpt || {};
        if (i && (b.size = s, n.push({
          ...X,
          type: hl.UpdateNode,
          updateNodeOpt: b
        }), !G.includes(h))) {
          let t = h;
          !S && this.serviceColloctor.isOwn(t) && (t = this.serviceColloctor.getLocalId(t)), e.push({
            workId: t,
            msgType: hl.UpdateNode,
            dataType: Fl.Local,
            updateNodeOpt: b,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), n.length && this.collectForServiceWorker(n);
  }
}
class Fa extends ld {
  constructor() {
    super(...arguments), Object.defineProperty(this, "emitEventType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ul.RotateNode
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  collect(d) {
    var a;
    if (!this.serviceColloctor || !this.mainEngine)
      return;
    const { workIds: l, angle: s, workState: c } = d, W = [...l], u = (a = this.serviceColloctor) == null ? void 0 : a.storage, e = [], n = [], G = [], y = c === Ll.Start && Date.now() || void 0;
    for (y && (this.undoTickerId = y, rl.emitter.emit("undoTickerStart", y)); W.length; ) {
      const I = W.pop();
      if (!I)
        continue;
      const h = I.toString(), S = this.serviceColloctor.isLocalId(h), p = S && this.serviceColloctor.transformKey(I) || h, X = Ol(u[p]);
      let V = h;
      if (!S && this.serviceColloctor.isOwn(V) && (V = this.serviceColloctor.getLocalId(V)), X && V === Il.selectorId) {
        if (X.selectIds && (G.push(...X.selectIds), c !== Ll.Start)) {
          const i = X.updateNodeOpt || {};
          i.angle = s, i.workState = c;
          const b = {
            workId: I,
            msgType: hl.UpdateNode,
            dataType: Fl.Local,
            updateNodeOpt: i,
            emitEventType: this.emitEventType,
            willRefreshSelector: !1,
            willSyncService: !0
          };
          if (c === Ll.Done) {
            const t = /* @__PURE__ */ new Map();
            G.forEach((m) => {
              var T, K, J;
              const R = (T = this.serviceColloctor) == null ? void 0 : T.isLocalId(m);
              let x = R && ((K = this.serviceColloctor) == null ? void 0 : K.transformKey(m)) || m;
              const C = u[x];
              !R && ((J = this.serviceColloctor) != null && J.isOwn(x)) && (x = this.serviceColloctor.getLocalId(x)), C != null && C.ops && t.set(x, {
                ops: C.ops,
                updateNodeOpt: C.updateNodeOpt,
                opt: C.opt,
                toolsType: C.toolsType
              });
            }), b.willRefreshSelector = !0, b.selectStore = t, b.willSerializeData = !0, b.undoTickerId = this.undoTickerId;
          }
          e.push(b);
        }
        continue;
      }
      if (X) {
        const i = X.opt, b = X.updateNodeOpt || {};
        if (i && (b.angle = s, n.push({
          ...X,
          type: hl.UpdateNode,
          updateNodeOpt: b
        }), !G.includes(h))) {
          let t = h;
          !S && this.serviceColloctor.isOwn(t) && (t = this.serviceColloctor.getLocalId(t)), e.push({
            workId: t,
            msgType: hl.UpdateNode,
            dataType: Fl.Local,
            updateNodeOpt: b,
            emitEventType: this.emitEventType,
            willSyncService: !1,
            willRefresh: !0
          });
        }
      }
    }
    e.length && this.collectForLocalWorker(e), n.length && this.collectForServiceWorker(n);
  }
}
class Ml {
  constructor(d) {
    Object.defineProperty(this, "builders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), this.builders = new Map(d.map((l) => [l, this.build(l)]));
  }
  build(d) {
    switch (d) {
      case ul.TranslateNode:
        return new Ca();
      case ul.ZIndexNode:
        return new ra();
      case ul.ZIndexActive:
        return new pb();
      case ul.CopyNode:
        return new Sa();
      case ul.SetColorNode:
        return new xa();
      case ul.DeleteNode:
        return new Ja();
      case ul.ScaleNode:
        return new Ta();
      case ul.RotateNode:
        return new Fa();
    }
  }
  registerForMainEngine(d, l, s) {
    return this.builders.forEach((c) => {
      c && c.registerForMainEngine(d, l, s);
    }), this;
  }
  destroy() {
    this.builders.forEach((d) => {
      d && d.destroy();
    });
  }
  static emitMethod(d, l, s) {
    ld.dispatch(d, l, s);
  }
}
const Na = () => {
  const { InternalMsgEmitter: Z } = td(dd);
  return Vl.createElement(
    "div",
    { className: "button normal-button", onClick: (d) => {
      d.preventDefault(), d.stopPropagation(), Z && Ml.emitMethod(pl.MainEngine, ul.DeleteNode, { workIds: ["selector"] });
    }, onTouchEnd: (d) => {
      d.stopPropagation(), Z && Ml.emitMethod(pl.MainEngine, ul.DeleteNode, { workIds: ["selector"] });
    } },
    Vl.createElement("img", { alt: "icon", src: md("delete") })
  );
}, ga = () => {
  const { InternalMsgEmitter: Z } = td(dd);
  return Vl.createElement(
    "div",
    { className: "button normal-button", onClick: (d) => {
      d.preventDefault(), d.stopPropagation(), Z && Ml.emitMethod(pl.MainEngine, ul.CopyNode, { workIds: ["selector"] });
    }, onTouchEnd: (d) => {
      d.stopPropagation(), Z && Ml.emitMethod(pl.MainEngine, ul.CopyNode, { workIds: ["selector"] });
    } },
    Vl.createElement("img", { alt: "icon", src: md("duplicate") })
  );
}, $i = (Z) => {
  const { icon: d, onClickHandler: l, onTouchEndHandler: s } = Z;
  return Vl.createElement(
    "div",
    { className: "button normal-button", onClick: l, onTouchEnd: s },
    Vl.createElement("img", { src: md(d) })
  );
}, Ha = () => {
  const { InternalMsgEmitter: Z, floatBarData: d } = td(dd), [l, s] = sd(!1), c = Rd(() => l ? Vl.createElement(
    "div",
    { className: "image-layer-menu" },
    Vl.createElement($i, { icon: "to-top", onClickHandler: (e) => {
      e.preventDefault(), e.stopPropagation(), Z && Ml.emitMethod(pl.MainEngine, ul.ZIndexNode, { workIds: ["selector"], num: 11 });
    }, onTouchEndHandler: (e) => {
      e.stopPropagation(), Z && Ml.emitMethod(pl.MainEngine, ul.ZIndexNode, { workIds: ["selector"], num: 11 });
    } }),
    Vl.createElement($i, { icon: "to-bottom", onClickHandler: (e) => {
      e.preventDefault(), e.stopPropagation(), Z && Ml.emitMethod(pl.MainEngine, ul.ZIndexNode, { workIds: ["selector"], num: -11 });
    }, onTouchEndHandler: (e) => {
      e.stopPropagation(), Z && Ml.emitMethod(pl.MainEngine, ul.ZIndexNode, { workIds: ["selector"], num: -11 });
    } })
  ) : null, [Z, l]), W = (e) => {
    e.preventDefault(), e.stopPropagation(), e.nativeEvent.stopImmediatePropagation();
    const n = !l;
    s(!l), Z && Ml.emitMethod(pl.MainEngine, ul.ZIndexActive, { workId: "selector", isActive: n });
  }, u = (e) => {
    e.stopPropagation(), e.nativeEvent.stopImmediatePropagation();
    const n = !l;
    s(!l), Z && Ml.emitMethod(pl.MainEngine, ul.ZIndexActive, { workId: "selector", isActive: n });
  };
  return Hd(() => () => {
    l && Z && Ml.emitMethod(pl.MainEngine, ul.ZIndexActive, { workId: "selector", isActive: !1 });
  }, [Z, l, d == null ? void 0 : d.x, d == null ? void 0 : d.y]), Vl.createElement(
    "div",
    { className: `button normal-button ${l && "active"}`, onClick: W, onTouchEnd: u },
    c,
    Vl.createElement("img", { alt: "icon", src: md(l ? "layer-pressed" : "layer") })
  );
}, za = (Z) => {
  const { color: d, opacity: l, activeColor: s, onClickHandler: c, onTouchEndHandler: W } = Z;
  return Vl.createElement(
    "div",
    { className: `font-color-button ${d === s ? "active" : ""}`, onClick: c, onTouchEnd: W },
    Vl.createElement("div", { className: "circle", style: { backgroundColor: s && Yd(d, l) } })
  );
}, Ma = (Z) => {
  const { opacity: d, activeColor: l, setCurOpacity: s } = Z;
  if (!l)
    return null;
  const c = ql((e, n) => {
    e.preventDefault(), e.stopPropagation();
    const G = Math.min(Math.max(d * 100 + n.x, 0.01), 100) / 100;
    d !== G && s(G, Ll.Doing);
  }, 100, { leading: !1 }), W = (e) => {
    e.preventDefault(), e.stopPropagation(), s(d, Ll.Start);
  }, u = ql((e, n) => {
    e.preventDefault(), e.stopPropagation();
    const G = Math.min(Math.max(d * 100 + n.x, 0.01), 100) / 100;
    s(G, Ll.Done);
  }, 100, { leading: !1 });
  return Vl.createElement(
    "div",
    { className: "font-color-opacity" },
    Vl.createElement("div", { className: "range-color", style: {
      background: `linear-gradient(to right, ${Yd(l, 0)}, ${Yd(l, 1)})`
    } }),
    Vl.createElement(
      "div",
      { className: "range-opacity" },
      Vl.createElement(
        di,
        { bounds: "parent", axis: "x", onDrag: c, onStart: W, onStop: u },
        Vl.createElement("div", { className: "circle", style: {
          left: `calc(${d * 100}% - 13px)`,
          backgroundColor: Yd(l, d)
        } })
      )
    )
  );
}, ka = () => {
  const { InternalMsgEmitter: Z, floatBarData: d, floatBarColors: l } = td(dd), [s, c] = sd(!1), [W, u] = sd(d == null ? void 0 : d.nodeColor), [e, n] = sd((d == null ? void 0 : d.opacity) || 1);
  Hd(() => {
    d && (u(d.nodeColor), n(d.opacity || 1));
  }, [d]);
  const G = Rd(() => Vl.createElement(Ma, { opacity: (d == null ? void 0 : d.opacity) || 1, activeColor: W, setCurOpacity: (I, h) => {
    n(I), Z && Ml.emitMethod(pl.MainEngine, ul.SetColorNode, { workIds: ["selector"], color: W, opacity: I, workState: h });
  } }), [Z, W, d == null ? void 0 : d.opacity]), y = Rd(() => s ? Vl.createElement(
    "div",
    { className: "font-colors-menu", onTouchEnd: (I) => {
      I.stopPropagation(), I.nativeEvent.stopImmediatePropagation();
    }, onClick: (I) => {
      I.preventDefault(), I.stopPropagation(), I.nativeEvent.stopImmediatePropagation();
    } },
    l.map((I, h) => {
      const S = si(...I);
      return Vl.createElement(za, { key: h, color: S, opacity: e, activeColor: W, onTouchEndHandler: (p) => {
        p.stopPropagation(), u(S), Z && Ml.emitMethod(pl.MainEngine, ul.SetColorNode, { workIds: ["selector"], color: S });
      }, onClickHandler: (p) => {
        p.preventDefault(), p.stopPropagation(), u(S), Z && Ml.emitMethod(pl.MainEngine, ul.SetColorNode, { workIds: ["selector"], color: S });
      } });
    }),
    G
  ) : null, [s, l, G, e, W, Z]), a = Rd(() => W && e ? Vl.createElement("div", { className: "color-bar", style: { backgroundColor: Yd(W, e) } }) : null, [W, e]);
  return Vl.createElement(
    "div",
    { className: `button normal-button font-colors-icon ${s && "active"}`, onTouchEnd: (I) => {
      I.stopPropagation(), I.nativeEvent.stopImmediatePropagation(), c(!s);
    }, onClick: (I) => {
      I.preventDefault(), I.stopPropagation(), I.nativeEvent.stopImmediatePropagation(), c(!s);
    } },
    Vl.createElement("img", { alt: "icon", src: md("font-colors") }),
    a,
    y
  );
}, va = Vl.memo(() => {
  const { position: Z } = td(dd);
  return Vl.createElement(
    "div",
    { className: "bezier-pencil-plugin-floatbtns", style: Z && Z.y < 80 ? {
      bottom: "-120px"
    } : void 0 },
    Vl.createElement(Na, null),
    Vl.createElement(Ha, null),
    Vl.createElement(ga, null),
    Vl.createElement(ka, null)
  );
}, () => !0), Ua = () => {
  const [Z, d] = sd({ width: 0, height: 0 }), { floatBarData: l, InternalMsgEmitter: s, setSize: c } = td(dd);
  Hd(() => {
    l && d({ width: l.w, height: l.h });
  }, [l]);
  const W = (n, G, y) => {
    n.preventDefault(), n.stopPropagation();
    const a = y.offsetWidth, I = y.offsetHeight, h = { width: a, height: I, workState: Ll.Start };
    c(h), d(h), s && Ml.emitMethod(pl.MainEngine, ul.ScaleNode, { workIds: ["selector"], size: h, workState: Ll.Start });
  }, u = ql((n, G, y) => {
    n.preventDefault(), n.stopPropagation();
    const a = y.offsetWidth, I = y.offsetHeight, h = { width: a, height: I, workState: Ll.Doing };
    (h.width !== Z.width || h.height !== Z.height) && (c(h), d(h), s && Ml.emitMethod(pl.MainEngine, ul.ScaleNode, { workIds: ["selector"], size: h, workState: Ll.Doing }));
  }, 100, { leading: !1 }), e = (n, G, y) => {
    n.preventDefault(), n.stopPropagation();
    const a = y.offsetWidth, I = y.offsetHeight, h = { width: a, height: I, workState: Ll.Done };
    c(h), d(h), s && Ml.emitMethod(pl.MainEngine, ul.ScaleNode, { workIds: ["selector"], size: h, workState: Ll.Done });
  };
  return Vl.createElement(
    dt,
    { className: "bezier-pencil-plugin-hightlight-box", boundsByDirection: !0, size: {
      width: Z.width,
      height: Z.height
    }, onResizeStart: W, onResize: u, onResizeStop: e },
    Vl.createElement("div", { className: "point LT nwse-resize", style: { backgroundColor: l == null ? void 0 : l.color } }),
    Vl.createElement("div", { className: "point LC ew-resize", style: { backgroundColor: l == null ? void 0 : l.color } }),
    Vl.createElement("div", { className: "point LB nesw-resize", style: { backgroundColor: l == null ? void 0 : l.color } }),
    Vl.createElement("div", { className: "point TC ns-resize", style: { backgroundColor: l == null ? void 0 : l.color } }),
    Vl.createElement("div", { className: "point RT nesw-resize", style: { backgroundColor: l == null ? void 0 : l.color } }),
    Vl.createElement("div", { className: "point RC ew-resize", style: { backgroundColor: l == null ? void 0 : l.color } }),
    Vl.createElement("div", { className: "point RB nwse-resize", style: { backgroundColor: l == null ? void 0 : l.color } }),
    Vl.createElement("div", { className: "point BC ns-resize", style: { backgroundColor: l == null ? void 0 : l.color } })
  );
}, Qa = Vl.forwardRef((Z, d) => {
  const { floatBarData: l, zIndex: s, InternalMsgEmitter: c, position: W, showFloatBarBtn: u, angle: e, isRotating: n, setShowFloatBarBtn: G, setPosition: y } = td(dd), { className: a } = Z, I = (X) => {
    X.preventDefault(), X.stopPropagation(), c && Ml.emitMethod(pl.MainEngine, ul.TranslateNode, { workIds: ["selector"], position: W, workState: Ll.Start });
  }, h = ql((X, V) => {
    X.preventDefault(), X.stopPropagation(), G(!0);
    const i = { x: V.x, y: V.y };
    y(i), c && Ml.emitMethod(pl.MainEngine, ul.TranslateNode, { workIds: ["selector"], position: i, workState: Ll.Done });
  }, 100, { leading: !1 }), S = ql((X, V) => {
    X.preventDefault(), X.stopPropagation(), G(!1);
    const i = { x: V.x, y: V.y };
    (V.x !== (W == null ? void 0 : W.x) || V.y !== (W == null ? void 0 : W.y)) && (y(i), c && Ml.emitMethod(pl.MainEngine, ul.TranslateNode, { workIds: ["selector"], position: i, workState: Ll.Doing }));
  }, 100, { leading: !1 }), p = Rd(() => u && !n ? Vl.createElement(va, null) : null, [u, n]);
  return Vl.createElement(
    di,
    { position: W, onStart: I, onDrag: S, onStop: h, handle: "canvas" },
    Vl.createElement(
      "div",
      { className: `${a}`, style: l ? {
        width: l.w,
        height: l.h,
        zIndex: s,
        pointerEvents: s < 2 ? "none" : "auto"
      } : void 0 },
      p,
      Vl.createElement(
        "div",
        { className: "bezier-pencil-plugin-floatCanvas-box", style: {
          width: "100%",
          height: "100%",
          transform: `rotate(${e}deg)`
        } },
        Vl.createElement("canvas", { ref: d, className: "bezier-pencil-plugin-floatCanvas" })
      ),
      !n && Vl.createElement(Ua, null)
    )
  );
}), Pa = (Z) => {
  const { className: d } = Z, { floatBarData: l, InternalMsgEmitter: s, angle: c, setAngle: W, setRotateState: u, position: e, setShowRotateBtn: n } = td(dd), [G, y] = sd(!1), [a, I] = sd(new zl()), [h, S] = sd(new zl());
  Hd(() => {
    if (l) {
      const i = Math.floor(l.w / 2), b = Math.floor(-l.h / 2);
      S(new zl(i, b)), I(new zl());
    }
  }, [l, e]);
  const p = (i, b) => {
    i.preventDefault(), i.stopPropagation(), y(!0);
    const t = Math.round(zl.GetAngleByPoints(a, h, new zl(b.x, b.y))) || 0;
    W(t), u(!0), s && Ml.emitMethod(pl.MainEngine, ul.RotateNode, { workIds: ["selector"], angle: t, workState: Ll.Start });
  }, X = ql((i, b) => {
    i.preventDefault(), i.stopPropagation(), y(!1);
    const t = Math.round(zl.GetAngleByPoints(a, h, new zl(b.x, b.y))) || 0;
    W(t), u(!1), n(!1), s && Ml.emitMethod(pl.MainEngine, ul.RotateNode, { workIds: ["selector"], angle: t, workState: Ll.Done });
  }, 100, { leading: !1 }), V = ql((i, b) => {
    i.preventDefault(), i.stopPropagation(), y(!0);
    const t = Math.round(zl.GetAngleByPoints(a, h, new zl(b.x, b.y))) || 0;
    W(t), u(!0), s && Ml.emitMethod(pl.MainEngine, ul.RotateNode, { workIds: ["selector"], angle: t, workState: Ll.Doing });
  }, 100, { leading: !1 });
  return Vl.createElement(
    di,
    { handle: ".bezier-pencil-plugin-rotate-mouse-pointer", onStart: p, onDrag: V, onStop: X },
    Vl.createElement(
      "div",
      { className: `${d}`, style: e && l ? {
        left: e.x - 30,
        top: e.y + l.h + 20
      } : void 0 },
      !G && Vl.createElement(
        "div",
        { className: "bezier-pencil-plugin-rotate-btn", style: { backgroundColor: l == null ? void 0 : l.color } },
        Vl.createElement("img", { alt: "icon", src: md("rotation-button") })
      ),
      Vl.createElement(
        "div",
        { className: `bezier-pencil-plugin-rotate-mouse-pointer ${G ? "active" : ""}` },
        Vl.createElement("img", { alt: "icon", src: md("rotation") }),
        Vl.createElement(
          "div",
          { className: "angle-icon" },
          c,
          "°"
        )
      )
    )
  );
}, dd = Vl.createContext({
  floatBarColors: [],
  InternalMsgEmitter: void 0,
  floatBarData: void 0,
  zIndex: -1,
  dpr: 1,
  position: void 0,
  angle: 0,
  isRotating: !1,
  showFloatBarBtn: !1,
  setPosition: () => {
  },
  setSize: () => {
  },
  setAngle: () => {
  },
  setRotateState: () => {
  },
  setShowRotateBtn: () => {
  },
  setShowFloatBarBtn: () => {
  }
});
class yl extends Vl.Component {
  constructor(d) {
    super(d), Object.defineProperty(this, "containerRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "floatBarRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "floatBarCanvasRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Vl.createRef()
    }), Object.defineProperty(this, "containerOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        l.button === 0 && yl.InternalMsgEmitter.emit([pl.MainEngine, ul.OriginalEvent], Ll.Start, [l.pageX - this.containerOffset.x, l.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        yl.InternalMsgEmitter.emit([pl.MainEngine, ul.OriginalEvent], Ll.Doing, [l.pageX - this.containerOffset.x, l.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        l.button === 0 && yl.InternalMsgEmitter.emit([pl.MainEngine, ul.OriginalEvent], Ll.Done, [l.pageX - this.containerOffset.x, l.pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        yl.InternalMsgEmitter.emit([pl.MainEngine, ul.OriginalEvent], Ll.Start, [l.targetTouches[0].pageX - this.containerOffset.x, l.targetTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        yl.InternalMsgEmitter.emit([pl.MainEngine, ul.OriginalEvent], Ll.Doing, [l.targetTouches[0].pageX - this.containerOffset.x, l.targetTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        yl.InternalMsgEmitter.emit([pl.MainEngine, ul.OriginalEvent], Ll.Done, [l.changedTouches[0].pageX - this.containerOffset.x, l.changedTouches[0].pageY - this.containerOffset.y]);
      }
    }), Object.defineProperty(this, "setPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        this.setState({ position: l });
      }
    }), Object.defineProperty(this, "setAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        this.setState({ angle: l });
      }
    }), Object.defineProperty(this, "setRotateState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        this.setState({ isRotating: l });
      }
    }), Object.defineProperty(this, "setShowRotateBtn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        this.setState({ showRotateBtn: l });
      }
    }), Object.defineProperty(this, "setShowFloatBarBtn", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (l) => {
        this.setState({ showFloatBarBtn: l });
      }
    }), this.state = {
      showRotateBtn: !1,
      floatBarData: void 0,
      showFloatBar: !1,
      zIndex: -1,
      dpr: 1,
      position: void 0,
      angle: 0,
      isRotating: !1,
      showFloatBarBtn: !1
    };
  }
  showFloatBar(d, l) {
    const s = d && l && { ...this.state.floatBarData, ...l } || void 0;
    this.setState({
      showFloatBar: d,
      floatBarData: s,
      position: l && { x: l.x, y: l.y },
      angle: 0,
      showRotateBtn: d,
      showFloatBarBtn: !0
    }), l && this.floatBarCanvasRef.current && (l.canvasHeight && l.canvasWidth ? (this.floatBarCanvasRef.current.width = l.canvasWidth * this.state.dpr, this.floatBarCanvasRef.current.height = l.canvasHeight * this.state.dpr, this.floatBarCanvasRef.current.style.width = l.canvasWidth + "px", this.floatBarCanvasRef.current.style.height = l.canvasHeight + "px") : (this.floatBarCanvasRef.current.width = l.w * this.state.dpr, this.floatBarCanvasRef.current.height = l.h * this.state.dpr, this.floatBarCanvasRef.current.style.width = "100%", this.floatBarCanvasRef.current.style.height = "100%"));
  }
  setSize(d) {
    this.state.floatBarData && this.setState({ floatBarData: { ...this.state.floatBarData, w: d.width, h: d.height } });
  }
  setFloatZIndex(d) {
    this.setState({ zIndex: d });
  }
  componentDidMount() {
    yl.instance = this, yl.InternalMsgEmitter.on(pl.DisplayContainer, this.init.bind(this)), yl.InternalMsgEmitter.on([pl.FloatBar, ul.ShowFloatBar], this.showFloatBar.bind(this)), yl.InternalMsgEmitter.on([pl.FloatBar, ul.ZIndexFloatBar], this.setFloatZIndex.bind(this)), yl.InternalMsgEmitter.emit(pl.DisplayState, od.mounted);
  }
  componentWillUnmount() {
    var l, s;
    yl.InternalMsgEmitter.emit(pl.DisplayState, od.unmounted);
    const d = (l = yl.instance) == null ? void 0 : l.containerRef;
    if (d) {
      const c = (s = d.parentNode) == null ? void 0 : s.children[0];
      this.removeDisplayerEvent(c);
    }
    yl.InternalMsgEmitter.removeAllListeners();
  }
  getRatioWithContext(d) {
    const l = d.webkitBackingStorePixelRatio || d.mozBackingStorePixelRatio || d.msBackingStorePixelRatio || d.oBackingStorePixelRatio || d.backingStorePixelRatio || 1;
    return Math.max(1, (window.devicePixelRatio || 1) / l);
  }
  init() {
    var c;
    const d = this.containerRef, l = this.canvasFloatRef, s = this.canvasBgRef;
    if (d && l && s) {
      const W = d.offsetWidth, u = d.offsetHeight;
      if (W && u) {
        l.style.width = `${W}px`, l.style.height = `${u}px`, s.style.width = `${W}px`, s.style.height = `${u}px`;
        const e = this.getRatioWithContext(s.getContext("2d"));
        l.width = W * e, l.height = u * e, s.width = W * e, s.height = u * e, yl.InternalMsgEmitter.emit([pl.MainEngine, ul.CreateScene], d.offsetWidth, d.offsetHeight, e);
        const n = (c = d.parentNode) == null ? void 0 : c.children[0];
        n && (this.containerOffset = this.getContainerOffset(d, this.containerOffset), this.bindDisplayerEvent(n)), this.setState({ dpr: e });
      }
    }
  }
  getContainerOffset(d, l) {
    var c;
    let s = {
      x: l.x + d.offsetLeft,
      y: l.y + d.offsetTop
    };
    return (c = d.offsetParent) != null && c.nodeName && d.offsetParent.nodeName !== "BODY" && (s = this.getContainerOffset(d.offsetParent, s)), s;
  }
  bindDisplayerEvent(d) {
    d.addEventListener("mousedown", this.mousedown, !1), window.addEventListener("mousemove", this.mousemove, !1), window.addEventListener("mouseup", this.mouseup, !1), window.addEventListener("mouseleave", this.mouseup, !1), d.addEventListener("touchstart", this.touchstart, !1), window.addEventListener("touchmove", this.touchmove, !1), window.addEventListener("touchend", this.touchend, !1);
  }
  removeDisplayerEvent(d) {
    d.removeEventListener("mousedown", this.mousedown), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup), window.removeEventListener("mouseleave", this.mouseup), d.removeEventListener("touchstart", this.touchstart), window.removeEventListener("touchmove", this.touchmove), window.removeEventListener("touchend", this.touchend);
  }
  render() {
    var d, l;
    return Vl.createElement(
      Vl.Fragment,
      null,
      this.props.children,
      Vl.createElement(
        "div",
        { id: "bezier-pencil-plugin", className: yd.Container, ref: (s) => this.containerRef = s, onMouseDown: (s) => {
          s.preventDefault(), s.stopPropagation();
        }, onTouchStart: (s) => {
          s.stopPropagation();
        } },
        Vl.createElement(
          "div",
          { className: yd.CanvasBox },
          Vl.createElement("canvas", { id: "bezier-pencil-float-canvas", className: yd.FloatCanvas, ref: (s) => this.canvasFloatRef = s }),
          Vl.createElement("canvas", { id: "bezier-pencil-bg-canvas", ref: (s) => this.canvasBgRef = s })
        ),
        Vl.createElement(
          dd.Provider,
          { value: {
            InternalMsgEmitter: yl.InternalMsgEmitter,
            floatBarColors: yl.floatBarColors,
            floatBarData: this.state.floatBarData,
            zIndex: this.state.zIndex,
            dpr: this.state.dpr,
            position: this.state.position,
            angle: this.state.angle,
            isRotating: this.state.isRotating,
            showFloatBarBtn: this.state.showFloatBarBtn,
            setPosition: this.setPosition.bind(this),
            setSize: this.setSize.bind(this),
            setAngle: this.setAngle.bind(this),
            setRotateState: this.setRotateState.bind(this),
            setShowRotateBtn: this.setShowRotateBtn.bind(this),
            setShowFloatBarBtn: this.setShowFloatBarBtn.bind(this)
          } },
          this.state.showFloatBar && Vl.createElement(Qa, { className: yd.FloatBar, ref: this.floatBarCanvasRef }),
          this.state.showFloatBarBtn && this.state.showRotateBtn && ((l = (d = this.state.floatBarData) == null ? void 0 : d.selectIds) == null ? void 0 : l.length) === 1 && Vl.createElement(Pa, { className: yd.RotateBtn })
        )
      )
    );
  }
}
Object.defineProperty(yl, "InternalMsgEmitter", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: new qs()
});
Object.defineProperty(yl, "floatBarColors", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: []
});
const Sd = "++";
class fa {
  setNamespace(d) {
    var l;
    this.namespace = d, this.serviceStorage = li((l = this.plugin) == null ? void 0 : l.attributes[d]) || {}, this.storage = Ol(this.serviceStorage);
  }
  isLocalId(d) {
    return d.split(Sd).length === 1;
  }
  getLocalId(d) {
    return d.split(Sd)[1];
  }
}
var wa = "__lodash_hash_undefined__";
function Ea(Z) {
  return this.__data__.set(Z, wa), this;
}
var ja = Ea;
function Ba(Z) {
  return this.__data__.has(Z);
}
var Oa = Ba, Da = ps, Aa = ja, qa = Oa;
function gd(Z) {
  var d = -1, l = Z == null ? 0 : Z.length;
  for (this.__data__ = new Da(); ++d < l; )
    this.add(Z[d]);
}
gd.prototype.add = gd.prototype.push = Aa;
gd.prototype.has = qa;
var $a = gd;
function _a(Z, d) {
  for (var l = -1, s = Z == null ? 0 : Z.length; ++l < s; )
    if (d(Z[l], l, Z))
      return !0;
  return !1;
}
var lo = _a;
function io(Z, d) {
  return Z.has(d);
}
var so = io, to = $a, bo = lo, co = so, Zo = 1, mo = 2;
function no(Z, d, l, s, c, W) {
  var u = l & Zo, e = Z.length, n = d.length;
  if (e != n && !(u && n > e))
    return !1;
  var G = W.get(Z), y = W.get(d);
  if (G && y)
    return G == d && y == Z;
  var a = -1, I = !0, h = l & mo ? new to() : void 0;
  for (W.set(Z, d), W.set(d, Z); ++a < e; ) {
    var S = Z[a], p = d[a];
    if (s)
      var X = u ? s(p, S, a, d, Z, W) : s(S, p, a, Z, d, W);
    if (X !== void 0) {
      if (X)
        continue;
      I = !1;
      break;
    }
    if (h) {
      if (!bo(d, function(V, i) {
        if (!co(h, i) && (S === V || c(S, V, l, s, W)))
          return h.push(i);
      })) {
        I = !1;
        break;
      }
    } else if (!(S === p || c(S, p, l, s, W))) {
      I = !1;
      break;
    }
  }
  return W.delete(Z), W.delete(d), I;
}
var Qs = no;
function Xo(Z) {
  var d = -1, l = Array(Z.size);
  return Z.forEach(function(s, c) {
    l[++d] = [c, s];
  }), l;
}
var eo = Xo;
function ao(Z) {
  var d = -1, l = Array(Z.size);
  return Z.forEach(function(s) {
    l[++d] = s;
  }), l;
}
var oo = ao, _i = zd, ls = Ms, Wo = bi, Go = Qs, uo = eo, Vo = oo, ho = 1, Io = 2, po = "[object Boolean]", Lo = "[object Date]", yo = "[object Error]", Ko = "[object Map]", Ro = "[object Number]", Yo = "[object RegExp]", So = "[object Set]", xo = "[object String]", ro = "[object Symbol]", Co = "[object ArrayBuffer]", Jo = "[object DataView]", ds = _i ? _i.prototype : void 0, jd = ds ? ds.valueOf : void 0;
function To(Z, d, l, s, c, W, u) {
  switch (l) {
    case Jo:
      if (Z.byteLength != d.byteLength || Z.byteOffset != d.byteOffset)
        return !1;
      Z = Z.buffer, d = d.buffer;
    case Co:
      return !(Z.byteLength != d.byteLength || !W(new ls(Z), new ls(d)));
    case po:
    case Lo:
    case Ro:
      return Wo(+Z, +d);
    case yo:
      return Z.name == d.name && Z.message == d.message;
    case Yo:
    case xo:
      return Z == d + "";
    case Ko:
      var e = uo;
    case So:
      var n = s & ho;
      if (e || (e = Vo), Z.size != d.size && !n)
        return !1;
      var G = u.get(Z);
      if (G)
        return G == d;
      s |= Io, u.set(Z, d);
      var y = Go(e(Z), e(d), s, c, W, u);
      return u.delete(Z), y;
    case ro:
      if (jd)
        return jd.call(Z) == jd.call(d);
  }
  return !1;
}
var Fo = To, is = Hs, No = 1, go = Object.prototype, Ho = go.hasOwnProperty;
function zo(Z, d, l, s, c, W) {
  var u = l & No, e = is(Z), n = e.length, G = is(d), y = G.length;
  if (n != y && !u)
    return !1;
  for (var a = n; a--; ) {
    var I = e[a];
    if (!(u ? I in d : Ho.call(d, I)))
      return !1;
  }
  var h = W.get(Z), S = W.get(d);
  if (h && S)
    return h == d && S == Z;
  var p = !0;
  W.set(Z, d), W.set(d, Z);
  for (var X = u; ++a < n; ) {
    I = e[a];
    var V = Z[I], i = d[I];
    if (s)
      var b = u ? s(i, V, I, d, Z, W) : s(V, i, I, Z, d, W);
    if (!(b === void 0 ? V === i || c(V, i, l, s, W) : b)) {
      p = !1;
      break;
    }
    X || (X = I == "constructor");
  }
  if (p && !X) {
    var t = Z.constructor, m = d.constructor;
    t != m && "constructor" in Z && "constructor" in d && !(typeof t == "function" && t instanceof t && typeof m == "function" && m instanceof m) && (p = !1);
  }
  return W.delete(Z), W.delete(d), p;
}
var Mo = zo, Bd = Ls, ko = Qs, vo = Fo, Uo = Mo, ss = fd, ts = Pd, bs = Zi, Qo = Ss, Po = 1, cs = "[object Arguments]", Zs = "[object Array]", Cd = "[object Object]", fo = Object.prototype, ms = fo.hasOwnProperty;
function wo(Z, d, l, s, c, W) {
  var u = ts(Z), e = ts(d), n = u ? Zs : ss(Z), G = e ? Zs : ss(d);
  n = n == cs ? Cd : n, G = G == cs ? Cd : G;
  var y = n == Cd, a = G == Cd, I = n == G;
  if (I && bs(Z)) {
    if (!bs(d))
      return !1;
    u = !0, y = !1;
  }
  if (I && !y)
    return W || (W = new Bd()), u || Qo(Z) ? ko(Z, d, l, s, c, W) : vo(Z, d, n, l, s, c, W);
  if (!(l & Po)) {
    var h = y && ms.call(Z, "__wrapped__"), S = a && ms.call(d, "__wrapped__");
    if (h || S) {
      var p = h ? Z.value() : Z, X = S ? d.value() : d;
      return W || (W = new Bd()), c(p, X, l, s, W);
    }
  }
  return I ? (W || (W = new Bd()), Uo(Z, d, l, s, c, W)) : !1;
}
var Eo = wo, jo = Eo, ns = nd;
function Ps(Z, d, l, s, c) {
  return Z === d ? !0 : Z == null || d == null || !ns(Z) && !ns(d) ? Z !== Z && d !== d : jo(Z, d, l, s, Ps, c);
}
var Bo = Ps, Oo = Bo;
function Do(Z, d) {
  return Oo(Z, d);
}
var Ao = Do;
const Xs = /* @__PURE__ */ ti(Ao);
class Zd extends fa {
  constructor(d, l) {
    super(), Object.defineProperty(this, "serviceStorage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "asyncClockState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Zd.syncInterval = (l || Zd.syncInterval) * 0.5, this.plugin = d, this.uid = d.displayer.uid;
    const s = d.displayer.state.sceneState.scenePath;
    this.setNamespace(s);
  }
  addStorageStateListener(d) {
    this.stateDisposer = Es(async () => {
      var c;
      const l = li((c = this.plugin) == null ? void 0 : c.attributes[this.namespace]) || {}, s = this.diffFun(this.serviceStorage, l);
      this.serviceStorage = l;
      for (const [W, u] of Object.entries(s))
        (u == null ? void 0 : u.newValue) === void 0 ? delete this.storage[W] : this.storage[W] = Ol(u == null ? void 0 : u.newValue);
      d(s);
    });
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  diffFun(d, l) {
    const s = Ld(d), c = Ld(l), W = {};
    for (const u of s) {
      if (c.includes(u)) {
        if (Xs(d[u], l[u]))
          continue;
        W[u] = {
          oldValue: d[u],
          newValue: l[u]
        };
        continue;
      }
      W[u] = {
        oldValue: d[u],
        newValue: void 0
      };
    }
    for (const u of c)
      s.includes(u) || (W[u] = {
        oldValue: void 0,
        newValue: l[u]
      });
    return W;
  }
  transformKey(d) {
    return this.uid + Sd + d;
  }
  isOwn(d) {
    return d.split(Sd)[0] === this.uid;
  }
  dispatch(d) {
    const { type: l, workId: s, ops: c, index: W, opt: u, toolsType: e, removeIds: n, updateNodeOpt: G, op: y, selectIds: a, isSync: I } = d;
    switch (l) {
      case hl.Clear:
        const h = {};
        Object.keys(this.storage).map((i) => {
          h[i] = void 0;
        }), this.setState(h, { isSync: I });
        break;
      case hl.CreateWork:
        if (s && e && u) {
          const i = this.isLocalId(s.toString()) ? this.transformKey(s) : s;
          this.updateValue(i.toString(), {
            type: hl.CreateWork,
            workId: s,
            toolsType: e,
            opt: u
          }, { isSync: I });
        }
        break;
      case hl.DrawWork:
        if (s && typeof W == "number" && (y != null && y.length)) {
          const i = this.isLocalId(s.toString()) ? this.transformKey(s) : s, b = this.storage[i], t = ((b == null ? void 0 : b.op) || []).slice(0, W).concat(y);
          b && t && this.updateValue(i.toString(), {
            ...b,
            type: hl.DrawWork,
            op: t,
            index: W
          }, { isSync: I });
        }
        break;
      case hl.FullWork:
        if (s) {
          const i = this.isLocalId(s.toString()) ? this.transformKey(s) : s, b = this.storage[i], t = G || (b == null ? void 0 : b.updateNodeOpt), m = e || (b == null ? void 0 : b.toolsType), R = u || (b == null ? void 0 : b.opt), x = c || (b == null ? void 0 : b.ops);
          m && R && x && this.updateValue(i.toString(), {
            type: hl.FullWork,
            updateNodeOpt: t,
            workId: i,
            toolsType: m,
            opt: R,
            ops: x
          }, { isSync: I });
        }
        break;
      case hl.RemoveNode:
        if (n != null && n.length) {
          const i = n.map((b) => this.isLocalId(b + "") ? this.transformKey(b) : b);
          Object.keys(this.storage).map((b) => {
            i != null && i.includes(b) && this.updateValue(b, void 0, { isSync: I });
          });
        }
        break;
      case hl.UpdateNode:
        if (s && (G || c || u)) {
          const i = this.isLocalId(s.toString()) ? this.transformKey(s) : s, b = this.storage[i];
          b && (b.type = l, b.updateNodeOpt = G, c && (b.ops = c), G && (b.updateNodeOpt = G), u && (b.opt = u), this.updateValue(i.toString(), b, { isSync: I }));
        }
        break;
      case hl.Select:
        let S;
        a != null && a.length && (S = a.map((i) => this.isLocalId(i + "") ? this.transformKey(i) : i));
        const p = this.transformKey(Il.selectorId), X = this.storage[p], V = u || (X == null ? void 0 : X.opt);
        S && this.checkOtherSelector(p, S, { isSync: I }), this.updateValue(p, S && {
          type: hl.Select,
          toolsType: Jl.Selector,
          opt: V,
          selectIds: S
        }, { isSync: I });
        break;
    }
  }
  checkOtherSelector(d, l, s) {
    for (const c of Object.keys(this.storage))
      if (c !== d && this.getLocalId(c) === "selector") {
        const W = this.storage[c];
        if (W && W.selectIds) {
          const u = W.selectIds.filter((e) => !l.includes(e));
          u.length > 0 && (W.selectIds = u), this.updateValue(c, u.length && W || void 0, s);
        }
      }
  }
  setState(d, l) {
    const s = Ld(d);
    for (let c = 0; c < s.length; c++) {
      const W = s[c], u = d[W];
      typeof u < "u" ? this.storage[W] = u : delete this.storage[W];
    }
    this.runSyncService(l);
  }
  updateValue(d, l, s) {
    l === void 0 ? delete this.storage[d] : this.storage[d] = l, this.runSyncService(s);
  }
  runSyncService(d) {
    this.asyncClockState || (this.asyncClockState = !0, setTimeout(() => {
      d != null && d.isSync ? (this.asyncClockState = !1, this.syncSerivice(d == null ? void 0 : d.isAfterUpdate)) : ii(() => {
        this.asyncClockState = !1, this.syncSerivice(d == null ? void 0 : d.isAfterUpdate);
      }, Zd.syncInterval);
    }, d != null && d.isSync ? 0 : Zd.syncInterval));
  }
  syncSerivice(d = !1) {
    const l = Ld(this.serviceStorage), s = Ld(this.storage), c = /* @__PURE__ */ new Map();
    let W = 0;
    for (const u of l) {
      const e = this.serviceStorage[u], n = this.storage[u];
      if (s.includes(u)) {
        if (Xs(e, n))
          continue;
        c.set(u, n), W++;
        continue;
      }
      c.set(u, void 0);
    }
    for (const u of s) {
      const e = this.storage[u];
      l.includes(u) || (c.set(u, e), W++);
    }
    if (W > 5)
      this.syncStorage(this.storage, d);
    else if (c.size > 0)
      for (const [u, e] of c.entries())
        this.syncUpdata(u, e, d);
  }
  syncUpdata(d, l, s = !1) {
    var W;
    Object.keys(this.serviceStorage).length ? (s || (l === void 0 ? delete this.serviceStorage[d] : this.serviceStorage[d] = l), (W = this.plugin) == null || W.updateAttributes([this.namespace, d], l)) : this.syncStorage(this.storage, s);
  }
  syncStorage(d, l = !1) {
    var c;
    l || (this.serviceStorage = Ol(d));
    const s = {};
    s[this.namespace] = d, (c = this.plugin) == null || c.setAttributes(s);
  }
  transformToSerializableData(d) {
    return os(d);
  }
  transformToNormalData(d) {
    return as(d);
  }
  keyTransformWorkId(d) {
    const l = d.split(Sd);
    return l.length === 2 ? l[1] : d;
  }
  destroy() {
    this.removeStorageStateListener(), this.plugin = void 0, this.serviceStorage = {}, this.storage = {}, this.namespace = "";
  }
}
Object.defineProperty(Zd, "syncInterval", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
class qo {
  constructor(d, l) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "player", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "commiter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onCameraChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ql((s) => {
        var c;
        (c = this.worker) == null || c.setCameraOpt(li(s));
      }, 20, { leading: !1 })
    }), Object.defineProperty(this, "onSceneChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ql((s) => {
        var c, W;
        (c = this.collector) == null || c.setNamespace(s.scenePath), (W = this.worker) == null || W.clearAll(!0).then(() => {
          var u;
          (u = this.worker) == null || u.initSyncData();
        });
      }, 100, { leading: !1 })
    }), Object.defineProperty(this, "onMemberChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ql((s) => {
        var e, n, G, y, a, I, h, S, p, X, V;
        if (!this.room || !this.worker)
          return;
        const c = s.currentApplianceName, W = c === ed.pencil && s.useLaserPen ? Jl.LaserPen : c === ed.eraser || c === ed.pencilEraser ? Jl.Eraser : c === ed.pencil && s.useNewPencil ? Jl.Pencil : c === ed.selector ? Jl.Selector : Jl.Clicker, u = {
          color: si(s.strokeColor[0], s.strokeColor[1], s.strokeColor[2]),
          opacity: (s == null ? void 0 : s.strokeOpacity) || 1
        };
        if (W === Jl.Pencil ? (u.thickness = s.strokeWidth, u.strokeType = (s == null ? void 0 : s.strokeType) || _l.Normal) : W === Jl.Eraser ? (u.thickness = Math.min(3, Math.max(1, Math.floor(s.pencilEraserSize || 1))) - 1, u.isLine = c === ed.eraser && !0) : W === Jl.LaserPen && (u.thickness = s.strokeWidth, u.duration = (s == null ? void 0 : s.duration) || 1, u.strokeType = (s == null ? void 0 : s.strokeType) || _l.Normal), (e = this.worker) == null || e.setCurrentToolsData({
          toolsType: W,
          toolsOpt: u
        }), W === Jl.Selector ? ((n = yl.InternalMsgEmitter) == null || n.on([pl.MainEngine, ul.TranslateNode], this.linstenerSelector.bind(this)), (G = yl.InternalMsgEmitter) == null || G.on([pl.MainEngine, ul.SetColorNode], this.linstenerSelector.bind(this)), (y = yl.InternalMsgEmitter) == null || y.on([pl.MainEngine, ul.ScaleNode], this.linstenerSelector.bind(this)), (a = yl.InternalMsgEmitter) == null || a.on([pl.MainEngine, ul.RotateNode], this.linstenerSelector.bind(this))) : ((I = yl.InternalMsgEmitter) == null || I.off([pl.MainEngine, ul.TranslateNode], this.linstenerSelector.bind(this)), (h = yl.InternalMsgEmitter) == null || h.off([pl.MainEngine, ul.SetColorNode], this.linstenerSelector.bind(this)), (S = yl.InternalMsgEmitter) == null || S.off([pl.MainEngine, ul.ScaleNode], this.linstenerSelector.bind(this)), (p = yl.InternalMsgEmitter) == null || p.off([pl.MainEngine, ul.RotateNode], this.linstenerSelector.bind(this))), W === Jl.Eraser || W === Jl.Pencil || W === Jl.LaserPen || W === Jl.Selector) {
          W === Jl.Pencil || W === Jl.LaserPen ? (this.room.disableDeviceInputs = !0, setTimeout(() => {
            var b, t;
            const i = (t = (b = yl.instance.containerRef) == null ? void 0 : b.parentNode) == null ? void 0 : t.children[0];
            i && (i.className = i.className + " cursor-pencil");
          }, 0)) : this.room.disableDeviceInputs = !1, (X = this.worker) == null || X.abled();
          return;
        }
        this.room.disableDeviceInputs = !1, (V = this.worker) == null || V.unabled();
      }, 100, { leading: !1 })
    }), this.plugin = d, this.room = $l(d.displayer) ? d.displayer : void 0, this.player = es(d.displayer) ? d.displayer : void 0, this.pluginOptions = l, window.onbeforeunload = () => {
      this.onUnMountDisplayer();
    };
  }
  init() {
    var d, l;
    yl.floatBarColors = ((l = (d = this.room) == null ? void 0 : d.floatBarOptions) == null ? void 0 : l.colors) || [], yl.InternalMsgEmitter.on(pl.DisplayState, this.displayStateListener.bind(this)), this.player && (this.onMountDisplayer(), yl.InternalMsgEmitter.emit(pl.DisplayContainer, !0));
  }
  async screenshotToCanvas(d, l, s, c, W) {
    var e;
    const u = await ((e = this.worker) == null ? void 0 : e.getSnapshot(l, s, c, W));
    u && (d.drawImage(u, 0, 0), u.close());
  }
  async scenePreview(d, l) {
    var c;
    const s = await ((c = this.worker) == null ? void 0 : c.getSnapshot(d));
    if (s && this.worker) {
      const W = document.createElement("canvas"), u = W.getContext("2d"), { width: e, height: n } = this.worker.getCameraOpt();
      W.width = e, W.height = n, u && (u.drawImage(s, 0, 0), l.src = W.toDataURL(), l.onload = () => {
        W.remove();
      }, l.onerror = () => {
        W.remove(), l.remove();
      }), s.close();
    }
  }
  cleanCurrentScene() {
    var d;
    (d = this.worker) == null || d.clearAll();
  }
  destroy() {
    this.onUnMountDisplayer();
  }
  displayStateListener(d) {
    d === od.mounted && (this.onMountDisplayer(), yl.InternalMsgEmitter.emit(pl.DisplayContainer, !0)), d === od.unmounted && this.onUnMountDisplayer();
  }
  linstenerSelector(d) {
    this.room && d.workState === Ll.Start ? this.room.disableDeviceInputs = !0 : this.room && d.workState === Ll.Done && (this.room.disableDeviceInputs = !1);
  }
  onWritableChange(d) {
    var l, s;
    d ? (s = this.worker) == null || s.abled() : (l = this.worker) == null || l.unabled();
  }
  onMountDisplayer() {
    var c, W, u, e, n;
    const d = (c = yl.instance) == null ? void 0 : c.containerRef, l = (W = yl.instance) == null ? void 0 : W.canvasFloatRef, s = (u = yl.instance) == null ? void 0 : u.canvasBgRef;
    l && s && d && (this.collector = new Zd(this.plugin, (n = (e = this.pluginOptions) == null ? void 0 : e.syncOpt) == null ? void 0 : n.interval), this.worker = new Bl(yl.instance, this.collector, this.pluginOptions), this.commiter = this.room && new rl(this.room, this.worker, this.collector), this.collector.addStorageStateListener((G) => {
      var y, a, I;
      if (G) {
        if ((y = this.collector) != null && y.storage) {
          const h = Object.keys(this.collector.storage);
          if (h.length === 0) {
            (a = this.worker) == null || a.clearAll(!0);
            return;
          }
          if (this.worker) {
            let S = 0;
            for (const p of h) {
              const X = this.collector.storage[p];
              X && (S = Math.max(S, ((I = X.opt) == null ? void 0 : I.zIndex) || 0));
            }
            this.worker.maxLayerIndex = S;
          }
        }
        if (this.worker) {
          const h = this.worker.getRelevantWork(G);
          Object.keys(G).forEach((S) => {
            var X;
            const p = G[S];
            p && ((X = this.worker) == null || X.onServiceDerive(S, p, h));
          }), rl.emitter.emit("excludeIds", Object.keys(G));
        }
      }
    }), setTimeout(() => {
      var G;
      (G = this.worker) == null || G.initSyncData();
    }, 200));
  }
  onUnMountDisplayer() {
    var d, l, s;
    (d = this.collector) == null || d.destroy(), (l = this.worker) == null || l.destroy(), (s = this.commiter) == null || s.destroy(), this.collector = void 0, this.worker = void 0, this.commiter = void 0;
  }
}
class Cl extends js {
  static async getInstance(d, l) {
    l != null && l.logger && (Cl.logger = l.logger), l != null && l.options && (Cl.options = l.options), !d.getInvisiblePlugin(Cl.kind) && $l(d) && await d.createInvisiblePlugin(Cl, {});
    const c = {
      displayer: d,
      screenshotToCanvasAsync: async function(W, u, e, n, G, y) {
        Cl.logger.info("[BezierPencilPlugin plugin] screenshotToCanvasAsync");
        const a = document.createElement("canvas"), I = a.getContext("2d");
        a.width = e * (y || 1), a.height = n * (y || 1), I && (this.displayer.screenshotToCanvas(I, u, e, n, G, y), W.drawImage(a, 0, 0, e * (y || 1), n * (y || 1), 0, 0, e, n), a.remove()), await Cl.currentManager.screenshotToCanvas(W, u, e, n, G);
      },
      scenePreviewAsync: async function(W, u, e, n, G) {
        Cl.logger.info("[BezierPencilPlugin plugin] scenePreview"), this.displayer.scenePreview(W, u, e, n, G);
        const y = document.createElement("img");
        y.style.position = "absolute", y.style.top = "0px", y.style.left = "0px", y.style.width = "100%", y.style.height = "100%", y.style.pointerEvents = "none", u.append(y), getComputedStyle(u).position || (u.style.position = "relative"), await Cl.currentManager.scenePreview(W, y);
      },
      callbacksOn: function(W, u) {
        Cl.logger.info(`[BezierPencilPlugin plugin] callbacks ${W}`), (W === "onCanUndoStepsUpdate" || W === "onCanRedoStepsUpdate") && $l(this.displayer) && this.displayer.isWritable ? rl.emitter.on(W, u) : this.displayer.callbacks.on(W, u);
      },
      callbacksOnce: function(W, u) {
        Cl.logger.info(`[BezierPencilPlugin plugin] callbacks ${W}`), (W === "onCanUndoStepsUpdate" || W === "onCanRedoStepsUpdate") && $l(this.displayer) && this.displayer.isWritable ? rl.emitter.on(W, u) : this.displayer.callbacks.on(W, u);
      },
      callbacksOff: function(W, u) {
        Cl.logger.info(`[BezierPencilPlugin plugin] callbacks ${W}`), (W === "onCanUndoStepsUpdate" || W === "onCanRedoStepsUpdate") && $l(this.displayer) && this.displayer.isWritable ? rl.emitter.off(W, u) : this.displayer.callbacks.off(W, u);
      },
      undo: function() {
        var W;
        return Cl.logger.info("[BezierPencilPlugin plugin] undo"), $l(this.displayer) && !this.displayer.disableSerialization && ((W = Cl.currentManager.commiter) == null ? void 0 : W.undo(this.displayer.undo)) || 0;
      },
      redo: function() {
        var W;
        return Cl.logger.info("[BezierPencilPlugin plugin] redo"), $l(this.displayer) && !this.displayer.disableSerialization && ((W = Cl.currentManager.commiter) == null ? void 0 : W.redo(this.displayer.redo)) || 0;
      },
      cleanCurrentScene: function(W) {
        Cl.logger.info("[BezierPencilPlugin plugin] cleanCurrentScene"), $l(d) && d.isWritable && (Cl.currentManager.cleanCurrentScene(), this.displayer.cleanCurrentScene(W));
      }
    };
    return {
      ...c,
      callbacks: {
        on: c.callbacksOn.bind(c),
        once: c.callbacksOnce.bind(c),
        off: c.callbacksOff.bind(c),
        forwardTo: c.displayer.callbacks.forwardTo
      }
    };
  }
  static onCreate(d) {
    const l = d.displayer;
    d == null || d.init(l);
  }
  // static onDestroy(plugin: BezierPencilPlugin) {}
  /**
   * 房间实例化时，将当前实例对displayer外部API的添加内部处理逻辑;
   * @param displayer
   */
  // static effectInstance(displayer:Room) {
  //     const _cleanCurrentScene = displayer.cleanCurrentScene;
  //     displayer.cleanCurrentScene = function(retainPpt){
  //         BezierPencilPlugin.logger.info(`[BezierPencilPlugin plugin] cleanCurrentScene`);
  //         BezierPencilPlugin.currentManager.cleanCurrentScene();
  //         _cleanCurrentScene.call(displayer,retainPpt);
  //     }
  // }
  constructor(d) {
    super(d), Object.defineProperty(this, "onPhaseChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s === Bs.Disconnected && (this.displayer.callbacks.off(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.off("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.off("onPhaseChanged", this.onPhaseChanged), Cl.invisiblePlugins.delete(this.displayer), Cl.currentManager.destroy());
      }
    }), Object.defineProperty(this, "updateRoomWritable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        Cl.currentManager.onWritableChange(this.displayer.isWritable);
      }
    }), Object.defineProperty(this, "roomStateChangeListener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (s) => {
        s.cameraState && Cl.currentManager.onCameraChange(s.cameraState), s.memberState && Cl.currentManager.onMemberChange(s.memberState), s.sceneState && Cl.currentManager.onSceneChange(s.sceneState);
      }
    }), Object.defineProperty(this, "createCurrentManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        Cl.currentManager && Cl.currentManager.destroy();
        const s = new qo(this, Cl.options);
        s.init(), Cl.currentManager = s, Cl.logger.info("[BezierPencilPlugin plugin] refresh currentSlideManager object");
      }
    });
    const l = Cl.invisiblePlugins.get(this.displayer);
    l && Os(l, this);
  }
  get isReplay() {
    return es(this.displayer);
  }
  get callbackName() {
    return this.isReplay ? "onPlayerStateChanged" : "onRoomStateChanged";
  }
  init(d) {
    const l = Ds(d.getInvisiblePlugin(Cl.kind));
    if (Cl.invisiblePlugins.set(d, l), this.createCurrentManager(), $l(d)) {
      const s = d.state;
      s != null && s.memberState && Cl.currentManager.onMemberChange(s.memberState);
    }
    this.displayer.callbacks.on(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.on("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.on("onPhaseChanged", this.onPhaseChanged), this.displayer.callbacks.on("onCanUndoStepsUpdate", (s) => {
      var c;
      (c = Cl.currentManager.commiter) == null || c.addSdkUndoData(s);
    });
  }
}
Object.defineProperty(Cl, "kind", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "bezier-pencil-plugin"
});
Object.defineProperty(Cl, "invisiblePlugins", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /* @__PURE__ */ new WeakMap()
});
Object.defineProperty(Cl, "logger", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    info: console.log,
    warn: console.warn,
    error: console.error
  }
});
class Bl extends Xt {
  constructor(d, l, s) {
    var c, W;
    if (super(d, l), Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "threadEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "layerOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "msgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "offscreenCanvasOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "originalPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [0, 0]
    }), Object.defineProperty(this, "cameraOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localPointsBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "taskBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "currentToolsData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "currentLocalWorkData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "subWorkerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "wokerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "maxDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "cacheDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "reRenders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "bgCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "floatCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxLayerIndex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "methodBuilder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "localEventTimerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "undoTickerId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "snapshotMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), this.bgCanvas = d.canvasBgRef, this.floatCanvas = d.canvasFloatRef, this.bgCanvas && this.floatCanvas) {
      this.pluginOptions = s, Bl.maxLastSyncTime = (((c = s == null ? void 0 : s.syncOpt) == null ? void 0 : c.interval) || Bl.maxLastSyncTime) * 0.5, this.msgEmitter = new et();
      const u = {
        ...Bl.defaultScreenCanvasOpt,
        ...(W = this.pluginOptions) == null ? void 0 : W.canvasOpt,
        width: this.bgCanvas.offsetWidth,
        height: this.bgCanvas.offsetHeight
      };
      this.offscreenCanvasOpt = u, this.layerOpt = Bl.defauleLayerOpt, this.setLayerOpt(this.layerOpt), this.setCurrentLocalWorkData({
        workId: void 0,
        workState: Ll.Pending
      }), this.internalMsgEmitterListener(), this.on();
    }
  }
  internalMsgEmitterListener() {
    var d, l, s;
    this.collector && (this.methodBuilder = new Ml([
      ul.CopyNode,
      ul.SetColorNode,
      ul.DeleteNode,
      ul.RotateNode,
      ul.ScaleNode,
      ul.TranslateNode,
      ul.ZIndexActive,
      ul.ZIndexNode,
      ul.RotateNode
    ]).registerForMainEngine(pl.MainEngine, this, this.collector)), (d = yl.InternalMsgEmitter) == null || d.on([pl.MainEngine, ul.CreateScene], this.createSceneLintener.bind(this)), (l = yl.InternalMsgEmitter) == null || l.on([pl.MainEngine, ul.OriginalEvent], this.originalEventLintener.bind(this)), (s = yl.InternalMsgEmitter) == null || s.on([pl.FloatBar, ul.ShowFloatBar], this.showFloatBar.bind(this));
  }
  showFloatBar(d) {
    d ? window.addEventListener("beforeunload", this.removeSelectorFromStore.bind(this)) : window.removeEventListener("beforeunload", this.removeSelectorFromStore.bind(this));
  }
  removeSelectorFromStore() {
    this.collector.dispatch({
      type: hl.Select,
      selectIds: void 0
    });
  }
  internalMsgEmitterRemoveListener() {
    var d, l, s;
    (d = this.methodBuilder) == null || d.destroy(), (l = yl.InternalMsgEmitter) == null || l.off([pl.MainEngine, ul.CreateScene], this.createSceneLintener.bind(this)), (s = yl.InternalMsgEmitter) == null || s.off([pl.MainEngine, ul.OriginalEvent], this.originalEventLintener.bind(this));
  }
  createSceneLintener(d, l, s) {
    this.offscreenCanvasOpt = {
      ...this.offscreenCanvasOpt,
      width: d,
      height: l
    }, this.dpr = s, this.originalPoint = [d / 2, l / 2], this.cameraOpt = {
      centerX: 0,
      centerY: 0,
      scale: 1,
      width: d,
      height: l
    }, this.createThreadEngine(), this.createOptimizationWorker();
  }
  originalEventLintener(d, l) {
    switch (d) {
      case Ll.Start:
        this.onLocalEventStart(l);
        break;
      case Ll.Doing:
        this.onLocalEventDoing(l);
        break;
      case Ll.Done:
        this.onLocalEventEnd(l);
        break;
    }
  }
  destroySubWorker() {
    this.subWorker && (this.subWorker.terminate(), this.subWorker = void 0);
  }
  createThreadEngine() {
    this.taskBatchData.set("Init", {
      msgType: hl.Init,
      dataType: Fl.Local,
      offscreenCanvasOpt: this.offscreenCanvasOpt,
      layerOpt: this.layerOpt,
      dpr: this.dpr,
      isRunSubWork: !0
    }), this.runAnimation();
  }
  render(d) {
    var l, s, c, W, u, e, n, G;
    for (const y of d) {
      const { rect: a, imageBitmap: I, isClear: h, isUnClose: S, drawCanvas: p, clearCanvas: X, offset: V } = y;
      if (a) {
        const i = a.w * this.dpr, b = a.h * this.dpr, t = a.x * this.dpr, m = a.y * this.dpr;
        if (h)
          if (X === ad.Selector)
            (s = (l = this.displayer.floatBarCanvasRef.current) == null ? void 0 : l.getContext("2d")) == null || s.clearRect(0, 0, i, b);
          else {
            const R = X === ad.Float ? (c = this.floatCanvas) == null ? void 0 : c.getContext("2d") : (W = this.bgCanvas) == null ? void 0 : W.getContext("2d");
            R == null || R.clearRect(t, m, i, b);
          }
        if (p && I)
          if (p === ad.Selector) {
            const R = ((V == null ? void 0 : V.x) || 0) * this.dpr, x = ((V == null ? void 0 : V.y) || 0) * this.dpr;
            (e = (u = this.displayer.floatBarCanvasRef.current) == null ? void 0 : u.getContext("2d")) == null || e.drawImage(I, 0, 0, i, b, R, x, i, b);
          } else {
            const R = p === ad.Float ? (n = this.floatCanvas) == null ? void 0 : n.getContext("2d") : (G = this.bgCanvas) == null ? void 0 : G.getContext("2d");
            R == null || R.drawImage(I, 0, 0, i, b, t, m, i, b);
          }
        if (S)
          return;
        I == null || I.close();
      }
    }
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  setLayerOpt(d) {
    this.layerOpt = d;
  }
  updateCanvas(d) {
    const { width: l, height: s } = d;
    this.bgCanvas && this.floatCanvas && (this.bgCanvas.width = l * this.dpr, this.bgCanvas.height = s * this.dpr, this.floatCanvas.width = l * this.dpr, this.floatCanvas.height = s * this.dpr), this.originalPoint = [l * 0.5, s * 0.5], this.offscreenCanvasOpt.width = l, this.offscreenCanvasOpt.height = s;
  }
  pushPoint(d) {
    this.localPointsBatchData.push(d[0], d[1]);
  }
  transformToScenePoint(d) {
    const l = d, { scale: s, centerX: c, centerY: W } = this.cameraOpt;
    return this.originalPoint && (l[0] = (d[0] - this.originalPoint[0]) / s + c, l[1] = (d[1] - this.originalPoint[1]) / s + W), l;
  }
  getCameraOpt() {
    return this.cameraOpt;
  }
  getDpr() {
    return this.dpr;
  }
  initSyncData(d) {
    var s, c, W;
    const l = (s = this.collector) == null ? void 0 : s.storage;
    if (l) {
      for (const u of Object.keys(l).filter((e) => this.collector.getLocalId(e) !== "selector")) {
        d && d(u, l[u]);
        const e = (c = l[u]) == null ? void 0 : c.type;
        if (e && u) {
          const n = Ol(l[u]);
          n.workId = u, n.msgType = e, n.dataType = Fl.Service, n.useAnimation = !1, this.taskBatchData.set(`${n.dataType},${n.msgType},${n.workId}`, n), (W = n.opt) != null && W.zIndex && (this.maxLayerIndex = Math.max(this.maxLayerIndex, n.opt.zIndex));
        }
      }
      this.runAnimation();
    }
  }
  getRelevantWork(d) {
    let l;
    for (const [s, c] of Object.entries(d))
      if (c) {
        const { newValue: W, oldValue: u } = c;
        if (!W && u && Object.keys(d).some((n) => n !== s && n.indexOf(`${s}_s_`) > -1 ? (l = s, !0) : !1))
          break;
      }
    return l;
  }
  onServiceDerive(d, l, s) {
    const { newValue: c, oldValue: W } = l, u = Ol(c) || {}, e = d;
    let n = u.type;
    if (!(!c && W && (n = hl.RemoveNode, W.toolsType === Jl.LaserPen))) {
      if (n && e) {
        const G = u;
        G.workId = this.collector.isOwn(e) ? this.collector.getLocalId(e) : e, G.msgType = n, G.dataType = Fl.Service, G.selectIds && (G.selectIds = G.selectIds.map((y) => this.collector.isOwn(y) ? this.collector.getLocalId(y) : y)), s === d ? setTimeout(() => {
          this.taskBatchData.set(`${G.dataType},${G.msgType},${G.workId}`, G), this.runAnimation();
        }, 16) : this.taskBatchData.set(`${G.dataType},${G.msgType},${G.workId}`, G);
      }
      this.runAnimation();
    }
  }
  onLocalEventEnd(d) {
    var s;
    const l = this.currentLocalWorkData.workState;
    if (!(l === Ll.Freeze || l === Ll.Unwritable) && (l === Ll.Start || l === Ll.Doing)) {
      const c = this.transformToScenePoint(d);
      this.pushPoint(c), this.localEventTimerId = setTimeout(() => {
        this.localEventTimerId = void 0, this.setCurrentLocalWorkData({ workId: this.currentLocalWorkData.workId, workState: Ll.Done }), this.runAnimation();
      }, 0), this.currentToolsData.toolsType === Jl.Selector && ((s = yl.InternalMsgEmitter) == null || s.emit([pl.FloatBar, ul.ZIndexFloatBar], 2));
    }
  }
  onLocalEventDoing(d) {
    let l = this.currentLocalWorkData.workState;
    if (!(l === Ll.Freeze || l === Ll.Unwritable) && (l === Ll.Start && (l = Ll.Doing, this.setCurrentLocalWorkData({ workId: this.currentLocalWorkData.workId, workState: l })), l === Ll.Doing || this.localEventTimerId)) {
      const s = this.transformToScenePoint(d);
      this.pushPoint(s), this.localEventTimerId || this.runAnimation();
    }
  }
  onLocalEventStart(d) {
    var u, e;
    const { workState: l } = this.currentLocalWorkData;
    if (l === Ll.Freeze || l === Ll.Unwritable)
      return;
    const s = this.currentToolsData.toolsType === Jl.Selector ? "selector" : Date.now(), c = Ol(this.currentToolsData.toolsOpt);
    this.currentToolsData.toolsType === Jl.Pencil && (this.maxLayerIndex = this.maxLayerIndex + 10, c.zIndex = this.maxLayerIndex), this.setCurrentLocalWorkData({
      workId: s,
      workState: Ll.Start
    }, hl.CreateWork);
    const W = this.transformToScenePoint(d);
    this.pushPoint(W), this.maxDrawCount = 0, this.wokerDrawCount = 0, this.reRenders.length = 0, this.consume(), (this.currentToolsData.toolsType === Jl.Pencil || this.currentToolsData.toolsType === Jl.Eraser || this.currentToolsData.toolsType === Jl.Selector) && (this.currentToolsData.toolsType === Jl.Selector ? this.undoTickerId = Date.now() : this.undoTickerId = s, rl.emitter.emit("undoTickerStart", this.undoTickerId)), this.currentToolsData.toolsType === Jl.Pencil || this.currentToolsData.toolsType === Jl.LaserPen ? (u = this.collector) == null || u.dispatch({
      type: hl.CreateWork,
      workId: s,
      toolsType: this.currentToolsData.toolsType,
      opt: this.currentToolsData.toolsOpt
    }) : this.currentToolsData.toolsType === Jl.Selector && ((e = yl.InternalMsgEmitter) == null || e.emit([pl.FloatBar, ul.ZIndexFloatBar], -1));
  }
  consume() {
    this.animationId = void 0;
    const d = this.currentLocalWorkData.workState;
    let l = !1;
    if (!this.localEventTimerId) {
      if (this.localPointsBatchData.length) {
        const s = this.currentToolsData.toolsType === Jl.Pencil || this.currentToolsData.toolsType === Jl.LaserPen;
        this.wokerDrawCount !== 1 / 0 && this.wokerDrawCount <= this.subWorkerDrawCount && this.cacheDrawCount < this.maxDrawCount && (l = !0), this.maxDrawCount || (l = !0), l && (this.cacheDrawCount = this.maxDrawCount, this.taskBatchData.set(this.currentLocalWorkData.workId, {
          op: this.localPointsBatchData.map((c) => c),
          workState: d,
          workId: this.currentLocalWorkData.workId,
          dataType: Fl.Local,
          msgType: hl.DrawWork,
          isRunSubWork: s,
          undoTickerId: d === Ll.Done && this.undoTickerId || void 0
        }), this.localPointsBatchData.length = 0);
      }
      this.taskBatchData.size && (this.post(this.taskBatchData), this.taskBatchData.clear(), this.undoTickerId && d === Ll.Done && (this.undoTickerId = void 0));
    }
    (this.taskBatchData.size || this.localPointsBatchData.length) && (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  post(d) {
    var s;
    this.msgEmitter.postMessage(d);
    const l = /* @__PURE__ */ new Map();
    for (const [c, W] of d.entries())
      (c === "Init" || c === "ClearAll" || c === "UpdateCamera" || W.isRunSubWork) && l.set(c, W);
    l.size && ((s = this.subWorker) == null || s.postMessage(l));
  }
  on() {
    this.msgEmitter.onmessage = (d) => {
      if (d.data) {
        const { render: l, sp: s, drawCount: c } = d.data;
        if (s != null && s.length && this.collectorSyncData(s), !c && l) {
          this.render(l);
          return;
        }
        c && (this.wokerDrawCount = c, this.wokerDrawCount < 1 / 0 ? this.maxDrawCount = Math.max(this.maxDrawCount, this.wokerDrawCount) : this.maxDrawCount = 0, l != null && l.length && (this.render(l), this.wokerDrawCount < this.subWorkerDrawCount && (this.reRenders.forEach((W) => {
          W.isUnClose = !1;
        }), this.render(this.reRenders), this.reRenders.length = 0)));
      }
    };
  }
  createOptimizationWorker() {
    this.subWorker = new at(), this.subWorker.onmessage = (d) => {
      if (d.data) {
        const { render: l, drawCount: s, sp: c } = d.data;
        if (c != null && c.length && this.collectorSyncData(c), !s && (l != null && l.length)) {
          this.render(l);
          return;
        }
        s && (this.subWorkerDrawCount = s, this.wokerDrawCount < 1 / 0 && (this.maxDrawCount = Math.max(this.maxDrawCount, this.subWorkerDrawCount)), l != null && l.length && (this.subWorkerDrawCount > this.wokerDrawCount && (l.forEach((W) => W.isUnClose = !0), this.reRenders.push(...l)), this.wokerDrawCount < 1 / 0 && this.render(l)));
      }
    };
  }
  collectorSyncData(d) {
    var s, c;
    let l = !1;
    for (const W of d) {
      const { type: u, selectIds: e, opt: n, padding: G, selectRect: y, nodeColor: a, nodeOpactiy: I, willSyncService: h, isSync: S, undoTickerId: p, imageBitmap: X, scenePath: V, canvasHeight: i, canvasWidth: b } = W;
      switch (u) {
        case hl.Select:
          const t = e != null && e.length ? { ...y, selectIds: e, canvasHeight: i, canvasWidth: b } : void 0;
          t && (n != null && n.color) && (t.color = n.color), t && G && (t.padding = G), t && a && (t.nodeColor = a), t && (n != null && n.opacity) && (t.opacity = n.opacity), t && I && (t.opacity = I), (s = yl.InternalMsgEmitter) == null || s.emit([pl.FloatBar, ul.ShowFloatBar], !!t, t), h && ((c = this.collector) == null || c.dispatch({ type: u, selectIds: e, opt: n, isSync: S }), p && rl.emitter.emit("undoTickerEnd", p));
          break;
        case hl.Snapshot:
          if (X && V) {
            const m = this.snapshotMap.get(V);
            m && m(X);
          }
          break;
        default:
          l = !0;
          break;
      }
    }
    l && ii(() => {
      this.collectorAsyncData(d);
    }, Bl.maxLastSyncTime);
  }
  collectorAsyncData(d) {
    var l, s, c, W;
    for (const u of d) {
      const { type: e, op: n, workId: G, index: y, removeIds: a, ops: I, opt: h, updateNodeOpt: S, toolsType: p, isSync: X, undoTickerId: V } = u;
      switch (e) {
        case hl.DrawWork:
          n != null && n.length && G && typeof y == "number" && ((l = this.collector) == null || l.dispatch({
            type: e,
            op: n,
            workId: G,
            index: y,
            isSync: X
          }));
          break;
        case hl.FullWork:
          I && ((s = this.collector) == null || s.dispatch({ type: e, ops: I, workId: G, updateNodeOpt: S, opt: h, toolsType: p, isSync: X }));
          break;
        case hl.UpdateNode:
          (S || h || I) && ((c = this.collector) == null || c.dispatch({ type: e, updateNodeOpt: S, workId: G, opt: h, ops: I, isSync: X }));
          break;
        case hl.RemoveNode:
          (n || a != null && a.length) && ((W = this.collector) == null || W.dispatch({ type: e, removeIds: a, isSync: X }));
          break;
      }
      V && rl.emitter.emit("undoTickerEnd", V);
    }
  }
  async clearAll(d = !1) {
    var l;
    this.taskBatchData.set("ClearAll", {
      dataType: Fl.Local,
      msgType: hl.Clear
    }), this.runAnimation(), d || (this.undoTickerId = Date.now(), rl.emitter.emit("undoTickerStart", this.undoTickerId), (l = this.collector) == null || l.dispatch({
      type: hl.Clear
    }), rl.emitter.emit("undoTickerEnd", this.undoTickerId)), this.maxLayerIndex = 0, await new Promise((s) => {
      setTimeout(() => {
        var c;
        if (this.bgCanvas && this.floatCanvas) {
          const W = this.bgCanvas.getContext("2d");
          W == null || W.clearRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
          const u = this.floatCanvas.getContext("2d");
          u == null || u.clearRect(0, 0, this.floatCanvas.width, this.floatCanvas.height), (c = yl.InternalMsgEmitter) == null || c.emit([pl.FloatBar, ul.ShowFloatBar], !1);
        }
        s(!0);
      }, 100);
    });
  }
  unabled() {
    this.setCurrentLocalWorkData({ workState: Ll.Freeze, workId: void 0 });
  }
  abled() {
    this.setCurrentLocalWorkData({ workState: Ll.Pending, workId: void 0 });
  }
  destroy() {
    var d;
    (d = this.msgEmitter) == null || d.terminate(), this.destroySubWorker(), this.internalMsgEmitterRemoveListener();
  }
  updateNode(d, l) {
    this.taskBatchData.set(`${hl.UpdateNode},${d}`, {
      msgType: hl.UpdateNode,
      workId: d,
      updateNodeOpt: l,
      dataType: Fl.Local
    }), this.runAnimation();
  }
  setCurrentLocalWorkData(d, l = hl.None) {
    super.setCurrentLocalWorkData(d);
    const { workState: s, workId: c } = d;
    if (s !== Ll.Unwritable && l !== hl.None) {
      const W = this.currentToolsData.toolsType;
      this.taskBatchData.set(`${l},${c}`, {
        msgType: l,
        workId: c,
        toolsType: W,
        opt: { ...this.currentToolsData.toolsOpt, syncUnitTime: Bl.maxLastSyncTime },
        dataType: Fl.Local,
        isRunSubWork: W === Jl.Pencil || W === Jl.LaserPen
      }), this.runAnimation();
    }
  }
  setCurrentToolsData(d) {
    super.setCurrentToolsData(d);
    const l = d.toolsType;
    this.taskBatchData.set("UpdateTools", {
      msgType: hl.UpdateTools,
      dataType: Fl.Local,
      toolsType: l,
      opt: { ...d.toolsOpt, syncUnitTime: Bl.maxLastSyncTime },
      isRunSubWork: l === Jl.Pencil || l === Jl.LaserPen
    }), this.runAnimation();
  }
  setCameraOpt(d) {
    super.setCameraOpt(d);
    const { width: l, height: s } = d;
    (l !== this.offscreenCanvasOpt.width || s !== this.offscreenCanvasOpt.height) && (this.bgCanvas && (this.bgCanvas.style.width = `${l}px`, this.bgCanvas.style.height = `${s}px`), this.floatCanvas && (this.floatCanvas.style.width = `${l}px`, this.floatCanvas.style.height = `${s}px`), this.updateCanvas({ width: l, height: s })), this.taskBatchData.set("UpdateCamera", {
      msgType: hl.UpdateCamera,
      dataType: Fl.Local,
      cameraOpt: d,
      isRunSubWork: !0
    }), this.runAnimation();
  }
  getSnapshot(d, l, s, c) {
    var u, e;
    if (!((u = this.snapshotMap) == null ? void 0 : u.get(d))) {
      const n = (e = this.collector.plugin) == null ? void 0 : e.attributes[d];
      if (n) {
        const G = {
          msgType: hl.Snapshot,
          dataType: Fl.Local,
          scenePath: d,
          scenes: n,
          w: l || this.cameraOpt.width,
          h: s || this.cameraOpt.height,
          cameraOpt: c && {
            ...c,
            width: this.cameraOpt.width,
            height: this.cameraOpt.height
          } || this.cameraOpt,
          isRunSubWork: !0
        };
        return this.taskBatchData.set(`${G.scenePath}`, G), this.runAnimation(), new Promise((y) => {
          this.snapshotMap.set(d, y);
        }).then((y) => (this.snapshotMap.delete(d), y));
      }
    }
  }
}
Object.defineProperty(Bl, "defaultScreenCanvasOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    autoRender: !1,
    contextType: Od.Canvas2d
    // bufferSize: 5000
  }
});
Object.defineProperty(Bl, "defauleLayerOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    offscreen: !0,
    handleEvent: !1,
    depth: !1
  }
});
Object.defineProperty(Bl, "maxLastSyncTime", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
export {
  yl as BezierPencilDisplayer,
  Cl as BezierPencilPlugin,
  od as DisplayStateEnum,
  Od as ECanvasContextType,
  ad as ECanvasShowType,
  Fl as EDataType,
  hl as EPostMessageType,
  Ii as EScaleDirection,
  hi as EShapeDataTypeKey,
  Vi as ESpriteNodeKey,
  _l as EStrokeType,
  Jl as EToolsKey,
  ul as EmitEventType,
  Ll as EvevtWorkState,
  pl as InternalMsgEmitterType,
  Bl as MainEngineForWorker
};
