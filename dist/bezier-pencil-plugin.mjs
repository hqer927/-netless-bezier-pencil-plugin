var Hb = Object.defineProperty;
var Mb = (n, l, i) => l in n ? Hb(n, l, { enumerable: !0, configurable: !0, writable: !0, value: i }) : n[l] = i;
var dl = (n, l, i) => (Mb(n, typeof l != "symbol" ? l + "" : l, i), i), Gd = (n, l, i) => {
  if (!l.has(n))
    throw TypeError("Cannot " + i);
};
var _i = (n, l, i) => (Gd(n, l, "read from private field"), i ? i.call(n) : l.get(n)), Xl = (n, l, i) => {
  if (l.has(n))
    throw TypeError("Cannot add the same private member more than once");
  l instanceof WeakSet ? l.add(n) : l.set(n, i);
}, hl = (n, l, i, c) => (Gd(n, l, "write to private field"), c ? c.call(n, i) : l.set(n, i), i);
var Vd = (n, l, i) => (Gd(n, l, "access private method"), i);
import { toJS as gd, autorun as zb, isRoom as Kd, ApplianceNames as Il, InvisiblePlugin as kb, RoomPhase as fb, isPlayer as vb } from "white-web-sdk";
var el;
(function(n) {
  n[n.pedding = 0] = "pedding", n[n.mounted = 1] = "mounted", n[n.update = 2] = "update", n[n.unmounted = 3] = "unmounted";
})(el || (el = {}));
var Bl;
(function(n) {
  n[n.Normal = 0] = "Normal", n[n.Stroke = 1] = "Stroke", n[n.Dotted = 2] = "Dotted", n[n.LongDotted = 3] = "LongDotted";
})(Bl || (Bl = {}));
var sl;
(function(n) {
  n[n.Pencil = 1] = "Pencil", n[n.Eraser = 2] = "Eraser", n[n.Selector = 3] = "Selector", n[n.Clicker = 4] = "Clicker", n[n.Arrow = 5] = "Arrow", n[n.Hand = 6] = "Hand", n[n.LaserPen = 7] = "LaserPen";
})(sl || (sl = {}));
var ps;
(function(n) {
  n[n.Path = 0] = "Path", n[n.Rect = 1] = "Rect";
})(ps || (ps = {}));
var Ai;
(function(n) {
  n[n.Local = 1] = "Local", n[n.Service = 2] = "Service";
})(Ai || (Ai = {}));
var Bi;
(function(n) {
  n[n.Pending = 0] = "Pending", n[n.Start = 1] = "Start", n[n.Doing = 2] = "Doing", n[n.Done = 3] = "Done", n[n.Freeze = 4] = "Freeze", n[n.Unwritable = 5] = "Unwritable";
})(Bi || (Bi = {}));
var Fi;
(function(n) {
  n[n.Init = 0] = "Init", n[n.Transform = 1] = "Transform", n[n.UpdateTools = 2] = "UpdateTools", n[n.UpdateScene = 3] = "UpdateScene", n[n.CreateWork = 4] = "CreateWork", n[n.DrawWork = 5] = "DrawWork", n[n.FullWork = 6] = "FullWork", n[n.UpdateWork = 7] = "UpdateWork", n[n.UpdateNode = 8] = "UpdateNode", n[n.RemoveNode = 9] = "RemoveNode", n[n.Clear = 10] = "Clear", n[n.Select = 11] = "Select", n[n.Destroy = 12] = "Destroy", n[n.None = 13] = "None", n[n.CombineDraw = 14] = "CombineDraw";
})(Fi || (Fi = {}));
var Ls;
(function(n) {
  n[n.Path = 0] = "Path", n[n.Rect = 1] = "Rect", n[n.Texture = 2] = "Texture";
})(Ls || (Ls = {}));
var Sd;
(function(n) {
  n.Webgl2 = "webgl2", n.Webgl = "webgl", n.Canvas2d = "2d";
})(Sd || (Sd = {}));
var ys;
(function(n) {
  n.immediately = "immediately", n.continuous = "continuous";
})(ys || (ys = {}));
var Ol;
(function(n) {
  n[n.Float = 0] = "Float", n[n.Bg = 1] = "Bg";
})(Ol || (Ol = {}));
var Ti = (
  /******/
  function(n) {
    var l = {};
    function i(c) {
      if (l[c])
        return l[c].exports;
      var Z = l[c] = {
        /******/
        i: c,
        /******/
        l: !1,
        /******/
        exports: {}
        /******/
      };
      return n[c].call(Z.exports, Z, Z.exports, i), Z.l = !0, Z.exports;
    }
    return i.m = n, i.c = l, i.d = function(c, Z, L) {
      i.o(c, Z) || Object.defineProperty(c, Z, { enumerable: !0, get: L });
    }, i.r = function(c) {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(c, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(c, "__esModule", { value: !0 });
    }, i.t = function(c, Z) {
      if (Z & 1 && (c = i(c)), Z & 8 || Z & 4 && typeof c == "object" && c && c.__esModule)
        return c;
      var L = /* @__PURE__ */ Object.create(null);
      if (i.r(L), Object.defineProperty(L, "default", { enumerable: !0, value: c }), Z & 2 && typeof c != "string")
        for (var K in c)
          i.d(L, K, (function(u) {
            return c[u];
          }).bind(null, K));
      return L;
    }, i.n = function(c) {
      var Z = c && c.__esModule ? (
        /******/
        function() {
          return c.default;
        }
      ) : (
        /******/
        function() {
          return c;
        }
      );
      return i.d(Z, "a", Z), Z;
    }, i.o = function(c, Z) {
      return Object.prototype.hasOwnProperty.call(c, Z);
    }, i.p = "/js/", i(i.s = 0);
  }([
    /* 0 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "version", function() {
        return P;
      }), i.d(l, "helpers", function() {
        return M;
      }), i.d(l, "createElement", function() {
        return N;
      }), i.d(l, "isSpriteNode", function() {
        return R;
      }), i.d(l, "registerNode", function() {
        return x;
      });
      var c = i(12);
      i.d(l, "ENV", function() {
        return c.ENV;
      });
      var Z = i(68);
      i.d(l, "requestAnimationFrame", function() {
        return Z.requestAnimationFrame;
      }), i.d(l, "cancelAnimationFrame", function() {
        return Z.cancelAnimationFrame;
      });
      var L = i(70);
      i.d(l, "Node", function() {
        return L.default;
      });
      var K = i(217);
      i.d(l, "Cloud", function() {
        return K.default;
      });
      var u = i(219);
      i.d(l, "Block", function() {
        return u.default;
      });
      var a = i(224);
      i.d(l, "Sprite", function() {
        return a.default;
      });
      var e = i(226);
      i.d(l, "Path", function() {
        return e.default;
      });
      var r = i(229);
      i.d(l, "Rect", function() {
        return r.default;
      });
      var X = i(231);
      i.d(l, "Triangle", function() {
        return X.default;
      });
      var W = i(236);
      i.d(l, "Parallel", function() {
        return W.default;
      });
      var p = i(238);
      i.d(l, "Regular", function() {
        return p.default;
      });
      var C = i(240);
      i.d(l, "Star", function() {
        return C.default;
      });
      var I = i(242);
      i.d(l, "Ellipse", function() {
        return I.default;
      });
      var o = i(244);
      i.d(l, "Arc", function() {
        return o.default;
      });
      var G = i(246);
      i.d(l, "Ring", function() {
        return G.default;
      });
      var d = i(232);
      i.d(l, "Polyline", function() {
        return d.default;
      });
      var t = i(248);
      i.d(l, "Label", function() {
        return t.default;
      });
      var s = i(250);
      i.d(l, "Group", function() {
        return s.default;
      });
      var b = i(286);
      i.d(l, "Layer", function() {
        return b.default;
      });
      var V = i(287);
      i.d(l, "SpriteSvg", function() {
        return V.default;
      });
      var S = i(289);
      i.d(l, "LayerWorker", function() {
        return S.default;
      });
      var Y = i(290);
      i.d(l, "Scene", function() {
        return Y.default;
      });
      var T = i(213), y = i(221);
      i.d(l, "Color", function() {
        return y.Color;
      }), i.d(l, "Gradient", function() {
        return y.Gradient;
      });
      var J = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const N = T.default.createElement, R = T.default.isSpriteNode, x = T.default.registerNode, M = {
        parseColor: y.parseColor,
        sizeToPixel: J.sizeToPixel,
        toArray: J.toArray,
        toString: J.toString,
        toNumber: J.toNumber
      };
      let Q;
      Q = "3.8.3";
      const P = Q;
    },
    /* 1 */
    /***/
    function(n, l, i) {
      i.r(l);
      var c = i(2);
      i.d(l, "glMatrix", function() {
        return c;
      });
      var Z = i(3);
      i.d(l, "mat2", function() {
        return Z;
      });
      var L = i(4);
      i.d(l, "mat2d", function() {
        return L;
      });
      var K = i(5);
      i.d(l, "mat3", function() {
        return K;
      });
      var u = i(6);
      i.d(l, "mat4", function() {
        return u;
      });
      var a = i(7);
      i.d(l, "quat", function() {
        return a;
      });
      var e = i(10);
      i.d(l, "quat2", function() {
        return e;
      });
      var r = i(11);
      i.d(l, "vec2", function() {
        return r;
      });
      var X = i(8);
      i.d(l, "vec3", function() {
        return X;
      });
      var W = i(9);
      i.d(l, "vec4", function() {
        return W;
      });
    },
    /* 2 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "EPSILON", function() {
        return c;
      }), i.d(l, "ARRAY_TYPE", function() {
        return Z;
      }), i.d(l, "RANDOM", function() {
        return L;
      }), i.d(l, "setMatrixArrayType", function() {
        return K;
      }), i.d(l, "toRadian", function() {
        return a;
      }), i.d(l, "equals", function() {
        return e;
      });
      var c = 1e-6, Z = typeof Float32Array < "u" ? Float32Array : Array, L = Math.random;
      function K(r) {
        Z = r;
      }
      var u = Math.PI / 180;
      function a(r) {
        return r * u;
      }
      function e(r, X) {
        return Math.abs(r - X) <= c * Math.max(1, Math.abs(r), Math.abs(X));
      }
      Math.hypot || (Math.hypot = function() {
        for (var r = 0, X = arguments.length; X--; )
          r += arguments[X] * arguments[X];
        return Math.sqrt(r);
      });
    },
    /* 3 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return Z;
      }), i.d(l, "clone", function() {
        return L;
      }), i.d(l, "copy", function() {
        return K;
      }), i.d(l, "identity", function() {
        return u;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "set", function() {
        return e;
      }), i.d(l, "transpose", function() {
        return r;
      }), i.d(l, "invert", function() {
        return X;
      }), i.d(l, "adjoint", function() {
        return W;
      }), i.d(l, "determinant", function() {
        return p;
      }), i.d(l, "multiply", function() {
        return C;
      }), i.d(l, "rotate", function() {
        return I;
      }), i.d(l, "scale", function() {
        return o;
      }), i.d(l, "fromRotation", function() {
        return G;
      }), i.d(l, "fromScaling", function() {
        return d;
      }), i.d(l, "str", function() {
        return t;
      }), i.d(l, "frob", function() {
        return s;
      }), i.d(l, "LDU", function() {
        return b;
      }), i.d(l, "add", function() {
        return V;
      }), i.d(l, "subtract", function() {
        return S;
      }), i.d(l, "exactEquals", function() {
        return Y;
      }), i.d(l, "equals", function() {
        return T;
      }), i.d(l, "multiplyScalar", function() {
        return y;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return J;
      }), i.d(l, "mul", function() {
        return N;
      }), i.d(l, "sub", function() {
        return R;
      });
      var c = i(2);
      function Z() {
        var x = new c.ARRAY_TYPE(4);
        return c.ARRAY_TYPE != Float32Array && (x[1] = 0, x[2] = 0), x[0] = 1, x[3] = 1, x;
      }
      function L(x) {
        var M = new c.ARRAY_TYPE(4);
        return M[0] = x[0], M[1] = x[1], M[2] = x[2], M[3] = x[3], M;
      }
      function K(x, M) {
        return x[0] = M[0], x[1] = M[1], x[2] = M[2], x[3] = M[3], x;
      }
      function u(x) {
        return x[0] = 1, x[1] = 0, x[2] = 0, x[3] = 1, x;
      }
      function a(x, M, Q, P) {
        var D = new c.ARRAY_TYPE(4);
        return D[0] = x, D[1] = M, D[2] = Q, D[3] = P, D;
      }
      function e(x, M, Q, P, D) {
        return x[0] = M, x[1] = Q, x[2] = P, x[3] = D, x;
      }
      function r(x, M) {
        if (x === M) {
          var Q = M[1];
          x[1] = M[2], x[2] = Q;
        } else
          x[0] = M[0], x[1] = M[2], x[2] = M[1], x[3] = M[3];
        return x;
      }
      function X(x, M) {
        var Q = M[0], P = M[1], D = M[2], _ = M[3], F = Q * _ - D * P;
        return F ? (F = 1 / F, x[0] = _ * F, x[1] = -P * F, x[2] = -D * F, x[3] = Q * F, x) : null;
      }
      function W(x, M) {
        var Q = M[0];
        return x[0] = M[3], x[1] = -M[1], x[2] = -M[2], x[3] = Q, x;
      }
      function p(x) {
        return x[0] * x[3] - x[2] * x[1];
      }
      function C(x, M, Q) {
        var P = M[0], D = M[1], _ = M[2], F = M[3], v = Q[0], O = Q[1], li = Q[2], ii = Q[3];
        return x[0] = P * v + _ * O, x[1] = D * v + F * O, x[2] = P * li + _ * ii, x[3] = D * li + F * ii, x;
      }
      function I(x, M, Q) {
        var P = M[0], D = M[1], _ = M[2], F = M[3], v = Math.sin(Q), O = Math.cos(Q);
        return x[0] = P * O + _ * v, x[1] = D * O + F * v, x[2] = P * -v + _ * O, x[3] = D * -v + F * O, x;
      }
      function o(x, M, Q) {
        var P = M[0], D = M[1], _ = M[2], F = M[3], v = Q[0], O = Q[1];
        return x[0] = P * v, x[1] = D * v, x[2] = _ * O, x[3] = F * O, x;
      }
      function G(x, M) {
        var Q = Math.sin(M), P = Math.cos(M);
        return x[0] = P, x[1] = Q, x[2] = -Q, x[3] = P, x;
      }
      function d(x, M) {
        return x[0] = M[0], x[1] = 0, x[2] = 0, x[3] = M[1], x;
      }
      function t(x) {
        return "mat2(" + x[0] + ", " + x[1] + ", " + x[2] + ", " + x[3] + ")";
      }
      function s(x) {
        return Math.hypot(x[0], x[1], x[2], x[3]);
      }
      function b(x, M, Q, P) {
        return x[2] = P[2] / P[0], Q[0] = P[0], Q[1] = P[1], Q[3] = P[3] - x[2] * Q[1], [x, M, Q];
      }
      function V(x, M, Q) {
        return x[0] = M[0] + Q[0], x[1] = M[1] + Q[1], x[2] = M[2] + Q[2], x[3] = M[3] + Q[3], x;
      }
      function S(x, M, Q) {
        return x[0] = M[0] - Q[0], x[1] = M[1] - Q[1], x[2] = M[2] - Q[2], x[3] = M[3] - Q[3], x;
      }
      function Y(x, M) {
        return x[0] === M[0] && x[1] === M[1] && x[2] === M[2] && x[3] === M[3];
      }
      function T(x, M) {
        var Q = x[0], P = x[1], D = x[2], _ = x[3], F = M[0], v = M[1], O = M[2], li = M[3];
        return Math.abs(Q - F) <= c.EPSILON * Math.max(1, Math.abs(Q), Math.abs(F)) && Math.abs(P - v) <= c.EPSILON * Math.max(1, Math.abs(P), Math.abs(v)) && Math.abs(D - O) <= c.EPSILON * Math.max(1, Math.abs(D), Math.abs(O)) && Math.abs(_ - li) <= c.EPSILON * Math.max(1, Math.abs(_), Math.abs(li));
      }
      function y(x, M, Q) {
        return x[0] = M[0] * Q, x[1] = M[1] * Q, x[2] = M[2] * Q, x[3] = M[3] * Q, x;
      }
      function J(x, M, Q, P) {
        return x[0] = M[0] + Q[0] * P, x[1] = M[1] + Q[1] * P, x[2] = M[2] + Q[2] * P, x[3] = M[3] + Q[3] * P, x;
      }
      var N = C, R = S;
    },
    /* 4 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return Z;
      }), i.d(l, "clone", function() {
        return L;
      }), i.d(l, "copy", function() {
        return K;
      }), i.d(l, "identity", function() {
        return u;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "set", function() {
        return e;
      }), i.d(l, "invert", function() {
        return r;
      }), i.d(l, "determinant", function() {
        return X;
      }), i.d(l, "multiply", function() {
        return W;
      }), i.d(l, "rotate", function() {
        return p;
      }), i.d(l, "scale", function() {
        return C;
      }), i.d(l, "translate", function() {
        return I;
      }), i.d(l, "fromRotation", function() {
        return o;
      }), i.d(l, "fromScaling", function() {
        return G;
      }), i.d(l, "fromTranslation", function() {
        return d;
      }), i.d(l, "str", function() {
        return t;
      }), i.d(l, "frob", function() {
        return s;
      }), i.d(l, "add", function() {
        return b;
      }), i.d(l, "subtract", function() {
        return V;
      }), i.d(l, "multiplyScalar", function() {
        return S;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return Y;
      }), i.d(l, "exactEquals", function() {
        return T;
      }), i.d(l, "equals", function() {
        return y;
      }), i.d(l, "mul", function() {
        return J;
      }), i.d(l, "sub", function() {
        return N;
      });
      var c = i(2);
      function Z() {
        var R = new c.ARRAY_TYPE(6);
        return c.ARRAY_TYPE != Float32Array && (R[1] = 0, R[2] = 0, R[4] = 0, R[5] = 0), R[0] = 1, R[3] = 1, R;
      }
      function L(R) {
        var x = new c.ARRAY_TYPE(6);
        return x[0] = R[0], x[1] = R[1], x[2] = R[2], x[3] = R[3], x[4] = R[4], x[5] = R[5], x;
      }
      function K(R, x) {
        return R[0] = x[0], R[1] = x[1], R[2] = x[2], R[3] = x[3], R[4] = x[4], R[5] = x[5], R;
      }
      function u(R) {
        return R[0] = 1, R[1] = 0, R[2] = 0, R[3] = 1, R[4] = 0, R[5] = 0, R;
      }
      function a(R, x, M, Q, P, D) {
        var _ = new c.ARRAY_TYPE(6);
        return _[0] = R, _[1] = x, _[2] = M, _[3] = Q, _[4] = P, _[5] = D, _;
      }
      function e(R, x, M, Q, P, D, _) {
        return R[0] = x, R[1] = M, R[2] = Q, R[3] = P, R[4] = D, R[5] = _, R;
      }
      function r(R, x) {
        var M = x[0], Q = x[1], P = x[2], D = x[3], _ = x[4], F = x[5], v = M * D - Q * P;
        return v ? (v = 1 / v, R[0] = D * v, R[1] = -Q * v, R[2] = -P * v, R[3] = M * v, R[4] = (P * F - D * _) * v, R[5] = (Q * _ - M * F) * v, R) : null;
      }
      function X(R) {
        return R[0] * R[3] - R[1] * R[2];
      }
      function W(R, x, M) {
        var Q = x[0], P = x[1], D = x[2], _ = x[3], F = x[4], v = x[5], O = M[0], li = M[1], ii = M[2], ti = M[3], $ = M[4], ai = M[5];
        return R[0] = Q * O + D * li, R[1] = P * O + _ * li, R[2] = Q * ii + D * ti, R[3] = P * ii + _ * ti, R[4] = Q * $ + D * ai + F, R[5] = P * $ + _ * ai + v, R;
      }
      function p(R, x, M) {
        var Q = x[0], P = x[1], D = x[2], _ = x[3], F = x[4], v = x[5], O = Math.sin(M), li = Math.cos(M);
        return R[0] = Q * li + D * O, R[1] = P * li + _ * O, R[2] = Q * -O + D * li, R[3] = P * -O + _ * li, R[4] = F, R[5] = v, R;
      }
      function C(R, x, M) {
        var Q = x[0], P = x[1], D = x[2], _ = x[3], F = x[4], v = x[5], O = M[0], li = M[1];
        return R[0] = Q * O, R[1] = P * O, R[2] = D * li, R[3] = _ * li, R[4] = F, R[5] = v, R;
      }
      function I(R, x, M) {
        var Q = x[0], P = x[1], D = x[2], _ = x[3], F = x[4], v = x[5], O = M[0], li = M[1];
        return R[0] = Q, R[1] = P, R[2] = D, R[3] = _, R[4] = Q * O + D * li + F, R[5] = P * O + _ * li + v, R;
      }
      function o(R, x) {
        var M = Math.sin(x), Q = Math.cos(x);
        return R[0] = Q, R[1] = M, R[2] = -M, R[3] = Q, R[4] = 0, R[5] = 0, R;
      }
      function G(R, x) {
        return R[0] = x[0], R[1] = 0, R[2] = 0, R[3] = x[1], R[4] = 0, R[5] = 0, R;
      }
      function d(R, x) {
        return R[0] = 1, R[1] = 0, R[2] = 0, R[3] = 1, R[4] = x[0], R[5] = x[1], R;
      }
      function t(R) {
        return "mat2d(" + R[0] + ", " + R[1] + ", " + R[2] + ", " + R[3] + ", " + R[4] + ", " + R[5] + ")";
      }
      function s(R) {
        return Math.hypot(R[0], R[1], R[2], R[3], R[4], R[5], 1);
      }
      function b(R, x, M) {
        return R[0] = x[0] + M[0], R[1] = x[1] + M[1], R[2] = x[2] + M[2], R[3] = x[3] + M[3], R[4] = x[4] + M[4], R[5] = x[5] + M[5], R;
      }
      function V(R, x, M) {
        return R[0] = x[0] - M[0], R[1] = x[1] - M[1], R[2] = x[2] - M[2], R[3] = x[3] - M[3], R[4] = x[4] - M[4], R[5] = x[5] - M[5], R;
      }
      function S(R, x, M) {
        return R[0] = x[0] * M, R[1] = x[1] * M, R[2] = x[2] * M, R[3] = x[3] * M, R[4] = x[4] * M, R[5] = x[5] * M, R;
      }
      function Y(R, x, M, Q) {
        return R[0] = x[0] + M[0] * Q, R[1] = x[1] + M[1] * Q, R[2] = x[2] + M[2] * Q, R[3] = x[3] + M[3] * Q, R[4] = x[4] + M[4] * Q, R[5] = x[5] + M[5] * Q, R;
      }
      function T(R, x) {
        return R[0] === x[0] && R[1] === x[1] && R[2] === x[2] && R[3] === x[3] && R[4] === x[4] && R[5] === x[5];
      }
      function y(R, x) {
        var M = R[0], Q = R[1], P = R[2], D = R[3], _ = R[4], F = R[5], v = x[0], O = x[1], li = x[2], ii = x[3], ti = x[4], $ = x[5];
        return Math.abs(M - v) <= c.EPSILON * Math.max(1, Math.abs(M), Math.abs(v)) && Math.abs(Q - O) <= c.EPSILON * Math.max(1, Math.abs(Q), Math.abs(O)) && Math.abs(P - li) <= c.EPSILON * Math.max(1, Math.abs(P), Math.abs(li)) && Math.abs(D - ii) <= c.EPSILON * Math.max(1, Math.abs(D), Math.abs(ii)) && Math.abs(_ - ti) <= c.EPSILON * Math.max(1, Math.abs(_), Math.abs(ti)) && Math.abs(F - $) <= c.EPSILON * Math.max(1, Math.abs(F), Math.abs($));
      }
      var J = W, N = V;
    },
    /* 5 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return Z;
      }), i.d(l, "fromMat4", function() {
        return L;
      }), i.d(l, "clone", function() {
        return K;
      }), i.d(l, "copy", function() {
        return u;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "set", function() {
        return e;
      }), i.d(l, "identity", function() {
        return r;
      }), i.d(l, "transpose", function() {
        return X;
      }), i.d(l, "invert", function() {
        return W;
      }), i.d(l, "adjoint", function() {
        return p;
      }), i.d(l, "determinant", function() {
        return C;
      }), i.d(l, "multiply", function() {
        return I;
      }), i.d(l, "translate", function() {
        return o;
      }), i.d(l, "rotate", function() {
        return G;
      }), i.d(l, "scale", function() {
        return d;
      }), i.d(l, "fromTranslation", function() {
        return t;
      }), i.d(l, "fromRotation", function() {
        return s;
      }), i.d(l, "fromScaling", function() {
        return b;
      }), i.d(l, "fromMat2d", function() {
        return V;
      }), i.d(l, "fromQuat", function() {
        return S;
      }), i.d(l, "normalFromMat4", function() {
        return Y;
      }), i.d(l, "projection", function() {
        return T;
      }), i.d(l, "str", function() {
        return y;
      }), i.d(l, "frob", function() {
        return J;
      }), i.d(l, "add", function() {
        return N;
      }), i.d(l, "subtract", function() {
        return R;
      }), i.d(l, "multiplyScalar", function() {
        return x;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return M;
      }), i.d(l, "exactEquals", function() {
        return Q;
      }), i.d(l, "equals", function() {
        return P;
      }), i.d(l, "mul", function() {
        return D;
      }), i.d(l, "sub", function() {
        return _;
      });
      var c = i(2);
      function Z() {
        var F = new c.ARRAY_TYPE(9);
        return c.ARRAY_TYPE != Float32Array && (F[1] = 0, F[2] = 0, F[3] = 0, F[5] = 0, F[6] = 0, F[7] = 0), F[0] = 1, F[4] = 1, F[8] = 1, F;
      }
      function L(F, v) {
        return F[0] = v[0], F[1] = v[1], F[2] = v[2], F[3] = v[4], F[4] = v[5], F[5] = v[6], F[6] = v[8], F[7] = v[9], F[8] = v[10], F;
      }
      function K(F) {
        var v = new c.ARRAY_TYPE(9);
        return v[0] = F[0], v[1] = F[1], v[2] = F[2], v[3] = F[3], v[4] = F[4], v[5] = F[5], v[6] = F[6], v[7] = F[7], v[8] = F[8], v;
      }
      function u(F, v) {
        return F[0] = v[0], F[1] = v[1], F[2] = v[2], F[3] = v[3], F[4] = v[4], F[5] = v[5], F[6] = v[6], F[7] = v[7], F[8] = v[8], F;
      }
      function a(F, v, O, li, ii, ti, $, ai, Xi) {
        var z = new c.ARRAY_TYPE(9);
        return z[0] = F, z[1] = v, z[2] = O, z[3] = li, z[4] = ii, z[5] = ti, z[6] = $, z[7] = ai, z[8] = Xi, z;
      }
      function e(F, v, O, li, ii, ti, $, ai, Xi, z) {
        return F[0] = v, F[1] = O, F[2] = li, F[3] = ii, F[4] = ti, F[5] = $, F[6] = ai, F[7] = Xi, F[8] = z, F;
      }
      function r(F) {
        return F[0] = 1, F[1] = 0, F[2] = 0, F[3] = 0, F[4] = 1, F[5] = 0, F[6] = 0, F[7] = 0, F[8] = 1, F;
      }
      function X(F, v) {
        if (F === v) {
          var O = v[1], li = v[2], ii = v[5];
          F[1] = v[3], F[2] = v[6], F[3] = O, F[5] = v[7], F[6] = li, F[7] = ii;
        } else
          F[0] = v[0], F[1] = v[3], F[2] = v[6], F[3] = v[1], F[4] = v[4], F[5] = v[7], F[6] = v[2], F[7] = v[5], F[8] = v[8];
        return F;
      }
      function W(F, v) {
        var O = v[0], li = v[1], ii = v[2], ti = v[3], $ = v[4], ai = v[5], Xi = v[6], z = v[7], k = v[8], j = k * $ - ai * z, A = -k * ti + ai * Xi, H = z * ti - $ * Xi, U = O * j + li * A + ii * H;
        return U ? (U = 1 / U, F[0] = j * U, F[1] = (-k * li + ii * z) * U, F[2] = (ai * li - ii * $) * U, F[3] = A * U, F[4] = (k * O - ii * Xi) * U, F[5] = (-ai * O + ii * ti) * U, F[6] = H * U, F[7] = (-z * O + li * Xi) * U, F[8] = ($ * O - li * ti) * U, F) : null;
      }
      function p(F, v) {
        var O = v[0], li = v[1], ii = v[2], ti = v[3], $ = v[4], ai = v[5], Xi = v[6], z = v[7], k = v[8];
        return F[0] = $ * k - ai * z, F[1] = ii * z - li * k, F[2] = li * ai - ii * $, F[3] = ai * Xi - ti * k, F[4] = O * k - ii * Xi, F[5] = ii * ti - O * ai, F[6] = ti * z - $ * Xi, F[7] = li * Xi - O * z, F[8] = O * $ - li * ti, F;
      }
      function C(F) {
        var v = F[0], O = F[1], li = F[2], ii = F[3], ti = F[4], $ = F[5], ai = F[6], Xi = F[7], z = F[8];
        return v * (z * ti - $ * Xi) + O * (-z * ii + $ * ai) + li * (Xi * ii - ti * ai);
      }
      function I(F, v, O) {
        var li = v[0], ii = v[1], ti = v[2], $ = v[3], ai = v[4], Xi = v[5], z = v[6], k = v[7], j = v[8], A = O[0], H = O[1], U = O[2], m = O[3], h = O[4], g = O[5], f = O[6], w = O[7], B = O[8];
        return F[0] = A * li + H * $ + U * z, F[1] = A * ii + H * ai + U * k, F[2] = A * ti + H * Xi + U * j, F[3] = m * li + h * $ + g * z, F[4] = m * ii + h * ai + g * k, F[5] = m * ti + h * Xi + g * j, F[6] = f * li + w * $ + B * z, F[7] = f * ii + w * ai + B * k, F[8] = f * ti + w * Xi + B * j, F;
      }
      function o(F, v, O) {
        var li = v[0], ii = v[1], ti = v[2], $ = v[3], ai = v[4], Xi = v[5], z = v[6], k = v[7], j = v[8], A = O[0], H = O[1];
        return F[0] = li, F[1] = ii, F[2] = ti, F[3] = $, F[4] = ai, F[5] = Xi, F[6] = A * li + H * $ + z, F[7] = A * ii + H * ai + k, F[8] = A * ti + H * Xi + j, F;
      }
      function G(F, v, O) {
        var li = v[0], ii = v[1], ti = v[2], $ = v[3], ai = v[4], Xi = v[5], z = v[6], k = v[7], j = v[8], A = Math.sin(O), H = Math.cos(O);
        return F[0] = H * li + A * $, F[1] = H * ii + A * ai, F[2] = H * ti + A * Xi, F[3] = H * $ - A * li, F[4] = H * ai - A * ii, F[5] = H * Xi - A * ti, F[6] = z, F[7] = k, F[8] = j, F;
      }
      function d(F, v, O) {
        var li = O[0], ii = O[1];
        return F[0] = li * v[0], F[1] = li * v[1], F[2] = li * v[2], F[3] = ii * v[3], F[4] = ii * v[4], F[5] = ii * v[5], F[6] = v[6], F[7] = v[7], F[8] = v[8], F;
      }
      function t(F, v) {
        return F[0] = 1, F[1] = 0, F[2] = 0, F[3] = 0, F[4] = 1, F[5] = 0, F[6] = v[0], F[7] = v[1], F[8] = 1, F;
      }
      function s(F, v) {
        var O = Math.sin(v), li = Math.cos(v);
        return F[0] = li, F[1] = O, F[2] = 0, F[3] = -O, F[4] = li, F[5] = 0, F[6] = 0, F[7] = 0, F[8] = 1, F;
      }
      function b(F, v) {
        return F[0] = v[0], F[1] = 0, F[2] = 0, F[3] = 0, F[4] = v[1], F[5] = 0, F[6] = 0, F[7] = 0, F[8] = 1, F;
      }
      function V(F, v) {
        return F[0] = v[0], F[1] = v[1], F[2] = 0, F[3] = v[2], F[4] = v[3], F[5] = 0, F[6] = v[4], F[7] = v[5], F[8] = 1, F;
      }
      function S(F, v) {
        var O = v[0], li = v[1], ii = v[2], ti = v[3], $ = O + O, ai = li + li, Xi = ii + ii, z = O * $, k = li * $, j = li * ai, A = ii * $, H = ii * ai, U = ii * Xi, m = ti * $, h = ti * ai, g = ti * Xi;
        return F[0] = 1 - j - U, F[3] = k - g, F[6] = A + h, F[1] = k + g, F[4] = 1 - z - U, F[7] = H - m, F[2] = A - h, F[5] = H + m, F[8] = 1 - z - j, F;
      }
      function Y(F, v) {
        var O = v[0], li = v[1], ii = v[2], ti = v[3], $ = v[4], ai = v[5], Xi = v[6], z = v[7], k = v[8], j = v[9], A = v[10], H = v[11], U = v[12], m = v[13], h = v[14], g = v[15], f = O * ai - li * $, w = O * Xi - ii * $, B = O * z - ti * $, q = li * Xi - ii * ai, si = li * z - ti * ai, bi = ii * z - ti * Xi, Zi = k * m - j * U, oi = k * h - A * U, mi = k * g - H * U, ci = j * h - A * m, ni = j * g - H * m, Gi = A * g - H * h, Vi = f * Gi - w * ni + B * ci + q * mi - si * oi + bi * Zi;
        return Vi ? (Vi = 1 / Vi, F[0] = (ai * Gi - Xi * ni + z * ci) * Vi, F[1] = (Xi * mi - $ * Gi - z * oi) * Vi, F[2] = ($ * ni - ai * mi + z * Zi) * Vi, F[3] = (ii * ni - li * Gi - ti * ci) * Vi, F[4] = (O * Gi - ii * mi + ti * oi) * Vi, F[5] = (li * mi - O * ni - ti * Zi) * Vi, F[6] = (m * bi - h * si + g * q) * Vi, F[7] = (h * B - U * bi - g * w) * Vi, F[8] = (U * si - m * B + g * f) * Vi, F) : null;
      }
      function T(F, v, O) {
        return F[0] = 2 / v, F[1] = 0, F[2] = 0, F[3] = 0, F[4] = -2 / O, F[5] = 0, F[6] = -1, F[7] = 1, F[8] = 1, F;
      }
      function y(F) {
        return "mat3(" + F[0] + ", " + F[1] + ", " + F[2] + ", " + F[3] + ", " + F[4] + ", " + F[5] + ", " + F[6] + ", " + F[7] + ", " + F[8] + ")";
      }
      function J(F) {
        return Math.hypot(F[0], F[1], F[2], F[3], F[4], F[5], F[6], F[7], F[8]);
      }
      function N(F, v, O) {
        return F[0] = v[0] + O[0], F[1] = v[1] + O[1], F[2] = v[2] + O[2], F[3] = v[3] + O[3], F[4] = v[4] + O[4], F[5] = v[5] + O[5], F[6] = v[6] + O[6], F[7] = v[7] + O[7], F[8] = v[8] + O[8], F;
      }
      function R(F, v, O) {
        return F[0] = v[0] - O[0], F[1] = v[1] - O[1], F[2] = v[2] - O[2], F[3] = v[3] - O[3], F[4] = v[4] - O[4], F[5] = v[5] - O[5], F[6] = v[6] - O[6], F[7] = v[7] - O[7], F[8] = v[8] - O[8], F;
      }
      function x(F, v, O) {
        return F[0] = v[0] * O, F[1] = v[1] * O, F[2] = v[2] * O, F[3] = v[3] * O, F[4] = v[4] * O, F[5] = v[5] * O, F[6] = v[6] * O, F[7] = v[7] * O, F[8] = v[8] * O, F;
      }
      function M(F, v, O, li) {
        return F[0] = v[0] + O[0] * li, F[1] = v[1] + O[1] * li, F[2] = v[2] + O[2] * li, F[3] = v[3] + O[3] * li, F[4] = v[4] + O[4] * li, F[5] = v[5] + O[5] * li, F[6] = v[6] + O[6] * li, F[7] = v[7] + O[7] * li, F[8] = v[8] + O[8] * li, F;
      }
      function Q(F, v) {
        return F[0] === v[0] && F[1] === v[1] && F[2] === v[2] && F[3] === v[3] && F[4] === v[4] && F[5] === v[5] && F[6] === v[6] && F[7] === v[7] && F[8] === v[8];
      }
      function P(F, v) {
        var O = F[0], li = F[1], ii = F[2], ti = F[3], $ = F[4], ai = F[5], Xi = F[6], z = F[7], k = F[8], j = v[0], A = v[1], H = v[2], U = v[3], m = v[4], h = v[5], g = v[6], f = v[7], w = v[8];
        return Math.abs(O - j) <= c.EPSILON * Math.max(1, Math.abs(O), Math.abs(j)) && Math.abs(li - A) <= c.EPSILON * Math.max(1, Math.abs(li), Math.abs(A)) && Math.abs(ii - H) <= c.EPSILON * Math.max(1, Math.abs(ii), Math.abs(H)) && Math.abs(ti - U) <= c.EPSILON * Math.max(1, Math.abs(ti), Math.abs(U)) && Math.abs($ - m) <= c.EPSILON * Math.max(1, Math.abs($), Math.abs(m)) && Math.abs(ai - h) <= c.EPSILON * Math.max(1, Math.abs(ai), Math.abs(h)) && Math.abs(Xi - g) <= c.EPSILON * Math.max(1, Math.abs(Xi), Math.abs(g)) && Math.abs(z - f) <= c.EPSILON * Math.max(1, Math.abs(z), Math.abs(f)) && Math.abs(k - w) <= c.EPSILON * Math.max(1, Math.abs(k), Math.abs(w));
      }
      var D = I, _ = R;
    },
    /* 6 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return Z;
      }), i.d(l, "clone", function() {
        return L;
      }), i.d(l, "copy", function() {
        return K;
      }), i.d(l, "fromValues", function() {
        return u;
      }), i.d(l, "set", function() {
        return a;
      }), i.d(l, "identity", function() {
        return e;
      }), i.d(l, "transpose", function() {
        return r;
      }), i.d(l, "invert", function() {
        return X;
      }), i.d(l, "adjoint", function() {
        return W;
      }), i.d(l, "determinant", function() {
        return p;
      }), i.d(l, "multiply", function() {
        return C;
      }), i.d(l, "translate", function() {
        return I;
      }), i.d(l, "scale", function() {
        return o;
      }), i.d(l, "rotate", function() {
        return G;
      }), i.d(l, "rotateX", function() {
        return d;
      }), i.d(l, "rotateY", function() {
        return t;
      }), i.d(l, "rotateZ", function() {
        return s;
      }), i.d(l, "fromTranslation", function() {
        return b;
      }), i.d(l, "fromScaling", function() {
        return V;
      }), i.d(l, "fromRotation", function() {
        return S;
      }), i.d(l, "fromXRotation", function() {
        return Y;
      }), i.d(l, "fromYRotation", function() {
        return T;
      }), i.d(l, "fromZRotation", function() {
        return y;
      }), i.d(l, "fromRotationTranslation", function() {
        return J;
      }), i.d(l, "fromQuat2", function() {
        return N;
      }), i.d(l, "getTranslation", function() {
        return R;
      }), i.d(l, "getScaling", function() {
        return x;
      }), i.d(l, "getRotation", function() {
        return M;
      }), i.d(l, "fromRotationTranslationScale", function() {
        return Q;
      }), i.d(l, "fromRotationTranslationScaleOrigin", function() {
        return P;
      }), i.d(l, "fromQuat", function() {
        return D;
      }), i.d(l, "frustum", function() {
        return _;
      }), i.d(l, "perspective", function() {
        return F;
      }), i.d(l, "perspectiveFromFieldOfView", function() {
        return v;
      }), i.d(l, "ortho", function() {
        return O;
      }), i.d(l, "lookAt", function() {
        return li;
      }), i.d(l, "targetTo", function() {
        return ii;
      }), i.d(l, "str", function() {
        return ti;
      }), i.d(l, "frob", function() {
        return $;
      }), i.d(l, "add", function() {
        return ai;
      }), i.d(l, "subtract", function() {
        return Xi;
      }), i.d(l, "multiplyScalar", function() {
        return z;
      }), i.d(l, "multiplyScalarAndAdd", function() {
        return k;
      }), i.d(l, "exactEquals", function() {
        return j;
      }), i.d(l, "equals", function() {
        return A;
      }), i.d(l, "mul", function() {
        return H;
      }), i.d(l, "sub", function() {
        return U;
      });
      var c = i(2);
      function Z() {
        var m = new c.ARRAY_TYPE(16);
        return c.ARRAY_TYPE != Float32Array && (m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[6] = 0, m[7] = 0, m[8] = 0, m[9] = 0, m[11] = 0, m[12] = 0, m[13] = 0, m[14] = 0), m[0] = 1, m[5] = 1, m[10] = 1, m[15] = 1, m;
      }
      function L(m) {
        var h = new c.ARRAY_TYPE(16);
        return h[0] = m[0], h[1] = m[1], h[2] = m[2], h[3] = m[3], h[4] = m[4], h[5] = m[5], h[6] = m[6], h[7] = m[7], h[8] = m[8], h[9] = m[9], h[10] = m[10], h[11] = m[11], h[12] = m[12], h[13] = m[13], h[14] = m[14], h[15] = m[15], h;
      }
      function K(m, h) {
        return m[0] = h[0], m[1] = h[1], m[2] = h[2], m[3] = h[3], m[4] = h[4], m[5] = h[5], m[6] = h[6], m[7] = h[7], m[8] = h[8], m[9] = h[9], m[10] = h[10], m[11] = h[11], m[12] = h[12], m[13] = h[13], m[14] = h[14], m[15] = h[15], m;
      }
      function u(m, h, g, f, w, B, q, si, bi, Zi, oi, mi, ci, ni, Gi, Vi) {
        var Wi = new c.ARRAY_TYPE(16);
        return Wi[0] = m, Wi[1] = h, Wi[2] = g, Wi[3] = f, Wi[4] = w, Wi[5] = B, Wi[6] = q, Wi[7] = si, Wi[8] = bi, Wi[9] = Zi, Wi[10] = oi, Wi[11] = mi, Wi[12] = ci, Wi[13] = ni, Wi[14] = Gi, Wi[15] = Vi, Wi;
      }
      function a(m, h, g, f, w, B, q, si, bi, Zi, oi, mi, ci, ni, Gi, Vi, Wi) {
        return m[0] = h, m[1] = g, m[2] = f, m[3] = w, m[4] = B, m[5] = q, m[6] = si, m[7] = bi, m[8] = Zi, m[9] = oi, m[10] = mi, m[11] = ci, m[12] = ni, m[13] = Gi, m[14] = Vi, m[15] = Wi, m;
      }
      function e(m) {
        return m[0] = 1, m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[5] = 1, m[6] = 0, m[7] = 0, m[8] = 0, m[9] = 0, m[10] = 1, m[11] = 0, m[12] = 0, m[13] = 0, m[14] = 0, m[15] = 1, m;
      }
      function r(m, h) {
        if (m === h) {
          var g = h[1], f = h[2], w = h[3], B = h[6], q = h[7], si = h[11];
          m[1] = h[4], m[2] = h[8], m[3] = h[12], m[4] = g, m[6] = h[9], m[7] = h[13], m[8] = f, m[9] = B, m[11] = h[14], m[12] = w, m[13] = q, m[14] = si;
        } else
          m[0] = h[0], m[1] = h[4], m[2] = h[8], m[3] = h[12], m[4] = h[1], m[5] = h[5], m[6] = h[9], m[7] = h[13], m[8] = h[2], m[9] = h[6], m[10] = h[10], m[11] = h[14], m[12] = h[3], m[13] = h[7], m[14] = h[11], m[15] = h[15];
        return m;
      }
      function X(m, h) {
        var g = h[0], f = h[1], w = h[2], B = h[3], q = h[4], si = h[5], bi = h[6], Zi = h[7], oi = h[8], mi = h[9], ci = h[10], ni = h[11], Gi = h[12], Vi = h[13], Wi = h[14], Ii = h[15], Ri = g * si - f * q, yi = g * bi - w * q, Li = g * Zi - B * q, ri = f * bi - w * si, Si = f * Zi - B * si, wi = w * Zi - B * bi, zi = oi * Vi - mi * Gi, Qi = oi * Wi - ci * Gi, ki = oi * Ii - ni * Gi, Pi = mi * Wi - ci * Vi, fi = mi * Ii - ni * Vi, ji = ci * Ii - ni * Wi, Ji = Ri * ji - yi * fi + Li * Pi + ri * ki - Si * Qi + wi * zi;
        return Ji ? (Ji = 1 / Ji, m[0] = (si * ji - bi * fi + Zi * Pi) * Ji, m[1] = (w * fi - f * ji - B * Pi) * Ji, m[2] = (Vi * wi - Wi * Si + Ii * ri) * Ji, m[3] = (ci * Si - mi * wi - ni * ri) * Ji, m[4] = (bi * ki - q * ji - Zi * Qi) * Ji, m[5] = (g * ji - w * ki + B * Qi) * Ji, m[6] = (Wi * Li - Gi * wi - Ii * yi) * Ji, m[7] = (oi * wi - ci * Li + ni * yi) * Ji, m[8] = (q * fi - si * ki + Zi * zi) * Ji, m[9] = (f * ki - g * fi - B * zi) * Ji, m[10] = (Gi * Si - Vi * Li + Ii * Ri) * Ji, m[11] = (mi * Li - oi * Si - ni * Ri) * Ji, m[12] = (si * Qi - q * Pi - bi * zi) * Ji, m[13] = (g * Pi - f * Qi + w * zi) * Ji, m[14] = (Vi * yi - Gi * ri - Wi * Ri) * Ji, m[15] = (oi * ri - mi * yi + ci * Ri) * Ji, m) : null;
      }
      function W(m, h) {
        var g = h[0], f = h[1], w = h[2], B = h[3], q = h[4], si = h[5], bi = h[6], Zi = h[7], oi = h[8], mi = h[9], ci = h[10], ni = h[11], Gi = h[12], Vi = h[13], Wi = h[14], Ii = h[15];
        return m[0] = si * (ci * Ii - ni * Wi) - mi * (bi * Ii - Zi * Wi) + Vi * (bi * ni - Zi * ci), m[1] = -(f * (ci * Ii - ni * Wi) - mi * (w * Ii - B * Wi) + Vi * (w * ni - B * ci)), m[2] = f * (bi * Ii - Zi * Wi) - si * (w * Ii - B * Wi) + Vi * (w * Zi - B * bi), m[3] = -(f * (bi * ni - Zi * ci) - si * (w * ni - B * ci) + mi * (w * Zi - B * bi)), m[4] = -(q * (ci * Ii - ni * Wi) - oi * (bi * Ii - Zi * Wi) + Gi * (bi * ni - Zi * ci)), m[5] = g * (ci * Ii - ni * Wi) - oi * (w * Ii - B * Wi) + Gi * (w * ni - B * ci), m[6] = -(g * (bi * Ii - Zi * Wi) - q * (w * Ii - B * Wi) + Gi * (w * Zi - B * bi)), m[7] = g * (bi * ni - Zi * ci) - q * (w * ni - B * ci) + oi * (w * Zi - B * bi), m[8] = q * (mi * Ii - ni * Vi) - oi * (si * Ii - Zi * Vi) + Gi * (si * ni - Zi * mi), m[9] = -(g * (mi * Ii - ni * Vi) - oi * (f * Ii - B * Vi) + Gi * (f * ni - B * mi)), m[10] = g * (si * Ii - Zi * Vi) - q * (f * Ii - B * Vi) + Gi * (f * Zi - B * si), m[11] = -(g * (si * ni - Zi * mi) - q * (f * ni - B * mi) + oi * (f * Zi - B * si)), m[12] = -(q * (mi * Wi - ci * Vi) - oi * (si * Wi - bi * Vi) + Gi * (si * ci - bi * mi)), m[13] = g * (mi * Wi - ci * Vi) - oi * (f * Wi - w * Vi) + Gi * (f * ci - w * mi), m[14] = -(g * (si * Wi - bi * Vi) - q * (f * Wi - w * Vi) + Gi * (f * bi - w * si)), m[15] = g * (si * ci - bi * mi) - q * (f * ci - w * mi) + oi * (f * bi - w * si), m;
      }
      function p(m) {
        var h = m[0], g = m[1], f = m[2], w = m[3], B = m[4], q = m[5], si = m[6], bi = m[7], Zi = m[8], oi = m[9], mi = m[10], ci = m[11], ni = m[12], Gi = m[13], Vi = m[14], Wi = m[15], Ii = h * q - g * B, Ri = h * si - f * B, yi = h * bi - w * B, Li = g * si - f * q, ri = g * bi - w * q, Si = f * bi - w * si, wi = Zi * Gi - oi * ni, zi = Zi * Vi - mi * ni, Qi = Zi * Wi - ci * ni, ki = oi * Vi - mi * Gi, Pi = oi * Wi - ci * Gi, fi = mi * Wi - ci * Vi;
        return Ii * fi - Ri * Pi + yi * ki + Li * Qi - ri * zi + Si * wi;
      }
      function C(m, h, g) {
        var f = h[0], w = h[1], B = h[2], q = h[3], si = h[4], bi = h[5], Zi = h[6], oi = h[7], mi = h[8], ci = h[9], ni = h[10], Gi = h[11], Vi = h[12], Wi = h[13], Ii = h[14], Ri = h[15], yi = g[0], Li = g[1], ri = g[2], Si = g[3];
        return m[0] = yi * f + Li * si + ri * mi + Si * Vi, m[1] = yi * w + Li * bi + ri * ci + Si * Wi, m[2] = yi * B + Li * Zi + ri * ni + Si * Ii, m[3] = yi * q + Li * oi + ri * Gi + Si * Ri, yi = g[4], Li = g[5], ri = g[6], Si = g[7], m[4] = yi * f + Li * si + ri * mi + Si * Vi, m[5] = yi * w + Li * bi + ri * ci + Si * Wi, m[6] = yi * B + Li * Zi + ri * ni + Si * Ii, m[7] = yi * q + Li * oi + ri * Gi + Si * Ri, yi = g[8], Li = g[9], ri = g[10], Si = g[11], m[8] = yi * f + Li * si + ri * mi + Si * Vi, m[9] = yi * w + Li * bi + ri * ci + Si * Wi, m[10] = yi * B + Li * Zi + ri * ni + Si * Ii, m[11] = yi * q + Li * oi + ri * Gi + Si * Ri, yi = g[12], Li = g[13], ri = g[14], Si = g[15], m[12] = yi * f + Li * si + ri * mi + Si * Vi, m[13] = yi * w + Li * bi + ri * ci + Si * Wi, m[14] = yi * B + Li * Zi + ri * ni + Si * Ii, m[15] = yi * q + Li * oi + ri * Gi + Si * Ri, m;
      }
      function I(m, h, g) {
        var f = g[0], w = g[1], B = g[2], q, si, bi, Zi, oi, mi, ci, ni, Gi, Vi, Wi, Ii;
        return h === m ? (m[12] = h[0] * f + h[4] * w + h[8] * B + h[12], m[13] = h[1] * f + h[5] * w + h[9] * B + h[13], m[14] = h[2] * f + h[6] * w + h[10] * B + h[14], m[15] = h[3] * f + h[7] * w + h[11] * B + h[15]) : (q = h[0], si = h[1], bi = h[2], Zi = h[3], oi = h[4], mi = h[5], ci = h[6], ni = h[7], Gi = h[8], Vi = h[9], Wi = h[10], Ii = h[11], m[0] = q, m[1] = si, m[2] = bi, m[3] = Zi, m[4] = oi, m[5] = mi, m[6] = ci, m[7] = ni, m[8] = Gi, m[9] = Vi, m[10] = Wi, m[11] = Ii, m[12] = q * f + oi * w + Gi * B + h[12], m[13] = si * f + mi * w + Vi * B + h[13], m[14] = bi * f + ci * w + Wi * B + h[14], m[15] = Zi * f + ni * w + Ii * B + h[15]), m;
      }
      function o(m, h, g) {
        var f = g[0], w = g[1], B = g[2];
        return m[0] = h[0] * f, m[1] = h[1] * f, m[2] = h[2] * f, m[3] = h[3] * f, m[4] = h[4] * w, m[5] = h[5] * w, m[6] = h[6] * w, m[7] = h[7] * w, m[8] = h[8] * B, m[9] = h[9] * B, m[10] = h[10] * B, m[11] = h[11] * B, m[12] = h[12], m[13] = h[13], m[14] = h[14], m[15] = h[15], m;
      }
      function G(m, h, g, f) {
        var w = f[0], B = f[1], q = f[2], si = Math.hypot(w, B, q), bi, Zi, oi, mi, ci, ni, Gi, Vi, Wi, Ii, Ri, yi, Li, ri, Si, wi, zi, Qi, ki, Pi, fi, ji, Ji, $i;
        return si < c.EPSILON ? null : (si = 1 / si, w *= si, B *= si, q *= si, bi = Math.sin(g), Zi = Math.cos(g), oi = 1 - Zi, mi = h[0], ci = h[1], ni = h[2], Gi = h[3], Vi = h[4], Wi = h[5], Ii = h[6], Ri = h[7], yi = h[8], Li = h[9], ri = h[10], Si = h[11], wi = w * w * oi + Zi, zi = B * w * oi + q * bi, Qi = q * w * oi - B * bi, ki = w * B * oi - q * bi, Pi = B * B * oi + Zi, fi = q * B * oi + w * bi, ji = w * q * oi + B * bi, Ji = B * q * oi - w * bi, $i = q * q * oi + Zi, m[0] = mi * wi + Vi * zi + yi * Qi, m[1] = ci * wi + Wi * zi + Li * Qi, m[2] = ni * wi + Ii * zi + ri * Qi, m[3] = Gi * wi + Ri * zi + Si * Qi, m[4] = mi * ki + Vi * Pi + yi * fi, m[5] = ci * ki + Wi * Pi + Li * fi, m[6] = ni * ki + Ii * Pi + ri * fi, m[7] = Gi * ki + Ri * Pi + Si * fi, m[8] = mi * ji + Vi * Ji + yi * $i, m[9] = ci * ji + Wi * Ji + Li * $i, m[10] = ni * ji + Ii * Ji + ri * $i, m[11] = Gi * ji + Ri * Ji + Si * $i, h !== m && (m[12] = h[12], m[13] = h[13], m[14] = h[14], m[15] = h[15]), m);
      }
      function d(m, h, g) {
        var f = Math.sin(g), w = Math.cos(g), B = h[4], q = h[5], si = h[6], bi = h[7], Zi = h[8], oi = h[9], mi = h[10], ci = h[11];
        return h !== m && (m[0] = h[0], m[1] = h[1], m[2] = h[2], m[3] = h[3], m[12] = h[12], m[13] = h[13], m[14] = h[14], m[15] = h[15]), m[4] = B * w + Zi * f, m[5] = q * w + oi * f, m[6] = si * w + mi * f, m[7] = bi * w + ci * f, m[8] = Zi * w - B * f, m[9] = oi * w - q * f, m[10] = mi * w - si * f, m[11] = ci * w - bi * f, m;
      }
      function t(m, h, g) {
        var f = Math.sin(g), w = Math.cos(g), B = h[0], q = h[1], si = h[2], bi = h[3], Zi = h[8], oi = h[9], mi = h[10], ci = h[11];
        return h !== m && (m[4] = h[4], m[5] = h[5], m[6] = h[6], m[7] = h[7], m[12] = h[12], m[13] = h[13], m[14] = h[14], m[15] = h[15]), m[0] = B * w - Zi * f, m[1] = q * w - oi * f, m[2] = si * w - mi * f, m[3] = bi * w - ci * f, m[8] = B * f + Zi * w, m[9] = q * f + oi * w, m[10] = si * f + mi * w, m[11] = bi * f + ci * w, m;
      }
      function s(m, h, g) {
        var f = Math.sin(g), w = Math.cos(g), B = h[0], q = h[1], si = h[2], bi = h[3], Zi = h[4], oi = h[5], mi = h[6], ci = h[7];
        return h !== m && (m[8] = h[8], m[9] = h[9], m[10] = h[10], m[11] = h[11], m[12] = h[12], m[13] = h[13], m[14] = h[14], m[15] = h[15]), m[0] = B * w + Zi * f, m[1] = q * w + oi * f, m[2] = si * w + mi * f, m[3] = bi * w + ci * f, m[4] = Zi * w - B * f, m[5] = oi * w - q * f, m[6] = mi * w - si * f, m[7] = ci * w - bi * f, m;
      }
      function b(m, h) {
        return m[0] = 1, m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[5] = 1, m[6] = 0, m[7] = 0, m[8] = 0, m[9] = 0, m[10] = 1, m[11] = 0, m[12] = h[0], m[13] = h[1], m[14] = h[2], m[15] = 1, m;
      }
      function V(m, h) {
        return m[0] = h[0], m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[5] = h[1], m[6] = 0, m[7] = 0, m[8] = 0, m[9] = 0, m[10] = h[2], m[11] = 0, m[12] = 0, m[13] = 0, m[14] = 0, m[15] = 1, m;
      }
      function S(m, h, g) {
        var f = g[0], w = g[1], B = g[2], q = Math.hypot(f, w, B), si, bi, Zi;
        return q < c.EPSILON ? null : (q = 1 / q, f *= q, w *= q, B *= q, si = Math.sin(h), bi = Math.cos(h), Zi = 1 - bi, m[0] = f * f * Zi + bi, m[1] = w * f * Zi + B * si, m[2] = B * f * Zi - w * si, m[3] = 0, m[4] = f * w * Zi - B * si, m[5] = w * w * Zi + bi, m[6] = B * w * Zi + f * si, m[7] = 0, m[8] = f * B * Zi + w * si, m[9] = w * B * Zi - f * si, m[10] = B * B * Zi + bi, m[11] = 0, m[12] = 0, m[13] = 0, m[14] = 0, m[15] = 1, m);
      }
      function Y(m, h) {
        var g = Math.sin(h), f = Math.cos(h);
        return m[0] = 1, m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[5] = f, m[6] = g, m[7] = 0, m[8] = 0, m[9] = -g, m[10] = f, m[11] = 0, m[12] = 0, m[13] = 0, m[14] = 0, m[15] = 1, m;
      }
      function T(m, h) {
        var g = Math.sin(h), f = Math.cos(h);
        return m[0] = f, m[1] = 0, m[2] = -g, m[3] = 0, m[4] = 0, m[5] = 1, m[6] = 0, m[7] = 0, m[8] = g, m[9] = 0, m[10] = f, m[11] = 0, m[12] = 0, m[13] = 0, m[14] = 0, m[15] = 1, m;
      }
      function y(m, h) {
        var g = Math.sin(h), f = Math.cos(h);
        return m[0] = f, m[1] = g, m[2] = 0, m[3] = 0, m[4] = -g, m[5] = f, m[6] = 0, m[7] = 0, m[8] = 0, m[9] = 0, m[10] = 1, m[11] = 0, m[12] = 0, m[13] = 0, m[14] = 0, m[15] = 1, m;
      }
      function J(m, h, g) {
        var f = h[0], w = h[1], B = h[2], q = h[3], si = f + f, bi = w + w, Zi = B + B, oi = f * si, mi = f * bi, ci = f * Zi, ni = w * bi, Gi = w * Zi, Vi = B * Zi, Wi = q * si, Ii = q * bi, Ri = q * Zi;
        return m[0] = 1 - (ni + Vi), m[1] = mi + Ri, m[2] = ci - Ii, m[3] = 0, m[4] = mi - Ri, m[5] = 1 - (oi + Vi), m[6] = Gi + Wi, m[7] = 0, m[8] = ci + Ii, m[9] = Gi - Wi, m[10] = 1 - (oi + ni), m[11] = 0, m[12] = g[0], m[13] = g[1], m[14] = g[2], m[15] = 1, m;
      }
      function N(m, h) {
        var g = new c.ARRAY_TYPE(3), f = -h[0], w = -h[1], B = -h[2], q = h[3], si = h[4], bi = h[5], Zi = h[6], oi = h[7], mi = f * f + w * w + B * B + q * q;
        return mi > 0 ? (g[0] = (si * q + oi * f + bi * B - Zi * w) * 2 / mi, g[1] = (bi * q + oi * w + Zi * f - si * B) * 2 / mi, g[2] = (Zi * q + oi * B + si * w - bi * f) * 2 / mi) : (g[0] = (si * q + oi * f + bi * B - Zi * w) * 2, g[1] = (bi * q + oi * w + Zi * f - si * B) * 2, g[2] = (Zi * q + oi * B + si * w - bi * f) * 2), J(m, h, g), m;
      }
      function R(m, h) {
        return m[0] = h[12], m[1] = h[13], m[2] = h[14], m;
      }
      function x(m, h) {
        var g = h[0], f = h[1], w = h[2], B = h[4], q = h[5], si = h[6], bi = h[8], Zi = h[9], oi = h[10];
        return m[0] = Math.hypot(g, f, w), m[1] = Math.hypot(B, q, si), m[2] = Math.hypot(bi, Zi, oi), m;
      }
      function M(m, h) {
        var g = new c.ARRAY_TYPE(3);
        x(g, h);
        var f = 1 / g[0], w = 1 / g[1], B = 1 / g[2], q = h[0] * f, si = h[1] * w, bi = h[2] * B, Zi = h[4] * f, oi = h[5] * w, mi = h[6] * B, ci = h[8] * f, ni = h[9] * w, Gi = h[10] * B, Vi = q + oi + Gi, Wi = 0;
        return Vi > 0 ? (Wi = Math.sqrt(Vi + 1) * 2, m[3] = 0.25 * Wi, m[0] = (mi - ni) / Wi, m[1] = (ci - bi) / Wi, m[2] = (si - Zi) / Wi) : q > oi && q > Gi ? (Wi = Math.sqrt(1 + q - oi - Gi) * 2, m[3] = (mi - ni) / Wi, m[0] = 0.25 * Wi, m[1] = (si + Zi) / Wi, m[2] = (ci + bi) / Wi) : oi > Gi ? (Wi = Math.sqrt(1 + oi - q - Gi) * 2, m[3] = (ci - bi) / Wi, m[0] = (si + Zi) / Wi, m[1] = 0.25 * Wi, m[2] = (mi + ni) / Wi) : (Wi = Math.sqrt(1 + Gi - q - oi) * 2, m[3] = (si - Zi) / Wi, m[0] = (ci + bi) / Wi, m[1] = (mi + ni) / Wi, m[2] = 0.25 * Wi), m;
      }
      function Q(m, h, g, f) {
        var w = h[0], B = h[1], q = h[2], si = h[3], bi = w + w, Zi = B + B, oi = q + q, mi = w * bi, ci = w * Zi, ni = w * oi, Gi = B * Zi, Vi = B * oi, Wi = q * oi, Ii = si * bi, Ri = si * Zi, yi = si * oi, Li = f[0], ri = f[1], Si = f[2];
        return m[0] = (1 - (Gi + Wi)) * Li, m[1] = (ci + yi) * Li, m[2] = (ni - Ri) * Li, m[3] = 0, m[4] = (ci - yi) * ri, m[5] = (1 - (mi + Wi)) * ri, m[6] = (Vi + Ii) * ri, m[7] = 0, m[8] = (ni + Ri) * Si, m[9] = (Vi - Ii) * Si, m[10] = (1 - (mi + Gi)) * Si, m[11] = 0, m[12] = g[0], m[13] = g[1], m[14] = g[2], m[15] = 1, m;
      }
      function P(m, h, g, f, w) {
        var B = h[0], q = h[1], si = h[2], bi = h[3], Zi = B + B, oi = q + q, mi = si + si, ci = B * Zi, ni = B * oi, Gi = B * mi, Vi = q * oi, Wi = q * mi, Ii = si * mi, Ri = bi * Zi, yi = bi * oi, Li = bi * mi, ri = f[0], Si = f[1], wi = f[2], zi = w[0], Qi = w[1], ki = w[2], Pi = (1 - (Vi + Ii)) * ri, fi = (ni + Li) * ri, ji = (Gi - yi) * ri, Ji = (ni - Li) * Si, $i = (1 - (ci + Ii)) * Si, Zl = (Wi + Ri) * Si, nl = (Gi + yi) * wi, Hl = (Wi - Ri) * wi, bl = (1 - (ci + Vi)) * wi;
        return m[0] = Pi, m[1] = fi, m[2] = ji, m[3] = 0, m[4] = Ji, m[5] = $i, m[6] = Zl, m[7] = 0, m[8] = nl, m[9] = Hl, m[10] = bl, m[11] = 0, m[12] = g[0] + zi - (Pi * zi + Ji * Qi + nl * ki), m[13] = g[1] + Qi - (fi * zi + $i * Qi + Hl * ki), m[14] = g[2] + ki - (ji * zi + Zl * Qi + bl * ki), m[15] = 1, m;
      }
      function D(m, h) {
        var g = h[0], f = h[1], w = h[2], B = h[3], q = g + g, si = f + f, bi = w + w, Zi = g * q, oi = f * q, mi = f * si, ci = w * q, ni = w * si, Gi = w * bi, Vi = B * q, Wi = B * si, Ii = B * bi;
        return m[0] = 1 - mi - Gi, m[1] = oi + Ii, m[2] = ci - Wi, m[3] = 0, m[4] = oi - Ii, m[5] = 1 - Zi - Gi, m[6] = ni + Vi, m[7] = 0, m[8] = ci + Wi, m[9] = ni - Vi, m[10] = 1 - Zi - mi, m[11] = 0, m[12] = 0, m[13] = 0, m[14] = 0, m[15] = 1, m;
      }
      function _(m, h, g, f, w, B, q) {
        var si = 1 / (g - h), bi = 1 / (w - f), Zi = 1 / (B - q);
        return m[0] = B * 2 * si, m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[5] = B * 2 * bi, m[6] = 0, m[7] = 0, m[8] = (g + h) * si, m[9] = (w + f) * bi, m[10] = (q + B) * Zi, m[11] = -1, m[12] = 0, m[13] = 0, m[14] = q * B * 2 * Zi, m[15] = 0, m;
      }
      function F(m, h, g, f, w) {
        var B = 1 / Math.tan(h / 2), q;
        return m[0] = B / g, m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[5] = B, m[6] = 0, m[7] = 0, m[8] = 0, m[9] = 0, m[11] = -1, m[12] = 0, m[13] = 0, m[15] = 0, w != null && w !== 1 / 0 ? (q = 1 / (f - w), m[10] = (w + f) * q, m[14] = 2 * w * f * q) : (m[10] = -1, m[14] = -2 * f), m;
      }
      function v(m, h, g, f) {
        var w = Math.tan(h.upDegrees * Math.PI / 180), B = Math.tan(h.downDegrees * Math.PI / 180), q = Math.tan(h.leftDegrees * Math.PI / 180), si = Math.tan(h.rightDegrees * Math.PI / 180), bi = 2 / (q + si), Zi = 2 / (w + B);
        return m[0] = bi, m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[5] = Zi, m[6] = 0, m[7] = 0, m[8] = -((q - si) * bi * 0.5), m[9] = (w - B) * Zi * 0.5, m[10] = f / (g - f), m[11] = -1, m[12] = 0, m[13] = 0, m[14] = f * g / (g - f), m[15] = 0, m;
      }
      function O(m, h, g, f, w, B, q) {
        var si = 1 / (h - g), bi = 1 / (f - w), Zi = 1 / (B - q);
        return m[0] = -2 * si, m[1] = 0, m[2] = 0, m[3] = 0, m[4] = 0, m[5] = -2 * bi, m[6] = 0, m[7] = 0, m[8] = 0, m[9] = 0, m[10] = 2 * Zi, m[11] = 0, m[12] = (h + g) * si, m[13] = (w + f) * bi, m[14] = (q + B) * Zi, m[15] = 1, m;
      }
      function li(m, h, g, f) {
        var w, B, q, si, bi, Zi, oi, mi, ci, ni, Gi = h[0], Vi = h[1], Wi = h[2], Ii = f[0], Ri = f[1], yi = f[2], Li = g[0], ri = g[1], Si = g[2];
        return Math.abs(Gi - Li) < c.EPSILON && Math.abs(Vi - ri) < c.EPSILON && Math.abs(Wi - Si) < c.EPSILON ? e(m) : (oi = Gi - Li, mi = Vi - ri, ci = Wi - Si, ni = 1 / Math.hypot(oi, mi, ci), oi *= ni, mi *= ni, ci *= ni, w = Ri * ci - yi * mi, B = yi * oi - Ii * ci, q = Ii * mi - Ri * oi, ni = Math.hypot(w, B, q), ni ? (ni = 1 / ni, w *= ni, B *= ni, q *= ni) : (w = 0, B = 0, q = 0), si = mi * q - ci * B, bi = ci * w - oi * q, Zi = oi * B - mi * w, ni = Math.hypot(si, bi, Zi), ni ? (ni = 1 / ni, si *= ni, bi *= ni, Zi *= ni) : (si = 0, bi = 0, Zi = 0), m[0] = w, m[1] = si, m[2] = oi, m[3] = 0, m[4] = B, m[5] = bi, m[6] = mi, m[7] = 0, m[8] = q, m[9] = Zi, m[10] = ci, m[11] = 0, m[12] = -(w * Gi + B * Vi + q * Wi), m[13] = -(si * Gi + bi * Vi + Zi * Wi), m[14] = -(oi * Gi + mi * Vi + ci * Wi), m[15] = 1, m);
      }
      function ii(m, h, g, f) {
        var w = h[0], B = h[1], q = h[2], si = f[0], bi = f[1], Zi = f[2], oi = w - g[0], mi = B - g[1], ci = q - g[2], ni = oi * oi + mi * mi + ci * ci;
        ni > 0 && (ni = 1 / Math.sqrt(ni), oi *= ni, mi *= ni, ci *= ni);
        var Gi = bi * ci - Zi * mi, Vi = Zi * oi - si * ci, Wi = si * mi - bi * oi;
        return ni = Gi * Gi + Vi * Vi + Wi * Wi, ni > 0 && (ni = 1 / Math.sqrt(ni), Gi *= ni, Vi *= ni, Wi *= ni), m[0] = Gi, m[1] = Vi, m[2] = Wi, m[3] = 0, m[4] = mi * Wi - ci * Vi, m[5] = ci * Gi - oi * Wi, m[6] = oi * Vi - mi * Gi, m[7] = 0, m[8] = oi, m[9] = mi, m[10] = ci, m[11] = 0, m[12] = w, m[13] = B, m[14] = q, m[15] = 1, m;
      }
      function ti(m) {
        return "mat4(" + m[0] + ", " + m[1] + ", " + m[2] + ", " + m[3] + ", " + m[4] + ", " + m[5] + ", " + m[6] + ", " + m[7] + ", " + m[8] + ", " + m[9] + ", " + m[10] + ", " + m[11] + ", " + m[12] + ", " + m[13] + ", " + m[14] + ", " + m[15] + ")";
      }
      function $(m) {
        return Math.hypot(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
      }
      function ai(m, h, g) {
        return m[0] = h[0] + g[0], m[1] = h[1] + g[1], m[2] = h[2] + g[2], m[3] = h[3] + g[3], m[4] = h[4] + g[4], m[5] = h[5] + g[5], m[6] = h[6] + g[6], m[7] = h[7] + g[7], m[8] = h[8] + g[8], m[9] = h[9] + g[9], m[10] = h[10] + g[10], m[11] = h[11] + g[11], m[12] = h[12] + g[12], m[13] = h[13] + g[13], m[14] = h[14] + g[14], m[15] = h[15] + g[15], m;
      }
      function Xi(m, h, g) {
        return m[0] = h[0] - g[0], m[1] = h[1] - g[1], m[2] = h[2] - g[2], m[3] = h[3] - g[3], m[4] = h[4] - g[4], m[5] = h[5] - g[5], m[6] = h[6] - g[6], m[7] = h[7] - g[7], m[8] = h[8] - g[8], m[9] = h[9] - g[9], m[10] = h[10] - g[10], m[11] = h[11] - g[11], m[12] = h[12] - g[12], m[13] = h[13] - g[13], m[14] = h[14] - g[14], m[15] = h[15] - g[15], m;
      }
      function z(m, h, g) {
        return m[0] = h[0] * g, m[1] = h[1] * g, m[2] = h[2] * g, m[3] = h[3] * g, m[4] = h[4] * g, m[5] = h[5] * g, m[6] = h[6] * g, m[7] = h[7] * g, m[8] = h[8] * g, m[9] = h[9] * g, m[10] = h[10] * g, m[11] = h[11] * g, m[12] = h[12] * g, m[13] = h[13] * g, m[14] = h[14] * g, m[15] = h[15] * g, m;
      }
      function k(m, h, g, f) {
        return m[0] = h[0] + g[0] * f, m[1] = h[1] + g[1] * f, m[2] = h[2] + g[2] * f, m[3] = h[3] + g[3] * f, m[4] = h[4] + g[4] * f, m[5] = h[5] + g[5] * f, m[6] = h[6] + g[6] * f, m[7] = h[7] + g[7] * f, m[8] = h[8] + g[8] * f, m[9] = h[9] + g[9] * f, m[10] = h[10] + g[10] * f, m[11] = h[11] + g[11] * f, m[12] = h[12] + g[12] * f, m[13] = h[13] + g[13] * f, m[14] = h[14] + g[14] * f, m[15] = h[15] + g[15] * f, m;
      }
      function j(m, h) {
        return m[0] === h[0] && m[1] === h[1] && m[2] === h[2] && m[3] === h[3] && m[4] === h[4] && m[5] === h[5] && m[6] === h[6] && m[7] === h[7] && m[8] === h[8] && m[9] === h[9] && m[10] === h[10] && m[11] === h[11] && m[12] === h[12] && m[13] === h[13] && m[14] === h[14] && m[15] === h[15];
      }
      function A(m, h) {
        var g = m[0], f = m[1], w = m[2], B = m[3], q = m[4], si = m[5], bi = m[6], Zi = m[7], oi = m[8], mi = m[9], ci = m[10], ni = m[11], Gi = m[12], Vi = m[13], Wi = m[14], Ii = m[15], Ri = h[0], yi = h[1], Li = h[2], ri = h[3], Si = h[4], wi = h[5], zi = h[6], Qi = h[7], ki = h[8], Pi = h[9], fi = h[10], ji = h[11], Ji = h[12], $i = h[13], Zl = h[14], nl = h[15];
        return Math.abs(g - Ri) <= c.EPSILON * Math.max(1, Math.abs(g), Math.abs(Ri)) && Math.abs(f - yi) <= c.EPSILON * Math.max(1, Math.abs(f), Math.abs(yi)) && Math.abs(w - Li) <= c.EPSILON * Math.max(1, Math.abs(w), Math.abs(Li)) && Math.abs(B - ri) <= c.EPSILON * Math.max(1, Math.abs(B), Math.abs(ri)) && Math.abs(q - Si) <= c.EPSILON * Math.max(1, Math.abs(q), Math.abs(Si)) && Math.abs(si - wi) <= c.EPSILON * Math.max(1, Math.abs(si), Math.abs(wi)) && Math.abs(bi - zi) <= c.EPSILON * Math.max(1, Math.abs(bi), Math.abs(zi)) && Math.abs(Zi - Qi) <= c.EPSILON * Math.max(1, Math.abs(Zi), Math.abs(Qi)) && Math.abs(oi - ki) <= c.EPSILON * Math.max(1, Math.abs(oi), Math.abs(ki)) && Math.abs(mi - Pi) <= c.EPSILON * Math.max(1, Math.abs(mi), Math.abs(Pi)) && Math.abs(ci - fi) <= c.EPSILON * Math.max(1, Math.abs(ci), Math.abs(fi)) && Math.abs(ni - ji) <= c.EPSILON * Math.max(1, Math.abs(ni), Math.abs(ji)) && Math.abs(Gi - Ji) <= c.EPSILON * Math.max(1, Math.abs(Gi), Math.abs(Ji)) && Math.abs(Vi - $i) <= c.EPSILON * Math.max(1, Math.abs(Vi), Math.abs($i)) && Math.abs(Wi - Zl) <= c.EPSILON * Math.max(1, Math.abs(Wi), Math.abs(Zl)) && Math.abs(Ii - nl) <= c.EPSILON * Math.max(1, Math.abs(Ii), Math.abs(nl));
      }
      var H = C, U = Xi;
    },
    /* 7 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return u;
      }), i.d(l, "identity", function() {
        return a;
      }), i.d(l, "setAxisAngle", function() {
        return e;
      }), i.d(l, "getAxisAngle", function() {
        return r;
      }), i.d(l, "getAngle", function() {
        return X;
      }), i.d(l, "multiply", function() {
        return W;
      }), i.d(l, "rotateX", function() {
        return p;
      }), i.d(l, "rotateY", function() {
        return C;
      }), i.d(l, "rotateZ", function() {
        return I;
      }), i.d(l, "calculateW", function() {
        return o;
      }), i.d(l, "exp", function() {
        return G;
      }), i.d(l, "ln", function() {
        return d;
      }), i.d(l, "pow", function() {
        return t;
      }), i.d(l, "slerp", function() {
        return s;
      }), i.d(l, "random", function() {
        return b;
      }), i.d(l, "invert", function() {
        return V;
      }), i.d(l, "conjugate", function() {
        return S;
      }), i.d(l, "fromMat3", function() {
        return Y;
      }), i.d(l, "fromEuler", function() {
        return T;
      }), i.d(l, "str", function() {
        return y;
      }), i.d(l, "clone", function() {
        return J;
      }), i.d(l, "fromValues", function() {
        return N;
      }), i.d(l, "copy", function() {
        return R;
      }), i.d(l, "set", function() {
        return x;
      }), i.d(l, "add", function() {
        return M;
      }), i.d(l, "mul", function() {
        return Q;
      }), i.d(l, "scale", function() {
        return P;
      }), i.d(l, "dot", function() {
        return D;
      }), i.d(l, "lerp", function() {
        return _;
      }), i.d(l, "length", function() {
        return F;
      }), i.d(l, "len", function() {
        return v;
      }), i.d(l, "squaredLength", function() {
        return O;
      }), i.d(l, "sqrLen", function() {
        return li;
      }), i.d(l, "normalize", function() {
        return ii;
      }), i.d(l, "exactEquals", function() {
        return ti;
      }), i.d(l, "equals", function() {
        return $;
      }), i.d(l, "rotationTo", function() {
        return ai;
      }), i.d(l, "sqlerp", function() {
        return Xi;
      }), i.d(l, "setAxes", function() {
        return z;
      });
      var c = i(2), Z = i(5), L = i(8), K = i(9);
      function u() {
        var k = new c.ARRAY_TYPE(4);
        return c.ARRAY_TYPE != Float32Array && (k[0] = 0, k[1] = 0, k[2] = 0), k[3] = 1, k;
      }
      function a(k) {
        return k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 1, k;
      }
      function e(k, j, A) {
        A = A * 0.5;
        var H = Math.sin(A);
        return k[0] = H * j[0], k[1] = H * j[1], k[2] = H * j[2], k[3] = Math.cos(A), k;
      }
      function r(k, j) {
        var A = Math.acos(j[3]) * 2, H = Math.sin(A / 2);
        return H > c.EPSILON ? (k[0] = j[0] / H, k[1] = j[1] / H, k[2] = j[2] / H) : (k[0] = 1, k[1] = 0, k[2] = 0), A;
      }
      function X(k, j) {
        var A = D(k, j);
        return Math.acos(2 * A * A - 1);
      }
      function W(k, j, A) {
        var H = j[0], U = j[1], m = j[2], h = j[3], g = A[0], f = A[1], w = A[2], B = A[3];
        return k[0] = H * B + h * g + U * w - m * f, k[1] = U * B + h * f + m * g - H * w, k[2] = m * B + h * w + H * f - U * g, k[3] = h * B - H * g - U * f - m * w, k;
      }
      function p(k, j, A) {
        A *= 0.5;
        var H = j[0], U = j[1], m = j[2], h = j[3], g = Math.sin(A), f = Math.cos(A);
        return k[0] = H * f + h * g, k[1] = U * f + m * g, k[2] = m * f - U * g, k[3] = h * f - H * g, k;
      }
      function C(k, j, A) {
        A *= 0.5;
        var H = j[0], U = j[1], m = j[2], h = j[3], g = Math.sin(A), f = Math.cos(A);
        return k[0] = H * f - m * g, k[1] = U * f + h * g, k[2] = m * f + H * g, k[3] = h * f - U * g, k;
      }
      function I(k, j, A) {
        A *= 0.5;
        var H = j[0], U = j[1], m = j[2], h = j[3], g = Math.sin(A), f = Math.cos(A);
        return k[0] = H * f + U * g, k[1] = U * f - H * g, k[2] = m * f + h * g, k[3] = h * f - m * g, k;
      }
      function o(k, j) {
        var A = j[0], H = j[1], U = j[2];
        return k[0] = A, k[1] = H, k[2] = U, k[3] = Math.sqrt(Math.abs(1 - A * A - H * H - U * U)), k;
      }
      function G(k, j) {
        var A = j[0], H = j[1], U = j[2], m = j[3], h = Math.sqrt(A * A + H * H + U * U), g = Math.exp(m), f = h > 0 ? g * Math.sin(h) / h : 0;
        return k[0] = A * f, k[1] = H * f, k[2] = U * f, k[3] = g * Math.cos(h), k;
      }
      function d(k, j) {
        var A = j[0], H = j[1], U = j[2], m = j[3], h = Math.sqrt(A * A + H * H + U * U), g = h > 0 ? Math.atan2(h, m) / h : 0;
        return k[0] = A * g, k[1] = H * g, k[2] = U * g, k[3] = 0.5 * Math.log(A * A + H * H + U * U + m * m), k;
      }
      function t(k, j, A) {
        return d(k, j), P(k, k, A), G(k, k), k;
      }
      function s(k, j, A, H) {
        var U = j[0], m = j[1], h = j[2], g = j[3], f = A[0], w = A[1], B = A[2], q = A[3], si, bi, Zi, oi, mi;
        return bi = U * f + m * w + h * B + g * q, bi < 0 && (bi = -bi, f = -f, w = -w, B = -B, q = -q), 1 - bi > c.EPSILON ? (si = Math.acos(bi), Zi = Math.sin(si), oi = Math.sin((1 - H) * si) / Zi, mi = Math.sin(H * si) / Zi) : (oi = 1 - H, mi = H), k[0] = oi * U + mi * f, k[1] = oi * m + mi * w, k[2] = oi * h + mi * B, k[3] = oi * g + mi * q, k;
      }
      function b(k) {
        var j = c.RANDOM(), A = c.RANDOM(), H = c.RANDOM(), U = Math.sqrt(1 - j), m = Math.sqrt(j);
        return k[0] = U * Math.sin(2 * Math.PI * A), k[1] = U * Math.cos(2 * Math.PI * A), k[2] = m * Math.sin(2 * Math.PI * H), k[3] = m * Math.cos(2 * Math.PI * H), k;
      }
      function V(k, j) {
        var A = j[0], H = j[1], U = j[2], m = j[3], h = A * A + H * H + U * U + m * m, g = h ? 1 / h : 0;
        return k[0] = -A * g, k[1] = -H * g, k[2] = -U * g, k[3] = m * g, k;
      }
      function S(k, j) {
        return k[0] = -j[0], k[1] = -j[1], k[2] = -j[2], k[3] = j[3], k;
      }
      function Y(k, j) {
        var A = j[0] + j[4] + j[8], H;
        if (A > 0)
          H = Math.sqrt(A + 1), k[3] = 0.5 * H, H = 0.5 / H, k[0] = (j[5] - j[7]) * H, k[1] = (j[6] - j[2]) * H, k[2] = (j[1] - j[3]) * H;
        else {
          var U = 0;
          j[4] > j[0] && (U = 1), j[8] > j[U * 3 + U] && (U = 2);
          var m = (U + 1) % 3, h = (U + 2) % 3;
          H = Math.sqrt(j[U * 3 + U] - j[m * 3 + m] - j[h * 3 + h] + 1), k[U] = 0.5 * H, H = 0.5 / H, k[3] = (j[m * 3 + h] - j[h * 3 + m]) * H, k[m] = (j[m * 3 + U] + j[U * 3 + m]) * H, k[h] = (j[h * 3 + U] + j[U * 3 + h]) * H;
        }
        return k;
      }
      function T(k, j, A, H) {
        var U = 0.5 * Math.PI / 180;
        j *= U, A *= U, H *= U;
        var m = Math.sin(j), h = Math.cos(j), g = Math.sin(A), f = Math.cos(A), w = Math.sin(H), B = Math.cos(H);
        return k[0] = m * f * B - h * g * w, k[1] = h * g * B + m * f * w, k[2] = h * f * w - m * g * B, k[3] = h * f * B + m * g * w, k;
      }
      function y(k) {
        return "quat(" + k[0] + ", " + k[1] + ", " + k[2] + ", " + k[3] + ")";
      }
      var J = K.clone, N = K.fromValues, R = K.copy, x = K.set, M = K.add, Q = W, P = K.scale, D = K.dot, _ = K.lerp, F = K.length, v = F, O = K.squaredLength, li = O, ii = K.normalize, ti = K.exactEquals, $ = K.equals, ai = function() {
        var k = L.create(), j = L.fromValues(1, 0, 0), A = L.fromValues(0, 1, 0);
        return function(H, U, m) {
          var h = L.dot(U, m);
          return h < -0.999999 ? (L.cross(k, j, U), L.len(k) < 1e-6 && L.cross(k, A, U), L.normalize(k, k), e(H, k, Math.PI), H) : h > 0.999999 ? (H[0] = 0, H[1] = 0, H[2] = 0, H[3] = 1, H) : (L.cross(k, U, m), H[0] = k[0], H[1] = k[1], H[2] = k[2], H[3] = 1 + h, ii(H, H));
        };
      }(), Xi = function() {
        var k = u(), j = u();
        return function(A, H, U, m, h, g) {
          return s(k, H, h, g), s(j, U, m, g), s(A, k, j, 2 * g * (1 - g)), A;
        };
      }(), z = function() {
        var k = Z.create();
        return function(j, A, H, U) {
          return k[0] = H[0], k[3] = H[1], k[6] = H[2], k[1] = U[0], k[4] = U[1], k[7] = U[2], k[2] = -A[0], k[5] = -A[1], k[8] = -A[2], ii(j, Y(j, k));
        };
      }();
    },
    /* 8 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return Z;
      }), i.d(l, "clone", function() {
        return L;
      }), i.d(l, "length", function() {
        return K;
      }), i.d(l, "fromValues", function() {
        return u;
      }), i.d(l, "copy", function() {
        return a;
      }), i.d(l, "set", function() {
        return e;
      }), i.d(l, "add", function() {
        return r;
      }), i.d(l, "subtract", function() {
        return X;
      }), i.d(l, "multiply", function() {
        return W;
      }), i.d(l, "divide", function() {
        return p;
      }), i.d(l, "ceil", function() {
        return C;
      }), i.d(l, "floor", function() {
        return I;
      }), i.d(l, "min", function() {
        return o;
      }), i.d(l, "max", function() {
        return G;
      }), i.d(l, "round", function() {
        return d;
      }), i.d(l, "scale", function() {
        return t;
      }), i.d(l, "scaleAndAdd", function() {
        return s;
      }), i.d(l, "distance", function() {
        return b;
      }), i.d(l, "squaredDistance", function() {
        return V;
      }), i.d(l, "squaredLength", function() {
        return S;
      }), i.d(l, "negate", function() {
        return Y;
      }), i.d(l, "inverse", function() {
        return T;
      }), i.d(l, "normalize", function() {
        return y;
      }), i.d(l, "dot", function() {
        return J;
      }), i.d(l, "cross", function() {
        return N;
      }), i.d(l, "lerp", function() {
        return R;
      }), i.d(l, "hermite", function() {
        return x;
      }), i.d(l, "bezier", function() {
        return M;
      }), i.d(l, "random", function() {
        return Q;
      }), i.d(l, "transformMat4", function() {
        return P;
      }), i.d(l, "transformMat3", function() {
        return D;
      }), i.d(l, "transformQuat", function() {
        return _;
      }), i.d(l, "rotateX", function() {
        return F;
      }), i.d(l, "rotateY", function() {
        return v;
      }), i.d(l, "rotateZ", function() {
        return O;
      }), i.d(l, "angle", function() {
        return li;
      }), i.d(l, "zero", function() {
        return ii;
      }), i.d(l, "str", function() {
        return ti;
      }), i.d(l, "exactEquals", function() {
        return $;
      }), i.d(l, "equals", function() {
        return ai;
      }), i.d(l, "sub", function() {
        return Xi;
      }), i.d(l, "mul", function() {
        return z;
      }), i.d(l, "div", function() {
        return k;
      }), i.d(l, "dist", function() {
        return j;
      }), i.d(l, "sqrDist", function() {
        return A;
      }), i.d(l, "len", function() {
        return H;
      }), i.d(l, "sqrLen", function() {
        return U;
      }), i.d(l, "forEach", function() {
        return m;
      });
      var c = i(2);
      function Z() {
        var h = new c.ARRAY_TYPE(3);
        return c.ARRAY_TYPE != Float32Array && (h[0] = 0, h[1] = 0, h[2] = 0), h;
      }
      function L(h) {
        var g = new c.ARRAY_TYPE(3);
        return g[0] = h[0], g[1] = h[1], g[2] = h[2], g;
      }
      function K(h) {
        var g = h[0], f = h[1], w = h[2];
        return Math.hypot(g, f, w);
      }
      function u(h, g, f) {
        var w = new c.ARRAY_TYPE(3);
        return w[0] = h, w[1] = g, w[2] = f, w;
      }
      function a(h, g) {
        return h[0] = g[0], h[1] = g[1], h[2] = g[2], h;
      }
      function e(h, g, f, w) {
        return h[0] = g, h[1] = f, h[2] = w, h;
      }
      function r(h, g, f) {
        return h[0] = g[0] + f[0], h[1] = g[1] + f[1], h[2] = g[2] + f[2], h;
      }
      function X(h, g, f) {
        return h[0] = g[0] - f[0], h[1] = g[1] - f[1], h[2] = g[2] - f[2], h;
      }
      function W(h, g, f) {
        return h[0] = g[0] * f[0], h[1] = g[1] * f[1], h[2] = g[2] * f[2], h;
      }
      function p(h, g, f) {
        return h[0] = g[0] / f[0], h[1] = g[1] / f[1], h[2] = g[2] / f[2], h;
      }
      function C(h, g) {
        return h[0] = Math.ceil(g[0]), h[1] = Math.ceil(g[1]), h[2] = Math.ceil(g[2]), h;
      }
      function I(h, g) {
        return h[0] = Math.floor(g[0]), h[1] = Math.floor(g[1]), h[2] = Math.floor(g[2]), h;
      }
      function o(h, g, f) {
        return h[0] = Math.min(g[0], f[0]), h[1] = Math.min(g[1], f[1]), h[2] = Math.min(g[2], f[2]), h;
      }
      function G(h, g, f) {
        return h[0] = Math.max(g[0], f[0]), h[1] = Math.max(g[1], f[1]), h[2] = Math.max(g[2], f[2]), h;
      }
      function d(h, g) {
        return h[0] = Math.round(g[0]), h[1] = Math.round(g[1]), h[2] = Math.round(g[2]), h;
      }
      function t(h, g, f) {
        return h[0] = g[0] * f, h[1] = g[1] * f, h[2] = g[2] * f, h;
      }
      function s(h, g, f, w) {
        return h[0] = g[0] + f[0] * w, h[1] = g[1] + f[1] * w, h[2] = g[2] + f[2] * w, h;
      }
      function b(h, g) {
        var f = g[0] - h[0], w = g[1] - h[1], B = g[2] - h[2];
        return Math.hypot(f, w, B);
      }
      function V(h, g) {
        var f = g[0] - h[0], w = g[1] - h[1], B = g[2] - h[2];
        return f * f + w * w + B * B;
      }
      function S(h) {
        var g = h[0], f = h[1], w = h[2];
        return g * g + f * f + w * w;
      }
      function Y(h, g) {
        return h[0] = -g[0], h[1] = -g[1], h[2] = -g[2], h;
      }
      function T(h, g) {
        return h[0] = 1 / g[0], h[1] = 1 / g[1], h[2] = 1 / g[2], h;
      }
      function y(h, g) {
        var f = g[0], w = g[1], B = g[2], q = f * f + w * w + B * B;
        return q > 0 && (q = 1 / Math.sqrt(q)), h[0] = g[0] * q, h[1] = g[1] * q, h[2] = g[2] * q, h;
      }
      function J(h, g) {
        return h[0] * g[0] + h[1] * g[1] + h[2] * g[2];
      }
      function N(h, g, f) {
        var w = g[0], B = g[1], q = g[2], si = f[0], bi = f[1], Zi = f[2];
        return h[0] = B * Zi - q * bi, h[1] = q * si - w * Zi, h[2] = w * bi - B * si, h;
      }
      function R(h, g, f, w) {
        var B = g[0], q = g[1], si = g[2];
        return h[0] = B + w * (f[0] - B), h[1] = q + w * (f[1] - q), h[2] = si + w * (f[2] - si), h;
      }
      function x(h, g, f, w, B, q) {
        var si = q * q, bi = si * (2 * q - 3) + 1, Zi = si * (q - 2) + q, oi = si * (q - 1), mi = si * (3 - 2 * q);
        return h[0] = g[0] * bi + f[0] * Zi + w[0] * oi + B[0] * mi, h[1] = g[1] * bi + f[1] * Zi + w[1] * oi + B[1] * mi, h[2] = g[2] * bi + f[2] * Zi + w[2] * oi + B[2] * mi, h;
      }
      function M(h, g, f, w, B, q) {
        var si = 1 - q, bi = si * si, Zi = q * q, oi = bi * si, mi = 3 * q * bi, ci = 3 * Zi * si, ni = Zi * q;
        return h[0] = g[0] * oi + f[0] * mi + w[0] * ci + B[0] * ni, h[1] = g[1] * oi + f[1] * mi + w[1] * ci + B[1] * ni, h[2] = g[2] * oi + f[2] * mi + w[2] * ci + B[2] * ni, h;
      }
      function Q(h, g) {
        g = g || 1;
        var f = c.RANDOM() * 2 * Math.PI, w = c.RANDOM() * 2 - 1, B = Math.sqrt(1 - w * w) * g;
        return h[0] = Math.cos(f) * B, h[1] = Math.sin(f) * B, h[2] = w * g, h;
      }
      function P(h, g, f) {
        var w = g[0], B = g[1], q = g[2], si = f[3] * w + f[7] * B + f[11] * q + f[15];
        return si = si || 1, h[0] = (f[0] * w + f[4] * B + f[8] * q + f[12]) / si, h[1] = (f[1] * w + f[5] * B + f[9] * q + f[13]) / si, h[2] = (f[2] * w + f[6] * B + f[10] * q + f[14]) / si, h;
      }
      function D(h, g, f) {
        var w = g[0], B = g[1], q = g[2];
        return h[0] = w * f[0] + B * f[3] + q * f[6], h[1] = w * f[1] + B * f[4] + q * f[7], h[2] = w * f[2] + B * f[5] + q * f[8], h;
      }
      function _(h, g, f) {
        var w = f[0], B = f[1], q = f[2], si = f[3], bi = g[0], Zi = g[1], oi = g[2], mi = B * oi - q * Zi, ci = q * bi - w * oi, ni = w * Zi - B * bi, Gi = B * ni - q * ci, Vi = q * mi - w * ni, Wi = w * ci - B * mi, Ii = si * 2;
        return mi *= Ii, ci *= Ii, ni *= Ii, Gi *= 2, Vi *= 2, Wi *= 2, h[0] = bi + mi + Gi, h[1] = Zi + ci + Vi, h[2] = oi + ni + Wi, h;
      }
      function F(h, g, f, w) {
        var B = [], q = [];
        return B[0] = g[0] - f[0], B[1] = g[1] - f[1], B[2] = g[2] - f[2], q[0] = B[0], q[1] = B[1] * Math.cos(w) - B[2] * Math.sin(w), q[2] = B[1] * Math.sin(w) + B[2] * Math.cos(w), h[0] = q[0] + f[0], h[1] = q[1] + f[1], h[2] = q[2] + f[2], h;
      }
      function v(h, g, f, w) {
        var B = [], q = [];
        return B[0] = g[0] - f[0], B[1] = g[1] - f[1], B[2] = g[2] - f[2], q[0] = B[2] * Math.sin(w) + B[0] * Math.cos(w), q[1] = B[1], q[2] = B[2] * Math.cos(w) - B[0] * Math.sin(w), h[0] = q[0] + f[0], h[1] = q[1] + f[1], h[2] = q[2] + f[2], h;
      }
      function O(h, g, f, w) {
        var B = [], q = [];
        return B[0] = g[0] - f[0], B[1] = g[1] - f[1], B[2] = g[2] - f[2], q[0] = B[0] * Math.cos(w) - B[1] * Math.sin(w), q[1] = B[0] * Math.sin(w) + B[1] * Math.cos(w), q[2] = B[2], h[0] = q[0] + f[0], h[1] = q[1] + f[1], h[2] = q[2] + f[2], h;
      }
      function li(h, g) {
        var f = h[0], w = h[1], B = h[2], q = g[0], si = g[1], bi = g[2], Zi = Math.sqrt(f * f + w * w + B * B), oi = Math.sqrt(q * q + si * si + bi * bi), mi = Zi * oi, ci = mi && J(h, g) / mi;
        return Math.acos(Math.min(Math.max(ci, -1), 1));
      }
      function ii(h) {
        return h[0] = 0, h[1] = 0, h[2] = 0, h;
      }
      function ti(h) {
        return "vec3(" + h[0] + ", " + h[1] + ", " + h[2] + ")";
      }
      function $(h, g) {
        return h[0] === g[0] && h[1] === g[1] && h[2] === g[2];
      }
      function ai(h, g) {
        var f = h[0], w = h[1], B = h[2], q = g[0], si = g[1], bi = g[2];
        return Math.abs(f - q) <= c.EPSILON * Math.max(1, Math.abs(f), Math.abs(q)) && Math.abs(w - si) <= c.EPSILON * Math.max(1, Math.abs(w), Math.abs(si)) && Math.abs(B - bi) <= c.EPSILON * Math.max(1, Math.abs(B), Math.abs(bi));
      }
      var Xi = X, z = W, k = p, j = b, A = V, H = K, U = S, m = function() {
        var h = Z();
        return function(g, f, w, B, q, si) {
          var bi, Zi;
          for (f || (f = 3), w || (w = 0), B ? Zi = Math.min(B * f + w, g.length) : Zi = g.length, bi = w; bi < Zi; bi += f)
            h[0] = g[bi], h[1] = g[bi + 1], h[2] = g[bi + 2], q(h, h, si), g[bi] = h[0], g[bi + 1] = h[1], g[bi + 2] = h[2];
          return g;
        };
      }();
    },
    /* 9 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return Z;
      }), i.d(l, "clone", function() {
        return L;
      }), i.d(l, "fromValues", function() {
        return K;
      }), i.d(l, "copy", function() {
        return u;
      }), i.d(l, "set", function() {
        return a;
      }), i.d(l, "add", function() {
        return e;
      }), i.d(l, "subtract", function() {
        return r;
      }), i.d(l, "multiply", function() {
        return X;
      }), i.d(l, "divide", function() {
        return W;
      }), i.d(l, "ceil", function() {
        return p;
      }), i.d(l, "floor", function() {
        return C;
      }), i.d(l, "min", function() {
        return I;
      }), i.d(l, "max", function() {
        return o;
      }), i.d(l, "round", function() {
        return G;
      }), i.d(l, "scale", function() {
        return d;
      }), i.d(l, "scaleAndAdd", function() {
        return t;
      }), i.d(l, "distance", function() {
        return s;
      }), i.d(l, "squaredDistance", function() {
        return b;
      }), i.d(l, "length", function() {
        return V;
      }), i.d(l, "squaredLength", function() {
        return S;
      }), i.d(l, "negate", function() {
        return Y;
      }), i.d(l, "inverse", function() {
        return T;
      }), i.d(l, "normalize", function() {
        return y;
      }), i.d(l, "dot", function() {
        return J;
      }), i.d(l, "cross", function() {
        return N;
      }), i.d(l, "lerp", function() {
        return R;
      }), i.d(l, "random", function() {
        return x;
      }), i.d(l, "transformMat4", function() {
        return M;
      }), i.d(l, "transformQuat", function() {
        return Q;
      }), i.d(l, "zero", function() {
        return P;
      }), i.d(l, "str", function() {
        return D;
      }), i.d(l, "exactEquals", function() {
        return _;
      }), i.d(l, "equals", function() {
        return F;
      }), i.d(l, "sub", function() {
        return v;
      }), i.d(l, "mul", function() {
        return O;
      }), i.d(l, "div", function() {
        return li;
      }), i.d(l, "dist", function() {
        return ii;
      }), i.d(l, "sqrDist", function() {
        return ti;
      }), i.d(l, "len", function() {
        return $;
      }), i.d(l, "sqrLen", function() {
        return ai;
      }), i.d(l, "forEach", function() {
        return Xi;
      });
      var c = i(2);
      function Z() {
        var z = new c.ARRAY_TYPE(4);
        return c.ARRAY_TYPE != Float32Array && (z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 0), z;
      }
      function L(z) {
        var k = new c.ARRAY_TYPE(4);
        return k[0] = z[0], k[1] = z[1], k[2] = z[2], k[3] = z[3], k;
      }
      function K(z, k, j, A) {
        var H = new c.ARRAY_TYPE(4);
        return H[0] = z, H[1] = k, H[2] = j, H[3] = A, H;
      }
      function u(z, k) {
        return z[0] = k[0], z[1] = k[1], z[2] = k[2], z[3] = k[3], z;
      }
      function a(z, k, j, A, H) {
        return z[0] = k, z[1] = j, z[2] = A, z[3] = H, z;
      }
      function e(z, k, j) {
        return z[0] = k[0] + j[0], z[1] = k[1] + j[1], z[2] = k[2] + j[2], z[3] = k[3] + j[3], z;
      }
      function r(z, k, j) {
        return z[0] = k[0] - j[0], z[1] = k[1] - j[1], z[2] = k[2] - j[2], z[3] = k[3] - j[3], z;
      }
      function X(z, k, j) {
        return z[0] = k[0] * j[0], z[1] = k[1] * j[1], z[2] = k[2] * j[2], z[3] = k[3] * j[3], z;
      }
      function W(z, k, j) {
        return z[0] = k[0] / j[0], z[1] = k[1] / j[1], z[2] = k[2] / j[2], z[3] = k[3] / j[3], z;
      }
      function p(z, k) {
        return z[0] = Math.ceil(k[0]), z[1] = Math.ceil(k[1]), z[2] = Math.ceil(k[2]), z[3] = Math.ceil(k[3]), z;
      }
      function C(z, k) {
        return z[0] = Math.floor(k[0]), z[1] = Math.floor(k[1]), z[2] = Math.floor(k[2]), z[3] = Math.floor(k[3]), z;
      }
      function I(z, k, j) {
        return z[0] = Math.min(k[0], j[0]), z[1] = Math.min(k[1], j[1]), z[2] = Math.min(k[2], j[2]), z[3] = Math.min(k[3], j[3]), z;
      }
      function o(z, k, j) {
        return z[0] = Math.max(k[0], j[0]), z[1] = Math.max(k[1], j[1]), z[2] = Math.max(k[2], j[2]), z[3] = Math.max(k[3], j[3]), z;
      }
      function G(z, k) {
        return z[0] = Math.round(k[0]), z[1] = Math.round(k[1]), z[2] = Math.round(k[2]), z[3] = Math.round(k[3]), z;
      }
      function d(z, k, j) {
        return z[0] = k[0] * j, z[1] = k[1] * j, z[2] = k[2] * j, z[3] = k[3] * j, z;
      }
      function t(z, k, j, A) {
        return z[0] = k[0] + j[0] * A, z[1] = k[1] + j[1] * A, z[2] = k[2] + j[2] * A, z[3] = k[3] + j[3] * A, z;
      }
      function s(z, k) {
        var j = k[0] - z[0], A = k[1] - z[1], H = k[2] - z[2], U = k[3] - z[3];
        return Math.hypot(j, A, H, U);
      }
      function b(z, k) {
        var j = k[0] - z[0], A = k[1] - z[1], H = k[2] - z[2], U = k[3] - z[3];
        return j * j + A * A + H * H + U * U;
      }
      function V(z) {
        var k = z[0], j = z[1], A = z[2], H = z[3];
        return Math.hypot(k, j, A, H);
      }
      function S(z) {
        var k = z[0], j = z[1], A = z[2], H = z[3];
        return k * k + j * j + A * A + H * H;
      }
      function Y(z, k) {
        return z[0] = -k[0], z[1] = -k[1], z[2] = -k[2], z[3] = -k[3], z;
      }
      function T(z, k) {
        return z[0] = 1 / k[0], z[1] = 1 / k[1], z[2] = 1 / k[2], z[3] = 1 / k[3], z;
      }
      function y(z, k) {
        var j = k[0], A = k[1], H = k[2], U = k[3], m = j * j + A * A + H * H + U * U;
        return m > 0 && (m = 1 / Math.sqrt(m)), z[0] = j * m, z[1] = A * m, z[2] = H * m, z[3] = U * m, z;
      }
      function J(z, k) {
        return z[0] * k[0] + z[1] * k[1] + z[2] * k[2] + z[3] * k[3];
      }
      function N(z, k, j, A) {
        var H = j[0] * A[1] - j[1] * A[0], U = j[0] * A[2] - j[2] * A[0], m = j[0] * A[3] - j[3] * A[0], h = j[1] * A[2] - j[2] * A[1], g = j[1] * A[3] - j[3] * A[1], f = j[2] * A[3] - j[3] * A[2], w = k[0], B = k[1], q = k[2], si = k[3];
        return z[0] = B * f - q * g + si * h, z[1] = -(w * f) + q * m - si * U, z[2] = w * g - B * m + si * H, z[3] = -(w * h) + B * U - q * H, z;
      }
      function R(z, k, j, A) {
        var H = k[0], U = k[1], m = k[2], h = k[3];
        return z[0] = H + A * (j[0] - H), z[1] = U + A * (j[1] - U), z[2] = m + A * (j[2] - m), z[3] = h + A * (j[3] - h), z;
      }
      function x(z, k) {
        k = k || 1;
        var j, A, H, U, m, h;
        do
          j = c.RANDOM() * 2 - 1, A = c.RANDOM() * 2 - 1, m = j * j + A * A;
        while (m >= 1);
        do
          H = c.RANDOM() * 2 - 1, U = c.RANDOM() * 2 - 1, h = H * H + U * U;
        while (h >= 1);
        var g = Math.sqrt((1 - m) / h);
        return z[0] = k * j, z[1] = k * A, z[2] = k * H * g, z[3] = k * U * g, z;
      }
      function M(z, k, j) {
        var A = k[0], H = k[1], U = k[2], m = k[3];
        return z[0] = j[0] * A + j[4] * H + j[8] * U + j[12] * m, z[1] = j[1] * A + j[5] * H + j[9] * U + j[13] * m, z[2] = j[2] * A + j[6] * H + j[10] * U + j[14] * m, z[3] = j[3] * A + j[7] * H + j[11] * U + j[15] * m, z;
      }
      function Q(z, k, j) {
        var A = k[0], H = k[1], U = k[2], m = j[0], h = j[1], g = j[2], f = j[3], w = f * A + h * U - g * H, B = f * H + g * A - m * U, q = f * U + m * H - h * A, si = -m * A - h * H - g * U;
        return z[0] = w * f + si * -m + B * -g - q * -h, z[1] = B * f + si * -h + q * -m - w * -g, z[2] = q * f + si * -g + w * -h - B * -m, z[3] = k[3], z;
      }
      function P(z) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 0, z;
      }
      function D(z) {
        return "vec4(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ")";
      }
      function _(z, k) {
        return z[0] === k[0] && z[1] === k[1] && z[2] === k[2] && z[3] === k[3];
      }
      function F(z, k) {
        var j = z[0], A = z[1], H = z[2], U = z[3], m = k[0], h = k[1], g = k[2], f = k[3];
        return Math.abs(j - m) <= c.EPSILON * Math.max(1, Math.abs(j), Math.abs(m)) && Math.abs(A - h) <= c.EPSILON * Math.max(1, Math.abs(A), Math.abs(h)) && Math.abs(H - g) <= c.EPSILON * Math.max(1, Math.abs(H), Math.abs(g)) && Math.abs(U - f) <= c.EPSILON * Math.max(1, Math.abs(U), Math.abs(f));
      }
      var v = r, O = X, li = W, ii = s, ti = b, $ = V, ai = S, Xi = function() {
        var z = Z();
        return function(k, j, A, H, U, m) {
          var h, g;
          for (j || (j = 4), A || (A = 0), H ? g = Math.min(H * j + A, k.length) : g = k.length, h = A; h < g; h += j)
            z[0] = k[h], z[1] = k[h + 1], z[2] = k[h + 2], z[3] = k[h + 3], U(z, z, m), k[h] = z[0], k[h + 1] = z[1], k[h + 2] = z[2], k[h + 3] = z[3];
          return k;
        };
      }();
    },
    /* 10 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return K;
      }), i.d(l, "clone", function() {
        return u;
      }), i.d(l, "fromValues", function() {
        return a;
      }), i.d(l, "fromRotationTranslationValues", function() {
        return e;
      }), i.d(l, "fromRotationTranslation", function() {
        return r;
      }), i.d(l, "fromTranslation", function() {
        return X;
      }), i.d(l, "fromRotation", function() {
        return W;
      }), i.d(l, "fromMat4", function() {
        return p;
      }), i.d(l, "copy", function() {
        return C;
      }), i.d(l, "identity", function() {
        return I;
      }), i.d(l, "set", function() {
        return o;
      }), i.d(l, "getReal", function() {
        return G;
      }), i.d(l, "getDual", function() {
        return d;
      }), i.d(l, "setReal", function() {
        return t;
      }), i.d(l, "setDual", function() {
        return s;
      }), i.d(l, "getTranslation", function() {
        return b;
      }), i.d(l, "translate", function() {
        return V;
      }), i.d(l, "rotateX", function() {
        return S;
      }), i.d(l, "rotateY", function() {
        return Y;
      }), i.d(l, "rotateZ", function() {
        return T;
      }), i.d(l, "rotateByQuatAppend", function() {
        return y;
      }), i.d(l, "rotateByQuatPrepend", function() {
        return J;
      }), i.d(l, "rotateAroundAxis", function() {
        return N;
      }), i.d(l, "add", function() {
        return R;
      }), i.d(l, "multiply", function() {
        return x;
      }), i.d(l, "mul", function() {
        return M;
      }), i.d(l, "scale", function() {
        return Q;
      }), i.d(l, "dot", function() {
        return P;
      }), i.d(l, "lerp", function() {
        return D;
      }), i.d(l, "invert", function() {
        return _;
      }), i.d(l, "conjugate", function() {
        return F;
      }), i.d(l, "length", function() {
        return v;
      }), i.d(l, "len", function() {
        return O;
      }), i.d(l, "squaredLength", function() {
        return li;
      }), i.d(l, "sqrLen", function() {
        return ii;
      }), i.d(l, "normalize", function() {
        return ti;
      }), i.d(l, "str", function() {
        return $;
      }), i.d(l, "exactEquals", function() {
        return ai;
      }), i.d(l, "equals", function() {
        return Xi;
      });
      var c = i(2), Z = i(7), L = i(6);
      function K() {
        var z = new c.ARRAY_TYPE(8);
        return c.ARRAY_TYPE != Float32Array && (z[0] = 0, z[1] = 0, z[2] = 0, z[4] = 0, z[5] = 0, z[6] = 0, z[7] = 0), z[3] = 1, z;
      }
      function u(z) {
        var k = new c.ARRAY_TYPE(8);
        return k[0] = z[0], k[1] = z[1], k[2] = z[2], k[3] = z[3], k[4] = z[4], k[5] = z[5], k[6] = z[6], k[7] = z[7], k;
      }
      function a(z, k, j, A, H, U, m, h) {
        var g = new c.ARRAY_TYPE(8);
        return g[0] = z, g[1] = k, g[2] = j, g[3] = A, g[4] = H, g[5] = U, g[6] = m, g[7] = h, g;
      }
      function e(z, k, j, A, H, U, m) {
        var h = new c.ARRAY_TYPE(8);
        h[0] = z, h[1] = k, h[2] = j, h[3] = A;
        var g = H * 0.5, f = U * 0.5, w = m * 0.5;
        return h[4] = g * A + f * j - w * k, h[5] = f * A + w * z - g * j, h[6] = w * A + g * k - f * z, h[7] = -g * z - f * k - w * j, h;
      }
      function r(z, k, j) {
        var A = j[0] * 0.5, H = j[1] * 0.5, U = j[2] * 0.5, m = k[0], h = k[1], g = k[2], f = k[3];
        return z[0] = m, z[1] = h, z[2] = g, z[3] = f, z[4] = A * f + H * g - U * h, z[5] = H * f + U * m - A * g, z[6] = U * f + A * h - H * m, z[7] = -A * m - H * h - U * g, z;
      }
      function X(z, k) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z[4] = k[0] * 0.5, z[5] = k[1] * 0.5, z[6] = k[2] * 0.5, z[7] = 0, z;
      }
      function W(z, k) {
        return z[0] = k[0], z[1] = k[1], z[2] = k[2], z[3] = k[3], z[4] = 0, z[5] = 0, z[6] = 0, z[7] = 0, z;
      }
      function p(z, k) {
        var j = Z.create();
        L.getRotation(j, k);
        var A = new c.ARRAY_TYPE(3);
        return L.getTranslation(A, k), r(z, j, A), z;
      }
      function C(z, k) {
        return z[0] = k[0], z[1] = k[1], z[2] = k[2], z[3] = k[3], z[4] = k[4], z[5] = k[5], z[6] = k[6], z[7] = k[7], z;
      }
      function I(z) {
        return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z[4] = 0, z[5] = 0, z[6] = 0, z[7] = 0, z;
      }
      function o(z, k, j, A, H, U, m, h, g) {
        return z[0] = k, z[1] = j, z[2] = A, z[3] = H, z[4] = U, z[5] = m, z[6] = h, z[7] = g, z;
      }
      var G = Z.copy;
      function d(z, k) {
        return z[0] = k[4], z[1] = k[5], z[2] = k[6], z[3] = k[7], z;
      }
      var t = Z.copy;
      function s(z, k) {
        return z[4] = k[0], z[5] = k[1], z[6] = k[2], z[7] = k[3], z;
      }
      function b(z, k) {
        var j = k[4], A = k[5], H = k[6], U = k[7], m = -k[0], h = -k[1], g = -k[2], f = k[3];
        return z[0] = (j * f + U * m + A * g - H * h) * 2, z[1] = (A * f + U * h + H * m - j * g) * 2, z[2] = (H * f + U * g + j * h - A * m) * 2, z;
      }
      function V(z, k, j) {
        var A = k[0], H = k[1], U = k[2], m = k[3], h = j[0] * 0.5, g = j[1] * 0.5, f = j[2] * 0.5, w = k[4], B = k[5], q = k[6], si = k[7];
        return z[0] = A, z[1] = H, z[2] = U, z[3] = m, z[4] = m * h + H * f - U * g + w, z[5] = m * g + U * h - A * f + B, z[6] = m * f + A * g - H * h + q, z[7] = -A * h - H * g - U * f + si, z;
      }
      function S(z, k, j) {
        var A = -k[0], H = -k[1], U = -k[2], m = k[3], h = k[4], g = k[5], f = k[6], w = k[7], B = h * m + w * A + g * U - f * H, q = g * m + w * H + f * A - h * U, si = f * m + w * U + h * H - g * A, bi = w * m - h * A - g * H - f * U;
        return Z.rotateX(z, k, j), A = z[0], H = z[1], U = z[2], m = z[3], z[4] = B * m + bi * A + q * U - si * H, z[5] = q * m + bi * H + si * A - B * U, z[6] = si * m + bi * U + B * H - q * A, z[7] = bi * m - B * A - q * H - si * U, z;
      }
      function Y(z, k, j) {
        var A = -k[0], H = -k[1], U = -k[2], m = k[3], h = k[4], g = k[5], f = k[6], w = k[7], B = h * m + w * A + g * U - f * H, q = g * m + w * H + f * A - h * U, si = f * m + w * U + h * H - g * A, bi = w * m - h * A - g * H - f * U;
        return Z.rotateY(z, k, j), A = z[0], H = z[1], U = z[2], m = z[3], z[4] = B * m + bi * A + q * U - si * H, z[5] = q * m + bi * H + si * A - B * U, z[6] = si * m + bi * U + B * H - q * A, z[7] = bi * m - B * A - q * H - si * U, z;
      }
      function T(z, k, j) {
        var A = -k[0], H = -k[1], U = -k[2], m = k[3], h = k[4], g = k[5], f = k[6], w = k[7], B = h * m + w * A + g * U - f * H, q = g * m + w * H + f * A - h * U, si = f * m + w * U + h * H - g * A, bi = w * m - h * A - g * H - f * U;
        return Z.rotateZ(z, k, j), A = z[0], H = z[1], U = z[2], m = z[3], z[4] = B * m + bi * A + q * U - si * H, z[5] = q * m + bi * H + si * A - B * U, z[6] = si * m + bi * U + B * H - q * A, z[7] = bi * m - B * A - q * H - si * U, z;
      }
      function y(z, k, j) {
        var A = j[0], H = j[1], U = j[2], m = j[3], h = k[0], g = k[1], f = k[2], w = k[3];
        return z[0] = h * m + w * A + g * U - f * H, z[1] = g * m + w * H + f * A - h * U, z[2] = f * m + w * U + h * H - g * A, z[3] = w * m - h * A - g * H - f * U, h = k[4], g = k[5], f = k[6], w = k[7], z[4] = h * m + w * A + g * U - f * H, z[5] = g * m + w * H + f * A - h * U, z[6] = f * m + w * U + h * H - g * A, z[7] = w * m - h * A - g * H - f * U, z;
      }
      function J(z, k, j) {
        var A = k[0], H = k[1], U = k[2], m = k[3], h = j[0], g = j[1], f = j[2], w = j[3];
        return z[0] = A * w + m * h + H * f - U * g, z[1] = H * w + m * g + U * h - A * f, z[2] = U * w + m * f + A * g - H * h, z[3] = m * w - A * h - H * g - U * f, h = j[4], g = j[5], f = j[6], w = j[7], z[4] = A * w + m * h + H * f - U * g, z[5] = H * w + m * g + U * h - A * f, z[6] = U * w + m * f + A * g - H * h, z[7] = m * w - A * h - H * g - U * f, z;
      }
      function N(z, k, j, A) {
        if (Math.abs(A) < c.EPSILON)
          return C(z, k);
        var H = Math.hypot(j[0], j[1], j[2]);
        A = A * 0.5;
        var U = Math.sin(A), m = U * j[0] / H, h = U * j[1] / H, g = U * j[2] / H, f = Math.cos(A), w = k[0], B = k[1], q = k[2], si = k[3];
        z[0] = w * f + si * m + B * g - q * h, z[1] = B * f + si * h + q * m - w * g, z[2] = q * f + si * g + w * h - B * m, z[3] = si * f - w * m - B * h - q * g;
        var bi = k[4], Zi = k[5], oi = k[6], mi = k[7];
        return z[4] = bi * f + mi * m + Zi * g - oi * h, z[5] = Zi * f + mi * h + oi * m - bi * g, z[6] = oi * f + mi * g + bi * h - Zi * m, z[7] = mi * f - bi * m - Zi * h - oi * g, z;
      }
      function R(z, k, j) {
        return z[0] = k[0] + j[0], z[1] = k[1] + j[1], z[2] = k[2] + j[2], z[3] = k[3] + j[3], z[4] = k[4] + j[4], z[5] = k[5] + j[5], z[6] = k[6] + j[6], z[7] = k[7] + j[7], z;
      }
      function x(z, k, j) {
        var A = k[0], H = k[1], U = k[2], m = k[3], h = j[4], g = j[5], f = j[6], w = j[7], B = k[4], q = k[5], si = k[6], bi = k[7], Zi = j[0], oi = j[1], mi = j[2], ci = j[3];
        return z[0] = A * ci + m * Zi + H * mi - U * oi, z[1] = H * ci + m * oi + U * Zi - A * mi, z[2] = U * ci + m * mi + A * oi - H * Zi, z[3] = m * ci - A * Zi - H * oi - U * mi, z[4] = A * w + m * h + H * f - U * g + B * ci + bi * Zi + q * mi - si * oi, z[5] = H * w + m * g + U * h - A * f + q * ci + bi * oi + si * Zi - B * mi, z[6] = U * w + m * f + A * g - H * h + si * ci + bi * mi + B * oi - q * Zi, z[7] = m * w - A * h - H * g - U * f + bi * ci - B * Zi - q * oi - si * mi, z;
      }
      var M = x;
      function Q(z, k, j) {
        return z[0] = k[0] * j, z[1] = k[1] * j, z[2] = k[2] * j, z[3] = k[3] * j, z[4] = k[4] * j, z[5] = k[5] * j, z[6] = k[6] * j, z[7] = k[7] * j, z;
      }
      var P = Z.dot;
      function D(z, k, j, A) {
        var H = 1 - A;
        return P(k, j) < 0 && (A = -A), z[0] = k[0] * H + j[0] * A, z[1] = k[1] * H + j[1] * A, z[2] = k[2] * H + j[2] * A, z[3] = k[3] * H + j[3] * A, z[4] = k[4] * H + j[4] * A, z[5] = k[5] * H + j[5] * A, z[6] = k[6] * H + j[6] * A, z[7] = k[7] * H + j[7] * A, z;
      }
      function _(z, k) {
        var j = li(k);
        return z[0] = -k[0] / j, z[1] = -k[1] / j, z[2] = -k[2] / j, z[3] = k[3] / j, z[4] = -k[4] / j, z[5] = -k[5] / j, z[6] = -k[6] / j, z[7] = k[7] / j, z;
      }
      function F(z, k) {
        return z[0] = -k[0], z[1] = -k[1], z[2] = -k[2], z[3] = k[3], z[4] = -k[4], z[5] = -k[5], z[6] = -k[6], z[7] = k[7], z;
      }
      var v = Z.length, O = v, li = Z.squaredLength, ii = li;
      function ti(z, k) {
        var j = li(k);
        if (j > 0) {
          j = Math.sqrt(j);
          var A = k[0] / j, H = k[1] / j, U = k[2] / j, m = k[3] / j, h = k[4], g = k[5], f = k[6], w = k[7], B = A * h + H * g + U * f + m * w;
          z[0] = A, z[1] = H, z[2] = U, z[3] = m, z[4] = (h - A * B) / j, z[5] = (g - H * B) / j, z[6] = (f - U * B) / j, z[7] = (w - m * B) / j;
        }
        return z;
      }
      function $(z) {
        return "quat2(" + z[0] + ", " + z[1] + ", " + z[2] + ", " + z[3] + ", " + z[4] + ", " + z[5] + ", " + z[6] + ", " + z[7] + ")";
      }
      function ai(z, k) {
        return z[0] === k[0] && z[1] === k[1] && z[2] === k[2] && z[3] === k[3] && z[4] === k[4] && z[5] === k[5] && z[6] === k[6] && z[7] === k[7];
      }
      function Xi(z, k) {
        var j = z[0], A = z[1], H = z[2], U = z[3], m = z[4], h = z[5], g = z[6], f = z[7], w = k[0], B = k[1], q = k[2], si = k[3], bi = k[4], Zi = k[5], oi = k[6], mi = k[7];
        return Math.abs(j - w) <= c.EPSILON * Math.max(1, Math.abs(j), Math.abs(w)) && Math.abs(A - B) <= c.EPSILON * Math.max(1, Math.abs(A), Math.abs(B)) && Math.abs(H - q) <= c.EPSILON * Math.max(1, Math.abs(H), Math.abs(q)) && Math.abs(U - si) <= c.EPSILON * Math.max(1, Math.abs(U), Math.abs(si)) && Math.abs(m - bi) <= c.EPSILON * Math.max(1, Math.abs(m), Math.abs(bi)) && Math.abs(h - Zi) <= c.EPSILON * Math.max(1, Math.abs(h), Math.abs(Zi)) && Math.abs(g - oi) <= c.EPSILON * Math.max(1, Math.abs(g), Math.abs(oi)) && Math.abs(f - mi) <= c.EPSILON * Math.max(1, Math.abs(f), Math.abs(mi));
      }
    },
    /* 11 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return Z;
      }), i.d(l, "clone", function() {
        return L;
      }), i.d(l, "fromValues", function() {
        return K;
      }), i.d(l, "copy", function() {
        return u;
      }), i.d(l, "set", function() {
        return a;
      }), i.d(l, "add", function() {
        return e;
      }), i.d(l, "subtract", function() {
        return r;
      }), i.d(l, "multiply", function() {
        return X;
      }), i.d(l, "divide", function() {
        return W;
      }), i.d(l, "ceil", function() {
        return p;
      }), i.d(l, "floor", function() {
        return C;
      }), i.d(l, "min", function() {
        return I;
      }), i.d(l, "max", function() {
        return o;
      }), i.d(l, "round", function() {
        return G;
      }), i.d(l, "scale", function() {
        return d;
      }), i.d(l, "scaleAndAdd", function() {
        return t;
      }), i.d(l, "distance", function() {
        return s;
      }), i.d(l, "squaredDistance", function() {
        return b;
      }), i.d(l, "length", function() {
        return V;
      }), i.d(l, "squaredLength", function() {
        return S;
      }), i.d(l, "negate", function() {
        return Y;
      }), i.d(l, "inverse", function() {
        return T;
      }), i.d(l, "normalize", function() {
        return y;
      }), i.d(l, "dot", function() {
        return J;
      }), i.d(l, "cross", function() {
        return N;
      }), i.d(l, "lerp", function() {
        return R;
      }), i.d(l, "random", function() {
        return x;
      }), i.d(l, "transformMat2", function() {
        return M;
      }), i.d(l, "transformMat2d", function() {
        return Q;
      }), i.d(l, "transformMat3", function() {
        return P;
      }), i.d(l, "transformMat4", function() {
        return D;
      }), i.d(l, "rotate", function() {
        return _;
      }), i.d(l, "angle", function() {
        return F;
      }), i.d(l, "zero", function() {
        return v;
      }), i.d(l, "str", function() {
        return O;
      }), i.d(l, "exactEquals", function() {
        return li;
      }), i.d(l, "equals", function() {
        return ii;
      }), i.d(l, "len", function() {
        return ti;
      }), i.d(l, "sub", function() {
        return $;
      }), i.d(l, "mul", function() {
        return ai;
      }), i.d(l, "div", function() {
        return Xi;
      }), i.d(l, "dist", function() {
        return z;
      }), i.d(l, "sqrDist", function() {
        return k;
      }), i.d(l, "sqrLen", function() {
        return j;
      }), i.d(l, "forEach", function() {
        return A;
      });
      var c = i(2);
      function Z() {
        var H = new c.ARRAY_TYPE(2);
        return c.ARRAY_TYPE != Float32Array && (H[0] = 0, H[1] = 0), H;
      }
      function L(H) {
        var U = new c.ARRAY_TYPE(2);
        return U[0] = H[0], U[1] = H[1], U;
      }
      function K(H, U) {
        var m = new c.ARRAY_TYPE(2);
        return m[0] = H, m[1] = U, m;
      }
      function u(H, U) {
        return H[0] = U[0], H[1] = U[1], H;
      }
      function a(H, U, m) {
        return H[0] = U, H[1] = m, H;
      }
      function e(H, U, m) {
        return H[0] = U[0] + m[0], H[1] = U[1] + m[1], H;
      }
      function r(H, U, m) {
        return H[0] = U[0] - m[0], H[1] = U[1] - m[1], H;
      }
      function X(H, U, m) {
        return H[0] = U[0] * m[0], H[1] = U[1] * m[1], H;
      }
      function W(H, U, m) {
        return H[0] = U[0] / m[0], H[1] = U[1] / m[1], H;
      }
      function p(H, U) {
        return H[0] = Math.ceil(U[0]), H[1] = Math.ceil(U[1]), H;
      }
      function C(H, U) {
        return H[0] = Math.floor(U[0]), H[1] = Math.floor(U[1]), H;
      }
      function I(H, U, m) {
        return H[0] = Math.min(U[0], m[0]), H[1] = Math.min(U[1], m[1]), H;
      }
      function o(H, U, m) {
        return H[0] = Math.max(U[0], m[0]), H[1] = Math.max(U[1], m[1]), H;
      }
      function G(H, U) {
        return H[0] = Math.round(U[0]), H[1] = Math.round(U[1]), H;
      }
      function d(H, U, m) {
        return H[0] = U[0] * m, H[1] = U[1] * m, H;
      }
      function t(H, U, m, h) {
        return H[0] = U[0] + m[0] * h, H[1] = U[1] + m[1] * h, H;
      }
      function s(H, U) {
        var m = U[0] - H[0], h = U[1] - H[1];
        return Math.hypot(m, h);
      }
      function b(H, U) {
        var m = U[0] - H[0], h = U[1] - H[1];
        return m * m + h * h;
      }
      function V(H) {
        var U = H[0], m = H[1];
        return Math.hypot(U, m);
      }
      function S(H) {
        var U = H[0], m = H[1];
        return U * U + m * m;
      }
      function Y(H, U) {
        return H[0] = -U[0], H[1] = -U[1], H;
      }
      function T(H, U) {
        return H[0] = 1 / U[0], H[1] = 1 / U[1], H;
      }
      function y(H, U) {
        var m = U[0], h = U[1], g = m * m + h * h;
        return g > 0 && (g = 1 / Math.sqrt(g)), H[0] = U[0] * g, H[1] = U[1] * g, H;
      }
      function J(H, U) {
        return H[0] * U[0] + H[1] * U[1];
      }
      function N(H, U, m) {
        var h = U[0] * m[1] - U[1] * m[0];
        return H[0] = H[1] = 0, H[2] = h, H;
      }
      function R(H, U, m, h) {
        var g = U[0], f = U[1];
        return H[0] = g + h * (m[0] - g), H[1] = f + h * (m[1] - f), H;
      }
      function x(H, U) {
        U = U || 1;
        var m = c.RANDOM() * 2 * Math.PI;
        return H[0] = Math.cos(m) * U, H[1] = Math.sin(m) * U, H;
      }
      function M(H, U, m) {
        var h = U[0], g = U[1];
        return H[0] = m[0] * h + m[2] * g, H[1] = m[1] * h + m[3] * g, H;
      }
      function Q(H, U, m) {
        var h = U[0], g = U[1];
        return H[0] = m[0] * h + m[2] * g + m[4], H[1] = m[1] * h + m[3] * g + m[5], H;
      }
      function P(H, U, m) {
        var h = U[0], g = U[1];
        return H[0] = m[0] * h + m[3] * g + m[6], H[1] = m[1] * h + m[4] * g + m[7], H;
      }
      function D(H, U, m) {
        var h = U[0], g = U[1];
        return H[0] = m[0] * h + m[4] * g + m[12], H[1] = m[1] * h + m[5] * g + m[13], H;
      }
      function _(H, U, m, h) {
        var g = U[0] - m[0], f = U[1] - m[1], w = Math.sin(h), B = Math.cos(h);
        return H[0] = g * B - f * w + m[0], H[1] = g * w + f * B + m[1], H;
      }
      function F(H, U) {
        var m = H[0], h = H[1], g = U[0], f = U[1], w = Math.sqrt(m * m + h * h) * Math.sqrt(g * g + f * f), B = w && (m * g + h * f) / w;
        return Math.acos(Math.min(Math.max(B, -1), 1));
      }
      function v(H) {
        return H[0] = 0, H[1] = 0, H;
      }
      function O(H) {
        return "vec2(" + H[0] + ", " + H[1] + ")";
      }
      function li(H, U) {
        return H[0] === U[0] && H[1] === U[1];
      }
      function ii(H, U) {
        var m = H[0], h = H[1], g = U[0], f = U[1];
        return Math.abs(m - g) <= c.EPSILON * Math.max(1, Math.abs(m), Math.abs(g)) && Math.abs(h - f) <= c.EPSILON * Math.max(1, Math.abs(h), Math.abs(f));
      }
      var ti = V, $ = r, ai = X, Xi = W, z = s, k = b, j = S, A = function() {
        var H = Z();
        return function(U, m, h, g, f, w) {
          var B, q;
          for (m || (m = 2), h || (h = 0), g ? q = Math.min(g * m + h, U.length) : q = U.length, B = h; B < q; B += m)
            H[0] = U[B], H[1] = U[B + 1], f(H, H, w), U[B] = H[0], U[B + 1] = H[1];
          return U;
        };
      }();
    },
    /* 12 */
    /***/
    function(n, l, i) {
      i.r(l);
      var c = i(13);
      i.d(l, "Renderer", function() {
        return c.default;
      });
      var Z = i(40);
      i.d(l, "Figure2D", function() {
        return Z.default;
      });
      var L = i(56);
      i.d(l, "Mesh2D", function() {
        return L.default;
      });
      var K = i(29);
      i.d(l, "MeshCloud", function() {
        return K.default;
      });
      var u = i(23);
      i.d(l, "parseFont", function() {
        return u.default;
      });
      var a = i(31);
      i.d(l, "parseColor", function() {
        return a.default;
      });
      var e = i(21);
      i.d(l, "ENV", function() {
        return e.default;
      }), i(1).glMatrix.setMatrixArrayType(Array);
    },
    /* 13 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return T;
      });
      var c = i(14), Z = i(1), L = i(20), K = i(27), u = i(25), a = i(40), e = i(56), r = i(29), X = i(59), W = i(21), p = i(63);
      i(1).glMatrix.setMatrixArrayType(Array);
      const C = {
        autoUpdate: !1,
        // premultipliedAlpha: true,
        preserveDrawingBuffer: !1,
        // depth: false,
        // antialias: false,
        bufferSize: 1500
      }, I = `attribute vec3 a_vertexPosition;
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

void main() {
  gl_PointSize = 1.0;
  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);    
  vTextureCoord = a_vertexTextureCoord;              
}
`, o = `precision mediump float;
varying vec3 vTextureCoord;
uniform sampler2D u_texSampler;
void main() {
  gl_FragColor = texture2D(u_texSampler, vTextureCoord.xy);
}
`, G = Symbol("glRenderer"), d = Symbol("canvasRenderer"), t = Symbol("options"), s = Symbol("globalTransform"), b = Symbol("applyGlobalTransform"), V = Symbol("canvas");
      function S(y) {
        const J = y.gl, N = y.fbo;
        N && J.bindFramebuffer(J.FRAMEBUFFER, N), y._draw(), N && J.bindFramebuffer(J.FRAMEBUFFER, null);
      }
      function Y(y, J, N, R) {
        const x = y.createTexture(J.canvas), M = [[[0, 0], [N, 0], [N, R], [0, R], [0, 0]]];
        M.closed = !0;
        const Q = new e.default({
          contours: M
        });
        Q.setTexture(x), y.setMeshData([Q.meshData]), S(y), x.delete(), J.clearRect(0, 0, N, R), delete J._filter;
      }
      class T {
        constructor(J, N = {}) {
          let R = N.contextType;
          if (R || (typeof WebGL2RenderingContext == "function" ? R = "webgl2" : typeof WebGLRenderingContext == "function" ? R = "webgl" : R = "2d"), !J.getContext) {
            const x = J;
            J = {
              getContext() {
                return x;
              },
              width: N.width,
              height: N.height
            }, x.canvas = J, R = "2d";
          }
          if (this[V] = J, R !== "webgl" && R !== "webgl2" && R !== "2d")
            throw new Error(`Unknown context type ${R}`);
          if (N.contextType = R, this[t] = Object.assign({}, C, N), R === "webgl" || R === "webgl2") {
            R === "webgl2" && (this[t].webgl2 = !0);
            const x = new c.default(J, this[t]);
            R === "webgl2" && !x.isWebGL2 && (N.contextType = "webgl"), Object(p.createShaders)(x), Object(p.applyShader)(x), Object(p.createCloudShaders)(x);
            const M = x.gl;
            M.clearColor(0, 0, 0, 0), M.blendFuncSeparate(M.SRC_ALPHA, M.ONE_MINUS_SRC_ALPHA, M.ONE, M.ONE_MINUS_SRC_ALPHA), this[G] = x;
          } else
            this[d] = new L.default(J, this[t]);
          this[s] = [1, 0, 0, 0, 1, 0, 0, 0, 1], this.updateResolution();
        }
        get canvas() {
          return this[V];
        }
        get canvasRenderer() {
          return this[d];
        }
        get glRenderer() {
          return this[G];
        }
        get isWebGL2() {
          return this[G] && this[G].isWebGL2;
        }
        get options() {
          return this[t];
        }
        get globalTransformMatrix() {
          const J = this[s];
          return [J[0], J[1], J[3], J[4], J[6], J[7]];
        }
        get viewMatrix() {
          return this[s];
        }
        [b]() {
          const J = this[G] || this[d];
          if (this[G]) {
            const {
              width: N,
              height: R
            } = this.canvas;
            J.uniforms.viewMatrix = this.viewMatrix, J.uniforms.projectionMatrix = this.projectionMatrix, J.uniforms.u_resolution = [N, R];
          }
        }
        updateResolution() {
          const {
            width: J,
            height: N
          } = this.canvas, R = [
            // translation
            1,
            0,
            0,
            0,
            1,
            0,
            -J / 2,
            -N / 2,
            1
          ], x = [
            // scale
            2 / J,
            0,
            0,
            0,
            -2 / N,
            0,
            0,
            0,
            1
          ], M = Z.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, R);
          this.projectionMatrix = M, this[G] && this[G].gl.viewport(0, 0, J, N);
        }
        createTexture(J, N) {
          return (this[G] || this[d]).createTexture(J, N);
        }
        /* async */
        loadTexture(J, {
          useImageBitmap: N = !1
        } = {}) {
          return (this[G] || this[d]).loadTexture(J, {
            useImageBitmap: N
          });
        }
        createText(J, {
          font: N = "16px arial",
          fillColor: R = null,
          strokeColor: x = null,
          strokeWidth: M = 1
        } = {}) {
          if (this[G]) {
            const Q = W.default.createText(J, {
              font: N,
              fillColor: R,
              strokeColor: x,
              strokeWidth: M
            });
            return {
              image: this.createTexture(Q.image),
              rect: Q.rect
            };
          }
          return {
            _img: {
              font: N,
              fillColor: R,
              strokeColor: x,
              strokeWidth: M,
              text: J
            }
          };
        }
        createProgram({
          vertex: J,
          fragment: N,
          options: R
        } = {}) {
          if (this[G]) {
            const x = this[G].compileSync(N, J);
            return x._attribOpts = R, x;
          }
          throw new Error("Context 2D cannot create webgl program.");
        }
        createPassProgram({
          vertex: J = I,
          fragment: N = o,
          options: R
        } = {}) {
          return this.createProgram({
            vertex: J,
            fragment: N,
            options: R
          });
        }
        useProgram(J, N = {}) {
          if (this[G]) {
            const R = Object.assign({}, J._attribOpts, N);
            return this[G].useProgram(J, R);
          }
          throw new Error("Context 2D cannot use webgl program.");
        }
        deleteTexture(J) {
          return (this[G] || this[d]).deleteTexture(J);
        }
        clear(...J) {
          if (this[G]) {
            const N = this[G].gl;
            N.clear(N.COLOR_BUFFER_BIT);
          } else
            this[d].clear(...J);
        }
        drawMeshCloud(J, {
          clear: N = !1,
          program: R = null
        } = {}) {
          const x = this[G] || this[d], M = R || J.program;
          if (this[G]) {
            const Q = x.gl;
            if (N && Q.clear(Q.COLOR_BUFFER_BIT), M)
              x.program !== M && this.useProgram(M, {
                a_color: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_fillCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_strokeCloudColor: {
                  type: "UNSIGNED_BYTE",
                  normalize: !0
                },
                a_frameIndex: {
                  type: "UNSIGNED_BYTE",
                  normalize: !1
                }
              });
            else {
              const P = J.mesh.meshData, D = !!P.uniforms.u_texSampler, _ = !!P.uniforms.u_filterFlag, F = !!P.uniforms.u_radialGradientVector, v = J.hasCloudColor, O = J.hasCloudFilter, li = !!P.uniforms.u_clipSampler;
              Object(p.applyCloudShader)(x, {
                hasTexture: D,
                hasFilter: _,
                hasGradient: F,
                hasCloudColor: v,
                hasCloudFilter: O,
                hasClipPath: li
              });
            }
            this[b](), x.setMeshData([J.meshData]), J.beforeRender && J.beforeRender(Q, J), S(x), J.afterRender && J.afterRender(Q, J);
          } else
            x.setTransform(this.globalTransformMatrix), x.drawMeshCloud(J, {
              clear: N,
              hook: !1
            });
        }
        drawMeshes(J, {
          clear: N = !1,
          program: R = null
        } = {}) {
          const x = this[G] || this[d];
          if (this[G]) {
            const M = x.fbo, Q = Object(K.default)(this, J, R == null), P = x.gl;
            N && P.clear(P.COLOR_BUFFER_BIT);
            const D = !Object(X.isUnitTransform)(this.globalTransformMatrix);
            this._drawCalls = 0;
            for (const _ of Q) {
              this._drawCalls++;
              const F = R || _.program;
              if (_ instanceof r.default)
                this.drawMeshCloud(_, {
                  clear: N,
                  program: F
                });
              else {
                const {
                  width: v,
                  height: O
                } = this.canvas;
                if (_.beforeRender && _.beforeRender(P, _), _.pass.length && ((!this.fbo || this.fbo.width !== v || this.fbo.height !== O) && (this.fbo = {
                  width: v,
                  height: O,
                  target: x.createFBO(),
                  buffer: x.createFBO(),
                  swap() {
                    [this.target, this.buffer] = [this.buffer, this.target];
                  }
                }), x.bindFBO(this.fbo.target)), !F && _.filterCanvas) {
                  Object(p.applyShader)(x, {
                    hasTexture: !0
                  });
                  let li = this.filterContext;
                  li || (li = W.default.createCanvas(v, O).getContext("2d"), this.filterContext = li);
                  const ii = J[_.packIndex], ti = ii.filter, $ = J[_.packIndex + 1], ai = J[_.packIndex - 1];
                  (!ai || !ai.filterCanvas || ai.filter !== ti) && (!$ || !$.filterCanvas || $.filter !== ti) ? (D ? (li.save(), Object(u.drawMesh2D)(ii, li, !1), li.restore(), Object(u.applyFilter)(li, ti)) : Object(u.drawMesh2D)(ii, li, !0), this[b](), Y(x, li, v, O)) : (D && li.save(), Object(u.drawMesh2D)(ii, li, !1), D && li.restore(), (!$ || !$.filterCanvas || ii.filter !== $.filter) && (Object(u.applyFilter)(li, ti), this[b](), Y(x, li, v, O)));
                } else {
                  if (F)
                    x.program !== F && this.useProgram(F, {
                      a_color: {
                        type: "UNSIGNED_BYTE",
                        normalize: !0
                      }
                    });
                  else {
                    const li = !!_.uniforms.u_texSampler, ii = !!_.uniforms.u_filterFlag, ti = !!_.uniforms.u_radialGradientVector, $ = !!_.uniforms.u_clipSampler;
                    Object(p.applyShader)(x, {
                      hasTexture: li,
                      hasFilter: ii,
                      hasGradient: ti,
                      hasClipPath: $
                    });
                  }
                  _.filterCanvas && console.warn("User program ignored some filter effects."), this[b](), x.setMeshData([_]), S(x);
                }
                if (_.pass.length) {
                  const li = _.pass.length;
                  _.pass.forEach((ii, ti) => {
                    ii.blend = _.enableBlend, ii.setTexture(x.fbo.texture), ti === li - 1 ? x.bindFBO(M) : (this.fbo.swap(), x.bindFBO(this.fbo.target)), ii.program ? x.useProgram(ii.program) : (this.defaultPassProgram = this.defaultPassProgram || this.createPassProgram(), x.useProgram(this.defaultPassProgram)), x.setMeshData([ii.meshData]), P.clear(P.COLOR_BUFFER_BIT), S(x);
                  });
                }
                _.afterRender && _.afterRender(P, _);
              }
            }
          } else
            x.setTransform(this.globalTransformMatrix), x.drawMeshes(J, {
              clear: N
            });
        }
        drawImage(J, ...N) {
          const R = N.length;
          if (R < 2)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': 3 arguments required, but only ${N.length + 1} present.`);
          if (R !== 2 && R !== 4 && R !== 8)
            throw new TypeError(`Failed to execute 'drawImage' on 'Renderer': Valid arities are: [3, 5, 9], but ${N.length + 1} arguments provided.`);
          let x = null, M = null;
          R === 2 ? x = [N[0], N[1], J.width, J.height] : R === 4 ? x = N : R === 8 && (M = N.slice(0, 4), x = N.slice(4));
          const Q = this.createTexture(J), {
            width: P,
            height: D
          } = this.canvas, _ = new a.default();
          _.rect(x[0], x[1], P, D);
          const F = new e.default(_, {
            width: P,
            height: D
          });
          F.setTexture(Q, {
            rect: x,
            srcRect: M
          }), this.drawMeshes([F]), this.deleteTexture(Q);
        }
        setGlobalTransform(...J) {
          return this[s] = [J[0], J[1], 0, J[2], J[3], 0, J[4], J[5], 1], this;
        }
        globalTransform(...J) {
          const N = this[s];
          return this[s] = Z.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), N, J), this;
        }
        globalTranslate(J, N) {
          let R = Z.mat3.create();
          return R = Z.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), R, [J, N]), this.globalTransform(...R);
        }
        globalRotate(J, [N, R] = [0, 0]) {
          let x = Z.mat3.create();
          return x = Z.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, [N, R]), x = Z.mat3.rotate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, J), x = Z.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, [-N, -R]), this.globalTransform(...x);
        }
        globalScale(J, N = J, [R, x] = [0, 0]) {
          let M = Z.mat3.create();
          return M = Z.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), M, [R, x]), M = Z.mat3.scale(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), M, [J, N]), M = Z.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), M, [-R, -x]), this.globalTransform(...M);
        }
        globalSkew(J, N = J, [R, x] = [0, 0]) {
          let M = Z.mat3.create();
          return M = Z.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), M, [R, x]), M = Z.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), M, Z.mat3.fromValues(1, Math.tan(N), Math.tan(J), 1, 0, 0)), M = Z.mat3.translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), M, [-R, -x]), this.globalTransform(...M);
        }
        transformPoint(J, N, R) {
          let x = this.globalTransformMatrix;
          R && (x = Z.mat3.multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), x, R));
          const M = J * x[0] + N * x[2] + x[4], Q = J * x[1] + N * x[3] + x[5];
          return [M, Q];
        }
      }
    },
    /* 14 */
    /***/
    function(n, l, i) {
      i.r(l);
      var c = i(15);
      i(1).glMatrix.setMatrixArrayType(Array), l.default = c.default;
    },
    /* 15 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return p;
      });
      var c = i(16), Z = i(17), L = i(18), K = i(19);
      i(1).glMatrix.setMatrixArrayType(Array);
      function u(C, I, o) {
        return I in C ? Object.defineProperty(C, I, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : C[I] = o, C;
      }
      const a = {};
      function e(C, I = 3) {
        const o = [], G = C.length;
        for (let d = 0; d < G; d++)
          d % I < 2 && o.push(0.5 * (C[d] + 1));
        return o;
      }
      function r(C, I) {
        const o = I._buffers;
        Object.values(o).forEach((G) => {
          C.deleteBuffer(G);
        }), I._buffers = {};
      }
      function X(C, I, o) {
        return C.activeTexture(C.TEXTURE0 + o), Array.isArray(I._img) ? C.bindTexture(C.TEXTURE_CUBE_MAP, I) : C.bindTexture(C.TEXTURE_2D, I), I;
      }
      const W = {
        int: "1i",
        ivec2: "2i",
        ivec3: "3i",
        ivec4: "4i",
        float: "1f",
        vec2: "2f",
        vec3: "3f",
        vec4: "4f",
        mat2: "Matrix2fv",
        mat3: "Matrix3fv",
        mat4: "Matrix4fv",
        sampler1D: "sampler1D",
        sampler2D: "sampler2D",
        sampler3D: "sampler3D",
        samplerCube: "samplerCube",
        sampler1DShadow: "sampler1DShadow",
        sampler2DShadow: "sampler2DShadow",
        sampler2DRect: "sampler2DRect",
        sampler2DRectShadow: "sampler2DRectShadow"
      };
      class p {
        static addLibs(I = {}) {
          Object.assign(a, I);
        }
        static FLOAT(I, o) {
          return Object(c.pointsToBuffer)(I, Float32Array, o);
        }
        static UNSIGNED_BYTE(I, o) {
          return Object(c.pointsToBuffer)(I, Uint8Array, o);
        }
        static UNSIGNED_SHORT(I, o) {
          return Object(c.pointsToBuffer)(I, Uint16Array, o);
        }
        static BYTE(I, o) {
          return Object(c.pointsToBuffer)(I, Int8Array, o);
        }
        static SHORT(I, o) {
          return Object(c.pointsToBuffer)(I, Int16Array, o);
        }
        constructor(I, o = {}) {
          this.options = Object.assign({}, p.defaultOptions, o), this.canvas = I;
          let G;
          this.options.webgl2 && (G = I.getContext("webgl2", this.options)), G == null && (G = Object(c.setupWebGL)(I, this.options), this.aia_ext = G.getExtension("ANGLE_instanced_arrays")), this.gl = G, G.viewport(0, 0, I.width, I.height), G.clearColor(0, 0, 0, 0), G.blendFuncSeparate(G.SRC_ALPHA, G.ONE_MINUS_SRC_ALPHA, G.ONE, G.ONE_MINUS_SRC_ALPHA), this.programs = [], this._events = {};
        }
        get program() {
          const I = this.gl;
          return I.getParameter(I.CURRENT_PROGRAM);
        }
        // WebGLRenderingContext.uniform[1234][fi][v]()
        // WebGLRenderingContext.uniformMatrix[234]fv()
        _declareUniform(I, o, G = "1f") {
          const d = this.gl, t = d.getUniformLocation(I, o);
          let s;
          const b = this;
          if (/^sampler/.test(G)) {
            const V = I._samplerMap, S = I._bindTextures;
            Object.defineProperty(I.uniforms, o, {
              get() {
                return s;
              },
              set(Y) {
                s = Y;
                const T = V[o] != null ? V[o] : S.length;
                S[T] = Y, X(d, Y, T), V[o] || (V[o] = T, d.uniform1i(t, T)), b.options.autoUpdate && b.update();
              },
              configurable: !1,
              enumerable: !0
            });
          } else {
            const V = G.indexOf("Matrix") === 0, S = !V && /v$/.test(G), Y = d[`uniform${G}`].bind(d);
            Object.defineProperty(I.uniforms, o, {
              get() {
                return s;
              },
              set(T) {
                s = T, typeof T == "number" && (T = [T]), V ? Y(t, !1, T) : S ? Y(t, T) : Y(t, ...T), b.options.autoUpdate && b.update();
              },
              configurable: !1,
              enumerable: !0
            });
          }
        }
        _draw() {
          const I = this.program;
          I.meshData.forEach((o, G) => {
            const {
              positions: d,
              cells: t,
              instanceCount: s,
              cellsCount: b,
              attributes: V,
              uniforms: S,
              textureCoord: Y,
              enableBlend: T
            } = o, y = this.gl;
            let J = o.mode != null ? o.mode : y.TRIANGLES;
            typeof J == "string" && (J = y[J]), T ? y.enable(y.BLEND) : y.disable(y.BLEND), y.bindBuffer(y.ARRAY_BUFFER, I._buffers.verticesBuffer), y.bufferData(y.ARRAY_BUFFER, d, y.STATIC_DRAW), t && (y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, I._buffers.cellsBuffer), y.bufferData(y.ELEMENT_ARRAY_BUFFER, t, y.STATIC_DRAW));
            const N = [];
            V && Object.values(V).forEach(({
              name: x,
              data: M,
              divisor: Q
            }) => {
              if (y.bindBuffer(y.ARRAY_BUFFER, I._buffers[x]), y.bufferData(y.ARRAY_BUFFER, M, y.STATIC_DRAW), Q != null) {
                const P = y.getAttribLocation(I, x);
                P >= 0 && (y.enableVertexAttribArray(P), N.push(P), y.vertexAttribDivisor ? y.vertexAttribDivisor(P, Q) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(P, Q));
              }
            }), S && Object.entries(S).forEach(([x, M]) => {
              this.uniforms[x] = M;
            });
            let R;
            if (!t) {
              const x = I._dimension;
              R = d.length / x;
            }
            if (I._enableTextures && I._buffers.texCoordBuffer) {
              const x = Y || e(d, I._dimension);
              y.bindBuffer(y.ARRAY_BUFFER, I._buffers.texCoordBuffer), y.bufferData(y.ARRAY_BUFFER, p.FLOAT(x), y.STATIC_DRAW);
            }
            s != null ? (t ? y.drawElementsInstanced ? y.drawElementsInstanced(J, b, y.UNSIGNED_SHORT, 0, s) : this.aia_ext && this.aia_ext.drawElementsInstancedANGLE(J, b, y.UNSIGNED_SHORT, 0, s) : y.drawArraysInstanced ? y.drawArraysInstanced(J, 0, R, s) : this.aia_ext.drawArraysInstancedANGLE(J, 0, R, s), N.forEach((x) => {
              y.vertexAttribDivisor ? y.vertexAttribDivisor(x, null) : this.aia_ext && this.aia_ext.vertexAttribDivisorANGLE(x, null);
            })) : t ? y.drawElements(J, b, y.UNSIGNED_SHORT, 0) : y.drawArrays(J, 0, R);
          });
        }
        get isWebGL2() {
          return typeof WebGL2RenderingContext < "u" && this.gl instanceof WebGL2RenderingContext;
        }
        get enableTextures() {
          return this.program && this.program._enableTextures;
        }
        get uniforms() {
          const I = this.program;
          if (!I || !I.uniforms)
            throw Error("No avaliable program.");
          return I.uniforms;
        }
        deleteProgram(I) {
          const o = this.gl;
          this.program === I && (this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID), o.useProgram(null));
          const G = this.programs.indexOf(I);
          G >= 0 && this.programs.splice(G, 1), r(o, I), o.deleteProgram(I);
        }
        /**
          [{
            positions: ...
            cells: ...
            textureCoord: ...
            attributes: {name: {data:..., normalize: true}},
            uniforms: ...
          }]
         */
        setMeshData(I) {
          Array.isArray(I) || (I = [I]);
          const o = this.program;
          o.meshData = I.map(({
            mode: G,
            positions: d,
            instanceCount: t,
            cells: s,
            cellsCount: b,
            attributes: V,
            uniforms: S,
            textureCoord: Y,
            enableBlend: T
          }) => {
            const y = {
              positions: p.FLOAT(d),
              uniforms: S,
              enableBlend: !!T,
              textureCoord: p.FLOAT(Y)
            };
            if (s && (y.cells = p.USHORT(s), y.cellsCount = b || y.cells.length), G != null && (y.mode = G), t != null) {
              if (!this.isWebGL2 && !this.aia_ext)
                throw new Error("Cannot use instanceCount in this rendering context, use webgl2 context instead.");
              y.instanceCount = t;
            }
            if (V) {
              const J = {};
              Object.entries(V).forEach(([N, R]) => {
                if (!o._attribute[N])
                  o._attribute[N] = "ignored";
                else if (o._attribute[N] !== "ignored") {
                  const {
                    name: x,
                    type: M
                  } = o._attribute[N];
                  let Q = R.data || R;
                  if (Array.isArray(Q) && (Q = p[M](Q)), J[N] = {
                    name: x,
                    data: Q
                  }, R.divisor != null) {
                    if (!this.isWebGL2 && !this.aia_ext)
                      throw new Error("Cannot use divisor in this rendering context, use webgl2 context instead.");
                    J[N].divisor = R.divisor;
                  }
                }
              }), y.attributes = J;
            }
            return y;
          }), this.options.autoUpdate && this.update();
        }
        createProgram(I, o) {
          const G = /^\s*uniform\s+sampler/mg.test(I);
          I == null && (I = L.default), o == null && (o = G ? K.default : Z.default);
          const d = this.gl, t = Object(c.createProgram)(d, o, I);
          t.shaderText = {
            vertexShader: o,
            fragmentShader: I
          }, t._buffers = {}, t._attribute = {}, t.uniforms = {}, t._samplerMap = {}, t._bindTextures = [];
          const s = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexPosition}`, "im");
          let b = o.match(s);
          b && (t._dimension = Number(b[1]));
          const V = new RegExp(`(?:attribute|in) vec(\\d) ${this.options.vertexTextureCoord}`, "im");
          b = o.match(V), b && (t._texCoordSize = Number(b[1]));
          const S = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/gim;
          if (b = o.match(S), b)
            for (let y = 0; y < b.length; y++) {
              const J = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/im, N = b[y].match(J);
              if (N && N[3] !== this.options.vertexPosition && N[3] !== this.options.vertexTextureCoord) {
                let [, R, x, M] = N;
                R === "mat" && (x **= 2), t._buffers[M] = d.createBuffer(), t._attribute[M] = {
                  name: M,
                  type: R,
                  size: Number(x) || 1
                };
              }
            }
          const Y = /^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/mg;
          b = o.match(Y) || [], b = b.concat(I.match(Y) || []), b.forEach((y) => {
            const J = y.match(/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/);
            let [N, R, x] = J.slice(1);
            N = W[N], x = !!x, N.indexOf("Matrix") !== 0 && x && (N += "v"), this._declareUniform(t, R, N);
          }), t._buffers.verticesBuffer = d.createBuffer(), t._buffers.cellsBuffer = d.createBuffer();
          const T = d.getAttribLocation(t, this.options.vertexTextureCoord);
          return t._enableTextures = T >= 0, t._enableTextures && (t._buffers.texCoordBuffer = d.createBuffer()), this.programs.push(t), t;
        }
        useProgram(I, o = {}) {
          this.startRender = !1, this._renderFrameID && (cancelAnimationFrame(this._renderFrameID), delete this._renderFrameID);
          const G = this.gl;
          G.useProgram(I);
          const d = I._dimension;
          G.bindBuffer(G.ARRAY_BUFFER, I._buffers.verticesBuffer);
          const t = G.getAttribLocation(I, this.options.vertexPosition);
          if (G.vertexAttribPointer(t, d, G.FLOAT, !1, 0, 0), G.enableVertexAttribArray(t), I._enableTextures) {
            G.bindBuffer(G.ARRAY_BUFFER, I._buffers.texCoordBuffer);
            const s = G.getAttribLocation(I, this.options.vertexTextureCoord);
            G.vertexAttribPointer(s, I._texCoordSize || 2, G.FLOAT, !1, 0, 0), G.enableVertexAttribArray(s);
          }
          if (Object.entries(I._attribute).forEach(([s, b]) => {
            if (b !== "ignored") {
              const V = b.size, S = o[s] || {}, Y = !!S.normalize;
              let T = S.type || "FLOAT";
              const y = S.key || s;
              T === "UBYTE" && (T = "UNSIGNED_BYTE"), T === "USHORT" && (T = "UNSIGNED_SHORT"), b.type = T, y && y !== s && (I._attribute[y] = b), G.bindBuffer(G.ARRAY_BUFFER, I._buffers[s]);
              const J = G.getAttribLocation(I, s);
              J >= 0 && (G.vertexAttribPointer(J, V, G[T], Y, 0, 0), G.enableVertexAttribArray(J));
            }
          }), !I.meshData) {
            const s = [[-1, -1, 0, 1].slice(0, d), [1, -1, 0, 1].slice(0, d), [1, 1, 0, 1].slice(0, d), [-1, 1, 0, 1].slice(0, d)], b = [[0, 1, 3], [3, 1, 2]];
            this.setMeshData({
              positions: s,
              cells: b
            });
          }
          return I;
        }
        compileSync(I, o) {
          I = I || L.default;
          const G = {};
          function d(V) {
            V = V.replace(/^\s*/mg, "");
            const S = [], Y = V.match(/^#pragma\s+include\s+.*/mg);
            if (Y) {
              for (let T = 0; T < Y.length; T++) {
                const J = Y[T].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const N = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let R = J[1];
                  if (R === "graph" && (R = "graphics"), G[R])
                    S.push(`/* included ${R} */`);
                  else if (G[R] = !0, N === "lib") {
                    const x = d(a[R]);
                    S.push(x);
                  } else if (N === "link")
                    throw new Error("Cannot load external links synchronously. Use compile instead of compileSync.");
                }
              }
              S.forEach((T) => {
                V = V.replace(/^#pragma\s+include\s+.*/m, T);
              });
            }
            return V;
          }
          const t = d(I), s = o ? d(o) : null;
          return this.createProgram(t, s);
        }
        async compile(I, o) {
          I = I || L.default;
          const G = {};
          async function d(V) {
            V = V.replace(/^\s*/mg, "");
            const S = [], Y = V.match(/^#pragma\s+include\s+.*/mg);
            if (Y) {
              for (let T = 0; T < Y.length; T++) {
                const J = Y[T].match(/(?:<|")(.*)(?:>|")/);
                if (J) {
                  const N = J[0].indexOf("<") === 0 ? "lib" : "link";
                  let R = J[1];
                  if (R === "graph" && (R = "graphics"), G[R])
                    S.push(`/* included ${R} */`);
                  else if (G[R] = !0, N === "lib") {
                    const x = await d(a[R]);
                    S.push(x);
                  } else if (N === "link") {
                    let x = await p.fetchShader(R);
                    x = await d(x), S.push(x);
                  }
                }
              }
              S.forEach((T) => {
                V = V.replace(/^#pragma\s+include\s+.*/m, T);
              });
            }
            return V;
          }
          const t = await d(I), s = o ? await d(o) : null;
          return this.createProgram(t, s);
        }
        async load(I, o = null) {
          return I = await p.fetchShader(I), o && (o = await p.fetchShader(o)), this.compile(I, o);
        }
        createTexture(I = null, {
          wrapS: o = this.gl.CLAMP_TO_EDGE,
          wrapT: G = this.gl.CLAMP_TO_EDGE,
          minFilter: d = this.gl.LINEAR,
          magFilter: t = this.gl.LINEAR
        } = {}) {
          const s = this.gl, b = Array.isArray(I) ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D;
          this._max_texture_image_units = this._max_texture_image_units || s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS), s.activeTexture(s.TEXTURE0 + this._max_texture_image_units - 1);
          const V = s.createTexture();
          s.bindTexture(b, V), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, !0);
          const {
            width: S,
            height: Y
          } = this.canvas;
          if (I)
            if (b === s.TEXTURE_CUBE_MAP)
              for (let T = 0; T < 6; T++)
                s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + T, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, I[T]);
            else
              s.texImage2D(b, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, I);
          else if (b === s.TEXTURE_CUBE_MAP)
            for (let T = 0; T < 6; T++)
              this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + T, 0, s.RGBA, S, Y, 0, s.RGBA, s.UNSIGNED_BYTE, null);
          else
            s.texImage2D(b, 0, s.RGBA, S, Y, 0, s.RGBA, s.UNSIGNED_BYTE, null);
          return s.texParameteri(b, s.TEXTURE_MIN_FILTER, d), s.texParameteri(b, s.TEXTURE_MAG_FILTER, t), s.texParameteri(b, s.TEXTURE_WRAP_S, o), s.texParameteri(b, s.TEXTURE_WRAP_T, G), b === s.TEXTURE_CUBE_MAP && (I.width = I[0].width, I.height = I[0].height), s.bindTexture(b, null), V._img = I || {
            width: S,
            height: Y
          }, V.delete = () => {
            this.deleteTexture(V);
          }, V;
        }
        deleteTexture(I) {
          const o = I._img;
          this.gl.deleteTexture(I), typeof o.close == "function" && o.close();
        }
        async loadTexture(I, {
          useImageBitmap: o = !0
        } = {}) {
          const G = await p.loadImage(I, {
            useImageBitmap: o
          });
          return this.createTexture(G);
        }
        createFBO({
          color: I = 1,
          blend: o = !1,
          depth: G = this.options.depth !== !1,
          stencil: d = !!this.options.stencil
        } = {}) {
          const t = this.gl, s = t.createFramebuffer();
          t.bindFramebuffer(t.FRAMEBUFFER, s);
          const b = [];
          for (let Y = 0; Y < I; Y++) {
            const T = this.createTexture();
            t.framebufferTexture2D(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + Y,
              t.TEXTURE_2D,
              T,
              0
              /* level */
            ), b.push(T);
          }
          s.textures = b, s.texture = b[0], s.blend = o;
          const {
            width: V,
            height: S
          } = this.canvas;
          return G && !d && (s.depthBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, s.depthBuffer), t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, V, S), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, s.depthBuffer)), d && !G && (s.stencilBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, s.stencilBuffer), t.renderbufferStorage(t.RENDERBUFFER, t.STENCIL_INDEX8, V, S), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.STENCIL_ATTACHMENT, t.RENDERBUFFER, s.stencilBuffer)), G && d && (s.depthStencilBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, s.depthStencilBuffer), t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, V, S), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, s.depthStencilBuffer)), t.bindFramebuffer(t.FRAMEBUFFER, null), s;
        }
        bindFBO(I = null) {
          this.fbo = I;
        }
        render({
          clearBuffer: I = !0
        } = {}) {
          this.startRender = !0;
          const o = this.gl;
          let G = this.program;
          G || (G = this.createProgram(), this.useProgram(G)), this.fbo && o.bindFramebuffer(o.FRAMEBUFFER, this.fbo);
          const d = this.options.depth;
          d && o.enable(o.DEPTH_TEST), this.gl.clear(this.gl.COLOR_BUFFER_BIT | (d ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.options.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));
          const t = this._renderFrameID;
          this._draw(), this.fbo && o.bindFramebuffer(o.FRAMEBUFFER, null), this._renderFrameID === t && (this._renderFrameID = null);
        }
        update() {
          this.startRender && this._renderFrameID == null && (this._renderFrameID = requestAnimationFrame(this.render.bind(this)));
        }
      }
      u(p, "defaultOptions", {
        preserveDrawingBuffer: !0,
        autoUpdate: !0,
        vertexPosition: "a_vertexPosition",
        vertexTextureCoord: "a_vertexTextureCoord",
        webgl2: !1
      }), u(p, "UBYTE", p.UNSIGNED_BYTE), u(p, "USHORT", p.UNSIGNED_SHORT), u(p, "fetchShader", c.fetchShader), u(p, "loadImage", c.loadImage);
    },
    /* 16 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "setupWebGL", function() {
        return Z;
      }), i.d(l, "createProgram", function() {
        return L;
      }), i.d(l, "pointsToBuffer", function() {
        return K;
      }), i.d(l, "loadImage", function() {
        return a;
      }), i.d(l, "fetchShader", function() {
        return r;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c(X, W) {
        const p = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        let C = null;
        for (let I = 0; I < p.length; ++I) {
          try {
            C = X.getContext(p[I], W);
          } catch {
          }
          if (C)
            break;
        }
        return C;
      }
      function Z(X, W) {
        const p = c(X, W);
        if (!p)
          throw new Error("Sorry, your browser doesn't support WebGL.");
        return p;
      }
      function L(X, W, p) {
        const C = X.createShader(X.VERTEX_SHADER);
        if (X.shaderSource(C, W), X.compileShader(C), !X.getShaderParameter(C, X.COMPILE_STATUS)) {
          const G = `Vertex shader failed to compile.  The error log is:${X.getShaderInfoLog(C)}`;
          throw new Error(G);
        }
        const I = X.createShader(X.FRAGMENT_SHADER);
        if (X.shaderSource(I, p), X.compileShader(I), !X.getShaderParameter(I, X.COMPILE_STATUS)) {
          const G = `Fragment shader failed to compile.  The error log is:${X.getShaderInfoLog(I)}`;
          throw new Error(G);
        }
        const o = X.createProgram();
        if (X.attachShader(o, C), X.attachShader(o, I), X.linkProgram(o), !X.getProgramParameter(o, X.LINK_STATUS)) {
          const G = `Shader program failed to link.  The error log is:${X.getProgramInfoLog(o)}`;
          throw new Error(G);
        }
        return X.deleteShader(C), X.deleteShader(I), o;
      }
      function K(X, W = Float32Array, p = null) {
        if (p && !(p instanceof W))
          throw new TypeError("Wrong buffer type.");
        if (X == null || X instanceof W)
          return X;
        if (X[0] == null || X[0].length == null)
          return p ? (p.set(X, 0), p) : new W(X);
        const C = X[0].length, I = X.length;
        p || (p = new W(C * I));
        let o = 0;
        for (let G = 0; G < I; G++)
          for (let d = 0; d < C; d++)
            p[o++] = X[G][d];
        return p;
      }
      const u = {};
      function a(X, {
        useImageBitmap: W = !0,
        alias: p = null
      } = {}) {
        if (!u[X]) {
          if (typeof Image == "function") {
            const C = new Image();
            typeof X == "string" && !(typeof location == "object" && /^file:/.test(location.href)) && !/^data:/.test(X) && (C.crossOrigin = "anonymous"), u[X] = new Promise((I) => {
              C.onload = function() {
                W && typeof createImageBitmap == "function" ? createImageBitmap(C, {
                  imageOrientation: "flipY"
                }).then((o) => {
                  u[X] = o, p && (u[p] = o), I(o);
                }) : (u[X] = C, p && (u[p] = C), I(C));
              }, C.src = X;
            }), p && (u[p] = u[X]);
          } else if (typeof fetch == "function")
            return fetch(X, {
              method: "GET",
              mode: "cors",
              cache: "default"
            }).then((C) => C.blob()).then((C) => createImageBitmap(C, {
              imageOrientation: "flipY"
            }).then((I) => (u[X] = I, p && (u[p] = I), I)));
        }
        return u[X];
      }
      const e = {};
      async function r(X) {
        if (e[X])
          return e[X];
        const W = await fetch(X);
        if (W.status >= 200 && W.status < 300) {
          const p = await W.text();
          return e[X] = p, p;
        }
        throw new Error("Shader loaded error.");
      }
    },
    /* 17 */
    /***/
    function(n, l, i) {
      i.r(l), l.default = `attribute vec3 a_vertexPosition;

void main() {
  gl_PointSize = 1.0;
  gl_Position = vec4(a_vertexPosition, 1);
}`;
    },
    /* 18 */
    /***/
    function(n, l, i) {
      i.r(l), l.default = `#ifdef GL_ES
precision mediump float;
#endif

void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
}`;
    },
    /* 19 */
    /***/
    function(n, l, i) {
      i.r(l), l.default = `attribute vec4 a_vertexPosition;
attribute vec2 a_vertexTextureCoord;
varying vec2 vTextureCoord;

void main() {
  gl_PointSize = 1.0;
  gl_Position = a_vertexPosition;
  vTextureCoord = a_vertexTextureCoord;
}`;
    },
    /* 20 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return K;
      });
      var c = i(21), Z = i(25);
      i(1).glMatrix.setMatrixArrayType(Array);
      const L = Symbol("transform");
      class K {
        constructor(a, e) {
          this.context = a.getContext("2d"), this.options = e, this[L] = [1, 0, 0, 1, 0, 0];
        }
        createTexture(a) {
          return {
            _img: a
          };
        }
        async loadTexture(a) {
          const e = await c.default.loadImage(a, {
            useImageBitmap: !1
          });
          return this.createTexture(e);
        }
        deleteTexture(a) {
          return a;
        }
        clear(a, e, r, X) {
          const W = this.context;
          a = a || 0, e = e || 0, r = r || W.canvas.width - a, X = X || W.canvas.height - e, W.clearRect(a, e, r, X);
        }
        drawMeshCloud(a, {
          clear: e = !1
        } = {}) {
          const r = [];
          for (let X = 0; X < a.amount; X++) {
            const W = a.getTransform(X);
            let p = a.getTextureFrame(X);
            p && (p = p._img);
            const C = a.getFilter(X), {
              fill: I,
              stroke: o
            } = a.getCloudRGBA(X);
            r.push({
              mesh: a.mesh,
              _cloudOptions: [I, o, p, W, C]
            });
          }
          a.beforeRender && a.beforeRender(this.context, a), this.drawMeshes(r, {
            clear: e,
            hook: !1
          }), a.afterRender && a.afterRender(this.context, a);
        }
        drawMeshes(a, {
          clear: e = !1,
          hook: r = !0
        } = {}) {
          const X = this.context;
          e && X.clearRect(0, 0, X.canvas.width, X.canvas.height);
          let W = null;
          const {
            width: p,
            height: C
          } = X.canvas, I = a.length;
          a.forEach((o, G) => {
            let d, t, s, b, V;
            r && o.beforeRender && o.beforeRender(X, o), o._cloudOptions && ([d, t, s, b, V] = o._cloudOptions, o = o.mesh);
            let S = o.filter;
            if (V && (S = S ? `${S} ${V}` : V), S && !this.filterBuffer && this.filterBuffer !== !1) {
              const Y = c.default.createCanvas(p, C);
              Y ? this.filterBuffer = Y.getContext("2d") : this.filterBuffer = !1;
            }
            W && W !== S && (Object(Z.applyFilter)(this.filterBuffer, W), X.drawImage(this.filterBuffer.canvas, 0, 0, p, C), this.filterBuffer.clearRect(0, 0, p, C), W = null), S && this.filterBuffer ? (this.filterBuffer.save(), this.filterBuffer.transform(...this[L]), Object(Z.drawMesh2D)(o, this.filterBuffer, !1, d, t, s, b), this.filterBuffer.restore(), G === I - 1 ? (Object(Z.applyFilter)(this.filterBuffer, S), X.drawImage(this.filterBuffer.canvas, 0, 0, p, C), this.filterBuffer.clearRect(0, 0, p, C)) : W = S) : (X.save(), X.transform(...this[L]), Object(Z.drawMesh2D)(o, X, !1, d, t, s, b), X.restore()), r && o.afterRender && o.afterRender(X, o);
          });
        }
        setTransform(a) {
          this[L] = a;
        }
      }
    },
    /* 21 */
    /***/
    function(n, l, i) {
      i.r(l), (function(c) {
        var Z = i(14), L = i(23), K = i(24);
        i(1).glMatrix.setMatrixArrayType(Array);
        const u = {};
        function a(p, C) {
          const {
            style: I,
            variant: o,
            weight: G,
            stretch: d,
            size: t,
            pxLineHeight: s,
            family: b
          } = p;
          return d === "normal" ? `${I} ${o} ${G} ${t * C}px/${s * C}px ${b}` : `${I} ${o} ${G} ${d} ${t * C}px/${s * C}px ${b}`;
        }
        function e(p, {
          font: C,
          fillColor: I,
          strokeColor: o,
          strokeWidth: G,
          ratio: d = 1,
          textCanvas: t,
          cachable: s = !1
        }) {
          let b;
          if (s) {
            b = [p, C, String(I), String(o), String(G)].join("###");
            const Q = u[b];
            if (Q)
              return Q;
          }
          t || (t = X(1, 1));
          const V = t.getContext("2d");
          V.save(), V.font = C;
          let {
            width: S
          } = V.measureText(p);
          V.restore();
          const Y = Object(L.default)(C), T = Math.max(Y.pxLineHeight, Y.pxHeight * 1.13);
          /italic|oblique/.test(C) && (S += T * Math.tan(15 * Math.PI / 180)), !I && !o && (I = "#000");
          const y = V.canvas, J = Math.ceil(S), N = Math.ceil(T);
          y.width = Math.round(J * d), y.height = Math.round(N * d), V.save(), V.font = a(Y, d), V.textAlign = "center", V.textBaseline = "middle";
          const R = y.height * 0.5 + Y.pxHeight * 0.05 * d, x = y.width * 0.5;
          if (I) {
            if (Array.isArray(I))
              I = Object(K.default)(I);
            else if (I.vector) {
              let Q;
              const {
                vector: P,
                colors: D
              } = I;
              P.length === 6 ? Q = V.createRadialGradient(...P) : Q = V.createLinearGradient(...P), D.forEach(({
                offset: _,
                color: F
              }) => {
                Q.addColorStop(_, F);
              }), I = Q;
            }
            V.fillStyle = I, V.fillText(p, x, R);
          }
          if (o) {
            if (V.lineWidth = G * d, Array.isArray(o))
              o = Object(K.default)(o);
            else if (o.vector) {
              let Q;
              const {
                vector: P,
                colors: D
              } = o;
              P.length === 6 ? Q = V.createRadialGradient(...P) : Q = V.createLinearGradient(...P), D.forEach(({
                offset: _,
                color: F
              }) => {
                Q.addColorStop(_, F);
              }), o = Q;
            }
            V.strokeStyle = o, V.strokeText(p, x, R);
          }
          V.restore();
          const M = {
            image: t,
            rect: [0, 0, J, N]
          };
          return s && (u[b] = M), M;
        }
        let r = !1;
        if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
          const p = navigator.userAgent.toLowerCase().match(/chrome\/(\d+)/);
          p && (r = Number(p[1]) < 70);
        }
        function X(p, C, I = {}) {
          const o = I.offscreen || !r && I.offscreen !== !1;
          let G;
          return typeof c < "u" && typeof c.createCanvas == "function" ? G = c.createCanvas(p, C, I) : o && typeof OffscreenCanvas == "function" ? G = new OffscreenCanvas(p, C) : (G = document.createElement("canvas"), G.width = p, G.height = C), G;
        }
        const W = {
          createCanvas: X,
          createText: e,
          loadImage: Z.default.loadImage
        };
        l.default = W;
      }).call(this, i(22));
    },
    /* 22 */
    /***/
    function(n, l) {
      var i;
      i = /* @__PURE__ */ function() {
        return this;
      }();
      try {
        i = i || new Function("return this")();
      } catch {
        typeof window == "object" && (i = window);
      }
      n.exports = i;
    },
    /* 23 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return I;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c(o, G) {
        if (typeof o == "string") {
          const s = o.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%)$/);
          s ? o = {
            size: parseFloat(s[1]),
            unit: s[2]
          } : o = {
            size: parseInt(o, 10),
            unit: "px"
          };
        }
        let {
          size: d,
          unit: t
        } = o;
        if (t === "pt")
          d /= 0.75;
        else if (t === "pc")
          d *= 16;
        else if (t === "in")
          d *= 96;
        else if (t === "cm")
          d *= 96 / 2.54;
        else if (t === "mm")
          d *= 96 / 25.4;
        else if (t === "em" || t === "rem" || t === "ex") {
          if (!G && typeof getComputedStyle == "function" && typeof document < "u") {
            const s = getComputedStyle(document.documentElement).fontSize;
            G = c(s, 16);
          }
          d *= G, t === "ex" && (d /= 2);
        } else if (t === "q")
          d *= 96 / 25.4 / 4;
        else if (t === "vw" || t === "vh") {
          if (typeof document < "u") {
            const s = t === "vw" ? document.documentElement.clientWidth : document.documentElement.clientHeight;
            d *= s / 100;
          }
        } else if ((t === "vmax" || t === "vmin") && typeof document < "u") {
          const s = document.documentElement.clientWidth, b = document.documentElement.clientHeight;
          t === "vmax" ? d *= Math.max(s, b) / 100 : d *= Math.min(s, b) / 100;
        }
        return d;
      }
      const Z = "bold|bolder|lighter|[1-9]00", L = "italic|oblique", K = "small-caps", u = "ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded", a = "px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%", e = `'([^']+)'|"([^"]+)"|([\\w-]|[一-龥])+`, r = new RegExp(`(${Z}) +`, "i"), X = new RegExp(`(${L}) +`, "i"), W = new RegExp(`(${K}) +`, "i"), p = new RegExp(`(${u}) +`, "i"), C = new RegExp("([\\d\\.]+)(" + a + ")(?:\\/([\\d\\.]+)(" + a + "))? *((?:" + e + ")( *, *(?:" + e + "))*)");
      function I(o, G) {
        const d = C.exec(o);
        if (!d)
          return;
        const t = parseFloat(d[3]), s = {
          weight: "normal",
          style: "normal",
          stretch: "normal",
          variant: "normal",
          size: parseFloat(d[1]),
          unit: d[2],
          lineHeight: Number.isFinite(t) ? t : void 0,
          lineHeightUnit: d[4],
          family: d[5].replace(/ *, */g, ",")
        }, b = o.substring(0, d.index), V = r.exec(b), S = X.exec(b), Y = W.exec(b), T = p.exec(b);
        return V && (s.weight = V[1]), S && (s.style = S[1]), Y && (s.variant = Y[1]), T && (s.stretch = T[1]), s.pxHeight = c({
          size: s.size,
          unit: s.unit
        }, G), s.pxLineHeight = c({
          size: s.lineHeight || s.size,
          unit: s.lineHeightUnit || s.unit
        }, G), s;
      }
    },
    /* 24 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return c;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c(Z) {
        return `rgba(${Z.map((L, K) => K < 3 ? Math.round(L * 255) : L).join()})`;
      }
    },
    /* 25 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "applyFilter", function() {
        return u;
      }), i.d(l, "drawMesh2D", function() {
        return e;
      });
      var c = i(1), Z = i(24), L = i(23), K = i(26);
      i(1).glMatrix.setMatrixArrayType(Array);
      function u(r, X) {
        const W = r.canvas;
        r.save(), r.filter = X, r.drawImage(W, 0, 0, W.width, W.height), r.restore();
      }
      function a(r, X) {
        const W = /rgba\((\d+),(\d+),(\d+),(\d+)\)/;
        r = r.match(W).slice(1, 5).map(Number), X = X.match(W).slice(1, 5).map(Number);
        const p = [], C = X[3];
        for (let I = 0; I < 4; I++)
          p[I] = Object(K.mix)(r[I], X[I], C);
        return `rgba(${p.join()})`;
      }
      function e(r, X, W = !0, p = null, C = null, I = null, o = null) {
        X.save();
        let G = !1, d = !1;
        if (X.globalAlpha = r.getOpacity(), r._updateMatrix && r.transformScale / r.contours.scale > 1.5 && r.accurate(r.transformScale), r.lineWidth) {
          let b = r.gradient && r.gradient.stroke;
          if (b) {
            const {
              vector: V,
              colors: S
            } = b;
            if (V.length === 6)
              b = X.createRadialGradient(...V);
            else if (V.length === 4)
              b = X.createLinearGradient(...V);
            else if (V.length === 3)
              b = X.createCircularGradient(...V);
            else
              throw new TypeError("Invalid vector dimension.");
            S.forEach(({
              offset: Y,
              color: T
            }) => {
              let y = Object(Z.default)(T);
              C && (y = a(y, C)), b.addColorStop(Y, y);
            }), X.strokeStyle = b, G = !0;
          } else
            r.strokeStyle && (C ? X.strokeStyle = a(r.strokeStyle, C) : X.strokeStyle = r.strokeStyle, G = !0);
        }
        G && (X.lineWidth = r.lineWidth, X.lineJoin = r.lineJoin, X.lineCap = r.lineCap, X.miterLimit = r.miterLimit, r.lineDash && (X.setLineDash(r.lineDash), r.lineDashOffset && (X.lineDashOffset = r.lineDashOffset)));
        let t = r.gradient && r.gradient.fill;
        if (t) {
          const {
            vector: b,
            colors: V
          } = t;
          if (b.length === 6)
            t = X.createRadialGradient(...b);
          else if (b.length === 4)
            t = X.createLinearGradient(...b);
          else if (b.length === 3)
            t = X.createCircularGradient(...b);
          else
            throw new TypeError("Invalid vector dimension.");
          V.forEach(({
            offset: S,
            color: Y
          }) => {
            let T = Object(Z.default)(Y);
            C && (T = a(T, C)), t.addColorStop(S, T);
          }), X.fillStyle = t, d = !0;
        } else
          r.fillStyle && (p ? X.fillStyle = a(r.fillStyle, p) : X.fillStyle = r.fillStyle, d = !0);
        if (o && X.transform(...o), X.transform(...r.transformMatrix), r.clipPath) {
          const b = r.clipPath, V = new Path2D(b);
          X.clip(V);
        }
        const s = r.contours.length;
        if (r.contours.forEach((b, V) => {
          const S = b.length, Y = S > 1 && c.vec2.equals(b[0], b[S - 1]), T = V === s - 1 && r.texture;
          if (b && S > 0) {
            if (d || G || T) {
              X.beginPath(), X.moveTo(...b[0]);
              for (let y = 1; y < S; y++)
                y === S - 1 && Y ? X.closePath() : X.lineTo(...b[y]);
            }
            if (d && X.fill(r.fillRule), T) {
              X.save(), X.clip();
              let {
                image: y,
                options: J
              } = r.texture;
              if (I && (y = I), J.repeat && console.warn("Context 2D not supported image repeat yet."), y.font) {
                J.scale && console.warn("Context 2D not supported text scale yet."), J.srcRect && console.warn("Context 2D not supported text srcRect yet.");
                let {
                  font: N,
                  fillColor: R,
                  strokeColor: x,
                  strokeWidth: M,
                  text: Q
                } = y;
                !R && !x && (R = "#000"), Array.isArray(R) && (R = Object(Z.default)(R)), Array.isArray(x) && (x = Object(Z.default)(x)), X.font = N;
                const {
                  width: P
                } = X.measureText(Q), D = Object(L.default)(N), _ = Math.max(D.pxLineHeight, D.pxHeight * 1.13);
                X.textAlign = "center", X.textBaseline = "middle";
                const F = J.rect, v = F[0] + _ * 0.5 + D.pxHeight * 0.06, O = F[1] + P * 0.5;
                F[2] != null && X.scale(F[2] / P, F[3] / _), R && (X.fillStyle = R, X.fillText(Q, O, v)), x && (X.lineWidth = M, X.strokeStyle = x, X.strokeText(Q, O, v));
              } else {
                let N = J.rect;
                const R = J.srcRect;
                J.scale && (N = [0, 0, X.canvas.width, X.canvas.height]), J.rotated && N && (N = [-N[1], N[0], N[3], N[2]]), R && (N = N || [0, 0, R[2], R[3]]), J.rotated && (X.translate(0, N ? N[2] : y.width), X.rotate(-0.5 * Math.PI)), R ? X.drawImage(y, ...R, ...N) : N ? X.drawImage(y, ...N) : X.drawImage(y, 0, 0);
              }
              X.restore();
            }
            G && X.stroke();
          }
        }), X.restore(), W) {
          const b = r.filter;
          b && u(X, b);
        }
      }
    },
    /* 26 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "clamp", function() {
        return c;
      }), i.d(l, "mix", function() {
        return Z;
      }), i.d(l, "transformPoint", function() {
        return L;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c(K, u, a) {
        return u > a && ([u, a] = [a, u]), K < u ? u : K > a ? a : K;
      }
      function Z(K, u, a) {
        return K * (1 - a) + u * a;
      }
      function L(K, u) {
        const [a, e] = K;
        return [a * u[0] + e * u[2] + u[4], a * u[1] + e * u[3] + u[5]];
      }
    },
    /* 27 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return a;
      });
      var c = i(28), Z = i(29);
      i(1).glMatrix.setMatrixArrayType(Array);
      function L(e, r, X) {
        const W = e.uniforms || {}, p = r.uniforms || {};
        if (W.u_texSampler && p.u_texSampler && W.u_texSampler !== p.u_texSampler)
          return !1;
        const C = Object.keys(W), I = Object.keys(p), o = C.indexOf("u_texSampler"), G = I.indexOf("u_texSampler");
        if (o >= 0 && C.splice(o, 1), G >= 0 && I.splice(G, 1), C.length !== I.length)
          return !1;
        const d = C.every((t) => {
          const s = W[t], b = p[t];
          if (s === b)
            return !0;
          if (s.length && b.length && s.length === b.length) {
            for (let V = 0; V < s.length; V++)
              if (s[V] !== b[V])
                return !1;
            return !0;
          }
          return !1;
        });
        if (d) {
          if (W.u_texSampler && !p.u_texSampler)
            r.setTexture(W.u_texSampler, {
              hidden: !0
            });
          else if (!W.u_texSampler && p.u_texSampler)
            for (let t = 0; t < X.length; t++)
              X[t].setTexture(p.u_texSampler, {
                hidden: !0
              });
        }
        return d;
      }
      const K = {};
      function u(e, r) {
        if (e.length) {
          const X = Object(c.default)(e, K);
          return X.enableBlend = r, e[0].filterCanvas && (X.filterCanvas = !0), X.packIndex = e[0].packIndex, X.packLength = e.length, X.beforeRender = e[0].beforeRender, X.pass = e[0].pass, X.afterRender = e[e.length - 1].afterRender, e.length = 0, X;
        }
      }
      function* a(e, r, X = !1) {
        const W = [], p = e.options.bufferSize;
        let C = 0, I = !1;
        for (let o = 0; o < r.length; o++) {
          const G = r[o];
          if (G instanceof Z.default)
            W.length && (yield u(W, I)), C = 0, I = !1, yield G;
          else {
            const d = G.meshData;
            if (d.clipPath && !d.uniforms.u_clipSampler) {
              const s = e.createTexture(d.clipPath);
              d.uniforms.u_clipSampler = s;
            }
            let t = 0;
            if ((!X || !G.canIgnore()) && d && d.positions.length) {
              G.packIndex = o;
              const s = G.filterCanvas;
              if (t = d.positions.length, s || C + t > p)
                W.length && (yield u(W, I)), C = 0, I = !1;
              else if (C) {
                const b = W[W.length - 1];
                b && (b.filterCanvas || b.afterRender || G.beforeRender || b.pass.length || G.pass.length || b.program !== G.program || !L(b, G, W)) && (yield u(W, I), C = 0, I = !1);
              }
              W.push(G), I = I || G.enableBlend, C += t;
            }
            o === r.length - 1 && W.length && (yield u(W, I));
          }
        }
      }
    },
    /* 28 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return L;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const c = {
        UNSIGNED_BYTE: Uint8Array,
        UNSIGNED_SHORT: Uint16Array,
        BYTE: Int8Array,
        SHORT: Int16Array,
        FLOAT: Float32Array
      };
      function Z(K, u) {
        let a = 0, e = 0, r = 0, X = 0, W = 0, p = 0, C = 0;
        const I = K[0].program;
        for (let o = 0; o < K.length; o++) {
          const G = K[o].meshData;
          if (G) {
            C += G.positions.length;
            const d = G.positions[0].length;
            a += G.positions.length * d, e += G.cells.length * 3, p += G.attributes.a_color.length * 4;
            const t = G.textureCoord;
            t && (r += t.length * t[0].length);
            const s = G.attributes.a_sourceRect;
            s && (X += s.length * 4);
            const b = G.attributes.a_clipUV;
            b && (W += b.length * 2);
          }
        }
        if ((!u.positions || u.positions.length < a) && (u.positions = new Float32Array(a)), (!u.cells || u.cells.length < e) && (u.cells = new Uint16Array(e)), r && (!u.textureCoord || u.textureCoord.length < r) && (u.textureCoord = new Float32Array(r)), (!u.a_color || u.a_color.length < p) && (u.a_color = new Uint8Array(p)), X && (!u.a_sourceRect || u.a_sourceRect.length < X) && (u.a_sourceRect = new Float32Array(X)), W && (!u.a_clipUV || u.a_clipUV.length < W) && (u.a_clipUV = new Float32Array(W)), I) {
          const o = Object.entries(I._attribute), G = I._attribOpts || {};
          for (let d = 0; d < o.length; d++) {
            const [t, s] = o[d];
            if (t !== "a_color" && t !== "a_sourceRect" && s !== "ignored") {
              const b = G[t] ? G[t].type : "FLOAT", V = c[b], S = s.size * C;
              (!u[t] || u[t].length < S) && (u[t] = new V(S));
            }
          }
        }
        return u;
      }
      function L(K, u) {
        let a = [], e = [], r = [], X = [], W = [], p = [], C = 0, I = 0;
        const o = K[0] ? K[0].uniforms || {} : {}, G = K[0] ? K[0].program : null;
        u && (Z(K, u), e = u.cells, a = u.positions, r = u.textureCoord, X = u.a_color, W = u.a_sourceRect, p = u.a_clipUV);
        let d = !1, t = !1;
        const s = {};
        for (let V = 0; V < K.length; V++) {
          let S = K[V];
          if (S) {
            if (S.meshData && (S = S.meshData), u) {
              const T = S.positions;
              for (let y = 0; y < T.length; y++) {
                const J = T[y], N = 3 * (C + y);
                for (let R = 0; R < J.length; R++)
                  a[N + R] = J[R];
              }
            } else
              a.push(...S.positions);
            const Y = S.cells;
            for (let T = 0; T < Y.length; T++) {
              const y = Y[T];
              if (u) {
                const J = 3 * (I + T);
                e[J] = y[0] + C, e[J + 1] = y[1] + C, e[J + 2] = y[2] + C;
              } else
                e.push([y[0] + C, y[1] + C, y[2] + C]);
            }
            if (u) {
              const T = S.attributes.a_color;
              for (let y = 0; y < T.length; y++) {
                const J = T[y], N = 4 * (C + y);
                X[N] = J[0], X[N + 1] = J[1], X[N + 2] = J[2], X[N + 3] = J[3];
              }
            } else
              X.push(...S.attributes.a_color);
            if (S.attributes.a_sourceRect)
              if (d = !0, u) {
                const T = S.attributes.a_sourceRect;
                for (let y = 0; y < T.length; y++) {
                  const J = T[y], N = 4 * (C + y);
                  W[N] = J[0], W[N + 1] = J[1], W[N + 2] = J[2], W[N + 3] = J[3];
                }
              } else
                W.push(...S.attributes.a_sourceRect);
            if (S.attributes.a_clipUV)
              if (t = !0, u) {
                const T = S.attributes.a_clipUV;
                for (let y = 0; y < T.length; y++) {
                  const J = T[y], N = 2 * (C + y);
                  p[N] = J[0], p[N + 1] = J[1];
                }
              } else
                p.push(...S.attributes.a_clipUV);
            if (S.textureCoord)
              if (u) {
                const T = S.textureCoord;
                for (let y = 0; y < T.length; y++) {
                  const J = T[y], N = 3 * (C + y);
                  for (let R = 0; R < J.length; R++)
                    r[N + R] = J[R];
                }
              } else
                r.push(...S.textureCoord);
            if (G) {
              const T = Object.entries(G._attribute);
              for (let y = 0; y < T.length; y++) {
                const [J, N] = T[y];
                if (J !== "a_color" && J !== "a_sourceRect" && N !== "ignored")
                  if (s[J] = [], u) {
                    s[J] = u[J];
                    const R = S.attributes[J], x = R[0].length;
                    for (let M = 0; M < R.length; M++) {
                      const Q = R[M], P = x * (C + M);
                      for (let D = 0; D < Q.length; D++)
                        s[J][P + D] = Q[D];
                    }
                  } else
                    s[J].push(...S.attributes[J]);
              }
            }
            C += S.positions.length, I += S.cells.length;
          }
        }
        s.a_color = X, d && W && W.length > 0 && (s.a_sourceRect = W);
        const b = {
          positions: a,
          cells: e,
          attributes: s,
          uniforms: o,
          cellsCount: I * 3,
          program: G
        };
        return r && r.length && (b.textureCoord = r), t && p.length > 0 && (s.a_clipUV = p), b;
      }
    },
    /* 29 */
    /***/
    function(n, l, i) {
      i.r(l);
      var c = i(1), Z = i(30), L = i(26), K = i(31);
      i(1).glMatrix.setMatrixArrayType(Array);
      function u(s, b) {
        var V = Object.keys(s);
        if (Object.getOwnPropertySymbols) {
          var S = Object.getOwnPropertySymbols(s);
          b && (S = S.filter(function(Y) {
            return Object.getOwnPropertyDescriptor(s, Y).enumerable;
          })), V.push.apply(V, S);
        }
        return V;
      }
      function a(s) {
        for (var b = 1; b < arguments.length; b++) {
          var V = arguments[b] != null ? arguments[b] : {};
          b % 2 ? u(Object(V), !0).forEach(function(S) {
            e(s, S, V[S]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(V)) : u(Object(V)).forEach(function(S) {
            Object.defineProperty(s, S, Object.getOwnPropertyDescriptor(V, S));
          });
        }
        return s;
      }
      function e(s, b, V) {
        return b in s ? Object.defineProperty(s, b, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : s[b] = V, s;
      }
      const r = Symbol("mesh"), X = Symbol("count"), W = Symbol("blend"), p = Symbol("filter"), C = Symbol("textures"), I = Symbol("textureOptions"), o = Symbol("cloudColor"), G = Symbol("cloudFilter"), d = Symbol("buffer");
      function t(s, b = null) {
        const V = new Float32Array(3 * s), S = new Float32Array(3 * s), Y = new Float32Array(4 * s), T = new Float32Array(4 * s), y = new Float32Array(4 * s), J = new Float32Array(4 * s), N = new Float32Array(4 * s), R = new Uint8Array(s), x = new Uint8Array(4 * s), M = new Uint8Array(4 * s);
        return b && (V.set(b.transform0, 0), S.set(b.transform1, 0), Y.set(b.color0, 0), T.set(b.color1, 0), y.set(b.color2, 0), J.set(b.color3, 0), N.set(b.color4, 0), R.set(b.frameIndex, 0), x.set(b.fillColor, 0), M.set(b.strokeColor, 0)), {
          bufferSize: s,
          transform0: V,
          transform1: S,
          color0: Y,
          color1: T,
          color2: y,
          color3: J,
          color4: N,
          frameIndex: R,
          fillColor: x,
          strokeColor: M
        };
      }
      l.default = class {
        constructor(s, b = 1, {
          buffer: V = 1e3
        } = {}) {
          V = Math.max(V, b), this[X] = b, this[r] = s, this[d] = t(V), this[C] = [], this[p] = [], this[o] = !1, this[G] = !1, this[W] = !1, this.initBuffer();
        }
        initBuffer(s = 0) {
          const b = this[X];
          for (let V = s; V < b; V++)
            this[d].transform0.set([1, 0, 0], V * 3), this[d].transform1.set([0, 1, 0], V * 3), this[d].frameIndex.set([-1], V), this[d].fillColor.set([0, 0, 0, 0], V * 4), this[d].strokeColor.set([0, 0, 0, 0], V * 4), this.setColorTransform(V, null);
        }
        get bufferSize() {
          return this[d].bufferSize;
        }
        get mesh() {
          return this[r];
        }
        set mesh(s) {
          this[r] = s, this[C] && this.setTextureFrames(this[C], this[I]);
        }
        get hasCloudColor() {
          return this[o];
        }
        get hasCloudFilter() {
          return this[G];
        }
        _getFilter(s) {
          return this[p][s] = this[p][s] || [], this[p][s];
        }
        getFilter(s) {
          return this._getFilter(s).join(" ");
        }
        get enableBlend() {
          return this[r].enableBlend || this[W];
        }
        canIgnore() {
          return this[r].canIgnore();
        }
        delete(s) {
          if (s >= this[X] || s < 0)
            throw new Error("Out of range.");
          const {
            transform0: b,
            transform1: V,
            color0: S,
            color1: Y,
            color2: T,
            color3: y,
            color4: J,
            frameIndex: N,
            fillColor: R,
            strokeColor: x
          } = this[d];
          b.set(b.subarray(3 * (s + 1)), 3 * s), V.set(V.subarray(3 * (s + 1)), 3 * s), S.set(S.subarray(4 * (s + 1)), 4 * s), Y.set(Y.subarray(4 * (s + 1)), 4 * s), T.set(T.subarray(4 * (s + 1)), 4 * s), y.set(y.subarray(4 * (s + 1)), 4 * s), J.set(J.subarray(4 * (s + 1)), 4 * s), N.set(N.subarray(s + 1), s), R.set(R.subarray(4 * (s + 1)), 4 * s), x.set(x.subarray(4 * (s + 1)), 4 * s);
          for (const M in this[p])
            M === s ? delete this[p][M] : M > s && (this[p][M - 1] = this[p][M], delete this[p][M]);
          this[X]--;
        }
        setColorTransform(s, b) {
          if (s >= this[X] || s < 0)
            throw new Error("Out of range.");
          s *= 4;
          const {
            color0: V,
            color1: S,
            color2: Y,
            color3: T,
            color4: y
          } = this[d];
          return b != null ? (V.set([b[0], b[5], b[10], b[15]], s), S.set([b[1], b[6], b[11], b[16]], s), Y.set([b[2], b[7], b[12], b[17]], s), T.set([b[3], b[8], b[13], b[18]], s), y.set([b[4], b[9], b[14], b[19]], s), this[W] = this[W] || b[18] < 1, this[G] = !0) : (V.set([1, 0, 0, 0], s), S.set([0, 1, 0, 0], s), Y.set([0, 0, 1, 0], s), T.set([0, 0, 0, 1], s), y.set([0, 0, 0, 0], s)), this;
        }
        getColorTransform(s) {
          if (s >= this[X] || s < 0)
            throw new Error("Out of range.");
          s *= 4;
          const {
            color0: b,
            color1: V,
            color2: S,
            color3: Y,
            color4: T
          } = this[d];
          return [b[s], V[s], S[s], Y[s], T[s], b[s + 1], V[s + 1], S[s + 1], Y[s + 1], T[s + 1], b[s + 2], V[s + 2], S[s + 2], Y[s + 2], T[s + 2], b[s + 3], V[s + 3], S[s + 3], Y[s + 3], T[s + 3]];
        }
        transformColor(s, b) {
          let V = this.getColorTransform(s);
          return V = Object(Z.multiply)(V, b), this.setColorTransform(s, V), this;
        }
        setFillColor(s, b) {
          if (s >= this[X] || s < 0)
            throw new Error("Out of range.");
          typeof b == "string" && (b = Object(K.default)(b)), b[3] > 0 && (this[o] = !0), this[d].fillColor.set(b.map((V) => Math.round(255 * V)), 4 * s);
        }
        setStrokeColor(s, b) {
          if (s >= this[X] || s < 0)
            throw new Error("Out of range.");
          typeof b == "string" && (b = Object(K.default)(b)), b[3] > 0 && (this[o] = !0), this[d].strokeColor.set(b.map((V) => Math.round(255 * V)), 4 * s);
        }
        getCloudRGBA(s) {
          if (s >= this[X] || s < 0)
            throw new Error("Out of range.");
          s *= 4;
          const {
            fillColor: b,
            strokeColor: V
          } = this[d], S = [b[s], b[s + 1], b[s + 2], b[s + 3]], Y = [V[s], V[s + 1], V[s + 2], V[s + 3]];
          return S[3] /= 255, Y[3] /= 255, {
            fill: `rgba(${S.join()})`,
            stroke: `rgba(${Y.join()})`
          };
        }
        grayscale(s, b) {
          this.transformColor(s, Object(Z.grayscale)(b)), this._getFilter(s).push(`grayscale(${100 * b}%)`);
        }
        brightness(s, b) {
          this.transformColor(s, Object(Z.brightness)(b)), this._getFilter(s).push(`brightness(${100 * b}%)`);
        }
        saturate(s, b) {
          this.transformColor(s, Object(Z.saturate)(b)), this._getFilter(s).push(`saturate(${100 * b}%)`);
        }
        contrast(s, b) {
          this.transformColor(s, Object(Z.contrast)(b)), this._getFilter(s).push(`contrast(${100 * b}%)`);
        }
        invert(s, b) {
          this.transformColor(s, Object(Z.invert)(b)), this._getFilter(s).push(`invert(${100 * b}%)`);
        }
        sepia(s, b) {
          this.transformColor(s, Object(Z.sepia)(b)), this._getFilter(s).push(`sepia(${100 * b}%)`);
        }
        opacity(s, b) {
          this.transformColor(s, Object(Z.opacity)(b)), this._getFilter(s).push(`opacity(${100 * b}%)`);
        }
        hueRotate(s, b) {
          this.transformColor(s, Object(Z.hueRotate)(b)), this._getFilter(s).push(`hue-rotate(${b}deg)`);
        }
        setTransform(s, b) {
          if (s >= this[X] || s < 0)
            throw new Error("Out of range.");
          s *= 3, b == null && (b = [1, 0, 0, 1, 0, 0]);
          const {
            transform0: V,
            transform1: S
          } = this[d];
          return V.set([b[0], b[2], b[4]], s), S.set([b[1], b[3], b[5]], s), this;
        }
        getTransform(s) {
          if (s >= this[X] || s < 0)
            throw new Error("Out of range.");
          s *= 3;
          const {
            transform0: b,
            transform1: V
          } = this[d];
          return [b[s], V[s], b[s + 1], V[s + 1], b[s + 2], V[s + 2]];
        }
        getTextureFrame(s) {
          return this[C][this[d].frameIndex[s]];
        }
        setTextureFrames(s = [], b = {}) {
          if (s.length > 12)
            throw new Error("Max frames exceed. Allow 12 frames.");
          s.length && this[r].setTexture(s[0], b), this[C] = s, this[I] = b;
        }
        setFrameIndex(s, b) {
          if (s >= this[X] || s < 0)
            throw new Error("Out of range.");
          const V = this[C].length;
          if (V <= 0)
            throw new Error("No frames");
          this[d].frameIndex[s] = b % V;
        }
        get amount() {
          return this[X];
        }
        set amount(s) {
          const b = this[X];
          s !== b && (s > this[d].bufferSize && (this[d] = t(Math.max(s, this[d].bufferSize + 1e3), this[d])), this[X] = s, s > b && this.initBuffer(b));
        }
        get meshData() {
          const {
            attributes: s,
            cells: b,
            positions: V,
            textureCoord: S,
            uniforms: Y
          } = this[r].meshData, T = this[C], y = {
            attributes: a({}, s),
            cells: b,
            positions: V,
            textureCoord: S,
            uniforms: a({}, Y),
            instanceCount: this[X],
            enableBlend: this.enableBlend
          };
          T.length && T.forEach((v, O) => {
            y.uniforms[`u_texFrame${O}`] = v;
          });
          const {
            transform0: J,
            transform1: N,
            color0: R,
            color1: x,
            color2: M,
            color3: Q,
            color4: P,
            fillColor: D,
            strokeColor: _,
            frameIndex: F
          } = this[d];
          return this[r].uniforms.u_texSampler && (y.attributes.a_frameIndex = {
            data: F,
            divisor: 1
          }), y.attributes.a_transform0 = {
            data: J,
            divisor: 1
          }, y.attributes.a_transform1 = {
            data: N,
            divisor: 1
          }, y.attributes.a_colorCloud0 = {
            data: R,
            divisor: 1
          }, y.attributes.a_colorCloud1 = {
            data: x,
            divisor: 1
          }, y.attributes.a_colorCloud2 = {
            data: M,
            divisor: 1
          }, y.attributes.a_colorCloud3 = {
            data: Q,
            divisor: 1
          }, y.attributes.a_colorCloud4 = {
            data: P,
            divisor: 1
          }, this.hasCloudColor && (y.attributes.a_fillCloudColor = {
            data: D,
            divisor: 1
          }, y.attributes.a_strokeCloudColor = {
            data: _,
            divisor: 1
          }), y;
        }
        setProgram(s) {
          this[r].setProgram(s);
        }
        get program() {
          return this[r].program;
        }
        transform(s, b) {
          const V = this.getTransform(s);
          return b = c.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), V, b), this.setTransform(s, b), this;
        }
        translate(s, [b, V]) {
          let S = c.mat2d.create();
          return S = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), S, [b, V]), this.transform(s, S);
        }
        rotate(s, b, [V, S] = [0, 0]) {
          let Y = c.mat2d.create();
          return Y = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), Y, [V, S]), Y = c.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), Y, b), Y = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), Y, [-V, -S]), this.transform(s, Y);
        }
        scale(s, [b, V = b], [S, Y] = [0, 0]) {
          let T = c.mat2d.create();
          return T = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [S, Y]), T = c.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), T, [b, V]), T = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-S, -Y]), this.transform(s, T);
        }
        skew(s, [b, V = b], [S, Y] = [0, 0]) {
          let T = c.mat2d.create();
          return T = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [S, Y]), T = c.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), T, c.mat2d.fromValues(1, Math.tan(V), Math.tan(b), 1, 0, 0)), T = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), T, [-S, -Y]), this.transform(s, T);
        }
        isPointCollision(s, [b, V], S = "both") {
          const Y = this.getTransform(s), T = Object(L.transformPoint)([b, V], c.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), Y));
          return this[r].isPointCollision(...T, S);
        }
        isPointInFill(s, [b, V]) {
          return this.isPointCollision(s, [b, V], "fill");
        }
        isPointInStroke(s, [b, V]) {
          return this.isPointCollision(s, [b, V], "stroke");
        }
      };
    },
    /* 30 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "multiply", function() {
        return Z;
      }), i.d(l, "grayscale", function() {
        return L;
      }), i.d(l, "brightness", function() {
        return K;
      }), i.d(l, "saturate", function() {
        return u;
      }), i.d(l, "contrast", function() {
        return a;
      }), i.d(l, "invert", function() {
        return e;
      }), i.d(l, "sepia", function() {
        return r;
      }), i.d(l, "opacity", function() {
        return X;
      }), i.d(l, "hueRotate", function() {
        return W;
      });
      var c = i(26);
      i(1).glMatrix.setMatrixArrayType(Array);
      function Z(p, C) {
        const I = [], o = p[0], G = p[1], d = p[2], t = p[3], s = p[4], b = p[5], V = p[6], S = p[7], Y = p[8], T = p[9], y = p[10], J = p[11], N = p[12], R = p[13], x = p[14], M = p[15], Q = p[16], P = p[17], D = p[18], _ = p[19];
        let F = C[0], v = C[1], O = C[2], li = C[3], ii = C[4];
        return I[0] = F * o + v * b + O * y + li * M, I[1] = F * G + v * V + O * J + li * Q, I[2] = F * d + v * S + O * N + li * P, I[3] = F * t + v * Y + O * R + li * D, I[4] = F * s + v * T + O * x + li * _ + ii, F = C[5], v = C[6], O = C[7], li = C[8], ii = C[9], I[5] = F * o + v * b + O * y + li * M, I[6] = F * G + v * V + O * J + li * Q, I[7] = F * d + v * S + O * N + li * P, I[8] = F * t + v * Y + O * R + li * D, I[9] = F * s + v * T + O * x + li * _ + ii, F = C[10], v = C[11], O = C[12], li = C[13], ii = C[14], I[10] = F * o + v * b + O * y + li * M, I[11] = F * G + v * V + O * J + li * Q, I[12] = F * d + v * S + O * N + li * P, I[13] = F * t + v * Y + O * R + li * D, I[14] = F * s + v * T + O * x + li * _ + ii, F = C[15], v = C[16], O = C[17], li = C[18], ii = C[19], I[15] = F * o + v * b + O * y + li * M, I[16] = F * G + v * V + O * J + li * Q, I[17] = F * d + v * S + O * N + li * P, I[18] = F * t + v * Y + O * R + li * D, I[19] = F * s + v * T + O * x + li * _ + ii, I;
      }
      function L(p) {
        p = Object(c.clamp)(0, 1, p);
        const C = 0.2126 * p, I = 0.7152 * p, o = 0.0722 * p;
        return [C + 1 - p, I, o, 0, 0, C, I + 1 - p, o, 0, 0, C, I, o + 1 - p, 0, 0, 0, 0, 0, 1, 0];
      }
      function K(p) {
        return [p, 0, 0, 0, 0, 0, p, 0, 0, 0, 0, 0, p, 0, 0, 0, 0, 0, 1, 0];
      }
      function u(p) {
        const C = 0.2126 * (1 - p), I = 0.7152 * (1 - p), o = 0.0722 * (1 - p);
        return [C + p, I, o, 0, 0, C, I + p, o, 0, 0, C, I, o + p, 0, 0, 0, 0, 0, 1, 0];
      }
      function a(p) {
        const C = 0.5 * (1 - p);
        return [p, 0, 0, 0, C, 0, p, 0, 0, C, 0, 0, p, 0, C, 0, 0, 0, 1, 0];
      }
      function e(p) {
        const C = 1 - 2 * p;
        return [C, 0, 0, 0, p, 0, C, 0, 0, p, 0, 0, C, 0, p, 0, 0, 0, 1, 0];
      }
      function r(p) {
        return [1 - 0.607 * p, 0.769 * p, 0.189 * p, 0, 0, 0.349 * p, 1 - 0.314 * p, 0.168 * p, 0, 0, 0.272 * p, 0.534 * p, 1 - 0.869 * p, 0, 0, 0, 0, 0, 1, 0];
      }
      function X(p) {
        return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, p, 0];
      }
      function W(p) {
        const C = p / 180 * Math.PI, I = Math.cos(C), o = Math.sin(C), G = 0.2126, d = 0.7152, t = 0.0722;
        return [G + I * (1 - G) + o * -G, d + I * -d + o * -d, t + I * -t + o * (1 - t), 0, 0, G + I * -G + o * 0.143, d + I * (1 - d) + o * 0.14, t + I * -t + o * -0.283, 0, 0, G + I * -G + o * -(1 - G), d + I * -d + o * d, t + I * (1 - t) + o * t, 0, 0, 0, 0, 0, 1, 0];
      }
    },
    /* 31 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return L;
      });
      var c = i(32), Z = /* @__PURE__ */ i.n(c);
      i(1).glMatrix.setMatrixArrayType(Array);
      function L(K) {
        const u = Z()(K);
        if (!u || !u.length)
          throw new TypeError("Invalid color value.");
        return [u[0] / 255, u[1] / 255, u[2] / 255, u[3]];
      }
    },
    /* 32 */
    /***/
    function(n, l, i) {
      var c = i(33), Z = i(37), L = i(39);
      n.exports = function(u) {
        var a, e = c(u);
        return e.space ? (a = Array(3), a[0] = L(e.values[0], 0, 255), a[1] = L(e.values[1], 0, 255), a[2] = L(e.values[2], 0, 255), e.space[0] === "h" && (a = Z.rgb(a)), a.push(L(e.alpha, 0, 1)), a) : [];
      };
    },
    /* 33 */
    /***/
    function(n, l, i) {
      (function(c) {
        var Z = i(34), L = i(35), K = i(36);
        n.exports = a;
        var u = {
          red: 0,
          orange: 60,
          yellow: 120,
          green: 180,
          blue: 240,
          purple: 300
        };
        function a(e) {
          var r, X = [], W = 1, p;
          if (typeof e == "string")
            if (Z[e])
              X = Z[e].slice(), p = "rgb";
            else if (e === "transparent")
              W = 0, p = "rgb", X = [0, 0, 0];
            else if (/^#[A-Fa-f0-9]+$/.test(e)) {
              var C = e.slice(1), I = C.length, o = I <= 4;
              W = 1, o ? (X = [
                parseInt(C[0] + C[0], 16),
                parseInt(C[1] + C[1], 16),
                parseInt(C[2] + C[2], 16)
              ], I === 4 && (W = parseInt(C[3] + C[3], 16) / 255)) : (X = [
                parseInt(C[0] + C[1], 16),
                parseInt(C[2] + C[3], 16),
                parseInt(C[4] + C[5], 16)
              ], I === 8 && (W = parseInt(C[6] + C[7], 16) / 255)), X[0] || (X[0] = 0), X[1] || (X[1] = 0), X[2] || (X[2] = 0), p = "rgb";
            } else if (r = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(e)) {
              var G = r[1], d = G === "rgb", C = G.replace(/a$/, "");
              p = C;
              var I = C === "cmyk" ? 4 : C === "gray" ? 1 : 3;
              X = r[2].trim().split(/\s*,\s*/).map(function(V, S) {
                if (/%$/.test(V))
                  return S === I ? parseFloat(V) / 100 : C === "rgb" ? parseFloat(V) * 255 / 100 : parseFloat(V);
                if (C[S] === "h") {
                  if (/deg$/.test(V))
                    return parseFloat(V);
                  if (u[V] !== void 0)
                    return u[V];
                }
                return parseFloat(V);
              }), G === C && X.push(1), W = d || X[I] === void 0 ? 1 : X[I], X = X.slice(0, I);
            } else
              e.length > 10 && /[0-9](?:\s|\/)/.test(e) && (X = e.match(/([0-9]+)/g).map(function(s) {
                return parseFloat(s);
              }), p = e.match(/([a-z])/ig).join("").toLowerCase());
          else if (!isNaN(e))
            p = "rgb", X = [e >>> 16, (e & 65280) >>> 8, e & 255];
          else if (L(e)) {
            var t = K(e.r, e.red, e.R, null);
            t !== null ? (p = "rgb", X = [
              t,
              K(e.g, e.green, e.G),
              K(e.b, e.blue, e.B)
            ]) : (p = "hsl", X = [
              K(e.h, e.hue, e.H),
              K(e.s, e.saturation, e.S),
              K(e.l, e.lightness, e.L, e.b, e.brightness)
            ]), W = K(e.a, e.alpha, e.opacity, 1), e.opacity != null && (W /= 100);
          } else
            (Array.isArray(e) || c.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(e)) && (X = [e[0], e[1], e[2]], p = "rgb", W = e.length === 4 ? e[3] : 1);
          return {
            space: p,
            values: X,
            alpha: W
          };
        }
      }).call(this, i(22));
    },
    /* 34 */
    /***/
    function(n, l, i) {
      n.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    },
    /* 35 */
    /***/
    function(n, l, i) {
      var c = Object.prototype.toString;
      n.exports = function(Z) {
        var L;
        return c.call(Z) === "[object Object]" && (L = Object.getPrototypeOf(Z), L === null || L === Object.getPrototypeOf({}));
      };
    },
    /* 36 */
    /***/
    function(n, l) {
      n.exports = function() {
        for (var i = 0; i < arguments.length; i++)
          if (arguments[i] !== void 0)
            return arguments[i];
      };
    },
    /* 37 */
    /***/
    function(n, l, i) {
      var c = i(38);
      n.exports = {
        name: "hsl",
        min: [0, 0, 0],
        max: [360, 100, 100],
        channel: ["hue", "saturation", "lightness"],
        alias: ["HSL"],
        rgb: function(Z) {
          var L = Z[0] / 360, K = Z[1] / 100, u = Z[2] / 100, a, e, r, X, W;
          if (K === 0)
            return W = u * 255, [W, W, W];
          u < 0.5 ? e = u * (1 + K) : e = u + K - u * K, a = 2 * u - e, X = [0, 0, 0];
          for (var p = 0; p < 3; p++)
            r = L + 1 / 3 * -(p - 1), r < 0 ? r++ : r > 1 && r--, 6 * r < 1 ? W = a + (e - a) * 6 * r : 2 * r < 1 ? W = e : 3 * r < 2 ? W = a + (e - a) * (2 / 3 - r) * 6 : W = a, X[p] = W * 255;
          return X;
        }
      }, c.hsl = function(Z) {
        var L = Z[0] / 255, K = Z[1] / 255, u = Z[2] / 255, a = Math.min(L, K, u), e = Math.max(L, K, u), r = e - a, X, W, p;
        return e === a ? X = 0 : L === e ? X = (K - u) / r : K === e ? X = 2 + (u - L) / r : u === e && (X = 4 + (L - K) / r), X = Math.min(X * 60, 360), X < 0 && (X += 360), p = (a + e) / 2, e === a ? W = 0 : p <= 0.5 ? W = r / (e + a) : W = r / (2 - e - a), [X, W * 100, p * 100];
      };
    },
    /* 38 */
    /***/
    function(n, l, i) {
      n.exports = {
        name: "rgb",
        min: [0, 0, 0],
        max: [255, 255, 255],
        channel: ["red", "green", "blue"],
        alias: ["RGB"]
      };
    },
    /* 39 */
    /***/
    function(n, l) {
      n.exports = i;
      function i(c, Z, L) {
        return Z < L ? c < Z ? Z : c > L ? L : c : c < L ? L : c > Z ? Z : c;
      }
    },
    /* 40 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return t;
      });
      var c = i(41), Z = /* @__PURE__ */ i.n(c), L = i(42), K = /* @__PURE__ */ i.n(L), u = i(43), a = /* @__PURE__ */ i.n(u), e = i(44), r = i(46), X = /* @__PURE__ */ i.n(r), W = i(53), p = i(55);
      i(1).glMatrix.setMatrixArrayType(Array);
      const C = Symbol("contours"), I = Symbol("path"), o = Symbol("simplify"), G = Symbol("scale"), d = 2 * Math.PI;
      class t {
        constructor(b = {}) {
          typeof b == "string" && (b = {
            path: b
          }), b.path ? this[I] = Z()(b.path) : this[I] = [], this[C] = null, this[o] = b.simplify != null ? b.simplify : 0, this[G] = b.scale != null ? b.scale : 2;
        }
        get contours() {
          let b = null;
          if (!this[C] && this[I]) {
            const V = Object(e.default)(a()(this[I]));
            this[C] = X()(V, this[G], this[o]), this[C].path = V, this[C].simplify = this[o], this[C].scale = this[G];
          }
          return this[C] && (b = this[C].map((V) => [...V]), b.path = this[C].path, b.simplify = this[C].simplify, b.scale = this[C].scale), b;
        }
        get path() {
          return this[I];
        }
        get simplify() {
          return this[o];
        }
        get boundingBox() {
          const b = this.contours;
          if (b && b.length) {
            const V = b.reduce((S, Y) => [...S, ...Y]);
            return K()(V);
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const b = this.boundingBox;
          return b ? [0.5 * (b[0][0] + b[1][0]), 0.5 * (b[0][1] + b[1][1])] : [0, 0];
        }
        normalize(b = 0, V = 0) {
          const S = Object(e.default)(a()(this[I])).map(([Y, ...T]) => {
            const y = [Y];
            for (let J = 0; J < T.length; J += 2) {
              const N = T[J] - b, R = T[J + 1] - V;
              y.push(N, R);
            }
            return y;
          });
          return this.beginPath(), this[I].push(...S), this;
        }
        getPointAtLength(b) {
          return this.contours ? Object(W.getPointAtLength)(this[C], b) : null;
        }
        getTotalLength() {
          return this.contours ? Object(W.getTotalLength)(this[C]) : 0;
        }
        addPath(b) {
          this[C] = null, typeof b == "string" && (b = Z()(b)), this[I].push(...b);
        }
        beginPath() {
          this[I] = [], this[C] = null;
        }
        clear() {
          this.beginPath();
        }
        ellipse(b, V, S, Y, T, y, J, N = 0) {
          if (y += T, J += T, S <= 0 || Y <= 0 || J === y)
            return;
          J < y && (J = y + d + (J - y) % d), J - y > d && (J = y + d);
          const R = J - y;
          R >= d && (J -= 1e-3);
          let x = this[I].length > 0 && R < d ? "L" : "M";
          const M = Object(p.getPoint)(b, V, S, Y, y), Q = Object(p.getPoint)(b, V, S, Y, J), P = +!N;
          let D = R > Math.PI ? 1 : 0;
          N && (D = 1 - D), x += M.join(" "), x += `A${S} ${Y} 0 ${D} ${P} ${Q.join(" ")}`, R >= d && (x += "Z"), this.addPath(x);
        }
        arc(b, V, S, Y, T, y = 0) {
          return this.ellipse(b, V, S, S, 0, Y, T, y);
        }
        arcTo(b, V, S, Y, T, y, J) {
          this[C] = null, this[I].push(["A", b, V, S, Y, T, y, J]);
        }
        moveTo(b, V) {
          this[C] = null, this[I].push(["M", b, V]);
        }
        lineTo(b, V) {
          this[C] = null, this[I].push(["L", b, V]);
        }
        bezierCurveTo(b, V, S, Y, T, y) {
          this[C] = null, this[I].push(["C", b, V, S, Y, T, y]);
        }
        quadraticCurveTo(b, V, S, Y) {
          this[C] = null, this[I].push(["Q", b, V, S, Y]);
        }
        rect(b, V, S, Y) {
          const T = `M${b} ${V}L${b + S} ${V}L${b + S} ${V + Y}L${b} ${V + Y}Z`;
          this.addPath(T);
        }
        closePath() {
          this[C] = null;
          let b = [];
          const V = this[I].length;
          V > 0 && (b = this[I][V - 1]), b[0] !== "Z" && b[0] !== "z" && this[I].push(["Z"]);
        }
      }
    },
    /* 41 */
    /***/
    function(n, l) {
      n.exports = Z;
      var i = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, c = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function Z(u) {
        var a = [];
        return u.replace(c, function(e, r, X) {
          var W = r.toLowerCase();
          for (X = K(X), W == "m" && X.length > 2 && (a.push([r].concat(X.splice(0, 2))), W = "l", r = r == "m" ? "l" : "L"); ; ) {
            if (X.length == i[W])
              return X.unshift(r), a.push(X);
            if (X.length < i[W])
              throw new Error("malformed path data");
            a.push([r].concat(X.splice(0, i[W])));
          }
        }), a;
      }
      var L = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function K(u) {
        var a = u.match(L);
        return a ? a.map(Number) : [];
      }
    },
    /* 42 */
    /***/
    function(n, l, i) {
      n.exports = c;
      function c(Z) {
        var L = Z.length;
        if (L === 0)
          return [[], []];
        for (var K = Z[0].length, u = Z[0].slice(), a = Z[0].slice(), e = 1; e < L; ++e)
          for (var r = Z[e], X = 0; X < K; ++X) {
            var W = r[X];
            u[X] = Math.min(u[X], W), a[X] = Math.max(a[X], W);
          }
        return [u, a];
      }
    },
    /* 43 */
    /***/
    function(n, l) {
      n.exports = i;
      function i(c) {
        var Z = 0, L = 0, K = 0, u = 0;
        return c.map(function(a) {
          a = a.slice();
          var e = a[0], r = e.toUpperCase();
          if (e != r)
            switch (a[0] = r, e) {
              case "a":
                a[6] += K, a[7] += u;
                break;
              case "v":
                a[1] += u;
                break;
              case "h":
                a[1] += K;
                break;
              default:
                for (var X = 1; X < a.length; )
                  a[X++] += K, a[X++] += u;
            }
          switch (r) {
            case "Z":
              K = Z, u = L;
              break;
            case "H":
              K = a[1];
              break;
            case "V":
              u = a[1];
              break;
            case "M":
              K = Z = a[1], u = L = a[2];
              break;
            default:
              K = a[a.length - 2], u = a[a.length - 1];
          }
          return a;
        });
      }
    },
    /* 44 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return Z;
      });
      var c = i(45);
      i(1).glMatrix.setMatrixArrayType(Array);
      function Z(u) {
        for (var a, e = [], r = 0, X = 0, W = 0, p = 0, C = null, I = null, o = 0, G = 0, d = 0, t = u.length; d < t; d++) {
          var s = u[d], b = s[0];
          switch (b) {
            case "M":
              W = s[1], p = s[2];
              break;
            case "A":
              var V = Object(c.default)(o, G, s[6], s[7], s[4], s[5], s[1], s[2], s[3]);
              if (!V.length)
                continue;
              V = V.map((J) => {
                const [N, R, x, M, Q, P, D, _] = J;
                return {
                  x1: x,
                  y1: M,
                  x2: Q,
                  y2: P,
                  x: D,
                  y: _
                };
              });
              for (var S = 0, Y; S < V.length; S++)
                Y = V[S], s = ["C", Y.x1, Y.y1, Y.x2, Y.y2, Y.x, Y.y], S < V.length - 1 && e.push(s);
              break;
            case "S":
              var T = o, y = G;
              (a == "C" || a == "S") && (T += T - r, y += y - X), s = ["C", T, y, s[1], s[2], s[3], s[4]];
              break;
            case "T":
              a == "Q" || a == "T" ? (C = o * 2 - C, I = G * 2 - I) : (C = o, I = G), s = K(o, G, C, I, s[1], s[2]);
              break;
            case "Q":
              C = s[1], I = s[2], s = K(o, G, s[1], s[2], s[3], s[4]);
              break;
            case "L":
              s = L(o, G, s[1], s[2]);
              break;
            case "H":
              s = L(o, G, s[1], G);
              break;
            case "V":
              s = L(o, G, o, s[1]);
              break;
            case "Z":
              s = L(o, G, W, p);
              break;
          }
          a = b, o = s[s.length - 2], G = s[s.length - 1], s.length > 4 ? (r = s[s.length - 4], X = s[s.length - 3]) : (r = o, X = G), e.push(s);
        }
        return e;
      }
      function L(u, a, e, r) {
        return ["C", u, a, e, r, e, r];
      }
      function K(u, a, e, r, X, W) {
        return ["C", u / 3 + 2 / 3 * e, a / 3 + 2 / 3 * r, X / 3 + 2 / 3 * e, W / 3 + 2 / 3 * r, X, W];
      }
    },
    /* 45 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const c = Math.PI * 2;
      function Z(a, e, r, X) {
        const W = a * X - e * r < 0 ? -1 : 1;
        let p = a * r + e * X;
        return p > 1 && (p = 1), p < -1 && (p = -1), W * Math.acos(p);
      }
      function L(a, e, r, X, W, p, C, I, o, G) {
        const d = G * (a - r) / 2 + o * (e - X) / 2, t = -o * (a - r) / 2 + G * (e - X) / 2, s = C * C, b = I * I, V = d * d, S = t * t;
        let Y = s * b - s * S - b * V;
        Y < 0 && (Y = 0), Y /= s * S + b * V, Y = Math.sqrt(Y) * (W === p ? -1 : 1);
        const T = Y * C / I * t, y = Y * -I / C * d, J = G * T - o * y + (a + r) / 2, N = o * T + G * y + (e + X) / 2, R = (d - T) / C, x = (t - y) / I, M = (-d - T) / C, Q = (-t - y) / I, P = Z(1, 0, R, x);
        let D = Z(R, x, M, Q);
        return p === 0 && D > 0 && (D -= c), p === 1 && D < 0 && (D += c), [J, N, P, D];
      }
      function K(a, e) {
        const r = 1.3333333333333333 * Math.tan(e / 4), X = Math.cos(a), W = Math.sin(a), p = Math.cos(a + e), C = Math.sin(a + e);
        return [X, W, X - W * r, W + X * r, p + C * r, C - p * r, p, C];
      }
      function u(a, e, r, X, W, p, C, I, o) {
        const G = Math.sin(o * c / 360), d = Math.cos(o * c / 360), t = d * (a - r) / 2 + G * (e - X) / 2, s = -G * (a - r) / 2 + d * (e - X) / 2;
        if (t === 0 && s === 0)
          return [];
        if (C === 0 || I === 0)
          return [];
        C = Math.abs(C), I = Math.abs(I);
        const b = t * t / (C * C) + s * s / (I * I);
        b > 1 && (C *= Math.sqrt(b), I *= Math.sqrt(b));
        const V = L(a, e, r, X, W, p, C, I, G, d), S = [];
        let Y = V[2], T = V[3];
        const y = Math.max(Math.ceil(Math.abs(T) / (c / 4)), 1);
        T /= y;
        for (let J = 0; J < y; J++)
          S.push(K(Y, T)), Y += T;
        return S.map((J) => {
          for (let N = 0; N < J.length; N += 2) {
            let R = J[N + 0], x = J[N + 1];
            R *= C, x *= I;
            const M = d * R - G * x, Q = G * R + d * x;
            J[N + 0] = M + V[0], J[N + 1] = Q + V[1];
          }
          return J;
        });
      }
    },
    /* 46 */
    /***/
    function(n, l, i) {
      i(1).glMatrix.setMatrixArrayType(Array);
      var c = i(47), {
        copy: Z
      } = i(49), L = i(50);
      function K(X, W, p) {
        return X[0] = W, X[1] = p, X;
      }
      var u = [0, 0], a = [0, 0], e = [0, 0];
      function r(X, W, p, C) {
        c(p, K(u, C[1], C[2]), K(a, C[3], C[4]), K(e, C[5], C[6]), W, X);
      }
      n.exports = function(W, p, C) {
        var I = [], o = [], G = [0, 0];
        return W.forEach(function(d, t, s) {
          if (d[0] === "M")
            Z(G, d.slice(1)), o.length > 0 && (I.push(o), o = []);
          else if (d[0] === "C")
            r(o, p, G, d), K(G, d[5], d[6]);
          else
            throw new Error("illegal type in SVG: " + d[0]);
        }), o.length > 0 && I.push(o), I.map(function(d) {
          return L(d, C || 0);
        });
      };
    },
    /* 47 */
    /***/
    function(n, l, i) {
      n.exports = i(48)();
    },
    /* 48 */
    /***/
    function(n, l) {
      function i(Z) {
        return [Z[0], Z[1]];
      }
      function c(Z, L) {
        return [Z, L];
      }
      n.exports = function(L) {
        L = L || {};
        var K = typeof L.recursion == "number" ? L.recursion : 8, u = typeof L.epsilon == "number" ? L.epsilon : 11920929e-14, a = typeof L.pathEpsilon == "number" ? L.pathEpsilon : 1, e = typeof L.angleEpsilon == "number" ? L.angleEpsilon : 0.01, r = L.angleTolerance || 0, X = L.cuspLimit || 0;
        return function(I, o, G, d, t, s) {
          s || (s = []), t = typeof t == "number" ? t : 1;
          var b = a / t;
          return b *= b, W(I, o, G, d, s, b), s;
        };
        function W(C, I, o, G, d, t) {
          d.push(i(C));
          var s = C[0], b = C[1], V = I[0], S = I[1], Y = o[0], T = o[1], y = G[0], J = G[1];
          p(s, b, V, S, Y, T, y, J, d, t, 0), d.push(i(G));
        }
        function p(C, I, o, G, d, t, s, b, V, S, Y) {
          if (!(Y > K)) {
            var T = Math.PI, y = (C + o) / 2, J = (I + G) / 2, N = (o + d) / 2, R = (G + t) / 2, x = (d + s) / 2, M = (t + b) / 2, Q = (y + N) / 2, P = (J + R) / 2, D = (N + x) / 2, _ = (R + M) / 2, F = (Q + D) / 2, v = (P + _) / 2;
            if (Y > 0) {
              var O = s - C, li = b - I, ii = Math.abs((o - s) * li - (G - b) * O), ti = Math.abs((d - s) * li - (t - b) * O), $, ai;
              if (ii > u && ti > u) {
                if ((ii + ti) * (ii + ti) <= S * (O * O + li * li)) {
                  if (r < e) {
                    V.push(c(F, v));
                    return;
                  }
                  var Xi = Math.atan2(t - G, d - o);
                  if ($ = Math.abs(Xi - Math.atan2(G - I, o - C)), ai = Math.abs(Math.atan2(b - t, s - d) - Xi), $ >= T && ($ = 2 * T - $), ai >= T && (ai = 2 * T - ai), $ + ai < r) {
                    V.push(c(F, v));
                    return;
                  }
                  if (X !== 0) {
                    if ($ > X) {
                      V.push(c(o, G));
                      return;
                    }
                    if (ai > X) {
                      V.push(c(d, t));
                      return;
                    }
                  }
                }
              } else if (ii > u) {
                if (ii * ii <= S * (O * O + li * li)) {
                  if (r < e) {
                    V.push(c(F, v));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(t - G, d - o) - Math.atan2(G - I, o - C)), $ >= T && ($ = 2 * T - $), $ < r) {
                    V.push(c(o, G)), V.push(c(d, t));
                    return;
                  }
                  if (X !== 0 && $ > X) {
                    V.push(c(o, G));
                    return;
                  }
                }
              } else if (ti > u) {
                if (ti * ti <= S * (O * O + li * li)) {
                  if (r < e) {
                    V.push(c(F, v));
                    return;
                  }
                  if ($ = Math.abs(Math.atan2(b - t, s - d) - Math.atan2(t - G, d - o)), $ >= T && ($ = 2 * T - $), $ < r) {
                    V.push(c(o, G)), V.push(c(d, t));
                    return;
                  }
                  if (X !== 0 && $ > X) {
                    V.push(c(d, t));
                    return;
                  }
                }
              } else if (O = F - (C + s) / 2, li = v - (I + b) / 2, O * O + li * li <= S) {
                V.push(c(F, v));
                return;
              }
            }
            p(C, I, y, J, Q, P, F, v, V, S, Y + 1), p(F, v, D, _, x, M, s, b, V, S, Y + 1);
          }
        }
      };
    },
    /* 49 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "create", function() {
        return L;
      }), i.d(l, "clone", function() {
        return Z;
      }), i.d(l, "copy", function() {
        return K;
      }), i.d(l, "scaleAndAdd", function() {
        return u;
      }), i.d(l, "dot", function() {
        return a;
      }), i.d(l, "rotate", function() {
        return e;
      }), i.d(l, "cross", function() {
        return r;
      }), i.d(l, "sub", function() {
        return X;
      }), i.d(l, "add", function() {
        return W;
      }), i.d(l, "computeMiter", function() {
        return o;
      }), i.d(l, "normal", function() {
        return G;
      }), i.d(l, "direction", function() {
        return d;
      });
      var c = i(1);
      i(1).glMatrix.setMatrixArrayType(Array);
      function Z(t) {
        return [t[0], t[1]];
      }
      function L() {
        return [0, 0];
      }
      const K = c.vec2.copy, u = c.vec2.scaleAndAdd, a = c.vec2.dot, e = c.vec2.rotate, r = c.vec2.cross, X = c.vec2.sub, W = c.vec2.add, p = c.vec2.normalize, C = c.vec2.set, I = L();
      function o(t, s, b, V, S) {
        W(t, b, V), p(t, t), C(s, -t[1], t[0]), C(I, -b[1], b[0]);
        const Y = S / a(s, I);
        return Math.abs(Y);
      }
      function G(t, s) {
        return C(t, -s[1], s[0]), t;
      }
      function d(t, s, b) {
        return X(t, s, b), p(t, t), t;
      }
    },
    /* 50 */
    /***/
    function(n, l, i) {
      var c = i(51), Z = i(52);
      n.exports = function(K, u) {
        return K = c(K, u), K = Z(K, u), K;
      }, n.exports.radialDistance = c, n.exports.douglasPeucker = Z;
    },
    /* 51 */
    /***/
    function(n, l) {
      function i(c, Z) {
        var L = c[0] - Z[0], K = c[1] - Z[1];
        return L * L + K * K;
      }
      n.exports = function(Z, L) {
        if (Z.length <= 1)
          return Z;
        L = typeof L == "number" ? L : 1;
        for (var K = L * L, u = Z[0], a = [u], e, r = 1, X = Z.length; r < X; r++)
          e = Z[r], i(e, u) > K && (a.push(e), u = e);
        return u !== e && a.push(e), a;
      };
    },
    /* 52 */
    /***/
    function(n, l) {
      function i(Z, L, K) {
        var u = L[0], a = L[1], e = K[0] - u, r = K[1] - a;
        if (e !== 0 || r !== 0) {
          var X = ((Z[0] - u) * e + (Z[1] - a) * r) / (e * e + r * r);
          X > 1 ? (u = K[0], a = K[1]) : X > 0 && (u += e * X, a += r * X);
        }
        return e = Z[0] - u, r = Z[1] - a, e * e + r * r;
      }
      function c(Z, L, K, u, a) {
        for (var e = u, r, X = L + 1; X < K; X++) {
          var W = i(Z[X], Z[L], Z[K]);
          W > e && (r = X, e = W);
        }
        e > u && (r - L > 1 && c(Z, L, r, u, a), a.push(Z[r]), K - r > 1 && c(Z, r, K, u, a));
      }
      n.exports = function(L, K) {
        if (L.length <= 1)
          return L;
        K = typeof K == "number" ? K : 1;
        var u = K * K, a = L.length - 1, e = [L[0]];
        return c(L, 0, a, u, e), e.push(L[a]), e;
      };
    },
    /* 53 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "getTotalLength", function() {
        return Z;
      }), i.d(l, "getPointAtLength", function() {
        return K;
      }), i.d(l, "getDashContours", function() {
        return u;
      });
      var c = i(54);
      i(1).glMatrix.setMatrixArrayType(Array);
      function Z(a) {
        if (a.totalLength != null)
          return a.totalLength;
        let e = 0;
        return a.forEach((r) => {
          let X = r[0];
          for (let W = 1; W < r.length; W++) {
            const p = r[W];
            e += Object(c.distance)(X, p), X = p;
          }
        }), a.totalLength = e, e;
      }
      function L(a, e, r = !0) {
        if (e = Number(e), !Number.isFinite(e))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (e <= 0)
          throw new TypeError("Length must > 0");
        const X = Z(a);
        if (e >= X) {
          const p = a[a.length - 1], C = p[p.length - 2], I = p[p.length - 1], o = Math.atan2(I[1] - C[1], I[0] - C[0]);
          return {
            current: a.map((G) => [...G]),
            point: {
              x: I[0],
              y: I[1],
              angle: o
            }
          };
        }
        const W = [];
        for (let p = 0; p < a.length; p++) {
          W[p] = [];
          const C = a[p];
          let I = C[0];
          for (let o = 1; o < C.length; o++) {
            const G = C[o], d = Object(c.distance)(I, G);
            if (e < d) {
              const t = e / d, s = Math.atan2(G[1] - I[1], G[0] - I[0]), b = {
                x: I[0] * (1 - t) + G[0] * t,
                y: I[1] * (1 - t) + G[1] * t,
                angle: s
              };
              if (W[p].push(I), e > 0 && W[p].push([b.x, b.y]), !r)
                return {
                  current: W,
                  point: b
                };
              const V = [], S = p;
              for (; p < a.length; p++) {
                for (V[p - S] = [], p === S && V[0].push([b.x, b.y]); o < C.length; o++)
                  V[p - S].push(C[o]);
                o = 0;
              }
              return {
                current: W,
                point: b,
                rest: V
              };
            }
            e -= d, W[p].push(I), I = G;
          }
        }
      }
      function K(a, e) {
        if (e = Number(e), !Number.isFinite(e))
          throw new TypeError("Failed to execute 'getPointAtLength' on figure: The provided float value is non-finite.");
        if (a.length <= 0)
          return {
            x: 0,
            y: 0,
            angle: 0
          };
        if (e <= 0) {
          const r = a[0][0], X = a[0][1], W = Math.atan2(X[1] - r[1], X[0] - r[0]);
          return {
            x: r[0],
            y: r[1],
            angle: W
          };
        }
        return L(a, e, !1).point;
      }
      function u(a, e, r) {
        let X = 0, W = e[0], p = a;
        const C = [], I = e.length;
        if (r > 0) {
          do
            r -= e[X % I], X++;
          while (r > 0);
          r < 0 && (W = -r, X--);
        } else if (r < 0) {
          X = -1;
          do
            r += e[X % I + I - 1], X--;
          while (r < 0);
          r >= 0 && (X++, W = e[X % I + I - 1] - r);
        }
        do {
          const o = L(p, W);
          p = o.rest, ++X % 2 && C.push(...o.current);
          let G = X % I;
          G < 0 && (G += I), W = e[G];
        } while (p);
        return C;
      }
    },
    /* 54 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "normalize", function() {
        return c;
      }), i.d(l, "distance", function() {
        return Z;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c([L, K, u], a, e, r) {
        return L = L * 2 / a - 1, K = 1 - K * 2 / e, Number.isFinite(r) ? (u = u * 2 / r - 1, [L, K, u]) : [L, K];
      }
      function Z([L, K, u = 0], [a, e, r = 0]) {
        return Math.hypot(a - L, e - K, r - u);
      }
    },
    /* 55 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "getPoint", function() {
        return Z;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const c = Math.PI * 2;
      function Z(L, K, u, a, e) {
        e %= c, e < 0 && (e += c);
        const r = Math.tan(e);
        if (Math.abs(r) < 1e5) {
          const X = K - r * L, W = 1 / u ** 2 + r ** 2 / a ** 2;
          let p = -1;
          (e <= Math.PI / 2 || e > 3 * Math.PI / 2) && (p = 1);
          const C = p * Math.sqrt(1 / W) + L, I = r * C + X;
          return [C, I];
        }
        return e < Math.PI ? [L, K + a] : [L, K - a];
      }
    },
    /* 56 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return j;
      });
      var c = i(1), Z = i(42), L = /* @__PURE__ */ i.n(Z), K = i(57), u = i(28), a = i(24), e = i(30), r = i(59), X = i(53), W = i(60), p = /* @__PURE__ */ i.n(W), C = i(46), I = /* @__PURE__ */ i.n(C), o = i(31), G = i(40), d = i(21);
      i(1).glMatrix.setMatrixArrayType(Array);
      function t(A, H) {
        if (A == null)
          return {};
        var U = s(A, H), m, h;
        if (Object.getOwnPropertySymbols) {
          var g = Object.getOwnPropertySymbols(A);
          for (h = 0; h < g.length; h++)
            m = g[h], !(H.indexOf(m) >= 0) && Object.prototype.propertyIsEnumerable.call(A, m) && (U[m] = A[m]);
        }
        return U;
      }
      function s(A, H) {
        if (A == null)
          return {};
        var U = {}, m = Object.keys(A), h, g;
        for (g = 0; g < m.length; g++)
          h = m[g], !(H.indexOf(h) >= 0) && (U[h] = A[h]);
        return U;
      }
      const b = Symbol("mesh"), V = Symbol("contours"), S = Symbol("stroke"), Y = Symbol("fill"), T = Symbol("strokeColor"), y = Symbol("fillColor"), J = Symbol("transform"), N = Symbol("invertTransform"), R = Symbol("uniforms"), x = Symbol("texOptions"), M = Symbol("blend"), Q = Symbol("applyTexture"), P = Symbol("applyTransform"), D = Symbol("applyGradientTransform"), _ = Symbol("applyProgram"), F = Symbol("gradient"), v = Symbol("filter"), O = Symbol("opacity"), li = Symbol("program"), ii = Symbol("attributes"), ti = Symbol("pass"), $ = Symbol("clipContext"), ai = Symbol("applyClipPath");
      function Xi(A, H) {
        const [U, m] = [A[1][0] - A[0][0], A[1][1] - A[0][1]], h = [];
        for (let g = 0; g < H.length; g++) {
          const f = H[g], w = [(f[0] - A[0][0]) / U, 1 - (f[1] - A[0][1]) / m];
          h.push(w);
        }
        return h;
      }
      function z([A, H], [U, m, h, g], {
        scale: f
      }) {
        return f || (A /= h, H = 1 - H / g, A -= U, H += m), [A, H, 0];
      }
      function k(A, H, U) {
        const m = I()(A, H, U);
        return m.path = A, m.simplify = U, m.scale = H, m;
      }
      class j {
        constructor(H) {
          this[S] = null, this[Y] = null, this[J] = [1, 0, 0, 1, 0, 0], this[O] = 1, this[R] = {}, this[v] = [], this[M] = null, this[x] = {}, this.contours = H.contours, this[li] = null, this[ii] = {}, this[ti] = [];
        }
        get contours() {
          return this[V];
        }
        set contours(H) {
          this[b] = null, this[V] = H;
          const U = H.scale;
          this.transformScale / U > 1.5 && this.accurate(this.transformScale);
        }
        setProgram(H) {
          this[li] = H, this[b] && this[_](H);
        }
        get program() {
          return this[li];
        }
        setAttribute(H, U) {
          U == null ? delete this[ii][H] : this[ii][H] = U;
        }
        getOpacity() {
          return this[O];
        }
        setOpacity(H) {
          if (H < 0 || H > 1)
            throw new TypeError("Invalid opacity value.");
          this[b] && this[b].positions.forEach((U) => {
            U[2] = 1 / U[2] > 0 ? H : -H;
          }), this[O] = H;
        }
        setClipPath(H) {
          this.clipPath = H, this[R].u_clipSampler && this[R].u_clipSampler.delete(), this.setUniforms({
            u_clipSampler: null
          }), this[b] && delete this[b].attributes.a_clipUV, H && this[b] && this[ai]();
        }
        [ai]() {
          if (this.clipPath) {
            this[$] || (this[$] = d.default.createCanvas(1, 1));
            const [[H, U], [m, h]] = this.boundingBox;
            m && h && (this[$].width = m - H, this[$].height = h - U);
            const g = this[$].getContext("2d"), f = new Path2D(this.clipPath);
            g.clearRect(0, 0, this[$].width, this[$].height), g.save(), g.translate(-H, -U), g.fillStyle = "white", g.fill(f), g.restore(), this[b].clipPath = this[$];
            const w = Xi(this.boundingBox, this[b].position0);
            this[b].attributes.a_clipUV = w;
          }
        }
        getPointAtLength(H) {
          return Object(X.getPointAtLength)(this[V], H);
        }
        getTotalLength() {
          return Object(X.getTotalLength)(this[V]);
        }
        get blend() {
          return this[M] == null ? "auto" : this[M];
        }
        set blend(H) {
          this[M] = H, this[b] && (this[b].enableBlend = this.enableBlend);
        }
        get boundingBox() {
          if (this[b] && this[b].boundingBox)
            return this[b].boundingBox;
          const H = this.meshData;
          if (H) {
            const U = H.position0;
            if (U.length)
              H.boundingBox = L()(U);
            else
              return [[0, 0], [0, 0]];
            return H.boundingBox;
          }
          return [[0, 0], [0, 0]];
        }
        get boundingCenter() {
          const H = this.boundingBox;
          return H ? [0.5 * (H[0][0] + H[1][0]), 0.5 * (H[0][1] + H[1][1])] : [0, 0];
        }
        get fillRule() {
          return this[Y] ? this[Y].rule : "nonzero";
        }
        get lineWidth() {
          return this[S] ? this[S].lineWidth : 0;
        }
        get lineCap() {
          return this[S] ? this[S].lineCap : "";
        }
        get lineJoin() {
          return this[S] ? this[S].lineJoin : "";
        }
        get miterLimit() {
          return this[S] ? this[S].miterLimit : 0;
        }
        get strokeStyle() {
          return this[T] && this[T][3] !== 0 ? Object(a.default)(this[T]) : "";
        }
        get lineDash() {
          return this[S] ? this[S].lineDash : null;
        }
        get lineDashOffset() {
          return this[S] ? this[S].lineDashOffset : 0;
        }
        get fillStyle() {
          return this[y] && this[y][3] !== 0 ? Object(a.default)(this[y]) : "";
        }
        get gradient() {
          return this[F];
        }
        get texture() {
          return this[R].u_texSampler ? {
            image: this[R].u_texSampler._img,
            options: this[x]
          } : null;
        }
        get enableBlend() {
          return this[M] === !0 || this[M] === !1 ? this[M] : this[O] < 1 || this[T] != null && this[T][3] < 1 || this[y] != null && this[y][3] < 1 || this[R].u_colorMatrix != null && this[R].u_colorMatrix[18] < 1 || this[R].u_radialGradientVector != null || this.beforeRender || this.afterRender;
        }
        get filterCanvas() {
          return /blur|drop-shadow|url/.test(this.filter);
        }
        get filter() {
          return this[v].join(" ");
        }
        get transformMatrix() {
          return this[J];
        }
        get invertMatrix() {
          if (!this[N]) {
            const H = c.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this[J]);
            this[N] = H;
          }
          return this[N];
        }
        get transformScale() {
          const H = this[J];
          return Math.max(Math.hypot(H[0], H[1]), Math.hypot(H[2], H[3]));
        }
        get uniforms() {
          return this[R];
        }
        get pass() {
          return this[ti];
        }
        [_](H) {
          const U = this[ii], m = this[b].position0, h = Object.entries(H._attribute);
          for (let g = 0; g < h.length; g++) {
            const [f, w] = h[g];
            if (f !== "a_color" && f !== "a_sourceRect" && w !== "ignored") {
              const B = U[f];
              if (f === "uv" && !B) {
                const q = this[b].boundingBox || L()(m);
                this[b].attributes[f] = Xi(q, m);
              } else {
                this[b].attributes[f] = [];
                for (let q = 0; q < m.length; q++) {
                  const si = m[q];
                  this[b].attributes[f].push(B ? B(si, g, m) : Array(w.size).fill(0));
                }
              }
            }
          }
        }
        // {stroke, fill}
        get meshData() {
          if (this._updateMatrix && this.transformScale / this.contours.scale > 1.5 && this.accurate(this.transformScale), !this[b]) {
            !this[Y] && !this[S] && this.setFill();
            const H = this[V], U = {};
            if (H && H.length) {
              if (this[Y])
                try {
                  const g = p()(H, this[Y]);
                  g.positions = g.positions.map((f) => (f.push(this[O]), f)), g.attributes = {
                    a_color: Array.from({
                      length: g.positions.length
                    }).map(() => this[y].map((f) => Math.round(255 * f)))
                    // a_sourceRect: Array.from({length: mesh.positions.length}).map(() => [0, 0, 0, 0]),
                  }, U.fill = g;
                } catch {
                }
              if (this[S]) {
                const g = this[S].lineDash;
                let f = H;
                if (g) {
                  const B = this[S].lineDashOffset;
                  f = Object(X.getDashContours)(H, g, B);
                }
                const w = f.map((B, q) => {
                  const si = B.length > 1 && c.vec2.equals(B[0], B[B.length - 1]), bi = this[S].build(B, si);
                  return p()([bi]);
                });
                w.forEach((B) => {
                  B.positions = B.positions.map((q) => (q.push(-this[O]), q)), B.attributes = {
                    a_color: Array.from({
                      length: B.positions.length
                    }).map(() => this[T].map((q) => Math.round(255 * q)))
                  };
                }), U.stroke = Object(u.default)(w);
              }
            }
            const m = Object(u.default)([U.fill, U.stroke]);
            m.fillPointCount = U.fill ? U.fill.positions.length : 0, m.enableBlend = this.enableBlend, m.position0 = m.positions.map(([g, f, w]) => [g, f, w]), m.uniforms = this[R], this[b] = m, this[R].u_texSampler && this[Q](m, this[x]);
            const h = this[J];
            Object(r.isUnitTransform)(h) || (this[P](m, h), this[R].u_radialGradientVector && this[D]()), this.clipPath && this[ai](), this[li] && this[_](this[li]);
          }
          return this._updateMatrix && (this[b].matrix = this[J], this[P](this[b], this[J]), this[R].u_radialGradientVector && this[D]()), this[b];
        }
        [P](H, U) {
          const {
            positions: m,
            position0: h
          } = H;
          for (let g = 0; g < m.length; g++) {
            const [f, w] = h[g], B = m[g];
            B[0] = f * U[0] + w * U[2] + U[4], B[1] = f * U[1] + w * U[3] + U[5];
          }
          this._updateMatrix = !1;
        }
        [D]() {
          const H = this[J], U = [...this._radialGradientVector];
          if (U) {
            const [m, h, , g, f] = U;
            U[0] = m * H[0] + h * H[2] + H[4], U[1] = m * H[1] + h * H[3] + H[5], U[3] = g * H[0] + f * H[2] + H[4], U[4] = g * H[1] + f * H[3] + H[5], this[R].u_radialGradientVector = U;
          }
        }
        [Q](H, U) {
          function m(q, si) {
            return q == null && si == null ? !0 : q == null || si == null ? !1 : q[0] === si[0] && q[1] === si[1] && q[2] === si[2] && q[3] === si[3];
          }
          const h = this[R].u_texSampler;
          if (!h)
            return;
          const {
            width: g,
            height: f
          } = h._img, w = U.srcRect;
          let B = U.rect || [0, 0];
          if (U.rotated && (B = [-B[1], B[0], B[3], B[2]]), B[2] == null && (B[2] = w ? w[2] : g), B[3] == null && (B[3] = w ? w[3] : f), U.hidden)
            H.textureCoord = H.positions.map(() => [-1, -1, -1]);
          else if (!H.textureCoord || !m(this[x].rect, U.rect) || this[x].hidden !== U.hidden || this[x].rotated !== U.rotated) {
            let q = null;
            U.rotated && (q = c.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), c.mat2d.fromValues(1, 0, 0, 1, 0, 0), 0.5 * Math.PI), q = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), q, [0, -B[2]])), H.textureCoord = H.position0.map(([si, bi, Zi]) => {
              if (1 / Zi > 0) {
                if (U.rotated) {
                  const mi = si * q[0] + bi * q[2] + q[4], ci = si * q[1] + bi * q[3] + q[5];
                  [si, bi] = [mi, ci];
                }
                const oi = z([si, bi], [B[0] / B[2], B[1] / B[3], B[2], B[3]], U);
                return U.repeat && (oi[2] = 1), oi;
              }
              return [-1, -1, -1];
            });
          }
          if (w) {
            const q = [w[0] / g, w[1] / f, w[2] / g, w[3] / f];
            H.attributes.a_sourceRect = H.positions.map(() => [...q]);
          } else
            H.attributes.a_sourceRect = H.positions.map(() => [0, 0, 0, 0]);
        }
        accurate(H) {
          if (!this.contours)
            return;
          if (this.contours.path) {
            const m = this.contours.simplify, h = k(this.contours.path, 2 * H, m);
            this[b] = null, this[V] = h;
          }
        }
        canIgnore() {
          const H = this[S] == null || this[S].lineWidth === 0 || this[T][3] === 0, U = this[Y] == null || this[y][3] === 0, m = this[R].u_radialGradientVector == null, h = this[R].u_texSampler == null;
          return this[O] === 0 || this[li] == null && H && U && m && h && !this.beforeRender && !this.afterRender;
        }
        // join: 'miter' or 'bevel'
        // cap: 'butt' or 'square'
        // lineDash: null
        // lineDashOffset: 0
        setStroke({
          thickness: H = 1,
          cap: U = "butt",
          join: m = "miter",
          miterLimit: h = 10,
          color: g = [0, 0, 0, 0],
          lineDash: f = null,
          lineDashOffset: w = 0,
          roundSegments: B = 20
        } = {}) {
          return this[b] = null, this[S] = new K.default({
            lineWidth: H,
            lineCap: U,
            lineJoin: m,
            miterLimit: h,
            roundSegments: B
          }), typeof g == "string" && (g = Object(o.default)(g)), this[T] = g, this[S].lineDash = f, this[S].lineDashOffset = w, this;
        }
        setFill({
          rule: H = this.fillRule,
          color: U = [0, 0, 0, 0]
        } = {}) {
          return this[b] = null, this[Y] = {
            rule: H
          }, typeof U == "string" && (U = Object(o.default)(U)), this[y] = U, this;
        }
        /**
          options: {
            scale: false,
            repeat: false,
            rotated: false,
            rect: [10, 10],
            srcRect: [...],
            hidden: false,
          }
         */
        setTexture(H, U = {}) {
          if (H && H.image) {
            const {
              image: m,
              rect: h
            } = H;
            if (H = m, U.rect)
              for (let g = 0; g < U.rect.length; g++)
                h[g] = U.rect[g];
            U.rect = h;
          }
          return this[Y] || this.setFill(), this.setUniforms({
            u_texSampler: H
          }), this[b] && this[Q](this[b], U), this[x] = U, this;
        }
        setCircularGradient({
          vector: H,
          colors: U,
          type: m = "fill"
        } = {}) {
          if (H.length !== 3)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: H,
            colors: U,
            type: m
          });
        }
        setLinearGradient({
          vector: H,
          colors: U,
          type: m = "fill"
        } = {}) {
          if (H.length !== 4)
            throw new TypeError("Invalid linearGradient.");
          this.setGradient({
            vector: H,
            colors: U,
            type: m
          });
        }
        setRadialGradient({
          vector: H,
          colors: U,
          type: m = "fill"
        } = {}) {
          if (H.length !== 6)
            throw new TypeError("Invalid radialGradient.");
          this.setGradient({
            vector: H,
            colors: U,
            type: m
          });
        }
        /**
          vector: [x0, y0, r0, x1, y1, r1],
          colors: [{offset:0, color}, {offset:1, color}, ...],
         */
        setGradient({
          vector: H,
          colors: U,
          type: m = "fill"
        } = {}) {
          U = U.map(({
            offset: f,
            color: w
          }) => (typeof w == "string" && (w = Object(o.default)(w)), {
            offset: f,
            color: w
          })), this[F] = this[F] || {}, this[F][m] = {
            vector: H,
            colors: U
          }, U.sort((f, w) => f.offset - w.offset);
          const h = [];
          U.forEach(({
            offset: f,
            color: w
          }) => {
            h.push(f, ...w);
          });
          let g;
          if (H.length === 4 ? g = [H[0], H[1], 0, H[2], H[3], 0] : g = [...H], h.length < 40 && h.push(-1), h.length > 40)
            throw new Error("Too many colors, should be less than 8 colors");
          return this._radialGradientVector = g, this[R].u_colorSteps = h, m === "fill" ? this[R].u_gradientType = 1 : this[R].u_gradientType = 0, this[D](), this;
        }
        setUniforms(H = {}) {
          return Object.assign(this[R], H), this;
        }
        setTransform(...H) {
          const U = this[J];
          return c.mat2d.equals(H, U) || (this[J] = H, delete this[N], this._updateMatrix = !0), this;
        }
        transform(...H) {
          const U = this[J];
          return this[J] = c.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), U, H), delete this[N], this._updateMatrix = !0, this;
        }
        translate(H, U) {
          let m = c.mat2d.create();
          return m = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), m, [H, U]), this.transform(...m);
        }
        rotate(H, [U, m] = [0, 0]) {
          let h = c.mat2d.create();
          return h = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), h, [U, m]), h = c.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), h, H), h = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), h, [-U, -m]), this.transform(...h);
        }
        scale(H, U = H, [m, h] = [0, 0]) {
          let g = c.mat2d.create();
          return g = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), g, [m, h]), g = c.mat2d.scale(Array.of(0, 0, 0, 0, 0, 0), g, [H, U]), g = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), g, [-m, -h]), this.transform(...g);
        }
        skew(H, U = H, [m, h] = [0, 0]) {
          let g = c.mat2d.create();
          return g = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), g, [m, h]), g = c.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), g, c.mat2d.fromValues(1, Math.tan(U), Math.tan(H), 1, 0, 0)), g = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), g, [-m, -h]), this.transform(...g);
        }
        clearFilter() {
          return this.setColorTransform(null), this[v].length = 0, this;
        }
        setColorTransform(...H) {
          return H[0] === null ? this.setUniforms({
            u_filterFlag: 0,
            u_colorMatrix: 0
          }) : this.setUniforms({
            u_filterFlag: 1,
            u_colorMatrix: H
          }), this;
        }
        // apply linear color transform
        transformColor(...H) {
          let U = this.uniforms.u_colorMatrix;
          return U ? U = Object(e.multiply)(U, H) : U = H, this.setColorTransform(...U), this;
        }
        blur(H) {
          return this[v].push(`blur(${H}px)`), this;
        }
        brightness(H = 1) {
          return this[v].push(`brightness(${100 * H}%)`), this.transformColor(...Object(e.brightness)(H));
        }
        contrast(H = 1) {
          return this[v].push(`contrast(${100 * H}%)`), this.transformColor(...Object(e.contrast)(H));
        }
        dropShadow(H, U, m = 0, h = [0, 0, 0, 1]) {
          return Array.isArray(h) && (h = Object(a.default)(h)), this[v].push(`drop-shadow(${H}px ${U}px ${m}px ${h})`), this;
        }
        grayscale(H = 1) {
          return this[v].push(`grayscale(${100 * H}%)`), this.transformColor(...Object(e.grayscale)(H));
        }
        // https://github.com/phoboslab/WebGLImageFilter/blob/master/webgl-image-filter.js#L371
        hueRotate(H = 0) {
          return this[v].push(`hue-rotate(${H}deg)`), this.transformColor(...Object(e.hueRotate)(H));
        }
        invert(H = 1) {
          return this[v].push(`invert(${100 * H}%)`), this.transformColor(...Object(e.invert)(H));
        }
        opacity(H = 1) {
          return this[v].push(`opacity(${100 * H}%)`), this.transformColor(...Object(e.opacity)(H));
        }
        saturate(H = 1) {
          return this[v].push(`saturate(${100 * H}%)`), this.transformColor(...Object(e.saturate)(H));
        }
        sepia(H = 1) {
          return this[v].push(`sepia(${100 * H}%)`), this.transformColor(...Object(e.sepia)(H));
        }
        url(H) {
          return this[v].push(`url(${H})`), this;
        }
        isPointCollision(H, U, m = "both") {
          const h = this.meshData, {
            positions: g,
            cells: f
          } = h, w = this.invertMatrix, B = w[0] * H + w[2] * U + w[4], q = w[1] * H + w[3] * U + w[5], si = this.boundingBox;
          if (B < si[0][0] || B > si[1][0] || q < si[0][1] || q > si[1][1])
            return !1;
          function bi([Zi, oi], [mi, ci], [ni, Gi]) {
            const Vi = ni - mi, Wi = Gi - ci, Ii = ((Zi - mi) * Vi + (oi - ci) * Wi) / (Vi ** 2 + Wi ** 2);
            return Ii >= 0 && Ii <= 1;
          }
          for (let Zi = 0; Zi < f.length; Zi++) {
            const oi = f[Zi];
            if (m === "fill" && oi[0] >= h.fillPointCount)
              break;
            if (m === "stroke" && oi[0] < h.fillPointCount)
              continue;
            const [[mi, ci], [ni, Gi], [Vi, Wi]] = oi.map((Li) => g[Li]), Ii = Math.sign((H - mi) * (Gi - ci) - (ni - mi) * (U - ci));
            if (Ii === 0 && bi([H, U], [mi, ci], [ni, Gi]))
              return !0;
            const Ri = Math.sign((H - ni) * (Wi - Gi) - (Vi - ni) * (U - Gi));
            if (Ri === 0 && bi([H, U], [ni, Gi], [Vi, Wi]))
              return !0;
            const yi = Math.sign((H - Vi) * (ci - Wi) - (mi - Vi) * (U - Wi));
            if (yi === 0 && bi([H, U], [Vi, Wi], [mi, ci]) || Ii === 1 && Ri === 1 && yi === 1 || Ii === -1 && Ri === -1 && yi === -1)
              return !0;
          }
          return !1;
        }
        isPointInFill(H, U) {
          return this.isPointCollision(H, U, "fill");
        }
        isPointInStroke(H, U) {
          return this.isPointCollision(H, U, "stroke");
        }
        addPass(H, U = {}) {
          let {
            width: m,
            height: h
          } = U, g = t(U, ["width", "height"]);
          const f = new G.default();
          f.rect(0, 0, m, h);
          const w = new j(f, {
            width: m,
            height: h
          });
          w.setUniforms(g), w.setProgram(H), this[ti].push(w);
        }
      }
    },
    /* 57 */
    /***/
    function(n, l, i) {
      i.r(l);
      var c = i(58);
      i(1).glMatrix.setMatrixArrayType(Array), l.default = c.Stroke;
    },
    /* 58 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "Stroke", function() {
        return r;
      });
      var c = i(49);
      i(1).glMatrix.setMatrixArrayType(Array);
      const Z = Object(c.create)(), L = Object(c.create)(), K = Object(c.create)(), u = Object(c.create)(), a = Object(c.create)(), e = 1e20;
      class r {
        constructor({
          lineWidth: I = 1,
          lineJoin: o = "miter",
          miterLimit: G = 10,
          lineCap: d = "butt",
          roundSegments: t = 20
        } = {}) {
          this.lineWidth = I, this.lineJoin = o, this.miterLimit = G, this.lineCap = d, this.roundSegments = t, this._normal = null;
        }
        build(I, o = !1) {
          let G = I.length;
          if (I = [...I], G < 2)
            return I;
          o && ((I[0][0] !== I[G - 1][0] || I[0][1] !== I[G - 1][1]) && I.push([...I[0]]), I.push([...I[1]])), G = I.length, this._normal = null;
          const d = {
            left: [],
            right: []
          }, t = this.lineWidth / 2, s = this.lineCap;
          if (!o && s === "square") {
            Object(c.direction)(L, I[0], I[1]), Object(c.scaleAndAdd)(I[0], I[0], L, t);
            const V = I.length - 1;
            Object(c.direction)(L, I[V], I[V - 1]), Object(c.scaleAndAdd)(I[V], I[V], L, t);
          }
          for (let V = 1; V < G; V++) {
            const S = I[V - 1], Y = I[V], T = I[V + 1];
            this._seg(d, S, Y, T, t, o);
          }
          return !o && s === "round" && p(d, this.roundSegments), [...d.left, ...d.right.reverse()];
        }
        _seg(I, o, G, d, t, s) {
          const b = this.lineJoin === "bevel", V = this.lineJoin === "round";
          if (Object(c.direction)(L, G, o), this._normal || (this._normal = Object(c.create)(), Object(c.normal)(this._normal, L)), I.left.length || W(I, o, this._normal, t), !d)
            Object(c.normal)(this._normal, L), s ? W(I, o, this._normal, t) : W(I, G, this._normal, t);
          else {
            Object(c.direction)(K, d, G);
            let S = Object(c.computeMiter)(u, a, L, K, t);
            S = Math.min(S, e);
            const Y = Object(c.dot)(u, this._normal) < 0 ? -1 : 1;
            let T = b || V;
            if (!T && this.lineJoin === "miter" && S / t > this.miterLimit && (T = !0), T) {
              Object(c.scaleAndAdd)(Z, G, this._normal, -t * Y), X(I, Z, Y);
              let y = 1 / 0;
              o && (y = Math.min(y, Math.hypot(G[0] - o[0], G[1] - o[1]))), d && (y = Math.min(y, Math.hypot(d[0] - G[0], d[1] - G[1])));
              const J = Math.max(t, Math.min(S, y));
              if (Object(c.scaleAndAdd)(Z, G, a, J * Y), X(I, Z, -Y), d)
                if (Object(c.normal)(Z, K), Object(c.copy)(this._normal, Z), Object(c.scaleAndAdd)(Z, G, Z, -t * Y), V) {
                  const N = Object(c.clone)(Z), R = Y > 0 ? I.left[I.left.length - 1] : I.right[I.right.length - 1], x = Object(c.clone)(G), M = Object(c.sub)(Object(c.create)(), R, x), Q = Object(c.sub)(Object(c.create)(), N, x), P = Math.PI / this.roundSegments;
                  for (let D = 0; D < this.roundSegments && (Object(c.rotate)(M, M, [0, 0], Y * P), Math.sign(Object(c.cross)(Z, M, Q)[2]) === Y); D++)
                    Object(c.add)(Z, M, x), X(I, Z, Y);
                  X(I, N, Y);
                } else
                  X(I, Z, Y);
            } else
              W(I, G, a, S), Object(c.copy)(this._normal, a);
          }
        }
      }
      function X(C, I, o) {
        o > 0 ? C.left.push(Object(c.clone)(I)) : C.right.push(Object(c.clone)(I));
      }
      function W(C, I, o, G, d = -1) {
        Object(c.scaleAndAdd)(Z, I, o, -G), X(C, Z, -d), Object(c.scaleAndAdd)(Z, I, o, G), X(C, Z, d);
      }
      function p({
        left: C,
        right: I
      }, o) {
        const G = Object(c.create)(), d = Object(c.create)();
        let t = C[0], s = I[0], b = [0.5 * (t[0] + s[0]), 0.5 * (t[1] + s[1])];
        Object(c.sub)(d, t, b);
        for (let V = 1; V <= o; V++) {
          const S = -1 * Math.PI * V / o;
          Object(c.rotate)(G, d, [0, 0], S), Object(c.add)(Z, b, G), C.unshift(Object(c.clone)(Z));
        }
        t = I[I.length - 1], s = C[C.length - 1], b = [0.5 * (t[0] + s[0]), 0.5 * (t[1] + s[1])], Object(c.sub)(d, t, b);
        for (let V = 1; V <= o; V++) {
          const S = -1 * Math.PI * V / o;
          Object(c.rotate)(G, d, [0, 0], S), Object(c.add)(Z, b, G), I.push(Object(c.clone)(Z));
        }
      }
    },
    /* 59 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "isUnitTransform", function() {
        return c;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c(Z) {
        return Z[0] === 1 && Z[1] === 0 && Z[2] === 0 && Z[3] === 1 && Z[4] === 0 && Z[5] === 0;
      }
    },
    /* 60 */
    /***/
    function(n, l, i) {
      i(1).glMatrix.setMatrixArrayType(Array);
      var c = i(61), Z = i(62);
      n.exports = function(L, K) {
        if (K = K || {}, L = L.filter(function(o) {
          return o.length > 2;
        }), L.length === 0)
          return {
            positions: [],
            cells: []
          };
        typeof K.vertexSize != "number" && (K.vertexSize = L[0][0].length), L = L.map(function(o) {
          return o.reduce(function(G, d) {
            return G.concat(d);
          });
        });
        const u = K.rule === "evenodd" ? c.WINDING_ODD : c.WINDING_NONZERO;
        for (var a = c.tesselate(Z({
          contours: L,
          windingRule: u,
          elementType: c.POLYGONS,
          polySize: 3,
          vertexSize: 2
        }, K)), e = [], r = 0; r < a.vertices.length; r += K.vertexSize) {
          var X = a.vertices.slice(r, r + K.vertexSize);
          e.push(X);
        }
        var W = [];
        for (r = 0; r < a.elements.length; r += 3) {
          var p = a.elements[r], C = a.elements[r + 1], I = a.elements[r + 2];
          W.push([p, C, I]);
        }
        return {
          positions: e,
          cells: W
        };
      };
    },
    /* 61 */
    /***/
    function(n, l, i) {
      i(1).glMatrix.setMatrixArrayType(Array);
      var c = {}, Z = {};
      n.exports = c, c.WINDING_ODD = 0, c.WINDING_NONZERO = 1, c.WINDING_POSITIVE = 2, c.WINDING_NEGATIVE = 3, c.WINDING_ABS_GEQ_TWO = 4, c.POLYGONS = 0, c.CONNECTED_POLYGONS = 1, c.BOUNDARY_CONTOURS = 2, c.tesselate = function(d) {
        for (var t = d.debug || !1, s = new G(), b = 0; b < d.contours.length; b++)
          s.addContour(d.vertexSize || 2, d.contours[b]);
        return s.tesselate(d.windingRule || c.WINDING_ODD, d.elementType || c.POLYGONS, d.polySize || 3, d.vertexSize || 2, d.normal || [0, 0, 1]), {
          vertices: s.vertices,
          vertexIndices: s.vertexIndices,
          vertexCount: s.vertexCount,
          elements: s.elements,
          elementCount: s.elementCount,
          mesh: t ? s.mesh : void 0
        };
      };
      var L = function(d) {
        if (!d)
          throw "Assertion Failed!";
      };
      function K() {
        this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
      }
      function u() {
        this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1;
      }
      function a(d) {
        this.next = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Org = null, this.Lface = null, this.activeRegion = null, this.winding = 0, this.side = d;
      }
      a.prototype = {
        get Rface() {
          return this.Sym.Lface;
        },
        set Rface(d) {
          this.Sym.Lface = d;
        },
        get Dst() {
          return this.Sym.Org;
        },
        set Dst(d) {
          this.Sym.Org = d;
        },
        get Oprev() {
          return this.Sym.Lnext;
        },
        set Oprev(d) {
          this.Sym.Lnext = d;
        },
        get Lprev() {
          return this.Onext.Sym;
        },
        set Lprev(d) {
          this.Onext.Sym = d;
        },
        get Dprev() {
          return this.Lnext.Sym;
        },
        set Dprev(d) {
          this.Lnext.Sym = d;
        },
        get Rprev() {
          return this.Sym.Onext;
        },
        set Rprev(d) {
          this.Sym.Onext = d;
        },
        get Dnext() {
          return (
            /*this.Rprev*/
            this.Sym.Onext.Sym
          );
        },
        /* 3 pointers */
        set Dnext(d) {
          this.Sym.Onext.Sym = d;
        },
        /* 3 pointers */
        get Rnext() {
          return (
            /*this.Oprev*/
            this.Sym.Lnext.Sym
          );
        },
        /* 3 pointers */
        set Rnext(d) {
          this.Sym.Lnext.Sym = d;
        }
        /* 3 pointers */
      };
      function e() {
        var d = new K(), t = new u(), s = new a(0), b = new a(1);
        d.next = d.prev = d, d.anEdge = null, t.next = t.prev = t, t.anEdge = null, t.trail = null, t.marked = !1, t.inside = !1, s.next = s, s.Sym = b, s.Onext = null, s.Lnext = null, s.Org = null, s.Lface = null, s.winding = 0, s.activeRegion = null, b.next = b, b.Sym = s, b.Onext = null, b.Lnext = null, b.Org = null, b.Lface = null, b.winding = 0, b.activeRegion = null, this.vHead = d, this.fHead = t, this.eHead = s, this.eHeadSym = b;
      }
      e.prototype = {
        /* MakeEdge creates a new pair of half-edges which form their own loop.
        * No vertex or face structures are allocated, but these must be assigned
        * before the current edge operation is completed.
        */
        //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
        makeEdge_: function(d) {
          var t = new a(0), s = new a(1);
          d.Sym.side < d.side && (d = d.Sym);
          var b = d.Sym.next;
          return s.next = b, b.Sym.next = t, t.next = d, d.Sym.next = s, t.Sym = s, t.Onext = t, t.Lnext = s, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, s.Sym = t, s.Onext = s, s.Lnext = t, s.Org = null, s.Lface = null, s.winding = 0, s.activeRegion = null, t;
        },
        /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
        * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
        * a->Onext and b->Onext are exchanged.  This can have various effects
        * depending on whether a and b belong to different face or vertex rings.
        * For more explanation see tessMeshSplice() below.
        */
        // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
        splice_: function(d, t) {
          var s = d.Onext, b = t.Onext;
          s.Sym.Lnext = t, b.Sym.Lnext = d, d.Onext = b, t.Onext = s;
        },
        /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
        * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
        * a place to insert the new vertex in the global vertex list.  We insert
        * the new vertex *before* vNext so that algorithms which walk the vertex
        * list will not see the newly created vertices.
        */
        //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
        makeVertex_: function(d, t, s) {
          var b = d;
          L(b !== null);
          var V = s.prev;
          b.prev = V, V.next = b, b.next = s, s.prev = b, b.anEdge = t;
          var S = t;
          do
            S.Org = b, S = S.Onext;
          while (S !== t);
        },
        /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
        * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
        * a place to insert the new face in the global face list.  We insert
        * the new face *before* fNext so that algorithms which walk the face
        * list will not see the newly created faces.
        */
        // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
        makeFace_: function(d, t, s) {
          var b = d;
          L(b !== null);
          var V = s.prev;
          b.prev = V, V.next = b, b.next = s, s.prev = b, b.anEdge = t, b.trail = null, b.marked = !1, b.inside = s.inside;
          var S = t;
          do
            S.Lface = b, S = S.Lnext;
          while (S !== t);
        },
        /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
        * and removes from the global edge list.
        */
        //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
        killEdge_: function(d) {
          d.Sym.side < d.side && (d = d.Sym);
          var t = d.next, s = d.Sym.next;
          t.Sym.next = s, s.Sym.next = t;
        },
        /* KillVertex( vDel ) destroys a vertex and removes it from the global
        * vertex list.  It updates the vertex loop to point to a given new vertex.
        */
        //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
        killVertex_: function(d, t) {
          var s = d.anEdge, b = s;
          do
            b.Org = t, b = b.Onext;
          while (b !== s);
          var V = d.prev, S = d.next;
          S.prev = V, V.next = S;
        },
        /* KillFace( fDel ) destroys a face and removes it from the global face
        * list.  It updates the face loop to point to a given new face.
        */
        //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
        killFace_: function(d, t) {
          var s = d.anEdge, b = s;
          do
            b.Lface = t, b = b.Lnext;
          while (b !== s);
          var V = d.prev, S = d.next;
          S.prev = V, V.next = S;
        },
        /****************** Basic Edge Operations **********************/
        /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
        * The loop consists of the two new half-edges.
        */
        //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
        makeEdge: function() {
          var d = new K(), t = new K(), s = new u(), b = this.makeEdge_(this.eHead);
          return this.makeVertex_(d, b, this.vHead), this.makeVertex_(t, b.Sym, this.vHead), this.makeFace_(s, b, this.fHead), b;
        },
        /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
        * mesh connectivity and topology.  It changes the mesh so that
        *	eOrg->Onext <- OLD( eDst->Onext )
        *	eDst->Onext <- OLD( eOrg->Onext )
        * where OLD(...) means the value before the meshSplice operation.
        *
        * This can have two effects on the vertex structure:
        *  - if eOrg->Org != eDst->Org, the two vertices are merged together
        *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
        * In both cases, eDst->Org is changed and eOrg->Org is untouched.
        *
        * Similarly (and independently) for the face structure,
        *  - if eOrg->Lface == eDst->Lface, one loop is split into two
        *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
        * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
        *
        * Some special cases:
        * If eDst == eOrg, the operation has no effect.
        * If eDst == eOrg->Lnext, the new face will have a single edge.
        * If eDst == eOrg->Lprev, the old face will have a single edge.
        * If eDst == eOrg->Onext, the new vertex will have a single edge.
        * If eDst == eOrg->Oprev, the old vertex will have a single edge.
        */
        //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
        splice: function(d, t) {
          var s = !1, b = !1;
          if (d !== t) {
            if (t.Org !== d.Org && (b = !0, this.killVertex_(t.Org, d.Org)), t.Lface !== d.Lface && (s = !0, this.killFace_(t.Lface, d.Lface)), this.splice_(t, d), !b) {
              var V = new K();
              this.makeVertex_(V, t, d.Org), d.Org.anEdge = d;
            }
            if (!s) {
              var S = new u();
              this.makeFace_(S, t, d.Lface), d.Lface.anEdge = d;
            }
          }
        },
        /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
        * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
        * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
        * the newly created loop will contain eDel->Dst.  If the deletion of eDel
        * would create isolated vertices, those are deleted as well.
        *
        * This function could be implemented as two calls to tessMeshSplice
        * plus a few calls to memFree, but this would allocate and delete
        * unnecessary vertices and faces.
        */
        //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
        delete: function(d) {
          var t = d.Sym, s = !1;
          if (d.Lface !== d.Rface && (s = !0, this.killFace_(d.Lface, d.Rface)), d.Onext === d)
            this.killVertex_(d.Org, null);
          else if (d.Rface.anEdge = d.Oprev, d.Org.anEdge = d.Onext, this.splice_(d, d.Oprev), !s) {
            var b = new u();
            this.makeFace_(b, d, d.Lface);
          }
          t.Onext === t ? (this.killVertex_(t.Org, null), this.killFace_(t.Lface, null)) : (d.Lface.anEdge = t.Oprev, t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), this.killEdge_(d);
        },
        /******************** Other Edge Operations **********************/
        /* All these routines can be implemented with the basic edge
        * operations above.  They are provided for convenience and efficiency.
        */
        /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
        * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
        addEdgeVertex: function(d) {
          var t = this.makeEdge_(d), s = t.Sym;
          this.splice_(t, d.Lnext), t.Org = d.Dst;
          var b = new K();
          return this.makeVertex_(b, s, t.Org), t.Lface = s.Lface = d.Lface, t;
        },
        /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
        * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
        * eOrg and eNew will have the same left face.
        */
        // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
        splitEdge: function(d, t) {
          var s = this.addEdgeVertex(d), b = s.Sym;
          return this.splice_(d.Sym, d.Sym.Oprev), this.splice_(d.Sym, b), d.Dst = b.Org, b.Dst.anEdge = b.Sym, b.Rface = d.Rface, b.winding = d.winding, b.Sym.winding = d.Sym.winding, b;
        },
        /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
        * to eDst->Org, and returns the corresponding half-edge eNew.
        * If eOrg->Lface == eDst->Lface, this splits one loop into two,
        * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
        * loops are merged into one, and the loop eDst->Lface is destroyed.
        *
        * If (eOrg == eDst), the new face will have only two edges.
        * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
        * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
        */
        // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
        connect: function(d, t) {
          var s = !1, b = this.makeEdge_(d), V = b.Sym;
          if (t.Lface !== d.Lface && (s = !0, this.killFace_(t.Lface, d.Lface)), this.splice_(b, d.Lnext), this.splice_(V, t), b.Org = d.Dst, V.Org = t.Org, b.Lface = V.Lface = d.Lface, d.Lface.anEdge = V, !s) {
            var S = new u();
            this.makeFace_(S, b, d.Lface);
          }
          return b;
        },
        /* tessMeshZapFace( fZap ) destroys a face and removes it from the
        * global face list.  All edges of fZap will have a NULL pointer as their
        * left face.  Any edges which also have a NULL pointer as their right face
        * are deleted entirely (along with any isolated vertices this produces).
        * An entire mesh can be deleted by zapping its faces, one at a time,
        * in any order.  Zapped faces cannot be used in further mesh operations!
        */
        zapFace: function(d) {
          var t = d.anEdge, s, b, V, S, Y;
          b = t.Lnext;
          do
            s = b, b = s.Lnext, s.Lface = null, s.Rface === null && (s.Onext === s ? this.killVertex_(s.Org, null) : (s.Org.anEdge = s.Onext, this.splice_(s, s.Oprev)), V = s.Sym, V.Onext === V ? this.killVertex_(V.Org, null) : (V.Org.anEdge = V.Onext, this.splice_(V, V.Oprev)), this.killEdge_(s));
          while (s != t);
          S = d.prev, Y = d.next, Y.prev = S, S.next = Y;
        },
        countFaceVerts_: function(d) {
          var t = d.anEdge, s = 0;
          do
            s++, t = t.Lnext;
          while (t !== d.anEdge);
          return s;
        },
        //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
        mergeConvexFaces: function(d) {
          var t, s, b, V, S, Y, T;
          for (t = this.fHead.next; t !== this.fHead; t = t.next)
            if (t.inside)
              for (s = t.anEdge, S = s.Org; b = s.Lnext, V = s.Sym, V && V.Lface && V.Lface.inside && (Y = this.countFaceVerts_(t), T = this.countFaceVerts_(V.Lface), Y + T - 2 <= d && Z.vertCCW(s.Lprev.Org, s.Org, V.Lnext.Lnext.Org) && Z.vertCCW(V.Lprev.Org, V.Org, s.Lnext.Lnext.Org) && (b = V.Lnext, this.delete(V), s = null, V = null)), !(s && s.Lnext.Org === S); )
                s = b;
          return !0;
        },
        /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
        */
        check: function() {
          var d = this.fHead, t = this.vHead, s = this.eHead, b, V, S, Y, T, y;
          for (V = d, V = d; (b = V.next) !== d; V = b) {
            L(b.prev === V), T = b.anEdge;
            do
              L(T.Sym !== T), L(T.Sym.Sym === T), L(T.Lnext.Onext.Sym === T), L(T.Onext.Sym.Lnext === T), L(T.Lface === b), T = T.Lnext;
            while (T !== b.anEdge);
          }
          for (L(b.prev === V && b.anEdge === null), Y = t, Y = t; (S = Y.next) !== t; Y = S) {
            L(S.prev === Y), T = S.anEdge;
            do
              L(T.Sym !== T), L(T.Sym.Sym === T), L(T.Lnext.Onext.Sym === T), L(T.Onext.Sym.Lnext === T), L(T.Org === S), T = T.Onext;
            while (T !== S.anEdge);
          }
          for (L(S.prev === Y && S.anEdge === null), y = s, y = s; (T = y.next) !== s; y = T)
            L(T.Sym.next === y.Sym), L(T.Sym !== T), L(T.Sym.Sym === T), L(T.Org !== null), L(T.Dst !== null), L(T.Lnext.Onext.Sym === T), L(T.Onext.Sym.Lnext === T);
          L(T.Sym.next === y.Sym && T.Sym === this.eHeadSym && T.Sym.Sym === T && T.Org === null && T.Dst === null && T.Lface === null && T.Rface === null);
        }
      }, Z.vertEq = function(d, t) {
        return d.s === t.s && d.t === t.t;
      }, Z.vertLeq = function(d, t) {
        return d.s < t.s || d.s === t.s && d.t <= t.t;
      }, Z.transLeq = function(d, t) {
        return d.t < t.t || d.t === t.t && d.s <= t.s;
      }, Z.edgeGoesLeft = function(d) {
        return Z.vertLeq(d.Dst, d.Org);
      }, Z.edgeGoesRight = function(d) {
        return Z.vertLeq(d.Org, d.Dst);
      }, Z.vertL1dist = function(d, t) {
        return Math.abs(d.s - t.s) + Math.abs(d.t - t.t);
      }, Z.edgeEval = function(d, t, s) {
        L(Z.vertLeq(d, t) && Z.vertLeq(t, s));
        var b = t.s - d.s, V = s.s - t.s;
        return b + V > 0 ? b < V ? t.t - d.t + (d.t - s.t) * (b / (b + V)) : t.t - s.t + (s.t - d.t) * (V / (b + V)) : 0;
      }, Z.edgeSign = function(d, t, s) {
        L(Z.vertLeq(d, t) && Z.vertLeq(t, s));
        var b = t.s - d.s, V = s.s - t.s;
        return b + V > 0 ? (t.t - s.t) * b + (t.t - d.t) * V : 0;
      }, Z.transEval = function(d, t, s) {
        L(Z.transLeq(d, t) && Z.transLeq(t, s));
        var b = t.t - d.t, V = s.t - t.t;
        return b + V > 0 ? b < V ? t.s - d.s + (d.s - s.s) * (b / (b + V)) : t.s - s.s + (s.s - d.s) * (V / (b + V)) : 0;
      }, Z.transSign = function(d, t, s) {
        L(Z.transLeq(d, t) && Z.transLeq(t, s));
        var b = t.t - d.t, V = s.t - t.t;
        return b + V > 0 ? (t.s - s.s) * b + (t.s - d.s) * V : 0;
      }, Z.vertCCW = function(d, t, s) {
        return d.s * (t.t - s.t) + t.s * (s.t - d.t) + s.s * (d.t - t.t) >= 0;
      }, Z.interpolate = function(d, t, s, b) {
        return d = d < 0 ? 0 : d, s = s < 0 ? 0 : s, d <= s ? s === 0 ? (t + b) / 2 : t + (b - t) * (d / (d + s)) : b + (t - b) * (s / (d + s));
      }, Z.intersect = function(d, t, s, b, V) {
        var S, Y, T;
        Z.vertLeq(d, t) || (T = d, d = t, t = T), Z.vertLeq(s, b) || (T = s, s = b, b = T), Z.vertLeq(d, s) || (T = d, d = s, s = T, T = t, t = b, b = T), Z.vertLeq(s, t) ? Z.vertLeq(t, b) ? (S = Z.edgeEval(d, s, t), Y = Z.edgeEval(s, t, b), S + Y < 0 && (S = -S, Y = -Y), V.s = Z.interpolate(S, s.s, Y, t.s)) : (S = Z.edgeSign(d, s, t), Y = -Z.edgeSign(d, b, t), S + Y < 0 && (S = -S, Y = -Y), V.s = Z.interpolate(S, s.s, Y, b.s)) : V.s = (s.s + t.s) / 2, Z.transLeq(d, t) || (T = d, d = t, t = T), Z.transLeq(s, b) || (T = s, s = b, b = T), Z.transLeq(d, s) || (T = d, d = s, s = T, T = t, t = b, b = T), Z.transLeq(s, t) ? Z.transLeq(t, b) ? (S = Z.transEval(d, s, t), Y = Z.transEval(s, t, b), S + Y < 0 && (S = -S, Y = -Y), V.t = Z.interpolate(S, s.t, Y, t.t)) : (S = Z.transSign(d, s, t), Y = -Z.transSign(d, b, t), S + Y < 0 && (S = -S, Y = -Y), V.t = Z.interpolate(S, s.t, Y, b.t)) : V.t = (s.t + t.t) / 2;
      };
      function r() {
        this.key = null, this.next = null, this.prev = null;
      }
      function X(d, t) {
        this.head = new r(), this.head.next = this.head, this.head.prev = this.head, this.frame = d, this.leq = t;
      }
      X.prototype = {
        min: function() {
          return this.head.next;
        },
        max: function() {
          return this.head.prev;
        },
        insert: function(d) {
          return this.insertBefore(this.head, d);
        },
        search: function(d) {
          var t = this.head;
          do
            t = t.next;
          while (t.key !== null && !this.leq(this.frame, d, t.key));
          return t;
        },
        insertBefore: function(d, t) {
          do
            d = d.prev;
          while (d.key !== null && !this.leq(this.frame, d.key, t));
          var s = new r();
          return s.key = t, s.next = d.next, d.next.prev = s, s.prev = d, d.next = s, s;
        },
        delete: function(d) {
          d.next.prev = d.prev, d.prev.next = d.next;
        }
      };
      function W() {
        this.handle = null;
      }
      function p() {
        this.key = null, this.node = null;
      }
      function C(d, t) {
        this.size = 0, this.max = d, this.nodes = [], this.nodes.length = d + 1;
        var s;
        for (s = 0; s < this.nodes.length; s++)
          this.nodes[s] = new W();
        for (this.handles = [], this.handles.length = d + 1, s = 0; s < this.handles.length; s++)
          this.handles[s] = new p();
        this.initialized = !1, this.freeList = 0, this.leq = t, this.nodes[1].handle = 1, this.handles[1].key = null;
      }
      C.prototype = {
        floatDown_: function(d) {
          var t = this.nodes, s = this.handles, b, V, S;
          for (b = t[d].handle; ; ) {
            if (S = d << 1, S < this.size && this.leq(s[t[S + 1].handle].key, s[t[S].handle].key) && ++S, L(S <= this.max), V = t[S].handle, S > this.size || this.leq(s[b].key, s[V].key)) {
              t[d].handle = b, s[b].node = d;
              break;
            }
            t[d].handle = V, s[V].node = d, d = S;
          }
        },
        floatUp_: function(d) {
          var t = this.nodes, s = this.handles, b, V, S;
          for (b = t[d].handle; ; ) {
            if (S = d >> 1, V = t[S].handle, S === 0 || this.leq(s[V].key, s[b].key)) {
              t[d].handle = b, s[b].node = d;
              break;
            }
            t[d].handle = V, s[V].node = d, d = S;
          }
        },
        init: function() {
          for (var d = this.size; d >= 1; --d)
            this.floatDown_(d);
          this.initialized = !0;
        },
        min: function() {
          return this.handles[this.nodes[1].handle].key;
        },
        /* really pqHeapInsert */
        /* returns INV_HANDLE iff out of memory */
        //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
        insert: function(d) {
          var t, s;
          if (t = ++this.size, t * 2 > this.max) {
            this.max *= 2;
            var b, V;
            for (V = this.nodes.length, this.nodes.length = this.max + 1, b = V; b < this.nodes.length; b++)
              this.nodes[b] = new W();
            for (V = this.handles.length, this.handles.length = this.max + 1, b = V; b < this.handles.length; b++)
              this.handles[b] = new p();
          }
          return this.freeList === 0 ? s = t : (s = this.freeList, this.freeList = this.handles[s].node), this.nodes[t].handle = s, this.handles[s].node = t, this.handles[s].key = d, this.initialized && this.floatUp_(t), s;
        },
        //PQkey pqHeapExtractMin( PriorityQHeap *pq )
        extractMin: function() {
          var d = this.nodes, t = this.handles, s = d[1].handle, b = t[s].key;
          return this.size > 0 && (d[1].handle = d[this.size].handle, t[d[1].handle].node = 1, t[s].key = null, t[s].node = this.freeList, this.freeList = s, --this.size, this.size > 0 && this.floatDown_(1)), b;
        },
        delete: function(d) {
          var t = this.nodes, s = this.handles, b;
          L(d >= 1 && d <= this.max && s[d].key !== null), b = s[d].node, t[b].handle = t[this.size].handle, s[t[b].handle].node = b, --this.size, b <= this.size && (b <= 1 || this.leq(s[t[b >> 1].handle].key, s[t[b].handle].key) ? this.floatDown_(b) : this.floatUp_(b)), s[d].key = null, s[d].node = this.freeList, this.freeList = d;
        }
      };
      function I() {
        this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1;
      }
      var o = {};
      o.regionBelow = function(d) {
        return d.nodeUp.prev.key;
      }, o.regionAbove = function(d) {
        return d.nodeUp.next.key;
      }, o.debugEvent = function(d) {
      }, o.addWinding = function(d, t) {
        d.winding += t.winding, d.Sym.winding += t.Sym.winding;
      }, o.edgeLeq = function(d, t, s) {
        var b = d.event, Y, T, V = t.eUp, S = s.eUp;
        if (V.Dst === b)
          return S.Dst === b ? Z.vertLeq(V.Org, S.Org) ? Z.edgeSign(S.Dst, V.Org, S.Org) <= 0 : Z.edgeSign(V.Dst, S.Org, V.Org) >= 0 : Z.edgeSign(S.Dst, b, S.Org) <= 0;
        if (S.Dst === b)
          return Z.edgeSign(V.Dst, b, V.Org) >= 0;
        var Y = Z.edgeEval(V.Dst, b, V.Org), T = Z.edgeEval(S.Dst, b, S.Org);
        return Y >= T;
      }, o.deleteRegion = function(d, t) {
        t.fixUpperEdge && L(t.eUp.winding === 0), t.eUp.activeRegion = null, d.dict.delete(t.nodeUp);
      }, o.fixUpperEdge = function(d, t, s) {
        L(t.fixUpperEdge), d.mesh.delete(t.eUp), t.fixUpperEdge = !1, t.eUp = s, s.activeRegion = t;
      }, o.topLeftRegion = function(d, t) {
        var s = t.eUp.Org, b;
        do
          t = o.regionAbove(t);
        while (t.eUp.Org === s);
        if (t.fixUpperEdge) {
          if (b = d.mesh.connect(o.regionBelow(t).eUp.Sym, t.eUp.Lnext), b === null)
            return null;
          o.fixUpperEdge(d, t, b), t = o.regionAbove(t);
        }
        return t;
      }, o.topRightRegion = function(d) {
        var t = d.eUp.Dst;
        do
          d = o.regionAbove(d);
        while (d.eUp.Dst === t);
        return d;
      }, o.addRegionBelow = function(d, t, s) {
        var b = new I();
        return b.eUp = s, b.nodeUp = d.dict.insertBefore(t.nodeUp, b), b.fixUpperEdge = !1, b.sentinel = !1, b.dirty = !1, s.activeRegion = b, b;
      }, o.isWindingInside = function(d, t) {
        switch (d.windingRule) {
          case c.WINDING_ODD:
            return (t & 1) !== 0;
          case c.WINDING_NONZERO:
            return t !== 0;
          case c.WINDING_POSITIVE:
            return t > 0;
          case c.WINDING_NEGATIVE:
            return t < 0;
          case c.WINDING_ABS_GEQ_TWO:
            return t >= 2 || t <= -2;
        }
        return L(!1), !1;
      }, o.computeWinding = function(d, t) {
        t.windingNumber = o.regionAbove(t).windingNumber + t.eUp.winding, t.inside = o.isWindingInside(d, t.windingNumber);
      }, o.finishRegion = function(d, t) {
        var s = t.eUp, b = s.Lface;
        b.inside = t.inside, b.anEdge = s, o.deleteRegion(d, t);
      }, o.finishLeftRegions = function(d, t, s) {
        for (var b, Y, V = null, S = t, Y = t.eUp; S !== s; ) {
          if (S.fixUpperEdge = !1, V = o.regionBelow(S), b = V.eUp, b.Org != Y.Org) {
            if (!V.fixUpperEdge) {
              o.finishRegion(d, S);
              break;
            }
            b = d.mesh.connect(Y.Lprev, b.Sym), o.fixUpperEdge(d, V, b);
          }
          Y.Onext !== b && (d.mesh.splice(b.Oprev, b), d.mesh.splice(Y, b)), o.finishRegion(d, S), Y = V.eUp, S = V;
        }
        return Y;
      }, o.addRightEdges = function(d, t, s, b, V, S) {
        var Y, T, y, J, N = !0;
        y = s;
        do
          L(Z.vertLeq(y.Org, y.Dst)), o.addRegionBelow(d, t, y.Sym), y = y.Onext;
        while (y !== b);
        for (V === null && (V = o.regionBelow(t).eUp.Rprev), T = t, J = V; Y = o.regionBelow(T), y = Y.eUp.Sym, y.Org === J.Org; )
          y.Onext !== J && (d.mesh.splice(y.Oprev, y), d.mesh.splice(J.Oprev, y)), Y.windingNumber = T.windingNumber - y.winding, Y.inside = o.isWindingInside(d, Y.windingNumber), T.dirty = !0, !N && o.checkForRightSplice(d, T) && (o.addWinding(y, J), o.deleteRegion(d, T), d.mesh.delete(J)), N = !1, T = Y, J = y;
        T.dirty = !0, L(T.windingNumber - y.winding === Y.windingNumber), S && o.walkDirtyRegions(d, T);
      }, o.spliceMergeVertices = function(d, t, s) {
        d.mesh.splice(t, s);
      }, o.vertexWeights = function(d, t, s) {
        var b = Z.vertL1dist(t, d), V = Z.vertL1dist(s, d), S = 0.5 * V / (b + V), Y = 0.5 * b / (b + V);
        d.coords[0] += S * t.coords[0] + Y * s.coords[0], d.coords[1] += S * t.coords[1] + Y * s.coords[1], d.coords[2] += S * t.coords[2] + Y * s.coords[2];
      }, o.getIntersectData = function(d, t, s, b, V, S) {
        t.coords[0] = t.coords[1] = t.coords[2] = 0, t.idx = -1, o.vertexWeights(t, s, b), o.vertexWeights(t, V, S);
      }, o.checkForRightSplice = function(d, t) {
        var s = o.regionBelow(t), b = t.eUp, V = s.eUp;
        if (Z.vertLeq(b.Org, V.Org)) {
          if (Z.edgeSign(V.Dst, b.Org, V.Org) > 0)
            return !1;
          Z.vertEq(b.Org, V.Org) ? b.Org !== V.Org && (d.pq.delete(b.Org.pqHandle), o.spliceMergeVertices(d, V.Oprev, b)) : (d.mesh.splitEdge(V.Sym), d.mesh.splice(b, V.Oprev), t.dirty = s.dirty = !0);
        } else {
          if (Z.edgeSign(b.Dst, V.Org, b.Org) < 0)
            return !1;
          o.regionAbove(t).dirty = t.dirty = !0, d.mesh.splitEdge(b.Sym), d.mesh.splice(V.Oprev, b);
        }
        return !0;
      }, o.checkForLeftSplice = function(d, t) {
        var s = o.regionBelow(t), b = t.eUp, V = s.eUp, S;
        if (L(!Z.vertEq(b.Dst, V.Dst)), Z.vertLeq(b.Dst, V.Dst)) {
          if (Z.edgeSign(b.Dst, V.Dst, b.Org) < 0)
            return !1;
          o.regionAbove(t).dirty = t.dirty = !0, S = d.mesh.splitEdge(b), d.mesh.splice(V.Sym, S), S.Lface.inside = t.inside;
        } else {
          if (Z.edgeSign(V.Dst, b.Dst, V.Org) > 0)
            return !1;
          t.dirty = s.dirty = !0, S = d.mesh.splitEdge(V), d.mesh.splice(b.Lnext, V.Sym), S.Rface.inside = t.inside;
        }
        return !0;
      }, o.checkForIntersect = function(d, t) {
        var s = o.regionBelow(t), b = t.eUp, V = s.eUp, S = b.Org, Y = V.Org, T = b.Dst, y = V.Dst, J, N, R = new K(), x, M;
        if (L(!Z.vertEq(y, T)), L(Z.edgeSign(T, d.event, S) <= 0), L(Z.edgeSign(y, d.event, Y) >= 0), L(S !== d.event && Y !== d.event), L(!t.fixUpperEdge && !s.fixUpperEdge), S === Y || (J = Math.min(S.t, T.t), N = Math.max(Y.t, y.t), J > N))
          return !1;
        if (Z.vertLeq(S, Y)) {
          if (Z.edgeSign(y, S, Y) > 0)
            return !1;
        } else if (Z.edgeSign(T, Y, S) < 0)
          return !1;
        return o.debugEvent(d), Z.intersect(T, S, y, Y, R), L(Math.min(S.t, T.t) <= R.t), L(R.t <= Math.max(Y.t, y.t)), L(Math.min(y.s, T.s) <= R.s), L(R.s <= Math.max(Y.s, S.s)), Z.vertLeq(R, d.event) && (R.s = d.event.s, R.t = d.event.t), x = Z.vertLeq(S, Y) ? S : Y, Z.vertLeq(x, R) && (R.s = x.s, R.t = x.t), Z.vertEq(R, S) || Z.vertEq(R, Y) ? (o.checkForRightSplice(d, t), !1) : !Z.vertEq(T, d.event) && Z.edgeSign(T, d.event, R) >= 0 || !Z.vertEq(y, d.event) && Z.edgeSign(y, d.event, R) <= 0 ? y === d.event ? (d.mesh.splitEdge(b.Sym), d.mesh.splice(V.Sym, b), t = o.topLeftRegion(d, t), b = o.regionBelow(t).eUp, o.finishLeftRegions(d, o.regionBelow(t), s), o.addRightEdges(d, t, b.Oprev, b, b, !0), !0) : T === d.event ? (d.mesh.splitEdge(V.Sym), d.mesh.splice(b.Lnext, V.Oprev), s = t, t = o.topRightRegion(t), M = o.regionBelow(t).eUp.Rprev, s.eUp = V.Oprev, V = o.finishLeftRegions(d, s, null), o.addRightEdges(d, t, V.Onext, b.Rprev, M, !0), !0) : (Z.edgeSign(T, d.event, R) >= 0 && (o.regionAbove(t).dirty = t.dirty = !0, d.mesh.splitEdge(b.Sym), b.Org.s = d.event.s, b.Org.t = d.event.t), Z.edgeSign(y, d.event, R) <= 0 && (t.dirty = s.dirty = !0, d.mesh.splitEdge(V.Sym), V.Org.s = d.event.s, V.Org.t = d.event.t), !1) : (d.mesh.splitEdge(b.Sym), d.mesh.splitEdge(V.Sym), d.mesh.splice(V.Oprev, b), b.Org.s = R.s, b.Org.t = R.t, b.Org.pqHandle = d.pq.insert(b.Org), o.getIntersectData(d, b.Org, S, T, Y, y), o.regionAbove(t).dirty = t.dirty = s.dirty = !0, !1);
      }, o.walkDirtyRegions = function(d, t) {
        for (var s = o.regionBelow(t), b, V; ; ) {
          for (; s.dirty; )
            t = s, s = o.regionBelow(s);
          if (!t.dirty && (s = t, t = o.regionAbove(t), t === null || !t.dirty))
            return;
          if (t.dirty = !1, b = t.eUp, V = s.eUp, b.Dst !== V.Dst && o.checkForLeftSplice(d, t) && (s.fixUpperEdge ? (o.deleteRegion(d, s), d.mesh.delete(V), s = o.regionBelow(t), V = s.eUp) : t.fixUpperEdge && (o.deleteRegion(d, t), d.mesh.delete(b), t = o.regionAbove(s), b = t.eUp)), b.Org !== V.Org)
            if (b.Dst !== V.Dst && !t.fixUpperEdge && !s.fixUpperEdge && (b.Dst === d.event || V.Dst === d.event)) {
              if (o.checkForIntersect(d, t))
                return;
            } else
              o.checkForRightSplice(d, t);
          b.Org === V.Org && b.Dst === V.Dst && (o.addWinding(V, b), o.deleteRegion(d, t), d.mesh.delete(b), t = o.regionAbove(s));
        }
      }, o.connectRightVertex = function(d, t, s) {
        var b, V = s.Onext, S = o.regionBelow(t), Y = t.eUp, T = S.eUp, y = !1;
        if (Y.Dst !== T.Dst && o.checkForIntersect(d, t), Z.vertEq(Y.Org, d.event) && (d.mesh.splice(V.Oprev, Y), t = o.topLeftRegion(d, t), V = o.regionBelow(t).eUp, o.finishLeftRegions(d, o.regionBelow(t), S), y = !0), Z.vertEq(T.Org, d.event) && (d.mesh.splice(s, T.Oprev), s = o.finishLeftRegions(d, S, null), y = !0), y) {
          o.addRightEdges(d, t, s.Onext, V, V, !0);
          return;
        }
        Z.vertLeq(T.Org, Y.Org) ? b = T.Oprev : b = Y, b = d.mesh.connect(s.Lprev, b), o.addRightEdges(d, t, b, b.Onext, b.Onext, !1), b.Sym.activeRegion.fixUpperEdge = !0, o.walkDirtyRegions(d, t);
      }, o.connectLeftDegenerate = function(d, t, s) {
        var b, V, S, Y, T;
        if (b = t.eUp, Z.vertEq(b.Org, s)) {
          L(
            !1
            /*TOLERANCE_NONZERO*/
          ), o.spliceMergeVertices(d, b, s.anEdge);
          return;
        }
        if (!Z.vertEq(b.Dst, s)) {
          d.mesh.splitEdge(b.Sym), t.fixUpperEdge && (d.mesh.delete(b.Onext), t.fixUpperEdge = !1), d.mesh.splice(s.anEdge, b), o.sweepEvent(d, s);
          return;
        }
        L(
          !1
          /*TOLERANCE_NONZERO*/
        ), t = o.topRightRegion(t), T = o.regionBelow(t), S = T.eUp.Sym, V = Y = S.Onext, T.fixUpperEdge && (L(V !== S), o.deleteRegion(d, T), d.mesh.delete(S), S = V.Oprev), d.mesh.splice(s.anEdge, S), Z.edgeGoesLeft(V) || (V = null), o.addRightEdges(d, t, S.Onext, Y, V, !0);
      }, o.connectLeftVertex = function(d, t) {
        var s, b, V, S, Y, T, y = new I();
        if (y.eUp = t.anEdge.Sym, s = d.dict.search(y).key, b = o.regionBelow(s), !!b) {
          if (S = s.eUp, Y = b.eUp, Z.edgeSign(S.Dst, t, S.Org) === 0) {
            o.connectLeftDegenerate(d, s, t);
            return;
          }
          if (V = Z.vertLeq(Y.Dst, S.Dst) ? s : b, s.inside || V.fixUpperEdge) {
            if (V === s)
              T = d.mesh.connect(t.anEdge.Sym, S.Lnext);
            else {
              var J = d.mesh.connect(Y.Dnext, t.anEdge);
              T = J.Sym;
            }
            V.fixUpperEdge ? o.fixUpperEdge(d, V, T) : o.computeWinding(d, o.addRegionBelow(d, s, T)), o.sweepEvent(d, t);
          } else
            o.addRightEdges(d, s, t.anEdge, t.anEdge, null, !0);
        }
      }, o.sweepEvent = function(d, t) {
        d.event = t, o.debugEvent(d);
        for (var s = t.anEdge; s.activeRegion === null; )
          if (s = s.Onext, s === t.anEdge) {
            o.connectLeftVertex(d, t);
            return;
          }
        var b = o.topLeftRegion(d, s.activeRegion);
        L(b !== null);
        var V = o.regionBelow(b), S = V.eUp, Y = o.finishLeftRegions(d, V, null);
        Y.Onext === S ? o.connectRightVertex(d, b, Y) : o.addRightEdges(d, b, Y.Onext, S, S, !0);
      }, o.addSentinel = function(d, t, s, b) {
        var V = new I(), S = d.mesh.makeEdge();
        S.Org.s = s, S.Org.t = b, S.Dst.s = t, S.Dst.t = b, d.event = S.Dst, V.eUp = S, V.windingNumber = 0, V.inside = !1, V.fixUpperEdge = !1, V.sentinel = !0, V.dirty = !1, V.nodeUp = d.dict.insert(V);
      }, o.initEdgeDict = function(d) {
        d.dict = new X(d, o.edgeLeq);
        var t = d.bmax[0] - d.bmin[0], s = d.bmax[1] - d.bmin[1], b = d.bmin[0] - t, V = d.bmax[0] + t, S = d.bmin[1] - s, Y = d.bmax[1] + s;
        o.addSentinel(d, b, V, S), o.addSentinel(d, b, V, Y);
      }, o.doneEdgeDict = function(d) {
        for (var t, s = 0; (t = d.dict.min().key) !== null; )
          t.sentinel || (L(t.fixUpperEdge), L(++s === 1)), L(t.windingNumber === 0), o.deleteRegion(d, t);
      }, o.removeDegenerateEdges = function(d) {
        var t, s, b, V = d.mesh.eHead;
        for (t = V.next; t !== V; t = s)
          s = t.next, b = t.Lnext, Z.vertEq(t.Org, t.Dst) && t.Lnext.Lnext !== t && (o.spliceMergeVertices(d, b, t), d.mesh.delete(t), t = b, b = t.Lnext), b.Lnext === t && (b !== t && ((b === s || b === s.Sym) && (s = s.next), d.mesh.delete(b)), (t === s || t === s.Sym) && (s = s.next), d.mesh.delete(t));
      }, o.initPriorityQ = function(d) {
        var t, s, b, V = 0;
        for (b = d.mesh.vHead, s = b.next; s !== b; s = s.next)
          V++;
        for (V += 8, t = d.pq = new C(V, Z.vertLeq), b = d.mesh.vHead, s = b.next; s !== b; s = s.next)
          s.pqHandle = t.insert(s);
        return s !== b ? !1 : (t.init(), !0);
      }, o.donePriorityQ = function(d) {
        d.pq = null;
      }, o.removeDegenerateFaces = function(d, t) {
        var s, b, V;
        for (s = t.fHead.next; s !== t.fHead; s = b)
          b = s.next, V = s.anEdge, L(V.Lnext !== V), V.Lnext.Lnext === V && (o.addWinding(V.Onext, V), d.mesh.delete(V));
        return !0;
      }, o.computeInterior = function(d) {
        var t, s;
        if (o.removeDegenerateEdges(d), !o.initPriorityQ(d))
          return !1;
        for (o.initEdgeDict(d); (t = d.pq.extractMin()) !== null; ) {
          for (; s = d.pq.min(), !(s === null || !Z.vertEq(s, t)); )
            s = d.pq.extractMin(), o.spliceMergeVertices(d, t.anEdge, s.anEdge);
          o.sweepEvent(d, t);
        }
        return d.event = d.dict.min().key.eUp.Org, o.debugEvent(d), o.doneEdgeDict(d), o.donePriorityQ(d), o.removeDegenerateFaces(d, d.mesh) ? (d.mesh.check(), !0) : !1;
      };
      function G() {
        this.mesh = null, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = c.WINDING_ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
      }
      G.prototype = {
        dot_: function(d, t) {
          return d[0] * t[0] + d[1] * t[1] + d[2] * t[2];
        },
        normalize_: function(d) {
          var t = d[0] * d[0] + d[1] * d[1] + d[2] * d[2];
          L(t > 0), t = Math.sqrt(t), d[0] /= t, d[1] /= t, d[2] /= t;
        },
        longAxis_: function(d) {
          var t = 0;
          return Math.abs(d[1]) > Math.abs(d[0]) && (t = 1), Math.abs(d[2]) > Math.abs(d[t]) && (t = 2), t;
        },
        computeNormal_: function(d) {
          var t, s, b, V, S, Y, T = [0, 0, 0], y = [0, 0, 0], J = [0, 0, 0], N = [0, 0, 0], R = [0, 0, 0], x = [null, null, null], M = [null, null, null], Q = this.mesh.vHead, P;
          for (t = Q.next, P = 0; P < 3; ++P)
            V = t.coords[P], y[P] = V, M[P] = t, T[P] = V, x[P] = t;
          for (t = Q.next; t !== Q; t = t.next)
            for (P = 0; P < 3; ++P)
              V = t.coords[P], V < y[P] && (y[P] = V, M[P] = t), V > T[P] && (T[P] = V, x[P] = t);
          if (P = 0, T[1] - y[1] > T[0] - y[0] && (P = 1), T[2] - y[2] > T[P] - y[P] && (P = 2), y[P] >= T[P]) {
            d[0] = 0, d[1] = 0, d[2] = 1;
            return;
          }
          for (Y = 0, s = M[P], b = x[P], J[0] = s.coords[0] - b.coords[0], J[1] = s.coords[1] - b.coords[1], J[2] = s.coords[2] - b.coords[2], t = Q.next; t !== Q; t = t.next)
            N[0] = t.coords[0] - b.coords[0], N[1] = t.coords[1] - b.coords[1], N[2] = t.coords[2] - b.coords[2], R[0] = J[1] * N[2] - J[2] * N[1], R[1] = J[2] * N[0] - J[0] * N[2], R[2] = J[0] * N[1] - J[1] * N[0], S = R[0] * R[0] + R[1] * R[1] + R[2] * R[2], S > Y && (Y = S, d[0] = R[0], d[1] = R[1], d[2] = R[2]);
          Y <= 0 && (d[0] = d[1] = d[2] = 0, d[this.longAxis_(J)] = 1);
        },
        checkOrientation_: function() {
          var d, t, s = this.mesh.fHead, b, V = this.mesh.vHead, S;
          for (d = 0, t = s.next; t !== s; t = t.next)
            if (S = t.anEdge, !(S.winding <= 0))
              do
                d += (S.Org.s - S.Dst.s) * (S.Org.t + S.Dst.t), S = S.Lnext;
              while (S !== t.anEdge);
          if (d < 0) {
            for (b = V.next; b !== V; b = b.next)
              b.t = -b.t;
            this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
          }
        },
        /*	#ifdef FOR_TRITE_TEST_PROGRAM
          #include <stdlib.h>
          extern int RandomSweep;
          #define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
          #define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
          #else
          #if defined(SLANTED_SWEEP) */
        /* The "feature merging" is not intended to be complete.  There are
        * special cases where edges are nearly parallel to the sweep line
        * which are not implemented.  The algorithm should still behave
        * robustly (ie. produce a reasonable tesselation) in the presence
        * of such edges, however it may miss features which could have been
        * merged.  We could minimize this effect by choosing the sweep line
        * direction to be something unusual (ie. not parallel to one of the
        * coordinate axes).
        */
        /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
          #define S_UNIT_Y	(TESSreal)0.86052074622010633
          #else
          #define S_UNIT_X	(TESSreal)1.0
          #define S_UNIT_Y	(TESSreal)0.0
          #endif
          #endif*/
        /* Determine the polygon normal and project vertices onto the plane
        * of the polygon.
        */
        projectPolygon_: function() {
          var d, t = this.mesh.vHead, s = [0, 0, 0], b, V, S, Y, T = !1;
          for (s[0] = this.normal[0], s[1] = this.normal[1], s[2] = this.normal[2], s[0] === 0 && s[1] === 0 && s[2] === 0 && (this.computeNormal_(s), T = !0), b = this.sUnit, V = this.tUnit, S = this.longAxis_(s), b[S] = 0, b[(S + 1) % 3] = 1, b[(S + 2) % 3] = 0, V[S] = 0, V[(S + 1) % 3] = 0, V[(S + 2) % 3] = s[S] > 0 ? 1 : -1, d = t.next; d !== t; d = d.next)
            d.s = this.dot_(d.coords, b), d.t = this.dot_(d.coords, V);
          for (T && this.checkOrientation_(), Y = !0, d = t.next; d !== t; d = d.next)
            Y ? (this.bmin[0] = this.bmax[0] = d.s, this.bmin[1] = this.bmax[1] = d.t, Y = !1) : (d.s < this.bmin[0] && (this.bmin[0] = d.s), d.s > this.bmax[0] && (this.bmax[0] = d.s), d.t < this.bmin[1] && (this.bmin[1] = d.t), d.t > this.bmax[1] && (this.bmax[1] = d.t));
        },
        addWinding_: function(d, t) {
          d.winding += t.winding, d.Sym.winding += t.Sym.winding;
        },
        /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
        * (what else would it do??)  The region must consist of a single
        * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
        * case means that any vertical line intersects the interior of the
        * region in a single interval.  
        *
        * Tessellation consists of adding interior edges (actually pairs of
        * half-edges), to split the region into non-overlapping triangles.
        *
        * The basic idea is explained in Preparata and Shamos (which I don''t
        * have handy right now), although their implementation is more
        * complicated than this one.  The are two edge chains, an upper chain
        * and a lower chain.  We process all vertices from both chains in order,
        * from right to left.
        *
        * The algorithm ensures that the following invariant holds after each
        * vertex is processed: the untessellated region consists of two
        * chains, where one chain (say the upper) is a single edge, and
        * the other chain is concave.  The left vertex of the single edge
        * is always to the left of all vertices in the concave chain.
        *
        * Each step consists of adding the rightmost unprocessed vertex to one
        * of the two chains, and forming a fan of triangles from the rightmost
        * of two chain endpoints.  Determining whether we can add each triangle
        * to the fan is a simple orientation test.  By making the fan as large
        * as possible, we restore the invariant (check it yourself).
        */
        //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
        tessellateMonoRegion_: function(d, t) {
          var s, b;
          for (s = t.anEdge, L(s.Lnext !== s && s.Lnext.Lnext !== s); Z.vertLeq(s.Dst, s.Org); s = s.Lprev)
            ;
          for (; Z.vertLeq(s.Org, s.Dst); s = s.Lnext)
            ;
          for (b = s.Lprev; s.Lnext !== b; )
            if (Z.vertLeq(s.Dst, b.Org)) {
              for (; b.Lnext !== s && (Z.edgeGoesLeft(b.Lnext) || Z.edgeSign(b.Org, b.Dst, b.Lnext.Dst) <= 0); ) {
                var V = d.connect(b.Lnext, b);
                b = V.Sym;
              }
              b = b.Lprev;
            } else {
              for (; b.Lnext !== s && (Z.edgeGoesRight(s.Lprev) || Z.edgeSign(s.Dst, s.Org, s.Lprev.Org) >= 0); ) {
                var V = d.connect(s, s.Lprev);
                s = V.Sym;
              }
              s = s.Lnext;
            }
          for (L(b.Lnext !== s); b.Lnext.Lnext !== s; ) {
            var V = d.connect(b.Lnext, b);
            b = V.Sym;
          }
          return !0;
        },
        /* tessMeshTessellateInterior( mesh ) tessellates each region of
        * the mesh which is marked "inside" the polygon.  Each such region
        * must be monotone.
        */
        //int tessMeshTessellateInterior( TESSmesh *mesh )
        tessellateInterior_: function(d) {
          var t, s;
          for (t = d.fHead.next; t !== d.fHead; t = s)
            if (s = t.next, t.inside && !this.tessellateMonoRegion_(d, t))
              return !1;
          return !0;
        },
        /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
        * which are not marked "inside" the polygon.  Since further mesh operations
        * on NULL faces are not allowed, the main purpose is to clean up the
        * mesh so that exterior loops are not represented in the data structure.
        */
        //void tessMeshDiscardExterior( TESSmesh *mesh )
        discardExterior_: function(d) {
          var t, s;
          for (t = d.fHead.next; t !== d.fHead; t = s)
            s = t.next, t.inside || d.zapFace(t);
        },
        /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
        * winding numbers on all edges so that regions marked "inside" the
        * polygon have a winding number of "value", and regions outside
        * have a winding number of 0.
        *
        * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
        * separate an interior region from an exterior one.
        */
        //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
        setWindingNumber_: function(d, t, s) {
          var b, V;
          for (b = d.eHead.next; b !== d.eHead; b = V)
            V = b.next, b.Rface.inside !== b.Lface.inside ? b.winding = b.Lface.inside ? t : -t : s ? d.delete(b) : b.winding = 0;
        },
        getNeighbourFace_: function(d) {
          return !d.Rface || !d.Rface.inside ? -1 : d.Rface.n;
        },
        outputPolymesh_: function(d, t, s, b) {
          var V, S, Y, T = 0, y = 0, J, N;
          for (s > 3 && d.mergeConvexFaces(s), V = d.vHead.next; V !== d.vHead; V = V.next)
            V.n = -1;
          for (S = d.fHead.next; S !== d.fHead; S = S.next)
            if (S.n = -1, !!S.inside) {
              Y = S.anEdge, J = 0;
              do
                V = Y.Org, V.n === -1 && (V.n = y, y++), J++, Y = Y.Lnext;
              while (Y !== S.anEdge);
              L(J <= s), S.n = T, ++T;
            }
          for (this.elementCount = T, t === c.CONNECTED_POLYGONS && (T *= 2), this.elements = [], this.elements.length = T * s, this.vertexCount = y, this.vertices = [], this.vertices.length = y * b, this.vertexIndices = [], this.vertexIndices.length = y, V = d.vHead.next; V !== d.vHead; V = V.next)
            if (V.n !== -1) {
              var R = V.n * b;
              this.vertices[R + 0] = V.coords[0], this.vertices[R + 1] = V.coords[1], b > 2 && (this.vertices[R + 2] = V.coords[2]), this.vertexIndices[V.n] = V.idx;
            }
          var x = 0;
          for (S = d.fHead.next; S !== d.fHead; S = S.next)
            if (S.inside) {
              Y = S.anEdge, J = 0;
              do
                V = Y.Org, this.elements[x++] = V.n, J++, Y = Y.Lnext;
              while (Y !== S.anEdge);
              for (N = J; N < s; ++N)
                this.elements[x++] = -1;
              if (t === c.CONNECTED_POLYGONS) {
                Y = S.anEdge;
                do
                  this.elements[x++] = this.getNeighbourFace_(Y), Y = Y.Lnext;
                while (Y !== S.anEdge);
                for (N = J; N < s; ++N)
                  this.elements[x++] = -1;
              }
            }
        },
        //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
        outputContours_: function(d, t) {
          var s, b, V, S = 0, Y = 0;
          for (this.vertexCount = 0, this.elementCount = 0, s = d.fHead.next; s !== d.fHead; s = s.next)
            if (s.inside) {
              V = b = s.anEdge;
              do
                this.vertexCount++, b = b.Lnext;
              while (b !== V);
              this.elementCount++;
            }
          this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * t, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
          var T = 0, y = 0, J = 0;
          for (S = 0, s = d.fHead.next; s !== d.fHead; s = s.next)
            if (s.inside) {
              Y = 0, V = b = s.anEdge;
              do
                this.vertices[T++] = b.Org.coords[0], this.vertices[T++] = b.Org.coords[1], t > 2 && (this.vertices[T++] = b.Org.coords[2]), this.vertexIndices[y++] = b.Org.idx, Y++, b = b.Lnext;
              while (b !== V);
              this.elements[J++] = S, this.elements[J++] = Y, S += Y;
            }
        },
        addContour: function(d, t) {
          var s, b;
          for (this.mesh === null && (this.mesh = new e()), d < 2 && (d = 2), d > 3 && (d = 3), s = null, b = 0; b < t.length; b += d)
            s === null ? (s = this.mesh.makeEdge(), this.mesh.splice(s, s.Sym)) : (this.mesh.splitEdge(s), s = s.Lnext), s.Org.coords[0] = t[b + 0], s.Org.coords[1] = t[b + 1], d > 2 ? s.Org.coords[2] = t[b + 2] : s.Org.coords[2] = 0, s.Org.idx = this.vertexIndexCounter++, s.winding = 1, s.Sym.winding = -1;
        },
        //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
        tesselate: function(d, t, s, b, V) {
          if (this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, V && (this.normal[0] = V[0], this.normal[1] = V[1], this.normal[2] = V[2]), this.windingRule = d, b < 2 && (b = 2), b > 3 && (b = 3), !this.mesh)
            return !1;
          this.projectPolygon_(), o.computeInterior(this);
          var S = this.mesh;
          return t === c.BOUNDARY_CONTOURS ? this.setWindingNumber_(S, 1, !0) : this.tessellateInterior_(S), S.check(), t === c.BOUNDARY_CONTOURS ? this.outputContours_(S, b) : this.outputPolymesh_(S, t, s, b), !0;
        }
      };
    },
    /* 62 */
    /***/
    function(n, l) {
      n.exports = c;
      var i = Object.prototype.hasOwnProperty;
      function c() {
        for (var Z = {}, L = 0; L < arguments.length; L++) {
          var K = arguments[L];
          for (var u in K)
            i.call(K, u) && (Z[u] = K[u]);
        }
        return Z;
      }
    },
    /* 63 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "createShaders", function() {
        return a;
      }), i.d(l, "applyShader", function() {
        return e;
      }), i.d(l, "createCloudShaders", function() {
        return X;
      }), i.d(l, "applyCloudShader", function() {
        return W;
      });
      var c = i(64), Z = i(65), L = i(66), K = i(67);
      i(1).glMatrix.setMatrixArrayType(Array);
      const u = Symbol("shaders");
      function a(p) {
        p[u] = [];
        for (let C = 0; C < 16; C++) {
          const I = [], o = !!(C & 1), G = !!(C & 2), d = !!(C & 4), t = !!(C & 8);
          o && I.push("#define TEXTURE 1"), G && I.push("#define FILTER 1"), d && I.push("#define GRADIENT 1"), t && I.push("#define CLIPPATH 1");
          const s = `${I.join(`
`)}
`, b = [];
          o && b.push("uniform sampler2D u_texSampler;"), t && b.push("uniform sampler2D u_clipSampler;"), p[u][C] = [s + b.join(`
`) + Z.default, s + c.default];
        }
      }
      function e(p, {
        hasTexture: C = !1,
        hasFilter: I = !1,
        hasGradient: o = !1,
        hasClipPath: G = !1
      } = {}) {
        const d = C | I << 1 | o << 2 | G << 3;
        let t = p[u][d];
        Array.isArray(t) && (t = p.createProgram(...t), p[u][d] = t), p.program !== t && p.useProgram(t, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          }
        });
      }
      const r = [];
      function X(p) {
        for (let C = 0; C < 64; C++) {
          const I = [], o = !!(C & 1), G = !!(C & 2), d = !!(C & 4), t = !!(C & 8), s = !!(C & 16), b = !!(C & 32);
          o && I.push("#define TEXTURE 1"), G && I.push("#define FILTER 1"), d && I.push("#define GRADIENT 1"), t && I.push("#define CLOUDCOLOR 1"), s && I.push("#define CLOUDFILTER 1"), b && I.push("#define CLIPPATH 1");
          const V = `${I.join(`
`)}
`, S = [];
          if (o) {
            S.push("uniform sampler2D u_texSampler;");
            for (let Y = 0; Y < 12; Y++)
              S.push(`uniform sampler2D u_texFrame${Y};`);
          }
          b && S.push("uniform sampler2D u_clipSampler;"), r[C] = [V + S.join(`
`) + K.default, V + L.default];
        }
      }
      function W(p, {
        hasTexture: C = !1,
        hasFilter: I = !1,
        hasGradient: o = !1,
        hasCloudColor: G = !1,
        hasCloudFilter: d = !1,
        hasClipPath: t = !1
      } = {}) {
        const s = C | I << 1 | o << 2 | G << 3 | d << 4 | t << 5;
        let b = r[s];
        Array.isArray(b) && (b = p.createProgram(...b), r[s] = b), p.program !== b && p.useProgram(b, {
          a_color: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_fillCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_strokeCloudColor: {
            type: "UNSIGNED_BYTE",
            normalize: !0
          },
          a_frameIndex: {
            type: "UNSIGNED_BYTE",
            normalize: !1
          }
        });
      }
    },
    /* 64 */
    /***/
    function(n, l, i) {
      i.r(l), l.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;
  vColor = a_color;

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif
}`;
    },
    /* 65 */
    /***/
    function(n, l, i) {
      i.r(l), l.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;
// uniform float u_radialGradientVector[6];

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

#ifdef FILTER
void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      vec4 texColor = texture2D(u_texSampler, texCoord.xy);
      float alpha = texColor.a;
      if(opacity < 1.0) {
        texColor.a *= opacity;
        alpha *= mix(0.465, 1.0, opacity);
      }
      // color = mix(color, texColor, texColor.a);
      color.rgb = mix(color.rgb, texColor.rgb, alpha);
      // color.rgb = mix(texColor.rgb, color.rgb, color.a);
      color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
      color.a = texColor.a + (1.0 - texColor.a) * color.a;
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 66 */
    /***/
    function(n, l, i) {
      i.r(l), l.default = `attribute vec3 a_vertexPosition;
attribute vec4 a_color;
varying vec4 vColor;
varying float flagBackground;
attribute vec3 a_transform0;
attribute vec3 a_transform1;
uniform vec2 u_resolution;
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

#ifdef TEXTURE
attribute vec3 a_vertexTextureCoord;
varying vec3 vTextureCoord;
attribute float a_frameIndex;
varying float frameIndex;
attribute vec4 a_sourceRect;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
attribute vec2 a_clipUV;
varying vec2 vClipUV;
#endif

#ifdef CLOUDFILTER
attribute vec4 a_colorCloud0;
attribute vec4 a_colorCloud1;
attribute vec4 a_colorCloud2;
attribute vec4 a_colorCloud3;
attribute vec4 a_colorCloud4;
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef CLOUDCOLOR
attribute vec4 a_fillCloudColor;
attribute vec4 a_strokeCloudColor;
#endif

#ifdef GRADIENT
uniform float u_radialGradientVector[6];
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
#endif

void main() {
  gl_PointSize = 1.0;

  mat3 modelMatrix = mat3(
    a_transform0.x, a_transform1.x, 0, 
    a_transform0.y, a_transform1.y, 0,
    a_transform0.z, a_transform1.z, 1
  );

  vec3 pos = projectionMatrix * viewMatrix * modelMatrix * vec3(a_vertexPosition.xy, 1.0);
  gl_Position = vec4(pos.xy, 1.0, 1.0);

#ifdef GRADIENT
  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);
  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);
  float h = u_resolution.y;
  vg1.y = h - vg1.y;
  vg2.y = h - vg2.y;
  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);
  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);
#endif
  
  flagBackground = a_vertexPosition.z;

#ifdef CLOUDCOLOR
  if(flagBackground > 0.0) {
    vColor = mix(a_color, a_fillCloudColor, a_fillCloudColor.a);
  } else {
    vColor = mix(a_color, a_strokeCloudColor, a_strokeCloudColor.a);
  }
#else
  vColor = a_color;
#endif

#ifdef TEXTURE
  vTextureCoord = a_vertexTextureCoord;
  frameIndex = a_frameIndex;
  vSourceRect = a_sourceRect;
#endif

#ifdef CLIPPATH
  vClipUV = a_clipUV;
#endif

#ifdef CLOUDFILTER
  colorCloud0 = a_colorCloud0;
  colorCloud1 = a_colorCloud1;
  colorCloud2 = a_colorCloud2;
  colorCloud3 = a_colorCloud3;
  colorCloud4 = a_colorCloud4;
#endif
}`;
    },
    /* 67 */
    /***/
    function(n, l, i) {
      i.r(l), l.default = `precision mediump float;

varying vec4 vColor;
varying float flagBackground;

#ifdef TEXTURE
varying float frameIndex;
varying vec3 vTextureCoord;
varying vec4 vSourceRect;
#endif

#ifdef CLIPPATH
varying vec2 vClipUV;
#endif

#ifdef FILTER
uniform int u_filterFlag;
uniform float u_colorMatrix[20];
#endif

#ifdef CLOUDFILTER
varying vec4 colorCloud0;
varying vec4 colorCloud1;
varying vec4 colorCloud2;
varying vec4 colorCloud3;
varying vec4 colorCloud4;
#endif

#ifdef GRADIENT
varying vec3 vGradientVector1;
varying vec3 vGradientVector2;
uniform float u_colorSteps[40];
uniform int u_gradientType;

void gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {
  float t;
  // center circle radius
  float cr = gv1.z;
  // focal circle radius
  float fr = gv2.z;

  if(cr > 0.0 || fr > 0.0) {
    // radial gradient
    vec2 center = gv1.xy;
    vec2 focal = gv2.xy;
    float x = focal.x - gl_FragCoord.x;
    float y = focal.y - gl_FragCoord.y;
    float dx = focal.x - center.x;
    float dy = focal.y - center.y;
    float dr = cr - fr;
    float a = dx * dx + dy * dy - dr * dr;
    float b = -2.0 * (y * dy + x * dx + fr * dr);
    float c = x * x + y * y - fr * fr;
    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));
  } else {
    // linear gradient
    vec2 v1 = gl_FragCoord.xy - gv1.xy;
    vec2 v2 = gv2.xy - gv1.xy;
    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);
  }

  vec4 colors[8];
  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);
  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);
  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);
  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);
  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);
  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);
  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);
  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);
  
  float steps[8];
  steps[0] = colorSteps[0];
  steps[1] = colorSteps[5];
  steps[2] = colorSteps[10];
  steps[3] = colorSteps[15];
  steps[4] = colorSteps[20];
  steps[5] = colorSteps[25];
  steps[6] = colorSteps[30];
  steps[7] = colorSteps[35];

  color = colors[0];
  for (int i = 1; i < 8; i++) {
    if (steps[i] < 0.0 || steps[i] > 1.0) {
      break;
    }
    if(steps[i] == steps[i - 1]) {
      color = colors[i];
    } else {
      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));
    }
    if (steps[i] >= t) {
      break;
    }
  }
}
#endif

void transformColor(inout vec4 color, in float colorMatrix[20]) {
  float r = color.r, g = color.g, b = color.b, a = color.a;
  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];
  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];
  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];
  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];
}

#ifdef CLOUDFILTER
void buildCloudColor(inout float colorCloudMatrix[20]) {
  colorCloudMatrix[0] = colorCloud0[0];
  colorCloudMatrix[1] = colorCloud1[0];
  colorCloudMatrix[2] = colorCloud2[0];
  colorCloudMatrix[3] = colorCloud3[0];
  colorCloudMatrix[4] = colorCloud4[0];

  colorCloudMatrix[5] = colorCloud0[1];
  colorCloudMatrix[6] = colorCloud1[1];
  colorCloudMatrix[7] = colorCloud2[1];
  colorCloudMatrix[8] = colorCloud3[1];
  colorCloudMatrix[9] = colorCloud4[1];

  colorCloudMatrix[10] = colorCloud0[2];
  colorCloudMatrix[11] = colorCloud1[2];
  colorCloudMatrix[12] = colorCloud2[2];
  colorCloudMatrix[13] = colorCloud3[2];
  colorCloudMatrix[14] = colorCloud4[2];

  colorCloudMatrix[15] = colorCloud0[3];
  colorCloudMatrix[16] = colorCloud1[3];
  colorCloudMatrix[17] = colorCloud2[3];
  colorCloudMatrix[18] = colorCloud3[3];
  colorCloudMatrix[19] = colorCloud4[3];
}
#endif

void main() {
  vec4 color = vColor;
  float opacity = abs(flagBackground);

#ifdef GRADIENT
  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {
    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);
  }
#endif

  if(opacity < 1.0) {
    color.a *= opacity;
  }

#ifdef TEXTURE
  if(flagBackground > 0.0) {
    vec3 texCoord = vTextureCoord;

    if(texCoord.z == 1.0) {
      texCoord = fract(texCoord);
    }

    if(texCoord.x <= 1.0 && texCoord.x >= 0.0
      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {
      if(vSourceRect.z > 0.0) {
        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;
        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);
      }
      if(frameIndex < 0.0) {
        vec4 texColor = texture2D(u_texSampler, texCoord.xy);
        color = mix(color, texColor, texColor.a);
      } else {
        int index = int(floor(clamp(0.0, 11.0, frameIndex)));
        vec4 texColor;
        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);
        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);
        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);
        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);
        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);
        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);
        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);
        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);
        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);
        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);
        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);
        else texColor = texture2D(u_texFrame11, texCoord.xy);
        float alpha = texColor.a;
        if(opacity < 1.0) {
          texColor.a *= opacity;
          alpha *= mix(0.465, 1.0, opacity);
        }
        // color = mix(color, texColor, texColor.a);
        color.rgb = mix(color.rgb, texColor.rgb, alpha);
        // color.rgb = mix(texColor.rgb, color.rgb, color.a);
        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));
        color.a = texColor.a + (1.0 - texColor.a) * color.a;
      }
    }
  }
#endif

#ifdef FILTER
  if(u_filterFlag > 0) {
    transformColor(color, u_colorMatrix);
  }
#endif

#ifdef CLOUDFILTER
  float colorCloudMatrix[20];
  buildCloudColor(colorCloudMatrix);
  transformColor(color, colorCloudMatrix);
#endif

#ifdef CLIPPATH
  float clip = texture2D(u_clipSampler, vClipUV).r;
  color *= clip;
#endif

  gl_FragColor = color;
}`;
    },
    /* 68 */
    /***/
    function(n, l, i) {
      i.r(l), (function(c, Z) {
        i.d(l, "requestAnimationFrame", function() {
          return K;
        }), i.d(l, "cancelAnimationFrame", function() {
          return u;
        }), i(1).glMatrix.setMatrixArrayType(Array);
        function L() {
          if (typeof performance < "u" && performance.now)
            return performance.now();
          if (typeof c < "u" && c.hrtime) {
            const [a, e] = c.hrtime();
            return a * 1e3 + e * 1e-6;
          }
          return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
        }
        let K, u;
        typeof Z < "u" && typeof Z.requestAnimationFrame == "function" ? (K = Z.requestAnimationFrame, u = Z.cancelAnimationFrame) : (K = function(a) {
          return setTimeout(() => {
            a(L());
          }, 16);
        }, u = function(a) {
          return clearTimeout(a);
        });
      }).call(this, i(69), i(22));
    },
    /* 69 */
    /***/
    function(n, l) {
      var i = n.exports = {}, c, Z;
      function L() {
        throw new Error("setTimeout has not been defined");
      }
      function K() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? c = setTimeout : c = L;
        } catch {
          c = L;
        }
        try {
          typeof clearTimeout == "function" ? Z = clearTimeout : Z = K;
        } catch {
          Z = K;
        }
      })();
      function u(G) {
        if (c === setTimeout)
          return setTimeout(G, 0);
        if ((c === L || !c) && setTimeout)
          return c = setTimeout, setTimeout(G, 0);
        try {
          return c(G, 0);
        } catch {
          try {
            return c.call(null, G, 0);
          } catch {
            return c.call(this, G, 0);
          }
        }
      }
      function a(G) {
        if (Z === clearTimeout)
          return clearTimeout(G);
        if ((Z === K || !Z) && clearTimeout)
          return Z = clearTimeout, clearTimeout(G);
        try {
          return Z(G);
        } catch {
          try {
            return Z.call(null, G);
          } catch {
            return Z.call(this, G);
          }
        }
      }
      var e = [], r = !1, X, W = -1;
      function p() {
        !r || !X || (r = !1, X.length ? e = X.concat(e) : W = -1, e.length && C());
      }
      function C() {
        if (!r) {
          var G = u(p);
          r = !0;
          for (var d = e.length; d; ) {
            for (X = e, e = []; ++W < d; )
              X && X[W].run();
            W = -1, d = e.length;
          }
          X = null, r = !1, a(G);
        }
      }
      i.nextTick = function(G) {
        var d = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var t = 1; t < arguments.length; t++)
            d[t - 1] = arguments[t];
        e.push(new I(G, d)), e.length === 1 && !r && u(C);
      };
      function I(G, d) {
        this.fun = G, this.array = d;
      }
      I.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {};
      function o() {
      }
      i.on = o, i.addListener = o, i.once = o, i.off = o, i.removeListener = o, i.removeAllListeners = o, i.emit = o, i.prependListener = o, i.prependOnceListener = o, i.listeners = function(G) {
        return [];
      }, i.binding = function(G) {
        throw new Error("process.binding is not supported");
      }, i.cwd = function() {
        return "/";
      }, i.chdir = function(G) {
        throw new Error("process.chdir is not supported");
      }, i.umask = function() {
        return 0;
      };
    },
    /* 70 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return Y;
      });
      var c = i(1), Z = i(71), L = i(73), K = i(213), u = i(214), a = i(215), e = i(216);
      i(1).glMatrix.setMatrixArrayType(Array);
      function r(T, y) {
        var J = Object.keys(T);
        if (Object.getOwnPropertySymbols) {
          var N = Object.getOwnPropertySymbols(T);
          y && (N = N.filter(function(R) {
            return Object.getOwnPropertyDescriptor(T, R).enumerable;
          })), J.push.apply(J, N);
        }
        return J;
      }
      function X(T) {
        for (var y = 1; y < arguments.length; y++) {
          var J = arguments[y] != null ? arguments[y] : {};
          y % 2 ? r(Object(J), !0).forEach(function(N) {
            W(T, N, J[N]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(T, Object.getOwnPropertyDescriptors(J)) : r(Object(J)).forEach(function(N) {
            Object.defineProperty(T, N, Object.getOwnPropertyDescriptor(J, N));
          });
        }
        return T;
      }
      function W(T, y, J) {
        return y in T ? Object.defineProperty(T, y, { value: J, enumerable: !0, configurable: !0, writable: !0 }) : T[y] = J, T;
      }
      const p = Symbol.for("spritejs_changedAttrs"), C = Symbol.for("spritejs_attributes"), I = Symbol("resolution"), o = Symbol("animations"), G = Symbol("eventListeners"), d = Symbol("captureEventListeners"), t = Symbol("filters"), s = Symbol("display"), b = Symbol("program"), V = Symbol("shaderAttrs"), S = Symbol("uniforms");
      class Y {
        constructor(y = {}) {
          this.attributes = new this.constructor.Attr(this), this[I] = {
            width: 300,
            height: 150
          }, Object.assign(this.attributes, y), this[o] = /* @__PURE__ */ new Set(), this[G] = {}, this[d] = {};
        }
        get ancestors() {
          let y = this.parent;
          const J = [];
          for (; y; )
            J.push(y), y = y.parent;
          return J;
        }
        get animations() {
          return this[o];
        }
        get filters() {
          return this[t] || this.parent && this.parent.filters;
        }
        get isVisible() {
          return !1;
        }
        get layer() {
          return this.parent ? this.parent.layer : null;
        }
        get localMatrix() {
          const y = this.transformMatrix, {
            x: J,
            y: N
          } = this.attributes;
          return y[4] += J, y[5] += N, y;
        }
        get opacity() {
          let y = this.attributes.opacity;
          return this.parent && this.parent.opacity != null && (y *= this.parent.opacity), y;
        }
        get parentNode() {
          return this.parent;
        }
        get nextSibling() {
          return this.getNodeNearBy(1);
        }
        get previousSibling() {
          return this.getNodeNearBy(-1);
        }
        get program() {
          return this[b];
        }
        /* get parent defined by connect method */
        get renderer() {
          return this.parent ? this.parent.renderer : null;
        }
        get renderMatrix() {
          if (this.__cacheRenderMatrix)
            return this.__cacheRenderMatrix;
          let y = this.localMatrix;
          const J = this.parent;
          if (J) {
            const N = J.__cacheRenderMatrix || J.renderMatrix;
            N && (y = c.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), N, y));
          }
          return y;
        }
        get worldScaling() {
          const y = this.renderMatrix;
          return [Math.hypot(y[0], y[1]), Math.hypot(y[2], y[3])];
        }
        get worldRotation() {
          const y = this.renderMatrix;
          return Math.atan2(y[1], y[3]);
        }
        get worldPosition() {
          const y = this.renderMatrix;
          return [y[4], y[5]];
        }
        get uniforms() {
          return this[S];
        }
        /* get zOrder defined by connect method */
        /* attributes */
        get className() {
          return this.attributes.className;
        }
        set className(y) {
          this.attributes.className = y;
        }
        get id() {
          return this.attributes.id;
        }
        set id(y) {
          this.attributes.id = y;
        }
        get name() {
          return this.attributes.name;
        }
        set name(y) {
          this.attributes.name = y;
        }
        get zIndex() {
          return this.attributes.zIndex;
        }
        set zIndex(y) {
          this.attributes.zIndex = y;
        }
        get mesh() {
          return null;
        }
        get shaderAttrs() {
          return this[V] || {};
        }
        activateAnimations() {
          const y = this.layer;
          if (y) {
            const J = this[o];
            J.forEach((R) => {
              R.baseTimeline = y.timeline, R.play(), R.finished.then(() => {
                J.delete(R);
              });
            });
            const N = this.children;
            N && N.forEach((R) => {
              R.activateAnimations && R.activateAnimations();
            });
          }
        }
        addEventListener(y, J, N = {}) {
          y === "mousewheel" && (y = "wheel"), typeof N == "boolean" && (N = {
            capture: N
          });
          const {
            capture: R,
            once: x
          } = N, M = R ? d : G;
          return this[M][y] = this[M][y] || [], this[M][y].push({
            listener: J,
            once: x
          }), this;
        }
        animate(y, J) {
          const N = new L.default(this, y, J);
          return this.effects && N.applyEffects(this.effects), this.layer && (N.baseTimeline = this.layer.timeline, N.play(), N.finished.then(() => {
            this[o].delete(N);
          })), this[o].add(N), N;
        }
        attr(...y) {
          if (y.length === 0)
            return this.attributes[C];
          if (y.length > 1) {
            let [J, N] = y;
            return typeof N == "function" && (N = N(this.attr(J))), this.setAttribute(J, N), this;
          }
          return typeof y[0] == "string" ? this.getAttribute(y[0]) : (Object.assign(this.attributes, y[0]), this);
        }
        cloneNode() {
          const y = new this.constructor(), J = this.attributes[p];
          return y.attr(J), y;
        }
        connect(y, J) {
          Object.defineProperty(this, "parent", {
            value: y,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: J,
            writable: !1,
            configurable: !0
          }), y.timeline && this.activateAnimations(), this.setResolution(y.getResolution()), this.forceUpdate(), this.dispatchEvent({
            type: "append",
            detail: {
              parent: y,
              zOrder: J
            }
          });
        }
        contains(y) {
          for (; y && this !== y; )
            y = y.parent;
          return !!y;
        }
        deactivateAnimations() {
          this[o].forEach((J) => J.cancel());
          const y = this.children;
          y && y.forEach((J) => {
            J.deactivateAnimations && J.deactivateAnimations();
          });
        }
        disconnect() {
          const {
            parent: y,
            zOrder: J
          } = this;
          delete this.parent, delete this.zOrder, this.deactivateAnimations(), this.dispatchEvent({
            type: "remove",
            detail: {
              parent: y,
              zOrder: J
            }
          }), y && y.forceUpdate();
        }
        dispatchEvent(y) {
          y instanceof u.default || (y = new u.default(y)), y.target = this;
          let J = y.type;
          J === "mousewheel" && (J = "wheel");
          const N = [this];
          let R = this.parent;
          for (; y.bubbles && R; )
            N.push(R), R = R.parent;
          for (let x = N.length - 1; x >= 0; x--) {
            const M = N[x], Q = M[d] && M[d][J];
            if (Q && Q.length && (y.currentTarget = M, Q.forEach(({
              listener: P,
              once: D
            }) => {
              P.call(this, y), D && N.removeEventListener(P);
            }), delete y.currentTarget), !y.bubbles && y.cancelBubble)
              break;
          }
          if (!y.cancelBubble)
            for (let x = 0; x < N.length; x++) {
              const M = N[x], Q = M[G] && M[G][J];
              if (Q && Q.length && (y.currentTarget = M, Q.forEach(({
                listener: P,
                once: D
              }) => {
                P.call(this, y), D && N.removeEventListener(P);
              }), delete y.currentTarget), !y.bubbles || y.cancelBubble)
                break;
            }
        }
        dispatchPointerEvent(y) {
          const {
            layerX: J,
            layerY: N
          } = y;
          return this.isPointCollision(J, N) ? (this.dispatchEvent(y), !0) : !1;
        }
        draw(y = []) {
          const J = this.mesh;
          if (J) {
            if (Object(a.applyFilters)(J, this.filters), y.push(J), this[b]) {
              J.setProgram(this[b]);
              const N = this[V];
              N && Object.entries(N).forEach(([x, M]) => {
                J.setAttribute(x, M);
              });
              const R = this[S];
              if (this[S]) {
                const x = {};
                Object.entries(R).forEach(([M, Q]) => {
                  typeof Q == "function" && (Q = Q(this, M)), x[M] = Q;
                }), J.setUniforms(x);
              }
            }
            Object(e.default)(this, J);
          }
          return y;
        }
        forceUpdate() {
          this.parent && this.parent.forceUpdate();
        }
        getAttribute(y) {
          return this.attributes[y];
        }
        getListeners(y, {
          capture: J = !1
        } = {}) {
          return [...this[J ? d : G][y] || []];
        }
        getNodeNearBy(y = 1) {
          if (!this.parent)
            return null;
          if (y === 0)
            return this;
          const J = this.parent.children, N = J.indexOf(this);
          return J[N + y];
        }
        getWorldPosition(y, J) {
          const N = this.renderMatrix, R = y * N[0] + J * N[2] + N[4], x = y * N[1] + J * N[3] + N[5];
          return [R, x];
        }
        getOffsetPosition(y, J) {
          const N = c.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), this.renderMatrix), R = y * N[0] + J * N[2] + N[4], x = y * N[1] + J * N[3] + N[5];
          return [R, x];
        }
        getResolution() {
          return X({}, this[I]);
        }
        isPointCollision(y, J) {
          if (!this.mesh)
            return !1;
          const N = this.attributes.pointerEvents;
          if (N === "none" || N !== "all" && !this.isVisible)
            return !1;
          let R = "both";
          return N === "visibleFill" && (R = "fill"), N === "visibleStroke" && (R = "stroke"), this.mesh.isPointCollision(y, J, R);
        }
        onPropertyChange(y, J, N) {
          y !== "id" && y !== "name" && y !== "className" && y !== "pointerEvents" && y !== "passEvents" && this.forceUpdate(), y === "filter" && (this[t] = Object(a.parseFilterString)(J)), y === "zIndex" && this.parent && this.parent.reorder();
        }
        setAttribute(y, J) {
          y === "attrs" && this.attr(J), this.attributes[y] = J;
        }
        setMouseCapture() {
          this.layer && (this.layer.__mouseCapturedTarget = this);
        }
        // layer.renderer.createProgram(fragmentShader, vertexShader, attributeOptions)
        setProgram(y) {
          this[b] = y, this.forceUpdate();
        }
        setShaderAttribute(y, J) {
          this[V] = this[V] || {}, this[V][y] = J, this.forceUpdate();
        }
        setUniforms(y) {
          this[S] = this[S] || {}, Object.assign(this[S], y), this.forceUpdate();
        }
        setResolution({
          width: y,
          height: J
        }) {
          const {
            width: N,
            height: R
          } = this[I];
          (N !== y || R !== J) && (this[I] = {
            width: y,
            height: J
          }, this.forceUpdate(), this.dispatchEvent({
            type: "resolutionchange",
            detail: {
              width: y,
              height: J
            }
          }));
        }
        show() {
          this.attributes.display === "none" && (this.attributes.display = this[s] || "");
        }
        hide() {
          this.attributes.display !== "none" && (this[s] = this.attributes.display, this.attributes.display = "none");
        }
        releaseMouseCapture() {
          this.layer && this.layer.__mouseCapturedTarget === this && (this.layer.__mouseCapturedTarget = null);
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        removeAllListeners(y, J = {}) {
          typeof J == "boolean" && (J = {
            capture: J
          });
          const R = J.capture ? d : G;
          return this[R][y] && (this[R][y] = []), this;
        }
        removeAttribute(y) {
          this.setAttribute(y, null);
        }
        removeEventListener(y, J, N = {}) {
          typeof N == "boolean" && (N = {
            capture: N
          });
          const x = N.capture ? d : G;
          if (this[x][y]) {
            const M = this[x][y];
            if (M)
              for (let Q = 0; Q < M.length; Q++) {
                const {
                  listener: P
                } = M[Q];
                if (P === J) {
                  this[x][y].splice(Q, 1);
                  break;
                }
              }
          }
          return this;
        }
        transition(y, J = "linear") {
          const N = this, R = Symbol("animation");
          J = J || "linear";
          let x = 0;
          return typeof y == "object" && (x = y.delay || 0, y = y.duration), {
            [R]: null,
            cancel(M = !1) {
              const Q = this[R];
              Q && Q.cancel(M);
            },
            end() {
              const M = this[R];
              M && (M.playState === "running" || M.playState === "pending") && M.finish();
            },
            reverse() {
              const M = this[R];
              if (M)
                if (M.playState === "running" || M.playState === "pending")
                  M.playbackRate = -M.playbackRate;
                else {
                  const Q = M.timing.direction;
                  M.timing.direction = Q === "reverse" ? "normal" : "reverse", M.play();
                }
              return M.finished;
            },
            attr(M, Q) {
              return this.end(), typeof M == "string" && (M = {
                [M]: Q
              }), Object.entries(M).forEach(([P, D]) => {
                typeof D == "function" && (M[P] = D(N.attr(P)));
              }), this[R] = N.animate([M], {
                duration: y * 1e3,
                delay: x * 1e3,
                fill: "forwards",
                easing: J
              }), this[R].finished;
            }
          };
        }
        updateContours() {
        }
      }
      W(Y, "Attr", Z.default), K.default.registerNode(Y, "node");
    },
    /* 71 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return Y;
      });
      var c = i(1), Z = i(12), L = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const K = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_declareAlias"), a = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), r = Symbol.for("spritejs_attributes"), X = Symbol.for("spritejs_changedAttrs"), W = Symbol("subject"), p = Symbol("attr"), C = Symbol("default"), I = Symbol("alias");
      function o(T, [y, J]) {
        let N = c.mat2d.fromValues(1, 0, 0, 1, 0, 0);
        return [...T].forEach(([R, x]) => {
          if ((y || J) && (N = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [y, J])), R === "matrix")
            N = c.mat2d.multiply(N, N, x);
          else if (R === "offsetTranslate")
            N[4] += x[0], N[5] += x[1];
          else if (R === "offsetRotate")
            N = c.mat2d.rotate(Array.of(0, 0, 0, 0, 0, 0), N, x);
          else if (R === "skew") {
            const [M, Q] = x;
            N = c.mat2d.multiply(N, N, c.mat2d.fromValues(1, Math.tan(Q), Math.tan(M), 1, 0, 0));
          } else
            c.mat2d[R](N, N, x);
          (y || J) && (N = c.mat2d.translate(Array.of(0, 0, 0, 0, 0, 0), N, [-y, -J]));
        }), N;
      }
      const G = Symbol("transformMatrix"), d = Symbol("transforms"), t = Symbol("changedAttrs"), s = Symbol("lastChangedAttr"), b = Symbol("offsetFigure");
      function V(T, y, J) {
        const N = T[p][y];
        if (T[a](y, J, !1) || T[s] !== y) {
          const x = T[d];
          x.has(y) && x.delete(y), J && (y === "rotate" && (J = Math.PI * J / 180), y === "scale" && (J = J.map((M) => Math.abs(M) > 1e-5 ? M : 1 / M > 0 ? 1e-5 : -1e-5)), x.set(y, J)), T[G] = null, T[W].onPropertyChange(y, J, N, T);
        }
      }
      function S(T) {
        const y = T[b], J = T.offsetDistance * y.getTotalLength(), N = y.getPointAtLength(J);
        if (N) {
          const R = T[d];
          let x = T.offsetRotate;
          x === "auto" ? x = N.angle : x === "reverse" ? x = Math.PI + N.angle : x = Math.PI * x / 180, R.set("offsetRotate", x), R.set("offsetTranslate", [N.x, N.y]), T[G] = null;
        }
      }
      class Y {
        static setDefault(y, ...J) {
          return y[K](...J);
        }
        static declareAlias(y, ...J) {
          return y[u](...J);
        }
        static setAttribute(y, ...J) {
          return y[a](...J);
        }
        static getAttribute(y, ...J) {
          return y[e](...J);
        }
        static getAttributes(y) {
          return y[r];
        }
        static getChangedAttributes(y) {
          return y[X];
        }
        constructor(y) {
          this[W] = y, this[p] = {}, this[G] = c.mat2d.fromValues(1, 0, 0, 1, 0, 0), this[d] = /* @__PURE__ */ new Map(), this[C] = {}, this[I] = [], Object.defineProperty(y, "transformMatrix", {
            get: () => (this[G] || (this[G] = o(this[d], this.transformOrigin)), [...this[G]])
          }), this[K]({
            id: "",
            name: "",
            className: "",
            /* class */
            x: 0,
            y: 0,
            /* pos */
            transformOrigin: [0, 0],
            transform: "",
            translate: [0, 0],
            rotate: 0,
            scale: [1, 1],
            skew: [0, 0],
            opacity: 1,
            zIndex: 0,
            offsetPath: void 0,
            offsetDistance: 0,
            offsetRotate: "auto",
            pointerEvents: "visible",
            // none | visible | visibleFill | visibleStroke | all
            filter: "none",
            display: ""
          }), this[u]("class", "pos"), this[t] = /* @__PURE__ */ new Set(), this[b] = new Z.Figure2D({
            scale: 5,
            simplify: 0
          });
        }
        get [X]() {
          const y = {};
          return [...this[t]].forEach((J) => {
            y[J] = this[p][J];
          }), y;
        }
        get [r]() {
          const y = Object.assign({}, this[p]);
          for (let J = 0; J < this[I].length; J++) {
            const N = this[I][J];
            y[N] = this[N];
          }
          return y;
        }
        [K](y) {
          Object.assign(this[C], y), Object.assign(this[p], y);
        }
        [u](...y) {
          this[I].push(...y);
        }
        [a](y, J, N = !0) {
          const R = this[p][y], x = this[W];
          return J == null && (J = this[C][y]), Object(L.compareValue)(R, J) ? !1 : (this[p][y] = J, this[t].has(y) && this[t].delete(y), this[t].add(y), this[s] = y, N && x.onPropertyChange(y, J, R, this), !0);
        }
        [e](y) {
          return this[p][y];
        }
        set id(y) {
          this[a]("id", y);
        }
        get id() {
          return this[e]("id");
        }
        set name(y) {
          this[a]("name", y);
        }
        get name() {
          return this[e]("name");
        }
        set className(y) {
          this[a]("className", y);
        }
        get className() {
          return this[e]("className");
        }
        set class(y) {
          this.className = y;
        }
        get class() {
          return this.className;
        }
        get x() {
          return this[e]("x");
        }
        set x(y) {
          this[a]("x", Object(L.toNumber)(y));
        }
        get y() {
          return this[e]("y");
        }
        set y(y) {
          this[a]("y", Object(L.toNumber)(y));
        }
        get pos() {
          return [this.x, this.y];
        }
        set pos(y) {
          y = Object(L.toArray)(y), Array.isArray(y) || (y = [y, y]), this.x = y[0], this.y = y[1];
        }
        get transform() {
          return this[e]("transform");
        }
        set transform(y) {
          let J = null;
          if (Array.isArray(y) && (J = y, y = `matrix(${y.map(L.toNumber).join()})`), typeof y == "string")
            y = y.replace(/\s*,\s*/g, ",");
          else if (y != null)
            throw new TypeError("Invalid transform value.");
          const N = this[p].transform;
          if (this[a]("transform", y, !1)) {
            const R = this[d];
            if (R.has("matrix") && R.delete("matrix"), J)
              R.set("matrix", J);
            else if (y) {
              const x = y.match(/(matrix|translate|rotate|scale|skew)\([^()]+\)/g);
              if (x) {
                let M = c.mat2d.fromValues(1, 0, 0, 1, 0, 0);
                for (let Q = 0; Q < x.length; Q++) {
                  const D = x[Q].match(/^(matrix|translate|rotate|scale|skew)\(([^()]+)\)/);
                  if (D) {
                    let [, _, F] = D;
                    _ === "rotate" ? F = Math.PI * parseFloat(F) / 180 : F = F.trim().split(/[\s,]+/).map((v) => Object(L.toNumber)(v)), _ === "matrix" ? M = c.mat2d.multiply(M, M, F) : _ === "skew" ? M = c.mat2d.multiply(M, M, c.mat2d.fromValues(1, Math.tan(F[1]), Math.tan(F[0]), 1, 0, 0)) : c.mat2d[_](M, M, F), R.set("matrix", M);
                  }
                }
              } else
                throw new TypeError("Invalid transform value.");
            }
            this[G] = null, this[W].onPropertyChange("transform", y, N, this);
          }
        }
        get transformOrigin() {
          return this[e]("transformOrigin");
        }
        set transformOrigin(y) {
          y = Object(L.toArray)(y, !0), y != null && !Array.isArray(y) && (y = [y, y]), this[a]("transformOrigin", y) && (this[G] = null);
        }
        get rotate() {
          return this[e]("rotate");
        }
        set rotate(y) {
          V(this, "rotate", y);
        }
        get translate() {
          return this[e]("translate");
        }
        set translate(y) {
          y = Object(L.toArray)(y, !0), y != null && !Array.isArray(y) && (y = [y, y]), V(this, "translate", y);
        }
        get scale() {
          return this[e]("scale");
        }
        set scale(y) {
          y = Object(L.toArray)(y, !0), y != null && !Array.isArray(y) && (y = [y, y]), V(this, "scale", y);
        }
        get skew() {
          return this[e]("skew");
        }
        set skew(y) {
          y = Object(L.toArray)(y, !0), y != null && !Array.isArray(y) && (y = [y, y]), V(this, "skew", y);
        }
        get opacity() {
          return this[e]("opacity");
        }
        set opacity(y) {
          y != null && (y = Number(y)), this[a]("opacity", y);
        }
        get zIndex() {
          return this[e]("zIndex");
        }
        set zIndex(y) {
          y != null && (y = Number(y)), this[a]("zIndex", y);
        }
        get offsetPath() {
          return this[e]("offsetPath");
        }
        set offsetPath(y) {
          this[a]("offsetPath", y) && (this[b].beginPath(), y != null && this[b].addPath(y), S(this));
        }
        get offsetDistance() {
          return this[e]("offsetDistance");
        }
        set offsetDistance(y) {
          this[a]("offsetDistance", Object(L.toNumber)(y)) && S(this);
        }
        get offsetRotate() {
          return this[e]("offsetRotate");
        }
        set offsetRotate(y) {
          this[a]("offsetRotate", y), S(this);
        }
        get pointerEvents() {
          return this[e]("pointerEvents");
        }
        set pointerEvents(y) {
          if (y != null && y !== "none" && y !== "visible" && y !== "visibleFill" && y !== "visibleStroke" && y !== "all")
            throw new TypeError("Invalid pointerEvents type.");
          this[a]("pointerEvents", y);
        }
        get filter() {
          return this[e]("filter");
        }
        set filter(y) {
          this[a]("filter", y);
        }
        get display() {
          return this[e]("display");
        }
        set display(y) {
          this[a]("display", y);
        }
        /* istanbul ignore next */
        set offset(y) {
        }
      }
    },
    /* 72 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "sizeToPixel", function() {
        return c;
      }), i.d(l, "toString", function() {
        return Z;
      }), i.d(l, "toNumber", function() {
        return L;
      }), i.d(l, "toArray", function() {
        return K;
      }), i.d(l, "compareValue", function() {
        return u;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c(a, e) {
        const r = a.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/);
        r ? a = {
          size: parseFloat(r[1]),
          unit: r[2]
        } : a = {
          size: parseFloat(a),
          unit: "px"
        };
        let {
          size: X,
          unit: W
        } = a;
        if (W === "pt")
          X /= 0.75;
        else if (W === "pc")
          X *= 16;
        else if (W === "in")
          X *= 96;
        else if (W === "cm")
          X *= 96 / 2.54;
        else if (W === "mm")
          X *= 96 / 25.4;
        else if (W === "em" || W === "rem" || W === "ex") {
          if (!e && typeof getComputedStyle == "function" && typeof document < "u") {
            const p = getComputedStyle(document.documentElement).fontSize;
            p ? e = c(p, 16) : e = 16;
          }
          X *= e, W === "ex" && (X /= 2);
        } else if (W === "q")
          X *= 96 / 25.4 / 4;
        else if (W === "vw" || W === "vh") {
          if (typeof document < "u") {
            const p = W === "vw" ? window.innerWidth || document.documentElement.clientWidth : window.innerHeight || document.documentElement.clientHeight;
            X *= p / 100;
          }
        } else if ((W === "vmax" || W === "vmin") && typeof document < "u") {
          const p = window.innerWidth || document.documentElement.clientWidth, C = window.innerHeight || document.documentElement.clientHeight;
          W === "vmax" ? X *= Math.max(p, C) / 100 : X *= Math.min(p, C) / 100;
        }
        return X;
      }
      function Z(a) {
        return a == null ? a : String(a);
      }
      function L(a) {
        if (a == null)
          return a;
        if (typeof a == "string" && (a = c(a)), !Number.isFinite(a))
          throw new TypeError("Invalid value");
        return a;
      }
      function K(a, e = !1) {
        return a === "" ? null : (typeof a == "string" && (a = a.split(/[\s,]+/g)), Array.isArray(a) && (e && (a = a.map(L)), a.length === 1) ? a[0] : a);
      }
      function u(a, e) {
        if (Array.isArray(a) && Array.isArray(e)) {
          if (a.length !== e.length)
            return !1;
          for (let r = 0; r < a.length; r++)
            if (a[r] !== e[r])
              return !1;
          return !0;
        }
        return a == null && e == null || a === e;
      }
    },
    /* 73 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return W;
      });
      var c = i(74), Z = i(32), L = /* @__PURE__ */ i.n(Z), K = i(68), u = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a() {
        return a = Object.assign || function(p) {
          for (var C = 1; C < arguments.length; C++) {
            var I = arguments[C];
            for (var o in I)
              Object.prototype.hasOwnProperty.call(I, o) && (p[o] = I[o]);
          }
          return p;
        }, a.apply(this, arguments);
      }
      function e(p) {
        if (typeof p == "string") {
          if (p = p.trim(), /^[0-9.]+%$/.test(p))
            return parseFloat(p) / 100;
          if (/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin)$/.test(p))
            return Object(u.sizeToPixel)(p);
        }
        return p;
      }
      function r(p, C, I, o, G) {
        return typeof p == "string" && (p = L()(p)), typeof C == "string" && (C = L()(C)), c.Effects.default(p, C, I, o, G);
      }
      function X(p, C, I, o, G) {
        return c.Effects.default(p, C, I, o, G);
      }
      c.Effects.default = function(p, C, I, o, G) {
        return Array.isArray(p) && Array.isArray(C) ? p.map((d, t) => d + (I - o) / (G - o) * (C[t] - d)) : typeof p == "number" && typeof C == "number" ? p + (I - o) / (G - o) * (C - p) : I - o > G - I ? C : p;
      }, c.Effects.fillColor = r, c.Effects.strokeColor = r, c.Effects.bgcolor = r, c.Effects.borderColor = r, c.Effects.text = X;
      class W extends c.Animator {
        constructor(C, I, o) {
          const G = C.attr();
          Object.entries(G).forEach(([d, t]) => {
            G[d] = c.Effects[d] ? t : e(t);
          }), I = I.map((d) => {
            let t = a({}, d);
            const s = {};
            return Object.entries(t).forEach(([b, V]) => {
              s[b] = c.Effects[b] ? V : e(V);
            }), s;
          }), super(G, I, o), this.target = C, this.setter = function(d, t) {
            t.attr(d);
          };
        }
        get playState() {
          return this.target.parent ? super.playState : "idle";
        }
        get finished() {
          return super.finished.then(() => {
            const C = this;
            return new Promise((I) => {
              function o() {
                C.setter(C.frame, C.target);
                const G = C.playState;
                G === "finished" || G === "idle" ? (Object(K.cancelAnimationFrame)(C.requestId), I()) : Object(K.requestAnimationFrame)(o);
              }
              o();
            });
          });
        }
        finish() {
          super.finish(), Object(K.cancelAnimationFrame)(this.requestId), this.setter(this.frame, this.target);
        }
        play() {
          if (!this.target.parent || this.playState === "running")
            return;
          super.play(), this.setter(this.frame, this.target);
          const C = this;
          this.ready.then(() => {
            C.setter(C.frame, C.target), C.requestId = Object(K.requestAnimationFrame)(function I() {
              const o = C.target;
              if (typeof document < "u" && document.documentElement && document.documentElement.contains && o.layer && o.layer.canvas && !document.documentElement.contains(o.layer.canvas)) {
                C.cancel();
                return;
              }
              const G = C.playState;
              C.setter(C.frame, C.target), G !== "idle" && (G === "running" ? C.requestId = Object(K.requestAnimationFrame)(I) : (G === "paused" || G === "pending" && C.timeline.currentTime < 0) && C.ready.then(() => {
                C.setter(C.frame, C.target), C.requestId = Object(K.requestAnimationFrame)(I);
              }));
            });
          });
        }
        cancel(C = !1) {
          Object(K.cancelAnimationFrame)(this.requestId), C ? (this.setter(this.frame, this.target), super.cancel()) : (super.cancel(), this.setter(this.frame, this.target));
        }
      }
    },
    /* 74 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.Timeline = l.Effects = l.Easings = l.Animator = void 0;
      var c = i(75), Z = r(c), L = i(187), K = r(L), u = i(188), a = i(190), e = r(a);
      function r(X) {
        return X && X.__esModule ? X : { default: X };
      }
      l.Animator = e.default, l.Easings = u.Easings, l.Effects = K.default, l.Timeline = Z.default;
    },
    /* 75 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var c = i(76), Z = d(c), L = i(133), K = d(L), u = i(141), a = d(u), e = i(164), r = d(e), X = i(170), W = d(X), p = i(171), C = d(p), I = i(175), o = d(I), G = i(186);
      function d(N) {
        return N && N.__esModule ? N : { default: N };
      }
      var t = (0, G.createNowTime)(), s = {
        originTime: 0,
        playbackRate: 1
      }, b = (0, o.default)("timeMark"), V = (0, o.default)("playbackRate"), S = (0, o.default)("timers"), Y = (0, o.default)("originTime"), T = (0, o.default)("setTimer"), y = (0, o.default)("parent"), J = function() {
        function N(R, x) {
          (0, W.default)(this, N), R instanceof N && (x = R, R = {}), R = (0, r.default)({}, s, R), x && (this[y] = x);
          var M = R.nowtime || t;
          if (x)
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return x.currentTime;
              }
            });
          else {
            var Q = M();
            Object.defineProperty(this, "globalTime", {
              get: function() {
                return M() - Q;
              }
            });
          }
          this[b] = [{
            globalTime: this.globalTime,
            localTime: -R.originTime,
            entropy: -R.originTime,
            playbackRate: R.playbackRate,
            globalEntropy: 0
          }], this[y] && (this[b][0].globalEntropy = this[y].entropy), this[Y] = R.originTime, this[V] = R.playbackRate, this[S] = new a.default();
        }
        return (0, C.default)(N, [{
          key: "markTime",
          value: function() {
            var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, M = x.time, Q = M === void 0 ? this.currentTime : M, P = x.entropy, D = P === void 0 ? this.entropy : P, _ = x.playbackRate, F = _ === void 0 ? this.playbackRate : _, v = {
              globalTime: this.globalTime,
              localTime: Q,
              entropy: D,
              playbackRate: F,
              globalEntropy: this.globalEntropy
            };
            this[b].push(v);
          }
        }, {
          key: "fork",
          value: function(x) {
            return new N(x, this);
          }
        }, {
          key: "seekGlobalTime",
          value: function(x) {
            var M = this.seekTimeMark(x), Q = this[b][M], P = Q.entropy, D = Q.playbackRate, _ = Q.globalTime;
            return _ + (x - P) / Math.abs(D);
          }
        }, {
          key: "seekLocalTime",
          value: function(x) {
            var M = this.seekTimeMark(x), Q = this[b][M], P = Q.localTime, D = Q.entropy, _ = Q.playbackRate;
            return _ > 0 ? P + (x - D) : P - (x - D);
          }
        }, {
          key: "seekTimeMark",
          value: function(x) {
            var M = this[b], Q = 0, P = M.length - 1;
            if (x <= M[Q].entropy)
              return Q;
            if (x >= M[P].entropy)
              return P;
            for (var D = Math.floor((Q + P) / 2); D > Q && D < P; ) {
              if (x === M[D].entropy)
                return D;
              x < M[D].entropy ? P = D : x > M[D].entropy && (Q = D), D = Math.floor((Q + P) / 2);
            }
            return Q;
          }
        }, {
          key: "updateTimers",
          value: function() {
            var x = this, M = [].concat((0, K.default)(this[S]));
            M.forEach(function(Q) {
              var P = (0, Z.default)(Q, 2), D = P[0], _ = P[1];
              x[T](_.handler, _.time, D);
            });
          }
        }, {
          key: "clearTimeout",
          value: function(R) {
            function x(M) {
              return R.apply(this, arguments);
            }
            return x.toString = function() {
              return R.toString();
            }, x;
          }(function(R) {
            var x = this[S].get(R);
            x && x.timerID != null && (this[y] ? this[y].clearTimeout(x.timerID) : clearTimeout(x.timerID)), this[S].delete(R);
          })
        }, {
          key: "clearInterval",
          value: function(x) {
            return this.clearTimeout(x);
          }
        }, {
          key: "clear",
          value: function() {
            var x = this, M = this[S];
            [].concat((0, K.default)(M.keys())).forEach(function(Q) {
              x.clearTimeout(Q);
            });
          }
          /*
            setTimeout(func, {delay: 100, isEntropy: true})
            setTimeout(func, {entropy: 100})
            setTimeout(func, 100})
           */
        }, {
          key: "setTimeout",
          value: function(x) {
            var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 };
            return this[T](x, M);
          }
        }, {
          key: "setInterval",
          value: function(x) {
            var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { delay: 0 }, Q = this, P = this[T](function D() {
              Q[T](D, M, P), x();
            }, M);
            return P;
          }
        }, {
          key: T,
          value: function(x, M) {
            var Q = this, P = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, o.default)("timerID");
            M = (0, G.formatDelay)(M);
            var D = this[S].get(P), _ = void 0, F = null, v = void 0, O = void 0;
            D ? (this.clearTimeout(P), M.isEntropy ? _ = (M.delay - (this.entropy - D.startEntropy)) / Math.abs(this.playbackRate) : _ = (M.delay - (this.currentTime - D.startTime)) / this.playbackRate, v = D.startTime, O = D.startEntropy) : (_ = M.delay / (M.isEntropy ? Math.abs(this.playbackRate) : this.playbackRate), v = this.currentTime, O = this.entropy);
            var li = this[y], ii = li ? li.setTimeout.bind(li) : setTimeout, ti = M.heading;
            return !li && ti === !1 && _ < 0 && (_ = 1 / 0), (isFinite(_) || li) && (_ = Math.ceil(_), ii !== setTimeout && (_ = { delay: _, heading: ti }), F = ii(function() {
              Q[S].delete(P), x();
            }, _)), this[S].set(P, {
              timerID: F,
              handler: x,
              time: M,
              startTime: v,
              startEntropy: O
            }), P;
          }
        }, {
          key: "parent",
          get: function() {
            return this[y];
          }
        }, {
          key: "lastTimeMark",
          get: function() {
            return this[b][this[b].length - 1];
          }
        }, {
          key: "currentTime",
          get: function() {
            var x = this.lastTimeMark, M = x.localTime, Q = x.globalTime;
            return M + (this.globalTime - Q) * this.playbackRate;
          },
          set: function(x) {
            var M = this, Q = this.currentTime, P = x, D = this[S];
            this.markTime({ time: x }), [].concat((0, K.default)(D)).forEach(function(_) {
              var F = (0, Z.default)(_, 2), v = F[0], O = F[1];
              if (D.has(v)) {
                var li = O.time, ii = li.isEntropy, ti = li.delay, $ = li.heading, ai = O.handler, Xi = O.startTime;
                if (ii)
                  ti === 0 && (ai(), M.clearTimeout(v));
                else {
                  var z = Xi + ti;
                  (ti === 0 || $ !== !1 && (P - Q) * ti <= 0 || Q <= z && z <= P || Q >= z && z >= P) && (ai(), M.clearTimeout(v));
                }
              }
            }), this.updateTimers();
          }
          // Both currentTime and entropy should be influenced by playbackRate.
          // If current playbackRate is negative, the currentTime should go backwards
          // while the entropy remain to go forwards.
          // Both of the initial values is set to -originTime
        }, {
          key: "entropy",
          get: function() {
            var x = this.lastTimeMark, M = x.entropy, Q = x.globalEntropy;
            return M + Math.abs((this.globalEntropy - Q) * this.playbackRate);
          },
          // get globalTime() {
          //   if(this[_parent]) {
          //     return this[_parent].currentTime;
          //   }
          //   return nowtime();
          // }
          // change entropy will NOT cause currentTime changing but may influence the pass
          // and the future of the timeline. (It may change the result of seek***Time)
          // While entropy is set, all the marks behind will be droped
          set: function(x) {
            if (this.entropy > x) {
              var M = this.seekTimeMark(x);
              this[b].length = M + 1;
            }
            this.markTime({ entropy: x }), this.updateTimers();
          }
        }, {
          key: "globalEntropy",
          get: function() {
            return this[y] ? this[y].entropy : this.globalTime;
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[V];
          },
          set: function(x) {
            x !== this.playbackRate && (this.markTime({ playbackRate: x }), this[V] = x, this.updateTimers());
          }
        }, {
          key: "paused",
          get: function() {
            if (this.playbackRate === 0)
              return !0;
            for (var x = this.parent; x; ) {
              if (x.playbackRate === 0)
                return !0;
              x = x.parent;
            }
            return !1;
          }
        }]), N;
      }();
      l.default = J;
    },
    /* 76 */
    /***/
    function(n, l, i) {
      l.__esModule = !0;
      var c = i(77), Z = u(c), L = i(129), K = u(L);
      function u(a) {
        return a && a.__esModule ? a : { default: a };
      }
      l.default = /* @__PURE__ */ function() {
        function a(e, r) {
          var X = [], W = !0, p = !1, C = void 0;
          try {
            for (var I = (0, K.default)(e), o; !(W = (o = I.next()).done) && (X.push(o.value), !(r && X.length === r)); W = !0)
              ;
          } catch (G) {
            p = !0, C = G;
          } finally {
            try {
              !W && I.return && I.return();
            } finally {
              if (p)
                throw C;
            }
          }
          return X;
        }
        return function(e, r) {
          if (Array.isArray(e))
            return e;
          if ((0, Z.default)(Object(e)))
            return a(e, r);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }();
    },
    /* 77 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(78), __esModule: !0 };
    },
    /* 78 */
    /***/
    function(n, l, i) {
      i(79), i(125), n.exports = i(127);
    },
    /* 79 */
    /***/
    function(n, l, i) {
      i(80);
      for (var c = i(91), Z = i(95), L = i(83), K = i(122)("toStringTag"), u = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), a = 0; a < u.length; a++) {
        var e = u[a], r = c[e], X = r && r.prototype;
        X && !X[K] && Z(X, K, e), L[e] = L.Array;
      }
    },
    /* 80 */
    /***/
    function(n, l, i) {
      var c = i(81), Z = i(82), L = i(83), K = i(84);
      n.exports = i(88)(Array, "Array", function(u, a) {
        this._t = K(u), this._i = 0, this._k = a;
      }, function() {
        var u = this._t, a = this._k, e = this._i++;
        return !u || e >= u.length ? (this._t = void 0, Z(1)) : a == "keys" ? Z(0, e) : a == "values" ? Z(0, u[e]) : Z(0, [e, u[e]]);
      }, "values"), L.Arguments = L.Array, c("keys"), c("values"), c("entries");
    },
    /* 81 */
    /***/
    function(n, l) {
      n.exports = function() {
      };
    },
    /* 82 */
    /***/
    function(n, l) {
      n.exports = function(i, c) {
        return { value: c, done: !!i };
      };
    },
    /* 83 */
    /***/
    function(n, l) {
      n.exports = {};
    },
    /* 84 */
    /***/
    function(n, l, i) {
      var c = i(85), Z = i(87);
      n.exports = function(L) {
        return c(Z(L));
      };
    },
    /* 85 */
    /***/
    function(n, l, i) {
      var c = i(86);
      n.exports = Object("z").propertyIsEnumerable(0) ? Object : function(Z) {
        return c(Z) == "String" ? Z.split("") : Object(Z);
      };
    },
    /* 86 */
    /***/
    function(n, l) {
      var i = {}.toString;
      n.exports = function(c) {
        return i.call(c).slice(8, -1);
      };
    },
    /* 87 */
    /***/
    function(n, l) {
      n.exports = function(i) {
        if (i == null)
          throw TypeError("Can't call method on  " + i);
        return i;
      };
    },
    /* 88 */
    /***/
    function(n, l, i) {
      var c = i(89), Z = i(90), L = i(106), K = i(95), u = i(83), a = i(107), e = i(121), r = i(123), X = i(122)("iterator"), W = !([].keys && "next" in [].keys()), p = "@@iterator", C = "keys", I = "values", o = function() {
        return this;
      };
      n.exports = function(G, d, t, s, b, V, S) {
        a(t, d, s);
        var Y = function(F) {
          if (!W && F in N)
            return N[F];
          switch (F) {
            case C:
              return function() {
                return new t(this, F);
              };
            case I:
              return function() {
                return new t(this, F);
              };
          }
          return function() {
            return new t(this, F);
          };
        }, T = d + " Iterator", y = b == I, J = !1, N = G.prototype, R = N[X] || N[p] || b && N[b], x = R || Y(b), M = b ? y ? Y("entries") : x : void 0, Q = d == "Array" && N.entries || R, P, D, _;
        if (Q && (_ = r(Q.call(new G())), _ !== Object.prototype && _.next && (e(_, T, !0), !c && typeof _[X] != "function" && K(_, X, o))), y && R && R.name !== I && (J = !0, x = function() {
          return R.call(this);
        }), (!c || S) && (W || J || !N[X]) && K(N, X, x), u[d] = x, u[T] = o, b)
          if (P = {
            values: y ? x : Y(I),
            keys: V ? x : Y(C),
            entries: M
          }, S)
            for (D in P)
              D in N || L(N, D, P[D]);
          else
            Z(Z.P + Z.F * (W || J), d, P);
        return P;
      };
    },
    /* 89 */
    /***/
    function(n, l) {
      n.exports = !0;
    },
    /* 90 */
    /***/
    function(n, l, i) {
      var c = i(91), Z = i(92), L = i(93), K = i(95), u = i(105), a = "prototype", e = function(r, X, W) {
        var p = r & e.F, C = r & e.G, I = r & e.S, o = r & e.P, G = r & e.B, d = r & e.W, t = C ? Z : Z[X] || (Z[X] = {}), s = t[a], b = C ? c : I ? c[X] : (c[X] || {})[a], V, S, Y;
        C && (W = X);
        for (V in W)
          S = !p && b && b[V] !== void 0, !(S && u(t, V)) && (Y = S ? b[V] : W[V], t[V] = C && typeof b[V] != "function" ? W[V] : G && S ? L(Y, c) : d && b[V] == Y ? function(T) {
            var y = function(J, N, R) {
              if (this instanceof T) {
                switch (arguments.length) {
                  case 0:
                    return new T();
                  case 1:
                    return new T(J);
                  case 2:
                    return new T(J, N);
                }
                return new T(J, N, R);
              }
              return T.apply(this, arguments);
            };
            return y[a] = T[a], y;
          }(Y) : o && typeof Y == "function" ? L(Function.call, Y) : Y, o && ((t.virtual || (t.virtual = {}))[V] = Y, r & e.R && s && !s[V] && K(s, V, Y)));
      };
      e.F = 1, e.G = 2, e.S = 4, e.P = 8, e.B = 16, e.W = 32, e.U = 64, e.R = 128, n.exports = e;
    },
    /* 91 */
    /***/
    function(n, l) {
      var i = n.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
      typeof __g == "number" && (__g = i);
    },
    /* 92 */
    /***/
    function(n, l) {
      var i = n.exports = { version: "2.6.11" };
      typeof __e == "number" && (__e = i);
    },
    /* 93 */
    /***/
    function(n, l, i) {
      var c = i(94);
      n.exports = function(Z, L, K) {
        if (c(Z), L === void 0)
          return Z;
        switch (K) {
          case 1:
            return function(u) {
              return Z.call(L, u);
            };
          case 2:
            return function(u, a) {
              return Z.call(L, u, a);
            };
          case 3:
            return function(u, a, e) {
              return Z.call(L, u, a, e);
            };
        }
        return function() {
          return Z.apply(L, arguments);
        };
      };
    },
    /* 94 */
    /***/
    function(n, l) {
      n.exports = function(i) {
        if (typeof i != "function")
          throw TypeError(i + " is not a function!");
        return i;
      };
    },
    /* 95 */
    /***/
    function(n, l, i) {
      var c = i(96), Z = i(104);
      n.exports = i(100) ? function(L, K, u) {
        return c.f(L, K, Z(1, u));
      } : function(L, K, u) {
        return L[K] = u, L;
      };
    },
    /* 96 */
    /***/
    function(n, l, i) {
      var c = i(97), Z = i(99), L = i(103), K = Object.defineProperty;
      l.f = i(100) ? Object.defineProperty : function(a, e, r) {
        if (c(a), e = L(e, !0), c(r), Z)
          try {
            return K(a, e, r);
          } catch {
          }
        if ("get" in r || "set" in r)
          throw TypeError("Accessors not supported!");
        return "value" in r && (a[e] = r.value), a;
      };
    },
    /* 97 */
    /***/
    function(n, l, i) {
      var c = i(98);
      n.exports = function(Z) {
        if (!c(Z))
          throw TypeError(Z + " is not an object!");
        return Z;
      };
    },
    /* 98 */
    /***/
    function(n, l) {
      n.exports = function(i) {
        return typeof i == "object" ? i !== null : typeof i == "function";
      };
    },
    /* 99 */
    /***/
    function(n, l, i) {
      n.exports = !i(100) && !i(101)(function() {
        return Object.defineProperty(i(102)("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 100 */
    /***/
    function(n, l, i) {
      n.exports = !i(101)(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    },
    /* 101 */
    /***/
    function(n, l) {
      n.exports = function(i) {
        try {
          return !!i();
        } catch {
          return !0;
        }
      };
    },
    /* 102 */
    /***/
    function(n, l, i) {
      var c = i(98), Z = i(91).document, L = c(Z) && c(Z.createElement);
      n.exports = function(K) {
        return L ? Z.createElement(K) : {};
      };
    },
    /* 103 */
    /***/
    function(n, l, i) {
      var c = i(98);
      n.exports = function(Z, L) {
        if (!c(Z))
          return Z;
        var K, u;
        if (L && typeof (K = Z.toString) == "function" && !c(u = K.call(Z)) || typeof (K = Z.valueOf) == "function" && !c(u = K.call(Z)) || !L && typeof (K = Z.toString) == "function" && !c(u = K.call(Z)))
          return u;
        throw TypeError("Can't convert object to primitive value");
      };
    },
    /* 104 */
    /***/
    function(n, l) {
      n.exports = function(i, c) {
        return {
          enumerable: !(i & 1),
          configurable: !(i & 2),
          writable: !(i & 4),
          value: c
        };
      };
    },
    /* 105 */
    /***/
    function(n, l) {
      var i = {}.hasOwnProperty;
      n.exports = function(c, Z) {
        return i.call(c, Z);
      };
    },
    /* 106 */
    /***/
    function(n, l, i) {
      n.exports = i(95);
    },
    /* 107 */
    /***/
    function(n, l, i) {
      var c = i(108), Z = i(104), L = i(121), K = {};
      i(95)(K, i(122)("iterator"), function() {
        return this;
      }), n.exports = function(u, a, e) {
        u.prototype = c(K, { next: Z(1, e) }), L(u, a + " Iterator");
      };
    },
    /* 108 */
    /***/
    function(n, l, i) {
      var c = i(97), Z = i(109), L = i(119), K = i(116)("IE_PROTO"), u = function() {
      }, a = "prototype", e = function() {
        var r = i(102)("iframe"), X = L.length, W = "<", p = ">", C;
        for (r.style.display = "none", i(120).appendChild(r), r.src = "javascript:", C = r.contentWindow.document, C.open(), C.write(W + "script" + p + "document.F=Object" + W + "/script" + p), C.close(), e = C.F; X--; )
          delete e[a][L[X]];
        return e();
      };
      n.exports = Object.create || function(X, W) {
        var p;
        return X !== null ? (u[a] = c(X), p = new u(), u[a] = null, p[K] = X) : p = e(), W === void 0 ? p : Z(p, W);
      };
    },
    /* 109 */
    /***/
    function(n, l, i) {
      var c = i(96), Z = i(97), L = i(110);
      n.exports = i(100) ? Object.defineProperties : function(u, a) {
        Z(u);
        for (var e = L(a), r = e.length, X = 0, W; r > X; )
          c.f(u, W = e[X++], a[W]);
        return u;
      };
    },
    /* 110 */
    /***/
    function(n, l, i) {
      var c = i(111), Z = i(119);
      n.exports = Object.keys || function(K) {
        return c(K, Z);
      };
    },
    /* 111 */
    /***/
    function(n, l, i) {
      var c = i(105), Z = i(84), L = i(112)(!1), K = i(116)("IE_PROTO");
      n.exports = function(u, a) {
        var e = Z(u), r = 0, X = [], W;
        for (W in e)
          W != K && c(e, W) && X.push(W);
        for (; a.length > r; )
          c(e, W = a[r++]) && (~L(X, W) || X.push(W));
        return X;
      };
    },
    /* 112 */
    /***/
    function(n, l, i) {
      var c = i(84), Z = i(113), L = i(115);
      n.exports = function(K) {
        return function(u, a, e) {
          var r = c(u), X = Z(r.length), W = L(e, X), p;
          if (K && a != a) {
            for (; X > W; )
              if (p = r[W++], p != p)
                return !0;
          } else
            for (; X > W; W++)
              if ((K || W in r) && r[W] === a)
                return K || W || 0;
          return !K && -1;
        };
      };
    },
    /* 113 */
    /***/
    function(n, l, i) {
      var c = i(114), Z = Math.min;
      n.exports = function(L) {
        return L > 0 ? Z(c(L), 9007199254740991) : 0;
      };
    },
    /* 114 */
    /***/
    function(n, l) {
      var i = Math.ceil, c = Math.floor;
      n.exports = function(Z) {
        return isNaN(Z = +Z) ? 0 : (Z > 0 ? c : i)(Z);
      };
    },
    /* 115 */
    /***/
    function(n, l, i) {
      var c = i(114), Z = Math.max, L = Math.min;
      n.exports = function(K, u) {
        return K = c(K), K < 0 ? Z(K + u, 0) : L(K, u);
      };
    },
    /* 116 */
    /***/
    function(n, l, i) {
      var c = i(117)("keys"), Z = i(118);
      n.exports = function(L) {
        return c[L] || (c[L] = Z(L));
      };
    },
    /* 117 */
    /***/
    function(n, l, i) {
      var c = i(92), Z = i(91), L = "__core-js_shared__", K = Z[L] || (Z[L] = {});
      (n.exports = function(u, a) {
        return K[u] || (K[u] = a !== void 0 ? a : {});
      })("versions", []).push({
        version: c.version,
        mode: i(89) ? "pure" : "global",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
      });
    },
    /* 118 */
    /***/
    function(n, l) {
      var i = 0, c = Math.random();
      n.exports = function(Z) {
        return "Symbol(".concat(Z === void 0 ? "" : Z, ")_", (++i + c).toString(36));
      };
    },
    /* 119 */
    /***/
    function(n, l) {
      n.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    },
    /* 120 */
    /***/
    function(n, l, i) {
      var c = i(91).document;
      n.exports = c && c.documentElement;
    },
    /* 121 */
    /***/
    function(n, l, i) {
      var c = i(96).f, Z = i(105), L = i(122)("toStringTag");
      n.exports = function(K, u, a) {
        K && !Z(K = a ? K : K.prototype, L) && c(K, L, { configurable: !0, value: u });
      };
    },
    /* 122 */
    /***/
    function(n, l, i) {
      var c = i(117)("wks"), Z = i(118), L = i(91).Symbol, K = typeof L == "function", u = n.exports = function(a) {
        return c[a] || (c[a] = K && L[a] || (K ? L : Z)("Symbol." + a));
      };
      u.store = c;
    },
    /* 123 */
    /***/
    function(n, l, i) {
      var c = i(105), Z = i(124), L = i(116)("IE_PROTO"), K = Object.prototype;
      n.exports = Object.getPrototypeOf || function(u) {
        return u = Z(u), c(u, L) ? u[L] : typeof u.constructor == "function" && u instanceof u.constructor ? u.constructor.prototype : u instanceof Object ? K : null;
      };
    },
    /* 124 */
    /***/
    function(n, l, i) {
      var c = i(87);
      n.exports = function(Z) {
        return Object(c(Z));
      };
    },
    /* 125 */
    /***/
    function(n, l, i) {
      var c = i(126)(!0);
      i(88)(String, "String", function(Z) {
        this._t = String(Z), this._i = 0;
      }, function() {
        var Z = this._t, L = this._i, K;
        return L >= Z.length ? { value: void 0, done: !0 } : (K = c(Z, L), this._i += K.length, { value: K, done: !1 });
      });
    },
    /* 126 */
    /***/
    function(n, l, i) {
      var c = i(114), Z = i(87);
      n.exports = function(L) {
        return function(K, u) {
          var a = String(Z(K)), e = c(u), r = a.length, X, W;
          return e < 0 || e >= r ? L ? "" : void 0 : (X = a.charCodeAt(e), X < 55296 || X > 56319 || e + 1 === r || (W = a.charCodeAt(e + 1)) < 56320 || W > 57343 ? L ? a.charAt(e) : X : L ? a.slice(e, e + 2) : (X - 55296 << 10) + (W - 56320) + 65536);
        };
      };
    },
    /* 127 */
    /***/
    function(n, l, i) {
      var c = i(128), Z = i(122)("iterator"), L = i(83);
      n.exports = i(92).isIterable = function(K) {
        var u = Object(K);
        return u[Z] !== void 0 || "@@iterator" in u || L.hasOwnProperty(c(u));
      };
    },
    /* 128 */
    /***/
    function(n, l, i) {
      var c = i(86), Z = i(122)("toStringTag"), L = c(/* @__PURE__ */ function() {
        return arguments;
      }()) == "Arguments", K = function(u, a) {
        try {
          return u[a];
        } catch {
        }
      };
      n.exports = function(u) {
        var a, e, r;
        return u === void 0 ? "Undefined" : u === null ? "Null" : typeof (e = K(a = Object(u), Z)) == "string" ? e : L ? c(a) : (r = c(a)) == "Object" && typeof a.callee == "function" ? "Arguments" : r;
      };
    },
    /* 129 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(130), __esModule: !0 };
    },
    /* 130 */
    /***/
    function(n, l, i) {
      i(79), i(125), n.exports = i(131);
    },
    /* 131 */
    /***/
    function(n, l, i) {
      var c = i(97), Z = i(132);
      n.exports = i(92).getIterator = function(L) {
        var K = Z(L);
        if (typeof K != "function")
          throw TypeError(L + " is not iterable!");
        return c(K.call(L));
      };
    },
    /* 132 */
    /***/
    function(n, l, i) {
      var c = i(128), Z = i(122)("iterator"), L = i(83);
      n.exports = i(92).getIteratorMethod = function(K) {
        if (K != null)
          return K[Z] || K["@@iterator"] || L[c(K)];
      };
    },
    /* 133 */
    /***/
    function(n, l, i) {
      l.__esModule = !0;
      var c = i(134), Z = L(c);
      function L(K) {
        return K && K.__esModule ? K : { default: K };
      }
      l.default = function(K) {
        if (Array.isArray(K)) {
          for (var u = 0, a = Array(K.length); u < K.length; u++)
            a[u] = K[u];
          return a;
        } else
          return (0, Z.default)(K);
      };
    },
    /* 134 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(135), __esModule: !0 };
    },
    /* 135 */
    /***/
    function(n, l, i) {
      i(125), i(136), n.exports = i(92).Array.from;
    },
    /* 136 */
    /***/
    function(n, l, i) {
      var c = i(93), Z = i(90), L = i(124), K = i(137), u = i(138), a = i(113), e = i(139), r = i(132);
      Z(Z.S + Z.F * !i(140)(function(X) {
        Array.from(X);
      }), "Array", {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function(W) {
          var p = L(W), C = typeof this == "function" ? this : Array, I = arguments.length, o = I > 1 ? arguments[1] : void 0, G = o !== void 0, d = 0, t = r(p), s, b, V, S;
          if (G && (o = c(o, I > 2 ? arguments[2] : void 0, 2)), t != null && !(C == Array && u(t)))
            for (S = t.call(p), b = new C(); !(V = S.next()).done; d++)
              e(b, d, G ? K(S, o, [V.value, d], !0) : V.value);
          else
            for (s = a(p.length), b = new C(s); s > d; d++)
              e(b, d, G ? o(p[d], d) : p[d]);
          return b.length = d, b;
        }
      });
    },
    /* 137 */
    /***/
    function(n, l, i) {
      var c = i(97);
      n.exports = function(Z, L, K, u) {
        try {
          return u ? L(c(K)[0], K[1]) : L(K);
        } catch (e) {
          var a = Z.return;
          throw a !== void 0 && c(a.call(Z)), e;
        }
      };
    },
    /* 138 */
    /***/
    function(n, l, i) {
      var c = i(83), Z = i(122)("iterator"), L = Array.prototype;
      n.exports = function(K) {
        return K !== void 0 && (c.Array === K || L[Z] === K);
      };
    },
    /* 139 */
    /***/
    function(n, l, i) {
      var c = i(96), Z = i(104);
      n.exports = function(L, K, u) {
        K in L ? c.f(L, K, Z(0, u)) : L[K] = u;
      };
    },
    /* 140 */
    /***/
    function(n, l, i) {
      var c = i(122)("iterator"), Z = !1;
      try {
        var L = [7][c]();
        L.return = function() {
          Z = !0;
        }, Array.from(L, function() {
          throw 2;
        });
      } catch {
      }
      n.exports = function(K, u) {
        if (!u && !Z)
          return !1;
        var a = !1;
        try {
          var e = [7], r = e[c]();
          r.next = function() {
            return { done: a = !0 };
          }, e[c] = function() {
            return r;
          }, K(e);
        } catch {
        }
        return a;
      };
    },
    /* 141 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(142), __esModule: !0 };
    },
    /* 142 */
    /***/
    function(n, l, i) {
      i(143), i(125), i(79), i(144), i(157), i(160), i(162), n.exports = i(92).Map;
    },
    /* 143 */
    /***/
    function(n, l) {
    },
    /* 144 */
    /***/
    function(n, l, i) {
      var c = i(145), Z = i(151), L = "Map";
      n.exports = i(152)(L, function(K) {
        return function() {
          return K(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function(u) {
          var a = c.getEntry(Z(this, L), u);
          return a && a.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function(u, a) {
          return c.def(Z(this, L), u === 0 ? 0 : u, a);
        }
      }, c, !0);
    },
    /* 145 */
    /***/
    function(n, l, i) {
      var c = i(96).f, Z = i(108), L = i(146), K = i(93), u = i(147), a = i(148), e = i(88), r = i(82), X = i(149), W = i(100), p = i(150).fastKey, C = i(151), I = W ? "_s" : "size", o = function(G, d) {
        var t = p(d), s;
        if (t !== "F")
          return G._i[t];
        for (s = G._f; s; s = s.n)
          if (s.k == d)
            return s;
      };
      n.exports = {
        getConstructor: function(G, d, t, s) {
          var b = G(function(V, S) {
            u(V, b, d, "_i"), V._t = d, V._i = Z(null), V._f = void 0, V._l = void 0, V[I] = 0, S != null && a(S, t, V[s], V);
          });
          return L(b.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function() {
              for (var S = C(this, d), Y = S._i, T = S._f; T; T = T.n)
                T.r = !0, T.p && (T.p = T.p.n = void 0), delete Y[T.i];
              S._f = S._l = void 0, S[I] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            delete: function(V) {
              var S = C(this, d), Y = o(S, V);
              if (Y) {
                var T = Y.n, y = Y.p;
                delete S._i[Y.i], Y.r = !0, y && (y.n = T), T && (T.p = y), S._f == Y && (S._f = T), S._l == Y && (S._l = y), S[I]--;
              }
              return !!Y;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function(S) {
              C(this, d);
              for (var Y = K(S, arguments.length > 1 ? arguments[1] : void 0, 3), T; T = T ? T.n : this._f; )
                for (Y(T.v, T.k, this); T && T.r; )
                  T = T.p;
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function(S) {
              return !!o(C(this, d), S);
            }
          }), W && c(b.prototype, "size", {
            get: function() {
              return C(this, d)[I];
            }
          }), b;
        },
        def: function(G, d, t) {
          var s = o(G, d), b, V;
          return s ? s.v = t : (G._l = s = {
            i: V = p(d, !0),
            // <- index
            k: d,
            // <- key
            v: t,
            // <- value
            p: b = G._l,
            // <- previous entry
            n: void 0,
            // <- next entry
            r: !1
            // <- removed
          }, G._f || (G._f = s), b && (b.n = s), G[I]++, V !== "F" && (G._i[V] = s)), G;
        },
        getEntry: o,
        setStrong: function(G, d, t) {
          e(G, d, function(s, b) {
            this._t = C(s, d), this._k = b, this._l = void 0;
          }, function() {
            for (var s = this, b = s._k, V = s._l; V && V.r; )
              V = V.p;
            return !s._t || !(s._l = V = V ? V.n : s._t._f) ? (s._t = void 0, r(1)) : b == "keys" ? r(0, V.k) : b == "values" ? r(0, V.v) : r(0, [V.k, V.v]);
          }, t ? "entries" : "values", !t, !0), X(d);
        }
      };
    },
    /* 146 */
    /***/
    function(n, l, i) {
      var c = i(95);
      n.exports = function(Z, L, K) {
        for (var u in L)
          K && Z[u] ? Z[u] = L[u] : c(Z, u, L[u]);
        return Z;
      };
    },
    /* 147 */
    /***/
    function(n, l) {
      n.exports = function(i, c, Z, L) {
        if (!(i instanceof c) || L !== void 0 && L in i)
          throw TypeError(Z + ": incorrect invocation!");
        return i;
      };
    },
    /* 148 */
    /***/
    function(n, X, i) {
      var c = i(93), Z = i(137), L = i(138), K = i(97), u = i(113), a = i(132), e = {}, r = {}, X = n.exports = function(W, p, C, I, o) {
        var G = o ? function() {
          return W;
        } : a(W), d = c(C, I, p ? 2 : 1), t = 0, s, b, V, S;
        if (typeof G != "function")
          throw TypeError(W + " is not iterable!");
        if (L(G)) {
          for (s = u(W.length); s > t; t++)
            if (S = p ? d(K(b = W[t])[0], b[1]) : d(W[t]), S === e || S === r)
              return S;
        } else
          for (V = G.call(W); !(b = V.next()).done; )
            if (S = Z(V, d, b.value, p), S === e || S === r)
              return S;
      };
      X.BREAK = e, X.RETURN = r;
    },
    /* 149 */
    /***/
    function(n, l, i) {
      var c = i(91), Z = i(92), L = i(96), K = i(100), u = i(122)("species");
      n.exports = function(a) {
        var e = typeof Z[a] == "function" ? Z[a] : c[a];
        K && e && !e[u] && L.f(e, u, {
          configurable: !0,
          get: function() {
            return this;
          }
        });
      };
    },
    /* 150 */
    /***/
    function(n, l, i) {
      var c = i(118)("meta"), Z = i(98), L = i(105), K = i(96).f, u = 0, a = Object.isExtensible || function() {
        return !0;
      }, e = !i(101)(function() {
        return a(Object.preventExtensions({}));
      }), r = function(I) {
        K(I, c, { value: {
          i: "O" + ++u,
          // object ID
          w: {}
          // weak collections IDs
        } });
      }, X = function(I, o) {
        if (!Z(I))
          return typeof I == "symbol" ? I : (typeof I == "string" ? "S" : "P") + I;
        if (!L(I, c)) {
          if (!a(I))
            return "F";
          if (!o)
            return "E";
          r(I);
        }
        return I[c].i;
      }, W = function(I, o) {
        if (!L(I, c)) {
          if (!a(I))
            return !0;
          if (!o)
            return !1;
          r(I);
        }
        return I[c].w;
      }, p = function(I) {
        return e && C.NEED && a(I) && !L(I, c) && r(I), I;
      }, C = n.exports = {
        KEY: c,
        NEED: !1,
        fastKey: X,
        getWeak: W,
        onFreeze: p
      };
    },
    /* 151 */
    /***/
    function(n, l, i) {
      var c = i(98);
      n.exports = function(Z, L) {
        if (!c(Z) || Z._t !== L)
          throw TypeError("Incompatible receiver, " + L + " required!");
        return Z;
      };
    },
    /* 152 */
    /***/
    function(n, l, i) {
      var c = i(91), Z = i(90), L = i(150), K = i(101), u = i(95), a = i(146), e = i(148), r = i(147), X = i(98), W = i(121), p = i(96).f, C = i(153)(0), I = i(100);
      n.exports = function(o, G, d, t, s, b) {
        var V = c[o], S = V, Y = s ? "set" : "add", T = S && S.prototype, y = {};
        return !I || typeof S != "function" || !(b || T.forEach && !K(function() {
          new S().entries().next();
        })) ? (S = t.getConstructor(G, o, s, Y), a(S.prototype, d), L.NEED = !0) : (S = G(function(J, N) {
          r(J, S, o, "_c"), J._c = new V(), N != null && e(N, s, J[Y], J);
        }), C("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(J) {
          var N = J == "add" || J == "set";
          J in T && !(b && J == "clear") && u(S.prototype, J, function(R, x) {
            if (r(this, S, J), !N && b && !X(R))
              return J == "get" ? void 0 : !1;
            var M = this._c[J](R === 0 ? 0 : R, x);
            return N ? this : M;
          });
        }), b || p(S.prototype, "size", {
          get: function() {
            return this._c.size;
          }
        })), W(S, o), y[o] = S, Z(Z.G + Z.W + Z.F, y), b || t.setStrong(S, o, s), S;
      };
    },
    /* 153 */
    /***/
    function(n, l, i) {
      var c = i(93), Z = i(85), L = i(124), K = i(113), u = i(154);
      n.exports = function(a, e) {
        var r = a == 1, X = a == 2, W = a == 3, p = a == 4, C = a == 6, I = a == 5 || C, o = e || u;
        return function(G, d, t) {
          for (var s = L(G), b = Z(s), V = c(d, t, 3), S = K(b.length), Y = 0, T = r ? o(G, S) : X ? o(G, 0) : void 0, y, J; S > Y; Y++)
            if ((I || Y in b) && (y = b[Y], J = V(y, Y, s), a)) {
              if (r)
                T[Y] = J;
              else if (J)
                switch (a) {
                  case 3:
                    return !0;
                  case 5:
                    return y;
                  case 6:
                    return Y;
                  case 2:
                    T.push(y);
                }
              else if (p)
                return !1;
            }
          return C ? -1 : W || p ? p : T;
        };
      };
    },
    /* 154 */
    /***/
    function(n, l, i) {
      var c = i(155);
      n.exports = function(Z, L) {
        return new (c(Z))(L);
      };
    },
    /* 155 */
    /***/
    function(n, l, i) {
      var c = i(98), Z = i(156), L = i(122)("species");
      n.exports = function(K) {
        var u;
        return Z(K) && (u = K.constructor, typeof u == "function" && (u === Array || Z(u.prototype)) && (u = void 0), c(u) && (u = u[L], u === null && (u = void 0))), u === void 0 ? Array : u;
      };
    },
    /* 156 */
    /***/
    function(n, l, i) {
      var c = i(86);
      n.exports = Array.isArray || function(L) {
        return c(L) == "Array";
      };
    },
    /* 157 */
    /***/
    function(n, l, i) {
      var c = i(90);
      c(c.P + c.R, "Map", { toJSON: i(158)("Map") });
    },
    /* 158 */
    /***/
    function(n, l, i) {
      var c = i(128), Z = i(159);
      n.exports = function(L) {
        return function() {
          if (c(this) != L)
            throw TypeError(L + "#toJSON isn't generic");
          return Z(this);
        };
      };
    },
    /* 159 */
    /***/
    function(n, l, i) {
      var c = i(148);
      n.exports = function(Z, L) {
        var K = [];
        return c(Z, !1, K.push, K, L), K;
      };
    },
    /* 160 */
    /***/
    function(n, l, i) {
      i(161)("Map");
    },
    /* 161 */
    /***/
    function(n, l, i) {
      var c = i(90);
      n.exports = function(Z) {
        c(c.S, Z, { of: function() {
          for (var K = arguments.length, u = new Array(K); K--; )
            u[K] = arguments[K];
          return new this(u);
        } });
      };
    },
    /* 162 */
    /***/
    function(n, l, i) {
      i(163)("Map");
    },
    /* 163 */
    /***/
    function(n, l, i) {
      var c = i(90), Z = i(94), L = i(93), K = i(148);
      n.exports = function(u) {
        c(c.S, u, { from: function(e) {
          var r = arguments[1], X, W, p, C;
          return Z(this), X = r !== void 0, X && Z(r), e == null ? new this() : (W = [], X ? (p = 0, C = L(r, arguments[2], 2), K(e, !1, function(I) {
            W.push(C(I, p++));
          })) : K(e, !1, W.push, W), new this(W));
        } });
      };
    },
    /* 164 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(165), __esModule: !0 };
    },
    /* 165 */
    /***/
    function(n, l, i) {
      i(166), n.exports = i(92).Object.assign;
    },
    /* 166 */
    /***/
    function(n, l, i) {
      var c = i(90);
      c(c.S + c.F, "Object", { assign: i(167) });
    },
    /* 167 */
    /***/
    function(n, l, i) {
      var c = i(100), Z = i(110), L = i(168), K = i(169), u = i(124), a = i(85), e = Object.assign;
      n.exports = !e || i(101)(function() {
        var r = {}, X = {}, W = Symbol(), p = "abcdefghijklmnopqrst";
        return r[W] = 7, p.split("").forEach(function(C) {
          X[C] = C;
        }), e({}, r)[W] != 7 || Object.keys(e({}, X)).join("") != p;
      }) ? function(X, W) {
        for (var p = u(X), C = arguments.length, I = 1, o = L.f, G = K.f; C > I; )
          for (var d = a(arguments[I++]), t = o ? Z(d).concat(o(d)) : Z(d), s = t.length, b = 0, V; s > b; )
            V = t[b++], (!c || G.call(d, V)) && (p[V] = d[V]);
        return p;
      } : e;
    },
    /* 168 */
    /***/
    function(n, l) {
      l.f = Object.getOwnPropertySymbols;
    },
    /* 169 */
    /***/
    function(n, l) {
      l.f = {}.propertyIsEnumerable;
    },
    /* 170 */
    /***/
    function(n, l, i) {
      l.__esModule = !0, l.default = function(c, Z) {
        if (!(c instanceof Z))
          throw new TypeError("Cannot call a class as a function");
      };
    },
    /* 171 */
    /***/
    function(n, l, i) {
      l.__esModule = !0;
      var c = i(172), Z = L(c);
      function L(K) {
        return K && K.__esModule ? K : { default: K };
      }
      l.default = /* @__PURE__ */ function() {
        function K(u, a) {
          for (var e = 0; e < a.length; e++) {
            var r = a[e];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), (0, Z.default)(u, r.key, r);
          }
        }
        return function(u, a, e) {
          return a && K(u.prototype, a), e && K(u, e), u;
        };
      }();
    },
    /* 172 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(173), __esModule: !0 };
    },
    /* 173 */
    /***/
    function(n, l, i) {
      i(174);
      var c = i(92).Object;
      n.exports = function(L, K, u) {
        return c.defineProperty(L, K, u);
      };
    },
    /* 174 */
    /***/
    function(n, l, i) {
      var c = i(90);
      c(c.S + c.F * !i(100), "Object", { defineProperty: i(96).f });
    },
    /* 175 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(176), __esModule: !0 };
    },
    /* 176 */
    /***/
    function(n, l, i) {
      i(177), i(143), i(184), i(185), n.exports = i(92).Symbol;
    },
    /* 177 */
    /***/
    function(n, l, i) {
      var c = i(91), Z = i(105), L = i(100), K = i(90), u = i(106), a = i(150).KEY, e = i(101), r = i(117), X = i(121), W = i(118), p = i(122), C = i(178), I = i(179), o = i(180), G = i(156), d = i(97), t = i(98), s = i(124), b = i(84), V = i(103), S = i(104), Y = i(108), T = i(181), y = i(183), J = i(168), N = i(96), R = i(110), x = y.f, M = N.f, Q = T.f, P = c.Symbol, D = c.JSON, _ = D && D.stringify, F = "prototype", v = p("_hidden"), O = p("toPrimitive"), li = {}.propertyIsEnumerable, ii = r("symbol-registry"), ti = r("symbols"), $ = r("op-symbols"), ai = Object[F], Xi = typeof P == "function" && !!J.f, z = c.QObject, k = !z || !z[F] || !z[F].findChild, j = L && e(function() {
        return Y(M({}, "a", {
          get: function() {
            return M(this, "a", { value: 7 }).a;
          }
        })).a != 7;
      }) ? function(mi, ci, ni) {
        var Gi = x(ai, ci);
        Gi && delete ai[ci], M(mi, ci, ni), Gi && mi !== ai && M(ai, ci, Gi);
      } : M, A = function(mi) {
        var ci = ti[mi] = Y(P[F]);
        return ci._k = mi, ci;
      }, H = Xi && typeof P.iterator == "symbol" ? function(mi) {
        return typeof mi == "symbol";
      } : function(mi) {
        return mi instanceof P;
      }, U = function(ci, ni, Gi) {
        return ci === ai && U($, ni, Gi), d(ci), ni = V(ni, !0), d(Gi), Z(ti, ni) ? (Gi.enumerable ? (Z(ci, v) && ci[v][ni] && (ci[v][ni] = !1), Gi = Y(Gi, { enumerable: S(0, !1) })) : (Z(ci, v) || M(ci, v, S(1, {})), ci[v][ni] = !0), j(ci, ni, Gi)) : M(ci, ni, Gi);
      }, m = function(ci, ni) {
        d(ci);
        for (var Gi = o(ni = b(ni)), Vi = 0, Wi = Gi.length, Ii; Wi > Vi; )
          U(ci, Ii = Gi[Vi++], ni[Ii]);
        return ci;
      }, h = function(ci, ni) {
        return ni === void 0 ? Y(ci) : m(Y(ci), ni);
      }, g = function(ci) {
        var ni = li.call(this, ci = V(ci, !0));
        return this === ai && Z(ti, ci) && !Z($, ci) ? !1 : ni || !Z(this, ci) || !Z(ti, ci) || Z(this, v) && this[v][ci] ? ni : !0;
      }, f = function(ci, ni) {
        if (ci = b(ci), ni = V(ni, !0), !(ci === ai && Z(ti, ni) && !Z($, ni))) {
          var Gi = x(ci, ni);
          return Gi && Z(ti, ni) && !(Z(ci, v) && ci[v][ni]) && (Gi.enumerable = !0), Gi;
        }
      }, w = function(ci) {
        for (var ni = Q(b(ci)), Gi = [], Vi = 0, Wi; ni.length > Vi; )
          !Z(ti, Wi = ni[Vi++]) && Wi != v && Wi != a && Gi.push(Wi);
        return Gi;
      }, B = function(ci) {
        for (var ni = ci === ai, Gi = Q(ni ? $ : b(ci)), Vi = [], Wi = 0, Ii; Gi.length > Wi; )
          Z(ti, Ii = Gi[Wi++]) && (!ni || Z(ai, Ii)) && Vi.push(ti[Ii]);
        return Vi;
      };
      Xi || (P = function() {
        if (this instanceof P)
          throw TypeError("Symbol is not a constructor!");
        var ci = W(arguments.length > 0 ? arguments[0] : void 0), ni = function(Gi) {
          this === ai && ni.call($, Gi), Z(this, v) && Z(this[v], ci) && (this[v][ci] = !1), j(this, ci, S(1, Gi));
        };
        return L && k && j(ai, ci, { configurable: !0, set: ni }), A(ci);
      }, u(P[F], "toString", function() {
        return this._k;
      }), y.f = f, N.f = U, i(182).f = T.f = w, i(169).f = g, J.f = B, L && !i(89) && u(ai, "propertyIsEnumerable", g, !0), C.f = function(mi) {
        return A(p(mi));
      }), K(K.G + K.W + K.F * !Xi, { Symbol: P });
      for (var q = (
        // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
        "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(",")
      ), si = 0; q.length > si; )
        p(q[si++]);
      for (var bi = R(p.store), Zi = 0; bi.length > Zi; )
        I(bi[Zi++]);
      K(K.S + K.F * !Xi, "Symbol", {
        // 19.4.2.1 Symbol.for(key)
        for: function(mi) {
          return Z(ii, mi += "") ? ii[mi] : ii[mi] = P(mi);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function(ci) {
          if (!H(ci))
            throw TypeError(ci + " is not a symbol!");
          for (var ni in ii)
            if (ii[ni] === ci)
              return ni;
        },
        useSetter: function() {
          k = !0;
        },
        useSimple: function() {
          k = !1;
        }
      }), K(K.S + K.F * !Xi, "Object", {
        // 19.1.2.2 Object.create(O [, Properties])
        create: h,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: U,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: m,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: f,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: w,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: B
      });
      var oi = e(function() {
        J.f(1);
      });
      K(K.S + K.F * oi, "Object", {
        getOwnPropertySymbols: function(ci) {
          return J.f(s(ci));
        }
      }), D && K(K.S + K.F * (!Xi || e(function() {
        var mi = P();
        return _([mi]) != "[null]" || _({ a: mi }) != "{}" || _(Object(mi)) != "{}";
      })), "JSON", {
        stringify: function(ci) {
          for (var ni = [ci], Gi = 1, Vi, Wi; arguments.length > Gi; )
            ni.push(arguments[Gi++]);
          if (Wi = Vi = ni[1], !(!t(Vi) && ci === void 0 || H(ci)))
            return G(Vi) || (Vi = function(Ii, Ri) {
              if (typeof Wi == "function" && (Ri = Wi.call(this, Ii, Ri)), !H(Ri))
                return Ri;
            }), ni[1] = Vi, _.apply(D, ni);
        }
      }), P[F][O] || i(95)(P[F], O, P[F].valueOf), X(P, "Symbol"), X(Math, "Math", !0), X(c.JSON, "JSON", !0);
    },
    /* 178 */
    /***/
    function(n, l, i) {
      l.f = i(122);
    },
    /* 179 */
    /***/
    function(n, l, i) {
      var c = i(91), Z = i(92), L = i(89), K = i(178), u = i(96).f;
      n.exports = function(a) {
        var e = Z.Symbol || (Z.Symbol = L ? {} : c.Symbol || {});
        a.charAt(0) != "_" && !(a in e) && u(e, a, { value: K.f(a) });
      };
    },
    /* 180 */
    /***/
    function(n, l, i) {
      var c = i(110), Z = i(168), L = i(169);
      n.exports = function(K) {
        var u = c(K), a = Z.f;
        if (a)
          for (var e = a(K), r = L.f, X = 0, W; e.length > X; )
            r.call(K, W = e[X++]) && u.push(W);
        return u;
      };
    },
    /* 181 */
    /***/
    function(n, l, i) {
      var c = i(84), Z = i(182).f, L = {}.toString, K = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], u = function(a) {
        try {
          return Z(a);
        } catch {
          return K.slice();
        }
      };
      n.exports.f = function(e) {
        return K && L.call(e) == "[object Window]" ? u(e) : Z(c(e));
      };
    },
    /* 182 */
    /***/
    function(n, l, i) {
      var c = i(111), Z = i(119).concat("length", "prototype");
      l.f = Object.getOwnPropertyNames || function(K) {
        return c(K, Z);
      };
    },
    /* 183 */
    /***/
    function(n, l, i) {
      var c = i(169), Z = i(104), L = i(84), K = i(103), u = i(105), a = i(99), e = Object.getOwnPropertyDescriptor;
      l.f = i(100) ? e : function(X, W) {
        if (X = L(X), W = K(W, !0), a)
          try {
            return e(X, W);
          } catch {
          }
        if (u(X, W))
          return Z(!c.f.call(X, W), X[W]);
      };
    },
    /* 184 */
    /***/
    function(n, l, i) {
      i(179)("asyncIterator");
    },
    /* 185 */
    /***/
    function(n, l, i) {
      i(179)("observable");
    },
    /* 186 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.createNowTime = c, l.formatDelay = Z;
      function c() {
        var L = null;
        return Date.now ? L = Date.now : L = function() {
          return (/* @__PURE__ */ new Date()).getTime();
        }, L;
      }
      function Z(L) {
        return typeof L == "number" ? L = { delay: L } : "entropy" in L && (L = { delay: L.entropy, isEntropy: !0 }), L;
      }
    },
    /* 187 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.default = {
        // s - startFrame, e - endFrame
        default: function(Z, L, K, u, a) {
          return typeof Z == "number" && typeof L == "number" ? Z + (K - u) / (a - u) * (L - Z) : K - u > a - K ? L : Z;
        }
      };
    },
    /* 188 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      }), l.parseEasing = l.Easings = void 0;
      var c = i(76), Z = e(c), L = i(133), K = e(L), u = i(141), a = e(u);
      function e(G) {
        return G && G.__esModule ? G : { default: G };
      }
      var r = i(189), X = new a.default();
      function W() {
        for (var G = arguments.length, d = Array(G), t = 0; t < G; t++)
          d[t] = arguments[t];
        var s = X.get(d);
        return s || (s = r.apply(void 0, d), X.set(d, s), s);
      }
      function p(G) {
        var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "end";
        return function(t, s) {
          for (var b = 1; b < s.length; b++) {
            var V = s[b].offset;
            if (t <= V) {
              var S = s[b - 1].offset, Y = V, T = (t - S) / (Y - S), y = 1 / G, J = T / y;
              return d === "end" ? J = Math.floor(J) : J = Math.ceil(J), y * J * (Y - S) + S;
            }
          }
          return 0;
        };
      }
      function C(G) {
        var d = /^cubic-bezier\((.*)\)/, t = G.match(d);
        if (t) {
          var s = t[1].trim();
          return s = s.split(",").map(function(y) {
            return parseFloat(y.trim());
          }), W.apply(void 0, (0, K.default)(s));
        }
        if (d = /^steps\((.*)\)/, t = G.match(d), t) {
          var b = t[1].trim();
          b = b.split(",").map(function(y) {
            return y.trim();
          });
          var V = b, S = (0, Z.default)(V, 2), Y = S[0], T = S[1];
          return p(parseInt(Y, 10), T);
        }
        return G;
      }
      var I = {
        linear: function(d) {
          return d;
        },
        ease: W(0.25, 0.1, 0.25, 1),
        "ease-in": W(0.42, 0, 1, 1),
        "ease-out": W(0, 0, 0.58, 1),
        "ease-in-out": W(0.42, 0, 0.58, 1),
        // 'step-start': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     ret = offset
        //     if(p < offset){
        //       break
        //     }
        //   }
        //   return ret
        // },
        // 'step-end': function(p, frames){
        //   let ret = 0
        //   for(let i = 0; i < frames.length; i++){
        //     const {offset} = frames[i]
        //     if(p < offset){
        //       break
        //     }
        //     ret = offset
        //   }
        //   return ret
        // }
        "step-start": p(1, "start"),
        "step-end": p(1, "end")
      };
      function o(G) {
        return typeof G == "string" ? I[G] ? G = I[G] : G = C(G) : G.type === "cubic-bezier" ? G = W.apply(void 0, (0, K.default)(G.value)) : G.type === "steps" && (G = p(G.step, G.pos)), G;
      }
      l.Easings = I, l.parseEasing = o;
    },
    /* 189 */
    /***/
    function(n, l) {
      var i = 4, c = 1e-3, Z = 1e-7, L = 10, K = 11, u = 1 / (K - 1), a = typeof Float32Array == "function";
      function e(G, d) {
        return 1 - 3 * d + 3 * G;
      }
      function r(G, d) {
        return 3 * d - 6 * G;
      }
      function X(G) {
        return 3 * G;
      }
      function W(G, d, t) {
        return ((e(d, t) * G + r(d, t)) * G + X(d)) * G;
      }
      function p(G, d, t) {
        return 3 * e(d, t) * G * G + 2 * r(d, t) * G + X(d);
      }
      function C(G, d, t, s, b) {
        var V, S, Y = 0;
        do
          S = d + (t - d) / 2, V = W(S, s, b) - G, V > 0 ? t = S : d = S;
        while (Math.abs(V) > Z && ++Y < L);
        return S;
      }
      function I(G, d, t, s) {
        for (var b = 0; b < i; ++b) {
          var V = p(d, t, s);
          if (V === 0)
            return d;
          var S = W(d, t, s) - G;
          d -= S / V;
        }
        return d;
      }
      function o(G) {
        return G;
      }
      n.exports = function(d, t, s, b) {
        if (!(0 <= d && d <= 1 && 0 <= s && s <= 1))
          throw new Error("bezier x values must be in [0, 1] range");
        if (d === t && s === b)
          return o;
        for (var V = a ? new Float32Array(K) : new Array(K), S = 0; S < K; ++S)
          V[S] = W(S * u, d, s);
        function Y(T) {
          for (var y = 0, J = 1, N = K - 1; J !== N && V[J] <= T; ++J)
            y += u;
          --J;
          var R = (T - V[J]) / (V[J + 1] - V[J]), x = y + R * u, M = p(x, d, s);
          return M >= c ? I(T, x, d, s) : M === 0 ? x : C(T, y, y + u, d, s);
        }
        return function(y) {
          return y === 0 ? 0 : y === 1 ? 1 : W(Y(y), t, b);
        };
      };
    },
    /* 190 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var c = i(191), Z = t(c), L = i(204), K = t(L), u = i(164), a = t(u), e = i(170), r = t(e), X = i(171), W = t(X), p = i(175), C = t(p), I = i(75), o = t(I), G = i(208), d = i(188);
      function t(M) {
        return M && M.__esModule ? M : { default: M };
      }
      var s = (0, C.default)("timing"), b = (0, C.default)("keyframes"), V = (0, C.default)("initState"), S = (0, C.default)("readyDefer"), Y = (0, C.default)("finishedDefer"), T = (0, C.default)("effects"), y = (0, C.default)("activeReadyTimer"), J = (0, C.default)("activeFinishTimer"), N = (0, C.default)("removeDefer"), R = {
        delay: 0,
        endDelay: 0,
        fill: "auto",
        iterations: 1,
        playbackRate: 1,
        direction: "normal",
        easing: "linear",
        effect: null
      }, x = function() {
        function M(Q, P, D) {
          var _ = this;
          if ((0, r.default)(this, M), Array.isArray(Q)) {
            var F = [Q[0], Q, P];
            Q = F[0], P = F[1], D = F[2];
          }
          typeof D == "number" && (D = { duration: D }), this[s] = (0, a.default)({}, R, D), this[s].easing = (0, d.parseEasing)(this[s].easing), this[b] = (0, G.calculateFramesOffset)(P);
          var v = this[b][this[b].length - 1];
          this[V] = {}, (0, K.default)(v).forEach(function(O) {
            Object.prototype.hasOwnProperty.call(Q, O) && O !== "easing" && O !== "offset" && (_[V][O] = Q[O]);
          }), this[b] = this[b].map(function(O) {
            return (0, a.default)({}, _[V], O);
          }), this[b][0].offset !== 0 && this[b].unshift((0, a.default)({}, this[V], { offset: 0 })), v.offset < 1 && this[b].push((0, a.default)({}, v, { offset: 1 })), this[T] = {}, this.timeline = null;
        }
        return (0, W.default)(M, [{
          key: "pause",
          value: function() {
            this.timeline.playbackRate = 0;
          }
        }, {
          key: y,
          value: function() {
            var P = this;
            this[S] && !this[S].timerID && (this.timeline.currentTime < 0 ? this[S].timerID = this.timeline.setTimeout(function() {
              P[S].resolve(), delete P[S];
            }, { delay: -this.timeline.currentTime, heading: !1 }) : this[S].timerID = this.timeline.setTimeout(function() {
              P[S].resolve(), delete P[S];
            }, { delay: 0, isEntropy: !0 }));
          }
        }, {
          key: J,
          value: function() {
            var P = this, D = this[s], _ = D.duration, F = D.iterations, v = D.endDelay, O = Math.ceil(_ * F + v - this.timeline.currentTime) + 1;
            this[Y] && !this[Y].timerID && (this[Y].timerID = this.timeline.setTimeout(function() {
              P[Y].resolve(), P[N](S), P[N](Y);
            }, { delay: O, heading: !1 }), this[Y].reverseTimerID = this.timeline.setTimeout(function() {
              P[Y].resolve(), P[N](S), P[N](Y), P.timeline = null;
            }, { delay: -this[s].delay - 1, heading: !1 }));
          }
        }, {
          key: "play",
          value: function() {
            if (this.playState === "finished" && this.cancel(), this.playState === "idle") {
              if (this.playbackRate <= 0)
                return;
              var P = this[s], D = P.delay, _ = P.playbackRate, F = P.timeline;
              this.timeline = new o.default({
                originTime: D,
                playbackRate: _
              }, F), this[y](), this[J]();
            } else
              this.playState === "paused" && (this.timeline.playbackRate = this.playbackRate, this[y]());
          }
        }, {
          key: N,
          value: function(P) {
            var D = this[P], _ = this.timeline;
            D && _ && (_.clearTimeout(D.timerID), D.reverseTimerID && _.clearTimeout(D.reverseTimerID)), delete this[P];
          }
        }, {
          key: "cancel",
          value: function() {
            this[N](S), this[N](Y), this.timeline = null;
          }
        }, {
          key: "finish",
          value: function() {
            this.timeline && (this.timeline.currentTime = 1 / 0 / this.playbackRate), this[N](S), this[N](Y);
          }
        }, {
          key: "applyEffects",
          value: function(P) {
            return (0, a.default)(this[T], P);
          }
        }, {
          key: "playbackRate",
          get: function() {
            return this[s].playbackRate;
          },
          set: function(P) {
            this.timeline && (this.timeline.playbackRate = P), this[s].playbackRate = P;
          }
        }, {
          key: "playState",
          get: function() {
            var P = this.timeline, D = this[s], _ = D.iterations, F = D.duration, v = D.endDelay, O = "running";
            if (P == null)
              O = "idle";
            else if (P.paused)
              O = "paused";
            else if (P.currentTime < 0)
              O = "pending";
            else {
              var li = P.currentTime - _ * F;
              li > 0 && li < v ? O = "pending" : li >= v && (O = "finished");
            }
            return O;
          }
        }, {
          key: "progress",
          get: function() {
            if (!this.timeline)
              return 0;
            var P = this[s], D = P.duration, _ = P.iterations, F = this.timeline, v = this.playState, O = void 0;
            if (v === "idle")
              O = 0;
            else if (v === "paused" && F.currentTime < 0)
              O = 0;
            else if (v === "pending")
              if (F.currentTime < 0)
                O = 0;
              else {
                var li = F.seekLocalTime(_ * D);
                O = (0, G.periodicity)(li, D)[1] / D;
              }
            else
              (v === "running" || v === "paused") && (O = (0, G.periodicity)(F.currentTime, D)[1] / D);
            return v === "finished" && (O = (0, G.periodicity)(_, 1)[1]), O;
          }
        }, {
          key: "frame",
          get: function() {
            var P = this.playState, D = this[V], _ = this[s].fill;
            if (P === "idle")
              return D;
            var F = this.timeline.currentTime, v = this[b].slice(0), O = (0, G.getProgress)(this.timeline, this[s], this.progress), li = O.p, ii = O.inverted, ti = D;
            return F < 0 && P === "pending" ? (_ === "backwards" || _ === "both") && (ti = ii ? v[v.length - 1] : v[0]) : (P !== "pending" && P !== "finished" || _ === "forwards" || _ === "both") && (ti = (0, G.getCurrentFrame)(this[s], v, this[T], li)), ti;
          }
        }, {
          key: "timing",
          get: function() {
            return this[s];
          }
        }, {
          key: "effects",
          get: function() {
            return this[T];
          }
        }, {
          key: "baseTimeline",
          set: function(P) {
            this[s].timeline = P;
          },
          get: function() {
            return this[s].timeline;
          }
        }, {
          key: "ready",
          get: function() {
            return this[S] ? this[S].promise : this.timeline && this.timeline.currentTime >= 0 && this.playState !== "paused" ? Z.default.resolve() : (this[S] = (0, G.defer)(), this.timeline && this[y](), this[S] ? this[S].promise : Z.default.resolve());
          }
        }, {
          key: "finished",
          get: function() {
            return this.playState === "finished" ? Z.default.resolve() : (this[Y] || (this[Y] = (0, G.defer)(), this.timeline && this[J]()), this[Y].promise);
          }
        }]), M;
      }();
      l.default = x;
    },
    /* 191 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(192), __esModule: !0 };
    },
    /* 192 */
    /***/
    function(n, l, i) {
      i(143), i(125), i(79), i(193), i(202), i(203), n.exports = i(92).Promise;
    },
    /* 193 */
    /***/
    function(n, l, i) {
      var c = i(89), Z = i(91), L = i(93), K = i(128), u = i(90), a = i(98), e = i(94), r = i(147), X = i(148), W = i(194), p = i(195).set, C = i(197)(), I = i(198), o = i(199), G = i(200), d = i(201), t = "Promise", s = Z.TypeError, b = Z.process, V = b && b.versions, S = V && V.v8 || "", Y = Z[t], T = K(b) == "process", y = function() {
      }, J, N, R, x, M = N = I.f, Q = !!function() {
        try {
          var ii = Y.resolve(1), ti = (ii.constructor = {})[i(122)("species")] = function($) {
            $(y, y);
          };
          return (T || typeof PromiseRejectionEvent == "function") && ii.then(y) instanceof ti && S.indexOf("6.6") !== 0 && G.indexOf("Chrome/66") === -1;
        } catch {
        }
      }(), P = function(ii) {
        var ti;
        return a(ii) && typeof (ti = ii.then) == "function" ? ti : !1;
      }, D = function(ii, ti) {
        if (!ii._n) {
          ii._n = !0;
          var $ = ii._c;
          C(function() {
            for (var ai = ii._v, Xi = ii._s == 1, z = 0, k = function(j) {
              var A = Xi ? j.ok : j.fail, H = j.resolve, U = j.reject, m = j.domain, h, g, f;
              try {
                A ? (Xi || (ii._h == 2 && v(ii), ii._h = 1), A === !0 ? h = ai : (m && m.enter(), h = A(ai), m && (m.exit(), f = !0)), h === j.promise ? U(s("Promise-chain cycle")) : (g = P(h)) ? g.call(h, H, U) : H(h)) : U(ai);
              } catch (w) {
                m && !f && m.exit(), U(w);
              }
            }; $.length > z; )
              k($[z++]);
            ii._c = [], ii._n = !1, ti && !ii._h && _(ii);
          });
        }
      }, _ = function(ii) {
        p.call(Z, function() {
          var ti = ii._v, $ = F(ii), ai, Xi, z;
          if ($ && (ai = o(function() {
            T ? b.emit("unhandledRejection", ti, ii) : (Xi = Z.onunhandledrejection) ? Xi({ promise: ii, reason: ti }) : (z = Z.console) && z.error && z.error("Unhandled promise rejection", ti);
          }), ii._h = T || F(ii) ? 2 : 1), ii._a = void 0, $ && ai.e)
            throw ai.v;
        });
      }, F = function(ii) {
        return ii._h !== 1 && (ii._a || ii._c).length === 0;
      }, v = function(ii) {
        p.call(Z, function() {
          var ti;
          T ? b.emit("rejectionHandled", ii) : (ti = Z.onrejectionhandled) && ti({ promise: ii, reason: ii._v });
        });
      }, O = function(ii) {
        var ti = this;
        ti._d || (ti._d = !0, ti = ti._w || ti, ti._v = ii, ti._s = 2, ti._a || (ti._a = ti._c.slice()), D(ti, !0));
      }, li = function(ii) {
        var ti = this, $;
        if (!ti._d) {
          ti._d = !0, ti = ti._w || ti;
          try {
            if (ti === ii)
              throw s("Promise can't be resolved itself");
            ($ = P(ii)) ? C(function() {
              var ai = { _w: ti, _d: !1 };
              try {
                $.call(ii, L(li, ai, 1), L(O, ai, 1));
              } catch (Xi) {
                O.call(ai, Xi);
              }
            }) : (ti._v = ii, ti._s = 1, D(ti, !1));
          } catch (ai) {
            O.call({ _w: ti, _d: !1 }, ai);
          }
        }
      };
      Q || (Y = function(ti) {
        r(this, Y, t, "_h"), e(ti), J.call(this);
        try {
          ti(L(li, this, 1), L(O, this, 1));
        } catch ($) {
          O.call(this, $);
        }
      }, J = function(ti) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1;
      }, J.prototype = i(146)(Y.prototype, {
        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function(ti, $) {
          var ai = M(W(this, Y));
          return ai.ok = typeof ti == "function" ? ti : !0, ai.fail = typeof $ == "function" && $, ai.domain = T ? b.domain : void 0, this._c.push(ai), this._a && this._a.push(ai), this._s && D(this, !1), ai.promise;
        },
        // 25.4.5.1 Promise.prototype.catch(onRejected)
        catch: function(ii) {
          return this.then(void 0, ii);
        }
      }), R = function() {
        var ii = new J();
        this.promise = ii, this.resolve = L(li, ii, 1), this.reject = L(O, ii, 1);
      }, I.f = M = function(ii) {
        return ii === Y || ii === x ? new R(ii) : N(ii);
      }), u(u.G + u.W + u.F * !Q, { Promise: Y }), i(121)(Y, t), i(149)(t), x = i(92)[t], u(u.S + u.F * !Q, t, {
        // 25.4.4.5 Promise.reject(r)
        reject: function(ti) {
          var $ = M(this), ai = $.reject;
          return ai(ti), $.promise;
        }
      }), u(u.S + u.F * (c || !Q), t, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function(ti) {
          return d(c && this === x ? Y : this, ti);
        }
      }), u(u.S + u.F * !(Q && i(140)(function(ii) {
        Y.all(ii).catch(y);
      })), t, {
        // 25.4.4.1 Promise.all(iterable)
        all: function(ti) {
          var $ = this, ai = M($), Xi = ai.resolve, z = ai.reject, k = o(function() {
            var j = [], A = 0, H = 1;
            X(ti, !1, function(U) {
              var m = A++, h = !1;
              j.push(void 0), H++, $.resolve(U).then(function(g) {
                h || (h = !0, j[m] = g, --H || Xi(j));
              }, z);
            }), --H || Xi(j);
          });
          return k.e && z(k.v), ai.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function(ti) {
          var $ = this, ai = M($), Xi = ai.reject, z = o(function() {
            X(ti, !1, function(k) {
              $.resolve(k).then(ai.resolve, Xi);
            });
          });
          return z.e && Xi(z.v), ai.promise;
        }
      });
    },
    /* 194 */
    /***/
    function(n, l, i) {
      var c = i(97), Z = i(94), L = i(122)("species");
      n.exports = function(K, u) {
        var a = c(K).constructor, e;
        return a === void 0 || (e = c(a)[L]) == null ? u : Z(e);
      };
    },
    /* 195 */
    /***/
    function(n, l, i) {
      var c = i(93), Z = i(196), L = i(120), K = i(102), u = i(91), a = u.process, e = u.setImmediate, r = u.clearImmediate, X = u.MessageChannel, W = u.Dispatch, p = 0, C = {}, I = "onreadystatechange", o, G, d, t = function() {
        var b = +this;
        if (C.hasOwnProperty(b)) {
          var V = C[b];
          delete C[b], V();
        }
      }, s = function(b) {
        t.call(b.data);
      };
      (!e || !r) && (e = function(V) {
        for (var S = [], Y = 1; arguments.length > Y; )
          S.push(arguments[Y++]);
        return C[++p] = function() {
          Z(typeof V == "function" ? V : Function(V), S);
        }, o(p), p;
      }, r = function(V) {
        delete C[V];
      }, i(86)(a) == "process" ? o = function(b) {
        a.nextTick(c(t, b, 1));
      } : W && W.now ? o = function(b) {
        W.now(c(t, b, 1));
      } : X ? (G = new X(), d = G.port2, G.port1.onmessage = s, o = c(d.postMessage, d, 1)) : u.addEventListener && typeof postMessage == "function" && !u.importScripts ? (o = function(b) {
        u.postMessage(b + "", "*");
      }, u.addEventListener("message", s, !1)) : I in K("script") ? o = function(b) {
        L.appendChild(K("script"))[I] = function() {
          L.removeChild(this), t.call(b);
        };
      } : o = function(b) {
        setTimeout(c(t, b, 1), 0);
      }), n.exports = {
        set: e,
        clear: r
      };
    },
    /* 196 */
    /***/
    function(n, l) {
      n.exports = function(i, c, Z) {
        var L = Z === void 0;
        switch (c.length) {
          case 0:
            return L ? i() : i.call(Z);
          case 1:
            return L ? i(c[0]) : i.call(Z, c[0]);
          case 2:
            return L ? i(c[0], c[1]) : i.call(Z, c[0], c[1]);
          case 3:
            return L ? i(c[0], c[1], c[2]) : i.call(Z, c[0], c[1], c[2]);
          case 4:
            return L ? i(c[0], c[1], c[2], c[3]) : i.call(Z, c[0], c[1], c[2], c[3]);
        }
        return i.apply(Z, c);
      };
    },
    /* 197 */
    /***/
    function(n, l, i) {
      var c = i(91), Z = i(195).set, L = c.MutationObserver || c.WebKitMutationObserver, K = c.process, u = c.Promise, a = i(86)(K) == "process";
      n.exports = function() {
        var e, r, X, W = function() {
          var o, G;
          for (a && (o = K.domain) && o.exit(); e; ) {
            G = e.fn, e = e.next;
            try {
              G();
            } catch (d) {
              throw e ? X() : r = void 0, d;
            }
          }
          r = void 0, o && o.enter();
        };
        if (a)
          X = function() {
            K.nextTick(W);
          };
        else if (L && !(c.navigator && c.navigator.standalone)) {
          var p = !0, C = document.createTextNode("");
          new L(W).observe(C, { characterData: !0 }), X = function() {
            C.data = p = !p;
          };
        } else if (u && u.resolve) {
          var I = u.resolve(void 0);
          X = function() {
            I.then(W);
          };
        } else
          X = function() {
            Z.call(c, W);
          };
        return function(o) {
          var G = { fn: o, next: void 0 };
          r && (r.next = G), e || (e = G, X()), r = G;
        };
      };
    },
    /* 198 */
    /***/
    function(n, l, i) {
      var c = i(94);
      function Z(L) {
        var K, u;
        this.promise = new L(function(a, e) {
          if (K !== void 0 || u !== void 0)
            throw TypeError("Bad Promise constructor");
          K = a, u = e;
        }), this.resolve = c(K), this.reject = c(u);
      }
      n.exports.f = function(L) {
        return new Z(L);
      };
    },
    /* 199 */
    /***/
    function(n, l) {
      n.exports = function(i) {
        try {
          return { e: !1, v: i() };
        } catch (c) {
          return { e: !0, v: c };
        }
      };
    },
    /* 200 */
    /***/
    function(n, l, i) {
      var c = i(91), Z = c.navigator;
      n.exports = Z && Z.userAgent || "";
    },
    /* 201 */
    /***/
    function(n, l, i) {
      var c = i(97), Z = i(98), L = i(198);
      n.exports = function(K, u) {
        if (c(K), Z(u) && u.constructor === K)
          return u;
        var a = L.f(K), e = a.resolve;
        return e(u), a.promise;
      };
    },
    /* 202 */
    /***/
    function(n, l, i) {
      var c = i(90), Z = i(92), L = i(91), K = i(194), u = i(201);
      c(c.P + c.R, "Promise", { finally: function(a) {
        var e = K(this, Z.Promise || L.Promise), r = typeof a == "function";
        return this.then(
          r ? function(X) {
            return u(e, a()).then(function() {
              return X;
            });
          } : a,
          r ? function(X) {
            return u(e, a()).then(function() {
              throw X;
            });
          } : a
        );
      } });
    },
    /* 203 */
    /***/
    function(n, l, i) {
      var c = i(90), Z = i(198), L = i(199);
      c(c.S, "Promise", { try: function(K) {
        var u = Z.f(this), a = L(K);
        return (a.e ? u.reject : u.resolve)(a.v), u.promise;
      } });
    },
    /* 204 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(205), __esModule: !0 };
    },
    /* 205 */
    /***/
    function(n, l, i) {
      i(206), n.exports = i(92).Object.keys;
    },
    /* 206 */
    /***/
    function(n, l, i) {
      var c = i(124), Z = i(110);
      i(207)("keys", function() {
        return function(K) {
          return Z(c(K));
        };
      });
    },
    /* 207 */
    /***/
    function(n, l, i) {
      var c = i(90), Z = i(92), L = i(101);
      n.exports = function(K, u) {
        var a = (Z.Object || {})[K] || Object[K], e = {};
        e[K] = u(a), c(c.S + c.F * L(function() {
          a(1);
        }), "Object", e);
      };
    },
    /* 208 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", {
        value: !0
      });
      var c = i(76), Z = C(c), L = i(209), K = C(L), u = i(164), a = C(u), e = i(191), r = C(e);
      l.defer = I, l.periodicity = o, l.calculateFramesOffset = G, l.getProgress = d, l.getCurrentFrame = s;
      var X = i(188), W = i(187), p = C(W);
      function C(b) {
        return b && b.__esModule ? b : { default: b };
      }
      function I() {
        var b = {};
        return b.promise = new r.default(function(V, S) {
          b.resolve = V, b.reject = S;
        }), b;
      }
      function o(b, V) {
        var S = Math.floor(b / V), Y = b - S * V;
        return Y === 0 && S > 0 && (Y = V, S--), [S, Y];
      }
      function G(b) {
        b = b.slice(0);
        var V = b[0], S = b[b.length - 1];
        S.offset = S.offset || 1, V.offset = V.offset || 0;
        for (var Y = 0, T = -1, y = 0; y < b.length; y++) {
          var J = b[y];
          if (J.offset != null) {
            var N = y - T;
            if (N > 1)
              for (var R = (J.offset - Y) / N, x = 0; x < N - 1; x++)
                b[T + x + 1].offset = Y + R * (x + 1);
            Y = J.offset, T = y;
          }
          if (J.easing != null && (J.easing = (0, X.parseEasing)(J.easing)), y > 0) {
            var M = b[y].easing != null;
            b[y] = (0, a.default)({}, b[y - 1], b[y]), M || delete b[y].easing;
          }
        }
        return b;
      }
      function d(b, V, S) {
        var Y = b.currentTime, T = V.direction, y = V.duration, J = !1;
        if (T === "reverse")
          S = 1 - S, J = !0;
        else if (T === "alternate" || T === "alternate-reverse") {
          var N = Math.floor(Y / y);
          S === 1 && N--, N % 2 ^ T === "alternate-reverse" && (S = 1 - S, J = !0);
        }
        return { p: S, inverted: J };
      }
      function t(b, V, S, Y) {
        var T = {};
        return (0, K.default)(V).forEach(function(y) {
          var J = (0, Z.default)(y, 2), N = J[0], R = J[1];
          if (N !== "offset" && N !== "easing") {
            var x = S[N] || S.default, M = x(b[N], R, Y, b.offset, V.offset);
            M != null && (T[N] = M);
          }
        }), T;
      }
      function s(b, V, S, Y) {
        var T = b.easing, y = b.effect;
        y || (S = (0, a.default)({}, p.default, S));
        var J = {};
        Y = T(Y, V);
        for (var N = 1; N < V.length; N++) {
          var R = V[N], x = R.offset;
          if (x >= Y || N === V.length - 1) {
            var M = V[N - 1], Q = M.offset, P = M.easing, D = Y;
            if (P) {
              var _ = x - Q;
              D = P((Y - Q) / _) * _ + Q;
            }
            y ? J = y(M, R, D, Q, x) : J = t(M, R, S, D);
            break;
          }
        }
        return J;
      }
    },
    /* 209 */
    /***/
    function(n, l, i) {
      n.exports = { default: i(210), __esModule: !0 };
    },
    /* 210 */
    /***/
    function(n, l, i) {
      i(211), n.exports = i(92).Object.entries;
    },
    /* 211 */
    /***/
    function(n, l, i) {
      var c = i(90), Z = i(212)(!0);
      c(c.S, "Object", {
        entries: function(K) {
          return Z(K);
        }
      });
    },
    /* 212 */
    /***/
    function(n, l, i) {
      var c = i(100), Z = i(110), L = i(84), K = i(169).f;
      n.exports = function(u) {
        return function(a) {
          for (var e = L(a), r = Z(e), X = r.length, W = 0, p = [], C; X > W; )
            C = r[W++], (!c || K.call(e, C)) && p.push(u ? [C, e[C]] : e[C]);
          return p;
        };
      };
    },
    /* 213 */
    /***/
    function(n, l, i) {
      i.r(l), i(1).glMatrix.setMatrixArrayType(Array);
      const c = /* @__PURE__ */ new Map();
      function Z(K, u = {}, a = []) {
        K = K.toLowerCase();
        const e = c.get(K);
        if (!e)
          throw new TypeError(`Invalid node: ${K}`);
        const r = new e(u);
        return a.forEach((X) => {
          r.appendChild(X);
        }), r;
      }
      const L = {
        registerNode(K, u, a = 100) {
          if (u = u.toLowerCase(), c.has(u))
            throw new TypeError(`Cannot registerNode, ${u} has been taken.`);
          c.set(u, K), Object.defineProperties(K.prototype, {
            nodeType: {
              value: a
            },
            tagName: {
              value: u.toUpperCase()
            },
            nodeName: {
              value: u
            },
            ownerDocument: {
              value: L
            },
            namespaceURI: {
              value: `http://spritejs.com/${u}`
            }
          });
        },
        createElement: Z,
        createElementNS(K, u) {
          return Z(u);
        },
        isSpriteNode(K) {
          return c.has(K.toLowerCase());
        }
      };
      l.default = L;
    },
    /* 214 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      const c = Symbol("type"), Z = Symbol("bubbles"), L = Symbol("originalEvent"), K = Symbol("detail");
      class u {
        constructor(e, {
          bubbles: r = null
        } = {}) {
          if (typeof e == "string" ? (this[c] = e, this[Z] = !!r) : (this[c] = e.type, this[L] = e, this[Z] = r != null ? !!r : !!e.bubbles, e.detail && (this[K] = e.detail)), !this[c])
            throw new TypeError("Invalid event type.");
          this.cancelBubble = !1;
        }
        setOriginalEvent(e) {
          this[L] = e;
        }
        get originalEvent() {
          return this[L];
        }
        get type() {
          return this[c];
        }
        get bubbles() {
          return this[Z];
        }
        get detail() {
          return this[K];
        }
        stopPropagation() {
          this.cancelBubble = !0;
        }
      }
    },
    /* 215 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "parseFilterString", function() {
        return Z;
      }), i.d(l, "applyFilters", function() {
        return L;
      });
      var c = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      function Z(K) {
        if (K = K.trim(), !K || K === "none")
          return null;
        const u = /^(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+$/i, a = K.match(/(?:(url|blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)\(([^()]*(?:\(.*\))*[^()]*)\))+?/ig), e = [];
        return a && a.forEach((r) => {
          const X = r.match(u);
          if (!X)
            throw new TypeError("Invalid fitler string.");
          let [, W, p] = X;
          W = W.toLowerCase(), p = p.trim().match(/([^( )]+|([^( )]+\(.*\)))(?=\s|$)/g).map((C, I) => {
            let o;
            return W === "url" || W === "drop-shadow" && I === 3 ? o = C : o = Object(c.toNumber)(C), /%$/.test(C) && (o /= 100), o;
          }), e.push({
            type: W,
            args: p
          });
        }), e;
      }
      function L(K, u) {
        K.clearFilter(), u && u.forEach(({
          type: a,
          args: e
        }) => {
          let r = a;
          r === "drop-shadow" ? r = "dropShadow" : r === "hue-rotate" && (r = "hueRotate"), K[r](...e);
        });
      }
    },
    /* 216 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return c;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c(Z, L) {
        if (!L)
          return;
        const K = Z.getListeners("beforerender"), u = Z.getListeners("afterrender");
        K.length && !L.beforeRender ? L.beforeRender = (a) => {
          Z.dispatchEvent({
            type: "beforerender",
            detail: {
              context: a
            }
          });
        } : K.length || (L.beforeRender = null), u.length && !L.afterRender ? L.afterRender = (a) => {
          Z.dispatchEvent({
            type: "afterrender",
            detail: {
              context: a
            }
          });
        } : u.length || (L.afterRender = null);
      }
    },
    /* 217 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var c = i(12), Z = i(218), L = i(70), K = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      const u = Symbol("amount"), a = Symbol("meshCloud");
      class e extends L.default {
        constructor(X, W = 1) {
          super(), this.meshNode = X, X.connect(this), this[u] = W, this[a] = null;
        }
        get meshCloud() {
          const X = this.meshNode, W = this[u];
          return !this[a] && X.mesh && (this[a] = new c.MeshCloud(X.mesh, W)), this[a];
        }
        /* override */
        get isVisible() {
          return !!this.meshNode && this.meshNode.isVisible;
        }
        get amount() {
          return this[u];
        }
        set amount(X) {
          this[u] = X, this[a] && (this[a].amount = X);
        }
        brightness(X, W) {
          this.meshCloud && (this.meshCloud.brightness(X, W), this.forceUpdate());
        }
        contrast(X, W) {
          this.meshCloud && (this.meshCloud.contrast(X, W), this.forceUpdate());
        }
        delete(X) {
          this.meshCloud && (this.meshCloud.delete(X), this[u]--, this.forceUpdate());
        }
        /* override */
        draw(X = []) {
          if (super.draw(X), this.meshCloud) {
            if (this.program) {
              this.meshCloud.setProgram(this.program);
              const W = this.shaderAttrs;
              W && Object.entries(W).forEach(([C, I]) => {
                this.meshCloud.mesh.setAttribute(C, I);
              });
              const p = this.uniforms;
              if (this.uniforms) {
                const C = {};
                Object.entries(p).forEach(([I, o]) => {
                  typeof o == "function" && (o = o(this, I)), C[I] = o;
                }), this.meshCloud.mesh.setUniforms(C);
              }
            }
            this.meshNode.textureImage && Object(Z.drawTexture)(this.meshNode, this.meshNode.mesh), X.push(this.meshCloud);
          }
          return X;
        }
        getTransform(X) {
          if (this.meshCloud)
            return this.meshCloud.getTransform(X);
        }
        grayscale(X, W) {
          this.meshCloud && (this.meshCloud.grayscale(X, W), this.forceUpdate());
        }
        hueRotate(X, W) {
          this.meshCloud && (this.meshCloud.hueRotate(X, W), this.forceUpdate());
        }
        invert(X, W) {
          this.meshCloud && (this.meshCloud.invert(X, W), this.forceUpdate());
        }
        /* override */
        isPointCollision(X, W) {
          if (!this.meshCloud)
            return !1;
          const p = this.attributes.pointerEvents;
          if (p === "none" || p !== "all" && !this.isVisible)
            return !1;
          let C = "both";
          p === "visibleFill" && (C = "fill"), p === "visibleStroke" && (C = "stroke");
          for (let I = 0; I < this[u]; I++)
            if (!this.meshCloud.isPointCollision(I, [X, W], C))
              return !1;
          return !0;
        }
        setOpacity(X, W) {
          this.meshCloud && (this.meshCloud.opacity(X, W), this.forceUpdate());
        }
        rotate(X, W, [p, C] = [0, 0]) {
          const I = Math.PI * W / 180;
          if (this.meshCloud) {
            const {
              x: o,
              y: G
            } = this.meshNode.attributes;
            this.meshCloud.rotate(X, I, [p + o, C + G]), this.forceUpdate();
          }
        }
        saturate(X, W) {
          this.meshCloud && (this.meshCloud.saturate(X, W), this.forceUpdate());
        }
        scale(X, [W, p = W], [C, I] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: o,
              y: G
            } = this.meshNode.attributes, d = 1e-5;
            Math.abs(W) < d && (W = 1 / W > 0 ? d : -d), Math.abs(p) < d && (p = 1 / p > 0 ? d : -d), this.meshCloud.scale(X, [W, p], [C + o, I + G]), this.forceUpdate();
          }
        }
        setColorTransform(X, W) {
          this.meshCloud && (this.meshCloud.setColorTransform(X, W), this.forceUpdate());
        }
        setFillColor(X, W) {
          this.meshCloud && (Array.isArray(W) && (W = [...W], W[0] /= 255, W[1] /= 255, W[2] /= 255), this.meshCloud.setFillColor(X, W), this.forceUpdate());
        }
        sepia(X, W) {
          this.meshCloud && (this.meshCloud.sepia(X, W), this.forceUpdate());
        }
        /* override */
        setResolution({
          width: X,
          height: W
        }) {
          super.setResolution({
            width: X,
            height: W
          }), this.meshNode.setResolution({
            width: X,
            height: W
          });
        }
        setStrokeColor(X, W) {
          this.meshCloud && (Array.isArray(W) && (W = [...W], W[0] /= 255, W[1] /= 255, W[2] /= 255), this.meshCloud.setStrokeColor(X, W), this.forceUpdate());
        }
        setTransform(X, W) {
          this.meshCloud && (this.meshCloud.setTransform(X, W), this.forceUpdate());
        }
        skew(X, [W, p = W], [C, I] = [0, 0]) {
          if (this.meshCloud) {
            const {
              x: o,
              y: G
            } = this.meshNode.attributes;
            this.meshCloud.skew(X, [W, p], [C + o, I + G]), this.forceUpdate();
          }
        }
        transform(X, W) {
          this.meshCloud && (this.meshCloud.transform(X, W), this.forceUpdate());
        }
        transformColor(X, W) {
          this.meshCloud && (this.meshCloud.transformColor(X, W), this.forceUpdate());
        }
        translate(X, [W, p]) {
          this.meshCloud && (this.meshCloud.translate(X, [W, p]), this.forceUpdate());
        }
        updateMesh() {
          this[a] && (this[a].mesh = this.meshNode.mesh, this.forceUpdate());
        }
      }
      K.default.registerNode(e, "cloud");
    },
    /* 218 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "loadTexture", function() {
        return K;
      }), i.d(l, "applyTexture", function() {
        return u;
      }), i.d(l, "createTexture", function() {
        return e;
      }), i.d(l, "deleteTexture", function() {
        return r;
      }), i.d(l, "drawTexture", function() {
        return W;
      }), i.d(l, "loadFrames", function() {
        return p;
      });
      var c = i(12), Z = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const L = {};
      function K(C, I) {
        if (L[C])
          return L[C];
        const o = c.ENV.loadImage(C, {
          alias: I,
          useImageBitmap: !1
        });
        return o ?? C;
      }
      async function u(C, I, o) {
        let G = I;
        if (typeof I == "string" && (G = K(I)), G && typeof G.then == "function" && (G = await G), I === C.attributes.texture) {
          G && G.image && (G.sourceRect && (C.attributes.sourceRect = G.sourceRect), C.textureImageRotated = !!G.rotated, G = G.image);
          const {
            width: d,
            height: t,
            textureRect: s
          } = C.attributes, b = C.textureImage;
          C.textureImage = G, o && b !== G && !s && (d == null || t == null) && C.updateContours(), C.forceUpdate();
        }
        return G;
      }
      const a = Symbol("textureMap");
      function e(C, I) {
        if (I[a] = I[a] || /* @__PURE__ */ new Map(), I[a].has(C))
          return I[a].get(C);
        const o = I.createTexture(C);
        return !/^blob:/.test(C.src) && typeof C.getContext != "function" && I[a].set(C, o), o;
      }
      function r(C, I) {
        if (I[a] && I[a].has(C)) {
          const o = I[a].get(C);
          return I.deleteTexture(o), I[a].delete(C), !0;
        }
        return !1;
      }
      const X = Symbol("textureContext");
      function W(C, I) {
        const o = C.textureImage instanceof String ? String(C.textureImage) : C.textureImage, G = C.textureImageRotated, d = I.texture, t = C.renderer;
        if (o) {
          const s = C.originalContentRect;
          let b = C.attributes.textureRect;
          const V = C.attributes.textureRepeat, S = C.attributes.sourceRect;
          if (!d || C[X] && C[X] !== t || d.image !== o || d.options.repeat !== V || !Object(Z.compareValue)(d.options.rect, b) || !Object(Z.compareValue)(d.options.srcRect, S)) {
            const Y = e(o, t);
            b ? (b[0] += s[0], b[1] += s[1]) : b = s;
            let T = null;
            d && !t[a].has(d.image) && (!d.options || !d.options.hidden) && (T = I.uniforms.u_texSampler), I.setTexture(Y, {
              rect: b,
              repeat: V,
              srcRect: S,
              rotated: G
            }), T && T.delete && T.delete(), C[X] = t;
          }
        } else if (d) {
          let s = null;
          !t[a].has(d.image) && (!d.options || !d.options.hidden) && (s = I.uniforms.u_texSampler), I.setTexture(null), s && s.delete && s.delete();
        }
      }
      async function p(C, I) {
        typeof I == "string" && (I = await (await fetch(I, {
          method: "GET",
          mode: "cors",
          cache: "default"
        })).json());
        const o = await K(C), G = I.frames;
        return Object.entries(G).forEach(([d, t]) => {
          const {
            x: s,
            y: b,
            w: V,
            h: S
          } = t.frame;
          let Y = [s, b, V, S];
          const T = t.rotated;
          T && (Y = [Y[0], Y[1], Y[3], Y[2]]), L[d] = {
            image: o,
            sourceRect: Y,
            rotated: T
          };
        }), o;
      }
    },
    /* 219 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return p;
      });
      var c = i(1), Z = i(12), L = i(70), K = i(220), u = i(221), a = i(222), e = i(213), r = i(223);
      i(1).glMatrix.setMatrixArrayType(Array);
      function X(C, I, o) {
        return I in C ? Object.defineProperty(C, I, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : C[I] = o, C;
      }
      const W = Symbol("mesh");
      class p extends L.default {
        constructor(I = {}) {
          super(I);
        }
        get borderSize() {
          const {
            paddingTop: I,
            paddingRight: o,
            paddingBottom: G,
            paddingLeft: d,
            borderWidth: t
          } = this.attributes, [s, b] = this.contentSize;
          return [d + s + o + t, I + b + G + t];
        }
        // content + padding
        get clientSize() {
          const {
            paddingTop: I,
            paddingRight: o,
            paddingBottom: G,
            paddingLeft: d
          } = this.attributes, [t, s] = this.contentSize;
          return [d + t + o, I + s + G];
        }
        get contentSize() {
          let {
            width: I,
            height: o,
            boxSizing: G,
            paddingTop: d,
            paddingRight: t,
            paddingBottom: s,
            paddingLeft: b
          } = this.attributes;
          if (I = I || 0, o = o || 0, G === "border-box") {
            const V = 2 * this.attributes.borderWidth;
            I -= V + t + b, o -= V + d + s, I = Math.max(0, I), o = Math.max(0, o);
          }
          return [I, o];
        }
        get hasBorder() {
          return this.attributes.borderWidth > 0;
        }
        /* override */
        get isVisible() {
          const [I, o] = this.borderSize;
          return I > 0 && o > 0;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const I = this.clientBox;
          if (I) {
            let o = this[W];
            if (o)
              o.box !== I && (o.contours = I.contours, o.box = I);
            else {
              o = new Z.Mesh2D(I), o.box = I;
              const d = this.attributes.bgcolor;
              if (Object(u.setFillColor)(o, {
                color: d
              }), this.hasBorder) {
                const {
                  borderColor: s,
                  borderWidth: b,
                  borderDash: V,
                  borderDashOffset: S
                } = this.attributes;
                Object(u.setStrokeColor)(o, {
                  color: s,
                  lineWidth: b,
                  lineDash: V,
                  lineDashOffset: S
                });
              }
              this[W] = o;
              const t = this.attributes.clipPath;
              t && this[W].setClipPath(t);
            }
            const G = this.opacity;
            return o.getOpacity() !== G && o.setOpacity(G), o.setTransform(...this.renderMatrix), o;
          }
          return null;
        }
        // content + padding + border
        get offsetSize() {
          const {
            paddingTop: I,
            paddingRight: o,
            paddingBottom: G,
            paddingLeft: d,
            borderWidth: t
          } = this.attributes, [s, b] = this.contentSize, V = 2 * t;
          return [d + s + o + V, I + b + G + V];
        }
        get originalClientRect() {
          if (this.mesh) {
            const I = this.mesh.boundingBox;
            return [I[0][0], I[0][1], I[1][0] - I[0][0], I[1][1] - I[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalContentRect() {
          const [I, o, G, d] = this.originalClientRect, t = this.attributes.padding;
          return [I + t[0], o + t[1], G - t[0] - t[2], d - t[1] - t[3]];
        }
        getBoundingClientRect() {
          let I = this.renderMatrix;
          this.layer && this.layer.layerTransformInvert && (I = c.mat2d.multiply(Array.of(0, 0, 0, 0, 0, 0), this.layer.transformMatrix, I));
          let o = null;
          if (this.mesh) {
            o = [...this.mesh.boundingBox];
            const G = this.attributes.borderWidth;
            G && (o[0] = [o[0][0] - G, o[0][1] - G], o[1] = [o[1][0] + G, o[1][1] + G]);
          }
          return Object(r.default)(o, I);
        }
        // transformPoint(x, y) {
        //   const m = mat2d.invert(this.renderMatrix);
        //   const newX = x * m[0] + y * m[2] + m[4];
        //   const newY = x * m[1] + y * m[3] + m[5];
        //   return [newX, newY];
        // }
        /* override */
        onPropertyChange(I, o, G) {
          if (super.onPropertyChange(I, o, G), (I === "anchorX" || I === "anchorY" || I === "boxSizing" || I === "width" || I === "height" || I === "borderWidth" || I === "paddingLeft" || I === "paddingRight" || I === "paddingTop" || I === "paddingBottom" || /^border(TopLeft|TopRight|BottomRight|BottomLeft)Radius$/.test(I)) && this.updateContours(), this[W] && I === "clipPath" && this[W].setClipPath(o), this[W] && I === "bgcolor" && Object(u.setFillColor)(this[W], {
            color: o
          }), this[W] && (I === "borderColor" || I === "borderWidth" || I === "borderDash" || I === "borderDashOffset")) {
            const {
              borderColor: d,
              borderWidth: t,
              borderDash: s,
              borderDashOffset: b
            } = this.attributes;
            Object(u.setStrokeColor)(this[W], {
              color: d,
              lineWidth: t,
              lineDash: t ? s : 0,
              lineDashOffset: b
            });
          }
        }
        /* override */
        updateContours() {
          const {
            anchorX: I,
            anchorY: o,
            borderWidth: G,
            borderRadius: d
          } = this.attributes, [t, s] = this.borderSize, b = this.offsetSize, V = 0.5 * G, S = -I * b[0] + V, Y = -o * b[1] + V;
          this.clientBox = new Z.Figure2D(), Object(a.createRadiusBox)(this.clientBox, [S, Y, t, s], d);
        }
      }
      X(p, "Attr", K.default), e.default.registerNode(p, "block");
    },
    /* 220 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return r;
      });
      var c = i(71), Z = i(72), L = i(221);
      i(1).glMatrix.setMatrixArrayType(Array);
      const K = Symbol.for("spritejs_setAttribute"), u = Symbol.for("spritejs_getAttribute"), a = Symbol.for("spritejs_setAttributeDefault"), e = Symbol.for("spritejs_declareAlias");
      class r extends c.default {
        constructor(W) {
          super(W), this[a]({
            anchorX: 0,
            anchorY: 0,
            /* anchor */
            width: void 0,
            height: void 0,
            /* size */
            borderWidth: 0,
            borderColor: "rgba(0,0,0,1)",
            /* border */
            borderDash: void 0,
            borderDashOffset: 0,
            borderTopLeftRadius: [0, 0],
            borderTopRightRadius: [0, 0],
            borderBottomRightRadius: [0, 0],
            borderBottomLeftRadius: [0, 0],
            /* borderRadius */
            bgcolor: "rgba(0,0,0,0)",
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            /* padding */
            boxSizing: "content-box",
            clipPath: void 0
          }), this[e]("anchor", "size", "border", "borderRadius", "padding");
        }
        get anchorX() {
          return this[u]("anchorX");
        }
        set anchorX(W) {
          this[K]("anchorX", Object(Z.toNumber)(W));
        }
        get anchorY() {
          return this[u]("anchorY");
        }
        set anchorY(W) {
          this[K]("anchorY", Object(Z.toNumber)(W));
        }
        get anchor() {
          return [this.anchorX, this.anchorY];
        }
        set anchor(W) {
          W = Object(Z.toArray)(W), Array.isArray(W) || (W = [W, W]), this.anchorX = W[0], this.anchorY = W[1];
        }
        get width() {
          return this[u]("width");
        }
        set width(W) {
          this[K]("width", Object(Z.toNumber)(W));
        }
        get height() {
          return this[u]("height");
        }
        set height(W) {
          this[K]("height", Object(Z.toNumber)(W));
        }
        get size() {
          return [this.width, this.height];
        }
        set size(W) {
          W = Object(Z.toArray)(W), Array.isArray(W) || (W = [W, W]), this.width = W[0], this.height = W[1];
        }
        get borderWidth() {
          return this[u]("borderWidth");
        }
        set borderWidth(W) {
          this[K]("borderWidth", Object(Z.toNumber)(W));
        }
        get borderColor() {
          return this[u]("borderColor");
        }
        set borderColor(W) {
          this[K]("borderColor", Object(L.parseColor)(W));
        }
        get border() {
          return [this.borderWidth, this.borderColor];
        }
        set border(W) {
          W = Object(Z.toArray)(W), Array.isArray(W) || (W = [W]), this.borderWidth = W[0], W[1] != null && (this.borderColor = W[1]);
        }
        get borderDash() {
          return this[u]("borderDash");
        }
        set borderDash(W) {
          W = Object(Z.toArray)(W, !0), W != null && !Array.isArray(W) && (W = [W]), this[K]("borderDash", W ? W.map(Z.toNumber) : null);
        }
        get borderDashOffset() {
          return this[u]("borderDashOffset");
        }
        set borderDashOffset(W) {
          this[K]("borderDashOffset", Object(Z.toNumber)(W));
        }
        get borderTopLeftRadius() {
          return this[u]("borderTopLeftRadius");
        }
        set borderTopLeftRadius(W) {
          W = Object(Z.toArray)(W, !0), Array.isArray(W) || (W = [W, W]), this[K]("borderTopLeftRadius", W.map(Z.toNumber));
        }
        get borderTopRightRadius() {
          return this[u]("borderTopRightRadius");
        }
        set borderTopRightRadius(W) {
          W = Object(Z.toArray)(W, !0), Array.isArray(W) || (W = [W, W]), this[K]("borderTopRightRadius", W.map(Z.toNumber));
        }
        get borderBottomRightRadius() {
          return this[u]("borderBottomRightRadius");
        }
        set borderBottomRightRadius(W) {
          W = Object(Z.toArray)(W, !0), Array.isArray(W) || (W = [W, W]), this[K]("borderBottomRightRadius", W.map(Z.toNumber));
        }
        get borderBottomLeftRadius() {
          return this[u]("borderBottomLeftRadius");
        }
        set borderBottomLeftRadius(W) {
          W = Object(Z.toArray)(W, !0), Array.isArray(W) || (W = [W, W]), this[K]("borderBottomLeftRadius", W.map(Z.toNumber));
        }
        get borderRadius() {
          return [...this.borderTopLeftRadius, ...this.borderTopRightRadius, ...this.borderBottomRightRadius, ...this.borderBottomLeftRadius];
        }
        set borderRadius(W) {
          if (W = Object(Z.toArray)(W), !Array.isArray(W))
            W = Array(8).fill(W);
          else if (W.length === 2)
            W = [W[0], W[1], W[0], W[1], W[0], W[1], W[0], W[1]];
          else if (W.length === 4)
            W = [W[0], W[1], W[2], W[3], W[0], W[1], W[2], W[3]];
          else if (W.length === 6)
            W = [W[0], W[1], W[2], W[3], W[4], W[5], W[2], W[3]];
          else if (W.length !== 8)
            throw new TypeError("Invalid borderRadius value.");
          this.borderTopLeftRadius = [W[0], W[1]], this.borderTopRightRadius = [W[2], W[3]], this.borderBottomRightRadius = [W[4], W[5]], this.borderBottomLeftRadius = [W[6], W[7]];
        }
        get bgcolor() {
          return this[u]("bgcolor");
        }
        set bgcolor(W) {
          this[K]("bgcolor", Object(L.parseColor)(W));
        }
        get paddingTop() {
          return this[u]("paddingTop");
        }
        set paddingTop(W) {
          this[K]("paddingTop", Object(Z.toNumber)(W));
        }
        get paddingRight() {
          return this[u]("paddingRight");
        }
        set paddingRight(W) {
          this[K]("paddingRight", Object(Z.toNumber)(W));
        }
        get paddingBottom() {
          return this[u]("paddingBottom");
        }
        set paddingBottom(W) {
          this[K]("paddingBottom", Object(Z.toNumber)(W));
        }
        get paddingLeft() {
          return this[u]("paddingLeft");
        }
        set paddingLeft(W) {
          this[K]("paddingLeft", Object(Z.toNumber)(W));
        }
        get padding() {
          return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
        }
        set padding(W) {
          W = Object(Z.toArray)(W), Array.isArray(W) ? W.length === 2 ? W = [W[0], W[1], W[0], W[1]] : W.length === 3 && (W = [W[0], W[1], W[2], W[1]]) : W = [W, W, W, W], this.paddingTop = W[0], this.paddingRight = W[1], this.paddingBottom = W[2], this.paddingLeft = W[3];
        }
        get clipPath() {
          return this[u]("clipPath");
        }
        set clipPath(W) {
          this[K]("clipPath", W);
        }
        get boxSizing() {
          return this[u]("boxSizing");
        }
        set boxSizing(W) {
          if (W != null && W !== "border-box" && W !== "content-box")
            throw new TypeError("Invalid boxSizing type.");
          this[K]("boxSizing", W);
        }
      }
    },
    /* 221 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "Gradient", function() {
        return L;
      }), i.d(l, "isTransparent", function() {
        return K;
      }), i.d(l, "parseColor", function() {
        return u;
      }), i.d(l, "setFillColor", function() {
        return e;
      }), i.d(l, "setStrokeColor", function() {
        return r;
      }), i.d(l, "Color", function() {
        return X;
      });
      var c = i(32), Z = /* @__PURE__ */ i.n(c);
      i(1).glMatrix.setMatrixArrayType(Array);
      class L {
        constructor({
          vector: p,
          colors: C
        }) {
          if (!Array.isArray(p) || p.length !== 4 && p.length !== 6 && p.length !== 3)
            throw new TypeError("Invalid gradient");
          this.vector = p, this.colors = C.map(({
            offset: I,
            color: o
          }) => ({
            offset: I,
            color: u(o)
          }));
        }
        toString() {
          return JSON.stringify({
            vector: this.vector,
            colors: this.colors
          });
        }
      }
      function K(W) {
        return W instanceof L ? !1 : W == null ? !0 : Z()(W)[3] === 0;
      }
      function u(W) {
        if (W == null || (W || (W = "transparent"), W instanceof L))
          return W;
        const p = Z()(W);
        if (!p || !p.length)
          throw new TypeError("Invalid color value.");
        return `rgba(${p.join()})`;
      }
      function a(W, p, C) {
        const I = W.boundingBox[0];
        if (C.vector) {
          let {
            vector: o,
            colors: G
          } = C;
          o.length === 4 ? (o = [o[0] + I[0], o[1] + I[1], o[2] + I[0], o[3] + I[1]], W.setLinearGradient({
            vector: o,
            colors: G,
            type: p
          })) : o.length === 3 ? (o = [o[0] + I[0], o[1] + I[1], o[2]], W.setCircularGradient({
            vector: o,
            colors: G,
            type: p
          })) : (o = [o[0] + I[0], o[1] + I[1], o[2], o[3] + I[0], o[4] + I[1], o[5]], W.setRadialGradient({
            vector: o,
            colors: G,
            type: p
          }));
        } else
          W.gradient && W.gradient[p] && (delete W.gradient[p], delete W.uniforms.u_radialGradientVector);
      }
      function e(W, {
        color: p,
        rule: C = "nonzero"
      }) {
        return a(W, "fill", p), p.vector || W.setFill({
          color: p,
          rule: C
        }), W;
      }
      function r(W, {
        color: p,
        lineWidth: C,
        lineCap: I,
        lineJoin: o,
        lineDash: G,
        lineDashOffset: d,
        miterLimit: t,
        roundSegments: s
      }) {
        a(W, "stroke", p), p.vector && (p = [0, 0, 0, 1]), W.setStroke({
          color: p,
          thickness: C,
          cap: I,
          join: o,
          miterLimit: t,
          lineDash: G,
          lineDashOffset: d,
          roundSegments: s
        });
      }
      class X extends Array {
        constructor(p = 0, C = 0, I = 0, o = 0) {
          return Array.isArray(p) && ([p, C, I, o] = p), typeof p == "string" && ([p, C, I, o] = Z()(p), p /= 255, C /= 255, I /= 255), super(p, C, I, o), this;
        }
        get r() {
          return Math.round(this[0] * 255);
        }
        set r(p) {
          this[0] = p / 255;
        }
        get g() {
          return Math.round(this[1] * 255);
        }
        set g(p) {
          this[1] = p / 255;
        }
        get b() {
          return Math.round(this[2] * 255);
        }
        set b(p) {
          this[2] = p / 255;
        }
        get a() {
          return this[3];
        }
        set a(p) {
          this[3] = p;
        }
        get hex() {
          const p = `0${this.r.toString(16)}`.slice(-2), C = `0${this.g.toString(16)}`.slice(-2), I = `0${this.b.toString(16)}`.slice(-2);
          let o;
          return this.a < 1 && (o = Math.round(this[3] * 255), o = `0${o.toString(16)}`.slice(-2)), `#${p}${C}${I}${o || ""}`;
        }
        get rgba() {
          return `rgba(${this.r},${this.g},${this.b},${this.a})`;
        }
        fromColor(p) {
          return typeof p == "string" && (p = Z()(p), p[0] /= 255, p[1] /= 255, p[2] /= 255), this[0] = p[0], this[1] = p[1], this[2] = p[2], this[3] = p[3], this;
        }
      }
    },
    /* 222 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "createRadiusBox", function() {
        return Z;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c(L, K, u, a, e, r = "leftTop") {
        const X = 0.5522848, W = a / 2 * X, p = e / 2 * X, C = K + a, I = u + e, o = K + a / 2, G = u + e / 2;
        r === "leftTop" ? (L.moveTo(K, G), L.bezierCurveTo(K, G - p, o - W, u, o, u)) : r === "rightTop" ? L.bezierCurveTo(o + W, u, C, G - p, C, G) : r === "rightBottom" ? L.bezierCurveTo(C, G + p, o + W, I, o, I) : r === "leftBottom" && L.bezierCurveTo(o - W, I, K, G + p, K, G);
      }
      function Z(L, [K, u, a, e], r) {
        if (!r || Array.isArray(r) && r.every((X) => X === 0))
          L.beginPath(), L.rect(K, u, a, e);
        else {
          typeof r == "number" && (r = Array(8).fill(r));
          const [X, W, p, C, I, o, G, d] = r.map((t, s) => s % 2 ? Math.min(t, e / 2) : Math.min(t, a / 2));
          L.beginPath(), L.moveTo(K, u + W), c(L, K, u, X * 2, W * 2, "leftTop"), L.lineTo(K + a - p, u), c(L, K + a - p * 2, u, p * 2, C * 2, "rightTop"), L.lineTo(K + a, u + e - o), c(L, K + a - I * 2, u + e - o * 2, I * 2, o * 2, "rightBottom"), L.lineTo(K + G, u + e), c(L, K, u + e - d * 2, G * 2, d * 2, "leftBottom"), L.closePath();
        }
        return L;
      }
    },
    /* 223 */
    /***/
    function(n, l, i) {
      i.r(l), i(1).glMatrix.setMatrixArrayType(Array), l.default = function(c, Z) {
        if (!c)
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
        const [[L, K], [u, a]] = c, e = L * Z[0] + K * Z[2] + Z[4], r = L * Z[1] + K * Z[3] + Z[5], X = u * Z[0] + K * Z[2] + Z[4], W = u * Z[1] + K * Z[3] + Z[5], p = u * Z[0] + a * Z[2] + Z[4], C = u * Z[1] + a * Z[3] + Z[5], I = L * Z[0] + a * Z[2] + Z[4], o = L * Z[1] + a * Z[3] + Z[5], G = Math.min(e, X, p, I), d = Math.min(r, W, C, o), t = Math.max(e, X, p, I), s = Math.max(r, W, C, o);
        return {
          x: G,
          y: d,
          width: t - G,
          height: s - d,
          left: G,
          top: d,
          right: t,
          bottom: s
        };
      };
    },
    /* 224 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var c = i(218), Z = i(219), L = i(225), K = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      function u(r, X, W) {
        return X in r ? Object.defineProperty(r, X, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : r[X] = W, r;
      }
      const a = Symbol("textureTask");
      class e extends Z.default {
        constructor(X = {}) {
          typeof X == "string" && (X = {
            texture: X
          }), super(X);
        }
        /* override */
        get contentSize() {
          let [X, W] = super.contentSize;
          const {
            width: p,
            height: C
          } = this.attributes;
          if (p == null || C == null) {
            const I = this.textureImage, o = this.attributes.textureRect, G = this.attributes.sourceRect;
            if (o)
              p == null && (X = o[0] + o[2]), C == null && (W = o[1] + o[3]);
            else if (G) {
              const d = this.layer ? this.layer.displayRatio : 1;
              p == null && (X = G[2] / d), C == null && (W = G[3] / d);
            } else if (I) {
              const d = this.layer ? this.layer.displayRatio : 1;
              p == null && (X = I.width / d), C == null && (W = I.height / d);
            }
          }
          return [X, W];
        }
        get textureImageReady() {
          return this[a] || Promise.resolve();
        }
        /* override */
        draw(X = []) {
          super.draw(X);
          const W = this.mesh;
          return W && Object(c.drawTexture)(this, W), X;
        }
        /* override */
        onPropertyChange(X, W, p) {
          if (super.onPropertyChange(X, W, p), X === "texture" && (this[a] = Object(c.applyTexture)(this, W, !0)), X === "textureRect") {
            const {
              width: C,
              height: I
            } = this.attributes;
            (C == null || I == null) && this.updateContours();
          }
        }
      }
      u(e, "Attr", L.default), K.default.registerNode(e, "sprite");
    },
    /* 225 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(220);
      i(1).glMatrix.setMatrixArrayType(Array);
      const Z = Symbol.for("spritejs_setAttributeDefault"), L = Symbol.for("spritejs_setAttribute"), K = Symbol.for("spritejs_getAttribute");
      class u extends c.default {
        constructor(e) {
          super(e), this[Z]({
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0
          });
        }
        get texture() {
          return this[K]("texture");
        }
        set texture(e) {
          this[L]("texture", e);
        }
        get textureRect() {
          return this[K]("textureRect");
        }
        set textureRect(e) {
          this[L]("textureRect", e);
        }
        get sourceRect() {
          return this[K]("sourceRect");
        }
        set sourceRect(e) {
          this[L]("sourceRect", e);
        }
        get textureRepeat() {
          return this[K]("textureRepeat");
        }
        set textureRepeat(e) {
          this[L]("textureRepeat", !!e);
        }
      }
    },
    /* 226 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return C;
      });
      var c = i(12), Z = i(227), L = /* @__PURE__ */ i.n(Z), K = i(70), u = i(228), a = i(221), e = i(218), r = i(213), X = i(223);
      i(1).glMatrix.setMatrixArrayType(Array);
      function W(I, o, G) {
        return o in I ? Object.defineProperty(I, o, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : I[o] = G, I;
      }
      const p = Symbol("mesh");
      class C extends K.default {
        constructor(o = {}) {
          typeof o == "string" && (o = {
            d: o
          }), super(o), this.effects = {
            d(G, d, t, s, b) {
              const V = (t - s) / (b - s);
              if (V <= 0)
                return G;
              if (V >= 1)
                return d;
              const S = L.a._preprocessing(L.a.path2shapes(G), L.a.path2shapes(d)), Y = L.a._lerp(...S, V)[0];
              return Y.reduce((y, J) => `${y}${J.slice(2).join(" ")} `, `M${Y[0][0]} ${Y[0][1]}C`).trim();
            }
          };
        }
        /* override */
        get isVisible() {
          return !!this.d;
        }
        get mesh() {
          if (this.attributes.display === "none")
            return null;
          const o = this.path;
          if (o) {
            let G = this[p];
            if (G)
              G.path !== o && (G.contours = o.contours, G.path = o);
            else {
              G = new c.Mesh2D(this.path), G.path = o;
              const t = this.attributes.fillColor, s = this.attributes.fillRule;
              t && Object(a.setFillColor)(G, {
                color: t,
                rule: s
              });
              const b = this.attributes.lineWidth, V = this.attributes.strokeColor;
              if (V && b > 0) {
                const {
                  lineCap: Y,
                  lineJoin: T,
                  miterLimit: y,
                  lineDash: J,
                  lineDashOffset: N,
                  roundSegments: R
                } = this.attributes;
                Object(a.setStrokeColor)(G, {
                  color: V,
                  lineWidth: b,
                  lineCap: Y,
                  lineJoin: T,
                  miterLimit: y,
                  lineDash: J,
                  lineDashOffset: N,
                  roundSegments: R
                });
              }
              this[p] = G;
              const S = this.attributes.clipPath;
              S && this[p].setClipPath(S);
            }
            const d = this.opacity;
            return G.getOpacity() !== d && G.setOpacity(d), G.setTransform(...this.renderMatrix), G;
          }
          return null;
        }
        get originalContentRect() {
          if (this.path) {
            const o = this.path.boundingBox;
            return [o[0][0], o[0][1], o[1][0] - o[0][0], o[1][1] - o[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientRect() {
          if (this.mesh) {
            const o = this.mesh.boundingBox;
            return [o[0][0], o[0][1], o[1][0] - o[0][0], o[1][1] - o[0][1]];
          }
          return [0, 0, 0, 0];
        }
        get originalClientCenter() {
          return this.mesh ? this.mesh.boundingCenter : [0, 0];
        }
        set d(o) {
          this.attributes.d = o;
        }
        get d() {
          return this.attributes.d;
        }
        /* override */
        draw(o = []) {
          super.draw(o);
          const G = this.mesh;
          return G && Object(e.drawTexture)(this, G), o;
        }
        getBoundingClientRect() {
          let o = null;
          return this.mesh && (o = this.mesh.boundingBox), Object(X.default)(o, this.renderMatrix);
        }
        getPathLength() {
          return this.mesh ? this.mesh.getTotalLength() : 0;
        }
        getPointAtLength(o) {
          if (this.mesh) {
            const G = this.mesh.getPointAtLength(o);
            if (G)
              return [G.x, G.y];
          }
          return [0, 0];
        }
        /* override */
        onPropertyChange(o, G, d) {
          if (super.onPropertyChange(o, G, d), (o === "d" || o === "normalize") && this.updateContours(), this[p] && (o === "fillColor" || o === "fillRule")) {
            const {
              fillColor: t,
              fillRule: s
            } = this.attributes;
            Object(a.setFillColor)(this[p], {
              color: t,
              rule: s
            });
          }
          if (this[p] && (o === "strokeColor" || o === "lineWidth" || o === "lineCap" || o === "lineJoin" || o === "lineDash" || o === "lineDashOffset" || o === "roundSegments")) {
            const {
              strokeColor: t,
              lineWidth: s
            } = this.attributes;
            if (t && s > 0) {
              const {
                lineCap: b,
                lineJoin: V,
                lineDash: S,
                lineDashOffset: Y,
                miterLimit: T,
                roundSegments: y
              } = this.attributes;
              Object(a.setStrokeColor)(this[p], {
                color: t,
                lineCap: b,
                lineJoin: V,
                lineWidth: s,
                lineDash: S,
                lineDashOffset: Y,
                miterLimit: T,
                roundSegments: y
              });
            }
          }
          this[p] && o === "clipPath" && this[p].setClipPath(G), o === "texture" && Object(e.applyTexture)(this, G);
        }
        /* override */
        updateContours() {
          this.path = new c.Figure2D(), this.path.addPath(this.attributes.d), this.attributes.normalize && this.path.normalize(...this.path.boundingCenter);
        }
      }
      W(C, "Attr", u.default), r.default.registerNode(C, "path");
    },
    /* 227 */
    /***/
    function(n, l, i) {
      (function(c, Z) {
        n.exports = Z();
      })(this, function() {
        var c = /* @__PURE__ */ function() {
          function J(N, R) {
            var x = [], M = !0, Q = !1, P = void 0;
            try {
              for (var D = N[Symbol.iterator](), _; !(M = (_ = D.next()).done) && (x.push(_.value), !(R && x.length === R)); M = !0)
                ;
            } catch (F) {
              Q = !0, P = F;
            } finally {
              try {
                !M && D.return && D.return();
              } finally {
                if (Q)
                  throw P;
              }
            }
            return x;
          }
          return function(N, R) {
            if (Array.isArray(N))
              return N;
            if (Symbol.iterator in Object(N))
              return J(N, R);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), Z = Math.PI * 2, L = function(N, R, x, M, Q, P, D) {
          var _ = N.x, F = N.y;
          _ *= R, F *= x;
          var v = M * _ - Q * F, O = Q * _ + M * F;
          return {
            x: v + P,
            y: O + D
          };
        }, K = function(N, R) {
          var x = 1.3333333333333333 * Math.tan(R / 4), M = Math.cos(N), Q = Math.sin(N), P = Math.cos(N + R), D = Math.sin(N + R);
          return [{
            x: M - Q * x,
            y: Q + M * x
          }, {
            x: P + D * x,
            y: D - P * x
          }, {
            x: P,
            y: D
          }];
        }, u = function(N, R, x, M) {
          var Q = N * M - R * x < 0 ? -1 : 1, P = Math.sqrt(N * N + R * R), D = Math.sqrt(N * N + R * R), _ = N * x + R * M, F = _ / (P * D);
          return F > 1 && (F = 1), F < -1 && (F = -1), Q * Math.acos(F);
        }, a = function(N, R, x, M, Q, P, D, _, F, v, O, li) {
          var ii = Math.pow(Q, 2), ti = Math.pow(P, 2), $ = Math.pow(O, 2), ai = Math.pow(li, 2), Xi = ii * ti - ii * ai - ti * $;
          Xi < 0 && (Xi = 0), Xi /= ii * ai + ti * $, Xi = Math.sqrt(Xi) * (D === _ ? -1 : 1);
          var z = Xi * Q / P * li, k = Xi * -P / Q * O, j = v * z - F * k + (N + x) / 2, A = F * z + v * k + (R + M) / 2, H = (O - z) / Q, U = (li - k) / P, m = (-O - z) / Q, h = (-li - k) / P, g = u(1, 0, H, U), f = u(H, U, m, h);
          return _ === 0 && f > 0 && (f -= Z), _ === 1 && f < 0 && (f += Z), [j, A, g, f];
        }, e = function(N) {
          var R = N.px, x = N.py, M = N.cx, Q = N.cy, P = N.rx, D = N.ry, _ = N.xAxisRotation, F = _ === void 0 ? 0 : _, v = N.largeArcFlag, O = v === void 0 ? 0 : v, li = N.sweepFlag, ii = li === void 0 ? 0 : li, ti = [];
          if (P === 0 || D === 0)
            return [];
          var $ = Math.sin(F * Z / 360), ai = Math.cos(F * Z / 360), Xi = ai * (R - M) / 2 + $ * (x - Q) / 2, z = -$ * (R - M) / 2 + ai * (x - Q) / 2;
          if (Xi === 0 && z === 0)
            return [];
          P = Math.abs(P), D = Math.abs(D);
          var k = Math.pow(Xi, 2) / Math.pow(P, 2) + Math.pow(z, 2) / Math.pow(D, 2);
          k > 1 && (P *= Math.sqrt(k), D *= Math.sqrt(k));
          var j = a(R, x, M, Q, P, D, O, ii, $, ai, Xi, z), A = c(j, 4), H = A[0], U = A[1], m = A[2], h = A[3], g = Math.max(Math.ceil(Math.abs(h) / (Z / 4)), 1);
          h /= g;
          for (var f = 0; f < g; f++)
            ti.push(K(m, h)), m += h;
          return ti.map(function(w) {
            var B = L(w[0], P, D, ai, $, H, U), q = B.x, si = B.y, bi = L(w[1], P, D, ai, $, H, U), Zi = bi.x, oi = bi.y, mi = L(w[2], P, D, ai, $, H, U), ci = mi.x, ni = mi.y;
            return { x1: q, y1: si, x2: Zi, y2: oi, x: ci, y: ni };
          });
        }, r = {
          a: 7,
          c: 6,
          h: 1,
          l: 2,
          m: 2,
          q: 4,
          s: 4,
          t: 2,
          v: 1,
          z: 0
          /**
           * segment pattern
           * @type {RegExp}
           */
        }, X = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
        function W(J) {
          var N = [];
          return J.replace(X, function(R, x, M) {
            var Q = x.toLowerCase();
            for (M = C(M), Q == "m" && M.length > 2 && (N.push([x].concat(M.splice(0, 2))), Q = "l", x = x == "m" ? "l" : "L"); ; ) {
              if (M.length == r[Q])
                return M.unshift(x), N.push(M);
              if (M.length < r[Q])
                throw new Error("malformed path data");
              N.push([x].concat(M.splice(0, r[Q])));
            }
          }), N;
        }
        var p = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
        function C(J) {
          var N = J.match(p);
          return N ? N.map(Number) : [];
        }
        function I(J) {
          var N = J[0][0], R = J[0][1], x = N, M = R;
          return J.forEach(function(Q) {
            var P = Q[0], D = Q[2], _ = Q[4], F = Q[6], v = Q[1], O = Q[3], li = Q[5], ii = Q[7];
            N = Math.min(N, P, D, _, F), R = Math.min(R, v, O, li, ii), x = Math.max(x, P, D, _, F), M = Math.max(M, v, O, li, ii);
          }), [N, R, x, M];
        }
        function o(J, N) {
          return Math.sqrt(Math.pow(J[0] - N[0], 2) + Math.pow(J[1] - N[1], 2)) + Math.sqrt(Math.pow(J[2] - N[2], 2) + Math.pow(J[3] - N[3], 2));
        }
        function G(J, N) {
          var R = J[0], x = J[2], M = J[4], Q = J[6], P = J[1], D = J[3], _ = J[5], F = J[7], v = N[0], O = N[2], li = N[4], ii = N[6], ti = N[1], $ = N[3], ai = N[5], Xi = N[7];
          return Math.sqrt(Math.pow(v - R, 2) + Math.pow(ti - P, 2)) + Math.sqrt(Math.pow(O - x, 2) + Math.pow($ - D, 2)) + Math.sqrt(Math.pow(li - M, 2) + Math.pow(ai - _, 2)) + Math.sqrt(Math.pow(ii - Q, 2) + Math.pow(Xi - F, 2));
        }
        function d(J, N) {
          var R = s(J.length), x = [];
          R.forEach(function(Q) {
            var P = 0, D = 0;
            Q.forEach(function(_) {
              P += G(J[_], N[D++]);
            }), x.push({ index: Q, distance: P });
          }), x.sort(function(Q, P) {
            return Q.distance - P.distance;
          });
          var M = [];
          return x[0].index.forEach(function(Q) {
            M.push(J[Q]);
          }), M;
        }
        function t(J, N) {
          var R = b(J.length), x = [];
          R.forEach(function(Q) {
            var P = 0;
            Q.forEach(function(D) {
              P += o(I(J[D]), I(N[D]));
            }), x.push({ index: Q, distance: P });
          }), x.sort(function(Q, P) {
            return Q.distance - P.distance;
          });
          var M = [];
          return x[0].index.forEach(function(Q) {
            M.push(J[Q]);
          }), M;
        }
        function s(J) {
          for (var N = [], R = 0; R < J; R++) {
            for (var x = [], M = 0; M < J; M++) {
              var Q = M + R;
              Q > J - 1 && (Q -= J), x[Q] = M;
            }
            N.push(x);
          }
          return N;
        }
        function b(J) {
          for (var N = [], R = 0; R < J; R++)
            N.push(R);
          return V(N);
        }
        function V(J) {
          var N = [], R = [];
          function x(M) {
            var Q, P;
            for (Q = 0; Q < M.length; Q++)
              P = M.splice(Q, 1)[0], R.push(P), M.length == 0 && N.push(R.slice()), x(M), M.splice(Q, 0, P), R.pop();
            return N;
          }
          return x(J);
        }
        var S = {};
        S.parser = W, S.lerpCurve = function(J, N, R) {
          return S.lerpPoints(J[0], J[1], N[0], N[1], R).concat(S.lerpPoints(J[2], J[3], N[2], N[3], R)).concat(S.lerpPoints(J[4], J[5], N[4], N[5], R)).concat(S.lerpPoints(J[6], J[7], N[6], N[7], R));
        }, S.lerpPoints = function(J, N, R, x, M) {
          return [J + (R - J) * M, N + (x - N) * M];
        }, S.q2b = function(J, N, R, x, M, Q) {
          return [J, N, (J + 2 * R) / 3, (N + 2 * x) / 3, (M + 2 * R) / 3, (Q + 2 * x) / 3, M, Q];
        }, S.path2shapes = function(J) {
          for (var N = S.parser(J), R = 0, x = 0, M = 0, Q = N.length, P = [], D = null, _ = void 0, F = void 0, v = void 0, O = void 0, li = void 0, ii = void 0, ti = void 0; M < Q; M++) {
            var $ = N[M], ai = $[0], Xi = N[M - 1];
            switch (ai) {
              case "m":
                li = P.length, P[li] = [], D = P[li], R = R + $[1], x = x + $[2];
                break;
              case "M":
                li = P.length, P[li] = [], D = P[li], R = $[1], x = $[2];
                break;
              case "l":
                D.push([R, x, R, x, R, x, R + $[1], x + $[2]]), R += $[1], x += $[2];
                break;
              case "L":
                D.push([R, x, $[1], $[2], $[1], $[2], $[1], $[2]]), R = $[1], x = $[2];
                break;
              case "h":
                D.push([R, x, R, x, R, x, R + $[1], x]), R += $[1];
                break;
              case "H":
                D.push([R, x, $[1], x, $[1], x, $[1], x]), R = $[1];
                break;
              case "v":
                D.push([R, x, R, x, R, x, R, x + $[1]]), x += $[1];
                break;
              case "V":
                D.push([R, x, R, $[1], R, $[1], R, $[1]]), x = $[1];
                break;
              case "C":
                D.push([R, x, $[1], $[2], $[3], $[4], $[5], $[6]]), R = $[5], x = $[6];
                break;
              case "S":
                Xi[0] === "C" || Xi[0] === "c" ? D.push([R, x, R + Xi[5] - Xi[3], x + Xi[6] - Xi[4], $[1], $[2], $[3], $[4]]) : (Xi[0] === "S" || Xi[0] === "s") && D.push([R, x, R + Xi[3] - Xi[1], x + Xi[4] - Xi[2], $[1], $[2], $[3], $[4]]), R = $[3], x = $[4];
                break;
              case "c":
                D.push([R, x, R + $[1], x + $[2], R + $[3], x + $[4], R + $[5], x + $[6]]), R = R + $[5], x = x + $[6];
                break;
              case "s":
                Xi[0] === "C" || Xi[0] === "c" ? D.push([R, x, R + Xi[5] - Xi[3], x + Xi[6] - Xi[4], R + $[1], x + $[2], R + $[3], x + $[4]]) : (Xi[0] === "S" || Xi[0] === "s") && D.push([R, x, R + Xi[3] - Xi[1], x + Xi[4] - Xi[2], R + $[1], x + $[2], R + $[3], x + $[4]]), R = R + $[3], x = x + $[4];
                break;
              case "a":
                ii = e({
                  rx: $[1],
                  ry: $[2],
                  px: R,
                  py: x,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: R + $[6],
                  cy: x + $[7]
                }), ti = ii[ii.length - 1], ii.forEach(function(z, k) {
                  k === 0 ? D.push([R, x, z.x1, z.y1, z.x2, z.y2, z.x, z.y]) : D.push([ii[k - 1].x, ii[k - 1].y, z.x1, z.y1, z.x2, z.y2, z.x, z.y]);
                }), R = ti.x, x = ti.y;
                break;
              case "A":
                ii = e({
                  rx: $[1],
                  ry: $[2],
                  px: R,
                  py: x,
                  xAxisRotation: $[3],
                  largeArcFlag: $[4],
                  sweepFlag: $[5],
                  cx: $[6],
                  cy: $[7]
                }), ti = ii[ii.length - 1], ii.forEach(function(z, k) {
                  k === 0 ? D.push([R, x, z.x1, z.y1, z.x2, z.y2, z.x, z.y]) : D.push([ii[k - 1].x, ii[k - 1].y, z.x1, z.y1, z.x2, z.y2, z.x, z.y]);
                }), R = ti.x, x = ti.y;
                break;
              case "Q":
                D.push(S.q2b(R, x, $[1], $[2], $[3], $[4])), R = $[3], x = $[4];
                break;
              case "q":
                D.push(S.q2b(R, x, R + $[1], x + $[2], $[3] + R, $[4] + x)), R += $[3], x += $[4];
                break;
              case "T":
                Xi[0] === "Q" || Xi[0] === "q" ? (v = R + Xi[3] - Xi[1], O = x + Xi[4] - Xi[2], D.push(S.q2b(R, x, v, O, $[1], $[2]))) : (Xi[0] === "T" || Xi[0] === "t") && (D.push(S.q2b(R, x, R + R - v, x + x - O, $[1], $[2])), v = R + R - v, O = x + x - O), R = $[1], x = $[2];
                break;
              case "t":
                Xi[0] === "Q" || Xi[0] === "q" ? (v = R + Xi[3] - Xi[1], O = x + Xi[4] - Xi[2], D.push(S.q2b(R, x, v, O, R + $[1], x + $[2]))) : (Xi[0] === "T" || Xi[0] === "t") && (D.push(S.q2b(R, x, R + R - v, x + x - O, R + $[1], x + $[2])), v = R + R - v, O = x + x - O), R += $[1], x += $[2];
                break;
              case "Z":
                _ = D[0][0], F = D[0][1], D.push([R, x, _, F, _, F, _, F]);
                break;
              case "z":
                _ = D[0][0], F = D[0][1], D.push([R, x, _, F, _, F, _, F]);
                break;
            }
          }
          return P;
        }, S._upCurves = function(J, N) {
          for (var R = 0, x = 0, M = J.length; R < N; R++)
            J.push(J[x].slice(0)), x++, x > M - 1 && (x -= M);
        };
        function Y(J, N, R, x, M, Q, P, D, _) {
          return {
            left: T(J, N, R, x, M, Q, P, D, _),
            right: T(P, D, M, Q, R, x, J, N, 1 - _, !0)
          };
        }
        function T(J, N, R, x, M, Q, P, D, _, F) {
          var v = (R - J) * _ + J, O = (x - N) * _ + N, li = (M - R) * _ + R, ii = (Q - x) * _ + x, ti = (P - M) * _ + M, $ = (D - Q) * _ + Q, ai = (li - v) * _ + v, Xi = (ii - O) * _ + O, z = (ti - li) * _ + li, k = ($ - ii) * _ + ii, j = (z - ai) * _ + ai, A = (k - Xi) * _ + Xi;
          return F ? [j, A, ai, Xi, v, O, J, N] : [J, N, v, O, ai, Xi, j, A];
        }
        S._splitCurves = function(J, N) {
          for (var R = 0, x = 0; R < N; R++) {
            var M = J[x], Q = Y(M[0], M[1], M[2], M[3], M[4], M[5], M[6], M[7], 0.5);
            J.splice(x, 1), J.splice(x, 0, Q.left, Q.right), x += 2, x >= J.length - 1 && (x = 0);
          }
        };
        function y(J, N) {
          for (var R = function(Q) {
            var P = J[J.length - 1], D = [];
            P.forEach(function(_) {
              D.push(_.slice(0));
            }), J.push(D);
          }, x = 0; x < N; x++)
            R();
        }
        return S.lerp = function(J, N, R) {
          return S._lerp(S.path2shapes(J), S.path2shapes(N), R);
        }, S.MIM_CURVES_COUNT = 100, S._preprocessing = function(J, N) {
          var R = J.length, x = N.length, M = JSON.parse(JSON.stringify(J)), Q = JSON.parse(JSON.stringify(N));
          return R > x ? y(Q, R - x) : R < x && y(M, x - R), M = t(M, Q), M.forEach(function(P, D) {
            var _ = P.length, F = Q[D].length;
            _ > F ? _ < S.MIM_CURVES_COUNT ? (S._splitCurves(P, S.MIM_CURVES_COUNT - _), S._splitCurves(Q[D], S.MIM_CURVES_COUNT - F)) : S._splitCurves(Q[D], _ - F) : _ < F && (F < S.MIM_CURVES_COUNT ? (S._splitCurves(P, S.MIM_CURVES_COUNT - _), S._splitCurves(Q[D], S.MIM_CURVES_COUNT - F)) : S._splitCurves(P, F - _));
          }), M.forEach(function(P, D) {
            M[D] = d(P, Q[D]);
          }), [M, Q];
        }, S._lerp = function(J, N, R) {
          var x = [];
          return J.forEach(function(M, Q) {
            var P = [];
            M.forEach(function(D, _) {
              P.push(S.lerpCurve(D, N[Q][_], R));
            }), x.push(P);
          }), x;
        }, S.animate = function(J) {
          var N = S.path2shapes(J.from), R = S.path2shapes(J.to), x = S._preprocessing(N, R), M = /* @__PURE__ */ new Date(), Q = J.end || function() {
          }, P = J.progress || function() {
          }, D = J.begin || function() {
          }, _ = J.easing || function(ii) {
            return ii;
          }, F = null, v = null, O = J.time;
          D(N);
          var li = function ii() {
            var ti = /* @__PURE__ */ new Date() - M;
            if (ti >= O) {
              v = R, P(v, 1), Q(v), cancelAnimationFrame(F);
              return;
            }
            var $ = _(ti / O);
            v = S._lerp(x[0], x[1], $), P(v, $), F = requestAnimationFrame(ii);
          };
          li();
        }, S;
      });
    },
    /* 228 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var c = i(71), Z = i(221), L = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const K = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_getAttribute");
      class e extends c.default {
        constructor(X) {
          super(X), this[K]({
            d: "",
            normalize: !1,
            fillColor: void 0,
            fillRule: "nonzero",
            strokeColor: void 0,
            lineWidth: 1,
            lineJoin: "miter",
            // 'miter' or 'bevel' or 'round'
            lineCap: "butt",
            // 'butt' or 'square' or 'round'
            roundSegments: 20,
            // default roundSegment if lineJoin or lineCap is round
            lineDash: void 0,
            lineDashOffset: 0,
            miterLimit: 10,
            texture: void 0,
            textureRect: void 0,
            textureRepeat: !1,
            sourceRect: void 0,
            clipPath: void 0
          });
        }
        get d() {
          return this[a]("d");
        }
        set d(X) {
          this[u]("d", X);
        }
        get normalize() {
          return this[a]("normalize");
        }
        set normalize(X) {
          this[u]("normalize", !!X);
        }
        get fillColor() {
          return this[a]("fillColor");
        }
        set fillColor(X) {
          this[u]("fillColor", Object(Z.parseColor)(X));
        }
        get fillRule() {
          return this[a]("fillRule");
        }
        set fillRule(X) {
          if (X != null && X !== "nonzero" && X !== "evenodd")
            throw new TypeError("Invalid fill rule.");
          this[u]("fillRule", X);
        }
        get strokeColor() {
          return this[a]("strokeColor");
        }
        set strokeColor(X) {
          this[u]("strokeColor", Object(Z.parseColor)(X));
        }
        get lineWidth() {
          return this[a]("lineWidth");
        }
        set lineWidth(X) {
          this[u]("lineWidth", Object(L.toNumber)(X));
        }
        get lineJoin() {
          return this[a]("lineJoin");
        }
        set lineJoin(X) {
          if (X != null && X !== "miter" && X !== "bevel" && X !== "round")
            throw new TypeError("Invalid lineJoin type.");
          this[u]("lineJoin", X);
        }
        get lineCap() {
          return this[a]("lineCap");
        }
        set lineCap(X) {
          if (X != null && X !== "butt" && X !== "square" && X !== "round")
            throw new TypeError("Invalid lineCap type.");
          this[u]("lineCap", X);
        }
        get lineDash() {
          return this[a]("lineDash");
        }
        set lineDash(X) {
          X = Object(L.toArray)(X, !0), X != null && !Array.isArray(X) && (X = [X]), this[u]("lineDash", X ? X.map(L.toNumber) : null);
        }
        get lineDashOffset() {
          return this[a]("lineDashOffset");
        }
        set lineDashOffset(X) {
          this[u]("lineDashOffset", Object(L.toNumber)(X));
        }
        get miterLimit() {
          return this[a]("miterLimit");
        }
        set miterLimit(X) {
          this[u]("miterLimit", Object(L.toNumber)(X));
        }
        get roundSegments() {
          return this[a]("roundSegments");
        }
        set roundSegments(X) {
          this[u]("roundSegments", X);
        }
        get texture() {
          return this[a]("texture");
        }
        set texture(X) {
          this[u]("texture", X);
        }
        get textureRect() {
          return this[a]("textureRect");
        }
        set textureRect(X) {
          this[u]("textureRect", X);
        }
        get sourceRect() {
          return this[a]("sourceRect");
        }
        set sourceRect(X) {
          this[u]("sourceRect", X);
        }
        get textureRepeat() {
          return this[a]("textureRepeat");
        }
        set textureRepeat(X) {
          this[u]("textureRepeat", !!X);
        }
        get clipPath() {
          return this[a]("clipPath");
        }
        set clipPath(X) {
          this[u]("clipPath", X);
        }
      }
    },
    /* 229 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(226), Z = i(213), L = i(230);
      i(1).glMatrix.setMatrixArrayType(Array);
      function K(a, e, r) {
        return e in a ? Object.defineProperty(a, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = r, a;
      }
      class u extends c.default {
        /* override */
        get isVisible() {
          const {
            width: e,
            height: r
          } = this.attributes;
          return e > 0 && r > 0 && super.isVisible;
        }
      }
      K(u, "Attr", L.default), Z.default.registerNode(u, "rect");
    },
    /* 230 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return r;
      });
      var c = i(228), Z = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const L = Symbol.for("spritejs_setAttributeDefault"), K = Symbol.for("spritejs_setAttribute"), u = Symbol.for("spritejs_getAttribute"), a = Symbol.for("spritejs_declareAlias");
      function e(X) {
        const {
          width: W,
          height: p
        } = X;
        return `M0 0L${W} 0L${W} ${p}L0 ${p}Z`;
      }
      class r extends c.default {
        constructor(W) {
          super(W), this[L]({
            width: 0,
            height: 0
            /* size */
          }), this[a]("size");
        }
        // readonly
        get d() {
          return this[u]("d");
        }
        set d(W) {
        }
        // eslint-disable-line no-empty-function
        get width() {
          return this[u]("width");
        }
        set width(W) {
          if (W = Object(Z.toNumber)(W), this[K]("width", W)) {
            const p = e(this);
            this[K]("d", p);
          }
        }
        get height() {
          return this[u]("height");
        }
        set height(W) {
          if (W = Object(Z.toNumber)(W), this[K]("height", W)) {
            const p = e(this);
            this[K]("d", p);
          }
        }
        get size() {
          return [this.width, this.height];
        }
        set size(W) {
          W = Object(Z.toArray)(W), Array.isArray(W) || (W = [W, W]), this.width = W[0], this.height = W[1];
        }
      }
    },
    /* 231 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(232), Z = i(213), L = i(235);
      i(1).glMatrix.setMatrixArrayType(Array);
      function K(a, e, r) {
        return e in a ? Object.defineProperty(a, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = r, a;
      }
      class u extends c.default {
        get isVisible() {
          const {
            sides: e
          } = this.attributes;
          return e[0] > 0 && e[1] > 0 && super.isVisible;
        }
      }
      K(u, "Attr", L.default), Z.default.registerNode(u, "triangle");
    },
    /* 232 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(226), Z = i(213), L = i(233);
      i(1).glMatrix.setMatrixArrayType(Array);
      function K(a, e, r) {
        return e in a ? Object.defineProperty(a, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = r, a;
      }
      class u extends c.default {
        /* override */
        get isVisible() {
          const {
            points: e
          } = this.attributes;
          return e.length > 0 && super.isVisible;
        }
      }
      K(u, "Attr", L.default), Z.default.registerNode(u, "polyline");
    },
    /* 233 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return X;
      });
      var c = i(228), Z = i(72), L = i(234);
      i(1).glMatrix.setMatrixArrayType(Array);
      const K = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_getAttribute"), e = Symbol.for("spritejs_declareAlias");
      function r(W) {
        const {
          points: p,
          smooth: C,
          smoothRange: I,
          close: o
        } = W, G = [];
        for (let t = 0; t < p.length; t += 2)
          G.push([p[t], p[t + 1]]);
        let d = "";
        return C ? d = Object(L.makeSmoothCurveLine)(G, I) : G.length && (d = `M${G.map((t) => t.join(" ")).join("L")}`), d && o && (d += "Z"), d;
      }
      class X extends c.default {
        constructor(p) {
          super(p), this[K]({
            points: [],
            smooth: !1,
            smoothRange: [0],
            closeType: "none"
            // none | normal
            /* close */
          }), this[e]("close");
        }
        // readonly
        get d() {
          return this[a]("d");
        }
        set d(p) {
        }
        // eslint-disable-line no-empty-function
        get close() {
          return this.closeType !== "none";
        }
        set close(p) {
          p = p ? "normal" : "none", this.closeType = p;
        }
        get closeType() {
          return this[a]("closeType");
        }
        set closeType(p) {
          if (p != null && p !== "none" && p !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[u]("closeType", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get smooth() {
          return this[a]("smooth");
        }
        set smooth(p) {
          if (this[u]("smooth", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get smoothRange() {
          return this[a]("smoothRange");
        }
        set smoothRange(p) {
          if (p && !Array.isArray(p) && (p = [p]), this[u]("smoothRange", p) && this.smooth) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get points() {
          return this[a]("points");
        }
        set points(p) {
          if (p = Object(Z.toArray)(p), Array.isArray(p) && (p = p.reduce((C, I) => Array.isArray(I) ? [...C, ...I.map((o) => Object(Z.toNumber)(o))] : [...C, Object(Z.toNumber)(I)], [])), this[u]("points", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
      }
    },
    /* 234 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "makeSmoothCurveLine", function() {
        return c;
      }), i(1).glMatrix.setMatrixArrayType(Array);
      function c(Z, L = [0]) {
        function K(e, r = 0.168, X = 0.168) {
          let W, p, C, I;
          if ((Z[e].x === Z[e + 1].x || Z[e].y === Z[e + 1].y) && (r = 0, X = 0), e < 1 ? (W = Z[0].x + (Z[1].x - Z[0].x) * r, p = Z[0].y + (Z[1].y - Z[0].y) * r) : (W = Z[e].x + (Z[e + 1].x - Z[e - 1].x) * r, p = Z[e].y + (Z[e + 1].y - Z[e - 1].y) * r), e > Z.length - 3) {
            const o = Z.length - 1;
            C = Z[o].x - (Z[o].x - Z[o - 1].x) * X, I = Z[o].y - (Z[o].y - Z[o - 1].y) * X;
          } else
            C = Z[e + 1].x - (Z[e + 2].x - Z[e].x) * X, I = Z[e + 1].y - (Z[e + 2].y - Z[e].y) * X;
          return [{
            x: W,
            y: p
          }, {
            x: C,
            y: I
          }];
        }
        Z = Z.map(([e, r]) => ({
          x: e,
          y: r
        }));
        let u = "", a = 0;
        return Z.forEach((e, r) => {
          if (r === 0)
            u += `M${e.x} ${e.y}`;
          else {
            for (; r > L[a]; )
              a++;
            if (a % 2) {
              const [X, W] = K(r - 1);
              u += `C${[X.x, X.y, W.x, W.y, e.x, e.y].join(" ")}`;
            } else
              u += `L${e.x} ${e.y}`;
          }
        }), u;
      }
    },
    /* 235 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var c = i(233), Z = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const L = Symbol.for("spritejs_setAttributeDefault"), K = Symbol.for("spritejs_setAttribute"), u = Symbol.for("spritejs_getAttribute");
      function a(r) {
        const [X, W] = r.sides;
        let p = r.angle % 360;
        return p < 0 && (p += 360), p = Math.PI * p / 180, [0, 0, X, 0, W * Math.cos(p), W * Math.sin(p)];
      }
      class e extends c.default {
        constructor(X) {
          super(X), this[L]({
            sides: [0, 0],
            angle: 60,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(X) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[u]("sides");
        }
        set sides(X) {
          if (X = Object(Z.toArray)(X, !0), X != null && !Array.isArray(X) && (X = [X, X]), this[K]("sides", X)) {
            const W = a(this);
            super.points = W;
          }
        }
        get angle() {
          return this[u]("angle");
        }
        set angle(X) {
          if (X = Object(Z.toNumber)(X), this[K]("angle", X)) {
            const W = a(this);
            super.points = W;
          }
        }
      }
    },
    /* 236 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(232), Z = i(213), L = i(237);
      i(1).glMatrix.setMatrixArrayType(Array);
      function K(a, e, r) {
        return e in a ? Object.defineProperty(a, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = r, a;
      }
      class u extends c.default {
        /* override */
        get isVisible() {
          const {
            sides: e
          } = this.attributes;
          return e[0] > 0 && e[1] > 0 && super.isVisible;
        }
      }
      K(u, "Attr", L.default), Z.default.registerNode(u, "parallel");
    },
    /* 237 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var c = i(233), Z = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const L = Symbol.for("spritejs_setAttributeDefault"), K = Symbol.for("spritejs_setAttribute"), u = Symbol.for("spritejs_getAttribute");
      function a(r) {
        const [X, W] = r.sides;
        let p = r.angle % 360;
        p < 0 && (p += 360), p = Math.PI * p / 180;
        const C = W * Math.cos(p), I = W * Math.sin(p);
        return [0, 0, X, 0, C + X, I, C, I];
      }
      class e extends c.default {
        constructor(X) {
          super(X), this[L]({
            sides: [0, 0],
            angle: 90,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(X) {
        }
        // eslint-disable-line no-empty-function
        get sides() {
          return this[u]("sides");
        }
        set sides(X) {
          if (X = Object(Z.toArray)(X, !0), X != null && !Array.isArray(X) && (X = [X, X]), this[K]("sides", X)) {
            const W = a(this);
            super.points = W;
          }
        }
        get angle() {
          return this[u]("angle");
        }
        set angle(X) {
          if (X = Object(Z.toNumber)(X), this[K]("angle", X)) {
            const W = a(this);
            super.points = W;
          }
        }
      }
    },
    /* 238 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(232), Z = i(213), L = i(239);
      i(1).glMatrix.setMatrixArrayType(Array);
      function K(a, e, r) {
        return e in a ? Object.defineProperty(a, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = r, a;
      }
      class u extends c.default {
      }
      K(u, "Attr", L.default), Z.default.registerNode(u, "regular");
    },
    /* 239 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var c = i(233), Z = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const L = Symbol.for("spritejs_setAttributeDefault"), K = Symbol.for("spritejs_setAttribute"), u = Symbol.for("spritejs_getAttribute");
      function a(r) {
        const {
          edges: X,
          radius: W,
          offsetAngle: p
        } = r, C = Math.PI * p / 180 - 0.5 * Math.PI;
        if (X < 3 || W <= 0)
          return [];
        const I = [];
        for (let o = 0; o < X; o++) {
          const G = o * 2 * Math.PI / X + C, d = W * Math.cos(G), t = W * Math.sin(G);
          I.push(d, t);
        }
        return I;
      }
      class e extends c.default {
        constructor(X) {
          super(X), this[L]({
            edges: 3,
            radius: 0,
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(X) {
        }
        // eslint-disable-line no-empty-function
        get edges() {
          return this[u]("edges");
        }
        set edges(X) {
          if (X = Object(Z.toNumber)(X), this[K]("edges", X)) {
            const W = a(this);
            super.points = W;
          }
        }
        get radius() {
          return this[u]("radius");
        }
        set radius(X) {
          if (X = Object(Z.toNumber)(X), this[K]("radius", X)) {
            const W = a(this);
            super.points = W;
          }
        }
        get offsetAngle() {
          return this[u]("offsetAngle");
        }
        set offsetAngle(X) {
          if (X = Object(Z.toNumber)(X), this[K]("offsetAngle", X)) {
            const W = a(this);
            super.points = W;
          }
        }
      }
    },
    /* 240 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(232), Z = i(213), L = i(241);
      i(1).glMatrix.setMatrixArrayType(Array);
      function K(a, e, r) {
        return e in a ? Object.defineProperty(a, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = r, a;
      }
      class u extends c.default {
      }
      K(u, "Attr", L.default), Z.default.registerNode(u, "star");
    },
    /* 241 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return e;
      });
      var c = i(233), Z = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const L = Symbol.for("spritejs_setAttributeDefault"), K = Symbol.for("spritejs_setAttribute"), u = Symbol.for("spritejs_getAttribute");
      function a(r) {
        const {
          angles: X,
          innerRadius: W,
          outerRadius: p,
          offsetAngle: C
        } = r, I = Math.PI * C / 180 - 0.5 * Math.PI;
        if (X < 3 || W <= 0 || p <= 0)
          return [];
        const o = [];
        for (let G = 0; G < X * 2; G++) {
          const d = G * Math.PI / X + I, t = G % 2 ? W : p, s = t * Math.cos(d), b = t * Math.sin(d);
          o.push(s, b);
        }
        return o;
      }
      class e extends c.default {
        constructor(X) {
          super(X), this[L]({
            angles: 5,
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            offsetAngle: 0,
            closeType: "normal"
          });
        }
        // readonly
        get points() {
          return super.points;
        }
        set points(X) {
        }
        // eslint-disable-line no-empty-function
        get angles() {
          return this[u]("angles");
        }
        set angles(X) {
          if (X = Object(Z.toNumber)(X), this[K]("angles", X)) {
            const W = a(this);
            super.points = W;
          }
        }
        get innerRadius() {
          return this[u]("innerRadius");
        }
        set innerRadius(X) {
          if (X = Object(Z.toNumber)(X), this[K]("innerRadius", X)) {
            const W = a(this);
            super.points = W;
          }
        }
        get outerRadius() {
          return this[u]("outerRadius");
        }
        set outerRadius(X) {
          if (X = Object(Z.toNumber)(X), this[K]("outerRadius", X)) {
            const W = a(this);
            super.points = W;
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(X) {
          X = Object(Z.toArray)(X, !0), Array.isArray(X) || (X = [X, X]), this.innerRadius = X[0], this.outerRadius = X[1];
        }
        get offsetAngle() {
          return this[u]("offsetAngle");
        }
        set offsetAngle(X) {
          if (X = Object(Z.toNumber)(X), this[K]("offsetAngle", X)) {
            const W = a(this);
            super.points = W;
          }
        }
      }
    },
    /* 242 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(226), Z = i(213), L = i(243);
      i(1).glMatrix.setMatrixArrayType(Array);
      function K(a, e, r) {
        return e in a ? Object.defineProperty(a, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = r, a;
      }
      class u extends c.default {
        /* override */
        get isVisible() {
          const {
            radiusX: e,
            radiusY: r,
            startAngle: X,
            endAngle: W
          } = this.attributes;
          return e > 0 && r > 0 && X !== W && super.isVisible;
        }
      }
      K(u, "Attr", L.default), Z.default.registerNode(u, "ellipse");
    },
    /* 243 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return X;
      });
      var c = i(12), Z = i(228), L = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const K = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_getAttribute"), e = Symbol.for("spritejs_declareAlias");
      function r(W) {
        const {
          radiusX: p,
          radiusY: C,
          startAngle: I,
          endAngle: o,
          direction: G,
          closeType: d
        } = W, t = G === "anitclockwise", s = new c.Figure2D();
        return d === "sector" && s.moveTo(0, 0), s.ellipse(0, 0, p, C, 0, Math.PI * I / 180, Math.PI * o / 180, t), d !== "none" && s.closePath(), s.path.reduce((S, Y) => S + Y.join(" "), "");
      }
      class X extends Z.default {
        constructor(p) {
          super(p), this[K]({
            radiusX: 0,
            radiusY: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360,
            /* angle */
            direction: "clockwise",
            // clockwise | anticlockwise
            closeType: "none"
            // none | sector | normal
          }), this[e]("radius", "angle");
        }
        // readonly
        get d() {
          return this[a]("d");
        }
        set d(p) {
        }
        // eslint-disable-line no-empty-function
        get radiusX() {
          return this[a]("radiusX");
        }
        set radiusX(p) {
          if (p = Object(L.toNumber)(p), this[u]("radiusX", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get radiusY() {
          return this[a]("radiusY");
        }
        set radiusY(p) {
          if (p = Object(L.toNumber)(p), this[u]("radiusY", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get radius() {
          return [this.radiusX, this.radiusY];
        }
        set radius(p) {
          p = Object(L.toArray)(p, !0), Array.isArray(p) || (p = [p, p]), this.radiusX = p[0], this.radiusY = p[1];
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(p) {
          p = Object(L.toArray)(p), Array.isArray(p) || (p = [p, p]), this.startAngle = p[0], this.endAngle = p[1];
        }
        get direction() {
          return this[a]("direction");
        }
        set direction(p) {
          if (p != null && p !== "clockwise" && p !== "anticlockwise")
            throw new TypeError("Invalid direction type.");
          this[u]("direction", p);
        }
        get startAngle() {
          return this[a]("startAngle");
        }
        set startAngle(p) {
          if (p = Object(L.toNumber)(p), this[u]("startAngle", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get endAngle() {
          return this[a]("endAngle");
        }
        set endAngle(p) {
          if (p = Object(L.toNumber)(p), this[u]("endAngle", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get closeType() {
          return this[a]("closeType");
        }
        set closeType(p) {
          if (p != null && p !== "none" && p !== "sector" && p !== "normal")
            throw new TypeError("Invalid closeType type.");
          if (this[u]("closeType", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
      }
    },
    /* 244 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(242), Z = i(213), L = i(245);
      i(1).glMatrix.setMatrixArrayType(Array);
      function K(a, e, r) {
        return e in a ? Object.defineProperty(a, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = r, a;
      }
      class u extends c.default {
      }
      K(u, "Attr", L.default), Z.default.registerNode(u, "arc");
    },
    /* 245 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return L;
      });
      var c = i(243), Z = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      class L extends c.default {
        get radius() {
          return super.radiusX;
        }
        set radius(u) {
          u = Object(Z.toNumber)(u), super.radiusX = u, super.radiusY = u;
        }
      }
    },
    /* 246 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(226), Z = i(213), L = i(247);
      i(1).glMatrix.setMatrixArrayType(Array);
      function K(a, e, r) {
        return e in a ? Object.defineProperty(a, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : a[e] = r, a;
      }
      class u extends c.default {
        /* override */
        get isVisible() {
          const {
            innerRadius: e,
            outerRadius: r,
            startAngle: X,
            endAngle: W
          } = this.attributes;
          return (e > 0 || r > 0) && X !== W && super.isVisible;
        }
      }
      K(u, "Attr", L.default), Z.default.registerNode(u, "ring");
    },
    /* 247 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return X;
      });
      var c = i(12), Z = i(228), L = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      const K = Symbol.for("spritejs_setAttributeDefault"), u = Symbol.for("spritejs_setAttribute"), a = Symbol.for("spritejs_getAttribute"), e = Symbol.for("spritejs_declareAlias");
      function r(W) {
        let {
          innerRadius: p,
          outerRadius: C,
          startAngle: I,
          endAngle: o
        } = W;
        const G = new c.Figure2D();
        if (I = Math.PI * I / 180, o = Math.PI * o / 180, p > C && ([p, C] = [C, p]), p <= 0 && G.moveTo(0, 0), G.arc(0, 0, C, I, o, !1), p > 0) {
          const s = Math.PI * 2;
          o < I && (o = I + s + (o - I) % s), o - I >= s && (o = I + s - 1e-6), G.arc(0, 0, p, o, I, !0);
        }
        return G.closePath(), G.path.reduce((s, b) => s + b.join(" "), "");
      }
      class X extends Z.default {
        constructor(p) {
          super(p), this[K]({
            innerRadius: 0,
            outerRadius: 0,
            /* radius */
            startAngle: 0,
            endAngle: 360
            /* angle */
          }), this[e]("radius", "angle");
        }
        // readonly
        get d() {
          return this[a]("d");
        }
        set d(p) {
        }
        // eslint-disable-line no-empty-function
        get innerRadius() {
          return this[a]("innerRadius");
        }
        set innerRadius(p) {
          if (p = Object(L.toNumber)(p), this[u]("innerRadius", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get outerRadius() {
          return this[a]("outerRadius");
        }
        set outerRadius(p) {
          if (p = Object(L.toNumber)(p), this[u]("outerRadius", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get radius() {
          return [this.innerRadius, this.outerRadius];
        }
        set radius(p) {
          p = Object(L.toArray)(p, !0), Array.isArray(p) || (p = [p, p]), this.innerRadius = p[0], this.outerRadius = p[1];
        }
        get startAngle() {
          return this[a]("startAngle");
        }
        set startAngle(p) {
          if (p = Object(L.toNumber)(p), this[u]("startAngle", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get endAngle() {
          return this[a]("endAngle");
        }
        set endAngle(p) {
          if (p = Object(L.toNumber)(p), this[u]("endAngle", p)) {
            const C = r(this);
            this[u]("d", C);
          }
        }
        get angle() {
          return [this.startAngle, this.endAngle];
        }
        set angle(p) {
          p = Object(L.toArray)(p), Array.isArray(p) || (p = [p, p]), this.startAngle = p[0], this.endAngle = p[1];
        }
      }
    },
    /* 248 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return C;
      });
      var c = i(12), Z = i(218), L = i(219), K = i(249), u = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(I, o, G) {
        return o in I ? Object.defineProperty(I, o, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : I[o] = G, I;
      }
      const e = Symbol("textImage"), r = Symbol("textImageTask"), X = Symbol("textureContext"), W = Symbol("updateTextureRect"), p = Symbol("textCanvas");
      class C extends L.default {
        constructor(o = {}) {
          typeof o == "string" && (o = {
            text: o
          }), super(o);
        }
        /* override */
        get contentSize() {
          let [o, G] = super.contentSize;
          const {
            width: d,
            height: t
          } = this.attributes;
          if (d == null || t == null) {
            const s = this[e];
            s && (d == null && (o = s.rect[2]), t == null && (G = s.rect[3]));
          }
          return [o, G];
        }
        get text() {
          return this.attributes.text;
        }
        set text(o) {
          this.attributes.text = o;
        }
        get textContent() {
          return this.attributes.text;
        }
        set textContent(o) {
          this.attributes.text = o;
        }
        get textImage() {
          return this[e] || {};
        }
        get textImageReady() {
          return this[r] || Promise.resolve();
        }
        /* override */
        draw(o) {
          super.draw(o);
          const G = this.mesh;
          if (G) {
            const d = this[e];
            if (d) {
              let t = G.texture;
              if (!t || this[X] && this[X] !== this.renderer || d.needsUpdate ? (d.needsUpdate = !1, Object(Z.deleteTexture)(d.image, this.renderer), t = Object(Z.createTexture)(d.image, this.renderer), this[W] = !0) : t = G.uniforms.u_texSampler, this[W]) {
                const [s, b] = d.rect.slice(2), [V, S] = this.contentSize, Y = this.attributes.textAlign, T = this.attributes.verticalAlign;
                let y = 0;
                Y === "center" ? y = (V - s) / 2 : (Y === "right" || Y === "end") && (y = V - s);
                const J = this.attributes.fontSize, N = this.attributes.lineHeight;
                let R = 0;
                T === "top" ? R = (J - N) / 2 : T === "bottom" && (R = (N - J) / 2);
                const {
                  paddingLeft: x,
                  paddingTop: M
                } = this.attributes, {
                  borderWidth: Q
                } = this.attributes;
                y += x + Q, R += M + Q;
                const {
                  anchorX: P,
                  anchorY: D
                } = this.attributes;
                y -= this.offsetSize[0] * P, R -= this.offsetSize[1] * D, G.setTexture(t, {
                  rect: [y, R, s, b]
                }), this[W] = !1, this[X] = this.renderer;
              }
            }
          }
          return o;
        }
        /* override */
        onPropertyChange(o, G, d) {
          o === "text" || o === "fontSize" || o === "fontFamily" || o === "fontStyle" || o === "fontVariant" || o === "fontWeight" || o === "fontStretch" || o === "lineHeight" || o === "strokeColor" || o === "fillColor" || o === "strokeWidth" ? this.updateText() : ((o === "textAlign" || o === "verticalAlign") && (this[W] = !0), super.onPropertyChange(o, G, d));
        }
        /* override */
        updateContours() {
          super.updateContours(), this[W] = !0;
        }
        updateText() {
          this[r] || (this[r] = Promise.resolve().then(() => {
            this[r] = null;
            const {
              text: o,
              font: G,
              fillColor: d,
              strokeColor: t,
              strokeWidth: s
            } = this.attributes, b = this.layer ? this.layer.displayRatio : 1;
            return this[p] = this[p] || c.ENV.createCanvas(1, 1), this[e] = c.ENV.createText(o, {
              font: G,
              fillColor: d,
              strokeColor: t,
              strokeWidth: s,
              parseFont: c.parseFont,
              ratio: b,
              textCanvas: this[p]
            }), this[e].needsUpdate = !0, this.updateContours(), this.forceUpdate(), this[e];
          }));
        }
      }
      a(C, "Attr", K.default), u.default.registerNode(C, "label");
    },
    /* 249 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return X;
      });
      var c = i(12), Z = i(72), L = i(221), K = i(220);
      i(1).glMatrix.setMatrixArrayType(Array);
      const u = Symbol.for("spritejs_setAttributeDefault"), a = Symbol.for("spritejs_setAttribute"), e = Symbol.for("spritejs_getAttribute"), r = Symbol.for("spritejs_declareAlias");
      class X extends K.default {
        constructor(p) {
          super(p), this[u]({
            text: "",
            fontSize: 16,
            fontFamily: "Helvetica,Arial,sans-serif",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            fontStretch: "normal",
            lineHeight: "",
            /* font */
            textAlign: "left",
            strokeColor: void 0,
            strokeWidth: 1,
            fillColor: void 0,
            verticalAlign: "middle"
          }), this[r]("font");
        }
        get text() {
          return this[e]("text") || " ";
        }
        set text(p) {
          this[a]("text", p);
        }
        get fontSize() {
          return this[e]("fontSize");
        }
        set fontSize(p) {
          this[a]("fontSize", Object(Z.toNumber)(p));
        }
        get fontFamily() {
          return this[e]("fontFamily");
        }
        set fontFamily(p) {
          this[a]("fontFamily", p);
        }
        get fontStyle() {
          return this[e]("fontStyle");
        }
        set fontStyle(p) {
          this[a]("fontStyle", p);
        }
        get fontVariant() {
          return this[e]("fontVariant");
        }
        set fontVariant(p) {
          this[a]("fontVariant", p);
        }
        get fontWeight() {
          return this[e]("fontWeight");
        }
        set fontWeight(p) {
          this[a]("fontWeight", p);
        }
        get fontStretch() {
          return this[e]("fontStretch");
        }
        set fontStretch(p) {
          this[a]("fontStretch", p);
        }
        get lineHeight() {
          return this[e]("lineHeight") || this.fontSize;
        }
        set lineHeight(p) {
          this[a]("lineHeight", Object(Z.toNumber)(p));
        }
        get textAlign() {
          return this[e]("textAlign");
        }
        set textAlign(p) {
          this[a]("textAlign", p);
        }
        get strokeColor() {
          return this[e]("strokeColor");
        }
        set strokeColor(p) {
          this[a]("strokeColor", Object(L.parseColor)(p));
        }
        get strokeWidth() {
          return this[e]("strokeWidth");
        }
        set strokeWidth(p) {
          this[a]("strokeWidth", Object(Z.toNumber)(p));
        }
        get verticalAlign() {
          return this[e]("verticalAlign");
        }
        set verticalAlign(p) {
          this[a]("verticalAlign", p);
        }
        get fillColor() {
          return this[e]("fillColor");
        }
        set fillColor(p) {
          this[a]("fillColor", Object(L.parseColor)(p));
        }
        get font() {
          const {
            fontStyle: p,
            fontVariant: C,
            fontWeight: I,
            fontStretch: o,
            fontSize: G,
            lineHeight: d,
            fontFamily: t
          } = this;
          return `${p} ${C} ${I} ${o} ${G}px/${d}px ${t}`;
        }
        set font(p) {
          if (p == null)
            this.fontStyle = null, this.fontVariant = null, this.fontWeight = null, this.fontStretch = null, this.fontSize = null, this.lineHeight = null, this.fontFamily = null;
          else {
            const C = Object(c.parseFont)(p);
            this.fontStyle = C.style, this.fontVariant = C.variant, this.fontWeight = C.weight, this.fontStretch = C.stretch, this.fontSize = Object(Z.toNumber)(`${C.size}${C.unit}`), C.lineHeight && (this.lineHeight = C.pxLineHeight), this.fontFamily = C.family;
          }
        }
      }
    },
    /* 250 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return p;
      });
      var c = i(12), Z = i(219), L = i(251), K = i(213), u = i(252);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(C, I, o) {
        return I in C ? Object.defineProperty(C, I, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : C[I] = o, C;
      }
      const e = Symbol("zOrder"), r = Symbol("ordered"), X = Symbol("children"), W = Symbol("sealed");
      class p extends Z.default {
        constructor(I = {}) {
          super(I), this[X] = [], this[r] = null, this[e] = 0;
        }
        get childNodes() {
          return this[X];
        }
        get children() {
          return this[X];
        }
        get orderedChildren() {
          return this[r] || (this[r] = [...this[X]], this[r].sort((I, o) => I.zIndex - o.zIndex || I.zOrder - o.zOrder)), this[r];
        }
        append(...I) {
          return I.map((o) => this.appendChild(o));
        }
        appendChild(I) {
          return I.remove(), this[X].push(I), I.connect(this, this[e]++), this[r] && (this[r].length && I.zIndex < this[r][this[r].length - 1].zIndex ? this.reorder() : this[r].push(I)), I;
        }
        /* override */
        // get isVisible() {
        //   return this.attributes.opacity > 0 && this[_children].length > 0;
        // }
        /* override */
        cloneNode(I = !1) {
          const o = super.cloneNode();
          return I && this[X].forEach((G) => {
            const d = G.cloneNode(I);
            o.appendChild(d);
          }), o;
        }
        /* override */
        dispatchPointerEvent(I) {
          const o = this.orderedChildren;
          for (let G = o.length - 1; G >= 0; G--)
            if (o[G].dispatchPointerEvent(I))
              return !0;
          return super.dispatchPointerEvent(I);
        }
        /* override */
        draw(I = []) {
          if (this.__cacheRenderMatrix = this.renderMatrix, super.draw(I), !this[W] && this.attributes.display !== "none") {
            const o = this.orderedChildren;
            for (let G = 0; G < o.length; G++)
              o[G].draw(I);
          }
          return this.__cacheRenderMatrix = null, I;
        }
        getElementById(I) {
          return Object(u.querySelector)(`#${I}`, this);
        }
        getElementsByClassName(I) {
          return Object(u.querySelectorAll)(`.${I}`, this);
        }
        getElementsByName(I) {
          return Object(u.querySelectorAll)(`[name="${I}"]`, this);
        }
        getElementsByTagName(I) {
          return Object(u.querySelectorAll)(I, this);
        }
        insertBefore(I, o) {
          if (o == null)
            return this.appendChild(I);
          I.remove();
          const G = this[X].indexOf(o);
          if (G < 0)
            throw new Error("Invalid reference node.");
          const d = o.zOrder;
          for (let t = G; t < this[X].length; t++) {
            const s = this[X][t].zOrder, b = this[X][t];
            delete b.zOrder, Object.defineProperty(b, "zOrder", {
              value: s + 1,
              writable: !1,
              configurable: !0
            });
          }
          if (this[X].splice(G, 0, I), I.connect(this, d), this[r])
            if (I.zIndex !== o.zIndex)
              this.reorder();
            else {
              const t = this[r].indexOf(o);
              this[r].splice(t, 0, I);
            }
          return I;
        }
        querySelector(I) {
          return Object(u.querySelector)(I, this);
        }
        querySelectorAll(I) {
          return Object(u.querySelectorAll)(I, this);
        }
        replaceChild(I, o) {
          I.remove();
          const G = this[X].indexOf(o);
          if (G < 0)
            throw new Error("Invalid reference node.");
          if (this[X][G] = I, I.connect(this, o.zOrder), this[r])
            if (I.zIndex !== o.zIndex)
              this.reorder();
            else {
              const d = this[r].indexOf(o);
              this[r][d] = I;
            }
          return o.disconnect(this), I;
        }
        removeAllChildren() {
          const I = this[X];
          for (let o = I.length - 1; o >= 0; o--)
            I[o].remove();
        }
        removeChild(I) {
          const o = this[X].indexOf(I);
          if (o >= 0) {
            if (this[X].splice(o, 1), this[r]) {
              const G = this[r].indexOf(I);
              this[r].splice(G, 1);
            }
            return I.disconnect(this), I;
          }
          return null;
        }
        reorder() {
          this[r] = null;
        }
        seal() {
          function I(t, s) {
            const b = [];
            for (let V = 0; V < t.length; V++) {
              const S = [...t[V]];
              for (let Y = 1; Y < S.length; Y += 2) {
                const T = S[Y], y = S[Y + 1];
                S[Y] = T * s[0] + y * s[2] + s[4], S[Y + 1] = T * s[1] + y * s[3] + s[5];
              }
              b.push(S);
            }
            return b;
          }
          const o = this.orderedChildren, G = new c.Figure2D(), d = this.localMatrix;
          for (let t = 0; t < o.length; t++) {
            let s = o[t];
            if (s instanceof p && (s = s.seal()), s.clientBox) {
              let b = s.clientBox.contours.path;
              b = I(b, s.localMatrix), G.addPath(b);
            }
            if (s.path) {
              let b = s.path.contours.path;
              b = I(b, s.localMatrix), G.addPath(b);
            }
          }
          return this[W] = !0, this.clientBox = G, {
            clientBox: G,
            localMatrix: d
          };
        }
        /* override */
        setResolution({
          width: I,
          height: o
        }) {
          super.setResolution({
            width: I,
            height: o
          }), this[X].forEach((G) => {
            G.setResolution({
              width: I,
              height: o
            });
          });
        }
        /* override */
        updateContours() {
          this[W] || super.updateContours();
        }
      }
      a(p, "Attr", L.default), K.default.registerNode(p, "group");
    },
    /* 251 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return Z;
      });
      var c = i(220);
      i(1).glMatrix.setMatrixArrayType(Array);
      class Z extends c.default {
        // constructor(subject) {
        //   super(subject);
        //   this[setDefault]({
        //     pointerEvents: 'all',
        //   });
        // }
      }
    },
    /* 252 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "querySelectorAll", function() {
        return W;
      }), i.d(l, "querySelector", function() {
        return p;
      }), i.d(l, "isMatched", function() {
        return C;
      }), i.d(l, "compile", function() {
        return I;
      });
      var c = i(221), Z = i(213);
      i(1).glMatrix.setMatrixArrayType(Array);
      const L = i(253);
      function K(o) {
        return o.nodeType === 1 || Z.default.isSpriteNode(o.nodeName);
      }
      function u(o) {
        return Array.from(o.childNodes || []);
      }
      function a(o) {
        return Z.default.isSpriteNode(o.nodeName) ? o.parent || o.canvas || o.container : o.parentElement;
      }
      function e(o) {
        let G = o.length, d, t, s;
        for (; --G > -1; ) {
          for (d = t = o[G], o[G] = null, s = !0; t; ) {
            if (o.indexOf(t) > -1) {
              s = !1, o.splice(G, 1);
              break;
            }
            t = a(t);
          }
          s && (o[G] = d);
        }
        return o;
      }
      const r = {
        isTag: K,
        existsOne(o, G) {
          return G.some((d) => K(d) ? o(d) || r.existsOne(o, u(d)) : !1);
        },
        getSiblings(o) {
          const G = a(o);
          return G && u(G);
        },
        getChildren: u,
        getParent: a,
        getAttributeValue(o, G) {
          if (o.nodeType === 1 && G === "class" || G === "id")
            return o[G];
          if (this.hasAttrib(o, G)) {
            let d = o.attributes[G];
            return Array.isArray(d) && (d = `[${d.join()}]`), String(d);
          }
        },
        hasAttrib(o, G) {
          return o.attributes[G] != null;
        },
        removeSubsets: e,
        getName(o) {
          return o.tagName ? o.tagName.toLowerCase() : null;
        },
        findOne: function o(G, d) {
          let t = null;
          for (let s = 0, b = d.length; s < b && !t; s++)
            if (G(d[s]))
              t = d[s];
            else {
              const V = u(d[s]);
              V && V.length > 0 && (t = o(G, V));
            }
          return t;
        },
        findAll: function o(G, d) {
          let t = [];
          for (let s = 0, b = d.length; s < b; s++) {
            if (!K(d[s]))
              continue;
            G(d[s]) && t.push(d[s]);
            const V = u(d[s]);
            V && (t = t.concat(o(G, V)));
          }
          return t;
        },
        getText: function o(G) {
          return Array.isArray(G) ? G.map(o).join("") : K(G) ? o(u(G)) : G.nodeType === 3 ? G.nodeValue : Z.default.isSpriteNode(G.nodeName) ? G.text : "";
        }
      };
      function X(o) {
        if (typeof o != "string")
          return o;
        let G = o.match(/\[(bgcolor|fillColor|strokeColor|color)\s*=\s*['"]?\w+['"]?\]/g);
        return G && (G = G.map((d) => {
          const t = d.slice(1, -1).split("="), s = Object(c.parseColor)(t[1].replace(/['"]/g, ""));
          return [d, `[${t[0]}="${s}"]`];
        }), G.forEach(([d, t]) => {
          o = o.replace(d, t);
        })), G = o.match(/\[\w+\s*=\s*['"]\[.+?\]['"]\]/g), G && (G = G.map((d) => {
          const t = d.slice(1, -1).split("="), s = t[1].slice(2, -2).split(/,/g).map((b) => b.trim());
          return [d, `[${t[0]}="[${s}]"]`];
        }), G.forEach(([d, t]) => {
          o = o.replace(d, t);
        })), o;
      }
      function W(o, G) {
        return L.selectAll(X(o), G, {
          adapter: r
        });
      }
      function p(o, G) {
        return L.selectOne(X(o), G, {
          adapter: r
        });
      }
      function C(o, G) {
        return L.is(o, X(G), {
          adapter: r
        });
      }
      function I(o) {
        return L.compile(X(o), {
          adapter: r
        });
      }
    },
    /* 253 */
    /***/
    function(n, l, i) {
      n.exports = I;
      var c = i(254), Z = i(273).falseFunc, L = i(274);
      function K(o) {
        return function(d, t, s) {
          return t = t || {}, t.adapter = t.adapter || c, o(d, t, s);
        };
      }
      var u = K(L), a = K(L.compileUnsafe);
      function e(o) {
        return function(d, t, s) {
          return s = s || {}, s.adapter = s.adapter || c, typeof d != "function" && (d = a(d, s, t)), d.shouldTestNextSiblings && (t = X(s && s.context || t, s.adapter)), Array.isArray(t) ? t = s.adapter.removeSubsets(t) : t = s.adapter.getChildren(t), o(d, t, s);
        };
      }
      function r(o, G) {
        var d = G.getSiblings(o);
        if (!Array.isArray(d))
          return [];
        for (d = d.slice(0); d.shift() !== o; )
          ;
        return d;
      }
      function X(o, G) {
        Array.isArray(o) || (o = [o]);
        for (var d = o.slice(0), t = 0, s = o.length; t < s; t++) {
          var b = r(d[t], G);
          d.push.apply(d, b);
        }
        return d;
      }
      var W = e(function(G, d, t) {
        return G === Z || !d || d.length === 0 ? [] : t.adapter.findAll(G, d);
      }), p = e(function(G, d, t) {
        return G === Z || !d || d.length === 0 ? null : t.adapter.findOne(G, d);
      });
      function C(o, G, d) {
        return d = d || {}, d.adapter = d.adapter || c, (typeof G == "function" ? G : u(G, d))(o);
      }
      function I(o, G, d) {
        return W(o, G, d);
      }
      I.compile = u, I.filters = L.Pseudos.filters, I.pseudos = L.Pseudos.pseudos, I.selectAll = W, I.selectOne = p, I.is = C, I.parse = u, I.iterate = W, I._compileUnsafe = a, I._compileToken = L.compileToken;
    },
    /* 254 */
    /***/
    function(n, l, i) {
      var c = n.exports;
      [
        i(255),
        i(268),
        i(269),
        i(270),
        i(271),
        i(272)
      ].forEach(function(Z) {
        Object.keys(Z).forEach(function(L) {
          c[L] = Z[L].bind(c);
        });
      });
    },
    /* 255 */
    /***/
    function(n, l, i) {
      var c = i(256), Z = i(257), L = c.isTag;
      n.exports = {
        getInnerHTML: K,
        getOuterHTML: Z,
        getText: u
      };
      function K(a, e) {
        return a.children ? a.children.map(function(r) {
          return Z(r, e);
        }).join("") : "";
      }
      function u(a) {
        return Array.isArray(a) ? a.map(u).join("") : L(a) ? a.name === "br" ? `
` : u(a.children) : a.type === c.CDATA ? u(a.children) : a.type === c.Text ? a.data : "";
      }
    },
    /* 256 */
    /***/
    function(n, l) {
      n.exports = {
        Text: "text",
        //Text
        Directive: "directive",
        //<? ... ?>
        Comment: "comment",
        //<!-- ... -->
        Script: "script",
        //<script> tags
        Style: "style",
        //<style> tags
        Tag: "tag",
        //Any tag
        CDATA: "cdata",
        //<![CDATA[ ... ]]>
        Doctype: "doctype",
        isTag: function(i) {
          return i.type === "tag" || i.type === "script" || i.type === "style";
        }
      };
    },
    /* 257 */
    /***/
    function(n, l, i) {
      var c = i(258), Z = i(259), L = i(267);
      L.elementNames.__proto__ = null, L.attributeNames.__proto__ = null;
      var K = {
        __proto__: null,
        style: !0,
        script: !0,
        xmp: !0,
        iframe: !0,
        noembed: !0,
        noframes: !0,
        plaintext: !0,
        noscript: !0
      };
      function u(o, G) {
        if (o) {
          var d = "", t;
          for (var s in o)
            t = o[s], d && (d += " "), G.xmlMode === "foreign" && (s = L.attributeNames[s] || s), d += s, (t !== null && t !== "" || G.xmlMode) && (d += '="' + (G.decodeEntities ? Z.encodeXML(t) : t.replace(/\"/g, "&quot;")) + '"');
          return d;
        }
      }
      var a = {
        __proto__: null,
        area: !0,
        base: !0,
        basefont: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        isindex: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, e = n.exports = function(o, G) {
        !Array.isArray(o) && !o.cheerio && (o = [o]), G = G || {};
        for (var d = "", t = 0; t < o.length; t++) {
          var s = o[t];
          s.type === "root" ? d += e(s.children, G) : c.isTag(s) ? d += X(s, G) : s.type === c.Directive ? d += W(s) : s.type === c.Comment ? d += I(s) : s.type === c.CDATA ? d += C(s) : d += p(s, G);
        }
        return d;
      }, r = [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ];
      function X(o, G) {
        G.xmlMode === "foreign" && (o.name = L.elementNames[o.name] || o.name, o.parent && r.indexOf(o.parent.name) >= 0 && (G = Object.assign({}, G, { xmlMode: !1 }))), !G.xmlMode && ["svg", "math"].indexOf(o.name) >= 0 && (G = Object.assign({}, G, { xmlMode: "foreign" }));
        var d = "<" + o.name, t = u(o.attribs, G);
        return t && (d += " " + t), G.xmlMode && (!o.children || o.children.length === 0) ? d += "/>" : (d += ">", o.children && (d += e(o.children, G)), (!a[o.name] || G.xmlMode) && (d += "</" + o.name + ">")), d;
      }
      function W(o) {
        return "<" + o.data + ">";
      }
      function p(o, G) {
        var d = o.data || "";
        return G.decodeEntities && !(o.parent && o.parent.name in K) && (d = Z.encodeXML(d)), d;
      }
      function C(o) {
        return "<![CDATA[" + o.children[0].data + "]]>";
      }
      function I(o) {
        return "<!--" + o.data + "-->";
      }
    },
    /* 258 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 });
      function c(Z) {
        return Z.type === "tag" || Z.type === "script" || Z.type === "style";
      }
      l.isTag = c, l.Text = "text", l.Directive = "directive", l.Comment = "comment", l.Script = "script", l.Style = "style", l.Tag = "tag", l.CDATA = "cdata", l.Doctype = "doctype";
    },
    /* 259 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 }), l.encode = l.decodeStrict = l.decode = void 0;
      var c = i(260), Z = i(266);
      function L(r, X) {
        return (!X || X <= 0 ? c.decodeXML : c.decodeHTML)(r);
      }
      l.decode = L;
      function K(r, X) {
        return (!X || X <= 0 ? c.decodeXML : c.decodeHTMLStrict)(r);
      }
      l.decodeStrict = K;
      function u(r, X) {
        return (!X || X <= 0 ? Z.encodeXML : Z.encodeHTML)(r);
      }
      l.encode = u;
      var a = i(266);
      Object.defineProperty(l, "encodeXML", { enumerable: !0, get: function() {
        return a.encodeXML;
      } }), Object.defineProperty(l, "encodeHTML", { enumerable: !0, get: function() {
        return a.encodeHTML;
      } }), Object.defineProperty(l, "escape", { enumerable: !0, get: function() {
        return a.escape;
      } }), Object.defineProperty(l, "encodeHTML4", { enumerable: !0, get: function() {
        return a.encodeHTML;
      } }), Object.defineProperty(l, "encodeHTML5", { enumerable: !0, get: function() {
        return a.encodeHTML;
      } });
      var e = i(260);
      Object.defineProperty(l, "decodeXML", { enumerable: !0, get: function() {
        return e.decodeXML;
      } }), Object.defineProperty(l, "decodeHTML", { enumerable: !0, get: function() {
        return e.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTMLStrict", { enumerable: !0, get: function() {
        return e.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeHTML4", { enumerable: !0, get: function() {
        return e.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTML5", { enumerable: !0, get: function() {
        return e.decodeHTML;
      } }), Object.defineProperty(l, "decodeHTML4Strict", { enumerable: !0, get: function() {
        return e.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeHTML5Strict", { enumerable: !0, get: function() {
        return e.decodeHTMLStrict;
      } }), Object.defineProperty(l, "decodeXMLStrict", { enumerable: !0, get: function() {
        return e.decodeXML;
      } });
    },
    /* 260 */
    /***/
    function(n, l, i) {
      var c = this && this.__importDefault || function(X) {
        return X && X.__esModule ? X : { default: X };
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), l.decodeHTML = l.decodeHTMLStrict = l.decodeXML = void 0;
      var Z = c(i(261)), L = c(i(262)), K = c(i(263)), u = c(i(264));
      l.decodeXML = a(K.default), l.decodeHTMLStrict = a(Z.default);
      function a(X) {
        var W = Object.keys(X).join("|"), p = r(X);
        W += "|#[xX][\\da-fA-F]+|#\\d+";
        var C = new RegExp("&(?:" + W + ");", "g");
        return function(I) {
          return String(I).replace(C, p);
        };
      }
      var e = function(X, W) {
        return X < W ? 1 : -1;
      };
      l.decodeHTML = function() {
        for (var X = Object.keys(L.default).sort(e), W = Object.keys(Z.default).sort(e), p = 0, C = 0; p < W.length; p++)
          X[C] === W[p] ? (W[p] += ";?", C++) : W[p] += ";";
        var I = new RegExp("&(?:" + W.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), o = r(Z.default);
        function G(d) {
          return d.substr(-1) !== ";" && (d += ";"), o(d);
        }
        return function(d) {
          return String(d).replace(I, G);
        };
      }();
      function r(X) {
        return function(p) {
          if (p.charAt(1) === "#") {
            var C = p.charAt(2);
            return C === "X" || C === "x" ? u.default(parseInt(p.substr(3), 16)) : u.default(parseInt(p.substr(2), 10));
          }
          return X[p.slice(1, -1)];
        };
      }
    },
    /* 261 */
    /***/
    function(n) {
      n.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');
    },
    /* 262 */
    /***/
    function(n) {
      n.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');
    },
    /* 263 */
    /***/
    function(n) {
      n.exports = JSON.parse(`{"amp":"&","apos":"'","gt":">","lt":"<","quot":"\\""}`);
    },
    /* 264 */
    /***/
    function(n, l, i) {
      var c = this && this.__importDefault || function(K) {
        return K && K.__esModule ? K : { default: K };
      };
      Object.defineProperty(l, "__esModule", { value: !0 });
      var Z = c(i(265));
      function L(K) {
        if (K >= 55296 && K <= 57343 || K > 1114111)
          return "�";
        K in Z.default && (K = Z.default[K]);
        var u = "";
        return K > 65535 && (K -= 65536, u += String.fromCharCode(K >>> 10 & 1023 | 55296), K = 56320 | K & 1023), u += String.fromCharCode(K), u;
      }
      l.default = L;
    },
    /* 265 */
    /***/
    function(n) {
      n.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');
    },
    /* 266 */
    /***/
    function(n, l, i) {
      var c = this && this.__importDefault || function(G) {
        return G && G.__esModule ? G : { default: G };
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), l.escape = l.encodeHTML = l.encodeXML = void 0;
      var Z = c(i(263)), L = r(Z.default), K = X(L);
      l.encodeXML = C(L, K);
      var u = c(i(261)), a = r(u.default), e = X(a);
      l.encodeHTML = C(a, e);
      function r(G) {
        return Object.keys(G).sort().reduce(function(d, t) {
          return d[G[t]] = "&" + t + ";", d;
        }, {});
      }
      function X(G) {
        for (var d = [], t = [], s = 0, b = Object.keys(G); s < b.length; s++) {
          var V = b[s];
          V.length === 1 ? d.push("\\" + V) : t.push(V);
        }
        d.sort();
        for (var S = 0; S < d.length - 1; S++) {
          for (var Y = S; Y < d.length - 1 && d[Y].charCodeAt(1) + 1 === d[Y + 1].charCodeAt(1); )
            Y += 1;
          var T = 1 + Y - S;
          T < 3 || d.splice(S, T, d[S] + "-" + d[Y]);
        }
        return t.unshift("[" + d.join("") + "]"), new RegExp(t.join("|"), "g");
      }
      var W = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
      function p(G) {
        return "&#x" + G.codePointAt(0).toString(16).toUpperCase() + ";";
      }
      function C(G, d) {
        return function(t) {
          return t.replace(d, function(s) {
            return G[s];
          }).replace(W, p);
        };
      }
      var I = X(L);
      function o(G) {
        return G.replace(I, p).replace(W, p);
      }
      l.escape = o;
    },
    /* 267 */
    /***/
    function(n) {
      n.exports = JSON.parse('{"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}}');
    },
    /* 268 */
    /***/
    function(n, l) {
      var i = l.getChildren = function(Z) {
        return Z.children;
      }, c = l.getParent = function(Z) {
        return Z.parent;
      };
      l.getSiblings = function(Z) {
        var L = c(Z);
        return L ? i(L) : [Z];
      }, l.getAttributeValue = function(Z, L) {
        return Z.attribs && Z.attribs[L];
      }, l.hasAttrib = function(Z, L) {
        return !!Z.attribs && hasOwnProperty.call(Z.attribs, L);
      }, l.getName = function(Z) {
        return Z.name;
      };
    },
    /* 269 */
    /***/
    function(n, l) {
      l.removeElement = function(i) {
        if (i.prev && (i.prev.next = i.next), i.next && (i.next.prev = i.prev), i.parent) {
          var c = i.parent.children;
          c.splice(c.lastIndexOf(i), 1);
        }
      }, l.replaceElement = function(i, c) {
        var Z = c.prev = i.prev;
        Z && (Z.next = c);
        var L = c.next = i.next;
        L && (L.prev = c);
        var K = c.parent = i.parent;
        if (K) {
          var u = K.children;
          u[u.lastIndexOf(i)] = c;
        }
      }, l.appendChild = function(i, c) {
        if (c.parent = i, i.children.push(c) !== 1) {
          var Z = i.children[i.children.length - 2];
          Z.next = c, c.prev = Z, c.next = null;
        }
      }, l.append = function(i, c) {
        var Z = i.parent, L = i.next;
        if (c.next = L, c.prev = i, i.next = c, c.parent = Z, L) {
          if (L.prev = c, Z) {
            var K = Z.children;
            K.splice(K.lastIndexOf(L), 0, c);
          }
        } else
          Z && Z.children.push(c);
      }, l.prepend = function(i, c) {
        var Z = i.parent;
        if (Z) {
          var L = Z.children;
          L.splice(L.lastIndexOf(i), 0, c);
        }
        i.prev && (i.prev.next = c), c.parent = Z, c.prev = i.prev, c.next = i, i.prev = c;
      };
    },
    /* 270 */
    /***/
    function(n, l, i) {
      var c = i(256).isTag;
      n.exports = {
        filter: Z,
        find: L,
        findOneChild: K,
        findOne: u,
        existsOne: a,
        findAll: e
      };
      function Z(r, X, W, p) {
        return Array.isArray(X) || (X = [X]), (typeof p != "number" || !isFinite(p)) && (p = 1 / 0), L(r, X, W !== !1, p);
      }
      function L(r, X, W, p) {
        for (var C = [], I, o = 0, G = X.length; o < G && !(r(X[o]) && (C.push(X[o]), --p <= 0) || (I = X[o].children, W && I && I.length > 0 && (I = L(r, I, W, p), C = C.concat(I), p -= I.length, p <= 0))); o++)
          ;
        return C;
      }
      function K(r, X) {
        for (var W = 0, p = X.length; W < p; W++)
          if (r(X[W]))
            return X[W];
        return null;
      }
      function u(r, X) {
        for (var W = null, p = 0, C = X.length; p < C && !W; p++)
          if (c(X[p]))
            r(X[p]) ? W = X[p] : X[p].children.length > 0 && (W = u(r, X[p].children));
          else
            continue;
        return W;
      }
      function a(r, X) {
        for (var W = 0, p = X.length; W < p; W++)
          if (c(X[W]) && (r(X[W]) || X[W].children.length > 0 && a(r, X[W].children)))
            return !0;
        return !1;
      }
      function e(r, X) {
        for (var W = [], p = X.slice(); p.length; ) {
          var C = p.shift();
          c(C) && (C.children && C.children.length > 0 && p.unshift.apply(p, C.children), r(C) && W.push(C));
        }
        return W;
      }
    },
    /* 271 */
    /***/
    function(n, l, i) {
      var c = i(256), Z = l.isTag = c.isTag;
      l.testElement = function(a, e) {
        for (var r in a)
          if (a.hasOwnProperty(r)) {
            if (r === "tag_name") {
              if (!Z(e) || !a.tag_name(e.name))
                return !1;
            } else if (r === "tag_type") {
              if (!a.tag_type(e.type))
                return !1;
            } else if (r === "tag_contains") {
              if (Z(e) || !a.tag_contains(e.data))
                return !1;
            } else if (!e.attribs || !a[r](e.attribs[r]))
              return !1;
          }
        return !0;
      };
      var L = {
        tag_name: function(a) {
          return typeof a == "function" ? function(e) {
            return Z(e) && a(e.name);
          } : a === "*" ? Z : function(e) {
            return Z(e) && e.name === a;
          };
        },
        tag_type: function(a) {
          return typeof a == "function" ? function(e) {
            return a(e.type);
          } : function(e) {
            return e.type === a;
          };
        },
        tag_contains: function(a) {
          return typeof a == "function" ? function(e) {
            return !Z(e) && a(e.data);
          } : function(e) {
            return !Z(e) && e.data === a;
          };
        }
      };
      function K(a, e) {
        return typeof e == "function" ? function(r) {
          return r.attribs && e(r.attribs[a]);
        } : function(r) {
          return r.attribs && r.attribs[a] === e;
        };
      }
      function u(a, e) {
        return function(r) {
          return a(r) || e(r);
        };
      }
      l.getElements = function(a, e, r, X) {
        var W = Object.keys(a).map(function(p) {
          var C = a[p];
          return p in L ? L[p](C) : K(p, C);
        });
        return W.length === 0 ? [] : this.filter(
          W.reduce(u),
          e,
          r,
          X
        );
      }, l.getElementById = function(a, e, r) {
        return Array.isArray(e) || (e = [e]), this.findOne(K("id", a), e, r !== !1);
      }, l.getElementsByTagName = function(a, e, r, X) {
        return this.filter(L.tag_name(a), e, r, X);
      }, l.getElementsByTagType = function(a, e, r, X) {
        return this.filter(L.tag_type(a), e, r, X);
      };
    },
    /* 272 */
    /***/
    function(n, l) {
      l.removeSubsets = function(Z) {
        for (var L = Z.length, K, u, a; --L > -1; ) {
          for (K = u = Z[L], Z[L] = null, a = !0; u; ) {
            if (Z.indexOf(u) > -1) {
              a = !1, Z.splice(L, 1);
              break;
            }
            u = u.parent;
          }
          a && (Z[L] = K);
        }
        return Z;
      };
      var i = {
        DISCONNECTED: 1,
        PRECEDING: 2,
        FOLLOWING: 4,
        CONTAINS: 8,
        CONTAINED_BY: 16
      }, c = l.compareDocumentPosition = function(Z, L) {
        var K = [], u = [], a, e, r, X, W, p;
        if (Z === L)
          return 0;
        for (a = Z; a; )
          K.unshift(a), a = a.parent;
        for (a = L; a; )
          u.unshift(a), a = a.parent;
        for (p = 0; K[p] === u[p]; )
          p++;
        return p === 0 ? i.DISCONNECTED : (e = K[p - 1], r = e.children, X = K[p], W = u[p], r.indexOf(X) > r.indexOf(W) ? e === L ? i.FOLLOWING | i.CONTAINED_BY : i.FOLLOWING : e === Z ? i.PRECEDING | i.CONTAINS : i.PRECEDING);
      };
      l.uniqueSort = function(Z) {
        var L = Z.length, K, u;
        for (Z = Z.slice(); --L > -1; )
          K = Z[L], u = Z.indexOf(K), u > -1 && u < L && Z.splice(L, 1);
        return Z.sort(function(a, e) {
          var r = c(a, e);
          return r & i.PRECEDING ? -1 : r & i.FOLLOWING ? 1 : 0;
        }), Z;
      };
    },
    /* 273 */
    /***/
    function(n, l) {
      n.exports = {
        trueFunc: function() {
          return !0;
        },
        falseFunc: function() {
          return !1;
        }
      };
    },
    /* 274 */
    /***/
    function(n, l, i) {
      n.exports = W;
      var c = i(275).parse, Z = i(273), L = i(278), K = i(279), u = i(280), a = i(282), e = Z.trueFunc, r = Z.falseFunc, X = a.filters;
      function W(y, J, N) {
        var R = C(y, J, N);
        return p(R, J);
      }
      function p(y, J) {
        var N = J.adapter;
        return function(x) {
          return N.isTag(x) && y(x);
        };
      }
      function C(y, J, N) {
        var R = c(y, J);
        return b(R, J, N);
      }
      function I(y) {
        return y.type === "pseudo" && (y.name === "scope" || Array.isArray(y.data) && y.data.some(function(J) {
          return J.some(I);
        }));
      }
      var o = { type: "descendant" }, G = { type: "_flexibleDescendant" }, d = { type: "pseudo", name: "scope" }, t = {};
      function s(y, J, N) {
        var R = J.adapter, x = !!N && !!N.length && N.every(function(M) {
          return M === t || !!R.getParent(M);
        });
        y.forEach(function(M) {
          if (!(M.length > 0 && V(M[0]) && M[0].type !== "descendant"))
            if (x && !(Array.isArray(M) ? M.some(I) : I(M)))
              M.unshift(o);
            else
              return;
          M.unshift(d);
        });
      }
      function b(y, J, N) {
        y = y.filter(function(Q) {
          return Q.length > 0;
        }), y.forEach(L);
        var R = Array.isArray(N);
        N = J && J.context || N, N && !R && (N = [N]), s(y, J, N);
        var x = !1, M = y.map(function(Q) {
          if (Q[0] && Q[1] && Q[0].name === "scope") {
            var P = Q[1].type;
            R && P === "descendant" ? Q[1] = G : (P === "adjacent" || P === "sibling") && (x = !0);
          }
          return S(Q, J, N);
        }).reduce(Y, r);
        return M.shouldTestNextSiblings = x, M;
      }
      function V(y) {
        return K[y.type] < 0;
      }
      function S(y, J, N) {
        return y.reduce(function(R, x) {
          if (R === r)
            return R;
          if (!(x.type in u))
            throw new Error("Rule type " + x.type + " is not supported by css-select");
          return u[x.type](R, x, J, N);
        }, J && J.rootFunc || e);
      }
      function Y(y, J) {
        return J === r || y === e ? y : y === r || J === e ? J : function(R) {
          return y(R) || J(R);
        };
      }
      function T(y) {
        return y.some(V);
      }
      X.not = function(y, J, N, R) {
        var x = {
          xmlMode: !!(N && N.xmlMode),
          strict: !!(N && N.strict),
          adapter: N.adapter
        };
        if (x.strict && (J.length > 1 || J.some(T)))
          throw new Error("complex selectors in :not aren't allowed in strict mode");
        var M = b(J, x, R);
        return M === r ? y : M === e ? r : function(P) {
          return !M(P) && y(P);
        };
      }, X.has = function(y, J, N) {
        var R = N.adapter, x = {
          xmlMode: !!(N && N.xmlMode),
          strict: !!(N && N.strict),
          adapter: R
        }, M = J.some(T) ? [t] : null, Q = b(J, x, M);
        return Q === r ? r : Q === e ? function(D) {
          return R.getChildren(D).some(R.isTag) && y(D);
        } : (Q = p(Q, N), M ? function(D) {
          return y(D) && (M[0] = D, R.existsOne(Q, R.getChildren(D)));
        } : function(D) {
          return y(D) && R.existsOne(Q, R.getChildren(D));
        });
      }, X.matches = function(y, J, N, R) {
        var x = {
          xmlMode: !!(N && N.xmlMode),
          strict: !!(N && N.strict),
          rootFunc: y,
          adapter: N.adapter
        };
        return b(J, x, R);
      }, W.compileToken = b, W.compileUnsafe = C, W.Pseudos = a;
    },
    /* 275 */
    /***/
    function(n, l, i) {
      var c = this && this.__createBinding || (Object.create ? function(u, a, e, r) {
        r === void 0 && (r = e), Object.defineProperty(u, r, { enumerable: !0, get: function() {
          return a[e];
        } });
      } : function(u, a, e, r) {
        r === void 0 && (r = e), u[r] = a[e];
      }), Z = this && this.__exportStar || function(u, a) {
        for (var e in u)
          e !== "default" && !a.hasOwnProperty(e) && c(a, u, e);
      };
      Object.defineProperty(l, "__esModule", { value: !0 }), Z(i(276), l);
      var L = i(276);
      Object.defineProperty(l, "parse", { enumerable: !0, get: function() {
        return L.default;
      } });
      var K = i(277);
      Object.defineProperty(l, "stringify", { enumerable: !0, get: function() {
        return K.default;
      } });
    },
    /* 276 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 }), l.default = I;
      var c = /^[^\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, Z = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, L = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/, K = {
        undefined: "exists",
        "": "equals",
        "~": "element",
        "^": "start",
        $: "end",
        "*": "any",
        "!": "not",
        "|": "hyphen"
      }, u = {
        ">": "child",
        "<": "parent",
        "~": "sibling",
        "+": "adjacent"
      }, a = {
        "#": ["id", "equals"],
        ".": ["class", "element"]
      }, e = /* @__PURE__ */ new Set(["has", "not", "matches"]), r = /* @__PURE__ */ new Set(["contains", "icontains"]), X = /* @__PURE__ */ new Set(['"', "'"]);
      function W(d, t, s) {
        var b = parseInt(t, 16) - 65536;
        return b !== b || s ? t : b < 0 ? (
          // BMP codepoint
          String.fromCharCode(b + 65536)
        ) : (
          // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(b >> 10 | 55296, b & 1023 | 56320)
        );
      }
      function p(d) {
        return d.replace(Z, W);
      }
      function C(d) {
        return d === " " || d === `
` || d === "	" || d === "\f" || d === "\r";
      }
      function I(d, t) {
        var s = [];
        if (d = o(s, "" + d, t), d !== "")
          throw new Error("Unmatched selector: " + d);
        return s;
      }
      function o(d, t, s) {
        var b = [], V = !1;
        function S() {
          var O = t.match(c);
          if (!O)
            throw new Error("Expected name, found " + t);
          var li = O[0];
          return t = t.substr(li.length), p(li);
        }
        function Y(O) {
          for (; C(t.charAt(O)); )
            O++;
          t = t.substr(O);
        }
        function T(O) {
          for (var li = 0; t.charAt(--O) === "\\"; )
            li++;
          return (li & 1) === 1;
        }
        for (Y(0); t !== ""; ) {
          var y = t.charAt(0);
          if (C(y))
            V = !0, Y(1);
          else if (y in u)
            b.push({ type: u[y] }), V = !1, Y(1);
          else if (y === ",") {
            if (b.length === 0)
              throw new Error("Empty sub-selector");
            d.push(b), b = [], V = !1, Y(1);
          } else if (V && (b.length > 0 && b.push({ type: "descendant" }), V = !1), y === "*")
            t = t.substr(1), b.push({ type: "universal" });
          else if (y in a) {
            var J = a[y], N = J[0], R = J[1];
            t = t.substr(1), b.push({
              type: "attribute",
              name: N,
              action: R,
              value: S(),
              ignoreCase: !1
            });
          } else if (y === "[") {
            t = t.substr(1);
            var x = t.match(L);
            if (!x)
              throw new Error("Malformed attribute selector: " + t);
            t = t.substr(x[0].length);
            var M = p(x[1]);
            (!s || ("lowerCaseAttributeNames" in s ? s.lowerCaseAttributeNames : !s.xmlMode)) && (M = M.toLowerCase()), b.push({
              type: "attribute",
              name: M,
              action: K[x[2]],
              value: p(x[4] || x[5] || ""),
              ignoreCase: !!x[6]
            });
          } else if (y === ":") {
            if (t.charAt(1) === ":") {
              t = t.substr(2), b.push({
                type: "pseudo-element",
                name: S().toLowerCase()
              });
              continue;
            }
            t = t.substr(1);
            var Q = S().toLowerCase(), x = null;
            if (t.charAt(0) === "(")
              if (e.has(Q)) {
                var P = t.charAt(1), D = X.has(P);
                if (t = t.substr(D ? 2 : 1), x = [], t = o(x, t, s), D) {
                  if (t.charAt(0) !== P)
                    throw new Error("Unmatched quotes in :" + Q);
                  t = t.substr(1);
                }
                if (t.charAt(0) !== ")")
                  throw new Error("Missing closing parenthesis in :" + Q + " (" + t + ")");
                t = t.substr(1);
              } else {
                for (var _ = 1, F = 1; F > 0 && _ < t.length; _++)
                  t.charAt(_) === "(" && !T(_) ? F++ : t.charAt(_) === ")" && !T(_) && F--;
                if (F)
                  throw new Error("Parenthesis not matched");
                if (x = t.substr(1, _ - 2), t = t.substr(_), r.has(Q)) {
                  var P = x.charAt(0);
                  P === x.slice(-1) && X.has(P) && (x = x.slice(1, -1)), x = p(x);
                }
              }
            b.push({ type: "pseudo", name: Q, data: x });
          } else if (c.test(t)) {
            var v = S();
            (!s || ("lowerCaseTags" in s ? s.lowerCaseTags : !s.xmlMode)) && (v = v.toLowerCase()), b.push({ type: "tag", name: v });
          } else
            return b.length && b[b.length - 1].type === "descendant" && b.pop(), G(d, b), t;
        }
        return G(d, b), t;
      }
      function G(d, t) {
        if (d.length > 0 && t.length === 0)
          throw new Error("Empty sub-selector");
        d.push(t);
      }
    },
    /* 277 */
    /***/
    function(n, l, i) {
      Object.defineProperty(l, "__esModule", { value: !0 });
      var c = {
        equals: "",
        element: "~",
        start: "^",
        end: "$",
        any: "*",
        not: "!",
        hyphen: "|"
      };
      function Z(a) {
        return a.map(L).join(", ");
      }
      l.default = Z;
      function L(a) {
        return a.map(K).join("");
      }
      function K(a) {
        switch (a.type) {
          case "child":
            return " > ";
          case "parent":
            return " < ";
          case "sibling":
            return " ~ ";
          case "adjacent":
            return " + ";
          case "descendant":
            return " ";
          case "universal":
            return "*";
          case "tag":
            return a.name;
          case "pseudo-element":
            return "::" + a.name;
          case "pseudo":
            return a.data === null ? ":" + a.name : typeof a.data == "string" ? ":" + a.name + "(" + a.data + ")" : ":" + a.name + "(" + Z(a.data) + ")";
          case "attribute":
            return a.action === "exists" ? "[" + a.name + "]" : a.name === "id" && a.action === "equals" && !a.ignoreCase ? "#" + a.value : a.name === "class" && a.action === "element" && !a.ignoreCase ? "." + a.value : "[" + a.name + c[a.action] + "='" + a.value + "'" + (a.ignoreCase ? "i" : "") + "]";
          default:
            throw new Error("Unknown type");
        }
      }
      function u(a) {
        return a;
      }
    },
    /* 278 */
    /***/
    function(n, l, i) {
      n.exports = L;
      var c = i(279), Z = {
        __proto__: null,
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4
      };
      function L(u) {
        for (var a = u.map(K), e = 1; e < u.length; e++) {
          var r = a[e];
          if (!(r < 0))
            for (var X = e - 1; X >= 0 && r < a[X]; X--) {
              var W = u[X + 1];
              u[X + 1] = u[X], u[X] = W, a[X + 1] = a[X], a[X] = r;
            }
        }
      }
      function K(u) {
        var a = c[u.type];
        if (a === c.attribute)
          a = Z[u.action], a === Z.equals && u.name === "id" && (a = 9), u.ignoreCase && (a >>= 1);
        else if (a === c.pseudo)
          if (!u.data)
            a = 3;
          else if (u.name === "has" || u.name === "contains")
            a = 0;
          else if (u.name === "matches" || u.name === "not") {
            a = 0;
            for (var e = 0; e < u.data.length; e++)
              if (u.data[e].length === 1) {
                var r = K(u.data[e][0]);
                if (r === 0) {
                  a = 0;
                  break;
                }
                r > a && (a = r);
              }
            u.data.length > 1 && a > 0 && (a -= 1);
          } else
            a = 1;
        return a;
      }
    },
    /* 279 */
    /***/
    function(n) {
      n.exports = JSON.parse('{"universal":50,"tag":30,"attribute":1,"pseudo":0,"descendant":-1,"child":-1,"parent":-1,"sibling":-1,"adjacent":-1}');
    },
    /* 280 */
    /***/
    function(n, l, i) {
      var c = i(281), Z = i(282);
      n.exports = {
        __proto__: null,
        attribute: c.compile,
        pseudo: Z.compile,
        //tags
        tag: function(L, K, u) {
          var a = K.name, e = u.adapter;
          return function(X) {
            return e.getName(X) === a && L(X);
          };
        },
        //traversal
        descendant: function(L, K, u) {
          var a = typeof WeakSet < "u" ? /* @__PURE__ */ new WeakSet() : null, e = u.adapter;
          return function(X) {
            for (var W = !1; !W && (X = e.getParent(X)); )
              (!a || !a.has(X)) && (W = L(X), !W && a && a.add(X));
            return W;
          };
        },
        _flexibleDescendant: function(L, K, u) {
          var a = u.adapter;
          return function(r) {
            for (var X = L(r); !X && (r = a.getParent(r)); )
              X = L(r);
            return X;
          };
        },
        parent: function(L, K, u) {
          if (u && u.strict)
            throw new Error("Parent selector isn't part of CSS3");
          var a = u.adapter;
          return function(X) {
            return a.getChildren(X).some(e);
          };
          function e(r) {
            return a.isTag(r) && L(r);
          }
        },
        child: function(L, K, u) {
          var a = u.adapter;
          return function(r) {
            var X = a.getParent(r);
            return !!X && L(X);
          };
        },
        sibling: function(L, K, u) {
          var a = u.adapter;
          return function(r) {
            for (var X = a.getSiblings(r), W = 0; W < X.length; W++)
              if (a.isTag(X[W])) {
                if (X[W] === r)
                  break;
                if (L(X[W]))
                  return !0;
              }
            return !1;
          };
        },
        adjacent: function(L, K, u) {
          var a = u.adapter;
          return function(r) {
            for (var X = a.getSiblings(r), W, p = 0; p < X.length; p++)
              if (a.isTag(X[p])) {
                if (X[p] === r)
                  break;
                W = X[p];
              }
            return !!W && L(W);
          };
        },
        universal: function(L) {
          return L;
        }
      };
    },
    /* 281 */
    /***/
    function(n, l, i) {
      var c = i(273).falseFunc, Z = /[-[\]{}()*+?.,\\^$|#\s]/g, L = {
        __proto__: null,
        equals: function(K, u, a) {
          var e = u.name, r = u.value, X = a.adapter;
          return u.ignoreCase ? (r = r.toLowerCase(), function(p) {
            var C = X.getAttributeValue(p, e);
            return C != null && C.toLowerCase() === r && K(p);
          }) : function(p) {
            return X.getAttributeValue(p, e) === r && K(p);
          };
        },
        hyphen: function(K, u, a) {
          var e = u.name, r = u.value, X = r.length, W = a.adapter;
          return u.ignoreCase ? (r = r.toLowerCase(), function(C) {
            var I = W.getAttributeValue(C, e);
            return I != null && (I.length === X || I.charAt(X) === "-") && I.substr(0, X).toLowerCase() === r && K(C);
          }) : function(C) {
            var I = W.getAttributeValue(C, e);
            return I != null && I.substr(0, X) === r && (I.length === X || I.charAt(X) === "-") && K(C);
          };
        },
        element: function(K, u, a) {
          var e = u.name, r = u.value, X = a.adapter;
          if (/\s/.test(r))
            return c;
          r = r.replace(Z, "\\$&");
          var W = "(?:^|\\s)" + r + "(?:$|\\s)", p = u.ignoreCase ? "i" : "", C = new RegExp(W, p);
          return function(o) {
            var G = X.getAttributeValue(o, e);
            return G != null && C.test(G) && K(o);
          };
        },
        exists: function(K, u, a) {
          var e = u.name, r = a.adapter;
          return function(W) {
            return r.hasAttrib(W, e) && K(W);
          };
        },
        start: function(K, u, a) {
          var e = u.name, r = u.value, X = r.length, W = a.adapter;
          return X === 0 ? c : u.ignoreCase ? (r = r.toLowerCase(), function(C) {
            var I = W.getAttributeValue(C, e);
            return I != null && I.substr(0, X).toLowerCase() === r && K(C);
          }) : function(C) {
            var I = W.getAttributeValue(C, e);
            return I != null && I.substr(0, X) === r && K(C);
          };
        },
        end: function(K, u, a) {
          var e = u.name, r = u.value, X = -r.length, W = a.adapter;
          return X === 0 ? c : u.ignoreCase ? (r = r.toLowerCase(), function(C) {
            var I = W.getAttributeValue(C, e);
            return I != null && I.substr(X).toLowerCase() === r && K(C);
          }) : function(C) {
            var I = W.getAttributeValue(C, e);
            return I != null && I.substr(X) === r && K(C);
          };
        },
        any: function(K, u, a) {
          var e = u.name, r = u.value, X = a.adapter;
          if (r === "")
            return c;
          if (u.ignoreCase) {
            var W = new RegExp(r.replace(Z, "\\$&"), "i");
            return function(C) {
              var I = X.getAttributeValue(C, e);
              return I != null && W.test(I) && K(C);
            };
          }
          return function(C) {
            var I = X.getAttributeValue(C, e);
            return I != null && I.indexOf(r) >= 0 && K(C);
          };
        },
        not: function(K, u, a) {
          var e = u.name, r = u.value, X = a.adapter;
          return r === "" ? function(p) {
            return !!X.getAttributeValue(p, e) && K(p);
          } : u.ignoreCase ? (r = r.toLowerCase(), function(p) {
            var C = X.getAttributeValue(p, e);
            return C != null && C.toLowerCase() !== r && K(p);
          }) : function(p) {
            return X.getAttributeValue(p, e) !== r && K(p);
          };
        }
      };
      n.exports = {
        compile: function(K, u, a) {
          if (a && a.strict && (u.ignoreCase || u.action === "not"))
            throw new Error("Unsupported attribute selector");
          return L[u.action](K, u, a);
        },
        rules: L
      };
    },
    /* 282 */
    /***/
    function(n, l, i) {
      var c = i(283), Z = i(273), L = i(281), K = Z.trueFunc, u = Z.falseFunc, a = L.rules.equals;
      function e(G, d) {
        var t = { name: G, value: d };
        return function(b, V, S) {
          return a(b, t, S);
        };
      }
      function r(G, d) {
        return function(t) {
          return !!d.getParent(t) && G(t);
        };
      }
      var X = {
        contains: function(G, d, t) {
          var s = t.adapter;
          return function(V) {
            return G(V) && s.getText(V).indexOf(d) >= 0;
          };
        },
        icontains: function(G, d, t) {
          var s = d.toLowerCase(), b = t.adapter;
          return function(S) {
            return G(S) && b.getText(S).toLowerCase().indexOf(s) >= 0;
          };
        },
        //location specific methods
        "nth-child": function(G, d, t) {
          var s = c(d), b = t.adapter;
          return s === u ? s : s === K ? r(G, b) : function(S) {
            for (var Y = b.getSiblings(S), T = 0, y = 0; T < Y.length; T++)
              if (b.isTag(Y[T])) {
                if (Y[T] === S)
                  break;
                y++;
              }
            return s(y) && G(S);
          };
        },
        "nth-last-child": function(G, d, t) {
          var s = c(d), b = t.adapter;
          return s === u ? s : s === K ? r(G, b) : function(S) {
            for (var Y = b.getSiblings(S), T = 0, y = Y.length - 1; y >= 0; y--)
              if (b.isTag(Y[y])) {
                if (Y[y] === S)
                  break;
                T++;
              }
            return s(T) && G(S);
          };
        },
        "nth-of-type": function(G, d, t) {
          var s = c(d), b = t.adapter;
          return s === u ? s : s === K ? r(G, b) : function(S) {
            for (var Y = b.getSiblings(S), T = 0, y = 0; y < Y.length; y++)
              if (b.isTag(Y[y])) {
                if (Y[y] === S)
                  break;
                b.getName(Y[y]) === b.getName(S) && T++;
              }
            return s(T) && G(S);
          };
        },
        "nth-last-of-type": function(G, d, t) {
          var s = c(d), b = t.adapter;
          return s === u ? s : s === K ? r(G, b) : function(S) {
            for (var Y = b.getSiblings(S), T = 0, y = Y.length - 1; y >= 0; y--)
              if (b.isTag(Y[y])) {
                if (Y[y] === S)
                  break;
                b.getName(Y[y]) === b.getName(S) && T++;
              }
            return s(T) && G(S);
          };
        },
        //TODO determine the actual root element
        root: function(G, d, t) {
          var s = t.adapter;
          return function(b) {
            return !s.getParent(b) && G(b);
          };
        },
        scope: function(G, d, t, s) {
          var b = t.adapter;
          if (!s || s.length === 0)
            return X.root(G, d, t);
          function V(S, Y) {
            return typeof b.equals == "function" ? b.equals(S, Y) : S === Y;
          }
          return s.length === 1 ? function(S) {
            return V(s[0], S) && G(S);
          } : function(S) {
            return s.indexOf(S) >= 0 && G(S);
          };
        },
        //jQuery extensions (others follow as pseudos)
        checkbox: e("type", "checkbox"),
        file: e("type", "file"),
        password: e("type", "password"),
        radio: e("type", "radio"),
        reset: e("type", "reset"),
        image: e("type", "image"),
        submit: e("type", "submit"),
        //dynamic state pseudos. These depend on optional Adapter methods.
        hover: function(G, d, t) {
          var s = t.adapter;
          return typeof s.isHovered == "function" ? function(V) {
            return G(V) && s.isHovered(V);
          } : u;
        },
        visited: function(G, d, t) {
          var s = t.adapter;
          return typeof s.isVisited == "function" ? function(V) {
            return G(V) && s.isVisited(V);
          } : u;
        },
        active: function(G, d, t) {
          var s = t.adapter;
          return typeof s.isActive == "function" ? function(V) {
            return G(V) && s.isActive(V);
          } : u;
        }
      };
      function W(G, d) {
        for (var t = 0; G && t < G.length; t++)
          if (d.isTag(G[t]))
            return G[t];
      }
      var p = {
        empty: function(G, d) {
          return !d.getChildren(G).some(function(t) {
            return d.isTag(t) || t.type === "text";
          });
        },
        "first-child": function(G, d) {
          return W(d.getSiblings(G), d) === G;
        },
        "last-child": function(G, d) {
          for (var t = d.getSiblings(G), s = t.length - 1; s >= 0; s--) {
            if (t[s] === G)
              return !0;
            if (d.isTag(t[s]))
              break;
          }
          return !1;
        },
        "first-of-type": function(G, d) {
          for (var t = d.getSiblings(G), s = 0; s < t.length; s++)
            if (d.isTag(t[s])) {
              if (t[s] === G)
                return !0;
              if (d.getName(t[s]) === d.getName(G))
                break;
            }
          return !1;
        },
        "last-of-type": function(G, d) {
          for (var t = d.getSiblings(G), s = t.length - 1; s >= 0; s--)
            if (d.isTag(t[s])) {
              if (t[s] === G)
                return !0;
              if (d.getName(t[s]) === d.getName(G))
                break;
            }
          return !1;
        },
        "only-of-type": function(G, d) {
          for (var t = d.getSiblings(G), s = 0, b = t.length; s < b; s++)
            if (d.isTag(t[s])) {
              if (t[s] === G)
                continue;
              if (d.getName(t[s]) === d.getName(G))
                return !1;
            }
          return !0;
        },
        "only-child": function(G, d) {
          for (var t = d.getSiblings(G), s = 0; s < t.length; s++)
            if (d.isTag(t[s]) && t[s] !== G)
              return !1;
          return !0;
        },
        //:matches(a, area, link)[href]
        link: function(G, d) {
          return d.hasAttrib(G, "href");
        },
        //TODO: :any-link once the name is finalized (as an alias of :link)
        //forms
        //to consider: :target
        //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
        selected: function(G, d) {
          if (d.hasAttrib(G, "selected"))
            return !0;
          if (d.getName(G) !== "option")
            return !1;
          var t = d.getParent(G);
          if (!t || d.getName(t) !== "select" || d.hasAttrib(t, "multiple"))
            return !1;
          for (var s = d.getChildren(t), b = !1, V = 0; V < s.length; V++)
            if (d.isTag(s[V]))
              if (s[V] === G)
                b = !0;
              else if (b) {
                if (d.hasAttrib(s[V], "selected"))
                  return !1;
              } else
                return !1;
          return b;
        },
        //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        //:matches(
        //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
        //  optgroup[disabled] > option),
        // fieldset[disabled] * //TODO not child of first <legend>
        //)
        disabled: function(G, d) {
          return d.hasAttrib(G, "disabled");
        },
        enabled: function(G, d) {
          return !d.hasAttrib(G, "disabled");
        },
        //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
        checked: function(G, d) {
          return d.hasAttrib(G, "checked") || p.selected(G, d);
        },
        //:matches(input, select, textarea)[required]
        required: function(G, d) {
          return d.hasAttrib(G, "required");
        },
        //:matches(input, select, textarea):not([required])
        optional: function(G, d) {
          return !d.hasAttrib(G, "required");
        },
        //jQuery extensions
        //:not(:empty)
        parent: function(G, d) {
          return !p.empty(G, d);
        },
        //:matches(h1, h2, h3, h4, h5, h6)
        header: C(["h1", "h2", "h3", "h4", "h5", "h6"]),
        //:matches(button, input[type=button])
        button: function(G, d) {
          var t = d.getName(G);
          return t === "button" || t === "input" && d.getAttributeValue(G, "type") === "button";
        },
        //:matches(input, textarea, select, button)
        input: C(["input", "textarea", "select", "button"]),
        //input:matches(:not([type!='']), [type='text' i])
        text: function(G, d) {
          var t;
          return d.getName(G) === "input" && (!(t = d.getAttributeValue(G, "type")) || t.toLowerCase() === "text");
        }
      };
      function C(G) {
        if (typeof Set < "u") {
          var d = new Set(G);
          return function(t, s) {
            return d.has(s.getName(t));
          };
        }
        return function(t, s) {
          return G.indexOf(s.getName(t)) >= 0;
        };
      }
      function I(G, d, t) {
        if (t === null) {
          if (G.length > 2 && d !== "scope")
            throw new Error("pseudo-selector :" + d + " requires an argument");
        } else if (G.length === 2)
          throw new Error("pseudo-selector :" + d + " doesn't have any arguments");
      }
      var o = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
      n.exports = {
        compile: function(G, d, t, s) {
          var b = d.name, V = d.data, S = t.adapter;
          if (t && t.strict && !o.test(b))
            throw new Error(":" + b + " isn't part of CSS3");
          if (typeof X[b] == "function")
            return X[b](G, V, t, s);
          if (typeof p[b] == "function") {
            var Y = p[b];
            return I(Y, b, V), Y === u ? Y : G === K ? function(y) {
              return Y(y, S, V);
            } : function(y) {
              return Y(y, S, V) && G(y);
            };
          } else
            throw new Error("unmatched pseudo-class :" + b);
        },
        filters: X,
        pseudos: p
      };
    },
    /* 283 */
    /***/
    function(n, l, i) {
      var c = i(284), Z = i(285);
      n.exports = function(K) {
        return Z(c(K));
      }, n.exports.parse = c, n.exports.compile = Z;
    },
    /* 284 */
    /***/
    function(n, l) {
      n.exports = c;
      var i = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
      function c(Z) {
        if (Z = Z.trim().toLowerCase(), Z === "even")
          return [2, 0];
        if (Z === "odd")
          return [2, 1];
        var L = Z.match(i);
        if (!L)
          throw new SyntaxError("n-th rule couldn't be parsed ('" + Z + "')");
        var K;
        return L[1] ? (K = parseInt(L[1], 10), isNaN(K) && (L[1].charAt(0) === "-" ? K = -1 : K = 1)) : K = 0, [
          K,
          L[3] ? parseInt((L[2] || "") + L[3], 10) : 0
        ];
      }
    },
    /* 285 */
    /***/
    function(n, l, i) {
      n.exports = K;
      var c = i(273), Z = c.trueFunc, L = c.falseFunc;
      function K(u) {
        var a = u[0], e = u[1] - 1;
        if (e < 0 && a <= 0)
          return L;
        if (a === -1)
          return function(X) {
            return X <= e;
          };
        if (a === 0)
          return function(X) {
            return X === e;
          };
        if (a === 1)
          return e < 0 ? Z : function(X) {
            return X >= e;
          };
        var r = e % a;
        return r < 0 && (r += a), a > 1 ? function(X) {
          return X >= e && X % a === r;
        } : (a *= -1, function(X) {
          return X <= e && X % a === r;
        });
      }
    },
    /* 286 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return V;
      });
      var c = i(12), Z = i(74), L = i(1), K = i(68), u = i(250), a = i(213), e = i(218);
      i(1).glMatrix.setMatrixArrayType(Array);
      function r(S, Y) {
        if (S == null)
          return {};
        var T = X(S, Y), y, J;
        if (Object.getOwnPropertySymbols) {
          var N = Object.getOwnPropertySymbols(S);
          for (J = 0; J < N.length; J++)
            y = N[J], !(Y.indexOf(y) >= 0) && Object.prototype.propertyIsEnumerable.call(S, y) && (T[y] = S[y]);
        }
        return T;
      }
      function X(S, Y) {
        if (S == null)
          return {};
        var T = {}, y = Object.keys(S), J, N;
        for (N = 0; N < y.length; N++)
          J = y[N], !(Y.indexOf(J) >= 0) && (T[J] = S[J]);
        return T;
      }
      const W = {
        antialias: !0,
        autoRender: !0,
        alpha: !0
        // for wx-miniprogram
      }, p = Symbol("autoRender"), C = Symbol("renderer"), I = Symbol("timeline"), o = Symbol("prepareRender"), G = Symbol("tickRender"), d = Symbol("pass"), t = Symbol("fbo"), s = Symbol("tickers"), b = Symbol("layerTransformInvert");
      class V extends u.default {
        constructor(Y = {}) {
          if (super(), !Y.canvas) {
            const {
              width: N,
              height: R
            } = this.getResolution(), x = c.ENV.createCanvas(N, R, {
              offscreen: !!Y.offscreen,
              id: Y.id,
              extra: Y.extra
            });
            x.style && (x.style.position = "absolute"), x.dataset && (x.dataset.layerId = Y.id), x.contextType && (Y.contextType = x.contextType), Y.canvas = x;
          }
          const T = Y.canvas, y = Object.assign({}, W, Y);
          this[p] = y.autoRender, delete Y.autoRender;
          const J = y.Renderer || c.Renderer;
          this[C] = new J(T, y), this.options = Y, this.id = Y.id, this[d] = [], this.setResolution(T), this.canvas = T, this[I] = new Z.Timeline(), this.__mouseCapturedTarget = null, this[b] = null;
        }
        get autoRender() {
          return this[p];
        }
        get displayRatio() {
          return this.parent && this.parent.options ? this.parent.options.displayRatio : 1;
        }
        get height() {
          const {
            height: Y
          } = this.getResolution();
          return Y / this.displayRatio;
        }
        get gl() {
          return this.renderer.glRenderer ? this.renderer.glRenderer.gl : null;
        }
        /* override */
        get layer() {
          return this;
        }
        get offscreen() {
          return !!this.options.offscreen || this.canvas._offscreen;
        }
        get pass() {
          return this[d];
        }
        get prepareRender() {
          return this[o] ? this[o] : Promise.resolve();
        }
        /* override */
        get renderer() {
          return this[C];
        }
        get renderOffset() {
          if (this.parent && this.parent.options) {
            const {
              left: Y,
              top: T
            } = this.parent.options;
            return [Y, T];
          }
          return [this.options.left | 0, this.options.top | 0];
        }
        get timeline() {
          return this[I];
        }
        get width() {
          const {
            width: Y
          } = this.getResolution();
          return Y / this.displayRatio;
        }
        get localMatrix() {
          const {
            x: Y,
            y: T
          } = this.attributes;
          return [1, 0, 0, 1, Y, T];
        }
        get layerTransformInvert() {
          if (this[b])
            return this[b];
          const Y = this.transformMatrix;
          return Y[0] === 1 && Y[1] === 0 && Y[2] === 0 && Y[3] === 1 && Y[4] === 0 && Y[5] === 0 ? null : (this[b] = L.mat2d.invert(Array.of(0, 0, 0, 0, 0, 0), Y), this[b]);
        }
        forceContextLoss() {
          const Y = this.renderer.glRenderer;
          if (Y) {
            const T = Y.getExtension("WEBGL_lose_context");
            if (T)
              return T.loseContext(), !0;
          }
          return !1;
        }
        // isPointCollision(x, y) {
        //   return true;
        // }
        addPass({
          vertex: Y,
          fragment: T,
          options: y,
          uniforms: J
        } = {}) {
          if (this.renderer.glRenderer) {
            const {
              width: N,
              height: R
            } = this.getResolution(), x = this.renderer.createPassProgram({
              vertex: Y,
              fragment: T,
              options: y
            }), M = new c.Figure2D();
            M.rect(0, 0, N / this.displayRatio, R / this.displayRatio);
            const Q = new c.Mesh2D(M);
            return Q.setUniforms(J), Q.setProgram(x), this[d].push(Q), this.forceUpdate(), Q;
          }
          return null;
        }
        // delete unused texture to release memory.
        deleteTexture(Y) {
          return Object(e.deleteTexture)(Y, this.renderer);
        }
        /* override */
        dispatchPointerEvent(Y) {
          const T = Y.type;
          if (T === "mousedown" || T === "mouseup" || T === "mousemove") {
            const x = this.__mouseCapturedTarget;
            if (x) {
              if (x.layer === this)
                return x.dispatchEvent(Y), !0;
              this.__mouseCapturedTarget = null;
            }
          }
          let y, J;
          const N = this.layerTransformInvert;
          if (N) {
            y = Y.x, J = Y.y;
            const x = N, M = x[0] * y + x[2] * J + x[4], Q = x[1] * y + x[3] * J + x[5];
            delete Y.x, delete Y.y, delete Y.layerX, delete Y.layerY, Object.defineProperties(Y, {
              layerX: {
                value: M,
                configurable: !0
              },
              layerY: {
                value: Q,
                configurable: !0
              },
              x: {
                value: M,
                configurable: !0
              },
              y: {
                value: Q,
                configurable: !0
              }
            });
          }
          const R = super.dispatchPointerEvent(Y);
          return N && Object.defineProperties(Y, {
            layerX: {
              value: y,
              configurable: !0
            },
            layerY: {
              value: J,
              configurable: !0
            },
            x: {
              value: y,
              configurable: !0
            },
            y: {
              value: J,
              configurable: !0
            }
          }), R;
        }
        /* override */
        forceUpdate() {
          if (!this[o])
            if (this.parent && this.parent.hasOffscreenCanvas) {
              this.parent.forceUpdate();
              let Y = null;
              const T = new Promise((y) => {
                Y = y;
              });
              T._resolve = Y, this[o] = T;
            } else {
              let Y = null, T = null;
              const y = new Promise((J) => {
                Y = J, this[p] && (T = Object(K.requestAnimationFrame)(() => {
                  delete y._requestID, this.render();
                }));
              });
              y._resolve = Y, y._requestID = T, this[o] = y;
            }
        }
        getFBO() {
          const Y = this.renderer.glRenderer, {
            width: T,
            height: y
          } = this.getResolution();
          return Y && (!this[t] || this[t].width !== T || this[t].height !== y) ? (this[t] = {
            width: T,
            height: y,
            target: Y.createFBO(),
            buffer: Y.createFBO(),
            swap() {
              [this.target, this.buffer] = [this.buffer, this.target];
            }
          }, this[t]) : this[t] ? this[t] : null;
        }
        updateGlobalTransform() {
          if (this.layerTransformInvert) {
            const Y = this.renderer, T = Y.__globalTransformMatrix || Y.globalTransformMatrix;
            Y.__globalTransformMatrix = T;
            const y = L.mat2d.fromValues(1, 0, 0, 1, 0, 0);
            Y.setGlobalTransform(...L.mat2d.multiply(y, T, this.transformMatrix));
          }
        }
        /* override */
        onPropertyChange(Y, T, y) {
          if (super.onPropertyChange(Y, T, y), Y === "zIndex" && (this.canvas.style.zIndex = T), Y === "transform" || Y === "translate" || Y === "rotate" || Y === "scale" || Y === "skew") {
            const J = this[b];
            if (this[b] = null, this.updateGlobalTransform(), J && !this.layerTransformInvert) {
              const N = this.renderer, R = N.__globalTransformMatrix || N.globalTransformMatrix;
              N.setGlobalTransform(...R);
            }
          }
        }
        _prepareRenderFinished() {
          this[o] && (this[o]._requestID && Object(K.cancelAnimationFrame)(this[o]._requestID), this[o]._resolve(), delete this[o]);
        }
        render({
          clear: Y = !0
        } = {}) {
          const T = this[d].length ? this.getFBO() : null;
          T && this.renderer.glRenderer.bindFBO(T.target), Y && this[C].clear();
          const y = this.draw();
          if (y && y.length && (this.renderer.drawMeshes(y), this.canvas.draw && this.canvas.draw()), T) {
            const J = this.renderer.glRenderer, N = this[d].length, {
              width: R,
              height: x
            } = this.getResolution(), M = [0, 0, R / this.displayRatio, x / this.displayRatio];
            this[d].forEach((Q, P) => {
              Q.blend = !0, Q.setTexture(T.target.texture, {
                rect: M
              }), P === N - 1 ? J.bindFBO(null) : (T.swap(), J.bindFBO(T.target)), this[C].clear(), this.renderer.drawMeshes([Q]);
            });
          }
          this._prepareRenderFinished();
        }
        /* override */
        setResolution({
          width: Y,
          height: T
        }) {
          const y = this.renderer, J = y.__globalTransformMatrix || y.globalTransformMatrix, N = J[4], R = J[5], x = J[0], {
            width: M,
            height: Q
          } = this.getResolution();
          (M !== Y || Q !== T) && (super.setResolution({
            width: Y,
            height: T
          }), this.canvas && (this.canvas.width = Y, this.canvas.height = T, y.updateResolution && y.updateResolution()), this.attributes.size = [Y, T], this[d].length && this[d].forEach((F) => {
            const v = new c.Figure2D();
            v.rect(0, 0, Y / this.displayRatio, T / this.displayRatio), F.contours = v.contours;
          }));
          const [P, D] = this.renderOffset, _ = this.displayRatio;
          (N !== P || R !== D || x !== _) && (y.setGlobalTransform(_, 0, 0, _, P, D), y.__globalTransformMatrix = null, this[b] = null, this.updateGlobalTransform(), this.forceUpdate());
        }
        /**
         * tick(handler, {originTime = 0, playbackRate = 1.0, duration = Infinity})
         * @param {*} handler
         * @param {*} options
         */
        tick(Y = null, T = {}) {
          let {
            duration: y = 1 / 0
          } = T, J = r(T, ["duration"]);
          const N = this.timeline.fork(J), R = this;
          this[s] = this[s] || [], this[s].push({
            handler: Y,
            duration: y
          });
          const x = () => {
            let M = null, Q = null;
            const P = () => {
              const D = this[s].map(({
                handler: _,
                duration: F
              }) => {
                const v = Math.min(1, N.currentTime / F);
                return {
                  value: _ ? _(N.currentTime, v) : null,
                  p: v
                };
              });
              R[G] || (R[G] = Promise.resolve().then(() => {
                R[p] && R.render(), delete R[G];
                for (let _ = D.length - 1; _ >= 0; _--) {
                  const {
                    value: F,
                    p: v
                  } = D[_];
                  (F === !1 || v >= 1) && this[s].splice(_, 1);
                }
                this[s].length > 0 && x();
              }));
            };
            if (this[o] && this[o]._type !== "ticker" && (Object(K.cancelAnimationFrame)(this[o]._requestID), delete this[o]), !this[o]) {
              const D = new Promise((_) => {
                M = _, Q = Object(K.requestAnimationFrame)(P);
              });
              D._resolve = M, D._requestID = Q, D._type = "ticker", this[o] = D;
            }
          };
          x();
        }
        toGlobalPos(Y, T) {
          if (this.layerTransformInvert) {
            const M = this.transformMatrix;
            Y = M[0] * Y + M[2] * T + M[4], T = M[1] * Y + M[3] * T + M[5];
          }
          const {
            width: y,
            height: J
          } = this.getResolution(), N = this.renderOffset, R = [this.canvas.clientWidth, this.canvas.clientHeight];
          Y = Y * R[0] / y + N[0], T = T * R[1] / J + N[1];
          const x = this.displayRatio;
          return Y *= x, T *= x, [Y, T];
        }
        toLocalPos(Y, T) {
          const {
            width: y,
            height: J
          } = this.getResolution(), N = this.renderOffset, R = [this.canvas.clientWidth, this.canvas.clientHeight];
          Y = Y * y / R[0] - N[0], T = T * J / R[1] - N[1];
          const x = this.displayRatio;
          Y /= x, T /= x;
          const M = this.layerTransformInvert;
          return M && (Y = M[0] * Y + M[2] * T + M[4], T = M[1] * Y + M[3] * T + M[5]), [Y, T];
        }
      }
      a.default.registerNode(V, "layer");
    },
    /* 287 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return o;
      });
      var c = i(224), Z = i(288), L = i(213), K = i(252), u = i(72);
      i(1).glMatrix.setMatrixArrayType(Array);
      function a(G, d) {
        if (G == null)
          return {};
        var t = e(G, d), s, b;
        if (Object.getOwnPropertySymbols) {
          var V = Object.getOwnPropertySymbols(G);
          for (b = 0; b < V.length; b++)
            s = V[b], !(d.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(G, s) && (t[s] = G[s]);
        }
        return t;
      }
      function e(G, d) {
        if (G == null)
          return {};
        var t = {}, s = Object.keys(G), b, V;
        for (V = 0; V < s.length; V++)
          b = s[V], !(d.indexOf(b) >= 0) && (t[b] = G[b]);
        return t;
      }
      function r(G, d, t) {
        return d in G ? Object.defineProperty(G, d, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : G[d] = t, G;
      }
      const X = "http://www.w3.org/2000/svg", W = Symbol.for("spritejs_setAttribute"), p = Symbol("root"), C = Symbol("task");
      function I(G, d = !0) {
        const t = G[p];
        if (t && t.children[0]) {
          const s = G.svg, b = G.layer ? G.layer.displayRatio : 1;
          if (!s.hasAttribute("data-original-width")) {
            let Y = s.getAttribute("width");
            Y = Y ? Object(u.sizeToPixel)(Y) : 300;
            let T = s.getAttribute("height");
            T = T ? Object(u.sizeToPixel)(T) : 150, s.hasAttribute("viewBox") || s.setAttribute("viewBox", `0 0 ${Math.round(Y)} ${Math.round(T)}`), s.setAttribute("data-original-width", Y), s.setAttribute("data-original-height", T);
          }
          let V = G.attributes.width || Number(s.getAttribute("data-original-width")), S = G.attributes.height || Number(s.getAttribute("data-original-height"));
          if (V *= b, S *= b, d && G.attributes.flexible) {
            const Y = G.attributes.scale[0];
            if (V *= Y, S *= Y, s.setAttribute("width", V), s.setAttribute("height", S), V && S && G.textureImage) {
              const T = G.textureImage.width, y = G.textureImage.height, J = G.clientSize;
              G.attributes.textureRect = [0, 0, Math.round(J[0] * T / V), Math.round(J[1] * y / S)];
            }
          } else
            G[C] || (s.setAttribute("width", V), s.setAttribute("height", S), G[C] = Promise.resolve().then(() => {
              delete G[C];
              const Y = t.innerHTML, T = new Blob([Y], {
                type: "image/svg+xml"
              }), y = URL.createObjectURL(T), J = new Image();
              J.onload = function() {
                J.width && J.height ? (G.attributes[W]("texture", J), G.attributes.flexible && (G.attributes.textureRect = null)) : G.attributes[W]("texture", null);
              }, J.src = y;
            }));
        }
      }
      class o extends c.default {
        constructor(d = {}) {
          typeof d == "string" && (d = {
            svgText: d
          });
          let {
            svgText: t
          } = d, s = a(d, ["svgText"]);
          if (super(s), this[p] = document.createElement("div"), t) {
            this[p].innerHTML = t;
            const b = this[p].children[0];
            b ? b.setAttribute("xmlns", X) : (fetch(t).then((V) => V.text()).then((V) => {
              this[p].innerHTML = V, (!this.observer || this.attributes.flexible) && I(this);
            }), t = null);
          }
          if (!t) {
            const b = document.createElementNS(X, "svg");
            b.setAttribute("xmlns", X), this[p].appendChild(b);
          }
          if (typeof MutationObserver == "function") {
            const b = new MutationObserver((V) => {
              I(this, !1);
            });
            b.observe(this[p], {
              attributes: !0,
              subtree: !0,
              characterData: !0,
              childList: !0
            }), this.observer = b;
          }
        }
        get children() {
          return [this.svg];
        }
        get childNodes() {
          return [this.svg];
        }
        get svg() {
          return this[p] ? this[p].children[0] : null;
        }
        /* override */
        setResolution({
          width: d,
          height: t
        }) {
          super.setResolution({
            width: d,
            height: t
          }), I(this);
        }
        /* override */
        dispatchPointerEvent(d) {
          const t = super.dispatchPointerEvent(d);
          if (t && this.attributes.passEvents && typeof MouseEvent == "function") {
            const {
              x: s,
              y: b
            } = d;
            let [V, S] = this.getOffsetPosition(s, b);
            const Y = d.originalEvent, T = this.attributes.anchor, y = this.clientSize;
            V = (V + T[0] * y[0]) / 2, S = (S + T[1] * y[1]) / 2;
            const J = d.type;
            if (J === Y.type) {
              let N = null;
              if (Y instanceof MouseEvent)
                N = new MouseEvent(J, {
                  screenX: V,
                  screenY: S,
                  clientX: V,
                  clientY: S,
                  bubbles: Y.bubbles,
                  button: Y.button,
                  buttons: Y.buttons,
                  cancelBubble: Y.cancelBubble,
                  cancelable: Y.cancelable,
                  currentTarget: Y.currentTarget,
                  fromElement: Y.fromElement,
                  relatedTarget: Y.relatedTarget,
                  returnValue: Y.returnValue,
                  srcElement: Y.srcElement,
                  target: Y.target,
                  toElement: Y.toElement,
                  // view: originalEvent.view,
                  which: Y.witch
                });
              else if (Y instanceof TouchEvent) {
                let R = null;
                const x = Y.changedTouches || [Y];
                for (let M = 0; M < x.length; M++) {
                  const Q = x[M];
                  if (d.identifier === Q.identifier) {
                    R = Q;
                    break;
                  }
                }
                if (R) {
                  const M = new Touch({
                    identifier: R.identifier,
                    target: R.target,
                    clientX: V,
                    clientY: S,
                    screenX: V,
                    screenY: S,
                    pageX: V,
                    pageY: S,
                    radiusX: R.radiusX,
                    radiusY: R.radiusY,
                    rotationAngle: R.rotationAngle,
                    force: R.force
                  });
                  N = new TouchEvent(J, {
                    cancelable: Y.cancelable,
                    bubbles: Y.bubbles,
                    composed: Y.composed,
                    touches: [M],
                    targetTouches: [M],
                    changedTouches: [M]
                  });
                }
              } else
                N = Y;
              N && this.svg.dispatchEvent(N);
            }
          }
          return t;
        }
        getElementById(d) {
          return Object(K.querySelector)(`#${d}`, this);
        }
        getElementsByClassName(d) {
          return Object(K.querySelectorAll)(`.${d}`, this);
        }
        getElementsByName(d) {
          return Object(K.querySelectorAll)(`[name="${d}"]`, this);
        }
        getElementsByTagName(d) {
          return Object(K.querySelectorAll)(d, this);
        }
        querySelector(d) {
          return Object(K.querySelector)(d, this);
        }
        querySelectorAll(d) {
          return Object(K.querySelectorAll)(d, this);
        }
        /* override */
        onPropertyChange(d, t, s) {
          super.onPropertyChange(d, t, s), d === "flexible" && I(this), this.attributes.flexible && (d === "width" || d === "height" || d === "scale" || d === "transform") && I(this);
        }
      }
      r(o, "Attr", Z.default), L.default.registerNode(o, "spritesvg");
    },
    /* 288 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return u;
      });
      var c = i(225);
      i(1).glMatrix.setMatrixArrayType(Array);
      const Z = Symbol.for("spritejs_getAttribute"), L = Symbol.for("spritejs_setAttribute"), K = Symbol.for("spritejs_setAttributeDefault");
      class u extends c.default {
        constructor(e) {
          super(e), this[K]({
            passEvents: !1,
            flexible: !1
          });
        }
        // readonly
        get texture() {
          return this[Z]("texture");
        }
        set texture(e) {
        }
        // eslint-disable-line no-empty-function
        get passEvents() {
          return this[Z]("passEvents");
        }
        set passEvents(e) {
          return this[L]("passEvents", e);
        }
        get flexible() {
          return this[Z]("flexible");
        }
        set flexible(e) {
          return this[L]("flexible", e);
        }
      }
    },
    /* 289 */
    /***/
    function(n, l, i) {
      i.r(l);
      var c = i(12);
      i(1).glMatrix.setMatrixArrayType(Array);
      function Z(e, r) {
        var X = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var W = Object.getOwnPropertySymbols(e);
          r && (W = W.filter(function(p) {
            return Object.getOwnPropertyDescriptor(e, p).enumerable;
          })), X.push.apply(X, W);
        }
        return X;
      }
      function L(e) {
        for (var r = 1; r < arguments.length; r++) {
          var X = arguments[r] != null ? arguments[r] : {};
          r % 2 ? Z(Object(X), !0).forEach(function(W) {
            K(e, W, X[W]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(X)) : Z(Object(X)).forEach(function(W) {
            Object.defineProperty(e, W, Object.getOwnPropertyDescriptor(X, W));
          });
        }
        return e;
      }
      function K(e, r, X) {
        return r in e ? Object.defineProperty(e, r, { value: X, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = X, e;
      }
      const u = Symbol("inited");
      let a = null;
      typeof Worker == "function" && (a = class extends Worker {
        constructor(e) {
          if (e.worker === !0 && (e.worker = `./${e.id}.worker.js`), super(e.worker), this.options = e, !e.canvas) {
            const {
              width: r,
              height: X
            } = this.getResolution(), W = c.ENV.createCanvas(r, X, {
              offscreen: !1
            });
            W.style && (W.style.position = "absolute"), W.dataset && (W.dataset.layerId = e.id), e.canvas = W;
          }
          this.canvas = e.canvas;
        }
        get id() {
          return this.options.id;
        }
        setResolution({
          width: e,
          height: r
        }) {
          if (this[u])
            this.postMessage({
              type: "resolution_change",
              width: e,
              height: r
            });
          else {
            this.canvas.width = e, this.canvas.height = r;
            const X = this.options, W = X.canvas.transferControlToOffscreen(), p = L({}, X);
            delete p.container, p.canvas = W, this.postMessage({
              type: "create",
              options: p
            }, [W]), this[u] = !0;
          }
        }
        getResolution() {
          if (this.canvas) {
            const {
              width: e,
              height: r
            } = this.canvas;
            return {
              width: e,
              height: r
            };
          }
          return {
            width: 300,
            height: 150
          };
        }
        remove() {
          return this.parent && this.parent.removeChild ? (this.parent.removeChild(this), !0) : !1;
        }
        connect(e, r) {
          Object.defineProperty(this, "parent", {
            value: e,
            writable: !1,
            configurable: !0
          }), Object.defineProperty(this, "zOrder", {
            value: r,
            writable: !1,
            configurable: !0
          });
        }
        disconnect() {
          delete this.parent, delete this.zOrder;
        }
        dispatchPointerEvent(e) {
          this.postMessage({
            type: "event",
            event: {
              cancelBubble: e.cancelBubble,
              bubbles: e.bubbles,
              detail: e.detail,
              identifier: e.identifier,
              layerX: e.layerX,
              layerY: e.layerY,
              originalX: e.originalX,
              originalY: e.originalY,
              type: e.type,
              x: e.x,
              y: e.y
            }
          });
        }
      }), l.default = a;
    },
    /* 290 */
    /***/
    function(n, l, i) {
      i.r(l), (function(c) {
        i.d(l, "default", function() {
          return V;
        });
        var Z = i(12), L = i(68), K = i(70), u = i(286), a = i(289), e = i(250), r = i(291), X = i(214), W = i(218), p = i(213);
        i(1).glMatrix.setMatrixArrayType(Array);
        const C = Symbol("enteredTargets");
        function I(S) {
          return S.id = S.id || `_layer${Math.random().toString(36).slice(2, 12)}`, S.dataset || (S.dataset = {}), S.dataset.layerId = S.id, S.connect = (Y, T) => {
            S.parent = Y, Object.defineProperty(S, "zOrder", {
              value: T,
              writable: !1,
              configurable: !0
            });
          }, S.disconnect = (Y) => {
            delete S.zOrder;
          }, S.canvas = S, S.getResolution = () => ({
            width: 0,
            height: 0
          }), S.setResolution = () => !1, S.options = {
            handleEvent: !1
          }, S;
        }
        function o(S, Y) {
          const T = S.children;
          let y = null;
          for (let J = 0; J < T.length; J++) {
            const N = T[J];
            if ((Y === N || y != null) && (y = N), y && y !== Y && !y.offscreen)
              return y.canvas;
          }
          return null;
        }
        function G(S, Y) {
          const [T, y] = S.renderOffset, {
            width: J,
            height: N
          } = S.getResolution(), R = S.displayRatio;
          S.renderer.drawImage(Y.canvas, -T / R, -y / R, J / R, N / R);
        }
        const d = {};
        function t(S) {
          const Y = ["mousedown", "mouseup", "mousemove", "mousewheel", "wheel", "touchstart", "touchend", "touchmove", "touchcancel", "click", "dblclick", "longpress", "tap", "contextmenu"], T = S.container;
          T.addEventListener("mouseleave", (y) => {
            const J = S[C];
            if (J.size) {
              const N = new X.default("mouseleave");
              N.setOriginalEvent(y), [...J].forEach((R) => {
                R.dispatchEvent(N);
              }), S[C].clear();
            }
          }, {
            passive: !0
          }), Y.forEach((y) => {
            T.addEventListener(y, (J) => {
              const {
                left: N,
                top: R,
                displayRatio: x
              } = S.options, M = S.orderedChildren;
              Object(r.default)(J, {
                offsetLeft: N,
                offsetTop: R,
                displayRatio: x
              }).forEach((P) => {
                const D = P.identifier;
                if (P.type === "touchmove" || P.type === "touchend") {
                  const F = d[D];
                  F && F.dispatchEvent(P), P.type === "touchend" && delete d[D];
                } else {
                  for (let F = M.length - 1; F >= 0; F--) {
                    const v = M[F];
                    if (v.options.handleEvent !== !1) {
                      if (v.dispatchPointerEvent(P) && P.target !== v)
                        break;
                      P.cancelBubble = !1;
                    }
                  }
                  if (P.target === M[0])
                    for (let F = M.length - 1; F >= 0; F--) {
                      const v = M[F];
                      if (v.options.handleEvent !== !1) {
                        P.target = v;
                        break;
                      }
                    }
                }
                const _ = P.target;
                if (P.type === "touchstart" && (d[D] = P.target), P.type === "mousemove") {
                  const F = S[C];
                  let v;
                  if (_) {
                    const ii = _.ancestors || [];
                    v = /* @__PURE__ */ new Set([_, ...ii]);
                  } else
                    v = /* @__PURE__ */ new Set();
                  const O = Object.entries(J);
                  if (!F.has(_) && _) {
                    const ii = new X.default("mouseenter");
                    ii.setOriginalEvent(J), O.forEach(([$, ai]) => {
                      ii[$] = ai;
                    }), F.add(_), _.dispatchEvent(ii);
                    const ti = _.ancestors;
                    ti && ti.forEach(($) => {
                      $ instanceof K.default && !F.has($) && (F.add($), $.dispatchEvent(ii));
                    });
                  }
                  const li = new X.default("mouseleave");
                  li.setOriginalEvent(J), O.forEach(([ii, ti]) => {
                    li[ii] = ti;
                  }), [...F].forEach((ii) => {
                    v.has(ii) || (F.delete(ii), ii.dispatchEvent(li));
                  });
                }
              });
            }, {
              passive: y !== "contextmenu"
            });
          });
        }
        function s(S, Y) {
          if (Y && Y.style) {
            let {
              width: T,
              height: y,
              mode: J,
              container: N
            } = S;
            const {
              clientWidth: R,
              clientHeight: x
            } = N;
            T = T || R, y = y || x, J === "static" ? (Y.style.width = `${T}px`, Y.style.height = `${y}px`) : (Y.style.top = "0", Y.style.left = "0", Y.style.width = `${R}px`, Y.style.height = `${x}px`, Y.style.transform = "", Y.style.webkitTransform = "");
          }
        }
        const b = Symbol("offscreenLayerCount");
        class V extends e.default {
          /**
            width
            height
            mode: 'static', 'scale', 'stickyWidth', 'stickyHeight', 'stickyTop', 'stickyBottom', 'stickyLeft', 'stickyRight'
           */
          constructor(Y = {}) {
            if (super(), !Y.container)
              if (typeof Z.ENV.Container == "function")
                Y.container = new Z.ENV.Container(Y.width || 300, Y.height || 150);
              else
                throw new Error("No container specified.");
            if (this.container = Y.container, this.container.style && (this.container.style.overflow || (this.container.style.overflow = "hidden"), this.container.style.position || (this.container.style.position = "relative")), this.options = Y, Y.displayRatio = Y.displayRatio || 1, Y.mode = Y.mode || "scale", Y.left = 0, Y.top = 0, Y.autoResize = Y.autoResize !== !1, Y.autoResize) {
              let T;
              if (typeof globalThis < "u" ? T = globalThis : T = typeof window < "u" ? window : c, T.addEventListener) {
                const y = this;
                T.addEventListener("resize", function J() {
                  typeof document < "u" && document.contains(y.container) ? y.resize() : T.removeEventListener("resize", J);
                });
              }
            }
            this[C] = /* @__PURE__ */ new Set(), this.setResolution(Y), t(this), this[b] = 0;
          }
          get hasOffscreenCanvas() {
            return this[b] > 0;
          }
          set displayRatio(Y) {
            this.options.displayRatio !== Y && (this.options.displayRatio = Y, this.resize());
          }
          get displayRatio() {
            return this.options.displayRatio;
          }
          set height(Y) {
            this.options.height !== Y && (this.options.height = Y, this.resize());
          }
          get height() {
            return this.options.height;
          }
          set mode(Y) {
            this.options.mode !== Y && (this.options.mode = Y, this.resize());
          }
          get mode() {
            return this.options.mode;
          }
          set width(Y) {
            this.options.width !== Y && (this.options.width = Y, this.resize());
          }
          get width() {
            return this.options.width;
          }
          /* override */
          appendChild(Y) {
            !(Y instanceof u.default) && !(Y instanceof a.default) && I(Y);
            const T = super.appendChild(Y), y = Y.canvas;
            return Y.offscreen ? this[b]++ : this.container.appendChild(y), s(this.options, y), Y.setResolution(this.getResolution()), T;
          }
          /* override */
          forceUpdate() {
            this.hasOffscreenCanvas && !this._requestID && (this._requestID = Object(L.requestAnimationFrame)(() => {
              delete this._requestID, this.render();
            }));
          }
          /* override */
          insertBefore(Y, T) {
            !(Y instanceof u.default) && !(Y instanceof a.default) && I(Y);
            const y = super.insertBefore(Y, T), J = Y.canvas;
            if (!Y.offscreen) {
              const N = o(this, Y);
              this.container.insertBefore(J, N);
            }
            return s(this.options, J), Y.setResolution(this.getResolution()), y;
          }
          layer(Y = "default", T = {}) {
            T = Object.assign({}, this.options, T), T.id = Y;
            const y = this.orderedChildren;
            for (let R = 0; R < y.length; R++)
              if (y[R].id === Y)
                return y[R];
            const J = T.worker;
            let N;
            return J ? N = new a.default(T) : N = new u.default(T), this.appendChild(N), N;
          }
          async preload(...Y) {
            const T = [], y = [], J = [];
            for (let N = 0; N < Y.length; N++) {
              const R = Y[N];
              let x;
              if (typeof R == "string")
                x = Object(W.loadTexture)(R);
              else if (Array.isArray(R))
                x = Object(W.loadFrames)(...R);
              else {
                const {
                  id: M,
                  src: Q
                } = R;
                x = Object(W.loadTexture)(Q, M);
              }
              x instanceof Promise || (x = Promise.resolve(x)), y.push(x.then((M) => {
                T.push(M), J[N] = M;
                const Q = new X.default({
                  type: "preload",
                  detail: {
                    current: M,
                    loaded: T,
                    resources: Y
                  }
                });
                this.dispatchEvent(Q);
              }));
            }
            return await Promise.all(y), J;
          }
          /* override */
          removeChild(Y) {
            const T = super.removeChild(Y);
            if (T) {
              Y._prepareRenderFinished && Y._prepareRenderFinished();
              const y = Y.canvas;
              y && y.remove && y.remove(), Y.offscreen && this[b]--;
            }
            return T;
          }
          // for offscreen mode rendering
          render() {
            const Y = this.orderedChildren;
            let T = null;
            const y = [];
            for (let J = 0; J < Y.length; J++) {
              const N = Y[J], R = y.length > 0;
              if (N instanceof u.default && !N.offscreen)
                if (!N.autoRender)
                  R && (console.warn("Some offscreen canvas will not be rendered."), y.length = 0);
                else if (T = N, R) {
                  N.renderer.clear();
                  for (let x = 0; x < y.length; x++) {
                    const M = y[x];
                    M.render(), G(N, M);
                  }
                  y.length = 0, N.render({
                    clear: !1
                  });
                } else
                  N.prepareRender && N.render();
              else
                N.offscreen ? T ? (N.prepareRender && N.render(), G(T, N)) : y.push(N) : N instanceof a.default && R && (console.warn("Some offscreen canvas will not be rendered."), y.length = 0);
            }
          }
          /* override */
          replaceChild(Y, T) {
            const y = super.replaceChild(Y, T);
            T.canvas.remove && T.canvas.remove(), T.offscreen && this[b]--;
            const J = Y.canvas;
            if (!Y.offscreen) {
              const N = o(this, Y);
              this.container.insertBefore(J, N);
            }
            return s(this.options, J), Y.setResolution(this.getResolution()), y;
          }
          resize() {
            const Y = this.options;
            this.children.forEach((T) => {
              s(Y, T.canvas);
            }), this.setResolution(Y), this.dispatchEvent({
              type: "resize"
            });
          }
          /* override */
          setResolution({
            width: Y,
            height: T
          } = {}) {
            const y = this.container, {
              clientWidth: J,
              clientHeight: N
            } = y;
            (Y == null || T == null) && (Y = Y ?? J, T = T ?? N);
            const {
              mode: R,
              displayRatio: x
            } = this.options;
            if (Y *= x, T *= x, this.options.left = 0, this.options.top = 0, R === "stickyHeight" || R === "stickyLeft" || R === "stickyRight") {
              const M = Y;
              Y = J * T / N, R === "stickyHeight" && (this.options.left = 0.5 * (Y - M)), R === "stickyRight" && (this.options.left = Y - M);
            } else if (R === "stickyWidth" || R === "stickyTop" || R === "stickyBottom") {
              const M = T;
              T = N * Y / J, R === "stickyWidth" && (this.options.top = 0.5 * (T - M)), R === "stickyBottom" && (this.options.top = T - M);
            }
            super.setResolution({
              width: Y,
              height: T
            });
          }
          snapshot({
            offscreen: Y = !1,
            layers: T
          } = {}) {
            const y = Y ? "snapshotOffScreenCanvas" : "snapshotCanvas", {
              width: J,
              height: N
            } = this.getResolution();
            this[y] = this[y] || Z.ENV.createCanvas(J, N, {
              offscreen: Y
            });
            const R = this[y].getContext("2d");
            T = T || this.orderedChildren, this[y].width = J, this[y].height = N;
            for (let x = 0; x < T.length; x++) {
              const M = T[x];
              if (!M.options.ignoreSnapshot) {
                M.render && M.render();
                const Q = M.canvas;
                Q && Q !== M && R.drawImage(Q, 0, 0, J, N);
              }
            }
            return this[y];
          }
        }
        typeof document < "u" && (V.prototype.layer3d = function(S, Y = {}) {
          const T = Y.url || "https://unpkg.com/sprite-extend-3d/dist/sprite-extend-3d.min.js";
          return new Promise((y, J) => {
            const N = document.createElement("script");
            N.async = !1, N.src = T, N.onload = () => {
              try {
                y(this.layer3d(S, Y));
              } catch (R) {
                J(R);
              }
            }, document.documentElement.appendChild(N);
          });
        }), p.default.registerNode(V, "scene");
      }).call(this, i(22));
    },
    /* 291 */
    /***/
    function(n, l, i) {
      i.r(l), i.d(l, "default", function() {
        return Z;
      });
      var c = i(214);
      i(1).glMatrix.setMatrixArrayType(Array);
      function Z(L, {
        offsetTop: K = 0,
        offsetLeft: u = 0,
        displayRatio: a = 1
      } = {}) {
        let e, r;
        const X = [], {
          left: W,
          top: p,
          width: C,
          height: I
        } = L.target.getBoundingClientRect(), o = L.target.width, G = L.target.height, d = L.changedTouches || [L];
        for (let s = 0; s < d.length; s++) {
          const b = d[s], V = b.identifier, {
            clientX: S,
            clientY: Y
          } = b;
          S != null && Y != null && X.push({
            x: Math.round((S | 0) - W),
            y: Math.round((Y | 0) - p),
            identifier: V
          });
        }
        X.length <= 0 && X.push({
          x: e,
          y: r
        });
        const t = [];
        return X.forEach((s) => {
          s.x != null && s.y != null && (e = (s.x * o / C - u) / a, r = (s.y * G / I - K) / a);
          const b = new c.default(L);
          Object.defineProperties(b, {
            layerX: {
              value: e,
              configurable: !0
            },
            layerY: {
              value: r,
              configurable: !0
            },
            originalX: {
              value: s.x
            },
            originalY: {
              value: s.y
            },
            x: {
              value: e,
              configurable: !0
            },
            y: {
              value: r,
              configurable: !0
            },
            identifier: {
              value: s.identifier
            }
          }), t.push(b);
        }), t;
      }
    }
    /******/
  ])
);
Ti.version;
Ti.Arc;
Ti.Block;
Ti.Cloud;
Ti.Color;
Ti.Ellipse;
Ti.Gradient;
Ti.Group;
Ti.Label;
Ti.Layer;
Ti.LayerWorker;
Ti.Node;
Ti.Parallel;
Ti.Path;
Ti.Polyline;
Ti.Rect;
Ti.Regular;
Ti.Ring;
Ti.Scene;
Ti.Sprite;
Ti.SpriteSvg;
Ti.Star;
Ti.Triangle;
Ti.helpers;
Ti.createElement;
Ti.isSpriteNode;
Ti.registerNode;
Ti.requestAnimationFrame;
Ti.cancelAnimationFrame;
Ti.ENV;
var Pl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Hd(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Md = { exports: {} };
Md.exports;
(function(n) {
  var l = function() {
    var i = String.fromCharCode, c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", L = {};
    function K(a, e) {
      if (!L[a]) {
        L[a] = {};
        for (var r = 0; r < a.length; r++)
          L[a][a.charAt(r)] = r;
      }
      return L[a][e];
    }
    var u = {
      compressToBase64: function(a) {
        if (a == null)
          return "";
        var e = u._compress(a, 6, function(r) {
          return c.charAt(r);
        });
        switch (e.length % 4) {
          default:
          case 0:
            return e;
          case 1:
            return e + "===";
          case 2:
            return e + "==";
          case 3:
            return e + "=";
        }
      },
      decompressFromBase64: function(a) {
        return a == null ? "" : a == "" ? null : u._decompress(a.length, 32, function(e) {
          return K(c, a.charAt(e));
        });
      },
      compressToUTF16: function(a) {
        return a == null ? "" : u._compress(a, 15, function(e) {
          return i(e + 32);
        }) + " ";
      },
      decompressFromUTF16: function(a) {
        return a == null ? "" : a == "" ? null : u._decompress(a.length, 16384, function(e) {
          return a.charCodeAt(e) - 32;
        });
      },
      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: function(a) {
        for (var e = u.compress(a), r = new Uint8Array(e.length * 2), X = 0, W = e.length; X < W; X++) {
          var p = e.charCodeAt(X);
          r[X * 2] = p >>> 8, r[X * 2 + 1] = p % 256;
        }
        return r;
      },
      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: function(a) {
        if (a == null)
          return u.decompress(a);
        for (var e = new Array(a.length / 2), r = 0, X = e.length; r < X; r++)
          e[r] = a[r * 2] * 256 + a[r * 2 + 1];
        var W = [];
        return e.forEach(function(p) {
          W.push(i(p));
        }), u.decompress(W.join(""));
      },
      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: function(a) {
        return a == null ? "" : u._compress(a, 6, function(e) {
          return Z.charAt(e);
        });
      },
      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: function(a) {
        return a == null ? "" : a == "" ? null : (a = a.replace(/ /g, "+"), u._decompress(a.length, 32, function(e) {
          return K(Z, a.charAt(e));
        }));
      },
      compress: function(a) {
        return u._compress(a, 16, function(e) {
          return i(e);
        });
      },
      _compress: function(a, e, r) {
        if (a == null)
          return "";
        var X, W, p = {}, C = {}, I = "", o = "", G = "", d = 2, t = 3, s = 2, b = [], V = 0, S = 0, Y;
        for (Y = 0; Y < a.length; Y += 1)
          if (I = a.charAt(Y), Object.prototype.hasOwnProperty.call(p, I) || (p[I] = t++, C[I] = !0), o = G + I, Object.prototype.hasOwnProperty.call(p, o))
            G = o;
          else {
            if (Object.prototype.hasOwnProperty.call(C, G)) {
              if (G.charCodeAt(0) < 256) {
                for (X = 0; X < s; X++)
                  V = V << 1, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++;
                for (W = G.charCodeAt(0), X = 0; X < 8; X++)
                  V = V << 1 | W & 1, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++, W = W >> 1;
              } else {
                for (W = 1, X = 0; X < s; X++)
                  V = V << 1 | W, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++, W = 0;
                for (W = G.charCodeAt(0), X = 0; X < 16; X++)
                  V = V << 1 | W & 1, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++, W = W >> 1;
              }
              d--, d == 0 && (d = Math.pow(2, s), s++), delete C[G];
            } else
              for (W = p[G], X = 0; X < s; X++)
                V = V << 1 | W & 1, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++, W = W >> 1;
            d--, d == 0 && (d = Math.pow(2, s), s++), p[o] = t++, G = String(I);
          }
        if (G !== "") {
          if (Object.prototype.hasOwnProperty.call(C, G)) {
            if (G.charCodeAt(0) < 256) {
              for (X = 0; X < s; X++)
                V = V << 1, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++;
              for (W = G.charCodeAt(0), X = 0; X < 8; X++)
                V = V << 1 | W & 1, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++, W = W >> 1;
            } else {
              for (W = 1, X = 0; X < s; X++)
                V = V << 1 | W, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++, W = 0;
              for (W = G.charCodeAt(0), X = 0; X < 16; X++)
                V = V << 1 | W & 1, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++, W = W >> 1;
            }
            d--, d == 0 && (d = Math.pow(2, s), s++), delete C[G];
          } else
            for (W = p[G], X = 0; X < s; X++)
              V = V << 1 | W & 1, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++, W = W >> 1;
          d--, d == 0 && (d = Math.pow(2, s), s++);
        }
        for (W = 2, X = 0; X < s; X++)
          V = V << 1 | W & 1, S == e - 1 ? (S = 0, b.push(r(V)), V = 0) : S++, W = W >> 1;
        for (; ; )
          if (V = V << 1, S == e - 1) {
            b.push(r(V));
            break;
          } else
            S++;
        return b.join("");
      },
      decompress: function(a) {
        return a == null ? "" : a == "" ? null : u._decompress(a.length, 32768, function(e) {
          return a.charCodeAt(e);
        });
      },
      _decompress: function(a, e, r) {
        var X = [], W = 4, p = 4, C = 3, I = "", o = [], G, d, t, s, b, V, S, Y = { val: r(0), position: e, index: 1 };
        for (G = 0; G < 3; G += 1)
          X[G] = G;
        for (t = 0, b = Math.pow(2, 2), V = 1; V != b; )
          s = Y.val & Y.position, Y.position >>= 1, Y.position == 0 && (Y.position = e, Y.val = r(Y.index++)), t |= (s > 0 ? 1 : 0) * V, V <<= 1;
        switch (t) {
          case 0:
            for (t = 0, b = Math.pow(2, 8), V = 1; V != b; )
              s = Y.val & Y.position, Y.position >>= 1, Y.position == 0 && (Y.position = e, Y.val = r(Y.index++)), t |= (s > 0 ? 1 : 0) * V, V <<= 1;
            S = i(t);
            break;
          case 1:
            for (t = 0, b = Math.pow(2, 16), V = 1; V != b; )
              s = Y.val & Y.position, Y.position >>= 1, Y.position == 0 && (Y.position = e, Y.val = r(Y.index++)), t |= (s > 0 ? 1 : 0) * V, V <<= 1;
            S = i(t);
            break;
          case 2:
            return "";
        }
        for (X[3] = S, d = S, o.push(S); ; ) {
          if (Y.index > a)
            return "";
          for (t = 0, b = Math.pow(2, C), V = 1; V != b; )
            s = Y.val & Y.position, Y.position >>= 1, Y.position == 0 && (Y.position = e, Y.val = r(Y.index++)), t |= (s > 0 ? 1 : 0) * V, V <<= 1;
          switch (S = t) {
            case 0:
              for (t = 0, b = Math.pow(2, 8), V = 1; V != b; )
                s = Y.val & Y.position, Y.position >>= 1, Y.position == 0 && (Y.position = e, Y.val = r(Y.index++)), t |= (s > 0 ? 1 : 0) * V, V <<= 1;
              X[p++] = i(t), S = p - 1, W--;
              break;
            case 1:
              for (t = 0, b = Math.pow(2, 16), V = 1; V != b; )
                s = Y.val & Y.position, Y.position >>= 1, Y.position == 0 && (Y.position = e, Y.val = r(Y.index++)), t |= (s > 0 ? 1 : 0) * V, V <<= 1;
              X[p++] = i(t), S = p - 1, W--;
              break;
            case 2:
              return o.join("");
          }
          if (W == 0 && (W = Math.pow(2, C), C++), X[S])
            I = X[S];
          else if (S === p)
            I = d + d.charAt(0);
          else
            return null;
          o.push(I), X[p++] = d + I.charAt(0), W--, d = I, W == 0 && (W = Math.pow(2, C), C++);
        }
      }
    };
    return u;
  }();
  n != null ? n.exports = l : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
    return l;
  });
})(Md);
var ut = Md.exports;
function Ub(n) {
  return JSON.parse(ut.decompress(n));
}
function Qb(n) {
  return ut.compress(JSON.stringify(n));
}
const hd = Object.keys;
class Pb {
  constructor(l, i, c) {
    Object.defineProperty(this, "dpr", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "displayCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "floatCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dustbin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), this.displayCanvas = l, this.floatCanvas = i;
    const Z = this.displayCanvas.getContext("2d");
    Z && (this.dpr = this.getRatioWithContext(Z)), this.collector = c;
  }
  getRatioWithContext(l) {
    const i = l.webkitBackingStorePixelRatio || l.mozBackingStorePixelRatio || l.msBackingStorePixelRatio || l.oBackingStorePixelRatio || l.backingStorePixelRatio || 1;
    return Math.max(1, (window.devicePixelRatio || 1) / i);
  }
  /** 设置当前选中的工具配置数据 */
  setCurrentToolsData(l) {
    this.currentToolsData = l;
  }
  /** 设置当前绘制任务数据 */
  setCurrentLocalWorkData(l) {
    this.currentLocalWorkData = l;
  }
  /** 设置相机参数 */
  setCameraOpt(l) {
    this.cameraOpt = l;
  }
  /** 获取当前绘制任务id */
  getWorkId() {
    return this.currentLocalWorkData.workId;
  }
}
const Gt = "dmFyIHhlPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgTWU9KFB0LFd0LFJ0KT0+V3QgaW4gUHQ/eGUoUHQsV3Qse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlJ0fSk6UHRbV3RdPVJ0O3ZhciB6dD0oUHQsV3QsUnQpPT4oTWUoUHQsdHlwZW9mIFd0IT0ic3ltYm9sIj9XdCsiIjpXdCxSdCksUnQpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgUHQ7KGZ1bmN0aW9uKEwpe0xbTC5QZW5jaWw9MV09IlBlbmNpbCIsTFtMLkVyYXNlcj0yXT0iRXJhc2VyIixMW0wuU2VsZWN0b3I9M109IlNlbGVjdG9yIixMW0wuQ2xpY2tlcj00XT0iQ2xpY2tlciIsTFtMLkFycm93PTVdPSJBcnJvdyIsTFtMLkhhbmQ9Nl09IkhhbmQiLExbTC5MYXNlclBlbj03XT0iTGFzZXJQZW4ifSkoUHR8fChQdD17fSkpO3ZhciBXdDsoZnVuY3Rpb24oTCl7TFtMLlBhdGg9MF09IlBhdGgiLExbTC5SZWN0PTFdPSJSZWN0In0pKFd0fHwoV3Q9e30pKTt2YXIgUnQ7KGZ1bmN0aW9uKEwpe0xbTC5Mb2NhbD0xXT0iTG9jYWwiLExbTC5TZXJ2aWNlPTJdPSJTZXJ2aWNlIn0pKFJ0fHwoUnQ9e30pKTt2YXIgR3Q7KGZ1bmN0aW9uKEwpe0xbTC5QZW5kaW5nPTBdPSJQZW5kaW5nIixMW0wuU3RhcnQ9MV09IlN0YXJ0IixMW0wuRG9pbmc9Ml09IkRvaW5nIixMW0wuRG9uZT0zXT0iRG9uZSIsTFtMLkZyZWV6ZT00XT0iRnJlZXplIixMW0wuVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KShHdHx8KEd0PXt9KSk7dmFyIFR0OyhmdW5jdGlvbihMKXtMW0wuSW5pdD0wXT0iSW5pdCIsTFtMLlRyYW5zZm9ybT0xXT0iVHJhbnNmb3JtIixMW0wuVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixMW0wuVXBkYXRlU2NlbmU9M109IlVwZGF0ZVNjZW5lIixMW0wuQ3JlYXRlV29yaz00XT0iQ3JlYXRlV29yayIsTFtMLkRyYXdXb3JrPTVdPSJEcmF3V29yayIsTFtMLkZ1bGxXb3JrPTZdPSJGdWxsV29yayIsTFtMLlVwZGF0ZVdvcms9N109IlVwZGF0ZVdvcmsiLExbTC5VcGRhdGVOb2RlPThdPSJVcGRhdGVOb2RlIixMW0wuUmVtb3ZlTm9kZT05XT0iUmVtb3ZlTm9kZSIsTFtMLkNsZWFyPTEwXT0iQ2xlYXIiLExbTC5TZWxlY3Q9MTFdPSJTZWxlY3QiLExbTC5EZXN0cm95PTEyXT0iRGVzdHJveSIsTFtMLk5vbmU9MTNdPSJOb25lIixMW0wuQ29tYmluZURyYXc9MTRdPSJDb21iaW5lRHJhdyJ9KShUdHx8KFR0PXt9KSk7dmFyIGt0OyhmdW5jdGlvbihMKXtMW0wuUGF0aD0wXT0iUGF0aCIsTFtMLlJlY3Q9MV09IlJlY3QiLExbTC5UZXh0dXJlPTJdPSJUZXh0dXJlIn0pKGt0fHwoa3Q9e30pKTt2YXIgX3Q7KGZ1bmN0aW9uKEwpe0wuV2ViZ2wyPSJ3ZWJnbDIiLEwuV2ViZ2w9IndlYmdsIixMLkNhbnZhczJkPSIyZCJ9KShfdHx8KF90PXt9KSk7dmFyIHRlOyhmdW5jdGlvbihMKXtMLmltbWVkaWF0ZWx5PSJpbW1lZGlhdGVseSIsTC5jb250aW51b3VzPSJjb250aW51b3VzIn0pKHRlfHwodGU9e30pKTt2YXIgVXQ7KGZ1bmN0aW9uKEwpe0xbTC5GbG9hdD0wXT0iRmxvYXQiLExbTC5CZz0xXT0iQmcifSkoVXR8fChVdD17fSkpO2NsYXNzIFp0e2NvbnN0cnVjdG9yKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNVbml0VGltZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjFlM30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuZnVsbExheWVyPWUsdGhpcy5kcmF3TGF5ZXI9dH1zZXRXb3JrSWQoZSl7dGhpcy53b3JrSWQ9ZX1nZXRXb3JrSWQoKXtyZXR1cm4gdGhpcy53b3JrSWR9Z2V0V29ya09wdGlvbnMoKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9uc319dmFyIE90PWZ1bmN0aW9uKEwpe3ZhciBlPXt9O2Z1bmN0aW9uIHQoYSl7aWYoZVthXSlyZXR1cm4gZVthXS5leHBvcnRzO3ZhciBvPWVbYV09e2k6YSxsOiExLGV4cG9ydHM6e319O3JldHVybiBMW2FdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLHQpLG8ubD0hMCxvLmV4cG9ydHN9cmV0dXJuIHQubT1MLHQuYz1lLHQuZD1mdW5jdGlvbihhLG8sdil7dC5vKGEsbyl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLG8se2VudW1lcmFibGU6ITAsZ2V0OnZ9KX0sdC5yPWZ1bmN0aW9uKGEpe3R5cGVvZiBTeW1ib2w8InUiJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LHQudD1mdW5jdGlvbihhLG8pe2lmKG8mMSYmKGE9dChhKSksbyY4fHxvJjQmJnR5cGVvZiBhPT0ib2JqZWN0IiYmYSYmYS5fX2VzTW9kdWxlKXJldHVybiBhO3ZhciB2PU9iamVjdC5jcmVhdGUobnVsbCk7aWYodC5yKHYpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCx2YWx1ZTphfSksbyYyJiZ0eXBlb2YgYSE9InN0cmluZyIpZm9yKHZhciBUIGluIGEpdC5kKHYsVCwoZnVuY3Rpb24oZCl7cmV0dXJuIGFbZF19KS5iaW5kKG51bGwsVCkpO3JldHVybiB2fSx0Lm49ZnVuY3Rpb24oYSl7dmFyIG89YSYmYS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gYX07cmV0dXJuIHQuZChvLCJhIixvKSxvfSx0Lm89ZnVuY3Rpb24oYSxvKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsbyl9LHQucD0iL2pzLyIsdCh0LnM9MCl9KFtmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJ2ZXJzaW9uIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImhlbHBlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwiY3JlYXRlRWxlbWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJpc1Nwcml0ZU5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicmVnaXN0ZXJOb2RlIixmdW5jdGlvbigpe3JldHVybiBBfSk7dmFyIGE9dCgxMik7dC5kKGUsIkVOViIsZnVuY3Rpb24oKXtyZXR1cm4gYS5FTlZ9KTt2YXIgbz10KDY4KTt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBvLnJlcXVlc3RBbmltYXRpb25GcmFtZX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gby5jYW5jZWxBbmltYXRpb25GcmFtZX0pO3ZhciB2PXQoNzApO3QuZChlLCJOb2RlIixmdW5jdGlvbigpe3JldHVybiB2LmRlZmF1bHR9KTt2YXIgVD10KDIxNyk7dC5kKGUsIkNsb3VkIixmdW5jdGlvbigpe3JldHVybiBULmRlZmF1bHR9KTt2YXIgZD10KDIxOSk7dC5kKGUsIkJsb2NrIixmdW5jdGlvbigpe3JldHVybiBkLmRlZmF1bHR9KTt2YXIgdT10KDIyNCk7dC5kKGUsIlNwcml0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIGM9dCgyMjYpO3QuZChlLCJQYXRoIixmdW5jdGlvbigpe3JldHVybiBjLmRlZmF1bHR9KTt2YXIgRT10KDIyOSk7dC5kKGUsIlJlY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEUuZGVmYXVsdH0pO3ZhciBmPXQoMjMxKTt0LmQoZSwiVHJpYW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pO3ZhciBnPXQoMjM2KTt0LmQoZSwiUGFyYWxsZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGcuZGVmYXVsdH0pO3ZhciB5PXQoMjM4KTt0LmQoZSwiUmVndWxhciIsZnVuY3Rpb24oKXtyZXR1cm4geS5kZWZhdWx0fSk7dmFyIEM9dCgyNDApO3QuZChlLCJTdGFyIixmdW5jdGlvbigpe3JldHVybiBDLmRlZmF1bHR9KTt2YXIgeD10KDI0Mik7dC5kKGUsIkVsbGlwc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHguZGVmYXVsdH0pO3ZhciBoPXQoMjQ0KTt0LmQoZSwiQXJjIixmdW5jdGlvbigpe3JldHVybiBoLmRlZmF1bHR9KTt2YXIgbT10KDI0Nik7dC5kKGUsIlJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG0uZGVmYXVsdH0pO3ZhciByPXQoMjMyKTt0LmQoZSwiUG9seWxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH0pO3ZhciBpPXQoMjQ4KTt0LmQoZSwiTGFiZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdH0pO3ZhciBuPXQoMjUwKTt0LmQoZSwiR3JvdXAiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH0pO3ZhciBzPXQoMjg2KTt0LmQoZSwiTGF5ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdH0pO3ZhciBNPXQoMjg3KTt0LmQoZSwiU3ByaXRlU3ZnIixmdW5jdGlvbigpe3JldHVybiBNLmRlZmF1bHR9KTt2YXIgUD10KDI4OSk7dC5kKGUsIkxheWVyV29ya2VyIixmdW5jdGlvbigpe3JldHVybiBQLmRlZmF1bHR9KTt2YXIgUz10KDI5MCk7dC5kKGUsIlNjZW5lIixmdW5jdGlvbigpe3JldHVybiBTLmRlZmF1bHR9KTt2YXIgYj10KDIxMyksTz10KDIyMSk7dC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBPLkNvbG9yfSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBPLkdyYWRpZW50fSk7dmFyIEQ9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEk9Yi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQsUj1iLmRlZmF1bHQuaXNTcHJpdGVOb2RlLEE9Yi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSxVPXtwYXJzZUNvbG9yOk8ucGFyc2VDb2xvcixzaXplVG9QaXhlbDpELnNpemVUb1BpeGVsLHRvQXJyYXk6RC50b0FycmF5LHRvU3RyaW5nOkQudG9TdHJpbmcsdG9OdW1iZXI6RC50b051bWJlcn07bGV0IEs7Sz0iMy44LjMiO2NvbnN0IFY9S30sZnVuY3Rpb24oTCxlLHQpe3QucihlKTt2YXIgYT10KDIpO3QuZChlLCJnbE1hdHJpeCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pO3ZhciBvPXQoMyk7dC5kKGUsIm1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KTt2YXIgdj10KDQpO3QuZChlLCJtYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pO3ZhciBUPXQoNSk7dC5kKGUsIm1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgZD10KDYpO3QuZChlLCJtYXQ0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIHU9dCg3KTt0LmQoZSwicXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBjPXQoMTApO3QuZChlLCJxdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBFPXQoMTEpO3QuZChlLCJ2ZWMyIixmdW5jdGlvbigpe3JldHVybiBFfSk7dmFyIGY9dCg4KTt0LmQoZSwidmVjMyIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBnPXQoOSk7dC5kKGUsInZlYzQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiRVBTSUxPTiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJBUlJBWV9UWVBFIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsIlJBTkRPTSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJzZXRNYXRyaXhBcnJheVR5cGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwidG9SYWRpYW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9MWUtNixvPXR5cGVvZiBGbG9hdDMyQXJyYXk8InUiP0Zsb2F0MzJBcnJheTpBcnJheSx2PU1hdGgucmFuZG9tO2Z1bmN0aW9uIFQoRSl7bz1FfXZhciBkPU1hdGguUEkvMTgwO2Z1bmN0aW9uIHUoRSl7cmV0dXJuIEUqZH1mdW5jdGlvbiBjKEUsZil7cmV0dXJuIE1hdGguYWJzKEUtZik8PWEqTWF0aC5tYXgoMSxNYXRoLmFicyhFKSxNYXRoLmFicyhmKSl9TWF0aC5oeXBvdHx8KE1hdGguaHlwb3Q9ZnVuY3Rpb24oKXtmb3IodmFyIEU9MCxmPWFyZ3VtZW50cy5sZW5ndGg7Zi0tOylFKz1hcmd1bWVudHNbZl0qYXJndW1lbnRzW2ZdO3JldHVybiBNYXRoLnNxcnQoRSl9KX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiTERVIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pO3ZhciBhPXQoMik7ZnVuY3Rpb24gbygpe3ZhciBBPW5ldyBhLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoQVsxXT0wLEFbMl09MCksQVswXT0xLEFbM109MSxBfWZ1bmN0aW9uIHYoQSl7dmFyIFU9bmV3IGEuQVJSQVlfVFlQRSg0KTtyZXR1cm4gVVswXT1BWzBdLFVbMV09QVsxXSxVWzJdPUFbMl0sVVszXT1BWzNdLFV9ZnVuY3Rpb24gVChBLFUpe3JldHVybiBBWzBdPVVbMF0sQVsxXT1VWzFdLEFbMl09VVsyXSxBWzNdPVVbM10sQX1mdW5jdGlvbiBkKEEpe3JldHVybiBBWzBdPTEsQVsxXT0wLEFbMl09MCxBWzNdPTEsQX1mdW5jdGlvbiB1KEEsVSxLLFYpe3ZhciBRPW5ldyBhLkFSUkFZX1RZUEUoNCk7cmV0dXJuIFFbMF09QSxRWzFdPVUsUVsyXT1LLFFbM109VixRfWZ1bmN0aW9uIGMoQSxVLEssVixRKXtyZXR1cm4gQVswXT1VLEFbMV09SyxBWzJdPVYsQVszXT1RLEF9ZnVuY3Rpb24gRShBLFUpe2lmKEE9PT1VKXt2YXIgSz1VWzFdO0FbMV09VVsyXSxBWzJdPUt9ZWxzZSBBWzBdPVVbMF0sQVsxXT1VWzJdLEFbMl09VVsxXSxBWzNdPVVbM107cmV0dXJuIEF9ZnVuY3Rpb24gZihBLFUpe3ZhciBLPVVbMF0sVj1VWzFdLFE9VVsyXSxxPVVbM10sVz1LKnEtUSpWO3JldHVybiBXPyhXPTEvVyxBWzBdPXEqVyxBWzFdPS1WKlcsQVsyXT0tUSpXLEFbM109SypXLEEpOm51bGx9ZnVuY3Rpb24gZyhBLFUpe3ZhciBLPVVbMF07cmV0dXJuIEFbMF09VVszXSxBWzFdPS1VWzFdLEFbMl09LVVbMl0sQVszXT1LLEF9ZnVuY3Rpb24geShBKXtyZXR1cm4gQVswXSpBWzNdLUFbMl0qQVsxXX1mdW5jdGlvbiBDKEEsVSxLKXt2YXIgVj1VWzBdLFE9VVsxXSxxPVVbMl0sVz1VWzNdLEg9S1swXSxaPUtbMV0sdHQ9S1syXSxfPUtbM107cmV0dXJuIEFbMF09VipIK3EqWixBWzFdPVEqSCtXKlosQVsyXT1WKnR0K3EqXyxBWzNdPVEqdHQrVypfLEF9ZnVuY3Rpb24geChBLFUsSyl7dmFyIFY9VVswXSxRPVVbMV0scT1VWzJdLFc9VVszXSxIPU1hdGguc2luKEspLFo9TWF0aC5jb3MoSyk7cmV0dXJuIEFbMF09VipaK3EqSCxBWzFdPVEqWitXKkgsQVsyXT1WKi1IK3EqWixBWzNdPVEqLUgrVypaLEF9ZnVuY3Rpb24gaChBLFUsSyl7dmFyIFY9VVswXSxRPVVbMV0scT1VWzJdLFc9VVszXSxIPUtbMF0sWj1LWzFdO3JldHVybiBBWzBdPVYqSCxBWzFdPVEqSCxBWzJdPXEqWixBWzNdPVcqWixBfWZ1bmN0aW9uIG0oQSxVKXt2YXIgSz1NYXRoLnNpbihVKSxWPU1hdGguY29zKFUpO3JldHVybiBBWzBdPVYsQVsxXT1LLEFbMl09LUssQVszXT1WLEF9ZnVuY3Rpb24gcihBLFUpe3JldHVybiBBWzBdPVVbMF0sQVsxXT0wLEFbMl09MCxBWzNdPVVbMV0sQX1mdW5jdGlvbiBpKEEpe3JldHVybiJtYXQyKCIrQVswXSsiLCAiK0FbMV0rIiwgIitBWzJdKyIsICIrQVszXSsiKSJ9ZnVuY3Rpb24gbihBKXtyZXR1cm4gTWF0aC5oeXBvdChBWzBdLEFbMV0sQVsyXSxBWzNdKX1mdW5jdGlvbiBzKEEsVSxLLFYpe3JldHVybiBBWzJdPVZbMl0vVlswXSxLWzBdPVZbMF0sS1sxXT1WWzFdLEtbM109VlszXS1BWzJdKktbMV0sW0EsVSxLXX1mdW5jdGlvbiBNKEEsVSxLKXtyZXR1cm4gQVswXT1VWzBdK0tbMF0sQVsxXT1VWzFdK0tbMV0sQVsyXT1VWzJdK0tbMl0sQVszXT1VWzNdK0tbM10sQX1mdW5jdGlvbiBQKEEsVSxLKXtyZXR1cm4gQVswXT1VWzBdLUtbMF0sQVsxXT1VWzFdLUtbMV0sQVsyXT1VWzJdLUtbMl0sQVszXT1VWzNdLUtbM10sQX1mdW5jdGlvbiBTKEEsVSl7cmV0dXJuIEFbMF09PT1VWzBdJiZBWzFdPT09VVsxXSYmQVsyXT09PVVbMl0mJkFbM109PT1VWzNdfWZ1bmN0aW9uIGIoQSxVKXt2YXIgSz1BWzBdLFY9QVsxXSxRPUFbMl0scT1BWzNdLFc9VVswXSxIPVVbMV0sWj1VWzJdLHR0PVVbM107cmV0dXJuIE1hdGguYWJzKEstVyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEspLE1hdGguYWJzKFcpKSYmTWF0aC5hYnMoVi1IKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoViksTWF0aC5hYnMoSCkpJiZNYXRoLmFicyhRLVopPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhRKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKHEtdHQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyh0dCkpfWZ1bmN0aW9uIE8oQSxVLEspe3JldHVybiBBWzBdPVVbMF0qSyxBWzFdPVVbMV0qSyxBWzJdPVVbMl0qSyxBWzNdPVVbM10qSyxBfWZ1bmN0aW9uIEQoQSxVLEssVil7cmV0dXJuIEFbMF09VVswXStLWzBdKlYsQVsxXT1VWzFdK0tbMV0qVixBWzJdPVVbMl0rS1syXSpWLEFbM109VVszXStLWzNdKlYsQX12YXIgST1DLFI9UH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KTt2YXIgYT10KDIpO2Z1bmN0aW9uIG8oKXt2YXIgUj1uZXcgYS5BUlJBWV9UWVBFKDYpO3JldHVybiBhLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFJbMV09MCxSWzJdPTAsUls0XT0wLFJbNV09MCksUlswXT0xLFJbM109MSxSfWZ1bmN0aW9uIHYoUil7dmFyIEE9bmV3IGEuQVJSQVlfVFlQRSg2KTtyZXR1cm4gQVswXT1SWzBdLEFbMV09UlsxXSxBWzJdPVJbMl0sQVszXT1SWzNdLEFbNF09Uls0XSxBWzVdPVJbNV0sQX1mdW5jdGlvbiBUKFIsQSl7cmV0dXJuIFJbMF09QVswXSxSWzFdPUFbMV0sUlsyXT1BWzJdLFJbM109QVszXSxSWzRdPUFbNF0sUls1XT1BWzVdLFJ9ZnVuY3Rpb24gZChSKXtyZXR1cm4gUlswXT0xLFJbMV09MCxSWzJdPTAsUlszXT0xLFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiB1KFIsQSxVLEssVixRKXt2YXIgcT1uZXcgYS5BUlJBWV9UWVBFKDYpO3JldHVybiBxWzBdPVIscVsxXT1BLHFbMl09VSxxWzNdPUsscVs0XT1WLHFbNV09USxxfWZ1bmN0aW9uIGMoUixBLFUsSyxWLFEscSl7cmV0dXJuIFJbMF09QSxSWzFdPVUsUlsyXT1LLFJbM109VixSWzRdPVEsUls1XT1xLFJ9ZnVuY3Rpb24gRShSLEEpe3ZhciBVPUFbMF0sSz1BWzFdLFY9QVsyXSxRPUFbM10scT1BWzRdLFc9QVs1XSxIPVUqUS1LKlY7cmV0dXJuIEg/KEg9MS9ILFJbMF09USpILFJbMV09LUsqSCxSWzJdPS1WKkgsUlszXT1VKkgsUls0XT0oVipXLVEqcSkqSCxSWzVdPShLKnEtVSpXKSpILFIpOm51bGx9ZnVuY3Rpb24gZihSKXtyZXR1cm4gUlswXSpSWzNdLVJbMV0qUlsyXX1mdW5jdGlvbiBnKFIsQSxVKXt2YXIgSz1BWzBdLFY9QVsxXSxRPUFbMl0scT1BWzNdLFc9QVs0XSxIPUFbNV0sWj1VWzBdLHR0PVVbMV0sXz1VWzJdLHN0PVVbM10saz1VWzRdLGN0PVVbNV07cmV0dXJuIFJbMF09SypaK1EqdHQsUlsxXT1WKlorcSp0dCxSWzJdPUsqXytRKnN0LFJbM109VipfK3Eqc3QsUls0XT1LKmsrUSpjdCtXLFJbNV09ViprK3EqY3QrSCxSfWZ1bmN0aW9uIHkoUixBLFUpe3ZhciBLPUFbMF0sVj1BWzFdLFE9QVsyXSxxPUFbM10sVz1BWzRdLEg9QVs1XSxaPU1hdGguc2luKFUpLHR0PU1hdGguY29zKFUpO3JldHVybiBSWzBdPUsqdHQrUSpaLFJbMV09Vip0dCtxKlosUlsyXT1LKi1aK1EqdHQsUlszXT1WKi1aK3EqdHQsUls0XT1XLFJbNV09SCxSfWZ1bmN0aW9uIEMoUixBLFUpe3ZhciBLPUFbMF0sVj1BWzFdLFE9QVsyXSxxPUFbM10sVz1BWzRdLEg9QVs1XSxaPVVbMF0sdHQ9VVsxXTtyZXR1cm4gUlswXT1LKlosUlsxXT1WKlosUlsyXT1RKnR0LFJbM109cSp0dCxSWzRdPVcsUls1XT1ILFJ9ZnVuY3Rpb24geChSLEEsVSl7dmFyIEs9QVswXSxWPUFbMV0sUT1BWzJdLHE9QVszXSxXPUFbNF0sSD1BWzVdLFo9VVswXSx0dD1VWzFdO3JldHVybiBSWzBdPUssUlsxXT1WLFJbMl09USxSWzNdPXEsUls0XT1LKlorUSp0dCtXLFJbNV09VipaK3EqdHQrSCxSfWZ1bmN0aW9uIGgoUixBKXt2YXIgVT1NYXRoLnNpbihBKSxLPU1hdGguY29zKEEpO3JldHVybiBSWzBdPUssUlsxXT1VLFJbMl09LVUsUlszXT1LLFJbNF09MCxSWzVdPTAsUn1mdW5jdGlvbiBtKFIsQSl7cmV0dXJuIFJbMF09QVswXSxSWzFdPTAsUlsyXT0wLFJbM109QVsxXSxSWzRdPTAsUls1XT0wLFJ9ZnVuY3Rpb24gcihSLEEpe3JldHVybiBSWzBdPTEsUlsxXT0wLFJbMl09MCxSWzNdPTEsUls0XT1BWzBdLFJbNV09QVsxXSxSfWZ1bmN0aW9uIGkoUil7cmV0dXJuIm1hdDJkKCIrUlswXSsiLCAiK1JbMV0rIiwgIitSWzJdKyIsICIrUlszXSsiLCAiK1JbNF0rIiwgIitSWzVdKyIpIn1mdW5jdGlvbiBuKFIpe3JldHVybiBNYXRoLmh5cG90KFJbMF0sUlsxXSxSWzJdLFJbM10sUls0XSxSWzVdLDEpfWZ1bmN0aW9uIHMoUixBLFUpe3JldHVybiBSWzBdPUFbMF0rVVswXSxSWzFdPUFbMV0rVVsxXSxSWzJdPUFbMl0rVVsyXSxSWzNdPUFbM10rVVszXSxSWzRdPUFbNF0rVVs0XSxSWzVdPUFbNV0rVVs1XSxSfWZ1bmN0aW9uIE0oUixBLFUpe3JldHVybiBSWzBdPUFbMF0tVVswXSxSWzFdPUFbMV0tVVsxXSxSWzJdPUFbMl0tVVsyXSxSWzNdPUFbM10tVVszXSxSWzRdPUFbNF0tVVs0XSxSWzVdPUFbNV0tVVs1XSxSfWZ1bmN0aW9uIFAoUixBLFUpe3JldHVybiBSWzBdPUFbMF0qVSxSWzFdPUFbMV0qVSxSWzJdPUFbMl0qVSxSWzNdPUFbM10qVSxSWzRdPUFbNF0qVSxSWzVdPUFbNV0qVSxSfWZ1bmN0aW9uIFMoUixBLFUsSyl7cmV0dXJuIFJbMF09QVswXStVWzBdKkssUlsxXT1BWzFdK1VbMV0qSyxSWzJdPUFbMl0rVVsyXSpLLFJbM109QVszXStVWzNdKkssUls0XT1BWzRdK1VbNF0qSyxSWzVdPUFbNV0rVVs1XSpLLFJ9ZnVuY3Rpb24gYihSLEEpe3JldHVybiBSWzBdPT09QVswXSYmUlsxXT09PUFbMV0mJlJbMl09PT1BWzJdJiZSWzNdPT09QVszXSYmUls0XT09PUFbNF0mJlJbNV09PT1BWzVdfWZ1bmN0aW9uIE8oUixBKXt2YXIgVT1SWzBdLEs9UlsxXSxWPVJbMl0sUT1SWzNdLHE9Uls0XSxXPVJbNV0sSD1BWzBdLFo9QVsxXSx0dD1BWzJdLF89QVszXSxzdD1BWzRdLGs9QVs1XTtyZXR1cm4gTWF0aC5hYnMoVS1IKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoSCkpJiZNYXRoLmFicyhLLVopPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKFYtdHQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhWKSxNYXRoLmFicyh0dCkpJiZNYXRoLmFicyhRLV8pPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhRKSxNYXRoLmFicyhfKSkmJk1hdGguYWJzKHEtc3QpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyhzdCkpJiZNYXRoLmFicyhXLWspPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhXKSxNYXRoLmFicyhrKSl9dmFyIEQ9ZyxJPU19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZnJvbU1hdDJkIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImZyb21RdWF0IixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm5vcm1hbEZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInByb2plY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFF9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBxfSk7dmFyIGE9dCgyKTtmdW5jdGlvbiBvKCl7dmFyIFc9bmV3IGEuQVJSQVlfVFlQRSg5KTtyZXR1cm4gYS5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihXWzFdPTAsV1syXT0wLFdbM109MCxXWzVdPTAsV1s2XT0wLFdbN109MCksV1swXT0xLFdbNF09MSxXWzhdPTEsV31mdW5jdGlvbiB2KFcsSCl7cmV0dXJuIFdbMF09SFswXSxXWzFdPUhbMV0sV1syXT1IWzJdLFdbM109SFs0XSxXWzRdPUhbNV0sV1s1XT1IWzZdLFdbNl09SFs4XSxXWzddPUhbOV0sV1s4XT1IWzEwXSxXfWZ1bmN0aW9uIFQoVyl7dmFyIEg9bmV3IGEuQVJSQVlfVFlQRSg5KTtyZXR1cm4gSFswXT1XWzBdLEhbMV09V1sxXSxIWzJdPVdbMl0sSFszXT1XWzNdLEhbNF09V1s0XSxIWzVdPVdbNV0sSFs2XT1XWzZdLEhbN109V1s3XSxIWzhdPVdbOF0sSH1mdW5jdGlvbiBkKFcsSCl7cmV0dXJuIFdbMF09SFswXSxXWzFdPUhbMV0sV1syXT1IWzJdLFdbM109SFszXSxXWzRdPUhbNF0sV1s1XT1IWzVdLFdbNl09SFs2XSxXWzddPUhbN10sV1s4XT1IWzhdLFd9ZnVuY3Rpb24gdShXLEgsWix0dCxfLHN0LGssY3QsZnQpe3ZhciBCPW5ldyBhLkFSUkFZX1RZUEUoOSk7cmV0dXJuIEJbMF09VyxCWzFdPUgsQlsyXT1aLEJbM109dHQsQls0XT1fLEJbNV09c3QsQls2XT1rLEJbN109Y3QsQls4XT1mdCxCfWZ1bmN0aW9uIGMoVyxILFosdHQsXyxzdCxrLGN0LGZ0LEIpe3JldHVybiBXWzBdPUgsV1sxXT1aLFdbMl09dHQsV1szXT1fLFdbNF09c3QsV1s1XT1rLFdbNl09Y3QsV1s3XT1mdCxXWzhdPUIsV31mdW5jdGlvbiBFKFcpe3JldHVybiBXWzBdPTEsV1sxXT0wLFdbMl09MCxXWzNdPTAsV1s0XT0xLFdbNV09MCxXWzZdPTAsV1s3XT0wLFdbOF09MSxXfWZ1bmN0aW9uIGYoVyxIKXtpZihXPT09SCl7dmFyIFo9SFsxXSx0dD1IWzJdLF89SFs1XTtXWzFdPUhbM10sV1syXT1IWzZdLFdbM109WixXWzVdPUhbN10sV1s2XT10dCxXWzddPV99ZWxzZSBXWzBdPUhbMF0sV1sxXT1IWzNdLFdbMl09SFs2XSxXWzNdPUhbMV0sV1s0XT1IWzRdLFdbNV09SFs3XSxXWzZdPUhbMl0sV1s3XT1IWzVdLFdbOF09SFs4XTtyZXR1cm4gV31mdW5jdGlvbiBnKFcsSCl7dmFyIFo9SFswXSx0dD1IWzFdLF89SFsyXSxzdD1IWzNdLGs9SFs0XSxjdD1IWzVdLGZ0PUhbNl0sQj1IWzddLEY9SFs4XSxZPUYqay1jdCpCLEo9LUYqc3QrY3QqZnQsaj1CKnN0LWsqZnQsRz1aKlkrdHQqSitfKmo7cmV0dXJuIEc/KEc9MS9HLFdbMF09WSpHLFdbMV09KC1GKnR0K18qQikqRyxXWzJdPShjdCp0dC1fKmspKkcsV1szXT1KKkcsV1s0XT0oRipaLV8qZnQpKkcsV1s1XT0oLWN0KlorXypzdCkqRyxXWzZdPWoqRyxXWzddPSgtQipaK3R0KmZ0KSpHLFdbOF09KGsqWi10dCpzdCkqRyxXKTpudWxsfWZ1bmN0aW9uIHkoVyxIKXt2YXIgWj1IWzBdLHR0PUhbMV0sXz1IWzJdLHN0PUhbM10saz1IWzRdLGN0PUhbNV0sZnQ9SFs2XSxCPUhbN10sRj1IWzhdO3JldHVybiBXWzBdPWsqRi1jdCpCLFdbMV09XypCLXR0KkYsV1syXT10dCpjdC1fKmssV1szXT1jdCpmdC1zdCpGLFdbNF09WipGLV8qZnQsV1s1XT1fKnN0LVoqY3QsV1s2XT1zdCpCLWsqZnQsV1s3XT10dCpmdC1aKkIsV1s4XT1aKmstdHQqc3QsV31mdW5jdGlvbiBDKFcpe3ZhciBIPVdbMF0sWj1XWzFdLHR0PVdbMl0sXz1XWzNdLHN0PVdbNF0saz1XWzVdLGN0PVdbNl0sZnQ9V1s3XSxCPVdbOF07cmV0dXJuIEgqKEIqc3QtaypmdCkrWiooLUIqXytrKmN0KSt0dCooZnQqXy1zdCpjdCl9ZnVuY3Rpb24geChXLEgsWil7dmFyIHR0PUhbMF0sXz1IWzFdLHN0PUhbMl0saz1IWzNdLGN0PUhbNF0sZnQ9SFs1XSxCPUhbNl0sRj1IWzddLFk9SFs4XSxKPVpbMF0saj1aWzFdLEc9WlsyXSxsPVpbM10scD1aWzRdLE49Wls1XSx6PVpbNl0sJD1aWzddLFg9Wls4XTtyZXR1cm4gV1swXT1KKnR0K2oqaytHKkIsV1sxXT1KKl8raipjdCtHKkYsV1syXT1KKnN0K2oqZnQrRypZLFdbM109bCp0dCtwKmsrTipCLFdbNF09bCpfK3AqY3QrTipGLFdbNV09bCpzdCtwKmZ0K04qWSxXWzZdPXoqdHQrJCprK1gqQixXWzddPXoqXyskKmN0K1gqRixXWzhdPXoqc3QrJCpmdCtYKlksV31mdW5jdGlvbiBoKFcsSCxaKXt2YXIgdHQ9SFswXSxfPUhbMV0sc3Q9SFsyXSxrPUhbM10sY3Q9SFs0XSxmdD1IWzVdLEI9SFs2XSxGPUhbN10sWT1IWzhdLEo9WlswXSxqPVpbMV07cmV0dXJuIFdbMF09dHQsV1sxXT1fLFdbMl09c3QsV1szXT1rLFdbNF09Y3QsV1s1XT1mdCxXWzZdPUoqdHQraiprK0IsV1s3XT1KKl8raipjdCtGLFdbOF09SipzdCtqKmZ0K1ksV31mdW5jdGlvbiBtKFcsSCxaKXt2YXIgdHQ9SFswXSxfPUhbMV0sc3Q9SFsyXSxrPUhbM10sY3Q9SFs0XSxmdD1IWzVdLEI9SFs2XSxGPUhbN10sWT1IWzhdLEo9TWF0aC5zaW4oWiksaj1NYXRoLmNvcyhaKTtyZXR1cm4gV1swXT1qKnR0K0oqayxXWzFdPWoqXytKKmN0LFdbMl09aipzdCtKKmZ0LFdbM109aiprLUoqdHQsV1s0XT1qKmN0LUoqXyxXWzVdPWoqZnQtSipzdCxXWzZdPUIsV1s3XT1GLFdbOF09WSxXfWZ1bmN0aW9uIHIoVyxILFope3ZhciB0dD1aWzBdLF89WlsxXTtyZXR1cm4gV1swXT10dCpIWzBdLFdbMV09dHQqSFsxXSxXWzJdPXR0KkhbMl0sV1szXT1fKkhbM10sV1s0XT1fKkhbNF0sV1s1XT1fKkhbNV0sV1s2XT1IWzZdLFdbN109SFs3XSxXWzhdPUhbOF0sV31mdW5jdGlvbiBpKFcsSCl7cmV0dXJuIFdbMF09MSxXWzFdPTAsV1syXT0wLFdbM109MCxXWzRdPTEsV1s1XT0wLFdbNl09SFswXSxXWzddPUhbMV0sV1s4XT0xLFd9ZnVuY3Rpb24gbihXLEgpe3ZhciBaPU1hdGguc2luKEgpLHR0PU1hdGguY29zKEgpO3JldHVybiBXWzBdPXR0LFdbMV09WixXWzJdPTAsV1szXT0tWixXWzRdPXR0LFdbNV09MCxXWzZdPTAsV1s3XT0wLFdbOF09MSxXfWZ1bmN0aW9uIHMoVyxIKXtyZXR1cm4gV1swXT1IWzBdLFdbMV09MCxXWzJdPTAsV1szXT0wLFdbNF09SFsxXSxXWzVdPTAsV1s2XT0wLFdbN109MCxXWzhdPTEsV31mdW5jdGlvbiBNKFcsSCl7cmV0dXJuIFdbMF09SFswXSxXWzFdPUhbMV0sV1syXT0wLFdbM109SFsyXSxXWzRdPUhbM10sV1s1XT0wLFdbNl09SFs0XSxXWzddPUhbNV0sV1s4XT0xLFd9ZnVuY3Rpb24gUChXLEgpe3ZhciBaPUhbMF0sdHQ9SFsxXSxfPUhbMl0sc3Q9SFszXSxrPVorWixjdD10dCt0dCxmdD1fK18sQj1aKmssRj10dCprLFk9dHQqY3QsSj1fKmssaj1fKmN0LEc9XypmdCxsPXN0KmsscD1zdCpjdCxOPXN0KmZ0O3JldHVybiBXWzBdPTEtWS1HLFdbM109Ri1OLFdbNl09SitwLFdbMV09RitOLFdbNF09MS1CLUcsV1s3XT1qLWwsV1syXT1KLXAsV1s1XT1qK2wsV1s4XT0xLUItWSxXfWZ1bmN0aW9uIFMoVyxIKXt2YXIgWj1IWzBdLHR0PUhbMV0sXz1IWzJdLHN0PUhbM10saz1IWzRdLGN0PUhbNV0sZnQ9SFs2XSxCPUhbN10sRj1IWzhdLFk9SFs5XSxKPUhbMTBdLGo9SFsxMV0sRz1IWzEyXSxsPUhbMTNdLHA9SFsxNF0sTj1IWzE1XSx6PVoqY3QtdHQqaywkPVoqZnQtXyprLFg9WipCLXN0Kmssdz10dCpmdC1fKmN0LGV0PXR0KkItc3QqY3QscnQ9XypCLXN0KmZ0LGF0PUYqbC1ZKkcsbHQ9RipwLUoqRyxpdD1GKk4taipHLG50PVkqcC1KKmwsb3Q9WSpOLWoqbCxodD1KKk4taipwLGR0PXoqaHQtJCpvdCtYKm50K3cqaXQtZXQqbHQrcnQqYXQ7cmV0dXJuIGR0PyhkdD0xL2R0LFdbMF09KGN0Kmh0LWZ0Km90K0IqbnQpKmR0LFdbMV09KGZ0Kml0LWsqaHQtQipsdCkqZHQsV1syXT0oaypvdC1jdCppdCtCKmF0KSpkdCxXWzNdPShfKm90LXR0Kmh0LXN0Km50KSpkdCxXWzRdPShaKmh0LV8qaXQrc3QqbHQpKmR0LFdbNV09KHR0Kml0LVoqb3Qtc3QqYXQpKmR0LFdbNl09KGwqcnQtcCpldCtOKncpKmR0LFdbN109KHAqWC1HKnJ0LU4qJCkqZHQsV1s4XT0oRypldC1sKlgrTip6KSpkdCxXKTpudWxsfWZ1bmN0aW9uIGIoVyxILFope3JldHVybiBXWzBdPTIvSCxXWzFdPTAsV1syXT0wLFdbM109MCxXWzRdPS0yL1osV1s1XT0wLFdbNl09LTEsV1s3XT0xLFdbOF09MSxXfWZ1bmN0aW9uIE8oVyl7cmV0dXJuIm1hdDMoIitXWzBdKyIsICIrV1sxXSsiLCAiK1dbMl0rIiwgIitXWzNdKyIsICIrV1s0XSsiLCAiK1dbNV0rIiwgIitXWzZdKyIsICIrV1s3XSsiLCAiK1dbOF0rIikifWZ1bmN0aW9uIEQoVyl7cmV0dXJuIE1hdGguaHlwb3QoV1swXSxXWzFdLFdbMl0sV1szXSxXWzRdLFdbNV0sV1s2XSxXWzddLFdbOF0pfWZ1bmN0aW9uIEkoVyxILFope3JldHVybiBXWzBdPUhbMF0rWlswXSxXWzFdPUhbMV0rWlsxXSxXWzJdPUhbMl0rWlsyXSxXWzNdPUhbM10rWlszXSxXWzRdPUhbNF0rWls0XSxXWzVdPUhbNV0rWls1XSxXWzZdPUhbNl0rWls2XSxXWzddPUhbN10rWls3XSxXWzhdPUhbOF0rWls4XSxXfWZ1bmN0aW9uIFIoVyxILFope3JldHVybiBXWzBdPUhbMF0tWlswXSxXWzFdPUhbMV0tWlsxXSxXWzJdPUhbMl0tWlsyXSxXWzNdPUhbM10tWlszXSxXWzRdPUhbNF0tWls0XSxXWzVdPUhbNV0tWls1XSxXWzZdPUhbNl0tWls2XSxXWzddPUhbN10tWls3XSxXWzhdPUhbOF0tWls4XSxXfWZ1bmN0aW9uIEEoVyxILFope3JldHVybiBXWzBdPUhbMF0qWixXWzFdPUhbMV0qWixXWzJdPUhbMl0qWixXWzNdPUhbM10qWixXWzRdPUhbNF0qWixXWzVdPUhbNV0qWixXWzZdPUhbNl0qWixXWzddPUhbN10qWixXWzhdPUhbOF0qWixXfWZ1bmN0aW9uIFUoVyxILFosdHQpe3JldHVybiBXWzBdPUhbMF0rWlswXSp0dCxXWzFdPUhbMV0rWlsxXSp0dCxXWzJdPUhbMl0rWlsyXSp0dCxXWzNdPUhbM10rWlszXSp0dCxXWzRdPUhbNF0rWls0XSp0dCxXWzVdPUhbNV0rWls1XSp0dCxXWzZdPUhbNl0rWls2XSp0dCxXWzddPUhbN10rWls3XSp0dCxXWzhdPUhbOF0rWls4XSp0dCxXfWZ1bmN0aW9uIEsoVyxIKXtyZXR1cm4gV1swXT09PUhbMF0mJldbMV09PT1IWzFdJiZXWzJdPT09SFsyXSYmV1szXT09PUhbM10mJldbNF09PT1IWzRdJiZXWzVdPT09SFs1XSYmV1s2XT09PUhbNl0mJldbN109PT1IWzddJiZXWzhdPT09SFs4XX1mdW5jdGlvbiBWKFcsSCl7dmFyIFo9V1swXSx0dD1XWzFdLF89V1syXSxzdD1XWzNdLGs9V1s0XSxjdD1XWzVdLGZ0PVdbNl0sQj1XWzddLEY9V1s4XSxZPUhbMF0sSj1IWzFdLGo9SFsyXSxHPUhbM10sbD1IWzRdLHA9SFs1XSxOPUhbNl0sej1IWzddLCQ9SFs4XTtyZXR1cm4gTWF0aC5hYnMoWi1ZKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWiksTWF0aC5hYnMoWSkpJiZNYXRoLmFicyh0dC1KKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModHQpLE1hdGguYWJzKEopKSYmTWF0aC5hYnMoXy1qKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMoaikpJiZNYXRoLmFicyhzdC1HKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoc3QpLE1hdGguYWJzKEcpKSYmTWF0aC5hYnMoay1sKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoayksTWF0aC5hYnMobCkpJiZNYXRoLmFicyhjdC1wKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoY3QpLE1hdGguYWJzKHApKSYmTWF0aC5hYnMoZnQtTik8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGZ0KSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKEIteik8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEIpLE1hdGguYWJzKHopKSYmTWF0aC5hYnMoRi0kKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoRiksTWF0aC5hYnMoJCkpfXZhciBRPXgscT1SfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImZyb21YUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZnJvbVlSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJmcm9tWlJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImZyb21RdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJnZXRTY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImdldFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJmcnVzdHVtIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInBlcnNwZWN0aXZlIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3IixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsIm9ydGhvIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImxvb2tBdCIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwidGFyZ2V0VG8iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBZfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGp9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBHfSk7dmFyIGE9dCgyKTtmdW5jdGlvbiBvKCl7dmFyIGw9bmV3IGEuQVJSQVlfVFlQRSgxNik7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYobFsxXT0wLGxbMl09MCxsWzNdPTAsbFs0XT0wLGxbNl09MCxsWzddPTAsbFs4XT0wLGxbOV09MCxsWzExXT0wLGxbMTJdPTAsbFsxM109MCxsWzE0XT0wKSxsWzBdPTEsbFs1XT0xLGxbMTBdPTEsbFsxNV09MSxsfWZ1bmN0aW9uIHYobCl7dmFyIHA9bmV3IGEuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHBbMF09bFswXSxwWzFdPWxbMV0scFsyXT1sWzJdLHBbM109bFszXSxwWzRdPWxbNF0scFs1XT1sWzVdLHBbNl09bFs2XSxwWzddPWxbN10scFs4XT1sWzhdLHBbOV09bFs5XSxwWzEwXT1sWzEwXSxwWzExXT1sWzExXSxwWzEyXT1sWzEyXSxwWzEzXT1sWzEzXSxwWzE0XT1sWzE0XSxwWzE1XT1sWzE1XSxwfWZ1bmN0aW9uIFQobCxwKXtyZXR1cm4gbFswXT1wWzBdLGxbMV09cFsxXSxsWzJdPXBbMl0sbFszXT1wWzNdLGxbNF09cFs0XSxsWzVdPXBbNV0sbFs2XT1wWzZdLGxbN109cFs3XSxsWzhdPXBbOF0sbFs5XT1wWzldLGxbMTBdPXBbMTBdLGxbMTFdPXBbMTFdLGxbMTJdPXBbMTJdLGxbMTNdPXBbMTNdLGxbMTRdPXBbMTRdLGxbMTVdPXBbMTVdLGx9ZnVuY3Rpb24gZChsLHAsTix6LCQsWCx3LGV0LHJ0LGF0LGx0LGl0LG50LG90LGh0LGR0KXt2YXIgdXQ9bmV3IGEuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHV0WzBdPWwsdXRbMV09cCx1dFsyXT1OLHV0WzNdPXosdXRbNF09JCx1dFs1XT1YLHV0WzZdPXcsdXRbN109ZXQsdXRbOF09cnQsdXRbOV09YXQsdXRbMTBdPWx0LHV0WzExXT1pdCx1dFsxMl09bnQsdXRbMTNdPW90LHV0WzE0XT1odCx1dFsxNV09ZHQsdXR9ZnVuY3Rpb24gdShsLHAsTix6LCQsWCx3LGV0LHJ0LGF0LGx0LGl0LG50LG90LGh0LGR0LHV0KXtyZXR1cm4gbFswXT1wLGxbMV09TixsWzJdPXosbFszXT0kLGxbNF09WCxsWzVdPXcsbFs2XT1ldCxsWzddPXJ0LGxbOF09YXQsbFs5XT1sdCxsWzEwXT1pdCxsWzExXT1udCxsWzEyXT1vdCxsWzEzXT1odCxsWzE0XT1kdCxsWzE1XT11dCxsfWZ1bmN0aW9uIGMobCl7cmV0dXJuIGxbMF09MSxsWzFdPTAsbFsyXT0wLGxbM109MCxsWzRdPTAsbFs1XT0xLGxbNl09MCxsWzddPTAsbFs4XT0wLGxbOV09MCxsWzEwXT0xLGxbMTFdPTAsbFsxMl09MCxsWzEzXT0wLGxbMTRdPTAsbFsxNV09MSxsfWZ1bmN0aW9uIEUobCxwKXtpZihsPT09cCl7dmFyIE49cFsxXSx6PXBbMl0sJD1wWzNdLFg9cFs2XSx3PXBbN10sZXQ9cFsxMV07bFsxXT1wWzRdLGxbMl09cFs4XSxsWzNdPXBbMTJdLGxbNF09TixsWzZdPXBbOV0sbFs3XT1wWzEzXSxsWzhdPXosbFs5XT1YLGxbMTFdPXBbMTRdLGxbMTJdPSQsbFsxM109dyxsWzE0XT1ldH1lbHNlIGxbMF09cFswXSxsWzFdPXBbNF0sbFsyXT1wWzhdLGxbM109cFsxMl0sbFs0XT1wWzFdLGxbNV09cFs1XSxsWzZdPXBbOV0sbFs3XT1wWzEzXSxsWzhdPXBbMl0sbFs5XT1wWzZdLGxbMTBdPXBbMTBdLGxbMTFdPXBbMTRdLGxbMTJdPXBbM10sbFsxM109cFs3XSxsWzE0XT1wWzExXSxsWzE1XT1wWzE1XTtyZXR1cm4gbH1mdW5jdGlvbiBmKGwscCl7dmFyIE49cFswXSx6PXBbMV0sJD1wWzJdLFg9cFszXSx3PXBbNF0sZXQ9cFs1XSxydD1wWzZdLGF0PXBbN10sbHQ9cFs4XSxpdD1wWzldLG50PXBbMTBdLG90PXBbMTFdLGh0PXBbMTJdLGR0PXBbMTNdLHV0PXBbMTRdLG10PXBbMTVdLE10PU4qZXQteip3LHZ0PU4qcnQtJCp3LHl0PU4qYXQtWCp3LHB0PXoqcnQtJCpldCx4dD16KmF0LVgqZXQsTHQ9JCphdC1YKnJ0LFN0PWx0KmR0LWl0Kmh0LEN0PWx0KnV0LW50Kmh0LER0PWx0Km10LW90Kmh0LGJ0PWl0KnV0LW50KmR0LEl0PWl0Km10LW90KmR0LE50PW50Km10LW90KnV0LEV0PU10Kk50LXZ0Kkl0K3l0KmJ0K3B0KkR0LXh0KkN0K0x0KlN0O3JldHVybiBFdD8oRXQ9MS9FdCxsWzBdPShldCpOdC1ydCpJdCthdCpidCkqRXQsbFsxXT0oJCpJdC16Kk50LVgqYnQpKkV0LGxbMl09KGR0Kkx0LXV0Knh0K210KnB0KSpFdCxsWzNdPShudCp4dC1pdCpMdC1vdCpwdCkqRXQsbFs0XT0ocnQqRHQtdypOdC1hdCpDdCkqRXQsbFs1XT0oTipOdC0kKkR0K1gqQ3QpKkV0LGxbNl09KHV0Knl0LWh0Kkx0LW10KnZ0KSpFdCxsWzddPShsdCpMdC1udCp5dCtvdCp2dCkqRXQsbFs4XT0odypJdC1ldCpEdCthdCpTdCkqRXQsbFs5XT0oeipEdC1OKkl0LVgqU3QpKkV0LGxbMTBdPShodCp4dC1kdCp5dCttdCpNdCkqRXQsbFsxMV09KGl0Knl0LWx0Knh0LW90Kk10KSpFdCxsWzEyXT0oZXQqQ3QtdypidC1ydCpTdCkqRXQsbFsxM109KE4qYnQteipDdCskKlN0KSpFdCxsWzE0XT0oZHQqdnQtaHQqcHQtdXQqTXQpKkV0LGxbMTVdPShsdCpwdC1pdCp2dCtudCpNdCkqRXQsbCk6bnVsbH1mdW5jdGlvbiBnKGwscCl7dmFyIE49cFswXSx6PXBbMV0sJD1wWzJdLFg9cFszXSx3PXBbNF0sZXQ9cFs1XSxydD1wWzZdLGF0PXBbN10sbHQ9cFs4XSxpdD1wWzldLG50PXBbMTBdLG90PXBbMTFdLGh0PXBbMTJdLGR0PXBbMTNdLHV0PXBbMTRdLG10PXBbMTVdO3JldHVybiBsWzBdPWV0KihudCptdC1vdCp1dCktaXQqKHJ0Km10LWF0KnV0KStkdCoocnQqb3QtYXQqbnQpLGxbMV09LSh6KihudCptdC1vdCp1dCktaXQqKCQqbXQtWCp1dCkrZHQqKCQqb3QtWCpudCkpLGxbMl09eioocnQqbXQtYXQqdXQpLWV0KigkKm10LVgqdXQpK2R0KigkKmF0LVgqcnQpLGxbM109LSh6KihydCpvdC1hdCpudCktZXQqKCQqb3QtWCpudCkraXQqKCQqYXQtWCpydCkpLGxbNF09LSh3KihudCptdC1vdCp1dCktbHQqKHJ0Km10LWF0KnV0KStodCoocnQqb3QtYXQqbnQpKSxsWzVdPU4qKG50Km10LW90KnV0KS1sdCooJCptdC1YKnV0KStodCooJCpvdC1YKm50KSxsWzZdPS0oTioocnQqbXQtYXQqdXQpLXcqKCQqbXQtWCp1dCkraHQqKCQqYXQtWCpydCkpLGxbN109TioocnQqb3QtYXQqbnQpLXcqKCQqb3QtWCpudCkrbHQqKCQqYXQtWCpydCksbFs4XT13KihpdCptdC1vdCpkdCktbHQqKGV0Km10LWF0KmR0KStodCooZXQqb3QtYXQqaXQpLGxbOV09LShOKihpdCptdC1vdCpkdCktbHQqKHoqbXQtWCpkdCkraHQqKHoqb3QtWCppdCkpLGxbMTBdPU4qKGV0Km10LWF0KmR0KS13Kih6Km10LVgqZHQpK2h0Kih6KmF0LVgqZXQpLGxbMTFdPS0oTiooZXQqb3QtYXQqaXQpLXcqKHoqb3QtWCppdCkrbHQqKHoqYXQtWCpldCkpLGxbMTJdPS0odyooaXQqdXQtbnQqZHQpLWx0KihldCp1dC1ydCpkdCkraHQqKGV0Km50LXJ0Kml0KSksbFsxM109TiooaXQqdXQtbnQqZHQpLWx0Kih6KnV0LSQqZHQpK2h0Kih6Km50LSQqaXQpLGxbMTRdPS0oTiooZXQqdXQtcnQqZHQpLXcqKHoqdXQtJCpkdCkraHQqKHoqcnQtJCpldCkpLGxbMTVdPU4qKGV0Km50LXJ0Kml0KS13Kih6Km50LSQqaXQpK2x0Kih6KnJ0LSQqZXQpLGx9ZnVuY3Rpb24geShsKXt2YXIgcD1sWzBdLE49bFsxXSx6PWxbMl0sJD1sWzNdLFg9bFs0XSx3PWxbNV0sZXQ9bFs2XSxydD1sWzddLGF0PWxbOF0sbHQ9bFs5XSxpdD1sWzEwXSxudD1sWzExXSxvdD1sWzEyXSxodD1sWzEzXSxkdD1sWzE0XSx1dD1sWzE1XSxtdD1wKnctTipYLE10PXAqZXQteipYLHZ0PXAqcnQtJCpYLHl0PU4qZXQteip3LHB0PU4qcnQtJCp3LHh0PXoqcnQtJCpldCxMdD1hdCpodC1sdCpvdCxTdD1hdCpkdC1pdCpvdCxDdD1hdCp1dC1udCpvdCxEdD1sdCpkdC1pdCpodCxidD1sdCp1dC1udCpodCxJdD1pdCp1dC1udCpkdDtyZXR1cm4gbXQqSXQtTXQqYnQrdnQqRHQreXQqQ3QtcHQqU3QreHQqTHR9ZnVuY3Rpb24gQyhsLHAsTil7dmFyIHo9cFswXSwkPXBbMV0sWD1wWzJdLHc9cFszXSxldD1wWzRdLHJ0PXBbNV0sYXQ9cFs2XSxsdD1wWzddLGl0PXBbOF0sbnQ9cFs5XSxvdD1wWzEwXSxodD1wWzExXSxkdD1wWzEyXSx1dD1wWzEzXSxtdD1wWzE0XSxNdD1wWzE1XSx2dD1OWzBdLHl0PU5bMV0scHQ9TlsyXSx4dD1OWzNdO3JldHVybiBsWzBdPXZ0KnoreXQqZXQrcHQqaXQreHQqZHQsbFsxXT12dCokK3l0KnJ0K3B0Km50K3h0KnV0LGxbMl09dnQqWCt5dCphdCtwdCpvdCt4dCptdCxsWzNdPXZ0KncreXQqbHQrcHQqaHQreHQqTXQsdnQ9Tls0XSx5dD1OWzVdLHB0PU5bNl0seHQ9Tls3XSxsWzRdPXZ0KnoreXQqZXQrcHQqaXQreHQqZHQsbFs1XT12dCokK3l0KnJ0K3B0Km50K3h0KnV0LGxbNl09dnQqWCt5dCphdCtwdCpvdCt4dCptdCxsWzddPXZ0KncreXQqbHQrcHQqaHQreHQqTXQsdnQ9Tls4XSx5dD1OWzldLHB0PU5bMTBdLHh0PU5bMTFdLGxbOF09dnQqeit5dCpldCtwdCppdCt4dCpkdCxsWzldPXZ0KiQreXQqcnQrcHQqbnQreHQqdXQsbFsxMF09dnQqWCt5dCphdCtwdCpvdCt4dCptdCxsWzExXT12dCp3K3l0Kmx0K3B0Kmh0K3h0Kk10LHZ0PU5bMTJdLHl0PU5bMTNdLHB0PU5bMTRdLHh0PU5bMTVdLGxbMTJdPXZ0KnoreXQqZXQrcHQqaXQreHQqZHQsbFsxM109dnQqJCt5dCpydCtwdCpudCt4dCp1dCxsWzE0XT12dCpYK3l0KmF0K3B0Km90K3h0Km10LGxbMTVdPXZ0KncreXQqbHQrcHQqaHQreHQqTXQsbH1mdW5jdGlvbiB4KGwscCxOKXt2YXIgej1OWzBdLCQ9TlsxXSxYPU5bMl0sdyxldCxydCxhdCxsdCxpdCxudCxvdCxodCxkdCx1dCxtdDtyZXR1cm4gcD09PWw/KGxbMTJdPXBbMF0qeitwWzRdKiQrcFs4XSpYK3BbMTJdLGxbMTNdPXBbMV0qeitwWzVdKiQrcFs5XSpYK3BbMTNdLGxbMTRdPXBbMl0qeitwWzZdKiQrcFsxMF0qWCtwWzE0XSxsWzE1XT1wWzNdKnorcFs3XSokK3BbMTFdKlgrcFsxNV0pOih3PXBbMF0sZXQ9cFsxXSxydD1wWzJdLGF0PXBbM10sbHQ9cFs0XSxpdD1wWzVdLG50PXBbNl0sb3Q9cFs3XSxodD1wWzhdLGR0PXBbOV0sdXQ9cFsxMF0sbXQ9cFsxMV0sbFswXT13LGxbMV09ZXQsbFsyXT1ydCxsWzNdPWF0LGxbNF09bHQsbFs1XT1pdCxsWzZdPW50LGxbN109b3QsbFs4XT1odCxsWzldPWR0LGxbMTBdPXV0LGxbMTFdPW10LGxbMTJdPXcqeitsdCokK2h0KlgrcFsxMl0sbFsxM109ZXQqeitpdCokK2R0KlgrcFsxM10sbFsxNF09cnQqeitudCokK3V0KlgrcFsxNF0sbFsxNV09YXQqeitvdCokK210KlgrcFsxNV0pLGx9ZnVuY3Rpb24gaChsLHAsTil7dmFyIHo9TlswXSwkPU5bMV0sWD1OWzJdO3JldHVybiBsWzBdPXBbMF0qeixsWzFdPXBbMV0qeixsWzJdPXBbMl0qeixsWzNdPXBbM10qeixsWzRdPXBbNF0qJCxsWzVdPXBbNV0qJCxsWzZdPXBbNl0qJCxsWzddPXBbN10qJCxsWzhdPXBbOF0qWCxsWzldPXBbOV0qWCxsWzEwXT1wWzEwXSpYLGxbMTFdPXBbMTFdKlgsbFsxMl09cFsxMl0sbFsxM109cFsxM10sbFsxNF09cFsxNF0sbFsxNV09cFsxNV0sbH1mdW5jdGlvbiBtKGwscCxOLHope3ZhciAkPXpbMF0sWD16WzFdLHc9elsyXSxldD1NYXRoLmh5cG90KCQsWCx3KSxydCxhdCxsdCxpdCxudCxvdCxodCxkdCx1dCxtdCxNdCx2dCx5dCxwdCx4dCxMdCxTdCxDdCxEdCxidCxJdCxOdCxFdCxGdDtyZXR1cm4gZXQ8YS5FUFNJTE9OP251bGw6KGV0PTEvZXQsJCo9ZXQsWCo9ZXQsdyo9ZXQscnQ9TWF0aC5zaW4oTiksYXQ9TWF0aC5jb3MoTiksbHQ9MS1hdCxpdD1wWzBdLG50PXBbMV0sb3Q9cFsyXSxodD1wWzNdLGR0PXBbNF0sdXQ9cFs1XSxtdD1wWzZdLE10PXBbN10sdnQ9cFs4XSx5dD1wWzldLHB0PXBbMTBdLHh0PXBbMTFdLEx0PSQqJCpsdCthdCxTdD1YKiQqbHQrdypydCxDdD13KiQqbHQtWCpydCxEdD0kKlgqbHQtdypydCxidD1YKlgqbHQrYXQsSXQ9dypYKmx0KyQqcnQsTnQ9JCp3Kmx0K1gqcnQsRXQ9WCp3Kmx0LSQqcnQsRnQ9dyp3Kmx0K2F0LGxbMF09aXQqTHQrZHQqU3QrdnQqQ3QsbFsxXT1udCpMdCt1dCpTdCt5dCpDdCxsWzJdPW90Kkx0K210KlN0K3B0KkN0LGxbM109aHQqTHQrTXQqU3QreHQqQ3QsbFs0XT1pdCpEdCtkdCpidCt2dCpJdCxsWzVdPW50KkR0K3V0KmJ0K3l0Kkl0LGxbNl09b3QqRHQrbXQqYnQrcHQqSXQsbFs3XT1odCpEdCtNdCpidCt4dCpJdCxsWzhdPWl0Kk50K2R0KkV0K3Z0KkZ0LGxbOV09bnQqTnQrdXQqRXQreXQqRnQsbFsxMF09b3QqTnQrbXQqRXQrcHQqRnQsbFsxMV09aHQqTnQrTXQqRXQreHQqRnQscCE9PWwmJihsWzEyXT1wWzEyXSxsWzEzXT1wWzEzXSxsWzE0XT1wWzE0XSxsWzE1XT1wWzE1XSksbCl9ZnVuY3Rpb24gcihsLHAsTil7dmFyIHo9TWF0aC5zaW4oTiksJD1NYXRoLmNvcyhOKSxYPXBbNF0sdz1wWzVdLGV0PXBbNl0scnQ9cFs3XSxhdD1wWzhdLGx0PXBbOV0saXQ9cFsxMF0sbnQ9cFsxMV07cmV0dXJuIHAhPT1sJiYobFswXT1wWzBdLGxbMV09cFsxXSxsWzJdPXBbMl0sbFszXT1wWzNdLGxbMTJdPXBbMTJdLGxbMTNdPXBbMTNdLGxbMTRdPXBbMTRdLGxbMTVdPXBbMTVdKSxsWzRdPVgqJCthdCp6LGxbNV09dyokK2x0KnosbFs2XT1ldCokK2l0KnosbFs3XT1ydCokK250KnosbFs4XT1hdCokLVgqeixsWzldPWx0KiQtdyp6LGxbMTBdPWl0KiQtZXQqeixsWzExXT1udCokLXJ0KnosbH1mdW5jdGlvbiBpKGwscCxOKXt2YXIgej1NYXRoLnNpbihOKSwkPU1hdGguY29zKE4pLFg9cFswXSx3PXBbMV0sZXQ9cFsyXSxydD1wWzNdLGF0PXBbOF0sbHQ9cFs5XSxpdD1wWzEwXSxudD1wWzExXTtyZXR1cm4gcCE9PWwmJihsWzRdPXBbNF0sbFs1XT1wWzVdLGxbNl09cFs2XSxsWzddPXBbN10sbFsxMl09cFsxMl0sbFsxM109cFsxM10sbFsxNF09cFsxNF0sbFsxNV09cFsxNV0pLGxbMF09WCokLWF0KnosbFsxXT13KiQtbHQqeixsWzJdPWV0KiQtaXQqeixsWzNdPXJ0KiQtbnQqeixsWzhdPVgqeithdCokLGxbOV09dyp6K2x0KiQsbFsxMF09ZXQqeitpdCokLGxbMTFdPXJ0KnorbnQqJCxsfWZ1bmN0aW9uIG4obCxwLE4pe3ZhciB6PU1hdGguc2luKE4pLCQ9TWF0aC5jb3MoTiksWD1wWzBdLHc9cFsxXSxldD1wWzJdLHJ0PXBbM10sYXQ9cFs0XSxsdD1wWzVdLGl0PXBbNl0sbnQ9cFs3XTtyZXR1cm4gcCE9PWwmJihsWzhdPXBbOF0sbFs5XT1wWzldLGxbMTBdPXBbMTBdLGxbMTFdPXBbMTFdLGxbMTJdPXBbMTJdLGxbMTNdPXBbMTNdLGxbMTRdPXBbMTRdLGxbMTVdPXBbMTVdKSxsWzBdPVgqJCthdCp6LGxbMV09dyokK2x0KnosbFsyXT1ldCokK2l0KnosbFszXT1ydCokK250KnosbFs0XT1hdCokLVgqeixsWzVdPWx0KiQtdyp6LGxbNl09aXQqJC1ldCp6LGxbN109bnQqJC1ydCp6LGx9ZnVuY3Rpb24gcyhsLHApe3JldHVybiBsWzBdPTEsbFsxXT0wLGxbMl09MCxsWzNdPTAsbFs0XT0wLGxbNV09MSxsWzZdPTAsbFs3XT0wLGxbOF09MCxsWzldPTAsbFsxMF09MSxsWzExXT0wLGxbMTJdPXBbMF0sbFsxM109cFsxXSxsWzE0XT1wWzJdLGxbMTVdPTEsbH1mdW5jdGlvbiBNKGwscCl7cmV0dXJuIGxbMF09cFswXSxsWzFdPTAsbFsyXT0wLGxbM109MCxsWzRdPTAsbFs1XT1wWzFdLGxbNl09MCxsWzddPTAsbFs4XT0wLGxbOV09MCxsWzEwXT1wWzJdLGxbMTFdPTAsbFsxMl09MCxsWzEzXT0wLGxbMTRdPTAsbFsxNV09MSxsfWZ1bmN0aW9uIFAobCxwLE4pe3ZhciB6PU5bMF0sJD1OWzFdLFg9TlsyXSx3PU1hdGguaHlwb3QoeiwkLFgpLGV0LHJ0LGF0O3JldHVybiB3PGEuRVBTSUxPTj9udWxsOih3PTEvdyx6Kj13LCQqPXcsWCo9dyxldD1NYXRoLnNpbihwKSxydD1NYXRoLmNvcyhwKSxhdD0xLXJ0LGxbMF09eip6KmF0K3J0LGxbMV09JCp6KmF0K1gqZXQsbFsyXT1YKnoqYXQtJCpldCxsWzNdPTAsbFs0XT16KiQqYXQtWCpldCxsWzVdPSQqJCphdCtydCxsWzZdPVgqJCphdCt6KmV0LGxbN109MCxsWzhdPXoqWCphdCskKmV0LGxbOV09JCpYKmF0LXoqZXQsbFsxMF09WCpYKmF0K3J0LGxbMTFdPTAsbFsxMl09MCxsWzEzXT0wLGxbMTRdPTAsbFsxNV09MSxsKX1mdW5jdGlvbiBTKGwscCl7dmFyIE49TWF0aC5zaW4ocCksej1NYXRoLmNvcyhwKTtyZXR1cm4gbFswXT0xLGxbMV09MCxsWzJdPTAsbFszXT0wLGxbNF09MCxsWzVdPXosbFs2XT1OLGxbN109MCxsWzhdPTAsbFs5XT0tTixsWzEwXT16LGxbMTFdPTAsbFsxMl09MCxsWzEzXT0wLGxbMTRdPTAsbFsxNV09MSxsfWZ1bmN0aW9uIGIobCxwKXt2YXIgTj1NYXRoLnNpbihwKSx6PU1hdGguY29zKHApO3JldHVybiBsWzBdPXosbFsxXT0wLGxbMl09LU4sbFszXT0wLGxbNF09MCxsWzVdPTEsbFs2XT0wLGxbN109MCxsWzhdPU4sbFs5XT0wLGxbMTBdPXosbFsxMV09MCxsWzEyXT0wLGxbMTNdPTAsbFsxNF09MCxsWzE1XT0xLGx9ZnVuY3Rpb24gTyhsLHApe3ZhciBOPU1hdGguc2luKHApLHo9TWF0aC5jb3MocCk7cmV0dXJuIGxbMF09eixsWzFdPU4sbFsyXT0wLGxbM109MCxsWzRdPS1OLGxbNV09eixsWzZdPTAsbFs3XT0wLGxbOF09MCxsWzldPTAsbFsxMF09MSxsWzExXT0wLGxbMTJdPTAsbFsxM109MCxsWzE0XT0wLGxbMTVdPTEsbH1mdW5jdGlvbiBEKGwscCxOKXt2YXIgej1wWzBdLCQ9cFsxXSxYPXBbMl0sdz1wWzNdLGV0PXoreixydD0kKyQsYXQ9WCtYLGx0PXoqZXQsaXQ9eipydCxudD16KmF0LG90PSQqcnQsaHQ9JCphdCxkdD1YKmF0LHV0PXcqZXQsbXQ9dypydCxNdD13KmF0O3JldHVybiBsWzBdPTEtKG90K2R0KSxsWzFdPWl0K010LGxbMl09bnQtbXQsbFszXT0wLGxbNF09aXQtTXQsbFs1XT0xLShsdCtkdCksbFs2XT1odCt1dCxsWzddPTAsbFs4XT1udCttdCxsWzldPWh0LXV0LGxbMTBdPTEtKGx0K290KSxsWzExXT0wLGxbMTJdPU5bMF0sbFsxM109TlsxXSxsWzE0XT1OWzJdLGxbMTVdPTEsbH1mdW5jdGlvbiBJKGwscCl7dmFyIE49bmV3IGEuQVJSQVlfVFlQRSgzKSx6PS1wWzBdLCQ9LXBbMV0sWD0tcFsyXSx3PXBbM10sZXQ9cFs0XSxydD1wWzVdLGF0PXBbNl0sbHQ9cFs3XSxpdD16KnorJCokK1gqWCt3Knc7cmV0dXJuIGl0PjA/KE5bMF09KGV0KncrbHQqeitydCpYLWF0KiQpKjIvaXQsTlsxXT0ocnQqdytsdCokK2F0KnotZXQqWCkqMi9pdCxOWzJdPShhdCp3K2x0KlgrZXQqJC1ydCp6KSoyL2l0KTooTlswXT0oZXQqdytsdCp6K3J0KlgtYXQqJCkqMixOWzFdPShydCp3K2x0KiQrYXQqei1ldCpYKSoyLE5bMl09KGF0KncrbHQqWCtldCokLXJ0KnopKjIpLEQobCxwLE4pLGx9ZnVuY3Rpb24gUihsLHApe3JldHVybiBsWzBdPXBbMTJdLGxbMV09cFsxM10sbFsyXT1wWzE0XSxsfWZ1bmN0aW9uIEEobCxwKXt2YXIgTj1wWzBdLHo9cFsxXSwkPXBbMl0sWD1wWzRdLHc9cFs1XSxldD1wWzZdLHJ0PXBbOF0sYXQ9cFs5XSxsdD1wWzEwXTtyZXR1cm4gbFswXT1NYXRoLmh5cG90KE4seiwkKSxsWzFdPU1hdGguaHlwb3QoWCx3LGV0KSxsWzJdPU1hdGguaHlwb3QocnQsYXQsbHQpLGx9ZnVuY3Rpb24gVShsLHApe3ZhciBOPW5ldyBhLkFSUkFZX1RZUEUoMyk7QShOLHApO3ZhciB6PTEvTlswXSwkPTEvTlsxXSxYPTEvTlsyXSx3PXBbMF0qeixldD1wWzFdKiQscnQ9cFsyXSpYLGF0PXBbNF0qeixsdD1wWzVdKiQsaXQ9cFs2XSpYLG50PXBbOF0qeixvdD1wWzldKiQsaHQ9cFsxMF0qWCxkdD13K2x0K2h0LHV0PTA7cmV0dXJuIGR0PjA/KHV0PU1hdGguc3FydChkdCsxKSoyLGxbM109LjI1KnV0LGxbMF09KGl0LW90KS91dCxsWzFdPShudC1ydCkvdXQsbFsyXT0oZXQtYXQpL3V0KTp3Pmx0JiZ3Pmh0Pyh1dD1NYXRoLnNxcnQoMSt3LWx0LWh0KSoyLGxbM109KGl0LW90KS91dCxsWzBdPS4yNSp1dCxsWzFdPShldCthdCkvdXQsbFsyXT0obnQrcnQpL3V0KTpsdD5odD8odXQ9TWF0aC5zcXJ0KDErbHQtdy1odCkqMixsWzNdPShudC1ydCkvdXQsbFswXT0oZXQrYXQpL3V0LGxbMV09LjI1KnV0LGxbMl09KGl0K290KS91dCk6KHV0PU1hdGguc3FydCgxK2h0LXctbHQpKjIsbFszXT0oZXQtYXQpL3V0LGxbMF09KG50K3J0KS91dCxsWzFdPShpdCtvdCkvdXQsbFsyXT0uMjUqdXQpLGx9ZnVuY3Rpb24gSyhsLHAsTix6KXt2YXIgJD1wWzBdLFg9cFsxXSx3PXBbMl0sZXQ9cFszXSxydD0kKyQsYXQ9WCtYLGx0PXcrdyxpdD0kKnJ0LG50PSQqYXQsb3Q9JCpsdCxodD1YKmF0LGR0PVgqbHQsdXQ9dypsdCxtdD1ldCpydCxNdD1ldCphdCx2dD1ldCpsdCx5dD16WzBdLHB0PXpbMV0seHQ9elsyXTtyZXR1cm4gbFswXT0oMS0oaHQrdXQpKSp5dCxsWzFdPShudCt2dCkqeXQsbFsyXT0ob3QtTXQpKnl0LGxbM109MCxsWzRdPShudC12dCkqcHQsbFs1XT0oMS0oaXQrdXQpKSpwdCxsWzZdPShkdCttdCkqcHQsbFs3XT0wLGxbOF09KG90K010KSp4dCxsWzldPShkdC1tdCkqeHQsbFsxMF09KDEtKGl0K2h0KSkqeHQsbFsxMV09MCxsWzEyXT1OWzBdLGxbMTNdPU5bMV0sbFsxNF09TlsyXSxsWzE1XT0xLGx9ZnVuY3Rpb24gVihsLHAsTix6LCQpe3ZhciBYPXBbMF0sdz1wWzFdLGV0PXBbMl0scnQ9cFszXSxhdD1YK1gsbHQ9dyt3LGl0PWV0K2V0LG50PVgqYXQsb3Q9WCpsdCxodD1YKml0LGR0PXcqbHQsdXQ9dyppdCxtdD1ldCppdCxNdD1ydCphdCx2dD1ydCpsdCx5dD1ydCppdCxwdD16WzBdLHh0PXpbMV0sTHQ9elsyXSxTdD0kWzBdLEN0PSRbMV0sRHQ9JFsyXSxidD0oMS0oZHQrbXQpKSpwdCxJdD0ob3QreXQpKnB0LE50PShodC12dCkqcHQsRXQ9KG90LXl0KSp4dCxGdD0oMS0obnQrbXQpKSp4dCxZdD0odXQrTXQpKnh0LFh0PShodCt2dCkqTHQsYWU9KHV0LU10KSpMdCxvZT0oMS0obnQrZHQpKSpMdDtyZXR1cm4gbFswXT1idCxsWzFdPUl0LGxbMl09TnQsbFszXT0wLGxbNF09RXQsbFs1XT1GdCxsWzZdPVl0LGxbN109MCxsWzhdPVh0LGxbOV09YWUsbFsxMF09b2UsbFsxMV09MCxsWzEyXT1OWzBdK1N0LShidCpTdCtFdCpDdCtYdCpEdCksbFsxM109TlsxXStDdC0oSXQqU3QrRnQqQ3QrYWUqRHQpLGxbMTRdPU5bMl0rRHQtKE50KlN0K1l0KkN0K29lKkR0KSxsWzE1XT0xLGx9ZnVuY3Rpb24gUShsLHApe3ZhciBOPXBbMF0sej1wWzFdLCQ9cFsyXSxYPXBbM10sdz1OK04sZXQ9eit6LHJ0PSQrJCxhdD1OKncsbHQ9eip3LGl0PXoqZXQsbnQ9JCp3LG90PSQqZXQsaHQ9JCpydCxkdD1YKncsdXQ9WCpldCxtdD1YKnJ0O3JldHVybiBsWzBdPTEtaXQtaHQsbFsxXT1sdCttdCxsWzJdPW50LXV0LGxbM109MCxsWzRdPWx0LW10LGxbNV09MS1hdC1odCxsWzZdPW90K2R0LGxbN109MCxsWzhdPW50K3V0LGxbOV09b3QtZHQsbFsxMF09MS1hdC1pdCxsWzExXT0wLGxbMTJdPTAsbFsxM109MCxsWzE0XT0wLGxbMTVdPTEsbH1mdW5jdGlvbiBxKGwscCxOLHosJCxYLHcpe3ZhciBldD0xLyhOLXApLHJ0PTEvKCQteiksYXQ9MS8oWC13KTtyZXR1cm4gbFswXT1YKjIqZXQsbFsxXT0wLGxbMl09MCxsWzNdPTAsbFs0XT0wLGxbNV09WCoyKnJ0LGxbNl09MCxsWzddPTAsbFs4XT0oTitwKSpldCxsWzldPSgkK3opKnJ0LGxbMTBdPSh3K1gpKmF0LGxbMTFdPS0xLGxbMTJdPTAsbFsxM109MCxsWzE0XT13KlgqMiphdCxsWzE1XT0wLGx9ZnVuY3Rpb24gVyhsLHAsTix6LCQpe3ZhciBYPTEvTWF0aC50YW4ocC8yKSx3O3JldHVybiBsWzBdPVgvTixsWzFdPTAsbFsyXT0wLGxbM109MCxsWzRdPTAsbFs1XT1YLGxbNl09MCxsWzddPTAsbFs4XT0wLGxbOV09MCxsWzExXT0tMSxsWzEyXT0wLGxbMTNdPTAsbFsxNV09MCwkIT1udWxsJiYkIT09MS8wPyh3PTEvKHotJCksbFsxMF09KCQreikqdyxsWzE0XT0yKiQqeip3KToobFsxMF09LTEsbFsxNF09LTIqeiksbH1mdW5jdGlvbiBIKGwscCxOLHope3ZhciAkPU1hdGgudGFuKHAudXBEZWdyZWVzKk1hdGguUEkvMTgwKSxYPU1hdGgudGFuKHAuZG93bkRlZ3JlZXMqTWF0aC5QSS8xODApLHc9TWF0aC50YW4ocC5sZWZ0RGVncmVlcypNYXRoLlBJLzE4MCksZXQ9TWF0aC50YW4ocC5yaWdodERlZ3JlZXMqTWF0aC5QSS8xODApLHJ0PTIvKHcrZXQpLGF0PTIvKCQrWCk7cmV0dXJuIGxbMF09cnQsbFsxXT0wLGxbMl09MCxsWzNdPTAsbFs0XT0wLGxbNV09YXQsbFs2XT0wLGxbN109MCxsWzhdPS0oKHctZXQpKnJ0Ki41KSxsWzldPSgkLVgpKmF0Ki41LGxbMTBdPXovKE4teiksbFsxMV09LTEsbFsxMl09MCxsWzEzXT0wLGxbMTRdPXoqTi8oTi16KSxsWzE1XT0wLGx9ZnVuY3Rpb24gWihsLHAsTix6LCQsWCx3KXt2YXIgZXQ9MS8ocC1OKSxydD0xLyh6LSQpLGF0PTEvKFgtdyk7cmV0dXJuIGxbMF09LTIqZXQsbFsxXT0wLGxbMl09MCxsWzNdPTAsbFs0XT0wLGxbNV09LTIqcnQsbFs2XT0wLGxbN109MCxsWzhdPTAsbFs5XT0wLGxbMTBdPTIqYXQsbFsxMV09MCxsWzEyXT0ocCtOKSpldCxsWzEzXT0oJCt6KSpydCxsWzE0XT0odytYKSphdCxsWzE1XT0xLGx9ZnVuY3Rpb24gdHQobCxwLE4seil7dmFyICQsWCx3LGV0LHJ0LGF0LGx0LGl0LG50LG90LGh0PXBbMF0sZHQ9cFsxXSx1dD1wWzJdLG10PXpbMF0sTXQ9elsxXSx2dD16WzJdLHl0PU5bMF0scHQ9TlsxXSx4dD1OWzJdO3JldHVybiBNYXRoLmFicyhodC15dCk8YS5FUFNJTE9OJiZNYXRoLmFicyhkdC1wdCk8YS5FUFNJTE9OJiZNYXRoLmFicyh1dC14dCk8YS5FUFNJTE9OP2MobCk6KGx0PWh0LXl0LGl0PWR0LXB0LG50PXV0LXh0LG90PTEvTWF0aC5oeXBvdChsdCxpdCxudCksbHQqPW90LGl0Kj1vdCxudCo9b3QsJD1NdCpudC12dCppdCxYPXZ0Kmx0LW10Km50LHc9bXQqaXQtTXQqbHQsb3Q9TWF0aC5oeXBvdCgkLFgsdyksb3Q/KG90PTEvb3QsJCo9b3QsWCo9b3Qsdyo9b3QpOigkPTAsWD0wLHc9MCksZXQ9aXQqdy1udCpYLHJ0PW50KiQtbHQqdyxhdD1sdCpYLWl0KiQsb3Q9TWF0aC5oeXBvdChldCxydCxhdCksb3Q/KG90PTEvb3QsZXQqPW90LHJ0Kj1vdCxhdCo9b3QpOihldD0wLHJ0PTAsYXQ9MCksbFswXT0kLGxbMV09ZXQsbFsyXT1sdCxsWzNdPTAsbFs0XT1YLGxbNV09cnQsbFs2XT1pdCxsWzddPTAsbFs4XT13LGxbOV09YXQsbFsxMF09bnQsbFsxMV09MCxsWzEyXT0tKCQqaHQrWCpkdCt3KnV0KSxsWzEzXT0tKGV0Kmh0K3J0KmR0K2F0KnV0KSxsWzE0XT0tKGx0Kmh0K2l0KmR0K250KnV0KSxsWzE1XT0xLGwpfWZ1bmN0aW9uIF8obCxwLE4seil7dmFyICQ9cFswXSxYPXBbMV0sdz1wWzJdLGV0PXpbMF0scnQ9elsxXSxhdD16WzJdLGx0PSQtTlswXSxpdD1YLU5bMV0sbnQ9dy1OWzJdLG90PWx0Kmx0K2l0Kml0K250Km50O290PjAmJihvdD0xL01hdGguc3FydChvdCksbHQqPW90LGl0Kj1vdCxudCo9b3QpO3ZhciBodD1ydCpudC1hdCppdCxkdD1hdCpsdC1ldCpudCx1dD1ldCppdC1ydCpsdDtyZXR1cm4gb3Q9aHQqaHQrZHQqZHQrdXQqdXQsb3Q+MCYmKG90PTEvTWF0aC5zcXJ0KG90KSxodCo9b3QsZHQqPW90LHV0Kj1vdCksbFswXT1odCxsWzFdPWR0LGxbMl09dXQsbFszXT0wLGxbNF09aXQqdXQtbnQqZHQsbFs1XT1udCpodC1sdCp1dCxsWzZdPWx0KmR0LWl0Kmh0LGxbN109MCxsWzhdPWx0LGxbOV09aXQsbFsxMF09bnQsbFsxMV09MCxsWzEyXT0kLGxbMTNdPVgsbFsxNF09dyxsWzE1XT0xLGx9ZnVuY3Rpb24gc3QobCl7cmV0dXJuIm1hdDQoIitsWzBdKyIsICIrbFsxXSsiLCAiK2xbMl0rIiwgIitsWzNdKyIsICIrbFs0XSsiLCAiK2xbNV0rIiwgIitsWzZdKyIsICIrbFs3XSsiLCAiK2xbOF0rIiwgIitsWzldKyIsICIrbFsxMF0rIiwgIitsWzExXSsiLCAiK2xbMTJdKyIsICIrbFsxM10rIiwgIitsWzE0XSsiLCAiK2xbMTVdKyIpIn1mdW5jdGlvbiBrKGwpe3JldHVybiBNYXRoLmh5cG90KGxbMF0sbFsxXSxsWzJdLGxbM10sbFs0XSxsWzVdLGxbNl0sbFs3XSxsWzhdLGxbOV0sbFsxMF0sbFsxMV0sbFsxMl0sbFsxM10sbFsxNF0sbFsxNV0pfWZ1bmN0aW9uIGN0KGwscCxOKXtyZXR1cm4gbFswXT1wWzBdK05bMF0sbFsxXT1wWzFdK05bMV0sbFsyXT1wWzJdK05bMl0sbFszXT1wWzNdK05bM10sbFs0XT1wWzRdK05bNF0sbFs1XT1wWzVdK05bNV0sbFs2XT1wWzZdK05bNl0sbFs3XT1wWzddK05bN10sbFs4XT1wWzhdK05bOF0sbFs5XT1wWzldK05bOV0sbFsxMF09cFsxMF0rTlsxMF0sbFsxMV09cFsxMV0rTlsxMV0sbFsxMl09cFsxMl0rTlsxMl0sbFsxM109cFsxM10rTlsxM10sbFsxNF09cFsxNF0rTlsxNF0sbFsxNV09cFsxNV0rTlsxNV0sbH1mdW5jdGlvbiBmdChsLHAsTil7cmV0dXJuIGxbMF09cFswXS1OWzBdLGxbMV09cFsxXS1OWzFdLGxbMl09cFsyXS1OWzJdLGxbM109cFszXS1OWzNdLGxbNF09cFs0XS1OWzRdLGxbNV09cFs1XS1OWzVdLGxbNl09cFs2XS1OWzZdLGxbN109cFs3XS1OWzddLGxbOF09cFs4XS1OWzhdLGxbOV09cFs5XS1OWzldLGxbMTBdPXBbMTBdLU5bMTBdLGxbMTFdPXBbMTFdLU5bMTFdLGxbMTJdPXBbMTJdLU5bMTJdLGxbMTNdPXBbMTNdLU5bMTNdLGxbMTRdPXBbMTRdLU5bMTRdLGxbMTVdPXBbMTVdLU5bMTVdLGx9ZnVuY3Rpb24gQihsLHAsTil7cmV0dXJuIGxbMF09cFswXSpOLGxbMV09cFsxXSpOLGxbMl09cFsyXSpOLGxbM109cFszXSpOLGxbNF09cFs0XSpOLGxbNV09cFs1XSpOLGxbNl09cFs2XSpOLGxbN109cFs3XSpOLGxbOF09cFs4XSpOLGxbOV09cFs5XSpOLGxbMTBdPXBbMTBdKk4sbFsxMV09cFsxMV0qTixsWzEyXT1wWzEyXSpOLGxbMTNdPXBbMTNdKk4sbFsxNF09cFsxNF0qTixsWzE1XT1wWzE1XSpOLGx9ZnVuY3Rpb24gRihsLHAsTix6KXtyZXR1cm4gbFswXT1wWzBdK05bMF0qeixsWzFdPXBbMV0rTlsxXSp6LGxbMl09cFsyXStOWzJdKnosbFszXT1wWzNdK05bM10qeixsWzRdPXBbNF0rTls0XSp6LGxbNV09cFs1XStOWzVdKnosbFs2XT1wWzZdK05bNl0qeixsWzddPXBbN10rTls3XSp6LGxbOF09cFs4XStOWzhdKnosbFs5XT1wWzldK05bOV0qeixsWzEwXT1wWzEwXStOWzEwXSp6LGxbMTFdPXBbMTFdK05bMTFdKnosbFsxMl09cFsxMl0rTlsxMl0qeixsWzEzXT1wWzEzXStOWzEzXSp6LGxbMTRdPXBbMTRdK05bMTRdKnosbFsxNV09cFsxNV0rTlsxNV0qeixsfWZ1bmN0aW9uIFkobCxwKXtyZXR1cm4gbFswXT09PXBbMF0mJmxbMV09PT1wWzFdJiZsWzJdPT09cFsyXSYmbFszXT09PXBbM10mJmxbNF09PT1wWzRdJiZsWzVdPT09cFs1XSYmbFs2XT09PXBbNl0mJmxbN109PT1wWzddJiZsWzhdPT09cFs4XSYmbFs5XT09PXBbOV0mJmxbMTBdPT09cFsxMF0mJmxbMTFdPT09cFsxMV0mJmxbMTJdPT09cFsxMl0mJmxbMTNdPT09cFsxM10mJmxbMTRdPT09cFsxNF0mJmxbMTVdPT09cFsxNV19ZnVuY3Rpb24gSihsLHApe3ZhciBOPWxbMF0sej1sWzFdLCQ9bFsyXSxYPWxbM10sdz1sWzRdLGV0PWxbNV0scnQ9bFs2XSxhdD1sWzddLGx0PWxbOF0saXQ9bFs5XSxudD1sWzEwXSxvdD1sWzExXSxodD1sWzEyXSxkdD1sWzEzXSx1dD1sWzE0XSxtdD1sWzE1XSxNdD1wWzBdLHZ0PXBbMV0seXQ9cFsyXSxwdD1wWzNdLHh0PXBbNF0sTHQ9cFs1XSxTdD1wWzZdLEN0PXBbN10sRHQ9cFs4XSxidD1wWzldLEl0PXBbMTBdLE50PXBbMTFdLEV0PXBbMTJdLEZ0PXBbMTNdLFl0PXBbMTRdLFh0PXBbMTVdO3JldHVybiBNYXRoLmFicyhOLU10KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoTiksTWF0aC5hYnMoTXQpKSYmTWF0aC5hYnMoei12dCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKHZ0KSkmJk1hdGguYWJzKCQteXQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyh5dCkpJiZNYXRoLmFicyhYLXB0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMocHQpKSYmTWF0aC5hYnMody14dCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHcpLE1hdGguYWJzKHh0KSkmJk1hdGguYWJzKGV0LUx0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZXQpLE1hdGguYWJzKEx0KSkmJk1hdGguYWJzKHJ0LVN0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocnQpLE1hdGguYWJzKFN0KSkmJk1hdGguYWJzKGF0LUN0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYXQpLE1hdGguYWJzKEN0KSkmJk1hdGguYWJzKGx0LUR0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobHQpLE1hdGguYWJzKER0KSkmJk1hdGguYWJzKGl0LWJ0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaXQpLE1hdGguYWJzKGJ0KSkmJk1hdGguYWJzKG50LUl0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobnQpLE1hdGguYWJzKEl0KSkmJk1hdGguYWJzKG90LU50KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMob3QpLE1hdGguYWJzKE50KSkmJk1hdGguYWJzKGh0LUV0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaHQpLE1hdGguYWJzKEV0KSkmJk1hdGguYWJzKGR0LUZ0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZHQpLE1hdGguYWJzKEZ0KSkmJk1hdGguYWJzKHV0LVl0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModXQpLE1hdGguYWJzKFl0KSkmJk1hdGguYWJzKG10LVh0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobXQpLE1hdGguYWJzKFh0KSl9dmFyIGo9QyxHPWZ0fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImdldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJnZXRBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJjYWxjdWxhdGVXIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImV4cCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJsbiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJwb3ciLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic2xlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZnJvbU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiZnJvbUV1bGVyIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwicm90YXRpb25UbyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3FsZXJwIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJzZXRBeGVzIixmdW5jdGlvbigpe3JldHVybiBCfSk7dmFyIGE9dCgyKSxvPXQoNSksdj10KDgpLFQ9dCg5KTtmdW5jdGlvbiBkKCl7dmFyIEY9bmV3IGEuQVJSQVlfVFlQRSg0KTtyZXR1cm4gYS5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihGWzBdPTAsRlsxXT0wLEZbMl09MCksRlszXT0xLEZ9ZnVuY3Rpb24gdShGKXtyZXR1cm4gRlswXT0wLEZbMV09MCxGWzJdPTAsRlszXT0xLEZ9ZnVuY3Rpb24gYyhGLFksSil7Sj1KKi41O3ZhciBqPU1hdGguc2luKEopO3JldHVybiBGWzBdPWoqWVswXSxGWzFdPWoqWVsxXSxGWzJdPWoqWVsyXSxGWzNdPU1hdGguY29zKEopLEZ9ZnVuY3Rpb24gRShGLFkpe3ZhciBKPU1hdGguYWNvcyhZWzNdKSoyLGo9TWF0aC5zaW4oSi8yKTtyZXR1cm4gaj5hLkVQU0lMT04/KEZbMF09WVswXS9qLEZbMV09WVsxXS9qLEZbMl09WVsyXS9qKTooRlswXT0xLEZbMV09MCxGWzJdPTApLEp9ZnVuY3Rpb24gZihGLFkpe3ZhciBKPVEoRixZKTtyZXR1cm4gTWF0aC5hY29zKDIqSipKLTEpfWZ1bmN0aW9uIGcoRixZLEope3ZhciBqPVlbMF0sRz1ZWzFdLGw9WVsyXSxwPVlbM10sTj1KWzBdLHo9SlsxXSwkPUpbMl0sWD1KWzNdO3JldHVybiBGWzBdPWoqWCtwKk4rRyokLWwqeixGWzFdPUcqWCtwKnorbCpOLWoqJCxGWzJdPWwqWCtwKiQraip6LUcqTixGWzNdPXAqWC1qKk4tRyp6LWwqJCxGfWZ1bmN0aW9uIHkoRixZLEope0oqPS41O3ZhciBqPVlbMF0sRz1ZWzFdLGw9WVsyXSxwPVlbM10sTj1NYXRoLnNpbihKKSx6PU1hdGguY29zKEopO3JldHVybiBGWzBdPWoqeitwKk4sRlsxXT1HKnorbCpOLEZbMl09bCp6LUcqTixGWzNdPXAqei1qKk4sRn1mdW5jdGlvbiBDKEYsWSxKKXtKKj0uNTt2YXIgaj1ZWzBdLEc9WVsxXSxsPVlbMl0scD1ZWzNdLE49TWF0aC5zaW4oSiksej1NYXRoLmNvcyhKKTtyZXR1cm4gRlswXT1qKnotbCpOLEZbMV09Ryp6K3AqTixGWzJdPWwqeitqKk4sRlszXT1wKnotRypOLEZ9ZnVuY3Rpb24geChGLFksSil7Sio9LjU7dmFyIGo9WVswXSxHPVlbMV0sbD1ZWzJdLHA9WVszXSxOPU1hdGguc2luKEopLHo9TWF0aC5jb3MoSik7cmV0dXJuIEZbMF09aip6K0cqTixGWzFdPUcqei1qKk4sRlsyXT1sKnorcCpOLEZbM109cCp6LWwqTixGfWZ1bmN0aW9uIGgoRixZKXt2YXIgSj1ZWzBdLGo9WVsxXSxHPVlbMl07cmV0dXJuIEZbMF09SixGWzFdPWosRlsyXT1HLEZbM109TWF0aC5zcXJ0KE1hdGguYWJzKDEtSipKLWoqai1HKkcpKSxGfWZ1bmN0aW9uIG0oRixZKXt2YXIgSj1ZWzBdLGo9WVsxXSxHPVlbMl0sbD1ZWzNdLHA9TWF0aC5zcXJ0KEoqSitqKmorRypHKSxOPU1hdGguZXhwKGwpLHo9cD4wP04qTWF0aC5zaW4ocCkvcDowO3JldHVybiBGWzBdPUoqeixGWzFdPWoqeixGWzJdPUcqeixGWzNdPU4qTWF0aC5jb3MocCksRn1mdW5jdGlvbiByKEYsWSl7dmFyIEo9WVswXSxqPVlbMV0sRz1ZWzJdLGw9WVszXSxwPU1hdGguc3FydChKKkoraipqK0cqRyksTj1wPjA/TWF0aC5hdGFuMihwLGwpL3A6MDtyZXR1cm4gRlswXT1KKk4sRlsxXT1qKk4sRlsyXT1HKk4sRlszXT0uNSpNYXRoLmxvZyhKKkoraipqK0cqRytsKmwpLEZ9ZnVuY3Rpb24gaShGLFksSil7cmV0dXJuIHIoRixZKSxWKEYsRixKKSxtKEYsRiksRn1mdW5jdGlvbiBuKEYsWSxKLGope3ZhciBHPVlbMF0sbD1ZWzFdLHA9WVsyXSxOPVlbM10sej1KWzBdLCQ9SlsxXSxYPUpbMl0sdz1KWzNdLGV0LHJ0LGF0LGx0LGl0O3JldHVybiBydD1HKnorbCokK3AqWCtOKncscnQ8MCYmKHJ0PS1ydCx6PS16LCQ9LSQsWD0tWCx3PS13KSwxLXJ0PmEuRVBTSUxPTj8oZXQ9TWF0aC5hY29zKHJ0KSxhdD1NYXRoLnNpbihldCksbHQ9TWF0aC5zaW4oKDEtaikqZXQpL2F0LGl0PU1hdGguc2luKGoqZXQpL2F0KToobHQ9MS1qLGl0PWopLEZbMF09bHQqRytpdCp6LEZbMV09bHQqbCtpdCokLEZbMl09bHQqcCtpdCpYLEZbM109bHQqTitpdCp3LEZ9ZnVuY3Rpb24gcyhGKXt2YXIgWT1hLlJBTkRPTSgpLEo9YS5SQU5ET00oKSxqPWEuUkFORE9NKCksRz1NYXRoLnNxcnQoMS1ZKSxsPU1hdGguc3FydChZKTtyZXR1cm4gRlswXT1HKk1hdGguc2luKDIqTWF0aC5QSSpKKSxGWzFdPUcqTWF0aC5jb3MoMipNYXRoLlBJKkopLEZbMl09bCpNYXRoLnNpbigyKk1hdGguUEkqaiksRlszXT1sKk1hdGguY29zKDIqTWF0aC5QSSpqKSxGfWZ1bmN0aW9uIE0oRixZKXt2YXIgSj1ZWzBdLGo9WVsxXSxHPVlbMl0sbD1ZWzNdLHA9SipKK2oqaitHKkcrbCpsLE49cD8xL3A6MDtyZXR1cm4gRlswXT0tSipOLEZbMV09LWoqTixGWzJdPS1HKk4sRlszXT1sKk4sRn1mdW5jdGlvbiBQKEYsWSl7cmV0dXJuIEZbMF09LVlbMF0sRlsxXT0tWVsxXSxGWzJdPS1ZWzJdLEZbM109WVszXSxGfWZ1bmN0aW9uIFMoRixZKXt2YXIgSj1ZWzBdK1lbNF0rWVs4XSxqO2lmKEo+MClqPU1hdGguc3FydChKKzEpLEZbM109LjUqaixqPS41L2osRlswXT0oWVs1XS1ZWzddKSpqLEZbMV09KFlbNl0tWVsyXSkqaixGWzJdPShZWzFdLVlbM10pKmo7ZWxzZXt2YXIgRz0wO1lbNF0+WVswXSYmKEc9MSksWVs4XT5ZW0cqMytHXSYmKEc9Mik7dmFyIGw9KEcrMSklMyxwPShHKzIpJTM7aj1NYXRoLnNxcnQoWVtHKjMrR10tWVtsKjMrbF0tWVtwKjMrcF0rMSksRltHXT0uNSpqLGo9LjUvaixGWzNdPShZW2wqMytwXS1ZW3AqMytsXSkqaixGW2xdPShZW2wqMytHXStZW0cqMytsXSkqaixGW3BdPShZW3AqMytHXStZW0cqMytwXSkqan1yZXR1cm4gRn1mdW5jdGlvbiBiKEYsWSxKLGope3ZhciBHPS41Kk1hdGguUEkvMTgwO1kqPUcsSio9RyxqKj1HO3ZhciBsPU1hdGguc2luKFkpLHA9TWF0aC5jb3MoWSksTj1NYXRoLnNpbihKKSx6PU1hdGguY29zKEopLCQ9TWF0aC5zaW4oaiksWD1NYXRoLmNvcyhqKTtyZXR1cm4gRlswXT1sKnoqWC1wKk4qJCxGWzFdPXAqTipYK2wqeiokLEZbMl09cCp6KiQtbCpOKlgsRlszXT1wKnoqWCtsKk4qJCxGfWZ1bmN0aW9uIE8oRil7cmV0dXJuInF1YXQoIitGWzBdKyIsICIrRlsxXSsiLCAiK0ZbMl0rIiwgIitGWzNdKyIpIn12YXIgRD1ULmNsb25lLEk9VC5mcm9tVmFsdWVzLFI9VC5jb3B5LEE9VC5zZXQsVT1ULmFkZCxLPWcsVj1ULnNjYWxlLFE9VC5kb3QscT1ULmxlcnAsVz1ULmxlbmd0aCxIPVcsWj1ULnNxdWFyZWRMZW5ndGgsdHQ9WixfPVQubm9ybWFsaXplLHN0PVQuZXhhY3RFcXVhbHMsaz1ULmVxdWFscyxjdD1mdW5jdGlvbigpe3ZhciBGPXYuY3JlYXRlKCksWT12LmZyb21WYWx1ZXMoMSwwLDApLEo9di5mcm9tVmFsdWVzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24oaixHLGwpe3ZhciBwPXYuZG90KEcsbCk7cmV0dXJuIHA8LS45OTk5OTk/KHYuY3Jvc3MoRixZLEcpLHYubGVuKEYpPDFlLTYmJnYuY3Jvc3MoRixKLEcpLHYubm9ybWFsaXplKEYsRiksYyhqLEYsTWF0aC5QSSksaik6cD4uOTk5OTk5PyhqWzBdPTAsalsxXT0wLGpbMl09MCxqWzNdPTEsaik6KHYuY3Jvc3MoRixHLGwpLGpbMF09RlswXSxqWzFdPUZbMV0salsyXT1GWzJdLGpbM109MStwLF8oaixqKSl9fSgpLGZ0PWZ1bmN0aW9uKCl7dmFyIEY9ZCgpLFk9ZCgpO3JldHVybiBmdW5jdGlvbihKLGosRyxsLHAsTil7cmV0dXJuIG4oRixqLHAsTiksbihZLEcsbCxOKSxuKEosRixZLDIqTiooMS1OKSksSn19KCksQj1mdW5jdGlvbigpe3ZhciBGPW8uY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKFksSixqLEcpe3JldHVybiBGWzBdPWpbMF0sRlszXT1qWzFdLEZbNl09alsyXSxGWzFdPUdbMF0sRls0XT1HWzFdLEZbN109R1syXSxGWzJdPS1KWzBdLEZbNV09LUpbMV0sRls4XT0tSlsyXSxfKFksUyhZLEYpKX19KCl9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiaGVybWl0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJiZXppZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gWX0pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciBhPXQoMik7ZnVuY3Rpb24gbygpe3ZhciBwPW5ldyBhLkFSUkFZX1RZUEUoMyk7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYocFswXT0wLHBbMV09MCxwWzJdPTApLHB9ZnVuY3Rpb24gdihwKXt2YXIgTj1uZXcgYS5BUlJBWV9UWVBFKDMpO3JldHVybiBOWzBdPXBbMF0sTlsxXT1wWzFdLE5bMl09cFsyXSxOfWZ1bmN0aW9uIFQocCl7dmFyIE49cFswXSx6PXBbMV0sJD1wWzJdO3JldHVybiBNYXRoLmh5cG90KE4seiwkKX1mdW5jdGlvbiBkKHAsTix6KXt2YXIgJD1uZXcgYS5BUlJBWV9UWVBFKDMpO3JldHVybiAkWzBdPXAsJFsxXT1OLCRbMl09eiwkfWZ1bmN0aW9uIHUocCxOKXtyZXR1cm4gcFswXT1OWzBdLHBbMV09TlsxXSxwWzJdPU5bMl0scH1mdW5jdGlvbiBjKHAsTix6LCQpe3JldHVybiBwWzBdPU4scFsxXT16LHBbMl09JCxwfWZ1bmN0aW9uIEUocCxOLHope3JldHVybiBwWzBdPU5bMF0relswXSxwWzFdPU5bMV0relsxXSxwWzJdPU5bMl0relsyXSxwfWZ1bmN0aW9uIGYocCxOLHope3JldHVybiBwWzBdPU5bMF0telswXSxwWzFdPU5bMV0telsxXSxwWzJdPU5bMl0telsyXSxwfWZ1bmN0aW9uIGcocCxOLHope3JldHVybiBwWzBdPU5bMF0qelswXSxwWzFdPU5bMV0qelsxXSxwWzJdPU5bMl0qelsyXSxwfWZ1bmN0aW9uIHkocCxOLHope3JldHVybiBwWzBdPU5bMF0velswXSxwWzFdPU5bMV0velsxXSxwWzJdPU5bMl0velsyXSxwfWZ1bmN0aW9uIEMocCxOKXtyZXR1cm4gcFswXT1NYXRoLmNlaWwoTlswXSkscFsxXT1NYXRoLmNlaWwoTlsxXSkscFsyXT1NYXRoLmNlaWwoTlsyXSkscH1mdW5jdGlvbiB4KHAsTil7cmV0dXJuIHBbMF09TWF0aC5mbG9vcihOWzBdKSxwWzFdPU1hdGguZmxvb3IoTlsxXSkscFsyXT1NYXRoLmZsb29yKE5bMl0pLHB9ZnVuY3Rpb24gaChwLE4seil7cmV0dXJuIHBbMF09TWF0aC5taW4oTlswXSx6WzBdKSxwWzFdPU1hdGgubWluKE5bMV0selsxXSkscFsyXT1NYXRoLm1pbihOWzJdLHpbMl0pLHB9ZnVuY3Rpb24gbShwLE4seil7cmV0dXJuIHBbMF09TWF0aC5tYXgoTlswXSx6WzBdKSxwWzFdPU1hdGgubWF4KE5bMV0selsxXSkscFsyXT1NYXRoLm1heChOWzJdLHpbMl0pLHB9ZnVuY3Rpb24gcihwLE4pe3JldHVybiBwWzBdPU1hdGgucm91bmQoTlswXSkscFsxXT1NYXRoLnJvdW5kKE5bMV0pLHBbMl09TWF0aC5yb3VuZChOWzJdKSxwfWZ1bmN0aW9uIGkocCxOLHope3JldHVybiBwWzBdPU5bMF0qeixwWzFdPU5bMV0qeixwWzJdPU5bMl0qeixwfWZ1bmN0aW9uIG4ocCxOLHosJCl7cmV0dXJuIHBbMF09TlswXSt6WzBdKiQscFsxXT1OWzFdK3pbMV0qJCxwWzJdPU5bMl0relsyXSokLHB9ZnVuY3Rpb24gcyhwLE4pe3ZhciB6PU5bMF0tcFswXSwkPU5bMV0tcFsxXSxYPU5bMl0tcFsyXTtyZXR1cm4gTWF0aC5oeXBvdCh6LCQsWCl9ZnVuY3Rpb24gTShwLE4pe3ZhciB6PU5bMF0tcFswXSwkPU5bMV0tcFsxXSxYPU5bMl0tcFsyXTtyZXR1cm4geip6KyQqJCtYKlh9ZnVuY3Rpb24gUChwKXt2YXIgTj1wWzBdLHo9cFsxXSwkPXBbMl07cmV0dXJuIE4qTit6KnorJCokfWZ1bmN0aW9uIFMocCxOKXtyZXR1cm4gcFswXT0tTlswXSxwWzFdPS1OWzFdLHBbMl09LU5bMl0scH1mdW5jdGlvbiBiKHAsTil7cmV0dXJuIHBbMF09MS9OWzBdLHBbMV09MS9OWzFdLHBbMl09MS9OWzJdLHB9ZnVuY3Rpb24gTyhwLE4pe3ZhciB6PU5bMF0sJD1OWzFdLFg9TlsyXSx3PXoqeiskKiQrWCpYO3JldHVybiB3PjAmJih3PTEvTWF0aC5zcXJ0KHcpKSxwWzBdPU5bMF0qdyxwWzFdPU5bMV0qdyxwWzJdPU5bMl0qdyxwfWZ1bmN0aW9uIEQocCxOKXtyZXR1cm4gcFswXSpOWzBdK3BbMV0qTlsxXStwWzJdKk5bMl19ZnVuY3Rpb24gSShwLE4seil7dmFyICQ9TlswXSxYPU5bMV0sdz1OWzJdLGV0PXpbMF0scnQ9elsxXSxhdD16WzJdO3JldHVybiBwWzBdPVgqYXQtdypydCxwWzFdPXcqZXQtJCphdCxwWzJdPSQqcnQtWCpldCxwfWZ1bmN0aW9uIFIocCxOLHosJCl7dmFyIFg9TlswXSx3PU5bMV0sZXQ9TlsyXTtyZXR1cm4gcFswXT1YKyQqKHpbMF0tWCkscFsxXT13KyQqKHpbMV0tdykscFsyXT1ldCskKih6WzJdLWV0KSxwfWZ1bmN0aW9uIEEocCxOLHosJCxYLHcpe3ZhciBldD13KncscnQ9ZXQqKDIqdy0zKSsxLGF0PWV0Kih3LTIpK3csbHQ9ZXQqKHctMSksaXQ9ZXQqKDMtMip3KTtyZXR1cm4gcFswXT1OWzBdKnJ0K3pbMF0qYXQrJFswXSpsdCtYWzBdKml0LHBbMV09TlsxXSpydCt6WzFdKmF0KyRbMV0qbHQrWFsxXSppdCxwWzJdPU5bMl0qcnQrelsyXSphdCskWzJdKmx0K1hbMl0qaXQscH1mdW5jdGlvbiBVKHAsTix6LCQsWCx3KXt2YXIgZXQ9MS13LHJ0PWV0KmV0LGF0PXcqdyxsdD1ydCpldCxpdD0zKncqcnQsbnQ9MyphdCpldCxvdD1hdCp3O3JldHVybiBwWzBdPU5bMF0qbHQrelswXSppdCskWzBdKm50K1hbMF0qb3QscFsxXT1OWzFdKmx0K3pbMV0qaXQrJFsxXSpudCtYWzFdKm90LHBbMl09TlsyXSpsdCt6WzJdKml0KyRbMl0qbnQrWFsyXSpvdCxwfWZ1bmN0aW9uIEsocCxOKXtOPU58fDE7dmFyIHo9YS5SQU5ET00oKSoyKk1hdGguUEksJD1hLlJBTkRPTSgpKjItMSxYPU1hdGguc3FydCgxLSQqJCkqTjtyZXR1cm4gcFswXT1NYXRoLmNvcyh6KSpYLHBbMV09TWF0aC5zaW4oeikqWCxwWzJdPSQqTixwfWZ1bmN0aW9uIFYocCxOLHope3ZhciAkPU5bMF0sWD1OWzFdLHc9TlsyXSxldD16WzNdKiQrels3XSpYK3pbMTFdKncrelsxNV07cmV0dXJuIGV0PWV0fHwxLHBbMF09KHpbMF0qJCt6WzRdKlgrels4XSp3K3pbMTJdKS9ldCxwWzFdPSh6WzFdKiQrels1XSpYK3pbOV0qdyt6WzEzXSkvZXQscFsyXT0oelsyXSokK3pbNl0qWCt6WzEwXSp3K3pbMTRdKS9ldCxwfWZ1bmN0aW9uIFEocCxOLHope3ZhciAkPU5bMF0sWD1OWzFdLHc9TlsyXTtyZXR1cm4gcFswXT0kKnpbMF0rWCp6WzNdK3cqels2XSxwWzFdPSQqelsxXStYKnpbNF0rdyp6WzddLHBbMl09JCp6WzJdK1gqels1XSt3KnpbOF0scH1mdW5jdGlvbiBxKHAsTix6KXt2YXIgJD16WzBdLFg9elsxXSx3PXpbMl0sZXQ9elszXSxydD1OWzBdLGF0PU5bMV0sbHQ9TlsyXSxpdD1YKmx0LXcqYXQsbnQ9dypydC0kKmx0LG90PSQqYXQtWCpydCxodD1YKm90LXcqbnQsZHQ9dyppdC0kKm90LHV0PSQqbnQtWCppdCxtdD1ldCoyO3JldHVybiBpdCo9bXQsbnQqPW10LG90Kj1tdCxodCo9MixkdCo9Mix1dCo9MixwWzBdPXJ0K2l0K2h0LHBbMV09YXQrbnQrZHQscFsyXT1sdCtvdCt1dCxwfWZ1bmN0aW9uIFcocCxOLHosJCl7dmFyIFg9W10sdz1bXTtyZXR1cm4gWFswXT1OWzBdLXpbMF0sWFsxXT1OWzFdLXpbMV0sWFsyXT1OWzJdLXpbMl0sd1swXT1YWzBdLHdbMV09WFsxXSpNYXRoLmNvcygkKS1YWzJdKk1hdGguc2luKCQpLHdbMl09WFsxXSpNYXRoLnNpbigkKStYWzJdKk1hdGguY29zKCQpLHBbMF09d1swXSt6WzBdLHBbMV09d1sxXSt6WzFdLHBbMl09d1syXSt6WzJdLHB9ZnVuY3Rpb24gSChwLE4seiwkKXt2YXIgWD1bXSx3PVtdO3JldHVybiBYWzBdPU5bMF0telswXSxYWzFdPU5bMV0telsxXSxYWzJdPU5bMl0telsyXSx3WzBdPVhbMl0qTWF0aC5zaW4oJCkrWFswXSpNYXRoLmNvcygkKSx3WzFdPVhbMV0sd1syXT1YWzJdKk1hdGguY29zKCQpLVhbMF0qTWF0aC5zaW4oJCkscFswXT13WzBdK3pbMF0scFsxXT13WzFdK3pbMV0scFsyXT13WzJdK3pbMl0scH1mdW5jdGlvbiBaKHAsTix6LCQpe3ZhciBYPVtdLHc9W107cmV0dXJuIFhbMF09TlswXS16WzBdLFhbMV09TlsxXS16WzFdLFhbMl09TlsyXS16WzJdLHdbMF09WFswXSpNYXRoLmNvcygkKS1YWzFdKk1hdGguc2luKCQpLHdbMV09WFswXSpNYXRoLnNpbigkKStYWzFdKk1hdGguY29zKCQpLHdbMl09WFsyXSxwWzBdPXdbMF0relswXSxwWzFdPXdbMV0relsxXSxwWzJdPXdbMl0relsyXSxwfWZ1bmN0aW9uIHR0KHAsTil7dmFyIHo9cFswXSwkPXBbMV0sWD1wWzJdLHc9TlswXSxldD1OWzFdLHJ0PU5bMl0sYXQ9TWF0aC5zcXJ0KHoqeiskKiQrWCpYKSxsdD1NYXRoLnNxcnQodyp3K2V0KmV0K3J0KnJ0KSxpdD1hdCpsdCxudD1pdCYmRChwLE4pL2l0O3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgobnQsLTEpLDEpKX1mdW5jdGlvbiBfKHApe3JldHVybiBwWzBdPTAscFsxXT0wLHBbMl09MCxwfWZ1bmN0aW9uIHN0KHApe3JldHVybiJ2ZWMzKCIrcFswXSsiLCAiK3BbMV0rIiwgIitwWzJdKyIpIn1mdW5jdGlvbiBrKHAsTil7cmV0dXJuIHBbMF09PT1OWzBdJiZwWzFdPT09TlsxXSYmcFsyXT09PU5bMl19ZnVuY3Rpb24gY3QocCxOKXt2YXIgej1wWzBdLCQ9cFsxXSxYPXBbMl0sdz1OWzBdLGV0PU5bMV0scnQ9TlsyXTtyZXR1cm4gTWF0aC5hYnMoei13KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeiksTWF0aC5hYnModykpJiZNYXRoLmFicygkLWV0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoJCksTWF0aC5hYnMoZXQpKSYmTWF0aC5hYnMoWC1ydCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFgpLE1hdGguYWJzKHJ0KSl9dmFyIGZ0PWYsQj1nLEY9eSxZPXMsSj1NLGo9VCxHPVAsbD1mdW5jdGlvbigpe3ZhciBwPW8oKTtyZXR1cm4gZnVuY3Rpb24oTix6LCQsWCx3LGV0KXt2YXIgcnQsYXQ7Zm9yKHp8fCh6PTMpLCR8fCgkPTApLFg/YXQ9TWF0aC5taW4oWCp6KyQsTi5sZW5ndGgpOmF0PU4ubGVuZ3RoLHJ0PSQ7cnQ8YXQ7cnQrPXopcFswXT1OW3J0XSxwWzFdPU5bcnQrMV0scFsyXT1OW3J0KzJdLHcocCxwLGV0KSxOW3J0XT1wWzBdLE5bcnQrMV09cFsxXSxOW3J0KzJdPXBbMl07cmV0dXJuIE59fSgpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsInRyYW5zZm9ybVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIFF9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSk7dmFyIGE9dCgyKTtmdW5jdGlvbiBvKCl7dmFyIEI9bmV3IGEuQVJSQVlfVFlQRSg0KTtyZXR1cm4gYS5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTApLEJ9ZnVuY3Rpb24gdihCKXt2YXIgRj1uZXcgYS5BUlJBWV9UWVBFKDQpO3JldHVybiBGWzBdPUJbMF0sRlsxXT1CWzFdLEZbMl09QlsyXSxGWzNdPUJbM10sRn1mdW5jdGlvbiBUKEIsRixZLEope3ZhciBqPW5ldyBhLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGpbMF09QixqWzFdPUYsalsyXT1ZLGpbM109SixqfWZ1bmN0aW9uIGQoQixGKXtyZXR1cm4gQlswXT1GWzBdLEJbMV09RlsxXSxCWzJdPUZbMl0sQlszXT1GWzNdLEJ9ZnVuY3Rpb24gdShCLEYsWSxKLGope3JldHVybiBCWzBdPUYsQlsxXT1ZLEJbMl09SixCWzNdPWosQn1mdW5jdGlvbiBjKEIsRixZKXtyZXR1cm4gQlswXT1GWzBdK1lbMF0sQlsxXT1GWzFdK1lbMV0sQlsyXT1GWzJdK1lbMl0sQlszXT1GWzNdK1lbM10sQn1mdW5jdGlvbiBFKEIsRixZKXtyZXR1cm4gQlswXT1GWzBdLVlbMF0sQlsxXT1GWzFdLVlbMV0sQlsyXT1GWzJdLVlbMl0sQlszXT1GWzNdLVlbM10sQn1mdW5jdGlvbiBmKEIsRixZKXtyZXR1cm4gQlswXT1GWzBdKllbMF0sQlsxXT1GWzFdKllbMV0sQlsyXT1GWzJdKllbMl0sQlszXT1GWzNdKllbM10sQn1mdW5jdGlvbiBnKEIsRixZKXtyZXR1cm4gQlswXT1GWzBdL1lbMF0sQlsxXT1GWzFdL1lbMV0sQlsyXT1GWzJdL1lbMl0sQlszXT1GWzNdL1lbM10sQn1mdW5jdGlvbiB5KEIsRil7cmV0dXJuIEJbMF09TWF0aC5jZWlsKEZbMF0pLEJbMV09TWF0aC5jZWlsKEZbMV0pLEJbMl09TWF0aC5jZWlsKEZbMl0pLEJbM109TWF0aC5jZWlsKEZbM10pLEJ9ZnVuY3Rpb24gQyhCLEYpe3JldHVybiBCWzBdPU1hdGguZmxvb3IoRlswXSksQlsxXT1NYXRoLmZsb29yKEZbMV0pLEJbMl09TWF0aC5mbG9vcihGWzJdKSxCWzNdPU1hdGguZmxvb3IoRlszXSksQn1mdW5jdGlvbiB4KEIsRixZKXtyZXR1cm4gQlswXT1NYXRoLm1pbihGWzBdLFlbMF0pLEJbMV09TWF0aC5taW4oRlsxXSxZWzFdKSxCWzJdPU1hdGgubWluKEZbMl0sWVsyXSksQlszXT1NYXRoLm1pbihGWzNdLFlbM10pLEJ9ZnVuY3Rpb24gaChCLEYsWSl7cmV0dXJuIEJbMF09TWF0aC5tYXgoRlswXSxZWzBdKSxCWzFdPU1hdGgubWF4KEZbMV0sWVsxXSksQlsyXT1NYXRoLm1heChGWzJdLFlbMl0pLEJbM109TWF0aC5tYXgoRlszXSxZWzNdKSxCfWZ1bmN0aW9uIG0oQixGKXtyZXR1cm4gQlswXT1NYXRoLnJvdW5kKEZbMF0pLEJbMV09TWF0aC5yb3VuZChGWzFdKSxCWzJdPU1hdGgucm91bmQoRlsyXSksQlszXT1NYXRoLnJvdW5kKEZbM10pLEJ9ZnVuY3Rpb24gcihCLEYsWSl7cmV0dXJuIEJbMF09RlswXSpZLEJbMV09RlsxXSpZLEJbMl09RlsyXSpZLEJbM109RlszXSpZLEJ9ZnVuY3Rpb24gaShCLEYsWSxKKXtyZXR1cm4gQlswXT1GWzBdK1lbMF0qSixCWzFdPUZbMV0rWVsxXSpKLEJbMl09RlsyXStZWzJdKkosQlszXT1GWzNdK1lbM10qSixCfWZ1bmN0aW9uIG4oQixGKXt2YXIgWT1GWzBdLUJbMF0sSj1GWzFdLUJbMV0saj1GWzJdLUJbMl0sRz1GWzNdLUJbM107cmV0dXJuIE1hdGguaHlwb3QoWSxKLGosRyl9ZnVuY3Rpb24gcyhCLEYpe3ZhciBZPUZbMF0tQlswXSxKPUZbMV0tQlsxXSxqPUZbMl0tQlsyXSxHPUZbM10tQlszXTtyZXR1cm4gWSpZK0oqSitqKmorRypHfWZ1bmN0aW9uIE0oQil7dmFyIEY9QlswXSxZPUJbMV0sSj1CWzJdLGo9QlszXTtyZXR1cm4gTWF0aC5oeXBvdChGLFksSixqKX1mdW5jdGlvbiBQKEIpe3ZhciBGPUJbMF0sWT1CWzFdLEo9QlsyXSxqPUJbM107cmV0dXJuIEYqRitZKlkrSipKK2oqan1mdW5jdGlvbiBTKEIsRil7cmV0dXJuIEJbMF09LUZbMF0sQlsxXT0tRlsxXSxCWzJdPS1GWzJdLEJbM109LUZbM10sQn1mdW5jdGlvbiBiKEIsRil7cmV0dXJuIEJbMF09MS9GWzBdLEJbMV09MS9GWzFdLEJbMl09MS9GWzJdLEJbM109MS9GWzNdLEJ9ZnVuY3Rpb24gTyhCLEYpe3ZhciBZPUZbMF0sSj1GWzFdLGo9RlsyXSxHPUZbM10sbD1ZKlkrSipKK2oqaitHKkc7cmV0dXJuIGw+MCYmKGw9MS9NYXRoLnNxcnQobCkpLEJbMF09WSpsLEJbMV09SipsLEJbMl09aipsLEJbM109RypsLEJ9ZnVuY3Rpb24gRChCLEYpe3JldHVybiBCWzBdKkZbMF0rQlsxXSpGWzFdK0JbMl0qRlsyXStCWzNdKkZbM119ZnVuY3Rpb24gSShCLEYsWSxKKXt2YXIgaj1ZWzBdKkpbMV0tWVsxXSpKWzBdLEc9WVswXSpKWzJdLVlbMl0qSlswXSxsPVlbMF0qSlszXS1ZWzNdKkpbMF0scD1ZWzFdKkpbMl0tWVsyXSpKWzFdLE49WVsxXSpKWzNdLVlbM10qSlsxXSx6PVlbMl0qSlszXS1ZWzNdKkpbMl0sJD1GWzBdLFg9RlsxXSx3PUZbMl0sZXQ9RlszXTtyZXR1cm4gQlswXT1YKnotdypOK2V0KnAsQlsxXT0tKCQqeikrdypsLWV0KkcsQlsyXT0kKk4tWCpsK2V0KmosQlszXT0tKCQqcCkrWCpHLXcqaixCfWZ1bmN0aW9uIFIoQixGLFksSil7dmFyIGo9RlswXSxHPUZbMV0sbD1GWzJdLHA9RlszXTtyZXR1cm4gQlswXT1qK0oqKFlbMF0taiksQlsxXT1HK0oqKFlbMV0tRyksQlsyXT1sK0oqKFlbMl0tbCksQlszXT1wK0oqKFlbM10tcCksQn1mdW5jdGlvbiBBKEIsRil7Rj1GfHwxO3ZhciBZLEosaixHLGwscDtkbyBZPWEuUkFORE9NKCkqMi0xLEo9YS5SQU5ET00oKSoyLTEsbD1ZKlkrSipKO3doaWxlKGw+PTEpO2RvIGo9YS5SQU5ET00oKSoyLTEsRz1hLlJBTkRPTSgpKjItMSxwPWoqaitHKkc7d2hpbGUocD49MSk7dmFyIE49TWF0aC5zcXJ0KCgxLWwpL3ApO3JldHVybiBCWzBdPUYqWSxCWzFdPUYqSixCWzJdPUYqaipOLEJbM109RipHKk4sQn1mdW5jdGlvbiBVKEIsRixZKXt2YXIgSj1GWzBdLGo9RlsxXSxHPUZbMl0sbD1GWzNdO3JldHVybiBCWzBdPVlbMF0qSitZWzRdKmorWVs4XSpHK1lbMTJdKmwsQlsxXT1ZWzFdKkorWVs1XSpqK1lbOV0qRytZWzEzXSpsLEJbMl09WVsyXSpKK1lbNl0qaitZWzEwXSpHK1lbMTRdKmwsQlszXT1ZWzNdKkorWVs3XSpqK1lbMTFdKkcrWVsxNV0qbCxCfWZ1bmN0aW9uIEsoQixGLFkpe3ZhciBKPUZbMF0saj1GWzFdLEc9RlsyXSxsPVlbMF0scD1ZWzFdLE49WVsyXSx6PVlbM10sJD16KkorcCpHLU4qaixYPXoqaitOKkotbCpHLHc9eipHK2wqai1wKkosZXQ9LWwqSi1wKmotTipHO3JldHVybiBCWzBdPSQqeitldCotbCtYKi1OLXcqLXAsQlsxXT1YKnorZXQqLXArdyotbC0kKi1OLEJbMl09dyp6K2V0Ki1OKyQqLXAtWCotbCxCWzNdPUZbM10sQn1mdW5jdGlvbiBWKEIpe3JldHVybiBCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTAsQn1mdW5jdGlvbiBRKEIpe3JldHVybiJ2ZWM0KCIrQlswXSsiLCAiK0JbMV0rIiwgIitCWzJdKyIsICIrQlszXSsiKSJ9ZnVuY3Rpb24gcShCLEYpe3JldHVybiBCWzBdPT09RlswXSYmQlsxXT09PUZbMV0mJkJbMl09PT1GWzJdJiZCWzNdPT09RlszXX1mdW5jdGlvbiBXKEIsRil7dmFyIFk9QlswXSxKPUJbMV0saj1CWzJdLEc9QlszXSxsPUZbMF0scD1GWzFdLE49RlsyXSx6PUZbM107cmV0dXJuIE1hdGguYWJzKFktbCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFkpLE1hdGguYWJzKGwpKSYmTWF0aC5hYnMoSi1wKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoSiksTWF0aC5hYnMocCkpJiZNYXRoLmFicyhqLU4pPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhqKSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKEcteik8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEcpLE1hdGguYWJzKHopKX12YXIgSD1FLFo9Zix0dD1nLF89bixzdD1zLGs9TSxjdD1QLGZ0PWZ1bmN0aW9uKCl7dmFyIEI9bygpO3JldHVybiBmdW5jdGlvbihGLFksSixqLEcsbCl7dmFyIHAsTjtmb3IoWXx8KFk9NCksSnx8KEo9MCksaj9OPU1hdGgubWluKGoqWStKLEYubGVuZ3RoKTpOPUYubGVuZ3RoLHA9SjtwPE47cCs9WSlCWzBdPUZbcF0sQlsxXT1GW3ArMV0sQlsyXT1GW3ArMl0sQlszXT1GW3ArM10sRyhCLEIsbCksRltwXT1CWzBdLEZbcCsxXT1CWzFdLEZbcCsyXT1CWzJdLEZbcCszXT1CWzNdO3JldHVybiBGfX0oKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJnZXRSZWFsIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImdldER1YWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwic2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImdldFRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJyb3RhdGVCeVF1YXRBcHBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwicm90YXRlQnlRdWF0UHJlcGVuZCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJyb3RhdGVBcm91bmRBeGlzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFF9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBmdH0pO3ZhciBhPXQoMiksbz10KDcpLHY9dCg2KTtmdW5jdGlvbiBUKCl7dmFyIEI9bmV3IGEuQVJSQVlfVFlQRSg4KTtyZXR1cm4gYS5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzRdPTAsQls1XT0wLEJbNl09MCxCWzddPTApLEJbM109MSxCfWZ1bmN0aW9uIGQoQil7dmFyIEY9bmV3IGEuQVJSQVlfVFlQRSg4KTtyZXR1cm4gRlswXT1CWzBdLEZbMV09QlsxXSxGWzJdPUJbMl0sRlszXT1CWzNdLEZbNF09Qls0XSxGWzVdPUJbNV0sRls2XT1CWzZdLEZbN109Qls3XSxGfWZ1bmN0aW9uIHUoQixGLFksSixqLEcsbCxwKXt2YXIgTj1uZXcgYS5BUlJBWV9UWVBFKDgpO3JldHVybiBOWzBdPUIsTlsxXT1GLE5bMl09WSxOWzNdPUosTls0XT1qLE5bNV09RyxOWzZdPWwsTls3XT1wLE59ZnVuY3Rpb24gYyhCLEYsWSxKLGosRyxsKXt2YXIgcD1uZXcgYS5BUlJBWV9UWVBFKDgpO3BbMF09QixwWzFdPUYscFsyXT1ZLHBbM109Sjt2YXIgTj1qKi41LHo9RyouNSwkPWwqLjU7cmV0dXJuIHBbNF09TipKK3oqWS0kKkYscFs1XT16KkorJCpCLU4qWSxwWzZdPSQqSitOKkYteipCLHBbN109LU4qQi16KkYtJCpZLHB9ZnVuY3Rpb24gRShCLEYsWSl7dmFyIEo9WVswXSouNSxqPVlbMV0qLjUsRz1ZWzJdKi41LGw9RlswXSxwPUZbMV0sTj1GWzJdLHo9RlszXTtyZXR1cm4gQlswXT1sLEJbMV09cCxCWzJdPU4sQlszXT16LEJbNF09Sip6K2oqTi1HKnAsQls1XT1qKnorRypsLUoqTixCWzZdPUcqeitKKnAtaipsLEJbN109LUoqbC1qKnAtRypOLEJ9ZnVuY3Rpb24gZihCLEYpe3JldHVybiBCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTEsQls0XT1GWzBdKi41LEJbNV09RlsxXSouNSxCWzZdPUZbMl0qLjUsQls3XT0wLEJ9ZnVuY3Rpb24gZyhCLEYpe3JldHVybiBCWzBdPUZbMF0sQlsxXT1GWzFdLEJbMl09RlsyXSxCWzNdPUZbM10sQls0XT0wLEJbNV09MCxCWzZdPTAsQls3XT0wLEJ9ZnVuY3Rpb24geShCLEYpe3ZhciBZPW8uY3JlYXRlKCk7di5nZXRSb3RhdGlvbihZLEYpO3ZhciBKPW5ldyBhLkFSUkFZX1RZUEUoMyk7cmV0dXJuIHYuZ2V0VHJhbnNsYXRpb24oSixGKSxFKEIsWSxKKSxCfWZ1bmN0aW9uIEMoQixGKXtyZXR1cm4gQlswXT1GWzBdLEJbMV09RlsxXSxCWzJdPUZbMl0sQlszXT1GWzNdLEJbNF09Rls0XSxCWzVdPUZbNV0sQls2XT1GWzZdLEJbN109Rls3XSxCfWZ1bmN0aW9uIHgoQil7cmV0dXJuIEJbMF09MCxCWzFdPTAsQlsyXT0wLEJbM109MSxCWzRdPTAsQls1XT0wLEJbNl09MCxCWzddPTAsQn1mdW5jdGlvbiBoKEIsRixZLEosaixHLGwscCxOKXtyZXR1cm4gQlswXT1GLEJbMV09WSxCWzJdPUosQlszXT1qLEJbNF09RyxCWzVdPWwsQls2XT1wLEJbN109TixCfXZhciBtPW8uY29weTtmdW5jdGlvbiByKEIsRil7cmV0dXJuIEJbMF09Rls0XSxCWzFdPUZbNV0sQlsyXT1GWzZdLEJbM109Rls3XSxCfXZhciBpPW8uY29weTtmdW5jdGlvbiBuKEIsRil7cmV0dXJuIEJbNF09RlswXSxCWzVdPUZbMV0sQls2XT1GWzJdLEJbN109RlszXSxCfWZ1bmN0aW9uIHMoQixGKXt2YXIgWT1GWzRdLEo9Rls1XSxqPUZbNl0sRz1GWzddLGw9LUZbMF0scD0tRlsxXSxOPS1GWzJdLHo9RlszXTtyZXR1cm4gQlswXT0oWSp6K0cqbCtKKk4taipwKSoyLEJbMV09KEoqeitHKnAraipsLVkqTikqMixCWzJdPShqKnorRypOK1kqcC1KKmwpKjIsQn1mdW5jdGlvbiBNKEIsRixZKXt2YXIgSj1GWzBdLGo9RlsxXSxHPUZbMl0sbD1GWzNdLHA9WVswXSouNSxOPVlbMV0qLjUsej1ZWzJdKi41LCQ9Rls0XSxYPUZbNV0sdz1GWzZdLGV0PUZbN107cmV0dXJuIEJbMF09SixCWzFdPWosQlsyXT1HLEJbM109bCxCWzRdPWwqcCtqKnotRypOKyQsQls1XT1sKk4rRypwLUoqeitYLEJbNl09bCp6K0oqTi1qKnArdyxCWzddPS1KKnAtaipOLUcqeitldCxCfWZ1bmN0aW9uIFAoQixGLFkpe3ZhciBKPS1GWzBdLGo9LUZbMV0sRz0tRlsyXSxsPUZbM10scD1GWzRdLE49Rls1XSx6PUZbNl0sJD1GWzddLFg9cCpsKyQqSitOKkcteipqLHc9TipsKyQqait6KkotcCpHLGV0PXoqbCskKkcrcCpqLU4qSixydD0kKmwtcCpKLU4qai16Kkc7cmV0dXJuIG8ucm90YXRlWChCLEYsWSksSj1CWzBdLGo9QlsxXSxHPUJbMl0sbD1CWzNdLEJbNF09WCpsK3J0KkordypHLWV0KmosQls1XT13KmwrcnQqaitldCpKLVgqRyxCWzZdPWV0KmwrcnQqRytYKmotdypKLEJbN109cnQqbC1YKkotdypqLWV0KkcsQn1mdW5jdGlvbiBTKEIsRixZKXt2YXIgSj0tRlswXSxqPS1GWzFdLEc9LUZbMl0sbD1GWzNdLHA9Rls0XSxOPUZbNV0sej1GWzZdLCQ9Rls3XSxYPXAqbCskKkorTipHLXoqaix3PU4qbCskKmoreipKLXAqRyxldD16KmwrJCpHK3Aqai1OKkoscnQ9JCpsLXAqSi1OKmoteipHO3JldHVybiBvLnJvdGF0ZVkoQixGLFkpLEo9QlswXSxqPUJbMV0sRz1CWzJdLGw9QlszXSxCWzRdPVgqbCtydCpKK3cqRy1ldCpqLEJbNV09dypsK3J0KmorZXQqSi1YKkcsQls2XT1ldCpsK3J0KkcrWCpqLXcqSixCWzddPXJ0KmwtWCpKLXcqai1ldCpHLEJ9ZnVuY3Rpb24gYihCLEYsWSl7dmFyIEo9LUZbMF0saj0tRlsxXSxHPS1GWzJdLGw9RlszXSxwPUZbNF0sTj1GWzVdLHo9Rls2XSwkPUZbN10sWD1wKmwrJCpKK04qRy16Kmosdz1OKmwrJCpqK3oqSi1wKkcsZXQ9eipsKyQqRytwKmotTipKLHJ0PSQqbC1wKkotTipqLXoqRztyZXR1cm4gby5yb3RhdGVaKEIsRixZKSxKPUJbMF0saj1CWzFdLEc9QlsyXSxsPUJbM10sQls0XT1YKmwrcnQqSit3KkctZXQqaixCWzVdPXcqbCtydCpqK2V0KkotWCpHLEJbNl09ZXQqbCtydCpHK1gqai13KkosQls3XT1ydCpsLVgqSi13KmotZXQqRyxCfWZ1bmN0aW9uIE8oQixGLFkpe3ZhciBKPVlbMF0saj1ZWzFdLEc9WVsyXSxsPVlbM10scD1GWzBdLE49RlsxXSx6PUZbMl0sJD1GWzNdO3JldHVybiBCWzBdPXAqbCskKkorTipHLXoqaixCWzFdPU4qbCskKmoreipKLXAqRyxCWzJdPXoqbCskKkcrcCpqLU4qSixCWzNdPSQqbC1wKkotTipqLXoqRyxwPUZbNF0sTj1GWzVdLHo9Rls2XSwkPUZbN10sQls0XT1wKmwrJCpKK04qRy16KmosQls1XT1OKmwrJCpqK3oqSi1wKkcsQls2XT16KmwrJCpHK3Aqai1OKkosQls3XT0kKmwtcCpKLU4qai16KkcsQn1mdW5jdGlvbiBEKEIsRixZKXt2YXIgSj1GWzBdLGo9RlsxXSxHPUZbMl0sbD1GWzNdLHA9WVswXSxOPVlbMV0sej1ZWzJdLCQ9WVszXTtyZXR1cm4gQlswXT1KKiQrbCpwK2oqei1HKk4sQlsxXT1qKiQrbCpOK0cqcC1KKnosQlsyXT1HKiQrbCp6K0oqTi1qKnAsQlszXT1sKiQtSipwLWoqTi1HKnoscD1ZWzRdLE49WVs1XSx6PVlbNl0sJD1ZWzddLEJbNF09SiokK2wqcCtqKnotRypOLEJbNV09aiokK2wqTitHKnAtSip6LEJbNl09RyokK2wqeitKKk4taipwLEJbN109bCokLUoqcC1qKk4tRyp6LEJ9ZnVuY3Rpb24gSShCLEYsWSxKKXtpZihNYXRoLmFicyhKKTxhLkVQU0lMT04pcmV0dXJuIEMoQixGKTt2YXIgaj1NYXRoLmh5cG90KFlbMF0sWVsxXSxZWzJdKTtKPUoqLjU7dmFyIEc9TWF0aC5zaW4oSiksbD1HKllbMF0vaixwPUcqWVsxXS9qLE49RypZWzJdL2osej1NYXRoLmNvcyhKKSwkPUZbMF0sWD1GWzFdLHc9RlsyXSxldD1GWzNdO0JbMF09JCp6K2V0KmwrWCpOLXcqcCxCWzFdPVgqeitldCpwK3cqbC0kKk4sQlsyXT13KnorZXQqTiskKnAtWCpsLEJbM109ZXQqei0kKmwtWCpwLXcqTjt2YXIgcnQ9Rls0XSxhdD1GWzVdLGx0PUZbNl0saXQ9Rls3XTtyZXR1cm4gQls0XT1ydCp6K2l0KmwrYXQqTi1sdCpwLEJbNV09YXQqeitpdCpwK2x0KmwtcnQqTixCWzZdPWx0KnoraXQqTitydCpwLWF0KmwsQls3XT1pdCp6LXJ0KmwtYXQqcC1sdCpOLEJ9ZnVuY3Rpb24gUihCLEYsWSl7cmV0dXJuIEJbMF09RlswXStZWzBdLEJbMV09RlsxXStZWzFdLEJbMl09RlsyXStZWzJdLEJbM109RlszXStZWzNdLEJbNF09Rls0XStZWzRdLEJbNV09Rls1XStZWzVdLEJbNl09Rls2XStZWzZdLEJbN109Rls3XStZWzddLEJ9ZnVuY3Rpb24gQShCLEYsWSl7dmFyIEo9RlswXSxqPUZbMV0sRz1GWzJdLGw9RlszXSxwPVlbNF0sTj1ZWzVdLHo9WVs2XSwkPVlbN10sWD1GWzRdLHc9Rls1XSxldD1GWzZdLHJ0PUZbN10sYXQ9WVswXSxsdD1ZWzFdLGl0PVlbMl0sbnQ9WVszXTtyZXR1cm4gQlswXT1KKm50K2wqYXQraippdC1HKmx0LEJbMV09aipudCtsKmx0K0cqYXQtSippdCxCWzJdPUcqbnQrbCppdCtKKmx0LWoqYXQsQlszXT1sKm50LUoqYXQtaipsdC1HKml0LEJbNF09SiokK2wqcCtqKnotRypOK1gqbnQrcnQqYXQrdyppdC1ldCpsdCxCWzVdPWoqJCtsKk4rRypwLUoqeit3Km50K3J0Kmx0K2V0KmF0LVgqaXQsQls2XT1HKiQrbCp6K0oqTi1qKnArZXQqbnQrcnQqaXQrWCpsdC13KmF0LEJbN109bCokLUoqcC1qKk4tRyp6K3J0Km50LVgqYXQtdypsdC1ldCppdCxCfXZhciBVPUE7ZnVuY3Rpb24gSyhCLEYsWSl7cmV0dXJuIEJbMF09RlswXSpZLEJbMV09RlsxXSpZLEJbMl09RlsyXSpZLEJbM109RlszXSpZLEJbNF09Rls0XSpZLEJbNV09Rls1XSpZLEJbNl09Rls2XSpZLEJbN109Rls3XSpZLEJ9dmFyIFY9by5kb3Q7ZnVuY3Rpb24gUShCLEYsWSxKKXt2YXIgaj0xLUo7cmV0dXJuIFYoRixZKTwwJiYoSj0tSiksQlswXT1GWzBdKmorWVswXSpKLEJbMV09RlsxXSpqK1lbMV0qSixCWzJdPUZbMl0qaitZWzJdKkosQlszXT1GWzNdKmorWVszXSpKLEJbNF09Rls0XSpqK1lbNF0qSixCWzVdPUZbNV0qaitZWzVdKkosQls2XT1GWzZdKmorWVs2XSpKLEJbN109Rls3XSpqK1lbN10qSixCfWZ1bmN0aW9uIHEoQixGKXt2YXIgWT10dChGKTtyZXR1cm4gQlswXT0tRlswXS9ZLEJbMV09LUZbMV0vWSxCWzJdPS1GWzJdL1ksQlszXT1GWzNdL1ksQls0XT0tRls0XS9ZLEJbNV09LUZbNV0vWSxCWzZdPS1GWzZdL1ksQls3XT1GWzddL1ksQn1mdW5jdGlvbiBXKEIsRil7cmV0dXJuIEJbMF09LUZbMF0sQlsxXT0tRlsxXSxCWzJdPS1GWzJdLEJbM109RlszXSxCWzRdPS1GWzRdLEJbNV09LUZbNV0sQls2XT0tRls2XSxCWzddPUZbN10sQn12YXIgSD1vLmxlbmd0aCxaPUgsdHQ9by5zcXVhcmVkTGVuZ3RoLF89dHQ7ZnVuY3Rpb24gc3QoQixGKXt2YXIgWT10dChGKTtpZihZPjApe1k9TWF0aC5zcXJ0KFkpO3ZhciBKPUZbMF0vWSxqPUZbMV0vWSxHPUZbMl0vWSxsPUZbM10vWSxwPUZbNF0sTj1GWzVdLHo9Rls2XSwkPUZbN10sWD1KKnAraipOK0cqeitsKiQ7QlswXT1KLEJbMV09aixCWzJdPUcsQlszXT1sLEJbNF09KHAtSipYKS9ZLEJbNV09KE4taipYKS9ZLEJbNl09KHotRypYKS9ZLEJbN109KCQtbCpYKS9ZfXJldHVybiBCfWZ1bmN0aW9uIGsoQil7cmV0dXJuInF1YXQyKCIrQlswXSsiLCAiK0JbMV0rIiwgIitCWzJdKyIsICIrQlszXSsiLCAiK0JbNF0rIiwgIitCWzVdKyIsICIrQls2XSsiLCAiK0JbN10rIikifWZ1bmN0aW9uIGN0KEIsRil7cmV0dXJuIEJbMF09PT1GWzBdJiZCWzFdPT09RlsxXSYmQlsyXT09PUZbMl0mJkJbM109PT1GWzNdJiZCWzRdPT09Rls0XSYmQls1XT09PUZbNV0mJkJbNl09PT1GWzZdJiZCWzddPT09Rls3XX1mdW5jdGlvbiBmdChCLEYpe3ZhciBZPUJbMF0sSj1CWzFdLGo9QlsyXSxHPUJbM10sbD1CWzRdLHA9Qls1XSxOPUJbNl0sej1CWzddLCQ9RlswXSxYPUZbMV0sdz1GWzJdLGV0PUZbM10scnQ9Rls0XSxhdD1GWzVdLGx0PUZbNl0saXQ9Rls3XTtyZXR1cm4gTWF0aC5hYnMoWS0kKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWSksTWF0aC5hYnMoJCkpJiZNYXRoLmFicyhKLVgpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhYKSkmJk1hdGguYWJzKGotdyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGopLE1hdGguYWJzKHcpKSYmTWF0aC5hYnMoRy1ldCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEcpLE1hdGguYWJzKGV0KSkmJk1hdGguYWJzKGwtcnQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhsKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyhwLWF0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocCksTWF0aC5hYnMoYXQpKSYmTWF0aC5hYnMoTi1sdCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKGx0KSkmJk1hdGguYWJzKHotaXQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh6KSxNYXRoLmFicyhpdCkpfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiB5fSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwidHJhbnNmb3JtTWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gS30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQzIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIFF9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pO3ZhciBhPXQoMik7ZnVuY3Rpb24gbygpe3ZhciBqPW5ldyBhLkFSUkFZX1RZUEUoMik7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoalswXT0wLGpbMV09MCksan1mdW5jdGlvbiB2KGope3ZhciBHPW5ldyBhLkFSUkFZX1RZUEUoMik7cmV0dXJuIEdbMF09alswXSxHWzFdPWpbMV0sR31mdW5jdGlvbiBUKGosRyl7dmFyIGw9bmV3IGEuQVJSQVlfVFlQRSgyKTtyZXR1cm4gbFswXT1qLGxbMV09RyxsfWZ1bmN0aW9uIGQoaixHKXtyZXR1cm4galswXT1HWzBdLGpbMV09R1sxXSxqfWZ1bmN0aW9uIHUoaixHLGwpe3JldHVybiBqWzBdPUcsalsxXT1sLGp9ZnVuY3Rpb24gYyhqLEcsbCl7cmV0dXJuIGpbMF09R1swXStsWzBdLGpbMV09R1sxXStsWzFdLGp9ZnVuY3Rpb24gRShqLEcsbCl7cmV0dXJuIGpbMF09R1swXS1sWzBdLGpbMV09R1sxXS1sWzFdLGp9ZnVuY3Rpb24gZihqLEcsbCl7cmV0dXJuIGpbMF09R1swXSpsWzBdLGpbMV09R1sxXSpsWzFdLGp9ZnVuY3Rpb24gZyhqLEcsbCl7cmV0dXJuIGpbMF09R1swXS9sWzBdLGpbMV09R1sxXS9sWzFdLGp9ZnVuY3Rpb24geShqLEcpe3JldHVybiBqWzBdPU1hdGguY2VpbChHWzBdKSxqWzFdPU1hdGguY2VpbChHWzFdKSxqfWZ1bmN0aW9uIEMoaixHKXtyZXR1cm4galswXT1NYXRoLmZsb29yKEdbMF0pLGpbMV09TWF0aC5mbG9vcihHWzFdKSxqfWZ1bmN0aW9uIHgoaixHLGwpe3JldHVybiBqWzBdPU1hdGgubWluKEdbMF0sbFswXSksalsxXT1NYXRoLm1pbihHWzFdLGxbMV0pLGp9ZnVuY3Rpb24gaChqLEcsbCl7cmV0dXJuIGpbMF09TWF0aC5tYXgoR1swXSxsWzBdKSxqWzFdPU1hdGgubWF4KEdbMV0sbFsxXSksan1mdW5jdGlvbiBtKGosRyl7cmV0dXJuIGpbMF09TWF0aC5yb3VuZChHWzBdKSxqWzFdPU1hdGgucm91bmQoR1sxXSksan1mdW5jdGlvbiByKGosRyxsKXtyZXR1cm4galswXT1HWzBdKmwsalsxXT1HWzFdKmwsan1mdW5jdGlvbiBpKGosRyxsLHApe3JldHVybiBqWzBdPUdbMF0rbFswXSpwLGpbMV09R1sxXStsWzFdKnAsan1mdW5jdGlvbiBuKGosRyl7dmFyIGw9R1swXS1qWzBdLHA9R1sxXS1qWzFdO3JldHVybiBNYXRoLmh5cG90KGwscCl9ZnVuY3Rpb24gcyhqLEcpe3ZhciBsPUdbMF0talswXSxwPUdbMV0talsxXTtyZXR1cm4gbCpsK3AqcH1mdW5jdGlvbiBNKGope3ZhciBHPWpbMF0sbD1qWzFdO3JldHVybiBNYXRoLmh5cG90KEcsbCl9ZnVuY3Rpb24gUChqKXt2YXIgRz1qWzBdLGw9alsxXTtyZXR1cm4gRypHK2wqbH1mdW5jdGlvbiBTKGosRyl7cmV0dXJuIGpbMF09LUdbMF0salsxXT0tR1sxXSxqfWZ1bmN0aW9uIGIoaixHKXtyZXR1cm4galswXT0xL0dbMF0salsxXT0xL0dbMV0san1mdW5jdGlvbiBPKGosRyl7dmFyIGw9R1swXSxwPUdbMV0sTj1sKmwrcCpwO3JldHVybiBOPjAmJihOPTEvTWF0aC5zcXJ0KE4pKSxqWzBdPUdbMF0qTixqWzFdPUdbMV0qTixqfWZ1bmN0aW9uIEQoaixHKXtyZXR1cm4galswXSpHWzBdK2pbMV0qR1sxXX1mdW5jdGlvbiBJKGosRyxsKXt2YXIgcD1HWzBdKmxbMV0tR1sxXSpsWzBdO3JldHVybiBqWzBdPWpbMV09MCxqWzJdPXAsan1mdW5jdGlvbiBSKGosRyxsLHApe3ZhciBOPUdbMF0sej1HWzFdO3JldHVybiBqWzBdPU4rcCoobFswXS1OKSxqWzFdPXorcCoobFsxXS16KSxqfWZ1bmN0aW9uIEEoaixHKXtHPUd8fDE7dmFyIGw9YS5SQU5ET00oKSoyKk1hdGguUEk7cmV0dXJuIGpbMF09TWF0aC5jb3MobCkqRyxqWzFdPU1hdGguc2luKGwpKkcsan1mdW5jdGlvbiBVKGosRyxsKXt2YXIgcD1HWzBdLE49R1sxXTtyZXR1cm4galswXT1sWzBdKnArbFsyXSpOLGpbMV09bFsxXSpwK2xbM10qTixqfWZ1bmN0aW9uIEsoaixHLGwpe3ZhciBwPUdbMF0sTj1HWzFdO3JldHVybiBqWzBdPWxbMF0qcCtsWzJdKk4rbFs0XSxqWzFdPWxbMV0qcCtsWzNdKk4rbFs1XSxqfWZ1bmN0aW9uIFYoaixHLGwpe3ZhciBwPUdbMF0sTj1HWzFdO3JldHVybiBqWzBdPWxbMF0qcCtsWzNdKk4rbFs2XSxqWzFdPWxbMV0qcCtsWzRdKk4rbFs3XSxqfWZ1bmN0aW9uIFEoaixHLGwpe3ZhciBwPUdbMF0sTj1HWzFdO3JldHVybiBqWzBdPWxbMF0qcCtsWzRdKk4rbFsxMl0salsxXT1sWzFdKnArbFs1XSpOK2xbMTNdLGp9ZnVuY3Rpb24gcShqLEcsbCxwKXt2YXIgTj1HWzBdLWxbMF0sej1HWzFdLWxbMV0sJD1NYXRoLnNpbihwKSxYPU1hdGguY29zKHApO3JldHVybiBqWzBdPU4qWC16KiQrbFswXSxqWzFdPU4qJCt6KlgrbFsxXSxqfWZ1bmN0aW9uIFcoaixHKXt2YXIgbD1qWzBdLHA9alsxXSxOPUdbMF0sej1HWzFdLCQ9TWF0aC5zcXJ0KGwqbCtwKnApKk1hdGguc3FydChOKk4reip6KSxYPSQmJihsKk4rcCp6KS8kO3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoWCwtMSksMSkpfWZ1bmN0aW9uIEgoail7cmV0dXJuIGpbMF09MCxqWzFdPTAsan1mdW5jdGlvbiBaKGope3JldHVybiJ2ZWMyKCIralswXSsiLCAiK2pbMV0rIikifWZ1bmN0aW9uIHR0KGosRyl7cmV0dXJuIGpbMF09PT1HWzBdJiZqWzFdPT09R1sxXX1mdW5jdGlvbiBfKGosRyl7dmFyIGw9alswXSxwPWpbMV0sTj1HWzBdLHo9R1sxXTtyZXR1cm4gTWF0aC5hYnMobC1OKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobCksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhwLXopPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhwKSxNYXRoLmFicyh6KSl9dmFyIHN0PU0saz1FLGN0PWYsZnQ9ZyxCPW4sRj1zLFk9UCxKPWZ1bmN0aW9uKCl7dmFyIGo9bygpO3JldHVybiBmdW5jdGlvbihHLGwscCxOLHosJCl7dmFyIFgsdztmb3IobHx8KGw9MikscHx8KHA9MCksTj93PU1hdGgubWluKE4qbCtwLEcubGVuZ3RoKTp3PUcubGVuZ3RoLFg9cDtYPHc7WCs9bClqWzBdPUdbWF0salsxXT1HW1grMV0seihqLGosJCksR1tYXT1qWzBdLEdbWCsxXT1qWzFdO3JldHVybiBHfX0oKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKTt2YXIgYT10KDEzKTt0LmQoZSwiUmVuZGVyZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH0pO3ZhciBvPXQoNDApO3QuZChlLCJGaWd1cmUyRCIsZnVuY3Rpb24oKXtyZXR1cm4gby5kZWZhdWx0fSk7dmFyIHY9dCg1Nik7dC5kKGUsIk1lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gdi5kZWZhdWx0fSk7dmFyIFQ9dCgyOSk7dC5kKGUsIk1lc2hDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4gVC5kZWZhdWx0fSk7dmFyIGQ9dCgyMyk7dC5kKGUsInBhcnNlRm9udCIsZnVuY3Rpb24oKXtyZXR1cm4gZC5kZWZhdWx0fSk7dmFyIHU9dCgzMSk7dC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVmYXVsdH0pO3ZhciBjPXQoMjEpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciBhPXQoMTQpLG89dCgxKSx2PXQoMjApLFQ9dCgyNyksZD10KDI1KSx1PXQoNDApLGM9dCg1NiksRT10KDI5KSxmPXQoNTkpLGc9dCgyMSkseT10KDYzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQz17YXV0b1VwZGF0ZTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsYnVmZmVyU2l6ZToxNTAwfSx4PWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7ICAgIAogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsgICAgICAgICAgICAgIAp9CmAsaD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7CnZvaWQgbWFpbigpIHsKICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLnh5KTsKfQpgLG09U3ltYm9sKCJnbFJlbmRlcmVyIikscj1TeW1ib2woImNhbnZhc1JlbmRlcmVyIiksaT1TeW1ib2woIm9wdGlvbnMiKSxuPVN5bWJvbCgiZ2xvYmFsVHJhbnNmb3JtIikscz1TeW1ib2woImFwcGx5R2xvYmFsVHJhbnNmb3JtIiksTT1TeW1ib2woImNhbnZhcyIpO2Z1bmN0aW9uIFAoTyl7Y29uc3QgRD1PLmdsLEk9Ty5mYm87SSYmRC5iaW5kRnJhbWVidWZmZXIoRC5GUkFNRUJVRkZFUixJKSxPLl9kcmF3KCksSSYmRC5iaW5kRnJhbWVidWZmZXIoRC5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBTKE8sRCxJLFIpe2NvbnN0IEE9Ty5jcmVhdGVUZXh0dXJlKEQuY2FudmFzKSxVPVtbWzAsMF0sW0ksMF0sW0ksUl0sWzAsUl0sWzAsMF1dXTtVLmNsb3NlZD0hMDtjb25zdCBLPW5ldyBjLmRlZmF1bHQoe2NvbnRvdXJzOlV9KTtLLnNldFRleHR1cmUoQSksTy5zZXRNZXNoRGF0YShbSy5tZXNoRGF0YV0pLFAoTyksQS5kZWxldGUoKSxELmNsZWFyUmVjdCgwLDAsSSxSKSxkZWxldGUgRC5fZmlsdGVyfWNsYXNzIGJ7Y29uc3RydWN0b3IoRCxJPXt9KXtsZXQgUj1JLmNvbnRleHRUeXBlO2lmKFJ8fCh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dD09ImZ1bmN0aW9uIj9SPSJ3ZWJnbDIiOnR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Uj0id2ViZ2wiOlI9IjJkIiksIUQuZ2V0Q29udGV4dCl7Y29uc3QgQT1EO0Q9e2dldENvbnRleHQoKXtyZXR1cm4gQX0sd2lkdGg6SS53aWR0aCxoZWlnaHQ6SS5oZWlnaHR9LEEuY2FudmFzPUQsUj0iMmQifWlmKHRoaXNbTV09RCxSIT09IndlYmdsIiYmUiE9PSJ3ZWJnbDIiJiZSIT09IjJkIil0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29udGV4dCB0eXBlICR7Un1gKTtpZihJLmNvbnRleHRUeXBlPVIsdGhpc1tpXT1PYmplY3QuYXNzaWduKHt9LEMsSSksUj09PSJ3ZWJnbCJ8fFI9PT0id2ViZ2wyIil7Uj09PSJ3ZWJnbDIiJiYodGhpc1tpXS53ZWJnbDI9ITApO2NvbnN0IEE9bmV3IGEuZGVmYXVsdChELHRoaXNbaV0pO1I9PT0id2ViZ2wyIiYmIUEuaXNXZWJHTDImJihJLmNvbnRleHRUeXBlPSJ3ZWJnbCIpLE9iamVjdCh5LmNyZWF0ZVNoYWRlcnMpKEEpLE9iamVjdCh5LmFwcGx5U2hhZGVyKShBKSxPYmplY3QoeS5jcmVhdGVDbG91ZFNoYWRlcnMpKEEpO2NvbnN0IFU9QS5nbDtVLmNsZWFyQ29sb3IoMCwwLDAsMCksVS5ibGVuZEZ1bmNTZXBhcmF0ZShVLlNSQ19BTFBIQSxVLk9ORV9NSU5VU19TUkNfQUxQSEEsVS5PTkUsVS5PTkVfTUlOVVNfU1JDX0FMUEhBKSx0aGlzW21dPUF9ZWxzZSB0aGlzW3JdPW5ldyB2LmRlZmF1bHQoRCx0aGlzW2ldKTt0aGlzW25dPVsxLDAsMCwwLDEsMCwwLDAsMV0sdGhpcy51cGRhdGVSZXNvbHV0aW9uKCl9Z2V0IGNhbnZhcygpe3JldHVybiB0aGlzW01dfWdldCBjYW52YXNSZW5kZXJlcigpe3JldHVybiB0aGlzW3JdfWdldCBnbFJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbbV19Z2V0IGlzV2ViR0wyKCl7cmV0dXJuIHRoaXNbbV0mJnRoaXNbbV0uaXNXZWJHTDJ9Z2V0IG9wdGlvbnMoKXtyZXR1cm4gdGhpc1tpXX1nZXQgZ2xvYmFsVHJhbnNmb3JtTWF0cml4KCl7Y29uc3QgRD10aGlzW25dO3JldHVybltEWzBdLERbMV0sRFszXSxEWzRdLERbNl0sRFs3XV19Z2V0IHZpZXdNYXRyaXgoKXtyZXR1cm4gdGhpc1tuXX1bc10oKXtjb25zdCBEPXRoaXNbbV18fHRoaXNbcl07aWYodGhpc1ttXSl7Y29uc3R7d2lkdGg6SSxoZWlnaHQ6Un09dGhpcy5jYW52YXM7RC51bmlmb3Jtcy52aWV3TWF0cml4PXRoaXMudmlld01hdHJpeCxELnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXg9dGhpcy5wcm9qZWN0aW9uTWF0cml4LEQudW5pZm9ybXMudV9yZXNvbHV0aW9uPVtJLFJdfX11cGRhdGVSZXNvbHV0aW9uKCl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6SX09dGhpcy5jYW52YXMsUj1bMSwwLDAsMCwxLDAsLUQvMiwtSS8yLDFdLEE9WzIvRCwwLDAsMCwtMi9JLDAsMCwwLDFdLFU9by5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxBLFIpO3RoaXMucHJvamVjdGlvbk1hdHJpeD1VLHRoaXNbbV0mJnRoaXNbbV0uZ2wudmlld3BvcnQoMCwwLEQsSSl9Y3JlYXRlVGV4dHVyZShELEkpe3JldHVybih0aGlzW21dfHx0aGlzW3JdKS5jcmVhdGVUZXh0dXJlKEQsSSl9bG9hZFRleHR1cmUoRCx7dXNlSW1hZ2VCaXRtYXA6ST0hMX09e30pe3JldHVybih0aGlzW21dfHx0aGlzW3JdKS5sb2FkVGV4dHVyZShELHt1c2VJbWFnZUJpdG1hcDpJfSl9Y3JlYXRlVGV4dChELHtmb250Okk9IjE2cHggYXJpYWwiLGZpbGxDb2xvcjpSPW51bGwsc3Ryb2tlQ29sb3I6QT1udWxsLHN0cm9rZVdpZHRoOlU9MX09e30pe2lmKHRoaXNbbV0pe2NvbnN0IEs9Zy5kZWZhdWx0LmNyZWF0ZVRleHQoRCx7Zm9udDpJLGZpbGxDb2xvcjpSLHN0cm9rZUNvbG9yOkEsc3Ryb2tlV2lkdGg6VX0pO3JldHVybntpbWFnZTp0aGlzLmNyZWF0ZVRleHR1cmUoSy5pbWFnZSkscmVjdDpLLnJlY3R9fXJldHVybntfaW1nOntmb250OkksZmlsbENvbG9yOlIsc3Ryb2tlQ29sb3I6QSxzdHJva2VXaWR0aDpVLHRleHQ6RH19fWNyZWF0ZVByb2dyYW0oe3ZlcnRleDpELGZyYWdtZW50Okksb3B0aW9uczpSfT17fSl7aWYodGhpc1ttXSl7Y29uc3QgQT10aGlzW21dLmNvbXBpbGVTeW5jKEksRCk7cmV0dXJuIEEuX2F0dHJpYk9wdHM9UixBfXRocm93IG5ldyBFcnJvcigiQ29udGV4dCAyRCBjYW5ub3QgY3JlYXRlIHdlYmdsIHByb2dyYW0uIil9Y3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDpEPXgsZnJhZ21lbnQ6ST1oLG9wdGlvbnM6Un09e30pe3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDpELGZyYWdtZW50Okksb3B0aW9uczpSfSl9dXNlUHJvZ3JhbShELEk9e30pe2lmKHRoaXNbbV0pe2NvbnN0IFI9T2JqZWN0LmFzc2lnbih7fSxELl9hdHRyaWJPcHRzLEkpO3JldHVybiB0aGlzW21dLnVzZVByb2dyYW0oRCxSKX10aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IHVzZSB3ZWJnbCBwcm9ncmFtLiIpfWRlbGV0ZVRleHR1cmUoRCl7cmV0dXJuKHRoaXNbbV18fHRoaXNbcl0pLmRlbGV0ZVRleHR1cmUoRCl9Y2xlYXIoLi4uRCl7aWYodGhpc1ttXSl7Y29uc3QgST10aGlzW21dLmdsO0kuY2xlYXIoSS5DT0xPUl9CVUZGRVJfQklUKX1lbHNlIHRoaXNbcl0uY2xlYXIoLi4uRCl9ZHJhd01lc2hDbG91ZChELHtjbGVhcjpJPSExLHByb2dyYW06Uj1udWxsfT17fSl7Y29uc3QgQT10aGlzW21dfHx0aGlzW3JdLFU9Unx8RC5wcm9ncmFtO2lmKHRoaXNbbV0pe2NvbnN0IEs9QS5nbDtpZihJJiZLLmNsZWFyKEsuQ09MT1JfQlVGRkVSX0JJVCksVSlBLnByb2dyYW0hPT1VJiZ0aGlzLnVzZVByb2dyYW0oVSx7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZpbGxDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfc3Ryb2tlQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZyYW1lSW5kZXg6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMX19KTtlbHNle2NvbnN0IFY9RC5tZXNoLm1lc2hEYXRhLFE9ISFWLnVuaWZvcm1zLnVfdGV4U2FtcGxlcixxPSEhVi51bmlmb3Jtcy51X2ZpbHRlckZsYWcsVz0hIVYudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3RvcixIPUQuaGFzQ2xvdWRDb2xvcixaPUQuaGFzQ2xvdWRGaWx0ZXIsdHQ9ISFWLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHkuYXBwbHlDbG91ZFNoYWRlcikoQSx7aGFzVGV4dHVyZTpRLGhhc0ZpbHRlcjpxLGhhc0dyYWRpZW50OlcsaGFzQ2xvdWRDb2xvcjpILGhhc0Nsb3VkRmlsdGVyOlosaGFzQ2xpcFBhdGg6dHR9KX10aGlzW3NdKCksQS5zZXRNZXNoRGF0YShbRC5tZXNoRGF0YV0pLEQuYmVmb3JlUmVuZGVyJiZELmJlZm9yZVJlbmRlcihLLEQpLFAoQSksRC5hZnRlclJlbmRlciYmRC5hZnRlclJlbmRlcihLLEQpfWVsc2UgQS5zZXRUcmFuc2Zvcm0odGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpLEEuZHJhd01lc2hDbG91ZChELHtjbGVhcjpJLGhvb2s6ITF9KX1kcmF3TWVzaGVzKEQse2NsZWFyOkk9ITEscHJvZ3JhbTpSPW51bGx9PXt9KXtjb25zdCBBPXRoaXNbbV18fHRoaXNbcl07aWYodGhpc1ttXSl7Y29uc3QgVT1BLmZibyxLPU9iamVjdChULmRlZmF1bHQpKHRoaXMsRCxSPT1udWxsKSxWPUEuZ2w7SSYmVi5jbGVhcihWLkNPTE9SX0JVRkZFUl9CSVQpO2NvbnN0IFE9IU9iamVjdChmLmlzVW5pdFRyYW5zZm9ybSkodGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpO3RoaXMuX2RyYXdDYWxscz0wO2Zvcihjb25zdCBxIG9mIEspe3RoaXMuX2RyYXdDYWxscysrO2NvbnN0IFc9Unx8cS5wcm9ncmFtO2lmKHEgaW5zdGFuY2VvZiBFLmRlZmF1bHQpdGhpcy5kcmF3TWVzaENsb3VkKHEse2NsZWFyOkkscHJvZ3JhbTpXfSk7ZWxzZXtjb25zdHt3aWR0aDpILGhlaWdodDpafT10aGlzLmNhbnZhcztpZihxLmJlZm9yZVJlbmRlciYmcS5iZWZvcmVSZW5kZXIoVixxKSxxLnBhc3MubGVuZ3RoJiYoKCF0aGlzLmZib3x8dGhpcy5mYm8ud2lkdGghPT1IfHx0aGlzLmZiby5oZWlnaHQhPT1aKSYmKHRoaXMuZmJvPXt3aWR0aDpILGhlaWdodDpaLHRhcmdldDpBLmNyZWF0ZUZCTygpLGJ1ZmZlcjpBLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSksQS5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLCFXJiZxLmZpbHRlckNhbnZhcyl7T2JqZWN0KHkuYXBwbHlTaGFkZXIpKEEse2hhc1RleHR1cmU6ITB9KTtsZXQgdHQ9dGhpcy5maWx0ZXJDb250ZXh0O3R0fHwodHQ9Zy5kZWZhdWx0LmNyZWF0ZUNhbnZhcyhILFopLmdldENvbnRleHQoIjJkIiksdGhpcy5maWx0ZXJDb250ZXh0PXR0KTtjb25zdCBfPURbcS5wYWNrSW5kZXhdLHN0PV8uZmlsdGVyLGs9RFtxLnBhY2tJbmRleCsxXSxjdD1EW3EucGFja0luZGV4LTFdOyghY3R8fCFjdC5maWx0ZXJDYW52YXN8fGN0LmZpbHRlciE9PXN0KSYmKCFrfHwhay5maWx0ZXJDYW52YXN8fGsuZmlsdGVyIT09c3QpPyhRPyh0dC5zYXZlKCksT2JqZWN0KGQuZHJhd01lc2gyRCkoXyx0dCwhMSksdHQucmVzdG9yZSgpLE9iamVjdChkLmFwcGx5RmlsdGVyKSh0dCxzdCkpOk9iamVjdChkLmRyYXdNZXNoMkQpKF8sdHQsITApLHRoaXNbc10oKSxTKEEsdHQsSCxaKSk6KFEmJnR0LnNhdmUoKSxPYmplY3QoZC5kcmF3TWVzaDJEKShfLHR0LCExKSxRJiZ0dC5yZXN0b3JlKCksKCFrfHwhay5maWx0ZXJDYW52YXN8fF8uZmlsdGVyIT09ay5maWx0ZXIpJiYoT2JqZWN0KGQuYXBwbHlGaWx0ZXIpKHR0LHN0KSx0aGlzW3NdKCksUyhBLHR0LEgsWikpKX1lbHNle2lmKFcpQS5wcm9ncmFtIT09VyYmdGhpcy51c2VQcm9ncmFtKFcse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH19KTtlbHNle2NvbnN0IHR0PSEhcS51bmlmb3Jtcy51X3RleFNhbXBsZXIsXz0hIXEudW5pZm9ybXMudV9maWx0ZXJGbGFnLHN0PSEhcS51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLGs9ISFxLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHkuYXBwbHlTaGFkZXIpKEEse2hhc1RleHR1cmU6dHQsaGFzRmlsdGVyOl8saGFzR3JhZGllbnQ6c3QsaGFzQ2xpcFBhdGg6a30pfXEuZmlsdGVyQ2FudmFzJiZjb25zb2xlLndhcm4oIlVzZXIgcHJvZ3JhbSBpZ25vcmVkIHNvbWUgZmlsdGVyIGVmZmVjdHMuIiksdGhpc1tzXSgpLEEuc2V0TWVzaERhdGEoW3FdKSxQKEEpfWlmKHEucGFzcy5sZW5ndGgpe2NvbnN0IHR0PXEucGFzcy5sZW5ndGg7cS5wYXNzLmZvckVhY2goKF8sc3QpPT57Xy5ibGVuZD1xLmVuYWJsZUJsZW5kLF8uc2V0VGV4dHVyZShBLmZiby50ZXh0dXJlKSxzdD09PXR0LTE/QS5iaW5kRkJPKFUpOih0aGlzLmZiby5zd2FwKCksQS5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLF8ucHJvZ3JhbT9BLnVzZVByb2dyYW0oXy5wcm9ncmFtKToodGhpcy5kZWZhdWx0UGFzc1Byb2dyYW09dGhpcy5kZWZhdWx0UGFzc1Byb2dyYW18fHRoaXMuY3JlYXRlUGFzc1Byb2dyYW0oKSxBLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0UGFzc1Byb2dyYW0pKSxBLnNldE1lc2hEYXRhKFtfLm1lc2hEYXRhXSksVi5jbGVhcihWLkNPTE9SX0JVRkZFUl9CSVQpLFAoQSl9KX1xLmFmdGVyUmVuZGVyJiZxLmFmdGVyUmVuZGVyKFYscSl9fX1lbHNlIEEuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxBLmRyYXdNZXNoZXMoRCx7Y2xlYXI6SX0pfWRyYXdJbWFnZShELC4uLkkpe2NvbnN0IFI9SS5sZW5ndGg7aWYoUjwyKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICdkcmF3SW1hZ2UnIG9uICdSZW5kZXJlcic6IDMgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke0kubGVuZ3RoKzF9IHByZXNlbnQuYCk7aWYoUiE9PTImJlIhPT00JiZSIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiBWYWxpZCBhcml0aWVzIGFyZTogWzMsIDUsIDldLCBidXQgJHtJLmxlbmd0aCsxfSBhcmd1bWVudHMgcHJvdmlkZWQuYCk7bGV0IEE9bnVsbCxVPW51bGw7Uj09PTI/QT1bSVswXSxJWzFdLEQud2lkdGgsRC5oZWlnaHRdOlI9PT00P0E9STpSPT09OCYmKFU9SS5zbGljZSgwLDQpLEE9SS5zbGljZSg0KSk7Y29uc3QgSz10aGlzLmNyZWF0ZVRleHR1cmUoRCkse3dpZHRoOlYsaGVpZ2h0OlF9PXRoaXMuY2FudmFzLHE9bmV3IHUuZGVmYXVsdDtxLnJlY3QoQVswXSxBWzFdLFYsUSk7Y29uc3QgVz1uZXcgYy5kZWZhdWx0KHEse3dpZHRoOlYsaGVpZ2h0OlF9KTtXLnNldFRleHR1cmUoSyx7cmVjdDpBLHNyY1JlY3Q6VX0pLHRoaXMuZHJhd01lc2hlcyhbV10pLHRoaXMuZGVsZXRlVGV4dHVyZShLKX1zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uRCl7cmV0dXJuIHRoaXNbbl09W0RbMF0sRFsxXSwwLERbMl0sRFszXSwwLERbNF0sRFs1XSwxXSx0aGlzfWdsb2JhbFRyYW5zZm9ybSguLi5EKXtjb25zdCBJPXRoaXNbbl07cmV0dXJuIHRoaXNbbl09by5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxJLEQpLHRoaXN9Z2xvYmFsVHJhbnNsYXRlKEQsSSl7bGV0IFI9by5tYXQzLmNyZWF0ZSgpO3JldHVybiBSPW8ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFIsW0QsSV0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLlIpfWdsb2JhbFJvdGF0ZShELFtJLFJdPVswLDBdKXtsZXQgQT1vLm1hdDMuY3JlYXRlKCk7cmV0dXJuIEE9by5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQSxbSSxSXSksQT1vLm1hdDMucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxBLEQpLEE9by5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQSxbLUksLVJdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5BKX1nbG9iYWxTY2FsZShELEk9RCxbUixBXT1bMCwwXSl7bGV0IFU9by5tYXQzLmNyZWF0ZSgpO3JldHVybiBVPW8ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFUsW1IsQV0pLFU9by5tYXQzLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxVLFtELEldKSxVPW8ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFUsWy1SLC1BXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uVSl9Z2xvYmFsU2tldyhELEk9RCxbUixBXT1bMCwwXSl7bGV0IFU9by5tYXQzLmNyZWF0ZSgpO3JldHVybiBVPW8ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFUsW1IsQV0pLFU9by5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxVLG8ubWF0My5mcm9tVmFsdWVzKDEsTWF0aC50YW4oSSksTWF0aC50YW4oRCksMSwwLDApKSxVPW8ubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFUsWy1SLC1BXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uVSl9dHJhbnNmb3JtUG9pbnQoRCxJLFIpe2xldCBBPXRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O1ImJihBPW8ubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQSxSKSk7Y29uc3QgVT1EKkFbMF0rSSpBWzJdK0FbNF0sSz1EKkFbMV0rSSpBWzNdK0FbNV07cmV0dXJuW1UsS119fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKTt2YXIgYT10KDE1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWEuZGVmYXVsdH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geX0pO3ZhciBhPXQoMTYpLG89dCgxNyksdj10KDE4KSxUPXQoMTkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBkKEMseCxoKXtyZXR1cm4geCBpbiBDP09iamVjdC5kZWZpbmVQcm9wZXJ0eShDLHgse3ZhbHVlOmgsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpDW3hdPWgsQ31jb25zdCB1PXt9O2Z1bmN0aW9uIGMoQyx4PTMpe2NvbnN0IGg9W10sbT1DLmxlbmd0aDtmb3IobGV0IHI9MDtyPG07cisrKXIleDwyJiZoLnB1c2goLjUqKENbcl0rMSkpO3JldHVybiBofWZ1bmN0aW9uIEUoQyx4KXtjb25zdCBoPXguX2J1ZmZlcnM7T2JqZWN0LnZhbHVlcyhoKS5mb3JFYWNoKG09PntDLmRlbGV0ZUJ1ZmZlcihtKX0pLHguX2J1ZmZlcnM9e319ZnVuY3Rpb24gZihDLHgsaCl7cmV0dXJuIEMuYWN0aXZlVGV4dHVyZShDLlRFWFRVUkUwK2gpLEFycmF5LmlzQXJyYXkoeC5faW1nKT9DLmJpbmRUZXh0dXJlKEMuVEVYVFVSRV9DVUJFX01BUCx4KTpDLmJpbmRUZXh0dXJlKEMuVEVYVFVSRV8yRCx4KSx4fWNvbnN0IGc9e2ludDoiMWkiLGl2ZWMyOiIyaSIsaXZlYzM6IjNpIixpdmVjNDoiNGkiLGZsb2F0OiIxZiIsdmVjMjoiMmYiLHZlYzM6IjNmIix2ZWM0OiI0ZiIsbWF0MjoiTWF0cml4MmZ2IixtYXQzOiJNYXRyaXgzZnYiLG1hdDQ6Ik1hdHJpeDRmdiIsc2FtcGxlcjFEOiJzYW1wbGVyMUQiLHNhbXBsZXIyRDoic2FtcGxlcjJEIixzYW1wbGVyM0Q6InNhbXBsZXIzRCIsc2FtcGxlckN1YmU6InNhbXBsZXJDdWJlIixzYW1wbGVyMURTaGFkb3c6InNhbXBsZXIxRFNoYWRvdyIsc2FtcGxlcjJEU2hhZG93OiJzYW1wbGVyMkRTaGFkb3ciLHNhbXBsZXIyRFJlY3Q6InNhbXBsZXIyRFJlY3QiLHNhbXBsZXIyRFJlY3RTaGFkb3c6InNhbXBsZXIyRFJlY3RTaGFkb3cifTtjbGFzcyB5e3N0YXRpYyBhZGRMaWJzKHg9e30pe09iamVjdC5hc3NpZ24odSx4KX1zdGF0aWMgRkxPQVQoeCxoKXtyZXR1cm4gT2JqZWN0KGEucG9pbnRzVG9CdWZmZXIpKHgsRmxvYXQzMkFycmF5LGgpfXN0YXRpYyBVTlNJR05FRF9CWVRFKHgsaCl7cmV0dXJuIE9iamVjdChhLnBvaW50c1RvQnVmZmVyKSh4LFVpbnQ4QXJyYXksaCl9c3RhdGljIFVOU0lHTkVEX1NIT1JUKHgsaCl7cmV0dXJuIE9iamVjdChhLnBvaW50c1RvQnVmZmVyKSh4LFVpbnQxNkFycmF5LGgpfXN0YXRpYyBCWVRFKHgsaCl7cmV0dXJuIE9iamVjdChhLnBvaW50c1RvQnVmZmVyKSh4LEludDhBcnJheSxoKX1zdGF0aWMgU0hPUlQoeCxoKXtyZXR1cm4gT2JqZWN0KGEucG9pbnRzVG9CdWZmZXIpKHgsSW50MTZBcnJheSxoKX1jb25zdHJ1Y3Rvcih4LGg9e30pe3RoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LHkuZGVmYXVsdE9wdGlvbnMsaCksdGhpcy5jYW52YXM9eDtsZXQgbTt0aGlzLm9wdGlvbnMud2ViZ2wyJiYobT14LmdldENvbnRleHQoIndlYmdsMiIsdGhpcy5vcHRpb25zKSksbT09bnVsbCYmKG09T2JqZWN0KGEuc2V0dXBXZWJHTCkoeCx0aGlzLm9wdGlvbnMpLHRoaXMuYWlhX2V4dD1tLmdldEV4dGVuc2lvbigiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpKSx0aGlzLmdsPW0sbS52aWV3cG9ydCgwLDAseC53aWR0aCx4LmhlaWdodCksbS5jbGVhckNvbG9yKDAsMCwwLDApLG0uYmxlbmRGdW5jU2VwYXJhdGUobS5TUkNfQUxQSEEsbS5PTkVfTUlOVVNfU1JDX0FMUEhBLG0uT05FLG0uT05FX01JTlVTX1NSQ19BTFBIQSksdGhpcy5wcm9ncmFtcz1bXSx0aGlzLl9ldmVudHM9e319Z2V0IHByb2dyYW0oKXtjb25zdCB4PXRoaXMuZ2w7cmV0dXJuIHguZ2V0UGFyYW1ldGVyKHguQ1VSUkVOVF9QUk9HUkFNKX1fZGVjbGFyZVVuaWZvcm0oeCxoLG09IjFmIil7Y29uc3Qgcj10aGlzLmdsLGk9ci5nZXRVbmlmb3JtTG9jYXRpb24oeCxoKTtsZXQgbjtjb25zdCBzPXRoaXM7aWYoL15zYW1wbGVyLy50ZXN0KG0pKXtjb25zdCBNPXguX3NhbXBsZXJNYXAsUD14Ll9iaW5kVGV4dHVyZXM7T2JqZWN0LmRlZmluZVByb3BlcnR5KHgudW5pZm9ybXMsaCx7Z2V0KCl7cmV0dXJuIG59LHNldChTKXtuPVM7Y29uc3QgYj1NW2hdIT1udWxsP01baF06UC5sZW5ndGg7UFtiXT1TLGYocixTLGIpLE1baF18fChNW2hdPWIsci51bmlmb3JtMWkoaSxiKSkscy5vcHRpb25zLmF1dG9VcGRhdGUmJnMudXBkYXRlKCl9LGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwfSl9ZWxzZXtjb25zdCBNPW0uaW5kZXhPZigiTWF0cml4Iik9PT0wLFA9IU0mJi92JC8udGVzdChtKSxTPXJbYHVuaWZvcm0ke219YF0uYmluZChyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeC51bmlmb3JtcyxoLHtnZXQoKXtyZXR1cm4gbn0sc2V0KGIpe249Yix0eXBlb2YgYj09Im51bWJlciImJihiPVtiXSksTT9TKGksITEsYik6UD9TKGksYik6UyhpLC4uLmIpLHMub3B0aW9ucy5hdXRvVXBkYXRlJiZzLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfX1fZHJhdygpe2NvbnN0IHg9dGhpcy5wcm9ncmFtO3gubWVzaERhdGEuZm9yRWFjaCgoaCxtKT0+e2NvbnN0e3Bvc2l0aW9uczpyLGNlbGxzOmksaW5zdGFuY2VDb3VudDpuLGNlbGxzQ291bnQ6cyxhdHRyaWJ1dGVzOk0sdW5pZm9ybXM6UCx0ZXh0dXJlQ29vcmQ6UyxlbmFibGVCbGVuZDpifT1oLE89dGhpcy5nbDtsZXQgRD1oLm1vZGUhPW51bGw/aC5tb2RlOk8uVFJJQU5HTEVTO3R5cGVvZiBEPT0ic3RyaW5nIiYmKEQ9T1tEXSksYj9PLmVuYWJsZShPLkJMRU5EKTpPLmRpc2FibGUoTy5CTEVORCksTy5iaW5kQnVmZmVyKE8uQVJSQVlfQlVGRkVSLHguX2J1ZmZlcnMudmVydGljZXNCdWZmZXIpLE8uYnVmZmVyRGF0YShPLkFSUkFZX0JVRkZFUixyLE8uU1RBVElDX0RSQVcpLGkmJihPLmJpbmRCdWZmZXIoTy5FTEVNRU5UX0FSUkFZX0JVRkZFUix4Ll9idWZmZXJzLmNlbGxzQnVmZmVyKSxPLmJ1ZmZlckRhdGEoTy5FTEVNRU5UX0FSUkFZX0JVRkZFUixpLE8uU1RBVElDX0RSQVcpKTtjb25zdCBJPVtdO00mJk9iamVjdC52YWx1ZXMoTSkuZm9yRWFjaCgoe25hbWU6QSxkYXRhOlUsZGl2aXNvcjpLfSk9PntpZihPLmJpbmRCdWZmZXIoTy5BUlJBWV9CVUZGRVIseC5fYnVmZmVyc1tBXSksTy5idWZmZXJEYXRhKE8uQVJSQVlfQlVGRkVSLFUsTy5TVEFUSUNfRFJBVyksSyE9bnVsbCl7Y29uc3QgVj1PLmdldEF0dHJpYkxvY2F0aW9uKHgsQSk7Vj49MCYmKE8uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoViksSS5wdXNoKFYpLE8udmVydGV4QXR0cmliRGl2aXNvcj9PLnZlcnRleEF0dHJpYkRpdmlzb3IoVixLKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoVixLKSl9fSksUCYmT2JqZWN0LmVudHJpZXMoUCkuZm9yRWFjaCgoW0EsVV0pPT57dGhpcy51bmlmb3Jtc1tBXT1VfSk7bGV0IFI7aWYoIWkpe2NvbnN0IEE9eC5fZGltZW5zaW9uO1I9ci5sZW5ndGgvQX1pZih4Ll9lbmFibGVUZXh0dXJlcyYmeC5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcil7Y29uc3QgQT1TfHxjKHIseC5fZGltZW5zaW9uKTtPLmJpbmRCdWZmZXIoTy5BUlJBWV9CVUZGRVIseC5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlciksTy5idWZmZXJEYXRhKE8uQVJSQVlfQlVGRkVSLHkuRkxPQVQoQSksTy5TVEFUSUNfRFJBVyl9biE9bnVsbD8oaT9PLmRyYXdFbGVtZW50c0luc3RhbmNlZD9PLmRyYXdFbGVtZW50c0luc3RhbmNlZChELHMsTy5VTlNJR05FRF9TSE9SVCwwLG4pOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKEQscyxPLlVOU0lHTkVEX1NIT1JULDAsbik6Ty5kcmF3QXJyYXlzSW5zdGFuY2VkP08uZHJhd0FycmF5c0luc3RhbmNlZChELDAsUixuKTp0aGlzLmFpYV9leHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKEQsMCxSLG4pLEkuZm9yRWFjaChBPT57Ty52ZXJ0ZXhBdHRyaWJEaXZpc29yP08udmVydGV4QXR0cmliRGl2aXNvcihBLG51bGwpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShBLG51bGwpfSkpOmk/Ty5kcmF3RWxlbWVudHMoRCxzLE8uVU5TSUdORURfU0hPUlQsMCk6Ty5kcmF3QXJyYXlzKEQsMCxSKX0pfWdldCBpc1dlYkdMMigpe3JldHVybiB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDwidSImJnRoaXMuZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0fWdldCBlbmFibGVUZXh0dXJlcygpe3JldHVybiB0aGlzLnByb2dyYW0mJnRoaXMucHJvZ3JhbS5fZW5hYmxlVGV4dHVyZXN9Z2V0IHVuaWZvcm1zKCl7Y29uc3QgeD10aGlzLnByb2dyYW07aWYoIXh8fCF4LnVuaWZvcm1zKXRocm93IEVycm9yKCJObyBhdmFsaWFibGUgcHJvZ3JhbS4iKTtyZXR1cm4geC51bmlmb3Jtc31kZWxldGVQcm9ncmFtKHgpe2NvbnN0IGg9dGhpcy5nbDt0aGlzLnByb2dyYW09PT14JiYodGhpcy5zdGFydFJlbmRlcj0hMSx0aGlzLl9yZW5kZXJGcmFtZUlEJiYoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyRnJhbWVJRCksZGVsZXRlIHRoaXMuX3JlbmRlckZyYW1lSUQpLGgudXNlUHJvZ3JhbShudWxsKSk7Y29uc3QgbT10aGlzLnByb2dyYW1zLmluZGV4T2YoeCk7bT49MCYmdGhpcy5wcm9ncmFtcy5zcGxpY2UobSwxKSxFKGgseCksaC5kZWxldGVQcm9ncmFtKHgpfXNldE1lc2hEYXRhKHgpe0FycmF5LmlzQXJyYXkoeCl8fCh4PVt4XSk7Y29uc3QgaD10aGlzLnByb2dyYW07aC5tZXNoRGF0YT14Lm1hcCgoe21vZGU6bSxwb3NpdGlvbnM6cixpbnN0YW5jZUNvdW50OmksY2VsbHM6bixjZWxsc0NvdW50OnMsYXR0cmlidXRlczpNLHVuaWZvcm1zOlAsdGV4dHVyZUNvb3JkOlMsZW5hYmxlQmxlbmQ6Yn0pPT57Y29uc3QgTz17cG9zaXRpb25zOnkuRkxPQVQociksdW5pZm9ybXM6UCxlbmFibGVCbGVuZDohIWIsdGV4dHVyZUNvb3JkOnkuRkxPQVQoUyl9O2lmKG4mJihPLmNlbGxzPXkuVVNIT1JUKG4pLE8uY2VsbHNDb3VudD1zfHxPLmNlbGxzLmxlbmd0aCksbSE9bnVsbCYmKE8ubW9kZT1tKSxpIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgaW5zdGFuY2VDb3VudCBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtPLmluc3RhbmNlQ291bnQ9aX1pZihNKXtjb25zdCBEPXt9O09iamVjdC5lbnRyaWVzKE0pLmZvckVhY2goKFtJLFJdKT0+e2lmKCFoLl9hdHRyaWJ1dGVbSV0paC5fYXR0cmlidXRlW0ldPSJpZ25vcmVkIjtlbHNlIGlmKGguX2F0dHJpYnV0ZVtJXSE9PSJpZ25vcmVkIil7Y29uc3R7bmFtZTpBLHR5cGU6VX09aC5fYXR0cmlidXRlW0ldO2xldCBLPVIuZGF0YXx8UjtpZihBcnJheS5pc0FycmF5KEspJiYoSz15W1VdKEspKSxEW0ldPXtuYW1lOkEsZGF0YTpLfSxSLmRpdmlzb3IhPW51bGwpe2lmKCF0aGlzLmlzV2ViR0wyJiYhdGhpcy5haWFfZXh0KXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHVzZSBkaXZpc29yIGluIHRoaXMgcmVuZGVyaW5nIGNvbnRleHQsIHVzZSB3ZWJnbDIgY29udGV4dCBpbnN0ZWFkLiIpO0RbSV0uZGl2aXNvcj1SLmRpdmlzb3J9fX0pLE8uYXR0cmlidXRlcz1EfXJldHVybiBPfSksdGhpcy5vcHRpb25zLmF1dG9VcGRhdGUmJnRoaXMudXBkYXRlKCl9Y3JlYXRlUHJvZ3JhbSh4LGgpe2NvbnN0IG09L15ccyp1bmlmb3JtXHMrc2FtcGxlci9tZy50ZXN0KHgpO3g9PW51bGwmJih4PXYuZGVmYXVsdCksaD09bnVsbCYmKGg9bT9ULmRlZmF1bHQ6by5kZWZhdWx0KTtjb25zdCByPXRoaXMuZ2wsaT1PYmplY3QoYS5jcmVhdGVQcm9ncmFtKShyLGgseCk7aS5zaGFkZXJUZXh0PXt2ZXJ0ZXhTaGFkZXI6aCxmcmFnbWVudFNoYWRlcjp4fSxpLl9idWZmZXJzPXt9LGkuX2F0dHJpYnV0ZT17fSxpLnVuaWZvcm1zPXt9LGkuX3NhbXBsZXJNYXA9e30saS5fYmluZFRleHR1cmVzPVtdO2NvbnN0IG49bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhQb3NpdGlvbn1gLCJpbSIpO2xldCBzPWgubWF0Y2gobik7cyYmKGkuX2RpbWVuc2lvbj1OdW1iZXIoc1sxXSkpO2NvbnN0IE09bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhUZXh0dXJlQ29vcmR9YCwiaW0iKTtzPWgubWF0Y2goTSkscyYmKGkuX3RleENvb3JkU2l6ZT1OdW1iZXIoc1sxXSkpO2NvbnN0IFA9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2dpbTtpZihzPWgubWF0Y2goUCkscylmb3IobGV0IE89MDtPPHMubGVuZ3RoO08rKyl7Y29uc3QgRD0vXlxzKig/OmF0dHJpYnV0ZXxpbikgKFx3Kz8pKFxkKikgKFx3KykvaW0sST1zW09dLm1hdGNoKEQpO2lmKEkmJklbM10hPT10aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24mJklbM10hPT10aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKXtsZXRbLFIsQSxVXT1JO1I9PT0ibWF0IiYmKEEqKj0yKSxpLl9idWZmZXJzW1VdPXIuY3JlYXRlQnVmZmVyKCksaS5fYXR0cmlidXRlW1VdPXtuYW1lOlUsdHlwZTpSLHNpemU6TnVtYmVyKEEpfHwxfX19Y29uc3QgUz0vXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy9tZztzPWgubWF0Y2goUyl8fFtdLHM9cy5jb25jYXQoeC5tYXRjaChTKXx8W10pLHMuZm9yRWFjaChPPT57Y29uc3QgRD1PLm1hdGNoKC9eXHMqdW5pZm9ybVxzKyhcdyspXHMrKFx3KykoXFtcZCtcXSk/Lyk7bGV0W0ksUixBXT1ELnNsaWNlKDEpO0k9Z1tJXSxBPSEhQSxJLmluZGV4T2YoIk1hdHJpeCIpIT09MCYmQSYmKEkrPSJ2IiksdGhpcy5fZGVjbGFyZVVuaWZvcm0oaSxSLEkpfSksaS5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcj1yLmNyZWF0ZUJ1ZmZlcigpLGkuX2J1ZmZlcnMuY2VsbHNCdWZmZXI9ci5jcmVhdGVCdWZmZXIoKTtjb25zdCBiPXIuZ2V0QXR0cmliTG9jYXRpb24oaSx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtyZXR1cm4gaS5fZW5hYmxlVGV4dHVyZXM9Yj49MCxpLl9lbmFibGVUZXh0dXJlcyYmKGkuX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXI9ci5jcmVhdGVCdWZmZXIoKSksdGhpcy5wcm9ncmFtcy5wdXNoKGkpLGl9dXNlUHJvZ3JhbSh4LGg9e30pe3RoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKTtjb25zdCBtPXRoaXMuZ2w7bS51c2VQcm9ncmFtKHgpO2NvbnN0IHI9eC5fZGltZW5zaW9uO20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKTtjb25zdCBpPW0uZ2V0QXR0cmliTG9jYXRpb24oeCx0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24pO2lmKG0udmVydGV4QXR0cmliUG9pbnRlcihpLHIsbS5GTE9BVCwhMSwwLDApLG0uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSkseC5fZW5hYmxlVGV4dHVyZXMpe20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzLnRleENvb3JkQnVmZmVyKTtjb25zdCBuPW0uZ2V0QXR0cmliTG9jYXRpb24oeCx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTttLnZlcnRleEF0dHJpYlBvaW50ZXIobix4Ll90ZXhDb29yZFNpemV8fDIsbS5GTE9BVCwhMSwwLDApLG0uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobil9aWYoT2JqZWN0LmVudHJpZXMoeC5fYXR0cmlidXRlKS5mb3JFYWNoKChbbixzXSk9PntpZihzIT09Imlnbm9yZWQiKXtjb25zdCBNPXMuc2l6ZSxQPWhbbl18fHt9LFM9ISFQLm5vcm1hbGl6ZTtsZXQgYj1QLnR5cGV8fCJGTE9BVCI7Y29uc3QgTz1QLmtleXx8bjtiPT09IlVCWVRFIiYmKGI9IlVOU0lHTkVEX0JZVEUiKSxiPT09IlVTSE9SVCImJihiPSJVTlNJR05FRF9TSE9SVCIpLHMudHlwZT1iLE8mJk8hPT1uJiYoeC5fYXR0cmlidXRlW09dPXMpLG0uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUix4Ll9idWZmZXJzW25dKTtjb25zdCBEPW0uZ2V0QXR0cmliTG9jYXRpb24oeCxuKTtEPj0wJiYobS52ZXJ0ZXhBdHRyaWJQb2ludGVyKEQsTSxtW2JdLFMsMCwwKSxtLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEQpKX19KSwheC5tZXNoRGF0YSl7Y29uc3Qgbj1bWy0xLC0xLDAsMV0uc2xpY2UoMCxyKSxbMSwtMSwwLDFdLnNsaWNlKDAsciksWzEsMSwwLDFdLnNsaWNlKDAsciksWy0xLDEsMCwxXS5zbGljZSgwLHIpXSxzPVtbMCwxLDNdLFszLDEsMl1dO3RoaXMuc2V0TWVzaERhdGEoe3Bvc2l0aW9uczpuLGNlbGxzOnN9KX1yZXR1cm4geH1jb21waWxlU3luYyh4LGgpe3g9eHx8di5kZWZhdWx0O2NvbnN0IG09e307ZnVuY3Rpb24gcihNKXtNPU0ucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgUD1bXSxTPU0ubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihTKXtmb3IobGV0IGI9MDtiPFMubGVuZ3RoO2IrKyl7Y29uc3QgRD1TW2JdLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihEKXtjb25zdCBJPURbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9RFsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIiksbVtSXSlQLnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKG1bUl09ITAsST09PSJsaWIiKXtjb25zdCBBPXIodVtSXSk7UC5wdXNoKEEpfWVsc2UgaWYoST09PSJsaW5rIil0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBsb2FkIGV4dGVybmFsIGxpbmtzIHN5bmNocm9ub3VzbHkuIFVzZSBjb21waWxlIGluc3RlYWQgb2YgY29tcGlsZVN5bmMuIil9fVAuZm9yRWFjaChiPT57TT1NLnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sYil9KX1yZXR1cm4gTX1jb25zdCBpPXIoeCksbj1oP3IoaCk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGksbil9YXN5bmMgY29tcGlsZSh4LGgpe3g9eHx8di5kZWZhdWx0O2NvbnN0IG09e307YXN5bmMgZnVuY3Rpb24gcihNKXtNPU0ucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgUD1bXSxTPU0ubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihTKXtmb3IobGV0IGI9MDtiPFMubGVuZ3RoO2IrKyl7Y29uc3QgRD1TW2JdLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihEKXtjb25zdCBJPURbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFI9RFsxXTtpZihSPT09ImdyYXBoIiYmKFI9ImdyYXBoaWNzIiksbVtSXSlQLnB1c2goYC8qIGluY2x1ZGVkICR7Un0gKi9gKTtlbHNlIGlmKG1bUl09ITAsST09PSJsaWIiKXtjb25zdCBBPWF3YWl0IHIodVtSXSk7UC5wdXNoKEEpfWVsc2UgaWYoST09PSJsaW5rIil7bGV0IEE9YXdhaXQgeS5mZXRjaFNoYWRlcihSKTtBPWF3YWl0IHIoQSksUC5wdXNoKEEpfX19UC5mb3JFYWNoKGI9PntNPU0ucmVwbGFjZSgvXiNwcmFnbWFccytpbmNsdWRlXHMrLiovbSxiKX0pfXJldHVybiBNfWNvbnN0IGk9YXdhaXQgcih4KSxuPWg/YXdhaXQgcihoKTpudWxsO3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oaSxuKX1hc3luYyBsb2FkKHgsaD1udWxsKXtyZXR1cm4geD1hd2FpdCB5LmZldGNoU2hhZGVyKHgpLGgmJihoPWF3YWl0IHkuZmV0Y2hTaGFkZXIoaCkpLHRoaXMuY29tcGlsZSh4LGgpfWNyZWF0ZVRleHR1cmUoeD1udWxsLHt3cmFwUzpoPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSx3cmFwVDptPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSxtaW5GaWx0ZXI6cj10aGlzLmdsLkxJTkVBUixtYWdGaWx0ZXI6aT10aGlzLmdsLkxJTkVBUn09e30pe2NvbnN0IG49dGhpcy5nbCxzPUFycmF5LmlzQXJyYXkoeCk/bi5URVhUVVJFX0NVQkVfTUFQOm4uVEVYVFVSRV8yRDt0aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0cz10aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0c3x8bi5nZXRQYXJhbWV0ZXIobi5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyksbi5hY3RpdmVUZXh0dXJlKG4uVEVYVFVSRTArdGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHMtMSk7Y29uc3QgTT1uLmNyZWF0ZVRleHR1cmUoKTtuLmJpbmRUZXh0dXJlKHMsTSksbi5waXhlbFN0b3JlaShuLlVOUEFDS19GTElQX1lfV0VCR0wsITApO2NvbnN0e3dpZHRoOlAsaGVpZ2h0OlN9PXRoaXMuY2FudmFzO2lmKHgpaWYocz09PW4uVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IGI9MDtiPDY7YisrKW4udGV4SW1hZ2UyRChuLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtiLDAsbi5SR0JBLG4uUkdCQSxuLlVOU0lHTkVEX0JZVEUseFtiXSk7ZWxzZSBuLnRleEltYWdlMkQocywwLG4uUkdCQSxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLHgpO2Vsc2UgaWYocz09PW4uVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IGI9MDtiPDY7YisrKXRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtiLDAsbi5SR0JBLFAsUywwLG4uUkdCQSxuLlVOU0lHTkVEX0JZVEUsbnVsbCk7ZWxzZSBuLnRleEltYWdlMkQocywwLG4uUkdCQSxQLFMsMCxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLG51bGwpO3JldHVybiBuLnRleFBhcmFtZXRlcmkocyxuLlRFWFRVUkVfTUlOX0ZJTFRFUixyKSxuLnRleFBhcmFtZXRlcmkocyxuLlRFWFRVUkVfTUFHX0ZJTFRFUixpKSxuLnRleFBhcmFtZXRlcmkocyxuLlRFWFRVUkVfV1JBUF9TLGgpLG4udGV4UGFyYW1ldGVyaShzLG4uVEVYVFVSRV9XUkFQX1QsbSkscz09PW4uVEVYVFVSRV9DVUJFX01BUCYmKHgud2lkdGg9eFswXS53aWR0aCx4LmhlaWdodD14WzBdLmhlaWdodCksbi5iaW5kVGV4dHVyZShzLG51bGwpLE0uX2ltZz14fHx7d2lkdGg6UCxoZWlnaHQ6U30sTS5kZWxldGU9KCk9Pnt0aGlzLmRlbGV0ZVRleHR1cmUoTSl9LE19ZGVsZXRlVGV4dHVyZSh4KXtjb25zdCBoPXguX2ltZzt0aGlzLmdsLmRlbGV0ZVRleHR1cmUoeCksdHlwZW9mIGguY2xvc2U9PSJmdW5jdGlvbiImJmguY2xvc2UoKX1hc3luYyBsb2FkVGV4dHVyZSh4LHt1c2VJbWFnZUJpdG1hcDpoPSEwfT17fSl7Y29uc3QgbT1hd2FpdCB5LmxvYWRJbWFnZSh4LHt1c2VJbWFnZUJpdG1hcDpofSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShtKX1jcmVhdGVGQk8oe2NvbG9yOng9MSxibGVuZDpoPSExLGRlcHRoOm09dGhpcy5vcHRpb25zLmRlcHRoIT09ITEsc3RlbmNpbDpyPSEhdGhpcy5vcHRpb25zLnN0ZW5jaWx9PXt9KXtjb25zdCBpPXRoaXMuZ2wsbj1pLmNyZWF0ZUZyYW1lYnVmZmVyKCk7aS5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixuKTtjb25zdCBzPVtdO2ZvcihsZXQgUz0wO1M8eDtTKyspe2NvbnN0IGI9dGhpcy5jcmVhdGVUZXh0dXJlKCk7aS5mcmFtZWJ1ZmZlclRleHR1cmUyRChpLkZSQU1FQlVGRkVSLGkuQ09MT1JfQVRUQUNITUVOVDArUyxpLlRFWFRVUkVfMkQsYiwwKSxzLnB1c2goYil9bi50ZXh0dXJlcz1zLG4udGV4dHVyZT1zWzBdLG4uYmxlbmQ9aDtjb25zdHt3aWR0aDpNLGhlaWdodDpQfT10aGlzLmNhbnZhcztyZXR1cm4gbSYmIXImJihuLmRlcHRoQnVmZmVyPWkuY3JlYXRlUmVuZGVyYnVmZmVyKCksaS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLG4uZGVwdGhCdWZmZXIpLGkucmVuZGVyYnVmZmVyU3RvcmFnZShpLlJFTkRFUkJVRkZFUixpLkRFUFRIX0NPTVBPTkVOVDE2LE0sUCksaS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLkZSQU1FQlVGRkVSLGkuREVQVEhfQVRUQUNITUVOVCxpLlJFTkRFUkJVRkZFUixuLmRlcHRoQnVmZmVyKSksciYmIW0mJihuLnN0ZW5jaWxCdWZmZXI9aS5jcmVhdGVSZW5kZXJidWZmZXIoKSxpLmJpbmRSZW5kZXJidWZmZXIoaS5SRU5ERVJCVUZGRVIsbi5zdGVuY2lsQnVmZmVyKSxpLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoaS5SRU5ERVJCVUZGRVIsaS5TVEVOQ0lMX0lOREVYOCxNLFApLGkuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoaS5GUkFNRUJVRkZFUixpLlNURU5DSUxfQVRUQUNITUVOVCxpLlJFTkRFUkJVRkZFUixuLnN0ZW5jaWxCdWZmZXIpKSxtJiZyJiYobi5kZXB0aFN0ZW5jaWxCdWZmZXI9aS5jcmVhdGVSZW5kZXJidWZmZXIoKSxpLmJpbmRSZW5kZXJidWZmZXIoaS5SRU5ERVJCVUZGRVIsbi5kZXB0aFN0ZW5jaWxCdWZmZXIpLGkucmVuZGVyYnVmZmVyU3RvcmFnZShpLlJFTkRFUkJVRkZFUixpLkRFUFRIX1NURU5DSUwsTSxQKSxpLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGkuRlJBTUVCVUZGRVIsaS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsaS5SRU5ERVJCVUZGRVIsbi5kZXB0aFN0ZW5jaWxCdWZmZXIpKSxpLmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLG51bGwpLG59YmluZEZCTyh4PW51bGwpe3RoaXMuZmJvPXh9cmVuZGVyKHtjbGVhckJ1ZmZlcjp4PSEwfT17fSl7dGhpcy5zdGFydFJlbmRlcj0hMDtjb25zdCBoPXRoaXMuZ2w7bGV0IG09dGhpcy5wcm9ncmFtO218fChtPXRoaXMuY3JlYXRlUHJvZ3JhbSgpLHRoaXMudXNlUHJvZ3JhbShtKSksdGhpcy5mYm8mJmguYmluZEZyYW1lYnVmZmVyKGguRlJBTUVCVUZGRVIsdGhpcy5mYm8pO2NvbnN0IHI9dGhpcy5vcHRpb25zLmRlcHRoO3ImJmguZW5hYmxlKGguREVQVEhfVEVTVCksdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVR8KHI/dGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUOjApfCh0aGlzLm9wdGlvbnMuc3RlbmNpbD90aGlzLmdsLlNURU5DSUxfQlVGRkVSX0JJVDowKSk7Y29uc3QgaT10aGlzLl9yZW5kZXJGcmFtZUlEO3RoaXMuX2RyYXcoKSx0aGlzLmZibyYmaC5iaW5kRnJhbWVidWZmZXIoaC5GUkFNRUJVRkZFUixudWxsKSx0aGlzLl9yZW5kZXJGcmFtZUlEPT09aSYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9bnVsbCl9dXBkYXRlKCl7dGhpcy5zdGFydFJlbmRlciYmdGhpcy5fcmVuZGVyRnJhbWVJRD09bnVsbCYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyLmJpbmQodGhpcykpKX19ZCh5LCJkZWZhdWx0T3B0aW9ucyIse3ByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMCxhdXRvVXBkYXRlOiEwLHZlcnRleFBvc2l0aW9uOiJhX3ZlcnRleFBvc2l0aW9uIix2ZXJ0ZXhUZXh0dXJlQ29vcmQ6ImFfdmVydGV4VGV4dHVyZUNvb3JkIix3ZWJnbDI6ITF9KSxkKHksIlVCWVRFIix5LlVOU0lHTkVEX0JZVEUpLGQoeSwiVVNIT1JUIix5LlVOU0lHTkVEX1NIT1JUKSxkKHksImZldGNoU2hhZGVyIixhLmZldGNoU2hhZGVyKSxkKHksImxvYWRJbWFnZSIsYS5sb2FkSW1hZ2UpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJzZXR1cFdlYkdMIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImNyZWF0ZVByb2dyYW0iLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwicG9pbnRzVG9CdWZmZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwibG9hZEltYWdlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZldGNoU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBFfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEoZixnKXtjb25zdCB5PVsid2ViZ2wiLCJleHBlcmltZW50YWwtd2ViZ2wiLCJ3ZWJraXQtM2QiLCJtb3otd2ViZ2wiXTtsZXQgQz1udWxsO2ZvcihsZXQgeD0wO3g8eS5sZW5ndGg7Kyt4KXt0cnl7Qz1mLmdldENvbnRleHQoeVt4XSxnKX1jYXRjaHt9aWYoQylicmVha31yZXR1cm4gQ31mdW5jdGlvbiBvKGYsZyl7Y29uc3QgeT1hKGYsZyk7aWYoIXkpdGhyb3cgbmV3IEVycm9yKCJTb3JyeSwgeW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTC4iKTtyZXR1cm4geX1mdW5jdGlvbiB2KGYsZyx5KXtjb25zdCBDPWYuY3JlYXRlU2hhZGVyKGYuVkVSVEVYX1NIQURFUik7aWYoZi5zaGFkZXJTb3VyY2UoQyxnKSxmLmNvbXBpbGVTaGFkZXIoQyksIWYuZ2V0U2hhZGVyUGFyYW1ldGVyKEMsZi5DT01QSUxFX1NUQVRVUykpe2NvbnN0IG09YFZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zi5nZXRTaGFkZXJJbmZvTG9nKEMpfWA7dGhyb3cgbmV3IEVycm9yKG0pfWNvbnN0IHg9Zi5jcmVhdGVTaGFkZXIoZi5GUkFHTUVOVF9TSEFERVIpO2lmKGYuc2hhZGVyU291cmNlKHgseSksZi5jb21waWxlU2hhZGVyKHgpLCFmLmdldFNoYWRlclBhcmFtZXRlcih4LGYuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBtPWBGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zi5nZXRTaGFkZXJJbmZvTG9nKHgpfWA7dGhyb3cgbmV3IEVycm9yKG0pfWNvbnN0IGg9Zi5jcmVhdGVQcm9ncmFtKCk7aWYoZi5hdHRhY2hTaGFkZXIoaCxDKSxmLmF0dGFjaFNoYWRlcihoLHgpLGYubGlua1Byb2dyYW0oaCksIWYuZ2V0UHJvZ3JhbVBhcmFtZXRlcihoLGYuTElOS19TVEFUVVMpKXtjb25zdCBtPWBTaGFkZXIgcHJvZ3JhbSBmYWlsZWQgdG8gbGluay4gIFRoZSBlcnJvciBsb2cgaXM6JHtmLmdldFByb2dyYW1JbmZvTG9nKGgpfWA7dGhyb3cgbmV3IEVycm9yKG0pfXJldHVybiBmLmRlbGV0ZVNoYWRlcihDKSxmLmRlbGV0ZVNoYWRlcih4KSxofWZ1bmN0aW9uIFQoZixnPUZsb2F0MzJBcnJheSx5PW51bGwpe2lmKHkmJiEoeSBpbnN0YW5jZW9mIGcpKXRocm93IG5ldyBUeXBlRXJyb3IoIldyb25nIGJ1ZmZlciB0eXBlLiIpO2lmKGY9PW51bGx8fGYgaW5zdGFuY2VvZiBnKXJldHVybiBmO2lmKGZbMF09PW51bGx8fGZbMF0ubGVuZ3RoPT1udWxsKXJldHVybiB5Pyh5LnNldChmLDApLHkpOm5ldyBnKGYpO2NvbnN0IEM9ZlswXS5sZW5ndGgseD1mLmxlbmd0aDt5fHwoeT1uZXcgZyhDKngpKTtsZXQgaD0wO2ZvcihsZXQgbT0wO208eDttKyspZm9yKGxldCByPTA7cjxDO3IrKyl5W2grK109ZlttXVtyXTtyZXR1cm4geX1jb25zdCBkPXt9O2Z1bmN0aW9uIHUoZix7dXNlSW1hZ2VCaXRtYXA6Zz0hMCxhbGlhczp5PW51bGx9PXt9KXtpZighZFtmXSl7aWYodHlwZW9mIEltYWdlPT0iZnVuY3Rpb24iKXtjb25zdCBDPW5ldyBJbWFnZTt0eXBlb2YgZj09InN0cmluZyImJiEodHlwZW9mIGxvY2F0aW9uPT0ib2JqZWN0IiYmL15maWxlOi8udGVzdChsb2NhdGlvbi5ocmVmKSkmJiEvXmRhdGE6Ly50ZXN0KGYpJiYoQy5jcm9zc09yaWdpbj0iYW5vbnltb3VzIiksZFtmXT1uZXcgUHJvbWlzZSh4PT57Qy5vbmxvYWQ9ZnVuY3Rpb24oKXtnJiZ0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXA9PSJmdW5jdGlvbiI/Y3JlYXRlSW1hZ2VCaXRtYXAoQyx7aW1hZ2VPcmllbnRhdGlvbjoiZmxpcFkifSkudGhlbihoPT57ZFtmXT1oLHkmJihkW3ldPWgpLHgoaCl9KTooZFtmXT1DLHkmJihkW3ldPUMpLHgoQykpfSxDLnNyYz1mfSkseSYmKGRbeV09ZFtmXSl9ZWxzZSBpZih0eXBlb2YgZmV0Y2g9PSJmdW5jdGlvbiIpcmV0dXJuIGZldGNoKGYse21ldGhvZDoiR0VUIixtb2RlOiJjb3JzIixjYWNoZToiZGVmYXVsdCJ9KS50aGVuKEM9PkMuYmxvYigpKS50aGVuKEM9PmNyZWF0ZUltYWdlQml0bWFwKEMse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4oeD0+KGRbZl09eCx5JiYoZFt5XT14KSx4KSkpfXJldHVybiBkW2ZdfWNvbnN0IGM9e307YXN5bmMgZnVuY3Rpb24gRShmKXtpZihjW2ZdKXJldHVybiBjW2ZdO2NvbnN0IGc9YXdhaXQgZmV0Y2goZik7aWYoZy5zdGF0dXM+PTIwMCYmZy5zdGF0dXM8MzAwKXtjb25zdCB5PWF3YWl0IGcudGV4dCgpO3JldHVybiBjW2ZdPXkseX10aHJvdyBuZXcgRXJyb3IoIlNoYWRlciBsb2FkZWQgZXJyb3IuIil9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfdmVydGV4UG9zaXRpb24sIDEpOwp9YH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YCNpZmRlZiBHTF9FUwpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjEpOwp9YH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWM0IGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSBhX3ZlcnRleFBvc2l0aW9uOwogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKfWB9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgYT10KDIxKSxvPXQoMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB2PVN5bWJvbCgidHJhbnNmb3JtIik7Y2xhc3MgVHtjb25zdHJ1Y3Rvcih1LGMpe3RoaXMuY29udGV4dD11LmdldENvbnRleHQoIjJkIiksdGhpcy5vcHRpb25zPWMsdGhpc1t2XT1bMSwwLDAsMSwwLDBdfWNyZWF0ZVRleHR1cmUodSl7cmV0dXJue19pbWc6dX19YXN5bmMgbG9hZFRleHR1cmUodSl7Y29uc3QgYz1hd2FpdCBhLmRlZmF1bHQubG9hZEltYWdlKHUse3VzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShjKX1kZWxldGVUZXh0dXJlKHUpe3JldHVybiB1fWNsZWFyKHUsYyxFLGYpe2NvbnN0IGc9dGhpcy5jb250ZXh0O3U9dXx8MCxjPWN8fDAsRT1FfHxnLmNhbnZhcy53aWR0aC11LGY9Znx8Zy5jYW52YXMuaGVpZ2h0LWMsZy5jbGVhclJlY3QodSxjLEUsZil9ZHJhd01lc2hDbG91ZCh1LHtjbGVhcjpjPSExfT17fSl7Y29uc3QgRT1bXTtmb3IobGV0IGY9MDtmPHUuYW1vdW50O2YrKyl7Y29uc3QgZz11LmdldFRyYW5zZm9ybShmKTtsZXQgeT11LmdldFRleHR1cmVGcmFtZShmKTt5JiYoeT15Ll9pbWcpO2NvbnN0IEM9dS5nZXRGaWx0ZXIoZikse2ZpbGw6eCxzdHJva2U6aH09dS5nZXRDbG91ZFJHQkEoZik7RS5wdXNoKHttZXNoOnUubWVzaCxfY2xvdWRPcHRpb25zOlt4LGgseSxnLENdfSl9dS5iZWZvcmVSZW5kZXImJnUuYmVmb3JlUmVuZGVyKHRoaXMuY29udGV4dCx1KSx0aGlzLmRyYXdNZXNoZXMoRSx7Y2xlYXI6Yyxob29rOiExfSksdS5hZnRlclJlbmRlciYmdS5hZnRlclJlbmRlcih0aGlzLmNvbnRleHQsdSl9ZHJhd01lc2hlcyh1LHtjbGVhcjpjPSExLGhvb2s6RT0hMH09e30pe2NvbnN0IGY9dGhpcy5jb250ZXh0O2MmJmYuY2xlYXJSZWN0KDAsMCxmLmNhbnZhcy53aWR0aCxmLmNhbnZhcy5oZWlnaHQpO2xldCBnPW51bGw7Y29uc3R7d2lkdGg6eSxoZWlnaHQ6Q309Zi5jYW52YXMseD11Lmxlbmd0aDt1LmZvckVhY2goKGgsbSk9PntsZXQgcixpLG4scyxNO0UmJmguYmVmb3JlUmVuZGVyJiZoLmJlZm9yZVJlbmRlcihmLGgpLGguX2Nsb3VkT3B0aW9ucyYmKFtyLGksbixzLE1dPWguX2Nsb3VkT3B0aW9ucyxoPWgubWVzaCk7bGV0IFA9aC5maWx0ZXI7aWYoTSYmKFA9UD9gJHtQfSAke019YDpNKSxQJiYhdGhpcy5maWx0ZXJCdWZmZXImJnRoaXMuZmlsdGVyQnVmZmVyIT09ITEpe2NvbnN0IFM9YS5kZWZhdWx0LmNyZWF0ZUNhbnZhcyh5LEMpO1M/dGhpcy5maWx0ZXJCdWZmZXI9Uy5nZXRDb250ZXh0KCIyZCIpOnRoaXMuZmlsdGVyQnVmZmVyPSExfWcmJmchPT1QJiYoT2JqZWN0KG8uYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLGcpLGYuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAseSxDKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHksQyksZz1udWxsKSxQJiZ0aGlzLmZpbHRlckJ1ZmZlcj8odGhpcy5maWx0ZXJCdWZmZXIuc2F2ZSgpLHRoaXMuZmlsdGVyQnVmZmVyLnRyYW5zZm9ybSguLi50aGlzW3ZdKSxPYmplY3Qoby5kcmF3TWVzaDJEKShoLHRoaXMuZmlsdGVyQnVmZmVyLCExLHIsaSxuLHMpLHRoaXMuZmlsdGVyQnVmZmVyLnJlc3RvcmUoKSxtPT09eC0xPyhPYmplY3Qoby5hcHBseUZpbHRlcikodGhpcy5maWx0ZXJCdWZmZXIsUCksZi5kcmF3SW1hZ2UodGhpcy5maWx0ZXJCdWZmZXIuY2FudmFzLDAsMCx5LEMpLHRoaXMuZmlsdGVyQnVmZmVyLmNsZWFyUmVjdCgwLDAseSxDKSk6Zz1QKTooZi5zYXZlKCksZi50cmFuc2Zvcm0oLi4udGhpc1t2XSksT2JqZWN0KG8uZHJhd01lc2gyRCkoaCxmLCExLHIsaSxuLHMpLGYucmVzdG9yZSgpKSxFJiZoLmFmdGVyUmVuZGVyJiZoLmFmdGVyUmVuZGVyKGYsaCl9KX1zZXRUcmFuc2Zvcm0odSl7dGhpc1t2XT11fX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKGEpe3ZhciBvPXQoMTQpLHY9dCgyMyksVD10KDI0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD17fTtmdW5jdGlvbiB1KHksQyl7Y29uc3R7c3R5bGU6eCx2YXJpYW50Omgsd2VpZ2h0Om0sc3RyZXRjaDpyLHNpemU6aSxweExpbmVIZWlnaHQ6bixmYW1pbHk6c309eTtyZXR1cm4gcj09PSJub3JtYWwiP2Ake3h9ICR7aH0gJHttfSAke2kqQ31weC8ke24qQ31weCAke3N9YDpgJHt4fSAke2h9ICR7bX0gJHtyfSAke2kqQ31weC8ke24qQ31weCAke3N9YH1mdW5jdGlvbiBjKHkse2ZvbnQ6QyxmaWxsQ29sb3I6eCxzdHJva2VDb2xvcjpoLHN0cm9rZVdpZHRoOm0scmF0aW86cj0xLHRleHRDYW52YXM6aSxjYWNoYWJsZTpuPSExfSl7bGV0IHM7aWYobil7cz1beSxDLFN0cmluZyh4KSxTdHJpbmcoaCksU3RyaW5nKG0pXS5qb2luKCIjIyMiKTtjb25zdCBLPWRbc107aWYoSylyZXR1cm4gS31pfHwoaT1mKDEsMSkpO2NvbnN0IE09aS5nZXRDb250ZXh0KCIyZCIpO00uc2F2ZSgpLE0uZm9udD1DO2xldHt3aWR0aDpQfT1NLm1lYXN1cmVUZXh0KHkpO00ucmVzdG9yZSgpO2NvbnN0IFM9T2JqZWN0KHYuZGVmYXVsdCkoQyksYj1NYXRoLm1heChTLnB4TGluZUhlaWdodCxTLnB4SGVpZ2h0KjEuMTMpOy9pdGFsaWN8b2JsaXF1ZS8udGVzdChDKSYmKFArPWIqTWF0aC50YW4oMTUqTWF0aC5QSS8xODApKSwheCYmIWgmJih4PSIjMDAwIik7Y29uc3QgTz1NLmNhbnZhcyxEPU1hdGguY2VpbChQKSxJPU1hdGguY2VpbChiKTtPLndpZHRoPU1hdGgucm91bmQoRCpyKSxPLmhlaWdodD1NYXRoLnJvdW5kKEkqciksTS5zYXZlKCksTS5mb250PXUoUyxyKSxNLnRleHRBbGlnbj0iY2VudGVyIixNLnRleHRCYXNlbGluZT0ibWlkZGxlIjtjb25zdCBSPU8uaGVpZ2h0Ki41K1MucHhIZWlnaHQqLjA1KnIsQT1PLndpZHRoKi41O2lmKHgpe2lmKEFycmF5LmlzQXJyYXkoeCkpeD1PYmplY3QoVC5kZWZhdWx0KSh4KTtlbHNlIGlmKHgudmVjdG9yKXtsZXQgSztjb25zdHt2ZWN0b3I6Vixjb2xvcnM6UX09eDtWLmxlbmd0aD09PTY/Sz1NLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLlYpOks9TS5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5WKSxRLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpXfSk9PntLLmFkZENvbG9yU3RvcChxLFcpfSkseD1LfU0uZmlsbFN0eWxlPXgsTS5maWxsVGV4dCh5LEEsUil9aWYoaCl7aWYoTS5saW5lV2lkdGg9bSpyLEFycmF5LmlzQXJyYXkoaCkpaD1PYmplY3QoVC5kZWZhdWx0KShoKTtlbHNlIGlmKGgudmVjdG9yKXtsZXQgSztjb25zdHt2ZWN0b3I6Vixjb2xvcnM6UX09aDtWLmxlbmd0aD09PTY/Sz1NLmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLlYpOks9TS5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5WKSxRLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpXfSk9PntLLmFkZENvbG9yU3RvcChxLFcpfSksaD1LfU0uc3Ryb2tlU3R5bGU9aCxNLnN0cm9rZVRleHQoeSxBLFIpfU0ucmVzdG9yZSgpO2NvbnN0IFU9e2ltYWdlOmkscmVjdDpbMCwwLEQsSV19O3JldHVybiBuJiYoZFtzXT1VKSxVfWxldCBFPSExO2lmKHR5cGVvZiBuYXZpZ2F0b3I9PSJvYmplY3QiJiZ0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudD09InN0cmluZyIpe2NvbnN0IHk9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9jaHJvbWVcLyhcZCspLyk7eSYmKEU9TnVtYmVyKHlbMV0pPDcwKX1mdW5jdGlvbiBmKHksQyx4PXt9KXtjb25zdCBoPXgub2Zmc2NyZWVufHwhRSYmeC5vZmZzY3JlZW4hPT0hMTtsZXQgbTtyZXR1cm4gdHlwZW9mIGE8InUiJiZ0eXBlb2YgYS5jcmVhdGVDYW52YXM9PSJmdW5jdGlvbiI/bT1hLmNyZWF0ZUNhbnZhcyh5LEMseCk6aCYmdHlwZW9mIE9mZnNjcmVlbkNhbnZhcz09ImZ1bmN0aW9uIj9tPW5ldyBPZmZzY3JlZW5DYW52YXMoeSxDKToobT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxtLndpZHRoPXksbS5oZWlnaHQ9QyksbX1jb25zdCBnPXtjcmVhdGVDYW52YXM6ZixjcmVhdGVUZXh0OmMsbG9hZEltYWdlOm8uZGVmYXVsdC5sb2FkSW1hZ2V9O2UuZGVmYXVsdD1nfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oTCxlKXt2YXIgdDt0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3Q9dHx8bmV3IEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCl9Y2F0Y2h7dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJih0PXdpbmRvdyl9TC5leHBvcnRzPXR9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShoLG0pe2lmKHR5cGVvZiBoPT0ic3RyaW5nIil7Y29uc3Qgbj1oLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbnwlKSQvKTtuP2g9e3NpemU6cGFyc2VGbG9hdChuWzFdKSx1bml0Om5bMl19Omg9e3NpemU6cGFyc2VJbnQoaCwxMCksdW5pdDoicHgifX1sZXR7c2l6ZTpyLHVuaXQ6aX09aDtpZihpPT09InB0IilyLz0uNzU7ZWxzZSBpZihpPT09InBjIilyKj0xNjtlbHNlIGlmKGk9PT0iaW4iKXIqPTk2O2Vsc2UgaWYoaT09PSJjbSIpcio9OTYvMi41NDtlbHNlIGlmKGk9PT0ibW0iKXIqPTk2LzI1LjQ7ZWxzZSBpZihpPT09ImVtInx8aT09PSJyZW0ifHxpPT09ImV4Iil7aWYoIW0mJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBuPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTttPWEobiwxNil9cio9bSxpPT09ImV4IiYmKHIvPTIpfWVsc2UgaWYoaT09PSJxIilyKj05Ni8yNS40LzQ7ZWxzZSBpZihpPT09InZ3Inx8aT09PSJ2aCIpe2lmKHR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IG49aT09PSJ2dyI/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7cio9bi8xMDB9fWVsc2UgaWYoKGk9PT0idm1heCJ8fGk9PT0idm1pbiIpJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBuPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxzPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7aT09PSJ2bWF4Ij9yKj1NYXRoLm1heChuLHMpLzEwMDpyKj1NYXRoLm1pbihuLHMpLzEwMH1yZXR1cm4gcn1jb25zdCBvPSJib2xkfGJvbGRlcnxsaWdodGVyfFsxLTldMDAiLHY9Iml0YWxpY3xvYmxpcXVlIixUPSJzbWFsbC1jYXBzIixkPSJ1bHRyYS1jb25kZW5zZWR8ZXh0cmEtY29uZGVuc2VkfGNvbmRlbnNlZHxzZW1pLWNvbmRlbnNlZHxzZW1pLWV4cGFuZGVkfGV4cGFuZGVkfGV4dHJhLWV4cGFuZGVkfHVsdHJhLWV4cGFuZGVkIix1PSJweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSIsYz1gJyhbXiddKyknfCIoW14iXSspInwoW1xcdy1dfFvkuIAt6b6lXSkrYCxFPW5ldyBSZWdFeHAoYCgke299KSArYCwiaSIpLGY9bmV3IFJlZ0V4cChgKCR7dn0pICtgLCJpIiksZz1uZXcgUmVnRXhwKGAoJHtUfSkgK2AsImkiKSx5PW5ldyBSZWdFeHAoYCgke2R9KSArYCwiaSIpLEM9bmV3IFJlZ0V4cCgiKFtcXGRcXC5dKykoIit1KyIpKD86XFwvKFtcXGRcXC5dKykoIit1KyIpKT8gKigoPzoiK2MrIikoICosICooPzoiK2MrIikpKikiKTtmdW5jdGlvbiB4KGgsbSl7Y29uc3Qgcj1DLmV4ZWMoaCk7aWYoIXIpcmV0dXJuO2NvbnN0IGk9cGFyc2VGbG9hdChyWzNdKSxuPXt3ZWlnaHQ6Im5vcm1hbCIsc3R5bGU6Im5vcm1hbCIsc3RyZXRjaDoibm9ybWFsIix2YXJpYW50OiJub3JtYWwiLHNpemU6cGFyc2VGbG9hdChyWzFdKSx1bml0OnJbMl0sbGluZUhlaWdodDpOdW1iZXIuaXNGaW5pdGUoaSk/aTp2b2lkIDAsbGluZUhlaWdodFVuaXQ6cls0XSxmYW1pbHk6cls1XS5yZXBsYWNlKC8gKiwgKi9nLCIsIil9LHM9aC5zdWJzdHJpbmcoMCxyLmluZGV4KSxNPUUuZXhlYyhzKSxQPWYuZXhlYyhzKSxTPWcuZXhlYyhzKSxiPXkuZXhlYyhzKTtyZXR1cm4gTSYmKG4ud2VpZ2h0PU1bMV0pLFAmJihuLnN0eWxlPVBbMV0pLFMmJihuLnZhcmlhbnQ9U1sxXSksYiYmKG4uc3RyZXRjaD1iWzFdKSxuLnB4SGVpZ2h0PWEoe3NpemU6bi5zaXplLHVuaXQ6bi51bml0fSxtKSxuLnB4TGluZUhlaWdodD1hKHtzaXplOm4ubGluZUhlaWdodHx8bi5zaXplLHVuaXQ6bi5saW5lSGVpZ2h0VW5pdHx8bi51bml0fSxtKSxufX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKG8pe3JldHVybmByZ2JhKCR7by5tYXAoKHYsVCk9PlQ8Mz9NYXRoLnJvdW5kKHYqMjU1KTp2KS5qb2luKCl9KWB9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJhcHBseUZpbHRlciIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJkcmF3TWVzaDJEIixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCgxKSxvPXQoMjQpLHY9dCgyMyksVD10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZChFLGYpe2NvbnN0IGc9RS5jYW52YXM7RS5zYXZlKCksRS5maWx0ZXI9ZixFLmRyYXdJbWFnZShnLDAsMCxnLndpZHRoLGcuaGVpZ2h0KSxFLnJlc3RvcmUoKX1mdW5jdGlvbiB1KEUsZil7Y29uc3QgZz0vcmdiYVwoKFxkKyksKFxkKyksKFxkKyksKFxkKylcKS87RT1FLm1hdGNoKGcpLnNsaWNlKDEsNSkubWFwKE51bWJlciksZj1mLm1hdGNoKGcpLnNsaWNlKDEsNSkubWFwKE51bWJlcik7Y29uc3QgeT1bXSxDPWZbM107Zm9yKGxldCB4PTA7eDw0O3grKyl5W3hdPU9iamVjdChULm1peCkoRVt4XSxmW3hdLEMpO3JldHVybmByZ2JhKCR7eS5qb2luKCl9KWB9ZnVuY3Rpb24gYyhFLGYsZz0hMCx5PW51bGwsQz1udWxsLHg9bnVsbCxoPW51bGwpe2Yuc2F2ZSgpO2xldCBtPSExLHI9ITE7aWYoZi5nbG9iYWxBbHBoYT1FLmdldE9wYWNpdHkoKSxFLl91cGRhdGVNYXRyaXgmJkUudHJhbnNmb3JtU2NhbGUvRS5jb250b3Vycy5zY2FsZT4xLjUmJkUuYWNjdXJhdGUoRS50cmFuc2Zvcm1TY2FsZSksRS5saW5lV2lkdGgpe2xldCBzPUUuZ3JhZGllbnQmJkUuZ3JhZGllbnQuc3Ryb2tlO2lmKHMpe2NvbnN0e3ZlY3RvcjpNLGNvbG9yczpQfT1zO2lmKE0ubGVuZ3RoPT09NilzPWYuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4uTSk7ZWxzZSBpZihNLmxlbmd0aD09PTQpcz1mLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLk0pO2Vsc2UgaWYoTS5sZW5ndGg9PT0zKXM9Zi5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLk0pO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO1AuZm9yRWFjaCgoe29mZnNldDpTLGNvbG9yOmJ9KT0+e2xldCBPPU9iamVjdChvLmRlZmF1bHQpKGIpO0MmJihPPXUoTyxDKSkscy5hZGRDb2xvclN0b3AoUyxPKX0pLGYuc3Ryb2tlU3R5bGU9cyxtPSEwfWVsc2UgRS5zdHJva2VTdHlsZSYmKEM/Zi5zdHJva2VTdHlsZT11KEUuc3Ryb2tlU3R5bGUsQyk6Zi5zdHJva2VTdHlsZT1FLnN0cm9rZVN0eWxlLG09ITApfW0mJihmLmxpbmVXaWR0aD1FLmxpbmVXaWR0aCxmLmxpbmVKb2luPUUubGluZUpvaW4sZi5saW5lQ2FwPUUubGluZUNhcCxmLm1pdGVyTGltaXQ9RS5taXRlckxpbWl0LEUubGluZURhc2gmJihmLnNldExpbmVEYXNoKEUubGluZURhc2gpLEUubGluZURhc2hPZmZzZXQmJihmLmxpbmVEYXNoT2Zmc2V0PUUubGluZURhc2hPZmZzZXQpKSk7bGV0IGk9RS5ncmFkaWVudCYmRS5ncmFkaWVudC5maWxsO2lmKGkpe2NvbnN0e3ZlY3RvcjpzLGNvbG9yczpNfT1pO2lmKHMubGVuZ3RoPT09NilpPWYuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4ucyk7ZWxzZSBpZihzLmxlbmd0aD09PTQpaT1mLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLnMpO2Vsc2UgaWYocy5sZW5ndGg9PT0zKWk9Zi5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLnMpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO00uZm9yRWFjaCgoe29mZnNldDpQLGNvbG9yOlN9KT0+e2xldCBiPU9iamVjdChvLmRlZmF1bHQpKFMpO0MmJihiPXUoYixDKSksaS5hZGRDb2xvclN0b3AoUCxiKX0pLGYuZmlsbFN0eWxlPWkscj0hMH1lbHNlIEUuZmlsbFN0eWxlJiYoeT9mLmZpbGxTdHlsZT11KEUuZmlsbFN0eWxlLHkpOmYuZmlsbFN0eWxlPUUuZmlsbFN0eWxlLHI9ITApO2lmKGgmJmYudHJhbnNmb3JtKC4uLmgpLGYudHJhbnNmb3JtKC4uLkUudHJhbnNmb3JtTWF0cml4KSxFLmNsaXBQYXRoKXtjb25zdCBzPUUuY2xpcFBhdGgsTT1uZXcgUGF0aDJEKHMpO2YuY2xpcChNKX1jb25zdCBuPUUuY29udG91cnMubGVuZ3RoO2lmKEUuY29udG91cnMuZm9yRWFjaCgocyxNKT0+e2NvbnN0IFA9cy5sZW5ndGgsUz1QPjEmJmEudmVjMi5lcXVhbHMoc1swXSxzW1AtMV0pLGI9TT09PW4tMSYmRS50ZXh0dXJlO2lmKHMmJlA+MCl7aWYocnx8bXx8Yil7Zi5iZWdpblBhdGgoKSxmLm1vdmVUbyguLi5zWzBdKTtmb3IobGV0IE89MTtPPFA7TysrKU89PT1QLTEmJlM/Zi5jbG9zZVBhdGgoKTpmLmxpbmVUbyguLi5zW09dKX1pZihyJiZmLmZpbGwoRS5maWxsUnVsZSksYil7Zi5zYXZlKCksZi5jbGlwKCk7bGV0e2ltYWdlOk8sb3B0aW9uczpEfT1FLnRleHR1cmU7aWYoeCYmKE89eCksRC5yZXBlYXQmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIGltYWdlIHJlcGVhdCB5ZXQuIiksTy5mb250KXtELnNjYWxlJiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNjYWxlIHlldC4iKSxELnNyY1JlY3QmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIHRleHQgc3JjUmVjdCB5ZXQuIik7bGV0e2ZvbnQ6SSxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpBLHN0cm9rZVdpZHRoOlUsdGV4dDpLfT1POyFSJiYhQSYmKFI9IiMwMDAiKSxBcnJheS5pc0FycmF5KFIpJiYoUj1PYmplY3Qoby5kZWZhdWx0KShSKSksQXJyYXkuaXNBcnJheShBKSYmKEE9T2JqZWN0KG8uZGVmYXVsdCkoQSkpLGYuZm9udD1JO2NvbnN0e3dpZHRoOlZ9PWYubWVhc3VyZVRleHQoSyksUT1PYmplY3Qodi5kZWZhdWx0KShJKSxxPU1hdGgubWF4KFEucHhMaW5lSGVpZ2h0LFEucHhIZWlnaHQqMS4xMyk7Zi50ZXh0QWxpZ249ImNlbnRlciIsZi50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgVz1ELnJlY3QsSD1XWzBdK3EqLjUrUS5weEhlaWdodCouMDYsWj1XWzFdK1YqLjU7V1syXSE9bnVsbCYmZi5zY2FsZShXWzJdL1YsV1szXS9xKSxSJiYoZi5maWxsU3R5bGU9UixmLmZpbGxUZXh0KEssWixIKSksQSYmKGYubGluZVdpZHRoPVUsZi5zdHJva2VTdHlsZT1BLGYuc3Ryb2tlVGV4dChLLFosSCkpfWVsc2V7bGV0IEk9RC5yZWN0O2NvbnN0IFI9RC5zcmNSZWN0O0Quc2NhbGUmJihJPVswLDAsZi5jYW52YXMud2lkdGgsZi5jYW52YXMuaGVpZ2h0XSksRC5yb3RhdGVkJiZJJiYoST1bLUlbMV0sSVswXSxJWzNdLElbMl1dKSxSJiYoST1JfHxbMCwwLFJbMl0sUlszXV0pLEQucm90YXRlZCYmKGYudHJhbnNsYXRlKDAsST9JWzJdOk8ud2lkdGgpLGYucm90YXRlKC0uNSpNYXRoLlBJKSksUj9mLmRyYXdJbWFnZShPLC4uLlIsLi4uSSk6ST9mLmRyYXdJbWFnZShPLC4uLkkpOmYuZHJhd0ltYWdlKE8sMCwwKX1mLnJlc3RvcmUoKX1tJiZmLnN0cm9rZSgpfX0pLGYucmVzdG9yZSgpLGcpe2NvbnN0IHM9RS5maWx0ZXI7cyYmZChmLHMpfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNsYW1wIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsIm1peCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJ0cmFuc2Zvcm1Qb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKFQsZCx1KXtyZXR1cm4gZD51JiYoW2QsdV09W3UsZF0pLFQ8ZD9kOlQ+dT91OlR9ZnVuY3Rpb24gbyhULGQsdSl7cmV0dXJuIFQqKDEtdSkrZCp1fWZ1bmN0aW9uIHYoVCxkKXtjb25zdFt1LGNdPVQ7cmV0dXJuW3UqZFswXStjKmRbMl0rZFs0XSx1KmRbMV0rYypkWzNdK2RbNV1dfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBhPXQoMjgpLG89dCgyOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYoYyxFLGYpe2NvbnN0IGc9Yy51bmlmb3Jtc3x8e30seT1FLnVuaWZvcm1zfHx7fTtpZihnLnVfdGV4U2FtcGxlciYmeS51X3RleFNhbXBsZXImJmcudV90ZXhTYW1wbGVyIT09eS51X3RleFNhbXBsZXIpcmV0dXJuITE7Y29uc3QgQz1PYmplY3Qua2V5cyhnKSx4PU9iamVjdC5rZXlzKHkpLGg9Qy5pbmRleE9mKCJ1X3RleFNhbXBsZXIiKSxtPXguaW5kZXhPZigidV90ZXhTYW1wbGVyIik7aWYoaD49MCYmQy5zcGxpY2UoaCwxKSxtPj0wJiZ4LnNwbGljZShtLDEpLEMubGVuZ3RoIT09eC5sZW5ndGgpcmV0dXJuITE7Y29uc3Qgcj1DLmV2ZXJ5KGk9Pntjb25zdCBuPWdbaV0scz15W2ldO2lmKG49PT1zKXJldHVybiEwO2lmKG4ubGVuZ3RoJiZzLmxlbmd0aCYmbi5sZW5ndGg9PT1zLmxlbmd0aCl7Zm9yKGxldCBNPTA7TTxuLmxlbmd0aDtNKyspaWYobltNXSE9PXNbTV0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9KTtpZihyKXtpZihnLnVfdGV4U2FtcGxlciYmIXkudV90ZXhTYW1wbGVyKUUuc2V0VGV4dHVyZShnLnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSk7ZWxzZSBpZighZy51X3RleFNhbXBsZXImJnkudV90ZXhTYW1wbGVyKWZvcihsZXQgaT0wO2k8Zi5sZW5ndGg7aSsrKWZbaV0uc2V0VGV4dHVyZSh5LnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSl9cmV0dXJuIHJ9Y29uc3QgVD17fTtmdW5jdGlvbiBkKGMsRSl7aWYoYy5sZW5ndGgpe2NvbnN0IGY9T2JqZWN0KGEuZGVmYXVsdCkoYyxUKTtyZXR1cm4gZi5lbmFibGVCbGVuZD1FLGNbMF0uZmlsdGVyQ2FudmFzJiYoZi5maWx0ZXJDYW52YXM9ITApLGYucGFja0luZGV4PWNbMF0ucGFja0luZGV4LGYucGFja0xlbmd0aD1jLmxlbmd0aCxmLmJlZm9yZVJlbmRlcj1jWzBdLmJlZm9yZVJlbmRlcixmLnBhc3M9Y1swXS5wYXNzLGYuYWZ0ZXJSZW5kZXI9Y1tjLmxlbmd0aC0xXS5hZnRlclJlbmRlcixjLmxlbmd0aD0wLGZ9fWZ1bmN0aW9uKnUoYyxFLGY9ITEpe2NvbnN0IGc9W10seT1jLm9wdGlvbnMuYnVmZmVyU2l6ZTtsZXQgQz0wLHg9ITE7Zm9yKGxldCBoPTA7aDxFLmxlbmd0aDtoKyspe2NvbnN0IG09RVtoXTtpZihtIGluc3RhbmNlb2Ygby5kZWZhdWx0KWcubGVuZ3RoJiYoeWllbGQgZChnLHgpKSxDPTAseD0hMSx5aWVsZCBtO2Vsc2V7Y29uc3Qgcj1tLm1lc2hEYXRhO2lmKHIuY2xpcFBhdGgmJiFyLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXIpe2NvbnN0IG49Yy5jcmVhdGVUZXh0dXJlKHIuY2xpcFBhdGgpO3IudW5pZm9ybXMudV9jbGlwU2FtcGxlcj1ufWxldCBpPTA7aWYoKCFmfHwhbS5jYW5JZ25vcmUoKSkmJnImJnIucG9zaXRpb25zLmxlbmd0aCl7bS5wYWNrSW5kZXg9aDtjb25zdCBuPW0uZmlsdGVyQ2FudmFzO2lmKGk9ci5wb3NpdGlvbnMubGVuZ3RoLG58fEMraT55KWcubGVuZ3RoJiYoeWllbGQgZChnLHgpKSxDPTAseD0hMTtlbHNlIGlmKEMpe2NvbnN0IHM9Z1tnLmxlbmd0aC0xXTtzJiYocy5maWx0ZXJDYW52YXN8fHMuYWZ0ZXJSZW5kZXJ8fG0uYmVmb3JlUmVuZGVyfHxzLnBhc3MubGVuZ3RofHxtLnBhc3MubGVuZ3RofHxzLnByb2dyYW0hPT1tLnByb2dyYW18fCF2KHMsbSxnKSkmJih5aWVsZCBkKGcseCksQz0wLHg9ITEpfWcucHVzaChtKSx4PXh8fG0uZW5hYmxlQmxlbmQsQys9aX1oPT09RS5sZW5ndGgtMSYmZy5sZW5ndGgmJih5aWVsZCBkKGcseCkpfX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB2fSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGE9e1VOU0lHTkVEX0JZVEU6VWludDhBcnJheSxVTlNJR05FRF9TSE9SVDpVaW50MTZBcnJheSxCWVRFOkludDhBcnJheSxTSE9SVDpJbnQxNkFycmF5LEZMT0FUOkZsb2F0MzJBcnJheX07ZnVuY3Rpb24gbyhULGQpe2xldCB1PTAsYz0wLEU9MCxmPTAsZz0wLHk9MCxDPTA7Y29uc3QgeD1UWzBdLnByb2dyYW07Zm9yKGxldCBoPTA7aDxULmxlbmd0aDtoKyspe2NvbnN0IG09VFtoXS5tZXNoRGF0YTtpZihtKXtDKz1tLnBvc2l0aW9ucy5sZW5ndGg7Y29uc3Qgcj1tLnBvc2l0aW9uc1swXS5sZW5ndGg7dSs9bS5wb3NpdGlvbnMubGVuZ3RoKnIsYys9bS5jZWxscy5sZW5ndGgqMyx5Kz1tLmF0dHJpYnV0ZXMuYV9jb2xvci5sZW5ndGgqNDtjb25zdCBpPW0udGV4dHVyZUNvb3JkO2kmJihFKz1pLmxlbmd0aCppWzBdLmxlbmd0aCk7Y29uc3Qgbj1tLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O24mJihmKz1uLmxlbmd0aCo0KTtjb25zdCBzPW0uYXR0cmlidXRlcy5hX2NsaXBVVjtzJiYoZys9cy5sZW5ndGgqMil9fWlmKCghZC5wb3NpdGlvbnN8fGQucG9zaXRpb25zLmxlbmd0aDx1KSYmKGQucG9zaXRpb25zPW5ldyBGbG9hdDMyQXJyYXkodSkpLCghZC5jZWxsc3x8ZC5jZWxscy5sZW5ndGg8YykmJihkLmNlbGxzPW5ldyBVaW50MTZBcnJheShjKSksRSYmKCFkLnRleHR1cmVDb29yZHx8ZC50ZXh0dXJlQ29vcmQubGVuZ3RoPEUpJiYoZC50ZXh0dXJlQ29vcmQ9bmV3IEZsb2F0MzJBcnJheShFKSksKCFkLmFfY29sb3J8fGQuYV9jb2xvci5sZW5ndGg8eSkmJihkLmFfY29sb3I9bmV3IFVpbnQ4QXJyYXkoeSkpLGYmJighZC5hX3NvdXJjZVJlY3R8fGQuYV9zb3VyY2VSZWN0Lmxlbmd0aDxmKSYmKGQuYV9zb3VyY2VSZWN0PW5ldyBGbG9hdDMyQXJyYXkoZikpLGcmJighZC5hX2NsaXBVVnx8ZC5hX2NsaXBVVi5sZW5ndGg8ZykmJihkLmFfY2xpcFVWPW5ldyBGbG9hdDMyQXJyYXkoZykpLHgpe2NvbnN0IGg9T2JqZWN0LmVudHJpZXMoeC5fYXR0cmlidXRlKSxtPXguX2F0dHJpYk9wdHN8fHt9O2ZvcihsZXQgcj0wO3I8aC5sZW5ndGg7cisrKXtjb25zdFtpLG5dPWhbcl07aWYoaSE9PSJhX2NvbG9yIiYmaSE9PSJhX3NvdXJjZVJlY3QiJiZuIT09Imlnbm9yZWQiKXtjb25zdCBzPW1baV0/bVtpXS50eXBlOiJGTE9BVCIsTT1hW3NdLFA9bi5zaXplKkM7KCFkW2ldfHxkW2ldLmxlbmd0aDxQKSYmKGRbaV09bmV3IE0oUCkpfX19cmV0dXJuIGR9ZnVuY3Rpb24gdihULGQpe2xldCB1PVtdLGM9W10sRT1bXSxmPVtdLGc9W10seT1bXSxDPTAseD0wO2NvbnN0IGg9VFswXT9UWzBdLnVuaWZvcm1zfHx7fTp7fSxtPVRbMF0/VFswXS5wcm9ncmFtOm51bGw7ZCYmKG8oVCxkKSxjPWQuY2VsbHMsdT1kLnBvc2l0aW9ucyxFPWQudGV4dHVyZUNvb3JkLGY9ZC5hX2NvbG9yLGc9ZC5hX3NvdXJjZVJlY3QseT1kLmFfY2xpcFVWKTtsZXQgcj0hMSxpPSExO2NvbnN0IG49e307Zm9yKGxldCBNPTA7TTxULmxlbmd0aDtNKyspe2xldCBQPVRbTV07aWYoUCl7aWYoUC5tZXNoRGF0YSYmKFA9UC5tZXNoRGF0YSksZCl7Y29uc3QgYj1QLnBvc2l0aW9ucztmb3IobGV0IE89MDtPPGIubGVuZ3RoO08rKyl7Y29uc3QgRD1iW09dLEk9MyooQytPKTtmb3IobGV0IFI9MDtSPEQubGVuZ3RoO1IrKyl1W0krUl09RFtSXX19ZWxzZSB1LnB1c2goLi4uUC5wb3NpdGlvbnMpO2NvbnN0IFM9UC5jZWxscztmb3IobGV0IGI9MDtiPFMubGVuZ3RoO2IrKyl7Y29uc3QgTz1TW2JdO2lmKGQpe2NvbnN0IEQ9MyooeCtiKTtjW0RdPU9bMF0rQyxjW0QrMV09T1sxXStDLGNbRCsyXT1PWzJdK0N9ZWxzZSBjLnB1c2goW09bMF0rQyxPWzFdK0MsT1syXStDXSl9aWYoZCl7Y29uc3QgYj1QLmF0dHJpYnV0ZXMuYV9jb2xvcjtmb3IobGV0IE89MDtPPGIubGVuZ3RoO08rKyl7Y29uc3QgRD1iW09dLEk9NCooQytPKTtmW0ldPURbMF0sZltJKzFdPURbMV0sZltJKzJdPURbMl0sZltJKzNdPURbM119fWVsc2UgZi5wdXNoKC4uLlAuYXR0cmlidXRlcy5hX2NvbG9yKTtpZihQLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0KWlmKHI9ITAsZCl7Y29uc3QgYj1QLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2ZvcihsZXQgTz0wO088Yi5sZW5ndGg7TysrKXtjb25zdCBEPWJbT10sST00KihDK08pO2dbSV09RFswXSxnW0krMV09RFsxXSxnW0krMl09RFsyXSxnW0krM109RFszXX19ZWxzZSBnLnB1c2goLi4uUC5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdCk7aWYoUC5hdHRyaWJ1dGVzLmFfY2xpcFVWKWlmKGk9ITAsZCl7Y29uc3QgYj1QLmF0dHJpYnV0ZXMuYV9jbGlwVVY7Zm9yKGxldCBPPTA7TzxiLmxlbmd0aDtPKyspe2NvbnN0IEQ9YltPXSxJPTIqKEMrTyk7eVtJXT1EWzBdLHlbSSsxXT1EWzFdfX1lbHNlIHkucHVzaCguLi5QLmF0dHJpYnV0ZXMuYV9jbGlwVVYpO2lmKFAudGV4dHVyZUNvb3JkKWlmKGQpe2NvbnN0IGI9UC50ZXh0dXJlQ29vcmQ7Zm9yKGxldCBPPTA7TzxiLmxlbmd0aDtPKyspe2NvbnN0IEQ9YltPXSxJPTMqKEMrTyk7Zm9yKGxldCBSPTA7UjxELmxlbmd0aDtSKyspRVtJK1JdPURbUl19fWVsc2UgRS5wdXNoKC4uLlAudGV4dHVyZUNvb3JkKTtpZihtKXtjb25zdCBiPU9iamVjdC5lbnRyaWVzKG0uX2F0dHJpYnV0ZSk7Zm9yKGxldCBPPTA7TzxiLmxlbmd0aDtPKyspe2NvbnN0W0QsSV09YltPXTtpZihEIT09ImFfY29sb3IiJiZEIT09ImFfc291cmNlUmVjdCImJkkhPT0iaWdub3JlZCIpaWYobltEXT1bXSxkKXtuW0RdPWRbRF07Y29uc3QgUj1QLmF0dHJpYnV0ZXNbRF0sQT1SWzBdLmxlbmd0aDtmb3IobGV0IFU9MDtVPFIubGVuZ3RoO1UrKyl7Y29uc3QgSz1SW1VdLFY9QSooQytVKTtmb3IobGV0IFE9MDtRPEsubGVuZ3RoO1ErKyluW0RdW1YrUV09S1tRXX19ZWxzZSBuW0RdLnB1c2goLi4uUC5hdHRyaWJ1dGVzW0RdKX19Qys9UC5wb3NpdGlvbnMubGVuZ3RoLHgrPVAuY2VsbHMubGVuZ3RofX1uLmFfY29sb3I9ZixyJiZnJiZnLmxlbmd0aD4wJiYobi5hX3NvdXJjZVJlY3Q9Zyk7Y29uc3Qgcz17cG9zaXRpb25zOnUsY2VsbHM6YyxhdHRyaWJ1dGVzOm4sdW5pZm9ybXM6aCxjZWxsc0NvdW50OngqMyxwcm9ncmFtOm19O3JldHVybiBFJiZFLmxlbmd0aCYmKHMudGV4dHVyZUNvb3JkPUUpLGkmJnkubGVuZ3RoPjAmJihuLmFfY2xpcFVWPXkpLHN9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpO3ZhciBhPXQoMSksbz10KDMwKSx2PXQoMjYpLFQ9dCgzMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGQobixzKXt2YXIgTT1PYmplY3Qua2V5cyhuKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgUD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG4pO3MmJihQPVAuZmlsdGVyKGZ1bmN0aW9uKFMpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sUykuZW51bWVyYWJsZX0pKSxNLnB1c2guYXBwbHkoTSxQKX1yZXR1cm4gTX1mdW5jdGlvbiB1KG4pe2Zvcih2YXIgcz0xO3M8YXJndW1lbnRzLmxlbmd0aDtzKyspe3ZhciBNPWFyZ3VtZW50c1tzXSE9bnVsbD9hcmd1bWVudHNbc106e307cyUyP2QoT2JqZWN0KE0pLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKFApe2MobixQLE1bUF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhNKSk6ZChPYmplY3QoTSkpLmZvckVhY2goZnVuY3Rpb24oUCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sUCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE0sUCkpfSl9cmV0dXJuIG59ZnVuY3Rpb24gYyhuLHMsTSl7cmV0dXJuIHMgaW4gbj9PYmplY3QuZGVmaW5lUHJvcGVydHkobixzLHt2YWx1ZTpNLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6bltzXT1NLG59Y29uc3QgRT1TeW1ib2woIm1lc2giKSxmPVN5bWJvbCgiY291bnQiKSxnPVN5bWJvbCgiYmxlbmQiKSx5PVN5bWJvbCgiZmlsdGVyIiksQz1TeW1ib2woInRleHR1cmVzIikseD1TeW1ib2woInRleHR1cmVPcHRpb25zIiksaD1TeW1ib2woImNsb3VkQ29sb3IiKSxtPVN5bWJvbCgiY2xvdWRGaWx0ZXIiKSxyPVN5bWJvbCgiYnVmZmVyIik7ZnVuY3Rpb24gaShuLHM9bnVsbCl7Y29uc3QgTT1uZXcgRmxvYXQzMkFycmF5KDMqbiksUD1uZXcgRmxvYXQzMkFycmF5KDMqbiksUz1uZXcgRmxvYXQzMkFycmF5KDQqbiksYj1uZXcgRmxvYXQzMkFycmF5KDQqbiksTz1uZXcgRmxvYXQzMkFycmF5KDQqbiksRD1uZXcgRmxvYXQzMkFycmF5KDQqbiksST1uZXcgRmxvYXQzMkFycmF5KDQqbiksUj1uZXcgVWludDhBcnJheShuKSxBPW5ldyBVaW50OEFycmF5KDQqbiksVT1uZXcgVWludDhBcnJheSg0Km4pO3JldHVybiBzJiYoTS5zZXQocy50cmFuc2Zvcm0wLDApLFAuc2V0KHMudHJhbnNmb3JtMSwwKSxTLnNldChzLmNvbG9yMCwwKSxiLnNldChzLmNvbG9yMSwwKSxPLnNldChzLmNvbG9yMiwwKSxELnNldChzLmNvbG9yMywwKSxJLnNldChzLmNvbG9yNCwwKSxSLnNldChzLmZyYW1lSW5kZXgsMCksQS5zZXQocy5maWxsQ29sb3IsMCksVS5zZXQocy5zdHJva2VDb2xvciwwKSkse2J1ZmZlclNpemU6bix0cmFuc2Zvcm0wOk0sdHJhbnNmb3JtMTpQLGNvbG9yMDpTLGNvbG9yMTpiLGNvbG9yMjpPLGNvbG9yMzpELGNvbG9yNDpJLGZyYW1lSW5kZXg6UixmaWxsQ29sb3I6QSxzdHJva2VDb2xvcjpVfX1lLmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IobixzPTEse2J1ZmZlcjpNPTFlM309e30pe009TWF0aC5tYXgoTSxzKSx0aGlzW2ZdPXMsdGhpc1tFXT1uLHRoaXNbcl09aShNKSx0aGlzW0NdPVtdLHRoaXNbeV09W10sdGhpc1toXT0hMSx0aGlzW21dPSExLHRoaXNbZ109ITEsdGhpcy5pbml0QnVmZmVyKCl9aW5pdEJ1ZmZlcihuPTApe2NvbnN0IHM9dGhpc1tmXTtmb3IobGV0IE09bjtNPHM7TSsrKXRoaXNbcl0udHJhbnNmb3JtMC5zZXQoWzEsMCwwXSxNKjMpLHRoaXNbcl0udHJhbnNmb3JtMS5zZXQoWzAsMSwwXSxNKjMpLHRoaXNbcl0uZnJhbWVJbmRleC5zZXQoWy0xXSxNKSx0aGlzW3JdLmZpbGxDb2xvci5zZXQoWzAsMCwwLDBdLE0qNCksdGhpc1tyXS5zdHJva2VDb2xvci5zZXQoWzAsMCwwLDBdLE0qNCksdGhpcy5zZXRDb2xvclRyYW5zZm9ybShNLG51bGwpfWdldCBidWZmZXJTaXplKCl7cmV0dXJuIHRoaXNbcl0uYnVmZmVyU2l6ZX1nZXQgbWVzaCgpe3JldHVybiB0aGlzW0VdfXNldCBtZXNoKG4pe3RoaXNbRV09bix0aGlzW0NdJiZ0aGlzLnNldFRleHR1cmVGcmFtZXModGhpc1tDXSx0aGlzW3hdKX1nZXQgaGFzQ2xvdWRDb2xvcigpe3JldHVybiB0aGlzW2hdfWdldCBoYXNDbG91ZEZpbHRlcigpe3JldHVybiB0aGlzW21dfV9nZXRGaWx0ZXIobil7cmV0dXJuIHRoaXNbeV1bbl09dGhpc1t5XVtuXXx8W10sdGhpc1t5XVtuXX1nZXRGaWx0ZXIobil7cmV0dXJuIHRoaXMuX2dldEZpbHRlcihuKS5qb2luKCIgIil9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbRV0uZW5hYmxlQmxlbmR8fHRoaXNbZ119Y2FuSWdub3JlKCl7cmV0dXJuIHRoaXNbRV0uY2FuSWdub3JlKCl9ZGVsZXRlKG4pe2lmKG4+PXRoaXNbZl18fG48MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdHt0cmFuc2Zvcm0wOnMsdHJhbnNmb3JtMTpNLGNvbG9yMDpQLGNvbG9yMTpTLGNvbG9yMjpiLGNvbG9yMzpPLGNvbG9yNDpELGZyYW1lSW5kZXg6SSxmaWxsQ29sb3I6UixzdHJva2VDb2xvcjpBfT10aGlzW3JdO3Muc2V0KHMuc3ViYXJyYXkoMyoobisxKSksMypuKSxNLnNldChNLnN1YmFycmF5KDMqKG4rMSkpLDMqbiksUC5zZXQoUC5zdWJhcnJheSg0KihuKzEpKSw0Km4pLFMuc2V0KFMuc3ViYXJyYXkoNCoobisxKSksNCpuKSxiLnNldChiLnN1YmFycmF5KDQqKG4rMSkpLDQqbiksTy5zZXQoTy5zdWJhcnJheSg0KihuKzEpKSw0Km4pLEQuc2V0KEQuc3ViYXJyYXkoNCoobisxKSksNCpuKSxJLnNldChJLnN1YmFycmF5KG4rMSksbiksUi5zZXQoUi5zdWJhcnJheSg0KihuKzEpKSw0Km4pLEEuc2V0KEEuc3ViYXJyYXkoNCoobisxKSksNCpuKTtmb3IoY29uc3QgVSBpbiB0aGlzW3ldKVU9PT1uP2RlbGV0ZSB0aGlzW3ldW1VdOlU+biYmKHRoaXNbeV1bVS0xXT10aGlzW3ldW1VdLGRlbGV0ZSB0aGlzW3ldW1VdKTt0aGlzW2ZdLS19c2V0Q29sb3JUcmFuc2Zvcm0obixzKXtpZihuPj10aGlzW2ZdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7bio9NDtjb25zdHtjb2xvcjA6TSxjb2xvcjE6UCxjb2xvcjI6Uyxjb2xvcjM6Yixjb2xvcjQ6T309dGhpc1tyXTtyZXR1cm4gcyE9bnVsbD8oTS5zZXQoW3NbMF0sc1s1XSxzWzEwXSxzWzE1XV0sbiksUC5zZXQoW3NbMV0sc1s2XSxzWzExXSxzWzE2XV0sbiksUy5zZXQoW3NbMl0sc1s3XSxzWzEyXSxzWzE3XV0sbiksYi5zZXQoW3NbM10sc1s4XSxzWzEzXSxzWzE4XV0sbiksTy5zZXQoW3NbNF0sc1s5XSxzWzE0XSxzWzE5XV0sbiksdGhpc1tnXT10aGlzW2ddfHxzWzE4XTwxLHRoaXNbbV09ITApOihNLnNldChbMSwwLDAsMF0sbiksUC5zZXQoWzAsMSwwLDBdLG4pLFMuc2V0KFswLDAsMSwwXSxuKSxiLnNldChbMCwwLDAsMV0sbiksTy5zZXQoWzAsMCwwLDBdLG4pKSx0aGlzfWdldENvbG9yVHJhbnNmb3JtKG4pe2lmKG4+PXRoaXNbZl18fG48MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtuKj00O2NvbnN0e2NvbG9yMDpzLGNvbG9yMTpNLGNvbG9yMjpQLGNvbG9yMzpTLGNvbG9yNDpifT10aGlzW3JdO3JldHVybltzW25dLE1bbl0sUFtuXSxTW25dLGJbbl0sc1tuKzFdLE1bbisxXSxQW24rMV0sU1tuKzFdLGJbbisxXSxzW24rMl0sTVtuKzJdLFBbbisyXSxTW24rMl0sYltuKzJdLHNbbiszXSxNW24rM10sUFtuKzNdLFNbbiszXSxiW24rM11dfXRyYW5zZm9ybUNvbG9yKG4scyl7bGV0IE09dGhpcy5nZXRDb2xvclRyYW5zZm9ybShuKTtyZXR1cm4gTT1PYmplY3Qoby5tdWx0aXBseSkoTSxzKSx0aGlzLnNldENvbG9yVHJhbnNmb3JtKG4sTSksdGhpc31zZXRGaWxsQ29sb3IobixzKXtpZihuPj10aGlzW2ZdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7dHlwZW9mIHM9PSJzdHJpbmciJiYocz1PYmplY3QoVC5kZWZhdWx0KShzKSksc1szXT4wJiYodGhpc1toXT0hMCksdGhpc1tyXS5maWxsQ29sb3Iuc2V0KHMubWFwKE09Pk1hdGgucm91bmQoMjU1Kk0pKSw0Km4pfXNldFN0cm9rZUNvbG9yKG4scyl7aWYobj49dGhpc1tmXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBzPT0ic3RyaW5nIiYmKHM9T2JqZWN0KFQuZGVmYXVsdCkocykpLHNbM10+MCYmKHRoaXNbaF09ITApLHRoaXNbcl0uc3Ryb2tlQ29sb3Iuc2V0KHMubWFwKE09Pk1hdGgucm91bmQoMjU1Kk0pKSw0Km4pfWdldENsb3VkUkdCQShuKXtpZihuPj10aGlzW2ZdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7bio9NDtjb25zdHtmaWxsQ29sb3I6cyxzdHJva2VDb2xvcjpNfT10aGlzW3JdLFA9W3Nbbl0sc1tuKzFdLHNbbisyXSxzW24rM11dLFM9W01bbl0sTVtuKzFdLE1bbisyXSxNW24rM11dO3JldHVybiBQWzNdLz0yNTUsU1szXS89MjU1LHtmaWxsOmByZ2JhKCR7UC5qb2luKCl9KWAsc3Ryb2tlOmByZ2JhKCR7Uy5qb2luKCl9KWB9fWdyYXlzY2FsZShuLHMpe3RoaXMudHJhbnNmb3JtQ29sb3IobixPYmplY3Qoby5ncmF5c2NhbGUpKHMpKSx0aGlzLl9nZXRGaWx0ZXIobikucHVzaChgZ3JheXNjYWxlKCR7MTAwKnN9JSlgKX1icmlnaHRuZXNzKG4scyl7dGhpcy50cmFuc2Zvcm1Db2xvcihuLE9iamVjdChvLmJyaWdodG5lc3MpKHMpKSx0aGlzLl9nZXRGaWx0ZXIobikucHVzaChgYnJpZ2h0bmVzcygkezEwMCpzfSUpYCl9c2F0dXJhdGUobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KG8uc2F0dXJhdGUpKHMpKSx0aGlzLl9nZXRGaWx0ZXIobikucHVzaChgc2F0dXJhdGUoJHsxMDAqc30lKWApfWNvbnRyYXN0KG4scyl7dGhpcy50cmFuc2Zvcm1Db2xvcihuLE9iamVjdChvLmNvbnRyYXN0KShzKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYGNvbnRyYXN0KCR7MTAwKnN9JSlgKX1pbnZlcnQobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KG8uaW52ZXJ0KShzKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYGludmVydCgkezEwMCpzfSUpYCl9c2VwaWEobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KG8uc2VwaWEpKHMpKSx0aGlzLl9nZXRGaWx0ZXIobikucHVzaChgc2VwaWEoJHsxMDAqc30lKWApfW9wYWNpdHkobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KG8ub3BhY2l0eSkocykpLHRoaXMuX2dldEZpbHRlcihuKS5wdXNoKGBvcGFjaXR5KCR7MTAwKnN9JSlgKX1odWVSb3RhdGUobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KG8uaHVlUm90YXRlKShzKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYGh1ZS1yb3RhdGUoJHtzfWRlZylgKX1zZXRUcmFuc2Zvcm0obixzKXtpZihuPj10aGlzW2ZdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7bio9MyxzPT1udWxsJiYocz1bMSwwLDAsMSwwLDBdKTtjb25zdHt0cmFuc2Zvcm0wOk0sdHJhbnNmb3JtMTpQfT10aGlzW3JdO3JldHVybiBNLnNldChbc1swXSxzWzJdLHNbNF1dLG4pLFAuc2V0KFtzWzFdLHNbM10sc1s1XV0sbiksdGhpc31nZXRUcmFuc2Zvcm0obil7aWYobj49dGhpc1tmXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO24qPTM7Y29uc3R7dHJhbnNmb3JtMDpzLHRyYW5zZm9ybTE6TX09dGhpc1tyXTtyZXR1cm5bc1tuXSxNW25dLHNbbisxXSxNW24rMV0sc1tuKzJdLE1bbisyXV19Z2V0VGV4dHVyZUZyYW1lKG4pe3JldHVybiB0aGlzW0NdW3RoaXNbcl0uZnJhbWVJbmRleFtuXV19c2V0VGV4dHVyZUZyYW1lcyhuPVtdLHM9e30pe2lmKG4ubGVuZ3RoPjEyKXRocm93IG5ldyBFcnJvcigiTWF4IGZyYW1lcyBleGNlZWQuIEFsbG93IDEyIGZyYW1lcy4iKTtuLmxlbmd0aCYmdGhpc1tFXS5zZXRUZXh0dXJlKG5bMF0scyksdGhpc1tDXT1uLHRoaXNbeF09c31zZXRGcmFtZUluZGV4KG4scyl7aWYobj49dGhpc1tmXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2NvbnN0IE09dGhpc1tDXS5sZW5ndGg7aWYoTTw9MCl0aHJvdyBuZXcgRXJyb3IoIk5vIGZyYW1lcyIpO3RoaXNbcl0uZnJhbWVJbmRleFtuXT1zJU19Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2ZdfXNldCBhbW91bnQobil7Y29uc3Qgcz10aGlzW2ZdO24hPT1zJiYobj50aGlzW3JdLmJ1ZmZlclNpemUmJih0aGlzW3JdPWkoTWF0aC5tYXgobix0aGlzW3JdLmJ1ZmZlclNpemUrMWUzKSx0aGlzW3JdKSksdGhpc1tmXT1uLG4+cyYmdGhpcy5pbml0QnVmZmVyKHMpKX1nZXQgbWVzaERhdGEoKXtjb25zdHthdHRyaWJ1dGVzOm4sY2VsbHM6cyxwb3NpdGlvbnM6TSx0ZXh0dXJlQ29vcmQ6UCx1bmlmb3JtczpTfT10aGlzW0VdLm1lc2hEYXRhLGI9dGhpc1tDXSxPPXthdHRyaWJ1dGVzOnUoe30sbiksY2VsbHM6cyxwb3NpdGlvbnM6TSx0ZXh0dXJlQ29vcmQ6UCx1bmlmb3Jtczp1KHt9LFMpLGluc3RhbmNlQ291bnQ6dGhpc1tmXSxlbmFibGVCbGVuZDp0aGlzLmVuYWJsZUJsZW5kfTtiLmxlbmd0aCYmYi5mb3JFYWNoKChILFopPT57Ty51bmlmb3Jtc1tgdV90ZXhGcmFtZSR7Wn1gXT1IfSk7Y29uc3R7dHJhbnNmb3JtMDpELHRyYW5zZm9ybTE6SSxjb2xvcjA6Uixjb2xvcjE6QSxjb2xvcjI6VSxjb2xvcjM6Syxjb2xvcjQ6VixmaWxsQ29sb3I6USxzdHJva2VDb2xvcjpxLGZyYW1lSW5kZXg6V309dGhpc1tyXTtyZXR1cm4gdGhpc1tFXS51bmlmb3Jtcy51X3RleFNhbXBsZXImJihPLmF0dHJpYnV0ZXMuYV9mcmFtZUluZGV4PXtkYXRhOlcsZGl2aXNvcjoxfSksTy5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMD17ZGF0YTpELGRpdmlzb3I6MX0sTy5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMT17ZGF0YTpJLGRpdmlzb3I6MX0sTy5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDA9e2RhdGE6UixkaXZpc29yOjF9LE8uYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQxPXtkYXRhOkEsZGl2aXNvcjoxfSxPLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMj17ZGF0YTpVLGRpdmlzb3I6MX0sTy5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDM9e2RhdGE6SyxkaXZpc29yOjF9LE8uYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQ0PXtkYXRhOlYsZGl2aXNvcjoxfSx0aGlzLmhhc0Nsb3VkQ29sb3ImJihPLmF0dHJpYnV0ZXMuYV9maWxsQ2xvdWRDb2xvcj17ZGF0YTpRLGRpdmlzb3I6MX0sTy5hdHRyaWJ1dGVzLmFfc3Ryb2tlQ2xvdWRDb2xvcj17ZGF0YTpxLGRpdmlzb3I6MX0pLE99c2V0UHJvZ3JhbShuKXt0aGlzW0VdLnNldFByb2dyYW0obil9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1tFXS5wcm9ncmFtfXRyYW5zZm9ybShuLHMpe2NvbnN0IE09dGhpcy5nZXRUcmFuc2Zvcm0obik7cmV0dXJuIHM9YS5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCksTSxzKSx0aGlzLnNldFRyYW5zZm9ybShuLHMpLHRoaXN9dHJhbnNsYXRlKG4sW3MsTV0pe2xldCBQPWEubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFA9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFAsW3MsTV0pLHRoaXMudHJhbnNmb3JtKG4sUCl9cm90YXRlKG4scyxbTSxQXT1bMCwwXSl7bGV0IFM9YS5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gUz1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksUyxbTSxQXSksUz1hLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksUyxzKSxTPWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxTLFstTSwtUF0pLHRoaXMudHJhbnNmb3JtKG4sUyl9c2NhbGUobixbcyxNPXNdLFtQLFNdPVswLDBdKXtsZXQgYj1hLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBiPWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxiLFtQLFNdKSxiPWEubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGIsW3MsTV0pLGI9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGIsWy1QLC1TXSksdGhpcy50cmFuc2Zvcm0obixiKX1za2V3KG4sW3MsTT1zXSxbUCxTXT1bMCwwXSl7bGV0IGI9YS5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gYj1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksYixbUCxTXSksYj1hLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxiLGEubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKE0pLE1hdGgudGFuKHMpLDEsMCwwKSksYj1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksYixbLVAsLVNdKSx0aGlzLnRyYW5zZm9ybShuLGIpfWlzUG9pbnRDb2xsaXNpb24obixbcyxNXSxQPSJib3RoIil7Y29uc3QgUz10aGlzLmdldFRyYW5zZm9ybShuKSxiPU9iamVjdCh2LnRyYW5zZm9ybVBvaW50KShbcyxNXSxhLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksUykpO3JldHVybiB0aGlzW0VdLmlzUG9pbnRDb2xsaXNpb24oLi4uYixQKX1pc1BvaW50SW5GaWxsKG4sW3MsTV0pe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24obixbcyxNXSwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShuLFtzLE1dKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKG4sW3MsTV0sInN0cm9rZSIpfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImdyYXlzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJicmlnaHRuZXNzIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNhdHVyYXRlIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImNvbnRyYXN0IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzZXBpYSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJvcGFjaXR5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImh1ZVJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciBhPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKHksQyl7Y29uc3QgeD1bXSxoPXlbMF0sbT15WzFdLHI9eVsyXSxpPXlbM10sbj15WzRdLHM9eVs1XSxNPXlbNl0sUD15WzddLFM9eVs4XSxiPXlbOV0sTz15WzEwXSxEPXlbMTFdLEk9eVsxMl0sUj15WzEzXSxBPXlbMTRdLFU9eVsxNV0sSz15WzE2XSxWPXlbMTddLFE9eVsxOF0scT15WzE5XTtsZXQgVz1DWzBdLEg9Q1sxXSxaPUNbMl0sdHQ9Q1szXSxfPUNbNF07cmV0dXJuIHhbMF09VypoK0gqcytaKk8rdHQqVSx4WzFdPVcqbStIKk0rWipEK3R0KksseFsyXT1XKnIrSCpQK1oqSSt0dCpWLHhbM109VyppK0gqUytaKlIrdHQqUSx4WzRdPVcqbitIKmIrWipBK3R0KnErXyxXPUNbNV0sSD1DWzZdLFo9Q1s3XSx0dD1DWzhdLF89Q1s5XSx4WzVdPVcqaCtIKnMrWipPK3R0KlUseFs2XT1XKm0rSCpNK1oqRCt0dCpLLHhbN109VypyK0gqUCtaKkkrdHQqVix4WzhdPVcqaStIKlMrWipSK3R0KlEseFs5XT1XKm4rSCpiK1oqQSt0dCpxK18sVz1DWzEwXSxIPUNbMTFdLFo9Q1sxMl0sdHQ9Q1sxM10sXz1DWzE0XSx4WzEwXT1XKmgrSCpzK1oqTyt0dCpVLHhbMTFdPVcqbStIKk0rWipEK3R0KksseFsxMl09VypyK0gqUCtaKkkrdHQqVix4WzEzXT1XKmkrSCpTK1oqUit0dCpRLHhbMTRdPVcqbitIKmIrWipBK3R0KnErXyxXPUNbMTVdLEg9Q1sxNl0sWj1DWzE3XSx0dD1DWzE4XSxfPUNbMTldLHhbMTVdPVcqaCtIKnMrWipPK3R0KlUseFsxNl09VyptK0gqTStaKkQrdHQqSyx4WzE3XT1XKnIrSCpQK1oqSSt0dCpWLHhbMThdPVcqaStIKlMrWipSK3R0KlEseFsxOV09VypuK0gqYitaKkErdHQqcStfLHh9ZnVuY3Rpb24gdih5KXt5PU9iamVjdChhLmNsYW1wKSgwLDEseSk7Y29uc3QgQz0uMjEyNip5LHg9LjcxNTIqeSxoPS4wNzIyKnk7cmV0dXJuW0MrMS15LHgsaCwwLDAsQyx4KzEteSxoLDAsMCxDLHgsaCsxLXksMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gVCh5KXtyZXR1cm5beSwwLDAsMCwwLDAseSwwLDAsMCwwLDAseSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBkKHkpe2NvbnN0IEM9LjIxMjYqKDEteSkseD0uNzE1MiooMS15KSxoPS4wNzIyKigxLXkpO3JldHVybltDK3kseCxoLDAsMCxDLHgreSxoLDAsMCxDLHgsaCt5LDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIHUoeSl7Y29uc3QgQz0uNSooMS15KTtyZXR1cm5beSwwLDAsMCxDLDAseSwwLDAsQywwLDAseSwwLEMsMCwwLDAsMSwwXX1mdW5jdGlvbiBjKHkpe2NvbnN0IEM9MS0yKnk7cmV0dXJuW0MsMCwwLDAseSwwLEMsMCwwLHksMCwwLEMsMCx5LDAsMCwwLDEsMF19ZnVuY3Rpb24gRSh5KXtyZXR1cm5bMS0uNjA3KnksLjc2OSp5LC4xODkqeSwwLDAsLjM0OSp5LDEtLjMxNCp5LC4xNjgqeSwwLDAsLjI3Mip5LC41MzQqeSwxLS44NjkqeSwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBmKHkpe3JldHVyblsxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCx5LDBdfWZ1bmN0aW9uIGcoeSl7Y29uc3QgQz15LzE4MCpNYXRoLlBJLHg9TWF0aC5jb3MoQyksaD1NYXRoLnNpbihDKSxtPS4yMTI2LHI9LjcxNTIsaT0uMDcyMjtyZXR1cm5bbSt4KigxLW0pK2gqLW0scit4Ki1yK2gqLXIsaSt4Ki1pK2gqKDEtaSksMCwwLG0reCotbStoKi4xNDMscit4KigxLXIpK2gqLjE0LGkreCotaStoKi0uMjgzLDAsMCxtK3gqLW0raCotKDEtbSkscit4Ki1yK2gqcixpK3gqKDEtaSkraCppLDAsMCwwLDAsMCwxLDBdfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pO3ZhciBhPXQoMzIpLG89dC5uKGEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB2KFQpe2NvbnN0IGQ9bygpKFQpO2lmKCFkfHwhZC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5bZFswXS8yNTUsZFsxXS8yNTUsZFsyXS8yNTUsZFszXV19fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgzMyksbz10KDM3KSx2PXQoMzkpO0wuZXhwb3J0cz1mdW5jdGlvbihkKXt2YXIgdSxjPWEoZCk7cmV0dXJuIGMuc3BhY2U/KHU9QXJyYXkoMyksdVswXT12KGMudmFsdWVzWzBdLDAsMjU1KSx1WzFdPXYoYy52YWx1ZXNbMV0sMCwyNTUpLHVbMl09dihjLnZhbHVlc1syXSwwLDI1NSksYy5zcGFjZVswXT09PSJoIiYmKHU9by5yZ2IodSkpLHUucHVzaCh2KGMuYWxwaGEsMCwxKSksdSk6W119fSxmdW5jdGlvbihMLGUsdCl7KGZ1bmN0aW9uKGEpe3ZhciBvPXQoMzQpLHY9dCgzNSksVD10KDM2KTtMLmV4cG9ydHM9dTt2YXIgZD17cmVkOjAsb3JhbmdlOjYwLHllbGxvdzoxMjAsZ3JlZW46MTgwLGJsdWU6MjQwLHB1cnBsZTozMDB9O2Z1bmN0aW9uIHUoYyl7dmFyIEUsZj1bXSxnPTEseTtpZih0eXBlb2YgYz09InN0cmluZyIpaWYob1tjXSlmPW9bY10uc2xpY2UoKSx5PSJyZ2IiO2Vsc2UgaWYoYz09PSJ0cmFuc3BhcmVudCIpZz0wLHk9InJnYiIsZj1bMCwwLDBdO2Vsc2UgaWYoL14jW0EtRmEtZjAtOV0rJC8udGVzdChjKSl7dmFyIEM9Yy5zbGljZSgxKSx4PUMubGVuZ3RoLGg9eDw9NDtnPTEsaD8oZj1bcGFyc2VJbnQoQ1swXStDWzBdLDE2KSxwYXJzZUludChDWzFdK0NbMV0sMTYpLHBhcnNlSW50KENbMl0rQ1syXSwxNildLHg9PT00JiYoZz1wYXJzZUludChDWzNdK0NbM10sMTYpLzI1NSkpOihmPVtwYXJzZUludChDWzBdK0NbMV0sMTYpLHBhcnNlSW50KENbMl0rQ1szXSwxNikscGFyc2VJbnQoQ1s0XStDWzVdLDE2KV0seD09PTgmJihnPXBhcnNlSW50KENbNl0rQ1s3XSwxNikvMjU1KSksZlswXXx8KGZbMF09MCksZlsxXXx8KGZbMV09MCksZlsyXXx8KGZbMl09MCkseT0icmdiIn1lbHNlIGlmKEU9L14oKD86cmdifGhzW2x2Yl18aHdifGNteWs/fHh5W3p5XXxncmF5fGxhYnxsY2h1P3Y/fFtseV11dnxsbXMpYT8pXHMqXCgoW15cKV0qKVwpLy5leGVjKGMpKXt2YXIgbT1FWzFdLHI9bT09PSJyZ2IiLEM9bS5yZXBsYWNlKC9hJC8sIiIpO3k9Qzt2YXIgeD1DPT09ImNteWsiPzQ6Qz09PSJncmF5Ij8xOjM7Zj1FWzJdLnRyaW0oKS5zcGxpdCgvXHMqLFxzKi8pLm1hcChmdW5jdGlvbihNLFApe2lmKC8lJC8udGVzdChNKSlyZXR1cm4gUD09PXg/cGFyc2VGbG9hdChNKS8xMDA6Qz09PSJyZ2IiP3BhcnNlRmxvYXQoTSkqMjU1LzEwMDpwYXJzZUZsb2F0KE0pO2lmKENbUF09PT0iaCIpe2lmKC9kZWckLy50ZXN0KE0pKXJldHVybiBwYXJzZUZsb2F0KE0pO2lmKGRbTV0hPT12b2lkIDApcmV0dXJuIGRbTV19cmV0dXJuIHBhcnNlRmxvYXQoTSl9KSxtPT09QyYmZi5wdXNoKDEpLGc9cnx8Zlt4XT09PXZvaWQgMD8xOmZbeF0sZj1mLnNsaWNlKDAseCl9ZWxzZSBjLmxlbmd0aD4xMCYmL1swLTldKD86XHN8XC8pLy50ZXN0KGMpJiYoZj1jLm1hdGNoKC8oWzAtOV0rKS9nKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIHBhcnNlRmxvYXQobil9KSx5PWMubWF0Y2goLyhbYS16XSkvaWcpLmpvaW4oIiIpLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoIWlzTmFOKGMpKXk9InJnYiIsZj1bYz4+PjE2LChjJjY1MjgwKT4+PjgsYyYyNTVdO2Vsc2UgaWYodihjKSl7dmFyIGk9VChjLnIsYy5yZWQsYy5SLG51bGwpO2khPT1udWxsPyh5PSJyZ2IiLGY9W2ksVChjLmcsYy5ncmVlbixjLkcpLFQoYy5iLGMuYmx1ZSxjLkIpXSk6KHk9ImhzbCIsZj1bVChjLmgsYy5odWUsYy5IKSxUKGMucyxjLnNhdHVyYXRpb24sYy5TKSxUKGMubCxjLmxpZ2h0bmVzcyxjLkwsYy5iLGMuYnJpZ2h0bmVzcyldKSxnPVQoYy5hLGMuYWxwaGEsYy5vcGFjaXR5LDEpLGMub3BhY2l0eSE9bnVsbCYmKGcvPTEwMCl9ZWxzZShBcnJheS5pc0FycmF5KGMpfHxhLkFycmF5QnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcmJkFycmF5QnVmZmVyLmlzVmlldyhjKSkmJihmPVtjWzBdLGNbMV0sY1syXV0seT0icmdiIixnPWMubGVuZ3RoPT09ND9jWzNdOjEpO3JldHVybntzcGFjZTp5LHZhbHVlczpmLGFscGhhOmd9fX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2FsaWNlYmx1ZTpbMjQwLDI0OCwyNTVdLGFudGlxdWV3aGl0ZTpbMjUwLDIzNSwyMTVdLGFxdWE6WzAsMjU1LDI1NV0sYXF1YW1hcmluZTpbMTI3LDI1NSwyMTJdLGF6dXJlOlsyNDAsMjU1LDI1NV0sYmVpZ2U6WzI0NSwyNDUsMjIwXSxiaXNxdWU6WzI1NSwyMjgsMTk2XSxibGFjazpbMCwwLDBdLGJsYW5jaGVkYWxtb25kOlsyNTUsMjM1LDIwNV0sYmx1ZTpbMCwwLDI1NV0sYmx1ZXZpb2xldDpbMTM4LDQzLDIyNl0sYnJvd246WzE2NSw0Miw0Ml0sYnVybHl3b29kOlsyMjIsMTg0LDEzNV0sY2FkZXRibHVlOls5NSwxNTgsMTYwXSxjaGFydHJldXNlOlsxMjcsMjU1LDBdLGNob2NvbGF0ZTpbMjEwLDEwNSwzMF0sY29yYWw6WzI1NSwxMjcsODBdLGNvcm5mbG93ZXJibHVlOlsxMDAsMTQ5LDIzN10sY29ybnNpbGs6WzI1NSwyNDgsMjIwXSxjcmltc29uOlsyMjAsMjAsNjBdLGN5YW46WzAsMjU1LDI1NV0sZGFya2JsdWU6WzAsMCwxMzldLGRhcmtjeWFuOlswLDEzOSwxMzldLGRhcmtnb2xkZW5yb2Q6WzE4NCwxMzQsMTFdLGRhcmtncmF5OlsxNjksMTY5LDE2OV0sZGFya2dyZWVuOlswLDEwMCwwXSxkYXJrZ3JleTpbMTY5LDE2OSwxNjldLGRhcmtraGFraTpbMTg5LDE4MywxMDddLGRhcmttYWdlbnRhOlsxMzksMCwxMzldLGRhcmtvbGl2ZWdyZWVuOls4NSwxMDcsNDddLGRhcmtvcmFuZ2U6WzI1NSwxNDAsMF0sZGFya29yY2hpZDpbMTUzLDUwLDIwNF0sZGFya3JlZDpbMTM5LDAsMF0sZGFya3NhbG1vbjpbMjMzLDE1MCwxMjJdLGRhcmtzZWFncmVlbjpbMTQzLDE4OCwxNDNdLGRhcmtzbGF0ZWJsdWU6WzcyLDYxLDEzOV0sZGFya3NsYXRlZ3JheTpbNDcsNzksNzldLGRhcmtzbGF0ZWdyZXk6WzQ3LDc5LDc5XSxkYXJrdHVycXVvaXNlOlswLDIwNiwyMDldLGRhcmt2aW9sZXQ6WzE0OCwwLDIxMV0sZGVlcHBpbms6WzI1NSwyMCwxNDddLGRlZXBza3libHVlOlswLDE5MSwyNTVdLGRpbWdyYXk6WzEwNSwxMDUsMTA1XSxkaW1ncmV5OlsxMDUsMTA1LDEwNV0sZG9kZ2VyYmx1ZTpbMzAsMTQ0LDI1NV0sZmlyZWJyaWNrOlsxNzgsMzQsMzRdLGZsb3JhbHdoaXRlOlsyNTUsMjUwLDI0MF0sZm9yZXN0Z3JlZW46WzM0LDEzOSwzNF0sZnVjaHNpYTpbMjU1LDAsMjU1XSxnYWluc2Jvcm86WzIyMCwyMjAsMjIwXSxnaG9zdHdoaXRlOlsyNDgsMjQ4LDI1NV0sZ29sZDpbMjU1LDIxNSwwXSxnb2xkZW5yb2Q6WzIxOCwxNjUsMzJdLGdyYXk6WzEyOCwxMjgsMTI4XSxncmVlbjpbMCwxMjgsMF0sZ3JlZW55ZWxsb3c6WzE3MywyNTUsNDddLGdyZXk6WzEyOCwxMjgsMTI4XSxob25leWRldzpbMjQwLDI1NSwyNDBdLGhvdHBpbms6WzI1NSwxMDUsMTgwXSxpbmRpYW5yZWQ6WzIwNSw5Miw5Ml0saW5kaWdvOls3NSwwLDEzMF0saXZvcnk6WzI1NSwyNTUsMjQwXSxraGFraTpbMjQwLDIzMCwxNDBdLGxhdmVuZGVyOlsyMzAsMjMwLDI1MF0sbGF2ZW5kZXJibHVzaDpbMjU1LDI0MCwyNDVdLGxhd25ncmVlbjpbMTI0LDI1MiwwXSxsZW1vbmNoaWZmb246WzI1NSwyNTAsMjA1XSxsaWdodGJsdWU6WzE3MywyMTYsMjMwXSxsaWdodGNvcmFsOlsyNDAsMTI4LDEyOF0sbGlnaHRjeWFuOlsyMjQsMjU1LDI1NV0sbGlnaHRnb2xkZW5yb2R5ZWxsb3c6WzI1MCwyNTAsMjEwXSxsaWdodGdyYXk6WzIxMSwyMTEsMjExXSxsaWdodGdyZWVuOlsxNDQsMjM4LDE0NF0sbGlnaHRncmV5OlsyMTEsMjExLDIxMV0sbGlnaHRwaW5rOlsyNTUsMTgyLDE5M10sbGlnaHRzYWxtb246WzI1NSwxNjAsMTIyXSxsaWdodHNlYWdyZWVuOlszMiwxNzgsMTcwXSxsaWdodHNreWJsdWU6WzEzNSwyMDYsMjUwXSxsaWdodHNsYXRlZ3JheTpbMTE5LDEzNiwxNTNdLGxpZ2h0c2xhdGVncmV5OlsxMTksMTM2LDE1M10sbGlnaHRzdGVlbGJsdWU6WzE3NiwxOTYsMjIyXSxsaWdodHllbGxvdzpbMjU1LDI1NSwyMjRdLGxpbWU6WzAsMjU1LDBdLGxpbWVncmVlbjpbNTAsMjA1LDUwXSxsaW5lbjpbMjUwLDI0MCwyMzBdLG1hZ2VudGE6WzI1NSwwLDI1NV0sbWFyb29uOlsxMjgsMCwwXSxtZWRpdW1hcXVhbWFyaW5lOlsxMDIsMjA1LDE3MF0sbWVkaXVtYmx1ZTpbMCwwLDIwNV0sbWVkaXVtb3JjaGlkOlsxODYsODUsMjExXSxtZWRpdW1wdXJwbGU6WzE0NywxMTIsMjE5XSxtZWRpdW1zZWFncmVlbjpbNjAsMTc5LDExM10sbWVkaXVtc2xhdGVibHVlOlsxMjMsMTA0LDIzOF0sbWVkaXVtc3ByaW5nZ3JlZW46WzAsMjUwLDE1NF0sbWVkaXVtdHVycXVvaXNlOls3MiwyMDksMjA0XSxtZWRpdW12aW9sZXRyZWQ6WzE5OSwyMSwxMzNdLG1pZG5pZ2h0Ymx1ZTpbMjUsMjUsMTEyXSxtaW50Y3JlYW06WzI0NSwyNTUsMjUwXSxtaXN0eXJvc2U6WzI1NSwyMjgsMjI1XSxtb2NjYXNpbjpbMjU1LDIyOCwxODFdLG5hdmFqb3doaXRlOlsyNTUsMjIyLDE3M10sbmF2eTpbMCwwLDEyOF0sb2xkbGFjZTpbMjUzLDI0NSwyMzBdLG9saXZlOlsxMjgsMTI4LDBdLG9saXZlZHJhYjpbMTA3LDE0MiwzNV0sb3JhbmdlOlsyNTUsMTY1LDBdLG9yYW5nZXJlZDpbMjU1LDY5LDBdLG9yY2hpZDpbMjE4LDExMiwyMTRdLHBhbGVnb2xkZW5yb2Q6WzIzOCwyMzIsMTcwXSxwYWxlZ3JlZW46WzE1MiwyNTEsMTUyXSxwYWxldHVycXVvaXNlOlsxNzUsMjM4LDIzOF0scGFsZXZpb2xldHJlZDpbMjE5LDExMiwxNDddLHBhcGF5YXdoaXA6WzI1NSwyMzksMjEzXSxwZWFjaHB1ZmY6WzI1NSwyMTgsMTg1XSxwZXJ1OlsyMDUsMTMzLDYzXSxwaW5rOlsyNTUsMTkyLDIwM10scGx1bTpbMjIxLDE2MCwyMjFdLHBvd2RlcmJsdWU6WzE3NiwyMjQsMjMwXSxwdXJwbGU6WzEyOCwwLDEyOF0scmViZWNjYXB1cnBsZTpbMTAyLDUxLDE1M10scmVkOlsyNTUsMCwwXSxyb3N5YnJvd246WzE4OCwxNDMsMTQzXSxyb3lhbGJsdWU6WzY1LDEwNSwyMjVdLHNhZGRsZWJyb3duOlsxMzksNjksMTldLHNhbG1vbjpbMjUwLDEyOCwxMTRdLHNhbmR5YnJvd246WzI0NCwxNjQsOTZdLHNlYWdyZWVuOls0NiwxMzksODddLHNlYXNoZWxsOlsyNTUsMjQ1LDIzOF0sc2llbm5hOlsxNjAsODIsNDVdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLHNreWJsdWU6WzEzNSwyMDYsMjM1XSxzbGF0ZWJsdWU6WzEwNiw5MCwyMDVdLHNsYXRlZ3JheTpbMTEyLDEyOCwxNDRdLHNsYXRlZ3JleTpbMTEyLDEyOCwxNDRdLHNub3c6WzI1NSwyNTAsMjUwXSxzcHJpbmdncmVlbjpbMCwyNTUsMTI3XSxzdGVlbGJsdWU6WzcwLDEzMCwxODBdLHRhbjpbMjEwLDE4MCwxNDBdLHRlYWw6WzAsMTI4LDEyOF0sdGhpc3RsZTpbMjE2LDE5MSwyMTZdLHRvbWF0bzpbMjU1LDk5LDcxXSx0dXJxdW9pc2U6WzY0LDIyNCwyMDhdLHZpb2xldDpbMjM4LDEzMCwyMzhdLHdoZWF0OlsyNDUsMjIyLDE3OV0sd2hpdGU6WzI1NSwyNTUsMjU1XSx3aGl0ZXNtb2tlOlsyNDUsMjQ1LDI0NV0seWVsbG93OlsyNTUsMjU1LDBdLHllbGxvd2dyZWVuOlsxNTQsMjA1LDUwXX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO0wuZXhwb3J0cz1mdW5jdGlvbihvKXt2YXIgdjtyZXR1cm4gYS5jYWxsKG8pPT09IltvYmplY3QgT2JqZWN0XSImJih2PU9iamVjdC5nZXRQcm90b3R5cGVPZihvKSx2PT09bnVsbHx8dj09PU9iamVjdC5nZXRQcm90b3R5cGVPZih7fSkpfX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWlmKGFyZ3VtZW50c1t0XSE9PXZvaWQgMClyZXR1cm4gYXJndW1lbnRzW3RdfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMzgpO0wuZXhwb3J0cz17bmFtZToiaHNsIixtaW46WzAsMCwwXSxtYXg6WzM2MCwxMDAsMTAwXSxjaGFubmVsOlsiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyJdLGFsaWFzOlsiSFNMIl0scmdiOmZ1bmN0aW9uKG8pe3ZhciB2PW9bMF0vMzYwLFQ9b1sxXS8xMDAsZD1vWzJdLzEwMCx1LGMsRSxmLGc7aWYoVD09PTApcmV0dXJuIGc9ZCoyNTUsW2csZyxnXTtkPC41P2M9ZCooMStUKTpjPWQrVC1kKlQsdT0yKmQtYyxmPVswLDAsMF07Zm9yKHZhciB5PTA7eTwzO3krKylFPXYrMS8zKi0oeS0xKSxFPDA/RSsrOkU+MSYmRS0tLDYqRTwxP2c9dSsoYy11KSo2KkU6MipFPDE/Zz1jOjMqRTwyP2c9dSsoYy11KSooMi8zLUUpKjY6Zz11LGZbeV09ZyoyNTU7cmV0dXJuIGZ9fSxhLmhzbD1mdW5jdGlvbihvKXt2YXIgdj1vWzBdLzI1NSxUPW9bMV0vMjU1LGQ9b1syXS8yNTUsdT1NYXRoLm1pbih2LFQsZCksYz1NYXRoLm1heCh2LFQsZCksRT1jLXUsZixnLHk7cmV0dXJuIGM9PT11P2Y9MDp2PT09Yz9mPShULWQpL0U6VD09PWM/Zj0yKyhkLXYpL0U6ZD09PWMmJihmPTQrKHYtVCkvRSksZj1NYXRoLm1pbihmKjYwLDM2MCksZjwwJiYoZis9MzYwKSx5PSh1K2MpLzIsYz09PXU/Zz0wOnk8PS41P2c9RS8oYyt1KTpnPUUvKDItYy11KSxbZixnKjEwMCx5KjEwMF19fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXtuYW1lOiJyZ2IiLG1pbjpbMCwwLDBdLG1heDpbMjU1LDI1NSwyNTVdLGNoYW5uZWw6WyJyZWQiLCJncmVlbiIsImJsdWUiXSxhbGlhczpbIlJHQiJdfX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9dDtmdW5jdGlvbiB0KGEsbyx2KXtyZXR1cm4gbzx2P2E8bz9vOmE+dj92OmE6YTx2P3Y6YT5vP286YX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTt2YXIgYT10KDQxKSxvPXQubihhKSx2PXQoNDIpLFQ9dC5uKHYpLGQ9dCg0MyksdT10Lm4oZCksYz10KDQ0KSxFPXQoNDYpLGY9dC5uKEUpLGc9dCg1MykseT10KDU1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQz1TeW1ib2woImNvbnRvdXJzIikseD1TeW1ib2woInBhdGgiKSxoPVN5bWJvbCgic2ltcGxpZnkiKSxtPVN5bWJvbCgic2NhbGUiKSxyPTIqTWF0aC5QSTtjbGFzcyBpe2NvbnN0cnVjdG9yKHM9e30pe3R5cGVvZiBzPT0ic3RyaW5nIiYmKHM9e3BhdGg6c30pLHMucGF0aD90aGlzW3hdPW8oKShzLnBhdGgpOnRoaXNbeF09W10sdGhpc1tDXT1udWxsLHRoaXNbaF09cy5zaW1wbGlmeSE9bnVsbD9zLnNpbXBsaWZ5OjAsdGhpc1ttXT1zLnNjYWxlIT1udWxsP3Muc2NhbGU6Mn1nZXQgY29udG91cnMoKXtsZXQgcz1udWxsO2lmKCF0aGlzW0NdJiZ0aGlzW3hdKXtjb25zdCBNPU9iamVjdChjLmRlZmF1bHQpKHUoKSh0aGlzW3hdKSk7dGhpc1tDXT1mKCkoTSx0aGlzW21dLHRoaXNbaF0pLHRoaXNbQ10ucGF0aD1NLHRoaXNbQ10uc2ltcGxpZnk9dGhpc1toXSx0aGlzW0NdLnNjYWxlPXRoaXNbbV19cmV0dXJuIHRoaXNbQ10mJihzPXRoaXNbQ10ubWFwKE09PlsuLi5NXSkscy5wYXRoPXRoaXNbQ10ucGF0aCxzLnNpbXBsaWZ5PXRoaXNbQ10uc2ltcGxpZnkscy5zY2FsZT10aGlzW0NdLnNjYWxlKSxzfWdldCBwYXRoKCl7cmV0dXJuIHRoaXNbeF19Z2V0IHNpbXBsaWZ5KCl7cmV0dXJuIHRoaXNbaF19Z2V0IGJvdW5kaW5nQm94KCl7Y29uc3Qgcz10aGlzLmNvbnRvdXJzO2lmKHMmJnMubGVuZ3RoKXtjb25zdCBNPXMucmVkdWNlKChQLFMpPT5bLi4uUCwuLi5TXSk7cmV0dXJuIFQoKShNKX1yZXR1cm5bWzAsMF0sWzAsMF1dfWdldCBib3VuZGluZ0NlbnRlcigpe2NvbnN0IHM9dGhpcy5ib3VuZGluZ0JveDtyZXR1cm4gcz9bLjUqKHNbMF1bMF0rc1sxXVswXSksLjUqKHNbMF1bMV0rc1sxXVsxXSldOlswLDBdfW5vcm1hbGl6ZShzPTAsTT0wKXtjb25zdCBQPU9iamVjdChjLmRlZmF1bHQpKHUoKSh0aGlzW3hdKSkubWFwKChbUywuLi5iXSk9Pntjb25zdCBPPVtTXTtmb3IobGV0IEQ9MDtEPGIubGVuZ3RoO0QrPTIpe2NvbnN0IEk9YltEXS1zLFI9YltEKzFdLU07Ty5wdXNoKEksUil9cmV0dXJuIE99KTtyZXR1cm4gdGhpcy5iZWdpblBhdGgoKSx0aGlzW3hdLnB1c2goLi4uUCksdGhpc31nZXRQb2ludEF0TGVuZ3RoKHMpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdChnLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbQ10scyk6bnVsbH1nZXRUb3RhbExlbmd0aCgpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdChnLmdldFRvdGFsTGVuZ3RoKSh0aGlzW0NdKTowfWFkZFBhdGgocyl7dGhpc1tDXT1udWxsLHR5cGVvZiBzPT0ic3RyaW5nIiYmKHM9bygpKHMpKSx0aGlzW3hdLnB1c2goLi4ucyl9YmVnaW5QYXRoKCl7dGhpc1t4XT1bXSx0aGlzW0NdPW51bGx9Y2xlYXIoKXt0aGlzLmJlZ2luUGF0aCgpfWVsbGlwc2UocyxNLFAsUyxiLE8sRCxJPTApe2lmKE8rPWIsRCs9YixQPD0wfHxTPD0wfHxEPT09TylyZXR1cm47RDxPJiYoRD1PK3IrKEQtTyklciksRC1PPnImJihEPU8rcik7Y29uc3QgUj1ELU87Uj49ciYmKEQtPS4wMDEpO2xldCBBPXRoaXNbeF0ubGVuZ3RoPjAmJlI8cj8iTCI6Ik0iO2NvbnN0IFU9T2JqZWN0KHkuZ2V0UG9pbnQpKHMsTSxQLFMsTyksSz1PYmplY3QoeS5nZXRQb2ludCkocyxNLFAsUyxEKSxWPSshSTtsZXQgUT1SPk1hdGguUEk/MTowO0kmJihRPTEtUSksQSs9VS5qb2luKCIgIiksQSs9YEEke1B9ICR7U30gMCAke1F9ICR7Vn0gJHtLLmpvaW4oIiAiKX1gLFI+PXImJihBKz0iWiIpLHRoaXMuYWRkUGF0aChBKX1hcmMocyxNLFAsUyxiLE89MCl7cmV0dXJuIHRoaXMuZWxsaXBzZShzLE0sUCxQLDAsUyxiLE8pfWFyY1RvKHMsTSxQLFMsYixPLEQpe3RoaXNbQ109bnVsbCx0aGlzW3hdLnB1c2goWyJBIixzLE0sUCxTLGIsTyxEXSl9bW92ZVRvKHMsTSl7dGhpc1tDXT1udWxsLHRoaXNbeF0ucHVzaChbIk0iLHMsTV0pfWxpbmVUbyhzLE0pe3RoaXNbQ109bnVsbCx0aGlzW3hdLnB1c2goWyJMIixzLE1dKX1iZXppZXJDdXJ2ZVRvKHMsTSxQLFMsYixPKXt0aGlzW0NdPW51bGwsdGhpc1t4XS5wdXNoKFsiQyIscyxNLFAsUyxiLE9dKX1xdWFkcmF0aWNDdXJ2ZVRvKHMsTSxQLFMpe3RoaXNbQ109bnVsbCx0aGlzW3hdLnB1c2goWyJRIixzLE0sUCxTXSl9cmVjdChzLE0sUCxTKXtjb25zdCBiPWBNJHtzfSAke019TCR7cytQfSAke019TCR7cytQfSAke00rU31MJHtzfSAke00rU31aYDt0aGlzLmFkZFBhdGgoYil9Y2xvc2VQYXRoKCl7dGhpc1tDXT1udWxsO2xldCBzPVtdO2NvbnN0IE09dGhpc1t4XS5sZW5ndGg7TT4wJiYocz10aGlzW3hdW00tMV0pLHNbMF0hPT0iWiImJnNbMF0hPT0ieiImJnRoaXNbeF0ucHVzaChbIloiXSl9fX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9bzt2YXIgdD17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxhPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gbyhkKXt2YXIgdT1bXTtyZXR1cm4gZC5yZXBsYWNlKGEsZnVuY3Rpb24oYyxFLGYpe3ZhciBnPUUudG9Mb3dlckNhc2UoKTtmb3IoZj1UKGYpLGc9PSJtIiYmZi5sZW5ndGg+MiYmKHUucHVzaChbRV0uY29uY2F0KGYuc3BsaWNlKDAsMikpKSxnPSJsIixFPUU9PSJtIj8ibCI6IkwiKTs7KXtpZihmLmxlbmd0aD09dFtnXSlyZXR1cm4gZi51bnNoaWZ0KEUpLHUucHVzaChmKTtpZihmLmxlbmd0aDx0W2ddKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO3UucHVzaChbRV0uY29uY2F0KGYuc3BsaWNlKDAsdFtnXSkpKX19KSx1fXZhciB2PS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIFQoZCl7dmFyIHU9ZC5tYXRjaCh2KTtyZXR1cm4gdT91Lm1hcChOdW1iZXIpOltdfX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz1hO2Z1bmN0aW9uIGEobyl7dmFyIHY9by5sZW5ndGg7aWYodj09PTApcmV0dXJuW1tdLFtdXTtmb3IodmFyIFQ9b1swXS5sZW5ndGgsZD1vWzBdLnNsaWNlKCksdT1vWzBdLnNsaWNlKCksYz0xO2M8djsrK2MpZm9yKHZhciBFPW9bY10sZj0wO2Y8VDsrK2Ype3ZhciBnPUVbZl07ZFtmXT1NYXRoLm1pbihkW2ZdLGcpLHVbZl09TWF0aC5tYXgodVtmXSxnKX1yZXR1cm5bZCx1XX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPXQ7ZnVuY3Rpb24gdChhKXt2YXIgbz0wLHY9MCxUPTAsZD0wO3JldHVybiBhLm1hcChmdW5jdGlvbih1KXt1PXUuc2xpY2UoKTt2YXIgYz11WzBdLEU9Yy50b1VwcGVyQ2FzZSgpO2lmKGMhPUUpc3dpdGNoKHVbMF09RSxjKXtjYXNlImEiOnVbNl0rPVQsdVs3XSs9ZDticmVhaztjYXNlInYiOnVbMV0rPWQ7YnJlYWs7Y2FzZSJoIjp1WzFdKz1UO2JyZWFrO2RlZmF1bHQ6Zm9yKHZhciBmPTE7Zjx1Lmxlbmd0aDspdVtmKytdKz1ULHVbZisrXSs9ZH1zd2l0Y2goRSl7Y2FzZSJaIjpUPW8sZD12O2JyZWFrO2Nhc2UiSCI6VD11WzFdO2JyZWFrO2Nhc2UiViI6ZD11WzFdO2JyZWFrO2Nhc2UiTSI6VD1vPXVbMV0sZD12PXVbMl07YnJlYWs7ZGVmYXVsdDpUPXVbdS5sZW5ndGgtMl0sZD11W3UubGVuZ3RoLTFdfXJldHVybiB1fSl9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBvfSk7dmFyIGE9dCg0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG8oZCl7Zm9yKHZhciB1LGM9W10sRT0wLGY9MCxnPTAseT0wLEM9bnVsbCx4PW51bGwsaD0wLG09MCxyPTAsaT1kLmxlbmd0aDtyPGk7cisrKXt2YXIgbj1kW3JdLHM9blswXTtzd2l0Y2gocyl7Y2FzZSJNIjpnPW5bMV0seT1uWzJdO2JyZWFrO2Nhc2UiQSI6dmFyIE09T2JqZWN0KGEuZGVmYXVsdCkoaCxtLG5bNl0sbls3XSxuWzRdLG5bNV0sblsxXSxuWzJdLG5bM10pO2lmKCFNLmxlbmd0aCljb250aW51ZTtNPU0ubWFwKEQ9Pntjb25zdFtJLFIsQSxVLEssVixRLHFdPUQ7cmV0dXJue3gxOkEseTE6VSx4MjpLLHkyOlYseDpRLHk6cX19KTtmb3IodmFyIFA9MCxTO1A8TS5sZW5ndGg7UCsrKVM9TVtQXSxuPVsiQyIsUy54MSxTLnkxLFMueDIsUy55MixTLngsUy55XSxQPE0ubGVuZ3RoLTEmJmMucHVzaChuKTticmVhaztjYXNlIlMiOnZhciBiPWgsTz1tOyh1PT0iQyJ8fHU9PSJTIikmJihiKz1iLUUsTys9Ty1mKSxuPVsiQyIsYixPLG5bMV0sblsyXSxuWzNdLG5bNF1dO2JyZWFrO2Nhc2UiVCI6dT09IlEifHx1PT0iVCI/KEM9aCoyLUMseD1tKjIteCk6KEM9aCx4PW0pLG49VChoLG0sQyx4LG5bMV0sblsyXSk7YnJlYWs7Y2FzZSJRIjpDPW5bMV0seD1uWzJdLG49VChoLG0sblsxXSxuWzJdLG5bM10sbls0XSk7YnJlYWs7Y2FzZSJMIjpuPXYoaCxtLG5bMV0sblsyXSk7YnJlYWs7Y2FzZSJIIjpuPXYoaCxtLG5bMV0sbSk7YnJlYWs7Y2FzZSJWIjpuPXYoaCxtLGgsblsxXSk7YnJlYWs7Y2FzZSJaIjpuPXYoaCxtLGcseSk7YnJlYWt9dT1zLGg9bltuLmxlbmd0aC0yXSxtPW5bbi5sZW5ndGgtMV0sbi5sZW5ndGg+ND8oRT1uW24ubGVuZ3RoLTRdLGY9bltuLmxlbmd0aC0zXSk6KEU9aCxmPW0pLGMucHVzaChuKX1yZXR1cm4gY31mdW5jdGlvbiB2KGQsdSxjLEUpe3JldHVyblsiQyIsZCx1LGMsRSxjLEVdfWZ1bmN0aW9uIFQoZCx1LGMsRSxmLGcpe3JldHVyblsiQyIsZC8zKzIvMypjLHUvMysyLzMqRSxmLzMrMi8zKmMsZy8zKzIvMypFLGYsZ119fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGE9TWF0aC5QSSoyO2Z1bmN0aW9uIG8odSxjLEUsZil7Y29uc3QgZz11KmYtYypFPDA/LTE6MTtsZXQgeT11KkUrYypmO3JldHVybiB5PjEmJih5PTEpLHk8LTEmJih5PS0xKSxnKk1hdGguYWNvcyh5KX1mdW5jdGlvbiB2KHUsYyxFLGYsZyx5LEMseCxoLG0pe2NvbnN0IHI9bSoodS1FKS8yK2gqKGMtZikvMixpPS1oKih1LUUpLzIrbSooYy1mKS8yLG49QypDLHM9eCp4LE09cipyLFA9aSppO2xldCBTPW4qcy1uKlAtcypNO1M8MCYmKFM9MCksUy89bipQK3MqTSxTPU1hdGguc3FydChTKSooZz09PXk/LTE6MSk7Y29uc3QgYj1TKkMveCppLE89UyoteC9DKnIsRD1tKmItaCpPKyh1K0UpLzIsST1oKmIrbSpPKyhjK2YpLzIsUj0oci1iKS9DLEE9KGktTykveCxVPSgtci1iKS9DLEs9KC1pLU8pL3gsVj1vKDEsMCxSLEEpO2xldCBRPW8oUixBLFUsSyk7cmV0dXJuIHk9PT0wJiZRPjAmJihRLT1hKSx5PT09MSYmUTwwJiYoUSs9YSksW0QsSSxWLFFdfWZ1bmN0aW9uIFQodSxjKXtjb25zdCBFPTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihjLzQpLGY9TWF0aC5jb3ModSksZz1NYXRoLnNpbih1KSx5PU1hdGguY29zKHUrYyksQz1NYXRoLnNpbih1K2MpO3JldHVybltmLGcsZi1nKkUsZytmKkUseStDKkUsQy15KkUseSxDXX1mdW5jdGlvbiBkKHUsYyxFLGYsZyx5LEMseCxoKXtjb25zdCBtPU1hdGguc2luKGgqYS8zNjApLHI9TWF0aC5jb3MoaCphLzM2MCksaT1yKih1LUUpLzIrbSooYy1mKS8yLG49LW0qKHUtRSkvMityKihjLWYpLzI7aWYoaT09PTAmJm49PT0wKXJldHVybltdO2lmKEM9PT0wfHx4PT09MClyZXR1cm5bXTtDPU1hdGguYWJzKEMpLHg9TWF0aC5hYnMoeCk7Y29uc3Qgcz1pKmkvKEMqQykrbipuLyh4KngpO3M+MSYmKEMqPU1hdGguc3FydChzKSx4Kj1NYXRoLnNxcnQocykpO2NvbnN0IE09dih1LGMsRSxmLGcseSxDLHgsbSxyKSxQPVtdO2xldCBTPU1bMl0sYj1NWzNdO2NvbnN0IE89TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKGIpLyhhLzQpKSwxKTtiLz1PO2ZvcihsZXQgRD0wO0Q8TztEKyspUC5wdXNoKFQoUyxiKSksUys9YjtyZXR1cm4gUC5tYXAoRD0+e2ZvcihsZXQgST0wO0k8RC5sZW5ndGg7SSs9Mil7bGV0IFI9RFtJKzBdLEE9RFtJKzFdO1IqPUMsQSo9eDtjb25zdCBVPXIqUi1tKkEsSz1tKlIrcipBO0RbSSswXT1VK01bMF0sRFtJKzFdPUsrTVsxXX1yZXR1cm4gRH0pfX0sZnVuY3Rpb24oTCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgYT10KDQ3KSx7Y29weTpvfT10KDQ5KSx2PXQoNTApO2Z1bmN0aW9uIFQoZixnLHkpe3JldHVybiBmWzBdPWcsZlsxXT15LGZ9dmFyIGQ9WzAsMF0sdT1bMCwwXSxjPVswLDBdO2Z1bmN0aW9uIEUoZixnLHksQyl7YSh5LFQoZCxDWzFdLENbMl0pLFQodSxDWzNdLENbNF0pLFQoYyxDWzVdLENbNl0pLGcsZil9TC5leHBvcnRzPWZ1bmN0aW9uKGcseSxDKXt2YXIgeD1bXSxoPVtdLG09WzAsMF07cmV0dXJuIGcuZm9yRWFjaChmdW5jdGlvbihyLGksbil7aWYoclswXT09PSJNIilvKG0sci5zbGljZSgxKSksaC5sZW5ndGg+MCYmKHgucHVzaChoKSxoPVtdKTtlbHNlIGlmKHJbMF09PT0iQyIpRShoLHksbSxyKSxUKG0scls1XSxyWzZdKTtlbHNlIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCB0eXBlIGluIFNWRzogIityWzBdKX0pLGgubGVuZ3RoPjAmJngucHVzaChoKSx4Lm1hcChmdW5jdGlvbihyKXtyZXR1cm4gdihyLEN8fDApfSl9fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXQoNDgpKCl9LGZ1bmN0aW9uKEwsZSl7ZnVuY3Rpb24gdChvKXtyZXR1cm5bb1swXSxvWzFdXX1mdW5jdGlvbiBhKG8sdil7cmV0dXJuW28sdl19TC5leHBvcnRzPWZ1bmN0aW9uKHYpe3Y9dnx8e307dmFyIFQ9dHlwZW9mIHYucmVjdXJzaW9uPT0ibnVtYmVyIj92LnJlY3Vyc2lvbjo4LGQ9dHlwZW9mIHYuZXBzaWxvbj09Im51bWJlciI/di5lcHNpbG9uOjExOTIwOTI5ZS0xNCx1PXR5cGVvZiB2LnBhdGhFcHNpbG9uPT0ibnVtYmVyIj92LnBhdGhFcHNpbG9uOjEsYz10eXBlb2Ygdi5hbmdsZUVwc2lsb249PSJudW1iZXIiP3YuYW5nbGVFcHNpbG9uOi4wMSxFPXYuYW5nbGVUb2xlcmFuY2V8fDAsZj12LmN1c3BMaW1pdHx8MDtyZXR1cm4gZnVuY3Rpb24oeCxoLG0scixpLG4pe258fChuPVtdKSxpPXR5cGVvZiBpPT0ibnVtYmVyIj9pOjE7dmFyIHM9dS9pO3JldHVybiBzKj1zLGcoeCxoLG0scixuLHMpLG59O2Z1bmN0aW9uIGcoQyx4LGgsbSxyLGkpe3IucHVzaCh0KEMpKTt2YXIgbj1DWzBdLHM9Q1sxXSxNPXhbMF0sUD14WzFdLFM9aFswXSxiPWhbMV0sTz1tWzBdLEQ9bVsxXTt5KG4scyxNLFAsUyxiLE8sRCxyLGksMCksci5wdXNoKHQobSkpfWZ1bmN0aW9uIHkoQyx4LGgsbSxyLGksbixzLE0sUCxTKXtpZighKFM+VCkpe3ZhciBiPU1hdGguUEksTz0oQytoKS8yLEQ9KHgrbSkvMixJPShoK3IpLzIsUj0obStpKS8yLEE9KHIrbikvMixVPShpK3MpLzIsSz0oTytJKS8yLFY9KEQrUikvMixRPShJK0EpLzIscT0oUitVKS8yLFc9KEsrUSkvMixIPShWK3EpLzI7aWYoUz4wKXt2YXIgWj1uLUMsdHQ9cy14LF89TWF0aC5hYnMoKGgtbikqdHQtKG0tcykqWiksc3Q9TWF0aC5hYnMoKHItbikqdHQtKGktcykqWiksayxjdDtpZihfPmQmJnN0PmQpe2lmKChfK3N0KSooXytzdCk8PVAqKFoqWit0dCp0dCkpe2lmKEU8Yyl7TS5wdXNoKGEoVyxIKSk7cmV0dXJufXZhciBmdD1NYXRoLmF0YW4yKGktbSxyLWgpO2lmKGs9TWF0aC5hYnMoZnQtTWF0aC5hdGFuMihtLXgsaC1DKSksY3Q9TWF0aC5hYnMoTWF0aC5hdGFuMihzLWksbi1yKS1mdCksaz49YiYmKGs9MipiLWspLGN0Pj1iJiYoY3Q9MipiLWN0KSxrK2N0PEUpe00ucHVzaChhKFcsSCkpO3JldHVybn1pZihmIT09MCl7aWYoaz5mKXtNLnB1c2goYShoLG0pKTtyZXR1cm59aWYoY3Q+Zil7TS5wdXNoKGEocixpKSk7cmV0dXJufX19fWVsc2UgaWYoXz5kKXtpZihfKl88PVAqKFoqWit0dCp0dCkpe2lmKEU8Yyl7TS5wdXNoKGEoVyxIKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihpLW0sci1oKS1NYXRoLmF0YW4yKG0teCxoLUMpKSxrPj1iJiYoaz0yKmItayksazxFKXtNLnB1c2goYShoLG0pKSxNLnB1c2goYShyLGkpKTtyZXR1cm59aWYoZiE9PTAmJms+Zil7TS5wdXNoKGEoaCxtKSk7cmV0dXJufX19ZWxzZSBpZihzdD5kKXtpZihzdCpzdDw9UCooWipaK3R0KnR0KSl7aWYoRTxjKXtNLnB1c2goYShXLEgpKTtyZXR1cm59aWYoaz1NYXRoLmFicyhNYXRoLmF0YW4yKHMtaSxuLXIpLU1hdGguYXRhbjIoaS1tLHItaCkpLGs+PWImJihrPTIqYi1rKSxrPEUpe00ucHVzaChhKGgsbSkpLE0ucHVzaChhKHIsaSkpO3JldHVybn1pZihmIT09MCYmaz5mKXtNLnB1c2goYShyLGkpKTtyZXR1cm59fX1lbHNlIGlmKFo9Vy0oQytuKS8yLHR0PUgtKHgrcykvMixaKlordHQqdHQ8PVApe00ucHVzaChhKFcsSCkpO3JldHVybn19eShDLHgsTyxELEssVixXLEgsTSxQLFMrMSkseShXLEgsUSxxLEEsVSxuLHMsTSxQLFMrMSl9fX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjb21wdXRlTWl0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwibm9ybWFsIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImRpcmVjdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pO3ZhciBhPXQoMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG8oaSl7cmV0dXJuW2lbMF0saVsxXV19ZnVuY3Rpb24gdigpe3JldHVyblswLDBdfWNvbnN0IFQ9YS52ZWMyLmNvcHksZD1hLnZlYzIuc2NhbGVBbmRBZGQsdT1hLnZlYzIuZG90LGM9YS52ZWMyLnJvdGF0ZSxFPWEudmVjMi5jcm9zcyxmPWEudmVjMi5zdWIsZz1hLnZlYzIuYWRkLHk9YS52ZWMyLm5vcm1hbGl6ZSxDPWEudmVjMi5zZXQseD12KCk7ZnVuY3Rpb24gaChpLG4scyxNLFApe2coaSxzLE0pLHkoaSxpKSxDKG4sLWlbMV0saVswXSksQyh4LC1zWzFdLHNbMF0pO2NvbnN0IFM9UC91KG4seCk7cmV0dXJuIE1hdGguYWJzKFMpfWZ1bmN0aW9uIG0oaSxuKXtyZXR1cm4gQyhpLC1uWzFdLG5bMF0pLGl9ZnVuY3Rpb24gcihpLG4scyl7cmV0dXJuIGYoaSxuLHMpLHkoaSxpKSxpfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoNTEpLG89dCg1Mik7TC5leHBvcnRzPWZ1bmN0aW9uKFQsZCl7cmV0dXJuIFQ9YShULGQpLFQ9byhULGQpLFR9LEwuZXhwb3J0cy5yYWRpYWxEaXN0YW5jZT1hLEwuZXhwb3J0cy5kb3VnbGFzUGV1Y2tlcj1vfSxmdW5jdGlvbihMLGUpe2Z1bmN0aW9uIHQoYSxvKXt2YXIgdj1hWzBdLW9bMF0sVD1hWzFdLW9bMV07cmV0dXJuIHYqditUKlR9TC5leHBvcnRzPWZ1bmN0aW9uKG8sdil7aWYoby5sZW5ndGg8PTEpcmV0dXJuIG87dj10eXBlb2Ygdj09Im51bWJlciI/djoxO2Zvcih2YXIgVD12KnYsZD1vWzBdLHU9W2RdLGMsRT0xLGY9by5sZW5ndGg7RTxmO0UrKyljPW9bRV0sdChjLGQpPlQmJih1LnB1c2goYyksZD1jKTtyZXR1cm4gZCE9PWMmJnUucHVzaChjKSx1fX0sZnVuY3Rpb24oTCxlKXtmdW5jdGlvbiB0KG8sdixUKXt2YXIgZD12WzBdLHU9dlsxXSxjPVRbMF0tZCxFPVRbMV0tdTtpZihjIT09MHx8RSE9PTApe3ZhciBmPSgob1swXS1kKSpjKyhvWzFdLXUpKkUpLyhjKmMrRSpFKTtmPjE/KGQ9VFswXSx1PVRbMV0pOmY+MCYmKGQrPWMqZix1Kz1FKmYpfXJldHVybiBjPW9bMF0tZCxFPW9bMV0tdSxjKmMrRSpFfWZ1bmN0aW9uIGEobyx2LFQsZCx1KXtmb3IodmFyIGM9ZCxFLGY9disxO2Y8VDtmKyspe3ZhciBnPXQob1tmXSxvW3ZdLG9bVF0pO2c+YyYmKEU9ZixjPWcpfWM+ZCYmKEUtdj4xJiZhKG8sdixFLGQsdSksdS5wdXNoKG9bRV0pLFQtRT4xJiZhKG8sRSxULGQsdSkpfUwuZXhwb3J0cz1mdW5jdGlvbih2LFQpe2lmKHYubGVuZ3RoPD0xKXJldHVybiB2O1Q9dHlwZW9mIFQ9PSJudW1iZXIiP1Q6MTt2YXIgZD1UKlQsdT12Lmxlbmd0aC0xLGM9W3ZbMF1dO3JldHVybiBhKHYsMCx1LGQsYyksYy5wdXNoKHZbdV0pLGN9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRUb3RhbExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJnZXRQb2ludEF0TGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImdldERhc2hDb250b3VycyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBhPXQoNTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKHUpe2lmKHUudG90YWxMZW5ndGghPW51bGwpcmV0dXJuIHUudG90YWxMZW5ndGg7bGV0IGM9MDtyZXR1cm4gdS5mb3JFYWNoKEU9PntsZXQgZj1FWzBdO2ZvcihsZXQgZz0xO2c8RS5sZW5ndGg7ZysrKXtjb25zdCB5PUVbZ107Yys9T2JqZWN0KGEuZGlzdGFuY2UpKGYseSksZj15fX0pLHUudG90YWxMZW5ndGg9YyxjfWZ1bmN0aW9uIHYodSxjLEU9ITApe2lmKGM9TnVtYmVyKGMpLCFOdW1iZXIuaXNGaW5pdGUoYykpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoYzw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJMZW5ndGggbXVzdCA+IDAiKTtjb25zdCBmPW8odSk7aWYoYz49Zil7Y29uc3QgeT11W3UubGVuZ3RoLTFdLEM9eVt5Lmxlbmd0aC0yXSx4PXlbeS5sZW5ndGgtMV0saD1NYXRoLmF0YW4yKHhbMV0tQ1sxXSx4WzBdLUNbMF0pO3JldHVybntjdXJyZW50OnUubWFwKG09PlsuLi5tXSkscG9pbnQ6e3g6eFswXSx5OnhbMV0sYW5nbGU6aH19fWNvbnN0IGc9W107Zm9yKGxldCB5PTA7eTx1Lmxlbmd0aDt5Kyspe2dbeV09W107Y29uc3QgQz11W3ldO2xldCB4PUNbMF07Zm9yKGxldCBoPTE7aDxDLmxlbmd0aDtoKyspe2NvbnN0IG09Q1toXSxyPU9iamVjdChhLmRpc3RhbmNlKSh4LG0pO2lmKGM8cil7Y29uc3QgaT1jL3Isbj1NYXRoLmF0YW4yKG1bMV0teFsxXSxtWzBdLXhbMF0pLHM9e3g6eFswXSooMS1pKSttWzBdKmkseTp4WzFdKigxLWkpK21bMV0qaSxhbmdsZTpufTtpZihnW3ldLnB1c2goeCksYz4wJiZnW3ldLnB1c2goW3MueCxzLnldKSwhRSlyZXR1cm57Y3VycmVudDpnLHBvaW50OnN9O2NvbnN0IE09W10sUD15O2Zvcig7eTx1Lmxlbmd0aDt5Kyspe2ZvcihNW3ktUF09W10seT09PVAmJk1bMF0ucHVzaChbcy54LHMueV0pO2g8Qy5sZW5ndGg7aCsrKU1beS1QXS5wdXNoKENbaF0pO2g9MH1yZXR1cm57Y3VycmVudDpnLHBvaW50OnMscmVzdDpNfX1jLT1yLGdbeV0ucHVzaCh4KSx4PW19fX1mdW5jdGlvbiBUKHUsYyl7aWYoYz1OdW1iZXIoYyksIU51bWJlci5pc0Zpbml0ZShjKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UG9pbnRBdExlbmd0aCcgb24gZmlndXJlOiBUaGUgcHJvdmlkZWQgZmxvYXQgdmFsdWUgaXMgbm9uLWZpbml0ZS4iKTtpZih1Lmxlbmd0aDw9MClyZXR1cm57eDowLHk6MCxhbmdsZTowfTtpZihjPD0wKXtjb25zdCBFPXVbMF1bMF0sZj11WzBdWzFdLGc9TWF0aC5hdGFuMihmWzFdLUVbMV0sZlswXS1FWzBdKTtyZXR1cm57eDpFWzBdLHk6RVsxXSxhbmdsZTpnfX1yZXR1cm4gdih1LGMsITEpLnBvaW50fWZ1bmN0aW9uIGQodSxjLEUpe2xldCBmPTAsZz1jWzBdLHk9dTtjb25zdCBDPVtdLHg9Yy5sZW5ndGg7aWYoRT4wKXtkbyBFLT1jW2YleF0sZisrO3doaWxlKEU+MCk7RTwwJiYoZz0tRSxmLS0pfWVsc2UgaWYoRTwwKXtmPS0xO2RvIEUrPWNbZiV4K3gtMV0sZi0tO3doaWxlKEU8MCk7RT49MCYmKGYrKyxnPWNbZiV4K3gtMV0tRSl9ZG97Y29uc3QgaD12KHksZyk7eT1oLnJlc3QsKytmJTImJkMucHVzaCguLi5oLmN1cnJlbnQpO2xldCBtPWYleDttPDAmJihtKz14KSxnPWNbbV19d2hpbGUoeSk7cmV0dXJuIEN9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShbdixULGRdLHUsYyxFKXtyZXR1cm4gdj12KjIvdS0xLFQ9MS1UKjIvYyxOdW1iZXIuaXNGaW5pdGUoRSk/KGQ9ZCoyL0UtMSxbdixULGRdKTpbdixUXX1mdW5jdGlvbiBvKFt2LFQsZD0wXSxbdSxjLEU9MF0pe3JldHVybiBNYXRoLmh5cG90KHUtdixjLVQsRS1kKX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImdldFBvaW50IixmdW5jdGlvbigpe3JldHVybiBvfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGE9TWF0aC5QSSoyO2Z1bmN0aW9uIG8odixULGQsdSxjKXtjJT1hLGM8MCYmKGMrPWEpO2NvbnN0IEU9TWF0aC50YW4oYyk7aWYoTWF0aC5hYnMoRSk8MWU1KXtjb25zdCBmPVQtRSp2LGc9MS9kKioyK0UqKjIvdSoqMjtsZXQgeT0tMTsoYzw9TWF0aC5QSS8yfHxjPjMqTWF0aC5QSS8yKSYmKHk9MSk7Y29uc3QgQz15Kk1hdGguc3FydCgxL2cpK3YseD1FKkMrZjtyZXR1cm5bQyx4XX1yZXR1cm4gYzxNYXRoLlBJP1t2LFQrdV06W3YsVC11XX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KTt2YXIgYT10KDEpLG89dCg0Miksdj10Lm4obyksVD10KDU3KSxkPXQoMjgpLHU9dCgyNCksYz10KDMwKSxFPXQoNTkpLGY9dCg1MyksZz10KDYwKSx5PXQubihnKSxDPXQoNDYpLHg9dC5uKEMpLGg9dCgzMSksbT10KDQwKSxyPXQoMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKEosail7aWYoSj09bnVsbClyZXR1cm57fTt2YXIgRz1uKEosaiksbCxwO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBOPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoSik7Zm9yKHA9MDtwPE4ubGVuZ3RoO3ArKylsPU5bcF0sIShqLmluZGV4T2YobCk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoSixsKSYmKEdbbF09SltsXSl9cmV0dXJuIEd9ZnVuY3Rpb24gbihKLGope2lmKEo9PW51bGwpcmV0dXJue307dmFyIEc9e30sbD1PYmplY3Qua2V5cyhKKSxwLE47Zm9yKE49MDtOPGwubGVuZ3RoO04rKylwPWxbTl0sIShqLmluZGV4T2YocCk+PTApJiYoR1twXT1KW3BdKTtyZXR1cm4gR31jb25zdCBzPVN5bWJvbCgibWVzaCIpLE09U3ltYm9sKCJjb250b3VycyIpLFA9U3ltYm9sKCJzdHJva2UiKSxTPVN5bWJvbCgiZmlsbCIpLGI9U3ltYm9sKCJzdHJva2VDb2xvciIpLE89U3ltYm9sKCJmaWxsQ29sb3IiKSxEPVN5bWJvbCgidHJhbnNmb3JtIiksST1TeW1ib2woImludmVydFRyYW5zZm9ybSIpLFI9U3ltYm9sKCJ1bmlmb3JtcyIpLEE9U3ltYm9sKCJ0ZXhPcHRpb25zIiksVT1TeW1ib2woImJsZW5kIiksSz1TeW1ib2woImFwcGx5VGV4dHVyZSIpLFY9U3ltYm9sKCJhcHBseVRyYW5zZm9ybSIpLFE9U3ltYm9sKCJhcHBseUdyYWRpZW50VHJhbnNmb3JtIikscT1TeW1ib2woImFwcGx5UHJvZ3JhbSIpLFc9U3ltYm9sKCJncmFkaWVudCIpLEg9U3ltYm9sKCJmaWx0ZXIiKSxaPVN5bWJvbCgib3BhY2l0eSIpLHR0PVN5bWJvbCgicHJvZ3JhbSIpLF89U3ltYm9sKCJhdHRyaWJ1dGVzIiksc3Q9U3ltYm9sKCJwYXNzIiksaz1TeW1ib2woImNsaXBDb250ZXh0IiksY3Q9U3ltYm9sKCJhcHBseUNsaXBQYXRoIik7ZnVuY3Rpb24gZnQoSixqKXtjb25zdFtHLGxdPVtKWzFdWzBdLUpbMF1bMF0sSlsxXVsxXS1KWzBdWzFdXSxwPVtdO2ZvcihsZXQgTj0wO048ai5sZW5ndGg7TisrKXtjb25zdCB6PWpbTl0sJD1bKHpbMF0tSlswXVswXSkvRywxLSh6WzFdLUpbMF1bMV0pL2xdO3AucHVzaCgkKX1yZXR1cm4gcH1mdW5jdGlvbiBCKFtKLGpdLFtHLGwscCxOXSx7c2NhbGU6en0pe3JldHVybiB6fHwoSi89cCxqPTEtai9OLEotPUcsais9bCksW0osaiwwXX1mdW5jdGlvbiBGKEosaixHKXtjb25zdCBsPXgoKShKLGosRyk7cmV0dXJuIGwucGF0aD1KLGwuc2ltcGxpZnk9RyxsLnNjYWxlPWosbH1jbGFzcyBZe2NvbnN0cnVjdG9yKGope3RoaXNbUF09bnVsbCx0aGlzW1NdPW51bGwsdGhpc1tEXT1bMSwwLDAsMSwwLDBdLHRoaXNbWl09MSx0aGlzW1JdPXt9LHRoaXNbSF09W10sdGhpc1tVXT1udWxsLHRoaXNbQV09e30sdGhpcy5jb250b3Vycz1qLmNvbnRvdXJzLHRoaXNbdHRdPW51bGwsdGhpc1tfXT17fSx0aGlzW3N0XT1bXX1nZXQgY29udG91cnMoKXtyZXR1cm4gdGhpc1tNXX1zZXQgY29udG91cnMoail7dGhpc1tzXT1udWxsLHRoaXNbTV09ajtjb25zdCBHPWouc2NhbGU7dGhpcy50cmFuc2Zvcm1TY2FsZS9HPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKX1zZXRQcm9ncmFtKGope3RoaXNbdHRdPWosdGhpc1tzXSYmdGhpc1txXShqKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW3R0XX1zZXRBdHRyaWJ1dGUoaixHKXtHPT1udWxsP2RlbGV0ZSB0aGlzW19dW2pdOnRoaXNbX11bal09R31nZXRPcGFjaXR5KCl7cmV0dXJuIHRoaXNbWl19c2V0T3BhY2l0eShqKXtpZihqPDB8fGo+MSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIG9wYWNpdHkgdmFsdWUuIik7dGhpc1tzXSYmdGhpc1tzXS5wb3NpdGlvbnMuZm9yRWFjaChHPT57R1syXT0xL0dbMl0+MD9qOi1qfSksdGhpc1taXT1qfXNldENsaXBQYXRoKGope3RoaXMuY2xpcFBhdGg9aix0aGlzW1JdLnVfY2xpcFNhbXBsZXImJnRoaXNbUl0udV9jbGlwU2FtcGxlci5kZWxldGUoKSx0aGlzLnNldFVuaWZvcm1zKHt1X2NsaXBTYW1wbGVyOm51bGx9KSx0aGlzW3NdJiZkZWxldGUgdGhpc1tzXS5hdHRyaWJ1dGVzLmFfY2xpcFVWLGomJnRoaXNbc10mJnRoaXNbY3RdKCl9W2N0XSgpe2lmKHRoaXMuY2xpcFBhdGgpe3RoaXNba118fCh0aGlzW2tdPXIuZGVmYXVsdC5jcmVhdGVDYW52YXMoMSwxKSk7Y29uc3RbW2osR10sW2wscF1dPXRoaXMuYm91bmRpbmdCb3g7bCYmcCYmKHRoaXNba10ud2lkdGg9bC1qLHRoaXNba10uaGVpZ2h0PXAtRyk7Y29uc3QgTj10aGlzW2tdLmdldENvbnRleHQoIjJkIiksej1uZXcgUGF0aDJEKHRoaXMuY2xpcFBhdGgpO04uY2xlYXJSZWN0KDAsMCx0aGlzW2tdLndpZHRoLHRoaXNba10uaGVpZ2h0KSxOLnNhdmUoKSxOLnRyYW5zbGF0ZSgtaiwtRyksTi5maWxsU3R5bGU9IndoaXRlIixOLmZpbGwoeiksTi5yZXN0b3JlKCksdGhpc1tzXS5jbGlwUGF0aD10aGlzW2tdO2NvbnN0ICQ9ZnQodGhpcy5ib3VuZGluZ0JveCx0aGlzW3NdLnBvc2l0aW9uMCk7dGhpc1tzXS5hdHRyaWJ1dGVzLmFfY2xpcFVWPSR9fWdldFBvaW50QXRMZW5ndGgoail7cmV0dXJuIE9iamVjdChmLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbTV0sail9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gT2JqZWN0KGYuZ2V0VG90YWxMZW5ndGgpKHRoaXNbTV0pfWdldCBibGVuZCgpe3JldHVybiB0aGlzW1VdPT1udWxsPyJhdXRvIjp0aGlzW1VdfXNldCBibGVuZChqKXt0aGlzW1VdPWosdGhpc1tzXSYmKHRoaXNbc10uZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCl9Z2V0IGJvdW5kaW5nQm94KCl7aWYodGhpc1tzXSYmdGhpc1tzXS5ib3VuZGluZ0JveClyZXR1cm4gdGhpc1tzXS5ib3VuZGluZ0JveDtjb25zdCBqPXRoaXMubWVzaERhdGE7aWYoail7Y29uc3QgRz1qLnBvc2l0aW9uMDtpZihHLmxlbmd0aClqLmJvdW5kaW5nQm94PXYoKShHKTtlbHNlIHJldHVybltbMCwwXSxbMCwwXV07cmV0dXJuIGouYm91bmRpbmdCb3h9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBqPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIGo/Wy41KihqWzBdWzBdK2pbMV1bMF0pLC41KihqWzBdWzFdK2pbMV1bMV0pXTpbMCwwXX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tTXT90aGlzW1NdLnJ1bGU6Im5vbnplcm8ifWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tQXT90aGlzW1BdLmxpbmVXaWR0aDowfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5saW5lQ2FwOiIifWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW1BdP3RoaXNbUF0ubGluZUpvaW46IiJ9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tQXT90aGlzW1BdLm1pdGVyTGltaXQ6MH1nZXQgc3Ryb2tlU3R5bGUoKXtyZXR1cm4gdGhpc1tiXSYmdGhpc1tiXVszXSE9PTA/T2JqZWN0KHUuZGVmYXVsdCkodGhpc1tiXSk6IiJ9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5saW5lRGFzaDpudWxsfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW1BdP3RoaXNbUF0ubGluZURhc2hPZmZzZXQ6MH1nZXQgZmlsbFN0eWxlKCl7cmV0dXJuIHRoaXNbT10mJnRoaXNbT11bM10hPT0wP09iamVjdCh1LmRlZmF1bHQpKHRoaXNbT10pOiIifWdldCBncmFkaWVudCgpe3JldHVybiB0aGlzW1ddfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbUl0udV90ZXhTYW1wbGVyP3tpbWFnZTp0aGlzW1JdLnVfdGV4U2FtcGxlci5faW1nLG9wdGlvbnM6dGhpc1tBXX06bnVsbH1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tVXT09PSEwfHx0aGlzW1VdPT09ITE/dGhpc1tVXTp0aGlzW1pdPDF8fHRoaXNbYl0hPW51bGwmJnRoaXNbYl1bM108MXx8dGhpc1tPXSE9bnVsbCYmdGhpc1tPXVszXTwxfHx0aGlzW1JdLnVfY29sb3JNYXRyaXghPW51bGwmJnRoaXNbUl0udV9jb2xvck1hdHJpeFsxOF08MXx8dGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yIT1udWxsfHx0aGlzLmJlZm9yZVJlbmRlcnx8dGhpcy5hZnRlclJlbmRlcn1nZXQgZmlsdGVyQ2FudmFzKCl7cmV0dXJuL2JsdXJ8ZHJvcC1zaGFkb3d8dXJsLy50ZXN0KHRoaXMuZmlsdGVyKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbSF0uam9pbigiICIpfWdldCB0cmFuc2Zvcm1NYXRyaXgoKXtyZXR1cm4gdGhpc1tEXX1nZXQgaW52ZXJ0TWF0cml4KCl7aWYoIXRoaXNbSV0pe2NvbnN0IGo9YS5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXNbRF0pO3RoaXNbSV09an1yZXR1cm4gdGhpc1tJXX1nZXQgdHJhbnNmb3JtU2NhbGUoKXtjb25zdCBqPXRoaXNbRF07cmV0dXJuIE1hdGgubWF4KE1hdGguaHlwb3QoalswXSxqWzFdKSxNYXRoLmh5cG90KGpbMl0salszXSkpfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW1JdfWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbc3RdfVtxXShqKXtjb25zdCBHPXRoaXNbX10sbD10aGlzW3NdLnBvc2l0aW9uMCxwPU9iamVjdC5lbnRyaWVzKGouX2F0dHJpYnV0ZSk7Zm9yKGxldCBOPTA7TjxwLmxlbmd0aDtOKyspe2NvbnN0W3osJF09cFtOXTtpZih6IT09ImFfY29sb3IiJiZ6IT09ImFfc291cmNlUmVjdCImJiQhPT0iaWdub3JlZCIpe2NvbnN0IFg9R1t6XTtpZih6PT09InV2IiYmIVgpe2NvbnN0IHc9dGhpc1tzXS5ib3VuZGluZ0JveHx8digpKGwpO3RoaXNbc10uYXR0cmlidXRlc1t6XT1mdCh3LGwpfWVsc2V7dGhpc1tzXS5hdHRyaWJ1dGVzW3pdPVtdO2ZvcihsZXQgdz0wO3c8bC5sZW5ndGg7dysrKXtjb25zdCBldD1sW3ddO3RoaXNbc10uYXR0cmlidXRlc1t6XS5wdXNoKFg/WChldCxOLGwpOkFycmF5KCQuc2l6ZSkuZmlsbCgwKSl9fX19fWdldCBtZXNoRGF0YSgpe2lmKHRoaXMuX3VwZGF0ZU1hdHJpeCYmdGhpcy50cmFuc2Zvcm1TY2FsZS90aGlzLmNvbnRvdXJzLnNjYWxlPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKSwhdGhpc1tzXSl7IXRoaXNbU10mJiF0aGlzW1BdJiZ0aGlzLnNldEZpbGwoKTtjb25zdCBqPXRoaXNbTV0sRz17fTtpZihqJiZqLmxlbmd0aCl7aWYodGhpc1tTXSl0cnl7Y29uc3QgTj15KCkoaix0aGlzW1NdKTtOLnBvc2l0aW9ucz1OLnBvc2l0aW9ucy5tYXAoej0+KHoucHVzaCh0aGlzW1pdKSx6KSksTi5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpOLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbT10ubWFwKHo9Pk1hdGgucm91bmQoMjU1KnopKSl9LEcuZmlsbD1OfWNhdGNoe31pZih0aGlzW1BdKXtjb25zdCBOPXRoaXNbUF0ubGluZURhc2g7bGV0IHo9ajtpZihOKXtjb25zdCBYPXRoaXNbUF0ubGluZURhc2hPZmZzZXQ7ej1PYmplY3QoZi5nZXREYXNoQ29udG91cnMpKGosTixYKX1jb25zdCAkPXoubWFwKChYLHcpPT57Y29uc3QgZXQ9WC5sZW5ndGg+MSYmYS52ZWMyLmVxdWFscyhYWzBdLFhbWC5sZW5ndGgtMV0pLHJ0PXRoaXNbUF0uYnVpbGQoWCxldCk7cmV0dXJuIHkoKShbcnRdKX0pOyQuZm9yRWFjaChYPT57WC5wb3NpdGlvbnM9WC5wb3NpdGlvbnMubWFwKHc9Pih3LnB1c2goLXRoaXNbWl0pLHcpKSxYLmF0dHJpYnV0ZXM9e2FfY29sb3I6QXJyYXkuZnJvbSh7bGVuZ3RoOlgucG9zaXRpb25zLmxlbmd0aH0pLm1hcCgoKT0+dGhpc1tiXS5tYXAodz0+TWF0aC5yb3VuZCgyNTUqdykpKX19KSxHLnN0cm9rZT1PYmplY3QoZC5kZWZhdWx0KSgkKX19Y29uc3QgbD1PYmplY3QoZC5kZWZhdWx0KShbRy5maWxsLEcuc3Ryb2tlXSk7bC5maWxsUG9pbnRDb3VudD1HLmZpbGw/Ry5maWxsLnBvc2l0aW9ucy5sZW5ndGg6MCxsLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQsbC5wb3NpdGlvbjA9bC5wb3NpdGlvbnMubWFwKChbTix6LCRdKT0+W04seiwkXSksbC51bmlmb3Jtcz10aGlzW1JdLHRoaXNbc109bCx0aGlzW1JdLnVfdGV4U2FtcGxlciYmdGhpc1tLXShsLHRoaXNbQV0pO2NvbnN0IHA9dGhpc1tEXTtPYmplY3QoRS5pc1VuaXRUcmFuc2Zvcm0pKHApfHwodGhpc1tWXShsLHApLHRoaXNbUl0udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1tRXSgpKSx0aGlzLmNsaXBQYXRoJiZ0aGlzW2N0XSgpLHRoaXNbdHRdJiZ0aGlzW3FdKHRoaXNbdHRdKX1yZXR1cm4gdGhpcy5fdXBkYXRlTWF0cml4JiYodGhpc1tzXS5tYXRyaXg9dGhpc1tEXSx0aGlzW1ZdKHRoaXNbc10sdGhpc1tEXSksdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW1FdKCkpLHRoaXNbc119W1ZdKGosRyl7Y29uc3R7cG9zaXRpb25zOmwscG9zaXRpb24wOnB9PWo7Zm9yKGxldCBOPTA7TjxsLmxlbmd0aDtOKyspe2NvbnN0W3osJF09cFtOXSxYPWxbTl07WFswXT16KkdbMF0rJCpHWzJdK0dbNF0sWFsxXT16KkdbMV0rJCpHWzNdK0dbNV19dGhpcy5fdXBkYXRlTWF0cml4PSExfVtRXSgpe2NvbnN0IGo9dGhpc1tEXSxHPVsuLi50aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcl07aWYoRyl7Y29uc3RbbCxwLCxOLHpdPUc7R1swXT1sKmpbMF0rcCpqWzJdK2pbNF0sR1sxXT1sKmpbMV0rcCpqWzNdK2pbNV0sR1szXT1OKmpbMF0reipqWzJdK2pbNF0sR1s0XT1OKmpbMV0reipqWzNdK2pbNV0sdGhpc1tSXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPUd9fVtLXShqLEcpe2Z1bmN0aW9uIGwodyxldCl7cmV0dXJuIHc9PW51bGwmJmV0PT1udWxsPyEwOnc9PW51bGx8fGV0PT1udWxsPyExOndbMF09PT1ldFswXSYmd1sxXT09PWV0WzFdJiZ3WzJdPT09ZXRbMl0mJndbM109PT1ldFszXX1jb25zdCBwPXRoaXNbUl0udV90ZXhTYW1wbGVyO2lmKCFwKXJldHVybjtjb25zdHt3aWR0aDpOLGhlaWdodDp6fT1wLl9pbWcsJD1HLnNyY1JlY3Q7bGV0IFg9Ry5yZWN0fHxbMCwwXTtpZihHLnJvdGF0ZWQmJihYPVstWFsxXSxYWzBdLFhbM10sWFsyXV0pLFhbMl09PW51bGwmJihYWzJdPSQ/JFsyXTpOKSxYWzNdPT1udWxsJiYoWFszXT0kPyRbM106eiksRy5oaWRkZW4pai50ZXh0dXJlQ29vcmQ9ai5wb3NpdGlvbnMubWFwKCgpPT5bLTEsLTEsLTFdKTtlbHNlIGlmKCFqLnRleHR1cmVDb29yZHx8IWwodGhpc1tBXS5yZWN0LEcucmVjdCl8fHRoaXNbQV0uaGlkZGVuIT09Ry5oaWRkZW58fHRoaXNbQV0ucm90YXRlZCE9PUcucm90YXRlZCl7bGV0IHc9bnVsbDtHLnJvdGF0ZWQmJih3PWEubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxhLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLC41Kk1hdGguUEkpLHc9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsWzAsLVhbMl1dKSksai50ZXh0dXJlQ29vcmQ9ai5wb3NpdGlvbjAubWFwKChbZXQscnQsYXRdKT0+e2lmKDEvYXQ+MCl7aWYoRy5yb3RhdGVkKXtjb25zdCBpdD1ldCp3WzBdK3J0KndbMl0rd1s0XSxudD1ldCp3WzFdK3J0KndbM10rd1s1XTtbZXQscnRdPVtpdCxudF19Y29uc3QgbHQ9QihbZXQscnRdLFtYWzBdL1hbMl0sWFsxXS9YWzNdLFhbMl0sWFszXV0sRyk7cmV0dXJuIEcucmVwZWF0JiYobHRbMl09MSksbHR9cmV0dXJuWy0xLC0xLC0xXX0pfWlmKCQpe2NvbnN0IHc9WyRbMF0vTiwkWzFdL3osJFsyXS9OLCRbM10vel07ai5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1qLnBvc2l0aW9ucy5tYXAoKCk9PlsuLi53XSl9ZWxzZSBqLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0PWoucG9zaXRpb25zLm1hcCgoKT0+WzAsMCwwLDBdKX1hY2N1cmF0ZShqKXtpZighdGhpcy5jb250b3VycylyZXR1cm47aWYodGhpcy5jb250b3Vycy5wYXRoKXtjb25zdCBsPXRoaXMuY29udG91cnMuc2ltcGxpZnkscD1GKHRoaXMuY29udG91cnMucGF0aCwyKmosbCk7dGhpc1tzXT1udWxsLHRoaXNbTV09cH19Y2FuSWdub3JlKCl7Y29uc3Qgaj10aGlzW1BdPT1udWxsfHx0aGlzW1BdLmxpbmVXaWR0aD09PTB8fHRoaXNbYl1bM109PT0wLEc9dGhpc1tTXT09bnVsbHx8dGhpc1tPXVszXT09PTAsbD10aGlzW1JdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3I9PW51bGwscD10aGlzW1JdLnVfdGV4U2FtcGxlcj09bnVsbDtyZXR1cm4gdGhpc1taXT09PTB8fHRoaXNbdHRdPT1udWxsJiZqJiZHJiZsJiZwJiYhdGhpcy5iZWZvcmVSZW5kZXImJiF0aGlzLmFmdGVyUmVuZGVyfXNldFN0cm9rZSh7dGhpY2tuZXNzOmo9MSxjYXA6Rz0iYnV0dCIsam9pbjpsPSJtaXRlciIsbWl0ZXJMaW1pdDpwPTEwLGNvbG9yOk49WzAsMCwwLDBdLGxpbmVEYXNoOno9bnVsbCxsaW5lRGFzaE9mZnNldDokPTAscm91bmRTZWdtZW50czpYPTIwfT17fSl7cmV0dXJuIHRoaXNbc109bnVsbCx0aGlzW1BdPW5ldyBULmRlZmF1bHQoe2xpbmVXaWR0aDpqLGxpbmVDYXA6RyxsaW5lSm9pbjpsLG1pdGVyTGltaXQ6cCxyb3VuZFNlZ21lbnRzOlh9KSx0eXBlb2YgTj09InN0cmluZyImJihOPU9iamVjdChoLmRlZmF1bHQpKE4pKSx0aGlzW2JdPU4sdGhpc1tQXS5saW5lRGFzaD16LHRoaXNbUF0ubGluZURhc2hPZmZzZXQ9JCx0aGlzfXNldEZpbGwoe3J1bGU6aj10aGlzLmZpbGxSdWxlLGNvbG9yOkc9WzAsMCwwLDBdfT17fSl7cmV0dXJuIHRoaXNbc109bnVsbCx0aGlzW1NdPXtydWxlOmp9LHR5cGVvZiBHPT0ic3RyaW5nIiYmKEc9T2JqZWN0KGguZGVmYXVsdCkoRykpLHRoaXNbT109Ryx0aGlzfXNldFRleHR1cmUoaixHPXt9KXtpZihqJiZqLmltYWdlKXtjb25zdHtpbWFnZTpsLHJlY3Q6cH09ajtpZihqPWwsRy5yZWN0KWZvcihsZXQgTj0wO048Ry5yZWN0Lmxlbmd0aDtOKyspcFtOXT1HLnJlY3RbTl07Ry5yZWN0PXB9cmV0dXJuIHRoaXNbU118fHRoaXMuc2V0RmlsbCgpLHRoaXMuc2V0VW5pZm9ybXMoe3VfdGV4U2FtcGxlcjpqfSksdGhpc1tzXSYmdGhpc1tLXSh0aGlzW3NdLEcpLHRoaXNbQV09Ryx0aGlzfXNldENpcmN1bGFyR3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczpHLHR5cGU6bD0iZmlsbCJ9PXt9KXtpZihqLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6Ryx0eXBlOmx9KX1zZXRMaW5lYXJHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOkcsdHlwZTpsPSJmaWxsIn09e30pe2lmKGoubGVuZ3RoIT09NCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVhckdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczpHLHR5cGU6bH0pfXNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6aixjb2xvcnM6Ryx0eXBlOmw9ImZpbGwifT17fSl7aWYoai5sZW5ndGghPT02KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcmFkaWFsR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOmosY29sb3JzOkcsdHlwZTpsfSl9c2V0R3JhZGllbnQoe3ZlY3RvcjpqLGNvbG9yczpHLHR5cGU6bD0iZmlsbCJ9PXt9KXtHPUcubWFwKCh7b2Zmc2V0OnosY29sb3I6JH0pPT4odHlwZW9mICQ9PSJzdHJpbmciJiYoJD1PYmplY3QoaC5kZWZhdWx0KSgkKSkse29mZnNldDp6LGNvbG9yOiR9KSksdGhpc1tXXT10aGlzW1ddfHx7fSx0aGlzW1ddW2xdPXt2ZWN0b3I6aixjb2xvcnM6R30sRy5zb3J0KCh6LCQpPT56Lm9mZnNldC0kLm9mZnNldCk7Y29uc3QgcD1bXTtHLmZvckVhY2goKHtvZmZzZXQ6eixjb2xvcjokfSk9PntwLnB1c2goeiwuLi4kKX0pO2xldCBOO2lmKGoubGVuZ3RoPT09ND9OPVtqWzBdLGpbMV0sMCxqWzJdLGpbM10sMF06Tj1bLi4ual0scC5sZW5ndGg8NDAmJnAucHVzaCgtMSkscC5sZW5ndGg+NDApdGhyb3cgbmV3IEVycm9yKCJUb28gbWFueSBjb2xvcnMsIHNob3VsZCBiZSBsZXNzIHRoYW4gOCBjb2xvcnMiKTtyZXR1cm4gdGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3I9Tix0aGlzW1JdLnVfY29sb3JTdGVwcz1wLGw9PT0iZmlsbCI/dGhpc1tSXS51X2dyYWRpZW50VHlwZT0xOnRoaXNbUl0udV9ncmFkaWVudFR5cGU9MCx0aGlzW1FdKCksdGhpc31zZXRVbmlmb3JtcyhqPXt9KXtyZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzW1JdLGopLHRoaXN9c2V0VHJhbnNmb3JtKC4uLmope2NvbnN0IEc9dGhpc1tEXTtyZXR1cm4gYS5tYXQyZC5lcXVhbHMoaixHKXx8KHRoaXNbRF09aixkZWxldGUgdGhpc1tJXSx0aGlzLl91cGRhdGVNYXRyaXg9ITApLHRoaXN9dHJhbnNmb3JtKC4uLmope2NvbnN0IEc9dGhpc1tEXTtyZXR1cm4gdGhpc1tEXT1hLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxHLGopLGRlbGV0ZSB0aGlzW0ldLHRoaXMuX3VwZGF0ZU1hdHJpeD0hMCx0aGlzfXRyYW5zbGF0ZShqLEcpe2xldCBsPWEubWF0MmQuY3JlYXRlKCk7cmV0dXJuIGw9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGwsW2osR10pLHRoaXMudHJhbnNmb3JtKC4uLmwpfXJvdGF0ZShqLFtHLGxdPVswLDBdKXtsZXQgcD1hLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBwPWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxwLFtHLGxdKSxwPWEubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxwLGopLHA9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHAsWy1HLC1sXSksdGhpcy50cmFuc2Zvcm0oLi4ucCl9c2NhbGUoaixHPWosW2wscF09WzAsMF0pe2xldCBOPWEubWF0MmQuY3JlYXRlKCk7cmV0dXJuIE49YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sW2wscF0pLE49YS5tYXQyZC5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbaixHXSksTj1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksTixbLWwsLXBdKSx0aGlzLnRyYW5zZm9ybSguLi5OKX1za2V3KGosRz1qLFtsLHBdPVswLDBdKXtsZXQgTj1hLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBOPWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFtsLHBdKSxOPWEubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLE4sYS5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRyksTWF0aC50YW4oaiksMSwwLDApKSxOPWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxOLFstbCwtcF0pLHRoaXMudHJhbnNmb3JtKC4uLk4pfWNsZWFyRmlsdGVyKCl7cmV0dXJuIHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0obnVsbCksdGhpc1tIXS5sZW5ndGg9MCx0aGlzfXNldENvbG9yVHJhbnNmb3JtKC4uLmope3JldHVybiBqWzBdPT09bnVsbD90aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MCx1X2NvbG9yTWF0cml4OjB9KTp0aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MSx1X2NvbG9yTWF0cml4Omp9KSx0aGlzfXRyYW5zZm9ybUNvbG9yKC4uLmope2xldCBHPXRoaXMudW5pZm9ybXMudV9jb2xvck1hdHJpeDtyZXR1cm4gRz9HPU9iamVjdChjLm11bHRpcGx5KShHLGopOkc9aix0aGlzLnNldENvbG9yVHJhbnNmb3JtKC4uLkcpLHRoaXN9Ymx1cihqKXtyZXR1cm4gdGhpc1tIXS5wdXNoKGBibHVyKCR7an1weClgKSx0aGlzfWJyaWdodG5lc3Moaj0xKXtyZXR1cm4gdGhpc1tIXS5wdXNoKGBicmlnaHRuZXNzKCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLmJyaWdodG5lc3MpKGopKX1jb250cmFzdChqPTEpe3JldHVybiB0aGlzW0hdLnB1c2goYGNvbnRyYXN0KCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLmNvbnRyYXN0KShqKSl9ZHJvcFNoYWRvdyhqLEcsbD0wLHA9WzAsMCwwLDFdKXtyZXR1cm4gQXJyYXkuaXNBcnJheShwKSYmKHA9T2JqZWN0KHUuZGVmYXVsdCkocCkpLHRoaXNbSF0ucHVzaChgZHJvcC1zaGFkb3coJHtqfXB4ICR7R31weCAke2x9cHggJHtwfSlgKSx0aGlzfWdyYXlzY2FsZShqPTEpe3JldHVybiB0aGlzW0hdLnB1c2goYGdyYXlzY2FsZSgkezEwMCpqfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoYy5ncmF5c2NhbGUpKGopKX1odWVSb3RhdGUoaj0wKXtyZXR1cm4gdGhpc1tIXS5wdXNoKGBodWUtcm90YXRlKCR7an1kZWcpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoYy5odWVSb3RhdGUpKGopKX1pbnZlcnQoaj0xKXtyZXR1cm4gdGhpc1tIXS5wdXNoKGBpbnZlcnQoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMuaW52ZXJ0KShqKSl9b3BhY2l0eShqPTEpe3JldHVybiB0aGlzW0hdLnB1c2goYG9wYWNpdHkoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMub3BhY2l0eSkoaikpfXNhdHVyYXRlKGo9MSl7cmV0dXJuIHRoaXNbSF0ucHVzaChgc2F0dXJhdGUoJHsxMDAqan0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMuc2F0dXJhdGUpKGopKX1zZXBpYShqPTEpe3JldHVybiB0aGlzW0hdLnB1c2goYHNlcGlhKCR7MTAwKmp9JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLnNlcGlhKShqKSl9dXJsKGope3JldHVybiB0aGlzW0hdLnB1c2goYHVybCgke2p9KWApLHRoaXN9aXNQb2ludENvbGxpc2lvbihqLEcsbD0iYm90aCIpe2NvbnN0IHA9dGhpcy5tZXNoRGF0YSx7cG9zaXRpb25zOk4sY2VsbHM6en09cCwkPXRoaXMuaW52ZXJ0TWF0cml4LFg9JFswXSpqKyRbMl0qRyskWzRdLHc9JFsxXSpqKyRbM10qRyskWzVdLGV0PXRoaXMuYm91bmRpbmdCb3g7aWYoWDxldFswXVswXXx8WD5ldFsxXVswXXx8dzxldFswXVsxXXx8dz5ldFsxXVsxXSlyZXR1cm4hMTtmdW5jdGlvbiBydChbYXQsbHRdLFtpdCxudF0sW290LGh0XSl7Y29uc3QgZHQ9b3QtaXQsdXQ9aHQtbnQsbXQ9KChhdC1pdCkqZHQrKGx0LW50KSp1dCkvKGR0KioyK3V0KioyKTtyZXR1cm4gbXQ+PTAmJm10PD0xfWZvcihsZXQgYXQ9MDthdDx6Lmxlbmd0aDthdCsrKXtjb25zdCBsdD16W2F0XTtpZihsPT09ImZpbGwiJiZsdFswXT49cC5maWxsUG9pbnRDb3VudClicmVhaztpZihsPT09InN0cm9rZSImJmx0WzBdPHAuZmlsbFBvaW50Q291bnQpY29udGludWU7Y29uc3RbW2l0LG50XSxbb3QsaHRdLFtkdCx1dF1dPWx0Lm1hcCh5dD0+Tlt5dF0pLG10PU1hdGguc2lnbigoai1pdCkqKGh0LW50KS0ob3QtaXQpKihHLW50KSk7aWYobXQ9PT0wJiZydChbaixHXSxbaXQsbnRdLFtvdCxodF0pKXJldHVybiEwO2NvbnN0IE10PU1hdGguc2lnbigoai1vdCkqKHV0LWh0KS0oZHQtb3QpKihHLWh0KSk7aWYoTXQ9PT0wJiZydChbaixHXSxbb3QsaHRdLFtkdCx1dF0pKXJldHVybiEwO2NvbnN0IHZ0PU1hdGguc2lnbigoai1kdCkqKG50LXV0KS0oaXQtZHQpKihHLXV0KSk7aWYodnQ9PT0wJiZydChbaixHXSxbZHQsdXRdLFtpdCxudF0pfHxtdD09PTEmJk10PT09MSYmdnQ9PT0xfHxtdD09PS0xJiZNdD09PS0xJiZ2dD09PS0xKXJldHVybiEwfXJldHVybiExfWlzUG9pbnRJbkZpbGwoaixHKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKGosRywiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShqLEcpe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oaixHLCJzdHJva2UiKX1hZGRQYXNzKGosRz17fSl7bGV0e3dpZHRoOmwsaGVpZ2h0OnB9PUcsTj1pKEcsWyJ3aWR0aCIsImhlaWdodCJdKTtjb25zdCB6PW5ldyBtLmRlZmF1bHQ7ei5yZWN0KDAsMCxsLHApO2NvbnN0ICQ9bmV3IFkoeix7d2lkdGg6bCxoZWlnaHQ6cH0pOyQuc2V0VW5pZm9ybXMoTiksJC5zZXRQcm9ncmFtKGopLHRoaXNbc3RdLnB1c2goJCl9fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKTt2YXIgYT10KDU4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWEuU3Ryb2tlfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJTdHJva2UiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KTt2YXIgYT10KDQ5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgbz1PYmplY3QoYS5jcmVhdGUpKCksdj1PYmplY3QoYS5jcmVhdGUpKCksVD1PYmplY3QoYS5jcmVhdGUpKCksZD1PYmplY3QoYS5jcmVhdGUpKCksdT1PYmplY3QoYS5jcmVhdGUpKCksYz0xZTIwO2NsYXNzIEV7Y29uc3RydWN0b3Ioe2xpbmVXaWR0aDp4PTEsbGluZUpvaW46aD0ibWl0ZXIiLG1pdGVyTGltaXQ6bT0xMCxsaW5lQ2FwOnI9ImJ1dHQiLHJvdW5kU2VnbWVudHM6aT0yMH09e30pe3RoaXMubGluZVdpZHRoPXgsdGhpcy5saW5lSm9pbj1oLHRoaXMubWl0ZXJMaW1pdD1tLHRoaXMubGluZUNhcD1yLHRoaXMucm91bmRTZWdtZW50cz1pLHRoaXMuX25vcm1hbD1udWxsfWJ1aWxkKHgsaD0hMSl7bGV0IG09eC5sZW5ndGg7aWYoeD1bLi4ueF0sbTwyKXJldHVybiB4O2gmJigoeFswXVswXSE9PXhbbS0xXVswXXx8eFswXVsxXSE9PXhbbS0xXVsxXSkmJngucHVzaChbLi4ueFswXV0pLHgucHVzaChbLi4ueFsxXV0pKSxtPXgubGVuZ3RoLHRoaXMuX25vcm1hbD1udWxsO2NvbnN0IHI9e2xlZnQ6W10scmlnaHQ6W119LGk9dGhpcy5saW5lV2lkdGgvMixuPXRoaXMubGluZUNhcDtpZighaCYmbj09PSJzcXVhcmUiKXtPYmplY3QoYS5kaXJlY3Rpb24pKHYseFswXSx4WzFdKSxPYmplY3QoYS5zY2FsZUFuZEFkZCkoeFswXSx4WzBdLHYsaSk7Y29uc3QgTT14Lmxlbmd0aC0xO09iamVjdChhLmRpcmVjdGlvbikodix4W01dLHhbTS0xXSksT2JqZWN0KGEuc2NhbGVBbmRBZGQpKHhbTV0seFtNXSx2LGkpfWZvcihsZXQgTT0xO008bTtNKyspe2NvbnN0IFA9eFtNLTFdLFM9eFtNXSxiPXhbTSsxXTt0aGlzLl9zZWcocixQLFMsYixpLGgpfXJldHVybiFoJiZuPT09InJvdW5kIiYmeShyLHRoaXMucm91bmRTZWdtZW50cyksWy4uLnIubGVmdCwuLi5yLnJpZ2h0LnJldmVyc2UoKV19X3NlZyh4LGgsbSxyLGksbil7Y29uc3Qgcz10aGlzLmxpbmVKb2luPT09ImJldmVsIixNPXRoaXMubGluZUpvaW49PT0icm91bmQiO2lmKE9iamVjdChhLmRpcmVjdGlvbikodixtLGgpLHRoaXMuX25vcm1hbHx8KHRoaXMuX25vcm1hbD1PYmplY3QoYS5jcmVhdGUpKCksT2JqZWN0KGEubm9ybWFsKSh0aGlzLl9ub3JtYWwsdikpLHgubGVmdC5sZW5ndGh8fGcoeCxoLHRoaXMuX25vcm1hbCxpKSwhcilPYmplY3QoYS5ub3JtYWwpKHRoaXMuX25vcm1hbCx2KSxuP2coeCxoLHRoaXMuX25vcm1hbCxpKTpnKHgsbSx0aGlzLl9ub3JtYWwsaSk7ZWxzZXtPYmplY3QoYS5kaXJlY3Rpb24pKFQscixtKTtsZXQgUD1PYmplY3QoYS5jb21wdXRlTWl0ZXIpKGQsdSx2LFQsaSk7UD1NYXRoLm1pbihQLGMpO2NvbnN0IFM9T2JqZWN0KGEuZG90KShkLHRoaXMuX25vcm1hbCk8MD8tMToxO2xldCBiPXN8fE07aWYoIWImJnRoaXMubGluZUpvaW49PT0ibWl0ZXIiJiZQL2k+dGhpcy5taXRlckxpbWl0JiYoYj0hMCksYil7T2JqZWN0KGEuc2NhbGVBbmRBZGQpKG8sbSx0aGlzLl9ub3JtYWwsLWkqUyksZih4LG8sUyk7bGV0IE89MS8wO2gmJihPPU1hdGgubWluKE8sTWF0aC5oeXBvdChtWzBdLWhbMF0sbVsxXS1oWzFdKSkpLHImJihPPU1hdGgubWluKE8sTWF0aC5oeXBvdChyWzBdLW1bMF0sclsxXS1tWzFdKSkpO2NvbnN0IEQ9TWF0aC5tYXgoaSxNYXRoLm1pbihQLE8pKTtpZihPYmplY3QoYS5zY2FsZUFuZEFkZCkobyxtLHUsRCpTKSxmKHgsbywtUykscilpZihPYmplY3QoYS5ub3JtYWwpKG8sVCksT2JqZWN0KGEuY29weSkodGhpcy5fbm9ybWFsLG8pLE9iamVjdChhLnNjYWxlQW5kQWRkKShvLG0sbywtaSpTKSxNKXtjb25zdCBJPU9iamVjdChhLmNsb25lKShvKSxSPVM+MD94LmxlZnRbeC5sZWZ0Lmxlbmd0aC0xXTp4LnJpZ2h0W3gucmlnaHQubGVuZ3RoLTFdLEE9T2JqZWN0KGEuY2xvbmUpKG0pLFU9T2JqZWN0KGEuc3ViKShPYmplY3QoYS5jcmVhdGUpKCksUixBKSxLPU9iamVjdChhLnN1YikoT2JqZWN0KGEuY3JlYXRlKSgpLEksQSksVj1NYXRoLlBJL3RoaXMucm91bmRTZWdtZW50cztmb3IobGV0IFE9MDtRPHRoaXMucm91bmRTZWdtZW50cyYmKE9iamVjdChhLnJvdGF0ZSkoVSxVLFswLDBdLFMqViksTWF0aC5zaWduKE9iamVjdChhLmNyb3NzKShvLFUsSylbMl0pPT09Uyk7USsrKU9iamVjdChhLmFkZCkobyxVLEEpLGYoeCxvLFMpO2YoeCxJLFMpfWVsc2UgZih4LG8sUyl9ZWxzZSBnKHgsbSx1LFApLE9iamVjdChhLmNvcHkpKHRoaXMuX25vcm1hbCx1KX19fWZ1bmN0aW9uIGYoQyx4LGgpe2g+MD9DLmxlZnQucHVzaChPYmplY3QoYS5jbG9uZSkoeCkpOkMucmlnaHQucHVzaChPYmplY3QoYS5jbG9uZSkoeCkpfWZ1bmN0aW9uIGcoQyx4LGgsbSxyPS0xKXtPYmplY3QoYS5zY2FsZUFuZEFkZCkobyx4LGgsLW0pLGYoQyxvLC1yKSxPYmplY3QoYS5zY2FsZUFuZEFkZCkobyx4LGgsbSksZihDLG8scil9ZnVuY3Rpb24geSh7bGVmdDpDLHJpZ2h0Onh9LGgpe2NvbnN0IG09T2JqZWN0KGEuY3JlYXRlKSgpLHI9T2JqZWN0KGEuY3JlYXRlKSgpO2xldCBpPUNbMF0sbj14WzBdLHM9Wy41KihpWzBdK25bMF0pLC41KihpWzFdK25bMV0pXTtPYmplY3QoYS5zdWIpKHIsaSxzKTtmb3IobGV0IE09MTtNPD1oO00rKyl7Y29uc3QgUD0tMSpNYXRoLlBJKk0vaDtPYmplY3QoYS5yb3RhdGUpKG0scixbMCwwXSxQKSxPYmplY3QoYS5hZGQpKG8scyxtKSxDLnVuc2hpZnQoT2JqZWN0KGEuY2xvbmUpKG8pKX1pPXhbeC5sZW5ndGgtMV0sbj1DW0MubGVuZ3RoLTFdLHM9Wy41KihpWzBdK25bMF0pLC41KihpWzFdK25bMV0pXSxPYmplY3QoYS5zdWIpKHIsaSxzKTtmb3IobGV0IE09MTtNPD1oO00rKyl7Y29uc3QgUD0tMSpNYXRoLlBJKk0vaDtPYmplY3QoYS5yb3RhdGUpKG0scixbMCwwXSxQKSxPYmplY3QoYS5hZGQpKG8scyxtKSx4LnB1c2goT2JqZWN0KGEuY2xvbmUpKG8pKX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJpc1VuaXRUcmFuc2Zvcm0iLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShvKXtyZXR1cm4gb1swXT09PTEmJm9bMV09PT0wJiZvWzJdPT09MCYmb1szXT09PTEmJm9bNF09PT0wJiZvWzVdPT09MH19LGZ1bmN0aW9uKEwsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIGE9dCg2MSksbz10KDYyKTtMLmV4cG9ydHM9ZnVuY3Rpb24odixUKXtpZihUPVR8fHt9LHY9di5maWx0ZXIoZnVuY3Rpb24oaCl7cmV0dXJuIGgubGVuZ3RoPjJ9KSx2Lmxlbmd0aD09PTApcmV0dXJue3Bvc2l0aW9uczpbXSxjZWxsczpbXX07dHlwZW9mIFQudmVydGV4U2l6ZSE9Im51bWJlciImJihULnZlcnRleFNpemU9dlswXVswXS5sZW5ndGgpLHY9di5tYXAoZnVuY3Rpb24oaCl7cmV0dXJuIGgucmVkdWNlKGZ1bmN0aW9uKG0scil7cmV0dXJuIG0uY29uY2F0KHIpfSl9KTtjb25zdCBkPVQucnVsZT09PSJldmVub2RkIj9hLldJTkRJTkdfT0REOmEuV0lORElOR19OT05aRVJPO2Zvcih2YXIgdT1hLnRlc3NlbGF0ZShvKHtjb250b3Vyczp2LHdpbmRpbmdSdWxlOmQsZWxlbWVudFR5cGU6YS5QT0xZR09OUyxwb2x5U2l6ZTozLHZlcnRleFNpemU6Mn0sVCkpLGM9W10sRT0wO0U8dS52ZXJ0aWNlcy5sZW5ndGg7RSs9VC52ZXJ0ZXhTaXplKXt2YXIgZj11LnZlcnRpY2VzLnNsaWNlKEUsRStULnZlcnRleFNpemUpO2MucHVzaChmKX12YXIgZz1bXTtmb3IoRT0wO0U8dS5lbGVtZW50cy5sZW5ndGg7RSs9Myl7dmFyIHk9dS5lbGVtZW50c1tFXSxDPXUuZWxlbWVudHNbRSsxXSx4PXUuZWxlbWVudHNbRSsyXTtnLnB1c2goW3ksQyx4XSl9cmV0dXJue3Bvc2l0aW9uczpjLGNlbGxzOmd9fX0sZnVuY3Rpb24oTCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgYT17fSxvPXt9O0wuZXhwb3J0cz1hLGEuV0lORElOR19PREQ9MCxhLldJTkRJTkdfTk9OWkVSTz0xLGEuV0lORElOR19QT1NJVElWRT0yLGEuV0lORElOR19ORUdBVElWRT0zLGEuV0lORElOR19BQlNfR0VRX1RXTz00LGEuUE9MWUdPTlM9MCxhLkNPTk5FQ1RFRF9QT0xZR09OUz0xLGEuQk9VTkRBUllfQ09OVE9VUlM9MixhLnRlc3NlbGF0ZT1mdW5jdGlvbihyKXtmb3IodmFyIGk9ci5kZWJ1Z3x8ITEsbj1uZXcgbSxzPTA7czxyLmNvbnRvdXJzLmxlbmd0aDtzKyspbi5hZGRDb250b3VyKHIudmVydGV4U2l6ZXx8MixyLmNvbnRvdXJzW3NdKTtyZXR1cm4gbi50ZXNzZWxhdGUoci53aW5kaW5nUnVsZXx8YS5XSU5ESU5HX09ERCxyLmVsZW1lbnRUeXBlfHxhLlBPTFlHT05TLHIucG9seVNpemV8fDMsci52ZXJ0ZXhTaXplfHwyLHIubm9ybWFsfHxbMCwwLDFdKSx7dmVydGljZXM6bi52ZXJ0aWNlcyx2ZXJ0ZXhJbmRpY2VzOm4udmVydGV4SW5kaWNlcyx2ZXJ0ZXhDb3VudDpuLnZlcnRleENvdW50LGVsZW1lbnRzOm4uZWxlbWVudHMsZWxlbWVudENvdW50Om4uZWxlbWVudENvdW50LG1lc2g6aT9uLm1lc2g6dm9pZCAwfX07dmFyIHY9ZnVuY3Rpb24ocil7aWYoIXIpdGhyb3ciQXNzZXJ0aW9uIEZhaWxlZCEifTtmdW5jdGlvbiBUKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLmNvb3Jkcz1bMCwwLDBdLHRoaXMucz0wLHRoaXMudD0wLHRoaXMucHFIYW5kbGU9MCx0aGlzLm49MCx0aGlzLmlkeD0wfWZ1bmN0aW9uIGQoKXt0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbCx0aGlzLmFuRWRnZT1udWxsLHRoaXMudHJhaWw9bnVsbCx0aGlzLm49MCx0aGlzLm1hcmtlZD0hMSx0aGlzLmluc2lkZT0hMX1mdW5jdGlvbiB1KHIpe3RoaXMubmV4dD1udWxsLHRoaXMuU3ltPW51bGwsdGhpcy5PbmV4dD1udWxsLHRoaXMuTG5leHQ9bnVsbCx0aGlzLk9yZz1udWxsLHRoaXMuTGZhY2U9bnVsbCx0aGlzLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMud2luZGluZz0wLHRoaXMuc2lkZT1yfXUucHJvdG90eXBlPXtnZXQgUmZhY2UoKXtyZXR1cm4gdGhpcy5TeW0uTGZhY2V9LHNldCBSZmFjZShyKXt0aGlzLlN5bS5MZmFjZT1yfSxnZXQgRHN0KCl7cmV0dXJuIHRoaXMuU3ltLk9yZ30sc2V0IERzdChyKXt0aGlzLlN5bS5Pcmc9cn0sZ2V0IE9wcmV2KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0fSxzZXQgT3ByZXYocil7dGhpcy5TeW0uTG5leHQ9cn0sZ2V0IExwcmV2KCl7cmV0dXJuIHRoaXMuT25leHQuU3ltfSxzZXQgTHByZXYocil7dGhpcy5PbmV4dC5TeW09cn0sZ2V0IERwcmV2KCl7cmV0dXJuIHRoaXMuTG5leHQuU3ltfSxzZXQgRHByZXYocil7dGhpcy5MbmV4dC5TeW09cn0sZ2V0IFJwcmV2KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0fSxzZXQgUnByZXYocil7dGhpcy5TeW0uT25leHQ9cn0sZ2V0IERuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0LlN5bX0sc2V0IERuZXh0KHIpe3RoaXMuU3ltLk9uZXh0LlN5bT1yfSxnZXQgUm5leHQoKXtyZXR1cm4gdGhpcy5TeW0uTG5leHQuU3ltfSxzZXQgUm5leHQocil7dGhpcy5TeW0uTG5leHQuU3ltPXJ9fTtmdW5jdGlvbiBjKCl7dmFyIHI9bmV3IFQsaT1uZXcgZCxuPW5ldyB1KDApLHM9bmV3IHUoMSk7ci5uZXh0PXIucHJldj1yLHIuYW5FZGdlPW51bGwsaS5uZXh0PWkucHJldj1pLGkuYW5FZGdlPW51bGwsaS50cmFpbD1udWxsLGkubWFya2VkPSExLGkuaW5zaWRlPSExLG4ubmV4dD1uLG4uU3ltPXMsbi5PbmV4dD1udWxsLG4uTG5leHQ9bnVsbCxuLk9yZz1udWxsLG4uTGZhY2U9bnVsbCxuLndpbmRpbmc9MCxuLmFjdGl2ZVJlZ2lvbj1udWxsLHMubmV4dD1zLHMuU3ltPW4scy5PbmV4dD1udWxsLHMuTG5leHQ9bnVsbCxzLk9yZz1udWxsLHMuTGZhY2U9bnVsbCxzLndpbmRpbmc9MCxzLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMudkhlYWQ9cix0aGlzLmZIZWFkPWksdGhpcy5lSGVhZD1uLHRoaXMuZUhlYWRTeW09c31jLnByb3RvdHlwZT17bWFrZUVkZ2VfOmZ1bmN0aW9uKHIpe3ZhciBpPW5ldyB1KDApLG49bmV3IHUoMSk7ci5TeW0uc2lkZTxyLnNpZGUmJihyPXIuU3ltKTt2YXIgcz1yLlN5bS5uZXh0O3JldHVybiBuLm5leHQ9cyxzLlN5bS5uZXh0PWksaS5uZXh0PXIsci5TeW0ubmV4dD1uLGkuU3ltPW4saS5PbmV4dD1pLGkuTG5leHQ9bixpLk9yZz1udWxsLGkuTGZhY2U9bnVsbCxpLndpbmRpbmc9MCxpLmFjdGl2ZVJlZ2lvbj1udWxsLG4uU3ltPWksbi5PbmV4dD1uLG4uTG5leHQ9aSxuLk9yZz1udWxsLG4uTGZhY2U9bnVsbCxuLndpbmRpbmc9MCxuLmFjdGl2ZVJlZ2lvbj1udWxsLGl9LHNwbGljZV86ZnVuY3Rpb24ocixpKXt2YXIgbj1yLk9uZXh0LHM9aS5PbmV4dDtuLlN5bS5MbmV4dD1pLHMuU3ltLkxuZXh0PXIsci5PbmV4dD1zLGkuT25leHQ9bn0sbWFrZVZlcnRleF86ZnVuY3Rpb24ocixpLG4pe3ZhciBzPXI7dihzIT09bnVsbCk7dmFyIE09bi5wcmV2O3MucHJldj1NLE0ubmV4dD1zLHMubmV4dD1uLG4ucHJldj1zLHMuYW5FZGdlPWk7dmFyIFA9aTtkbyBQLk9yZz1zLFA9UC5PbmV4dDt3aGlsZShQIT09aSl9LG1ha2VGYWNlXzpmdW5jdGlvbihyLGksbil7dmFyIHM9cjt2KHMhPT1udWxsKTt2YXIgTT1uLnByZXY7cy5wcmV2PU0sTS5uZXh0PXMscy5uZXh0PW4sbi5wcmV2PXMscy5hbkVkZ2U9aSxzLnRyYWlsPW51bGwscy5tYXJrZWQ9ITEscy5pbnNpZGU9bi5pbnNpZGU7dmFyIFA9aTtkbyBQLkxmYWNlPXMsUD1QLkxuZXh0O3doaWxlKFAhPT1pKX0sa2lsbEVkZ2VfOmZ1bmN0aW9uKHIpe3IuU3ltLnNpZGU8ci5zaWRlJiYocj1yLlN5bSk7dmFyIGk9ci5uZXh0LG49ci5TeW0ubmV4dDtpLlN5bS5uZXh0PW4sbi5TeW0ubmV4dD1pfSxraWxsVmVydGV4XzpmdW5jdGlvbihyLGkpe3ZhciBuPXIuYW5FZGdlLHM9bjtkbyBzLk9yZz1pLHM9cy5PbmV4dDt3aGlsZShzIT09bik7dmFyIE09ci5wcmV2LFA9ci5uZXh0O1AucHJldj1NLE0ubmV4dD1QfSxraWxsRmFjZV86ZnVuY3Rpb24ocixpKXt2YXIgbj1yLmFuRWRnZSxzPW47ZG8gcy5MZmFjZT1pLHM9cy5MbmV4dDt3aGlsZShzIT09bik7dmFyIE09ci5wcmV2LFA9ci5uZXh0O1AucHJldj1NLE0ubmV4dD1QfSxtYWtlRWRnZTpmdW5jdGlvbigpe3ZhciByPW5ldyBULGk9bmV3IFQsbj1uZXcgZCxzPXRoaXMubWFrZUVkZ2VfKHRoaXMuZUhlYWQpO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKHIscyx0aGlzLnZIZWFkKSx0aGlzLm1ha2VWZXJ0ZXhfKGkscy5TeW0sdGhpcy52SGVhZCksdGhpcy5tYWtlRmFjZV8obixzLHRoaXMuZkhlYWQpLHN9LHNwbGljZTpmdW5jdGlvbihyLGkpe3ZhciBuPSExLHM9ITE7aWYociE9PWkpe2lmKGkuT3JnIT09ci5PcmcmJihzPSEwLHRoaXMua2lsbFZlcnRleF8oaS5Pcmcsci5PcmcpKSxpLkxmYWNlIT09ci5MZmFjZSYmKG49ITAsdGhpcy5raWxsRmFjZV8oaS5MZmFjZSxyLkxmYWNlKSksdGhpcy5zcGxpY2VfKGksciksIXMpe3ZhciBNPW5ldyBUO3RoaXMubWFrZVZlcnRleF8oTSxpLHIuT3JnKSxyLk9yZy5hbkVkZ2U9cn1pZighbil7dmFyIFA9bmV3IGQ7dGhpcy5tYWtlRmFjZV8oUCxpLHIuTGZhY2UpLHIuTGZhY2UuYW5FZGdlPXJ9fX0sZGVsZXRlOmZ1bmN0aW9uKHIpe3ZhciBpPXIuU3ltLG49ITE7aWYoci5MZmFjZSE9PXIuUmZhY2UmJihuPSEwLHRoaXMua2lsbEZhY2VfKHIuTGZhY2Usci5SZmFjZSkpLHIuT25leHQ9PT1yKXRoaXMua2lsbFZlcnRleF8oci5PcmcsbnVsbCk7ZWxzZSBpZihyLlJmYWNlLmFuRWRnZT1yLk9wcmV2LHIuT3JnLmFuRWRnZT1yLk9uZXh0LHRoaXMuc3BsaWNlXyhyLHIuT3ByZXYpLCFuKXt2YXIgcz1uZXcgZDt0aGlzLm1ha2VGYWNlXyhzLHIsci5MZmFjZSl9aS5PbmV4dD09PWk/KHRoaXMua2lsbFZlcnRleF8oaS5PcmcsbnVsbCksdGhpcy5raWxsRmFjZV8oaS5MZmFjZSxudWxsKSk6KHIuTGZhY2UuYW5FZGdlPWkuT3ByZXYsaS5PcmcuYW5FZGdlPWkuT25leHQsdGhpcy5zcGxpY2VfKGksaS5PcHJldikpLHRoaXMua2lsbEVkZ2VfKHIpfSxhZGRFZGdlVmVydGV4OmZ1bmN0aW9uKHIpe3ZhciBpPXRoaXMubWFrZUVkZ2VfKHIpLG49aS5TeW07dGhpcy5zcGxpY2VfKGksci5MbmV4dCksaS5Pcmc9ci5Ec3Q7dmFyIHM9bmV3IFQ7cmV0dXJuIHRoaXMubWFrZVZlcnRleF8ocyxuLGkuT3JnKSxpLkxmYWNlPW4uTGZhY2U9ci5MZmFjZSxpfSxzcGxpdEVkZ2U6ZnVuY3Rpb24ocixpKXt2YXIgbj10aGlzLmFkZEVkZ2VWZXJ0ZXgocikscz1uLlN5bTtyZXR1cm4gdGhpcy5zcGxpY2VfKHIuU3ltLHIuU3ltLk9wcmV2KSx0aGlzLnNwbGljZV8oci5TeW0scyksci5Ec3Q9cy5Pcmcscy5Ec3QuYW5FZGdlPXMuU3ltLHMuUmZhY2U9ci5SZmFjZSxzLndpbmRpbmc9ci53aW5kaW5nLHMuU3ltLndpbmRpbmc9ci5TeW0ud2luZGluZyxzfSxjb25uZWN0OmZ1bmN0aW9uKHIsaSl7dmFyIG49ITEscz10aGlzLm1ha2VFZGdlXyhyKSxNPXMuU3ltO2lmKGkuTGZhY2UhPT1yLkxmYWNlJiYobj0hMCx0aGlzLmtpbGxGYWNlXyhpLkxmYWNlLHIuTGZhY2UpKSx0aGlzLnNwbGljZV8ocyxyLkxuZXh0KSx0aGlzLnNwbGljZV8oTSxpKSxzLk9yZz1yLkRzdCxNLk9yZz1pLk9yZyxzLkxmYWNlPU0uTGZhY2U9ci5MZmFjZSxyLkxmYWNlLmFuRWRnZT1NLCFuKXt2YXIgUD1uZXcgZDt0aGlzLm1ha2VGYWNlXyhQLHMsci5MZmFjZSl9cmV0dXJuIHN9LHphcEZhY2U6ZnVuY3Rpb24ocil7dmFyIGk9ci5hbkVkZ2UsbixzLE0sUCxTO3M9aS5MbmV4dDtkbyBuPXMscz1uLkxuZXh0LG4uTGZhY2U9bnVsbCxuLlJmYWNlPT09bnVsbCYmKG4uT25leHQ9PT1uP3RoaXMua2lsbFZlcnRleF8obi5PcmcsbnVsbCk6KG4uT3JnLmFuRWRnZT1uLk9uZXh0LHRoaXMuc3BsaWNlXyhuLG4uT3ByZXYpKSxNPW4uU3ltLE0uT25leHQ9PT1NP3RoaXMua2lsbFZlcnRleF8oTS5PcmcsbnVsbCk6KE0uT3JnLmFuRWRnZT1NLk9uZXh0LHRoaXMuc3BsaWNlXyhNLE0uT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhuKSk7d2hpbGUobiE9aSk7UD1yLnByZXYsUz1yLm5leHQsUy5wcmV2PVAsUC5uZXh0PVN9LGNvdW50RmFjZVZlcnRzXzpmdW5jdGlvbihyKXt2YXIgaT1yLmFuRWRnZSxuPTA7ZG8gbisrLGk9aS5MbmV4dDt3aGlsZShpIT09ci5hbkVkZ2UpO3JldHVybiBufSxtZXJnZUNvbnZleEZhY2VzOmZ1bmN0aW9uKHIpe3ZhciBpLG4scyxNLFAsUyxiO2ZvcihpPXRoaXMuZkhlYWQubmV4dDtpIT09dGhpcy5mSGVhZDtpPWkubmV4dClpZihpLmluc2lkZSlmb3Iobj1pLmFuRWRnZSxQPW4uT3JnO3M9bi5MbmV4dCxNPW4uU3ltLE0mJk0uTGZhY2UmJk0uTGZhY2UuaW5zaWRlJiYoUz10aGlzLmNvdW50RmFjZVZlcnRzXyhpKSxiPXRoaXMuY291bnRGYWNlVmVydHNfKE0uTGZhY2UpLFMrYi0yPD1yJiZvLnZlcnRDQ1cobi5McHJldi5Pcmcsbi5PcmcsTS5MbmV4dC5MbmV4dC5PcmcpJiZvLnZlcnRDQ1coTS5McHJldi5PcmcsTS5Pcmcsbi5MbmV4dC5MbmV4dC5PcmcpJiYocz1NLkxuZXh0LHRoaXMuZGVsZXRlKE0pLG49bnVsbCxNPW51bGwpKSwhKG4mJm4uTG5leHQuT3JnPT09UCk7KW49cztyZXR1cm4hMH0sY2hlY2s6ZnVuY3Rpb24oKXt2YXIgcj10aGlzLmZIZWFkLGk9dGhpcy52SGVhZCxuPXRoaXMuZUhlYWQscyxNLFAsUyxiLE87Zm9yKE09cixNPXI7KHM9TS5uZXh0KSE9PXI7TT1zKXt2KHMucHJldj09PU0pLGI9cy5hbkVkZ2U7ZG8gdihiLlN5bSE9PWIpLHYoYi5TeW0uU3ltPT09YiksdihiLkxuZXh0Lk9uZXh0LlN5bT09PWIpLHYoYi5PbmV4dC5TeW0uTG5leHQ9PT1iKSx2KGIuTGZhY2U9PT1zKSxiPWIuTG5leHQ7d2hpbGUoYiE9PXMuYW5FZGdlKX1mb3IodihzLnByZXY9PT1NJiZzLmFuRWRnZT09PW51bGwpLFM9aSxTPWk7KFA9Uy5uZXh0KSE9PWk7Uz1QKXt2KFAucHJldj09PVMpLGI9UC5hbkVkZ2U7ZG8gdihiLlN5bSE9PWIpLHYoYi5TeW0uU3ltPT09YiksdihiLkxuZXh0Lk9uZXh0LlN5bT09PWIpLHYoYi5PbmV4dC5TeW0uTG5leHQ9PT1iKSx2KGIuT3JnPT09UCksYj1iLk9uZXh0O3doaWxlKGIhPT1QLmFuRWRnZSl9Zm9yKHYoUC5wcmV2PT09UyYmUC5hbkVkZ2U9PT1udWxsKSxPPW4sTz1uOyhiPU8ubmV4dCkhPT1uO089Yil2KGIuU3ltLm5leHQ9PT1PLlN5bSksdihiLlN5bSE9PWIpLHYoYi5TeW0uU3ltPT09YiksdihiLk9yZyE9PW51bGwpLHYoYi5Ec3QhPT1udWxsKSx2KGIuTG5leHQuT25leHQuU3ltPT09YiksdihiLk9uZXh0LlN5bS5MbmV4dD09PWIpO3YoYi5TeW0ubmV4dD09PU8uU3ltJiZiLlN5bT09PXRoaXMuZUhlYWRTeW0mJmIuU3ltLlN5bT09PWImJmIuT3JnPT09bnVsbCYmYi5Ec3Q9PT1udWxsJiZiLkxmYWNlPT09bnVsbCYmYi5SZmFjZT09PW51bGwpfX0sby52ZXJ0RXE9ZnVuY3Rpb24ocixpKXtyZXR1cm4gci5zPT09aS5zJiZyLnQ9PT1pLnR9LG8udmVydExlcT1mdW5jdGlvbihyLGkpe3JldHVybiByLnM8aS5zfHxyLnM9PT1pLnMmJnIudDw9aS50fSxvLnRyYW5zTGVxPWZ1bmN0aW9uKHIsaSl7cmV0dXJuIHIudDxpLnR8fHIudD09PWkudCYmci5zPD1pLnN9LG8uZWRnZUdvZXNMZWZ0PWZ1bmN0aW9uKHIpe3JldHVybiBvLnZlcnRMZXEoci5Ec3Qsci5PcmcpfSxvLmVkZ2VHb2VzUmlnaHQ9ZnVuY3Rpb24ocil7cmV0dXJuIG8udmVydExlcShyLk9yZyxyLkRzdCl9LG8udmVydEwxZGlzdD1mdW5jdGlvbihyLGkpe3JldHVybiBNYXRoLmFicyhyLnMtaS5zKStNYXRoLmFicyhyLnQtaS50KX0sby5lZGdlRXZhbD1mdW5jdGlvbihyLGksbil7dihvLnZlcnRMZXEocixpKSYmby52ZXJ0TGVxKGksbikpO3ZhciBzPWkucy1yLnMsTT1uLnMtaS5zO3JldHVybiBzK00+MD9zPE0/aS50LXIudCsoci50LW4udCkqKHMvKHMrTSkpOmkudC1uLnQrKG4udC1yLnQpKihNLyhzK00pKTowfSxvLmVkZ2VTaWduPWZ1bmN0aW9uKHIsaSxuKXt2KG8udmVydExlcShyLGkpJiZvLnZlcnRMZXEoaSxuKSk7dmFyIHM9aS5zLXIucyxNPW4ucy1pLnM7cmV0dXJuIHMrTT4wPyhpLnQtbi50KSpzKyhpLnQtci50KSpNOjB9LG8udHJhbnNFdmFsPWZ1bmN0aW9uKHIsaSxuKXt2KG8udHJhbnNMZXEocixpKSYmby50cmFuc0xlcShpLG4pKTt2YXIgcz1pLnQtci50LE09bi50LWkudDtyZXR1cm4gcytNPjA/czxNP2kucy1yLnMrKHIucy1uLnMpKihzLyhzK00pKTppLnMtbi5zKyhuLnMtci5zKSooTS8ocytNKSk6MH0sby50cmFuc1NpZ249ZnVuY3Rpb24ocixpLG4pe3Yoby50cmFuc0xlcShyLGkpJiZvLnRyYW5zTGVxKGksbikpO3ZhciBzPWkudC1yLnQsTT1uLnQtaS50O3JldHVybiBzK00+MD8oaS5zLW4ucykqcysoaS5zLXIucykqTTowfSxvLnZlcnRDQ1c9ZnVuY3Rpb24ocixpLG4pe3JldHVybiByLnMqKGkudC1uLnQpK2kucyoobi50LXIudCkrbi5zKihyLnQtaS50KT49MH0sby5pbnRlcnBvbGF0ZT1mdW5jdGlvbihyLGksbixzKXtyZXR1cm4gcj1yPDA/MDpyLG49bjwwPzA6bixyPD1uP249PT0wPyhpK3MpLzI6aSsocy1pKSooci8ocituKSk6cysoaS1zKSoobi8ocituKSl9LG8uaW50ZXJzZWN0PWZ1bmN0aW9uKHIsaSxuLHMsTSl7dmFyIFAsUyxiO28udmVydExlcShyLGkpfHwoYj1yLHI9aSxpPWIpLG8udmVydExlcShuLHMpfHwoYj1uLG49cyxzPWIpLG8udmVydExlcShyLG4pfHwoYj1yLHI9bixuPWIsYj1pLGk9cyxzPWIpLG8udmVydExlcShuLGkpP28udmVydExlcShpLHMpPyhQPW8uZWRnZUV2YWwocixuLGkpLFM9by5lZGdlRXZhbChuLGkscyksUCtTPDAmJihQPS1QLFM9LVMpLE0ucz1vLmludGVycG9sYXRlKFAsbi5zLFMsaS5zKSk6KFA9by5lZGdlU2lnbihyLG4saSksUz0tby5lZGdlU2lnbihyLHMsaSksUCtTPDAmJihQPS1QLFM9LVMpLE0ucz1vLmludGVycG9sYXRlKFAsbi5zLFMscy5zKSk6TS5zPShuLnMraS5zKS8yLG8udHJhbnNMZXEocixpKXx8KGI9cixyPWksaT1iKSxvLnRyYW5zTGVxKG4scyl8fChiPW4sbj1zLHM9Yiksby50cmFuc0xlcShyLG4pfHwoYj1yLHI9bixuPWIsYj1pLGk9cyxzPWIpLG8udHJhbnNMZXEobixpKT9vLnRyYW5zTGVxKGkscyk/KFA9by50cmFuc0V2YWwocixuLGkpLFM9by50cmFuc0V2YWwobixpLHMpLFArUzwwJiYoUD0tUCxTPS1TKSxNLnQ9by5pbnRlcnBvbGF0ZShQLG4udCxTLGkudCkpOihQPW8udHJhbnNTaWduKHIsbixpKSxTPS1vLnRyYW5zU2lnbihyLHMsaSksUCtTPDAmJihQPS1QLFM9LVMpLE0udD1vLmludGVycG9sYXRlKFAsbi50LFMscy50KSk6TS50PShuLnQraS50KS8yfTtmdW5jdGlvbiBFKCl7dGhpcy5rZXk9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbH1mdW5jdGlvbiBmKHIsaSl7dGhpcy5oZWFkPW5ldyBFLHRoaXMuaGVhZC5uZXh0PXRoaXMuaGVhZCx0aGlzLmhlYWQucHJldj10aGlzLmhlYWQsdGhpcy5mcmFtZT1yLHRoaXMubGVxPWl9Zi5wcm90b3R5cGU9e21pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQubmV4dH0sbWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5wcmV2fSxpbnNlcnQ6ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCxyKX0sc2VhcmNoOmZ1bmN0aW9uKHIpe3ZhciBpPXRoaXMuaGVhZDtkbyBpPWkubmV4dDt3aGlsZShpLmtleSE9PW51bGwmJiF0aGlzLmxlcSh0aGlzLmZyYW1lLHIsaS5rZXkpKTtyZXR1cm4gaX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKHIsaSl7ZG8gcj1yLnByZXY7d2hpbGUoci5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxyLmtleSxpKSk7dmFyIG49bmV3IEU7cmV0dXJuIG4ua2V5PWksbi5uZXh0PXIubmV4dCxyLm5leHQucHJldj1uLG4ucHJldj1yLHIubmV4dD1uLG59LGRlbGV0ZTpmdW5jdGlvbihyKXtyLm5leHQucHJldj1yLnByZXYsci5wcmV2Lm5leHQ9ci5uZXh0fX07ZnVuY3Rpb24gZygpe3RoaXMuaGFuZGxlPW51bGx9ZnVuY3Rpb24geSgpe3RoaXMua2V5PW51bGwsdGhpcy5ub2RlPW51bGx9ZnVuY3Rpb24gQyhyLGkpe3RoaXMuc2l6ZT0wLHRoaXMubWF4PXIsdGhpcy5ub2Rlcz1bXSx0aGlzLm5vZGVzLmxlbmd0aD1yKzE7dmFyIG47Zm9yKG49MDtuPHRoaXMubm9kZXMubGVuZ3RoO24rKyl0aGlzLm5vZGVzW25dPW5ldyBnO2Zvcih0aGlzLmhhbmRsZXM9W10sdGhpcy5oYW5kbGVzLmxlbmd0aD1yKzEsbj0wO248dGhpcy5oYW5kbGVzLmxlbmd0aDtuKyspdGhpcy5oYW5kbGVzW25dPW5ldyB5O3RoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5mcmVlTGlzdD0wLHRoaXMubGVxPWksdGhpcy5ub2Rlc1sxXS5oYW5kbGU9MSx0aGlzLmhhbmRsZXNbMV0ua2V5PW51bGx9Qy5wcm90b3R5cGU9e2Zsb2F0RG93bl86ZnVuY3Rpb24ocil7dmFyIGk9dGhpcy5ub2RlcyxuPXRoaXMuaGFuZGxlcyxzLE0sUDtmb3Iocz1pW3JdLmhhbmRsZTs7KXtpZihQPXI8PDEsUDx0aGlzLnNpemUmJnRoaXMubGVxKG5baVtQKzFdLmhhbmRsZV0ua2V5LG5baVtQXS5oYW5kbGVdLmtleSkmJisrUCx2KFA8PXRoaXMubWF4KSxNPWlbUF0uaGFuZGxlLFA+dGhpcy5zaXplfHx0aGlzLmxlcShuW3NdLmtleSxuW01dLmtleSkpe2lbcl0uaGFuZGxlPXMsbltzXS5ub2RlPXI7YnJlYWt9aVtyXS5oYW5kbGU9TSxuW01dLm5vZGU9cixyPVB9fSxmbG9hdFVwXzpmdW5jdGlvbihyKXt2YXIgaT10aGlzLm5vZGVzLG49dGhpcy5oYW5kbGVzLHMsTSxQO2ZvcihzPWlbcl0uaGFuZGxlOzspe2lmKFA9cj4+MSxNPWlbUF0uaGFuZGxlLFA9PT0wfHx0aGlzLmxlcShuW01dLmtleSxuW3NdLmtleSkpe2lbcl0uaGFuZGxlPXMsbltzXS5ub2RlPXI7YnJlYWt9aVtyXS5oYW5kbGU9TSxuW01dLm5vZGU9cixyPVB9fSxpbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciByPXRoaXMuc2l6ZTtyPj0xOy0tcil0aGlzLmZsb2F0RG93bl8ocik7dGhpcy5pbml0aWFsaXplZD0hMH0sbWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFuZGxlc1t0aGlzLm5vZGVzWzFdLmhhbmRsZV0ua2V5fSxpbnNlcnQ6ZnVuY3Rpb24ocil7dmFyIGksbjtpZihpPSsrdGhpcy5zaXplLGkqMj50aGlzLm1heCl7dGhpcy5tYXgqPTI7dmFyIHMsTTtmb3IoTT10aGlzLm5vZGVzLmxlbmd0aCx0aGlzLm5vZGVzLmxlbmd0aD10aGlzLm1heCsxLHM9TTtzPHRoaXMubm9kZXMubGVuZ3RoO3MrKyl0aGlzLm5vZGVzW3NdPW5ldyBnO2ZvcihNPXRoaXMuaGFuZGxlcy5sZW5ndGgsdGhpcy5oYW5kbGVzLmxlbmd0aD10aGlzLm1heCsxLHM9TTtzPHRoaXMuaGFuZGxlcy5sZW5ndGg7cysrKXRoaXMuaGFuZGxlc1tzXT1uZXcgeX1yZXR1cm4gdGhpcy5mcmVlTGlzdD09PTA/bj1pOihuPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD10aGlzLmhhbmRsZXNbbl0ubm9kZSksdGhpcy5ub2Rlc1tpXS5oYW5kbGU9bix0aGlzLmhhbmRsZXNbbl0ubm9kZT1pLHRoaXMuaGFuZGxlc1tuXS5rZXk9cix0aGlzLmluaXRpYWxpemVkJiZ0aGlzLmZsb2F0VXBfKGkpLG59LGV4dHJhY3RNaW46ZnVuY3Rpb24oKXt2YXIgcj10aGlzLm5vZGVzLGk9dGhpcy5oYW5kbGVzLG49clsxXS5oYW5kbGUscz1pW25dLmtleTtyZXR1cm4gdGhpcy5zaXplPjAmJihyWzFdLmhhbmRsZT1yW3RoaXMuc2l6ZV0uaGFuZGxlLGlbclsxXS5oYW5kbGVdLm5vZGU9MSxpW25dLmtleT1udWxsLGlbbl0ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9biwtLXRoaXMuc2l6ZSx0aGlzLnNpemU+MCYmdGhpcy5mbG9hdERvd25fKDEpKSxzfSxkZWxldGU6ZnVuY3Rpb24ocil7dmFyIGk9dGhpcy5ub2RlcyxuPXRoaXMuaGFuZGxlcyxzO3Yocj49MSYmcjw9dGhpcy5tYXgmJm5bcl0ua2V5IT09bnVsbCkscz1uW3JdLm5vZGUsaVtzXS5oYW5kbGU9aVt0aGlzLnNpemVdLmhhbmRsZSxuW2lbc10uaGFuZGxlXS5ub2RlPXMsLS10aGlzLnNpemUsczw9dGhpcy5zaXplJiYoczw9MXx8dGhpcy5sZXEobltpW3M+PjFdLmhhbmRsZV0ua2V5LG5baVtzXS5oYW5kbGVdLmtleSk/dGhpcy5mbG9hdERvd25fKHMpOnRoaXMuZmxvYXRVcF8ocykpLG5bcl0ua2V5PW51bGwsbltyXS5ub2RlPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD1yfX07ZnVuY3Rpb24geCgpe3RoaXMuZVVwPW51bGwsdGhpcy5ub2RlVXA9bnVsbCx0aGlzLndpbmRpbmdOdW1iZXI9MCx0aGlzLmluc2lkZT0hMSx0aGlzLnNlbnRpbmVsPSExLHRoaXMuZGlydHk9ITEsdGhpcy5maXhVcHBlckVkZ2U9ITF9dmFyIGg9e307aC5yZWdpb25CZWxvdz1mdW5jdGlvbihyKXtyZXR1cm4gci5ub2RlVXAucHJldi5rZXl9LGgucmVnaW9uQWJvdmU9ZnVuY3Rpb24ocil7cmV0dXJuIHIubm9kZVVwLm5leHQua2V5fSxoLmRlYnVnRXZlbnQ9ZnVuY3Rpb24ocil7fSxoLmFkZFdpbmRpbmc9ZnVuY3Rpb24ocixpKXtyLndpbmRpbmcrPWkud2luZGluZyxyLlN5bS53aW5kaW5nKz1pLlN5bS53aW5kaW5nfSxoLmVkZ2VMZXE9ZnVuY3Rpb24ocixpLG4pe3ZhciBzPXIuZXZlbnQsUyxiLE09aS5lVXAsUD1uLmVVcDtpZihNLkRzdD09PXMpcmV0dXJuIFAuRHN0PT09cz9vLnZlcnRMZXEoTS5PcmcsUC5PcmcpP28uZWRnZVNpZ24oUC5Ec3QsTS5PcmcsUC5PcmcpPD0wOm8uZWRnZVNpZ24oTS5Ec3QsUC5PcmcsTS5PcmcpPj0wOm8uZWRnZVNpZ24oUC5Ec3QscyxQLk9yZyk8PTA7aWYoUC5Ec3Q9PT1zKXJldHVybiBvLmVkZ2VTaWduKE0uRHN0LHMsTS5PcmcpPj0wO3ZhciBTPW8uZWRnZUV2YWwoTS5Ec3QscyxNLk9yZyksYj1vLmVkZ2VFdmFsKFAuRHN0LHMsUC5PcmcpO3JldHVybiBTPj1ifSxoLmRlbGV0ZVJlZ2lvbj1mdW5jdGlvbihyLGkpe2kuZml4VXBwZXJFZGdlJiZ2KGkuZVVwLndpbmRpbmc9PT0wKSxpLmVVcC5hY3RpdmVSZWdpb249bnVsbCxyLmRpY3QuZGVsZXRlKGkubm9kZVVwKX0saC5maXhVcHBlckVkZ2U9ZnVuY3Rpb24ocixpLG4pe3YoaS5maXhVcHBlckVkZ2UpLHIubWVzaC5kZWxldGUoaS5lVXApLGkuZml4VXBwZXJFZGdlPSExLGkuZVVwPW4sbi5hY3RpdmVSZWdpb249aX0saC50b3BMZWZ0UmVnaW9uPWZ1bmN0aW9uKHIsaSl7dmFyIG49aS5lVXAuT3JnLHM7ZG8gaT1oLnJlZ2lvbkFib3ZlKGkpO3doaWxlKGkuZVVwLk9yZz09PW4pO2lmKGkuZml4VXBwZXJFZGdlKXtpZihzPXIubWVzaC5jb25uZWN0KGgucmVnaW9uQmVsb3coaSkuZVVwLlN5bSxpLmVVcC5MbmV4dCkscz09PW51bGwpcmV0dXJuIG51bGw7aC5maXhVcHBlckVkZ2UocixpLHMpLGk9aC5yZWdpb25BYm92ZShpKX1yZXR1cm4gaX0saC50b3BSaWdodFJlZ2lvbj1mdW5jdGlvbihyKXt2YXIgaT1yLmVVcC5Ec3Q7ZG8gcj1oLnJlZ2lvbkFib3ZlKHIpO3doaWxlKHIuZVVwLkRzdD09PWkpO3JldHVybiByfSxoLmFkZFJlZ2lvbkJlbG93PWZ1bmN0aW9uKHIsaSxuKXt2YXIgcz1uZXcgeDtyZXR1cm4gcy5lVXA9bixzLm5vZGVVcD1yLmRpY3QuaW5zZXJ0QmVmb3JlKGkubm9kZVVwLHMpLHMuZml4VXBwZXJFZGdlPSExLHMuc2VudGluZWw9ITEscy5kaXJ0eT0hMSxuLmFjdGl2ZVJlZ2lvbj1zLHN9LGguaXNXaW5kaW5nSW5zaWRlPWZ1bmN0aW9uKHIsaSl7c3dpdGNoKHIud2luZGluZ1J1bGUpe2Nhc2UgYS5XSU5ESU5HX09ERDpyZXR1cm4oaSYxKSE9PTA7Y2FzZSBhLldJTkRJTkdfTk9OWkVSTzpyZXR1cm4gaSE9PTA7Y2FzZSBhLldJTkRJTkdfUE9TSVRJVkU6cmV0dXJuIGk+MDtjYXNlIGEuV0lORElOR19ORUdBVElWRTpyZXR1cm4gaTwwO2Nhc2UgYS5XSU5ESU5HX0FCU19HRVFfVFdPOnJldHVybiBpPj0yfHxpPD0tMn1yZXR1cm4gdighMSksITF9LGguY29tcHV0ZVdpbmRpbmc9ZnVuY3Rpb24ocixpKXtpLndpbmRpbmdOdW1iZXI9aC5yZWdpb25BYm92ZShpKS53aW5kaW5nTnVtYmVyK2kuZVVwLndpbmRpbmcsaS5pbnNpZGU9aC5pc1dpbmRpbmdJbnNpZGUocixpLndpbmRpbmdOdW1iZXIpfSxoLmZpbmlzaFJlZ2lvbj1mdW5jdGlvbihyLGkpe3ZhciBuPWkuZVVwLHM9bi5MZmFjZTtzLmluc2lkZT1pLmluc2lkZSxzLmFuRWRnZT1uLGguZGVsZXRlUmVnaW9uKHIsaSl9LGguZmluaXNoTGVmdFJlZ2lvbnM9ZnVuY3Rpb24ocixpLG4pe2Zvcih2YXIgcyxTLE09bnVsbCxQPWksUz1pLmVVcDtQIT09bjspe2lmKFAuZml4VXBwZXJFZGdlPSExLE09aC5yZWdpb25CZWxvdyhQKSxzPU0uZVVwLHMuT3JnIT1TLk9yZyl7aWYoIU0uZml4VXBwZXJFZGdlKXtoLmZpbmlzaFJlZ2lvbihyLFApO2JyZWFrfXM9ci5tZXNoLmNvbm5lY3QoUy5McHJldixzLlN5bSksaC5maXhVcHBlckVkZ2UocixNLHMpfVMuT25leHQhPT1zJiYoci5tZXNoLnNwbGljZShzLk9wcmV2LHMpLHIubWVzaC5zcGxpY2UoUyxzKSksaC5maW5pc2hSZWdpb24ocixQKSxTPU0uZVVwLFA9TX1yZXR1cm4gU30saC5hZGRSaWdodEVkZ2VzPWZ1bmN0aW9uKHIsaSxuLHMsTSxQKXt2YXIgUyxiLE8sRCxJPSEwO089bjtkbyB2KG8udmVydExlcShPLk9yZyxPLkRzdCkpLGguYWRkUmVnaW9uQmVsb3cocixpLE8uU3ltKSxPPU8uT25leHQ7d2hpbGUoTyE9PXMpO2ZvcihNPT09bnVsbCYmKE09aC5yZWdpb25CZWxvdyhpKS5lVXAuUnByZXYpLGI9aSxEPU07Uz1oLnJlZ2lvbkJlbG93KGIpLE89Uy5lVXAuU3ltLE8uT3JnPT09RC5Pcmc7KU8uT25leHQhPT1EJiYoci5tZXNoLnNwbGljZShPLk9wcmV2LE8pLHIubWVzaC5zcGxpY2UoRC5PcHJldixPKSksUy53aW5kaW5nTnVtYmVyPWIud2luZGluZ051bWJlci1PLndpbmRpbmcsUy5pbnNpZGU9aC5pc1dpbmRpbmdJbnNpZGUocixTLndpbmRpbmdOdW1iZXIpLGIuZGlydHk9ITAsIUkmJmguY2hlY2tGb3JSaWdodFNwbGljZShyLGIpJiYoaC5hZGRXaW5kaW5nKE8sRCksaC5kZWxldGVSZWdpb24ocixiKSxyLm1lc2guZGVsZXRlKEQpKSxJPSExLGI9UyxEPU87Yi5kaXJ0eT0hMCx2KGIud2luZGluZ051bWJlci1PLndpbmRpbmc9PT1TLndpbmRpbmdOdW1iZXIpLFAmJmgud2Fsa0RpcnR5UmVnaW9ucyhyLGIpfSxoLnNwbGljZU1lcmdlVmVydGljZXM9ZnVuY3Rpb24ocixpLG4pe3IubWVzaC5zcGxpY2UoaSxuKX0saC52ZXJ0ZXhXZWlnaHRzPWZ1bmN0aW9uKHIsaSxuKXt2YXIgcz1vLnZlcnRMMWRpc3QoaSxyKSxNPW8udmVydEwxZGlzdChuLHIpLFA9LjUqTS8ocytNKSxTPS41KnMvKHMrTSk7ci5jb29yZHNbMF0rPVAqaS5jb29yZHNbMF0rUypuLmNvb3Jkc1swXSxyLmNvb3Jkc1sxXSs9UCppLmNvb3Jkc1sxXStTKm4uY29vcmRzWzFdLHIuY29vcmRzWzJdKz1QKmkuY29vcmRzWzJdK1Mqbi5jb29yZHNbMl19LGguZ2V0SW50ZXJzZWN0RGF0YT1mdW5jdGlvbihyLGksbixzLE0sUCl7aS5jb29yZHNbMF09aS5jb29yZHNbMV09aS5jb29yZHNbMl09MCxpLmlkeD0tMSxoLnZlcnRleFdlaWdodHMoaSxuLHMpLGgudmVydGV4V2VpZ2h0cyhpLE0sUCl9LGguY2hlY2tGb3JSaWdodFNwbGljZT1mdW5jdGlvbihyLGkpe3ZhciBuPWgucmVnaW9uQmVsb3coaSkscz1pLmVVcCxNPW4uZVVwO2lmKG8udmVydExlcShzLk9yZyxNLk9yZykpe2lmKG8uZWRnZVNpZ24oTS5Ec3Qscy5PcmcsTS5PcmcpPjApcmV0dXJuITE7by52ZXJ0RXEocy5PcmcsTS5PcmcpP3MuT3JnIT09TS5PcmcmJihyLnBxLmRlbGV0ZShzLk9yZy5wcUhhbmRsZSksaC5zcGxpY2VNZXJnZVZlcnRpY2VzKHIsTS5PcHJldixzKSk6KHIubWVzaC5zcGxpdEVkZ2UoTS5TeW0pLHIubWVzaC5zcGxpY2UocyxNLk9wcmV2KSxpLmRpcnR5PW4uZGlydHk9ITApfWVsc2V7aWYoby5lZGdlU2lnbihzLkRzdCxNLk9yZyxzLk9yZyk8MClyZXR1cm4hMTtoLnJlZ2lvbkFib3ZlKGkpLmRpcnR5PWkuZGlydHk9ITAsci5tZXNoLnNwbGl0RWRnZShzLlN5bSksci5tZXNoLnNwbGljZShNLk9wcmV2LHMpfXJldHVybiEwfSxoLmNoZWNrRm9yTGVmdFNwbGljZT1mdW5jdGlvbihyLGkpe3ZhciBuPWgucmVnaW9uQmVsb3coaSkscz1pLmVVcCxNPW4uZVVwLFA7aWYodighby52ZXJ0RXEocy5Ec3QsTS5Ec3QpKSxvLnZlcnRMZXEocy5Ec3QsTS5Ec3QpKXtpZihvLmVkZ2VTaWduKHMuRHN0LE0uRHN0LHMuT3JnKTwwKXJldHVybiExO2gucmVnaW9uQWJvdmUoaSkuZGlydHk9aS5kaXJ0eT0hMCxQPXIubWVzaC5zcGxpdEVkZ2Uocyksci5tZXNoLnNwbGljZShNLlN5bSxQKSxQLkxmYWNlLmluc2lkZT1pLmluc2lkZX1lbHNle2lmKG8uZWRnZVNpZ24oTS5Ec3Qscy5Ec3QsTS5PcmcpPjApcmV0dXJuITE7aS5kaXJ0eT1uLmRpcnR5PSEwLFA9ci5tZXNoLnNwbGl0RWRnZShNKSxyLm1lc2guc3BsaWNlKHMuTG5leHQsTS5TeW0pLFAuUmZhY2UuaW5zaWRlPWkuaW5zaWRlfXJldHVybiEwfSxoLmNoZWNrRm9ySW50ZXJzZWN0PWZ1bmN0aW9uKHIsaSl7dmFyIG49aC5yZWdpb25CZWxvdyhpKSxzPWkuZVVwLE09bi5lVXAsUD1zLk9yZyxTPU0uT3JnLGI9cy5Ec3QsTz1NLkRzdCxELEksUj1uZXcgVCxBLFU7aWYodighby52ZXJ0RXEoTyxiKSksdihvLmVkZ2VTaWduKGIsci5ldmVudCxQKTw9MCksdihvLmVkZ2VTaWduKE8sci5ldmVudCxTKT49MCksdihQIT09ci5ldmVudCYmUyE9PXIuZXZlbnQpLHYoIWkuZml4VXBwZXJFZGdlJiYhbi5maXhVcHBlckVkZ2UpLFA9PT1TfHwoRD1NYXRoLm1pbihQLnQsYi50KSxJPU1hdGgubWF4KFMudCxPLnQpLEQ+SSkpcmV0dXJuITE7aWYoby52ZXJ0TGVxKFAsUykpe2lmKG8uZWRnZVNpZ24oTyxQLFMpPjApcmV0dXJuITF9ZWxzZSBpZihvLmVkZ2VTaWduKGIsUyxQKTwwKXJldHVybiExO3JldHVybiBoLmRlYnVnRXZlbnQociksby5pbnRlcnNlY3QoYixQLE8sUyxSKSx2KE1hdGgubWluKFAudCxiLnQpPD1SLnQpLHYoUi50PD1NYXRoLm1heChTLnQsTy50KSksdihNYXRoLm1pbihPLnMsYi5zKTw9Ui5zKSx2KFIuczw9TWF0aC5tYXgoUy5zLFAucykpLG8udmVydExlcShSLHIuZXZlbnQpJiYoUi5zPXIuZXZlbnQucyxSLnQ9ci5ldmVudC50KSxBPW8udmVydExlcShQLFMpP1A6UyxvLnZlcnRMZXEoQSxSKSYmKFIucz1BLnMsUi50PUEudCksby52ZXJ0RXEoUixQKXx8by52ZXJ0RXEoUixTKT8oaC5jaGVja0ZvclJpZ2h0U3BsaWNlKHIsaSksITEpOiFvLnZlcnRFcShiLHIuZXZlbnQpJiZvLmVkZ2VTaWduKGIsci5ldmVudCxSKT49MHx8IW8udmVydEVxKE8sci5ldmVudCkmJm8uZWRnZVNpZ24oTyxyLmV2ZW50LFIpPD0wP089PT1yLmV2ZW50PyhyLm1lc2guc3BsaXRFZGdlKHMuU3ltKSxyLm1lc2guc3BsaWNlKE0uU3ltLHMpLGk9aC50b3BMZWZ0UmVnaW9uKHIsaSkscz1oLnJlZ2lvbkJlbG93KGkpLmVVcCxoLmZpbmlzaExlZnRSZWdpb25zKHIsaC5yZWdpb25CZWxvdyhpKSxuKSxoLmFkZFJpZ2h0RWRnZXMocixpLHMuT3ByZXYscyxzLCEwKSwhMCk6Yj09PXIuZXZlbnQ/KHIubWVzaC5zcGxpdEVkZ2UoTS5TeW0pLHIubWVzaC5zcGxpY2Uocy5MbmV4dCxNLk9wcmV2KSxuPWksaT1oLnRvcFJpZ2h0UmVnaW9uKGkpLFU9aC5yZWdpb25CZWxvdyhpKS5lVXAuUnByZXYsbi5lVXA9TS5PcHJldixNPWguZmluaXNoTGVmdFJlZ2lvbnMocixuLG51bGwpLGguYWRkUmlnaHRFZGdlcyhyLGksTS5PbmV4dCxzLlJwcmV2LFUsITApLCEwKTooby5lZGdlU2lnbihiLHIuZXZlbnQsUik+PTAmJihoLnJlZ2lvbkFib3ZlKGkpLmRpcnR5PWkuZGlydHk9ITAsci5tZXNoLnNwbGl0RWRnZShzLlN5bSkscy5Pcmcucz1yLmV2ZW50LnMscy5PcmcudD1yLmV2ZW50LnQpLG8uZWRnZVNpZ24oTyxyLmV2ZW50LFIpPD0wJiYoaS5kaXJ0eT1uLmRpcnR5PSEwLHIubWVzaC5zcGxpdEVkZ2UoTS5TeW0pLE0uT3JnLnM9ci5ldmVudC5zLE0uT3JnLnQ9ci5ldmVudC50KSwhMSk6KHIubWVzaC5zcGxpdEVkZ2Uocy5TeW0pLHIubWVzaC5zcGxpdEVkZ2UoTS5TeW0pLHIubWVzaC5zcGxpY2UoTS5PcHJldixzKSxzLk9yZy5zPVIucyxzLk9yZy50PVIudCxzLk9yZy5wcUhhbmRsZT1yLnBxLmluc2VydChzLk9yZyksaC5nZXRJbnRlcnNlY3REYXRhKHIscy5PcmcsUCxiLFMsTyksaC5yZWdpb25BYm92ZShpKS5kaXJ0eT1pLmRpcnR5PW4uZGlydHk9ITAsITEpfSxoLndhbGtEaXJ0eVJlZ2lvbnM9ZnVuY3Rpb24ocixpKXtmb3IodmFyIG49aC5yZWdpb25CZWxvdyhpKSxzLE07Oyl7Zm9yKDtuLmRpcnR5OylpPW4sbj1oLnJlZ2lvbkJlbG93KG4pO2lmKCFpLmRpcnR5JiYobj1pLGk9aC5yZWdpb25BYm92ZShpKSxpPT09bnVsbHx8IWkuZGlydHkpKXJldHVybjtpZihpLmRpcnR5PSExLHM9aS5lVXAsTT1uLmVVcCxzLkRzdCE9PU0uRHN0JiZoLmNoZWNrRm9yTGVmdFNwbGljZShyLGkpJiYobi5maXhVcHBlckVkZ2U/KGguZGVsZXRlUmVnaW9uKHIsbiksci5tZXNoLmRlbGV0ZShNKSxuPWgucmVnaW9uQmVsb3coaSksTT1uLmVVcCk6aS5maXhVcHBlckVkZ2UmJihoLmRlbGV0ZVJlZ2lvbihyLGkpLHIubWVzaC5kZWxldGUocyksaT1oLnJlZ2lvbkFib3ZlKG4pLHM9aS5lVXApKSxzLk9yZyE9PU0uT3JnKWlmKHMuRHN0IT09TS5Ec3QmJiFpLmZpeFVwcGVyRWRnZSYmIW4uZml4VXBwZXJFZGdlJiYocy5Ec3Q9PT1yLmV2ZW50fHxNLkRzdD09PXIuZXZlbnQpKXtpZihoLmNoZWNrRm9ySW50ZXJzZWN0KHIsaSkpcmV0dXJufWVsc2UgaC5jaGVja0ZvclJpZ2h0U3BsaWNlKHIsaSk7cy5Pcmc9PT1NLk9yZyYmcy5Ec3Q9PT1NLkRzdCYmKGguYWRkV2luZGluZyhNLHMpLGguZGVsZXRlUmVnaW9uKHIsaSksci5tZXNoLmRlbGV0ZShzKSxpPWgucmVnaW9uQWJvdmUobikpfX0saC5jb25uZWN0UmlnaHRWZXJ0ZXg9ZnVuY3Rpb24ocixpLG4pe3ZhciBzLE09bi5PbmV4dCxQPWgucmVnaW9uQmVsb3coaSksUz1pLmVVcCxiPVAuZVVwLE89ITE7aWYoUy5Ec3QhPT1iLkRzdCYmaC5jaGVja0ZvckludGVyc2VjdChyLGkpLG8udmVydEVxKFMuT3JnLHIuZXZlbnQpJiYoci5tZXNoLnNwbGljZShNLk9wcmV2LFMpLGk9aC50b3BMZWZ0UmVnaW9uKHIsaSksTT1oLnJlZ2lvbkJlbG93KGkpLmVVcCxoLmZpbmlzaExlZnRSZWdpb25zKHIsaC5yZWdpb25CZWxvdyhpKSxQKSxPPSEwKSxvLnZlcnRFcShiLk9yZyxyLmV2ZW50KSYmKHIubWVzaC5zcGxpY2UobixiLk9wcmV2KSxuPWguZmluaXNoTGVmdFJlZ2lvbnMocixQLG51bGwpLE89ITApLE8pe2guYWRkUmlnaHRFZGdlcyhyLGksbi5PbmV4dCxNLE0sITApO3JldHVybn1vLnZlcnRMZXEoYi5PcmcsUy5PcmcpP3M9Yi5PcHJldjpzPVMscz1yLm1lc2guY29ubmVjdChuLkxwcmV2LHMpLGguYWRkUmlnaHRFZGdlcyhyLGkscyxzLk9uZXh0LHMuT25leHQsITEpLHMuU3ltLmFjdGl2ZVJlZ2lvbi5maXhVcHBlckVkZ2U9ITAsaC53YWxrRGlydHlSZWdpb25zKHIsaSl9LGguY29ubmVjdExlZnREZWdlbmVyYXRlPWZ1bmN0aW9uKHIsaSxuKXt2YXIgcyxNLFAsUyxiO2lmKHM9aS5lVXAsby52ZXJ0RXEocy5Pcmcsbikpe3YoITEpLGguc3BsaWNlTWVyZ2VWZXJ0aWNlcyhyLHMsbi5hbkVkZ2UpO3JldHVybn1pZighby52ZXJ0RXEocy5Ec3Qsbikpe3IubWVzaC5zcGxpdEVkZ2Uocy5TeW0pLGkuZml4VXBwZXJFZGdlJiYoci5tZXNoLmRlbGV0ZShzLk9uZXh0KSxpLmZpeFVwcGVyRWRnZT0hMSksci5tZXNoLnNwbGljZShuLmFuRWRnZSxzKSxoLnN3ZWVwRXZlbnQocixuKTtyZXR1cm59dighMSksaT1oLnRvcFJpZ2h0UmVnaW9uKGkpLGI9aC5yZWdpb25CZWxvdyhpKSxQPWIuZVVwLlN5bSxNPVM9UC5PbmV4dCxiLmZpeFVwcGVyRWRnZSYmKHYoTSE9PVApLGguZGVsZXRlUmVnaW9uKHIsYiksci5tZXNoLmRlbGV0ZShQKSxQPU0uT3ByZXYpLHIubWVzaC5zcGxpY2Uobi5hbkVkZ2UsUCksby5lZGdlR29lc0xlZnQoTSl8fChNPW51bGwpLGguYWRkUmlnaHRFZGdlcyhyLGksUC5PbmV4dCxTLE0sITApfSxoLmNvbm5lY3RMZWZ0VmVydGV4PWZ1bmN0aW9uKHIsaSl7dmFyIG4scyxNLFAsUyxiLE89bmV3IHg7aWYoTy5lVXA9aS5hbkVkZ2UuU3ltLG49ci5kaWN0LnNlYXJjaChPKS5rZXkscz1oLnJlZ2lvbkJlbG93KG4pLCEhcyl7aWYoUD1uLmVVcCxTPXMuZVVwLG8uZWRnZVNpZ24oUC5Ec3QsaSxQLk9yZyk9PT0wKXtoLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZShyLG4saSk7cmV0dXJufWlmKE09by52ZXJ0TGVxKFMuRHN0LFAuRHN0KT9uOnMsbi5pbnNpZGV8fE0uZml4VXBwZXJFZGdlKXtpZihNPT09biliPXIubWVzaC5jb25uZWN0KGkuYW5FZGdlLlN5bSxQLkxuZXh0KTtlbHNle3ZhciBEPXIubWVzaC5jb25uZWN0KFMuRG5leHQsaS5hbkVkZ2UpO2I9RC5TeW19TS5maXhVcHBlckVkZ2U/aC5maXhVcHBlckVkZ2UocixNLGIpOmguY29tcHV0ZVdpbmRpbmcocixoLmFkZFJlZ2lvbkJlbG93KHIsbixiKSksaC5zd2VlcEV2ZW50KHIsaSl9ZWxzZSBoLmFkZFJpZ2h0RWRnZXMocixuLGkuYW5FZGdlLGkuYW5FZGdlLG51bGwsITApfX0saC5zd2VlcEV2ZW50PWZ1bmN0aW9uKHIsaSl7ci5ldmVudD1pLGguZGVidWdFdmVudChyKTtmb3IodmFyIG49aS5hbkVkZ2U7bi5hY3RpdmVSZWdpb249PT1udWxsOylpZihuPW4uT25leHQsbj09PWkuYW5FZGdlKXtoLmNvbm5lY3RMZWZ0VmVydGV4KHIsaSk7cmV0dXJufXZhciBzPWgudG9wTGVmdFJlZ2lvbihyLG4uYWN0aXZlUmVnaW9uKTt2KHMhPT1udWxsKTt2YXIgTT1oLnJlZ2lvbkJlbG93KHMpLFA9TS5lVXAsUz1oLmZpbmlzaExlZnRSZWdpb25zKHIsTSxudWxsKTtTLk9uZXh0PT09UD9oLmNvbm5lY3RSaWdodFZlcnRleChyLHMsUyk6aC5hZGRSaWdodEVkZ2VzKHIscyxTLk9uZXh0LFAsUCwhMCl9LGguYWRkU2VudGluZWw9ZnVuY3Rpb24ocixpLG4scyl7dmFyIE09bmV3IHgsUD1yLm1lc2gubWFrZUVkZ2UoKTtQLk9yZy5zPW4sUC5PcmcudD1zLFAuRHN0LnM9aSxQLkRzdC50PXMsci5ldmVudD1QLkRzdCxNLmVVcD1QLE0ud2luZGluZ051bWJlcj0wLE0uaW5zaWRlPSExLE0uZml4VXBwZXJFZGdlPSExLE0uc2VudGluZWw9ITAsTS5kaXJ0eT0hMSxNLm5vZGVVcD1yLmRpY3QuaW5zZXJ0KE0pfSxoLmluaXRFZGdlRGljdD1mdW5jdGlvbihyKXtyLmRpY3Q9bmV3IGYocixoLmVkZ2VMZXEpO3ZhciBpPXIuYm1heFswXS1yLmJtaW5bMF0sbj1yLmJtYXhbMV0tci5ibWluWzFdLHM9ci5ibWluWzBdLWksTT1yLmJtYXhbMF0raSxQPXIuYm1pblsxXS1uLFM9ci5ibWF4WzFdK247aC5hZGRTZW50aW5lbChyLHMsTSxQKSxoLmFkZFNlbnRpbmVsKHIscyxNLFMpfSxoLmRvbmVFZGdlRGljdD1mdW5jdGlvbihyKXtmb3IodmFyIGksbj0wOyhpPXIuZGljdC5taW4oKS5rZXkpIT09bnVsbDspaS5zZW50aW5lbHx8KHYoaS5maXhVcHBlckVkZ2UpLHYoKytuPT09MSkpLHYoaS53aW5kaW5nTnVtYmVyPT09MCksaC5kZWxldGVSZWdpb24ocixpKX0saC5yZW1vdmVEZWdlbmVyYXRlRWRnZXM9ZnVuY3Rpb24ocil7dmFyIGksbixzLE09ci5tZXNoLmVIZWFkO2ZvcihpPU0ubmV4dDtpIT09TTtpPW4pbj1pLm5leHQscz1pLkxuZXh0LG8udmVydEVxKGkuT3JnLGkuRHN0KSYmaS5MbmV4dC5MbmV4dCE9PWkmJihoLnNwbGljZU1lcmdlVmVydGljZXMocixzLGkpLHIubWVzaC5kZWxldGUoaSksaT1zLHM9aS5MbmV4dCkscy5MbmV4dD09PWkmJihzIT09aSYmKChzPT09bnx8cz09PW4uU3ltKSYmKG49bi5uZXh0KSxyLm1lc2guZGVsZXRlKHMpKSwoaT09PW58fGk9PT1uLlN5bSkmJihuPW4ubmV4dCksci5tZXNoLmRlbGV0ZShpKSl9LGguaW5pdFByaW9yaXR5UT1mdW5jdGlvbihyKXt2YXIgaSxuLHMsTT0wO2ZvcihzPXIubWVzaC52SGVhZCxuPXMubmV4dDtuIT09cztuPW4ubmV4dClNKys7Zm9yKE0rPTgsaT1yLnBxPW5ldyBDKE0sby52ZXJ0TGVxKSxzPXIubWVzaC52SGVhZCxuPXMubmV4dDtuIT09cztuPW4ubmV4dCluLnBxSGFuZGxlPWkuaW5zZXJ0KG4pO3JldHVybiBuIT09cz8hMTooaS5pbml0KCksITApfSxoLmRvbmVQcmlvcml0eVE9ZnVuY3Rpb24ocil7ci5wcT1udWxsfSxoLnJlbW92ZURlZ2VuZXJhdGVGYWNlcz1mdW5jdGlvbihyLGkpe3ZhciBuLHMsTTtmb3Iobj1pLmZIZWFkLm5leHQ7biE9PWkuZkhlYWQ7bj1zKXM9bi5uZXh0LE09bi5hbkVkZ2UsdihNLkxuZXh0IT09TSksTS5MbmV4dC5MbmV4dD09PU0mJihoLmFkZFdpbmRpbmcoTS5PbmV4dCxNKSxyLm1lc2guZGVsZXRlKE0pKTtyZXR1cm4hMH0saC5jb21wdXRlSW50ZXJpb3I9ZnVuY3Rpb24ocil7dmFyIGksbjtpZihoLnJlbW92ZURlZ2VuZXJhdGVFZGdlcyhyKSwhaC5pbml0UHJpb3JpdHlRKHIpKXJldHVybiExO2ZvcihoLmluaXRFZGdlRGljdChyKTsoaT1yLnBxLmV4dHJhY3RNaW4oKSkhPT1udWxsOyl7Zm9yKDtuPXIucHEubWluKCksIShuPT09bnVsbHx8IW8udmVydEVxKG4saSkpOyluPXIucHEuZXh0cmFjdE1pbigpLGguc3BsaWNlTWVyZ2VWZXJ0aWNlcyhyLGkuYW5FZGdlLG4uYW5FZGdlKTtoLnN3ZWVwRXZlbnQocixpKX1yZXR1cm4gci5ldmVudD1yLmRpY3QubWluKCkua2V5LmVVcC5PcmcsaC5kZWJ1Z0V2ZW50KHIpLGguZG9uZUVkZ2VEaWN0KHIpLGguZG9uZVByaW9yaXR5UShyKSxoLnJlbW92ZURlZ2VuZXJhdGVGYWNlcyhyLHIubWVzaCk/KHIubWVzaC5jaGVjaygpLCEwKTohMX07ZnVuY3Rpb24gbSgpe3RoaXMubWVzaD1udWxsLHRoaXMubm9ybWFsPVswLDAsMF0sdGhpcy5zVW5pdD1bMCwwLDBdLHRoaXMudFVuaXQ9WzAsMCwwXSx0aGlzLmJtaW49WzAsMF0sdGhpcy5ibWF4PVswLDBdLHRoaXMud2luZGluZ1J1bGU9YS5XSU5ESU5HX09ERCx0aGlzLmRpY3Q9bnVsbCx0aGlzLnBxPW51bGwsdGhpcy5ldmVudD1udWxsLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhDb3VudD0wLHRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50Q291bnQ9MH1tLnByb3RvdHlwZT17ZG90XzpmdW5jdGlvbihyLGkpe3JldHVybiByWzBdKmlbMF0rclsxXSppWzFdK3JbMl0qaVsyXX0sbm9ybWFsaXplXzpmdW5jdGlvbihyKXt2YXIgaT1yWzBdKnJbMF0rclsxXSpyWzFdK3JbMl0qclsyXTt2KGk+MCksaT1NYXRoLnNxcnQoaSksclswXS89aSxyWzFdLz1pLHJbMl0vPWl9LGxvbmdBeGlzXzpmdW5jdGlvbihyKXt2YXIgaT0wO3JldHVybiBNYXRoLmFicyhyWzFdKT5NYXRoLmFicyhyWzBdKSYmKGk9MSksTWF0aC5hYnMoclsyXSk+TWF0aC5hYnMocltpXSkmJihpPTIpLGl9LGNvbXB1dGVOb3JtYWxfOmZ1bmN0aW9uKHIpe3ZhciBpLG4scyxNLFAsUyxiPVswLDAsMF0sTz1bMCwwLDBdLEQ9WzAsMCwwXSxJPVswLDAsMF0sUj1bMCwwLDBdLEE9W251bGwsbnVsbCxudWxsXSxVPVtudWxsLG51bGwsbnVsbF0sSz10aGlzLm1lc2gudkhlYWQsVjtmb3IoaT1LLm5leHQsVj0wO1Y8MzsrK1YpTT1pLmNvb3Jkc1tWXSxPW1ZdPU0sVVtWXT1pLGJbVl09TSxBW1ZdPWk7Zm9yKGk9Sy5uZXh0O2khPT1LO2k9aS5uZXh0KWZvcihWPTA7VjwzOysrVilNPWkuY29vcmRzW1ZdLE08T1tWXSYmKE9bVl09TSxVW1ZdPWkpLE0+YltWXSYmKGJbVl09TSxBW1ZdPWkpO2lmKFY9MCxiWzFdLU9bMV0+YlswXS1PWzBdJiYoVj0xKSxiWzJdLU9bMl0+YltWXS1PW1ZdJiYoVj0yKSxPW1ZdPj1iW1ZdKXtyWzBdPTAsclsxXT0wLHJbMl09MTtyZXR1cm59Zm9yKFM9MCxuPVVbVl0scz1BW1ZdLERbMF09bi5jb29yZHNbMF0tcy5jb29yZHNbMF0sRFsxXT1uLmNvb3Jkc1sxXS1zLmNvb3Jkc1sxXSxEWzJdPW4uY29vcmRzWzJdLXMuY29vcmRzWzJdLGk9Sy5uZXh0O2khPT1LO2k9aS5uZXh0KUlbMF09aS5jb29yZHNbMF0tcy5jb29yZHNbMF0sSVsxXT1pLmNvb3Jkc1sxXS1zLmNvb3Jkc1sxXSxJWzJdPWkuY29vcmRzWzJdLXMuY29vcmRzWzJdLFJbMF09RFsxXSpJWzJdLURbMl0qSVsxXSxSWzFdPURbMl0qSVswXS1EWzBdKklbMl0sUlsyXT1EWzBdKklbMV0tRFsxXSpJWzBdLFA9UlswXSpSWzBdK1JbMV0qUlsxXStSWzJdKlJbMl0sUD5TJiYoUz1QLHJbMF09UlswXSxyWzFdPVJbMV0sclsyXT1SWzJdKTtTPD0wJiYoclswXT1yWzFdPXJbMl09MCxyW3RoaXMubG9uZ0F4aXNfKEQpXT0xKX0sY2hlY2tPcmllbnRhdGlvbl86ZnVuY3Rpb24oKXt2YXIgcixpLG49dGhpcy5tZXNoLmZIZWFkLHMsTT10aGlzLm1lc2gudkhlYWQsUDtmb3Iocj0wLGk9bi5uZXh0O2khPT1uO2k9aS5uZXh0KWlmKFA9aS5hbkVkZ2UsIShQLndpbmRpbmc8PTApKWRvIHIrPShQLk9yZy5zLVAuRHN0LnMpKihQLk9yZy50K1AuRHN0LnQpLFA9UC5MbmV4dDt3aGlsZShQIT09aS5hbkVkZ2UpO2lmKHI8MCl7Zm9yKHM9TS5uZXh0O3MhPT1NO3M9cy5uZXh0KXMudD0tcy50O3RoaXMudFVuaXRbMF09LXRoaXMudFVuaXRbMF0sdGhpcy50VW5pdFsxXT0tdGhpcy50VW5pdFsxXSx0aGlzLnRVbml0WzJdPS10aGlzLnRVbml0WzJdfX0scHJvamVjdFBvbHlnb25fOmZ1bmN0aW9uKCl7dmFyIHIsaT10aGlzLm1lc2gudkhlYWQsbj1bMCwwLDBdLHMsTSxQLFMsYj0hMTtmb3IoblswXT10aGlzLm5vcm1hbFswXSxuWzFdPXRoaXMubm9ybWFsWzFdLG5bMl09dGhpcy5ub3JtYWxbMl0sblswXT09PTAmJm5bMV09PT0wJiZuWzJdPT09MCYmKHRoaXMuY29tcHV0ZU5vcm1hbF8obiksYj0hMCkscz10aGlzLnNVbml0LE09dGhpcy50VW5pdCxQPXRoaXMubG9uZ0F4aXNfKG4pLHNbUF09MCxzWyhQKzEpJTNdPTEsc1soUCsyKSUzXT0wLE1bUF09MCxNWyhQKzEpJTNdPTAsTVsoUCsyKSUzXT1uW1BdPjA/MTotMSxyPWkubmV4dDtyIT09aTtyPXIubmV4dClyLnM9dGhpcy5kb3RfKHIuY29vcmRzLHMpLHIudD10aGlzLmRvdF8oci5jb29yZHMsTSk7Zm9yKGImJnRoaXMuY2hlY2tPcmllbnRhdGlvbl8oKSxTPSEwLHI9aS5uZXh0O3IhPT1pO3I9ci5uZXh0KVM/KHRoaXMuYm1pblswXT10aGlzLmJtYXhbMF09ci5zLHRoaXMuYm1pblsxXT10aGlzLmJtYXhbMV09ci50LFM9ITEpOihyLnM8dGhpcy5ibWluWzBdJiYodGhpcy5ibWluWzBdPXIucyksci5zPnRoaXMuYm1heFswXSYmKHRoaXMuYm1heFswXT1yLnMpLHIudDx0aGlzLmJtaW5bMV0mJih0aGlzLmJtaW5bMV09ci50KSxyLnQ+dGhpcy5ibWF4WzFdJiYodGhpcy5ibWF4WzFdPXIudCkpfSxhZGRXaW5kaW5nXzpmdW5jdGlvbihyLGkpe3Iud2luZGluZys9aS53aW5kaW5nLHIuU3ltLndpbmRpbmcrPWkuU3ltLndpbmRpbmd9LHRlc3NlbGxhdGVNb25vUmVnaW9uXzpmdW5jdGlvbihyLGkpe3ZhciBuLHM7Zm9yKG49aS5hbkVkZ2UsdihuLkxuZXh0IT09biYmbi5MbmV4dC5MbmV4dCE9PW4pO28udmVydExlcShuLkRzdCxuLk9yZyk7bj1uLkxwcmV2KTtmb3IoO28udmVydExlcShuLk9yZyxuLkRzdCk7bj1uLkxuZXh0KTtmb3Iocz1uLkxwcmV2O24uTG5leHQhPT1zOylpZihvLnZlcnRMZXEobi5Ec3Qscy5PcmcpKXtmb3IoO3MuTG5leHQhPT1uJiYoby5lZGdlR29lc0xlZnQocy5MbmV4dCl8fG8uZWRnZVNpZ24ocy5Pcmcscy5Ec3Qscy5MbmV4dC5Ec3QpPD0wKTspe3ZhciBNPXIuY29ubmVjdChzLkxuZXh0LHMpO3M9TS5TeW19cz1zLkxwcmV2fWVsc2V7Zm9yKDtzLkxuZXh0IT09biYmKG8uZWRnZUdvZXNSaWdodChuLkxwcmV2KXx8by5lZGdlU2lnbihuLkRzdCxuLk9yZyxuLkxwcmV2Lk9yZyk+PTApOyl7dmFyIE09ci5jb25uZWN0KG4sbi5McHJldik7bj1NLlN5bX1uPW4uTG5leHR9Zm9yKHYocy5MbmV4dCE9PW4pO3MuTG5leHQuTG5leHQhPT1uOyl7dmFyIE09ci5jb25uZWN0KHMuTG5leHQscyk7cz1NLlN5bX1yZXR1cm4hMH0sdGVzc2VsbGF0ZUludGVyaW9yXzpmdW5jdGlvbihyKXt2YXIgaSxuO2ZvcihpPXIuZkhlYWQubmV4dDtpIT09ci5mSGVhZDtpPW4paWYobj1pLm5leHQsaS5pbnNpZGUmJiF0aGlzLnRlc3NlbGxhdGVNb25vUmVnaW9uXyhyLGkpKXJldHVybiExO3JldHVybiEwfSxkaXNjYXJkRXh0ZXJpb3JfOmZ1bmN0aW9uKHIpe3ZhciBpLG47Zm9yKGk9ci5mSGVhZC5uZXh0O2khPT1yLmZIZWFkO2k9biluPWkubmV4dCxpLmluc2lkZXx8ci56YXBGYWNlKGkpfSxzZXRXaW5kaW5nTnVtYmVyXzpmdW5jdGlvbihyLGksbil7dmFyIHMsTTtmb3Iocz1yLmVIZWFkLm5leHQ7cyE9PXIuZUhlYWQ7cz1NKU09cy5uZXh0LHMuUmZhY2UuaW5zaWRlIT09cy5MZmFjZS5pbnNpZGU/cy53aW5kaW5nPXMuTGZhY2UuaW5zaWRlP2k6LWk6bj9yLmRlbGV0ZShzKTpzLndpbmRpbmc9MH0sZ2V0TmVpZ2hib3VyRmFjZV86ZnVuY3Rpb24ocil7cmV0dXJuIXIuUmZhY2V8fCFyLlJmYWNlLmluc2lkZT8tMTpyLlJmYWNlLm59LG91dHB1dFBvbHltZXNoXzpmdW5jdGlvbihyLGksbixzKXt2YXIgTSxQLFMsYj0wLE89MCxELEk7Zm9yKG4+MyYmci5tZXJnZUNvbnZleEZhY2VzKG4pLE09ci52SGVhZC5uZXh0O00hPT1yLnZIZWFkO009TS5uZXh0KU0ubj0tMTtmb3IoUD1yLmZIZWFkLm5leHQ7UCE9PXIuZkhlYWQ7UD1QLm5leHQpaWYoUC5uPS0xLCEhUC5pbnNpZGUpe1M9UC5hbkVkZ2UsRD0wO2RvIE09Uy5PcmcsTS5uPT09LTEmJihNLm49TyxPKyspLEQrKyxTPVMuTG5leHQ7d2hpbGUoUyE9PVAuYW5FZGdlKTt2KEQ8PW4pLFAubj1iLCsrYn1mb3IodGhpcy5lbGVtZW50Q291bnQ9YixpPT09YS5DT05ORUNURURfUE9MWUdPTlMmJihiKj0yKSx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPWIqbix0aGlzLnZlcnRleENvdW50PU8sdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD1PKnMsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9TyxNPXIudkhlYWQubmV4dDtNIT09ci52SGVhZDtNPU0ubmV4dClpZihNLm4hPT0tMSl7dmFyIFI9TS5uKnM7dGhpcy52ZXJ0aWNlc1tSKzBdPU0uY29vcmRzWzBdLHRoaXMudmVydGljZXNbUisxXT1NLmNvb3Jkc1sxXSxzPjImJih0aGlzLnZlcnRpY2VzW1IrMl09TS5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1tNLm5dPU0uaWR4fXZhciBBPTA7Zm9yKFA9ci5mSGVhZC5uZXh0O1AhPT1yLmZIZWFkO1A9UC5uZXh0KWlmKFAuaW5zaWRlKXtTPVAuYW5FZGdlLEQ9MDtkbyBNPVMuT3JnLHRoaXMuZWxlbWVudHNbQSsrXT1NLm4sRCsrLFM9Uy5MbmV4dDt3aGlsZShTIT09UC5hbkVkZ2UpO2ZvcihJPUQ7STxuOysrSSl0aGlzLmVsZW1lbnRzW0ErK109LTE7aWYoaT09PWEuQ09OTkVDVEVEX1BPTFlHT05TKXtTPVAuYW5FZGdlO2RvIHRoaXMuZWxlbWVudHNbQSsrXT10aGlzLmdldE5laWdoYm91ckZhY2VfKFMpLFM9Uy5MbmV4dDt3aGlsZShTIT09UC5hbkVkZ2UpO2ZvcihJPUQ7STxuOysrSSl0aGlzLmVsZW1lbnRzW0ErK109LTF9fX0sb3V0cHV0Q29udG91cnNfOmZ1bmN0aW9uKHIsaSl7dmFyIG4scyxNLFA9MCxTPTA7Zm9yKHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRDb3VudD0wLG49ci5mSGVhZC5uZXh0O24hPT1yLmZIZWFkO249bi5uZXh0KWlmKG4uaW5zaWRlKXtNPXM9bi5hbkVkZ2U7ZG8gdGhpcy52ZXJ0ZXhDb3VudCsrLHM9cy5MbmV4dDt3aGlsZShzIT09TSk7dGhpcy5lbGVtZW50Q291bnQrK310aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPXRoaXMuZWxlbWVudENvdW50KjIsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD10aGlzLnZlcnRleENvdW50KmksdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudDt2YXIgYj0wLE89MCxEPTA7Zm9yKFA9MCxuPXIuZkhlYWQubmV4dDtuIT09ci5mSGVhZDtuPW4ubmV4dClpZihuLmluc2lkZSl7Uz0wLE09cz1uLmFuRWRnZTtkbyB0aGlzLnZlcnRpY2VzW2IrK109cy5PcmcuY29vcmRzWzBdLHRoaXMudmVydGljZXNbYisrXT1zLk9yZy5jb29yZHNbMV0saT4yJiYodGhpcy52ZXJ0aWNlc1tiKytdPXMuT3JnLmNvb3Jkc1syXSksdGhpcy52ZXJ0ZXhJbmRpY2VzW08rK109cy5PcmcuaWR4LFMrKyxzPXMuTG5leHQ7d2hpbGUocyE9PU0pO3RoaXMuZWxlbWVudHNbRCsrXT1QLHRoaXMuZWxlbWVudHNbRCsrXT1TLFArPVN9fSxhZGRDb250b3VyOmZ1bmN0aW9uKHIsaSl7dmFyIG4scztmb3IodGhpcy5tZXNoPT09bnVsbCYmKHRoaXMubWVzaD1uZXcgYykscjwyJiYocj0yKSxyPjMmJihyPTMpLG49bnVsbCxzPTA7czxpLmxlbmd0aDtzKz1yKW49PT1udWxsPyhuPXRoaXMubWVzaC5tYWtlRWRnZSgpLHRoaXMubWVzaC5zcGxpY2UobixuLlN5bSkpOih0aGlzLm1lc2guc3BsaXRFZGdlKG4pLG49bi5MbmV4dCksbi5PcmcuY29vcmRzWzBdPWlbcyswXSxuLk9yZy5jb29yZHNbMV09aVtzKzFdLHI+Mj9uLk9yZy5jb29yZHNbMl09aVtzKzJdOm4uT3JnLmNvb3Jkc1syXT0wLG4uT3JnLmlkeD10aGlzLnZlcnRleEluZGV4Q291bnRlcisrLG4ud2luZGluZz0xLG4uU3ltLndpbmRpbmc9LTF9LHRlc3NlbGF0ZTpmdW5jdGlvbihyLGksbixzLE0pe2lmKHRoaXMudmVydGljZXM9W10sdGhpcy5lbGVtZW50cz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXI9MCxNJiYodGhpcy5ub3JtYWxbMF09TVswXSx0aGlzLm5vcm1hbFsxXT1NWzFdLHRoaXMubm9ybWFsWzJdPU1bMl0pLHRoaXMud2luZGluZ1J1bGU9cixzPDImJihzPTIpLHM+MyYmKHM9MyksIXRoaXMubWVzaClyZXR1cm4hMTt0aGlzLnByb2plY3RQb2x5Z29uXygpLGguY29tcHV0ZUludGVyaW9yKHRoaXMpO3ZhciBQPXRoaXMubWVzaDtyZXR1cm4gaT09PWEuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5zZXRXaW5kaW5nTnVtYmVyXyhQLDEsITApOnRoaXMudGVzc2VsbGF0ZUludGVyaW9yXyhQKSxQLmNoZWNrKCksaT09PWEuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5vdXRwdXRDb250b3Vyc18oUCxzKTp0aGlzLm91dHB1dFBvbHltZXNoXyhQLGksbixzKSwhMH19fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1hO3ZhciB0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gYSgpe2Zvcih2YXIgbz17fSx2PTA7djxhcmd1bWVudHMubGVuZ3RoO3YrKyl7dmFyIFQ9YXJndW1lbnRzW3ZdO2Zvcih2YXIgZCBpbiBUKXQuY2FsbChULGQpJiYob1tkXT1UW2RdKX1yZXR1cm4gb319LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZVNoYWRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiYXBwbHlTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiY3JlYXRlQ2xvdWRTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFwcGx5Q2xvdWRTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgYT10KDY0KSxvPXQoNjUpLHY9dCg2NiksVD10KDY3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD1TeW1ib2woInNoYWRlcnMiKTtmdW5jdGlvbiB1KHkpe3lbZF09W107Zm9yKGxldCBDPTA7QzwxNjtDKyspe2NvbnN0IHg9W10saD0hIShDJjEpLG09ISEoQyYyKSxyPSEhKEMmNCksaT0hIShDJjgpO2gmJngucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxtJiZ4LnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxyJiZ4LnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLGkmJngucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3Qgbj1gJHt4LmpvaW4oYApgKX0KYCxzPVtdO2gmJnMucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpLGkmJnMucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV9jbGlwU2FtcGxlcjsiKSx5W2RdW0NdPVtuK3Muam9pbihgCmApK28uZGVmYXVsdCxuK2EuZGVmYXVsdF19fWZ1bmN0aW9uIGMoeSx7aGFzVGV4dHVyZTpDPSExLGhhc0ZpbHRlcjp4PSExLGhhc0dyYWRpZW50Omg9ITEsaGFzQ2xpcFBhdGg6bT0hMX09e30pe2NvbnN0IHI9Q3x4PDwxfGg8PDJ8bTw8MztsZXQgaT15W2RdW3JdO0FycmF5LmlzQXJyYXkoaSkmJihpPXkuY3JlYXRlUHJvZ3JhbSguLi5pKSx5W2RdW3JdPWkpLHkucHJvZ3JhbSE9PWkmJnkudXNlUHJvZ3JhbShpLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSl9Y29uc3QgRT1bXTtmdW5jdGlvbiBmKHkpe2ZvcihsZXQgQz0wO0M8NjQ7QysrKXtjb25zdCB4PVtdLGg9ISEoQyYxKSxtPSEhKEMmMikscj0hIShDJjQpLGk9ISEoQyY4KSxuPSEhKEMmMTYpLHM9ISEoQyYzMik7aCYmeC5wdXNoKCIjZGVmaW5lIFRFWFRVUkUgMSIpLG0mJngucHVzaCgiI2RlZmluZSBGSUxURVIgMSIpLHImJngucHVzaCgiI2RlZmluZSBHUkFESUVOVCAxIiksaSYmeC5wdXNoKCIjZGVmaW5lIENMT1VEQ09MT1IgMSIpLG4mJngucHVzaCgiI2RlZmluZSBDTE9VREZJTFRFUiAxIikscyYmeC5wdXNoKCIjZGVmaW5lIENMSVBQQVRIIDEiKTtjb25zdCBNPWAke3guam9pbihgCmApfQpgLFA9W107aWYoaCl7UC5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7Iik7Zm9yKGxldCBTPTA7UzwxMjtTKyspUC5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleEZyYW1lJHtTfTtgKX1zJiZQLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IiksRVtDXT1bTStQLmpvaW4oYApgKStULmRlZmF1bHQsTSt2LmRlZmF1bHRdfX1mdW5jdGlvbiBnKHkse2hhc1RleHR1cmU6Qz0hMSxoYXNGaWx0ZXI6eD0hMSxoYXNHcmFkaWVudDpoPSExLGhhc0Nsb3VkQ29sb3I6bT0hMSxoYXNDbG91ZEZpbHRlcjpyPSExLGhhc0NsaXBQYXRoOmk9ITF9PXt9KXtjb25zdCBuPUN8eDw8MXxoPDwyfG08PDN8cjw8NHxpPDw1O2xldCBzPUVbbl07QXJyYXkuaXNBcnJheShzKSYmKHM9eS5jcmVhdGVQcm9ncmFtKC4uLnMpLEVbbl09cykseS5wcm9ncmFtIT09cyYmeS51c2VQcm9ncmFtKHMse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSl9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKI2lmZGVmIFRFWFRVUkUKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsKCiNpZmRlZiBHUkFESUVOVAogIHZlYzMgdmcxID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclswXSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsxXSwgMS4wKTsKICB2ZWMzIHZnMiA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbM10sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNF0sIDEuMCk7CiAgZmxvYXQgaCA9IHVfcmVzb2x1dGlvbi55OwogIHZnMS55ID0gaCAtIHZnMS55OwogIHZnMi55ID0gaCAtIHZnMi55OwogIHZHcmFkaWVudFZlY3RvcjEgPSB2ZWMzKHZnMS54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsyXSk7CiAgdkdyYWRpZW50VmVjdG9yMiA9IHZlYzModmcyLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzVdKTsKI2VuZGlmCiAgCiAgZmxhZ0JhY2tncm91bmQgPSBhX3ZlcnRleFBvc2l0aW9uLno7CiAgdkNvbG9yID0gYV9jb2xvcjsKCiNpZmRlZiBURVhUVVJFCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCn1gfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp1bmlmb3JtIGludCB1X2ZpbHRlckZsYWc7CnVuaWZvcm0gZmxvYXQgdV9jb2xvck1hdHJpeFsyMF07CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKLy8gdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgojaWZkZWYgRklMVEVSCnZvaWQgdHJhbnNmb3JtQ29sb3IoaW5vdXQgdmVjNCBjb2xvciwgaW4gZmxvYXQgY29sb3JNYXRyaXhbMjBdKSB7CiAgZmxvYXQgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgYSA9IGNvbG9yLmE7CiAgY29sb3JbMF0gPSBjb2xvck1hdHJpeFswXSAqIHIgKyBjb2xvck1hdHJpeFsxXSAqIGcgKyBjb2xvck1hdHJpeFsyXSAqIGIgKyBjb2xvck1hdHJpeFszXSAqIGEgKyBjb2xvck1hdHJpeFs0XTsKICBjb2xvclsxXSA9IGNvbG9yTWF0cml4WzVdICogciArIGNvbG9yTWF0cml4WzZdICogZyArIGNvbG9yTWF0cml4WzddICogYiArIGNvbG9yTWF0cml4WzhdICogYSArIGNvbG9yTWF0cml4WzldOwogIGNvbG9yWzJdID0gY29sb3JNYXRyaXhbMTBdICogciArIGNvbG9yTWF0cml4WzExXSAqIGcgKyBjb2xvck1hdHJpeFsxMl0gKiBiICsgY29sb3JNYXRyaXhbMTNdICogYSArIGNvbG9yTWF0cml4WzE0XTsKICBjb2xvclszXSA9IGNvbG9yTWF0cml4WzE1XSAqIHIgKyBjb2xvck1hdHJpeFsxNl0gKiBnICsgY29sb3JNYXRyaXhbMTddICogYiArIGNvbG9yTWF0cml4WzE4XSAqIGEgKyBjb2xvck1hdHJpeFsxOV07Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgIHRleENvbG9yLmEgKj0gb3BhY2l0eTsKICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgIH0KICAgICAgLy8gY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY2xhbXAoY29sb3IuYSAvIG1heCgwLjAwMDEsIHRleENvbG9yLmEpLCAwLjAsIDEuMCkpOwogICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIGZsb2F0IGNsaXAgPSB0ZXh0dXJlMkQodV9jbGlwU2FtcGxlciwgdkNsaXBVVikucjsKICBjb2xvciAqPSBjbGlwOwojZW5kaWYKCiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7Cn1gfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0wOwphdHRyaWJ1dGUgdmVjMyBhX3RyYW5zZm9ybTE7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIGZsb2F0IGFfZnJhbWVJbmRleDsKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4OwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQwOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQxOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQyOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQzOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQ0Owp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgQ0xPVURDT0xPUgphdHRyaWJ1dGUgdmVjNCBhX2ZpbGxDbG91ZENvbG9yOwphdHRyaWJ1dGUgdmVjNCBhX3N0cm9rZUNsb3VkQ29sb3I7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwojZW5kaWYKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CgogIG1hdDMgbW9kZWxNYXRyaXggPSBtYXQzKAogICAgYV90cmFuc2Zvcm0wLngsIGFfdHJhbnNmb3JtMS54LCAwLCAKICAgIGFfdHJhbnNmb3JtMC55LCBhX3RyYW5zZm9ybTEueSwgMCwKICAgIGFfdHJhbnNmb3JtMC56LCBhX3RyYW5zZm9ybTEueiwgMQogICk7CgogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwoKI2lmZGVmIENMT1VEQ09MT1IKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdkNvbG9yID0gbWl4KGFfY29sb3IsIGFfZmlsbENsb3VkQ29sb3IsIGFfZmlsbENsb3VkQ29sb3IuYSk7CiAgfSBlbHNlIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IsIGFfc3Ryb2tlQ2xvdWRDb2xvci5hKTsKICB9CiNlbHNlCiAgdkNvbG9yID0gYV9jb2xvcjsKI2VuZGlmCgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICBmcmFtZUluZGV4ID0gYV9mcmFtZUluZGV4OwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKICBjb2xvckNsb3VkMCA9IGFfY29sb3JDbG91ZDA7CiAgY29sb3JDbG91ZDEgPSBhX2NvbG9yQ2xvdWQxOwogIGNvbG9yQ2xvdWQyID0gYV9jb2xvckNsb3VkMjsKICBjb2xvckNsb3VkMyA9IGFfY29sb3JDbG91ZDM7CiAgY29sb3JDbG91ZDQgPSBhX2NvbG9yQ2xvdWQ0OwojZW5kaWYKfWB9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CgojaWZkZWYgVEVYVFVSRQp2YXJ5aW5nIGZsb2F0IGZyYW1lSW5kZXg7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JTdGVwc1s0MF07CnVuaWZvcm0gaW50IHVfZ3JhZGllbnRUeXBlOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CgojaWZkZWYgQ0xPVURGSUxURVIKdm9pZCBidWlsZENsb3VkQ29sb3IoaW5vdXQgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF0pIHsKICBjb2xvckNsb3VkTWF0cml4WzBdID0gY29sb3JDbG91ZDBbMF07CiAgY29sb3JDbG91ZE1hdHJpeFsxXSA9IGNvbG9yQ2xvdWQxWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMl0gPSBjb2xvckNsb3VkMlswXTsKICBjb2xvckNsb3VkTWF0cml4WzNdID0gY29sb3JDbG91ZDNbMF07CiAgY29sb3JDbG91ZE1hdHJpeFs0XSA9IGNvbG9yQ2xvdWQ0WzBdOwoKICBjb2xvckNsb3VkTWF0cml4WzVdID0gY29sb3JDbG91ZDBbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs2XSA9IGNvbG9yQ2xvdWQxWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbN10gPSBjb2xvckNsb3VkMlsxXTsKICBjb2xvckNsb3VkTWF0cml4WzhdID0gY29sb3JDbG91ZDNbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs5XSA9IGNvbG9yQ2xvdWQ0WzFdOwoKICBjb2xvckNsb3VkTWF0cml4WzEwXSA9IGNvbG9yQ2xvdWQwWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTFdID0gY29sb3JDbG91ZDFbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxMl0gPSBjb2xvckNsb3VkMlsyXTsKICBjb2xvckNsb3VkTWF0cml4WzEzXSA9IGNvbG9yQ2xvdWQzWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTRdID0gY29sb3JDbG91ZDRbMl07CgogIGNvbG9yQ2xvdWRNYXRyaXhbMTVdID0gY29sb3JDbG91ZDBbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxNl0gPSBjb2xvckNsb3VkMVszXTsKICBjb2xvckNsb3VkTWF0cml4WzE3XSA9IGNvbG9yQ2xvdWQyWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMThdID0gY29sb3JDbG91ZDNbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxOV0gPSBjb2xvckNsb3VkNFszXTsKfQojZW5kaWYKCnZvaWQgbWFpbigpIHsKICB2ZWM0IGNvbG9yID0gdkNvbG9yOwogIGZsb2F0IG9wYWNpdHkgPSBhYnMoZmxhZ0JhY2tncm91bmQpOwoKI2lmZGVmIEdSQURJRU5UCiAgaWYodV9ncmFkaWVudFR5cGUgPiAwICYmIGZsYWdCYWNrZ3JvdW5kID4gMC4wIHx8IHVfZ3JhZGllbnRUeXBlID09IDAgJiYgZmxhZ0JhY2tncm91bmQgPD0gMC4wKSB7CiAgICBncmFkaWVudChjb2xvciwgdkdyYWRpZW50VmVjdG9yMSwgdkdyYWRpZW50VmVjdG9yMiwgdV9jb2xvclN0ZXBzKTsKICB9CiNlbmRpZgoKICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICBjb2xvci5hICo9IG9wYWNpdHk7CiAgfQoKI2lmZGVmIFRFWFRVUkUKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdmVjMyB0ZXhDb29yZCA9IHZUZXh0dXJlQ29vcmQ7CgogICAgaWYodGV4Q29vcmQueiA9PSAxLjApIHsKICAgICAgdGV4Q29vcmQgPSBmcmFjdCh0ZXhDb29yZCk7CiAgICB9CgogICAgaWYodGV4Q29vcmQueCA8PSAxLjAgJiYgdGV4Q29vcmQueCA+PSAwLjAKICAgICAgJiYgdGV4Q29vcmQueSA8PSAxLjAgJiYgdGV4Q29vcmQueSA+PSAwLjApIHsKICAgICAgaWYodlNvdXJjZVJlY3QueiA+IDAuMCkgewogICAgICAgIHRleENvb3JkLnggPSB2U291cmNlUmVjdC54ICsgdGV4Q29vcmQueCAqIHZTb3VyY2VSZWN0Lno7CiAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtICh2U291cmNlUmVjdC55ICsgKDEuMCAtIHRleENvb3JkLnkpICogdlNvdXJjZVJlY3Qudyk7CiAgICAgIH0KICAgICAgaWYoZnJhbWVJbmRleCA8IDAuMCkgewogICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgICAgY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbnQgaW5kZXggPSBpbnQoZmxvb3IoY2xhbXAoMC4wLCAxMS4wLCBmcmFtZUluZGV4KSkpOwogICAgICAgIHZlYzQgdGV4Q29sb3I7CiAgICAgICAgaWYoaW5kZXggPT0gMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAyKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMiwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMykgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTMsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDQpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU0LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA1KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTYsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDcpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU3LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA4KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lOCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTksIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEwKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgICAgfQogICAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgICAgLy8gY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjb2xvci5hKTsKICAgICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICAgIH0KICAgIH0KICB9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgogIGlmKHVfZmlsdGVyRmxhZyA+IDApIHsKICAgIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCB1X2NvbG9yTWF0cml4KTsKICB9CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF07CiAgYnVpbGRDbG91ZENvbG9yKGNvbG9yQ2xvdWRNYXRyaXgpOwogIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCBjb2xvckNsb3VkTWF0cml4KTsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSwoZnVuY3Rpb24oYSxvKXt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBkfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIHYoKXtpZih0eXBlb2YgcGVyZm9ybWFuY2U8InUiJiZwZXJmb3JtYW5jZS5ub3cpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKHR5cGVvZiBhPCJ1IiYmYS5ocnRpbWUpe2NvbnN0W3UsY109YS5ocnRpbWUoKTtyZXR1cm4gdSoxZTMrYyoxZS02fXJldHVybiBEYXRlLm5vdz9EYXRlLm5vdygpOm5ldyBEYXRlKCkuZ2V0VGltZSgpfWxldCBULGQ7dHlwZW9mIG88InUiJiZ0eXBlb2Ygby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9PSJmdW5jdGlvbiI/KFQ9by5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsZD1vLmNhbmNlbEFuaW1hdGlvbkZyYW1lKTooVD1mdW5jdGlvbih1KXtyZXR1cm4gc2V0VGltZW91dCgoKT0+e3UodigpKX0sMTYpfSxkPWZ1bmN0aW9uKHUpe3JldHVybiBjbGVhclRpbWVvdXQodSl9KX0pLmNhbGwodGhpcyx0KDY5KSx0KDIyKSl9LGZ1bmN0aW9uKEwsZSl7dmFyIHQ9TC5leHBvcnRzPXt9LGEsbztmdW5jdGlvbiB2KCl7dGhyb3cgbmV3IEVycm9yKCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9ZnVuY3Rpb24gVCgpe3Rocm93IG5ldyBFcnJvcigiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9KGZ1bmN0aW9uKCl7dHJ5e3R5cGVvZiBzZXRUaW1lb3V0PT0iZnVuY3Rpb24iP2E9c2V0VGltZW91dDphPXZ9Y2F0Y2h7YT12fXRyeXt0eXBlb2YgY2xlYXJUaW1lb3V0PT0iZnVuY3Rpb24iP289Y2xlYXJUaW1lb3V0Om89VH1jYXRjaHtvPVR9fSkoKTtmdW5jdGlvbiBkKG0pe2lmKGE9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KG0sMCk7aWYoKGE9PT12fHwhYSkmJnNldFRpbWVvdXQpcmV0dXJuIGE9c2V0VGltZW91dCxzZXRUaW1lb3V0KG0sMCk7dHJ5e3JldHVybiBhKG0sMCl9Y2F0Y2h7dHJ5e3JldHVybiBhLmNhbGwobnVsbCxtLDApfWNhdGNoe3JldHVybiBhLmNhbGwodGhpcyxtLDApfX19ZnVuY3Rpb24gdShtKXtpZihvPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQobSk7aWYoKG89PT1UfHwhbykmJmNsZWFyVGltZW91dClyZXR1cm4gbz1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KG0pO3RyeXtyZXR1cm4gbyhtKX1jYXRjaHt0cnl7cmV0dXJuIG8uY2FsbChudWxsLG0pfWNhdGNoe3JldHVybiBvLmNhbGwodGhpcyxtKX19fXZhciBjPVtdLEU9ITEsZixnPS0xO2Z1bmN0aW9uIHkoKXshRXx8IWZ8fChFPSExLGYubGVuZ3RoP2M9Zi5jb25jYXQoYyk6Zz0tMSxjLmxlbmd0aCYmQygpKX1mdW5jdGlvbiBDKCl7aWYoIUUpe3ZhciBtPWQoeSk7RT0hMDtmb3IodmFyIHI9Yy5sZW5ndGg7cjspe2ZvcihmPWMsYz1bXTsrK2c8cjspZiYmZltnXS5ydW4oKTtnPS0xLHI9Yy5sZW5ndGh9Zj1udWxsLEU9ITEsdShtKX19dC5uZXh0VGljaz1mdW5jdGlvbihtKXt2YXIgcj1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBpPTE7aTxhcmd1bWVudHMubGVuZ3RoO2krKylyW2ktMV09YXJndW1lbnRzW2ldO2MucHVzaChuZXcgeChtLHIpKSxjLmxlbmd0aD09PTEmJiFFJiZkKEMpfTtmdW5jdGlvbiB4KG0scil7dGhpcy5mdW49bSx0aGlzLmFycmF5PXJ9eC5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0sdC50aXRsZT0iYnJvd3NlciIsdC5icm93c2VyPSEwLHQuZW52PXt9LHQuYXJndj1bXSx0LnZlcnNpb249IiIsdC52ZXJzaW9ucz17fTtmdW5jdGlvbiBoKCl7fXQub249aCx0LmFkZExpc3RlbmVyPWgsdC5vbmNlPWgsdC5vZmY9aCx0LnJlbW92ZUxpc3RlbmVyPWgsdC5yZW1vdmVBbGxMaXN0ZW5lcnM9aCx0LmVtaXQ9aCx0LnByZXBlbmRMaXN0ZW5lcj1oLHQucHJlcGVuZE9uY2VMaXN0ZW5lcj1oLHQubGlzdGVuZXJzPWZ1bmN0aW9uKG0pe3JldHVybltdfSx0LmJpbmRpbmc9ZnVuY3Rpb24obSl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCIpfSx0LmN3ZD1mdW5jdGlvbigpe3JldHVybiIvIn0sdC5jaGRpcj1mdW5jdGlvbihtKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCIpfSx0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBTfSk7dmFyIGE9dCgxKSxvPXQoNzEpLHY9dCg3MyksVD10KDIxMyksZD10KDIxNCksdT10KDIxNSksYz10KDIxNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIEUoYixPKXt2YXIgRD1PYmplY3Qua2V5cyhiKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgST1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGIpO08mJihJPUkuZmlsdGVyKGZ1bmN0aW9uKFIpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsUikuZW51bWVyYWJsZX0pKSxELnB1c2guYXBwbHkoRCxJKX1yZXR1cm4gRH1mdW5jdGlvbiBmKGIpe2Zvcih2YXIgTz0xO088YXJndW1lbnRzLmxlbmd0aDtPKyspe3ZhciBEPWFyZ3VtZW50c1tPXSE9bnVsbD9hcmd1bWVudHNbT106e307TyUyP0UoT2JqZWN0KEQpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEkpe2coYixJLERbSV0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhEKSk6RShPYmplY3QoRCkpLmZvckVhY2goZnVuY3Rpb24oSSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsSSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEQsSSkpfSl9cmV0dXJuIGJ9ZnVuY3Rpb24gZyhiLE8sRCl7cmV0dXJuIE8gaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixPLHt2YWx1ZTpELGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltPXT1ELGJ9Y29uc3QgeT1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxDPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSx4PVN5bWJvbCgicmVzb2x1dGlvbiIpLGg9U3ltYm9sKCJhbmltYXRpb25zIiksbT1TeW1ib2woImV2ZW50TGlzdGVuZXJzIikscj1TeW1ib2woImNhcHR1cmVFdmVudExpc3RlbmVycyIpLGk9U3ltYm9sKCJmaWx0ZXJzIiksbj1TeW1ib2woImRpc3BsYXkiKSxzPVN5bWJvbCgicHJvZ3JhbSIpLE09U3ltYm9sKCJzaGFkZXJBdHRycyIpLFA9U3ltYm9sKCJ1bmlmb3JtcyIpO2NsYXNzIFN7Y29uc3RydWN0b3IoTz17fSl7dGhpcy5hdHRyaWJ1dGVzPW5ldyB0aGlzLmNvbnN0cnVjdG9yLkF0dHIodGhpcyksdGhpc1t4XT17d2lkdGg6MzAwLGhlaWdodDoxNTB9LE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLE8pLHRoaXNbaF09bmV3IFNldCx0aGlzW21dPXt9LHRoaXNbcl09e319Z2V0IGFuY2VzdG9ycygpe2xldCBPPXRoaXMucGFyZW50O2NvbnN0IEQ9W107Zm9yKDtPOylELnB1c2goTyksTz1PLnBhcmVudDtyZXR1cm4gRH1nZXQgYW5pbWF0aW9ucygpe3JldHVybiB0aGlzW2hdfWdldCBmaWx0ZXJzKCl7cmV0dXJuIHRoaXNbaV18fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5maWx0ZXJzfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hMX1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQubGF5ZXI6bnVsbH1nZXQgbG9jYWxNYXRyaXgoKXtjb25zdCBPPXRoaXMudHJhbnNmb3JtTWF0cml4LHt4OkQseTpJfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIE9bNF0rPUQsT1s1XSs9SSxPfWdldCBvcGFjaXR5KCl7bGV0IE89dGhpcy5hdHRyaWJ1dGVzLm9wYWNpdHk7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcGFjaXR5IT1udWxsJiYoTyo9dGhpcy5wYXJlbnQub3BhY2l0eSksT31nZXQgcGFyZW50Tm9kZSgpe3JldHVybiB0aGlzLnBhcmVudH1nZXQgbmV4dFNpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KDEpfWdldCBwcmV2aW91c1NpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KC0xKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW3NdfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5yZW5kZXJlcjpudWxsfWdldCByZW5kZXJNYXRyaXgoKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXgpcmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeDtsZXQgTz10aGlzLmxvY2FsTWF0cml4O2NvbnN0IEQ9dGhpcy5wYXJlbnQ7aWYoRCl7Y29uc3QgST1ELl9fY2FjaGVSZW5kZXJNYXRyaXh8fEQucmVuZGVyTWF0cml4O0kmJihPPWEubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksTykpfXJldHVybiBPfWdldCB3b3JsZFNjYWxpbmcoKXtjb25zdCBPPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltNYXRoLmh5cG90KE9bMF0sT1sxXSksTWF0aC5oeXBvdChPWzJdLE9bM10pXX1nZXQgd29ybGRSb3RhdGlvbigpe2NvbnN0IE89dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuIE1hdGguYXRhbjIoT1sxXSxPWzNdKX1nZXQgd29ybGRQb3NpdGlvbigpe2NvbnN0IE89dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuW09bNF0sT1s1XV19Z2V0IHVuaWZvcm1zKCl7cmV0dXJuIHRoaXNbUF19Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuY2xhc3NOYW1lfXNldCBjbGFzc05hbWUoTyl7dGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZT1PfWdldCBpZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuaWR9c2V0IGlkKE8pe3RoaXMuYXR0cmlidXRlcy5pZD1PfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5uYW1lfXNldCBuYW1lKE8pe3RoaXMuYXR0cmlidXRlcy5uYW1lPU99Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuekluZGV4fXNldCB6SW5kZXgoTyl7dGhpcy5hdHRyaWJ1dGVzLnpJbmRleD1PfWdldCBtZXNoKCl7cmV0dXJuIG51bGx9Z2V0IHNoYWRlckF0dHJzKCl7cmV0dXJuIHRoaXNbTV18fHt9fWFjdGl2YXRlQW5pbWF0aW9ucygpe2NvbnN0IE89dGhpcy5sYXllcjtpZihPKXtjb25zdCBEPXRoaXNbaF07RC5mb3JFYWNoKFI9PntSLmJhc2VUaW1lbGluZT1PLnRpbWVsaW5lLFIucGxheSgpLFIuZmluaXNoZWQudGhlbigoKT0+e0QuZGVsZXRlKFIpfSl9KTtjb25zdCBJPXRoaXMuY2hpbGRyZW47SSYmSS5mb3JFYWNoKFI9PntSLmFjdGl2YXRlQW5pbWF0aW9ucyYmUi5hY3RpdmF0ZUFuaW1hdGlvbnMoKX0pfX1hZGRFdmVudExpc3RlbmVyKE8sRCxJPXt9KXtPPT09Im1vdXNld2hlZWwiJiYoTz0id2hlZWwiKSx0eXBlb2YgST09ImJvb2xlYW4iJiYoST17Y2FwdHVyZTpJfSk7Y29uc3R7Y2FwdHVyZTpSLG9uY2U6QX09SSxVPVI/cjptO3JldHVybiB0aGlzW1VdW09dPXRoaXNbVV1bT118fFtdLHRoaXNbVV1bT10ucHVzaCh7bGlzdGVuZXI6RCxvbmNlOkF9KSx0aGlzfWFuaW1hdGUoTyxEKXtjb25zdCBJPW5ldyB2LmRlZmF1bHQodGhpcyxPLEQpO3JldHVybiB0aGlzLmVmZmVjdHMmJkkuYXBwbHlFZmZlY3RzKHRoaXMuZWZmZWN0cyksdGhpcy5sYXllciYmKEkuYmFzZVRpbWVsaW5lPXRoaXMubGF5ZXIudGltZWxpbmUsSS5wbGF5KCksSS5maW5pc2hlZC50aGVuKCgpPT57dGhpc1toXS5kZWxldGUoSSl9KSksdGhpc1toXS5hZGQoSSksSX1hdHRyKC4uLk8pe2lmKE8ubGVuZ3RoPT09MClyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW0NdO2lmKE8ubGVuZ3RoPjEpe2xldFtELEldPU87cmV0dXJuIHR5cGVvZiBJPT0iZnVuY3Rpb24iJiYoST1JKHRoaXMuYXR0cihEKSkpLHRoaXMuc2V0QXR0cmlidXRlKEQsSSksdGhpc31yZXR1cm4gdHlwZW9mIE9bMF09PSJzdHJpbmciP3RoaXMuZ2V0QXR0cmlidXRlKE9bMF0pOihPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxPWzBdKSx0aGlzKX1jbG9uZU5vZGUoKXtjb25zdCBPPW5ldyB0aGlzLmNvbnN0cnVjdG9yLEQ9dGhpcy5hdHRyaWJ1dGVzW3ldO3JldHVybiBPLmF0dHIoRCksT31jb25uZWN0KE8sRCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOk8sd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkQsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksTy50aW1lbGluZSYmdGhpcy5hY3RpdmF0ZUFuaW1hdGlvbnMoKSx0aGlzLnNldFJlc29sdXRpb24oTy5nZXRSZXNvbHV0aW9uKCkpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImFwcGVuZCIsZGV0YWlsOntwYXJlbnQ6Tyx6T3JkZXI6RH19KX1jb250YWlucyhPKXtmb3IoO08mJnRoaXMhPT1POylPPU8ucGFyZW50O3JldHVybiEhT31kZWFjdGl2YXRlQW5pbWF0aW9ucygpe3RoaXNbaF0uZm9yRWFjaChEPT5ELmNhbmNlbCgpKTtjb25zdCBPPXRoaXMuY2hpbGRyZW47TyYmTy5mb3JFYWNoKEQ9PntELmRlYWN0aXZhdGVBbmltYXRpb25zJiZELmRlYWN0aXZhdGVBbmltYXRpb25zKCl9KX1kaXNjb25uZWN0KCl7Y29uc3R7cGFyZW50Ok8sek9yZGVyOkR9PXRoaXM7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcix0aGlzLmRlYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZW1vdmUiLGRldGFpbDp7cGFyZW50Ok8sek9yZGVyOkR9fSksTyYmTy5mb3JjZVVwZGF0ZSgpfWRpc3BhdGNoRXZlbnQoTyl7TyBpbnN0YW5jZW9mIGQuZGVmYXVsdHx8KE89bmV3IGQuZGVmYXVsdChPKSksTy50YXJnZXQ9dGhpcztsZXQgRD1PLnR5cGU7RD09PSJtb3VzZXdoZWVsIiYmKEQ9IndoZWVsIik7Y29uc3QgST1bdGhpc107bGV0IFI9dGhpcy5wYXJlbnQ7Zm9yKDtPLmJ1YmJsZXMmJlI7KUkucHVzaChSKSxSPVIucGFyZW50O2ZvcihsZXQgQT1JLmxlbmd0aC0xO0E+PTA7QS0tKXtjb25zdCBVPUlbQV0sSz1VW3JdJiZVW3JdW0RdO2lmKEsmJksubGVuZ3RoJiYoTy5jdXJyZW50VGFyZ2V0PVUsSy5mb3JFYWNoKCh7bGlzdGVuZXI6VixvbmNlOlF9KT0+e1YuY2FsbCh0aGlzLE8pLFEmJkkucmVtb3ZlRXZlbnRMaXN0ZW5lcihWKX0pLGRlbGV0ZSBPLmN1cnJlbnRUYXJnZXQpLCFPLmJ1YmJsZXMmJk8uY2FuY2VsQnViYmxlKWJyZWFrfWlmKCFPLmNhbmNlbEJ1YmJsZSlmb3IobGV0IEE9MDtBPEkubGVuZ3RoO0ErKyl7Y29uc3QgVT1JW0FdLEs9VVttXSYmVVttXVtEXTtpZihLJiZLLmxlbmd0aCYmKE8uY3VycmVudFRhcmdldD1VLEsuZm9yRWFjaCgoe2xpc3RlbmVyOlYsb25jZTpRfSk9PntWLmNhbGwodGhpcyxPKSxRJiZJLnJlbW92ZUV2ZW50TGlzdGVuZXIoVil9KSxkZWxldGUgTy5jdXJyZW50VGFyZ2V0KSwhTy5idWJibGVzfHxPLmNhbmNlbEJ1YmJsZSlicmVha319ZGlzcGF0Y2hQb2ludGVyRXZlbnQoTyl7Y29uc3R7bGF5ZXJYOkQsbGF5ZXJZOkl9PU87cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihELEkpPyh0aGlzLmRpc3BhdGNoRXZlbnQoTyksITApOiExfWRyYXcoTz1bXSl7Y29uc3QgRD10aGlzLm1lc2g7aWYoRCl7aWYoT2JqZWN0KHUuYXBwbHlGaWx0ZXJzKShELHRoaXMuZmlsdGVycyksTy5wdXNoKEQpLHRoaXNbc10pe0Quc2V0UHJvZ3JhbSh0aGlzW3NdKTtjb25zdCBJPXRoaXNbTV07SSYmT2JqZWN0LmVudHJpZXMoSSkuZm9yRWFjaCgoW0EsVV0pPT57RC5zZXRBdHRyaWJ1dGUoQSxVKX0pO2NvbnN0IFI9dGhpc1tQXTtpZih0aGlzW1BdKXtjb25zdCBBPXt9O09iamVjdC5lbnRyaWVzKFIpLmZvckVhY2goKFtVLEtdKT0+e3R5cGVvZiBLPT0iZnVuY3Rpb24iJiYoSz1LKHRoaXMsVSkpLEFbVV09S30pLEQuc2V0VW5pZm9ybXMoQSl9fU9iamVjdChjLmRlZmF1bHQpKHRoaXMsRCl9cmV0dXJuIE99Zm9yY2VVcGRhdGUoKXt0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKX1nZXRBdHRyaWJ1dGUoTyl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tPXX1nZXRMaXN0ZW5lcnMoTyx7Y2FwdHVyZTpEPSExfT17fSl7cmV0dXJuWy4uLnRoaXNbRD9yOm1dW09dfHxbXV19Z2V0Tm9kZU5lYXJCeShPPTEpe2lmKCF0aGlzLnBhcmVudClyZXR1cm4gbnVsbDtpZihPPT09MClyZXR1cm4gdGhpcztjb25zdCBEPXRoaXMucGFyZW50LmNoaWxkcmVuLEk9RC5pbmRleE9mKHRoaXMpO3JldHVybiBEW0krT119Z2V0V29ybGRQb3NpdGlvbihPLEQpe2NvbnN0IEk9dGhpcy5yZW5kZXJNYXRyaXgsUj1PKklbMF0rRCpJWzJdK0lbNF0sQT1PKklbMV0rRCpJWzNdK0lbNV07cmV0dXJuW1IsQV19Z2V0T2Zmc2V0UG9zaXRpb24oTyxEKXtjb25zdCBJPWEubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLnJlbmRlck1hdHJpeCksUj1PKklbMF0rRCpJWzJdK0lbNF0sQT1PKklbMV0rRCpJWzNdK0lbNV07cmV0dXJuW1IsQV19Z2V0UmVzb2x1dGlvbigpe3JldHVybiBmKHt9LHRoaXNbeF0pfWlzUG9pbnRDb2xsaXNpb24oTyxEKXtpZighdGhpcy5tZXNoKXJldHVybiExO2NvbnN0IEk9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoST09PSJub25lInx8SSE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IFI9ImJvdGgiO3JldHVybiBJPT09InZpc2libGVGaWxsIiYmKFI9ImZpbGwiKSxJPT09InZpc2libGVTdHJva2UiJiYoUj0ic3Ryb2tlIiksdGhpcy5tZXNoLmlzUG9pbnRDb2xsaXNpb24oTyxELFIpfW9uUHJvcGVydHlDaGFuZ2UoTyxELEkpe08hPT0iaWQiJiZPIT09Im5hbWUiJiZPIT09ImNsYXNzTmFtZSImJk8hPT0icG9pbnRlckV2ZW50cyImJk8hPT0icGFzc0V2ZW50cyImJnRoaXMuZm9yY2VVcGRhdGUoKSxPPT09ImZpbHRlciImJih0aGlzW2ldPU9iamVjdCh1LnBhcnNlRmlsdGVyU3RyaW5nKShEKSksTz09PSJ6SW5kZXgiJiZ0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVvcmRlcigpfXNldEF0dHJpYnV0ZShPLEQpe089PT0iYXR0cnMiJiZ0aGlzLmF0dHIoRCksdGhpcy5hdHRyaWJ1dGVzW09dPUR9c2V0TW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmKHRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PXRoaXMpfXNldFByb2dyYW0oTyl7dGhpc1tzXT1PLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRTaGFkZXJBdHRyaWJ1dGUoTyxEKXt0aGlzW01dPXRoaXNbTV18fHt9LHRoaXNbTV1bT109RCx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0VW5pZm9ybXMoTyl7dGhpc1tQXT10aGlzW1BdfHx7fSxPYmplY3QuYXNzaWduKHRoaXNbUF0sTyksdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFJlc29sdXRpb24oe3dpZHRoOk8saGVpZ2h0OkR9KXtjb25zdHt3aWR0aDpJLGhlaWdodDpSfT10aGlzW3hdOyhJIT09T3x8UiE9PUQpJiYodGhpc1t4XT17d2lkdGg6TyxoZWlnaHQ6RH0sdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzb2x1dGlvbmNoYW5nZSIsZGV0YWlsOnt3aWR0aDpPLGhlaWdodDpEfX0pKX1zaG93KCl7dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSImJih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT10aGlzW25dfHwiIil9aGlkZSgpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiJiYodGhpc1tuXT10aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSx0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT0ibm9uZSIpfXJlbGVhc2VNb3VzZUNhcHR1cmUoKXt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD09PXRoaXMmJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsKX1yZW1vdmUoKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlbW92ZUNoaWxkPyh0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSwhMCk6ITF9cmVtb3ZlQWxsTGlzdGVuZXJzKE8sRD17fSl7dHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0IFI9RC5jYXB0dXJlP3I6bTtyZXR1cm4gdGhpc1tSXVtPXSYmKHRoaXNbUl1bT109W10pLHRoaXN9cmVtb3ZlQXR0cmlidXRlKE8pe3RoaXMuc2V0QXR0cmlidXRlKE8sbnVsbCl9cmVtb3ZlRXZlbnRMaXN0ZW5lcihPLEQsST17fSl7dHlwZW9mIEk9PSJib29sZWFuIiYmKEk9e2NhcHR1cmU6SX0pO2NvbnN0IEE9SS5jYXB0dXJlP3I6bTtpZih0aGlzW0FdW09dKXtjb25zdCBVPXRoaXNbQV1bT107aWYoVSlmb3IobGV0IEs9MDtLPFUubGVuZ3RoO0srKyl7Y29uc3R7bGlzdGVuZXI6Vn09VVtLXTtpZihWPT09RCl7dGhpc1tBXVtPXS5zcGxpY2UoSywxKTticmVha319fXJldHVybiB0aGlzfXRyYW5zaXRpb24oTyxEPSJsaW5lYXIiKXtjb25zdCBJPXRoaXMsUj1TeW1ib2woImFuaW1hdGlvbiIpO0Q9RHx8ImxpbmVhciI7bGV0IEE9MDtyZXR1cm4gdHlwZW9mIE89PSJvYmplY3QiJiYoQT1PLmRlbGF5fHwwLE89Ty5kdXJhdGlvbikse1tSXTpudWxsLGNhbmNlbChVPSExKXtjb25zdCBLPXRoaXNbUl07SyYmSy5jYW5jZWwoVSl9LGVuZCgpe2NvbnN0IFU9dGhpc1tSXTtVJiYoVS5wbGF5U3RhdGU9PT0icnVubmluZyJ8fFUucGxheVN0YXRlPT09InBlbmRpbmciKSYmVS5maW5pc2goKX0scmV2ZXJzZSgpe2NvbnN0IFU9dGhpc1tSXTtpZihVKWlmKFUucGxheVN0YXRlPT09InJ1bm5pbmcifHxVLnBsYXlTdGF0ZT09PSJwZW5kaW5nIilVLnBsYXliYWNrUmF0ZT0tVS5wbGF5YmFja1JhdGU7ZWxzZXtjb25zdCBLPVUudGltaW5nLmRpcmVjdGlvbjtVLnRpbWluZy5kaXJlY3Rpb249Sz09PSJyZXZlcnNlIj8ibm9ybWFsIjoicmV2ZXJzZSIsVS5wbGF5KCl9cmV0dXJuIFUuZmluaXNoZWR9LGF0dHIoVSxLKXtyZXR1cm4gdGhpcy5lbmQoKSx0eXBlb2YgVT09InN0cmluZyImJihVPXtbVV06S30pLE9iamVjdC5lbnRyaWVzKFUpLmZvckVhY2goKFtWLFFdKT0+e3R5cGVvZiBRPT0iZnVuY3Rpb24iJiYoVVtWXT1RKEkuYXR0cihWKSkpfSksdGhpc1tSXT1JLmFuaW1hdGUoW1VdLHtkdXJhdGlvbjpPKjFlMyxkZWxheTpBKjFlMyxmaWxsOiJmb3J3YXJkcyIsZWFzaW5nOkR9KSx0aGlzW1JdLmZpbmlzaGVkfX19dXBkYXRlQ29udG91cnMoKXt9fWcoUywiQXR0ciIsby5kZWZhdWx0KSxULmRlZmF1bHQucmVnaXN0ZXJOb2RlKFMsIm5vZGUiKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pO3ZhciBhPXQoMSksbz10KDEyKSx2PXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxFPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2NoYW5nZWRBdHRycyIpLGc9U3ltYm9sKCJzdWJqZWN0IikseT1TeW1ib2woImF0dHIiKSxDPVN5bWJvbCgiZGVmYXVsdCIpLHg9U3ltYm9sKCJhbGlhcyIpO2Z1bmN0aW9uIGgoYixbTyxEXSl7bGV0IEk9YS5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtyZXR1cm5bLi4uYl0uZm9yRWFjaCgoW1IsQV0pPT57aWYoKE98fEQpJiYoST1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbTyxEXSkpLFI9PT0ibWF0cml4IilJPWEubWF0MmQubXVsdGlwbHkoSSxJLEEpO2Vsc2UgaWYoUj09PSJvZmZzZXRUcmFuc2xhdGUiKUlbNF0rPUFbMF0sSVs1XSs9QVsxXTtlbHNlIGlmKFI9PT0ib2Zmc2V0Um90YXRlIilJPWEubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLEEpO2Vsc2UgaWYoUj09PSJza2V3Iil7Y29uc3RbVSxLXT1BO0k9YS5tYXQyZC5tdWx0aXBseShJLEksYS5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oSyksTWF0aC50YW4oVSksMSwwLDApKX1lbHNlIGEubWF0MmRbUl0oSSxJLEEpOyhPfHxEKSYmKEk9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksWy1PLC1EXSkpfSksSX1jb25zdCBtPVN5bWJvbCgidHJhbnNmb3JtTWF0cml4Iikscj1TeW1ib2woInRyYW5zZm9ybXMiKSxpPVN5bWJvbCgiY2hhbmdlZEF0dHJzIiksbj1TeW1ib2woImxhc3RDaGFuZ2VkQXR0ciIpLHM9U3ltYm9sKCJvZmZzZXRGaWd1cmUiKTtmdW5jdGlvbiBNKGIsTyxEKXtjb25zdCBJPWJbeV1bT107aWYoYlt1XShPLEQsITEpfHxiW25dIT09Tyl7Y29uc3QgQT1iW3JdO0EuaGFzKE8pJiZBLmRlbGV0ZShPKSxEJiYoTz09PSJyb3RhdGUiJiYoRD1NYXRoLlBJKkQvMTgwKSxPPT09InNjYWxlIiYmKEQ9RC5tYXAoVT0+TWF0aC5hYnMoVSk+MWUtNT9VOjEvVT4wPzFlLTU6LTFlLTUpKSxBLnNldChPLEQpKSxiW21dPW51bGwsYltnXS5vblByb3BlcnR5Q2hhbmdlKE8sRCxJLGIpfX1mdW5jdGlvbiBQKGIpe2NvbnN0IE89YltzXSxEPWIub2Zmc2V0RGlzdGFuY2UqTy5nZXRUb3RhbExlbmd0aCgpLEk9Ty5nZXRQb2ludEF0TGVuZ3RoKEQpO2lmKEkpe2NvbnN0IFI9YltyXTtsZXQgQT1iLm9mZnNldFJvdGF0ZTtBPT09ImF1dG8iP0E9SS5hbmdsZTpBPT09InJldmVyc2UiP0E9TWF0aC5QSStJLmFuZ2xlOkE9TWF0aC5QSSpBLzE4MCxSLnNldCgib2Zmc2V0Um90YXRlIixBKSxSLnNldCgib2Zmc2V0VHJhbnNsYXRlIixbSS54LEkueV0pLGJbbV09bnVsbH19Y2xhc3MgU3tzdGF0aWMgc2V0RGVmYXVsdChPLC4uLkQpe3JldHVybiBPW1RdKC4uLkQpfXN0YXRpYyBkZWNsYXJlQWxpYXMoTywuLi5EKXtyZXR1cm4gT1tkXSguLi5EKX1zdGF0aWMgc2V0QXR0cmlidXRlKE8sLi4uRCl7cmV0dXJuIE9bdV0oLi4uRCl9c3RhdGljIGdldEF0dHJpYnV0ZShPLC4uLkQpe3JldHVybiBPW2NdKC4uLkQpfXN0YXRpYyBnZXRBdHRyaWJ1dGVzKE8pe3JldHVybiBPW0VdfXN0YXRpYyBnZXRDaGFuZ2VkQXR0cmlidXRlcyhPKXtyZXR1cm4gT1tmXX1jb25zdHJ1Y3RvcihPKXt0aGlzW2ddPU8sdGhpc1t5XT17fSx0aGlzW21dPWEubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCksdGhpc1tyXT1uZXcgTWFwLHRoaXNbQ109e30sdGhpc1t4XT1bXSxPYmplY3QuZGVmaW5lUHJvcGVydHkoTywidHJhbnNmb3JtTWF0cml4Iix7Z2V0OigpPT4odGhpc1ttXXx8KHRoaXNbbV09aCh0aGlzW3JdLHRoaXMudHJhbnNmb3JtT3JpZ2luKSksWy4uLnRoaXNbbV1dKX0pLHRoaXNbVF0oe2lkOiIiLG5hbWU6IiIsY2xhc3NOYW1lOiIiLHg6MCx5OjAsdHJhbnNmb3JtT3JpZ2luOlswLDBdLHRyYW5zZm9ybToiIix0cmFuc2xhdGU6WzAsMF0scm90YXRlOjAsc2NhbGU6WzEsMV0sc2tldzpbMCwwXSxvcGFjaXR5OjEsekluZGV4OjAsb2Zmc2V0UGF0aDp2b2lkIDAsb2Zmc2V0RGlzdGFuY2U6MCxvZmZzZXRSb3RhdGU6ImF1dG8iLHBvaW50ZXJFdmVudHM6InZpc2libGUiLGZpbHRlcjoibm9uZSIsZGlzcGxheToiIn0pLHRoaXNbZF0oImNsYXNzIiwicG9zIiksdGhpc1tpXT1uZXcgU2V0LHRoaXNbc109bmV3IG8uRmlndXJlMkQoe3NjYWxlOjUsc2ltcGxpZnk6MH0pfWdldFtmXSgpe2NvbnN0IE89e307cmV0dXJuWy4uLnRoaXNbaV1dLmZvckVhY2goRD0+e09bRF09dGhpc1t5XVtEXX0pLE99Z2V0W0VdKCl7Y29uc3QgTz1PYmplY3QuYXNzaWduKHt9LHRoaXNbeV0pO2ZvcihsZXQgRD0wO0Q8dGhpc1t4XS5sZW5ndGg7RCsrKXtjb25zdCBJPXRoaXNbeF1bRF07T1tJXT10aGlzW0ldfXJldHVybiBPfVtUXShPKXtPYmplY3QuYXNzaWduKHRoaXNbQ10sTyksT2JqZWN0LmFzc2lnbih0aGlzW3ldLE8pfVtkXSguLi5PKXt0aGlzW3hdLnB1c2goLi4uTyl9W3VdKE8sRCxJPSEwKXtjb25zdCBSPXRoaXNbeV1bT10sQT10aGlzW2ddO3JldHVybiBEPT1udWxsJiYoRD10aGlzW0NdW09dKSxPYmplY3Qodi5jb21wYXJlVmFsdWUpKFIsRCk/ITE6KHRoaXNbeV1bT109RCx0aGlzW2ldLmhhcyhPKSYmdGhpc1tpXS5kZWxldGUoTyksdGhpc1tpXS5hZGQoTyksdGhpc1tuXT1PLEkmJkEub25Qcm9wZXJ0eUNoYW5nZShPLEQsUix0aGlzKSwhMCl9W2NdKE8pe3JldHVybiB0aGlzW3ldW09dfXNldCBpZChPKXt0aGlzW3VdKCJpZCIsTyl9Z2V0IGlkKCl7cmV0dXJuIHRoaXNbY10oImlkIil9c2V0IG5hbWUoTyl7dGhpc1t1XSgibmFtZSIsTyl9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1tjXSgibmFtZSIpfXNldCBjbGFzc05hbWUoTyl7dGhpc1t1XSgiY2xhc3NOYW1lIixPKX1nZXQgY2xhc3NOYW1lKCl7cmV0dXJuIHRoaXNbY10oImNsYXNzTmFtZSIpfXNldCBjbGFzcyhPKXt0aGlzLmNsYXNzTmFtZT1PfWdldCBjbGFzcygpe3JldHVybiB0aGlzLmNsYXNzTmFtZX1nZXQgeCgpe3JldHVybiB0aGlzW2NdKCJ4Iil9c2V0IHgoTyl7dGhpc1t1XSgieCIsT2JqZWN0KHYudG9OdW1iZXIpKE8pKX1nZXQgeSgpe3JldHVybiB0aGlzW2NdKCJ5Iil9c2V0IHkoTyl7dGhpc1t1XSgieSIsT2JqZWN0KHYudG9OdW1iZXIpKE8pKX1nZXQgcG9zKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldCBwb3MoTyl7Tz1PYmplY3Qodi50b0FycmF5KShPKSxBcnJheS5pc0FycmF5KE8pfHwoTz1bTyxPXSksdGhpcy54PU9bMF0sdGhpcy55PU9bMV19Z2V0IHRyYW5zZm9ybSgpe3JldHVybiB0aGlzW2NdKCJ0cmFuc2Zvcm0iKX1zZXQgdHJhbnNmb3JtKE8pe2xldCBEPW51bGw7aWYoQXJyYXkuaXNBcnJheShPKSYmKEQ9TyxPPWBtYXRyaXgoJHtPLm1hcCh2LnRvTnVtYmVyKS5qb2luKCl9KWApLHR5cGVvZiBPPT0ic3RyaW5nIilPPU8ucmVwbGFjZSgvXHMqLFxzKi9nLCIsIik7ZWxzZSBpZihPIT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpO2NvbnN0IEk9dGhpc1t5XS50cmFuc2Zvcm07aWYodGhpc1t1XSgidHJhbnNmb3JtIixPLCExKSl7Y29uc3QgUj10aGlzW3JdO2lmKFIuaGFzKCJtYXRyaXgiKSYmUi5kZWxldGUoIm1hdHJpeCIpLEQpUi5zZXQoIm1hdHJpeCIsRCk7ZWxzZSBpZihPKXtjb25zdCBBPU8ubWF0Y2goLyhtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoW14oKV0rXCkvZyk7aWYoQSl7bGV0IFU9YS5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtmb3IobGV0IEs9MDtLPEEubGVuZ3RoO0srKyl7Y29uc3QgUT1BW0tdLm1hdGNoKC9eKG1hdHJpeHx0cmFuc2xhdGV8cm90YXRlfHNjYWxlfHNrZXcpXCgoW14oKV0rKVwpLyk7aWYoUSl7bGV0WyxxLFddPVE7cT09PSJyb3RhdGUiP1c9TWF0aC5QSSpwYXJzZUZsb2F0KFcpLzE4MDpXPVcudHJpbSgpLnNwbGl0KC9bXHMsXSsvKS5tYXAoSD0+T2JqZWN0KHYudG9OdW1iZXIpKEgpKSxxPT09Im1hdHJpeCI/VT1hLm1hdDJkLm11bHRpcGx5KFUsVSxXKTpxPT09InNrZXciP1U9YS5tYXQyZC5tdWx0aXBseShVLFUsYS5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oV1sxXSksTWF0aC50YW4oV1swXSksMSwwLDApKTphLm1hdDJkW3FdKFUsVSxXKSxSLnNldCgibWF0cml4IixVKX19fWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB0cmFuc2Zvcm0gdmFsdWUuIil9dGhpc1ttXT1udWxsLHRoaXNbZ10ub25Qcm9wZXJ0eUNoYW5nZSgidHJhbnNmb3JtIixPLEksdGhpcyl9fWdldCB0cmFuc2Zvcm1PcmlnaW4oKXtyZXR1cm4gdGhpc1tjXSgidHJhbnNmb3JtT3JpZ2luIil9c2V0IHRyYW5zZm9ybU9yaWdpbihPKXtPPU9iamVjdCh2LnRvQXJyYXkpKE8sITApLE8hPW51bGwmJiFBcnJheS5pc0FycmF5KE8pJiYoTz1bTyxPXSksdGhpc1t1XSgidHJhbnNmb3JtT3JpZ2luIixPKSYmKHRoaXNbbV09bnVsbCl9Z2V0IHJvdGF0ZSgpe3JldHVybiB0aGlzW2NdKCJyb3RhdGUiKX1zZXQgcm90YXRlKE8pe00odGhpcywicm90YXRlIixPKX1nZXQgdHJhbnNsYXRlKCl7cmV0dXJuIHRoaXNbY10oInRyYW5zbGF0ZSIpfXNldCB0cmFuc2xhdGUoTyl7Tz1PYmplY3Qodi50b0FycmF5KShPLCEwKSxPIT1udWxsJiYhQXJyYXkuaXNBcnJheShPKSYmKE89W08sT10pLE0odGhpcywidHJhbnNsYXRlIixPKX1nZXQgc2NhbGUoKXtyZXR1cm4gdGhpc1tjXSgic2NhbGUiKX1zZXQgc2NhbGUoTyl7Tz1PYmplY3Qodi50b0FycmF5KShPLCEwKSxPIT1udWxsJiYhQXJyYXkuaXNBcnJheShPKSYmKE89W08sT10pLE0odGhpcywic2NhbGUiLE8pfWdldCBza2V3KCl7cmV0dXJuIHRoaXNbY10oInNrZXciKX1zZXQgc2tldyhPKXtPPU9iamVjdCh2LnRvQXJyYXkpKE8sITApLE8hPW51bGwmJiFBcnJheS5pc0FycmF5KE8pJiYoTz1bTyxPXSksTSh0aGlzLCJza2V3IixPKX1nZXQgb3BhY2l0eSgpe3JldHVybiB0aGlzW2NdKCJvcGFjaXR5Iil9c2V0IG9wYWNpdHkoTyl7TyE9bnVsbCYmKE89TnVtYmVyKE8pKSx0aGlzW3VdKCJvcGFjaXR5IixPKX1nZXQgekluZGV4KCl7cmV0dXJuIHRoaXNbY10oInpJbmRleCIpfXNldCB6SW5kZXgoTyl7TyE9bnVsbCYmKE89TnVtYmVyKE8pKSx0aGlzW3VdKCJ6SW5kZXgiLE8pfWdldCBvZmZzZXRQYXRoKCl7cmV0dXJuIHRoaXNbY10oIm9mZnNldFBhdGgiKX1zZXQgb2Zmc2V0UGF0aChPKXt0aGlzW3VdKCJvZmZzZXRQYXRoIixPKSYmKHRoaXNbc10uYmVnaW5QYXRoKCksTyE9bnVsbCYmdGhpc1tzXS5hZGRQYXRoKE8pLFAodGhpcykpfWdldCBvZmZzZXREaXN0YW5jZSgpe3JldHVybiB0aGlzW2NdKCJvZmZzZXREaXN0YW5jZSIpfXNldCBvZmZzZXREaXN0YW5jZShPKXt0aGlzW3VdKCJvZmZzZXREaXN0YW5jZSIsT2JqZWN0KHYudG9OdW1iZXIpKE8pKSYmUCh0aGlzKX1nZXQgb2Zmc2V0Um90YXRlKCl7cmV0dXJuIHRoaXNbY10oIm9mZnNldFJvdGF0ZSIpfXNldCBvZmZzZXRSb3RhdGUoTyl7dGhpc1t1XSgib2Zmc2V0Um90YXRlIixPKSxQKHRoaXMpfWdldCBwb2ludGVyRXZlbnRzKCl7cmV0dXJuIHRoaXNbY10oInBvaW50ZXJFdmVudHMiKX1zZXQgcG9pbnRlckV2ZW50cyhPKXtpZihPIT1udWxsJiZPIT09Im5vbmUiJiZPIT09InZpc2libGUiJiZPIT09InZpc2libGVGaWxsIiYmTyE9PSJ2aXNpYmxlU3Ryb2tlIiYmTyE9PSJhbGwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcG9pbnRlckV2ZW50cyB0eXBlLiIpO3RoaXNbdV0oInBvaW50ZXJFdmVudHMiLE8pfWdldCBmaWx0ZXIoKXtyZXR1cm4gdGhpc1tjXSgiZmlsdGVyIil9c2V0IGZpbHRlcihPKXt0aGlzW3VdKCJmaWx0ZXIiLE8pfWdldCBkaXNwbGF5KCl7cmV0dXJuIHRoaXNbY10oImRpc3BsYXkiKX1zZXQgZGlzcGxheShPKXt0aGlzW3VdKCJkaXNwbGF5IixPKX1zZXQgb2Zmc2V0KE8pe319fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJzaXplVG9QaXhlbCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChlLCJ0b051bWJlciIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJ0b0FycmF5IixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImNvbXBhcmVWYWx1ZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKHUsYyl7Y29uc3QgRT11LnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLyk7RT91PXtzaXplOnBhcnNlRmxvYXQoRVsxXSksdW5pdDpFWzJdfTp1PXtzaXplOnBhcnNlRmxvYXQodSksdW5pdDoicHgifTtsZXR7c2l6ZTpmLHVuaXQ6Z309dTtpZihnPT09InB0IilmLz0uNzU7ZWxzZSBpZihnPT09InBjIilmKj0xNjtlbHNlIGlmKGc9PT0iaW4iKWYqPTk2O2Vsc2UgaWYoZz09PSJjbSIpZio9OTYvMi41NDtlbHNlIGlmKGc9PT0ibW0iKWYqPTk2LzI1LjQ7ZWxzZSBpZihnPT09ImVtInx8Zz09PSJyZW0ifHxnPT09ImV4Iil7aWYoIWMmJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCB5PWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTt5P2M9YSh5LDE2KTpjPTE2fWYqPWMsZz09PSJleCImJihmLz0yKX1lbHNlIGlmKGc9PT0icSIpZio9OTYvMjUuNC80O2Vsc2UgaWYoZz09PSJ2dyJ8fGc9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCB5PWc9PT0idnciP3dpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2YqPXkvMTAwfX1lbHNlIGlmKChnPT09InZtYXgifHxnPT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3QgeT13aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLEM9d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2c9PT0idm1heCI/Zio9TWF0aC5tYXgoeSxDKS8xMDA6Zio9TWF0aC5taW4oeSxDKS8xMDB9cmV0dXJuIGZ9ZnVuY3Rpb24gbyh1KXtyZXR1cm4gdT09bnVsbD91OlN0cmluZyh1KX1mdW5jdGlvbiB2KHUpe2lmKHU9PW51bGwpcmV0dXJuIHU7aWYodHlwZW9mIHU9PSJzdHJpbmciJiYodT1hKHUpKSwhTnVtYmVyLmlzRmluaXRlKHUpKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmFsdWUiKTtyZXR1cm4gdX1mdW5jdGlvbiBUKHUsYz0hMSl7cmV0dXJuIHU9PT0iIj9udWxsOih0eXBlb2YgdT09InN0cmluZyImJih1PXUuc3BsaXQoL1tccyxdKy9nKSksQXJyYXkuaXNBcnJheSh1KSYmKGMmJih1PXUubWFwKHYpKSx1Lmxlbmd0aD09PTEpP3VbMF06dSl9ZnVuY3Rpb24gZCh1LGMpe2lmKEFycmF5LmlzQXJyYXkodSkmJkFycmF5LmlzQXJyYXkoYykpe2lmKHUubGVuZ3RoIT09Yy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBFPTA7RTx1Lmxlbmd0aDtFKyspaWYodVtFXSE9PWNbRV0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHU9PW51bGwmJmM9PW51bGx8fHU9PT1jfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciBhPXQoNzQpLG89dCgzMiksdj10Lm4obyksVD10KDY4KSxkPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KCl7cmV0dXJuIHU9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oeSl7Zm9yKHZhciBDPTE7Qzxhcmd1bWVudHMubGVuZ3RoO0MrKyl7dmFyIHg9YXJndW1lbnRzW0NdO2Zvcih2YXIgaCBpbiB4KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LGgpJiYoeVtoXT14W2hdKX1yZXR1cm4geX0sdS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYyh5KXtpZih0eXBlb2YgeT09InN0cmluZyIpe2lmKHk9eS50cmltKCksL15bMC05Ll0rJSQvLnRlc3QoeSkpcmV0dXJuIHBhcnNlRmxvYXQoeSkvMTAwO2lmKC9eKFtcZC5dKykocHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWluKSQvLnRlc3QoeSkpcmV0dXJuIE9iamVjdChkLnNpemVUb1BpeGVsKSh5KX1yZXR1cm4geX1mdW5jdGlvbiBFKHksQyx4LGgsbSl7cmV0dXJuIHR5cGVvZiB5PT0ic3RyaW5nIiYmKHk9digpKHkpKSx0eXBlb2YgQz09InN0cmluZyImJihDPXYoKShDKSksYS5FZmZlY3RzLmRlZmF1bHQoeSxDLHgsaCxtKX1mdW5jdGlvbiBmKHksQyx4LGgsbSl7cmV0dXJuIGEuRWZmZWN0cy5kZWZhdWx0KHksQyx4LGgsbSl9YS5FZmZlY3RzLmRlZmF1bHQ9ZnVuY3Rpb24oeSxDLHgsaCxtKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh5KSYmQXJyYXkuaXNBcnJheShDKT95Lm1hcCgocixpKT0+cisoeC1oKS8obS1oKSooQ1tpXS1yKSk6dHlwZW9mIHk9PSJudW1iZXIiJiZ0eXBlb2YgQz09Im51bWJlciI/eSsoeC1oKS8obS1oKSooQy15KTp4LWg+bS14P0M6eX0sYS5FZmZlY3RzLmZpbGxDb2xvcj1FLGEuRWZmZWN0cy5zdHJva2VDb2xvcj1FLGEuRWZmZWN0cy5iZ2NvbG9yPUUsYS5FZmZlY3RzLmJvcmRlckNvbG9yPUUsYS5FZmZlY3RzLnRleHQ9ZjtjbGFzcyBnIGV4dGVuZHMgYS5BbmltYXRvcntjb25zdHJ1Y3RvcihDLHgsaCl7Y29uc3QgbT1DLmF0dHIoKTtPYmplY3QuZW50cmllcyhtKS5mb3JFYWNoKChbcixpXSk9PnttW3JdPWEuRWZmZWN0c1tyXT9pOmMoaSl9KSx4PXgubWFwKHI9PntsZXQgaT11KHt9LHIpO2NvbnN0IG49e307cmV0dXJuIE9iamVjdC5lbnRyaWVzKGkpLmZvckVhY2goKFtzLE1dKT0+e25bc109YS5FZmZlY3RzW3NdP006YyhNKX0pLG59KSxzdXBlcihtLHgsaCksdGhpcy50YXJnZXQ9Qyx0aGlzLnNldHRlcj1mdW5jdGlvbihyLGkpe2kuYXR0cihyKX19Z2V0IHBsYXlTdGF0ZSgpe3JldHVybiB0aGlzLnRhcmdldC5wYXJlbnQ/c3VwZXIucGxheVN0YXRlOiJpZGxlIn1nZXQgZmluaXNoZWQoKXtyZXR1cm4gc3VwZXIuZmluaXNoZWQudGhlbigoKT0+e2NvbnN0IEM9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoeD0+e2Z1bmN0aW9uIGgoKXtDLnNldHRlcihDLmZyYW1lLEMudGFyZ2V0KTtjb25zdCBtPUMucGxheVN0YXRlO209PT0iZmluaXNoZWQifHxtPT09ImlkbGUiPyhPYmplY3QoVC5jYW5jZWxBbmltYXRpb25GcmFtZSkoQy5yZXF1ZXN0SWQpLHgoKSk6T2JqZWN0KFQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShoKX1oKCl9KX0pfWZpbmlzaCgpe3N1cGVyLmZpbmlzaCgpLE9iamVjdChULmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzLnJlcXVlc3RJZCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCl9cGxheSgpe2lmKCF0aGlzLnRhcmdldC5wYXJlbnR8fHRoaXMucGxheVN0YXRlPT09InJ1bm5pbmciKXJldHVybjtzdXBlci5wbGF5KCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCk7Y29uc3QgQz10aGlzO3RoaXMucmVhZHkudGhlbigoKT0+e0Muc2V0dGVyKEMuZnJhbWUsQy50YXJnZXQpLEMucmVxdWVzdElkPU9iamVjdChULnJlcXVlc3RBbmltYXRpb25GcmFtZSkoZnVuY3Rpb24geCgpe2NvbnN0IGg9Qy50YXJnZXQ7aWYodHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMmJmgubGF5ZXImJmgubGF5ZXIuY2FudmFzJiYhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGgubGF5ZXIuY2FudmFzKSl7Qy5jYW5jZWwoKTtyZXR1cm59Y29uc3QgbT1DLnBsYXlTdGF0ZTtDLnNldHRlcihDLmZyYW1lLEMudGFyZ2V0KSxtIT09ImlkbGUiJiYobT09PSJydW5uaW5nIj9DLnJlcXVlc3RJZD1PYmplY3QoVC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKHgpOihtPT09InBhdXNlZCJ8fG09PT0icGVuZGluZyImJkMudGltZWxpbmUuY3VycmVudFRpbWU8MCkmJkMucmVhZHkudGhlbigoKT0+e0Muc2V0dGVyKEMuZnJhbWUsQy50YXJnZXQpLEMucmVxdWVzdElkPU9iamVjdChULnJlcXVlc3RBbmltYXRpb25GcmFtZSkoeCl9KSl9KX0pfWNhbmNlbChDPSExKXtPYmplY3QoVC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLEM/KHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpLHN1cGVyLmNhbmNlbCgpKTooc3VwZXIuY2FuY2VsKCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCkpfX19LGZ1bmN0aW9uKEwsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5UaW1lbGluZT1lLkVmZmVjdHM9ZS5FYXNpbmdzPWUuQW5pbWF0b3I9dm9pZCAwO3ZhciBhPXQoNzUpLG89RShhKSx2PXQoMTg3KSxUPUUodiksZD10KDE4OCksdT10KDE5MCksYz1FKHUpO2Z1bmN0aW9uIEUoZil7cmV0dXJuIGYmJmYuX19lc01vZHVsZT9mOntkZWZhdWx0OmZ9fWUuQW5pbWF0b3I9Yy5kZWZhdWx0LGUuRWFzaW5ncz1kLkVhc2luZ3MsZS5FZmZlY3RzPVQuZGVmYXVsdCxlLlRpbWVsaW5lPW8uZGVmYXVsdH0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgYT10KDc2KSxvPXIoYSksdj10KDEzMyksVD1yKHYpLGQ9dCgxNDEpLHU9cihkKSxjPXQoMTY0KSxFPXIoYyksZj10KDE3MCksZz1yKGYpLHk9dCgxNzEpLEM9cih5KSx4PXQoMTc1KSxoPXIoeCksbT10KDE4Nik7ZnVuY3Rpb24gcihJKXtyZXR1cm4gSSYmSS5fX2VzTW9kdWxlP0k6e2RlZmF1bHQ6SX19dmFyIGk9KDAsbS5jcmVhdGVOb3dUaW1lKSgpLG49e29yaWdpblRpbWU6MCxwbGF5YmFja1JhdGU6MX0scz0oMCxoLmRlZmF1bHQpKCJ0aW1lTWFyayIpLE09KDAsaC5kZWZhdWx0KSgicGxheWJhY2tSYXRlIiksUD0oMCxoLmRlZmF1bHQpKCJ0aW1lcnMiKSxTPSgwLGguZGVmYXVsdCkoIm9yaWdpblRpbWUiKSxiPSgwLGguZGVmYXVsdCkoInNldFRpbWVyIiksTz0oMCxoLmRlZmF1bHQpKCJwYXJlbnQiKSxEPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gSShSLEEpeygwLGcuZGVmYXVsdCkodGhpcyxJKSxSIGluc3RhbmNlb2YgSSYmKEE9UixSPXt9KSxSPSgwLEUuZGVmYXVsdCkoe30sbixSKSxBJiYodGhpc1tPXT1BKTt2YXIgVT1SLm5vd3RpbWV8fGk7aWYoQSlPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBBLmN1cnJlbnRUaW1lfX0pO2Vsc2V7dmFyIEs9VSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJnbG9iYWxUaW1lIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFUoKS1LfX0pfXRoaXNbc109W3tnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6LVIub3JpZ2luVGltZSxlbnRyb3B5Oi1SLm9yaWdpblRpbWUscGxheWJhY2tSYXRlOlIucGxheWJhY2tSYXRlLGdsb2JhbEVudHJvcHk6MH1dLHRoaXNbT10mJih0aGlzW3NdWzBdLmdsb2JhbEVudHJvcHk9dGhpc1tPXS5lbnRyb3B5KSx0aGlzW1NdPVIub3JpZ2luVGltZSx0aGlzW01dPVIucGxheWJhY2tSYXRlLHRoaXNbUF09bmV3IHUuZGVmYXVsdH1yZXR1cm4oMCxDLmRlZmF1bHQpKEksW3trZXk6Im1hcmtUaW1lIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBBPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxVPUEudGltZSxLPVU9PT12b2lkIDA/dGhpcy5jdXJyZW50VGltZTpVLFY9QS5lbnRyb3B5LFE9Vj09PXZvaWQgMD90aGlzLmVudHJvcHk6VixxPUEucGxheWJhY2tSYXRlLFc9cT09PXZvaWQgMD90aGlzLnBsYXliYWNrUmF0ZTpxLEg9e2dsb2JhbFRpbWU6dGhpcy5nbG9iYWxUaW1lLGxvY2FsVGltZTpLLGVudHJvcHk6USxwbGF5YmFja1JhdGU6VyxnbG9iYWxFbnRyb3B5OnRoaXMuZ2xvYmFsRW50cm9weX07dGhpc1tzXS5wdXNoKEgpfX0se2tleToiZm9yayIsdmFsdWU6ZnVuY3Rpb24oQSl7cmV0dXJuIG5ldyBJKEEsdGhpcyl9fSx7a2V5OiJzZWVrR2xvYmFsVGltZSIsdmFsdWU6ZnVuY3Rpb24oQSl7dmFyIFU9dGhpcy5zZWVrVGltZU1hcmsoQSksSz10aGlzW3NdW1VdLFY9Sy5lbnRyb3B5LFE9Sy5wbGF5YmFja1JhdGUscT1LLmdsb2JhbFRpbWU7cmV0dXJuIHErKEEtVikvTWF0aC5hYnMoUSl9fSx7a2V5OiJzZWVrTG9jYWxUaW1lIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgVT10aGlzLnNlZWtUaW1lTWFyayhBKSxLPXRoaXNbc11bVV0sVj1LLmxvY2FsVGltZSxRPUsuZW50cm9weSxxPUsucGxheWJhY2tSYXRlO3JldHVybiBxPjA/VisoQS1RKTpWLShBLVEpfX0se2tleToic2Vla1RpbWVNYXJrIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgVT10aGlzW3NdLEs9MCxWPVUubGVuZ3RoLTE7aWYoQTw9VVtLXS5lbnRyb3B5KXJldHVybiBLO2lmKEE+PVVbVl0uZW50cm9weSlyZXR1cm4gVjtmb3IodmFyIFE9TWF0aC5mbG9vcigoSytWKS8yKTtRPksmJlE8Vjspe2lmKEE9PT1VW1FdLmVudHJvcHkpcmV0dXJuIFE7QTxVW1FdLmVudHJvcHk/Vj1ROkE+VVtRXS5lbnRyb3B5JiYoSz1RKSxRPU1hdGguZmxvb3IoKEsrVikvMil9cmV0dXJuIEt9fSx7a2V5OiJ1cGRhdGVUaW1lcnMiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEE9dGhpcyxVPVtdLmNvbmNhdCgoMCxULmRlZmF1bHQpKHRoaXNbUF0pKTtVLmZvckVhY2goZnVuY3Rpb24oSyl7dmFyIFY9KDAsby5kZWZhdWx0KShLLDIpLFE9VlswXSxxPVZbMV07QVtiXShxLmhhbmRsZXIscS50aW1lLFEpfSl9fSx7a2V5OiJjbGVhclRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKFIpe2Z1bmN0aW9uIEEoVSl7cmV0dXJuIFIuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBBLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIFIudG9TdHJpbmcoKX0sQX0oZnVuY3Rpb24oUil7dmFyIEE9dGhpc1tQXS5nZXQoUik7QSYmQS50aW1lcklEIT1udWxsJiYodGhpc1tPXT90aGlzW09dLmNsZWFyVGltZW91dChBLnRpbWVySUQpOmNsZWFyVGltZW91dChBLnRpbWVySUQpKSx0aGlzW1BdLmRlbGV0ZShSKX0pfSx7a2V5OiJjbGVhckludGVydmFsIix2YWx1ZTpmdW5jdGlvbihBKXtyZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoQSl9fSx7a2V5OiJjbGVhciIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgQT10aGlzLFU9dGhpc1tQXTtbXS5jb25jYXQoKDAsVC5kZWZhdWx0KShVLmtleXMoKSkpLmZvckVhY2goZnVuY3Rpb24oSyl7QS5jbGVhclRpbWVvdXQoSyl9KX19LHtrZXk6InNldFRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKEEpe3ZhciBVPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7ZGVsYXk6MH07cmV0dXJuIHRoaXNbYl0oQSxVKX19LHtrZXk6InNldEludGVydmFsIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgVT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9LEs9dGhpcyxWPXRoaXNbYl0oZnVuY3Rpb24gUSgpe0tbYl0oUSxVLFYpLEEoKX0sVSk7cmV0dXJuIFZ9fSx7a2V5OmIsdmFsdWU6ZnVuY3Rpb24oQSxVKXt2YXIgSz10aGlzLFY9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOigwLGguZGVmYXVsdCkoInRpbWVySUQiKTtVPSgwLG0uZm9ybWF0RGVsYXkpKFUpO3ZhciBRPXRoaXNbUF0uZ2V0KFYpLHE9dm9pZCAwLFc9bnVsbCxIPXZvaWQgMCxaPXZvaWQgMDtRPyh0aGlzLmNsZWFyVGltZW91dChWKSxVLmlzRW50cm9weT9xPShVLmRlbGF5LSh0aGlzLmVudHJvcHktUS5zdGFydEVudHJvcHkpKS9NYXRoLmFicyh0aGlzLnBsYXliYWNrUmF0ZSk6cT0oVS5kZWxheS0odGhpcy5jdXJyZW50VGltZS1RLnN0YXJ0VGltZSkpL3RoaXMucGxheWJhY2tSYXRlLEg9US5zdGFydFRpbWUsWj1RLnN0YXJ0RW50cm9weSk6KHE9VS5kZWxheS8oVS5pc0VudHJvcHk/TWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnRoaXMucGxheWJhY2tSYXRlKSxIPXRoaXMuY3VycmVudFRpbWUsWj10aGlzLmVudHJvcHkpO3ZhciB0dD10aGlzW09dLF89dHQ/dHQuc2V0VGltZW91dC5iaW5kKHR0KTpzZXRUaW1lb3V0LHN0PVUuaGVhZGluZztyZXR1cm4hdHQmJnN0PT09ITEmJnE8MCYmKHE9MS8wKSwoaXNGaW5pdGUocSl8fHR0KSYmKHE9TWF0aC5jZWlsKHEpLF8hPT1zZXRUaW1lb3V0JiYocT17ZGVsYXk6cSxoZWFkaW5nOnN0fSksVz1fKGZ1bmN0aW9uKCl7S1tQXS5kZWxldGUoViksQSgpfSxxKSksdGhpc1tQXS5zZXQoVix7dGltZXJJRDpXLGhhbmRsZXI6QSx0aW1lOlUsc3RhcnRUaW1lOkgsc3RhcnRFbnRyb3B5Olp9KSxWfX0se2tleToicGFyZW50IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tPXX19LHtrZXk6Imxhc3RUaW1lTWFyayIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbc11bdGhpc1tzXS5sZW5ndGgtMV19fSx7a2V5OiJjdXJyZW50VGltZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEE9dGhpcy5sYXN0VGltZU1hcmssVT1BLmxvY2FsVGltZSxLPUEuZ2xvYmFsVGltZTtyZXR1cm4gVSsodGhpcy5nbG9iYWxUaW1lLUspKnRoaXMucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oQSl7dmFyIFU9dGhpcyxLPXRoaXMuY3VycmVudFRpbWUsVj1BLFE9dGhpc1tQXTt0aGlzLm1hcmtUaW1lKHt0aW1lOkF9KSxbXS5jb25jYXQoKDAsVC5kZWZhdWx0KShRKSkuZm9yRWFjaChmdW5jdGlvbihxKXt2YXIgVz0oMCxvLmRlZmF1bHQpKHEsMiksSD1XWzBdLFo9V1sxXTtpZihRLmhhcyhIKSl7dmFyIHR0PVoudGltZSxfPXR0LmlzRW50cm9weSxzdD10dC5kZWxheSxrPXR0LmhlYWRpbmcsY3Q9Wi5oYW5kbGVyLGZ0PVouc3RhcnRUaW1lO2lmKF8pc3Q9PT0wJiYoY3QoKSxVLmNsZWFyVGltZW91dChIKSk7ZWxzZXt2YXIgQj1mdCtzdDsoc3Q9PT0wfHxrIT09ITEmJihWLUspKnN0PD0wfHxLPD1CJiZCPD1WfHxLPj1CJiZCPj1WKSYmKGN0KCksVS5jbGVhclRpbWVvdXQoSCkpfX19KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEE9dGhpcy5sYXN0VGltZU1hcmssVT1BLmVudHJvcHksSz1BLmdsb2JhbEVudHJvcHk7cmV0dXJuIFUrTWF0aC5hYnMoKHRoaXMuZ2xvYmFsRW50cm9weS1LKSp0aGlzLnBsYXliYWNrUmF0ZSl9LHNldDpmdW5jdGlvbihBKXtpZih0aGlzLmVudHJvcHk+QSl7dmFyIFU9dGhpcy5zZWVrVGltZU1hcmsoQSk7dGhpc1tzXS5sZW5ndGg9VSsxfXRoaXMubWFya1RpbWUoe2VudHJvcHk6QX0pLHRoaXMudXBkYXRlVGltZXJzKCl9fSx7a2V5OiJnbG9iYWxFbnRyb3B5IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tPXT90aGlzW09dLmVudHJvcHk6dGhpcy5nbG9iYWxUaW1lfX0se2tleToicGxheWJhY2tSYXRlIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tNXX0sc2V0OmZ1bmN0aW9uKEEpe0EhPT10aGlzLnBsYXliYWNrUmF0ZSYmKHRoaXMubWFya1RpbWUoe3BsYXliYWNrUmF0ZTpBfSksdGhpc1tNXT1BLHRoaXMudXBkYXRlVGltZXJzKCkpfX0se2tleToicGF1c2VkIixnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7Zm9yKHZhciBBPXRoaXMucGFyZW50O0E7KXtpZihBLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7QT1BLnBhcmVudH1yZXR1cm4hMX19XSksSX0oKTtlLmRlZmF1bHQ9RH0sZnVuY3Rpb24oTCxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgYT10KDc3KSxvPWQoYSksdj10KDEyOSksVD1kKHYpO2Z1bmN0aW9uIGQodSl7cmV0dXJuIHUmJnUuX19lc01vZHVsZT91OntkZWZhdWx0OnV9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHUoYyxFKXt2YXIgZj1bXSxnPSEwLHk9ITEsQz12b2lkIDA7dHJ5e2Zvcih2YXIgeD0oMCxULmRlZmF1bHQpKGMpLGg7IShnPShoPXgubmV4dCgpKS5kb25lKSYmKGYucHVzaChoLnZhbHVlKSwhKEUmJmYubGVuZ3RoPT09RSkpO2c9ITApO31jYXRjaChtKXt5PSEwLEM9bX1maW5hbGx5e3RyeXshZyYmeC5yZXR1cm4mJngucmV0dXJuKCl9ZmluYWxseXtpZih5KXRocm93IEN9fXJldHVybiBmfXJldHVybiBmdW5jdGlvbihjLEUpe2lmKEFycmF5LmlzQXJyYXkoYykpcmV0dXJuIGM7aWYoKDAsby5kZWZhdWx0KShPYmplY3QoYykpKXJldHVybiB1KGMsRSk7dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZSIpfX0oKX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz17ZGVmYXVsdDp0KDc4KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oTCxlLHQpe3QoNzkpLHQoMTI1KSxMLmV4cG9ydHM9dCgxMjcpfSxmdW5jdGlvbihMLGUsdCl7dCg4MCk7Zm9yKHZhciBhPXQoOTEpLG89dCg5NSksdj10KDgzKSxUPXQoMTIyKSgidG9TdHJpbmdUYWciKSxkPSJDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LERPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCxTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCxUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCIuc3BsaXQoIiwiKSx1PTA7dTxkLmxlbmd0aDt1Kyspe3ZhciBjPWRbdV0sRT1hW2NdLGY9RSYmRS5wcm90b3R5cGU7ZiYmIWZbVF0mJm8oZixULGMpLHZbY109di5BcnJheX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDgxKSxvPXQoODIpLHY9dCg4MyksVD10KDg0KTtMLmV4cG9ydHM9dCg4OCkoQXJyYXksIkFycmF5IixmdW5jdGlvbihkLHUpe3RoaXMuX3Q9VChkKSx0aGlzLl9pPTAsdGhpcy5faz11fSxmdW5jdGlvbigpe3ZhciBkPXRoaXMuX3QsdT10aGlzLl9rLGM9dGhpcy5faSsrO3JldHVybiFkfHxjPj1kLmxlbmd0aD8odGhpcy5fdD12b2lkIDAsbygxKSk6dT09ImtleXMiP28oMCxjKTp1PT0idmFsdWVzIj9vKDAsZFtjXSk6bygwLFtjLGRbY11dKX0sInZhbHVlcyIpLHYuQXJndW1lbnRzPXYuQXJyYXksYSgia2V5cyIpLGEoInZhbHVlcyIpLGEoImVudHJpZXMiKX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ZnVuY3Rpb24oKXt9fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0LGEpe3JldHVybnt2YWx1ZTphLGRvbmU6ISF0fX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPXt9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg4NSksbz10KDg3KTtMLmV4cG9ydHM9ZnVuY3Rpb24odil7cmV0dXJuIGEobyh2KSl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg4Nik7TC5leHBvcnRzPU9iamVjdCgieiIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApP09iamVjdDpmdW5jdGlvbihvKXtyZXR1cm4gYShvKT09IlN0cmluZyI/by5zcGxpdCgiIik6T2JqZWN0KG8pfX0sZnVuY3Rpb24oTCxlKXt2YXIgdD17fS50b1N0cmluZztMLmV4cG9ydHM9ZnVuY3Rpb24oYSl7cmV0dXJuIHQuY2FsbChhKS5zbGljZSg4LC0xKX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHQ9PW51bGwpdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgIit0KTtyZXR1cm4gdH19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDg5KSxvPXQoOTApLHY9dCgxMDYpLFQ9dCg5NSksZD10KDgzKSx1PXQoMTA3KSxjPXQoMTIxKSxFPXQoMTIzKSxmPXQoMTIyKSgiaXRlcmF0b3IiKSxnPSEoW10ua2V5cyYmIm5leHQiaW5bXS5rZXlzKCkpLHk9IkBAaXRlcmF0b3IiLEM9ImtleXMiLHg9InZhbHVlcyIsaD1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtMLmV4cG9ydHM9ZnVuY3Rpb24obSxyLGksbixzLE0sUCl7dShpLHIsbik7dmFyIFM9ZnVuY3Rpb24oVyl7aWYoIWcmJlcgaW4gSSlyZXR1cm4gSVtXXTtzd2l0Y2goVyl7Y2FzZSBDOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgaSh0aGlzLFcpfTtjYXNlIHg6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBpKHRoaXMsVyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgaSh0aGlzLFcpfX0sYj1yKyIgSXRlcmF0b3IiLE89cz09eCxEPSExLEk9bS5wcm90b3R5cGUsUj1JW2ZdfHxJW3ldfHxzJiZJW3NdLEE9Unx8UyhzKSxVPXM/Tz9TKCJlbnRyaWVzIik6QTp2b2lkIDAsSz1yPT0iQXJyYXkiJiZJLmVudHJpZXN8fFIsVixRLHE7aWYoSyYmKHE9RShLLmNhbGwobmV3IG0pKSxxIT09T2JqZWN0LnByb3RvdHlwZSYmcS5uZXh0JiYoYyhxLGIsITApLCFhJiZ0eXBlb2YgcVtmXSE9ImZ1bmN0aW9uIiYmVChxLGYsaCkpKSxPJiZSJiZSLm5hbWUhPT14JiYoRD0hMCxBPWZ1bmN0aW9uKCl7cmV0dXJuIFIuY2FsbCh0aGlzKX0pLCghYXx8UCkmJihnfHxEfHwhSVtmXSkmJlQoSSxmLEEpLGRbcl09QSxkW2JdPWgscylpZihWPXt2YWx1ZXM6Tz9BOlMoeCksa2V5czpNP0E6UyhDKSxlbnRyaWVzOlV9LFApZm9yKFEgaW4gVilRIGluIEl8fHYoSSxRLFZbUV0pO2Vsc2UgbyhvLlArby5GKihnfHxEKSxyLFYpO3JldHVybiBWfX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ITB9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkxKSxvPXQoOTIpLHY9dCg5MyksVD10KDk1KSxkPXQoMTA1KSx1PSJwcm90b3R5cGUiLGM9ZnVuY3Rpb24oRSxmLGcpe3ZhciB5PUUmYy5GLEM9RSZjLkcseD1FJmMuUyxoPUUmYy5QLG09RSZjLkIscj1FJmMuVyxpPUM/bzpvW2ZdfHwob1tmXT17fSksbj1pW3VdLHM9Qz9hOng/YVtmXTooYVtmXXx8e30pW3VdLE0sUCxTO0MmJihnPWYpO2ZvcihNIGluIGcpUD0heSYmcyYmc1tNXSE9PXZvaWQgMCwhKFAmJmQoaSxNKSkmJihTPVA/c1tNXTpnW01dLGlbTV09QyYmdHlwZW9mIHNbTV0hPSJmdW5jdGlvbiI/Z1tNXTptJiZQP3YoUyxhKTpyJiZzW01dPT1TP2Z1bmN0aW9uKGIpe3ZhciBPPWZ1bmN0aW9uKEQsSSxSKXtpZih0aGlzIGluc3RhbmNlb2YgYil7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IGI7Y2FzZSAxOnJldHVybiBuZXcgYihEKTtjYXNlIDI6cmV0dXJuIG5ldyBiKEQsSSl9cmV0dXJuIG5ldyBiKEQsSSxSKX1yZXR1cm4gYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3JldHVybiBPW3VdPWJbdV0sT30oUyk6aCYmdHlwZW9mIFM9PSJmdW5jdGlvbiI/dihGdW5jdGlvbi5jYWxsLFMpOlMsaCYmKChpLnZpcnR1YWx8fChpLnZpcnR1YWw9e30pKVtNXT1TLEUmYy5SJiZuJiYhbltNXSYmVChuLE0sUykpKX07Yy5GPTEsYy5HPTIsYy5TPTQsYy5QPTgsYy5CPTE2LGMuVz0zMixjLlU9NjQsYy5SPTEyOCxMLmV4cG9ydHM9Y30sZnVuY3Rpb24oTCxlKXt2YXIgdD1MLmV4cG9ydHM9dHlwZW9mIHdpbmRvdzwidSImJndpbmRvdy5NYXRoPT1NYXRoP3dpbmRvdzp0eXBlb2Ygc2VsZjwidSImJnNlbGYuTWF0aD09TWF0aD9zZWxmOkZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCk7dHlwZW9mIF9fZz09Im51bWJlciImJihfX2c9dCl9LGZ1bmN0aW9uKEwsZSl7dmFyIHQ9TC5leHBvcnRzPXt2ZXJzaW9uOiIyLjYuMTEifTt0eXBlb2YgX19lPT0ibnVtYmVyIiYmKF9fZT10KX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTQpO0wuZXhwb3J0cz1mdW5jdGlvbihvLHYsVCl7aWYoYShvKSx2PT09dm9pZCAwKXJldHVybiBvO3N3aXRjaChUKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiBvLmNhbGwodixkKX07Y2FzZSAyOnJldHVybiBmdW5jdGlvbihkLHUpe3JldHVybiBvLmNhbGwodixkLHUpfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKGQsdSxjKXtyZXR1cm4gby5jYWxsKHYsZCx1LGMpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gby5hcHBseSh2LGFyZ3VtZW50cyl9fX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodHlwZW9mIHQhPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKHQrIiBpcyBub3QgYSBmdW5jdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk2KSxvPXQoMTA0KTtMLmV4cG9ydHM9dCgxMDApP2Z1bmN0aW9uKHYsVCxkKXtyZXR1cm4gYS5mKHYsVCxvKDEsZCkpfTpmdW5jdGlvbih2LFQsZCl7cmV0dXJuIHZbVF09ZCx2fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTcpLG89dCg5OSksdj10KDEwMyksVD1PYmplY3QuZGVmaW5lUHJvcGVydHk7ZS5mPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24odSxjLEUpe2lmKGEodSksYz12KGMsITApLGEoRSksbyl0cnl7cmV0dXJuIFQodSxjLEUpfWNhdGNoe31pZigiZ2V0ImluIEV8fCJzZXQiaW4gRSl0aHJvdyBUeXBlRXJyb3IoIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkISIpO3JldHVybiJ2YWx1ZSJpbiBFJiYodVtjXT1FLnZhbHVlKSx1fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTgpO0wuZXhwb3J0cz1mdW5jdGlvbihvKXtpZighYShvKSl0aHJvdyBUeXBlRXJyb3IobysiIGlzIG5vdCBhbiBvYmplY3QhIik7cmV0dXJuIG99fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJvYmplY3QiP3QhPT1udWxsOnR5cGVvZiB0PT0iZnVuY3Rpb24ifX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz0hdCgxMDApJiYhdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0KDEwMikoImRpdiIpLCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPSF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2h7cmV0dXJuITB9fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTgpLG89dCg5MSkuZG9jdW1lbnQsdj1hKG8pJiZhKG8uY3JlYXRlRWxlbWVudCk7TC5leHBvcnRzPWZ1bmN0aW9uKFQpe3JldHVybiB2P28uY3JlYXRlRWxlbWVudChUKTp7fX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk4KTtMLmV4cG9ydHM9ZnVuY3Rpb24obyx2KXtpZighYShvKSlyZXR1cm4gbzt2YXIgVCxkO2lmKHYmJnR5cGVvZihUPW8udG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhYShkPVQuY2FsbChvKSl8fHR5cGVvZihUPW8udmFsdWVPZik9PSJmdW5jdGlvbiImJiFhKGQ9VC5jYWxsKG8pKXx8IXYmJnR5cGVvZihUPW8udG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhYShkPVQuY2FsbChvKSkpcmV0dXJuIGQ7dGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPWZ1bmN0aW9uKHQsYSl7cmV0dXJue2VudW1lcmFibGU6ISh0JjEpLGNvbmZpZ3VyYWJsZTohKHQmMiksd3JpdGFibGU6ISh0JjQpLHZhbHVlOmF9fX0sZnVuY3Rpb24oTCxlKXt2YXIgdD17fS5oYXNPd25Qcm9wZXJ0eTtMLmV4cG9ydHM9ZnVuY3Rpb24oYSxvKXtyZXR1cm4gdC5jYWxsKGEsbyl9fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXQoOTUpfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMDgpLG89dCgxMDQpLHY9dCgxMjEpLFQ9e307dCg5NSkoVCx0KDEyMikoIml0ZXJhdG9yIiksZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLEwuZXhwb3J0cz1mdW5jdGlvbihkLHUsYyl7ZC5wcm90b3R5cGU9YShULHtuZXh0Om8oMSxjKX0pLHYoZCx1KyIgSXRlcmF0b3IiKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk3KSxvPXQoMTA5KSx2PXQoMTE5KSxUPXQoMTE2KSgiSUVfUFJPVE8iKSxkPWZ1bmN0aW9uKCl7fSx1PSJwcm90b3R5cGUiLGM9ZnVuY3Rpb24oKXt2YXIgRT10KDEwMikoImlmcmFtZSIpLGY9di5sZW5ndGgsZz0iPCIseT0iPiIsQztmb3IoRS5zdHlsZS5kaXNwbGF5PSJub25lIix0KDEyMCkuYXBwZW5kQ2hpbGQoRSksRS5zcmM9ImphdmFzY3JpcHQ6IixDPUUuY29udGVudFdpbmRvdy5kb2N1bWVudCxDLm9wZW4oKSxDLndyaXRlKGcrInNjcmlwdCIreSsiZG9jdW1lbnQuRj1PYmplY3QiK2crIi9zY3JpcHQiK3kpLEMuY2xvc2UoKSxjPUMuRjtmLS07KWRlbGV0ZSBjW3VdW3ZbZl1dO3JldHVybiBjKCl9O0wuZXhwb3J0cz1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbihmLGcpe3ZhciB5O3JldHVybiBmIT09bnVsbD8oZFt1XT1hKGYpLHk9bmV3IGQsZFt1XT1udWxsLHlbVF09Zik6eT1jKCksZz09PXZvaWQgMD95Om8oeSxnKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk2KSxvPXQoOTcpLHY9dCgxMTApO0wuZXhwb3J0cz10KDEwMCk/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24oZCx1KXtvKGQpO2Zvcih2YXIgYz12KHUpLEU9Yy5sZW5ndGgsZj0wLGc7RT5mOylhLmYoZCxnPWNbZisrXSx1W2ddKTtyZXR1cm4gZH19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDExMSksbz10KDExOSk7TC5leHBvcnRzPU9iamVjdC5rZXlzfHxmdW5jdGlvbihUKXtyZXR1cm4gYShULG8pfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTA1KSxvPXQoODQpLHY9dCgxMTIpKCExKSxUPXQoMTE2KSgiSUVfUFJPVE8iKTtMLmV4cG9ydHM9ZnVuY3Rpb24oZCx1KXt2YXIgYz1vKGQpLEU9MCxmPVtdLGc7Zm9yKGcgaW4gYylnIT1UJiZhKGMsZykmJmYucHVzaChnKTtmb3IoO3UubGVuZ3RoPkU7KWEoYyxnPXVbRSsrXSkmJih+dihmLGcpfHxmLnB1c2goZykpO3JldHVybiBmfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoODQpLG89dCgxMTMpLHY9dCgxMTUpO0wuZXhwb3J0cz1mdW5jdGlvbihUKXtyZXR1cm4gZnVuY3Rpb24oZCx1LGMpe3ZhciBFPWEoZCksZj1vKEUubGVuZ3RoKSxnPXYoYyxmKSx5O2lmKFQmJnUhPXUpe2Zvcig7Zj5nOylpZih5PUVbZysrXSx5IT15KXJldHVybiEwfWVsc2UgZm9yKDtmPmc7ZysrKWlmKChUfHxnIGluIEUpJiZFW2ddPT09dSlyZXR1cm4gVHx8Z3x8MDtyZXR1cm4hVCYmLTF9fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTE0KSxvPU1hdGgubWluO0wuZXhwb3J0cz1mdW5jdGlvbih2KXtyZXR1cm4gdj4wP28oYSh2KSw5MDA3MTk5MjU0NzQwOTkxKTowfX0sZnVuY3Rpb24oTCxlKXt2YXIgdD1NYXRoLmNlaWwsYT1NYXRoLmZsb29yO0wuZXhwb3J0cz1mdW5jdGlvbihvKXtyZXR1cm4gaXNOYU4obz0rbyk/MDoobz4wP2E6dCkobyl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMTQpLG89TWF0aC5tYXgsdj1NYXRoLm1pbjtMLmV4cG9ydHM9ZnVuY3Rpb24oVCxkKXtyZXR1cm4gVD1hKFQpLFQ8MD9vKFQrZCwwKTp2KFQsZCl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMTcpKCJrZXlzIiksbz10KDExOCk7TC5leHBvcnRzPWZ1bmN0aW9uKHYpe3JldHVybiBhW3ZdfHwoYVt2XT1vKHYpKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkyKSxvPXQoOTEpLHY9Il9fY29yZS1qc19zaGFyZWRfXyIsVD1vW3ZdfHwob1t2XT17fSk7KEwuZXhwb3J0cz1mdW5jdGlvbihkLHUpe3JldHVybiBUW2RdfHwoVFtkXT11IT09dm9pZCAwP3U6e30pfSkoInZlcnNpb25zIixbXSkucHVzaCh7dmVyc2lvbjphLnZlcnNpb24sbW9kZTp0KDg5KT8icHVyZSI6Imdsb2JhbCIsY29weXJpZ2h0OiLCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpIn0pfSxmdW5jdGlvbihMLGUpe3ZhciB0PTAsYT1NYXRoLnJhbmRvbSgpO0wuZXhwb3J0cz1mdW5jdGlvbihvKXtyZXR1cm4iU3ltYm9sKCIuY29uY2F0KG89PT12b2lkIDA/IiI6bywiKV8iLCgrK3QrYSkudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPSJjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YiLnNwbGl0KCIsIil9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkxKS5kb2N1bWVudDtMLmV4cG9ydHM9YSYmYS5kb2N1bWVudEVsZW1lbnR9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk2KS5mLG89dCgxMDUpLHY9dCgxMjIpKCJ0b1N0cmluZ1RhZyIpO0wuZXhwb3J0cz1mdW5jdGlvbihULGQsdSl7VCYmIW8oVD11P1Q6VC5wcm90b3R5cGUsdikmJmEoVCx2LHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZH0pfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTE3KSgid2tzIiksbz10KDExOCksdj10KDkxKS5TeW1ib2wsVD10eXBlb2Ygdj09ImZ1bmN0aW9uIixkPUwuZXhwb3J0cz1mdW5jdGlvbih1KXtyZXR1cm4gYVt1XXx8KGFbdV09VCYmdlt1XXx8KFQ/djpvKSgiU3ltYm9sLiIrdSkpfTtkLnN0b3JlPWF9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDEwNSksbz10KDEyNCksdj10KDExNikoIklFX1BST1RPIiksVD1PYmplY3QucHJvdG90eXBlO0wuZXhwb3J0cz1PYmplY3QuZ2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGQpe3JldHVybiBkPW8oZCksYShkLHYpP2Rbdl06dHlwZW9mIGQuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJmQgaW5zdGFuY2VvZiBkLmNvbnN0cnVjdG9yP2QuY29uc3RydWN0b3IucHJvdG90eXBlOmQgaW5zdGFuY2VvZiBPYmplY3Q/VDpudWxsfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoODcpO0wuZXhwb3J0cz1mdW5jdGlvbihvKXtyZXR1cm4gT2JqZWN0KGEobykpfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTI2KSghMCk7dCg4OCkoU3RyaW5nLCJTdHJpbmciLGZ1bmN0aW9uKG8pe3RoaXMuX3Q9U3RyaW5nKG8pLHRoaXMuX2k9MH0sZnVuY3Rpb24oKXt2YXIgbz10aGlzLl90LHY9dGhpcy5faSxUO3JldHVybiB2Pj1vLmxlbmd0aD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9OihUPWEobyx2KSx0aGlzLl9pKz1ULmxlbmd0aCx7dmFsdWU6VCxkb25lOiExfSl9KX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTE0KSxvPXQoODcpO0wuZXhwb3J0cz1mdW5jdGlvbih2KXtyZXR1cm4gZnVuY3Rpb24oVCxkKXt2YXIgdT1TdHJpbmcobyhUKSksYz1hKGQpLEU9dS5sZW5ndGgsZixnO3JldHVybiBjPDB8fGM+PUU/dj8iIjp2b2lkIDA6KGY9dS5jaGFyQ29kZUF0KGMpLGY8NTUyOTZ8fGY+NTYzMTl8fGMrMT09PUV8fChnPXUuY2hhckNvZGVBdChjKzEpKTw1NjMyMHx8Zz41NzM0Mz92P3UuY2hhckF0KGMpOmY6dj91LnNsaWNlKGMsYysyKTooZi01NTI5Njw8MTApKyhnLTU2MzIwKSs2NTUzNil9fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTI4KSxvPXQoMTIyKSgiaXRlcmF0b3IiKSx2PXQoODMpO0wuZXhwb3J0cz10KDkyKS5pc0l0ZXJhYmxlPWZ1bmN0aW9uKFQpe3ZhciBkPU9iamVjdChUKTtyZXR1cm4gZFtvXSE9PXZvaWQgMHx8IkBAaXRlcmF0b3IiaW4gZHx8di5oYXNPd25Qcm9wZXJ0eShhKGQpKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDg2KSxvPXQoMTIyKSgidG9TdHJpbmdUYWciKSx2PWEoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT09IkFyZ3VtZW50cyIsVD1mdW5jdGlvbihkLHUpe3RyeXtyZXR1cm4gZFt1XX1jYXRjaHt9fTtMLmV4cG9ydHM9ZnVuY3Rpb24oZCl7dmFyIHUsYyxFO3JldHVybiBkPT09dm9pZCAwPyJVbmRlZmluZWQiOmQ9PT1udWxsPyJOdWxsIjp0eXBlb2YoYz1UKHU9T2JqZWN0KGQpLG8pKT09InN0cmluZyI/Yzp2P2EodSk6KEU9YSh1KSk9PSJPYmplY3QiJiZ0eXBlb2YgdS5jYWxsZWU9PSJmdW5jdGlvbiI/IkFyZ3VtZW50cyI6RX19LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihMLGUsdCl7dCg3OSksdCgxMjUpLEwuZXhwb3J0cz10KDEzMSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk3KSxvPXQoMTMyKTtMLmV4cG9ydHM9dCg5MikuZ2V0SXRlcmF0b3I9ZnVuY3Rpb24odil7dmFyIFQ9byh2KTtpZih0eXBlb2YgVCE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IodisiIGlzIG5vdCBpdGVyYWJsZSEiKTtyZXR1cm4gYShULmNhbGwodikpfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTI4KSxvPXQoMTIyKSgiaXRlcmF0b3IiKSx2PXQoODMpO0wuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvck1ldGhvZD1mdW5jdGlvbihUKXtpZihUIT1udWxsKXJldHVybiBUW29dfHxUWyJAQGl0ZXJhdG9yIl18fHZbYShUKV19fSxmdW5jdGlvbihMLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciBhPXQoMTM0KSxvPXYoYSk7ZnVuY3Rpb24gdihUKXtyZXR1cm4gVCYmVC5fX2VzTW9kdWxlP1Q6e2RlZmF1bHQ6VH19ZS5kZWZhdWx0PWZ1bmN0aW9uKFQpe2lmKEFycmF5LmlzQXJyYXkoVCkpe2Zvcih2YXIgZD0wLHU9QXJyYXkoVC5sZW5ndGgpO2Q8VC5sZW5ndGg7ZCsrKXVbZF09VFtkXTtyZXR1cm4gdX1lbHNlIHJldHVybigwLG8uZGVmYXVsdCkoVCl9fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXtkZWZhdWx0OnQoMTM1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oTCxlLHQpe3QoMTI1KSx0KDEzNiksTC5leHBvcnRzPXQoOTIpLkFycmF5LmZyb219LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkzKSxvPXQoOTApLHY9dCgxMjQpLFQ9dCgxMzcpLGQ9dCgxMzgpLHU9dCgxMTMpLGM9dCgxMzkpLEU9dCgxMzIpO28oby5TK28uRiohdCgxNDApKGZ1bmN0aW9uKGYpe0FycmF5LmZyb20oZil9KSwiQXJyYXkiLHtmcm9tOmZ1bmN0aW9uKGcpe3ZhciB5PXYoZyksQz10eXBlb2YgdGhpcz09ImZ1bmN0aW9uIj90aGlzOkFycmF5LHg9YXJndW1lbnRzLmxlbmd0aCxoPXg+MT9hcmd1bWVudHNbMV06dm9pZCAwLG09aCE9PXZvaWQgMCxyPTAsaT1FKHkpLG4scyxNLFA7aWYobSYmKGg9YShoLHg+Mj9hcmd1bWVudHNbMl06dm9pZCAwLDIpKSxpIT1udWxsJiYhKEM9PUFycmF5JiZkKGkpKSlmb3IoUD1pLmNhbGwoeSkscz1uZXcgQzshKE09UC5uZXh0KCkpLmRvbmU7cisrKWMocyxyLG0/VChQLGgsW00udmFsdWUscl0sITApOk0udmFsdWUpO2Vsc2UgZm9yKG49dSh5Lmxlbmd0aCkscz1uZXcgQyhuKTtuPnI7cisrKWMocyxyLG0/aCh5W3JdLHIpOnlbcl0pO3JldHVybiBzLmxlbmd0aD1yLHN9fSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk3KTtMLmV4cG9ydHM9ZnVuY3Rpb24obyx2LFQsZCl7dHJ5e3JldHVybiBkP3YoYShUKVswXSxUWzFdKTp2KFQpfWNhdGNoKGMpe3ZhciB1PW8ucmV0dXJuO3Rocm93IHUhPT12b2lkIDAmJmEodS5jYWxsKG8pKSxjfX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDgzKSxvPXQoMTIyKSgiaXRlcmF0b3IiKSx2PUFycmF5LnByb3RvdHlwZTtMLmV4cG9ydHM9ZnVuY3Rpb24oVCl7cmV0dXJuIFQhPT12b2lkIDAmJihhLkFycmF5PT09VHx8dltvXT09PVQpfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTYpLG89dCgxMDQpO0wuZXhwb3J0cz1mdW5jdGlvbih2LFQsZCl7VCBpbiB2P2EuZih2LFQsbygwLGQpKTp2W1RdPWR9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMjIpKCJpdGVyYXRvciIpLG89ITE7dHJ5e3ZhciB2PVs3XVthXSgpO3YucmV0dXJuPWZ1bmN0aW9uKCl7bz0hMH0sQXJyYXkuZnJvbSh2LGZ1bmN0aW9uKCl7dGhyb3cgMn0pfWNhdGNoe31MLmV4cG9ydHM9ZnVuY3Rpb24oVCxkKXtpZighZCYmIW8pcmV0dXJuITE7dmFyIHU9ITE7dHJ5e3ZhciBjPVs3XSxFPWNbYV0oKTtFLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTp1PSEwfX0sY1thXT1mdW5jdGlvbigpe3JldHVybiBFfSxUKGMpfWNhdGNoe31yZXR1cm4gdX19LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNDIpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihMLGUsdCl7dCgxNDMpLHQoMTI1KSx0KDc5KSx0KDE0NCksdCgxNTcpLHQoMTYwKSx0KDE2MiksTC5leHBvcnRzPXQoOTIpLk1hcH0sZnVuY3Rpb24oTCxlKXt9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDE0NSksbz10KDE1MSksdj0iTWFwIjtMLmV4cG9ydHM9dCgxNTIpKHYsZnVuY3Rpb24oVCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIFQodGhpcyxhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSx7Z2V0OmZ1bmN0aW9uKGQpe3ZhciB1PWEuZ2V0RW50cnkobyh0aGlzLHYpLGQpO3JldHVybiB1JiZ1LnZ9LHNldDpmdW5jdGlvbihkLHUpe3JldHVybiBhLmRlZihvKHRoaXMsdiksZD09PTA/MDpkLHUpfX0sYSwhMCl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk2KS5mLG89dCgxMDgpLHY9dCgxNDYpLFQ9dCg5MyksZD10KDE0NyksdT10KDE0OCksYz10KDg4KSxFPXQoODIpLGY9dCgxNDkpLGc9dCgxMDApLHk9dCgxNTApLmZhc3RLZXksQz10KDE1MSkseD1nPyJfcyI6InNpemUiLGg9ZnVuY3Rpb24obSxyKXt2YXIgaT15KHIpLG47aWYoaSE9PSJGIilyZXR1cm4gbS5faVtpXTtmb3Iobj1tLl9mO247bj1uLm4paWYobi5rPT1yKXJldHVybiBufTtMLmV4cG9ydHM9e2dldENvbnN0cnVjdG9yOmZ1bmN0aW9uKG0scixpLG4pe3ZhciBzPW0oZnVuY3Rpb24oTSxQKXtkKE0scyxyLCJfaSIpLE0uX3Q9cixNLl9pPW8obnVsbCksTS5fZj12b2lkIDAsTS5fbD12b2lkIDAsTVt4XT0wLFAhPW51bGwmJnUoUCxpLE1bbl0sTSl9KTtyZXR1cm4gdihzLnByb3RvdHlwZSx7Y2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIFA9Qyh0aGlzLHIpLFM9UC5faSxiPVAuX2Y7YjtiPWIubiliLnI9ITAsYi5wJiYoYi5wPWIucC5uPXZvaWQgMCksZGVsZXRlIFNbYi5pXTtQLl9mPVAuX2w9dm9pZCAwLFBbeF09MH0sZGVsZXRlOmZ1bmN0aW9uKE0pe3ZhciBQPUModGhpcyxyKSxTPWgoUCxNKTtpZihTKXt2YXIgYj1TLm4sTz1TLnA7ZGVsZXRlIFAuX2lbUy5pXSxTLnI9ITAsTyYmKE8ubj1iKSxiJiYoYi5wPU8pLFAuX2Y9PVMmJihQLl9mPWIpLFAuX2w9PVMmJihQLl9sPU8pLFBbeF0tLX1yZXR1cm4hIVN9LGZvckVhY2g6ZnVuY3Rpb24oUCl7Qyh0aGlzLHIpO2Zvcih2YXIgUz1UKFAsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyksYjtiPWI/Yi5uOnRoaXMuX2Y7KWZvcihTKGIudixiLmssdGhpcyk7YiYmYi5yOyliPWIucH0saGFzOmZ1bmN0aW9uKFApe3JldHVybiEhaChDKHRoaXMsciksUCl9fSksZyYmYShzLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBDKHRoaXMscilbeF19fSksc30sZGVmOmZ1bmN0aW9uKG0scixpKXt2YXIgbj1oKG0scikscyxNO3JldHVybiBuP24udj1pOihtLl9sPW49e2k6TT15KHIsITApLGs6cix2OmkscDpzPW0uX2wsbjp2b2lkIDAscjohMX0sbS5fZnx8KG0uX2Y9bikscyYmKHMubj1uKSxtW3hdKyssTSE9PSJGIiYmKG0uX2lbTV09bikpLG19LGdldEVudHJ5Omgsc2V0U3Ryb25nOmZ1bmN0aW9uKG0scixpKXtjKG0scixmdW5jdGlvbihuLHMpe3RoaXMuX3Q9QyhuLHIpLHRoaXMuX2s9cyx0aGlzLl9sPXZvaWQgMH0sZnVuY3Rpb24oKXtmb3IodmFyIG49dGhpcyxzPW4uX2ssTT1uLl9sO00mJk0ucjspTT1NLnA7cmV0dXJuIW4uX3R8fCEobi5fbD1NPU0/TS5uOm4uX3QuX2YpPyhuLl90PXZvaWQgMCxFKDEpKTpzPT0ia2V5cyI/RSgwLE0uayk6cz09InZhbHVlcyI/RSgwLE0udik6RSgwLFtNLmssTS52XSl9LGk/ImVudHJpZXMiOiJ2YWx1ZXMiLCFpLCEwKSxmKHIpfX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk1KTtMLmV4cG9ydHM9ZnVuY3Rpb24obyx2LFQpe2Zvcih2YXIgZCBpbiB2KVQmJm9bZF0/b1tkXT12W2RdOmEobyxkLHZbZF0pO3JldHVybiBvfX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ZnVuY3Rpb24odCxhLG8sdil7aWYoISh0IGluc3RhbmNlb2YgYSl8fHYhPT12b2lkIDAmJnYgaW4gdCl0aHJvdyBUeXBlRXJyb3IobysiOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKEwsZix0KXt2YXIgYT10KDkzKSxvPXQoMTM3KSx2PXQoMTM4KSxUPXQoOTcpLGQ9dCgxMTMpLHU9dCgxMzIpLGM9e30sRT17fSxmPUwuZXhwb3J0cz1mdW5jdGlvbihnLHksQyx4LGgpe3ZhciBtPWg/ZnVuY3Rpb24oKXtyZXR1cm4gZ306dShnKSxyPWEoQyx4LHk/MjoxKSxpPTAsbixzLE0sUDtpZih0eXBlb2YgbSE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IoZysiIGlzIG5vdCBpdGVyYWJsZSEiKTtpZih2KG0pKXtmb3Iobj1kKGcubGVuZ3RoKTtuPmk7aSsrKWlmKFA9eT9yKFQocz1nW2ldKVswXSxzWzFdKTpyKGdbaV0pLFA9PT1jfHxQPT09RSlyZXR1cm4gUH1lbHNlIGZvcihNPW0uY2FsbChnKTshKHM9TS5uZXh0KCkpLmRvbmU7KWlmKFA9byhNLHIscy52YWx1ZSx5KSxQPT09Y3x8UD09PUUpcmV0dXJuIFB9O2YuQlJFQUs9YyxmLlJFVFVSTj1FfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MSksbz10KDkyKSx2PXQoOTYpLFQ9dCgxMDApLGQ9dCgxMjIpKCJzcGVjaWVzIik7TC5leHBvcnRzPWZ1bmN0aW9uKHUpe3ZhciBjPXR5cGVvZiBvW3VdPT0iZnVuY3Rpb24iP29bdV06YVt1XTtUJiZjJiYhY1tkXSYmdi5mKGMsZCx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzfX0pfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTE4KSgibWV0YSIpLG89dCg5OCksdj10KDEwNSksVD10KDk2KS5mLGQ9MCx1PU9iamVjdC5pc0V4dGVuc2libGV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LGM9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiB1KE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpfSksRT1mdW5jdGlvbih4KXtUKHgsYSx7dmFsdWU6e2k6Ik8iKyArK2Qsdzp7fX19KX0sZj1mdW5jdGlvbih4LGgpe2lmKCFvKHgpKXJldHVybiB0eXBlb2YgeD09InN5bWJvbCI/eDoodHlwZW9mIHg9PSJzdHJpbmciPyJTIjoiUCIpK3g7aWYoIXYoeCxhKSl7aWYoIXUoeCkpcmV0dXJuIkYiO2lmKCFoKXJldHVybiJFIjtFKHgpfXJldHVybiB4W2FdLml9LGc9ZnVuY3Rpb24oeCxoKXtpZighdih4LGEpKXtpZighdSh4KSlyZXR1cm4hMDtpZighaClyZXR1cm4hMTtFKHgpfXJldHVybiB4W2FdLnd9LHk9ZnVuY3Rpb24oeCl7cmV0dXJuIGMmJkMuTkVFRCYmdSh4KSYmIXYoeCxhKSYmRSh4KSx4fSxDPUwuZXhwb3J0cz17S0VZOmEsTkVFRDohMSxmYXN0S2V5OmYsZ2V0V2VhazpnLG9uRnJlZXplOnl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5OCk7TC5leHBvcnRzPWZ1bmN0aW9uKG8sdil7aWYoIWEobyl8fG8uX3QhPT12KXRocm93IFR5cGVFcnJvcigiSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAiK3YrIiByZXF1aXJlZCEiKTtyZXR1cm4gb319LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkxKSxvPXQoOTApLHY9dCgxNTApLFQ9dCgxMDEpLGQ9dCg5NSksdT10KDE0NiksYz10KDE0OCksRT10KDE0NyksZj10KDk4KSxnPXQoMTIxKSx5PXQoOTYpLmYsQz10KDE1MykoMCkseD10KDEwMCk7TC5leHBvcnRzPWZ1bmN0aW9uKGgsbSxyLGksbixzKXt2YXIgTT1hW2hdLFA9TSxTPW4/InNldCI6ImFkZCIsYj1QJiZQLnByb3RvdHlwZSxPPXt9O3JldHVybiF4fHx0eXBlb2YgUCE9ImZ1bmN0aW9uInx8IShzfHxiLmZvckVhY2gmJiFUKGZ1bmN0aW9uKCl7bmV3IFAoKS5lbnRyaWVzKCkubmV4dCgpfSkpPyhQPWkuZ2V0Q29uc3RydWN0b3IobSxoLG4sUyksdShQLnByb3RvdHlwZSxyKSx2Lk5FRUQ9ITApOihQPW0oZnVuY3Rpb24oRCxJKXtFKEQsUCxoLCJfYyIpLEQuX2M9bmV3IE0sSSE9bnVsbCYmYyhJLG4sRFtTXSxEKX0pLEMoImFkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTiIuc3BsaXQoIiwiKSxmdW5jdGlvbihEKXt2YXIgST1EPT0iYWRkInx8RD09InNldCI7RCBpbiBiJiYhKHMmJkQ9PSJjbGVhciIpJiZkKFAucHJvdG90eXBlLEQsZnVuY3Rpb24oUixBKXtpZihFKHRoaXMsUCxEKSwhSSYmcyYmIWYoUikpcmV0dXJuIEQ9PSJnZXQiP3ZvaWQgMDohMTt2YXIgVT10aGlzLl9jW0RdKFI9PT0wPzA6UixBKTtyZXR1cm4gST90aGlzOlV9KX0pLHN8fHkoUC5wcm90b3R5cGUsInNpemUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYy5zaXplfX0pKSxnKFAsaCksT1toXT1QLG8oby5HK28uVytvLkYsTyksc3x8aS5zZXRTdHJvbmcoUCxoLG4pLFB9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5Myksbz10KDg1KSx2PXQoMTI0KSxUPXQoMTEzKSxkPXQoMTU0KTtMLmV4cG9ydHM9ZnVuY3Rpb24odSxjKXt2YXIgRT11PT0xLGY9dT09MixnPXU9PTMseT11PT00LEM9dT09Nix4PXU9PTV8fEMsaD1jfHxkO3JldHVybiBmdW5jdGlvbihtLHIsaSl7Zm9yKHZhciBuPXYobSkscz1vKG4pLE09YShyLGksMyksUD1UKHMubGVuZ3RoKSxTPTAsYj1FP2gobSxQKTpmP2gobSwwKTp2b2lkIDAsTyxEO1A+UztTKyspaWYoKHh8fFMgaW4gcykmJihPPXNbU10sRD1NKE8sUyxuKSx1KSl7aWYoRSliW1NdPUQ7ZWxzZSBpZihEKXN3aXRjaCh1KXtjYXNlIDM6cmV0dXJuITA7Y2FzZSA1OnJldHVybiBPO2Nhc2UgNjpyZXR1cm4gUztjYXNlIDI6Yi5wdXNoKE8pfWVsc2UgaWYoeSlyZXR1cm4hMX1yZXR1cm4gQz8tMTpnfHx5P3k6Yn19fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxNTUpO0wuZXhwb3J0cz1mdW5jdGlvbihvLHYpe3JldHVybiBuZXcoYShvKSkodil9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5OCksbz10KDE1Niksdj10KDEyMikoInNwZWNpZXMiKTtMLmV4cG9ydHM9ZnVuY3Rpb24oVCl7dmFyIGQ7cmV0dXJuIG8oVCkmJihkPVQuY29uc3RydWN0b3IsdHlwZW9mIGQ9PSJmdW5jdGlvbiImJihkPT09QXJyYXl8fG8oZC5wcm90b3R5cGUpKSYmKGQ9dm9pZCAwKSxhKGQpJiYoZD1kW3ZdLGQ9PT1udWxsJiYoZD12b2lkIDApKSksZD09PXZvaWQgMD9BcnJheTpkfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoODYpO0wuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih2KXtyZXR1cm4gYSh2KT09IkFycmF5In19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkwKTthKGEuUCthLlIsIk1hcCIse3RvSlNPTjp0KDE1OCkoIk1hcCIpfSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDEyOCksbz10KDE1OSk7TC5leHBvcnRzPWZ1bmN0aW9uKHYpe3JldHVybiBmdW5jdGlvbigpe2lmKGEodGhpcykhPXYpdGhyb3cgVHlwZUVycm9yKHYrIiN0b0pTT04gaXNuJ3QgZ2VuZXJpYyIpO3JldHVybiBvKHRoaXMpfX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDE0OCk7TC5leHBvcnRzPWZ1bmN0aW9uKG8sdil7dmFyIFQ9W107cmV0dXJuIGEobywhMSxULnB1c2gsVCx2KSxUfX0sZnVuY3Rpb24oTCxlLHQpe3QoMTYxKSgiTWFwIil9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkwKTtMLmV4cG9ydHM9ZnVuY3Rpb24obyl7YShhLlMsbyx7b2Y6ZnVuY3Rpb24oKXtmb3IodmFyIFQ9YXJndW1lbnRzLmxlbmd0aCxkPW5ldyBBcnJheShUKTtULS07KWRbVF09YXJndW1lbnRzW1RdO3JldHVybiBuZXcgdGhpcyhkKX19KX19LGZ1bmN0aW9uKEwsZSx0KXt0KDE2MykoIk1hcCIpfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCksbz10KDk0KSx2PXQoOTMpLFQ9dCgxNDgpO0wuZXhwb3J0cz1mdW5jdGlvbihkKXthKGEuUyxkLHtmcm9tOmZ1bmN0aW9uKGMpe3ZhciBFPWFyZ3VtZW50c1sxXSxmLGcseSxDO3JldHVybiBvKHRoaXMpLGY9RSE9PXZvaWQgMCxmJiZvKEUpLGM9PW51bGw/bmV3IHRoaXM6KGc9W10sZj8oeT0wLEM9dihFLGFyZ3VtZW50c1syXSwyKSxUKGMsITEsZnVuY3Rpb24oeCl7Zy5wdXNoKEMoeCx5KyspKX0pKTpUKGMsITEsZy5wdXNoLGcpLG5ldyB0aGlzKGcpKX19KX19LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNjUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihMLGUsdCl7dCgxNjYpLEwuZXhwb3J0cz10KDkyKS5PYmplY3QuYXNzaWdufSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCk7YShhLlMrYS5GLCJPYmplY3QiLHthc3NpZ246dCgxNjcpfSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDEwMCksbz10KDExMCksdj10KDE2OCksVD10KDE2OSksZD10KDEyNCksdT10KDg1KSxjPU9iamVjdC5hc3NpZ247TC5leHBvcnRzPSFjfHx0KDEwMSkoZnVuY3Rpb24oKXt2YXIgRT17fSxmPXt9LGc9U3ltYm9sKCkseT0iYWJjZGVmZ2hpamtsbW5vcHFyc3QiO3JldHVybiBFW2ddPTcseS5zcGxpdCgiIikuZm9yRWFjaChmdW5jdGlvbihDKXtmW0NdPUN9KSxjKHt9LEUpW2ddIT03fHxPYmplY3Qua2V5cyhjKHt9LGYpKS5qb2luKCIiKSE9eX0pP2Z1bmN0aW9uKGYsZyl7Zm9yKHZhciB5PWQoZiksQz1hcmd1bWVudHMubGVuZ3RoLHg9MSxoPXYuZixtPVQuZjtDPng7KWZvcih2YXIgcj11KGFyZ3VtZW50c1t4KytdKSxpPWg/byhyKS5jb25jYXQoaChyKSk6byhyKSxuPWkubGVuZ3RoLHM9MCxNO24+czspTT1pW3MrK10sKCFhfHxtLmNhbGwocixNKSkmJih5W01dPXJbTV0pO3JldHVybiB5fTpjfSxmdW5jdGlvbihMLGUpe2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbihMLGUpe2UuZj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZX0sZnVuY3Rpb24oTCxlLHQpe2UuX19lc01vZHVsZT0hMCxlLmRlZmF1bHQ9ZnVuY3Rpb24oYSxvKXtpZighKGEgaW5zdGFuY2VvZiBvKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKX19LGZ1bmN0aW9uKEwsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIGE9dCgxNzIpLG89dihhKTtmdW5jdGlvbiB2KFQpe3JldHVybiBUJiZULl9fZXNNb2R1bGU/VDp7ZGVmYXVsdDpUfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBUKGQsdSl7Zm9yKHZhciBjPTA7Yzx1Lmxlbmd0aDtjKyspe3ZhciBFPXVbY107RS5lbnVtZXJhYmxlPUUuZW51bWVyYWJsZXx8ITEsRS5jb25maWd1cmFibGU9ITAsInZhbHVlImluIEUmJihFLndyaXRhYmxlPSEwKSwoMCxvLmRlZmF1bHQpKGQsRS5rZXksRSl9fXJldHVybiBmdW5jdGlvbihkLHUsYyl7cmV0dXJuIHUmJlQoZC5wcm90b3R5cGUsdSksYyYmVChkLGMpLGR9fSgpfSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXtkZWZhdWx0OnQoMTczKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oTCxlLHQpe3QoMTc0KTt2YXIgYT10KDkyKS5PYmplY3Q7TC5leHBvcnRzPWZ1bmN0aW9uKHYsVCxkKXtyZXR1cm4gYS5kZWZpbmVQcm9wZXJ0eSh2LFQsZCl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCk7YShhLlMrYS5GKiF0KDEwMCksIk9iamVjdCIse2RlZmluZVByb3BlcnR5OnQoOTYpLmZ9KX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz17ZGVmYXVsdDp0KDE3NiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKEwsZSx0KXt0KDE3NyksdCgxNDMpLHQoMTg0KSx0KDE4NSksTC5leHBvcnRzPXQoOTIpLlN5bWJvbH0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTEpLG89dCgxMDUpLHY9dCgxMDApLFQ9dCg5MCksZD10KDEwNiksdT10KDE1MCkuS0VZLGM9dCgxMDEpLEU9dCgxMTcpLGY9dCgxMjEpLGc9dCgxMTgpLHk9dCgxMjIpLEM9dCgxNzgpLHg9dCgxNzkpLGg9dCgxODApLG09dCgxNTYpLHI9dCg5NyksaT10KDk4KSxuPXQoMTI0KSxzPXQoODQpLE09dCgxMDMpLFA9dCgxMDQpLFM9dCgxMDgpLGI9dCgxODEpLE89dCgxODMpLEQ9dCgxNjgpLEk9dCg5NiksUj10KDExMCksQT1PLmYsVT1JLmYsSz1iLmYsVj1hLlN5bWJvbCxRPWEuSlNPTixxPVEmJlEuc3RyaW5naWZ5LFc9InByb3RvdHlwZSIsSD15KCJfaGlkZGVuIiksWj15KCJ0b1ByaW1pdGl2ZSIpLHR0PXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLF89RSgic3ltYm9sLXJlZ2lzdHJ5Iiksc3Q9RSgic3ltYm9scyIpLGs9RSgib3Atc3ltYm9scyIpLGN0PU9iamVjdFtXXSxmdD10eXBlb2YgVj09ImZ1bmN0aW9uIiYmISFELmYsQj1hLlFPYmplY3QsRj0hQnx8IUJbV118fCFCW1ddLmZpbmRDaGlsZCxZPXYmJmMoZnVuY3Rpb24oKXtyZXR1cm4gUyhVKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFUodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hIT03fSk/ZnVuY3Rpb24oaXQsbnQsb3Qpe3ZhciBodD1BKGN0LG50KTtodCYmZGVsZXRlIGN0W250XSxVKGl0LG50LG90KSxodCYmaXQhPT1jdCYmVShjdCxudCxodCl9OlUsSj1mdW5jdGlvbihpdCl7dmFyIG50PXN0W2l0XT1TKFZbV10pO3JldHVybiBudC5faz1pdCxudH0saj1mdCYmdHlwZW9mIFYuaXRlcmF0b3I9PSJzeW1ib2wiP2Z1bmN0aW9uKGl0KXtyZXR1cm4gdHlwZW9mIGl0PT0ic3ltYm9sIn06ZnVuY3Rpb24oaXQpe3JldHVybiBpdCBpbnN0YW5jZW9mIFZ9LEc9ZnVuY3Rpb24obnQsb3QsaHQpe3JldHVybiBudD09PWN0JiZHKGssb3QsaHQpLHIobnQpLG90PU0ob3QsITApLHIoaHQpLG8oc3Qsb3QpPyhodC5lbnVtZXJhYmxlPyhvKG50LEgpJiZudFtIXVtvdF0mJihudFtIXVtvdF09ITEpLGh0PVMoaHQse2VudW1lcmFibGU6UCgwLCExKX0pKToobyhudCxIKXx8VShudCxILFAoMSx7fSkpLG50W0hdW290XT0hMCksWShudCxvdCxodCkpOlUobnQsb3QsaHQpfSxsPWZ1bmN0aW9uKG50LG90KXtyKG50KTtmb3IodmFyIGh0PWgob3Q9cyhvdCkpLGR0PTAsdXQ9aHQubGVuZ3RoLG10O3V0PmR0OylHKG50LG10PWh0W2R0KytdLG90W210XSk7cmV0dXJuIG50fSxwPWZ1bmN0aW9uKG50LG90KXtyZXR1cm4gb3Q9PT12b2lkIDA/UyhudCk6bChTKG50KSxvdCl9LE49ZnVuY3Rpb24obnQpe3ZhciBvdD10dC5jYWxsKHRoaXMsbnQ9TShudCwhMCkpO3JldHVybiB0aGlzPT09Y3QmJm8oc3QsbnQpJiYhbyhrLG50KT8hMTpvdHx8IW8odGhpcyxudCl8fCFvKHN0LG50KXx8byh0aGlzLEgpJiZ0aGlzW0hdW250XT9vdDohMH0sej1mdW5jdGlvbihudCxvdCl7aWYobnQ9cyhudCksb3Q9TShvdCwhMCksIShudD09PWN0JiZvKHN0LG90KSYmIW8oayxvdCkpKXt2YXIgaHQ9QShudCxvdCk7cmV0dXJuIGh0JiZvKHN0LG90KSYmIShvKG50LEgpJiZudFtIXVtvdF0pJiYoaHQuZW51bWVyYWJsZT0hMCksaHR9fSwkPWZ1bmN0aW9uKG50KXtmb3IodmFyIG90PUsocyhudCkpLGh0PVtdLGR0PTAsdXQ7b3QubGVuZ3RoPmR0OykhbyhzdCx1dD1vdFtkdCsrXSkmJnV0IT1IJiZ1dCE9dSYmaHQucHVzaCh1dCk7cmV0dXJuIGh0fSxYPWZ1bmN0aW9uKG50KXtmb3IodmFyIG90PW50PT09Y3QsaHQ9SyhvdD9rOnMobnQpKSxkdD1bXSx1dD0wLG10O2h0Lmxlbmd0aD51dDspbyhzdCxtdD1odFt1dCsrXSkmJighb3R8fG8oY3QsbXQpKSYmZHQucHVzaChzdFttdF0pO3JldHVybiBkdH07ZnR8fChWPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIFYpdGhyb3cgVHlwZUVycm9yKCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhIik7dmFyIG50PWcoYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApLG90PWZ1bmN0aW9uKGh0KXt0aGlzPT09Y3QmJm90LmNhbGwoayxodCksbyh0aGlzLEgpJiZvKHRoaXNbSF0sbnQpJiYodGhpc1tIXVtudF09ITEpLFkodGhpcyxudCxQKDEsaHQpKX07cmV0dXJuIHYmJkYmJlkoY3QsbnQse2NvbmZpZ3VyYWJsZTohMCxzZXQ6b3R9KSxKKG50KX0sZChWW1ddLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa30pLE8uZj16LEkuZj1HLHQoMTgyKS5mPWIuZj0kLHQoMTY5KS5mPU4sRC5mPVgsdiYmIXQoODkpJiZkKGN0LCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsTiwhMCksQy5mPWZ1bmN0aW9uKGl0KXtyZXR1cm4gSih5KGl0KSl9KSxUKFQuRytULlcrVC5GKiFmdCx7U3ltYm9sOlZ9KTtmb3IodmFyIHc9Imhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzIi5zcGxpdCgiLCIpLGV0PTA7dy5sZW5ndGg+ZXQ7KXkod1tldCsrXSk7Zm9yKHZhciBydD1SKHkuc3RvcmUpLGF0PTA7cnQubGVuZ3RoPmF0Oyl4KHJ0W2F0KytdKTtUKFQuUytULkYqIWZ0LCJTeW1ib2wiLHtmb3I6ZnVuY3Rpb24oaXQpe3JldHVybiBvKF8saXQrPSIiKT9fW2l0XTpfW2l0XT1WKGl0KX0sa2V5Rm9yOmZ1bmN0aW9uKG50KXtpZighaihudCkpdGhyb3cgVHlwZUVycm9yKG50KyIgaXMgbm90IGEgc3ltYm9sISIpO2Zvcih2YXIgb3QgaW4gXylpZihfW290XT09PW50KXJldHVybiBvdH0sdXNlU2V0dGVyOmZ1bmN0aW9uKCl7Rj0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7Rj0hMX19KSxUKFQuUytULkYqIWZ0LCJPYmplY3QiLHtjcmVhdGU6cCxkZWZpbmVQcm9wZXJ0eTpHLGRlZmluZVByb3BlcnRpZXM6bCxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6eixnZXRPd25Qcm9wZXJ0eU5hbWVzOiQsZ2V0T3duUHJvcGVydHlTeW1ib2xzOlh9KTt2YXIgbHQ9YyhmdW5jdGlvbigpe0QuZigxKX0pO1QoVC5TK1QuRipsdCwiT2JqZWN0Iix7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKG50KXtyZXR1cm4gRC5mKG4obnQpKX19KSxRJiZUKFQuUytULkYqKCFmdHx8YyhmdW5jdGlvbigpe3ZhciBpdD1WKCk7cmV0dXJuIHEoW2l0XSkhPSJbbnVsbF0ifHxxKHthOml0fSkhPSJ7fSJ8fHEoT2JqZWN0KGl0KSkhPSJ7fSJ9KSksIkpTT04iLHtzdHJpbmdpZnk6ZnVuY3Rpb24obnQpe2Zvcih2YXIgb3Q9W250XSxodD0xLGR0LHV0O2FyZ3VtZW50cy5sZW5ndGg+aHQ7KW90LnB1c2goYXJndW1lbnRzW2h0KytdKTtpZih1dD1kdD1vdFsxXSwhKCFpKGR0KSYmbnQ9PT12b2lkIDB8fGoobnQpKSlyZXR1cm4gbShkdCl8fChkdD1mdW5jdGlvbihtdCxNdCl7aWYodHlwZW9mIHV0PT0iZnVuY3Rpb24iJiYoTXQ9dXQuY2FsbCh0aGlzLG10LE10KSksIWooTXQpKXJldHVybiBNdH0pLG90WzFdPWR0LHEuYXBwbHkoUSxvdCl9fSksVltXXVtaXXx8dCg5NSkoVltXXSxaLFZbV10udmFsdWVPZiksZihWLCJTeW1ib2wiKSxmKE1hdGgsIk1hdGgiLCEwKSxmKGEuSlNPTiwiSlNPTiIsITApfSxmdW5jdGlvbihMLGUsdCl7ZS5mPXQoMTIyKX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTEpLG89dCg5Miksdj10KDg5KSxUPXQoMTc4KSxkPXQoOTYpLmY7TC5leHBvcnRzPWZ1bmN0aW9uKHUpe3ZhciBjPW8uU3ltYm9sfHwoby5TeW1ib2w9dj97fTphLlN5bWJvbHx8e30pO3UuY2hhckF0KDApIT0iXyImJiEodSBpbiBjKSYmZChjLHUse3ZhbHVlOlQuZih1KX0pfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTEwKSxvPXQoMTY4KSx2PXQoMTY5KTtMLmV4cG9ydHM9ZnVuY3Rpb24oVCl7dmFyIGQ9YShUKSx1PW8uZjtpZih1KWZvcih2YXIgYz11KFQpLEU9di5mLGY9MCxnO2MubGVuZ3RoPmY7KUUuY2FsbChULGc9Y1tmKytdKSYmZC5wdXNoKGcpO3JldHVybiBkfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoODQpLG89dCgxODIpLmYsdj17fS50b1N0cmluZyxUPXR5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W10sZD1mdW5jdGlvbih1KXt0cnl7cmV0dXJuIG8odSl9Y2F0Y2h7cmV0dXJuIFQuc2xpY2UoKX19O0wuZXhwb3J0cy5mPWZ1bmN0aW9uKGMpe3JldHVybiBUJiZ2LmNhbGwoYyk9PSJbb2JqZWN0IFdpbmRvd10iP2QoYyk6byhhKGMpKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDExMSksbz10KDExOSkuY29uY2F0KCJsZW5ndGgiLCJwcm90b3R5cGUiKTtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKFQpe3JldHVybiBhKFQsbyl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxNjkpLG89dCgxMDQpLHY9dCg4NCksVD10KDEwMyksZD10KDEwNSksdT10KDk5KSxjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPXQoMTAwKT9jOmZ1bmN0aW9uKGYsZyl7aWYoZj12KGYpLGc9VChnLCEwKSx1KXRyeXtyZXR1cm4gYyhmLGcpfWNhdGNoe31pZihkKGYsZykpcmV0dXJuIG8oIWEuZi5jYWxsKGYsZyksZltnXSl9fSxmdW5jdGlvbihMLGUsdCl7dCgxNzkpKCJhc3luY0l0ZXJhdG9yIil9LGZ1bmN0aW9uKEwsZSx0KXt0KDE3OSkoIm9ic2VydmFibGUiKX0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmNyZWF0ZU5vd1RpbWU9YSxlLmZvcm1hdERlbGF5PW87ZnVuY3Rpb24gYSgpe3ZhciB2PW51bGw7cmV0dXJuIERhdGUubm93P3Y9RGF0ZS5ub3c6dj1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKX0sdn1mdW5jdGlvbiBvKHYpe3JldHVybiB0eXBlb2Ygdj09Im51bWJlciI/dj17ZGVsYXk6dn06ImVudHJvcHkiaW4gdiYmKHY9e2RlbGF5OnYuZW50cm9weSxpc0VudHJvcHk6ITB9KSx2fX0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9e2RlZmF1bHQ6ZnVuY3Rpb24obyx2LFQsZCx1KXtyZXR1cm4gdHlwZW9mIG89PSJudW1iZXIiJiZ0eXBlb2Ygdj09Im51bWJlciI/bysoVC1kKS8odS1kKSoodi1vKTpULWQ+dS1UP3Y6b319fSxmdW5jdGlvbihMLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUucGFyc2VFYXNpbmc9ZS5FYXNpbmdzPXZvaWQgMDt2YXIgYT10KDc2KSxvPWMoYSksdj10KDEzMyksVD1jKHYpLGQ9dCgxNDEpLHU9YyhkKTtmdW5jdGlvbiBjKG0pe3JldHVybiBtJiZtLl9fZXNNb2R1bGU/bTp7ZGVmYXVsdDptfX12YXIgRT10KDE4OSksZj1uZXcgdS5kZWZhdWx0O2Z1bmN0aW9uIGcoKXtmb3IodmFyIG09YXJndW1lbnRzLmxlbmd0aCxyPUFycmF5KG0pLGk9MDtpPG07aSsrKXJbaV09YXJndW1lbnRzW2ldO3ZhciBuPWYuZ2V0KHIpO3JldHVybiBufHwobj1FLmFwcGx5KHZvaWQgMCxyKSxmLnNldChyLG4pLG4pfWZ1bmN0aW9uIHkobSl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiJlbmQiO3JldHVybiBmdW5jdGlvbihpLG4pe2Zvcih2YXIgcz0xO3M8bi5sZW5ndGg7cysrKXt2YXIgTT1uW3NdLm9mZnNldDtpZihpPD1NKXt2YXIgUD1uW3MtMV0ub2Zmc2V0LFM9TSxiPShpLVApLyhTLVApLE89MS9tLEQ9Yi9PO3JldHVybiByPT09ImVuZCI/RD1NYXRoLmZsb29yKEQpOkQ9TWF0aC5jZWlsKEQpLE8qRCooUy1QKStQfX1yZXR1cm4gMH19ZnVuY3Rpb24gQyhtKXt2YXIgcj0vXmN1YmljLWJlemllclwoKC4qKVwpLyxpPW0ubWF0Y2gocik7aWYoaSl7dmFyIG49aVsxXS50cmltKCk7cmV0dXJuIG49bi5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihPKXtyZXR1cm4gcGFyc2VGbG9hdChPLnRyaW0oKSl9KSxnLmFwcGx5KHZvaWQgMCwoMCxULmRlZmF1bHQpKG4pKX1pZihyPS9ec3RlcHNcKCguKilcKS8saT1tLm1hdGNoKHIpLGkpe3ZhciBzPWlbMV0udHJpbSgpO3M9cy5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihPKXtyZXR1cm4gTy50cmltKCl9KTt2YXIgTT1zLFA9KDAsby5kZWZhdWx0KShNLDIpLFM9UFswXSxiPVBbMV07cmV0dXJuIHkocGFyc2VJbnQoUywxMCksYil9cmV0dXJuIG19dmFyIHg9e2xpbmVhcjpmdW5jdGlvbihyKXtyZXR1cm4gcn0sZWFzZTpnKC4yNSwuMSwuMjUsMSksImVhc2UtaW4iOmcoLjQyLDAsMSwxKSwiZWFzZS1vdXQiOmcoMCwwLC41OCwxKSwiZWFzZS1pbi1vdXQiOmcoLjQyLDAsLjU4LDEpLCJzdGVwLXN0YXJ0Ijp5KDEsInN0YXJ0IiksInN0ZXAtZW5kIjp5KDEsImVuZCIpfTtmdW5jdGlvbiBoKG0pe3JldHVybiB0eXBlb2YgbT09InN0cmluZyI/eFttXT9tPXhbbV06bT1DKG0pOm0udHlwZT09PSJjdWJpYy1iZXppZXIiP209Zy5hcHBseSh2b2lkIDAsKDAsVC5kZWZhdWx0KShtLnZhbHVlKSk6bS50eXBlPT09InN0ZXBzIiYmKG09eShtLnN0ZXAsbS5wb3MpKSxtfWUuRWFzaW5ncz14LGUucGFyc2VFYXNpbmc9aH0sZnVuY3Rpb24oTCxlKXt2YXIgdD00LGE9LjAwMSxvPTFlLTcsdj0xMCxUPTExLGQ9MS8oVC0xKSx1PXR5cGVvZiBGbG9hdDMyQXJyYXk9PSJmdW5jdGlvbiI7ZnVuY3Rpb24gYyhtLHIpe3JldHVybiAxLTMqciszKm19ZnVuY3Rpb24gRShtLHIpe3JldHVybiAzKnItNiptfWZ1bmN0aW9uIGYobSl7cmV0dXJuIDMqbX1mdW5jdGlvbiBnKG0scixpKXtyZXR1cm4oKGMocixpKSptK0UocixpKSkqbStmKHIpKSptfWZ1bmN0aW9uIHkobSxyLGkpe3JldHVybiAzKmMocixpKSptKm0rMipFKHIsaSkqbStmKHIpfWZ1bmN0aW9uIEMobSxyLGksbixzKXt2YXIgTSxQLFM9MDtkbyBQPXIrKGktcikvMixNPWcoUCxuLHMpLW0sTT4wP2k9UDpyPVA7d2hpbGUoTWF0aC5hYnMoTSk+byYmKytTPHYpO3JldHVybiBQfWZ1bmN0aW9uIHgobSxyLGksbil7Zm9yKHZhciBzPTA7czx0Oysrcyl7dmFyIE09eShyLGksbik7aWYoTT09PTApcmV0dXJuIHI7dmFyIFA9ZyhyLGksbiktbTtyLT1QL019cmV0dXJuIHJ9ZnVuY3Rpb24gaChtKXtyZXR1cm4gbX1MLmV4cG9ydHM9ZnVuY3Rpb24ocixpLG4scyl7aWYoISgwPD1yJiZyPD0xJiYwPD1uJiZuPD0xKSl0aHJvdyBuZXcgRXJyb3IoImJlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZSIpO2lmKHI9PT1pJiZuPT09cylyZXR1cm4gaDtmb3IodmFyIE09dT9uZXcgRmxvYXQzMkFycmF5KFQpOm5ldyBBcnJheShUKSxQPTA7UDxUOysrUClNW1BdPWcoUCpkLHIsbik7ZnVuY3Rpb24gUyhiKXtmb3IodmFyIE89MCxEPTEsST1ULTE7RCE9PUkmJk1bRF08PWI7KytEKU8rPWQ7LS1EO3ZhciBSPShiLU1bRF0pLyhNW0QrMV0tTVtEXSksQT1PK1IqZCxVPXkoQSxyLG4pO3JldHVybiBVPj1hP3goYixBLHIsbik6VT09PTA/QTpDKGIsTyxPK2QscixuKX1yZXR1cm4gZnVuY3Rpb24oTyl7cmV0dXJuIE89PT0wPzA6Tz09PTE/MTpnKFMoTyksaSxzKX19fSxmdW5jdGlvbihMLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciBhPXQoMTkxKSxvPWkoYSksdj10KDIwNCksVD1pKHYpLGQ9dCgxNjQpLHU9aShkKSxjPXQoMTcwKSxFPWkoYyksZj10KDE3MSksZz1pKGYpLHk9dCgxNzUpLEM9aSh5KSx4PXQoNzUpLGg9aSh4KSxtPXQoMjA4KSxyPXQoMTg4KTtmdW5jdGlvbiBpKFUpe3JldHVybiBVJiZVLl9fZXNNb2R1bGU/VTp7ZGVmYXVsdDpVfX12YXIgbj0oMCxDLmRlZmF1bHQpKCJ0aW1pbmciKSxzPSgwLEMuZGVmYXVsdCkoImtleWZyYW1lcyIpLE09KDAsQy5kZWZhdWx0KSgiaW5pdFN0YXRlIiksUD0oMCxDLmRlZmF1bHQpKCJyZWFkeURlZmVyIiksUz0oMCxDLmRlZmF1bHQpKCJmaW5pc2hlZERlZmVyIiksYj0oMCxDLmRlZmF1bHQpKCJlZmZlY3RzIiksTz0oMCxDLmRlZmF1bHQpKCJhY3RpdmVSZWFkeVRpbWVyIiksRD0oMCxDLmRlZmF1bHQpKCJhY3RpdmVGaW5pc2hUaW1lciIpLEk9KDAsQy5kZWZhdWx0KSgicmVtb3ZlRGVmZXIiKSxSPXtkZWxheTowLGVuZERlbGF5OjAsZmlsbDoiYXV0byIsaXRlcmF0aW9uczoxLHBsYXliYWNrUmF0ZToxLGRpcmVjdGlvbjoibm9ybWFsIixlYXNpbmc6ImxpbmVhciIsZWZmZWN0Om51bGx9LEE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBVKEssVixRKXt2YXIgcT10aGlzO2lmKCgwLEUuZGVmYXVsdCkodGhpcyxVKSxBcnJheS5pc0FycmF5KEspKXt2YXIgVz1bS1swXSxLLFZdO0s9V1swXSxWPVdbMV0sUT1XWzJdfXR5cGVvZiBRPT0ibnVtYmVyIiYmKFE9e2R1cmF0aW9uOlF9KSx0aGlzW25dPSgwLHUuZGVmYXVsdCkoe30sUixRKSx0aGlzW25dLmVhc2luZz0oMCxyLnBhcnNlRWFzaW5nKSh0aGlzW25dLmVhc2luZyksdGhpc1tzXT0oMCxtLmNhbGN1bGF0ZUZyYW1lc09mZnNldCkoVik7dmFyIEg9dGhpc1tzXVt0aGlzW3NdLmxlbmd0aC0xXTt0aGlzW01dPXt9LCgwLFQuZGVmYXVsdCkoSCkuZm9yRWFjaChmdW5jdGlvbihaKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoSyxaKSYmWiE9PSJlYXNpbmciJiZaIT09Im9mZnNldCImJihxW01dW1pdPUtbWl0pfSksdGhpc1tzXT10aGlzW3NdLm1hcChmdW5jdGlvbihaKXtyZXR1cm4oMCx1LmRlZmF1bHQpKHt9LHFbTV0sWil9KSx0aGlzW3NdWzBdLm9mZnNldCE9PTAmJnRoaXNbc10udW5zaGlmdCgoMCx1LmRlZmF1bHQpKHt9LHRoaXNbTV0se29mZnNldDowfSkpLEgub2Zmc2V0PDEmJnRoaXNbc10ucHVzaCgoMCx1LmRlZmF1bHQpKHt9LEgse29mZnNldDoxfSkpLHRoaXNbYl09e30sdGhpcy50aW1lbGluZT1udWxsfXJldHVybigwLGcuZGVmYXVsdCkoVSxbe2tleToicGF1c2UiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9MH19LHtrZXk6Tyx2YWx1ZTpmdW5jdGlvbigpe3ZhciBWPXRoaXM7dGhpc1tQXSYmIXRoaXNbUF0udGltZXJJRCYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU8MD90aGlzW1BdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7VltQXS5yZXNvbHZlKCksZGVsZXRlIFZbUF19LHtkZWxheTotdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxoZWFkaW5nOiExfSk6dGhpc1tQXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe1ZbUF0ucmVzb2x2ZSgpLGRlbGV0ZSBWW1BdfSx7ZGVsYXk6MCxpc0VudHJvcHk6ITB9KSl9fSx7a2V5OkQsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgVj10aGlzLFE9dGhpc1tuXSxxPVEuZHVyYXRpb24sVz1RLml0ZXJhdGlvbnMsSD1RLmVuZERlbGF5LFo9TWF0aC5jZWlsKHEqVytILXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUpKzE7dGhpc1tTXSYmIXRoaXNbU10udGltZXJJRCYmKHRoaXNbU10udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtWW1NdLnJlc29sdmUoKSxWW0ldKFApLFZbSV0oUyl9LHtkZWxheTpaLGhlYWRpbmc6ITF9KSx0aGlzW1NdLnJldmVyc2VUaW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe1ZbU10ucmVzb2x2ZSgpLFZbSV0oUCksVltJXShTKSxWLnRpbWVsaW5lPW51bGx9LHtkZWxheTotdGhpc1tuXS5kZWxheS0xLGhlYWRpbmc6ITF9KSl9fSx7a2V5OiJwbGF5Iix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIiYmdGhpcy5jYW5jZWwoKSx0aGlzLnBsYXlTdGF0ZT09PSJpZGxlIil7aWYodGhpcy5wbGF5YmFja1JhdGU8PTApcmV0dXJuO3ZhciBWPXRoaXNbbl0sUT1WLmRlbGF5LHE9Vi5wbGF5YmFja1JhdGUsVz1WLnRpbWVsaW5lO3RoaXMudGltZWxpbmU9bmV3IGguZGVmYXVsdCh7b3JpZ2luVGltZTpRLHBsYXliYWNrUmF0ZTpxfSxXKSx0aGlzW09dKCksdGhpc1tEXSgpfWVsc2UgdGhpcy5wbGF5U3RhdGU9PT0icGF1c2VkIiYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlLHRoaXNbT10oKSl9fSx7a2V5OkksdmFsdWU6ZnVuY3Rpb24oVil7dmFyIFE9dGhpc1tWXSxxPXRoaXMudGltZWxpbmU7USYmcSYmKHEuY2xlYXJUaW1lb3V0KFEudGltZXJJRCksUS5yZXZlcnNlVGltZXJJRCYmcS5jbGVhclRpbWVvdXQoUS5yZXZlcnNlVGltZXJJRCkpLGRlbGV0ZSB0aGlzW1ZdfX0se2tleToiY2FuY2VsIix2YWx1ZTpmdW5jdGlvbigpe3RoaXNbSV0oUCksdGhpc1tJXShTKSx0aGlzLnRpbWVsaW5lPW51bGx9fSx7a2V5OiJmaW5pc2giLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU9MS8wL3RoaXMucGxheWJhY2tSYXRlKSx0aGlzW0ldKFApLHRoaXNbSV0oUyl9fSx7a2V5OiJhcHBseUVmZmVjdHMiLHZhbHVlOmZ1bmN0aW9uKFYpe3JldHVybigwLHUuZGVmYXVsdCkodGhpc1tiXSxWKX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbbl0ucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oVil7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPVYpLHRoaXNbbl0ucGxheWJhY2tSYXRlPVZ9fSx7a2V5OiJwbGF5U3RhdGUiLGdldDpmdW5jdGlvbigpe3ZhciBWPXRoaXMudGltZWxpbmUsUT10aGlzW25dLHE9US5pdGVyYXRpb25zLFc9US5kdXJhdGlvbixIPVEuZW5kRGVsYXksWj0icnVubmluZyI7aWYoVj09bnVsbClaPSJpZGxlIjtlbHNlIGlmKFYucGF1c2VkKVo9InBhdXNlZCI7ZWxzZSBpZihWLmN1cnJlbnRUaW1lPDApWj0icGVuZGluZyI7ZWxzZXt2YXIgdHQ9Vi5jdXJyZW50VGltZS1xKlc7dHQ+MCYmdHQ8SD9aPSJwZW5kaW5nIjp0dD49SCYmKFo9ImZpbmlzaGVkIil9cmV0dXJuIFp9fSx7a2V5OiJwcm9ncmVzcyIsZ2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMudGltZWxpbmUpcmV0dXJuIDA7dmFyIFY9dGhpc1tuXSxRPVYuZHVyYXRpb24scT1WLml0ZXJhdGlvbnMsVz10aGlzLnRpbWVsaW5lLEg9dGhpcy5wbGF5U3RhdGUsWj12b2lkIDA7aWYoSD09PSJpZGxlIilaPTA7ZWxzZSBpZihIPT09InBhdXNlZCImJlcuY3VycmVudFRpbWU8MClaPTA7ZWxzZSBpZihIPT09InBlbmRpbmciKWlmKFcuY3VycmVudFRpbWU8MClaPTA7ZWxzZXt2YXIgdHQ9Vy5zZWVrTG9jYWxUaW1lKHEqUSk7Wj0oMCxtLnBlcmlvZGljaXR5KSh0dCxRKVsxXS9RfWVsc2UoSD09PSJydW5uaW5nInx8SD09PSJwYXVzZWQiKSYmKFo9KDAsbS5wZXJpb2RpY2l0eSkoVy5jdXJyZW50VGltZSxRKVsxXS9RKTtyZXR1cm4gSD09PSJmaW5pc2hlZCImJihaPSgwLG0ucGVyaW9kaWNpdHkpKHEsMSlbMV0pLFp9fSx7a2V5OiJmcmFtZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIFY9dGhpcy5wbGF5U3RhdGUsUT10aGlzW01dLHE9dGhpc1tuXS5maWxsO2lmKFY9PT0iaWRsZSIpcmV0dXJuIFE7dmFyIFc9dGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxIPXRoaXNbc10uc2xpY2UoMCksWj0oMCxtLmdldFByb2dyZXNzKSh0aGlzLnRpbWVsaW5lLHRoaXNbbl0sdGhpcy5wcm9ncmVzcyksdHQ9Wi5wLF89Wi5pbnZlcnRlZCxzdD1RO3JldHVybiBXPDAmJlY9PT0icGVuZGluZyI/KHE9PT0iYmFja3dhcmRzInx8cT09PSJib3RoIikmJihzdD1fP0hbSC5sZW5ndGgtMV06SFswXSk6KFYhPT0icGVuZGluZyImJlYhPT0iZmluaXNoZWQifHxxPT09ImZvcndhcmRzInx8cT09PSJib3RoIikmJihzdD0oMCxtLmdldEN1cnJlbnRGcmFtZSkodGhpc1tuXSxILHRoaXNbYl0sdHQpKSxzdH19LHtrZXk6InRpbWluZyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbbl19fSx7a2V5OiJlZmZlY3RzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tiXX19LHtrZXk6ImJhc2VUaW1lbGluZSIsc2V0OmZ1bmN0aW9uKFYpe3RoaXNbbl0udGltZWxpbmU9Vn0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbbl0udGltZWxpbmV9fSx7a2V5OiJyZWFkeSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5wcm9taXNlOnRoaXMudGltZWxpbmUmJnRoaXMudGltZWxpbmUuY3VycmVudFRpbWU+PTAmJnRoaXMucGxheVN0YXRlIT09InBhdXNlZCI/by5kZWZhdWx0LnJlc29sdmUoKToodGhpc1tQXT0oMCxtLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbT10oKSx0aGlzW1BdP3RoaXNbUF0ucHJvbWlzZTpvLmRlZmF1bHQucmVzb2x2ZSgpKX19LHtrZXk6ImZpbmlzaGVkIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGU9PT0iZmluaXNoZWQiP28uZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbU118fCh0aGlzW1NdPSgwLG0uZGVmZXIpKCksdGhpcy50aW1lbGluZSYmdGhpc1tEXSgpKSx0aGlzW1NdLnByb21pc2UpfX1dKSxVfSgpO2UuZGVmYXVsdD1BfSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXtkZWZhdWx0OnQoMTkyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oTCxlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxOTMpLHQoMjAyKSx0KDIwMyksTC5leHBvcnRzPXQoOTIpLlByb21pc2V9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDg5KSxvPXQoOTEpLHY9dCg5MyksVD10KDEyOCksZD10KDkwKSx1PXQoOTgpLGM9dCg5NCksRT10KDE0NyksZj10KDE0OCksZz10KDE5NCkseT10KDE5NSkuc2V0LEM9dCgxOTcpKCkseD10KDE5OCksaD10KDE5OSksbT10KDIwMCkscj10KDIwMSksaT0iUHJvbWlzZSIsbj1vLlR5cGVFcnJvcixzPW8ucHJvY2VzcyxNPXMmJnMudmVyc2lvbnMsUD1NJiZNLnY4fHwiIixTPW9baV0sYj1UKHMpPT0icHJvY2VzcyIsTz1mdW5jdGlvbigpe30sRCxJLFIsQSxVPUk9eC5mLEs9ISFmdW5jdGlvbigpe3RyeXt2YXIgXz1TLnJlc29sdmUoMSksc3Q9KF8uY29uc3RydWN0b3I9e30pW3QoMTIyKSgic3BlY2llcyIpXT1mdW5jdGlvbihrKXtrKE8sTyl9O3JldHVybihifHx0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50PT0iZnVuY3Rpb24iKSYmXy50aGVuKE8paW5zdGFuY2VvZiBzdCYmUC5pbmRleE9mKCI2LjYiKSE9PTAmJm0uaW5kZXhPZigiQ2hyb21lLzY2Iik9PT0tMX1jYXRjaHt9fSgpLFY9ZnVuY3Rpb24oXyl7dmFyIHN0O3JldHVybiB1KF8pJiZ0eXBlb2Yoc3Q9Xy50aGVuKT09ImZ1bmN0aW9uIj9zdDohMX0sUT1mdW5jdGlvbihfLHN0KXtpZighXy5fbil7Xy5fbj0hMDt2YXIgaz1fLl9jO0MoZnVuY3Rpb24oKXtmb3IodmFyIGN0PV8uX3YsZnQ9Xy5fcz09MSxCPTAsRj1mdW5jdGlvbihZKXt2YXIgSj1mdD9ZLm9rOlkuZmFpbCxqPVkucmVzb2x2ZSxHPVkucmVqZWN0LGw9WS5kb21haW4scCxOLHo7dHJ5e0o/KGZ0fHwoXy5faD09MiYmSChfKSxfLl9oPTEpLEo9PT0hMD9wPWN0OihsJiZsLmVudGVyKCkscD1KKGN0KSxsJiYobC5leGl0KCksej0hMCkpLHA9PT1ZLnByb21pc2U/RyhuKCJQcm9taXNlLWNoYWluIGN5Y2xlIikpOihOPVYocCkpP04uY2FsbChwLGosRyk6aihwKSk6RyhjdCl9Y2F0Y2goJCl7bCYmIXomJmwuZXhpdCgpLEcoJCl9fTtrLmxlbmd0aD5COylGKGtbQisrXSk7Xy5fYz1bXSxfLl9uPSExLHN0JiYhXy5faCYmcShfKX0pfX0scT1mdW5jdGlvbihfKXt5LmNhbGwobyxmdW5jdGlvbigpe3ZhciBzdD1fLl92LGs9VyhfKSxjdCxmdCxCO2lmKGsmJihjdD1oKGZ1bmN0aW9uKCl7Yj9zLmVtaXQoInVuaGFuZGxlZFJlamVjdGlvbiIsc3QsXyk6KGZ0PW8ub251bmhhbmRsZWRyZWplY3Rpb24pP2Z0KHtwcm9taXNlOl8scmVhc29uOnN0fSk6KEI9by5jb25zb2xlKSYmQi5lcnJvciYmQi5lcnJvcigiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIixzdCl9KSxfLl9oPWJ8fFcoXyk/MjoxKSxfLl9hPXZvaWQgMCxrJiZjdC5lKXRocm93IGN0LnZ9KX0sVz1mdW5jdGlvbihfKXtyZXR1cm4gXy5faCE9PTEmJihfLl9hfHxfLl9jKS5sZW5ndGg9PT0wfSxIPWZ1bmN0aW9uKF8pe3kuY2FsbChvLGZ1bmN0aW9uKCl7dmFyIHN0O2I/cy5lbWl0KCJyZWplY3Rpb25IYW5kbGVkIixfKTooc3Q9by5vbnJlamVjdGlvbmhhbmRsZWQpJiZzdCh7cHJvbWlzZTpfLHJlYXNvbjpfLl92fSl9KX0sWj1mdW5jdGlvbihfKXt2YXIgc3Q9dGhpcztzdC5fZHx8KHN0Ll9kPSEwLHN0PXN0Ll93fHxzdCxzdC5fdj1fLHN0Ll9zPTIsc3QuX2F8fChzdC5fYT1zdC5fYy5zbGljZSgpKSxRKHN0LCEwKSl9LHR0PWZ1bmN0aW9uKF8pe3ZhciBzdD10aGlzLGs7aWYoIXN0Ll9kKXtzdC5fZD0hMCxzdD1zdC5fd3x8c3Q7dHJ5e2lmKHN0PT09Xyl0aHJvdyBuKCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZiIpOyhrPVYoXykpP0MoZnVuY3Rpb24oKXt2YXIgY3Q9e193OnN0LF9kOiExfTt0cnl7ay5jYWxsKF8sdih0dCxjdCwxKSx2KFosY3QsMSkpfWNhdGNoKGZ0KXtaLmNhbGwoY3QsZnQpfX0pOihzdC5fdj1fLHN0Ll9zPTEsUShzdCwhMSkpfWNhdGNoKGN0KXtaLmNhbGwoe193OnN0LF9kOiExfSxjdCl9fX07S3x8KFM9ZnVuY3Rpb24oc3Qpe0UodGhpcyxTLGksIl9oIiksYyhzdCksRC5jYWxsKHRoaXMpO3RyeXtzdCh2KHR0LHRoaXMsMSksdihaLHRoaXMsMSkpfWNhdGNoKGspe1ouY2FsbCh0aGlzLGspfX0sRD1mdW5jdGlvbihzdCl7dGhpcy5fYz1bXSx0aGlzLl9hPXZvaWQgMCx0aGlzLl9zPTAsdGhpcy5fZD0hMSx0aGlzLl92PXZvaWQgMCx0aGlzLl9oPTAsdGhpcy5fbj0hMX0sRC5wcm90b3R5cGU9dCgxNDYpKFMucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHN0LGspe3ZhciBjdD1VKGcodGhpcyxTKSk7cmV0dXJuIGN0Lm9rPXR5cGVvZiBzdD09ImZ1bmN0aW9uIj9zdDohMCxjdC5mYWlsPXR5cGVvZiBrPT0iZnVuY3Rpb24iJiZrLGN0LmRvbWFpbj1iP3MuZG9tYWluOnZvaWQgMCx0aGlzLl9jLnB1c2goY3QpLHRoaXMuX2EmJnRoaXMuX2EucHVzaChjdCksdGhpcy5fcyYmUSh0aGlzLCExKSxjdC5wcm9taXNlfSxjYXRjaDpmdW5jdGlvbihfKXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxfKX19KSxSPWZ1bmN0aW9uKCl7dmFyIF89bmV3IEQ7dGhpcy5wcm9taXNlPV8sdGhpcy5yZXNvbHZlPXYodHQsXywxKSx0aGlzLnJlamVjdD12KFosXywxKX0seC5mPVU9ZnVuY3Rpb24oXyl7cmV0dXJuIF89PT1TfHxfPT09QT9uZXcgUihfKTpJKF8pfSksZChkLkcrZC5XK2QuRiohSyx7UHJvbWlzZTpTfSksdCgxMjEpKFMsaSksdCgxNDkpKGkpLEE9dCg5MilbaV0sZChkLlMrZC5GKiFLLGkse3JlamVjdDpmdW5jdGlvbihzdCl7dmFyIGs9VSh0aGlzKSxjdD1rLnJlamVjdDtyZXR1cm4gY3Qoc3QpLGsucHJvbWlzZX19KSxkKGQuUytkLkYqKGF8fCFLKSxpLHtyZXNvbHZlOmZ1bmN0aW9uKHN0KXtyZXR1cm4gcihhJiZ0aGlzPT09QT9TOnRoaXMsc3QpfX0pLGQoZC5TK2QuRiohKEsmJnQoMTQwKShmdW5jdGlvbihfKXtTLmFsbChfKS5jYXRjaChPKX0pKSxpLHthbGw6ZnVuY3Rpb24oc3Qpe3ZhciBrPXRoaXMsY3Q9VShrKSxmdD1jdC5yZXNvbHZlLEI9Y3QucmVqZWN0LEY9aChmdW5jdGlvbigpe3ZhciBZPVtdLEo9MCxqPTE7ZihzdCwhMSxmdW5jdGlvbihHKXt2YXIgbD1KKysscD0hMTtZLnB1c2godm9pZCAwKSxqKyssay5yZXNvbHZlKEcpLnRoZW4oZnVuY3Rpb24oTil7cHx8KHA9ITAsWVtsXT1OLC0tanx8ZnQoWSkpfSxCKX0pLC0tanx8ZnQoWSl9KTtyZXR1cm4gRi5lJiZCKEYudiksY3QucHJvbWlzZX0scmFjZTpmdW5jdGlvbihzdCl7dmFyIGs9dGhpcyxjdD1VKGspLGZ0PWN0LnJlamVjdCxCPWgoZnVuY3Rpb24oKXtmKHN0LCExLGZ1bmN0aW9uKEYpe2sucmVzb2x2ZShGKS50aGVuKGN0LnJlc29sdmUsZnQpfSl9KTtyZXR1cm4gQi5lJiZmdChCLnYpLGN0LnByb21pc2V9fSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk3KSxvPXQoOTQpLHY9dCgxMjIpKCJzcGVjaWVzIik7TC5leHBvcnRzPWZ1bmN0aW9uKFQsZCl7dmFyIHU9YShUKS5jb25zdHJ1Y3RvcixjO3JldHVybiB1PT09dm9pZCAwfHwoYz1hKHUpW3ZdKT09bnVsbD9kOm8oYyl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5Myksbz10KDE5Niksdj10KDEyMCksVD10KDEwMiksZD10KDkxKSx1PWQucHJvY2VzcyxjPWQuc2V0SW1tZWRpYXRlLEU9ZC5jbGVhckltbWVkaWF0ZSxmPWQuTWVzc2FnZUNoYW5uZWwsZz1kLkRpc3BhdGNoLHk9MCxDPXt9LHg9Im9ucmVhZHlzdGF0ZWNoYW5nZSIsaCxtLHIsaT1mdW5jdGlvbigpe3ZhciBzPSt0aGlzO2lmKEMuaGFzT3duUHJvcGVydHkocykpe3ZhciBNPUNbc107ZGVsZXRlIENbc10sTSgpfX0sbj1mdW5jdGlvbihzKXtpLmNhbGwocy5kYXRhKX07KCFjfHwhRSkmJihjPWZ1bmN0aW9uKE0pe2Zvcih2YXIgUD1bXSxTPTE7YXJndW1lbnRzLmxlbmd0aD5TOylQLnB1c2goYXJndW1lbnRzW1MrK10pO3JldHVybiBDWysreV09ZnVuY3Rpb24oKXtvKHR5cGVvZiBNPT0iZnVuY3Rpb24iP006RnVuY3Rpb24oTSksUCl9LGgoeSkseX0sRT1mdW5jdGlvbihNKXtkZWxldGUgQ1tNXX0sdCg4NikodSk9PSJwcm9jZXNzIj9oPWZ1bmN0aW9uKHMpe3UubmV4dFRpY2soYShpLHMsMSkpfTpnJiZnLm5vdz9oPWZ1bmN0aW9uKHMpe2cubm93KGEoaSxzLDEpKX06Zj8obT1uZXcgZixyPW0ucG9ydDIsbS5wb3J0MS5vbm1lc3NhZ2U9bixoPWEoci5wb3N0TWVzc2FnZSxyLDEpKTpkLmFkZEV2ZW50TGlzdGVuZXImJnR5cGVvZiBwb3N0TWVzc2FnZT09ImZ1bmN0aW9uIiYmIWQuaW1wb3J0U2NyaXB0cz8oaD1mdW5jdGlvbihzKXtkLnBvc3RNZXNzYWdlKHMrIiIsIioiKX0sZC5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixuLCExKSk6eCBpbiBUKCJzY3JpcHQiKT9oPWZ1bmN0aW9uKHMpe3YuYXBwZW5kQ2hpbGQoVCgic2NyaXB0IikpW3hdPWZ1bmN0aW9uKCl7di5yZW1vdmVDaGlsZCh0aGlzKSxpLmNhbGwocyl9fTpoPWZ1bmN0aW9uKHMpe3NldFRpbWVvdXQoYShpLHMsMSksMCl9KSxMLmV4cG9ydHM9e3NldDpjLGNsZWFyOkV9fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0LGEsbyl7dmFyIHY9bz09PXZvaWQgMDtzd2l0Y2goYS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdj90KCk6dC5jYWxsKG8pO2Nhc2UgMTpyZXR1cm4gdj90KGFbMF0pOnQuY2FsbChvLGFbMF0pO2Nhc2UgMjpyZXR1cm4gdj90KGFbMF0sYVsxXSk6dC5jYWxsKG8sYVswXSxhWzFdKTtjYXNlIDM6cmV0dXJuIHY/dChhWzBdLGFbMV0sYVsyXSk6dC5jYWxsKG8sYVswXSxhWzFdLGFbMl0pO2Nhc2UgNDpyZXR1cm4gdj90KGFbMF0sYVsxXSxhWzJdLGFbM10pOnQuY2FsbChvLGFbMF0sYVsxXSxhWzJdLGFbM10pfXJldHVybiB0LmFwcGx5KG8sYSl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MSksbz10KDE5NSkuc2V0LHY9YS5NdXRhdGlvbk9ic2VydmVyfHxhLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsVD1hLnByb2Nlc3MsZD1hLlByb21pc2UsdT10KDg2KShUKT09InByb2Nlc3MiO0wuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBjLEUsZixnPWZ1bmN0aW9uKCl7dmFyIGgsbTtmb3IodSYmKGg9VC5kb21haW4pJiZoLmV4aXQoKTtjOyl7bT1jLmZuLGM9Yy5uZXh0O3RyeXttKCl9Y2F0Y2gocil7dGhyb3cgYz9mKCk6RT12b2lkIDAscn19RT12b2lkIDAsaCYmaC5lbnRlcigpfTtpZih1KWY9ZnVuY3Rpb24oKXtULm5leHRUaWNrKGcpfTtlbHNlIGlmKHYmJiEoYS5uYXZpZ2F0b3ImJmEubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgeT0hMCxDPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTtuZXcgdihnKS5vYnNlcnZlKEMse2NoYXJhY3RlckRhdGE6ITB9KSxmPWZ1bmN0aW9uKCl7Qy5kYXRhPXk9IXl9fWVsc2UgaWYoZCYmZC5yZXNvbHZlKXt2YXIgeD1kLnJlc29sdmUodm9pZCAwKTtmPWZ1bmN0aW9uKCl7eC50aGVuKGcpfX1lbHNlIGY9ZnVuY3Rpb24oKXtvLmNhbGwoYSxnKX07cmV0dXJuIGZ1bmN0aW9uKGgpe3ZhciBtPXtmbjpoLG5leHQ6dm9pZCAwfTtFJiYoRS5uZXh0PW0pLGN8fChjPW0sZigpKSxFPW19fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTQpO2Z1bmN0aW9uIG8odil7dmFyIFQsZDt0aGlzLnByb21pc2U9bmV3IHYoZnVuY3Rpb24odSxjKXtpZihUIT09dm9pZCAwfHxkIT09dm9pZCAwKXRocm93IFR5cGVFcnJvcigiQmFkIFByb21pc2UgY29uc3RydWN0b3IiKTtUPXUsZD1jfSksdGhpcy5yZXNvbHZlPWEoVCksdGhpcy5yZWplY3Q9YShkKX1MLmV4cG9ydHMuZj1mdW5jdGlvbih2KXtyZXR1cm4gbmV3IG8odil9fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJue2U6ITEsdjp0KCl9fWNhdGNoKGEpe3JldHVybntlOiEwLHY6YX19fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTEpLG89YS5uYXZpZ2F0b3I7TC5leHBvcnRzPW8mJm8udXNlckFnZW50fHwiIn0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTcpLG89dCg5OCksdj10KDE5OCk7TC5leHBvcnRzPWZ1bmN0aW9uKFQsZCl7aWYoYShUKSxvKGQpJiZkLmNvbnN0cnVjdG9yPT09VClyZXR1cm4gZDt2YXIgdT12LmYoVCksYz11LnJlc29sdmU7cmV0dXJuIGMoZCksdS5wcm9taXNlfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTApLG89dCg5Miksdj10KDkxKSxUPXQoMTk0KSxkPXQoMjAxKTthKGEuUCthLlIsIlByb21pc2UiLHtmaW5hbGx5OmZ1bmN0aW9uKHUpe3ZhciBjPVQodGhpcyxvLlByb21pc2V8fHYuUHJvbWlzZSksRT10eXBlb2YgdT09ImZ1bmN0aW9uIjtyZXR1cm4gdGhpcy50aGVuKEU/ZnVuY3Rpb24oZil7cmV0dXJuIGQoYyx1KCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZn0pfTp1LEU/ZnVuY3Rpb24oZil7cmV0dXJuIGQoYyx1KCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBmfSl9OnUpfX0pfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCksbz10KDE5OCksdj10KDE5OSk7YShhLlMsIlByb21pc2UiLHt0cnk6ZnVuY3Rpb24oVCl7dmFyIGQ9by5mKHRoaXMpLHU9dihUKTtyZXR1cm4odS5lP2QucmVqZWN0OmQucmVzb2x2ZSkodS52KSxkLnByb21pc2V9fSl9LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMDUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihMLGUsdCl7dCgyMDYpLEwuZXhwb3J0cz10KDkyKS5PYmplY3Qua2V5c30sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTI0KSxvPXQoMTEwKTt0KDIwNykoImtleXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKFQpe3JldHVybiBvKGEoVCkpfX0pfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCksbz10KDkyKSx2PXQoMTAxKTtMLmV4cG9ydHM9ZnVuY3Rpb24oVCxkKXt2YXIgdT0oby5PYmplY3R8fHt9KVtUXXx8T2JqZWN0W1RdLGM9e307Y1tUXT1kKHUpLGEoYS5TK2EuRip2KGZ1bmN0aW9uKCl7dSgxKX0pLCJPYmplY3QiLGMpfX0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgYT10KDc2KSxvPUMoYSksdj10KDIwOSksVD1DKHYpLGQ9dCgxNjQpLHU9QyhkKSxjPXQoMTkxKSxFPUMoYyk7ZS5kZWZlcj14LGUucGVyaW9kaWNpdHk9aCxlLmNhbGN1bGF0ZUZyYW1lc09mZnNldD1tLGUuZ2V0UHJvZ3Jlc3M9cixlLmdldEN1cnJlbnRGcmFtZT1uO3ZhciBmPXQoMTg4KSxnPXQoMTg3KSx5PUMoZyk7ZnVuY3Rpb24gQyhzKXtyZXR1cm4gcyYmcy5fX2VzTW9kdWxlP3M6e2RlZmF1bHQ6c319ZnVuY3Rpb24geCgpe3ZhciBzPXt9O3JldHVybiBzLnByb21pc2U9bmV3IEUuZGVmYXVsdChmdW5jdGlvbihNLFApe3MucmVzb2x2ZT1NLHMucmVqZWN0PVB9KSxzfWZ1bmN0aW9uIGgocyxNKXt2YXIgUD1NYXRoLmZsb29yKHMvTSksUz1zLVAqTTtyZXR1cm4gUz09PTAmJlA+MCYmKFM9TSxQLS0pLFtQLFNdfWZ1bmN0aW9uIG0ocyl7cz1zLnNsaWNlKDApO3ZhciBNPXNbMF0sUD1zW3MubGVuZ3RoLTFdO1Aub2Zmc2V0PVAub2Zmc2V0fHwxLE0ub2Zmc2V0PU0ub2Zmc2V0fHwwO2Zvcih2YXIgUz0wLGI9LTEsTz0wO088cy5sZW5ndGg7TysrKXt2YXIgRD1zW09dO2lmKEQub2Zmc2V0IT1udWxsKXt2YXIgST1PLWI7aWYoST4xKWZvcih2YXIgUj0oRC5vZmZzZXQtUykvSSxBPTA7QTxJLTE7QSsrKXNbYitBKzFdLm9mZnNldD1TK1IqKEErMSk7Uz1ELm9mZnNldCxiPU99aWYoRC5lYXNpbmchPW51bGwmJihELmVhc2luZz0oMCxmLnBhcnNlRWFzaW5nKShELmVhc2luZykpLE8+MCl7dmFyIFU9c1tPXS5lYXNpbmchPW51bGw7c1tPXT0oMCx1LmRlZmF1bHQpKHt9LHNbTy0xXSxzW09dKSxVfHxkZWxldGUgc1tPXS5lYXNpbmd9fXJldHVybiBzfWZ1bmN0aW9uIHIocyxNLFApe3ZhciBTPXMuY3VycmVudFRpbWUsYj1NLmRpcmVjdGlvbixPPU0uZHVyYXRpb24sRD0hMTtpZihiPT09InJldmVyc2UiKVA9MS1QLEQ9ITA7ZWxzZSBpZihiPT09ImFsdGVybmF0ZSJ8fGI9PT0iYWx0ZXJuYXRlLXJldmVyc2UiKXt2YXIgST1NYXRoLmZsb29yKFMvTyk7UD09PTEmJkktLSxJJTJeYj09PSJhbHRlcm5hdGUtcmV2ZXJzZSImJihQPTEtUCxEPSEwKX1yZXR1cm57cDpQLGludmVydGVkOkR9fWZ1bmN0aW9uIGkocyxNLFAsUyl7dmFyIGI9e307cmV0dXJuKDAsVC5kZWZhdWx0KShNKS5mb3JFYWNoKGZ1bmN0aW9uKE8pe3ZhciBEPSgwLG8uZGVmYXVsdCkoTywyKSxJPURbMF0sUj1EWzFdO2lmKEkhPT0ib2Zmc2V0IiYmSSE9PSJlYXNpbmciKXt2YXIgQT1QW0ldfHxQLmRlZmF1bHQsVT1BKHNbSV0sUixTLHMub2Zmc2V0LE0ub2Zmc2V0KTtVIT1udWxsJiYoYltJXT1VKX19KSxifWZ1bmN0aW9uIG4ocyxNLFAsUyl7dmFyIGI9cy5lYXNpbmcsTz1zLmVmZmVjdDtPfHwoUD0oMCx1LmRlZmF1bHQpKHt9LHkuZGVmYXVsdCxQKSk7dmFyIEQ9e307Uz1iKFMsTSk7Zm9yKHZhciBJPTE7STxNLmxlbmd0aDtJKyspe3ZhciBSPU1bSV0sQT1SLm9mZnNldDtpZihBPj1TfHxJPT09TS5sZW5ndGgtMSl7dmFyIFU9TVtJLTFdLEs9VS5vZmZzZXQsVj1VLmVhc2luZyxRPVM7aWYoVil7dmFyIHE9QS1LO1E9VigoUy1LKS9xKSpxK0t9Tz9EPU8oVSxSLFEsSyxBKTpEPWkoVSxSLFAsUSk7YnJlYWt9fXJldHVybiBEfX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz17ZGVmYXVsdDp0KDIxMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKEwsZSx0KXt0KDIxMSksTC5leHBvcnRzPXQoOTIpLk9iamVjdC5lbnRyaWVzfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCksbz10KDIxMikoITApO2EoYS5TLCJPYmplY3QiLHtlbnRyaWVzOmZ1bmN0aW9uKFQpe3JldHVybiBvKFQpfX0pfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMDApLG89dCgxMTApLHY9dCg4NCksVD10KDE2OSkuZjtMLmV4cG9ydHM9ZnVuY3Rpb24oZCl7cmV0dXJuIGZ1bmN0aW9uKHUpe2Zvcih2YXIgYz12KHUpLEU9byhjKSxmPUUubGVuZ3RoLGc9MCx5PVtdLEM7Zj5nOylDPUVbZysrXSwoIWF8fFQuY2FsbChjLEMpKSYmeS5wdXNoKGQ/W0MsY1tDXV06Y1tDXSk7cmV0dXJuIHl9fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYT1uZXcgTWFwO2Z1bmN0aW9uIG8oVCxkPXt9LHU9W10pe1Q9VC50b0xvd2VyQ2FzZSgpO2NvbnN0IGM9YS5nZXQoVCk7aWYoIWMpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBub2RlOiAke1R9YCk7Y29uc3QgRT1uZXcgYyhkKTtyZXR1cm4gdS5mb3JFYWNoKGY9PntFLmFwcGVuZENoaWxkKGYpfSksRX1jb25zdCB2PXtyZWdpc3Rlck5vZGUoVCxkLHU9MTAwKXtpZihkPWQudG9Mb3dlckNhc2UoKSxhLmhhcyhkKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVnaXN0ZXJOb2RlLCAke2R9IGhhcyBiZWVuIHRha2VuLmApO2Euc2V0KGQsVCksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVC5wcm90b3R5cGUse25vZGVUeXBlOnt2YWx1ZTp1fSx0YWdOYW1lOnt2YWx1ZTpkLnRvVXBwZXJDYXNlKCl9LG5vZGVOYW1lOnt2YWx1ZTpkfSxvd25lckRvY3VtZW50Ont2YWx1ZTp2fSxuYW1lc3BhY2VVUkk6e3ZhbHVlOmBodHRwOi8vc3ByaXRlanMuY29tLyR7ZH1gfX0pfSxjcmVhdGVFbGVtZW50Om8sY3JlYXRlRWxlbWVudE5TKFQsZCl7cmV0dXJuIG8oZCl9LGlzU3ByaXRlTm9kZShUKXtyZXR1cm4gYS5oYXMoVC50b0xvd2VyQ2FzZSgpKX19O2UuZGVmYXVsdD12fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGE9U3ltYm9sKCJ0eXBlIiksbz1TeW1ib2woImJ1YmJsZXMiKSx2PVN5bWJvbCgib3JpZ2luYWxFdmVudCIpLFQ9U3ltYm9sKCJkZXRhaWwiKTtjbGFzcyBke2NvbnN0cnVjdG9yKGMse2J1YmJsZXM6RT1udWxsfT17fSl7aWYodHlwZW9mIGM9PSJzdHJpbmciPyh0aGlzW2FdPWMsdGhpc1tvXT0hIUUpOih0aGlzW2FdPWMudHlwZSx0aGlzW3ZdPWMsdGhpc1tvXT1FIT1udWxsPyEhRTohIWMuYnViYmxlcyxjLmRldGFpbCYmKHRoaXNbVF09Yy5kZXRhaWwpKSwhdGhpc1thXSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGV2ZW50IHR5cGUuIik7dGhpcy5jYW5jZWxCdWJibGU9ITF9c2V0T3JpZ2luYWxFdmVudChjKXt0aGlzW3ZdPWN9Z2V0IG9yaWdpbmFsRXZlbnQoKXtyZXR1cm4gdGhpc1t2XX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW2FdfWdldCBidWJibGVzKCl7cmV0dXJuIHRoaXNbb119Z2V0IGRldGFpbCgpe3JldHVybiB0aGlzW1RdfXN0b3BQcm9wYWdhdGlvbigpe3RoaXMuY2FuY2VsQnViYmxlPSEwfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsInBhcnNlRmlsdGVyU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBvfSksdC5kKGUsImFwcGx5RmlsdGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pO3ZhciBhPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBvKFQpe2lmKFQ9VC50cmltKCksIVR8fFQ9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgZD0vXig/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSskL2ksdT1ULm1hdGNoKC8oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrPy9pZyksYz1bXTtyZXR1cm4gdSYmdS5mb3JFYWNoKEU9Pntjb25zdCBmPUUubWF0Y2goZCk7aWYoIWYpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaXRsZXIgc3RyaW5nLiIpO2xldFssZyx5XT1mO2c9Zy50b0xvd2VyQ2FzZSgpLHk9eS50cmltKCkubWF0Y2goLyhbXiggKV0rfChbXiggKV0rXCguKlwpKSkoPz1cc3wkKS9nKS5tYXAoKEMseCk9PntsZXQgaDtyZXR1cm4gZz09PSJ1cmwifHxnPT09ImRyb3Atc2hhZG93IiYmeD09PTM/aD1DOmg9T2JqZWN0KGEudG9OdW1iZXIpKEMpLC8lJC8udGVzdChDKSYmKGgvPTEwMCksaH0pLGMucHVzaCh7dHlwZTpnLGFyZ3M6eX0pfSksY31mdW5jdGlvbiB2KFQsZCl7VC5jbGVhckZpbHRlcigpLGQmJmQuZm9yRWFjaCgoe3R5cGU6dSxhcmdzOmN9KT0+e2xldCBFPXU7RT09PSJkcm9wLXNoYWRvdyI/RT0iZHJvcFNoYWRvdyI6RT09PSJodWUtcm90YXRlIiYmKEU9Imh1ZVJvdGF0ZSIpLFRbRV0oLi4uYyl9KX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShvLHYpe2lmKCF2KXJldHVybjtjb25zdCBUPW8uZ2V0TGlzdGVuZXJzKCJiZWZvcmVyZW5kZXIiKSxkPW8uZ2V0TGlzdGVuZXJzKCJhZnRlcnJlbmRlciIpO1QubGVuZ3RoJiYhdi5iZWZvcmVSZW5kZXI/di5iZWZvcmVSZW5kZXI9dT0+e28uZGlzcGF0Y2hFdmVudCh7dHlwZToiYmVmb3JlcmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6dX19KX06VC5sZW5ndGh8fCh2LmJlZm9yZVJlbmRlcj1udWxsKSxkLmxlbmd0aCYmIXYuYWZ0ZXJSZW5kZXI/di5hZnRlclJlbmRlcj11PT57by5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhZnRlcnJlbmRlciIsZGV0YWlsOntjb250ZXh0OnV9fSl9OmQubGVuZ3RofHwodi5hZnRlclJlbmRlcj1udWxsKX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgYT10KDEyKSxvPXQoMjE4KSx2PXQoNzApLFQ9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBkPVN5bWJvbCgiYW1vdW50IiksdT1TeW1ib2woIm1lc2hDbG91ZCIpO2NsYXNzIGMgZXh0ZW5kcyB2LmRlZmF1bHR7Y29uc3RydWN0b3IoZixnPTEpe3N1cGVyKCksdGhpcy5tZXNoTm9kZT1mLGYuY29ubmVjdCh0aGlzKSx0aGlzW2RdPWcsdGhpc1t1XT1udWxsfWdldCBtZXNoQ2xvdWQoKXtjb25zdCBmPXRoaXMubWVzaE5vZGUsZz10aGlzW2RdO3JldHVybiF0aGlzW3VdJiZmLm1lc2gmJih0aGlzW3VdPW5ldyBhLk1lc2hDbG91ZChmLm1lc2gsZykpLHRoaXNbdV19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5tZXNoTm9kZSYmdGhpcy5tZXNoTm9kZS5pc1Zpc2libGV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2RdfXNldCBhbW91bnQoZil7dGhpc1tkXT1mLHRoaXNbdV0mJih0aGlzW3VdLmFtb3VudD1mKX1icmlnaHRuZXNzKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5icmlnaHRuZXNzKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1jb250cmFzdChmLGcpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuY29udHJhc3QoZixnKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRlbGV0ZShmKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmRlbGV0ZShmKSx0aGlzW2RdLS0sdGhpcy5mb3JjZVVwZGF0ZSgpKX1kcmF3KGY9W10pe2lmKHN1cGVyLmRyYXcoZiksdGhpcy5tZXNoQ2xvdWQpe2lmKHRoaXMucHJvZ3JhbSl7dGhpcy5tZXNoQ2xvdWQuc2V0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO2NvbnN0IGc9dGhpcy5zaGFkZXJBdHRycztnJiZPYmplY3QuZW50cmllcyhnKS5mb3JFYWNoKChbQyx4XSk9Pnt0aGlzLm1lc2hDbG91ZC5tZXNoLnNldEF0dHJpYnV0ZShDLHgpfSk7Y29uc3QgeT10aGlzLnVuaWZvcm1zO2lmKHRoaXMudW5pZm9ybXMpe2NvbnN0IEM9e307T2JqZWN0LmVudHJpZXMoeSkuZm9yRWFjaCgoW3gsaF0pPT57dHlwZW9mIGg9PSJmdW5jdGlvbiImJihoPWgodGhpcyx4KSksQ1t4XT1ofSksdGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRVbmlmb3JtcyhDKX19dGhpcy5tZXNoTm9kZS50ZXh0dXJlSW1hZ2UmJk9iamVjdChvLmRyYXdUZXh0dXJlKSh0aGlzLm1lc2hOb2RlLHRoaXMubWVzaE5vZGUubWVzaCksZi5wdXNoKHRoaXMubWVzaENsb3VkKX1yZXR1cm4gZn1nZXRUcmFuc2Zvcm0oZil7aWYodGhpcy5tZXNoQ2xvdWQpcmV0dXJuIHRoaXMubWVzaENsb3VkLmdldFRyYW5zZm9ybShmKX1ncmF5c2NhbGUoZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmdyYXlzY2FsZShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9aHVlUm90YXRlKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5odWVSb3RhdGUoZixnKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWludmVydChmLGcpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaW52ZXJ0KGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pc1BvaW50Q29sbGlzaW9uKGYsZyl7aWYoIXRoaXMubWVzaENsb3VkKXJldHVybiExO2NvbnN0IHk9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoeT09PSJub25lInx8eSE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IEM9ImJvdGgiO3k9PT0idmlzaWJsZUZpbGwiJiYoQz0iZmlsbCIpLHk9PT0idmlzaWJsZVN0cm9rZSImJihDPSJzdHJva2UiKTtmb3IobGV0IHg9MDt4PHRoaXNbZF07eCsrKWlmKCF0aGlzLm1lc2hDbG91ZC5pc1BvaW50Q29sbGlzaW9uKHgsW2YsZ10sQykpcmV0dXJuITE7cmV0dXJuITB9c2V0T3BhY2l0eShmLGcpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQub3BhY2l0eShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9cm90YXRlKGYsZyxbeSxDXT1bMCwwXSl7Y29uc3QgeD1NYXRoLlBJKmcvMTgwO2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OmgseTptfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQucm90YXRlKGYseCxbeStoLEMrbV0pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2F0dXJhdGUoZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNhdHVyYXRlKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zY2FsZShmLFtnLHk9Z10sW0MseF09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OmgseTptfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXMscj0xZS01O01hdGguYWJzKGcpPHImJihnPTEvZz4wP3I6LXIpLE1hdGguYWJzKHkpPHImJih5PTEveT4wP3I6LXIpLHRoaXMubWVzaENsb3VkLnNjYWxlKGYsW2cseV0sW0MraCx4K21dKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNldENvbG9yVHJhbnNmb3JtKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRDb2xvclRyYW5zZm9ybShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0RmlsbENvbG9yKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KGcpJiYoZz1bLi4uZ10sZ1swXS89MjU1LGdbMV0vPTI1NSxnWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldEZpbGxDb2xvcihmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2VwaWEoZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNlcGlhKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpmLGhlaWdodDpnfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6Z30pLHRoaXMubWVzaE5vZGUuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6Z30pfXNldFN0cm9rZUNvbG9yKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KGcpJiYoZz1bLi4uZ10sZ1swXS89MjU1LGdbMV0vPTI1NSxnWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldFN0cm9rZUNvbG9yKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRUcmFuc2Zvcm0oZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldFRyYW5zZm9ybShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2tldyhmLFtnLHk9Z10sW0MseF09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OmgseTptfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQuc2tldyhmLFtnLHldLFtDK2gseCttXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX10cmFuc2Zvcm0oZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNmb3JtQ29sb3IoZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybUNvbG9yKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2xhdGUoZixbZyx5XSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2xhdGUoZixbZyx5XSksdGhpcy5mb3JjZVVwZGF0ZSgpKX11cGRhdGVNZXNoKCl7dGhpc1t1XSYmKHRoaXNbdV0ubWVzaD10aGlzLm1lc2hOb2RlLm1lc2gsdGhpcy5mb3JjZVVwZGF0ZSgpKX19VC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJjbG91ZCIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJsb2FkVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJhcHBseVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiY3JlYXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJkZWxldGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImRyYXdUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImxvYWRGcmFtZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgYT10KDEyKSxvPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB2PXt9O2Z1bmN0aW9uIFQoQyx4KXtpZih2W0NdKXJldHVybiB2W0NdO2NvbnN0IGg9YS5FTlYubG9hZEltYWdlKEMse2FsaWFzOngsdXNlSW1hZ2VCaXRtYXA6ITF9KTtyZXR1cm4gaD8/Q31hc3luYyBmdW5jdGlvbiBkKEMseCxoKXtsZXQgbT14O2lmKHR5cGVvZiB4PT0ic3RyaW5nIiYmKG09VCh4KSksbSYmdHlwZW9mIG0udGhlbj09ImZ1bmN0aW9uIiYmKG09YXdhaXQgbSkseD09PUMuYXR0cmlidXRlcy50ZXh0dXJlKXttJiZtLmltYWdlJiYobS5zb3VyY2VSZWN0JiYoQy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q9bS5zb3VyY2VSZWN0KSxDLnRleHR1cmVJbWFnZVJvdGF0ZWQ9ISFtLnJvdGF0ZWQsbT1tLmltYWdlKTtjb25zdHt3aWR0aDpyLGhlaWdodDppLHRleHR1cmVSZWN0Om59PUMuYXR0cmlidXRlcyxzPUMudGV4dHVyZUltYWdlO0MudGV4dHVyZUltYWdlPW0saCYmcyE9PW0mJiFuJiYocj09bnVsbHx8aT09bnVsbCkmJkMudXBkYXRlQ29udG91cnMoKSxDLmZvcmNlVXBkYXRlKCl9cmV0dXJuIG19Y29uc3QgdT1TeW1ib2woInRleHR1cmVNYXAiKTtmdW5jdGlvbiBjKEMseCl7aWYoeFt1XT14W3VdfHxuZXcgTWFwLHhbdV0uaGFzKEMpKXJldHVybiB4W3VdLmdldChDKTtjb25zdCBoPXguY3JlYXRlVGV4dHVyZShDKTtyZXR1cm4hL15ibG9iOi8udGVzdChDLnNyYykmJnR5cGVvZiBDLmdldENvbnRleHQhPSJmdW5jdGlvbiImJnhbdV0uc2V0KEMsaCksaH1mdW5jdGlvbiBFKEMseCl7aWYoeFt1XSYmeFt1XS5oYXMoQykpe2NvbnN0IGg9eFt1XS5nZXQoQyk7cmV0dXJuIHguZGVsZXRlVGV4dHVyZShoKSx4W3VdLmRlbGV0ZShDKSwhMH1yZXR1cm4hMX1jb25zdCBmPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKTtmdW5jdGlvbiBnKEMseCl7Y29uc3QgaD1DLnRleHR1cmVJbWFnZSBpbnN0YW5jZW9mIFN0cmluZz9TdHJpbmcoQy50ZXh0dXJlSW1hZ2UpOkMudGV4dHVyZUltYWdlLG09Qy50ZXh0dXJlSW1hZ2VSb3RhdGVkLHI9eC50ZXh0dXJlLGk9Qy5yZW5kZXJlcjtpZihoKXtjb25zdCBuPUMub3JpZ2luYWxDb250ZW50UmVjdDtsZXQgcz1DLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q7Y29uc3QgTT1DLmF0dHJpYnV0ZXMudGV4dHVyZVJlcGVhdCxQPUMuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKCFyfHxDW2ZdJiZDW2ZdIT09aXx8ci5pbWFnZSE9PWh8fHIub3B0aW9ucy5yZXBlYXQhPT1NfHwhT2JqZWN0KG8uY29tcGFyZVZhbHVlKShyLm9wdGlvbnMucmVjdCxzKXx8IU9iamVjdChvLmNvbXBhcmVWYWx1ZSkoci5vcHRpb25zLnNyY1JlY3QsUCkpe2NvbnN0IFM9YyhoLGkpO3M/KHNbMF0rPW5bMF0sc1sxXSs9blsxXSk6cz1uO2xldCBiPW51bGw7ciYmIWlbdV0uaGFzKHIuaW1hZ2UpJiYoIXIub3B0aW9uc3x8IXIub3B0aW9ucy5oaWRkZW4pJiYoYj14LnVuaWZvcm1zLnVfdGV4U2FtcGxlcikseC5zZXRUZXh0dXJlKFMse3JlY3Q6cyxyZXBlYXQ6TSxzcmNSZWN0OlAscm90YXRlZDptfSksYiYmYi5kZWxldGUmJmIuZGVsZXRlKCksQ1tmXT1pfX1lbHNlIGlmKHIpe2xldCBuPW51bGw7IWlbdV0uaGFzKHIuaW1hZ2UpJiYoIXIub3B0aW9uc3x8IXIub3B0aW9ucy5oaWRkZW4pJiYobj14LnVuaWZvcm1zLnVfdGV4U2FtcGxlcikseC5zZXRUZXh0dXJlKG51bGwpLG4mJm4uZGVsZXRlJiZuLmRlbGV0ZSgpfX1hc3luYyBmdW5jdGlvbiB5KEMseCl7dHlwZW9mIHg9PSJzdHJpbmciJiYoeD1hd2FpdChhd2FpdCBmZXRjaCh4LHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkpLmpzb24oKSk7Y29uc3QgaD1hd2FpdCBUKEMpLG09eC5mcmFtZXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKG0pLmZvckVhY2goKFtyLGldKT0+e2NvbnN0e3g6bix5OnMsdzpNLGg6UH09aS5mcmFtZTtsZXQgUz1bbixzLE0sUF07Y29uc3QgYj1pLnJvdGF0ZWQ7YiYmKFM9W1NbMF0sU1sxXSxTWzNdLFNbMl1dKSx2W3JdPXtpbWFnZTpoLHNvdXJjZVJlY3Q6Uyxyb3RhdGVkOmJ9fSksaH19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgYT10KDEpLG89dCgxMiksdj10KDcwKSxUPXQoMjIwKSxkPXQoMjIxKSx1PXQoMjIyKSxjPXQoMjEzKSxFPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZihDLHgsaCl7cmV0dXJuIHggaW4gQz9PYmplY3QuZGVmaW5lUHJvcGVydHkoQyx4LHt2YWx1ZTpoLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Q1t4XT1oLEN9Y29uc3QgZz1TeW1ib2woIm1lc2giKTtjbGFzcyB5IGV4dGVuZHMgdi5kZWZhdWx0e2NvbnN0cnVjdG9yKHg9e30pe3N1cGVyKHgpfWdldCBib3JkZXJTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDp4LHBhZGRpbmdSaWdodDpoLHBhZGRpbmdCb3R0b206bSxwYWRkaW5nTGVmdDpyLGJvcmRlcldpZHRoOml9PXRoaXMuYXR0cmlidXRlcyxbbixzXT10aGlzLmNvbnRlbnRTaXplO3JldHVybltyK24raCtpLHgrcyttK2ldfWdldCBjbGllbnRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDp4LHBhZGRpbmdSaWdodDpoLHBhZGRpbmdCb3R0b206bSxwYWRkaW5nTGVmdDpyfT10aGlzLmF0dHJpYnV0ZXMsW2ksbl09dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bcitpK2gseCtuK21dfWdldCBjb250ZW50U2l6ZSgpe2xldHt3aWR0aDp4LGhlaWdodDpoLGJveFNpemluZzptLHBhZGRpbmdUb3A6cixwYWRkaW5nUmlnaHQ6aSxwYWRkaW5nQm90dG9tOm4scGFkZGluZ0xlZnQ6c309dGhpcy5hdHRyaWJ1dGVzO2lmKHg9eHx8MCxoPWh8fDAsbT09PSJib3JkZXItYm94Iil7Y29uc3QgTT0yKnRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDt4LT1NK2krcyxoLT1NK3Irbix4PU1hdGgubWF4KDAseCksaD1NYXRoLm1heCgwLGgpfXJldHVyblt4LGhdfWdldCBoYXNCb3JkZXIoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoPjB9Z2V0IGlzVmlzaWJsZSgpe2NvbnN0W3gsaF09dGhpcy5ib3JkZXJTaXplO3JldHVybiB4PjAmJmg+MH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IHg9dGhpcy5jbGllbnRCb3g7aWYoeCl7bGV0IGg9dGhpc1tnXTtpZihoKWguYm94IT09eCYmKGguY29udG91cnM9eC5jb250b3VycyxoLmJveD14KTtlbHNle2g9bmV3IG8uTWVzaDJEKHgpLGguYm94PXg7Y29uc3Qgcj10aGlzLmF0dHJpYnV0ZXMuYmdjb2xvcjtpZihPYmplY3QoZC5zZXRGaWxsQ29sb3IpKGgse2NvbG9yOnJ9KSx0aGlzLmhhc0JvcmRlcil7Y29uc3R7Ym9yZGVyQ29sb3I6bixib3JkZXJXaWR0aDpzLGJvcmRlckRhc2g6TSxib3JkZXJEYXNoT2Zmc2V0OlB9PXRoaXMuYXR0cmlidXRlcztPYmplY3QoZC5zZXRTdHJva2VDb2xvcikoaCx7Y29sb3I6bixsaW5lV2lkdGg6cyxsaW5lRGFzaDpNLGxpbmVEYXNoT2Zmc2V0OlB9KX10aGlzW2ddPWg7Y29uc3QgaT10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7aSYmdGhpc1tnXS5zZXRDbGlwUGF0aChpKX1jb25zdCBtPXRoaXMub3BhY2l0eTtyZXR1cm4gaC5nZXRPcGFjaXR5KCkhPT1tJiZoLnNldE9wYWNpdHkobSksaC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLGh9cmV0dXJuIG51bGx9Z2V0IG9mZnNldFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOngscGFkZGluZ1JpZ2h0OmgscGFkZGluZ0JvdHRvbTptLHBhZGRpbmdMZWZ0OnIsYm9yZGVyV2lkdGg6aX09dGhpcy5hdHRyaWJ1dGVzLFtuLHNdPXRoaXMuY29udGVudFNpemUsTT0yKmk7cmV0dXJuW3IrbitoK00seCtzK20rTV19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgeD10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW3hbMF1bMF0seFswXVsxXSx4WzFdWzBdLXhbMF1bMF0seFsxXVsxXS14WzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtjb25zdFt4LGgsbSxyXT10aGlzLm9yaWdpbmFsQ2xpZW50UmVjdCxpPXRoaXMuYXR0cmlidXRlcy5wYWRkaW5nO3JldHVyblt4K2lbMF0saCtpWzFdLG0taVswXS1pWzJdLHItaVsxXS1pWzNdXX1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgeD10aGlzLnJlbmRlck1hdHJpeDt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLmxheWVyVHJhbnNmb3JtSW52ZXJ0JiYoeD1hLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLmxheWVyLnRyYW5zZm9ybU1hdHJpeCx4KSk7bGV0IGg9bnVsbDtpZih0aGlzLm1lc2gpe2g9Wy4uLnRoaXMubWVzaC5ib3VuZGluZ0JveF07Y29uc3QgbT10aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7bSYmKGhbMF09W2hbMF1bMF0tbSxoWzBdWzFdLW1dLGhbMV09W2hbMV1bMF0rbSxoWzFdWzFdK21dKX1yZXR1cm4gT2JqZWN0KEUuZGVmYXVsdCkoaCx4KX1vblByb3BlcnR5Q2hhbmdlKHgsaCxtKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKHgsaCxtKSwoeD09PSJhbmNob3JYInx8eD09PSJhbmNob3JZInx8eD09PSJib3hTaXppbmcifHx4PT09IndpZHRoInx8eD09PSJoZWlnaHQifHx4PT09ImJvcmRlcldpZHRoInx8eD09PSJwYWRkaW5nTGVmdCJ8fHg9PT0icGFkZGluZ1JpZ2h0Inx8eD09PSJwYWRkaW5nVG9wInx8eD09PSJwYWRkaW5nQm90dG9tInx8L15ib3JkZXIoVG9wTGVmdHxUb3BSaWdodHxCb3R0b21SaWdodHxCb3R0b21MZWZ0KVJhZGl1cyQvLnRlc3QoeCkpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1tnXSYmeD09PSJjbGlwUGF0aCImJnRoaXNbZ10uc2V0Q2xpcFBhdGgoaCksdGhpc1tnXSYmeD09PSJiZ2NvbG9yIiYmT2JqZWN0KGQuc2V0RmlsbENvbG9yKSh0aGlzW2ddLHtjb2xvcjpofSksdGhpc1tnXSYmKHg9PT0iYm9yZGVyQ29sb3IifHx4PT09ImJvcmRlcldpZHRoInx8eD09PSJib3JkZXJEYXNoInx8eD09PSJib3JkZXJEYXNoT2Zmc2V0Iikpe2NvbnN0e2JvcmRlckNvbG9yOnIsYm9yZGVyV2lkdGg6aSxib3JkZXJEYXNoOm4sYm9yZGVyRGFzaE9mZnNldDpzfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGQuc2V0U3Ryb2tlQ29sb3IpKHRoaXNbZ10se2NvbG9yOnIsbGluZVdpZHRoOmksbGluZURhc2g6aT9uOjAsbGluZURhc2hPZmZzZXQ6c30pfX11cGRhdGVDb250b3Vycygpe2NvbnN0e2FuY2hvclg6eCxhbmNob3JZOmgsYm9yZGVyV2lkdGg6bSxib3JkZXJSYWRpdXM6cn09dGhpcy5hdHRyaWJ1dGVzLFtpLG5dPXRoaXMuYm9yZGVyU2l6ZSxzPXRoaXMub2Zmc2V0U2l6ZSxNPS41Km0sUD0teCpzWzBdK00sUz0taCpzWzFdK007dGhpcy5jbGllbnRCb3g9bmV3IG8uRmlndXJlMkQsT2JqZWN0KHUuY3JlYXRlUmFkaXVzQm94KSh0aGlzLmNsaWVudEJveCxbUCxTLGksbl0scil9fWYoeSwiQXR0ciIsVC5kZWZhdWx0KSxjLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHksImJsb2NrIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KTt2YXIgYT10KDcxKSxvPXQoNzIpLHY9dCgyMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyBFIGV4dGVuZHMgYS5kZWZhdWx0e2NvbnN0cnVjdG9yKGcpe3N1cGVyKGcpLHRoaXNbdV0oe2FuY2hvclg6MCxhbmNob3JZOjAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsYm9yZGVyV2lkdGg6MCxib3JkZXJDb2xvcjoicmdiYSgwLDAsMCwxKSIsYm9yZGVyRGFzaDp2b2lkIDAsYm9yZGVyRGFzaE9mZnNldDowLGJvcmRlclRvcExlZnRSYWRpdXM6WzAsMF0sYm9yZGVyVG9wUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tTGVmdFJhZGl1czpbMCwwXSxiZ2NvbG9yOiJyZ2JhKDAsMCwwLDApIixwYWRkaW5nVG9wOjAscGFkZGluZ1JpZ2h0OjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsY2xpcFBhdGg6dm9pZCAwfSksdGhpc1tjXSgiYW5jaG9yIiwic2l6ZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciKX1nZXQgYW5jaG9yWCgpe3JldHVybiB0aGlzW2RdKCJhbmNob3JYIil9c2V0IGFuY2hvclgoZyl7dGhpc1tUXSgiYW5jaG9yWCIsT2JqZWN0KG8udG9OdW1iZXIpKGcpKX1nZXQgYW5jaG9yWSgpe3JldHVybiB0aGlzW2RdKCJhbmNob3JZIil9c2V0IGFuY2hvclkoZyl7dGhpc1tUXSgiYW5jaG9yWSIsT2JqZWN0KG8udG9OdW1iZXIpKGcpKX1nZXQgYW5jaG9yKCl7cmV0dXJuW3RoaXMuYW5jaG9yWCx0aGlzLmFuY2hvclldfXNldCBhbmNob3IoZyl7Zz1PYmplY3Qoby50b0FycmF5KShnKSxBcnJheS5pc0FycmF5KGcpfHwoZz1bZyxnXSksdGhpcy5hbmNob3JYPWdbMF0sdGhpcy5hbmNob3JZPWdbMV19Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbZF0oIndpZHRoIil9c2V0IHdpZHRoKGcpe3RoaXNbVF0oIndpZHRoIixPYmplY3Qoby50b051bWJlcikoZykpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1tkXSgiaGVpZ2h0Iil9c2V0IGhlaWdodChnKXt0aGlzW1RdKCJoZWlnaHQiLE9iamVjdChvLnRvTnVtYmVyKShnKSl9Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUoZyl7Zz1PYmplY3Qoby50b0FycmF5KShnKSxBcnJheS5pc0FycmF5KGcpfHwoZz1bZyxnXSksdGhpcy53aWR0aD1nWzBdLHRoaXMuaGVpZ2h0PWdbMV19Z2V0IGJvcmRlcldpZHRoKCl7cmV0dXJuIHRoaXNbZF0oImJvcmRlcldpZHRoIil9c2V0IGJvcmRlcldpZHRoKGcpe3RoaXNbVF0oImJvcmRlcldpZHRoIixPYmplY3Qoby50b051bWJlcikoZykpfWdldCBib3JkZXJDb2xvcigpe3JldHVybiB0aGlzW2RdKCJib3JkZXJDb2xvciIpfXNldCBib3JkZXJDb2xvcihnKXt0aGlzW1RdKCJib3JkZXJDb2xvciIsT2JqZWN0KHYucGFyc2VDb2xvcikoZykpfWdldCBib3JkZXIoKXtyZXR1cm5bdGhpcy5ib3JkZXJXaWR0aCx0aGlzLmJvcmRlckNvbG9yXX1zZXQgYm9yZGVyKGcpe2c9T2JqZWN0KG8udG9BcnJheSkoZyksQXJyYXkuaXNBcnJheShnKXx8KGc9W2ddKSx0aGlzLmJvcmRlcldpZHRoPWdbMF0sZ1sxXSE9bnVsbCYmKHRoaXMuYm9yZGVyQ29sb3I9Z1sxXSl9Z2V0IGJvcmRlckRhc2goKXtyZXR1cm4gdGhpc1tkXSgiYm9yZGVyRGFzaCIpfXNldCBib3JkZXJEYXNoKGcpe2c9T2JqZWN0KG8udG9BcnJheSkoZywhMCksZyE9bnVsbCYmIUFycmF5LmlzQXJyYXkoZykmJihnPVtnXSksdGhpc1tUXSgiYm9yZGVyRGFzaCIsZz9nLm1hcChvLnRvTnVtYmVyKTpudWxsKX1nZXQgYm9yZGVyRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW2RdKCJib3JkZXJEYXNoT2Zmc2V0Iil9c2V0IGJvcmRlckRhc2hPZmZzZXQoZyl7dGhpc1tUXSgiYm9yZGVyRGFzaE9mZnNldCIsT2JqZWN0KG8udG9OdW1iZXIpKGcpKX1nZXQgYm9yZGVyVG9wTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW2RdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIil9c2V0IGJvcmRlclRvcExlZnRSYWRpdXMoZyl7Zz1PYmplY3Qoby50b0FycmF5KShnLCEwKSxBcnJheS5pc0FycmF5KGcpfHwoZz1bZyxnXSksdGhpc1tUXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIsZy5tYXAoby50b051bWJlcikpfWdldCBib3JkZXJUb3BSaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2RdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIpfXNldCBib3JkZXJUb3BSaWdodFJhZGl1cyhnKXtnPU9iamVjdChvLnRvQXJyYXkpKGcsITApLEFycmF5LmlzQXJyYXkoZyl8fChnPVtnLGddKSx0aGlzW1RdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIsZy5tYXAoby50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2RdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyhnKXtnPU9iamVjdChvLnRvQXJyYXkpKGcsITApLEFycmF5LmlzQXJyYXkoZyl8fChnPVtnLGddKSx0aGlzW1RdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIsZy5tYXAoby50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbZF0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyhnKXtnPU9iamVjdChvLnRvQXJyYXkpKGcsITApLEFycmF5LmlzQXJyYXkoZyl8fChnPVtnLGddKSx0aGlzW1RdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIixnLm1hcChvLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclJhZGl1cygpe3JldHVyblsuLi50aGlzLmJvcmRlclRvcExlZnRSYWRpdXMsLi4udGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1c119c2V0IGJvcmRlclJhZGl1cyhnKXtpZihnPU9iamVjdChvLnRvQXJyYXkpKGcpLCFBcnJheS5pc0FycmF5KGcpKWc9QXJyYXkoOCkuZmlsbChnKTtlbHNlIGlmKGcubGVuZ3RoPT09MilnPVtnWzBdLGdbMV0sZ1swXSxnWzFdLGdbMF0sZ1sxXSxnWzBdLGdbMV1dO2Vsc2UgaWYoZy5sZW5ndGg9PT00KWc9W2dbMF0sZ1sxXSxnWzJdLGdbM10sZ1swXSxnWzFdLGdbMl0sZ1szXV07ZWxzZSBpZihnLmxlbmd0aD09PTYpZz1bZ1swXSxnWzFdLGdbMl0sZ1szXSxnWzRdLGdbNV0sZ1syXSxnWzNdXTtlbHNlIGlmKGcubGVuZ3RoIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJvcmRlclJhZGl1cyB2YWx1ZS4iKTt0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9W2dbMF0sZ1sxXV0sdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cz1bZ1syXSxnWzNdXSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPVtnWzRdLGdbNV1dLHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1bZ1s2XSxnWzddXX1nZXQgYmdjb2xvcigpe3JldHVybiB0aGlzW2RdKCJiZ2NvbG9yIil9c2V0IGJnY29sb3IoZyl7dGhpc1tUXSgiYmdjb2xvciIsT2JqZWN0KHYucGFyc2VDb2xvcikoZykpfWdldCBwYWRkaW5nVG9wKCl7cmV0dXJuIHRoaXNbZF0oInBhZGRpbmdUb3AiKX1zZXQgcGFkZGluZ1RvcChnKXt0aGlzW1RdKCJwYWRkaW5nVG9wIixPYmplY3Qoby50b051bWJlcikoZykpfWdldCBwYWRkaW5nUmlnaHQoKXtyZXR1cm4gdGhpc1tkXSgicGFkZGluZ1JpZ2h0Iil9c2V0IHBhZGRpbmdSaWdodChnKXt0aGlzW1RdKCJwYWRkaW5nUmlnaHQiLE9iamVjdChvLnRvTnVtYmVyKShnKSl9Z2V0IHBhZGRpbmdCb3R0b20oKXtyZXR1cm4gdGhpc1tkXSgicGFkZGluZ0JvdHRvbSIpfXNldCBwYWRkaW5nQm90dG9tKGcpe3RoaXNbVF0oInBhZGRpbmdCb3R0b20iLE9iamVjdChvLnRvTnVtYmVyKShnKSl9Z2V0IHBhZGRpbmdMZWZ0KCl7cmV0dXJuIHRoaXNbZF0oInBhZGRpbmdMZWZ0Iil9c2V0IHBhZGRpbmdMZWZ0KGcpe3RoaXNbVF0oInBhZGRpbmdMZWZ0IixPYmplY3Qoby50b051bWJlcikoZykpfWdldCBwYWRkaW5nKCl7cmV0dXJuW3RoaXMucGFkZGluZ1RvcCx0aGlzLnBhZGRpbmdSaWdodCx0aGlzLnBhZGRpbmdCb3R0b20sdGhpcy5wYWRkaW5nTGVmdF19c2V0IHBhZGRpbmcoZyl7Zz1PYmplY3Qoby50b0FycmF5KShnKSxBcnJheS5pc0FycmF5KGcpP2cubGVuZ3RoPT09Mj9nPVtnWzBdLGdbMV0sZ1swXSxnWzFdXTpnLmxlbmd0aD09PTMmJihnPVtnWzBdLGdbMV0sZ1syXSxnWzFdXSk6Zz1bZyxnLGcsZ10sdGhpcy5wYWRkaW5nVG9wPWdbMF0sdGhpcy5wYWRkaW5nUmlnaHQ9Z1sxXSx0aGlzLnBhZGRpbmdCb3R0b209Z1syXSx0aGlzLnBhZGRpbmdMZWZ0PWdbM119Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbZF0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKGcpe3RoaXNbVF0oImNsaXBQYXRoIixnKX1nZXQgYm94U2l6aW5nKCl7cmV0dXJuIHRoaXNbZF0oImJveFNpemluZyIpfXNldCBib3hTaXppbmcoZyl7aWYoZyE9bnVsbCYmZyE9PSJib3JkZXItYm94IiYmZyE9PSJjb250ZW50LWJveCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3hTaXppbmcgdHlwZS4iKTt0aGlzW1RdKCJib3hTaXppbmciLGcpfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImlzVHJhbnNwYXJlbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJzZXRGaWxsQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2V0U3Ryb2tlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgYT10KDMyKSxvPXQubihhKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3Mgdntjb25zdHJ1Y3Rvcih7dmVjdG9yOnksY29sb3JzOkN9KXtpZighQXJyYXkuaXNBcnJheSh5KXx8eS5sZW5ndGghPT00JiZ5Lmxlbmd0aCE9PTYmJnkubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGdyYWRpZW50Iik7dGhpcy52ZWN0b3I9eSx0aGlzLmNvbG9ycz1DLm1hcCgoe29mZnNldDp4LGNvbG9yOmh9KT0+KHtvZmZzZXQ6eCxjb2xvcjpkKGgpfSkpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt2ZWN0b3I6dGhpcy52ZWN0b3IsY29sb3JzOnRoaXMuY29sb3JzfSl9fWZ1bmN0aW9uIFQoZyl7cmV0dXJuIGcgaW5zdGFuY2VvZiB2PyExOmc9PW51bGw/ITA6bygpKGcpWzNdPT09MH1mdW5jdGlvbiBkKGcpe2lmKGc9PW51bGx8fChnfHwoZz0idHJhbnNwYXJlbnQiKSxnIGluc3RhbmNlb2YgdikpcmV0dXJuIGc7Y29uc3QgeT1vKCkoZyk7aWYoIXl8fCF5Lmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybmByZ2JhKCR7eS5qb2luKCl9KWB9ZnVuY3Rpb24gdShnLHksQyl7Y29uc3QgeD1nLmJvdW5kaW5nQm94WzBdO2lmKEMudmVjdG9yKXtsZXR7dmVjdG9yOmgsY29sb3JzOm19PUM7aC5sZW5ndGg9PT00PyhoPVtoWzBdK3hbMF0saFsxXSt4WzFdLGhbMl0reFswXSxoWzNdK3hbMV1dLGcuc2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjpoLGNvbG9yczptLHR5cGU6eX0pKTpoLmxlbmd0aD09PTM/KGg9W2hbMF0reFswXSxoWzFdK3hbMV0saFsyXV0sZy5zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6aCxjb2xvcnM6bSx0eXBlOnl9KSk6KGg9W2hbMF0reFswXSxoWzFdK3hbMV0saFsyXSxoWzNdK3hbMF0saFs0XSt4WzFdLGhbNV1dLGcuc2V0UmFkaWFsR3JhZGllbnQoe3ZlY3RvcjpoLGNvbG9yczptLHR5cGU6eX0pKX1lbHNlIGcuZ3JhZGllbnQmJmcuZ3JhZGllbnRbeV0mJihkZWxldGUgZy5ncmFkaWVudFt5XSxkZWxldGUgZy51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yKX1mdW5jdGlvbiBjKGcse2NvbG9yOnkscnVsZTpDPSJub256ZXJvIn0pe3JldHVybiB1KGcsImZpbGwiLHkpLHkudmVjdG9yfHxnLnNldEZpbGwoe2NvbG9yOnkscnVsZTpDfSksZ31mdW5jdGlvbiBFKGcse2NvbG9yOnksbGluZVdpZHRoOkMsbGluZUNhcDp4LGxpbmVKb2luOmgsbGluZURhc2g6bSxsaW5lRGFzaE9mZnNldDpyLG1pdGVyTGltaXQ6aSxyb3VuZFNlZ21lbnRzOm59KXt1KGcsInN0cm9rZSIseSkseS52ZWN0b3ImJih5PVswLDAsMCwxXSksZy5zZXRTdHJva2Uoe2NvbG9yOnksdGhpY2tuZXNzOkMsY2FwOngsam9pbjpoLG1pdGVyTGltaXQ6aSxsaW5lRGFzaDptLGxpbmVEYXNoT2Zmc2V0OnIscm91bmRTZWdtZW50czpufSl9Y2xhc3MgZiBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKHk9MCxDPTAseD0wLGg9MCl7cmV0dXJuIEFycmF5LmlzQXJyYXkoeSkmJihbeSxDLHgsaF09eSksdHlwZW9mIHk9PSJzdHJpbmciJiYoW3ksQyx4LGhdPW8oKSh5KSx5Lz0yNTUsQy89MjU1LHgvPTI1NSksc3VwZXIoeSxDLHgsaCksdGhpc31nZXQgcigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMF0qMjU1KX1zZXQgcih5KXt0aGlzWzBdPXkvMjU1fWdldCBnKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1sxXSoyNTUpfXNldCBnKHkpe3RoaXNbMV09eS8yNTV9Z2V0IGIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzJdKjI1NSl9c2V0IGIoeSl7dGhpc1syXT15LzI1NX1nZXQgYSgpe3JldHVybiB0aGlzWzNdfXNldCBhKHkpe3RoaXNbM109eX1nZXQgaGV4KCl7Y29uc3QgeT1gMCR7dGhpcy5yLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxDPWAwJHt0aGlzLmcudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLHg9YDAke3RoaXMuYi50b1N0cmluZygxNil9YC5zbGljZSgtMik7bGV0IGg7cmV0dXJuIHRoaXMuYTwxJiYoaD1NYXRoLnJvdW5kKHRoaXNbM10qMjU1KSxoPWAwJHtoLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSksYCMke3l9JHtDfSR7eH0ke2h8fCIifWB9Z2V0IHJnYmEoKXtyZXR1cm5gcmdiYSgke3RoaXMucn0sJHt0aGlzLmd9LCR7dGhpcy5ifSwke3RoaXMuYX0pYH1mcm9tQ29sb3IoeSl7cmV0dXJuIHR5cGVvZiB5PT0ic3RyaW5nIiYmKHk9bygpKHkpLHlbMF0vPTI1NSx5WzFdLz0yNTUseVsyXS89MjU1KSx0aGlzWzBdPXlbMF0sdGhpc1sxXT15WzFdLHRoaXNbMl09eVsyXSx0aGlzWzNdPXlbM10sdGhpc319fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVSYWRpdXNCb3giLGZ1bmN0aW9uKCl7cmV0dXJuIG99KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYSh2LFQsZCx1LGMsRT0ibGVmdFRvcCIpe2NvbnN0IGY9LjU1MjI4NDgsZz11LzIqZix5PWMvMipmLEM9VCt1LHg9ZCtjLGg9VCt1LzIsbT1kK2MvMjtFPT09ImxlZnRUb3AiPyh2Lm1vdmVUbyhULG0pLHYuYmV6aWVyQ3VydmVUbyhULG0teSxoLWcsZCxoLGQpKTpFPT09InJpZ2h0VG9wIj92LmJlemllckN1cnZlVG8oaCtnLGQsQyxtLXksQyxtKTpFPT09InJpZ2h0Qm90dG9tIj92LmJlemllckN1cnZlVG8oQyxtK3ksaCtnLHgsaCx4KTpFPT09ImxlZnRCb3R0b20iJiZ2LmJlemllckN1cnZlVG8oaC1nLHgsVCxtK3ksVCxtKX1mdW5jdGlvbiBvKHYsW1QsZCx1LGNdLEUpe2lmKCFFfHxBcnJheS5pc0FycmF5KEUpJiZFLmV2ZXJ5KGY9PmY9PT0wKSl2LmJlZ2luUGF0aCgpLHYucmVjdChULGQsdSxjKTtlbHNle3R5cGVvZiBFPT0ibnVtYmVyIiYmKEU9QXJyYXkoOCkuZmlsbChFKSk7Y29uc3RbZixnLHksQyx4LGgsbSxyXT1FLm1hcCgoaSxuKT0+biUyP01hdGgubWluKGksYy8yKTpNYXRoLm1pbihpLHUvMikpO3YuYmVnaW5QYXRoKCksdi5tb3ZlVG8oVCxkK2cpLGEodixULGQsZioyLGcqMiwibGVmdFRvcCIpLHYubGluZVRvKFQrdS15LGQpLGEodixUK3UteSoyLGQseSoyLEMqMiwicmlnaHRUb3AiKSx2LmxpbmVUbyhUK3UsZCtjLWgpLGEodixUK3UteCoyLGQrYy1oKjIseCoyLGgqMiwicmlnaHRCb3R0b20iKSx2LmxpbmVUbyhUK20sZCtjKSxhKHYsVCxkK2MtcioyLG0qMixyKjIsImxlZnRCb3R0b20iKSx2LmNsb3NlUGF0aCgpfXJldHVybiB2fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWZ1bmN0aW9uKGEsbyl7aWYoIWEpcmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH07Y29uc3RbW3YsVF0sW2QsdV1dPWEsYz12Km9bMF0rVCpvWzJdK29bNF0sRT12Km9bMV0rVCpvWzNdK29bNV0sZj1kKm9bMF0rVCpvWzJdK29bNF0sZz1kKm9bMV0rVCpvWzNdK29bNV0seT1kKm9bMF0rdSpvWzJdK29bNF0sQz1kKm9bMV0rdSpvWzNdK29bNV0seD12Km9bMF0rdSpvWzJdK29bNF0saD12Km9bMV0rdSpvWzNdK29bNV0sbT1NYXRoLm1pbihjLGYseSx4KSxyPU1hdGgubWluKEUsZyxDLGgpLGk9TWF0aC5tYXgoYyxmLHkseCksbj1NYXRoLm1heChFLGcsQyxoKTtyZXR1cm57eDptLHk6cix3aWR0aDppLW0saGVpZ2h0Om4tcixsZWZ0Om0sdG9wOnIscmlnaHQ6aSxib3R0b206bn19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCgyMTgpLG89dCgyMTkpLHY9dCgyMjUpLFQ9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBkKEUsZixnKXtyZXR1cm4gZiBpbiBFP09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLGYse3ZhbHVlOmcsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpFW2ZdPWcsRX1jb25zdCB1PVN5bWJvbCgidGV4dHVyZVRhc2siKTtjbGFzcyBjIGV4dGVuZHMgby5kZWZhdWx0e2NvbnN0cnVjdG9yKGY9e30pe3R5cGVvZiBmPT0ic3RyaW5nIiYmKGY9e3RleHR1cmU6Zn0pLHN1cGVyKGYpfWdldCBjb250ZW50U2l6ZSgpe2xldFtmLGddPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOnksaGVpZ2h0OkN9PXRoaXMuYXR0cmlidXRlcztpZih5PT1udWxsfHxDPT1udWxsKXtjb25zdCB4PXRoaXMudGV4dHVyZUltYWdlLGg9dGhpcy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0LG09dGhpcy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYoaCl5PT1udWxsJiYoZj1oWzBdK2hbMl0pLEM9PW51bGwmJihnPWhbMV0raFszXSk7ZWxzZSBpZihtKXtjb25zdCByPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt5PT1udWxsJiYoZj1tWzJdL3IpLEM9PW51bGwmJihnPW1bM10vcil9ZWxzZSBpZih4KXtjb25zdCByPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt5PT1udWxsJiYoZj14LndpZHRoL3IpLEM9PW51bGwmJihnPXguaGVpZ2h0L3IpfX1yZXR1cm5bZixnXX1nZXQgdGV4dHVyZUltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1t1XXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhmPVtdKXtzdXBlci5kcmF3KGYpO2NvbnN0IGc9dGhpcy5tZXNoO3JldHVybiBnJiZPYmplY3QoYS5kcmF3VGV4dHVyZSkodGhpcyxnKSxmfW9uUHJvcGVydHlDaGFuZ2UoZixnLHkpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoZixnLHkpLGY9PT0idGV4dHVyZSImJih0aGlzW3VdPU9iamVjdChhLmFwcGx5VGV4dHVyZSkodGhpcyxnLCEwKSksZj09PSJ0ZXh0dXJlUmVjdCIpe2NvbnN0e3dpZHRoOkMsaGVpZ2h0Onh9PXRoaXMuYXR0cmlidXRlczsoQz09bnVsbHx8eD09bnVsbCkmJnRoaXMudXBkYXRlQ29udG91cnMoKX19fWQoYywiQXR0ciIsdi5kZWZhdWx0KSxULmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInNwcml0ZSIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGE9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBvPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSx2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLFQ9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgZCBleHRlbmRzIGEuZGVmYXVsdHtjb25zdHJ1Y3RvcihjKXtzdXBlcihjKSx0aGlzW29dKHt0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMH0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbVF0oInRleHR1cmUiKX1zZXQgdGV4dHVyZShjKXt0aGlzW3ZdKCJ0ZXh0dXJlIixjKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1tUXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoYyl7dGhpc1t2XSgidGV4dHVyZVJlY3QiLGMpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbVF0oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChjKXt0aGlzW3ZdKCJzb3VyY2VSZWN0IixjKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW1RdKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoYyl7dGhpc1t2XSgidGV4dHVyZVJlcGVhdCIsISFjKX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBDfSk7dmFyIGE9dCgxMiksbz10KDIyNyksdj10Lm4obyksVD10KDcwKSxkPXQoMjI4KSx1PXQoMjIxKSxjPXQoMjE4KSxFPXQoMjEzKSxmPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyh4LGgsbSl7cmV0dXJuIGggaW4geD9PYmplY3QuZGVmaW5lUHJvcGVydHkoeCxoLHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6eFtoXT1tLHh9Y29uc3QgeT1TeW1ib2woIm1lc2giKTtjbGFzcyBDIGV4dGVuZHMgVC5kZWZhdWx0e2NvbnN0cnVjdG9yKGg9e30pe3R5cGVvZiBoPT0ic3RyaW5nIiYmKGg9e2Q6aH0pLHN1cGVyKGgpLHRoaXMuZWZmZWN0cz17ZChtLHIsaSxuLHMpe2NvbnN0IE09KGktbikvKHMtbik7aWYoTTw9MClyZXR1cm4gbTtpZihNPj0xKXJldHVybiByO2NvbnN0IFA9di5hLl9wcmVwcm9jZXNzaW5nKHYuYS5wYXRoMnNoYXBlcyhtKSx2LmEucGF0aDJzaGFwZXMocikpLFM9di5hLl9sZXJwKC4uLlAsTSlbMF07cmV0dXJuIFMucmVkdWNlKChPLEQpPT5gJHtPfSR7RC5zbGljZSgyKS5qb2luKCIgIil9IGAsYE0ke1NbMF1bMF19ICR7U1swXVsxXX1DYCkudHJpbSgpfX19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5kfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgaD10aGlzLnBhdGg7aWYoaCl7bGV0IG09dGhpc1t5XTtpZihtKW0ucGF0aCE9PWgmJihtLmNvbnRvdXJzPWguY29udG91cnMsbS5wYXRoPWgpO2Vsc2V7bT1uZXcgYS5NZXNoMkQodGhpcy5wYXRoKSxtLnBhdGg9aDtjb25zdCBpPXRoaXMuYXR0cmlidXRlcy5maWxsQ29sb3Isbj10aGlzLmF0dHJpYnV0ZXMuZmlsbFJ1bGU7aSYmT2JqZWN0KHUuc2V0RmlsbENvbG9yKShtLHtjb2xvcjppLHJ1bGU6bn0pO2NvbnN0IHM9dGhpcy5hdHRyaWJ1dGVzLmxpbmVXaWR0aCxNPXRoaXMuYXR0cmlidXRlcy5zdHJva2VDb2xvcjtpZihNJiZzPjApe2NvbnN0e2xpbmVDYXA6UyxsaW5lSm9pbjpiLG1pdGVyTGltaXQ6TyxsaW5lRGFzaDpELGxpbmVEYXNoT2Zmc2V0Okkscm91bmRTZWdtZW50czpSfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHUuc2V0U3Ryb2tlQ29sb3IpKG0se2NvbG9yOk0sbGluZVdpZHRoOnMsbGluZUNhcDpTLGxpbmVKb2luOmIsbWl0ZXJMaW1pdDpPLGxpbmVEYXNoOkQsbGluZURhc2hPZmZzZXQ6SSxyb3VuZFNlZ21lbnRzOlJ9KX10aGlzW3ldPW07Y29uc3QgUD10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7UCYmdGhpc1t5XS5zZXRDbGlwUGF0aChQKX1jb25zdCByPXRoaXMub3BhY2l0eTtyZXR1cm4gbS5nZXRPcGFjaXR5KCkhPT1yJiZtLnNldE9wYWNpdHkociksbS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLG19cmV0dXJuIG51bGx9Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtpZih0aGlzLnBhdGgpe2NvbnN0IGg9dGhpcy5wYXRoLmJvdW5kaW5nQm94O3JldHVybltoWzBdWzBdLGhbMF1bMV0saFsxXVswXS1oWzBdWzBdLGhbMV1bMV0taFswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IGg9dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVybltoWzBdWzBdLGhbMF1bMV0saFsxXVswXS1oWzBdWzBdLGhbMV1bMV0taFswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudENlbnRlcigpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmJvdW5kaW5nQ2VudGVyOlswLDBdfXNldCBkKGgpe3RoaXMuYXR0cmlidXRlcy5kPWh9Z2V0IGQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmR9ZHJhdyhoPVtdKXtzdXBlci5kcmF3KGgpO2NvbnN0IG09dGhpcy5tZXNoO3JldHVybiBtJiZPYmplY3QoYy5kcmF3VGV4dHVyZSkodGhpcyxtKSxofWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCBoPW51bGw7cmV0dXJuIHRoaXMubWVzaCYmKGg9dGhpcy5tZXNoLmJvdW5kaW5nQm94KSxPYmplY3QoZi5kZWZhdWx0KShoLHRoaXMucmVuZGVyTWF0cml4KX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guZ2V0VG90YWxMZW5ndGgoKTowfWdldFBvaW50QXRMZW5ndGgoaCl7aWYodGhpcy5tZXNoKXtjb25zdCBtPXRoaXMubWVzaC5nZXRQb2ludEF0TGVuZ3RoKGgpO2lmKG0pcmV0dXJuW20ueCxtLnldfXJldHVyblswLDBdfW9uUHJvcGVydHlDaGFuZ2UoaCxtLHIpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoaCxtLHIpLChoPT09ImQifHxoPT09Im5vcm1hbGl6ZSIpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t5XSYmKGg9PT0iZmlsbENvbG9yInx8aD09PSJmaWxsUnVsZSIpKXtjb25zdHtmaWxsQ29sb3I6aSxmaWxsUnVsZTpufT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHUuc2V0RmlsbENvbG9yKSh0aGlzW3ldLHtjb2xvcjppLHJ1bGU6bn0pfWlmKHRoaXNbeV0mJihoPT09InN0cm9rZUNvbG9yInx8aD09PSJsaW5lV2lkdGgifHxoPT09ImxpbmVDYXAifHxoPT09ImxpbmVKb2luInx8aD09PSJsaW5lRGFzaCJ8fGg9PT0ibGluZURhc2hPZmZzZXQifHxoPT09InJvdW5kU2VnbWVudHMiKSl7Y29uc3R7c3Ryb2tlQ29sb3I6aSxsaW5lV2lkdGg6bn09dGhpcy5hdHRyaWJ1dGVzO2lmKGkmJm4+MCl7Y29uc3R7bGluZUNhcDpzLGxpbmVKb2luOk0sbGluZURhc2g6UCxsaW5lRGFzaE9mZnNldDpTLG1pdGVyTGltaXQ6Yixyb3VuZFNlZ21lbnRzOk99PXRoaXMuYXR0cmlidXRlcztPYmplY3QodS5zZXRTdHJva2VDb2xvcikodGhpc1t5XSx7Y29sb3I6aSxsaW5lQ2FwOnMsbGluZUpvaW46TSxsaW5lV2lkdGg6bixsaW5lRGFzaDpQLGxpbmVEYXNoT2Zmc2V0OlMsbWl0ZXJMaW1pdDpiLHJvdW5kU2VnbWVudHM6T30pfX10aGlzW3ldJiZoPT09ImNsaXBQYXRoIiYmdGhpc1t5XS5zZXRDbGlwUGF0aChtKSxoPT09InRleHR1cmUiJiZPYmplY3QoYy5hcHBseVRleHR1cmUpKHRoaXMsbSl9dXBkYXRlQ29udG91cnMoKXt0aGlzLnBhdGg9bmV3IGEuRmlndXJlMkQsdGhpcy5wYXRoLmFkZFBhdGgodGhpcy5hdHRyaWJ1dGVzLmQpLHRoaXMuYXR0cmlidXRlcy5ub3JtYWxpemUmJnRoaXMucGF0aC5ub3JtYWxpemUoLi4udGhpcy5wYXRoLmJvdW5kaW5nQ2VudGVyKX19ZyhDLCJBdHRyIixkLmRlZmF1bHQpLEUuZGVmYXVsdC5yZWdpc3Rlck5vZGUoQywicGF0aCIpfSxmdW5jdGlvbihMLGUsdCl7KGZ1bmN0aW9uKGEsbyl7TC5leHBvcnRzPW8oKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIEQoSSxSKXt2YXIgQT1bXSxVPSEwLEs9ITEsVj12b2lkIDA7dHJ5e2Zvcih2YXIgUT1JW1N5bWJvbC5pdGVyYXRvcl0oKSxxOyEoVT0ocT1RLm5leHQoKSkuZG9uZSkmJihBLnB1c2gocS52YWx1ZSksIShSJiZBLmxlbmd0aD09PVIpKTtVPSEwKTt9Y2F0Y2goVyl7Sz0hMCxWPVd9ZmluYWxseXt0cnl7IVUmJlEucmV0dXJuJiZRLnJldHVybigpfWZpbmFsbHl7aWYoSyl0aHJvdyBWfX1yZXR1cm4gQX1yZXR1cm4gZnVuY3Rpb24oSSxSKXtpZihBcnJheS5pc0FycmF5KEkpKXJldHVybiBJO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoSSkpcmV0dXJuIEQoSSxSKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpLG89TWF0aC5QSSoyLHY9ZnVuY3Rpb24oSSxSLEEsVSxLLFYsUSl7dmFyIHE9SS54LFc9SS55O3EqPVIsVyo9QTt2YXIgSD1VKnEtSypXLFo9SypxK1UqVztyZXR1cm57eDpIK1YseTpaK1F9fSxUPWZ1bmN0aW9uKEksUil7dmFyIEE9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKFIvNCksVT1NYXRoLmNvcyhJKSxLPU1hdGguc2luKEkpLFY9TWF0aC5jb3MoSStSKSxRPU1hdGguc2luKEkrUik7cmV0dXJuW3t4OlUtSypBLHk6SytVKkF9LHt4OlYrUSpBLHk6US1WKkF9LHt4OlYseTpRfV19LGQ9ZnVuY3Rpb24oSSxSLEEsVSl7dmFyIEs9SSpVLVIqQTwwPy0xOjEsVj1NYXRoLnNxcnQoSSpJK1IqUiksUT1NYXRoLnNxcnQoSSpJK1IqUikscT1JKkErUipVLFc9cS8oVipRKTtyZXR1cm4gVz4xJiYoVz0xKSxXPC0xJiYoVz0tMSksSypNYXRoLmFjb3MoVyl9LHU9ZnVuY3Rpb24oSSxSLEEsVSxLLFYsUSxxLFcsSCxaLHR0KXt2YXIgXz1NYXRoLnBvdyhLLDIpLHN0PU1hdGgucG93KFYsMiksaz1NYXRoLnBvdyhaLDIpLGN0PU1hdGgucG93KHR0LDIpLGZ0PV8qc3QtXypjdC1zdCprO2Z0PDAmJihmdD0wKSxmdC89XypjdCtzdCprLGZ0PU1hdGguc3FydChmdCkqKFE9PT1xPy0xOjEpO3ZhciBCPWZ0KksvVip0dCxGPWZ0Ki1WL0sqWixZPUgqQi1XKkYrKEkrQSkvMixKPVcqQitIKkYrKFIrVSkvMixqPShaLUIpL0ssRz0odHQtRikvVixsPSgtWi1CKS9LLHA9KC10dC1GKS9WLE49ZCgxLDAsaixHKSx6PWQoaixHLGwscCk7cmV0dXJuIHE9PT0wJiZ6PjAmJih6LT1vKSxxPT09MSYmejwwJiYoeis9byksW1ksSixOLHpdfSxjPWZ1bmN0aW9uKEkpe3ZhciBSPUkucHgsQT1JLnB5LFU9SS5jeCxLPUkuY3ksVj1JLnJ4LFE9SS5yeSxxPUkueEF4aXNSb3RhdGlvbixXPXE9PT12b2lkIDA/MDpxLEg9SS5sYXJnZUFyY0ZsYWcsWj1IPT09dm9pZCAwPzA6SCx0dD1JLnN3ZWVwRmxhZyxfPXR0PT09dm9pZCAwPzA6dHQsc3Q9W107aWYoVj09PTB8fFE9PT0wKXJldHVybltdO3ZhciBrPU1hdGguc2luKFcqby8zNjApLGN0PU1hdGguY29zKFcqby8zNjApLGZ0PWN0KihSLVUpLzIrayooQS1LKS8yLEI9LWsqKFItVSkvMitjdCooQS1LKS8yO2lmKGZ0PT09MCYmQj09PTApcmV0dXJuW107Vj1NYXRoLmFicyhWKSxRPU1hdGguYWJzKFEpO3ZhciBGPU1hdGgucG93KGZ0LDIpL01hdGgucG93KFYsMikrTWF0aC5wb3coQiwyKS9NYXRoLnBvdyhRLDIpO0Y+MSYmKFYqPU1hdGguc3FydChGKSxRKj1NYXRoLnNxcnQoRikpO3ZhciBZPXUoUixBLFUsSyxWLFEsWixfLGssY3QsZnQsQiksSj1hKFksNCksaj1KWzBdLEc9SlsxXSxsPUpbMl0scD1KWzNdLE49TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKHApLyhvLzQpKSwxKTtwLz1OO2Zvcih2YXIgej0wO3o8Tjt6Kyspc3QucHVzaChUKGwscCkpLGwrPXA7cmV0dXJuIHN0Lm1hcChmdW5jdGlvbigkKXt2YXIgWD12KCRbMF0sVixRLGN0LGssaixHKSx3PVgueCxldD1YLnkscnQ9digkWzFdLFYsUSxjdCxrLGosRyksYXQ9cnQueCxsdD1ydC55LGl0PXYoJFsyXSxWLFEsY3QsayxqLEcpLG50PWl0Lngsb3Q9aXQueTtyZXR1cm57eDE6dyx5MTpldCx4MjphdCx5MjpsdCx4Om50LHk6b3R9fSl9LEU9e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0sZj0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIGcoRCl7dmFyIEk9W107cmV0dXJuIEQucmVwbGFjZShmLGZ1bmN0aW9uKFIsQSxVKXt2YXIgSz1BLnRvTG93ZXJDYXNlKCk7Zm9yKFU9QyhVKSxLPT0ibSImJlUubGVuZ3RoPjImJihJLnB1c2goW0FdLmNvbmNhdChVLnNwbGljZSgwLDIpKSksSz0ibCIsQT1BPT0ibSI/ImwiOiJMIik7Oyl7aWYoVS5sZW5ndGg9PUVbS10pcmV0dXJuIFUudW5zaGlmdChBKSxJLnB1c2goVSk7aWYoVS5sZW5ndGg8RVtLXSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTtJLnB1c2goW0FdLmNvbmNhdChVLnNwbGljZSgwLEVbS10pKSl9fSksSX12YXIgeT0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiBDKEQpe3ZhciBJPUQubWF0Y2goeSk7cmV0dXJuIEk/SS5tYXAoTnVtYmVyKTpbXX1mdW5jdGlvbiB4KEQpe3ZhciBJPURbMF1bMF0sUj1EWzBdWzFdLEE9SSxVPVI7cmV0dXJuIEQuZm9yRWFjaChmdW5jdGlvbihLKXt2YXIgVj1LWzBdLFE9S1syXSxxPUtbNF0sVz1LWzZdLEg9S1sxXSxaPUtbM10sdHQ9S1s1XSxfPUtbN107ST1NYXRoLm1pbihJLFYsUSxxLFcpLFI9TWF0aC5taW4oUixILFosdHQsXyksQT1NYXRoLm1heChBLFYsUSxxLFcpLFU9TWF0aC5tYXgoVSxILFosdHQsXyl9KSxbSSxSLEEsVV19ZnVuY3Rpb24gaChELEkpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coRFswXS1JWzBdLDIpK01hdGgucG93KERbMV0tSVsxXSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KERbMl0tSVsyXSwyKStNYXRoLnBvdyhEWzNdLUlbM10sMikpfWZ1bmN0aW9uIG0oRCxJKXt2YXIgUj1EWzBdLEE9RFsyXSxVPURbNF0sSz1EWzZdLFY9RFsxXSxRPURbM10scT1EWzVdLFc9RFs3XSxIPUlbMF0sWj1JWzJdLHR0PUlbNF0sXz1JWzZdLHN0PUlbMV0saz1JWzNdLGN0PUlbNV0sZnQ9SVs3XTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KEgtUiwyKStNYXRoLnBvdyhzdC1WLDIpKStNYXRoLnNxcnQoTWF0aC5wb3coWi1BLDIpK01hdGgucG93KGstUSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KHR0LVUsMikrTWF0aC5wb3coY3QtcSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KF8tSywyKStNYXRoLnBvdyhmdC1XLDIpKX1mdW5jdGlvbiByKEQsSSl7dmFyIFI9bihELmxlbmd0aCksQT1bXTtSLmZvckVhY2goZnVuY3Rpb24oSyl7dmFyIFY9MCxRPTA7Sy5mb3JFYWNoKGZ1bmN0aW9uKHEpe1YrPW0oRFtxXSxJW1ErK10pfSksQS5wdXNoKHtpbmRleDpLLGRpc3RhbmNlOlZ9KX0pLEEuc29ydChmdW5jdGlvbihLLFYpe3JldHVybiBLLmRpc3RhbmNlLVYuZGlzdGFuY2V9KTt2YXIgVT1bXTtyZXR1cm4gQVswXS5pbmRleC5mb3JFYWNoKGZ1bmN0aW9uKEspe1UucHVzaChEW0tdKX0pLFV9ZnVuY3Rpb24gaShELEkpe3ZhciBSPXMoRC5sZW5ndGgpLEE9W107Ui5mb3JFYWNoKGZ1bmN0aW9uKEspe3ZhciBWPTA7Sy5mb3JFYWNoKGZ1bmN0aW9uKFEpe1YrPWgoeChEW1FdKSx4KElbUV0pKX0pLEEucHVzaCh7aW5kZXg6SyxkaXN0YW5jZTpWfSl9KSxBLnNvcnQoZnVuY3Rpb24oSyxWKXtyZXR1cm4gSy5kaXN0YW5jZS1WLmRpc3RhbmNlfSk7dmFyIFU9W107cmV0dXJuIEFbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbihLKXtVLnB1c2goRFtLXSl9KSxVfWZ1bmN0aW9uIG4oRCl7Zm9yKHZhciBJPVtdLFI9MDtSPEQ7UisrKXtmb3IodmFyIEE9W10sVT0wO1U8RDtVKyspe3ZhciBLPVUrUjtLPkQtMSYmKEstPUQpLEFbS109VX1JLnB1c2goQSl9cmV0dXJuIEl9ZnVuY3Rpb24gcyhEKXtmb3IodmFyIEk9W10sUj0wO1I8RDtSKyspSS5wdXNoKFIpO3JldHVybiBNKEkpfWZ1bmN0aW9uIE0oRCl7dmFyIEk9W10sUj1bXTtmdW5jdGlvbiBBKFUpe3ZhciBLLFY7Zm9yKEs9MDtLPFUubGVuZ3RoO0srKylWPVUuc3BsaWNlKEssMSlbMF0sUi5wdXNoKFYpLFUubGVuZ3RoPT0wJiZJLnB1c2goUi5zbGljZSgpKSxBKFUpLFUuc3BsaWNlKEssMCxWKSxSLnBvcCgpO3JldHVybiBJfXJldHVybiBBKEQpfXZhciBQPXt9O1AucGFyc2VyPWcsUC5sZXJwQ3VydmU9ZnVuY3Rpb24oRCxJLFIpe3JldHVybiBQLmxlcnBQb2ludHMoRFswXSxEWzFdLElbMF0sSVsxXSxSKS5jb25jYXQoUC5sZXJwUG9pbnRzKERbMl0sRFszXSxJWzJdLElbM10sUikpLmNvbmNhdChQLmxlcnBQb2ludHMoRFs0XSxEWzVdLElbNF0sSVs1XSxSKSkuY29uY2F0KFAubGVycFBvaW50cyhEWzZdLERbN10sSVs2XSxJWzddLFIpKX0sUC5sZXJwUG9pbnRzPWZ1bmN0aW9uKEQsSSxSLEEsVSl7cmV0dXJuW0QrKFItRCkqVSxJKyhBLUkpKlVdfSxQLnEyYj1mdW5jdGlvbihELEksUixBLFUsSyl7cmV0dXJuW0QsSSwoRCsyKlIpLzMsKEkrMipBKS8zLChVKzIqUikvMywoSysyKkEpLzMsVSxLXX0sUC5wYXRoMnNoYXBlcz1mdW5jdGlvbihEKXtmb3IodmFyIEk9UC5wYXJzZXIoRCksUj0wLEE9MCxVPTAsSz1JLmxlbmd0aCxWPVtdLFE9bnVsbCxxPXZvaWQgMCxXPXZvaWQgMCxIPXZvaWQgMCxaPXZvaWQgMCx0dD12b2lkIDAsXz12b2lkIDAsc3Q9dm9pZCAwO1U8SztVKyspe3ZhciBrPUlbVV0sY3Q9a1swXSxmdD1JW1UtMV07c3dpdGNoKGN0KXtjYXNlIm0iOnR0PVYubGVuZ3RoLFZbdHRdPVtdLFE9Vlt0dF0sUj1SK2tbMV0sQT1BK2tbMl07YnJlYWs7Y2FzZSJNIjp0dD1WLmxlbmd0aCxWW3R0XT1bXSxRPVZbdHRdLFI9a1sxXSxBPWtbMl07YnJlYWs7Y2FzZSJsIjpRLnB1c2goW1IsQSxSLEEsUixBLFIra1sxXSxBK2tbMl1dKSxSKz1rWzFdLEErPWtbMl07YnJlYWs7Y2FzZSJMIjpRLnB1c2goW1IsQSxrWzFdLGtbMl0sa1sxXSxrWzJdLGtbMV0sa1syXV0pLFI9a1sxXSxBPWtbMl07YnJlYWs7Y2FzZSJoIjpRLnB1c2goW1IsQSxSLEEsUixBLFIra1sxXSxBXSksUis9a1sxXTticmVhaztjYXNlIkgiOlEucHVzaChbUixBLGtbMV0sQSxrWzFdLEEsa1sxXSxBXSksUj1rWzFdO2JyZWFrO2Nhc2UidiI6US5wdXNoKFtSLEEsUixBLFIsQSxSLEEra1sxXV0pLEErPWtbMV07YnJlYWs7Y2FzZSJWIjpRLnB1c2goW1IsQSxSLGtbMV0sUixrWzFdLFIsa1sxXV0pLEE9a1sxXTticmVhaztjYXNlIkMiOlEucHVzaChbUixBLGtbMV0sa1syXSxrWzNdLGtbNF0sa1s1XSxrWzZdXSksUj1rWzVdLEE9a1s2XTticmVhaztjYXNlIlMiOmZ0WzBdPT09IkMifHxmdFswXT09PSJjIj9RLnB1c2goW1IsQSxSK2Z0WzVdLWZ0WzNdLEErZnRbNl0tZnRbNF0sa1sxXSxrWzJdLGtbM10sa1s0XV0pOihmdFswXT09PSJTInx8ZnRbMF09PT0icyIpJiZRLnB1c2goW1IsQSxSK2Z0WzNdLWZ0WzFdLEErZnRbNF0tZnRbMl0sa1sxXSxrWzJdLGtbM10sa1s0XV0pLFI9a1szXSxBPWtbNF07YnJlYWs7Y2FzZSJjIjpRLnB1c2goW1IsQSxSK2tbMV0sQStrWzJdLFIra1szXSxBK2tbNF0sUitrWzVdLEEra1s2XV0pLFI9UitrWzVdLEE9QStrWzZdO2JyZWFrO2Nhc2UicyI6ZnRbMF09PT0iQyJ8fGZ0WzBdPT09ImMiP1EucHVzaChbUixBLFIrZnRbNV0tZnRbM10sQStmdFs2XS1mdFs0XSxSK2tbMV0sQStrWzJdLFIra1szXSxBK2tbNF1dKTooZnRbMF09PT0iUyJ8fGZ0WzBdPT09InMiKSYmUS5wdXNoKFtSLEEsUitmdFszXS1mdFsxXSxBK2Z0WzRdLWZ0WzJdLFIra1sxXSxBK2tbMl0sUitrWzNdLEEra1s0XV0pLFI9UitrWzNdLEE9QStrWzRdO2JyZWFrO2Nhc2UiYSI6Xz1jKHtyeDprWzFdLHJ5OmtbMl0scHg6UixweTpBLHhBeGlzUm90YXRpb246a1szXSxsYXJnZUFyY0ZsYWc6a1s0XSxzd2VlcEZsYWc6a1s1XSxjeDpSK2tbNl0sY3k6QStrWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oQixGKXtGPT09MD9RLnB1c2goW1IsQSxCLngxLEIueTEsQi54MixCLnkyLEIueCxCLnldKTpRLnB1c2goW19bRi0xXS54LF9bRi0xXS55LEIueDEsQi55MSxCLngyLEIueTIsQi54LEIueV0pfSksUj1zdC54LEE9c3QueTticmVhaztjYXNlIkEiOl89Yyh7cng6a1sxXSxyeTprWzJdLHB4OlIscHk6QSx4QXhpc1JvdGF0aW9uOmtbM10sbGFyZ2VBcmNGbGFnOmtbNF0sc3dlZXBGbGFnOmtbNV0sY3g6a1s2XSxjeTprWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oQixGKXtGPT09MD9RLnB1c2goW1IsQSxCLngxLEIueTEsQi54MixCLnkyLEIueCxCLnldKTpRLnB1c2goW19bRi0xXS54LF9bRi0xXS55LEIueDEsQi55MSxCLngyLEIueTIsQi54LEIueV0pfSksUj1zdC54LEE9c3QueTticmVhaztjYXNlIlEiOlEucHVzaChQLnEyYihSLEEsa1sxXSxrWzJdLGtbM10sa1s0XSkpLFI9a1szXSxBPWtbNF07YnJlYWs7Y2FzZSJxIjpRLnB1c2goUC5xMmIoUixBLFIra1sxXSxBK2tbMl0sa1szXStSLGtbNF0rQSkpLFIrPWtbM10sQSs9a1s0XTticmVhaztjYXNlIlQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oSD1SK2Z0WzNdLWZ0WzFdLFo9QStmdFs0XS1mdFsyXSxRLnB1c2goUC5xMmIoUixBLEgsWixrWzFdLGtbMl0pKSk6KGZ0WzBdPT09IlQifHxmdFswXT09PSJ0IikmJihRLnB1c2goUC5xMmIoUixBLFIrUi1ILEErQS1aLGtbMV0sa1syXSkpLEg9UitSLUgsWj1BK0EtWiksUj1rWzFdLEE9a1syXTticmVhaztjYXNlInQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oSD1SK2Z0WzNdLWZ0WzFdLFo9QStmdFs0XS1mdFsyXSxRLnB1c2goUC5xMmIoUixBLEgsWixSK2tbMV0sQStrWzJdKSkpOihmdFswXT09PSJUInx8ZnRbMF09PT0idCIpJiYoUS5wdXNoKFAucTJiKFIsQSxSK1ItSCxBK0EtWixSK2tbMV0sQStrWzJdKSksSD1SK1ItSCxaPUErQS1aKSxSKz1rWzFdLEErPWtbMl07YnJlYWs7Y2FzZSJaIjpxPVFbMF1bMF0sVz1RWzBdWzFdLFEucHVzaChbUixBLHEsVyxxLFcscSxXXSk7YnJlYWs7Y2FzZSJ6IjpxPVFbMF1bMF0sVz1RWzBdWzFdLFEucHVzaChbUixBLHEsVyxxLFcscSxXXSk7YnJlYWt9fXJldHVybiBWfSxQLl91cEN1cnZlcz1mdW5jdGlvbihELEkpe2Zvcih2YXIgUj0wLEE9MCxVPUQubGVuZ3RoO1I8STtSKyspRC5wdXNoKERbQV0uc2xpY2UoMCkpLEErKyxBPlUtMSYmKEEtPVUpfTtmdW5jdGlvbiBTKEQsSSxSLEEsVSxLLFYsUSxxKXtyZXR1cm57bGVmdDpiKEQsSSxSLEEsVSxLLFYsUSxxKSxyaWdodDpiKFYsUSxVLEssUixBLEQsSSwxLXEsITApfX1mdW5jdGlvbiBiKEQsSSxSLEEsVSxLLFYsUSxxLFcpe3ZhciBIPShSLUQpKnErRCxaPShBLUkpKnErSSx0dD0oVS1SKSpxK1IsXz0oSy1BKSpxK0Esc3Q9KFYtVSkqcStVLGs9KFEtSykqcStLLGN0PSh0dC1IKSpxK0gsZnQ9KF8tWikqcStaLEI9KHN0LXR0KSpxK3R0LEY9KGstXykqcStfLFk9KEItY3QpKnErY3QsSj0oRi1mdCkqcStmdDtyZXR1cm4gVz9bWSxKLGN0LGZ0LEgsWixELEldOltELEksSCxaLGN0LGZ0LFksSl19UC5fc3BsaXRDdXJ2ZXM9ZnVuY3Rpb24oRCxJKXtmb3IodmFyIFI9MCxBPTA7UjxJO1IrKyl7dmFyIFU9RFtBXSxLPVMoVVswXSxVWzFdLFVbMl0sVVszXSxVWzRdLFVbNV0sVVs2XSxVWzddLC41KTtELnNwbGljZShBLDEpLEQuc3BsaWNlKEEsMCxLLmxlZnQsSy5yaWdodCksQSs9MixBPj1ELmxlbmd0aC0xJiYoQT0wKX19O2Z1bmN0aW9uIE8oRCxJKXtmb3IodmFyIFI9ZnVuY3Rpb24oSyl7dmFyIFY9RFtELmxlbmd0aC0xXSxRPVtdO1YuZm9yRWFjaChmdW5jdGlvbihxKXtRLnB1c2gocS5zbGljZSgwKSl9KSxELnB1c2goUSl9LEE9MDtBPEk7QSsrKVIoKX1yZXR1cm4gUC5sZXJwPWZ1bmN0aW9uKEQsSSxSKXtyZXR1cm4gUC5fbGVycChQLnBhdGgyc2hhcGVzKEQpLFAucGF0aDJzaGFwZXMoSSksUil9LFAuTUlNX0NVUlZFU19DT1VOVD0xMDAsUC5fcHJlcHJvY2Vzc2luZz1mdW5jdGlvbihELEkpe3ZhciBSPUQubGVuZ3RoLEE9SS5sZW5ndGgsVT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEQpKSxLPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoSSkpO3JldHVybiBSPkE/TyhLLFItQSk6UjxBJiZPKFUsQS1SKSxVPWkoVSxLKSxVLmZvckVhY2goZnVuY3Rpb24oVixRKXt2YXIgcT1WLmxlbmd0aCxXPUtbUV0ubGVuZ3RoO3E+Vz9xPFAuTUlNX0NVUlZFU19DT1VOVD8oUC5fc3BsaXRDdXJ2ZXMoVixQLk1JTV9DVVJWRVNfQ09VTlQtcSksUC5fc3BsaXRDdXJ2ZXMoS1tRXSxQLk1JTV9DVVJWRVNfQ09VTlQtVykpOlAuX3NwbGl0Q3VydmVzKEtbUV0scS1XKTpxPFcmJihXPFAuTUlNX0NVUlZFU19DT1VOVD8oUC5fc3BsaXRDdXJ2ZXMoVixQLk1JTV9DVVJWRVNfQ09VTlQtcSksUC5fc3BsaXRDdXJ2ZXMoS1tRXSxQLk1JTV9DVVJWRVNfQ09VTlQtVykpOlAuX3NwbGl0Q3VydmVzKFYsVy1xKSl9KSxVLmZvckVhY2goZnVuY3Rpb24oVixRKXtVW1FdPXIoVixLW1FdKX0pLFtVLEtdfSxQLl9sZXJwPWZ1bmN0aW9uKEQsSSxSKXt2YXIgQT1bXTtyZXR1cm4gRC5mb3JFYWNoKGZ1bmN0aW9uKFUsSyl7dmFyIFY9W107VS5mb3JFYWNoKGZ1bmN0aW9uKFEscSl7Vi5wdXNoKFAubGVycEN1cnZlKFEsSVtLXVtxXSxSKSl9KSxBLnB1c2goVil9KSxBfSxQLmFuaW1hdGU9ZnVuY3Rpb24oRCl7dmFyIEk9UC5wYXRoMnNoYXBlcyhELmZyb20pLFI9UC5wYXRoMnNoYXBlcyhELnRvKSxBPVAuX3ByZXByb2Nlc3NpbmcoSSxSKSxVPW5ldyBEYXRlLEs9RC5lbmR8fGZ1bmN0aW9uKCl7fSxWPUQucHJvZ3Jlc3N8fGZ1bmN0aW9uKCl7fSxRPUQuYmVnaW58fGZ1bmN0aW9uKCl7fSxxPUQuZWFzaW5nfHxmdW5jdGlvbihfKXtyZXR1cm4gX30sVz1udWxsLEg9bnVsbCxaPUQudGltZTtRKEkpO3ZhciB0dD1mdW5jdGlvbiBfKCl7dmFyIHN0PW5ldyBEYXRlLVU7aWYoc3Q+PVope0g9UixWKEgsMSksSyhIKSxjYW5jZWxBbmltYXRpb25GcmFtZShXKTtyZXR1cm59dmFyIGs9cShzdC9aKTtIPVAuX2xlcnAoQVswXSxBWzFdLGspLFYoSCxrKSxXPXJlcXVlc3RBbmltYXRpb25GcmFtZShfKX07dHQoKX0sUH0pfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCg3MSksbz10KDIyMSksdj10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgVD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIGMgZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1tUXSh7ZDoiIixub3JtYWxpemU6ITEsZmlsbENvbG9yOnZvaWQgMCxmaWxsUnVsZToibm9uemVybyIsc3Ryb2tlQ29sb3I6dm9pZCAwLGxpbmVXaWR0aDoxLGxpbmVKb2luOiJtaXRlciIsbGluZUNhcDoiYnV0dCIscm91bmRTZWdtZW50czoyMCxsaW5lRGFzaDp2b2lkIDAsbGluZURhc2hPZmZzZXQ6MCxtaXRlckxpbWl0OjEwLHRleHR1cmU6dm9pZCAwLHRleHR1cmVSZWN0OnZvaWQgMCx0ZXh0dXJlUmVwZWF0OiExLHNvdXJjZVJlY3Q6dm9pZCAwLGNsaXBQYXRoOnZvaWQgMH0pfWdldCBkKCl7cmV0dXJuIHRoaXNbdV0oImQiKX1zZXQgZChmKXt0aGlzW2RdKCJkIixmKX1nZXQgbm9ybWFsaXplKCl7cmV0dXJuIHRoaXNbdV0oIm5vcm1hbGl6ZSIpfXNldCBub3JtYWxpemUoZil7dGhpc1tkXSgibm9ybWFsaXplIiwhIWYpfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1t1XSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcihmKXt0aGlzW2RdKCJmaWxsQ29sb3IiLE9iamVjdChvLnBhcnNlQ29sb3IpKGYpKX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1t1XSgiZmlsbFJ1bGUiKX1zZXQgZmlsbFJ1bGUoZil7aWYoZiE9bnVsbCYmZiE9PSJub256ZXJvIiYmZiE9PSJldmVub2RkIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGZpbGwgcnVsZS4iKTt0aGlzW2RdKCJmaWxsUnVsZSIsZil9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbdV0oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKGYpe3RoaXNbZF0oInN0cm9rZUNvbG9yIixPYmplY3Qoby5wYXJzZUNvbG9yKShmKSl9Z2V0IGxpbmVXaWR0aCgpe3JldHVybiB0aGlzW3VdKCJsaW5lV2lkdGgiKX1zZXQgbGluZVdpZHRoKGYpe3RoaXNbZF0oImxpbmVXaWR0aCIsT2JqZWN0KHYudG9OdW1iZXIpKGYpKX1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1t1XSgibGluZUpvaW4iKX1zZXQgbGluZUpvaW4oZil7aWYoZiE9bnVsbCYmZiE9PSJtaXRlciImJmYhPT0iYmV2ZWwiJiZmIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVKb2luIHR5cGUuIik7dGhpc1tkXSgibGluZUpvaW4iLGYpfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbdV0oImxpbmVDYXAiKX1zZXQgbGluZUNhcChmKXtpZihmIT1udWxsJiZmIT09ImJ1dHQiJiZmIT09InNxdWFyZSImJmYhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUNhcCB0eXBlLiIpO3RoaXNbZF0oImxpbmVDYXAiLGYpfWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW3VdKCJsaW5lRGFzaCIpfXNldCBsaW5lRGFzaChmKXtmPU9iamVjdCh2LnRvQXJyYXkpKGYsITApLGYhPW51bGwmJiFBcnJheS5pc0FycmF5KGYpJiYoZj1bZl0pLHRoaXNbZF0oImxpbmVEYXNoIixmP2YubWFwKHYudG9OdW1iZXIpOm51bGwpfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW3VdKCJsaW5lRGFzaE9mZnNldCIpfXNldCBsaW5lRGFzaE9mZnNldChmKXt0aGlzW2RdKCJsaW5lRGFzaE9mZnNldCIsT2JqZWN0KHYudG9OdW1iZXIpKGYpKX1nZXQgbWl0ZXJMaW1pdCgpe3JldHVybiB0aGlzW3VdKCJtaXRlckxpbWl0Iil9c2V0IG1pdGVyTGltaXQoZil7dGhpc1tkXSgibWl0ZXJMaW1pdCIsT2JqZWN0KHYudG9OdW1iZXIpKGYpKX1nZXQgcm91bmRTZWdtZW50cygpe3JldHVybiB0aGlzW3VdKCJyb3VuZFNlZ21lbnRzIil9c2V0IHJvdW5kU2VnbWVudHMoZil7dGhpc1tkXSgicm91bmRTZWdtZW50cyIsZil9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1t1XSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe3RoaXNbZF0oInRleHR1cmUiLGYpfWdldCB0ZXh0dXJlUmVjdCgpe3JldHVybiB0aGlzW3VdKCJ0ZXh0dXJlUmVjdCIpfXNldCB0ZXh0dXJlUmVjdChmKXt0aGlzW2RdKCJ0ZXh0dXJlUmVjdCIsZil9Z2V0IHNvdXJjZVJlY3QoKXtyZXR1cm4gdGhpc1t1XSgic291cmNlUmVjdCIpfXNldCBzb3VyY2VSZWN0KGYpe3RoaXNbZF0oInNvdXJjZVJlY3QiLGYpfWdldCB0ZXh0dXJlUmVwZWF0KCl7cmV0dXJuIHRoaXNbdV0oInRleHR1cmVSZXBlYXQiKX1zZXQgdGV4dHVyZVJlcGVhdChmKXt0aGlzW2RdKCJ0ZXh0dXJlUmVwZWF0IiwhIWYpfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW3VdKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aChmKXt0aGlzW2RdKCJjbGlwUGF0aCIsZil9fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBhPXQoMjI2KSxvPXQoMjEzKSx2PXQoMjMwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gVCh1LGMsRSl7cmV0dXJuIGMgaW4gdT9PYmplY3QuZGVmaW5lUHJvcGVydHkodSxjLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dVtjXT1FLHV9Y2xhc3MgZCBleHRlbmRzIGEuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7d2lkdGg6YyxoZWlnaHQ6RX09dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBjPjAmJkU+MCYmc3VwZXIuaXNWaXNpYmxlfX1UKGQsIkF0dHIiLHYuZGVmYXVsdCksby5kZWZhdWx0LnJlZ2lzdGVyTm9kZShkLCJyZWN0Iil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KTt2YXIgYT10KDIyOCksbz10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3Qgdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksVD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gYyhmKXtjb25zdHt3aWR0aDpnLGhlaWdodDp5fT1mO3JldHVybmBNMCAwTCR7Z30gMEwke2d9ICR7eX1MMCAke3l9WmB9Y2xhc3MgRSBleHRlbmRzIGEuZGVmYXVsdHtjb25zdHJ1Y3RvcihnKXtzdXBlcihnKSx0aGlzW3ZdKHt3aWR0aDowLGhlaWdodDowfSksdGhpc1t1XSgic2l6ZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbZF0oImQiKX1zZXQgZChnKXt9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbZF0oIndpZHRoIil9c2V0IHdpZHRoKGcpe2lmKGc9T2JqZWN0KG8udG9OdW1iZXIpKGcpLHRoaXNbVF0oIndpZHRoIixnKSl7Y29uc3QgeT1jKHRoaXMpO3RoaXNbVF0oImQiLHkpfX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbZF0oImhlaWdodCIpfXNldCBoZWlnaHQoZyl7aWYoZz1PYmplY3Qoby50b051bWJlcikoZyksdGhpc1tUXSgiaGVpZ2h0IixnKSl7Y29uc3QgeT1jKHRoaXMpO3RoaXNbVF0oImQiLHkpfX1nZXQgc2l6ZSgpe3JldHVyblt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XX1zZXQgc2l6ZShnKXtnPU9iamVjdChvLnRvQXJyYXkpKGcpLEFycmF5LmlzQXJyYXkoZyl8fChnPVtnLGddKSx0aGlzLndpZHRoPWdbMF0sdGhpcy5oZWlnaHQ9Z1sxXX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGE9dCgyMzIpLG89dCgyMTMpLHY9dCgyMzUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBUKHUsYyxFKXtyZXR1cm4gYyBpbiB1P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LGMse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp1W2NdPUUsdX1jbGFzcyBkIGV4dGVuZHMgYS5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczpjfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGNbMF0+MCYmY1sxXT4wJiZzdXBlci5pc1Zpc2libGV9fVQoZCwiQXR0ciIsdi5kZWZhdWx0KSxvLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGQsInRyaWFuZ2xlIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgYT10KDIyNiksbz10KDIxMyksdj10KDIzMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIFQodSxjLEUpe3JldHVybiBjIGluIHU/T2JqZWN0LmRlZmluZVByb3BlcnR5KHUsYyx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnVbY109RSx1fWNsYXNzIGQgZXh0ZW5kcyBhLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3BvaW50czpjfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGMubGVuZ3RoPjAmJnN1cGVyLmlzVmlzaWJsZX19VChkLCJBdHRyIix2LmRlZmF1bHQpLG8uZGVmYXVsdC5yZWdpc3Rlck5vZGUoZCwicG9seWxpbmUiKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBhPXQoMjI4KSxvPXQoNzIpLHY9dCgyMzQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBFKGcpe2NvbnN0e3BvaW50czp5LHNtb290aDpDLHNtb290aFJhbmdlOngsY2xvc2U6aH09ZyxtPVtdO2ZvcihsZXQgaT0wO2k8eS5sZW5ndGg7aSs9MiltLnB1c2goW3lbaV0seVtpKzFdXSk7bGV0IHI9IiI7cmV0dXJuIEM/cj1PYmplY3Qodi5tYWtlU21vb3RoQ3VydmVMaW5lKShtLHgpOm0ubGVuZ3RoJiYocj1gTSR7bS5tYXAoaT0+aS5qb2luKCIgIikpLmpvaW4oIkwiKX1gKSxyJiZoJiYocis9IloiKSxyfWNsYXNzIGYgZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tUXSh7cG9pbnRzOltdLHNtb290aDohMSxzbW9vdGhSYW5nZTpbMF0sY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbY10oImNsb3NlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1t1XSgiZCIpfXNldCBkKHkpe31nZXQgY2xvc2UoKXtyZXR1cm4gdGhpcy5jbG9zZVR5cGUhPT0ibm9uZSJ9c2V0IGNsb3NlKHkpe3k9eT8ibm9ybWFsIjoibm9uZSIsdGhpcy5jbG9zZVR5cGU9eX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbdV0oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUoeSl7aWYoeSE9bnVsbCYmeSE9PSJub25lIiYmeSE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1tkXSgiY2xvc2VUeXBlIix5KSl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgc21vb3RoKCl7cmV0dXJuIHRoaXNbdV0oInNtb290aCIpfXNldCBzbW9vdGgoeSl7aWYodGhpc1tkXSgic21vb3RoIix5KSl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgc21vb3RoUmFuZ2UoKXtyZXR1cm4gdGhpc1t1XSgic21vb3RoUmFuZ2UiKX1zZXQgc21vb3RoUmFuZ2UoeSl7aWYoeSYmIUFycmF5LmlzQXJyYXkoeSkmJih5PVt5XSksdGhpc1tkXSgic21vb3RoUmFuZ2UiLHkpJiZ0aGlzLnNtb290aCl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgcG9pbnRzKCl7cmV0dXJuIHRoaXNbdV0oInBvaW50cyIpfXNldCBwb2ludHMoeSl7aWYoeT1PYmplY3Qoby50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpJiYoeT15LnJlZHVjZSgoQyx4KT0+QXJyYXkuaXNBcnJheSh4KT9bLi4uQywuLi54Lm1hcChoPT5PYmplY3Qoby50b051bWJlcikoaCkpXTpbLi4uQyxPYmplY3Qoby50b051bWJlcikoeCldLFtdKSksdGhpc1tkXSgicG9pbnRzIix5KSl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbZF0oImQiLEMpfX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJtYWtlU21vb3RoQ3VydmVMaW5lIixmdW5jdGlvbigpe3JldHVybiBhfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEobyx2PVswXSl7ZnVuY3Rpb24gVChjLEU9LjE2OCxmPS4xNjgpe2xldCBnLHksQyx4O2lmKChvW2NdLng9PT1vW2MrMV0ueHx8b1tjXS55PT09b1tjKzFdLnkpJiYoRT0wLGY9MCksYzwxPyhnPW9bMF0ueCsob1sxXS54LW9bMF0ueCkqRSx5PW9bMF0ueSsob1sxXS55LW9bMF0ueSkqRSk6KGc9b1tjXS54KyhvW2MrMV0ueC1vW2MtMV0ueCkqRSx5PW9bY10ueSsob1tjKzFdLnktb1tjLTFdLnkpKkUpLGM+by5sZW5ndGgtMyl7Y29uc3QgaD1vLmxlbmd0aC0xO0M9b1toXS54LShvW2hdLngtb1toLTFdLngpKmYseD1vW2hdLnktKG9baF0ueS1vW2gtMV0ueSkqZn1lbHNlIEM9b1tjKzFdLngtKG9bYysyXS54LW9bY10ueCkqZix4PW9bYysxXS55LShvW2MrMl0ueS1vW2NdLnkpKmY7cmV0dXJuW3t4OmcseX0se3g6Qyx5Onh9XX1vPW8ubWFwKChbYyxFXSk9Pih7eDpjLHk6RX0pKTtsZXQgZD0iIix1PTA7cmV0dXJuIG8uZm9yRWFjaCgoYyxFKT0+e2lmKEU9PT0wKWQrPWBNJHtjLnh9ICR7Yy55fWA7ZWxzZXtmb3IoO0U+dlt1XTspdSsrO2lmKHUlMil7Y29uc3RbZixnXT1UKEUtMSk7ZCs9YEMke1tmLngsZi55LGcueCxnLnksYy54LGMueV0uam9pbigiICIpfWB9ZWxzZSBkKz1gTCR7Yy54fSAke2MueX1gfX0pLGR9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCgyMzMpLG89dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLFQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiB1KEUpe2NvbnN0W2YsZ109RS5zaWRlcztsZXQgeT1FLmFuZ2xlJTM2MDtyZXR1cm4geTwwJiYoeSs9MzYwKSx5PU1hdGguUEkqeS8xODAsWzAsMCxmLDAsZypNYXRoLmNvcyh5KSxnKk1hdGguc2luKHkpXX1jbGFzcyBjIGV4dGVuZHMgYS5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbdl0oe3NpZGVzOlswLDBdLGFuZ2xlOjYwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZil7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW2RdKCJzaWRlcyIpfXNldCBzaWRlcyhmKXtpZihmPU9iamVjdChvLnRvQXJyYXkpKGYsITApLGYhPW51bGwmJiFBcnJheS5pc0FycmF5KGYpJiYoZj1bZixmXSksdGhpc1tUXSgic2lkZXMiLGYpKXtjb25zdCBnPXUodGhpcyk7c3VwZXIucG9pbnRzPWd9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW2RdKCJhbmdsZSIpfXNldCBhbmdsZShmKXtpZihmPU9iamVjdChvLnRvTnVtYmVyKShmKSx0aGlzW1RdKCJhbmdsZSIsZikpe2NvbnN0IGc9dSh0aGlzKTtzdXBlci5wb2ludHM9Z319fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBhPXQoMjMyKSxvPXQoMjEzKSx2PXQoMjM3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gVCh1LGMsRSl7cmV0dXJuIGMgaW4gdT9PYmplY3QuZGVmaW5lUHJvcGVydHkodSxjLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dVtjXT1FLHV9Y2xhc3MgZCBleHRlbmRzIGEuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7c2lkZXM6Y309dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBjWzBdPjAmJmNbMV0+MCYmc3VwZXIuaXNWaXNpYmxlfX1UKGQsIkF0dHIiLHYuZGVmYXVsdCksby5kZWZhdWx0LnJlZ2lzdGVyTm9kZShkLCJwYXJhbGxlbCIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCgyMzMpLG89dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLFQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiB1KEUpe2NvbnN0W2YsZ109RS5zaWRlcztsZXQgeT1FLmFuZ2xlJTM2MDt5PDAmJih5Kz0zNjApLHk9TWF0aC5QSSp5LzE4MDtjb25zdCBDPWcqTWF0aC5jb3MoeSkseD1nKk1hdGguc2luKHkpO3JldHVyblswLDAsZiwwLEMrZix4LEMseF19Y2xhc3MgYyBleHRlbmRzIGEuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW3ZdKHtzaWRlczpbMCwwXSxhbmdsZTo5MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGYpe31nZXQgc2lkZXMoKXtyZXR1cm4gdGhpc1tkXSgic2lkZXMiKX1zZXQgc2lkZXMoZil7aWYoZj1PYmplY3Qoby50b0FycmF5KShmLCEwKSxmIT1udWxsJiYhQXJyYXkuaXNBcnJheShmKSYmKGY9W2YsZl0pLHRoaXNbVF0oInNpZGVzIixmKSl7Y29uc3QgZz11KHRoaXMpO3N1cGVyLnBvaW50cz1nfX1nZXQgYW5nbGUoKXtyZXR1cm4gdGhpc1tkXSgiYW5nbGUiKX1zZXQgYW5nbGUoZil7aWYoZj1PYmplY3Qoby50b051bWJlcikoZiksdGhpc1tUXSgiYW5nbGUiLGYpKXtjb25zdCBnPXUodGhpcyk7c3VwZXIucG9pbnRzPWd9fX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgYT10KDIzMiksbz10KDIxMyksdj10KDIzOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIFQodSxjLEUpe3JldHVybiBjIGluIHU/T2JqZWN0LmRlZmluZVByb3BlcnR5KHUsYyx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnVbY109RSx1fWNsYXNzIGQgZXh0ZW5kcyBhLmRlZmF1bHR7fVQoZCwiQXR0ciIsdi5kZWZhdWx0KSxvLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGQsInJlZ3VsYXIiKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBhPXQoMjMzKSxvPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCB2PVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7ZnVuY3Rpb24gdShFKXtjb25zdHtlZGdlczpmLHJhZGl1czpnLG9mZnNldEFuZ2xlOnl9PUUsQz1NYXRoLlBJKnkvMTgwLS41Kk1hdGguUEk7aWYoZjwzfHxnPD0wKXJldHVybltdO2NvbnN0IHg9W107Zm9yKGxldCBoPTA7aDxmO2grKyl7Y29uc3QgbT1oKjIqTWF0aC5QSS9mK0Mscj1nKk1hdGguY29zKG0pLGk9ZypNYXRoLnNpbihtKTt4LnB1c2gocixpKX1yZXR1cm4geH1jbGFzcyBjIGV4dGVuZHMgYS5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbdl0oe2VkZ2VzOjMscmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGYpe31nZXQgZWRnZXMoKXtyZXR1cm4gdGhpc1tkXSgiZWRnZXMiKX1zZXQgZWRnZXMoZil7aWYoZj1PYmplY3Qoby50b051bWJlcikoZiksdGhpc1tUXSgiZWRnZXMiLGYpKXtjb25zdCBnPXUodGhpcyk7c3VwZXIucG9pbnRzPWd9fWdldCByYWRpdXMoKXtyZXR1cm4gdGhpc1tkXSgicmFkaXVzIil9c2V0IHJhZGl1cyhmKXtpZihmPU9iamVjdChvLnRvTnVtYmVyKShmKSx0aGlzW1RdKCJyYWRpdXMiLGYpKXtjb25zdCBnPXUodGhpcyk7c3VwZXIucG9pbnRzPWd9fWdldCBvZmZzZXRBbmdsZSgpe3JldHVybiB0aGlzW2RdKCJvZmZzZXRBbmdsZSIpfXNldCBvZmZzZXRBbmdsZShmKXtpZihmPU9iamVjdChvLnRvTnVtYmVyKShmKSx0aGlzW1RdKCJvZmZzZXRBbmdsZSIsZikpe2NvbnN0IGc9dSh0aGlzKTtzdXBlci5wb2ludHM9Z319fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBhPXQoMjMyKSxvPXQoMjEzKSx2PXQoMjQxKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gVCh1LGMsRSl7cmV0dXJuIGMgaW4gdT9PYmplY3QuZGVmaW5lUHJvcGVydHkodSxjLHt2YWx1ZTpFLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dVtjXT1FLHV9Y2xhc3MgZCBleHRlbmRzIGEuZGVmYXVsdHt9VChkLCJBdHRyIix2LmRlZmF1bHQpLG8uZGVmYXVsdC5yZWdpc3Rlck5vZGUoZCwic3RhciIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCgyMzMpLG89dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLFQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiB1KEUpe2NvbnN0e2FuZ2xlczpmLGlubmVyUmFkaXVzOmcsb3V0ZXJSYWRpdXM6eSxvZmZzZXRBbmdsZTpDfT1FLHg9TWF0aC5QSSpDLzE4MC0uNSpNYXRoLlBJO2lmKGY8M3x8Zzw9MHx8eTw9MClyZXR1cm5bXTtjb25zdCBoPVtdO2ZvcihsZXQgbT0wO208ZioyO20rKyl7Y29uc3Qgcj1tKk1hdGguUEkvZit4LGk9bSUyP2c6eSxuPWkqTWF0aC5jb3Mocikscz1pKk1hdGguc2luKHIpO2gucHVzaChuLHMpfXJldHVybiBofWNsYXNzIGMgZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1t2XSh7YW5nbGVzOjUsaW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLG9mZnNldEFuZ2xlOjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhmKXt9Z2V0IGFuZ2xlcygpe3JldHVybiB0aGlzW2RdKCJhbmdsZXMiKX1zZXQgYW5nbGVzKGYpe2lmKGY9T2JqZWN0KG8udG9OdW1iZXIpKGYpLHRoaXNbVF0oImFuZ2xlcyIsZikpe2NvbnN0IGc9dSh0aGlzKTtzdXBlci5wb2ludHM9Z319Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbZF0oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKGYpe2lmKGY9T2JqZWN0KG8udG9OdW1iZXIpKGYpLHRoaXNbVF0oImlubmVyUmFkaXVzIixmKSl7Y29uc3QgZz11KHRoaXMpO3N1cGVyLnBvaW50cz1nfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tkXSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoZil7aWYoZj1PYmplY3Qoby50b051bWJlcikoZiksdGhpc1tUXSgib3V0ZXJSYWRpdXMiLGYpKXtjb25zdCBnPXUodGhpcyk7c3VwZXIucG9pbnRzPWd9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKGYpe2Y9T2JqZWN0KG8udG9BcnJheSkoZiwhMCksQXJyYXkuaXNBcnJheShmKXx8KGY9W2YsZl0pLHRoaXMuaW5uZXJSYWRpdXM9ZlswXSx0aGlzLm91dGVyUmFkaXVzPWZbMV19Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbZF0oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGYpe2lmKGY9T2JqZWN0KG8udG9OdW1iZXIpKGYpLHRoaXNbVF0oIm9mZnNldEFuZ2xlIixmKSl7Y29uc3QgZz11KHRoaXMpO3N1cGVyLnBvaW50cz1nfX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGE9dCgyMjYpLG89dCgyMTMpLHY9dCgyNDMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBUKHUsYyxFKXtyZXR1cm4gYyBpbiB1P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LGMse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp1W2NdPUUsdX1jbGFzcyBkIGV4dGVuZHMgYS5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtyYWRpdXNYOmMscmFkaXVzWTpFLHN0YXJ0QW5nbGU6ZixlbmRBbmdsZTpnfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGM+MCYmRT4wJiZmIT09ZyYmc3VwZXIuaXNWaXNpYmxlfX1UKGQsIkF0dHIiLHYuZGVmYXVsdCksby5kZWZhdWx0LnJlZ2lzdGVyTm9kZShkLCJlbGxpcHNlIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgYT10KDEyKSxvPXQoMjI4KSx2PXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBFKGcpe2NvbnN0e3JhZGl1c1g6eSxyYWRpdXNZOkMsc3RhcnRBbmdsZTp4LGVuZEFuZ2xlOmgsZGlyZWN0aW9uOm0sY2xvc2VUeXBlOnJ9PWcsaT1tPT09ImFuaXRjbG9ja3dpc2UiLG49bmV3IGEuRmlndXJlMkQ7cmV0dXJuIHI9PT0ic2VjdG9yIiYmbi5tb3ZlVG8oMCwwKSxuLmVsbGlwc2UoMCwwLHksQywwLE1hdGguUEkqeC8xODAsTWF0aC5QSSpoLzE4MCxpKSxyIT09Im5vbmUiJiZuLmNsb3NlUGF0aCgpLG4ucGF0aC5yZWR1Y2UoKFAsUyk9PlArUy5qb2luKCIgIiksIiIpfWNsYXNzIGYgZXh0ZW5kcyBvLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tUXSh7cmFkaXVzWDowLHJhZGl1c1k6MCxzdGFydEFuZ2xlOjAsZW5kQW5nbGU6MzYwLGRpcmVjdGlvbjoiY2xvY2t3aXNlIixjbG9zZVR5cGU6Im5vbmUifSksdGhpc1tjXSgicmFkaXVzIiwiYW5nbGUiKX1nZXQgZCgpe3JldHVybiB0aGlzW3VdKCJkIil9c2V0IGQoeSl7fWdldCByYWRpdXNYKCl7cmV0dXJuIHRoaXNbdV0oInJhZGl1c1giKX1zZXQgcmFkaXVzWCh5KXtpZih5PU9iamVjdCh2LnRvTnVtYmVyKSh5KSx0aGlzW2RdKCJyYWRpdXNYIix5KSl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgcmFkaXVzWSgpe3JldHVybiB0aGlzW3VdKCJyYWRpdXNZIil9c2V0IHJhZGl1c1koeSl7aWYoeT1PYmplY3Qodi50b051bWJlcikoeSksdGhpc1tkXSgicmFkaXVzWSIseSkpe2NvbnN0IEM9RSh0aGlzKTt0aGlzW2RdKCJkIixDKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLnJhZGl1c1gsdGhpcy5yYWRpdXNZXX1zZXQgcmFkaXVzKHkpe3k9T2JqZWN0KHYudG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMucmFkaXVzWD15WzBdLHRoaXMucmFkaXVzWT15WzFdfWdldCBhbmdsZSgpe3JldHVyblt0aGlzLnN0YXJ0QW5nbGUsdGhpcy5lbmRBbmdsZV19c2V0IGFuZ2xlKHkpe3k9T2JqZWN0KHYudG9BcnJheSkoeSksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMuc3RhcnRBbmdsZT15WzBdLHRoaXMuZW5kQW5nbGU9eVsxXX1nZXQgZGlyZWN0aW9uKCl7cmV0dXJuIHRoaXNbdV0oImRpcmVjdGlvbiIpfXNldCBkaXJlY3Rpb24oeSl7aWYoeSE9bnVsbCYmeSE9PSJjbG9ja3dpc2UiJiZ5IT09ImFudGljbG9ja3dpc2UiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgZGlyZWN0aW9uIHR5cGUuIik7dGhpc1tkXSgiZGlyZWN0aW9uIix5KX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW3VdKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUoeSl7aWYoeT1PYmplY3Qodi50b051bWJlcikoeSksdGhpc1tkXSgic3RhcnRBbmdsZSIseSkpe2NvbnN0IEM9RSh0aGlzKTt0aGlzW2RdKCJkIixDKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKHkpe2lmKHk9T2JqZWN0KHYudG9OdW1iZXIpKHkpLHRoaXNbZF0oImVuZEFuZ2xlIix5KSl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbdV0oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUoeSl7aWYoeSE9bnVsbCYmeSE9PSJub25lIiYmeSE9PSJzZWN0b3IiJiZ5IT09Im5vcm1hbCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjbG9zZVR5cGUgdHlwZS4iKTtpZih0aGlzW2RdKCJjbG9zZVR5cGUiLHkpKXtjb25zdCBDPUUodGhpcyk7dGhpc1tkXSgiZCIsQyl9fX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgYT10KDI0Miksbz10KDIxMyksdj10KDI0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIFQodSxjLEUpe3JldHVybiBjIGluIHU/T2JqZWN0LmRlZmluZVByb3BlcnR5KHUsYyx7dmFsdWU6RSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnVbY109RSx1fWNsYXNzIGQgZXh0ZW5kcyBhLmRlZmF1bHR7fVQoZCwiQXR0ciIsdi5kZWZhdWx0KSxvLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGQsImFyYyIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB2fSk7dmFyIGE9dCgyNDMpLG89dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NsYXNzIHYgZXh0ZW5kcyBhLmRlZmF1bHR7Z2V0IHJhZGl1cygpe3JldHVybiBzdXBlci5yYWRpdXNYfXNldCByYWRpdXMoZCl7ZD1PYmplY3Qoby50b051bWJlcikoZCksc3VwZXIucmFkaXVzWD1kLHN1cGVyLnJhZGl1c1k9ZH19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGE9dCgyMjYpLG89dCgyMTMpLHY9dCgyNDcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBUKHUsYyxFKXtyZXR1cm4gYyBpbiB1P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LGMse3ZhbHVlOkUsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp1W2NdPUUsdX1jbGFzcyBkIGV4dGVuZHMgYS5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtpbm5lclJhZGl1czpjLG91dGVyUmFkaXVzOkUsc3RhcnRBbmdsZTpmLGVuZEFuZ2xlOmd9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4oYz4wfHxFPjApJiZmIT09ZyYmc3VwZXIuaXNWaXNpYmxlfX1UKGQsIkF0dHIiLHYuZGVmYXVsdCksby5kZWZhdWx0LnJlZ2lzdGVyTm9kZShkLCJyaW5nIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgYT10KDEyKSxvPXQoMjI4KSx2PXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBFKGcpe2xldHtpbm5lclJhZGl1czp5LG91dGVyUmFkaXVzOkMsc3RhcnRBbmdsZTp4LGVuZEFuZ2xlOmh9PWc7Y29uc3QgbT1uZXcgYS5GaWd1cmUyRDtpZih4PU1hdGguUEkqeC8xODAsaD1NYXRoLlBJKmgvMTgwLHk+QyYmKFt5LENdPVtDLHldKSx5PD0wJiZtLm1vdmVUbygwLDApLG0uYXJjKDAsMCxDLHgsaCwhMSkseT4wKXtjb25zdCBuPU1hdGguUEkqMjtoPHgmJihoPXgrbisoaC14KSVuKSxoLXg+PW4mJihoPXgrbi0xZS02KSxtLmFyYygwLDAseSxoLHgsITApfXJldHVybiBtLmNsb3NlUGF0aCgpLG0ucGF0aC5yZWR1Y2UoKG4scyk9Pm4rcy5qb2luKCIgIiksIiIpfWNsYXNzIGYgZXh0ZW5kcyBvLmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tUXSh7aW5uZXJSYWRpdXM6MCxvdXRlclJhZGl1czowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjB9KSx0aGlzW2NdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbdV0oImQiKX1zZXQgZCh5KXt9Z2V0IGlubmVyUmFkaXVzKCl7cmV0dXJuIHRoaXNbdV0oImlubmVyUmFkaXVzIil9c2V0IGlubmVyUmFkaXVzKHkpe2lmKHk9T2JqZWN0KHYudG9OdW1iZXIpKHkpLHRoaXNbZF0oImlubmVyUmFkaXVzIix5KSl7Y29uc3QgQz1FKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgb3V0ZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1t1XSgib3V0ZXJSYWRpdXMiKX1zZXQgb3V0ZXJSYWRpdXMoeSl7aWYoeT1PYmplY3Qodi50b051bWJlcikoeSksdGhpc1tkXSgib3V0ZXJSYWRpdXMiLHkpKXtjb25zdCBDPUUodGhpcyk7dGhpc1tkXSgiZCIsQyl9fWdldCByYWRpdXMoKXtyZXR1cm5bdGhpcy5pbm5lclJhZGl1cyx0aGlzLm91dGVyUmFkaXVzXX1zZXQgcmFkaXVzKHkpe3k9T2JqZWN0KHYudG9BcnJheSkoeSwhMCksQXJyYXkuaXNBcnJheSh5KXx8KHk9W3kseV0pLHRoaXMuaW5uZXJSYWRpdXM9eVswXSx0aGlzLm91dGVyUmFkaXVzPXlbMV19Z2V0IHN0YXJ0QW5nbGUoKXtyZXR1cm4gdGhpc1t1XSgic3RhcnRBbmdsZSIpfXNldCBzdGFydEFuZ2xlKHkpe2lmKHk9T2JqZWN0KHYudG9OdW1iZXIpKHkpLHRoaXNbZF0oInN0YXJ0QW5nbGUiLHkpKXtjb25zdCBDPUUodGhpcyk7dGhpc1tkXSgiZCIsQyl9fWdldCBlbmRBbmdsZSgpe3JldHVybiB0aGlzW3VdKCJlbmRBbmdsZSIpfXNldCBlbmRBbmdsZSh5KXtpZih5PU9iamVjdCh2LnRvTnVtYmVyKSh5KSx0aGlzW2RdKCJlbmRBbmdsZSIseSkpe2NvbnN0IEM9RSh0aGlzKTt0aGlzW2RdKCJkIixDKX19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUoeSl7eT1PYmplY3Qodi50b0FycmF5KSh5KSxBcnJheS5pc0FycmF5KHkpfHwoeT1beSx5XSksdGhpcy5zdGFydEFuZ2xlPXlbMF0sdGhpcy5lbmRBbmdsZT15WzFdfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KTt2YXIgYT10KDEyKSxvPXQoMjE4KSx2PXQoMjE5KSxUPXQoMjQ5KSxkPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdSh4LGgsbSl7cmV0dXJuIGggaW4geD9PYmplY3QuZGVmaW5lUHJvcGVydHkoeCxoLHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6eFtoXT1tLHh9Y29uc3QgYz1TeW1ib2woInRleHRJbWFnZSIpLEU9U3ltYm9sKCJ0ZXh0SW1hZ2VUYXNrIiksZj1TeW1ib2woInRleHR1cmVDb250ZXh0IiksZz1TeW1ib2woInVwZGF0ZVRleHR1cmVSZWN0IikseT1TeW1ib2woInRleHRDYW52YXMiKTtjbGFzcyBDIGV4dGVuZHMgdi5kZWZhdWx0e2NvbnN0cnVjdG9yKGg9e30pe3R5cGVvZiBoPT0ic3RyaW5nIiYmKGg9e3RleHQ6aH0pLHN1cGVyKGgpfWdldCBjb250ZW50U2l6ZSgpe2xldFtoLG1dPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOnIsaGVpZ2h0Oml9PXRoaXMuYXR0cmlidXRlcztpZihyPT1udWxsfHxpPT1udWxsKXtjb25zdCBuPXRoaXNbY107biYmKHI9PW51bGwmJihoPW4ucmVjdFsyXSksaT09bnVsbCYmKG09bi5yZWN0WzNdKSl9cmV0dXJuW2gsbV19Z2V0IHRleHQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHQoaCl7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9aH1nZXQgdGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnRleHR9c2V0IHRleHRDb250ZW50KGgpe3RoaXMuYXR0cmlidXRlcy50ZXh0PWh9Z2V0IHRleHRJbWFnZSgpe3JldHVybiB0aGlzW2NdfHx7fX1nZXQgdGV4dEltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1tFXXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhoKXtzdXBlci5kcmF3KGgpO2NvbnN0IG09dGhpcy5tZXNoO2lmKG0pe2NvbnN0IHI9dGhpc1tjXTtpZihyKXtsZXQgaT1tLnRleHR1cmU7aWYoIWl8fHRoaXNbZl0mJnRoaXNbZl0hPT10aGlzLnJlbmRlcmVyfHxyLm5lZWRzVXBkYXRlPyhyLm5lZWRzVXBkYXRlPSExLE9iamVjdChvLmRlbGV0ZVRleHR1cmUpKHIuaW1hZ2UsdGhpcy5yZW5kZXJlciksaT1PYmplY3Qoby5jcmVhdGVUZXh0dXJlKShyLmltYWdlLHRoaXMucmVuZGVyZXIpLHRoaXNbZ109ITApOmk9bS51bmlmb3Jtcy51X3RleFNhbXBsZXIsdGhpc1tnXSl7Y29uc3RbbixzXT1yLnJlY3Quc2xpY2UoMiksW00sUF09dGhpcy5jb250ZW50U2l6ZSxTPXRoaXMuYXR0cmlidXRlcy50ZXh0QWxpZ24sYj10aGlzLmF0dHJpYnV0ZXMudmVydGljYWxBbGlnbjtsZXQgTz0wO1M9PT0iY2VudGVyIj9PPShNLW4pLzI6KFM9PT0icmlnaHQifHxTPT09ImVuZCIpJiYoTz1NLW4pO2NvbnN0IEQ9dGhpcy5hdHRyaWJ1dGVzLmZvbnRTaXplLEk9dGhpcy5hdHRyaWJ1dGVzLmxpbmVIZWlnaHQ7bGV0IFI9MDtiPT09InRvcCI/Uj0oRC1JKS8yOmI9PT0iYm90dG9tIiYmKFI9KEktRCkvMik7Y29uc3R7cGFkZGluZ0xlZnQ6QSxwYWRkaW5nVG9wOlV9PXRoaXMuYXR0cmlidXRlcyx7Ym9yZGVyV2lkdGg6S309dGhpcy5hdHRyaWJ1dGVzO08rPUErSyxSKz1VK0s7Y29uc3R7YW5jaG9yWDpWLGFuY2hvclk6UX09dGhpcy5hdHRyaWJ1dGVzO08tPXRoaXMub2Zmc2V0U2l6ZVswXSpWLFItPXRoaXMub2Zmc2V0U2l6ZVsxXSpRLG0uc2V0VGV4dHVyZShpLHtyZWN0OltPLFIsbixzXX0pLHRoaXNbZ109ITEsdGhpc1tmXT10aGlzLnJlbmRlcmVyfX19cmV0dXJuIGh9b25Qcm9wZXJ0eUNoYW5nZShoLG0scil7aD09PSJ0ZXh0Inx8aD09PSJmb250U2l6ZSJ8fGg9PT0iZm9udEZhbWlseSJ8fGg9PT0iZm9udFN0eWxlInx8aD09PSJmb250VmFyaWFudCJ8fGg9PT0iZm9udFdlaWdodCJ8fGg9PT0iZm9udFN0cmV0Y2gifHxoPT09ImxpbmVIZWlnaHQifHxoPT09InN0cm9rZUNvbG9yInx8aD09PSJmaWxsQ29sb3IifHxoPT09InN0cm9rZVdpZHRoIj90aGlzLnVwZGF0ZVRleHQoKTooKGg9PT0idGV4dEFsaWduInx8aD09PSJ2ZXJ0aWNhbEFsaWduIikmJih0aGlzW2ddPSEwKSxzdXBlci5vblByb3BlcnR5Q2hhbmdlKGgsbSxyKSl9dXBkYXRlQ29udG91cnMoKXtzdXBlci51cGRhdGVDb250b3VycygpLHRoaXNbZ109ITB9dXBkYXRlVGV4dCgpe3RoaXNbRV18fCh0aGlzW0VdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzW0VdPW51bGw7Y29uc3R7dGV4dDpoLGZvbnQ6bSxmaWxsQ29sb3I6cixzdHJva2VDb2xvcjppLHN0cm9rZVdpZHRoOm59PXRoaXMuYXR0cmlidXRlcyxzPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTtyZXR1cm4gdGhpc1t5XT10aGlzW3ldfHxhLkVOVi5jcmVhdGVDYW52YXMoMSwxKSx0aGlzW2NdPWEuRU5WLmNyZWF0ZVRleHQoaCx7Zm9udDptLGZpbGxDb2xvcjpyLHN0cm9rZUNvbG9yOmksc3Ryb2tlV2lkdGg6bixwYXJzZUZvbnQ6YS5wYXJzZUZvbnQscmF0aW86cyx0ZXh0Q2FudmFzOnRoaXNbeV19KSx0aGlzW2NdLm5lZWRzVXBkYXRlPSEwLHRoaXMudXBkYXRlQ29udG91cnMoKSx0aGlzLmZvcmNlVXBkYXRlKCksdGhpc1tjXX0pKX19dShDLCJBdHRyIixULmRlZmF1bHQpLGQuZGVmYXVsdC5yZWdpc3Rlck5vZGUoQywibGFiZWwiKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBhPXQoMTIpLG89dCg3Miksdj10KDIyMSksVD10KDIyMCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxFPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2NsYXNzIGYgZXh0ZW5kcyBULmRlZmF1bHR7Y29uc3RydWN0b3IoeSl7c3VwZXIoeSksdGhpc1tkXSh7dGV4dDoiIixmb250U2l6ZToxNixmb250RmFtaWx5OiJIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZiIsZm9udFN0eWxlOiJub3JtYWwiLGZvbnRWYXJpYW50OiJub3JtYWwiLGZvbnRXZWlnaHQ6Im5vcm1hbCIsZm9udFN0cmV0Y2g6Im5vcm1hbCIsbGluZUhlaWdodDoiIix0ZXh0QWxpZ246ImxlZnQiLHN0cm9rZUNvbG9yOnZvaWQgMCxzdHJva2VXaWR0aDoxLGZpbGxDb2xvcjp2b2lkIDAsdmVydGljYWxBbGlnbjoibWlkZGxlIn0pLHRoaXNbRV0oImZvbnQiKX1nZXQgdGV4dCgpe3JldHVybiB0aGlzW2NdKCJ0ZXh0Iil8fCIgIn1zZXQgdGV4dCh5KXt0aGlzW3VdKCJ0ZXh0Iix5KX1nZXQgZm9udFNpemUoKXtyZXR1cm4gdGhpc1tjXSgiZm9udFNpemUiKX1zZXQgZm9udFNpemUoeSl7dGhpc1t1XSgiZm9udFNpemUiLE9iamVjdChvLnRvTnVtYmVyKSh5KSl9Z2V0IGZvbnRGYW1pbHkoKXtyZXR1cm4gdGhpc1tjXSgiZm9udEZhbWlseSIpfXNldCBmb250RmFtaWx5KHkpe3RoaXNbdV0oImZvbnRGYW1pbHkiLHkpfWdldCBmb250U3R5bGUoKXtyZXR1cm4gdGhpc1tjXSgiZm9udFN0eWxlIil9c2V0IGZvbnRTdHlsZSh5KXt0aGlzW3VdKCJmb250U3R5bGUiLHkpfWdldCBmb250VmFyaWFudCgpe3JldHVybiB0aGlzW2NdKCJmb250VmFyaWFudCIpfXNldCBmb250VmFyaWFudCh5KXt0aGlzW3VdKCJmb250VmFyaWFudCIseSl9Z2V0IGZvbnRXZWlnaHQoKXtyZXR1cm4gdGhpc1tjXSgiZm9udFdlaWdodCIpfXNldCBmb250V2VpZ2h0KHkpe3RoaXNbdV0oImZvbnRXZWlnaHQiLHkpfWdldCBmb250U3RyZXRjaCgpe3JldHVybiB0aGlzW2NdKCJmb250U3RyZXRjaCIpfXNldCBmb250U3RyZXRjaCh5KXt0aGlzW3VdKCJmb250U3RyZXRjaCIseSl9Z2V0IGxpbmVIZWlnaHQoKXtyZXR1cm4gdGhpc1tjXSgibGluZUhlaWdodCIpfHx0aGlzLmZvbnRTaXplfXNldCBsaW5lSGVpZ2h0KHkpe3RoaXNbdV0oImxpbmVIZWlnaHQiLE9iamVjdChvLnRvTnVtYmVyKSh5KSl9Z2V0IHRleHRBbGlnbigpe3JldHVybiB0aGlzW2NdKCJ0ZXh0QWxpZ24iKX1zZXQgdGV4dEFsaWduKHkpe3RoaXNbdV0oInRleHRBbGlnbiIseSl9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbY10oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKHkpe3RoaXNbdV0oInN0cm9rZUNvbG9yIixPYmplY3Qodi5wYXJzZUNvbG9yKSh5KSl9Z2V0IHN0cm9rZVdpZHRoKCl7cmV0dXJuIHRoaXNbY10oInN0cm9rZVdpZHRoIil9c2V0IHN0cm9rZVdpZHRoKHkpe3RoaXNbdV0oInN0cm9rZVdpZHRoIixPYmplY3Qoby50b051bWJlcikoeSkpfWdldCB2ZXJ0aWNhbEFsaWduKCl7cmV0dXJuIHRoaXNbY10oInZlcnRpY2FsQWxpZ24iKX1zZXQgdmVydGljYWxBbGlnbih5KXt0aGlzW3VdKCJ2ZXJ0aWNhbEFsaWduIix5KX1nZXQgZmlsbENvbG9yKCl7cmV0dXJuIHRoaXNbY10oImZpbGxDb2xvciIpfXNldCBmaWxsQ29sb3IoeSl7dGhpc1t1XSgiZmlsbENvbG9yIixPYmplY3Qodi5wYXJzZUNvbG9yKSh5KSl9Z2V0IGZvbnQoKXtjb25zdHtmb250U3R5bGU6eSxmb250VmFyaWFudDpDLGZvbnRXZWlnaHQ6eCxmb250U3RyZXRjaDpoLGZvbnRTaXplOm0sbGluZUhlaWdodDpyLGZvbnRGYW1pbHk6aX09dGhpcztyZXR1cm5gJHt5fSAke0N9ICR7eH0gJHtofSAke219cHgvJHtyfXB4ICR7aX1gfXNldCBmb250KHkpe2lmKHk9PW51bGwpdGhpcy5mb250U3R5bGU9bnVsbCx0aGlzLmZvbnRWYXJpYW50PW51bGwsdGhpcy5mb250V2VpZ2h0PW51bGwsdGhpcy5mb250U3RyZXRjaD1udWxsLHRoaXMuZm9udFNpemU9bnVsbCx0aGlzLmxpbmVIZWlnaHQ9bnVsbCx0aGlzLmZvbnRGYW1pbHk9bnVsbDtlbHNle2NvbnN0IEM9T2JqZWN0KGEucGFyc2VGb250KSh5KTt0aGlzLmZvbnRTdHlsZT1DLnN0eWxlLHRoaXMuZm9udFZhcmlhbnQ9Qy52YXJpYW50LHRoaXMuZm9udFdlaWdodD1DLndlaWdodCx0aGlzLmZvbnRTdHJldGNoPUMuc3RyZXRjaCx0aGlzLmZvbnRTaXplPU9iamVjdChvLnRvTnVtYmVyKShgJHtDLnNpemV9JHtDLnVuaXR9YCksQy5saW5lSGVpZ2h0JiYodGhpcy5saW5lSGVpZ2h0PUMucHhMaW5lSGVpZ2h0KSx0aGlzLmZvbnRGYW1pbHk9Qy5mYW1pbHl9fX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTt2YXIgYT10KDEyKSxvPXQoMjE5KSx2PXQoMjUxKSxUPXQoMjEzKSxkPXQoMjUyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShDLHgsaCl7cmV0dXJuIHggaW4gQz9PYmplY3QuZGVmaW5lUHJvcGVydHkoQyx4LHt2YWx1ZTpoLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Q1t4XT1oLEN9Y29uc3QgYz1TeW1ib2woInpPcmRlciIpLEU9U3ltYm9sKCJvcmRlcmVkIiksZj1TeW1ib2woImNoaWxkcmVuIiksZz1TeW1ib2woInNlYWxlZCIpO2NsYXNzIHkgZXh0ZW5kcyBvLmRlZmF1bHR7Y29uc3RydWN0b3IoeD17fSl7c3VwZXIoeCksdGhpc1tmXT1bXSx0aGlzW0VdPW51bGwsdGhpc1tjXT0wfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuIHRoaXNbZl19Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXNbZl19Z2V0IG9yZGVyZWRDaGlsZHJlbigpe3JldHVybiB0aGlzW0VdfHwodGhpc1tFXT1bLi4udGhpc1tmXV0sdGhpc1tFXS5zb3J0KCh4LGgpPT54LnpJbmRleC1oLnpJbmRleHx8eC56T3JkZXItaC56T3JkZXIpKSx0aGlzW0VdfWFwcGVuZCguLi54KXtyZXR1cm4geC5tYXAoaD0+dGhpcy5hcHBlbmRDaGlsZChoKSl9YXBwZW5kQ2hpbGQoeCl7cmV0dXJuIHgucmVtb3ZlKCksdGhpc1tmXS5wdXNoKHgpLHguY29ubmVjdCh0aGlzLHRoaXNbY10rKyksdGhpc1tFXSYmKHRoaXNbRV0ubGVuZ3RoJiZ4LnpJbmRleDx0aGlzW0VdW3RoaXNbRV0ubGVuZ3RoLTFdLnpJbmRleD90aGlzLnJlb3JkZXIoKTp0aGlzW0VdLnB1c2goeCkpLHh9Y2xvbmVOb2RlKHg9ITEpe2NvbnN0IGg9c3VwZXIuY2xvbmVOb2RlKCk7cmV0dXJuIHgmJnRoaXNbZl0uZm9yRWFjaChtPT57Y29uc3Qgcj1tLmNsb25lTm9kZSh4KTtoLmFwcGVuZENoaWxkKHIpfSksaH1kaXNwYXRjaFBvaW50ZXJFdmVudCh4KXtjb25zdCBoPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgbT1oLmxlbmd0aC0xO20+PTA7bS0tKWlmKGhbbV0uZGlzcGF0Y2hQb2ludGVyRXZlbnQoeCkpcmV0dXJuITA7cmV0dXJuIHN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KHgpfWRyYXcoeD1bXSl7aWYodGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PXRoaXMucmVuZGVyTWF0cml4LHN1cGVyLmRyYXcoeCksIXRoaXNbZ10mJnRoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiKXtjb25zdCBoPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgbT0wO208aC5sZW5ndGg7bSsrKWhbbV0uZHJhdyh4KX1yZXR1cm4gdGhpcy5fX2NhY2hlUmVuZGVyTWF0cml4PW51bGwseH1nZXRFbGVtZW50QnlJZCh4KXtyZXR1cm4gT2JqZWN0KGQucXVlcnlTZWxlY3RvcikoYCMke3h9YCx0aGlzKX1nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHgpe3JldHVybiBPYmplY3QoZC5xdWVyeVNlbGVjdG9yQWxsKShgLiR7eH1gLHRoaXMpfWdldEVsZW1lbnRzQnlOYW1lKHgpe3JldHVybiBPYmplY3QoZC5xdWVyeVNlbGVjdG9yQWxsKShgW25hbWU9IiR7eH0iXWAsdGhpcyl9Z2V0RWxlbWVudHNCeVRhZ05hbWUoeCl7cmV0dXJuIE9iamVjdChkLnF1ZXJ5U2VsZWN0b3JBbGwpKHgsdGhpcyl9aW5zZXJ0QmVmb3JlKHgsaCl7aWYoaD09bnVsbClyZXR1cm4gdGhpcy5hcHBlbmRDaGlsZCh4KTt4LnJlbW92ZSgpO2NvbnN0IG09dGhpc1tmXS5pbmRleE9mKGgpO2lmKG08MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7Y29uc3Qgcj1oLnpPcmRlcjtmb3IobGV0IGk9bTtpPHRoaXNbZl0ubGVuZ3RoO2krKyl7Y29uc3Qgbj10aGlzW2ZdW2ldLnpPcmRlcixzPXRoaXNbZl1baV07ZGVsZXRlIHMuek9yZGVyLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCJ6T3JkZXIiLHt2YWx1ZTpuKzEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9aWYodGhpc1tmXS5zcGxpY2UobSwwLHgpLHguY29ubmVjdCh0aGlzLHIpLHRoaXNbRV0paWYoeC56SW5kZXghPT1oLnpJbmRleCl0aGlzLnJlb3JkZXIoKTtlbHNle2NvbnN0IGk9dGhpc1tFXS5pbmRleE9mKGgpO3RoaXNbRV0uc3BsaWNlKGksMCx4KX1yZXR1cm4geH1xdWVyeVNlbGVjdG9yKHgpe3JldHVybiBPYmplY3QoZC5xdWVyeVNlbGVjdG9yKSh4LHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwoeCl7cmV0dXJuIE9iamVjdChkLnF1ZXJ5U2VsZWN0b3JBbGwpKHgsdGhpcyl9cmVwbGFjZUNoaWxkKHgsaCl7eC5yZW1vdmUoKTtjb25zdCBtPXRoaXNbZl0uaW5kZXhPZihoKTtpZihtPDApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJlZmVyZW5jZSBub2RlLiIpO2lmKHRoaXNbZl1bbV09eCx4LmNvbm5lY3QodGhpcyxoLnpPcmRlciksdGhpc1tFXSlpZih4LnpJbmRleCE9PWguekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3Qgcj10aGlzW0VdLmluZGV4T2YoaCk7dGhpc1tFXVtyXT14fXJldHVybiBoLmRpc2Nvbm5lY3QodGhpcykseH1yZW1vdmVBbGxDaGlsZHJlbigpe2NvbnN0IHg9dGhpc1tmXTtmb3IobGV0IGg9eC5sZW5ndGgtMTtoPj0wO2gtLSl4W2hdLnJlbW92ZSgpfXJlbW92ZUNoaWxkKHgpe2NvbnN0IGg9dGhpc1tmXS5pbmRleE9mKHgpO2lmKGg+PTApe2lmKHRoaXNbZl0uc3BsaWNlKGgsMSksdGhpc1tFXSl7Y29uc3QgbT10aGlzW0VdLmluZGV4T2YoeCk7dGhpc1tFXS5zcGxpY2UobSwxKX1yZXR1cm4geC5kaXNjb25uZWN0KHRoaXMpLHh9cmV0dXJuIG51bGx9cmVvcmRlcigpe3RoaXNbRV09bnVsbH1zZWFsKCl7ZnVuY3Rpb24geChpLG4pe2NvbnN0IHM9W107Zm9yKGxldCBNPTA7TTxpLmxlbmd0aDtNKyspe2NvbnN0IFA9Wy4uLmlbTV1dO2ZvcihsZXQgUz0xO1M8UC5sZW5ndGg7Uys9Mil7Y29uc3QgYj1QW1NdLE89UFtTKzFdO1BbU109YipuWzBdK08qblsyXStuWzRdLFBbUysxXT1iKm5bMV0rTypuWzNdK25bNV19cy5wdXNoKFApfXJldHVybiBzfWNvbnN0IGg9dGhpcy5vcmRlcmVkQ2hpbGRyZW4sbT1uZXcgYS5GaWd1cmUyRCxyPXRoaXMubG9jYWxNYXRyaXg7Zm9yKGxldCBpPTA7aTxoLmxlbmd0aDtpKyspe2xldCBuPWhbaV07aWYobiBpbnN0YW5jZW9mIHkmJihuPW4uc2VhbCgpKSxuLmNsaWVudEJveCl7bGV0IHM9bi5jbGllbnRCb3guY29udG91cnMucGF0aDtzPXgocyxuLmxvY2FsTWF0cml4KSxtLmFkZFBhdGgocyl9aWYobi5wYXRoKXtsZXQgcz1uLnBhdGguY29udG91cnMucGF0aDtzPXgocyxuLmxvY2FsTWF0cml4KSxtLmFkZFBhdGgocyl9fXJldHVybiB0aGlzW2ddPSEwLHRoaXMuY2xpZW50Qm94PW0se2NsaWVudEJveDptLGxvY2FsTWF0cml4OnJ9fXNldFJlc29sdXRpb24oe3dpZHRoOngsaGVpZ2h0Omh9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDp4LGhlaWdodDpofSksdGhpc1tmXS5mb3JFYWNoKG09PnttLnNldFJlc29sdXRpb24oe3dpZHRoOngsaGVpZ2h0Omh9KX0pfXVwZGF0ZUNvbnRvdXJzKCl7dGhpc1tnXXx8c3VwZXIudXBkYXRlQ29udG91cnMoKX19dSh5LCJBdHRyIix2LmRlZmF1bHQpLFQuZGVmYXVsdC5yZWdpc3Rlck5vZGUoeSwiZ3JvdXAiKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pO3ZhciBhPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgbyBleHRlbmRzIGEuZGVmYXVsdHt9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJxdWVyeVNlbGVjdG9yQWxsIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInF1ZXJ5U2VsZWN0b3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSx0LmQoZSwiaXNNYXRjaGVkIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImNvbXBpbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KTt2YXIgYT10KDIyMSksbz10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IHY9dCgyNTMpO2Z1bmN0aW9uIFQoaCl7cmV0dXJuIGgubm9kZVR5cGU9PT0xfHxvLmRlZmF1bHQuaXNTcHJpdGVOb2RlKGgubm9kZU5hbWUpfWZ1bmN0aW9uIGQoaCl7cmV0dXJuIEFycmF5LmZyb20oaC5jaGlsZE5vZGVzfHxbXSl9ZnVuY3Rpb24gdShoKXtyZXR1cm4gby5kZWZhdWx0LmlzU3ByaXRlTm9kZShoLm5vZGVOYW1lKT9oLnBhcmVudHx8aC5jYW52YXN8fGguY29udGFpbmVyOmgucGFyZW50RWxlbWVudH1mdW5jdGlvbiBjKGgpe2xldCBtPWgubGVuZ3RoLHIsaSxuO2Zvcig7LS1tPi0xOyl7Zm9yKHI9aT1oW21dLGhbbV09bnVsbCxuPSEwO2k7KXtpZihoLmluZGV4T2YoaSk+LTEpe249ITEsaC5zcGxpY2UobSwxKTticmVha31pPXUoaSl9biYmKGhbbV09cil9cmV0dXJuIGh9Y29uc3QgRT17aXNUYWc6VCxleGlzdHNPbmUoaCxtKXtyZXR1cm4gbS5zb21lKHI9PlQocik/aChyKXx8RS5leGlzdHNPbmUoaCxkKHIpKTohMSl9LGdldFNpYmxpbmdzKGgpe2NvbnN0IG09dShoKTtyZXR1cm4gbSYmZChtKX0sZ2V0Q2hpbGRyZW46ZCxnZXRQYXJlbnQ6dSxnZXRBdHRyaWJ1dGVWYWx1ZShoLG0pe2lmKGgubm9kZVR5cGU9PT0xJiZtPT09ImNsYXNzInx8bT09PSJpZCIpcmV0dXJuIGhbbV07aWYodGhpcy5oYXNBdHRyaWIoaCxtKSl7bGV0IHI9aC5hdHRyaWJ1dGVzW21dO3JldHVybiBBcnJheS5pc0FycmF5KHIpJiYocj1gWyR7ci5qb2luKCl9XWApLFN0cmluZyhyKX19LGhhc0F0dHJpYihoLG0pe3JldHVybiBoLmF0dHJpYnV0ZXNbbV0hPW51bGx9LHJlbW92ZVN1YnNldHM6YyxnZXROYW1lKGgpe3JldHVybiBoLnRhZ05hbWU/aC50YWdOYW1lLnRvTG93ZXJDYXNlKCk6bnVsbH0sZmluZE9uZTpmdW5jdGlvbiBoKG0scil7bGV0IGk9bnVsbDtmb3IobGV0IG49MCxzPXIubGVuZ3RoO248cyYmIWk7bisrKWlmKG0ocltuXSkpaT1yW25dO2Vsc2V7Y29uc3QgTT1kKHJbbl0pO00mJk0ubGVuZ3RoPjAmJihpPWgobSxNKSl9cmV0dXJuIGl9LGZpbmRBbGw6ZnVuY3Rpb24gaChtLHIpe2xldCBpPVtdO2ZvcihsZXQgbj0wLHM9ci5sZW5ndGg7bjxzO24rKyl7aWYoIVQocltuXSkpY29udGludWU7bShyW25dKSYmaS5wdXNoKHJbbl0pO2NvbnN0IE09ZChyW25dKTtNJiYoaT1pLmNvbmNhdChoKG0sTSkpKX1yZXR1cm4gaX0sZ2V0VGV4dDpmdW5jdGlvbiBoKG0pe3JldHVybiBBcnJheS5pc0FycmF5KG0pP20ubWFwKGgpLmpvaW4oIiIpOlQobSk/aChkKG0pKTptLm5vZGVUeXBlPT09Mz9tLm5vZGVWYWx1ZTpvLmRlZmF1bHQuaXNTcHJpdGVOb2RlKG0ubm9kZU5hbWUpP20udGV4dDoiIn19O2Z1bmN0aW9uIGYoaCl7aWYodHlwZW9mIGghPSJzdHJpbmciKXJldHVybiBoO2xldCBtPWgubWF0Y2goL1xbKGJnY29sb3J8ZmlsbENvbG9yfHN0cm9rZUNvbG9yfGNvbG9yKVxzKj1ccypbJyJdP1x3K1snIl0/XF0vZyk7cmV0dXJuIG0mJihtPW0ubWFwKHI9Pntjb25zdCBpPXIuc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxuPU9iamVjdChhLnBhcnNlQ29sb3IpKGlbMV0ucmVwbGFjZSgvWyciXS9nLCIiKSk7cmV0dXJuW3IsYFske2lbMF19PSIke259Il1gXX0pLG0uZm9yRWFjaCgoW3IsaV0pPT57aD1oLnJlcGxhY2UocixpKX0pKSxtPWgubWF0Y2goL1xbXHcrXHMqPVxzKlsnIl1cWy4rP1xdWyciXVxdL2cpLG0mJihtPW0ubWFwKHI9Pntjb25zdCBpPXIuc2xpY2UoMSwtMSkuc3BsaXQoIj0iKSxuPWlbMV0uc2xpY2UoMiwtMikuc3BsaXQoLywvZykubWFwKHM9PnMudHJpbSgpKTtyZXR1cm5bcixgWyR7aVswXX09Ilske259XSJdYF19KSxtLmZvckVhY2goKFtyLGldKT0+e2g9aC5yZXBsYWNlKHIsaSl9KSksaH1mdW5jdGlvbiBnKGgsbSl7cmV0dXJuIHYuc2VsZWN0QWxsKGYoaCksbSx7YWRhcHRlcjpFfSl9ZnVuY3Rpb24geShoLG0pe3JldHVybiB2LnNlbGVjdE9uZShmKGgpLG0se2FkYXB0ZXI6RX0pfWZ1bmN0aW9uIEMoaCxtKXtyZXR1cm4gdi5pcyhoLGYobSkse2FkYXB0ZXI6RX0pfWZ1bmN0aW9uIHgoaCl7cmV0dXJuIHYuY29tcGlsZShmKGgpLHthZGFwdGVyOkV9KX19LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9eDt2YXIgYT10KDI1NCksbz10KDI3MykuZmFsc2VGdW5jLHY9dCgyNzQpO2Z1bmN0aW9uIFQoaCl7cmV0dXJuIGZ1bmN0aW9uKHIsaSxuKXtyZXR1cm4gaT1pfHx7fSxpLmFkYXB0ZXI9aS5hZGFwdGVyfHxhLGgocixpLG4pfX12YXIgZD1UKHYpLHU9VCh2LmNvbXBpbGVVbnNhZmUpO2Z1bmN0aW9uIGMoaCl7cmV0dXJuIGZ1bmN0aW9uKHIsaSxuKXtyZXR1cm4gbj1ufHx7fSxuLmFkYXB0ZXI9bi5hZGFwdGVyfHxhLHR5cGVvZiByIT0iZnVuY3Rpb24iJiYocj11KHIsbixpKSksci5zaG91bGRUZXN0TmV4dFNpYmxpbmdzJiYoaT1mKG4mJm4uY29udGV4dHx8aSxuLmFkYXB0ZXIpKSxBcnJheS5pc0FycmF5KGkpP2k9bi5hZGFwdGVyLnJlbW92ZVN1YnNldHMoaSk6aT1uLmFkYXB0ZXIuZ2V0Q2hpbGRyZW4oaSksaChyLGksbil9fWZ1bmN0aW9uIEUoaCxtKXt2YXIgcj1tLmdldFNpYmxpbmdzKGgpO2lmKCFBcnJheS5pc0FycmF5KHIpKXJldHVybltdO2ZvcihyPXIuc2xpY2UoMCk7ci5zaGlmdCgpIT09aDspO3JldHVybiByfWZ1bmN0aW9uIGYoaCxtKXtBcnJheS5pc0FycmF5KGgpfHwoaD1baF0pO2Zvcih2YXIgcj1oLnNsaWNlKDApLGk9MCxuPWgubGVuZ3RoO2k8bjtpKyspe3ZhciBzPUUocltpXSxtKTtyLnB1c2guYXBwbHkocixzKX1yZXR1cm4gcn12YXIgZz1jKGZ1bmN0aW9uKG0scixpKXtyZXR1cm4gbT09PW98fCFyfHxyLmxlbmd0aD09PTA/W106aS5hZGFwdGVyLmZpbmRBbGwobSxyKX0pLHk9YyhmdW5jdGlvbihtLHIsaSl7cmV0dXJuIG09PT1vfHwhcnx8ci5sZW5ndGg9PT0wP251bGw6aS5hZGFwdGVyLmZpbmRPbmUobSxyKX0pO2Z1bmN0aW9uIEMoaCxtLHIpe3JldHVybiByPXJ8fHt9LHIuYWRhcHRlcj1yLmFkYXB0ZXJ8fGEsKHR5cGVvZiBtPT0iZnVuY3Rpb24iP206ZChtLHIpKShoKX1mdW5jdGlvbiB4KGgsbSxyKXtyZXR1cm4gZyhoLG0scil9eC5jb21waWxlPWQseC5maWx0ZXJzPXYuUHNldWRvcy5maWx0ZXJzLHgucHNldWRvcz12LlBzZXVkb3MucHNldWRvcyx4LnNlbGVjdEFsbD1nLHguc2VsZWN0T25lPXkseC5pcz1DLHgucGFyc2U9ZCx4Lml0ZXJhdGU9Zyx4Ll9jb21waWxlVW5zYWZlPXUseC5fY29tcGlsZVRva2VuPXYuY29tcGlsZVRva2VufSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9TC5leHBvcnRzO1t0KDI1NSksdCgyNjgpLHQoMjY5KSx0KDI3MCksdCgyNzEpLHQoMjcyKV0uZm9yRWFjaChmdW5jdGlvbihvKXtPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKHYpe2Fbdl09b1t2XS5iaW5kKGEpfSl9KX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMjU2KSxvPXQoMjU3KSx2PWEuaXNUYWc7TC5leHBvcnRzPXtnZXRJbm5lckhUTUw6VCxnZXRPdXRlckhUTUw6byxnZXRUZXh0OmR9O2Z1bmN0aW9uIFQodSxjKXtyZXR1cm4gdS5jaGlsZHJlbj91LmNoaWxkcmVuLm1hcChmdW5jdGlvbihFKXtyZXR1cm4gbyhFLGMpfSkuam9pbigiIik6IiJ9ZnVuY3Rpb24gZCh1KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh1KT91Lm1hcChkKS5qb2luKCIiKTp2KHUpP3UubmFtZT09PSJiciI/YApgOmQodS5jaGlsZHJlbik6dS50eXBlPT09YS5DREFUQT9kKHUuY2hpbGRyZW4pOnUudHlwZT09PWEuVGV4dD91LmRhdGE6IiJ9fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz17VGV4dDoidGV4dCIsRGlyZWN0aXZlOiJkaXJlY3RpdmUiLENvbW1lbnQ6ImNvbW1lbnQiLFNjcmlwdDoic2NyaXB0IixTdHlsZToic3R5bGUiLFRhZzoidGFnIixDREFUQToiY2RhdGEiLERvY3R5cGU6ImRvY3R5cGUiLGlzVGFnOmZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGU9PT0idGFnInx8dC50eXBlPT09InNjcmlwdCJ8fHQudHlwZT09PSJzdHlsZSJ9fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMjU4KSxvPXQoMjU5KSx2PXQoMjY3KTt2LmVsZW1lbnROYW1lcy5fX3Byb3RvX189bnVsbCx2LmF0dHJpYnV0ZU5hbWVzLl9fcHJvdG9fXz1udWxsO3ZhciBUPXtfX3Byb3RvX186bnVsbCxzdHlsZTohMCxzY3JpcHQ6ITAseG1wOiEwLGlmcmFtZTohMCxub2VtYmVkOiEwLG5vZnJhbWVzOiEwLHBsYWludGV4dDohMCxub3NjcmlwdDohMH07ZnVuY3Rpb24gZChoLG0pe2lmKGgpe3ZhciByPSIiLGk7Zm9yKHZhciBuIGluIGgpaT1oW25dLHImJihyKz0iICIpLG0ueG1sTW9kZT09PSJmb3JlaWduIiYmKG49di5hdHRyaWJ1dGVOYW1lc1tuXXx8bikscis9biwoaSE9PW51bGwmJmkhPT0iInx8bS54bWxNb2RlKSYmKHIrPSc9IicrKG0uZGVjb2RlRW50aXRpZXM/by5lbmNvZGVYTUwoaSk6aS5yZXBsYWNlKC9cIi9nLCImcXVvdDsiKSkrJyInKTtyZXR1cm4gcn19dmFyIHU9e19fcHJvdG9fXzpudWxsLGFyZWE6ITAsYmFzZTohMCxiYXNlZm9udDohMCxicjohMCxjb2w6ITAsY29tbWFuZDohMCxlbWJlZDohMCxmcmFtZTohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsaXNpbmRleDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9LGM9TC5leHBvcnRzPWZ1bmN0aW9uKGgsbSl7IUFycmF5LmlzQXJyYXkoaCkmJiFoLmNoZWVyaW8mJihoPVtoXSksbT1tfHx7fTtmb3IodmFyIHI9IiIsaT0wO2k8aC5sZW5ndGg7aSsrKXt2YXIgbj1oW2ldO24udHlwZT09PSJyb290Ij9yKz1jKG4uY2hpbGRyZW4sbSk6YS5pc1RhZyhuKT9yKz1mKG4sbSk6bi50eXBlPT09YS5EaXJlY3RpdmU/cis9ZyhuKTpuLnR5cGU9PT1hLkNvbW1lbnQ/cis9eChuKTpuLnR5cGU9PT1hLkNEQVRBP3IrPUMobik6cis9eShuLG0pfXJldHVybiByfSxFPVsibWkiLCJtbyIsIm1uIiwibXMiLCJtdGV4dCIsImFubm90YXRpb24teG1sIiwiZm9yZWlnbk9iamVjdCIsImRlc2MiLCJ0aXRsZSJdO2Z1bmN0aW9uIGYoaCxtKXttLnhtbE1vZGU9PT0iZm9yZWlnbiImJihoLm5hbWU9di5lbGVtZW50TmFtZXNbaC5uYW1lXXx8aC5uYW1lLGgucGFyZW50JiZFLmluZGV4T2YoaC5wYXJlbnQubmFtZSk+PTAmJihtPU9iamVjdC5hc3NpZ24oe30sbSx7eG1sTW9kZTohMX0pKSksIW0ueG1sTW9kZSYmWyJzdmciLCJtYXRoIl0uaW5kZXhPZihoLm5hbWUpPj0wJiYobT1PYmplY3QuYXNzaWduKHt9LG0se3htbE1vZGU6ImZvcmVpZ24ifSkpO3ZhciByPSI8IitoLm5hbWUsaT1kKGguYXR0cmlicyxtKTtyZXR1cm4gaSYmKHIrPSIgIitpKSxtLnhtbE1vZGUmJighaC5jaGlsZHJlbnx8aC5jaGlsZHJlbi5sZW5ndGg9PT0wKT9yKz0iLz4iOihyKz0iPiIsaC5jaGlsZHJlbiYmKHIrPWMoaC5jaGlsZHJlbixtKSksKCF1W2gubmFtZV18fG0ueG1sTW9kZSkmJihyKz0iPC8iK2gubmFtZSsiPiIpKSxyfWZ1bmN0aW9uIGcoaCl7cmV0dXJuIjwiK2guZGF0YSsiPiJ9ZnVuY3Rpb24geShoLG0pe3ZhciByPWguZGF0YXx8IiI7cmV0dXJuIG0uZGVjb2RlRW50aXRpZXMmJiEoaC5wYXJlbnQmJmgucGFyZW50Lm5hbWUgaW4gVCkmJihyPW8uZW5jb2RlWE1MKHIpKSxyfWZ1bmN0aW9uIEMoaCl7cmV0dXJuIjwhW0NEQVRBWyIraC5jaGlsZHJlblswXS5kYXRhKyJdXT4ifWZ1bmN0aW9uIHgoaCl7cmV0dXJuIjwhLS0iK2guZGF0YSsiLS0+In19LGZ1bmN0aW9uKEwsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gYShvKXtyZXR1cm4gby50eXBlPT09InRhZyJ8fG8udHlwZT09PSJzY3JpcHQifHxvLnR5cGU9PT0ic3R5bGUifWUuaXNUYWc9YSxlLlRleHQ9InRleHQiLGUuRGlyZWN0aXZlPSJkaXJlY3RpdmUiLGUuQ29tbWVudD0iY29tbWVudCIsZS5TY3JpcHQ9InNjcmlwdCIsZS5TdHlsZT0ic3R5bGUiLGUuVGFnPSJ0YWciLGUuQ0RBVEE9ImNkYXRhIixlLkRvY3R5cGU9ImRvY3R5cGUifSxmdW5jdGlvbihMLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZW5jb2RlPWUuZGVjb2RlU3RyaWN0PWUuZGVjb2RlPXZvaWQgMDt2YXIgYT10KDI2MCksbz10KDI2Nik7ZnVuY3Rpb24gdihFLGYpe3JldHVybighZnx8Zjw9MD9hLmRlY29kZVhNTDphLmRlY29kZUhUTUwpKEUpfWUuZGVjb2RlPXY7ZnVuY3Rpb24gVChFLGYpe3JldHVybighZnx8Zjw9MD9hLmRlY29kZVhNTDphLmRlY29kZUhUTUxTdHJpY3QpKEUpfWUuZGVjb2RlU3RyaWN0PVQ7ZnVuY3Rpb24gZChFLGYpe3JldHVybighZnx8Zjw9MD9vLmVuY29kZVhNTDpvLmVuY29kZUhUTUwpKEUpfWUuZW5jb2RlPWQ7dmFyIHU9dCgyNjYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVYTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmVuY29kZVhNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZW5jb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZXNjYXBlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5lc2NhcGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZW5jb2RlSFRNTH19KTt2YXIgYz10KDI2MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVjb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNVN0cmljdCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVjb2RlSFRNTFN0cmljdH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MU3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVYTUx9fSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZil7cmV0dXJuIGYmJmYuX19lc01vZHVsZT9mOntkZWZhdWx0OmZ9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5kZWNvZGVIVE1MPWUuZGVjb2RlSFRNTFN0cmljdD1lLmRlY29kZVhNTD12b2lkIDA7dmFyIG89YSh0KDI2MSkpLHY9YSh0KDI2MikpLFQ9YSh0KDI2MykpLGQ9YSh0KDI2NCkpO2UuZGVjb2RlWE1MPXUoVC5kZWZhdWx0KSxlLmRlY29kZUhUTUxTdHJpY3Q9dShvLmRlZmF1bHQpO2Z1bmN0aW9uIHUoZil7dmFyIGc9T2JqZWN0LmtleXMoZikuam9pbigifCIpLHk9RShmKTtnKz0ifCNbeFhdW1xcZGEtZkEtRl0rfCNcXGQrIjt2YXIgQz1uZXcgUmVnRXhwKCImKD86IitnKyIpOyIsImciKTtyZXR1cm4gZnVuY3Rpb24oeCl7cmV0dXJuIFN0cmluZyh4KS5yZXBsYWNlKEMseSl9fXZhciBjPWZ1bmN0aW9uKGYsZyl7cmV0dXJuIGY8Zz8xOi0xfTtlLmRlY29kZUhUTUw9ZnVuY3Rpb24oKXtmb3IodmFyIGY9T2JqZWN0LmtleXModi5kZWZhdWx0KS5zb3J0KGMpLGc9T2JqZWN0LmtleXMoby5kZWZhdWx0KS5zb3J0KGMpLHk9MCxDPTA7eTxnLmxlbmd0aDt5KyspZltDXT09PWdbeV0/KGdbeV0rPSI7PyIsQysrKTpnW3ldKz0iOyI7dmFyIHg9bmV3IFJlZ0V4cCgiJig/OiIrZy5qb2luKCJ8IikrInwjW3hYXVtcXGRhLWZBLUZdKzs/fCNcXGQrOz8pIiwiZyIpLGg9RShvLmRlZmF1bHQpO2Z1bmN0aW9uIG0ocil7cmV0dXJuIHIuc3Vic3RyKC0xKSE9PSI7IiYmKHIrPSI7IiksaChyKX1yZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIFN0cmluZyhyKS5yZXBsYWNlKHgsbSl9fSgpO2Z1bmN0aW9uIEUoZil7cmV0dXJuIGZ1bmN0aW9uKHkpe2lmKHkuY2hhckF0KDEpPT09IiMiKXt2YXIgQz15LmNoYXJBdCgyKTtyZXR1cm4gQz09PSJYInx8Qz09PSJ4Ij9kLmRlZmF1bHQocGFyc2VJbnQoeS5zdWJzdHIoMyksMTYpKTpkLmRlZmF1bHQocGFyc2VJbnQoeS5zdWJzdHIoMiksMTApKX1yZXR1cm4gZlt5LnNsaWNlKDEsLTEpXX19fSxmdW5jdGlvbihMKXtMLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWJyZXZlIjoixIIiLCJhYnJldmUiOiLEgyIsImFjIjoi4oi+IiwiYWNkIjoi4oi/IiwiYWNFIjoi4oi+zLMiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBY3kiOiLQkCIsImFjeSI6ItCwIiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJhZiI6IuKBoSIsIkFmciI6IvCdlIQiLCJhZnIiOiLwnZSeIiwiQWdyYXZlIjoiw4AiLCJhZ3JhdmUiOiLDoCIsImFsZWZzeW0iOiLihLUiLCJhbGVwaCI6IuKEtSIsIkFscGhhIjoizpEiLCJhbHBoYSI6Is6xIiwiQW1hY3IiOiLEgCIsImFtYWNyIjoixIEiLCJhbWFsZyI6IuKovyIsImFtcCI6IiYiLCJBTVAiOiImIiwiYW5kYW5kIjoi4qmVIiwiQW5kIjoi4qmTIiwiYW5kIjoi4oinIiwiYW5kZCI6IuKpnCIsImFuZHNsb3BlIjoi4qmYIiwiYW5kdiI6IuKpmiIsImFuZyI6IuKIoCIsImFuZ2UiOiLipqQiLCJhbmdsZSI6IuKIoCIsImFuZ21zZGFhIjoi4qaoIiwiYW5nbXNkYWIiOiLipqkiLCJhbmdtc2RhYyI6IuKmqiIsImFuZ21zZGFkIjoi4qarIiwiYW5nbXNkYWUiOiLipqwiLCJhbmdtc2RhZiI6IuKmrSIsImFuZ21zZGFnIjoi4qauIiwiYW5nbXNkYWgiOiLipq8iLCJhbmdtc2QiOiLiiKEiLCJhbmdydCI6IuKInyIsImFuZ3J0dmIiOiLiir4iLCJhbmdydHZiZCI6IuKmnSIsImFuZ3NwaCI6IuKIoiIsImFuZ3N0Ijoiw4UiLCJhbmd6YXJyIjoi4o28IiwiQW9nb24iOiLEhCIsImFvZ29uIjoixIUiLCJBb3BmIjoi8J2UuCIsImFvcGYiOiLwnZWSIiwiYXBhY2lyIjoi4qmvIiwiYXAiOiLiiYgiLCJhcEUiOiLiqbAiLCJhcGUiOiLiiYoiLCJhcGlkIjoi4omLIiwiYXBvcyI6IlwnIiwiQXBwbHlGdW5jdGlvbiI6IuKBoSIsImFwcHJveCI6IuKJiCIsImFwcHJveGVxIjoi4omKIiwiQXJpbmciOiLDhSIsImFyaW5nIjoiw6UiLCJBc2NyIjoi8J2SnCIsImFzY3IiOiLwnZK2IiwiQXNzaWduIjoi4omUIiwiYXN0IjoiKiIsImFzeW1wIjoi4omIIiwiYXN5bXBlcSI6IuKJjSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJhd2NvbmludCI6IuKIsyIsImF3aW50Ijoi4qiRIiwiYmFja2NvbmciOiLiiYwiLCJiYWNrZXBzaWxvbiI6Is+2IiwiYmFja3ByaW1lIjoi4oC1IiwiYmFja3NpbSI6IuKIvSIsImJhY2tzaW1lcSI6IuKLjSIsIkJhY2tzbGFzaCI6IuKIliIsIkJhcnYiOiLiq6ciLCJiYXJ2ZWUiOiLiir0iLCJiYXJ3ZWQiOiLijIUiLCJCYXJ3ZWQiOiLijIYiLCJiYXJ3ZWRnZSI6IuKMhSIsImJicmsiOiLijrUiLCJiYnJrdGJyayI6IuKOtiIsImJjb25nIjoi4omMIiwiQmN5Ijoi0JEiLCJiY3kiOiLQsSIsImJkcXVvIjoi4oCeIiwiYmVjYXVzIjoi4oi1IiwiYmVjYXVzZSI6IuKItSIsIkJlY2F1c2UiOiLiiLUiLCJiZW1wdHl2Ijoi4qawIiwiYmVwc2kiOiLPtiIsImJlcm5vdSI6IuKErCIsIkJlcm5vdWxsaXMiOiLihKwiLCJCZXRhIjoizpIiLCJiZXRhIjoizrIiLCJiZXRoIjoi4oS2IiwiYmV0d2VlbiI6IuKJrCIsIkJmciI6IvCdlIUiLCJiZnIiOiLwnZSfIiwiYmlnY2FwIjoi4ouCIiwiYmlnY2lyYyI6IuKXryIsImJpZ2N1cCI6IuKLgyIsImJpZ29kb3QiOiLiqIAiLCJiaWdvcGx1cyI6IuKogSIsImJpZ290aW1lcyI6IuKogiIsImJpZ3NxY3VwIjoi4qiGIiwiYmlnc3RhciI6IuKYhSIsImJpZ3RyaWFuZ2xlZG93biI6IuKWvSIsImJpZ3RyaWFuZ2xldXAiOiLilrMiLCJiaWd1cGx1cyI6IuKohCIsImJpZ3ZlZSI6IuKLgSIsImJpZ3dlZGdlIjoi4ouAIiwiYmthcm93Ijoi4qSNIiwiYmxhY2tsb3plbmdlIjoi4qerIiwiYmxhY2tzcXVhcmUiOiLilqoiLCJibGFja3RyaWFuZ2xlIjoi4pa0IiwiYmxhY2t0cmlhbmdsZWRvd24iOiLilr4iLCJibGFja3RyaWFuZ2xlbGVmdCI6IuKXgiIsImJsYWNrdHJpYW5nbGVyaWdodCI6IuKWuCIsImJsYW5rIjoi4pCjIiwiYmxrMTIiOiLilpIiLCJibGsxNCI6IuKWkSIsImJsazM0Ijoi4paTIiwiYmxvY2siOiLilogiLCJibmUiOiI94oOlIiwiYm5lcXVpdiI6IuKJoeKDpSIsImJOb3QiOiLiq60iLCJibm90Ijoi4oyQIiwiQm9wZiI6IvCdlLkiLCJib3BmIjoi8J2VkyIsImJvdCI6IuKKpSIsImJvdHRvbSI6IuKKpSIsImJvd3RpZSI6IuKLiCIsImJveGJveCI6IuKniSIsImJveGRsIjoi4pSQIiwiYm94ZEwiOiLilZUiLCJib3hEbCI6IuKVliIsImJveERMIjoi4pWXIiwiYm94ZHIiOiLilIwiLCJib3hkUiI6IuKVkiIsImJveERyIjoi4pWTIiwiYm94RFIiOiLilZQiLCJib3hoIjoi4pSAIiwiYm94SCI6IuKVkCIsImJveGhkIjoi4pSsIiwiYm94SGQiOiLilaQiLCJib3hoRCI6IuKVpSIsImJveEhEIjoi4pWmIiwiYm94aHUiOiLilLQiLCJib3hIdSI6IuKVpyIsImJveGhVIjoi4pWoIiwiYm94SFUiOiLilakiLCJib3htaW51cyI6IuKKnyIsImJveHBsdXMiOiLiip4iLCJib3h0aW1lcyI6IuKKoCIsImJveHVsIjoi4pSYIiwiYm94dUwiOiLilZsiLCJib3hVbCI6IuKVnCIsImJveFVMIjoi4pWdIiwiYm94dXIiOiLilJQiLCJib3h1UiI6IuKVmCIsImJveFVyIjoi4pWZIiwiYm94VVIiOiLilZoiLCJib3h2Ijoi4pSCIiwiYm94ViI6IuKVkSIsImJveHZoIjoi4pS8IiwiYm94dkgiOiLilaoiLCJib3hWaCI6IuKVqyIsImJveFZIIjoi4pWsIiwiYm94dmwiOiLilKQiLCJib3h2TCI6IuKVoSIsImJveFZsIjoi4pWiIiwiYm94VkwiOiLilaMiLCJib3h2ciI6IuKUnCIsImJveHZSIjoi4pWeIiwiYm94VnIiOiLilZ8iLCJib3hWUiI6IuKVoCIsImJwcmltZSI6IuKAtSIsImJyZXZlIjoiy5giLCJCcmV2ZSI6IsuYIiwiYnJ2YmFyIjoiwqYiLCJic2NyIjoi8J2StyIsIkJzY3IiOiLihKwiLCJic2VtaSI6IuKBjyIsImJzaW0iOiLiiL0iLCJic2ltZSI6IuKLjSIsImJzb2xiIjoi4qeFIiwiYnNvbCI6IlxcXFwiLCJic29saHN1YiI6IuKfiCIsImJ1bGwiOiLigKIiLCJidWxsZXQiOiLigKIiLCJidW1wIjoi4omOIiwiYnVtcEUiOiLiqq4iLCJidW1wZSI6IuKJjyIsIkJ1bXBlcSI6IuKJjiIsImJ1bXBlcSI6IuKJjyIsIkNhY3V0ZSI6IsSGIiwiY2FjdXRlIjoixIciLCJjYXBhbmQiOiLiqYQiLCJjYXBicmN1cCI6IuKpiSIsImNhcGNhcCI6IuKpiyIsImNhcCI6IuKIqSIsIkNhcCI6IuKLkiIsImNhcGN1cCI6IuKphyIsImNhcGRvdCI6IuKpgCIsIkNhcGl0YWxEaWZmZXJlbnRpYWxEIjoi4oWFIiwiY2FwcyI6IuKIqe+4gCIsImNhcmV0Ijoi4oGBIiwiY2Fyb24iOiLLhyIsIkNheWxleXMiOiLihK0iLCJjY2FwcyI6IuKpjSIsIkNjYXJvbiI6IsSMIiwiY2Nhcm9uIjoixI0iLCJDY2VkaWwiOiLDhyIsImNjZWRpbCI6IsOnIiwiQ2NpcmMiOiLEiCIsImNjaXJjIjoixIkiLCJDY29uaW50Ijoi4oiwIiwiY2N1cHMiOiLiqYwiLCJjY3Vwc3NtIjoi4qmQIiwiQ2RvdCI6IsSKIiwiY2RvdCI6IsSLIiwiY2VkaWwiOiLCuCIsIkNlZGlsbGEiOiLCuCIsImNlbXB0eXYiOiLiprIiLCJjZW50IjoiwqIiLCJjZW50ZXJkb3QiOiLCtyIsIkNlbnRlckRvdCI6IsK3IiwiY2ZyIjoi8J2UoCIsIkNmciI6IuKErSIsIkNIY3kiOiLQpyIsImNoY3kiOiLRhyIsImNoZWNrIjoi4pyTIiwiY2hlY2ttYXJrIjoi4pyTIiwiQ2hpIjoizqciLCJjaGkiOiLPhyIsImNpcmMiOiLLhiIsImNpcmNlcSI6IuKJlyIsImNpcmNsZWFycm93bGVmdCI6IuKGuiIsImNpcmNsZWFycm93cmlnaHQiOiLihrsiLCJjaXJjbGVkYXN0Ijoi4oqbIiwiY2lyY2xlZGNpcmMiOiLiipoiLCJjaXJjbGVkZGFzaCI6IuKKnSIsIkNpcmNsZURvdCI6IuKKmSIsImNpcmNsZWRSIjoiwq4iLCJjaXJjbGVkUyI6IuKTiCIsIkNpcmNsZU1pbnVzIjoi4oqWIiwiQ2lyY2xlUGx1cyI6IuKKlSIsIkNpcmNsZVRpbWVzIjoi4oqXIiwiY2lyIjoi4peLIiwiY2lyRSI6IuKngyIsImNpcmUiOiLiiZciLCJjaXJmbmludCI6IuKokCIsImNpcm1pZCI6IuKrryIsImNpcnNjaXIiOiLip4IiLCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLIiLCJDbG9zZUN1cmx5RG91YmxlUXVvdGUiOiLigJ0iLCJDbG9zZUN1cmx5UXVvdGUiOiLigJkiLCJjbHVicyI6IuKZoyIsImNsdWJzdWl0Ijoi4pmjIiwiY29sb24iOiI6IiwiQ29sb24iOiLiiLciLCJDb2xvbmUiOiLiqbQiLCJjb2xvbmUiOiLiiZQiLCJjb2xvbmVxIjoi4omUIiwiY29tbWEiOiIsIiwiY29tbWF0IjoiQCIsImNvbXAiOiLiiIEiLCJjb21wZm4iOiLiiJgiLCJjb21wbGVtZW50Ijoi4oiBIiwiY29tcGxleGVzIjoi4oSCIiwiY29uZyI6IuKJhSIsImNvbmdkb3QiOiLiqa0iLCJDb25ncnVlbnQiOiLiiaEiLCJjb25pbnQiOiLiiK4iLCJDb25pbnQiOiLiiK8iLCJDb250b3VySW50ZWdyYWwiOiLiiK4iLCJjb3BmIjoi8J2VlCIsIkNvcGYiOiLihIIiLCJjb3Byb2QiOiLiiJAiLCJDb3Byb2R1Y3QiOiLiiJAiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjb3B5c3IiOiLihJciLCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsIjoi4oizIiwiY3JhcnIiOiLihrUiLCJjcm9zcyI6IuKclyIsIkNyb3NzIjoi4qivIiwiQ3NjciI6IvCdkp4iLCJjc2NyIjoi8J2SuCIsImNzdWIiOiLiq48iLCJjc3ViZSI6IuKrkSIsImNzdXAiOiLiq5AiLCJjc3VwZSI6IuKrkiIsImN0ZG90Ijoi4ouvIiwiY3VkYXJybCI6IuKkuCIsImN1ZGFycnIiOiLipLUiLCJjdWVwciI6IuKLniIsImN1ZXNjIjoi4oufIiwiY3VsYXJyIjoi4oa2IiwiY3VsYXJycCI6IuKkvSIsImN1cGJyY2FwIjoi4qmIIiwiY3VwY2FwIjoi4qmGIiwiQ3VwQ2FwIjoi4omNIiwiY3VwIjoi4oiqIiwiQ3VwIjoi4ouTIiwiY3VwY3VwIjoi4qmKIiwiY3VwZG90Ijoi4oqNIiwiY3Vwb3IiOiLiqYUiLCJjdXBzIjoi4oiq77iAIiwiY3VyYXJyIjoi4oa3IiwiY3VyYXJybSI6IuKkvCIsImN1cmx5ZXFwcmVjIjoi4oueIiwiY3VybHllcXN1Y2MiOiLii58iLCJjdXJseXZlZSI6IuKLjiIsImN1cmx5d2VkZ2UiOiLii48iLCJjdXJyZW4iOiLCpCIsImN1cnZlYXJyb3dsZWZ0Ijoi4oa2IiwiY3VydmVhcnJvd3JpZ2h0Ijoi4oa3IiwiY3V2ZWUiOiLii44iLCJjdXdlZCI6IuKLjyIsImN3Y29uaW50Ijoi4oiyIiwiY3dpbnQiOiLiiLEiLCJjeWxjdHkiOiLijK0iLCJkYWdnZXIiOiLigKAiLCJEYWdnZXIiOiLigKEiLCJkYWxldGgiOiLihLgiLCJkYXJyIjoi4oaTIiwiRGFyciI6IuKGoSIsImRBcnIiOiLih5MiLCJkYXNoIjoi4oCQIiwiRGFzaHYiOiLiq6QiLCJkYXNodiI6IuKKoyIsImRia2Fyb3ciOiLipI8iLCJkYmxhYyI6IsudIiwiRGNhcm9uIjoixI4iLCJkY2Fyb24iOiLEjyIsIkRjeSI6ItCUIiwiZGN5Ijoi0LQiLCJkZGFnZ2VyIjoi4oChIiwiZGRhcnIiOiLih4oiLCJERCI6IuKFhSIsImRkIjoi4oWGIiwiRERvdHJhaGQiOiLipJEiLCJkZG90c2VxIjoi4qm3IiwiZGVnIjoiwrAiLCJEZWwiOiLiiIciLCJEZWx0YSI6Is6UIiwiZGVsdGEiOiLOtCIsImRlbXB0eXYiOiLiprEiLCJkZmlzaHQiOiLipb8iLCJEZnIiOiLwnZSHIiwiZGZyIjoi8J2UoSIsImRIYXIiOiLipaUiLCJkaGFybCI6IuKHgyIsImRoYXJyIjoi4oeCIiwiRGlhY3JpdGljYWxBY3V0ZSI6IsK0IiwiRGlhY3JpdGljYWxEb3QiOiLLmSIsIkRpYWNyaXRpY2FsRG91YmxlQWN1dGUiOiLLnSIsIkRpYWNyaXRpY2FsR3JhdmUiOiJgIiwiRGlhY3JpdGljYWxUaWxkZSI6IsucIiwiZGlhbSI6IuKLhCIsImRpYW1vbmQiOiLii4QiLCJEaWFtb25kIjoi4ouEIiwiZGlhbW9uZHN1aXQiOiLimaYiLCJkaWFtcyI6IuKZpiIsImRpZSI6IsKoIiwiRGlmZmVyZW50aWFsRCI6IuKFhiIsImRpZ2FtbWEiOiLPnSIsImRpc2luIjoi4ouyIiwiZGl2Ijoiw7ciLCJkaXZpZGUiOiLDtyIsImRpdmlkZW9udGltZXMiOiLii4ciLCJkaXZvbngiOiLii4ciLCJESmN5Ijoi0IIiLCJkamN5Ijoi0ZIiLCJkbGNvcm4iOiLijJ4iLCJkbGNyb3AiOiLijI0iLCJkb2xsYXIiOiIkIiwiRG9wZiI6IvCdlLsiLCJkb3BmIjoi8J2VlSIsIkRvdCI6IsKoIiwiZG90Ijoiy5kiLCJEb3REb3QiOiLig5wiLCJkb3RlcSI6IuKJkCIsImRvdGVxZG90Ijoi4omRIiwiRG90RXF1YWwiOiLiiZAiLCJkb3RtaW51cyI6IuKIuCIsImRvdHBsdXMiOiLiiJQiLCJkb3RzcXVhcmUiOiLiiqEiLCJkb3VibGViYXJ3ZWRnZSI6IuKMhiIsIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbCI6IuKIryIsIkRvdWJsZURvdCI6IsKoIiwiRG91YmxlRG93bkFycm93Ijoi4oeTIiwiRG91YmxlTGVmdEFycm93Ijoi4oeQIiwiRG91YmxlTGVmdFJpZ2h0QXJyb3ciOiLih5QiLCJEb3VibGVMZWZ0VGVlIjoi4qukIiwiRG91YmxlTG9uZ0xlZnRBcnJvdyI6IuKfuCIsIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyI6IuKfuiIsIkRvdWJsZUxvbmdSaWdodEFycm93Ijoi4p+5IiwiRG91YmxlUmlnaHRBcnJvdyI6IuKHkiIsIkRvdWJsZVJpZ2h0VGVlIjoi4oqoIiwiRG91YmxlVXBBcnJvdyI6IuKHkSIsIkRvdWJsZVVwRG93bkFycm93Ijoi4oeVIiwiRG91YmxlVmVydGljYWxCYXIiOiLiiKUiLCJEb3duQXJyb3dCYXIiOiLipJMiLCJkb3duYXJyb3ciOiLihpMiLCJEb3duQXJyb3ciOiLihpMiLCJEb3duYXJyb3ciOiLih5MiLCJEb3duQXJyb3dVcEFycm93Ijoi4oe1IiwiRG93bkJyZXZlIjoizJEiLCJkb3duZG93bmFycm93cyI6IuKHiiIsImRvd25oYXJwb29ubGVmdCI6IuKHgyIsImRvd25oYXJwb29ucmlnaHQiOiLih4IiLCJEb3duTGVmdFJpZ2h0VmVjdG9yIjoi4qWQIiwiRG93bkxlZnRUZWVWZWN0b3IiOiLipZ4iLCJEb3duTGVmdFZlY3RvckJhciI6IuKlliIsIkRvd25MZWZ0VmVjdG9yIjoi4oa9IiwiRG93blJpZ2h0VGVlVmVjdG9yIjoi4qWfIiwiRG93blJpZ2h0VmVjdG9yQmFyIjoi4qWXIiwiRG93blJpZ2h0VmVjdG9yIjoi4oeBIiwiRG93blRlZUFycm93Ijoi4oanIiwiRG93blRlZSI6IuKKpCIsImRyYmthcm93Ijoi4qSQIiwiZHJjb3JuIjoi4oyfIiwiZHJjcm9wIjoi4oyMIiwiRHNjciI6IvCdkp8iLCJkc2NyIjoi8J2SuSIsIkRTY3kiOiLQhSIsImRzY3kiOiLRlSIsImRzb2wiOiLip7YiLCJEc3Ryb2siOiLEkCIsImRzdHJvayI6IsSRIiwiZHRkb3QiOiLii7EiLCJkdHJpIjoi4pa/IiwiZHRyaWYiOiLilr4iLCJkdWFyciI6IuKHtSIsImR1aGFyIjoi4qWvIiwiZHdhbmdsZSI6IuKmpiIsIkRaY3kiOiLQjyIsImR6Y3kiOiLRnyIsImR6aWdyYXJyIjoi4p+/IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsImVhc3RlciI6IuKpriIsIkVjYXJvbiI6IsSaIiwiZWNhcm9uIjoixJsiLCJFY2lyYyI6IsOKIiwiZWNpcmMiOiLDqiIsImVjaXIiOiLiiZYiLCJlY29sb24iOiLiiZUiLCJFY3kiOiLQrSIsImVjeSI6ItGNIiwiZUREb3QiOiLiqbciLCJFZG90IjoixJYiLCJlZG90IjoixJciLCJlRG90Ijoi4omRIiwiZWUiOiLihYciLCJlZkRvdCI6IuKJkiIsIkVmciI6IvCdlIgiLCJlZnIiOiLwnZSiIiwiZWciOiLiqpoiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiZWdzIjoi4qqWIiwiZWdzZG90Ijoi4qqYIiwiZWwiOiLiqpkiLCJFbGVtZW50Ijoi4oiIIiwiZWxpbnRlcnMiOiLij6ciLCJlbGwiOiLihJMiLCJlbHMiOiLiqpUiLCJlbHNkb3QiOiLiqpciLCJFbWFjciI6IsSSIiwiZW1hY3IiOiLEkyIsImVtcHR5Ijoi4oiFIiwiZW1wdHlzZXQiOiLiiIUiLCJFbXB0eVNtYWxsU3F1YXJlIjoi4pe7IiwiZW1wdHl2Ijoi4oiFIiwiRW1wdHlWZXJ5U21hbGxTcXVhcmUiOiLilqsiLCJlbXNwMTMiOiLigIQiLCJlbXNwMTQiOiLigIUiLCJlbXNwIjoi4oCDIiwiRU5HIjoixYoiLCJlbmciOiLFiyIsImVuc3AiOiLigIIiLCJFb2dvbiI6IsSYIiwiZW9nb24iOiLEmSIsIkVvcGYiOiLwnZS8IiwiZW9wZiI6IvCdlZYiLCJlcGFyIjoi4ouVIiwiZXBhcnNsIjoi4qejIiwiZXBsdXMiOiLiqbEiLCJlcHNpIjoizrUiLCJFcHNpbG9uIjoizpUiLCJlcHNpbG9uIjoizrUiLCJlcHNpdiI6Is+1IiwiZXFjaXJjIjoi4omWIiwiZXFjb2xvbiI6IuKJlSIsImVxc2ltIjoi4omCIiwiZXFzbGFudGd0ciI6IuKqliIsImVxc2xhbnRsZXNzIjoi4qqVIiwiRXF1YWwiOiLiqbUiLCJlcXVhbHMiOiI9IiwiRXF1YWxUaWxkZSI6IuKJgiIsImVxdWVzdCI6IuKJnyIsIkVxdWlsaWJyaXVtIjoi4oeMIiwiZXF1aXYiOiLiiaEiLCJlcXVpdkREIjoi4qm4IiwiZXF2cGFyc2wiOiLip6UiLCJlcmFyciI6IuKlsSIsImVyRG90Ijoi4omTIiwiZXNjciI6IuKEryIsIkVzY3IiOiLihLAiLCJlc2RvdCI6IuKJkCIsIkVzaW0iOiLiqbMiLCJlc2ltIjoi4omCIiwiRXRhIjoizpciLCJldGEiOiLOtyIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJldXJvIjoi4oKsIiwiZXhjbCI6IiEiLCJleGlzdCI6IuKIgyIsIkV4aXN0cyI6IuKIgyIsImV4cGVjdGF0aW9uIjoi4oSwIiwiZXhwb25lbnRpYWxlIjoi4oWHIiwiRXhwb25lbnRpYWxFIjoi4oWHIiwiZmFsbGluZ2RvdHNlcSI6IuKJkiIsIkZjeSI6ItCkIiwiZmN5Ijoi0YQiLCJmZW1hbGUiOiLimYAiLCJmZmlsaWciOiLvrIMiLCJmZmxpZyI6Iu+sgCIsImZmbGxpZyI6Iu+shCIsIkZmciI6IvCdlIkiLCJmZnIiOiLwnZSjIiwiZmlsaWciOiLvrIEiLCJGaWxsZWRTbWFsbFNxdWFyZSI6IuKXvCIsIkZpbGxlZFZlcnlTbWFsbFNxdWFyZSI6IuKWqiIsImZqbGlnIjoiZmoiLCJmbGF0Ijoi4pmtIiwiZmxsaWciOiLvrIIiLCJmbHRucyI6IuKWsSIsImZub2YiOiLGkiIsIkZvcGYiOiLwnZS9IiwiZm9wZiI6IvCdlZciLCJmb3JhbGwiOiLiiIAiLCJGb3JBbGwiOiLiiIAiLCJmb3JrIjoi4ouUIiwiZm9ya3YiOiLiq5kiLCJGb3VyaWVydHJmIjoi4oSxIiwiZnBhcnRpbnQiOiLiqI0iLCJmcmFjMTIiOiLCvSIsImZyYWMxMyI6IuKFkyIsImZyYWMxNCI6IsK8IiwiZnJhYzE1Ijoi4oWVIiwiZnJhYzE2Ijoi4oWZIiwiZnJhYzE4Ijoi4oWbIiwiZnJhYzIzIjoi4oWUIiwiZnJhYzI1Ijoi4oWWIiwiZnJhYzM0Ijoiwr4iLCJmcmFjMzUiOiLihZciLCJmcmFjMzgiOiLihZwiLCJmcmFjNDUiOiLihZgiLCJmcmFjNTYiOiLihZoiLCJmcmFjNTgiOiLihZ0iLCJmcmFjNzgiOiLihZ4iLCJmcmFzbCI6IuKBhCIsImZyb3duIjoi4oyiIiwiZnNjciI6IvCdkrsiLCJGc2NyIjoi4oSxIiwiZ2FjdXRlIjoix7UiLCJHYW1tYSI6Is6TIiwiZ2FtbWEiOiLOsyIsIkdhbW1hZCI6Is+cIiwiZ2FtbWFkIjoiz50iLCJnYXAiOiLiqoYiLCJHYnJldmUiOiLEniIsImdicmV2ZSI6IsSfIiwiR2NlZGlsIjoixKIiLCJHY2lyYyI6IsScIiwiZ2NpcmMiOiLEnSIsIkdjeSI6ItCTIiwiZ2N5Ijoi0LMiLCJHZG90IjoixKAiLCJnZG90IjoixKEiLCJnZSI6IuKJpSIsImdFIjoi4omnIiwiZ0VsIjoi4qqMIiwiZ2VsIjoi4oubIiwiZ2VxIjoi4omlIiwiZ2VxcSI6IuKJpyIsImdlcXNsYW50Ijoi4qm+IiwiZ2VzY2MiOiLiqqkiLCJnZXMiOiLiqb4iLCJnZXNkb3QiOiLiqoAiLCJnZXNkb3RvIjoi4qqCIiwiZ2VzZG90b2wiOiLiqoQiLCJnZXNsIjoi4oub77iAIiwiZ2VzbGVzIjoi4qqUIiwiR2ZyIjoi8J2UiiIsImdmciI6IvCdlKQiLCJnZyI6IuKJqyIsIkdnIjoi4ouZIiwiZ2dnIjoi4ouZIiwiZ2ltZWwiOiLihLciLCJHSmN5Ijoi0IMiLCJnamN5Ijoi0ZMiLCJnbGEiOiLiqqUiLCJnbCI6IuKJtyIsImdsRSI6IuKqkiIsImdsaiI6IuKqpCIsImduYXAiOiLiqooiLCJnbmFwcHJveCI6IuKqiiIsImduZSI6IuKqiCIsImduRSI6IuKJqSIsImduZXEiOiLiqogiLCJnbmVxcSI6IuKJqSIsImduc2ltIjoi4ounIiwiR29wZiI6IvCdlL4iLCJnb3BmIjoi8J2VmCIsImdyYXZlIjoiYCIsIkdyZWF0ZXJFcXVhbCI6IuKJpSIsIkdyZWF0ZXJFcXVhbExlc3MiOiLii5siLCJHcmVhdGVyRnVsbEVxdWFsIjoi4omnIiwiR3JlYXRlckdyZWF0ZXIiOiLiqqIiLCJHcmVhdGVyTGVzcyI6IuKJtyIsIkdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+IiwiR3JlYXRlclRpbGRlIjoi4omzIiwiR3NjciI6IvCdkqIiLCJnc2NyIjoi4oSKIiwiZ3NpbSI6IuKJsyIsImdzaW1lIjoi4qqOIiwiZ3NpbWwiOiLiqpAiLCJndGNjIjoi4qqnIiwiZ3RjaXIiOiLiqboiLCJndCI6Ij4iLCJHVCI6Ij4iLCJHdCI6IuKJqyIsImd0ZG90Ijoi4ouXIiwiZ3RsUGFyIjoi4qaVIiwiZ3RxdWVzdCI6IuKpvCIsImd0cmFwcHJveCI6IuKqhiIsImd0cmFyciI6IuKluCIsImd0cmRvdCI6IuKLlyIsImd0cmVxbGVzcyI6IuKLmyIsImd0cmVxcWxlc3MiOiLiqowiLCJndHJsZXNzIjoi4om3IiwiZ3Ryc2ltIjoi4omzIiwiZ3ZlcnRuZXFxIjoi4omp77iAIiwiZ3ZuRSI6IuKJqe+4gCIsIkhhY2VrIjoiy4ciLCJoYWlyc3AiOiLigIoiLCJoYWxmIjoiwr0iLCJoYW1pbHQiOiLihIsiLCJIQVJEY3kiOiLQqiIsImhhcmRjeSI6ItGKIiwiaGFycmNpciI6IuKliCIsImhhcnIiOiLihpQiLCJoQXJyIjoi4oeUIiwiaGFycnciOiLihq0iLCJIYXQiOiJeIiwiaGJhciI6IuKEjyIsIkhjaXJjIjoixKQiLCJoY2lyYyI6IsSlIiwiaGVhcnRzIjoi4pmlIiwiaGVhcnRzdWl0Ijoi4pmlIiwiaGVsbGlwIjoi4oCmIiwiaGVyY29uIjoi4oq5IiwiaGZyIjoi8J2UpSIsIkhmciI6IuKEjCIsIkhpbGJlcnRTcGFjZSI6IuKEiyIsImhrc2Vhcm93Ijoi4qSlIiwiaGtzd2Fyb3ciOiLipKYiLCJob2FyciI6IuKHvyIsImhvbXRodCI6IuKIuyIsImhvb2tsZWZ0YXJyb3ciOiLihqkiLCJob29rcmlnaHRhcnJvdyI6IuKGqiIsImhvcGYiOiLwnZWZIiwiSG9wZiI6IuKEjSIsImhvcmJhciI6IuKAlSIsIkhvcml6b250YWxMaW5lIjoi4pSAIiwiaHNjciI6IvCdkr0iLCJIc2NyIjoi4oSLIiwiaHNsYXNoIjoi4oSPIiwiSHN0cm9rIjoixKYiLCJoc3Ryb2siOiLEpyIsIkh1bXBEb3duSHVtcCI6IuKJjiIsIkh1bXBFcXVhbCI6IuKJjyIsImh5YnVsbCI6IuKBgyIsImh5cGhlbiI6IuKAkCIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJpYyI6IuKBoyIsIkljaXJjIjoiw44iLCJpY2lyYyI6IsOuIiwiSWN5Ijoi0JgiLCJpY3kiOiLQuCIsIklkb3QiOiLEsCIsIklFY3kiOiLQlSIsImllY3kiOiLQtSIsImlleGNsIjoiwqEiLCJpZmYiOiLih5QiLCJpZnIiOiLwnZSmIiwiSWZyIjoi4oSRIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlpIjoi4oWIIiwiaWlpaW50Ijoi4qiMIiwiaWlpbnQiOiLiiK0iLCJpaW5maW4iOiLip5wiLCJpaW90YSI6IuKEqSIsIklKbGlnIjoixLIiLCJpamxpZyI6IsSzIiwiSW1hY3IiOiLEqiIsImltYWNyIjoixKsiLCJpbWFnZSI6IuKEkSIsIkltYWdpbmFyeUkiOiLihYgiLCJpbWFnbGluZSI6IuKEkCIsImltYWdwYXJ0Ijoi4oSRIiwiaW1hdGgiOiLEsSIsIkltIjoi4oSRIiwiaW1vZiI6IuKKtyIsImltcGVkIjoixrUiLCJJbXBsaWVzIjoi4oeSIiwiaW5jYXJlIjoi4oSFIiwiaW4iOiLiiIgiLCJpbmZpbiI6IuKIniIsImluZmludGllIjoi4qedIiwiaW5vZG90IjoixLEiLCJpbnRjYWwiOiLiiroiLCJpbnQiOiLiiKsiLCJJbnQiOiLiiKwiLCJpbnRlZ2VycyI6IuKEpCIsIkludGVncmFsIjoi4oirIiwiaW50ZXJjYWwiOiLiiroiLCJJbnRlcnNlY3Rpb24iOiLii4IiLCJpbnRsYXJoayI6IuKolyIsImludHByb2QiOiLiqLwiLCJJbnZpc2libGVDb21tYSI6IuKBoyIsIkludmlzaWJsZVRpbWVzIjoi4oGiIiwiSU9jeSI6ItCBIiwiaW9jeSI6ItGRIiwiSW9nb24iOiLEriIsImlvZ29uIjoixK8iLCJJb3BmIjoi8J2VgCIsImlvcGYiOiLwnZWaIiwiSW90YSI6Is6ZIiwiaW90YSI6Is65IiwiaXByb2QiOiLiqLwiLCJpcXVlc3QiOiLCvyIsImlzY3IiOiLwnZK+IiwiSXNjciI6IuKEkCIsImlzaW4iOiLiiIgiLCJpc2luZG90Ijoi4ou1IiwiaXNpbkUiOiLii7kiLCJpc2lucyI6IuKLtCIsImlzaW5zdiI6IuKLsyIsImlzaW52Ijoi4oiIIiwiaXQiOiLigaIiLCJJdGlsZGUiOiLEqCIsIml0aWxkZSI6IsSpIiwiSXVrY3kiOiLQhiIsIml1a2N5Ijoi0ZYiLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJKY2lyYyI6IsS0IiwiamNpcmMiOiLEtSIsIkpjeSI6ItCZIiwiamN5Ijoi0LkiLCJKZnIiOiLwnZSNIiwiamZyIjoi8J2UpyIsImptYXRoIjoiyLciLCJKb3BmIjoi8J2VgSIsImpvcGYiOiLwnZWbIiwiSnNjciI6IvCdkqUiLCJqc2NyIjoi8J2SvyIsIkpzZXJjeSI6ItCIIiwianNlcmN5Ijoi0ZgiLCJKdWtjeSI6ItCEIiwianVrY3kiOiLRlCIsIkthcHBhIjoizpoiLCJrYXBwYSI6Is66Iiwia2FwcGF2Ijoiz7AiLCJLY2VkaWwiOiLEtiIsImtjZWRpbCI6IsS3IiwiS2N5Ijoi0JoiLCJrY3kiOiLQuiIsIktmciI6IvCdlI4iLCJrZnIiOiLwnZSoIiwia2dyZWVuIjoixLgiLCJLSGN5Ijoi0KUiLCJraGN5Ijoi0YUiLCJLSmN5Ijoi0IwiLCJramN5Ijoi0ZwiLCJLb3BmIjoi8J2VgiIsImtvcGYiOiLwnZWcIiwiS3NjciI6IvCdkqYiLCJrc2NyIjoi8J2TgCIsImxBYXJyIjoi4oeaIiwiTGFjdXRlIjoixLkiLCJsYWN1dGUiOiLEuiIsImxhZW1wdHl2Ijoi4qa0IiwibGFncmFuIjoi4oSSIiwiTGFtYmRhIjoizpsiLCJsYW1iZGEiOiLOuyIsImxhbmciOiLin6giLCJMYW5nIjoi4p+qIiwibGFuZ2QiOiLippEiLCJsYW5nbGUiOiLin6giLCJsYXAiOiLiqoUiLCJMYXBsYWNldHJmIjoi4oSSIiwibGFxdW8iOiLCqyIsImxhcnJiIjoi4oekIiwibGFycmJmcyI6IuKknyIsImxhcnIiOiLihpAiLCJMYXJyIjoi4oaeIiwibEFyciI6IuKHkCIsImxhcnJmcyI6IuKknSIsImxhcnJoayI6IuKGqSIsImxhcnJscCI6IuKGqyIsImxhcnJwbCI6IuKkuSIsImxhcnJzaW0iOiLipbMiLCJsYXJydGwiOiLihqIiLCJsYXRhaWwiOiLipJkiLCJsQXRhaWwiOiLipJsiLCJsYXQiOiLiqqsiLCJsYXRlIjoi4qqtIiwibGF0ZXMiOiLiqq3vuIAiLCJsYmFyciI6IuKkjCIsImxCYXJyIjoi4qSOIiwibGJicmsiOiLinbIiLCJsYnJhY2UiOiJ7IiwibGJyYWNrIjoiWyIsImxicmtlIjoi4qaLIiwibGJya3NsZCI6IuKmjyIsImxicmtzbHUiOiLipo0iLCJMY2Fyb24iOiLEvSIsImxjYXJvbiI6IsS+IiwiTGNlZGlsIjoixLsiLCJsY2VkaWwiOiLEvCIsImxjZWlsIjoi4oyIIiwibGN1YiI6InsiLCJMY3kiOiLQmyIsImxjeSI6ItC7IiwibGRjYSI6IuKktiIsImxkcXVvIjoi4oCcIiwibGRxdW9yIjoi4oCeIiwibGRyZGhhciI6IuKlpyIsImxkcnVzaGFyIjoi4qWLIiwibGRzaCI6IuKGsiIsImxlIjoi4omkIiwibEUiOiLiiaYiLCJMZWZ0QW5nbGVCcmFja2V0Ijoi4p+oIiwiTGVmdEFycm93QmFyIjoi4oekIiwibGVmdGFycm93Ijoi4oaQIiwiTGVmdEFycm93Ijoi4oaQIiwiTGVmdGFycm93Ijoi4oeQIiwiTGVmdEFycm93UmlnaHRBcnJvdyI6IuKHhiIsImxlZnRhcnJvd3RhaWwiOiLihqIiLCJMZWZ0Q2VpbGluZyI6IuKMiCIsIkxlZnREb3VibGVCcmFja2V0Ijoi4p+mIiwiTGVmdERvd25UZWVWZWN0b3IiOiLipaEiLCJMZWZ0RG93blZlY3RvckJhciI6IuKlmSIsIkxlZnREb3duVmVjdG9yIjoi4oeDIiwiTGVmdEZsb29yIjoi4oyKIiwibGVmdGhhcnBvb25kb3duIjoi4oa9IiwibGVmdGhhcnBvb251cCI6IuKGvCIsImxlZnRsZWZ0YXJyb3dzIjoi4oeHIiwibGVmdHJpZ2h0YXJyb3ciOiLihpQiLCJMZWZ0UmlnaHRBcnJvdyI6IuKGlCIsIkxlZnRyaWdodGFycm93Ijoi4oeUIiwibGVmdHJpZ2h0YXJyb3dzIjoi4oeGIiwibGVmdHJpZ2h0aGFycG9vbnMiOiLih4siLCJsZWZ0cmlnaHRzcXVpZ2Fycm93Ijoi4oatIiwiTGVmdFJpZ2h0VmVjdG9yIjoi4qWOIiwiTGVmdFRlZUFycm93Ijoi4oakIiwiTGVmdFRlZSI6IuKKoyIsIkxlZnRUZWVWZWN0b3IiOiLipZoiLCJsZWZ0dGhyZWV0aW1lcyI6IuKLiyIsIkxlZnRUcmlhbmdsZUJhciI6IuKnjyIsIkxlZnRUcmlhbmdsZSI6IuKKsiIsIkxlZnRUcmlhbmdsZUVxdWFsIjoi4oq0IiwiTGVmdFVwRG93blZlY3RvciI6IuKlkSIsIkxlZnRVcFRlZVZlY3RvciI6IuKloCIsIkxlZnRVcFZlY3RvckJhciI6IuKlmCIsIkxlZnRVcFZlY3RvciI6IuKGvyIsIkxlZnRWZWN0b3JCYXIiOiLipZIiLCJMZWZ0VmVjdG9yIjoi4oa8IiwibEVnIjoi4qqLIiwibGVnIjoi4ouaIiwibGVxIjoi4omkIiwibGVxcSI6IuKJpiIsImxlcXNsYW50Ijoi4qm9IiwibGVzY2MiOiLiqqgiLCJsZXMiOiLiqb0iLCJsZXNkb3QiOiLiqb8iLCJsZXNkb3RvIjoi4qqBIiwibGVzZG90b3IiOiLiqoMiLCJsZXNnIjoi4oua77iAIiwibGVzZ2VzIjoi4qqTIiwibGVzc2FwcHJveCI6IuKqhSIsImxlc3Nkb3QiOiLii5YiLCJsZXNzZXFndHIiOiLii5oiLCJsZXNzZXFxZ3RyIjoi4qqLIiwiTGVzc0VxdWFsR3JlYXRlciI6IuKLmiIsIkxlc3NGdWxsRXF1YWwiOiLiiaYiLCJMZXNzR3JlYXRlciI6IuKJtiIsImxlc3NndHIiOiLiibYiLCJMZXNzTGVzcyI6IuKqoSIsImxlc3NzaW0iOiLiibIiLCJMZXNzU2xhbnRFcXVhbCI6IuKpvSIsIkxlc3NUaWxkZSI6IuKJsiIsImxmaXNodCI6IuKlvCIsImxmbG9vciI6IuKMiiIsIkxmciI6IvCdlI8iLCJsZnIiOiLwnZSpIiwibGciOiLiibYiLCJsZ0UiOiLiqpEiLCJsSGFyIjoi4qWiIiwibGhhcmQiOiLihr0iLCJsaGFydSI6IuKGvCIsImxoYXJ1bCI6IuKlqiIsImxoYmxrIjoi4paEIiwiTEpjeSI6ItCJIiwibGpjeSI6ItGZIiwibGxhcnIiOiLih4ciLCJsbCI6IuKJqiIsIkxsIjoi4ouYIiwibGxjb3JuZXIiOiLijJ4iLCJMbGVmdGFycm93Ijoi4oeaIiwibGxoYXJkIjoi4qWrIiwibGx0cmkiOiLil7oiLCJMbWlkb3QiOiLEvyIsImxtaWRvdCI6IsWAIiwibG1vdXN0YWNoZSI6IuKOsCIsImxtb3VzdCI6IuKOsCIsImxuYXAiOiLiqokiLCJsbmFwcHJveCI6IuKqiSIsImxuZSI6IuKqhyIsImxuRSI6IuKJqCIsImxuZXEiOiLiqociLCJsbmVxcSI6IuKJqCIsImxuc2ltIjoi4oumIiwibG9hbmciOiLin6wiLCJsb2FyciI6IuKHvSIsImxvYnJrIjoi4p+mIiwibG9uZ2xlZnRhcnJvdyI6IuKftSIsIkxvbmdMZWZ0QXJyb3ciOiLin7UiLCJMb25nbGVmdGFycm93Ijoi4p+4IiwibG9uZ2xlZnRyaWdodGFycm93Ijoi4p+3IiwiTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+3IiwiTG9uZ2xlZnRyaWdodGFycm93Ijoi4p+6IiwibG9uZ21hcHN0byI6IuKfvCIsImxvbmdyaWdodGFycm93Ijoi4p+2IiwiTG9uZ1JpZ2h0QXJyb3ciOiLin7YiLCJMb25ncmlnaHRhcnJvdyI6IuKfuSIsImxvb3BhcnJvd2xlZnQiOiLihqsiLCJsb29wYXJyb3dyaWdodCI6IuKGrCIsImxvcGFyIjoi4qaFIiwiTG9wZiI6IvCdlYMiLCJsb3BmIjoi8J2VnSIsImxvcGx1cyI6IuKorSIsImxvdGltZXMiOiLiqLQiLCJsb3dhc3QiOiLiiJciLCJsb3diYXIiOiJfIiwiTG93ZXJMZWZ0QXJyb3ciOiLihpkiLCJMb3dlclJpZ2h0QXJyb3ciOiLihpgiLCJsb3oiOiLil4oiLCJsb3plbmdlIjoi4peKIiwibG96ZiI6IuKnqyIsImxwYXIiOiIoIiwibHBhcmx0Ijoi4qaTIiwibHJhcnIiOiLih4YiLCJscmNvcm5lciI6IuKMnyIsImxyaGFyIjoi4oeLIiwibHJoYXJkIjoi4qWtIiwibHJtIjoi4oCOIiwibHJ0cmkiOiLiir8iLCJsc2FxdW8iOiLigLkiLCJsc2NyIjoi8J2TgSIsIkxzY3IiOiLihJIiLCJsc2giOiLihrAiLCJMc2giOiLihrAiLCJsc2ltIjoi4omyIiwibHNpbWUiOiLiqo0iLCJsc2ltZyI6IuKqjyIsImxzcWIiOiJbIiwibHNxdW8iOiLigJgiLCJsc3F1b3IiOiLigJoiLCJMc3Ryb2siOiLFgSIsImxzdHJvayI6IsWCIiwibHRjYyI6IuKqpiIsImx0Y2lyIjoi4qm5IiwibHQiOiI8IiwiTFQiOiI8IiwiTHQiOiLiiaoiLCJsdGRvdCI6IuKLliIsImx0aHJlZSI6IuKLiyIsImx0aW1lcyI6IuKLiSIsImx0bGFyciI6IuKltiIsImx0cXVlc3QiOiLiqbsiLCJsdHJpIjoi4peDIiwibHRyaWUiOiLiirQiLCJsdHJpZiI6IuKXgiIsImx0clBhciI6IuKmliIsImx1cmRzaGFyIjoi4qWKIiwibHVydWhhciI6IuKlpiIsImx2ZXJ0bmVxcSI6IuKJqO+4gCIsImx2bkUiOiLiiajvuIAiLCJtYWNyIjoiwq8iLCJtYWxlIjoi4pmCIiwibWFsdCI6IuKcoCIsIm1hbHRlc2UiOiLinKAiLCJNYXAiOiLipIUiLCJtYXAiOiLihqYiLCJtYXBzdG8iOiLihqYiLCJtYXBzdG9kb3duIjoi4oanIiwibWFwc3RvbGVmdCI6IuKGpCIsIm1hcHN0b3VwIjoi4oalIiwibWFya2VyIjoi4pauIiwibWNvbW1hIjoi4qipIiwiTWN5Ijoi0JwiLCJtY3kiOiLQvCIsIm1kYXNoIjoi4oCUIiwibUREb3QiOiLiiLoiLCJtZWFzdXJlZGFuZ2xlIjoi4oihIiwiTWVkaXVtU3BhY2UiOiLigZ8iLCJNZWxsaW50cmYiOiLihLMiLCJNZnIiOiLwnZSQIiwibWZyIjoi8J2UqiIsIm1obyI6IuKEpyIsIm1pY3JvIjoiwrUiLCJtaWRhc3QiOiIqIiwibWlkY2lyIjoi4quwIiwibWlkIjoi4oijIiwibWlkZG90IjoiwrciLCJtaW51c2IiOiLiip8iLCJtaW51cyI6IuKIkiIsIm1pbnVzZCI6IuKIuCIsIm1pbnVzZHUiOiLiqKoiLCJNaW51c1BsdXMiOiLiiJMiLCJtbGNwIjoi4qubIiwibWxkciI6IuKApiIsIm1ucGx1cyI6IuKIkyIsIm1vZGVscyI6IuKKpyIsIk1vcGYiOiLwnZWEIiwibW9wZiI6IvCdlZ4iLCJtcCI6IuKIkyIsIm1zY3IiOiLwnZOCIiwiTXNjciI6IuKEsyIsIm1zdHBvcyI6IuKIviIsIk11IjoizpwiLCJtdSI6Is68IiwibXVsdGltYXAiOiLiirgiLCJtdW1hcCI6IuKKuCIsIm5hYmxhIjoi4oiHIiwiTmFjdXRlIjoixYMiLCJuYWN1dGUiOiLFhCIsIm5hbmciOiLiiKDig5IiLCJuYXAiOiLiiYkiLCJuYXBFIjoi4qmwzLgiLCJuYXBpZCI6IuKJi8y4IiwibmFwb3MiOiLFiSIsIm5hcHByb3giOiLiiYkiLCJuYXR1cmFsIjoi4pmuIiwibmF0dXJhbHMiOiLihJUiLCJuYXR1ciI6IuKZriIsIm5ic3AiOiLCoCIsIm5idW1wIjoi4omOzLgiLCJuYnVtcGUiOiLiiY/MuCIsIm5jYXAiOiLiqYMiLCJOY2Fyb24iOiLFhyIsIm5jYXJvbiI6IsWIIiwiTmNlZGlsIjoixYUiLCJuY2VkaWwiOiLFhiIsIm5jb25nIjoi4omHIiwibmNvbmdkb3QiOiLiqa3MuCIsIm5jdXAiOiLiqYIiLCJOY3kiOiLQnSIsIm5jeSI6ItC9IiwibmRhc2giOiLigJMiLCJuZWFyaGsiOiLipKQiLCJuZWFyciI6IuKGlyIsIm5lQXJyIjoi4oeXIiwibmVhcnJvdyI6IuKGlyIsIm5lIjoi4omgIiwibmVkb3QiOiLiiZDMuCIsIk5lZ2F0aXZlTWVkaXVtU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaWNrU3BhY2UiOiLigIsiLCJOZWdhdGl2ZVRoaW5TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZSI6IuKAiyIsIm5lcXVpdiI6IuKJoiIsIm5lc2VhciI6IuKkqCIsIm5lc2ltIjoi4omCzLgiLCJOZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKJqyIsIk5lc3RlZExlc3NMZXNzIjoi4omqIiwiTmV3TGluZSI6IlxcbiIsIm5leGlzdCI6IuKIhCIsIm5leGlzdHMiOiLiiIQiLCJOZnIiOiLwnZSRIiwibmZyIjoi8J2UqyIsIm5nRSI6IuKJp8y4IiwibmdlIjoi4omxIiwibmdlcSI6IuKJsSIsIm5nZXFxIjoi4omnzLgiLCJuZ2Vxc2xhbnQiOiLiqb7MuCIsIm5nZXMiOiLiqb7MuCIsIm5HZyI6IuKLmcy4IiwibmdzaW0iOiLiibUiLCJuR3QiOiLiiavig5IiLCJuZ3QiOiLiia8iLCJuZ3RyIjoi4omvIiwibkd0diI6IuKJq8y4IiwibmhhcnIiOiLihq4iLCJuaEFyciI6IuKHjiIsIm5ocGFyIjoi4quyIiwibmkiOiLiiIsiLCJuaXMiOiLii7wiLCJuaXNkIjoi4ou6Iiwibml2Ijoi4oiLIiwiTkpjeSI6ItCKIiwibmpjeSI6ItGaIiwibmxhcnIiOiLihpoiLCJubEFyciI6IuKHjSIsIm5sZHIiOiLigKUiLCJubEUiOiLiiabMuCIsIm5sZSI6IuKJsCIsIm5sZWZ0YXJyb3ciOiLihpoiLCJuTGVmdGFycm93Ijoi4oeNIiwibmxlZnRyaWdodGFycm93Ijoi4oauIiwibkxlZnRyaWdodGFycm93Ijoi4oeOIiwibmxlcSI6IuKJsCIsIm5sZXFxIjoi4ommzLgiLCJubGVxc2xhbnQiOiLiqb3MuCIsIm5sZXMiOiLiqb3MuCIsIm5sZXNzIjoi4omuIiwibkxsIjoi4ouYzLgiLCJubHNpbSI6IuKJtCIsIm5MdCI6IuKJquKDkiIsIm5sdCI6IuKJriIsIm5sdHJpIjoi4ouqIiwibmx0cmllIjoi4ousIiwibkx0diI6IuKJqsy4Iiwibm1pZCI6IuKIpCIsIk5vQnJlYWsiOiLigaAiLCJOb25CcmVha2luZ1NwYWNlIjoiwqAiLCJub3BmIjoi8J2VnyIsIk5vcGYiOiLihJUiLCJOb3QiOiLiq6wiLCJub3QiOiLCrCIsIk5vdENvbmdydWVudCI6IuKJoiIsIk5vdEN1cENhcCI6IuKJrSIsIk5vdERvdWJsZVZlcnRpY2FsQmFyIjoi4oimIiwiTm90RWxlbWVudCI6IuKIiSIsIk5vdEVxdWFsIjoi4omgIiwiTm90RXF1YWxUaWxkZSI6IuKJgsy4IiwiTm90RXhpc3RzIjoi4oiEIiwiTm90R3JlYXRlciI6IuKJryIsIk5vdEdyZWF0ZXJFcXVhbCI6IuKJsSIsIk5vdEdyZWF0ZXJGdWxsRXF1YWwiOiLiiafMuCIsIk5vdEdyZWF0ZXJHcmVhdGVyIjoi4omrzLgiLCJOb3RHcmVhdGVyTGVzcyI6IuKJuSIsIk5vdEdyZWF0ZXJTbGFudEVxdWFsIjoi4qm+zLgiLCJOb3RHcmVhdGVyVGlsZGUiOiLiibUiLCJOb3RIdW1wRG93bkh1bXAiOiLiiY7MuCIsIk5vdEh1bXBFcXVhbCI6IuKJj8y4Iiwibm90aW4iOiLiiIkiLCJub3RpbmRvdCI6IuKLtcy4Iiwibm90aW5FIjoi4ou5zLgiLCJub3RpbnZhIjoi4oiJIiwibm90aW52YiI6IuKLtyIsIm5vdGludmMiOiLii7YiLCJOb3RMZWZ0VHJpYW5nbGVCYXIiOiLip4/MuCIsIk5vdExlZnRUcmlhbmdsZSI6IuKLqiIsIk5vdExlZnRUcmlhbmdsZUVxdWFsIjoi4ousIiwiTm90TGVzcyI6IuKJriIsIk5vdExlc3NFcXVhbCI6IuKJsCIsIk5vdExlc3NHcmVhdGVyIjoi4om4IiwiTm90TGVzc0xlc3MiOiLiiarMuCIsIk5vdExlc3NTbGFudEVxdWFsIjoi4qm9zLgiLCJOb3RMZXNzVGlsZGUiOiLiibQiLCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlciI6IuKqosy4IiwiTm90TmVzdGVkTGVzc0xlc3MiOiLiqqHMuCIsIm5vdG5pIjoi4oiMIiwibm90bml2YSI6IuKIjCIsIm5vdG5pdmIiOiLii74iLCJub3RuaXZjIjoi4ou9IiwiTm90UHJlY2VkZXMiOiLiioAiLCJOb3RQcmVjZWRlc0VxdWFsIjoi4qqvzLgiLCJOb3RQcmVjZWRlc1NsYW50RXF1YWwiOiLii6AiLCJOb3RSZXZlcnNlRWxlbWVudCI6IuKIjCIsIk5vdFJpZ2h0VHJpYW5nbGVCYXIiOiLip5DMuCIsIk5vdFJpZ2h0VHJpYW5nbGUiOiLii6siLCJOb3RSaWdodFRyaWFuZ2xlRXF1YWwiOiLii60iLCJOb3RTcXVhcmVTdWJzZXQiOiLiio/MuCIsIk5vdFNxdWFyZVN1YnNldEVxdWFsIjoi4ouiIiwiTm90U3F1YXJlU3VwZXJzZXQiOiLiipDMuCIsIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWwiOiLii6MiLCJOb3RTdWJzZXQiOiLiioLig5IiLCJOb3RTdWJzZXRFcXVhbCI6IuKKiCIsIk5vdFN1Y2NlZWRzIjoi4oqBIiwiTm90U3VjY2VlZHNFcXVhbCI6IuKqsMy4IiwiTm90U3VjY2VlZHNTbGFudEVxdWFsIjoi4ouhIiwiTm90U3VjY2VlZHNUaWxkZSI6IuKJv8y4IiwiTm90U3VwZXJzZXQiOiLiioPig5IiLCJOb3RTdXBlcnNldEVxdWFsIjoi4oqJIiwiTm90VGlsZGUiOiLiiYEiLCJOb3RUaWxkZUVxdWFsIjoi4omEIiwiTm90VGlsZGVGdWxsRXF1YWwiOiLiiYciLCJOb3RUaWxkZVRpbGRlIjoi4omJIiwiTm90VmVydGljYWxCYXIiOiLiiKQiLCJucGFyYWxsZWwiOiLiiKYiLCJucGFyIjoi4oimIiwibnBhcnNsIjoi4qu94oOlIiwibnBhcnQiOiLiiILMuCIsIm5wb2xpbnQiOiLiqJQiLCJucHIiOiLiioAiLCJucHJjdWUiOiLii6AiLCJucHJlYyI6IuKKgCIsIm5wcmVjZXEiOiLiqq/MuCIsIm5wcmUiOiLiqq/MuCIsIm5yYXJyYyI6IuKks8y4IiwibnJhcnIiOiLihpsiLCJuckFyciI6IuKHjyIsIm5yYXJydyI6IuKGncy4IiwibnJpZ2h0YXJyb3ciOiLihpsiLCJuUmlnaHRhcnJvdyI6IuKHjyIsIm5ydHJpIjoi4ourIiwibnJ0cmllIjoi4outIiwibnNjIjoi4oqBIiwibnNjY3VlIjoi4ouhIiwibnNjZSI6IuKqsMy4IiwiTnNjciI6IvCdkqkiLCJuc2NyIjoi8J2TgyIsIm5zaG9ydG1pZCI6IuKIpCIsIm5zaG9ydHBhcmFsbGVsIjoi4oimIiwibnNpbSI6IuKJgSIsIm5zaW1lIjoi4omEIiwibnNpbWVxIjoi4omEIiwibnNtaWQiOiLiiKQiLCJuc3BhciI6IuKIpiIsIm5zcXN1YmUiOiLii6IiLCJuc3FzdXBlIjoi4oujIiwibnN1YiI6IuKKhCIsIm5zdWJFIjoi4quFzLgiLCJuc3ViZSI6IuKKiCIsIm5zdWJzZXQiOiLiioLig5IiLCJuc3Vic2V0ZXEiOiLiiogiLCJuc3Vic2V0ZXFxIjoi4quFzLgiLCJuc3VjYyI6IuKKgSIsIm5zdWNjZXEiOiLiqrDMuCIsIm5zdXAiOiLiioUiLCJuc3VwRSI6IuKrhsy4IiwibnN1cGUiOiLiiokiLCJuc3Vwc2V0Ijoi4oqD4oOSIiwibnN1cHNldGVxIjoi4oqJIiwibnN1cHNldGVxcSI6IuKrhsy4IiwibnRnbCI6IuKJuSIsIk50aWxkZSI6IsORIiwibnRpbGRlIjoiw7EiLCJudGxnIjoi4om4IiwibnRyaWFuZ2xlbGVmdCI6IuKLqiIsIm50cmlhbmdsZWxlZnRlcSI6IuKLrCIsIm50cmlhbmdsZXJpZ2h0Ijoi4ourIiwibnRyaWFuZ2xlcmlnaHRlcSI6IuKLrSIsIk51Ijoizp0iLCJudSI6Is69IiwibnVtIjoiIyIsIm51bWVybyI6IuKEliIsIm51bXNwIjoi4oCHIiwibnZhcCI6IuKJjeKDkiIsIm52ZGFzaCI6IuKKrCIsIm52RGFzaCI6IuKKrSIsIm5WZGFzaCI6IuKKriIsIm5WRGFzaCI6IuKKryIsIm52Z2UiOiLiiaXig5IiLCJudmd0IjoiPuKDkiIsIm52SGFyciI6IuKkhCIsIm52aW5maW4iOiLip54iLCJudmxBcnIiOiLipIIiLCJudmxlIjoi4omk4oOSIiwibnZsdCI6Ijzig5IiLCJudmx0cmllIjoi4oq04oOSIiwibnZyQXJyIjoi4qSDIiwibnZydHJpZSI6IuKKteKDkiIsIm52c2ltIjoi4oi84oOSIiwibndhcmhrIjoi4qSjIiwibndhcnIiOiLihpYiLCJud0FyciI6IuKHliIsIm53YXJyb3ciOiLihpYiLCJud25lYXIiOiLipKciLCJPYWN1dGUiOiLDkyIsIm9hY3V0ZSI6IsOzIiwib2FzdCI6IuKKmyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0Iiwib2NpciI6IuKKmiIsIk9jeSI6ItCeIiwib2N5Ijoi0L4iLCJvZGFzaCI6IuKKnSIsIk9kYmxhYyI6IsWQIiwib2RibGFjIjoixZEiLCJvZGl2Ijoi4qi4Iiwib2RvdCI6IuKKmSIsIm9kc29sZCI6IuKmvCIsIk9FbGlnIjoixZIiLCJvZWxpZyI6IsWTIiwib2ZjaXIiOiLipr8iLCJPZnIiOiLwnZSSIiwib2ZyIjoi8J2UrCIsIm9nb24iOiLLmyIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvZ3QiOiLip4EiLCJvaGJhciI6IuKmtSIsIm9obSI6Is6pIiwib2ludCI6IuKIriIsIm9sYXJyIjoi4oa6Iiwib2xjaXIiOiLipr4iLCJvbGNyb3NzIjoi4qa7Iiwib2xpbmUiOiLigL4iLCJvbHQiOiLip4AiLCJPbWFjciI6IsWMIiwib21hY3IiOiLFjSIsIk9tZWdhIjoizqkiLCJvbWVnYSI6Is+JIiwiT21pY3JvbiI6Is6fIiwib21pY3JvbiI6Is6/Iiwib21pZCI6IuKmtiIsIm9taW51cyI6IuKKliIsIk9vcGYiOiLwnZWGIiwib29wZiI6IvCdlaAiLCJvcGFyIjoi4qa3IiwiT3BlbkN1cmx5RG91YmxlUXVvdGUiOiLigJwiLCJPcGVuQ3VybHlRdW90ZSI6IuKAmCIsIm9wZXJwIjoi4qa5Iiwib3BsdXMiOiLiipUiLCJvcmFyciI6IuKGuyIsIk9yIjoi4qmUIiwib3IiOiLiiKgiLCJvcmQiOiLiqZ0iLCJvcmRlciI6IuKEtCIsIm9yZGVyb2YiOiLihLQiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJvcmlnb2YiOiLiirYiLCJvcm9yIjoi4qmWIiwib3JzbG9wZSI6IuKplyIsIm9ydiI6IuKpmyIsIm9TIjoi4pOIIiwiT3NjciI6IvCdkqoiLCJvc2NyIjoi4oS0IiwiT3NsYXNoIjoiw5giLCJvc2xhc2giOiLDuCIsIm9zb2wiOiLiipgiLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1Iiwib3RpbWVzYXMiOiLiqLYiLCJPdGltZXMiOiLiqLciLCJvdGltZXMiOiLiipciLCJPdW1sIjoiw5YiLCJvdW1sIjoiw7YiLCJvdmJhciI6IuKMvSIsIk92ZXJCYXIiOiLigL4iLCJPdmVyQnJhY2UiOiLij54iLCJPdmVyQnJhY2tldCI6IuKOtCIsIk92ZXJQYXJlbnRoZXNpcyI6IuKPnCIsInBhcmEiOiLCtiIsInBhcmFsbGVsIjoi4oilIiwicGFyIjoi4oilIiwicGFyc2ltIjoi4quzIiwicGFyc2wiOiLiq70iLCJwYXJ0Ijoi4oiCIiwiUGFydGlhbEQiOiLiiIIiLCJQY3kiOiLQnyIsInBjeSI6ItC/IiwicGVyY250IjoiJSIsInBlcmlvZCI6Ii4iLCJwZXJtaWwiOiLigLAiLCJwZXJwIjoi4oqlIiwicGVydGVuayI6IuKAsSIsIlBmciI6IvCdlJMiLCJwZnIiOiLwnZStIiwiUGhpIjoizqYiLCJwaGkiOiLPhiIsInBoaXYiOiLPlSIsInBobW1hdCI6IuKEsyIsInBob25lIjoi4piOIiwiUGkiOiLOoCIsInBpIjoiz4AiLCJwaXRjaGZvcmsiOiLii5QiLCJwaXYiOiLPliIsInBsYW5jayI6IuKEjyIsInBsYW5ja2giOiLihI4iLCJwbGFua3YiOiLihI8iLCJwbHVzYWNpciI6IuKooyIsInBsdXNiIjoi4oqeIiwicGx1c2NpciI6IuKooiIsInBsdXMiOiIrIiwicGx1c2RvIjoi4oiUIiwicGx1c2R1Ijoi4qilIiwicGx1c2UiOiLiqbIiLCJQbHVzTWludXMiOiLCsSIsInBsdXNtbiI6IsKxIiwicGx1c3NpbSI6IuKopiIsInBsdXN0d28iOiLiqKciLCJwbSI6IsKxIiwiUG9pbmNhcmVwbGFuZSI6IuKEjCIsInBvaW50aW50Ijoi4qiVIiwicG9wZiI6IvCdlaEiLCJQb3BmIjoi4oSZIiwicG91bmQiOiLCoyIsInByYXAiOiLiqrciLCJQciI6IuKquyIsInByIjoi4om6IiwicHJjdWUiOiLiibwiLCJwcmVjYXBwcm94Ijoi4qq3IiwicHJlYyI6IuKJuiIsInByZWNjdXJseWVxIjoi4om8IiwiUHJlY2VkZXMiOiLiiboiLCJQcmVjZWRlc0VxdWFsIjoi4qqvIiwiUHJlY2VkZXNTbGFudEVxdWFsIjoi4om8IiwiUHJlY2VkZXNUaWxkZSI6IuKJviIsInByZWNlcSI6IuKqryIsInByZWNuYXBwcm94Ijoi4qq5IiwicHJlY25lcXEiOiLiqrUiLCJwcmVjbnNpbSI6IuKLqCIsInByZSI6IuKqryIsInByRSI6IuKqsyIsInByZWNzaW0iOiLiib4iLCJwcmltZSI6IuKAsiIsIlByaW1lIjoi4oCzIiwicHJpbWVzIjoi4oSZIiwicHJuYXAiOiLiqrkiLCJwcm5FIjoi4qq1IiwicHJuc2ltIjoi4ouoIiwicHJvZCI6IuKIjyIsIlByb2R1Y3QiOiLiiI8iLCJwcm9mYWxhciI6IuKMriIsInByb2ZsaW5lIjoi4oySIiwicHJvZnN1cmYiOiLijJMiLCJwcm9wIjoi4oidIiwiUHJvcG9ydGlvbmFsIjoi4oidIiwiUHJvcG9ydGlvbiI6IuKItyIsInByb3B0byI6IuKInSIsInByc2ltIjoi4om+IiwicHJ1cmVsIjoi4oqwIiwiUHNjciI6IvCdkqsiLCJwc2NyIjoi8J2ThSIsIlBzaSI6Is6oIiwicHNpIjoiz4giLCJwdW5jc3AiOiLigIgiLCJRZnIiOiLwnZSUIiwicWZyIjoi8J2UriIsInFpbnQiOiLiqIwiLCJxb3BmIjoi8J2VoiIsIlFvcGYiOiLihJoiLCJxcHJpbWUiOiLigZciLCJRc2NyIjoi8J2SrCIsInFzY3IiOiLwnZOGIiwicXVhdGVybmlvbnMiOiLihI0iLCJxdWF0aW50Ijoi4qiWIiwicXVlc3QiOiI/IiwicXVlc3RlcSI6IuKJnyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwickFhcnIiOiLih5siLCJyYWNlIjoi4oi9zLEiLCJSYWN1dGUiOiLFlCIsInJhY3V0ZSI6IsWVIiwicmFkaWMiOiLiiJoiLCJyYWVtcHR5diI6IuKmsyIsInJhbmciOiLin6kiLCJSYW5nIjoi4p+rIiwicmFuZ2QiOiLippIiLCJyYW5nZSI6IuKmpSIsInJhbmdsZSI6IuKfqSIsInJhcXVvIjoiwrsiLCJyYXJyYXAiOiLipbUiLCJyYXJyYiI6IuKHpSIsInJhcnJiZnMiOiLipKAiLCJyYXJyYyI6IuKksyIsInJhcnIiOiLihpIiLCJSYXJyIjoi4oagIiwickFyciI6IuKHkiIsInJhcnJmcyI6IuKkniIsInJhcnJoayI6IuKGqiIsInJhcnJscCI6IuKGrCIsInJhcnJwbCI6IuKlhSIsInJhcnJzaW0iOiLipbQiLCJSYXJydGwiOiLipJYiLCJyYXJydGwiOiLihqMiLCJyYXJydyI6IuKGnSIsInJhdGFpbCI6IuKkmiIsInJBdGFpbCI6IuKknCIsInJhdGlvIjoi4oi2IiwicmF0aW9uYWxzIjoi4oSaIiwicmJhcnIiOiLipI0iLCJyQmFyciI6IuKkjyIsIlJCYXJyIjoi4qSQIiwicmJicmsiOiLinbMiLCJyYnJhY2UiOiJ9IiwicmJyYWNrIjoiXSIsInJicmtlIjoi4qaMIiwicmJya3NsZCI6IuKmjiIsInJicmtzbHUiOiLippAiLCJSY2Fyb24iOiLFmCIsInJjYXJvbiI6IsWZIiwiUmNlZGlsIjoixZYiLCJyY2VkaWwiOiLFlyIsInJjZWlsIjoi4oyJIiwicmN1YiI6In0iLCJSY3kiOiLQoCIsInJjeSI6ItGAIiwicmRjYSI6IuKktyIsInJkbGRoYXIiOiLipakiLCJyZHF1byI6IuKAnSIsInJkcXVvciI6IuKAnSIsInJkc2giOiLihrMiLCJyZWFsIjoi4oScIiwicmVhbGluZSI6IuKEmyIsInJlYWxwYXJ0Ijoi4oScIiwicmVhbHMiOiLihJ0iLCJSZSI6IuKEnCIsInJlY3QiOiLilq0iLCJyZWciOiLCriIsIlJFRyI6IsKuIiwiUmV2ZXJzZUVsZW1lbnQiOiLiiIsiLCJSZXZlcnNlRXF1aWxpYnJpdW0iOiLih4siLCJSZXZlcnNlVXBFcXVpbGlicml1bSI6IuKlryIsInJmaXNodCI6IuKlvSIsInJmbG9vciI6IuKMiyIsInJmciI6IvCdlK8iLCJSZnIiOiLihJwiLCJySGFyIjoi4qWkIiwicmhhcmQiOiLih4EiLCJyaGFydSI6IuKHgCIsInJoYXJ1bCI6IuKlrCIsIlJobyI6Is6hIiwicmhvIjoiz4EiLCJyaG92Ijoiz7EiLCJSaWdodEFuZ2xlQnJhY2tldCI6IuKfqSIsIlJpZ2h0QXJyb3dCYXIiOiLih6UiLCJyaWdodGFycm93Ijoi4oaSIiwiUmlnaHRBcnJvdyI6IuKGkiIsIlJpZ2h0YXJyb3ciOiLih5IiLCJSaWdodEFycm93TGVmdEFycm93Ijoi4oeEIiwicmlnaHRhcnJvd3RhaWwiOiLihqMiLCJSaWdodENlaWxpbmciOiLijIkiLCJSaWdodERvdWJsZUJyYWNrZXQiOiLin6ciLCJSaWdodERvd25UZWVWZWN0b3IiOiLipZ0iLCJSaWdodERvd25WZWN0b3JCYXIiOiLipZUiLCJSaWdodERvd25WZWN0b3IiOiLih4IiLCJSaWdodEZsb29yIjoi4oyLIiwicmlnaHRoYXJwb29uZG93biI6IuKHgSIsInJpZ2h0aGFycG9vbnVwIjoi4oeAIiwicmlnaHRsZWZ0YXJyb3dzIjoi4oeEIiwicmlnaHRsZWZ0aGFycG9vbnMiOiLih4wiLCJyaWdodHJpZ2h0YXJyb3dzIjoi4oeJIiwicmlnaHRzcXVpZ2Fycm93Ijoi4oadIiwiUmlnaHRUZWVBcnJvdyI6IuKGpiIsIlJpZ2h0VGVlIjoi4oqiIiwiUmlnaHRUZWVWZWN0b3IiOiLipZsiLCJyaWdodHRocmVldGltZXMiOiLii4wiLCJSaWdodFRyaWFuZ2xlQmFyIjoi4qeQIiwiUmlnaHRUcmlhbmdsZSI6IuKKsyIsIlJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKKtSIsIlJpZ2h0VXBEb3duVmVjdG9yIjoi4qWPIiwiUmlnaHRVcFRlZVZlY3RvciI6IuKlnCIsIlJpZ2h0VXBWZWN0b3JCYXIiOiLipZQiLCJSaWdodFVwVmVjdG9yIjoi4oa+IiwiUmlnaHRWZWN0b3JCYXIiOiLipZMiLCJSaWdodFZlY3RvciI6IuKHgCIsInJpbmciOiLLmiIsInJpc2luZ2RvdHNlcSI6IuKJkyIsInJsYXJyIjoi4oeEIiwicmxoYXIiOiLih4wiLCJybG0iOiLigI8iLCJybW91c3RhY2hlIjoi4o6xIiwicm1vdXN0Ijoi4o6xIiwicm5taWQiOiLiq64iLCJyb2FuZyI6IuKfrSIsInJvYXJyIjoi4oe+Iiwicm9icmsiOiLin6ciLCJyb3BhciI6IuKmhiIsInJvcGYiOiLwnZWjIiwiUm9wZiI6IuKEnSIsInJvcGx1cyI6IuKoriIsInJvdGltZXMiOiLiqLUiLCJSb3VuZEltcGxpZXMiOiLipbAiLCJycGFyIjoiKSIsInJwYXJndCI6IuKmlCIsInJwcG9saW50Ijoi4qiSIiwicnJhcnIiOiLih4kiLCJScmlnaHRhcnJvdyI6IuKHmyIsInJzYXF1byI6IuKAuiIsInJzY3IiOiLwnZOHIiwiUnNjciI6IuKEmyIsInJzaCI6IuKGsSIsIlJzaCI6IuKGsSIsInJzcWIiOiJdIiwicnNxdW8iOiLigJkiLCJyc3F1b3IiOiLigJkiLCJydGhyZWUiOiLii4wiLCJydGltZXMiOiLii4oiLCJydHJpIjoi4pa5IiwicnRyaWUiOiLiirUiLCJydHJpZiI6IuKWuCIsInJ0cmlsdHJpIjoi4qeOIiwiUnVsZURlbGF5ZWQiOiLip7QiLCJydWx1aGFyIjoi4qWoIiwicngiOiLihJ4iLCJTYWN1dGUiOiLFmiIsInNhY3V0ZSI6IsWbIiwic2JxdW8iOiLigJoiLCJzY2FwIjoi4qq4IiwiU2Nhcm9uIjoixaAiLCJzY2Fyb24iOiLFoSIsIlNjIjoi4qq8Iiwic2MiOiLiibsiLCJzY2N1ZSI6IuKJvSIsInNjZSI6IuKqsCIsInNjRSI6IuKqtCIsIlNjZWRpbCI6IsWeIiwic2NlZGlsIjoixZ8iLCJTY2lyYyI6IsWcIiwic2NpcmMiOiLFnSIsInNjbmFwIjoi4qq6Iiwic2NuRSI6IuKqtiIsInNjbnNpbSI6IuKLqSIsInNjcG9saW50Ijoi4qiTIiwic2NzaW0iOiLiib8iLCJTY3kiOiLQoSIsInNjeSI6ItGBIiwic2RvdGIiOiLiiqEiLCJzZG90Ijoi4ouFIiwic2RvdGUiOiLiqaYiLCJzZWFyaGsiOiLipKUiLCJzZWFyciI6IuKGmCIsInNlQXJyIjoi4oeYIiwic2VhcnJvdyI6IuKGmCIsInNlY3QiOiLCpyIsInNlbWkiOiI7Iiwic2Vzd2FyIjoi4qSpIiwic2V0bWludXMiOiLiiJYiLCJzZXRtbiI6IuKIliIsInNleHQiOiLinLYiLCJTZnIiOiLwnZSWIiwic2ZyIjoi8J2UsCIsInNmcm93biI6IuKMoiIsInNoYXJwIjoi4pmvIiwiU0hDSGN5Ijoi0KkiLCJzaGNoY3kiOiLRiSIsIlNIY3kiOiLQqCIsInNoY3kiOiLRiCIsIlNob3J0RG93bkFycm93Ijoi4oaTIiwiU2hvcnRMZWZ0QXJyb3ciOiLihpAiLCJzaG9ydG1pZCI6IuKIoyIsInNob3J0cGFyYWxsZWwiOiLiiKUiLCJTaG9ydFJpZ2h0QXJyb3ciOiLihpIiLCJTaG9ydFVwQXJyb3ciOiLihpEiLCJzaHkiOiLCrSIsIlNpZ21hIjoizqMiLCJzaWdtYSI6Is+DIiwic2lnbWFmIjoiz4IiLCJzaWdtYXYiOiLPgiIsInNpbSI6IuKIvCIsInNpbWRvdCI6IuKpqiIsInNpbWUiOiLiiYMiLCJzaW1lcSI6IuKJgyIsInNpbWciOiLiqp4iLCJzaW1nRSI6IuKqoCIsInNpbWwiOiLiqp0iLCJzaW1sRSI6IuKqnyIsInNpbW5lIjoi4omGIiwic2ltcGx1cyI6IuKopCIsInNpbXJhcnIiOiLipbIiLCJzbGFyciI6IuKGkCIsIlNtYWxsQ2lyY2xlIjoi4oiYIiwic21hbGxzZXRtaW51cyI6IuKIliIsInNtYXNocCI6IuKosyIsInNtZXBhcnNsIjoi4qekIiwic21pZCI6IuKIoyIsInNtaWxlIjoi4oyjIiwic210Ijoi4qqqIiwic210ZSI6IuKqrCIsInNtdGVzIjoi4qqs77iAIiwiU09GVGN5Ijoi0KwiLCJzb2Z0Y3kiOiLRjCIsInNvbGJhciI6IuKMvyIsInNvbGIiOiLip4QiLCJzb2wiOiIvIiwiU29wZiI6IvCdlYoiLCJzb3BmIjoi8J2VpCIsInNwYWRlcyI6IuKZoCIsInNwYWRlc3VpdCI6IuKZoCIsInNwYXIiOiLiiKUiLCJzcWNhcCI6IuKKkyIsInNxY2FwcyI6IuKKk++4gCIsInNxY3VwIjoi4oqUIiwic3FjdXBzIjoi4oqU77iAIiwiU3FydCI6IuKImiIsInNxc3ViIjoi4oqPIiwic3FzdWJlIjoi4oqRIiwic3FzdWJzZXQiOiLiio8iLCJzcXN1YnNldGVxIjoi4oqRIiwic3FzdXAiOiLiipAiLCJzcXN1cGUiOiLiipIiLCJzcXN1cHNldCI6IuKKkCIsInNxc3Vwc2V0ZXEiOiLiipIiLCJzcXVhcmUiOiLilqEiLCJTcXVhcmUiOiLilqEiLCJTcXVhcmVJbnRlcnNlY3Rpb24iOiLiipMiLCJTcXVhcmVTdWJzZXQiOiLiio8iLCJTcXVhcmVTdWJzZXRFcXVhbCI6IuKKkSIsIlNxdWFyZVN1cGVyc2V0Ijoi4oqQIiwiU3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKKkiIsIlNxdWFyZVVuaW9uIjoi4oqUIiwic3F1YXJmIjoi4paqIiwic3F1Ijoi4pahIiwic3F1ZiI6IuKWqiIsInNyYXJyIjoi4oaSIiwiU3NjciI6IvCdkq4iLCJzc2NyIjoi8J2TiCIsInNzZXRtbiI6IuKIliIsInNzbWlsZSI6IuKMoyIsInNzdGFyZiI6IuKLhiIsIlN0YXIiOiLii4YiLCJzdGFyIjoi4piGIiwic3RhcmYiOiLimIUiLCJzdHJhaWdodGVwc2lsb24iOiLPtSIsInN0cmFpZ2h0cGhpIjoiz5UiLCJzdHJucyI6IsKvIiwic3ViIjoi4oqCIiwiU3ViIjoi4ouQIiwic3ViZG90Ijoi4qq9Iiwic3ViRSI6IuKrhSIsInN1YmUiOiLiioYiLCJzdWJlZG90Ijoi4quDIiwic3VibXVsdCI6IuKrgSIsInN1Ym5FIjoi4quLIiwic3VibmUiOiLiiooiLCJzdWJwbHVzIjoi4qq/Iiwic3VicmFyciI6IuKluSIsInN1YnNldCI6IuKKgiIsIlN1YnNldCI6IuKLkCIsInN1YnNldGVxIjoi4oqGIiwic3Vic2V0ZXFxIjoi4quFIiwiU3Vic2V0RXF1YWwiOiLiioYiLCJzdWJzZXRuZXEiOiLiiooiLCJzdWJzZXRuZXFxIjoi4quLIiwic3Vic2ltIjoi4quHIiwic3Vic3ViIjoi4quVIiwic3Vic3VwIjoi4quTIiwic3VjY2FwcHJveCI6IuKquCIsInN1Y2MiOiLiibsiLCJzdWNjY3VybHllcSI6IuKJvSIsIlN1Y2NlZWRzIjoi4om7IiwiU3VjY2VlZHNFcXVhbCI6IuKqsCIsIlN1Y2NlZWRzU2xhbnRFcXVhbCI6IuKJvSIsIlN1Y2NlZWRzVGlsZGUiOiLiib8iLCJzdWNjZXEiOiLiqrAiLCJzdWNjbmFwcHJveCI6IuKquiIsInN1Y2NuZXFxIjoi4qq2Iiwic3VjY25zaW0iOiLii6kiLCJzdWNjc2ltIjoi4om/IiwiU3VjaFRoYXQiOiLiiIsiLCJzdW0iOiLiiJEiLCJTdW0iOiLiiJEiLCJzdW5nIjoi4pmqIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3VwIjoi4oqDIiwiU3VwIjoi4ouRIiwic3VwZG90Ijoi4qq+Iiwic3VwZHN1YiI6IuKrmCIsInN1cEUiOiLiq4YiLCJzdXBlIjoi4oqHIiwic3VwZWRvdCI6IuKrhCIsIlN1cGVyc2V0Ijoi4oqDIiwiU3VwZXJzZXRFcXVhbCI6IuKKhyIsInN1cGhzb2wiOiLin4kiLCJzdXBoc3ViIjoi4quXIiwic3VwbGFyciI6IuKluyIsInN1cG11bHQiOiLiq4IiLCJzdXBuRSI6IuKrjCIsInN1cG5lIjoi4oqLIiwic3VwcGx1cyI6IuKrgCIsInN1cHNldCI6IuKKgyIsIlN1cHNldCI6IuKLkSIsInN1cHNldGVxIjoi4oqHIiwic3Vwc2V0ZXFxIjoi4quGIiwic3Vwc2V0bmVxIjoi4oqLIiwic3Vwc2V0bmVxcSI6IuKrjCIsInN1cHNpbSI6IuKriCIsInN1cHN1YiI6IuKrlCIsInN1cHN1cCI6IuKrliIsInN3YXJoayI6IuKkpiIsInN3YXJyIjoi4oaZIiwic3dBcnIiOiLih5kiLCJzd2Fycm93Ijoi4oaZIiwic3dud2FyIjoi4qSqIiwic3psaWciOiLDnyIsIlRhYiI6IlxcdCIsInRhcmdldCI6IuKMliIsIlRhdSI6Is6kIiwidGF1Ijoiz4QiLCJ0YnJrIjoi4o60IiwiVGNhcm9uIjoixaQiLCJ0Y2Fyb24iOiLFpSIsIlRjZWRpbCI6IsWiIiwidGNlZGlsIjoixaMiLCJUY3kiOiLQoiIsInRjeSI6ItGCIiwidGRvdCI6IuKDmyIsInRlbHJlYyI6IuKMlSIsIlRmciI6IvCdlJciLCJ0ZnIiOiLwnZSxIiwidGhlcmU0Ijoi4oi0IiwidGhlcmVmb3JlIjoi4oi0IiwiVGhlcmVmb3JlIjoi4oi0IiwiVGhldGEiOiLOmCIsInRoZXRhIjoizrgiLCJ0aGV0YXN5bSI6Is+RIiwidGhldGF2Ijoiz5EiLCJ0aGlja2FwcHJveCI6IuKJiCIsInRoaWNrc2ltIjoi4oi8IiwiVGhpY2tTcGFjZSI6IuKBn+KAiiIsIlRoaW5TcGFjZSI6IuKAiSIsInRoaW5zcCI6IuKAiSIsInRoa2FwIjoi4omIIiwidGhrc2ltIjoi4oi8IiwiVEhPUk4iOiLDniIsInRob3JuIjoiw74iLCJ0aWxkZSI6IsucIiwiVGlsZGUiOiLiiLwiLCJUaWxkZUVxdWFsIjoi4omDIiwiVGlsZGVGdWxsRXF1YWwiOiLiiYUiLCJUaWxkZVRpbGRlIjoi4omIIiwidGltZXNiYXIiOiLiqLEiLCJ0aW1lc2IiOiLiiqAiLCJ0aW1lcyI6IsOXIiwidGltZXNkIjoi4qiwIiwidGludCI6IuKIrSIsInRvZWEiOiLipKgiLCJ0b3Bib3QiOiLijLYiLCJ0b3BjaXIiOiLiq7EiLCJ0b3AiOiLiiqQiLCJUb3BmIjoi8J2ViyIsInRvcGYiOiLwnZWlIiwidG9wZm9yayI6IuKrmiIsInRvc2EiOiLipKkiLCJ0cHJpbWUiOiLigLQiLCJ0cmFkZSI6IuKEoiIsIlRSQURFIjoi4oSiIiwidHJpYW5nbGUiOiLilrUiLCJ0cmlhbmdsZWRvd24iOiLilr8iLCJ0cmlhbmdsZWxlZnQiOiLil4MiLCJ0cmlhbmdsZWxlZnRlcSI6IuKKtCIsInRyaWFuZ2xlcSI6IuKJnCIsInRyaWFuZ2xlcmlnaHQiOiLilrkiLCJ0cmlhbmdsZXJpZ2h0ZXEiOiLiirUiLCJ0cmlkb3QiOiLil6wiLCJ0cmllIjoi4omcIiwidHJpbWludXMiOiLiqLoiLCJUcmlwbGVEb3QiOiLig5siLCJ0cmlwbHVzIjoi4qi5IiwidHJpc2IiOiLip40iLCJ0cml0aW1lIjoi4qi7IiwidHJwZXppdW0iOiLij6IiLCJUc2NyIjoi8J2SryIsInRzY3IiOiLwnZOJIiwiVFNjeSI6ItCmIiwidHNjeSI6ItGGIiwiVFNIY3kiOiLQiyIsInRzaGN5Ijoi0ZsiLCJUc3Ryb2siOiLFpiIsInRzdHJvayI6IsWnIiwidHdpeHQiOiLiiawiLCJ0d29oZWFkbGVmdGFycm93Ijoi4oaeIiwidHdvaGVhZHJpZ2h0YXJyb3ciOiLihqAiLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwidWFyciI6IuKGkSIsIlVhcnIiOiLihp8iLCJ1QXJyIjoi4oeRIiwiVWFycm9jaXIiOiLipYkiLCJVYnJjeSI6ItCOIiwidWJyY3kiOiLRniIsIlVicmV2ZSI6IsWsIiwidWJyZXZlIjoixa0iLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVjeSI6ItCjIiwidWN5Ijoi0YMiLCJ1ZGFyciI6IuKHhSIsIlVkYmxhYyI6IsWwIiwidWRibGFjIjoixbEiLCJ1ZGhhciI6IuKlriIsInVmaXNodCI6IuKlviIsIlVmciI6IvCdlJgiLCJ1ZnIiOiLwnZSyIiwiVWdyYXZlIjoiw5kiLCJ1Z3JhdmUiOiLDuSIsInVIYXIiOiLipaMiLCJ1aGFybCI6IuKGvyIsInVoYXJyIjoi4oa+IiwidWhibGsiOiLiloAiLCJ1bGNvcm4iOiLijJwiLCJ1bGNvcm5lciI6IuKMnCIsInVsY3JvcCI6IuKMjyIsInVsdHJpIjoi4pe4IiwiVW1hY3IiOiLFqiIsInVtYWNyIjoixasiLCJ1bWwiOiLCqCIsIlVuZGVyQmFyIjoiXyIsIlVuZGVyQnJhY2UiOiLij58iLCJVbmRlckJyYWNrZXQiOiLijrUiLCJVbmRlclBhcmVudGhlc2lzIjoi4o+dIiwiVW5pb24iOiLii4MiLCJVbmlvblBsdXMiOiLiio4iLCJVb2dvbiI6IsWyIiwidW9nb24iOiLFsyIsIlVvcGYiOiLwnZWMIiwidW9wZiI6IvCdlaYiLCJVcEFycm93QmFyIjoi4qSSIiwidXBhcnJvdyI6IuKGkSIsIlVwQXJyb3ciOiLihpEiLCJVcGFycm93Ijoi4oeRIiwiVXBBcnJvd0Rvd25BcnJvdyI6IuKHhSIsInVwZG93bmFycm93Ijoi4oaVIiwiVXBEb3duQXJyb3ciOiLihpUiLCJVcGRvd25hcnJvdyI6IuKHlSIsIlVwRXF1aWxpYnJpdW0iOiLipa4iLCJ1cGhhcnBvb25sZWZ0Ijoi4oa/IiwidXBoYXJwb29ucmlnaHQiOiLihr4iLCJ1cGx1cyI6IuKKjiIsIlVwcGVyTGVmdEFycm93Ijoi4oaWIiwiVXBwZXJSaWdodEFycm93Ijoi4oaXIiwidXBzaSI6Is+FIiwiVXBzaSI6Is+SIiwidXBzaWgiOiLPkiIsIlVwc2lsb24iOiLOpSIsInVwc2lsb24iOiLPhSIsIlVwVGVlQXJyb3ciOiLihqUiLCJVcFRlZSI6IuKKpSIsInVwdXBhcnJvd3MiOiLih4giLCJ1cmNvcm4iOiLijJ0iLCJ1cmNvcm5lciI6IuKMnSIsInVyY3JvcCI6IuKMjiIsIlVyaW5nIjoixa4iLCJ1cmluZyI6IsWvIiwidXJ0cmkiOiLil7kiLCJVc2NyIjoi8J2SsCIsInVzY3IiOiLwnZOKIiwidXRkb3QiOiLii7AiLCJVdGlsZGUiOiLFqCIsInV0aWxkZSI6IsWpIiwidXRyaSI6IuKWtSIsInV0cmlmIjoi4pa0IiwidXVhcnIiOiLih4giLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJ1d2FuZ2xlIjoi4qanIiwidmFuZ3J0Ijoi4qacIiwidmFyZXBzaWxvbiI6Is+1IiwidmFya2FwcGEiOiLPsCIsInZhcm5vdGhpbmciOiLiiIUiLCJ2YXJwaGkiOiLPlSIsInZhcnBpIjoiz5YiLCJ2YXJwcm9wdG8iOiLiiJ0iLCJ2YXJyIjoi4oaVIiwidkFyciI6IuKHlSIsInZhcnJobyI6Is+xIiwidmFyc2lnbWEiOiLPgiIsInZhcnN1YnNldG5lcSI6IuKKiu+4gCIsInZhcnN1YnNldG5lcXEiOiLiq4vvuIAiLCJ2YXJzdXBzZXRuZXEiOiLiiovvuIAiLCJ2YXJzdXBzZXRuZXFxIjoi4quM77iAIiwidmFydGhldGEiOiLPkSIsInZhcnRyaWFuZ2xlbGVmdCI6IuKKsiIsInZhcnRyaWFuZ2xlcmlnaHQiOiLiirMiLCJ2QmFyIjoi4quoIiwiVmJhciI6IuKrqyIsInZCYXJ2Ijoi4qupIiwiVmN5Ijoi0JIiLCJ2Y3kiOiLQsiIsInZkYXNoIjoi4oqiIiwidkRhc2giOiLiiqgiLCJWZGFzaCI6IuKKqSIsIlZEYXNoIjoi4oqrIiwiVmRhc2hsIjoi4qumIiwidmVlYmFyIjoi4oq7IiwidmVlIjoi4oioIiwiVmVlIjoi4ouBIiwidmVlZXEiOiLiiZoiLCJ2ZWxsaXAiOiLii64iLCJ2ZXJiYXIiOiJ8IiwiVmVyYmFyIjoi4oCWIiwidmVydCI6InwiLCJWZXJ0Ijoi4oCWIiwiVmVydGljYWxCYXIiOiLiiKMiLCJWZXJ0aWNhbExpbmUiOiJ8IiwiVmVydGljYWxTZXBhcmF0b3IiOiLinZgiLCJWZXJ0aWNhbFRpbGRlIjoi4omAIiwiVmVyeVRoaW5TcGFjZSI6IuKAiiIsIlZmciI6IvCdlJkiLCJ2ZnIiOiLwnZSzIiwidmx0cmkiOiLiirIiLCJ2bnN1YiI6IuKKguKDkiIsInZuc3VwIjoi4oqD4oOSIiwiVm9wZiI6IvCdlY0iLCJ2b3BmIjoi8J2VpyIsInZwcm9wIjoi4oidIiwidnJ0cmkiOiLiirMiLCJWc2NyIjoi8J2SsSIsInZzY3IiOiLwnZOLIiwidnN1Ym5FIjoi4quL77iAIiwidnN1Ym5lIjoi4oqK77iAIiwidnN1cG5FIjoi4quM77iAIiwidnN1cG5lIjoi4oqL77iAIiwiVnZkYXNoIjoi4oqqIiwidnppZ3phZyI6IuKmmiIsIldjaXJjIjoixbQiLCJ3Y2lyYyI6IsW1Iiwid2VkYmFyIjoi4qmfIiwid2VkZ2UiOiLiiKciLCJXZWRnZSI6IuKLgCIsIndlZGdlcSI6IuKJmSIsIndlaWVycCI6IuKEmCIsIldmciI6IvCdlJoiLCJ3ZnIiOiLwnZS0IiwiV29wZiI6IvCdlY4iLCJ3b3BmIjoi8J2VqCIsIndwIjoi4oSYIiwid3IiOiLiiYAiLCJ3cmVhdGgiOiLiiYAiLCJXc2NyIjoi8J2SsiIsIndzY3IiOiLwnZOMIiwieGNhcCI6IuKLgiIsInhjaXJjIjoi4pevIiwieGN1cCI6IuKLgyIsInhkdHJpIjoi4pa9IiwiWGZyIjoi8J2UmyIsInhmciI6IvCdlLUiLCJ4aGFyciI6IuKftyIsInhoQXJyIjoi4p+6IiwiWGkiOiLOniIsInhpIjoizr4iLCJ4bGFyciI6IuKftSIsInhsQXJyIjoi4p+4IiwieG1hcCI6IuKfvCIsInhuaXMiOiLii7siLCJ4b2RvdCI6IuKogCIsIlhvcGYiOiLwnZWPIiwieG9wZiI6IvCdlakiLCJ4b3BsdXMiOiLiqIEiLCJ4b3RpbWUiOiLiqIIiLCJ4cmFyciI6IuKftiIsInhyQXJyIjoi4p+5IiwiWHNjciI6IvCdkrMiLCJ4c2NyIjoi8J2TjSIsInhzcWN1cCI6IuKohiIsInh1cGx1cyI6IuKohCIsInh1dHJpIjoi4pazIiwieHZlZSI6IuKLgSIsInh3ZWRnZSI6IuKLgCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJZQWN5Ijoi0K8iLCJ5YWN5Ijoi0Y8iLCJZY2lyYyI6IsW2IiwieWNpcmMiOiLFtyIsIlljeSI6ItCrIiwieWN5Ijoi0YsiLCJ5ZW4iOiLCpSIsIllmciI6IvCdlJwiLCJ5ZnIiOiLwnZS2IiwiWUljeSI6ItCHIiwieWljeSI6ItGXIiwiWW9wZiI6IvCdlZAiLCJ5b3BmIjoi8J2VqiIsIllzY3IiOiLwnZK0IiwieXNjciI6IvCdk44iLCJZVWN5Ijoi0K4iLCJ5dWN5Ijoi0Y4iLCJ5dW1sIjoiw78iLCJZdW1sIjoixbgiLCJaYWN1dGUiOiLFuSIsInphY3V0ZSI6IsW6IiwiWmNhcm9uIjoixb0iLCJ6Y2Fyb24iOiLFviIsIlpjeSI6ItCXIiwiemN5Ijoi0LciLCJaZG90IjoixbsiLCJ6ZG90IjoixbwiLCJ6ZWV0cmYiOiLihKgiLCJaZXJvV2lkdGhTcGFjZSI6IuKAiyIsIlpldGEiOiLOliIsInpldGEiOiLOtiIsInpmciI6IvCdlLciLCJaZnIiOiLihKgiLCJaSGN5Ijoi0JYiLCJ6aGN5Ijoi0LYiLCJ6aWdyYXJyIjoi4oedIiwiem9wZiI6IvCdlasiLCJab3BmIjoi4oSkIiwiWnNjciI6IvCdkrUiLCJ6c2NyIjoi8J2TjyIsInp3aiI6IuKAjSIsInp3bmoiOiLigIwifScpfSxmdW5jdGlvbihMKXtMLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJBYWN1dGUiOiLDgSIsImFhY3V0ZSI6IsOhIiwiQWNpcmMiOiLDgiIsImFjaXJjIjoiw6IiLCJhY3V0ZSI6IsK0IiwiQUVsaWciOiLDhiIsImFlbGlnIjoiw6YiLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkF0aWxkZSI6IsODIiwiYXRpbGRlIjoiw6MiLCJBdW1sIjoiw4QiLCJhdW1sIjoiw6QiLCJicnZiYXIiOiLCpiIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJjZWRpbCI6IsK4IiwiY2VudCI6IsKiIiwiY29weSI6IsKpIiwiQ09QWSI6IsKpIiwiY3VycmVuIjoiwqQiLCJkZWciOiLCsCIsImRpdmlkZSI6IsO3IiwiRWFjdXRlIjoiw4kiLCJlYWN1dGUiOiLDqSIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiRWdyYXZlIjoiw4giLCJlZ3JhdmUiOiLDqCIsIkVUSCI6IsOQIiwiZXRoIjoiw7AiLCJFdW1sIjoiw4siLCJldW1sIjoiw6siLCJmcmFjMTIiOiLCvSIsImZyYWMxNCI6IsK8IiwiZnJhYzM0Ijoiwr4iLCJndCI6Ij4iLCJHVCI6Ij4iLCJJYWN1dGUiOiLDjSIsImlhY3V0ZSI6IsOtIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJpZXhjbCI6IsKhIiwiSWdyYXZlIjoiw4wiLCJpZ3JhdmUiOiLDrCIsImlxdWVzdCI6IsK/IiwiSXVtbCI6IsOPIiwiaXVtbCI6IsOvIiwibGFxdW8iOiLCqyIsImx0IjoiPCIsIkxUIjoiPCIsIm1hY3IiOiLCryIsIm1pY3JvIjoiwrUiLCJtaWRkb3QiOiLCtyIsIm5ic3AiOiLCoCIsIm5vdCI6IsKsIiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJPY2lyYyI6IsOUIiwib2NpcmMiOiLDtCIsIk9ncmF2ZSI6IsOSIiwib2dyYXZlIjoiw7IiLCJvcmRmIjoiwqoiLCJvcmRtIjoiwroiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4IiwiT3RpbGRlIjoiw5UiLCJvdGlsZGUiOiLDtSIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsInBhcmEiOiLCtiIsInBsdXNtbiI6IsKxIiwicG91bmQiOiLCoyIsInF1b3QiOiJcXCIiLCJRVU9UIjoiXFwiIiwicmFxdW8iOiLCuyIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJzZWN0IjoiwqciLCJzaHkiOiLCrSIsInN1cDEiOiLCuSIsInN1cDIiOiLCsiIsInN1cDMiOiLCsyIsInN6bGlnIjoiw58iLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbWVzIjoiw5ciLCJVYWN1dGUiOiLDmiIsInVhY3V0ZSI6IsO6IiwiVWNpcmMiOiLDmyIsInVjaXJjIjoiw7siLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidW1sIjoiwqgiLCJVdW1sIjoiw5wiLCJ1dW1sIjoiw7wiLCJZYWN1dGUiOiLDnSIsInlhY3V0ZSI6IsO9IiwieWVuIjoiwqUiLCJ5dW1sIjoiw78ifScpfSxmdW5jdGlvbihMKXtMLmV4cG9ydHM9SlNPTi5wYXJzZShgeyJhbXAiOiImIiwiYXBvcyI6IiciLCJndCI6Ij4iLCJsdCI6IjwiLCJxdW90IjoiXFwiIn1gKX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihUKXtyZXR1cm4gVCYmVC5fX2VzTW9kdWxlP1Q6e2RlZmF1bHQ6VH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgbz1hKHQoMjY1KSk7ZnVuY3Rpb24gdihUKXtpZihUPj01NTI5NiYmVDw9NTczNDN8fFQ+MTExNDExMSlyZXR1cm4i77+9IjtUIGluIG8uZGVmYXVsdCYmKFQ9by5kZWZhdWx0W1RdKTt2YXIgZD0iIjtyZXR1cm4gVD42NTUzNSYmKFQtPTY1NTM2LGQrPVN0cmluZy5mcm9tQ2hhckNvZGUoVD4+PjEwJjEwMjN8NTUyOTYpLFQ9NTYzMjB8VCYxMDIzKSxkKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFQpLGR9ZS5kZWZhdWx0PXZ9LGZ1bmN0aW9uKEwpe0wuZXhwb3J0cz1KU09OLnBhcnNlKCd7IjAiOjY1NTMzLCIxMjgiOjgzNjQsIjEzMCI6ODIxOCwiMTMxIjo0MDIsIjEzMiI6ODIyMiwiMTMzIjo4MjMwLCIxMzQiOjgyMjQsIjEzNSI6ODIyNSwiMTM2Ijo3MTAsIjEzNyI6ODI0MCwiMTM4IjozNTIsIjEzOSI6ODI0OSwiMTQwIjozMzgsIjE0MiI6MzgxLCIxNDUiOjgyMTYsIjE0NiI6ODIxNywiMTQ3Ijo4MjIwLCIxNDgiOjgyMjEsIjE0OSI6ODIyNiwiMTUwIjo4MjExLCIxNTEiOjgyMTIsIjE1MiI6NzMyLCIxNTMiOjg0ODIsIjE1NCI6MzUzLCIxNTUiOjgyNTAsIjE1NiI6MzM5LCIxNTgiOjM4MiwiMTU5IjozNzZ9Jyl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24obSl7cmV0dXJuIG0mJm0uX19lc01vZHVsZT9tOntkZWZhdWx0Om19fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lc2NhcGU9ZS5lbmNvZGVIVE1MPWUuZW5jb2RlWE1MPXZvaWQgMDt2YXIgbz1hKHQoMjYzKSksdj1FKG8uZGVmYXVsdCksVD1mKHYpO2UuZW5jb2RlWE1MPUModixUKTt2YXIgZD1hKHQoMjYxKSksdT1FKGQuZGVmYXVsdCksYz1mKHUpO2UuZW5jb2RlSFRNTD1DKHUsYyk7ZnVuY3Rpb24gRShtKXtyZXR1cm4gT2JqZWN0LmtleXMobSkuc29ydCgpLnJlZHVjZShmdW5jdGlvbihyLGkpe3JldHVybiByW21baV1dPSImIitpKyI7IixyfSx7fSl9ZnVuY3Rpb24gZihtKXtmb3IodmFyIHI9W10saT1bXSxuPTAscz1PYmplY3Qua2V5cyhtKTtuPHMubGVuZ3RoO24rKyl7dmFyIE09c1tuXTtNLmxlbmd0aD09PTE/ci5wdXNoKCJcXCIrTSk6aS5wdXNoKE0pfXIuc29ydCgpO2Zvcih2YXIgUD0wO1A8ci5sZW5ndGgtMTtQKyspe2Zvcih2YXIgUz1QO1M8ci5sZW5ndGgtMSYmcltTXS5jaGFyQ29kZUF0KDEpKzE9PT1yW1MrMV0uY2hhckNvZGVBdCgxKTspUys9MTt2YXIgYj0xK1MtUDtiPDN8fHIuc3BsaWNlKFAsYixyW1BdKyItIityW1NdKX1yZXR1cm4gaS51bnNoaWZ0KCJbIityLmpvaW4oIiIpKyJdIiksbmV3IFJlZ0V4cChpLmpvaW4oInwiKSwiZyIpfXZhciBnPS8oPzpbXHg4MC1cdUQ3RkZcdUUwMDAtXHVGRkZGXXxbXHVEODAwLVx1REJGRl1bXHVEQzAwLVx1REZGRl18W1x1RDgwMC1cdURCRkZdKD8hW1x1REMwMC1cdURGRkZdKXwoPzpbXlx1RDgwMC1cdURCRkZdfF4pW1x1REMwMC1cdURGRkZdKS9nO2Z1bmN0aW9uIHkobSl7cmV0dXJuIiYjeCIrbS5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSsiOyJ9ZnVuY3Rpb24gQyhtLHIpe3JldHVybiBmdW5jdGlvbihpKXtyZXR1cm4gaS5yZXBsYWNlKHIsZnVuY3Rpb24obil7cmV0dXJuIG1bbl19KS5yZXBsYWNlKGcseSl9fXZhciB4PWYodik7ZnVuY3Rpb24gaChtKXtyZXR1cm4gbS5yZXBsYWNlKHgseSkucmVwbGFjZShnLHkpfWUuZXNjYXBlPWh9LGZ1bmN0aW9uKEwpe0wuZXhwb3J0cz1KU09OLnBhcnNlKCd7ImVsZW1lbnROYW1lcyI6eyJhbHRnbHlwaCI6ImFsdEdseXBoIiwiYWx0Z2x5cGhkZWYiOiJhbHRHbHlwaERlZiIsImFsdGdseXBoaXRlbSI6ImFsdEdseXBoSXRlbSIsImFuaW1hdGVjb2xvciI6ImFuaW1hdGVDb2xvciIsImFuaW1hdGVtb3Rpb24iOiJhbmltYXRlTW90aW9uIiwiYW5pbWF0ZXRyYW5zZm9ybSI6ImFuaW1hdGVUcmFuc2Zvcm0iLCJjbGlwcGF0aCI6ImNsaXBQYXRoIiwiZmVibGVuZCI6ImZlQmxlbmQiLCJmZWNvbG9ybWF0cml4IjoiZmVDb2xvck1hdHJpeCIsImZlY29tcG9uZW50dHJhbnNmZXIiOiJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVjb21wb3NpdGUiOiJmZUNvbXBvc2l0ZSIsImZlY29udm9sdmVtYXRyaXgiOiJmZUNvbnZvbHZlTWF0cml4IiwiZmVkaWZmdXNlbGlnaHRpbmciOiJmZURpZmZ1c2VMaWdodGluZyIsImZlZGlzcGxhY2VtZW50bWFwIjoiZmVEaXNwbGFjZW1lbnRNYXAiLCJmZWRpc3RhbnRsaWdodCI6ImZlRGlzdGFudExpZ2h0IiwiZmVkcm9wc2hhZG93IjoiZmVEcm9wU2hhZG93IiwiZmVmbG9vZCI6ImZlRmxvb2QiLCJmZWZ1bmNhIjoiZmVGdW5jQSIsImZlZnVuY2IiOiJmZUZ1bmNCIiwiZmVmdW5jZyI6ImZlRnVuY0ciLCJmZWZ1bmNyIjoiZmVGdW5jUiIsImZlZ2F1c3NpYW5ibHVyIjoiZmVHYXVzc2lhbkJsdXIiLCJmZWltYWdlIjoiZmVJbWFnZSIsImZlbWVyZ2UiOiJmZU1lcmdlIiwiZmVtZXJnZW5vZGUiOiJmZU1lcmdlTm9kZSIsImZlbW9ycGhvbG9neSI6ImZlTW9ycGhvbG9neSIsImZlb2Zmc2V0IjoiZmVPZmZzZXQiLCJmZXBvaW50bGlnaHQiOiJmZVBvaW50TGlnaHQiLCJmZXNwZWN1bGFybGlnaHRpbmciOiJmZVNwZWN1bGFyTGlnaHRpbmciLCJmZXNwb3RsaWdodCI6ImZlU3BvdExpZ2h0IiwiZmV0aWxlIjoiZmVUaWxlIiwiZmV0dXJidWxlbmNlIjoiZmVUdXJidWxlbmNlIiwiZm9yZWlnbm9iamVjdCI6ImZvcmVpZ25PYmplY3QiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwibGluZWFyZ3JhZGllbnQiOiJsaW5lYXJHcmFkaWVudCIsInJhZGlhbGdyYWRpZW50IjoicmFkaWFsR3JhZGllbnQiLCJ0ZXh0cGF0aCI6InRleHRQYXRoIn0sImF0dHJpYnV0ZU5hbWVzIjp7ImRlZmluaXRpb251cmwiOiJkZWZpbml0aW9uVVJMIiwiYXR0cmlidXRlbmFtZSI6ImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGV0eXBlIjoiYXR0cmlidXRlVHlwZSIsImJhc2VmcmVxdWVuY3kiOiJiYXNlRnJlcXVlbmN5IiwiYmFzZXByb2ZpbGUiOiJiYXNlUHJvZmlsZSIsImNhbGNtb2RlIjoiY2FsY01vZGUiLCJjbGlwcGF0aHVuaXRzIjoiY2xpcFBhdGhVbml0cyIsImRpZmZ1c2Vjb25zdGFudCI6ImRpZmZ1c2VDb25zdGFudCIsImVkZ2Vtb2RlIjoiZWRnZU1vZGUiLCJmaWx0ZXJ1bml0cyI6ImZpbHRlclVuaXRzIiwiZ2x5cGhyZWYiOiJnbHlwaFJlZiIsImdyYWRpZW50dHJhbnNmb3JtIjoiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIjoiZ3JhZGllbnRVbml0cyIsImtlcm5lbG1hdHJpeCI6Imtlcm5lbE1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiOiJrZXJuZWxVbml0TGVuZ3RoIiwia2V5cG9pbnRzIjoia2V5UG9pbnRzIiwia2V5c3BsaW5lcyI6ImtleVNwbGluZXMiLCJrZXl0aW1lcyI6ImtleVRpbWVzIiwibGVuZ3RoYWRqdXN0IjoibGVuZ3RoQWRqdXN0IiwibGltaXRpbmdjb25lYW5nbGUiOiJsaW1pdGluZ0NvbmVBbmdsZSIsIm1hcmtlcmhlaWdodCI6Im1hcmtlckhlaWdodCIsIm1hcmtlcnVuaXRzIjoibWFya2VyVW5pdHMiLCJtYXJrZXJ3aWR0aCI6Im1hcmtlcldpZHRoIiwibWFza2NvbnRlbnR1bml0cyI6Im1hc2tDb250ZW50VW5pdHMiLCJtYXNrdW5pdHMiOiJtYXNrVW5pdHMiLCJudW1vY3RhdmVzIjoibnVtT2N0YXZlcyIsInBhdGhsZW5ndGgiOiJwYXRoTGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyI6InBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIjoicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm51bml0cyI6InBhdHRlcm5Vbml0cyIsInBvaW50c2F0eCI6InBvaW50c0F0WCIsInBvaW50c2F0eSI6InBvaW50c0F0WSIsInBvaW50c2F0eiI6InBvaW50c0F0WiIsInByZXNlcnZlYWxwaGEiOiJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyI6InByZXNlcnZlQXNwZWN0UmF0aW8iLCJwcmltaXRpdmV1bml0cyI6InByaW1pdGl2ZVVuaXRzIiwicmVmeCI6InJlZlgiLCJyZWZ5IjoicmVmWSIsInJlcGVhdGNvdW50IjoicmVwZWF0Q291bnQiLCJyZXBlYXRkdXIiOiJyZXBlYXREdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiOiJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIjoicmVxdWlyZWRGZWF0dXJlcyIsInNwZWN1bGFyY29uc3RhbnQiOiJzcGVjdWxhckNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCI6InNwZWN1bGFyRXhwb25lbnQiLCJzcHJlYWRtZXRob2QiOiJzcHJlYWRNZXRob2QiLCJzdGFydG9mZnNldCI6InN0YXJ0T2Zmc2V0Iiwic3RkZGV2aWF0aW9uIjoic3RkRGV2aWF0aW9uIiwic3RpdGNodGlsZXMiOiJzdGl0Y2hUaWxlcyIsInN1cmZhY2VzY2FsZSI6InN1cmZhY2VTY2FsZSIsInN5c3RlbWxhbmd1YWdlIjoic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyI6InRhYmxlVmFsdWVzIiwidGFyZ2V0eCI6InRhcmdldFgiLCJ0YXJnZXR5IjoidGFyZ2V0WSIsInRleHRsZW5ndGgiOiJ0ZXh0TGVuZ3RoIiwidmlld2JveCI6InZpZXdCb3giLCJ2aWV3dGFyZ2V0Ijoidmlld1RhcmdldCIsInhjaGFubmVsc2VsZWN0b3IiOiJ4Q2hhbm5lbFNlbGVjdG9yIiwieWNoYW5uZWxzZWxlY3RvciI6InlDaGFubmVsU2VsZWN0b3IiLCJ6b29tYW5kcGFuIjoiem9vbUFuZFBhbiJ9fScpfSxmdW5jdGlvbihMLGUpe3ZhciB0PWUuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24obyl7cmV0dXJuIG8uY2hpbGRyZW59LGE9ZS5nZXRQYXJlbnQ9ZnVuY3Rpb24obyl7cmV0dXJuIG8ucGFyZW50fTtlLmdldFNpYmxpbmdzPWZ1bmN0aW9uKG8pe3ZhciB2PWEobyk7cmV0dXJuIHY/dCh2KTpbb119LGUuZ2V0QXR0cmlidXRlVmFsdWU9ZnVuY3Rpb24obyx2KXtyZXR1cm4gby5hdHRyaWJzJiZvLmF0dHJpYnNbdl19LGUuaGFzQXR0cmliPWZ1bmN0aW9uKG8sdil7cmV0dXJuISFvLmF0dHJpYnMmJmhhc093blByb3BlcnR5LmNhbGwoby5hdHRyaWJzLHYpfSxlLmdldE5hbWU9ZnVuY3Rpb24obyl7cmV0dXJuIG8ubmFtZX19LGZ1bmN0aW9uKEwsZSl7ZS5yZW1vdmVFbGVtZW50PWZ1bmN0aW9uKHQpe2lmKHQucHJldiYmKHQucHJldi5uZXh0PXQubmV4dCksdC5uZXh0JiYodC5uZXh0LnByZXY9dC5wcmV2KSx0LnBhcmVudCl7dmFyIGE9dC5wYXJlbnQuY2hpbGRyZW47YS5zcGxpY2UoYS5sYXN0SW5kZXhPZih0KSwxKX19LGUucmVwbGFjZUVsZW1lbnQ9ZnVuY3Rpb24odCxhKXt2YXIgbz1hLnByZXY9dC5wcmV2O28mJihvLm5leHQ9YSk7dmFyIHY9YS5uZXh0PXQubmV4dDt2JiYodi5wcmV2PWEpO3ZhciBUPWEucGFyZW50PXQucGFyZW50O2lmKFQpe3ZhciBkPVQuY2hpbGRyZW47ZFtkLmxhc3RJbmRleE9mKHQpXT1hfX0sZS5hcHBlbmRDaGlsZD1mdW5jdGlvbih0LGEpe2lmKGEucGFyZW50PXQsdC5jaGlsZHJlbi5wdXNoKGEpIT09MSl7dmFyIG89dC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aC0yXTtvLm5leHQ9YSxhLnByZXY9byxhLm5leHQ9bnVsbH19LGUuYXBwZW5kPWZ1bmN0aW9uKHQsYSl7dmFyIG89dC5wYXJlbnQsdj10Lm5leHQ7aWYoYS5uZXh0PXYsYS5wcmV2PXQsdC5uZXh0PWEsYS5wYXJlbnQ9byx2KXtpZih2LnByZXY9YSxvKXt2YXIgVD1vLmNoaWxkcmVuO1Quc3BsaWNlKFQubGFzdEluZGV4T2YodiksMCxhKX19ZWxzZSBvJiZvLmNoaWxkcmVuLnB1c2goYSl9LGUucHJlcGVuZD1mdW5jdGlvbih0LGEpe3ZhciBvPXQucGFyZW50O2lmKG8pe3ZhciB2PW8uY2hpbGRyZW47di5zcGxpY2Uodi5sYXN0SW5kZXhPZih0KSwwLGEpfXQucHJldiYmKHQucHJldi5uZXh0PWEpLGEucGFyZW50PW8sYS5wcmV2PXQucHJldixhLm5leHQ9dCx0LnByZXY9YX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDI1NikuaXNUYWc7TC5leHBvcnRzPXtmaWx0ZXI6byxmaW5kOnYsZmluZE9uZUNoaWxkOlQsZmluZE9uZTpkLGV4aXN0c09uZTp1LGZpbmRBbGw6Y307ZnVuY3Rpb24gbyhFLGYsZyx5KXtyZXR1cm4gQXJyYXkuaXNBcnJheShmKXx8KGY9W2ZdKSwodHlwZW9mIHkhPSJudW1iZXIifHwhaXNGaW5pdGUoeSkpJiYoeT0xLzApLHYoRSxmLGchPT0hMSx5KX1mdW5jdGlvbiB2KEUsZixnLHkpe2Zvcih2YXIgQz1bXSx4LGg9MCxtPWYubGVuZ3RoO2g8bSYmIShFKGZbaF0pJiYoQy5wdXNoKGZbaF0pLC0teTw9MCl8fCh4PWZbaF0uY2hpbGRyZW4sZyYmeCYmeC5sZW5ndGg+MCYmKHg9dihFLHgsZyx5KSxDPUMuY29uY2F0KHgpLHktPXgubGVuZ3RoLHk8PTApKSk7aCsrKTtyZXR1cm4gQ31mdW5jdGlvbiBUKEUsZil7Zm9yKHZhciBnPTAseT1mLmxlbmd0aDtnPHk7ZysrKWlmKEUoZltnXSkpcmV0dXJuIGZbZ107cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChFLGYpe2Zvcih2YXIgZz1udWxsLHk9MCxDPWYubGVuZ3RoO3k8QyYmIWc7eSsrKWlmKGEoZlt5XSkpRShmW3ldKT9nPWZbeV06Zlt5XS5jaGlsZHJlbi5sZW5ndGg+MCYmKGc9ZChFLGZbeV0uY2hpbGRyZW4pKTtlbHNlIGNvbnRpbnVlO3JldHVybiBnfWZ1bmN0aW9uIHUoRSxmKXtmb3IodmFyIGc9MCx5PWYubGVuZ3RoO2c8eTtnKyspaWYoYShmW2ddKSYmKEUoZltnXSl8fGZbZ10uY2hpbGRyZW4ubGVuZ3RoPjAmJnUoRSxmW2ddLmNoaWxkcmVuKSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gYyhFLGYpe2Zvcih2YXIgZz1bXSx5PWYuc2xpY2UoKTt5Lmxlbmd0aDspe3ZhciBDPXkuc2hpZnQoKTthKEMpJiYoQy5jaGlsZHJlbiYmQy5jaGlsZHJlbi5sZW5ndGg+MCYmeS51bnNoaWZ0LmFwcGx5KHksQy5jaGlsZHJlbiksRShDKSYmZy5wdXNoKEMpKX1yZXR1cm4gZ319LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDI1Niksbz1lLmlzVGFnPWEuaXNUYWc7ZS50ZXN0RWxlbWVudD1mdW5jdGlvbih1LGMpe2Zvcih2YXIgRSBpbiB1KWlmKHUuaGFzT3duUHJvcGVydHkoRSkpe2lmKEU9PT0idGFnX25hbWUiKXtpZighbyhjKXx8IXUudGFnX25hbWUoYy5uYW1lKSlyZXR1cm4hMX1lbHNlIGlmKEU9PT0idGFnX3R5cGUiKXtpZighdS50YWdfdHlwZShjLnR5cGUpKXJldHVybiExfWVsc2UgaWYoRT09PSJ0YWdfY29udGFpbnMiKXtpZihvKGMpfHwhdS50YWdfY29udGFpbnMoYy5kYXRhKSlyZXR1cm4hMX1lbHNlIGlmKCFjLmF0dHJpYnN8fCF1W0VdKGMuYXR0cmlic1tFXSkpcmV0dXJuITF9cmV0dXJuITB9O3ZhciB2PXt0YWdfbmFtZTpmdW5jdGlvbih1KXtyZXR1cm4gdHlwZW9mIHU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYyl7cmV0dXJuIG8oYykmJnUoYy5uYW1lKX06dT09PSIqIj9vOmZ1bmN0aW9uKGMpe3JldHVybiBvKGMpJiZjLm5hbWU9PT11fX0sdGFnX3R5cGU6ZnVuY3Rpb24odSl7cmV0dXJuIHR5cGVvZiB1PT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGMpe3JldHVybiB1KGMudHlwZSl9OmZ1bmN0aW9uKGMpe3JldHVybiBjLnR5cGU9PT11fX0sdGFnX2NvbnRhaW5zOmZ1bmN0aW9uKHUpe3JldHVybiB0eXBlb2YgdT09ImZ1bmN0aW9uIj9mdW5jdGlvbihjKXtyZXR1cm4hbyhjKSYmdShjLmRhdGEpfTpmdW5jdGlvbihjKXtyZXR1cm4hbyhjKSYmYy5kYXRhPT09dX19fTtmdW5jdGlvbiBUKHUsYyl7cmV0dXJuIHR5cGVvZiBjPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKEUpe3JldHVybiBFLmF0dHJpYnMmJmMoRS5hdHRyaWJzW3VdKX06ZnVuY3Rpb24oRSl7cmV0dXJuIEUuYXR0cmlicyYmRS5hdHRyaWJzW3VdPT09Y319ZnVuY3Rpb24gZCh1LGMpe3JldHVybiBmdW5jdGlvbihFKXtyZXR1cm4gdShFKXx8YyhFKX19ZS5nZXRFbGVtZW50cz1mdW5jdGlvbih1LGMsRSxmKXt2YXIgZz1PYmplY3Qua2V5cyh1KS5tYXAoZnVuY3Rpb24oeSl7dmFyIEM9dVt5XTtyZXR1cm4geSBpbiB2P3ZbeV0oQyk6VCh5LEMpfSk7cmV0dXJuIGcubGVuZ3RoPT09MD9bXTp0aGlzLmZpbHRlcihnLnJlZHVjZShkKSxjLEUsZil9LGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24odSxjLEUpe3JldHVybiBBcnJheS5pc0FycmF5KGMpfHwoYz1bY10pLHRoaXMuZmluZE9uZShUKCJpZCIsdSksYyxFIT09ITEpfSxlLmdldEVsZW1lbnRzQnlUYWdOYW1lPWZ1bmN0aW9uKHUsYyxFLGYpe3JldHVybiB0aGlzLmZpbHRlcih2LnRhZ19uYW1lKHUpLGMsRSxmKX0sZS5nZXRFbGVtZW50c0J5VGFnVHlwZT1mdW5jdGlvbih1LGMsRSxmKXtyZXR1cm4gdGhpcy5maWx0ZXIodi50YWdfdHlwZSh1KSxjLEUsZil9fSxmdW5jdGlvbihMLGUpe2UucmVtb3ZlU3Vic2V0cz1mdW5jdGlvbihvKXtmb3IodmFyIHY9by5sZW5ndGgsVCxkLHU7LS12Pi0xOyl7Zm9yKFQ9ZD1vW3ZdLG9bdl09bnVsbCx1PSEwO2Q7KXtpZihvLmluZGV4T2YoZCk+LTEpe3U9ITEsby5zcGxpY2UodiwxKTticmVha31kPWQucGFyZW50fXUmJihvW3ZdPVQpfXJldHVybiBvfTt2YXIgdD17RElTQ09OTkVDVEVEOjEsUFJFQ0VESU5HOjIsRk9MTE9XSU5HOjQsQ09OVEFJTlM6OCxDT05UQUlORURfQlk6MTZ9LGE9ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj1mdW5jdGlvbihvLHYpe3ZhciBUPVtdLGQ9W10sdSxjLEUsZixnLHk7aWYobz09PXYpcmV0dXJuIDA7Zm9yKHU9bzt1OylULnVuc2hpZnQodSksdT11LnBhcmVudDtmb3IodT12O3U7KWQudW5zaGlmdCh1KSx1PXUucGFyZW50O2Zvcih5PTA7VFt5XT09PWRbeV07KXkrKztyZXR1cm4geT09PTA/dC5ESVNDT05ORUNURUQ6KGM9VFt5LTFdLEU9Yy5jaGlsZHJlbixmPVRbeV0sZz1kW3ldLEUuaW5kZXhPZihmKT5FLmluZGV4T2YoZyk/Yz09PXY/dC5GT0xMT1dJTkd8dC5DT05UQUlORURfQlk6dC5GT0xMT1dJTkc6Yz09PW8/dC5QUkVDRURJTkd8dC5DT05UQUlOUzp0LlBSRUNFRElORyl9O2UudW5pcXVlU29ydD1mdW5jdGlvbihvKXt2YXIgdj1vLmxlbmd0aCxULGQ7Zm9yKG89by5zbGljZSgpOy0tdj4tMTspVD1vW3ZdLGQ9by5pbmRleE9mKFQpLGQ+LTEmJmQ8diYmby5zcGxpY2UodiwxKTtyZXR1cm4gby5zb3J0KGZ1bmN0aW9uKHUsYyl7dmFyIEU9YSh1LGMpO3JldHVybiBFJnQuUFJFQ0VESU5HPy0xOkUmdC5GT0xMT1dJTkc/MTowfSksb319LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPXt0cnVlRnVuYzpmdW5jdGlvbigpe3JldHVybiEwfSxmYWxzZUZ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4hMX19fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPWc7dmFyIGE9dCgyNzUpLnBhcnNlLG89dCgyNzMpLHY9dCgyNzgpLFQ9dCgyNzkpLGQ9dCgyODApLHU9dCgyODIpLGM9by50cnVlRnVuYyxFPW8uZmFsc2VGdW5jLGY9dS5maWx0ZXJzO2Z1bmN0aW9uIGcoTyxELEkpe3ZhciBSPUMoTyxELEkpO3JldHVybiB5KFIsRCl9ZnVuY3Rpb24geShPLEQpe3ZhciBJPUQuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oQSl7cmV0dXJuIEkuaXNUYWcoQSkmJk8oQSl9fWZ1bmN0aW9uIEMoTyxELEkpe3ZhciBSPWEoTyxEKTtyZXR1cm4gcyhSLEQsSSl9ZnVuY3Rpb24geChPKXtyZXR1cm4gTy50eXBlPT09InBzZXVkbyImJihPLm5hbWU9PT0ic2NvcGUifHxBcnJheS5pc0FycmF5KE8uZGF0YSkmJk8uZGF0YS5zb21lKGZ1bmN0aW9uKEQpe3JldHVybiBELnNvbWUoeCl9KSl9dmFyIGg9e3R5cGU6ImRlc2NlbmRhbnQifSxtPXt0eXBlOiJfZmxleGlibGVEZXNjZW5kYW50In0scj17dHlwZToicHNldWRvIixuYW1lOiJzY29wZSJ9LGk9e307ZnVuY3Rpb24gbihPLEQsSSl7dmFyIFI9RC5hZGFwdGVyLEE9ISFJJiYhIUkubGVuZ3RoJiZJLmV2ZXJ5KGZ1bmN0aW9uKFUpe3JldHVybiBVPT09aXx8ISFSLmdldFBhcmVudChVKX0pO08uZm9yRWFjaChmdW5jdGlvbihVKXtpZighKFUubGVuZ3RoPjAmJk0oVVswXSkmJlVbMF0udHlwZSE9PSJkZXNjZW5kYW50IikpaWYoQSYmIShBcnJheS5pc0FycmF5KFUpP1Uuc29tZSh4KTp4KFUpKSlVLnVuc2hpZnQoaCk7ZWxzZSByZXR1cm47VS51bnNoaWZ0KHIpfSl9ZnVuY3Rpb24gcyhPLEQsSSl7Tz1PLmZpbHRlcihmdW5jdGlvbihLKXtyZXR1cm4gSy5sZW5ndGg+MH0pLE8uZm9yRWFjaCh2KTt2YXIgUj1BcnJheS5pc0FycmF5KEkpO0k9RCYmRC5jb250ZXh0fHxJLEkmJiFSJiYoST1bSV0pLG4oTyxELEkpO3ZhciBBPSExLFU9Ty5tYXAoZnVuY3Rpb24oSyl7aWYoS1swXSYmS1sxXSYmS1swXS5uYW1lPT09InNjb3BlIil7dmFyIFY9S1sxXS50eXBlO1ImJlY9PT0iZGVzY2VuZGFudCI/S1sxXT1tOihWPT09ImFkamFjZW50Inx8Vj09PSJzaWJsaW5nIikmJihBPSEwKX1yZXR1cm4gUChLLEQsSSl9KS5yZWR1Y2UoUyxFKTtyZXR1cm4gVS5zaG91bGRUZXN0TmV4dFNpYmxpbmdzPUEsVX1mdW5jdGlvbiBNKE8pe3JldHVybiBUW08udHlwZV08MH1mdW5jdGlvbiBQKE8sRCxJKXtyZXR1cm4gTy5yZWR1Y2UoZnVuY3Rpb24oUixBKXtpZihSPT09RSlyZXR1cm4gUjtpZighKEEudHlwZSBpbiBkKSl0aHJvdyBuZXcgRXJyb3IoIlJ1bGUgdHlwZSAiK0EudHlwZSsiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgY3NzLXNlbGVjdCIpO3JldHVybiBkW0EudHlwZV0oUixBLEQsSSl9LEQmJkQucm9vdEZ1bmN8fGMpfWZ1bmN0aW9uIFMoTyxEKXtyZXR1cm4gRD09PUV8fE89PT1jP086Tz09PUV8fEQ9PT1jP0Q6ZnVuY3Rpb24oUil7cmV0dXJuIE8oUil8fEQoUil9fWZ1bmN0aW9uIGIoTyl7cmV0dXJuIE8uc29tZShNKX1mLm5vdD1mdW5jdGlvbihPLEQsSSxSKXt2YXIgQT17eG1sTW9kZTohIShJJiZJLnhtbE1vZGUpLHN0cmljdDohIShJJiZJLnN0cmljdCksYWRhcHRlcjpJLmFkYXB0ZXJ9O2lmKEEuc3RyaWN0JiYoRC5sZW5ndGg+MXx8RC5zb21lKGIpKSl0aHJvdyBuZXcgRXJyb3IoImNvbXBsZXggc2VsZWN0b3JzIGluIDpub3QgYXJlbid0IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUiKTt2YXIgVT1zKEQsQSxSKTtyZXR1cm4gVT09PUU/TzpVPT09Yz9FOmZ1bmN0aW9uKFYpe3JldHVybiFVKFYpJiZPKFYpfX0sZi5oYXM9ZnVuY3Rpb24oTyxELEkpe3ZhciBSPUkuYWRhcHRlcixBPXt4bWxNb2RlOiEhKEkmJkkueG1sTW9kZSksc3RyaWN0OiEhKEkmJkkuc3RyaWN0KSxhZGFwdGVyOlJ9LFU9RC5zb21lKGIpP1tpXTpudWxsLEs9cyhELEEsVSk7cmV0dXJuIEs9PT1FP0U6Sz09PWM/ZnVuY3Rpb24oUSl7cmV0dXJuIFIuZ2V0Q2hpbGRyZW4oUSkuc29tZShSLmlzVGFnKSYmTyhRKX06KEs9eShLLEkpLFU/ZnVuY3Rpb24oUSl7cmV0dXJuIE8oUSkmJihVWzBdPVEsUi5leGlzdHNPbmUoSyxSLmdldENoaWxkcmVuKFEpKSl9OmZ1bmN0aW9uKFEpe3JldHVybiBPKFEpJiZSLmV4aXN0c09uZShLLFIuZ2V0Q2hpbGRyZW4oUSkpfSl9LGYubWF0Y2hlcz1mdW5jdGlvbihPLEQsSSxSKXt2YXIgQT17eG1sTW9kZTohIShJJiZJLnhtbE1vZGUpLHN0cmljdDohIShJJiZJLnN0cmljdCkscm9vdEZ1bmM6TyxhZGFwdGVyOkkuYWRhcHRlcn07cmV0dXJuIHMoRCxBLFIpfSxnLmNvbXBpbGVUb2tlbj1zLGcuY29tcGlsZVVuc2FmZT1DLGcuUHNldWRvcz11fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGQsdSxjLEUpe0U9PT12b2lkIDAmJihFPWMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLEUse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHVbY119fSl9OmZ1bmN0aW9uKGQsdSxjLEUpe0U9PT12b2lkIDAmJihFPWMpLGRbRV09dVtjXX0pLG89dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGQsdSl7Zm9yKHZhciBjIGluIGQpYyE9PSJkZWZhdWx0IiYmIXUuaGFzT3duUHJvcGVydHkoYykmJmEodSxkLGMpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksbyh0KDI3NiksZSk7dmFyIHY9dCgyNzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJwYXJzZSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHYuZGVmYXVsdH19KTt2YXIgVD10KDI3Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInN0cmluZ2lmeSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFQuZGVmYXVsdH19KX0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9eDt2YXIgYT0vXlteXFxdPyg/OlxcKD86W1xkYS1mXXsxLDZ9XHM/fC4pfFtcd1wtXHUwMGIwLVx1RkZGRl0pKy8sbz0vXFwoW1xkYS1mXXsxLDZ9XHM/fChccyl8LikvZ2ksdj0vXlxzKigoPzpcXC58W1x3XHUwMGIwLVx1RkZGRi1dKSspXHMqKD86KFxTPyk9XHMqKD86KFsnIl0pKFteXSo/KVwzfCgjPyg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKil8KXwpXHMqKGkpP1xdLyxUPXt1bmRlZmluZWQ6ImV4aXN0cyIsIiI6ImVxdWFscyIsIn4iOiJlbGVtZW50IiwiXiI6InN0YXJ0IiwkOiJlbmQiLCIqIjoiYW55IiwiISI6Im5vdCIsInwiOiJoeXBoZW4ifSxkPXsiPiI6ImNoaWxkIiwiPCI6InBhcmVudCIsIn4iOiJzaWJsaW5nIiwiKyI6ImFkamFjZW50In0sdT17IiMiOlsiaWQiLCJlcXVhbHMiXSwiLiI6WyJjbGFzcyIsImVsZW1lbnQiXX0sYz1uZXcgU2V0KFsiaGFzIiwibm90IiwibWF0Y2hlcyJdKSxFPW5ldyBTZXQoWyJjb250YWlucyIsImljb250YWlucyJdKSxmPW5ldyBTZXQoWyciJywiJyJdKTtmdW5jdGlvbiBnKHIsaSxuKXt2YXIgcz1wYXJzZUludChpLDE2KS02NTUzNjtyZXR1cm4gcyE9PXN8fG4/aTpzPDA/U3RyaW5nLmZyb21DaGFyQ29kZShzKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKHM+PjEwfDU1Mjk2LHMmMTAyM3w1NjMyMCl9ZnVuY3Rpb24geShyKXtyZXR1cm4gci5yZXBsYWNlKG8sZyl9ZnVuY3Rpb24gQyhyKXtyZXR1cm4gcj09PSIgInx8cj09PWAKYHx8cj09PSIJInx8cj09PSJcZiJ8fHI9PT0iXHIifWZ1bmN0aW9uIHgocixpKXt2YXIgbj1bXTtpZihyPWgobiwiIityLGkpLHIhPT0iIil0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBzZWxlY3RvcjogIityKTtyZXR1cm4gbn1mdW5jdGlvbiBoKHIsaSxuKXt2YXIgcz1bXSxNPSExO2Z1bmN0aW9uIFAoKXt2YXIgWj1pLm1hdGNoKGEpO2lmKCFaKXRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbmFtZSwgZm91bmQgIitpKTt2YXIgdHQ9WlswXTtyZXR1cm4gaT1pLnN1YnN0cih0dC5sZW5ndGgpLHkodHQpfWZ1bmN0aW9uIFMoWil7Zm9yKDtDKGkuY2hhckF0KFopKTspWisrO2k9aS5zdWJzdHIoWil9ZnVuY3Rpb24gYihaKXtmb3IodmFyIHR0PTA7aS5jaGFyQXQoLS1aKT09PSJcXCI7KXR0Kys7cmV0dXJuKHR0JjEpPT09MX1mb3IoUygwKTtpIT09IiI7KXt2YXIgTz1pLmNoYXJBdCgwKTtpZihDKE8pKU09ITAsUygxKTtlbHNlIGlmKE8gaW4gZClzLnB1c2goe3R5cGU6ZFtPXX0pLE09ITEsUygxKTtlbHNlIGlmKE89PT0iLCIpe2lmKHMubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO3IucHVzaChzKSxzPVtdLE09ITEsUygxKX1lbHNlIGlmKE0mJihzLmxlbmd0aD4wJiZzLnB1c2goe3R5cGU6ImRlc2NlbmRhbnQifSksTT0hMSksTz09PSIqIilpPWkuc3Vic3RyKDEpLHMucHVzaCh7dHlwZToidW5pdmVyc2FsIn0pO2Vsc2UgaWYoTyBpbiB1KXt2YXIgRD11W09dLEk9RFswXSxSPURbMV07aT1pLnN1YnN0cigxKSxzLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpJLGFjdGlvbjpSLHZhbHVlOlAoKSxpZ25vcmVDYXNlOiExfSl9ZWxzZSBpZihPPT09IlsiKXtpPWkuc3Vic3RyKDEpO3ZhciBBPWkubWF0Y2godik7aWYoIUEpdGhyb3cgbmV3IEVycm9yKCJNYWxmb3JtZWQgYXR0cmlidXRlIHNlbGVjdG9yOiAiK2kpO2k9aS5zdWJzdHIoQVswXS5sZW5ndGgpO3ZhciBVPXkoQVsxXSk7KCFufHwoImxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzImluIG4/bi5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lczohbi54bWxNb2RlKSkmJihVPVUudG9Mb3dlckNhc2UoKSkscy5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLG5hbWU6VSxhY3Rpb246VFtBWzJdXSx2YWx1ZTp5KEFbNF18fEFbNV18fCIiKSxpZ25vcmVDYXNlOiEhQVs2XX0pfWVsc2UgaWYoTz09PSI6Iil7aWYoaS5jaGFyQXQoMSk9PT0iOiIpe2k9aS5zdWJzdHIoMikscy5wdXNoKHt0eXBlOiJwc2V1ZG8tZWxlbWVudCIsbmFtZTpQKCkudG9Mb3dlckNhc2UoKX0pO2NvbnRpbnVlfWk9aS5zdWJzdHIoMSk7dmFyIEs9UCgpLnRvTG93ZXJDYXNlKCksQT1udWxsO2lmKGkuY2hhckF0KDApPT09IigiKWlmKGMuaGFzKEspKXt2YXIgVj1pLmNoYXJBdCgxKSxRPWYuaGFzKFYpO2lmKGk9aS5zdWJzdHIoUT8yOjEpLEE9W10saT1oKEEsaSxuKSxRKXtpZihpLmNoYXJBdCgwKSE9PVYpdGhyb3cgbmV3IEVycm9yKCJVbm1hdGNoZWQgcXVvdGVzIGluIDoiK0spO2k9aS5zdWJzdHIoMSl9aWYoaS5jaGFyQXQoMCkhPT0iKSIpdGhyb3cgbmV3IEVycm9yKCJNaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMgaW4gOiIrSysiICgiK2krIikiKTtpPWkuc3Vic3RyKDEpfWVsc2V7Zm9yKHZhciBxPTEsVz0xO1c+MCYmcTxpLmxlbmd0aDtxKyspaS5jaGFyQXQocSk9PT0iKCImJiFiKHEpP1crKzppLmNoYXJBdChxKT09PSIpIiYmIWIocSkmJlctLTtpZihXKXRocm93IG5ldyBFcnJvcigiUGFyZW50aGVzaXMgbm90IG1hdGNoZWQiKTtpZihBPWkuc3Vic3RyKDEscS0yKSxpPWkuc3Vic3RyKHEpLEUuaGFzKEspKXt2YXIgVj1BLmNoYXJBdCgwKTtWPT09QS5zbGljZSgtMSkmJmYuaGFzKFYpJiYoQT1BLnNsaWNlKDEsLTEpKSxBPXkoQSl9fXMucHVzaCh7dHlwZToicHNldWRvIixuYW1lOkssZGF0YTpBfSl9ZWxzZSBpZihhLnRlc3QoaSkpe3ZhciBIPVAoKTsoIW58fCgibG93ZXJDYXNlVGFncyJpbiBuP24ubG93ZXJDYXNlVGFnczohbi54bWxNb2RlKSkmJihIPUgudG9Mb3dlckNhc2UoKSkscy5wdXNoKHt0eXBlOiJ0YWciLG5hbWU6SH0pfWVsc2UgcmV0dXJuIHMubGVuZ3RoJiZzW3MubGVuZ3RoLTFdLnR5cGU9PT0iZGVzY2VuZGFudCImJnMucG9wKCksbShyLHMpLGl9cmV0dXJuIG0ocixzKSxpfWZ1bmN0aW9uIG0ocixpKXtpZihyLmxlbmd0aD4wJiZpLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJFbXB0eSBzdWItc2VsZWN0b3IiKTtyLnB1c2goaSl9fSxmdW5jdGlvbihMLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciBhPXtlcXVhbHM6IiIsZWxlbWVudDoifiIsc3RhcnQ6Il4iLGVuZDoiJCIsYW55OiIqIixub3Q6IiEiLGh5cGhlbjoifCJ9O2Z1bmN0aW9uIG8odSl7cmV0dXJuIHUubWFwKHYpLmpvaW4oIiwgIil9ZS5kZWZhdWx0PW87ZnVuY3Rpb24gdih1KXtyZXR1cm4gdS5tYXAoVCkuam9pbigiIil9ZnVuY3Rpb24gVCh1KXtzd2l0Y2godS50eXBlKXtjYXNlImNoaWxkIjpyZXR1cm4iID4gIjtjYXNlInBhcmVudCI6cmV0dXJuIiA8ICI7Y2FzZSJzaWJsaW5nIjpyZXR1cm4iIH4gIjtjYXNlImFkamFjZW50IjpyZXR1cm4iICsgIjtjYXNlImRlc2NlbmRhbnQiOnJldHVybiIgIjtjYXNlInVuaXZlcnNhbCI6cmV0dXJuIioiO2Nhc2UidGFnIjpyZXR1cm4gdS5uYW1lO2Nhc2UicHNldWRvLWVsZW1lbnQiOnJldHVybiI6OiIrdS5uYW1lO2Nhc2UicHNldWRvIjpyZXR1cm4gdS5kYXRhPT09bnVsbD8iOiIrdS5uYW1lOnR5cGVvZiB1LmRhdGE9PSJzdHJpbmciPyI6Iit1Lm5hbWUrIigiK3UuZGF0YSsiKSI6IjoiK3UubmFtZSsiKCIrbyh1LmRhdGEpKyIpIjtjYXNlImF0dHJpYnV0ZSI6cmV0dXJuIHUuYWN0aW9uPT09ImV4aXN0cyI/IlsiK3UubmFtZSsiXSI6dS5uYW1lPT09ImlkIiYmdS5hY3Rpb249PT0iZXF1YWxzIiYmIXUuaWdub3JlQ2FzZT8iIyIrdS52YWx1ZTp1Lm5hbWU9PT0iY2xhc3MiJiZ1LmFjdGlvbj09PSJlbGVtZW50IiYmIXUuaWdub3JlQ2FzZT8iLiIrdS52YWx1ZToiWyIrdS5uYW1lK2FbdS5hY3Rpb25dKyI9JyIrdS52YWx1ZSsiJyIrKHUuaWdub3JlQ2FzZT8iaSI6IiIpKyJdIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5rbm93biB0eXBlIil9fWZ1bmN0aW9uIGQodSl7cmV0dXJuIHV9fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXY7dmFyIGE9dCgyNzkpLG89e19fcHJvdG9fXzpudWxsLGV4aXN0czoxMCxlcXVhbHM6OCxub3Q6NyxzdGFydDo2LGVuZDo2LGFueTo1LGh5cGhlbjo0LGVsZW1lbnQ6NH07ZnVuY3Rpb24gdihkKXtmb3IodmFyIHU9ZC5tYXAoVCksYz0xO2M8ZC5sZW5ndGg7YysrKXt2YXIgRT11W2NdO2lmKCEoRTwwKSlmb3IodmFyIGY9Yy0xO2Y+PTAmJkU8dVtmXTtmLS0pe3ZhciBnPWRbZisxXTtkW2YrMV09ZFtmXSxkW2ZdPWcsdVtmKzFdPXVbZl0sdVtmXT1FfX19ZnVuY3Rpb24gVChkKXt2YXIgdT1hW2QudHlwZV07aWYodT09PWEuYXR0cmlidXRlKXU9b1tkLmFjdGlvbl0sdT09PW8uZXF1YWxzJiZkLm5hbWU9PT0iaWQiJiYodT05KSxkLmlnbm9yZUNhc2UmJih1Pj49MSk7ZWxzZSBpZih1PT09YS5wc2V1ZG8paWYoIWQuZGF0YSl1PTM7ZWxzZSBpZihkLm5hbWU9PT0iaGFzInx8ZC5uYW1lPT09ImNvbnRhaW5zIil1PTA7ZWxzZSBpZihkLm5hbWU9PT0ibWF0Y2hlcyJ8fGQubmFtZT09PSJub3QiKXt1PTA7Zm9yKHZhciBjPTA7YzxkLmRhdGEubGVuZ3RoO2MrKylpZihkLmRhdGFbY10ubGVuZ3RoPT09MSl7dmFyIEU9VChkLmRhdGFbY11bMF0pO2lmKEU9PT0wKXt1PTA7YnJlYWt9RT51JiYodT1FKX1kLmRhdGEubGVuZ3RoPjEmJnU+MCYmKHUtPTEpfWVsc2UgdT0xO3JldHVybiB1fX0sZnVuY3Rpb24oTCl7TC5leHBvcnRzPUpTT04ucGFyc2UoJ3sidW5pdmVyc2FsIjo1MCwidGFnIjozMCwiYXR0cmlidXRlIjoxLCJwc2V1ZG8iOjAsImRlc2NlbmRhbnQiOi0xLCJjaGlsZCI6LTEsInBhcmVudCI6LTEsInNpYmxpbmciOi0xLCJhZGphY2VudCI6LTF9Jyl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDI4MSksbz10KDI4Mik7TC5leHBvcnRzPXtfX3Byb3RvX186bnVsbCxhdHRyaWJ1dGU6YS5jb21waWxlLHBzZXVkbzpvLmNvbXBpbGUsdGFnOmZ1bmN0aW9uKHYsVCxkKXt2YXIgdT1ULm5hbWUsYz1kLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiBjLmdldE5hbWUoZik9PT11JiZ2KGYpfX0sZGVzY2VuZGFudDpmdW5jdGlvbih2LFQsZCl7dmFyIHU9dHlwZW9mIFdlYWtTZXQ8InUiP25ldyBXZWFrU2V0Om51bGwsYz1kLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGYpe2Zvcih2YXIgZz0hMTshZyYmKGY9Yy5nZXRQYXJlbnQoZikpOykoIXV8fCF1LmhhcyhmKSkmJihnPXYoZiksIWcmJnUmJnUuYWRkKGYpKTtyZXR1cm4gZ319LF9mbGV4aWJsZURlc2NlbmRhbnQ6ZnVuY3Rpb24odixULGQpe3ZhciB1PWQuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oRSl7Zm9yKHZhciBmPXYoRSk7IWYmJihFPXUuZ2V0UGFyZW50KEUpKTspZj12KEUpO3JldHVybiBmfX0scGFyZW50OmZ1bmN0aW9uKHYsVCxkKXtpZihkJiZkLnN0cmljdCl0aHJvdyBuZXcgRXJyb3IoIlBhcmVudCBzZWxlY3RvciBpc24ndCBwYXJ0IG9mIENTUzMiKTt2YXIgdT1kLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiB1LmdldENoaWxkcmVuKGYpLnNvbWUoYyl9O2Z1bmN0aW9uIGMoRSl7cmV0dXJuIHUuaXNUYWcoRSkmJnYoRSl9fSxjaGlsZDpmdW5jdGlvbih2LFQsZCl7dmFyIHU9ZC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihFKXt2YXIgZj11LmdldFBhcmVudChFKTtyZXR1cm4hIWYmJnYoZil9fSxzaWJsaW5nOmZ1bmN0aW9uKHYsVCxkKXt2YXIgdT1kLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKEUpe2Zvcih2YXIgZj11LmdldFNpYmxpbmdzKEUpLGc9MDtnPGYubGVuZ3RoO2crKylpZih1LmlzVGFnKGZbZ10pKXtpZihmW2ddPT09RSlicmVhaztpZih2KGZbZ10pKXJldHVybiEwfXJldHVybiExfX0sYWRqYWNlbnQ6ZnVuY3Rpb24odixULGQpe3ZhciB1PWQuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oRSl7Zm9yKHZhciBmPXUuZ2V0U2libGluZ3MoRSksZyx5PTA7eTxmLmxlbmd0aDt5KyspaWYodS5pc1RhZyhmW3ldKSl7aWYoZlt5XT09PUUpYnJlYWs7Zz1mW3ldfXJldHVybiEhZyYmdihnKX19LHVuaXZlcnNhbDpmdW5jdGlvbih2KXtyZXR1cm4gdn19fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgyNzMpLmZhbHNlRnVuYyxvPS9bLVtcXXt9KCkqKz8uLFxcXiR8I1xzXS9nLHY9e19fcHJvdG9fXzpudWxsLGVxdWFsczpmdW5jdGlvbihULGQsdSl7dmFyIGM9ZC5uYW1lLEU9ZC52YWx1ZSxmPXUuYWRhcHRlcjtyZXR1cm4gZC5pZ25vcmVDYXNlPyhFPUUudG9Mb3dlckNhc2UoKSxmdW5jdGlvbih5KXt2YXIgQz1mLmdldEF0dHJpYnV0ZVZhbHVlKHksYyk7cmV0dXJuIEMhPW51bGwmJkMudG9Mb3dlckNhc2UoKT09PUUmJlQoeSl9KTpmdW5jdGlvbih5KXtyZXR1cm4gZi5nZXRBdHRyaWJ1dGVWYWx1ZSh5LGMpPT09RSYmVCh5KX19LGh5cGhlbjpmdW5jdGlvbihULGQsdSl7dmFyIGM9ZC5uYW1lLEU9ZC52YWx1ZSxmPUUubGVuZ3RoLGc9dS5hZGFwdGVyO3JldHVybiBkLmlnbm9yZUNhc2U/KEU9RS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKEMpe3ZhciB4PWcuZ2V0QXR0cmlidXRlVmFsdWUoQyxjKTtyZXR1cm4geCE9bnVsbCYmKHgubGVuZ3RoPT09Znx8eC5jaGFyQXQoZik9PT0iLSIpJiZ4LnN1YnN0cigwLGYpLnRvTG93ZXJDYXNlKCk9PT1FJiZUKEMpfSk6ZnVuY3Rpb24oQyl7dmFyIHg9Zy5nZXRBdHRyaWJ1dGVWYWx1ZShDLGMpO3JldHVybiB4IT1udWxsJiZ4LnN1YnN0cigwLGYpPT09RSYmKHgubGVuZ3RoPT09Znx8eC5jaGFyQXQoZik9PT0iLSIpJiZUKEMpfX0sZWxlbWVudDpmdW5jdGlvbihULGQsdSl7dmFyIGM9ZC5uYW1lLEU9ZC52YWx1ZSxmPXUuYWRhcHRlcjtpZigvXHMvLnRlc3QoRSkpcmV0dXJuIGE7RT1FLnJlcGxhY2UobywiXFwkJiIpO3ZhciBnPSIoPzpefFxccykiK0UrIig/OiR8XFxzKSIseT1kLmlnbm9yZUNhc2U/ImkiOiIiLEM9bmV3IFJlZ0V4cChnLHkpO3JldHVybiBmdW5jdGlvbihoKXt2YXIgbT1mLmdldEF0dHJpYnV0ZVZhbHVlKGgsYyk7cmV0dXJuIG0hPW51bGwmJkMudGVzdChtKSYmVChoKX19LGV4aXN0czpmdW5jdGlvbihULGQsdSl7dmFyIGM9ZC5uYW1lLEU9dS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihnKXtyZXR1cm4gRS5oYXNBdHRyaWIoZyxjKSYmVChnKX19LHN0YXJ0OmZ1bmN0aW9uKFQsZCx1KXt2YXIgYz1kLm5hbWUsRT1kLnZhbHVlLGY9RS5sZW5ndGgsZz11LmFkYXB0ZXI7cmV0dXJuIGY9PT0wP2E6ZC5pZ25vcmVDYXNlPyhFPUUudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihDKXt2YXIgeD1nLmdldEF0dHJpYnV0ZVZhbHVlKEMsYyk7cmV0dXJuIHghPW51bGwmJnguc3Vic3RyKDAsZikudG9Mb3dlckNhc2UoKT09PUUmJlQoQyl9KTpmdW5jdGlvbihDKXt2YXIgeD1nLmdldEF0dHJpYnV0ZVZhbHVlKEMsYyk7cmV0dXJuIHghPW51bGwmJnguc3Vic3RyKDAsZik9PT1FJiZUKEMpfX0sZW5kOmZ1bmN0aW9uKFQsZCx1KXt2YXIgYz1kLm5hbWUsRT1kLnZhbHVlLGY9LUUubGVuZ3RoLGc9dS5hZGFwdGVyO3JldHVybiBmPT09MD9hOmQuaWdub3JlQ2FzZT8oRT1FLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oQyl7dmFyIHg9Zy5nZXRBdHRyaWJ1dGVWYWx1ZShDLGMpO3JldHVybiB4IT1udWxsJiZ4LnN1YnN0cihmKS50b0xvd2VyQ2FzZSgpPT09RSYmVChDKX0pOmZ1bmN0aW9uKEMpe3ZhciB4PWcuZ2V0QXR0cmlidXRlVmFsdWUoQyxjKTtyZXR1cm4geCE9bnVsbCYmeC5zdWJzdHIoZik9PT1FJiZUKEMpfX0sYW55OmZ1bmN0aW9uKFQsZCx1KXt2YXIgYz1kLm5hbWUsRT1kLnZhbHVlLGY9dS5hZGFwdGVyO2lmKEU9PT0iIilyZXR1cm4gYTtpZihkLmlnbm9yZUNhc2Upe3ZhciBnPW5ldyBSZWdFeHAoRS5yZXBsYWNlKG8sIlxcJCYiKSwiaSIpO3JldHVybiBmdW5jdGlvbihDKXt2YXIgeD1mLmdldEF0dHJpYnV0ZVZhbHVlKEMsYyk7cmV0dXJuIHghPW51bGwmJmcudGVzdCh4KSYmVChDKX19cmV0dXJuIGZ1bmN0aW9uKEMpe3ZhciB4PWYuZ2V0QXR0cmlidXRlVmFsdWUoQyxjKTtyZXR1cm4geCE9bnVsbCYmeC5pbmRleE9mKEUpPj0wJiZUKEMpfX0sbm90OmZ1bmN0aW9uKFQsZCx1KXt2YXIgYz1kLm5hbWUsRT1kLnZhbHVlLGY9dS5hZGFwdGVyO3JldHVybiBFPT09IiI/ZnVuY3Rpb24oeSl7cmV0dXJuISFmLmdldEF0dHJpYnV0ZVZhbHVlKHksYykmJlQoeSl9OmQuaWdub3JlQ2FzZT8oRT1FLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oeSl7dmFyIEM9Zi5nZXRBdHRyaWJ1dGVWYWx1ZSh5LGMpO3JldHVybiBDIT1udWxsJiZDLnRvTG93ZXJDYXNlKCkhPT1FJiZUKHkpfSk6ZnVuY3Rpb24oeSl7cmV0dXJuIGYuZ2V0QXR0cmlidXRlVmFsdWUoeSxjKSE9PUUmJlQoeSl9fX07TC5leHBvcnRzPXtjb21waWxlOmZ1bmN0aW9uKFQsZCx1KXtpZih1JiZ1LnN0cmljdCYmKGQuaWdub3JlQ2FzZXx8ZC5hY3Rpb249PT0ibm90IikpdGhyb3cgbmV3IEVycm9yKCJVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgc2VsZWN0b3IiKTtyZXR1cm4gdltkLmFjdGlvbl0oVCxkLHUpfSxydWxlczp2fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMjgzKSxvPXQoMjczKSx2PXQoMjgxKSxUPW8udHJ1ZUZ1bmMsZD1vLmZhbHNlRnVuYyx1PXYucnVsZXMuZXF1YWxzO2Z1bmN0aW9uIGMobSxyKXt2YXIgaT17bmFtZTptLHZhbHVlOnJ9O3JldHVybiBmdW5jdGlvbihzLE0sUCl7cmV0dXJuIHUocyxpLFApfX1mdW5jdGlvbiBFKG0scil7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiEhci5nZXRQYXJlbnQoaSkmJm0oaSl9fXZhciBmPXtjb250YWluczpmdW5jdGlvbihtLHIsaSl7dmFyIG49aS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihNKXtyZXR1cm4gbShNKSYmbi5nZXRUZXh0KE0pLmluZGV4T2Yocik+PTB9fSxpY29udGFpbnM6ZnVuY3Rpb24obSxyLGkpe3ZhciBuPXIudG9Mb3dlckNhc2UoKSxzPWkuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oUCl7cmV0dXJuIG0oUCkmJnMuZ2V0VGV4dChQKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yobik+PTB9fSwibnRoLWNoaWxkIjpmdW5jdGlvbihtLHIsaSl7dmFyIG49YShyKSxzPWkuYWRhcHRlcjtyZXR1cm4gbj09PWQ/bjpuPT09VD9FKG0scyk6ZnVuY3Rpb24oUCl7Zm9yKHZhciBTPXMuZ2V0U2libGluZ3MoUCksYj0wLE89MDtiPFMubGVuZ3RoO2IrKylpZihzLmlzVGFnKFNbYl0pKXtpZihTW2JdPT09UClicmVhaztPKyt9cmV0dXJuIG4oTykmJm0oUCl9fSwibnRoLWxhc3QtY2hpbGQiOmZ1bmN0aW9uKG0scixpKXt2YXIgbj1hKHIpLHM9aS5hZGFwdGVyO3JldHVybiBuPT09ZD9uOm49PT1UP0UobSxzKTpmdW5jdGlvbihQKXtmb3IodmFyIFM9cy5nZXRTaWJsaW5ncyhQKSxiPTAsTz1TLmxlbmd0aC0xO08+PTA7Ty0tKWlmKHMuaXNUYWcoU1tPXSkpe2lmKFNbT109PT1QKWJyZWFrO2IrK31yZXR1cm4gbihiKSYmbShQKX19LCJudGgtb2YtdHlwZSI6ZnVuY3Rpb24obSxyLGkpe3ZhciBuPWEocikscz1pLmFkYXB0ZXI7cmV0dXJuIG49PT1kP246bj09PVQ/RShtLHMpOmZ1bmN0aW9uKFApe2Zvcih2YXIgUz1zLmdldFNpYmxpbmdzKFApLGI9MCxPPTA7TzxTLmxlbmd0aDtPKyspaWYocy5pc1RhZyhTW09dKSl7aWYoU1tPXT09PVApYnJlYWs7cy5nZXROYW1lKFNbT10pPT09cy5nZXROYW1lKFApJiZiKyt9cmV0dXJuIG4oYikmJm0oUCl9fSwibnRoLWxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24obSxyLGkpe3ZhciBuPWEocikscz1pLmFkYXB0ZXI7cmV0dXJuIG49PT1kP246bj09PVQ/RShtLHMpOmZ1bmN0aW9uKFApe2Zvcih2YXIgUz1zLmdldFNpYmxpbmdzKFApLGI9MCxPPVMubGVuZ3RoLTE7Tz49MDtPLS0paWYocy5pc1RhZyhTW09dKSl7aWYoU1tPXT09PVApYnJlYWs7cy5nZXROYW1lKFNbT10pPT09cy5nZXROYW1lKFApJiZiKyt9cmV0dXJuIG4oYikmJm0oUCl9fSxyb290OmZ1bmN0aW9uKG0scixpKXt2YXIgbj1pLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHMpe3JldHVybiFuLmdldFBhcmVudChzKSYmbShzKX19LHNjb3BlOmZ1bmN0aW9uKG0scixpLG4pe3ZhciBzPWkuYWRhcHRlcjtpZighbnx8bi5sZW5ndGg9PT0wKXJldHVybiBmLnJvb3QobSxyLGkpO2Z1bmN0aW9uIE0oUCxTKXtyZXR1cm4gdHlwZW9mIHMuZXF1YWxzPT0iZnVuY3Rpb24iP3MuZXF1YWxzKFAsUyk6UD09PVN9cmV0dXJuIG4ubGVuZ3RoPT09MT9mdW5jdGlvbihQKXtyZXR1cm4gTShuWzBdLFApJiZtKFApfTpmdW5jdGlvbihQKXtyZXR1cm4gbi5pbmRleE9mKFApPj0wJiZtKFApfX0sY2hlY2tib3g6YygidHlwZSIsImNoZWNrYm94IiksZmlsZTpjKCJ0eXBlIiwiZmlsZSIpLHBhc3N3b3JkOmMoInR5cGUiLCJwYXNzd29yZCIpLHJhZGlvOmMoInR5cGUiLCJyYWRpbyIpLHJlc2V0OmMoInR5cGUiLCJyZXNldCIpLGltYWdlOmMoInR5cGUiLCJpbWFnZSIpLHN1Ym1pdDpjKCJ0eXBlIiwic3VibWl0IiksaG92ZXI6ZnVuY3Rpb24obSxyLGkpe3ZhciBuPWkuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIG4uaXNIb3ZlcmVkPT0iZnVuY3Rpb24iP2Z1bmN0aW9uKE0pe3JldHVybiBtKE0pJiZuLmlzSG92ZXJlZChNKX06ZH0sdmlzaXRlZDpmdW5jdGlvbihtLHIsaSl7dmFyIG49aS5hZGFwdGVyO3JldHVybiB0eXBlb2Ygbi5pc1Zpc2l0ZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oTSl7cmV0dXJuIG0oTSkmJm4uaXNWaXNpdGVkKE0pfTpkfSxhY3RpdmU6ZnVuY3Rpb24obSxyLGkpe3ZhciBuPWkuYWRhcHRlcjtyZXR1cm4gdHlwZW9mIG4uaXNBY3RpdmU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oTSl7cmV0dXJuIG0oTSkmJm4uaXNBY3RpdmUoTSl9OmR9fTtmdW5jdGlvbiBnKG0scil7Zm9yKHZhciBpPTA7bSYmaTxtLmxlbmd0aDtpKyspaWYoci5pc1RhZyhtW2ldKSlyZXR1cm4gbVtpXX12YXIgeT17ZW1wdHk6ZnVuY3Rpb24obSxyKXtyZXR1cm4hci5nZXRDaGlsZHJlbihtKS5zb21lKGZ1bmN0aW9uKGkpe3JldHVybiByLmlzVGFnKGkpfHxpLnR5cGU9PT0idGV4dCJ9KX0sImZpcnN0LWNoaWxkIjpmdW5jdGlvbihtLHIpe3JldHVybiBnKHIuZ2V0U2libGluZ3MobSkscik9PT1tfSwibGFzdC1jaGlsZCI6ZnVuY3Rpb24obSxyKXtmb3IodmFyIGk9ci5nZXRTaWJsaW5ncyhtKSxuPWkubGVuZ3RoLTE7bj49MDtuLS0pe2lmKGlbbl09PT1tKXJldHVybiEwO2lmKHIuaXNUYWcoaVtuXSkpYnJlYWt9cmV0dXJuITF9LCJmaXJzdC1vZi10eXBlIjpmdW5jdGlvbihtLHIpe2Zvcih2YXIgaT1yLmdldFNpYmxpbmdzKG0pLG49MDtuPGkubGVuZ3RoO24rKylpZihyLmlzVGFnKGlbbl0pKXtpZihpW25dPT09bSlyZXR1cm4hMDtpZihyLmdldE5hbWUoaVtuXSk9PT1yLmdldE5hbWUobSkpYnJlYWt9cmV0dXJuITF9LCJsYXN0LW9mLXR5cGUiOmZ1bmN0aW9uKG0scil7Zm9yKHZhciBpPXIuZ2V0U2libGluZ3MobSksbj1pLmxlbmd0aC0xO24+PTA7bi0tKWlmKHIuaXNUYWcoaVtuXSkpe2lmKGlbbl09PT1tKXJldHVybiEwO2lmKHIuZ2V0TmFtZShpW25dKT09PXIuZ2V0TmFtZShtKSlicmVha31yZXR1cm4hMX0sIm9ubHktb2YtdHlwZSI6ZnVuY3Rpb24obSxyKXtmb3IodmFyIGk9ci5nZXRTaWJsaW5ncyhtKSxuPTAscz1pLmxlbmd0aDtuPHM7bisrKWlmKHIuaXNUYWcoaVtuXSkpe2lmKGlbbl09PT1tKWNvbnRpbnVlO2lmKHIuZ2V0TmFtZShpW25dKT09PXIuZ2V0TmFtZShtKSlyZXR1cm4hMX1yZXR1cm4hMH0sIm9ubHktY2hpbGQiOmZ1bmN0aW9uKG0scil7Zm9yKHZhciBpPXIuZ2V0U2libGluZ3MobSksbj0wO248aS5sZW5ndGg7bisrKWlmKHIuaXNUYWcoaVtuXSkmJmlbbl0hPT1tKXJldHVybiExO3JldHVybiEwfSxsaW5rOmZ1bmN0aW9uKG0scil7cmV0dXJuIHIuaGFzQXR0cmliKG0sImhyZWYiKX0sc2VsZWN0ZWQ6ZnVuY3Rpb24obSxyKXtpZihyLmhhc0F0dHJpYihtLCJzZWxlY3RlZCIpKXJldHVybiEwO2lmKHIuZ2V0TmFtZShtKSE9PSJvcHRpb24iKXJldHVybiExO3ZhciBpPXIuZ2V0UGFyZW50KG0pO2lmKCFpfHxyLmdldE5hbWUoaSkhPT0ic2VsZWN0Inx8ci5oYXNBdHRyaWIoaSwibXVsdGlwbGUiKSlyZXR1cm4hMTtmb3IodmFyIG49ci5nZXRDaGlsZHJlbihpKSxzPSExLE09MDtNPG4ubGVuZ3RoO00rKylpZihyLmlzVGFnKG5bTV0pKWlmKG5bTV09PT1tKXM9ITA7ZWxzZSBpZihzKXtpZihyLmhhc0F0dHJpYihuW01dLCJzZWxlY3RlZCIpKXJldHVybiExfWVsc2UgcmV0dXJuITE7cmV0dXJuIHN9LGRpc2FibGVkOmZ1bmN0aW9uKG0scil7cmV0dXJuIHIuaGFzQXR0cmliKG0sImRpc2FibGVkIil9LGVuYWJsZWQ6ZnVuY3Rpb24obSxyKXtyZXR1cm4hci5oYXNBdHRyaWIobSwiZGlzYWJsZWQiKX0sY2hlY2tlZDpmdW5jdGlvbihtLHIpe3JldHVybiByLmhhc0F0dHJpYihtLCJjaGVja2VkIil8fHkuc2VsZWN0ZWQobSxyKX0scmVxdWlyZWQ6ZnVuY3Rpb24obSxyKXtyZXR1cm4gci5oYXNBdHRyaWIobSwicmVxdWlyZWQiKX0sb3B0aW9uYWw6ZnVuY3Rpb24obSxyKXtyZXR1cm4hci5oYXNBdHRyaWIobSwicmVxdWlyZWQiKX0scGFyZW50OmZ1bmN0aW9uKG0scil7cmV0dXJuIXkuZW1wdHkobSxyKX0saGVhZGVyOkMoWyJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiXSksYnV0dG9uOmZ1bmN0aW9uKG0scil7dmFyIGk9ci5nZXROYW1lKG0pO3JldHVybiBpPT09ImJ1dHRvbiJ8fGk9PT0iaW5wdXQiJiZyLmdldEF0dHJpYnV0ZVZhbHVlKG0sInR5cGUiKT09PSJidXR0b24ifSxpbnB1dDpDKFsiaW5wdXQiLCJ0ZXh0YXJlYSIsInNlbGVjdCIsImJ1dHRvbiJdKSx0ZXh0OmZ1bmN0aW9uKG0scil7dmFyIGk7cmV0dXJuIHIuZ2V0TmFtZShtKT09PSJpbnB1dCImJighKGk9ci5nZXRBdHRyaWJ1dGVWYWx1ZShtLCJ0eXBlIikpfHxpLnRvTG93ZXJDYXNlKCk9PT0idGV4dCIpfX07ZnVuY3Rpb24gQyhtKXtpZih0eXBlb2YgU2V0PCJ1Iil7dmFyIHI9bmV3IFNldChtKTtyZXR1cm4gZnVuY3Rpb24oaSxuKXtyZXR1cm4gci5oYXMobi5nZXROYW1lKGkpKX19cmV0dXJuIGZ1bmN0aW9uKGksbil7cmV0dXJuIG0uaW5kZXhPZihuLmdldE5hbWUoaSkpPj0wfX1mdW5jdGlvbiB4KG0scixpKXtpZihpPT09bnVsbCl7aWYobS5sZW5ndGg+MiYmciE9PSJzY29wZSIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIrcisiIHJlcXVpcmVzIGFuIGFyZ3VtZW50Iil9ZWxzZSBpZihtLmxlbmd0aD09PTIpdGhyb3cgbmV3IEVycm9yKCJwc2V1ZG8tc2VsZWN0b3IgOiIrcisiIGRvZXNuJ3QgaGF2ZSBhbnkgYXJndW1lbnRzIil9dmFyIGg9L14oPzooPzpudGh8bGFzdHxmaXJzdHxvbmx5KS0oPzpjaGlsZHxvZi10eXBlKXxyb290fGVtcHR5fCg/OmVufGRpcylhYmxlZHxjaGVja2VkfG5vdCkkLztMLmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24obSxyLGksbil7dmFyIHM9ci5uYW1lLE09ci5kYXRhLFA9aS5hZGFwdGVyO2lmKGkmJmkuc3RyaWN0JiYhaC50ZXN0KHMpKXRocm93IG5ldyBFcnJvcigiOiIrcysiIGlzbid0IHBhcnQgb2YgQ1NTMyIpO2lmKHR5cGVvZiBmW3NdPT0iZnVuY3Rpb24iKXJldHVybiBmW3NdKG0sTSxpLG4pO2lmKHR5cGVvZiB5W3NdPT0iZnVuY3Rpb24iKXt2YXIgUz15W3NdO3JldHVybiB4KFMscyxNKSxTPT09ZD9TOm09PT1UP2Z1bmN0aW9uKE8pe3JldHVybiBTKE8sUCxNKX06ZnVuY3Rpb24oTyl7cmV0dXJuIFMoTyxQLE0pJiZtKE8pfX1lbHNlIHRocm93IG5ldyBFcnJvcigidW5tYXRjaGVkIHBzZXVkby1jbGFzcyA6IitzKX0sZmlsdGVyczpmLHBzZXVkb3M6eX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDI4NCksbz10KDI4NSk7TC5leHBvcnRzPWZ1bmN0aW9uKFQpe3JldHVybiBvKGEoVCkpfSxMLmV4cG9ydHMucGFyc2U9YSxMLmV4cG9ydHMuY29tcGlsZT1vfSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1hO3ZhciB0PS9eKFsrXC1dP1xkKm4pP1xzKig/OihbK1wtXT8pXHMqKFxkKykpPyQvO2Z1bmN0aW9uIGEobyl7aWYobz1vLnRyaW0oKS50b0xvd2VyQ2FzZSgpLG89PT0iZXZlbiIpcmV0dXJuWzIsMF07aWYobz09PSJvZGQiKXJldHVyblsyLDFdO3ZhciB2PW8ubWF0Y2godCk7aWYoIXYpdGhyb3cgbmV3IFN5bnRheEVycm9yKCJuLXRoIHJ1bGUgY291bGRuJ3QgYmUgcGFyc2VkICgnIitvKyInKSIpO3ZhciBUO3JldHVybiB2WzFdPyhUPXBhcnNlSW50KHZbMV0sMTApLGlzTmFOKFQpJiYodlsxXS5jaGFyQXQoMCk9PT0iLSI/VD0tMTpUPTEpKTpUPTAsW1QsdlszXT9wYXJzZUludCgodlsyXXx8IiIpK3ZbM10sMTApOjBdfX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz1UO3ZhciBhPXQoMjczKSxvPWEudHJ1ZUZ1bmMsdj1hLmZhbHNlRnVuYztmdW5jdGlvbiBUKGQpe3ZhciB1PWRbMF0sYz1kWzFdLTE7aWYoYzwwJiZ1PD0wKXJldHVybiB2O2lmKHU9PT0tMSlyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIGY8PWN9O2lmKHU9PT0wKXJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gZj09PWN9O2lmKHU9PT0xKXJldHVybiBjPDA/bzpmdW5jdGlvbihmKXtyZXR1cm4gZj49Y307dmFyIEU9YyV1O3JldHVybiBFPDAmJihFKz11KSx1PjE/ZnVuY3Rpb24oZil7cmV0dXJuIGY+PWMmJmYldT09PUV9Oih1Kj0tMSxmdW5jdGlvbihmKXtyZXR1cm4gZjw9YyYmZiV1PT09RX0pfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pO3ZhciBhPXQoMTIpLG89dCg3NCksdj10KDEpLFQ9dCg2OCksZD10KDI1MCksdT10KDIxMyksYz10KDIxOCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIEUoUCxTKXtpZihQPT1udWxsKXJldHVybnt9O3ZhciBiPWYoUCxTKSxPLEQ7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIEk9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhQKTtmb3IoRD0wO0Q8SS5sZW5ndGg7RCsrKU89SVtEXSwhKFMuaW5kZXhPZihPKT49MCkmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChQLE8pJiYoYltPXT1QW09dKX1yZXR1cm4gYn1mdW5jdGlvbiBmKFAsUyl7aWYoUD09bnVsbClyZXR1cm57fTt2YXIgYj17fSxPPU9iamVjdC5rZXlzKFApLEQsSTtmb3IoST0wO0k8Ty5sZW5ndGg7SSsrKUQ9T1tJXSwhKFMuaW5kZXhPZihEKT49MCkmJihiW0RdPVBbRF0pO3JldHVybiBifWNvbnN0IGc9e2FudGlhbGlhczohMCxhdXRvUmVuZGVyOiEwLGFscGhhOiEwfSx5PVN5bWJvbCgiYXV0b1JlbmRlciIpLEM9U3ltYm9sKCJyZW5kZXJlciIpLHg9U3ltYm9sKCJ0aW1lbGluZSIpLGg9U3ltYm9sKCJwcmVwYXJlUmVuZGVyIiksbT1TeW1ib2woInRpY2tSZW5kZXIiKSxyPVN5bWJvbCgicGFzcyIpLGk9U3ltYm9sKCJmYm8iKSxuPVN5bWJvbCgidGlja2VycyIpLHM9U3ltYm9sKCJsYXllclRyYW5zZm9ybUludmVydCIpO2NsYXNzIE0gZXh0ZW5kcyBkLmRlZmF1bHR7Y29uc3RydWN0b3IoUz17fSl7aWYoc3VwZXIoKSwhUy5jYW52YXMpe2NvbnN0e3dpZHRoOkksaGVpZ2h0OlJ9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEE9YS5FTlYuY3JlYXRlQ2FudmFzKEksUix7b2Zmc2NyZWVuOiEhUy5vZmZzY3JlZW4saWQ6Uy5pZCxleHRyYTpTLmV4dHJhfSk7QS5zdHlsZSYmKEEuc3R5bGUucG9zaXRpb249ImFic29sdXRlIiksQS5kYXRhc2V0JiYoQS5kYXRhc2V0LmxheWVySWQ9Uy5pZCksQS5jb250ZXh0VHlwZSYmKFMuY29udGV4dFR5cGU9QS5jb250ZXh0VHlwZSksUy5jYW52YXM9QX1jb25zdCBiPVMuY2FudmFzLE89T2JqZWN0LmFzc2lnbih7fSxnLFMpO3RoaXNbeV09Ty5hdXRvUmVuZGVyLGRlbGV0ZSBTLmF1dG9SZW5kZXI7Y29uc3QgRD1PLlJlbmRlcmVyfHxhLlJlbmRlcmVyO3RoaXNbQ109bmV3IEQoYixPKSx0aGlzLm9wdGlvbnM9Uyx0aGlzLmlkPVMuaWQsdGhpc1tyXT1bXSx0aGlzLnNldFJlc29sdXRpb24oYiksdGhpcy5jYW52YXM9Yix0aGlzW3hdPW5ldyBvLlRpbWVsaW5lLHRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGwsdGhpc1tzXT1udWxsfWdldCBhdXRvUmVuZGVyKCl7cmV0dXJuIHRoaXNbeV19Z2V0IGRpc3BsYXlSYXRpbygpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucz90aGlzLnBhcmVudC5vcHRpb25zLmRpc3BsYXlSYXRpbzoxfWdldCBoZWlnaHQoKXtjb25zdHtoZWlnaHQ6U309dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIFMvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGdsKCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcj90aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIuZ2w6bnVsbH1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpc31nZXQgb2Zmc2NyZWVuKCl7cmV0dXJuISF0aGlzLm9wdGlvbnMub2Zmc2NyZWVufHx0aGlzLmNhbnZhcy5fb2Zmc2NyZWVufWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbcl19Z2V0IHByZXBhcmVSZW5kZXIoKXtyZXR1cm4gdGhpc1toXT90aGlzW2hdOlByb21pc2UucmVzb2x2ZSgpfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzW0NdfWdldCByZW5kZXJPZmZzZXQoKXtpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQub3B0aW9ucyl7Y29uc3R7bGVmdDpTLHRvcDpifT10aGlzLnBhcmVudC5vcHRpb25zO3JldHVybltTLGJdfXJldHVyblt0aGlzLm9wdGlvbnMubGVmdHwwLHRoaXMub3B0aW9ucy50b3B8MF19Z2V0IHRpbWVsaW5lKCl7cmV0dXJuIHRoaXNbeF19Z2V0IHdpZHRoKCl7Y29uc3R7d2lkdGg6U309dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIFMvdGhpcy5kaXNwbGF5UmF0aW99Z2V0IGxvY2FsTWF0cml4KCl7Y29uc3R7eDpTLHk6Yn09dGhpcy5hdHRyaWJ1dGVzO3JldHVyblsxLDAsMCwxLFMsYl19Z2V0IGxheWVyVHJhbnNmb3JtSW52ZXJ0KCl7aWYodGhpc1tzXSlyZXR1cm4gdGhpc1tzXTtjb25zdCBTPXRoaXMudHJhbnNmb3JtTWF0cml4O3JldHVybiBTWzBdPT09MSYmU1sxXT09PTAmJlNbMl09PT0wJiZTWzNdPT09MSYmU1s0XT09PTAmJlNbNV09PT0wP251bGw6KHRoaXNbc109di5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLFMpLHRoaXNbc10pfWZvcmNlQ29udGV4dExvc3MoKXtjb25zdCBTPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcjtpZihTKXtjb25zdCBiPVMuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9sb3NlX2NvbnRleHQiKTtpZihiKXJldHVybiBiLmxvc2VDb250ZXh0KCksITB9cmV0dXJuITF9YWRkUGFzcyh7dmVydGV4OlMsZnJhZ21lbnQ6YixvcHRpb25zOk8sdW5pZm9ybXM6RH09e30pe2lmKHRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcil7Y29uc3R7d2lkdGg6SSxoZWlnaHQ6Un09dGhpcy5nZXRSZXNvbHV0aW9uKCksQT10aGlzLnJlbmRlcmVyLmNyZWF0ZVBhc3NQcm9ncmFtKHt2ZXJ0ZXg6UyxmcmFnbWVudDpiLG9wdGlvbnM6T30pLFU9bmV3IGEuRmlndXJlMkQ7VS5yZWN0KDAsMCxJL3RoaXMuZGlzcGxheVJhdGlvLFIvdGhpcy5kaXNwbGF5UmF0aW8pO2NvbnN0IEs9bmV3IGEuTWVzaDJEKFUpO3JldHVybiBLLnNldFVuaWZvcm1zKEQpLEsuc2V0UHJvZ3JhbShBKSx0aGlzW3JdLnB1c2goSyksdGhpcy5mb3JjZVVwZGF0ZSgpLEt9cmV0dXJuIG51bGx9ZGVsZXRlVGV4dHVyZShTKXtyZXR1cm4gT2JqZWN0KGMuZGVsZXRlVGV4dHVyZSkoUyx0aGlzLnJlbmRlcmVyKX1kaXNwYXRjaFBvaW50ZXJFdmVudChTKXtjb25zdCBiPVMudHlwZTtpZihiPT09Im1vdXNlZG93biJ8fGI9PT0ibW91c2V1cCJ8fGI9PT0ibW91c2Vtb3ZlIil7Y29uc3QgQT10aGlzLl9fbW91c2VDYXB0dXJlZFRhcmdldDtpZihBKXtpZihBLmxheWVyPT09dGhpcylyZXR1cm4gQS5kaXNwYXRjaEV2ZW50KFMpLCEwO3RoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PW51bGx9fWxldCBPLEQ7Y29uc3QgST10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O2lmKEkpe089Uy54LEQ9Uy55O2NvbnN0IEE9SSxVPUFbMF0qTytBWzJdKkQrQVs0XSxLPUFbMV0qTytBWzNdKkQrQVs1XTtkZWxldGUgUy54LGRlbGV0ZSBTLnksZGVsZXRlIFMubGF5ZXJYLGRlbGV0ZSBTLmxheWVyWSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTLHtsYXllclg6e3ZhbHVlOlUsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOkssY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpVLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6Syxjb25maWd1cmFibGU6ITB9fSl9Y29uc3QgUj1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChTKTtyZXR1cm4gSSYmT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUyx7bGF5ZXJYOnt2YWx1ZTpPLGNvbmZpZ3VyYWJsZTohMH0sbGF5ZXJZOnt2YWx1ZTpELGNvbmZpZ3VyYWJsZTohMH0seDp7dmFsdWU6Tyxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOkQsY29uZmlndXJhYmxlOiEwfX0pLFJ9Zm9yY2VVcGRhdGUoKXtpZighdGhpc1toXSlpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuaGFzT2Zmc2NyZWVuQ2FudmFzKXt0aGlzLnBhcmVudC5mb3JjZVVwZGF0ZSgpO2xldCBTPW51bGw7Y29uc3QgYj1uZXcgUHJvbWlzZShPPT57Uz1PfSk7Yi5fcmVzb2x2ZT1TLHRoaXNbaF09Yn1lbHNle2xldCBTPW51bGwsYj1udWxsO2NvbnN0IE89bmV3IFByb21pc2UoRD0+e1M9RCx0aGlzW3ldJiYoYj1PYmplY3QoVC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIE8uX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfSk7Ty5fcmVzb2x2ZT1TLE8uX3JlcXVlc3RJRD1iLHRoaXNbaF09T319Z2V0RkJPKCl7Y29uc3QgUz10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIse3dpZHRoOmIsaGVpZ2h0Ok99PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3JldHVybiBTJiYoIXRoaXNbaV18fHRoaXNbaV0ud2lkdGghPT1ifHx0aGlzW2ldLmhlaWdodCE9PU8pPyh0aGlzW2ldPXt3aWR0aDpiLGhlaWdodDpPLHRhcmdldDpTLmNyZWF0ZUZCTygpLGJ1ZmZlcjpTLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSx0aGlzW2ldKTp0aGlzW2ldP3RoaXNbaV06bnVsbH11cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBTPXRoaXMucmVuZGVyZXIsYj1TLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxTLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtTLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PWI7Y29uc3QgTz12Lm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApO1Muc2V0R2xvYmFsVHJhbnNmb3JtKC4uLnYubWF0MmQubXVsdGlwbHkoTyxiLHRoaXMudHJhbnNmb3JtTWF0cml4KSl9fW9uUHJvcGVydHlDaGFuZ2UoUyxiLE8pe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoUyxiLE8pLFM9PT0iekluZGV4IiYmKHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleD1iKSxTPT09InRyYW5zZm9ybSJ8fFM9PT0idHJhbnNsYXRlInx8Uz09PSJyb3RhdGUifHxTPT09InNjYWxlInx8Uz09PSJza2V3Iil7Y29uc3QgRD10aGlzW3NdO2lmKHRoaXNbc109bnVsbCx0aGlzLnVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpLEQmJiF0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBJPXRoaXMucmVuZGVyZXIsUj1JLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxJLmdsb2JhbFRyYW5zZm9ybU1hdHJpeDtJLnNldEdsb2JhbFRyYW5zZm9ybSguLi5SKX19fV9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKXt0aGlzW2hdJiYodGhpc1toXS5fcmVxdWVzdElEJiZPYmplY3QoVC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1toXS5fcmVxdWVzdElEKSx0aGlzW2hdLl9yZXNvbHZlKCksZGVsZXRlIHRoaXNbaF0pfXJlbmRlcih7Y2xlYXI6Uz0hMH09e30pe2NvbnN0IGI9dGhpc1tyXS5sZW5ndGg/dGhpcy5nZXRGQk8oKTpudWxsO2ImJnRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5iaW5kRkJPKGIudGFyZ2V0KSxTJiZ0aGlzW0NdLmNsZWFyKCk7Y29uc3QgTz10aGlzLmRyYXcoKTtpZihPJiZPLmxlbmd0aCYmKHRoaXMucmVuZGVyZXIuZHJhd01lc2hlcyhPKSx0aGlzLmNhbnZhcy5kcmF3JiZ0aGlzLmNhbnZhcy5kcmF3KCkpLGIpe2NvbnN0IEQ9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLEk9dGhpc1tyXS5sZW5ndGgse3dpZHRoOlIsaGVpZ2h0OkF9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLFU9WzAsMCxSL3RoaXMuZGlzcGxheVJhdGlvLEEvdGhpcy5kaXNwbGF5UmF0aW9dO3RoaXNbcl0uZm9yRWFjaCgoSyxWKT0+e0suYmxlbmQ9ITAsSy5zZXRUZXh0dXJlKGIudGFyZ2V0LnRleHR1cmUse3JlY3Q6VX0pLFY9PT1JLTE/RC5iaW5kRkJPKG51bGwpOihiLnN3YXAoKSxELmJpbmRGQk8oYi50YXJnZXQpKSx0aGlzW0NdLmNsZWFyKCksdGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKFtLXSl9KX10aGlzLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpTLGhlaWdodDpifSl7Y29uc3QgTz10aGlzLnJlbmRlcmVyLEQ9Ty5fX2dsb2JhbFRyYW5zZm9ybU1hdHJpeHx8Ty5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgsST1EWzRdLFI9RFs1XSxBPURbMF0se3dpZHRoOlUsaGVpZ2h0Okt9PXRoaXMuZ2V0UmVzb2x1dGlvbigpOyhVIT09U3x8SyE9PWIpJiYoc3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6UyxoZWlnaHQ6Yn0pLHRoaXMuY2FudmFzJiYodGhpcy5jYW52YXMud2lkdGg9Uyx0aGlzLmNhbnZhcy5oZWlnaHQ9YixPLnVwZGF0ZVJlc29sdXRpb24mJk8udXBkYXRlUmVzb2x1dGlvbigpKSx0aGlzLmF0dHJpYnV0ZXMuc2l6ZT1bUyxiXSx0aGlzW3JdLmxlbmd0aCYmdGhpc1tyXS5mb3JFYWNoKFc9Pntjb25zdCBIPW5ldyBhLkZpZ3VyZTJEO0gucmVjdCgwLDAsUy90aGlzLmRpc3BsYXlSYXRpbyxiL3RoaXMuZGlzcGxheVJhdGlvKSxXLmNvbnRvdXJzPUguY29udG91cnN9KSk7Y29uc3RbVixRXT10aGlzLnJlbmRlck9mZnNldCxxPXRoaXMuZGlzcGxheVJhdGlvOyhJIT09Vnx8UiE9PVF8fEEhPT1xKSYmKE8uc2V0R2xvYmFsVHJhbnNmb3JtKHEsMCwwLHEsVixRKSxPLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4PW51bGwsdGhpc1tzXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksdGhpcy5mb3JjZVVwZGF0ZSgpKX10aWNrKFM9bnVsbCxiPXt9KXtsZXR7ZHVyYXRpb246Tz0xLzB9PWIsRD1FKGIsWyJkdXJhdGlvbiJdKTtjb25zdCBJPXRoaXMudGltZWxpbmUuZm9yayhEKSxSPXRoaXM7dGhpc1tuXT10aGlzW25dfHxbXSx0aGlzW25dLnB1c2goe2hhbmRsZXI6UyxkdXJhdGlvbjpPfSk7Y29uc3QgQT0oKT0+e2xldCBVPW51bGwsSz1udWxsO2NvbnN0IFY9KCk9Pntjb25zdCBRPXRoaXNbbl0ubWFwKCh7aGFuZGxlcjpxLGR1cmF0aW9uOld9KT0+e2NvbnN0IEg9TWF0aC5taW4oMSxJLmN1cnJlbnRUaW1lL1cpO3JldHVybnt2YWx1ZTpxP3EoSS5jdXJyZW50VGltZSxIKTpudWxsLHA6SH19KTtSW21dfHwoUlttXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57Ult5XSYmUi5yZW5kZXIoKSxkZWxldGUgUlttXTtmb3IobGV0IHE9US5sZW5ndGgtMTtxPj0wO3EtLSl7Y29uc3R7dmFsdWU6VyxwOkh9PVFbcV07KFc9PT0hMXx8SD49MSkmJnRoaXNbbl0uc3BsaWNlKHEsMSl9dGhpc1tuXS5sZW5ndGg+MCYmQSgpfSkpfTtpZih0aGlzW2hdJiZ0aGlzW2hdLl90eXBlIT09InRpY2tlciImJihPYmplY3QoVC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpc1toXS5fcmVxdWVzdElEKSxkZWxldGUgdGhpc1toXSksIXRoaXNbaF0pe2NvbnN0IFE9bmV3IFByb21pc2UocT0+e1U9cSxLPU9iamVjdChULnJlcXVlc3RBbmltYXRpb25GcmFtZSkoVil9KTtRLl9yZXNvbHZlPVUsUS5fcmVxdWVzdElEPUssUS5fdHlwZT0idGlja2VyIix0aGlzW2hdPVF9fTtBKCl9dG9HbG9iYWxQb3MoUyxiKXtpZih0aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0KXtjb25zdCBVPXRoaXMudHJhbnNmb3JtTWF0cml4O1M9VVswXSpTK1VbMl0qYitVWzRdLGI9VVsxXSpTK1VbM10qYitVWzVdfWNvbnN0e3dpZHRoOk8saGVpZ2h0OkR9PXRoaXMuZ2V0UmVzb2x1dGlvbigpLEk9dGhpcy5yZW5kZXJPZmZzZXQsUj1bdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0XTtTPVMqUlswXS9PK0lbMF0sYj1iKlJbMV0vRCtJWzFdO2NvbnN0IEE9dGhpcy5kaXNwbGF5UmF0aW87cmV0dXJuIFMqPUEsYio9QSxbUyxiXX10b0xvY2FsUG9zKFMsYil7Y29uc3R7d2lkdGg6TyxoZWlnaHQ6RH09dGhpcy5nZXRSZXNvbHV0aW9uKCksST10aGlzLnJlbmRlck9mZnNldCxSPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO1M9UypPL1JbMF0tSVswXSxiPWIqRC9SWzFdLUlbMV07Y29uc3QgQT10aGlzLmRpc3BsYXlSYXRpbztTLz1BLGIvPUE7Y29uc3QgVT10aGlzLmxheWVyVHJhbnNmb3JtSW52ZXJ0O3JldHVybiBVJiYoUz1VWzBdKlMrVVsyXSpiK1VbNF0sYj1VWzFdKlMrVVszXSpiK1VbNV0pLFtTLGJdfX11LmRlZmF1bHQucmVnaXN0ZXJOb2RlKE0sImxheWVyIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KTt2YXIgYT10KDIyNCksbz10KDI4OCksdj10KDIxMyksVD10KDI1MiksZD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gdShtLHIpe2lmKG09PW51bGwpcmV0dXJue307dmFyIGk9YyhtLHIpLG4scztpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgTT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG0pO2ZvcihzPTA7czxNLmxlbmd0aDtzKyspbj1NW3NdLCEoci5pbmRleE9mKG4pPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG0sbikmJihpW25dPW1bbl0pfXJldHVybiBpfWZ1bmN0aW9uIGMobSxyKXtpZihtPT1udWxsKXJldHVybnt9O3ZhciBpPXt9LG49T2JqZWN0LmtleXMobSkscyxNO2ZvcihNPTA7TTxuLmxlbmd0aDtNKyspcz1uW01dLCEoci5pbmRleE9mKHMpPj0wKSYmKGlbc109bVtzXSk7cmV0dXJuIGl9ZnVuY3Rpb24gRShtLHIsaSl7cmV0dXJuIHIgaW4gbT9PYmplY3QuZGVmaW5lUHJvcGVydHkobSxyLHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6bVtyXT1pLG19Y29uc3QgZj0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLGc9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIikseT1TeW1ib2woInJvb3QiKSxDPVN5bWJvbCgidGFzayIpO2Z1bmN0aW9uIHgobSxyPSEwKXtjb25zdCBpPW1beV07aWYoaSYmaS5jaGlsZHJlblswXSl7Y29uc3Qgbj1tLnN2ZyxzPW0ubGF5ZXI/bS5sYXllci5kaXNwbGF5UmF0aW86MTtpZighbi5oYXNBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSl7bGV0IFM9bi5nZXRBdHRyaWJ1dGUoIndpZHRoIik7Uz1TP09iamVjdChkLnNpemVUb1BpeGVsKShTKTozMDA7bGV0IGI9bi5nZXRBdHRyaWJ1dGUoImhlaWdodCIpO2I9Yj9PYmplY3QoZC5zaXplVG9QaXhlbCkoYik6MTUwLG4uaGFzQXR0cmlidXRlKCJ2aWV3Qm94Iil8fG4uc2V0QXR0cmlidXRlKCJ2aWV3Qm94IixgMCAwICR7TWF0aC5yb3VuZChTKX0gJHtNYXRoLnJvdW5kKGIpfWApLG4uc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIixTKSxuLnNldEF0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC1oZWlnaHQiLGIpfWxldCBNPW0uYXR0cmlidXRlcy53aWR0aHx8TnVtYmVyKG4uZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLXdpZHRoIikpLFA9bS5hdHRyaWJ1dGVzLmhlaWdodHx8TnVtYmVyKG4uZ2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIpKTtpZihNKj1zLFAqPXMsciYmbS5hdHRyaWJ1dGVzLmZsZXhpYmxlKXtjb25zdCBTPW0uYXR0cmlidXRlcy5zY2FsZVswXTtpZihNKj1TLFAqPVMsbi5zZXRBdHRyaWJ1dGUoIndpZHRoIixNKSxuLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixQKSxNJiZQJiZtLnRleHR1cmVJbWFnZSl7Y29uc3QgYj1tLnRleHR1cmVJbWFnZS53aWR0aCxPPW0udGV4dHVyZUltYWdlLmhlaWdodCxEPW0uY2xpZW50U2l6ZTttLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9WzAsMCxNYXRoLnJvdW5kKERbMF0qYi9NKSxNYXRoLnJvdW5kKERbMV0qTy9QKV19fWVsc2UgbVtDXXx8KG4uc2V0QXR0cmlidXRlKCJ3aWR0aCIsTSksbi5zZXRBdHRyaWJ1dGUoImhlaWdodCIsUCksbVtDXT1Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57ZGVsZXRlIG1bQ107Y29uc3QgUz1pLmlubmVySFRNTCxiPW5ldyBCbG9iKFtTXSx7dHlwZToiaW1hZ2Uvc3ZnK3htbCJ9KSxPPVVSTC5jcmVhdGVPYmplY3RVUkwoYiksRD1uZXcgSW1hZ2U7RC5vbmxvYWQ9ZnVuY3Rpb24oKXtELndpZHRoJiZELmhlaWdodD8obS5hdHRyaWJ1dGVzW2ddKCJ0ZXh0dXJlIixEKSxtLmF0dHJpYnV0ZXMuZmxleGlibGUmJihtLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q9bnVsbCkpOm0uYXR0cmlidXRlc1tnXSgidGV4dHVyZSIsbnVsbCl9LEQuc3JjPU99KSl9fWNsYXNzIGggZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3Iocj17fSl7dHlwZW9mIHI9PSJzdHJpbmciJiYocj17c3ZnVGV4dDpyfSk7bGV0e3N2Z1RleHQ6aX09cixuPXUocixbInN2Z1RleHQiXSk7aWYoc3VwZXIobiksdGhpc1t5XT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxpKXt0aGlzW3ldLmlubmVySFRNTD1pO2NvbnN0IHM9dGhpc1t5XS5jaGlsZHJlblswXTtzP3Muc2V0QXR0cmlidXRlKCJ4bWxucyIsZik6KGZldGNoKGkpLnRoZW4oTT0+TS50ZXh0KCkpLnRoZW4oTT0+e3RoaXNbeV0uaW5uZXJIVE1MPU0sKCF0aGlzLm9ic2VydmVyfHx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUpJiZ4KHRoaXMpfSksaT1udWxsKX1pZighaSl7Y29uc3Qgcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZiwic3ZnIik7cy5zZXRBdHRyaWJ1dGUoInhtbG5zIixmKSx0aGlzW3ldLmFwcGVuZENoaWxkKHMpfWlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPT0iZnVuY3Rpb24iKXtjb25zdCBzPW5ldyBNdXRhdGlvbk9ic2VydmVyKE09Pnt4KHRoaXMsITEpfSk7cy5vYnNlcnZlKHRoaXNbeV0se2F0dHJpYnV0ZXM6ITAsc3VidHJlZTohMCxjaGFyYWN0ZXJEYXRhOiEwLGNoaWxkTGlzdDohMH0pLHRoaXMub2JzZXJ2ZXI9c319Z2V0IGNoaWxkcmVuKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgY2hpbGROb2Rlcygpe3JldHVyblt0aGlzLnN2Z119Z2V0IHN2Zygpe3JldHVybiB0aGlzW3ldP3RoaXNbeV0uY2hpbGRyZW5bMF06bnVsbH1zZXRSZXNvbHV0aW9uKHt3aWR0aDpyLGhlaWdodDppfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6cixoZWlnaHQ6aX0pLHgodGhpcyl9ZGlzcGF0Y2hQb2ludGVyRXZlbnQocil7Y29uc3QgaT1zdXBlci5kaXNwYXRjaFBvaW50ZXJFdmVudChyKTtpZihpJiZ0aGlzLmF0dHJpYnV0ZXMucGFzc0V2ZW50cyYmdHlwZW9mIE1vdXNlRXZlbnQ9PSJmdW5jdGlvbiIpe2NvbnN0e3g6bix5OnN9PXI7bGV0W00sUF09dGhpcy5nZXRPZmZzZXRQb3NpdGlvbihuLHMpO2NvbnN0IFM9ci5vcmlnaW5hbEV2ZW50LGI9dGhpcy5hdHRyaWJ1dGVzLmFuY2hvcixPPXRoaXMuY2xpZW50U2l6ZTtNPShNK2JbMF0qT1swXSkvMixQPShQK2JbMV0qT1sxXSkvMjtjb25zdCBEPXIudHlwZTtpZihEPT09Uy50eXBlKXtsZXQgST1udWxsO2lmKFMgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KUk9bmV3IE1vdXNlRXZlbnQoRCx7c2NyZWVuWDpNLHNjcmVlblk6UCxjbGllbnRYOk0sY2xpZW50WTpQLGJ1YmJsZXM6Uy5idWJibGVzLGJ1dHRvbjpTLmJ1dHRvbixidXR0b25zOlMuYnV0dG9ucyxjYW5jZWxCdWJibGU6Uy5jYW5jZWxCdWJibGUsY2FuY2VsYWJsZTpTLmNhbmNlbGFibGUsY3VycmVudFRhcmdldDpTLmN1cnJlbnRUYXJnZXQsZnJvbUVsZW1lbnQ6Uy5mcm9tRWxlbWVudCxyZWxhdGVkVGFyZ2V0OlMucmVsYXRlZFRhcmdldCxyZXR1cm5WYWx1ZTpTLnJldHVyblZhbHVlLHNyY0VsZW1lbnQ6Uy5zcmNFbGVtZW50LHRhcmdldDpTLnRhcmdldCx0b0VsZW1lbnQ6Uy50b0VsZW1lbnQsd2hpY2g6Uy53aXRjaH0pO2Vsc2UgaWYoUyBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpe2xldCBSPW51bGw7Y29uc3QgQT1TLmNoYW5nZWRUb3VjaGVzfHxbU107Zm9yKGxldCBVPTA7VTxBLmxlbmd0aDtVKyspe2NvbnN0IEs9QVtVXTtpZihyLmlkZW50aWZpZXI9PT1LLmlkZW50aWZpZXIpe1I9SzticmVha319aWYoUil7Y29uc3QgVT1uZXcgVG91Y2goe2lkZW50aWZpZXI6Ui5pZGVudGlmaWVyLHRhcmdldDpSLnRhcmdldCxjbGllbnRYOk0sY2xpZW50WTpQLHNjcmVlblg6TSxzY3JlZW5ZOlAscGFnZVg6TSxwYWdlWTpQLHJhZGl1c1g6Ui5yYWRpdXNYLHJhZGl1c1k6Ui5yYWRpdXNZLHJvdGF0aW9uQW5nbGU6Ui5yb3RhdGlvbkFuZ2xlLGZvcmNlOlIuZm9yY2V9KTtJPW5ldyBUb3VjaEV2ZW50KEQse2NhbmNlbGFibGU6Uy5jYW5jZWxhYmxlLGJ1YmJsZXM6Uy5idWJibGVzLGNvbXBvc2VkOlMuY29tcG9zZWQsdG91Y2hlczpbVV0sdGFyZ2V0VG91Y2hlczpbVV0sY2hhbmdlZFRvdWNoZXM6W1VdfSl9fWVsc2UgST1TO0kmJnRoaXMuc3ZnLmRpc3BhdGNoRXZlbnQoSSl9fXJldHVybiBpfWdldEVsZW1lbnRCeUlkKHIpe3JldHVybiBPYmplY3QoVC5xdWVyeVNlbGVjdG9yKShgIyR7cn1gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUocil7cmV0dXJuIE9iamVjdChULnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtyfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUocil7cmV0dXJuIE9iamVjdChULnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtyfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShyKXtyZXR1cm4gT2JqZWN0KFQucXVlcnlTZWxlY3RvckFsbCkocix0aGlzKX1xdWVyeVNlbGVjdG9yKHIpe3JldHVybiBPYmplY3QoVC5xdWVyeVNlbGVjdG9yKShyLHRoaXMpfXF1ZXJ5U2VsZWN0b3JBbGwocil7cmV0dXJuIE9iamVjdChULnF1ZXJ5U2VsZWN0b3JBbGwpKHIsdGhpcyl9b25Qcm9wZXJ0eUNoYW5nZShyLGksbil7c3VwZXIub25Qcm9wZXJ0eUNoYW5nZShyLGksbikscj09PSJmbGV4aWJsZSImJngodGhpcyksdGhpcy5hdHRyaWJ1dGVzLmZsZXhpYmxlJiYocj09PSJ3aWR0aCJ8fHI9PT0iaGVpZ2h0Inx8cj09PSJzY2FsZSJ8fHI9PT0idHJhbnNmb3JtIikmJngodGhpcyl9fUUoaCwiQXR0ciIsby5kZWZhdWx0KSx2LmRlZmF1bHQucmVnaXN0ZXJOb2RlKGgsInNwcml0ZXN2ZyIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGE9dCgyMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBvPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHY9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksVD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0Iik7Y2xhc3MgZCBleHRlbmRzIGEuZGVmYXVsdHtjb25zdHJ1Y3RvcihjKXtzdXBlcihjKSx0aGlzW1RdKHtwYXNzRXZlbnRzOiExLGZsZXhpYmxlOiExfSl9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1tvXSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGMpe31nZXQgcGFzc0V2ZW50cygpe3JldHVybiB0aGlzW29dKCJwYXNzRXZlbnRzIil9c2V0IHBhc3NFdmVudHMoYyl7cmV0dXJuIHRoaXNbdl0oInBhc3NFdmVudHMiLGMpfWdldCBmbGV4aWJsZSgpe3JldHVybiB0aGlzW29dKCJmbGV4aWJsZSIpfXNldCBmbGV4aWJsZShjKXtyZXR1cm4gdGhpc1t2XSgiZmxleGlibGUiLGMpfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSk7dmFyIGE9dCgxMik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG8oYyxFKXt2YXIgZj1PYmplY3Qua2V5cyhjKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgZz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGMpO0UmJihnPWcuZmlsdGVyKGZ1bmN0aW9uKHkpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGMseSkuZW51bWVyYWJsZX0pKSxmLnB1c2guYXBwbHkoZixnKX1yZXR1cm4gZn1mdW5jdGlvbiB2KGMpe2Zvcih2YXIgRT0xO0U8YXJndW1lbnRzLmxlbmd0aDtFKyspe3ZhciBmPWFyZ3VtZW50c1tFXSE9bnVsbD9hcmd1bWVudHNbRV06e307RSUyP28oT2JqZWN0KGYpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKGcpe1QoYyxnLGZbZ10pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhmKSk6byhPYmplY3QoZikpLmZvckVhY2goZnVuY3Rpb24oZyl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGMsZyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGYsZykpfSl9cmV0dXJuIGN9ZnVuY3Rpb24gVChjLEUsZil7cmV0dXJuIEUgaW4gYz9PYmplY3QuZGVmaW5lUHJvcGVydHkoYyxFLHt2YWx1ZTpmLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Y1tFXT1mLGN9Y29uc3QgZD1TeW1ib2woImluaXRlZCIpO2xldCB1PW51bGw7dHlwZW9mIFdvcmtlcj09ImZ1bmN0aW9uIiYmKHU9Y2xhc3MgZXh0ZW5kcyBXb3JrZXJ7Y29uc3RydWN0b3IoYyl7aWYoYy53b3JrZXI9PT0hMCYmKGMud29ya2VyPWAuLyR7Yy5pZH0ud29ya2VyLmpzYCksc3VwZXIoYy53b3JrZXIpLHRoaXMub3B0aW9ucz1jLCFjLmNhbnZhcyl7Y29uc3R7d2lkdGg6RSxoZWlnaHQ6Zn09dGhpcy5nZXRSZXNvbHV0aW9uKCksZz1hLkVOVi5jcmVhdGVDYW52YXMoRSxmLHtvZmZzY3JlZW46ITF9KTtnLnN0eWxlJiYoZy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxnLmRhdGFzZXQmJihnLmRhdGFzZXQubGF5ZXJJZD1jLmlkKSxjLmNhbnZhcz1nfXRoaXMuY2FudmFzPWMuY2FudmFzfWdldCBpZCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaWR9c2V0UmVzb2x1dGlvbih7d2lkdGg6YyxoZWlnaHQ6RX0pe2lmKHRoaXNbZF0pdGhpcy5wb3N0TWVzc2FnZSh7dHlwZToicmVzb2x1dGlvbl9jaGFuZ2UiLHdpZHRoOmMsaGVpZ2h0OkV9KTtlbHNle3RoaXMuY2FudmFzLndpZHRoPWMsdGhpcy5jYW52YXMuaGVpZ2h0PUU7Y29uc3QgZj10aGlzLm9wdGlvbnMsZz1mLmNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpLHk9dih7fSxmKTtkZWxldGUgeS5jb250YWluZXIseS5jYW52YXM9Zyx0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJjcmVhdGUiLG9wdGlvbnM6eX0sW2ddKSx0aGlzW2RdPSEwfX1nZXRSZXNvbHV0aW9uKCl7aWYodGhpcy5jYW52YXMpe2NvbnN0e3dpZHRoOmMsaGVpZ2h0OkV9PXRoaXMuY2FudmFzO3JldHVybnt3aWR0aDpjLGhlaWdodDpFfX1yZXR1cm57d2lkdGg6MzAwLGhlaWdodDoxNTB9fXJlbW92ZSgpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQ/KHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCEwKTohMX1jb25uZWN0KGMsRSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOmMsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkUsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9ZGlzY29ubmVjdCgpe2RlbGV0ZSB0aGlzLnBhcmVudCxkZWxldGUgdGhpcy56T3JkZXJ9ZGlzcGF0Y2hQb2ludGVyRXZlbnQoYyl7dGhpcy5wb3N0TWVzc2FnZSh7dHlwZToiZXZlbnQiLGV2ZW50OntjYW5jZWxCdWJibGU6Yy5jYW5jZWxCdWJibGUsYnViYmxlczpjLmJ1YmJsZXMsZGV0YWlsOmMuZGV0YWlsLGlkZW50aWZpZXI6Yy5pZGVudGlmaWVyLGxheWVyWDpjLmxheWVyWCxsYXllclk6Yy5sYXllclksb3JpZ2luYWxYOmMub3JpZ2luYWxYLG9yaWdpbmFsWTpjLm9yaWdpbmFsWSx0eXBlOmMudHlwZSx4OmMueCx5OmMueX19KX19KSxlLmRlZmF1bHQ9dX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSwoZnVuY3Rpb24oYSl7dC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KTt2YXIgbz10KDEyKSx2PXQoNjgpLFQ9dCg3MCksZD10KDI4NiksdT10KDI4OSksYz10KDI1MCksRT10KDI5MSksZj10KDIxNCksZz10KDIxOCkseT10KDIxMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEM9U3ltYm9sKCJlbnRlcmVkVGFyZ2V0cyIpO2Z1bmN0aW9uIHgoUCl7cmV0dXJuIFAuaWQ9UC5pZHx8YF9sYXllciR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwxMil9YCxQLmRhdGFzZXR8fChQLmRhdGFzZXQ9e30pLFAuZGF0YXNldC5sYXllcklkPVAuaWQsUC5jb25uZWN0PShTLGIpPT57UC5wYXJlbnQ9UyxPYmplY3QuZGVmaW5lUHJvcGVydHkoUCwiek9yZGVyIix7dmFsdWU6Yix3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX0sUC5kaXNjb25uZWN0PVM9PntkZWxldGUgUC56T3JkZXJ9LFAuY2FudmFzPVAsUC5nZXRSZXNvbHV0aW9uPSgpPT4oe3dpZHRoOjAsaGVpZ2h0OjB9KSxQLnNldFJlc29sdXRpb249KCk9PiExLFAub3B0aW9ucz17aGFuZGxlRXZlbnQ6ITF9LFB9ZnVuY3Rpb24gaChQLFMpe2NvbnN0IGI9UC5jaGlsZHJlbjtsZXQgTz1udWxsO2ZvcihsZXQgRD0wO0Q8Yi5sZW5ndGg7RCsrKXtjb25zdCBJPWJbRF07aWYoKFM9PT1JfHxPIT1udWxsKSYmKE89SSksTyYmTyE9PVMmJiFPLm9mZnNjcmVlbilyZXR1cm4gTy5jYW52YXN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gbShQLFMpe2NvbnN0W2IsT109UC5yZW5kZXJPZmZzZXQse3dpZHRoOkQsaGVpZ2h0Okl9PVAuZ2V0UmVzb2x1dGlvbigpLFI9UC5kaXNwbGF5UmF0aW87UC5yZW5kZXJlci5kcmF3SW1hZ2UoUy5jYW52YXMsLWIvUiwtTy9SLEQvUixJL1IpfWNvbnN0IHI9e307ZnVuY3Rpb24gaShQKXtjb25zdCBTPVsibW91c2Vkb3duIiwibW91c2V1cCIsIm1vdXNlbW92ZSIsIm1vdXNld2hlZWwiLCJ3aGVlbCIsInRvdWNoc3RhcnQiLCJ0b3VjaGVuZCIsInRvdWNobW92ZSIsInRvdWNoY2FuY2VsIiwiY2xpY2siLCJkYmxjbGljayIsImxvbmdwcmVzcyIsInRhcCIsImNvbnRleHRtZW51Il0sYj1QLmNvbnRhaW5lcjtiLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLE89Pntjb25zdCBEPVBbQ107aWYoRC5zaXplKXtjb25zdCBJPW5ldyBmLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTtJLnNldE9yaWdpbmFsRXZlbnQoTyksWy4uLkRdLmZvckVhY2goUj0+e1IuZGlzcGF0Y2hFdmVudChJKX0pLFBbQ10uY2xlYXIoKX19LHtwYXNzaXZlOiEwfSksUy5mb3JFYWNoKE89PntiLmFkZEV2ZW50TGlzdGVuZXIoTyxEPT57Y29uc3R7bGVmdDpJLHRvcDpSLGRpc3BsYXlSYXRpbzpBfT1QLm9wdGlvbnMsVT1QLm9yZGVyZWRDaGlsZHJlbjtPYmplY3QoRS5kZWZhdWx0KShELHtvZmZzZXRMZWZ0Okksb2Zmc2V0VG9wOlIsZGlzcGxheVJhdGlvOkF9KS5mb3JFYWNoKFY9Pntjb25zdCBRPVYuaWRlbnRpZmllcjtpZihWLnR5cGU9PT0idG91Y2htb3ZlInx8Vi50eXBlPT09InRvdWNoZW5kIil7Y29uc3QgVz1yW1FdO1cmJlcuZGlzcGF0Y2hFdmVudChWKSxWLnR5cGU9PT0idG91Y2hlbmQiJiZkZWxldGUgcltRXX1lbHNle2ZvcihsZXQgVz1VLmxlbmd0aC0xO1c+PTA7Vy0tKXtjb25zdCBIPVVbV107aWYoSC5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe2lmKEguZGlzcGF0Y2hQb2ludGVyRXZlbnQoVikmJlYudGFyZ2V0IT09SClicmVhaztWLmNhbmNlbEJ1YmJsZT0hMX19aWYoVi50YXJnZXQ9PT1VWzBdKWZvcihsZXQgVz1VLmxlbmd0aC0xO1c+PTA7Vy0tKXtjb25zdCBIPVVbV107aWYoSC5vcHRpb25zLmhhbmRsZUV2ZW50IT09ITEpe1YudGFyZ2V0PUg7YnJlYWt9fX1jb25zdCBxPVYudGFyZ2V0O2lmKFYudHlwZT09PSJ0b3VjaHN0YXJ0IiYmKHJbUV09Vi50YXJnZXQpLFYudHlwZT09PSJtb3VzZW1vdmUiKXtjb25zdCBXPVBbQ107bGV0IEg7aWYocSl7Y29uc3QgXz1xLmFuY2VzdG9yc3x8W107SD1uZXcgU2V0KFtxLC4uLl9dKX1lbHNlIEg9bmV3IFNldDtjb25zdCBaPU9iamVjdC5lbnRyaWVzKEQpO2lmKCFXLmhhcyhxKSYmcSl7Y29uc3QgXz1uZXcgZi5kZWZhdWx0KCJtb3VzZWVudGVyIik7Xy5zZXRPcmlnaW5hbEV2ZW50KEQpLFouZm9yRWFjaCgoW2ssY3RdKT0+e19ba109Y3R9KSxXLmFkZChxKSxxLmRpc3BhdGNoRXZlbnQoXyk7Y29uc3Qgc3Q9cS5hbmNlc3RvcnM7c3QmJnN0LmZvckVhY2goaz0+e2sgaW5zdGFuY2VvZiBULmRlZmF1bHQmJiFXLmhhcyhrKSYmKFcuYWRkKGspLGsuZGlzcGF0Y2hFdmVudChfKSl9KX1jb25zdCB0dD1uZXcgZi5kZWZhdWx0KCJtb3VzZWxlYXZlIik7dHQuc2V0T3JpZ2luYWxFdmVudChEKSxaLmZvckVhY2goKFtfLHN0XSk9Pnt0dFtfXT1zdH0pLFsuLi5XXS5mb3JFYWNoKF89PntILmhhcyhfKXx8KFcuZGVsZXRlKF8pLF8uZGlzcGF0Y2hFdmVudCh0dCkpfSl9fSl9LHtwYXNzaXZlOk8hPT0iY29udGV4dG1lbnUifSl9KX1mdW5jdGlvbiBuKFAsUyl7aWYoUyYmUy5zdHlsZSl7bGV0e3dpZHRoOmIsaGVpZ2h0Ok8sbW9kZTpELGNvbnRhaW5lcjpJfT1QO2NvbnN0e2NsaWVudFdpZHRoOlIsY2xpZW50SGVpZ2h0OkF9PUk7Yj1ifHxSLE89T3x8QSxEPT09InN0YXRpYyI/KFMuc3R5bGUud2lkdGg9YCR7Yn1weGAsUy5zdHlsZS5oZWlnaHQ9YCR7T31weGApOihTLnN0eWxlLnRvcD0iMCIsUy5zdHlsZS5sZWZ0PSIwIixTLnN0eWxlLndpZHRoPWAke1J9cHhgLFMuc3R5bGUuaGVpZ2h0PWAke0F9cHhgLFMuc3R5bGUudHJhbnNmb3JtPSIiLFMuc3R5bGUud2Via2l0VHJhbnNmb3JtPSIiKX19Y29uc3Qgcz1TeW1ib2woIm9mZnNjcmVlbkxheWVyQ291bnQiKTtjbGFzcyBNIGV4dGVuZHMgYy5kZWZhdWx0e2NvbnN0cnVjdG9yKFM9e30pe2lmKHN1cGVyKCksIVMuY29udGFpbmVyKWlmKHR5cGVvZiBvLkVOVi5Db250YWluZXI9PSJmdW5jdGlvbiIpUy5jb250YWluZXI9bmV3IG8uRU5WLkNvbnRhaW5lcihTLndpZHRofHwzMDAsUy5oZWlnaHR8fDE1MCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIk5vIGNvbnRhaW5lciBzcGVjaWZpZWQuIik7aWYodGhpcy5jb250YWluZXI9Uy5jb250YWluZXIsdGhpcy5jb250YWluZXIuc3R5bGUmJih0aGlzLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd3x8KHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iKSx0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbnx8KHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSIpKSx0aGlzLm9wdGlvbnM9UyxTLmRpc3BsYXlSYXRpbz1TLmRpc3BsYXlSYXRpb3x8MSxTLm1vZGU9Uy5tb2RlfHwic2NhbGUiLFMubGVmdD0wLFMudG9wPTAsUy5hdXRvUmVzaXplPVMuYXV0b1Jlc2l6ZSE9PSExLFMuYXV0b1Jlc2l6ZSl7bGV0IGI7aWYodHlwZW9mIGdsb2JhbFRoaXM8InUiP2I9Z2xvYmFsVGhpczpiPXR5cGVvZiB3aW5kb3c8InUiP3dpbmRvdzphLGIuYWRkRXZlbnRMaXN0ZW5lcil7Y29uc3QgTz10aGlzO2IuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIixmdW5jdGlvbiBEKCl7dHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuY29udGFpbnMoTy5jb250YWluZXIpP08ucmVzaXplKCk6Yi5yZW1vdmVFdmVudExpc3RlbmVyKCJyZXNpemUiLEQpfSl9fXRoaXNbQ109bmV3IFNldCx0aGlzLnNldFJlc29sdXRpb24oUyksaSh0aGlzKSx0aGlzW3NdPTB9Z2V0IGhhc09mZnNjcmVlbkNhbnZhcygpe3JldHVybiB0aGlzW3NdPjB9c2V0IGRpc3BsYXlSYXRpbyhTKXt0aGlzLm9wdGlvbnMuZGlzcGxheVJhdGlvIT09UyYmKHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW89Uyx0aGlzLnJlc2l6ZSgpKX1nZXQgZGlzcGxheVJhdGlvKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW99c2V0IGhlaWdodChTKXt0aGlzLm9wdGlvbnMuaGVpZ2h0IT09UyYmKHRoaXMub3B0aW9ucy5oZWlnaHQ9Uyx0aGlzLnJlc2l6ZSgpKX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXMub3B0aW9ucy5oZWlnaHR9c2V0IG1vZGUoUyl7dGhpcy5vcHRpb25zLm1vZGUhPT1TJiYodGhpcy5vcHRpb25zLm1vZGU9Uyx0aGlzLnJlc2l6ZSgpKX1nZXQgbW9kZSgpe3JldHVybiB0aGlzLm9wdGlvbnMubW9kZX1zZXQgd2lkdGgoUyl7dGhpcy5vcHRpb25zLndpZHRoIT09UyYmKHRoaXMub3B0aW9ucy53aWR0aD1TLHRoaXMucmVzaXplKCkpfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLm9wdGlvbnMud2lkdGh9YXBwZW5kQ2hpbGQoUyl7IShTIGluc3RhbmNlb2YgZC5kZWZhdWx0KSYmIShTIGluc3RhbmNlb2YgdS5kZWZhdWx0KSYmeChTKTtjb25zdCBiPXN1cGVyLmFwcGVuZENoaWxkKFMpLE89Uy5jYW52YXM7cmV0dXJuIFMub2Zmc2NyZWVuP3RoaXNbc10rKzp0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChPKSxuKHRoaXMub3B0aW9ucyxPKSxTLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uKCkpLGJ9Zm9yY2VVcGRhdGUoKXt0aGlzLmhhc09mZnNjcmVlbkNhbnZhcyYmIXRoaXMuX3JlcXVlc3RJRCYmKHRoaXMuX3JlcXVlc3RJRD1PYmplY3Qodi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKCgpPT57ZGVsZXRlIHRoaXMuX3JlcXVlc3RJRCx0aGlzLnJlbmRlcigpfSkpfWluc2VydEJlZm9yZShTLGIpeyEoUyBpbnN0YW5jZW9mIGQuZGVmYXVsdCkmJiEoUyBpbnN0YW5jZW9mIHUuZGVmYXVsdCkmJngoUyk7Y29uc3QgTz1zdXBlci5pbnNlcnRCZWZvcmUoUyxiKSxEPVMuY2FudmFzO2lmKCFTLm9mZnNjcmVlbil7Y29uc3QgST1oKHRoaXMsUyk7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEQsSSl9cmV0dXJuIG4odGhpcy5vcHRpb25zLEQpLFMuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksT31sYXllcihTPSJkZWZhdWx0IixiPXt9KXtiPU9iamVjdC5hc3NpZ24oe30sdGhpcy5vcHRpb25zLGIpLGIuaWQ9Uztjb25zdCBPPXRoaXMub3JkZXJlZENoaWxkcmVuO2ZvcihsZXQgUj0wO1I8Ty5sZW5ndGg7UisrKWlmKE9bUl0uaWQ9PT1TKXJldHVybiBPW1JdO2NvbnN0IEQ9Yi53b3JrZXI7bGV0IEk7cmV0dXJuIEQ/ST1uZXcgdS5kZWZhdWx0KGIpOkk9bmV3IGQuZGVmYXVsdChiKSx0aGlzLmFwcGVuZENoaWxkKEkpLEl9YXN5bmMgcHJlbG9hZCguLi5TKXtjb25zdCBiPVtdLE89W10sRD1bXTtmb3IobGV0IEk9MDtJPFMubGVuZ3RoO0krKyl7Y29uc3QgUj1TW0ldO2xldCBBO2lmKHR5cGVvZiBSPT0ic3RyaW5nIilBPU9iamVjdChnLmxvYWRUZXh0dXJlKShSKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoUikpQT1PYmplY3QoZy5sb2FkRnJhbWVzKSguLi5SKTtlbHNle2NvbnN0e2lkOlUsc3JjOkt9PVI7QT1PYmplY3QoZy5sb2FkVGV4dHVyZSkoSyxVKX1BIGluc3RhbmNlb2YgUHJvbWlzZXx8KEE9UHJvbWlzZS5yZXNvbHZlKEEpKSxPLnB1c2goQS50aGVuKFU9PntiLnB1c2goVSksRFtJXT1VO2NvbnN0IEs9bmV3IGYuZGVmYXVsdCh7dHlwZToicHJlbG9hZCIsZGV0YWlsOntjdXJyZW50OlUsbG9hZGVkOmIscmVzb3VyY2VzOlN9fSk7dGhpcy5kaXNwYXRjaEV2ZW50KEspfSkpfXJldHVybiBhd2FpdCBQcm9taXNlLmFsbChPKSxEfXJlbW92ZUNoaWxkKFMpe2NvbnN0IGI9c3VwZXIucmVtb3ZlQ2hpbGQoUyk7aWYoYil7Uy5fcHJlcGFyZVJlbmRlckZpbmlzaGVkJiZTLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQoKTtjb25zdCBPPVMuY2FudmFzO08mJk8ucmVtb3ZlJiZPLnJlbW92ZSgpLFMub2Zmc2NyZWVuJiZ0aGlzW3NdLS19cmV0dXJuIGJ9cmVuZGVyKCl7Y29uc3QgUz10aGlzLm9yZGVyZWRDaGlsZHJlbjtsZXQgYj1udWxsO2NvbnN0IE89W107Zm9yKGxldCBEPTA7RDxTLmxlbmd0aDtEKyspe2NvbnN0IEk9U1tEXSxSPU8ubGVuZ3RoPjA7aWYoSSBpbnN0YW5jZW9mIGQuZGVmYXVsdCYmIUkub2Zmc2NyZWVuKWlmKCFJLmF1dG9SZW5kZXIpUiYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLE8ubGVuZ3RoPTApO2Vsc2UgaWYoYj1JLFIpe0kucmVuZGVyZXIuY2xlYXIoKTtmb3IobGV0IEE9MDtBPE8ubGVuZ3RoO0ErKyl7Y29uc3QgVT1PW0FdO1UucmVuZGVyKCksbShJLFUpfU8ubGVuZ3RoPTAsSS5yZW5kZXIoe2NsZWFyOiExfSl9ZWxzZSBJLnByZXBhcmVSZW5kZXImJkkucmVuZGVyKCk7ZWxzZSBJLm9mZnNjcmVlbj9iPyhJLnByZXBhcmVSZW5kZXImJkkucmVuZGVyKCksbShiLEkpKTpPLnB1c2goSSk6SSBpbnN0YW5jZW9mIHUuZGVmYXVsdCYmUiYmKGNvbnNvbGUud2FybigiU29tZSBvZmZzY3JlZW4gY2FudmFzIHdpbGwgbm90IGJlIHJlbmRlcmVkLiIpLE8ubGVuZ3RoPTApfX1yZXBsYWNlQ2hpbGQoUyxiKXtjb25zdCBPPXN1cGVyLnJlcGxhY2VDaGlsZChTLGIpO2IuY2FudmFzLnJlbW92ZSYmYi5jYW52YXMucmVtb3ZlKCksYi5vZmZzY3JlZW4mJnRoaXNbc10tLTtjb25zdCBEPVMuY2FudmFzO2lmKCFTLm9mZnNjcmVlbil7Y29uc3QgST1oKHRoaXMsUyk7dGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKEQsSSl9cmV0dXJuIG4odGhpcy5vcHRpb25zLEQpLFMuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksT31yZXNpemUoKXtjb25zdCBTPXRoaXMub3B0aW9uczt0aGlzLmNoaWxkcmVuLmZvckVhY2goYj0+e24oUyxiLmNhbnZhcyl9KSx0aGlzLnNldFJlc29sdXRpb24oUyksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZXNpemUifSl9c2V0UmVzb2x1dGlvbih7d2lkdGg6UyxoZWlnaHQ6Yn09e30pe2NvbnN0IE89dGhpcy5jb250YWluZXIse2NsaWVudFdpZHRoOkQsY2xpZW50SGVpZ2h0Okl9PU87KFM9PW51bGx8fGI9PW51bGwpJiYoUz1TPz9ELGI9Yj8/SSk7Y29uc3R7bW9kZTpSLGRpc3BsYXlSYXRpbzpBfT10aGlzLm9wdGlvbnM7aWYoUyo9QSxiKj1BLHRoaXMub3B0aW9ucy5sZWZ0PTAsdGhpcy5vcHRpb25zLnRvcD0wLFI9PT0ic3RpY2t5SGVpZ2h0Inx8Uj09PSJzdGlja3lMZWZ0Inx8Uj09PSJzdGlja3lSaWdodCIpe2NvbnN0IFU9UztTPUQqYi9JLFI9PT0ic3RpY2t5SGVpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PS41KihTLVUpKSxSPT09InN0aWNreVJpZ2h0IiYmKHRoaXMub3B0aW9ucy5sZWZ0PVMtVSl9ZWxzZSBpZihSPT09InN0aWNreVdpZHRoInx8Uj09PSJzdGlja3lUb3AifHxSPT09InN0aWNreUJvdHRvbSIpe2NvbnN0IFU9YjtiPUkqUy9ELFI9PT0ic3RpY2t5V2lkdGgiJiYodGhpcy5vcHRpb25zLnRvcD0uNSooYi1VKSksUj09PSJzdGlja3lCb3R0b20iJiYodGhpcy5vcHRpb25zLnRvcD1iLVUpfXN1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOlMsaGVpZ2h0OmJ9KX1zbmFwc2hvdCh7b2Zmc2NyZWVuOlM9ITEsbGF5ZXJzOmJ9PXt9KXtjb25zdCBPPVM/InNuYXBzaG90T2ZmU2NyZWVuQ2FudmFzIjoic25hcHNob3RDYW52YXMiLHt3aWR0aDpELGhlaWdodDpJfT10aGlzLmdldFJlc29sdXRpb24oKTt0aGlzW09dPXRoaXNbT118fG8uRU5WLmNyZWF0ZUNhbnZhcyhELEkse29mZnNjcmVlbjpTfSk7Y29uc3QgUj10aGlzW09dLmdldENvbnRleHQoIjJkIik7Yj1ifHx0aGlzLm9yZGVyZWRDaGlsZHJlbix0aGlzW09dLndpZHRoPUQsdGhpc1tPXS5oZWlnaHQ9STtmb3IobGV0IEE9MDtBPGIubGVuZ3RoO0ErKyl7Y29uc3QgVT1iW0FdO2lmKCFVLm9wdGlvbnMuaWdub3JlU25hcHNob3Qpe1UucmVuZGVyJiZVLnJlbmRlcigpO2NvbnN0IEs9VS5jYW52YXM7SyYmSyE9PVUmJlIuZHJhd0ltYWdlKEssMCwwLEQsSSl9fXJldHVybiB0aGlzW09dfX10eXBlb2YgZG9jdW1lbnQ8InUiJiYoTS5wcm90b3R5cGUubGF5ZXIzZD1mdW5jdGlvbihQLFM9e30pe2NvbnN0IGI9Uy51cmx8fCJodHRwczovL3VucGtnLmNvbS9zcHJpdGUtZXh0ZW5kLTNkL2Rpc3Qvc3ByaXRlLWV4dGVuZC0zZC5taW4uanMiO3JldHVybiBuZXcgUHJvbWlzZSgoTyxEKT0+e2NvbnN0IEk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0Iik7SS5hc3luYz0hMSxJLnNyYz1iLEkub25sb2FkPSgpPT57dHJ5e08odGhpcy5sYXllcjNkKFAsUykpfWNhdGNoKFIpe0QoUil9fSxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoSSl9KX0pLHkuZGVmYXVsdC5yZWdpc3Rlck5vZGUoTSwic2NlbmUiKX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIG99KTt2YXIgYT10KDIxNCk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIG8odix7b2Zmc2V0VG9wOlQ9MCxvZmZzZXRMZWZ0OmQ9MCxkaXNwbGF5UmF0aW86dT0xfT17fSl7bGV0IGMsRTtjb25zdCBmPVtdLHtsZWZ0OmcsdG9wOnksd2lkdGg6QyxoZWlnaHQ6eH09di50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksaD12LnRhcmdldC53aWR0aCxtPXYudGFyZ2V0LmhlaWdodCxyPXYuY2hhbmdlZFRvdWNoZXN8fFt2XTtmb3IobGV0IG49MDtuPHIubGVuZ3RoO24rKyl7Y29uc3Qgcz1yW25dLE09cy5pZGVudGlmaWVyLHtjbGllbnRYOlAsY2xpZW50WTpTfT1zO1AhPW51bGwmJlMhPW51bGwmJmYucHVzaCh7eDpNYXRoLnJvdW5kKChQfDApLWcpLHk6TWF0aC5yb3VuZCgoU3wwKS15KSxpZGVudGlmaWVyOk19KX1mLmxlbmd0aDw9MCYmZi5wdXNoKHt4OmMseTpFfSk7Y29uc3QgaT1bXTtyZXR1cm4gZi5mb3JFYWNoKG49PntuLnghPW51bGwmJm4ueSE9bnVsbCYmKGM9KG4ueCpoL0MtZCkvdSxFPShuLnkqbS94LVQpL3UpO2NvbnN0IHM9bmV3IGEuZGVmYXVsdCh2KTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzLHtsYXllclg6e3ZhbHVlOmMsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOkUsY29uZmlndXJhYmxlOiEwfSxvcmlnaW5hbFg6e3ZhbHVlOm4ueH0sb3JpZ2luYWxZOnt2YWx1ZTpuLnl9LHg6e3ZhbHVlOmMsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTpFLGNvbmZpZ3VyYWJsZTohMH0saWRlbnRpZmllcjp7dmFsdWU6bi5pZGVudGlmaWVyfX0pLGkucHVzaChzKX0pLGl9fV0pO090LnZlcnNpb24sT3QuQXJjLE90LkJsb2NrLE90LkNsb3VkLE90LkNvbG9yLE90LkVsbGlwc2UsT3QuR3JhZGllbnQsT3QuR3JvdXAsT3QuTGFiZWwsT3QuTGF5ZXIsT3QuTGF5ZXJXb3JrZXIsT3QuTm9kZSxPdC5QYXJhbGxlbDtjb25zdCBlZT1PdC5QYXRoO090LlBvbHlsaW5lLE90LlJlY3QsT3QuUmVndWxhcixPdC5SaW5nO2NvbnN0IGxlPU90LlNjZW5lO090LlNwcml0ZSxPdC5TcHJpdGVTdmcsT3QuU3RhcixPdC5UcmlhbmdsZSxPdC5oZWxwZXJzLE90LmNyZWF0ZUVsZW1lbnQsT3QuaXNTcHJpdGVOb2RlLE90LnJlZ2lzdGVyTm9kZSxPdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsT3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUsT3QuRU5WO2NvbnN0IGZlPXtsaW5lYXI6TD0+TCxlYXNlSW5RdWFkOkw9PkwqTCxlYXNlT3V0UXVhZDpMPT5MKigyLUwpLGVhc2VJbk91dFF1YWQ6TD0+TDwuNT8yKkwqTDotMSsoNC0yKkwpKkwsZWFzZUluQ3ViaWM6TD0+TCpMKkwsZWFzZU91dEN1YmljOkw9Pi0tTCpMKkwrMSxlYXNlSW5PdXRDdWJpYzpMPT5MPC41PzQqTCpMKkw6KEwtMSkqKDIqTC0yKSooMipMLTIpKzEsZWFzZUluUXVhcnQ6TD0+TCpMKkwqTCxlYXNlT3V0UXVhcnQ6TD0+MS0gLS1MKkwqTCpMLGVhc2VJbk91dFF1YXJ0Okw9Pkw8LjU/OCpMKkwqTCpMOjEtOCotLUwqTCpMKkwsZWFzZUluUXVpbnQ6TD0+TCpMKkwqTCpMLGVhc2VPdXRRdWludDpMPT4xKy0tTCpMKkwqTCpMLGVhc2VJbk91dFF1aW50Okw9Pkw8LjU/MTYqTCpMKkwqTCpMOjErMTYqLS1MKkwqTCpMKkwsZWFzZUluU2luZTpMPT4xLU1hdGguY29zKEwqTWF0aC5QSS8yKSxlYXNlT3V0U2luZTpMPT5NYXRoLnNpbihMKk1hdGguUEkvMiksZWFzZUluT3V0U2luZTpMPT4tKE1hdGguY29zKE1hdGguUEkqTCktMSkvMixlYXNlSW5FeHBvOkw9Pkw8PTA/MDpNYXRoLnBvdygyLDEwKkwtMTApLGVhc2VPdXRFeHBvOkw9Pkw+PTE/MToxLU1hdGgucG93KDIsLTEwKkwpLGVhc2VJbk91dEV4cG86TD0+TDw9MD8wOkw+PTE/MTpMPC41P01hdGgucG93KDIsMjAqTC0xMCkvMjooMi1NYXRoLnBvdygyLC0yMCpMKzEwKSkvMn07Y2xhc3MgZ3R7Y29uc3RydWN0b3IoZT0wLHQ9MCxhPTEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6YX0pfWdldCBYWSgpe3JldHVyblt0aGlzLngsdGhpcy55XX1zZXR6KGUpe3JldHVybiB0aGlzLno9ZSx0aGlzfXNldFhZKGU9dGhpcy54LHQ9dGhpcy55KXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpc31zZXQoZT10aGlzLngsdD10aGlzLnksYT10aGlzLnope3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9YSx0aGlzfXNldFRvKHt4OmU9MCx5OnQ9MCx6OmE9MX0pe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzLno9YSx0aGlzfXJvdChlKXtpZihlPT09MClyZXR1cm4gdGhpcztjb25zdHt4OnQseTphfT10aGlzLG89TWF0aC5zaW4oZSksdj1NYXRoLmNvcyhlKTtyZXR1cm4gdGhpcy54PXQqdi1hKm8sdGhpcy55PXQqbythKnYsdGhpc31yb3RXaXRoKGUsdCl7aWYodD09PTApcmV0dXJuIHRoaXM7Y29uc3QgYT10aGlzLngtZS54LG89dGhpcy55LWUueSx2PU1hdGguc2luKHQpLFQ9TWF0aC5jb3ModCk7cmV0dXJuIHRoaXMueD1lLngrKGEqVC1vKnYpLHRoaXMueT1lLnkrKGEqditvKlQpLHRoaXN9Y2xvbmUoKXtjb25zdHt4OmUseTp0LHo6YX09dGhpcztyZXR1cm4gbmV3IGd0KGUsdCxhKX1zdWIoZSl7cmV0dXJuIHRoaXMueC09ZS54LHRoaXMueS09ZS55LHRoaXN9c3ViWFkoZSx0KXtyZXR1cm4gdGhpcy54LT1lLHRoaXMueS09dCx0aGlzfXN1YlNjYWxhcihlKXtyZXR1cm4gdGhpcy54LT1lLHRoaXMueS09ZSx0aGlzfWFkZChlKXtyZXR1cm4gdGhpcy54Kz1lLngsdGhpcy55Kz1lLnksdGhpc31hZGRYWShlLHQpe3JldHVybiB0aGlzLngrPWUsdGhpcy55Kz10LHRoaXN9YWRkU2NhbGFyKGUpe3JldHVybiB0aGlzLngrPWUsdGhpcy55Kz1lLHRoaXN9Y2xhbXAoZSx0KXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHRoaXMueCxlKSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LGUpLHQhPT12b2lkIDAmJih0aGlzLng9TWF0aC5taW4odGhpcy54LHQpLHRoaXMueT1NYXRoLm1pbih0aGlzLnksdCkpLHRoaXN9ZGl2KGUpe3JldHVybiB0aGlzLngvPWUsdGhpcy55Lz1lLHRoaXN9ZGl2VihlKXtyZXR1cm4gdGhpcy54Lz1lLngsdGhpcy55Lz1lLnksdGhpc31tdWwoZSl7cmV0dXJuIHRoaXMueCo9ZSx0aGlzLnkqPWUsdGhpc31tdWxWKGUpe3JldHVybiB0aGlzLngqPWUueCx0aGlzLnkqPWUueSx0aGlzfWFicygpe3JldHVybiB0aGlzLng9TWF0aC5hYnModGhpcy54KSx0aGlzLnk9TWF0aC5hYnModGhpcy55KSx0aGlzfW51ZGdlKGUsdCl7Y29uc3QgYT1ndC5UYW4oZSx0aGlzKTtyZXR1cm4gdGhpcy5hZGQoYS5tdWwodCkpfW5lZygpe3JldHVybiB0aGlzLngqPS0xLHRoaXMueSo9LTEsdGhpc31jcm9zcyhlKXtyZXR1cm4gdGhpcy54PXRoaXMueSplLnotdGhpcy56KmUueSx0aGlzLnk9dGhpcy56KmUueC10aGlzLngqZS56LHRoaXN9ZHByKGUpe3JldHVybiBndC5EcHIodGhpcyxlKX1jcHIoZSl7cmV0dXJuIGd0LkNwcih0aGlzLGUpfWxlbjIoKXtyZXR1cm4gZ3QuTGVuMih0aGlzKX1sZW4oKXtyZXR1cm4gZ3QuTGVuKHRoaXMpfXByeShlKXtyZXR1cm4gZ3QuUHJ5KHRoaXMsZSl9cGVyKCl7Y29uc3R7eDplLHk6dH09dGhpcztyZXR1cm4gdGhpcy54PXQsdGhpcy55PS1lLHRoaXN9dW5pKCl7cmV0dXJuIGd0LlVuaSh0aGlzKX10YW4oZSl7cmV0dXJuIGd0LlRhbih0aGlzLGUpfWRpc3QoZSl7cmV0dXJuIGd0LkRpc3QodGhpcyxlKX1kaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0KXtyZXR1cm4gZ3QuRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCx0aGlzKX1zbG9wZShlKXtyZXR1cm4gZ3QuU2xvcGUodGhpcyxlKX1zbmFwVG9HcmlkKGUpe3JldHVybiB0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngvZSkqZSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkvZSkqZSx0aGlzfWFuZ2xlKGUpe3JldHVybiBndC5BbmdsZSh0aGlzLGUpfXRvQW5nbGUoKXtyZXR1cm4gZ3QuVG9BbmdsZSh0aGlzKX1scnAoZSx0KXtyZXR1cm4gdGhpcy54PXRoaXMueCsoZS54LXRoaXMueCkqdCx0aGlzLnk9dGhpcy55KyhlLnktdGhpcy55KSp0LHRoaXN9ZXF1YWxzKGUsdCl7cmV0dXJuIGd0LkVxdWFscyh0aGlzLGUsdCl9ZXF1YWxzWFkoZSx0KXtyZXR1cm4gZ3QuRXF1YWxzWFkodGhpcyxlLHQpfW5vcm0oKXtjb25zdCBlPXRoaXMubGVuKCk7cmV0dXJuIHRoaXMueD1lPT09MD8wOnRoaXMueC9lLHRoaXMueT1lPT09MD8wOnRoaXMueS9lLHRoaXN9dG9GaXhlZCgpe3JldHVybiBndC5Ub0ZpeGVkKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuIGd0LlRvU3RyaW5nKGd0LlRvRml4ZWQodGhpcykpfXRvSnNvbigpe3JldHVybiBndC5Ub0pzb24odGhpcyl9dG9BcnJheSgpe3JldHVybiBndC5Ub0FycmF5KHRoaXMpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IGd0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEFkZFhZKGUsdCxhKXtyZXR1cm4gbmV3IGd0KGUueCt0LGUueSthKX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBndChlLngtdC54LGUueS10LnkpfXN0YXRpYyBTdWJYWShlLHQsYSl7cmV0dXJuIG5ldyBndChlLngtdCxlLnktYSl9c3RhdGljIEFkZFNjYWxhcihlLHQpe3JldHVybiBuZXcgZ3QoZS54K3QsZS55K3QpfXN0YXRpYyBTdWJTY2FsYXIoZSx0KXtyZXR1cm4gbmV3IGd0KGUueC10LGUueS10KX1zdGF0aWMgRGl2KGUsdCl7cmV0dXJuIG5ldyBndChlLngvdCxlLnkvdCl9c3RhdGljIE11bChlLHQpe3JldHVybiBuZXcgZ3QoZS54KnQsZS55KnQpfXN0YXRpYyBEaXZWKGUsdCl7cmV0dXJuIG5ldyBndChlLngvdC54LGUueS90LnkpfXN0YXRpYyBNdWxWKGUsdCl7cmV0dXJuIG5ldyBndChlLngqdC54LGUueSp0LnkpfXN0YXRpYyBOZWcoZSl7cmV0dXJuIG5ldyBndCgtZS54LC1lLnkpfXN0YXRpYyBQZXIoZSl7cmV0dXJuIG5ldyBndChlLnksLWUueCl9c3RhdGljIERpc3QyKGUsdCl7cmV0dXJuIGd0LlN1YihlLHQpLmxlbjIoKX1zdGF0aWMgQWJzKGUpe3JldHVybiBuZXcgZ3QoTWF0aC5hYnMoZS54KSxNYXRoLmFicyhlLnkpKX1zdGF0aWMgRGlzdChlLHQpe3JldHVybiBNYXRoLmh5cG90KGUueS10LnksZS54LXQueCl9c3RhdGljIERwcihlLHQpe3JldHVybiBlLngqdC54K2UueSp0Lnl9c3RhdGljIENyb3NzKGUsdCl7cmV0dXJuIG5ldyBndChlLnkqdC56LWUueip0LnksZS56KnQueC1lLngqdC56KX1zdGF0aWMgQ3ByKGUsdCl7cmV0dXJuIGUueCp0LnktdC54KmUueX1zdGF0aWMgTGVuMihlKXtyZXR1cm4gZS54KmUueCtlLnkqZS55fXN0YXRpYyBMZW4oZSl7cmV0dXJuIE1hdGguaHlwb3QoZS54LGUueSl9c3RhdGljIFByeShlLHQpe3JldHVybiBndC5EcHIoZSx0KS9ndC5MZW4odCl9c3RhdGljIFVuaShlKXtyZXR1cm4gZ3QuRGl2KGUsZ3QuTGVuKGUpKX1zdGF0aWMgVGFuKGUsdCl7cmV0dXJuIGd0LlVuaShndC5TdWIoZSx0KSl9c3RhdGljIE1pbihlLHQpe3JldHVybiBuZXcgZ3QoTWF0aC5taW4oZS54LHQueCksTWF0aC5taW4oZS55LHQueSkpfXN0YXRpYyBNYXgoZSx0KXtyZXR1cm4gbmV3IGd0KE1hdGgubWF4KGUueCx0LngpLE1hdGgubWF4KGUueSx0LnkpKX1zdGF0aWMgRnJvbShlKXtyZXR1cm4gbmV3IGd0KCkuYWRkKGUpfXN0YXRpYyBGcm9tQXJyYXkoZSl7cmV0dXJuIG5ldyBndChlWzBdLGVbMV0pfXN0YXRpYyBSb3QoZSx0PTApe2NvbnN0IGE9TWF0aC5zaW4odCksbz1NYXRoLmNvcyh0KTtyZXR1cm4gbmV3IGd0KGUueCpvLWUueSphLGUueCphK2UueSpvKX1zdGF0aWMgUm90V2l0aChlLHQsYSl7Y29uc3Qgbz1lLngtdC54LHY9ZS55LXQueSxUPU1hdGguc2luKGEpLGQ9TWF0aC5jb3MoYSk7cmV0dXJuIG5ldyBndCh0LngrKG8qZC12KlQpLHQueSsobypUK3YqZCkpfXN0YXRpYyBOZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LGEpe3JldHVybiBndC5NdWwodCxndC5TdWIoYSxlKS5wcnkodCkpLmFkZChlKX1zdGF0aWMgTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQsYSxvPSEwKXtjb25zdCB2PWd0LlRhbih0LGUpLFQ9Z3QuQWRkKGUsZ3QuTXVsKHYsZ3QuU3ViKGEsZSkucHJ5KHYpKSk7aWYobyl7aWYoVC54PE1hdGgubWluKGUueCx0LngpKXJldHVybiBndC5DYXN0KGUueDx0Lng/ZTp0KTtpZihULng+TWF0aC5tYXgoZS54LHQueCkpcmV0dXJuIGd0LkNhc3QoZS54PnQueD9lOnQpO2lmKFQueTxNYXRoLm1pbihlLnksdC55KSlyZXR1cm4gZ3QuQ2FzdChlLnk8dC55P2U6dCk7aWYoVC55Pk1hdGgubWF4KGUueSx0LnkpKXJldHVybiBndC5DYXN0KGUueT50Lnk/ZTp0KX1yZXR1cm4gVH1zdGF0aWMgRGlzdGFuY2VUb0xpbmVUaHJvdWdoUG9pbnQoZSx0LGEpe3JldHVybiBndC5EaXN0KGEsZ3QuTmVhcmVzdFBvaW50T25MaW5lVGhyb3VnaFBvaW50KGUsdCxhKSl9c3RhdGljIERpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQsYSxvPSEwKXtyZXR1cm4gZ3QuRGlzdChhLGd0Lk5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoZSx0LGEsbykpfXN0YXRpYyBTbmFwKGUsdD0xKXtyZXR1cm4gbmV3IGd0KE1hdGgucm91bmQoZS54L3QpKnQsTWF0aC5yb3VuZChlLnkvdCkqdCl9c3RhdGljIENhc3QoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBndD9lOmd0LkZyb20oZSl9c3RhdGljIFNsb3BlKGUsdCl7cmV0dXJuIGUueD09PXQueT9OYU46KGUueS10LnkpLyhlLngtdC54KX1zdGF0aWMgQW5nbGUoZSx0KXtyZXR1cm4gTWF0aC5hdGFuMih0LnktZS55LHQueC1lLngpfXN0YXRpYyBMcnAoZSx0LGEpe3JldHVybiBndC5TdWIodCxlKS5tdWwoYSkuYWRkKGUpfXN0YXRpYyBNZWQoZSx0KXtyZXR1cm4gbmV3IGd0KChlLngrdC54KS8yLChlLnkrdC55KS8yKX1zdGF0aWMgRXF1YWxzKGUsdCxhPTFlLTQpe3JldHVybiBNYXRoLmFicyhlLngtdC54KTxhJiZNYXRoLmFicyhlLnktdC55KTxhfXN0YXRpYyBFcXVhbHNYWShlLHQsYSl7cmV0dXJuIGUueD09PXQmJmUueT09PWF9c3RhdGljIEVxdWFsc1hZWihlLHQsYT0xZS00KXtyZXR1cm4gZ3QuRXF1YWxzKGUsdCxhKSYmTWF0aC5hYnMoKGUuenx8MCktKHQuenx8MCkpPGF9c3RhdGljIENsb2Nrd2lzZShlLHQsYSl7cmV0dXJuKGEueC1lLngpKih0LnktZS55KS0odC54LWUueCkqKGEueS1lLnkpPDB9c3RhdGljIFJlc2NhbGUoZSx0KXtjb25zdCBhPWd0LkxlbihlKTtyZXR1cm4gbmV3IGd0KHQqZS54L2EsdCplLnkvYSl9c3RhdGljIFNjYWxlV2l0aE9yaWdpbihlLHQsYSl7cmV0dXJuIGd0LlN1YihlLGEpLm11bCh0KS5hZGQoYSl9c3RhdGljIFRvRml4ZWQoZSx0PTIpe3JldHVybiBuZXcgZ3QoK2UueC50b0ZpeGVkKHQpLCtlLnkudG9GaXhlZCh0KSwrZS56LnRvRml4ZWQodCkpfXN0YXRpYyBOdWRnZShlLHQsYSl7cmV0dXJuIGd0LkFkZChlLGd0LlRhbih0LGUpLm11bChhKSl9c3RhdGljIFRvU3RyaW5nKGUpe3JldHVybmAke2UueH0sICR7ZS55fWB9c3RhdGljIFRvQW5nbGUoZSl7bGV0IHQ9TWF0aC5hdGFuMihlLnksZS54KTtyZXR1cm4gdDwwJiYodCs9TWF0aC5QSSoyKSx0fXN0YXRpYyBGcm9tQW5nbGUoZSx0PTEpe3JldHVybiBuZXcgZ3QoTWF0aC5jb3MoZSkqdCxNYXRoLnNpbihlKSp0KX1zdGF0aWMgVG9BcnJheShlKXtyZXR1cm5bZS54LGUueSxlLnpdfXN0YXRpYyBUb0pzb24oZSl7Y29uc3R7eDp0LHk6YSx6Om99PWU7cmV0dXJue3g6dCx5OmEsejpvfX1zdGF0aWMgQXZlcmFnZShlKXtjb25zdCB0PWUubGVuZ3RoLGE9bmV3IGd0KDAsMCk7Zm9yKGxldCBvPTA7bzx0O28rKylhLmFkZChlW29dKTtyZXR1cm4gYS5kaXYodCl9c3RhdGljIENsYW1wKGUsdCxhKXtyZXR1cm4gYT09PXZvaWQgMD9uZXcgZ3QoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpKSxNYXRoLm1pbihNYXRoLm1heChlLnksdCkpKTpuZXcgZ3QoTWF0aC5taW4oTWF0aC5tYXgoZS54LHQpLGEpLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSxhKSl9c3RhdGljIFBvaW50c0JldHdlZW4oZSx0LGE9Nil7Y29uc3Qgbz1bXTtmb3IobGV0IHY9MDt2PGE7disrKXtjb25zdCBUPWZlLmVhc2VJblF1YWQodi8oYS0xKSksZD1ndC5McnAoZSx0LFQpO2Quej1NYXRoLm1pbigxLC41K01hdGguYWJzKC41LXVlKFQpKSouNjUpLG8ucHVzaChkKX1yZXR1cm4gb31zdGF0aWMgU25hcFRvR3JpZChlLHQ9OCl7cmV0dXJuIG5ldyBndChNYXRoLnJvdW5kKGUueC90KSp0LE1hdGgucm91bmQoZS55L3QpKnQpfX1jb25zdCB1ZT1MPT5MPC41PzIqTCpMOi0xKyg0LTIqTCkqTDtjbGFzcyBBdCBleHRlbmRzIGd0e2NvbnN0cnVjdG9yKGU9MCx0PTAsYT0wLG89e3g6MCx5OjB9LHY9MCxUPTApe3N1cGVyKGUsdCxhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm99KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlR9KX1nZXQgdGltZXN0YW1wKCl7cmV0dXJuIHRoaXMudH1nZXQgcHJlc3N1cmUoKXtyZXR1cm4gdGhpcy56fWdldCBhbmdsZU51bSgpe3JldHVybiB0aGlzLmF9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldEEoZSl7dGhpcy5hPWV9c2V0VChlKXt0aGlzLnQ9ZX1zZXR2KGUpe3JldHVybiB0aGlzLnY9e3g6ZS54LHk6ZS55fSx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxhPXRoaXMueixvPXRoaXMudix2PXRoaXMudCxUPXRoaXMuYSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1hLHRoaXMudj1vLHRoaXMudD12LHRoaXMuYT1ULHRoaXN9Y2xvbmUoKXtjb25zdHt4OmUseTp0LHo6YSx2Om8sdDp2LGE6VH09dGhpcyxkPXt4Om8ueCx5Om8ueX07cmV0dXJuIG5ldyBBdChlLHQsYSxkLHYsVCl9ZGlzdGFuY2UoZSl7cmV0dXJuIEF0LkdldERpc3RhbmNlKHRoaXMsZSl9aXNOZWFyKGUsdCl7cmV0dXJuIEF0LklzTmVhcih0aGlzLGUsdCl9Z2V0QW5nbGVCeVBvaW50cyhlLHQpe3JldHVybiBBdC5HZXRBbmdsZUJ5UG9pbnRzKGUsdGhpcyx0KX1zdGF0aWMgU3ViKGUsdCl7cmV0dXJuIG5ldyBBdChlLngtdC54LGUueS10LnkpfXN0YXRpYyBBZGQoZSx0KXtyZXR1cm4gbmV3IEF0KGUueCt0LngsZS55K3QueSl9c3RhdGljIEdldERpc3RhbmNlKGUsdCl7cmV0dXJuIEF0LkxlbihlLmNsb25lKCkuc3ViKHQpKX1zdGF0aWMgR2V0QW5nbGVCeVBvaW50cyhlLHQsYSl7Y29uc3Qgbz10LngtZS54LHY9YS54LXQueCxUPXQueS1lLnksZD1hLnktdC55O2xldCB1PTA7Y29uc3QgYz1NYXRoLnNxcnQobypvK1QqVCksRT1NYXRoLnNxcnQodip2K2QqZCk7aWYoYyYmRSl7Y29uc3QgZj1vKnYrVCpkO3U9TWF0aC5hY29zKGYvKGMqRSkpLHU9dS9NYXRoLlBJKjE4MDtsZXQgZz1vKmQtVCp2O2c9Zz4wPzE6LTEsdT0xODArZyp1fXJldHVybiB1fXN0YXRpYyBJc05lYXIoZSx0LGEpe3JldHVybiBBdC5MZW4oZS5jbG9uZSgpLnN1Yih0KSk8YX1zdGF0aWMgUm90V2l0aChlLHQsYSxvPTIpe2NvbnN0IHY9ZS54LXQueCxUPWUueS10LnksZD1NYXRoLnNpbihhKSx1PU1hdGguY29zKGEpLGM9TWF0aC5wb3coMTAsbyksRT1NYXRoLmZsb29yKCh0LngrKHYqdS1UKmQpKSpjKS9jLGY9TWF0aC5mbG9vcigodC55Kyh2KmQrVCp1KSkqYykvYztyZXR1cm4gbmV3IEF0KEUsZil9c3RhdGljIEdldERvdFN0cm9rZShlLHQsYT0xNil7Y29uc3Qgbz1uZXcgZ3QoMSwxKSx2PU1hdGguUEkrLjAwMSxUPUF0LkFkZChlLEF0LlN1YihlLG8pLnVuaSgpLnBlcigpLm11bCgtdCkpLGQ9W107Zm9yKGxldCB1PTEvYSxjPXU7Yzw9MTtjKz11KWQucHVzaChBdC5Sb3RXaXRoKFQsZSx2KjIqYykpO3JldHVybiBkfXN0YXRpYyBHZXRTZW1pY2lyY2xlU3Ryb2tlKGUsdCxhPS0xLG89OCl7Y29uc3Qgdj1hKihNYXRoLlBJKy4wMDEpLFQ9W107Zm9yKGxldCBkPTEvbyx1PWQ7dTw9MTt1Kz1kKVQucHVzaChBdC5Sb3RXaXRoKHQsZSx2KnUpKTtyZXR1cm4gVH19ZnVuY3Rpb24gQnQoTCxlKXtpZihMJiZlKXtjb25zdCB0PU1hdGgubWluKEw9PW51bGw/dm9pZCAwOkwueCxlLngpLGE9TWF0aC5taW4oTD09bnVsbD92b2lkIDA6TC55LGUueSksbz1NYXRoLm1heChMLngrTC53LGUueCtlLncpLHY9TWF0aC5tYXgoTC55K0wuaCxlLnkrZS5oKSxUPW8tdCxkPXYtYTtyZXR1cm57eDp0LHk6YSx3OlQsaDpkfX1yZXR1cm4gZXx8TH1mdW5jdGlvbiAkdChMLGU9MCl7Y29uc3QgdD17eDowLHk6MCx3OjAsaDowfTtsZXQgYT10Lngsbz10Lnksdj10LngsVD10Lnk7cmV0dXJuIEwuZm9yRWFjaChkPT57Y29uc3RbdSxjXT1kLlhZO2E9TWF0aC5taW4oYSx1LWUpLG89TWF0aC5taW4obyxjLWUpLHY9TWF0aC5tYXgodix1K2UpLFQ9TWF0aC5tYXgoVCxjK2UpfSksdC54PWEsdC55PW8sdC53PXYtYSx0Lmg9VC1vLHR9ZnVuY3Rpb24gS3QoTCl7cmV0dXJuYCR7SnQoTC54KX0sJHtKdChMLnkpfSBgfWZ1bmN0aW9uIEh0KEwsZSl7cmV0dXJuYCR7SnQoKEwueCtlLngpLzIpfSwke0p0KChMLnkrZS55KS8yKX0gYH1mdW5jdGlvbiBKdChMKXtyZXR1cm4rTC50b0ZpeGVkKDQpfWZ1bmN0aW9uIFF0KEwsZT0hMCl7Y29uc3QgdD1MLmxlbmd0aDtpZih0PDIpcmV0dXJuIiI7bGV0IGE9TFswXSxvPUxbMV07aWYodD09PTIpcmV0dXJuYE0ke0t0KGEpfUwke0t0KG8pfWA7bGV0IHY9IiI7Zm9yKGxldCBUPTIsZD10LTE7VDxkO1QrKylhPUxbVF0sbz1MW1QrMV0sdis9SHQoYSxvKTtyZXR1cm4gZT9gTSR7SHQoTFswXSxMWzFdKX1RJHtLdChMWzFdKX0ke0h0KExbMV0sTFsyXSl9VCR7dn0ke0h0KExbdC0xXSxMWzBdKX0ke0h0KExbMF0sTFsxXSl9WmA6YE0ke0t0KExbMF0pfVEke0t0KExbMV0pfSR7SHQoTFsxXSxMWzJdKX0ke0wubGVuZ3RoPjM/IlQiOiIifSR7dn1MJHtLdChMW3QtMV0pfWB9dmFyIHd0PXtleHBvcnRzOnt9fTt3dC5leHBvcnRzLGZ1bmN0aW9uKEwpe3ZhciBlPWZ1bmN0aW9uKCl7dmFyIHQ9U3RyaW5nLmZyb21DaGFyQ29kZSxhPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSIsbz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLSQiLHY9e307ZnVuY3Rpb24gVCh1LGMpe2lmKCF2W3VdKXt2W3VdPXt9O2Zvcih2YXIgRT0wO0U8dS5sZW5ndGg7RSsrKXZbdV1bdS5jaGFyQXQoRSldPUV9cmV0dXJuIHZbdV1bY119dmFyIGQ9e2NvbXByZXNzVG9CYXNlNjQ6ZnVuY3Rpb24odSl7aWYodT09bnVsbClyZXR1cm4iIjt2YXIgYz1kLl9jb21wcmVzcyh1LDYsZnVuY3Rpb24oRSl7cmV0dXJuIGEuY2hhckF0KEUpfSk7c3dpdGNoKGMubGVuZ3RoJTQpe2RlZmF1bHQ6Y2FzZSAwOnJldHVybiBjO2Nhc2UgMTpyZXR1cm4gYysiPT09IjtjYXNlIDI6cmV0dXJuIGMrIj09IjtjYXNlIDM6cmV0dXJuIGMrIj0ifX0sZGVjb21wcmVzc0Zyb21CYXNlNjQ6ZnVuY3Rpb24odSl7cmV0dXJuIHU9PW51bGw/IiI6dT09IiI/bnVsbDpkLl9kZWNvbXByZXNzKHUubGVuZ3RoLDMyLGZ1bmN0aW9uKGMpe3JldHVybiBUKGEsdS5jaGFyQXQoYykpfSl9LGNvbXByZXNzVG9VVEYxNjpmdW5jdGlvbih1KXtyZXR1cm4gdT09bnVsbD8iIjpkLl9jb21wcmVzcyh1LDE1LGZ1bmN0aW9uKGMpe3JldHVybiB0KGMrMzIpfSkrIiAifSxkZWNvbXByZXNzRnJvbVVURjE2OmZ1bmN0aW9uKHUpe3JldHVybiB1PT1udWxsPyIiOnU9PSIiP251bGw6ZC5fZGVjb21wcmVzcyh1Lmxlbmd0aCwxNjM4NCxmdW5jdGlvbihjKXtyZXR1cm4gdS5jaGFyQ29kZUF0KGMpLTMyfSl9LGNvbXByZXNzVG9VaW50OEFycmF5OmZ1bmN0aW9uKHUpe2Zvcih2YXIgYz1kLmNvbXByZXNzKHUpLEU9bmV3IFVpbnQ4QXJyYXkoYy5sZW5ndGgqMiksZj0wLGc9Yy5sZW5ndGg7ZjxnO2YrKyl7dmFyIHk9Yy5jaGFyQ29kZUF0KGYpO0VbZioyXT15Pj4+OCxFW2YqMisxXT15JTI1Nn1yZXR1cm4gRX0sZGVjb21wcmVzc0Zyb21VaW50OEFycmF5OmZ1bmN0aW9uKHUpe2lmKHU9PW51bGwpcmV0dXJuIGQuZGVjb21wcmVzcyh1KTtmb3IodmFyIGM9bmV3IEFycmF5KHUubGVuZ3RoLzIpLEU9MCxmPWMubGVuZ3RoO0U8ZjtFKyspY1tFXT11W0UqMl0qMjU2K3VbRSoyKzFdO3ZhciBnPVtdO3JldHVybiBjLmZvckVhY2goZnVuY3Rpb24oeSl7Zy5wdXNoKHQoeSkpfSksZC5kZWNvbXByZXNzKGcuam9pbigiIikpfSxjb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbih1KXtyZXR1cm4gdT09bnVsbD8iIjpkLl9jb21wcmVzcyh1LDYsZnVuY3Rpb24oYyl7cmV0dXJuIG8uY2hhckF0KGMpfSl9LGRlY29tcHJlc3NGcm9tRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbih1KXtyZXR1cm4gdT09bnVsbD8iIjp1PT0iIj9udWxsOih1PXUucmVwbGFjZSgvIC9nLCIrIiksZC5fZGVjb21wcmVzcyh1Lmxlbmd0aCwzMixmdW5jdGlvbihjKXtyZXR1cm4gVChvLHUuY2hhckF0KGMpKX0pKX0sY29tcHJlc3M6ZnVuY3Rpb24odSl7cmV0dXJuIGQuX2NvbXByZXNzKHUsMTYsZnVuY3Rpb24oYyl7cmV0dXJuIHQoYyl9KX0sX2NvbXByZXNzOmZ1bmN0aW9uKHUsYyxFKXtpZih1PT1udWxsKXJldHVybiIiO3ZhciBmLGcseT17fSxDPXt9LHg9IiIsaD0iIixtPSIiLHI9MixpPTMsbj0yLHM9W10sTT0wLFA9MCxTO2ZvcihTPTA7Uzx1Lmxlbmd0aDtTKz0xKWlmKHg9dS5jaGFyQXQoUyksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHkseCl8fCh5W3hdPWkrKyxDW3hdPSEwKSxoPW0reCxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeSxoKSltPWg7ZWxzZXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQyxtKSl7aWYobS5jaGFyQ29kZUF0KDApPDI1Nil7Zm9yKGY9MDtmPG47ZisrKU09TTw8MSxQPT1jLTE/KFA9MCxzLnB1c2goRShNKSksTT0wKTpQKys7Zm9yKGc9bS5jaGFyQ29kZUF0KDApLGY9MDtmPDg7ZisrKU09TTw8MXxnJjEsUD09Yy0xPyhQPTAscy5wdXNoKEUoTSkpLE09MCk6UCsrLGc9Zz4+MX1lbHNle2ZvcihnPTEsZj0wO2Y8bjtmKyspTT1NPDwxfGcsUD09Yy0xPyhQPTAscy5wdXNoKEUoTSkpLE09MCk6UCsrLGc9MDtmb3IoZz1tLmNoYXJDb2RlQXQoMCksZj0wO2Y8MTY7ZisrKU09TTw8MXxnJjEsUD09Yy0xPyhQPTAscy5wdXNoKEUoTSkpLE09MCk6UCsrLGc9Zz4+MX1yLS0scj09MCYmKHI9TWF0aC5wb3coMixuKSxuKyspLGRlbGV0ZSBDW21dfWVsc2UgZm9yKGc9eVttXSxmPTA7ZjxuO2YrKylNPU08PDF8ZyYxLFA9PWMtMT8oUD0wLHMucHVzaChFKE0pKSxNPTApOlArKyxnPWc+PjE7ci0tLHI9PTAmJihyPU1hdGgucG93KDIsbiksbisrKSx5W2hdPWkrKyxtPVN0cmluZyh4KX1pZihtIT09IiIpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChDLG0pKXtpZihtLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IoZj0wO2Y8bjtmKyspTT1NPDwxLFA9PWMtMT8oUD0wLHMucHVzaChFKE0pKSxNPTApOlArKztmb3IoZz1tLmNoYXJDb2RlQXQoMCksZj0wO2Y8ODtmKyspTT1NPDwxfGcmMSxQPT1jLTE/KFA9MCxzLnB1c2goRShNKSksTT0wKTpQKyssZz1nPj4xfWVsc2V7Zm9yKGc9MSxmPTA7ZjxuO2YrKylNPU08PDF8ZyxQPT1jLTE/KFA9MCxzLnB1c2goRShNKSksTT0wKTpQKyssZz0wO2ZvcihnPW0uY2hhckNvZGVBdCgwKSxmPTA7ZjwxNjtmKyspTT1NPDwxfGcmMSxQPT1jLTE/KFA9MCxzLnB1c2goRShNKSksTT0wKTpQKyssZz1nPj4xfXItLSxyPT0wJiYocj1NYXRoLnBvdygyLG4pLG4rKyksZGVsZXRlIENbbV19ZWxzZSBmb3IoZz15W21dLGY9MDtmPG47ZisrKU09TTw8MXxnJjEsUD09Yy0xPyhQPTAscy5wdXNoKEUoTSkpLE09MCk6UCsrLGc9Zz4+MTtyLS0scj09MCYmKHI9TWF0aC5wb3coMixuKSxuKyspfWZvcihnPTIsZj0wO2Y8bjtmKyspTT1NPDwxfGcmMSxQPT1jLTE/KFA9MCxzLnB1c2goRShNKSksTT0wKTpQKyssZz1nPj4xO2Zvcig7OylpZihNPU08PDEsUD09Yy0xKXtzLnB1c2goRShNKSk7YnJlYWt9ZWxzZSBQKys7cmV0dXJuIHMuam9pbigiIil9LGRlY29tcHJlc3M6ZnVuY3Rpb24odSl7cmV0dXJuIHU9PW51bGw/IiI6dT09IiI/bnVsbDpkLl9kZWNvbXByZXNzKHUubGVuZ3RoLDMyNzY4LGZ1bmN0aW9uKGMpe3JldHVybiB1LmNoYXJDb2RlQXQoYyl9KX0sX2RlY29tcHJlc3M6ZnVuY3Rpb24odSxjLEUpe3ZhciBmPVtdLGc9NCx5PTQsQz0zLHg9IiIsaD1bXSxtLHIsaSxuLHMsTSxQLFM9e3ZhbDpFKDApLHBvc2l0aW9uOmMsaW5kZXg6MX07Zm9yKG09MDttPDM7bSs9MSlmW21dPW07Zm9yKGk9MCxzPU1hdGgucG93KDIsMiksTT0xO00hPXM7KW49Uy52YWwmUy5wb3NpdGlvbixTLnBvc2l0aW9uPj49MSxTLnBvc2l0aW9uPT0wJiYoUy5wb3NpdGlvbj1jLFMudmFsPUUoUy5pbmRleCsrKSksaXw9KG4+MD8xOjApKk0sTTw8PTE7c3dpdGNoKGkpe2Nhc2UgMDpmb3IoaT0wLHM9TWF0aC5wb3coMiw4KSxNPTE7TSE9czspbj1TLnZhbCZTLnBvc2l0aW9uLFMucG9zaXRpb24+Pj0xLFMucG9zaXRpb249PTAmJihTLnBvc2l0aW9uPWMsUy52YWw9RShTLmluZGV4KyspKSxpfD0obj4wPzE6MCkqTSxNPDw9MTtQPXQoaSk7YnJlYWs7Y2FzZSAxOmZvcihpPTAscz1NYXRoLnBvdygyLDE2KSxNPTE7TSE9czspbj1TLnZhbCZTLnBvc2l0aW9uLFMucG9zaXRpb24+Pj0xLFMucG9zaXRpb249PTAmJihTLnBvc2l0aW9uPWMsUy52YWw9RShTLmluZGV4KyspKSxpfD0obj4wPzE6MCkqTSxNPDw9MTtQPXQoaSk7YnJlYWs7Y2FzZSAyOnJldHVybiIifWZvcihmWzNdPVAscj1QLGgucHVzaChQKTs7KXtpZihTLmluZGV4PnUpcmV0dXJuIiI7Zm9yKGk9MCxzPU1hdGgucG93KDIsQyksTT0xO00hPXM7KW49Uy52YWwmUy5wb3NpdGlvbixTLnBvc2l0aW9uPj49MSxTLnBvc2l0aW9uPT0wJiYoUy5wb3NpdGlvbj1jLFMudmFsPUUoUy5pbmRleCsrKSksaXw9KG4+MD8xOjApKk0sTTw8PTE7c3dpdGNoKFA9aSl7Y2FzZSAwOmZvcihpPTAscz1NYXRoLnBvdygyLDgpLE09MTtNIT1zOyluPVMudmFsJlMucG9zaXRpb24sUy5wb3NpdGlvbj4+PTEsUy5wb3NpdGlvbj09MCYmKFMucG9zaXRpb249YyxTLnZhbD1FKFMuaW5kZXgrKykpLGl8PShuPjA/MTowKSpNLE08PD0xO2ZbeSsrXT10KGkpLFA9eS0xLGctLTticmVhaztjYXNlIDE6Zm9yKGk9MCxzPU1hdGgucG93KDIsMTYpLE09MTtNIT1zOyluPVMudmFsJlMucG9zaXRpb24sUy5wb3NpdGlvbj4+PTEsUy5wb3NpdGlvbj09MCYmKFMucG9zaXRpb249YyxTLnZhbD1FKFMuaW5kZXgrKykpLGl8PShuPjA/MTowKSpNLE08PD0xO2ZbeSsrXT10KGkpLFA9eS0xLGctLTticmVhaztjYXNlIDI6cmV0dXJuIGguam9pbigiIil9aWYoZz09MCYmKGc9TWF0aC5wb3coMixDKSxDKyspLGZbUF0peD1mW1BdO2Vsc2UgaWYoUD09PXkpeD1yK3IuY2hhckF0KDApO2Vsc2UgcmV0dXJuIG51bGw7aC5wdXNoKHgpLGZbeSsrXT1yK3guY2hhckF0KDApLGctLSxyPXgsZz09MCYmKGc9TWF0aC5wb3coMixDKSxDKyspfX19O3JldHVybiBkfSgpO0whPW51bGw/TC5leHBvcnRzPWU6dHlwZW9mIGFuZ3VsYXI8InUiJiZhbmd1bGFyIT1udWxsJiZhbmd1bGFyLm1vZHVsZSgiTFpTdHJpbmciLFtdKS5mYWN0b3J5KCJMWlN0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gZX0pfSh3dCk7dmFyIHJlPXd0LmV4cG9ydHM7ZnVuY3Rpb24gY2UoTCl7cmV0dXJuIEpTT04ucGFyc2UocmUuZGVjb21wcmVzcyhMKSl9ZnVuY3Rpb24gaGUoTCl7cmV0dXJuIHJlLmNvbXByZXNzKEpTT04uc3RyaW5naWZ5KEwpKX12YXIgbmU7KGZ1bmN0aW9uKEwpe0xbTC5wZWRkaW5nPTBdPSJwZWRkaW5nIixMW0wubW91bnRlZD0xXT0ibW91bnRlZCIsTFtMLnVwZGF0ZT0yXT0idXBkYXRlIixMW0wudW5tb3VudGVkPTNdPSJ1bm1vdW50ZWQifSkobmV8fChuZT17fSkpO3ZhciBqdDsoZnVuY3Rpb24oTCl7TFtMLk5vcm1hbD0wXT0iTm9ybWFsIixMW0wuU3Ryb2tlPTFdPSJTdHJva2UiLExbTC5Eb3R0ZWQ9Ml09IkRvdHRlZCIsTFtMLkxvbmdEb3R0ZWQ9M109IkxvbmdEb3R0ZWQifSkoanR8fChqdD17fSkpO2NsYXNzIGllIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IoZSx0LGEpe3N1cGVyKHQsYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlB0LlBlbmNpbH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiTUFYX1JFUEVBUiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInVuaVRoaWNrbmVzcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrT3B0aW9ucyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMud29ya09wdGlvbnM9ZSx0aGlzLnVuaVRoaWNrbmVzcz10aGlzLk1BWF9SRVBFQVIvZS50aGlja25lc3MvMTAsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tYmluZUNvbnN1bWUoKXt2YXIgdjtjb25zdCBlPSh2PXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6di50b1N0cmluZygpLHQ9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCksYT17bmFtZTplLGNsYXNzTmFtZToicGVuY2lsIn07bGV0IG87cmV0dXJuIHQubGVuZ3RoJiYobz10aGlzLmRyYXcoe2F0dHJzOmEsdGFza3M6dCxyZXBsYWNlSWQ6ZSxpc0Z1bGxXb3JrOiExfSkpLHtyZWN0Om8sdHlwZTpUdC5EcmF3V29yayxkYXRhVHlwZTpSdC5Mb2NhbH19c2V0V29ya09wdGlvbnMoZSl7dGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbnN1bWUoZSx0KXt2YXIgZztpZigoKGc9ZS5vcCk9PW51bGw/dm9pZCAwOmcubGVuZ3RoKT09PTApcmV0dXJue3R5cGU6VHQuTm9uZX07Y29uc3R7d29ya0lkOmF9PWUse3Rhc2tzOm8sZWZmZWN0czp2LGNvbnN1bWVJbmRleDpUfT10aGlzLnRyYW5zZm9ybURhdGEoZSwhMSk7dGhpcy5zeW5jSW5kZXg9TWF0aC5taW4odGhpcy5zeW5jSW5kZXgsVCk7Y29uc3QgZD17bmFtZTphPT1udWxsP3ZvaWQgMDphLnRvU3RyaW5nKCksY2xhc3NOYW1lOiJwZW5jaWwifTtsZXQgdSxjPSExO2NvbnN0IEU9dGhpcy5zeW5jSW5kZXg7dGhpcy5zeW5jVGltZXN0YW1wPT09MCYmKHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpKSxvLmxlbmd0aCYmKG9bMF0udGFza0lkLXRoaXMuc3luY1RpbWVzdGFtcD50aGlzLnN5bmNVbml0VGltZSYmKGM9ITAsdGhpcy5zeW5jVGltZXN0YW1wPW9bMF0udGFza0lkLHRoaXMuc3luY0luZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aCksdT10aGlzLmRyYXcoe2F0dHJzOmQsdGFza3M6byxlZmZlY3RzOnYsaXNGdWxsV29yazp0fSkpO2NvbnN0IGY9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKEUpLmZvckVhY2goeT0+e2YucHVzaCh5LngseS55LHkueil9KSx7cmVjdDp1LHR5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6UnQuTG9jYWwsd29ya0lkOmM/YTp2b2lkIDAsb3A6Yz9mOnZvaWQgMCxpbmRleDpjP0UqMzp2b2lkIDB9fWNvbnN1bWVBbGwoZSl7dmFyIGQ7aWYoZSl7Y29uc3R7b3A6dSx3b3JrU3RhdGU6Y309ZTt1IT1udWxsJiZ1Lmxlbmd0aCYmYz09PUd0LkRvbmUmJnRoaXMud29ya09wdGlvbnMuc3Ryb2tlVHlwZT09PWp0LlN0cm9rZSYmdGhpcy51cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlV2hlbkRvbmUodSl9Y29uc3QgdD0oZD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmQudG9TdHJpbmcoKSxhPXRoaXMudHJhbnNmb3JtRGF0YUFsbCgpLG89e25hbWU6dCxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCB2O2EubGVuZ3RoJiYodj10aGlzLmRyYXcoe2F0dHJzOm8sdGFza3M6YSxyZXBsYWNlSWQ6dCxpc0Z1bGxXb3JrOiEwfSkpO2NvbnN0IFQ9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLm1hcCh1PT57VC5wdXNoKHUueCx1LnksdS56KX0pLHRoaXMuc3luY1RpbWVzdGFtcD0wLHtyZWN0OnYsdHlwZTpUdC5GdWxsV29yayxkYXRhVHlwZTpSdC5Mb2NhbCx3b3JrSWQ6dCxvcHM6aGUoVCl9fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jSW5kZXg9MH1jb25zdW1lU2VydmljZShlLHQpe3ZhciBUO3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wO2ZvcihsZXQgZD0wO2Q8ZS5sZW5ndGg7ZCs9Myl7Y29uc3QgdT1uZXcgQXQoZVtkXSxlW2QrMV0sZVtkKzJdKTtpZih0aGlzLnRtcFBvaW50cy5sZW5ndGg+MCl7Y29uc3QgYz10aGlzLnRtcFBvaW50c1t0aGlzLnRtcFBvaW50cy5sZW5ndGgtMV0sRT1ndC5TdWIodSxjKS51bmkoKTt1LnNldHYoRSl9dGhpcy50bXBQb2ludHMucHVzaCh1KX1jb25zdCBhPXRoaXMudHJhbnNmb3JtRGF0YUFsbCgpLG89e25hbWU6KFQ9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpULnRvU3RyaW5nKCksY2xhc3NOYW1lOiJwZW5jaWwifTtsZXQgdjtyZXR1cm4gYS5sZW5ndGgmJih2PXRoaXMuZHJhdyh7YXR0cnM6byx0YXNrczphLHJlcGxhY2VJZDp0P3RoaXMud29ya0lkOnZvaWQgMCxpc0Z1bGxXb3JrOnR9KSksdn10cmFuc2Zvcm1EYXRhQWxsKCl7cmV0dXJuIHRoaXMuZ2V0VGFza1BvaW50cyh0aGlzLnRtcFBvaW50cyx0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcyl9ZHJhdyhlKXtjb25zdHthdHRyczp0LHRhc2tzOmEscmVwbGFjZUlkOm8sZWZmZWN0czp2LGlzRnVsbFdvcms6VH09ZSxkPVQ/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXJ8fHRoaXMuZnVsbExheWVyLHtjb2xvcjp1LHN0cm9rZVR5cGU6Yyx0aGlja25lc3M6RSxvcGFjaXR5OmZ9PXRoaXMud29ya09wdGlvbnM7VD8obyYmZC5nZXRFbGVtZW50c0J5TmFtZShvKyIiKS5tYXAoeT0+eS5yZW1vdmUoKSksdiE9bnVsbCYmdi5zaXplJiYodi5mb3JFYWNoKHk9Pntjb25zdCBDPWQuZ2V0RWxlbWVudEJ5SWQoeSsiIik7Qz09bnVsbHx8Qy5yZW1vdmUoKX0pLHYuY2xlYXIoKSkpOmQucmVtb3ZlQWxsQ2hpbGRyZW4oKTtsZXQgZztmb3IobGV0IHk9MDt5PGEubGVuZ3RoO3krKyl7Y29uc3R7cG9zOkMscG9pbnRzOngsdGFza0lkOmh9PWFbeV07dC5pZD1oLnRvU3RyaW5nKCk7Y29uc3QgbT1uZXcgZWUse3BzOnIscmVjdDppfT10aGlzLmNvbXB1dERyYXdQb2ludHMoeCk7bGV0IG47Y29uc3Qgcz14Lmxlbmd0aD09PTE7Yz09PWp0LlN0cm9rZXx8cz9uPVF0KHIsITApOm49UXQociwhMSksbS5hdHRyKHsuLi50LHBvczpDLGQ6bixmaWxsQ29sb3I6Yz09PWp0LlN0cm9rZXx8cz91OnZvaWQgMCxvcGFjaXR5OmZ8fDEsbGluZURhc2g6Yz09PWp0LkRvdHRlZCYmIXM/WzEsRSoyXTpjPT09anQuTG9uZ0RvdHRlZCYmIXM/W0UsRSoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6dSxsaW5lQ2FwOmM9PT1qdC5TdHJva2V8fHM/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOmM9PT1qdC5TdHJva2V8fHM/MDpFfSksZz1CdChnLHt4Ok1hdGguZmxvb3IoaS54K0NbMF0tMTApLHk6TWF0aC5mbG9vcihpLnkrQ1sxXS0xMCksdzpNYXRoLmZsb29yKGkudysyMCksaDpNYXRoLmZsb29yKGkuaCsyMCl9KTtjb25zdHt2ZXJ0ZXg6TSxmcmFnbWVudDpQfT10aGlzLndvcmtPcHRpb25zO2lmKE0mJlApe2NvbnN0IFM9ZC5yZW5kZXJlci5jcmVhdGVQcm9ncmFtKHt2ZXJ0ZXg6TSxmcmFnbWVudDpQfSkse3dpZHRoOmIsaGVpZ2h0Ok99PWQuZ2V0UmVzb2x1dGlvbigpO20uc2V0VW5pZm9ybXMoe3VfdGltZTowLHVfcmVzb2x1dGlvbjpbYixPXX0pLG0uc2V0UHJvZ3JhbShTKX0hVCYmdGhpcy5kcmF3TGF5ZXImJlByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzLmZ1bGxMYXllci5hcHBlbmRDaGlsZChtLmNsb25lTm9kZSgpKX0pLGQuYXBwZW5kQ2hpbGQobSl9cmV0dXJuIGd9Y29tcHV0RHJhd1BvaW50cyhlKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09anQuU3Ryb2tlfHxlLmxlbmd0aD09PTE/dGhpcy5jb21wdXRTdHJva2UoZSk6dGhpcy5jb21wdXROb21hbChlKX1jb21wdXROb21hbChlKXtjb25zdCB0PWUubWFwKGE9PmEucG9pbnQpO3JldHVybntwczp0LHJlY3Q6JHQodCx0aGlzLndvcmtPcHRpb25zLnRoaWNrbmVzcyl9fWNvbXB1dFN0cm9rZShlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP3RoaXMuY29tcHV0RG90U3Ryb2tlKGVbMF0pOnRoaXMuY29tcHV0TGluZVN0cm9rZShlKX1jb21wdXRMaW5lU3Ryb2tlKGUpe2NvbnN0IHQ9W10sYT1bXTtmb3IobGV0IHU9MDt1PGUubGVuZ3RoO3UrKyl7Y29uc3R7cG9pbnQ6YyxyYWRpdXM6RX09ZVt1XTtsZXQgZj1jLnY7dT09PTAmJmUubGVuZ3RoPjEmJihmPWVbdSsxXS5wb2ludC52KTtjb25zdCBnPWd0LlBlcihmKS5tdWwoRSk7dC5wdXNoKEF0LlN1YihjLGcpKSxhLnB1c2goQXQuQWRkKGMsZykpfWNvbnN0IG89ZVtlLmxlbmd0aC0xXSx2PUF0LkdldFNlbWljaXJjbGVTdHJva2Uoby5wb2ludCx0W3QubGVuZ3RoLTFdLC0xLDgpLFQ9QXQuR2V0U2VtaWNpcmNsZVN0cm9rZShlWzBdLnBvaW50LGFbMF0sLTEsOCksZD10LmNvbmNhdCh2LGEucmV2ZXJzZSgpLFQpO3JldHVybntwczpkLHJlY3Q6JHQoZCl9fWNvbXB1dERvdFN0cm9rZShlKXtjb25zdHtwb2ludDp0LHJhZGl1czphfT1lLG89e3g6dC54LWEseTp0LnktYSx3OmEqMixoOmEqMn07cmV0dXJue3BzOkF0LkdldERvdFN0cm9rZSh0LGEsOCkscmVjdDpvfX10cmFuc2Zvcm1EYXRhKGUsdCl7Y29uc3R7b3A6YSx3b3JrU3RhdGU6b309ZTtsZXQgdj10aGlzLnRtcFBvaW50cy5sZW5ndGgtMSxUPVtdO2lmKGEhPW51bGwmJmEubGVuZ3RoJiZvKXtjb25zdHtzdHJva2VUeXBlOmQsdGhpY2tuZXNzOnV9PXRoaXMud29ya09wdGlvbnMsYz1uZXcgU2V0O3Y9ZD09PWp0LlN0cm9rZT90aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmUoYSx1LGMpOnRoaXMudXBkYXRlVGVtcFBvaW50cyhhLHUsYyk7Y29uc3QgRT10P3RoaXMudG1wUG9pbnRzOnRoaXMudG1wUG9pbnRzLnNsaWNlKHYpO3JldHVybiBUPXRoaXMuZ2V0VGFza1BvaW50cyhFLHUpLHt0YXNrczpULGVmZmVjdHM6Yyxjb25zdW1lSW5kZXg6dn19cmV0dXJue3Rhc2tzOlQsY29uc3VtZUluZGV4OnZ9fWNvbXB1dFJhZGl1cyhlLHQpe3JldHVybiBlKi4zK3QqLjV9Z2V0VGFza1BvaW50cyhlLHQpe3ZhciBFO2NvbnN0IGE9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCBvPTAsdj1lWzBdLngsVD1lWzBdLnksZD1bdixUXSx1PVtdLGM9ZVswXS50O2Zvcig7bzxlLmxlbmd0aDspe2NvbnN0IGY9ZVtvXSxnPWYueC12LHk9Zi55LVQsQz1mLnoseD10aGlzLmNvbXB1dFJhZGl1cyhDLHQpO2lmKHUucHVzaCh7cG9pbnQ6bmV3IEF0KGcseSxDLGVbb10udikscmFkaXVzOnh9KSxvPjAmJm88ZS5sZW5ndGgtMSl7Y29uc3QgaD1lW29dLmdldEFuZ2xlQnlQb2ludHMoZVtvLTFdLGVbbysxXSk7aWYoaDw5MHx8aD4yNzApe2NvbnN0IG09KEU9dS5wb3AoKSk9PW51bGw/dm9pZCAwOkUucG9pbnQuY2xvbmUoKTttJiZhLnB1c2goe3Rhc2tJZDpjLHBvczpkLHBvaW50czpbLi4udSx7cG9pbnQ6bSxyYWRpdXM6eH1dfSksdj1lW29dLngsVD1lW29dLnksZD1bdixUXTtjb25zdCByPWYueC12LGk9Zi55LVQ7dT1be3BvaW50Om5ldyBBdChyLGksQykscmFkaXVzOnh9XSxjPURhdGUubm93KCl9fW8rK31yZXR1cm4gYS5wdXNoKHt0YXNrSWQ6Yyxwb3M6ZCxwb2ludHM6dX0pLGF9dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShlLHQsYSl7Y29uc3Qgbz1EYXRlLm5vdygpLHY9dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBUPXY7Zm9yKGxldCB1PTA7dTxlLmxlbmd0aDt1Kz0yKXtUPU1hdGgubWluKFQsdik7Y29uc3QgYz10aGlzLnRtcFBvaW50cy5sZW5ndGgsRT1uZXcgQXQoZVt1XSxlW3UrMV0pO2lmKGM9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKEUpO2NvbnRpbnVlfWNvbnN0IGY9Yy0xLGc9dGhpcy50bXBQb2ludHNbZl0seT1ndC5TdWIoRSxnKS51bmkoKTtpZihFLmlzTmVhcihnLHQpKXtpZihnLno8dGhpcy5NQVhfUkVQRUFSKXtpZihnLnNldHooTWF0aC5taW4oZy56KzEsdGhpcy5NQVhfUkVQRUFSKSksVD1NYXRoLm1pbihULGYpLGM+MSl7bGV0IGg9Yy0xO2Zvcig7aD4wOyl7Y29uc3QgbT10aGlzLnRtcFBvaW50c1toXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1toLTFdKSxyPU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW2hdLnotdGhpcy51bmlUaGlja25lc3MqbSwwKTtpZih0aGlzLnRtcFBvaW50c1toLTFdLno+PXIpYnJlYWs7dGhpcy50bXBQb2ludHNbaC0xXS5zZXR6KHIpLFQ9TWF0aC5taW4oVCxoLTEpLGgtLX19fWVsc2UgVD0xLzA7Y29udGludWV9RS5zZXR2KHkpO2NvbnN0IEM9RS5kaXN0YW5jZShnKSx4PU1hdGgubWF4KGcuei10aGlzLnVuaVRoaWNrbmVzcypDLDApO2M+MSYmZ3QuRXF1YWxzKHksZy52LC4wMikmJih4PjB8fGcuejw9MCkmJihhJiZnLnQmJmEuYWRkKGcudCksdGhpcy50bXBQb2ludHMucG9wKCksVD1NYXRoLm1pbihmLFQpKSxFLnNldHooeCksdGhpcy50bXBQb2ludHMucHVzaChFKX1pZihUPT09MS8wKXJldHVybiB0aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IGQ9djtpZihUPT09dil7ZD1NYXRoLm1heChkLTEsMCk7Y29uc3QgdT10aGlzLnRtcFBvaW50c1tkXS50O3UmJihhPT1udWxsfHxhLmFkZCh1KSl9ZWxzZXtsZXQgdT12LTE7Zm9yKGQ9VDt1Pj0wOyl7Y29uc3QgYz10aGlzLnRtcFBvaW50c1t1XS50O2lmKGMmJihhPT1udWxsfHxhLmFkZChjKSx1PD1UKSl7ZD11LHU9LTE7YnJlYWt9dS0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbZF0uc2V0VChvKSxkfXVwZGF0ZVRlbXBQb2ludHMoZSx0LGEpe3ZhciB1O2NvbnN0IG89RGF0ZS5ub3coKSx2PXRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgVD12O2ZvcihsZXQgYz0wO2M8ZS5sZW5ndGg7Yys9Mil7Y29uc3QgRT10aGlzLnRtcFBvaW50cy5sZW5ndGgsZj1uZXcgQXQoZVtjXSxlW2MrMV0pO2lmKEU9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKGYpO2NvbnRpbnVlfWNvbnN0IGc9RS0xLHk9dGhpcy50bXBQb2ludHNbZ10sQz1ndC5TdWIoZix5KS51bmkoKTtpZihndC5FcXVhbHMoQyx5LnYsLjAyKSl7YSYmeS50JiZhLmFkZCh5LnQpLHRoaXMudG1wUG9pbnRzLnBvcCgpLFQ9TWF0aC5taW4oZyxUKTtjb250aW51ZX1pZihmLmlzTmVhcih5LHQvMikpe1Q9TWF0aC5taW4oZyxUKTtjb250aW51ZX1mLnNldHYoQyksdGhpcy50bXBQb2ludHMucHVzaChmKX1sZXQgZD12O2lmKFQ9PT12KXtkPU1hdGgubWF4KGQtMSwwKTtjb25zdCBjPXRoaXMudG1wUG9pbnRzW2RdLnQ7YyYmKGE9PW51bGx8fGEuYWRkKGMpKX1lbHNle2xldCBjPU1hdGgubWluKHYtMSxUKTtmb3IoZD1UO2M+PTA7KXtjb25zdCBFPSh1PXRoaXMudG1wUG9pbnRzW2NdKT09bnVsbD92b2lkIDA6dS50O2lmKEUmJihhPT1udWxsfHxhLmFkZChFKSxjPD1UKSl7ZD1jLGM9LTE7YnJlYWt9Yy0tfX1yZXR1cm4gdGhpcy50bXBQb2ludHNbZF0uc2V0VChvKSxkfXVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZShlKXtjb25zdHt0aGlja25lc3M6dH09dGhpcy53b3JrT3B0aW9ucztmb3IobGV0IGE9MDthPGUubGVuZ3RoO2ErPTIpe2NvbnN0IG89dGhpcy50bXBQb2ludHMubGVuZ3RoLHY9bmV3IEF0KGVbYV0sZVthKzFdKTtpZihvPT09MCl7dGhpcy50bXBQb2ludHMucHVzaCh2KTtjb250aW51ZX1jb25zdCBUPW8tMSxkPXRoaXMudG1wUG9pbnRzW1RdLHU9Z3QuU3ViKHYsZCkudW5pKCk7aWYodi5pc05lYXIoZCx0LzIpKXtpZihkLno8dGhpcy5NQVhfUkVQRUFSJiYoZC5zZXR6KE1hdGgubWluKGQueisxLHRoaXMuTUFYX1JFUEVBUikpLG8+MSkpe2xldCBmPW8tMTtmb3IoO2Y+MDspe2NvbnN0IGc9dGhpcy50bXBQb2ludHNbZl0uZGlzdGFuY2UodGhpcy50bXBQb2ludHNbZi0xXSkseT1NYXRoLm1heCh0aGlzLnRtcFBvaW50c1tmXS56LXRoaXMudW5pVGhpY2tuZXNzKmcsMCk7aWYodGhpcy50bXBQb2ludHNbZi0xXS56Pj15KWJyZWFrO3RoaXMudG1wUG9pbnRzW2YtMV0uc2V0eih5KSxmLS19fWNvbnRpbnVlfXYuc2V0dih1KTtjb25zdCBjPXYuZGlzdGFuY2UoZCksRT1NYXRoLm1heChkLnotdGhpcy51bmlUaGlja25lc3MqYywtdGhpcy5NQVhfUkVQRUFSLzUpO28+MSYmZ3QuRXF1YWxzKHUsZC52LC4wMikmJmQuejw9MCYmdGhpcy50bXBQb2ludHMucG9wKCksdi5zZXR6KEUpLHRoaXMudG1wUG9pbnRzLnB1c2godil9fX1jbGFzcyBkZSBleHRlbmRzIFp0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIodCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6UHQuRXJhc2VyfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJlbW92ZUlkcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksdGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7fWNvbnN1bWVTZXJ2aWNlKCl7fXNldFdvcmtPcHRpb25zKGUpe3RoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUpe2NvbnN0e29wOnR9PWU7aWYoIXR8fHQubGVuZ3RoPT09MClyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdHtyZWN0OmEscmVtb3ZlSWRzOm99PXRoaXMucmVtb3ZlKHQpO3JldHVybiBhJiZvLmxlbmd0aD97dHlwZTpUdC5SZW1vdmVOb2RlLGRhdGFUeXBlOlJ0LkxvY2FsLHJlY3Q6YSxyZW1vdmVJZHM6b306e3R5cGU6VHQuTm9uZX19cmVtb3ZlKGUpe2NvbnN0e2lzTGluZTp0fT10aGlzLndvcmtPcHRpb25zO2xldCBhO2NvbnN0IG89W107Zm9yKGxldCB2PTA7djxlLmxlbmd0aDt2Kz0yKXtjb25zdCBUPWVbdl0sZD1lW3YrMV07dGhpcy5mdWxsTGF5ZXIuY2hpbGRyZW4uZm9yRWFjaCh1PT57dS5pc1BvaW50Q29sbGlzaW9uKFQsZCkmJih0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZSh1Lm5hbWUpLmZvckVhY2goYz0+e2NvbnN0IEU9Yz09bnVsbD92b2lkIDA6Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtFJiYoYT1CdChhLHt4OkUueC0xMCx5OkUueS0xMCx3OkUud2lkdGgrMjAsaDpFLmhlaWdodCsyMH0pKSxjLnJlbW92ZSgpfSksdCYmKG8ucHVzaCh1Lm5hbWUpLHRoaXMucmVtb3ZlSWRzLnB1c2godS5uYW1lKSkpfSl9cmV0dXJue3JlY3Q6YSxyZW1vdmVJZHM6b319Y29uc3VtZUFsbChlKXtyZXR1cm4gdGhpcy5jb25zdW1lKGUpfWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTB9fWNsYXNzIHNlIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcih0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jSW5kZXgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRvb2xzVHlwZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlB0Lkxhc2VyUGVufSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFBvaW50cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOltdfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1RpbWVzdGFtcD0wfWNvbWJpbmVDb25zdW1lKCl7fXNldFdvcmtPcHRpb25zKGUpe3RoaXMud29ya09wdGlvbnM9ZSx0aGlzLnN5bmNUaW1lc3RhbXA9RGF0ZS5ub3coKX1jb25zdW1lKGUsdCl7Y29uc3R7d29ya0lkOmEsb3A6b309ZTtpZigobz09bnVsbD92b2lkIDA6by5sZW5ndGgpPT09MClyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdCB2PU1hdGgubWF4KDAsdGhpcy50bXBQb2ludHMubGVuZ3RoLTEpLFQ9dGhpcy50bXBQb2ludHMubGVuZ3RoO2lmKHRoaXMudXBkYXRlVGVtcFBvaW50cyhvfHxbXSksVD09PXRoaXMudG1wUG9pbnRzLmxlbmd0aClyZXR1cm57dHlwZTpUdC5Ob25lfTtjb25zdHtjb2xvcjpkLHRoaWNrbmVzczp1LHN0cm9rZVR5cGU6YyxvcGFjaXR5OkV9PXRoaXMud29ya09wdGlvbnM7bGV0IGYsZz0hMTtjb25zdCB5PXRoaXMuc3luY0luZGV4O2xldCBDPXRoaXMudG1wUG9pbnRzLnNsaWNlKHYpO2NvbnN0IHg9Qy5sZW5ndGg9PT0xO2lmKHgpe2NvbnN0IGk9dGhpcy5jb21wdXREb3RTdHJva2Uoe3BvaW50OkNbMF0scmFkaXVzOnUvMn0pO0M9aS5wcyxmPWkucmVjdH1lbHNlIGY9JHQodGhpcy50bXBQb2ludHMsdSk7dGhpcy5zeW5jVGltZXN0YW1wPT09MCYmKHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpKTtjb25zdCBoPXtuYW1lOmE9PW51bGw/dm9pZCAwOmEudG9TdHJpbmcoKSxjbGFzc05hbWU6Ikxhc2VyUGVuIixmaWxsQ29sb3I6eD9kOnZvaWQgMCxvcGFjaXR5OkV8fDEsbGluZURhc2g6Yz09PWp0LkRvdHRlZCYmIXg/WzEsdSoyXTpjPT09anQuTG9uZ0RvdHRlZCYmIXg/W3UsdSoyXTp2b2lkIDAsc3Ryb2tlQ29sb3I6ZCxsaW5lQ2FwOng/dm9pZCAwOiJyb3VuZCIsbGluZVdpZHRoOng/MDp1LGFuY2hvcjpbLjUsLjVdfSxtPXRoaXMuZ2V0VGFza1BvaW50cyhDKTtpZihtLmxlbmd0aCl7Y29uc3QgaT1EYXRlLm5vdygpO2ktdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYoZz0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9aSx0aGlzLnN5bmNJbmRleD10aGlzLnRtcFBvaW50cy5sZW5ndGgpLCF0JiZ0aGlzLmRyYXcoe2F0dHJzOmgsdGFza3M6bSxpc0RvdDp4fSl9Y29uc3Qgcj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UoeSkuZm9yRWFjaChpPT57ci5wdXNoKGkueCxpLnkpfSkse3JlY3Q6Zix0eXBlOlR0LkRyYXdXb3JrLGRhdGFUeXBlOlJ0LkxvY2FsLHdvcmtJZDpnP2E6dm9pZCAwLG9wOmc/cjp2b2lkIDAsaW5kZXg6Zz95KjI6dm9pZCAwfX1jb25zdW1lQWxsKCl7dmFyIGE7Y29uc3QgZT0oYT10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOmEudG9TdHJpbmcoKSx0PVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh0aGlzLnN5bmNJbmRleCkuZm9yRWFjaChvPT57dC5wdXNoKG8ueCxvLnkpfSkse3R5cGU6VHQuRHJhd1dvcmssZGF0YVR5cGU6UnQuTG9jYWwsd29ya0lkOmUsb3A6dCxpbmRleDp0aGlzLnN5bmNJbmRleCoyfX1jbGVhclRtcFBvaW50cygpe3RoaXMudG1wUG9pbnRzLmxlbmd0aD0wLHRoaXMuc3luY1RpbWVzdGFtcD0wLHRoaXMuc3luY0luZGV4PTB9Y29uc3VtZVNlcnZpY2UoZSl7dmFyIGc7Y29uc3R7Y29sb3I6dCx0aGlja25lc3M6YSxzdHJva2VUeXBlOm8sb3BhY2l0eTp2fT10aGlzLndvcmtPcHRpb25zO2lmKCFlLmxlbmd0aClyZXR1cm4gJHQodGhpcy50bXBQb2ludHMsYSk7Y29uc3QgVD1NYXRoLm1heCgwLHRoaXMudG1wUG9pbnRzLmxlbmd0aC0xKTt0aGlzLnVwZGF0ZVRlbXBQb2ludHMoZXx8W10pO2xldCBkLHU9dGhpcy50bXBQb2ludHMuc2xpY2UoVCk7Y29uc3QgYz11Lmxlbmd0aD09PTE7aWYoYyl7Y29uc3QgeT10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6dVswXSxyYWRpdXM6YS8yfSk7dT15LnBzLGQ9eS5yZWN0fWVsc2UgZD0kdCh0aGlzLnRtcFBvaW50cyxhKTtjb25zdCBFPXtuYW1lOihnPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6Zy50b1N0cmluZygpLGNsYXNzTmFtZToiTGFzZXJQZW4iLGZpbGxDb2xvcjpjP3Q6dm9pZCAwLG9wYWNpdHk6dnx8MSxsaW5lRGFzaDpvPT09anQuRG90dGVkJiYhYz9bMSxhKjJdOm89PT1qdC5Mb25nRG90dGVkJiYhYz9bYSxhKjJdOnZvaWQgMCxzdHJva2VDb2xvcjp0LGxpbmVDYXA6Yz92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6Yz8wOmEsYW5jaG9yOlsuNSwuNV19LGY9dGhpcy5nZXRUYXNrUG9pbnRzKHUpO3JldHVybiBmLmxlbmd0aCYmdGhpcy5kcmF3KHthdHRyczpFLHRhc2tzOmYsaXNEb3Q6Y30pLGR9Y29tcHV0RG90U3Ryb2tlKGUpe2NvbnN0e3BvaW50OnQscmFkaXVzOmF9PWUsbz17eDp0LngtYSx5OnQueS1hLHc6YSoyLGg6YSoyfTtyZXR1cm57cHM6QXQuR2V0RG90U3Ryb2tlKHQsYSw4KSxyZWN0Om99fXVwZGF0ZVRlbXBQb2ludHMoZSl7Y29uc3QgdD10aGlzLnRtcFBvaW50cy5sZW5ndGg7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKz0yKXtpZih0KXtjb25zdCBvPXRoaXMudG1wUG9pbnRzLnNsaWNlKC0xKVswXTtvJiZvLng9PT1lW2FdJiZvLnk9PT1lW2ErMV0mJnRoaXMudG1wUG9pbnRzLnBvcCgpfXRoaXMudG1wUG9pbnRzLnB1c2gobmV3IEF0KGVbYV0sZVthKzFdKSl9fWFzeW5jIGRyYXcoZSl7Y29uc3R7YXR0cnM6dCx0YXNrczphLGlzRG90Om99PWUsdj10aGlzLmZ1bGxMYXllcix7ZHVyYXRpb246VH09dGhpcy53b3JrT3B0aW9ucyxkPW5ldyBlZTtmb3IobGV0IHU9MDt1PGEubGVuZ3RoO3UrKyl7Y29uc3R7cG9zOmMscG9pbnRzOkV9PWFbdV07bGV0IGY7bz9mPVF0KEUsITApOmY9UXQoRSwhMSksZC5hdHRyKHsuLi50LHBvczpjLGQ6Zn0pO2NvbnN0e3ZlcnRleDpnLGZyYWdtZW50Onl9PXRoaXMud29ya09wdGlvbnM7aWYoZyYmeSl7Y29uc3QgQz12LnJlbmRlcmVyLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDpnLGZyYWdtZW50Onl9KSx7d2lkdGg6eCxoZWlnaHQ6aH09di5nZXRSZXNvbHV0aW9uKCk7ZC5zZXRVbmlmb3Jtcyh7dV90aW1lOjAsdV9yZXNvbHV0aW9uOlt4LGhdfSksZC5zZXRQcm9ncmFtKEMpfXYuYXBwZW5kQ2hpbGQoZCksYXdhaXQgZC50cmFuc2l0aW9uKFQpLmF0dHIoe3NjYWxlOm8/Wy4xLC4xXTpbMSwxXSxsaW5lV2lkdGg6bz8wOjF9KSxkLnJlbW92ZSgpfX1nZXRUYXNrUG9pbnRzKGUpe3ZhciB1O2NvbnN0IHQ9W107aWYoZS5sZW5ndGg9PT0wKXJldHVybltdO2xldCBhPTAsbz1lWzBdLngsdj1lWzBdLnksVD1bbyx2XSxkPVtdO2Zvcig7YTxlLmxlbmd0aDspe2NvbnN0IGM9ZVthXSxFPWMueC1vLGY9Yy55LXY7aWYoZC5wdXNoKG5ldyBBdChFLGYpKSxhPjAmJmE8ZS5sZW5ndGgtMSl7Y29uc3QgZz1lW2FdLmdldEFuZ2xlQnlQb2ludHMoZVthLTFdLGVbYSsxXSk7aWYoZzw5MHx8Zz4yNzApe2NvbnN0IHk9KHU9ZC5wb3AoKSk9PW51bGw/dm9pZCAwOnUuY2xvbmUoKTt5JiZ0LnB1c2goe3BvczpULHBvaW50czpbLi4uZCx5XX0pLG89ZVthXS54LHY9ZVthXS55LFQ9W28sdl07Y29uc3QgQz1jLngtbyx4PWMueS12O2Q9W25ldyBBdChDLHgpXX19YSsrfXJldHVybiB0LnB1c2goe3BvczpULHBvaW50czpkfSksdH19Y2xhc3MgZ2V7Y29uc3RydWN0b3IoKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidHJhbnNsYXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6WzAsMF19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic2NhbGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZToxfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImR1c3RiaW4iLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpuZXcgU2V0fSl9dXBkYXRlU2NlbmUoZSl7dGhpcy5zY2VuZS5hdHRyKHsuLi5lLGJ1ZmZlclNpemU6MWU0fSl9dXBkYXRlTGF5ZXIoZSl7dGhpcy5mdWxsTGF5ZXIuYXR0cih7Li4uZSxidWZmZXJTaXplOjVlM30pLHRoaXMuZHJhd0xheWVyLmF0dHIoZSl9Y3JlYXRlU2NlbmUoZSl7Y29uc3R7d2lkdGg6dCxoZWlnaHQ6YX09ZSxvPW5ldyBPZmZzY3JlZW5DYW52YXModCxhKTtyZXR1cm4gbmV3IGxlKHtjb250YWluZXI6byxkaXNwbGF5UmF0aW86dGhpcy5kcHIsZGVwdGg6ITEsZGVzeW5jaHJvbml6ZWQ6ITAsLi4uZX0pfWNyZWF0ZUxheWVyKGUpe2NvbnN0IHQ9Im9mZnNjcmVlbiIrRGF0ZS5ub3coKTtyZXR1cm4gdGhpcy5zY2VuZS5sYXllcih0LGUpfXNldFRyYW5zbGF0ZShlKXt0aGlzLnRyYW5zbGF0ZT1lfXNldFNjYWxlKGUpe3RoaXMuc2NhbGU9ZX1nZXROb2RlcyhlKXtyZXR1cm4gdGhpcy5mdWxsTGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSsiIikuY29uY2F0KHRoaXMuZHJhd0xheWVyLmdldEVsZW1lbnRzQnlOYW1lKGUrIiIpKX19Y2xhc3MgbWV7Y29uc3RydWN0b3IoZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImRyYXdMYXllciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBXb3JrU2hhcGVOb2RlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcE9wdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuZnVsbExheWVyPWUsdGhpcy5kcmF3TGF5ZXI9dH1nZXRXb3JrU2hhcGUoZSl7cmV0dXJuIHRoaXMud29ya1NoYXBlcy5nZXQoZSl9Z2V0VG1wV29ya1NoYXBlTm9kZSgpe3JldHVybiB0aGlzLnRtcFdvcmtTaGFwZU5vZGV9c2V0VG1wV29ya0lkKGUpe2lmKGUmJnRoaXMudG1wV29ya1NoYXBlTm9kZSl7dGhpcy50bXBXb3JrU2hhcGVOb2RlLnNldFdvcmtJZChlKSx0aGlzLndvcmtTaGFwZXMuc2V0KGUsdGhpcy50bXBXb3JrU2hhcGVOb2RlKSx0aGlzLnRtcE9wdCYmdGhpcy5zZXRUb29sc09wdCh0aGlzLnRtcE9wdCk7cmV0dXJufX1zZXRUbXBXb3JrT3B0aW9ucyhlKXt2YXIgdDsodD10aGlzLnRtcFdvcmtTaGFwZU5vZGUpPT1udWxsfHx0LnNldFdvcmtPcHRpb25zKGUpfXNldFdvcmtPcHRpb25zKGUsdCl7dmFyIG87dGhpcy53b3JrU2hhcGVzLmdldChlKXx8dGhpcy5zZXRUbXBXb3JrSWQoZSksKG89dGhpcy53b3JrU2hhcGVzLmdldChlKSk9PW51bGx8fG8uc2V0V29ya09wdGlvbnModCl9c2V0VG9vbHNPcHQoZSl7dmFyIHQ7c3dpdGNoKCgodD10aGlzLnRtcE9wdCk9PW51bGw/dm9pZCAwOnQudG9vbHNUeXBlKSE9PWUudG9vbHNUeXBlJiZ0aGlzLmNsZWFyQWxsV29ya1NoYXBlc0NhY2hlKCksdGhpcy50bXBPcHQ9ZSxlLnRvb2xzVHlwZSl7Y2FzZSBQdC5QZW5jaWw6dGhpcy50bXBXb3JrU2hhcGVOb2RlPW5ldyBpZShlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyKTticmVhaztjYXNlIFB0Lkxhc2VyUGVuOnRoaXMudG1wV29ya1NoYXBlTm9kZT1uZXcgc2UoZS50b29sc09wdCx0aGlzLmZ1bGxMYXllcik7YnJlYWs7Y2FzZSBQdC5FcmFzZXI6dGhpcy50bXBXb3JrU2hhcGVOb2RlPW5ldyBkZShlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztkZWZhdWx0OnRoaXMudG1wV29ya1NoYXBlTm9kZT12b2lkIDA7YnJlYWt9fWNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKGUpe3ZhciB0Oyh0PXRoaXMuZ2V0V29ya1NoYXBlKGUpKT09bnVsbHx8dC5jbGVhclRtcFBvaW50cygpLHRoaXMud29ya1NoYXBlcy5kZWxldGUoZSl9Y2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKXt0aGlzLndvcmtTaGFwZXMuZm9yRWFjaChlPT5lLmNsZWFyVG1wUG9pbnRzKCkpLHRoaXMud29ya1NoYXBlcy5jbGVhcigpfX1jbGFzcyB2ZXtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5mdWxsTGF5ZXI9ZSx0aGlzLmRyYXdMYXllcj10fX1jbGFzcyB5ZSBleHRlbmRzIG1le2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcihlLHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3b3JrU2hhcGVzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bmV3IE1hcH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb21iaW5lVW5pdFRpbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTo2MDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZVRpbWVySWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3Bvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0NvdW50Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLHRoaXMuX3Bvc3Q9YX1kcmF3UGVuY2lsQ29tYmluZShlKXt2YXIgYTtjb25zdCB0PShhPXRoaXMud29ya1NoYXBlcy5nZXQoZSkpPT1udWxsP3ZvaWQgMDphLmNvbWJpbmVDb25zdW1lKCk7aWYodCl7Y29uc3Qgbz17cmVuZGVyOntyZWN0OnQ9PW51bGw/dm9pZCAwOnQucmVjdCxpc0NsZWFyOiEwLGRyYXdDYW52YXM6VXQuRmxvYXQsY2xlYXJDYW52YXM6VXQuRmxvYXQsaXNGdWxsV29yazohMX19O1Byb21pc2UucmVzb2x2ZShvKS50aGVuKHY9Pnt2LmRyYXdDb3VudD10aGlzLmRyYXdDb3VudCx0aGlzLl9wb3N0KHYpfSl9fWRyYXdFcmFzZXIoZSl7UHJvbWlzZS5yZXNvbHZlKGUpLnRoZW4odD0+e3RoaXMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDp0LnJlY3QsZHJhd0NhbnZhczpVdC5CZyxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOlV0LkJnLGlzRnVsbFdvcms6ITB9LHNwOlt0XX0pfSl9Y29uc3VtZURyYXcoZSl7Y29uc3R7b3A6dCx3b3JrSWQ6YX09ZTtpZih0IT1udWxsJiZ0Lmxlbmd0aCYmYSl7Y29uc3Qgbz10aGlzLndvcmtTaGFwZXMuZ2V0KGEpO2lmKCFvKXJldHVybjtjb25zdCB2PW8udG9vbHNUeXBlLFQ9by5jb25zdW1lKGUsITApO2lmKHY9PT1QdC5FcmFzZXIpe1QhPW51bGwmJlQucmVjdCYmdGhpcy5kcmF3RXJhc2VyKFQpO3JldHVybn1yZXR1cm4gdj09PVB0LlBlbmNpbCYmKHRoaXMuY29tYmluZVRpbWVySWR8fCh0aGlzLmNvbWJpbmVUaW1lcklkPXNldFRpbWVvdXQoKCk9Pnt0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCx0aGlzLmRyYXdQZW5jaWxDb21iaW5lKGEpfSx0aGlzLmNvbWJpbmVVbml0VGltZSkpLFQmJih0aGlzLmRyYXdDb3VudCsrLFQuZHJhd0NvdW50PXRoaXMuZHJhd0NvdW50KSksVH19Y29uc3VtZURyYXdBbGwoZSl7dGhpcy5jb21iaW5lVGltZXJJZCYmKGNsZWFyVGltZW91dCh0aGlzLmNvbWJpbmVUaW1lcklkKSx0aGlzLmNvbWJpbmVUaW1lcklkPXZvaWQgMCk7Y29uc3R7d29ya0lkOnR9PWU7aWYodCl7Y29uc3QgYT10aGlzLndvcmtTaGFwZXMuZ2V0KHQpO2lmKCFhKXJldHVybjt0aGlzLmRyYXdDb3VudD0wO2NvbnN0IG89YS50b29sc1R5cGUsdj1hLmNvbnN1bWVBbGwoZSk7aWYobz09PVB0LkVyYXNlcil7diE9bnVsbCYmdi5yZWN0JiZ0aGlzLmRyYXdFcmFzZXIodik7cmV0dXJufXJldHVybiB0aGlzLmNsZWFyV29ya1NoYXBlTm9kZUNhY2hlKHQpLG89PT1QdC5MYXNlclBlbiYmc2V0VGltZW91dCgoKT0+e3RoaXMuX3Bvc3Qoe3NwOlt7cmVtb3ZlSWRzOlt0LnRvU3RyaW5nKCldLHR5cGU6VHQuUmVtb3ZlTm9kZX1dfSl9LHRoaXMuY29tYmluZVVuaXRUaW1lKSx2fX19Y2xhc3MgcGUgZXh0ZW5kcyB2ZXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX3Bvc3QiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLl9wb3N0PWF9YWN0aXZlV29ya1NoYXBlKGUpe3ZhciBmLGcseTtjb25zdHt3b3JrSWQ6dCxvcHQ6YSx0b29sc3R5cGU6byx0eXBlOnYsdXBkYXRlTm9kZU9wdDpULG9wczpkLG9wOnV9PWU7aWYoIXQpcmV0dXJuO2NvbnN0IGM9dC50b1N0cmluZygpO2lmKCEoKGY9dGhpcy53b3JrU2hhcGVzKSE9bnVsbCYmZi5oYXMoYykpKXtsZXQgQz17dG9vbHN0eXBlOm8sYW5pbWF0aW9uV29ya0RhdGE6dXx8W10sYW5pbWF0aW9uSW5kZXg6MCx0eXBlOnYsdXBkYXRlTm9kZU9wdDpULG9wczpkfTtvJiZhJiYoQz10aGlzLnNldE5vZGVLZXkoQyxvLGEpKSwoZz10aGlzLndvcmtTaGFwZXMpPT1udWxsfHxnLnNldChjLEMpfWNvbnN0IEU9KHk9dGhpcy53b3JrU2hhcGVzKT09bnVsbD92b2lkIDA6eS5nZXQoYyk7diYmKEUudHlwZT12KSxUJiYoRS51cGRhdGVOb2RlT3B0PVQpLGQmJihFLm9wcz1kLEUuYW5pbWF0aW9uV29ya0RhdGE9Y2UoZCkpLHUmJihFLmFuaW1hdGlvbldvcmtEYXRhPXUpLEUubm9kZSYmRS5ub2RlLmdldFdvcmtJZCgpIT09YyYmRS5ub2RlLnNldFdvcmtJZChjKSxFLnRvb2xzdHlwZSE9PW8mJm8mJmEmJnRoaXMuc2V0Tm9kZUtleShFLG8sYSl9c2V0Tm9kZUtleShlLHQsYSl7c3dpdGNoKGUudG9vbHN0eXBlPXQsdCl7Y2FzZSBQdC5QZW5jaWw6ZS5ub2RlPW5ldyBpZShhLHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyKTticmVhaztjYXNlIFB0Lkxhc2VyUGVuOmUubm9kZT1uZXcgc2UoYSx0aGlzLmRyYXdMYXllcik7YnJlYWs7ZGVmYXVsdDplLm5vZGU9dm9pZCAwO2JyZWFrfXJldHVybiBlfWNvbXB1dE5leHRBbmltYXRpb25JbmRleChlLHQpe3ZhciBvO2NvbnN0IGE9TWF0aC5mbG9vcihlLmFuaW1hdGlvbldvcmtEYXRhLnNsaWNlKGUuYW5pbWF0aW9uSW5kZXgpLmxlbmd0aCoxNi90LygoKG89ZS5ub2RlKT09bnVsbD92b2lkIDA6by5zeW5jVW5pdFRpbWUpfHwxZTMpKSp0O3JldHVybiBNYXRoLm1pbihlLmFuaW1hdGlvbkluZGV4KyhhfHx0KSxlLmFuaW1hdGlvbldvcmtEYXRhLmxlbmd0aCl9YW5pbWF0aW9uRHJhdygpe2xldCBlLHQsYT0hMSxvPSExO3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKCh2LFQpPT57dmFyIGcseSxDLHg7Y29uc3QgZD12LnRvb2xzdHlwZT09PVB0LlBlbmNpbD8zOjIsdT10aGlzLmNvbXB1dE5leHRBbmltYXRpb25JbmRleCh2LGQpLGM9TWF0aC5tYXgoMCx2LmFuaW1hdGlvbkluZGV4LWQpLEU9di5hbmltYXRpb25Xb3JrRGF0YS5zbGljZShjLHUpO2xldCBmO3YuYW5pbWF0aW9uSW5kZXg8dT8oZj0oZz12Lm5vZGUpPT1udWxsP3ZvaWQgMDpnLmNvbnN1bWVTZXJ2aWNlKEUsITEpLHYudG9vbHN0eXBlPT09UHQuTGFzZXJQZW4/KHQ9QnQodCxmKSx2LnRpbWVyJiYoY2xlYXJUaW1lb3V0KHYudGltZXIpLHYudGltZXI9dm9pZCAwKSk6ZT1CdChlLGYpLGE9ITAsdi5hbmltYXRpb25JbmRleD11KTp2LmlzRGVsP3YuaXNEZWwmJnRoaXMud29ya1NoYXBlcy5kZWxldGUoVCk6KHYudG9vbHN0eXBlPT09UHQuUGVuY2lsJiZ2Lm9wcyYmKGY9KHk9di5ub2RlKT09bnVsbD92b2lkIDA6eS5jb25zdW1lU2VydmljZSh2LmFuaW1hdGlvbldvcmtEYXRhLCEwKSx0PUJ0KHQsZiksdi5pc0RlbD0hMCxvPSEwKSx2LnRvb2xzdHlwZT09PVB0Lkxhc2VyUGVuJiYodi50aW1lcnx8KHYudGltZXI9c2V0VGltZW91dCgoKT0+e3YudGltZXI9dm9pZCAwLHYuaXNEZWw9ITAsY29uc29sZS5sb2coImFuaW1hdGlvbkRyYXc0Iil9LCgoQz12Lm5vZGUpPT1udWxsP3ZvaWQgMDpDLmdldFdvcmtPcHRpb25zKCkpLmR1cmF0aW9uKjFlMysxMDApKSxmPSh4PXYubm9kZSk9PW51bGw/dm9pZCAwOnguY29uc3VtZVNlcnZpY2UoW10sITEpLHQ9QnQodCxmKSxvPSExKSxhPSEwKX0pLGEmJih0aGlzLmFuaW1hdGlvbklkPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRyYXcuYmluZCh0aGlzKSkpLGUmJnRoaXMuX3Bvc3Qoe3JlbmRlcjp7cmVjdDplLGRyYXdDYW52YXM6bz9VdC5CZzpVdC5GbG9hdCxpc0NsZWFyOm8sY2xlYXJDYW52YXM6VXQuRmxvYXQsaXNGdWxsV29yazpvfX0pLHQmJlByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnt0aGlzLl9wb3N0KHtyZW5kZXI6e3JlY3Q6dCxkcmF3Q2FudmFzOm8/VXQuQmc6VXQuRmxvYXQsaXNDbGVhcjohMCxjbGVhckNhbnZhczpVdC5GbG9hdCxpc0Z1bGxXb3JrOm99fSl9KX1jb25zdW1lRHJhdyhlKXt0aGlzLmFjdGl2ZVdvcmtTaGFwZShlKSxQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57dGhpcy5hbmltYXRpb25EcmF3KCl9KX1jb25zdW1lRnVsbChlKXt0aGlzLmFjdGl2ZVdvcmtTaGFwZShlKSxQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57dGhpcy5hbmltYXRpb25EcmF3KCl9KX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5jbGVhcigpfX1jb25zdCBWdD1jbGFzcyBWdCBleHRlbmRzIGdle2NvbnN0cnVjdG9yKCl7c3VwZXIoKTt6dCh0aGlzLCJkcHIiKTt6dCh0aGlzLCJzY2VuZSIpO3p0KHRoaXMsImRyYXdMYXllciIpO3p0KHRoaXMsImZ1bGxMYXllciIpO3p0KHRoaXMsImxvY2FsV29yayIpO3p0KHRoaXMsInNlcnZpY2VXb3JrIik7dGhpcy5yZWdpc3RlcigpfWluaXQodCxhLG8pe3RoaXMuZHByPXQsdGhpcy5zY2VuZT10aGlzLmNyZWF0ZVNjZW5lKGEpLHRoaXMuZHJhd0xheWVyPXRoaXMuY3JlYXRlTGF5ZXIobyksdGhpcy5mdWxsTGF5ZXI9dGhpcy5jcmVhdGVMYXllcihvKSx0aGlzLmxvY2FsV29yaz1uZXcgeWUodGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIsdGhpcy5wb3N0LmJpbmQodGhpcykpLHRoaXMuc2VydmljZVdvcms9bmV3IHBlKHRoaXMuZnVsbExheWVyLHRoaXMuZHJhd0xheWVyLHRoaXMucG9zdC5iaW5kKHRoaXMpKX1nZXRPZmZzY3JlZW4odCl7cmV0dXJuKHQ/dGhpcy5mdWxsTGF5ZXI6dGhpcy5kcmF3TGF5ZXIpLmNhbnZhc31yZWdpc3Rlcigpe3RoaXMub24odD0+e2NvbnN0IGE9W10sbz17fTtsZXQgdjtmb3IoY29uc3QgZCBvZiB0KXtjb25zdHt3b3JrU3RhdGU6dSx1cGRhdGVOb2RlT3B0OmMsZGF0YVR5cGU6RSxtc2dUeXBlOmYsd29ya0lkOmcsdHJhbnNsYXRlOnksc2NhbGU6QyxvZmZzY3JlZW5DYW52YXNPcHQ6eCx0b29sc1R5cGU6aCxsYXllck9wdDptLGRwcjpyLG9wdDppfT1kO2lmKGY9PT1UdC5Jbml0JiZ4JiZtJiZyKXt0aGlzLmluaXQocix4LG0pO2NvbnRpbnVlfWlmKGY9PT1UdC5UcmFuc2Zvcm0mJnkmJkMpe2NvbnN0IG49dGhpcy5zZXRUcmFuc2Zvcm0oeSxDKTtpZihuKXtjb25zdCBzPW4ucmVjdDtzJiYoby5yZWN0PUJ0KG8ucmVjdCxzKSxvLmlzQ2xlYXI9ITAsby5pc0Z1bGxXb3JrPSEwKSxhLnB1c2gobil9Y29udGludWV9aWYoZj09PVR0LlVwZGF0ZVNjZW5lJiZ4KXtjb25zdCBuPXRoaXMudXBkYXRlU2NlbmUoeCk7aWYobil7Y29uc3Qgcz1uLnJlY3Q7cyYmKG8ucmVjdD1CdChvLnJlY3Qscyksby5pc0NsZWFyPSEwLG8uaXNGdWxsV29yaz0hMCksYS5wdXNoKG4pfWNvbnRpbnVlfWlmKGY9PT1UdC5VcGRhdGVUb29scyYmaCYmaSl7dGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOmgsdG9vbHNPcHQ6aX0pO2NvbnRpbnVlfWlmKGY9PT1UdC5DcmVhdGVXb3JrJiZnJiZpKXshdGhpcy5sb2NhbFdvcmsuZ2V0VG1wV29ya1NoYXBlTm9kZSgpJiZoJiZ0aGlzLnNldFRvb2xzT3B0KHt0b29sc1R5cGU6aCx0b29sc09wdDppfSksdGhpcy5zZXRXb3JrT3B0KHt3b3JrSWQ6Zyx0b29sc09wdDppfSk7Y29udGludWV9aWYoZj09PVR0LkNsZWFyKXt0aGlzLmNsZWFyQWxsKCk7Y29udGludWV9aWYoZj09PVR0LlJlbW92ZU5vZGUmJmcmJkUpe2lmKGg9PT1QdC5MYXNlclBlbiljb250aW51ZTtjb25zdCBuPXRoaXMucmVtb3ZlKGcsRSk7aWYobil7Y29uc3Qgcz1uLnJlY3Q7cyYmKG8ucmVjdD1CdChvLnJlY3Qscyksby5pc0NsZWFyPSEwLG8uaXNGdWxsV29yaz0hMCksRT09PVJ0LkxvY2FsJiZhLnB1c2gobil9Y29udGludWV9aWYoZj09PVR0LlVwZGF0ZU5vZGUmJmcmJmgmJmMpe2NvbnN0IG49dGhpcy51cGRhdGVOb2RlKGcsYyk7aWYobil7Y29uc3Qgcz1uLnJlY3Q7cyYmKG8ucmVjdD1CdChvLnJlY3Qscyksby5pc0NsZWFyPSEwLG8uaXNGdWxsV29yaz0hMCksYS5wdXNoKG4pfWNvbnRpbnVlfWlmKGY9PT1UdC5GdWxsV29yayYmRSl7dGhpcy5jb25zdW1lRnVsbChFLGQpO2NvbnRpbnVlfWlmKGY9PT1UdC5EcmF3V29yayYmRSl7aWYoRT09PVJ0LlNlcnZpY2V8fEU9PT1SdC5Mb2NhbCYmKHU9PT1HdC5TdGFydHx8dT09PUd0LkRvaW5nKSl7Y29uc3Qgbj10aGlzLmNvbnN1bWVEcmF3KEUsZCk7biE9bnVsbCYmbi5kcmF3Q291bnQmJih2PW4uZHJhd0NvdW50KSxuIT1udWxsJiZuLm9wJiZhLnB1c2gobil9aWYodT09PUd0LkRvbmUmJmcpe2NvbnN0IG49dGhpcy5jb25zdW1lRHJhd0FsbChFLGQpO2lmKG4pe2NvbnN0IHM9bi5yZWN0O3MmJihvLnJlY3Q9QnQoby5yZWN0LHMpLG8uZHJhd0NhbnZhcz1VdC5CZyxvLmlzQ2xlYXI9ITAsby5jbGVhckNhbnZhcz1VdC5GbG9hdCxvLmlzRnVsbFdvcms9ITApLGEucHVzaChuKX19Y29udGludWV9fWNvbnN0IFQ9e307YS5sZW5ndGgmJihULnNwPWEpLChvLnJlY3R8fG8uaXNDbGVhcnx8by5pc0Z1bGxXb3JrKSYmKFQucmVuZGVyPW8pLHYmJihULmRyYXdDb3VudD12KSxPYmplY3Qua2V5cyhUKS5sZW5ndGgmJnRoaXMucG9zdChUKX0pfXJlbW92ZSh0LGEpe2NvbnN0IG89dGhpcy5nZXROb2Rlcyh0KTtpZihvLmxlbmd0aCl7bGV0IHY7Zm9yKGNvbnN0IFQgb2Ygbyl7Y29uc3QgZD1ULmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3Y9QnQodix7eDpNYXRoLmZsb29yKGQueC0xMCkseTpNYXRoLmZsb29yKGQueS0xMCksdzpNYXRoLmZsb29yKGQud2lkdGgrMjApLGg6TWF0aC5mbG9vcihkLmhlaWdodCsyMCl9KSxULnJlbW92ZSgpfXJldHVybntyZWN0OnYsdHlwZTphPT09UnQuTG9jYWw/VHQuUmVtb3ZlTm9kZTpUdC5Ob25lfX19dXBkYXRlTm9kZSh0LGEpe2NvbnN0IG89dGhpcy5nZXROb2Rlcyh0KTtpZihvLmxlbmd0aCl7bGV0IHY7cmV0dXJuIG8uZm9yRWFjaChUPT57Y29uc3QgZD1ULmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1QuYXR0cihhKSx2PUJ0KHYse3g6TWF0aC5mbG9vcihkLngtMTApLHk6TWF0aC5mbG9vcihkLnktMTApLHc6TWF0aC5mbG9vcihkLndpZHRoKzIwKSxoOk1hdGguZmxvb3IoZC5oZWlnaHQrMjApfSl9KSx7cmVjdDp2LHR5cGU6VHQuVXBkYXRlTm9kZX19fXVwZGF0ZVNjZW5lKHQpe3N1cGVyLnVwZGF0ZVNjZW5lKHQpLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgid2lkdGgiLHQud2lkdGgpLHRoaXMuZnVsbExheWVyLnNldEF0dHJpYnV0ZSgiaGVpZ2h0Iix0LmhlaWdodCksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdC53aWR0aCksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHQuaGVpZ2h0KTtjb25zdCBhPXt4OjAvdGhpcy5zY2FsZS10aGlzLnRyYW5zbGF0ZVswXSx5OjAvdGhpcy5zY2FsZS10aGlzLnRyYW5zbGF0ZVsxXSx3OnQud2lkdGgsaDp0LmhlaWdodH07cmV0dXJue3R5cGU6VHQuVXBkYXRlU2NlbmUscmVjdDphfX1zZXRUb29sc09wdCh0KXt0aGlzLmxvY2FsV29yay5zZXRUb29sc09wdCh0KX1zZXRXb3JrT3B0KHQpe2NvbnN0e3dvcmtJZDphLHRvb2xzT3B0Om99PXQ7YSYmbyYmdGhpcy5sb2NhbFdvcmsuc2V0V29ya09wdGlvbnMoYSxvKX1jbGVhckFsbCgpe3RoaXMuZnVsbExheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5kcmF3TGF5ZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKSx0aGlzLmxvY2FsV29yay5jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpLHRoaXMuc2VydmljZVdvcmsuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKX1zZXRUcmFuc2Zvcm0odCxhKXt2YXIgVCxkO3RoaXMuc2V0VHJhbnNsYXRlKHQpLHRoaXMuc2V0U2NhbGUoYSksKFQ9dGhpcy5mdWxsTGF5ZXIpPT1udWxsfHxULnNldEF0dHJpYnV0ZSgic2NhbGUiLFthLGFdKSx0aGlzLmZ1bGxMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsdGhpcy50cmFuc2xhdGUpLChkPXRoaXMuZHJhd0xheWVyKT09bnVsbHx8ZC5zZXRBdHRyaWJ1dGUoInNjYWxlIixbYSxhXSksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJ0cmFuc2xhdGUiLHRoaXMudHJhbnNsYXRlKTtjb25zdCBvPXt4OjAvYS10aGlzLnRyYW5zbGF0ZVswXSx5OjAvYS10aGlzLnRyYW5zbGF0ZVsxXSx3OnRoaXMuZnVsbExheWVyLndpZHRoLGg6dGhpcy5mdWxsTGF5ZXIuaGVpZ2h0fTtyZXR1cm57dHlwZTpUdC5UcmFuc2Zvcm0scmVjdDpvfX1nZXRSZWN0SW1hZ2VCaXRtYXAodCxhKXtjb25zdHt4Om8seTp2LHc6VCxoOmR9PXQsdT10aGlzLnNjYWxlPDE/dGhpcy5zY2FsZToxK01hdGguYWJzKHRoaXMuc2NhbGUtMSksYz10aGlzLnNjYWxlPDE/VC90aGlzLnNjYWxlOlQqdSxFPXRoaXMuc2NhbGU8MT9kL3RoaXMuc2NhbGU6ZCp1LGY9KG8rdGhpcy50cmFuc2xhdGVbMF0pKnRoaXMuc2NhbGUsZz0odit0aGlzLnRyYW5zbGF0ZVsxXSkqdGhpcy5zY2FsZTtyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAodGhpcy5nZXRPZmZzY3JlZW4oYSksZip0aGlzLmRwcixnKnRoaXMuZHByLGMqdGhpcy5kcHIsRSp0aGlzLmRwcix7cmVzaXplUXVhbGl0eToibG93In0pfXBvc3QodCl7Y29uc3QgYT10LnJlbmRlcjtpZihhJiYoKGEuaXNGdWxsV29yaz90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcikucmVuZGVyKCksYS5yZWN0KSl7dGhpcy5nZXRSZWN0SW1hZ2VCaXRtYXAoYS5yZWN0LCEhYS5pc0Z1bGxXb3JrKS50aGVuKG89PnthLmltYWdlQml0bWFwPW8sdC5yZW5kZXI9YSxWdC5fc2VsZi5wb3N0TWVzc2FnZSh0LFtvXSksby5jbG9zZSgpfSk7cmV0dXJufVZ0Ll9zZWxmLnBvc3RNZXNzYWdlKHQpfW9uKHQpe29ubWVzc2FnZT1hPT57dChhLmRhdGEpfX1jb25zdW1lRHJhdyh0LGEpe2lmKHQ9PT1SdC5Mb2NhbClyZXR1cm4gdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXcoYSk7dD09PVJ0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZURyYXcoYSl9Y29uc3VtZURyYXdBbGwodCxhKXtpZih0PT09UnQuTG9jYWwpcmV0dXJuIHRoaXMubG9jYWxXb3JrLmNvbnN1bWVEcmF3QWxsKGEpfWNvbnN1bWVGdWxsKHQsYSl7dD09PVJ0LlNlcnZpY2UmJnRoaXMuc2VydmljZVdvcmsuY29uc3VtZUZ1bGwoYSl9fTt6dChWdCwiX3NlbGYiLHNlbGYpO2xldCBxdD1WdDtuZXcgcXR9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItZ0wxcjZPc1kuanMubWFwCg==", rs = typeof window < "u" && window.Blob && new Blob([atob(Gt)], { type: "text/javascript;charset=utf-8" });
function Eb(n) {
  let l;
  try {
    if (l = rs && (window.URL || window.webkitURL).createObjectURL(rs), !l)
      throw "";
    const i = new Worker(l, {
      name: n == null ? void 0 : n.name
    });
    return i.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(l);
    }), i;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + Gt,
      {
        name: n == null ? void 0 : n.name
      }
    );
  } finally {
    l && (window.URL || window.webkitURL).revokeObjectURL(l);
  }
}
const Vt = "dmFyIHZlPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgeWU9KGJ0LEJ0LGp0KT0+QnQgaW4gYnQ/dmUoYnQsQnQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmp0fSk6YnRbQnRdPWp0O3ZhciBGdD0oYnQsQnQsanQpPT4oeWUoYnQsdHlwZW9mIEJ0IT0ic3ltYm9sIj9CdCsiIjpCdCxqdCksanQpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgYnQ7KGZ1bmN0aW9uKEwpe0xbTC5QZW5jaWw9MV09IlBlbmNpbCIsTFtMLkVyYXNlcj0yXT0iRXJhc2VyIixMW0wuU2VsZWN0b3I9M109IlNlbGVjdG9yIixMW0wuQ2xpY2tlcj00XT0iQ2xpY2tlciIsTFtMLkFycm93PTVdPSJBcnJvdyIsTFtMLkhhbmQ9Nl09IkhhbmQiLExbTC5MYXNlclBlbj03XT0iTGFzZXJQZW4ifSkoYnR8fChidD17fSkpO3ZhciBCdDsoZnVuY3Rpb24oTCl7TFtMLlBhdGg9MF09IlBhdGgiLExbTC5SZWN0PTFdPSJSZWN0In0pKEJ0fHwoQnQ9e30pKTt2YXIganQ7KGZ1bmN0aW9uKEwpe0xbTC5Mb2NhbD0xXT0iTG9jYWwiLExbTC5TZXJ2aWNlPTJdPSJTZXJ2aWNlIn0pKGp0fHwoanQ9e30pKTt2YXIgV3Q7KGZ1bmN0aW9uKEwpe0xbTC5QZW5kaW5nPTBdPSJQZW5kaW5nIixMW0wuU3RhcnQ9MV09IlN0YXJ0IixMW0wuRG9pbmc9Ml09IkRvaW5nIixMW0wuRG9uZT0zXT0iRG9uZSIsTFtMLkZyZWV6ZT00XT0iRnJlZXplIixMW0wuVW53cml0YWJsZT01XT0iVW53cml0YWJsZSJ9KShXdHx8KFd0PXt9KSk7dmFyIEF0OyhmdW5jdGlvbihMKXtMW0wuSW5pdD0wXT0iSW5pdCIsTFtMLlRyYW5zZm9ybT0xXT0iVHJhbnNmb3JtIixMW0wuVXBkYXRlVG9vbHM9Ml09IlVwZGF0ZVRvb2xzIixMW0wuVXBkYXRlU2NlbmU9M109IlVwZGF0ZVNjZW5lIixMW0wuQ3JlYXRlV29yaz00XT0iQ3JlYXRlV29yayIsTFtMLkRyYXdXb3JrPTVdPSJEcmF3V29yayIsTFtMLkZ1bGxXb3JrPTZdPSJGdWxsV29yayIsTFtMLlVwZGF0ZVdvcms9N109IlVwZGF0ZVdvcmsiLExbTC5VcGRhdGVOb2RlPThdPSJVcGRhdGVOb2RlIixMW0wuUmVtb3ZlTm9kZT05XT0iUmVtb3ZlTm9kZSIsTFtMLkNsZWFyPTEwXT0iQ2xlYXIiLExbTC5TZWxlY3Q9MTFdPSJTZWxlY3QiLExbTC5EZXN0cm95PTEyXT0iRGVzdHJveSIsTFtMLk5vbmU9MTNdPSJOb25lIixMW0wuQ29tYmluZURyYXc9MTRdPSJDb21iaW5lRHJhdyJ9KShBdHx8KEF0PXt9KSk7dmFyIGt0OyhmdW5jdGlvbihMKXtMW0wuUGF0aD0wXT0iUGF0aCIsTFtMLlJlY3Q9MV09IlJlY3QiLExbTC5UZXh0dXJlPTJdPSJUZXh0dXJlIn0pKGt0fHwoa3Q9e30pKTt2YXIgX3Q7KGZ1bmN0aW9uKEwpe0wuV2ViZ2wyPSJ3ZWJnbDIiLEwuV2ViZ2w9IndlYmdsIixMLkNhbnZhczJkPSIyZCJ9KShfdHx8KF90PXt9KSk7dmFyIHRlOyhmdW5jdGlvbihMKXtMLmltbWVkaWF0ZWx5PSJpbW1lZGlhdGVseSIsTC5jb250aW51b3VzPSJjb250aW51b3VzIn0pKHRlfHwodGU9e30pKTt2YXIgS3Q7KGZ1bmN0aW9uKEwpe0xbTC5GbG9hdD0wXT0iRmxvYXQiLExbTC5CZz0xXT0iQmcifSkoS3R8fChLdD17fSkpO2NsYXNzIFp0e2NvbnN0cnVjdG9yKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNVbml0VGltZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjFlM30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3TGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZnVsbExheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtJZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLHRoaXMuZnVsbExheWVyPWUsdGhpcy5kcmF3TGF5ZXI9dH1zZXRXb3JrSWQoZSl7dGhpcy53b3JrSWQ9ZX1nZXRXb3JrSWQoKXtyZXR1cm4gdGhpcy53b3JrSWR9Z2V0V29ya09wdGlvbnMoKXtyZXR1cm4gdGhpcy53b3JrT3B0aW9uc319dmFyIE90PWZ1bmN0aW9uKEwpe3ZhciBlPXt9O2Z1bmN0aW9uIHQoYSl7aWYoZVthXSlyZXR1cm4gZVthXS5leHBvcnRzO3ZhciBsPWVbYV09e2k6YSxsOiExLGV4cG9ydHM6e319O3JldHVybiBMW2FdLmNhbGwobC5leHBvcnRzLGwsbC5leHBvcnRzLHQpLGwubD0hMCxsLmV4cG9ydHN9cmV0dXJuIHQubT1MLHQuYz1lLHQuZD1mdW5jdGlvbihhLGwsTSl7dC5vKGEsbCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGwse2VudW1lcmFibGU6ITAsZ2V0Ok19KX0sdC5yPWZ1bmN0aW9uKGEpe3R5cGVvZiBTeW1ib2w8InUiJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LHQudD1mdW5jdGlvbihhLGwpe2lmKGwmMSYmKGE9dChhKSksbCY4fHxsJjQmJnR5cGVvZiBhPT0ib2JqZWN0IiYmYSYmYS5fX2VzTW9kdWxlKXJldHVybiBhO3ZhciBNPU9iamVjdC5jcmVhdGUobnVsbCk7aWYodC5yKE0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNLCJkZWZhdWx0Iix7ZW51bWVyYWJsZTohMCx2YWx1ZTphfSksbCYyJiZ0eXBlb2YgYSE9InN0cmluZyIpZm9yKHZhciBUIGluIGEpdC5kKE0sVCwoZnVuY3Rpb24oZCl7cmV0dXJuIGFbZF19KS5iaW5kKG51bGwsVCkpO3JldHVybiBNfSx0Lm49ZnVuY3Rpb24oYSl7dmFyIGw9YSYmYS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gYX07cmV0dXJuIHQuZChsLCJhIixsKSxsfSx0Lm89ZnVuY3Rpb24oYSxsKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsbCl9LHQucD0iL2pzLyIsdCh0LnM9MCl9KFtmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJ2ZXJzaW9uIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImhlbHBlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwiY3JlYXRlRWxlbWVudCIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJpc1Nwcml0ZU5vZGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwicmVnaXN0ZXJOb2RlIixmdW5jdGlvbigpe3JldHVybiBBfSk7dmFyIGE9dCgxMik7dC5kKGUsIkVOViIsZnVuY3Rpb24oKXtyZXR1cm4gYS5FTlZ9KTt2YXIgbD10KDY4KTt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBsLnJlcXVlc3RBbmltYXRpb25GcmFtZX0pLHQuZChlLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsZnVuY3Rpb24oKXtyZXR1cm4gbC5jYW5jZWxBbmltYXRpb25GcmFtZX0pO3ZhciBNPXQoNzApO3QuZChlLCJOb2RlIixmdW5jdGlvbigpe3JldHVybiBNLmRlZmF1bHR9KTt2YXIgVD10KDIxNyk7dC5kKGUsIkNsb3VkIixmdW5jdGlvbigpe3JldHVybiBULmRlZmF1bHR9KTt2YXIgZD10KDIxOSk7dC5kKGUsIkJsb2NrIixmdW5jdGlvbigpe3JldHVybiBkLmRlZmF1bHR9KTt2YXIgdT10KDIyNCk7dC5kKGUsIlNwcml0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdS5kZWZhdWx0fSk7dmFyIGM9dCgyMjYpO3QuZChlLCJQYXRoIixmdW5jdGlvbigpe3JldHVybiBjLmRlZmF1bHR9KTt2YXIgTz10KDIyOSk7dC5kKGUsIlJlY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIE8uZGVmYXVsdH0pO3ZhciBmPXQoMjMxKTt0LmQoZSwiVHJpYW5nbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuZGVmYXVsdH0pO3ZhciBnPXQoMjM2KTt0LmQoZSwiUGFyYWxsZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGcuZGVmYXVsdH0pO3ZhciB2PXQoMjM4KTt0LmQoZSwiUmVndWxhciIsZnVuY3Rpb24oKXtyZXR1cm4gdi5kZWZhdWx0fSk7dmFyIEM9dCgyNDApO3QuZChlLCJTdGFyIixmdW5jdGlvbigpe3JldHVybiBDLmRlZmF1bHR9KTt2YXIgcD10KDI0Mik7dC5kKGUsIkVsbGlwc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHAuZGVmYXVsdH0pO3ZhciBoPXQoMjQ0KTt0LmQoZSwiQXJjIixmdW5jdGlvbigpe3JldHVybiBoLmRlZmF1bHR9KTt2YXIgbT10KDI0Nik7dC5kKGUsIlJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIG0uZGVmYXVsdH0pO3ZhciByPXQoMjMyKTt0LmQoZSwiUG9seWxpbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdH0pO3ZhciBpPXQoMjQ4KTt0LmQoZSwiTGFiZWwiLGZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdH0pO3ZhciBuPXQoMjUwKTt0LmQoZSwiR3JvdXAiLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH0pO3ZhciBzPXQoMjg2KTt0LmQoZSwiTGF5ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdH0pO3ZhciB4PXQoMjg3KTt0LmQoZSwiU3ByaXRlU3ZnIixmdW5jdGlvbigpe3JldHVybiB4LmRlZmF1bHR9KTt2YXIgUD10KDI4OSk7dC5kKGUsIkxheWVyV29ya2VyIixmdW5jdGlvbigpe3JldHVybiBQLmRlZmF1bHR9KTt2YXIgUj10KDI5MCk7dC5kKGUsIlNjZW5lIixmdW5jdGlvbigpe3JldHVybiBSLmRlZmF1bHR9KTt2YXIgYj10KDIxMyksRT10KDIyMSk7dC5kKGUsIkNvbG9yIixmdW5jdGlvbigpe3JldHVybiBFLkNvbG9yfSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBFLkdyYWRpZW50fSk7dmFyIEQ9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IEk9Yi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQsUz1iLmRlZmF1bHQuaXNTcHJpdGVOb2RlLEE9Yi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSxVPXtwYXJzZUNvbG9yOkUucGFyc2VDb2xvcixzaXplVG9QaXhlbDpELnNpemVUb1BpeGVsLHRvQXJyYXk6RC50b0FycmF5LHRvU3RyaW5nOkQudG9TdHJpbmcsdG9OdW1iZXI6RC50b051bWJlcn07bGV0IEs7Sz0iMy44LjMiO2NvbnN0IFY9S30sZnVuY3Rpb24oTCxlLHQpe3QucihlKTt2YXIgYT10KDIpO3QuZChlLCJnbE1hdHJpeCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pO3ZhciBsPXQoMyk7dC5kKGUsIm1hdDIiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KTt2YXIgTT10KDQpO3QuZChlLCJtYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pO3ZhciBUPXQoNSk7dC5kKGUsIm1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgZD10KDYpO3QuZChlLCJtYXQ0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIHU9dCg3KTt0LmQoZSwicXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBjPXQoMTApO3QuZChlLCJxdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gY30pO3ZhciBPPXQoMTEpO3QuZChlLCJ2ZWMyIixmdW5jdGlvbigpe3JldHVybiBPfSk7dmFyIGY9dCg4KTt0LmQoZSwidmVjMyIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBnPXQoOSk7dC5kKGUsInZlYzQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiRVBTSUxPTiIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJBUlJBWV9UWVBFIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsIlJBTkRPTSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJzZXRNYXRyaXhBcnJheVR5cGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwidG9SYWRpYW4iLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9MWUtNixsPXR5cGVvZiBGbG9hdDMyQXJyYXk8InUiP0Zsb2F0MzJBcnJheTpBcnJheSxNPU1hdGgucmFuZG9tO2Z1bmN0aW9uIFQoTyl7bD1PfXZhciBkPU1hdGguUEkvMTgwO2Z1bmN0aW9uIHUoTyl7cmV0dXJuIE8qZH1mdW5jdGlvbiBjKE8sZil7cmV0dXJuIE1hdGguYWJzKE8tZik8PWEqTWF0aC5tYXgoMSxNYXRoLmFicyhPKSxNYXRoLmFicyhmKSl9TWF0aC5oeXBvdHx8KE1hdGguaHlwb3Q9ZnVuY3Rpb24oKXtmb3IodmFyIE89MCxmPWFyZ3VtZW50cy5sZW5ndGg7Zi0tOylPKz1hcmd1bWVudHNbZl0qYXJndW1lbnRzW2ZdO3JldHVybiBNYXRoLnNxcnQoTyl9KX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwidHJhbnNwb3NlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJhZGpvaW50IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiTERVIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzdWJ0cmFjdCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gU30pO3ZhciBhPXQoMik7ZnVuY3Rpb24gbCgpe3ZhciBBPW5ldyBhLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoQVsxXT0wLEFbMl09MCksQVswXT0xLEFbM109MSxBfWZ1bmN0aW9uIE0oQSl7dmFyIFU9bmV3IGEuQVJSQVlfVFlQRSg0KTtyZXR1cm4gVVswXT1BWzBdLFVbMV09QVsxXSxVWzJdPUFbMl0sVVszXT1BWzNdLFV9ZnVuY3Rpb24gVChBLFUpe3JldHVybiBBWzBdPVVbMF0sQVsxXT1VWzFdLEFbMl09VVsyXSxBWzNdPVVbM10sQX1mdW5jdGlvbiBkKEEpe3JldHVybiBBWzBdPTEsQVsxXT0wLEFbMl09MCxBWzNdPTEsQX1mdW5jdGlvbiB1KEEsVSxLLFYpe3ZhciBKPW5ldyBhLkFSUkFZX1RZUEUoNCk7cmV0dXJuIEpbMF09QSxKWzFdPVUsSlsyXT1LLEpbM109VixKfWZ1bmN0aW9uIGMoQSxVLEssVixKKXtyZXR1cm4gQVswXT1VLEFbMV09SyxBWzJdPVYsQVszXT1KLEF9ZnVuY3Rpb24gTyhBLFUpe2lmKEE9PT1VKXt2YXIgSz1VWzFdO0FbMV09VVsyXSxBWzJdPUt9ZWxzZSBBWzBdPVVbMF0sQVsxXT1VWzJdLEFbMl09VVsxXSxBWzNdPVVbM107cmV0dXJuIEF9ZnVuY3Rpb24gZihBLFUpe3ZhciBLPVVbMF0sVj1VWzFdLEo9VVsyXSxxPVVbM10sVz1LKnEtSipWO3JldHVybiBXPyhXPTEvVyxBWzBdPXEqVyxBWzFdPS1WKlcsQVsyXT0tSipXLEFbM109SypXLEEpOm51bGx9ZnVuY3Rpb24gZyhBLFUpe3ZhciBLPVVbMF07cmV0dXJuIEFbMF09VVszXSxBWzFdPS1VWzFdLEFbMl09LVVbMl0sQVszXT1LLEF9ZnVuY3Rpb24gdihBKXtyZXR1cm4gQVswXSpBWzNdLUFbMl0qQVsxXX1mdW5jdGlvbiBDKEEsVSxLKXt2YXIgVj1VWzBdLEo9VVsxXSxxPVVbMl0sVz1VWzNdLEg9S1swXSxaPUtbMV0sdHQ9S1syXSxfPUtbM107cmV0dXJuIEFbMF09VipIK3EqWixBWzFdPUoqSCtXKlosQVsyXT1WKnR0K3EqXyxBWzNdPUoqdHQrVypfLEF9ZnVuY3Rpb24gcChBLFUsSyl7dmFyIFY9VVswXSxKPVVbMV0scT1VWzJdLFc9VVszXSxIPU1hdGguc2luKEspLFo9TWF0aC5jb3MoSyk7cmV0dXJuIEFbMF09VipaK3EqSCxBWzFdPUoqWitXKkgsQVsyXT1WKi1IK3EqWixBWzNdPUoqLUgrVypaLEF9ZnVuY3Rpb24gaChBLFUsSyl7dmFyIFY9VVswXSxKPVVbMV0scT1VWzJdLFc9VVszXSxIPUtbMF0sWj1LWzFdO3JldHVybiBBWzBdPVYqSCxBWzFdPUoqSCxBWzJdPXEqWixBWzNdPVcqWixBfWZ1bmN0aW9uIG0oQSxVKXt2YXIgSz1NYXRoLnNpbihVKSxWPU1hdGguY29zKFUpO3JldHVybiBBWzBdPVYsQVsxXT1LLEFbMl09LUssQVszXT1WLEF9ZnVuY3Rpb24gcihBLFUpe3JldHVybiBBWzBdPVVbMF0sQVsxXT0wLEFbMl09MCxBWzNdPVVbMV0sQX1mdW5jdGlvbiBpKEEpe3JldHVybiJtYXQyKCIrQVswXSsiLCAiK0FbMV0rIiwgIitBWzJdKyIsICIrQVszXSsiKSJ9ZnVuY3Rpb24gbihBKXtyZXR1cm4gTWF0aC5oeXBvdChBWzBdLEFbMV0sQVsyXSxBWzNdKX1mdW5jdGlvbiBzKEEsVSxLLFYpe3JldHVybiBBWzJdPVZbMl0vVlswXSxLWzBdPVZbMF0sS1sxXT1WWzFdLEtbM109VlszXS1BWzJdKktbMV0sW0EsVSxLXX1mdW5jdGlvbiB4KEEsVSxLKXtyZXR1cm4gQVswXT1VWzBdK0tbMF0sQVsxXT1VWzFdK0tbMV0sQVsyXT1VWzJdK0tbMl0sQVszXT1VWzNdK0tbM10sQX1mdW5jdGlvbiBQKEEsVSxLKXtyZXR1cm4gQVswXT1VWzBdLUtbMF0sQVsxXT1VWzFdLUtbMV0sQVsyXT1VWzJdLUtbMl0sQVszXT1VWzNdLUtbM10sQX1mdW5jdGlvbiBSKEEsVSl7cmV0dXJuIEFbMF09PT1VWzBdJiZBWzFdPT09VVsxXSYmQVsyXT09PVVbMl0mJkFbM109PT1VWzNdfWZ1bmN0aW9uIGIoQSxVKXt2YXIgSz1BWzBdLFY9QVsxXSxKPUFbMl0scT1BWzNdLFc9VVswXSxIPVVbMV0sWj1VWzJdLHR0PVVbM107cmV0dXJuIE1hdGguYWJzKEstVyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEspLE1hdGguYWJzKFcpKSYmTWF0aC5hYnMoVi1IKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoViksTWF0aC5hYnMoSCkpJiZNYXRoLmFicyhKLVopPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKHEtdHQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyh0dCkpfWZ1bmN0aW9uIEUoQSxVLEspe3JldHVybiBBWzBdPVVbMF0qSyxBWzFdPVVbMV0qSyxBWzJdPVVbMl0qSyxBWzNdPVVbM10qSyxBfWZ1bmN0aW9uIEQoQSxVLEssVil7cmV0dXJuIEFbMF09VVswXStLWzBdKlYsQVsxXT1VWzFdK0tbMV0qVixBWzJdPVVbMl0rS1syXSpWLEFbM109VVszXStLWzNdKlYsQX12YXIgST1DLFM9UH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImRldGVybWluYW50IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImZyb21TY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiZnJvYiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KTt2YXIgYT10KDIpO2Z1bmN0aW9uIGwoKXt2YXIgUz1uZXcgYS5BUlJBWV9UWVBFKDYpO3JldHVybiBhLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKFNbMV09MCxTWzJdPTAsU1s0XT0wLFNbNV09MCksU1swXT0xLFNbM109MSxTfWZ1bmN0aW9uIE0oUyl7dmFyIEE9bmV3IGEuQVJSQVlfVFlQRSg2KTtyZXR1cm4gQVswXT1TWzBdLEFbMV09U1sxXSxBWzJdPVNbMl0sQVszXT1TWzNdLEFbNF09U1s0XSxBWzVdPVNbNV0sQX1mdW5jdGlvbiBUKFMsQSl7cmV0dXJuIFNbMF09QVswXSxTWzFdPUFbMV0sU1syXT1BWzJdLFNbM109QVszXSxTWzRdPUFbNF0sU1s1XT1BWzVdLFN9ZnVuY3Rpb24gZChTKXtyZXR1cm4gU1swXT0xLFNbMV09MCxTWzJdPTAsU1szXT0xLFNbNF09MCxTWzVdPTAsU31mdW5jdGlvbiB1KFMsQSxVLEssVixKKXt2YXIgcT1uZXcgYS5BUlJBWV9UWVBFKDYpO3JldHVybiBxWzBdPVMscVsxXT1BLHFbMl09VSxxWzNdPUsscVs0XT1WLHFbNV09SixxfWZ1bmN0aW9uIGMoUyxBLFUsSyxWLEoscSl7cmV0dXJuIFNbMF09QSxTWzFdPVUsU1syXT1LLFNbM109VixTWzRdPUosU1s1XT1xLFN9ZnVuY3Rpb24gTyhTLEEpe3ZhciBVPUFbMF0sSz1BWzFdLFY9QVsyXSxKPUFbM10scT1BWzRdLFc9QVs1XSxIPVUqSi1LKlY7cmV0dXJuIEg/KEg9MS9ILFNbMF09SipILFNbMV09LUsqSCxTWzJdPS1WKkgsU1szXT1VKkgsU1s0XT0oVipXLUoqcSkqSCxTWzVdPShLKnEtVSpXKSpILFMpOm51bGx9ZnVuY3Rpb24gZihTKXtyZXR1cm4gU1swXSpTWzNdLVNbMV0qU1syXX1mdW5jdGlvbiBnKFMsQSxVKXt2YXIgSz1BWzBdLFY9QVsxXSxKPUFbMl0scT1BWzNdLFc9QVs0XSxIPUFbNV0sWj1VWzBdLHR0PVVbMV0sXz1VWzJdLHN0PVVbM10saz1VWzRdLGN0PVVbNV07cmV0dXJuIFNbMF09SypaK0oqdHQsU1sxXT1WKlorcSp0dCxTWzJdPUsqXytKKnN0LFNbM109VipfK3Eqc3QsU1s0XT1LKmsrSipjdCtXLFNbNV09ViprK3EqY3QrSCxTfWZ1bmN0aW9uIHYoUyxBLFUpe3ZhciBLPUFbMF0sVj1BWzFdLEo9QVsyXSxxPUFbM10sVz1BWzRdLEg9QVs1XSxaPU1hdGguc2luKFUpLHR0PU1hdGguY29zKFUpO3JldHVybiBTWzBdPUsqdHQrSipaLFNbMV09Vip0dCtxKlosU1syXT1LKi1aK0oqdHQsU1szXT1WKi1aK3EqdHQsU1s0XT1XLFNbNV09SCxTfWZ1bmN0aW9uIEMoUyxBLFUpe3ZhciBLPUFbMF0sVj1BWzFdLEo9QVsyXSxxPUFbM10sVz1BWzRdLEg9QVs1XSxaPVVbMF0sdHQ9VVsxXTtyZXR1cm4gU1swXT1LKlosU1sxXT1WKlosU1syXT1KKnR0LFNbM109cSp0dCxTWzRdPVcsU1s1XT1ILFN9ZnVuY3Rpb24gcChTLEEsVSl7dmFyIEs9QVswXSxWPUFbMV0sSj1BWzJdLHE9QVszXSxXPUFbNF0sSD1BWzVdLFo9VVswXSx0dD1VWzFdO3JldHVybiBTWzBdPUssU1sxXT1WLFNbMl09SixTWzNdPXEsU1s0XT1LKlorSip0dCtXLFNbNV09VipaK3EqdHQrSCxTfWZ1bmN0aW9uIGgoUyxBKXt2YXIgVT1NYXRoLnNpbihBKSxLPU1hdGguY29zKEEpO3JldHVybiBTWzBdPUssU1sxXT1VLFNbMl09LVUsU1szXT1LLFNbNF09MCxTWzVdPTAsU31mdW5jdGlvbiBtKFMsQSl7cmV0dXJuIFNbMF09QVswXSxTWzFdPTAsU1syXT0wLFNbM109QVsxXSxTWzRdPTAsU1s1XT0wLFN9ZnVuY3Rpb24gcihTLEEpe3JldHVybiBTWzBdPTEsU1sxXT0wLFNbMl09MCxTWzNdPTEsU1s0XT1BWzBdLFNbNV09QVsxXSxTfWZ1bmN0aW9uIGkoUyl7cmV0dXJuIm1hdDJkKCIrU1swXSsiLCAiK1NbMV0rIiwgIitTWzJdKyIsICIrU1szXSsiLCAiK1NbNF0rIiwgIitTWzVdKyIpIn1mdW5jdGlvbiBuKFMpe3JldHVybiBNYXRoLmh5cG90KFNbMF0sU1sxXSxTWzJdLFNbM10sU1s0XSxTWzVdLDEpfWZ1bmN0aW9uIHMoUyxBLFUpe3JldHVybiBTWzBdPUFbMF0rVVswXSxTWzFdPUFbMV0rVVsxXSxTWzJdPUFbMl0rVVsyXSxTWzNdPUFbM10rVVszXSxTWzRdPUFbNF0rVVs0XSxTWzVdPUFbNV0rVVs1XSxTfWZ1bmN0aW9uIHgoUyxBLFUpe3JldHVybiBTWzBdPUFbMF0tVVswXSxTWzFdPUFbMV0tVVsxXSxTWzJdPUFbMl0tVVsyXSxTWzNdPUFbM10tVVszXSxTWzRdPUFbNF0tVVs0XSxTWzVdPUFbNV0tVVs1XSxTfWZ1bmN0aW9uIFAoUyxBLFUpe3JldHVybiBTWzBdPUFbMF0qVSxTWzFdPUFbMV0qVSxTWzJdPUFbMl0qVSxTWzNdPUFbM10qVSxTWzRdPUFbNF0qVSxTWzVdPUFbNV0qVSxTfWZ1bmN0aW9uIFIoUyxBLFUsSyl7cmV0dXJuIFNbMF09QVswXStVWzBdKkssU1sxXT1BWzFdK1VbMV0qSyxTWzJdPUFbMl0rVVsyXSpLLFNbM109QVszXStVWzNdKkssU1s0XT1BWzRdK1VbNF0qSyxTWzVdPUFbNV0rVVs1XSpLLFN9ZnVuY3Rpb24gYihTLEEpe3JldHVybiBTWzBdPT09QVswXSYmU1sxXT09PUFbMV0mJlNbMl09PT1BWzJdJiZTWzNdPT09QVszXSYmU1s0XT09PUFbNF0mJlNbNV09PT1BWzVdfWZ1bmN0aW9uIEUoUyxBKXt2YXIgVT1TWzBdLEs9U1sxXSxWPVNbMl0sSj1TWzNdLHE9U1s0XSxXPVNbNV0sSD1BWzBdLFo9QVsxXSx0dD1BWzJdLF89QVszXSxzdD1BWzRdLGs9QVs1XTtyZXR1cm4gTWF0aC5hYnMoVS1IKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoVSksTWF0aC5hYnMoSCkpJiZNYXRoLmFicyhLLVopPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhLKSxNYXRoLmFicyhaKSkmJk1hdGguYWJzKFYtdHQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhWKSxNYXRoLmFicyh0dCkpJiZNYXRoLmFicyhKLV8pPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhKKSxNYXRoLmFicyhfKSkmJk1hdGguYWJzKHEtc3QpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhxKSxNYXRoLmFicyhzdCkpJiZNYXRoLmFicyhXLWspPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhXKSxNYXRoLmFicyhrKSl9dmFyIEQ9ZyxJPXh9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsInRyYW5zcG9zZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJpbnZlcnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiYWRqb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJkZXRlcm1pbmFudCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJ0cmFuc2xhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsImZyb21UcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJmcm9tUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZnJvbU1hdDJkIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsImZyb21RdWF0IixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm5vcm1hbEZyb21NYXQ0IixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsInByb2plY3Rpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImZyb2IiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBxfSk7dmFyIGE9dCgyKTtmdW5jdGlvbiBsKCl7dmFyIFc9bmV3IGEuQVJSQVlfVFlQRSg5KTtyZXR1cm4gYS5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihXWzFdPTAsV1syXT0wLFdbM109MCxXWzVdPTAsV1s2XT0wLFdbN109MCksV1swXT0xLFdbNF09MSxXWzhdPTEsV31mdW5jdGlvbiBNKFcsSCl7cmV0dXJuIFdbMF09SFswXSxXWzFdPUhbMV0sV1syXT1IWzJdLFdbM109SFs0XSxXWzRdPUhbNV0sV1s1XT1IWzZdLFdbNl09SFs4XSxXWzddPUhbOV0sV1s4XT1IWzEwXSxXfWZ1bmN0aW9uIFQoVyl7dmFyIEg9bmV3IGEuQVJSQVlfVFlQRSg5KTtyZXR1cm4gSFswXT1XWzBdLEhbMV09V1sxXSxIWzJdPVdbMl0sSFszXT1XWzNdLEhbNF09V1s0XSxIWzVdPVdbNV0sSFs2XT1XWzZdLEhbN109V1s3XSxIWzhdPVdbOF0sSH1mdW5jdGlvbiBkKFcsSCl7cmV0dXJuIFdbMF09SFswXSxXWzFdPUhbMV0sV1syXT1IWzJdLFdbM109SFszXSxXWzRdPUhbNF0sV1s1XT1IWzVdLFdbNl09SFs2XSxXWzddPUhbN10sV1s4XT1IWzhdLFd9ZnVuY3Rpb24gdShXLEgsWix0dCxfLHN0LGssY3QsZnQpe3ZhciBCPW5ldyBhLkFSUkFZX1RZUEUoOSk7cmV0dXJuIEJbMF09VyxCWzFdPUgsQlsyXT1aLEJbM109dHQsQls0XT1fLEJbNV09c3QsQls2XT1rLEJbN109Y3QsQls4XT1mdCxCfWZ1bmN0aW9uIGMoVyxILFosdHQsXyxzdCxrLGN0LGZ0LEIpe3JldHVybiBXWzBdPUgsV1sxXT1aLFdbMl09dHQsV1szXT1fLFdbNF09c3QsV1s1XT1rLFdbNl09Y3QsV1s3XT1mdCxXWzhdPUIsV31mdW5jdGlvbiBPKFcpe3JldHVybiBXWzBdPTEsV1sxXT0wLFdbMl09MCxXWzNdPTAsV1s0XT0xLFdbNV09MCxXWzZdPTAsV1s3XT0wLFdbOF09MSxXfWZ1bmN0aW9uIGYoVyxIKXtpZihXPT09SCl7dmFyIFo9SFsxXSx0dD1IWzJdLF89SFs1XTtXWzFdPUhbM10sV1syXT1IWzZdLFdbM109WixXWzVdPUhbN10sV1s2XT10dCxXWzddPV99ZWxzZSBXWzBdPUhbMF0sV1sxXT1IWzNdLFdbMl09SFs2XSxXWzNdPUhbMV0sV1s0XT1IWzRdLFdbNV09SFs3XSxXWzZdPUhbMl0sV1s3XT1IWzVdLFdbOF09SFs4XTtyZXR1cm4gV31mdW5jdGlvbiBnKFcsSCl7dmFyIFo9SFswXSx0dD1IWzFdLF89SFsyXSxzdD1IWzNdLGs9SFs0XSxjdD1IWzVdLGZ0PUhbNl0sQj1IWzddLEY9SFs4XSxZPUYqay1jdCpCLFE9LUYqc3QrY3QqZnQsTj1CKnN0LWsqZnQsRz1aKlkrdHQqUStfKk47cmV0dXJuIEc/KEc9MS9HLFdbMF09WSpHLFdbMV09KC1GKnR0K18qQikqRyxXWzJdPShjdCp0dC1fKmspKkcsV1szXT1RKkcsV1s0XT0oRipaLV8qZnQpKkcsV1s1XT0oLWN0KlorXypzdCkqRyxXWzZdPU4qRyxXWzddPSgtQipaK3R0KmZ0KSpHLFdbOF09KGsqWi10dCpzdCkqRyxXKTpudWxsfWZ1bmN0aW9uIHYoVyxIKXt2YXIgWj1IWzBdLHR0PUhbMV0sXz1IWzJdLHN0PUhbM10saz1IWzRdLGN0PUhbNV0sZnQ9SFs2XSxCPUhbN10sRj1IWzhdO3JldHVybiBXWzBdPWsqRi1jdCpCLFdbMV09XypCLXR0KkYsV1syXT10dCpjdC1fKmssV1szXT1jdCpmdC1zdCpGLFdbNF09WipGLV8qZnQsV1s1XT1fKnN0LVoqY3QsV1s2XT1zdCpCLWsqZnQsV1s3XT10dCpmdC1aKkIsV1s4XT1aKmstdHQqc3QsV31mdW5jdGlvbiBDKFcpe3ZhciBIPVdbMF0sWj1XWzFdLHR0PVdbMl0sXz1XWzNdLHN0PVdbNF0saz1XWzVdLGN0PVdbNl0sZnQ9V1s3XSxCPVdbOF07cmV0dXJuIEgqKEIqc3QtaypmdCkrWiooLUIqXytrKmN0KSt0dCooZnQqXy1zdCpjdCl9ZnVuY3Rpb24gcChXLEgsWil7dmFyIHR0PUhbMF0sXz1IWzFdLHN0PUhbMl0saz1IWzNdLGN0PUhbNF0sZnQ9SFs1XSxCPUhbNl0sRj1IWzddLFk9SFs4XSxRPVpbMF0sTj1aWzFdLEc9WlsyXSxvPVpbM10seT1aWzRdLGo9Wls1XSx6PVpbNl0sJD1aWzddLFg9Wls4XTtyZXR1cm4gV1swXT1RKnR0K04qaytHKkIsV1sxXT1RKl8rTipjdCtHKkYsV1syXT1RKnN0K04qZnQrRypZLFdbM109byp0dCt5KmsraipCLFdbNF09bypfK3kqY3QraipGLFdbNV09bypzdCt5KmZ0K2oqWSxXWzZdPXoqdHQrJCprK1gqQixXWzddPXoqXyskKmN0K1gqRixXWzhdPXoqc3QrJCpmdCtYKlksV31mdW5jdGlvbiBoKFcsSCxaKXt2YXIgdHQ9SFswXSxfPUhbMV0sc3Q9SFsyXSxrPUhbM10sY3Q9SFs0XSxmdD1IWzVdLEI9SFs2XSxGPUhbN10sWT1IWzhdLFE9WlswXSxOPVpbMV07cmV0dXJuIFdbMF09dHQsV1sxXT1fLFdbMl09c3QsV1szXT1rLFdbNF09Y3QsV1s1XT1mdCxXWzZdPVEqdHQrTiprK0IsV1s3XT1RKl8rTipjdCtGLFdbOF09USpzdCtOKmZ0K1ksV31mdW5jdGlvbiBtKFcsSCxaKXt2YXIgdHQ9SFswXSxfPUhbMV0sc3Q9SFsyXSxrPUhbM10sY3Q9SFs0XSxmdD1IWzVdLEI9SFs2XSxGPUhbN10sWT1IWzhdLFE9TWF0aC5zaW4oWiksTj1NYXRoLmNvcyhaKTtyZXR1cm4gV1swXT1OKnR0K1EqayxXWzFdPU4qXytRKmN0LFdbMl09TipzdCtRKmZ0LFdbM109TiprLVEqdHQsV1s0XT1OKmN0LVEqXyxXWzVdPU4qZnQtUSpzdCxXWzZdPUIsV1s3XT1GLFdbOF09WSxXfWZ1bmN0aW9uIHIoVyxILFope3ZhciB0dD1aWzBdLF89WlsxXTtyZXR1cm4gV1swXT10dCpIWzBdLFdbMV09dHQqSFsxXSxXWzJdPXR0KkhbMl0sV1szXT1fKkhbM10sV1s0XT1fKkhbNF0sV1s1XT1fKkhbNV0sV1s2XT1IWzZdLFdbN109SFs3XSxXWzhdPUhbOF0sV31mdW5jdGlvbiBpKFcsSCl7cmV0dXJuIFdbMF09MSxXWzFdPTAsV1syXT0wLFdbM109MCxXWzRdPTEsV1s1XT0wLFdbNl09SFswXSxXWzddPUhbMV0sV1s4XT0xLFd9ZnVuY3Rpb24gbihXLEgpe3ZhciBaPU1hdGguc2luKEgpLHR0PU1hdGguY29zKEgpO3JldHVybiBXWzBdPXR0LFdbMV09WixXWzJdPTAsV1szXT0tWixXWzRdPXR0LFdbNV09MCxXWzZdPTAsV1s3XT0wLFdbOF09MSxXfWZ1bmN0aW9uIHMoVyxIKXtyZXR1cm4gV1swXT1IWzBdLFdbMV09MCxXWzJdPTAsV1szXT0wLFdbNF09SFsxXSxXWzVdPTAsV1s2XT0wLFdbN109MCxXWzhdPTEsV31mdW5jdGlvbiB4KFcsSCl7cmV0dXJuIFdbMF09SFswXSxXWzFdPUhbMV0sV1syXT0wLFdbM109SFsyXSxXWzRdPUhbM10sV1s1XT0wLFdbNl09SFs0XSxXWzddPUhbNV0sV1s4XT0xLFd9ZnVuY3Rpb24gUChXLEgpe3ZhciBaPUhbMF0sdHQ9SFsxXSxfPUhbMl0sc3Q9SFszXSxrPVorWixjdD10dCt0dCxmdD1fK18sQj1aKmssRj10dCprLFk9dHQqY3QsUT1fKmssTj1fKmN0LEc9XypmdCxvPXN0KmsseT1zdCpjdCxqPXN0KmZ0O3JldHVybiBXWzBdPTEtWS1HLFdbM109Ri1qLFdbNl09USt5LFdbMV09RitqLFdbNF09MS1CLUcsV1s3XT1OLW8sV1syXT1RLXksV1s1XT1OK28sV1s4XT0xLUItWSxXfWZ1bmN0aW9uIFIoVyxIKXt2YXIgWj1IWzBdLHR0PUhbMV0sXz1IWzJdLHN0PUhbM10saz1IWzRdLGN0PUhbNV0sZnQ9SFs2XSxCPUhbN10sRj1IWzhdLFk9SFs5XSxRPUhbMTBdLE49SFsxMV0sRz1IWzEyXSxvPUhbMTNdLHk9SFsxNF0saj1IWzE1XSx6PVoqY3QtdHQqaywkPVoqZnQtXyprLFg9WipCLXN0Kmssdz10dCpmdC1fKmN0LGV0PXR0KkItc3QqY3QscnQ9XypCLXN0KmZ0LGF0PUYqby1ZKkcsbHQ9Rip5LVEqRyxpdD1GKmotTipHLG50PVkqeS1RKm8sb3Q9WSpqLU4qbyxodD1RKmotTip5LGR0PXoqaHQtJCpvdCtYKm50K3cqaXQtZXQqbHQrcnQqYXQ7cmV0dXJuIGR0PyhkdD0xL2R0LFdbMF09KGN0Kmh0LWZ0Km90K0IqbnQpKmR0LFdbMV09KGZ0Kml0LWsqaHQtQipsdCkqZHQsV1syXT0oaypvdC1jdCppdCtCKmF0KSpkdCxXWzNdPShfKm90LXR0Kmh0LXN0Km50KSpkdCxXWzRdPShaKmh0LV8qaXQrc3QqbHQpKmR0LFdbNV09KHR0Kml0LVoqb3Qtc3QqYXQpKmR0LFdbNl09KG8qcnQteSpldCtqKncpKmR0LFdbN109KHkqWC1HKnJ0LWoqJCkqZHQsV1s4XT0oRypldC1vKlgraip6KSpkdCxXKTpudWxsfWZ1bmN0aW9uIGIoVyxILFope3JldHVybiBXWzBdPTIvSCxXWzFdPTAsV1syXT0wLFdbM109MCxXWzRdPS0yL1osV1s1XT0wLFdbNl09LTEsV1s3XT0xLFdbOF09MSxXfWZ1bmN0aW9uIEUoVyl7cmV0dXJuIm1hdDMoIitXWzBdKyIsICIrV1sxXSsiLCAiK1dbMl0rIiwgIitXWzNdKyIsICIrV1s0XSsiLCAiK1dbNV0rIiwgIitXWzZdKyIsICIrV1s3XSsiLCAiK1dbOF0rIikifWZ1bmN0aW9uIEQoVyl7cmV0dXJuIE1hdGguaHlwb3QoV1swXSxXWzFdLFdbMl0sV1szXSxXWzRdLFdbNV0sV1s2XSxXWzddLFdbOF0pfWZ1bmN0aW9uIEkoVyxILFope3JldHVybiBXWzBdPUhbMF0rWlswXSxXWzFdPUhbMV0rWlsxXSxXWzJdPUhbMl0rWlsyXSxXWzNdPUhbM10rWlszXSxXWzRdPUhbNF0rWls0XSxXWzVdPUhbNV0rWls1XSxXWzZdPUhbNl0rWls2XSxXWzddPUhbN10rWls3XSxXWzhdPUhbOF0rWls4XSxXfWZ1bmN0aW9uIFMoVyxILFope3JldHVybiBXWzBdPUhbMF0tWlswXSxXWzFdPUhbMV0tWlsxXSxXWzJdPUhbMl0tWlsyXSxXWzNdPUhbM10tWlszXSxXWzRdPUhbNF0tWls0XSxXWzVdPUhbNV0tWls1XSxXWzZdPUhbNl0tWls2XSxXWzddPUhbN10tWls3XSxXWzhdPUhbOF0tWls4XSxXfWZ1bmN0aW9uIEEoVyxILFope3JldHVybiBXWzBdPUhbMF0qWixXWzFdPUhbMV0qWixXWzJdPUhbMl0qWixXWzNdPUhbM10qWixXWzRdPUhbNF0qWixXWzVdPUhbNV0qWixXWzZdPUhbNl0qWixXWzddPUhbN10qWixXWzhdPUhbOF0qWixXfWZ1bmN0aW9uIFUoVyxILFosdHQpe3JldHVybiBXWzBdPUhbMF0rWlswXSp0dCxXWzFdPUhbMV0rWlsxXSp0dCxXWzJdPUhbMl0rWlsyXSp0dCxXWzNdPUhbM10rWlszXSp0dCxXWzRdPUhbNF0rWls0XSp0dCxXWzVdPUhbNV0rWls1XSp0dCxXWzZdPUhbNl0rWls2XSp0dCxXWzddPUhbN10rWls3XSp0dCxXWzhdPUhbOF0rWls4XSp0dCxXfWZ1bmN0aW9uIEsoVyxIKXtyZXR1cm4gV1swXT09PUhbMF0mJldbMV09PT1IWzFdJiZXWzJdPT09SFsyXSYmV1szXT09PUhbM10mJldbNF09PT1IWzRdJiZXWzVdPT09SFs1XSYmV1s2XT09PUhbNl0mJldbN109PT1IWzddJiZXWzhdPT09SFs4XX1mdW5jdGlvbiBWKFcsSCl7dmFyIFo9V1swXSx0dD1XWzFdLF89V1syXSxzdD1XWzNdLGs9V1s0XSxjdD1XWzVdLGZ0PVdbNl0sQj1XWzddLEY9V1s4XSxZPUhbMF0sUT1IWzFdLE49SFsyXSxHPUhbM10sbz1IWzRdLHk9SFs1XSxqPUhbNl0sej1IWzddLCQ9SFs4XTtyZXR1cm4gTWF0aC5hYnMoWi1ZKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWiksTWF0aC5hYnMoWSkpJiZNYXRoLmFicyh0dC1RKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModHQpLE1hdGguYWJzKFEpKSYmTWF0aC5hYnMoXy1OKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoXyksTWF0aC5hYnMoTikpJiZNYXRoLmFicyhzdC1HKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoc3QpLE1hdGguYWJzKEcpKSYmTWF0aC5hYnMoay1vKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoayksTWF0aC5hYnMobykpJiZNYXRoLmFicyhjdC15KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoY3QpLE1hdGguYWJzKHkpKSYmTWF0aC5hYnMoZnQtaik8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGZ0KSxNYXRoLmFicyhqKSkmJk1hdGguYWJzKEIteik8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEIpLE1hdGguYWJzKHopKSYmTWF0aC5hYnMoRi0kKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoRiksTWF0aC5hYnMoJCkpfXZhciBKPXAscT1TfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJpZGVudGl0eSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJ0cmFuc3Bvc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFkam9pbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZGV0ZXJtaW5hbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwidHJhbnNsYXRlIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInNjYWxlIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsInJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiByfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJmcm9tVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwiZnJvbVNjYWxpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwiZnJvbVJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsImZyb21YUm90YXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiZnJvbVlSb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJmcm9tWlJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImZyb21RdWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJnZXRUcmFuc2xhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJnZXRTY2FsaW5nIixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImdldFJvdGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsImZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJmcm9tUXVhdCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJmcnVzdHVtIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInBlcnNwZWN0aXZlIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3IixmdW5jdGlvbigpe3JldHVybiBIfSksdC5kKGUsIm9ydGhvIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImxvb2tBdCIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwidGFyZ2V0VG8iLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJmcm9iIixmdW5jdGlvbigpe3JldHVybiBrfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bHRpcGx5U2NhbGFyIixmdW5jdGlvbigpe3JldHVybiBCfSksdC5kKGUsIm11bHRpcGx5U2NhbGFyQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBGfSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBZfSksdC5kKGUsImVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIE59KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBHfSk7dmFyIGE9dCgyKTtmdW5jdGlvbiBsKCl7dmFyIG89bmV3IGEuQVJSQVlfVFlQRSgxNik7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYob1sxXT0wLG9bMl09MCxvWzNdPTAsb1s0XT0wLG9bNl09MCxvWzddPTAsb1s4XT0wLG9bOV09MCxvWzExXT0wLG9bMTJdPTAsb1sxM109MCxvWzE0XT0wKSxvWzBdPTEsb1s1XT0xLG9bMTBdPTEsb1sxNV09MSxvfWZ1bmN0aW9uIE0obyl7dmFyIHk9bmV3IGEuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHlbMF09b1swXSx5WzFdPW9bMV0seVsyXT1vWzJdLHlbM109b1szXSx5WzRdPW9bNF0seVs1XT1vWzVdLHlbNl09b1s2XSx5WzddPW9bN10seVs4XT1vWzhdLHlbOV09b1s5XSx5WzEwXT1vWzEwXSx5WzExXT1vWzExXSx5WzEyXT1vWzEyXSx5WzEzXT1vWzEzXSx5WzE0XT1vWzE0XSx5WzE1XT1vWzE1XSx5fWZ1bmN0aW9uIFQobyx5KXtyZXR1cm4gb1swXT15WzBdLG9bMV09eVsxXSxvWzJdPXlbMl0sb1szXT15WzNdLG9bNF09eVs0XSxvWzVdPXlbNV0sb1s2XT15WzZdLG9bN109eVs3XSxvWzhdPXlbOF0sb1s5XT15WzldLG9bMTBdPXlbMTBdLG9bMTFdPXlbMTFdLG9bMTJdPXlbMTJdLG9bMTNdPXlbMTNdLG9bMTRdPXlbMTRdLG9bMTVdPXlbMTVdLG99ZnVuY3Rpb24gZChvLHksaix6LCQsWCx3LGV0LHJ0LGF0LGx0LGl0LG50LG90LGh0LGR0KXt2YXIgdXQ9bmV3IGEuQVJSQVlfVFlQRSgxNik7cmV0dXJuIHV0WzBdPW8sdXRbMV09eSx1dFsyXT1qLHV0WzNdPXosdXRbNF09JCx1dFs1XT1YLHV0WzZdPXcsdXRbN109ZXQsdXRbOF09cnQsdXRbOV09YXQsdXRbMTBdPWx0LHV0WzExXT1pdCx1dFsxMl09bnQsdXRbMTNdPW90LHV0WzE0XT1odCx1dFsxNV09ZHQsdXR9ZnVuY3Rpb24gdShvLHksaix6LCQsWCx3LGV0LHJ0LGF0LGx0LGl0LG50LG90LGh0LGR0LHV0KXtyZXR1cm4gb1swXT15LG9bMV09aixvWzJdPXosb1szXT0kLG9bNF09WCxvWzVdPXcsb1s2XT1ldCxvWzddPXJ0LG9bOF09YXQsb1s5XT1sdCxvWzEwXT1pdCxvWzExXT1udCxvWzEyXT1vdCxvWzEzXT1odCxvWzE0XT1kdCxvWzE1XT11dCxvfWZ1bmN0aW9uIGMobyl7cmV0dXJuIG9bMF09MSxvWzFdPTAsb1syXT0wLG9bM109MCxvWzRdPTAsb1s1XT0xLG9bNl09MCxvWzddPTAsb1s4XT0wLG9bOV09MCxvWzEwXT0xLG9bMTFdPTAsb1sxMl09MCxvWzEzXT0wLG9bMTRdPTAsb1sxNV09MSxvfWZ1bmN0aW9uIE8obyx5KXtpZihvPT09eSl7dmFyIGo9eVsxXSx6PXlbMl0sJD15WzNdLFg9eVs2XSx3PXlbN10sZXQ9eVsxMV07b1sxXT15WzRdLG9bMl09eVs4XSxvWzNdPXlbMTJdLG9bNF09aixvWzZdPXlbOV0sb1s3XT15WzEzXSxvWzhdPXosb1s5XT1YLG9bMTFdPXlbMTRdLG9bMTJdPSQsb1sxM109dyxvWzE0XT1ldH1lbHNlIG9bMF09eVswXSxvWzFdPXlbNF0sb1syXT15WzhdLG9bM109eVsxMl0sb1s0XT15WzFdLG9bNV09eVs1XSxvWzZdPXlbOV0sb1s3XT15WzEzXSxvWzhdPXlbMl0sb1s5XT15WzZdLG9bMTBdPXlbMTBdLG9bMTFdPXlbMTRdLG9bMTJdPXlbM10sb1sxM109eVs3XSxvWzE0XT15WzExXSxvWzE1XT15WzE1XTtyZXR1cm4gb31mdW5jdGlvbiBmKG8seSl7dmFyIGo9eVswXSx6PXlbMV0sJD15WzJdLFg9eVszXSx3PXlbNF0sZXQ9eVs1XSxydD15WzZdLGF0PXlbN10sbHQ9eVs4XSxpdD15WzldLG50PXlbMTBdLG90PXlbMTFdLGh0PXlbMTJdLGR0PXlbMTNdLHV0PXlbMTRdLG10PXlbMTVdLE10PWoqZXQteip3LHZ0PWoqcnQtJCp3LHl0PWoqYXQtWCp3LHB0PXoqcnQtJCpldCx4dD16KmF0LVgqZXQsQ3Q9JCphdC1YKnJ0LFB0PWx0KmR0LWl0Kmh0LFN0PWx0KnV0LW50Kmh0LFJ0PWx0Km10LW90Kmh0LER0PWl0KnV0LW50KmR0LEx0PWl0Km10LW90KmR0LEl0PW50Km10LW90KnV0LEV0PU10Kkl0LXZ0Kkx0K3l0KkR0K3B0KlJ0LXh0KlN0K0N0KlB0O3JldHVybiBFdD8oRXQ9MS9FdCxvWzBdPShldCpJdC1ydCpMdCthdCpEdCkqRXQsb1sxXT0oJCpMdC16Kkl0LVgqRHQpKkV0LG9bMl09KGR0KkN0LXV0Knh0K210KnB0KSpFdCxvWzNdPShudCp4dC1pdCpDdC1vdCpwdCkqRXQsb1s0XT0ocnQqUnQtdypJdC1hdCpTdCkqRXQsb1s1XT0oaipJdC0kKlJ0K1gqU3QpKkV0LG9bNl09KHV0Knl0LWh0KkN0LW10KnZ0KSpFdCxvWzddPShsdCpDdC1udCp5dCtvdCp2dCkqRXQsb1s4XT0odypMdC1ldCpSdCthdCpQdCkqRXQsb1s5XT0oeipSdC1qKkx0LVgqUHQpKkV0LG9bMTBdPShodCp4dC1kdCp5dCttdCpNdCkqRXQsb1sxMV09KGl0Knl0LWx0Knh0LW90Kk10KSpFdCxvWzEyXT0oZXQqU3QtdypEdC1ydCpQdCkqRXQsb1sxM109KGoqRHQteipTdCskKlB0KSpFdCxvWzE0XT0oZHQqdnQtaHQqcHQtdXQqTXQpKkV0LG9bMTVdPShsdCpwdC1pdCp2dCtudCpNdCkqRXQsbyk6bnVsbH1mdW5jdGlvbiBnKG8seSl7dmFyIGo9eVswXSx6PXlbMV0sJD15WzJdLFg9eVszXSx3PXlbNF0sZXQ9eVs1XSxydD15WzZdLGF0PXlbN10sbHQ9eVs4XSxpdD15WzldLG50PXlbMTBdLG90PXlbMTFdLGh0PXlbMTJdLGR0PXlbMTNdLHV0PXlbMTRdLG10PXlbMTVdO3JldHVybiBvWzBdPWV0KihudCptdC1vdCp1dCktaXQqKHJ0Km10LWF0KnV0KStkdCoocnQqb3QtYXQqbnQpLG9bMV09LSh6KihudCptdC1vdCp1dCktaXQqKCQqbXQtWCp1dCkrZHQqKCQqb3QtWCpudCkpLG9bMl09eioocnQqbXQtYXQqdXQpLWV0KigkKm10LVgqdXQpK2R0KigkKmF0LVgqcnQpLG9bM109LSh6KihydCpvdC1hdCpudCktZXQqKCQqb3QtWCpudCkraXQqKCQqYXQtWCpydCkpLG9bNF09LSh3KihudCptdC1vdCp1dCktbHQqKHJ0Km10LWF0KnV0KStodCoocnQqb3QtYXQqbnQpKSxvWzVdPWoqKG50Km10LW90KnV0KS1sdCooJCptdC1YKnV0KStodCooJCpvdC1YKm50KSxvWzZdPS0oaioocnQqbXQtYXQqdXQpLXcqKCQqbXQtWCp1dCkraHQqKCQqYXQtWCpydCkpLG9bN109aioocnQqb3QtYXQqbnQpLXcqKCQqb3QtWCpudCkrbHQqKCQqYXQtWCpydCksb1s4XT13KihpdCptdC1vdCpkdCktbHQqKGV0Km10LWF0KmR0KStodCooZXQqb3QtYXQqaXQpLG9bOV09LShqKihpdCptdC1vdCpkdCktbHQqKHoqbXQtWCpkdCkraHQqKHoqb3QtWCppdCkpLG9bMTBdPWoqKGV0Km10LWF0KmR0KS13Kih6Km10LVgqZHQpK2h0Kih6KmF0LVgqZXQpLG9bMTFdPS0oaiooZXQqb3QtYXQqaXQpLXcqKHoqb3QtWCppdCkrbHQqKHoqYXQtWCpldCkpLG9bMTJdPS0odyooaXQqdXQtbnQqZHQpLWx0KihldCp1dC1ydCpkdCkraHQqKGV0Km50LXJ0Kml0KSksb1sxM109aiooaXQqdXQtbnQqZHQpLWx0Kih6KnV0LSQqZHQpK2h0Kih6Km50LSQqaXQpLG9bMTRdPS0oaiooZXQqdXQtcnQqZHQpLXcqKHoqdXQtJCpkdCkraHQqKHoqcnQtJCpldCkpLG9bMTVdPWoqKGV0Km50LXJ0Kml0KS13Kih6Km50LSQqaXQpK2x0Kih6KnJ0LSQqZXQpLG99ZnVuY3Rpb24gdihvKXt2YXIgeT1vWzBdLGo9b1sxXSx6PW9bMl0sJD1vWzNdLFg9b1s0XSx3PW9bNV0sZXQ9b1s2XSxydD1vWzddLGF0PW9bOF0sbHQ9b1s5XSxpdD1vWzEwXSxudD1vWzExXSxvdD1vWzEyXSxodD1vWzEzXSxkdD1vWzE0XSx1dD1vWzE1XSxtdD15KnctaipYLE10PXkqZXQteipYLHZ0PXkqcnQtJCpYLHl0PWoqZXQteip3LHB0PWoqcnQtJCp3LHh0PXoqcnQtJCpldCxDdD1hdCpodC1sdCpvdCxQdD1hdCpkdC1pdCpvdCxTdD1hdCp1dC1udCpvdCxSdD1sdCpkdC1pdCpodCxEdD1sdCp1dC1udCpodCxMdD1pdCp1dC1udCpkdDtyZXR1cm4gbXQqTHQtTXQqRHQrdnQqUnQreXQqU3QtcHQqUHQreHQqQ3R9ZnVuY3Rpb24gQyhvLHksail7dmFyIHo9eVswXSwkPXlbMV0sWD15WzJdLHc9eVszXSxldD15WzRdLHJ0PXlbNV0sYXQ9eVs2XSxsdD15WzddLGl0PXlbOF0sbnQ9eVs5XSxvdD15WzEwXSxodD15WzExXSxkdD15WzEyXSx1dD15WzEzXSxtdD15WzE0XSxNdD15WzE1XSx2dD1qWzBdLHl0PWpbMV0scHQ9alsyXSx4dD1qWzNdO3JldHVybiBvWzBdPXZ0KnoreXQqZXQrcHQqaXQreHQqZHQsb1sxXT12dCokK3l0KnJ0K3B0Km50K3h0KnV0LG9bMl09dnQqWCt5dCphdCtwdCpvdCt4dCptdCxvWzNdPXZ0KncreXQqbHQrcHQqaHQreHQqTXQsdnQ9als0XSx5dD1qWzVdLHB0PWpbNl0seHQ9als3XSxvWzRdPXZ0KnoreXQqZXQrcHQqaXQreHQqZHQsb1s1XT12dCokK3l0KnJ0K3B0Km50K3h0KnV0LG9bNl09dnQqWCt5dCphdCtwdCpvdCt4dCptdCxvWzddPXZ0KncreXQqbHQrcHQqaHQreHQqTXQsdnQ9als4XSx5dD1qWzldLHB0PWpbMTBdLHh0PWpbMTFdLG9bOF09dnQqeit5dCpldCtwdCppdCt4dCpkdCxvWzldPXZ0KiQreXQqcnQrcHQqbnQreHQqdXQsb1sxMF09dnQqWCt5dCphdCtwdCpvdCt4dCptdCxvWzExXT12dCp3K3l0Kmx0K3B0Kmh0K3h0Kk10LHZ0PWpbMTJdLHl0PWpbMTNdLHB0PWpbMTRdLHh0PWpbMTVdLG9bMTJdPXZ0KnoreXQqZXQrcHQqaXQreHQqZHQsb1sxM109dnQqJCt5dCpydCtwdCpudCt4dCp1dCxvWzE0XT12dCpYK3l0KmF0K3B0Km90K3h0Km10LG9bMTVdPXZ0KncreXQqbHQrcHQqaHQreHQqTXQsb31mdW5jdGlvbiBwKG8seSxqKXt2YXIgej1qWzBdLCQ9alsxXSxYPWpbMl0sdyxldCxydCxhdCxsdCxpdCxudCxvdCxodCxkdCx1dCxtdDtyZXR1cm4geT09PW8/KG9bMTJdPXlbMF0qeit5WzRdKiQreVs4XSpYK3lbMTJdLG9bMTNdPXlbMV0qeit5WzVdKiQreVs5XSpYK3lbMTNdLG9bMTRdPXlbMl0qeit5WzZdKiQreVsxMF0qWCt5WzE0XSxvWzE1XT15WzNdKnoreVs3XSokK3lbMTFdKlgreVsxNV0pOih3PXlbMF0sZXQ9eVsxXSxydD15WzJdLGF0PXlbM10sbHQ9eVs0XSxpdD15WzVdLG50PXlbNl0sb3Q9eVs3XSxodD15WzhdLGR0PXlbOV0sdXQ9eVsxMF0sbXQ9eVsxMV0sb1swXT13LG9bMV09ZXQsb1syXT1ydCxvWzNdPWF0LG9bNF09bHQsb1s1XT1pdCxvWzZdPW50LG9bN109b3Qsb1s4XT1odCxvWzldPWR0LG9bMTBdPXV0LG9bMTFdPW10LG9bMTJdPXcqeitsdCokK2h0KlgreVsxMl0sb1sxM109ZXQqeitpdCokK2R0KlgreVsxM10sb1sxNF09cnQqeitudCokK3V0KlgreVsxNF0sb1sxNV09YXQqeitvdCokK210KlgreVsxNV0pLG99ZnVuY3Rpb24gaChvLHksail7dmFyIHo9alswXSwkPWpbMV0sWD1qWzJdO3JldHVybiBvWzBdPXlbMF0qeixvWzFdPXlbMV0qeixvWzJdPXlbMl0qeixvWzNdPXlbM10qeixvWzRdPXlbNF0qJCxvWzVdPXlbNV0qJCxvWzZdPXlbNl0qJCxvWzddPXlbN10qJCxvWzhdPXlbOF0qWCxvWzldPXlbOV0qWCxvWzEwXT15WzEwXSpYLG9bMTFdPXlbMTFdKlgsb1sxMl09eVsxMl0sb1sxM109eVsxM10sb1sxNF09eVsxNF0sb1sxNV09eVsxNV0sb31mdW5jdGlvbiBtKG8seSxqLHope3ZhciAkPXpbMF0sWD16WzFdLHc9elsyXSxldD1NYXRoLmh5cG90KCQsWCx3KSxydCxhdCxsdCxpdCxudCxvdCxodCxkdCx1dCxtdCxNdCx2dCx5dCxwdCx4dCxDdCxQdCxTdCxSdCxEdCxMdCxJdCxFdCxVdDtyZXR1cm4gZXQ8YS5FUFNJTE9OP251bGw6KGV0PTEvZXQsJCo9ZXQsWCo9ZXQsdyo9ZXQscnQ9TWF0aC5zaW4oaiksYXQ9TWF0aC5jb3MoaiksbHQ9MS1hdCxpdD15WzBdLG50PXlbMV0sb3Q9eVsyXSxodD15WzNdLGR0PXlbNF0sdXQ9eVs1XSxtdD15WzZdLE10PXlbN10sdnQ9eVs4XSx5dD15WzldLHB0PXlbMTBdLHh0PXlbMTFdLEN0PSQqJCpsdCthdCxQdD1YKiQqbHQrdypydCxTdD13KiQqbHQtWCpydCxSdD0kKlgqbHQtdypydCxEdD1YKlgqbHQrYXQsTHQ9dypYKmx0KyQqcnQsSXQ9JCp3Kmx0K1gqcnQsRXQ9WCp3Kmx0LSQqcnQsVXQ9dyp3Kmx0K2F0LG9bMF09aXQqQ3QrZHQqUHQrdnQqU3Qsb1sxXT1udCpDdCt1dCpQdCt5dCpTdCxvWzJdPW90KkN0K210KlB0K3B0KlN0LG9bM109aHQqQ3QrTXQqUHQreHQqU3Qsb1s0XT1pdCpSdCtkdCpEdCt2dCpMdCxvWzVdPW50KlJ0K3V0KkR0K3l0Kkx0LG9bNl09b3QqUnQrbXQqRHQrcHQqTHQsb1s3XT1odCpSdCtNdCpEdCt4dCpMdCxvWzhdPWl0Kkl0K2R0KkV0K3Z0KlV0LG9bOV09bnQqSXQrdXQqRXQreXQqVXQsb1sxMF09b3QqSXQrbXQqRXQrcHQqVXQsb1sxMV09aHQqSXQrTXQqRXQreHQqVXQseSE9PW8mJihvWzEyXT15WzEyXSxvWzEzXT15WzEzXSxvWzE0XT15WzE0XSxvWzE1XT15WzE1XSksbyl9ZnVuY3Rpb24gcihvLHksail7dmFyIHo9TWF0aC5zaW4oaiksJD1NYXRoLmNvcyhqKSxYPXlbNF0sdz15WzVdLGV0PXlbNl0scnQ9eVs3XSxhdD15WzhdLGx0PXlbOV0saXQ9eVsxMF0sbnQ9eVsxMV07cmV0dXJuIHkhPT1vJiYob1swXT15WzBdLG9bMV09eVsxXSxvWzJdPXlbMl0sb1szXT15WzNdLG9bMTJdPXlbMTJdLG9bMTNdPXlbMTNdLG9bMTRdPXlbMTRdLG9bMTVdPXlbMTVdKSxvWzRdPVgqJCthdCp6LG9bNV09dyokK2x0Knosb1s2XT1ldCokK2l0Knosb1s3XT1ydCokK250Knosb1s4XT1hdCokLVgqeixvWzldPWx0KiQtdyp6LG9bMTBdPWl0KiQtZXQqeixvWzExXT1udCokLXJ0Knosb31mdW5jdGlvbiBpKG8seSxqKXt2YXIgej1NYXRoLnNpbihqKSwkPU1hdGguY29zKGopLFg9eVswXSx3PXlbMV0sZXQ9eVsyXSxydD15WzNdLGF0PXlbOF0sbHQ9eVs5XSxpdD15WzEwXSxudD15WzExXTtyZXR1cm4geSE9PW8mJihvWzRdPXlbNF0sb1s1XT15WzVdLG9bNl09eVs2XSxvWzddPXlbN10sb1sxMl09eVsxMl0sb1sxM109eVsxM10sb1sxNF09eVsxNF0sb1sxNV09eVsxNV0pLG9bMF09WCokLWF0Knosb1sxXT13KiQtbHQqeixvWzJdPWV0KiQtaXQqeixvWzNdPXJ0KiQtbnQqeixvWzhdPVgqeithdCokLG9bOV09dyp6K2x0KiQsb1sxMF09ZXQqeitpdCokLG9bMTFdPXJ0KnorbnQqJCxvfWZ1bmN0aW9uIG4obyx5LGope3ZhciB6PU1hdGguc2luKGopLCQ9TWF0aC5jb3MoaiksWD15WzBdLHc9eVsxXSxldD15WzJdLHJ0PXlbM10sYXQ9eVs0XSxsdD15WzVdLGl0PXlbNl0sbnQ9eVs3XTtyZXR1cm4geSE9PW8mJihvWzhdPXlbOF0sb1s5XT15WzldLG9bMTBdPXlbMTBdLG9bMTFdPXlbMTFdLG9bMTJdPXlbMTJdLG9bMTNdPXlbMTNdLG9bMTRdPXlbMTRdLG9bMTVdPXlbMTVdKSxvWzBdPVgqJCthdCp6LG9bMV09dyokK2x0Knosb1syXT1ldCokK2l0Knosb1szXT1ydCokK250Knosb1s0XT1hdCokLVgqeixvWzVdPWx0KiQtdyp6LG9bNl09aXQqJC1ldCp6LG9bN109bnQqJC1ydCp6LG99ZnVuY3Rpb24gcyhvLHkpe3JldHVybiBvWzBdPTEsb1sxXT0wLG9bMl09MCxvWzNdPTAsb1s0XT0wLG9bNV09MSxvWzZdPTAsb1s3XT0wLG9bOF09MCxvWzldPTAsb1sxMF09MSxvWzExXT0wLG9bMTJdPXlbMF0sb1sxM109eVsxXSxvWzE0XT15WzJdLG9bMTVdPTEsb31mdW5jdGlvbiB4KG8seSl7cmV0dXJuIG9bMF09eVswXSxvWzFdPTAsb1syXT0wLG9bM109MCxvWzRdPTAsb1s1XT15WzFdLG9bNl09MCxvWzddPTAsb1s4XT0wLG9bOV09MCxvWzEwXT15WzJdLG9bMTFdPTAsb1sxMl09MCxvWzEzXT0wLG9bMTRdPTAsb1sxNV09MSxvfWZ1bmN0aW9uIFAobyx5LGope3ZhciB6PWpbMF0sJD1qWzFdLFg9alsyXSx3PU1hdGguaHlwb3QoeiwkLFgpLGV0LHJ0LGF0O3JldHVybiB3PGEuRVBTSUxPTj9udWxsOih3PTEvdyx6Kj13LCQqPXcsWCo9dyxldD1NYXRoLnNpbih5KSxydD1NYXRoLmNvcyh5KSxhdD0xLXJ0LG9bMF09eip6KmF0K3J0LG9bMV09JCp6KmF0K1gqZXQsb1syXT1YKnoqYXQtJCpldCxvWzNdPTAsb1s0XT16KiQqYXQtWCpldCxvWzVdPSQqJCphdCtydCxvWzZdPVgqJCphdCt6KmV0LG9bN109MCxvWzhdPXoqWCphdCskKmV0LG9bOV09JCpYKmF0LXoqZXQsb1sxMF09WCpYKmF0K3J0LG9bMTFdPTAsb1sxMl09MCxvWzEzXT0wLG9bMTRdPTAsb1sxNV09MSxvKX1mdW5jdGlvbiBSKG8seSl7dmFyIGo9TWF0aC5zaW4oeSksej1NYXRoLmNvcyh5KTtyZXR1cm4gb1swXT0xLG9bMV09MCxvWzJdPTAsb1szXT0wLG9bNF09MCxvWzVdPXosb1s2XT1qLG9bN109MCxvWzhdPTAsb1s5XT0taixvWzEwXT16LG9bMTFdPTAsb1sxMl09MCxvWzEzXT0wLG9bMTRdPTAsb1sxNV09MSxvfWZ1bmN0aW9uIGIobyx5KXt2YXIgaj1NYXRoLnNpbih5KSx6PU1hdGguY29zKHkpO3JldHVybiBvWzBdPXosb1sxXT0wLG9bMl09LWosb1szXT0wLG9bNF09MCxvWzVdPTEsb1s2XT0wLG9bN109MCxvWzhdPWosb1s5XT0wLG9bMTBdPXosb1sxMV09MCxvWzEyXT0wLG9bMTNdPTAsb1sxNF09MCxvWzE1XT0xLG99ZnVuY3Rpb24gRShvLHkpe3ZhciBqPU1hdGguc2luKHkpLHo9TWF0aC5jb3MoeSk7cmV0dXJuIG9bMF09eixvWzFdPWosb1syXT0wLG9bM109MCxvWzRdPS1qLG9bNV09eixvWzZdPTAsb1s3XT0wLG9bOF09MCxvWzldPTAsb1sxMF09MSxvWzExXT0wLG9bMTJdPTAsb1sxM109MCxvWzE0XT0wLG9bMTVdPTEsb31mdW5jdGlvbiBEKG8seSxqKXt2YXIgej15WzBdLCQ9eVsxXSxYPXlbMl0sdz15WzNdLGV0PXoreixydD0kKyQsYXQ9WCtYLGx0PXoqZXQsaXQ9eipydCxudD16KmF0LG90PSQqcnQsaHQ9JCphdCxkdD1YKmF0LHV0PXcqZXQsbXQ9dypydCxNdD13KmF0O3JldHVybiBvWzBdPTEtKG90K2R0KSxvWzFdPWl0K010LG9bMl09bnQtbXQsb1szXT0wLG9bNF09aXQtTXQsb1s1XT0xLShsdCtkdCksb1s2XT1odCt1dCxvWzddPTAsb1s4XT1udCttdCxvWzldPWh0LXV0LG9bMTBdPTEtKGx0K290KSxvWzExXT0wLG9bMTJdPWpbMF0sb1sxM109alsxXSxvWzE0XT1qWzJdLG9bMTVdPTEsb31mdW5jdGlvbiBJKG8seSl7dmFyIGo9bmV3IGEuQVJSQVlfVFlQRSgzKSx6PS15WzBdLCQ9LXlbMV0sWD0teVsyXSx3PXlbM10sZXQ9eVs0XSxydD15WzVdLGF0PXlbNl0sbHQ9eVs3XSxpdD16KnorJCokK1gqWCt3Knc7cmV0dXJuIGl0PjA/KGpbMF09KGV0KncrbHQqeitydCpYLWF0KiQpKjIvaXQsalsxXT0ocnQqdytsdCokK2F0KnotZXQqWCkqMi9pdCxqWzJdPShhdCp3K2x0KlgrZXQqJC1ydCp6KSoyL2l0KTooalswXT0oZXQqdytsdCp6K3J0KlgtYXQqJCkqMixqWzFdPShydCp3K2x0KiQrYXQqei1ldCpYKSoyLGpbMl09KGF0KncrbHQqWCtldCokLXJ0KnopKjIpLEQobyx5LGopLG99ZnVuY3Rpb24gUyhvLHkpe3JldHVybiBvWzBdPXlbMTJdLG9bMV09eVsxM10sb1syXT15WzE0XSxvfWZ1bmN0aW9uIEEobyx5KXt2YXIgaj15WzBdLHo9eVsxXSwkPXlbMl0sWD15WzRdLHc9eVs1XSxldD15WzZdLHJ0PXlbOF0sYXQ9eVs5XSxsdD15WzEwXTtyZXR1cm4gb1swXT1NYXRoLmh5cG90KGoseiwkKSxvWzFdPU1hdGguaHlwb3QoWCx3LGV0KSxvWzJdPU1hdGguaHlwb3QocnQsYXQsbHQpLG99ZnVuY3Rpb24gVShvLHkpe3ZhciBqPW5ldyBhLkFSUkFZX1RZUEUoMyk7QShqLHkpO3ZhciB6PTEvalswXSwkPTEvalsxXSxYPTEvalsyXSx3PXlbMF0qeixldD15WzFdKiQscnQ9eVsyXSpYLGF0PXlbNF0qeixsdD15WzVdKiQsaXQ9eVs2XSpYLG50PXlbOF0qeixvdD15WzldKiQsaHQ9eVsxMF0qWCxkdD13K2x0K2h0LHV0PTA7cmV0dXJuIGR0PjA/KHV0PU1hdGguc3FydChkdCsxKSoyLG9bM109LjI1KnV0LG9bMF09KGl0LW90KS91dCxvWzFdPShudC1ydCkvdXQsb1syXT0oZXQtYXQpL3V0KTp3Pmx0JiZ3Pmh0Pyh1dD1NYXRoLnNxcnQoMSt3LWx0LWh0KSoyLG9bM109KGl0LW90KS91dCxvWzBdPS4yNSp1dCxvWzFdPShldCthdCkvdXQsb1syXT0obnQrcnQpL3V0KTpsdD5odD8odXQ9TWF0aC5zcXJ0KDErbHQtdy1odCkqMixvWzNdPShudC1ydCkvdXQsb1swXT0oZXQrYXQpL3V0LG9bMV09LjI1KnV0LG9bMl09KGl0K290KS91dCk6KHV0PU1hdGguc3FydCgxK2h0LXctbHQpKjIsb1szXT0oZXQtYXQpL3V0LG9bMF09KG50K3J0KS91dCxvWzFdPShpdCtvdCkvdXQsb1syXT0uMjUqdXQpLG99ZnVuY3Rpb24gSyhvLHksaix6KXt2YXIgJD15WzBdLFg9eVsxXSx3PXlbMl0sZXQ9eVszXSxydD0kKyQsYXQ9WCtYLGx0PXcrdyxpdD0kKnJ0LG50PSQqYXQsb3Q9JCpsdCxodD1YKmF0LGR0PVgqbHQsdXQ9dypsdCxtdD1ldCpydCxNdD1ldCphdCx2dD1ldCpsdCx5dD16WzBdLHB0PXpbMV0seHQ9elsyXTtyZXR1cm4gb1swXT0oMS0oaHQrdXQpKSp5dCxvWzFdPShudCt2dCkqeXQsb1syXT0ob3QtTXQpKnl0LG9bM109MCxvWzRdPShudC12dCkqcHQsb1s1XT0oMS0oaXQrdXQpKSpwdCxvWzZdPShkdCttdCkqcHQsb1s3XT0wLG9bOF09KG90K010KSp4dCxvWzldPShkdC1tdCkqeHQsb1sxMF09KDEtKGl0K2h0KSkqeHQsb1sxMV09MCxvWzEyXT1qWzBdLG9bMTNdPWpbMV0sb1sxNF09alsyXSxvWzE1XT0xLG99ZnVuY3Rpb24gVihvLHksaix6LCQpe3ZhciBYPXlbMF0sdz15WzFdLGV0PXlbMl0scnQ9eVszXSxhdD1YK1gsbHQ9dyt3LGl0PWV0K2V0LG50PVgqYXQsb3Q9WCpsdCxodD1YKml0LGR0PXcqbHQsdXQ9dyppdCxtdD1ldCppdCxNdD1ydCphdCx2dD1ydCpsdCx5dD1ydCppdCxwdD16WzBdLHh0PXpbMV0sQ3Q9elsyXSxQdD0kWzBdLFN0PSRbMV0sUnQ9JFsyXSxEdD0oMS0oZHQrbXQpKSpwdCxMdD0ob3QreXQpKnB0LEl0PShodC12dCkqcHQsRXQ9KG90LXl0KSp4dCxVdD0oMS0obnQrbXQpKSp4dCxWdD0odXQrTXQpKnh0LFl0PShodCt2dCkqQ3QsbmU9KHV0LU10KSpDdCxpZT0oMS0obnQrZHQpKSpDdDtyZXR1cm4gb1swXT1EdCxvWzFdPUx0LG9bMl09SXQsb1szXT0wLG9bNF09RXQsb1s1XT1VdCxvWzZdPVZ0LG9bN109MCxvWzhdPVl0LG9bOV09bmUsb1sxMF09aWUsb1sxMV09MCxvWzEyXT1qWzBdK1B0LShEdCpQdCtFdCpTdCtZdCpSdCksb1sxM109alsxXStTdC0oTHQqUHQrVXQqU3QrbmUqUnQpLG9bMTRdPWpbMl0rUnQtKEl0KlB0K1Z0KlN0K2llKlJ0KSxvWzE1XT0xLG99ZnVuY3Rpb24gSihvLHkpe3ZhciBqPXlbMF0sej15WzFdLCQ9eVsyXSxYPXlbM10sdz1qK2osZXQ9eit6LHJ0PSQrJCxhdD1qKncsbHQ9eip3LGl0PXoqZXQsbnQ9JCp3LG90PSQqZXQsaHQ9JCpydCxkdD1YKncsdXQ9WCpldCxtdD1YKnJ0O3JldHVybiBvWzBdPTEtaXQtaHQsb1sxXT1sdCttdCxvWzJdPW50LXV0LG9bM109MCxvWzRdPWx0LW10LG9bNV09MS1hdC1odCxvWzZdPW90K2R0LG9bN109MCxvWzhdPW50K3V0LG9bOV09b3QtZHQsb1sxMF09MS1hdC1pdCxvWzExXT0wLG9bMTJdPTAsb1sxM109MCxvWzE0XT0wLG9bMTVdPTEsb31mdW5jdGlvbiBxKG8seSxqLHosJCxYLHcpe3ZhciBldD0xLyhqLXkpLHJ0PTEvKCQteiksYXQ9MS8oWC13KTtyZXR1cm4gb1swXT1YKjIqZXQsb1sxXT0wLG9bMl09MCxvWzNdPTAsb1s0XT0wLG9bNV09WCoyKnJ0LG9bNl09MCxvWzddPTAsb1s4XT0oait5KSpldCxvWzldPSgkK3opKnJ0LG9bMTBdPSh3K1gpKmF0LG9bMTFdPS0xLG9bMTJdPTAsb1sxM109MCxvWzE0XT13KlgqMiphdCxvWzE1XT0wLG99ZnVuY3Rpb24gVyhvLHksaix6LCQpe3ZhciBYPTEvTWF0aC50YW4oeS8yKSx3O3JldHVybiBvWzBdPVgvaixvWzFdPTAsb1syXT0wLG9bM109MCxvWzRdPTAsb1s1XT1YLG9bNl09MCxvWzddPTAsb1s4XT0wLG9bOV09MCxvWzExXT0tMSxvWzEyXT0wLG9bMTNdPTAsb1sxNV09MCwkIT1udWxsJiYkIT09MS8wPyh3PTEvKHotJCksb1sxMF09KCQreikqdyxvWzE0XT0yKiQqeip3KToob1sxMF09LTEsb1sxNF09LTIqeiksb31mdW5jdGlvbiBIKG8seSxqLHope3ZhciAkPU1hdGgudGFuKHkudXBEZWdyZWVzKk1hdGguUEkvMTgwKSxYPU1hdGgudGFuKHkuZG93bkRlZ3JlZXMqTWF0aC5QSS8xODApLHc9TWF0aC50YW4oeS5sZWZ0RGVncmVlcypNYXRoLlBJLzE4MCksZXQ9TWF0aC50YW4oeS5yaWdodERlZ3JlZXMqTWF0aC5QSS8xODApLHJ0PTIvKHcrZXQpLGF0PTIvKCQrWCk7cmV0dXJuIG9bMF09cnQsb1sxXT0wLG9bMl09MCxvWzNdPTAsb1s0XT0wLG9bNV09YXQsb1s2XT0wLG9bN109MCxvWzhdPS0oKHctZXQpKnJ0Ki41KSxvWzldPSgkLVgpKmF0Ki41LG9bMTBdPXovKGoteiksb1sxMV09LTEsb1sxMl09MCxvWzEzXT0wLG9bMTRdPXoqai8oai16KSxvWzE1XT0wLG99ZnVuY3Rpb24gWihvLHksaix6LCQsWCx3KXt2YXIgZXQ9MS8oeS1qKSxydD0xLyh6LSQpLGF0PTEvKFgtdyk7cmV0dXJuIG9bMF09LTIqZXQsb1sxXT0wLG9bMl09MCxvWzNdPTAsb1s0XT0wLG9bNV09LTIqcnQsb1s2XT0wLG9bN109MCxvWzhdPTAsb1s5XT0wLG9bMTBdPTIqYXQsb1sxMV09MCxvWzEyXT0oeStqKSpldCxvWzEzXT0oJCt6KSpydCxvWzE0XT0odytYKSphdCxvWzE1XT0xLG99ZnVuY3Rpb24gdHQobyx5LGoseil7dmFyICQsWCx3LGV0LHJ0LGF0LGx0LGl0LG50LG90LGh0PXlbMF0sZHQ9eVsxXSx1dD15WzJdLG10PXpbMF0sTXQ9elsxXSx2dD16WzJdLHl0PWpbMF0scHQ9alsxXSx4dD1qWzJdO3JldHVybiBNYXRoLmFicyhodC15dCk8YS5FUFNJTE9OJiZNYXRoLmFicyhkdC1wdCk8YS5FUFNJTE9OJiZNYXRoLmFicyh1dC14dCk8YS5FUFNJTE9OP2Mobyk6KGx0PWh0LXl0LGl0PWR0LXB0LG50PXV0LXh0LG90PTEvTWF0aC5oeXBvdChsdCxpdCxudCksbHQqPW90LGl0Kj1vdCxudCo9b3QsJD1NdCpudC12dCppdCxYPXZ0Kmx0LW10Km50LHc9bXQqaXQtTXQqbHQsb3Q9TWF0aC5oeXBvdCgkLFgsdyksb3Q/KG90PTEvb3QsJCo9b3QsWCo9b3Qsdyo9b3QpOigkPTAsWD0wLHc9MCksZXQ9aXQqdy1udCpYLHJ0PW50KiQtbHQqdyxhdD1sdCpYLWl0KiQsb3Q9TWF0aC5oeXBvdChldCxydCxhdCksb3Q/KG90PTEvb3QsZXQqPW90LHJ0Kj1vdCxhdCo9b3QpOihldD0wLHJ0PTAsYXQ9MCksb1swXT0kLG9bMV09ZXQsb1syXT1sdCxvWzNdPTAsb1s0XT1YLG9bNV09cnQsb1s2XT1pdCxvWzddPTAsb1s4XT13LG9bOV09YXQsb1sxMF09bnQsb1sxMV09MCxvWzEyXT0tKCQqaHQrWCpkdCt3KnV0KSxvWzEzXT0tKGV0Kmh0K3J0KmR0K2F0KnV0KSxvWzE0XT0tKGx0Kmh0K2l0KmR0K250KnV0KSxvWzE1XT0xLG8pfWZ1bmN0aW9uIF8obyx5LGoseil7dmFyICQ9eVswXSxYPXlbMV0sdz15WzJdLGV0PXpbMF0scnQ9elsxXSxhdD16WzJdLGx0PSQtalswXSxpdD1YLWpbMV0sbnQ9dy1qWzJdLG90PWx0Kmx0K2l0Kml0K250Km50O290PjAmJihvdD0xL01hdGguc3FydChvdCksbHQqPW90LGl0Kj1vdCxudCo9b3QpO3ZhciBodD1ydCpudC1hdCppdCxkdD1hdCpsdC1ldCpudCx1dD1ldCppdC1ydCpsdDtyZXR1cm4gb3Q9aHQqaHQrZHQqZHQrdXQqdXQsb3Q+MCYmKG90PTEvTWF0aC5zcXJ0KG90KSxodCo9b3QsZHQqPW90LHV0Kj1vdCksb1swXT1odCxvWzFdPWR0LG9bMl09dXQsb1szXT0wLG9bNF09aXQqdXQtbnQqZHQsb1s1XT1udCpodC1sdCp1dCxvWzZdPWx0KmR0LWl0Kmh0LG9bN109MCxvWzhdPWx0LG9bOV09aXQsb1sxMF09bnQsb1sxMV09MCxvWzEyXT0kLG9bMTNdPVgsb1sxNF09dyxvWzE1XT0xLG99ZnVuY3Rpb24gc3Qobyl7cmV0dXJuIm1hdDQoIitvWzBdKyIsICIrb1sxXSsiLCAiK29bMl0rIiwgIitvWzNdKyIsICIrb1s0XSsiLCAiK29bNV0rIiwgIitvWzZdKyIsICIrb1s3XSsiLCAiK29bOF0rIiwgIitvWzldKyIsICIrb1sxMF0rIiwgIitvWzExXSsiLCAiK29bMTJdKyIsICIrb1sxM10rIiwgIitvWzE0XSsiLCAiK29bMTVdKyIpIn1mdW5jdGlvbiBrKG8pe3JldHVybiBNYXRoLmh5cG90KG9bMF0sb1sxXSxvWzJdLG9bM10sb1s0XSxvWzVdLG9bNl0sb1s3XSxvWzhdLG9bOV0sb1sxMF0sb1sxMV0sb1sxMl0sb1sxM10sb1sxNF0sb1sxNV0pfWZ1bmN0aW9uIGN0KG8seSxqKXtyZXR1cm4gb1swXT15WzBdK2pbMF0sb1sxXT15WzFdK2pbMV0sb1syXT15WzJdK2pbMl0sb1szXT15WzNdK2pbM10sb1s0XT15WzRdK2pbNF0sb1s1XT15WzVdK2pbNV0sb1s2XT15WzZdK2pbNl0sb1s3XT15WzddK2pbN10sb1s4XT15WzhdK2pbOF0sb1s5XT15WzldK2pbOV0sb1sxMF09eVsxMF0ralsxMF0sb1sxMV09eVsxMV0ralsxMV0sb1sxMl09eVsxMl0ralsxMl0sb1sxM109eVsxM10ralsxM10sb1sxNF09eVsxNF0ralsxNF0sb1sxNV09eVsxNV0ralsxNV0sb31mdW5jdGlvbiBmdChvLHksail7cmV0dXJuIG9bMF09eVswXS1qWzBdLG9bMV09eVsxXS1qWzFdLG9bMl09eVsyXS1qWzJdLG9bM109eVszXS1qWzNdLG9bNF09eVs0XS1qWzRdLG9bNV09eVs1XS1qWzVdLG9bNl09eVs2XS1qWzZdLG9bN109eVs3XS1qWzddLG9bOF09eVs4XS1qWzhdLG9bOV09eVs5XS1qWzldLG9bMTBdPXlbMTBdLWpbMTBdLG9bMTFdPXlbMTFdLWpbMTFdLG9bMTJdPXlbMTJdLWpbMTJdLG9bMTNdPXlbMTNdLWpbMTNdLG9bMTRdPXlbMTRdLWpbMTRdLG9bMTVdPXlbMTVdLWpbMTVdLG99ZnVuY3Rpb24gQihvLHksail7cmV0dXJuIG9bMF09eVswXSpqLG9bMV09eVsxXSpqLG9bMl09eVsyXSpqLG9bM109eVszXSpqLG9bNF09eVs0XSpqLG9bNV09eVs1XSpqLG9bNl09eVs2XSpqLG9bN109eVs3XSpqLG9bOF09eVs4XSpqLG9bOV09eVs5XSpqLG9bMTBdPXlbMTBdKmosb1sxMV09eVsxMV0qaixvWzEyXT15WzEyXSpqLG9bMTNdPXlbMTNdKmosb1sxNF09eVsxNF0qaixvWzE1XT15WzE1XSpqLG99ZnVuY3Rpb24gRihvLHksaix6KXtyZXR1cm4gb1swXT15WzBdK2pbMF0qeixvWzFdPXlbMV0ralsxXSp6LG9bMl09eVsyXStqWzJdKnosb1szXT15WzNdK2pbM10qeixvWzRdPXlbNF0rals0XSp6LG9bNV09eVs1XStqWzVdKnosb1s2XT15WzZdK2pbNl0qeixvWzddPXlbN10rals3XSp6LG9bOF09eVs4XStqWzhdKnosb1s5XT15WzldK2pbOV0qeixvWzEwXT15WzEwXStqWzEwXSp6LG9bMTFdPXlbMTFdK2pbMTFdKnosb1sxMl09eVsxMl0ralsxMl0qeixvWzEzXT15WzEzXStqWzEzXSp6LG9bMTRdPXlbMTRdK2pbMTRdKnosb1sxNV09eVsxNV0ralsxNV0qeixvfWZ1bmN0aW9uIFkobyx5KXtyZXR1cm4gb1swXT09PXlbMF0mJm9bMV09PT15WzFdJiZvWzJdPT09eVsyXSYmb1szXT09PXlbM10mJm9bNF09PT15WzRdJiZvWzVdPT09eVs1XSYmb1s2XT09PXlbNl0mJm9bN109PT15WzddJiZvWzhdPT09eVs4XSYmb1s5XT09PXlbOV0mJm9bMTBdPT09eVsxMF0mJm9bMTFdPT09eVsxMV0mJm9bMTJdPT09eVsxMl0mJm9bMTNdPT09eVsxM10mJm9bMTRdPT09eVsxNF0mJm9bMTVdPT09eVsxNV19ZnVuY3Rpb24gUShvLHkpe3ZhciBqPW9bMF0sej1vWzFdLCQ9b1syXSxYPW9bM10sdz1vWzRdLGV0PW9bNV0scnQ9b1s2XSxhdD1vWzddLGx0PW9bOF0saXQ9b1s5XSxudD1vWzEwXSxvdD1vWzExXSxodD1vWzEyXSxkdD1vWzEzXSx1dD1vWzE0XSxtdD1vWzE1XSxNdD15WzBdLHZ0PXlbMV0seXQ9eVsyXSxwdD15WzNdLHh0PXlbNF0sQ3Q9eVs1XSxQdD15WzZdLFN0PXlbN10sUnQ9eVs4XSxEdD15WzldLEx0PXlbMTBdLEl0PXlbMTFdLEV0PXlbMTJdLFV0PXlbMTNdLFZ0PXlbMTRdLFl0PXlbMTVdO3JldHVybiBNYXRoLmFicyhqLU10KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaiksTWF0aC5hYnMoTXQpKSYmTWF0aC5hYnMoei12dCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHopLE1hdGguYWJzKHZ0KSkmJk1hdGguYWJzKCQteXQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicygkKSxNYXRoLmFicyh5dCkpJiZNYXRoLmFicyhYLXB0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWCksTWF0aC5hYnMocHQpKSYmTWF0aC5hYnMody14dCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHcpLE1hdGguYWJzKHh0KSkmJk1hdGguYWJzKGV0LUN0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZXQpLE1hdGguYWJzKEN0KSkmJk1hdGguYWJzKHJ0LVB0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocnQpLE1hdGguYWJzKFB0KSkmJk1hdGguYWJzKGF0LVN0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYXQpLE1hdGguYWJzKFN0KSkmJk1hdGguYWJzKGx0LVJ0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobHQpLE1hdGguYWJzKFJ0KSkmJk1hdGguYWJzKGl0LUR0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaXQpLE1hdGguYWJzKER0KSkmJk1hdGguYWJzKG50LUx0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobnQpLE1hdGguYWJzKEx0KSkmJk1hdGguYWJzKG90LUl0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMob3QpLE1hdGguYWJzKEl0KSkmJk1hdGguYWJzKGh0LUV0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaHQpLE1hdGguYWJzKEV0KSkmJk1hdGguYWJzKGR0LVV0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZHQpLE1hdGguYWJzKFV0KSkmJk1hdGguYWJzKHV0LVZ0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModXQpLE1hdGguYWJzKFZ0KSkmJk1hdGguYWJzKG10LVl0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobXQpLE1hdGguYWJzKFl0KSl9dmFyIE49QyxHPWZ0fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiaWRlbnRpdHkiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwic2V0QXhpc0FuZ2xlIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsImdldEF4aXNBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJnZXRBbmdsZSIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJjYWxjdWxhdGVXIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsImV4cCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJsbiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJwb3ciLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwic2xlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJjb25qdWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwiZnJvbU1hdDMiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiZnJvbUV1bGVyIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJmcm9tVmFsdWVzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImNvcHkiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwic2V0IixmdW5jdGlvbigpe3JldHVybiBBfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBKfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwicm90YXRpb25UbyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwic3FsZXJwIixmdW5jdGlvbigpe3JldHVybiBmdH0pLHQuZChlLCJzZXRBeGVzIixmdW5jdGlvbigpe3JldHVybiBCfSk7dmFyIGE9dCgyKSxsPXQoNSksTT10KDgpLFQ9dCg5KTtmdW5jdGlvbiBkKCl7dmFyIEY9bmV3IGEuQVJSQVlfVFlQRSg0KTtyZXR1cm4gYS5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihGWzBdPTAsRlsxXT0wLEZbMl09MCksRlszXT0xLEZ9ZnVuY3Rpb24gdShGKXtyZXR1cm4gRlswXT0wLEZbMV09MCxGWzJdPTAsRlszXT0xLEZ9ZnVuY3Rpb24gYyhGLFksUSl7UT1RKi41O3ZhciBOPU1hdGguc2luKFEpO3JldHVybiBGWzBdPU4qWVswXSxGWzFdPU4qWVsxXSxGWzJdPU4qWVsyXSxGWzNdPU1hdGguY29zKFEpLEZ9ZnVuY3Rpb24gTyhGLFkpe3ZhciBRPU1hdGguYWNvcyhZWzNdKSoyLE49TWF0aC5zaW4oUS8yKTtyZXR1cm4gTj5hLkVQU0lMT04/KEZbMF09WVswXS9OLEZbMV09WVsxXS9OLEZbMl09WVsyXS9OKTooRlswXT0xLEZbMV09MCxGWzJdPTApLFF9ZnVuY3Rpb24gZihGLFkpe3ZhciBRPUooRixZKTtyZXR1cm4gTWF0aC5hY29zKDIqUSpRLTEpfWZ1bmN0aW9uIGcoRixZLFEpe3ZhciBOPVlbMF0sRz1ZWzFdLG89WVsyXSx5PVlbM10saj1RWzBdLHo9UVsxXSwkPVFbMl0sWD1RWzNdO3JldHVybiBGWzBdPU4qWCt5KmorRyokLW8qeixGWzFdPUcqWCt5KnorbypqLU4qJCxGWzJdPW8qWCt5KiQrTip6LUcqaixGWzNdPXkqWC1OKmotRyp6LW8qJCxGfWZ1bmN0aW9uIHYoRixZLFEpe1EqPS41O3ZhciBOPVlbMF0sRz1ZWzFdLG89WVsyXSx5PVlbM10saj1NYXRoLnNpbihRKSx6PU1hdGguY29zKFEpO3JldHVybiBGWzBdPU4qeit5KmosRlsxXT1HKnorbypqLEZbMl09byp6LUcqaixGWzNdPXkqei1OKmosRn1mdW5jdGlvbiBDKEYsWSxRKXtRKj0uNTt2YXIgTj1ZWzBdLEc9WVsxXSxvPVlbMl0seT1ZWzNdLGo9TWF0aC5zaW4oUSksej1NYXRoLmNvcyhRKTtyZXR1cm4gRlswXT1OKnotbypqLEZbMV09Ryp6K3kqaixGWzJdPW8qeitOKmosRlszXT15KnotRypqLEZ9ZnVuY3Rpb24gcChGLFksUSl7USo9LjU7dmFyIE49WVswXSxHPVlbMV0sbz1ZWzJdLHk9WVszXSxqPU1hdGguc2luKFEpLHo9TWF0aC5jb3MoUSk7cmV0dXJuIEZbMF09Tip6K0cqaixGWzFdPUcqei1OKmosRlsyXT1vKnoreSpqLEZbM109eSp6LW8qaixGfWZ1bmN0aW9uIGgoRixZKXt2YXIgUT1ZWzBdLE49WVsxXSxHPVlbMl07cmV0dXJuIEZbMF09USxGWzFdPU4sRlsyXT1HLEZbM109TWF0aC5zcXJ0KE1hdGguYWJzKDEtUSpRLU4qTi1HKkcpKSxGfWZ1bmN0aW9uIG0oRixZKXt2YXIgUT1ZWzBdLE49WVsxXSxHPVlbMl0sbz1ZWzNdLHk9TWF0aC5zcXJ0KFEqUStOKk4rRypHKSxqPU1hdGguZXhwKG8pLHo9eT4wP2oqTWF0aC5zaW4oeSkveTowO3JldHVybiBGWzBdPVEqeixGWzFdPU4qeixGWzJdPUcqeixGWzNdPWoqTWF0aC5jb3MoeSksRn1mdW5jdGlvbiByKEYsWSl7dmFyIFE9WVswXSxOPVlbMV0sRz1ZWzJdLG89WVszXSx5PU1hdGguc3FydChRKlErTipOK0cqRyksaj15PjA/TWF0aC5hdGFuMih5LG8pL3k6MDtyZXR1cm4gRlswXT1RKmosRlsxXT1OKmosRlsyXT1HKmosRlszXT0uNSpNYXRoLmxvZyhRKlErTipOK0cqRytvKm8pLEZ9ZnVuY3Rpb24gaShGLFksUSl7cmV0dXJuIHIoRixZKSxWKEYsRixRKSxtKEYsRiksRn1mdW5jdGlvbiBuKEYsWSxRLE4pe3ZhciBHPVlbMF0sbz1ZWzFdLHk9WVsyXSxqPVlbM10sej1RWzBdLCQ9UVsxXSxYPVFbMl0sdz1RWzNdLGV0LHJ0LGF0LGx0LGl0O3JldHVybiBydD1HKnorbyokK3kqWCtqKncscnQ8MCYmKHJ0PS1ydCx6PS16LCQ9LSQsWD0tWCx3PS13KSwxLXJ0PmEuRVBTSUxPTj8oZXQ9TWF0aC5hY29zKHJ0KSxhdD1NYXRoLnNpbihldCksbHQ9TWF0aC5zaW4oKDEtTikqZXQpL2F0LGl0PU1hdGguc2luKE4qZXQpL2F0KToobHQ9MS1OLGl0PU4pLEZbMF09bHQqRytpdCp6LEZbMV09bHQqbytpdCokLEZbMl09bHQqeStpdCpYLEZbM109bHQqaitpdCp3LEZ9ZnVuY3Rpb24gcyhGKXt2YXIgWT1hLlJBTkRPTSgpLFE9YS5SQU5ET00oKSxOPWEuUkFORE9NKCksRz1NYXRoLnNxcnQoMS1ZKSxvPU1hdGguc3FydChZKTtyZXR1cm4gRlswXT1HKk1hdGguc2luKDIqTWF0aC5QSSpRKSxGWzFdPUcqTWF0aC5jb3MoMipNYXRoLlBJKlEpLEZbMl09bypNYXRoLnNpbigyKk1hdGguUEkqTiksRlszXT1vKk1hdGguY29zKDIqTWF0aC5QSSpOKSxGfWZ1bmN0aW9uIHgoRixZKXt2YXIgUT1ZWzBdLE49WVsxXSxHPVlbMl0sbz1ZWzNdLHk9USpRK04qTitHKkcrbypvLGo9eT8xL3k6MDtyZXR1cm4gRlswXT0tUSpqLEZbMV09LU4qaixGWzJdPS1HKmosRlszXT1vKmosRn1mdW5jdGlvbiBQKEYsWSl7cmV0dXJuIEZbMF09LVlbMF0sRlsxXT0tWVsxXSxGWzJdPS1ZWzJdLEZbM109WVszXSxGfWZ1bmN0aW9uIFIoRixZKXt2YXIgUT1ZWzBdK1lbNF0rWVs4XSxOO2lmKFE+MClOPU1hdGguc3FydChRKzEpLEZbM109LjUqTixOPS41L04sRlswXT0oWVs1XS1ZWzddKSpOLEZbMV09KFlbNl0tWVsyXSkqTixGWzJdPShZWzFdLVlbM10pKk47ZWxzZXt2YXIgRz0wO1lbNF0+WVswXSYmKEc9MSksWVs4XT5ZW0cqMytHXSYmKEc9Mik7dmFyIG89KEcrMSklMyx5PShHKzIpJTM7Tj1NYXRoLnNxcnQoWVtHKjMrR10tWVtvKjMrb10tWVt5KjMreV0rMSksRltHXT0uNSpOLE49LjUvTixGWzNdPShZW28qMyt5XS1ZW3kqMytvXSkqTixGW29dPShZW28qMytHXStZW0cqMytvXSkqTixGW3ldPShZW3kqMytHXStZW0cqMyt5XSkqTn1yZXR1cm4gRn1mdW5jdGlvbiBiKEYsWSxRLE4pe3ZhciBHPS41Kk1hdGguUEkvMTgwO1kqPUcsUSo9RyxOKj1HO3ZhciBvPU1hdGguc2luKFkpLHk9TWF0aC5jb3MoWSksaj1NYXRoLnNpbihRKSx6PU1hdGguY29zKFEpLCQ9TWF0aC5zaW4oTiksWD1NYXRoLmNvcyhOKTtyZXR1cm4gRlswXT1vKnoqWC15KmoqJCxGWzFdPXkqaipYK28qeiokLEZbMl09eSp6KiQtbypqKlgsRlszXT15KnoqWCtvKmoqJCxGfWZ1bmN0aW9uIEUoRil7cmV0dXJuInF1YXQoIitGWzBdKyIsICIrRlsxXSsiLCAiK0ZbMl0rIiwgIitGWzNdKyIpIn12YXIgRD1ULmNsb25lLEk9VC5mcm9tVmFsdWVzLFM9VC5jb3B5LEE9VC5zZXQsVT1ULmFkZCxLPWcsVj1ULnNjYWxlLEo9VC5kb3QscT1ULmxlcnAsVz1ULmxlbmd0aCxIPVcsWj1ULnNxdWFyZWRMZW5ndGgsdHQ9WixfPVQubm9ybWFsaXplLHN0PVQuZXhhY3RFcXVhbHMsaz1ULmVxdWFscyxjdD1mdW5jdGlvbigpe3ZhciBGPU0uY3JlYXRlKCksWT1NLmZyb21WYWx1ZXMoMSwwLDApLFE9TS5mcm9tVmFsdWVzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24oTixHLG8pe3ZhciB5PU0uZG90KEcsbyk7cmV0dXJuIHk8LS45OTk5OTk/KE0uY3Jvc3MoRixZLEcpLE0ubGVuKEYpPDFlLTYmJk0uY3Jvc3MoRixRLEcpLE0ubm9ybWFsaXplKEYsRiksYyhOLEYsTWF0aC5QSSksTik6eT4uOTk5OTk5PyhOWzBdPTAsTlsxXT0wLE5bMl09MCxOWzNdPTEsTik6KE0uY3Jvc3MoRixHLG8pLE5bMF09RlswXSxOWzFdPUZbMV0sTlsyXT1GWzJdLE5bM109MSt5LF8oTixOKSl9fSgpLGZ0PWZ1bmN0aW9uKCl7dmFyIEY9ZCgpLFk9ZCgpO3JldHVybiBmdW5jdGlvbihRLE4sRyxvLHksail7cmV0dXJuIG4oRixOLHksaiksbihZLEcsbyxqKSxuKFEsRixZLDIqaiooMS1qKSksUX19KCksQj1mdW5jdGlvbigpe3ZhciBGPWwuY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKFksUSxOLEcpe3JldHVybiBGWzBdPU5bMF0sRlszXT1OWzFdLEZbNl09TlsyXSxGWzFdPUdbMF0sRls0XT1HWzFdLEZbN109R1syXSxGWzJdPS1RWzBdLEZbNV09LVFbMV0sRls4XT0tUVsyXSxfKFksUihZLEYpKX19KCl9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBofSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gc30pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHh9KSx0LmQoZSwic3F1YXJlZExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHQuZChlLCJuZWdhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwiaW52ZXJzZSIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBEfSksdC5kKGUsImNyb3NzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIFN9KSx0LmQoZSwiaGVybWl0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJiZXppZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwicmFuZG9tIixmdW5jdGlvbigpe3JldHVybiBLfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIFZ9KSx0LmQoZSwidHJhbnNmb3JtTWF0MyIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHQuZChlLCJ0cmFuc2Zvcm1RdWF0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsInJvdGF0ZVgiLGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSx0LmQoZSwicm90YXRlWSIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJyb3RhdGVaIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJ6ZXJvIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4gc3R9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsIm11bCIsZnVuY3Rpb24oKXtyZXR1cm4gQn0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIEZ9KSx0LmQoZSwiZGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gWX0pLHQuZChlLCJzcXJEaXN0IixmdW5jdGlvbigpe3JldHVybiBRfSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIEd9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pO3ZhciBhPXQoMik7ZnVuY3Rpb24gbCgpe3ZhciB5PW5ldyBhLkFSUkFZX1RZUEUoMyk7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoeVswXT0wLHlbMV09MCx5WzJdPTApLHl9ZnVuY3Rpb24gTSh5KXt2YXIgaj1uZXcgYS5BUlJBWV9UWVBFKDMpO3JldHVybiBqWzBdPXlbMF0salsxXT15WzFdLGpbMl09eVsyXSxqfWZ1bmN0aW9uIFQoeSl7dmFyIGo9eVswXSx6PXlbMV0sJD15WzJdO3JldHVybiBNYXRoLmh5cG90KGoseiwkKX1mdW5jdGlvbiBkKHksaix6KXt2YXIgJD1uZXcgYS5BUlJBWV9UWVBFKDMpO3JldHVybiAkWzBdPXksJFsxXT1qLCRbMl09eiwkfWZ1bmN0aW9uIHUoeSxqKXtyZXR1cm4geVswXT1qWzBdLHlbMV09alsxXSx5WzJdPWpbMl0seX1mdW5jdGlvbiBjKHksaix6LCQpe3JldHVybiB5WzBdPWoseVsxXT16LHlbMl09JCx5fWZ1bmN0aW9uIE8oeSxqLHope3JldHVybiB5WzBdPWpbMF0relswXSx5WzFdPWpbMV0relsxXSx5WzJdPWpbMl0relsyXSx5fWZ1bmN0aW9uIGYoeSxqLHope3JldHVybiB5WzBdPWpbMF0telswXSx5WzFdPWpbMV0telsxXSx5WzJdPWpbMl0telsyXSx5fWZ1bmN0aW9uIGcoeSxqLHope3JldHVybiB5WzBdPWpbMF0qelswXSx5WzFdPWpbMV0qelsxXSx5WzJdPWpbMl0qelsyXSx5fWZ1bmN0aW9uIHYoeSxqLHope3JldHVybiB5WzBdPWpbMF0velswXSx5WzFdPWpbMV0velsxXSx5WzJdPWpbMl0velsyXSx5fWZ1bmN0aW9uIEMoeSxqKXtyZXR1cm4geVswXT1NYXRoLmNlaWwoalswXSkseVsxXT1NYXRoLmNlaWwoalsxXSkseVsyXT1NYXRoLmNlaWwoalsyXSkseX1mdW5jdGlvbiBwKHksail7cmV0dXJuIHlbMF09TWF0aC5mbG9vcihqWzBdKSx5WzFdPU1hdGguZmxvb3IoalsxXSkseVsyXT1NYXRoLmZsb29yKGpbMl0pLHl9ZnVuY3Rpb24gaCh5LGoseil7cmV0dXJuIHlbMF09TWF0aC5taW4oalswXSx6WzBdKSx5WzFdPU1hdGgubWluKGpbMV0selsxXSkseVsyXT1NYXRoLm1pbihqWzJdLHpbMl0pLHl9ZnVuY3Rpb24gbSh5LGoseil7cmV0dXJuIHlbMF09TWF0aC5tYXgoalswXSx6WzBdKSx5WzFdPU1hdGgubWF4KGpbMV0selsxXSkseVsyXT1NYXRoLm1heChqWzJdLHpbMl0pLHl9ZnVuY3Rpb24gcih5LGope3JldHVybiB5WzBdPU1hdGgucm91bmQoalswXSkseVsxXT1NYXRoLnJvdW5kKGpbMV0pLHlbMl09TWF0aC5yb3VuZChqWzJdKSx5fWZ1bmN0aW9uIGkoeSxqLHope3JldHVybiB5WzBdPWpbMF0qeix5WzFdPWpbMV0qeix5WzJdPWpbMl0qeix5fWZ1bmN0aW9uIG4oeSxqLHosJCl7cmV0dXJuIHlbMF09alswXSt6WzBdKiQseVsxXT1qWzFdK3pbMV0qJCx5WzJdPWpbMl0relsyXSokLHl9ZnVuY3Rpb24gcyh5LGope3ZhciB6PWpbMF0teVswXSwkPWpbMV0teVsxXSxYPWpbMl0teVsyXTtyZXR1cm4gTWF0aC5oeXBvdCh6LCQsWCl9ZnVuY3Rpb24geCh5LGope3ZhciB6PWpbMF0teVswXSwkPWpbMV0teVsxXSxYPWpbMl0teVsyXTtyZXR1cm4geip6KyQqJCtYKlh9ZnVuY3Rpb24gUCh5KXt2YXIgaj15WzBdLHo9eVsxXSwkPXlbMl07cmV0dXJuIGoqait6KnorJCokfWZ1bmN0aW9uIFIoeSxqKXtyZXR1cm4geVswXT0talswXSx5WzFdPS1qWzFdLHlbMl09LWpbMl0seX1mdW5jdGlvbiBiKHksail7cmV0dXJuIHlbMF09MS9qWzBdLHlbMV09MS9qWzFdLHlbMl09MS9qWzJdLHl9ZnVuY3Rpb24gRSh5LGope3ZhciB6PWpbMF0sJD1qWzFdLFg9alsyXSx3PXoqeiskKiQrWCpYO3JldHVybiB3PjAmJih3PTEvTWF0aC5zcXJ0KHcpKSx5WzBdPWpbMF0qdyx5WzFdPWpbMV0qdyx5WzJdPWpbMl0qdyx5fWZ1bmN0aW9uIEQoeSxqKXtyZXR1cm4geVswXSpqWzBdK3lbMV0qalsxXSt5WzJdKmpbMl19ZnVuY3Rpb24gSSh5LGoseil7dmFyICQ9alswXSxYPWpbMV0sdz1qWzJdLGV0PXpbMF0scnQ9elsxXSxhdD16WzJdO3JldHVybiB5WzBdPVgqYXQtdypydCx5WzFdPXcqZXQtJCphdCx5WzJdPSQqcnQtWCpldCx5fWZ1bmN0aW9uIFMoeSxqLHosJCl7dmFyIFg9alswXSx3PWpbMV0sZXQ9alsyXTtyZXR1cm4geVswXT1YKyQqKHpbMF0tWCkseVsxXT13KyQqKHpbMV0tdykseVsyXT1ldCskKih6WzJdLWV0KSx5fWZ1bmN0aW9uIEEoeSxqLHosJCxYLHcpe3ZhciBldD13KncscnQ9ZXQqKDIqdy0zKSsxLGF0PWV0Kih3LTIpK3csbHQ9ZXQqKHctMSksaXQ9ZXQqKDMtMip3KTtyZXR1cm4geVswXT1qWzBdKnJ0K3pbMF0qYXQrJFswXSpsdCtYWzBdKml0LHlbMV09alsxXSpydCt6WzFdKmF0KyRbMV0qbHQrWFsxXSppdCx5WzJdPWpbMl0qcnQrelsyXSphdCskWzJdKmx0K1hbMl0qaXQseX1mdW5jdGlvbiBVKHksaix6LCQsWCx3KXt2YXIgZXQ9MS13LHJ0PWV0KmV0LGF0PXcqdyxsdD1ydCpldCxpdD0zKncqcnQsbnQ9MyphdCpldCxvdD1hdCp3O3JldHVybiB5WzBdPWpbMF0qbHQrelswXSppdCskWzBdKm50K1hbMF0qb3QseVsxXT1qWzFdKmx0K3pbMV0qaXQrJFsxXSpudCtYWzFdKm90LHlbMl09alsyXSpsdCt6WzJdKml0KyRbMl0qbnQrWFsyXSpvdCx5fWZ1bmN0aW9uIEsoeSxqKXtqPWp8fDE7dmFyIHo9YS5SQU5ET00oKSoyKk1hdGguUEksJD1hLlJBTkRPTSgpKjItMSxYPU1hdGguc3FydCgxLSQqJCkqajtyZXR1cm4geVswXT1NYXRoLmNvcyh6KSpYLHlbMV09TWF0aC5zaW4oeikqWCx5WzJdPSQqaix5fWZ1bmN0aW9uIFYoeSxqLHope3ZhciAkPWpbMF0sWD1qWzFdLHc9alsyXSxldD16WzNdKiQrels3XSpYK3pbMTFdKncrelsxNV07cmV0dXJuIGV0PWV0fHwxLHlbMF09KHpbMF0qJCt6WzRdKlgrels4XSp3K3pbMTJdKS9ldCx5WzFdPSh6WzFdKiQrels1XSpYK3pbOV0qdyt6WzEzXSkvZXQseVsyXT0oelsyXSokK3pbNl0qWCt6WzEwXSp3K3pbMTRdKS9ldCx5fWZ1bmN0aW9uIEooeSxqLHope3ZhciAkPWpbMF0sWD1qWzFdLHc9alsyXTtyZXR1cm4geVswXT0kKnpbMF0rWCp6WzNdK3cqels2XSx5WzFdPSQqelsxXStYKnpbNF0rdyp6WzddLHlbMl09JCp6WzJdK1gqels1XSt3KnpbOF0seX1mdW5jdGlvbiBxKHksaix6KXt2YXIgJD16WzBdLFg9elsxXSx3PXpbMl0sZXQ9elszXSxydD1qWzBdLGF0PWpbMV0sbHQ9alsyXSxpdD1YKmx0LXcqYXQsbnQ9dypydC0kKmx0LG90PSQqYXQtWCpydCxodD1YKm90LXcqbnQsZHQ9dyppdC0kKm90LHV0PSQqbnQtWCppdCxtdD1ldCoyO3JldHVybiBpdCo9bXQsbnQqPW10LG90Kj1tdCxodCo9MixkdCo9Mix1dCo9Mix5WzBdPXJ0K2l0K2h0LHlbMV09YXQrbnQrZHQseVsyXT1sdCtvdCt1dCx5fWZ1bmN0aW9uIFcoeSxqLHosJCl7dmFyIFg9W10sdz1bXTtyZXR1cm4gWFswXT1qWzBdLXpbMF0sWFsxXT1qWzFdLXpbMV0sWFsyXT1qWzJdLXpbMl0sd1swXT1YWzBdLHdbMV09WFsxXSpNYXRoLmNvcygkKS1YWzJdKk1hdGguc2luKCQpLHdbMl09WFsxXSpNYXRoLnNpbigkKStYWzJdKk1hdGguY29zKCQpLHlbMF09d1swXSt6WzBdLHlbMV09d1sxXSt6WzFdLHlbMl09d1syXSt6WzJdLHl9ZnVuY3Rpb24gSCh5LGoseiwkKXt2YXIgWD1bXSx3PVtdO3JldHVybiBYWzBdPWpbMF0telswXSxYWzFdPWpbMV0telsxXSxYWzJdPWpbMl0telsyXSx3WzBdPVhbMl0qTWF0aC5zaW4oJCkrWFswXSpNYXRoLmNvcygkKSx3WzFdPVhbMV0sd1syXT1YWzJdKk1hdGguY29zKCQpLVhbMF0qTWF0aC5zaW4oJCkseVswXT13WzBdK3pbMF0seVsxXT13WzFdK3pbMV0seVsyXT13WzJdK3pbMl0seX1mdW5jdGlvbiBaKHksaix6LCQpe3ZhciBYPVtdLHc9W107cmV0dXJuIFhbMF09alswXS16WzBdLFhbMV09alsxXS16WzFdLFhbMl09alsyXS16WzJdLHdbMF09WFswXSpNYXRoLmNvcygkKS1YWzFdKk1hdGguc2luKCQpLHdbMV09WFswXSpNYXRoLnNpbigkKStYWzFdKk1hdGguY29zKCQpLHdbMl09WFsyXSx5WzBdPXdbMF0relswXSx5WzFdPXdbMV0relsxXSx5WzJdPXdbMl0relsyXSx5fWZ1bmN0aW9uIHR0KHksail7dmFyIHo9eVswXSwkPXlbMV0sWD15WzJdLHc9alswXSxldD1qWzFdLHJ0PWpbMl0sYXQ9TWF0aC5zcXJ0KHoqeiskKiQrWCpYKSxsdD1NYXRoLnNxcnQodyp3K2V0KmV0K3J0KnJ0KSxpdD1hdCpsdCxudD1pdCYmRCh5LGopL2l0O3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgobnQsLTEpLDEpKX1mdW5jdGlvbiBfKHkpe3JldHVybiB5WzBdPTAseVsxXT0wLHlbMl09MCx5fWZ1bmN0aW9uIHN0KHkpe3JldHVybiJ2ZWMzKCIreVswXSsiLCAiK3lbMV0rIiwgIit5WzJdKyIpIn1mdW5jdGlvbiBrKHksail7cmV0dXJuIHlbMF09PT1qWzBdJiZ5WzFdPT09alsxXSYmeVsyXT09PWpbMl19ZnVuY3Rpb24gY3QoeSxqKXt2YXIgej15WzBdLCQ9eVsxXSxYPXlbMl0sdz1qWzBdLGV0PWpbMV0scnQ9alsyXTtyZXR1cm4gTWF0aC5hYnMoei13KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeiksTWF0aC5hYnModykpJiZNYXRoLmFicygkLWV0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoJCksTWF0aC5hYnMoZXQpKSYmTWF0aC5hYnMoWC1ydCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFgpLE1hdGguYWJzKHJ0KSl9dmFyIGZ0PWYsQj1nLEY9dixZPXMsUT14LE49VCxHPVAsbz1mdW5jdGlvbigpe3ZhciB5PWwoKTtyZXR1cm4gZnVuY3Rpb24oaix6LCQsWCx3LGV0KXt2YXIgcnQsYXQ7Zm9yKHp8fCh6PTMpLCR8fCgkPTApLFg/YXQ9TWF0aC5taW4oWCp6KyQsai5sZW5ndGgpOmF0PWoubGVuZ3RoLHJ0PSQ7cnQ8YXQ7cnQrPXopeVswXT1qW3J0XSx5WzFdPWpbcnQrMV0seVsyXT1qW3J0KzJdLHcoeSx5LGV0KSxqW3J0XT15WzBdLGpbcnQrMV09eVsxXSxqW3J0KzJdPXlbMl07cmV0dXJuIGp9fSgpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0LmQoZSwiY2xvbmUiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwiZnJvbVZhbHVlcyIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJhZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic3VidHJhY3QiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwibXVsdGlwbHkiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQoZSwiZGl2aWRlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImNlaWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQoZSwiZmxvb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwibWluIixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsIm1heCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJyb3VuZCIsZnVuY3Rpb24oKXtyZXR1cm4gbX0pLHQuZChlLCJzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pLHQuZChlLCJzY2FsZUFuZEFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJkaXN0YW5jZSIsZnVuY3Rpb24oKXtyZXR1cm4gbn0pLHQuZChlLCJzcXVhcmVkRGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSx0LmQoZSwibGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiB4fSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQoZSwibmVnYXRlIixmdW5jdGlvbigpe3JldHVybiBSfSksdC5kKGUsImludmVyc2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSx0LmQoZSwibm9ybWFsaXplIixmdW5jdGlvbigpe3JldHVybiBFfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJjcm9zcyIsZnVuY3Rpb24oKXtyZXR1cm4gSX0pLHQuZChlLCJsZXJwIixmdW5jdGlvbigpe3JldHVybiBTfSksdC5kKGUsInJhbmRvbSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQ0IixmdW5jdGlvbigpe3JldHVybiBVfSksdC5kKGUsInRyYW5zZm9ybVF1YXQiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwiemVybyIsZnVuY3Rpb24oKXtyZXR1cm4gVn0pLHQuZChlLCJzdHIiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiZXhhY3RFcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIHF9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInN1YiIsZnVuY3Rpb24oKXtyZXR1cm4gSH0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSx0LmQoZSwiZGl2IixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJkaXN0IixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKGUsInNxckRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsImxlbiIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIGN0fSksdC5kKGUsImZvckVhY2giLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSk7dmFyIGE9dCgyKTtmdW5jdGlvbiBsKCl7dmFyIEI9bmV3IGEuQVJSQVlfVFlQRSg0KTtyZXR1cm4gYS5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTApLEJ9ZnVuY3Rpb24gTShCKXt2YXIgRj1uZXcgYS5BUlJBWV9UWVBFKDQpO3JldHVybiBGWzBdPUJbMF0sRlsxXT1CWzFdLEZbMl09QlsyXSxGWzNdPUJbM10sRn1mdW5jdGlvbiBUKEIsRixZLFEpe3ZhciBOPW5ldyBhLkFSUkFZX1RZUEUoNCk7cmV0dXJuIE5bMF09QixOWzFdPUYsTlsyXT1ZLE5bM109USxOfWZ1bmN0aW9uIGQoQixGKXtyZXR1cm4gQlswXT1GWzBdLEJbMV09RlsxXSxCWzJdPUZbMl0sQlszXT1GWzNdLEJ9ZnVuY3Rpb24gdShCLEYsWSxRLE4pe3JldHVybiBCWzBdPUYsQlsxXT1ZLEJbMl09USxCWzNdPU4sQn1mdW5jdGlvbiBjKEIsRixZKXtyZXR1cm4gQlswXT1GWzBdK1lbMF0sQlsxXT1GWzFdK1lbMV0sQlsyXT1GWzJdK1lbMl0sQlszXT1GWzNdK1lbM10sQn1mdW5jdGlvbiBPKEIsRixZKXtyZXR1cm4gQlswXT1GWzBdLVlbMF0sQlsxXT1GWzFdLVlbMV0sQlsyXT1GWzJdLVlbMl0sQlszXT1GWzNdLVlbM10sQn1mdW5jdGlvbiBmKEIsRixZKXtyZXR1cm4gQlswXT1GWzBdKllbMF0sQlsxXT1GWzFdKllbMV0sQlsyXT1GWzJdKllbMl0sQlszXT1GWzNdKllbM10sQn1mdW5jdGlvbiBnKEIsRixZKXtyZXR1cm4gQlswXT1GWzBdL1lbMF0sQlsxXT1GWzFdL1lbMV0sQlsyXT1GWzJdL1lbMl0sQlszXT1GWzNdL1lbM10sQn1mdW5jdGlvbiB2KEIsRil7cmV0dXJuIEJbMF09TWF0aC5jZWlsKEZbMF0pLEJbMV09TWF0aC5jZWlsKEZbMV0pLEJbMl09TWF0aC5jZWlsKEZbMl0pLEJbM109TWF0aC5jZWlsKEZbM10pLEJ9ZnVuY3Rpb24gQyhCLEYpe3JldHVybiBCWzBdPU1hdGguZmxvb3IoRlswXSksQlsxXT1NYXRoLmZsb29yKEZbMV0pLEJbMl09TWF0aC5mbG9vcihGWzJdKSxCWzNdPU1hdGguZmxvb3IoRlszXSksQn1mdW5jdGlvbiBwKEIsRixZKXtyZXR1cm4gQlswXT1NYXRoLm1pbihGWzBdLFlbMF0pLEJbMV09TWF0aC5taW4oRlsxXSxZWzFdKSxCWzJdPU1hdGgubWluKEZbMl0sWVsyXSksQlszXT1NYXRoLm1pbihGWzNdLFlbM10pLEJ9ZnVuY3Rpb24gaChCLEYsWSl7cmV0dXJuIEJbMF09TWF0aC5tYXgoRlswXSxZWzBdKSxCWzFdPU1hdGgubWF4KEZbMV0sWVsxXSksQlsyXT1NYXRoLm1heChGWzJdLFlbMl0pLEJbM109TWF0aC5tYXgoRlszXSxZWzNdKSxCfWZ1bmN0aW9uIG0oQixGKXtyZXR1cm4gQlswXT1NYXRoLnJvdW5kKEZbMF0pLEJbMV09TWF0aC5yb3VuZChGWzFdKSxCWzJdPU1hdGgucm91bmQoRlsyXSksQlszXT1NYXRoLnJvdW5kKEZbM10pLEJ9ZnVuY3Rpb24gcihCLEYsWSl7cmV0dXJuIEJbMF09RlswXSpZLEJbMV09RlsxXSpZLEJbMl09RlsyXSpZLEJbM109RlszXSpZLEJ9ZnVuY3Rpb24gaShCLEYsWSxRKXtyZXR1cm4gQlswXT1GWzBdK1lbMF0qUSxCWzFdPUZbMV0rWVsxXSpRLEJbMl09RlsyXStZWzJdKlEsQlszXT1GWzNdK1lbM10qUSxCfWZ1bmN0aW9uIG4oQixGKXt2YXIgWT1GWzBdLUJbMF0sUT1GWzFdLUJbMV0sTj1GWzJdLUJbMl0sRz1GWzNdLUJbM107cmV0dXJuIE1hdGguaHlwb3QoWSxRLE4sRyl9ZnVuY3Rpb24gcyhCLEYpe3ZhciBZPUZbMF0tQlswXSxRPUZbMV0tQlsxXSxOPUZbMl0tQlsyXSxHPUZbM10tQlszXTtyZXR1cm4gWSpZK1EqUStOKk4rRypHfWZ1bmN0aW9uIHgoQil7dmFyIEY9QlswXSxZPUJbMV0sUT1CWzJdLE49QlszXTtyZXR1cm4gTWF0aC5oeXBvdChGLFksUSxOKX1mdW5jdGlvbiBQKEIpe3ZhciBGPUJbMF0sWT1CWzFdLFE9QlsyXSxOPUJbM107cmV0dXJuIEYqRitZKlkrUSpRK04qTn1mdW5jdGlvbiBSKEIsRil7cmV0dXJuIEJbMF09LUZbMF0sQlsxXT0tRlsxXSxCWzJdPS1GWzJdLEJbM109LUZbM10sQn1mdW5jdGlvbiBiKEIsRil7cmV0dXJuIEJbMF09MS9GWzBdLEJbMV09MS9GWzFdLEJbMl09MS9GWzJdLEJbM109MS9GWzNdLEJ9ZnVuY3Rpb24gRShCLEYpe3ZhciBZPUZbMF0sUT1GWzFdLE49RlsyXSxHPUZbM10sbz1ZKlkrUSpRK04qTitHKkc7cmV0dXJuIG8+MCYmKG89MS9NYXRoLnNxcnQobykpLEJbMF09WSpvLEJbMV09USpvLEJbMl09TipvLEJbM109RypvLEJ9ZnVuY3Rpb24gRChCLEYpe3JldHVybiBCWzBdKkZbMF0rQlsxXSpGWzFdK0JbMl0qRlsyXStCWzNdKkZbM119ZnVuY3Rpb24gSShCLEYsWSxRKXt2YXIgTj1ZWzBdKlFbMV0tWVsxXSpRWzBdLEc9WVswXSpRWzJdLVlbMl0qUVswXSxvPVlbMF0qUVszXS1ZWzNdKlFbMF0seT1ZWzFdKlFbMl0tWVsyXSpRWzFdLGo9WVsxXSpRWzNdLVlbM10qUVsxXSx6PVlbMl0qUVszXS1ZWzNdKlFbMl0sJD1GWzBdLFg9RlsxXSx3PUZbMl0sZXQ9RlszXTtyZXR1cm4gQlswXT1YKnotdypqK2V0KnksQlsxXT0tKCQqeikrdypvLWV0KkcsQlsyXT0kKmotWCpvK2V0Kk4sQlszXT0tKCQqeSkrWCpHLXcqTixCfWZ1bmN0aW9uIFMoQixGLFksUSl7dmFyIE49RlswXSxHPUZbMV0sbz1GWzJdLHk9RlszXTtyZXR1cm4gQlswXT1OK1EqKFlbMF0tTiksQlsxXT1HK1EqKFlbMV0tRyksQlsyXT1vK1EqKFlbMl0tbyksQlszXT15K1EqKFlbM10teSksQn1mdW5jdGlvbiBBKEIsRil7Rj1GfHwxO3ZhciBZLFEsTixHLG8seTtkbyBZPWEuUkFORE9NKCkqMi0xLFE9YS5SQU5ET00oKSoyLTEsbz1ZKlkrUSpRO3doaWxlKG8+PTEpO2RvIE49YS5SQU5ET00oKSoyLTEsRz1hLlJBTkRPTSgpKjItMSx5PU4qTitHKkc7d2hpbGUoeT49MSk7dmFyIGo9TWF0aC5zcXJ0KCgxLW8pL3kpO3JldHVybiBCWzBdPUYqWSxCWzFdPUYqUSxCWzJdPUYqTipqLEJbM109RipHKmosQn1mdW5jdGlvbiBVKEIsRixZKXt2YXIgUT1GWzBdLE49RlsxXSxHPUZbMl0sbz1GWzNdO3JldHVybiBCWzBdPVlbMF0qUStZWzRdKk4rWVs4XSpHK1lbMTJdKm8sQlsxXT1ZWzFdKlErWVs1XSpOK1lbOV0qRytZWzEzXSpvLEJbMl09WVsyXSpRK1lbNl0qTitZWzEwXSpHK1lbMTRdKm8sQlszXT1ZWzNdKlErWVs3XSpOK1lbMTFdKkcrWVsxNV0qbyxCfWZ1bmN0aW9uIEsoQixGLFkpe3ZhciBRPUZbMF0sTj1GWzFdLEc9RlsyXSxvPVlbMF0seT1ZWzFdLGo9WVsyXSx6PVlbM10sJD16KlEreSpHLWoqTixYPXoqTitqKlEtbypHLHc9eipHK28qTi15KlEsZXQ9LW8qUS15Kk4taipHO3JldHVybiBCWzBdPSQqeitldCotbytYKi1qLXcqLXksQlsxXT1YKnorZXQqLXkrdyotby0kKi1qLEJbMl09dyp6K2V0Ki1qKyQqLXktWCotbyxCWzNdPUZbM10sQn1mdW5jdGlvbiBWKEIpe3JldHVybiBCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTAsQn1mdW5jdGlvbiBKKEIpe3JldHVybiJ2ZWM0KCIrQlswXSsiLCAiK0JbMV0rIiwgIitCWzJdKyIsICIrQlszXSsiKSJ9ZnVuY3Rpb24gcShCLEYpe3JldHVybiBCWzBdPT09RlswXSYmQlsxXT09PUZbMV0mJkJbMl09PT1GWzJdJiZCWzNdPT09RlszXX1mdW5jdGlvbiBXKEIsRil7dmFyIFk9QlswXSxRPUJbMV0sTj1CWzJdLEc9QlszXSxvPUZbMF0seT1GWzFdLGo9RlsyXSx6PUZbM107cmV0dXJuIE1hdGguYWJzKFktbyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKFkpLE1hdGguYWJzKG8pKSYmTWF0aC5hYnMoUS15KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoUSksTWF0aC5hYnMoeSkpJiZNYXRoLmFicyhOLWopPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhOKSxNYXRoLmFicyhqKSkmJk1hdGguYWJzKEcteik8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEcpLE1hdGguYWJzKHopKX12YXIgSD1PLFo9Zix0dD1nLF89bixzdD1zLGs9eCxjdD1QLGZ0PWZ1bmN0aW9uKCl7dmFyIEI9bCgpO3JldHVybiBmdW5jdGlvbihGLFksUSxOLEcsbyl7dmFyIHksajtmb3IoWXx8KFk9NCksUXx8KFE9MCksTj9qPU1hdGgubWluKE4qWStRLEYubGVuZ3RoKTpqPUYubGVuZ3RoLHk9UTt5PGo7eSs9WSlCWzBdPUZbeV0sQlsxXT1GW3krMV0sQlsyXT1GW3krMl0sQlszXT1GW3krM10sRyhCLEIsbyksRlt5XT1CWzBdLEZbeSsxXT1CWzFdLEZbeSsyXT1CWzJdLEZbeSszXT1CWzNdO3JldHVybiBGfX0oKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24iLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiZnJvbVRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImZyb21Sb3RhdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJmcm9tTWF0NCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsImlkZW50aXR5IixmdW5jdGlvbigpe3JldHVybiBwfSksdC5kKGUsInNldCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pLHQuZChlLCJnZXRSZWFsIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImdldER1YWwiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwic2V0UmVhbCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pLHQuZChlLCJzZXREdWFsIixmdW5jdGlvbigpe3JldHVybiBufSksdC5kKGUsImdldFRyYW5zbGF0aW9uIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsInRyYW5zbGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJyb3RhdGVYIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsInJvdGF0ZVkiLGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSx0LmQoZSwicm90YXRlWiIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pLHQuZChlLCJyb3RhdGVCeVF1YXRBcHBlbmQiLGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSx0LmQoZSwicm90YXRlQnlRdWF0UHJlcGVuZCIsZnVuY3Rpb24oKXtyZXR1cm4gRH0pLHQuZChlLCJyb3RhdGVBcm91bmRBeGlzIixmdW5jdGlvbigpe3JldHVybiBJfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJtdWx0aXBseSIsZnVuY3Rpb24oKXtyZXR1cm4gQX0pLHQuZChlLCJtdWwiLGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSx0LmQoZSwiZG90IixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsImxlcnAiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwiaW52ZXJ0IixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImNvbmp1Z2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLHQuZChlLCJsZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsInNxdWFyZWRMZW5ndGgiLGZ1bmN0aW9uKCl7cmV0dXJuIHR0fSksdC5kKGUsInNxckxlbiIsZnVuY3Rpb24oKXtyZXR1cm4gX30pLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSksdC5kKGUsInN0ciIsZnVuY3Rpb24oKXtyZXR1cm4ga30pLHQuZChlLCJleGFjdEVxdWFscyIsZnVuY3Rpb24oKXtyZXR1cm4gY3R9KSx0LmQoZSwiZXF1YWxzIixmdW5jdGlvbigpe3JldHVybiBmdH0pO3ZhciBhPXQoMiksbD10KDcpLE09dCg2KTtmdW5jdGlvbiBUKCl7dmFyIEI9bmV3IGEuQVJSQVlfVFlQRSg4KTtyZXR1cm4gYS5BUlJBWV9UWVBFIT1GbG9hdDMyQXJyYXkmJihCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzRdPTAsQls1XT0wLEJbNl09MCxCWzddPTApLEJbM109MSxCfWZ1bmN0aW9uIGQoQil7dmFyIEY9bmV3IGEuQVJSQVlfVFlQRSg4KTtyZXR1cm4gRlswXT1CWzBdLEZbMV09QlsxXSxGWzJdPUJbMl0sRlszXT1CWzNdLEZbNF09Qls0XSxGWzVdPUJbNV0sRls2XT1CWzZdLEZbN109Qls3XSxGfWZ1bmN0aW9uIHUoQixGLFksUSxOLEcsbyx5KXt2YXIgaj1uZXcgYS5BUlJBWV9UWVBFKDgpO3JldHVybiBqWzBdPUIsalsxXT1GLGpbMl09WSxqWzNdPVEsals0XT1OLGpbNV09RyxqWzZdPW8sals3XT15LGp9ZnVuY3Rpb24gYyhCLEYsWSxRLE4sRyxvKXt2YXIgeT1uZXcgYS5BUlJBWV9UWVBFKDgpO3lbMF09Qix5WzFdPUYseVsyXT1ZLHlbM109UTt2YXIgaj1OKi41LHo9RyouNSwkPW8qLjU7cmV0dXJuIHlbNF09aipRK3oqWS0kKkYseVs1XT16KlErJCpCLWoqWSx5WzZdPSQqUStqKkYteipCLHlbN109LWoqQi16KkYtJCpZLHl9ZnVuY3Rpb24gTyhCLEYsWSl7dmFyIFE9WVswXSouNSxOPVlbMV0qLjUsRz1ZWzJdKi41LG89RlswXSx5PUZbMV0saj1GWzJdLHo9RlszXTtyZXR1cm4gQlswXT1vLEJbMV09eSxCWzJdPWosQlszXT16LEJbNF09USp6K04qai1HKnksQls1XT1OKnorRypvLVEqaixCWzZdPUcqeitRKnktTipvLEJbN109LVEqby1OKnktRypqLEJ9ZnVuY3Rpb24gZihCLEYpe3JldHVybiBCWzBdPTAsQlsxXT0wLEJbMl09MCxCWzNdPTEsQls0XT1GWzBdKi41LEJbNV09RlsxXSouNSxCWzZdPUZbMl0qLjUsQls3XT0wLEJ9ZnVuY3Rpb24gZyhCLEYpe3JldHVybiBCWzBdPUZbMF0sQlsxXT1GWzFdLEJbMl09RlsyXSxCWzNdPUZbM10sQls0XT0wLEJbNV09MCxCWzZdPTAsQls3XT0wLEJ9ZnVuY3Rpb24gdihCLEYpe3ZhciBZPWwuY3JlYXRlKCk7TS5nZXRSb3RhdGlvbihZLEYpO3ZhciBRPW5ldyBhLkFSUkFZX1RZUEUoMyk7cmV0dXJuIE0uZ2V0VHJhbnNsYXRpb24oUSxGKSxPKEIsWSxRKSxCfWZ1bmN0aW9uIEMoQixGKXtyZXR1cm4gQlswXT1GWzBdLEJbMV09RlsxXSxCWzJdPUZbMl0sQlszXT1GWzNdLEJbNF09Rls0XSxCWzVdPUZbNV0sQls2XT1GWzZdLEJbN109Rls3XSxCfWZ1bmN0aW9uIHAoQil7cmV0dXJuIEJbMF09MCxCWzFdPTAsQlsyXT0wLEJbM109MSxCWzRdPTAsQls1XT0wLEJbNl09MCxCWzddPTAsQn1mdW5jdGlvbiBoKEIsRixZLFEsTixHLG8seSxqKXtyZXR1cm4gQlswXT1GLEJbMV09WSxCWzJdPVEsQlszXT1OLEJbNF09RyxCWzVdPW8sQls2XT15LEJbN109aixCfXZhciBtPWwuY29weTtmdW5jdGlvbiByKEIsRil7cmV0dXJuIEJbMF09Rls0XSxCWzFdPUZbNV0sQlsyXT1GWzZdLEJbM109Rls3XSxCfXZhciBpPWwuY29weTtmdW5jdGlvbiBuKEIsRil7cmV0dXJuIEJbNF09RlswXSxCWzVdPUZbMV0sQls2XT1GWzJdLEJbN109RlszXSxCfWZ1bmN0aW9uIHMoQixGKXt2YXIgWT1GWzRdLFE9Rls1XSxOPUZbNl0sRz1GWzddLG89LUZbMF0seT0tRlsxXSxqPS1GWzJdLHo9RlszXTtyZXR1cm4gQlswXT0oWSp6K0cqbytRKmotTip5KSoyLEJbMV09KFEqeitHKnkrTipvLVkqaikqMixCWzJdPShOKnorRypqK1kqeS1RKm8pKjIsQn1mdW5jdGlvbiB4KEIsRixZKXt2YXIgUT1GWzBdLE49RlsxXSxHPUZbMl0sbz1GWzNdLHk9WVswXSouNSxqPVlbMV0qLjUsej1ZWzJdKi41LCQ9Rls0XSxYPUZbNV0sdz1GWzZdLGV0PUZbN107cmV0dXJuIEJbMF09USxCWzFdPU4sQlsyXT1HLEJbM109byxCWzRdPW8qeStOKnotRypqKyQsQls1XT1vKmorRyp5LVEqeitYLEJbNl09byp6K1Eqai1OKnkrdyxCWzddPS1RKnktTipqLUcqeitldCxCfWZ1bmN0aW9uIFAoQixGLFkpe3ZhciBRPS1GWzBdLE49LUZbMV0sRz0tRlsyXSxvPUZbM10seT1GWzRdLGo9Rls1XSx6PUZbNl0sJD1GWzddLFg9eSpvKyQqUStqKkcteipOLHc9aipvKyQqTit6KlEteSpHLGV0PXoqbyskKkcreSpOLWoqUSxydD0kKm8teSpRLWoqTi16Kkc7cmV0dXJuIGwucm90YXRlWChCLEYsWSksUT1CWzBdLE49QlsxXSxHPUJbMl0sbz1CWzNdLEJbNF09WCpvK3J0KlErdypHLWV0Kk4sQls1XT13Km8rcnQqTitldCpRLVgqRyxCWzZdPWV0Km8rcnQqRytYKk4tdypRLEJbN109cnQqby1YKlEtdypOLWV0KkcsQn1mdW5jdGlvbiBSKEIsRixZKXt2YXIgUT0tRlswXSxOPS1GWzFdLEc9LUZbMl0sbz1GWzNdLHk9Rls0XSxqPUZbNV0sej1GWzZdLCQ9Rls3XSxYPXkqbyskKlEraipHLXoqTix3PWoqbyskKk4reipRLXkqRyxldD16Km8rJCpHK3kqTi1qKlEscnQ9JCpvLXkqUS1qKk4teipHO3JldHVybiBsLnJvdGF0ZVkoQixGLFkpLFE9QlswXSxOPUJbMV0sRz1CWzJdLG89QlszXSxCWzRdPVgqbytydCpRK3cqRy1ldCpOLEJbNV09dypvK3J0Kk4rZXQqUS1YKkcsQls2XT1ldCpvK3J0KkcrWCpOLXcqUSxCWzddPXJ0Km8tWCpRLXcqTi1ldCpHLEJ9ZnVuY3Rpb24gYihCLEYsWSl7dmFyIFE9LUZbMF0sTj0tRlsxXSxHPS1GWzJdLG89RlszXSx5PUZbNF0saj1GWzVdLHo9Rls2XSwkPUZbN10sWD15Km8rJCpRK2oqRy16Kk4sdz1qKm8rJCpOK3oqUS15KkcsZXQ9eipvKyQqRyt5Kk4taipRLHJ0PSQqby15KlEtaipOLXoqRztyZXR1cm4gbC5yb3RhdGVaKEIsRixZKSxRPUJbMF0sTj1CWzFdLEc9QlsyXSxvPUJbM10sQls0XT1YKm8rcnQqUSt3KkctZXQqTixCWzVdPXcqbytydCpOK2V0KlEtWCpHLEJbNl09ZXQqbytydCpHK1gqTi13KlEsQls3XT1ydCpvLVgqUS13Kk4tZXQqRyxCfWZ1bmN0aW9uIEUoQixGLFkpe3ZhciBRPVlbMF0sTj1ZWzFdLEc9WVsyXSxvPVlbM10seT1GWzBdLGo9RlsxXSx6PUZbMl0sJD1GWzNdO3JldHVybiBCWzBdPXkqbyskKlEraipHLXoqTixCWzFdPWoqbyskKk4reipRLXkqRyxCWzJdPXoqbyskKkcreSpOLWoqUSxCWzNdPSQqby15KlEtaipOLXoqRyx5PUZbNF0saj1GWzVdLHo9Rls2XSwkPUZbN10sQls0XT15Km8rJCpRK2oqRy16Kk4sQls1XT1qKm8rJCpOK3oqUS15KkcsQls2XT16Km8rJCpHK3kqTi1qKlEsQls3XT0kKm8teSpRLWoqTi16KkcsQn1mdW5jdGlvbiBEKEIsRixZKXt2YXIgUT1GWzBdLE49RlsxXSxHPUZbMl0sbz1GWzNdLHk9WVswXSxqPVlbMV0sej1ZWzJdLCQ9WVszXTtyZXR1cm4gQlswXT1RKiQrbyp5K04qei1HKmosQlsxXT1OKiQrbypqK0cqeS1RKnosQlsyXT1HKiQrbyp6K1Eqai1OKnksQlszXT1vKiQtUSp5LU4qai1HKnoseT1ZWzRdLGo9WVs1XSx6PVlbNl0sJD1ZWzddLEJbNF09USokK28qeStOKnotRypqLEJbNV09TiokK28qaitHKnktUSp6LEJbNl09RyokK28qeitRKmotTip5LEJbN109byokLVEqeS1OKmotRyp6LEJ9ZnVuY3Rpb24gSShCLEYsWSxRKXtpZihNYXRoLmFicyhRKTxhLkVQU0lMT04pcmV0dXJuIEMoQixGKTt2YXIgTj1NYXRoLmh5cG90KFlbMF0sWVsxXSxZWzJdKTtRPVEqLjU7dmFyIEc9TWF0aC5zaW4oUSksbz1HKllbMF0vTix5PUcqWVsxXS9OLGo9RypZWzJdL04sej1NYXRoLmNvcyhRKSwkPUZbMF0sWD1GWzFdLHc9RlsyXSxldD1GWzNdO0JbMF09JCp6K2V0Km8rWCpqLXcqeSxCWzFdPVgqeitldCp5K3cqby0kKmosQlsyXT13KnorZXQqaiskKnktWCpvLEJbM109ZXQqei0kKm8tWCp5LXcqajt2YXIgcnQ9Rls0XSxhdD1GWzVdLGx0PUZbNl0saXQ9Rls3XTtyZXR1cm4gQls0XT1ydCp6K2l0Km8rYXQqai1sdCp5LEJbNV09YXQqeitpdCp5K2x0Km8tcnQqaixCWzZdPWx0KnoraXQqaitydCp5LWF0Km8sQls3XT1pdCp6LXJ0Km8tYXQqeS1sdCpqLEJ9ZnVuY3Rpb24gUyhCLEYsWSl7cmV0dXJuIEJbMF09RlswXStZWzBdLEJbMV09RlsxXStZWzFdLEJbMl09RlsyXStZWzJdLEJbM109RlszXStZWzNdLEJbNF09Rls0XStZWzRdLEJbNV09Rls1XStZWzVdLEJbNl09Rls2XStZWzZdLEJbN109Rls3XStZWzddLEJ9ZnVuY3Rpb24gQShCLEYsWSl7dmFyIFE9RlswXSxOPUZbMV0sRz1GWzJdLG89RlszXSx5PVlbNF0saj1ZWzVdLHo9WVs2XSwkPVlbN10sWD1GWzRdLHc9Rls1XSxldD1GWzZdLHJ0PUZbN10sYXQ9WVswXSxsdD1ZWzFdLGl0PVlbMl0sbnQ9WVszXTtyZXR1cm4gQlswXT1RKm50K28qYXQrTippdC1HKmx0LEJbMV09TipudCtvKmx0K0cqYXQtUSppdCxCWzJdPUcqbnQrbyppdCtRKmx0LU4qYXQsQlszXT1vKm50LVEqYXQtTipsdC1HKml0LEJbNF09USokK28qeStOKnotRypqK1gqbnQrcnQqYXQrdyppdC1ldCpsdCxCWzVdPU4qJCtvKmorRyp5LVEqeit3Km50K3J0Kmx0K2V0KmF0LVgqaXQsQls2XT1HKiQrbyp6K1Eqai1OKnkrZXQqbnQrcnQqaXQrWCpsdC13KmF0LEJbN109byokLVEqeS1OKmotRyp6K3J0Km50LVgqYXQtdypsdC1ldCppdCxCfXZhciBVPUE7ZnVuY3Rpb24gSyhCLEYsWSl7cmV0dXJuIEJbMF09RlswXSpZLEJbMV09RlsxXSpZLEJbMl09RlsyXSpZLEJbM109RlszXSpZLEJbNF09Rls0XSpZLEJbNV09Rls1XSpZLEJbNl09Rls2XSpZLEJbN109Rls3XSpZLEJ9dmFyIFY9bC5kb3Q7ZnVuY3Rpb24gSihCLEYsWSxRKXt2YXIgTj0xLVE7cmV0dXJuIFYoRixZKTwwJiYoUT0tUSksQlswXT1GWzBdKk4rWVswXSpRLEJbMV09RlsxXSpOK1lbMV0qUSxCWzJdPUZbMl0qTitZWzJdKlEsQlszXT1GWzNdKk4rWVszXSpRLEJbNF09Rls0XSpOK1lbNF0qUSxCWzVdPUZbNV0qTitZWzVdKlEsQls2XT1GWzZdKk4rWVs2XSpRLEJbN109Rls3XSpOK1lbN10qUSxCfWZ1bmN0aW9uIHEoQixGKXt2YXIgWT10dChGKTtyZXR1cm4gQlswXT0tRlswXS9ZLEJbMV09LUZbMV0vWSxCWzJdPS1GWzJdL1ksQlszXT1GWzNdL1ksQls0XT0tRls0XS9ZLEJbNV09LUZbNV0vWSxCWzZdPS1GWzZdL1ksQls3XT1GWzddL1ksQn1mdW5jdGlvbiBXKEIsRil7cmV0dXJuIEJbMF09LUZbMF0sQlsxXT0tRlsxXSxCWzJdPS1GWzJdLEJbM109RlszXSxCWzRdPS1GWzRdLEJbNV09LUZbNV0sQls2XT0tRls2XSxCWzddPUZbN10sQn12YXIgSD1sLmxlbmd0aCxaPUgsdHQ9bC5zcXVhcmVkTGVuZ3RoLF89dHQ7ZnVuY3Rpb24gc3QoQixGKXt2YXIgWT10dChGKTtpZihZPjApe1k9TWF0aC5zcXJ0KFkpO3ZhciBRPUZbMF0vWSxOPUZbMV0vWSxHPUZbMl0vWSxvPUZbM10vWSx5PUZbNF0saj1GWzVdLHo9Rls2XSwkPUZbN10sWD1RKnkrTipqK0cqeitvKiQ7QlswXT1RLEJbMV09TixCWzJdPUcsQlszXT1vLEJbNF09KHktUSpYKS9ZLEJbNV09KGotTipYKS9ZLEJbNl09KHotRypYKS9ZLEJbN109KCQtbypYKS9ZfXJldHVybiBCfWZ1bmN0aW9uIGsoQil7cmV0dXJuInF1YXQyKCIrQlswXSsiLCAiK0JbMV0rIiwgIitCWzJdKyIsICIrQlszXSsiLCAiK0JbNF0rIiwgIitCWzVdKyIsICIrQls2XSsiLCAiK0JbN10rIikifWZ1bmN0aW9uIGN0KEIsRil7cmV0dXJuIEJbMF09PT1GWzBdJiZCWzFdPT09RlsxXSYmQlsyXT09PUZbMl0mJkJbM109PT1GWzNdJiZCWzRdPT09Rls0XSYmQls1XT09PUZbNV0mJkJbNl09PT1GWzZdJiZCWzddPT09Rls3XX1mdW5jdGlvbiBmdChCLEYpe3ZhciBZPUJbMF0sUT1CWzFdLE49QlsyXSxHPUJbM10sbz1CWzRdLHk9Qls1XSxqPUJbNl0sej1CWzddLCQ9RlswXSxYPUZbMV0sdz1GWzJdLGV0PUZbM10scnQ9Rls0XSxhdD1GWzVdLGx0PUZbNl0saXQ9Rls3XTtyZXR1cm4gTWF0aC5hYnMoWS0kKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoWSksTWF0aC5hYnMoJCkpJiZNYXRoLmFicyhRLVgpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhRKSxNYXRoLmFicyhYKSkmJk1hdGguYWJzKE4tdyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE4pLE1hdGguYWJzKHcpKSYmTWF0aC5hYnMoRy1ldCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKEcpLE1hdGguYWJzKGV0KSkmJk1hdGguYWJzKG8tcnQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhvKSxNYXRoLmFicyhydCkpJiZNYXRoLmFicyh5LWF0KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoeSksTWF0aC5hYnMoYXQpKSYmTWF0aC5hYnMoai1sdCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGopLE1hdGguYWJzKGx0KSkmJk1hdGguYWJzKHotaXQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh6KSxNYXRoLmFicyhpdCkpfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiY3JlYXRlIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNsb25lIixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImZyb21WYWx1ZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwiY29weSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJzZXQiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiYWRkIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKGUsInN1YnRyYWN0IixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImRpdmlkZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjZWlsIixmdW5jdGlvbigpe3JldHVybiB2fSksdC5kKGUsImZsb29yIixmdW5jdGlvbigpe3JldHVybiBDfSksdC5kKGUsIm1pbiIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pLHQuZChlLCJtYXgiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwicm91bmQiLGZ1bmN0aW9uKCl7cmV0dXJuIG19KSx0LmQoZSwic2NhbGUiLGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KSx0LmQoZSwic2NhbGVBbmRBZGQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIG59KSx0LmQoZSwic3F1YXJlZERpc3RhbmNlIixmdW5jdGlvbigpe3JldHVybiBzfSksdC5kKGUsImxlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pLHQuZChlLCJzcXVhcmVkTGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBQfSksdC5kKGUsIm5lZ2F0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pLHQuZChlLCJpbnZlcnNlIixmdW5jdGlvbigpe3JldHVybiBifSksdC5kKGUsIm5vcm1hbGl6ZSIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pLHQuZChlLCJkb3QiLGZ1bmN0aW9uKCl7cmV0dXJuIER9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIEl9KSx0LmQoZSwibGVycCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChlLCJyYW5kb20iLGZ1bmN0aW9uKCl7cmV0dXJuIEF9KSx0LmQoZSwidHJhbnNmb3JtTWF0MiIsZnVuY3Rpb24oKXtyZXR1cm4gVX0pLHQuZChlLCJ0cmFuc2Zvcm1NYXQyZCIsZnVuY3Rpb24oKXtyZXR1cm4gS30pLHQuZChlLCJ0cmFuc2Zvcm1NYXQzIixmdW5jdGlvbigpe3JldHVybiBWfSksdC5kKGUsInRyYW5zZm9ybU1hdDQiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSx0LmQoZSwicm90YXRlIixmdW5jdGlvbigpe3JldHVybiBxfSksdC5kKGUsImFuZ2xlIixmdW5jdGlvbigpe3JldHVybiBXfSksdC5kKGUsInplcm8iLGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSx0LmQoZSwic3RyIixmdW5jdGlvbigpe3JldHVybiBafSksdC5kKGUsImV4YWN0RXF1YWxzIixmdW5jdGlvbigpe3JldHVybiB0dH0pLHQuZChlLCJlcXVhbHMiLGZ1bmN0aW9uKCl7cmV0dXJuIF99KSx0LmQoZSwibGVuIixmdW5jdGlvbigpe3JldHVybiBzdH0pLHQuZChlLCJzdWIiLGZ1bmN0aW9uKCl7cmV0dXJuIGt9KSx0LmQoZSwibXVsIixmdW5jdGlvbigpe3JldHVybiBjdH0pLHQuZChlLCJkaXYiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSksdC5kKGUsImRpc3QiLGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSx0LmQoZSwic3FyRGlzdCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChlLCJzcXJMZW4iLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KSx0LmQoZSwiZm9yRWFjaCIsZnVuY3Rpb24oKXtyZXR1cm4gUX0pO3ZhciBhPXQoMik7ZnVuY3Rpb24gbCgpe3ZhciBOPW5ldyBhLkFSUkFZX1RZUEUoMik7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYoTlswXT0wLE5bMV09MCksTn1mdW5jdGlvbiBNKE4pe3ZhciBHPW5ldyBhLkFSUkFZX1RZUEUoMik7cmV0dXJuIEdbMF09TlswXSxHWzFdPU5bMV0sR31mdW5jdGlvbiBUKE4sRyl7dmFyIG89bmV3IGEuQVJSQVlfVFlQRSgyKTtyZXR1cm4gb1swXT1OLG9bMV09RyxvfWZ1bmN0aW9uIGQoTixHKXtyZXR1cm4gTlswXT1HWzBdLE5bMV09R1sxXSxOfWZ1bmN0aW9uIHUoTixHLG8pe3JldHVybiBOWzBdPUcsTlsxXT1vLE59ZnVuY3Rpb24gYyhOLEcsbyl7cmV0dXJuIE5bMF09R1swXStvWzBdLE5bMV09R1sxXStvWzFdLE59ZnVuY3Rpb24gTyhOLEcsbyl7cmV0dXJuIE5bMF09R1swXS1vWzBdLE5bMV09R1sxXS1vWzFdLE59ZnVuY3Rpb24gZihOLEcsbyl7cmV0dXJuIE5bMF09R1swXSpvWzBdLE5bMV09R1sxXSpvWzFdLE59ZnVuY3Rpb24gZyhOLEcsbyl7cmV0dXJuIE5bMF09R1swXS9vWzBdLE5bMV09R1sxXS9vWzFdLE59ZnVuY3Rpb24gdihOLEcpe3JldHVybiBOWzBdPU1hdGguY2VpbChHWzBdKSxOWzFdPU1hdGguY2VpbChHWzFdKSxOfWZ1bmN0aW9uIEMoTixHKXtyZXR1cm4gTlswXT1NYXRoLmZsb29yKEdbMF0pLE5bMV09TWF0aC5mbG9vcihHWzFdKSxOfWZ1bmN0aW9uIHAoTixHLG8pe3JldHVybiBOWzBdPU1hdGgubWluKEdbMF0sb1swXSksTlsxXT1NYXRoLm1pbihHWzFdLG9bMV0pLE59ZnVuY3Rpb24gaChOLEcsbyl7cmV0dXJuIE5bMF09TWF0aC5tYXgoR1swXSxvWzBdKSxOWzFdPU1hdGgubWF4KEdbMV0sb1sxXSksTn1mdW5jdGlvbiBtKE4sRyl7cmV0dXJuIE5bMF09TWF0aC5yb3VuZChHWzBdKSxOWzFdPU1hdGgucm91bmQoR1sxXSksTn1mdW5jdGlvbiByKE4sRyxvKXtyZXR1cm4gTlswXT1HWzBdKm8sTlsxXT1HWzFdKm8sTn1mdW5jdGlvbiBpKE4sRyxvLHkpe3JldHVybiBOWzBdPUdbMF0rb1swXSp5LE5bMV09R1sxXStvWzFdKnksTn1mdW5jdGlvbiBuKE4sRyl7dmFyIG89R1swXS1OWzBdLHk9R1sxXS1OWzFdO3JldHVybiBNYXRoLmh5cG90KG8seSl9ZnVuY3Rpb24gcyhOLEcpe3ZhciBvPUdbMF0tTlswXSx5PUdbMV0tTlsxXTtyZXR1cm4gbypvK3kqeX1mdW5jdGlvbiB4KE4pe3ZhciBHPU5bMF0sbz1OWzFdO3JldHVybiBNYXRoLmh5cG90KEcsbyl9ZnVuY3Rpb24gUChOKXt2YXIgRz1OWzBdLG89TlsxXTtyZXR1cm4gRypHK28qb31mdW5jdGlvbiBSKE4sRyl7cmV0dXJuIE5bMF09LUdbMF0sTlsxXT0tR1sxXSxOfWZ1bmN0aW9uIGIoTixHKXtyZXR1cm4gTlswXT0xL0dbMF0sTlsxXT0xL0dbMV0sTn1mdW5jdGlvbiBFKE4sRyl7dmFyIG89R1swXSx5PUdbMV0saj1vKm8reSp5O3JldHVybiBqPjAmJihqPTEvTWF0aC5zcXJ0KGopKSxOWzBdPUdbMF0qaixOWzFdPUdbMV0qaixOfWZ1bmN0aW9uIEQoTixHKXtyZXR1cm4gTlswXSpHWzBdK05bMV0qR1sxXX1mdW5jdGlvbiBJKE4sRyxvKXt2YXIgeT1HWzBdKm9bMV0tR1sxXSpvWzBdO3JldHVybiBOWzBdPU5bMV09MCxOWzJdPXksTn1mdW5jdGlvbiBTKE4sRyxvLHkpe3ZhciBqPUdbMF0sej1HWzFdO3JldHVybiBOWzBdPWoreSoob1swXS1qKSxOWzFdPXoreSoob1sxXS16KSxOfWZ1bmN0aW9uIEEoTixHKXtHPUd8fDE7dmFyIG89YS5SQU5ET00oKSoyKk1hdGguUEk7cmV0dXJuIE5bMF09TWF0aC5jb3MobykqRyxOWzFdPU1hdGguc2luKG8pKkcsTn1mdW5jdGlvbiBVKE4sRyxvKXt2YXIgeT1HWzBdLGo9R1sxXTtyZXR1cm4gTlswXT1vWzBdKnkrb1syXSpqLE5bMV09b1sxXSp5K29bM10qaixOfWZ1bmN0aW9uIEsoTixHLG8pe3ZhciB5PUdbMF0saj1HWzFdO3JldHVybiBOWzBdPW9bMF0qeStvWzJdKmorb1s0XSxOWzFdPW9bMV0qeStvWzNdKmorb1s1XSxOfWZ1bmN0aW9uIFYoTixHLG8pe3ZhciB5PUdbMF0saj1HWzFdO3JldHVybiBOWzBdPW9bMF0qeStvWzNdKmorb1s2XSxOWzFdPW9bMV0qeStvWzRdKmorb1s3XSxOfWZ1bmN0aW9uIEooTixHLG8pe3ZhciB5PUdbMF0saj1HWzFdO3JldHVybiBOWzBdPW9bMF0qeStvWzRdKmorb1sxMl0sTlsxXT1vWzFdKnkrb1s1XSpqK29bMTNdLE59ZnVuY3Rpb24gcShOLEcsbyx5KXt2YXIgaj1HWzBdLW9bMF0sej1HWzFdLW9bMV0sJD1NYXRoLnNpbih5KSxYPU1hdGguY29zKHkpO3JldHVybiBOWzBdPWoqWC16KiQrb1swXSxOWzFdPWoqJCt6Klgrb1sxXSxOfWZ1bmN0aW9uIFcoTixHKXt2YXIgbz1OWzBdLHk9TlsxXSxqPUdbMF0sej1HWzFdLCQ9TWF0aC5zcXJ0KG8qbyt5KnkpKk1hdGguc3FydChqKmoreip6KSxYPSQmJihvKmoreSp6KS8kO3JldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoWCwtMSksMSkpfWZ1bmN0aW9uIEgoTil7cmV0dXJuIE5bMF09MCxOWzFdPTAsTn1mdW5jdGlvbiBaKE4pe3JldHVybiJ2ZWMyKCIrTlswXSsiLCAiK05bMV0rIikifWZ1bmN0aW9uIHR0KE4sRyl7cmV0dXJuIE5bMF09PT1HWzBdJiZOWzFdPT09R1sxXX1mdW5jdGlvbiBfKE4sRyl7dmFyIG89TlswXSx5PU5bMV0saj1HWzBdLHo9R1sxXTtyZXR1cm4gTWF0aC5hYnMoby1qKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobyksTWF0aC5hYnMoaikpJiZNYXRoLmFicyh5LXopPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh5KSxNYXRoLmFicyh6KSl9dmFyIHN0PXgsaz1PLGN0PWYsZnQ9ZyxCPW4sRj1zLFk9UCxRPWZ1bmN0aW9uKCl7dmFyIE49bCgpO3JldHVybiBmdW5jdGlvbihHLG8seSxqLHosJCl7dmFyIFgsdztmb3Iob3x8KG89MikseXx8KHk9MCksaj93PU1hdGgubWluKGoqbyt5LEcubGVuZ3RoKTp3PUcubGVuZ3RoLFg9eTtYPHc7WCs9bylOWzBdPUdbWF0sTlsxXT1HW1grMV0seihOLE4sJCksR1tYXT1OWzBdLEdbWCsxXT1OWzFdO3JldHVybiBHfX0oKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKTt2YXIgYT10KDEzKTt0LmQoZSwiUmVuZGVyZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH0pO3ZhciBsPXQoNDApO3QuZChlLCJGaWd1cmUyRCIsZnVuY3Rpb24oKXtyZXR1cm4gbC5kZWZhdWx0fSk7dmFyIE09dCg1Nik7dC5kKGUsIk1lc2gyRCIsZnVuY3Rpb24oKXtyZXR1cm4gTS5kZWZhdWx0fSk7dmFyIFQ9dCgyOSk7dC5kKGUsIk1lc2hDbG91ZCIsZnVuY3Rpb24oKXtyZXR1cm4gVC5kZWZhdWx0fSk7dmFyIGQ9dCgyMyk7dC5kKGUsInBhcnNlRm9udCIsZnVuY3Rpb24oKXtyZXR1cm4gZC5kZWZhdWx0fSk7dmFyIHU9dCgzMSk7dC5kKGUsInBhcnNlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIHUuZGVmYXVsdH0pO3ZhciBjPXQoMjEpO3QuZChlLCJFTlYiLGZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVmYXVsdH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYn0pO3ZhciBhPXQoMTQpLGw9dCgxKSxNPXQoMjApLFQ9dCgyNyksZD10KDI1KSx1PXQoNDApLGM9dCg1NiksTz10KDI5KSxmPXQoNTkpLGc9dCgyMSksdj10KDYzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQz17YXV0b1VwZGF0ZTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsYnVmZmVyU2l6ZToxNTAwfSxwPWBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFBvc2l0aW9uOwphdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleFRleHR1cmVDb29yZDsKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgdmVjMyBwb3MgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7ICAgIAogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsgICAgICAgICAgICAgIAp9CmAsaD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7CnZvaWQgbWFpbigpIHsKICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLnh5KTsKfQpgLG09U3ltYm9sKCJnbFJlbmRlcmVyIikscj1TeW1ib2woImNhbnZhc1JlbmRlcmVyIiksaT1TeW1ib2woIm9wdGlvbnMiKSxuPVN5bWJvbCgiZ2xvYmFsVHJhbnNmb3JtIikscz1TeW1ib2woImFwcGx5R2xvYmFsVHJhbnNmb3JtIikseD1TeW1ib2woImNhbnZhcyIpO2Z1bmN0aW9uIFAoRSl7Y29uc3QgRD1FLmdsLEk9RS5mYm87SSYmRC5iaW5kRnJhbWVidWZmZXIoRC5GUkFNRUJVRkZFUixJKSxFLl9kcmF3KCksSSYmRC5iaW5kRnJhbWVidWZmZXIoRC5GUkFNRUJVRkZFUixudWxsKX1mdW5jdGlvbiBSKEUsRCxJLFMpe2NvbnN0IEE9RS5jcmVhdGVUZXh0dXJlKEQuY2FudmFzKSxVPVtbWzAsMF0sW0ksMF0sW0ksU10sWzAsU10sWzAsMF1dXTtVLmNsb3NlZD0hMDtjb25zdCBLPW5ldyBjLmRlZmF1bHQoe2NvbnRvdXJzOlV9KTtLLnNldFRleHR1cmUoQSksRS5zZXRNZXNoRGF0YShbSy5tZXNoRGF0YV0pLFAoRSksQS5kZWxldGUoKSxELmNsZWFyUmVjdCgwLDAsSSxTKSxkZWxldGUgRC5fZmlsdGVyfWNsYXNzIGJ7Y29uc3RydWN0b3IoRCxJPXt9KXtsZXQgUz1JLmNvbnRleHRUeXBlO2lmKFN8fCh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dD09ImZ1bmN0aW9uIj9TPSJ3ZWJnbDIiOnR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ9PSJmdW5jdGlvbiI/Uz0id2ViZ2wiOlM9IjJkIiksIUQuZ2V0Q29udGV4dCl7Y29uc3QgQT1EO0Q9e2dldENvbnRleHQoKXtyZXR1cm4gQX0sd2lkdGg6SS53aWR0aCxoZWlnaHQ6SS5oZWlnaHR9LEEuY2FudmFzPUQsUz0iMmQifWlmKHRoaXNbeF09RCxTIT09IndlYmdsIiYmUyE9PSJ3ZWJnbDIiJiZTIT09IjJkIil0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29udGV4dCB0eXBlICR7U31gKTtpZihJLmNvbnRleHRUeXBlPVMsdGhpc1tpXT1PYmplY3QuYXNzaWduKHt9LEMsSSksUz09PSJ3ZWJnbCJ8fFM9PT0id2ViZ2wyIil7Uz09PSJ3ZWJnbDIiJiYodGhpc1tpXS53ZWJnbDI9ITApO2NvbnN0IEE9bmV3IGEuZGVmYXVsdChELHRoaXNbaV0pO1M9PT0id2ViZ2wyIiYmIUEuaXNXZWJHTDImJihJLmNvbnRleHRUeXBlPSJ3ZWJnbCIpLE9iamVjdCh2LmNyZWF0ZVNoYWRlcnMpKEEpLE9iamVjdCh2LmFwcGx5U2hhZGVyKShBKSxPYmplY3Qodi5jcmVhdGVDbG91ZFNoYWRlcnMpKEEpO2NvbnN0IFU9QS5nbDtVLmNsZWFyQ29sb3IoMCwwLDAsMCksVS5ibGVuZEZ1bmNTZXBhcmF0ZShVLlNSQ19BTFBIQSxVLk9ORV9NSU5VU19TUkNfQUxQSEEsVS5PTkUsVS5PTkVfTUlOVVNfU1JDX0FMUEhBKSx0aGlzW21dPUF9ZWxzZSB0aGlzW3JdPW5ldyBNLmRlZmF1bHQoRCx0aGlzW2ldKTt0aGlzW25dPVsxLDAsMCwwLDEsMCwwLDAsMV0sdGhpcy51cGRhdGVSZXNvbHV0aW9uKCl9Z2V0IGNhbnZhcygpe3JldHVybiB0aGlzW3hdfWdldCBjYW52YXNSZW5kZXJlcigpe3JldHVybiB0aGlzW3JdfWdldCBnbFJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbbV19Z2V0IGlzV2ViR0wyKCl7cmV0dXJuIHRoaXNbbV0mJnRoaXNbbV0uaXNXZWJHTDJ9Z2V0IG9wdGlvbnMoKXtyZXR1cm4gdGhpc1tpXX1nZXQgZ2xvYmFsVHJhbnNmb3JtTWF0cml4KCl7Y29uc3QgRD10aGlzW25dO3JldHVybltEWzBdLERbMV0sRFszXSxEWzRdLERbNl0sRFs3XV19Z2V0IHZpZXdNYXRyaXgoKXtyZXR1cm4gdGhpc1tuXX1bc10oKXtjb25zdCBEPXRoaXNbbV18fHRoaXNbcl07aWYodGhpc1ttXSl7Y29uc3R7d2lkdGg6SSxoZWlnaHQ6U309dGhpcy5jYW52YXM7RC51bmlmb3Jtcy52aWV3TWF0cml4PXRoaXMudmlld01hdHJpeCxELnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXg9dGhpcy5wcm9qZWN0aW9uTWF0cml4LEQudW5pZm9ybXMudV9yZXNvbHV0aW9uPVtJLFNdfX11cGRhdGVSZXNvbHV0aW9uKCl7Y29uc3R7d2lkdGg6RCxoZWlnaHQ6SX09dGhpcy5jYW52YXMsUz1bMSwwLDAsMCwxLDAsLUQvMiwtSS8yLDFdLEE9WzIvRCwwLDAsMCwtMi9JLDAsMCwwLDFdLFU9bC5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxBLFMpO3RoaXMucHJvamVjdGlvbk1hdHJpeD1VLHRoaXNbbV0mJnRoaXNbbV0uZ2wudmlld3BvcnQoMCwwLEQsSSl9Y3JlYXRlVGV4dHVyZShELEkpe3JldHVybih0aGlzW21dfHx0aGlzW3JdKS5jcmVhdGVUZXh0dXJlKEQsSSl9bG9hZFRleHR1cmUoRCx7dXNlSW1hZ2VCaXRtYXA6ST0hMX09e30pe3JldHVybih0aGlzW21dfHx0aGlzW3JdKS5sb2FkVGV4dHVyZShELHt1c2VJbWFnZUJpdG1hcDpJfSl9Y3JlYXRlVGV4dChELHtmb250Okk9IjE2cHggYXJpYWwiLGZpbGxDb2xvcjpTPW51bGwsc3Ryb2tlQ29sb3I6QT1udWxsLHN0cm9rZVdpZHRoOlU9MX09e30pe2lmKHRoaXNbbV0pe2NvbnN0IEs9Zy5kZWZhdWx0LmNyZWF0ZVRleHQoRCx7Zm9udDpJLGZpbGxDb2xvcjpTLHN0cm9rZUNvbG9yOkEsc3Ryb2tlV2lkdGg6VX0pO3JldHVybntpbWFnZTp0aGlzLmNyZWF0ZVRleHR1cmUoSy5pbWFnZSkscmVjdDpLLnJlY3R9fXJldHVybntfaW1nOntmb250OkksZmlsbENvbG9yOlMsc3Ryb2tlQ29sb3I6QSxzdHJva2VXaWR0aDpVLHRleHQ6RH19fWNyZWF0ZVByb2dyYW0oe3ZlcnRleDpELGZyYWdtZW50Okksb3B0aW9uczpTfT17fSl7aWYodGhpc1ttXSl7Y29uc3QgQT10aGlzW21dLmNvbXBpbGVTeW5jKEksRCk7cmV0dXJuIEEuX2F0dHJpYk9wdHM9UyxBfXRocm93IG5ldyBFcnJvcigiQ29udGV4dCAyRCBjYW5ub3QgY3JlYXRlIHdlYmdsIHByb2dyYW0uIil9Y3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDpEPXAsZnJhZ21lbnQ6ST1oLG9wdGlvbnM6U309e30pe3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDpELGZyYWdtZW50Okksb3B0aW9uczpTfSl9dXNlUHJvZ3JhbShELEk9e30pe2lmKHRoaXNbbV0pe2NvbnN0IFM9T2JqZWN0LmFzc2lnbih7fSxELl9hdHRyaWJPcHRzLEkpO3JldHVybiB0aGlzW21dLnVzZVByb2dyYW0oRCxTKX10aHJvdyBuZXcgRXJyb3IoIkNvbnRleHQgMkQgY2Fubm90IHVzZSB3ZWJnbCBwcm9ncmFtLiIpfWRlbGV0ZVRleHR1cmUoRCl7cmV0dXJuKHRoaXNbbV18fHRoaXNbcl0pLmRlbGV0ZVRleHR1cmUoRCl9Y2xlYXIoLi4uRCl7aWYodGhpc1ttXSl7Y29uc3QgST10aGlzW21dLmdsO0kuY2xlYXIoSS5DT0xPUl9CVUZGRVJfQklUKX1lbHNlIHRoaXNbcl0uY2xlYXIoLi4uRCl9ZHJhd01lc2hDbG91ZChELHtjbGVhcjpJPSExLHByb2dyYW06Uz1udWxsfT17fSl7Y29uc3QgQT10aGlzW21dfHx0aGlzW3JdLFU9U3x8RC5wcm9ncmFtO2lmKHRoaXNbbV0pe2NvbnN0IEs9QS5nbDtpZihJJiZLLmNsZWFyKEsuQ09MT1JfQlVGRkVSX0JJVCksVSlBLnByb2dyYW0hPT1VJiZ0aGlzLnVzZVByb2dyYW0oVSx7YV9jb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZpbGxDbG91ZENvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9LGFfc3Ryb2tlQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX2ZyYW1lSW5kZXg6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMX19KTtlbHNle2NvbnN0IFY9RC5tZXNoLm1lc2hEYXRhLEo9ISFWLnVuaWZvcm1zLnVfdGV4U2FtcGxlcixxPSEhVi51bmlmb3Jtcy51X2ZpbHRlckZsYWcsVz0hIVYudW5pZm9ybXMudV9yYWRpYWxHcmFkaWVudFZlY3RvcixIPUQuaGFzQ2xvdWRDb2xvcixaPUQuaGFzQ2xvdWRGaWx0ZXIsdHQ9ISFWLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHYuYXBwbHlDbG91ZFNoYWRlcikoQSx7aGFzVGV4dHVyZTpKLGhhc0ZpbHRlcjpxLGhhc0dyYWRpZW50OlcsaGFzQ2xvdWRDb2xvcjpILGhhc0Nsb3VkRmlsdGVyOlosaGFzQ2xpcFBhdGg6dHR9KX10aGlzW3NdKCksQS5zZXRNZXNoRGF0YShbRC5tZXNoRGF0YV0pLEQuYmVmb3JlUmVuZGVyJiZELmJlZm9yZVJlbmRlcihLLEQpLFAoQSksRC5hZnRlclJlbmRlciYmRC5hZnRlclJlbmRlcihLLEQpfWVsc2UgQS5zZXRUcmFuc2Zvcm0odGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpLEEuZHJhd01lc2hDbG91ZChELHtjbGVhcjpJLGhvb2s6ITF9KX1kcmF3TWVzaGVzKEQse2NsZWFyOkk9ITEscHJvZ3JhbTpTPW51bGx9PXt9KXtjb25zdCBBPXRoaXNbbV18fHRoaXNbcl07aWYodGhpc1ttXSl7Y29uc3QgVT1BLmZibyxLPU9iamVjdChULmRlZmF1bHQpKHRoaXMsRCxTPT1udWxsKSxWPUEuZ2w7SSYmVi5jbGVhcihWLkNPTE9SX0JVRkZFUl9CSVQpO2NvbnN0IEo9IU9iamVjdChmLmlzVW5pdFRyYW5zZm9ybSkodGhpcy5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgpO3RoaXMuX2RyYXdDYWxscz0wO2Zvcihjb25zdCBxIG9mIEspe3RoaXMuX2RyYXdDYWxscysrO2NvbnN0IFc9U3x8cS5wcm9ncmFtO2lmKHEgaW5zdGFuY2VvZiBPLmRlZmF1bHQpdGhpcy5kcmF3TWVzaENsb3VkKHEse2NsZWFyOkkscHJvZ3JhbTpXfSk7ZWxzZXtjb25zdHt3aWR0aDpILGhlaWdodDpafT10aGlzLmNhbnZhcztpZihxLmJlZm9yZVJlbmRlciYmcS5iZWZvcmVSZW5kZXIoVixxKSxxLnBhc3MubGVuZ3RoJiYoKCF0aGlzLmZib3x8dGhpcy5mYm8ud2lkdGghPT1IfHx0aGlzLmZiby5oZWlnaHQhPT1aKSYmKHRoaXMuZmJvPXt3aWR0aDpILGhlaWdodDpaLHRhcmdldDpBLmNyZWF0ZUZCTygpLGJ1ZmZlcjpBLmNyZWF0ZUZCTygpLHN3YXAoKXtbdGhpcy50YXJnZXQsdGhpcy5idWZmZXJdPVt0aGlzLmJ1ZmZlcix0aGlzLnRhcmdldF19fSksQS5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLCFXJiZxLmZpbHRlckNhbnZhcyl7T2JqZWN0KHYuYXBwbHlTaGFkZXIpKEEse2hhc1RleHR1cmU6ITB9KTtsZXQgdHQ9dGhpcy5maWx0ZXJDb250ZXh0O3R0fHwodHQ9Zy5kZWZhdWx0LmNyZWF0ZUNhbnZhcyhILFopLmdldENvbnRleHQoIjJkIiksdGhpcy5maWx0ZXJDb250ZXh0PXR0KTtjb25zdCBfPURbcS5wYWNrSW5kZXhdLHN0PV8uZmlsdGVyLGs9RFtxLnBhY2tJbmRleCsxXSxjdD1EW3EucGFja0luZGV4LTFdOyghY3R8fCFjdC5maWx0ZXJDYW52YXN8fGN0LmZpbHRlciE9PXN0KSYmKCFrfHwhay5maWx0ZXJDYW52YXN8fGsuZmlsdGVyIT09c3QpPyhKPyh0dC5zYXZlKCksT2JqZWN0KGQuZHJhd01lc2gyRCkoXyx0dCwhMSksdHQucmVzdG9yZSgpLE9iamVjdChkLmFwcGx5RmlsdGVyKSh0dCxzdCkpOk9iamVjdChkLmRyYXdNZXNoMkQpKF8sdHQsITApLHRoaXNbc10oKSxSKEEsdHQsSCxaKSk6KEomJnR0LnNhdmUoKSxPYmplY3QoZC5kcmF3TWVzaDJEKShfLHR0LCExKSxKJiZ0dC5yZXN0b3JlKCksKCFrfHwhay5maWx0ZXJDYW52YXN8fF8uZmlsdGVyIT09ay5maWx0ZXIpJiYoT2JqZWN0KGQuYXBwbHlGaWx0ZXIpKHR0LHN0KSx0aGlzW3NdKCksUihBLHR0LEgsWikpKX1lbHNle2lmKFcpQS5wcm9ncmFtIT09VyYmdGhpcy51c2VQcm9ncmFtKFcse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH19KTtlbHNle2NvbnN0IHR0PSEhcS51bmlmb3Jtcy51X3RleFNhbXBsZXIsXz0hIXEudW5pZm9ybXMudV9maWx0ZXJGbGFnLHN0PSEhcS51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yLGs9ISFxLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXI7T2JqZWN0KHYuYXBwbHlTaGFkZXIpKEEse2hhc1RleHR1cmU6dHQsaGFzRmlsdGVyOl8saGFzR3JhZGllbnQ6c3QsaGFzQ2xpcFBhdGg6a30pfXEuZmlsdGVyQ2FudmFzJiZjb25zb2xlLndhcm4oIlVzZXIgcHJvZ3JhbSBpZ25vcmVkIHNvbWUgZmlsdGVyIGVmZmVjdHMuIiksdGhpc1tzXSgpLEEuc2V0TWVzaERhdGEoW3FdKSxQKEEpfWlmKHEucGFzcy5sZW5ndGgpe2NvbnN0IHR0PXEucGFzcy5sZW5ndGg7cS5wYXNzLmZvckVhY2goKF8sc3QpPT57Xy5ibGVuZD1xLmVuYWJsZUJsZW5kLF8uc2V0VGV4dHVyZShBLmZiby50ZXh0dXJlKSxzdD09PXR0LTE/QS5iaW5kRkJPKFUpOih0aGlzLmZiby5zd2FwKCksQS5iaW5kRkJPKHRoaXMuZmJvLnRhcmdldCkpLF8ucHJvZ3JhbT9BLnVzZVByb2dyYW0oXy5wcm9ncmFtKToodGhpcy5kZWZhdWx0UGFzc1Byb2dyYW09dGhpcy5kZWZhdWx0UGFzc1Byb2dyYW18fHRoaXMuY3JlYXRlUGFzc1Byb2dyYW0oKSxBLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0UGFzc1Byb2dyYW0pKSxBLnNldE1lc2hEYXRhKFtfLm1lc2hEYXRhXSksVi5jbGVhcihWLkNPTE9SX0JVRkZFUl9CSVQpLFAoQSl9KX1xLmFmdGVyUmVuZGVyJiZxLmFmdGVyUmVuZGVyKFYscSl9fX1lbHNlIEEuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4KSxBLmRyYXdNZXNoZXMoRCx7Y2xlYXI6SX0pfWRyYXdJbWFnZShELC4uLkkpe2NvbnN0IFM9SS5sZW5ndGg7aWYoUzwyKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICdkcmF3SW1hZ2UnIG9uICdSZW5kZXJlcic6IDMgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke0kubGVuZ3RoKzF9IHByZXNlbnQuYCk7aWYoUyE9PTImJlMhPT00JiZTIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnZHJhd0ltYWdlJyBvbiAnUmVuZGVyZXInOiBWYWxpZCBhcml0aWVzIGFyZTogWzMsIDUsIDldLCBidXQgJHtJLmxlbmd0aCsxfSBhcmd1bWVudHMgcHJvdmlkZWQuYCk7bGV0IEE9bnVsbCxVPW51bGw7Uz09PTI/QT1bSVswXSxJWzFdLEQud2lkdGgsRC5oZWlnaHRdOlM9PT00P0E9STpTPT09OCYmKFU9SS5zbGljZSgwLDQpLEE9SS5zbGljZSg0KSk7Y29uc3QgSz10aGlzLmNyZWF0ZVRleHR1cmUoRCkse3dpZHRoOlYsaGVpZ2h0Okp9PXRoaXMuY2FudmFzLHE9bmV3IHUuZGVmYXVsdDtxLnJlY3QoQVswXSxBWzFdLFYsSik7Y29uc3QgVz1uZXcgYy5kZWZhdWx0KHEse3dpZHRoOlYsaGVpZ2h0Okp9KTtXLnNldFRleHR1cmUoSyx7cmVjdDpBLHNyY1JlY3Q6VX0pLHRoaXMuZHJhd01lc2hlcyhbV10pLHRoaXMuZGVsZXRlVGV4dHVyZShLKX1zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uRCl7cmV0dXJuIHRoaXNbbl09W0RbMF0sRFsxXSwwLERbMl0sRFszXSwwLERbNF0sRFs1XSwxXSx0aGlzfWdsb2JhbFRyYW5zZm9ybSguLi5EKXtjb25zdCBJPXRoaXNbbl07cmV0dXJuIHRoaXNbbl09bC5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxJLEQpLHRoaXN9Z2xvYmFsVHJhbnNsYXRlKEQsSSl7bGV0IFM9bC5tYXQzLmNyZWF0ZSgpO3JldHVybiBTPWwubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFMsW0QsSV0pLHRoaXMuZ2xvYmFsVHJhbnNmb3JtKC4uLlMpfWdsb2JhbFJvdGF0ZShELFtJLFNdPVswLDBdKXtsZXQgQT1sLm1hdDMuY3JlYXRlKCk7cmV0dXJuIEE9bC5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQSxbSSxTXSksQT1sLm1hdDMucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxBLEQpLEE9bC5tYXQzLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQSxbLUksLVNdKSx0aGlzLmdsb2JhbFRyYW5zZm9ybSguLi5BKX1nbG9iYWxTY2FsZShELEk9RCxbUyxBXT1bMCwwXSl7bGV0IFU9bC5tYXQzLmNyZWF0ZSgpO3JldHVybiBVPWwubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFUsW1MsQV0pLFU9bC5tYXQzLnNjYWxlKEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxVLFtELEldKSxVPWwubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFUsWy1TLC1BXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uVSl9Z2xvYmFsU2tldyhELEk9RCxbUyxBXT1bMCwwXSl7bGV0IFU9bC5tYXQzLmNyZWF0ZSgpO3JldHVybiBVPWwubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFUsW1MsQV0pLFU9bC5tYXQzLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwLDAsMCwwKSxVLGwubWF0My5mcm9tVmFsdWVzKDEsTWF0aC50YW4oSSksTWF0aC50YW4oRCksMSwwLDApKSxVPWwubWF0My50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDAsMCwwLDApLFUsWy1TLC1BXSksdGhpcy5nbG9iYWxUcmFuc2Zvcm0oLi4uVSl9dHJhbnNmb3JtUG9pbnQoRCxJLFMpe2xldCBBPXRoaXMuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O1MmJihBPWwubWF0My5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCwwLDAsMCksQSxTKSk7Y29uc3QgVT1EKkFbMF0rSSpBWzJdK0FbNF0sSz1EKkFbMV0rSSpBWzNdK0FbNV07cmV0dXJuW1UsS119fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKTt2YXIgYT10KDE1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWEuZGVmYXVsdH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pO3ZhciBhPXQoMTYpLGw9dCgxNyksTT10KDE4KSxUPXQoMTkpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBkKEMscCxoKXtyZXR1cm4gcCBpbiBDP09iamVjdC5kZWZpbmVQcm9wZXJ0eShDLHAse3ZhbHVlOmgsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpDW3BdPWgsQ31jb25zdCB1PXt9O2Z1bmN0aW9uIGMoQyxwPTMpe2NvbnN0IGg9W10sbT1DLmxlbmd0aDtmb3IobGV0IHI9MDtyPG07cisrKXIlcDwyJiZoLnB1c2goLjUqKENbcl0rMSkpO3JldHVybiBofWZ1bmN0aW9uIE8oQyxwKXtjb25zdCBoPXAuX2J1ZmZlcnM7T2JqZWN0LnZhbHVlcyhoKS5mb3JFYWNoKG09PntDLmRlbGV0ZUJ1ZmZlcihtKX0pLHAuX2J1ZmZlcnM9e319ZnVuY3Rpb24gZihDLHAsaCl7cmV0dXJuIEMuYWN0aXZlVGV4dHVyZShDLlRFWFRVUkUwK2gpLEFycmF5LmlzQXJyYXkocC5faW1nKT9DLmJpbmRUZXh0dXJlKEMuVEVYVFVSRV9DVUJFX01BUCxwKTpDLmJpbmRUZXh0dXJlKEMuVEVYVFVSRV8yRCxwKSxwfWNvbnN0IGc9e2ludDoiMWkiLGl2ZWMyOiIyaSIsaXZlYzM6IjNpIixpdmVjNDoiNGkiLGZsb2F0OiIxZiIsdmVjMjoiMmYiLHZlYzM6IjNmIix2ZWM0OiI0ZiIsbWF0MjoiTWF0cml4MmZ2IixtYXQzOiJNYXRyaXgzZnYiLG1hdDQ6Ik1hdHJpeDRmdiIsc2FtcGxlcjFEOiJzYW1wbGVyMUQiLHNhbXBsZXIyRDoic2FtcGxlcjJEIixzYW1wbGVyM0Q6InNhbXBsZXIzRCIsc2FtcGxlckN1YmU6InNhbXBsZXJDdWJlIixzYW1wbGVyMURTaGFkb3c6InNhbXBsZXIxRFNoYWRvdyIsc2FtcGxlcjJEU2hhZG93OiJzYW1wbGVyMkRTaGFkb3ciLHNhbXBsZXIyRFJlY3Q6InNhbXBsZXIyRFJlY3QiLHNhbXBsZXIyRFJlY3RTaGFkb3c6InNhbXBsZXIyRFJlY3RTaGFkb3cifTtjbGFzcyB2e3N0YXRpYyBhZGRMaWJzKHA9e30pe09iamVjdC5hc3NpZ24odSxwKX1zdGF0aWMgRkxPQVQocCxoKXtyZXR1cm4gT2JqZWN0KGEucG9pbnRzVG9CdWZmZXIpKHAsRmxvYXQzMkFycmF5LGgpfXN0YXRpYyBVTlNJR05FRF9CWVRFKHAsaCl7cmV0dXJuIE9iamVjdChhLnBvaW50c1RvQnVmZmVyKShwLFVpbnQ4QXJyYXksaCl9c3RhdGljIFVOU0lHTkVEX1NIT1JUKHAsaCl7cmV0dXJuIE9iamVjdChhLnBvaW50c1RvQnVmZmVyKShwLFVpbnQxNkFycmF5LGgpfXN0YXRpYyBCWVRFKHAsaCl7cmV0dXJuIE9iamVjdChhLnBvaW50c1RvQnVmZmVyKShwLEludDhBcnJheSxoKX1zdGF0aWMgU0hPUlQocCxoKXtyZXR1cm4gT2JqZWN0KGEucG9pbnRzVG9CdWZmZXIpKHAsSW50MTZBcnJheSxoKX1jb25zdHJ1Y3RvcihwLGg9e30pe3RoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LHYuZGVmYXVsdE9wdGlvbnMsaCksdGhpcy5jYW52YXM9cDtsZXQgbTt0aGlzLm9wdGlvbnMud2ViZ2wyJiYobT1wLmdldENvbnRleHQoIndlYmdsMiIsdGhpcy5vcHRpb25zKSksbT09bnVsbCYmKG09T2JqZWN0KGEuc2V0dXBXZWJHTCkocCx0aGlzLm9wdGlvbnMpLHRoaXMuYWlhX2V4dD1tLmdldEV4dGVuc2lvbigiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpKSx0aGlzLmdsPW0sbS52aWV3cG9ydCgwLDAscC53aWR0aCxwLmhlaWdodCksbS5jbGVhckNvbG9yKDAsMCwwLDApLG0uYmxlbmRGdW5jU2VwYXJhdGUobS5TUkNfQUxQSEEsbS5PTkVfTUlOVVNfU1JDX0FMUEhBLG0uT05FLG0uT05FX01JTlVTX1NSQ19BTFBIQSksdGhpcy5wcm9ncmFtcz1bXSx0aGlzLl9ldmVudHM9e319Z2V0IHByb2dyYW0oKXtjb25zdCBwPXRoaXMuZ2w7cmV0dXJuIHAuZ2V0UGFyYW1ldGVyKHAuQ1VSUkVOVF9QUk9HUkFNKX1fZGVjbGFyZVVuaWZvcm0ocCxoLG09IjFmIil7Y29uc3Qgcj10aGlzLmdsLGk9ci5nZXRVbmlmb3JtTG9jYXRpb24ocCxoKTtsZXQgbjtjb25zdCBzPXRoaXM7aWYoL15zYW1wbGVyLy50ZXN0KG0pKXtjb25zdCB4PXAuX3NhbXBsZXJNYXAsUD1wLl9iaW5kVGV4dHVyZXM7T2JqZWN0LmRlZmluZVByb3BlcnR5KHAudW5pZm9ybXMsaCx7Z2V0KCl7cmV0dXJuIG59LHNldChSKXtuPVI7Y29uc3QgYj14W2hdIT1udWxsP3hbaF06UC5sZW5ndGg7UFtiXT1SLGYocixSLGIpLHhbaF18fCh4W2hdPWIsci51bmlmb3JtMWkoaSxiKSkscy5vcHRpb25zLmF1dG9VcGRhdGUmJnMudXBkYXRlKCl9LGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwfSl9ZWxzZXtjb25zdCB4PW0uaW5kZXhPZigiTWF0cml4Iik9PT0wLFA9IXgmJi92JC8udGVzdChtKSxSPXJbYHVuaWZvcm0ke219YF0uYmluZChyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkocC51bmlmb3JtcyxoLHtnZXQoKXtyZXR1cm4gbn0sc2V0KGIpe249Yix0eXBlb2YgYj09Im51bWJlciImJihiPVtiXSkseD9SKGksITEsYik6UD9SKGksYik6UihpLC4uLmIpLHMub3B0aW9ucy5hdXRvVXBkYXRlJiZzLnVwZGF0ZSgpfSxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMH0pfX1fZHJhdygpe2NvbnN0IHA9dGhpcy5wcm9ncmFtO3AubWVzaERhdGEuZm9yRWFjaCgoaCxtKT0+e2NvbnN0e3Bvc2l0aW9uczpyLGNlbGxzOmksaW5zdGFuY2VDb3VudDpuLGNlbGxzQ291bnQ6cyxhdHRyaWJ1dGVzOngsdW5pZm9ybXM6UCx0ZXh0dXJlQ29vcmQ6UixlbmFibGVCbGVuZDpifT1oLEU9dGhpcy5nbDtsZXQgRD1oLm1vZGUhPW51bGw/aC5tb2RlOkUuVFJJQU5HTEVTO3R5cGVvZiBEPT0ic3RyaW5nIiYmKEQ9RVtEXSksYj9FLmVuYWJsZShFLkJMRU5EKTpFLmRpc2FibGUoRS5CTEVORCksRS5iaW5kQnVmZmVyKEUuQVJSQVlfQlVGRkVSLHAuX2J1ZmZlcnMudmVydGljZXNCdWZmZXIpLEUuYnVmZmVyRGF0YShFLkFSUkFZX0JVRkZFUixyLEUuU1RBVElDX0RSQVcpLGkmJihFLmJpbmRCdWZmZXIoRS5FTEVNRU5UX0FSUkFZX0JVRkZFUixwLl9idWZmZXJzLmNlbGxzQnVmZmVyKSxFLmJ1ZmZlckRhdGEoRS5FTEVNRU5UX0FSUkFZX0JVRkZFUixpLEUuU1RBVElDX0RSQVcpKTtjb25zdCBJPVtdO3gmJk9iamVjdC52YWx1ZXMoeCkuZm9yRWFjaCgoe25hbWU6QSxkYXRhOlUsZGl2aXNvcjpLfSk9PntpZihFLmJpbmRCdWZmZXIoRS5BUlJBWV9CVUZGRVIscC5fYnVmZmVyc1tBXSksRS5idWZmZXJEYXRhKEUuQVJSQVlfQlVGRkVSLFUsRS5TVEFUSUNfRFJBVyksSyE9bnVsbCl7Y29uc3QgVj1FLmdldEF0dHJpYkxvY2F0aW9uKHAsQSk7Vj49MCYmKEUuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoViksSS5wdXNoKFYpLEUudmVydGV4QXR0cmliRGl2aXNvcj9FLnZlcnRleEF0dHJpYkRpdmlzb3IoVixLKTp0aGlzLmFpYV9leHQmJnRoaXMuYWlhX2V4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoVixLKSl9fSksUCYmT2JqZWN0LmVudHJpZXMoUCkuZm9yRWFjaCgoW0EsVV0pPT57dGhpcy51bmlmb3Jtc1tBXT1VfSk7bGV0IFM7aWYoIWkpe2NvbnN0IEE9cC5fZGltZW5zaW9uO1M9ci5sZW5ndGgvQX1pZihwLl9lbmFibGVUZXh0dXJlcyYmcC5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlcil7Y29uc3QgQT1SfHxjKHIscC5fZGltZW5zaW9uKTtFLmJpbmRCdWZmZXIoRS5BUlJBWV9CVUZGRVIscC5fYnVmZmVycy50ZXhDb29yZEJ1ZmZlciksRS5idWZmZXJEYXRhKEUuQVJSQVlfQlVGRkVSLHYuRkxPQVQoQSksRS5TVEFUSUNfRFJBVyl9biE9bnVsbD8oaT9FLmRyYXdFbGVtZW50c0luc3RhbmNlZD9FLmRyYXdFbGVtZW50c0luc3RhbmNlZChELHMsRS5VTlNJR05FRF9TSE9SVCwwLG4pOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKEQscyxFLlVOU0lHTkVEX1NIT1JULDAsbik6RS5kcmF3QXJyYXlzSW5zdGFuY2VkP0UuZHJhd0FycmF5c0luc3RhbmNlZChELDAsUyxuKTp0aGlzLmFpYV9leHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKEQsMCxTLG4pLEkuZm9yRWFjaChBPT57RS52ZXJ0ZXhBdHRyaWJEaXZpc29yP0UudmVydGV4QXR0cmliRGl2aXNvcihBLG51bGwpOnRoaXMuYWlhX2V4dCYmdGhpcy5haWFfZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShBLG51bGwpfSkpOmk/RS5kcmF3RWxlbWVudHMoRCxzLEUuVU5TSUdORURfU0hPUlQsMCk6RS5kcmF3QXJyYXlzKEQsMCxTKX0pfWdldCBpc1dlYkdMMigpe3JldHVybiB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDwidSImJnRoaXMuZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0fWdldCBlbmFibGVUZXh0dXJlcygpe3JldHVybiB0aGlzLnByb2dyYW0mJnRoaXMucHJvZ3JhbS5fZW5hYmxlVGV4dHVyZXN9Z2V0IHVuaWZvcm1zKCl7Y29uc3QgcD10aGlzLnByb2dyYW07aWYoIXB8fCFwLnVuaWZvcm1zKXRocm93IEVycm9yKCJObyBhdmFsaWFibGUgcHJvZ3JhbS4iKTtyZXR1cm4gcC51bmlmb3Jtc31kZWxldGVQcm9ncmFtKHApe2NvbnN0IGg9dGhpcy5nbDt0aGlzLnByb2dyYW09PT1wJiYodGhpcy5zdGFydFJlbmRlcj0hMSx0aGlzLl9yZW5kZXJGcmFtZUlEJiYoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyRnJhbWVJRCksZGVsZXRlIHRoaXMuX3JlbmRlckZyYW1lSUQpLGgudXNlUHJvZ3JhbShudWxsKSk7Y29uc3QgbT10aGlzLnByb2dyYW1zLmluZGV4T2YocCk7bT49MCYmdGhpcy5wcm9ncmFtcy5zcGxpY2UobSwxKSxPKGgscCksaC5kZWxldGVQcm9ncmFtKHApfXNldE1lc2hEYXRhKHApe0FycmF5LmlzQXJyYXkocCl8fChwPVtwXSk7Y29uc3QgaD10aGlzLnByb2dyYW07aC5tZXNoRGF0YT1wLm1hcCgoe21vZGU6bSxwb3NpdGlvbnM6cixpbnN0YW5jZUNvdW50OmksY2VsbHM6bixjZWxsc0NvdW50OnMsYXR0cmlidXRlczp4LHVuaWZvcm1zOlAsdGV4dHVyZUNvb3JkOlIsZW5hYmxlQmxlbmQ6Yn0pPT57Y29uc3QgRT17cG9zaXRpb25zOnYuRkxPQVQociksdW5pZm9ybXM6UCxlbmFibGVCbGVuZDohIWIsdGV4dHVyZUNvb3JkOnYuRkxPQVQoUil9O2lmKG4mJihFLmNlbGxzPXYuVVNIT1JUKG4pLEUuY2VsbHNDb3VudD1zfHxFLmNlbGxzLmxlbmd0aCksbSE9bnVsbCYmKEUubW9kZT1tKSxpIT1udWxsKXtpZighdGhpcy5pc1dlYkdMMiYmIXRoaXMuYWlhX2V4dCl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCB1c2UgaW5zdGFuY2VDb3VudCBpbiB0aGlzIHJlbmRlcmluZyBjb250ZXh0LCB1c2Ugd2ViZ2wyIGNvbnRleHQgaW5zdGVhZC4iKTtFLmluc3RhbmNlQ291bnQ9aX1pZih4KXtjb25zdCBEPXt9O09iamVjdC5lbnRyaWVzKHgpLmZvckVhY2goKFtJLFNdKT0+e2lmKCFoLl9hdHRyaWJ1dGVbSV0paC5fYXR0cmlidXRlW0ldPSJpZ25vcmVkIjtlbHNlIGlmKGguX2F0dHJpYnV0ZVtJXSE9PSJpZ25vcmVkIil7Y29uc3R7bmFtZTpBLHR5cGU6VX09aC5fYXR0cmlidXRlW0ldO2xldCBLPVMuZGF0YXx8UztpZihBcnJheS5pc0FycmF5KEspJiYoSz12W1VdKEspKSxEW0ldPXtuYW1lOkEsZGF0YTpLfSxTLmRpdmlzb3IhPW51bGwpe2lmKCF0aGlzLmlzV2ViR0wyJiYhdGhpcy5haWFfZXh0KXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHVzZSBkaXZpc29yIGluIHRoaXMgcmVuZGVyaW5nIGNvbnRleHQsIHVzZSB3ZWJnbDIgY29udGV4dCBpbnN0ZWFkLiIpO0RbSV0uZGl2aXNvcj1TLmRpdmlzb3J9fX0pLEUuYXR0cmlidXRlcz1EfXJldHVybiBFfSksdGhpcy5vcHRpb25zLmF1dG9VcGRhdGUmJnRoaXMudXBkYXRlKCl9Y3JlYXRlUHJvZ3JhbShwLGgpe2NvbnN0IG09L15ccyp1bmlmb3JtXHMrc2FtcGxlci9tZy50ZXN0KHApO3A9PW51bGwmJihwPU0uZGVmYXVsdCksaD09bnVsbCYmKGg9bT9ULmRlZmF1bHQ6bC5kZWZhdWx0KTtjb25zdCByPXRoaXMuZ2wsaT1PYmplY3QoYS5jcmVhdGVQcm9ncmFtKShyLGgscCk7aS5zaGFkZXJUZXh0PXt2ZXJ0ZXhTaGFkZXI6aCxmcmFnbWVudFNoYWRlcjpwfSxpLl9idWZmZXJzPXt9LGkuX2F0dHJpYnV0ZT17fSxpLnVuaWZvcm1zPXt9LGkuX3NhbXBsZXJNYXA9e30saS5fYmluZFRleHR1cmVzPVtdO2NvbnN0IG49bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhQb3NpdGlvbn1gLCJpbSIpO2xldCBzPWgubWF0Y2gobik7cyYmKGkuX2RpbWVuc2lvbj1OdW1iZXIoc1sxXSkpO2NvbnN0IHg9bmV3IFJlZ0V4cChgKD86YXR0cmlidXRlfGluKSB2ZWMoXFxkKSAke3RoaXMub3B0aW9ucy52ZXJ0ZXhUZXh0dXJlQ29vcmR9YCwiaW0iKTtzPWgubWF0Y2goeCkscyYmKGkuX3RleENvb3JkU2l6ZT1OdW1iZXIoc1sxXSkpO2NvbnN0IFA9L15ccyooPzphdHRyaWJ1dGV8aW4pIChcdys/KShcZCopIChcdyspL2dpbTtpZihzPWgubWF0Y2goUCkscylmb3IobGV0IEU9MDtFPHMubGVuZ3RoO0UrKyl7Y29uc3QgRD0vXlxzKig/OmF0dHJpYnV0ZXxpbikgKFx3Kz8pKFxkKikgKFx3KykvaW0sST1zW0VdLm1hdGNoKEQpO2lmKEkmJklbM10hPT10aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24mJklbM10hPT10aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKXtsZXRbLFMsQSxVXT1JO1M9PT0ibWF0IiYmKEEqKj0yKSxpLl9idWZmZXJzW1VdPXIuY3JlYXRlQnVmZmVyKCksaS5fYXR0cmlidXRlW1VdPXtuYW1lOlUsdHlwZTpTLHNpemU6TnVtYmVyKEEpfHwxfX19Y29uc3QgUj0vXlxzKnVuaWZvcm1ccysoXHcrKVxzKyhcdyspKFxbXGQrXF0pPy9tZztzPWgubWF0Y2goUil8fFtdLHM9cy5jb25jYXQocC5tYXRjaChSKXx8W10pLHMuZm9yRWFjaChFPT57Y29uc3QgRD1FLm1hdGNoKC9eXHMqdW5pZm9ybVxzKyhcdyspXHMrKFx3KykoXFtcZCtcXSk/Lyk7bGV0W0ksUyxBXT1ELnNsaWNlKDEpO0k9Z1tJXSxBPSEhQSxJLmluZGV4T2YoIk1hdHJpeCIpIT09MCYmQSYmKEkrPSJ2IiksdGhpcy5fZGVjbGFyZVVuaWZvcm0oaSxTLEkpfSksaS5fYnVmZmVycy52ZXJ0aWNlc0J1ZmZlcj1yLmNyZWF0ZUJ1ZmZlcigpLGkuX2J1ZmZlcnMuY2VsbHNCdWZmZXI9ci5jcmVhdGVCdWZmZXIoKTtjb25zdCBiPXIuZ2V0QXR0cmliTG9jYXRpb24oaSx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTtyZXR1cm4gaS5fZW5hYmxlVGV4dHVyZXM9Yj49MCxpLl9lbmFibGVUZXh0dXJlcyYmKGkuX2J1ZmZlcnMudGV4Q29vcmRCdWZmZXI9ci5jcmVhdGVCdWZmZXIoKSksdGhpcy5wcm9ncmFtcy5wdXNoKGkpLGl9dXNlUHJvZ3JhbShwLGg9e30pe3RoaXMuc3RhcnRSZW5kZXI9ITEsdGhpcy5fcmVuZGVyRnJhbWVJRCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckZyYW1lSUQpLGRlbGV0ZSB0aGlzLl9yZW5kZXJGcmFtZUlEKTtjb25zdCBtPXRoaXMuZ2w7bS51c2VQcm9ncmFtKHApO2NvbnN0IHI9cC5fZGltZW5zaW9uO20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixwLl9idWZmZXJzLnZlcnRpY2VzQnVmZmVyKTtjb25zdCBpPW0uZ2V0QXR0cmliTG9jYXRpb24ocCx0aGlzLm9wdGlvbnMudmVydGV4UG9zaXRpb24pO2lmKG0udmVydGV4QXR0cmliUG9pbnRlcihpLHIsbS5GTE9BVCwhMSwwLDApLG0uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSkscC5fZW5hYmxlVGV4dHVyZXMpe20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixwLl9idWZmZXJzLnRleENvb3JkQnVmZmVyKTtjb25zdCBuPW0uZ2V0QXR0cmliTG9jYXRpb24ocCx0aGlzLm9wdGlvbnMudmVydGV4VGV4dHVyZUNvb3JkKTttLnZlcnRleEF0dHJpYlBvaW50ZXIobixwLl90ZXhDb29yZFNpemV8fDIsbS5GTE9BVCwhMSwwLDApLG0uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobil9aWYoT2JqZWN0LmVudHJpZXMocC5fYXR0cmlidXRlKS5mb3JFYWNoKChbbixzXSk9PntpZihzIT09Imlnbm9yZWQiKXtjb25zdCB4PXMuc2l6ZSxQPWhbbl18fHt9LFI9ISFQLm5vcm1hbGl6ZTtsZXQgYj1QLnR5cGV8fCJGTE9BVCI7Y29uc3QgRT1QLmtleXx8bjtiPT09IlVCWVRFIiYmKGI9IlVOU0lHTkVEX0JZVEUiKSxiPT09IlVTSE9SVCImJihiPSJVTlNJR05FRF9TSE9SVCIpLHMudHlwZT1iLEUmJkUhPT1uJiYocC5fYXR0cmlidXRlW0VdPXMpLG0uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixwLl9idWZmZXJzW25dKTtjb25zdCBEPW0uZ2V0QXR0cmliTG9jYXRpb24ocCxuKTtEPj0wJiYobS52ZXJ0ZXhBdHRyaWJQb2ludGVyKEQseCxtW2JdLFIsMCwwKSxtLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEQpKX19KSwhcC5tZXNoRGF0YSl7Y29uc3Qgbj1bWy0xLC0xLDAsMV0uc2xpY2UoMCxyKSxbMSwtMSwwLDFdLnNsaWNlKDAsciksWzEsMSwwLDFdLnNsaWNlKDAsciksWy0xLDEsMCwxXS5zbGljZSgwLHIpXSxzPVtbMCwxLDNdLFszLDEsMl1dO3RoaXMuc2V0TWVzaERhdGEoe3Bvc2l0aW9uczpuLGNlbGxzOnN9KX1yZXR1cm4gcH1jb21waWxlU3luYyhwLGgpe3A9cHx8TS5kZWZhdWx0O2NvbnN0IG09e307ZnVuY3Rpb24gcih4KXt4PXgucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgUD1bXSxSPXgubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihSKXtmb3IobGV0IGI9MDtiPFIubGVuZ3RoO2IrKyl7Y29uc3QgRD1SW2JdLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihEKXtjb25zdCBJPURbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFM9RFsxXTtpZihTPT09ImdyYXBoIiYmKFM9ImdyYXBoaWNzIiksbVtTXSlQLnB1c2goYC8qIGluY2x1ZGVkICR7U30gKi9gKTtlbHNlIGlmKG1bU109ITAsST09PSJsaWIiKXtjb25zdCBBPXIodVtTXSk7UC5wdXNoKEEpfWVsc2UgaWYoST09PSJsaW5rIil0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBsb2FkIGV4dGVybmFsIGxpbmtzIHN5bmNocm9ub3VzbHkuIFVzZSBjb21waWxlIGluc3RlYWQgb2YgY29tcGlsZVN5bmMuIil9fVAuZm9yRWFjaChiPT57eD14LnJlcGxhY2UoL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL20sYil9KX1yZXR1cm4geH1jb25zdCBpPXIocCksbj1oP3IoaCk6bnVsbDtyZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtKGksbil9YXN5bmMgY29tcGlsZShwLGgpe3A9cHx8TS5kZWZhdWx0O2NvbnN0IG09e307YXN5bmMgZnVuY3Rpb24gcih4KXt4PXgucmVwbGFjZSgvXlxzKi9tZywiIik7Y29uc3QgUD1bXSxSPXgubWF0Y2goL14jcHJhZ21hXHMraW5jbHVkZVxzKy4qL21nKTtpZihSKXtmb3IobGV0IGI9MDtiPFIubGVuZ3RoO2IrKyl7Y29uc3QgRD1SW2JdLm1hdGNoKC8oPzo8fCIpKC4qKSg/Oj58IikvKTtpZihEKXtjb25zdCBJPURbMF0uaW5kZXhPZigiPCIpPT09MD8ibGliIjoibGluayI7bGV0IFM9RFsxXTtpZihTPT09ImdyYXBoIiYmKFM9ImdyYXBoaWNzIiksbVtTXSlQLnB1c2goYC8qIGluY2x1ZGVkICR7U30gKi9gKTtlbHNlIGlmKG1bU109ITAsST09PSJsaWIiKXtjb25zdCBBPWF3YWl0IHIodVtTXSk7UC5wdXNoKEEpfWVsc2UgaWYoST09PSJsaW5rIil7bGV0IEE9YXdhaXQgdi5mZXRjaFNoYWRlcihTKTtBPWF3YWl0IHIoQSksUC5wdXNoKEEpfX19UC5mb3JFYWNoKGI9Pnt4PXgucmVwbGFjZSgvXiNwcmFnbWFccytpbmNsdWRlXHMrLiovbSxiKX0pfXJldHVybiB4fWNvbnN0IGk9YXdhaXQgcihwKSxuPWg/YXdhaXQgcihoKTpudWxsO3JldHVybiB0aGlzLmNyZWF0ZVByb2dyYW0oaSxuKX1hc3luYyBsb2FkKHAsaD1udWxsKXtyZXR1cm4gcD1hd2FpdCB2LmZldGNoU2hhZGVyKHApLGgmJihoPWF3YWl0IHYuZmV0Y2hTaGFkZXIoaCkpLHRoaXMuY29tcGlsZShwLGgpfWNyZWF0ZVRleHR1cmUocD1udWxsLHt3cmFwUzpoPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSx3cmFwVDptPXRoaXMuZ2wuQ0xBTVBfVE9fRURHRSxtaW5GaWx0ZXI6cj10aGlzLmdsLkxJTkVBUixtYWdGaWx0ZXI6aT10aGlzLmdsLkxJTkVBUn09e30pe2NvbnN0IG49dGhpcy5nbCxzPUFycmF5LmlzQXJyYXkocCk/bi5URVhUVVJFX0NVQkVfTUFQOm4uVEVYVFVSRV8yRDt0aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0cz10aGlzLl9tYXhfdGV4dHVyZV9pbWFnZV91bml0c3x8bi5nZXRQYXJhbWV0ZXIobi5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyksbi5hY3RpdmVUZXh0dXJlKG4uVEVYVFVSRTArdGhpcy5fbWF4X3RleHR1cmVfaW1hZ2VfdW5pdHMtMSk7Y29uc3QgeD1uLmNyZWF0ZVRleHR1cmUoKTtuLmJpbmRUZXh0dXJlKHMseCksbi5waXhlbFN0b3JlaShuLlVOUEFDS19GTElQX1lfV0VCR0wsITApO2NvbnN0e3dpZHRoOlAsaGVpZ2h0OlJ9PXRoaXMuY2FudmFzO2lmKHApaWYocz09PW4uVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IGI9MDtiPDY7YisrKW4udGV4SW1hZ2UyRChuLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtiLDAsbi5SR0JBLG4uUkdCQSxuLlVOU0lHTkVEX0JZVEUscFtiXSk7ZWxzZSBuLnRleEltYWdlMkQocywwLG4uUkdCQSxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLHApO2Vsc2UgaWYocz09PW4uVEVYVFVSRV9DVUJFX01BUClmb3IobGV0IGI9MDtiPDY7YisrKXRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtiLDAsbi5SR0JBLFAsUiwwLG4uUkdCQSxuLlVOU0lHTkVEX0JZVEUsbnVsbCk7ZWxzZSBuLnRleEltYWdlMkQocywwLG4uUkdCQSxQLFIsMCxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLG51bGwpO3JldHVybiBuLnRleFBhcmFtZXRlcmkocyxuLlRFWFRVUkVfTUlOX0ZJTFRFUixyKSxuLnRleFBhcmFtZXRlcmkocyxuLlRFWFRVUkVfTUFHX0ZJTFRFUixpKSxuLnRleFBhcmFtZXRlcmkocyxuLlRFWFRVUkVfV1JBUF9TLGgpLG4udGV4UGFyYW1ldGVyaShzLG4uVEVYVFVSRV9XUkFQX1QsbSkscz09PW4uVEVYVFVSRV9DVUJFX01BUCYmKHAud2lkdGg9cFswXS53aWR0aCxwLmhlaWdodD1wWzBdLmhlaWdodCksbi5iaW5kVGV4dHVyZShzLG51bGwpLHguX2ltZz1wfHx7d2lkdGg6UCxoZWlnaHQ6Un0seC5kZWxldGU9KCk9Pnt0aGlzLmRlbGV0ZVRleHR1cmUoeCl9LHh9ZGVsZXRlVGV4dHVyZShwKXtjb25zdCBoPXAuX2ltZzt0aGlzLmdsLmRlbGV0ZVRleHR1cmUocCksdHlwZW9mIGguY2xvc2U9PSJmdW5jdGlvbiImJmguY2xvc2UoKX1hc3luYyBsb2FkVGV4dHVyZShwLHt1c2VJbWFnZUJpdG1hcDpoPSEwfT17fSl7Y29uc3QgbT1hd2FpdCB2LmxvYWRJbWFnZShwLHt1c2VJbWFnZUJpdG1hcDpofSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShtKX1jcmVhdGVGQk8oe2NvbG9yOnA9MSxibGVuZDpoPSExLGRlcHRoOm09dGhpcy5vcHRpb25zLmRlcHRoIT09ITEsc3RlbmNpbDpyPSEhdGhpcy5vcHRpb25zLnN0ZW5jaWx9PXt9KXtjb25zdCBpPXRoaXMuZ2wsbj1pLmNyZWF0ZUZyYW1lYnVmZmVyKCk7aS5iaW5kRnJhbWVidWZmZXIoaS5GUkFNRUJVRkZFUixuKTtjb25zdCBzPVtdO2ZvcihsZXQgUj0wO1I8cDtSKyspe2NvbnN0IGI9dGhpcy5jcmVhdGVUZXh0dXJlKCk7aS5mcmFtZWJ1ZmZlclRleHR1cmUyRChpLkZSQU1FQlVGRkVSLGkuQ09MT1JfQVRUQUNITUVOVDArUixpLlRFWFRVUkVfMkQsYiwwKSxzLnB1c2goYil9bi50ZXh0dXJlcz1zLG4udGV4dHVyZT1zWzBdLG4uYmxlbmQ9aDtjb25zdHt3aWR0aDp4LGhlaWdodDpQfT10aGlzLmNhbnZhcztyZXR1cm4gbSYmIXImJihuLmRlcHRoQnVmZmVyPWkuY3JlYXRlUmVuZGVyYnVmZmVyKCksaS5iaW5kUmVuZGVyYnVmZmVyKGkuUkVOREVSQlVGRkVSLG4uZGVwdGhCdWZmZXIpLGkucmVuZGVyYnVmZmVyU3RvcmFnZShpLlJFTkRFUkJVRkZFUixpLkRFUFRIX0NPTVBPTkVOVDE2LHgsUCksaS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihpLkZSQU1FQlVGRkVSLGkuREVQVEhfQVRUQUNITUVOVCxpLlJFTkRFUkJVRkZFUixuLmRlcHRoQnVmZmVyKSksciYmIW0mJihuLnN0ZW5jaWxCdWZmZXI9aS5jcmVhdGVSZW5kZXJidWZmZXIoKSxpLmJpbmRSZW5kZXJidWZmZXIoaS5SRU5ERVJCVUZGRVIsbi5zdGVuY2lsQnVmZmVyKSxpLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoaS5SRU5ERVJCVUZGRVIsaS5TVEVOQ0lMX0lOREVYOCx4LFApLGkuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoaS5GUkFNRUJVRkZFUixpLlNURU5DSUxfQVRUQUNITUVOVCxpLlJFTkRFUkJVRkZFUixuLnN0ZW5jaWxCdWZmZXIpKSxtJiZyJiYobi5kZXB0aFN0ZW5jaWxCdWZmZXI9aS5jcmVhdGVSZW5kZXJidWZmZXIoKSxpLmJpbmRSZW5kZXJidWZmZXIoaS5SRU5ERVJCVUZGRVIsbi5kZXB0aFN0ZW5jaWxCdWZmZXIpLGkucmVuZGVyYnVmZmVyU3RvcmFnZShpLlJFTkRFUkJVRkZFUixpLkRFUFRIX1NURU5DSUwseCxQKSxpLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGkuRlJBTUVCVUZGRVIsaS5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsaS5SRU5ERVJCVUZGRVIsbi5kZXB0aFN0ZW5jaWxCdWZmZXIpKSxpLmJpbmRGcmFtZWJ1ZmZlcihpLkZSQU1FQlVGRkVSLG51bGwpLG59YmluZEZCTyhwPW51bGwpe3RoaXMuZmJvPXB9cmVuZGVyKHtjbGVhckJ1ZmZlcjpwPSEwfT17fSl7dGhpcy5zdGFydFJlbmRlcj0hMDtjb25zdCBoPXRoaXMuZ2w7bGV0IG09dGhpcy5wcm9ncmFtO218fChtPXRoaXMuY3JlYXRlUHJvZ3JhbSgpLHRoaXMudXNlUHJvZ3JhbShtKSksdGhpcy5mYm8mJmguYmluZEZyYW1lYnVmZmVyKGguRlJBTUVCVUZGRVIsdGhpcy5mYm8pO2NvbnN0IHI9dGhpcy5vcHRpb25zLmRlcHRoO3ImJmguZW5hYmxlKGguREVQVEhfVEVTVCksdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVR8KHI/dGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUOjApfCh0aGlzLm9wdGlvbnMuc3RlbmNpbD90aGlzLmdsLlNURU5DSUxfQlVGRkVSX0JJVDowKSk7Y29uc3QgaT10aGlzLl9yZW5kZXJGcmFtZUlEO3RoaXMuX2RyYXcoKSx0aGlzLmZibyYmaC5iaW5kRnJhbWVidWZmZXIoaC5GUkFNRUJVRkZFUixudWxsKSx0aGlzLl9yZW5kZXJGcmFtZUlEPT09aSYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9bnVsbCl9dXBkYXRlKCl7dGhpcy5zdGFydFJlbmRlciYmdGhpcy5fcmVuZGVyRnJhbWVJRD09bnVsbCYmKHRoaXMuX3JlbmRlckZyYW1lSUQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyLmJpbmQodGhpcykpKX19ZCh2LCJkZWZhdWx0T3B0aW9ucyIse3ByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMCxhdXRvVXBkYXRlOiEwLHZlcnRleFBvc2l0aW9uOiJhX3ZlcnRleFBvc2l0aW9uIix2ZXJ0ZXhUZXh0dXJlQ29vcmQ6ImFfdmVydGV4VGV4dHVyZUNvb3JkIix3ZWJnbDI6ITF9KSxkKHYsIlVCWVRFIix2LlVOU0lHTkVEX0JZVEUpLGQodiwiVVNIT1JUIix2LlVOU0lHTkVEX1NIT1JUKSxkKHYsImZldGNoU2hhZGVyIixhLmZldGNoU2hhZGVyKSxkKHYsImxvYWRJbWFnZSIsYS5sb2FkSW1hZ2UpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJzZXR1cFdlYkdMIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImNyZWF0ZVByb2dyYW0iLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQoZSwicG9pbnRzVG9CdWZmZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwibG9hZEltYWdlIixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImZldGNoU2hhZGVyIixmdW5jdGlvbigpe3JldHVybiBPfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEoZixnKXtjb25zdCB2PVsid2ViZ2wiLCJleHBlcmltZW50YWwtd2ViZ2wiLCJ3ZWJraXQtM2QiLCJtb3otd2ViZ2wiXTtsZXQgQz1udWxsO2ZvcihsZXQgcD0wO3A8di5sZW5ndGg7KytwKXt0cnl7Qz1mLmdldENvbnRleHQodltwXSxnKX1jYXRjaHt9aWYoQylicmVha31yZXR1cm4gQ31mdW5jdGlvbiBsKGYsZyl7Y29uc3Qgdj1hKGYsZyk7aWYoIXYpdGhyb3cgbmV3IEVycm9yKCJTb3JyeSwgeW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTC4iKTtyZXR1cm4gdn1mdW5jdGlvbiBNKGYsZyx2KXtjb25zdCBDPWYuY3JlYXRlU2hhZGVyKGYuVkVSVEVYX1NIQURFUik7aWYoZi5zaGFkZXJTb3VyY2UoQyxnKSxmLmNvbXBpbGVTaGFkZXIoQyksIWYuZ2V0U2hhZGVyUGFyYW1ldGVyKEMsZi5DT01QSUxFX1NUQVRVUykpe2NvbnN0IG09YFZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zi5nZXRTaGFkZXJJbmZvTG9nKEMpfWA7dGhyb3cgbmV3IEVycm9yKG0pfWNvbnN0IHA9Zi5jcmVhdGVTaGFkZXIoZi5GUkFHTUVOVF9TSEFERVIpO2lmKGYuc2hhZGVyU291cmNlKHAsdiksZi5jb21waWxlU2hhZGVyKHApLCFmLmdldFNoYWRlclBhcmFtZXRlcihwLGYuQ09NUElMRV9TVEFUVVMpKXtjb25zdCBtPWBGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGUuICBUaGUgZXJyb3IgbG9nIGlzOiR7Zi5nZXRTaGFkZXJJbmZvTG9nKHApfWA7dGhyb3cgbmV3IEVycm9yKG0pfWNvbnN0IGg9Zi5jcmVhdGVQcm9ncmFtKCk7aWYoZi5hdHRhY2hTaGFkZXIoaCxDKSxmLmF0dGFjaFNoYWRlcihoLHApLGYubGlua1Byb2dyYW0oaCksIWYuZ2V0UHJvZ3JhbVBhcmFtZXRlcihoLGYuTElOS19TVEFUVVMpKXtjb25zdCBtPWBTaGFkZXIgcHJvZ3JhbSBmYWlsZWQgdG8gbGluay4gIFRoZSBlcnJvciBsb2cgaXM6JHtmLmdldFByb2dyYW1JbmZvTG9nKGgpfWA7dGhyb3cgbmV3IEVycm9yKG0pfXJldHVybiBmLmRlbGV0ZVNoYWRlcihDKSxmLmRlbGV0ZVNoYWRlcihwKSxofWZ1bmN0aW9uIFQoZixnPUZsb2F0MzJBcnJheSx2PW51bGwpe2lmKHYmJiEodiBpbnN0YW5jZW9mIGcpKXRocm93IG5ldyBUeXBlRXJyb3IoIldyb25nIGJ1ZmZlciB0eXBlLiIpO2lmKGY9PW51bGx8fGYgaW5zdGFuY2VvZiBnKXJldHVybiBmO2lmKGZbMF09PW51bGx8fGZbMF0ubGVuZ3RoPT1udWxsKXJldHVybiB2Pyh2LnNldChmLDApLHYpOm5ldyBnKGYpO2NvbnN0IEM9ZlswXS5sZW5ndGgscD1mLmxlbmd0aDt2fHwodj1uZXcgZyhDKnApKTtsZXQgaD0wO2ZvcihsZXQgbT0wO208cDttKyspZm9yKGxldCByPTA7cjxDO3IrKyl2W2grK109ZlttXVtyXTtyZXR1cm4gdn1jb25zdCBkPXt9O2Z1bmN0aW9uIHUoZix7dXNlSW1hZ2VCaXRtYXA6Zz0hMCxhbGlhczp2PW51bGx9PXt9KXtpZighZFtmXSl7aWYodHlwZW9mIEltYWdlPT0iZnVuY3Rpb24iKXtjb25zdCBDPW5ldyBJbWFnZTt0eXBlb2YgZj09InN0cmluZyImJiEodHlwZW9mIGxvY2F0aW9uPT0ib2JqZWN0IiYmL15maWxlOi8udGVzdChsb2NhdGlvbi5ocmVmKSkmJiEvXmRhdGE6Ly50ZXN0KGYpJiYoQy5jcm9zc09yaWdpbj0iYW5vbnltb3VzIiksZFtmXT1uZXcgUHJvbWlzZShwPT57Qy5vbmxvYWQ9ZnVuY3Rpb24oKXtnJiZ0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXA9PSJmdW5jdGlvbiI/Y3JlYXRlSW1hZ2VCaXRtYXAoQyx7aW1hZ2VPcmllbnRhdGlvbjoiZmxpcFkifSkudGhlbihoPT57ZFtmXT1oLHYmJihkW3ZdPWgpLHAoaCl9KTooZFtmXT1DLHYmJihkW3ZdPUMpLHAoQykpfSxDLnNyYz1mfSksdiYmKGRbdl09ZFtmXSl9ZWxzZSBpZih0eXBlb2YgZmV0Y2g9PSJmdW5jdGlvbiIpcmV0dXJuIGZldGNoKGYse21ldGhvZDoiR0VUIixtb2RlOiJjb3JzIixjYWNoZToiZGVmYXVsdCJ9KS50aGVuKEM9PkMuYmxvYigpKS50aGVuKEM9PmNyZWF0ZUltYWdlQml0bWFwKEMse2ltYWdlT3JpZW50YXRpb246ImZsaXBZIn0pLnRoZW4ocD0+KGRbZl09cCx2JiYoZFt2XT1wKSxwKSkpfXJldHVybiBkW2ZdfWNvbnN0IGM9e307YXN5bmMgZnVuY3Rpb24gTyhmKXtpZihjW2ZdKXJldHVybiBjW2ZdO2NvbnN0IGc9YXdhaXQgZmV0Y2goZik7aWYoZy5zdGF0dXM+PTIwMCYmZy5zdGF0dXM8MzAwKXtjb25zdCB2PWF3YWl0IGcudGV4dCgpO3JldHVybiBjW2ZdPXYsdn10aHJvdyBuZXcgRXJyb3IoIlNoYWRlciBsb2FkZWQgZXJyb3IuIil9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfdmVydGV4UG9zaXRpb24sIDEpOwp9YH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YCNpZmRlZiBHTF9FUwpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjEpOwp9YH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSxlLmRlZmF1bHQ9YGF0dHJpYnV0ZSB2ZWM0IGFfdmVydGV4UG9zaXRpb247CmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CiAgZ2xfUG9zaXRpb24gPSBhX3ZlcnRleFBvc2l0aW9uOwogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKfWB9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KTt2YXIgYT10KDIxKSxsPXQoMjUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBNPVN5bWJvbCgidHJhbnNmb3JtIik7Y2xhc3MgVHtjb25zdHJ1Y3Rvcih1LGMpe3RoaXMuY29udGV4dD11LmdldENvbnRleHQoIjJkIiksdGhpcy5vcHRpb25zPWMsdGhpc1tNXT1bMSwwLDAsMSwwLDBdfWNyZWF0ZVRleHR1cmUodSl7cmV0dXJue19pbWc6dX19YXN5bmMgbG9hZFRleHR1cmUodSl7Y29uc3QgYz1hd2FpdCBhLmRlZmF1bHQubG9hZEltYWdlKHUse3VzZUltYWdlQml0bWFwOiExfSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZShjKX1kZWxldGVUZXh0dXJlKHUpe3JldHVybiB1fWNsZWFyKHUsYyxPLGYpe2NvbnN0IGc9dGhpcy5jb250ZXh0O3U9dXx8MCxjPWN8fDAsTz1PfHxnLmNhbnZhcy53aWR0aC11LGY9Znx8Zy5jYW52YXMuaGVpZ2h0LWMsZy5jbGVhclJlY3QodSxjLE8sZil9ZHJhd01lc2hDbG91ZCh1LHtjbGVhcjpjPSExfT17fSl7Y29uc3QgTz1bXTtmb3IobGV0IGY9MDtmPHUuYW1vdW50O2YrKyl7Y29uc3QgZz11LmdldFRyYW5zZm9ybShmKTtsZXQgdj11LmdldFRleHR1cmVGcmFtZShmKTt2JiYodj12Ll9pbWcpO2NvbnN0IEM9dS5nZXRGaWx0ZXIoZikse2ZpbGw6cCxzdHJva2U6aH09dS5nZXRDbG91ZFJHQkEoZik7Ty5wdXNoKHttZXNoOnUubWVzaCxfY2xvdWRPcHRpb25zOltwLGgsdixnLENdfSl9dS5iZWZvcmVSZW5kZXImJnUuYmVmb3JlUmVuZGVyKHRoaXMuY29udGV4dCx1KSx0aGlzLmRyYXdNZXNoZXMoTyx7Y2xlYXI6Yyxob29rOiExfSksdS5hZnRlclJlbmRlciYmdS5hZnRlclJlbmRlcih0aGlzLmNvbnRleHQsdSl9ZHJhd01lc2hlcyh1LHtjbGVhcjpjPSExLGhvb2s6Tz0hMH09e30pe2NvbnN0IGY9dGhpcy5jb250ZXh0O2MmJmYuY2xlYXJSZWN0KDAsMCxmLmNhbnZhcy53aWR0aCxmLmNhbnZhcy5oZWlnaHQpO2xldCBnPW51bGw7Y29uc3R7d2lkdGg6dixoZWlnaHQ6Q309Zi5jYW52YXMscD11Lmxlbmd0aDt1LmZvckVhY2goKGgsbSk9PntsZXQgcixpLG4scyx4O08mJmguYmVmb3JlUmVuZGVyJiZoLmJlZm9yZVJlbmRlcihmLGgpLGguX2Nsb3VkT3B0aW9ucyYmKFtyLGksbixzLHhdPWguX2Nsb3VkT3B0aW9ucyxoPWgubWVzaCk7bGV0IFA9aC5maWx0ZXI7aWYoeCYmKFA9UD9gJHtQfSAke3h9YDp4KSxQJiYhdGhpcy5maWx0ZXJCdWZmZXImJnRoaXMuZmlsdGVyQnVmZmVyIT09ITEpe2NvbnN0IFI9YS5kZWZhdWx0LmNyZWF0ZUNhbnZhcyh2LEMpO1I/dGhpcy5maWx0ZXJCdWZmZXI9Ui5nZXRDb250ZXh0KCIyZCIpOnRoaXMuZmlsdGVyQnVmZmVyPSExfWcmJmchPT1QJiYoT2JqZWN0KGwuYXBwbHlGaWx0ZXIpKHRoaXMuZmlsdGVyQnVmZmVyLGcpLGYuZHJhd0ltYWdlKHRoaXMuZmlsdGVyQnVmZmVyLmNhbnZhcywwLDAsdixDKSx0aGlzLmZpbHRlckJ1ZmZlci5jbGVhclJlY3QoMCwwLHYsQyksZz1udWxsKSxQJiZ0aGlzLmZpbHRlckJ1ZmZlcj8odGhpcy5maWx0ZXJCdWZmZXIuc2F2ZSgpLHRoaXMuZmlsdGVyQnVmZmVyLnRyYW5zZm9ybSguLi50aGlzW01dKSxPYmplY3QobC5kcmF3TWVzaDJEKShoLHRoaXMuZmlsdGVyQnVmZmVyLCExLHIsaSxuLHMpLHRoaXMuZmlsdGVyQnVmZmVyLnJlc3RvcmUoKSxtPT09cC0xPyhPYmplY3QobC5hcHBseUZpbHRlcikodGhpcy5maWx0ZXJCdWZmZXIsUCksZi5kcmF3SW1hZ2UodGhpcy5maWx0ZXJCdWZmZXIuY2FudmFzLDAsMCx2LEMpLHRoaXMuZmlsdGVyQnVmZmVyLmNsZWFyUmVjdCgwLDAsdixDKSk6Zz1QKTooZi5zYXZlKCksZi50cmFuc2Zvcm0oLi4udGhpc1tNXSksT2JqZWN0KGwuZHJhd01lc2gyRCkoaCxmLCExLHIsaSxuLHMpLGYucmVzdG9yZSgpKSxPJiZoLmFmdGVyUmVuZGVyJiZoLmFmdGVyUmVuZGVyKGYsaCl9KX1zZXRUcmFuc2Zvcm0odSl7dGhpc1tNXT11fX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksKGZ1bmN0aW9uKGEpe3ZhciBsPXQoMTQpLE09dCgyMyksVD10KDI0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD17fTtmdW5jdGlvbiB1KHYsQyl7Y29uc3R7c3R5bGU6cCx2YXJpYW50Omgsd2VpZ2h0Om0sc3RyZXRjaDpyLHNpemU6aSxweExpbmVIZWlnaHQ6bixmYW1pbHk6c309djtyZXR1cm4gcj09PSJub3JtYWwiP2Ake3B9ICR7aH0gJHttfSAke2kqQ31weC8ke24qQ31weCAke3N9YDpgJHtwfSAke2h9ICR7bX0gJHtyfSAke2kqQ31weC8ke24qQ31weCAke3N9YH1mdW5jdGlvbiBjKHYse2ZvbnQ6QyxmaWxsQ29sb3I6cCxzdHJva2VDb2xvcjpoLHN0cm9rZVdpZHRoOm0scmF0aW86cj0xLHRleHRDYW52YXM6aSxjYWNoYWJsZTpuPSExfSl7bGV0IHM7aWYobil7cz1bdixDLFN0cmluZyhwKSxTdHJpbmcoaCksU3RyaW5nKG0pXS5qb2luKCIjIyMiKTtjb25zdCBLPWRbc107aWYoSylyZXR1cm4gS31pfHwoaT1mKDEsMSkpO2NvbnN0IHg9aS5nZXRDb250ZXh0KCIyZCIpO3guc2F2ZSgpLHguZm9udD1DO2xldHt3aWR0aDpQfT14Lm1lYXN1cmVUZXh0KHYpO3gucmVzdG9yZSgpO2NvbnN0IFI9T2JqZWN0KE0uZGVmYXVsdCkoQyksYj1NYXRoLm1heChSLnB4TGluZUhlaWdodCxSLnB4SGVpZ2h0KjEuMTMpOy9pdGFsaWN8b2JsaXF1ZS8udGVzdChDKSYmKFArPWIqTWF0aC50YW4oMTUqTWF0aC5QSS8xODApKSwhcCYmIWgmJihwPSIjMDAwIik7Y29uc3QgRT14LmNhbnZhcyxEPU1hdGguY2VpbChQKSxJPU1hdGguY2VpbChiKTtFLndpZHRoPU1hdGgucm91bmQoRCpyKSxFLmhlaWdodD1NYXRoLnJvdW5kKEkqcikseC5zYXZlKCkseC5mb250PXUoUixyKSx4LnRleHRBbGlnbj0iY2VudGVyIix4LnRleHRCYXNlbGluZT0ibWlkZGxlIjtjb25zdCBTPUUuaGVpZ2h0Ki41K1IucHhIZWlnaHQqLjA1KnIsQT1FLndpZHRoKi41O2lmKHApe2lmKEFycmF5LmlzQXJyYXkocCkpcD1PYmplY3QoVC5kZWZhdWx0KShwKTtlbHNlIGlmKHAudmVjdG9yKXtsZXQgSztjb25zdHt2ZWN0b3I6Vixjb2xvcnM6Sn09cDtWLmxlbmd0aD09PTY/Sz14LmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLlYpOks9eC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5WKSxKLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpXfSk9PntLLmFkZENvbG9yU3RvcChxLFcpfSkscD1LfXguZmlsbFN0eWxlPXAseC5maWxsVGV4dCh2LEEsUyl9aWYoaCl7aWYoeC5saW5lV2lkdGg9bSpyLEFycmF5LmlzQXJyYXkoaCkpaD1PYmplY3QoVC5kZWZhdWx0KShoKTtlbHNlIGlmKGgudmVjdG9yKXtsZXQgSztjb25zdHt2ZWN0b3I6Vixjb2xvcnM6Sn09aDtWLmxlbmd0aD09PTY/Sz14LmNyZWF0ZVJhZGlhbEdyYWRpZW50KC4uLlYpOks9eC5jcmVhdGVMaW5lYXJHcmFkaWVudCguLi5WKSxKLmZvckVhY2goKHtvZmZzZXQ6cSxjb2xvcjpXfSk9PntLLmFkZENvbG9yU3RvcChxLFcpfSksaD1LfXguc3Ryb2tlU3R5bGU9aCx4LnN0cm9rZVRleHQodixBLFMpfXgucmVzdG9yZSgpO2NvbnN0IFU9e2ltYWdlOmkscmVjdDpbMCwwLEQsSV19O3JldHVybiBuJiYoZFtzXT1VKSxVfWxldCBPPSExO2lmKHR5cGVvZiBuYXZpZ2F0b3I9PSJvYmplY3QiJiZ0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudD09InN0cmluZyIpe2NvbnN0IHY9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9jaHJvbWVcLyhcZCspLyk7diYmKE89TnVtYmVyKHZbMV0pPDcwKX1mdW5jdGlvbiBmKHYsQyxwPXt9KXtjb25zdCBoPXAub2Zmc2NyZWVufHwhTyYmcC5vZmZzY3JlZW4hPT0hMTtsZXQgbTtyZXR1cm4gdHlwZW9mIGE8InUiJiZ0eXBlb2YgYS5jcmVhdGVDYW52YXM9PSJmdW5jdGlvbiI/bT1hLmNyZWF0ZUNhbnZhcyh2LEMscCk6aCYmdHlwZW9mIE9mZnNjcmVlbkNhbnZhcz09ImZ1bmN0aW9uIj9tPW5ldyBPZmZzY3JlZW5DYW52YXModixDKToobT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxtLndpZHRoPXYsbS5oZWlnaHQ9QyksbX1jb25zdCBnPXtjcmVhdGVDYW52YXM6ZixjcmVhdGVUZXh0OmMsbG9hZEltYWdlOmwuZGVmYXVsdC5sb2FkSW1hZ2V9O2UuZGVmYXVsdD1nfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oTCxlKXt2YXIgdDt0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3Q9dHx8bmV3IEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCl9Y2F0Y2h7dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJih0PXdpbmRvdyl9TC5leHBvcnRzPXR9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShoLG0pe2lmKHR5cGVvZiBoPT0ic3RyaW5nIil7Y29uc3Qgbj1oLnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbnwlKSQvKTtuP2g9e3NpemU6cGFyc2VGbG9hdChuWzFdKSx1bml0Om5bMl19Omg9e3NpemU6cGFyc2VJbnQoaCwxMCksdW5pdDoicHgifX1sZXR7c2l6ZTpyLHVuaXQ6aX09aDtpZihpPT09InB0IilyLz0uNzU7ZWxzZSBpZihpPT09InBjIilyKj0xNjtlbHNlIGlmKGk9PT0iaW4iKXIqPTk2O2Vsc2UgaWYoaT09PSJjbSIpcio9OTYvMi41NDtlbHNlIGlmKGk9PT0ibW0iKXIqPTk2LzI1LjQ7ZWxzZSBpZihpPT09ImVtInx8aT09PSJyZW0ifHxpPT09ImV4Iil7aWYoIW0mJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBuPWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTttPWEobiwxNil9cio9bSxpPT09ImV4IiYmKHIvPTIpfWVsc2UgaWYoaT09PSJxIilyKj05Ni8yNS40LzQ7ZWxzZSBpZihpPT09InZ3Inx8aT09PSJ2aCIpe2lmKHR5cGVvZiBkb2N1bWVudDwidSIpe2NvbnN0IG49aT09PSJ2dyI/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7cio9bi8xMDB9fWVsc2UgaWYoKGk9PT0idm1heCJ8fGk9PT0idm1pbiIpJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCBuPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxzPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7aT09PSJ2bWF4Ij9yKj1NYXRoLm1heChuLHMpLzEwMDpyKj1NYXRoLm1pbihuLHMpLzEwMH1yZXR1cm4gcn1jb25zdCBsPSJib2xkfGJvbGRlcnxsaWdodGVyfFsxLTldMDAiLE09Iml0YWxpY3xvYmxpcXVlIixUPSJzbWFsbC1jYXBzIixkPSJ1bHRyYS1jb25kZW5zZWR8ZXh0cmEtY29uZGVuc2VkfGNvbmRlbnNlZHxzZW1pLWNvbmRlbnNlZHxzZW1pLWV4cGFuZGVkfGV4cGFuZGVkfGV4dHJhLWV4cGFuZGVkfHVsdHJhLWV4cGFuZGVkIix1PSJweHxwdHxwY3xpbnxjbXxtbXxlbXxleHxyZW18cXx2d3x2aHx2bWF4fHZtaW58JSIsYz1gJyhbXiddKyknfCIoW14iXSspInwoW1xcdy1dfFvkuIAt6b6lXSkrYCxPPW5ldyBSZWdFeHAoYCgke2x9KSArYCwiaSIpLGY9bmV3IFJlZ0V4cChgKCR7TX0pICtgLCJpIiksZz1uZXcgUmVnRXhwKGAoJHtUfSkgK2AsImkiKSx2PW5ldyBSZWdFeHAoYCgke2R9KSArYCwiaSIpLEM9bmV3IFJlZ0V4cCgiKFtcXGRcXC5dKykoIit1KyIpKD86XFwvKFtcXGRcXC5dKykoIit1KyIpKT8gKigoPzoiK2MrIikoICosICooPzoiK2MrIikpKikiKTtmdW5jdGlvbiBwKGgsbSl7Y29uc3Qgcj1DLmV4ZWMoaCk7aWYoIXIpcmV0dXJuO2NvbnN0IGk9cGFyc2VGbG9hdChyWzNdKSxuPXt3ZWlnaHQ6Im5vcm1hbCIsc3R5bGU6Im5vcm1hbCIsc3RyZXRjaDoibm9ybWFsIix2YXJpYW50OiJub3JtYWwiLHNpemU6cGFyc2VGbG9hdChyWzFdKSx1bml0OnJbMl0sbGluZUhlaWdodDpOdW1iZXIuaXNGaW5pdGUoaSk/aTp2b2lkIDAsbGluZUhlaWdodFVuaXQ6cls0XSxmYW1pbHk6cls1XS5yZXBsYWNlKC8gKiwgKi9nLCIsIil9LHM9aC5zdWJzdHJpbmcoMCxyLmluZGV4KSx4PU8uZXhlYyhzKSxQPWYuZXhlYyhzKSxSPWcuZXhlYyhzKSxiPXYuZXhlYyhzKTtyZXR1cm4geCYmKG4ud2VpZ2h0PXhbMV0pLFAmJihuLnN0eWxlPVBbMV0pLFImJihuLnZhcmlhbnQ9UlsxXSksYiYmKG4uc3RyZXRjaD1iWzFdKSxuLnB4SGVpZ2h0PWEoe3NpemU6bi5zaXplLHVuaXQ6bi51bml0fSxtKSxuLnB4TGluZUhlaWdodD1hKHtzaXplOm4ubGluZUhlaWdodHx8bi5zaXplLHVuaXQ6bi5saW5lSGVpZ2h0VW5pdHx8bi51bml0fSxtKSxufX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKGwpe3JldHVybmByZ2JhKCR7bC5tYXAoKE0sVCk9PlQ8Mz9NYXRoLnJvdW5kKE0qMjU1KTpNKS5qb2luKCl9KWB9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJhcHBseUZpbHRlciIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJkcmF3TWVzaDJEIixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCgxKSxsPXQoMjQpLE09dCgyMyksVD10KDI2KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZChPLGYpe2NvbnN0IGc9Ty5jYW52YXM7Ty5zYXZlKCksTy5maWx0ZXI9ZixPLmRyYXdJbWFnZShnLDAsMCxnLndpZHRoLGcuaGVpZ2h0KSxPLnJlc3RvcmUoKX1mdW5jdGlvbiB1KE8sZil7Y29uc3QgZz0vcmdiYVwoKFxkKyksKFxkKyksKFxkKyksKFxkKylcKS87Tz1PLm1hdGNoKGcpLnNsaWNlKDEsNSkubWFwKE51bWJlciksZj1mLm1hdGNoKGcpLnNsaWNlKDEsNSkubWFwKE51bWJlcik7Y29uc3Qgdj1bXSxDPWZbM107Zm9yKGxldCBwPTA7cDw0O3ArKyl2W3BdPU9iamVjdChULm1peCkoT1twXSxmW3BdLEMpO3JldHVybmByZ2JhKCR7di5qb2luKCl9KWB9ZnVuY3Rpb24gYyhPLGYsZz0hMCx2PW51bGwsQz1udWxsLHA9bnVsbCxoPW51bGwpe2Yuc2F2ZSgpO2xldCBtPSExLHI9ITE7aWYoZi5nbG9iYWxBbHBoYT1PLmdldE9wYWNpdHkoKSxPLl91cGRhdGVNYXRyaXgmJk8udHJhbnNmb3JtU2NhbGUvTy5jb250b3Vycy5zY2FsZT4xLjUmJk8uYWNjdXJhdGUoTy50cmFuc2Zvcm1TY2FsZSksTy5saW5lV2lkdGgpe2xldCBzPU8uZ3JhZGllbnQmJk8uZ3JhZGllbnQuc3Ryb2tlO2lmKHMpe2NvbnN0e3ZlY3Rvcjp4LGNvbG9yczpQfT1zO2lmKHgubGVuZ3RoPT09NilzPWYuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4ueCk7ZWxzZSBpZih4Lmxlbmd0aD09PTQpcz1mLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLngpO2Vsc2UgaWYoeC5sZW5ndGg9PT0zKXM9Zi5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLngpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO1AuZm9yRWFjaCgoe29mZnNldDpSLGNvbG9yOmJ9KT0+e2xldCBFPU9iamVjdChsLmRlZmF1bHQpKGIpO0MmJihFPXUoRSxDKSkscy5hZGRDb2xvclN0b3AoUixFKX0pLGYuc3Ryb2tlU3R5bGU9cyxtPSEwfWVsc2UgTy5zdHJva2VTdHlsZSYmKEM/Zi5zdHJva2VTdHlsZT11KE8uc3Ryb2tlU3R5bGUsQyk6Zi5zdHJva2VTdHlsZT1PLnN0cm9rZVN0eWxlLG09ITApfW0mJihmLmxpbmVXaWR0aD1PLmxpbmVXaWR0aCxmLmxpbmVKb2luPU8ubGluZUpvaW4sZi5saW5lQ2FwPU8ubGluZUNhcCxmLm1pdGVyTGltaXQ9Ty5taXRlckxpbWl0LE8ubGluZURhc2gmJihmLnNldExpbmVEYXNoKE8ubGluZURhc2gpLE8ubGluZURhc2hPZmZzZXQmJihmLmxpbmVEYXNoT2Zmc2V0PU8ubGluZURhc2hPZmZzZXQpKSk7bGV0IGk9Ty5ncmFkaWVudCYmTy5ncmFkaWVudC5maWxsO2lmKGkpe2NvbnN0e3ZlY3RvcjpzLGNvbG9yczp4fT1pO2lmKHMubGVuZ3RoPT09NilpPWYuY3JlYXRlUmFkaWFsR3JhZGllbnQoLi4ucyk7ZWxzZSBpZihzLmxlbmd0aD09PTQpaT1mLmNyZWF0ZUxpbmVhckdyYWRpZW50KC4uLnMpO2Vsc2UgaWYocy5sZW5ndGg9PT0zKWk9Zi5jcmVhdGVDaXJjdWxhckdyYWRpZW50KC4uLnMpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB2ZWN0b3IgZGltZW5zaW9uLiIpO3guZm9yRWFjaCgoe29mZnNldDpQLGNvbG9yOlJ9KT0+e2xldCBiPU9iamVjdChsLmRlZmF1bHQpKFIpO0MmJihiPXUoYixDKSksaS5hZGRDb2xvclN0b3AoUCxiKX0pLGYuZmlsbFN0eWxlPWkscj0hMH1lbHNlIE8uZmlsbFN0eWxlJiYodj9mLmZpbGxTdHlsZT11KE8uZmlsbFN0eWxlLHYpOmYuZmlsbFN0eWxlPU8uZmlsbFN0eWxlLHI9ITApO2lmKGgmJmYudHJhbnNmb3JtKC4uLmgpLGYudHJhbnNmb3JtKC4uLk8udHJhbnNmb3JtTWF0cml4KSxPLmNsaXBQYXRoKXtjb25zdCBzPU8uY2xpcFBhdGgseD1uZXcgUGF0aDJEKHMpO2YuY2xpcCh4KX1jb25zdCBuPU8uY29udG91cnMubGVuZ3RoO2lmKE8uY29udG91cnMuZm9yRWFjaCgocyx4KT0+e2NvbnN0IFA9cy5sZW5ndGgsUj1QPjEmJmEudmVjMi5lcXVhbHMoc1swXSxzW1AtMV0pLGI9eD09PW4tMSYmTy50ZXh0dXJlO2lmKHMmJlA+MCl7aWYocnx8bXx8Yil7Zi5iZWdpblBhdGgoKSxmLm1vdmVUbyguLi5zWzBdKTtmb3IobGV0IEU9MTtFPFA7RSsrKUU9PT1QLTEmJlI/Zi5jbG9zZVBhdGgoKTpmLmxpbmVUbyguLi5zW0VdKX1pZihyJiZmLmZpbGwoTy5maWxsUnVsZSksYil7Zi5zYXZlKCksZi5jbGlwKCk7bGV0e2ltYWdlOkUsb3B0aW9uczpEfT1PLnRleHR1cmU7aWYocCYmKEU9cCksRC5yZXBlYXQmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIGltYWdlIHJlcGVhdCB5ZXQuIiksRS5mb250KXtELnNjYWxlJiZjb25zb2xlLndhcm4oIkNvbnRleHQgMkQgbm90IHN1cHBvcnRlZCB0ZXh0IHNjYWxlIHlldC4iKSxELnNyY1JlY3QmJmNvbnNvbGUud2FybigiQ29udGV4dCAyRCBub3Qgc3VwcG9ydGVkIHRleHQgc3JjUmVjdCB5ZXQuIik7bGV0e2ZvbnQ6SSxmaWxsQ29sb3I6UyxzdHJva2VDb2xvcjpBLHN0cm9rZVdpZHRoOlUsdGV4dDpLfT1FOyFTJiYhQSYmKFM9IiMwMDAiKSxBcnJheS5pc0FycmF5KFMpJiYoUz1PYmplY3QobC5kZWZhdWx0KShTKSksQXJyYXkuaXNBcnJheShBKSYmKEE9T2JqZWN0KGwuZGVmYXVsdCkoQSkpLGYuZm9udD1JO2NvbnN0e3dpZHRoOlZ9PWYubWVhc3VyZVRleHQoSyksSj1PYmplY3QoTS5kZWZhdWx0KShJKSxxPU1hdGgubWF4KEoucHhMaW5lSGVpZ2h0LEoucHhIZWlnaHQqMS4xMyk7Zi50ZXh0QWxpZ249ImNlbnRlciIsZi50ZXh0QmFzZWxpbmU9Im1pZGRsZSI7Y29uc3QgVz1ELnJlY3QsSD1XWzBdK3EqLjUrSi5weEhlaWdodCouMDYsWj1XWzFdK1YqLjU7V1syXSE9bnVsbCYmZi5zY2FsZShXWzJdL1YsV1szXS9xKSxTJiYoZi5maWxsU3R5bGU9UyxmLmZpbGxUZXh0KEssWixIKSksQSYmKGYubGluZVdpZHRoPVUsZi5zdHJva2VTdHlsZT1BLGYuc3Ryb2tlVGV4dChLLFosSCkpfWVsc2V7bGV0IEk9RC5yZWN0O2NvbnN0IFM9RC5zcmNSZWN0O0Quc2NhbGUmJihJPVswLDAsZi5jYW52YXMud2lkdGgsZi5jYW52YXMuaGVpZ2h0XSksRC5yb3RhdGVkJiZJJiYoST1bLUlbMV0sSVswXSxJWzNdLElbMl1dKSxTJiYoST1JfHxbMCwwLFNbMl0sU1szXV0pLEQucm90YXRlZCYmKGYudHJhbnNsYXRlKDAsST9JWzJdOkUud2lkdGgpLGYucm90YXRlKC0uNSpNYXRoLlBJKSksUz9mLmRyYXdJbWFnZShFLC4uLlMsLi4uSSk6ST9mLmRyYXdJbWFnZShFLC4uLkkpOmYuZHJhd0ltYWdlKEUsMCwwKX1mLnJlc3RvcmUoKX1tJiZmLnN0cm9rZSgpfX0pLGYucmVzdG9yZSgpLGcpe2NvbnN0IHM9Ty5maWx0ZXI7cyYmZChmLHMpfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNsYW1wIixmdW5jdGlvbigpe3JldHVybiBhfSksdC5kKGUsIm1peCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJ0cmFuc2Zvcm1Qb2ludCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKFQsZCx1KXtyZXR1cm4gZD51JiYoW2QsdV09W3UsZF0pLFQ8ZD9kOlQ+dT91OlR9ZnVuY3Rpb24gbChULGQsdSl7cmV0dXJuIFQqKDEtdSkrZCp1fWZ1bmN0aW9uIE0oVCxkKXtjb25zdFt1LGNdPVQ7cmV0dXJuW3UqZFswXStjKmRbMl0rZFs0XSx1KmRbMV0rYypkWzNdK2RbNV1dfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pO3ZhciBhPXQoMjgpLGw9dCgyOSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIE0oYyxPLGYpe2NvbnN0IGc9Yy51bmlmb3Jtc3x8e30sdj1PLnVuaWZvcm1zfHx7fTtpZihnLnVfdGV4U2FtcGxlciYmdi51X3RleFNhbXBsZXImJmcudV90ZXhTYW1wbGVyIT09di51X3RleFNhbXBsZXIpcmV0dXJuITE7Y29uc3QgQz1PYmplY3Qua2V5cyhnKSxwPU9iamVjdC5rZXlzKHYpLGg9Qy5pbmRleE9mKCJ1X3RleFNhbXBsZXIiKSxtPXAuaW5kZXhPZigidV90ZXhTYW1wbGVyIik7aWYoaD49MCYmQy5zcGxpY2UoaCwxKSxtPj0wJiZwLnNwbGljZShtLDEpLEMubGVuZ3RoIT09cC5sZW5ndGgpcmV0dXJuITE7Y29uc3Qgcj1DLmV2ZXJ5KGk9Pntjb25zdCBuPWdbaV0scz12W2ldO2lmKG49PT1zKXJldHVybiEwO2lmKG4ubGVuZ3RoJiZzLmxlbmd0aCYmbi5sZW5ndGg9PT1zLmxlbmd0aCl7Zm9yKGxldCB4PTA7eDxuLmxlbmd0aDt4KyspaWYoblt4XSE9PXNbeF0pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9KTtpZihyKXtpZihnLnVfdGV4U2FtcGxlciYmIXYudV90ZXhTYW1wbGVyKU8uc2V0VGV4dHVyZShnLnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSk7ZWxzZSBpZighZy51X3RleFNhbXBsZXImJnYudV90ZXhTYW1wbGVyKWZvcihsZXQgaT0wO2k8Zi5sZW5ndGg7aSsrKWZbaV0uc2V0VGV4dHVyZSh2LnVfdGV4U2FtcGxlcix7aGlkZGVuOiEwfSl9cmV0dXJuIHJ9Y29uc3QgVD17fTtmdW5jdGlvbiBkKGMsTyl7aWYoYy5sZW5ndGgpe2NvbnN0IGY9T2JqZWN0KGEuZGVmYXVsdCkoYyxUKTtyZXR1cm4gZi5lbmFibGVCbGVuZD1PLGNbMF0uZmlsdGVyQ2FudmFzJiYoZi5maWx0ZXJDYW52YXM9ITApLGYucGFja0luZGV4PWNbMF0ucGFja0luZGV4LGYucGFja0xlbmd0aD1jLmxlbmd0aCxmLmJlZm9yZVJlbmRlcj1jWzBdLmJlZm9yZVJlbmRlcixmLnBhc3M9Y1swXS5wYXNzLGYuYWZ0ZXJSZW5kZXI9Y1tjLmxlbmd0aC0xXS5hZnRlclJlbmRlcixjLmxlbmd0aD0wLGZ9fWZ1bmN0aW9uKnUoYyxPLGY9ITEpe2NvbnN0IGc9W10sdj1jLm9wdGlvbnMuYnVmZmVyU2l6ZTtsZXQgQz0wLHA9ITE7Zm9yKGxldCBoPTA7aDxPLmxlbmd0aDtoKyspe2NvbnN0IG09T1toXTtpZihtIGluc3RhbmNlb2YgbC5kZWZhdWx0KWcubGVuZ3RoJiYoeWllbGQgZChnLHApKSxDPTAscD0hMSx5aWVsZCBtO2Vsc2V7Y29uc3Qgcj1tLm1lc2hEYXRhO2lmKHIuY2xpcFBhdGgmJiFyLnVuaWZvcm1zLnVfY2xpcFNhbXBsZXIpe2NvbnN0IG49Yy5jcmVhdGVUZXh0dXJlKHIuY2xpcFBhdGgpO3IudW5pZm9ybXMudV9jbGlwU2FtcGxlcj1ufWxldCBpPTA7aWYoKCFmfHwhbS5jYW5JZ25vcmUoKSkmJnImJnIucG9zaXRpb25zLmxlbmd0aCl7bS5wYWNrSW5kZXg9aDtjb25zdCBuPW0uZmlsdGVyQ2FudmFzO2lmKGk9ci5wb3NpdGlvbnMubGVuZ3RoLG58fEMraT52KWcubGVuZ3RoJiYoeWllbGQgZChnLHApKSxDPTAscD0hMTtlbHNlIGlmKEMpe2NvbnN0IHM9Z1tnLmxlbmd0aC0xXTtzJiYocy5maWx0ZXJDYW52YXN8fHMuYWZ0ZXJSZW5kZXJ8fG0uYmVmb3JlUmVuZGVyfHxzLnBhc3MubGVuZ3RofHxtLnBhc3MubGVuZ3RofHxzLnByb2dyYW0hPT1tLnByb2dyYW18fCFNKHMsbSxnKSkmJih5aWVsZCBkKGcscCksQz0wLHA9ITEpfWcucHVzaChtKSxwPXB8fG0uZW5hYmxlQmxlbmQsQys9aX1oPT09Ty5sZW5ndGgtMSYmZy5sZW5ndGgmJih5aWVsZCBkKGcscCkpfX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBNfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGE9e1VOU0lHTkVEX0JZVEU6VWludDhBcnJheSxVTlNJR05FRF9TSE9SVDpVaW50MTZBcnJheSxCWVRFOkludDhBcnJheSxTSE9SVDpJbnQxNkFycmF5LEZMT0FUOkZsb2F0MzJBcnJheX07ZnVuY3Rpb24gbChULGQpe2xldCB1PTAsYz0wLE89MCxmPTAsZz0wLHY9MCxDPTA7Y29uc3QgcD1UWzBdLnByb2dyYW07Zm9yKGxldCBoPTA7aDxULmxlbmd0aDtoKyspe2NvbnN0IG09VFtoXS5tZXNoRGF0YTtpZihtKXtDKz1tLnBvc2l0aW9ucy5sZW5ndGg7Y29uc3Qgcj1tLnBvc2l0aW9uc1swXS5sZW5ndGg7dSs9bS5wb3NpdGlvbnMubGVuZ3RoKnIsYys9bS5jZWxscy5sZW5ndGgqMyx2Kz1tLmF0dHJpYnV0ZXMuYV9jb2xvci5sZW5ndGgqNDtjb25zdCBpPW0udGV4dHVyZUNvb3JkO2kmJihPKz1pLmxlbmd0aCppWzBdLmxlbmd0aCk7Y29uc3Qgbj1tLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O24mJihmKz1uLmxlbmd0aCo0KTtjb25zdCBzPW0uYXR0cmlidXRlcy5hX2NsaXBVVjtzJiYoZys9cy5sZW5ndGgqMil9fWlmKCghZC5wb3NpdGlvbnN8fGQucG9zaXRpb25zLmxlbmd0aDx1KSYmKGQucG9zaXRpb25zPW5ldyBGbG9hdDMyQXJyYXkodSkpLCghZC5jZWxsc3x8ZC5jZWxscy5sZW5ndGg8YykmJihkLmNlbGxzPW5ldyBVaW50MTZBcnJheShjKSksTyYmKCFkLnRleHR1cmVDb29yZHx8ZC50ZXh0dXJlQ29vcmQubGVuZ3RoPE8pJiYoZC50ZXh0dXJlQ29vcmQ9bmV3IEZsb2F0MzJBcnJheShPKSksKCFkLmFfY29sb3J8fGQuYV9jb2xvci5sZW5ndGg8dikmJihkLmFfY29sb3I9bmV3IFVpbnQ4QXJyYXkodikpLGYmJighZC5hX3NvdXJjZVJlY3R8fGQuYV9zb3VyY2VSZWN0Lmxlbmd0aDxmKSYmKGQuYV9zb3VyY2VSZWN0PW5ldyBGbG9hdDMyQXJyYXkoZikpLGcmJighZC5hX2NsaXBVVnx8ZC5hX2NsaXBVVi5sZW5ndGg8ZykmJihkLmFfY2xpcFVWPW5ldyBGbG9hdDMyQXJyYXkoZykpLHApe2NvbnN0IGg9T2JqZWN0LmVudHJpZXMocC5fYXR0cmlidXRlKSxtPXAuX2F0dHJpYk9wdHN8fHt9O2ZvcihsZXQgcj0wO3I8aC5sZW5ndGg7cisrKXtjb25zdFtpLG5dPWhbcl07aWYoaSE9PSJhX2NvbG9yIiYmaSE9PSJhX3NvdXJjZVJlY3QiJiZuIT09Imlnbm9yZWQiKXtjb25zdCBzPW1baV0/bVtpXS50eXBlOiJGTE9BVCIseD1hW3NdLFA9bi5zaXplKkM7KCFkW2ldfHxkW2ldLmxlbmd0aDxQKSYmKGRbaV09bmV3IHgoUCkpfX19cmV0dXJuIGR9ZnVuY3Rpb24gTShULGQpe2xldCB1PVtdLGM9W10sTz1bXSxmPVtdLGc9W10sdj1bXSxDPTAscD0wO2NvbnN0IGg9VFswXT9UWzBdLnVuaWZvcm1zfHx7fTp7fSxtPVRbMF0/VFswXS5wcm9ncmFtOm51bGw7ZCYmKGwoVCxkKSxjPWQuY2VsbHMsdT1kLnBvc2l0aW9ucyxPPWQudGV4dHVyZUNvb3JkLGY9ZC5hX2NvbG9yLGc9ZC5hX3NvdXJjZVJlY3Qsdj1kLmFfY2xpcFVWKTtsZXQgcj0hMSxpPSExO2NvbnN0IG49e307Zm9yKGxldCB4PTA7eDxULmxlbmd0aDt4Kyspe2xldCBQPVRbeF07aWYoUCl7aWYoUC5tZXNoRGF0YSYmKFA9UC5tZXNoRGF0YSksZCl7Y29uc3QgYj1QLnBvc2l0aW9ucztmb3IobGV0IEU9MDtFPGIubGVuZ3RoO0UrKyl7Y29uc3QgRD1iW0VdLEk9MyooQytFKTtmb3IobGV0IFM9MDtTPEQubGVuZ3RoO1MrKyl1W0krU109RFtTXX19ZWxzZSB1LnB1c2goLi4uUC5wb3NpdGlvbnMpO2NvbnN0IFI9UC5jZWxscztmb3IobGV0IGI9MDtiPFIubGVuZ3RoO2IrKyl7Y29uc3QgRT1SW2JdO2lmKGQpe2NvbnN0IEQ9MyoocCtiKTtjW0RdPUVbMF0rQyxjW0QrMV09RVsxXStDLGNbRCsyXT1FWzJdK0N9ZWxzZSBjLnB1c2goW0VbMF0rQyxFWzFdK0MsRVsyXStDXSl9aWYoZCl7Y29uc3QgYj1QLmF0dHJpYnV0ZXMuYV9jb2xvcjtmb3IobGV0IEU9MDtFPGIubGVuZ3RoO0UrKyl7Y29uc3QgRD1iW0VdLEk9NCooQytFKTtmW0ldPURbMF0sZltJKzFdPURbMV0sZltJKzJdPURbMl0sZltJKzNdPURbM119fWVsc2UgZi5wdXNoKC4uLlAuYXR0cmlidXRlcy5hX2NvbG9yKTtpZihQLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0KWlmKHI9ITAsZCl7Y29uc3QgYj1QLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0O2ZvcihsZXQgRT0wO0U8Yi5sZW5ndGg7RSsrKXtjb25zdCBEPWJbRV0sST00KihDK0UpO2dbSV09RFswXSxnW0krMV09RFsxXSxnW0krMl09RFsyXSxnW0krM109RFszXX19ZWxzZSBnLnB1c2goLi4uUC5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdCk7aWYoUC5hdHRyaWJ1dGVzLmFfY2xpcFVWKWlmKGk9ITAsZCl7Y29uc3QgYj1QLmF0dHJpYnV0ZXMuYV9jbGlwVVY7Zm9yKGxldCBFPTA7RTxiLmxlbmd0aDtFKyspe2NvbnN0IEQ9YltFXSxJPTIqKEMrRSk7dltJXT1EWzBdLHZbSSsxXT1EWzFdfX1lbHNlIHYucHVzaCguLi5QLmF0dHJpYnV0ZXMuYV9jbGlwVVYpO2lmKFAudGV4dHVyZUNvb3JkKWlmKGQpe2NvbnN0IGI9UC50ZXh0dXJlQ29vcmQ7Zm9yKGxldCBFPTA7RTxiLmxlbmd0aDtFKyspe2NvbnN0IEQ9YltFXSxJPTMqKEMrRSk7Zm9yKGxldCBTPTA7UzxELmxlbmd0aDtTKyspT1tJK1NdPURbU119fWVsc2UgTy5wdXNoKC4uLlAudGV4dHVyZUNvb3JkKTtpZihtKXtjb25zdCBiPU9iamVjdC5lbnRyaWVzKG0uX2F0dHJpYnV0ZSk7Zm9yKGxldCBFPTA7RTxiLmxlbmd0aDtFKyspe2NvbnN0W0QsSV09YltFXTtpZihEIT09ImFfY29sb3IiJiZEIT09ImFfc291cmNlUmVjdCImJkkhPT0iaWdub3JlZCIpaWYobltEXT1bXSxkKXtuW0RdPWRbRF07Y29uc3QgUz1QLmF0dHJpYnV0ZXNbRF0sQT1TWzBdLmxlbmd0aDtmb3IobGV0IFU9MDtVPFMubGVuZ3RoO1UrKyl7Y29uc3QgSz1TW1VdLFY9QSooQytVKTtmb3IobGV0IEo9MDtKPEsubGVuZ3RoO0orKyluW0RdW1YrSl09S1tKXX19ZWxzZSBuW0RdLnB1c2goLi4uUC5hdHRyaWJ1dGVzW0RdKX19Qys9UC5wb3NpdGlvbnMubGVuZ3RoLHArPVAuY2VsbHMubGVuZ3RofX1uLmFfY29sb3I9ZixyJiZnJiZnLmxlbmd0aD4wJiYobi5hX3NvdXJjZVJlY3Q9Zyk7Y29uc3Qgcz17cG9zaXRpb25zOnUsY2VsbHM6YyxhdHRyaWJ1dGVzOm4sdW5pZm9ybXM6aCxjZWxsc0NvdW50OnAqMyxwcm9ncmFtOm19O3JldHVybiBPJiZPLmxlbmd0aCYmKHMudGV4dHVyZUNvb3JkPU8pLGkmJnYubGVuZ3RoPjAmJihuLmFfY2xpcFVWPXYpLHN9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpO3ZhciBhPXQoMSksbD10KDMwKSxNPXQoMjYpLFQ9dCgzMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGQobixzKXt2YXIgeD1PYmplY3Qua2V5cyhuKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgUD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG4pO3MmJihQPVAuZmlsdGVyKGZ1bmN0aW9uKFIpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sUikuZW51bWVyYWJsZX0pKSx4LnB1c2guYXBwbHkoeCxQKX1yZXR1cm4geH1mdW5jdGlvbiB1KG4pe2Zvcih2YXIgcz0xO3M8YXJndW1lbnRzLmxlbmd0aDtzKyspe3ZhciB4PWFyZ3VtZW50c1tzXSE9bnVsbD9hcmd1bWVudHNbc106e307cyUyP2QoT2JqZWN0KHgpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKFApe2MobixQLHhbUF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh4KSk6ZChPYmplY3QoeCkpLmZvckVhY2goZnVuY3Rpb24oUCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sUCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHgsUCkpfSl9cmV0dXJuIG59ZnVuY3Rpb24gYyhuLHMseCl7cmV0dXJuIHMgaW4gbj9PYmplY3QuZGVmaW5lUHJvcGVydHkobixzLHt2YWx1ZTp4LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6bltzXT14LG59Y29uc3QgTz1TeW1ib2woIm1lc2giKSxmPVN5bWJvbCgiY291bnQiKSxnPVN5bWJvbCgiYmxlbmQiKSx2PVN5bWJvbCgiZmlsdGVyIiksQz1TeW1ib2woInRleHR1cmVzIikscD1TeW1ib2woInRleHR1cmVPcHRpb25zIiksaD1TeW1ib2woImNsb3VkQ29sb3IiKSxtPVN5bWJvbCgiY2xvdWRGaWx0ZXIiKSxyPVN5bWJvbCgiYnVmZmVyIik7ZnVuY3Rpb24gaShuLHM9bnVsbCl7Y29uc3QgeD1uZXcgRmxvYXQzMkFycmF5KDMqbiksUD1uZXcgRmxvYXQzMkFycmF5KDMqbiksUj1uZXcgRmxvYXQzMkFycmF5KDQqbiksYj1uZXcgRmxvYXQzMkFycmF5KDQqbiksRT1uZXcgRmxvYXQzMkFycmF5KDQqbiksRD1uZXcgRmxvYXQzMkFycmF5KDQqbiksST1uZXcgRmxvYXQzMkFycmF5KDQqbiksUz1uZXcgVWludDhBcnJheShuKSxBPW5ldyBVaW50OEFycmF5KDQqbiksVT1uZXcgVWludDhBcnJheSg0Km4pO3JldHVybiBzJiYoeC5zZXQocy50cmFuc2Zvcm0wLDApLFAuc2V0KHMudHJhbnNmb3JtMSwwKSxSLnNldChzLmNvbG9yMCwwKSxiLnNldChzLmNvbG9yMSwwKSxFLnNldChzLmNvbG9yMiwwKSxELnNldChzLmNvbG9yMywwKSxJLnNldChzLmNvbG9yNCwwKSxTLnNldChzLmZyYW1lSW5kZXgsMCksQS5zZXQocy5maWxsQ29sb3IsMCksVS5zZXQocy5zdHJva2VDb2xvciwwKSkse2J1ZmZlclNpemU6bix0cmFuc2Zvcm0wOngsdHJhbnNmb3JtMTpQLGNvbG9yMDpSLGNvbG9yMTpiLGNvbG9yMjpFLGNvbG9yMzpELGNvbG9yNDpJLGZyYW1lSW5kZXg6UyxmaWxsQ29sb3I6QSxzdHJva2VDb2xvcjpVfX1lLmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IobixzPTEse2J1ZmZlcjp4PTFlM309e30pe3g9TWF0aC5tYXgoeCxzKSx0aGlzW2ZdPXMsdGhpc1tPXT1uLHRoaXNbcl09aSh4KSx0aGlzW0NdPVtdLHRoaXNbdl09W10sdGhpc1toXT0hMSx0aGlzW21dPSExLHRoaXNbZ109ITEsdGhpcy5pbml0QnVmZmVyKCl9aW5pdEJ1ZmZlcihuPTApe2NvbnN0IHM9dGhpc1tmXTtmb3IobGV0IHg9bjt4PHM7eCsrKXRoaXNbcl0udHJhbnNmb3JtMC5zZXQoWzEsMCwwXSx4KjMpLHRoaXNbcl0udHJhbnNmb3JtMS5zZXQoWzAsMSwwXSx4KjMpLHRoaXNbcl0uZnJhbWVJbmRleC5zZXQoWy0xXSx4KSx0aGlzW3JdLmZpbGxDb2xvci5zZXQoWzAsMCwwLDBdLHgqNCksdGhpc1tyXS5zdHJva2VDb2xvci5zZXQoWzAsMCwwLDBdLHgqNCksdGhpcy5zZXRDb2xvclRyYW5zZm9ybSh4LG51bGwpfWdldCBidWZmZXJTaXplKCl7cmV0dXJuIHRoaXNbcl0uYnVmZmVyU2l6ZX1nZXQgbWVzaCgpe3JldHVybiB0aGlzW09dfXNldCBtZXNoKG4pe3RoaXNbT109bix0aGlzW0NdJiZ0aGlzLnNldFRleHR1cmVGcmFtZXModGhpc1tDXSx0aGlzW3BdKX1nZXQgaGFzQ2xvdWRDb2xvcigpe3JldHVybiB0aGlzW2hdfWdldCBoYXNDbG91ZEZpbHRlcigpe3JldHVybiB0aGlzW21dfV9nZXRGaWx0ZXIobil7cmV0dXJuIHRoaXNbdl1bbl09dGhpc1t2XVtuXXx8W10sdGhpc1t2XVtuXX1nZXRGaWx0ZXIobil7cmV0dXJuIHRoaXMuX2dldEZpbHRlcihuKS5qb2luKCIgIil9Z2V0IGVuYWJsZUJsZW5kKCl7cmV0dXJuIHRoaXNbT10uZW5hYmxlQmxlbmR8fHRoaXNbZ119Y2FuSWdub3JlKCl7cmV0dXJuIHRoaXNbT10uY2FuSWdub3JlKCl9ZGVsZXRlKG4pe2lmKG4+PXRoaXNbZl18fG48MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtjb25zdHt0cmFuc2Zvcm0wOnMsdHJhbnNmb3JtMTp4LGNvbG9yMDpQLGNvbG9yMTpSLGNvbG9yMjpiLGNvbG9yMzpFLGNvbG9yNDpELGZyYW1lSW5kZXg6SSxmaWxsQ29sb3I6UyxzdHJva2VDb2xvcjpBfT10aGlzW3JdO3Muc2V0KHMuc3ViYXJyYXkoMyoobisxKSksMypuKSx4LnNldCh4LnN1YmFycmF5KDMqKG4rMSkpLDMqbiksUC5zZXQoUC5zdWJhcnJheSg0KihuKzEpKSw0Km4pLFIuc2V0KFIuc3ViYXJyYXkoNCoobisxKSksNCpuKSxiLnNldChiLnN1YmFycmF5KDQqKG4rMSkpLDQqbiksRS5zZXQoRS5zdWJhcnJheSg0KihuKzEpKSw0Km4pLEQuc2V0KEQuc3ViYXJyYXkoNCoobisxKSksNCpuKSxJLnNldChJLnN1YmFycmF5KG4rMSksbiksUy5zZXQoUy5zdWJhcnJheSg0KihuKzEpKSw0Km4pLEEuc2V0KEEuc3ViYXJyYXkoNCoobisxKSksNCpuKTtmb3IoY29uc3QgVSBpbiB0aGlzW3ZdKVU9PT1uP2RlbGV0ZSB0aGlzW3ZdW1VdOlU+biYmKHRoaXNbdl1bVS0xXT10aGlzW3ZdW1VdLGRlbGV0ZSB0aGlzW3ZdW1VdKTt0aGlzW2ZdLS19c2V0Q29sb3JUcmFuc2Zvcm0obixzKXtpZihuPj10aGlzW2ZdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7bio9NDtjb25zdHtjb2xvcjA6eCxjb2xvcjE6UCxjb2xvcjI6Uixjb2xvcjM6Yixjb2xvcjQ6RX09dGhpc1tyXTtyZXR1cm4gcyE9bnVsbD8oeC5zZXQoW3NbMF0sc1s1XSxzWzEwXSxzWzE1XV0sbiksUC5zZXQoW3NbMV0sc1s2XSxzWzExXSxzWzE2XV0sbiksUi5zZXQoW3NbMl0sc1s3XSxzWzEyXSxzWzE3XV0sbiksYi5zZXQoW3NbM10sc1s4XSxzWzEzXSxzWzE4XV0sbiksRS5zZXQoW3NbNF0sc1s5XSxzWzE0XSxzWzE5XV0sbiksdGhpc1tnXT10aGlzW2ddfHxzWzE4XTwxLHRoaXNbbV09ITApOih4LnNldChbMSwwLDAsMF0sbiksUC5zZXQoWzAsMSwwLDBdLG4pLFIuc2V0KFswLDAsMSwwXSxuKSxiLnNldChbMCwwLDAsMV0sbiksRS5zZXQoWzAsMCwwLDBdLG4pKSx0aGlzfWdldENvbG9yVHJhbnNmb3JtKG4pe2lmKG4+PXRoaXNbZl18fG48MCl0aHJvdyBuZXcgRXJyb3IoIk91dCBvZiByYW5nZS4iKTtuKj00O2NvbnN0e2NvbG9yMDpzLGNvbG9yMTp4LGNvbG9yMjpQLGNvbG9yMzpSLGNvbG9yNDpifT10aGlzW3JdO3JldHVybltzW25dLHhbbl0sUFtuXSxSW25dLGJbbl0sc1tuKzFdLHhbbisxXSxQW24rMV0sUltuKzFdLGJbbisxXSxzW24rMl0seFtuKzJdLFBbbisyXSxSW24rMl0sYltuKzJdLHNbbiszXSx4W24rM10sUFtuKzNdLFJbbiszXSxiW24rM11dfXRyYW5zZm9ybUNvbG9yKG4scyl7bGV0IHg9dGhpcy5nZXRDb2xvclRyYW5zZm9ybShuKTtyZXR1cm4geD1PYmplY3QobC5tdWx0aXBseSkoeCxzKSx0aGlzLnNldENvbG9yVHJhbnNmb3JtKG4seCksdGhpc31zZXRGaWxsQ29sb3IobixzKXtpZihuPj10aGlzW2ZdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7dHlwZW9mIHM9PSJzdHJpbmciJiYocz1PYmplY3QoVC5kZWZhdWx0KShzKSksc1szXT4wJiYodGhpc1toXT0hMCksdGhpc1tyXS5maWxsQ29sb3Iuc2V0KHMubWFwKHg9Pk1hdGgucm91bmQoMjU1KngpKSw0Km4pfXNldFN0cm9rZUNvbG9yKG4scyl7aWYobj49dGhpc1tmXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO3R5cGVvZiBzPT0ic3RyaW5nIiYmKHM9T2JqZWN0KFQuZGVmYXVsdCkocykpLHNbM10+MCYmKHRoaXNbaF09ITApLHRoaXNbcl0uc3Ryb2tlQ29sb3Iuc2V0KHMubWFwKHg9Pk1hdGgucm91bmQoMjU1KngpKSw0Km4pfWdldENsb3VkUkdCQShuKXtpZihuPj10aGlzW2ZdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7bio9NDtjb25zdHtmaWxsQ29sb3I6cyxzdHJva2VDb2xvcjp4fT10aGlzW3JdLFA9W3Nbbl0sc1tuKzFdLHNbbisyXSxzW24rM11dLFI9W3hbbl0seFtuKzFdLHhbbisyXSx4W24rM11dO3JldHVybiBQWzNdLz0yNTUsUlszXS89MjU1LHtmaWxsOmByZ2JhKCR7UC5qb2luKCl9KWAsc3Ryb2tlOmByZ2JhKCR7Ui5qb2luKCl9KWB9fWdyYXlzY2FsZShuLHMpe3RoaXMudHJhbnNmb3JtQ29sb3IobixPYmplY3QobC5ncmF5c2NhbGUpKHMpKSx0aGlzLl9nZXRGaWx0ZXIobikucHVzaChgZ3JheXNjYWxlKCR7MTAwKnN9JSlgKX1icmlnaHRuZXNzKG4scyl7dGhpcy50cmFuc2Zvcm1Db2xvcihuLE9iamVjdChsLmJyaWdodG5lc3MpKHMpKSx0aGlzLl9nZXRGaWx0ZXIobikucHVzaChgYnJpZ2h0bmVzcygkezEwMCpzfSUpYCl9c2F0dXJhdGUobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KGwuc2F0dXJhdGUpKHMpKSx0aGlzLl9nZXRGaWx0ZXIobikucHVzaChgc2F0dXJhdGUoJHsxMDAqc30lKWApfWNvbnRyYXN0KG4scyl7dGhpcy50cmFuc2Zvcm1Db2xvcihuLE9iamVjdChsLmNvbnRyYXN0KShzKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYGNvbnRyYXN0KCR7MTAwKnN9JSlgKX1pbnZlcnQobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KGwuaW52ZXJ0KShzKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYGludmVydCgkezEwMCpzfSUpYCl9c2VwaWEobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KGwuc2VwaWEpKHMpKSx0aGlzLl9nZXRGaWx0ZXIobikucHVzaChgc2VwaWEoJHsxMDAqc30lKWApfW9wYWNpdHkobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KGwub3BhY2l0eSkocykpLHRoaXMuX2dldEZpbHRlcihuKS5wdXNoKGBvcGFjaXR5KCR7MTAwKnN9JSlgKX1odWVSb3RhdGUobixzKXt0aGlzLnRyYW5zZm9ybUNvbG9yKG4sT2JqZWN0KGwuaHVlUm90YXRlKShzKSksdGhpcy5fZ2V0RmlsdGVyKG4pLnB1c2goYGh1ZS1yb3RhdGUoJHtzfWRlZylgKX1zZXRUcmFuc2Zvcm0obixzKXtpZihuPj10aGlzW2ZdfHxuPDApdGhyb3cgbmV3IEVycm9yKCJPdXQgb2YgcmFuZ2UuIik7bio9MyxzPT1udWxsJiYocz1bMSwwLDAsMSwwLDBdKTtjb25zdHt0cmFuc2Zvcm0wOngsdHJhbnNmb3JtMTpQfT10aGlzW3JdO3JldHVybiB4LnNldChbc1swXSxzWzJdLHNbNF1dLG4pLFAuc2V0KFtzWzFdLHNbM10sc1s1XV0sbiksdGhpc31nZXRUcmFuc2Zvcm0obil7aWYobj49dGhpc1tmXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO24qPTM7Y29uc3R7dHJhbnNmb3JtMDpzLHRyYW5zZm9ybTE6eH09dGhpc1tyXTtyZXR1cm5bc1tuXSx4W25dLHNbbisxXSx4W24rMV0sc1tuKzJdLHhbbisyXV19Z2V0VGV4dHVyZUZyYW1lKG4pe3JldHVybiB0aGlzW0NdW3RoaXNbcl0uZnJhbWVJbmRleFtuXV19c2V0VGV4dHVyZUZyYW1lcyhuPVtdLHM9e30pe2lmKG4ubGVuZ3RoPjEyKXRocm93IG5ldyBFcnJvcigiTWF4IGZyYW1lcyBleGNlZWQuIEFsbG93IDEyIGZyYW1lcy4iKTtuLmxlbmd0aCYmdGhpc1tPXS5zZXRUZXh0dXJlKG5bMF0scyksdGhpc1tDXT1uLHRoaXNbcF09c31zZXRGcmFtZUluZGV4KG4scyl7aWYobj49dGhpc1tmXXx8bjwwKXRocm93IG5ldyBFcnJvcigiT3V0IG9mIHJhbmdlLiIpO2NvbnN0IHg9dGhpc1tDXS5sZW5ndGg7aWYoeDw9MCl0aHJvdyBuZXcgRXJyb3IoIk5vIGZyYW1lcyIpO3RoaXNbcl0uZnJhbWVJbmRleFtuXT1zJXh9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2ZdfXNldCBhbW91bnQobil7Y29uc3Qgcz10aGlzW2ZdO24hPT1zJiYobj50aGlzW3JdLmJ1ZmZlclNpemUmJih0aGlzW3JdPWkoTWF0aC5tYXgobix0aGlzW3JdLmJ1ZmZlclNpemUrMWUzKSx0aGlzW3JdKSksdGhpc1tmXT1uLG4+cyYmdGhpcy5pbml0QnVmZmVyKHMpKX1nZXQgbWVzaERhdGEoKXtjb25zdHthdHRyaWJ1dGVzOm4sY2VsbHM6cyxwb3NpdGlvbnM6eCx0ZXh0dXJlQ29vcmQ6UCx1bmlmb3JtczpSfT10aGlzW09dLm1lc2hEYXRhLGI9dGhpc1tDXSxFPXthdHRyaWJ1dGVzOnUoe30sbiksY2VsbHM6cyxwb3NpdGlvbnM6eCx0ZXh0dXJlQ29vcmQ6UCx1bmlmb3Jtczp1KHt9LFIpLGluc3RhbmNlQ291bnQ6dGhpc1tmXSxlbmFibGVCbGVuZDp0aGlzLmVuYWJsZUJsZW5kfTtiLmxlbmd0aCYmYi5mb3JFYWNoKChILFopPT57RS51bmlmb3Jtc1tgdV90ZXhGcmFtZSR7Wn1gXT1IfSk7Y29uc3R7dHJhbnNmb3JtMDpELHRyYW5zZm9ybTE6SSxjb2xvcjA6Uyxjb2xvcjE6QSxjb2xvcjI6VSxjb2xvcjM6Syxjb2xvcjQ6VixmaWxsQ29sb3I6SixzdHJva2VDb2xvcjpxLGZyYW1lSW5kZXg6V309dGhpc1tyXTtyZXR1cm4gdGhpc1tPXS51bmlmb3Jtcy51X3RleFNhbXBsZXImJihFLmF0dHJpYnV0ZXMuYV9mcmFtZUluZGV4PXtkYXRhOlcsZGl2aXNvcjoxfSksRS5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMD17ZGF0YTpELGRpdmlzb3I6MX0sRS5hdHRyaWJ1dGVzLmFfdHJhbnNmb3JtMT17ZGF0YTpJLGRpdmlzb3I6MX0sRS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDA9e2RhdGE6UyxkaXZpc29yOjF9LEUuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQxPXtkYXRhOkEsZGl2aXNvcjoxfSxFLmF0dHJpYnV0ZXMuYV9jb2xvckNsb3VkMj17ZGF0YTpVLGRpdmlzb3I6MX0sRS5hdHRyaWJ1dGVzLmFfY29sb3JDbG91ZDM9e2RhdGE6SyxkaXZpc29yOjF9LEUuYXR0cmlidXRlcy5hX2NvbG9yQ2xvdWQ0PXtkYXRhOlYsZGl2aXNvcjoxfSx0aGlzLmhhc0Nsb3VkQ29sb3ImJihFLmF0dHJpYnV0ZXMuYV9maWxsQ2xvdWRDb2xvcj17ZGF0YTpKLGRpdmlzb3I6MX0sRS5hdHRyaWJ1dGVzLmFfc3Ryb2tlQ2xvdWRDb2xvcj17ZGF0YTpxLGRpdmlzb3I6MX0pLEV9c2V0UHJvZ3JhbShuKXt0aGlzW09dLnNldFByb2dyYW0obil9Z2V0IHByb2dyYW0oKXtyZXR1cm4gdGhpc1tPXS5wcm9ncmFtfXRyYW5zZm9ybShuLHMpe2NvbnN0IHg9dGhpcy5nZXRUcmFuc2Zvcm0obik7cmV0dXJuIHM9YS5tYXQyZC5tdWx0aXBseShBcnJheS5vZigwLDAsMCwwLDAsMCkseCxzKSx0aGlzLnNldFRyYW5zZm9ybShuLHMpLHRoaXN9dHJhbnNsYXRlKG4sW3MseF0pe2xldCBQPWEubWF0MmQuY3JlYXRlKCk7cmV0dXJuIFA9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLFAsW3MseF0pLHRoaXMudHJhbnNmb3JtKG4sUCl9cm90YXRlKG4scyxbeCxQXT1bMCwwXSl7bGV0IFI9YS5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gUj1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksUixbeCxQXSksUj1hLm1hdDJkLnJvdGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksUixzKSxSPWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxSLFsteCwtUF0pLHRoaXMudHJhbnNmb3JtKG4sUil9c2NhbGUobixbcyx4PXNdLFtQLFJdPVswLDBdKXtsZXQgYj1hLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBiPWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxiLFtQLFJdKSxiPWEubWF0MmQuc2NhbGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGIsW3MseF0pLGI9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGIsWy1QLC1SXSksdGhpcy50cmFuc2Zvcm0obixiKX1za2V3KG4sW3MseD1zXSxbUCxSXT1bMCwwXSl7bGV0IGI9YS5tYXQyZC5jcmVhdGUoKTtyZXR1cm4gYj1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksYixbUCxSXSksYj1hLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxiLGEubWF0MmQuZnJvbVZhbHVlcygxLE1hdGgudGFuKHgpLE1hdGgudGFuKHMpLDEsMCwwKSksYj1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksYixbLVAsLVJdKSx0aGlzLnRyYW5zZm9ybShuLGIpfWlzUG9pbnRDb2xsaXNpb24obixbcyx4XSxQPSJib3RoIil7Y29uc3QgUj10aGlzLmdldFRyYW5zZm9ybShuKSxiPU9iamVjdChNLnRyYW5zZm9ybVBvaW50KShbcyx4XSxhLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksUikpO3JldHVybiB0aGlzW09dLmlzUG9pbnRDb2xsaXNpb24oLi4uYixQKX1pc1BvaW50SW5GaWxsKG4sW3MseF0pe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24obixbcyx4XSwiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShuLFtzLHhdKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKG4sW3MseF0sInN0cm9rZSIpfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsIm11bHRpcGx5IixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImdyYXlzY2FsZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJicmlnaHRuZXNzIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNhdHVyYXRlIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImNvbnRyYXN0IixmdW5jdGlvbigpe3JldHVybiB1fSksdC5kKGUsImludmVydCIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJzZXBpYSIsZnVuY3Rpb24oKXtyZXR1cm4gT30pLHQuZChlLCJvcGFjaXR5IixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImh1ZVJvdGF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciBhPXQoMjYpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKHYsQyl7Y29uc3QgcD1bXSxoPXZbMF0sbT12WzFdLHI9dlsyXSxpPXZbM10sbj12WzRdLHM9dls1XSx4PXZbNl0sUD12WzddLFI9dls4XSxiPXZbOV0sRT12WzEwXSxEPXZbMTFdLEk9dlsxMl0sUz12WzEzXSxBPXZbMTRdLFU9dlsxNV0sSz12WzE2XSxWPXZbMTddLEo9dlsxOF0scT12WzE5XTtsZXQgVz1DWzBdLEg9Q1sxXSxaPUNbMl0sdHQ9Q1szXSxfPUNbNF07cmV0dXJuIHBbMF09VypoK0gqcytaKkUrdHQqVSxwWzFdPVcqbStIKngrWipEK3R0KksscFsyXT1XKnIrSCpQK1oqSSt0dCpWLHBbM109VyppK0gqUitaKlMrdHQqSixwWzRdPVcqbitIKmIrWipBK3R0KnErXyxXPUNbNV0sSD1DWzZdLFo9Q1s3XSx0dD1DWzhdLF89Q1s5XSxwWzVdPVcqaCtIKnMrWipFK3R0KlUscFs2XT1XKm0rSCp4K1oqRCt0dCpLLHBbN109VypyK0gqUCtaKkkrdHQqVixwWzhdPVcqaStIKlIrWipTK3R0KkoscFs5XT1XKm4rSCpiK1oqQSt0dCpxK18sVz1DWzEwXSxIPUNbMTFdLFo9Q1sxMl0sdHQ9Q1sxM10sXz1DWzE0XSxwWzEwXT1XKmgrSCpzK1oqRSt0dCpVLHBbMTFdPVcqbStIKngrWipEK3R0KksscFsxMl09VypyK0gqUCtaKkkrdHQqVixwWzEzXT1XKmkrSCpSK1oqUyt0dCpKLHBbMTRdPVcqbitIKmIrWipBK3R0KnErXyxXPUNbMTVdLEg9Q1sxNl0sWj1DWzE3XSx0dD1DWzE4XSxfPUNbMTldLHBbMTVdPVcqaCtIKnMrWipFK3R0KlUscFsxNl09VyptK0gqeCtaKkQrdHQqSyxwWzE3XT1XKnIrSCpQK1oqSSt0dCpWLHBbMThdPVcqaStIKlIrWipTK3R0KkoscFsxOV09VypuK0gqYitaKkErdHQqcStfLHB9ZnVuY3Rpb24gTSh2KXt2PU9iamVjdChhLmNsYW1wKSgwLDEsdik7Y29uc3QgQz0uMjEyNip2LHA9LjcxNTIqdixoPS4wNzIyKnY7cmV0dXJuW0MrMS12LHAsaCwwLDAsQyxwKzEtdixoLDAsMCxDLHAsaCsxLXYsMCwwLDAsMCwwLDEsMF19ZnVuY3Rpb24gVCh2KXtyZXR1cm5bdiwwLDAsMCwwLDAsdiwwLDAsMCwwLDAsdiwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBkKHYpe2NvbnN0IEM9LjIxMjYqKDEtdikscD0uNzE1MiooMS12KSxoPS4wNzIyKigxLXYpO3JldHVybltDK3YscCxoLDAsMCxDLHArdixoLDAsMCxDLHAsaCt2LDAsMCwwLDAsMCwxLDBdfWZ1bmN0aW9uIHUodil7Y29uc3QgQz0uNSooMS12KTtyZXR1cm5bdiwwLDAsMCxDLDAsdiwwLDAsQywwLDAsdiwwLEMsMCwwLDAsMSwwXX1mdW5jdGlvbiBjKHYpe2NvbnN0IEM9MS0yKnY7cmV0dXJuW0MsMCwwLDAsdiwwLEMsMCwwLHYsMCwwLEMsMCx2LDAsMCwwLDEsMF19ZnVuY3Rpb24gTyh2KXtyZXR1cm5bMS0uNjA3KnYsLjc2OSp2LC4xODkqdiwwLDAsLjM0OSp2LDEtLjMxNCp2LC4xNjgqdiwwLDAsLjI3Mip2LC41MzQqdiwxLS44NjkqdiwwLDAsMCwwLDAsMSwwXX1mdW5jdGlvbiBmKHYpe3JldHVyblsxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCx2LDBdfWZ1bmN0aW9uIGcodil7Y29uc3QgQz12LzE4MCpNYXRoLlBJLHA9TWF0aC5jb3MoQyksaD1NYXRoLnNpbihDKSxtPS4yMTI2LHI9LjcxNTIsaT0uMDcyMjtyZXR1cm5bbStwKigxLW0pK2gqLW0scitwKi1yK2gqLXIsaStwKi1pK2gqKDEtaSksMCwwLG0rcCotbStoKi4xNDMscitwKigxLXIpK2gqLjE0LGkrcCotaStoKi0uMjgzLDAsMCxtK3AqLW0raCotKDEtbSkscitwKi1yK2gqcixpK3AqKDEtaSkraCppLDAsMCwwLDAsMCwxLDBdfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pO3ZhciBhPXQoMzIpLGw9dC5uKGEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBNKFQpe2NvbnN0IGQ9bCgpKFQpO2lmKCFkfHwhZC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjb2xvciB2YWx1ZS4iKTtyZXR1cm5bZFswXS8yNTUsZFsxXS8yNTUsZFsyXS8yNTUsZFszXV19fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgzMyksbD10KDM3KSxNPXQoMzkpO0wuZXhwb3J0cz1mdW5jdGlvbihkKXt2YXIgdSxjPWEoZCk7cmV0dXJuIGMuc3BhY2U/KHU9QXJyYXkoMyksdVswXT1NKGMudmFsdWVzWzBdLDAsMjU1KSx1WzFdPU0oYy52YWx1ZXNbMV0sMCwyNTUpLHVbMl09TShjLnZhbHVlc1syXSwwLDI1NSksYy5zcGFjZVswXT09PSJoIiYmKHU9bC5yZ2IodSkpLHUucHVzaChNKGMuYWxwaGEsMCwxKSksdSk6W119fSxmdW5jdGlvbihMLGUsdCl7KGZ1bmN0aW9uKGEpe3ZhciBsPXQoMzQpLE09dCgzNSksVD10KDM2KTtMLmV4cG9ydHM9dTt2YXIgZD17cmVkOjAsb3JhbmdlOjYwLHllbGxvdzoxMjAsZ3JlZW46MTgwLGJsdWU6MjQwLHB1cnBsZTozMDB9O2Z1bmN0aW9uIHUoYyl7dmFyIE8sZj1bXSxnPTEsdjtpZih0eXBlb2YgYz09InN0cmluZyIpaWYobFtjXSlmPWxbY10uc2xpY2UoKSx2PSJyZ2IiO2Vsc2UgaWYoYz09PSJ0cmFuc3BhcmVudCIpZz0wLHY9InJnYiIsZj1bMCwwLDBdO2Vsc2UgaWYoL14jW0EtRmEtZjAtOV0rJC8udGVzdChjKSl7dmFyIEM9Yy5zbGljZSgxKSxwPUMubGVuZ3RoLGg9cDw9NDtnPTEsaD8oZj1bcGFyc2VJbnQoQ1swXStDWzBdLDE2KSxwYXJzZUludChDWzFdK0NbMV0sMTYpLHBhcnNlSW50KENbMl0rQ1syXSwxNildLHA9PT00JiYoZz1wYXJzZUludChDWzNdK0NbM10sMTYpLzI1NSkpOihmPVtwYXJzZUludChDWzBdK0NbMV0sMTYpLHBhcnNlSW50KENbMl0rQ1szXSwxNikscGFyc2VJbnQoQ1s0XStDWzVdLDE2KV0scD09PTgmJihnPXBhcnNlSW50KENbNl0rQ1s3XSwxNikvMjU1KSksZlswXXx8KGZbMF09MCksZlsxXXx8KGZbMV09MCksZlsyXXx8KGZbMl09MCksdj0icmdiIn1lbHNlIGlmKE89L14oKD86cmdifGhzW2x2Yl18aHdifGNteWs/fHh5W3p5XXxncmF5fGxhYnxsY2h1P3Y/fFtseV11dnxsbXMpYT8pXHMqXCgoW15cKV0qKVwpLy5leGVjKGMpKXt2YXIgbT1PWzFdLHI9bT09PSJyZ2IiLEM9bS5yZXBsYWNlKC9hJC8sIiIpO3Y9Qzt2YXIgcD1DPT09ImNteWsiPzQ6Qz09PSJncmF5Ij8xOjM7Zj1PWzJdLnRyaW0oKS5zcGxpdCgvXHMqLFxzKi8pLm1hcChmdW5jdGlvbih4LFApe2lmKC8lJC8udGVzdCh4KSlyZXR1cm4gUD09PXA/cGFyc2VGbG9hdCh4KS8xMDA6Qz09PSJyZ2IiP3BhcnNlRmxvYXQoeCkqMjU1LzEwMDpwYXJzZUZsb2F0KHgpO2lmKENbUF09PT0iaCIpe2lmKC9kZWckLy50ZXN0KHgpKXJldHVybiBwYXJzZUZsb2F0KHgpO2lmKGRbeF0hPT12b2lkIDApcmV0dXJuIGRbeF19cmV0dXJuIHBhcnNlRmxvYXQoeCl9KSxtPT09QyYmZi5wdXNoKDEpLGc9cnx8ZltwXT09PXZvaWQgMD8xOmZbcF0sZj1mLnNsaWNlKDAscCl9ZWxzZSBjLmxlbmd0aD4xMCYmL1swLTldKD86XHN8XC8pLy50ZXN0KGMpJiYoZj1jLm1hdGNoKC8oWzAtOV0rKS9nKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIHBhcnNlRmxvYXQobil9KSx2PWMubWF0Y2goLyhbYS16XSkvaWcpLmpvaW4oIiIpLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoIWlzTmFOKGMpKXY9InJnYiIsZj1bYz4+PjE2LChjJjY1MjgwKT4+PjgsYyYyNTVdO2Vsc2UgaWYoTShjKSl7dmFyIGk9VChjLnIsYy5yZWQsYy5SLG51bGwpO2khPT1udWxsPyh2PSJyZ2IiLGY9W2ksVChjLmcsYy5ncmVlbixjLkcpLFQoYy5iLGMuYmx1ZSxjLkIpXSk6KHY9ImhzbCIsZj1bVChjLmgsYy5odWUsYy5IKSxUKGMucyxjLnNhdHVyYXRpb24sYy5TKSxUKGMubCxjLmxpZ2h0bmVzcyxjLkwsYy5iLGMuYnJpZ2h0bmVzcyldKSxnPVQoYy5hLGMuYWxwaGEsYy5vcGFjaXR5LDEpLGMub3BhY2l0eSE9bnVsbCYmKGcvPTEwMCl9ZWxzZShBcnJheS5pc0FycmF5KGMpfHxhLkFycmF5QnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcmJkFycmF5QnVmZmVyLmlzVmlldyhjKSkmJihmPVtjWzBdLGNbMV0sY1syXV0sdj0icmdiIixnPWMubGVuZ3RoPT09ND9jWzNdOjEpO3JldHVybntzcGFjZTp2LHZhbHVlczpmLGFscGhhOmd9fX0pLmNhbGwodGhpcyx0KDIyKSl9LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2FsaWNlYmx1ZTpbMjQwLDI0OCwyNTVdLGFudGlxdWV3aGl0ZTpbMjUwLDIzNSwyMTVdLGFxdWE6WzAsMjU1LDI1NV0sYXF1YW1hcmluZTpbMTI3LDI1NSwyMTJdLGF6dXJlOlsyNDAsMjU1LDI1NV0sYmVpZ2U6WzI0NSwyNDUsMjIwXSxiaXNxdWU6WzI1NSwyMjgsMTk2XSxibGFjazpbMCwwLDBdLGJsYW5jaGVkYWxtb25kOlsyNTUsMjM1LDIwNV0sYmx1ZTpbMCwwLDI1NV0sYmx1ZXZpb2xldDpbMTM4LDQzLDIyNl0sYnJvd246WzE2NSw0Miw0Ml0sYnVybHl3b29kOlsyMjIsMTg0LDEzNV0sY2FkZXRibHVlOls5NSwxNTgsMTYwXSxjaGFydHJldXNlOlsxMjcsMjU1LDBdLGNob2NvbGF0ZTpbMjEwLDEwNSwzMF0sY29yYWw6WzI1NSwxMjcsODBdLGNvcm5mbG93ZXJibHVlOlsxMDAsMTQ5LDIzN10sY29ybnNpbGs6WzI1NSwyNDgsMjIwXSxjcmltc29uOlsyMjAsMjAsNjBdLGN5YW46WzAsMjU1LDI1NV0sZGFya2JsdWU6WzAsMCwxMzldLGRhcmtjeWFuOlswLDEzOSwxMzldLGRhcmtnb2xkZW5yb2Q6WzE4NCwxMzQsMTFdLGRhcmtncmF5OlsxNjksMTY5LDE2OV0sZGFya2dyZWVuOlswLDEwMCwwXSxkYXJrZ3JleTpbMTY5LDE2OSwxNjldLGRhcmtraGFraTpbMTg5LDE4MywxMDddLGRhcmttYWdlbnRhOlsxMzksMCwxMzldLGRhcmtvbGl2ZWdyZWVuOls4NSwxMDcsNDddLGRhcmtvcmFuZ2U6WzI1NSwxNDAsMF0sZGFya29yY2hpZDpbMTUzLDUwLDIwNF0sZGFya3JlZDpbMTM5LDAsMF0sZGFya3NhbG1vbjpbMjMzLDE1MCwxMjJdLGRhcmtzZWFncmVlbjpbMTQzLDE4OCwxNDNdLGRhcmtzbGF0ZWJsdWU6WzcyLDYxLDEzOV0sZGFya3NsYXRlZ3JheTpbNDcsNzksNzldLGRhcmtzbGF0ZWdyZXk6WzQ3LDc5LDc5XSxkYXJrdHVycXVvaXNlOlswLDIwNiwyMDldLGRhcmt2aW9sZXQ6WzE0OCwwLDIxMV0sZGVlcHBpbms6WzI1NSwyMCwxNDddLGRlZXBza3libHVlOlswLDE5MSwyNTVdLGRpbWdyYXk6WzEwNSwxMDUsMTA1XSxkaW1ncmV5OlsxMDUsMTA1LDEwNV0sZG9kZ2VyYmx1ZTpbMzAsMTQ0LDI1NV0sZmlyZWJyaWNrOlsxNzgsMzQsMzRdLGZsb3JhbHdoaXRlOlsyNTUsMjUwLDI0MF0sZm9yZXN0Z3JlZW46WzM0LDEzOSwzNF0sZnVjaHNpYTpbMjU1LDAsMjU1XSxnYWluc2Jvcm86WzIyMCwyMjAsMjIwXSxnaG9zdHdoaXRlOlsyNDgsMjQ4LDI1NV0sZ29sZDpbMjU1LDIxNSwwXSxnb2xkZW5yb2Q6WzIxOCwxNjUsMzJdLGdyYXk6WzEyOCwxMjgsMTI4XSxncmVlbjpbMCwxMjgsMF0sZ3JlZW55ZWxsb3c6WzE3MywyNTUsNDddLGdyZXk6WzEyOCwxMjgsMTI4XSxob25leWRldzpbMjQwLDI1NSwyNDBdLGhvdHBpbms6WzI1NSwxMDUsMTgwXSxpbmRpYW5yZWQ6WzIwNSw5Miw5Ml0saW5kaWdvOls3NSwwLDEzMF0saXZvcnk6WzI1NSwyNTUsMjQwXSxraGFraTpbMjQwLDIzMCwxNDBdLGxhdmVuZGVyOlsyMzAsMjMwLDI1MF0sbGF2ZW5kZXJibHVzaDpbMjU1LDI0MCwyNDVdLGxhd25ncmVlbjpbMTI0LDI1MiwwXSxsZW1vbmNoaWZmb246WzI1NSwyNTAsMjA1XSxsaWdodGJsdWU6WzE3MywyMTYsMjMwXSxsaWdodGNvcmFsOlsyNDAsMTI4LDEyOF0sbGlnaHRjeWFuOlsyMjQsMjU1LDI1NV0sbGlnaHRnb2xkZW5yb2R5ZWxsb3c6WzI1MCwyNTAsMjEwXSxsaWdodGdyYXk6WzIxMSwyMTEsMjExXSxsaWdodGdyZWVuOlsxNDQsMjM4LDE0NF0sbGlnaHRncmV5OlsyMTEsMjExLDIxMV0sbGlnaHRwaW5rOlsyNTUsMTgyLDE5M10sbGlnaHRzYWxtb246WzI1NSwxNjAsMTIyXSxsaWdodHNlYWdyZWVuOlszMiwxNzgsMTcwXSxsaWdodHNreWJsdWU6WzEzNSwyMDYsMjUwXSxsaWdodHNsYXRlZ3JheTpbMTE5LDEzNiwxNTNdLGxpZ2h0c2xhdGVncmV5OlsxMTksMTM2LDE1M10sbGlnaHRzdGVlbGJsdWU6WzE3NiwxOTYsMjIyXSxsaWdodHllbGxvdzpbMjU1LDI1NSwyMjRdLGxpbWU6WzAsMjU1LDBdLGxpbWVncmVlbjpbNTAsMjA1LDUwXSxsaW5lbjpbMjUwLDI0MCwyMzBdLG1hZ2VudGE6WzI1NSwwLDI1NV0sbWFyb29uOlsxMjgsMCwwXSxtZWRpdW1hcXVhbWFyaW5lOlsxMDIsMjA1LDE3MF0sbWVkaXVtYmx1ZTpbMCwwLDIwNV0sbWVkaXVtb3JjaGlkOlsxODYsODUsMjExXSxtZWRpdW1wdXJwbGU6WzE0NywxMTIsMjE5XSxtZWRpdW1zZWFncmVlbjpbNjAsMTc5LDExM10sbWVkaXVtc2xhdGVibHVlOlsxMjMsMTA0LDIzOF0sbWVkaXVtc3ByaW5nZ3JlZW46WzAsMjUwLDE1NF0sbWVkaXVtdHVycXVvaXNlOls3MiwyMDksMjA0XSxtZWRpdW12aW9sZXRyZWQ6WzE5OSwyMSwxMzNdLG1pZG5pZ2h0Ymx1ZTpbMjUsMjUsMTEyXSxtaW50Y3JlYW06WzI0NSwyNTUsMjUwXSxtaXN0eXJvc2U6WzI1NSwyMjgsMjI1XSxtb2NjYXNpbjpbMjU1LDIyOCwxODFdLG5hdmFqb3doaXRlOlsyNTUsMjIyLDE3M10sbmF2eTpbMCwwLDEyOF0sb2xkbGFjZTpbMjUzLDI0NSwyMzBdLG9saXZlOlsxMjgsMTI4LDBdLG9saXZlZHJhYjpbMTA3LDE0MiwzNV0sb3JhbmdlOlsyNTUsMTY1LDBdLG9yYW5nZXJlZDpbMjU1LDY5LDBdLG9yY2hpZDpbMjE4LDExMiwyMTRdLHBhbGVnb2xkZW5yb2Q6WzIzOCwyMzIsMTcwXSxwYWxlZ3JlZW46WzE1MiwyNTEsMTUyXSxwYWxldHVycXVvaXNlOlsxNzUsMjM4LDIzOF0scGFsZXZpb2xldHJlZDpbMjE5LDExMiwxNDddLHBhcGF5YXdoaXA6WzI1NSwyMzksMjEzXSxwZWFjaHB1ZmY6WzI1NSwyMTgsMTg1XSxwZXJ1OlsyMDUsMTMzLDYzXSxwaW5rOlsyNTUsMTkyLDIwM10scGx1bTpbMjIxLDE2MCwyMjFdLHBvd2RlcmJsdWU6WzE3NiwyMjQsMjMwXSxwdXJwbGU6WzEyOCwwLDEyOF0scmViZWNjYXB1cnBsZTpbMTAyLDUxLDE1M10scmVkOlsyNTUsMCwwXSxyb3N5YnJvd246WzE4OCwxNDMsMTQzXSxyb3lhbGJsdWU6WzY1LDEwNSwyMjVdLHNhZGRsZWJyb3duOlsxMzksNjksMTldLHNhbG1vbjpbMjUwLDEyOCwxMTRdLHNhbmR5YnJvd246WzI0NCwxNjQsOTZdLHNlYWdyZWVuOls0NiwxMzksODddLHNlYXNoZWxsOlsyNTUsMjQ1LDIzOF0sc2llbm5hOlsxNjAsODIsNDVdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLHNreWJsdWU6WzEzNSwyMDYsMjM1XSxzbGF0ZWJsdWU6WzEwNiw5MCwyMDVdLHNsYXRlZ3JheTpbMTEyLDEyOCwxNDRdLHNsYXRlZ3JleTpbMTEyLDEyOCwxNDRdLHNub3c6WzI1NSwyNTAsMjUwXSxzcHJpbmdncmVlbjpbMCwyNTUsMTI3XSxzdGVlbGJsdWU6WzcwLDEzMCwxODBdLHRhbjpbMjEwLDE4MCwxNDBdLHRlYWw6WzAsMTI4LDEyOF0sdGhpc3RsZTpbMjE2LDE5MSwyMTZdLHRvbWF0bzpbMjU1LDk5LDcxXSx0dXJxdW9pc2U6WzY0LDIyNCwyMDhdLHZpb2xldDpbMjM4LDEzMCwyMzhdLHdoZWF0OlsyNDUsMjIyLDE3OV0sd2hpdGU6WzI1NSwyNTUsMjU1XSx3aGl0ZXNtb2tlOlsyNDUsMjQ1LDI0NV0seWVsbG93OlsyNTUsMjU1LDBdLHllbGxvd2dyZWVuOlsxNTQsMjA1LDUwXX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO0wuZXhwb3J0cz1mdW5jdGlvbihsKXt2YXIgTTtyZXR1cm4gYS5jYWxsKGwpPT09IltvYmplY3QgT2JqZWN0XSImJihNPU9iamVjdC5nZXRQcm90b3R5cGVPZihsKSxNPT09bnVsbHx8TT09PU9iamVjdC5nZXRQcm90b3R5cGVPZih7fSkpfX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWlmKGFyZ3VtZW50c1t0XSE9PXZvaWQgMClyZXR1cm4gYXJndW1lbnRzW3RdfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMzgpO0wuZXhwb3J0cz17bmFtZToiaHNsIixtaW46WzAsMCwwXSxtYXg6WzM2MCwxMDAsMTAwXSxjaGFubmVsOlsiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyJdLGFsaWFzOlsiSFNMIl0scmdiOmZ1bmN0aW9uKGwpe3ZhciBNPWxbMF0vMzYwLFQ9bFsxXS8xMDAsZD1sWzJdLzEwMCx1LGMsTyxmLGc7aWYoVD09PTApcmV0dXJuIGc9ZCoyNTUsW2csZyxnXTtkPC41P2M9ZCooMStUKTpjPWQrVC1kKlQsdT0yKmQtYyxmPVswLDAsMF07Zm9yKHZhciB2PTA7djwzO3YrKylPPU0rMS8zKi0odi0xKSxPPDA/TysrOk8+MSYmTy0tLDYqTzwxP2c9dSsoYy11KSo2Kk86MipPPDE/Zz1jOjMqTzwyP2c9dSsoYy11KSooMi8zLU8pKjY6Zz11LGZbdl09ZyoyNTU7cmV0dXJuIGZ9fSxhLmhzbD1mdW5jdGlvbihsKXt2YXIgTT1sWzBdLzI1NSxUPWxbMV0vMjU1LGQ9bFsyXS8yNTUsdT1NYXRoLm1pbihNLFQsZCksYz1NYXRoLm1heChNLFQsZCksTz1jLXUsZixnLHY7cmV0dXJuIGM9PT11P2Y9MDpNPT09Yz9mPShULWQpL086VD09PWM/Zj0yKyhkLU0pL086ZD09PWMmJihmPTQrKE0tVCkvTyksZj1NYXRoLm1pbihmKjYwLDM2MCksZjwwJiYoZis9MzYwKSx2PSh1K2MpLzIsYz09PXU/Zz0wOnY8PS41P2c9Ty8oYyt1KTpnPU8vKDItYy11KSxbZixnKjEwMCx2KjEwMF19fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXtuYW1lOiJyZ2IiLG1pbjpbMCwwLDBdLG1heDpbMjU1LDI1NSwyNTVdLGNoYW5uZWw6WyJyZWQiLCJncmVlbiIsImJsdWUiXSxhbGlhczpbIlJHQiJdfX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9dDtmdW5jdGlvbiB0KGEsbCxNKXtyZXR1cm4gbDxNP2E8bD9sOmE+TT9NOmE6YTxNP006YT5sP2w6YX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTt2YXIgYT10KDQxKSxsPXQubihhKSxNPXQoNDIpLFQ9dC5uKE0pLGQ9dCg0MyksdT10Lm4oZCksYz10KDQ0KSxPPXQoNDYpLGY9dC5uKE8pLGc9dCg1Myksdj10KDU1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQz1TeW1ib2woImNvbnRvdXJzIikscD1TeW1ib2woInBhdGgiKSxoPVN5bWJvbCgic2ltcGxpZnkiKSxtPVN5bWJvbCgic2NhbGUiKSxyPTIqTWF0aC5QSTtjbGFzcyBpe2NvbnN0cnVjdG9yKHM9e30pe3R5cGVvZiBzPT0ic3RyaW5nIiYmKHM9e3BhdGg6c30pLHMucGF0aD90aGlzW3BdPWwoKShzLnBhdGgpOnRoaXNbcF09W10sdGhpc1tDXT1udWxsLHRoaXNbaF09cy5zaW1wbGlmeSE9bnVsbD9zLnNpbXBsaWZ5OjAsdGhpc1ttXT1zLnNjYWxlIT1udWxsP3Muc2NhbGU6Mn1nZXQgY29udG91cnMoKXtsZXQgcz1udWxsO2lmKCF0aGlzW0NdJiZ0aGlzW3BdKXtjb25zdCB4PU9iamVjdChjLmRlZmF1bHQpKHUoKSh0aGlzW3BdKSk7dGhpc1tDXT1mKCkoeCx0aGlzW21dLHRoaXNbaF0pLHRoaXNbQ10ucGF0aD14LHRoaXNbQ10uc2ltcGxpZnk9dGhpc1toXSx0aGlzW0NdLnNjYWxlPXRoaXNbbV19cmV0dXJuIHRoaXNbQ10mJihzPXRoaXNbQ10ubWFwKHg9PlsuLi54XSkscy5wYXRoPXRoaXNbQ10ucGF0aCxzLnNpbXBsaWZ5PXRoaXNbQ10uc2ltcGxpZnkscy5zY2FsZT10aGlzW0NdLnNjYWxlKSxzfWdldCBwYXRoKCl7cmV0dXJuIHRoaXNbcF19Z2V0IHNpbXBsaWZ5KCl7cmV0dXJuIHRoaXNbaF19Z2V0IGJvdW5kaW5nQm94KCl7Y29uc3Qgcz10aGlzLmNvbnRvdXJzO2lmKHMmJnMubGVuZ3RoKXtjb25zdCB4PXMucmVkdWNlKChQLFIpPT5bLi4uUCwuLi5SXSk7cmV0dXJuIFQoKSh4KX1yZXR1cm5bWzAsMF0sWzAsMF1dfWdldCBib3VuZGluZ0NlbnRlcigpe2NvbnN0IHM9dGhpcy5ib3VuZGluZ0JveDtyZXR1cm4gcz9bLjUqKHNbMF1bMF0rc1sxXVswXSksLjUqKHNbMF1bMV0rc1sxXVsxXSldOlswLDBdfW5vcm1hbGl6ZShzPTAseD0wKXtjb25zdCBQPU9iamVjdChjLmRlZmF1bHQpKHUoKSh0aGlzW3BdKSkubWFwKChbUiwuLi5iXSk9Pntjb25zdCBFPVtSXTtmb3IobGV0IEQ9MDtEPGIubGVuZ3RoO0QrPTIpe2NvbnN0IEk9YltEXS1zLFM9YltEKzFdLXg7RS5wdXNoKEksUyl9cmV0dXJuIEV9KTtyZXR1cm4gdGhpcy5iZWdpblBhdGgoKSx0aGlzW3BdLnB1c2goLi4uUCksdGhpc31nZXRQb2ludEF0TGVuZ3RoKHMpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdChnLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbQ10scyk6bnVsbH1nZXRUb3RhbExlbmd0aCgpe3JldHVybiB0aGlzLmNvbnRvdXJzP09iamVjdChnLmdldFRvdGFsTGVuZ3RoKSh0aGlzW0NdKTowfWFkZFBhdGgocyl7dGhpc1tDXT1udWxsLHR5cGVvZiBzPT0ic3RyaW5nIiYmKHM9bCgpKHMpKSx0aGlzW3BdLnB1c2goLi4ucyl9YmVnaW5QYXRoKCl7dGhpc1twXT1bXSx0aGlzW0NdPW51bGx9Y2xlYXIoKXt0aGlzLmJlZ2luUGF0aCgpfWVsbGlwc2Uocyx4LFAsUixiLEUsRCxJPTApe2lmKEUrPWIsRCs9YixQPD0wfHxSPD0wfHxEPT09RSlyZXR1cm47RDxFJiYoRD1FK3IrKEQtRSklciksRC1FPnImJihEPUUrcik7Y29uc3QgUz1ELUU7Uz49ciYmKEQtPS4wMDEpO2xldCBBPXRoaXNbcF0ubGVuZ3RoPjAmJlM8cj8iTCI6Ik0iO2NvbnN0IFU9T2JqZWN0KHYuZ2V0UG9pbnQpKHMseCxQLFIsRSksSz1PYmplY3Qodi5nZXRQb2ludCkocyx4LFAsUixEKSxWPSshSTtsZXQgSj1TPk1hdGguUEk/MTowO0kmJihKPTEtSiksQSs9VS5qb2luKCIgIiksQSs9YEEke1B9ICR7Un0gMCAke0p9ICR7Vn0gJHtLLmpvaW4oIiAiKX1gLFM+PXImJihBKz0iWiIpLHRoaXMuYWRkUGF0aChBKX1hcmMocyx4LFAsUixiLEU9MCl7cmV0dXJuIHRoaXMuZWxsaXBzZShzLHgsUCxQLDAsUixiLEUpfWFyY1RvKHMseCxQLFIsYixFLEQpe3RoaXNbQ109bnVsbCx0aGlzW3BdLnB1c2goWyJBIixzLHgsUCxSLGIsRSxEXSl9bW92ZVRvKHMseCl7dGhpc1tDXT1udWxsLHRoaXNbcF0ucHVzaChbIk0iLHMseF0pfWxpbmVUbyhzLHgpe3RoaXNbQ109bnVsbCx0aGlzW3BdLnB1c2goWyJMIixzLHhdKX1iZXppZXJDdXJ2ZVRvKHMseCxQLFIsYixFKXt0aGlzW0NdPW51bGwsdGhpc1twXS5wdXNoKFsiQyIscyx4LFAsUixiLEVdKX1xdWFkcmF0aWNDdXJ2ZVRvKHMseCxQLFIpe3RoaXNbQ109bnVsbCx0aGlzW3BdLnB1c2goWyJRIixzLHgsUCxSXSl9cmVjdChzLHgsUCxSKXtjb25zdCBiPWBNJHtzfSAke3h9TCR7cytQfSAke3h9TCR7cytQfSAke3grUn1MJHtzfSAke3grUn1aYDt0aGlzLmFkZFBhdGgoYil9Y2xvc2VQYXRoKCl7dGhpc1tDXT1udWxsO2xldCBzPVtdO2NvbnN0IHg9dGhpc1twXS5sZW5ndGg7eD4wJiYocz10aGlzW3BdW3gtMV0pLHNbMF0hPT0iWiImJnNbMF0hPT0ieiImJnRoaXNbcF0ucHVzaChbIloiXSl9fX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9bDt2YXIgdD17YTo3LGM6NixoOjEsbDoyLG06MixxOjQsczo0LHQ6Mix2OjEsejowfSxhPS8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWc7ZnVuY3Rpb24gbChkKXt2YXIgdT1bXTtyZXR1cm4gZC5yZXBsYWNlKGEsZnVuY3Rpb24oYyxPLGYpe3ZhciBnPU8udG9Mb3dlckNhc2UoKTtmb3IoZj1UKGYpLGc9PSJtIiYmZi5sZW5ndGg+MiYmKHUucHVzaChbT10uY29uY2F0KGYuc3BsaWNlKDAsMikpKSxnPSJsIixPPU89PSJtIj8ibCI6IkwiKTs7KXtpZihmLmxlbmd0aD09dFtnXSlyZXR1cm4gZi51bnNoaWZ0KE8pLHUucHVzaChmKTtpZihmLmxlbmd0aDx0W2ddKXRocm93IG5ldyBFcnJvcigibWFsZm9ybWVkIHBhdGggZGF0YSIpO3UucHVzaChbT10uY29uY2F0KGYuc3BsaWNlKDAsdFtnXSkpKX19KSx1fXZhciBNPS8tP1swLTldKlwuP1swLTldKyg/OmVbLStdP1xkKyk/L2lnO2Z1bmN0aW9uIFQoZCl7dmFyIHU9ZC5tYXRjaChNKTtyZXR1cm4gdT91Lm1hcChOdW1iZXIpOltdfX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz1hO2Z1bmN0aW9uIGEobCl7dmFyIE09bC5sZW5ndGg7aWYoTT09PTApcmV0dXJuW1tdLFtdXTtmb3IodmFyIFQ9bFswXS5sZW5ndGgsZD1sWzBdLnNsaWNlKCksdT1sWzBdLnNsaWNlKCksYz0xO2M8TTsrK2MpZm9yKHZhciBPPWxbY10sZj0wO2Y8VDsrK2Ype3ZhciBnPU9bZl07ZFtmXT1NYXRoLm1pbihkW2ZdLGcpLHVbZl09TWF0aC5tYXgodVtmXSxnKX1yZXR1cm5bZCx1XX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPXQ7ZnVuY3Rpb24gdChhKXt2YXIgbD0wLE09MCxUPTAsZD0wO3JldHVybiBhLm1hcChmdW5jdGlvbih1KXt1PXUuc2xpY2UoKTt2YXIgYz11WzBdLE89Yy50b1VwcGVyQ2FzZSgpO2lmKGMhPU8pc3dpdGNoKHVbMF09TyxjKXtjYXNlImEiOnVbNl0rPVQsdVs3XSs9ZDticmVhaztjYXNlInYiOnVbMV0rPWQ7YnJlYWs7Y2FzZSJoIjp1WzFdKz1UO2JyZWFrO2RlZmF1bHQ6Zm9yKHZhciBmPTE7Zjx1Lmxlbmd0aDspdVtmKytdKz1ULHVbZisrXSs9ZH1zd2l0Y2goTyl7Y2FzZSJaIjpUPWwsZD1NO2JyZWFrO2Nhc2UiSCI6VD11WzFdO2JyZWFrO2Nhc2UiViI6ZD11WzFdO2JyZWFrO2Nhc2UiTSI6VD1sPXVbMV0sZD1NPXVbMl07YnJlYWs7ZGVmYXVsdDpUPXVbdS5sZW5ndGgtMl0sZD11W3UubGVuZ3RoLTFdfXJldHVybiB1fSl9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIGE9dCg0NSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwoZCl7Zm9yKHZhciB1LGM9W10sTz0wLGY9MCxnPTAsdj0wLEM9bnVsbCxwPW51bGwsaD0wLG09MCxyPTAsaT1kLmxlbmd0aDtyPGk7cisrKXt2YXIgbj1kW3JdLHM9blswXTtzd2l0Y2gocyl7Y2FzZSJNIjpnPW5bMV0sdj1uWzJdO2JyZWFrO2Nhc2UiQSI6dmFyIHg9T2JqZWN0KGEuZGVmYXVsdCkoaCxtLG5bNl0sbls3XSxuWzRdLG5bNV0sblsxXSxuWzJdLG5bM10pO2lmKCF4Lmxlbmd0aCljb250aW51ZTt4PXgubWFwKEQ9Pntjb25zdFtJLFMsQSxVLEssVixKLHFdPUQ7cmV0dXJue3gxOkEseTE6VSx4MjpLLHkyOlYseDpKLHk6cX19KTtmb3IodmFyIFA9MCxSO1A8eC5sZW5ndGg7UCsrKVI9eFtQXSxuPVsiQyIsUi54MSxSLnkxLFIueDIsUi55MixSLngsUi55XSxQPHgubGVuZ3RoLTEmJmMucHVzaChuKTticmVhaztjYXNlIlMiOnZhciBiPWgsRT1tOyh1PT0iQyJ8fHU9PSJTIikmJihiKz1iLU8sRSs9RS1mKSxuPVsiQyIsYixFLG5bMV0sblsyXSxuWzNdLG5bNF1dO2JyZWFrO2Nhc2UiVCI6dT09IlEifHx1PT0iVCI/KEM9aCoyLUMscD1tKjItcCk6KEM9aCxwPW0pLG49VChoLG0sQyxwLG5bMV0sblsyXSk7YnJlYWs7Y2FzZSJRIjpDPW5bMV0scD1uWzJdLG49VChoLG0sblsxXSxuWzJdLG5bM10sbls0XSk7YnJlYWs7Y2FzZSJMIjpuPU0oaCxtLG5bMV0sblsyXSk7YnJlYWs7Y2FzZSJIIjpuPU0oaCxtLG5bMV0sbSk7YnJlYWs7Y2FzZSJWIjpuPU0oaCxtLGgsblsxXSk7YnJlYWs7Y2FzZSJaIjpuPU0oaCxtLGcsdik7YnJlYWt9dT1zLGg9bltuLmxlbmd0aC0yXSxtPW5bbi5sZW5ndGgtMV0sbi5sZW5ndGg+ND8oTz1uW24ubGVuZ3RoLTRdLGY9bltuLmxlbmd0aC0zXSk6KE89aCxmPW0pLGMucHVzaChuKX1yZXR1cm4gY31mdW5jdGlvbiBNKGQsdSxjLE8pe3JldHVyblsiQyIsZCx1LGMsTyxjLE9dfWZ1bmN0aW9uIFQoZCx1LGMsTyxmLGcpe3JldHVyblsiQyIsZC8zKzIvMypjLHUvMysyLzMqTyxmLzMrMi8zKmMsZy8zKzIvMypPLGYsZ119fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGE9TWF0aC5QSSoyO2Z1bmN0aW9uIGwodSxjLE8sZil7Y29uc3QgZz11KmYtYypPPDA/LTE6MTtsZXQgdj11Kk8rYypmO3JldHVybiB2PjEmJih2PTEpLHY8LTEmJih2PS0xKSxnKk1hdGguYWNvcyh2KX1mdW5jdGlvbiBNKHUsYyxPLGYsZyx2LEMscCxoLG0pe2NvbnN0IHI9bSoodS1PKS8yK2gqKGMtZikvMixpPS1oKih1LU8pLzIrbSooYy1mKS8yLG49QypDLHM9cCpwLHg9cipyLFA9aSppO2xldCBSPW4qcy1uKlAtcyp4O1I8MCYmKFI9MCksUi89bipQK3MqeCxSPU1hdGguc3FydChSKSooZz09PXY/LTE6MSk7Y29uc3QgYj1SKkMvcCppLEU9UiotcC9DKnIsRD1tKmItaCpFKyh1K08pLzIsST1oKmIrbSpFKyhjK2YpLzIsUz0oci1iKS9DLEE9KGktRSkvcCxVPSgtci1iKS9DLEs9KC1pLUUpL3AsVj1sKDEsMCxTLEEpO2xldCBKPWwoUyxBLFUsSyk7cmV0dXJuIHY9PT0wJiZKPjAmJihKLT1hKSx2PT09MSYmSjwwJiYoSis9YSksW0QsSSxWLEpdfWZ1bmN0aW9uIFQodSxjKXtjb25zdCBPPTEuMzMzMzMzMzMzMzMzMzMzMypNYXRoLnRhbihjLzQpLGY9TWF0aC5jb3ModSksZz1NYXRoLnNpbih1KSx2PU1hdGguY29zKHUrYyksQz1NYXRoLnNpbih1K2MpO3JldHVybltmLGcsZi1nKk8sZytmKk8sditDKk8sQy12Kk8sdixDXX1mdW5jdGlvbiBkKHUsYyxPLGYsZyx2LEMscCxoKXtjb25zdCBtPU1hdGguc2luKGgqYS8zNjApLHI9TWF0aC5jb3MoaCphLzM2MCksaT1yKih1LU8pLzIrbSooYy1mKS8yLG49LW0qKHUtTykvMityKihjLWYpLzI7aWYoaT09PTAmJm49PT0wKXJldHVybltdO2lmKEM9PT0wfHxwPT09MClyZXR1cm5bXTtDPU1hdGguYWJzKEMpLHA9TWF0aC5hYnMocCk7Y29uc3Qgcz1pKmkvKEMqQykrbipuLyhwKnApO3M+MSYmKEMqPU1hdGguc3FydChzKSxwKj1NYXRoLnNxcnQocykpO2NvbnN0IHg9TSh1LGMsTyxmLGcsdixDLHAsbSxyKSxQPVtdO2xldCBSPXhbMl0sYj14WzNdO2NvbnN0IEU9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKGIpLyhhLzQpKSwxKTtiLz1FO2ZvcihsZXQgRD0wO0Q8RTtEKyspUC5wdXNoKFQoUixiKSksUis9YjtyZXR1cm4gUC5tYXAoRD0+e2ZvcihsZXQgST0wO0k8RC5sZW5ndGg7SSs9Mil7bGV0IFM9RFtJKzBdLEE9RFtJKzFdO1MqPUMsQSo9cDtjb25zdCBVPXIqUy1tKkEsSz1tKlMrcipBO0RbSSswXT1VK3hbMF0sRFtJKzFdPUsreFsxXX1yZXR1cm4gRH0pfX0sZnVuY3Rpb24oTCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgYT10KDQ3KSx7Y29weTpsfT10KDQ5KSxNPXQoNTApO2Z1bmN0aW9uIFQoZixnLHYpe3JldHVybiBmWzBdPWcsZlsxXT12LGZ9dmFyIGQ9WzAsMF0sdT1bMCwwXSxjPVswLDBdO2Z1bmN0aW9uIE8oZixnLHYsQyl7YSh2LFQoZCxDWzFdLENbMl0pLFQodSxDWzNdLENbNF0pLFQoYyxDWzVdLENbNl0pLGcsZil9TC5leHBvcnRzPWZ1bmN0aW9uKGcsdixDKXt2YXIgcD1bXSxoPVtdLG09WzAsMF07cmV0dXJuIGcuZm9yRWFjaChmdW5jdGlvbihyLGksbil7aWYoclswXT09PSJNIilsKG0sci5zbGljZSgxKSksaC5sZW5ndGg+MCYmKHAucHVzaChoKSxoPVtdKTtlbHNlIGlmKHJbMF09PT0iQyIpTyhoLHYsbSxyKSxUKG0scls1XSxyWzZdKTtlbHNlIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCB0eXBlIGluIFNWRzogIityWzBdKX0pLGgubGVuZ3RoPjAmJnAucHVzaChoKSxwLm1hcChmdW5jdGlvbihyKXtyZXR1cm4gTShyLEN8fDApfSl9fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXQoNDgpKCl9LGZ1bmN0aW9uKEwsZSl7ZnVuY3Rpb24gdChsKXtyZXR1cm5bbFswXSxsWzFdXX1mdW5jdGlvbiBhKGwsTSl7cmV0dXJuW2wsTV19TC5leHBvcnRzPWZ1bmN0aW9uKE0pe009TXx8e307dmFyIFQ9dHlwZW9mIE0ucmVjdXJzaW9uPT0ibnVtYmVyIj9NLnJlY3Vyc2lvbjo4LGQ9dHlwZW9mIE0uZXBzaWxvbj09Im51bWJlciI/TS5lcHNpbG9uOjExOTIwOTI5ZS0xNCx1PXR5cGVvZiBNLnBhdGhFcHNpbG9uPT0ibnVtYmVyIj9NLnBhdGhFcHNpbG9uOjEsYz10eXBlb2YgTS5hbmdsZUVwc2lsb249PSJudW1iZXIiP00uYW5nbGVFcHNpbG9uOi4wMSxPPU0uYW5nbGVUb2xlcmFuY2V8fDAsZj1NLmN1c3BMaW1pdHx8MDtyZXR1cm4gZnVuY3Rpb24ocCxoLG0scixpLG4pe258fChuPVtdKSxpPXR5cGVvZiBpPT0ibnVtYmVyIj9pOjE7dmFyIHM9dS9pO3JldHVybiBzKj1zLGcocCxoLG0scixuLHMpLG59O2Z1bmN0aW9uIGcoQyxwLGgsbSxyLGkpe3IucHVzaCh0KEMpKTt2YXIgbj1DWzBdLHM9Q1sxXSx4PXBbMF0sUD1wWzFdLFI9aFswXSxiPWhbMV0sRT1tWzBdLEQ9bVsxXTt2KG4scyx4LFAsUixiLEUsRCxyLGksMCksci5wdXNoKHQobSkpfWZ1bmN0aW9uIHYoQyxwLGgsbSxyLGksbixzLHgsUCxSKXtpZighKFI+VCkpe3ZhciBiPU1hdGguUEksRT0oQytoKS8yLEQ9KHArbSkvMixJPShoK3IpLzIsUz0obStpKS8yLEE9KHIrbikvMixVPShpK3MpLzIsSz0oRStJKS8yLFY9KEQrUykvMixKPShJK0EpLzIscT0oUytVKS8yLFc9KEsrSikvMixIPShWK3EpLzI7aWYoUj4wKXt2YXIgWj1uLUMsdHQ9cy1wLF89TWF0aC5hYnMoKGgtbikqdHQtKG0tcykqWiksc3Q9TWF0aC5hYnMoKHItbikqdHQtKGktcykqWiksayxjdDtpZihfPmQmJnN0PmQpe2lmKChfK3N0KSooXytzdCk8PVAqKFoqWit0dCp0dCkpe2lmKE88Yyl7eC5wdXNoKGEoVyxIKSk7cmV0dXJufXZhciBmdD1NYXRoLmF0YW4yKGktbSxyLWgpO2lmKGs9TWF0aC5hYnMoZnQtTWF0aC5hdGFuMihtLXAsaC1DKSksY3Q9TWF0aC5hYnMoTWF0aC5hdGFuMihzLWksbi1yKS1mdCksaz49YiYmKGs9MipiLWspLGN0Pj1iJiYoY3Q9MipiLWN0KSxrK2N0PE8pe3gucHVzaChhKFcsSCkpO3JldHVybn1pZihmIT09MCl7aWYoaz5mKXt4LnB1c2goYShoLG0pKTtyZXR1cm59aWYoY3Q+Zil7eC5wdXNoKGEocixpKSk7cmV0dXJufX19fWVsc2UgaWYoXz5kKXtpZihfKl88PVAqKFoqWit0dCp0dCkpe2lmKE88Yyl7eC5wdXNoKGEoVyxIKSk7cmV0dXJufWlmKGs9TWF0aC5hYnMoTWF0aC5hdGFuMihpLW0sci1oKS1NYXRoLmF0YW4yKG0tcCxoLUMpKSxrPj1iJiYoaz0yKmItayksazxPKXt4LnB1c2goYShoLG0pKSx4LnB1c2goYShyLGkpKTtyZXR1cm59aWYoZiE9PTAmJms+Zil7eC5wdXNoKGEoaCxtKSk7cmV0dXJufX19ZWxzZSBpZihzdD5kKXtpZihzdCpzdDw9UCooWipaK3R0KnR0KSl7aWYoTzxjKXt4LnB1c2goYShXLEgpKTtyZXR1cm59aWYoaz1NYXRoLmFicyhNYXRoLmF0YW4yKHMtaSxuLXIpLU1hdGguYXRhbjIoaS1tLHItaCkpLGs+PWImJihrPTIqYi1rKSxrPE8pe3gucHVzaChhKGgsbSkpLHgucHVzaChhKHIsaSkpO3JldHVybn1pZihmIT09MCYmaz5mKXt4LnB1c2goYShyLGkpKTtyZXR1cm59fX1lbHNlIGlmKFo9Vy0oQytuKS8yLHR0PUgtKHArcykvMixaKlordHQqdHQ8PVApe3gucHVzaChhKFcsSCkpO3JldHVybn19dihDLHAsRSxELEssVixXLEgseCxQLFIrMSksdihXLEgsSixxLEEsVSxuLHMseCxQLFIrMSl9fX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZSIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJjbG9uZSIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJjb3B5IixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsInNjYWxlQW5kQWRkIixmdW5jdGlvbigpe3JldHVybiBkfSksdC5kKGUsImRvdCIsZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHQuZChlLCJyb3RhdGUiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiY3Jvc3MiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwic3ViIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFkZCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pLHQuZChlLCJjb21wdXRlTWl0ZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9KSx0LmQoZSwibm9ybWFsIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKGUsImRpcmVjdGlvbiIsZnVuY3Rpb24oKXtyZXR1cm4gcn0pO3ZhciBhPXQoMSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGwoaSl7cmV0dXJuW2lbMF0saVsxXV19ZnVuY3Rpb24gTSgpe3JldHVyblswLDBdfWNvbnN0IFQ9YS52ZWMyLmNvcHksZD1hLnZlYzIuc2NhbGVBbmRBZGQsdT1hLnZlYzIuZG90LGM9YS52ZWMyLnJvdGF0ZSxPPWEudmVjMi5jcm9zcyxmPWEudmVjMi5zdWIsZz1hLnZlYzIuYWRkLHY9YS52ZWMyLm5vcm1hbGl6ZSxDPWEudmVjMi5zZXQscD1NKCk7ZnVuY3Rpb24gaChpLG4scyx4LFApe2coaSxzLHgpLHYoaSxpKSxDKG4sLWlbMV0saVswXSksQyhwLC1zWzFdLHNbMF0pO2NvbnN0IFI9UC91KG4scCk7cmV0dXJuIE1hdGguYWJzKFIpfWZ1bmN0aW9uIG0oaSxuKXtyZXR1cm4gQyhpLC1uWzFdLG5bMF0pLGl9ZnVuY3Rpb24gcihpLG4scyl7cmV0dXJuIGYoaSxuLHMpLHYoaSxpKSxpfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoNTEpLGw9dCg1Mik7TC5leHBvcnRzPWZ1bmN0aW9uKFQsZCl7cmV0dXJuIFQ9YShULGQpLFQ9bChULGQpLFR9LEwuZXhwb3J0cy5yYWRpYWxEaXN0YW5jZT1hLEwuZXhwb3J0cy5kb3VnbGFzUGV1Y2tlcj1sfSxmdW5jdGlvbihMLGUpe2Z1bmN0aW9uIHQoYSxsKXt2YXIgTT1hWzBdLWxbMF0sVD1hWzFdLWxbMV07cmV0dXJuIE0qTStUKlR9TC5leHBvcnRzPWZ1bmN0aW9uKGwsTSl7aWYobC5sZW5ndGg8PTEpcmV0dXJuIGw7TT10eXBlb2YgTT09Im51bWJlciI/TToxO2Zvcih2YXIgVD1NKk0sZD1sWzBdLHU9W2RdLGMsTz0xLGY9bC5sZW5ndGg7TzxmO08rKyljPWxbT10sdChjLGQpPlQmJih1LnB1c2goYyksZD1jKTtyZXR1cm4gZCE9PWMmJnUucHVzaChjKSx1fX0sZnVuY3Rpb24oTCxlKXtmdW5jdGlvbiB0KGwsTSxUKXt2YXIgZD1NWzBdLHU9TVsxXSxjPVRbMF0tZCxPPVRbMV0tdTtpZihjIT09MHx8TyE9PTApe3ZhciBmPSgobFswXS1kKSpjKyhsWzFdLXUpKk8pLyhjKmMrTypPKTtmPjE/KGQ9VFswXSx1PVRbMV0pOmY+MCYmKGQrPWMqZix1Kz1PKmYpfXJldHVybiBjPWxbMF0tZCxPPWxbMV0tdSxjKmMrTypPfWZ1bmN0aW9uIGEobCxNLFQsZCx1KXtmb3IodmFyIGM9ZCxPLGY9TSsxO2Y8VDtmKyspe3ZhciBnPXQobFtmXSxsW01dLGxbVF0pO2c+YyYmKE89ZixjPWcpfWM+ZCYmKE8tTT4xJiZhKGwsTSxPLGQsdSksdS5wdXNoKGxbT10pLFQtTz4xJiZhKGwsTyxULGQsdSkpfUwuZXhwb3J0cz1mdW5jdGlvbihNLFQpe2lmKE0ubGVuZ3RoPD0xKXJldHVybiBNO1Q9dHlwZW9mIFQ9PSJudW1iZXIiP1Q6MTt2YXIgZD1UKlQsdT1NLmxlbmd0aC0xLGM9W01bMF1dO3JldHVybiBhKE0sMCx1LGQsYyksYy5wdXNoKE1bdV0pLGN9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJnZXRUb3RhbExlbmd0aCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJnZXRQb2ludEF0TGVuZ3RoIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImdldERhc2hDb250b3VycyIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBhPXQoNTQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKHUpe2lmKHUudG90YWxMZW5ndGghPW51bGwpcmV0dXJuIHUudG90YWxMZW5ndGg7bGV0IGM9MDtyZXR1cm4gdS5mb3JFYWNoKE89PntsZXQgZj1PWzBdO2ZvcihsZXQgZz0xO2c8Ty5sZW5ndGg7ZysrKXtjb25zdCB2PU9bZ107Yys9T2JqZWN0KGEuZGlzdGFuY2UpKGYsdiksZj12fX0pLHUudG90YWxMZW5ndGg9YyxjfWZ1bmN0aW9uIE0odSxjLE89ITApe2lmKGM9TnVtYmVyKGMpLCFOdW1iZXIuaXNGaW5pdGUoYykpdGhyb3cgbmV3IFR5cGVFcnJvcigiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFBvaW50QXRMZW5ndGgnIG9uIGZpZ3VyZTogVGhlIHByb3ZpZGVkIGZsb2F0IHZhbHVlIGlzIG5vbi1maW5pdGUuIik7aWYoYzw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJMZW5ndGggbXVzdCA+IDAiKTtjb25zdCBmPWwodSk7aWYoYz49Zil7Y29uc3Qgdj11W3UubGVuZ3RoLTFdLEM9dlt2Lmxlbmd0aC0yXSxwPXZbdi5sZW5ndGgtMV0saD1NYXRoLmF0YW4yKHBbMV0tQ1sxXSxwWzBdLUNbMF0pO3JldHVybntjdXJyZW50OnUubWFwKG09PlsuLi5tXSkscG9pbnQ6e3g6cFswXSx5OnBbMV0sYW5nbGU6aH19fWNvbnN0IGc9W107Zm9yKGxldCB2PTA7djx1Lmxlbmd0aDt2Kyspe2dbdl09W107Y29uc3QgQz11W3ZdO2xldCBwPUNbMF07Zm9yKGxldCBoPTE7aDxDLmxlbmd0aDtoKyspe2NvbnN0IG09Q1toXSxyPU9iamVjdChhLmRpc3RhbmNlKShwLG0pO2lmKGM8cil7Y29uc3QgaT1jL3Isbj1NYXRoLmF0YW4yKG1bMV0tcFsxXSxtWzBdLXBbMF0pLHM9e3g6cFswXSooMS1pKSttWzBdKmkseTpwWzFdKigxLWkpK21bMV0qaSxhbmdsZTpufTtpZihnW3ZdLnB1c2gocCksYz4wJiZnW3ZdLnB1c2goW3MueCxzLnldKSwhTylyZXR1cm57Y3VycmVudDpnLHBvaW50OnN9O2NvbnN0IHg9W10sUD12O2Zvcig7djx1Lmxlbmd0aDt2Kyspe2Zvcih4W3YtUF09W10sdj09PVAmJnhbMF0ucHVzaChbcy54LHMueV0pO2g8Qy5sZW5ndGg7aCsrKXhbdi1QXS5wdXNoKENbaF0pO2g9MH1yZXR1cm57Y3VycmVudDpnLHBvaW50OnMscmVzdDp4fX1jLT1yLGdbdl0ucHVzaChwKSxwPW19fX1mdW5jdGlvbiBUKHUsYyl7aWYoYz1OdW1iZXIoYyksIU51bWJlci5pc0Zpbml0ZShjKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UG9pbnRBdExlbmd0aCcgb24gZmlndXJlOiBUaGUgcHJvdmlkZWQgZmxvYXQgdmFsdWUgaXMgbm9uLWZpbml0ZS4iKTtpZih1Lmxlbmd0aDw9MClyZXR1cm57eDowLHk6MCxhbmdsZTowfTtpZihjPD0wKXtjb25zdCBPPXVbMF1bMF0sZj11WzBdWzFdLGc9TWF0aC5hdGFuMihmWzFdLU9bMV0sZlswXS1PWzBdKTtyZXR1cm57eDpPWzBdLHk6T1sxXSxhbmdsZTpnfX1yZXR1cm4gTSh1LGMsITEpLnBvaW50fWZ1bmN0aW9uIGQodSxjLE8pe2xldCBmPTAsZz1jWzBdLHY9dTtjb25zdCBDPVtdLHA9Yy5sZW5ndGg7aWYoTz4wKXtkbyBPLT1jW2YlcF0sZisrO3doaWxlKE8+MCk7TzwwJiYoZz0tTyxmLS0pfWVsc2UgaWYoTzwwKXtmPS0xO2RvIE8rPWNbZiVwK3AtMV0sZi0tO3doaWxlKE88MCk7Tz49MCYmKGYrKyxnPWNbZiVwK3AtMV0tTyl9ZG97Y29uc3QgaD1NKHYsZyk7dj1oLnJlc3QsKytmJTImJkMucHVzaCguLi5oLmN1cnJlbnQpO2xldCBtPWYlcDttPDAmJihtKz1wKSxnPWNbbV19d2hpbGUodik7cmV0dXJuIEN9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJub3JtYWxpemUiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0LmQoZSwiZGlzdGFuY2UiLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShbTSxULGRdLHUsYyxPKXtyZXR1cm4gTT1NKjIvdS0xLFQ9MS1UKjIvYyxOdW1iZXIuaXNGaW5pdGUoTyk/KGQ9ZCoyL08tMSxbTSxULGRdKTpbTSxUXX1mdW5jdGlvbiBsKFtNLFQsZD0wXSxbdSxjLE89MF0pe3JldHVybiBNYXRoLmh5cG90KHUtTSxjLVQsTy1kKX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImdldFBvaW50IixmdW5jdGlvbigpe3JldHVybiBsfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGE9TWF0aC5QSSoyO2Z1bmN0aW9uIGwoTSxULGQsdSxjKXtjJT1hLGM8MCYmKGMrPWEpO2NvbnN0IE89TWF0aC50YW4oYyk7aWYoTWF0aC5hYnMoTyk8MWU1KXtjb25zdCBmPVQtTypNLGc9MS9kKioyK08qKjIvdSoqMjtsZXQgdj0tMTsoYzw9TWF0aC5QSS8yfHxjPjMqTWF0aC5QSS8yKSYmKHY9MSk7Y29uc3QgQz12Kk1hdGguc3FydCgxL2cpK00scD1PKkMrZjtyZXR1cm5bQyxwXX1yZXR1cm4gYzxNYXRoLlBJP1tNLFQrdV06W00sVC11XX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIFl9KTt2YXIgYT10KDEpLGw9dCg0MiksTT10Lm4obCksVD10KDU3KSxkPXQoMjgpLHU9dCgyNCksYz10KDMwKSxPPXQoNTkpLGY9dCg1MyksZz10KDYwKSx2PXQubihnKSxDPXQoNDYpLHA9dC5uKEMpLGg9dCgzMSksbT10KDQwKSxyPXQoMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBpKFEsTil7aWYoUT09bnVsbClyZXR1cm57fTt2YXIgRz1uKFEsTiksbyx5O2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBqPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUSk7Zm9yKHk9MDt5PGoubGVuZ3RoO3krKylvPWpbeV0sIShOLmluZGV4T2Yobyk+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUSxvKSYmKEdbb109UVtvXSl9cmV0dXJuIEd9ZnVuY3Rpb24gbihRLE4pe2lmKFE9PW51bGwpcmV0dXJue307dmFyIEc9e30sbz1PYmplY3Qua2V5cyhRKSx5LGo7Zm9yKGo9MDtqPG8ubGVuZ3RoO2orKyl5PW9bal0sIShOLmluZGV4T2YoeSk+PTApJiYoR1t5XT1RW3ldKTtyZXR1cm4gR31jb25zdCBzPVN5bWJvbCgibWVzaCIpLHg9U3ltYm9sKCJjb250b3VycyIpLFA9U3ltYm9sKCJzdHJva2UiKSxSPVN5bWJvbCgiZmlsbCIpLGI9U3ltYm9sKCJzdHJva2VDb2xvciIpLEU9U3ltYm9sKCJmaWxsQ29sb3IiKSxEPVN5bWJvbCgidHJhbnNmb3JtIiksST1TeW1ib2woImludmVydFRyYW5zZm9ybSIpLFM9U3ltYm9sKCJ1bmlmb3JtcyIpLEE9U3ltYm9sKCJ0ZXhPcHRpb25zIiksVT1TeW1ib2woImJsZW5kIiksSz1TeW1ib2woImFwcGx5VGV4dHVyZSIpLFY9U3ltYm9sKCJhcHBseVRyYW5zZm9ybSIpLEo9U3ltYm9sKCJhcHBseUdyYWRpZW50VHJhbnNmb3JtIikscT1TeW1ib2woImFwcGx5UHJvZ3JhbSIpLFc9U3ltYm9sKCJncmFkaWVudCIpLEg9U3ltYm9sKCJmaWx0ZXIiKSxaPVN5bWJvbCgib3BhY2l0eSIpLHR0PVN5bWJvbCgicHJvZ3JhbSIpLF89U3ltYm9sKCJhdHRyaWJ1dGVzIiksc3Q9U3ltYm9sKCJwYXNzIiksaz1TeW1ib2woImNsaXBDb250ZXh0IiksY3Q9U3ltYm9sKCJhcHBseUNsaXBQYXRoIik7ZnVuY3Rpb24gZnQoUSxOKXtjb25zdFtHLG9dPVtRWzFdWzBdLVFbMF1bMF0sUVsxXVsxXS1RWzBdWzFdXSx5PVtdO2ZvcihsZXQgaj0wO2o8Ti5sZW5ndGg7aisrKXtjb25zdCB6PU5bal0sJD1bKHpbMF0tUVswXVswXSkvRywxLSh6WzFdLVFbMF1bMV0pL29dO3kucHVzaCgkKX1yZXR1cm4geX1mdW5jdGlvbiBCKFtRLE5dLFtHLG8seSxqXSx7c2NhbGU6en0pe3JldHVybiB6fHwoUS89eSxOPTEtTi9qLFEtPUcsTis9byksW1EsTiwwXX1mdW5jdGlvbiBGKFEsTixHKXtjb25zdCBvPXAoKShRLE4sRyk7cmV0dXJuIG8ucGF0aD1RLG8uc2ltcGxpZnk9RyxvLnNjYWxlPU4sb31jbGFzcyBZe2NvbnN0cnVjdG9yKE4pe3RoaXNbUF09bnVsbCx0aGlzW1JdPW51bGwsdGhpc1tEXT1bMSwwLDAsMSwwLDBdLHRoaXNbWl09MSx0aGlzW1NdPXt9LHRoaXNbSF09W10sdGhpc1tVXT1udWxsLHRoaXNbQV09e30sdGhpcy5jb250b3Vycz1OLmNvbnRvdXJzLHRoaXNbdHRdPW51bGwsdGhpc1tfXT17fSx0aGlzW3N0XT1bXX1nZXQgY29udG91cnMoKXtyZXR1cm4gdGhpc1t4XX1zZXQgY29udG91cnMoTil7dGhpc1tzXT1udWxsLHRoaXNbeF09Tjtjb25zdCBHPU4uc2NhbGU7dGhpcy50cmFuc2Zvcm1TY2FsZS9HPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKX1zZXRQcm9ncmFtKE4pe3RoaXNbdHRdPU4sdGhpc1tzXSYmdGhpc1txXShOKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW3R0XX1zZXRBdHRyaWJ1dGUoTixHKXtHPT1udWxsP2RlbGV0ZSB0aGlzW19dW05dOnRoaXNbX11bTl09R31nZXRPcGFjaXR5KCl7cmV0dXJuIHRoaXNbWl19c2V0T3BhY2l0eShOKXtpZihOPDB8fE4+MSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIG9wYWNpdHkgdmFsdWUuIik7dGhpc1tzXSYmdGhpc1tzXS5wb3NpdGlvbnMuZm9yRWFjaChHPT57R1syXT0xL0dbMl0+MD9OOi1OfSksdGhpc1taXT1OfXNldENsaXBQYXRoKE4pe3RoaXMuY2xpcFBhdGg9Tix0aGlzW1NdLnVfY2xpcFNhbXBsZXImJnRoaXNbU10udV9jbGlwU2FtcGxlci5kZWxldGUoKSx0aGlzLnNldFVuaWZvcm1zKHt1X2NsaXBTYW1wbGVyOm51bGx9KSx0aGlzW3NdJiZkZWxldGUgdGhpc1tzXS5hdHRyaWJ1dGVzLmFfY2xpcFVWLE4mJnRoaXNbc10mJnRoaXNbY3RdKCl9W2N0XSgpe2lmKHRoaXMuY2xpcFBhdGgpe3RoaXNba118fCh0aGlzW2tdPXIuZGVmYXVsdC5jcmVhdGVDYW52YXMoMSwxKSk7Y29uc3RbW04sR10sW28seV1dPXRoaXMuYm91bmRpbmdCb3g7byYmeSYmKHRoaXNba10ud2lkdGg9by1OLHRoaXNba10uaGVpZ2h0PXktRyk7Y29uc3Qgaj10aGlzW2tdLmdldENvbnRleHQoIjJkIiksej1uZXcgUGF0aDJEKHRoaXMuY2xpcFBhdGgpO2ouY2xlYXJSZWN0KDAsMCx0aGlzW2tdLndpZHRoLHRoaXNba10uaGVpZ2h0KSxqLnNhdmUoKSxqLnRyYW5zbGF0ZSgtTiwtRyksai5maWxsU3R5bGU9IndoaXRlIixqLmZpbGwoeiksai5yZXN0b3JlKCksdGhpc1tzXS5jbGlwUGF0aD10aGlzW2tdO2NvbnN0ICQ9ZnQodGhpcy5ib3VuZGluZ0JveCx0aGlzW3NdLnBvc2l0aW9uMCk7dGhpc1tzXS5hdHRyaWJ1dGVzLmFfY2xpcFVWPSR9fWdldFBvaW50QXRMZW5ndGgoTil7cmV0dXJuIE9iamVjdChmLmdldFBvaW50QXRMZW5ndGgpKHRoaXNbeF0sTil9Z2V0VG90YWxMZW5ndGgoKXtyZXR1cm4gT2JqZWN0KGYuZ2V0VG90YWxMZW5ndGgpKHRoaXNbeF0pfWdldCBibGVuZCgpe3JldHVybiB0aGlzW1VdPT1udWxsPyJhdXRvIjp0aGlzW1VdfXNldCBibGVuZChOKXt0aGlzW1VdPU4sdGhpc1tzXSYmKHRoaXNbc10uZW5hYmxlQmxlbmQ9dGhpcy5lbmFibGVCbGVuZCl9Z2V0IGJvdW5kaW5nQm94KCl7aWYodGhpc1tzXSYmdGhpc1tzXS5ib3VuZGluZ0JveClyZXR1cm4gdGhpc1tzXS5ib3VuZGluZ0JveDtjb25zdCBOPXRoaXMubWVzaERhdGE7aWYoTil7Y29uc3QgRz1OLnBvc2l0aW9uMDtpZihHLmxlbmd0aClOLmJvdW5kaW5nQm94PU0oKShHKTtlbHNlIHJldHVybltbMCwwXSxbMCwwXV07cmV0dXJuIE4uYm91bmRpbmdCb3h9cmV0dXJuW1swLDBdLFswLDBdXX1nZXQgYm91bmRpbmdDZW50ZXIoKXtjb25zdCBOPXRoaXMuYm91bmRpbmdCb3g7cmV0dXJuIE4/Wy41KihOWzBdWzBdK05bMV1bMF0pLC41KihOWzBdWzFdK05bMV1bMV0pXTpbMCwwXX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1tSXT90aGlzW1JdLnJ1bGU6Im5vbnplcm8ifWdldCBsaW5lV2lkdGgoKXtyZXR1cm4gdGhpc1tQXT90aGlzW1BdLmxpbmVXaWR0aDowfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5saW5lQ2FwOiIifWdldCBsaW5lSm9pbigpe3JldHVybiB0aGlzW1BdP3RoaXNbUF0ubGluZUpvaW46IiJ9Z2V0IG1pdGVyTGltaXQoKXtyZXR1cm4gdGhpc1tQXT90aGlzW1BdLm1pdGVyTGltaXQ6MH1nZXQgc3Ryb2tlU3R5bGUoKXtyZXR1cm4gdGhpc1tiXSYmdGhpc1tiXVszXSE9PTA/T2JqZWN0KHUuZGVmYXVsdCkodGhpc1tiXSk6IiJ9Z2V0IGxpbmVEYXNoKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5saW5lRGFzaDpudWxsfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW1BdP3RoaXNbUF0ubGluZURhc2hPZmZzZXQ6MH1nZXQgZmlsbFN0eWxlKCl7cmV0dXJuIHRoaXNbRV0mJnRoaXNbRV1bM10hPT0wP09iamVjdCh1LmRlZmF1bHQpKHRoaXNbRV0pOiIifWdldCBncmFkaWVudCgpe3JldHVybiB0aGlzW1ddfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbU10udV90ZXhTYW1wbGVyP3tpbWFnZTp0aGlzW1NdLnVfdGV4U2FtcGxlci5faW1nLG9wdGlvbnM6dGhpc1tBXX06bnVsbH1nZXQgZW5hYmxlQmxlbmQoKXtyZXR1cm4gdGhpc1tVXT09PSEwfHx0aGlzW1VdPT09ITE/dGhpc1tVXTp0aGlzW1pdPDF8fHRoaXNbYl0hPW51bGwmJnRoaXNbYl1bM108MXx8dGhpc1tFXSE9bnVsbCYmdGhpc1tFXVszXTwxfHx0aGlzW1NdLnVfY29sb3JNYXRyaXghPW51bGwmJnRoaXNbU10udV9jb2xvck1hdHJpeFsxOF08MXx8dGhpc1tTXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yIT1udWxsfHx0aGlzLmJlZm9yZVJlbmRlcnx8dGhpcy5hZnRlclJlbmRlcn1nZXQgZmlsdGVyQ2FudmFzKCl7cmV0dXJuL2JsdXJ8ZHJvcC1zaGFkb3d8dXJsLy50ZXN0KHRoaXMuZmlsdGVyKX1nZXQgZmlsdGVyKCl7cmV0dXJuIHRoaXNbSF0uam9pbigiICIpfWdldCB0cmFuc2Zvcm1NYXRyaXgoKXtyZXR1cm4gdGhpc1tEXX1nZXQgaW52ZXJ0TWF0cml4KCl7aWYoIXRoaXNbSV0pe2NvbnN0IE49YS5tYXQyZC5pbnZlcnQoQXJyYXkub2YoMCwwLDAsMCwwLDApLHRoaXNbRF0pO3RoaXNbSV09Tn1yZXR1cm4gdGhpc1tJXX1nZXQgdHJhbnNmb3JtU2NhbGUoKXtjb25zdCBOPXRoaXNbRF07cmV0dXJuIE1hdGgubWF4KE1hdGguaHlwb3QoTlswXSxOWzFdKSxNYXRoLmh5cG90KE5bMl0sTlszXSkpfWdldCB1bmlmb3Jtcygpe3JldHVybiB0aGlzW1NdfWdldCBwYXNzKCl7cmV0dXJuIHRoaXNbc3RdfVtxXShOKXtjb25zdCBHPXRoaXNbX10sbz10aGlzW3NdLnBvc2l0aW9uMCx5PU9iamVjdC5lbnRyaWVzKE4uX2F0dHJpYnV0ZSk7Zm9yKGxldCBqPTA7ajx5Lmxlbmd0aDtqKyspe2NvbnN0W3osJF09eVtqXTtpZih6IT09ImFfY29sb3IiJiZ6IT09ImFfc291cmNlUmVjdCImJiQhPT0iaWdub3JlZCIpe2NvbnN0IFg9R1t6XTtpZih6PT09InV2IiYmIVgpe2NvbnN0IHc9dGhpc1tzXS5ib3VuZGluZ0JveHx8TSgpKG8pO3RoaXNbc10uYXR0cmlidXRlc1t6XT1mdCh3LG8pfWVsc2V7dGhpc1tzXS5hdHRyaWJ1dGVzW3pdPVtdO2ZvcihsZXQgdz0wO3c8by5sZW5ndGg7dysrKXtjb25zdCBldD1vW3ddO3RoaXNbc10uYXR0cmlidXRlc1t6XS5wdXNoKFg/WChldCxqLG8pOkFycmF5KCQuc2l6ZSkuZmlsbCgwKSl9fX19fWdldCBtZXNoRGF0YSgpe2lmKHRoaXMuX3VwZGF0ZU1hdHJpeCYmdGhpcy50cmFuc2Zvcm1TY2FsZS90aGlzLmNvbnRvdXJzLnNjYWxlPjEuNSYmdGhpcy5hY2N1cmF0ZSh0aGlzLnRyYW5zZm9ybVNjYWxlKSwhdGhpc1tzXSl7IXRoaXNbUl0mJiF0aGlzW1BdJiZ0aGlzLnNldEZpbGwoKTtjb25zdCBOPXRoaXNbeF0sRz17fTtpZihOJiZOLmxlbmd0aCl7aWYodGhpc1tSXSl0cnl7Y29uc3Qgaj12KCkoTix0aGlzW1JdKTtqLnBvc2l0aW9ucz1qLnBvc2l0aW9ucy5tYXAoej0+KHoucHVzaCh0aGlzW1pdKSx6KSksai5hdHRyaWJ1dGVzPXthX2NvbG9yOkFycmF5LmZyb20oe2xlbmd0aDpqLnBvc2l0aW9ucy5sZW5ndGh9KS5tYXAoKCk9PnRoaXNbRV0ubWFwKHo9Pk1hdGgucm91bmQoMjU1KnopKSl9LEcuZmlsbD1qfWNhdGNoe31pZih0aGlzW1BdKXtjb25zdCBqPXRoaXNbUF0ubGluZURhc2g7bGV0IHo9TjtpZihqKXtjb25zdCBYPXRoaXNbUF0ubGluZURhc2hPZmZzZXQ7ej1PYmplY3QoZi5nZXREYXNoQ29udG91cnMpKE4saixYKX1jb25zdCAkPXoubWFwKChYLHcpPT57Y29uc3QgZXQ9WC5sZW5ndGg+MSYmYS52ZWMyLmVxdWFscyhYWzBdLFhbWC5sZW5ndGgtMV0pLHJ0PXRoaXNbUF0uYnVpbGQoWCxldCk7cmV0dXJuIHYoKShbcnRdKX0pOyQuZm9yRWFjaChYPT57WC5wb3NpdGlvbnM9WC5wb3NpdGlvbnMubWFwKHc9Pih3LnB1c2goLXRoaXNbWl0pLHcpKSxYLmF0dHJpYnV0ZXM9e2FfY29sb3I6QXJyYXkuZnJvbSh7bGVuZ3RoOlgucG9zaXRpb25zLmxlbmd0aH0pLm1hcCgoKT0+dGhpc1tiXS5tYXAodz0+TWF0aC5yb3VuZCgyNTUqdykpKX19KSxHLnN0cm9rZT1PYmplY3QoZC5kZWZhdWx0KSgkKX19Y29uc3Qgbz1PYmplY3QoZC5kZWZhdWx0KShbRy5maWxsLEcuc3Ryb2tlXSk7by5maWxsUG9pbnRDb3VudD1HLmZpbGw/Ry5maWxsLnBvc2l0aW9ucy5sZW5ndGg6MCxvLmVuYWJsZUJsZW5kPXRoaXMuZW5hYmxlQmxlbmQsby5wb3NpdGlvbjA9by5wb3NpdGlvbnMubWFwKChbaix6LCRdKT0+W2oseiwkXSksby51bmlmb3Jtcz10aGlzW1NdLHRoaXNbc109byx0aGlzW1NdLnVfdGV4U2FtcGxlciYmdGhpc1tLXShvLHRoaXNbQV0pO2NvbnN0IHk9dGhpc1tEXTtPYmplY3QoTy5pc1VuaXRUcmFuc2Zvcm0pKHkpfHwodGhpc1tWXShvLHkpLHRoaXNbU10udV9yYWRpYWxHcmFkaWVudFZlY3RvciYmdGhpc1tKXSgpKSx0aGlzLmNsaXBQYXRoJiZ0aGlzW2N0XSgpLHRoaXNbdHRdJiZ0aGlzW3FdKHRoaXNbdHRdKX1yZXR1cm4gdGhpcy5fdXBkYXRlTWF0cml4JiYodGhpc1tzXS5tYXRyaXg9dGhpc1tEXSx0aGlzW1ZdKHRoaXNbc10sdGhpc1tEXSksdGhpc1tTXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yJiZ0aGlzW0pdKCkpLHRoaXNbc119W1ZdKE4sRyl7Y29uc3R7cG9zaXRpb25zOm8scG9zaXRpb24wOnl9PU47Zm9yKGxldCBqPTA7ajxvLmxlbmd0aDtqKyspe2NvbnN0W3osJF09eVtqXSxYPW9bal07WFswXT16KkdbMF0rJCpHWzJdK0dbNF0sWFsxXT16KkdbMV0rJCpHWzNdK0dbNV19dGhpcy5fdXBkYXRlTWF0cml4PSExfVtKXSgpe2NvbnN0IE49dGhpc1tEXSxHPVsuLi50aGlzLl9yYWRpYWxHcmFkaWVudFZlY3Rvcl07aWYoRyl7Y29uc3Rbbyx5LCxqLHpdPUc7R1swXT1vKk5bMF0reSpOWzJdK05bNF0sR1sxXT1vKk5bMV0reSpOWzNdK05bNV0sR1szXT1qKk5bMF0reipOWzJdK05bNF0sR1s0XT1qKk5bMV0reipOWzNdK05bNV0sdGhpc1tTXS51X3JhZGlhbEdyYWRpZW50VmVjdG9yPUd9fVtLXShOLEcpe2Z1bmN0aW9uIG8odyxldCl7cmV0dXJuIHc9PW51bGwmJmV0PT1udWxsPyEwOnc9PW51bGx8fGV0PT1udWxsPyExOndbMF09PT1ldFswXSYmd1sxXT09PWV0WzFdJiZ3WzJdPT09ZXRbMl0mJndbM109PT1ldFszXX1jb25zdCB5PXRoaXNbU10udV90ZXhTYW1wbGVyO2lmKCF5KXJldHVybjtjb25zdHt3aWR0aDpqLGhlaWdodDp6fT15Ll9pbWcsJD1HLnNyY1JlY3Q7bGV0IFg9Ry5yZWN0fHxbMCwwXTtpZihHLnJvdGF0ZWQmJihYPVstWFsxXSxYWzBdLFhbM10sWFsyXV0pLFhbMl09PW51bGwmJihYWzJdPSQ/JFsyXTpqKSxYWzNdPT1udWxsJiYoWFszXT0kPyRbM106eiksRy5oaWRkZW4pTi50ZXh0dXJlQ29vcmQ9Ti5wb3NpdGlvbnMubWFwKCgpPT5bLTEsLTEsLTFdKTtlbHNlIGlmKCFOLnRleHR1cmVDb29yZHx8IW8odGhpc1tBXS5yZWN0LEcucmVjdCl8fHRoaXNbQV0uaGlkZGVuIT09Ry5oaWRkZW58fHRoaXNbQV0ucm90YXRlZCE9PUcucm90YXRlZCl7bGV0IHc9bnVsbDtHLnJvdGF0ZWQmJih3PWEubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxhLm1hdDJkLmZyb21WYWx1ZXMoMSwwLDAsMSwwLDApLC41Kk1hdGguUEkpLHc9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHcsWzAsLVhbMl1dKSksTi50ZXh0dXJlQ29vcmQ9Ti5wb3NpdGlvbjAubWFwKChbZXQscnQsYXRdKT0+e2lmKDEvYXQ+MCl7aWYoRy5yb3RhdGVkKXtjb25zdCBpdD1ldCp3WzBdK3J0KndbMl0rd1s0XSxudD1ldCp3WzFdK3J0KndbM10rd1s1XTtbZXQscnRdPVtpdCxudF19Y29uc3QgbHQ9QihbZXQscnRdLFtYWzBdL1hbMl0sWFsxXS9YWzNdLFhbMl0sWFszXV0sRyk7cmV0dXJuIEcucmVwZWF0JiYobHRbMl09MSksbHR9cmV0dXJuWy0xLC0xLC0xXX0pfWlmKCQpe2NvbnN0IHc9WyRbMF0vaiwkWzFdL3osJFsyXS9qLCRbM10vel07Ti5hdHRyaWJ1dGVzLmFfc291cmNlUmVjdD1OLnBvc2l0aW9ucy5tYXAoKCk9PlsuLi53XSl9ZWxzZSBOLmF0dHJpYnV0ZXMuYV9zb3VyY2VSZWN0PU4ucG9zaXRpb25zLm1hcCgoKT0+WzAsMCwwLDBdKX1hY2N1cmF0ZShOKXtpZighdGhpcy5jb250b3VycylyZXR1cm47aWYodGhpcy5jb250b3Vycy5wYXRoKXtjb25zdCBvPXRoaXMuY29udG91cnMuc2ltcGxpZnkseT1GKHRoaXMuY29udG91cnMucGF0aCwyKk4sbyk7dGhpc1tzXT1udWxsLHRoaXNbeF09eX19Y2FuSWdub3JlKCl7Y29uc3QgTj10aGlzW1BdPT1udWxsfHx0aGlzW1BdLmxpbmVXaWR0aD09PTB8fHRoaXNbYl1bM109PT0wLEc9dGhpc1tSXT09bnVsbHx8dGhpc1tFXVszXT09PTAsbz10aGlzW1NdLnVfcmFkaWFsR3JhZGllbnRWZWN0b3I9PW51bGwseT10aGlzW1NdLnVfdGV4U2FtcGxlcj09bnVsbDtyZXR1cm4gdGhpc1taXT09PTB8fHRoaXNbdHRdPT1udWxsJiZOJiZHJiZvJiZ5JiYhdGhpcy5iZWZvcmVSZW5kZXImJiF0aGlzLmFmdGVyUmVuZGVyfXNldFN0cm9rZSh7dGhpY2tuZXNzOk49MSxjYXA6Rz0iYnV0dCIsam9pbjpvPSJtaXRlciIsbWl0ZXJMaW1pdDp5PTEwLGNvbG9yOmo9WzAsMCwwLDBdLGxpbmVEYXNoOno9bnVsbCxsaW5lRGFzaE9mZnNldDokPTAscm91bmRTZWdtZW50czpYPTIwfT17fSl7cmV0dXJuIHRoaXNbc109bnVsbCx0aGlzW1BdPW5ldyBULmRlZmF1bHQoe2xpbmVXaWR0aDpOLGxpbmVDYXA6RyxsaW5lSm9pbjpvLG1pdGVyTGltaXQ6eSxyb3VuZFNlZ21lbnRzOlh9KSx0eXBlb2Ygaj09InN0cmluZyImJihqPU9iamVjdChoLmRlZmF1bHQpKGopKSx0aGlzW2JdPWosdGhpc1tQXS5saW5lRGFzaD16LHRoaXNbUF0ubGluZURhc2hPZmZzZXQ9JCx0aGlzfXNldEZpbGwoe3J1bGU6Tj10aGlzLmZpbGxSdWxlLGNvbG9yOkc9WzAsMCwwLDBdfT17fSl7cmV0dXJuIHRoaXNbc109bnVsbCx0aGlzW1JdPXtydWxlOk59LHR5cGVvZiBHPT0ic3RyaW5nIiYmKEc9T2JqZWN0KGguZGVmYXVsdCkoRykpLHRoaXNbRV09Ryx0aGlzfXNldFRleHR1cmUoTixHPXt9KXtpZihOJiZOLmltYWdlKXtjb25zdHtpbWFnZTpvLHJlY3Q6eX09TjtpZihOPW8sRy5yZWN0KWZvcihsZXQgaj0wO2o8Ry5yZWN0Lmxlbmd0aDtqKyspeVtqXT1HLnJlY3Rbal07Ry5yZWN0PXl9cmV0dXJuIHRoaXNbUl18fHRoaXMuc2V0RmlsbCgpLHRoaXMuc2V0VW5pZm9ybXMoe3VfdGV4U2FtcGxlcjpOfSksdGhpc1tzXSYmdGhpc1tLXSh0aGlzW3NdLEcpLHRoaXNbQV09Ryx0aGlzfXNldENpcmN1bGFyR3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczpHLHR5cGU6bz0iZmlsbCJ9PXt9KXtpZihOLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBsaW5lYXJHcmFkaWVudC4iKTt0aGlzLnNldEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6Ryx0eXBlOm99KX1zZXRMaW5lYXJHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOkcsdHlwZTpvPSJmaWxsIn09e30pe2lmKE4ubGVuZ3RoIT09NCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVhckdyYWRpZW50LiIpO3RoaXMuc2V0R3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczpHLHR5cGU6b30pfXNldFJhZGlhbEdyYWRpZW50KHt2ZWN0b3I6Tixjb2xvcnM6Ryx0eXBlOm89ImZpbGwifT17fSl7aWYoTi5sZW5ndGghPT02KXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcmFkaWFsR3JhZGllbnQuIik7dGhpcy5zZXRHcmFkaWVudCh7dmVjdG9yOk4sY29sb3JzOkcsdHlwZTpvfSl9c2V0R3JhZGllbnQoe3ZlY3RvcjpOLGNvbG9yczpHLHR5cGU6bz0iZmlsbCJ9PXt9KXtHPUcubWFwKCh7b2Zmc2V0OnosY29sb3I6JH0pPT4odHlwZW9mICQ9PSJzdHJpbmciJiYoJD1PYmplY3QoaC5kZWZhdWx0KSgkKSkse29mZnNldDp6LGNvbG9yOiR9KSksdGhpc1tXXT10aGlzW1ddfHx7fSx0aGlzW1ddW29dPXt2ZWN0b3I6Tixjb2xvcnM6R30sRy5zb3J0KCh6LCQpPT56Lm9mZnNldC0kLm9mZnNldCk7Y29uc3QgeT1bXTtHLmZvckVhY2goKHtvZmZzZXQ6eixjb2xvcjokfSk9Pnt5LnB1c2goeiwuLi4kKX0pO2xldCBqO2lmKE4ubGVuZ3RoPT09ND9qPVtOWzBdLE5bMV0sMCxOWzJdLE5bM10sMF06aj1bLi4uTl0seS5sZW5ndGg8NDAmJnkucHVzaCgtMSkseS5sZW5ndGg+NDApdGhyb3cgbmV3IEVycm9yKCJUb28gbWFueSBjb2xvcnMsIHNob3VsZCBiZSBsZXNzIHRoYW4gOCBjb2xvcnMiKTtyZXR1cm4gdGhpcy5fcmFkaWFsR3JhZGllbnRWZWN0b3I9aix0aGlzW1NdLnVfY29sb3JTdGVwcz15LG89PT0iZmlsbCI/dGhpc1tTXS51X2dyYWRpZW50VHlwZT0xOnRoaXNbU10udV9ncmFkaWVudFR5cGU9MCx0aGlzW0pdKCksdGhpc31zZXRVbmlmb3JtcyhOPXt9KXtyZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzW1NdLE4pLHRoaXN9c2V0VHJhbnNmb3JtKC4uLk4pe2NvbnN0IEc9dGhpc1tEXTtyZXR1cm4gYS5tYXQyZC5lcXVhbHMoTixHKXx8KHRoaXNbRF09TixkZWxldGUgdGhpc1tJXSx0aGlzLl91cGRhdGVNYXRyaXg9ITApLHRoaXN9dHJhbnNmb3JtKC4uLk4pe2NvbnN0IEc9dGhpc1tEXTtyZXR1cm4gdGhpc1tEXT1hLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxHLE4pLGRlbGV0ZSB0aGlzW0ldLHRoaXMuX3VwZGF0ZU1hdHJpeD0hMCx0aGlzfXRyYW5zbGF0ZShOLEcpe2xldCBvPWEubWF0MmQuY3JlYXRlKCk7cmV0dXJuIG89YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLG8sW04sR10pLHRoaXMudHJhbnNmb3JtKC4uLm8pfXJvdGF0ZShOLFtHLG9dPVswLDBdKXtsZXQgeT1hLm1hdDJkLmNyZWF0ZSgpO3JldHVybiB5PWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx5LFtHLG9dKSx5PWEubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx5LE4pLHk9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLHksWy1HLC1vXSksdGhpcy50cmFuc2Zvcm0oLi4ueSl9c2NhbGUoTixHPU4sW28seV09WzAsMF0pe2xldCBqPWEubWF0MmQuY3JlYXRlKCk7cmV0dXJuIGo9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLGosW28seV0pLGo9YS5tYXQyZC5zY2FsZShBcnJheS5vZigwLDAsMCwwLDAsMCksaixbTixHXSksaj1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksaixbLW8sLXldKSx0aGlzLnRyYW5zZm9ybSguLi5qKX1za2V3KE4sRz1OLFtvLHldPVswLDBdKXtsZXQgaj1hLm1hdDJkLmNyZWF0ZSgpO3JldHVybiBqPWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxqLFtvLHldKSxqPWEubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLGosYS5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oRyksTWF0aC50YW4oTiksMSwwLDApKSxqPWEubWF0MmQudHJhbnNsYXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxqLFstbywteV0pLHRoaXMudHJhbnNmb3JtKC4uLmopfWNsZWFyRmlsdGVyKCl7cmV0dXJuIHRoaXMuc2V0Q29sb3JUcmFuc2Zvcm0obnVsbCksdGhpc1tIXS5sZW5ndGg9MCx0aGlzfXNldENvbG9yVHJhbnNmb3JtKC4uLk4pe3JldHVybiBOWzBdPT09bnVsbD90aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MCx1X2NvbG9yTWF0cml4OjB9KTp0aGlzLnNldFVuaWZvcm1zKHt1X2ZpbHRlckZsYWc6MSx1X2NvbG9yTWF0cml4Ok59KSx0aGlzfXRyYW5zZm9ybUNvbG9yKC4uLk4pe2xldCBHPXRoaXMudW5pZm9ybXMudV9jb2xvck1hdHJpeDtyZXR1cm4gRz9HPU9iamVjdChjLm11bHRpcGx5KShHLE4pOkc9Tix0aGlzLnNldENvbG9yVHJhbnNmb3JtKC4uLkcpLHRoaXN9Ymx1cihOKXtyZXR1cm4gdGhpc1tIXS5wdXNoKGBibHVyKCR7Tn1weClgKSx0aGlzfWJyaWdodG5lc3MoTj0xKXtyZXR1cm4gdGhpc1tIXS5wdXNoKGBicmlnaHRuZXNzKCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLmJyaWdodG5lc3MpKE4pKX1jb250cmFzdChOPTEpe3JldHVybiB0aGlzW0hdLnB1c2goYGNvbnRyYXN0KCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLmNvbnRyYXN0KShOKSl9ZHJvcFNoYWRvdyhOLEcsbz0wLHk9WzAsMCwwLDFdKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh5KSYmKHk9T2JqZWN0KHUuZGVmYXVsdCkoeSkpLHRoaXNbSF0ucHVzaChgZHJvcC1zaGFkb3coJHtOfXB4ICR7R31weCAke299cHggJHt5fSlgKSx0aGlzfWdyYXlzY2FsZShOPTEpe3JldHVybiB0aGlzW0hdLnB1c2goYGdyYXlzY2FsZSgkezEwMCpOfSUpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoYy5ncmF5c2NhbGUpKE4pKX1odWVSb3RhdGUoTj0wKXtyZXR1cm4gdGhpc1tIXS5wdXNoKGBodWUtcm90YXRlKCR7Tn1kZWcpYCksdGhpcy50cmFuc2Zvcm1Db2xvciguLi5PYmplY3QoYy5odWVSb3RhdGUpKE4pKX1pbnZlcnQoTj0xKXtyZXR1cm4gdGhpc1tIXS5wdXNoKGBpbnZlcnQoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMuaW52ZXJ0KShOKSl9b3BhY2l0eShOPTEpe3JldHVybiB0aGlzW0hdLnB1c2goYG9wYWNpdHkoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMub3BhY2l0eSkoTikpfXNhdHVyYXRlKE49MSl7cmV0dXJuIHRoaXNbSF0ucHVzaChgc2F0dXJhdGUoJHsxMDAqTn0lKWApLHRoaXMudHJhbnNmb3JtQ29sb3IoLi4uT2JqZWN0KGMuc2F0dXJhdGUpKE4pKX1zZXBpYShOPTEpe3JldHVybiB0aGlzW0hdLnB1c2goYHNlcGlhKCR7MTAwKk59JSlgKSx0aGlzLnRyYW5zZm9ybUNvbG9yKC4uLk9iamVjdChjLnNlcGlhKShOKSl9dXJsKE4pe3JldHVybiB0aGlzW0hdLnB1c2goYHVybCgke059KWApLHRoaXN9aXNQb2ludENvbGxpc2lvbihOLEcsbz0iYm90aCIpe2NvbnN0IHk9dGhpcy5tZXNoRGF0YSx7cG9zaXRpb25zOmosY2VsbHM6en09eSwkPXRoaXMuaW52ZXJ0TWF0cml4LFg9JFswXSpOKyRbMl0qRyskWzRdLHc9JFsxXSpOKyRbM10qRyskWzVdLGV0PXRoaXMuYm91bmRpbmdCb3g7aWYoWDxldFswXVswXXx8WD5ldFsxXVswXXx8dzxldFswXVsxXXx8dz5ldFsxXVsxXSlyZXR1cm4hMTtmdW5jdGlvbiBydChbYXQsbHRdLFtpdCxudF0sW290LGh0XSl7Y29uc3QgZHQ9b3QtaXQsdXQ9aHQtbnQsbXQ9KChhdC1pdCkqZHQrKGx0LW50KSp1dCkvKGR0KioyK3V0KioyKTtyZXR1cm4gbXQ+PTAmJm10PD0xfWZvcihsZXQgYXQ9MDthdDx6Lmxlbmd0aDthdCsrKXtjb25zdCBsdD16W2F0XTtpZihvPT09ImZpbGwiJiZsdFswXT49eS5maWxsUG9pbnRDb3VudClicmVhaztpZihvPT09InN0cm9rZSImJmx0WzBdPHkuZmlsbFBvaW50Q291bnQpY29udGludWU7Y29uc3RbW2l0LG50XSxbb3QsaHRdLFtkdCx1dF1dPWx0Lm1hcCh5dD0+alt5dF0pLG10PU1hdGguc2lnbigoTi1pdCkqKGh0LW50KS0ob3QtaXQpKihHLW50KSk7aWYobXQ9PT0wJiZydChbTixHXSxbaXQsbnRdLFtvdCxodF0pKXJldHVybiEwO2NvbnN0IE10PU1hdGguc2lnbigoTi1vdCkqKHV0LWh0KS0oZHQtb3QpKihHLWh0KSk7aWYoTXQ9PT0wJiZydChbTixHXSxbb3QsaHRdLFtkdCx1dF0pKXJldHVybiEwO2NvbnN0IHZ0PU1hdGguc2lnbigoTi1kdCkqKG50LXV0KS0oaXQtZHQpKihHLXV0KSk7aWYodnQ9PT0wJiZydChbTixHXSxbZHQsdXRdLFtpdCxudF0pfHxtdD09PTEmJk10PT09MSYmdnQ9PT0xfHxtdD09PS0xJiZNdD09PS0xJiZ2dD09PS0xKXJldHVybiEwfXJldHVybiExfWlzUG9pbnRJbkZpbGwoTixHKXtyZXR1cm4gdGhpcy5pc1BvaW50Q29sbGlzaW9uKE4sRywiZmlsbCIpfWlzUG9pbnRJblN0cm9rZShOLEcpe3JldHVybiB0aGlzLmlzUG9pbnRDb2xsaXNpb24oTixHLCJzdHJva2UiKX1hZGRQYXNzKE4sRz17fSl7bGV0e3dpZHRoOm8saGVpZ2h0Onl9PUcsaj1pKEcsWyJ3aWR0aCIsImhlaWdodCJdKTtjb25zdCB6PW5ldyBtLmRlZmF1bHQ7ei5yZWN0KDAsMCxvLHkpO2NvbnN0ICQ9bmV3IFkoeix7d2lkdGg6byxoZWlnaHQ6eX0pOyQuc2V0VW5pZm9ybXMoaiksJC5zZXRQcm9ncmFtKE4pLHRoaXNbc3RdLnB1c2goJCl9fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKTt2YXIgYT10KDU4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWEuU3Ryb2tlfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJTdHJva2UiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgYT10KDQ5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgbD1PYmplY3QoYS5jcmVhdGUpKCksTT1PYmplY3QoYS5jcmVhdGUpKCksVD1PYmplY3QoYS5jcmVhdGUpKCksZD1PYmplY3QoYS5jcmVhdGUpKCksdT1PYmplY3QoYS5jcmVhdGUpKCksYz0xZTIwO2NsYXNzIE97Y29uc3RydWN0b3Ioe2xpbmVXaWR0aDpwPTEsbGluZUpvaW46aD0ibWl0ZXIiLG1pdGVyTGltaXQ6bT0xMCxsaW5lQ2FwOnI9ImJ1dHQiLHJvdW5kU2VnbWVudHM6aT0yMH09e30pe3RoaXMubGluZVdpZHRoPXAsdGhpcy5saW5lSm9pbj1oLHRoaXMubWl0ZXJMaW1pdD1tLHRoaXMubGluZUNhcD1yLHRoaXMucm91bmRTZWdtZW50cz1pLHRoaXMuX25vcm1hbD1udWxsfWJ1aWxkKHAsaD0hMSl7bGV0IG09cC5sZW5ndGg7aWYocD1bLi4ucF0sbTwyKXJldHVybiBwO2gmJigocFswXVswXSE9PXBbbS0xXVswXXx8cFswXVsxXSE9PXBbbS0xXVsxXSkmJnAucHVzaChbLi4ucFswXV0pLHAucHVzaChbLi4ucFsxXV0pKSxtPXAubGVuZ3RoLHRoaXMuX25vcm1hbD1udWxsO2NvbnN0IHI9e2xlZnQ6W10scmlnaHQ6W119LGk9dGhpcy5saW5lV2lkdGgvMixuPXRoaXMubGluZUNhcDtpZighaCYmbj09PSJzcXVhcmUiKXtPYmplY3QoYS5kaXJlY3Rpb24pKE0scFswXSxwWzFdKSxPYmplY3QoYS5zY2FsZUFuZEFkZCkocFswXSxwWzBdLE0saSk7Y29uc3QgeD1wLmxlbmd0aC0xO09iamVjdChhLmRpcmVjdGlvbikoTSxwW3hdLHBbeC0xXSksT2JqZWN0KGEuc2NhbGVBbmRBZGQpKHBbeF0scFt4XSxNLGkpfWZvcihsZXQgeD0xO3g8bTt4Kyspe2NvbnN0IFA9cFt4LTFdLFI9cFt4XSxiPXBbeCsxXTt0aGlzLl9zZWcocixQLFIsYixpLGgpfXJldHVybiFoJiZuPT09InJvdW5kIiYmdihyLHRoaXMucm91bmRTZWdtZW50cyksWy4uLnIubGVmdCwuLi5yLnJpZ2h0LnJldmVyc2UoKV19X3NlZyhwLGgsbSxyLGksbil7Y29uc3Qgcz10aGlzLmxpbmVKb2luPT09ImJldmVsIix4PXRoaXMubGluZUpvaW49PT0icm91bmQiO2lmKE9iamVjdChhLmRpcmVjdGlvbikoTSxtLGgpLHRoaXMuX25vcm1hbHx8KHRoaXMuX25vcm1hbD1PYmplY3QoYS5jcmVhdGUpKCksT2JqZWN0KGEubm9ybWFsKSh0aGlzLl9ub3JtYWwsTSkpLHAubGVmdC5sZW5ndGh8fGcocCxoLHRoaXMuX25vcm1hbCxpKSwhcilPYmplY3QoYS5ub3JtYWwpKHRoaXMuX25vcm1hbCxNKSxuP2cocCxoLHRoaXMuX25vcm1hbCxpKTpnKHAsbSx0aGlzLl9ub3JtYWwsaSk7ZWxzZXtPYmplY3QoYS5kaXJlY3Rpb24pKFQscixtKTtsZXQgUD1PYmplY3QoYS5jb21wdXRlTWl0ZXIpKGQsdSxNLFQsaSk7UD1NYXRoLm1pbihQLGMpO2NvbnN0IFI9T2JqZWN0KGEuZG90KShkLHRoaXMuX25vcm1hbCk8MD8tMToxO2xldCBiPXN8fHg7aWYoIWImJnRoaXMubGluZUpvaW49PT0ibWl0ZXIiJiZQL2k+dGhpcy5taXRlckxpbWl0JiYoYj0hMCksYil7T2JqZWN0KGEuc2NhbGVBbmRBZGQpKGwsbSx0aGlzLl9ub3JtYWwsLWkqUiksZihwLGwsUik7bGV0IEU9MS8wO2gmJihFPU1hdGgubWluKEUsTWF0aC5oeXBvdChtWzBdLWhbMF0sbVsxXS1oWzFdKSkpLHImJihFPU1hdGgubWluKEUsTWF0aC5oeXBvdChyWzBdLW1bMF0sclsxXS1tWzFdKSkpO2NvbnN0IEQ9TWF0aC5tYXgoaSxNYXRoLm1pbihQLEUpKTtpZihPYmplY3QoYS5zY2FsZUFuZEFkZCkobCxtLHUsRCpSKSxmKHAsbCwtUikscilpZihPYmplY3QoYS5ub3JtYWwpKGwsVCksT2JqZWN0KGEuY29weSkodGhpcy5fbm9ybWFsLGwpLE9iamVjdChhLnNjYWxlQW5kQWRkKShsLG0sbCwtaSpSKSx4KXtjb25zdCBJPU9iamVjdChhLmNsb25lKShsKSxTPVI+MD9wLmxlZnRbcC5sZWZ0Lmxlbmd0aC0xXTpwLnJpZ2h0W3AucmlnaHQubGVuZ3RoLTFdLEE9T2JqZWN0KGEuY2xvbmUpKG0pLFU9T2JqZWN0KGEuc3ViKShPYmplY3QoYS5jcmVhdGUpKCksUyxBKSxLPU9iamVjdChhLnN1YikoT2JqZWN0KGEuY3JlYXRlKSgpLEksQSksVj1NYXRoLlBJL3RoaXMucm91bmRTZWdtZW50cztmb3IobGV0IEo9MDtKPHRoaXMucm91bmRTZWdtZW50cyYmKE9iamVjdChhLnJvdGF0ZSkoVSxVLFswLDBdLFIqViksTWF0aC5zaWduKE9iamVjdChhLmNyb3NzKShsLFUsSylbMl0pPT09Uik7SisrKU9iamVjdChhLmFkZCkobCxVLEEpLGYocCxsLFIpO2YocCxJLFIpfWVsc2UgZihwLGwsUil9ZWxzZSBnKHAsbSx1LFApLE9iamVjdChhLmNvcHkpKHRoaXMuX25vcm1hbCx1KX19fWZ1bmN0aW9uIGYoQyxwLGgpe2g+MD9DLmxlZnQucHVzaChPYmplY3QoYS5jbG9uZSkocCkpOkMucmlnaHQucHVzaChPYmplY3QoYS5jbG9uZSkocCkpfWZ1bmN0aW9uIGcoQyxwLGgsbSxyPS0xKXtPYmplY3QoYS5zY2FsZUFuZEFkZCkobCxwLGgsLW0pLGYoQyxsLC1yKSxPYmplY3QoYS5zY2FsZUFuZEFkZCkobCxwLGgsbSksZihDLGwscil9ZnVuY3Rpb24gdih7bGVmdDpDLHJpZ2h0OnB9LGgpe2NvbnN0IG09T2JqZWN0KGEuY3JlYXRlKSgpLHI9T2JqZWN0KGEuY3JlYXRlKSgpO2xldCBpPUNbMF0sbj1wWzBdLHM9Wy41KihpWzBdK25bMF0pLC41KihpWzFdK25bMV0pXTtPYmplY3QoYS5zdWIpKHIsaSxzKTtmb3IobGV0IHg9MTt4PD1oO3grKyl7Y29uc3QgUD0tMSpNYXRoLlBJKngvaDtPYmplY3QoYS5yb3RhdGUpKG0scixbMCwwXSxQKSxPYmplY3QoYS5hZGQpKGwscyxtKSxDLnVuc2hpZnQoT2JqZWN0KGEuY2xvbmUpKGwpKX1pPXBbcC5sZW5ndGgtMV0sbj1DW0MubGVuZ3RoLTFdLHM9Wy41KihpWzBdK25bMF0pLC41KihpWzFdK25bMV0pXSxPYmplY3QoYS5zdWIpKHIsaSxzKTtmb3IobGV0IHg9MTt4PD1oO3grKyl7Y29uc3QgUD0tMSpNYXRoLlBJKngvaDtPYmplY3QoYS5yb3RhdGUpKG0scixbMCwwXSxQKSxPYmplY3QoYS5hZGQpKGwscyxtKSxwLnB1c2goT2JqZWN0KGEuY2xvbmUpKGwpKX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJpc1VuaXRUcmFuc2Zvcm0iLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShsKXtyZXR1cm4gbFswXT09PTEmJmxbMV09PT0wJiZsWzJdPT09MCYmbFszXT09PTEmJmxbNF09PT0wJiZsWzVdPT09MH19LGZ1bmN0aW9uKEwsZSx0KXt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7dmFyIGE9dCg2MSksbD10KDYyKTtMLmV4cG9ydHM9ZnVuY3Rpb24oTSxUKXtpZihUPVR8fHt9LE09TS5maWx0ZXIoZnVuY3Rpb24oaCl7cmV0dXJuIGgubGVuZ3RoPjJ9KSxNLmxlbmd0aD09PTApcmV0dXJue3Bvc2l0aW9uczpbXSxjZWxsczpbXX07dHlwZW9mIFQudmVydGV4U2l6ZSE9Im51bWJlciImJihULnZlcnRleFNpemU9TVswXVswXS5sZW5ndGgpLE09TS5tYXAoZnVuY3Rpb24oaCl7cmV0dXJuIGgucmVkdWNlKGZ1bmN0aW9uKG0scil7cmV0dXJuIG0uY29uY2F0KHIpfSl9KTtjb25zdCBkPVQucnVsZT09PSJldmVub2RkIj9hLldJTkRJTkdfT0REOmEuV0lORElOR19OT05aRVJPO2Zvcih2YXIgdT1hLnRlc3NlbGF0ZShsKHtjb250b3VyczpNLHdpbmRpbmdSdWxlOmQsZWxlbWVudFR5cGU6YS5QT0xZR09OUyxwb2x5U2l6ZTozLHZlcnRleFNpemU6Mn0sVCkpLGM9W10sTz0wO088dS52ZXJ0aWNlcy5sZW5ndGg7Tys9VC52ZXJ0ZXhTaXplKXt2YXIgZj11LnZlcnRpY2VzLnNsaWNlKE8sTytULnZlcnRleFNpemUpO2MucHVzaChmKX12YXIgZz1bXTtmb3IoTz0wO088dS5lbGVtZW50cy5sZW5ndGg7Tys9Myl7dmFyIHY9dS5lbGVtZW50c1tPXSxDPXUuZWxlbWVudHNbTysxXSxwPXUuZWxlbWVudHNbTysyXTtnLnB1c2goW3YsQyxwXSl9cmV0dXJue3Bvc2l0aW9uczpjLGNlbGxzOmd9fX0sZnVuY3Rpb24oTCxlLHQpe3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTt2YXIgYT17fSxsPXt9O0wuZXhwb3J0cz1hLGEuV0lORElOR19PREQ9MCxhLldJTkRJTkdfTk9OWkVSTz0xLGEuV0lORElOR19QT1NJVElWRT0yLGEuV0lORElOR19ORUdBVElWRT0zLGEuV0lORElOR19BQlNfR0VRX1RXTz00LGEuUE9MWUdPTlM9MCxhLkNPTk5FQ1RFRF9QT0xZR09OUz0xLGEuQk9VTkRBUllfQ09OVE9VUlM9MixhLnRlc3NlbGF0ZT1mdW5jdGlvbihyKXtmb3IodmFyIGk9ci5kZWJ1Z3x8ITEsbj1uZXcgbSxzPTA7czxyLmNvbnRvdXJzLmxlbmd0aDtzKyspbi5hZGRDb250b3VyKHIudmVydGV4U2l6ZXx8MixyLmNvbnRvdXJzW3NdKTtyZXR1cm4gbi50ZXNzZWxhdGUoci53aW5kaW5nUnVsZXx8YS5XSU5ESU5HX09ERCxyLmVsZW1lbnRUeXBlfHxhLlBPTFlHT05TLHIucG9seVNpemV8fDMsci52ZXJ0ZXhTaXplfHwyLHIubm9ybWFsfHxbMCwwLDFdKSx7dmVydGljZXM6bi52ZXJ0aWNlcyx2ZXJ0ZXhJbmRpY2VzOm4udmVydGV4SW5kaWNlcyx2ZXJ0ZXhDb3VudDpuLnZlcnRleENvdW50LGVsZW1lbnRzOm4uZWxlbWVudHMsZWxlbWVudENvdW50Om4uZWxlbWVudENvdW50LG1lc2g6aT9uLm1lc2g6dm9pZCAwfX07dmFyIE09ZnVuY3Rpb24ocil7aWYoIXIpdGhyb3ciQXNzZXJ0aW9uIEZhaWxlZCEifTtmdW5jdGlvbiBUKCl7dGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy5hbkVkZ2U9bnVsbCx0aGlzLmNvb3Jkcz1bMCwwLDBdLHRoaXMucz0wLHRoaXMudD0wLHRoaXMucHFIYW5kbGU9MCx0aGlzLm49MCx0aGlzLmlkeD0wfWZ1bmN0aW9uIGQoKXt0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbCx0aGlzLmFuRWRnZT1udWxsLHRoaXMudHJhaWw9bnVsbCx0aGlzLm49MCx0aGlzLm1hcmtlZD0hMSx0aGlzLmluc2lkZT0hMX1mdW5jdGlvbiB1KHIpe3RoaXMubmV4dD1udWxsLHRoaXMuU3ltPW51bGwsdGhpcy5PbmV4dD1udWxsLHRoaXMuTG5leHQ9bnVsbCx0aGlzLk9yZz1udWxsLHRoaXMuTGZhY2U9bnVsbCx0aGlzLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMud2luZGluZz0wLHRoaXMuc2lkZT1yfXUucHJvdG90eXBlPXtnZXQgUmZhY2UoKXtyZXR1cm4gdGhpcy5TeW0uTGZhY2V9LHNldCBSZmFjZShyKXt0aGlzLlN5bS5MZmFjZT1yfSxnZXQgRHN0KCl7cmV0dXJuIHRoaXMuU3ltLk9yZ30sc2V0IERzdChyKXt0aGlzLlN5bS5Pcmc9cn0sZ2V0IE9wcmV2KCl7cmV0dXJuIHRoaXMuU3ltLkxuZXh0fSxzZXQgT3ByZXYocil7dGhpcy5TeW0uTG5leHQ9cn0sZ2V0IExwcmV2KCl7cmV0dXJuIHRoaXMuT25leHQuU3ltfSxzZXQgTHByZXYocil7dGhpcy5PbmV4dC5TeW09cn0sZ2V0IERwcmV2KCl7cmV0dXJuIHRoaXMuTG5leHQuU3ltfSxzZXQgRHByZXYocil7dGhpcy5MbmV4dC5TeW09cn0sZ2V0IFJwcmV2KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0fSxzZXQgUnByZXYocil7dGhpcy5TeW0uT25leHQ9cn0sZ2V0IERuZXh0KCl7cmV0dXJuIHRoaXMuU3ltLk9uZXh0LlN5bX0sc2V0IERuZXh0KHIpe3RoaXMuU3ltLk9uZXh0LlN5bT1yfSxnZXQgUm5leHQoKXtyZXR1cm4gdGhpcy5TeW0uTG5leHQuU3ltfSxzZXQgUm5leHQocil7dGhpcy5TeW0uTG5leHQuU3ltPXJ9fTtmdW5jdGlvbiBjKCl7dmFyIHI9bmV3IFQsaT1uZXcgZCxuPW5ldyB1KDApLHM9bmV3IHUoMSk7ci5uZXh0PXIucHJldj1yLHIuYW5FZGdlPW51bGwsaS5uZXh0PWkucHJldj1pLGkuYW5FZGdlPW51bGwsaS50cmFpbD1udWxsLGkubWFya2VkPSExLGkuaW5zaWRlPSExLG4ubmV4dD1uLG4uU3ltPXMsbi5PbmV4dD1udWxsLG4uTG5leHQ9bnVsbCxuLk9yZz1udWxsLG4uTGZhY2U9bnVsbCxuLndpbmRpbmc9MCxuLmFjdGl2ZVJlZ2lvbj1udWxsLHMubmV4dD1zLHMuU3ltPW4scy5PbmV4dD1udWxsLHMuTG5leHQ9bnVsbCxzLk9yZz1udWxsLHMuTGZhY2U9bnVsbCxzLndpbmRpbmc9MCxzLmFjdGl2ZVJlZ2lvbj1udWxsLHRoaXMudkhlYWQ9cix0aGlzLmZIZWFkPWksdGhpcy5lSGVhZD1uLHRoaXMuZUhlYWRTeW09c31jLnByb3RvdHlwZT17bWFrZUVkZ2VfOmZ1bmN0aW9uKHIpe3ZhciBpPW5ldyB1KDApLG49bmV3IHUoMSk7ci5TeW0uc2lkZTxyLnNpZGUmJihyPXIuU3ltKTt2YXIgcz1yLlN5bS5uZXh0O3JldHVybiBuLm5leHQ9cyxzLlN5bS5uZXh0PWksaS5uZXh0PXIsci5TeW0ubmV4dD1uLGkuU3ltPW4saS5PbmV4dD1pLGkuTG5leHQ9bixpLk9yZz1udWxsLGkuTGZhY2U9bnVsbCxpLndpbmRpbmc9MCxpLmFjdGl2ZVJlZ2lvbj1udWxsLG4uU3ltPWksbi5PbmV4dD1uLG4uTG5leHQ9aSxuLk9yZz1udWxsLG4uTGZhY2U9bnVsbCxuLndpbmRpbmc9MCxuLmFjdGl2ZVJlZ2lvbj1udWxsLGl9LHNwbGljZV86ZnVuY3Rpb24ocixpKXt2YXIgbj1yLk9uZXh0LHM9aS5PbmV4dDtuLlN5bS5MbmV4dD1pLHMuU3ltLkxuZXh0PXIsci5PbmV4dD1zLGkuT25leHQ9bn0sbWFrZVZlcnRleF86ZnVuY3Rpb24ocixpLG4pe3ZhciBzPXI7TShzIT09bnVsbCk7dmFyIHg9bi5wcmV2O3MucHJldj14LHgubmV4dD1zLHMubmV4dD1uLG4ucHJldj1zLHMuYW5FZGdlPWk7dmFyIFA9aTtkbyBQLk9yZz1zLFA9UC5PbmV4dDt3aGlsZShQIT09aSl9LG1ha2VGYWNlXzpmdW5jdGlvbihyLGksbil7dmFyIHM9cjtNKHMhPT1udWxsKTt2YXIgeD1uLnByZXY7cy5wcmV2PXgseC5uZXh0PXMscy5uZXh0PW4sbi5wcmV2PXMscy5hbkVkZ2U9aSxzLnRyYWlsPW51bGwscy5tYXJrZWQ9ITEscy5pbnNpZGU9bi5pbnNpZGU7dmFyIFA9aTtkbyBQLkxmYWNlPXMsUD1QLkxuZXh0O3doaWxlKFAhPT1pKX0sa2lsbEVkZ2VfOmZ1bmN0aW9uKHIpe3IuU3ltLnNpZGU8ci5zaWRlJiYocj1yLlN5bSk7dmFyIGk9ci5uZXh0LG49ci5TeW0ubmV4dDtpLlN5bS5uZXh0PW4sbi5TeW0ubmV4dD1pfSxraWxsVmVydGV4XzpmdW5jdGlvbihyLGkpe3ZhciBuPXIuYW5FZGdlLHM9bjtkbyBzLk9yZz1pLHM9cy5PbmV4dDt3aGlsZShzIT09bik7dmFyIHg9ci5wcmV2LFA9ci5uZXh0O1AucHJldj14LHgubmV4dD1QfSxraWxsRmFjZV86ZnVuY3Rpb24ocixpKXt2YXIgbj1yLmFuRWRnZSxzPW47ZG8gcy5MZmFjZT1pLHM9cy5MbmV4dDt3aGlsZShzIT09bik7dmFyIHg9ci5wcmV2LFA9ci5uZXh0O1AucHJldj14LHgubmV4dD1QfSxtYWtlRWRnZTpmdW5jdGlvbigpe3ZhciByPW5ldyBULGk9bmV3IFQsbj1uZXcgZCxzPXRoaXMubWFrZUVkZ2VfKHRoaXMuZUhlYWQpO3JldHVybiB0aGlzLm1ha2VWZXJ0ZXhfKHIscyx0aGlzLnZIZWFkKSx0aGlzLm1ha2VWZXJ0ZXhfKGkscy5TeW0sdGhpcy52SGVhZCksdGhpcy5tYWtlRmFjZV8obixzLHRoaXMuZkhlYWQpLHN9LHNwbGljZTpmdW5jdGlvbihyLGkpe3ZhciBuPSExLHM9ITE7aWYociE9PWkpe2lmKGkuT3JnIT09ci5PcmcmJihzPSEwLHRoaXMua2lsbFZlcnRleF8oaS5Pcmcsci5PcmcpKSxpLkxmYWNlIT09ci5MZmFjZSYmKG49ITAsdGhpcy5raWxsRmFjZV8oaS5MZmFjZSxyLkxmYWNlKSksdGhpcy5zcGxpY2VfKGksciksIXMpe3ZhciB4PW5ldyBUO3RoaXMubWFrZVZlcnRleF8oeCxpLHIuT3JnKSxyLk9yZy5hbkVkZ2U9cn1pZighbil7dmFyIFA9bmV3IGQ7dGhpcy5tYWtlRmFjZV8oUCxpLHIuTGZhY2UpLHIuTGZhY2UuYW5FZGdlPXJ9fX0sZGVsZXRlOmZ1bmN0aW9uKHIpe3ZhciBpPXIuU3ltLG49ITE7aWYoci5MZmFjZSE9PXIuUmZhY2UmJihuPSEwLHRoaXMua2lsbEZhY2VfKHIuTGZhY2Usci5SZmFjZSkpLHIuT25leHQ9PT1yKXRoaXMua2lsbFZlcnRleF8oci5PcmcsbnVsbCk7ZWxzZSBpZihyLlJmYWNlLmFuRWRnZT1yLk9wcmV2LHIuT3JnLmFuRWRnZT1yLk9uZXh0LHRoaXMuc3BsaWNlXyhyLHIuT3ByZXYpLCFuKXt2YXIgcz1uZXcgZDt0aGlzLm1ha2VGYWNlXyhzLHIsci5MZmFjZSl9aS5PbmV4dD09PWk/KHRoaXMua2lsbFZlcnRleF8oaS5PcmcsbnVsbCksdGhpcy5raWxsRmFjZV8oaS5MZmFjZSxudWxsKSk6KHIuTGZhY2UuYW5FZGdlPWkuT3ByZXYsaS5PcmcuYW5FZGdlPWkuT25leHQsdGhpcy5zcGxpY2VfKGksaS5PcHJldikpLHRoaXMua2lsbEVkZ2VfKHIpfSxhZGRFZGdlVmVydGV4OmZ1bmN0aW9uKHIpe3ZhciBpPXRoaXMubWFrZUVkZ2VfKHIpLG49aS5TeW07dGhpcy5zcGxpY2VfKGksci5MbmV4dCksaS5Pcmc9ci5Ec3Q7dmFyIHM9bmV3IFQ7cmV0dXJuIHRoaXMubWFrZVZlcnRleF8ocyxuLGkuT3JnKSxpLkxmYWNlPW4uTGZhY2U9ci5MZmFjZSxpfSxzcGxpdEVkZ2U6ZnVuY3Rpb24ocixpKXt2YXIgbj10aGlzLmFkZEVkZ2VWZXJ0ZXgocikscz1uLlN5bTtyZXR1cm4gdGhpcy5zcGxpY2VfKHIuU3ltLHIuU3ltLk9wcmV2KSx0aGlzLnNwbGljZV8oci5TeW0scyksci5Ec3Q9cy5Pcmcscy5Ec3QuYW5FZGdlPXMuU3ltLHMuUmZhY2U9ci5SZmFjZSxzLndpbmRpbmc9ci53aW5kaW5nLHMuU3ltLndpbmRpbmc9ci5TeW0ud2luZGluZyxzfSxjb25uZWN0OmZ1bmN0aW9uKHIsaSl7dmFyIG49ITEscz10aGlzLm1ha2VFZGdlXyhyKSx4PXMuU3ltO2lmKGkuTGZhY2UhPT1yLkxmYWNlJiYobj0hMCx0aGlzLmtpbGxGYWNlXyhpLkxmYWNlLHIuTGZhY2UpKSx0aGlzLnNwbGljZV8ocyxyLkxuZXh0KSx0aGlzLnNwbGljZV8oeCxpKSxzLk9yZz1yLkRzdCx4Lk9yZz1pLk9yZyxzLkxmYWNlPXguTGZhY2U9ci5MZmFjZSxyLkxmYWNlLmFuRWRnZT14LCFuKXt2YXIgUD1uZXcgZDt0aGlzLm1ha2VGYWNlXyhQLHMsci5MZmFjZSl9cmV0dXJuIHN9LHphcEZhY2U6ZnVuY3Rpb24ocil7dmFyIGk9ci5hbkVkZ2UsbixzLHgsUCxSO3M9aS5MbmV4dDtkbyBuPXMscz1uLkxuZXh0LG4uTGZhY2U9bnVsbCxuLlJmYWNlPT09bnVsbCYmKG4uT25leHQ9PT1uP3RoaXMua2lsbFZlcnRleF8obi5PcmcsbnVsbCk6KG4uT3JnLmFuRWRnZT1uLk9uZXh0LHRoaXMuc3BsaWNlXyhuLG4uT3ByZXYpKSx4PW4uU3ltLHguT25leHQ9PT14P3RoaXMua2lsbFZlcnRleF8oeC5PcmcsbnVsbCk6KHguT3JnLmFuRWRnZT14Lk9uZXh0LHRoaXMuc3BsaWNlXyh4LHguT3ByZXYpKSx0aGlzLmtpbGxFZGdlXyhuKSk7d2hpbGUobiE9aSk7UD1yLnByZXYsUj1yLm5leHQsUi5wcmV2PVAsUC5uZXh0PVJ9LGNvdW50RmFjZVZlcnRzXzpmdW5jdGlvbihyKXt2YXIgaT1yLmFuRWRnZSxuPTA7ZG8gbisrLGk9aS5MbmV4dDt3aGlsZShpIT09ci5hbkVkZ2UpO3JldHVybiBufSxtZXJnZUNvbnZleEZhY2VzOmZ1bmN0aW9uKHIpe3ZhciBpLG4scyx4LFAsUixiO2ZvcihpPXRoaXMuZkhlYWQubmV4dDtpIT09dGhpcy5mSGVhZDtpPWkubmV4dClpZihpLmluc2lkZSlmb3Iobj1pLmFuRWRnZSxQPW4uT3JnO3M9bi5MbmV4dCx4PW4uU3ltLHgmJnguTGZhY2UmJnguTGZhY2UuaW5zaWRlJiYoUj10aGlzLmNvdW50RmFjZVZlcnRzXyhpKSxiPXRoaXMuY291bnRGYWNlVmVydHNfKHguTGZhY2UpLFIrYi0yPD1yJiZsLnZlcnRDQ1cobi5McHJldi5Pcmcsbi5PcmcseC5MbmV4dC5MbmV4dC5PcmcpJiZsLnZlcnRDQ1coeC5McHJldi5PcmcseC5Pcmcsbi5MbmV4dC5MbmV4dC5PcmcpJiYocz14LkxuZXh0LHRoaXMuZGVsZXRlKHgpLG49bnVsbCx4PW51bGwpKSwhKG4mJm4uTG5leHQuT3JnPT09UCk7KW49cztyZXR1cm4hMH0sY2hlY2s6ZnVuY3Rpb24oKXt2YXIgcj10aGlzLmZIZWFkLGk9dGhpcy52SGVhZCxuPXRoaXMuZUhlYWQscyx4LFAsUixiLEU7Zm9yKHg9cix4PXI7KHM9eC5uZXh0KSE9PXI7eD1zKXtNKHMucHJldj09PXgpLGI9cy5hbkVkZ2U7ZG8gTShiLlN5bSE9PWIpLE0oYi5TeW0uU3ltPT09YiksTShiLkxuZXh0Lk9uZXh0LlN5bT09PWIpLE0oYi5PbmV4dC5TeW0uTG5leHQ9PT1iKSxNKGIuTGZhY2U9PT1zKSxiPWIuTG5leHQ7d2hpbGUoYiE9PXMuYW5FZGdlKX1mb3IoTShzLnByZXY9PT14JiZzLmFuRWRnZT09PW51bGwpLFI9aSxSPWk7KFA9Ui5uZXh0KSE9PWk7Uj1QKXtNKFAucHJldj09PVIpLGI9UC5hbkVkZ2U7ZG8gTShiLlN5bSE9PWIpLE0oYi5TeW0uU3ltPT09YiksTShiLkxuZXh0Lk9uZXh0LlN5bT09PWIpLE0oYi5PbmV4dC5TeW0uTG5leHQ9PT1iKSxNKGIuT3JnPT09UCksYj1iLk9uZXh0O3doaWxlKGIhPT1QLmFuRWRnZSl9Zm9yKE0oUC5wcmV2PT09UiYmUC5hbkVkZ2U9PT1udWxsKSxFPW4sRT1uOyhiPUUubmV4dCkhPT1uO0U9YilNKGIuU3ltLm5leHQ9PT1FLlN5bSksTShiLlN5bSE9PWIpLE0oYi5TeW0uU3ltPT09YiksTShiLk9yZyE9PW51bGwpLE0oYi5Ec3QhPT1udWxsKSxNKGIuTG5leHQuT25leHQuU3ltPT09YiksTShiLk9uZXh0LlN5bS5MbmV4dD09PWIpO00oYi5TeW0ubmV4dD09PUUuU3ltJiZiLlN5bT09PXRoaXMuZUhlYWRTeW0mJmIuU3ltLlN5bT09PWImJmIuT3JnPT09bnVsbCYmYi5Ec3Q9PT1udWxsJiZiLkxmYWNlPT09bnVsbCYmYi5SZmFjZT09PW51bGwpfX0sbC52ZXJ0RXE9ZnVuY3Rpb24ocixpKXtyZXR1cm4gci5zPT09aS5zJiZyLnQ9PT1pLnR9LGwudmVydExlcT1mdW5jdGlvbihyLGkpe3JldHVybiByLnM8aS5zfHxyLnM9PT1pLnMmJnIudDw9aS50fSxsLnRyYW5zTGVxPWZ1bmN0aW9uKHIsaSl7cmV0dXJuIHIudDxpLnR8fHIudD09PWkudCYmci5zPD1pLnN9LGwuZWRnZUdvZXNMZWZ0PWZ1bmN0aW9uKHIpe3JldHVybiBsLnZlcnRMZXEoci5Ec3Qsci5PcmcpfSxsLmVkZ2VHb2VzUmlnaHQ9ZnVuY3Rpb24ocil7cmV0dXJuIGwudmVydExlcShyLk9yZyxyLkRzdCl9LGwudmVydEwxZGlzdD1mdW5jdGlvbihyLGkpe3JldHVybiBNYXRoLmFicyhyLnMtaS5zKStNYXRoLmFicyhyLnQtaS50KX0sbC5lZGdlRXZhbD1mdW5jdGlvbihyLGksbil7TShsLnZlcnRMZXEocixpKSYmbC52ZXJ0TGVxKGksbikpO3ZhciBzPWkucy1yLnMseD1uLnMtaS5zO3JldHVybiBzK3g+MD9zPHg/aS50LXIudCsoci50LW4udCkqKHMvKHMreCkpOmkudC1uLnQrKG4udC1yLnQpKih4LyhzK3gpKTowfSxsLmVkZ2VTaWduPWZ1bmN0aW9uKHIsaSxuKXtNKGwudmVydExlcShyLGkpJiZsLnZlcnRMZXEoaSxuKSk7dmFyIHM9aS5zLXIucyx4PW4ucy1pLnM7cmV0dXJuIHMreD4wPyhpLnQtbi50KSpzKyhpLnQtci50KSp4OjB9LGwudHJhbnNFdmFsPWZ1bmN0aW9uKHIsaSxuKXtNKGwudHJhbnNMZXEocixpKSYmbC50cmFuc0xlcShpLG4pKTt2YXIgcz1pLnQtci50LHg9bi50LWkudDtyZXR1cm4gcyt4PjA/czx4P2kucy1yLnMrKHIucy1uLnMpKihzLyhzK3gpKTppLnMtbi5zKyhuLnMtci5zKSooeC8ocyt4KSk6MH0sbC50cmFuc1NpZ249ZnVuY3Rpb24ocixpLG4pe00obC50cmFuc0xlcShyLGkpJiZsLnRyYW5zTGVxKGksbikpO3ZhciBzPWkudC1yLnQseD1uLnQtaS50O3JldHVybiBzK3g+MD8oaS5zLW4ucykqcysoaS5zLXIucykqeDowfSxsLnZlcnRDQ1c9ZnVuY3Rpb24ocixpLG4pe3JldHVybiByLnMqKGkudC1uLnQpK2kucyoobi50LXIudCkrbi5zKihyLnQtaS50KT49MH0sbC5pbnRlcnBvbGF0ZT1mdW5jdGlvbihyLGksbixzKXtyZXR1cm4gcj1yPDA/MDpyLG49bjwwPzA6bixyPD1uP249PT0wPyhpK3MpLzI6aSsocy1pKSooci8ocituKSk6cysoaS1zKSoobi8ocituKSl9LGwuaW50ZXJzZWN0PWZ1bmN0aW9uKHIsaSxuLHMseCl7dmFyIFAsUixiO2wudmVydExlcShyLGkpfHwoYj1yLHI9aSxpPWIpLGwudmVydExlcShuLHMpfHwoYj1uLG49cyxzPWIpLGwudmVydExlcShyLG4pfHwoYj1yLHI9bixuPWIsYj1pLGk9cyxzPWIpLGwudmVydExlcShuLGkpP2wudmVydExlcShpLHMpPyhQPWwuZWRnZUV2YWwocixuLGkpLFI9bC5lZGdlRXZhbChuLGkscyksUCtSPDAmJihQPS1QLFI9LVIpLHgucz1sLmludGVycG9sYXRlKFAsbi5zLFIsaS5zKSk6KFA9bC5lZGdlU2lnbihyLG4saSksUj0tbC5lZGdlU2lnbihyLHMsaSksUCtSPDAmJihQPS1QLFI9LVIpLHgucz1sLmludGVycG9sYXRlKFAsbi5zLFIscy5zKSk6eC5zPShuLnMraS5zKS8yLGwudHJhbnNMZXEocixpKXx8KGI9cixyPWksaT1iKSxsLnRyYW5zTGVxKG4scyl8fChiPW4sbj1zLHM9YiksbC50cmFuc0xlcShyLG4pfHwoYj1yLHI9bixuPWIsYj1pLGk9cyxzPWIpLGwudHJhbnNMZXEobixpKT9sLnRyYW5zTGVxKGkscyk/KFA9bC50cmFuc0V2YWwocixuLGkpLFI9bC50cmFuc0V2YWwobixpLHMpLFArUjwwJiYoUD0tUCxSPS1SKSx4LnQ9bC5pbnRlcnBvbGF0ZShQLG4udCxSLGkudCkpOihQPWwudHJhbnNTaWduKHIsbixpKSxSPS1sLnRyYW5zU2lnbihyLHMsaSksUCtSPDAmJihQPS1QLFI9LVIpLHgudD1sLmludGVycG9sYXRlKFAsbi50LFIscy50KSk6eC50PShuLnQraS50KS8yfTtmdW5jdGlvbiBPKCl7dGhpcy5rZXk9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLnByZXY9bnVsbH1mdW5jdGlvbiBmKHIsaSl7dGhpcy5oZWFkPW5ldyBPLHRoaXMuaGVhZC5uZXh0PXRoaXMuaGVhZCx0aGlzLmhlYWQucHJldj10aGlzLmhlYWQsdGhpcy5mcmFtZT1yLHRoaXMubGVxPWl9Zi5wcm90b3R5cGU9e21pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQubmV4dH0sbWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5wcmV2fSxpbnNlcnQ6ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCxyKX0sc2VhcmNoOmZ1bmN0aW9uKHIpe3ZhciBpPXRoaXMuaGVhZDtkbyBpPWkubmV4dDt3aGlsZShpLmtleSE9PW51bGwmJiF0aGlzLmxlcSh0aGlzLmZyYW1lLHIsaS5rZXkpKTtyZXR1cm4gaX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKHIsaSl7ZG8gcj1yLnByZXY7d2hpbGUoci5rZXkhPT1udWxsJiYhdGhpcy5sZXEodGhpcy5mcmFtZSxyLmtleSxpKSk7dmFyIG49bmV3IE87cmV0dXJuIG4ua2V5PWksbi5uZXh0PXIubmV4dCxyLm5leHQucHJldj1uLG4ucHJldj1yLHIubmV4dD1uLG59LGRlbGV0ZTpmdW5jdGlvbihyKXtyLm5leHQucHJldj1yLnByZXYsci5wcmV2Lm5leHQ9ci5uZXh0fX07ZnVuY3Rpb24gZygpe3RoaXMuaGFuZGxlPW51bGx9ZnVuY3Rpb24gdigpe3RoaXMua2V5PW51bGwsdGhpcy5ub2RlPW51bGx9ZnVuY3Rpb24gQyhyLGkpe3RoaXMuc2l6ZT0wLHRoaXMubWF4PXIsdGhpcy5ub2Rlcz1bXSx0aGlzLm5vZGVzLmxlbmd0aD1yKzE7dmFyIG47Zm9yKG49MDtuPHRoaXMubm9kZXMubGVuZ3RoO24rKyl0aGlzLm5vZGVzW25dPW5ldyBnO2Zvcih0aGlzLmhhbmRsZXM9W10sdGhpcy5oYW5kbGVzLmxlbmd0aD1yKzEsbj0wO248dGhpcy5oYW5kbGVzLmxlbmd0aDtuKyspdGhpcy5oYW5kbGVzW25dPW5ldyB2O3RoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy5mcmVlTGlzdD0wLHRoaXMubGVxPWksdGhpcy5ub2Rlc1sxXS5oYW5kbGU9MSx0aGlzLmhhbmRsZXNbMV0ua2V5PW51bGx9Qy5wcm90b3R5cGU9e2Zsb2F0RG93bl86ZnVuY3Rpb24ocil7dmFyIGk9dGhpcy5ub2RlcyxuPXRoaXMuaGFuZGxlcyxzLHgsUDtmb3Iocz1pW3JdLmhhbmRsZTs7KXtpZihQPXI8PDEsUDx0aGlzLnNpemUmJnRoaXMubGVxKG5baVtQKzFdLmhhbmRsZV0ua2V5LG5baVtQXS5oYW5kbGVdLmtleSkmJisrUCxNKFA8PXRoaXMubWF4KSx4PWlbUF0uaGFuZGxlLFA+dGhpcy5zaXplfHx0aGlzLmxlcShuW3NdLmtleSxuW3hdLmtleSkpe2lbcl0uaGFuZGxlPXMsbltzXS5ub2RlPXI7YnJlYWt9aVtyXS5oYW5kbGU9eCxuW3hdLm5vZGU9cixyPVB9fSxmbG9hdFVwXzpmdW5jdGlvbihyKXt2YXIgaT10aGlzLm5vZGVzLG49dGhpcy5oYW5kbGVzLHMseCxQO2ZvcihzPWlbcl0uaGFuZGxlOzspe2lmKFA9cj4+MSx4PWlbUF0uaGFuZGxlLFA9PT0wfHx0aGlzLmxlcShuW3hdLmtleSxuW3NdLmtleSkpe2lbcl0uaGFuZGxlPXMsbltzXS5ub2RlPXI7YnJlYWt9aVtyXS5oYW5kbGU9eCxuW3hdLm5vZGU9cixyPVB9fSxpbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciByPXRoaXMuc2l6ZTtyPj0xOy0tcil0aGlzLmZsb2F0RG93bl8ocik7dGhpcy5pbml0aWFsaXplZD0hMH0sbWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFuZGxlc1t0aGlzLm5vZGVzWzFdLmhhbmRsZV0ua2V5fSxpbnNlcnQ6ZnVuY3Rpb24ocil7dmFyIGksbjtpZihpPSsrdGhpcy5zaXplLGkqMj50aGlzLm1heCl7dGhpcy5tYXgqPTI7dmFyIHMseDtmb3IoeD10aGlzLm5vZGVzLmxlbmd0aCx0aGlzLm5vZGVzLmxlbmd0aD10aGlzLm1heCsxLHM9eDtzPHRoaXMubm9kZXMubGVuZ3RoO3MrKyl0aGlzLm5vZGVzW3NdPW5ldyBnO2Zvcih4PXRoaXMuaGFuZGxlcy5sZW5ndGgsdGhpcy5oYW5kbGVzLmxlbmd0aD10aGlzLm1heCsxLHM9eDtzPHRoaXMuaGFuZGxlcy5sZW5ndGg7cysrKXRoaXMuaGFuZGxlc1tzXT1uZXcgdn1yZXR1cm4gdGhpcy5mcmVlTGlzdD09PTA/bj1pOihuPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD10aGlzLmhhbmRsZXNbbl0ubm9kZSksdGhpcy5ub2Rlc1tpXS5oYW5kbGU9bix0aGlzLmhhbmRsZXNbbl0ubm9kZT1pLHRoaXMuaGFuZGxlc1tuXS5rZXk9cix0aGlzLmluaXRpYWxpemVkJiZ0aGlzLmZsb2F0VXBfKGkpLG59LGV4dHJhY3RNaW46ZnVuY3Rpb24oKXt2YXIgcj10aGlzLm5vZGVzLGk9dGhpcy5oYW5kbGVzLG49clsxXS5oYW5kbGUscz1pW25dLmtleTtyZXR1cm4gdGhpcy5zaXplPjAmJihyWzFdLmhhbmRsZT1yW3RoaXMuc2l6ZV0uaGFuZGxlLGlbclsxXS5oYW5kbGVdLm5vZGU9MSxpW25dLmtleT1udWxsLGlbbl0ubm9kZT10aGlzLmZyZWVMaXN0LHRoaXMuZnJlZUxpc3Q9biwtLXRoaXMuc2l6ZSx0aGlzLnNpemU+MCYmdGhpcy5mbG9hdERvd25fKDEpKSxzfSxkZWxldGU6ZnVuY3Rpb24ocil7dmFyIGk9dGhpcy5ub2RlcyxuPXRoaXMuaGFuZGxlcyxzO00ocj49MSYmcjw9dGhpcy5tYXgmJm5bcl0ua2V5IT09bnVsbCkscz1uW3JdLm5vZGUsaVtzXS5oYW5kbGU9aVt0aGlzLnNpemVdLmhhbmRsZSxuW2lbc10uaGFuZGxlXS5ub2RlPXMsLS10aGlzLnNpemUsczw9dGhpcy5zaXplJiYoczw9MXx8dGhpcy5sZXEobltpW3M+PjFdLmhhbmRsZV0ua2V5LG5baVtzXS5oYW5kbGVdLmtleSk/dGhpcy5mbG9hdERvd25fKHMpOnRoaXMuZmxvYXRVcF8ocykpLG5bcl0ua2V5PW51bGwsbltyXS5ub2RlPXRoaXMuZnJlZUxpc3QsdGhpcy5mcmVlTGlzdD1yfX07ZnVuY3Rpb24gcCgpe3RoaXMuZVVwPW51bGwsdGhpcy5ub2RlVXA9bnVsbCx0aGlzLndpbmRpbmdOdW1iZXI9MCx0aGlzLmluc2lkZT0hMSx0aGlzLnNlbnRpbmVsPSExLHRoaXMuZGlydHk9ITEsdGhpcy5maXhVcHBlckVkZ2U9ITF9dmFyIGg9e307aC5yZWdpb25CZWxvdz1mdW5jdGlvbihyKXtyZXR1cm4gci5ub2RlVXAucHJldi5rZXl9LGgucmVnaW9uQWJvdmU9ZnVuY3Rpb24ocil7cmV0dXJuIHIubm9kZVVwLm5leHQua2V5fSxoLmRlYnVnRXZlbnQ9ZnVuY3Rpb24ocil7fSxoLmFkZFdpbmRpbmc9ZnVuY3Rpb24ocixpKXtyLndpbmRpbmcrPWkud2luZGluZyxyLlN5bS53aW5kaW5nKz1pLlN5bS53aW5kaW5nfSxoLmVkZ2VMZXE9ZnVuY3Rpb24ocixpLG4pe3ZhciBzPXIuZXZlbnQsUixiLHg9aS5lVXAsUD1uLmVVcDtpZih4LkRzdD09PXMpcmV0dXJuIFAuRHN0PT09cz9sLnZlcnRMZXEoeC5PcmcsUC5PcmcpP2wuZWRnZVNpZ24oUC5Ec3QseC5PcmcsUC5PcmcpPD0wOmwuZWRnZVNpZ24oeC5Ec3QsUC5PcmcseC5PcmcpPj0wOmwuZWRnZVNpZ24oUC5Ec3QscyxQLk9yZyk8PTA7aWYoUC5Ec3Q9PT1zKXJldHVybiBsLmVkZ2VTaWduKHguRHN0LHMseC5PcmcpPj0wO3ZhciBSPWwuZWRnZUV2YWwoeC5Ec3Qscyx4Lk9yZyksYj1sLmVkZ2VFdmFsKFAuRHN0LHMsUC5PcmcpO3JldHVybiBSPj1ifSxoLmRlbGV0ZVJlZ2lvbj1mdW5jdGlvbihyLGkpe2kuZml4VXBwZXJFZGdlJiZNKGkuZVVwLndpbmRpbmc9PT0wKSxpLmVVcC5hY3RpdmVSZWdpb249bnVsbCxyLmRpY3QuZGVsZXRlKGkubm9kZVVwKX0saC5maXhVcHBlckVkZ2U9ZnVuY3Rpb24ocixpLG4pe00oaS5maXhVcHBlckVkZ2UpLHIubWVzaC5kZWxldGUoaS5lVXApLGkuZml4VXBwZXJFZGdlPSExLGkuZVVwPW4sbi5hY3RpdmVSZWdpb249aX0saC50b3BMZWZ0UmVnaW9uPWZ1bmN0aW9uKHIsaSl7dmFyIG49aS5lVXAuT3JnLHM7ZG8gaT1oLnJlZ2lvbkFib3ZlKGkpO3doaWxlKGkuZVVwLk9yZz09PW4pO2lmKGkuZml4VXBwZXJFZGdlKXtpZihzPXIubWVzaC5jb25uZWN0KGgucmVnaW9uQmVsb3coaSkuZVVwLlN5bSxpLmVVcC5MbmV4dCkscz09PW51bGwpcmV0dXJuIG51bGw7aC5maXhVcHBlckVkZ2UocixpLHMpLGk9aC5yZWdpb25BYm92ZShpKX1yZXR1cm4gaX0saC50b3BSaWdodFJlZ2lvbj1mdW5jdGlvbihyKXt2YXIgaT1yLmVVcC5Ec3Q7ZG8gcj1oLnJlZ2lvbkFib3ZlKHIpO3doaWxlKHIuZVVwLkRzdD09PWkpO3JldHVybiByfSxoLmFkZFJlZ2lvbkJlbG93PWZ1bmN0aW9uKHIsaSxuKXt2YXIgcz1uZXcgcDtyZXR1cm4gcy5lVXA9bixzLm5vZGVVcD1yLmRpY3QuaW5zZXJ0QmVmb3JlKGkubm9kZVVwLHMpLHMuZml4VXBwZXJFZGdlPSExLHMuc2VudGluZWw9ITEscy5kaXJ0eT0hMSxuLmFjdGl2ZVJlZ2lvbj1zLHN9LGguaXNXaW5kaW5nSW5zaWRlPWZ1bmN0aW9uKHIsaSl7c3dpdGNoKHIud2luZGluZ1J1bGUpe2Nhc2UgYS5XSU5ESU5HX09ERDpyZXR1cm4oaSYxKSE9PTA7Y2FzZSBhLldJTkRJTkdfTk9OWkVSTzpyZXR1cm4gaSE9PTA7Y2FzZSBhLldJTkRJTkdfUE9TSVRJVkU6cmV0dXJuIGk+MDtjYXNlIGEuV0lORElOR19ORUdBVElWRTpyZXR1cm4gaTwwO2Nhc2UgYS5XSU5ESU5HX0FCU19HRVFfVFdPOnJldHVybiBpPj0yfHxpPD0tMn1yZXR1cm4gTSghMSksITF9LGguY29tcHV0ZVdpbmRpbmc9ZnVuY3Rpb24ocixpKXtpLndpbmRpbmdOdW1iZXI9aC5yZWdpb25BYm92ZShpKS53aW5kaW5nTnVtYmVyK2kuZVVwLndpbmRpbmcsaS5pbnNpZGU9aC5pc1dpbmRpbmdJbnNpZGUocixpLndpbmRpbmdOdW1iZXIpfSxoLmZpbmlzaFJlZ2lvbj1mdW5jdGlvbihyLGkpe3ZhciBuPWkuZVVwLHM9bi5MZmFjZTtzLmluc2lkZT1pLmluc2lkZSxzLmFuRWRnZT1uLGguZGVsZXRlUmVnaW9uKHIsaSl9LGguZmluaXNoTGVmdFJlZ2lvbnM9ZnVuY3Rpb24ocixpLG4pe2Zvcih2YXIgcyxSLHg9bnVsbCxQPWksUj1pLmVVcDtQIT09bjspe2lmKFAuZml4VXBwZXJFZGdlPSExLHg9aC5yZWdpb25CZWxvdyhQKSxzPXguZVVwLHMuT3JnIT1SLk9yZyl7aWYoIXguZml4VXBwZXJFZGdlKXtoLmZpbmlzaFJlZ2lvbihyLFApO2JyZWFrfXM9ci5tZXNoLmNvbm5lY3QoUi5McHJldixzLlN5bSksaC5maXhVcHBlckVkZ2Uocix4LHMpfVIuT25leHQhPT1zJiYoci5tZXNoLnNwbGljZShzLk9wcmV2LHMpLHIubWVzaC5zcGxpY2UoUixzKSksaC5maW5pc2hSZWdpb24ocixQKSxSPXguZVVwLFA9eH1yZXR1cm4gUn0saC5hZGRSaWdodEVkZ2VzPWZ1bmN0aW9uKHIsaSxuLHMseCxQKXt2YXIgUixiLEUsRCxJPSEwO0U9bjtkbyBNKGwudmVydExlcShFLk9yZyxFLkRzdCkpLGguYWRkUmVnaW9uQmVsb3cocixpLEUuU3ltKSxFPUUuT25leHQ7d2hpbGUoRSE9PXMpO2Zvcih4PT09bnVsbCYmKHg9aC5yZWdpb25CZWxvdyhpKS5lVXAuUnByZXYpLGI9aSxEPXg7Uj1oLnJlZ2lvbkJlbG93KGIpLEU9Ui5lVXAuU3ltLEUuT3JnPT09RC5Pcmc7KUUuT25leHQhPT1EJiYoci5tZXNoLnNwbGljZShFLk9wcmV2LEUpLHIubWVzaC5zcGxpY2UoRC5PcHJldixFKSksUi53aW5kaW5nTnVtYmVyPWIud2luZGluZ051bWJlci1FLndpbmRpbmcsUi5pbnNpZGU9aC5pc1dpbmRpbmdJbnNpZGUocixSLndpbmRpbmdOdW1iZXIpLGIuZGlydHk9ITAsIUkmJmguY2hlY2tGb3JSaWdodFNwbGljZShyLGIpJiYoaC5hZGRXaW5kaW5nKEUsRCksaC5kZWxldGVSZWdpb24ocixiKSxyLm1lc2guZGVsZXRlKEQpKSxJPSExLGI9UixEPUU7Yi5kaXJ0eT0hMCxNKGIud2luZGluZ051bWJlci1FLndpbmRpbmc9PT1SLndpbmRpbmdOdW1iZXIpLFAmJmgud2Fsa0RpcnR5UmVnaW9ucyhyLGIpfSxoLnNwbGljZU1lcmdlVmVydGljZXM9ZnVuY3Rpb24ocixpLG4pe3IubWVzaC5zcGxpY2UoaSxuKX0saC52ZXJ0ZXhXZWlnaHRzPWZ1bmN0aW9uKHIsaSxuKXt2YXIgcz1sLnZlcnRMMWRpc3QoaSxyKSx4PWwudmVydEwxZGlzdChuLHIpLFA9LjUqeC8ocyt4KSxSPS41KnMvKHMreCk7ci5jb29yZHNbMF0rPVAqaS5jb29yZHNbMF0rUipuLmNvb3Jkc1swXSxyLmNvb3Jkc1sxXSs9UCppLmNvb3Jkc1sxXStSKm4uY29vcmRzWzFdLHIuY29vcmRzWzJdKz1QKmkuY29vcmRzWzJdK1Iqbi5jb29yZHNbMl19LGguZ2V0SW50ZXJzZWN0RGF0YT1mdW5jdGlvbihyLGksbixzLHgsUCl7aS5jb29yZHNbMF09aS5jb29yZHNbMV09aS5jb29yZHNbMl09MCxpLmlkeD0tMSxoLnZlcnRleFdlaWdodHMoaSxuLHMpLGgudmVydGV4V2VpZ2h0cyhpLHgsUCl9LGguY2hlY2tGb3JSaWdodFNwbGljZT1mdW5jdGlvbihyLGkpe3ZhciBuPWgucmVnaW9uQmVsb3coaSkscz1pLmVVcCx4PW4uZVVwO2lmKGwudmVydExlcShzLk9yZyx4Lk9yZykpe2lmKGwuZWRnZVNpZ24oeC5Ec3Qscy5PcmcseC5PcmcpPjApcmV0dXJuITE7bC52ZXJ0RXEocy5PcmcseC5PcmcpP3MuT3JnIT09eC5PcmcmJihyLnBxLmRlbGV0ZShzLk9yZy5wcUhhbmRsZSksaC5zcGxpY2VNZXJnZVZlcnRpY2VzKHIseC5PcHJldixzKSk6KHIubWVzaC5zcGxpdEVkZ2UoeC5TeW0pLHIubWVzaC5zcGxpY2Uocyx4Lk9wcmV2KSxpLmRpcnR5PW4uZGlydHk9ITApfWVsc2V7aWYobC5lZGdlU2lnbihzLkRzdCx4Lk9yZyxzLk9yZyk8MClyZXR1cm4hMTtoLnJlZ2lvbkFib3ZlKGkpLmRpcnR5PWkuZGlydHk9ITAsci5tZXNoLnNwbGl0RWRnZShzLlN5bSksci5tZXNoLnNwbGljZSh4Lk9wcmV2LHMpfXJldHVybiEwfSxoLmNoZWNrRm9yTGVmdFNwbGljZT1mdW5jdGlvbihyLGkpe3ZhciBuPWgucmVnaW9uQmVsb3coaSkscz1pLmVVcCx4PW4uZVVwLFA7aWYoTSghbC52ZXJ0RXEocy5Ec3QseC5Ec3QpKSxsLnZlcnRMZXEocy5Ec3QseC5Ec3QpKXtpZihsLmVkZ2VTaWduKHMuRHN0LHguRHN0LHMuT3JnKTwwKXJldHVybiExO2gucmVnaW9uQWJvdmUoaSkuZGlydHk9aS5kaXJ0eT0hMCxQPXIubWVzaC5zcGxpdEVkZ2Uocyksci5tZXNoLnNwbGljZSh4LlN5bSxQKSxQLkxmYWNlLmluc2lkZT1pLmluc2lkZX1lbHNle2lmKGwuZWRnZVNpZ24oeC5Ec3Qscy5Ec3QseC5PcmcpPjApcmV0dXJuITE7aS5kaXJ0eT1uLmRpcnR5PSEwLFA9ci5tZXNoLnNwbGl0RWRnZSh4KSxyLm1lc2guc3BsaWNlKHMuTG5leHQseC5TeW0pLFAuUmZhY2UuaW5zaWRlPWkuaW5zaWRlfXJldHVybiEwfSxoLmNoZWNrRm9ySW50ZXJzZWN0PWZ1bmN0aW9uKHIsaSl7dmFyIG49aC5yZWdpb25CZWxvdyhpKSxzPWkuZVVwLHg9bi5lVXAsUD1zLk9yZyxSPXguT3JnLGI9cy5Ec3QsRT14LkRzdCxELEksUz1uZXcgVCxBLFU7aWYoTSghbC52ZXJ0RXEoRSxiKSksTShsLmVkZ2VTaWduKGIsci5ldmVudCxQKTw9MCksTShsLmVkZ2VTaWduKEUsci5ldmVudCxSKT49MCksTShQIT09ci5ldmVudCYmUiE9PXIuZXZlbnQpLE0oIWkuZml4VXBwZXJFZGdlJiYhbi5maXhVcHBlckVkZ2UpLFA9PT1SfHwoRD1NYXRoLm1pbihQLnQsYi50KSxJPU1hdGgubWF4KFIudCxFLnQpLEQ+SSkpcmV0dXJuITE7aWYobC52ZXJ0TGVxKFAsUikpe2lmKGwuZWRnZVNpZ24oRSxQLFIpPjApcmV0dXJuITF9ZWxzZSBpZihsLmVkZ2VTaWduKGIsUixQKTwwKXJldHVybiExO3JldHVybiBoLmRlYnVnRXZlbnQociksbC5pbnRlcnNlY3QoYixQLEUsUixTKSxNKE1hdGgubWluKFAudCxiLnQpPD1TLnQpLE0oUy50PD1NYXRoLm1heChSLnQsRS50KSksTShNYXRoLm1pbihFLnMsYi5zKTw9Uy5zKSxNKFMuczw9TWF0aC5tYXgoUi5zLFAucykpLGwudmVydExlcShTLHIuZXZlbnQpJiYoUy5zPXIuZXZlbnQucyxTLnQ9ci5ldmVudC50KSxBPWwudmVydExlcShQLFIpP1A6UixsLnZlcnRMZXEoQSxTKSYmKFMucz1BLnMsUy50PUEudCksbC52ZXJ0RXEoUyxQKXx8bC52ZXJ0RXEoUyxSKT8oaC5jaGVja0ZvclJpZ2h0U3BsaWNlKHIsaSksITEpOiFsLnZlcnRFcShiLHIuZXZlbnQpJiZsLmVkZ2VTaWduKGIsci5ldmVudCxTKT49MHx8IWwudmVydEVxKEUsci5ldmVudCkmJmwuZWRnZVNpZ24oRSxyLmV2ZW50LFMpPD0wP0U9PT1yLmV2ZW50PyhyLm1lc2guc3BsaXRFZGdlKHMuU3ltKSxyLm1lc2guc3BsaWNlKHguU3ltLHMpLGk9aC50b3BMZWZ0UmVnaW9uKHIsaSkscz1oLnJlZ2lvbkJlbG93KGkpLmVVcCxoLmZpbmlzaExlZnRSZWdpb25zKHIsaC5yZWdpb25CZWxvdyhpKSxuKSxoLmFkZFJpZ2h0RWRnZXMocixpLHMuT3ByZXYscyxzLCEwKSwhMCk6Yj09PXIuZXZlbnQ/KHIubWVzaC5zcGxpdEVkZ2UoeC5TeW0pLHIubWVzaC5zcGxpY2Uocy5MbmV4dCx4Lk9wcmV2KSxuPWksaT1oLnRvcFJpZ2h0UmVnaW9uKGkpLFU9aC5yZWdpb25CZWxvdyhpKS5lVXAuUnByZXYsbi5lVXA9eC5PcHJldix4PWguZmluaXNoTGVmdFJlZ2lvbnMocixuLG51bGwpLGguYWRkUmlnaHRFZGdlcyhyLGkseC5PbmV4dCxzLlJwcmV2LFUsITApLCEwKToobC5lZGdlU2lnbihiLHIuZXZlbnQsUyk+PTAmJihoLnJlZ2lvbkFib3ZlKGkpLmRpcnR5PWkuZGlydHk9ITAsci5tZXNoLnNwbGl0RWRnZShzLlN5bSkscy5Pcmcucz1yLmV2ZW50LnMscy5PcmcudD1yLmV2ZW50LnQpLGwuZWRnZVNpZ24oRSxyLmV2ZW50LFMpPD0wJiYoaS5kaXJ0eT1uLmRpcnR5PSEwLHIubWVzaC5zcGxpdEVkZ2UoeC5TeW0pLHguT3JnLnM9ci5ldmVudC5zLHguT3JnLnQ9ci5ldmVudC50KSwhMSk6KHIubWVzaC5zcGxpdEVkZ2Uocy5TeW0pLHIubWVzaC5zcGxpdEVkZ2UoeC5TeW0pLHIubWVzaC5zcGxpY2UoeC5PcHJldixzKSxzLk9yZy5zPVMucyxzLk9yZy50PVMudCxzLk9yZy5wcUhhbmRsZT1yLnBxLmluc2VydChzLk9yZyksaC5nZXRJbnRlcnNlY3REYXRhKHIscy5PcmcsUCxiLFIsRSksaC5yZWdpb25BYm92ZShpKS5kaXJ0eT1pLmRpcnR5PW4uZGlydHk9ITAsITEpfSxoLndhbGtEaXJ0eVJlZ2lvbnM9ZnVuY3Rpb24ocixpKXtmb3IodmFyIG49aC5yZWdpb25CZWxvdyhpKSxzLHg7Oyl7Zm9yKDtuLmRpcnR5OylpPW4sbj1oLnJlZ2lvbkJlbG93KG4pO2lmKCFpLmRpcnR5JiYobj1pLGk9aC5yZWdpb25BYm92ZShpKSxpPT09bnVsbHx8IWkuZGlydHkpKXJldHVybjtpZihpLmRpcnR5PSExLHM9aS5lVXAseD1uLmVVcCxzLkRzdCE9PXguRHN0JiZoLmNoZWNrRm9yTGVmdFNwbGljZShyLGkpJiYobi5maXhVcHBlckVkZ2U/KGguZGVsZXRlUmVnaW9uKHIsbiksci5tZXNoLmRlbGV0ZSh4KSxuPWgucmVnaW9uQmVsb3coaSkseD1uLmVVcCk6aS5maXhVcHBlckVkZ2UmJihoLmRlbGV0ZVJlZ2lvbihyLGkpLHIubWVzaC5kZWxldGUocyksaT1oLnJlZ2lvbkFib3ZlKG4pLHM9aS5lVXApKSxzLk9yZyE9PXguT3JnKWlmKHMuRHN0IT09eC5Ec3QmJiFpLmZpeFVwcGVyRWRnZSYmIW4uZml4VXBwZXJFZGdlJiYocy5Ec3Q9PT1yLmV2ZW50fHx4LkRzdD09PXIuZXZlbnQpKXtpZihoLmNoZWNrRm9ySW50ZXJzZWN0KHIsaSkpcmV0dXJufWVsc2UgaC5jaGVja0ZvclJpZ2h0U3BsaWNlKHIsaSk7cy5Pcmc9PT14Lk9yZyYmcy5Ec3Q9PT14LkRzdCYmKGguYWRkV2luZGluZyh4LHMpLGguZGVsZXRlUmVnaW9uKHIsaSksci5tZXNoLmRlbGV0ZShzKSxpPWgucmVnaW9uQWJvdmUobikpfX0saC5jb25uZWN0UmlnaHRWZXJ0ZXg9ZnVuY3Rpb24ocixpLG4pe3ZhciBzLHg9bi5PbmV4dCxQPWgucmVnaW9uQmVsb3coaSksUj1pLmVVcCxiPVAuZVVwLEU9ITE7aWYoUi5Ec3QhPT1iLkRzdCYmaC5jaGVja0ZvckludGVyc2VjdChyLGkpLGwudmVydEVxKFIuT3JnLHIuZXZlbnQpJiYoci5tZXNoLnNwbGljZSh4Lk9wcmV2LFIpLGk9aC50b3BMZWZ0UmVnaW9uKHIsaSkseD1oLnJlZ2lvbkJlbG93KGkpLmVVcCxoLmZpbmlzaExlZnRSZWdpb25zKHIsaC5yZWdpb25CZWxvdyhpKSxQKSxFPSEwKSxsLnZlcnRFcShiLk9yZyxyLmV2ZW50KSYmKHIubWVzaC5zcGxpY2UobixiLk9wcmV2KSxuPWguZmluaXNoTGVmdFJlZ2lvbnMocixQLG51bGwpLEU9ITApLEUpe2guYWRkUmlnaHRFZGdlcyhyLGksbi5PbmV4dCx4LHgsITApO3JldHVybn1sLnZlcnRMZXEoYi5PcmcsUi5PcmcpP3M9Yi5PcHJldjpzPVIscz1yLm1lc2guY29ubmVjdChuLkxwcmV2LHMpLGguYWRkUmlnaHRFZGdlcyhyLGkscyxzLk9uZXh0LHMuT25leHQsITEpLHMuU3ltLmFjdGl2ZVJlZ2lvbi5maXhVcHBlckVkZ2U9ITAsaC53YWxrRGlydHlSZWdpb25zKHIsaSl9LGguY29ubmVjdExlZnREZWdlbmVyYXRlPWZ1bmN0aW9uKHIsaSxuKXt2YXIgcyx4LFAsUixiO2lmKHM9aS5lVXAsbC52ZXJ0RXEocy5Pcmcsbikpe00oITEpLGguc3BsaWNlTWVyZ2VWZXJ0aWNlcyhyLHMsbi5hbkVkZ2UpO3JldHVybn1pZighbC52ZXJ0RXEocy5Ec3Qsbikpe3IubWVzaC5zcGxpdEVkZ2Uocy5TeW0pLGkuZml4VXBwZXJFZGdlJiYoci5tZXNoLmRlbGV0ZShzLk9uZXh0KSxpLmZpeFVwcGVyRWRnZT0hMSksci5tZXNoLnNwbGljZShuLmFuRWRnZSxzKSxoLnN3ZWVwRXZlbnQocixuKTtyZXR1cm59TSghMSksaT1oLnRvcFJpZ2h0UmVnaW9uKGkpLGI9aC5yZWdpb25CZWxvdyhpKSxQPWIuZVVwLlN5bSx4PVI9UC5PbmV4dCxiLmZpeFVwcGVyRWRnZSYmKE0oeCE9PVApLGguZGVsZXRlUmVnaW9uKHIsYiksci5tZXNoLmRlbGV0ZShQKSxQPXguT3ByZXYpLHIubWVzaC5zcGxpY2Uobi5hbkVkZ2UsUCksbC5lZGdlR29lc0xlZnQoeCl8fCh4PW51bGwpLGguYWRkUmlnaHRFZGdlcyhyLGksUC5PbmV4dCxSLHgsITApfSxoLmNvbm5lY3RMZWZ0VmVydGV4PWZ1bmN0aW9uKHIsaSl7dmFyIG4scyx4LFAsUixiLEU9bmV3IHA7aWYoRS5lVXA9aS5hbkVkZ2UuU3ltLG49ci5kaWN0LnNlYXJjaChFKS5rZXkscz1oLnJlZ2lvbkJlbG93KG4pLCEhcyl7aWYoUD1uLmVVcCxSPXMuZVVwLGwuZWRnZVNpZ24oUC5Ec3QsaSxQLk9yZyk9PT0wKXtoLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZShyLG4saSk7cmV0dXJufWlmKHg9bC52ZXJ0TGVxKFIuRHN0LFAuRHN0KT9uOnMsbi5pbnNpZGV8fHguZml4VXBwZXJFZGdlKXtpZih4PT09biliPXIubWVzaC5jb25uZWN0KGkuYW5FZGdlLlN5bSxQLkxuZXh0KTtlbHNle3ZhciBEPXIubWVzaC5jb25uZWN0KFIuRG5leHQsaS5hbkVkZ2UpO2I9RC5TeW19eC5maXhVcHBlckVkZ2U/aC5maXhVcHBlckVkZ2Uocix4LGIpOmguY29tcHV0ZVdpbmRpbmcocixoLmFkZFJlZ2lvbkJlbG93KHIsbixiKSksaC5zd2VlcEV2ZW50KHIsaSl9ZWxzZSBoLmFkZFJpZ2h0RWRnZXMocixuLGkuYW5FZGdlLGkuYW5FZGdlLG51bGwsITApfX0saC5zd2VlcEV2ZW50PWZ1bmN0aW9uKHIsaSl7ci5ldmVudD1pLGguZGVidWdFdmVudChyKTtmb3IodmFyIG49aS5hbkVkZ2U7bi5hY3RpdmVSZWdpb249PT1udWxsOylpZihuPW4uT25leHQsbj09PWkuYW5FZGdlKXtoLmNvbm5lY3RMZWZ0VmVydGV4KHIsaSk7cmV0dXJufXZhciBzPWgudG9wTGVmdFJlZ2lvbihyLG4uYWN0aXZlUmVnaW9uKTtNKHMhPT1udWxsKTt2YXIgeD1oLnJlZ2lvbkJlbG93KHMpLFA9eC5lVXAsUj1oLmZpbmlzaExlZnRSZWdpb25zKHIseCxudWxsKTtSLk9uZXh0PT09UD9oLmNvbm5lY3RSaWdodFZlcnRleChyLHMsUik6aC5hZGRSaWdodEVkZ2VzKHIscyxSLk9uZXh0LFAsUCwhMCl9LGguYWRkU2VudGluZWw9ZnVuY3Rpb24ocixpLG4scyl7dmFyIHg9bmV3IHAsUD1yLm1lc2gubWFrZUVkZ2UoKTtQLk9yZy5zPW4sUC5PcmcudD1zLFAuRHN0LnM9aSxQLkRzdC50PXMsci5ldmVudD1QLkRzdCx4LmVVcD1QLHgud2luZGluZ051bWJlcj0wLHguaW5zaWRlPSExLHguZml4VXBwZXJFZGdlPSExLHguc2VudGluZWw9ITAseC5kaXJ0eT0hMSx4Lm5vZGVVcD1yLmRpY3QuaW5zZXJ0KHgpfSxoLmluaXRFZGdlRGljdD1mdW5jdGlvbihyKXtyLmRpY3Q9bmV3IGYocixoLmVkZ2VMZXEpO3ZhciBpPXIuYm1heFswXS1yLmJtaW5bMF0sbj1yLmJtYXhbMV0tci5ibWluWzFdLHM9ci5ibWluWzBdLWkseD1yLmJtYXhbMF0raSxQPXIuYm1pblsxXS1uLFI9ci5ibWF4WzFdK247aC5hZGRTZW50aW5lbChyLHMseCxQKSxoLmFkZFNlbnRpbmVsKHIscyx4LFIpfSxoLmRvbmVFZGdlRGljdD1mdW5jdGlvbihyKXtmb3IodmFyIGksbj0wOyhpPXIuZGljdC5taW4oKS5rZXkpIT09bnVsbDspaS5zZW50aW5lbHx8KE0oaS5maXhVcHBlckVkZ2UpLE0oKytuPT09MSkpLE0oaS53aW5kaW5nTnVtYmVyPT09MCksaC5kZWxldGVSZWdpb24ocixpKX0saC5yZW1vdmVEZWdlbmVyYXRlRWRnZXM9ZnVuY3Rpb24ocil7dmFyIGksbixzLHg9ci5tZXNoLmVIZWFkO2ZvcihpPXgubmV4dDtpIT09eDtpPW4pbj1pLm5leHQscz1pLkxuZXh0LGwudmVydEVxKGkuT3JnLGkuRHN0KSYmaS5MbmV4dC5MbmV4dCE9PWkmJihoLnNwbGljZU1lcmdlVmVydGljZXMocixzLGkpLHIubWVzaC5kZWxldGUoaSksaT1zLHM9aS5MbmV4dCkscy5MbmV4dD09PWkmJihzIT09aSYmKChzPT09bnx8cz09PW4uU3ltKSYmKG49bi5uZXh0KSxyLm1lc2guZGVsZXRlKHMpKSwoaT09PW58fGk9PT1uLlN5bSkmJihuPW4ubmV4dCksci5tZXNoLmRlbGV0ZShpKSl9LGguaW5pdFByaW9yaXR5UT1mdW5jdGlvbihyKXt2YXIgaSxuLHMseD0wO2ZvcihzPXIubWVzaC52SGVhZCxuPXMubmV4dDtuIT09cztuPW4ubmV4dCl4Kys7Zm9yKHgrPTgsaT1yLnBxPW5ldyBDKHgsbC52ZXJ0TGVxKSxzPXIubWVzaC52SGVhZCxuPXMubmV4dDtuIT09cztuPW4ubmV4dCluLnBxSGFuZGxlPWkuaW5zZXJ0KG4pO3JldHVybiBuIT09cz8hMTooaS5pbml0KCksITApfSxoLmRvbmVQcmlvcml0eVE9ZnVuY3Rpb24ocil7ci5wcT1udWxsfSxoLnJlbW92ZURlZ2VuZXJhdGVGYWNlcz1mdW5jdGlvbihyLGkpe3ZhciBuLHMseDtmb3Iobj1pLmZIZWFkLm5leHQ7biE9PWkuZkhlYWQ7bj1zKXM9bi5uZXh0LHg9bi5hbkVkZ2UsTSh4LkxuZXh0IT09eCkseC5MbmV4dC5MbmV4dD09PXgmJihoLmFkZFdpbmRpbmcoeC5PbmV4dCx4KSxyLm1lc2guZGVsZXRlKHgpKTtyZXR1cm4hMH0saC5jb21wdXRlSW50ZXJpb3I9ZnVuY3Rpb24ocil7dmFyIGksbjtpZihoLnJlbW92ZURlZ2VuZXJhdGVFZGdlcyhyKSwhaC5pbml0UHJpb3JpdHlRKHIpKXJldHVybiExO2ZvcihoLmluaXRFZGdlRGljdChyKTsoaT1yLnBxLmV4dHJhY3RNaW4oKSkhPT1udWxsOyl7Zm9yKDtuPXIucHEubWluKCksIShuPT09bnVsbHx8IWwudmVydEVxKG4saSkpOyluPXIucHEuZXh0cmFjdE1pbigpLGguc3BsaWNlTWVyZ2VWZXJ0aWNlcyhyLGkuYW5FZGdlLG4uYW5FZGdlKTtoLnN3ZWVwRXZlbnQocixpKX1yZXR1cm4gci5ldmVudD1yLmRpY3QubWluKCkua2V5LmVVcC5PcmcsaC5kZWJ1Z0V2ZW50KHIpLGguZG9uZUVkZ2VEaWN0KHIpLGguZG9uZVByaW9yaXR5UShyKSxoLnJlbW92ZURlZ2VuZXJhdGVGYWNlcyhyLHIubWVzaCk/KHIubWVzaC5jaGVjaygpLCEwKTohMX07ZnVuY3Rpb24gbSgpe3RoaXMubWVzaD1udWxsLHRoaXMubm9ybWFsPVswLDAsMF0sdGhpcy5zVW5pdD1bMCwwLDBdLHRoaXMudFVuaXQ9WzAsMCwwXSx0aGlzLmJtaW49WzAsMF0sdGhpcy5ibWF4PVswLDBdLHRoaXMud2luZGluZ1J1bGU9YS5XSU5ESU5HX09ERCx0aGlzLmRpY3Q9bnVsbCx0aGlzLnBxPW51bGwsdGhpcy5ldmVudD1udWxsLHRoaXMudmVydGV4SW5kZXhDb3VudGVyPTAsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhDb3VudD0wLHRoaXMuZWxlbWVudHM9W10sdGhpcy5lbGVtZW50Q291bnQ9MH1tLnByb3RvdHlwZT17ZG90XzpmdW5jdGlvbihyLGkpe3JldHVybiByWzBdKmlbMF0rclsxXSppWzFdK3JbMl0qaVsyXX0sbm9ybWFsaXplXzpmdW5jdGlvbihyKXt2YXIgaT1yWzBdKnJbMF0rclsxXSpyWzFdK3JbMl0qclsyXTtNKGk+MCksaT1NYXRoLnNxcnQoaSksclswXS89aSxyWzFdLz1pLHJbMl0vPWl9LGxvbmdBeGlzXzpmdW5jdGlvbihyKXt2YXIgaT0wO3JldHVybiBNYXRoLmFicyhyWzFdKT5NYXRoLmFicyhyWzBdKSYmKGk9MSksTWF0aC5hYnMoclsyXSk+TWF0aC5hYnMocltpXSkmJihpPTIpLGl9LGNvbXB1dGVOb3JtYWxfOmZ1bmN0aW9uKHIpe3ZhciBpLG4scyx4LFAsUixiPVswLDAsMF0sRT1bMCwwLDBdLEQ9WzAsMCwwXSxJPVswLDAsMF0sUz1bMCwwLDBdLEE9W251bGwsbnVsbCxudWxsXSxVPVtudWxsLG51bGwsbnVsbF0sSz10aGlzLm1lc2gudkhlYWQsVjtmb3IoaT1LLm5leHQsVj0wO1Y8MzsrK1YpeD1pLmNvb3Jkc1tWXSxFW1ZdPXgsVVtWXT1pLGJbVl09eCxBW1ZdPWk7Zm9yKGk9Sy5uZXh0O2khPT1LO2k9aS5uZXh0KWZvcihWPTA7VjwzOysrVil4PWkuY29vcmRzW1ZdLHg8RVtWXSYmKEVbVl09eCxVW1ZdPWkpLHg+YltWXSYmKGJbVl09eCxBW1ZdPWkpO2lmKFY9MCxiWzFdLUVbMV0+YlswXS1FWzBdJiYoVj0xKSxiWzJdLUVbMl0+YltWXS1FW1ZdJiYoVj0yKSxFW1ZdPj1iW1ZdKXtyWzBdPTAsclsxXT0wLHJbMl09MTtyZXR1cm59Zm9yKFI9MCxuPVVbVl0scz1BW1ZdLERbMF09bi5jb29yZHNbMF0tcy5jb29yZHNbMF0sRFsxXT1uLmNvb3Jkc1sxXS1zLmNvb3Jkc1sxXSxEWzJdPW4uY29vcmRzWzJdLXMuY29vcmRzWzJdLGk9Sy5uZXh0O2khPT1LO2k9aS5uZXh0KUlbMF09aS5jb29yZHNbMF0tcy5jb29yZHNbMF0sSVsxXT1pLmNvb3Jkc1sxXS1zLmNvb3Jkc1sxXSxJWzJdPWkuY29vcmRzWzJdLXMuY29vcmRzWzJdLFNbMF09RFsxXSpJWzJdLURbMl0qSVsxXSxTWzFdPURbMl0qSVswXS1EWzBdKklbMl0sU1syXT1EWzBdKklbMV0tRFsxXSpJWzBdLFA9U1swXSpTWzBdK1NbMV0qU1sxXStTWzJdKlNbMl0sUD5SJiYoUj1QLHJbMF09U1swXSxyWzFdPVNbMV0sclsyXT1TWzJdKTtSPD0wJiYoclswXT1yWzFdPXJbMl09MCxyW3RoaXMubG9uZ0F4aXNfKEQpXT0xKX0sY2hlY2tPcmllbnRhdGlvbl86ZnVuY3Rpb24oKXt2YXIgcixpLG49dGhpcy5tZXNoLmZIZWFkLHMseD10aGlzLm1lc2gudkhlYWQsUDtmb3Iocj0wLGk9bi5uZXh0O2khPT1uO2k9aS5uZXh0KWlmKFA9aS5hbkVkZ2UsIShQLndpbmRpbmc8PTApKWRvIHIrPShQLk9yZy5zLVAuRHN0LnMpKihQLk9yZy50K1AuRHN0LnQpLFA9UC5MbmV4dDt3aGlsZShQIT09aS5hbkVkZ2UpO2lmKHI8MCl7Zm9yKHM9eC5uZXh0O3MhPT14O3M9cy5uZXh0KXMudD0tcy50O3RoaXMudFVuaXRbMF09LXRoaXMudFVuaXRbMF0sdGhpcy50VW5pdFsxXT0tdGhpcy50VW5pdFsxXSx0aGlzLnRVbml0WzJdPS10aGlzLnRVbml0WzJdfX0scHJvamVjdFBvbHlnb25fOmZ1bmN0aW9uKCl7dmFyIHIsaT10aGlzLm1lc2gudkhlYWQsbj1bMCwwLDBdLHMseCxQLFIsYj0hMTtmb3IoblswXT10aGlzLm5vcm1hbFswXSxuWzFdPXRoaXMubm9ybWFsWzFdLG5bMl09dGhpcy5ub3JtYWxbMl0sblswXT09PTAmJm5bMV09PT0wJiZuWzJdPT09MCYmKHRoaXMuY29tcHV0ZU5vcm1hbF8obiksYj0hMCkscz10aGlzLnNVbml0LHg9dGhpcy50VW5pdCxQPXRoaXMubG9uZ0F4aXNfKG4pLHNbUF09MCxzWyhQKzEpJTNdPTEsc1soUCsyKSUzXT0wLHhbUF09MCx4WyhQKzEpJTNdPTAseFsoUCsyKSUzXT1uW1BdPjA/MTotMSxyPWkubmV4dDtyIT09aTtyPXIubmV4dClyLnM9dGhpcy5kb3RfKHIuY29vcmRzLHMpLHIudD10aGlzLmRvdF8oci5jb29yZHMseCk7Zm9yKGImJnRoaXMuY2hlY2tPcmllbnRhdGlvbl8oKSxSPSEwLHI9aS5uZXh0O3IhPT1pO3I9ci5uZXh0KVI/KHRoaXMuYm1pblswXT10aGlzLmJtYXhbMF09ci5zLHRoaXMuYm1pblsxXT10aGlzLmJtYXhbMV09ci50LFI9ITEpOihyLnM8dGhpcy5ibWluWzBdJiYodGhpcy5ibWluWzBdPXIucyksci5zPnRoaXMuYm1heFswXSYmKHRoaXMuYm1heFswXT1yLnMpLHIudDx0aGlzLmJtaW5bMV0mJih0aGlzLmJtaW5bMV09ci50KSxyLnQ+dGhpcy5ibWF4WzFdJiYodGhpcy5ibWF4WzFdPXIudCkpfSxhZGRXaW5kaW5nXzpmdW5jdGlvbihyLGkpe3Iud2luZGluZys9aS53aW5kaW5nLHIuU3ltLndpbmRpbmcrPWkuU3ltLndpbmRpbmd9LHRlc3NlbGxhdGVNb25vUmVnaW9uXzpmdW5jdGlvbihyLGkpe3ZhciBuLHM7Zm9yKG49aS5hbkVkZ2UsTShuLkxuZXh0IT09biYmbi5MbmV4dC5MbmV4dCE9PW4pO2wudmVydExlcShuLkRzdCxuLk9yZyk7bj1uLkxwcmV2KTtmb3IoO2wudmVydExlcShuLk9yZyxuLkRzdCk7bj1uLkxuZXh0KTtmb3Iocz1uLkxwcmV2O24uTG5leHQhPT1zOylpZihsLnZlcnRMZXEobi5Ec3Qscy5PcmcpKXtmb3IoO3MuTG5leHQhPT1uJiYobC5lZGdlR29lc0xlZnQocy5MbmV4dCl8fGwuZWRnZVNpZ24ocy5Pcmcscy5Ec3Qscy5MbmV4dC5Ec3QpPD0wKTspe3ZhciB4PXIuY29ubmVjdChzLkxuZXh0LHMpO3M9eC5TeW19cz1zLkxwcmV2fWVsc2V7Zm9yKDtzLkxuZXh0IT09biYmKGwuZWRnZUdvZXNSaWdodChuLkxwcmV2KXx8bC5lZGdlU2lnbihuLkRzdCxuLk9yZyxuLkxwcmV2Lk9yZyk+PTApOyl7dmFyIHg9ci5jb25uZWN0KG4sbi5McHJldik7bj14LlN5bX1uPW4uTG5leHR9Zm9yKE0ocy5MbmV4dCE9PW4pO3MuTG5leHQuTG5leHQhPT1uOyl7dmFyIHg9ci5jb25uZWN0KHMuTG5leHQscyk7cz14LlN5bX1yZXR1cm4hMH0sdGVzc2VsbGF0ZUludGVyaW9yXzpmdW5jdGlvbihyKXt2YXIgaSxuO2ZvcihpPXIuZkhlYWQubmV4dDtpIT09ci5mSGVhZDtpPW4paWYobj1pLm5leHQsaS5pbnNpZGUmJiF0aGlzLnRlc3NlbGxhdGVNb25vUmVnaW9uXyhyLGkpKXJldHVybiExO3JldHVybiEwfSxkaXNjYXJkRXh0ZXJpb3JfOmZ1bmN0aW9uKHIpe3ZhciBpLG47Zm9yKGk9ci5mSGVhZC5uZXh0O2khPT1yLmZIZWFkO2k9biluPWkubmV4dCxpLmluc2lkZXx8ci56YXBGYWNlKGkpfSxzZXRXaW5kaW5nTnVtYmVyXzpmdW5jdGlvbihyLGksbil7dmFyIHMseDtmb3Iocz1yLmVIZWFkLm5leHQ7cyE9PXIuZUhlYWQ7cz14KXg9cy5uZXh0LHMuUmZhY2UuaW5zaWRlIT09cy5MZmFjZS5pbnNpZGU/cy53aW5kaW5nPXMuTGZhY2UuaW5zaWRlP2k6LWk6bj9yLmRlbGV0ZShzKTpzLndpbmRpbmc9MH0sZ2V0TmVpZ2hib3VyRmFjZV86ZnVuY3Rpb24ocil7cmV0dXJuIXIuUmZhY2V8fCFyLlJmYWNlLmluc2lkZT8tMTpyLlJmYWNlLm59LG91dHB1dFBvbHltZXNoXzpmdW5jdGlvbihyLGksbixzKXt2YXIgeCxQLFIsYj0wLEU9MCxELEk7Zm9yKG4+MyYmci5tZXJnZUNvbnZleEZhY2VzKG4pLHg9ci52SGVhZC5uZXh0O3ghPT1yLnZIZWFkO3g9eC5uZXh0KXgubj0tMTtmb3IoUD1yLmZIZWFkLm5leHQ7UCE9PXIuZkhlYWQ7UD1QLm5leHQpaWYoUC5uPS0xLCEhUC5pbnNpZGUpe1I9UC5hbkVkZ2UsRD0wO2RvIHg9Ui5PcmcseC5uPT09LTEmJih4Lm49RSxFKyspLEQrKyxSPVIuTG5leHQ7d2hpbGUoUiE9PVAuYW5FZGdlKTtNKEQ8PW4pLFAubj1iLCsrYn1mb3IodGhpcy5lbGVtZW50Q291bnQ9YixpPT09YS5DT05ORUNURURfUE9MWUdPTlMmJihiKj0yKSx0aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPWIqbix0aGlzLnZlcnRleENvdW50PUUsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD1FKnMsdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9RSx4PXIudkhlYWQubmV4dDt4IT09ci52SGVhZDt4PXgubmV4dClpZih4Lm4hPT0tMSl7dmFyIFM9eC5uKnM7dGhpcy52ZXJ0aWNlc1tTKzBdPXguY29vcmRzWzBdLHRoaXMudmVydGljZXNbUysxXT14LmNvb3Jkc1sxXSxzPjImJih0aGlzLnZlcnRpY2VzW1MrMl09eC5jb29yZHNbMl0pLHRoaXMudmVydGV4SW5kaWNlc1t4Lm5dPXguaWR4fXZhciBBPTA7Zm9yKFA9ci5mSGVhZC5uZXh0O1AhPT1yLmZIZWFkO1A9UC5uZXh0KWlmKFAuaW5zaWRlKXtSPVAuYW5FZGdlLEQ9MDtkbyB4PVIuT3JnLHRoaXMuZWxlbWVudHNbQSsrXT14Lm4sRCsrLFI9Ui5MbmV4dDt3aGlsZShSIT09UC5hbkVkZ2UpO2ZvcihJPUQ7STxuOysrSSl0aGlzLmVsZW1lbnRzW0ErK109LTE7aWYoaT09PWEuQ09OTkVDVEVEX1BPTFlHT05TKXtSPVAuYW5FZGdlO2RvIHRoaXMuZWxlbWVudHNbQSsrXT10aGlzLmdldE5laWdoYm91ckZhY2VfKFIpLFI9Ui5MbmV4dDt3aGlsZShSIT09UC5hbkVkZ2UpO2ZvcihJPUQ7STxuOysrSSl0aGlzLmVsZW1lbnRzW0ErK109LTF9fX0sb3V0cHV0Q29udG91cnNfOmZ1bmN0aW9uKHIsaSl7dmFyIG4scyx4LFA9MCxSPTA7Zm9yKHRoaXMudmVydGV4Q291bnQ9MCx0aGlzLmVsZW1lbnRDb3VudD0wLG49ci5mSGVhZC5uZXh0O24hPT1yLmZIZWFkO249bi5uZXh0KWlmKG4uaW5zaWRlKXt4PXM9bi5hbkVkZ2U7ZG8gdGhpcy52ZXJ0ZXhDb3VudCsrLHM9cy5MbmV4dDt3aGlsZShzIT09eCk7dGhpcy5lbGVtZW50Q291bnQrK310aGlzLmVsZW1lbnRzPVtdLHRoaXMuZWxlbWVudHMubGVuZ3RoPXRoaXMuZWxlbWVudENvdW50KjIsdGhpcy52ZXJ0aWNlcz1bXSx0aGlzLnZlcnRpY2VzLmxlbmd0aD10aGlzLnZlcnRleENvdW50KmksdGhpcy52ZXJ0ZXhJbmRpY2VzPVtdLHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGg9dGhpcy52ZXJ0ZXhDb3VudDt2YXIgYj0wLEU9MCxEPTA7Zm9yKFA9MCxuPXIuZkhlYWQubmV4dDtuIT09ci5mSGVhZDtuPW4ubmV4dClpZihuLmluc2lkZSl7Uj0wLHg9cz1uLmFuRWRnZTtkbyB0aGlzLnZlcnRpY2VzW2IrK109cy5PcmcuY29vcmRzWzBdLHRoaXMudmVydGljZXNbYisrXT1zLk9yZy5jb29yZHNbMV0saT4yJiYodGhpcy52ZXJ0aWNlc1tiKytdPXMuT3JnLmNvb3Jkc1syXSksdGhpcy52ZXJ0ZXhJbmRpY2VzW0UrK109cy5PcmcuaWR4LFIrKyxzPXMuTG5leHQ7d2hpbGUocyE9PXgpO3RoaXMuZWxlbWVudHNbRCsrXT1QLHRoaXMuZWxlbWVudHNbRCsrXT1SLFArPVJ9fSxhZGRDb250b3VyOmZ1bmN0aW9uKHIsaSl7dmFyIG4scztmb3IodGhpcy5tZXNoPT09bnVsbCYmKHRoaXMubWVzaD1uZXcgYykscjwyJiYocj0yKSxyPjMmJihyPTMpLG49bnVsbCxzPTA7czxpLmxlbmd0aDtzKz1yKW49PT1udWxsPyhuPXRoaXMubWVzaC5tYWtlRWRnZSgpLHRoaXMubWVzaC5zcGxpY2UobixuLlN5bSkpOih0aGlzLm1lc2guc3BsaXRFZGdlKG4pLG49bi5MbmV4dCksbi5PcmcuY29vcmRzWzBdPWlbcyswXSxuLk9yZy5jb29yZHNbMV09aVtzKzFdLHI+Mj9uLk9yZy5jb29yZHNbMl09aVtzKzJdOm4uT3JnLmNvb3Jkc1syXT0wLG4uT3JnLmlkeD10aGlzLnZlcnRleEluZGV4Q291bnRlcisrLG4ud2luZGluZz0xLG4uU3ltLndpbmRpbmc9LTF9LHRlc3NlbGF0ZTpmdW5jdGlvbihyLGksbixzLHgpe2lmKHRoaXMudmVydGljZXM9W10sdGhpcy5lbGVtZW50cz1bXSx0aGlzLnZlcnRleEluZGljZXM9W10sdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXI9MCx4JiYodGhpcy5ub3JtYWxbMF09eFswXSx0aGlzLm5vcm1hbFsxXT14WzFdLHRoaXMubm9ybWFsWzJdPXhbMl0pLHRoaXMud2luZGluZ1J1bGU9cixzPDImJihzPTIpLHM+MyYmKHM9MyksIXRoaXMubWVzaClyZXR1cm4hMTt0aGlzLnByb2plY3RQb2x5Z29uXygpLGguY29tcHV0ZUludGVyaW9yKHRoaXMpO3ZhciBQPXRoaXMubWVzaDtyZXR1cm4gaT09PWEuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5zZXRXaW5kaW5nTnVtYmVyXyhQLDEsITApOnRoaXMudGVzc2VsbGF0ZUludGVyaW9yXyhQKSxQLmNoZWNrKCksaT09PWEuQk9VTkRBUllfQ09OVE9VUlM/dGhpcy5vdXRwdXRDb250b3Vyc18oUCxzKTp0aGlzLm91dHB1dFBvbHltZXNoXyhQLGksbixzKSwhMH19fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1hO3ZhciB0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gYSgpe2Zvcih2YXIgbD17fSxNPTA7TTxhcmd1bWVudHMubGVuZ3RoO00rKyl7dmFyIFQ9YXJndW1lbnRzW01dO2Zvcih2YXIgZCBpbiBUKXQuY2FsbChULGQpJiYobFtkXT1UW2RdKX1yZXR1cm4gbH19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImNyZWF0ZVNoYWRlcnMiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQoZSwiYXBwbHlTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwiY3JlYXRlQ2xvdWRTaGFkZXJzIixmdW5jdGlvbigpe3JldHVybiBmfSksdC5kKGUsImFwcGx5Q2xvdWRTaGFkZXIiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KTt2YXIgYT10KDY0KSxsPXQoNjUpLE09dCg2NiksVD10KDY3KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD1TeW1ib2woInNoYWRlcnMiKTtmdW5jdGlvbiB1KHYpe3ZbZF09W107Zm9yKGxldCBDPTA7QzwxNjtDKyspe2NvbnN0IHA9W10saD0hIShDJjEpLG09ISEoQyYyKSxyPSEhKEMmNCksaT0hIShDJjgpO2gmJnAucHVzaCgiI2RlZmluZSBURVhUVVJFIDEiKSxtJiZwLnB1c2goIiNkZWZpbmUgRklMVEVSIDEiKSxyJiZwLnB1c2goIiNkZWZpbmUgR1JBRElFTlQgMSIpLGkmJnAucHVzaCgiI2RlZmluZSBDTElQUEFUSCAxIik7Y29uc3Qgbj1gJHtwLmpvaW4oYApgKX0KYCxzPVtdO2gmJnMucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhTYW1wbGVyOyIpLGkmJnMucHVzaCgidW5pZm9ybSBzYW1wbGVyMkQgdV9jbGlwU2FtcGxlcjsiKSx2W2RdW0NdPVtuK3Muam9pbihgCmApK2wuZGVmYXVsdCxuK2EuZGVmYXVsdF19fWZ1bmN0aW9uIGModix7aGFzVGV4dHVyZTpDPSExLGhhc0ZpbHRlcjpwPSExLGhhc0dyYWRpZW50Omg9ITEsaGFzQ2xpcFBhdGg6bT0hMX09e30pe2NvbnN0IHI9Q3xwPDwxfGg8PDJ8bTw8MztsZXQgaT12W2RdW3JdO0FycmF5LmlzQXJyYXkoaSkmJihpPXYuY3JlYXRlUHJvZ3JhbSguLi5pKSx2W2RdW3JdPWkpLHYucHJvZ3JhbSE9PWkmJnYudXNlUHJvZ3JhbShpLHthX2NvbG9yOnt0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITB9fSl9Y29uc3QgTz1bXTtmdW5jdGlvbiBmKHYpe2ZvcihsZXQgQz0wO0M8NjQ7QysrKXtjb25zdCBwPVtdLGg9ISEoQyYxKSxtPSEhKEMmMikscj0hIShDJjQpLGk9ISEoQyY4KSxuPSEhKEMmMTYpLHM9ISEoQyYzMik7aCYmcC5wdXNoKCIjZGVmaW5lIFRFWFRVUkUgMSIpLG0mJnAucHVzaCgiI2RlZmluZSBGSUxURVIgMSIpLHImJnAucHVzaCgiI2RlZmluZSBHUkFESUVOVCAxIiksaSYmcC5wdXNoKCIjZGVmaW5lIENMT1VEQ09MT1IgMSIpLG4mJnAucHVzaCgiI2RlZmluZSBDTE9VREZJTFRFUiAxIikscyYmcC5wdXNoKCIjZGVmaW5lIENMSVBQQVRIIDEiKTtjb25zdCB4PWAke3Auam9pbihgCmApfQpgLFA9W107aWYoaCl7UC5wdXNoKCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFNhbXBsZXI7Iik7Zm9yKGxldCBSPTA7UjwxMjtSKyspUC5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleEZyYW1lJHtSfTtgKX1zJiZQLnB1c2goInVuaWZvcm0gc2FtcGxlcjJEIHVfY2xpcFNhbXBsZXI7IiksT1tDXT1beCtQLmpvaW4oYApgKStULmRlZmF1bHQseCtNLmRlZmF1bHRdfX1mdW5jdGlvbiBnKHYse2hhc1RleHR1cmU6Qz0hMSxoYXNGaWx0ZXI6cD0hMSxoYXNHcmFkaWVudDpoPSExLGhhc0Nsb3VkQ29sb3I6bT0hMSxoYXNDbG91ZEZpbHRlcjpyPSExLGhhc0NsaXBQYXRoOmk9ITF9PXt9KXtjb25zdCBuPUN8cDw8MXxoPDwyfG08PDN8cjw8NHxpPDw1O2xldCBzPU9bbl07QXJyYXkuaXNBcnJheShzKSYmKHM9di5jcmVhdGVQcm9ncmFtKC4uLnMpLE9bbl09cyksdi5wcm9ncmFtIT09cyYmdi51c2VQcm9ncmFtKHMse2FfY29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9maWxsQ2xvdWRDb2xvcjp7dHlwZToiVU5TSUdORURfQllURSIsbm9ybWFsaXplOiEwfSxhX3N0cm9rZUNsb3VkQ29sb3I6e3R5cGU6IlVOU0lHTkVEX0JZVEUiLG5vcm1hbGl6ZTohMH0sYV9mcmFtZUluZGV4Ont0eXBlOiJVTlNJR05FRF9CWVRFIixub3JtYWxpemU6ITF9fSl9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsKdW5pZm9ybSBtYXQzIHZpZXdNYXRyaXg7CnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OwoKI2lmZGVmIFRFWFRVUkUKYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBHUkFESUVOVAp1bmlmb3JtIGZsb2F0IHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNl07CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgZ2xfUG9pbnRTaXplID0gMS4wOwoKICB2ZWMzIHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogdmVjMyhhX3ZlcnRleFBvc2l0aW9uLnh5LCAxLjApOwogIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIDEuMCwgMS4wKTsKCiNpZmRlZiBHUkFESUVOVAogIHZlYzMgdmcxID0gdmlld01hdHJpeCAqIHZlYzModV9yYWRpYWxHcmFkaWVudFZlY3RvclswXSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsxXSwgMS4wKTsKICB2ZWMzIHZnMiA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbM10sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbNF0sIDEuMCk7CiAgZmxvYXQgaCA9IHVfcmVzb2x1dGlvbi55OwogIHZnMS55ID0gaCAtIHZnMS55OwogIHZnMi55ID0gaCAtIHZnMi55OwogIHZHcmFkaWVudFZlY3RvcjEgPSB2ZWMzKHZnMS54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3RvclsyXSk7CiAgdkdyYWRpZW50VmVjdG9yMiA9IHZlYzModmcyLnh5LCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzVdKTsKI2VuZGlmCiAgCiAgZmxhZ0JhY2tncm91bmQgPSBhX3ZlcnRleFBvc2l0aW9uLno7CiAgdkNvbG9yID0gYV9jb2xvcjsKCiNpZmRlZiBURVhUVVJFCiAgdlRleHR1cmVDb29yZCA9IGFfdmVydGV4VGV4dHVyZUNvb3JkOwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCn1gfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7Cgp2YXJ5aW5nIHZlYzQgdkNvbG9yOwp2YXJ5aW5nIGZsb2F0IGZsYWdCYWNrZ3JvdW5kOwoKI2lmZGVmIFRFWFRVUkUKdmFyeWluZyB2ZWMzIHZUZXh0dXJlQ29vcmQ7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKdmFyeWluZyB2ZWMyIHZDbGlwVVY7CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgp1bmlmb3JtIGludCB1X2ZpbHRlckZsYWc7CnVuaWZvcm0gZmxvYXQgdV9jb2xvck1hdHJpeFsyMF07CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IxOwp2YXJ5aW5nIHZlYzMgdkdyYWRpZW50VmVjdG9yMjsKdW5pZm9ybSBmbG9hdCB1X2NvbG9yU3RlcHNbNDBdOwp1bmlmb3JtIGludCB1X2dyYWRpZW50VHlwZTsKLy8gdW5pZm9ybSBmbG9hdCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzZdOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgojaWZkZWYgRklMVEVSCnZvaWQgdHJhbnNmb3JtQ29sb3IoaW5vdXQgdmVjNCBjb2xvciwgaW4gZmxvYXQgY29sb3JNYXRyaXhbMjBdKSB7CiAgZmxvYXQgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgYSA9IGNvbG9yLmE7CiAgY29sb3JbMF0gPSBjb2xvck1hdHJpeFswXSAqIHIgKyBjb2xvck1hdHJpeFsxXSAqIGcgKyBjb2xvck1hdHJpeFsyXSAqIGIgKyBjb2xvck1hdHJpeFszXSAqIGEgKyBjb2xvck1hdHJpeFs0XTsKICBjb2xvclsxXSA9IGNvbG9yTWF0cml4WzVdICogciArIGNvbG9yTWF0cml4WzZdICogZyArIGNvbG9yTWF0cml4WzddICogYiArIGNvbG9yTWF0cml4WzhdICogYSArIGNvbG9yTWF0cml4WzldOwogIGNvbG9yWzJdID0gY29sb3JNYXRyaXhbMTBdICogciArIGNvbG9yTWF0cml4WzExXSAqIGcgKyBjb2xvck1hdHJpeFsxMl0gKiBiICsgY29sb3JNYXRyaXhbMTNdICogYSArIGNvbG9yTWF0cml4WzE0XTsKICBjb2xvclszXSA9IGNvbG9yTWF0cml4WzE1XSAqIHIgKyBjb2xvck1hdHJpeFsxNl0gKiBnICsgY29sb3JNYXRyaXhbMTddICogYiArIGNvbG9yTWF0cml4WzE4XSAqIGEgKyBjb2xvck1hdHJpeFsxOV07Cn0KI2VuZGlmCgp2b2lkIG1haW4oKSB7CiAgdmVjNCBjb2xvciA9IHZDb2xvcjsKICBmbG9hdCBvcGFjaXR5ID0gYWJzKGZsYWdCYWNrZ3JvdW5kKTsKCiNpZmRlZiBHUkFESUVOVAogIGlmKHVfZ3JhZGllbnRUeXBlID4gMCAmJiBmbGFnQmFja2dyb3VuZCA+IDAuMCB8fCB1X2dyYWRpZW50VHlwZSA9PSAwICYmIGZsYWdCYWNrZ3JvdW5kIDw9IDAuMCkgewogICAgZ3JhZGllbnQoY29sb3IsIHZHcmFkaWVudFZlY3RvcjEsIHZHcmFkaWVudFZlY3RvcjIsIHVfY29sb3JTdGVwcyk7CiAgfQojZW5kaWYKCiAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgY29sb3IuYSAqPSBvcGFjaXR5OwogIH0KCiNpZmRlZiBURVhUVVJFCiAgaWYoZmxhZ0JhY2tncm91bmQgPiAwLjApIHsKICAgIHZlYzMgdGV4Q29vcmQgPSB2VGV4dHVyZUNvb3JkOwoKICAgIGlmKHRleENvb3JkLnogPT0gMS4wKSB7CiAgICAgIHRleENvb3JkID0gZnJhY3QodGV4Q29vcmQpOwogICAgfQoKICAgIGlmKHRleENvb3JkLnggPD0gMS4wICYmIHRleENvb3JkLnggPj0gMC4wCiAgICAgICYmIHRleENvb3JkLnkgPD0gMS4wICYmIHRleENvb3JkLnkgPj0gMC4wKSB7CiAgICAgIGlmKHZTb3VyY2VSZWN0LnogPiAwLjApIHsKICAgICAgICB0ZXhDb29yZC54ID0gdlNvdXJjZVJlY3QueCArIHRleENvb3JkLnggKiB2U291cmNlUmVjdC56OwogICAgICAgIHRleENvb3JkLnkgPSAxLjAgLSAodlNvdXJjZVJlY3QueSArICgxLjAgLSB0ZXhDb29yZC55KSAqIHZTb3VyY2VSZWN0LncpOwogICAgICB9CiAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgaWYob3BhY2l0eSA8IDEuMCkgewogICAgICAgIHRleENvbG9yLmEgKj0gb3BhY2l0eTsKICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgIH0KICAgICAgLy8gY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgIC8vIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY29sb3IuYSk7CiAgICAgIGNvbG9yLnJnYiA9IG1peCh0ZXhDb2xvci5yZ2IsIGNvbG9yLnJnYiwgY2xhbXAoY29sb3IuYSAvIG1heCgwLjAwMDEsIHRleENvbG9yLmEpLCAwLjAsIDEuMCkpOwogICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICB9CiAgfQojZW5kaWYKCiNpZmRlZiBGSUxURVIKICBpZih1X2ZpbHRlckZsYWcgPiAwKSB7CiAgICB0cmFuc2Zvcm1Db2xvcihjb2xvciwgdV9jb2xvck1hdHJpeCk7CiAgfQojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIGZsb2F0IGNsaXAgPSB0ZXh0dXJlMkQodV9jbGlwU2FtcGxlciwgdkNsaXBVVikucjsKICBjb2xvciAqPSBjbGlwOwojZW5kaWYKCiAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7Cn1gfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLGUuZGVmYXVsdD1gYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjsKYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsKdmFyeWluZyB2ZWM0IHZDb2xvcjsKdmFyeWluZyBmbG9hdCBmbGFnQmFja2dyb3VuZDsKYXR0cmlidXRlIHZlYzMgYV90cmFuc2Zvcm0wOwphdHRyaWJ1dGUgdmVjMyBhX3RyYW5zZm9ybTE7CnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247CnVuaWZvcm0gbWF0MyB2aWV3TWF0cml4Owp1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsKCiNpZmRlZiBURVhUVVJFCmF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDsKYXR0cmlidXRlIGZsb2F0IGFfZnJhbWVJbmRleDsKdmFyeWluZyBmbG9hdCBmcmFtZUluZGV4OwphdHRyaWJ1dGUgdmVjNCBhX3NvdXJjZVJlY3Q7CnZhcnlpbmcgdmVjNCB2U291cmNlUmVjdDsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKYXR0cmlidXRlIHZlYzIgYV9jbGlwVVY7CnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQwOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQxOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQyOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQzOwphdHRyaWJ1dGUgdmVjNCBhX2NvbG9yQ2xvdWQ0Owp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgQ0xPVURDT0xPUgphdHRyaWJ1dGUgdmVjNCBhX2ZpbGxDbG91ZENvbG9yOwphdHRyaWJ1dGUgdmVjNCBhX3N0cm9rZUNsb3VkQ29sb3I7CiNlbmRpZgoKI2lmZGVmIEdSQURJRU5UCnVuaWZvcm0gZmxvYXQgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls2XTsKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwojZW5kaWYKCnZvaWQgbWFpbigpIHsKICBnbF9Qb2ludFNpemUgPSAxLjA7CgogIG1hdDMgbW9kZWxNYXRyaXggPSBtYXQzKAogICAgYV90cmFuc2Zvcm0wLngsIGFfdHJhbnNmb3JtMS54LCAwLCAKICAgIGFfdHJhbnNmb3JtMC55LCBhX3RyYW5zZm9ybTEueSwgMCwKICAgIGFfdHJhbnNmb3JtMC56LCBhX3RyYW5zZm9ybTEueiwgMQogICk7CgogIHZlYzMgcG9zID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzMoYV92ZXJ0ZXhQb3NpdGlvbi54eSwgMS4wKTsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAxLjAsIDEuMCk7CgojaWZkZWYgR1JBRElFTlQKICB2ZWMzIHZnMSA9IHZpZXdNYXRyaXggKiB2ZWMzKHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMF0sIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMV0sIDEuMCk7CiAgdmVjMyB2ZzIgPSB2aWV3TWF0cml4ICogdmVjMyh1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzNdLCB1X3JhZGlhbEdyYWRpZW50VmVjdG9yWzRdLCAxLjApOwogIGZsb2F0IGggPSB1X3Jlc29sdXRpb24ueTsKICB2ZzEueSA9IGggLSB2ZzEueTsKICB2ZzIueSA9IGggLSB2ZzIueTsKICB2R3JhZGllbnRWZWN0b3IxID0gdmVjMyh2ZzEueHksIHVfcmFkaWFsR3JhZGllbnRWZWN0b3JbMl0pOwogIHZHcmFkaWVudFZlY3RvcjIgPSB2ZWMzKHZnMi54eSwgdV9yYWRpYWxHcmFkaWVudFZlY3Rvcls1XSk7CiNlbmRpZgogIAogIGZsYWdCYWNrZ3JvdW5kID0gYV92ZXJ0ZXhQb3NpdGlvbi56OwoKI2lmZGVmIENMT1VEQ09MT1IKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdkNvbG9yID0gbWl4KGFfY29sb3IsIGFfZmlsbENsb3VkQ29sb3IsIGFfZmlsbENsb3VkQ29sb3IuYSk7CiAgfSBlbHNlIHsKICAgIHZDb2xvciA9IG1peChhX2NvbG9yLCBhX3N0cm9rZUNsb3VkQ29sb3IsIGFfc3Ryb2tlQ2xvdWRDb2xvci5hKTsKICB9CiNlbHNlCiAgdkNvbG9yID0gYV9jb2xvcjsKI2VuZGlmCgojaWZkZWYgVEVYVFVSRQogIHZUZXh0dXJlQ29vcmQgPSBhX3ZlcnRleFRleHR1cmVDb29yZDsKICBmcmFtZUluZGV4ID0gYV9mcmFtZUluZGV4OwogIHZTb3VyY2VSZWN0ID0gYV9zb3VyY2VSZWN0OwojZW5kaWYKCiNpZmRlZiBDTElQUEFUSAogIHZDbGlwVVYgPSBhX2NsaXBVVjsKI2VuZGlmCgojaWZkZWYgQ0xPVURGSUxURVIKICBjb2xvckNsb3VkMCA9IGFfY29sb3JDbG91ZDA7CiAgY29sb3JDbG91ZDEgPSBhX2NvbG9yQ2xvdWQxOwogIGNvbG9yQ2xvdWQyID0gYV9jb2xvckNsb3VkMjsKICBjb2xvckNsb3VkMyA9IGFfY29sb3JDbG91ZDM7CiAgY29sb3JDbG91ZDQgPSBhX2NvbG9yQ2xvdWQ0OwojZW5kaWYKfWB9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksZS5kZWZhdWx0PWBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKCnZhcnlpbmcgdmVjNCB2Q29sb3I7CnZhcnlpbmcgZmxvYXQgZmxhZ0JhY2tncm91bmQ7CgojaWZkZWYgVEVYVFVSRQp2YXJ5aW5nIGZsb2F0IGZyYW1lSW5kZXg7CnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkOwp2YXJ5aW5nIHZlYzQgdlNvdXJjZVJlY3Q7CiNlbmRpZgoKI2lmZGVmIENMSVBQQVRICnZhcnlpbmcgdmVjMiB2Q2xpcFVWOwojZW5kaWYKCiNpZmRlZiBGSUxURVIKdW5pZm9ybSBpbnQgdV9maWx0ZXJGbGFnOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JNYXRyaXhbMjBdOwojZW5kaWYKCiNpZmRlZiBDTE9VREZJTFRFUgp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDA7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkMTsKdmFyeWluZyB2ZWM0IGNvbG9yQ2xvdWQyOwp2YXJ5aW5nIHZlYzQgY29sb3JDbG91ZDM7CnZhcnlpbmcgdmVjNCBjb2xvckNsb3VkNDsKI2VuZGlmCgojaWZkZWYgR1JBRElFTlQKdmFyeWluZyB2ZWMzIHZHcmFkaWVudFZlY3RvcjE7CnZhcnlpbmcgdmVjMyB2R3JhZGllbnRWZWN0b3IyOwp1bmlmb3JtIGZsb2F0IHVfY29sb3JTdGVwc1s0MF07CnVuaWZvcm0gaW50IHVfZ3JhZGllbnRUeXBlOwoKdm9pZCBncmFkaWVudChpbm91dCB2ZWM0IGNvbG9yLCB2ZWMzIGd2MSwgdmVjMyBndjIsIGZsb2F0IGNvbG9yU3RlcHNbNDBdKSB7CiAgZmxvYXQgdDsKICAvLyBjZW50ZXIgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGNyID0gZ3YxLno7CiAgLy8gZm9jYWwgY2lyY2xlIHJhZGl1cwogIGZsb2F0IGZyID0gZ3YyLno7CgogIGlmKGNyID4gMC4wIHx8IGZyID4gMC4wKSB7CiAgICAvLyByYWRpYWwgZ3JhZGllbnQKICAgIHZlYzIgY2VudGVyID0gZ3YxLnh5OwogICAgdmVjMiBmb2NhbCA9IGd2Mi54eTsKICAgIGZsb2F0IHggPSBmb2NhbC54IC0gZ2xfRnJhZ0Nvb3JkLng7CiAgICBmbG9hdCB5ID0gZm9jYWwueSAtIGdsX0ZyYWdDb29yZC55OwogICAgZmxvYXQgZHggPSBmb2NhbC54IC0gY2VudGVyLng7CiAgICBmbG9hdCBkeSA9IGZvY2FsLnkgLSBjZW50ZXIueTsKICAgIGZsb2F0IGRyID0gY3IgLSBmcjsKICAgIGZsb2F0IGEgPSBkeCAqIGR4ICsgZHkgKiBkeSAtIGRyICogZHI7CiAgICBmbG9hdCBiID0gLTIuMCAqICh5ICogZHkgKyB4ICogZHggKyBmciAqIGRyKTsKICAgIGZsb2F0IGMgPSB4ICogeCArIHkgKiB5IC0gZnIgKiBmcjsKICAgIHQgPSAxLjAgLSAwLjUgKiAoMS4wIC8gYSkgKiAoLWIgKyBzcXJ0KGIgKiBiIC0gNC4wICogYSAqIGMpKTsKICB9IGVsc2UgewogICAgLy8gbGluZWFyIGdyYWRpZW50CiAgICB2ZWMyIHYxID0gZ2xfRnJhZ0Nvb3JkLnh5IC0gZ3YxLnh5OwogICAgdmVjMiB2MiA9IGd2Mi54eSAtIGd2MS54eTsKICAgIHQgPSAodjEueCAqIHYyLnggKyB2MS55ICogdjIueSkgLyAodjIueCAqIHYyLnggKyB2Mi55ICogdjIueSk7CiAgfQoKICB2ZWM0IGNvbG9yc1s4XTsKICBjb2xvcnNbMF0gPSB2ZWM0KGNvbG9yU3RlcHNbMV0sIGNvbG9yU3RlcHNbMl0sIGNvbG9yU3RlcHNbM10sIGNvbG9yU3RlcHNbNF0pOwogIGNvbG9yc1sxXSA9IHZlYzQoY29sb3JTdGVwc1s2XSwgY29sb3JTdGVwc1s3XSwgY29sb3JTdGVwc1s4XSwgY29sb3JTdGVwc1s5XSk7CiAgY29sb3JzWzJdID0gdmVjNChjb2xvclN0ZXBzWzExXSwgY29sb3JTdGVwc1sxMl0sIGNvbG9yU3RlcHNbMTNdLCBjb2xvclN0ZXBzWzE0XSk7CiAgY29sb3JzWzNdID0gdmVjNChjb2xvclN0ZXBzWzE2XSwgY29sb3JTdGVwc1sxN10sIGNvbG9yU3RlcHNbMThdLCBjb2xvclN0ZXBzWzE5XSk7CiAgY29sb3JzWzRdID0gdmVjNChjb2xvclN0ZXBzWzIxXSwgY29sb3JTdGVwc1syMl0sIGNvbG9yU3RlcHNbMjNdLCBjb2xvclN0ZXBzWzI0XSk7CiAgY29sb3JzWzVdID0gdmVjNChjb2xvclN0ZXBzWzI2XSwgY29sb3JTdGVwc1syN10sIGNvbG9yU3RlcHNbMjhdLCBjb2xvclN0ZXBzWzI5XSk7CiAgY29sb3JzWzZdID0gdmVjNChjb2xvclN0ZXBzWzMxXSwgY29sb3JTdGVwc1szMl0sIGNvbG9yU3RlcHNbMzNdLCBjb2xvclN0ZXBzWzM0XSk7CiAgY29sb3JzWzddID0gdmVjNChjb2xvclN0ZXBzWzM2XSwgY29sb3JTdGVwc1szN10sIGNvbG9yU3RlcHNbMzhdLCBjb2xvclN0ZXBzWzM5XSk7CiAgCiAgZmxvYXQgc3RlcHNbOF07CiAgc3RlcHNbMF0gPSBjb2xvclN0ZXBzWzBdOwogIHN0ZXBzWzFdID0gY29sb3JTdGVwc1s1XTsKICBzdGVwc1syXSA9IGNvbG9yU3RlcHNbMTBdOwogIHN0ZXBzWzNdID0gY29sb3JTdGVwc1sxNV07CiAgc3RlcHNbNF0gPSBjb2xvclN0ZXBzWzIwXTsKICBzdGVwc1s1XSA9IGNvbG9yU3RlcHNbMjVdOwogIHN0ZXBzWzZdID0gY29sb3JTdGVwc1szMF07CiAgc3RlcHNbN10gPSBjb2xvclN0ZXBzWzM1XTsKCiAgY29sb3IgPSBjb2xvcnNbMF07CiAgZm9yIChpbnQgaSA9IDE7IGkgPCA4OyBpKyspIHsKICAgIGlmIChzdGVwc1tpXSA8IDAuMCB8fCBzdGVwc1tpXSA+IDEuMCkgewogICAgICBicmVhazsKICAgIH0KICAgIGlmKHN0ZXBzW2ldID09IHN0ZXBzW2kgLSAxXSkgewogICAgICBjb2xvciA9IGNvbG9yc1tpXTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvcnNbaV0sIGNsYW1wKCh0IC0gc3RlcHNbaSAtIDFdKSAvIChzdGVwc1tpXSAtIHN0ZXBzW2kgLSAxXSksIDAuMCwgMS4wKSk7CiAgICB9CiAgICBpZiAoc3RlcHNbaV0gPj0gdCkgewogICAgICBicmVhazsKICAgIH0KICB9Cn0KI2VuZGlmCgp2b2lkIHRyYW5zZm9ybUNvbG9yKGlub3V0IHZlYzQgY29sb3IsIGluIGZsb2F0IGNvbG9yTWF0cml4WzIwXSkgewogIGZsb2F0IHIgPSBjb2xvci5yLCBnID0gY29sb3IuZywgYiA9IGNvbG9yLmIsIGEgPSBjb2xvci5hOwogIGNvbG9yWzBdID0gY29sb3JNYXRyaXhbMF0gKiByICsgY29sb3JNYXRyaXhbMV0gKiBnICsgY29sb3JNYXRyaXhbMl0gKiBiICsgY29sb3JNYXRyaXhbM10gKiBhICsgY29sb3JNYXRyaXhbNF07CiAgY29sb3JbMV0gPSBjb2xvck1hdHJpeFs1XSAqIHIgKyBjb2xvck1hdHJpeFs2XSAqIGcgKyBjb2xvck1hdHJpeFs3XSAqIGIgKyBjb2xvck1hdHJpeFs4XSAqIGEgKyBjb2xvck1hdHJpeFs5XTsKICBjb2xvclsyXSA9IGNvbG9yTWF0cml4WzEwXSAqIHIgKyBjb2xvck1hdHJpeFsxMV0gKiBnICsgY29sb3JNYXRyaXhbMTJdICogYiArIGNvbG9yTWF0cml4WzEzXSAqIGEgKyBjb2xvck1hdHJpeFsxNF07CiAgY29sb3JbM10gPSBjb2xvck1hdHJpeFsxNV0gKiByICsgY29sb3JNYXRyaXhbMTZdICogZyArIGNvbG9yTWF0cml4WzE3XSAqIGIgKyBjb2xvck1hdHJpeFsxOF0gKiBhICsgY29sb3JNYXRyaXhbMTldOwp9CgojaWZkZWYgQ0xPVURGSUxURVIKdm9pZCBidWlsZENsb3VkQ29sb3IoaW5vdXQgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF0pIHsKICBjb2xvckNsb3VkTWF0cml4WzBdID0gY29sb3JDbG91ZDBbMF07CiAgY29sb3JDbG91ZE1hdHJpeFsxXSA9IGNvbG9yQ2xvdWQxWzBdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMl0gPSBjb2xvckNsb3VkMlswXTsKICBjb2xvckNsb3VkTWF0cml4WzNdID0gY29sb3JDbG91ZDNbMF07CiAgY29sb3JDbG91ZE1hdHJpeFs0XSA9IGNvbG9yQ2xvdWQ0WzBdOwoKICBjb2xvckNsb3VkTWF0cml4WzVdID0gY29sb3JDbG91ZDBbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs2XSA9IGNvbG9yQ2xvdWQxWzFdOwogIGNvbG9yQ2xvdWRNYXRyaXhbN10gPSBjb2xvckNsb3VkMlsxXTsKICBjb2xvckNsb3VkTWF0cml4WzhdID0gY29sb3JDbG91ZDNbMV07CiAgY29sb3JDbG91ZE1hdHJpeFs5XSA9IGNvbG9yQ2xvdWQ0WzFdOwoKICBjb2xvckNsb3VkTWF0cml4WzEwXSA9IGNvbG9yQ2xvdWQwWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTFdID0gY29sb3JDbG91ZDFbMl07CiAgY29sb3JDbG91ZE1hdHJpeFsxMl0gPSBjb2xvckNsb3VkMlsyXTsKICBjb2xvckNsb3VkTWF0cml4WzEzXSA9IGNvbG9yQ2xvdWQzWzJdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMTRdID0gY29sb3JDbG91ZDRbMl07CgogIGNvbG9yQ2xvdWRNYXRyaXhbMTVdID0gY29sb3JDbG91ZDBbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxNl0gPSBjb2xvckNsb3VkMVszXTsKICBjb2xvckNsb3VkTWF0cml4WzE3XSA9IGNvbG9yQ2xvdWQyWzNdOwogIGNvbG9yQ2xvdWRNYXRyaXhbMThdID0gY29sb3JDbG91ZDNbM107CiAgY29sb3JDbG91ZE1hdHJpeFsxOV0gPSBjb2xvckNsb3VkNFszXTsKfQojZW5kaWYKCnZvaWQgbWFpbigpIHsKICB2ZWM0IGNvbG9yID0gdkNvbG9yOwogIGZsb2F0IG9wYWNpdHkgPSBhYnMoZmxhZ0JhY2tncm91bmQpOwoKI2lmZGVmIEdSQURJRU5UCiAgaWYodV9ncmFkaWVudFR5cGUgPiAwICYmIGZsYWdCYWNrZ3JvdW5kID4gMC4wIHx8IHVfZ3JhZGllbnRUeXBlID09IDAgJiYgZmxhZ0JhY2tncm91bmQgPD0gMC4wKSB7CiAgICBncmFkaWVudChjb2xvciwgdkdyYWRpZW50VmVjdG9yMSwgdkdyYWRpZW50VmVjdG9yMiwgdV9jb2xvclN0ZXBzKTsKICB9CiNlbmRpZgoKICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICBjb2xvci5hICo9IG9wYWNpdHk7CiAgfQoKI2lmZGVmIFRFWFRVUkUKICBpZihmbGFnQmFja2dyb3VuZCA+IDAuMCkgewogICAgdmVjMyB0ZXhDb29yZCA9IHZUZXh0dXJlQ29vcmQ7CgogICAgaWYodGV4Q29vcmQueiA9PSAxLjApIHsKICAgICAgdGV4Q29vcmQgPSBmcmFjdCh0ZXhDb29yZCk7CiAgICB9CgogICAgaWYodGV4Q29vcmQueCA8PSAxLjAgJiYgdGV4Q29vcmQueCA+PSAwLjAKICAgICAgJiYgdGV4Q29vcmQueSA8PSAxLjAgJiYgdGV4Q29vcmQueSA+PSAwLjApIHsKICAgICAgaWYodlNvdXJjZVJlY3QueiA+IDAuMCkgewogICAgICAgIHRleENvb3JkLnggPSB2U291cmNlUmVjdC54ICsgdGV4Q29vcmQueCAqIHZTb3VyY2VSZWN0Lno7CiAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtICh2U291cmNlUmVjdC55ICsgKDEuMCAtIHRleENvb3JkLnkpICogdlNvdXJjZVJlY3Qudyk7CiAgICAgIH0KICAgICAgaWYoZnJhbWVJbmRleCA8IDAuMCkgewogICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhTYW1wbGVyLCB0ZXhDb29yZC54eSk7CiAgICAgICAgY29sb3IgPSBtaXgoY29sb3IsIHRleENvbG9yLCB0ZXhDb2xvci5hKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbnQgaW5kZXggPSBpbnQoZmxvb3IoY2xhbXAoMC4wLCAxMS4wLCBmcmFtZUluZGV4KSkpOwogICAgICAgIHZlYzQgdGV4Q29sb3I7CiAgICAgICAgaWYoaW5kZXggPT0gMCkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxLCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSAyKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMiwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gMykgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTMsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDQpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU0LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA1KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lNSwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gNikgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTYsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDcpIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWU3LCB0ZXhDb29yZC54eSk7CiAgICAgICAgZWxzZSBpZihpbmRleCA9PSA4KSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lOCwgdGV4Q29vcmQueHkpOwogICAgICAgIGVsc2UgaWYoaW5kZXggPT0gOSkgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV90ZXhGcmFtZTksIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIGlmKGluZGV4ID09IDEwKSB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleEZyYW1lMTAsIHRleENvb3JkLnh5KTsKICAgICAgICBlbHNlIHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4RnJhbWUxMSwgdGV4Q29vcmQueHkpOwogICAgICAgIGZsb2F0IGFscGhhID0gdGV4Q29sb3IuYTsKICAgICAgICBpZihvcGFjaXR5IDwgMS4wKSB7CiAgICAgICAgICB0ZXhDb2xvci5hICo9IG9wYWNpdHk7CiAgICAgICAgICBhbHBoYSAqPSBtaXgoMC40NjUsIDEuMCwgb3BhY2l0eSk7CiAgICAgICAgfQogICAgICAgIC8vIGNvbG9yID0gbWl4KGNvbG9yLCB0ZXhDb2xvciwgdGV4Q29sb3IuYSk7CiAgICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdGV4Q29sb3IucmdiLCBhbHBoYSk7CiAgICAgICAgLy8gY29sb3IucmdiID0gbWl4KHRleENvbG9yLnJnYiwgY29sb3IucmdiLCBjb2xvci5hKTsKICAgICAgICBjb2xvci5yZ2IgPSBtaXgodGV4Q29sb3IucmdiLCBjb2xvci5yZ2IsIGNsYW1wKGNvbG9yLmEgLyBtYXgoMC4wMDAxLCB0ZXhDb2xvci5hKSwgMC4wLCAxLjApKTsKICAgICAgICBjb2xvci5hID0gdGV4Q29sb3IuYSArICgxLjAgLSB0ZXhDb2xvci5hKSAqIGNvbG9yLmE7CiAgICAgIH0KICAgIH0KICB9CiNlbmRpZgoKI2lmZGVmIEZJTFRFUgogIGlmKHVfZmlsdGVyRmxhZyA+IDApIHsKICAgIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCB1X2NvbG9yTWF0cml4KTsKICB9CiNlbmRpZgoKI2lmZGVmIENMT1VERklMVEVSCiAgZmxvYXQgY29sb3JDbG91ZE1hdHJpeFsyMF07CiAgYnVpbGRDbG91ZENvbG9yKGNvbG9yQ2xvdWRNYXRyaXgpOwogIHRyYW5zZm9ybUNvbG9yKGNvbG9yLCBjb2xvckNsb3VkTWF0cml4KTsKI2VuZGlmCgojaWZkZWYgQ0xJUFBBVEgKICBmbG9hdCBjbGlwID0gdGV4dHVyZTJEKHVfY2xpcFNhbXBsZXIsIHZDbGlwVVYpLnI7CiAgY29sb3IgKj0gY2xpcDsKI2VuZGlmCgogIGdsX0ZyYWdDb2xvciA9IGNvbG9yOwp9YH0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSwoZnVuY3Rpb24oYSxsKXt0LmQoZSwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImNhbmNlbEFuaW1hdGlvbkZyYW1lIixmdW5jdGlvbigpe3JldHVybiBkfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIE0oKXtpZih0eXBlb2YgcGVyZm9ybWFuY2U8InUiJiZwZXJmb3JtYW5jZS5ub3cpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKHR5cGVvZiBhPCJ1IiYmYS5ocnRpbWUpe2NvbnN0W3UsY109YS5ocnRpbWUoKTtyZXR1cm4gdSoxZTMrYyoxZS02fXJldHVybiBEYXRlLm5vdz9EYXRlLm5vdygpOm5ldyBEYXRlKCkuZ2V0VGltZSgpfWxldCBULGQ7dHlwZW9mIGw8InUiJiZ0eXBlb2YgbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9PSJmdW5jdGlvbiI/KFQ9bC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsZD1sLmNhbmNlbEFuaW1hdGlvbkZyYW1lKTooVD1mdW5jdGlvbih1KXtyZXR1cm4gc2V0VGltZW91dCgoKT0+e3UoTSgpKX0sMTYpfSxkPWZ1bmN0aW9uKHUpe3JldHVybiBjbGVhclRpbWVvdXQodSl9KX0pLmNhbGwodGhpcyx0KDY5KSx0KDIyKSl9LGZ1bmN0aW9uKEwsZSl7dmFyIHQ9TC5leHBvcnRzPXt9LGEsbDtmdW5jdGlvbiBNKCl7dGhyb3cgbmV3IEVycm9yKCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9ZnVuY3Rpb24gVCgpe3Rocm93IG5ldyBFcnJvcigiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9KGZ1bmN0aW9uKCl7dHJ5e3R5cGVvZiBzZXRUaW1lb3V0PT0iZnVuY3Rpb24iP2E9c2V0VGltZW91dDphPU19Y2F0Y2h7YT1NfXRyeXt0eXBlb2YgY2xlYXJUaW1lb3V0PT0iZnVuY3Rpb24iP2w9Y2xlYXJUaW1lb3V0Omw9VH1jYXRjaHtsPVR9fSkoKTtmdW5jdGlvbiBkKG0pe2lmKGE9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KG0sMCk7aWYoKGE9PT1NfHwhYSkmJnNldFRpbWVvdXQpcmV0dXJuIGE9c2V0VGltZW91dCxzZXRUaW1lb3V0KG0sMCk7dHJ5e3JldHVybiBhKG0sMCl9Y2F0Y2h7dHJ5e3JldHVybiBhLmNhbGwobnVsbCxtLDApfWNhdGNoe3JldHVybiBhLmNhbGwodGhpcyxtLDApfX19ZnVuY3Rpb24gdShtKXtpZihsPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQobSk7aWYoKGw9PT1UfHwhbCkmJmNsZWFyVGltZW91dClyZXR1cm4gbD1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KG0pO3RyeXtyZXR1cm4gbChtKX1jYXRjaHt0cnl7cmV0dXJuIGwuY2FsbChudWxsLG0pfWNhdGNoe3JldHVybiBsLmNhbGwodGhpcyxtKX19fXZhciBjPVtdLE89ITEsZixnPS0xO2Z1bmN0aW9uIHYoKXshT3x8IWZ8fChPPSExLGYubGVuZ3RoP2M9Zi5jb25jYXQoYyk6Zz0tMSxjLmxlbmd0aCYmQygpKX1mdW5jdGlvbiBDKCl7aWYoIU8pe3ZhciBtPWQodik7Tz0hMDtmb3IodmFyIHI9Yy5sZW5ndGg7cjspe2ZvcihmPWMsYz1bXTsrK2c8cjspZiYmZltnXS5ydW4oKTtnPS0xLHI9Yy5sZW5ndGh9Zj1udWxsLE89ITEsdShtKX19dC5uZXh0VGljaz1mdW5jdGlvbihtKXt2YXIgcj1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBpPTE7aTxhcmd1bWVudHMubGVuZ3RoO2krKylyW2ktMV09YXJndW1lbnRzW2ldO2MucHVzaChuZXcgcChtLHIpKSxjLmxlbmd0aD09PTEmJiFPJiZkKEMpfTtmdW5jdGlvbiBwKG0scil7dGhpcy5mdW49bSx0aGlzLmFycmF5PXJ9cC5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0sdC50aXRsZT0iYnJvd3NlciIsdC5icm93c2VyPSEwLHQuZW52PXt9LHQuYXJndj1bXSx0LnZlcnNpb249IiIsdC52ZXJzaW9ucz17fTtmdW5jdGlvbiBoKCl7fXQub249aCx0LmFkZExpc3RlbmVyPWgsdC5vbmNlPWgsdC5vZmY9aCx0LnJlbW92ZUxpc3RlbmVyPWgsdC5yZW1vdmVBbGxMaXN0ZW5lcnM9aCx0LmVtaXQ9aCx0LnByZXBlbmRMaXN0ZW5lcj1oLHQucHJlcGVuZE9uY2VMaXN0ZW5lcj1oLHQubGlzdGVuZXJzPWZ1bmN0aW9uKG0pe3JldHVybltdfSx0LmJpbmRpbmc9ZnVuY3Rpb24obSl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCIpfSx0LmN3ZD1mdW5jdGlvbigpe3JldHVybiIvIn0sdC5jaGRpcj1mdW5jdGlvbihtKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCIpfSx0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBSfSk7dmFyIGE9dCgxKSxsPXQoNzEpLE09dCg3MyksVD10KDIxMyksZD10KDIxNCksdT10KDIxNSksYz10KDIxNik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIE8oYixFKXt2YXIgRD1PYmplY3Qua2V5cyhiKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgST1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGIpO0UmJihJPUkuZmlsdGVyKGZ1bmN0aW9uKFMpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsUykuZW51bWVyYWJsZX0pKSxELnB1c2guYXBwbHkoRCxJKX1yZXR1cm4gRH1mdW5jdGlvbiBmKGIpe2Zvcih2YXIgRT0xO0U8YXJndW1lbnRzLmxlbmd0aDtFKyspe3ZhciBEPWFyZ3VtZW50c1tFXSE9bnVsbD9hcmd1bWVudHNbRV06e307RSUyP08oT2JqZWN0KEQpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKEkpe2coYixJLERbSV0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhEKSk6TyhPYmplY3QoRCkpLmZvckVhY2goZnVuY3Rpb24oSSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsSSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEQsSSkpfSl9cmV0dXJuIGJ9ZnVuY3Rpb24gZyhiLEUsRCl7cmV0dXJuIEUgaW4gYj9PYmplY3QuZGVmaW5lUHJvcGVydHkoYixFLHt2YWx1ZTpELGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6YltFXT1ELGJ9Y29uc3Qgdj1TeW1ib2wuZm9yKCJzcHJpdGVqc19jaGFuZ2VkQXR0cnMiKSxDPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxwPVN5bWJvbCgicmVzb2x1dGlvbiIpLGg9U3ltYm9sKCJhbmltYXRpb25zIiksbT1TeW1ib2woImV2ZW50TGlzdGVuZXJzIikscj1TeW1ib2woImNhcHR1cmVFdmVudExpc3RlbmVycyIpLGk9U3ltYm9sKCJmaWx0ZXJzIiksbj1TeW1ib2woImRpc3BsYXkiKSxzPVN5bWJvbCgicHJvZ3JhbSIpLHg9U3ltYm9sKCJzaGFkZXJBdHRycyIpLFA9U3ltYm9sKCJ1bmlmb3JtcyIpO2NsYXNzIFJ7Y29uc3RydWN0b3IoRT17fSl7dGhpcy5hdHRyaWJ1dGVzPW5ldyB0aGlzLmNvbnN0cnVjdG9yLkF0dHIodGhpcyksdGhpc1twXT17d2lkdGg6MzAwLGhlaWdodDoxNTB9LE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLEUpLHRoaXNbaF09bmV3IFNldCx0aGlzW21dPXt9LHRoaXNbcl09e319Z2V0IGFuY2VzdG9ycygpe2xldCBFPXRoaXMucGFyZW50O2NvbnN0IEQ9W107Zm9yKDtFOylELnB1c2goRSksRT1FLnBhcmVudDtyZXR1cm4gRH1nZXQgYW5pbWF0aW9ucygpe3JldHVybiB0aGlzW2hdfWdldCBmaWx0ZXJzKCl7cmV0dXJuIHRoaXNbaV18fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5maWx0ZXJzfWdldCBpc1Zpc2libGUoKXtyZXR1cm4hMX1nZXQgbGF5ZXIoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQubGF5ZXI6bnVsbH1nZXQgbG9jYWxNYXRyaXgoKXtjb25zdCBFPXRoaXMudHJhbnNmb3JtTWF0cml4LHt4OkQseTpJfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIEVbNF0rPUQsRVs1XSs9SSxFfWdldCBvcGFjaXR5KCl7bGV0IEU9dGhpcy5hdHRyaWJ1dGVzLm9wYWNpdHk7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcGFjaXR5IT1udWxsJiYoRSo9dGhpcy5wYXJlbnQub3BhY2l0eSksRX1nZXQgcGFyZW50Tm9kZSgpe3JldHVybiB0aGlzLnBhcmVudH1nZXQgbmV4dFNpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KDEpfWdldCBwcmV2aW91c1NpYmxpbmcoKXtyZXR1cm4gdGhpcy5nZXROb2RlTmVhckJ5KC0xKX1nZXQgcHJvZ3JhbSgpe3JldHVybiB0aGlzW3NdfWdldCByZW5kZXJlcigpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5yZW5kZXJlcjpudWxsfWdldCByZW5kZXJNYXRyaXgoKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXgpcmV0dXJuIHRoaXMuX19jYWNoZVJlbmRlck1hdHJpeDtsZXQgRT10aGlzLmxvY2FsTWF0cml4O2NvbnN0IEQ9dGhpcy5wYXJlbnQ7aWYoRCl7Y29uc3QgST1ELl9fY2FjaGVSZW5kZXJNYXRyaXh8fEQucmVuZGVyTWF0cml4O0kmJihFPWEubWF0MmQubXVsdGlwbHkoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksRSkpfXJldHVybiBFfWdldCB3b3JsZFNjYWxpbmcoKXtjb25zdCBFPXRoaXMucmVuZGVyTWF0cml4O3JldHVybltNYXRoLmh5cG90KEVbMF0sRVsxXSksTWF0aC5oeXBvdChFWzJdLEVbM10pXX1nZXQgd29ybGRSb3RhdGlvbigpe2NvbnN0IEU9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuIE1hdGguYXRhbjIoRVsxXSxFWzNdKX1nZXQgd29ybGRQb3NpdGlvbigpe2NvbnN0IEU9dGhpcy5yZW5kZXJNYXRyaXg7cmV0dXJuW0VbNF0sRVs1XV19Z2V0IHVuaWZvcm1zKCl7cmV0dXJuIHRoaXNbUF19Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuY2xhc3NOYW1lfXNldCBjbGFzc05hbWUoRSl7dGhpcy5hdHRyaWJ1dGVzLmNsYXNzTmFtZT1FfWdldCBpZCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuaWR9c2V0IGlkKEUpe3RoaXMuYXR0cmlidXRlcy5pZD1FfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5uYW1lfXNldCBuYW1lKEUpe3RoaXMuYXR0cmlidXRlcy5uYW1lPUV9Z2V0IHpJbmRleCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuekluZGV4fXNldCB6SW5kZXgoRSl7dGhpcy5hdHRyaWJ1dGVzLnpJbmRleD1FfWdldCBtZXNoKCl7cmV0dXJuIG51bGx9Z2V0IHNoYWRlckF0dHJzKCl7cmV0dXJuIHRoaXNbeF18fHt9fWFjdGl2YXRlQW5pbWF0aW9ucygpe2NvbnN0IEU9dGhpcy5sYXllcjtpZihFKXtjb25zdCBEPXRoaXNbaF07RC5mb3JFYWNoKFM9PntTLmJhc2VUaW1lbGluZT1FLnRpbWVsaW5lLFMucGxheSgpLFMuZmluaXNoZWQudGhlbigoKT0+e0QuZGVsZXRlKFMpfSl9KTtjb25zdCBJPXRoaXMuY2hpbGRyZW47SSYmSS5mb3JFYWNoKFM9PntTLmFjdGl2YXRlQW5pbWF0aW9ucyYmUy5hY3RpdmF0ZUFuaW1hdGlvbnMoKX0pfX1hZGRFdmVudExpc3RlbmVyKEUsRCxJPXt9KXtFPT09Im1vdXNld2hlZWwiJiYoRT0id2hlZWwiKSx0eXBlb2YgST09ImJvb2xlYW4iJiYoST17Y2FwdHVyZTpJfSk7Y29uc3R7Y2FwdHVyZTpTLG9uY2U6QX09SSxVPVM/cjptO3JldHVybiB0aGlzW1VdW0VdPXRoaXNbVV1bRV18fFtdLHRoaXNbVV1bRV0ucHVzaCh7bGlzdGVuZXI6RCxvbmNlOkF9KSx0aGlzfWFuaW1hdGUoRSxEKXtjb25zdCBJPW5ldyBNLmRlZmF1bHQodGhpcyxFLEQpO3JldHVybiB0aGlzLmVmZmVjdHMmJkkuYXBwbHlFZmZlY3RzKHRoaXMuZWZmZWN0cyksdGhpcy5sYXllciYmKEkuYmFzZVRpbWVsaW5lPXRoaXMubGF5ZXIudGltZWxpbmUsSS5wbGF5KCksSS5maW5pc2hlZC50aGVuKCgpPT57dGhpc1toXS5kZWxldGUoSSl9KSksdGhpc1toXS5hZGQoSSksSX1hdHRyKC4uLkUpe2lmKEUubGVuZ3RoPT09MClyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW0NdO2lmKEUubGVuZ3RoPjEpe2xldFtELEldPUU7cmV0dXJuIHR5cGVvZiBJPT0iZnVuY3Rpb24iJiYoST1JKHRoaXMuYXR0cihEKSkpLHRoaXMuc2V0QXR0cmlidXRlKEQsSSksdGhpc31yZXR1cm4gdHlwZW9mIEVbMF09PSJzdHJpbmciP3RoaXMuZ2V0QXR0cmlidXRlKEVbMF0pOihPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcyxFWzBdKSx0aGlzKX1jbG9uZU5vZGUoKXtjb25zdCBFPW5ldyB0aGlzLmNvbnN0cnVjdG9yLEQ9dGhpcy5hdHRyaWJ1dGVzW3ZdO3JldHVybiBFLmF0dHIoRCksRX1jb25uZWN0KEUsRCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudCIse3ZhbHVlOkUsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInpPcmRlciIse3ZhbHVlOkQsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksRS50aW1lbGluZSYmdGhpcy5hY3RpdmF0ZUFuaW1hdGlvbnMoKSx0aGlzLnNldFJlc29sdXRpb24oRS5nZXRSZXNvbHV0aW9uKCkpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImFwcGVuZCIsZGV0YWlsOntwYXJlbnQ6RSx6T3JkZXI6RH19KX1jb250YWlucyhFKXtmb3IoO0UmJnRoaXMhPT1FOylFPUUucGFyZW50O3JldHVybiEhRX1kZWFjdGl2YXRlQW5pbWF0aW9ucygpe3RoaXNbaF0uZm9yRWFjaChEPT5ELmNhbmNlbCgpKTtjb25zdCBFPXRoaXMuY2hpbGRyZW47RSYmRS5mb3JFYWNoKEQ9PntELmRlYWN0aXZhdGVBbmltYXRpb25zJiZELmRlYWN0aXZhdGVBbmltYXRpb25zKCl9KX1kaXNjb25uZWN0KCl7Y29uc3R7cGFyZW50OkUsek9yZGVyOkR9PXRoaXM7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcix0aGlzLmRlYWN0aXZhdGVBbmltYXRpb25zKCksdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJyZW1vdmUiLGRldGFpbDp7cGFyZW50OkUsek9yZGVyOkR9fSksRSYmRS5mb3JjZVVwZGF0ZSgpfWRpc3BhdGNoRXZlbnQoRSl7RSBpbnN0YW5jZW9mIGQuZGVmYXVsdHx8KEU9bmV3IGQuZGVmYXVsdChFKSksRS50YXJnZXQ9dGhpcztsZXQgRD1FLnR5cGU7RD09PSJtb3VzZXdoZWVsIiYmKEQ9IndoZWVsIik7Y29uc3QgST1bdGhpc107bGV0IFM9dGhpcy5wYXJlbnQ7Zm9yKDtFLmJ1YmJsZXMmJlM7KUkucHVzaChTKSxTPVMucGFyZW50O2ZvcihsZXQgQT1JLmxlbmd0aC0xO0E+PTA7QS0tKXtjb25zdCBVPUlbQV0sSz1VW3JdJiZVW3JdW0RdO2lmKEsmJksubGVuZ3RoJiYoRS5jdXJyZW50VGFyZ2V0PVUsSy5mb3JFYWNoKCh7bGlzdGVuZXI6VixvbmNlOkp9KT0+e1YuY2FsbCh0aGlzLEUpLEomJkkucmVtb3ZlRXZlbnRMaXN0ZW5lcihWKX0pLGRlbGV0ZSBFLmN1cnJlbnRUYXJnZXQpLCFFLmJ1YmJsZXMmJkUuY2FuY2VsQnViYmxlKWJyZWFrfWlmKCFFLmNhbmNlbEJ1YmJsZSlmb3IobGV0IEE9MDtBPEkubGVuZ3RoO0ErKyl7Y29uc3QgVT1JW0FdLEs9VVttXSYmVVttXVtEXTtpZihLJiZLLmxlbmd0aCYmKEUuY3VycmVudFRhcmdldD1VLEsuZm9yRWFjaCgoe2xpc3RlbmVyOlYsb25jZTpKfSk9PntWLmNhbGwodGhpcyxFKSxKJiZJLnJlbW92ZUV2ZW50TGlzdGVuZXIoVil9KSxkZWxldGUgRS5jdXJyZW50VGFyZ2V0KSwhRS5idWJibGVzfHxFLmNhbmNlbEJ1YmJsZSlicmVha319ZGlzcGF0Y2hQb2ludGVyRXZlbnQoRSl7Y29uc3R7bGF5ZXJYOkQsbGF5ZXJZOkl9PUU7cmV0dXJuIHRoaXMuaXNQb2ludENvbGxpc2lvbihELEkpPyh0aGlzLmRpc3BhdGNoRXZlbnQoRSksITApOiExfWRyYXcoRT1bXSl7Y29uc3QgRD10aGlzLm1lc2g7aWYoRCl7aWYoT2JqZWN0KHUuYXBwbHlGaWx0ZXJzKShELHRoaXMuZmlsdGVycyksRS5wdXNoKEQpLHRoaXNbc10pe0Quc2V0UHJvZ3JhbSh0aGlzW3NdKTtjb25zdCBJPXRoaXNbeF07SSYmT2JqZWN0LmVudHJpZXMoSSkuZm9yRWFjaCgoW0EsVV0pPT57RC5zZXRBdHRyaWJ1dGUoQSxVKX0pO2NvbnN0IFM9dGhpc1tQXTtpZih0aGlzW1BdKXtjb25zdCBBPXt9O09iamVjdC5lbnRyaWVzKFMpLmZvckVhY2goKFtVLEtdKT0+e3R5cGVvZiBLPT0iZnVuY3Rpb24iJiYoSz1LKHRoaXMsVSkpLEFbVV09S30pLEQuc2V0VW5pZm9ybXMoQSl9fU9iamVjdChjLmRlZmF1bHQpKHRoaXMsRCl9cmV0dXJuIEV9Zm9yY2VVcGRhdGUoKXt0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZm9yY2VVcGRhdGUoKX1nZXRBdHRyaWJ1dGUoRSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tFXX1nZXRMaXN0ZW5lcnMoRSx7Y2FwdHVyZTpEPSExfT17fSl7cmV0dXJuWy4uLnRoaXNbRD9yOm1dW0VdfHxbXV19Z2V0Tm9kZU5lYXJCeShFPTEpe2lmKCF0aGlzLnBhcmVudClyZXR1cm4gbnVsbDtpZihFPT09MClyZXR1cm4gdGhpcztjb25zdCBEPXRoaXMucGFyZW50LmNoaWxkcmVuLEk9RC5pbmRleE9mKHRoaXMpO3JldHVybiBEW0krRV19Z2V0V29ybGRQb3NpdGlvbihFLEQpe2NvbnN0IEk9dGhpcy5yZW5kZXJNYXRyaXgsUz1FKklbMF0rRCpJWzJdK0lbNF0sQT1FKklbMV0rRCpJWzNdK0lbNV07cmV0dXJuW1MsQV19Z2V0T2Zmc2V0UG9zaXRpb24oRSxEKXtjb25zdCBJPWEubWF0MmQuaW52ZXJ0KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLnJlbmRlck1hdHJpeCksUz1FKklbMF0rRCpJWzJdK0lbNF0sQT1FKklbMV0rRCpJWzNdK0lbNV07cmV0dXJuW1MsQV19Z2V0UmVzb2x1dGlvbigpe3JldHVybiBmKHt9LHRoaXNbcF0pfWlzUG9pbnRDb2xsaXNpb24oRSxEKXtpZighdGhpcy5tZXNoKXJldHVybiExO2NvbnN0IEk9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYoST09PSJub25lInx8SSE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IFM9ImJvdGgiO3JldHVybiBJPT09InZpc2libGVGaWxsIiYmKFM9ImZpbGwiKSxJPT09InZpc2libGVTdHJva2UiJiYoUz0ic3Ryb2tlIiksdGhpcy5tZXNoLmlzUG9pbnRDb2xsaXNpb24oRSxELFMpfW9uUHJvcGVydHlDaGFuZ2UoRSxELEkpe0UhPT0iaWQiJiZFIT09Im5hbWUiJiZFIT09ImNsYXNzTmFtZSImJkUhPT0icG9pbnRlckV2ZW50cyImJkUhPT0icGFzc0V2ZW50cyImJnRoaXMuZm9yY2VVcGRhdGUoKSxFPT09ImZpbHRlciImJih0aGlzW2ldPU9iamVjdCh1LnBhcnNlRmlsdGVyU3RyaW5nKShEKSksRT09PSJ6SW5kZXgiJiZ0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucmVvcmRlcigpfXNldEF0dHJpYnV0ZShFLEQpe0U9PT0iYXR0cnMiJiZ0aGlzLmF0dHIoRCksdGhpcy5hdHRyaWJ1dGVzW0VdPUR9c2V0TW91c2VDYXB0dXJlKCl7dGhpcy5sYXllciYmKHRoaXMubGF5ZXIuX19tb3VzZUNhcHR1cmVkVGFyZ2V0PXRoaXMpfXNldFByb2dyYW0oRSl7dGhpc1tzXT1FLHRoaXMuZm9yY2VVcGRhdGUoKX1zZXRTaGFkZXJBdHRyaWJ1dGUoRSxEKXt0aGlzW3hdPXRoaXNbeF18fHt9LHRoaXNbeF1bRV09RCx0aGlzLmZvcmNlVXBkYXRlKCl9c2V0VW5pZm9ybXMoRSl7dGhpc1tQXT10aGlzW1BdfHx7fSxPYmplY3QuYXNzaWduKHRoaXNbUF0sRSksdGhpcy5mb3JjZVVwZGF0ZSgpfXNldFJlc29sdXRpb24oe3dpZHRoOkUsaGVpZ2h0OkR9KXtjb25zdHt3aWR0aDpJLGhlaWdodDpTfT10aGlzW3BdOyhJIT09RXx8UyE9PUQpJiYodGhpc1twXT17d2lkdGg6RSxoZWlnaHQ6RH0sdGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToicmVzb2x1dGlvbmNoYW5nZSIsZGV0YWlsOnt3aWR0aDpFLGhlaWdodDpEfX0pKX1zaG93KCl7dGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSImJih0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT10aGlzW25dfHwiIil9aGlkZSgpe3RoaXMuYXR0cmlidXRlcy5kaXNwbGF5IT09Im5vbmUiJiYodGhpc1tuXT10aGlzLmF0dHJpYnV0ZXMuZGlzcGxheSx0aGlzLmF0dHJpYnV0ZXMuZGlzcGxheT0ibm9uZSIpfXJlbGVhc2VNb3VzZUNhcHR1cmUoKXt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD09PXRoaXMmJih0aGlzLmxheWVyLl9fbW91c2VDYXB0dXJlZFRhcmdldD1udWxsKX1yZW1vdmUoKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LnJlbW92ZUNoaWxkPyh0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSwhMCk6ITF9cmVtb3ZlQWxsTGlzdGVuZXJzKEUsRD17fSl7dHlwZW9mIEQ9PSJib29sZWFuIiYmKEQ9e2NhcHR1cmU6RH0pO2NvbnN0IFM9RC5jYXB0dXJlP3I6bTtyZXR1cm4gdGhpc1tTXVtFXSYmKHRoaXNbU11bRV09W10pLHRoaXN9cmVtb3ZlQXR0cmlidXRlKEUpe3RoaXMuc2V0QXR0cmlidXRlKEUsbnVsbCl9cmVtb3ZlRXZlbnRMaXN0ZW5lcihFLEQsST17fSl7dHlwZW9mIEk9PSJib29sZWFuIiYmKEk9e2NhcHR1cmU6SX0pO2NvbnN0IEE9SS5jYXB0dXJlP3I6bTtpZih0aGlzW0FdW0VdKXtjb25zdCBVPXRoaXNbQV1bRV07aWYoVSlmb3IobGV0IEs9MDtLPFUubGVuZ3RoO0srKyl7Y29uc3R7bGlzdGVuZXI6Vn09VVtLXTtpZihWPT09RCl7dGhpc1tBXVtFXS5zcGxpY2UoSywxKTticmVha319fXJldHVybiB0aGlzfXRyYW5zaXRpb24oRSxEPSJsaW5lYXIiKXtjb25zdCBJPXRoaXMsUz1TeW1ib2woImFuaW1hdGlvbiIpO0Q9RHx8ImxpbmVhciI7bGV0IEE9MDtyZXR1cm4gdHlwZW9mIEU9PSJvYmplY3QiJiYoQT1FLmRlbGF5fHwwLEU9RS5kdXJhdGlvbikse1tTXTpudWxsLGNhbmNlbChVPSExKXtjb25zdCBLPXRoaXNbU107SyYmSy5jYW5jZWwoVSl9LGVuZCgpe2NvbnN0IFU9dGhpc1tTXTtVJiYoVS5wbGF5U3RhdGU9PT0icnVubmluZyJ8fFUucGxheVN0YXRlPT09InBlbmRpbmciKSYmVS5maW5pc2goKX0scmV2ZXJzZSgpe2NvbnN0IFU9dGhpc1tTXTtpZihVKWlmKFUucGxheVN0YXRlPT09InJ1bm5pbmcifHxVLnBsYXlTdGF0ZT09PSJwZW5kaW5nIilVLnBsYXliYWNrUmF0ZT0tVS5wbGF5YmFja1JhdGU7ZWxzZXtjb25zdCBLPVUudGltaW5nLmRpcmVjdGlvbjtVLnRpbWluZy5kaXJlY3Rpb249Sz09PSJyZXZlcnNlIj8ibm9ybWFsIjoicmV2ZXJzZSIsVS5wbGF5KCl9cmV0dXJuIFUuZmluaXNoZWR9LGF0dHIoVSxLKXtyZXR1cm4gdGhpcy5lbmQoKSx0eXBlb2YgVT09InN0cmluZyImJihVPXtbVV06S30pLE9iamVjdC5lbnRyaWVzKFUpLmZvckVhY2goKFtWLEpdKT0+e3R5cGVvZiBKPT0iZnVuY3Rpb24iJiYoVVtWXT1KKEkuYXR0cihWKSkpfSksdGhpc1tTXT1JLmFuaW1hdGUoW1VdLHtkdXJhdGlvbjpFKjFlMyxkZWxheTpBKjFlMyxmaWxsOiJmb3J3YXJkcyIsZWFzaW5nOkR9KSx0aGlzW1NdLmZpbmlzaGVkfX19dXBkYXRlQ29udG91cnMoKXt9fWcoUiwiQXR0ciIsbC5kZWZhdWx0KSxULmRlZmF1bHQucmVnaXN0ZXJOb2RlKFIsIm5vZGUiKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gUn0pO3ZhciBhPXQoMSksbD10KDEyKSxNPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxPPVN5bWJvbC5mb3IoInNwcml0ZWpzX2F0dHJpYnV0ZXMiKSxmPVN5bWJvbC5mb3IoInNwcml0ZWpzX2NoYW5nZWRBdHRycyIpLGc9U3ltYm9sKCJzdWJqZWN0Iiksdj1TeW1ib2woImF0dHIiKSxDPVN5bWJvbCgiZGVmYXVsdCIpLHA9U3ltYm9sKCJhbGlhcyIpO2Z1bmN0aW9uIGgoYixbRSxEXSl7bGV0IEk9YS5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtyZXR1cm5bLi4uYl0uZm9yRWFjaCgoW1MsQV0pPT57aWYoKEV8fEQpJiYoST1hLm1hdDJkLnRyYW5zbGF0ZShBcnJheS5vZigwLDAsMCwwLDAsMCksSSxbRSxEXSkpLFM9PT0ibWF0cml4IilJPWEubWF0MmQubXVsdGlwbHkoSSxJLEEpO2Vsc2UgaWYoUz09PSJvZmZzZXRUcmFuc2xhdGUiKUlbNF0rPUFbMF0sSVs1XSs9QVsxXTtlbHNlIGlmKFM9PT0ib2Zmc2V0Um90YXRlIilJPWEubWF0MmQucm90YXRlKEFycmF5Lm9mKDAsMCwwLDAsMCwwKSxJLEEpO2Vsc2UgaWYoUz09PSJza2V3Iil7Y29uc3RbVSxLXT1BO0k9YS5tYXQyZC5tdWx0aXBseShJLEksYS5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oSyksTWF0aC50YW4oVSksMSwwLDApKX1lbHNlIGEubWF0MmRbU10oSSxJLEEpOyhFfHxEKSYmKEk9YS5tYXQyZC50cmFuc2xhdGUoQXJyYXkub2YoMCwwLDAsMCwwLDApLEksWy1FLC1EXSkpfSksSX1jb25zdCBtPVN5bWJvbCgidHJhbnNmb3JtTWF0cml4Iikscj1TeW1ib2woInRyYW5zZm9ybXMiKSxpPVN5bWJvbCgiY2hhbmdlZEF0dHJzIiksbj1TeW1ib2woImxhc3RDaGFuZ2VkQXR0ciIpLHM9U3ltYm9sKCJvZmZzZXRGaWd1cmUiKTtmdW5jdGlvbiB4KGIsRSxEKXtjb25zdCBJPWJbdl1bRV07aWYoYlt1XShFLEQsITEpfHxiW25dIT09RSl7Y29uc3QgQT1iW3JdO0EuaGFzKEUpJiZBLmRlbGV0ZShFKSxEJiYoRT09PSJyb3RhdGUiJiYoRD1NYXRoLlBJKkQvMTgwKSxFPT09InNjYWxlIiYmKEQ9RC5tYXAoVT0+TWF0aC5hYnMoVSk+MWUtNT9VOjEvVT4wPzFlLTU6LTFlLTUpKSxBLnNldChFLEQpKSxiW21dPW51bGwsYltnXS5vblByb3BlcnR5Q2hhbmdlKEUsRCxJLGIpfX1mdW5jdGlvbiBQKGIpe2NvbnN0IEU9YltzXSxEPWIub2Zmc2V0RGlzdGFuY2UqRS5nZXRUb3RhbExlbmd0aCgpLEk9RS5nZXRQb2ludEF0TGVuZ3RoKEQpO2lmKEkpe2NvbnN0IFM9YltyXTtsZXQgQT1iLm9mZnNldFJvdGF0ZTtBPT09ImF1dG8iP0E9SS5hbmdsZTpBPT09InJldmVyc2UiP0E9TWF0aC5QSStJLmFuZ2xlOkE9TWF0aC5QSSpBLzE4MCxTLnNldCgib2Zmc2V0Um90YXRlIixBKSxTLnNldCgib2Zmc2V0VHJhbnNsYXRlIixbSS54LEkueV0pLGJbbV09bnVsbH19Y2xhc3MgUntzdGF0aWMgc2V0RGVmYXVsdChFLC4uLkQpe3JldHVybiBFW1RdKC4uLkQpfXN0YXRpYyBkZWNsYXJlQWxpYXMoRSwuLi5EKXtyZXR1cm4gRVtkXSguLi5EKX1zdGF0aWMgc2V0QXR0cmlidXRlKEUsLi4uRCl7cmV0dXJuIEVbdV0oLi4uRCl9c3RhdGljIGdldEF0dHJpYnV0ZShFLC4uLkQpe3JldHVybiBFW2NdKC4uLkQpfXN0YXRpYyBnZXRBdHRyaWJ1dGVzKEUpe3JldHVybiBFW09dfXN0YXRpYyBnZXRDaGFuZ2VkQXR0cmlidXRlcyhFKXtyZXR1cm4gRVtmXX1jb25zdHJ1Y3RvcihFKXt0aGlzW2ddPUUsdGhpc1t2XT17fSx0aGlzW21dPWEubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCksdGhpc1tyXT1uZXcgTWFwLHRoaXNbQ109e30sdGhpc1twXT1bXSxPYmplY3QuZGVmaW5lUHJvcGVydHkoRSwidHJhbnNmb3JtTWF0cml4Iix7Z2V0OigpPT4odGhpc1ttXXx8KHRoaXNbbV09aCh0aGlzW3JdLHRoaXMudHJhbnNmb3JtT3JpZ2luKSksWy4uLnRoaXNbbV1dKX0pLHRoaXNbVF0oe2lkOiIiLG5hbWU6IiIsY2xhc3NOYW1lOiIiLHg6MCx5OjAsdHJhbnNmb3JtT3JpZ2luOlswLDBdLHRyYW5zZm9ybToiIix0cmFuc2xhdGU6WzAsMF0scm90YXRlOjAsc2NhbGU6WzEsMV0sc2tldzpbMCwwXSxvcGFjaXR5OjEsekluZGV4OjAsb2Zmc2V0UGF0aDp2b2lkIDAsb2Zmc2V0RGlzdGFuY2U6MCxvZmZzZXRSb3RhdGU6ImF1dG8iLHBvaW50ZXJFdmVudHM6InZpc2libGUiLGZpbHRlcjoibm9uZSIsZGlzcGxheToiIn0pLHRoaXNbZF0oImNsYXNzIiwicG9zIiksdGhpc1tpXT1uZXcgU2V0LHRoaXNbc109bmV3IGwuRmlndXJlMkQoe3NjYWxlOjUsc2ltcGxpZnk6MH0pfWdldFtmXSgpe2NvbnN0IEU9e307cmV0dXJuWy4uLnRoaXNbaV1dLmZvckVhY2goRD0+e0VbRF09dGhpc1t2XVtEXX0pLEV9Z2V0W09dKCl7Y29uc3QgRT1PYmplY3QuYXNzaWduKHt9LHRoaXNbdl0pO2ZvcihsZXQgRD0wO0Q8dGhpc1twXS5sZW5ndGg7RCsrKXtjb25zdCBJPXRoaXNbcF1bRF07RVtJXT10aGlzW0ldfXJldHVybiBFfVtUXShFKXtPYmplY3QuYXNzaWduKHRoaXNbQ10sRSksT2JqZWN0LmFzc2lnbih0aGlzW3ZdLEUpfVtkXSguLi5FKXt0aGlzW3BdLnB1c2goLi4uRSl9W3VdKEUsRCxJPSEwKXtjb25zdCBTPXRoaXNbdl1bRV0sQT10aGlzW2ddO3JldHVybiBEPT1udWxsJiYoRD10aGlzW0NdW0VdKSxPYmplY3QoTS5jb21wYXJlVmFsdWUpKFMsRCk/ITE6KHRoaXNbdl1bRV09RCx0aGlzW2ldLmhhcyhFKSYmdGhpc1tpXS5kZWxldGUoRSksdGhpc1tpXS5hZGQoRSksdGhpc1tuXT1FLEkmJkEub25Qcm9wZXJ0eUNoYW5nZShFLEQsUyx0aGlzKSwhMCl9W2NdKEUpe3JldHVybiB0aGlzW3ZdW0VdfXNldCBpZChFKXt0aGlzW3VdKCJpZCIsRSl9Z2V0IGlkKCl7cmV0dXJuIHRoaXNbY10oImlkIil9c2V0IG5hbWUoRSl7dGhpc1t1XSgibmFtZSIsRSl9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpc1tjXSgibmFtZSIpfXNldCBjbGFzc05hbWUoRSl7dGhpc1t1XSgiY2xhc3NOYW1lIixFKX1nZXQgY2xhc3NOYW1lKCl7cmV0dXJuIHRoaXNbY10oImNsYXNzTmFtZSIpfXNldCBjbGFzcyhFKXt0aGlzLmNsYXNzTmFtZT1FfWdldCBjbGFzcygpe3JldHVybiB0aGlzLmNsYXNzTmFtZX1nZXQgeCgpe3JldHVybiB0aGlzW2NdKCJ4Iil9c2V0IHgoRSl7dGhpc1t1XSgieCIsT2JqZWN0KE0udG9OdW1iZXIpKEUpKX1nZXQgeSgpe3JldHVybiB0aGlzW2NdKCJ5Iil9c2V0IHkoRSl7dGhpc1t1XSgieSIsT2JqZWN0KE0udG9OdW1iZXIpKEUpKX1nZXQgcG9zKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldCBwb3MoRSl7RT1PYmplY3QoTS50b0FycmF5KShFKSxBcnJheS5pc0FycmF5KEUpfHwoRT1bRSxFXSksdGhpcy54PUVbMF0sdGhpcy55PUVbMV19Z2V0IHRyYW5zZm9ybSgpe3JldHVybiB0aGlzW2NdKCJ0cmFuc2Zvcm0iKX1zZXQgdHJhbnNmb3JtKEUpe2xldCBEPW51bGw7aWYoQXJyYXkuaXNBcnJheShFKSYmKEQ9RSxFPWBtYXRyaXgoJHtFLm1hcChNLnRvTnVtYmVyKS5qb2luKCl9KWApLHR5cGVvZiBFPT0ic3RyaW5nIilFPUUucmVwbGFjZSgvXHMqLFxzKi9nLCIsIik7ZWxzZSBpZihFIT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdHJhbnNmb3JtIHZhbHVlLiIpO2NvbnN0IEk9dGhpc1t2XS50cmFuc2Zvcm07aWYodGhpc1t1XSgidHJhbnNmb3JtIixFLCExKSl7Y29uc3QgUz10aGlzW3JdO2lmKFMuaGFzKCJtYXRyaXgiKSYmUy5kZWxldGUoIm1hdHJpeCIpLEQpUy5zZXQoIm1hdHJpeCIsRCk7ZWxzZSBpZihFKXtjb25zdCBBPUUubWF0Y2goLyhtYXRyaXh8dHJhbnNsYXRlfHJvdGF0ZXxzY2FsZXxza2V3KVwoW14oKV0rXCkvZyk7aWYoQSl7bGV0IFU9YS5tYXQyZC5mcm9tVmFsdWVzKDEsMCwwLDEsMCwwKTtmb3IobGV0IEs9MDtLPEEubGVuZ3RoO0srKyl7Y29uc3QgSj1BW0tdLm1hdGNoKC9eKG1hdHJpeHx0cmFuc2xhdGV8cm90YXRlfHNjYWxlfHNrZXcpXCgoW14oKV0rKVwpLyk7aWYoSil7bGV0WyxxLFddPUo7cT09PSJyb3RhdGUiP1c9TWF0aC5QSSpwYXJzZUZsb2F0KFcpLzE4MDpXPVcudHJpbSgpLnNwbGl0KC9bXHMsXSsvKS5tYXAoSD0+T2JqZWN0KE0udG9OdW1iZXIpKEgpKSxxPT09Im1hdHJpeCI/VT1hLm1hdDJkLm11bHRpcGx5KFUsVSxXKTpxPT09InNrZXciP1U9YS5tYXQyZC5tdWx0aXBseShVLFUsYS5tYXQyZC5mcm9tVmFsdWVzKDEsTWF0aC50YW4oV1sxXSksTWF0aC50YW4oV1swXSksMSwwLDApKTphLm1hdDJkW3FdKFUsVSxXKSxTLnNldCgibWF0cml4IixVKX19fWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCB0cmFuc2Zvcm0gdmFsdWUuIil9dGhpc1ttXT1udWxsLHRoaXNbZ10ub25Qcm9wZXJ0eUNoYW5nZSgidHJhbnNmb3JtIixFLEksdGhpcyl9fWdldCB0cmFuc2Zvcm1PcmlnaW4oKXtyZXR1cm4gdGhpc1tjXSgidHJhbnNmb3JtT3JpZ2luIil9c2V0IHRyYW5zZm9ybU9yaWdpbihFKXtFPU9iamVjdChNLnRvQXJyYXkpKEUsITApLEUhPW51bGwmJiFBcnJheS5pc0FycmF5KEUpJiYoRT1bRSxFXSksdGhpc1t1XSgidHJhbnNmb3JtT3JpZ2luIixFKSYmKHRoaXNbbV09bnVsbCl9Z2V0IHJvdGF0ZSgpe3JldHVybiB0aGlzW2NdKCJyb3RhdGUiKX1zZXQgcm90YXRlKEUpe3godGhpcywicm90YXRlIixFKX1nZXQgdHJhbnNsYXRlKCl7cmV0dXJuIHRoaXNbY10oInRyYW5zbGF0ZSIpfXNldCB0cmFuc2xhdGUoRSl7RT1PYmplY3QoTS50b0FycmF5KShFLCEwKSxFIT1udWxsJiYhQXJyYXkuaXNBcnJheShFKSYmKEU9W0UsRV0pLHgodGhpcywidHJhbnNsYXRlIixFKX1nZXQgc2NhbGUoKXtyZXR1cm4gdGhpc1tjXSgic2NhbGUiKX1zZXQgc2NhbGUoRSl7RT1PYmplY3QoTS50b0FycmF5KShFLCEwKSxFIT1udWxsJiYhQXJyYXkuaXNBcnJheShFKSYmKEU9W0UsRV0pLHgodGhpcywic2NhbGUiLEUpfWdldCBza2V3KCl7cmV0dXJuIHRoaXNbY10oInNrZXciKX1zZXQgc2tldyhFKXtFPU9iamVjdChNLnRvQXJyYXkpKEUsITApLEUhPW51bGwmJiFBcnJheS5pc0FycmF5KEUpJiYoRT1bRSxFXSkseCh0aGlzLCJza2V3IixFKX1nZXQgb3BhY2l0eSgpe3JldHVybiB0aGlzW2NdKCJvcGFjaXR5Iil9c2V0IG9wYWNpdHkoRSl7RSE9bnVsbCYmKEU9TnVtYmVyKEUpKSx0aGlzW3VdKCJvcGFjaXR5IixFKX1nZXQgekluZGV4KCl7cmV0dXJuIHRoaXNbY10oInpJbmRleCIpfXNldCB6SW5kZXgoRSl7RSE9bnVsbCYmKEU9TnVtYmVyKEUpKSx0aGlzW3VdKCJ6SW5kZXgiLEUpfWdldCBvZmZzZXRQYXRoKCl7cmV0dXJuIHRoaXNbY10oIm9mZnNldFBhdGgiKX1zZXQgb2Zmc2V0UGF0aChFKXt0aGlzW3VdKCJvZmZzZXRQYXRoIixFKSYmKHRoaXNbc10uYmVnaW5QYXRoKCksRSE9bnVsbCYmdGhpc1tzXS5hZGRQYXRoKEUpLFAodGhpcykpfWdldCBvZmZzZXREaXN0YW5jZSgpe3JldHVybiB0aGlzW2NdKCJvZmZzZXREaXN0YW5jZSIpfXNldCBvZmZzZXREaXN0YW5jZShFKXt0aGlzW3VdKCJvZmZzZXREaXN0YW5jZSIsT2JqZWN0KE0udG9OdW1iZXIpKEUpKSYmUCh0aGlzKX1nZXQgb2Zmc2V0Um90YXRlKCl7cmV0dXJuIHRoaXNbY10oIm9mZnNldFJvdGF0ZSIpfXNldCBvZmZzZXRSb3RhdGUoRSl7dGhpc1t1XSgib2Zmc2V0Um90YXRlIixFKSxQKHRoaXMpfWdldCBwb2ludGVyRXZlbnRzKCl7cmV0dXJuIHRoaXNbY10oInBvaW50ZXJFdmVudHMiKX1zZXQgcG9pbnRlckV2ZW50cyhFKXtpZihFIT1udWxsJiZFIT09Im5vbmUiJiZFIT09InZpc2libGUiJiZFIT09InZpc2libGVGaWxsIiYmRSE9PSJ2aXNpYmxlU3Ryb2tlIiYmRSE9PSJhbGwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgcG9pbnRlckV2ZW50cyB0eXBlLiIpO3RoaXNbdV0oInBvaW50ZXJFdmVudHMiLEUpfWdldCBmaWx0ZXIoKXtyZXR1cm4gdGhpc1tjXSgiZmlsdGVyIil9c2V0IGZpbHRlcihFKXt0aGlzW3VdKCJmaWx0ZXIiLEUpfWdldCBkaXNwbGF5KCl7cmV0dXJuIHRoaXNbY10oImRpc3BsYXkiKX1zZXQgZGlzcGxheShFKXt0aGlzW3VdKCJkaXNwbGF5IixFKX1zZXQgb2Zmc2V0KEUpe319fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJzaXplVG9QaXhlbCIsZnVuY3Rpb24oKXtyZXR1cm4gYX0pLHQuZChlLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pLHQuZChlLCJ0b051bWJlciIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pLHQuZChlLCJ0b0FycmF5IixmdW5jdGlvbigpe3JldHVybiBUfSksdC5kKGUsImNvbXBhcmVWYWx1ZSIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBhKHUsYyl7Y29uc3QgTz11LnRyaW0oKS5tYXRjaCgvXihbXGQuXSspKHB4fHB0fHBjfGlufGNtfG1tfGVtfGV4fHJlbXxxfHZ3fHZofHZtYXh8dm1pbikkLyk7Tz91PXtzaXplOnBhcnNlRmxvYXQoT1sxXSksdW5pdDpPWzJdfTp1PXtzaXplOnBhcnNlRmxvYXQodSksdW5pdDoicHgifTtsZXR7c2l6ZTpmLHVuaXQ6Z309dTtpZihnPT09InB0IilmLz0uNzU7ZWxzZSBpZihnPT09InBjIilmKj0xNjtlbHNlIGlmKGc9PT0iaW4iKWYqPTk2O2Vsc2UgaWYoZz09PSJjbSIpZio9OTYvMi41NDtlbHNlIGlmKGc9PT0ibW0iKWYqPTk2LzI1LjQ7ZWxzZSBpZihnPT09ImVtInx8Zz09PSJyZW0ifHxnPT09ImV4Iil7aWYoIWMmJnR5cGVvZiBnZXRDb21wdXRlZFN0eWxlPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCB2PWdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTt2P2M9YSh2LDE2KTpjPTE2fWYqPWMsZz09PSJleCImJihmLz0yKX1lbHNlIGlmKGc9PT0icSIpZio9OTYvMjUuNC80O2Vsc2UgaWYoZz09PSJ2dyJ8fGc9PT0idmgiKXtpZih0eXBlb2YgZG9jdW1lbnQ8InUiKXtjb25zdCB2PWc9PT0idnciP3dpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2YqPXYvMTAwfX1lbHNlIGlmKChnPT09InZtYXgifHxnPT09InZtaW4iKSYmdHlwZW9mIGRvY3VtZW50PCJ1Iil7Y29uc3Qgdj13aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLEM9d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O2c9PT0idm1heCI/Zio9TWF0aC5tYXgodixDKS8xMDA6Zio9TWF0aC5taW4odixDKS8xMDB9cmV0dXJuIGZ9ZnVuY3Rpb24gbCh1KXtyZXR1cm4gdT09bnVsbD91OlN0cmluZyh1KX1mdW5jdGlvbiBNKHUpe2lmKHU9PW51bGwpcmV0dXJuIHU7aWYodHlwZW9mIHU9PSJzdHJpbmciJiYodT1hKHUpKSwhTnVtYmVyLmlzRmluaXRlKHUpKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgdmFsdWUiKTtyZXR1cm4gdX1mdW5jdGlvbiBUKHUsYz0hMSl7cmV0dXJuIHU9PT0iIj9udWxsOih0eXBlb2YgdT09InN0cmluZyImJih1PXUuc3BsaXQoL1tccyxdKy9nKSksQXJyYXkuaXNBcnJheSh1KSYmKGMmJih1PXUubWFwKE0pKSx1Lmxlbmd0aD09PTEpP3VbMF06dSl9ZnVuY3Rpb24gZCh1LGMpe2lmKEFycmF5LmlzQXJyYXkodSkmJkFycmF5LmlzQXJyYXkoYykpe2lmKHUubGVuZ3RoIT09Yy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBPPTA7Tzx1Lmxlbmd0aDtPKyspaWYodVtPXSE9PWNbT10pcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHU9PW51bGwmJmM9PW51bGx8fHU9PT1jfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZ30pO3ZhciBhPXQoNzQpLGw9dCgzMiksTT10Lm4obCksVD10KDY4KSxkPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KCl7cmV0dXJuIHU9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odil7Zm9yKHZhciBDPTE7Qzxhcmd1bWVudHMubGVuZ3RoO0MrKyl7dmFyIHA9YXJndW1lbnRzW0NdO2Zvcih2YXIgaCBpbiBwKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwLGgpJiYodltoXT1wW2hdKX1yZXR1cm4gdn0sdS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYyh2KXtpZih0eXBlb2Ygdj09InN0cmluZyIpe2lmKHY9di50cmltKCksL15bMC05Ll0rJSQvLnRlc3QodikpcmV0dXJuIHBhcnNlRmxvYXQodikvMTAwO2lmKC9eKFtcZC5dKykocHh8cHR8cGN8aW58Y218bW18ZW18ZXh8cmVtfHF8dnd8dmh8dm1heHx2bWluKSQvLnRlc3QodikpcmV0dXJuIE9iamVjdChkLnNpemVUb1BpeGVsKSh2KX1yZXR1cm4gdn1mdW5jdGlvbiBPKHYsQyxwLGgsbSl7cmV0dXJuIHR5cGVvZiB2PT0ic3RyaW5nIiYmKHY9TSgpKHYpKSx0eXBlb2YgQz09InN0cmluZyImJihDPU0oKShDKSksYS5FZmZlY3RzLmRlZmF1bHQodixDLHAsaCxtKX1mdW5jdGlvbiBmKHYsQyxwLGgsbSl7cmV0dXJuIGEuRWZmZWN0cy5kZWZhdWx0KHYsQyxwLGgsbSl9YS5FZmZlY3RzLmRlZmF1bHQ9ZnVuY3Rpb24odixDLHAsaCxtKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh2KSYmQXJyYXkuaXNBcnJheShDKT92Lm1hcCgocixpKT0+cisocC1oKS8obS1oKSooQ1tpXS1yKSk6dHlwZW9mIHY9PSJudW1iZXIiJiZ0eXBlb2YgQz09Im51bWJlciI/disocC1oKS8obS1oKSooQy12KTpwLWg+bS1wP0M6dn0sYS5FZmZlY3RzLmZpbGxDb2xvcj1PLGEuRWZmZWN0cy5zdHJva2VDb2xvcj1PLGEuRWZmZWN0cy5iZ2NvbG9yPU8sYS5FZmZlY3RzLmJvcmRlckNvbG9yPU8sYS5FZmZlY3RzLnRleHQ9ZjtjbGFzcyBnIGV4dGVuZHMgYS5BbmltYXRvcntjb25zdHJ1Y3RvcihDLHAsaCl7Y29uc3QgbT1DLmF0dHIoKTtPYmplY3QuZW50cmllcyhtKS5mb3JFYWNoKChbcixpXSk9PnttW3JdPWEuRWZmZWN0c1tyXT9pOmMoaSl9KSxwPXAubWFwKHI9PntsZXQgaT11KHt9LHIpO2NvbnN0IG49e307cmV0dXJuIE9iamVjdC5lbnRyaWVzKGkpLmZvckVhY2goKFtzLHhdKT0+e25bc109YS5FZmZlY3RzW3NdP3g6Yyh4KX0pLG59KSxzdXBlcihtLHAsaCksdGhpcy50YXJnZXQ9Qyx0aGlzLnNldHRlcj1mdW5jdGlvbihyLGkpe2kuYXR0cihyKX19Z2V0IHBsYXlTdGF0ZSgpe3JldHVybiB0aGlzLnRhcmdldC5wYXJlbnQ/c3VwZXIucGxheVN0YXRlOiJpZGxlIn1nZXQgZmluaXNoZWQoKXtyZXR1cm4gc3VwZXIuZmluaXNoZWQudGhlbigoKT0+e2NvbnN0IEM9dGhpcztyZXR1cm4gbmV3IFByb21pc2UocD0+e2Z1bmN0aW9uIGgoKXtDLnNldHRlcihDLmZyYW1lLEMudGFyZ2V0KTtjb25zdCBtPUMucGxheVN0YXRlO209PT0iZmluaXNoZWQifHxtPT09ImlkbGUiPyhPYmplY3QoVC5jYW5jZWxBbmltYXRpb25GcmFtZSkoQy5yZXF1ZXN0SWQpLHAoKSk6T2JqZWN0KFQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShoKX1oKCl9KX0pfWZpbmlzaCgpe3N1cGVyLmZpbmlzaCgpLE9iamVjdChULmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzLnJlcXVlc3RJZCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCl9cGxheSgpe2lmKCF0aGlzLnRhcmdldC5wYXJlbnR8fHRoaXMucGxheVN0YXRlPT09InJ1bm5pbmciKXJldHVybjtzdXBlci5wbGF5KCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCk7Y29uc3QgQz10aGlzO3RoaXMucmVhZHkudGhlbigoKT0+e0Muc2V0dGVyKEMuZnJhbWUsQy50YXJnZXQpLEMucmVxdWVzdElkPU9iamVjdChULnJlcXVlc3RBbmltYXRpb25GcmFtZSkoZnVuY3Rpb24gcCgpe2NvbnN0IGg9Qy50YXJnZXQ7aWYodHlwZW9mIGRvY3VtZW50PCJ1IiYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMmJmgubGF5ZXImJmgubGF5ZXIuY2FudmFzJiYhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGgubGF5ZXIuY2FudmFzKSl7Qy5jYW5jZWwoKTtyZXR1cm59Y29uc3QgbT1DLnBsYXlTdGF0ZTtDLnNldHRlcihDLmZyYW1lLEMudGFyZ2V0KSxtIT09ImlkbGUiJiYobT09PSJydW5uaW5nIj9DLnJlcXVlc3RJZD1PYmplY3QoVC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKHApOihtPT09InBhdXNlZCJ8fG09PT0icGVuZGluZyImJkMudGltZWxpbmUuY3VycmVudFRpbWU8MCkmJkMucmVhZHkudGhlbigoKT0+e0Muc2V0dGVyKEMuZnJhbWUsQy50YXJnZXQpLEMucmVxdWVzdElkPU9iamVjdChULnJlcXVlc3RBbmltYXRpb25GcmFtZSkocCl9KSl9KX0pfWNhbmNlbChDPSExKXtPYmplY3QoVC5jYW5jZWxBbmltYXRpb25GcmFtZSkodGhpcy5yZXF1ZXN0SWQpLEM/KHRoaXMuc2V0dGVyKHRoaXMuZnJhbWUsdGhpcy50YXJnZXQpLHN1cGVyLmNhbmNlbCgpKTooc3VwZXIuY2FuY2VsKCksdGhpcy5zZXR0ZXIodGhpcy5mcmFtZSx0aGlzLnRhcmdldCkpfX19LGZ1bmN0aW9uKEwsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5UaW1lbGluZT1lLkVmZmVjdHM9ZS5FYXNpbmdzPWUuQW5pbWF0b3I9dm9pZCAwO3ZhciBhPXQoNzUpLGw9TyhhKSxNPXQoMTg3KSxUPU8oTSksZD10KDE4OCksdT10KDE5MCksYz1PKHUpO2Z1bmN0aW9uIE8oZil7cmV0dXJuIGYmJmYuX19lc01vZHVsZT9mOntkZWZhdWx0OmZ9fWUuQW5pbWF0b3I9Yy5kZWZhdWx0LGUuRWFzaW5ncz1kLkVhc2luZ3MsZS5FZmZlY3RzPVQuZGVmYXVsdCxlLlRpbWVsaW5lPWwuZGVmYXVsdH0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgYT10KDc2KSxsPXIoYSksTT10KDEzMyksVD1yKE0pLGQ9dCgxNDEpLHU9cihkKSxjPXQoMTY0KSxPPXIoYyksZj10KDE3MCksZz1yKGYpLHY9dCgxNzEpLEM9cih2KSxwPXQoMTc1KSxoPXIocCksbT10KDE4Nik7ZnVuY3Rpb24gcihJKXtyZXR1cm4gSSYmSS5fX2VzTW9kdWxlP0k6e2RlZmF1bHQ6SX19dmFyIGk9KDAsbS5jcmVhdGVOb3dUaW1lKSgpLG49e29yaWdpblRpbWU6MCxwbGF5YmFja1JhdGU6MX0scz0oMCxoLmRlZmF1bHQpKCJ0aW1lTWFyayIpLHg9KDAsaC5kZWZhdWx0KSgicGxheWJhY2tSYXRlIiksUD0oMCxoLmRlZmF1bHQpKCJ0aW1lcnMiKSxSPSgwLGguZGVmYXVsdCkoIm9yaWdpblRpbWUiKSxiPSgwLGguZGVmYXVsdCkoInNldFRpbWVyIiksRT0oMCxoLmRlZmF1bHQpKCJwYXJlbnQiKSxEPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gSShTLEEpeygwLGcuZGVmYXVsdCkodGhpcyxJKSxTIGluc3RhbmNlb2YgSSYmKEE9UyxTPXt9KSxTPSgwLE8uZGVmYXVsdCkoe30sbixTKSxBJiYodGhpc1tFXT1BKTt2YXIgVT1TLm5vd3RpbWV8fGk7aWYoQSlPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsVGltZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBBLmN1cnJlbnRUaW1lfX0pO2Vsc2V7dmFyIEs9VSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJnbG9iYWxUaW1lIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFUoKS1LfX0pfXRoaXNbc109W3tnbG9iYWxUaW1lOnRoaXMuZ2xvYmFsVGltZSxsb2NhbFRpbWU6LVMub3JpZ2luVGltZSxlbnRyb3B5Oi1TLm9yaWdpblRpbWUscGxheWJhY2tSYXRlOlMucGxheWJhY2tSYXRlLGdsb2JhbEVudHJvcHk6MH1dLHRoaXNbRV0mJih0aGlzW3NdWzBdLmdsb2JhbEVudHJvcHk9dGhpc1tFXS5lbnRyb3B5KSx0aGlzW1JdPVMub3JpZ2luVGltZSx0aGlzW3hdPVMucGxheWJhY2tSYXRlLHRoaXNbUF09bmV3IHUuZGVmYXVsdH1yZXR1cm4oMCxDLmRlZmF1bHQpKEksW3trZXk6Im1hcmtUaW1lIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBBPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxVPUEudGltZSxLPVU9PT12b2lkIDA/dGhpcy5jdXJyZW50VGltZTpVLFY9QS5lbnRyb3B5LEo9Vj09PXZvaWQgMD90aGlzLmVudHJvcHk6VixxPUEucGxheWJhY2tSYXRlLFc9cT09PXZvaWQgMD90aGlzLnBsYXliYWNrUmF0ZTpxLEg9e2dsb2JhbFRpbWU6dGhpcy5nbG9iYWxUaW1lLGxvY2FsVGltZTpLLGVudHJvcHk6SixwbGF5YmFja1JhdGU6VyxnbG9iYWxFbnRyb3B5OnRoaXMuZ2xvYmFsRW50cm9weX07dGhpc1tzXS5wdXNoKEgpfX0se2tleToiZm9yayIsdmFsdWU6ZnVuY3Rpb24oQSl7cmV0dXJuIG5ldyBJKEEsdGhpcyl9fSx7a2V5OiJzZWVrR2xvYmFsVGltZSIsdmFsdWU6ZnVuY3Rpb24oQSl7dmFyIFU9dGhpcy5zZWVrVGltZU1hcmsoQSksSz10aGlzW3NdW1VdLFY9Sy5lbnRyb3B5LEo9Sy5wbGF5YmFja1JhdGUscT1LLmdsb2JhbFRpbWU7cmV0dXJuIHErKEEtVikvTWF0aC5hYnMoSil9fSx7a2V5OiJzZWVrTG9jYWxUaW1lIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgVT10aGlzLnNlZWtUaW1lTWFyayhBKSxLPXRoaXNbc11bVV0sVj1LLmxvY2FsVGltZSxKPUsuZW50cm9weSxxPUsucGxheWJhY2tSYXRlO3JldHVybiBxPjA/VisoQS1KKTpWLShBLUopfX0se2tleToic2Vla1RpbWVNYXJrIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgVT10aGlzW3NdLEs9MCxWPVUubGVuZ3RoLTE7aWYoQTw9VVtLXS5lbnRyb3B5KXJldHVybiBLO2lmKEE+PVVbVl0uZW50cm9weSlyZXR1cm4gVjtmb3IodmFyIEo9TWF0aC5mbG9vcigoSytWKS8yKTtKPksmJko8Vjspe2lmKEE9PT1VW0pdLmVudHJvcHkpcmV0dXJuIEo7QTxVW0pdLmVudHJvcHk/Vj1KOkE+VVtKXS5lbnRyb3B5JiYoSz1KKSxKPU1hdGguZmxvb3IoKEsrVikvMil9cmV0dXJuIEt9fSx7a2V5OiJ1cGRhdGVUaW1lcnMiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIEE9dGhpcyxVPVtdLmNvbmNhdCgoMCxULmRlZmF1bHQpKHRoaXNbUF0pKTtVLmZvckVhY2goZnVuY3Rpb24oSyl7dmFyIFY9KDAsbC5kZWZhdWx0KShLLDIpLEo9VlswXSxxPVZbMV07QVtiXShxLmhhbmRsZXIscS50aW1lLEopfSl9fSx7a2V5OiJjbGVhclRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKFMpe2Z1bmN0aW9uIEEoVSl7cmV0dXJuIFMuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBBLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIFMudG9TdHJpbmcoKX0sQX0oZnVuY3Rpb24oUyl7dmFyIEE9dGhpc1tQXS5nZXQoUyk7QSYmQS50aW1lcklEIT1udWxsJiYodGhpc1tFXT90aGlzW0VdLmNsZWFyVGltZW91dChBLnRpbWVySUQpOmNsZWFyVGltZW91dChBLnRpbWVySUQpKSx0aGlzW1BdLmRlbGV0ZShTKX0pfSx7a2V5OiJjbGVhckludGVydmFsIix2YWx1ZTpmdW5jdGlvbihBKXtyZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoQSl9fSx7a2V5OiJjbGVhciIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgQT10aGlzLFU9dGhpc1tQXTtbXS5jb25jYXQoKDAsVC5kZWZhdWx0KShVLmtleXMoKSkpLmZvckVhY2goZnVuY3Rpb24oSyl7QS5jbGVhclRpbWVvdXQoSyl9KX19LHtrZXk6InNldFRpbWVvdXQiLHZhbHVlOmZ1bmN0aW9uKEEpe3ZhciBVPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7ZGVsYXk6MH07cmV0dXJuIHRoaXNbYl0oQSxVKX19LHtrZXk6InNldEludGVydmFsIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgVT1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e2RlbGF5OjB9LEs9dGhpcyxWPXRoaXNbYl0oZnVuY3Rpb24gSigpe0tbYl0oSixVLFYpLEEoKX0sVSk7cmV0dXJuIFZ9fSx7a2V5OmIsdmFsdWU6ZnVuY3Rpb24oQSxVKXt2YXIgSz10aGlzLFY9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOigwLGguZGVmYXVsdCkoInRpbWVySUQiKTtVPSgwLG0uZm9ybWF0RGVsYXkpKFUpO3ZhciBKPXRoaXNbUF0uZ2V0KFYpLHE9dm9pZCAwLFc9bnVsbCxIPXZvaWQgMCxaPXZvaWQgMDtKPyh0aGlzLmNsZWFyVGltZW91dChWKSxVLmlzRW50cm9weT9xPShVLmRlbGF5LSh0aGlzLmVudHJvcHktSi5zdGFydEVudHJvcHkpKS9NYXRoLmFicyh0aGlzLnBsYXliYWNrUmF0ZSk6cT0oVS5kZWxheS0odGhpcy5jdXJyZW50VGltZS1KLnN0YXJ0VGltZSkpL3RoaXMucGxheWJhY2tSYXRlLEg9Si5zdGFydFRpbWUsWj1KLnN0YXJ0RW50cm9weSk6KHE9VS5kZWxheS8oVS5pc0VudHJvcHk/TWF0aC5hYnModGhpcy5wbGF5YmFja1JhdGUpOnRoaXMucGxheWJhY2tSYXRlKSxIPXRoaXMuY3VycmVudFRpbWUsWj10aGlzLmVudHJvcHkpO3ZhciB0dD10aGlzW0VdLF89dHQ/dHQuc2V0VGltZW91dC5iaW5kKHR0KTpzZXRUaW1lb3V0LHN0PVUuaGVhZGluZztyZXR1cm4hdHQmJnN0PT09ITEmJnE8MCYmKHE9MS8wKSwoaXNGaW5pdGUocSl8fHR0KSYmKHE9TWF0aC5jZWlsKHEpLF8hPT1zZXRUaW1lb3V0JiYocT17ZGVsYXk6cSxoZWFkaW5nOnN0fSksVz1fKGZ1bmN0aW9uKCl7S1tQXS5kZWxldGUoViksQSgpfSxxKSksdGhpc1tQXS5zZXQoVix7dGltZXJJRDpXLGhhbmRsZXI6QSx0aW1lOlUsc3RhcnRUaW1lOkgsc3RhcnRFbnRyb3B5Olp9KSxWfX0se2tleToicGFyZW50IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tFXX19LHtrZXk6Imxhc3RUaW1lTWFyayIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbc11bdGhpc1tzXS5sZW5ndGgtMV19fSx7a2V5OiJjdXJyZW50VGltZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEE9dGhpcy5sYXN0VGltZU1hcmssVT1BLmxvY2FsVGltZSxLPUEuZ2xvYmFsVGltZTtyZXR1cm4gVSsodGhpcy5nbG9iYWxUaW1lLUspKnRoaXMucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oQSl7dmFyIFU9dGhpcyxLPXRoaXMuY3VycmVudFRpbWUsVj1BLEo9dGhpc1tQXTt0aGlzLm1hcmtUaW1lKHt0aW1lOkF9KSxbXS5jb25jYXQoKDAsVC5kZWZhdWx0KShKKSkuZm9yRWFjaChmdW5jdGlvbihxKXt2YXIgVz0oMCxsLmRlZmF1bHQpKHEsMiksSD1XWzBdLFo9V1sxXTtpZihKLmhhcyhIKSl7dmFyIHR0PVoudGltZSxfPXR0LmlzRW50cm9weSxzdD10dC5kZWxheSxrPXR0LmhlYWRpbmcsY3Q9Wi5oYW5kbGVyLGZ0PVouc3RhcnRUaW1lO2lmKF8pc3Q9PT0wJiYoY3QoKSxVLmNsZWFyVGltZW91dChIKSk7ZWxzZXt2YXIgQj1mdCtzdDsoc3Q9PT0wfHxrIT09ITEmJihWLUspKnN0PD0wfHxLPD1CJiZCPD1WfHxLPj1CJiZCPj1WKSYmKGN0KCksVS5jbGVhclRpbWVvdXQoSCkpfX19KSx0aGlzLnVwZGF0ZVRpbWVycygpfX0se2tleToiZW50cm9weSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIEE9dGhpcy5sYXN0VGltZU1hcmssVT1BLmVudHJvcHksSz1BLmdsb2JhbEVudHJvcHk7cmV0dXJuIFUrTWF0aC5hYnMoKHRoaXMuZ2xvYmFsRW50cm9weS1LKSp0aGlzLnBsYXliYWNrUmF0ZSl9LHNldDpmdW5jdGlvbihBKXtpZih0aGlzLmVudHJvcHk+QSl7dmFyIFU9dGhpcy5zZWVrVGltZU1hcmsoQSk7dGhpc1tzXS5sZW5ndGg9VSsxfXRoaXMubWFya1RpbWUoe2VudHJvcHk6QX0pLHRoaXMudXBkYXRlVGltZXJzKCl9fSx7a2V5OiJnbG9iYWxFbnRyb3B5IixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tFXT90aGlzW0VdLmVudHJvcHk6dGhpcy5nbG9iYWxUaW1lfX0se2tleToicGxheWJhY2tSYXRlIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1t4XX0sc2V0OmZ1bmN0aW9uKEEpe0EhPT10aGlzLnBsYXliYWNrUmF0ZSYmKHRoaXMubWFya1RpbWUoe3BsYXliYWNrUmF0ZTpBfSksdGhpc1t4XT1BLHRoaXMudXBkYXRlVGltZXJzKCkpfX0se2tleToicGF1c2VkIixnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7Zm9yKHZhciBBPXRoaXMucGFyZW50O0E7KXtpZihBLnBsYXliYWNrUmF0ZT09PTApcmV0dXJuITA7QT1BLnBhcmVudH1yZXR1cm4hMX19XSksSX0oKTtlLmRlZmF1bHQ9RH0sZnVuY3Rpb24oTCxlLHQpe2UuX19lc01vZHVsZT0hMDt2YXIgYT10KDc3KSxsPWQoYSksTT10KDEyOSksVD1kKE0pO2Z1bmN0aW9uIGQodSl7cmV0dXJuIHUmJnUuX19lc01vZHVsZT91OntkZWZhdWx0OnV9fWUuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHUoYyxPKXt2YXIgZj1bXSxnPSEwLHY9ITEsQz12b2lkIDA7dHJ5e2Zvcih2YXIgcD0oMCxULmRlZmF1bHQpKGMpLGg7IShnPShoPXAubmV4dCgpKS5kb25lKSYmKGYucHVzaChoLnZhbHVlKSwhKE8mJmYubGVuZ3RoPT09TykpO2c9ITApO31jYXRjaChtKXt2PSEwLEM9bX1maW5hbGx5e3RyeXshZyYmcC5yZXR1cm4mJnAucmV0dXJuKCl9ZmluYWxseXtpZih2KXRocm93IEN9fXJldHVybiBmfXJldHVybiBmdW5jdGlvbihjLE8pe2lmKEFycmF5LmlzQXJyYXkoYykpcmV0dXJuIGM7aWYoKDAsbC5kZWZhdWx0KShPYmplY3QoYykpKXJldHVybiB1KGMsTyk7dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZSIpfX0oKX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz17ZGVmYXVsdDp0KDc4KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oTCxlLHQpe3QoNzkpLHQoMTI1KSxMLmV4cG9ydHM9dCgxMjcpfSxmdW5jdGlvbihMLGUsdCl7dCg4MCk7Zm9yKHZhciBhPXQoOTEpLGw9dCg5NSksTT10KDgzKSxUPXQoMTIyKSgidG9TdHJpbmdUYWciKSxkPSJDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LERPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCxTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCxUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCIuc3BsaXQoIiwiKSx1PTA7dTxkLmxlbmd0aDt1Kyspe3ZhciBjPWRbdV0sTz1hW2NdLGY9TyYmTy5wcm90b3R5cGU7ZiYmIWZbVF0mJmwoZixULGMpLE1bY109TS5BcnJheX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDgxKSxsPXQoODIpLE09dCg4MyksVD10KDg0KTtMLmV4cG9ydHM9dCg4OCkoQXJyYXksIkFycmF5IixmdW5jdGlvbihkLHUpe3RoaXMuX3Q9VChkKSx0aGlzLl9pPTAsdGhpcy5faz11fSxmdW5jdGlvbigpe3ZhciBkPXRoaXMuX3QsdT10aGlzLl9rLGM9dGhpcy5faSsrO3JldHVybiFkfHxjPj1kLmxlbmd0aD8odGhpcy5fdD12b2lkIDAsbCgxKSk6dT09ImtleXMiP2woMCxjKTp1PT0idmFsdWVzIj9sKDAsZFtjXSk6bCgwLFtjLGRbY11dKX0sInZhbHVlcyIpLE0uQXJndW1lbnRzPU0uQXJyYXksYSgia2V5cyIpLGEoInZhbHVlcyIpLGEoImVudHJpZXMiKX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ZnVuY3Rpb24oKXt9fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0LGEpe3JldHVybnt2YWx1ZTphLGRvbmU6ISF0fX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPXt9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg4NSksbD10KDg3KTtMLmV4cG9ydHM9ZnVuY3Rpb24oTSl7cmV0dXJuIGEobChNKSl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg4Nik7TC5leHBvcnRzPU9iamVjdCgieiIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApP09iamVjdDpmdW5jdGlvbihsKXtyZXR1cm4gYShsKT09IlN0cmluZyI/bC5zcGxpdCgiIik6T2JqZWN0KGwpfX0sZnVuY3Rpb24oTCxlKXt2YXIgdD17fS50b1N0cmluZztMLmV4cG9ydHM9ZnVuY3Rpb24oYSl7cmV0dXJuIHQuY2FsbChhKS5zbGljZSg4LC0xKX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHQ9PW51bGwpdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgIit0KTtyZXR1cm4gdH19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDg5KSxsPXQoOTApLE09dCgxMDYpLFQ9dCg5NSksZD10KDgzKSx1PXQoMTA3KSxjPXQoMTIxKSxPPXQoMTIzKSxmPXQoMTIyKSgiaXRlcmF0b3IiKSxnPSEoW10ua2V5cyYmIm5leHQiaW5bXS5rZXlzKCkpLHY9IkBAaXRlcmF0b3IiLEM9ImtleXMiLHA9InZhbHVlcyIsaD1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtMLmV4cG9ydHM9ZnVuY3Rpb24obSxyLGksbixzLHgsUCl7dShpLHIsbik7dmFyIFI9ZnVuY3Rpb24oVyl7aWYoIWcmJlcgaW4gSSlyZXR1cm4gSVtXXTtzd2l0Y2goVyl7Y2FzZSBDOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgaSh0aGlzLFcpfTtjYXNlIHA6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBpKHRoaXMsVyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgaSh0aGlzLFcpfX0sYj1yKyIgSXRlcmF0b3IiLEU9cz09cCxEPSExLEk9bS5wcm90b3R5cGUsUz1JW2ZdfHxJW3ZdfHxzJiZJW3NdLEE9U3x8UihzKSxVPXM/RT9SKCJlbnRyaWVzIik6QTp2b2lkIDAsSz1yPT0iQXJyYXkiJiZJLmVudHJpZXN8fFMsVixKLHE7aWYoSyYmKHE9TyhLLmNhbGwobmV3IG0pKSxxIT09T2JqZWN0LnByb3RvdHlwZSYmcS5uZXh0JiYoYyhxLGIsITApLCFhJiZ0eXBlb2YgcVtmXSE9ImZ1bmN0aW9uIiYmVChxLGYsaCkpKSxFJiZTJiZTLm5hbWUhPT1wJiYoRD0hMCxBPWZ1bmN0aW9uKCl7cmV0dXJuIFMuY2FsbCh0aGlzKX0pLCghYXx8UCkmJihnfHxEfHwhSVtmXSkmJlQoSSxmLEEpLGRbcl09QSxkW2JdPWgscylpZihWPXt2YWx1ZXM6RT9BOlIocCksa2V5czp4P0E6UihDKSxlbnRyaWVzOlV9LFApZm9yKEogaW4gVilKIGluIEl8fE0oSSxKLFZbSl0pO2Vsc2UgbChsLlArbC5GKihnfHxEKSxyLFYpO3JldHVybiBWfX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ITB9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkxKSxsPXQoOTIpLE09dCg5MyksVD10KDk1KSxkPXQoMTA1KSx1PSJwcm90b3R5cGUiLGM9ZnVuY3Rpb24oTyxmLGcpe3ZhciB2PU8mYy5GLEM9TyZjLkcscD1PJmMuUyxoPU8mYy5QLG09TyZjLkIscj1PJmMuVyxpPUM/bDpsW2ZdfHwobFtmXT17fSksbj1pW3VdLHM9Qz9hOnA/YVtmXTooYVtmXXx8e30pW3VdLHgsUCxSO0MmJihnPWYpO2Zvcih4IGluIGcpUD0hdiYmcyYmc1t4XSE9PXZvaWQgMCwhKFAmJmQoaSx4KSkmJihSPVA/c1t4XTpnW3hdLGlbeF09QyYmdHlwZW9mIHNbeF0hPSJmdW5jdGlvbiI/Z1t4XTptJiZQP00oUixhKTpyJiZzW3hdPT1SP2Z1bmN0aW9uKGIpe3ZhciBFPWZ1bmN0aW9uKEQsSSxTKXtpZih0aGlzIGluc3RhbmNlb2YgYil7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IGI7Y2FzZSAxOnJldHVybiBuZXcgYihEKTtjYXNlIDI6cmV0dXJuIG5ldyBiKEQsSSl9cmV0dXJuIG5ldyBiKEQsSSxTKX1yZXR1cm4gYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3JldHVybiBFW3VdPWJbdV0sRX0oUik6aCYmdHlwZW9mIFI9PSJmdW5jdGlvbiI/TShGdW5jdGlvbi5jYWxsLFIpOlIsaCYmKChpLnZpcnR1YWx8fChpLnZpcnR1YWw9e30pKVt4XT1SLE8mYy5SJiZuJiYhblt4XSYmVChuLHgsUikpKX07Yy5GPTEsYy5HPTIsYy5TPTQsYy5QPTgsYy5CPTE2LGMuVz0zMixjLlU9NjQsYy5SPTEyOCxMLmV4cG9ydHM9Y30sZnVuY3Rpb24oTCxlKXt2YXIgdD1MLmV4cG9ydHM9dHlwZW9mIHdpbmRvdzwidSImJndpbmRvdy5NYXRoPT1NYXRoP3dpbmRvdzp0eXBlb2Ygc2VsZjwidSImJnNlbGYuTWF0aD09TWF0aD9zZWxmOkZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCk7dHlwZW9mIF9fZz09Im51bWJlciImJihfX2c9dCl9LGZ1bmN0aW9uKEwsZSl7dmFyIHQ9TC5leHBvcnRzPXt2ZXJzaW9uOiIyLjYuMTEifTt0eXBlb2YgX19lPT0ibnVtYmVyIiYmKF9fZT10KX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTQpO0wuZXhwb3J0cz1mdW5jdGlvbihsLE0sVCl7aWYoYShsKSxNPT09dm9pZCAwKXJldHVybiBsO3N3aXRjaChUKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiBsLmNhbGwoTSxkKX07Y2FzZSAyOnJldHVybiBmdW5jdGlvbihkLHUpe3JldHVybiBsLmNhbGwoTSxkLHUpfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKGQsdSxjKXtyZXR1cm4gbC5jYWxsKE0sZCx1LGMpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbC5hcHBseShNLGFyZ3VtZW50cyl9fX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodHlwZW9mIHQhPSJmdW5jdGlvbiIpdGhyb3cgVHlwZUVycm9yKHQrIiBpcyBub3QgYSBmdW5jdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk2KSxsPXQoMTA0KTtMLmV4cG9ydHM9dCgxMDApP2Z1bmN0aW9uKE0sVCxkKXtyZXR1cm4gYS5mKE0sVCxsKDEsZCkpfTpmdW5jdGlvbihNLFQsZCl7cmV0dXJuIE1bVF09ZCxNfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTcpLGw9dCg5OSksTT10KDEwMyksVD1PYmplY3QuZGVmaW5lUHJvcGVydHk7ZS5mPXQoMTAwKT9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24odSxjLE8pe2lmKGEodSksYz1NKGMsITApLGEoTyksbCl0cnl7cmV0dXJuIFQodSxjLE8pfWNhdGNoe31pZigiZ2V0ImluIE98fCJzZXQiaW4gTyl0aHJvdyBUeXBlRXJyb3IoIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkISIpO3JldHVybiJ2YWx1ZSJpbiBPJiYodVtjXT1PLnZhbHVlKSx1fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTgpO0wuZXhwb3J0cz1mdW5jdGlvbihsKXtpZighYShsKSl0aHJvdyBUeXBlRXJyb3IobCsiIGlzIG5vdCBhbiBvYmplY3QhIik7cmV0dXJuIGx9fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJvYmplY3QiP3QhPT1udWxsOnR5cGVvZiB0PT0iZnVuY3Rpb24ifX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz0hdCgxMDApJiYhdCgxMDEpKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0KDEwMikoImRpdiIpLCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPSF0KDEwMSkoZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2h7cmV0dXJuITB9fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTgpLGw9dCg5MSkuZG9jdW1lbnQsTT1hKGwpJiZhKGwuY3JlYXRlRWxlbWVudCk7TC5leHBvcnRzPWZ1bmN0aW9uKFQpe3JldHVybiBNP2wuY3JlYXRlRWxlbWVudChUKTp7fX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk4KTtMLmV4cG9ydHM9ZnVuY3Rpb24obCxNKXtpZighYShsKSlyZXR1cm4gbDt2YXIgVCxkO2lmKE0mJnR5cGVvZihUPWwudG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhYShkPVQuY2FsbChsKSl8fHR5cGVvZihUPWwudmFsdWVPZik9PSJmdW5jdGlvbiImJiFhKGQ9VC5jYWxsKGwpKXx8IU0mJnR5cGVvZihUPWwudG9TdHJpbmcpPT0iZnVuY3Rpb24iJiYhYShkPVQuY2FsbChsKSkpcmV0dXJuIGQ7dGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPWZ1bmN0aW9uKHQsYSl7cmV0dXJue2VudW1lcmFibGU6ISh0JjEpLGNvbmZpZ3VyYWJsZTohKHQmMiksd3JpdGFibGU6ISh0JjQpLHZhbHVlOmF9fX0sZnVuY3Rpb24oTCxlKXt2YXIgdD17fS5oYXNPd25Qcm9wZXJ0eTtMLmV4cG9ydHM9ZnVuY3Rpb24oYSxsKXtyZXR1cm4gdC5jYWxsKGEsbCl9fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXQoOTUpfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMDgpLGw9dCgxMDQpLE09dCgxMjEpLFQ9e307dCg5NSkoVCx0KDEyMikoIml0ZXJhdG9yIiksZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLEwuZXhwb3J0cz1mdW5jdGlvbihkLHUsYyl7ZC5wcm90b3R5cGU9YShULHtuZXh0OmwoMSxjKX0pLE0oZCx1KyIgSXRlcmF0b3IiKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk3KSxsPXQoMTA5KSxNPXQoMTE5KSxUPXQoMTE2KSgiSUVfUFJPVE8iKSxkPWZ1bmN0aW9uKCl7fSx1PSJwcm90b3R5cGUiLGM9ZnVuY3Rpb24oKXt2YXIgTz10KDEwMikoImlmcmFtZSIpLGY9TS5sZW5ndGgsZz0iPCIsdj0iPiIsQztmb3IoTy5zdHlsZS5kaXNwbGF5PSJub25lIix0KDEyMCkuYXBwZW5kQ2hpbGQoTyksTy5zcmM9ImphdmFzY3JpcHQ6IixDPU8uY29udGVudFdpbmRvdy5kb2N1bWVudCxDLm9wZW4oKSxDLndyaXRlKGcrInNjcmlwdCIrdisiZG9jdW1lbnQuRj1PYmplY3QiK2crIi9zY3JpcHQiK3YpLEMuY2xvc2UoKSxjPUMuRjtmLS07KWRlbGV0ZSBjW3VdW01bZl1dO3JldHVybiBjKCl9O0wuZXhwb3J0cz1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbihmLGcpe3ZhciB2O3JldHVybiBmIT09bnVsbD8oZFt1XT1hKGYpLHY9bmV3IGQsZFt1XT1udWxsLHZbVF09Zik6dj1jKCksZz09PXZvaWQgMD92OmwodixnKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk2KSxsPXQoOTcpLE09dCgxMTApO0wuZXhwb3J0cz10KDEwMCk/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24oZCx1KXtsKGQpO2Zvcih2YXIgYz1NKHUpLE89Yy5sZW5ndGgsZj0wLGc7Tz5mOylhLmYoZCxnPWNbZisrXSx1W2ddKTtyZXR1cm4gZH19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDExMSksbD10KDExOSk7TC5leHBvcnRzPU9iamVjdC5rZXlzfHxmdW5jdGlvbihUKXtyZXR1cm4gYShULGwpfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTA1KSxsPXQoODQpLE09dCgxMTIpKCExKSxUPXQoMTE2KSgiSUVfUFJPVE8iKTtMLmV4cG9ydHM9ZnVuY3Rpb24oZCx1KXt2YXIgYz1sKGQpLE89MCxmPVtdLGc7Zm9yKGcgaW4gYylnIT1UJiZhKGMsZykmJmYucHVzaChnKTtmb3IoO3UubGVuZ3RoPk87KWEoYyxnPXVbTysrXSkmJih+TShmLGcpfHxmLnB1c2goZykpO3JldHVybiBmfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoODQpLGw9dCgxMTMpLE09dCgxMTUpO0wuZXhwb3J0cz1mdW5jdGlvbihUKXtyZXR1cm4gZnVuY3Rpb24oZCx1LGMpe3ZhciBPPWEoZCksZj1sKE8ubGVuZ3RoKSxnPU0oYyxmKSx2O2lmKFQmJnUhPXUpe2Zvcig7Zj5nOylpZih2PU9bZysrXSx2IT12KXJldHVybiEwfWVsc2UgZm9yKDtmPmc7ZysrKWlmKChUfHxnIGluIE8pJiZPW2ddPT09dSlyZXR1cm4gVHx8Z3x8MDtyZXR1cm4hVCYmLTF9fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTE0KSxsPU1hdGgubWluO0wuZXhwb3J0cz1mdW5jdGlvbihNKXtyZXR1cm4gTT4wP2woYShNKSw5MDA3MTk5MjU0NzQwOTkxKTowfX0sZnVuY3Rpb24oTCxlKXt2YXIgdD1NYXRoLmNlaWwsYT1NYXRoLmZsb29yO0wuZXhwb3J0cz1mdW5jdGlvbihsKXtyZXR1cm4gaXNOYU4obD0rbCk/MDoobD4wP2E6dCkobCl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMTQpLGw9TWF0aC5tYXgsTT1NYXRoLm1pbjtMLmV4cG9ydHM9ZnVuY3Rpb24oVCxkKXtyZXR1cm4gVD1hKFQpLFQ8MD9sKFQrZCwwKTpNKFQsZCl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMTcpKCJrZXlzIiksbD10KDExOCk7TC5leHBvcnRzPWZ1bmN0aW9uKE0pe3JldHVybiBhW01dfHwoYVtNXT1sKE0pKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkyKSxsPXQoOTEpLE09Il9fY29yZS1qc19zaGFyZWRfXyIsVD1sW01dfHwobFtNXT17fSk7KEwuZXhwb3J0cz1mdW5jdGlvbihkLHUpe3JldHVybiBUW2RdfHwoVFtkXT11IT09dm9pZCAwP3U6e30pfSkoInZlcnNpb25zIixbXSkucHVzaCh7dmVyc2lvbjphLnZlcnNpb24sbW9kZTp0KDg5KT8icHVyZSI6Imdsb2JhbCIsY29weXJpZ2h0OiLCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpIn0pfSxmdW5jdGlvbihMLGUpe3ZhciB0PTAsYT1NYXRoLnJhbmRvbSgpO0wuZXhwb3J0cz1mdW5jdGlvbihsKXtyZXR1cm4iU3ltYm9sKCIuY29uY2F0KGw9PT12b2lkIDA/IiI6bCwiKV8iLCgrK3QrYSkudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPSJjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YiLnNwbGl0KCIsIil9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkxKS5kb2N1bWVudDtMLmV4cG9ydHM9YSYmYS5kb2N1bWVudEVsZW1lbnR9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk2KS5mLGw9dCgxMDUpLE09dCgxMjIpKCJ0b1N0cmluZ1RhZyIpO0wuZXhwb3J0cz1mdW5jdGlvbihULGQsdSl7VCYmIWwoVD11P1Q6VC5wcm90b3R5cGUsTSkmJmEoVCxNLHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZH0pfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTE3KSgid2tzIiksbD10KDExOCksTT10KDkxKS5TeW1ib2wsVD10eXBlb2YgTT09ImZ1bmN0aW9uIixkPUwuZXhwb3J0cz1mdW5jdGlvbih1KXtyZXR1cm4gYVt1XXx8KGFbdV09VCYmTVt1XXx8KFQ/TTpsKSgiU3ltYm9sLiIrdSkpfTtkLnN0b3JlPWF9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDEwNSksbD10KDEyNCksTT10KDExNikoIklFX1BST1RPIiksVD1PYmplY3QucHJvdG90eXBlO0wuZXhwb3J0cz1PYmplY3QuZ2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGQpe3JldHVybiBkPWwoZCksYShkLE0pP2RbTV06dHlwZW9mIGQuY29uc3RydWN0b3I9PSJmdW5jdGlvbiImJmQgaW5zdGFuY2VvZiBkLmNvbnN0cnVjdG9yP2QuY29uc3RydWN0b3IucHJvdG90eXBlOmQgaW5zdGFuY2VvZiBPYmplY3Q/VDpudWxsfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoODcpO0wuZXhwb3J0cz1mdW5jdGlvbihsKXtyZXR1cm4gT2JqZWN0KGEobCkpfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTI2KSghMCk7dCg4OCkoU3RyaW5nLCJTdHJpbmciLGZ1bmN0aW9uKGwpe3RoaXMuX3Q9U3RyaW5nKGwpLHRoaXMuX2k9MH0sZnVuY3Rpb24oKXt2YXIgbD10aGlzLl90LE09dGhpcy5faSxUO3JldHVybiBNPj1sLmxlbmd0aD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9OihUPWEobCxNKSx0aGlzLl9pKz1ULmxlbmd0aCx7dmFsdWU6VCxkb25lOiExfSl9KX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTE0KSxsPXQoODcpO0wuZXhwb3J0cz1mdW5jdGlvbihNKXtyZXR1cm4gZnVuY3Rpb24oVCxkKXt2YXIgdT1TdHJpbmcobChUKSksYz1hKGQpLE89dS5sZW5ndGgsZixnO3JldHVybiBjPDB8fGM+PU8/TT8iIjp2b2lkIDA6KGY9dS5jaGFyQ29kZUF0KGMpLGY8NTUyOTZ8fGY+NTYzMTl8fGMrMT09PU98fChnPXUuY2hhckNvZGVBdChjKzEpKTw1NjMyMHx8Zz41NzM0Mz9NP3UuY2hhckF0KGMpOmY6TT91LnNsaWNlKGMsYysyKTooZi01NTI5Njw8MTApKyhnLTU2MzIwKSs2NTUzNil9fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTI4KSxsPXQoMTIyKSgiaXRlcmF0b3IiKSxNPXQoODMpO0wuZXhwb3J0cz10KDkyKS5pc0l0ZXJhYmxlPWZ1bmN0aW9uKFQpe3ZhciBkPU9iamVjdChUKTtyZXR1cm4gZFtsXSE9PXZvaWQgMHx8IkBAaXRlcmF0b3IiaW4gZHx8TS5oYXNPd25Qcm9wZXJ0eShhKGQpKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDg2KSxsPXQoMTIyKSgidG9TdHJpbmdUYWciKSxNPWEoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT09IkFyZ3VtZW50cyIsVD1mdW5jdGlvbihkLHUpe3RyeXtyZXR1cm4gZFt1XX1jYXRjaHt9fTtMLmV4cG9ydHM9ZnVuY3Rpb24oZCl7dmFyIHUsYyxPO3JldHVybiBkPT09dm9pZCAwPyJVbmRlZmluZWQiOmQ9PT1udWxsPyJOdWxsIjp0eXBlb2YoYz1UKHU9T2JqZWN0KGQpLGwpKT09InN0cmluZyI/YzpNP2EodSk6KE89YSh1KSk9PSJPYmplY3QiJiZ0eXBlb2YgdS5jYWxsZWU9PSJmdW5jdGlvbiI/IkFyZ3VtZW50cyI6T319LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2RlZmF1bHQ6dCgxMzApLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihMLGUsdCl7dCg3OSksdCgxMjUpLEwuZXhwb3J0cz10KDEzMSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk3KSxsPXQoMTMyKTtMLmV4cG9ydHM9dCg5MikuZ2V0SXRlcmF0b3I9ZnVuY3Rpb24oTSl7dmFyIFQ9bChNKTtpZih0eXBlb2YgVCE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IoTSsiIGlzIG5vdCBpdGVyYWJsZSEiKTtyZXR1cm4gYShULmNhbGwoTSkpfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTI4KSxsPXQoMTIyKSgiaXRlcmF0b3IiKSxNPXQoODMpO0wuZXhwb3J0cz10KDkyKS5nZXRJdGVyYXRvck1ldGhvZD1mdW5jdGlvbihUKXtpZihUIT1udWxsKXJldHVybiBUW2xdfHxUWyJAQGl0ZXJhdG9yIl18fE1bYShUKV19fSxmdW5jdGlvbihMLGUsdCl7ZS5fX2VzTW9kdWxlPSEwO3ZhciBhPXQoMTM0KSxsPU0oYSk7ZnVuY3Rpb24gTShUKXtyZXR1cm4gVCYmVC5fX2VzTW9kdWxlP1Q6e2RlZmF1bHQ6VH19ZS5kZWZhdWx0PWZ1bmN0aW9uKFQpe2lmKEFycmF5LmlzQXJyYXkoVCkpe2Zvcih2YXIgZD0wLHU9QXJyYXkoVC5sZW5ndGgpO2Q8VC5sZW5ndGg7ZCsrKXVbZF09VFtkXTtyZXR1cm4gdX1lbHNlIHJldHVybigwLGwuZGVmYXVsdCkoVCl9fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXtkZWZhdWx0OnQoMTM1KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oTCxlLHQpe3QoMTI1KSx0KDEzNiksTC5leHBvcnRzPXQoOTIpLkFycmF5LmZyb219LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkzKSxsPXQoOTApLE09dCgxMjQpLFQ9dCgxMzcpLGQ9dCgxMzgpLHU9dCgxMTMpLGM9dCgxMzkpLE89dCgxMzIpO2wobC5TK2wuRiohdCgxNDApKGZ1bmN0aW9uKGYpe0FycmF5LmZyb20oZil9KSwiQXJyYXkiLHtmcm9tOmZ1bmN0aW9uKGcpe3ZhciB2PU0oZyksQz10eXBlb2YgdGhpcz09ImZ1bmN0aW9uIj90aGlzOkFycmF5LHA9YXJndW1lbnRzLmxlbmd0aCxoPXA+MT9hcmd1bWVudHNbMV06dm9pZCAwLG09aCE9PXZvaWQgMCxyPTAsaT1PKHYpLG4scyx4LFA7aWYobSYmKGg9YShoLHA+Mj9hcmd1bWVudHNbMl06dm9pZCAwLDIpKSxpIT1udWxsJiYhKEM9PUFycmF5JiZkKGkpKSlmb3IoUD1pLmNhbGwodikscz1uZXcgQzshKHg9UC5uZXh0KCkpLmRvbmU7cisrKWMocyxyLG0/VChQLGgsW3gudmFsdWUscl0sITApOngudmFsdWUpO2Vsc2UgZm9yKG49dSh2Lmxlbmd0aCkscz1uZXcgQyhuKTtuPnI7cisrKWMocyxyLG0/aCh2W3JdLHIpOnZbcl0pO3JldHVybiBzLmxlbmd0aD1yLHN9fSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk3KTtMLmV4cG9ydHM9ZnVuY3Rpb24obCxNLFQsZCl7dHJ5e3JldHVybiBkP00oYShUKVswXSxUWzFdKTpNKFQpfWNhdGNoKGMpe3ZhciB1PWwucmV0dXJuO3Rocm93IHUhPT12b2lkIDAmJmEodS5jYWxsKGwpKSxjfX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDgzKSxsPXQoMTIyKSgiaXRlcmF0b3IiKSxNPUFycmF5LnByb3RvdHlwZTtMLmV4cG9ydHM9ZnVuY3Rpb24oVCl7cmV0dXJuIFQhPT12b2lkIDAmJihhLkFycmF5PT09VHx8TVtsXT09PVQpfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTYpLGw9dCgxMDQpO0wuZXhwb3J0cz1mdW5jdGlvbihNLFQsZCl7VCBpbiBNP2EuZihNLFQsbCgwLGQpKTpNW1RdPWR9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMjIpKCJpdGVyYXRvciIpLGw9ITE7dHJ5e3ZhciBNPVs3XVthXSgpO00ucmV0dXJuPWZ1bmN0aW9uKCl7bD0hMH0sQXJyYXkuZnJvbShNLGZ1bmN0aW9uKCl7dGhyb3cgMn0pfWNhdGNoe31MLmV4cG9ydHM9ZnVuY3Rpb24oVCxkKXtpZighZCYmIWwpcmV0dXJuITE7dmFyIHU9ITE7dHJ5e3ZhciBjPVs3XSxPPWNbYV0oKTtPLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTp1PSEwfX0sY1thXT1mdW5jdGlvbigpe3JldHVybiBPfSxUKGMpfWNhdGNoe31yZXR1cm4gdX19LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNDIpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihMLGUsdCl7dCgxNDMpLHQoMTI1KSx0KDc5KSx0KDE0NCksdCgxNTcpLHQoMTYwKSx0KDE2MiksTC5leHBvcnRzPXQoOTIpLk1hcH0sZnVuY3Rpb24oTCxlKXt9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDE0NSksbD10KDE1MSksTT0iTWFwIjtMLmV4cG9ydHM9dCgxNTIpKE0sZnVuY3Rpb24oVCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIFQodGhpcyxhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSx7Z2V0OmZ1bmN0aW9uKGQpe3ZhciB1PWEuZ2V0RW50cnkobCh0aGlzLE0pLGQpO3JldHVybiB1JiZ1LnZ9LHNldDpmdW5jdGlvbihkLHUpe3JldHVybiBhLmRlZihsKHRoaXMsTSksZD09PTA/MDpkLHUpfX0sYSwhMCl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk2KS5mLGw9dCgxMDgpLE09dCgxNDYpLFQ9dCg5MyksZD10KDE0NyksdT10KDE0OCksYz10KDg4KSxPPXQoODIpLGY9dCgxNDkpLGc9dCgxMDApLHY9dCgxNTApLmZhc3RLZXksQz10KDE1MSkscD1nPyJfcyI6InNpemUiLGg9ZnVuY3Rpb24obSxyKXt2YXIgaT12KHIpLG47aWYoaSE9PSJGIilyZXR1cm4gbS5faVtpXTtmb3Iobj1tLl9mO247bj1uLm4paWYobi5rPT1yKXJldHVybiBufTtMLmV4cG9ydHM9e2dldENvbnN0cnVjdG9yOmZ1bmN0aW9uKG0scixpLG4pe3ZhciBzPW0oZnVuY3Rpb24oeCxQKXtkKHgscyxyLCJfaSIpLHguX3Q9cix4Ll9pPWwobnVsbCkseC5fZj12b2lkIDAseC5fbD12b2lkIDAseFtwXT0wLFAhPW51bGwmJnUoUCxpLHhbbl0seCl9KTtyZXR1cm4gTShzLnByb3RvdHlwZSx7Y2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIFA9Qyh0aGlzLHIpLFI9UC5faSxiPVAuX2Y7YjtiPWIubiliLnI9ITAsYi5wJiYoYi5wPWIucC5uPXZvaWQgMCksZGVsZXRlIFJbYi5pXTtQLl9mPVAuX2w9dm9pZCAwLFBbcF09MH0sZGVsZXRlOmZ1bmN0aW9uKHgpe3ZhciBQPUModGhpcyxyKSxSPWgoUCx4KTtpZihSKXt2YXIgYj1SLm4sRT1SLnA7ZGVsZXRlIFAuX2lbUi5pXSxSLnI9ITAsRSYmKEUubj1iKSxiJiYoYi5wPUUpLFAuX2Y9PVImJihQLl9mPWIpLFAuX2w9PVImJihQLl9sPUUpLFBbcF0tLX1yZXR1cm4hIVJ9LGZvckVhY2g6ZnVuY3Rpb24oUCl7Qyh0aGlzLHIpO2Zvcih2YXIgUj1UKFAsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsMyksYjtiPWI/Yi5uOnRoaXMuX2Y7KWZvcihSKGIudixiLmssdGhpcyk7YiYmYi5yOyliPWIucH0saGFzOmZ1bmN0aW9uKFApe3JldHVybiEhaChDKHRoaXMsciksUCl9fSksZyYmYShzLnByb3RvdHlwZSwic2l6ZSIse2dldDpmdW5jdGlvbigpe3JldHVybiBDKHRoaXMscilbcF19fSksc30sZGVmOmZ1bmN0aW9uKG0scixpKXt2YXIgbj1oKG0scikscyx4O3JldHVybiBuP24udj1pOihtLl9sPW49e2k6eD12KHIsITApLGs6cix2OmkscDpzPW0uX2wsbjp2b2lkIDAscjohMX0sbS5fZnx8KG0uX2Y9bikscyYmKHMubj1uKSxtW3BdKysseCE9PSJGIiYmKG0uX2lbeF09bikpLG19LGdldEVudHJ5Omgsc2V0U3Ryb25nOmZ1bmN0aW9uKG0scixpKXtjKG0scixmdW5jdGlvbihuLHMpe3RoaXMuX3Q9QyhuLHIpLHRoaXMuX2s9cyx0aGlzLl9sPXZvaWQgMH0sZnVuY3Rpb24oKXtmb3IodmFyIG49dGhpcyxzPW4uX2sseD1uLl9sO3gmJngucjspeD14LnA7cmV0dXJuIW4uX3R8fCEobi5fbD14PXg/eC5uOm4uX3QuX2YpPyhuLl90PXZvaWQgMCxPKDEpKTpzPT0ia2V5cyI/TygwLHguayk6cz09InZhbHVlcyI/TygwLHgudik6TygwLFt4LmsseC52XSl9LGk/ImVudHJpZXMiOiJ2YWx1ZXMiLCFpLCEwKSxmKHIpfX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk1KTtMLmV4cG9ydHM9ZnVuY3Rpb24obCxNLFQpe2Zvcih2YXIgZCBpbiBNKVQmJmxbZF0/bFtkXT1NW2RdOmEobCxkLE1bZF0pO3JldHVybiBsfX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9ZnVuY3Rpb24odCxhLGwsTSl7aWYoISh0IGluc3RhbmNlb2YgYSl8fE0hPT12b2lkIDAmJk0gaW4gdCl0aHJvdyBUeXBlRXJyb3IobCsiOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKEwsZix0KXt2YXIgYT10KDkzKSxsPXQoMTM3KSxNPXQoMTM4KSxUPXQoOTcpLGQ9dCgxMTMpLHU9dCgxMzIpLGM9e30sTz17fSxmPUwuZXhwb3J0cz1mdW5jdGlvbihnLHYsQyxwLGgpe3ZhciBtPWg/ZnVuY3Rpb24oKXtyZXR1cm4gZ306dShnKSxyPWEoQyxwLHY/MjoxKSxpPTAsbixzLHgsUDtpZih0eXBlb2YgbSE9ImZ1bmN0aW9uIil0aHJvdyBUeXBlRXJyb3IoZysiIGlzIG5vdCBpdGVyYWJsZSEiKTtpZihNKG0pKXtmb3Iobj1kKGcubGVuZ3RoKTtuPmk7aSsrKWlmKFA9dj9yKFQocz1nW2ldKVswXSxzWzFdKTpyKGdbaV0pLFA9PT1jfHxQPT09TylyZXR1cm4gUH1lbHNlIGZvcih4PW0uY2FsbChnKTshKHM9eC5uZXh0KCkpLmRvbmU7KWlmKFA9bCh4LHIscy52YWx1ZSx2KSxQPT09Y3x8UD09PU8pcmV0dXJuIFB9O2YuQlJFQUs9YyxmLlJFVFVSTj1PfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MSksbD10KDkyKSxNPXQoOTYpLFQ9dCgxMDApLGQ9dCgxMjIpKCJzcGVjaWVzIik7TC5leHBvcnRzPWZ1bmN0aW9uKHUpe3ZhciBjPXR5cGVvZiBsW3VdPT0iZnVuY3Rpb24iP2xbdV06YVt1XTtUJiZjJiYhY1tkXSYmTS5mKGMsZCx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzfX0pfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTE4KSgibWV0YSIpLGw9dCg5OCksTT10KDEwNSksVD10KDk2KS5mLGQ9MCx1PU9iamVjdC5pc0V4dGVuc2libGV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LGM9IXQoMTAxKShmdW5jdGlvbigpe3JldHVybiB1KE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpfSksTz1mdW5jdGlvbihwKXtUKHAsYSx7dmFsdWU6e2k6Ik8iKyArK2Qsdzp7fX19KX0sZj1mdW5jdGlvbihwLGgpe2lmKCFsKHApKXJldHVybiB0eXBlb2YgcD09InN5bWJvbCI/cDoodHlwZW9mIHA9PSJzdHJpbmciPyJTIjoiUCIpK3A7aWYoIU0ocCxhKSl7aWYoIXUocCkpcmV0dXJuIkYiO2lmKCFoKXJldHVybiJFIjtPKHApfXJldHVybiBwW2FdLml9LGc9ZnVuY3Rpb24ocCxoKXtpZighTShwLGEpKXtpZighdShwKSlyZXR1cm4hMDtpZighaClyZXR1cm4hMTtPKHApfXJldHVybiBwW2FdLnd9LHY9ZnVuY3Rpb24ocCl7cmV0dXJuIGMmJkMuTkVFRCYmdShwKSYmIU0ocCxhKSYmTyhwKSxwfSxDPUwuZXhwb3J0cz17S0VZOmEsTkVFRDohMSxmYXN0S2V5OmYsZ2V0V2VhazpnLG9uRnJlZXplOnZ9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5OCk7TC5leHBvcnRzPWZ1bmN0aW9uKGwsTSl7aWYoIWEobCl8fGwuX3QhPT1NKXRocm93IFR5cGVFcnJvcigiSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAiK00rIiByZXF1aXJlZCEiKTtyZXR1cm4gbH19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkxKSxsPXQoOTApLE09dCgxNTApLFQ9dCgxMDEpLGQ9dCg5NSksdT10KDE0NiksYz10KDE0OCksTz10KDE0NyksZj10KDk4KSxnPXQoMTIxKSx2PXQoOTYpLmYsQz10KDE1MykoMCkscD10KDEwMCk7TC5leHBvcnRzPWZ1bmN0aW9uKGgsbSxyLGksbixzKXt2YXIgeD1hW2hdLFA9eCxSPW4/InNldCI6ImFkZCIsYj1QJiZQLnByb3RvdHlwZSxFPXt9O3JldHVybiFwfHx0eXBlb2YgUCE9ImZ1bmN0aW9uInx8IShzfHxiLmZvckVhY2gmJiFUKGZ1bmN0aW9uKCl7bmV3IFAoKS5lbnRyaWVzKCkubmV4dCgpfSkpPyhQPWkuZ2V0Q29uc3RydWN0b3IobSxoLG4sUiksdShQLnByb3RvdHlwZSxyKSxNLk5FRUQ9ITApOihQPW0oZnVuY3Rpb24oRCxJKXtPKEQsUCxoLCJfYyIpLEQuX2M9bmV3IHgsSSE9bnVsbCYmYyhJLG4sRFtSXSxEKX0pLEMoImFkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTiIuc3BsaXQoIiwiKSxmdW5jdGlvbihEKXt2YXIgST1EPT0iYWRkInx8RD09InNldCI7RCBpbiBiJiYhKHMmJkQ9PSJjbGVhciIpJiZkKFAucHJvdG90eXBlLEQsZnVuY3Rpb24oUyxBKXtpZihPKHRoaXMsUCxEKSwhSSYmcyYmIWYoUykpcmV0dXJuIEQ9PSJnZXQiP3ZvaWQgMDohMTt2YXIgVT10aGlzLl9jW0RdKFM9PT0wPzA6UyxBKTtyZXR1cm4gST90aGlzOlV9KX0pLHN8fHYoUC5wcm90b3R5cGUsInNpemUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYy5zaXplfX0pKSxnKFAsaCksRVtoXT1QLGwobC5HK2wuVytsLkYsRSksc3x8aS5zZXRTdHJvbmcoUCxoLG4pLFB9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MyksbD10KDg1KSxNPXQoMTI0KSxUPXQoMTEzKSxkPXQoMTU0KTtMLmV4cG9ydHM9ZnVuY3Rpb24odSxjKXt2YXIgTz11PT0xLGY9dT09MixnPXU9PTMsdj11PT00LEM9dT09NixwPXU9PTV8fEMsaD1jfHxkO3JldHVybiBmdW5jdGlvbihtLHIsaSl7Zm9yKHZhciBuPU0obSkscz1sKG4pLHg9YShyLGksMyksUD1UKHMubGVuZ3RoKSxSPTAsYj1PP2gobSxQKTpmP2gobSwwKTp2b2lkIDAsRSxEO1A+UjtSKyspaWYoKHB8fFIgaW4gcykmJihFPXNbUl0sRD14KEUsUixuKSx1KSl7aWYoTyliW1JdPUQ7ZWxzZSBpZihEKXN3aXRjaCh1KXtjYXNlIDM6cmV0dXJuITA7Y2FzZSA1OnJldHVybiBFO2Nhc2UgNjpyZXR1cm4gUjtjYXNlIDI6Yi5wdXNoKEUpfWVsc2UgaWYodilyZXR1cm4hMX1yZXR1cm4gQz8tMTpnfHx2P3Y6Yn19fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxNTUpO0wuZXhwb3J0cz1mdW5jdGlvbihsLE0pe3JldHVybiBuZXcoYShsKSkoTSl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5OCksbD10KDE1NiksTT10KDEyMikoInNwZWNpZXMiKTtMLmV4cG9ydHM9ZnVuY3Rpb24oVCl7dmFyIGQ7cmV0dXJuIGwoVCkmJihkPVQuY29uc3RydWN0b3IsdHlwZW9mIGQ9PSJmdW5jdGlvbiImJihkPT09QXJyYXl8fGwoZC5wcm90b3R5cGUpKSYmKGQ9dm9pZCAwKSxhKGQpJiYoZD1kW01dLGQ9PT1udWxsJiYoZD12b2lkIDApKSksZD09PXZvaWQgMD9BcnJheTpkfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoODYpO0wuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihNKXtyZXR1cm4gYShNKT09IkFycmF5In19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkwKTthKGEuUCthLlIsIk1hcCIse3RvSlNPTjp0KDE1OCkoIk1hcCIpfSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDEyOCksbD10KDE1OSk7TC5leHBvcnRzPWZ1bmN0aW9uKE0pe3JldHVybiBmdW5jdGlvbigpe2lmKGEodGhpcykhPU0pdGhyb3cgVHlwZUVycm9yKE0rIiN0b0pTT04gaXNuJ3QgZ2VuZXJpYyIpO3JldHVybiBsKHRoaXMpfX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDE0OCk7TC5leHBvcnRzPWZ1bmN0aW9uKGwsTSl7dmFyIFQ9W107cmV0dXJuIGEobCwhMSxULnB1c2gsVCxNKSxUfX0sZnVuY3Rpb24oTCxlLHQpe3QoMTYxKSgiTWFwIil9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDkwKTtMLmV4cG9ydHM9ZnVuY3Rpb24obCl7YShhLlMsbCx7b2Y6ZnVuY3Rpb24oKXtmb3IodmFyIFQ9YXJndW1lbnRzLmxlbmd0aCxkPW5ldyBBcnJheShUKTtULS07KWRbVF09YXJndW1lbnRzW1RdO3JldHVybiBuZXcgdGhpcyhkKX19KX19LGZ1bmN0aW9uKEwsZSx0KXt0KDE2MykoIk1hcCIpfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCksbD10KDk0KSxNPXQoOTMpLFQ9dCgxNDgpO0wuZXhwb3J0cz1mdW5jdGlvbihkKXthKGEuUyxkLHtmcm9tOmZ1bmN0aW9uKGMpe3ZhciBPPWFyZ3VtZW50c1sxXSxmLGcsdixDO3JldHVybiBsKHRoaXMpLGY9TyE9PXZvaWQgMCxmJiZsKE8pLGM9PW51bGw/bmV3IHRoaXM6KGc9W10sZj8odj0wLEM9TShPLGFyZ3VtZW50c1syXSwyKSxUKGMsITEsZnVuY3Rpb24ocCl7Zy5wdXNoKEMocCx2KyspKX0pKTpUKGMsITEsZy5wdXNoLGcpLG5ldyB0aGlzKGcpKX19KX19LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2RlZmF1bHQ6dCgxNjUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihMLGUsdCl7dCgxNjYpLEwuZXhwb3J0cz10KDkyKS5PYmplY3QuYXNzaWdufSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCk7YShhLlMrYS5GLCJPYmplY3QiLHthc3NpZ246dCgxNjcpfSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDEwMCksbD10KDExMCksTT10KDE2OCksVD10KDE2OSksZD10KDEyNCksdT10KDg1KSxjPU9iamVjdC5hc3NpZ247TC5leHBvcnRzPSFjfHx0KDEwMSkoZnVuY3Rpb24oKXt2YXIgTz17fSxmPXt9LGc9U3ltYm9sKCksdj0iYWJjZGVmZ2hpamtsbW5vcHFyc3QiO3JldHVybiBPW2ddPTcsdi5zcGxpdCgiIikuZm9yRWFjaChmdW5jdGlvbihDKXtmW0NdPUN9KSxjKHt9LE8pW2ddIT03fHxPYmplY3Qua2V5cyhjKHt9LGYpKS5qb2luKCIiKSE9dn0pP2Z1bmN0aW9uKGYsZyl7Zm9yKHZhciB2PWQoZiksQz1hcmd1bWVudHMubGVuZ3RoLHA9MSxoPU0uZixtPVQuZjtDPnA7KWZvcih2YXIgcj11KGFyZ3VtZW50c1twKytdKSxpPWg/bChyKS5jb25jYXQoaChyKSk6bChyKSxuPWkubGVuZ3RoLHM9MCx4O24+czspeD1pW3MrK10sKCFhfHxtLmNhbGwocix4KSkmJih2W3hdPXJbeF0pO3JldHVybiB2fTpjfSxmdW5jdGlvbihMLGUpe2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbihMLGUpe2UuZj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZX0sZnVuY3Rpb24oTCxlLHQpe2UuX19lc01vZHVsZT0hMCxlLmRlZmF1bHQ9ZnVuY3Rpb24oYSxsKXtpZighKGEgaW5zdGFuY2VvZiBsKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKX19LGZ1bmN0aW9uKEwsZSx0KXtlLl9fZXNNb2R1bGU9ITA7dmFyIGE9dCgxNzIpLGw9TShhKTtmdW5jdGlvbiBNKFQpe3JldHVybiBUJiZULl9fZXNNb2R1bGU/VDp7ZGVmYXVsdDpUfX1lLmRlZmF1bHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBUKGQsdSl7Zm9yKHZhciBjPTA7Yzx1Lmxlbmd0aDtjKyspe3ZhciBPPXVbY107Ty5lbnVtZXJhYmxlPU8uZW51bWVyYWJsZXx8ITEsTy5jb25maWd1cmFibGU9ITAsInZhbHVlImluIE8mJihPLndyaXRhYmxlPSEwKSwoMCxsLmRlZmF1bHQpKGQsTy5rZXksTyl9fXJldHVybiBmdW5jdGlvbihkLHUsYyl7cmV0dXJuIHUmJlQoZC5wcm90b3R5cGUsdSksYyYmVChkLGMpLGR9fSgpfSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXtkZWZhdWx0OnQoMTczKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oTCxlLHQpe3QoMTc0KTt2YXIgYT10KDkyKS5PYmplY3Q7TC5leHBvcnRzPWZ1bmN0aW9uKE0sVCxkKXtyZXR1cm4gYS5kZWZpbmVQcm9wZXJ0eShNLFQsZCl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCk7YShhLlMrYS5GKiF0KDEwMCksIk9iamVjdCIse2RlZmluZVByb3BlcnR5OnQoOTYpLmZ9KX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz17ZGVmYXVsdDp0KDE3NiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKEwsZSx0KXt0KDE3NyksdCgxNDMpLHQoMTg0KSx0KDE4NSksTC5leHBvcnRzPXQoOTIpLlN5bWJvbH0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTEpLGw9dCgxMDUpLE09dCgxMDApLFQ9dCg5MCksZD10KDEwNiksdT10KDE1MCkuS0VZLGM9dCgxMDEpLE89dCgxMTcpLGY9dCgxMjEpLGc9dCgxMTgpLHY9dCgxMjIpLEM9dCgxNzgpLHA9dCgxNzkpLGg9dCgxODApLG09dCgxNTYpLHI9dCg5NyksaT10KDk4KSxuPXQoMTI0KSxzPXQoODQpLHg9dCgxMDMpLFA9dCgxMDQpLFI9dCgxMDgpLGI9dCgxODEpLEU9dCgxODMpLEQ9dCgxNjgpLEk9dCg5NiksUz10KDExMCksQT1FLmYsVT1JLmYsSz1iLmYsVj1hLlN5bWJvbCxKPWEuSlNPTixxPUomJkouc3RyaW5naWZ5LFc9InByb3RvdHlwZSIsSD12KCJfaGlkZGVuIiksWj12KCJ0b1ByaW1pdGl2ZSIpLHR0PXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLF89Tygic3ltYm9sLXJlZ2lzdHJ5Iiksc3Q9Tygic3ltYm9scyIpLGs9Tygib3Atc3ltYm9scyIpLGN0PU9iamVjdFtXXSxmdD10eXBlb2YgVj09ImZ1bmN0aW9uIiYmISFELmYsQj1hLlFPYmplY3QsRj0hQnx8IUJbV118fCFCW1ddLmZpbmRDaGlsZCxZPU0mJmMoZnVuY3Rpb24oKXtyZXR1cm4gUihVKHt9LCJhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFUodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hIT03fSk/ZnVuY3Rpb24oaXQsbnQsb3Qpe3ZhciBodD1BKGN0LG50KTtodCYmZGVsZXRlIGN0W250XSxVKGl0LG50LG90KSxodCYmaXQhPT1jdCYmVShjdCxudCxodCl9OlUsUT1mdW5jdGlvbihpdCl7dmFyIG50PXN0W2l0XT1SKFZbV10pO3JldHVybiBudC5faz1pdCxudH0sTj1mdCYmdHlwZW9mIFYuaXRlcmF0b3I9PSJzeW1ib2wiP2Z1bmN0aW9uKGl0KXtyZXR1cm4gdHlwZW9mIGl0PT0ic3ltYm9sIn06ZnVuY3Rpb24oaXQpe3JldHVybiBpdCBpbnN0YW5jZW9mIFZ9LEc9ZnVuY3Rpb24obnQsb3QsaHQpe3JldHVybiBudD09PWN0JiZHKGssb3QsaHQpLHIobnQpLG90PXgob3QsITApLHIoaHQpLGwoc3Qsb3QpPyhodC5lbnVtZXJhYmxlPyhsKG50LEgpJiZudFtIXVtvdF0mJihudFtIXVtvdF09ITEpLGh0PVIoaHQse2VudW1lcmFibGU6UCgwLCExKX0pKToobChudCxIKXx8VShudCxILFAoMSx7fSkpLG50W0hdW290XT0hMCksWShudCxvdCxodCkpOlUobnQsb3QsaHQpfSxvPWZ1bmN0aW9uKG50LG90KXtyKG50KTtmb3IodmFyIGh0PWgob3Q9cyhvdCkpLGR0PTAsdXQ9aHQubGVuZ3RoLG10O3V0PmR0OylHKG50LG10PWh0W2R0KytdLG90W210XSk7cmV0dXJuIG50fSx5PWZ1bmN0aW9uKG50LG90KXtyZXR1cm4gb3Q9PT12b2lkIDA/UihudCk6byhSKG50KSxvdCl9LGo9ZnVuY3Rpb24obnQpe3ZhciBvdD10dC5jYWxsKHRoaXMsbnQ9eChudCwhMCkpO3JldHVybiB0aGlzPT09Y3QmJmwoc3QsbnQpJiYhbChrLG50KT8hMTpvdHx8IWwodGhpcyxudCl8fCFsKHN0LG50KXx8bCh0aGlzLEgpJiZ0aGlzW0hdW250XT9vdDohMH0sej1mdW5jdGlvbihudCxvdCl7aWYobnQ9cyhudCksb3Q9eChvdCwhMCksIShudD09PWN0JiZsKHN0LG90KSYmIWwoayxvdCkpKXt2YXIgaHQ9QShudCxvdCk7cmV0dXJuIGh0JiZsKHN0LG90KSYmIShsKG50LEgpJiZudFtIXVtvdF0pJiYoaHQuZW51bWVyYWJsZT0hMCksaHR9fSwkPWZ1bmN0aW9uKG50KXtmb3IodmFyIG90PUsocyhudCkpLGh0PVtdLGR0PTAsdXQ7b3QubGVuZ3RoPmR0OykhbChzdCx1dD1vdFtkdCsrXSkmJnV0IT1IJiZ1dCE9dSYmaHQucHVzaCh1dCk7cmV0dXJuIGh0fSxYPWZ1bmN0aW9uKG50KXtmb3IodmFyIG90PW50PT09Y3QsaHQ9SyhvdD9rOnMobnQpKSxkdD1bXSx1dD0wLG10O2h0Lmxlbmd0aD51dDspbChzdCxtdD1odFt1dCsrXSkmJighb3R8fGwoY3QsbXQpKSYmZHQucHVzaChzdFttdF0pO3JldHVybiBkdH07ZnR8fChWPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIFYpdGhyb3cgVHlwZUVycm9yKCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhIik7dmFyIG50PWcoYXJndW1lbnRzLmxlbmd0aD4wP2FyZ3VtZW50c1swXTp2b2lkIDApLG90PWZ1bmN0aW9uKGh0KXt0aGlzPT09Y3QmJm90LmNhbGwoayxodCksbCh0aGlzLEgpJiZsKHRoaXNbSF0sbnQpJiYodGhpc1tIXVtudF09ITEpLFkodGhpcyxudCxQKDEsaHQpKX07cmV0dXJuIE0mJkYmJlkoY3QsbnQse2NvbmZpZ3VyYWJsZTohMCxzZXQ6b3R9KSxRKG50KX0sZChWW1ddLCJ0b1N0cmluZyIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa30pLEUuZj16LEkuZj1HLHQoMTgyKS5mPWIuZj0kLHQoMTY5KS5mPWosRC5mPVgsTSYmIXQoODkpJiZkKGN0LCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsaiwhMCksQy5mPWZ1bmN0aW9uKGl0KXtyZXR1cm4gUSh2KGl0KSl9KSxUKFQuRytULlcrVC5GKiFmdCx7U3ltYm9sOlZ9KTtmb3IodmFyIHc9Imhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzIi5zcGxpdCgiLCIpLGV0PTA7dy5sZW5ndGg+ZXQ7KXYod1tldCsrXSk7Zm9yKHZhciBydD1TKHYuc3RvcmUpLGF0PTA7cnQubGVuZ3RoPmF0OylwKHJ0W2F0KytdKTtUKFQuUytULkYqIWZ0LCJTeW1ib2wiLHtmb3I6ZnVuY3Rpb24oaXQpe3JldHVybiBsKF8saXQrPSIiKT9fW2l0XTpfW2l0XT1WKGl0KX0sa2V5Rm9yOmZ1bmN0aW9uKG50KXtpZighTihudCkpdGhyb3cgVHlwZUVycm9yKG50KyIgaXMgbm90IGEgc3ltYm9sISIpO2Zvcih2YXIgb3QgaW4gXylpZihfW290XT09PW50KXJldHVybiBvdH0sdXNlU2V0dGVyOmZ1bmN0aW9uKCl7Rj0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7Rj0hMX19KSxUKFQuUytULkYqIWZ0LCJPYmplY3QiLHtjcmVhdGU6eSxkZWZpbmVQcm9wZXJ0eTpHLGRlZmluZVByb3BlcnRpZXM6byxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6eixnZXRPd25Qcm9wZXJ0eU5hbWVzOiQsZ2V0T3duUHJvcGVydHlTeW1ib2xzOlh9KTt2YXIgbHQ9YyhmdW5jdGlvbigpe0QuZigxKX0pO1QoVC5TK1QuRipsdCwiT2JqZWN0Iix7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKG50KXtyZXR1cm4gRC5mKG4obnQpKX19KSxKJiZUKFQuUytULkYqKCFmdHx8YyhmdW5jdGlvbigpe3ZhciBpdD1WKCk7cmV0dXJuIHEoW2l0XSkhPSJbbnVsbF0ifHxxKHthOml0fSkhPSJ7fSJ8fHEoT2JqZWN0KGl0KSkhPSJ7fSJ9KSksIkpTT04iLHtzdHJpbmdpZnk6ZnVuY3Rpb24obnQpe2Zvcih2YXIgb3Q9W250XSxodD0xLGR0LHV0O2FyZ3VtZW50cy5sZW5ndGg+aHQ7KW90LnB1c2goYXJndW1lbnRzW2h0KytdKTtpZih1dD1kdD1vdFsxXSwhKCFpKGR0KSYmbnQ9PT12b2lkIDB8fE4obnQpKSlyZXR1cm4gbShkdCl8fChkdD1mdW5jdGlvbihtdCxNdCl7aWYodHlwZW9mIHV0PT0iZnVuY3Rpb24iJiYoTXQ9dXQuY2FsbCh0aGlzLG10LE10KSksIU4oTXQpKXJldHVybiBNdH0pLG90WzFdPWR0LHEuYXBwbHkoSixvdCl9fSksVltXXVtaXXx8dCg5NSkoVltXXSxaLFZbV10udmFsdWVPZiksZihWLCJTeW1ib2wiKSxmKE1hdGgsIk1hdGgiLCEwKSxmKGEuSlNPTiwiSlNPTiIsITApfSxmdW5jdGlvbihMLGUsdCl7ZS5mPXQoMTIyKX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTEpLGw9dCg5MiksTT10KDg5KSxUPXQoMTc4KSxkPXQoOTYpLmY7TC5leHBvcnRzPWZ1bmN0aW9uKHUpe3ZhciBjPWwuU3ltYm9sfHwobC5TeW1ib2w9TT97fTphLlN5bWJvbHx8e30pO3UuY2hhckF0KDApIT0iXyImJiEodSBpbiBjKSYmZChjLHUse3ZhbHVlOlQuZih1KX0pfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTEwKSxsPXQoMTY4KSxNPXQoMTY5KTtMLmV4cG9ydHM9ZnVuY3Rpb24oVCl7dmFyIGQ9YShUKSx1PWwuZjtpZih1KWZvcih2YXIgYz11KFQpLE89TS5mLGY9MCxnO2MubGVuZ3RoPmY7KU8uY2FsbChULGc9Y1tmKytdKSYmZC5wdXNoKGcpO3JldHVybiBkfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoODQpLGw9dCgxODIpLmYsTT17fS50b1N0cmluZyxUPXR5cGVvZiB3aW5kb3c9PSJvYmplY3QiJiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W10sZD1mdW5jdGlvbih1KXt0cnl7cmV0dXJuIGwodSl9Y2F0Y2h7cmV0dXJuIFQuc2xpY2UoKX19O0wuZXhwb3J0cy5mPWZ1bmN0aW9uKGMpe3JldHVybiBUJiZNLmNhbGwoYyk9PSJbb2JqZWN0IFdpbmRvd10iP2QoYyk6bChhKGMpKX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDExMSksbD10KDExOSkuY29uY2F0KCJsZW5ndGgiLCJwcm90b3R5cGUiKTtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKFQpe3JldHVybiBhKFQsbCl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxNjkpLGw9dCgxMDQpLE09dCg4NCksVD10KDEwMyksZD10KDEwNSksdT10KDk5KSxjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPXQoMTAwKT9jOmZ1bmN0aW9uKGYsZyl7aWYoZj1NKGYpLGc9VChnLCEwKSx1KXRyeXtyZXR1cm4gYyhmLGcpfWNhdGNoe31pZihkKGYsZykpcmV0dXJuIGwoIWEuZi5jYWxsKGYsZyksZltnXSl9fSxmdW5jdGlvbihMLGUsdCl7dCgxNzkpKCJhc3luY0l0ZXJhdG9yIil9LGZ1bmN0aW9uKEwsZSx0KXt0KDE3OSkoIm9ic2VydmFibGUiKX0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmNyZWF0ZU5vd1RpbWU9YSxlLmZvcm1hdERlbGF5PWw7ZnVuY3Rpb24gYSgpe3ZhciBNPW51bGw7cmV0dXJuIERhdGUubm93P009RGF0ZS5ub3c6TT1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKX0sTX1mdW5jdGlvbiBsKE0pe3JldHVybiB0eXBlb2YgTT09Im51bWJlciI/TT17ZGVsYXk6TX06ImVudHJvcHkiaW4gTSYmKE09e2RlbGF5Ok0uZW50cm9weSxpc0VudHJvcHk6ITB9KSxNfX0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9e2RlZmF1bHQ6ZnVuY3Rpb24obCxNLFQsZCx1KXtyZXR1cm4gdHlwZW9mIGw9PSJudW1iZXIiJiZ0eXBlb2YgTT09Im51bWJlciI/bCsoVC1kKS8odS1kKSooTS1sKTpULWQ+dS1UP006bH19fSxmdW5jdGlvbihMLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUucGFyc2VFYXNpbmc9ZS5FYXNpbmdzPXZvaWQgMDt2YXIgYT10KDc2KSxsPWMoYSksTT10KDEzMyksVD1jKE0pLGQ9dCgxNDEpLHU9YyhkKTtmdW5jdGlvbiBjKG0pe3JldHVybiBtJiZtLl9fZXNNb2R1bGU/bTp7ZGVmYXVsdDptfX12YXIgTz10KDE4OSksZj1uZXcgdS5kZWZhdWx0O2Z1bmN0aW9uIGcoKXtmb3IodmFyIG09YXJndW1lbnRzLmxlbmd0aCxyPUFycmF5KG0pLGk9MDtpPG07aSsrKXJbaV09YXJndW1lbnRzW2ldO3ZhciBuPWYuZ2V0KHIpO3JldHVybiBufHwobj1PLmFwcGx5KHZvaWQgMCxyKSxmLnNldChyLG4pLG4pfWZ1bmN0aW9uIHYobSl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiJlbmQiO3JldHVybiBmdW5jdGlvbihpLG4pe2Zvcih2YXIgcz0xO3M8bi5sZW5ndGg7cysrKXt2YXIgeD1uW3NdLm9mZnNldDtpZihpPD14KXt2YXIgUD1uW3MtMV0ub2Zmc2V0LFI9eCxiPShpLVApLyhSLVApLEU9MS9tLEQ9Yi9FO3JldHVybiByPT09ImVuZCI/RD1NYXRoLmZsb29yKEQpOkQ9TWF0aC5jZWlsKEQpLEUqRCooUi1QKStQfX1yZXR1cm4gMH19ZnVuY3Rpb24gQyhtKXt2YXIgcj0vXmN1YmljLWJlemllclwoKC4qKVwpLyxpPW0ubWF0Y2gocik7aWYoaSl7dmFyIG49aVsxXS50cmltKCk7cmV0dXJuIG49bi5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihFKXtyZXR1cm4gcGFyc2VGbG9hdChFLnRyaW0oKSl9KSxnLmFwcGx5KHZvaWQgMCwoMCxULmRlZmF1bHQpKG4pKX1pZihyPS9ec3RlcHNcKCguKilcKS8saT1tLm1hdGNoKHIpLGkpe3ZhciBzPWlbMV0udHJpbSgpO3M9cy5zcGxpdCgiLCIpLm1hcChmdW5jdGlvbihFKXtyZXR1cm4gRS50cmltKCl9KTt2YXIgeD1zLFA9KDAsbC5kZWZhdWx0KSh4LDIpLFI9UFswXSxiPVBbMV07cmV0dXJuIHYocGFyc2VJbnQoUiwxMCksYil9cmV0dXJuIG19dmFyIHA9e2xpbmVhcjpmdW5jdGlvbihyKXtyZXR1cm4gcn0sZWFzZTpnKC4yNSwuMSwuMjUsMSksImVhc2UtaW4iOmcoLjQyLDAsMSwxKSwiZWFzZS1vdXQiOmcoMCwwLC41OCwxKSwiZWFzZS1pbi1vdXQiOmcoLjQyLDAsLjU4LDEpLCJzdGVwLXN0YXJ0Ijp2KDEsInN0YXJ0IiksInN0ZXAtZW5kIjp2KDEsImVuZCIpfTtmdW5jdGlvbiBoKG0pe3JldHVybiB0eXBlb2YgbT09InN0cmluZyI/cFttXT9tPXBbbV06bT1DKG0pOm0udHlwZT09PSJjdWJpYy1iZXppZXIiP209Zy5hcHBseSh2b2lkIDAsKDAsVC5kZWZhdWx0KShtLnZhbHVlKSk6bS50eXBlPT09InN0ZXBzIiYmKG09dihtLnN0ZXAsbS5wb3MpKSxtfWUuRWFzaW5ncz1wLGUucGFyc2VFYXNpbmc9aH0sZnVuY3Rpb24oTCxlKXt2YXIgdD00LGE9LjAwMSxsPTFlLTcsTT0xMCxUPTExLGQ9MS8oVC0xKSx1PXR5cGVvZiBGbG9hdDMyQXJyYXk9PSJmdW5jdGlvbiI7ZnVuY3Rpb24gYyhtLHIpe3JldHVybiAxLTMqciszKm19ZnVuY3Rpb24gTyhtLHIpe3JldHVybiAzKnItNiptfWZ1bmN0aW9uIGYobSl7cmV0dXJuIDMqbX1mdW5jdGlvbiBnKG0scixpKXtyZXR1cm4oKGMocixpKSptK08ocixpKSkqbStmKHIpKSptfWZ1bmN0aW9uIHYobSxyLGkpe3JldHVybiAzKmMocixpKSptKm0rMipPKHIsaSkqbStmKHIpfWZ1bmN0aW9uIEMobSxyLGksbixzKXt2YXIgeCxQLFI9MDtkbyBQPXIrKGktcikvMix4PWcoUCxuLHMpLW0seD4wP2k9UDpyPVA7d2hpbGUoTWF0aC5hYnMoeCk+bCYmKytSPE0pO3JldHVybiBQfWZ1bmN0aW9uIHAobSxyLGksbil7Zm9yKHZhciBzPTA7czx0Oysrcyl7dmFyIHg9dihyLGksbik7aWYoeD09PTApcmV0dXJuIHI7dmFyIFA9ZyhyLGksbiktbTtyLT1QL3h9cmV0dXJuIHJ9ZnVuY3Rpb24gaChtKXtyZXR1cm4gbX1MLmV4cG9ydHM9ZnVuY3Rpb24ocixpLG4scyl7aWYoISgwPD1yJiZyPD0xJiYwPD1uJiZuPD0xKSl0aHJvdyBuZXcgRXJyb3IoImJlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZSIpO2lmKHI9PT1pJiZuPT09cylyZXR1cm4gaDtmb3IodmFyIHg9dT9uZXcgRmxvYXQzMkFycmF5KFQpOm5ldyBBcnJheShUKSxQPTA7UDxUOysrUCl4W1BdPWcoUCpkLHIsbik7ZnVuY3Rpb24gUihiKXtmb3IodmFyIEU9MCxEPTEsST1ULTE7RCE9PUkmJnhbRF08PWI7KytEKUUrPWQ7LS1EO3ZhciBTPShiLXhbRF0pLyh4W0QrMV0teFtEXSksQT1FK1MqZCxVPXYoQSxyLG4pO3JldHVybiBVPj1hP3AoYixBLHIsbik6VT09PTA/QTpDKGIsRSxFK2QscixuKX1yZXR1cm4gZnVuY3Rpb24oRSl7cmV0dXJuIEU9PT0wPzA6RT09PTE/MTpnKFIoRSksaSxzKX19fSxmdW5jdGlvbihMLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciBhPXQoMTkxKSxsPWkoYSksTT10KDIwNCksVD1pKE0pLGQ9dCgxNjQpLHU9aShkKSxjPXQoMTcwKSxPPWkoYyksZj10KDE3MSksZz1pKGYpLHY9dCgxNzUpLEM9aSh2KSxwPXQoNzUpLGg9aShwKSxtPXQoMjA4KSxyPXQoMTg4KTtmdW5jdGlvbiBpKFUpe3JldHVybiBVJiZVLl9fZXNNb2R1bGU/VTp7ZGVmYXVsdDpVfX12YXIgbj0oMCxDLmRlZmF1bHQpKCJ0aW1pbmciKSxzPSgwLEMuZGVmYXVsdCkoImtleWZyYW1lcyIpLHg9KDAsQy5kZWZhdWx0KSgiaW5pdFN0YXRlIiksUD0oMCxDLmRlZmF1bHQpKCJyZWFkeURlZmVyIiksUj0oMCxDLmRlZmF1bHQpKCJmaW5pc2hlZERlZmVyIiksYj0oMCxDLmRlZmF1bHQpKCJlZmZlY3RzIiksRT0oMCxDLmRlZmF1bHQpKCJhY3RpdmVSZWFkeVRpbWVyIiksRD0oMCxDLmRlZmF1bHQpKCJhY3RpdmVGaW5pc2hUaW1lciIpLEk9KDAsQy5kZWZhdWx0KSgicmVtb3ZlRGVmZXIiKSxTPXtkZWxheTowLGVuZERlbGF5OjAsZmlsbDoiYXV0byIsaXRlcmF0aW9uczoxLHBsYXliYWNrUmF0ZToxLGRpcmVjdGlvbjoibm9ybWFsIixlYXNpbmc6ImxpbmVhciIsZWZmZWN0Om51bGx9LEE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBVKEssVixKKXt2YXIgcT10aGlzO2lmKCgwLE8uZGVmYXVsdCkodGhpcyxVKSxBcnJheS5pc0FycmF5KEspKXt2YXIgVz1bS1swXSxLLFZdO0s9V1swXSxWPVdbMV0sSj1XWzJdfXR5cGVvZiBKPT0ibnVtYmVyIiYmKEo9e2R1cmF0aW9uOkp9KSx0aGlzW25dPSgwLHUuZGVmYXVsdCkoe30sUyxKKSx0aGlzW25dLmVhc2luZz0oMCxyLnBhcnNlRWFzaW5nKSh0aGlzW25dLmVhc2luZyksdGhpc1tzXT0oMCxtLmNhbGN1bGF0ZUZyYW1lc09mZnNldCkoVik7dmFyIEg9dGhpc1tzXVt0aGlzW3NdLmxlbmd0aC0xXTt0aGlzW3hdPXt9LCgwLFQuZGVmYXVsdCkoSCkuZm9yRWFjaChmdW5jdGlvbihaKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoSyxaKSYmWiE9PSJlYXNpbmciJiZaIT09Im9mZnNldCImJihxW3hdW1pdPUtbWl0pfSksdGhpc1tzXT10aGlzW3NdLm1hcChmdW5jdGlvbihaKXtyZXR1cm4oMCx1LmRlZmF1bHQpKHt9LHFbeF0sWil9KSx0aGlzW3NdWzBdLm9mZnNldCE9PTAmJnRoaXNbc10udW5zaGlmdCgoMCx1LmRlZmF1bHQpKHt9LHRoaXNbeF0se29mZnNldDowfSkpLEgub2Zmc2V0PDEmJnRoaXNbc10ucHVzaCgoMCx1LmRlZmF1bHQpKHt9LEgse29mZnNldDoxfSkpLHRoaXNbYl09e30sdGhpcy50aW1lbGluZT1udWxsfXJldHVybigwLGcuZGVmYXVsdCkoVSxbe2tleToicGF1c2UiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZS5wbGF5YmFja1JhdGU9MH19LHtrZXk6RSx2YWx1ZTpmdW5jdGlvbigpe3ZhciBWPXRoaXM7dGhpc1tQXSYmIXRoaXNbUF0udGltZXJJRCYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU8MD90aGlzW1BdLnRpbWVySUQ9dGhpcy50aW1lbGluZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7VltQXS5yZXNvbHZlKCksZGVsZXRlIFZbUF19LHtkZWxheTotdGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxoZWFkaW5nOiExfSk6dGhpc1tQXS50aW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe1ZbUF0ucmVzb2x2ZSgpLGRlbGV0ZSBWW1BdfSx7ZGVsYXk6MCxpc0VudHJvcHk6ITB9KSl9fSx7a2V5OkQsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgVj10aGlzLEo9dGhpc1tuXSxxPUouZHVyYXRpb24sVz1KLml0ZXJhdGlvbnMsSD1KLmVuZERlbGF5LFo9TWF0aC5jZWlsKHEqVytILXRoaXMudGltZWxpbmUuY3VycmVudFRpbWUpKzE7dGhpc1tSXSYmIXRoaXNbUl0udGltZXJJRCYmKHRoaXNbUl0udGltZXJJRD10aGlzLnRpbWVsaW5lLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtWW1JdLnJlc29sdmUoKSxWW0ldKFApLFZbSV0oUil9LHtkZWxheTpaLGhlYWRpbmc6ITF9KSx0aGlzW1JdLnJldmVyc2VUaW1lcklEPXRoaXMudGltZWxpbmUuc2V0VGltZW91dChmdW5jdGlvbigpe1ZbUl0ucmVzb2x2ZSgpLFZbSV0oUCksVltJXShSKSxWLnRpbWVsaW5lPW51bGx9LHtkZWxheTotdGhpc1tuXS5kZWxheS0xLGhlYWRpbmc6ITF9KSl9fSx7a2V5OiJwbGF5Iix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMucGxheVN0YXRlPT09ImZpbmlzaGVkIiYmdGhpcy5jYW5jZWwoKSx0aGlzLnBsYXlTdGF0ZT09PSJpZGxlIil7aWYodGhpcy5wbGF5YmFja1JhdGU8PTApcmV0dXJuO3ZhciBWPXRoaXNbbl0sSj1WLmRlbGF5LHE9Vi5wbGF5YmFja1JhdGUsVz1WLnRpbWVsaW5lO3RoaXMudGltZWxpbmU9bmV3IGguZGVmYXVsdCh7b3JpZ2luVGltZTpKLHBsYXliYWNrUmF0ZTpxfSxXKSx0aGlzW0VdKCksdGhpc1tEXSgpfWVsc2UgdGhpcy5wbGF5U3RhdGU9PT0icGF1c2VkIiYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPXRoaXMucGxheWJhY2tSYXRlLHRoaXNbRV0oKSl9fSx7a2V5OkksdmFsdWU6ZnVuY3Rpb24oVil7dmFyIEo9dGhpc1tWXSxxPXRoaXMudGltZWxpbmU7SiYmcSYmKHEuY2xlYXJUaW1lb3V0KEoudGltZXJJRCksSi5yZXZlcnNlVGltZXJJRCYmcS5jbGVhclRpbWVvdXQoSi5yZXZlcnNlVGltZXJJRCkpLGRlbGV0ZSB0aGlzW1ZdfX0se2tleToiY2FuY2VsIix2YWx1ZTpmdW5jdGlvbigpe3RoaXNbSV0oUCksdGhpc1tJXShSKSx0aGlzLnRpbWVsaW5lPW51bGx9fSx7a2V5OiJmaW5pc2giLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUuY3VycmVudFRpbWU9MS8wL3RoaXMucGxheWJhY2tSYXRlKSx0aGlzW0ldKFApLHRoaXNbSV0oUil9fSx7a2V5OiJhcHBseUVmZmVjdHMiLHZhbHVlOmZ1bmN0aW9uKFYpe3JldHVybigwLHUuZGVmYXVsdCkodGhpc1tiXSxWKX19LHtrZXk6InBsYXliYWNrUmF0ZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbbl0ucGxheWJhY2tSYXRlfSxzZXQ6ZnVuY3Rpb24oVil7dGhpcy50aW1lbGluZSYmKHRoaXMudGltZWxpbmUucGxheWJhY2tSYXRlPVYpLHRoaXNbbl0ucGxheWJhY2tSYXRlPVZ9fSx7a2V5OiJwbGF5U3RhdGUiLGdldDpmdW5jdGlvbigpe3ZhciBWPXRoaXMudGltZWxpbmUsSj10aGlzW25dLHE9Si5pdGVyYXRpb25zLFc9Si5kdXJhdGlvbixIPUouZW5kRGVsYXksWj0icnVubmluZyI7aWYoVj09bnVsbClaPSJpZGxlIjtlbHNlIGlmKFYucGF1c2VkKVo9InBhdXNlZCI7ZWxzZSBpZihWLmN1cnJlbnRUaW1lPDApWj0icGVuZGluZyI7ZWxzZXt2YXIgdHQ9Vi5jdXJyZW50VGltZS1xKlc7dHQ+MCYmdHQ8SD9aPSJwZW5kaW5nIjp0dD49SCYmKFo9ImZpbmlzaGVkIil9cmV0dXJuIFp9fSx7a2V5OiJwcm9ncmVzcyIsZ2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMudGltZWxpbmUpcmV0dXJuIDA7dmFyIFY9dGhpc1tuXSxKPVYuZHVyYXRpb24scT1WLml0ZXJhdGlvbnMsVz10aGlzLnRpbWVsaW5lLEg9dGhpcy5wbGF5U3RhdGUsWj12b2lkIDA7aWYoSD09PSJpZGxlIilaPTA7ZWxzZSBpZihIPT09InBhdXNlZCImJlcuY3VycmVudFRpbWU8MClaPTA7ZWxzZSBpZihIPT09InBlbmRpbmciKWlmKFcuY3VycmVudFRpbWU8MClaPTA7ZWxzZXt2YXIgdHQ9Vy5zZWVrTG9jYWxUaW1lKHEqSik7Wj0oMCxtLnBlcmlvZGljaXR5KSh0dCxKKVsxXS9KfWVsc2UoSD09PSJydW5uaW5nInx8SD09PSJwYXVzZWQiKSYmKFo9KDAsbS5wZXJpb2RpY2l0eSkoVy5jdXJyZW50VGltZSxKKVsxXS9KKTtyZXR1cm4gSD09PSJmaW5pc2hlZCImJihaPSgwLG0ucGVyaW9kaWNpdHkpKHEsMSlbMV0pLFp9fSx7a2V5OiJmcmFtZSIsZ2V0OmZ1bmN0aW9uKCl7dmFyIFY9dGhpcy5wbGF5U3RhdGUsSj10aGlzW3hdLHE9dGhpc1tuXS5maWxsO2lmKFY9PT0iaWRsZSIpcmV0dXJuIEo7dmFyIFc9dGhpcy50aW1lbGluZS5jdXJyZW50VGltZSxIPXRoaXNbc10uc2xpY2UoMCksWj0oMCxtLmdldFByb2dyZXNzKSh0aGlzLnRpbWVsaW5lLHRoaXNbbl0sdGhpcy5wcm9ncmVzcyksdHQ9Wi5wLF89Wi5pbnZlcnRlZCxzdD1KO3JldHVybiBXPDAmJlY9PT0icGVuZGluZyI/KHE9PT0iYmFja3dhcmRzInx8cT09PSJib3RoIikmJihzdD1fP0hbSC5sZW5ndGgtMV06SFswXSk6KFYhPT0icGVuZGluZyImJlYhPT0iZmluaXNoZWQifHxxPT09ImZvcndhcmRzInx8cT09PSJib3RoIikmJihzdD0oMCxtLmdldEN1cnJlbnRGcmFtZSkodGhpc1tuXSxILHRoaXNbYl0sdHQpKSxzdH19LHtrZXk6InRpbWluZyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbbl19fSx7a2V5OiJlZmZlY3RzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tiXX19LHtrZXk6ImJhc2VUaW1lbGluZSIsc2V0OmZ1bmN0aW9uKFYpe3RoaXNbbl0udGltZWxpbmU9Vn0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbbl0udGltZWxpbmV9fSx7a2V5OiJyZWFkeSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbUF0/dGhpc1tQXS5wcm9taXNlOnRoaXMudGltZWxpbmUmJnRoaXMudGltZWxpbmUuY3VycmVudFRpbWU+PTAmJnRoaXMucGxheVN0YXRlIT09InBhdXNlZCI/bC5kZWZhdWx0LnJlc29sdmUoKToodGhpc1tQXT0oMCxtLmRlZmVyKSgpLHRoaXMudGltZWxpbmUmJnRoaXNbRV0oKSx0aGlzW1BdP3RoaXNbUF0ucHJvbWlzZTpsLmRlZmF1bHQucmVzb2x2ZSgpKX19LHtrZXk6ImZpbmlzaGVkIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGU9PT0iZmluaXNoZWQiP2wuZGVmYXVsdC5yZXNvbHZlKCk6KHRoaXNbUl18fCh0aGlzW1JdPSgwLG0uZGVmZXIpKCksdGhpcy50aW1lbGluZSYmdGhpc1tEXSgpKSx0aGlzW1JdLnByb21pc2UpfX1dKSxVfSgpO2UuZGVmYXVsdD1BfSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPXtkZWZhdWx0OnQoMTkyKSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24oTCxlLHQpe3QoMTQzKSx0KDEyNSksdCg3OSksdCgxOTMpLHQoMjAyKSx0KDIwMyksTC5leHBvcnRzPXQoOTIpLlByb21pc2V9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDg5KSxsPXQoOTEpLE09dCg5MyksVD10KDEyOCksZD10KDkwKSx1PXQoOTgpLGM9dCg5NCksTz10KDE0NyksZj10KDE0OCksZz10KDE5NCksdj10KDE5NSkuc2V0LEM9dCgxOTcpKCkscD10KDE5OCksaD10KDE5OSksbT10KDIwMCkscj10KDIwMSksaT0iUHJvbWlzZSIsbj1sLlR5cGVFcnJvcixzPWwucHJvY2Vzcyx4PXMmJnMudmVyc2lvbnMsUD14JiZ4LnY4fHwiIixSPWxbaV0sYj1UKHMpPT0icHJvY2VzcyIsRT1mdW5jdGlvbigpe30sRCxJLFMsQSxVPUk9cC5mLEs9ISFmdW5jdGlvbigpe3RyeXt2YXIgXz1SLnJlc29sdmUoMSksc3Q9KF8uY29uc3RydWN0b3I9e30pW3QoMTIyKSgic3BlY2llcyIpXT1mdW5jdGlvbihrKXtrKEUsRSl9O3JldHVybihifHx0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50PT0iZnVuY3Rpb24iKSYmXy50aGVuKEUpaW5zdGFuY2VvZiBzdCYmUC5pbmRleE9mKCI2LjYiKSE9PTAmJm0uaW5kZXhPZigiQ2hyb21lLzY2Iik9PT0tMX1jYXRjaHt9fSgpLFY9ZnVuY3Rpb24oXyl7dmFyIHN0O3JldHVybiB1KF8pJiZ0eXBlb2Yoc3Q9Xy50aGVuKT09ImZ1bmN0aW9uIj9zdDohMX0sSj1mdW5jdGlvbihfLHN0KXtpZighXy5fbil7Xy5fbj0hMDt2YXIgaz1fLl9jO0MoZnVuY3Rpb24oKXtmb3IodmFyIGN0PV8uX3YsZnQ9Xy5fcz09MSxCPTAsRj1mdW5jdGlvbihZKXt2YXIgUT1mdD9ZLm9rOlkuZmFpbCxOPVkucmVzb2x2ZSxHPVkucmVqZWN0LG89WS5kb21haW4seSxqLHo7dHJ5e1E/KGZ0fHwoXy5faD09MiYmSChfKSxfLl9oPTEpLFE9PT0hMD95PWN0OihvJiZvLmVudGVyKCkseT1RKGN0KSxvJiYoby5leGl0KCksej0hMCkpLHk9PT1ZLnByb21pc2U/RyhuKCJQcm9taXNlLWNoYWluIGN5Y2xlIikpOihqPVYoeSkpP2ouY2FsbCh5LE4sRyk6Tih5KSk6RyhjdCl9Y2F0Y2goJCl7byYmIXomJm8uZXhpdCgpLEcoJCl9fTtrLmxlbmd0aD5COylGKGtbQisrXSk7Xy5fYz1bXSxfLl9uPSExLHN0JiYhXy5faCYmcShfKX0pfX0scT1mdW5jdGlvbihfKXt2LmNhbGwobCxmdW5jdGlvbigpe3ZhciBzdD1fLl92LGs9VyhfKSxjdCxmdCxCO2lmKGsmJihjdD1oKGZ1bmN0aW9uKCl7Yj9zLmVtaXQoInVuaGFuZGxlZFJlamVjdGlvbiIsc3QsXyk6KGZ0PWwub251bmhhbmRsZWRyZWplY3Rpb24pP2Z0KHtwcm9taXNlOl8scmVhc29uOnN0fSk6KEI9bC5jb25zb2xlKSYmQi5lcnJvciYmQi5lcnJvcigiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIixzdCl9KSxfLl9oPWJ8fFcoXyk/MjoxKSxfLl9hPXZvaWQgMCxrJiZjdC5lKXRocm93IGN0LnZ9KX0sVz1mdW5jdGlvbihfKXtyZXR1cm4gXy5faCE9PTEmJihfLl9hfHxfLl9jKS5sZW5ndGg9PT0wfSxIPWZ1bmN0aW9uKF8pe3YuY2FsbChsLGZ1bmN0aW9uKCl7dmFyIHN0O2I/cy5lbWl0KCJyZWplY3Rpb25IYW5kbGVkIixfKTooc3Q9bC5vbnJlamVjdGlvbmhhbmRsZWQpJiZzdCh7cHJvbWlzZTpfLHJlYXNvbjpfLl92fSl9KX0sWj1mdW5jdGlvbihfKXt2YXIgc3Q9dGhpcztzdC5fZHx8KHN0Ll9kPSEwLHN0PXN0Ll93fHxzdCxzdC5fdj1fLHN0Ll9zPTIsc3QuX2F8fChzdC5fYT1zdC5fYy5zbGljZSgpKSxKKHN0LCEwKSl9LHR0PWZ1bmN0aW9uKF8pe3ZhciBzdD10aGlzLGs7aWYoIXN0Ll9kKXtzdC5fZD0hMCxzdD1zdC5fd3x8c3Q7dHJ5e2lmKHN0PT09Xyl0aHJvdyBuKCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZiIpOyhrPVYoXykpP0MoZnVuY3Rpb24oKXt2YXIgY3Q9e193OnN0LF9kOiExfTt0cnl7ay5jYWxsKF8sTSh0dCxjdCwxKSxNKFosY3QsMSkpfWNhdGNoKGZ0KXtaLmNhbGwoY3QsZnQpfX0pOihzdC5fdj1fLHN0Ll9zPTEsSihzdCwhMSkpfWNhdGNoKGN0KXtaLmNhbGwoe193OnN0LF9kOiExfSxjdCl9fX07S3x8KFI9ZnVuY3Rpb24oc3Qpe08odGhpcyxSLGksIl9oIiksYyhzdCksRC5jYWxsKHRoaXMpO3RyeXtzdChNKHR0LHRoaXMsMSksTShaLHRoaXMsMSkpfWNhdGNoKGspe1ouY2FsbCh0aGlzLGspfX0sRD1mdW5jdGlvbihzdCl7dGhpcy5fYz1bXSx0aGlzLl9hPXZvaWQgMCx0aGlzLl9zPTAsdGhpcy5fZD0hMSx0aGlzLl92PXZvaWQgMCx0aGlzLl9oPTAsdGhpcy5fbj0hMX0sRC5wcm90b3R5cGU9dCgxNDYpKFIucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHN0LGspe3ZhciBjdD1VKGcodGhpcyxSKSk7cmV0dXJuIGN0Lm9rPXR5cGVvZiBzdD09ImZ1bmN0aW9uIj9zdDohMCxjdC5mYWlsPXR5cGVvZiBrPT0iZnVuY3Rpb24iJiZrLGN0LmRvbWFpbj1iP3MuZG9tYWluOnZvaWQgMCx0aGlzLl9jLnB1c2goY3QpLHRoaXMuX2EmJnRoaXMuX2EucHVzaChjdCksdGhpcy5fcyYmSih0aGlzLCExKSxjdC5wcm9taXNlfSxjYXRjaDpmdW5jdGlvbihfKXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxfKX19KSxTPWZ1bmN0aW9uKCl7dmFyIF89bmV3IEQ7dGhpcy5wcm9taXNlPV8sdGhpcy5yZXNvbHZlPU0odHQsXywxKSx0aGlzLnJlamVjdD1NKFosXywxKX0scC5mPVU9ZnVuY3Rpb24oXyl7cmV0dXJuIF89PT1SfHxfPT09QT9uZXcgUyhfKTpJKF8pfSksZChkLkcrZC5XK2QuRiohSyx7UHJvbWlzZTpSfSksdCgxMjEpKFIsaSksdCgxNDkpKGkpLEE9dCg5MilbaV0sZChkLlMrZC5GKiFLLGkse3JlamVjdDpmdW5jdGlvbihzdCl7dmFyIGs9VSh0aGlzKSxjdD1rLnJlamVjdDtyZXR1cm4gY3Qoc3QpLGsucHJvbWlzZX19KSxkKGQuUytkLkYqKGF8fCFLKSxpLHtyZXNvbHZlOmZ1bmN0aW9uKHN0KXtyZXR1cm4gcihhJiZ0aGlzPT09QT9SOnRoaXMsc3QpfX0pLGQoZC5TK2QuRiohKEsmJnQoMTQwKShmdW5jdGlvbihfKXtSLmFsbChfKS5jYXRjaChFKX0pKSxpLHthbGw6ZnVuY3Rpb24oc3Qpe3ZhciBrPXRoaXMsY3Q9VShrKSxmdD1jdC5yZXNvbHZlLEI9Y3QucmVqZWN0LEY9aChmdW5jdGlvbigpe3ZhciBZPVtdLFE9MCxOPTE7ZihzdCwhMSxmdW5jdGlvbihHKXt2YXIgbz1RKysseT0hMTtZLnB1c2godm9pZCAwKSxOKyssay5yZXNvbHZlKEcpLnRoZW4oZnVuY3Rpb24oail7eXx8KHk9ITAsWVtvXT1qLC0tTnx8ZnQoWSkpfSxCKX0pLC0tTnx8ZnQoWSl9KTtyZXR1cm4gRi5lJiZCKEYudiksY3QucHJvbWlzZX0scmFjZTpmdW5jdGlvbihzdCl7dmFyIGs9dGhpcyxjdD1VKGspLGZ0PWN0LnJlamVjdCxCPWgoZnVuY3Rpb24oKXtmKHN0LCExLGZ1bmN0aW9uKEYpe2sucmVzb2x2ZShGKS50aGVuKGN0LnJlc29sdmUsZnQpfSl9KTtyZXR1cm4gQi5lJiZmdChCLnYpLGN0LnByb21pc2V9fSl9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDk3KSxsPXQoOTQpLE09dCgxMjIpKCJzcGVjaWVzIik7TC5leHBvcnRzPWZ1bmN0aW9uKFQsZCl7dmFyIHU9YShUKS5jb25zdHJ1Y3RvcixjO3JldHVybiB1PT09dm9pZCAwfHwoYz1hKHUpW01dKT09bnVsbD9kOmwoYyl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MyksbD10KDE5NiksTT10KDEyMCksVD10KDEwMiksZD10KDkxKSx1PWQucHJvY2VzcyxjPWQuc2V0SW1tZWRpYXRlLE89ZC5jbGVhckltbWVkaWF0ZSxmPWQuTWVzc2FnZUNoYW5uZWwsZz1kLkRpc3BhdGNoLHY9MCxDPXt9LHA9Im9ucmVhZHlzdGF0ZWNoYW5nZSIsaCxtLHIsaT1mdW5jdGlvbigpe3ZhciBzPSt0aGlzO2lmKEMuaGFzT3duUHJvcGVydHkocykpe3ZhciB4PUNbc107ZGVsZXRlIENbc10seCgpfX0sbj1mdW5jdGlvbihzKXtpLmNhbGwocy5kYXRhKX07KCFjfHwhTykmJihjPWZ1bmN0aW9uKHgpe2Zvcih2YXIgUD1bXSxSPTE7YXJndW1lbnRzLmxlbmd0aD5SOylQLnB1c2goYXJndW1lbnRzW1IrK10pO3JldHVybiBDWysrdl09ZnVuY3Rpb24oKXtsKHR5cGVvZiB4PT0iZnVuY3Rpb24iP3g6RnVuY3Rpb24oeCksUCl9LGgodiksdn0sTz1mdW5jdGlvbih4KXtkZWxldGUgQ1t4XX0sdCg4NikodSk9PSJwcm9jZXNzIj9oPWZ1bmN0aW9uKHMpe3UubmV4dFRpY2soYShpLHMsMSkpfTpnJiZnLm5vdz9oPWZ1bmN0aW9uKHMpe2cubm93KGEoaSxzLDEpKX06Zj8obT1uZXcgZixyPW0ucG9ydDIsbS5wb3J0MS5vbm1lc3NhZ2U9bixoPWEoci5wb3N0TWVzc2FnZSxyLDEpKTpkLmFkZEV2ZW50TGlzdGVuZXImJnR5cGVvZiBwb3N0TWVzc2FnZT09ImZ1bmN0aW9uIiYmIWQuaW1wb3J0U2NyaXB0cz8oaD1mdW5jdGlvbihzKXtkLnBvc3RNZXNzYWdlKHMrIiIsIioiKX0sZC5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixuLCExKSk6cCBpbiBUKCJzY3JpcHQiKT9oPWZ1bmN0aW9uKHMpe00uYXBwZW5kQ2hpbGQoVCgic2NyaXB0IikpW3BdPWZ1bmN0aW9uKCl7TS5yZW1vdmVDaGlsZCh0aGlzKSxpLmNhbGwocyl9fTpoPWZ1bmN0aW9uKHMpe3NldFRpbWVvdXQoYShpLHMsMSksMCl9KSxMLmV4cG9ydHM9e3NldDpjLGNsZWFyOk99fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0LGEsbCl7dmFyIE09bD09PXZvaWQgMDtzd2l0Y2goYS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gTT90KCk6dC5jYWxsKGwpO2Nhc2UgMTpyZXR1cm4gTT90KGFbMF0pOnQuY2FsbChsLGFbMF0pO2Nhc2UgMjpyZXR1cm4gTT90KGFbMF0sYVsxXSk6dC5jYWxsKGwsYVswXSxhWzFdKTtjYXNlIDM6cmV0dXJuIE0/dChhWzBdLGFbMV0sYVsyXSk6dC5jYWxsKGwsYVswXSxhWzFdLGFbMl0pO2Nhc2UgNDpyZXR1cm4gTT90KGFbMF0sYVsxXSxhWzJdLGFbM10pOnQuY2FsbChsLGFbMF0sYVsxXSxhWzJdLGFbM10pfXJldHVybiB0LmFwcGx5KGwsYSl9fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MSksbD10KDE5NSkuc2V0LE09YS5NdXRhdGlvbk9ic2VydmVyfHxhLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsVD1hLnByb2Nlc3MsZD1hLlByb21pc2UsdT10KDg2KShUKT09InByb2Nlc3MiO0wuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBjLE8sZixnPWZ1bmN0aW9uKCl7dmFyIGgsbTtmb3IodSYmKGg9VC5kb21haW4pJiZoLmV4aXQoKTtjOyl7bT1jLmZuLGM9Yy5uZXh0O3RyeXttKCl9Y2F0Y2gocil7dGhyb3cgYz9mKCk6Tz12b2lkIDAscn19Tz12b2lkIDAsaCYmaC5lbnRlcigpfTtpZih1KWY9ZnVuY3Rpb24oKXtULm5leHRUaWNrKGcpfTtlbHNlIGlmKE0mJiEoYS5uYXZpZ2F0b3ImJmEubmF2aWdhdG9yLnN0YW5kYWxvbmUpKXt2YXIgdj0hMCxDPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTtuZXcgTShnKS5vYnNlcnZlKEMse2NoYXJhY3RlckRhdGE6ITB9KSxmPWZ1bmN0aW9uKCl7Qy5kYXRhPXY9IXZ9fWVsc2UgaWYoZCYmZC5yZXNvbHZlKXt2YXIgcD1kLnJlc29sdmUodm9pZCAwKTtmPWZ1bmN0aW9uKCl7cC50aGVuKGcpfX1lbHNlIGY9ZnVuY3Rpb24oKXtsLmNhbGwoYSxnKX07cmV0dXJuIGZ1bmN0aW9uKGgpe3ZhciBtPXtmbjpoLG5leHQ6dm9pZCAwfTtPJiYoTy5uZXh0PW0pLGN8fChjPW0sZigpKSxPPW19fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTQpO2Z1bmN0aW9uIGwoTSl7dmFyIFQsZDt0aGlzLnByb21pc2U9bmV3IE0oZnVuY3Rpb24odSxjKXtpZihUIT09dm9pZCAwfHxkIT09dm9pZCAwKXRocm93IFR5cGVFcnJvcigiQmFkIFByb21pc2UgY29uc3RydWN0b3IiKTtUPXUsZD1jfSksdGhpcy5yZXNvbHZlPWEoVCksdGhpcy5yZWplY3Q9YShkKX1MLmV4cG9ydHMuZj1mdW5jdGlvbihNKXtyZXR1cm4gbmV3IGwoTSl9fSxmdW5jdGlvbihMLGUpe0wuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJue2U6ITEsdjp0KCl9fWNhdGNoKGEpe3JldHVybntlOiEwLHY6YX19fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTEpLGw9YS5uYXZpZ2F0b3I7TC5leHBvcnRzPWwmJmwudXNlckFnZW50fHwiIn0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTcpLGw9dCg5OCksTT10KDE5OCk7TC5leHBvcnRzPWZ1bmN0aW9uKFQsZCl7aWYoYShUKSxsKGQpJiZkLmNvbnN0cnVjdG9yPT09VClyZXR1cm4gZDt2YXIgdT1NLmYoVCksYz11LnJlc29sdmU7cmV0dXJuIGMoZCksdS5wcm9taXNlfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoOTApLGw9dCg5MiksTT10KDkxKSxUPXQoMTk0KSxkPXQoMjAxKTthKGEuUCthLlIsIlByb21pc2UiLHtmaW5hbGx5OmZ1bmN0aW9uKHUpe3ZhciBjPVQodGhpcyxsLlByb21pc2V8fE0uUHJvbWlzZSksTz10eXBlb2YgdT09ImZ1bmN0aW9uIjtyZXR1cm4gdGhpcy50aGVuKE8/ZnVuY3Rpb24oZil7cmV0dXJuIGQoYyx1KCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZn0pfTp1LE8/ZnVuY3Rpb24oZil7cmV0dXJuIGQoYyx1KCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBmfSl9OnUpfX0pfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCksbD10KDE5OCksTT10KDE5OSk7YShhLlMsIlByb21pc2UiLHt0cnk6ZnVuY3Rpb24oVCl7dmFyIGQ9bC5mKHRoaXMpLHU9TShUKTtyZXR1cm4odS5lP2QucmVqZWN0OmQucmVzb2x2ZSkodS52KSxkLnByb21pc2V9fSl9LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9e2RlZmF1bHQ6dCgyMDUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbihMLGUsdCl7dCgyMDYpLEwuZXhwb3J0cz10KDkyKS5PYmplY3Qua2V5c30sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMTI0KSxsPXQoMTEwKTt0KDIwNykoImtleXMiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKFQpe3JldHVybiBsKGEoVCkpfX0pfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCksbD10KDkyKSxNPXQoMTAxKTtMLmV4cG9ydHM9ZnVuY3Rpb24oVCxkKXt2YXIgdT0obC5PYmplY3R8fHt9KVtUXXx8T2JqZWN0W1RdLGM9e307Y1tUXT1kKHUpLGEoYS5TK2EuRipNKGZ1bmN0aW9uKCl7dSgxKX0pLCJPYmplY3QiLGMpfX0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgYT10KDc2KSxsPUMoYSksTT10KDIwOSksVD1DKE0pLGQ9dCgxNjQpLHU9QyhkKSxjPXQoMTkxKSxPPUMoYyk7ZS5kZWZlcj1wLGUucGVyaW9kaWNpdHk9aCxlLmNhbGN1bGF0ZUZyYW1lc09mZnNldD1tLGUuZ2V0UHJvZ3Jlc3M9cixlLmdldEN1cnJlbnRGcmFtZT1uO3ZhciBmPXQoMTg4KSxnPXQoMTg3KSx2PUMoZyk7ZnVuY3Rpb24gQyhzKXtyZXR1cm4gcyYmcy5fX2VzTW9kdWxlP3M6e2RlZmF1bHQ6c319ZnVuY3Rpb24gcCgpe3ZhciBzPXt9O3JldHVybiBzLnByb21pc2U9bmV3IE8uZGVmYXVsdChmdW5jdGlvbih4LFApe3MucmVzb2x2ZT14LHMucmVqZWN0PVB9KSxzfWZ1bmN0aW9uIGgocyx4KXt2YXIgUD1NYXRoLmZsb29yKHMveCksUj1zLVAqeDtyZXR1cm4gUj09PTAmJlA+MCYmKFI9eCxQLS0pLFtQLFJdfWZ1bmN0aW9uIG0ocyl7cz1zLnNsaWNlKDApO3ZhciB4PXNbMF0sUD1zW3MubGVuZ3RoLTFdO1Aub2Zmc2V0PVAub2Zmc2V0fHwxLHgub2Zmc2V0PXgub2Zmc2V0fHwwO2Zvcih2YXIgUj0wLGI9LTEsRT0wO0U8cy5sZW5ndGg7RSsrKXt2YXIgRD1zW0VdO2lmKEQub2Zmc2V0IT1udWxsKXt2YXIgST1FLWI7aWYoST4xKWZvcih2YXIgUz0oRC5vZmZzZXQtUikvSSxBPTA7QTxJLTE7QSsrKXNbYitBKzFdLm9mZnNldD1SK1MqKEErMSk7Uj1ELm9mZnNldCxiPUV9aWYoRC5lYXNpbmchPW51bGwmJihELmVhc2luZz0oMCxmLnBhcnNlRWFzaW5nKShELmVhc2luZykpLEU+MCl7dmFyIFU9c1tFXS5lYXNpbmchPW51bGw7c1tFXT0oMCx1LmRlZmF1bHQpKHt9LHNbRS0xXSxzW0VdKSxVfHxkZWxldGUgc1tFXS5lYXNpbmd9fXJldHVybiBzfWZ1bmN0aW9uIHIocyx4LFApe3ZhciBSPXMuY3VycmVudFRpbWUsYj14LmRpcmVjdGlvbixFPXguZHVyYXRpb24sRD0hMTtpZihiPT09InJldmVyc2UiKVA9MS1QLEQ9ITA7ZWxzZSBpZihiPT09ImFsdGVybmF0ZSJ8fGI9PT0iYWx0ZXJuYXRlLXJldmVyc2UiKXt2YXIgST1NYXRoLmZsb29yKFIvRSk7UD09PTEmJkktLSxJJTJeYj09PSJhbHRlcm5hdGUtcmV2ZXJzZSImJihQPTEtUCxEPSEwKX1yZXR1cm57cDpQLGludmVydGVkOkR9fWZ1bmN0aW9uIGkocyx4LFAsUil7dmFyIGI9e307cmV0dXJuKDAsVC5kZWZhdWx0KSh4KS5mb3JFYWNoKGZ1bmN0aW9uKEUpe3ZhciBEPSgwLGwuZGVmYXVsdCkoRSwyKSxJPURbMF0sUz1EWzFdO2lmKEkhPT0ib2Zmc2V0IiYmSSE9PSJlYXNpbmciKXt2YXIgQT1QW0ldfHxQLmRlZmF1bHQsVT1BKHNbSV0sUyxSLHMub2Zmc2V0LHgub2Zmc2V0KTtVIT1udWxsJiYoYltJXT1VKX19KSxifWZ1bmN0aW9uIG4ocyx4LFAsUil7dmFyIGI9cy5lYXNpbmcsRT1zLmVmZmVjdDtFfHwoUD0oMCx1LmRlZmF1bHQpKHt9LHYuZGVmYXVsdCxQKSk7dmFyIEQ9e307Uj1iKFIseCk7Zm9yKHZhciBJPTE7STx4Lmxlbmd0aDtJKyspe3ZhciBTPXhbSV0sQT1TLm9mZnNldDtpZihBPj1SfHxJPT09eC5sZW5ndGgtMSl7dmFyIFU9eFtJLTFdLEs9VS5vZmZzZXQsVj1VLmVhc2luZyxKPVI7aWYoVil7dmFyIHE9QS1LO0o9VigoUi1LKS9xKSpxK0t9RT9EPUUoVSxTLEosSyxBKTpEPWkoVSxTLFAsSik7YnJlYWt9fXJldHVybiBEfX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz17ZGVmYXVsdDp0KDIxMCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKEwsZSx0KXt0KDIxMSksTC5leHBvcnRzPXQoOTIpLk9iamVjdC5lbnRyaWVzfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCg5MCksbD10KDIxMikoITApO2EoYS5TLCJPYmplY3QiLHtlbnRyaWVzOmZ1bmN0aW9uKFQpe3JldHVybiBsKFQpfX0pfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgxMDApLGw9dCgxMTApLE09dCg4NCksVD10KDE2OSkuZjtMLmV4cG9ydHM9ZnVuY3Rpb24oZCl7cmV0dXJuIGZ1bmN0aW9uKHUpe2Zvcih2YXIgYz1NKHUpLE89bChjKSxmPU8ubGVuZ3RoLGc9MCx2PVtdLEM7Zj5nOylDPU9bZysrXSwoIWF8fFQuY2FsbChjLEMpKSYmdi5wdXNoKGQ/W0MsY1tDXV06Y1tDXSk7cmV0dXJuIHZ9fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgYT1uZXcgTWFwO2Z1bmN0aW9uIGwoVCxkPXt9LHU9W10pe1Q9VC50b0xvd2VyQ2FzZSgpO2NvbnN0IGM9YS5nZXQoVCk7aWYoIWMpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBub2RlOiAke1R9YCk7Y29uc3QgTz1uZXcgYyhkKTtyZXR1cm4gdS5mb3JFYWNoKGY9PntPLmFwcGVuZENoaWxkKGYpfSksT31jb25zdCBNPXtyZWdpc3Rlck5vZGUoVCxkLHU9MTAwKXtpZihkPWQudG9Mb3dlckNhc2UoKSxhLmhhcyhkKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVnaXN0ZXJOb2RlLCAke2R9IGhhcyBiZWVuIHRha2VuLmApO2Euc2V0KGQsVCksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVC5wcm90b3R5cGUse25vZGVUeXBlOnt2YWx1ZTp1fSx0YWdOYW1lOnt2YWx1ZTpkLnRvVXBwZXJDYXNlKCl9LG5vZGVOYW1lOnt2YWx1ZTpkfSxvd25lckRvY3VtZW50Ont2YWx1ZTpNfSxuYW1lc3BhY2VVUkk6e3ZhbHVlOmBodHRwOi8vc3ByaXRlanMuY29tLyR7ZH1gfX0pfSxjcmVhdGVFbGVtZW50OmwsY3JlYXRlRWxlbWVudE5TKFQsZCl7cmV0dXJuIGwoZCl9LGlzU3ByaXRlTm9kZShUKXtyZXR1cm4gYS5oYXMoVC50b0xvd2VyQ2FzZSgpKX19O2UuZGVmYXVsdD1NfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGE9U3ltYm9sKCJ0eXBlIiksbD1TeW1ib2woImJ1YmJsZXMiKSxNPVN5bWJvbCgib3JpZ2luYWxFdmVudCIpLFQ9U3ltYm9sKCJkZXRhaWwiKTtjbGFzcyBke2NvbnN0cnVjdG9yKGMse2J1YmJsZXM6Tz1udWxsfT17fSl7aWYodHlwZW9mIGM9PSJzdHJpbmciPyh0aGlzW2FdPWMsdGhpc1tsXT0hIU8pOih0aGlzW2FdPWMudHlwZSx0aGlzW01dPWMsdGhpc1tsXT1PIT1udWxsPyEhTzohIWMuYnViYmxlcyxjLmRldGFpbCYmKHRoaXNbVF09Yy5kZXRhaWwpKSwhdGhpc1thXSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGV2ZW50IHR5cGUuIik7dGhpcy5jYW5jZWxCdWJibGU9ITF9c2V0T3JpZ2luYWxFdmVudChjKXt0aGlzW01dPWN9Z2V0IG9yaWdpbmFsRXZlbnQoKXtyZXR1cm4gdGhpc1tNXX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW2FdfWdldCBidWJibGVzKCl7cmV0dXJuIHRoaXNbbF19Z2V0IGRldGFpbCgpe3JldHVybiB0aGlzW1RdfXN0b3BQcm9wYWdhdGlvbigpe3RoaXMuY2FuY2VsQnViYmxlPSEwfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsInBhcnNlRmlsdGVyU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBsfSksdC5kKGUsImFwcGx5RmlsdGVycyIsZnVuY3Rpb24oKXtyZXR1cm4gTX0pO3ZhciBhPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBsKFQpe2lmKFQ9VC50cmltKCksIVR8fFQ9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgZD0vXig/Oih1cmx8Ymx1cnxicmlnaHRuZXNzfGNvbnRyYXN0fGRyb3Atc2hhZG93fGdyYXlzY2FsZXxodWUtcm90YXRlfGludmVydHxvcGFjaXR5fHNhdHVyYXRlfHNlcGlhKVwoKFteKCldKig/OlwoLipcKSkqW14oKV0qKVwpKSskL2ksdT1ULm1hdGNoKC8oPzoodXJsfGJsdXJ8YnJpZ2h0bmVzc3xjb250cmFzdHxkcm9wLXNoYWRvd3xncmF5c2NhbGV8aHVlLXJvdGF0ZXxpbnZlcnR8b3BhY2l0eXxzYXR1cmF0ZXxzZXBpYSlcKChbXigpXSooPzpcKC4qXCkpKlteKCldKilcKSkrPy9pZyksYz1bXTtyZXR1cm4gdSYmdS5mb3JFYWNoKE89Pntjb25zdCBmPU8ubWF0Y2goZCk7aWYoIWYpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBmaXRsZXIgc3RyaW5nLiIpO2xldFssZyx2XT1mO2c9Zy50b0xvd2VyQ2FzZSgpLHY9di50cmltKCkubWF0Y2goLyhbXiggKV0rfChbXiggKV0rXCguKlwpKSkoPz1cc3wkKS9nKS5tYXAoKEMscCk9PntsZXQgaDtyZXR1cm4gZz09PSJ1cmwifHxnPT09ImRyb3Atc2hhZG93IiYmcD09PTM/aD1DOmg9T2JqZWN0KGEudG9OdW1iZXIpKEMpLC8lJC8udGVzdChDKSYmKGgvPTEwMCksaH0pLGMucHVzaCh7dHlwZTpnLGFyZ3M6dn0pfSksY31mdW5jdGlvbiBNKFQsZCl7VC5jbGVhckZpbHRlcigpLGQmJmQuZm9yRWFjaCgoe3R5cGU6dSxhcmdzOmN9KT0+e2xldCBPPXU7Tz09PSJkcm9wLXNoYWRvdyI/Tz0iZHJvcFNoYWRvdyI6Tz09PSJodWUtcm90YXRlIiYmKE89Imh1ZVJvdGF0ZSIpLFRbT10oLi4uYyl9KX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShsLE0pe2lmKCFNKXJldHVybjtjb25zdCBUPWwuZ2V0TGlzdGVuZXJzKCJiZWZvcmVyZW5kZXIiKSxkPWwuZ2V0TGlzdGVuZXJzKCJhZnRlcnJlbmRlciIpO1QubGVuZ3RoJiYhTS5iZWZvcmVSZW5kZXI/TS5iZWZvcmVSZW5kZXI9dT0+e2wuZGlzcGF0Y2hFdmVudCh7dHlwZToiYmVmb3JlcmVuZGVyIixkZXRhaWw6e2NvbnRleHQ6dX19KX06VC5sZW5ndGh8fChNLmJlZm9yZVJlbmRlcj1udWxsKSxkLmxlbmd0aCYmIU0uYWZ0ZXJSZW5kZXI/TS5hZnRlclJlbmRlcj11PT57bC5kaXNwYXRjaEV2ZW50KHt0eXBlOiJhZnRlcnJlbmRlciIsZGV0YWlsOntjb250ZXh0OnV9fSl9OmQubGVuZ3RofHwoTS5hZnRlclJlbmRlcj1udWxsKX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgYT10KDEyKSxsPXQoMjE4KSxNPXQoNzApLFQ9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBkPVN5bWJvbCgiYW1vdW50IiksdT1TeW1ib2woIm1lc2hDbG91ZCIpO2NsYXNzIGMgZXh0ZW5kcyBNLmRlZmF1bHR7Y29uc3RydWN0b3IoZixnPTEpe3N1cGVyKCksdGhpcy5tZXNoTm9kZT1mLGYuY29ubmVjdCh0aGlzKSx0aGlzW2RdPWcsdGhpc1t1XT1udWxsfWdldCBtZXNoQ2xvdWQoKXtjb25zdCBmPXRoaXMubWVzaE5vZGUsZz10aGlzW2RdO3JldHVybiF0aGlzW3VdJiZmLm1lc2gmJih0aGlzW3VdPW5ldyBhLk1lc2hDbG91ZChmLm1lc2gsZykpLHRoaXNbdV19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5tZXNoTm9kZSYmdGhpcy5tZXNoTm9kZS5pc1Zpc2libGV9Z2V0IGFtb3VudCgpe3JldHVybiB0aGlzW2RdfXNldCBhbW91bnQoZil7dGhpc1tkXT1mLHRoaXNbdV0mJih0aGlzW3VdLmFtb3VudD1mKX1icmlnaHRuZXNzKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5icmlnaHRuZXNzKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1jb250cmFzdChmLGcpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuY29udHJhc3QoZixnKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWRlbGV0ZShmKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmRlbGV0ZShmKSx0aGlzW2RdLS0sdGhpcy5mb3JjZVVwZGF0ZSgpKX1kcmF3KGY9W10pe2lmKHN1cGVyLmRyYXcoZiksdGhpcy5tZXNoQ2xvdWQpe2lmKHRoaXMucHJvZ3JhbSl7dGhpcy5tZXNoQ2xvdWQuc2V0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO2NvbnN0IGc9dGhpcy5zaGFkZXJBdHRycztnJiZPYmplY3QuZW50cmllcyhnKS5mb3JFYWNoKChbQyxwXSk9Pnt0aGlzLm1lc2hDbG91ZC5tZXNoLnNldEF0dHJpYnV0ZShDLHApfSk7Y29uc3Qgdj10aGlzLnVuaWZvcm1zO2lmKHRoaXMudW5pZm9ybXMpe2NvbnN0IEM9e307T2JqZWN0LmVudHJpZXModikuZm9yRWFjaCgoW3AsaF0pPT57dHlwZW9mIGg9PSJmdW5jdGlvbiImJihoPWgodGhpcyxwKSksQ1twXT1ofSksdGhpcy5tZXNoQ2xvdWQubWVzaC5zZXRVbmlmb3JtcyhDKX19dGhpcy5tZXNoTm9kZS50ZXh0dXJlSW1hZ2UmJk9iamVjdChsLmRyYXdUZXh0dXJlKSh0aGlzLm1lc2hOb2RlLHRoaXMubWVzaE5vZGUubWVzaCksZi5wdXNoKHRoaXMubWVzaENsb3VkKX1yZXR1cm4gZn1nZXRUcmFuc2Zvcm0oZil7aWYodGhpcy5tZXNoQ2xvdWQpcmV0dXJuIHRoaXMubWVzaENsb3VkLmdldFRyYW5zZm9ybShmKX1ncmF5c2NhbGUoZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLmdyYXlzY2FsZShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9aHVlUm90YXRlKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5odWVSb3RhdGUoZixnKSx0aGlzLmZvcmNlVXBkYXRlKCkpfWludmVydChmLGcpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQuaW52ZXJ0KGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1pc1BvaW50Q29sbGlzaW9uKGYsZyl7aWYoIXRoaXMubWVzaENsb3VkKXJldHVybiExO2NvbnN0IHY9dGhpcy5hdHRyaWJ1dGVzLnBvaW50ZXJFdmVudHM7aWYodj09PSJub25lInx8diE9PSJhbGwiJiYhdGhpcy5pc1Zpc2libGUpcmV0dXJuITE7bGV0IEM9ImJvdGgiO3Y9PT0idmlzaWJsZUZpbGwiJiYoQz0iZmlsbCIpLHY9PT0idmlzaWJsZVN0cm9rZSImJihDPSJzdHJva2UiKTtmb3IobGV0IHA9MDtwPHRoaXNbZF07cCsrKWlmKCF0aGlzLm1lc2hDbG91ZC5pc1BvaW50Q29sbGlzaW9uKHAsW2YsZ10sQykpcmV0dXJuITE7cmV0dXJuITB9c2V0T3BhY2l0eShmLGcpe3RoaXMubWVzaENsb3VkJiYodGhpcy5tZXNoQ2xvdWQub3BhY2l0eShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9cm90YXRlKGYsZyxbdixDXT1bMCwwXSl7Y29uc3QgcD1NYXRoLlBJKmcvMTgwO2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OmgseTptfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQucm90YXRlKGYscCxbditoLEMrbV0pLHRoaXMuZm9yY2VVcGRhdGUoKX19c2F0dXJhdGUoZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNhdHVyYXRlKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zY2FsZShmLFtnLHY9Z10sW0MscF09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OmgseTptfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXMscj0xZS01O01hdGguYWJzKGcpPHImJihnPTEvZz4wP3I6LXIpLE1hdGguYWJzKHYpPHImJih2PTEvdj4wP3I6LXIpLHRoaXMubWVzaENsb3VkLnNjYWxlKGYsW2csdl0sW0MraCxwK21dKSx0aGlzLmZvcmNlVXBkYXRlKCl9fXNldENvbG9yVHJhbnNmb3JtKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC5zZXRDb2xvclRyYW5zZm9ybShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2V0RmlsbENvbG9yKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KGcpJiYoZz1bLi4uZ10sZ1swXS89MjU1LGdbMV0vPTI1NSxnWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldEZpbGxDb2xvcihmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2VwaWEoZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNlcGlhKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpmLGhlaWdodDpnfSl7c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6Z30pLHRoaXMubWVzaE5vZGUuc2V0UmVzb2x1dGlvbih7d2lkdGg6ZixoZWlnaHQ6Z30pfXNldFN0cm9rZUNvbG9yKGYsZyl7dGhpcy5tZXNoQ2xvdWQmJihBcnJheS5pc0FycmF5KGcpJiYoZz1bLi4uZ10sZ1swXS89MjU1LGdbMV0vPTI1NSxnWzJdLz0yNTUpLHRoaXMubWVzaENsb3VkLnNldFN0cm9rZUNvbG9yKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX1zZXRUcmFuc2Zvcm0oZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnNldFRyYW5zZm9ybShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9c2tldyhmLFtnLHY9Z10sW0MscF09WzAsMF0pe2lmKHRoaXMubWVzaENsb3VkKXtjb25zdHt4OmgseTptfT10aGlzLm1lc2hOb2RlLmF0dHJpYnV0ZXM7dGhpcy5tZXNoQ2xvdWQuc2tldyhmLFtnLHZdLFtDK2gscCttXSksdGhpcy5mb3JjZVVwZGF0ZSgpfX10cmFuc2Zvcm0oZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybShmLGcpLHRoaXMuZm9yY2VVcGRhdGUoKSl9dHJhbnNmb3JtQ29sb3IoZixnKXt0aGlzLm1lc2hDbG91ZCYmKHRoaXMubWVzaENsb3VkLnRyYW5zZm9ybUNvbG9yKGYsZyksdGhpcy5mb3JjZVVwZGF0ZSgpKX10cmFuc2xhdGUoZixbZyx2XSl7dGhpcy5tZXNoQ2xvdWQmJih0aGlzLm1lc2hDbG91ZC50cmFuc2xhdGUoZixbZyx2XSksdGhpcy5mb3JjZVVwZGF0ZSgpKX11cGRhdGVNZXNoKCl7dGhpc1t1XSYmKHRoaXNbdV0ubWVzaD10aGlzLm1lc2hOb2RlLm1lc2gsdGhpcy5mb3JjZVVwZGF0ZSgpKX19VC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShjLCJjbG91ZCIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJsb2FkVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gVH0pLHQuZChlLCJhcHBseVRleHR1cmUiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KSx0LmQoZSwiY3JlYXRlVGV4dHVyZSIsZnVuY3Rpb24oKXtyZXR1cm4gY30pLHQuZChlLCJkZWxldGVUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKGUsImRyYXdUZXh0dXJlIixmdW5jdGlvbigpe3JldHVybiBnfSksdC5kKGUsImxvYWRGcmFtZXMiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgYT10KDEyKSxsPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBNPXt9O2Z1bmN0aW9uIFQoQyxwKXtpZihNW0NdKXJldHVybiBNW0NdO2NvbnN0IGg9YS5FTlYubG9hZEltYWdlKEMse2FsaWFzOnAsdXNlSW1hZ2VCaXRtYXA6ITF9KTtyZXR1cm4gaD8/Q31hc3luYyBmdW5jdGlvbiBkKEMscCxoKXtsZXQgbT1wO2lmKHR5cGVvZiBwPT0ic3RyaW5nIiYmKG09VChwKSksbSYmdHlwZW9mIG0udGhlbj09ImZ1bmN0aW9uIiYmKG09YXdhaXQgbSkscD09PUMuYXR0cmlidXRlcy50ZXh0dXJlKXttJiZtLmltYWdlJiYobS5zb3VyY2VSZWN0JiYoQy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q9bS5zb3VyY2VSZWN0KSxDLnRleHR1cmVJbWFnZVJvdGF0ZWQ9ISFtLnJvdGF0ZWQsbT1tLmltYWdlKTtjb25zdHt3aWR0aDpyLGhlaWdodDppLHRleHR1cmVSZWN0Om59PUMuYXR0cmlidXRlcyxzPUMudGV4dHVyZUltYWdlO0MudGV4dHVyZUltYWdlPW0saCYmcyE9PW0mJiFuJiYocj09bnVsbHx8aT09bnVsbCkmJkMudXBkYXRlQ29udG91cnMoKSxDLmZvcmNlVXBkYXRlKCl9cmV0dXJuIG19Y29uc3QgdT1TeW1ib2woInRleHR1cmVNYXAiKTtmdW5jdGlvbiBjKEMscCl7aWYocFt1XT1wW3VdfHxuZXcgTWFwLHBbdV0uaGFzKEMpKXJldHVybiBwW3VdLmdldChDKTtjb25zdCBoPXAuY3JlYXRlVGV4dHVyZShDKTtyZXR1cm4hL15ibG9iOi8udGVzdChDLnNyYykmJnR5cGVvZiBDLmdldENvbnRleHQhPSJmdW5jdGlvbiImJnBbdV0uc2V0KEMsaCksaH1mdW5jdGlvbiBPKEMscCl7aWYocFt1XSYmcFt1XS5oYXMoQykpe2NvbnN0IGg9cFt1XS5nZXQoQyk7cmV0dXJuIHAuZGVsZXRlVGV4dHVyZShoKSxwW3VdLmRlbGV0ZShDKSwhMH1yZXR1cm4hMX1jb25zdCBmPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKTtmdW5jdGlvbiBnKEMscCl7Y29uc3QgaD1DLnRleHR1cmVJbWFnZSBpbnN0YW5jZW9mIFN0cmluZz9TdHJpbmcoQy50ZXh0dXJlSW1hZ2UpOkMudGV4dHVyZUltYWdlLG09Qy50ZXh0dXJlSW1hZ2VSb3RhdGVkLHI9cC50ZXh0dXJlLGk9Qy5yZW5kZXJlcjtpZihoKXtjb25zdCBuPUMub3JpZ2luYWxDb250ZW50UmVjdDtsZXQgcz1DLmF0dHJpYnV0ZXMudGV4dHVyZVJlY3Q7Y29uc3QgeD1DLmF0dHJpYnV0ZXMudGV4dHVyZVJlcGVhdCxQPUMuYXR0cmlidXRlcy5zb3VyY2VSZWN0O2lmKCFyfHxDW2ZdJiZDW2ZdIT09aXx8ci5pbWFnZSE9PWh8fHIub3B0aW9ucy5yZXBlYXQhPT14fHwhT2JqZWN0KGwuY29tcGFyZVZhbHVlKShyLm9wdGlvbnMucmVjdCxzKXx8IU9iamVjdChsLmNvbXBhcmVWYWx1ZSkoci5vcHRpb25zLnNyY1JlY3QsUCkpe2NvbnN0IFI9YyhoLGkpO3M/KHNbMF0rPW5bMF0sc1sxXSs9blsxXSk6cz1uO2xldCBiPW51bGw7ciYmIWlbdV0uaGFzKHIuaW1hZ2UpJiYoIXIub3B0aW9uc3x8IXIub3B0aW9ucy5oaWRkZW4pJiYoYj1wLnVuaWZvcm1zLnVfdGV4U2FtcGxlcikscC5zZXRUZXh0dXJlKFIse3JlY3Q6cyxyZXBlYXQ6eCxzcmNSZWN0OlAscm90YXRlZDptfSksYiYmYi5kZWxldGUmJmIuZGVsZXRlKCksQ1tmXT1pfX1lbHNlIGlmKHIpe2xldCBuPW51bGw7IWlbdV0uaGFzKHIuaW1hZ2UpJiYoIXIub3B0aW9uc3x8IXIub3B0aW9ucy5oaWRkZW4pJiYobj1wLnVuaWZvcm1zLnVfdGV4U2FtcGxlcikscC5zZXRUZXh0dXJlKG51bGwpLG4mJm4uZGVsZXRlJiZuLmRlbGV0ZSgpfX1hc3luYyBmdW5jdGlvbiB2KEMscCl7dHlwZW9mIHA9PSJzdHJpbmciJiYocD1hd2FpdChhd2FpdCBmZXRjaChwLHttZXRob2Q6IkdFVCIsbW9kZToiY29ycyIsY2FjaGU6ImRlZmF1bHQifSkpLmpzb24oKSk7Y29uc3QgaD1hd2FpdCBUKEMpLG09cC5mcmFtZXM7cmV0dXJuIE9iamVjdC5lbnRyaWVzKG0pLmZvckVhY2goKFtyLGldKT0+e2NvbnN0e3g6bix5OnMsdzp4LGg6UH09aS5mcmFtZTtsZXQgUj1bbixzLHgsUF07Y29uc3QgYj1pLnJvdGF0ZWQ7YiYmKFI9W1JbMF0sUlsxXSxSWzNdLFJbMl1dKSxNW3JdPXtpbWFnZTpoLHNvdXJjZVJlY3Q6Uixyb3RhdGVkOmJ9fSksaH19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgYT10KDEpLGw9dCgxMiksTT10KDcwKSxUPXQoMjIwKSxkPXQoMjIxKSx1PXQoMjIyKSxjPXQoMjEzKSxPPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZihDLHAsaCl7cmV0dXJuIHAgaW4gQz9PYmplY3QuZGVmaW5lUHJvcGVydHkoQyxwLHt2YWx1ZTpoLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6Q1twXT1oLEN9Y29uc3QgZz1TeW1ib2woIm1lc2giKTtjbGFzcyB2IGV4dGVuZHMgTS5kZWZhdWx0e2NvbnN0cnVjdG9yKHA9e30pe3N1cGVyKHApfWdldCBib3JkZXJTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpwLHBhZGRpbmdSaWdodDpoLHBhZGRpbmdCb3R0b206bSxwYWRkaW5nTGVmdDpyLGJvcmRlcldpZHRoOml9PXRoaXMuYXR0cmlidXRlcyxbbixzXT10aGlzLmNvbnRlbnRTaXplO3JldHVybltyK24raCtpLHArcyttK2ldfWdldCBjbGllbnRTaXplKCl7Y29uc3R7cGFkZGluZ1RvcDpwLHBhZGRpbmdSaWdodDpoLHBhZGRpbmdCb3R0b206bSxwYWRkaW5nTGVmdDpyfT10aGlzLmF0dHJpYnV0ZXMsW2ksbl09dGhpcy5jb250ZW50U2l6ZTtyZXR1cm5bcitpK2gscCtuK21dfWdldCBjb250ZW50U2l6ZSgpe2xldHt3aWR0aDpwLGhlaWdodDpoLGJveFNpemluZzptLHBhZGRpbmdUb3A6cixwYWRkaW5nUmlnaHQ6aSxwYWRkaW5nQm90dG9tOm4scGFkZGluZ0xlZnQ6c309dGhpcy5hdHRyaWJ1dGVzO2lmKHA9cHx8MCxoPWh8fDAsbT09PSJib3JkZXItYm94Iil7Y29uc3QgeD0yKnRoaXMuYXR0cmlidXRlcy5ib3JkZXJXaWR0aDtwLT14K2krcyxoLT14K3IrbixwPU1hdGgubWF4KDAscCksaD1NYXRoLm1heCgwLGgpfXJldHVybltwLGhdfWdldCBoYXNCb3JkZXIoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmJvcmRlcldpZHRoPjB9Z2V0IGlzVmlzaWJsZSgpe2NvbnN0W3AsaF09dGhpcy5ib3JkZXJTaXplO3JldHVybiBwPjAmJmg+MH1nZXQgbWVzaCgpe2lmKHRoaXMuYXR0cmlidXRlcy5kaXNwbGF5PT09Im5vbmUiKXJldHVybiBudWxsO2NvbnN0IHA9dGhpcy5jbGllbnRCb3g7aWYocCl7bGV0IGg9dGhpc1tnXTtpZihoKWguYm94IT09cCYmKGguY29udG91cnM9cC5jb250b3VycyxoLmJveD1wKTtlbHNle2g9bmV3IGwuTWVzaDJEKHApLGguYm94PXA7Y29uc3Qgcj10aGlzLmF0dHJpYnV0ZXMuYmdjb2xvcjtpZihPYmplY3QoZC5zZXRGaWxsQ29sb3IpKGgse2NvbG9yOnJ9KSx0aGlzLmhhc0JvcmRlcil7Y29uc3R7Ym9yZGVyQ29sb3I6bixib3JkZXJXaWR0aDpzLGJvcmRlckRhc2g6eCxib3JkZXJEYXNoT2Zmc2V0OlB9PXRoaXMuYXR0cmlidXRlcztPYmplY3QoZC5zZXRTdHJva2VDb2xvcikoaCx7Y29sb3I6bixsaW5lV2lkdGg6cyxsaW5lRGFzaDp4LGxpbmVEYXNoT2Zmc2V0OlB9KX10aGlzW2ddPWg7Y29uc3QgaT10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7aSYmdGhpc1tnXS5zZXRDbGlwUGF0aChpKX1jb25zdCBtPXRoaXMub3BhY2l0eTtyZXR1cm4gaC5nZXRPcGFjaXR5KCkhPT1tJiZoLnNldE9wYWNpdHkobSksaC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLGh9cmV0dXJuIG51bGx9Z2V0IG9mZnNldFNpemUoKXtjb25zdHtwYWRkaW5nVG9wOnAscGFkZGluZ1JpZ2h0OmgscGFkZGluZ0JvdHRvbTptLHBhZGRpbmdMZWZ0OnIsYm9yZGVyV2lkdGg6aX09dGhpcy5hdHRyaWJ1dGVzLFtuLHNdPXRoaXMuY29udGVudFNpemUseD0yKmk7cmV0dXJuW3IrbitoK3gscCtzK20reF19Z2V0IG9yaWdpbmFsQ2xpZW50UmVjdCgpe2lmKHRoaXMubWVzaCl7Y29uc3QgcD10aGlzLm1lc2guYm91bmRpbmdCb3g7cmV0dXJuW3BbMF1bMF0scFswXVsxXSxwWzFdWzBdLXBbMF1bMF0scFsxXVsxXS1wWzBdWzFdXX1yZXR1cm5bMCwwLDAsMF19Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtjb25zdFtwLGgsbSxyXT10aGlzLm9yaWdpbmFsQ2xpZW50UmVjdCxpPXRoaXMuYXR0cmlidXRlcy5wYWRkaW5nO3JldHVybltwK2lbMF0saCtpWzFdLG0taVswXS1pWzJdLHItaVsxXS1pWzNdXX1nZXRCb3VuZGluZ0NsaWVudFJlY3QoKXtsZXQgcD10aGlzLnJlbmRlck1hdHJpeDt0aGlzLmxheWVyJiZ0aGlzLmxheWVyLmxheWVyVHJhbnNmb3JtSW52ZXJ0JiYocD1hLm1hdDJkLm11bHRpcGx5KEFycmF5Lm9mKDAsMCwwLDAsMCwwKSx0aGlzLmxheWVyLnRyYW5zZm9ybU1hdHJpeCxwKSk7bGV0IGg9bnVsbDtpZih0aGlzLm1lc2gpe2g9Wy4uLnRoaXMubWVzaC5ib3VuZGluZ0JveF07Y29uc3QgbT10aGlzLmF0dHJpYnV0ZXMuYm9yZGVyV2lkdGg7bSYmKGhbMF09W2hbMF1bMF0tbSxoWzBdWzFdLW1dLGhbMV09W2hbMV1bMF0rbSxoWzFdWzFdK21dKX1yZXR1cm4gT2JqZWN0KE8uZGVmYXVsdCkoaCxwKX1vblByb3BlcnR5Q2hhbmdlKHAsaCxtKXtpZihzdXBlci5vblByb3BlcnR5Q2hhbmdlKHAsaCxtKSwocD09PSJhbmNob3JYInx8cD09PSJhbmNob3JZInx8cD09PSJib3hTaXppbmcifHxwPT09IndpZHRoInx8cD09PSJoZWlnaHQifHxwPT09ImJvcmRlcldpZHRoInx8cD09PSJwYWRkaW5nTGVmdCJ8fHA9PT0icGFkZGluZ1JpZ2h0Inx8cD09PSJwYWRkaW5nVG9wInx8cD09PSJwYWRkaW5nQm90dG9tInx8L15ib3JkZXIoVG9wTGVmdHxUb3BSaWdodHxCb3R0b21SaWdodHxCb3R0b21MZWZ0KVJhZGl1cyQvLnRlc3QocCkpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1tnXSYmcD09PSJjbGlwUGF0aCImJnRoaXNbZ10uc2V0Q2xpcFBhdGgoaCksdGhpc1tnXSYmcD09PSJiZ2NvbG9yIiYmT2JqZWN0KGQuc2V0RmlsbENvbG9yKSh0aGlzW2ddLHtjb2xvcjpofSksdGhpc1tnXSYmKHA9PT0iYm9yZGVyQ29sb3IifHxwPT09ImJvcmRlcldpZHRoInx8cD09PSJib3JkZXJEYXNoInx8cD09PSJib3JkZXJEYXNoT2Zmc2V0Iikpe2NvbnN0e2JvcmRlckNvbG9yOnIsYm9yZGVyV2lkdGg6aSxib3JkZXJEYXNoOm4sYm9yZGVyRGFzaE9mZnNldDpzfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KGQuc2V0U3Ryb2tlQ29sb3IpKHRoaXNbZ10se2NvbG9yOnIsbGluZVdpZHRoOmksbGluZURhc2g6aT9uOjAsbGluZURhc2hPZmZzZXQ6c30pfX11cGRhdGVDb250b3Vycygpe2NvbnN0e2FuY2hvclg6cCxhbmNob3JZOmgsYm9yZGVyV2lkdGg6bSxib3JkZXJSYWRpdXM6cn09dGhpcy5hdHRyaWJ1dGVzLFtpLG5dPXRoaXMuYm9yZGVyU2l6ZSxzPXRoaXMub2Zmc2V0U2l6ZSx4PS41Km0sUD0tcCpzWzBdK3gsUj0taCpzWzFdK3g7dGhpcy5jbGllbnRCb3g9bmV3IGwuRmlndXJlMkQsT2JqZWN0KHUuY3JlYXRlUmFkaXVzQm94KSh0aGlzLmNsaWVudEJveCxbUCxSLGksbl0scil9fWYodiwiQXR0ciIsVC5kZWZhdWx0KSxjLmRlZmF1bHQucmVnaXN0ZXJOb2RlKHYsImJsb2NrIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgYT10KDcxKSxsPXQoNzIpLE09dCgyMjEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtjbGFzcyBPIGV4dGVuZHMgYS5kZWZhdWx0e2NvbnN0cnVjdG9yKGcpe3N1cGVyKGcpLHRoaXNbdV0oe2FuY2hvclg6MCxhbmNob3JZOjAsd2lkdGg6dm9pZCAwLGhlaWdodDp2b2lkIDAsYm9yZGVyV2lkdGg6MCxib3JkZXJDb2xvcjoicmdiYSgwLDAsMCwxKSIsYm9yZGVyRGFzaDp2b2lkIDAsYm9yZGVyRGFzaE9mZnNldDowLGJvcmRlclRvcExlZnRSYWRpdXM6WzAsMF0sYm9yZGVyVG9wUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6WzAsMF0sYm9yZGVyQm90dG9tTGVmdFJhZGl1czpbMCwwXSxiZ2NvbG9yOiJyZ2JhKDAsMCwwLDApIixwYWRkaW5nVG9wOjAscGFkZGluZ1JpZ2h0OjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsY2xpcFBhdGg6dm9pZCAwfSksdGhpc1tjXSgiYW5jaG9yIiwic2l6ZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciKX1nZXQgYW5jaG9yWCgpe3JldHVybiB0aGlzW2RdKCJhbmNob3JYIil9c2V0IGFuY2hvclgoZyl7dGhpc1tUXSgiYW5jaG9yWCIsT2JqZWN0KGwudG9OdW1iZXIpKGcpKX1nZXQgYW5jaG9yWSgpe3JldHVybiB0aGlzW2RdKCJhbmNob3JZIil9c2V0IGFuY2hvclkoZyl7dGhpc1tUXSgiYW5jaG9yWSIsT2JqZWN0KGwudG9OdW1iZXIpKGcpKX1nZXQgYW5jaG9yKCl7cmV0dXJuW3RoaXMuYW5jaG9yWCx0aGlzLmFuY2hvclldfXNldCBhbmNob3IoZyl7Zz1PYmplY3QobC50b0FycmF5KShnKSxBcnJheS5pc0FycmF5KGcpfHwoZz1bZyxnXSksdGhpcy5hbmNob3JYPWdbMF0sdGhpcy5hbmNob3JZPWdbMV19Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbZF0oIndpZHRoIil9c2V0IHdpZHRoKGcpe3RoaXNbVF0oIndpZHRoIixPYmplY3QobC50b051bWJlcikoZykpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpc1tkXSgiaGVpZ2h0Iil9c2V0IGhlaWdodChnKXt0aGlzW1RdKCJoZWlnaHQiLE9iamVjdChsLnRvTnVtYmVyKShnKSl9Z2V0IHNpemUoKXtyZXR1cm5bdGhpcy53aWR0aCx0aGlzLmhlaWdodF19c2V0IHNpemUoZyl7Zz1PYmplY3QobC50b0FycmF5KShnKSxBcnJheS5pc0FycmF5KGcpfHwoZz1bZyxnXSksdGhpcy53aWR0aD1nWzBdLHRoaXMuaGVpZ2h0PWdbMV19Z2V0IGJvcmRlcldpZHRoKCl7cmV0dXJuIHRoaXNbZF0oImJvcmRlcldpZHRoIil9c2V0IGJvcmRlcldpZHRoKGcpe3RoaXNbVF0oImJvcmRlcldpZHRoIixPYmplY3QobC50b051bWJlcikoZykpfWdldCBib3JkZXJDb2xvcigpe3JldHVybiB0aGlzW2RdKCJib3JkZXJDb2xvciIpfXNldCBib3JkZXJDb2xvcihnKXt0aGlzW1RdKCJib3JkZXJDb2xvciIsT2JqZWN0KE0ucGFyc2VDb2xvcikoZykpfWdldCBib3JkZXIoKXtyZXR1cm5bdGhpcy5ib3JkZXJXaWR0aCx0aGlzLmJvcmRlckNvbG9yXX1zZXQgYm9yZGVyKGcpe2c9T2JqZWN0KGwudG9BcnJheSkoZyksQXJyYXkuaXNBcnJheShnKXx8KGc9W2ddKSx0aGlzLmJvcmRlcldpZHRoPWdbMF0sZ1sxXSE9bnVsbCYmKHRoaXMuYm9yZGVyQ29sb3I9Z1sxXSl9Z2V0IGJvcmRlckRhc2goKXtyZXR1cm4gdGhpc1tkXSgiYm9yZGVyRGFzaCIpfXNldCBib3JkZXJEYXNoKGcpe2c9T2JqZWN0KGwudG9BcnJheSkoZywhMCksZyE9bnVsbCYmIUFycmF5LmlzQXJyYXkoZykmJihnPVtnXSksdGhpc1tUXSgiYm9yZGVyRGFzaCIsZz9nLm1hcChsLnRvTnVtYmVyKTpudWxsKX1nZXQgYm9yZGVyRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW2RdKCJib3JkZXJEYXNoT2Zmc2V0Iil9c2V0IGJvcmRlckRhc2hPZmZzZXQoZyl7dGhpc1tUXSgiYm9yZGVyRGFzaE9mZnNldCIsT2JqZWN0KGwudG9OdW1iZXIpKGcpKX1nZXQgYm9yZGVyVG9wTGVmdFJhZGl1cygpe3JldHVybiB0aGlzW2RdKCJib3JkZXJUb3BMZWZ0UmFkaXVzIil9c2V0IGJvcmRlclRvcExlZnRSYWRpdXMoZyl7Zz1PYmplY3QobC50b0FycmF5KShnLCEwKSxBcnJheS5pc0FycmF5KGcpfHwoZz1bZyxnXSksdGhpc1tUXSgiYm9yZGVyVG9wTGVmdFJhZGl1cyIsZy5tYXAobC50b051bWJlcikpfWdldCBib3JkZXJUb3BSaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2RdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIpfXNldCBib3JkZXJUb3BSaWdodFJhZGl1cyhnKXtnPU9iamVjdChsLnRvQXJyYXkpKGcsITApLEFycmF5LmlzQXJyYXkoZyl8fChnPVtnLGddKSx0aGlzW1RdKCJib3JkZXJUb3BSaWdodFJhZGl1cyIsZy5tYXAobC50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cygpe3JldHVybiB0aGlzW2RdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIpfXNldCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyhnKXtnPU9iamVjdChsLnRvQXJyYXkpKGcsITApLEFycmF5LmlzQXJyYXkoZyl8fChnPVtnLGddKSx0aGlzW1RdKCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIsZy5tYXAobC50b051bWJlcikpfWdldCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzKCl7cmV0dXJuIHRoaXNbZF0oImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiKX1zZXQgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyhnKXtnPU9iamVjdChsLnRvQXJyYXkpKGcsITApLEFycmF5LmlzQXJyYXkoZyl8fChnPVtnLGddKSx0aGlzW1RdKCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzIixnLm1hcChsLnRvTnVtYmVyKSl9Z2V0IGJvcmRlclJhZGl1cygpe3JldHVyblsuLi50aGlzLmJvcmRlclRvcExlZnRSYWRpdXMsLi4udGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cywuLi50aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLC4uLnRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1c119c2V0IGJvcmRlclJhZGl1cyhnKXtpZihnPU9iamVjdChsLnRvQXJyYXkpKGcpLCFBcnJheS5pc0FycmF5KGcpKWc9QXJyYXkoOCkuZmlsbChnKTtlbHNlIGlmKGcubGVuZ3RoPT09MilnPVtnWzBdLGdbMV0sZ1swXSxnWzFdLGdbMF0sZ1sxXSxnWzBdLGdbMV1dO2Vsc2UgaWYoZy5sZW5ndGg9PT00KWc9W2dbMF0sZ1sxXSxnWzJdLGdbM10sZ1swXSxnWzFdLGdbMl0sZ1szXV07ZWxzZSBpZihnLmxlbmd0aD09PTYpZz1bZ1swXSxnWzFdLGdbMl0sZ1szXSxnWzRdLGdbNV0sZ1syXSxnWzNdXTtlbHNlIGlmKGcubGVuZ3RoIT09OCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGJvcmRlclJhZGl1cyB2YWx1ZS4iKTt0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9W2dbMF0sZ1sxXV0sdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cz1bZ1syXSxnWzNdXSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPVtnWzRdLGdbNV1dLHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1bZ1s2XSxnWzddXX1nZXQgYmdjb2xvcigpe3JldHVybiB0aGlzW2RdKCJiZ2NvbG9yIil9c2V0IGJnY29sb3IoZyl7dGhpc1tUXSgiYmdjb2xvciIsT2JqZWN0KE0ucGFyc2VDb2xvcikoZykpfWdldCBwYWRkaW5nVG9wKCl7cmV0dXJuIHRoaXNbZF0oInBhZGRpbmdUb3AiKX1zZXQgcGFkZGluZ1RvcChnKXt0aGlzW1RdKCJwYWRkaW5nVG9wIixPYmplY3QobC50b051bWJlcikoZykpfWdldCBwYWRkaW5nUmlnaHQoKXtyZXR1cm4gdGhpc1tkXSgicGFkZGluZ1JpZ2h0Iil9c2V0IHBhZGRpbmdSaWdodChnKXt0aGlzW1RdKCJwYWRkaW5nUmlnaHQiLE9iamVjdChsLnRvTnVtYmVyKShnKSl9Z2V0IHBhZGRpbmdCb3R0b20oKXtyZXR1cm4gdGhpc1tkXSgicGFkZGluZ0JvdHRvbSIpfXNldCBwYWRkaW5nQm90dG9tKGcpe3RoaXNbVF0oInBhZGRpbmdCb3R0b20iLE9iamVjdChsLnRvTnVtYmVyKShnKSl9Z2V0IHBhZGRpbmdMZWZ0KCl7cmV0dXJuIHRoaXNbZF0oInBhZGRpbmdMZWZ0Iil9c2V0IHBhZGRpbmdMZWZ0KGcpe3RoaXNbVF0oInBhZGRpbmdMZWZ0IixPYmplY3QobC50b051bWJlcikoZykpfWdldCBwYWRkaW5nKCl7cmV0dXJuW3RoaXMucGFkZGluZ1RvcCx0aGlzLnBhZGRpbmdSaWdodCx0aGlzLnBhZGRpbmdCb3R0b20sdGhpcy5wYWRkaW5nTGVmdF19c2V0IHBhZGRpbmcoZyl7Zz1PYmplY3QobC50b0FycmF5KShnKSxBcnJheS5pc0FycmF5KGcpP2cubGVuZ3RoPT09Mj9nPVtnWzBdLGdbMV0sZ1swXSxnWzFdXTpnLmxlbmd0aD09PTMmJihnPVtnWzBdLGdbMV0sZ1syXSxnWzFdXSk6Zz1bZyxnLGcsZ10sdGhpcy5wYWRkaW5nVG9wPWdbMF0sdGhpcy5wYWRkaW5nUmlnaHQ9Z1sxXSx0aGlzLnBhZGRpbmdCb3R0b209Z1syXSx0aGlzLnBhZGRpbmdMZWZ0PWdbM119Z2V0IGNsaXBQYXRoKCl7cmV0dXJuIHRoaXNbZF0oImNsaXBQYXRoIil9c2V0IGNsaXBQYXRoKGcpe3RoaXNbVF0oImNsaXBQYXRoIixnKX1nZXQgYm94U2l6aW5nKCl7cmV0dXJuIHRoaXNbZF0oImJveFNpemluZyIpfXNldCBib3hTaXppbmcoZyl7aWYoZyE9bnVsbCYmZyE9PSJib3JkZXItYm94IiYmZyE9PSJjb250ZW50LWJveCIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBib3hTaXppbmcgdHlwZS4iKTt0aGlzW1RdKCJib3hTaXppbmciLGcpfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsIkdyYWRpZW50IixmdW5jdGlvbigpe3JldHVybiBNfSksdC5kKGUsImlzVHJhbnNwYXJlbnQiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQoZSwicGFyc2VDb2xvciIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pLHQuZChlLCJzZXRGaWxsQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSx0LmQoZSwic2V0U3Ryb2tlQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KSx0LmQoZSwiQ29sb3IiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KTt2YXIgYT10KDMyKSxsPXQubihhKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgTXtjb25zdHJ1Y3Rvcih7dmVjdG9yOnYsY29sb3JzOkN9KXtpZighQXJyYXkuaXNBcnJheSh2KXx8di5sZW5ndGghPT00JiZ2Lmxlbmd0aCE9PTYmJnYubGVuZ3RoIT09Myl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGdyYWRpZW50Iik7dGhpcy52ZWN0b3I9dix0aGlzLmNvbG9ycz1DLm1hcCgoe29mZnNldDpwLGNvbG9yOmh9KT0+KHtvZmZzZXQ6cCxjb2xvcjpkKGgpfSkpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHt2ZWN0b3I6dGhpcy52ZWN0b3IsY29sb3JzOnRoaXMuY29sb3JzfSl9fWZ1bmN0aW9uIFQoZyl7cmV0dXJuIGcgaW5zdGFuY2VvZiBNPyExOmc9PW51bGw/ITA6bCgpKGcpWzNdPT09MH1mdW5jdGlvbiBkKGcpe2lmKGc9PW51bGx8fChnfHwoZz0idHJhbnNwYXJlbnQiKSxnIGluc3RhbmNlb2YgTSkpcmV0dXJuIGc7Y29uc3Qgdj1sKCkoZyk7aWYoIXZ8fCF2Lmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNvbG9yIHZhbHVlLiIpO3JldHVybmByZ2JhKCR7di5qb2luKCl9KWB9ZnVuY3Rpb24gdShnLHYsQyl7Y29uc3QgcD1nLmJvdW5kaW5nQm94WzBdO2lmKEMudmVjdG9yKXtsZXR7dmVjdG9yOmgsY29sb3JzOm19PUM7aC5sZW5ndGg9PT00PyhoPVtoWzBdK3BbMF0saFsxXStwWzFdLGhbMl0rcFswXSxoWzNdK3BbMV1dLGcuc2V0TGluZWFyR3JhZGllbnQoe3ZlY3RvcjpoLGNvbG9yczptLHR5cGU6dn0pKTpoLmxlbmd0aD09PTM/KGg9W2hbMF0rcFswXSxoWzFdK3BbMV0saFsyXV0sZy5zZXRDaXJjdWxhckdyYWRpZW50KHt2ZWN0b3I6aCxjb2xvcnM6bSx0eXBlOnZ9KSk6KGg9W2hbMF0rcFswXSxoWzFdK3BbMV0saFsyXSxoWzNdK3BbMF0saFs0XStwWzFdLGhbNV1dLGcuc2V0UmFkaWFsR3JhZGllbnQoe3ZlY3RvcjpoLGNvbG9yczptLHR5cGU6dn0pKX1lbHNlIGcuZ3JhZGllbnQmJmcuZ3JhZGllbnRbdl0mJihkZWxldGUgZy5ncmFkaWVudFt2XSxkZWxldGUgZy51bmlmb3Jtcy51X3JhZGlhbEdyYWRpZW50VmVjdG9yKX1mdW5jdGlvbiBjKGcse2NvbG9yOnYscnVsZTpDPSJub256ZXJvIn0pe3JldHVybiB1KGcsImZpbGwiLHYpLHYudmVjdG9yfHxnLnNldEZpbGwoe2NvbG9yOnYscnVsZTpDfSksZ31mdW5jdGlvbiBPKGcse2NvbG9yOnYsbGluZVdpZHRoOkMsbGluZUNhcDpwLGxpbmVKb2luOmgsbGluZURhc2g6bSxsaW5lRGFzaE9mZnNldDpyLG1pdGVyTGltaXQ6aSxyb3VuZFNlZ21lbnRzOm59KXt1KGcsInN0cm9rZSIsdiksdi52ZWN0b3ImJih2PVswLDAsMCwxXSksZy5zZXRTdHJva2Uoe2NvbG9yOnYsdGhpY2tuZXNzOkMsY2FwOnAsam9pbjpoLG1pdGVyTGltaXQ6aSxsaW5lRGFzaDptLGxpbmVEYXNoT2Zmc2V0OnIscm91bmRTZWdtZW50czpufSl9Y2xhc3MgZiBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKHY9MCxDPTAscD0wLGg9MCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodikmJihbdixDLHAsaF09diksdHlwZW9mIHY9PSJzdHJpbmciJiYoW3YsQyxwLGhdPWwoKSh2KSx2Lz0yNTUsQy89MjU1LHAvPTI1NSksc3VwZXIodixDLHAsaCksdGhpc31nZXQgcigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXNbMF0qMjU1KX1zZXQgcih2KXt0aGlzWzBdPXYvMjU1fWdldCBnKCl7cmV0dXJuIE1hdGgucm91bmQodGhpc1sxXSoyNTUpfXNldCBnKHYpe3RoaXNbMV09di8yNTV9Z2V0IGIoKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzWzJdKjI1NSl9c2V0IGIodil7dGhpc1syXT12LzI1NX1nZXQgYSgpe3JldHVybiB0aGlzWzNdfXNldCBhKHYpe3RoaXNbM109dn1nZXQgaGV4KCl7Y29uc3Qgdj1gMCR7dGhpcy5yLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxDPWAwJHt0aGlzLmcudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpLHA9YDAke3RoaXMuYi50b1N0cmluZygxNil9YC5zbGljZSgtMik7bGV0IGg7cmV0dXJuIHRoaXMuYTwxJiYoaD1NYXRoLnJvdW5kKHRoaXNbM10qMjU1KSxoPWAwJHtoLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSksYCMke3Z9JHtDfSR7cH0ke2h8fCIifWB9Z2V0IHJnYmEoKXtyZXR1cm5gcmdiYSgke3RoaXMucn0sJHt0aGlzLmd9LCR7dGhpcy5ifSwke3RoaXMuYX0pYH1mcm9tQ29sb3Iodil7cmV0dXJuIHR5cGVvZiB2PT0ic3RyaW5nIiYmKHY9bCgpKHYpLHZbMF0vPTI1NSx2WzFdLz0yNTUsdlsyXS89MjU1KSx0aGlzWzBdPXZbMF0sdGhpc1sxXT12WzFdLHRoaXNbMl09dlsyXSx0aGlzWzNdPXZbM10sdGhpc319fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJjcmVhdGVSYWRpdXNCb3giLGZ1bmN0aW9uKCl7cmV0dXJuIGx9KSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gYShNLFQsZCx1LGMsTz0ibGVmdFRvcCIpe2NvbnN0IGY9LjU1MjI4NDgsZz11LzIqZix2PWMvMipmLEM9VCt1LHA9ZCtjLGg9VCt1LzIsbT1kK2MvMjtPPT09ImxlZnRUb3AiPyhNLm1vdmVUbyhULG0pLE0uYmV6aWVyQ3VydmVUbyhULG0tdixoLWcsZCxoLGQpKTpPPT09InJpZ2h0VG9wIj9NLmJlemllckN1cnZlVG8oaCtnLGQsQyxtLXYsQyxtKTpPPT09InJpZ2h0Qm90dG9tIj9NLmJlemllckN1cnZlVG8oQyxtK3YsaCtnLHAsaCxwKTpPPT09ImxlZnRCb3R0b20iJiZNLmJlemllckN1cnZlVG8oaC1nLHAsVCxtK3YsVCxtKX1mdW5jdGlvbiBsKE0sW1QsZCx1LGNdLE8pe2lmKCFPfHxBcnJheS5pc0FycmF5KE8pJiZPLmV2ZXJ5KGY9PmY9PT0wKSlNLmJlZ2luUGF0aCgpLE0ucmVjdChULGQsdSxjKTtlbHNle3R5cGVvZiBPPT0ibnVtYmVyIiYmKE89QXJyYXkoOCkuZmlsbChPKSk7Y29uc3RbZixnLHYsQyxwLGgsbSxyXT1PLm1hcCgoaSxuKT0+biUyP01hdGgubWluKGksYy8yKTpNYXRoLm1pbihpLHUvMikpO00uYmVnaW5QYXRoKCksTS5tb3ZlVG8oVCxkK2cpLGEoTSxULGQsZioyLGcqMiwibGVmdFRvcCIpLE0ubGluZVRvKFQrdS12LGQpLGEoTSxUK3UtdioyLGQsdioyLEMqMiwicmlnaHRUb3AiKSxNLmxpbmVUbyhUK3UsZCtjLWgpLGEoTSxUK3UtcCoyLGQrYy1oKjIscCoyLGgqMiwicmlnaHRCb3R0b20iKSxNLmxpbmVUbyhUK20sZCtjKSxhKE0sVCxkK2MtcioyLG0qMixyKjIsImxlZnRCb3R0b20iKSxNLmNsb3NlUGF0aCgpfXJldHVybiBNfX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSksZS5kZWZhdWx0PWZ1bmN0aW9uKGEsbCl7aWYoIWEpcmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjAscmlnaHQ6MCxib3R0b206MH07Y29uc3RbW00sVF0sW2QsdV1dPWEsYz1NKmxbMF0rVCpsWzJdK2xbNF0sTz1NKmxbMV0rVCpsWzNdK2xbNV0sZj1kKmxbMF0rVCpsWzJdK2xbNF0sZz1kKmxbMV0rVCpsWzNdK2xbNV0sdj1kKmxbMF0rdSpsWzJdK2xbNF0sQz1kKmxbMV0rdSpsWzNdK2xbNV0scD1NKmxbMF0rdSpsWzJdK2xbNF0saD1NKmxbMV0rdSpsWzNdK2xbNV0sbT1NYXRoLm1pbihjLGYsdixwKSxyPU1hdGgubWluKE8sZyxDLGgpLGk9TWF0aC5tYXgoYyxmLHYscCksbj1NYXRoLm1heChPLGcsQyxoKTtyZXR1cm57eDptLHk6cix3aWR0aDppLW0saGVpZ2h0Om4tcixsZWZ0Om0sdG9wOnIscmlnaHQ6aSxib3R0b206bn19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCgyMTgpLGw9dCgyMTkpLE09dCgyMjUpLFQ9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBkKE8sZixnKXtyZXR1cm4gZiBpbiBPP09iamVjdC5kZWZpbmVQcm9wZXJ0eShPLGYse3ZhbHVlOmcsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpPW2ZdPWcsT31jb25zdCB1PVN5bWJvbCgidGV4dHVyZVRhc2siKTtjbGFzcyBjIGV4dGVuZHMgbC5kZWZhdWx0e2NvbnN0cnVjdG9yKGY9e30pe3R5cGVvZiBmPT0ic3RyaW5nIiYmKGY9e3RleHR1cmU6Zn0pLHN1cGVyKGYpfWdldCBjb250ZW50U2l6ZSgpe2xldFtmLGddPXN1cGVyLmNvbnRlbnRTaXplO2NvbnN0e3dpZHRoOnYsaGVpZ2h0OkN9PXRoaXMuYXR0cmlidXRlcztpZih2PT1udWxsfHxDPT1udWxsKXtjb25zdCBwPXRoaXMudGV4dHVyZUltYWdlLGg9dGhpcy5hdHRyaWJ1dGVzLnRleHR1cmVSZWN0LG09dGhpcy5hdHRyaWJ1dGVzLnNvdXJjZVJlY3Q7aWYoaCl2PT1udWxsJiYoZj1oWzBdK2hbMl0pLEM9PW51bGwmJihnPWhbMV0raFszXSk7ZWxzZSBpZihtKXtjb25zdCByPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt2PT1udWxsJiYoZj1tWzJdL3IpLEM9PW51bGwmJihnPW1bM10vcil9ZWxzZSBpZihwKXtjb25zdCByPXRoaXMubGF5ZXI/dGhpcy5sYXllci5kaXNwbGF5UmF0aW86MTt2PT1udWxsJiYoZj1wLndpZHRoL3IpLEM9PW51bGwmJihnPXAuaGVpZ2h0L3IpfX1yZXR1cm5bZixnXX1nZXQgdGV4dHVyZUltYWdlUmVhZHkoKXtyZXR1cm4gdGhpc1t1XXx8UHJvbWlzZS5yZXNvbHZlKCl9ZHJhdyhmPVtdKXtzdXBlci5kcmF3KGYpO2NvbnN0IGc9dGhpcy5tZXNoO3JldHVybiBnJiZPYmplY3QoYS5kcmF3VGV4dHVyZSkodGhpcyxnKSxmfW9uUHJvcGVydHlDaGFuZ2UoZixnLHYpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoZixnLHYpLGY9PT0idGV4dHVyZSImJih0aGlzW3VdPU9iamVjdChhLmFwcGx5VGV4dHVyZSkodGhpcyxnLCEwKSksZj09PSJ0ZXh0dXJlUmVjdCIpe2NvbnN0e3dpZHRoOkMsaGVpZ2h0OnB9PXRoaXMuYXR0cmlidXRlczsoQz09bnVsbHx8cD09bnVsbCkmJnRoaXMudXBkYXRlQ29udG91cnMoKX19fWQoYywiQXR0ciIsTS5kZWZhdWx0KSxULmRlZmF1bHQucmVnaXN0ZXJOb2RlKGMsInNwcml0ZSIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGE9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBsPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxNPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLFQ9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIik7Y2xhc3MgZCBleHRlbmRzIGEuZGVmYXVsdHtjb25zdHJ1Y3RvcihjKXtzdXBlcihjKSx0aGlzW2xdKHt0ZXh0dXJlOnZvaWQgMCx0ZXh0dXJlUmVjdDp2b2lkIDAsdGV4dHVyZVJlcGVhdDohMSxzb3VyY2VSZWN0OnZvaWQgMH0pfWdldCB0ZXh0dXJlKCl7cmV0dXJuIHRoaXNbVF0oInRleHR1cmUiKX1zZXQgdGV4dHVyZShjKXt0aGlzW01dKCJ0ZXh0dXJlIixjKX1nZXQgdGV4dHVyZVJlY3QoKXtyZXR1cm4gdGhpc1tUXSgidGV4dHVyZVJlY3QiKX1zZXQgdGV4dHVyZVJlY3QoYyl7dGhpc1tNXSgidGV4dHVyZVJlY3QiLGMpfWdldCBzb3VyY2VSZWN0KCl7cmV0dXJuIHRoaXNbVF0oInNvdXJjZVJlY3QiKX1zZXQgc291cmNlUmVjdChjKXt0aGlzW01dKCJzb3VyY2VSZWN0IixjKX1nZXQgdGV4dHVyZVJlcGVhdCgpe3JldHVybiB0aGlzW1RdKCJ0ZXh0dXJlUmVwZWF0Iil9c2V0IHRleHR1cmVSZXBlYXQoYyl7dGhpc1tNXSgidGV4dHVyZVJlcGVhdCIsISFjKX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBDfSk7dmFyIGE9dCgxMiksbD10KDIyNyksTT10Lm4obCksVD10KDcwKSxkPXQoMjI4KSx1PXQoMjIxKSxjPXQoMjE4KSxPPXQoMjEzKSxmPXQoMjIzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gZyhwLGgsbSl7cmV0dXJuIGggaW4gcD9PYmplY3QuZGVmaW5lUHJvcGVydHkocCxoLHt2YWx1ZTptLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6cFtoXT1tLHB9Y29uc3Qgdj1TeW1ib2woIm1lc2giKTtjbGFzcyBDIGV4dGVuZHMgVC5kZWZhdWx0e2NvbnN0cnVjdG9yKGg9e30pe3R5cGVvZiBoPT0ic3RyaW5nIiYmKGg9e2Q6aH0pLHN1cGVyKGgpLHRoaXMuZWZmZWN0cz17ZChtLHIsaSxuLHMpe2NvbnN0IHg9KGktbikvKHMtbik7aWYoeDw9MClyZXR1cm4gbTtpZih4Pj0xKXJldHVybiByO2NvbnN0IFA9TS5hLl9wcmVwcm9jZXNzaW5nKE0uYS5wYXRoMnNoYXBlcyhtKSxNLmEucGF0aDJzaGFwZXMocikpLFI9TS5hLl9sZXJwKC4uLlAseClbMF07cmV0dXJuIFIucmVkdWNlKChFLEQpPT5gJHtFfSR7RC5zbGljZSgyKS5qb2luKCIgIil9IGAsYE0ke1JbMF1bMF19ICR7UlswXVsxXX1DYCkudHJpbSgpfX19Z2V0IGlzVmlzaWJsZSgpe3JldHVybiEhdGhpcy5kfWdldCBtZXNoKCl7aWYodGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXk9PT0ibm9uZSIpcmV0dXJuIG51bGw7Y29uc3QgaD10aGlzLnBhdGg7aWYoaCl7bGV0IG09dGhpc1t2XTtpZihtKW0ucGF0aCE9PWgmJihtLmNvbnRvdXJzPWguY29udG91cnMsbS5wYXRoPWgpO2Vsc2V7bT1uZXcgYS5NZXNoMkQodGhpcy5wYXRoKSxtLnBhdGg9aDtjb25zdCBpPXRoaXMuYXR0cmlidXRlcy5maWxsQ29sb3Isbj10aGlzLmF0dHJpYnV0ZXMuZmlsbFJ1bGU7aSYmT2JqZWN0KHUuc2V0RmlsbENvbG9yKShtLHtjb2xvcjppLHJ1bGU6bn0pO2NvbnN0IHM9dGhpcy5hdHRyaWJ1dGVzLmxpbmVXaWR0aCx4PXRoaXMuYXR0cmlidXRlcy5zdHJva2VDb2xvcjtpZih4JiZzPjApe2NvbnN0e2xpbmVDYXA6UixsaW5lSm9pbjpiLG1pdGVyTGltaXQ6RSxsaW5lRGFzaDpELGxpbmVEYXNoT2Zmc2V0Okkscm91bmRTZWdtZW50czpTfT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHUuc2V0U3Ryb2tlQ29sb3IpKG0se2NvbG9yOngsbGluZVdpZHRoOnMsbGluZUNhcDpSLGxpbmVKb2luOmIsbWl0ZXJMaW1pdDpFLGxpbmVEYXNoOkQsbGluZURhc2hPZmZzZXQ6SSxyb3VuZFNlZ21lbnRzOlN9KX10aGlzW3ZdPW07Y29uc3QgUD10aGlzLmF0dHJpYnV0ZXMuY2xpcFBhdGg7UCYmdGhpc1t2XS5zZXRDbGlwUGF0aChQKX1jb25zdCByPXRoaXMub3BhY2l0eTtyZXR1cm4gbS5nZXRPcGFjaXR5KCkhPT1yJiZtLnNldE9wYWNpdHkociksbS5zZXRUcmFuc2Zvcm0oLi4udGhpcy5yZW5kZXJNYXRyaXgpLG19cmV0dXJuIG51bGx9Z2V0IG9yaWdpbmFsQ29udGVudFJlY3QoKXtpZih0aGlzLnBhdGgpe2NvbnN0IGg9dGhpcy5wYXRoLmJvdW5kaW5nQm94O3JldHVybltoWzBdWzBdLGhbMF1bMV0saFsxXVswXS1oWzBdWzBdLGhbMV1bMV0taFswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudFJlY3QoKXtpZih0aGlzLm1lc2gpe2NvbnN0IGg9dGhpcy5tZXNoLmJvdW5kaW5nQm94O3JldHVybltoWzBdWzBdLGhbMF1bMV0saFsxXVswXS1oWzBdWzBdLGhbMV1bMV0taFswXVsxXV19cmV0dXJuWzAsMCwwLDBdfWdldCBvcmlnaW5hbENsaWVudENlbnRlcigpe3JldHVybiB0aGlzLm1lc2g/dGhpcy5tZXNoLmJvdW5kaW5nQ2VudGVyOlswLDBdfXNldCBkKGgpe3RoaXMuYXR0cmlidXRlcy5kPWh9Z2V0IGQoKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmR9ZHJhdyhoPVtdKXtzdXBlci5kcmF3KGgpO2NvbnN0IG09dGhpcy5tZXNoO3JldHVybiBtJiZPYmplY3QoYy5kcmF3VGV4dHVyZSkodGhpcyxtKSxofWdldEJvdW5kaW5nQ2xpZW50UmVjdCgpe2xldCBoPW51bGw7cmV0dXJuIHRoaXMubWVzaCYmKGg9dGhpcy5tZXNoLmJvdW5kaW5nQm94KSxPYmplY3QoZi5kZWZhdWx0KShoLHRoaXMucmVuZGVyTWF0cml4KX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuIHRoaXMubWVzaD90aGlzLm1lc2guZ2V0VG90YWxMZW5ndGgoKTowfWdldFBvaW50QXRMZW5ndGgoaCl7aWYodGhpcy5tZXNoKXtjb25zdCBtPXRoaXMubWVzaC5nZXRQb2ludEF0TGVuZ3RoKGgpO2lmKG0pcmV0dXJuW20ueCxtLnldfXJldHVyblswLDBdfW9uUHJvcGVydHlDaGFuZ2UoaCxtLHIpe2lmKHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoaCxtLHIpLChoPT09ImQifHxoPT09Im5vcm1hbGl6ZSIpJiZ0aGlzLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1t2XSYmKGg9PT0iZmlsbENvbG9yInx8aD09PSJmaWxsUnVsZSIpKXtjb25zdHtmaWxsQ29sb3I6aSxmaWxsUnVsZTpufT10aGlzLmF0dHJpYnV0ZXM7T2JqZWN0KHUuc2V0RmlsbENvbG9yKSh0aGlzW3ZdLHtjb2xvcjppLHJ1bGU6bn0pfWlmKHRoaXNbdl0mJihoPT09InN0cm9rZUNvbG9yInx8aD09PSJsaW5lV2lkdGgifHxoPT09ImxpbmVDYXAifHxoPT09ImxpbmVKb2luInx8aD09PSJsaW5lRGFzaCJ8fGg9PT0ibGluZURhc2hPZmZzZXQifHxoPT09InJvdW5kU2VnbWVudHMiKSl7Y29uc3R7c3Ryb2tlQ29sb3I6aSxsaW5lV2lkdGg6bn09dGhpcy5hdHRyaWJ1dGVzO2lmKGkmJm4+MCl7Y29uc3R7bGluZUNhcDpzLGxpbmVKb2luOngsbGluZURhc2g6UCxsaW5lRGFzaE9mZnNldDpSLG1pdGVyTGltaXQ6Yixyb3VuZFNlZ21lbnRzOkV9PXRoaXMuYXR0cmlidXRlcztPYmplY3QodS5zZXRTdHJva2VDb2xvcikodGhpc1t2XSx7Y29sb3I6aSxsaW5lQ2FwOnMsbGluZUpvaW46eCxsaW5lV2lkdGg6bixsaW5lRGFzaDpQLGxpbmVEYXNoT2Zmc2V0OlIsbWl0ZXJMaW1pdDpiLHJvdW5kU2VnbWVudHM6RX0pfX10aGlzW3ZdJiZoPT09ImNsaXBQYXRoIiYmdGhpc1t2XS5zZXRDbGlwUGF0aChtKSxoPT09InRleHR1cmUiJiZPYmplY3QoYy5hcHBseVRleHR1cmUpKHRoaXMsbSl9dXBkYXRlQ29udG91cnMoKXt0aGlzLnBhdGg9bmV3IGEuRmlndXJlMkQsdGhpcy5wYXRoLmFkZFBhdGgodGhpcy5hdHRyaWJ1dGVzLmQpLHRoaXMuYXR0cmlidXRlcy5ub3JtYWxpemUmJnRoaXMucGF0aC5ub3JtYWxpemUoLi4udGhpcy5wYXRoLmJvdW5kaW5nQ2VudGVyKX19ZyhDLCJBdHRyIixkLmRlZmF1bHQpLE8uZGVmYXVsdC5yZWdpc3Rlck5vZGUoQywicGF0aCIpfSxmdW5jdGlvbihMLGUsdCl7KGZ1bmN0aW9uKGEsbCl7TC5leHBvcnRzPWwoKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIEQoSSxTKXt2YXIgQT1bXSxVPSEwLEs9ITEsVj12b2lkIDA7dHJ5e2Zvcih2YXIgSj1JW1N5bWJvbC5pdGVyYXRvcl0oKSxxOyEoVT0ocT1KLm5leHQoKSkuZG9uZSkmJihBLnB1c2gocS52YWx1ZSksIShTJiZBLmxlbmd0aD09PVMpKTtVPSEwKTt9Y2F0Y2goVyl7Sz0hMCxWPVd9ZmluYWxseXt0cnl7IVUmJkoucmV0dXJuJiZKLnJldHVybigpfWZpbmFsbHl7aWYoSyl0aHJvdyBWfX1yZXR1cm4gQX1yZXR1cm4gZnVuY3Rpb24oSSxTKXtpZihBcnJheS5pc0FycmF5KEkpKXJldHVybiBJO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoSSkpcmV0dXJuIEQoSSxTKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlIil9fSgpLGw9TWF0aC5QSSoyLE09ZnVuY3Rpb24oSSxTLEEsVSxLLFYsSil7dmFyIHE9SS54LFc9SS55O3EqPVMsVyo9QTt2YXIgSD1VKnEtSypXLFo9SypxK1UqVztyZXR1cm57eDpIK1YseTpaK0p9fSxUPWZ1bmN0aW9uKEksUyl7dmFyIEE9MS4zMzMzMzMzMzMzMzMzMzMzKk1hdGgudGFuKFMvNCksVT1NYXRoLmNvcyhJKSxLPU1hdGguc2luKEkpLFY9TWF0aC5jb3MoSStTKSxKPU1hdGguc2luKEkrUyk7cmV0dXJuW3t4OlUtSypBLHk6SytVKkF9LHt4OlYrSipBLHk6Si1WKkF9LHt4OlYseTpKfV19LGQ9ZnVuY3Rpb24oSSxTLEEsVSl7dmFyIEs9SSpVLVMqQTwwPy0xOjEsVj1NYXRoLnNxcnQoSSpJK1MqUyksSj1NYXRoLnNxcnQoSSpJK1MqUykscT1JKkErUypVLFc9cS8oVipKKTtyZXR1cm4gVz4xJiYoVz0xKSxXPC0xJiYoVz0tMSksSypNYXRoLmFjb3MoVyl9LHU9ZnVuY3Rpb24oSSxTLEEsVSxLLFYsSixxLFcsSCxaLHR0KXt2YXIgXz1NYXRoLnBvdyhLLDIpLHN0PU1hdGgucG93KFYsMiksaz1NYXRoLnBvdyhaLDIpLGN0PU1hdGgucG93KHR0LDIpLGZ0PV8qc3QtXypjdC1zdCprO2Z0PDAmJihmdD0wKSxmdC89XypjdCtzdCprLGZ0PU1hdGguc3FydChmdCkqKEo9PT1xPy0xOjEpO3ZhciBCPWZ0KksvVip0dCxGPWZ0Ki1WL0sqWixZPUgqQi1XKkYrKEkrQSkvMixRPVcqQitIKkYrKFMrVSkvMixOPShaLUIpL0ssRz0odHQtRikvVixvPSgtWi1CKS9LLHk9KC10dC1GKS9WLGo9ZCgxLDAsTixHKSx6PWQoTixHLG8seSk7cmV0dXJuIHE9PT0wJiZ6PjAmJih6LT1sKSxxPT09MSYmejwwJiYoeis9bCksW1ksUSxqLHpdfSxjPWZ1bmN0aW9uKEkpe3ZhciBTPUkucHgsQT1JLnB5LFU9SS5jeCxLPUkuY3ksVj1JLnJ4LEo9SS5yeSxxPUkueEF4aXNSb3RhdGlvbixXPXE9PT12b2lkIDA/MDpxLEg9SS5sYXJnZUFyY0ZsYWcsWj1IPT09dm9pZCAwPzA6SCx0dD1JLnN3ZWVwRmxhZyxfPXR0PT09dm9pZCAwPzA6dHQsc3Q9W107aWYoVj09PTB8fEo9PT0wKXJldHVybltdO3ZhciBrPU1hdGguc2luKFcqbC8zNjApLGN0PU1hdGguY29zKFcqbC8zNjApLGZ0PWN0KihTLVUpLzIrayooQS1LKS8yLEI9LWsqKFMtVSkvMitjdCooQS1LKS8yO2lmKGZ0PT09MCYmQj09PTApcmV0dXJuW107Vj1NYXRoLmFicyhWKSxKPU1hdGguYWJzKEopO3ZhciBGPU1hdGgucG93KGZ0LDIpL01hdGgucG93KFYsMikrTWF0aC5wb3coQiwyKS9NYXRoLnBvdyhKLDIpO0Y+MSYmKFYqPU1hdGguc3FydChGKSxKKj1NYXRoLnNxcnQoRikpO3ZhciBZPXUoUyxBLFUsSyxWLEosWixfLGssY3QsZnQsQiksUT1hKFksNCksTj1RWzBdLEc9UVsxXSxvPVFbMl0seT1RWzNdLGo9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKHkpLyhsLzQpKSwxKTt5Lz1qO2Zvcih2YXIgej0wO3o8ajt6Kyspc3QucHVzaChUKG8seSkpLG8rPXk7cmV0dXJuIHN0Lm1hcChmdW5jdGlvbigkKXt2YXIgWD1NKCRbMF0sVixKLGN0LGssTixHKSx3PVgueCxldD1YLnkscnQ9TSgkWzFdLFYsSixjdCxrLE4sRyksYXQ9cnQueCxsdD1ydC55LGl0PU0oJFsyXSxWLEosY3QsayxOLEcpLG50PWl0Lngsb3Q9aXQueTtyZXR1cm57eDE6dyx5MTpldCx4MjphdCx5MjpsdCx4Om50LHk6b3R9fSl9LE89e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0sZj0vKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO2Z1bmN0aW9uIGcoRCl7dmFyIEk9W107cmV0dXJuIEQucmVwbGFjZShmLGZ1bmN0aW9uKFMsQSxVKXt2YXIgSz1BLnRvTG93ZXJDYXNlKCk7Zm9yKFU9QyhVKSxLPT0ibSImJlUubGVuZ3RoPjImJihJLnB1c2goW0FdLmNvbmNhdChVLnNwbGljZSgwLDIpKSksSz0ibCIsQT1BPT0ibSI/ImwiOiJMIik7Oyl7aWYoVS5sZW5ndGg9PU9bS10pcmV0dXJuIFUudW5zaGlmdChBKSxJLnB1c2goVSk7aWYoVS5sZW5ndGg8T1tLXSl0aHJvdyBuZXcgRXJyb3IoIm1hbGZvcm1lZCBwYXRoIGRhdGEiKTtJLnB1c2goW0FdLmNvbmNhdChVLnNwbGljZSgwLE9bS10pKSl9fSksSX12YXIgdj0vLT9bMC05XSpcLj9bMC05XSsoPzplWy0rXT9cZCspPy9pZztmdW5jdGlvbiBDKEQpe3ZhciBJPUQubWF0Y2godik7cmV0dXJuIEk/SS5tYXAoTnVtYmVyKTpbXX1mdW5jdGlvbiBwKEQpe3ZhciBJPURbMF1bMF0sUz1EWzBdWzFdLEE9SSxVPVM7cmV0dXJuIEQuZm9yRWFjaChmdW5jdGlvbihLKXt2YXIgVj1LWzBdLEo9S1syXSxxPUtbNF0sVz1LWzZdLEg9S1sxXSxaPUtbM10sdHQ9S1s1XSxfPUtbN107ST1NYXRoLm1pbihJLFYsSixxLFcpLFM9TWF0aC5taW4oUyxILFosdHQsXyksQT1NYXRoLm1heChBLFYsSixxLFcpLFU9TWF0aC5tYXgoVSxILFosdHQsXyl9KSxbSSxTLEEsVV19ZnVuY3Rpb24gaChELEkpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coRFswXS1JWzBdLDIpK01hdGgucG93KERbMV0tSVsxXSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KERbMl0tSVsyXSwyKStNYXRoLnBvdyhEWzNdLUlbM10sMikpfWZ1bmN0aW9uIG0oRCxJKXt2YXIgUz1EWzBdLEE9RFsyXSxVPURbNF0sSz1EWzZdLFY9RFsxXSxKPURbM10scT1EWzVdLFc9RFs3XSxIPUlbMF0sWj1JWzJdLHR0PUlbNF0sXz1JWzZdLHN0PUlbMV0saz1JWzNdLGN0PUlbNV0sZnQ9SVs3XTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KEgtUywyKStNYXRoLnBvdyhzdC1WLDIpKStNYXRoLnNxcnQoTWF0aC5wb3coWi1BLDIpK01hdGgucG93KGstSiwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KHR0LVUsMikrTWF0aC5wb3coY3QtcSwyKSkrTWF0aC5zcXJ0KE1hdGgucG93KF8tSywyKStNYXRoLnBvdyhmdC1XLDIpKX1mdW5jdGlvbiByKEQsSSl7dmFyIFM9bihELmxlbmd0aCksQT1bXTtTLmZvckVhY2goZnVuY3Rpb24oSyl7dmFyIFY9MCxKPTA7Sy5mb3JFYWNoKGZ1bmN0aW9uKHEpe1YrPW0oRFtxXSxJW0orK10pfSksQS5wdXNoKHtpbmRleDpLLGRpc3RhbmNlOlZ9KX0pLEEuc29ydChmdW5jdGlvbihLLFYpe3JldHVybiBLLmRpc3RhbmNlLVYuZGlzdGFuY2V9KTt2YXIgVT1bXTtyZXR1cm4gQVswXS5pbmRleC5mb3JFYWNoKGZ1bmN0aW9uKEspe1UucHVzaChEW0tdKX0pLFV9ZnVuY3Rpb24gaShELEkpe3ZhciBTPXMoRC5sZW5ndGgpLEE9W107Uy5mb3JFYWNoKGZ1bmN0aW9uKEspe3ZhciBWPTA7Sy5mb3JFYWNoKGZ1bmN0aW9uKEope1YrPWgocChEW0pdKSxwKElbSl0pKX0pLEEucHVzaCh7aW5kZXg6SyxkaXN0YW5jZTpWfSl9KSxBLnNvcnQoZnVuY3Rpb24oSyxWKXtyZXR1cm4gSy5kaXN0YW5jZS1WLmRpc3RhbmNlfSk7dmFyIFU9W107cmV0dXJuIEFbMF0uaW5kZXguZm9yRWFjaChmdW5jdGlvbihLKXtVLnB1c2goRFtLXSl9KSxVfWZ1bmN0aW9uIG4oRCl7Zm9yKHZhciBJPVtdLFM9MDtTPEQ7UysrKXtmb3IodmFyIEE9W10sVT0wO1U8RDtVKyspe3ZhciBLPVUrUztLPkQtMSYmKEstPUQpLEFbS109VX1JLnB1c2goQSl9cmV0dXJuIEl9ZnVuY3Rpb24gcyhEKXtmb3IodmFyIEk9W10sUz0wO1M8RDtTKyspSS5wdXNoKFMpO3JldHVybiB4KEkpfWZ1bmN0aW9uIHgoRCl7dmFyIEk9W10sUz1bXTtmdW5jdGlvbiBBKFUpe3ZhciBLLFY7Zm9yKEs9MDtLPFUubGVuZ3RoO0srKylWPVUuc3BsaWNlKEssMSlbMF0sUy5wdXNoKFYpLFUubGVuZ3RoPT0wJiZJLnB1c2goUy5zbGljZSgpKSxBKFUpLFUuc3BsaWNlKEssMCxWKSxTLnBvcCgpO3JldHVybiBJfXJldHVybiBBKEQpfXZhciBQPXt9O1AucGFyc2VyPWcsUC5sZXJwQ3VydmU9ZnVuY3Rpb24oRCxJLFMpe3JldHVybiBQLmxlcnBQb2ludHMoRFswXSxEWzFdLElbMF0sSVsxXSxTKS5jb25jYXQoUC5sZXJwUG9pbnRzKERbMl0sRFszXSxJWzJdLElbM10sUykpLmNvbmNhdChQLmxlcnBQb2ludHMoRFs0XSxEWzVdLElbNF0sSVs1XSxTKSkuY29uY2F0KFAubGVycFBvaW50cyhEWzZdLERbN10sSVs2XSxJWzddLFMpKX0sUC5sZXJwUG9pbnRzPWZ1bmN0aW9uKEQsSSxTLEEsVSl7cmV0dXJuW0QrKFMtRCkqVSxJKyhBLUkpKlVdfSxQLnEyYj1mdW5jdGlvbihELEksUyxBLFUsSyl7cmV0dXJuW0QsSSwoRCsyKlMpLzMsKEkrMipBKS8zLChVKzIqUykvMywoSysyKkEpLzMsVSxLXX0sUC5wYXRoMnNoYXBlcz1mdW5jdGlvbihEKXtmb3IodmFyIEk9UC5wYXJzZXIoRCksUz0wLEE9MCxVPTAsSz1JLmxlbmd0aCxWPVtdLEo9bnVsbCxxPXZvaWQgMCxXPXZvaWQgMCxIPXZvaWQgMCxaPXZvaWQgMCx0dD12b2lkIDAsXz12b2lkIDAsc3Q9dm9pZCAwO1U8SztVKyspe3ZhciBrPUlbVV0sY3Q9a1swXSxmdD1JW1UtMV07c3dpdGNoKGN0KXtjYXNlIm0iOnR0PVYubGVuZ3RoLFZbdHRdPVtdLEo9Vlt0dF0sUz1TK2tbMV0sQT1BK2tbMl07YnJlYWs7Y2FzZSJNIjp0dD1WLmxlbmd0aCxWW3R0XT1bXSxKPVZbdHRdLFM9a1sxXSxBPWtbMl07YnJlYWs7Y2FzZSJsIjpKLnB1c2goW1MsQSxTLEEsUyxBLFMra1sxXSxBK2tbMl1dKSxTKz1rWzFdLEErPWtbMl07YnJlYWs7Y2FzZSJMIjpKLnB1c2goW1MsQSxrWzFdLGtbMl0sa1sxXSxrWzJdLGtbMV0sa1syXV0pLFM9a1sxXSxBPWtbMl07YnJlYWs7Y2FzZSJoIjpKLnB1c2goW1MsQSxTLEEsUyxBLFMra1sxXSxBXSksUys9a1sxXTticmVhaztjYXNlIkgiOkoucHVzaChbUyxBLGtbMV0sQSxrWzFdLEEsa1sxXSxBXSksUz1rWzFdO2JyZWFrO2Nhc2UidiI6Si5wdXNoKFtTLEEsUyxBLFMsQSxTLEEra1sxXV0pLEErPWtbMV07YnJlYWs7Y2FzZSJWIjpKLnB1c2goW1MsQSxTLGtbMV0sUyxrWzFdLFMsa1sxXV0pLEE9a1sxXTticmVhaztjYXNlIkMiOkoucHVzaChbUyxBLGtbMV0sa1syXSxrWzNdLGtbNF0sa1s1XSxrWzZdXSksUz1rWzVdLEE9a1s2XTticmVhaztjYXNlIlMiOmZ0WzBdPT09IkMifHxmdFswXT09PSJjIj9KLnB1c2goW1MsQSxTK2Z0WzVdLWZ0WzNdLEErZnRbNl0tZnRbNF0sa1sxXSxrWzJdLGtbM10sa1s0XV0pOihmdFswXT09PSJTInx8ZnRbMF09PT0icyIpJiZKLnB1c2goW1MsQSxTK2Z0WzNdLWZ0WzFdLEErZnRbNF0tZnRbMl0sa1sxXSxrWzJdLGtbM10sa1s0XV0pLFM9a1szXSxBPWtbNF07YnJlYWs7Y2FzZSJjIjpKLnB1c2goW1MsQSxTK2tbMV0sQStrWzJdLFMra1szXSxBK2tbNF0sUytrWzVdLEEra1s2XV0pLFM9UytrWzVdLEE9QStrWzZdO2JyZWFrO2Nhc2UicyI6ZnRbMF09PT0iQyJ8fGZ0WzBdPT09ImMiP0oucHVzaChbUyxBLFMrZnRbNV0tZnRbM10sQStmdFs2XS1mdFs0XSxTK2tbMV0sQStrWzJdLFMra1szXSxBK2tbNF1dKTooZnRbMF09PT0iUyJ8fGZ0WzBdPT09InMiKSYmSi5wdXNoKFtTLEEsUytmdFszXS1mdFsxXSxBK2Z0WzRdLWZ0WzJdLFMra1sxXSxBK2tbMl0sUytrWzNdLEEra1s0XV0pLFM9UytrWzNdLEE9QStrWzRdO2JyZWFrO2Nhc2UiYSI6Xz1jKHtyeDprWzFdLHJ5OmtbMl0scHg6UyxweTpBLHhBeGlzUm90YXRpb246a1szXSxsYXJnZUFyY0ZsYWc6a1s0XSxzd2VlcEZsYWc6a1s1XSxjeDpTK2tbNl0sY3k6QStrWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oQixGKXtGPT09MD9KLnB1c2goW1MsQSxCLngxLEIueTEsQi54MixCLnkyLEIueCxCLnldKTpKLnB1c2goW19bRi0xXS54LF9bRi0xXS55LEIueDEsQi55MSxCLngyLEIueTIsQi54LEIueV0pfSksUz1zdC54LEE9c3QueTticmVhaztjYXNlIkEiOl89Yyh7cng6a1sxXSxyeTprWzJdLHB4OlMscHk6QSx4QXhpc1JvdGF0aW9uOmtbM10sbGFyZ2VBcmNGbGFnOmtbNF0sc3dlZXBGbGFnOmtbNV0sY3g6a1s2XSxjeTprWzddfSksc3Q9X1tfLmxlbmd0aC0xXSxfLmZvckVhY2goZnVuY3Rpb24oQixGKXtGPT09MD9KLnB1c2goW1MsQSxCLngxLEIueTEsQi54MixCLnkyLEIueCxCLnldKTpKLnB1c2goW19bRi0xXS54LF9bRi0xXS55LEIueDEsQi55MSxCLngyLEIueTIsQi54LEIueV0pfSksUz1zdC54LEE9c3QueTticmVhaztjYXNlIlEiOkoucHVzaChQLnEyYihTLEEsa1sxXSxrWzJdLGtbM10sa1s0XSkpLFM9a1szXSxBPWtbNF07YnJlYWs7Y2FzZSJxIjpKLnB1c2goUC5xMmIoUyxBLFMra1sxXSxBK2tbMl0sa1szXStTLGtbNF0rQSkpLFMrPWtbM10sQSs9a1s0XTticmVhaztjYXNlIlQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oSD1TK2Z0WzNdLWZ0WzFdLFo9QStmdFs0XS1mdFsyXSxKLnB1c2goUC5xMmIoUyxBLEgsWixrWzFdLGtbMl0pKSk6KGZ0WzBdPT09IlQifHxmdFswXT09PSJ0IikmJihKLnB1c2goUC5xMmIoUyxBLFMrUy1ILEErQS1aLGtbMV0sa1syXSkpLEg9UytTLUgsWj1BK0EtWiksUz1rWzFdLEE9a1syXTticmVhaztjYXNlInQiOmZ0WzBdPT09IlEifHxmdFswXT09PSJxIj8oSD1TK2Z0WzNdLWZ0WzFdLFo9QStmdFs0XS1mdFsyXSxKLnB1c2goUC5xMmIoUyxBLEgsWixTK2tbMV0sQStrWzJdKSkpOihmdFswXT09PSJUInx8ZnRbMF09PT0idCIpJiYoSi5wdXNoKFAucTJiKFMsQSxTK1MtSCxBK0EtWixTK2tbMV0sQStrWzJdKSksSD1TK1MtSCxaPUErQS1aKSxTKz1rWzFdLEErPWtbMl07YnJlYWs7Y2FzZSJaIjpxPUpbMF1bMF0sVz1KWzBdWzFdLEoucHVzaChbUyxBLHEsVyxxLFcscSxXXSk7YnJlYWs7Y2FzZSJ6IjpxPUpbMF1bMF0sVz1KWzBdWzFdLEoucHVzaChbUyxBLHEsVyxxLFcscSxXXSk7YnJlYWt9fXJldHVybiBWfSxQLl91cEN1cnZlcz1mdW5jdGlvbihELEkpe2Zvcih2YXIgUz0wLEE9MCxVPUQubGVuZ3RoO1M8STtTKyspRC5wdXNoKERbQV0uc2xpY2UoMCkpLEErKyxBPlUtMSYmKEEtPVUpfTtmdW5jdGlvbiBSKEQsSSxTLEEsVSxLLFYsSixxKXtyZXR1cm57bGVmdDpiKEQsSSxTLEEsVSxLLFYsSixxKSxyaWdodDpiKFYsSixVLEssUyxBLEQsSSwxLXEsITApfX1mdW5jdGlvbiBiKEQsSSxTLEEsVSxLLFYsSixxLFcpe3ZhciBIPShTLUQpKnErRCxaPShBLUkpKnErSSx0dD0oVS1TKSpxK1MsXz0oSy1BKSpxK0Esc3Q9KFYtVSkqcStVLGs9KEotSykqcStLLGN0PSh0dC1IKSpxK0gsZnQ9KF8tWikqcStaLEI9KHN0LXR0KSpxK3R0LEY9KGstXykqcStfLFk9KEItY3QpKnErY3QsUT0oRi1mdCkqcStmdDtyZXR1cm4gVz9bWSxRLGN0LGZ0LEgsWixELEldOltELEksSCxaLGN0LGZ0LFksUV19UC5fc3BsaXRDdXJ2ZXM9ZnVuY3Rpb24oRCxJKXtmb3IodmFyIFM9MCxBPTA7UzxJO1MrKyl7dmFyIFU9RFtBXSxLPVIoVVswXSxVWzFdLFVbMl0sVVszXSxVWzRdLFVbNV0sVVs2XSxVWzddLC41KTtELnNwbGljZShBLDEpLEQuc3BsaWNlKEEsMCxLLmxlZnQsSy5yaWdodCksQSs9MixBPj1ELmxlbmd0aC0xJiYoQT0wKX19O2Z1bmN0aW9uIEUoRCxJKXtmb3IodmFyIFM9ZnVuY3Rpb24oSyl7dmFyIFY9RFtELmxlbmd0aC0xXSxKPVtdO1YuZm9yRWFjaChmdW5jdGlvbihxKXtKLnB1c2gocS5zbGljZSgwKSl9KSxELnB1c2goSil9LEE9MDtBPEk7QSsrKVMoKX1yZXR1cm4gUC5sZXJwPWZ1bmN0aW9uKEQsSSxTKXtyZXR1cm4gUC5fbGVycChQLnBhdGgyc2hhcGVzKEQpLFAucGF0aDJzaGFwZXMoSSksUyl9LFAuTUlNX0NVUlZFU19DT1VOVD0xMDAsUC5fcHJlcHJvY2Vzc2luZz1mdW5jdGlvbihELEkpe3ZhciBTPUQubGVuZ3RoLEE9SS5sZW5ndGgsVT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KEQpKSxLPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoSSkpO3JldHVybiBTPkE/RShLLFMtQSk6UzxBJiZFKFUsQS1TKSxVPWkoVSxLKSxVLmZvckVhY2goZnVuY3Rpb24oVixKKXt2YXIgcT1WLmxlbmd0aCxXPUtbSl0ubGVuZ3RoO3E+Vz9xPFAuTUlNX0NVUlZFU19DT1VOVD8oUC5fc3BsaXRDdXJ2ZXMoVixQLk1JTV9DVVJWRVNfQ09VTlQtcSksUC5fc3BsaXRDdXJ2ZXMoS1tKXSxQLk1JTV9DVVJWRVNfQ09VTlQtVykpOlAuX3NwbGl0Q3VydmVzKEtbSl0scS1XKTpxPFcmJihXPFAuTUlNX0NVUlZFU19DT1VOVD8oUC5fc3BsaXRDdXJ2ZXMoVixQLk1JTV9DVVJWRVNfQ09VTlQtcSksUC5fc3BsaXRDdXJ2ZXMoS1tKXSxQLk1JTV9DVVJWRVNfQ09VTlQtVykpOlAuX3NwbGl0Q3VydmVzKFYsVy1xKSl9KSxVLmZvckVhY2goZnVuY3Rpb24oVixKKXtVW0pdPXIoVixLW0pdKX0pLFtVLEtdfSxQLl9sZXJwPWZ1bmN0aW9uKEQsSSxTKXt2YXIgQT1bXTtyZXR1cm4gRC5mb3JFYWNoKGZ1bmN0aW9uKFUsSyl7dmFyIFY9W107VS5mb3JFYWNoKGZ1bmN0aW9uKEoscSl7Vi5wdXNoKFAubGVycEN1cnZlKEosSVtLXVtxXSxTKSl9KSxBLnB1c2goVil9KSxBfSxQLmFuaW1hdGU9ZnVuY3Rpb24oRCl7dmFyIEk9UC5wYXRoMnNoYXBlcyhELmZyb20pLFM9UC5wYXRoMnNoYXBlcyhELnRvKSxBPVAuX3ByZXByb2Nlc3NpbmcoSSxTKSxVPW5ldyBEYXRlLEs9RC5lbmR8fGZ1bmN0aW9uKCl7fSxWPUQucHJvZ3Jlc3N8fGZ1bmN0aW9uKCl7fSxKPUQuYmVnaW58fGZ1bmN0aW9uKCl7fSxxPUQuZWFzaW5nfHxmdW5jdGlvbihfKXtyZXR1cm4gX30sVz1udWxsLEg9bnVsbCxaPUQudGltZTtKKEkpO3ZhciB0dD1mdW5jdGlvbiBfKCl7dmFyIHN0PW5ldyBEYXRlLVU7aWYoc3Q+PVope0g9UyxWKEgsMSksSyhIKSxjYW5jZWxBbmltYXRpb25GcmFtZShXKTtyZXR1cm59dmFyIGs9cShzdC9aKTtIPVAuX2xlcnAoQVswXSxBWzFdLGspLFYoSCxrKSxXPXJlcXVlc3RBbmltYXRpb25GcmFtZShfKX07dHQoKX0sUH0pfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCg3MSksbD10KDIyMSksTT10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgVD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx1PVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2NsYXNzIGMgZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1tUXSh7ZDoiIixub3JtYWxpemU6ITEsZmlsbENvbG9yOnZvaWQgMCxmaWxsUnVsZToibm9uemVybyIsc3Ryb2tlQ29sb3I6dm9pZCAwLGxpbmVXaWR0aDoxLGxpbmVKb2luOiJtaXRlciIsbGluZUNhcDoiYnV0dCIscm91bmRTZWdtZW50czoyMCxsaW5lRGFzaDp2b2lkIDAsbGluZURhc2hPZmZzZXQ6MCxtaXRlckxpbWl0OjEwLHRleHR1cmU6dm9pZCAwLHRleHR1cmVSZWN0OnZvaWQgMCx0ZXh0dXJlUmVwZWF0OiExLHNvdXJjZVJlY3Q6dm9pZCAwLGNsaXBQYXRoOnZvaWQgMH0pfWdldCBkKCl7cmV0dXJuIHRoaXNbdV0oImQiKX1zZXQgZChmKXt0aGlzW2RdKCJkIixmKX1nZXQgbm9ybWFsaXplKCl7cmV0dXJuIHRoaXNbdV0oIm5vcm1hbGl6ZSIpfXNldCBub3JtYWxpemUoZil7dGhpc1tkXSgibm9ybWFsaXplIiwhIWYpfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1t1XSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcihmKXt0aGlzW2RdKCJmaWxsQ29sb3IiLE9iamVjdChsLnBhcnNlQ29sb3IpKGYpKX1nZXQgZmlsbFJ1bGUoKXtyZXR1cm4gdGhpc1t1XSgiZmlsbFJ1bGUiKX1zZXQgZmlsbFJ1bGUoZil7aWYoZiE9bnVsbCYmZiE9PSJub256ZXJvIiYmZiE9PSJldmVub2RkIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGZpbGwgcnVsZS4iKTt0aGlzW2RdKCJmaWxsUnVsZSIsZil9Z2V0IHN0cm9rZUNvbG9yKCl7cmV0dXJuIHRoaXNbdV0oInN0cm9rZUNvbG9yIil9c2V0IHN0cm9rZUNvbG9yKGYpe3RoaXNbZF0oInN0cm9rZUNvbG9yIixPYmplY3QobC5wYXJzZUNvbG9yKShmKSl9Z2V0IGxpbmVXaWR0aCgpe3JldHVybiB0aGlzW3VdKCJsaW5lV2lkdGgiKX1zZXQgbGluZVdpZHRoKGYpe3RoaXNbZF0oImxpbmVXaWR0aCIsT2JqZWN0KE0udG9OdW1iZXIpKGYpKX1nZXQgbGluZUpvaW4oKXtyZXR1cm4gdGhpc1t1XSgibGluZUpvaW4iKX1zZXQgbGluZUpvaW4oZil7aWYoZiE9bnVsbCYmZiE9PSJtaXRlciImJmYhPT0iYmV2ZWwiJiZmIT09InJvdW5kIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGxpbmVKb2luIHR5cGUuIik7dGhpc1tkXSgibGluZUpvaW4iLGYpfWdldCBsaW5lQ2FwKCl7cmV0dXJuIHRoaXNbdV0oImxpbmVDYXAiKX1zZXQgbGluZUNhcChmKXtpZihmIT1udWxsJiZmIT09ImJ1dHQiJiZmIT09InNxdWFyZSImJmYhPT0icm91bmQiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgbGluZUNhcCB0eXBlLiIpO3RoaXNbZF0oImxpbmVDYXAiLGYpfWdldCBsaW5lRGFzaCgpe3JldHVybiB0aGlzW3VdKCJsaW5lRGFzaCIpfXNldCBsaW5lRGFzaChmKXtmPU9iamVjdChNLnRvQXJyYXkpKGYsITApLGYhPW51bGwmJiFBcnJheS5pc0FycmF5KGYpJiYoZj1bZl0pLHRoaXNbZF0oImxpbmVEYXNoIixmP2YubWFwKE0udG9OdW1iZXIpOm51bGwpfWdldCBsaW5lRGFzaE9mZnNldCgpe3JldHVybiB0aGlzW3VdKCJsaW5lRGFzaE9mZnNldCIpfXNldCBsaW5lRGFzaE9mZnNldChmKXt0aGlzW2RdKCJsaW5lRGFzaE9mZnNldCIsT2JqZWN0KE0udG9OdW1iZXIpKGYpKX1nZXQgbWl0ZXJMaW1pdCgpe3JldHVybiB0aGlzW3VdKCJtaXRlckxpbWl0Iil9c2V0IG1pdGVyTGltaXQoZil7dGhpc1tkXSgibWl0ZXJMaW1pdCIsT2JqZWN0KE0udG9OdW1iZXIpKGYpKX1nZXQgcm91bmRTZWdtZW50cygpe3JldHVybiB0aGlzW3VdKCJyb3VuZFNlZ21lbnRzIil9c2V0IHJvdW5kU2VnbWVudHMoZil7dGhpc1tkXSgicm91bmRTZWdtZW50cyIsZil9Z2V0IHRleHR1cmUoKXtyZXR1cm4gdGhpc1t1XSgidGV4dHVyZSIpfXNldCB0ZXh0dXJlKGYpe3RoaXNbZF0oInRleHR1cmUiLGYpfWdldCB0ZXh0dXJlUmVjdCgpe3JldHVybiB0aGlzW3VdKCJ0ZXh0dXJlUmVjdCIpfXNldCB0ZXh0dXJlUmVjdChmKXt0aGlzW2RdKCJ0ZXh0dXJlUmVjdCIsZil9Z2V0IHNvdXJjZVJlY3QoKXtyZXR1cm4gdGhpc1t1XSgic291cmNlUmVjdCIpfXNldCBzb3VyY2VSZWN0KGYpe3RoaXNbZF0oInNvdXJjZVJlY3QiLGYpfWdldCB0ZXh0dXJlUmVwZWF0KCl7cmV0dXJuIHRoaXNbdV0oInRleHR1cmVSZXBlYXQiKX1zZXQgdGV4dHVyZVJlcGVhdChmKXt0aGlzW2RdKCJ0ZXh0dXJlUmVwZWF0IiwhIWYpfWdldCBjbGlwUGF0aCgpe3JldHVybiB0aGlzW3VdKCJjbGlwUGF0aCIpfXNldCBjbGlwUGF0aChmKXt0aGlzW2RdKCJjbGlwUGF0aCIsZil9fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBhPXQoMjI2KSxsPXQoMjEzKSxNPXQoMjMwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gVCh1LGMsTyl7cmV0dXJuIGMgaW4gdT9PYmplY3QuZGVmaW5lUHJvcGVydHkodSxjLHt2YWx1ZTpPLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dVtjXT1PLHV9Y2xhc3MgZCBleHRlbmRzIGEuZGVmYXVsdHtnZXQgaXNWaXNpYmxlKCl7Y29uc3R7d2lkdGg6YyxoZWlnaHQ6T309dGhpcy5hdHRyaWJ1dGVzO3JldHVybiBjPjAmJk8+MCYmc3VwZXIuaXNWaXNpYmxlfX1UKGQsIkF0dHIiLE0uZGVmYXVsdCksbC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShkLCJyZWN0Iil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE99KTt2YXIgYT10KDIyOCksbD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgTT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksVD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7ZnVuY3Rpb24gYyhmKXtjb25zdHt3aWR0aDpnLGhlaWdodDp2fT1mO3JldHVybmBNMCAwTCR7Z30gMEwke2d9ICR7dn1MMCAke3Z9WmB9Y2xhc3MgTyBleHRlbmRzIGEuZGVmYXVsdHtjb25zdHJ1Y3RvcihnKXtzdXBlcihnKSx0aGlzW01dKHt3aWR0aDowLGhlaWdodDowfSksdGhpc1t1XSgic2l6ZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbZF0oImQiKX1zZXQgZChnKXt9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXNbZF0oIndpZHRoIil9c2V0IHdpZHRoKGcpe2lmKGc9T2JqZWN0KGwudG9OdW1iZXIpKGcpLHRoaXNbVF0oIndpZHRoIixnKSl7Y29uc3Qgdj1jKHRoaXMpO3RoaXNbVF0oImQiLHYpfX1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXNbZF0oImhlaWdodCIpfXNldCBoZWlnaHQoZyl7aWYoZz1PYmplY3QobC50b051bWJlcikoZyksdGhpc1tUXSgiaGVpZ2h0IixnKSl7Y29uc3Qgdj1jKHRoaXMpO3RoaXNbVF0oImQiLHYpfX1nZXQgc2l6ZSgpe3JldHVyblt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XX1zZXQgc2l6ZShnKXtnPU9iamVjdChsLnRvQXJyYXkpKGcpLEFycmF5LmlzQXJyYXkoZyl8fChnPVtnLGddKSx0aGlzLndpZHRoPWdbMF0sdGhpcy5oZWlnaHQ9Z1sxXX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGE9dCgyMzIpLGw9dCgyMTMpLE09dCgyMzUpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBUKHUsYyxPKXtyZXR1cm4gYyBpbiB1P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LGMse3ZhbHVlOk8sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp1W2NdPU8sdX1jbGFzcyBkIGV4dGVuZHMgYS5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczpjfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGNbMF0+MCYmY1sxXT4wJiZzdXBlci5pc1Zpc2libGV9fVQoZCwiQXR0ciIsTS5kZWZhdWx0KSxsLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGQsInRyaWFuZ2xlIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgYT10KDIyNiksbD10KDIxMyksTT10KDIzMyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIFQodSxjLE8pe3JldHVybiBjIGluIHU/T2JqZWN0LmRlZmluZVByb3BlcnR5KHUsYyx7dmFsdWU6TyxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnVbY109Tyx1fWNsYXNzIGQgZXh0ZW5kcyBhLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3BvaW50czpjfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGMubGVuZ3RoPjAmJnN1cGVyLmlzVmlzaWJsZX19VChkLCJBdHRyIixNLmRlZmF1bHQpLGwuZGVmYXVsdC5yZWdpc3Rlck5vZGUoZCwicG9seWxpbmUiKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBhPXQoMjI4KSxsPXQoNzIpLE09dCgyMzQpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjb25zdCBUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZSIpLHU9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksYz1TeW1ib2wuZm9yKCJzcHJpdGVqc19kZWNsYXJlQWxpYXMiKTtmdW5jdGlvbiBPKGcpe2NvbnN0e3BvaW50czp2LHNtb290aDpDLHNtb290aFJhbmdlOnAsY2xvc2U6aH09ZyxtPVtdO2ZvcihsZXQgaT0wO2k8di5sZW5ndGg7aSs9MiltLnB1c2goW3ZbaV0sdltpKzFdXSk7bGV0IHI9IiI7cmV0dXJuIEM/cj1PYmplY3QoTS5tYWtlU21vb3RoQ3VydmVMaW5lKShtLHApOm0ubGVuZ3RoJiYocj1gTSR7bS5tYXAoaT0+aS5qb2luKCIgIikpLmpvaW4oIkwiKX1gKSxyJiZoJiYocis9IloiKSxyfWNsYXNzIGYgZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3Iodil7c3VwZXIodiksdGhpc1tUXSh7cG9pbnRzOltdLHNtb290aDohMSxzbW9vdGhSYW5nZTpbMF0sY2xvc2VUeXBlOiJub25lIn0pLHRoaXNbY10oImNsb3NlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1t1XSgiZCIpfXNldCBkKHYpe31nZXQgY2xvc2UoKXtyZXR1cm4gdGhpcy5jbG9zZVR5cGUhPT0ibm9uZSJ9c2V0IGNsb3NlKHYpe3Y9dj8ibm9ybWFsIjoibm9uZSIsdGhpcy5jbG9zZVR5cGU9dn1nZXQgY2xvc2VUeXBlKCl7cmV0dXJuIHRoaXNbdV0oImNsb3NlVHlwZSIpfXNldCBjbG9zZVR5cGUodil7aWYodiE9bnVsbCYmdiE9PSJub25lIiYmdiE9PSJub3JtYWwiKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2xvc2VUeXBlIHR5cGUuIik7aWYodGhpc1tkXSgiY2xvc2VUeXBlIix2KSl7Y29uc3QgQz1PKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgc21vb3RoKCl7cmV0dXJuIHRoaXNbdV0oInNtb290aCIpfXNldCBzbW9vdGgodil7aWYodGhpc1tkXSgic21vb3RoIix2KSl7Y29uc3QgQz1PKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgc21vb3RoUmFuZ2UoKXtyZXR1cm4gdGhpc1t1XSgic21vb3RoUmFuZ2UiKX1zZXQgc21vb3RoUmFuZ2Uodil7aWYodiYmIUFycmF5LmlzQXJyYXkodikmJih2PVt2XSksdGhpc1tkXSgic21vb3RoUmFuZ2UiLHYpJiZ0aGlzLnNtb290aCl7Y29uc3QgQz1PKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgcG9pbnRzKCl7cmV0dXJuIHRoaXNbdV0oInBvaW50cyIpfXNldCBwb2ludHModil7aWYodj1PYmplY3QobC50b0FycmF5KSh2KSxBcnJheS5pc0FycmF5KHYpJiYodj12LnJlZHVjZSgoQyxwKT0+QXJyYXkuaXNBcnJheShwKT9bLi4uQywuLi5wLm1hcChoPT5PYmplY3QobC50b051bWJlcikoaCkpXTpbLi4uQyxPYmplY3QobC50b051bWJlcikocCldLFtdKSksdGhpc1tkXSgicG9pbnRzIix2KSl7Y29uc3QgQz1PKHRoaXMpO3RoaXNbZF0oImQiLEMpfX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJtYWtlU21vb3RoQ3VydmVMaW5lIixmdW5jdGlvbigpe3JldHVybiBhfSksdCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIGEobCxNPVswXSl7ZnVuY3Rpb24gVChjLE89LjE2OCxmPS4xNjgpe2xldCBnLHYsQyxwO2lmKChsW2NdLng9PT1sW2MrMV0ueHx8bFtjXS55PT09bFtjKzFdLnkpJiYoTz0wLGY9MCksYzwxPyhnPWxbMF0ueCsobFsxXS54LWxbMF0ueCkqTyx2PWxbMF0ueSsobFsxXS55LWxbMF0ueSkqTyk6KGc9bFtjXS54KyhsW2MrMV0ueC1sW2MtMV0ueCkqTyx2PWxbY10ueSsobFtjKzFdLnktbFtjLTFdLnkpKk8pLGM+bC5sZW5ndGgtMyl7Y29uc3QgaD1sLmxlbmd0aC0xO0M9bFtoXS54LShsW2hdLngtbFtoLTFdLngpKmYscD1sW2hdLnktKGxbaF0ueS1sW2gtMV0ueSkqZn1lbHNlIEM9bFtjKzFdLngtKGxbYysyXS54LWxbY10ueCkqZixwPWxbYysxXS55LShsW2MrMl0ueS1sW2NdLnkpKmY7cmV0dXJuW3t4OmcseTp2fSx7eDpDLHk6cH1dfWw9bC5tYXAoKFtjLE9dKT0+KHt4OmMseTpPfSkpO2xldCBkPSIiLHU9MDtyZXR1cm4gbC5mb3JFYWNoKChjLE8pPT57aWYoTz09PTApZCs9YE0ke2MueH0gJHtjLnl9YDtlbHNle2Zvcig7Tz5NW3VdOyl1Kys7aWYodSUyKXtjb25zdFtmLGddPVQoTy0xKTtkKz1gQyR7W2YueCxmLnksZy54LGcueSxjLngsYy55XS5qb2luKCIgIil9YH1lbHNlIGQrPWBMJHtjLnh9ICR7Yy55fWB9fSksZH19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgYT10KDIzMyksbD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgTT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksVD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIHUoTyl7Y29uc3RbZixnXT1PLnNpZGVzO2xldCB2PU8uYW5nbGUlMzYwO3JldHVybiB2PDAmJih2Kz0zNjApLHY9TWF0aC5QSSp2LzE4MCxbMCwwLGYsMCxnKk1hdGguY29zKHYpLGcqTWF0aC5zaW4odildfWNsYXNzIGMgZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1tNXSh7c2lkZXM6WzAsMF0sYW5nbGU6NjAsY2xvc2VUeXBlOiJub3JtYWwifSl9Z2V0IHBvaW50cygpe3JldHVybiBzdXBlci5wb2ludHN9c2V0IHBvaW50cyhmKXt9Z2V0IHNpZGVzKCl7cmV0dXJuIHRoaXNbZF0oInNpZGVzIil9c2V0IHNpZGVzKGYpe2lmKGY9T2JqZWN0KGwudG9BcnJheSkoZiwhMCksZiE9bnVsbCYmIUFycmF5LmlzQXJyYXkoZikmJihmPVtmLGZdKSx0aGlzW1RdKCJzaWRlcyIsZikpe2NvbnN0IGc9dSh0aGlzKTtzdXBlci5wb2ludHM9Z319Z2V0IGFuZ2xlKCl7cmV0dXJuIHRoaXNbZF0oImFuZ2xlIil9c2V0IGFuZ2xlKGYpe2lmKGY9T2JqZWN0KGwudG9OdW1iZXIpKGYpLHRoaXNbVF0oImFuZ2xlIixmKSl7Y29uc3QgZz11KHRoaXMpO3N1cGVyLnBvaW50cz1nfX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGE9dCgyMzIpLGw9dCgyMTMpLE09dCgyMzcpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBUKHUsYyxPKXtyZXR1cm4gYyBpbiB1P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LGMse3ZhbHVlOk8sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp1W2NdPU8sdX1jbGFzcyBkIGV4dGVuZHMgYS5kZWZhdWx0e2dldCBpc1Zpc2libGUoKXtjb25zdHtzaWRlczpjfT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuIGNbMF0+MCYmY1sxXT4wJiZzdXBlci5pc1Zpc2libGV9fVQoZCwiQXR0ciIsTS5kZWZhdWx0KSxsLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGQsInBhcmFsbGVsIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgYT10KDIzMyksbD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgTT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksVD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIHUoTyl7Y29uc3RbZixnXT1PLnNpZGVzO2xldCB2PU8uYW5nbGUlMzYwO3Y8MCYmKHYrPTM2MCksdj1NYXRoLlBJKnYvMTgwO2NvbnN0IEM9ZypNYXRoLmNvcyh2KSxwPWcqTWF0aC5zaW4odik7cmV0dXJuWzAsMCxmLDAsQytmLHAsQyxwXX1jbGFzcyBjIGV4dGVuZHMgYS5kZWZhdWx0e2NvbnN0cnVjdG9yKGYpe3N1cGVyKGYpLHRoaXNbTV0oe3NpZGVzOlswLDBdLGFuZ2xlOjkwLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZil7fWdldCBzaWRlcygpe3JldHVybiB0aGlzW2RdKCJzaWRlcyIpfXNldCBzaWRlcyhmKXtpZihmPU9iamVjdChsLnRvQXJyYXkpKGYsITApLGYhPW51bGwmJiFBcnJheS5pc0FycmF5KGYpJiYoZj1bZixmXSksdGhpc1tUXSgic2lkZXMiLGYpKXtjb25zdCBnPXUodGhpcyk7c3VwZXIucG9pbnRzPWd9fWdldCBhbmdsZSgpe3JldHVybiB0aGlzW2RdKCJhbmdsZSIpfXNldCBhbmdsZShmKXtpZihmPU9iamVjdChsLnRvTnVtYmVyKShmKSx0aGlzW1RdKCJhbmdsZSIsZikpe2NvbnN0IGc9dSh0aGlzKTtzdXBlci5wb2ludHM9Z319fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBhPXQoMjMyKSxsPXQoMjEzKSxNPXQoMjM5KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gVCh1LGMsTyl7cmV0dXJuIGMgaW4gdT9PYmplY3QuZGVmaW5lUHJvcGVydHkodSxjLHt2YWx1ZTpPLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dVtjXT1PLHV9Y2xhc3MgZCBleHRlbmRzIGEuZGVmYXVsdHt9VChkLCJBdHRyIixNLmRlZmF1bHQpLGwuZGVmYXVsdC5yZWdpc3Rlck5vZGUoZCwicmVndWxhciIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBjfSk7dmFyIGE9dCgyMzMpLGw9dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IE09U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLFQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKTtmdW5jdGlvbiB1KE8pe2NvbnN0e2VkZ2VzOmYscmFkaXVzOmcsb2Zmc2V0QW5nbGU6dn09TyxDPU1hdGguUEkqdi8xODAtLjUqTWF0aC5QSTtpZihmPDN8fGc8PTApcmV0dXJuW107Y29uc3QgcD1bXTtmb3IobGV0IGg9MDtoPGY7aCsrKXtjb25zdCBtPWgqMipNYXRoLlBJL2YrQyxyPWcqTWF0aC5jb3MobSksaT1nKk1hdGguc2luKG0pO3AucHVzaChyLGkpfXJldHVybiBwfWNsYXNzIGMgZXh0ZW5kcyBhLmRlZmF1bHR7Y29uc3RydWN0b3IoZil7c3VwZXIoZiksdGhpc1tNXSh7ZWRnZXM6MyxyYWRpdXM6MCxvZmZzZXRBbmdsZTowLGNsb3NlVHlwZToibm9ybWFsIn0pfWdldCBwb2ludHMoKXtyZXR1cm4gc3VwZXIucG9pbnRzfXNldCBwb2ludHMoZil7fWdldCBlZGdlcygpe3JldHVybiB0aGlzW2RdKCJlZGdlcyIpfXNldCBlZGdlcyhmKXtpZihmPU9iamVjdChsLnRvTnVtYmVyKShmKSx0aGlzW1RdKCJlZGdlcyIsZikpe2NvbnN0IGc9dSh0aGlzKTtzdXBlci5wb2ludHM9Z319Z2V0IHJhZGl1cygpe3JldHVybiB0aGlzW2RdKCJyYWRpdXMiKX1zZXQgcmFkaXVzKGYpe2lmKGY9T2JqZWN0KGwudG9OdW1iZXIpKGYpLHRoaXNbVF0oInJhZGl1cyIsZikpe2NvbnN0IGc9dSh0aGlzKTtzdXBlci5wb2ludHM9Z319Z2V0IG9mZnNldEFuZ2xlKCl7cmV0dXJuIHRoaXNbZF0oIm9mZnNldEFuZ2xlIil9c2V0IG9mZnNldEFuZ2xlKGYpe2lmKGY9T2JqZWN0KGwudG9OdW1iZXIpKGYpLHRoaXNbVF0oIm9mZnNldEFuZ2xlIixmKSl7Y29uc3QgZz11KHRoaXMpO3N1cGVyLnBvaW50cz1nfX19fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBkfSk7dmFyIGE9dCgyMzIpLGw9dCgyMTMpLE09dCgyNDEpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiBUKHUsYyxPKXtyZXR1cm4gYyBpbiB1P09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LGMse3ZhbHVlOk8sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp1W2NdPU8sdX1jbGFzcyBkIGV4dGVuZHMgYS5kZWZhdWx0e31UKGQsIkF0dHIiLE0uZGVmYXVsdCksbC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShkLCJzdGFyIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTt2YXIgYT10KDIzMyksbD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgTT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksVD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxkPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpO2Z1bmN0aW9uIHUoTyl7Y29uc3R7YW5nbGVzOmYsaW5uZXJSYWRpdXM6ZyxvdXRlclJhZGl1czp2LG9mZnNldEFuZ2xlOkN9PU8scD1NYXRoLlBJKkMvMTgwLS41Kk1hdGguUEk7aWYoZjwzfHxnPD0wfHx2PD0wKXJldHVybltdO2NvbnN0IGg9W107Zm9yKGxldCBtPTA7bTxmKjI7bSsrKXtjb25zdCByPW0qTWF0aC5QSS9mK3AsaT1tJTI/Zzp2LG49aSpNYXRoLmNvcyhyKSxzPWkqTWF0aC5zaW4ocik7aC5wdXNoKG4scyl9cmV0dXJuIGh9Y2xhc3MgYyBleHRlbmRzIGEuZGVmYXVsdHtjb25zdHJ1Y3RvcihmKXtzdXBlcihmKSx0aGlzW01dKHthbmdsZXM6NSxpbm5lclJhZGl1czowLG91dGVyUmFkaXVzOjAsb2Zmc2V0QW5nbGU6MCxjbG9zZVR5cGU6Im5vcm1hbCJ9KX1nZXQgcG9pbnRzKCl7cmV0dXJuIHN1cGVyLnBvaW50c31zZXQgcG9pbnRzKGYpe31nZXQgYW5nbGVzKCl7cmV0dXJuIHRoaXNbZF0oImFuZ2xlcyIpfXNldCBhbmdsZXMoZil7aWYoZj1PYmplY3QobC50b051bWJlcikoZiksdGhpc1tUXSgiYW5nbGVzIixmKSl7Y29uc3QgZz11KHRoaXMpO3N1cGVyLnBvaW50cz1nfX1nZXQgaW5uZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1tkXSgiaW5uZXJSYWRpdXMiKX1zZXQgaW5uZXJSYWRpdXMoZil7aWYoZj1PYmplY3QobC50b051bWJlcikoZiksdGhpc1tUXSgiaW5uZXJSYWRpdXMiLGYpKXtjb25zdCBnPXUodGhpcyk7c3VwZXIucG9pbnRzPWd9fWdldCBvdXRlclJhZGl1cygpe3JldHVybiB0aGlzW2RdKCJvdXRlclJhZGl1cyIpfXNldCBvdXRlclJhZGl1cyhmKXtpZihmPU9iamVjdChsLnRvTnVtYmVyKShmKSx0aGlzW1RdKCJvdXRlclJhZGl1cyIsZikpe2NvbnN0IGc9dSh0aGlzKTtzdXBlci5wb2ludHM9Z319Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLmlubmVyUmFkaXVzLHRoaXMub3V0ZXJSYWRpdXNdfXNldCByYWRpdXMoZil7Zj1PYmplY3QobC50b0FycmF5KShmLCEwKSxBcnJheS5pc0FycmF5KGYpfHwoZj1bZixmXSksdGhpcy5pbm5lclJhZGl1cz1mWzBdLHRoaXMub3V0ZXJSYWRpdXM9ZlsxXX1nZXQgb2Zmc2V0QW5nbGUoKXtyZXR1cm4gdGhpc1tkXSgib2Zmc2V0QW5nbGUiKX1zZXQgb2Zmc2V0QW5nbGUoZil7aWYoZj1PYmplY3QobC50b051bWJlcikoZiksdGhpc1tUXSgib2Zmc2V0QW5nbGUiLGYpKXtjb25zdCBnPXUodGhpcyk7c3VwZXIucG9pbnRzPWd9fX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgYT10KDIyNiksbD10KDIxMyksTT10KDI0Myk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIFQodSxjLE8pe3JldHVybiBjIGluIHU/T2JqZWN0LmRlZmluZVByb3BlcnR5KHUsYyx7dmFsdWU6TyxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnVbY109Tyx1fWNsYXNzIGQgZXh0ZW5kcyBhLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e3JhZGl1c1g6YyxyYWRpdXNZOk8sc3RhcnRBbmdsZTpmLGVuZEFuZ2xlOmd9PXRoaXMuYXR0cmlidXRlcztyZXR1cm4gYz4wJiZPPjAmJmYhPT1nJiZzdXBlci5pc1Zpc2libGV9fVQoZCwiQXR0ciIsTS5kZWZhdWx0KSxsLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGQsImVsbGlwc2UiKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBhPXQoMTIpLGw9dCgyMjgpLE09dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIE8oZyl7Y29uc3R7cmFkaXVzWDp2LHJhZGl1c1k6QyxzdGFydEFuZ2xlOnAsZW5kQW5nbGU6aCxkaXJlY3Rpb246bSxjbG9zZVR5cGU6cn09ZyxpPW09PT0iYW5pdGNsb2Nrd2lzZSIsbj1uZXcgYS5GaWd1cmUyRDtyZXR1cm4gcj09PSJzZWN0b3IiJiZuLm1vdmVUbygwLDApLG4uZWxsaXBzZSgwLDAsdixDLDAsTWF0aC5QSSpwLzE4MCxNYXRoLlBJKmgvMTgwLGkpLHIhPT0ibm9uZSImJm4uY2xvc2VQYXRoKCksbi5wYXRoLnJlZHVjZSgoUCxSKT0+UCtSLmpvaW4oIiAiKSwiIil9Y2xhc3MgZiBleHRlbmRzIGwuZGVmYXVsdHtjb25zdHJ1Y3Rvcih2KXtzdXBlcih2KSx0aGlzW1RdKHtyYWRpdXNYOjAscmFkaXVzWTowLHN0YXJ0QW5nbGU6MCxlbmRBbmdsZTozNjAsZGlyZWN0aW9uOiJjbG9ja3dpc2UiLGNsb3NlVHlwZToibm9uZSJ9KSx0aGlzW2NdKCJyYWRpdXMiLCJhbmdsZSIpfWdldCBkKCl7cmV0dXJuIHRoaXNbdV0oImQiKX1zZXQgZCh2KXt9Z2V0IHJhZGl1c1goKXtyZXR1cm4gdGhpc1t1XSgicmFkaXVzWCIpfXNldCByYWRpdXNYKHYpe2lmKHY9T2JqZWN0KE0udG9OdW1iZXIpKHYpLHRoaXNbZF0oInJhZGl1c1giLHYpKXtjb25zdCBDPU8odGhpcyk7dGhpc1tkXSgiZCIsQyl9fWdldCByYWRpdXNZKCl7cmV0dXJuIHRoaXNbdV0oInJhZGl1c1kiKX1zZXQgcmFkaXVzWSh2KXtpZih2PU9iamVjdChNLnRvTnVtYmVyKSh2KSx0aGlzW2RdKCJyYWRpdXNZIix2KSl7Y29uc3QgQz1PKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgcmFkaXVzKCl7cmV0dXJuW3RoaXMucmFkaXVzWCx0aGlzLnJhZGl1c1ldfXNldCByYWRpdXModil7dj1PYmplY3QoTS50b0FycmF5KSh2LCEwKSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpcy5yYWRpdXNYPXZbMF0sdGhpcy5yYWRpdXNZPXZbMV19Z2V0IGFuZ2xlKCl7cmV0dXJuW3RoaXMuc3RhcnRBbmdsZSx0aGlzLmVuZEFuZ2xlXX1zZXQgYW5nbGUodil7dj1PYmplY3QoTS50b0FycmF5KSh2KSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpcy5zdGFydEFuZ2xlPXZbMF0sdGhpcy5lbmRBbmdsZT12WzFdfWdldCBkaXJlY3Rpb24oKXtyZXR1cm4gdGhpc1t1XSgiZGlyZWN0aW9uIil9c2V0IGRpcmVjdGlvbih2KXtpZih2IT1udWxsJiZ2IT09ImNsb2Nrd2lzZSImJnYhPT0iYW50aWNsb2Nrd2lzZSIpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBkaXJlY3Rpb24gdHlwZS4iKTt0aGlzW2RdKCJkaXJlY3Rpb24iLHYpfWdldCBzdGFydEFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oInN0YXJ0QW5nbGUiKX1zZXQgc3RhcnRBbmdsZSh2KXtpZih2PU9iamVjdChNLnRvTnVtYmVyKSh2KSx0aGlzW2RdKCJzdGFydEFuZ2xlIix2KSl7Y29uc3QgQz1PKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgZW5kQW5nbGUoKXtyZXR1cm4gdGhpc1t1XSgiZW5kQW5nbGUiKX1zZXQgZW5kQW5nbGUodil7aWYodj1PYmplY3QoTS50b051bWJlcikodiksdGhpc1tkXSgiZW5kQW5nbGUiLHYpKXtjb25zdCBDPU8odGhpcyk7dGhpc1tkXSgiZCIsQyl9fWdldCBjbG9zZVR5cGUoKXtyZXR1cm4gdGhpc1t1XSgiY2xvc2VUeXBlIil9c2V0IGNsb3NlVHlwZSh2KXtpZih2IT1udWxsJiZ2IT09Im5vbmUiJiZ2IT09InNlY3RvciImJnYhPT0ibm9ybWFsIil0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGNsb3NlVHlwZSB0eXBlLiIpO2lmKHRoaXNbZF0oImNsb3NlVHlwZSIsdikpe2NvbnN0IEM9Tyh0aGlzKTt0aGlzW2RdKCJkIixDKX19fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBhPXQoMjQyKSxsPXQoMjEzKSxNPXQoMjQ1KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gVCh1LGMsTyl7cmV0dXJuIGMgaW4gdT9PYmplY3QuZGVmaW5lUHJvcGVydHkodSxjLHt2YWx1ZTpPLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dVtjXT1PLHV9Y2xhc3MgZCBleHRlbmRzIGEuZGVmYXVsdHt9VChkLCJBdHRyIixNLmRlZmF1bHQpLGwuZGVmYXVsdC5yZWdpc3Rlck5vZGUoZCwiYXJjIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KTt2YXIgYT10KDI0MyksbD10KDcyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y2xhc3MgTSBleHRlbmRzIGEuZGVmYXVsdHtnZXQgcmFkaXVzKCl7cmV0dXJuIHN1cGVyLnJhZGl1c1h9c2V0IHJhZGl1cyhkKXtkPU9iamVjdChsLnRvTnVtYmVyKShkKSxzdXBlci5yYWRpdXNYPWQsc3VwZXIucmFkaXVzWT1kfX19LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgYT10KDIyNiksbD10KDIxMyksTT10KDI0Nyk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2Z1bmN0aW9uIFQodSxjLE8pe3JldHVybiBjIGluIHU/T2JqZWN0LmRlZmluZVByb3BlcnR5KHUsYyx7dmFsdWU6TyxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnVbY109Tyx1fWNsYXNzIGQgZXh0ZW5kcyBhLmRlZmF1bHR7Z2V0IGlzVmlzaWJsZSgpe2NvbnN0e2lubmVyUmFkaXVzOmMsb3V0ZXJSYWRpdXM6TyxzdGFydEFuZ2xlOmYsZW5kQW5nbGU6Z309dGhpcy5hdHRyaWJ1dGVzO3JldHVybihjPjB8fE8+MCkmJmYhPT1nJiZzdXBlci5pc1Zpc2libGV9fVQoZCwiQXR0ciIsTS5kZWZhdWx0KSxsLmRlZmF1bHQucmVnaXN0ZXJOb2RlKGQsInJpbmciKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pO3ZhciBhPXQoMTIpLGw9dCgyMjgpLE09dCg3Mik7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IFQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlRGVmYXVsdCIpLGQ9U3ltYm9sLmZvcigic3ByaXRlanNfc2V0QXR0cmlidXRlIiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19nZXRBdHRyaWJ1dGUiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2RlY2xhcmVBbGlhcyIpO2Z1bmN0aW9uIE8oZyl7bGV0e2lubmVyUmFkaXVzOnYsb3V0ZXJSYWRpdXM6QyxzdGFydEFuZ2xlOnAsZW5kQW5nbGU6aH09Zztjb25zdCBtPW5ldyBhLkZpZ3VyZTJEO2lmKHA9TWF0aC5QSSpwLzE4MCxoPU1hdGguUEkqaC8xODAsdj5DJiYoW3YsQ109W0Msdl0pLHY8PTAmJm0ubW92ZVRvKDAsMCksbS5hcmMoMCwwLEMscCxoLCExKSx2PjApe2NvbnN0IG49TWF0aC5QSSoyO2g8cCYmKGg9cCtuKyhoLXApJW4pLGgtcD49biYmKGg9cCtuLTFlLTYpLG0uYXJjKDAsMCx2LGgscCwhMCl9cmV0dXJuIG0uY2xvc2VQYXRoKCksbS5wYXRoLnJlZHVjZSgobixzKT0+bitzLmpvaW4oIiAiKSwiIil9Y2xhc3MgZiBleHRlbmRzIGwuZGVmYXVsdHtjb25zdHJ1Y3Rvcih2KXtzdXBlcih2KSx0aGlzW1RdKHtpbm5lclJhZGl1czowLG91dGVyUmFkaXVzOjAsc3RhcnRBbmdsZTowLGVuZEFuZ2xlOjM2MH0pLHRoaXNbY10oInJhZGl1cyIsImFuZ2xlIil9Z2V0IGQoKXtyZXR1cm4gdGhpc1t1XSgiZCIpfXNldCBkKHYpe31nZXQgaW5uZXJSYWRpdXMoKXtyZXR1cm4gdGhpc1t1XSgiaW5uZXJSYWRpdXMiKX1zZXQgaW5uZXJSYWRpdXModil7aWYodj1PYmplY3QoTS50b051bWJlcikodiksdGhpc1tkXSgiaW5uZXJSYWRpdXMiLHYpKXtjb25zdCBDPU8odGhpcyk7dGhpc1tkXSgiZCIsQyl9fWdldCBvdXRlclJhZGl1cygpe3JldHVybiB0aGlzW3VdKCJvdXRlclJhZGl1cyIpfXNldCBvdXRlclJhZGl1cyh2KXtpZih2PU9iamVjdChNLnRvTnVtYmVyKSh2KSx0aGlzW2RdKCJvdXRlclJhZGl1cyIsdikpe2NvbnN0IEM9Tyh0aGlzKTt0aGlzW2RdKCJkIixDKX19Z2V0IHJhZGl1cygpe3JldHVyblt0aGlzLmlubmVyUmFkaXVzLHRoaXMub3V0ZXJSYWRpdXNdfXNldCByYWRpdXModil7dj1PYmplY3QoTS50b0FycmF5KSh2LCEwKSxBcnJheS5pc0FycmF5KHYpfHwodj1bdix2XSksdGhpcy5pbm5lclJhZGl1cz12WzBdLHRoaXMub3V0ZXJSYWRpdXM9dlsxXX1nZXQgc3RhcnRBbmdsZSgpe3JldHVybiB0aGlzW3VdKCJzdGFydEFuZ2xlIil9c2V0IHN0YXJ0QW5nbGUodil7aWYodj1PYmplY3QoTS50b051bWJlcikodiksdGhpc1tkXSgic3RhcnRBbmdsZSIsdikpe2NvbnN0IEM9Tyh0aGlzKTt0aGlzW2RdKCJkIixDKX19Z2V0IGVuZEFuZ2xlKCl7cmV0dXJuIHRoaXNbdV0oImVuZEFuZ2xlIil9c2V0IGVuZEFuZ2xlKHYpe2lmKHY9T2JqZWN0KE0udG9OdW1iZXIpKHYpLHRoaXNbZF0oImVuZEFuZ2xlIix2KSl7Y29uc3QgQz1PKHRoaXMpO3RoaXNbZF0oImQiLEMpfX1nZXQgYW5nbGUoKXtyZXR1cm5bdGhpcy5zdGFydEFuZ2xlLHRoaXMuZW5kQW5nbGVdfXNldCBhbmdsZSh2KXt2PU9iamVjdChNLnRvQXJyYXkpKHYpLEFycmF5LmlzQXJyYXkodil8fCh2PVt2LHZdKSx0aGlzLnN0YXJ0QW5nbGU9dlswXSx0aGlzLmVuZEFuZ2xlPXZbMV19fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pO3ZhciBhPXQoMTIpLGw9dCgyMTgpLE09dCgyMTkpLFQ9dCgyNDkpLGQ9dCgyMTMpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KHAsaCxtKXtyZXR1cm4gaCBpbiBwP09iamVjdC5kZWZpbmVQcm9wZXJ0eShwLGgse3ZhbHVlOm0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpwW2hdPW0scH1jb25zdCBjPVN5bWJvbCgidGV4dEltYWdlIiksTz1TeW1ib2woInRleHRJbWFnZVRhc2siKSxmPVN5bWJvbCgidGV4dHVyZUNvbnRleHQiKSxnPVN5bWJvbCgidXBkYXRlVGV4dHVyZVJlY3QiKSx2PVN5bWJvbCgidGV4dENhbnZhcyIpO2NsYXNzIEMgZXh0ZW5kcyBNLmRlZmF1bHR7Y29uc3RydWN0b3IoaD17fSl7dHlwZW9mIGg9PSJzdHJpbmciJiYoaD17dGV4dDpofSksc3VwZXIoaCl9Z2V0IGNvbnRlbnRTaXplKCl7bGV0W2gsbV09c3VwZXIuY29udGVudFNpemU7Y29uc3R7d2lkdGg6cixoZWlnaHQ6aX09dGhpcy5hdHRyaWJ1dGVzO2lmKHI9PW51bGx8fGk9PW51bGwpe2NvbnN0IG49dGhpc1tjXTtuJiYocj09bnVsbCYmKGg9bi5yZWN0WzJdKSxpPT1udWxsJiYobT1uLnJlY3RbM10pKX1yZXR1cm5baCxtXX1nZXQgdGV4dCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMudGV4dH1zZXQgdGV4dChoKXt0aGlzLmF0dHJpYnV0ZXMudGV4dD1ofWdldCB0ZXh0Q29udGVudCgpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMudGV4dH1zZXQgdGV4dENvbnRlbnQoaCl7dGhpcy5hdHRyaWJ1dGVzLnRleHQ9aH1nZXQgdGV4dEltYWdlKCl7cmV0dXJuIHRoaXNbY118fHt9fWdldCB0ZXh0SW1hZ2VSZWFkeSgpe3JldHVybiB0aGlzW09dfHxQcm9taXNlLnJlc29sdmUoKX1kcmF3KGgpe3N1cGVyLmRyYXcoaCk7Y29uc3QgbT10aGlzLm1lc2g7aWYobSl7Y29uc3Qgcj10aGlzW2NdO2lmKHIpe2xldCBpPW0udGV4dHVyZTtpZighaXx8dGhpc1tmXSYmdGhpc1tmXSE9PXRoaXMucmVuZGVyZXJ8fHIubmVlZHNVcGRhdGU/KHIubmVlZHNVcGRhdGU9ITEsT2JqZWN0KGwuZGVsZXRlVGV4dHVyZSkoci5pbWFnZSx0aGlzLnJlbmRlcmVyKSxpPU9iamVjdChsLmNyZWF0ZVRleHR1cmUpKHIuaW1hZ2UsdGhpcy5yZW5kZXJlciksdGhpc1tnXT0hMCk6aT1tLnVuaWZvcm1zLnVfdGV4U2FtcGxlcix0aGlzW2ddKXtjb25zdFtuLHNdPXIucmVjdC5zbGljZSgyKSxbeCxQXT10aGlzLmNvbnRlbnRTaXplLFI9dGhpcy5hdHRyaWJ1dGVzLnRleHRBbGlnbixiPXRoaXMuYXR0cmlidXRlcy52ZXJ0aWNhbEFsaWduO2xldCBFPTA7Uj09PSJjZW50ZXIiP0U9KHgtbikvMjooUj09PSJyaWdodCJ8fFI9PT0iZW5kIikmJihFPXgtbik7Y29uc3QgRD10aGlzLmF0dHJpYnV0ZXMuZm9udFNpemUsST10aGlzLmF0dHJpYnV0ZXMubGluZUhlaWdodDtsZXQgUz0wO2I9PT0idG9wIj9TPShELUkpLzI6Yj09PSJib3R0b20iJiYoUz0oSS1EKS8yKTtjb25zdHtwYWRkaW5nTGVmdDpBLHBhZGRpbmdUb3A6VX09dGhpcy5hdHRyaWJ1dGVzLHtib3JkZXJXaWR0aDpLfT10aGlzLmF0dHJpYnV0ZXM7RSs9QStLLFMrPVUrSztjb25zdHthbmNob3JYOlYsYW5jaG9yWTpKfT10aGlzLmF0dHJpYnV0ZXM7RS09dGhpcy5vZmZzZXRTaXplWzBdKlYsUy09dGhpcy5vZmZzZXRTaXplWzFdKkosbS5zZXRUZXh0dXJlKGkse3JlY3Q6W0UsUyxuLHNdfSksdGhpc1tnXT0hMSx0aGlzW2ZdPXRoaXMucmVuZGVyZXJ9fX1yZXR1cm4gaH1vblByb3BlcnR5Q2hhbmdlKGgsbSxyKXtoPT09InRleHQifHxoPT09ImZvbnRTaXplInx8aD09PSJmb250RmFtaWx5Inx8aD09PSJmb250U3R5bGUifHxoPT09ImZvbnRWYXJpYW50Inx8aD09PSJmb250V2VpZ2h0Inx8aD09PSJmb250U3RyZXRjaCJ8fGg9PT0ibGluZUhlaWdodCJ8fGg9PT0ic3Ryb2tlQ29sb3IifHxoPT09ImZpbGxDb2xvciJ8fGg9PT0ic3Ryb2tlV2lkdGgiP3RoaXMudXBkYXRlVGV4dCgpOigoaD09PSJ0ZXh0QWxpZ24ifHxoPT09InZlcnRpY2FsQWxpZ24iKSYmKHRoaXNbZ109ITApLHN1cGVyLm9uUHJvcGVydHlDaGFuZ2UoaCxtLHIpKX11cGRhdGVDb250b3Vycygpe3N1cGVyLnVwZGF0ZUNvbnRvdXJzKCksdGhpc1tnXT0hMH11cGRhdGVUZXh0KCl7dGhpc1tPXXx8KHRoaXNbT109UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e3RoaXNbT109bnVsbDtjb25zdHt0ZXh0OmgsZm9udDptLGZpbGxDb2xvcjpyLHN0cm9rZUNvbG9yOmksc3Ryb2tlV2lkdGg6bn09dGhpcy5hdHRyaWJ1dGVzLHM9dGhpcy5sYXllcj90aGlzLmxheWVyLmRpc3BsYXlSYXRpbzoxO3JldHVybiB0aGlzW3ZdPXRoaXNbdl18fGEuRU5WLmNyZWF0ZUNhbnZhcygxLDEpLHRoaXNbY109YS5FTlYuY3JlYXRlVGV4dChoLHtmb250Om0sZmlsbENvbG9yOnIsc3Ryb2tlQ29sb3I6aSxzdHJva2VXaWR0aDpuLHBhcnNlRm9udDphLnBhcnNlRm9udCxyYXRpbzpzLHRleHRDYW52YXM6dGhpc1t2XX0pLHRoaXNbY10ubmVlZHNVcGRhdGU9ITAsdGhpcy51cGRhdGVDb250b3VycygpLHRoaXMuZm9yY2VVcGRhdGUoKSx0aGlzW2NdfSkpfX11KEMsIkF0dHIiLFQuZGVmYXVsdCksZC5kZWZhdWx0LnJlZ2lzdGVyTm9kZShDLCJsYWJlbCIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBmfSk7dmFyIGE9dCgxMiksbD10KDcyKSxNPXQoMjIxKSxUPXQoMjIwKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgZD1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGVEZWZhdWx0IiksdT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxjPVN5bWJvbC5mb3IoInNwcml0ZWpzX2dldEF0dHJpYnV0ZSIpLE89U3ltYm9sLmZvcigic3ByaXRlanNfZGVjbGFyZUFsaWFzIik7Y2xhc3MgZiBleHRlbmRzIFQuZGVmYXVsdHtjb25zdHJ1Y3Rvcih2KXtzdXBlcih2KSx0aGlzW2RdKHt0ZXh0OiIiLGZvbnRTaXplOjE2LGZvbnRGYW1pbHk6IkhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmIixmb250U3R5bGU6Im5vcm1hbCIsZm9udFZhcmlhbnQ6Im5vcm1hbCIsZm9udFdlaWdodDoibm9ybWFsIixmb250U3RyZXRjaDoibm9ybWFsIixsaW5lSGVpZ2h0OiIiLHRleHRBbGlnbjoibGVmdCIsc3Ryb2tlQ29sb3I6dm9pZCAwLHN0cm9rZVdpZHRoOjEsZmlsbENvbG9yOnZvaWQgMCx2ZXJ0aWNhbEFsaWduOiJtaWRkbGUifSksdGhpc1tPXSgiZm9udCIpfWdldCB0ZXh0KCl7cmV0dXJuIHRoaXNbY10oInRleHQiKXx8IiAifXNldCB0ZXh0KHYpe3RoaXNbdV0oInRleHQiLHYpfWdldCBmb250U2l6ZSgpe3JldHVybiB0aGlzW2NdKCJmb250U2l6ZSIpfXNldCBmb250U2l6ZSh2KXt0aGlzW3VdKCJmb250U2l6ZSIsT2JqZWN0KGwudG9OdW1iZXIpKHYpKX1nZXQgZm9udEZhbWlseSgpe3JldHVybiB0aGlzW2NdKCJmb250RmFtaWx5Iil9c2V0IGZvbnRGYW1pbHkodil7dGhpc1t1XSgiZm9udEZhbWlseSIsdil9Z2V0IGZvbnRTdHlsZSgpe3JldHVybiB0aGlzW2NdKCJmb250U3R5bGUiKX1zZXQgZm9udFN0eWxlKHYpe3RoaXNbdV0oImZvbnRTdHlsZSIsdil9Z2V0IGZvbnRWYXJpYW50KCl7cmV0dXJuIHRoaXNbY10oImZvbnRWYXJpYW50Iil9c2V0IGZvbnRWYXJpYW50KHYpe3RoaXNbdV0oImZvbnRWYXJpYW50Iix2KX1nZXQgZm9udFdlaWdodCgpe3JldHVybiB0aGlzW2NdKCJmb250V2VpZ2h0Iil9c2V0IGZvbnRXZWlnaHQodil7dGhpc1t1XSgiZm9udFdlaWdodCIsdil9Z2V0IGZvbnRTdHJldGNoKCl7cmV0dXJuIHRoaXNbY10oImZvbnRTdHJldGNoIil9c2V0IGZvbnRTdHJldGNoKHYpe3RoaXNbdV0oImZvbnRTdHJldGNoIix2KX1nZXQgbGluZUhlaWdodCgpe3JldHVybiB0aGlzW2NdKCJsaW5lSGVpZ2h0Iil8fHRoaXMuZm9udFNpemV9c2V0IGxpbmVIZWlnaHQodil7dGhpc1t1XSgibGluZUhlaWdodCIsT2JqZWN0KGwudG9OdW1iZXIpKHYpKX1nZXQgdGV4dEFsaWduKCl7cmV0dXJuIHRoaXNbY10oInRleHRBbGlnbiIpfXNldCB0ZXh0QWxpZ24odil7dGhpc1t1XSgidGV4dEFsaWduIix2KX1nZXQgc3Ryb2tlQ29sb3IoKXtyZXR1cm4gdGhpc1tjXSgic3Ryb2tlQ29sb3IiKX1zZXQgc3Ryb2tlQ29sb3Iodil7dGhpc1t1XSgic3Ryb2tlQ29sb3IiLE9iamVjdChNLnBhcnNlQ29sb3IpKHYpKX1nZXQgc3Ryb2tlV2lkdGgoKXtyZXR1cm4gdGhpc1tjXSgic3Ryb2tlV2lkdGgiKX1zZXQgc3Ryb2tlV2lkdGgodil7dGhpc1t1XSgic3Ryb2tlV2lkdGgiLE9iamVjdChsLnRvTnVtYmVyKSh2KSl9Z2V0IHZlcnRpY2FsQWxpZ24oKXtyZXR1cm4gdGhpc1tjXSgidmVydGljYWxBbGlnbiIpfXNldCB2ZXJ0aWNhbEFsaWduKHYpe3RoaXNbdV0oInZlcnRpY2FsQWxpZ24iLHYpfWdldCBmaWxsQ29sb3IoKXtyZXR1cm4gdGhpc1tjXSgiZmlsbENvbG9yIil9c2V0IGZpbGxDb2xvcih2KXt0aGlzW3VdKCJmaWxsQ29sb3IiLE9iamVjdChNLnBhcnNlQ29sb3IpKHYpKX1nZXQgZm9udCgpe2NvbnN0e2ZvbnRTdHlsZTp2LGZvbnRWYXJpYW50OkMsZm9udFdlaWdodDpwLGZvbnRTdHJldGNoOmgsZm9udFNpemU6bSxsaW5lSGVpZ2h0OnIsZm9udEZhbWlseTppfT10aGlzO3JldHVybmAke3Z9ICR7Q30gJHtwfSAke2h9ICR7bX1weC8ke3J9cHggJHtpfWB9c2V0IGZvbnQodil7aWYodj09bnVsbCl0aGlzLmZvbnRTdHlsZT1udWxsLHRoaXMuZm9udFZhcmlhbnQ9bnVsbCx0aGlzLmZvbnRXZWlnaHQ9bnVsbCx0aGlzLmZvbnRTdHJldGNoPW51bGwsdGhpcy5mb250U2l6ZT1udWxsLHRoaXMubGluZUhlaWdodD1udWxsLHRoaXMuZm9udEZhbWlseT1udWxsO2Vsc2V7Y29uc3QgQz1PYmplY3QoYS5wYXJzZUZvbnQpKHYpO3RoaXMuZm9udFN0eWxlPUMuc3R5bGUsdGhpcy5mb250VmFyaWFudD1DLnZhcmlhbnQsdGhpcy5mb250V2VpZ2h0PUMud2VpZ2h0LHRoaXMuZm9udFN0cmV0Y2g9Qy5zdHJldGNoLHRoaXMuZm9udFNpemU9T2JqZWN0KGwudG9OdW1iZXIpKGAke0Muc2l6ZX0ke0MudW5pdH1gKSxDLmxpbmVIZWlnaHQmJih0aGlzLmxpbmVIZWlnaHQ9Qy5weExpbmVIZWlnaHQpLHRoaXMuZm9udEZhbWlseT1DLmZhbWlseX19fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pO3ZhciBhPXQoMTIpLGw9dCgyMTkpLE09dCgyNTEpLFQ9dCgyMTMpLGQ9dCgyNTIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KEMscCxoKXtyZXR1cm4gcCBpbiBDP09iamVjdC5kZWZpbmVQcm9wZXJ0eShDLHAse3ZhbHVlOmgsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpDW3BdPWgsQ31jb25zdCBjPVN5bWJvbCgiek9yZGVyIiksTz1TeW1ib2woIm9yZGVyZWQiKSxmPVN5bWJvbCgiY2hpbGRyZW4iKSxnPVN5bWJvbCgic2VhbGVkIik7Y2xhc3MgdiBleHRlbmRzIGwuZGVmYXVsdHtjb25zdHJ1Y3RvcihwPXt9KXtzdXBlcihwKSx0aGlzW2ZdPVtdLHRoaXNbT109bnVsbCx0aGlzW2NdPTB9Z2V0IGNoaWxkTm9kZXMoKXtyZXR1cm4gdGhpc1tmXX1nZXQgY2hpbGRyZW4oKXtyZXR1cm4gdGhpc1tmXX1nZXQgb3JkZXJlZENoaWxkcmVuKCl7cmV0dXJuIHRoaXNbT118fCh0aGlzW09dPVsuLi50aGlzW2ZdXSx0aGlzW09dLnNvcnQoKHAsaCk9PnAuekluZGV4LWguekluZGV4fHxwLnpPcmRlci1oLnpPcmRlcikpLHRoaXNbT119YXBwZW5kKC4uLnApe3JldHVybiBwLm1hcChoPT50aGlzLmFwcGVuZENoaWxkKGgpKX1hcHBlbmRDaGlsZChwKXtyZXR1cm4gcC5yZW1vdmUoKSx0aGlzW2ZdLnB1c2gocCkscC5jb25uZWN0KHRoaXMsdGhpc1tjXSsrKSx0aGlzW09dJiYodGhpc1tPXS5sZW5ndGgmJnAuekluZGV4PHRoaXNbT11bdGhpc1tPXS5sZW5ndGgtMV0uekluZGV4P3RoaXMucmVvcmRlcigpOnRoaXNbT10ucHVzaChwKSkscH1jbG9uZU5vZGUocD0hMSl7Y29uc3QgaD1zdXBlci5jbG9uZU5vZGUoKTtyZXR1cm4gcCYmdGhpc1tmXS5mb3JFYWNoKG09Pntjb25zdCByPW0uY2xvbmVOb2RlKHApO2guYXBwZW5kQ2hpbGQocil9KSxofWRpc3BhdGNoUG9pbnRlckV2ZW50KHApe2NvbnN0IGg9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBtPWgubGVuZ3RoLTE7bT49MDttLS0paWYoaFttXS5kaXNwYXRjaFBvaW50ZXJFdmVudChwKSlyZXR1cm4hMDtyZXR1cm4gc3VwZXIuZGlzcGF0Y2hQb2ludGVyRXZlbnQocCl9ZHJhdyhwPVtdKXtpZih0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg9dGhpcy5yZW5kZXJNYXRyaXgsc3VwZXIuZHJhdyhwKSwhdGhpc1tnXSYmdGhpcy5hdHRyaWJ1dGVzLmRpc3BsYXkhPT0ibm9uZSIpe2NvbnN0IGg9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBtPTA7bTxoLmxlbmd0aDttKyspaFttXS5kcmF3KHApfXJldHVybiB0aGlzLl9fY2FjaGVSZW5kZXJNYXRyaXg9bnVsbCxwfWdldEVsZW1lbnRCeUlkKHApe3JldHVybiBPYmplY3QoZC5xdWVyeVNlbGVjdG9yKShgIyR7cH1gLHRoaXMpfWdldEVsZW1lbnRzQnlDbGFzc05hbWUocCl7cmV0dXJuIE9iamVjdChkLnF1ZXJ5U2VsZWN0b3JBbGwpKGAuJHtwfWAsdGhpcyl9Z2V0RWxlbWVudHNCeU5hbWUocCl7cmV0dXJuIE9iamVjdChkLnF1ZXJ5U2VsZWN0b3JBbGwpKGBbbmFtZT0iJHtwfSJdYCx0aGlzKX1nZXRFbGVtZW50c0J5VGFnTmFtZShwKXtyZXR1cm4gT2JqZWN0KGQucXVlcnlTZWxlY3RvckFsbCkocCx0aGlzKX1pbnNlcnRCZWZvcmUocCxoKXtpZihoPT1udWxsKXJldHVybiB0aGlzLmFwcGVuZENoaWxkKHApO3AucmVtb3ZlKCk7Y29uc3QgbT10aGlzW2ZdLmluZGV4T2YoaCk7aWYobTwwKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCByZWZlcmVuY2Ugbm9kZS4iKTtjb25zdCByPWguek9yZGVyO2ZvcihsZXQgaT1tO2k8dGhpc1tmXS5sZW5ndGg7aSsrKXtjb25zdCBuPXRoaXNbZl1baV0uek9yZGVyLHM9dGhpc1tmXVtpXTtkZWxldGUgcy56T3JkZXIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsInpPcmRlciIse3ZhbHVlOm4rMSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX1pZih0aGlzW2ZdLnNwbGljZShtLDAscCkscC5jb25uZWN0KHRoaXMsciksdGhpc1tPXSlpZihwLnpJbmRleCE9PWguekluZGV4KXRoaXMucmVvcmRlcigpO2Vsc2V7Y29uc3QgaT10aGlzW09dLmluZGV4T2YoaCk7dGhpc1tPXS5zcGxpY2UoaSwwLHApfXJldHVybiBwfXF1ZXJ5U2VsZWN0b3IocCl7cmV0dXJuIE9iamVjdChkLnF1ZXJ5U2VsZWN0b3IpKHAsdGhpcyl9cXVlcnlTZWxlY3RvckFsbChwKXtyZXR1cm4gT2JqZWN0KGQucXVlcnlTZWxlY3RvckFsbCkocCx0aGlzKX1yZXBsYWNlQ2hpbGQocCxoKXtwLnJlbW92ZSgpO2NvbnN0IG09dGhpc1tmXS5pbmRleE9mKGgpO2lmKG08MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcmVmZXJlbmNlIG5vZGUuIik7aWYodGhpc1tmXVttXT1wLHAuY29ubmVjdCh0aGlzLGguek9yZGVyKSx0aGlzW09dKWlmKHAuekluZGV4IT09aC56SW5kZXgpdGhpcy5yZW9yZGVyKCk7ZWxzZXtjb25zdCByPXRoaXNbT10uaW5kZXhPZihoKTt0aGlzW09dW3JdPXB9cmV0dXJuIGguZGlzY29ubmVjdCh0aGlzKSxwfXJlbW92ZUFsbENoaWxkcmVuKCl7Y29uc3QgcD10aGlzW2ZdO2ZvcihsZXQgaD1wLmxlbmd0aC0xO2g+PTA7aC0tKXBbaF0ucmVtb3ZlKCl9cmVtb3ZlQ2hpbGQocCl7Y29uc3QgaD10aGlzW2ZdLmluZGV4T2YocCk7aWYoaD49MCl7aWYodGhpc1tmXS5zcGxpY2UoaCwxKSx0aGlzW09dKXtjb25zdCBtPXRoaXNbT10uaW5kZXhPZihwKTt0aGlzW09dLnNwbGljZShtLDEpfXJldHVybiBwLmRpc2Nvbm5lY3QodGhpcykscH1yZXR1cm4gbnVsbH1yZW9yZGVyKCl7dGhpc1tPXT1udWxsfXNlYWwoKXtmdW5jdGlvbiBwKGksbil7Y29uc3Qgcz1bXTtmb3IobGV0IHg9MDt4PGkubGVuZ3RoO3grKyl7Y29uc3QgUD1bLi4uaVt4XV07Zm9yKGxldCBSPTE7UjxQLmxlbmd0aDtSKz0yKXtjb25zdCBiPVBbUl0sRT1QW1IrMV07UFtSXT1iKm5bMF0rRSpuWzJdK25bNF0sUFtSKzFdPWIqblsxXStFKm5bM10rbls1XX1zLnB1c2goUCl9cmV0dXJuIHN9Y29uc3QgaD10aGlzLm9yZGVyZWRDaGlsZHJlbixtPW5ldyBhLkZpZ3VyZTJELHI9dGhpcy5sb2NhbE1hdHJpeDtmb3IobGV0IGk9MDtpPGgubGVuZ3RoO2krKyl7bGV0IG49aFtpXTtpZihuIGluc3RhbmNlb2YgdiYmKG49bi5zZWFsKCkpLG4uY2xpZW50Qm94KXtsZXQgcz1uLmNsaWVudEJveC5jb250b3Vycy5wYXRoO3M9cChzLG4ubG9jYWxNYXRyaXgpLG0uYWRkUGF0aChzKX1pZihuLnBhdGgpe2xldCBzPW4ucGF0aC5jb250b3Vycy5wYXRoO3M9cChzLG4ubG9jYWxNYXRyaXgpLG0uYWRkUGF0aChzKX19cmV0dXJuIHRoaXNbZ109ITAsdGhpcy5jbGllbnRCb3g9bSx7Y2xpZW50Qm94Om0sbG9jYWxNYXRyaXg6cn19c2V0UmVzb2x1dGlvbih7d2lkdGg6cCxoZWlnaHQ6aH0pe3N1cGVyLnNldFJlc29sdXRpb24oe3dpZHRoOnAsaGVpZ2h0Omh9KSx0aGlzW2ZdLmZvckVhY2gobT0+e20uc2V0UmVzb2x1dGlvbih7d2lkdGg6cCxoZWlnaHQ6aH0pfSl9dXBkYXRlQ29udG91cnMoKXt0aGlzW2ddfHxzdXBlci51cGRhdGVDb250b3VycygpfX11KHYsIkF0dHIiLE0uZGVmYXVsdCksVC5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh2LCJncm91cCIpfSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiBsfSk7dmFyIGE9dCgyMjApO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtjbGFzcyBsIGV4dGVuZHMgYS5kZWZhdWx0e319LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsInF1ZXJ5U2VsZWN0b3JBbGwiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9KSx0LmQoZSwicXVlcnlTZWxlY3RvciIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHQuZChlLCJpc01hdGNoZWQiLGZ1bmN0aW9uKCl7cmV0dXJuIEN9KSx0LmQoZSwiY29tcGlsZSIsZnVuY3Rpb24oKXtyZXR1cm4gcH0pO3ZhciBhPXQoMjIxKSxsPXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgTT10KDI1Myk7ZnVuY3Rpb24gVChoKXtyZXR1cm4gaC5ub2RlVHlwZT09PTF8fGwuZGVmYXVsdC5pc1Nwcml0ZU5vZGUoaC5ub2RlTmFtZSl9ZnVuY3Rpb24gZChoKXtyZXR1cm4gQXJyYXkuZnJvbShoLmNoaWxkTm9kZXN8fFtdKX1mdW5jdGlvbiB1KGgpe3JldHVybiBsLmRlZmF1bHQuaXNTcHJpdGVOb2RlKGgubm9kZU5hbWUpP2gucGFyZW50fHxoLmNhbnZhc3x8aC5jb250YWluZXI6aC5wYXJlbnRFbGVtZW50fWZ1bmN0aW9uIGMoaCl7bGV0IG09aC5sZW5ndGgscixpLG47Zm9yKDstLW0+LTE7KXtmb3Iocj1pPWhbbV0saFttXT1udWxsLG49ITA7aTspe2lmKGguaW5kZXhPZihpKT4tMSl7bj0hMSxoLnNwbGljZShtLDEpO2JyZWFrfWk9dShpKX1uJiYoaFttXT1yKX1yZXR1cm4gaH1jb25zdCBPPXtpc1RhZzpULGV4aXN0c09uZShoLG0pe3JldHVybiBtLnNvbWUocj0+VChyKT9oKHIpfHxPLmV4aXN0c09uZShoLGQocikpOiExKX0sZ2V0U2libGluZ3MoaCl7Y29uc3QgbT11KGgpO3JldHVybiBtJiZkKG0pfSxnZXRDaGlsZHJlbjpkLGdldFBhcmVudDp1LGdldEF0dHJpYnV0ZVZhbHVlKGgsbSl7aWYoaC5ub2RlVHlwZT09PTEmJm09PT0iY2xhc3MifHxtPT09ImlkIilyZXR1cm4gaFttXTtpZih0aGlzLmhhc0F0dHJpYihoLG0pKXtsZXQgcj1oLmF0dHJpYnV0ZXNbbV07cmV0dXJuIEFycmF5LmlzQXJyYXkocikmJihyPWBbJHtyLmpvaW4oKX1dYCksU3RyaW5nKHIpfX0saGFzQXR0cmliKGgsbSl7cmV0dXJuIGguYXR0cmlidXRlc1ttXSE9bnVsbH0scmVtb3ZlU3Vic2V0czpjLGdldE5hbWUoaCl7cmV0dXJuIGgudGFnTmFtZT9oLnRhZ05hbWUudG9Mb3dlckNhc2UoKTpudWxsfSxmaW5kT25lOmZ1bmN0aW9uIGgobSxyKXtsZXQgaT1udWxsO2ZvcihsZXQgbj0wLHM9ci5sZW5ndGg7bjxzJiYhaTtuKyspaWYobShyW25dKSlpPXJbbl07ZWxzZXtjb25zdCB4PWQocltuXSk7eCYmeC5sZW5ndGg+MCYmKGk9aChtLHgpKX1yZXR1cm4gaX0sZmluZEFsbDpmdW5jdGlvbiBoKG0scil7bGV0IGk9W107Zm9yKGxldCBuPTAscz1yLmxlbmd0aDtuPHM7bisrKXtpZighVChyW25dKSljb250aW51ZTttKHJbbl0pJiZpLnB1c2gocltuXSk7Y29uc3QgeD1kKHJbbl0pO3gmJihpPWkuY29uY2F0KGgobSx4KSkpfXJldHVybiBpfSxnZXRUZXh0OmZ1bmN0aW9uIGgobSl7cmV0dXJuIEFycmF5LmlzQXJyYXkobSk/bS5tYXAoaCkuam9pbigiIik6VChtKT9oKGQobSkpOm0ubm9kZVR5cGU9PT0zP20ubm9kZVZhbHVlOmwuZGVmYXVsdC5pc1Nwcml0ZU5vZGUobS5ub2RlTmFtZSk/bS50ZXh0OiIifX07ZnVuY3Rpb24gZihoKXtpZih0eXBlb2YgaCE9InN0cmluZyIpcmV0dXJuIGg7bGV0IG09aC5tYXRjaCgvXFsoYmdjb2xvcnxmaWxsQ29sb3J8c3Ryb2tlQ29sb3J8Y29sb3IpXHMqPVxzKlsnIl0/XHcrWyciXT9cXS9nKTtyZXR1cm4gbSYmKG09bS5tYXAocj0+e2NvbnN0IGk9ci5zbGljZSgxLC0xKS5zcGxpdCgiPSIpLG49T2JqZWN0KGEucGFyc2VDb2xvcikoaVsxXS5yZXBsYWNlKC9bJyJdL2csIiIpKTtyZXR1cm5bcixgWyR7aVswXX09IiR7bn0iXWBdfSksbS5mb3JFYWNoKChbcixpXSk9PntoPWgucmVwbGFjZShyLGkpfSkpLG09aC5tYXRjaCgvXFtcdytccyo9XHMqWyciXVxbLis/XF1bJyJdXF0vZyksbSYmKG09bS5tYXAocj0+e2NvbnN0IGk9ci5zbGljZSgxLC0xKS5zcGxpdCgiPSIpLG49aVsxXS5zbGljZSgyLC0yKS5zcGxpdCgvLC9nKS5tYXAocz0+cy50cmltKCkpO3JldHVybltyLGBbJHtpWzBdfT0iWyR7bn1dIl1gXX0pLG0uZm9yRWFjaCgoW3IsaV0pPT57aD1oLnJlcGxhY2UocixpKX0pKSxofWZ1bmN0aW9uIGcoaCxtKXtyZXR1cm4gTS5zZWxlY3RBbGwoZihoKSxtLHthZGFwdGVyOk99KX1mdW5jdGlvbiB2KGgsbSl7cmV0dXJuIE0uc2VsZWN0T25lKGYoaCksbSx7YWRhcHRlcjpPfSl9ZnVuY3Rpb24gQyhoLG0pe3JldHVybiBNLmlzKGgsZihtKSx7YWRhcHRlcjpPfSl9ZnVuY3Rpb24gcChoKXtyZXR1cm4gTS5jb21waWxlKGYoaCkse2FkYXB0ZXI6T30pfX0sZnVuY3Rpb24oTCxlLHQpe0wuZXhwb3J0cz1wO3ZhciBhPXQoMjU0KSxsPXQoMjczKS5mYWxzZUZ1bmMsTT10KDI3NCk7ZnVuY3Rpb24gVChoKXtyZXR1cm4gZnVuY3Rpb24ocixpLG4pe3JldHVybiBpPWl8fHt9LGkuYWRhcHRlcj1pLmFkYXB0ZXJ8fGEsaChyLGksbil9fXZhciBkPVQoTSksdT1UKE0uY29tcGlsZVVuc2FmZSk7ZnVuY3Rpb24gYyhoKXtyZXR1cm4gZnVuY3Rpb24ocixpLG4pe3JldHVybiBuPW58fHt9LG4uYWRhcHRlcj1uLmFkYXB0ZXJ8fGEsdHlwZW9mIHIhPSJmdW5jdGlvbiImJihyPXUocixuLGkpKSxyLnNob3VsZFRlc3ROZXh0U2libGluZ3MmJihpPWYobiYmbi5jb250ZXh0fHxpLG4uYWRhcHRlcikpLEFycmF5LmlzQXJyYXkoaSk/aT1uLmFkYXB0ZXIucmVtb3ZlU3Vic2V0cyhpKTppPW4uYWRhcHRlci5nZXRDaGlsZHJlbihpKSxoKHIsaSxuKX19ZnVuY3Rpb24gTyhoLG0pe3ZhciByPW0uZ2V0U2libGluZ3MoaCk7aWYoIUFycmF5LmlzQXJyYXkocikpcmV0dXJuW107Zm9yKHI9ci5zbGljZSgwKTtyLnNoaWZ0KCkhPT1oOyk7cmV0dXJuIHJ9ZnVuY3Rpb24gZihoLG0pe0FycmF5LmlzQXJyYXkoaCl8fChoPVtoXSk7Zm9yKHZhciByPWguc2xpY2UoMCksaT0wLG49aC5sZW5ndGg7aTxuO2krKyl7dmFyIHM9TyhyW2ldLG0pO3IucHVzaC5hcHBseShyLHMpfXJldHVybiByfXZhciBnPWMoZnVuY3Rpb24obSxyLGkpe3JldHVybiBtPT09bHx8IXJ8fHIubGVuZ3RoPT09MD9bXTppLmFkYXB0ZXIuZmluZEFsbChtLHIpfSksdj1jKGZ1bmN0aW9uKG0scixpKXtyZXR1cm4gbT09PWx8fCFyfHxyLmxlbmd0aD09PTA/bnVsbDppLmFkYXB0ZXIuZmluZE9uZShtLHIpfSk7ZnVuY3Rpb24gQyhoLG0scil7cmV0dXJuIHI9cnx8e30sci5hZGFwdGVyPXIuYWRhcHRlcnx8YSwodHlwZW9mIG09PSJmdW5jdGlvbiI/bTpkKG0scikpKGgpfWZ1bmN0aW9uIHAoaCxtLHIpe3JldHVybiBnKGgsbSxyKX1wLmNvbXBpbGU9ZCxwLmZpbHRlcnM9TS5Qc2V1ZG9zLmZpbHRlcnMscC5wc2V1ZG9zPU0uUHNldWRvcy5wc2V1ZG9zLHAuc2VsZWN0QWxsPWcscC5zZWxlY3RPbmU9dixwLmlzPUMscC5wYXJzZT1kLHAuaXRlcmF0ZT1nLHAuX2NvbXBpbGVVbnNhZmU9dSxwLl9jb21waWxlVG9rZW49TS5jb21waWxlVG9rZW59LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT1MLmV4cG9ydHM7W3QoMjU1KSx0KDI2OCksdCgyNjkpLHQoMjcwKSx0KDI3MSksdCgyNzIpXS5mb3JFYWNoKGZ1bmN0aW9uKGwpe09iamVjdC5rZXlzKGwpLmZvckVhY2goZnVuY3Rpb24oTSl7YVtNXT1sW01dLmJpbmQoYSl9KX0pfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgyNTYpLGw9dCgyNTcpLE09YS5pc1RhZztMLmV4cG9ydHM9e2dldElubmVySFRNTDpULGdldE91dGVySFRNTDpsLGdldFRleHQ6ZH07ZnVuY3Rpb24gVCh1LGMpe3JldHVybiB1LmNoaWxkcmVuP3UuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKE8pe3JldHVybiBsKE8sYyl9KS5qb2luKCIiKToiIn1mdW5jdGlvbiBkKHUpe3JldHVybiBBcnJheS5pc0FycmF5KHUpP3UubWFwKGQpLmpvaW4oIiIpOk0odSk/dS5uYW1lPT09ImJyIj9gCmA6ZCh1LmNoaWxkcmVuKTp1LnR5cGU9PT1hLkNEQVRBP2QodS5jaGlsZHJlbik6dS50eXBlPT09YS5UZXh0P3UuZGF0YToiIn19LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPXtUZXh0OiJ0ZXh0IixEaXJlY3RpdmU6ImRpcmVjdGl2ZSIsQ29tbWVudDoiY29tbWVudCIsU2NyaXB0OiJzY3JpcHQiLFN0eWxlOiJzdHlsZSIsVGFnOiJ0YWciLENEQVRBOiJjZGF0YSIsRG9jdHlwZToiZG9jdHlwZSIsaXNUYWc6ZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZT09PSJ0YWcifHx0LnR5cGU9PT0ic2NyaXB0Inx8dC50eXBlPT09InN0eWxlIn19fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgyNTgpLGw9dCgyNTkpLE09dCgyNjcpO00uZWxlbWVudE5hbWVzLl9fcHJvdG9fXz1udWxsLE0uYXR0cmlidXRlTmFtZXMuX19wcm90b19fPW51bGw7dmFyIFQ9e19fcHJvdG9fXzpudWxsLHN0eWxlOiEwLHNjcmlwdDohMCx4bXA6ITAsaWZyYW1lOiEwLG5vZW1iZWQ6ITAsbm9mcmFtZXM6ITAscGxhaW50ZXh0OiEwLG5vc2NyaXB0OiEwfTtmdW5jdGlvbiBkKGgsbSl7aWYoaCl7dmFyIHI9IiIsaTtmb3IodmFyIG4gaW4gaClpPWhbbl0sciYmKHIrPSIgIiksbS54bWxNb2RlPT09ImZvcmVpZ24iJiYobj1NLmF0dHJpYnV0ZU5hbWVzW25dfHxuKSxyKz1uLChpIT09bnVsbCYmaSE9PSIifHxtLnhtbE1vZGUpJiYocis9Jz0iJysobS5kZWNvZGVFbnRpdGllcz9sLmVuY29kZVhNTChpKTppLnJlcGxhY2UoL1wiL2csIiZxdW90OyIpKSsnIicpO3JldHVybiByfX12YXIgdT17X19wcm90b19fOm51bGwsYXJlYTohMCxiYXNlOiEwLGJhc2Vmb250OiEwLGJyOiEwLGNvbDohMCxjb21tYW5kOiEwLGVtYmVkOiEwLGZyYW1lOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxpc2luZGV4OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0sYz1MLmV4cG9ydHM9ZnVuY3Rpb24oaCxtKXshQXJyYXkuaXNBcnJheShoKSYmIWguY2hlZXJpbyYmKGg9W2hdKSxtPW18fHt9O2Zvcih2YXIgcj0iIixpPTA7aTxoLmxlbmd0aDtpKyspe3ZhciBuPWhbaV07bi50eXBlPT09InJvb3QiP3IrPWMobi5jaGlsZHJlbixtKTphLmlzVGFnKG4pP3IrPWYobixtKTpuLnR5cGU9PT1hLkRpcmVjdGl2ZT9yKz1nKG4pOm4udHlwZT09PWEuQ29tbWVudD9yKz1wKG4pOm4udHlwZT09PWEuQ0RBVEE/cis9QyhuKTpyKz12KG4sbSl9cmV0dXJuIHJ9LE89WyJtaSIsIm1vIiwibW4iLCJtcyIsIm10ZXh0IiwiYW5ub3RhdGlvbi14bWwiLCJmb3JlaWduT2JqZWN0IiwiZGVzYyIsInRpdGxlIl07ZnVuY3Rpb24gZihoLG0pe20ueG1sTW9kZT09PSJmb3JlaWduIiYmKGgubmFtZT1NLmVsZW1lbnROYW1lc1toLm5hbWVdfHxoLm5hbWUsaC5wYXJlbnQmJk8uaW5kZXhPZihoLnBhcmVudC5uYW1lKT49MCYmKG09T2JqZWN0LmFzc2lnbih7fSxtLHt4bWxNb2RlOiExfSkpKSwhbS54bWxNb2RlJiZbInN2ZyIsIm1hdGgiXS5pbmRleE9mKGgubmFtZSk+PTAmJihtPU9iamVjdC5hc3NpZ24oe30sbSx7eG1sTW9kZToiZm9yZWlnbiJ9KSk7dmFyIHI9IjwiK2gubmFtZSxpPWQoaC5hdHRyaWJzLG0pO3JldHVybiBpJiYocis9IiAiK2kpLG0ueG1sTW9kZSYmKCFoLmNoaWxkcmVufHxoLmNoaWxkcmVuLmxlbmd0aD09PTApP3IrPSIvPiI6KHIrPSI+IixoLmNoaWxkcmVuJiYocis9YyhoLmNoaWxkcmVuLG0pKSwoIXVbaC5uYW1lXXx8bS54bWxNb2RlKSYmKHIrPSI8LyIraC5uYW1lKyI+IikpLHJ9ZnVuY3Rpb24gZyhoKXtyZXR1cm4iPCIraC5kYXRhKyI+In1mdW5jdGlvbiB2KGgsbSl7dmFyIHI9aC5kYXRhfHwiIjtyZXR1cm4gbS5kZWNvZGVFbnRpdGllcyYmIShoLnBhcmVudCYmaC5wYXJlbnQubmFtZSBpbiBUKSYmKHI9bC5lbmNvZGVYTUwocikpLHJ9ZnVuY3Rpb24gQyhoKXtyZXR1cm4iPCFbQ0RBVEFbIitoLmNoaWxkcmVuWzBdLmRhdGErIl1dPiJ9ZnVuY3Rpb24gcChoKXtyZXR1cm4iPCEtLSIraC5kYXRhKyItLT4ifX0sZnVuY3Rpb24oTCxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtmdW5jdGlvbiBhKGwpe3JldHVybiBsLnR5cGU9PT0idGFnInx8bC50eXBlPT09InNjcmlwdCJ8fGwudHlwZT09PSJzdHlsZSJ9ZS5pc1RhZz1hLGUuVGV4dD0idGV4dCIsZS5EaXJlY3RpdmU9ImRpcmVjdGl2ZSIsZS5Db21tZW50PSJjb21tZW50IixlLlNjcmlwdD0ic2NyaXB0IixlLlN0eWxlPSJzdHlsZSIsZS5UYWc9InRhZyIsZS5DREFUQT0iY2RhdGEiLGUuRG9jdHlwZT0iZG9jdHlwZSJ9LGZ1bmN0aW9uKEwsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5lbmNvZGU9ZS5kZWNvZGVTdHJpY3Q9ZS5kZWNvZGU9dm9pZCAwO3ZhciBhPXQoMjYwKSxsPXQoMjY2KTtmdW5jdGlvbiBNKE8sZil7cmV0dXJuKCFmfHxmPD0wP2EuZGVjb2RlWE1MOmEuZGVjb2RlSFRNTCkoTyl9ZS5kZWNvZGU9TTtmdW5jdGlvbiBUKE8sZil7cmV0dXJuKCFmfHxmPD0wP2EuZGVjb2RlWE1MOmEuZGVjb2RlSFRNTFN0cmljdCkoTyl9ZS5kZWNvZGVTdHJpY3Q9VDtmdW5jdGlvbiBkKE8sZil7cmV0dXJuKCFmfHxmPD0wP2wuZW5jb2RlWE1MOmwuZW5jb2RlSFRNTCkoTyl9ZS5lbmNvZGU9ZDt2YXIgdT10KDI2Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZVhNTCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZW5jb2RlWE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlbmNvZGVIVE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5lbmNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJlc2NhcGUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmVzY2FwZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZW5jb2RlSFRNTDQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmVuY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImVuY29kZUhUTUw1Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdS5lbmNvZGVIVE1MfX0pO3ZhciBjPXQoMjYwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlWE1MIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVYTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZUhUTUx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUxTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVIVE1MNSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZGVjb2RlSFRNTH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVjb2RlSFRNTDRTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZUhUTUxTdHJpY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsImRlY29kZUhUTUw1U3RyaWN0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWNvZGVIVE1MU3RyaWN0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWNvZGVYTUxTdHJpY3QiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmRlY29kZVhNTH19KX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihmKXtyZXR1cm4gZiYmZi5fX2VzTW9kdWxlP2Y6e2RlZmF1bHQ6Zn19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmRlY29kZUhUTUw9ZS5kZWNvZGVIVE1MU3RyaWN0PWUuZGVjb2RlWE1MPXZvaWQgMDt2YXIgbD1hKHQoMjYxKSksTT1hKHQoMjYyKSksVD1hKHQoMjYzKSksZD1hKHQoMjY0KSk7ZS5kZWNvZGVYTUw9dShULmRlZmF1bHQpLGUuZGVjb2RlSFRNTFN0cmljdD11KGwuZGVmYXVsdCk7ZnVuY3Rpb24gdShmKXt2YXIgZz1PYmplY3Qua2V5cyhmKS5qb2luKCJ8Iiksdj1PKGYpO2crPSJ8I1t4WF1bXFxkYS1mQS1GXSt8I1xcZCsiO3ZhciBDPW5ldyBSZWdFeHAoIiYoPzoiK2crIik7IiwiZyIpO3JldHVybiBmdW5jdGlvbihwKXtyZXR1cm4gU3RyaW5nKHApLnJlcGxhY2UoQyx2KX19dmFyIGM9ZnVuY3Rpb24oZixnKXtyZXR1cm4gZjxnPzE6LTF9O2UuZGVjb2RlSFRNTD1mdW5jdGlvbigpe2Zvcih2YXIgZj1PYmplY3Qua2V5cyhNLmRlZmF1bHQpLnNvcnQoYyksZz1PYmplY3Qua2V5cyhsLmRlZmF1bHQpLnNvcnQoYyksdj0wLEM9MDt2PGcubGVuZ3RoO3YrKylmW0NdPT09Z1t2XT8oZ1t2XSs9Ijs/IixDKyspOmdbdl0rPSI7Ijt2YXIgcD1uZXcgUmVnRXhwKCImKD86IitnLmpvaW4oInwiKSsifCNbeFhdW1xcZGEtZkEtRl0rOz98I1xcZCs7PykiLCJnIiksaD1PKGwuZGVmYXVsdCk7ZnVuY3Rpb24gbShyKXtyZXR1cm4gci5zdWJzdHIoLTEpIT09IjsiJiYocis9IjsiKSxoKHIpfXJldHVybiBmdW5jdGlvbihyKXtyZXR1cm4gU3RyaW5nKHIpLnJlcGxhY2UocCxtKX19KCk7ZnVuY3Rpb24gTyhmKXtyZXR1cm4gZnVuY3Rpb24odil7aWYodi5jaGFyQXQoMSk9PT0iIyIpe3ZhciBDPXYuY2hhckF0KDIpO3JldHVybiBDPT09IlgifHxDPT09IngiP2QuZGVmYXVsdChwYXJzZUludCh2LnN1YnN0cigzKSwxNikpOmQuZGVmYXVsdChwYXJzZUludCh2LnN1YnN0cigyKSwxMCkpfXJldHVybiBmW3Yuc2xpY2UoMSwtMSldfX19LGZ1bmN0aW9uKEwpe0wuZXhwb3J0cz1KU09OLnBhcnNlKCd7IkFhY3V0ZSI6IsOBIiwiYWFjdXRlIjoiw6EiLCJBYnJldmUiOiLEgiIsImFicmV2ZSI6IsSDIiwiYWMiOiLiiL4iLCJhY2QiOiLiiL8iLCJhY0UiOiLiiL7MsyIsIkFjaXJjIjoiw4IiLCJhY2lyYyI6IsOiIiwiYWN1dGUiOiLCtCIsIkFjeSI6ItCQIiwiYWN5Ijoi0LAiLCJBRWxpZyI6IsOGIiwiYWVsaWciOiLDpiIsImFmIjoi4oGhIiwiQWZyIjoi8J2UhCIsImFmciI6IvCdlJ4iLCJBZ3JhdmUiOiLDgCIsImFncmF2ZSI6IsOgIiwiYWxlZnN5bSI6IuKEtSIsImFsZXBoIjoi4oS1IiwiQWxwaGEiOiLOkSIsImFscGhhIjoizrEiLCJBbWFjciI6IsSAIiwiYW1hY3IiOiLEgSIsImFtYWxnIjoi4qi/IiwiYW1wIjoiJiIsIkFNUCI6IiYiLCJhbmRhbmQiOiLiqZUiLCJBbmQiOiLiqZMiLCJhbmQiOiLiiKciLCJhbmRkIjoi4qmcIiwiYW5kc2xvcGUiOiLiqZgiLCJhbmR2Ijoi4qmaIiwiYW5nIjoi4oigIiwiYW5nZSI6IuKmpCIsImFuZ2xlIjoi4oigIiwiYW5nbXNkYWEiOiLipqgiLCJhbmdtc2RhYiI6IuKmqSIsImFuZ21zZGFjIjoi4qaqIiwiYW5nbXNkYWQiOiLipqsiLCJhbmdtc2RhZSI6IuKmrCIsImFuZ21zZGFmIjoi4qatIiwiYW5nbXNkYWciOiLipq4iLCJhbmdtc2RhaCI6IuKmryIsImFuZ21zZCI6IuKIoSIsImFuZ3J0Ijoi4oifIiwiYW5ncnR2YiI6IuKKviIsImFuZ3J0dmJkIjoi4qadIiwiYW5nc3BoIjoi4oiiIiwiYW5nc3QiOiLDhSIsImFuZ3phcnIiOiLijbwiLCJBb2dvbiI6IsSEIiwiYW9nb24iOiLEhSIsIkFvcGYiOiLwnZS4IiwiYW9wZiI6IvCdlZIiLCJhcGFjaXIiOiLiqa8iLCJhcCI6IuKJiCIsImFwRSI6IuKpsCIsImFwZSI6IuKJiiIsImFwaWQiOiLiiYsiLCJhcG9zIjoiXCciLCJBcHBseUZ1bmN0aW9uIjoi4oGhIiwiYXBwcm94Ijoi4omIIiwiYXBwcm94ZXEiOiLiiYoiLCJBcmluZyI6IsOFIiwiYXJpbmciOiLDpSIsIkFzY3IiOiLwnZKcIiwiYXNjciI6IvCdkrYiLCJBc3NpZ24iOiLiiZQiLCJhc3QiOiIqIiwiYXN5bXAiOiLiiYgiLCJhc3ltcGVxIjoi4omNIiwiQXRpbGRlIjoiw4MiLCJhdGlsZGUiOiLDoyIsIkF1bWwiOiLDhCIsImF1bWwiOiLDpCIsImF3Y29uaW50Ijoi4oizIiwiYXdpbnQiOiLiqJEiLCJiYWNrY29uZyI6IuKJjCIsImJhY2tlcHNpbG9uIjoiz7YiLCJiYWNrcHJpbWUiOiLigLUiLCJiYWNrc2ltIjoi4oi9IiwiYmFja3NpbWVxIjoi4ouNIiwiQmFja3NsYXNoIjoi4oiWIiwiQmFydiI6IuKrpyIsImJhcnZlZSI6IuKKvSIsImJhcndlZCI6IuKMhSIsIkJhcndlZCI6IuKMhiIsImJhcndlZGdlIjoi4oyFIiwiYmJyayI6IuKOtSIsImJicmt0YnJrIjoi4o62IiwiYmNvbmciOiLiiYwiLCJCY3kiOiLQkSIsImJjeSI6ItCxIiwiYmRxdW8iOiLigJ4iLCJiZWNhdXMiOiLiiLUiLCJiZWNhdXNlIjoi4oi1IiwiQmVjYXVzZSI6IuKItSIsImJlbXB0eXYiOiLiprAiLCJiZXBzaSI6Is+2IiwiYmVybm91Ijoi4oSsIiwiQmVybm91bGxpcyI6IuKErCIsIkJldGEiOiLOkiIsImJldGEiOiLOsiIsImJldGgiOiLihLYiLCJiZXR3ZWVuIjoi4omsIiwiQmZyIjoi8J2UhSIsImJmciI6IvCdlJ8iLCJiaWdjYXAiOiLii4IiLCJiaWdjaXJjIjoi4pevIiwiYmlnY3VwIjoi4ouDIiwiYmlnb2RvdCI6IuKogCIsImJpZ29wbHVzIjoi4qiBIiwiYmlnb3RpbWVzIjoi4qiCIiwiYmlnc3FjdXAiOiLiqIYiLCJiaWdzdGFyIjoi4piFIiwiYmlndHJpYW5nbGVkb3duIjoi4pa9IiwiYmlndHJpYW5nbGV1cCI6IuKWsyIsImJpZ3VwbHVzIjoi4qiEIiwiYmlndmVlIjoi4ouBIiwiYmlnd2VkZ2UiOiLii4AiLCJia2Fyb3ciOiLipI0iLCJibGFja2xvemVuZ2UiOiLip6siLCJibGFja3NxdWFyZSI6IuKWqiIsImJsYWNrdHJpYW5nbGUiOiLilrQiLCJibGFja3RyaWFuZ2xlZG93biI6IuKWviIsImJsYWNrdHJpYW5nbGVsZWZ0Ijoi4peCIiwiYmxhY2t0cmlhbmdsZXJpZ2h0Ijoi4pa4IiwiYmxhbmsiOiLikKMiLCJibGsxMiI6IuKWkiIsImJsazE0Ijoi4paRIiwiYmxrMzQiOiLilpMiLCJibG9jayI6IuKWiCIsImJuZSI6Ij3ig6UiLCJibmVxdWl2Ijoi4omh4oOlIiwiYk5vdCI6IuKrrSIsImJub3QiOiLijJAiLCJCb3BmIjoi8J2UuSIsImJvcGYiOiLwnZWTIiwiYm90Ijoi4oqlIiwiYm90dG9tIjoi4oqlIiwiYm93dGllIjoi4ouIIiwiYm94Ym94Ijoi4qeJIiwiYm94ZGwiOiLilJAiLCJib3hkTCI6IuKVlSIsImJveERsIjoi4pWWIiwiYm94REwiOiLilZciLCJib3hkciI6IuKUjCIsImJveGRSIjoi4pWSIiwiYm94RHIiOiLilZMiLCJib3hEUiI6IuKVlCIsImJveGgiOiLilIAiLCJib3hIIjoi4pWQIiwiYm94aGQiOiLilKwiLCJib3hIZCI6IuKVpCIsImJveGhEIjoi4pWlIiwiYm94SEQiOiLilaYiLCJib3hodSI6IuKUtCIsImJveEh1Ijoi4pWnIiwiYm94aFUiOiLilagiLCJib3hIVSI6IuKVqSIsImJveG1pbnVzIjoi4oqfIiwiYm94cGx1cyI6IuKKniIsImJveHRpbWVzIjoi4oqgIiwiYm94dWwiOiLilJgiLCJib3h1TCI6IuKVmyIsImJveFVsIjoi4pWcIiwiYm94VUwiOiLilZ0iLCJib3h1ciI6IuKUlCIsImJveHVSIjoi4pWYIiwiYm94VXIiOiLilZkiLCJib3hVUiI6IuKVmiIsImJveHYiOiLilIIiLCJib3hWIjoi4pWRIiwiYm94dmgiOiLilLwiLCJib3h2SCI6IuKVqiIsImJveFZoIjoi4pWrIiwiYm94VkgiOiLilawiLCJib3h2bCI6IuKUpCIsImJveHZMIjoi4pWhIiwiYm94VmwiOiLilaIiLCJib3hWTCI6IuKVoyIsImJveHZyIjoi4pScIiwiYm94dlIiOiLilZ4iLCJib3hWciI6IuKVnyIsImJveFZSIjoi4pWgIiwiYnByaW1lIjoi4oC1IiwiYnJldmUiOiLLmCIsIkJyZXZlIjoiy5giLCJicnZiYXIiOiLCpiIsImJzY3IiOiLwnZK3IiwiQnNjciI6IuKErCIsImJzZW1pIjoi4oGPIiwiYnNpbSI6IuKIvSIsImJzaW1lIjoi4ouNIiwiYnNvbGIiOiLip4UiLCJic29sIjoiXFxcXCIsImJzb2xoc3ViIjoi4p+IIiwiYnVsbCI6IuKAoiIsImJ1bGxldCI6IuKAoiIsImJ1bXAiOiLiiY4iLCJidW1wRSI6IuKqriIsImJ1bXBlIjoi4omPIiwiQnVtcGVxIjoi4omOIiwiYnVtcGVxIjoi4omPIiwiQ2FjdXRlIjoixIYiLCJjYWN1dGUiOiLEhyIsImNhcGFuZCI6IuKphCIsImNhcGJyY3VwIjoi4qmJIiwiY2FwY2FwIjoi4qmLIiwiY2FwIjoi4oipIiwiQ2FwIjoi4ouSIiwiY2FwY3VwIjoi4qmHIiwiY2FwZG90Ijoi4qmAIiwiQ2FwaXRhbERpZmZlcmVudGlhbEQiOiLihYUiLCJjYXBzIjoi4oip77iAIiwiY2FyZXQiOiLigYEiLCJjYXJvbiI6IsuHIiwiQ2F5bGV5cyI6IuKErSIsImNjYXBzIjoi4qmNIiwiQ2Nhcm9uIjoixIwiLCJjY2Fyb24iOiLEjSIsIkNjZWRpbCI6IsOHIiwiY2NlZGlsIjoiw6ciLCJDY2lyYyI6IsSIIiwiY2NpcmMiOiLEiSIsIkNjb25pbnQiOiLiiLAiLCJjY3VwcyI6IuKpjCIsImNjdXBzc20iOiLiqZAiLCJDZG90IjoixIoiLCJjZG90IjoixIsiLCJjZWRpbCI6IsK4IiwiQ2VkaWxsYSI6IsK4IiwiY2VtcHR5diI6IuKmsiIsImNlbnQiOiLCoiIsImNlbnRlcmRvdCI6IsK3IiwiQ2VudGVyRG90IjoiwrciLCJjZnIiOiLwnZSgIiwiQ2ZyIjoi4oStIiwiQ0hjeSI6ItCnIiwiY2hjeSI6ItGHIiwiY2hlY2siOiLinJMiLCJjaGVja21hcmsiOiLinJMiLCJDaGkiOiLOpyIsImNoaSI6Is+HIiwiY2lyYyI6IsuGIiwiY2lyY2VxIjoi4omXIiwiY2lyY2xlYXJyb3dsZWZ0Ijoi4oa6IiwiY2lyY2xlYXJyb3dyaWdodCI6IuKGuyIsImNpcmNsZWRhc3QiOiLiipsiLCJjaXJjbGVkY2lyYyI6IuKKmiIsImNpcmNsZWRkYXNoIjoi4oqdIiwiQ2lyY2xlRG90Ijoi4oqZIiwiY2lyY2xlZFIiOiLCriIsImNpcmNsZWRTIjoi4pOIIiwiQ2lyY2xlTWludXMiOiLiipYiLCJDaXJjbGVQbHVzIjoi4oqVIiwiQ2lyY2xlVGltZXMiOiLiipciLCJjaXIiOiLil4siLCJjaXJFIjoi4qeDIiwiY2lyZSI6IuKJlyIsImNpcmZuaW50Ijoi4qiQIiwiY2lybWlkIjoi4quvIiwiY2lyc2NpciI6IuKngiIsIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCI6IuKIsiIsIkNsb3NlQ3VybHlEb3VibGVRdW90ZSI6IuKAnSIsIkNsb3NlQ3VybHlRdW90ZSI6IuKAmSIsImNsdWJzIjoi4pmjIiwiY2x1YnN1aXQiOiLimaMiLCJjb2xvbiI6IjoiLCJDb2xvbiI6IuKItyIsIkNvbG9uZSI6IuKptCIsImNvbG9uZSI6IuKJlCIsImNvbG9uZXEiOiLiiZQiLCJjb21tYSI6IiwiLCJjb21tYXQiOiJAIiwiY29tcCI6IuKIgSIsImNvbXBmbiI6IuKImCIsImNvbXBsZW1lbnQiOiLiiIEiLCJjb21wbGV4ZXMiOiLihIIiLCJjb25nIjoi4omFIiwiY29uZ2RvdCI6IuKprSIsIkNvbmdydWVudCI6IuKJoSIsImNvbmludCI6IuKIriIsIkNvbmludCI6IuKIryIsIkNvbnRvdXJJbnRlZ3JhbCI6IuKIriIsImNvcGYiOiLwnZWUIiwiQ29wZiI6IuKEgiIsImNvcHJvZCI6IuKIkCIsIkNvcHJvZHVjdCI6IuKIkCIsImNvcHkiOiLCqSIsIkNPUFkiOiLCqSIsImNvcHlzciI6IuKElyIsIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwiOiLiiLMiLCJjcmFyciI6IuKGtSIsImNyb3NzIjoi4pyXIiwiQ3Jvc3MiOiLiqK8iLCJDc2NyIjoi8J2SniIsImNzY3IiOiLwnZK4IiwiY3N1YiI6IuKrjyIsImNzdWJlIjoi4quRIiwiY3N1cCI6IuKrkCIsImNzdXBlIjoi4quSIiwiY3Rkb3QiOiLii68iLCJjdWRhcnJsIjoi4qS4IiwiY3VkYXJyciI6IuKktSIsImN1ZXByIjoi4oueIiwiY3Vlc2MiOiLii58iLCJjdWxhcnIiOiLihrYiLCJjdWxhcnJwIjoi4qS9IiwiY3VwYnJjYXAiOiLiqYgiLCJjdXBjYXAiOiLiqYYiLCJDdXBDYXAiOiLiiY0iLCJjdXAiOiLiiKoiLCJDdXAiOiLii5MiLCJjdXBjdXAiOiLiqYoiLCJjdXBkb3QiOiLiio0iLCJjdXBvciI6IuKphSIsImN1cHMiOiLiiKrvuIAiLCJjdXJhcnIiOiLihrciLCJjdXJhcnJtIjoi4qS8IiwiY3VybHllcXByZWMiOiLii54iLCJjdXJseWVxc3VjYyI6IuKLnyIsImN1cmx5dmVlIjoi4ouOIiwiY3VybHl3ZWRnZSI6IuKLjyIsImN1cnJlbiI6IsKkIiwiY3VydmVhcnJvd2xlZnQiOiLihrYiLCJjdXJ2ZWFycm93cmlnaHQiOiLihrciLCJjdXZlZSI6IuKLjiIsImN1d2VkIjoi4ouPIiwiY3djb25pbnQiOiLiiLIiLCJjd2ludCI6IuKIsSIsImN5bGN0eSI6IuKMrSIsImRhZ2dlciI6IuKAoCIsIkRhZ2dlciI6IuKAoSIsImRhbGV0aCI6IuKEuCIsImRhcnIiOiLihpMiLCJEYXJyIjoi4oahIiwiZEFyciI6IuKHkyIsImRhc2giOiLigJAiLCJEYXNodiI6IuKrpCIsImRhc2h2Ijoi4oqjIiwiZGJrYXJvdyI6IuKkjyIsImRibGFjIjoiy50iLCJEY2Fyb24iOiLEjiIsImRjYXJvbiI6IsSPIiwiRGN5Ijoi0JQiLCJkY3kiOiLQtCIsImRkYWdnZXIiOiLigKEiLCJkZGFyciI6IuKHiiIsIkREIjoi4oWFIiwiZGQiOiLihYYiLCJERG90cmFoZCI6IuKkkSIsImRkb3RzZXEiOiLiqbciLCJkZWciOiLCsCIsIkRlbCI6IuKIhyIsIkRlbHRhIjoizpQiLCJkZWx0YSI6Is60IiwiZGVtcHR5diI6IuKmsSIsImRmaXNodCI6IuKlvyIsIkRmciI6IvCdlIciLCJkZnIiOiLwnZShIiwiZEhhciI6IuKlpSIsImRoYXJsIjoi4oeDIiwiZGhhcnIiOiLih4IiLCJEaWFjcml0aWNhbEFjdXRlIjoiwrQiLCJEaWFjcml0aWNhbERvdCI6IsuZIiwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZSI6IsudIiwiRGlhY3JpdGljYWxHcmF2ZSI6ImAiLCJEaWFjcml0aWNhbFRpbGRlIjoiy5wiLCJkaWFtIjoi4ouEIiwiZGlhbW9uZCI6IuKLhCIsIkRpYW1vbmQiOiLii4QiLCJkaWFtb25kc3VpdCI6IuKZpiIsImRpYW1zIjoi4pmmIiwiZGllIjoiwqgiLCJEaWZmZXJlbnRpYWxEIjoi4oWGIiwiZGlnYW1tYSI6Is+dIiwiZGlzaW4iOiLii7IiLCJkaXYiOiLDtyIsImRpdmlkZSI6IsO3IiwiZGl2aWRlb250aW1lcyI6IuKLhyIsImRpdm9ueCI6IuKLhyIsIkRKY3kiOiLQgiIsImRqY3kiOiLRkiIsImRsY29ybiI6IuKMniIsImRsY3JvcCI6IuKMjSIsImRvbGxhciI6IiQiLCJEb3BmIjoi8J2UuyIsImRvcGYiOiLwnZWVIiwiRG90IjoiwqgiLCJkb3QiOiLLmSIsIkRvdERvdCI6IuKDnCIsImRvdGVxIjoi4omQIiwiZG90ZXFkb3QiOiLiiZEiLCJEb3RFcXVhbCI6IuKJkCIsImRvdG1pbnVzIjoi4oi4IiwiZG90cGx1cyI6IuKIlCIsImRvdHNxdWFyZSI6IuKKoSIsImRvdWJsZWJhcndlZGdlIjoi4oyGIiwiRG91YmxlQ29udG91ckludGVncmFsIjoi4oivIiwiRG91YmxlRG90IjoiwqgiLCJEb3VibGVEb3duQXJyb3ciOiLih5MiLCJEb3VibGVMZWZ0QXJyb3ciOiLih5AiLCJEb3VibGVMZWZ0UmlnaHRBcnJvdyI6IuKHlCIsIkRvdWJsZUxlZnRUZWUiOiLiq6QiLCJEb3VibGVMb25nTGVmdEFycm93Ijoi4p+4IiwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93Ijoi4p+6IiwiRG91YmxlTG9uZ1JpZ2h0QXJyb3ciOiLin7kiLCJEb3VibGVSaWdodEFycm93Ijoi4oeSIiwiRG91YmxlUmlnaHRUZWUiOiLiiqgiLCJEb3VibGVVcEFycm93Ijoi4oeRIiwiRG91YmxlVXBEb3duQXJyb3ciOiLih5UiLCJEb3VibGVWZXJ0aWNhbEJhciI6IuKIpSIsIkRvd25BcnJvd0JhciI6IuKkkyIsImRvd25hcnJvdyI6IuKGkyIsIkRvd25BcnJvdyI6IuKGkyIsIkRvd25hcnJvdyI6IuKHkyIsIkRvd25BcnJvd1VwQXJyb3ciOiLih7UiLCJEb3duQnJldmUiOiLMkSIsImRvd25kb3duYXJyb3dzIjoi4oeKIiwiZG93bmhhcnBvb25sZWZ0Ijoi4oeDIiwiZG93bmhhcnBvb25yaWdodCI6IuKHgiIsIkRvd25MZWZ0UmlnaHRWZWN0b3IiOiLipZAiLCJEb3duTGVmdFRlZVZlY3RvciI6IuKlniIsIkRvd25MZWZ0VmVjdG9yQmFyIjoi4qWWIiwiRG93bkxlZnRWZWN0b3IiOiLihr0iLCJEb3duUmlnaHRUZWVWZWN0b3IiOiLipZ8iLCJEb3duUmlnaHRWZWN0b3JCYXIiOiLipZciLCJEb3duUmlnaHRWZWN0b3IiOiLih4EiLCJEb3duVGVlQXJyb3ciOiLihqciLCJEb3duVGVlIjoi4oqkIiwiZHJia2Fyb3ciOiLipJAiLCJkcmNvcm4iOiLijJ8iLCJkcmNyb3AiOiLijIwiLCJEc2NyIjoi8J2SnyIsImRzY3IiOiLwnZK5IiwiRFNjeSI6ItCFIiwiZHNjeSI6ItGVIiwiZHNvbCI6IuKntiIsIkRzdHJvayI6IsSQIiwiZHN0cm9rIjoixJEiLCJkdGRvdCI6IuKLsSIsImR0cmkiOiLilr8iLCJkdHJpZiI6IuKWviIsImR1YXJyIjoi4oe1IiwiZHVoYXIiOiLipa8iLCJkd2FuZ2xlIjoi4qamIiwiRFpjeSI6ItCPIiwiZHpjeSI6ItGfIiwiZHppZ3JhcnIiOiLin78iLCJFYWN1dGUiOiLDiSIsImVhY3V0ZSI6IsOpIiwiZWFzdGVyIjoi4qmuIiwiRWNhcm9uIjoixJoiLCJlY2Fyb24iOiLEmyIsIkVjaXJjIjoiw4oiLCJlY2lyYyI6IsOqIiwiZWNpciI6IuKJliIsImVjb2xvbiI6IuKJlSIsIkVjeSI6ItCtIiwiZWN5Ijoi0Y0iLCJlRERvdCI6IuKptyIsIkVkb3QiOiLEliIsImVkb3QiOiLElyIsImVEb3QiOiLiiZEiLCJlZSI6IuKFhyIsImVmRG90Ijoi4omSIiwiRWZyIjoi8J2UiCIsImVmciI6IvCdlKIiLCJlZyI6IuKqmiIsIkVncmF2ZSI6IsOIIiwiZWdyYXZlIjoiw6giLCJlZ3MiOiLiqpYiLCJlZ3Nkb3QiOiLiqpgiLCJlbCI6IuKqmSIsIkVsZW1lbnQiOiLiiIgiLCJlbGludGVycyI6IuKPpyIsImVsbCI6IuKEkyIsImVscyI6IuKqlSIsImVsc2RvdCI6IuKqlyIsIkVtYWNyIjoixJIiLCJlbWFjciI6IsSTIiwiZW1wdHkiOiLiiIUiLCJlbXB0eXNldCI6IuKIhSIsIkVtcHR5U21hbGxTcXVhcmUiOiLil7siLCJlbXB0eXYiOiLiiIUiLCJFbXB0eVZlcnlTbWFsbFNxdWFyZSI6IuKWqyIsImVtc3AxMyI6IuKAhCIsImVtc3AxNCI6IuKAhSIsImVtc3AiOiLigIMiLCJFTkciOiLFiiIsImVuZyI6IsWLIiwiZW5zcCI6IuKAgiIsIkVvZ29uIjoixJgiLCJlb2dvbiI6IsSZIiwiRW9wZiI6IvCdlLwiLCJlb3BmIjoi8J2VliIsImVwYXIiOiLii5UiLCJlcGFyc2wiOiLip6MiLCJlcGx1cyI6IuKpsSIsImVwc2kiOiLOtSIsIkVwc2lsb24iOiLOlSIsImVwc2lsb24iOiLOtSIsImVwc2l2Ijoiz7UiLCJlcWNpcmMiOiLiiZYiLCJlcWNvbG9uIjoi4omVIiwiZXFzaW0iOiLiiYIiLCJlcXNsYW50Z3RyIjoi4qqWIiwiZXFzbGFudGxlc3MiOiLiqpUiLCJFcXVhbCI6IuKptSIsImVxdWFscyI6Ij0iLCJFcXVhbFRpbGRlIjoi4omCIiwiZXF1ZXN0Ijoi4omfIiwiRXF1aWxpYnJpdW0iOiLih4wiLCJlcXVpdiI6IuKJoSIsImVxdWl2REQiOiLiqbgiLCJlcXZwYXJzbCI6IuKnpSIsImVyYXJyIjoi4qWxIiwiZXJEb3QiOiLiiZMiLCJlc2NyIjoi4oSvIiwiRXNjciI6IuKEsCIsImVzZG90Ijoi4omQIiwiRXNpbSI6IuKpsyIsImVzaW0iOiLiiYIiLCJFdGEiOiLOlyIsImV0YSI6Is63IiwiRVRIIjoiw5AiLCJldGgiOiLDsCIsIkV1bWwiOiLDiyIsImV1bWwiOiLDqyIsImV1cm8iOiLigqwiLCJleGNsIjoiISIsImV4aXN0Ijoi4oiDIiwiRXhpc3RzIjoi4oiDIiwiZXhwZWN0YXRpb24iOiLihLAiLCJleHBvbmVudGlhbGUiOiLihYciLCJFeHBvbmVudGlhbEUiOiLihYciLCJmYWxsaW5nZG90c2VxIjoi4omSIiwiRmN5Ijoi0KQiLCJmY3kiOiLRhCIsImZlbWFsZSI6IuKZgCIsImZmaWxpZyI6Iu+sgyIsImZmbGlnIjoi76yAIiwiZmZsbGlnIjoi76yEIiwiRmZyIjoi8J2UiSIsImZmciI6IvCdlKMiLCJmaWxpZyI6Iu+sgSIsIkZpbGxlZFNtYWxsU3F1YXJlIjoi4pe8IiwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlIjoi4paqIiwiZmpsaWciOiJmaiIsImZsYXQiOiLima0iLCJmbGxpZyI6Iu+sgiIsImZsdG5zIjoi4paxIiwiZm5vZiI6IsaSIiwiRm9wZiI6IvCdlL0iLCJmb3BmIjoi8J2VlyIsImZvcmFsbCI6IuKIgCIsIkZvckFsbCI6IuKIgCIsImZvcmsiOiLii5QiLCJmb3JrdiI6IuKrmSIsIkZvdXJpZXJ0cmYiOiLihLEiLCJmcGFydGludCI6IuKojSIsImZyYWMxMiI6IsK9IiwiZnJhYzEzIjoi4oWTIiwiZnJhYzE0IjoiwrwiLCJmcmFjMTUiOiLihZUiLCJmcmFjMTYiOiLihZkiLCJmcmFjMTgiOiLihZsiLCJmcmFjMjMiOiLihZQiLCJmcmFjMjUiOiLihZYiLCJmcmFjMzQiOiLCviIsImZyYWMzNSI6IuKFlyIsImZyYWMzOCI6IuKFnCIsImZyYWM0NSI6IuKFmCIsImZyYWM1NiI6IuKFmiIsImZyYWM1OCI6IuKFnSIsImZyYWM3OCI6IuKFniIsImZyYXNsIjoi4oGEIiwiZnJvd24iOiLijKIiLCJmc2NyIjoi8J2SuyIsIkZzY3IiOiLihLEiLCJnYWN1dGUiOiLHtSIsIkdhbW1hIjoizpMiLCJnYW1tYSI6Is6zIiwiR2FtbWFkIjoiz5wiLCJnYW1tYWQiOiLPnSIsImdhcCI6IuKqhiIsIkdicmV2ZSI6IsSeIiwiZ2JyZXZlIjoixJ8iLCJHY2VkaWwiOiLEoiIsIkdjaXJjIjoixJwiLCJnY2lyYyI6IsSdIiwiR2N5Ijoi0JMiLCJnY3kiOiLQsyIsIkdkb3QiOiLEoCIsImdkb3QiOiLEoSIsImdlIjoi4omlIiwiZ0UiOiLiiaciLCJnRWwiOiLiqowiLCJnZWwiOiLii5siLCJnZXEiOiLiiaUiLCJnZXFxIjoi4omnIiwiZ2Vxc2xhbnQiOiLiqb4iLCJnZXNjYyI6IuKqqSIsImdlcyI6IuKpviIsImdlc2RvdCI6IuKqgCIsImdlc2RvdG8iOiLiqoIiLCJnZXNkb3RvbCI6IuKqhCIsImdlc2wiOiLii5vvuIAiLCJnZXNsZXMiOiLiqpQiLCJHZnIiOiLwnZSKIiwiZ2ZyIjoi8J2UpCIsImdnIjoi4omrIiwiR2ciOiLii5kiLCJnZ2ciOiLii5kiLCJnaW1lbCI6IuKEtyIsIkdKY3kiOiLQgyIsImdqY3kiOiLRkyIsImdsYSI6IuKqpSIsImdsIjoi4om3IiwiZ2xFIjoi4qqSIiwiZ2xqIjoi4qqkIiwiZ25hcCI6IuKqiiIsImduYXBwcm94Ijoi4qqKIiwiZ25lIjoi4qqIIiwiZ25FIjoi4ompIiwiZ25lcSI6IuKqiCIsImduZXFxIjoi4ompIiwiZ25zaW0iOiLii6ciLCJHb3BmIjoi8J2UviIsImdvcGYiOiLwnZWYIiwiZ3JhdmUiOiJgIiwiR3JlYXRlckVxdWFsIjoi4omlIiwiR3JlYXRlckVxdWFsTGVzcyI6IuKLmyIsIkdyZWF0ZXJGdWxsRXF1YWwiOiLiiaciLCJHcmVhdGVyR3JlYXRlciI6IuKqoiIsIkdyZWF0ZXJMZXNzIjoi4om3IiwiR3JlYXRlclNsYW50RXF1YWwiOiLiqb4iLCJHcmVhdGVyVGlsZGUiOiLiibMiLCJHc2NyIjoi8J2SoiIsImdzY3IiOiLihIoiLCJnc2ltIjoi4omzIiwiZ3NpbWUiOiLiqo4iLCJnc2ltbCI6IuKqkCIsImd0Y2MiOiLiqqciLCJndGNpciI6IuKpuiIsImd0IjoiPiIsIkdUIjoiPiIsIkd0Ijoi4omrIiwiZ3Rkb3QiOiLii5ciLCJndGxQYXIiOiLippUiLCJndHF1ZXN0Ijoi4qm8IiwiZ3RyYXBwcm94Ijoi4qqGIiwiZ3RyYXJyIjoi4qW4IiwiZ3RyZG90Ijoi4ouXIiwiZ3RyZXFsZXNzIjoi4oubIiwiZ3RyZXFxbGVzcyI6IuKqjCIsImd0cmxlc3MiOiLiibciLCJndHJzaW0iOiLiibMiLCJndmVydG5lcXEiOiLiianvuIAiLCJndm5FIjoi4omp77iAIiwiSGFjZWsiOiLLhyIsImhhaXJzcCI6IuKAiiIsImhhbGYiOiLCvSIsImhhbWlsdCI6IuKEiyIsIkhBUkRjeSI6ItCqIiwiaGFyZGN5Ijoi0YoiLCJoYXJyY2lyIjoi4qWIIiwiaGFyciI6IuKGlCIsImhBcnIiOiLih5QiLCJoYXJydyI6IuKGrSIsIkhhdCI6Il4iLCJoYmFyIjoi4oSPIiwiSGNpcmMiOiLEpCIsImhjaXJjIjoixKUiLCJoZWFydHMiOiLimaUiLCJoZWFydHN1aXQiOiLimaUiLCJoZWxsaXAiOiLigKYiLCJoZXJjb24iOiLiirkiLCJoZnIiOiLwnZSlIiwiSGZyIjoi4oSMIiwiSGlsYmVydFNwYWNlIjoi4oSLIiwiaGtzZWFyb3ciOiLipKUiLCJoa3N3YXJvdyI6IuKkpiIsImhvYXJyIjoi4oe/IiwiaG9tdGh0Ijoi4oi7IiwiaG9va2xlZnRhcnJvdyI6IuKGqSIsImhvb2tyaWdodGFycm93Ijoi4oaqIiwiaG9wZiI6IvCdlZkiLCJIb3BmIjoi4oSNIiwiaG9yYmFyIjoi4oCVIiwiSG9yaXpvbnRhbExpbmUiOiLilIAiLCJoc2NyIjoi8J2SvSIsIkhzY3IiOiLihIsiLCJoc2xhc2giOiLihI8iLCJIc3Ryb2siOiLEpiIsImhzdHJvayI6IsSnIiwiSHVtcERvd25IdW1wIjoi4omOIiwiSHVtcEVxdWFsIjoi4omPIiwiaHlidWxsIjoi4oGDIiwiaHlwaGVuIjoi4oCQIiwiSWFjdXRlIjoiw40iLCJpYWN1dGUiOiLDrSIsImljIjoi4oGjIiwiSWNpcmMiOiLDjiIsImljaXJjIjoiw64iLCJJY3kiOiLQmCIsImljeSI6ItC4IiwiSWRvdCI6IsSwIiwiSUVjeSI6ItCVIiwiaWVjeSI6ItC1IiwiaWV4Y2wiOiLCoSIsImlmZiI6IuKHlCIsImlmciI6IvCdlKYiLCJJZnIiOiLihJEiLCJJZ3JhdmUiOiLDjCIsImlncmF2ZSI6IsOsIiwiaWkiOiLihYgiLCJpaWlpbnQiOiLiqIwiLCJpaWludCI6IuKIrSIsImlpbmZpbiI6IuKnnCIsImlpb3RhIjoi4oSpIiwiSUpsaWciOiLEsiIsImlqbGlnIjoixLMiLCJJbWFjciI6IsSqIiwiaW1hY3IiOiLEqyIsImltYWdlIjoi4oSRIiwiSW1hZ2luYXJ5SSI6IuKFiCIsImltYWdsaW5lIjoi4oSQIiwiaW1hZ3BhcnQiOiLihJEiLCJpbWF0aCI6IsSxIiwiSW0iOiLihJEiLCJpbW9mIjoi4oq3IiwiaW1wZWQiOiLGtSIsIkltcGxpZXMiOiLih5IiLCJpbmNhcmUiOiLihIUiLCJpbiI6IuKIiCIsImluZmluIjoi4oieIiwiaW5maW50aWUiOiLip50iLCJpbm9kb3QiOiLEsSIsImludGNhbCI6IuKKuiIsImludCI6IuKIqyIsIkludCI6IuKIrCIsImludGVnZXJzIjoi4oSkIiwiSW50ZWdyYWwiOiLiiKsiLCJpbnRlcmNhbCI6IuKKuiIsIkludGVyc2VjdGlvbiI6IuKLgiIsImludGxhcmhrIjoi4qiXIiwiaW50cHJvZCI6IuKovCIsIkludmlzaWJsZUNvbW1hIjoi4oGjIiwiSW52aXNpYmxlVGltZXMiOiLigaIiLCJJT2N5Ijoi0IEiLCJpb2N5Ijoi0ZEiLCJJb2dvbiI6IsSuIiwiaW9nb24iOiLEryIsIklvcGYiOiLwnZWAIiwiaW9wZiI6IvCdlZoiLCJJb3RhIjoizpkiLCJpb3RhIjoizrkiLCJpcHJvZCI6IuKovCIsImlxdWVzdCI6IsK/IiwiaXNjciI6IvCdkr4iLCJJc2NyIjoi4oSQIiwiaXNpbiI6IuKIiCIsImlzaW5kb3QiOiLii7UiLCJpc2luRSI6IuKLuSIsImlzaW5zIjoi4ou0IiwiaXNpbnN2Ijoi4ouzIiwiaXNpbnYiOiLiiIgiLCJpdCI6IuKBoiIsIkl0aWxkZSI6IsSoIiwiaXRpbGRlIjoixKkiLCJJdWtjeSI6ItCGIiwiaXVrY3kiOiLRliIsIkl1bWwiOiLDjyIsIml1bWwiOiLDryIsIkpjaXJjIjoixLQiLCJqY2lyYyI6IsS1IiwiSmN5Ijoi0JkiLCJqY3kiOiLQuSIsIkpmciI6IvCdlI0iLCJqZnIiOiLwnZSnIiwiam1hdGgiOiLItyIsIkpvcGYiOiLwnZWBIiwiam9wZiI6IvCdlZsiLCJKc2NyIjoi8J2SpSIsImpzY3IiOiLwnZK/IiwiSnNlcmN5Ijoi0IgiLCJqc2VyY3kiOiLRmCIsIkp1a2N5Ijoi0IQiLCJqdWtjeSI6ItGUIiwiS2FwcGEiOiLOmiIsImthcHBhIjoizroiLCJrYXBwYXYiOiLPsCIsIktjZWRpbCI6IsS2Iiwia2NlZGlsIjoixLciLCJLY3kiOiLQmiIsImtjeSI6ItC6IiwiS2ZyIjoi8J2UjiIsImtmciI6IvCdlKgiLCJrZ3JlZW4iOiLEuCIsIktIY3kiOiLQpSIsImtoY3kiOiLRhSIsIktKY3kiOiLQjCIsImtqY3kiOiLRnCIsIktvcGYiOiLwnZWCIiwia29wZiI6IvCdlZwiLCJLc2NyIjoi8J2SpiIsImtzY3IiOiLwnZOAIiwibEFhcnIiOiLih5oiLCJMYWN1dGUiOiLEuSIsImxhY3V0ZSI6IsS6IiwibGFlbXB0eXYiOiLiprQiLCJsYWdyYW4iOiLihJIiLCJMYW1iZGEiOiLOmyIsImxhbWJkYSI6Is67IiwibGFuZyI6IuKfqCIsIkxhbmciOiLin6oiLCJsYW5nZCI6IuKmkSIsImxhbmdsZSI6IuKfqCIsImxhcCI6IuKqhSIsIkxhcGxhY2V0cmYiOiLihJIiLCJsYXF1byI6IsKrIiwibGFycmIiOiLih6QiLCJsYXJyYmZzIjoi4qSfIiwibGFyciI6IuKGkCIsIkxhcnIiOiLihp4iLCJsQXJyIjoi4oeQIiwibGFycmZzIjoi4qSdIiwibGFycmhrIjoi4oapIiwibGFycmxwIjoi4oarIiwibGFycnBsIjoi4qS5IiwibGFycnNpbSI6IuKlsyIsImxhcnJ0bCI6IuKGoiIsImxhdGFpbCI6IuKkmSIsImxBdGFpbCI6IuKkmyIsImxhdCI6IuKqqyIsImxhdGUiOiLiqq0iLCJsYXRlcyI6IuKqre+4gCIsImxiYXJyIjoi4qSMIiwibEJhcnIiOiLipI4iLCJsYmJyayI6IuKdsiIsImxicmFjZSI6InsiLCJsYnJhY2siOiJbIiwibGJya2UiOiLiposiLCJsYnJrc2xkIjoi4qaPIiwibGJya3NsdSI6IuKmjSIsIkxjYXJvbiI6IsS9IiwibGNhcm9uIjoixL4iLCJMY2VkaWwiOiLEuyIsImxjZWRpbCI6IsS8IiwibGNlaWwiOiLijIgiLCJsY3ViIjoieyIsIkxjeSI6ItCbIiwibGN5Ijoi0LsiLCJsZGNhIjoi4qS2IiwibGRxdW8iOiLigJwiLCJsZHF1b3IiOiLigJ4iLCJsZHJkaGFyIjoi4qWnIiwibGRydXNoYXIiOiLipYsiLCJsZHNoIjoi4oayIiwibGUiOiLiiaQiLCJsRSI6IuKJpiIsIkxlZnRBbmdsZUJyYWNrZXQiOiLin6giLCJMZWZ0QXJyb3dCYXIiOiLih6QiLCJsZWZ0YXJyb3ciOiLihpAiLCJMZWZ0QXJyb3ciOiLihpAiLCJMZWZ0YXJyb3ciOiLih5AiLCJMZWZ0QXJyb3dSaWdodEFycm93Ijoi4oeGIiwibGVmdGFycm93dGFpbCI6IuKGoiIsIkxlZnRDZWlsaW5nIjoi4oyIIiwiTGVmdERvdWJsZUJyYWNrZXQiOiLin6YiLCJMZWZ0RG93blRlZVZlY3RvciI6IuKloSIsIkxlZnREb3duVmVjdG9yQmFyIjoi4qWZIiwiTGVmdERvd25WZWN0b3IiOiLih4MiLCJMZWZ0Rmxvb3IiOiLijIoiLCJsZWZ0aGFycG9vbmRvd24iOiLihr0iLCJsZWZ0aGFycG9vbnVwIjoi4oa8IiwibGVmdGxlZnRhcnJvd3MiOiLih4ciLCJsZWZ0cmlnaHRhcnJvdyI6IuKGlCIsIkxlZnRSaWdodEFycm93Ijoi4oaUIiwiTGVmdHJpZ2h0YXJyb3ciOiLih5QiLCJsZWZ0cmlnaHRhcnJvd3MiOiLih4YiLCJsZWZ0cmlnaHRoYXJwb29ucyI6IuKHiyIsImxlZnRyaWdodHNxdWlnYXJyb3ciOiLihq0iLCJMZWZ0UmlnaHRWZWN0b3IiOiLipY4iLCJMZWZ0VGVlQXJyb3ciOiLihqQiLCJMZWZ0VGVlIjoi4oqjIiwiTGVmdFRlZVZlY3RvciI6IuKlmiIsImxlZnR0aHJlZXRpbWVzIjoi4ouLIiwiTGVmdFRyaWFuZ2xlQmFyIjoi4qePIiwiTGVmdFRyaWFuZ2xlIjoi4oqyIiwiTGVmdFRyaWFuZ2xlRXF1YWwiOiLiirQiLCJMZWZ0VXBEb3duVmVjdG9yIjoi4qWRIiwiTGVmdFVwVGVlVmVjdG9yIjoi4qWgIiwiTGVmdFVwVmVjdG9yQmFyIjoi4qWYIiwiTGVmdFVwVmVjdG9yIjoi4oa/IiwiTGVmdFZlY3RvckJhciI6IuKlkiIsIkxlZnRWZWN0b3IiOiLihrwiLCJsRWciOiLiqosiLCJsZWciOiLii5oiLCJsZXEiOiLiiaQiLCJsZXFxIjoi4ommIiwibGVxc2xhbnQiOiLiqb0iLCJsZXNjYyI6IuKqqCIsImxlcyI6IuKpvSIsImxlc2RvdCI6IuKpvyIsImxlc2RvdG8iOiLiqoEiLCJsZXNkb3RvciI6IuKqgyIsImxlc2ciOiLii5rvuIAiLCJsZXNnZXMiOiLiqpMiLCJsZXNzYXBwcm94Ijoi4qqFIiwibGVzc2RvdCI6IuKLliIsImxlc3NlcWd0ciI6IuKLmiIsImxlc3NlcXFndHIiOiLiqosiLCJMZXNzRXF1YWxHcmVhdGVyIjoi4ouaIiwiTGVzc0Z1bGxFcXVhbCI6IuKJpiIsIkxlc3NHcmVhdGVyIjoi4om2IiwibGVzc2d0ciI6IuKJtiIsIkxlc3NMZXNzIjoi4qqhIiwibGVzc3NpbSI6IuKJsiIsIkxlc3NTbGFudEVxdWFsIjoi4qm9IiwiTGVzc1RpbGRlIjoi4omyIiwibGZpc2h0Ijoi4qW8IiwibGZsb29yIjoi4oyKIiwiTGZyIjoi8J2UjyIsImxmciI6IvCdlKkiLCJsZyI6IuKJtiIsImxnRSI6IuKqkSIsImxIYXIiOiLipaIiLCJsaGFyZCI6IuKGvSIsImxoYXJ1Ijoi4oa8IiwibGhhcnVsIjoi4qWqIiwibGhibGsiOiLiloQiLCJMSmN5Ijoi0IkiLCJsamN5Ijoi0ZkiLCJsbGFyciI6IuKHhyIsImxsIjoi4omqIiwiTGwiOiLii5giLCJsbGNvcm5lciI6IuKMniIsIkxsZWZ0YXJyb3ciOiLih5oiLCJsbGhhcmQiOiLipasiLCJsbHRyaSI6IuKXuiIsIkxtaWRvdCI6IsS/IiwibG1pZG90IjoixYAiLCJsbW91c3RhY2hlIjoi4o6wIiwibG1vdXN0Ijoi4o6wIiwibG5hcCI6IuKqiSIsImxuYXBwcm94Ijoi4qqJIiwibG5lIjoi4qqHIiwibG5FIjoi4omoIiwibG5lcSI6IuKqhyIsImxuZXFxIjoi4omoIiwibG5zaW0iOiLii6YiLCJsb2FuZyI6IuKfrCIsImxvYXJyIjoi4oe9IiwibG9icmsiOiLin6YiLCJsb25nbGVmdGFycm93Ijoi4p+1IiwiTG9uZ0xlZnRBcnJvdyI6IuKftSIsIkxvbmdsZWZ0YXJyb3ciOiLin7giLCJsb25nbGVmdHJpZ2h0YXJyb3ciOiLin7ciLCJMb25nTGVmdFJpZ2h0QXJyb3ciOiLin7ciLCJMb25nbGVmdHJpZ2h0YXJyb3ciOiLin7oiLCJsb25nbWFwc3RvIjoi4p+8IiwibG9uZ3JpZ2h0YXJyb3ciOiLin7YiLCJMb25nUmlnaHRBcnJvdyI6IuKftiIsIkxvbmdyaWdodGFycm93Ijoi4p+5IiwibG9vcGFycm93bGVmdCI6IuKGqyIsImxvb3BhcnJvd3JpZ2h0Ijoi4oasIiwibG9wYXIiOiLipoUiLCJMb3BmIjoi8J2VgyIsImxvcGYiOiLwnZWdIiwibG9wbHVzIjoi4qitIiwibG90aW1lcyI6IuKotCIsImxvd2FzdCI6IuKIlyIsImxvd2JhciI6Il8iLCJMb3dlckxlZnRBcnJvdyI6IuKGmSIsIkxvd2VyUmlnaHRBcnJvdyI6IuKGmCIsImxveiI6IuKXiiIsImxvemVuZ2UiOiLil4oiLCJsb3pmIjoi4qerIiwibHBhciI6IigiLCJscGFybHQiOiLippMiLCJscmFyciI6IuKHhiIsImxyY29ybmVyIjoi4oyfIiwibHJoYXIiOiLih4siLCJscmhhcmQiOiLipa0iLCJscm0iOiLigI4iLCJscnRyaSI6IuKKvyIsImxzYXF1byI6IuKAuSIsImxzY3IiOiLwnZOBIiwiTHNjciI6IuKEkiIsImxzaCI6IuKGsCIsIkxzaCI6IuKGsCIsImxzaW0iOiLiibIiLCJsc2ltZSI6IuKqjSIsImxzaW1nIjoi4qqPIiwibHNxYiI6IlsiLCJsc3F1byI6IuKAmCIsImxzcXVvciI6IuKAmiIsIkxzdHJvayI6IsWBIiwibHN0cm9rIjoixYIiLCJsdGNjIjoi4qqmIiwibHRjaXIiOiLiqbkiLCJsdCI6IjwiLCJMVCI6IjwiLCJMdCI6IuKJqiIsImx0ZG90Ijoi4ouWIiwibHRocmVlIjoi4ouLIiwibHRpbWVzIjoi4ouJIiwibHRsYXJyIjoi4qW2IiwibHRxdWVzdCI6IuKpuyIsImx0cmkiOiLil4MiLCJsdHJpZSI6IuKKtCIsImx0cmlmIjoi4peCIiwibHRyUGFyIjoi4qaWIiwibHVyZHNoYXIiOiLipYoiLCJsdXJ1aGFyIjoi4qWmIiwibHZlcnRuZXFxIjoi4omo77iAIiwibHZuRSI6IuKJqO+4gCIsIm1hY3IiOiLCryIsIm1hbGUiOiLimYIiLCJtYWx0Ijoi4pygIiwibWFsdGVzZSI6IuKcoCIsIk1hcCI6IuKkhSIsIm1hcCI6IuKGpiIsIm1hcHN0byI6IuKGpiIsIm1hcHN0b2Rvd24iOiLihqciLCJtYXBzdG9sZWZ0Ijoi4oakIiwibWFwc3RvdXAiOiLihqUiLCJtYXJrZXIiOiLilq4iLCJtY29tbWEiOiLiqKkiLCJNY3kiOiLQnCIsIm1jeSI6ItC8IiwibWRhc2giOiLigJQiLCJtRERvdCI6IuKIuiIsIm1lYXN1cmVkYW5nbGUiOiLiiKEiLCJNZWRpdW1TcGFjZSI6IuKBnyIsIk1lbGxpbnRyZiI6IuKEsyIsIk1mciI6IvCdlJAiLCJtZnIiOiLwnZSqIiwibWhvIjoi4oSnIiwibWljcm8iOiLCtSIsIm1pZGFzdCI6IioiLCJtaWRjaXIiOiLiq7AiLCJtaWQiOiLiiKMiLCJtaWRkb3QiOiLCtyIsIm1pbnVzYiI6IuKKnyIsIm1pbnVzIjoi4oiSIiwibWludXNkIjoi4oi4IiwibWludXNkdSI6IuKoqiIsIk1pbnVzUGx1cyI6IuKIkyIsIm1sY3AiOiLiq5siLCJtbGRyIjoi4oCmIiwibW5wbHVzIjoi4oiTIiwibW9kZWxzIjoi4oqnIiwiTW9wZiI6IvCdlYQiLCJtb3BmIjoi8J2VniIsIm1wIjoi4oiTIiwibXNjciI6IvCdk4IiLCJNc2NyIjoi4oSzIiwibXN0cG9zIjoi4oi+IiwiTXUiOiLOnCIsIm11IjoizrwiLCJtdWx0aW1hcCI6IuKKuCIsIm11bWFwIjoi4oq4IiwibmFibGEiOiLiiIciLCJOYWN1dGUiOiLFgyIsIm5hY3V0ZSI6IsWEIiwibmFuZyI6IuKIoOKDkiIsIm5hcCI6IuKJiSIsIm5hcEUiOiLiqbDMuCIsIm5hcGlkIjoi4omLzLgiLCJuYXBvcyI6IsWJIiwibmFwcHJveCI6IuKJiSIsIm5hdHVyYWwiOiLima4iLCJuYXR1cmFscyI6IuKElSIsIm5hdHVyIjoi4pmuIiwibmJzcCI6IsKgIiwibmJ1bXAiOiLiiY7MuCIsIm5idW1wZSI6IuKJj8y4IiwibmNhcCI6IuKpgyIsIk5jYXJvbiI6IsWHIiwibmNhcm9uIjoixYgiLCJOY2VkaWwiOiLFhSIsIm5jZWRpbCI6IsWGIiwibmNvbmciOiLiiYciLCJuY29uZ2RvdCI6IuKprcy4IiwibmN1cCI6IuKpgiIsIk5jeSI6ItCdIiwibmN5Ijoi0L0iLCJuZGFzaCI6IuKAkyIsIm5lYXJoayI6IuKkpCIsIm5lYXJyIjoi4oaXIiwibmVBcnIiOiLih5ciLCJuZWFycm93Ijoi4oaXIiwibmUiOiLiiaAiLCJuZWRvdCI6IuKJkMy4IiwiTmVnYXRpdmVNZWRpdW1TcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVGhpY2tTcGFjZSI6IuKAiyIsIk5lZ2F0aXZlVGhpblNwYWNlIjoi4oCLIiwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlIjoi4oCLIiwibmVxdWl2Ijoi4omiIiwibmVzZWFyIjoi4qSoIiwibmVzaW0iOiLiiYLMuCIsIk5lc3RlZEdyZWF0ZXJHcmVhdGVyIjoi4omrIiwiTmVzdGVkTGVzc0xlc3MiOiLiiaoiLCJOZXdMaW5lIjoiXFxuIiwibmV4aXN0Ijoi4oiEIiwibmV4aXN0cyI6IuKIhCIsIk5mciI6IvCdlJEiLCJuZnIiOiLwnZSrIiwibmdFIjoi4omnzLgiLCJuZ2UiOiLiibEiLCJuZ2VxIjoi4omxIiwibmdlcXEiOiLiiafMuCIsIm5nZXFzbGFudCI6IuKpvsy4IiwibmdlcyI6IuKpvsy4IiwibkdnIjoi4ouZzLgiLCJuZ3NpbSI6IuKJtSIsIm5HdCI6IuKJq+KDkiIsIm5ndCI6IuKJryIsIm5ndHIiOiLiia8iLCJuR3R2Ijoi4omrzLgiLCJuaGFyciI6IuKGriIsIm5oQXJyIjoi4oeOIiwibmhwYXIiOiLiq7IiLCJuaSI6IuKIiyIsIm5pcyI6IuKLvCIsIm5pc2QiOiLii7oiLCJuaXYiOiLiiIsiLCJOSmN5Ijoi0IoiLCJuamN5Ijoi0ZoiLCJubGFyciI6IuKGmiIsIm5sQXJyIjoi4oeNIiwibmxkciI6IuKApSIsIm5sRSI6IuKJpsy4IiwibmxlIjoi4omwIiwibmxlZnRhcnJvdyI6IuKGmiIsIm5MZWZ0YXJyb3ciOiLih40iLCJubGVmdHJpZ2h0YXJyb3ciOiLihq4iLCJuTGVmdHJpZ2h0YXJyb3ciOiLih44iLCJubGVxIjoi4omwIiwibmxlcXEiOiLiiabMuCIsIm5sZXFzbGFudCI6IuKpvcy4IiwibmxlcyI6IuKpvcy4Iiwibmxlc3MiOiLiia4iLCJuTGwiOiLii5jMuCIsIm5sc2ltIjoi4om0Iiwibkx0Ijoi4omq4oOSIiwibmx0Ijoi4omuIiwibmx0cmkiOiLii6oiLCJubHRyaWUiOiLii6wiLCJuTHR2Ijoi4omqzLgiLCJubWlkIjoi4oikIiwiTm9CcmVhayI6IuKBoCIsIk5vbkJyZWFraW5nU3BhY2UiOiLCoCIsIm5vcGYiOiLwnZWfIiwiTm9wZiI6IuKElSIsIk5vdCI6IuKrrCIsIm5vdCI6IsKsIiwiTm90Q29uZ3J1ZW50Ijoi4omiIiwiTm90Q3VwQ2FwIjoi4omtIiwiTm90RG91YmxlVmVydGljYWxCYXIiOiLiiKYiLCJOb3RFbGVtZW50Ijoi4oiJIiwiTm90RXF1YWwiOiLiiaAiLCJOb3RFcXVhbFRpbGRlIjoi4omCzLgiLCJOb3RFeGlzdHMiOiLiiIQiLCJOb3RHcmVhdGVyIjoi4omvIiwiTm90R3JlYXRlckVxdWFsIjoi4omxIiwiTm90R3JlYXRlckZ1bGxFcXVhbCI6IuKJp8y4IiwiTm90R3JlYXRlckdyZWF0ZXIiOiLiiavMuCIsIk5vdEdyZWF0ZXJMZXNzIjoi4om5IiwiTm90R3JlYXRlclNsYW50RXF1YWwiOiLiqb7MuCIsIk5vdEdyZWF0ZXJUaWxkZSI6IuKJtSIsIk5vdEh1bXBEb3duSHVtcCI6IuKJjsy4IiwiTm90SHVtcEVxdWFsIjoi4omPzLgiLCJub3RpbiI6IuKIiSIsIm5vdGluZG90Ijoi4ou1zLgiLCJub3RpbkUiOiLii7nMuCIsIm5vdGludmEiOiLiiIkiLCJub3RpbnZiIjoi4ou3Iiwibm90aW52YyI6IuKLtiIsIk5vdExlZnRUcmlhbmdsZUJhciI6IuKnj8y4IiwiTm90TGVmdFRyaWFuZ2xlIjoi4ouqIiwiTm90TGVmdFRyaWFuZ2xlRXF1YWwiOiLii6wiLCJOb3RMZXNzIjoi4omuIiwiTm90TGVzc0VxdWFsIjoi4omwIiwiTm90TGVzc0dyZWF0ZXIiOiLiibgiLCJOb3RMZXNzTGVzcyI6IuKJqsy4IiwiTm90TGVzc1NsYW50RXF1YWwiOiLiqb3MuCIsIk5vdExlc3NUaWxkZSI6IuKJtCIsIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyIjoi4qqizLgiLCJOb3ROZXN0ZWRMZXNzTGVzcyI6IuKqocy4Iiwibm90bmkiOiLiiIwiLCJub3RuaXZhIjoi4oiMIiwibm90bml2YiI6IuKLviIsIm5vdG5pdmMiOiLii70iLCJOb3RQcmVjZWRlcyI6IuKKgCIsIk5vdFByZWNlZGVzRXF1YWwiOiLiqq/MuCIsIk5vdFByZWNlZGVzU2xhbnRFcXVhbCI6IuKLoCIsIk5vdFJldmVyc2VFbGVtZW50Ijoi4oiMIiwiTm90UmlnaHRUcmlhbmdsZUJhciI6IuKnkMy4IiwiTm90UmlnaHRUcmlhbmdsZSI6IuKLqyIsIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbCI6IuKLrSIsIk5vdFNxdWFyZVN1YnNldCI6IuKKj8y4IiwiTm90U3F1YXJlU3Vic2V0RXF1YWwiOiLii6IiLCJOb3RTcXVhcmVTdXBlcnNldCI6IuKKkMy4IiwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbCI6IuKLoyIsIk5vdFN1YnNldCI6IuKKguKDkiIsIk5vdFN1YnNldEVxdWFsIjoi4oqIIiwiTm90U3VjY2VlZHMiOiLiioEiLCJOb3RTdWNjZWVkc0VxdWFsIjoi4qqwzLgiLCJOb3RTdWNjZWVkc1NsYW50RXF1YWwiOiLii6EiLCJOb3RTdWNjZWVkc1RpbGRlIjoi4om/zLgiLCJOb3RTdXBlcnNldCI6IuKKg+KDkiIsIk5vdFN1cGVyc2V0RXF1YWwiOiLiiokiLCJOb3RUaWxkZSI6IuKJgSIsIk5vdFRpbGRlRXF1YWwiOiLiiYQiLCJOb3RUaWxkZUZ1bGxFcXVhbCI6IuKJhyIsIk5vdFRpbGRlVGlsZGUiOiLiiYkiLCJOb3RWZXJ0aWNhbEJhciI6IuKIpCIsIm5wYXJhbGxlbCI6IuKIpiIsIm5wYXIiOiLiiKYiLCJucGFyc2wiOiLiq73ig6UiLCJucGFydCI6IuKIgsy4IiwibnBvbGludCI6IuKolCIsIm5wciI6IuKKgCIsIm5wcmN1ZSI6IuKLoCIsIm5wcmVjIjoi4oqAIiwibnByZWNlcSI6IuKqr8y4IiwibnByZSI6IuKqr8y4IiwibnJhcnJjIjoi4qSzzLgiLCJucmFyciI6IuKGmyIsIm5yQXJyIjoi4oePIiwibnJhcnJ3Ijoi4oadzLgiLCJucmlnaHRhcnJvdyI6IuKGmyIsIm5SaWdodGFycm93Ijoi4oePIiwibnJ0cmkiOiLii6siLCJucnRyaWUiOiLii60iLCJuc2MiOiLiioEiLCJuc2NjdWUiOiLii6EiLCJuc2NlIjoi4qqwzLgiLCJOc2NyIjoi8J2SqSIsIm5zY3IiOiLwnZODIiwibnNob3J0bWlkIjoi4oikIiwibnNob3J0cGFyYWxsZWwiOiLiiKYiLCJuc2ltIjoi4omBIiwibnNpbWUiOiLiiYQiLCJuc2ltZXEiOiLiiYQiLCJuc21pZCI6IuKIpCIsIm5zcGFyIjoi4oimIiwibnNxc3ViZSI6IuKLoiIsIm5zcXN1cGUiOiLii6MiLCJuc3ViIjoi4oqEIiwibnN1YkUiOiLiq4XMuCIsIm5zdWJlIjoi4oqIIiwibnN1YnNldCI6IuKKguKDkiIsIm5zdWJzZXRlcSI6IuKKiCIsIm5zdWJzZXRlcXEiOiLiq4XMuCIsIm5zdWNjIjoi4oqBIiwibnN1Y2NlcSI6IuKqsMy4IiwibnN1cCI6IuKKhSIsIm5zdXBFIjoi4quGzLgiLCJuc3VwZSI6IuKKiSIsIm5zdXBzZXQiOiLiioPig5IiLCJuc3Vwc2V0ZXEiOiLiiokiLCJuc3Vwc2V0ZXFxIjoi4quGzLgiLCJudGdsIjoi4om5IiwiTnRpbGRlIjoiw5EiLCJudGlsZGUiOiLDsSIsIm50bGciOiLiibgiLCJudHJpYW5nbGVsZWZ0Ijoi4ouqIiwibnRyaWFuZ2xlbGVmdGVxIjoi4ousIiwibnRyaWFuZ2xlcmlnaHQiOiLii6siLCJudHJpYW5nbGVyaWdodGVxIjoi4outIiwiTnUiOiLOnSIsIm51Ijoizr0iLCJudW0iOiIjIiwibnVtZXJvIjoi4oSWIiwibnVtc3AiOiLigIciLCJudmFwIjoi4omN4oOSIiwibnZkYXNoIjoi4oqsIiwibnZEYXNoIjoi4oqtIiwiblZkYXNoIjoi4oquIiwiblZEYXNoIjoi4oqvIiwibnZnZSI6IuKJpeKDkiIsIm52Z3QiOiI+4oOSIiwibnZIYXJyIjoi4qSEIiwibnZpbmZpbiI6IuKnniIsIm52bEFyciI6IuKkgiIsIm52bGUiOiLiiaTig5IiLCJudmx0IjoiPOKDkiIsIm52bHRyaWUiOiLiirTig5IiLCJudnJBcnIiOiLipIMiLCJudnJ0cmllIjoi4oq14oOSIiwibnZzaW0iOiLiiLzig5IiLCJud2FyaGsiOiLipKMiLCJud2FyciI6IuKGliIsIm53QXJyIjoi4oeWIiwibndhcnJvdyI6IuKGliIsIm53bmVhciI6IuKkpyIsIk9hY3V0ZSI6IsOTIiwib2FjdXRlIjoiw7MiLCJvYXN0Ijoi4oqbIiwiT2NpcmMiOiLDlCIsIm9jaXJjIjoiw7QiLCJvY2lyIjoi4oqaIiwiT2N5Ijoi0J4iLCJvY3kiOiLQviIsIm9kYXNoIjoi4oqdIiwiT2RibGFjIjoixZAiLCJvZGJsYWMiOiLFkSIsIm9kaXYiOiLiqLgiLCJvZG90Ijoi4oqZIiwib2Rzb2xkIjoi4qa8IiwiT0VsaWciOiLFkiIsIm9lbGlnIjoixZMiLCJvZmNpciI6IuKmvyIsIk9mciI6IvCdlJIiLCJvZnIiOiLwnZSsIiwib2dvbiI6IsubIiwiT2dyYXZlIjoiw5IiLCJvZ3JhdmUiOiLDsiIsIm9ndCI6IuKngSIsIm9oYmFyIjoi4qa1Iiwib2htIjoizqkiLCJvaW50Ijoi4oiuIiwib2xhcnIiOiLihroiLCJvbGNpciI6IuKmviIsIm9sY3Jvc3MiOiLiprsiLCJvbGluZSI6IuKAviIsIm9sdCI6IuKngCIsIk9tYWNyIjoixYwiLCJvbWFjciI6IsWNIiwiT21lZ2EiOiLOqSIsIm9tZWdhIjoiz4kiLCJPbWljcm9uIjoizp8iLCJvbWljcm9uIjoizr8iLCJvbWlkIjoi4qa2Iiwib21pbnVzIjoi4oqWIiwiT29wZiI6IvCdlYYiLCJvb3BmIjoi8J2VoCIsIm9wYXIiOiLiprciLCJPcGVuQ3VybHlEb3VibGVRdW90ZSI6IuKAnCIsIk9wZW5DdXJseVF1b3RlIjoi4oCYIiwib3BlcnAiOiLiprkiLCJvcGx1cyI6IuKKlSIsIm9yYXJyIjoi4oa7IiwiT3IiOiLiqZQiLCJvciI6IuKIqCIsIm9yZCI6IuKpnSIsIm9yZGVyIjoi4oS0Iiwib3JkZXJvZiI6IuKEtCIsIm9yZGYiOiLCqiIsIm9yZG0iOiLCuiIsIm9yaWdvZiI6IuKKtiIsIm9yb3IiOiLiqZYiLCJvcnNsb3BlIjoi4qmXIiwib3J2Ijoi4qmbIiwib1MiOiLik4giLCJPc2NyIjoi8J2SqiIsIm9zY3IiOiLihLQiLCJPc2xhc2giOiLDmCIsIm9zbGFzaCI6IsO4Iiwib3NvbCI6IuKKmCIsIk90aWxkZSI6IsOVIiwib3RpbGRlIjoiw7UiLCJvdGltZXNhcyI6IuKotiIsIk90aW1lcyI6IuKotyIsIm90aW1lcyI6IuKKlyIsIk91bWwiOiLDliIsIm91bWwiOiLDtiIsIm92YmFyIjoi4oy9IiwiT3ZlckJhciI6IuKAviIsIk92ZXJCcmFjZSI6IuKPniIsIk92ZXJCcmFja2V0Ijoi4o60IiwiT3ZlclBhcmVudGhlc2lzIjoi4o+cIiwicGFyYSI6IsK2IiwicGFyYWxsZWwiOiLiiKUiLCJwYXIiOiLiiKUiLCJwYXJzaW0iOiLiq7MiLCJwYXJzbCI6IuKrvSIsInBhcnQiOiLiiIIiLCJQYXJ0aWFsRCI6IuKIgiIsIlBjeSI6ItCfIiwicGN5Ijoi0L8iLCJwZXJjbnQiOiIlIiwicGVyaW9kIjoiLiIsInBlcm1pbCI6IuKAsCIsInBlcnAiOiLiiqUiLCJwZXJ0ZW5rIjoi4oCxIiwiUGZyIjoi8J2UkyIsInBmciI6IvCdlK0iLCJQaGkiOiLOpiIsInBoaSI6Is+GIiwicGhpdiI6Is+VIiwicGhtbWF0Ijoi4oSzIiwicGhvbmUiOiLimI4iLCJQaSI6Is6gIiwicGkiOiLPgCIsInBpdGNoZm9yayI6IuKLlCIsInBpdiI6Is+WIiwicGxhbmNrIjoi4oSPIiwicGxhbmNraCI6IuKEjiIsInBsYW5rdiI6IuKEjyIsInBsdXNhY2lyIjoi4qijIiwicGx1c2IiOiLiip4iLCJwbHVzY2lyIjoi4qiiIiwicGx1cyI6IisiLCJwbHVzZG8iOiLiiJQiLCJwbHVzZHUiOiLiqKUiLCJwbHVzZSI6IuKpsiIsIlBsdXNNaW51cyI6IsKxIiwicGx1c21uIjoiwrEiLCJwbHVzc2ltIjoi4qimIiwicGx1c3R3byI6IuKopyIsInBtIjoiwrEiLCJQb2luY2FyZXBsYW5lIjoi4oSMIiwicG9pbnRpbnQiOiLiqJUiLCJwb3BmIjoi8J2VoSIsIlBvcGYiOiLihJkiLCJwb3VuZCI6IsKjIiwicHJhcCI6IuKqtyIsIlByIjoi4qq7IiwicHIiOiLiiboiLCJwcmN1ZSI6IuKJvCIsInByZWNhcHByb3giOiLiqrciLCJwcmVjIjoi4om6IiwicHJlY2N1cmx5ZXEiOiLiibwiLCJQcmVjZWRlcyI6IuKJuiIsIlByZWNlZGVzRXF1YWwiOiLiqq8iLCJQcmVjZWRlc1NsYW50RXF1YWwiOiLiibwiLCJQcmVjZWRlc1RpbGRlIjoi4om+IiwicHJlY2VxIjoi4qqvIiwicHJlY25hcHByb3giOiLiqrkiLCJwcmVjbmVxcSI6IuKqtSIsInByZWNuc2ltIjoi4ouoIiwicHJlIjoi4qqvIiwicHJFIjoi4qqzIiwicHJlY3NpbSI6IuKJviIsInByaW1lIjoi4oCyIiwiUHJpbWUiOiLigLMiLCJwcmltZXMiOiLihJkiLCJwcm5hcCI6IuKquSIsInBybkUiOiLiqrUiLCJwcm5zaW0iOiLii6giLCJwcm9kIjoi4oiPIiwiUHJvZHVjdCI6IuKIjyIsInByb2ZhbGFyIjoi4oyuIiwicHJvZmxpbmUiOiLijJIiLCJwcm9mc3VyZiI6IuKMkyIsInByb3AiOiLiiJ0iLCJQcm9wb3J0aW9uYWwiOiLiiJ0iLCJQcm9wb3J0aW9uIjoi4oi3IiwicHJvcHRvIjoi4oidIiwicHJzaW0iOiLiib4iLCJwcnVyZWwiOiLiirAiLCJQc2NyIjoi8J2SqyIsInBzY3IiOiLwnZOFIiwiUHNpIjoizqgiLCJwc2kiOiLPiCIsInB1bmNzcCI6IuKAiCIsIlFmciI6IvCdlJQiLCJxZnIiOiLwnZSuIiwicWludCI6IuKojCIsInFvcGYiOiLwnZWiIiwiUW9wZiI6IuKEmiIsInFwcmltZSI6IuKBlyIsIlFzY3IiOiLwnZKsIiwicXNjciI6IvCdk4YiLCJxdWF0ZXJuaW9ucyI6IuKEjSIsInF1YXRpbnQiOiLiqJYiLCJxdWVzdCI6Ij8iLCJxdWVzdGVxIjoi4omfIiwicXVvdCI6IlxcIiIsIlFVT1QiOiJcXCIiLCJyQWFyciI6IuKHmyIsInJhY2UiOiLiiL3MsSIsIlJhY3V0ZSI6IsWUIiwicmFjdXRlIjoixZUiLCJyYWRpYyI6IuKImiIsInJhZW1wdHl2Ijoi4qazIiwicmFuZyI6IuKfqSIsIlJhbmciOiLin6siLCJyYW5nZCI6IuKmkiIsInJhbmdlIjoi4qalIiwicmFuZ2xlIjoi4p+pIiwicmFxdW8iOiLCuyIsInJhcnJhcCI6IuKltSIsInJhcnJiIjoi4oelIiwicmFycmJmcyI6IuKkoCIsInJhcnJjIjoi4qSzIiwicmFyciI6IuKGkiIsIlJhcnIiOiLihqAiLCJyQXJyIjoi4oeSIiwicmFycmZzIjoi4qSeIiwicmFycmhrIjoi4oaqIiwicmFycmxwIjoi4oasIiwicmFycnBsIjoi4qWFIiwicmFycnNpbSI6IuKltCIsIlJhcnJ0bCI6IuKkliIsInJhcnJ0bCI6IuKGoyIsInJhcnJ3Ijoi4oadIiwicmF0YWlsIjoi4qSaIiwickF0YWlsIjoi4qScIiwicmF0aW8iOiLiiLYiLCJyYXRpb25hbHMiOiLihJoiLCJyYmFyciI6IuKkjSIsInJCYXJyIjoi4qSPIiwiUkJhcnIiOiLipJAiLCJyYmJyayI6IuKdsyIsInJicmFjZSI6In0iLCJyYnJhY2siOiJdIiwicmJya2UiOiLipowiLCJyYnJrc2xkIjoi4qaOIiwicmJya3NsdSI6IuKmkCIsIlJjYXJvbiI6IsWYIiwicmNhcm9uIjoixZkiLCJSY2VkaWwiOiLFliIsInJjZWRpbCI6IsWXIiwicmNlaWwiOiLijIkiLCJyY3ViIjoifSIsIlJjeSI6ItCgIiwicmN5Ijoi0YAiLCJyZGNhIjoi4qS3IiwicmRsZGhhciI6IuKlqSIsInJkcXVvIjoi4oCdIiwicmRxdW9yIjoi4oCdIiwicmRzaCI6IuKGsyIsInJlYWwiOiLihJwiLCJyZWFsaW5lIjoi4oSbIiwicmVhbHBhcnQiOiLihJwiLCJyZWFscyI6IuKEnSIsIlJlIjoi4oScIiwicmVjdCI6IuKWrSIsInJlZyI6IsKuIiwiUkVHIjoiwq4iLCJSZXZlcnNlRWxlbWVudCI6IuKIiyIsIlJldmVyc2VFcXVpbGlicml1bSI6IuKHiyIsIlJldmVyc2VVcEVxdWlsaWJyaXVtIjoi4qWvIiwicmZpc2h0Ijoi4qW9IiwicmZsb29yIjoi4oyLIiwicmZyIjoi8J2UryIsIlJmciI6IuKEnCIsInJIYXIiOiLipaQiLCJyaGFyZCI6IuKHgSIsInJoYXJ1Ijoi4oeAIiwicmhhcnVsIjoi4qWsIiwiUmhvIjoizqEiLCJyaG8iOiLPgSIsInJob3YiOiLPsSIsIlJpZ2h0QW5nbGVCcmFja2V0Ijoi4p+pIiwiUmlnaHRBcnJvd0JhciI6IuKHpSIsInJpZ2h0YXJyb3ciOiLihpIiLCJSaWdodEFycm93Ijoi4oaSIiwiUmlnaHRhcnJvdyI6IuKHkiIsIlJpZ2h0QXJyb3dMZWZ0QXJyb3ciOiLih4QiLCJyaWdodGFycm93dGFpbCI6IuKGoyIsIlJpZ2h0Q2VpbGluZyI6IuKMiSIsIlJpZ2h0RG91YmxlQnJhY2tldCI6IuKfpyIsIlJpZ2h0RG93blRlZVZlY3RvciI6IuKlnSIsIlJpZ2h0RG93blZlY3RvckJhciI6IuKllSIsIlJpZ2h0RG93blZlY3RvciI6IuKHgiIsIlJpZ2h0Rmxvb3IiOiLijIsiLCJyaWdodGhhcnBvb25kb3duIjoi4oeBIiwicmlnaHRoYXJwb29udXAiOiLih4AiLCJyaWdodGxlZnRhcnJvd3MiOiLih4QiLCJyaWdodGxlZnRoYXJwb29ucyI6IuKHjCIsInJpZ2h0cmlnaHRhcnJvd3MiOiLih4kiLCJyaWdodHNxdWlnYXJyb3ciOiLihp0iLCJSaWdodFRlZUFycm93Ijoi4oamIiwiUmlnaHRUZWUiOiLiiqIiLCJSaWdodFRlZVZlY3RvciI6IuKlmyIsInJpZ2h0dGhyZWV0aW1lcyI6IuKLjCIsIlJpZ2h0VHJpYW5nbGVCYXIiOiLip5AiLCJSaWdodFRyaWFuZ2xlIjoi4oqzIiwiUmlnaHRUcmlhbmdsZUVxdWFsIjoi4oq1IiwiUmlnaHRVcERvd25WZWN0b3IiOiLipY8iLCJSaWdodFVwVGVlVmVjdG9yIjoi4qWcIiwiUmlnaHRVcFZlY3RvckJhciI6IuKllCIsIlJpZ2h0VXBWZWN0b3IiOiLihr4iLCJSaWdodFZlY3RvckJhciI6IuKlkyIsIlJpZ2h0VmVjdG9yIjoi4oeAIiwicmluZyI6IsuaIiwicmlzaW5nZG90c2VxIjoi4omTIiwicmxhcnIiOiLih4QiLCJybGhhciI6IuKHjCIsInJsbSI6IuKAjyIsInJtb3VzdGFjaGUiOiLijrEiLCJybW91c3QiOiLijrEiLCJybm1pZCI6IuKrriIsInJvYW5nIjoi4p+tIiwicm9hcnIiOiLih74iLCJyb2JyayI6IuKfpyIsInJvcGFyIjoi4qaGIiwicm9wZiI6IvCdlaMiLCJSb3BmIjoi4oSdIiwicm9wbHVzIjoi4qiuIiwicm90aW1lcyI6IuKotSIsIlJvdW5kSW1wbGllcyI6IuKlsCIsInJwYXIiOiIpIiwicnBhcmd0Ijoi4qaUIiwicnBwb2xpbnQiOiLiqJIiLCJycmFyciI6IuKHiSIsIlJyaWdodGFycm93Ijoi4oebIiwicnNhcXVvIjoi4oC6IiwicnNjciI6IvCdk4ciLCJSc2NyIjoi4oSbIiwicnNoIjoi4oaxIiwiUnNoIjoi4oaxIiwicnNxYiI6Il0iLCJyc3F1byI6IuKAmSIsInJzcXVvciI6IuKAmSIsInJ0aHJlZSI6IuKLjCIsInJ0aW1lcyI6IuKLiiIsInJ0cmkiOiLilrkiLCJydHJpZSI6IuKKtSIsInJ0cmlmIjoi4pa4IiwicnRyaWx0cmkiOiLip44iLCJSdWxlRGVsYXllZCI6IuKntCIsInJ1bHVoYXIiOiLipagiLCJyeCI6IuKEniIsIlNhY3V0ZSI6IsWaIiwic2FjdXRlIjoixZsiLCJzYnF1byI6IuKAmiIsInNjYXAiOiLiqrgiLCJTY2Fyb24iOiLFoCIsInNjYXJvbiI6IsWhIiwiU2MiOiLiqrwiLCJzYyI6IuKJuyIsInNjY3VlIjoi4om9Iiwic2NlIjoi4qqwIiwic2NFIjoi4qq0IiwiU2NlZGlsIjoixZ4iLCJzY2VkaWwiOiLFnyIsIlNjaXJjIjoixZwiLCJzY2lyYyI6IsWdIiwic2NuYXAiOiLiqroiLCJzY25FIjoi4qq2Iiwic2Nuc2ltIjoi4oupIiwic2Nwb2xpbnQiOiLiqJMiLCJzY3NpbSI6IuKJvyIsIlNjeSI6ItChIiwic2N5Ijoi0YEiLCJzZG90YiI6IuKKoSIsInNkb3QiOiLii4UiLCJzZG90ZSI6IuKppiIsInNlYXJoayI6IuKkpSIsInNlYXJyIjoi4oaYIiwic2VBcnIiOiLih5giLCJzZWFycm93Ijoi4oaYIiwic2VjdCI6IsKnIiwic2VtaSI6IjsiLCJzZXN3YXIiOiLipKkiLCJzZXRtaW51cyI6IuKIliIsInNldG1uIjoi4oiWIiwic2V4dCI6IuKctiIsIlNmciI6IvCdlJYiLCJzZnIiOiLwnZSwIiwic2Zyb3duIjoi4oyiIiwic2hhcnAiOiLima8iLCJTSENIY3kiOiLQqSIsInNoY2hjeSI6ItGJIiwiU0hjeSI6ItCoIiwic2hjeSI6ItGIIiwiU2hvcnREb3duQXJyb3ciOiLihpMiLCJTaG9ydExlZnRBcnJvdyI6IuKGkCIsInNob3J0bWlkIjoi4oijIiwic2hvcnRwYXJhbGxlbCI6IuKIpSIsIlNob3J0UmlnaHRBcnJvdyI6IuKGkiIsIlNob3J0VXBBcnJvdyI6IuKGkSIsInNoeSI6IsKtIiwiU2lnbWEiOiLOoyIsInNpZ21hIjoiz4MiLCJzaWdtYWYiOiLPgiIsInNpZ21hdiI6Is+CIiwic2ltIjoi4oi8Iiwic2ltZG90Ijoi4qmqIiwic2ltZSI6IuKJgyIsInNpbWVxIjoi4omDIiwic2ltZyI6IuKqniIsInNpbWdFIjoi4qqgIiwic2ltbCI6IuKqnSIsInNpbWxFIjoi4qqfIiwic2ltbmUiOiLiiYYiLCJzaW1wbHVzIjoi4qikIiwic2ltcmFyciI6IuKlsiIsInNsYXJyIjoi4oaQIiwiU21hbGxDaXJjbGUiOiLiiJgiLCJzbWFsbHNldG1pbnVzIjoi4oiWIiwic21hc2hwIjoi4qizIiwic21lcGFyc2wiOiLip6QiLCJzbWlkIjoi4oijIiwic21pbGUiOiLijKMiLCJzbXQiOiLiqqoiLCJzbXRlIjoi4qqsIiwic210ZXMiOiLiqqzvuIAiLCJTT0ZUY3kiOiLQrCIsInNvZnRjeSI6ItGMIiwic29sYmFyIjoi4oy/Iiwic29sYiI6IuKnhCIsInNvbCI6Ii8iLCJTb3BmIjoi8J2ViiIsInNvcGYiOiLwnZWkIiwic3BhZGVzIjoi4pmgIiwic3BhZGVzdWl0Ijoi4pmgIiwic3BhciI6IuKIpSIsInNxY2FwIjoi4oqTIiwic3FjYXBzIjoi4oqT77iAIiwic3FjdXAiOiLiipQiLCJzcWN1cHMiOiLiipTvuIAiLCJTcXJ0Ijoi4oiaIiwic3FzdWIiOiLiio8iLCJzcXN1YmUiOiLiipEiLCJzcXN1YnNldCI6IuKKjyIsInNxc3Vic2V0ZXEiOiLiipEiLCJzcXN1cCI6IuKKkCIsInNxc3VwZSI6IuKKkiIsInNxc3Vwc2V0Ijoi4oqQIiwic3FzdXBzZXRlcSI6IuKKkiIsInNxdWFyZSI6IuKWoSIsIlNxdWFyZSI6IuKWoSIsIlNxdWFyZUludGVyc2VjdGlvbiI6IuKKkyIsIlNxdWFyZVN1YnNldCI6IuKKjyIsIlNxdWFyZVN1YnNldEVxdWFsIjoi4oqRIiwiU3F1YXJlU3VwZXJzZXQiOiLiipAiLCJTcXVhcmVTdXBlcnNldEVxdWFsIjoi4oqSIiwiU3F1YXJlVW5pb24iOiLiipQiLCJzcXVhcmYiOiLilqoiLCJzcXUiOiLilqEiLCJzcXVmIjoi4paqIiwic3JhcnIiOiLihpIiLCJTc2NyIjoi8J2SriIsInNzY3IiOiLwnZOIIiwic3NldG1uIjoi4oiWIiwic3NtaWxlIjoi4oyjIiwic3N0YXJmIjoi4ouGIiwiU3RhciI6IuKLhiIsInN0YXIiOiLimIYiLCJzdGFyZiI6IuKYhSIsInN0cmFpZ2h0ZXBzaWxvbiI6Is+1Iiwic3RyYWlnaHRwaGkiOiLPlSIsInN0cm5zIjoiwq8iLCJzdWIiOiLiioIiLCJTdWIiOiLii5AiLCJzdWJkb3QiOiLiqr0iLCJzdWJFIjoi4quFIiwic3ViZSI6IuKKhiIsInN1YmVkb3QiOiLiq4MiLCJzdWJtdWx0Ijoi4quBIiwic3VibkUiOiLiq4siLCJzdWJuZSI6IuKKiiIsInN1YnBsdXMiOiLiqr8iLCJzdWJyYXJyIjoi4qW5Iiwic3Vic2V0Ijoi4oqCIiwiU3Vic2V0Ijoi4ouQIiwic3Vic2V0ZXEiOiLiioYiLCJzdWJzZXRlcXEiOiLiq4UiLCJTdWJzZXRFcXVhbCI6IuKKhiIsInN1YnNldG5lcSI6IuKKiiIsInN1YnNldG5lcXEiOiLiq4siLCJzdWJzaW0iOiLiq4ciLCJzdWJzdWIiOiLiq5UiLCJzdWJzdXAiOiLiq5MiLCJzdWNjYXBwcm94Ijoi4qq4Iiwic3VjYyI6IuKJuyIsInN1Y2NjdXJseWVxIjoi4om9IiwiU3VjY2VlZHMiOiLiibsiLCJTdWNjZWVkc0VxdWFsIjoi4qqwIiwiU3VjY2VlZHNTbGFudEVxdWFsIjoi4om9IiwiU3VjY2VlZHNUaWxkZSI6IuKJvyIsInN1Y2NlcSI6IuKqsCIsInN1Y2NuYXBwcm94Ijoi4qq6Iiwic3VjY25lcXEiOiLiqrYiLCJzdWNjbnNpbSI6IuKLqSIsInN1Y2NzaW0iOiLiib8iLCJTdWNoVGhhdCI6IuKIiyIsInN1bSI6IuKIkSIsIlN1bSI6IuKIkSIsInN1bmciOiLimaoiLCJzdXAxIjoiwrkiLCJzdXAyIjoiwrIiLCJzdXAzIjoiwrMiLCJzdXAiOiLiioMiLCJTdXAiOiLii5EiLCJzdXBkb3QiOiLiqr4iLCJzdXBkc3ViIjoi4quYIiwic3VwRSI6IuKrhiIsInN1cGUiOiLiiociLCJzdXBlZG90Ijoi4quEIiwiU3VwZXJzZXQiOiLiioMiLCJTdXBlcnNldEVxdWFsIjoi4oqHIiwic3VwaHNvbCI6IuKfiSIsInN1cGhzdWIiOiLiq5ciLCJzdXBsYXJyIjoi4qW7Iiwic3VwbXVsdCI6IuKrgiIsInN1cG5FIjoi4quMIiwic3VwbmUiOiLiiosiLCJzdXBwbHVzIjoi4quAIiwic3Vwc2V0Ijoi4oqDIiwiU3Vwc2V0Ijoi4ouRIiwic3Vwc2V0ZXEiOiLiiociLCJzdXBzZXRlcXEiOiLiq4YiLCJzdXBzZXRuZXEiOiLiiosiLCJzdXBzZXRuZXFxIjoi4quMIiwic3Vwc2ltIjoi4quIIiwic3Vwc3ViIjoi4quUIiwic3Vwc3VwIjoi4quWIiwic3dhcmhrIjoi4qSmIiwic3dhcnIiOiLihpkiLCJzd0FyciI6IuKHmSIsInN3YXJyb3ciOiLihpkiLCJzd253YXIiOiLipKoiLCJzemxpZyI6IsOfIiwiVGFiIjoiXFx0IiwidGFyZ2V0Ijoi4oyWIiwiVGF1IjoizqQiLCJ0YXUiOiLPhCIsInRicmsiOiLijrQiLCJUY2Fyb24iOiLFpCIsInRjYXJvbiI6IsWlIiwiVGNlZGlsIjoixaIiLCJ0Y2VkaWwiOiLFoyIsIlRjeSI6ItCiIiwidGN5Ijoi0YIiLCJ0ZG90Ijoi4oObIiwidGVscmVjIjoi4oyVIiwiVGZyIjoi8J2UlyIsInRmciI6IvCdlLEiLCJ0aGVyZTQiOiLiiLQiLCJ0aGVyZWZvcmUiOiLiiLQiLCJUaGVyZWZvcmUiOiLiiLQiLCJUaGV0YSI6Is6YIiwidGhldGEiOiLOuCIsInRoZXRhc3ltIjoiz5EiLCJ0aGV0YXYiOiLPkSIsInRoaWNrYXBwcm94Ijoi4omIIiwidGhpY2tzaW0iOiLiiLwiLCJUaGlja1NwYWNlIjoi4oGf4oCKIiwiVGhpblNwYWNlIjoi4oCJIiwidGhpbnNwIjoi4oCJIiwidGhrYXAiOiLiiYgiLCJ0aGtzaW0iOiLiiLwiLCJUSE9STiI6IsOeIiwidGhvcm4iOiLDviIsInRpbGRlIjoiy5wiLCJUaWxkZSI6IuKIvCIsIlRpbGRlRXF1YWwiOiLiiYMiLCJUaWxkZUZ1bGxFcXVhbCI6IuKJhSIsIlRpbGRlVGlsZGUiOiLiiYgiLCJ0aW1lc2JhciI6IuKosSIsInRpbWVzYiI6IuKKoCIsInRpbWVzIjoiw5ciLCJ0aW1lc2QiOiLiqLAiLCJ0aW50Ijoi4oitIiwidG9lYSI6IuKkqCIsInRvcGJvdCI6IuKMtiIsInRvcGNpciI6IuKrsSIsInRvcCI6IuKKpCIsIlRvcGYiOiLwnZWLIiwidG9wZiI6IvCdlaUiLCJ0b3Bmb3JrIjoi4quaIiwidG9zYSI6IuKkqSIsInRwcmltZSI6IuKAtCIsInRyYWRlIjoi4oSiIiwiVFJBREUiOiLihKIiLCJ0cmlhbmdsZSI6IuKWtSIsInRyaWFuZ2xlZG93biI6IuKWvyIsInRyaWFuZ2xlbGVmdCI6IuKXgyIsInRyaWFuZ2xlbGVmdGVxIjoi4oq0IiwidHJpYW5nbGVxIjoi4omcIiwidHJpYW5nbGVyaWdodCI6IuKWuSIsInRyaWFuZ2xlcmlnaHRlcSI6IuKKtSIsInRyaWRvdCI6IuKXrCIsInRyaWUiOiLiiZwiLCJ0cmltaW51cyI6IuKouiIsIlRyaXBsZURvdCI6IuKDmyIsInRyaXBsdXMiOiLiqLkiLCJ0cmlzYiI6IuKnjSIsInRyaXRpbWUiOiLiqLsiLCJ0cnBleml1bSI6IuKPoiIsIlRzY3IiOiLwnZKvIiwidHNjciI6IvCdk4kiLCJUU2N5Ijoi0KYiLCJ0c2N5Ijoi0YYiLCJUU0hjeSI6ItCLIiwidHNoY3kiOiLRmyIsIlRzdHJvayI6IsWmIiwidHN0cm9rIjoixaciLCJ0d2l4dCI6IuKJrCIsInR3b2hlYWRsZWZ0YXJyb3ciOiLihp4iLCJ0d29oZWFkcmlnaHRhcnJvdyI6IuKGoCIsIlVhY3V0ZSI6IsOaIiwidWFjdXRlIjoiw7oiLCJ1YXJyIjoi4oaRIiwiVWFyciI6IuKGnyIsInVBcnIiOiLih5EiLCJVYXJyb2NpciI6IuKliSIsIlVicmN5Ijoi0I4iLCJ1YnJjeSI6ItGeIiwiVWJyZXZlIjoixawiLCJ1YnJldmUiOiLFrSIsIlVjaXJjIjoiw5siLCJ1Y2lyYyI6IsO7IiwiVWN5Ijoi0KMiLCJ1Y3kiOiLRgyIsInVkYXJyIjoi4oeFIiwiVWRibGFjIjoixbAiLCJ1ZGJsYWMiOiLFsSIsInVkaGFyIjoi4qWuIiwidWZpc2h0Ijoi4qW+IiwiVWZyIjoi8J2UmCIsInVmciI6IvCdlLIiLCJVZ3JhdmUiOiLDmSIsInVncmF2ZSI6IsO5IiwidUhhciI6IuKloyIsInVoYXJsIjoi4oa/IiwidWhhcnIiOiLihr4iLCJ1aGJsayI6IuKWgCIsInVsY29ybiI6IuKMnCIsInVsY29ybmVyIjoi4oycIiwidWxjcm9wIjoi4oyPIiwidWx0cmkiOiLil7giLCJVbWFjciI6IsWqIiwidW1hY3IiOiLFqyIsInVtbCI6IsKoIiwiVW5kZXJCYXIiOiJfIiwiVW5kZXJCcmFjZSI6IuKPnyIsIlVuZGVyQnJhY2tldCI6IuKOtSIsIlVuZGVyUGFyZW50aGVzaXMiOiLij50iLCJVbmlvbiI6IuKLgyIsIlVuaW9uUGx1cyI6IuKKjiIsIlVvZ29uIjoixbIiLCJ1b2dvbiI6IsWzIiwiVW9wZiI6IvCdlYwiLCJ1b3BmIjoi8J2VpiIsIlVwQXJyb3dCYXIiOiLipJIiLCJ1cGFycm93Ijoi4oaRIiwiVXBBcnJvdyI6IuKGkSIsIlVwYXJyb3ciOiLih5EiLCJVcEFycm93RG93bkFycm93Ijoi4oeFIiwidXBkb3duYXJyb3ciOiLihpUiLCJVcERvd25BcnJvdyI6IuKGlSIsIlVwZG93bmFycm93Ijoi4oeVIiwiVXBFcXVpbGlicml1bSI6IuKlriIsInVwaGFycG9vbmxlZnQiOiLihr8iLCJ1cGhhcnBvb25yaWdodCI6IuKGviIsInVwbHVzIjoi4oqOIiwiVXBwZXJMZWZ0QXJyb3ciOiLihpYiLCJVcHBlclJpZ2h0QXJyb3ciOiLihpciLCJ1cHNpIjoiz4UiLCJVcHNpIjoiz5IiLCJ1cHNpaCI6Is+SIiwiVXBzaWxvbiI6Is6lIiwidXBzaWxvbiI6Is+FIiwiVXBUZWVBcnJvdyI6IuKGpSIsIlVwVGVlIjoi4oqlIiwidXB1cGFycm93cyI6IuKHiCIsInVyY29ybiI6IuKMnSIsInVyY29ybmVyIjoi4oydIiwidXJjcm9wIjoi4oyOIiwiVXJpbmciOiLFriIsInVyaW5nIjoixa8iLCJ1cnRyaSI6IuKXuSIsIlVzY3IiOiLwnZKwIiwidXNjciI6IvCdk4oiLCJ1dGRvdCI6IuKLsCIsIlV0aWxkZSI6IsWoIiwidXRpbGRlIjoixakiLCJ1dHJpIjoi4pa1IiwidXRyaWYiOiLilrQiLCJ1dWFyciI6IuKHiCIsIlV1bWwiOiLDnCIsInV1bWwiOiLDvCIsInV3YW5nbGUiOiLipqciLCJ2YW5ncnQiOiLippwiLCJ2YXJlcHNpbG9uIjoiz7UiLCJ2YXJrYXBwYSI6Is+wIiwidmFybm90aGluZyI6IuKIhSIsInZhcnBoaSI6Is+VIiwidmFycGkiOiLPliIsInZhcnByb3B0byI6IuKInSIsInZhcnIiOiLihpUiLCJ2QXJyIjoi4oeVIiwidmFycmhvIjoiz7EiLCJ2YXJzaWdtYSI6Is+CIiwidmFyc3Vic2V0bmVxIjoi4oqK77iAIiwidmFyc3Vic2V0bmVxcSI6IuKri++4gCIsInZhcnN1cHNldG5lcSI6IuKKi++4gCIsInZhcnN1cHNldG5lcXEiOiLiq4zvuIAiLCJ2YXJ0aGV0YSI6Is+RIiwidmFydHJpYW5nbGVsZWZ0Ijoi4oqyIiwidmFydHJpYW5nbGVyaWdodCI6IuKKsyIsInZCYXIiOiLiq6giLCJWYmFyIjoi4qurIiwidkJhcnYiOiLiq6kiLCJWY3kiOiLQkiIsInZjeSI6ItCyIiwidmRhc2giOiLiiqIiLCJ2RGFzaCI6IuKKqCIsIlZkYXNoIjoi4oqpIiwiVkRhc2giOiLiiqsiLCJWZGFzaGwiOiLiq6YiLCJ2ZWViYXIiOiLiirsiLCJ2ZWUiOiLiiKgiLCJWZWUiOiLii4EiLCJ2ZWVlcSI6IuKJmiIsInZlbGxpcCI6IuKLriIsInZlcmJhciI6InwiLCJWZXJiYXIiOiLigJYiLCJ2ZXJ0IjoifCIsIlZlcnQiOiLigJYiLCJWZXJ0aWNhbEJhciI6IuKIoyIsIlZlcnRpY2FsTGluZSI6InwiLCJWZXJ0aWNhbFNlcGFyYXRvciI6IuKdmCIsIlZlcnRpY2FsVGlsZGUiOiLiiYAiLCJWZXJ5VGhpblNwYWNlIjoi4oCKIiwiVmZyIjoi8J2UmSIsInZmciI6IvCdlLMiLCJ2bHRyaSI6IuKKsiIsInZuc3ViIjoi4oqC4oOSIiwidm5zdXAiOiLiioPig5IiLCJWb3BmIjoi8J2VjSIsInZvcGYiOiLwnZWnIiwidnByb3AiOiLiiJ0iLCJ2cnRyaSI6IuKKsyIsIlZzY3IiOiLwnZKxIiwidnNjciI6IvCdk4siLCJ2c3VibkUiOiLiq4vvuIAiLCJ2c3VibmUiOiLiiorvuIAiLCJ2c3VwbkUiOiLiq4zvuIAiLCJ2c3VwbmUiOiLiiovvuIAiLCJWdmRhc2giOiLiiqoiLCJ2emlnemFnIjoi4qaaIiwiV2NpcmMiOiLFtCIsIndjaXJjIjoixbUiLCJ3ZWRiYXIiOiLiqZ8iLCJ3ZWRnZSI6IuKIpyIsIldlZGdlIjoi4ouAIiwid2VkZ2VxIjoi4omZIiwid2VpZXJwIjoi4oSYIiwiV2ZyIjoi8J2UmiIsIndmciI6IvCdlLQiLCJXb3BmIjoi8J2VjiIsIndvcGYiOiLwnZWoIiwid3AiOiLihJgiLCJ3ciI6IuKJgCIsIndyZWF0aCI6IuKJgCIsIldzY3IiOiLwnZKyIiwid3NjciI6IvCdk4wiLCJ4Y2FwIjoi4ouCIiwieGNpcmMiOiLil68iLCJ4Y3VwIjoi4ouDIiwieGR0cmkiOiLilr0iLCJYZnIiOiLwnZSbIiwieGZyIjoi8J2UtSIsInhoYXJyIjoi4p+3IiwieGhBcnIiOiLin7oiLCJYaSI6Is6eIiwieGkiOiLOviIsInhsYXJyIjoi4p+1IiwieGxBcnIiOiLin7giLCJ4bWFwIjoi4p+8IiwieG5pcyI6IuKLuyIsInhvZG90Ijoi4qiAIiwiWG9wZiI6IvCdlY8iLCJ4b3BmIjoi8J2VqSIsInhvcGx1cyI6IuKogSIsInhvdGltZSI6IuKogiIsInhyYXJyIjoi4p+2IiwieHJBcnIiOiLin7kiLCJYc2NyIjoi8J2SsyIsInhzY3IiOiLwnZONIiwieHNxY3VwIjoi4qiGIiwieHVwbHVzIjoi4qiEIiwieHV0cmkiOiLilrMiLCJ4dmVlIjoi4ouBIiwieHdlZGdlIjoi4ouAIiwiWWFjdXRlIjoiw50iLCJ5YWN1dGUiOiLDvSIsIllBY3kiOiLQryIsInlhY3kiOiLRjyIsIlljaXJjIjoixbYiLCJ5Y2lyYyI6IsW3IiwiWWN5Ijoi0KsiLCJ5Y3kiOiLRiyIsInllbiI6IsKlIiwiWWZyIjoi8J2UnCIsInlmciI6IvCdlLYiLCJZSWN5Ijoi0IciLCJ5aWN5Ijoi0ZciLCJZb3BmIjoi8J2VkCIsInlvcGYiOiLwnZWqIiwiWXNjciI6IvCdkrQiLCJ5c2NyIjoi8J2TjiIsIllVY3kiOiLQriIsInl1Y3kiOiLRjiIsInl1bWwiOiLDvyIsIll1bWwiOiLFuCIsIlphY3V0ZSI6IsW5IiwiemFjdXRlIjoixboiLCJaY2Fyb24iOiLFvSIsInpjYXJvbiI6IsW+IiwiWmN5Ijoi0JciLCJ6Y3kiOiLQtyIsIlpkb3QiOiLFuyIsInpkb3QiOiLFvCIsInplZXRyZiI6IuKEqCIsIlplcm9XaWR0aFNwYWNlIjoi4oCLIiwiWmV0YSI6Is6WIiwiemV0YSI6Is62IiwiemZyIjoi8J2UtyIsIlpmciI6IuKEqCIsIlpIY3kiOiLQliIsInpoY3kiOiLQtiIsInppZ3JhcnIiOiLih50iLCJ6b3BmIjoi8J2VqyIsIlpvcGYiOiLihKQiLCJac2NyIjoi8J2StSIsInpzY3IiOiLwnZOPIiwiendqIjoi4oCNIiwienduaiI6IuKAjCJ9Jyl9LGZ1bmN0aW9uKEwpe0wuZXhwb3J0cz1KU09OLnBhcnNlKCd7IkFhY3V0ZSI6IsOBIiwiYWFjdXRlIjoiw6EiLCJBY2lyYyI6IsOCIiwiYWNpcmMiOiLDoiIsImFjdXRlIjoiwrQiLCJBRWxpZyI6IsOGIiwiYWVsaWciOiLDpiIsIkFncmF2ZSI6IsOAIiwiYWdyYXZlIjoiw6AiLCJhbXAiOiImIiwiQU1QIjoiJiIsIkFyaW5nIjoiw4UiLCJhcmluZyI6IsOlIiwiQXRpbGRlIjoiw4MiLCJhdGlsZGUiOiLDoyIsIkF1bWwiOiLDhCIsImF1bWwiOiLDpCIsImJydmJhciI6IsKmIiwiQ2NlZGlsIjoiw4ciLCJjY2VkaWwiOiLDpyIsImNlZGlsIjoiwrgiLCJjZW50IjoiwqIiLCJjb3B5IjoiwqkiLCJDT1BZIjoiwqkiLCJjdXJyZW4iOiLCpCIsImRlZyI6IsKwIiwiZGl2aWRlIjoiw7ciLCJFYWN1dGUiOiLDiSIsImVhY3V0ZSI6IsOpIiwiRWNpcmMiOiLDiiIsImVjaXJjIjoiw6oiLCJFZ3JhdmUiOiLDiCIsImVncmF2ZSI6IsOoIiwiRVRIIjoiw5AiLCJldGgiOiLDsCIsIkV1bWwiOiLDiyIsImV1bWwiOiLDqyIsImZyYWMxMiI6IsK9IiwiZnJhYzE0IjoiwrwiLCJmcmFjMzQiOiLCviIsImd0IjoiPiIsIkdUIjoiPiIsIklhY3V0ZSI6IsONIiwiaWFjdXRlIjoiw60iLCJJY2lyYyI6IsOOIiwiaWNpcmMiOiLDriIsImlleGNsIjoiwqEiLCJJZ3JhdmUiOiLDjCIsImlncmF2ZSI6IsOsIiwiaXF1ZXN0Ijoiwr8iLCJJdW1sIjoiw48iLCJpdW1sIjoiw68iLCJsYXF1byI6IsKrIiwibHQiOiI8IiwiTFQiOiI8IiwibWFjciI6IsKvIiwibWljcm8iOiLCtSIsIm1pZGRvdCI6IsK3IiwibmJzcCI6IsKgIiwibm90IjoiwqwiLCJOdGlsZGUiOiLDkSIsIm50aWxkZSI6IsOxIiwiT2FjdXRlIjoiw5MiLCJvYWN1dGUiOiLDsyIsIk9jaXJjIjoiw5QiLCJvY2lyYyI6IsO0IiwiT2dyYXZlIjoiw5IiLCJvZ3JhdmUiOiLDsiIsIm9yZGYiOiLCqiIsIm9yZG0iOiLCuiIsIk9zbGFzaCI6IsOYIiwib3NsYXNoIjoiw7giLCJPdGlsZGUiOiLDlSIsIm90aWxkZSI6IsO1IiwiT3VtbCI6IsOWIiwib3VtbCI6IsO2IiwicGFyYSI6IsK2IiwicGx1c21uIjoiwrEiLCJwb3VuZCI6IsKjIiwicXVvdCI6IlxcIiIsIlFVT1QiOiJcXCIiLCJyYXF1byI6IsK7IiwicmVnIjoiwq4iLCJSRUciOiLCriIsInNlY3QiOiLCpyIsInNoeSI6IsKtIiwic3VwMSI6IsK5Iiwic3VwMiI6IsKyIiwic3VwMyI6IsKzIiwic3psaWciOiLDnyIsIlRIT1JOIjoiw54iLCJ0aG9ybiI6IsO+IiwidGltZXMiOiLDlyIsIlVhY3V0ZSI6IsOaIiwidWFjdXRlIjoiw7oiLCJVY2lyYyI6IsObIiwidWNpcmMiOiLDuyIsIlVncmF2ZSI6IsOZIiwidWdyYXZlIjoiw7kiLCJ1bWwiOiLCqCIsIlV1bWwiOiLDnCIsInV1bWwiOiLDvCIsIllhY3V0ZSI6IsOdIiwieWFjdXRlIjoiw70iLCJ5ZW4iOiLCpSIsInl1bWwiOiLDvyJ9Jyl9LGZ1bmN0aW9uKEwpe0wuZXhwb3J0cz1KU09OLnBhcnNlKGB7ImFtcCI6IiYiLCJhcG9zIjoiJyIsImd0IjoiPiIsImx0IjoiPCIsInF1b3QiOiJcXCIifWApfSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKFQpe3JldHVybiBUJiZULl9fZXNNb2R1bGU/VDp7ZGVmYXVsdDpUfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciBsPWEodCgyNjUpKTtmdW5jdGlvbiBNKFQpe2lmKFQ+PTU1Mjk2JiZUPD01NzM0M3x8VD4xMTE0MTExKXJldHVybiLvv70iO1QgaW4gbC5kZWZhdWx0JiYoVD1sLmRlZmF1bHRbVF0pO3ZhciBkPSIiO3JldHVybiBUPjY1NTM1JiYoVC09NjU1MzYsZCs9U3RyaW5nLmZyb21DaGFyQ29kZShUPj4+MTAmMTAyM3w1NTI5NiksVD01NjMyMHxUJjEwMjMpLGQrPVN0cmluZy5mcm9tQ2hhckNvZGUoVCksZH1lLmRlZmF1bHQ9TX0sZnVuY3Rpb24oTCl7TC5leHBvcnRzPUpTT04ucGFyc2UoJ3siMCI6NjU1MzMsIjEyOCI6ODM2NCwiMTMwIjo4MjE4LCIxMzEiOjQwMiwiMTMyIjo4MjIyLCIxMzMiOjgyMzAsIjEzNCI6ODIyNCwiMTM1Ijo4MjI1LCIxMzYiOjcxMCwiMTM3Ijo4MjQwLCIxMzgiOjM1MiwiMTM5Ijo4MjQ5LCIxNDAiOjMzOCwiMTQyIjozODEsIjE0NSI6ODIxNiwiMTQ2Ijo4MjE3LCIxNDciOjgyMjAsIjE0OCI6ODIyMSwiMTQ5Ijo4MjI2LCIxNTAiOjgyMTEsIjE1MSI6ODIxMiwiMTUyIjo3MzIsIjE1MyI6ODQ4MiwiMTU0IjozNTMsIjE1NSI6ODI1MCwiMTU2IjozMzksIjE1OCI6MzgyLCIxNTkiOjM3Nn0nKX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihtKXtyZXR1cm4gbSYmbS5fX2VzTW9kdWxlP206e2RlZmF1bHQ6bX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlLmVzY2FwZT1lLmVuY29kZUhUTUw9ZS5lbmNvZGVYTUw9dm9pZCAwO3ZhciBsPWEodCgyNjMpKSxNPU8obC5kZWZhdWx0KSxUPWYoTSk7ZS5lbmNvZGVYTUw9QyhNLFQpO3ZhciBkPWEodCgyNjEpKSx1PU8oZC5kZWZhdWx0KSxjPWYodSk7ZS5lbmNvZGVIVE1MPUModSxjKTtmdW5jdGlvbiBPKG0pe3JldHVybiBPYmplY3Qua2V5cyhtKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uKHIsaSl7cmV0dXJuIHJbbVtpXV09IiYiK2krIjsiLHJ9LHt9KX1mdW5jdGlvbiBmKG0pe2Zvcih2YXIgcj1bXSxpPVtdLG49MCxzPU9iamVjdC5rZXlzKG0pO248cy5sZW5ndGg7bisrKXt2YXIgeD1zW25dO3gubGVuZ3RoPT09MT9yLnB1c2goIlxcIit4KTppLnB1c2goeCl9ci5zb3J0KCk7Zm9yKHZhciBQPTA7UDxyLmxlbmd0aC0xO1ArKyl7Zm9yKHZhciBSPVA7UjxyLmxlbmd0aC0xJiZyW1JdLmNoYXJDb2RlQXQoMSkrMT09PXJbUisxXS5jaGFyQ29kZUF0KDEpOylSKz0xO3ZhciBiPTErUi1QO2I8M3x8ci5zcGxpY2UoUCxiLHJbUF0rIi0iK3JbUl0pfXJldHVybiBpLnVuc2hpZnQoIlsiK3Iuam9pbigiIikrIl0iKSxuZXcgUmVnRXhwKGkuam9pbigifCIpLCJnIil9dmFyIGc9Lyg/OltceDgwLVx1RDdGRlx1RTAwMC1cdUZGRkZdfFtcdUQ4MDAtXHVEQkZGXVtcdURDMDAtXHVERkZGXXxbXHVEODAwLVx1REJGRl0oPyFbXHVEQzAwLVx1REZGRl0pfCg/OlteXHVEODAwLVx1REJGRl18XilbXHVEQzAwLVx1REZGRl0pL2c7ZnVuY3Rpb24gdihtKXtyZXR1cm4iJiN4IittLmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKyI7In1mdW5jdGlvbiBDKG0scil7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiBpLnJlcGxhY2UocixmdW5jdGlvbihuKXtyZXR1cm4gbVtuXX0pLnJlcGxhY2UoZyx2KX19dmFyIHA9ZihNKTtmdW5jdGlvbiBoKG0pe3JldHVybiBtLnJlcGxhY2UocCx2KS5yZXBsYWNlKGcsdil9ZS5lc2NhcGU9aH0sZnVuY3Rpb24oTCl7TC5leHBvcnRzPUpTT04ucGFyc2UoJ3siZWxlbWVudE5hbWVzIjp7ImFsdGdseXBoIjoiYWx0R2x5cGgiLCJhbHRnbHlwaGRlZiI6ImFsdEdseXBoRGVmIiwiYWx0Z2x5cGhpdGVtIjoiYWx0R2x5cGhJdGVtIiwiYW5pbWF0ZWNvbG9yIjoiYW5pbWF0ZUNvbG9yIiwiYW5pbWF0ZW1vdGlvbiI6ImFuaW1hdGVNb3Rpb24iLCJhbmltYXRldHJhbnNmb3JtIjoiYW5pbWF0ZVRyYW5zZm9ybSIsImNsaXBwYXRoIjoiY2xpcFBhdGgiLCJmZWJsZW5kIjoiZmVCbGVuZCIsImZlY29sb3JtYXRyaXgiOiJmZUNvbG9yTWF0cml4IiwiZmVjb21wb25lbnR0cmFuc2ZlciI6ImZlQ29tcG9uZW50VHJhbnNmZXIiLCJmZWNvbXBvc2l0ZSI6ImZlQ29tcG9zaXRlIiwiZmVjb252b2x2ZW1hdHJpeCI6ImZlQ29udm9sdmVNYXRyaXgiLCJmZWRpZmZ1c2VsaWdodGluZyI6ImZlRGlmZnVzZUxpZ2h0aW5nIiwiZmVkaXNwbGFjZW1lbnRtYXAiOiJmZURpc3BsYWNlbWVudE1hcCIsImZlZGlzdGFudGxpZ2h0IjoiZmVEaXN0YW50TGlnaHQiLCJmZWRyb3BzaGFkb3ciOiJmZURyb3BTaGFkb3ciLCJmZWZsb29kIjoiZmVGbG9vZCIsImZlZnVuY2EiOiJmZUZ1bmNBIiwiZmVmdW5jYiI6ImZlRnVuY0IiLCJmZWZ1bmNnIjoiZmVGdW5jRyIsImZlZnVuY3IiOiJmZUZ1bmNSIiwiZmVnYXVzc2lhbmJsdXIiOiJmZUdhdXNzaWFuQmx1ciIsImZlaW1hZ2UiOiJmZUltYWdlIiwiZmVtZXJnZSI6ImZlTWVyZ2UiLCJmZW1lcmdlbm9kZSI6ImZlTWVyZ2VOb2RlIiwiZmVtb3JwaG9sb2d5IjoiZmVNb3JwaG9sb2d5IiwiZmVvZmZzZXQiOiJmZU9mZnNldCIsImZlcG9pbnRsaWdodCI6ImZlUG9pbnRMaWdodCIsImZlc3BlY3VsYXJsaWdodGluZyI6ImZlU3BlY3VsYXJMaWdodGluZyIsImZlc3BvdGxpZ2h0IjoiZmVTcG90TGlnaHQiLCJmZXRpbGUiOiJmZVRpbGUiLCJmZXR1cmJ1bGVuY2UiOiJmZVR1cmJ1bGVuY2UiLCJmb3JlaWdub2JqZWN0IjoiZm9yZWlnbk9iamVjdCIsImdseXBocmVmIjoiZ2x5cGhSZWYiLCJsaW5lYXJncmFkaWVudCI6ImxpbmVhckdyYWRpZW50IiwicmFkaWFsZ3JhZGllbnQiOiJyYWRpYWxHcmFkaWVudCIsInRleHRwYXRoIjoidGV4dFBhdGgifSwiYXR0cmlidXRlTmFtZXMiOnsiZGVmaW5pdGlvbnVybCI6ImRlZmluaXRpb25VUkwiLCJhdHRyaWJ1dGVuYW1lIjoiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZXR5cGUiOiJhdHRyaWJ1dGVUeXBlIiwiYmFzZWZyZXF1ZW5jeSI6ImJhc2VGcmVxdWVuY3kiLCJiYXNlcHJvZmlsZSI6ImJhc2VQcm9maWxlIiwiY2FsY21vZGUiOiJjYWxjTW9kZSIsImNsaXBwYXRodW5pdHMiOiJjbGlwUGF0aFVuaXRzIiwiZGlmZnVzZWNvbnN0YW50IjoiZGlmZnVzZUNvbnN0YW50IiwiZWRnZW1vZGUiOiJlZGdlTW9kZSIsImZpbHRlcnVuaXRzIjoiZmlsdGVyVW5pdHMiLCJnbHlwaHJlZiI6ImdseXBoUmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iOiJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiOiJncmFkaWVudFVuaXRzIiwia2VybmVsbWF0cml4Ijoia2VybmVsTWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCI6Imtlcm5lbFVuaXRMZW5ndGgiLCJrZXlwb2ludHMiOiJrZXlQb2ludHMiLCJrZXlzcGxpbmVzIjoia2V5U3BsaW5lcyIsImtleXRpbWVzIjoia2V5VGltZXMiLCJsZW5ndGhhZGp1c3QiOiJsZW5ndGhBZGp1c3QiLCJsaW1pdGluZ2NvbmVhbmdsZSI6ImxpbWl0aW5nQ29uZUFuZ2xlIiwibWFya2VyaGVpZ2h0IjoibWFya2VySGVpZ2h0IiwibWFya2VydW5pdHMiOiJtYXJrZXJVbml0cyIsIm1hcmtlcndpZHRoIjoibWFya2VyV2lkdGgiLCJtYXNrY29udGVudHVuaXRzIjoibWFza0NvbnRlbnRVbml0cyIsIm1hc2t1bml0cyI6Im1hc2tVbml0cyIsIm51bW9jdGF2ZXMiOiJudW1PY3RhdmVzIiwicGF0aGxlbmd0aCI6InBhdGhMZW5ndGgiLCJwYXR0ZXJuY29udGVudHVuaXRzIjoicGF0dGVybkNvbnRlbnRVbml0cyIsInBhdHRlcm50cmFuc2Zvcm0iOiJwYXR0ZXJuVHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIjoicGF0dGVyblVuaXRzIiwicG9pbnRzYXR4IjoicG9pbnRzQXRYIiwicG9pbnRzYXR5IjoicG9pbnRzQXRZIiwicG9pbnRzYXR6IjoicG9pbnRzQXRaIiwicHJlc2VydmVhbHBoYSI6InByZXNlcnZlQWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIjoicHJlc2VydmVBc3BlY3RSYXRpbyIsInByaW1pdGl2ZXVuaXRzIjoicHJpbWl0aXZlVW5pdHMiLCJyZWZ4IjoicmVmWCIsInJlZnkiOiJyZWZZIiwicmVwZWF0Y291bnQiOiJyZXBlYXRDb3VudCIsInJlcGVhdGR1ciI6InJlcGVhdER1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyI6InJlcXVpcmVkRXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiOiJyZXF1aXJlZEZlYXR1cmVzIiwic3BlY3VsYXJjb25zdGFudCI6InNwZWN1bGFyQ29uc3RhbnQiLCJzcGVjdWxhcmV4cG9uZW50Ijoic3BlY3VsYXJFeHBvbmVudCIsInNwcmVhZG1ldGhvZCI6InNwcmVhZE1ldGhvZCIsInN0YXJ0b2Zmc2V0Ijoic3RhcnRPZmZzZXQiLCJzdGRkZXZpYXRpb24iOiJzdGREZXZpYXRpb24iLCJzdGl0Y2h0aWxlcyI6InN0aXRjaFRpbGVzIiwic3VyZmFjZXNjYWxlIjoic3VyZmFjZVNjYWxlIiwic3lzdGVtbGFuZ3VhZ2UiOiJzeXN0ZW1MYW5ndWFnZSIsInRhYmxldmFsdWVzIjoidGFibGVWYWx1ZXMiLCJ0YXJnZXR4IjoidGFyZ2V0WCIsInRhcmdldHkiOiJ0YXJnZXRZIiwidGV4dGxlbmd0aCI6InRleHRMZW5ndGgiLCJ2aWV3Ym94Ijoidmlld0JveCIsInZpZXd0YXJnZXQiOiJ2aWV3VGFyZ2V0IiwieGNoYW5uZWxzZWxlY3RvciI6InhDaGFubmVsU2VsZWN0b3IiLCJ5Y2hhbm5lbHNlbGVjdG9yIjoieUNoYW5uZWxTZWxlY3RvciIsInpvb21hbmRwYW4iOiJ6b29tQW5kUGFuIn19Jyl9LGZ1bmN0aW9uKEwsZSl7dmFyIHQ9ZS5nZXRDaGlsZHJlbj1mdW5jdGlvbihsKXtyZXR1cm4gbC5jaGlsZHJlbn0sYT1lLmdldFBhcmVudD1mdW5jdGlvbihsKXtyZXR1cm4gbC5wYXJlbnR9O2UuZ2V0U2libGluZ3M9ZnVuY3Rpb24obCl7dmFyIE09YShsKTtyZXR1cm4gTT90KE0pOltsXX0sZS5nZXRBdHRyaWJ1dGVWYWx1ZT1mdW5jdGlvbihsLE0pe3JldHVybiBsLmF0dHJpYnMmJmwuYXR0cmlic1tNXX0sZS5oYXNBdHRyaWI9ZnVuY3Rpb24obCxNKXtyZXR1cm4hIWwuYXR0cmlicyYmaGFzT3duUHJvcGVydHkuY2FsbChsLmF0dHJpYnMsTSl9LGUuZ2V0TmFtZT1mdW5jdGlvbihsKXtyZXR1cm4gbC5uYW1lfX0sZnVuY3Rpb24oTCxlKXtlLnJlbW92ZUVsZW1lbnQ9ZnVuY3Rpb24odCl7aWYodC5wcmV2JiYodC5wcmV2Lm5leHQ9dC5uZXh0KSx0Lm5leHQmJih0Lm5leHQucHJldj10LnByZXYpLHQucGFyZW50KXt2YXIgYT10LnBhcmVudC5jaGlsZHJlbjthLnNwbGljZShhLmxhc3RJbmRleE9mKHQpLDEpfX0sZS5yZXBsYWNlRWxlbWVudD1mdW5jdGlvbih0LGEpe3ZhciBsPWEucHJldj10LnByZXY7bCYmKGwubmV4dD1hKTt2YXIgTT1hLm5leHQ9dC5uZXh0O00mJihNLnByZXY9YSk7dmFyIFQ9YS5wYXJlbnQ9dC5wYXJlbnQ7aWYoVCl7dmFyIGQ9VC5jaGlsZHJlbjtkW2QubGFzdEluZGV4T2YodCldPWF9fSxlLmFwcGVuZENoaWxkPWZ1bmN0aW9uKHQsYSl7aWYoYS5wYXJlbnQ9dCx0LmNoaWxkcmVuLnB1c2goYSkhPT0xKXt2YXIgbD10LmNoaWxkcmVuW3QuY2hpbGRyZW4ubGVuZ3RoLTJdO2wubmV4dD1hLGEucHJldj1sLGEubmV4dD1udWxsfX0sZS5hcHBlbmQ9ZnVuY3Rpb24odCxhKXt2YXIgbD10LnBhcmVudCxNPXQubmV4dDtpZihhLm5leHQ9TSxhLnByZXY9dCx0Lm5leHQ9YSxhLnBhcmVudD1sLE0pe2lmKE0ucHJldj1hLGwpe3ZhciBUPWwuY2hpbGRyZW47VC5zcGxpY2UoVC5sYXN0SW5kZXhPZihNKSwwLGEpfX1lbHNlIGwmJmwuY2hpbGRyZW4ucHVzaChhKX0sZS5wcmVwZW5kPWZ1bmN0aW9uKHQsYSl7dmFyIGw9dC5wYXJlbnQ7aWYobCl7dmFyIE09bC5jaGlsZHJlbjtNLnNwbGljZShNLmxhc3RJbmRleE9mKHQpLDAsYSl9dC5wcmV2JiYodC5wcmV2Lm5leHQ9YSksYS5wYXJlbnQ9bCxhLnByZXY9dC5wcmV2LGEubmV4dD10LHQucHJldj1hfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMjU2KS5pc1RhZztMLmV4cG9ydHM9e2ZpbHRlcjpsLGZpbmQ6TSxmaW5kT25lQ2hpbGQ6VCxmaW5kT25lOmQsZXhpc3RzT25lOnUsZmluZEFsbDpjfTtmdW5jdGlvbiBsKE8sZixnLHYpe3JldHVybiBBcnJheS5pc0FycmF5KGYpfHwoZj1bZl0pLCh0eXBlb2YgdiE9Im51bWJlciJ8fCFpc0Zpbml0ZSh2KSkmJih2PTEvMCksTShPLGYsZyE9PSExLHYpfWZ1bmN0aW9uIE0oTyxmLGcsdil7Zm9yKHZhciBDPVtdLHAsaD0wLG09Zi5sZW5ndGg7aDxtJiYhKE8oZltoXSkmJihDLnB1c2goZltoXSksLS12PD0wKXx8KHA9ZltoXS5jaGlsZHJlbixnJiZwJiZwLmxlbmd0aD4wJiYocD1NKE8scCxnLHYpLEM9Qy5jb25jYXQocCksdi09cC5sZW5ndGgsdjw9MCkpKTtoKyspO3JldHVybiBDfWZ1bmN0aW9uIFQoTyxmKXtmb3IodmFyIGc9MCx2PWYubGVuZ3RoO2c8djtnKyspaWYoTyhmW2ddKSlyZXR1cm4gZltnXTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBkKE8sZil7Zm9yKHZhciBnPW51bGwsdj0wLEM9Zi5sZW5ndGg7djxDJiYhZzt2KyspaWYoYShmW3ZdKSlPKGZbdl0pP2c9Zlt2XTpmW3ZdLmNoaWxkcmVuLmxlbmd0aD4wJiYoZz1kKE8sZlt2XS5jaGlsZHJlbikpO2Vsc2UgY29udGludWU7cmV0dXJuIGd9ZnVuY3Rpb24gdShPLGYpe2Zvcih2YXIgZz0wLHY9Zi5sZW5ndGg7Zzx2O2crKylpZihhKGZbZ10pJiYoTyhmW2ddKXx8ZltnXS5jaGlsZHJlbi5sZW5ndGg+MCYmdShPLGZbZ10uY2hpbGRyZW4pKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBjKE8sZil7Zm9yKHZhciBnPVtdLHY9Zi5zbGljZSgpO3YubGVuZ3RoOyl7dmFyIEM9di5zaGlmdCgpO2EoQykmJihDLmNoaWxkcmVuJiZDLmNoaWxkcmVuLmxlbmd0aD4wJiZ2LnVuc2hpZnQuYXBwbHkodixDLmNoaWxkcmVuKSxPKEMpJiZnLnB1c2goQykpfXJldHVybiBnfX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMjU2KSxsPWUuaXNUYWc9YS5pc1RhZztlLnRlc3RFbGVtZW50PWZ1bmN0aW9uKHUsYyl7Zm9yKHZhciBPIGluIHUpaWYodS5oYXNPd25Qcm9wZXJ0eShPKSl7aWYoTz09PSJ0YWdfbmFtZSIpe2lmKCFsKGMpfHwhdS50YWdfbmFtZShjLm5hbWUpKXJldHVybiExfWVsc2UgaWYoTz09PSJ0YWdfdHlwZSIpe2lmKCF1LnRhZ190eXBlKGMudHlwZSkpcmV0dXJuITF9ZWxzZSBpZihPPT09InRhZ19jb250YWlucyIpe2lmKGwoYyl8fCF1LnRhZ19jb250YWlucyhjLmRhdGEpKXJldHVybiExfWVsc2UgaWYoIWMuYXR0cmlic3x8IXVbT10oYy5hdHRyaWJzW09dKSlyZXR1cm4hMX1yZXR1cm4hMH07dmFyIE09e3RhZ19uYW1lOmZ1bmN0aW9uKHUpe3JldHVybiB0eXBlb2YgdT09ImZ1bmN0aW9uIj9mdW5jdGlvbihjKXtyZXR1cm4gbChjKSYmdShjLm5hbWUpfTp1PT09IioiP2w6ZnVuY3Rpb24oYyl7cmV0dXJuIGwoYykmJmMubmFtZT09PXV9fSx0YWdfdHlwZTpmdW5jdGlvbih1KXtyZXR1cm4gdHlwZW9mIHU9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oYyl7cmV0dXJuIHUoYy50eXBlKX06ZnVuY3Rpb24oYyl7cmV0dXJuIGMudHlwZT09PXV9fSx0YWdfY29udGFpbnM6ZnVuY3Rpb24odSl7cmV0dXJuIHR5cGVvZiB1PT0iZnVuY3Rpb24iP2Z1bmN0aW9uKGMpe3JldHVybiFsKGMpJiZ1KGMuZGF0YSl9OmZ1bmN0aW9uKGMpe3JldHVybiFsKGMpJiZjLmRhdGE9PT11fX19O2Z1bmN0aW9uIFQodSxjKXtyZXR1cm4gdHlwZW9mIGM9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oTyl7cmV0dXJuIE8uYXR0cmlicyYmYyhPLmF0dHJpYnNbdV0pfTpmdW5jdGlvbihPKXtyZXR1cm4gTy5hdHRyaWJzJiZPLmF0dHJpYnNbdV09PT1jfX1mdW5jdGlvbiBkKHUsYyl7cmV0dXJuIGZ1bmN0aW9uKE8pe3JldHVybiB1KE8pfHxjKE8pfX1lLmdldEVsZW1lbnRzPWZ1bmN0aW9uKHUsYyxPLGYpe3ZhciBnPU9iamVjdC5rZXlzKHUpLm1hcChmdW5jdGlvbih2KXt2YXIgQz11W3ZdO3JldHVybiB2IGluIE0/TVt2XShDKTpUKHYsQyl9KTtyZXR1cm4gZy5sZW5ndGg9PT0wP1tdOnRoaXMuZmlsdGVyKGcucmVkdWNlKGQpLGMsTyxmKX0sZS5nZXRFbGVtZW50QnlJZD1mdW5jdGlvbih1LGMsTyl7cmV0dXJuIEFycmF5LmlzQXJyYXkoYyl8fChjPVtjXSksdGhpcy5maW5kT25lKFQoImlkIix1KSxjLE8hPT0hMSl9LGUuZ2V0RWxlbWVudHNCeVRhZ05hbWU9ZnVuY3Rpb24odSxjLE8sZil7cmV0dXJuIHRoaXMuZmlsdGVyKE0udGFnX25hbWUodSksYyxPLGYpfSxlLmdldEVsZW1lbnRzQnlUYWdUeXBlPWZ1bmN0aW9uKHUsYyxPLGYpe3JldHVybiB0aGlzLmZpbHRlcihNLnRhZ190eXBlKHUpLGMsTyxmKX19LGZ1bmN0aW9uKEwsZSl7ZS5yZW1vdmVTdWJzZXRzPWZ1bmN0aW9uKGwpe2Zvcih2YXIgTT1sLmxlbmd0aCxULGQsdTstLU0+LTE7KXtmb3IoVD1kPWxbTV0sbFtNXT1udWxsLHU9ITA7ZDspe2lmKGwuaW5kZXhPZihkKT4tMSl7dT0hMSxsLnNwbGljZShNLDEpO2JyZWFrfWQ9ZC5wYXJlbnR9dSYmKGxbTV09VCl9cmV0dXJuIGx9O3ZhciB0PXtESVNDT05ORUNURUQ6MSxQUkVDRURJTkc6MixGT0xMT1dJTkc6NCxDT05UQUlOUzo4LENPTlRBSU5FRF9CWToxNn0sYT1lLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uPWZ1bmN0aW9uKGwsTSl7dmFyIFQ9W10sZD1bXSx1LGMsTyxmLGcsdjtpZihsPT09TSlyZXR1cm4gMDtmb3IodT1sO3U7KVQudW5zaGlmdCh1KSx1PXUucGFyZW50O2Zvcih1PU07dTspZC51bnNoaWZ0KHUpLHU9dS5wYXJlbnQ7Zm9yKHY9MDtUW3ZdPT09ZFt2XTspdisrO3JldHVybiB2PT09MD90LkRJU0NPTk5FQ1RFRDooYz1UW3YtMV0sTz1jLmNoaWxkcmVuLGY9VFt2XSxnPWRbdl0sTy5pbmRleE9mKGYpPk8uaW5kZXhPZihnKT9jPT09TT90LkZPTExPV0lOR3x0LkNPTlRBSU5FRF9CWTp0LkZPTExPV0lORzpjPT09bD90LlBSRUNFRElOR3x0LkNPTlRBSU5TOnQuUFJFQ0VESU5HKX07ZS51bmlxdWVTb3J0PWZ1bmN0aW9uKGwpe3ZhciBNPWwubGVuZ3RoLFQsZDtmb3IobD1sLnNsaWNlKCk7LS1NPi0xOylUPWxbTV0sZD1sLmluZGV4T2YoVCksZD4tMSYmZDxNJiZsLnNwbGljZShNLDEpO3JldHVybiBsLnNvcnQoZnVuY3Rpb24odSxjKXt2YXIgTz1hKHUsYyk7cmV0dXJuIE8mdC5QUkVDRURJTkc/LTE6TyZ0LkZPTExPV0lORz8xOjB9KSxsfX0sZnVuY3Rpb24oTCxlKXtMLmV4cG9ydHM9e3RydWVGdW5jOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGZhbHNlRnVuYzpmdW5jdGlvbigpe3JldHVybiExfX19LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9Zzt2YXIgYT10KDI3NSkucGFyc2UsbD10KDI3MyksTT10KDI3OCksVD10KDI3OSksZD10KDI4MCksdT10KDI4MiksYz1sLnRydWVGdW5jLE89bC5mYWxzZUZ1bmMsZj11LmZpbHRlcnM7ZnVuY3Rpb24gZyhFLEQsSSl7dmFyIFM9QyhFLEQsSSk7cmV0dXJuIHYoUyxEKX1mdW5jdGlvbiB2KEUsRCl7dmFyIEk9RC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihBKXtyZXR1cm4gSS5pc1RhZyhBKSYmRShBKX19ZnVuY3Rpb24gQyhFLEQsSSl7dmFyIFM9YShFLEQpO3JldHVybiBzKFMsRCxJKX1mdW5jdGlvbiBwKEUpe3JldHVybiBFLnR5cGU9PT0icHNldWRvIiYmKEUubmFtZT09PSJzY29wZSJ8fEFycmF5LmlzQXJyYXkoRS5kYXRhKSYmRS5kYXRhLnNvbWUoZnVuY3Rpb24oRCl7cmV0dXJuIEQuc29tZShwKX0pKX12YXIgaD17dHlwZToiZGVzY2VuZGFudCJ9LG09e3R5cGU6Il9mbGV4aWJsZURlc2NlbmRhbnQifSxyPXt0eXBlOiJwc2V1ZG8iLG5hbWU6InNjb3BlIn0saT17fTtmdW5jdGlvbiBuKEUsRCxJKXt2YXIgUz1ELmFkYXB0ZXIsQT0hIUkmJiEhSS5sZW5ndGgmJkkuZXZlcnkoZnVuY3Rpb24oVSl7cmV0dXJuIFU9PT1pfHwhIVMuZ2V0UGFyZW50KFUpfSk7RS5mb3JFYWNoKGZ1bmN0aW9uKFUpe2lmKCEoVS5sZW5ndGg+MCYmeChVWzBdKSYmVVswXS50eXBlIT09ImRlc2NlbmRhbnQiKSlpZihBJiYhKEFycmF5LmlzQXJyYXkoVSk/VS5zb21lKHApOnAoVSkpKVUudW5zaGlmdChoKTtlbHNlIHJldHVybjtVLnVuc2hpZnQocil9KX1mdW5jdGlvbiBzKEUsRCxJKXtFPUUuZmlsdGVyKGZ1bmN0aW9uKEspe3JldHVybiBLLmxlbmd0aD4wfSksRS5mb3JFYWNoKE0pO3ZhciBTPUFycmF5LmlzQXJyYXkoSSk7ST1EJiZELmNvbnRleHR8fEksSSYmIVMmJihJPVtJXSksbihFLEQsSSk7dmFyIEE9ITEsVT1FLm1hcChmdW5jdGlvbihLKXtpZihLWzBdJiZLWzFdJiZLWzBdLm5hbWU9PT0ic2NvcGUiKXt2YXIgVj1LWzFdLnR5cGU7UyYmVj09PSJkZXNjZW5kYW50Ij9LWzFdPW06KFY9PT0iYWRqYWNlbnQifHxWPT09InNpYmxpbmciKSYmKEE9ITApfXJldHVybiBQKEssRCxJKX0pLnJlZHVjZShSLE8pO3JldHVybiBVLnNob3VsZFRlc3ROZXh0U2libGluZ3M9QSxVfWZ1bmN0aW9uIHgoRSl7cmV0dXJuIFRbRS50eXBlXTwwfWZ1bmN0aW9uIFAoRSxELEkpe3JldHVybiBFLnJlZHVjZShmdW5jdGlvbihTLEEpe2lmKFM9PT1PKXJldHVybiBTO2lmKCEoQS50eXBlIGluIGQpKXRocm93IG5ldyBFcnJvcigiUnVsZSB0eXBlICIrQS50eXBlKyIgaXMgbm90IHN1cHBvcnRlZCBieSBjc3Mtc2VsZWN0Iik7cmV0dXJuIGRbQS50eXBlXShTLEEsRCxJKX0sRCYmRC5yb290RnVuY3x8Yyl9ZnVuY3Rpb24gUihFLEQpe3JldHVybiBEPT09T3x8RT09PWM/RTpFPT09T3x8RD09PWM/RDpmdW5jdGlvbihTKXtyZXR1cm4gRShTKXx8RChTKX19ZnVuY3Rpb24gYihFKXtyZXR1cm4gRS5zb21lKHgpfWYubm90PWZ1bmN0aW9uKEUsRCxJLFMpe3ZhciBBPXt4bWxNb2RlOiEhKEkmJkkueG1sTW9kZSksc3RyaWN0OiEhKEkmJkkuc3RyaWN0KSxhZGFwdGVyOkkuYWRhcHRlcn07aWYoQS5zdHJpY3QmJihELmxlbmd0aD4xfHxELnNvbWUoYikpKXRocm93IG5ldyBFcnJvcigiY29tcGxleCBzZWxlY3RvcnMgaW4gOm5vdCBhcmVuJ3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZSIpO3ZhciBVPXMoRCxBLFMpO3JldHVybiBVPT09Tz9FOlU9PT1jP086ZnVuY3Rpb24oVil7cmV0dXJuIVUoVikmJkUoVil9fSxmLmhhcz1mdW5jdGlvbihFLEQsSSl7dmFyIFM9SS5hZGFwdGVyLEE9e3htbE1vZGU6ISEoSSYmSS54bWxNb2RlKSxzdHJpY3Q6ISEoSSYmSS5zdHJpY3QpLGFkYXB0ZXI6U30sVT1ELnNvbWUoYik/W2ldOm51bGwsSz1zKEQsQSxVKTtyZXR1cm4gSz09PU8/TzpLPT09Yz9mdW5jdGlvbihKKXtyZXR1cm4gUy5nZXRDaGlsZHJlbihKKS5zb21lKFMuaXNUYWcpJiZFKEopfTooSz12KEssSSksVT9mdW5jdGlvbihKKXtyZXR1cm4gRShKKSYmKFVbMF09SixTLmV4aXN0c09uZShLLFMuZ2V0Q2hpbGRyZW4oSikpKX06ZnVuY3Rpb24oSil7cmV0dXJuIEUoSikmJlMuZXhpc3RzT25lKEssUy5nZXRDaGlsZHJlbihKKSl9KX0sZi5tYXRjaGVzPWZ1bmN0aW9uKEUsRCxJLFMpe3ZhciBBPXt4bWxNb2RlOiEhKEkmJkkueG1sTW9kZSksc3RyaWN0OiEhKEkmJkkuc3RyaWN0KSxyb290RnVuYzpFLGFkYXB0ZXI6SS5hZGFwdGVyfTtyZXR1cm4gcyhELEEsUyl9LGcuY29tcGlsZVRva2VuPXMsZy5jb21waWxlVW5zYWZlPUMsZy5Qc2V1ZG9zPXV9LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZCx1LGMsTyl7Tz09PXZvaWQgMCYmKE89YyksT2JqZWN0LmRlZmluZVByb3BlcnR5KGQsTyx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdVtjXX19KX06ZnVuY3Rpb24oZCx1LGMsTyl7Tz09PXZvaWQgMCYmKE89YyksZFtPXT11W2NdfSksbD10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZCx1KXtmb3IodmFyIGMgaW4gZCljIT09ImRlZmF1bHQiJiYhdS5oYXNPd25Qcm9wZXJ0eShjKSYmYSh1LGQsYyl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxsKHQoMjc2KSxlKTt2YXIgTT10KDI3Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInBhcnNlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTS5kZWZhdWx0fX0pO3ZhciBUPXQoMjc3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwic3RyaW5naWZ5Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gVC5kZWZhdWx0fX0pfSxmdW5jdGlvbihMLGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD1wO3ZhciBhPS9eW15cXF0/KD86XFwoPzpbXGRhLWZdezEsNn1ccz98Lil8W1x3XC1cdTAwYjAtXHVGRkZGXSkrLyxsPS9cXChbXGRhLWZdezEsNn1ccz98KFxzKXwuKS9naSxNPS9eXHMqKCg/OlxcLnxbXHdcdTAwYjAtXHVGRkZGLV0pKylccyooPzooXFM/KT1ccyooPzooWyciXSkoW15dKj8pXDN8KCM/KD86XFwufFtcd1x1MDBiMC1cdUZGRkYtXSkqKXwpfClccyooaSk/XF0vLFQ9e3VuZGVmaW5lZDoiZXhpc3RzIiwiIjoiZXF1YWxzIiwifiI6ImVsZW1lbnQiLCJeIjoic3RhcnQiLCQ6ImVuZCIsIioiOiJhbnkiLCIhIjoibm90IiwifCI6Imh5cGhlbiJ9LGQ9eyI+IjoiY2hpbGQiLCI8IjoicGFyZW50IiwifiI6InNpYmxpbmciLCIrIjoiYWRqYWNlbnQifSx1PXsiIyI6WyJpZCIsImVxdWFscyJdLCIuIjpbImNsYXNzIiwiZWxlbWVudCJdfSxjPW5ldyBTZXQoWyJoYXMiLCJub3QiLCJtYXRjaGVzIl0pLE89bmV3IFNldChbImNvbnRhaW5zIiwiaWNvbnRhaW5zIl0pLGY9bmV3IFNldChbJyInLCInIl0pO2Z1bmN0aW9uIGcocixpLG4pe3ZhciBzPXBhcnNlSW50KGksMTYpLTY1NTM2O3JldHVybiBzIT09c3x8bj9pOnM8MD9TdHJpbmcuZnJvbUNoYXJDb2RlKHMrNjU1MzYpOlN0cmluZy5mcm9tQ2hhckNvZGUocz4+MTB8NTUyOTYscyYxMDIzfDU2MzIwKX1mdW5jdGlvbiB2KHIpe3JldHVybiByLnJlcGxhY2UobCxnKX1mdW5jdGlvbiBDKHIpe3JldHVybiByPT09IiAifHxyPT09YApgfHxyPT09IgkifHxyPT09IlxmInx8cj09PSJcciJ9ZnVuY3Rpb24gcChyLGkpe3ZhciBuPVtdO2lmKHI9aChuLCIiK3IsaSksciE9PSIiKXRocm93IG5ldyBFcnJvcigiVW5tYXRjaGVkIHNlbGVjdG9yOiAiK3IpO3JldHVybiBufWZ1bmN0aW9uIGgocixpLG4pe3ZhciBzPVtdLHg9ITE7ZnVuY3Rpb24gUCgpe3ZhciBaPWkubWF0Y2goYSk7aWYoIVopdGhyb3cgbmV3IEVycm9yKCJFeHBlY3RlZCBuYW1lLCBmb3VuZCAiK2kpO3ZhciB0dD1aWzBdO3JldHVybiBpPWkuc3Vic3RyKHR0Lmxlbmd0aCksdih0dCl9ZnVuY3Rpb24gUihaKXtmb3IoO0MoaS5jaGFyQXQoWikpOylaKys7aT1pLnN1YnN0cihaKX1mdW5jdGlvbiBiKFope2Zvcih2YXIgdHQ9MDtpLmNoYXJBdCgtLVopPT09IlxcIjspdHQrKztyZXR1cm4odHQmMSk9PT0xfWZvcihSKDApO2khPT0iIjspe3ZhciBFPWkuY2hhckF0KDApO2lmKEMoRSkpeD0hMCxSKDEpO2Vsc2UgaWYoRSBpbiBkKXMucHVzaCh7dHlwZTpkW0VdfSkseD0hMSxSKDEpO2Vsc2UgaWYoRT09PSIsIil7aWYocy5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcigiRW1wdHkgc3ViLXNlbGVjdG9yIik7ci5wdXNoKHMpLHM9W10seD0hMSxSKDEpfWVsc2UgaWYoeCYmKHMubGVuZ3RoPjAmJnMucHVzaCh7dHlwZToiZGVzY2VuZGFudCJ9KSx4PSExKSxFPT09IioiKWk9aS5zdWJzdHIoMSkscy5wdXNoKHt0eXBlOiJ1bml2ZXJzYWwifSk7ZWxzZSBpZihFIGluIHUpe3ZhciBEPXVbRV0sST1EWzBdLFM9RFsxXTtpPWkuc3Vic3RyKDEpLHMucHVzaCh7dHlwZToiYXR0cmlidXRlIixuYW1lOkksYWN0aW9uOlMsdmFsdWU6UCgpLGlnbm9yZUNhc2U6ITF9KX1lbHNlIGlmKEU9PT0iWyIpe2k9aS5zdWJzdHIoMSk7dmFyIEE9aS5tYXRjaChNKTtpZighQSl0aHJvdyBuZXcgRXJyb3IoIk1hbGZvcm1lZCBhdHRyaWJ1dGUgc2VsZWN0b3I6ICIraSk7aT1pLnN1YnN0cihBWzBdLmxlbmd0aCk7dmFyIFU9dihBWzFdKTsoIW58fCgibG93ZXJDYXNlQXR0cmlidXRlTmFtZXMiaW4gbj9uLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiFuLnhtbE1vZGUpKSYmKFU9VS50b0xvd2VyQ2FzZSgpKSxzLnB1c2goe3R5cGU6ImF0dHJpYnV0ZSIsbmFtZTpVLGFjdGlvbjpUW0FbMl1dLHZhbHVlOnYoQVs0XXx8QVs1XXx8IiIpLGlnbm9yZUNhc2U6ISFBWzZdfSl9ZWxzZSBpZihFPT09IjoiKXtpZihpLmNoYXJBdCgxKT09PSI6Iil7aT1pLnN1YnN0cigyKSxzLnB1c2goe3R5cGU6InBzZXVkby1lbGVtZW50IixuYW1lOlAoKS50b0xvd2VyQ2FzZSgpfSk7Y29udGludWV9aT1pLnN1YnN0cigxKTt2YXIgSz1QKCkudG9Mb3dlckNhc2UoKSxBPW51bGw7aWYoaS5jaGFyQXQoMCk9PT0iKCIpaWYoYy5oYXMoSykpe3ZhciBWPWkuY2hhckF0KDEpLEo9Zi5oYXMoVik7aWYoaT1pLnN1YnN0cihKPzI6MSksQT1bXSxpPWgoQSxpLG4pLEope2lmKGkuY2hhckF0KDApIT09Vil0aHJvdyBuZXcgRXJyb3IoIlVubWF0Y2hlZCBxdW90ZXMgaW4gOiIrSyk7aT1pLnN1YnN0cigxKX1pZihpLmNoYXJBdCgwKSE9PSIpIil0aHJvdyBuZXcgRXJyb3IoIk1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcyBpbiA6IitLKyIgKCIraSsiKSIpO2k9aS5zdWJzdHIoMSl9ZWxzZXtmb3IodmFyIHE9MSxXPTE7Vz4wJiZxPGkubGVuZ3RoO3ErKylpLmNoYXJBdChxKT09PSIoIiYmIWIocSk/VysrOmkuY2hhckF0KHEpPT09IikiJiYhYihxKSYmVy0tO2lmKFcpdGhyb3cgbmV3IEVycm9yKCJQYXJlbnRoZXNpcyBub3QgbWF0Y2hlZCIpO2lmKEE9aS5zdWJzdHIoMSxxLTIpLGk9aS5zdWJzdHIocSksTy5oYXMoSykpe3ZhciBWPUEuY2hhckF0KDApO1Y9PT1BLnNsaWNlKC0xKSYmZi5oYXMoVikmJihBPUEuc2xpY2UoMSwtMSkpLEE9dihBKX19cy5wdXNoKHt0eXBlOiJwc2V1ZG8iLG5hbWU6SyxkYXRhOkF9KX1lbHNlIGlmKGEudGVzdChpKSl7dmFyIEg9UCgpOyghbnx8KCJsb3dlckNhc2VUYWdzImluIG4/bi5sb3dlckNhc2VUYWdzOiFuLnhtbE1vZGUpKSYmKEg9SC50b0xvd2VyQ2FzZSgpKSxzLnB1c2goe3R5cGU6InRhZyIsbmFtZTpIfSl9ZWxzZSByZXR1cm4gcy5sZW5ndGgmJnNbcy5sZW5ndGgtMV0udHlwZT09PSJkZXNjZW5kYW50IiYmcy5wb3AoKSxtKHIscyksaX1yZXR1cm4gbShyLHMpLGl9ZnVuY3Rpb24gbShyLGkpe2lmKHIubGVuZ3RoPjAmJmkubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoIkVtcHR5IHN1Yi1zZWxlY3RvciIpO3IucHVzaChpKX19LGZ1bmN0aW9uKEwsZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dmFyIGE9e2VxdWFsczoiIixlbGVtZW50OiJ+IixzdGFydDoiXiIsZW5kOiIkIixhbnk6IioiLG5vdDoiISIsaHlwaGVuOiJ8In07ZnVuY3Rpb24gbCh1KXtyZXR1cm4gdS5tYXAoTSkuam9pbigiLCAiKX1lLmRlZmF1bHQ9bDtmdW5jdGlvbiBNKHUpe3JldHVybiB1Lm1hcChUKS5qb2luKCIiKX1mdW5jdGlvbiBUKHUpe3N3aXRjaCh1LnR5cGUpe2Nhc2UiY2hpbGQiOnJldHVybiIgPiAiO2Nhc2UicGFyZW50IjpyZXR1cm4iIDwgIjtjYXNlInNpYmxpbmciOnJldHVybiIgfiAiO2Nhc2UiYWRqYWNlbnQiOnJldHVybiIgKyAiO2Nhc2UiZGVzY2VuZGFudCI6cmV0dXJuIiAiO2Nhc2UidW5pdmVyc2FsIjpyZXR1cm4iKiI7Y2FzZSJ0YWciOnJldHVybiB1Lm5hbWU7Y2FzZSJwc2V1ZG8tZWxlbWVudCI6cmV0dXJuIjo6Iit1Lm5hbWU7Y2FzZSJwc2V1ZG8iOnJldHVybiB1LmRhdGE9PT1udWxsPyI6Iit1Lm5hbWU6dHlwZW9mIHUuZGF0YT09InN0cmluZyI/IjoiK3UubmFtZSsiKCIrdS5kYXRhKyIpIjoiOiIrdS5uYW1lKyIoIitsKHUuZGF0YSkrIikiO2Nhc2UiYXR0cmlidXRlIjpyZXR1cm4gdS5hY3Rpb249PT0iZXhpc3RzIj8iWyIrdS5uYW1lKyJdIjp1Lm5hbWU9PT0iaWQiJiZ1LmFjdGlvbj09PSJlcXVhbHMiJiYhdS5pZ25vcmVDYXNlPyIjIit1LnZhbHVlOnUubmFtZT09PSJjbGFzcyImJnUuYWN0aW9uPT09ImVsZW1lbnQiJiYhdS5pZ25vcmVDYXNlPyIuIit1LnZhbHVlOiJbIit1Lm5hbWUrYVt1LmFjdGlvbl0rIj0nIit1LnZhbHVlKyInIisodS5pZ25vcmVDYXNlPyJpIjoiIikrIl0iO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIHR5cGUiKX19ZnVuY3Rpb24gZCh1KXtyZXR1cm4gdX19LGZ1bmN0aW9uKEwsZSx0KXtMLmV4cG9ydHM9TTt2YXIgYT10KDI3OSksbD17X19wcm90b19fOm51bGwsZXhpc3RzOjEwLGVxdWFsczo4LG5vdDo3LHN0YXJ0OjYsZW5kOjYsYW55OjUsaHlwaGVuOjQsZWxlbWVudDo0fTtmdW5jdGlvbiBNKGQpe2Zvcih2YXIgdT1kLm1hcChUKSxjPTE7YzxkLmxlbmd0aDtjKyspe3ZhciBPPXVbY107aWYoIShPPDApKWZvcih2YXIgZj1jLTE7Zj49MCYmTzx1W2ZdO2YtLSl7dmFyIGc9ZFtmKzFdO2RbZisxXT1kW2ZdLGRbZl09Zyx1W2YrMV09dVtmXSx1W2ZdPU99fX1mdW5jdGlvbiBUKGQpe3ZhciB1PWFbZC50eXBlXTtpZih1PT09YS5hdHRyaWJ1dGUpdT1sW2QuYWN0aW9uXSx1PT09bC5lcXVhbHMmJmQubmFtZT09PSJpZCImJih1PTkpLGQuaWdub3JlQ2FzZSYmKHU+Pj0xKTtlbHNlIGlmKHU9PT1hLnBzZXVkbylpZighZC5kYXRhKXU9MztlbHNlIGlmKGQubmFtZT09PSJoYXMifHxkLm5hbWU9PT0iY29udGFpbnMiKXU9MDtlbHNlIGlmKGQubmFtZT09PSJtYXRjaGVzInx8ZC5uYW1lPT09Im5vdCIpe3U9MDtmb3IodmFyIGM9MDtjPGQuZGF0YS5sZW5ndGg7YysrKWlmKGQuZGF0YVtjXS5sZW5ndGg9PT0xKXt2YXIgTz1UKGQuZGF0YVtjXVswXSk7aWYoTz09PTApe3U9MDticmVha31PPnUmJih1PU8pfWQuZGF0YS5sZW5ndGg+MSYmdT4wJiYodS09MSl9ZWxzZSB1PTE7cmV0dXJuIHV9fSxmdW5jdGlvbihMKXtMLmV4cG9ydHM9SlNPTi5wYXJzZSgneyJ1bml2ZXJzYWwiOjUwLCJ0YWciOjMwLCJhdHRyaWJ1dGUiOjEsInBzZXVkbyI6MCwiZGVzY2VuZGFudCI6LTEsImNoaWxkIjotMSwicGFyZW50IjotMSwic2libGluZyI6LTEsImFkamFjZW50IjotMX0nKX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMjgxKSxsPXQoMjgyKTtMLmV4cG9ydHM9e19fcHJvdG9fXzpudWxsLGF0dHJpYnV0ZTphLmNvbXBpbGUscHNldWRvOmwuY29tcGlsZSx0YWc6ZnVuY3Rpb24oTSxULGQpe3ZhciB1PVQubmFtZSxjPWQuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIGMuZ2V0TmFtZShmKT09PXUmJk0oZil9fSxkZXNjZW5kYW50OmZ1bmN0aW9uKE0sVCxkKXt2YXIgdT10eXBlb2YgV2Vha1NldDwidSI/bmV3IFdlYWtTZXQ6bnVsbCxjPWQuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oZil7Zm9yKHZhciBnPSExOyFnJiYoZj1jLmdldFBhcmVudChmKSk7KSghdXx8IXUuaGFzKGYpKSYmKGc9TShmKSwhZyYmdSYmdS5hZGQoZikpO3JldHVybiBnfX0sX2ZsZXhpYmxlRGVzY2VuZGFudDpmdW5jdGlvbihNLFQsZCl7dmFyIHU9ZC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihPKXtmb3IodmFyIGY9TShPKTshZiYmKE89dS5nZXRQYXJlbnQoTykpOylmPU0oTyk7cmV0dXJuIGZ9fSxwYXJlbnQ6ZnVuY3Rpb24oTSxULGQpe2lmKGQmJmQuc3RyaWN0KXRocm93IG5ldyBFcnJvcigiUGFyZW50IHNlbGVjdG9yIGlzbid0IHBhcnQgb2YgQ1NTMyIpO3ZhciB1PWQuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIHUuZ2V0Q2hpbGRyZW4oZikuc29tZShjKX07ZnVuY3Rpb24gYyhPKXtyZXR1cm4gdS5pc1RhZyhPKSYmTShPKX19LGNoaWxkOmZ1bmN0aW9uKE0sVCxkKXt2YXIgdT1kLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKE8pe3ZhciBmPXUuZ2V0UGFyZW50KE8pO3JldHVybiEhZiYmTShmKX19LHNpYmxpbmc6ZnVuY3Rpb24oTSxULGQpe3ZhciB1PWQuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24oTyl7Zm9yKHZhciBmPXUuZ2V0U2libGluZ3MoTyksZz0wO2c8Zi5sZW5ndGg7ZysrKWlmKHUuaXNUYWcoZltnXSkpe2lmKGZbZ109PT1PKWJyZWFrO2lmKE0oZltnXSkpcmV0dXJuITB9cmV0dXJuITF9fSxhZGphY2VudDpmdW5jdGlvbihNLFQsZCl7dmFyIHU9ZC5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihPKXtmb3IodmFyIGY9dS5nZXRTaWJsaW5ncyhPKSxnLHY9MDt2PGYubGVuZ3RoO3YrKylpZih1LmlzVGFnKGZbdl0pKXtpZihmW3ZdPT09TylicmVhaztnPWZbdl19cmV0dXJuISFnJiZNKGcpfX0sdW5pdmVyc2FsOmZ1bmN0aW9uKE0pe3JldHVybiBNfX19LGZ1bmN0aW9uKEwsZSx0KXt2YXIgYT10KDI3MykuZmFsc2VGdW5jLGw9L1stW1xde30oKSorPy4sXFxeJHwjXHNdL2csTT17X19wcm90b19fOm51bGwsZXF1YWxzOmZ1bmN0aW9uKFQsZCx1KXt2YXIgYz1kLm5hbWUsTz1kLnZhbHVlLGY9dS5hZGFwdGVyO3JldHVybiBkLmlnbm9yZUNhc2U/KE89Ty50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKHYpe3ZhciBDPWYuZ2V0QXR0cmlidXRlVmFsdWUodixjKTtyZXR1cm4gQyE9bnVsbCYmQy50b0xvd2VyQ2FzZSgpPT09TyYmVCh2KX0pOmZ1bmN0aW9uKHYpe3JldHVybiBmLmdldEF0dHJpYnV0ZVZhbHVlKHYsYyk9PT1PJiZUKHYpfX0saHlwaGVuOmZ1bmN0aW9uKFQsZCx1KXt2YXIgYz1kLm5hbWUsTz1kLnZhbHVlLGY9Ty5sZW5ndGgsZz11LmFkYXB0ZXI7cmV0dXJuIGQuaWdub3JlQ2FzZT8oTz1PLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oQyl7dmFyIHA9Zy5nZXRBdHRyaWJ1dGVWYWx1ZShDLGMpO3JldHVybiBwIT1udWxsJiYocC5sZW5ndGg9PT1mfHxwLmNoYXJBdChmKT09PSItIikmJnAuc3Vic3RyKDAsZikudG9Mb3dlckNhc2UoKT09PU8mJlQoQyl9KTpmdW5jdGlvbihDKXt2YXIgcD1nLmdldEF0dHJpYnV0ZVZhbHVlKEMsYyk7cmV0dXJuIHAhPW51bGwmJnAuc3Vic3RyKDAsZik9PT1PJiYocC5sZW5ndGg9PT1mfHxwLmNoYXJBdChmKT09PSItIikmJlQoQyl9fSxlbGVtZW50OmZ1bmN0aW9uKFQsZCx1KXt2YXIgYz1kLm5hbWUsTz1kLnZhbHVlLGY9dS5hZGFwdGVyO2lmKC9ccy8udGVzdChPKSlyZXR1cm4gYTtPPU8ucmVwbGFjZShsLCJcXCQmIik7dmFyIGc9Iig/Ol58XFxzKSIrTysiKD86JHxcXHMpIix2PWQuaWdub3JlQ2FzZT8iaSI6IiIsQz1uZXcgUmVnRXhwKGcsdik7cmV0dXJuIGZ1bmN0aW9uKGgpe3ZhciBtPWYuZ2V0QXR0cmlidXRlVmFsdWUoaCxjKTtyZXR1cm4gbSE9bnVsbCYmQy50ZXN0KG0pJiZUKGgpfX0sZXhpc3RzOmZ1bmN0aW9uKFQsZCx1KXt2YXIgYz1kLm5hbWUsTz11LmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiBPLmhhc0F0dHJpYihnLGMpJiZUKGcpfX0sc3RhcnQ6ZnVuY3Rpb24oVCxkLHUpe3ZhciBjPWQubmFtZSxPPWQudmFsdWUsZj1PLmxlbmd0aCxnPXUuYWRhcHRlcjtyZXR1cm4gZj09PTA/YTpkLmlnbm9yZUNhc2U/KE89Ty50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKEMpe3ZhciBwPWcuZ2V0QXR0cmlidXRlVmFsdWUoQyxjKTtyZXR1cm4gcCE9bnVsbCYmcC5zdWJzdHIoMCxmKS50b0xvd2VyQ2FzZSgpPT09TyYmVChDKX0pOmZ1bmN0aW9uKEMpe3ZhciBwPWcuZ2V0QXR0cmlidXRlVmFsdWUoQyxjKTtyZXR1cm4gcCE9bnVsbCYmcC5zdWJzdHIoMCxmKT09PU8mJlQoQyl9fSxlbmQ6ZnVuY3Rpb24oVCxkLHUpe3ZhciBjPWQubmFtZSxPPWQudmFsdWUsZj0tTy5sZW5ndGgsZz11LmFkYXB0ZXI7cmV0dXJuIGY9PT0wP2E6ZC5pZ25vcmVDYXNlPyhPPU8udG9Mb3dlckNhc2UoKSxmdW5jdGlvbihDKXt2YXIgcD1nLmdldEF0dHJpYnV0ZVZhbHVlKEMsYyk7cmV0dXJuIHAhPW51bGwmJnAuc3Vic3RyKGYpLnRvTG93ZXJDYXNlKCk9PT1PJiZUKEMpfSk6ZnVuY3Rpb24oQyl7dmFyIHA9Zy5nZXRBdHRyaWJ1dGVWYWx1ZShDLGMpO3JldHVybiBwIT1udWxsJiZwLnN1YnN0cihmKT09PU8mJlQoQyl9fSxhbnk6ZnVuY3Rpb24oVCxkLHUpe3ZhciBjPWQubmFtZSxPPWQudmFsdWUsZj11LmFkYXB0ZXI7aWYoTz09PSIiKXJldHVybiBhO2lmKGQuaWdub3JlQ2FzZSl7dmFyIGc9bmV3IFJlZ0V4cChPLnJlcGxhY2UobCwiXFwkJiIpLCJpIik7cmV0dXJuIGZ1bmN0aW9uKEMpe3ZhciBwPWYuZ2V0QXR0cmlidXRlVmFsdWUoQyxjKTtyZXR1cm4gcCE9bnVsbCYmZy50ZXN0KHApJiZUKEMpfX1yZXR1cm4gZnVuY3Rpb24oQyl7dmFyIHA9Zi5nZXRBdHRyaWJ1dGVWYWx1ZShDLGMpO3JldHVybiBwIT1udWxsJiZwLmluZGV4T2YoTyk+PTAmJlQoQyl9fSxub3Q6ZnVuY3Rpb24oVCxkLHUpe3ZhciBjPWQubmFtZSxPPWQudmFsdWUsZj11LmFkYXB0ZXI7cmV0dXJuIE89PT0iIj9mdW5jdGlvbih2KXtyZXR1cm4hIWYuZ2V0QXR0cmlidXRlVmFsdWUodixjKSYmVCh2KX06ZC5pZ25vcmVDYXNlPyhPPU8udG9Mb3dlckNhc2UoKSxmdW5jdGlvbih2KXt2YXIgQz1mLmdldEF0dHJpYnV0ZVZhbHVlKHYsYyk7cmV0dXJuIEMhPW51bGwmJkMudG9Mb3dlckNhc2UoKSE9PU8mJlQodil9KTpmdW5jdGlvbih2KXtyZXR1cm4gZi5nZXRBdHRyaWJ1dGVWYWx1ZSh2LGMpIT09TyYmVCh2KX19fTtMLmV4cG9ydHM9e2NvbXBpbGU6ZnVuY3Rpb24oVCxkLHUpe2lmKHUmJnUuc3RyaWN0JiYoZC5pZ25vcmVDYXNlfHxkLmFjdGlvbj09PSJub3QiKSl0aHJvdyBuZXcgRXJyb3IoIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZSBzZWxlY3RvciIpO3JldHVybiBNW2QuYWN0aW9uXShULGQsdSl9LHJ1bGVzOk19fSxmdW5jdGlvbihMLGUsdCl7dmFyIGE9dCgyODMpLGw9dCgyNzMpLE09dCgyODEpLFQ9bC50cnVlRnVuYyxkPWwuZmFsc2VGdW5jLHU9TS5ydWxlcy5lcXVhbHM7ZnVuY3Rpb24gYyhtLHIpe3ZhciBpPXtuYW1lOm0sdmFsdWU6cn07cmV0dXJuIGZ1bmN0aW9uKHMseCxQKXtyZXR1cm4gdShzLGksUCl9fWZ1bmN0aW9uIE8obSxyKXtyZXR1cm4gZnVuY3Rpb24oaSl7cmV0dXJuISFyLmdldFBhcmVudChpKSYmbShpKX19dmFyIGY9e2NvbnRhaW5zOmZ1bmN0aW9uKG0scixpKXt2YXIgbj1pLmFkYXB0ZXI7cmV0dXJuIGZ1bmN0aW9uKHgpe3JldHVybiBtKHgpJiZuLmdldFRleHQoeCkuaW5kZXhPZihyKT49MH19LGljb250YWluczpmdW5jdGlvbihtLHIsaSl7dmFyIG49ci50b0xvd2VyQ2FzZSgpLHM9aS5hZGFwdGVyO3JldHVybiBmdW5jdGlvbihQKXtyZXR1cm4gbShQKSYmcy5nZXRUZXh0KFApLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihuKT49MH19LCJudGgtY2hpbGQiOmZ1bmN0aW9uKG0scixpKXt2YXIgbj1hKHIpLHM9aS5hZGFwdGVyO3JldHVybiBuPT09ZD9uOm49PT1UP08obSxzKTpmdW5jdGlvbihQKXtmb3IodmFyIFI9cy5nZXRTaWJsaW5ncyhQKSxiPTAsRT0wO2I8Ui5sZW5ndGg7YisrKWlmKHMuaXNUYWcoUltiXSkpe2lmKFJbYl09PT1QKWJyZWFrO0UrK31yZXR1cm4gbihFKSYmbShQKX19LCJudGgtbGFzdC1jaGlsZCI6ZnVuY3Rpb24obSxyLGkpe3ZhciBuPWEocikscz1pLmFkYXB0ZXI7cmV0dXJuIG49PT1kP246bj09PVQ/TyhtLHMpOmZ1bmN0aW9uKFApe2Zvcih2YXIgUj1zLmdldFNpYmxpbmdzKFApLGI9MCxFPVIubGVuZ3RoLTE7RT49MDtFLS0paWYocy5pc1RhZyhSW0VdKSl7aWYoUltFXT09PVApYnJlYWs7YisrfXJldHVybiBuKGIpJiZtKFApfX0sIm50aC1vZi10eXBlIjpmdW5jdGlvbihtLHIsaSl7dmFyIG49YShyKSxzPWkuYWRhcHRlcjtyZXR1cm4gbj09PWQ/bjpuPT09VD9PKG0scyk6ZnVuY3Rpb24oUCl7Zm9yKHZhciBSPXMuZ2V0U2libGluZ3MoUCksYj0wLEU9MDtFPFIubGVuZ3RoO0UrKylpZihzLmlzVGFnKFJbRV0pKXtpZihSW0VdPT09UClicmVhaztzLmdldE5hbWUoUltFXSk9PT1zLmdldE5hbWUoUCkmJmIrK31yZXR1cm4gbihiKSYmbShQKX19LCJudGgtbGFzdC1vZi10eXBlIjpmdW5jdGlvbihtLHIsaSl7dmFyIG49YShyKSxzPWkuYWRhcHRlcjtyZXR1cm4gbj09PWQ/bjpuPT09VD9PKG0scyk6ZnVuY3Rpb24oUCl7Zm9yKHZhciBSPXMuZ2V0U2libGluZ3MoUCksYj0wLEU9Ui5sZW5ndGgtMTtFPj0wO0UtLSlpZihzLmlzVGFnKFJbRV0pKXtpZihSW0VdPT09UClicmVhaztzLmdldE5hbWUoUltFXSk9PT1zLmdldE5hbWUoUCkmJmIrK31yZXR1cm4gbihiKSYmbShQKX19LHJvb3Q6ZnVuY3Rpb24obSxyLGkpe3ZhciBuPWkuYWRhcHRlcjtyZXR1cm4gZnVuY3Rpb24ocyl7cmV0dXJuIW4uZ2V0UGFyZW50KHMpJiZtKHMpfX0sc2NvcGU6ZnVuY3Rpb24obSxyLGksbil7dmFyIHM9aS5hZGFwdGVyO2lmKCFufHxuLmxlbmd0aD09PTApcmV0dXJuIGYucm9vdChtLHIsaSk7ZnVuY3Rpb24geChQLFIpe3JldHVybiB0eXBlb2Ygcy5lcXVhbHM9PSJmdW5jdGlvbiI/cy5lcXVhbHMoUCxSKTpQPT09Un1yZXR1cm4gbi5sZW5ndGg9PT0xP2Z1bmN0aW9uKFApe3JldHVybiB4KG5bMF0sUCkmJm0oUCl9OmZ1bmN0aW9uKFApe3JldHVybiBuLmluZGV4T2YoUCk+PTAmJm0oUCl9fSxjaGVja2JveDpjKCJ0eXBlIiwiY2hlY2tib3giKSxmaWxlOmMoInR5cGUiLCJmaWxlIikscGFzc3dvcmQ6YygidHlwZSIsInBhc3N3b3JkIikscmFkaW86YygidHlwZSIsInJhZGlvIikscmVzZXQ6YygidHlwZSIsInJlc2V0IiksaW1hZ2U6YygidHlwZSIsImltYWdlIiksc3VibWl0OmMoInR5cGUiLCJzdWJtaXQiKSxob3ZlcjpmdW5jdGlvbihtLHIsaSl7dmFyIG49aS5hZGFwdGVyO3JldHVybiB0eXBlb2Ygbi5pc0hvdmVyZWQ9PSJmdW5jdGlvbiI/ZnVuY3Rpb24oeCl7cmV0dXJuIG0oeCkmJm4uaXNIb3ZlcmVkKHgpfTpkfSx2aXNpdGVkOmZ1bmN0aW9uKG0scixpKXt2YXIgbj1pLmFkYXB0ZXI7cmV0dXJuIHR5cGVvZiBuLmlzVmlzaXRlZD09ImZ1bmN0aW9uIj9mdW5jdGlvbih4KXtyZXR1cm4gbSh4KSYmbi5pc1Zpc2l0ZWQoeCl9OmR9LGFjdGl2ZTpmdW5jdGlvbihtLHIsaSl7dmFyIG49aS5hZGFwdGVyO3JldHVybiB0eXBlb2Ygbi5pc0FjdGl2ZT09ImZ1bmN0aW9uIj9mdW5jdGlvbih4KXtyZXR1cm4gbSh4KSYmbi5pc0FjdGl2ZSh4KX06ZH19O2Z1bmN0aW9uIGcobSxyKXtmb3IodmFyIGk9MDttJiZpPG0ubGVuZ3RoO2krKylpZihyLmlzVGFnKG1baV0pKXJldHVybiBtW2ldfXZhciB2PXtlbXB0eTpmdW5jdGlvbihtLHIpe3JldHVybiFyLmdldENoaWxkcmVuKG0pLnNvbWUoZnVuY3Rpb24oaSl7cmV0dXJuIHIuaXNUYWcoaSl8fGkudHlwZT09PSJ0ZXh0In0pfSwiZmlyc3QtY2hpbGQiOmZ1bmN0aW9uKG0scil7cmV0dXJuIGcoci5nZXRTaWJsaW5ncyhtKSxyKT09PW19LCJsYXN0LWNoaWxkIjpmdW5jdGlvbihtLHIpe2Zvcih2YXIgaT1yLmdldFNpYmxpbmdzKG0pLG49aS5sZW5ndGgtMTtuPj0wO24tLSl7aWYoaVtuXT09PW0pcmV0dXJuITA7aWYoci5pc1RhZyhpW25dKSlicmVha31yZXR1cm4hMX0sImZpcnN0LW9mLXR5cGUiOmZ1bmN0aW9uKG0scil7Zm9yKHZhciBpPXIuZ2V0U2libGluZ3MobSksbj0wO248aS5sZW5ndGg7bisrKWlmKHIuaXNUYWcoaVtuXSkpe2lmKGlbbl09PT1tKXJldHVybiEwO2lmKHIuZ2V0TmFtZShpW25dKT09PXIuZ2V0TmFtZShtKSlicmVha31yZXR1cm4hMX0sImxhc3Qtb2YtdHlwZSI6ZnVuY3Rpb24obSxyKXtmb3IodmFyIGk9ci5nZXRTaWJsaW5ncyhtKSxuPWkubGVuZ3RoLTE7bj49MDtuLS0paWYoci5pc1RhZyhpW25dKSl7aWYoaVtuXT09PW0pcmV0dXJuITA7aWYoci5nZXROYW1lKGlbbl0pPT09ci5nZXROYW1lKG0pKWJyZWFrfXJldHVybiExfSwib25seS1vZi10eXBlIjpmdW5jdGlvbihtLHIpe2Zvcih2YXIgaT1yLmdldFNpYmxpbmdzKG0pLG49MCxzPWkubGVuZ3RoO248cztuKyspaWYoci5pc1RhZyhpW25dKSl7aWYoaVtuXT09PW0pY29udGludWU7aWYoci5nZXROYW1lKGlbbl0pPT09ci5nZXROYW1lKG0pKXJldHVybiExfXJldHVybiEwfSwib25seS1jaGlsZCI6ZnVuY3Rpb24obSxyKXtmb3IodmFyIGk9ci5nZXRTaWJsaW5ncyhtKSxuPTA7bjxpLmxlbmd0aDtuKyspaWYoci5pc1RhZyhpW25dKSYmaVtuXSE9PW0pcmV0dXJuITE7cmV0dXJuITB9LGxpbms6ZnVuY3Rpb24obSxyKXtyZXR1cm4gci5oYXNBdHRyaWIobSwiaHJlZiIpfSxzZWxlY3RlZDpmdW5jdGlvbihtLHIpe2lmKHIuaGFzQXR0cmliKG0sInNlbGVjdGVkIikpcmV0dXJuITA7aWYoci5nZXROYW1lKG0pIT09Im9wdGlvbiIpcmV0dXJuITE7dmFyIGk9ci5nZXRQYXJlbnQobSk7aWYoIWl8fHIuZ2V0TmFtZShpKSE9PSJzZWxlY3QifHxyLmhhc0F0dHJpYihpLCJtdWx0aXBsZSIpKXJldHVybiExO2Zvcih2YXIgbj1yLmdldENoaWxkcmVuKGkpLHM9ITEseD0wO3g8bi5sZW5ndGg7eCsrKWlmKHIuaXNUYWcoblt4XSkpaWYoblt4XT09PW0pcz0hMDtlbHNlIGlmKHMpe2lmKHIuaGFzQXR0cmliKG5beF0sInNlbGVjdGVkIikpcmV0dXJuITF9ZWxzZSByZXR1cm4hMTtyZXR1cm4gc30sZGlzYWJsZWQ6ZnVuY3Rpb24obSxyKXtyZXR1cm4gci5oYXNBdHRyaWIobSwiZGlzYWJsZWQiKX0sZW5hYmxlZDpmdW5jdGlvbihtLHIpe3JldHVybiFyLmhhc0F0dHJpYihtLCJkaXNhYmxlZCIpfSxjaGVja2VkOmZ1bmN0aW9uKG0scil7cmV0dXJuIHIuaGFzQXR0cmliKG0sImNoZWNrZWQiKXx8di5zZWxlY3RlZChtLHIpfSxyZXF1aXJlZDpmdW5jdGlvbihtLHIpe3JldHVybiByLmhhc0F0dHJpYihtLCJyZXF1aXJlZCIpfSxvcHRpb25hbDpmdW5jdGlvbihtLHIpe3JldHVybiFyLmhhc0F0dHJpYihtLCJyZXF1aXJlZCIpfSxwYXJlbnQ6ZnVuY3Rpb24obSxyKXtyZXR1cm4hdi5lbXB0eShtLHIpfSxoZWFkZXI6QyhbImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiJdKSxidXR0b246ZnVuY3Rpb24obSxyKXt2YXIgaT1yLmdldE5hbWUobSk7cmV0dXJuIGk9PT0iYnV0dG9uInx8aT09PSJpbnB1dCImJnIuZ2V0QXR0cmlidXRlVmFsdWUobSwidHlwZSIpPT09ImJ1dHRvbiJ9LGlucHV0OkMoWyJpbnB1dCIsInRleHRhcmVhIiwic2VsZWN0IiwiYnV0dG9uIl0pLHRleHQ6ZnVuY3Rpb24obSxyKXt2YXIgaTtyZXR1cm4gci5nZXROYW1lKG0pPT09ImlucHV0IiYmKCEoaT1yLmdldEF0dHJpYnV0ZVZhbHVlKG0sInR5cGUiKSl8fGkudG9Mb3dlckNhc2UoKT09PSJ0ZXh0Iil9fTtmdW5jdGlvbiBDKG0pe2lmKHR5cGVvZiBTZXQ8InUiKXt2YXIgcj1uZXcgU2V0KG0pO3JldHVybiBmdW5jdGlvbihpLG4pe3JldHVybiByLmhhcyhuLmdldE5hbWUoaSkpfX1yZXR1cm4gZnVuY3Rpb24oaSxuKXtyZXR1cm4gbS5pbmRleE9mKG4uZ2V0TmFtZShpKSk+PTB9fWZ1bmN0aW9uIHAobSxyLGkpe2lmKGk9PT1udWxsKXtpZihtLmxlbmd0aD4yJiZyIT09InNjb3BlIil0aHJvdyBuZXcgRXJyb3IoInBzZXVkby1zZWxlY3RvciA6IityKyIgcmVxdWlyZXMgYW4gYXJndW1lbnQiKX1lbHNlIGlmKG0ubGVuZ3RoPT09Mil0aHJvdyBuZXcgRXJyb3IoInBzZXVkby1zZWxlY3RvciA6IityKyIgZG9lc24ndCBoYXZlIGFueSBhcmd1bWVudHMiKX12YXIgaD0vXig/Oig/Om50aHxsYXN0fGZpcnN0fG9ubHkpLSg/OmNoaWxkfG9mLXR5cGUpfHJvb3R8ZW1wdHl8KD86ZW58ZGlzKWFibGVkfGNoZWNrZWR8bm90KSQvO0wuZXhwb3J0cz17Y29tcGlsZTpmdW5jdGlvbihtLHIsaSxuKXt2YXIgcz1yLm5hbWUseD1yLmRhdGEsUD1pLmFkYXB0ZXI7aWYoaSYmaS5zdHJpY3QmJiFoLnRlc3QocykpdGhyb3cgbmV3IEVycm9yKCI6IitzKyIgaXNuJ3QgcGFydCBvZiBDU1MzIik7aWYodHlwZW9mIGZbc109PSJmdW5jdGlvbiIpcmV0dXJuIGZbc10obSx4LGksbik7aWYodHlwZW9mIHZbc109PSJmdW5jdGlvbiIpe3ZhciBSPXZbc107cmV0dXJuIHAoUixzLHgpLFI9PT1kP1I6bT09PVQ/ZnVuY3Rpb24oRSl7cmV0dXJuIFIoRSxQLHgpfTpmdW5jdGlvbihFKXtyZXR1cm4gUihFLFAseCkmJm0oRSl9fWVsc2UgdGhyb3cgbmV3IEVycm9yKCJ1bm1hdGNoZWQgcHNldWRvLWNsYXNzIDoiK3MpfSxmaWx0ZXJzOmYscHNldWRvczp2fX0sZnVuY3Rpb24oTCxlLHQpe3ZhciBhPXQoMjg0KSxsPXQoMjg1KTtMLmV4cG9ydHM9ZnVuY3Rpb24oVCl7cmV0dXJuIGwoYShUKSl9LEwuZXhwb3J0cy5wYXJzZT1hLEwuZXhwb3J0cy5jb21waWxlPWx9LGZ1bmN0aW9uKEwsZSl7TC5leHBvcnRzPWE7dmFyIHQ9L14oWytcLV0/XGQqbik/XHMqKD86KFsrXC1dPylccyooXGQrKSk/JC87ZnVuY3Rpb24gYShsKXtpZihsPWwudHJpbSgpLnRvTG93ZXJDYXNlKCksbD09PSJldmVuIilyZXR1cm5bMiwwXTtpZihsPT09Im9kZCIpcmV0dXJuWzIsMV07dmFyIE09bC5tYXRjaCh0KTtpZighTSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoIm4tdGggcnVsZSBjb3VsZG4ndCBiZSBwYXJzZWQgKCciK2wrIicpIik7dmFyIFQ7cmV0dXJuIE1bMV0/KFQ9cGFyc2VJbnQoTVsxXSwxMCksaXNOYU4oVCkmJihNWzFdLmNoYXJBdCgwKT09PSItIj9UPS0xOlQ9MSkpOlQ9MCxbVCxNWzNdP3BhcnNlSW50KChNWzJdfHwiIikrTVszXSwxMCk6MF19fSxmdW5jdGlvbihMLGUsdCl7TC5leHBvcnRzPVQ7dmFyIGE9dCgyNzMpLGw9YS50cnVlRnVuYyxNPWEuZmFsc2VGdW5jO2Z1bmN0aW9uIFQoZCl7dmFyIHU9ZFswXSxjPWRbMV0tMTtpZihjPDAmJnU8PTApcmV0dXJuIE07aWYodT09PS0xKXJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gZjw9Y307aWYodT09PTApcmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiBmPT09Y307aWYodT09PTEpcmV0dXJuIGM8MD9sOmZ1bmN0aW9uKGYpe3JldHVybiBmPj1jfTt2YXIgTz1jJXU7cmV0dXJuIE88MCYmKE8rPXUpLHU+MT9mdW5jdGlvbihmKXtyZXR1cm4gZj49YyYmZiV1PT09T306KHUqPS0xLGZ1bmN0aW9uKGYpe3JldHVybiBmPD1jJiZmJXU9PT1PfSl9fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLHQuZChlLCJkZWZhdWx0IixmdW5jdGlvbigpe3JldHVybiB4fSk7dmFyIGE9dCgxMiksbD10KDc0KSxNPXQoMSksVD10KDY4KSxkPXQoMjUwKSx1PXQoMjEzKSxjPXQoMjE4KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gTyhQLFIpe2lmKFA9PW51bGwpcmV0dXJue307dmFyIGI9ZihQLFIpLEUsRDtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgST1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKFApO2ZvcihEPTA7RDxJLmxlbmd0aDtEKyspRT1JW0RdLCEoUi5pbmRleE9mKEUpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFAsRSkmJihiW0VdPVBbRV0pfXJldHVybiBifWZ1bmN0aW9uIGYoUCxSKXtpZihQPT1udWxsKXJldHVybnt9O3ZhciBiPXt9LEU9T2JqZWN0LmtleXMoUCksRCxJO2ZvcihJPTA7STxFLmxlbmd0aDtJKyspRD1FW0ldLCEoUi5pbmRleE9mKEQpPj0wKSYmKGJbRF09UFtEXSk7cmV0dXJuIGJ9Y29uc3QgZz17YW50aWFsaWFzOiEwLGF1dG9SZW5kZXI6ITAsYWxwaGE6ITB9LHY9U3ltYm9sKCJhdXRvUmVuZGVyIiksQz1TeW1ib2woInJlbmRlcmVyIikscD1TeW1ib2woInRpbWVsaW5lIiksaD1TeW1ib2woInByZXBhcmVSZW5kZXIiKSxtPVN5bWJvbCgidGlja1JlbmRlciIpLHI9U3ltYm9sKCJwYXNzIiksaT1TeW1ib2woImZibyIpLG49U3ltYm9sKCJ0aWNrZXJzIikscz1TeW1ib2woImxheWVyVHJhbnNmb3JtSW52ZXJ0Iik7Y2xhc3MgeCBleHRlbmRzIGQuZGVmYXVsdHtjb25zdHJ1Y3RvcihSPXt9KXtpZihzdXBlcigpLCFSLmNhbnZhcyl7Y29uc3R7d2lkdGg6SSxoZWlnaHQ6U309dGhpcy5nZXRSZXNvbHV0aW9uKCksQT1hLkVOVi5jcmVhdGVDYW52YXMoSSxTLHtvZmZzY3JlZW46ISFSLm9mZnNjcmVlbixpZDpSLmlkLGV4dHJhOlIuZXh0cmF9KTtBLnN0eWxlJiYoQS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxBLmRhdGFzZXQmJihBLmRhdGFzZXQubGF5ZXJJZD1SLmlkKSxBLmNvbnRleHRUeXBlJiYoUi5jb250ZXh0VHlwZT1BLmNvbnRleHRUeXBlKSxSLmNhbnZhcz1BfWNvbnN0IGI9Ui5jYW52YXMsRT1PYmplY3QuYXNzaWduKHt9LGcsUik7dGhpc1t2XT1FLmF1dG9SZW5kZXIsZGVsZXRlIFIuYXV0b1JlbmRlcjtjb25zdCBEPUUuUmVuZGVyZXJ8fGEuUmVuZGVyZXI7dGhpc1tDXT1uZXcgRChiLEUpLHRoaXMub3B0aW9ucz1SLHRoaXMuaWQ9Ui5pZCx0aGlzW3JdPVtdLHRoaXMuc2V0UmVzb2x1dGlvbihiKSx0aGlzLmNhbnZhcz1iLHRoaXNbcF09bmV3IGwuVGltZWxpbmUsdGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbCx0aGlzW3NdPW51bGx9Z2V0IGF1dG9SZW5kZXIoKXtyZXR1cm4gdGhpc1t2XX1nZXQgZGlzcGxheVJhdGlvKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcHRpb25zP3RoaXMucGFyZW50Lm9wdGlvbnMuZGlzcGxheVJhdGlvOjF9Z2V0IGhlaWdodCgpe2NvbnN0e2hlaWdodDpSfT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gUi90aGlzLmRpc3BsYXlSYXRpb31nZXQgZ2woKXtyZXR1cm4gdGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyP3RoaXMucmVuZGVyZXIuZ2xSZW5kZXJlci5nbDpudWxsfWdldCBsYXllcigpe3JldHVybiB0aGlzfWdldCBvZmZzY3JlZW4oKXtyZXR1cm4hIXRoaXMub3B0aW9ucy5vZmZzY3JlZW58fHRoaXMuY2FudmFzLl9vZmZzY3JlZW59Z2V0IHBhc3MoKXtyZXR1cm4gdGhpc1tyXX1nZXQgcHJlcGFyZVJlbmRlcigpe3JldHVybiB0aGlzW2hdP3RoaXNbaF06UHJvbWlzZS5yZXNvbHZlKCl9Z2V0IHJlbmRlcmVyKCl7cmV0dXJuIHRoaXNbQ119Z2V0IHJlbmRlck9mZnNldCgpe2lmKHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5vcHRpb25zKXtjb25zdHtsZWZ0OlIsdG9wOmJ9PXRoaXMucGFyZW50Lm9wdGlvbnM7cmV0dXJuW1IsYl19cmV0dXJuW3RoaXMub3B0aW9ucy5sZWZ0fDAsdGhpcy5vcHRpb25zLnRvcHwwXX1nZXQgdGltZWxpbmUoKXtyZXR1cm4gdGhpc1twXX1nZXQgd2lkdGgoKXtjb25zdHt3aWR0aDpSfT10aGlzLmdldFJlc29sdXRpb24oKTtyZXR1cm4gUi90aGlzLmRpc3BsYXlSYXRpb31nZXQgbG9jYWxNYXRyaXgoKXtjb25zdHt4OlIseTpifT10aGlzLmF0dHJpYnV0ZXM7cmV0dXJuWzEsMCwwLDEsUixiXX1nZXQgbGF5ZXJUcmFuc2Zvcm1JbnZlcnQoKXtpZih0aGlzW3NdKXJldHVybiB0aGlzW3NdO2NvbnN0IFI9dGhpcy50cmFuc2Zvcm1NYXRyaXg7cmV0dXJuIFJbMF09PT0xJiZSWzFdPT09MCYmUlsyXT09PTAmJlJbM109PT0xJiZSWzRdPT09MCYmUls1XT09PTA/bnVsbDoodGhpc1tzXT1NLm1hdDJkLmludmVydChBcnJheS5vZigwLDAsMCwwLDAsMCksUiksdGhpc1tzXSl9Zm9yY2VDb250ZXh0TG9zcygpe2NvbnN0IFI9dGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyO2lmKFIpe2NvbnN0IGI9Ui5nZXRFeHRlbnNpb24oIldFQkdMX2xvc2VfY29udGV4dCIpO2lmKGIpcmV0dXJuIGIubG9zZUNvbnRleHQoKSwhMH1yZXR1cm4hMX1hZGRQYXNzKHt2ZXJ0ZXg6UixmcmFnbWVudDpiLG9wdGlvbnM6RSx1bmlmb3JtczpEfT17fSl7aWYodGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyKXtjb25zdHt3aWR0aDpJLGhlaWdodDpTfT10aGlzLmdldFJlc29sdXRpb24oKSxBPXRoaXMucmVuZGVyZXIuY3JlYXRlUGFzc1Byb2dyYW0oe3ZlcnRleDpSLGZyYWdtZW50OmIsb3B0aW9uczpFfSksVT1uZXcgYS5GaWd1cmUyRDtVLnJlY3QoMCwwLEkvdGhpcy5kaXNwbGF5UmF0aW8sUy90aGlzLmRpc3BsYXlSYXRpbyk7Y29uc3QgSz1uZXcgYS5NZXNoMkQoVSk7cmV0dXJuIEsuc2V0VW5pZm9ybXMoRCksSy5zZXRQcm9ncmFtKEEpLHRoaXNbcl0ucHVzaChLKSx0aGlzLmZvcmNlVXBkYXRlKCksS31yZXR1cm4gbnVsbH1kZWxldGVUZXh0dXJlKFIpe3JldHVybiBPYmplY3QoYy5kZWxldGVUZXh0dXJlKShSLHRoaXMucmVuZGVyZXIpfWRpc3BhdGNoUG9pbnRlckV2ZW50KFIpe2NvbnN0IGI9Ui50eXBlO2lmKGI9PT0ibW91c2Vkb3duInx8Yj09PSJtb3VzZXVwInx8Yj09PSJtb3VzZW1vdmUiKXtjb25zdCBBPXRoaXMuX19tb3VzZUNhcHR1cmVkVGFyZ2V0O2lmKEEpe2lmKEEubGF5ZXI9PT10aGlzKXJldHVybiBBLmRpc3BhdGNoRXZlbnQoUiksITA7dGhpcy5fX21vdXNlQ2FwdHVyZWRUYXJnZXQ9bnVsbH19bGV0IEUsRDtjb25zdCBJPXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQ7aWYoSSl7RT1SLngsRD1SLnk7Y29uc3QgQT1JLFU9QVswXSpFK0FbMl0qRCtBWzRdLEs9QVsxXSpFK0FbM10qRCtBWzVdO2RlbGV0ZSBSLngsZGVsZXRlIFIueSxkZWxldGUgUi5sYXllclgsZGVsZXRlIFIubGF5ZXJZLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFIse2xheWVyWDp7dmFsdWU6VSxjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6Syxjb25maWd1cmFibGU6ITB9LHg6e3ZhbHVlOlUsY29uZmlndXJhYmxlOiEwfSx5Ont2YWx1ZTpLLGNvbmZpZ3VyYWJsZTohMH19KX1jb25zdCBTPXN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KFIpO3JldHVybiBJJiZPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSLHtsYXllclg6e3ZhbHVlOkUsY29uZmlndXJhYmxlOiEwfSxsYXllclk6e3ZhbHVlOkQsY29uZmlndXJhYmxlOiEwfSx4Ont2YWx1ZTpFLGNvbmZpZ3VyYWJsZTohMH0seTp7dmFsdWU6RCxjb25maWd1cmFibGU6ITB9fSksU31mb3JjZVVwZGF0ZSgpe2lmKCF0aGlzW2hdKWlmKHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5oYXNPZmZzY3JlZW5DYW52YXMpe3RoaXMucGFyZW50LmZvcmNlVXBkYXRlKCk7bGV0IFI9bnVsbDtjb25zdCBiPW5ldyBQcm9taXNlKEU9PntSPUV9KTtiLl9yZXNvbHZlPVIsdGhpc1toXT1ifWVsc2V7bGV0IFI9bnVsbCxiPW51bGw7Y29uc3QgRT1uZXcgUHJvbWlzZShEPT57Uj1ELHRoaXNbdl0mJihiPU9iamVjdChULnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgRS5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9KTtFLl9yZXNvbHZlPVIsRS5fcmVxdWVzdElEPWIsdGhpc1toXT1FfX1nZXRGQk8oKXtjb25zdCBSPXRoaXMucmVuZGVyZXIuZ2xSZW5kZXJlcix7d2lkdGg6YixoZWlnaHQ6RX09dGhpcy5nZXRSZXNvbHV0aW9uKCk7cmV0dXJuIFImJighdGhpc1tpXXx8dGhpc1tpXS53aWR0aCE9PWJ8fHRoaXNbaV0uaGVpZ2h0IT09RSk/KHRoaXNbaV09e3dpZHRoOmIsaGVpZ2h0OkUsdGFyZ2V0OlIuY3JlYXRlRkJPKCksYnVmZmVyOlIuY3JlYXRlRkJPKCksc3dhcCgpe1t0aGlzLnRhcmdldCx0aGlzLmJ1ZmZlcl09W3RoaXMuYnVmZmVyLHRoaXMudGFyZ2V0XX19LHRoaXNbaV0pOnRoaXNbaV0/dGhpc1tpXTpudWxsfXVwZGF0ZUdsb2JhbFRyYW5zZm9ybSgpe2lmKHRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IFI9dGhpcy5yZW5kZXJlcixiPVIuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fFIuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O1IuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9Yjtjb25zdCBFPU0ubWF0MmQuZnJvbVZhbHVlcygxLDAsMCwxLDAsMCk7Ui5zZXRHbG9iYWxUcmFuc2Zvcm0oLi4uTS5tYXQyZC5tdWx0aXBseShFLGIsdGhpcy50cmFuc2Zvcm1NYXRyaXgpKX19b25Qcm9wZXJ0eUNoYW5nZShSLGIsRSl7aWYoc3VwZXIub25Qcm9wZXJ0eUNoYW5nZShSLGIsRSksUj09PSJ6SW5kZXgiJiYodGhpcy5jYW52YXMuc3R5bGUuekluZGV4PWIpLFI9PT0idHJhbnNmb3JtInx8Uj09PSJ0cmFuc2xhdGUifHxSPT09InJvdGF0ZSJ8fFI9PT0ic2NhbGUifHxSPT09InNrZXciKXtjb25zdCBEPXRoaXNbc107aWYodGhpc1tzXT1udWxsLHRoaXMudXBkYXRlR2xvYmFsVHJhbnNmb3JtKCksRCYmIXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IEk9dGhpcy5yZW5kZXJlcixTPUkuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXh8fEkuZ2xvYmFsVHJhbnNmb3JtTWF0cml4O0kuc2V0R2xvYmFsVHJhbnNmb3JtKC4uLlMpfX19X3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpe3RoaXNbaF0mJih0aGlzW2hdLl9yZXF1ZXN0SUQmJk9iamVjdChULmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzW2hdLl9yZXF1ZXN0SUQpLHRoaXNbaF0uX3Jlc29sdmUoKSxkZWxldGUgdGhpc1toXSl9cmVuZGVyKHtjbGVhcjpSPSEwfT17fSl7Y29uc3QgYj10aGlzW3JdLmxlbmd0aD90aGlzLmdldEZCTygpOm51bGw7YiYmdGhpcy5yZW5kZXJlci5nbFJlbmRlcmVyLmJpbmRGQk8oYi50YXJnZXQpLFImJnRoaXNbQ10uY2xlYXIoKTtjb25zdCBFPXRoaXMuZHJhdygpO2lmKEUmJkUubGVuZ3RoJiYodGhpcy5yZW5kZXJlci5kcmF3TWVzaGVzKEUpLHRoaXMuY2FudmFzLmRyYXcmJnRoaXMuY2FudmFzLmRyYXcoKSksYil7Y29uc3QgRD10aGlzLnJlbmRlcmVyLmdsUmVuZGVyZXIsST10aGlzW3JdLmxlbmd0aCx7d2lkdGg6UyxoZWlnaHQ6QX09dGhpcy5nZXRSZXNvbHV0aW9uKCksVT1bMCwwLFMvdGhpcy5kaXNwbGF5UmF0aW8sQS90aGlzLmRpc3BsYXlSYXRpb107dGhpc1tyXS5mb3JFYWNoKChLLFYpPT57Sy5ibGVuZD0hMCxLLnNldFRleHR1cmUoYi50YXJnZXQudGV4dHVyZSx7cmVjdDpVfSksVj09PUktMT9ELmJpbmRGQk8obnVsbCk6KGIuc3dhcCgpLEQuYmluZEZCTyhiLnRhcmdldCkpLHRoaXNbQ10uY2xlYXIoKSx0aGlzLnJlbmRlcmVyLmRyYXdNZXNoZXMoW0tdKX0pfXRoaXMuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpfXNldFJlc29sdXRpb24oe3dpZHRoOlIsaGVpZ2h0OmJ9KXtjb25zdCBFPXRoaXMucmVuZGVyZXIsRD1FLl9fZ2xvYmFsVHJhbnNmb3JtTWF0cml4fHxFLmdsb2JhbFRyYW5zZm9ybU1hdHJpeCxJPURbNF0sUz1EWzVdLEE9RFswXSx7d2lkdGg6VSxoZWlnaHQ6S309dGhpcy5nZXRSZXNvbHV0aW9uKCk7KFUhPT1SfHxLIT09YikmJihzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpSLGhlaWdodDpifSksdGhpcy5jYW52YXMmJih0aGlzLmNhbnZhcy53aWR0aD1SLHRoaXMuY2FudmFzLmhlaWdodD1iLEUudXBkYXRlUmVzb2x1dGlvbiYmRS51cGRhdGVSZXNvbHV0aW9uKCkpLHRoaXMuYXR0cmlidXRlcy5zaXplPVtSLGJdLHRoaXNbcl0ubGVuZ3RoJiZ0aGlzW3JdLmZvckVhY2goVz0+e2NvbnN0IEg9bmV3IGEuRmlndXJlMkQ7SC5yZWN0KDAsMCxSL3RoaXMuZGlzcGxheVJhdGlvLGIvdGhpcy5kaXNwbGF5UmF0aW8pLFcuY29udG91cnM9SC5jb250b3Vyc30pKTtjb25zdFtWLEpdPXRoaXMucmVuZGVyT2Zmc2V0LHE9dGhpcy5kaXNwbGF5UmF0aW87KEkhPT1WfHxTIT09Snx8QSE9PXEpJiYoRS5zZXRHbG9iYWxUcmFuc2Zvcm0ocSwwLDAscSxWLEopLEUuX19nbG9iYWxUcmFuc2Zvcm1NYXRyaXg9bnVsbCx0aGlzW3NdPW51bGwsdGhpcy51cGRhdGVHbG9iYWxUcmFuc2Zvcm0oKSx0aGlzLmZvcmNlVXBkYXRlKCkpfXRpY2soUj1udWxsLGI9e30pe2xldHtkdXJhdGlvbjpFPTEvMH09YixEPU8oYixbImR1cmF0aW9uIl0pO2NvbnN0IEk9dGhpcy50aW1lbGluZS5mb3JrKEQpLFM9dGhpczt0aGlzW25dPXRoaXNbbl18fFtdLHRoaXNbbl0ucHVzaCh7aGFuZGxlcjpSLGR1cmF0aW9uOkV9KTtjb25zdCBBPSgpPT57bGV0IFU9bnVsbCxLPW51bGw7Y29uc3QgVj0oKT0+e2NvbnN0IEo9dGhpc1tuXS5tYXAoKHtoYW5kbGVyOnEsZHVyYXRpb246V30pPT57Y29uc3QgSD1NYXRoLm1pbigxLEkuY3VycmVudFRpbWUvVyk7cmV0dXJue3ZhbHVlOnE/cShJLmN1cnJlbnRUaW1lLEgpOm51bGwscDpIfX0pO1NbbV18fChTW21dPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntTW3ZdJiZTLnJlbmRlcigpLGRlbGV0ZSBTW21dO2ZvcihsZXQgcT1KLmxlbmd0aC0xO3E+PTA7cS0tKXtjb25zdHt2YWx1ZTpXLHA6SH09SltxXTsoVz09PSExfHxIPj0xKSYmdGhpc1tuXS5zcGxpY2UocSwxKX10aGlzW25dLmxlbmd0aD4wJiZBKCl9KSl9O2lmKHRoaXNbaF0mJnRoaXNbaF0uX3R5cGUhPT0idGlja2VyIiYmKE9iamVjdChULmNhbmNlbEFuaW1hdGlvbkZyYW1lKSh0aGlzW2hdLl9yZXF1ZXN0SUQpLGRlbGV0ZSB0aGlzW2hdKSwhdGhpc1toXSl7Y29uc3QgSj1uZXcgUHJvbWlzZShxPT57VT1xLEs9T2JqZWN0KFQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKShWKX0pO0ouX3Jlc29sdmU9VSxKLl9yZXF1ZXN0SUQ9SyxKLl90eXBlPSJ0aWNrZXIiLHRoaXNbaF09Sn19O0EoKX10b0dsb2JhbFBvcyhSLGIpe2lmKHRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQpe2NvbnN0IFU9dGhpcy50cmFuc2Zvcm1NYXRyaXg7Uj1VWzBdKlIrVVsyXSpiK1VbNF0sYj1VWzFdKlIrVVszXSpiK1VbNV19Y29uc3R7d2lkdGg6RSxoZWlnaHQ6RH09dGhpcy5nZXRSZXNvbHV0aW9uKCksST10aGlzLnJlbmRlck9mZnNldCxTPVt0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHRdO1I9UipTWzBdL0UrSVswXSxiPWIqU1sxXS9EK0lbMV07Y29uc3QgQT10aGlzLmRpc3BsYXlSYXRpbztyZXR1cm4gUio9QSxiKj1BLFtSLGJdfXRvTG9jYWxQb3MoUixiKXtjb25zdHt3aWR0aDpFLGhlaWdodDpEfT10aGlzLmdldFJlc29sdXRpb24oKSxJPXRoaXMucmVuZGVyT2Zmc2V0LFM9W3RoaXMuY2FudmFzLmNsaWVudFdpZHRoLHRoaXMuY2FudmFzLmNsaWVudEhlaWdodF07Uj1SKkUvU1swXS1JWzBdLGI9YipEL1NbMV0tSVsxXTtjb25zdCBBPXRoaXMuZGlzcGxheVJhdGlvO1IvPUEsYi89QTtjb25zdCBVPXRoaXMubGF5ZXJUcmFuc2Zvcm1JbnZlcnQ7cmV0dXJuIFUmJihSPVVbMF0qUitVWzJdKmIrVVs0XSxiPVVbMV0qUitVWzNdKmIrVVs1XSksW1IsYl19fXUuZGVmYXVsdC5yZWdpc3Rlck5vZGUoeCwibGF5ZXIiKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gaH0pO3ZhciBhPXQoMjI0KSxsPXQoMjg4KSxNPXQoMjEzKSxUPXQoMjUyKSxkPXQoNzIpO3QoMSkuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtmdW5jdGlvbiB1KG0scil7aWYobT09bnVsbClyZXR1cm57fTt2YXIgaT1jKG0sciksbixzO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciB4PU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobSk7Zm9yKHM9MDtzPHgubGVuZ3RoO3MrKyluPXhbc10sIShyLmluZGV4T2Yobik+PTApJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwobSxuKSYmKGlbbl09bVtuXSl9cmV0dXJuIGl9ZnVuY3Rpb24gYyhtLHIpe2lmKG09PW51bGwpcmV0dXJue307dmFyIGk9e30sbj1PYmplY3Qua2V5cyhtKSxzLHg7Zm9yKHg9MDt4PG4ubGVuZ3RoO3grKylzPW5beF0sIShyLmluZGV4T2Yocyk+PTApJiYoaVtzXT1tW3NdKTtyZXR1cm4gaX1mdW5jdGlvbiBPKG0scixpKXtyZXR1cm4gciBpbiBtP09iamVjdC5kZWZpbmVQcm9wZXJ0eShtLHIse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTptW3JdPWksbX1jb25zdCBmPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsZz1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSx2PVN5bWJvbCgicm9vdCIpLEM9U3ltYm9sKCJ0YXNrIik7ZnVuY3Rpb24gcChtLHI9ITApe2NvbnN0IGk9bVt2XTtpZihpJiZpLmNoaWxkcmVuWzBdKXtjb25zdCBuPW0uc3ZnLHM9bS5sYXllcj9tLmxheWVyLmRpc3BsYXlSYXRpbzoxO2lmKCFuLmhhc0F0dHJpYnV0ZSgiZGF0YS1vcmlnaW5hbC13aWR0aCIpKXtsZXQgUj1uLmdldEF0dHJpYnV0ZSgid2lkdGgiKTtSPVI/T2JqZWN0KGQuc2l6ZVRvUGl4ZWwpKFIpOjMwMDtsZXQgYj1uLmdldEF0dHJpYnV0ZSgiaGVpZ2h0Iik7Yj1iP09iamVjdChkLnNpemVUb1BpeGVsKShiKToxNTAsbi5oYXNBdHRyaWJ1dGUoInZpZXdCb3giKXx8bi5zZXRBdHRyaWJ1dGUoInZpZXdCb3giLGAwIDAgJHtNYXRoLnJvdW5kKFIpfSAke01hdGgucm91bmQoYil9YCksbi5zZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiLFIpLG4uc2V0QXR0cmlidXRlKCJkYXRhLW9yaWdpbmFsLWhlaWdodCIsYil9bGV0IHg9bS5hdHRyaWJ1dGVzLndpZHRofHxOdW1iZXIobi5nZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtd2lkdGgiKSksUD1tLmF0dHJpYnV0ZXMuaGVpZ2h0fHxOdW1iZXIobi5nZXRBdHRyaWJ1dGUoImRhdGEtb3JpZ2luYWwtaGVpZ2h0IikpO2lmKHgqPXMsUCo9cyxyJiZtLmF0dHJpYnV0ZXMuZmxleGlibGUpe2NvbnN0IFI9bS5hdHRyaWJ1dGVzLnNjYWxlWzBdO2lmKHgqPVIsUCo9UixuLnNldEF0dHJpYnV0ZSgid2lkdGgiLHgpLG4uc2V0QXR0cmlidXRlKCJoZWlnaHQiLFApLHgmJlAmJm0udGV4dHVyZUltYWdlKXtjb25zdCBiPW0udGV4dHVyZUltYWdlLndpZHRoLEU9bS50ZXh0dXJlSW1hZ2UuaGVpZ2h0LEQ9bS5jbGllbnRTaXplO20uYXR0cmlidXRlcy50ZXh0dXJlUmVjdD1bMCwwLE1hdGgucm91bmQoRFswXSpiL3gpLE1hdGgucm91bmQoRFsxXSpFL1ApXX19ZWxzZSBtW0NdfHwobi5zZXRBdHRyaWJ1dGUoIndpZHRoIix4KSxuLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixQKSxtW0NdPVByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PntkZWxldGUgbVtDXTtjb25zdCBSPWkuaW5uZXJIVE1MLGI9bmV3IEJsb2IoW1JdLHt0eXBlOiJpbWFnZS9zdmcreG1sIn0pLEU9VVJMLmNyZWF0ZU9iamVjdFVSTChiKSxEPW5ldyBJbWFnZTtELm9ubG9hZD1mdW5jdGlvbigpe0Qud2lkdGgmJkQuaGVpZ2h0PyhtLmF0dHJpYnV0ZXNbZ10oInRleHR1cmUiLEQpLG0uYXR0cmlidXRlcy5mbGV4aWJsZSYmKG0uYXR0cmlidXRlcy50ZXh0dXJlUmVjdD1udWxsKSk6bS5hdHRyaWJ1dGVzW2ddKCJ0ZXh0dXJlIixudWxsKX0sRC5zcmM9RX0pKX19Y2xhc3MgaCBleHRlbmRzIGEuZGVmYXVsdHtjb25zdHJ1Y3RvcihyPXt9KXt0eXBlb2Ygcj09InN0cmluZyImJihyPXtzdmdUZXh0OnJ9KTtsZXR7c3ZnVGV4dDppfT1yLG49dShyLFsic3ZnVGV4dCJdKTtpZihzdXBlcihuKSx0aGlzW3ZdPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGkpe3RoaXNbdl0uaW5uZXJIVE1MPWk7Y29uc3Qgcz10aGlzW3ZdLmNoaWxkcmVuWzBdO3M/cy5zZXRBdHRyaWJ1dGUoInhtbG5zIixmKTooZmV0Y2goaSkudGhlbih4PT54LnRleHQoKSkudGhlbih4PT57dGhpc1t2XS5pbm5lckhUTUw9eCwoIXRoaXMub2JzZXJ2ZXJ8fHRoaXMuYXR0cmlidXRlcy5mbGV4aWJsZSkmJnAodGhpcyl9KSxpPW51bGwpfWlmKCFpKXtjb25zdCBzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmLCJzdmciKTtzLnNldEF0dHJpYnV0ZSgieG1sbnMiLGYpLHRoaXNbdl0uYXBwZW5kQ2hpbGQocyl9aWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXI9PSJmdW5jdGlvbiIpe2NvbnN0IHM9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoeD0+e3AodGhpcywhMSl9KTtzLm9ic2VydmUodGhpc1t2XSx7YXR0cmlidXRlczohMCxzdWJ0cmVlOiEwLGNoYXJhY3RlckRhdGE6ITAsY2hpbGRMaXN0OiEwfSksdGhpcy5vYnNlcnZlcj1zfX1nZXQgY2hpbGRyZW4oKXtyZXR1cm5bdGhpcy5zdmddfWdldCBjaGlsZE5vZGVzKCl7cmV0dXJuW3RoaXMuc3ZnXX1nZXQgc3ZnKCl7cmV0dXJuIHRoaXNbdl0/dGhpc1t2XS5jaGlsZHJlblswXTpudWxsfXNldFJlc29sdXRpb24oe3dpZHRoOnIsaGVpZ2h0Oml9KXtzdXBlci5zZXRSZXNvbHV0aW9uKHt3aWR0aDpyLGhlaWdodDppfSkscCh0aGlzKX1kaXNwYXRjaFBvaW50ZXJFdmVudChyKXtjb25zdCBpPXN1cGVyLmRpc3BhdGNoUG9pbnRlckV2ZW50KHIpO2lmKGkmJnRoaXMuYXR0cmlidXRlcy5wYXNzRXZlbnRzJiZ0eXBlb2YgTW91c2VFdmVudD09ImZ1bmN0aW9uIil7Y29uc3R7eDpuLHk6c309cjtsZXRbeCxQXT10aGlzLmdldE9mZnNldFBvc2l0aW9uKG4scyk7Y29uc3QgUj1yLm9yaWdpbmFsRXZlbnQsYj10aGlzLmF0dHJpYnV0ZXMuYW5jaG9yLEU9dGhpcy5jbGllbnRTaXplO3g9KHgrYlswXSpFWzBdKS8yLFA9KFArYlsxXSpFWzFdKS8yO2NvbnN0IEQ9ci50eXBlO2lmKEQ9PT1SLnR5cGUpe2xldCBJPW51bGw7aWYoUiBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpST1uZXcgTW91c2VFdmVudChELHtzY3JlZW5YOngsc2NyZWVuWTpQLGNsaWVudFg6eCxjbGllbnRZOlAsYnViYmxlczpSLmJ1YmJsZXMsYnV0dG9uOlIuYnV0dG9uLGJ1dHRvbnM6Ui5idXR0b25zLGNhbmNlbEJ1YmJsZTpSLmNhbmNlbEJ1YmJsZSxjYW5jZWxhYmxlOlIuY2FuY2VsYWJsZSxjdXJyZW50VGFyZ2V0OlIuY3VycmVudFRhcmdldCxmcm9tRWxlbWVudDpSLmZyb21FbGVtZW50LHJlbGF0ZWRUYXJnZXQ6Ui5yZWxhdGVkVGFyZ2V0LHJldHVyblZhbHVlOlIucmV0dXJuVmFsdWUsc3JjRWxlbWVudDpSLnNyY0VsZW1lbnQsdGFyZ2V0OlIudGFyZ2V0LHRvRWxlbWVudDpSLnRvRWxlbWVudCx3aGljaDpSLndpdGNofSk7ZWxzZSBpZihSIGluc3RhbmNlb2YgVG91Y2hFdmVudCl7bGV0IFM9bnVsbDtjb25zdCBBPVIuY2hhbmdlZFRvdWNoZXN8fFtSXTtmb3IobGV0IFU9MDtVPEEubGVuZ3RoO1UrKyl7Y29uc3QgSz1BW1VdO2lmKHIuaWRlbnRpZmllcj09PUsuaWRlbnRpZmllcil7Uz1LO2JyZWFrfX1pZihTKXtjb25zdCBVPW5ldyBUb3VjaCh7aWRlbnRpZmllcjpTLmlkZW50aWZpZXIsdGFyZ2V0OlMudGFyZ2V0LGNsaWVudFg6eCxjbGllbnRZOlAsc2NyZWVuWDp4LHNjcmVlblk6UCxwYWdlWDp4LHBhZ2VZOlAscmFkaXVzWDpTLnJhZGl1c1gscmFkaXVzWTpTLnJhZGl1c1kscm90YXRpb25BbmdsZTpTLnJvdGF0aW9uQW5nbGUsZm9yY2U6Uy5mb3JjZX0pO0k9bmV3IFRvdWNoRXZlbnQoRCx7Y2FuY2VsYWJsZTpSLmNhbmNlbGFibGUsYnViYmxlczpSLmJ1YmJsZXMsY29tcG9zZWQ6Ui5jb21wb3NlZCx0b3VjaGVzOltVXSx0YXJnZXRUb3VjaGVzOltVXSxjaGFuZ2VkVG91Y2hlczpbVV19KX19ZWxzZSBJPVI7SSYmdGhpcy5zdmcuZGlzcGF0Y2hFdmVudChJKX19cmV0dXJuIGl9Z2V0RWxlbWVudEJ5SWQocil7cmV0dXJuIE9iamVjdChULnF1ZXJ5U2VsZWN0b3IpKGAjJHtyfWAsdGhpcyl9Z2V0RWxlbWVudHNCeUNsYXNzTmFtZShyKXtyZXR1cm4gT2JqZWN0KFQucXVlcnlTZWxlY3RvckFsbCkoYC4ke3J9YCx0aGlzKX1nZXRFbGVtZW50c0J5TmFtZShyKXtyZXR1cm4gT2JqZWN0KFQucXVlcnlTZWxlY3RvckFsbCkoYFtuYW1lPSIke3J9Il1gLHRoaXMpfWdldEVsZW1lbnRzQnlUYWdOYW1lKHIpe3JldHVybiBPYmplY3QoVC5xdWVyeVNlbGVjdG9yQWxsKShyLHRoaXMpfXF1ZXJ5U2VsZWN0b3Iocil7cmV0dXJuIE9iamVjdChULnF1ZXJ5U2VsZWN0b3IpKHIsdGhpcyl9cXVlcnlTZWxlY3RvckFsbChyKXtyZXR1cm4gT2JqZWN0KFQucXVlcnlTZWxlY3RvckFsbCkocix0aGlzKX1vblByb3BlcnR5Q2hhbmdlKHIsaSxuKXtzdXBlci5vblByb3BlcnR5Q2hhbmdlKHIsaSxuKSxyPT09ImZsZXhpYmxlIiYmcCh0aGlzKSx0aGlzLmF0dHJpYnV0ZXMuZmxleGlibGUmJihyPT09IndpZHRoInx8cj09PSJoZWlnaHQifHxyPT09InNjYWxlInx8cj09PSJ0cmFuc2Zvcm0iKSYmcCh0aGlzKX19TyhoLCJBdHRyIixsLmRlZmF1bHQpLE0uZGVmYXVsdC5yZWdpc3Rlck5vZGUoaCwic3ByaXRlc3ZnIil9LGZ1bmN0aW9uKEwsZSx0KXt0LnIoZSksdC5kKGUsImRlZmF1bHQiLGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTt2YXIgYT10KDIyNSk7dCgxKS5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO2NvbnN0IGw9U3ltYm9sLmZvcigic3ByaXRlanNfZ2V0QXR0cmlidXRlIiksTT1TeW1ib2wuZm9yKCJzcHJpdGVqc19zZXRBdHRyaWJ1dGUiKSxUPVN5bWJvbC5mb3IoInNwcml0ZWpzX3NldEF0dHJpYnV0ZURlZmF1bHQiKTtjbGFzcyBkIGV4dGVuZHMgYS5kZWZhdWx0e2NvbnN0cnVjdG9yKGMpe3N1cGVyKGMpLHRoaXNbVF0oe3Bhc3NFdmVudHM6ITEsZmxleGlibGU6ITF9KX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzW2xdKCJ0ZXh0dXJlIil9c2V0IHRleHR1cmUoYyl7fWdldCBwYXNzRXZlbnRzKCl7cmV0dXJuIHRoaXNbbF0oInBhc3NFdmVudHMiKX1zZXQgcGFzc0V2ZW50cyhjKXtyZXR1cm4gdGhpc1tNXSgicGFzc0V2ZW50cyIsYyl9Z2V0IGZsZXhpYmxlKCl7cmV0dXJuIHRoaXNbbF0oImZsZXhpYmxlIil9c2V0IGZsZXhpYmxlKGMpe3JldHVybiB0aGlzW01dKCJmbGV4aWJsZSIsYyl9fX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKTt2YXIgYT10KDEyKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChjLE8pe3ZhciBmPU9iamVjdC5rZXlzKGMpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBnPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoYyk7TyYmKGc9Zy5maWx0ZXIoZnVuY3Rpb24odil7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYyx2KS5lbnVtZXJhYmxlfSkpLGYucHVzaC5hcHBseShmLGcpfXJldHVybiBmfWZ1bmN0aW9uIE0oYyl7Zm9yKHZhciBPPTE7Tzxhcmd1bWVudHMubGVuZ3RoO08rKyl7dmFyIGY9YXJndW1lbnRzW09dIT1udWxsP2FyZ3VtZW50c1tPXTp7fTtPJTI/bChPYmplY3QoZiksITApLmZvckVhY2goZnVuY3Rpb24oZyl7VChjLGcsZltnXSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhjLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGYpKTpsKE9iamVjdChmKSkuZm9yRWFjaChmdW5jdGlvbihnKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYyxnLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZixnKSl9KX1yZXR1cm4gY31mdW5jdGlvbiBUKGMsTyxmKXtyZXR1cm4gTyBpbiBjP09iamVjdC5kZWZpbmVQcm9wZXJ0eShjLE8se3ZhbHVlOmYsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTpjW09dPWYsY31jb25zdCBkPVN5bWJvbCgiaW5pdGVkIik7bGV0IHU9bnVsbDt0eXBlb2YgV29ya2VyPT0iZnVuY3Rpb24iJiYodT1jbGFzcyBleHRlbmRzIFdvcmtlcntjb25zdHJ1Y3RvcihjKXtpZihjLndvcmtlcj09PSEwJiYoYy53b3JrZXI9YC4vJHtjLmlkfS53b3JrZXIuanNgKSxzdXBlcihjLndvcmtlciksdGhpcy5vcHRpb25zPWMsIWMuY2FudmFzKXtjb25zdHt3aWR0aDpPLGhlaWdodDpmfT10aGlzLmdldFJlc29sdXRpb24oKSxnPWEuRU5WLmNyZWF0ZUNhbnZhcyhPLGYse29mZnNjcmVlbjohMX0pO2cuc3R5bGUmJihnLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpLGcuZGF0YXNldCYmKGcuZGF0YXNldC5sYXllcklkPWMuaWQpLGMuY2FudmFzPWd9dGhpcy5jYW52YXM9Yy5jYW52YXN9Z2V0IGlkKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5pZH1zZXRSZXNvbHV0aW9uKHt3aWR0aDpjLGhlaWdodDpPfSl7aWYodGhpc1tkXSl0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJyZXNvbHV0aW9uX2NoYW5nZSIsd2lkdGg6YyxoZWlnaHQ6T30pO2Vsc2V7dGhpcy5jYW52YXMud2lkdGg9Yyx0aGlzLmNhbnZhcy5oZWlnaHQ9Tztjb25zdCBmPXRoaXMub3B0aW9ucyxnPWYuY2FudmFzLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuKCksdj1NKHt9LGYpO2RlbGV0ZSB2LmNvbnRhaW5lcix2LmNhbnZhcz1nLHRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6ImNyZWF0ZSIsb3B0aW9uczp2fSxbZ10pLHRoaXNbZF09ITB9fWdldFJlc29sdXRpb24oKXtpZih0aGlzLmNhbnZhcyl7Y29uc3R7d2lkdGg6YyxoZWlnaHQ6T309dGhpcy5jYW52YXM7cmV0dXJue3dpZHRoOmMsaGVpZ2h0Ok99fXJldHVybnt3aWR0aDozMDAsaGVpZ2h0OjE1MH19cmVtb3ZlKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZD8odGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksITApOiExfWNvbm5lY3QoYyxPKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFyZW50Iix7dmFsdWU6Yyx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiek9yZGVyIix7dmFsdWU6Tyx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KX1kaXNjb25uZWN0KCl7ZGVsZXRlIHRoaXMucGFyZW50LGRlbGV0ZSB0aGlzLnpPcmRlcn1kaXNwYXRjaFBvaW50ZXJFdmVudChjKXt0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiJldmVudCIsZXZlbnQ6e2NhbmNlbEJ1YmJsZTpjLmNhbmNlbEJ1YmJsZSxidWJibGVzOmMuYnViYmxlcyxkZXRhaWw6Yy5kZXRhaWwsaWRlbnRpZmllcjpjLmlkZW50aWZpZXIsbGF5ZXJYOmMubGF5ZXJYLGxheWVyWTpjLmxheWVyWSxvcmlnaW5hbFg6Yy5vcmlnaW5hbFgsb3JpZ2luYWxZOmMub3JpZ2luYWxZLHR5cGU6Yy50eXBlLHg6Yy54LHk6Yy55fX0pfX0pLGUuZGVmYXVsdD11fSxmdW5jdGlvbihMLGUsdCl7dC5yKGUpLChmdW5jdGlvbihhKXt0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4geH0pO3ZhciBsPXQoMTIpLE09dCg2OCksVD10KDcwKSxkPXQoMjg2KSx1PXQoMjg5KSxjPXQoMjUwKSxPPXQoMjkxKSxmPXQoMjE0KSxnPXQoMjE4KSx2PXQoMjEzKTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7Y29uc3QgQz1TeW1ib2woImVudGVyZWRUYXJnZXRzIik7ZnVuY3Rpb24gcChQKXtyZXR1cm4gUC5pZD1QLmlkfHxgX2xheWVyJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLDEyKX1gLFAuZGF0YXNldHx8KFAuZGF0YXNldD17fSksUC5kYXRhc2V0LmxheWVySWQ9UC5pZCxQLmNvbm5lY3Q9KFIsYik9PntQLnBhcmVudD1SLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQLCJ6T3JkZXIiLHt2YWx1ZTpiLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfSxQLmRpc2Nvbm5lY3Q9Uj0+e2RlbGV0ZSBQLnpPcmRlcn0sUC5jYW52YXM9UCxQLmdldFJlc29sdXRpb249KCk9Pih7d2lkdGg6MCxoZWlnaHQ6MH0pLFAuc2V0UmVzb2x1dGlvbj0oKT0+ITEsUC5vcHRpb25zPXtoYW5kbGVFdmVudDohMX0sUH1mdW5jdGlvbiBoKFAsUil7Y29uc3QgYj1QLmNoaWxkcmVuO2xldCBFPW51bGw7Zm9yKGxldCBEPTA7RDxiLmxlbmd0aDtEKyspe2NvbnN0IEk9YltEXTtpZigoUj09PUl8fEUhPW51bGwpJiYoRT1JKSxFJiZFIT09UiYmIUUub2Zmc2NyZWVuKXJldHVybiBFLmNhbnZhc31yZXR1cm4gbnVsbH1mdW5jdGlvbiBtKFAsUil7Y29uc3RbYixFXT1QLnJlbmRlck9mZnNldCx7d2lkdGg6RCxoZWlnaHQ6SX09UC5nZXRSZXNvbHV0aW9uKCksUz1QLmRpc3BsYXlSYXRpbztQLnJlbmRlcmVyLmRyYXdJbWFnZShSLmNhbnZhcywtYi9TLC1FL1MsRC9TLEkvUyl9Y29uc3Qgcj17fTtmdW5jdGlvbiBpKFApe2NvbnN0IFI9WyJtb3VzZWRvd24iLCJtb3VzZXVwIiwibW91c2Vtb3ZlIiwibW91c2V3aGVlbCIsIndoZWVsIiwidG91Y2hzdGFydCIsInRvdWNoZW5kIiwidG91Y2htb3ZlIiwidG91Y2hjYW5jZWwiLCJjbGljayIsImRibGNsaWNrIiwibG9uZ3ByZXNzIiwidGFwIiwiY29udGV4dG1lbnUiXSxiPVAuY29udGFpbmVyO2IuYWRkRXZlbnRMaXN0ZW5lcigibW91c2VsZWF2ZSIsRT0+e2NvbnN0IEQ9UFtDXTtpZihELnNpemUpe2NvbnN0IEk9bmV3IGYuZGVmYXVsdCgibW91c2VsZWF2ZSIpO0kuc2V0T3JpZ2luYWxFdmVudChFKSxbLi4uRF0uZm9yRWFjaChTPT57Uy5kaXNwYXRjaEV2ZW50KEkpfSksUFtDXS5jbGVhcigpfX0se3Bhc3NpdmU6ITB9KSxSLmZvckVhY2goRT0+e2IuYWRkRXZlbnRMaXN0ZW5lcihFLEQ9Pntjb25zdHtsZWZ0OkksdG9wOlMsZGlzcGxheVJhdGlvOkF9PVAub3B0aW9ucyxVPVAub3JkZXJlZENoaWxkcmVuO09iamVjdChPLmRlZmF1bHQpKEQse29mZnNldExlZnQ6SSxvZmZzZXRUb3A6UyxkaXNwbGF5UmF0aW86QX0pLmZvckVhY2goVj0+e2NvbnN0IEo9Vi5pZGVudGlmaWVyO2lmKFYudHlwZT09PSJ0b3VjaG1vdmUifHxWLnR5cGU9PT0idG91Y2hlbmQiKXtjb25zdCBXPXJbSl07VyYmVy5kaXNwYXRjaEV2ZW50KFYpLFYudHlwZT09PSJ0b3VjaGVuZCImJmRlbGV0ZSByW0pdfWVsc2V7Zm9yKGxldCBXPVUubGVuZ3RoLTE7Vz49MDtXLS0pe2NvbnN0IEg9VVtXXTtpZihILm9wdGlvbnMuaGFuZGxlRXZlbnQhPT0hMSl7aWYoSC5kaXNwYXRjaFBvaW50ZXJFdmVudChWKSYmVi50YXJnZXQhPT1IKWJyZWFrO1YuY2FuY2VsQnViYmxlPSExfX1pZihWLnRhcmdldD09PVVbMF0pZm9yKGxldCBXPVUubGVuZ3RoLTE7Vz49MDtXLS0pe2NvbnN0IEg9VVtXXTtpZihILm9wdGlvbnMuaGFuZGxlRXZlbnQhPT0hMSl7Vi50YXJnZXQ9SDticmVha319fWNvbnN0IHE9Vi50YXJnZXQ7aWYoVi50eXBlPT09InRvdWNoc3RhcnQiJiYocltKXT1WLnRhcmdldCksVi50eXBlPT09Im1vdXNlbW92ZSIpe2NvbnN0IFc9UFtDXTtsZXQgSDtpZihxKXtjb25zdCBfPXEuYW5jZXN0b3JzfHxbXTtIPW5ldyBTZXQoW3EsLi4uX10pfWVsc2UgSD1uZXcgU2V0O2NvbnN0IFo9T2JqZWN0LmVudHJpZXMoRCk7aWYoIVcuaGFzKHEpJiZxKXtjb25zdCBfPW5ldyBmLmRlZmF1bHQoIm1vdXNlZW50ZXIiKTtfLnNldE9yaWdpbmFsRXZlbnQoRCksWi5mb3JFYWNoKChbayxjdF0pPT57X1trXT1jdH0pLFcuYWRkKHEpLHEuZGlzcGF0Y2hFdmVudChfKTtjb25zdCBzdD1xLmFuY2VzdG9ycztzdCYmc3QuZm9yRWFjaChrPT57ayBpbnN0YW5jZW9mIFQuZGVmYXVsdCYmIVcuaGFzKGspJiYoVy5hZGQoayksay5kaXNwYXRjaEV2ZW50KF8pKX0pfWNvbnN0IHR0PW5ldyBmLmRlZmF1bHQoIm1vdXNlbGVhdmUiKTt0dC5zZXRPcmlnaW5hbEV2ZW50KEQpLFouZm9yRWFjaCgoW18sc3RdKT0+e3R0W19dPXN0fSksWy4uLlddLmZvckVhY2goXz0+e0guaGFzKF8pfHwoVy5kZWxldGUoXyksXy5kaXNwYXRjaEV2ZW50KHR0KSl9KX19KX0se3Bhc3NpdmU6RSE9PSJjb250ZXh0bWVudSJ9KX0pfWZ1bmN0aW9uIG4oUCxSKXtpZihSJiZSLnN0eWxlKXtsZXR7d2lkdGg6YixoZWlnaHQ6RSxtb2RlOkQsY29udGFpbmVyOkl9PVA7Y29uc3R7Y2xpZW50V2lkdGg6UyxjbGllbnRIZWlnaHQ6QX09STtiPWJ8fFMsRT1FfHxBLEQ9PT0ic3RhdGljIj8oUi5zdHlsZS53aWR0aD1gJHtifXB4YCxSLnN0eWxlLmhlaWdodD1gJHtFfXB4YCk6KFIuc3R5bGUudG9wPSIwIixSLnN0eWxlLmxlZnQ9IjAiLFIuc3R5bGUud2lkdGg9YCR7U31weGAsUi5zdHlsZS5oZWlnaHQ9YCR7QX1weGAsUi5zdHlsZS50cmFuc2Zvcm09IiIsUi5zdHlsZS53ZWJraXRUcmFuc2Zvcm09IiIpfX1jb25zdCBzPVN5bWJvbCgib2Zmc2NyZWVuTGF5ZXJDb3VudCIpO2NsYXNzIHggZXh0ZW5kcyBjLmRlZmF1bHR7Y29uc3RydWN0b3IoUj17fSl7aWYoc3VwZXIoKSwhUi5jb250YWluZXIpaWYodHlwZW9mIGwuRU5WLkNvbnRhaW5lcj09ImZ1bmN0aW9uIilSLmNvbnRhaW5lcj1uZXcgbC5FTlYuQ29udGFpbmVyKFIud2lkdGh8fDMwMCxSLmhlaWdodHx8MTUwKTtlbHNlIHRocm93IG5ldyBFcnJvcigiTm8gY29udGFpbmVyIHNwZWNpZmllZC4iKTtpZih0aGlzLmNvbnRhaW5lcj1SLmNvbnRhaW5lcix0aGlzLmNvbnRhaW5lci5zdHlsZSYmKHRoaXMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93fHwodGhpcy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIpLHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9ufHwodGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIikpLHRoaXMub3B0aW9ucz1SLFIuZGlzcGxheVJhdGlvPVIuZGlzcGxheVJhdGlvfHwxLFIubW9kZT1SLm1vZGV8fCJzY2FsZSIsUi5sZWZ0PTAsUi50b3A9MCxSLmF1dG9SZXNpemU9Ui5hdXRvUmVzaXplIT09ITEsUi5hdXRvUmVzaXplKXtsZXQgYjtpZih0eXBlb2YgZ2xvYmFsVGhpczwidSI/Yj1nbG9iYWxUaGlzOmI9dHlwZW9mIHdpbmRvdzwidSI/d2luZG93OmEsYi5hZGRFdmVudExpc3RlbmVyKXtjb25zdCBFPXRoaXM7Yi5hZGRFdmVudExpc3RlbmVyKCJyZXNpemUiLGZ1bmN0aW9uIEQoKXt0eXBlb2YgZG9jdW1lbnQ8InUiJiZkb2N1bWVudC5jb250YWlucyhFLmNvbnRhaW5lcik/RS5yZXNpemUoKTpiLnJlbW92ZUV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsRCl9KX19dGhpc1tDXT1uZXcgU2V0LHRoaXMuc2V0UmVzb2x1dGlvbihSKSxpKHRoaXMpLHRoaXNbc109MH1nZXQgaGFzT2Zmc2NyZWVuQ2FudmFzKCl7cmV0dXJuIHRoaXNbc10+MH1zZXQgZGlzcGxheVJhdGlvKFIpe3RoaXMub3B0aW9ucy5kaXNwbGF5UmF0aW8hPT1SJiYodGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpbz1SLHRoaXMucmVzaXplKCkpfWdldCBkaXNwbGF5UmF0aW8oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmRpc3BsYXlSYXRpb31zZXQgaGVpZ2h0KFIpe3RoaXMub3B0aW9ucy5oZWlnaHQhPT1SJiYodGhpcy5vcHRpb25zLmhlaWdodD1SLHRoaXMucmVzaXplKCkpfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmhlaWdodH1zZXQgbW9kZShSKXt0aGlzLm9wdGlvbnMubW9kZSE9PVImJih0aGlzLm9wdGlvbnMubW9kZT1SLHRoaXMucmVzaXplKCkpfWdldCBtb2RlKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5tb2RlfXNldCB3aWR0aChSKXt0aGlzLm9wdGlvbnMud2lkdGghPT1SJiYodGhpcy5vcHRpb25zLndpZHRoPVIsdGhpcy5yZXNpemUoKSl9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMub3B0aW9ucy53aWR0aH1hcHBlbmRDaGlsZChSKXshKFIgaW5zdGFuY2VvZiBkLmRlZmF1bHQpJiYhKFIgaW5zdGFuY2VvZiB1LmRlZmF1bHQpJiZwKFIpO2NvbnN0IGI9c3VwZXIuYXBwZW5kQ2hpbGQoUiksRT1SLmNhbnZhcztyZXR1cm4gUi5vZmZzY3JlZW4/dGhpc1tzXSsrOnRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKEUpLG4odGhpcy5vcHRpb25zLEUpLFIuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb24oKSksYn1mb3JjZVVwZGF0ZSgpe3RoaXMuaGFzT2Zmc2NyZWVuQ2FudmFzJiYhdGhpcy5fcmVxdWVzdElEJiYodGhpcy5fcmVxdWVzdElEPU9iamVjdChNLnJlcXVlc3RBbmltYXRpb25GcmFtZSkoKCk9PntkZWxldGUgdGhpcy5fcmVxdWVzdElELHRoaXMucmVuZGVyKCl9KSl9aW5zZXJ0QmVmb3JlKFIsYil7IShSIGluc3RhbmNlb2YgZC5kZWZhdWx0KSYmIShSIGluc3RhbmNlb2YgdS5kZWZhdWx0KSYmcChSKTtjb25zdCBFPXN1cGVyLmluc2VydEJlZm9yZShSLGIpLEQ9Ui5jYW52YXM7aWYoIVIub2Zmc2NyZWVuKXtjb25zdCBJPWgodGhpcyxSKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoRCxJKX1yZXR1cm4gbih0aGlzLm9wdGlvbnMsRCksUi5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxFfWxheWVyKFI9ImRlZmF1bHQiLGI9e30pe2I9T2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMsYiksYi5pZD1SO2NvbnN0IEU9dGhpcy5vcmRlcmVkQ2hpbGRyZW47Zm9yKGxldCBTPTA7UzxFLmxlbmd0aDtTKyspaWYoRVtTXS5pZD09PVIpcmV0dXJuIEVbU107Y29uc3QgRD1iLndvcmtlcjtsZXQgSTtyZXR1cm4gRD9JPW5ldyB1LmRlZmF1bHQoYik6ST1uZXcgZC5kZWZhdWx0KGIpLHRoaXMuYXBwZW5kQ2hpbGQoSSksSX1hc3luYyBwcmVsb2FkKC4uLlIpe2NvbnN0IGI9W10sRT1bXSxEPVtdO2ZvcihsZXQgST0wO0k8Ui5sZW5ndGg7SSsrKXtjb25zdCBTPVJbSV07bGV0IEE7aWYodHlwZW9mIFM9PSJzdHJpbmciKUE9T2JqZWN0KGcubG9hZFRleHR1cmUpKFMpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShTKSlBPU9iamVjdChnLmxvYWRGcmFtZXMpKC4uLlMpO2Vsc2V7Y29uc3R7aWQ6VSxzcmM6S309UztBPU9iamVjdChnLmxvYWRUZXh0dXJlKShLLFUpfUEgaW5zdGFuY2VvZiBQcm9taXNlfHwoQT1Qcm9taXNlLnJlc29sdmUoQSkpLEUucHVzaChBLnRoZW4oVT0+e2IucHVzaChVKSxEW0ldPVU7Y29uc3QgSz1uZXcgZi5kZWZhdWx0KHt0eXBlOiJwcmVsb2FkIixkZXRhaWw6e2N1cnJlbnQ6VSxsb2FkZWQ6YixyZXNvdXJjZXM6Un19KTt0aGlzLmRpc3BhdGNoRXZlbnQoSyl9KSl9cmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKEUpLER9cmVtb3ZlQ2hpbGQoUil7Y29uc3QgYj1zdXBlci5yZW1vdmVDaGlsZChSKTtpZihiKXtSLl9wcmVwYXJlUmVuZGVyRmluaXNoZWQmJlIuX3ByZXBhcmVSZW5kZXJGaW5pc2hlZCgpO2NvbnN0IEU9Ui5jYW52YXM7RSYmRS5yZW1vdmUmJkUucmVtb3ZlKCksUi5vZmZzY3JlZW4mJnRoaXNbc10tLX1yZXR1cm4gYn1yZW5kZXIoKXtjb25zdCBSPXRoaXMub3JkZXJlZENoaWxkcmVuO2xldCBiPW51bGw7Y29uc3QgRT1bXTtmb3IobGV0IEQ9MDtEPFIubGVuZ3RoO0QrKyl7Y29uc3QgST1SW0RdLFM9RS5sZW5ndGg+MDtpZihJIGluc3RhbmNlb2YgZC5kZWZhdWx0JiYhSS5vZmZzY3JlZW4paWYoIUkuYXV0b1JlbmRlcilTJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksRS5sZW5ndGg9MCk7ZWxzZSBpZihiPUksUyl7SS5yZW5kZXJlci5jbGVhcigpO2ZvcihsZXQgQT0wO0E8RS5sZW5ndGg7QSsrKXtjb25zdCBVPUVbQV07VS5yZW5kZXIoKSxtKEksVSl9RS5sZW5ndGg9MCxJLnJlbmRlcih7Y2xlYXI6ITF9KX1lbHNlIEkucHJlcGFyZVJlbmRlciYmSS5yZW5kZXIoKTtlbHNlIEkub2Zmc2NyZWVuP2I/KEkucHJlcGFyZVJlbmRlciYmSS5yZW5kZXIoKSxtKGIsSSkpOkUucHVzaChJKTpJIGluc3RhbmNlb2YgdS5kZWZhdWx0JiZTJiYoY29uc29sZS53YXJuKCJTb21lIG9mZnNjcmVlbiBjYW52YXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuIiksRS5sZW5ndGg9MCl9fXJlcGxhY2VDaGlsZChSLGIpe2NvbnN0IEU9c3VwZXIucmVwbGFjZUNoaWxkKFIsYik7Yi5jYW52YXMucmVtb3ZlJiZiLmNhbnZhcy5yZW1vdmUoKSxiLm9mZnNjcmVlbiYmdGhpc1tzXS0tO2NvbnN0IEQ9Ui5jYW52YXM7aWYoIVIub2Zmc2NyZWVuKXtjb25zdCBJPWgodGhpcyxSKTt0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoRCxJKX1yZXR1cm4gbih0aGlzLm9wdGlvbnMsRCksUi5zZXRSZXNvbHV0aW9uKHRoaXMuZ2V0UmVzb2x1dGlvbigpKSxFfXJlc2l6ZSgpe2NvbnN0IFI9dGhpcy5vcHRpb25zO3RoaXMuY2hpbGRyZW4uZm9yRWFjaChiPT57bihSLGIuY2FudmFzKX0pLHRoaXMuc2V0UmVzb2x1dGlvbihSKSx0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6InJlc2l6ZSJ9KX1zZXRSZXNvbHV0aW9uKHt3aWR0aDpSLGhlaWdodDpifT17fSl7Y29uc3QgRT10aGlzLmNvbnRhaW5lcix7Y2xpZW50V2lkdGg6RCxjbGllbnRIZWlnaHQ6SX09RTsoUj09bnVsbHx8Yj09bnVsbCkmJihSPVI/P0QsYj1iPz9JKTtjb25zdHttb2RlOlMsZGlzcGxheVJhdGlvOkF9PXRoaXMub3B0aW9ucztpZihSKj1BLGIqPUEsdGhpcy5vcHRpb25zLmxlZnQ9MCx0aGlzLm9wdGlvbnMudG9wPTAsUz09PSJzdGlja3lIZWlnaHQifHxTPT09InN0aWNreUxlZnQifHxTPT09InN0aWNreVJpZ2h0Iil7Y29uc3QgVT1SO1I9RCpiL0ksUz09PSJzdGlja3lIZWlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9LjUqKFItVSkpLFM9PT0ic3RpY2t5UmlnaHQiJiYodGhpcy5vcHRpb25zLmxlZnQ9Ui1VKX1lbHNlIGlmKFM9PT0ic3RpY2t5V2lkdGgifHxTPT09InN0aWNreVRvcCJ8fFM9PT0ic3RpY2t5Qm90dG9tIil7Y29uc3QgVT1iO2I9SSpSL0QsUz09PSJzdGlja3lXaWR0aCImJih0aGlzLm9wdGlvbnMudG9wPS41KihiLVUpKSxTPT09InN0aWNreUJvdHRvbSImJih0aGlzLm9wdGlvbnMudG9wPWItVSl9c3VwZXIuc2V0UmVzb2x1dGlvbih7d2lkdGg6UixoZWlnaHQ6Yn0pfXNuYXBzaG90KHtvZmZzY3JlZW46Uj0hMSxsYXllcnM6Yn09e30pe2NvbnN0IEU9Uj8ic25hcHNob3RPZmZTY3JlZW5DYW52YXMiOiJzbmFwc2hvdENhbnZhcyIse3dpZHRoOkQsaGVpZ2h0Okl9PXRoaXMuZ2V0UmVzb2x1dGlvbigpO3RoaXNbRV09dGhpc1tFXXx8bC5FTlYuY3JlYXRlQ2FudmFzKEQsSSx7b2Zmc2NyZWVuOlJ9KTtjb25zdCBTPXRoaXNbRV0uZ2V0Q29udGV4dCgiMmQiKTtiPWJ8fHRoaXMub3JkZXJlZENoaWxkcmVuLHRoaXNbRV0ud2lkdGg9RCx0aGlzW0VdLmhlaWdodD1JO2ZvcihsZXQgQT0wO0E8Yi5sZW5ndGg7QSsrKXtjb25zdCBVPWJbQV07aWYoIVUub3B0aW9ucy5pZ25vcmVTbmFwc2hvdCl7VS5yZW5kZXImJlUucmVuZGVyKCk7Y29uc3QgSz1VLmNhbnZhcztLJiZLIT09VSYmUy5kcmF3SW1hZ2UoSywwLDAsRCxJKX19cmV0dXJuIHRoaXNbRV19fXR5cGVvZiBkb2N1bWVudDwidSImJih4LnByb3RvdHlwZS5sYXllcjNkPWZ1bmN0aW9uKFAsUj17fSl7Y29uc3QgYj1SLnVybHx8Imh0dHBzOi8vdW5wa2cuY29tL3Nwcml0ZS1leHRlbmQtM2QvZGlzdC9zcHJpdGUtZXh0ZW5kLTNkLm1pbi5qcyI7cmV0dXJuIG5ldyBQcm9taXNlKChFLEQpPT57Y29uc3QgST1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTtJLmFzeW5jPSExLEkuc3JjPWIsSS5vbmxvYWQ9KCk9Pnt0cnl7RSh0aGlzLmxheWVyM2QoUCxSKSl9Y2F0Y2goUyl7RChTKX19LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChJKX0pfSksdi5kZWZhdWx0LnJlZ2lzdGVyTm9kZSh4LCJzY2VuZSIpfSkuY2FsbCh0aGlzLHQoMjIpKX0sZnVuY3Rpb24oTCxlLHQpe3QucihlKSx0LmQoZSwiZGVmYXVsdCIsZnVuY3Rpb24oKXtyZXR1cm4gbH0pO3ZhciBhPXQoMjE0KTt0KDEpLmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7ZnVuY3Rpb24gbChNLHtvZmZzZXRUb3A6VD0wLG9mZnNldExlZnQ6ZD0wLGRpc3BsYXlSYXRpbzp1PTF9PXt9KXtsZXQgYyxPO2NvbnN0IGY9W10se2xlZnQ6Zyx0b3A6dix3aWR0aDpDLGhlaWdodDpwfT1NLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxoPU0udGFyZ2V0LndpZHRoLG09TS50YXJnZXQuaGVpZ2h0LHI9TS5jaGFuZ2VkVG91Y2hlc3x8W01dO2ZvcihsZXQgbj0wO248ci5sZW5ndGg7bisrKXtjb25zdCBzPXJbbl0seD1zLmlkZW50aWZpZXIse2NsaWVudFg6UCxjbGllbnRZOlJ9PXM7UCE9bnVsbCYmUiE9bnVsbCYmZi5wdXNoKHt4Ok1hdGgucm91bmQoKFB8MCktZykseTpNYXRoLnJvdW5kKChSfDApLXYpLGlkZW50aWZpZXI6eH0pfWYubGVuZ3RoPD0wJiZmLnB1c2goe3g6Yyx5Ok99KTtjb25zdCBpPVtdO3JldHVybiBmLmZvckVhY2gobj0+e24ueCE9bnVsbCYmbi55IT1udWxsJiYoYz0obi54KmgvQy1kKS91LE89KG4ueSptL3AtVCkvdSk7Y29uc3Qgcz1uZXcgYS5kZWZhdWx0KE0pO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHMse2xheWVyWDp7dmFsdWU6Yyxjb25maWd1cmFibGU6ITB9LGxheWVyWTp7dmFsdWU6Tyxjb25maWd1cmFibGU6ITB9LG9yaWdpbmFsWDp7dmFsdWU6bi54fSxvcmlnaW5hbFk6e3ZhbHVlOm4ueX0seDp7dmFsdWU6Yyxjb25maWd1cmFibGU6ITB9LHk6e3ZhbHVlOk8sY29uZmlndXJhYmxlOiEwfSxpZGVudGlmaWVyOnt2YWx1ZTpuLmlkZW50aWZpZXJ9fSksaS5wdXNoKHMpfSksaX19XSk7T3QudmVyc2lvbixPdC5BcmMsT3QuQmxvY2ssT3QuQ2xvdWQsT3QuQ29sb3IsT3QuRWxsaXBzZSxPdC5HcmFkaWVudCxPdC5Hcm91cCxPdC5MYWJlbCxPdC5MYXllcixPdC5MYXllcldvcmtlcixPdC5Ob2RlLE90LlBhcmFsbGVsO2NvbnN0IGVlPU90LlBhdGg7T3QuUG9seWxpbmUsT3QuUmVjdCxPdC5SZWd1bGFyLE90LlJpbmc7Y29uc3Qgc2U9T3QuU2NlbmU7T3QuU3ByaXRlLE90LlNwcml0ZVN2ZyxPdC5TdGFyLE90LlRyaWFuZ2xlLE90LmhlbHBlcnMsT3QuY3JlYXRlRWxlbWVudCxPdC5pc1Nwcml0ZU5vZGUsT3QucmVnaXN0ZXJOb2RlLE90LnJlcXVlc3RBbmltYXRpb25GcmFtZSxPdC5jYW5jZWxBbmltYXRpb25GcmFtZSxPdC5FTlY7Y29uc3QgYWU9e2xpbmVhcjpMPT5MLGVhc2VJblF1YWQ6TD0+TCpMLGVhc2VPdXRRdWFkOkw9PkwqKDItTCksZWFzZUluT3V0UXVhZDpMPT5MPC41PzIqTCpMOi0xKyg0LTIqTCkqTCxlYXNlSW5DdWJpYzpMPT5MKkwqTCxlYXNlT3V0Q3ViaWM6TD0+LS1MKkwqTCsxLGVhc2VJbk91dEN1YmljOkw9Pkw8LjU/NCpMKkwqTDooTC0xKSooMipMLTIpKigyKkwtMikrMSxlYXNlSW5RdWFydDpMPT5MKkwqTCpMLGVhc2VPdXRRdWFydDpMPT4xLSAtLUwqTCpMKkwsZWFzZUluT3V0UXVhcnQ6TD0+TDwuNT84KkwqTCpMKkw6MS04Ki0tTCpMKkwqTCxlYXNlSW5RdWludDpMPT5MKkwqTCpMKkwsZWFzZU91dFF1aW50Okw9PjErLS1MKkwqTCpMKkwsZWFzZUluT3V0UXVpbnQ6TD0+TDwuNT8xNipMKkwqTCpMKkw6MSsxNiotLUwqTCpMKkwqTCxlYXNlSW5TaW5lOkw9PjEtTWF0aC5jb3MoTCpNYXRoLlBJLzIpLGVhc2VPdXRTaW5lOkw9Pk1hdGguc2luKEwqTWF0aC5QSS8yKSxlYXNlSW5PdXRTaW5lOkw9Pi0oTWF0aC5jb3MoTWF0aC5QSSpMKS0xKS8yLGVhc2VJbkV4cG86TD0+TDw9MD8wOk1hdGgucG93KDIsMTAqTC0xMCksZWFzZU91dEV4cG86TD0+TD49MT8xOjEtTWF0aC5wb3coMiwtMTAqTCksZWFzZUluT3V0RXhwbzpMPT5MPD0wPzA6TD49MT8xOkw8LjU/TWF0aC5wb3coMiwyMCpMLTEwKS8yOigyLU1hdGgucG93KDIsLTIwKkwrMTApKS8yfTtjbGFzcyBndHtjb25zdHJ1Y3RvcihlPTAsdD0wLGE9MSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInoiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTphfSl9Z2V0IFhZKCl7cmV0dXJuW3RoaXMueCx0aGlzLnldfXNldHooZSl7cmV0dXJuIHRoaXMuej1lLHRoaXN9c2V0WFkoZT10aGlzLngsdD10aGlzLnkpe3JldHVybiB0aGlzLng9ZSx0aGlzLnk9dCx0aGlzfXNldChlPXRoaXMueCx0PXRoaXMueSxhPXRoaXMueil7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1hLHRoaXN9c2V0VG8oe3g6ZT0wLHk6dD0wLHo6YT0xfSl7cmV0dXJuIHRoaXMueD1lLHRoaXMueT10LHRoaXMuej1hLHRoaXN9cm90KGUpe2lmKGU9PT0wKXJldHVybiB0aGlzO2NvbnN0e3g6dCx5OmF9PXRoaXMsbD1NYXRoLnNpbihlKSxNPU1hdGguY29zKGUpO3JldHVybiB0aGlzLng9dCpNLWEqbCx0aGlzLnk9dCpsK2EqTSx0aGlzfXJvdFdpdGgoZSx0KXtpZih0PT09MClyZXR1cm4gdGhpcztjb25zdCBhPXRoaXMueC1lLngsbD10aGlzLnktZS55LE09TWF0aC5zaW4odCksVD1NYXRoLmNvcyh0KTtyZXR1cm4gdGhpcy54PWUueCsoYSpULWwqTSksdGhpcy55PWUueSsoYSpNK2wqVCksdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejphfT10aGlzO3JldHVybiBuZXcgZ3QoZSx0LGEpfXN1YihlKXtyZXR1cm4gdGhpcy54LT1lLngsdGhpcy55LT1lLnksdGhpc31zdWJYWShlLHQpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT10LHRoaXN9c3ViU2NhbGFyKGUpe3JldHVybiB0aGlzLngtPWUsdGhpcy55LT1lLHRoaXN9YWRkKGUpe3JldHVybiB0aGlzLngrPWUueCx0aGlzLnkrPWUueSx0aGlzfWFkZFhZKGUsdCl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPXQsdGhpc31hZGRTY2FsYXIoZSl7cmV0dXJuIHRoaXMueCs9ZSx0aGlzLnkrPWUsdGhpc31jbGFtcChlLHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LGUpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksZSksdCE9PXZvaWQgMCYmKHRoaXMueD1NYXRoLm1pbih0aGlzLngsdCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0KSksdGhpc31kaXYoZSl7cmV0dXJuIHRoaXMueC89ZSx0aGlzLnkvPWUsdGhpc31kaXZWKGUpe3JldHVybiB0aGlzLngvPWUueCx0aGlzLnkvPWUueSx0aGlzfW11bChlKXtyZXR1cm4gdGhpcy54Kj1lLHRoaXMueSo9ZSx0aGlzfW11bFYoZSl7cmV0dXJuIHRoaXMueCo9ZS54LHRoaXMueSo9ZS55LHRoaXN9YWJzKCl7cmV0dXJuIHRoaXMueD1NYXRoLmFicyh0aGlzLngpLHRoaXMueT1NYXRoLmFicyh0aGlzLnkpLHRoaXN9bnVkZ2UoZSx0KXtjb25zdCBhPWd0LlRhbihlLHRoaXMpO3JldHVybiB0aGlzLmFkZChhLm11bCh0KSl9bmVnKCl7cmV0dXJuIHRoaXMueCo9LTEsdGhpcy55Kj0tMSx0aGlzfWNyb3NzKGUpe3JldHVybiB0aGlzLng9dGhpcy55KmUuei10aGlzLnoqZS55LHRoaXMueT10aGlzLnoqZS54LXRoaXMueCplLnosdGhpc31kcHIoZSl7cmV0dXJuIGd0LkRwcih0aGlzLGUpfWNwcihlKXtyZXR1cm4gZ3QuQ3ByKHRoaXMsZSl9bGVuMigpe3JldHVybiBndC5MZW4yKHRoaXMpfWxlbigpe3JldHVybiBndC5MZW4odGhpcyl9cHJ5KGUpe3JldHVybiBndC5QcnkodGhpcyxlKX1wZXIoKXtjb25zdHt4OmUseTp0fT10aGlzO3JldHVybiB0aGlzLng9dCx0aGlzLnk9LWUsdGhpc311bmkoKXtyZXR1cm4gZ3QuVW5pKHRoaXMpfXRhbihlKXtyZXR1cm4gZ3QuVGFuKHRoaXMsZSl9ZGlzdChlKXtyZXR1cm4gZ3QuRGlzdCh0aGlzLGUpfWRpc3RhbmNlVG9MaW5lU2VnbWVudChlLHQpe3JldHVybiBndC5EaXN0YW5jZVRvTGluZVNlZ21lbnQoZSx0LHRoaXMpfXNsb3BlKGUpe3JldHVybiBndC5TbG9wZSh0aGlzLGUpfXNuYXBUb0dyaWQoZSl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueC9lKSplLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueS9lKSplLHRoaXN9YW5nbGUoZSl7cmV0dXJuIGd0LkFuZ2xlKHRoaXMsZSl9dG9BbmdsZSgpe3JldHVybiBndC5Ub0FuZ2xlKHRoaXMpfWxycChlLHQpe3JldHVybiB0aGlzLng9dGhpcy54KyhlLngtdGhpcy54KSp0LHRoaXMueT10aGlzLnkrKGUueS10aGlzLnkpKnQsdGhpc31lcXVhbHMoZSx0KXtyZXR1cm4gZ3QuRXF1YWxzKHRoaXMsZSx0KX1lcXVhbHNYWShlLHQpe3JldHVybiBndC5FcXVhbHNYWSh0aGlzLGUsdCl9bm9ybSgpe2NvbnN0IGU9dGhpcy5sZW4oKTtyZXR1cm4gdGhpcy54PWU9PT0wPzA6dGhpcy54L2UsdGhpcy55PWU9PT0wPzA6dGhpcy55L2UsdGhpc310b0ZpeGVkKCl7cmV0dXJuIGd0LlRvRml4ZWQodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm4gZ3QuVG9TdHJpbmcoZ3QuVG9GaXhlZCh0aGlzKSl9dG9Kc29uKCl7cmV0dXJuIGd0LlRvSnNvbih0aGlzKX10b0FycmF5KCl7cmV0dXJuIGd0LlRvQXJyYXkodGhpcyl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgZ3QoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgQWRkWFkoZSx0LGEpe3JldHVybiBuZXcgZ3QoZS54K3QsZS55K2EpfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IGd0KGUueC10LngsZS55LXQueSl9c3RhdGljIFN1YlhZKGUsdCxhKXtyZXR1cm4gbmV3IGd0KGUueC10LGUueS1hKX1zdGF0aWMgQWRkU2NhbGFyKGUsdCl7cmV0dXJuIG5ldyBndChlLngrdCxlLnkrdCl9c3RhdGljIFN1YlNjYWxhcihlLHQpe3JldHVybiBuZXcgZ3QoZS54LXQsZS55LXQpfXN0YXRpYyBEaXYoZSx0KXtyZXR1cm4gbmV3IGd0KGUueC90LGUueS90KX1zdGF0aWMgTXVsKGUsdCl7cmV0dXJuIG5ldyBndChlLngqdCxlLnkqdCl9c3RhdGljIERpdlYoZSx0KXtyZXR1cm4gbmV3IGd0KGUueC90LngsZS55L3QueSl9c3RhdGljIE11bFYoZSx0KXtyZXR1cm4gbmV3IGd0KGUueCp0LngsZS55KnQueSl9c3RhdGljIE5lZyhlKXtyZXR1cm4gbmV3IGd0KC1lLngsLWUueSl9c3RhdGljIFBlcihlKXtyZXR1cm4gbmV3IGd0KGUueSwtZS54KX1zdGF0aWMgRGlzdDIoZSx0KXtyZXR1cm4gZ3QuU3ViKGUsdCkubGVuMigpfXN0YXRpYyBBYnMoZSl7cmV0dXJuIG5ldyBndChNYXRoLmFicyhlLngpLE1hdGguYWJzKGUueSkpfXN0YXRpYyBEaXN0KGUsdCl7cmV0dXJuIE1hdGguaHlwb3QoZS55LXQueSxlLngtdC54KX1zdGF0aWMgRHByKGUsdCl7cmV0dXJuIGUueCp0LngrZS55KnQueX1zdGF0aWMgQ3Jvc3MoZSx0KXtyZXR1cm4gbmV3IGd0KGUueSp0LnotZS56KnQueSxlLnoqdC54LWUueCp0LnopfXN0YXRpYyBDcHIoZSx0KXtyZXR1cm4gZS54KnQueS10LngqZS55fXN0YXRpYyBMZW4yKGUpe3JldHVybiBlLngqZS54K2UueSplLnl9c3RhdGljIExlbihlKXtyZXR1cm4gTWF0aC5oeXBvdChlLngsZS55KX1zdGF0aWMgUHJ5KGUsdCl7cmV0dXJuIGd0LkRwcihlLHQpL2d0Lkxlbih0KX1zdGF0aWMgVW5pKGUpe3JldHVybiBndC5EaXYoZSxndC5MZW4oZSkpfXN0YXRpYyBUYW4oZSx0KXtyZXR1cm4gZ3QuVW5pKGd0LlN1YihlLHQpKX1zdGF0aWMgTWluKGUsdCl7cmV0dXJuIG5ldyBndChNYXRoLm1pbihlLngsdC54KSxNYXRoLm1pbihlLnksdC55KSl9c3RhdGljIE1heChlLHQpe3JldHVybiBuZXcgZ3QoTWF0aC5tYXgoZS54LHQueCksTWF0aC5tYXgoZS55LHQueSkpfXN0YXRpYyBGcm9tKGUpe3JldHVybiBuZXcgZ3QoKS5hZGQoZSl9c3RhdGljIEZyb21BcnJheShlKXtyZXR1cm4gbmV3IGd0KGVbMF0sZVsxXSl9c3RhdGljIFJvdChlLHQ9MCl7Y29uc3QgYT1NYXRoLnNpbih0KSxsPU1hdGguY29zKHQpO3JldHVybiBuZXcgZ3QoZS54KmwtZS55KmEsZS54KmErZS55KmwpfXN0YXRpYyBSb3RXaXRoKGUsdCxhKXtjb25zdCBsPWUueC10LngsTT1lLnktdC55LFQ9TWF0aC5zaW4oYSksZD1NYXRoLmNvcyhhKTtyZXR1cm4gbmV3IGd0KHQueCsobCpkLU0qVCksdC55KyhsKlQrTSpkKSl9c3RhdGljIE5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChlLHQsYSl7cmV0dXJuIGd0Lk11bCh0LGd0LlN1YihhLGUpLnByeSh0KSkuYWRkKGUpfXN0YXRpYyBOZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGUsdCxhLGw9ITApe2NvbnN0IE09Z3QuVGFuKHQsZSksVD1ndC5BZGQoZSxndC5NdWwoTSxndC5TdWIoYSxlKS5wcnkoTSkpKTtpZihsKXtpZihULng8TWF0aC5taW4oZS54LHQueCkpcmV0dXJuIGd0LkNhc3QoZS54PHQueD9lOnQpO2lmKFQueD5NYXRoLm1heChlLngsdC54KSlyZXR1cm4gZ3QuQ2FzdChlLng+dC54P2U6dCk7aWYoVC55PE1hdGgubWluKGUueSx0LnkpKXJldHVybiBndC5DYXN0KGUueTx0Lnk/ZTp0KTtpZihULnk+TWF0aC5tYXgoZS55LHQueSkpcmV0dXJuIGd0LkNhc3QoZS55PnQueT9lOnQpfXJldHVybiBUfXN0YXRpYyBEaXN0YW5jZVRvTGluZVRocm91Z2hQb2ludChlLHQsYSl7cmV0dXJuIGd0LkRpc3QoYSxndC5OZWFyZXN0UG9pbnRPbkxpbmVUaHJvdWdoUG9pbnQoZSx0LGEpKX1zdGF0aWMgRGlzdGFuY2VUb0xpbmVTZWdtZW50KGUsdCxhLGw9ITApe3JldHVybiBndC5EaXN0KGEsZ3QuTmVhcmVzdFBvaW50T25MaW5lU2VnbWVudChlLHQsYSxsKSl9c3RhdGljIFNuYXAoZSx0PTEpe3JldHVybiBuZXcgZ3QoTWF0aC5yb3VuZChlLngvdCkqdCxNYXRoLnJvdW5kKGUueS90KSp0KX1zdGF0aWMgQ2FzdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGd0P2U6Z3QuRnJvbShlKX1zdGF0aWMgU2xvcGUoZSx0KXtyZXR1cm4gZS54PT09dC55P05hTjooZS55LXQueSkvKGUueC10LngpfXN0YXRpYyBBbmdsZShlLHQpe3JldHVybiBNYXRoLmF0YW4yKHQueS1lLnksdC54LWUueCl9c3RhdGljIExycChlLHQsYSl7cmV0dXJuIGd0LlN1Yih0LGUpLm11bChhKS5hZGQoZSl9c3RhdGljIE1lZChlLHQpe3JldHVybiBuZXcgZ3QoKGUueCt0LngpLzIsKGUueSt0LnkpLzIpfXN0YXRpYyBFcXVhbHMoZSx0LGE9MWUtNCl7cmV0dXJuIE1hdGguYWJzKGUueC10LngpPGEmJk1hdGguYWJzKGUueS10LnkpPGF9c3RhdGljIEVxdWFsc1hZKGUsdCxhKXtyZXR1cm4gZS54PT09dCYmZS55PT09YX1zdGF0aWMgRXF1YWxzWFlaKGUsdCxhPTFlLTQpe3JldHVybiBndC5FcXVhbHMoZSx0LGEpJiZNYXRoLmFicygoZS56fHwwKS0odC56fHwwKSk8YX1zdGF0aWMgQ2xvY2t3aXNlKGUsdCxhKXtyZXR1cm4oYS54LWUueCkqKHQueS1lLnkpLSh0LngtZS54KSooYS55LWUueSk8MH1zdGF0aWMgUmVzY2FsZShlLHQpe2NvbnN0IGE9Z3QuTGVuKGUpO3JldHVybiBuZXcgZ3QodCplLngvYSx0KmUueS9hKX1zdGF0aWMgU2NhbGVXaXRoT3JpZ2luKGUsdCxhKXtyZXR1cm4gZ3QuU3ViKGUsYSkubXVsKHQpLmFkZChhKX1zdGF0aWMgVG9GaXhlZChlLHQ9Mil7cmV0dXJuIG5ldyBndCgrZS54LnRvRml4ZWQodCksK2UueS50b0ZpeGVkKHQpLCtlLnoudG9GaXhlZCh0KSl9c3RhdGljIE51ZGdlKGUsdCxhKXtyZXR1cm4gZ3QuQWRkKGUsZ3QuVGFuKHQsZSkubXVsKGEpKX1zdGF0aWMgVG9TdHJpbmcoZSl7cmV0dXJuYCR7ZS54fSwgJHtlLnl9YH1zdGF0aWMgVG9BbmdsZShlKXtsZXQgdD1NYXRoLmF0YW4yKGUueSxlLngpO3JldHVybiB0PDAmJih0Kz1NYXRoLlBJKjIpLHR9c3RhdGljIEZyb21BbmdsZShlLHQ9MSl7cmV0dXJuIG5ldyBndChNYXRoLmNvcyhlKSp0LE1hdGguc2luKGUpKnQpfXN0YXRpYyBUb0FycmF5KGUpe3JldHVybltlLngsZS55LGUuel19c3RhdGljIFRvSnNvbihlKXtjb25zdHt4OnQseTphLHo6bH09ZTtyZXR1cm57eDp0LHk6YSx6Omx9fXN0YXRpYyBBdmVyYWdlKGUpe2NvbnN0IHQ9ZS5sZW5ndGgsYT1uZXcgZ3QoMCwwKTtmb3IobGV0IGw9MDtsPHQ7bCsrKWEuYWRkKGVbbF0pO3JldHVybiBhLmRpdih0KX1zdGF0aWMgQ2xhbXAoZSx0LGEpe3JldHVybiBhPT09dm9pZCAwP25ldyBndChNYXRoLm1pbihNYXRoLm1heChlLngsdCkpLE1hdGgubWluKE1hdGgubWF4KGUueSx0KSkpOm5ldyBndChNYXRoLm1pbihNYXRoLm1heChlLngsdCksYSksTWF0aC5taW4oTWF0aC5tYXgoZS55LHQpLGEpKX1zdGF0aWMgUG9pbnRzQmV0d2VlbihlLHQsYT02KXtjb25zdCBsPVtdO2ZvcihsZXQgTT0wO008YTtNKyspe2NvbnN0IFQ9YWUuZWFzZUluUXVhZChNLyhhLTEpKSxkPWd0LkxycChlLHQsVCk7ZC56PU1hdGgubWluKDEsLjUrTWF0aC5hYnMoLjUtb2UoVCkpKi42NSksbC5wdXNoKGQpfXJldHVybiBsfXN0YXRpYyBTbmFwVG9HcmlkKGUsdD04KXtyZXR1cm4gbmV3IGd0KE1hdGgucm91bmQoZS54L3QpKnQsTWF0aC5yb3VuZChlLnkvdCkqdCl9fWNvbnN0IG9lPUw9Pkw8LjU/MipMKkw6LTErKDQtMipMKSpMO2NsYXNzIFR0IGV4dGVuZHMgZ3R7Y29uc3RydWN0b3IoZT0wLHQ9MCxhPTAsbD17eDowLHk6MH0sTT0wLFQ9MCl7c3VwZXIoZSx0LGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ6Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6YX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6TX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6VH0pfWdldCB0aW1lc3RhbXAoKXtyZXR1cm4gdGhpcy50fWdldCBwcmVzc3VyZSgpe3JldHVybiB0aGlzLnp9Z2V0IGFuZ2xlTnVtKCl7cmV0dXJuIHRoaXMuYX1nZXQgWFkoKXtyZXR1cm5bdGhpcy54LHRoaXMueV19c2V0QShlKXt0aGlzLmE9ZX1zZXRUKGUpe3RoaXMudD1lfXNldHYoZSl7cmV0dXJuIHRoaXMudj17eDplLngseTplLnl9LHRoaXN9c2V0KGU9dGhpcy54LHQ9dGhpcy55LGE9dGhpcy56LGw9dGhpcy52LE09dGhpcy50LFQ9dGhpcy5hKXtyZXR1cm4gdGhpcy54PWUsdGhpcy55PXQsdGhpcy56PWEsdGhpcy52PWwsdGhpcy50PU0sdGhpcy5hPVQsdGhpc31jbG9uZSgpe2NvbnN0e3g6ZSx5OnQsejphLHY6bCx0Ok0sYTpUfT10aGlzLGQ9e3g6bC54LHk6bC55fTtyZXR1cm4gbmV3IFR0KGUsdCxhLGQsTSxUKX1kaXN0YW5jZShlKXtyZXR1cm4gVHQuR2V0RGlzdGFuY2UodGhpcyxlKX1pc05lYXIoZSx0KXtyZXR1cm4gVHQuSXNOZWFyKHRoaXMsZSx0KX1nZXRBbmdsZUJ5UG9pbnRzKGUsdCl7cmV0dXJuIFR0LkdldEFuZ2xlQnlQb2ludHMoZSx0aGlzLHQpfXN0YXRpYyBTdWIoZSx0KXtyZXR1cm4gbmV3IFR0KGUueC10LngsZS55LXQueSl9c3RhdGljIEFkZChlLHQpe3JldHVybiBuZXcgVHQoZS54K3QueCxlLnkrdC55KX1zdGF0aWMgR2V0RGlzdGFuY2UoZSx0KXtyZXR1cm4gVHQuTGVuKGUuY2xvbmUoKS5zdWIodCkpfXN0YXRpYyBHZXRBbmdsZUJ5UG9pbnRzKGUsdCxhKXtjb25zdCBsPXQueC1lLngsTT1hLngtdC54LFQ9dC55LWUueSxkPWEueS10Lnk7bGV0IHU9MDtjb25zdCBjPU1hdGguc3FydChsKmwrVCpUKSxPPU1hdGguc3FydChNKk0rZCpkKTtpZihjJiZPKXtjb25zdCBmPWwqTStUKmQ7dT1NYXRoLmFjb3MoZi8oYypPKSksdT11L01hdGguUEkqMTgwO2xldCBnPWwqZC1UKk07Zz1nPjA/MTotMSx1PTE4MCtnKnV9cmV0dXJuIHV9c3RhdGljIElzTmVhcihlLHQsYSl7cmV0dXJuIFR0LkxlbihlLmNsb25lKCkuc3ViKHQpKTxhfXN0YXRpYyBSb3RXaXRoKGUsdCxhLGw9Mil7Y29uc3QgTT1lLngtdC54LFQ9ZS55LXQueSxkPU1hdGguc2luKGEpLHU9TWF0aC5jb3MoYSksYz1NYXRoLnBvdygxMCxsKSxPPU1hdGguZmxvb3IoKHQueCsoTSp1LVQqZCkpKmMpL2MsZj1NYXRoLmZsb29yKCh0LnkrKE0qZCtUKnUpKSpjKS9jO3JldHVybiBuZXcgVHQoTyxmKX1zdGF0aWMgR2V0RG90U3Ryb2tlKGUsdCxhPTE2KXtjb25zdCBsPW5ldyBndCgxLDEpLE09TWF0aC5QSSsuMDAxLFQ9VHQuQWRkKGUsVHQuU3ViKGUsbCkudW5pKCkucGVyKCkubXVsKC10KSksZD1bXTtmb3IobGV0IHU9MS9hLGM9dTtjPD0xO2MrPXUpZC5wdXNoKFR0LlJvdFdpdGgoVCxlLE0qMipjKSk7cmV0dXJuIGR9c3RhdGljIEdldFNlbWljaXJjbGVTdHJva2UoZSx0LGE9LTEsbD04KXtjb25zdCBNPWEqKE1hdGguUEkrLjAwMSksVD1bXTtmb3IobGV0IGQ9MS9sLHU9ZDt1PD0xO3UrPWQpVC5wdXNoKFR0LlJvdFdpdGgodCxlLE0qdSkpO3JldHVybiBUfX1mdW5jdGlvbiBYdChMLGUpe2lmKEwmJmUpe2NvbnN0IHQ9TWF0aC5taW4oTD09bnVsbD92b2lkIDA6TC54LGUueCksYT1NYXRoLm1pbihMPT1udWxsP3ZvaWQgMDpMLnksZS55KSxsPU1hdGgubWF4KEwueCtMLncsZS54K2UudyksTT1NYXRoLm1heChMLnkrTC5oLGUueStlLmgpLFQ9bC10LGQ9TS1hO3JldHVybnt4OnQseTphLHc6VCxoOmR9fXJldHVybiBlfHxMfWZ1bmN0aW9uIEh0KEwsZT0wKXtjb25zdCB0PXt4OjAseTowLHc6MCxoOjB9O2xldCBhPXQueCxsPXQueSxNPXQueCxUPXQueTtyZXR1cm4gTC5mb3JFYWNoKGQ9Pntjb25zdFt1LGNdPWQuWFk7YT1NYXRoLm1pbihhLHUtZSksbD1NYXRoLm1pbihsLGMtZSksTT1NYXRoLm1heChNLHUrZSksVD1NYXRoLm1heChULGMrZSl9KSx0Lng9YSx0Lnk9bCx0Lnc9TS1hLHQuaD1ULWwsdH1mdW5jdGlvbiB6dChMKXtyZXR1cm5gJHtRdChMLngpfSwke1F0KEwueSl9IGB9ZnVuY3Rpb24gR3QoTCxlKXtyZXR1cm5gJHtRdCgoTC54K2UueCkvMil9LCR7UXQoKEwueStlLnkpLzIpfSBgfWZ1bmN0aW9uIFF0KEwpe3JldHVybitMLnRvRml4ZWQoNCl9ZnVuY3Rpb24gSnQoTCxlPSEwKXtjb25zdCB0PUwubGVuZ3RoO2lmKHQ8MilyZXR1cm4iIjtsZXQgYT1MWzBdLGw9TFsxXTtpZih0PT09MilyZXR1cm5gTSR7enQoYSl9TCR7enQobCl9YDtsZXQgTT0iIjtmb3IobGV0IFQ9MixkPXQtMTtUPGQ7VCsrKWE9TFtUXSxsPUxbVCsxXSxNKz1HdChhLGwpO3JldHVybiBlP2BNJHtHdChMWzBdLExbMV0pfVEke3p0KExbMV0pfSR7R3QoTFsxXSxMWzJdKX1UJHtNfSR7R3QoTFt0LTFdLExbMF0pfSR7R3QoTFswXSxMWzFdKX1aYDpgTSR7enQoTFswXSl9USR7enQoTFsxXSl9JHtHdChMWzFdLExbMl0pfSR7TC5sZW5ndGg+Mz8iVCI6IiJ9JHtNfUwke3p0KExbdC0xXSl9YH12YXIgd3Q9e2V4cG9ydHM6e319O3d0LmV4cG9ydHMsZnVuY3Rpb24oTCl7dmFyIGU9ZnVuY3Rpb24oKXt2YXIgdD1TdHJpbmcuZnJvbUNoYXJDb2RlLGE9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89IixsPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSstJCIsTT17fTtmdW5jdGlvbiBUKHUsYyl7aWYoIU1bdV0pe01bdV09e307Zm9yKHZhciBPPTA7Tzx1Lmxlbmd0aDtPKyspTVt1XVt1LmNoYXJBdChPKV09T31yZXR1cm4gTVt1XVtjXX12YXIgZD17Y29tcHJlc3NUb0Jhc2U2NDpmdW5jdGlvbih1KXtpZih1PT1udWxsKXJldHVybiIiO3ZhciBjPWQuX2NvbXByZXNzKHUsNixmdW5jdGlvbihPKXtyZXR1cm4gYS5jaGFyQXQoTyl9KTtzd2l0Y2goYy5sZW5ndGglNCl7ZGVmYXVsdDpjYXNlIDA6cmV0dXJuIGM7Y2FzZSAxOnJldHVybiBjKyI9PT0iO2Nhc2UgMjpyZXR1cm4gYysiPT0iO2Nhc2UgMzpyZXR1cm4gYysiPSJ9fSxkZWNvbXByZXNzRnJvbUJhc2U2NDpmdW5jdGlvbih1KXtyZXR1cm4gdT09bnVsbD8iIjp1PT0iIj9udWxsOmQuX2RlY29tcHJlc3ModS5sZW5ndGgsMzIsZnVuY3Rpb24oYyl7cmV0dXJuIFQoYSx1LmNoYXJBdChjKSl9KX0sY29tcHJlc3NUb1VURjE2OmZ1bmN0aW9uKHUpe3JldHVybiB1PT1udWxsPyIiOmQuX2NvbXByZXNzKHUsMTUsZnVuY3Rpb24oYyl7cmV0dXJuIHQoYyszMil9KSsiICJ9LGRlY29tcHJlc3NGcm9tVVRGMTY6ZnVuY3Rpb24odSl7cmV0dXJuIHU9PW51bGw/IiI6dT09IiI/bnVsbDpkLl9kZWNvbXByZXNzKHUubGVuZ3RoLDE2Mzg0LGZ1bmN0aW9uKGMpe3JldHVybiB1LmNoYXJDb2RlQXQoYyktMzJ9KX0sY29tcHJlc3NUb1VpbnQ4QXJyYXk6ZnVuY3Rpb24odSl7Zm9yKHZhciBjPWQuY29tcHJlc3ModSksTz1uZXcgVWludDhBcnJheShjLmxlbmd0aCoyKSxmPTAsZz1jLmxlbmd0aDtmPGc7ZisrKXt2YXIgdj1jLmNoYXJDb2RlQXQoZik7T1tmKjJdPXY+Pj44LE9bZioyKzFdPXYlMjU2fXJldHVybiBPfSxkZWNvbXByZXNzRnJvbVVpbnQ4QXJyYXk6ZnVuY3Rpb24odSl7aWYodT09bnVsbClyZXR1cm4gZC5kZWNvbXByZXNzKHUpO2Zvcih2YXIgYz1uZXcgQXJyYXkodS5sZW5ndGgvMiksTz0wLGY9Yy5sZW5ndGg7TzxmO08rKyljW09dPXVbTyoyXSoyNTYrdVtPKjIrMV07dmFyIGc9W107cmV0dXJuIGMuZm9yRWFjaChmdW5jdGlvbih2KXtnLnB1c2godCh2KSl9KSxkLmRlY29tcHJlc3MoZy5qb2luKCIiKSl9LGNvbXByZXNzVG9FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKHUpe3JldHVybiB1PT1udWxsPyIiOmQuX2NvbXByZXNzKHUsNixmdW5jdGlvbihjKXtyZXR1cm4gbC5jaGFyQXQoYyl9KX0sZGVjb21wcmVzc0Zyb21FbmNvZGVkVVJJQ29tcG9uZW50OmZ1bmN0aW9uKHUpe3JldHVybiB1PT1udWxsPyIiOnU9PSIiP251bGw6KHU9dS5yZXBsYWNlKC8gL2csIisiKSxkLl9kZWNvbXByZXNzKHUubGVuZ3RoLDMyLGZ1bmN0aW9uKGMpe3JldHVybiBUKGwsdS5jaGFyQXQoYykpfSkpfSxjb21wcmVzczpmdW5jdGlvbih1KXtyZXR1cm4gZC5fY29tcHJlc3ModSwxNixmdW5jdGlvbihjKXtyZXR1cm4gdChjKX0pfSxfY29tcHJlc3M6ZnVuY3Rpb24odSxjLE8pe2lmKHU9PW51bGwpcmV0dXJuIiI7dmFyIGYsZyx2PXt9LEM9e30scD0iIixoPSIiLG09IiIscj0yLGk9MyxuPTIscz1bXSx4PTAsUD0wLFI7Zm9yKFI9MDtSPHUubGVuZ3RoO1IrPTEpaWYocD11LmNoYXJBdChSKSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodixwKXx8KHZbcF09aSsrLENbcF09ITApLGg9bStwLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2LGgpKW09aDtlbHNle2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChDLG0pKXtpZihtLmNoYXJDb2RlQXQoMCk8MjU2KXtmb3IoZj0wO2Y8bjtmKyspeD14PDwxLFA9PWMtMT8oUD0wLHMucHVzaChPKHgpKSx4PTApOlArKztmb3IoZz1tLmNoYXJDb2RlQXQoMCksZj0wO2Y8ODtmKyspeD14PDwxfGcmMSxQPT1jLTE/KFA9MCxzLnB1c2goTyh4KSkseD0wKTpQKyssZz1nPj4xfWVsc2V7Zm9yKGc9MSxmPTA7ZjxuO2YrKyl4PXg8PDF8ZyxQPT1jLTE/KFA9MCxzLnB1c2goTyh4KSkseD0wKTpQKyssZz0wO2ZvcihnPW0uY2hhckNvZGVBdCgwKSxmPTA7ZjwxNjtmKyspeD14PDwxfGcmMSxQPT1jLTE/KFA9MCxzLnB1c2goTyh4KSkseD0wKTpQKyssZz1nPj4xfXItLSxyPT0wJiYocj1NYXRoLnBvdygyLG4pLG4rKyksZGVsZXRlIENbbV19ZWxzZSBmb3IoZz12W21dLGY9MDtmPG47ZisrKXg9eDw8MXxnJjEsUD09Yy0xPyhQPTAscy5wdXNoKE8oeCkpLHg9MCk6UCsrLGc9Zz4+MTtyLS0scj09MCYmKHI9TWF0aC5wb3coMixuKSxuKyspLHZbaF09aSsrLG09U3RyaW5nKHApfWlmKG0hPT0iIil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEMsbSkpe2lmKG0uY2hhckNvZGVBdCgwKTwyNTYpe2ZvcihmPTA7ZjxuO2YrKyl4PXg8PDEsUD09Yy0xPyhQPTAscy5wdXNoKE8oeCkpLHg9MCk6UCsrO2ZvcihnPW0uY2hhckNvZGVBdCgwKSxmPTA7Zjw4O2YrKyl4PXg8PDF8ZyYxLFA9PWMtMT8oUD0wLHMucHVzaChPKHgpKSx4PTApOlArKyxnPWc+PjF9ZWxzZXtmb3IoZz0xLGY9MDtmPG47ZisrKXg9eDw8MXxnLFA9PWMtMT8oUD0wLHMucHVzaChPKHgpKSx4PTApOlArKyxnPTA7Zm9yKGc9bS5jaGFyQ29kZUF0KDApLGY9MDtmPDE2O2YrKyl4PXg8PDF8ZyYxLFA9PWMtMT8oUD0wLHMucHVzaChPKHgpKSx4PTApOlArKyxnPWc+PjF9ci0tLHI9PTAmJihyPU1hdGgucG93KDIsbiksbisrKSxkZWxldGUgQ1ttXX1lbHNlIGZvcihnPXZbbV0sZj0wO2Y8bjtmKyspeD14PDwxfGcmMSxQPT1jLTE/KFA9MCxzLnB1c2goTyh4KSkseD0wKTpQKyssZz1nPj4xO3ItLSxyPT0wJiYocj1NYXRoLnBvdygyLG4pLG4rKyl9Zm9yKGc9MixmPTA7ZjxuO2YrKyl4PXg8PDF8ZyYxLFA9PWMtMT8oUD0wLHMucHVzaChPKHgpKSx4PTApOlArKyxnPWc+PjE7Zm9yKDs7KWlmKHg9eDw8MSxQPT1jLTEpe3MucHVzaChPKHgpKTticmVha31lbHNlIFArKztyZXR1cm4gcy5qb2luKCIiKX0sZGVjb21wcmVzczpmdW5jdGlvbih1KXtyZXR1cm4gdT09bnVsbD8iIjp1PT0iIj9udWxsOmQuX2RlY29tcHJlc3ModS5sZW5ndGgsMzI3NjgsZnVuY3Rpb24oYyl7cmV0dXJuIHUuY2hhckNvZGVBdChjKX0pfSxfZGVjb21wcmVzczpmdW5jdGlvbih1LGMsTyl7dmFyIGY9W10sZz00LHY9NCxDPTMscD0iIixoPVtdLG0scixpLG4scyx4LFAsUj17dmFsOk8oMCkscG9zaXRpb246YyxpbmRleDoxfTtmb3IobT0wO208MzttKz0xKWZbbV09bTtmb3IoaT0wLHM9TWF0aC5wb3coMiwyKSx4PTE7eCE9czspbj1SLnZhbCZSLnBvc2l0aW9uLFIucG9zaXRpb24+Pj0xLFIucG9zaXRpb249PTAmJihSLnBvc2l0aW9uPWMsUi52YWw9TyhSLmluZGV4KyspKSxpfD0obj4wPzE6MCkqeCx4PDw9MTtzd2l0Y2goaSl7Y2FzZSAwOmZvcihpPTAscz1NYXRoLnBvdygyLDgpLHg9MTt4IT1zOyluPVIudmFsJlIucG9zaXRpb24sUi5wb3NpdGlvbj4+PTEsUi5wb3NpdGlvbj09MCYmKFIucG9zaXRpb249YyxSLnZhbD1PKFIuaW5kZXgrKykpLGl8PShuPjA/MTowKSp4LHg8PD0xO1A9dChpKTticmVhaztjYXNlIDE6Zm9yKGk9MCxzPU1hdGgucG93KDIsMTYpLHg9MTt4IT1zOyluPVIudmFsJlIucG9zaXRpb24sUi5wb3NpdGlvbj4+PTEsUi5wb3NpdGlvbj09MCYmKFIucG9zaXRpb249YyxSLnZhbD1PKFIuaW5kZXgrKykpLGl8PShuPjA/MTowKSp4LHg8PD0xO1A9dChpKTticmVhaztjYXNlIDI6cmV0dXJuIiJ9Zm9yKGZbM109UCxyPVAsaC5wdXNoKFApOzspe2lmKFIuaW5kZXg+dSlyZXR1cm4iIjtmb3IoaT0wLHM9TWF0aC5wb3coMixDKSx4PTE7eCE9czspbj1SLnZhbCZSLnBvc2l0aW9uLFIucG9zaXRpb24+Pj0xLFIucG9zaXRpb249PTAmJihSLnBvc2l0aW9uPWMsUi52YWw9TyhSLmluZGV4KyspKSxpfD0obj4wPzE6MCkqeCx4PDw9MTtzd2l0Y2goUD1pKXtjYXNlIDA6Zm9yKGk9MCxzPU1hdGgucG93KDIsOCkseD0xO3ghPXM7KW49Ui52YWwmUi5wb3NpdGlvbixSLnBvc2l0aW9uPj49MSxSLnBvc2l0aW9uPT0wJiYoUi5wb3NpdGlvbj1jLFIudmFsPU8oUi5pbmRleCsrKSksaXw9KG4+MD8xOjApKngseDw8PTE7Zlt2KytdPXQoaSksUD12LTEsZy0tO2JyZWFrO2Nhc2UgMTpmb3IoaT0wLHM9TWF0aC5wb3coMiwxNikseD0xO3ghPXM7KW49Ui52YWwmUi5wb3NpdGlvbixSLnBvc2l0aW9uPj49MSxSLnBvc2l0aW9uPT0wJiYoUi5wb3NpdGlvbj1jLFIudmFsPU8oUi5pbmRleCsrKSksaXw9KG4+MD8xOjApKngseDw8PTE7Zlt2KytdPXQoaSksUD12LTEsZy0tO2JyZWFrO2Nhc2UgMjpyZXR1cm4gaC5qb2luKCIiKX1pZihnPT0wJiYoZz1NYXRoLnBvdygyLEMpLEMrKyksZltQXSlwPWZbUF07ZWxzZSBpZihQPT09dilwPXIrci5jaGFyQXQoMCk7ZWxzZSByZXR1cm4gbnVsbDtoLnB1c2gocCksZlt2KytdPXIrcC5jaGFyQXQoMCksZy0tLHI9cCxnPT0wJiYoZz1NYXRoLnBvdygyLEMpLEMrKyl9fX07cmV0dXJuIGR9KCk7TCE9bnVsbD9MLmV4cG9ydHM9ZTp0eXBlb2YgYW5ndWxhcjwidSImJmFuZ3VsYXIhPW51bGwmJmFuZ3VsYXIubW9kdWxlKCJMWlN0cmluZyIsW10pLmZhY3RvcnkoIkxaU3RyaW5nIixmdW5jdGlvbigpe3JldHVybiBlfSl9KHd0KTt2YXIgbGU9d3QuZXhwb3J0cztmdW5jdGlvbiBmZShMKXtyZXR1cm4gbGUuY29tcHJlc3MoSlNPTi5zdHJpbmdpZnkoTCkpfXZhciByZTsoZnVuY3Rpb24oTCl7TFtMLnBlZGRpbmc9MF09InBlZGRpbmciLExbTC5tb3VudGVkPTFdPSJtb3VudGVkIixMW0wudXBkYXRlPTJdPSJ1cGRhdGUiLExbTC51bm1vdW50ZWQ9M109InVubW91bnRlZCJ9KShyZXx8KHJlPXt9KSk7dmFyIE50OyhmdW5jdGlvbihMKXtMW0wuTm9ybWFsPTBdPSJOb3JtYWwiLExbTC5TdHJva2U9MV09IlN0cm9rZSIsTFtMLkRvdHRlZD0yXT0iRG90dGVkIixMW0wuTG9uZ0RvdHRlZD0zXT0iTG9uZ0RvdHRlZCJ9KShOdHx8KE50PXt9KSk7Y2xhc3MgdWUgZXh0ZW5kcyBadHtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIodCxhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6YnQuUGVuY2lsfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNUaW1lc3RhbXAiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY0luZGV4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0bXBQb2ludHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJNQVhfUkVQRUFSIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MTB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidW5pVGhpY2tuZXNzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndvcmtPcHRpb25zIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy53b3JrT3B0aW9ucz1lLHRoaXMudW5pVGhpY2tuZXNzPXRoaXMuTUFYX1JFUEVBUi9lLnRoaWNrbmVzcy8xMCx0aGlzLnN5bmNUaW1lc3RhbXA9MH1jb21iaW5lQ29uc3VtZSgpe3ZhciBNO2NvbnN0IGU9KE09dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpNLnRvU3RyaW5nKCksdD10aGlzLnRyYW5zZm9ybURhdGFBbGwoKSxhPXtuYW1lOmUsY2xhc3NOYW1lOiJwZW5jaWwifTtsZXQgbDtyZXR1cm4gdC5sZW5ndGgmJihsPXRoaXMuZHJhdyh7YXR0cnM6YSx0YXNrczp0LHJlcGxhY2VJZDplLGlzRnVsbFdvcms6ITF9KSkse3JlY3Q6bCx0eXBlOkF0LkRyYXdXb3JrLGRhdGFUeXBlOmp0LkxvY2FsfX1zZXRXb3JrT3B0aW9ucyhlKXt0aGlzLndvcmtPcHRpb25zPWUsdGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCl9Y29uc3VtZShlLHQpe3ZhciBnO2lmKCgoZz1lLm9wKT09bnVsbD92b2lkIDA6Zy5sZW5ndGgpPT09MClyZXR1cm57dHlwZTpBdC5Ob25lfTtjb25zdHt3b3JrSWQ6YX09ZSx7dGFza3M6bCxlZmZlY3RzOk0sY29uc3VtZUluZGV4OlR9PXRoaXMudHJhbnNmb3JtRGF0YShlLCExKTt0aGlzLnN5bmNJbmRleD1NYXRoLm1pbih0aGlzLnN5bmNJbmRleCxUKTtjb25zdCBkPXtuYW1lOmE9PW51bGw/dm9pZCAwOmEudG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCB1LGM9ITE7Y29uc3QgTz10aGlzLnN5bmNJbmRleDt0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpLGwubGVuZ3RoJiYobFswXS50YXNrSWQtdGhpcy5zeW5jVGltZXN0YW1wPnRoaXMuc3luY1VuaXRUaW1lJiYoYz0hMCx0aGlzLnN5bmNUaW1lc3RhbXA9bFswXS50YXNrSWQsdGhpcy5zeW5jSW5kZXg9dGhpcy50bXBQb2ludHMubGVuZ3RoKSx1PXRoaXMuZHJhdyh7YXR0cnM6ZCx0YXNrczpsLGVmZmVjdHM6TSxpc0Z1bGxXb3JrOnR9KSk7Y29uc3QgZj1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMuc2xpY2UoTykuZm9yRWFjaCh2PT57Zi5wdXNoKHYueCx2Lnksdi56KX0pLHtyZWN0OnUsdHlwZTpBdC5EcmF3V29yayxkYXRhVHlwZTpqdC5Mb2NhbCx3b3JrSWQ6Yz9hOnZvaWQgMCxvcDpjP2Y6dm9pZCAwLGluZGV4OmM/TyozOnZvaWQgMH19Y29uc3VtZUFsbChlKXt2YXIgZDtpZihlKXtjb25zdHtvcDp1LHdvcmtTdGF0ZTpjfT1lO3UhPW51bGwmJnUubGVuZ3RoJiZjPT09V3QuRG9uZSYmdGhpcy53b3JrT3B0aW9ucy5zdHJva2VUeXBlPT09TnQuU3Ryb2tlJiZ0aGlzLnVwZGF0ZVRlbXBQb2ludHNXaXRoUHJlc3N1cmVXaGVuRG9uZSh1KX1jb25zdCB0PShkPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6ZC50b1N0cmluZygpLGE9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCksbD17bmFtZTp0LGNsYXNzTmFtZToicGVuY2lsIn07bGV0IE07YS5sZW5ndGgmJihNPXRoaXMuZHJhdyh7YXR0cnM6bCx0YXNrczphLHJlcGxhY2VJZDp0LGlzRnVsbFdvcms6ITB9KSk7Y29uc3QgVD1bXTtyZXR1cm4gdGhpcy50bXBQb2ludHMubWFwKHU9PntULnB1c2godS54LHUueSx1LnopfSksdGhpcy5zeW5jVGltZXN0YW1wPTAse3JlY3Q6TSx0eXBlOkF0LkZ1bGxXb3JrLGRhdGFUeXBlOmp0LkxvY2FsLHdvcmtJZDp0LG9wczpmZShUKX19Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MCx0aGlzLnN5bmNJbmRleD0wfWNvbnN1bWVTZXJ2aWNlKGUsdCl7dmFyIFQ7dGhpcy50bXBQb2ludHMubGVuZ3RoPTA7Zm9yKGxldCBkPTA7ZDxlLmxlbmd0aDtkKz0zKXtjb25zdCB1PW5ldyBUdChlW2RdLGVbZCsxXSxlW2QrMl0pO2lmKHRoaXMudG1wUG9pbnRzLmxlbmd0aD4wKXtjb25zdCBjPXRoaXMudG1wUG9pbnRzW3RoaXMudG1wUG9pbnRzLmxlbmd0aC0xXSxPPWd0LlN1Yih1LGMpLnVuaSgpO3Uuc2V0dihPKX10aGlzLnRtcFBvaW50cy5wdXNoKHUpfWNvbnN0IGE9dGhpcy50cmFuc2Zvcm1EYXRhQWxsKCksbD17bmFtZTooVD10aGlzLndvcmtJZCk9PW51bGw/dm9pZCAwOlQudG9TdHJpbmcoKSxjbGFzc05hbWU6InBlbmNpbCJ9O2xldCBNO3JldHVybiBhLmxlbmd0aCYmKE09dGhpcy5kcmF3KHthdHRyczpsLHRhc2tzOmEscmVwbGFjZUlkOnQ/dGhpcy53b3JrSWQ6dm9pZCAwLGlzRnVsbFdvcms6dH0pKSxNfXRyYW5zZm9ybURhdGFBbGwoKXtyZXR1cm4gdGhpcy5nZXRUYXNrUG9pbnRzKHRoaXMudG1wUG9pbnRzLHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKX1kcmF3KGUpe2NvbnN0e2F0dHJzOnQsdGFza3M6YSxyZXBsYWNlSWQ6bCxlZmZlY3RzOk0saXNGdWxsV29yazpUfT1lLGQ9VD90aGlzLmZ1bGxMYXllcjp0aGlzLmRyYXdMYXllcnx8dGhpcy5mdWxsTGF5ZXIse2NvbG9yOnUsc3Ryb2tlVHlwZTpjLHRoaWNrbmVzczpPLG9wYWNpdHk6Zn09dGhpcy53b3JrT3B0aW9ucztUPyhsJiZkLmdldEVsZW1lbnRzQnlOYW1lKGwrIiIpLm1hcCh2PT52LnJlbW92ZSgpKSxNIT1udWxsJiZNLnNpemUmJihNLmZvckVhY2godj0+e2NvbnN0IEM9ZC5nZXRFbGVtZW50QnlJZCh2KyIiKTtDPT1udWxsfHxDLnJlbW92ZSgpfSksTS5jbGVhcigpKSk6ZC5yZW1vdmVBbGxDaGlsZHJlbigpO2xldCBnO2ZvcihsZXQgdj0wO3Y8YS5sZW5ndGg7disrKXtjb25zdHtwb3M6Qyxwb2ludHM6cCx0YXNrSWQ6aH09YVt2XTt0LmlkPWgudG9TdHJpbmcoKTtjb25zdCBtPW5ldyBlZSx7cHM6cixyZWN0Oml9PXRoaXMuY29tcHV0RHJhd1BvaW50cyhwKTtsZXQgbjtjb25zdCBzPXAubGVuZ3RoPT09MTtjPT09TnQuU3Ryb2tlfHxzP249SnQociwhMCk6bj1KdChyLCExKSxtLmF0dHIoey4uLnQscG9zOkMsZDpuLGZpbGxDb2xvcjpjPT09TnQuU3Ryb2tlfHxzP3U6dm9pZCAwLG9wYWNpdHk6Znx8MSxsaW5lRGFzaDpjPT09TnQuRG90dGVkJiYhcz9bMSxPKjJdOmM9PT1OdC5Mb25nRG90dGVkJiYhcz9bTyxPKjJdOnZvaWQgMCxzdHJva2VDb2xvcjp1LGxpbmVDYXA6Yz09PU50LlN0cm9rZXx8cz92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6Yz09PU50LlN0cm9rZXx8cz8wOk99KSxnPVh0KGcse3g6TWF0aC5mbG9vcihpLngrQ1swXS0xMCkseTpNYXRoLmZsb29yKGkueStDWzFdLTEwKSx3Ok1hdGguZmxvb3IoaS53KzIwKSxoOk1hdGguZmxvb3IoaS5oKzIwKX0pO2NvbnN0e3ZlcnRleDp4LGZyYWdtZW50OlB9PXRoaXMud29ya09wdGlvbnM7aWYoeCYmUCl7Y29uc3QgUj1kLnJlbmRlcmVyLmNyZWF0ZVByb2dyYW0oe3ZlcnRleDp4LGZyYWdtZW50OlB9KSx7d2lkdGg6YixoZWlnaHQ6RX09ZC5nZXRSZXNvbHV0aW9uKCk7bS5zZXRVbmlmb3Jtcyh7dV90aW1lOjAsdV9yZXNvbHV0aW9uOltiLEVdfSksbS5zZXRQcm9ncmFtKFIpfSFUJiZ0aGlzLmRyYXdMYXllciYmUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e3RoaXMuZnVsbExheWVyLmFwcGVuZENoaWxkKG0uY2xvbmVOb2RlKCkpfSksZC5hcHBlbmRDaGlsZChtKX1yZXR1cm4gZ31jb21wdXREcmF3UG9pbnRzKGUpe3JldHVybiB0aGlzLndvcmtPcHRpb25zLnN0cm9rZVR5cGU9PT1OdC5TdHJva2V8fGUubGVuZ3RoPT09MT90aGlzLmNvbXB1dFN0cm9rZShlKTp0aGlzLmNvbXB1dE5vbWFsKGUpfWNvbXB1dE5vbWFsKGUpe2NvbnN0IHQ9ZS5tYXAoYT0+YS5wb2ludCk7cmV0dXJue3BzOnQscmVjdDpIdCh0LHRoaXMud29ya09wdGlvbnMudGhpY2tuZXNzKX19Y29tcHV0U3Ryb2tlKGUpe3JldHVybiBlLmxlbmd0aD09PTE/dGhpcy5jb21wdXREb3RTdHJva2UoZVswXSk6dGhpcy5jb21wdXRMaW5lU3Ryb2tlKGUpfWNvbXB1dExpbmVTdHJva2UoZSl7Y29uc3QgdD1bXSxhPVtdO2ZvcihsZXQgdT0wO3U8ZS5sZW5ndGg7dSsrKXtjb25zdHtwb2ludDpjLHJhZGl1czpPfT1lW3VdO2xldCBmPWMudjt1PT09MCYmZS5sZW5ndGg+MSYmKGY9ZVt1KzFdLnBvaW50LnYpO2NvbnN0IGc9Z3QuUGVyKGYpLm11bChPKTt0LnB1c2goVHQuU3ViKGMsZykpLGEucHVzaChUdC5BZGQoYyxnKSl9Y29uc3QgbD1lW2UubGVuZ3RoLTFdLE09VHQuR2V0U2VtaWNpcmNsZVN0cm9rZShsLnBvaW50LHRbdC5sZW5ndGgtMV0sLTEsOCksVD1UdC5HZXRTZW1pY2lyY2xlU3Ryb2tlKGVbMF0ucG9pbnQsYVswXSwtMSw4KSxkPXQuY29uY2F0KE0sYS5yZXZlcnNlKCksVCk7cmV0dXJue3BzOmQscmVjdDpIdChkKX19Y29tcHV0RG90U3Ryb2tlKGUpe2NvbnN0e3BvaW50OnQscmFkaXVzOmF9PWUsbD17eDp0LngtYSx5OnQueS1hLHc6YSoyLGg6YSoyfTtyZXR1cm57cHM6VHQuR2V0RG90U3Ryb2tlKHQsYSw4KSxyZWN0Omx9fXRyYW5zZm9ybURhdGEoZSx0KXtjb25zdHtvcDphLHdvcmtTdGF0ZTpsfT1lO2xldCBNPXRoaXMudG1wUG9pbnRzLmxlbmd0aC0xLFQ9W107aWYoYSE9bnVsbCYmYS5sZW5ndGgmJmwpe2NvbnN0e3N0cm9rZVR5cGU6ZCx0aGlja25lc3M6dX09dGhpcy53b3JrT3B0aW9ucyxjPW5ldyBTZXQ7TT1kPT09TnQuU3Ryb2tlP3RoaXMudXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZShhLHUsYyk6dGhpcy51cGRhdGVUZW1wUG9pbnRzKGEsdSxjKTtjb25zdCBPPXQ/dGhpcy50bXBQb2ludHM6dGhpcy50bXBQb2ludHMuc2xpY2UoTSk7cmV0dXJuIFQ9dGhpcy5nZXRUYXNrUG9pbnRzKE8sdSkse3Rhc2tzOlQsZWZmZWN0czpjLGNvbnN1bWVJbmRleDpNfX1yZXR1cm57dGFza3M6VCxjb25zdW1lSW5kZXg6TX19Y29tcHV0UmFkaXVzKGUsdCl7cmV0dXJuIGUqLjMrdCouNX1nZXRUYXNrUG9pbnRzKGUsdCl7dmFyIE87Y29uc3QgYT1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IGw9MCxNPWVbMF0ueCxUPWVbMF0ueSxkPVtNLFRdLHU9W10sYz1lWzBdLnQ7Zm9yKDtsPGUubGVuZ3RoOyl7Y29uc3QgZj1lW2xdLGc9Zi54LU0sdj1mLnktVCxDPWYueixwPXRoaXMuY29tcHV0UmFkaXVzKEMsdCk7aWYodS5wdXNoKHtwb2ludDpuZXcgVHQoZyx2LEMsZVtsXS52KSxyYWRpdXM6cH0pLGw+MCYmbDxlLmxlbmd0aC0xKXtjb25zdCBoPWVbbF0uZ2V0QW5nbGVCeVBvaW50cyhlW2wtMV0sZVtsKzFdKTtpZihoPDkwfHxoPjI3MCl7Y29uc3QgbT0oTz11LnBvcCgpKT09bnVsbD92b2lkIDA6Ty5wb2ludC5jbG9uZSgpO20mJmEucHVzaCh7dGFza0lkOmMscG9zOmQscG9pbnRzOlsuLi51LHtwb2ludDptLHJhZGl1czpwfV19KSxNPWVbbF0ueCxUPWVbbF0ueSxkPVtNLFRdO2NvbnN0IHI9Zi54LU0saT1mLnktVDt1PVt7cG9pbnQ6bmV3IFR0KHIsaSxDKSxyYWRpdXM6cH1dLGM9RGF0ZS5ub3coKX19bCsrfXJldHVybiBhLnB1c2goe3Rhc2tJZDpjLHBvczpkLHBvaW50czp1fSksYX11cGRhdGVUZW1wUG9pbnRzV2l0aFByZXNzdXJlKGUsdCxhKXtjb25zdCBsPURhdGUubm93KCksTT10aGlzLnRtcFBvaW50cy5sZW5ndGg7bGV0IFQ9TTtmb3IobGV0IHU9MDt1PGUubGVuZ3RoO3UrPTIpe1Q9TWF0aC5taW4oVCxNKTtjb25zdCBjPXRoaXMudG1wUG9pbnRzLmxlbmd0aCxPPW5ldyBUdChlW3VdLGVbdSsxXSk7aWYoYz09PTApe3RoaXMudG1wUG9pbnRzLnB1c2goTyk7Y29udGludWV9Y29uc3QgZj1jLTEsZz10aGlzLnRtcFBvaW50c1tmXSx2PWd0LlN1YihPLGcpLnVuaSgpO2lmKE8uaXNOZWFyKGcsdCkpe2lmKGcuejx0aGlzLk1BWF9SRVBFQVIpe2lmKGcuc2V0eihNYXRoLm1pbihnLnorMSx0aGlzLk1BWF9SRVBFQVIpKSxUPU1hdGgubWluKFQsZiksYz4xKXtsZXQgaD1jLTE7Zm9yKDtoPjA7KXtjb25zdCBtPXRoaXMudG1wUG9pbnRzW2hdLmRpc3RhbmNlKHRoaXMudG1wUG9pbnRzW2gtMV0pLHI9TWF0aC5tYXgodGhpcy50bXBQb2ludHNbaF0uei10aGlzLnVuaVRoaWNrbmVzcyptLDApO2lmKHRoaXMudG1wUG9pbnRzW2gtMV0uej49cilicmVhazt0aGlzLnRtcFBvaW50c1toLTFdLnNldHoociksVD1NYXRoLm1pbihULGgtMSksaC0tfX19ZWxzZSBUPTEvMDtjb250aW51ZX1PLnNldHYodik7Y29uc3QgQz1PLmRpc3RhbmNlKGcpLHA9TWF0aC5tYXgoZy56LXRoaXMudW5pVGhpY2tuZXNzKkMsMCk7Yz4xJiZndC5FcXVhbHModixnLnYsLjAyKSYmKHA+MHx8Zy56PD0wKSYmKGEmJmcudCYmYS5hZGQoZy50KSx0aGlzLnRtcFBvaW50cy5wb3AoKSxUPU1hdGgubWluKGYsVCkpLE8uc2V0eihwKSx0aGlzLnRtcFBvaW50cy5wdXNoKE8pfWlmKFQ9PT0xLzApcmV0dXJuIHRoaXMudG1wUG9pbnRzLmxlbmd0aDtsZXQgZD1NO2lmKFQ9PT1NKXtkPU1hdGgubWF4KGQtMSwwKTtjb25zdCB1PXRoaXMudG1wUG9pbnRzW2RdLnQ7dSYmKGE9PW51bGx8fGEuYWRkKHUpKX1lbHNle2xldCB1PU0tMTtmb3IoZD1UO3U+PTA7KXtjb25zdCBjPXRoaXMudG1wUG9pbnRzW3VdLnQ7aWYoYyYmKGE9PW51bGx8fGEuYWRkKGMpLHU8PVQpKXtkPXUsdT0tMTticmVha311LS19fXJldHVybiB0aGlzLnRtcFBvaW50c1tkXS5zZXRUKGwpLGR9dXBkYXRlVGVtcFBvaW50cyhlLHQsYSl7dmFyIHU7Y29uc3QgbD1EYXRlLm5vdygpLE09dGhpcy50bXBQb2ludHMubGVuZ3RoO2xldCBUPU07Zm9yKGxldCBjPTA7YzxlLmxlbmd0aDtjKz0yKXtjb25zdCBPPXRoaXMudG1wUG9pbnRzLmxlbmd0aCxmPW5ldyBUdChlW2NdLGVbYysxXSk7aWYoTz09PTApe3RoaXMudG1wUG9pbnRzLnB1c2goZik7Y29udGludWV9Y29uc3QgZz1PLTEsdj10aGlzLnRtcFBvaW50c1tnXSxDPWd0LlN1YihmLHYpLnVuaSgpO2lmKGd0LkVxdWFscyhDLHYudiwuMDIpKXthJiZ2LnQmJmEuYWRkKHYudCksdGhpcy50bXBQb2ludHMucG9wKCksVD1NYXRoLm1pbihnLFQpO2NvbnRpbnVlfWlmKGYuaXNOZWFyKHYsdC8yKSl7VD1NYXRoLm1pbihnLFQpO2NvbnRpbnVlfWYuc2V0dihDKSx0aGlzLnRtcFBvaW50cy5wdXNoKGYpfWxldCBkPU07aWYoVD09PU0pe2Q9TWF0aC5tYXgoZC0xLDApO2NvbnN0IGM9dGhpcy50bXBQb2ludHNbZF0udDtjJiYoYT09bnVsbHx8YS5hZGQoYykpfWVsc2V7bGV0IGM9TWF0aC5taW4oTS0xLFQpO2ZvcihkPVQ7Yz49MDspe2NvbnN0IE89KHU9dGhpcy50bXBQb2ludHNbY10pPT1udWxsP3ZvaWQgMDp1LnQ7aWYoTyYmKGE9PW51bGx8fGEuYWRkKE8pLGM8PVQpKXtkPWMsYz0tMTticmVha31jLS19fXJldHVybiB0aGlzLnRtcFBvaW50c1tkXS5zZXRUKGwpLGR9dXBkYXRlVGVtcFBvaW50c1dpdGhQcmVzc3VyZVdoZW5Eb25lKGUpe2NvbnN0e3RoaWNrbmVzczp0fT10aGlzLndvcmtPcHRpb25zO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7YSs9Mil7Y29uc3QgbD10aGlzLnRtcFBvaW50cy5sZW5ndGgsTT1uZXcgVHQoZVthXSxlW2ErMV0pO2lmKGw9PT0wKXt0aGlzLnRtcFBvaW50cy5wdXNoKE0pO2NvbnRpbnVlfWNvbnN0IFQ9bC0xLGQ9dGhpcy50bXBQb2ludHNbVF0sdT1ndC5TdWIoTSxkKS51bmkoKTtpZihNLmlzTmVhcihkLHQvMikpe2lmKGQuejx0aGlzLk1BWF9SRVBFQVImJihkLnNldHooTWF0aC5taW4oZC56KzEsdGhpcy5NQVhfUkVQRUFSKSksbD4xKSl7bGV0IGY9bC0xO2Zvcig7Zj4wOyl7Y29uc3QgZz10aGlzLnRtcFBvaW50c1tmXS5kaXN0YW5jZSh0aGlzLnRtcFBvaW50c1tmLTFdKSx2PU1hdGgubWF4KHRoaXMudG1wUG9pbnRzW2ZdLnotdGhpcy51bmlUaGlja25lc3MqZywwKTtpZih0aGlzLnRtcFBvaW50c1tmLTFdLno+PXYpYnJlYWs7dGhpcy50bXBQb2ludHNbZi0xXS5zZXR6KHYpLGYtLX19Y29udGludWV9TS5zZXR2KHUpO2NvbnN0IGM9TS5kaXN0YW5jZShkKSxPPU1hdGgubWF4KGQuei10aGlzLnVuaVRoaWNrbmVzcypjLC10aGlzLk1BWF9SRVBFQVIvNSk7bD4xJiZndC5FcXVhbHModSxkLnYsLjAyKSYmZC56PD0wJiZ0aGlzLnRtcFBvaW50cy5wb3AoKSxNLnNldHooTyksdGhpcy50bXBQb2ludHMucHVzaChNKX19fWNsYXNzIGNlIGV4dGVuZHMgWnR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcih0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3luY1RpbWVzdGFtcCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b29sc1R5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpidC5FcmFzZXJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicmVtb3ZlSWRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tYmluZUNvbnN1bWUoKXt9Y29uc3VtZVNlcnZpY2UoKXt9c2V0V29ya09wdGlvbnMoZSl7dGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbnN1bWUoZSl7Y29uc3R7b3A6dH09ZTtpZighdHx8dC5sZW5ndGg9PT0wKXJldHVybnt0eXBlOkF0Lk5vbmV9O2NvbnN0e3JlY3Q6YSxyZW1vdmVJZHM6bH09dGhpcy5yZW1vdmUodCk7cmV0dXJuIGEmJmwubGVuZ3RoP3t0eXBlOkF0LlJlbW92ZU5vZGUsZGF0YVR5cGU6anQuTG9jYWwscmVjdDphLHJlbW92ZUlkczpsfTp7dHlwZTpBdC5Ob25lfX1yZW1vdmUoZSl7Y29uc3R7aXNMaW5lOnR9PXRoaXMud29ya09wdGlvbnM7bGV0IGE7Y29uc3QgbD1bXTtmb3IobGV0IE09MDtNPGUubGVuZ3RoO00rPTIpe2NvbnN0IFQ9ZVtNXSxkPWVbTSsxXTt0aGlzLmZ1bGxMYXllci5jaGlsZHJlbi5mb3JFYWNoKHU9Pnt1LmlzUG9pbnRDb2xsaXNpb24oVCxkKSYmKHRoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHUubmFtZSkuZm9yRWFjaChjPT57Y29uc3QgTz1jPT1udWxsP3ZvaWQgMDpjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO08mJihhPVh0KGEse3g6Ty54LTEwLHk6Ty55LTEwLHc6Ty53aWR0aCsyMCxoOk8uaGVpZ2h0KzIwfSkpLGMucmVtb3ZlKCl9KSx0JiYobC5wdXNoKHUubmFtZSksdGhpcy5yZW1vdmVJZHMucHVzaCh1Lm5hbWUpKSl9KX1yZXR1cm57cmVjdDphLHJlbW92ZUlkczpsfX1jb25zdW1lQWxsKGUpe3JldHVybiB0aGlzLmNvbnN1bWUoZSl9Y2xlYXJUbXBQb2ludHMoKXt0aGlzLnRtcFBvaW50cy5sZW5ndGg9MCx0aGlzLnN5bmNUaW1lc3RhbXA9MH19Y2xhc3MgaGUgZXh0ZW5kcyBadHtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzeW5jVGltZXN0YW1wIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN5bmNJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG9vbHNUeXBlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6YnQuTGFzZXJQZW59KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wUG9pbnRzIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6W119KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya09wdGlvbnMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSx0aGlzLndvcmtPcHRpb25zPWUsdGhpcy5zeW5jVGltZXN0YW1wPTB9Y29tYmluZUNvbnN1bWUoKXt9c2V0V29ya09wdGlvbnMoZSl7dGhpcy53b3JrT3B0aW9ucz1lLHRoaXMuc3luY1RpbWVzdGFtcD1EYXRlLm5vdygpfWNvbnN1bWUoZSx0KXtjb25zdHt3b3JrSWQ6YSxvcDpsfT1lO2lmKChsPT1udWxsP3ZvaWQgMDpsLmxlbmd0aCk9PT0wKXJldHVybnt0eXBlOkF0Lk5vbmV9O2NvbnN0IE09TWF0aC5tYXgoMCx0aGlzLnRtcFBvaW50cy5sZW5ndGgtMSksVD10aGlzLnRtcFBvaW50cy5sZW5ndGg7aWYodGhpcy51cGRhdGVUZW1wUG9pbnRzKGx8fFtdKSxUPT09dGhpcy50bXBQb2ludHMubGVuZ3RoKXJldHVybnt0eXBlOkF0Lk5vbmV9O2NvbnN0e2NvbG9yOmQsdGhpY2tuZXNzOnUsc3Ryb2tlVHlwZTpjLG9wYWNpdHk6T309dGhpcy53b3JrT3B0aW9ucztsZXQgZixnPSExO2NvbnN0IHY9dGhpcy5zeW5jSW5kZXg7bGV0IEM9dGhpcy50bXBQb2ludHMuc2xpY2UoTSk7Y29uc3QgcD1DLmxlbmd0aD09PTE7aWYocCl7Y29uc3QgaT10aGlzLmNvbXB1dERvdFN0cm9rZSh7cG9pbnQ6Q1swXSxyYWRpdXM6dS8yfSk7Qz1pLnBzLGY9aS5yZWN0fWVsc2UgZj1IdCh0aGlzLnRtcFBvaW50cyx1KTt0aGlzLnN5bmNUaW1lc3RhbXA9PT0wJiYodGhpcy5zeW5jVGltZXN0YW1wPURhdGUubm93KCkpO2NvbnN0IGg9e25hbWU6YT09bnVsbD92b2lkIDA6YS50b1N0cmluZygpLGNsYXNzTmFtZToiTGFzZXJQZW4iLGZpbGxDb2xvcjpwP2Q6dm9pZCAwLG9wYWNpdHk6T3x8MSxsaW5lRGFzaDpjPT09TnQuRG90dGVkJiYhcD9bMSx1KjJdOmM9PT1OdC5Mb25nRG90dGVkJiYhcD9bdSx1KjJdOnZvaWQgMCxzdHJva2VDb2xvcjpkLGxpbmVDYXA6cD92b2lkIDA6InJvdW5kIixsaW5lV2lkdGg6cD8wOnUsYW5jaG9yOlsuNSwuNV19LG09dGhpcy5nZXRUYXNrUG9pbnRzKEMpO2lmKG0ubGVuZ3RoKXtjb25zdCBpPURhdGUubm93KCk7aS10aGlzLnN5bmNUaW1lc3RhbXA+dGhpcy5zeW5jVW5pdFRpbWUmJihnPSEwLHRoaXMuc3luY1RpbWVzdGFtcD1pLHRoaXMuc3luY0luZGV4PXRoaXMudG1wUG9pbnRzLmxlbmd0aCksIXQmJnRoaXMuZHJhdyh7YXR0cnM6aCx0YXNrczptLGlzRG90OnB9KX1jb25zdCByPVtdO3JldHVybiB0aGlzLnRtcFBvaW50cy5zbGljZSh2KS5mb3JFYWNoKGk9PntyLnB1c2goaS54LGkueSl9KSx7cmVjdDpmLHR5cGU6QXQuRHJhd1dvcmssZGF0YVR5cGU6anQuTG9jYWwsd29ya0lkOmc/YTp2b2lkIDAsb3A6Zz9yOnZvaWQgMCxpbmRleDpnP3YqMjp2b2lkIDB9fWNvbnN1bWVBbGwoKXt2YXIgYTtjb25zdCBlPShhPXRoaXMud29ya0lkKT09bnVsbD92b2lkIDA6YS50b1N0cmluZygpLHQ9W107cmV0dXJuIHRoaXMudG1wUG9pbnRzLnNsaWNlKHRoaXMuc3luY0luZGV4KS5mb3JFYWNoKGw9Pnt0LnB1c2gobC54LGwueSl9KSx7dHlwZTpBdC5EcmF3V29yayxkYXRhVHlwZTpqdC5Mb2NhbCx3b3JrSWQ6ZSxvcDp0LGluZGV4OnRoaXMuc3luY0luZGV4KjJ9fWNsZWFyVG1wUG9pbnRzKCl7dGhpcy50bXBQb2ludHMubGVuZ3RoPTAsdGhpcy5zeW5jVGltZXN0YW1wPTAsdGhpcy5zeW5jSW5kZXg9MH1jb25zdW1lU2VydmljZShlKXt2YXIgZztjb25zdHtjb2xvcjp0LHRoaWNrbmVzczphLHN0cm9rZVR5cGU6bCxvcGFjaXR5Ok19PXRoaXMud29ya09wdGlvbnM7aWYoIWUubGVuZ3RoKXJldHVybiBIdCh0aGlzLnRtcFBvaW50cyxhKTtjb25zdCBUPU1hdGgubWF4KDAsdGhpcy50bXBQb2ludHMubGVuZ3RoLTEpO3RoaXMudXBkYXRlVGVtcFBvaW50cyhlfHxbXSk7bGV0IGQsdT10aGlzLnRtcFBvaW50cy5zbGljZShUKTtjb25zdCBjPXUubGVuZ3RoPT09MTtpZihjKXtjb25zdCB2PXRoaXMuY29tcHV0RG90U3Ryb2tlKHtwb2ludDp1WzBdLHJhZGl1czphLzJ9KTt1PXYucHMsZD12LnJlY3R9ZWxzZSBkPUh0KHRoaXMudG1wUG9pbnRzLGEpO2NvbnN0IE89e25hbWU6KGc9dGhpcy53b3JrSWQpPT1udWxsP3ZvaWQgMDpnLnRvU3RyaW5nKCksY2xhc3NOYW1lOiJMYXNlclBlbiIsZmlsbENvbG9yOmM/dDp2b2lkIDAsb3BhY2l0eTpNfHwxLGxpbmVEYXNoOmw9PT1OdC5Eb3R0ZWQmJiFjP1sxLGEqMl06bD09PU50LkxvbmdEb3R0ZWQmJiFjP1thLGEqMl06dm9pZCAwLHN0cm9rZUNvbG9yOnQsbGluZUNhcDpjP3ZvaWQgMDoicm91bmQiLGxpbmVXaWR0aDpjPzA6YSxhbmNob3I6Wy41LC41XX0sZj10aGlzLmdldFRhc2tQb2ludHModSk7cmV0dXJuIGYubGVuZ3RoJiZ0aGlzLmRyYXcoe2F0dHJzOk8sdGFza3M6Zixpc0RvdDpjfSksZH1jb21wdXREb3RTdHJva2UoZSl7Y29uc3R7cG9pbnQ6dCxyYWRpdXM6YX09ZSxsPXt4OnQueC1hLHk6dC55LWEsdzphKjIsaDphKjJ9O3JldHVybntwczpUdC5HZXREb3RTdHJva2UodCxhLDgpLHJlY3Q6bH19dXBkYXRlVGVtcFBvaW50cyhlKXtjb25zdCB0PXRoaXMudG1wUG9pbnRzLmxlbmd0aDtmb3IobGV0IGE9MDthPGUubGVuZ3RoO2ErPTIpe2lmKHQpe2NvbnN0IGw9dGhpcy50bXBQb2ludHMuc2xpY2UoLTEpWzBdO2wmJmwueD09PWVbYV0mJmwueT09PWVbYSsxXSYmdGhpcy50bXBQb2ludHMucG9wKCl9dGhpcy50bXBQb2ludHMucHVzaChuZXcgVHQoZVthXSxlW2ErMV0pKX19YXN5bmMgZHJhdyhlKXtjb25zdHthdHRyczp0LHRhc2tzOmEsaXNEb3Q6bH09ZSxNPXRoaXMuZnVsbExheWVyLHtkdXJhdGlvbjpUfT10aGlzLndvcmtPcHRpb25zLGQ9bmV3IGVlO2ZvcihsZXQgdT0wO3U8YS5sZW5ndGg7dSsrKXtjb25zdHtwb3M6Yyxwb2ludHM6T309YVt1XTtsZXQgZjtsP2Y9SnQoTywhMCk6Zj1KdChPLCExKSxkLmF0dHIoey4uLnQscG9zOmMsZDpmfSk7Y29uc3R7dmVydGV4OmcsZnJhZ21lbnQ6dn09dGhpcy53b3JrT3B0aW9ucztpZihnJiZ2KXtjb25zdCBDPU0ucmVuZGVyZXIuY3JlYXRlUHJvZ3JhbSh7dmVydGV4OmcsZnJhZ21lbnQ6dn0pLHt3aWR0aDpwLGhlaWdodDpofT1NLmdldFJlc29sdXRpb24oKTtkLnNldFVuaWZvcm1zKHt1X3RpbWU6MCx1X3Jlc29sdXRpb246W3AsaF19KSxkLnNldFByb2dyYW0oQyl9TS5hcHBlbmRDaGlsZChkKSxhd2FpdCBkLnRyYW5zaXRpb24oVCkuYXR0cih7c2NhbGU6bD9bLjEsLjFdOlsxLDFdLGxpbmVXaWR0aDpsPzA6MX0pLGQucmVtb3ZlKCl9fWdldFRhc2tQb2ludHMoZSl7dmFyIHU7Y29uc3QgdD1bXTtpZihlLmxlbmd0aD09PTApcmV0dXJuW107bGV0IGE9MCxsPWVbMF0ueCxNPWVbMF0ueSxUPVtsLE1dLGQ9W107Zm9yKDthPGUubGVuZ3RoOyl7Y29uc3QgYz1lW2FdLE89Yy54LWwsZj1jLnktTTtpZihkLnB1c2gobmV3IFR0KE8sZikpLGE+MCYmYTxlLmxlbmd0aC0xKXtjb25zdCBnPWVbYV0uZ2V0QW5nbGVCeVBvaW50cyhlW2EtMV0sZVthKzFdKTtpZihnPDkwfHxnPjI3MCl7Y29uc3Qgdj0odT1kLnBvcCgpKT09bnVsbD92b2lkIDA6dS5jbG9uZSgpO3YmJnQucHVzaCh7cG9zOlQscG9pbnRzOlsuLi5kLHZdfSksbD1lW2FdLngsTT1lW2FdLnksVD1bbCxNXTtjb25zdCBDPWMueC1sLHA9Yy55LU07ZD1bbmV3IFR0KEMscCldfX1hKyt9cmV0dXJuIHQucHVzaCh7cG9zOlQscG9pbnRzOmR9KSx0fX1jbGFzcyBkZXtjb25zdHJ1Y3Rvcigpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0cmFuc2xhdGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpbMCwwXX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY2FsZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOjF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHVzdGJpbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBTZXR9KX11cGRhdGVTY2VuZShlKXt0aGlzLnNjZW5lLmF0dHIoey4uLmUsYnVmZmVyU2l6ZToxZTR9KX11cGRhdGVMYXllcihlKXt0aGlzLmZ1bGxMYXllci5hdHRyKHsuLi5lLGJ1ZmZlclNpemU6NWUzfSksdGhpcy5kcmF3TGF5ZXIuYXR0cihlKX1jcmVhdGVTY2VuZShlKXtjb25zdHt3aWR0aDp0LGhlaWdodDphfT1lLGw9bmV3IE9mZnNjcmVlbkNhbnZhcyh0LGEpO3JldHVybiBuZXcgc2Uoe2NvbnRhaW5lcjpsLGRpc3BsYXlSYXRpbzp0aGlzLmRwcixkZXB0aDohMSxkZXN5bmNocm9uaXplZDohMCwuLi5lfSl9Y3JlYXRlTGF5ZXIoZSl7Y29uc3QgdD0ib2Zmc2NyZWVuIitEYXRlLm5vdygpO3JldHVybiB0aGlzLnNjZW5lLmxheWVyKHQsZSl9c2V0VHJhbnNsYXRlKGUpe3RoaXMudHJhbnNsYXRlPWV9c2V0U2NhbGUoZSl7dGhpcy5zY2FsZT1lfWdldE5vZGVzKGUpe3JldHVybiB0aGlzLmZ1bGxMYXllci5nZXRFbGVtZW50c0J5TmFtZShlKyIiKS5jb25jYXQodGhpcy5kcmF3TGF5ZXIuZ2V0RWxlbWVudHNCeU5hbWUoZSsiIikpfX1jbGFzcyBnZXtjb25zdHJ1Y3RvcihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmdWxsTGF5ZXIiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZHJhd0xheWVyIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRtcFdvcmtTaGFwZU5vZGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidG1wT3B0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksdGhpcy5mdWxsTGF5ZXI9ZSx0aGlzLmRyYXdMYXllcj10fWdldFdvcmtTaGFwZShlKXtyZXR1cm4gdGhpcy53b3JrU2hhcGVzLmdldChlKX1nZXRUbXBXb3JrU2hhcGVOb2RlKCl7cmV0dXJuIHRoaXMudG1wV29ya1NoYXBlTm9kZX1zZXRUbXBXb3JrSWQoZSl7aWYoZSYmdGhpcy50bXBXb3JrU2hhcGVOb2RlKXt0aGlzLnRtcFdvcmtTaGFwZU5vZGUuc2V0V29ya0lkKGUpLHRoaXMud29ya1NoYXBlcy5zZXQoZSx0aGlzLnRtcFdvcmtTaGFwZU5vZGUpLHRoaXMudG1wT3B0JiZ0aGlzLnNldFRvb2xzT3B0KHRoaXMudG1wT3B0KTtyZXR1cm59fXNldFRtcFdvcmtPcHRpb25zKGUpe3ZhciB0Oyh0PXRoaXMudG1wV29ya1NoYXBlTm9kZSk9PW51bGx8fHQuc2V0V29ya09wdGlvbnMoZSl9c2V0V29ya09wdGlvbnMoZSx0KXt2YXIgbDt0aGlzLndvcmtTaGFwZXMuZ2V0KGUpfHx0aGlzLnNldFRtcFdvcmtJZChlKSwobD10aGlzLndvcmtTaGFwZXMuZ2V0KGUpKT09bnVsbHx8bC5zZXRXb3JrT3B0aW9ucyh0KX1zZXRUb29sc09wdChlKXt2YXIgdDtzd2l0Y2goKCh0PXRoaXMudG1wT3B0KT09bnVsbD92b2lkIDA6dC50b29sc1R5cGUpIT09ZS50b29sc1R5cGUmJnRoaXMuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKSx0aGlzLnRtcE9wdD1lLGUudG9vbHNUeXBlKXtjYXNlIGJ0LlBlbmNpbDp0aGlzLnRtcFdvcmtTaGFwZU5vZGU9bmV3IHVlKGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIsdGhpcy5kcmF3TGF5ZXIpO2JyZWFrO2Nhc2UgYnQuTGFzZXJQZW46dGhpcy50bXBXb3JrU2hhcGVOb2RlPW5ldyBoZShlLnRvb2xzT3B0LHRoaXMuZnVsbExheWVyKTticmVhaztjYXNlIGJ0LkVyYXNlcjp0aGlzLnRtcFdvcmtTaGFwZU5vZGU9bmV3IGNlKGUudG9vbHNPcHQsdGhpcy5mdWxsTGF5ZXIpO2JyZWFrO2RlZmF1bHQ6dGhpcy50bXBXb3JrU2hhcGVOb2RlPXZvaWQgMDticmVha319Y2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUoZSl7dmFyIHQ7KHQ9dGhpcy5nZXRXb3JrU2hhcGUoZSkpPT1udWxsfHx0LmNsZWFyVG1wUG9pbnRzKCksdGhpcy53b3JrU2hhcGVzLmRlbGV0ZShlKX1jbGVhckFsbFdvcmtTaGFwZXNDYWNoZSgpe3RoaXMud29ya1NoYXBlcy5mb3JFYWNoKGU9PmUuY2xlYXJUbXBQb2ludHMoKSksdGhpcy53b3JrU2hhcGVzLmNsZWFyKCl9fWNsYXNzIG1lIGV4dGVuZHMgZ2V7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid29ya1NoYXBlcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYmluZURyYXdUaW1lciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkcmF3Q291bnQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTowfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIl9wb3N0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dm9pZCAwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFuaW1hdGlvbldvcmtSZWN0cyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm5ldyBNYXB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYW5pbWF0aW9uSWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp2b2lkIDB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2xvc2VBbmltYXRpb25UaW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6MWUzfSksdGhpcy5fcG9zdD10fXJ1bkxhc2VyUGVuQW5pbWF0aW9uKCl7dGhpcy5hbmltYXRpb25JZHx8KHRoaXMuYW5pbWF0aW9uSWQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57dmFyIHQsYTtsZXQgZTsodD10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fHQuZm9yRWFjaCgobCxNLFQpPT57ZT1YdChlLGwucmVjdCksbC5jYW5EZWwmJlQuZGVsZXRlKE0pfSksdGhpcy5hbmltYXRpb25JZD12b2lkIDAsKGE9dGhpcy5hbmltYXRpb25Xb3JrUmVjdHMpIT1udWxsJiZhLnNpemUmJnRoaXMucnVuTGFzZXJQZW5BbmltYXRpb24oKSxQcm9taXNlLnJlc29sdmUoZSkudGhlbihsPT57dGhpcy5fcG9zdCh7cmVuZGVyOntyZWN0OmwsZHJhd0NhbnZhczpLdC5GbG9hdCxpc0NsZWFyOiEwLGNsZWFyQ2FudmFzOkt0LkZsb2F0LGlzRnVsbFdvcms6ITF9fSl9KX0pKX1jb25zdW1lRHJhdyhlKXt2YXIgbDtjb25zdHtvcDp0LHdvcmtJZDphfT1lO2lmKHQhPW51bGwmJnQubGVuZ3RoJiZhKXtjb25zdCBNPXRoaXMud29ya1NoYXBlcy5nZXQoYSk7aWYoIU0pcmV0dXJuO2NvbnN0IFQ9TS50b29sc1R5cGUsZD1NLmNvbnN1bWUoZSwhMSk7aWYoVD09PWJ0Lkxhc2VyUGVuKXtkIT1udWxsJiZkLnJlY3QmJigobD10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGx8fGwuc2V0KGEse3JlY3Q6ZC5yZWN0LGNhbkRlbDohMX0pKSx0aGlzLnJ1bkxhc2VyUGVuQW5pbWF0aW9uKCk7cmV0dXJufXJldHVybiBkJiYodGhpcy5kcmF3Q291bnQrKyxkLmRyYXdDb3VudD10aGlzLmRyYXdDb3VudCksZH19Y29uc3VtZURyYXdBbGwoZSl7dmFyIGE7Y29uc3R7d29ya0lkOnR9PWU7aWYodCl7Y29uc3QgbD10aGlzLndvcmtTaGFwZXMuZ2V0KHQpO2lmKCFsKXJldHVybjtjb25zdCBNPWwudG9vbHNUeXBlO2lmKE09PT1idC5MYXNlclBlbiYmdGhpcy5hbmltYXRpb25JZCl7bC5jb25zdW1lQWxsKGUpLHRoaXMuY2xvc2VBbmltYXRpb25UaW1lPSgoYT1sLmdldFdvcmtPcHRpb25zKCkpPT1udWxsP3ZvaWQgMDphLmR1cmF0aW9uKXx8dGhpcy5jbG9zZUFuaW1hdGlvblRpbWUsc2V0VGltZW91dCgoKT0+e3ZhciBkO3RoaXMuZnVsbExheWVyLmdldEVsZW1lbnRzQnlOYW1lKHQudG9TdHJpbmcoKSkubWFwKHU9PnUucmVtb3ZlKCkpLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodCk7Y29uc3QgVD0oZD10aGlzLmFuaW1hdGlvbldvcmtSZWN0cyk9PW51bGw/dm9pZCAwOmQuZ2V0KHQpO1QmJihULmNhbkRlbD0hMCl9LHRoaXMuY2xvc2VBbmltYXRpb25UaW1lKjFlMysxMDApO3JldHVybn1NPT09YnQuUGVuY2lsJiYodGhpcy5kcmF3Q291bnQ9MCx0aGlzLmZ1bGxMYXllci5yZW1vdmVBbGxDaGlsZHJlbigpLHRoaXMuY2xlYXJXb3JrU2hhcGVOb2RlQ2FjaGUodCkpfX19Y29uc3QgJHQ9Y2xhc3MgJHQgZXh0ZW5kcyBkZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCk7RnQodGhpcywibG9ja0lkIik7RnQodGhpcywiZHByIik7RnQodGhpcywic2NlbmUiKTtGdCh0aGlzLCJkcmF3TGF5ZXIiKTtGdCh0aGlzLCJmdWxsTGF5ZXIiKTtGdCh0aGlzLCJsb2NhbFdvcmsiKTt0aGlzLnJlZ2lzdGVyKCl9aW5pdCh0LGEsbCl7dGhpcy5kcHI9dCx0aGlzLnNjZW5lPXRoaXMuY3JlYXRlU2NlbmUoYSksdGhpcy5kcmF3TGF5ZXI9dGhpcy5jcmVhdGVMYXllcihsKSx0aGlzLmxvY2FsV29yaz1uZXcgbWUodGhpcy5kcmF3TGF5ZXIsdGhpcy5wb3N0LmJpbmQodGhpcykpfWdldE9mZnNjcmVlbigpe3JldHVybiB0aGlzLmRyYXdMYXllci5jYW52YXN9cmVnaXN0ZXIoKXt0aGlzLm9uKHQ9Pntjb25zdCBhPXt9O2xldCBsO2Zvcihjb25zdCBUIG9mIHQpe2NvbnN0e3dvcmtTdGF0ZTpkLGRhdGFUeXBlOnUsbXNnVHlwZTpjLHdvcmtJZDpPLHRyYW5zbGF0ZTpmLHNjYWxlOmcsb2Zmc2NyZWVuQ2FudmFzT3B0OnYsdG9vbHNUeXBlOkMsbGF5ZXJPcHQ6cCxkcHI6aCxvcHQ6bX09VDtpZihjPT09QXQuSW5pdCYmdiYmcCYmaCl7dGhpcy5pbml0KGgsdixwKTtjb250aW51ZX1pZihjPT09QXQuVHJhbnNmb3JtJiZmJiZnKXt0aGlzLnNldFRyYW5zZm9ybShmLGcpO2NvbnRpbnVlfWlmKGM9PT1BdC5VcGRhdGVTY2VuZSYmdil7dGhpcy51cGRhdGVTY2VuZSh2KTtjb250aW51ZX1pZihjPT09QXQuVXBkYXRlVG9vbHMmJkMmJm0pe3RoaXMuc2V0VG9vbHNPcHQoe3Rvb2xzVHlwZTpDLHRvb2xzT3B0Om19KTtjb250aW51ZX1pZihjPT09QXQuQ3JlYXRlV29yayYmTyYmbSl7IXRoaXMubG9jYWxXb3JrLmdldFRtcFdvcmtTaGFwZU5vZGUoKSYmQyYmdGhpcy5zZXRUb29sc09wdCh7dG9vbHNUeXBlOkMsdG9vbHNPcHQ6bX0pLHRoaXMuc2V0V29ya09wdCh7d29ya0lkOk8sdG9vbHNPcHQ6bX0pO2NvbnRpbnVlfWlmKGM9PT1BdC5DbGVhcil7dGhpcy5jbGVhckFsbCgpO2NvbnRpbnVlfWlmKGM9PT1BdC5EcmF3V29yayYmdT09PWp0LkxvY2FsKXtpZihkPT09V3QuU3RhcnR8fGQ9PT1XdC5Eb2luZyl7Y29uc3Qgcj10aGlzLmNvbnN1bWVEcmF3KHUsVCk7aWYocil7Y29uc3QgaT1yLnJlY3Q7aSYmKGEucmVjdD1YdChhLnJlY3QsaSksYS5kcmF3Q2FudmFzPUt0LkZsb2F0LGEuaXNDbGVhcj0hMSxhLmlzRnVsbFdvcms9ITEpLHIuZHJhd0NvdW50JiYobD1yLmRyYXdDb3VudCl9fWQ9PT1XdC5Eb25lJiZ0aGlzLmNvbnN1bWVEcmF3QWxsKHUsVCk7Y29udGludWV9fWNvbnN0IE09e307YS5yZWN0JiYoTS5yZW5kZXI9YSksbCYmKE0uZHJhd0NvdW50PWwpLE9iamVjdC5rZXlzKE0pLmxlbmd0aCYmdGhpcy5wb3N0KE0pfSl9dXBkYXRlU2NlbmUodCl7c3VwZXIudXBkYXRlU2NlbmUodCksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdC53aWR0aCksdGhpcy5kcmF3TGF5ZXIuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHQuaGVpZ2h0KTtjb25zdCBhPXt4OjAvdGhpcy5zY2FsZS10aGlzLnRyYW5zbGF0ZVswXSx5OjAvdGhpcy5zY2FsZS10aGlzLnRyYW5zbGF0ZVsxXSx3OnQud2lkdGgsaDp0LmhlaWdodH07cmV0dXJue3R5cGU6QXQuVXBkYXRlU2NlbmUscmVjdDphfX1zZXRUb29sc09wdCh0KXt0aGlzLmxvY2FsV29yay5zZXRUb29sc09wdCh0KX1zZXRXb3JrT3B0KHQpe2NvbnN0e3dvcmtJZDphLHRvb2xzT3B0Omx9PXQ7YSYmbCYmdGhpcy5sb2NhbFdvcmsuc2V0V29ya09wdGlvbnMoYSxsKX1jbGVhckFsbCgpe3RoaXMuZHJhd0xheWVyLnJlbW92ZUFsbENoaWxkcmVuKCksdGhpcy5sb2NhbFdvcmsuY2xlYXJBbGxXb3JrU2hhcGVzQ2FjaGUoKSx0aGlzLmR1c3RiaW4uY2xlYXIoKX1zZXRUcmFuc2Zvcm0odCxhKXt0aGlzLnNldFRyYW5zbGF0ZSh0KSx0aGlzLnNldFNjYWxlKGEpLHRoaXMuZHJhd0xheWVyLnNldEF0dHJpYnV0ZSgic2NhbGUiLFthLGFdKSx0aGlzLmRyYXdMYXllci5zZXRBdHRyaWJ1dGUoInRyYW5zbGF0ZSIsdGhpcy50cmFuc2xhdGUpO2NvbnN0IGw9e3g6MC9hLXRoaXMudHJhbnNsYXRlWzBdLHk6MC9hLXRoaXMudHJhbnNsYXRlWzFdLHc6dGhpcy5kcmF3TGF5ZXIud2lkdGgsaDp0aGlzLmRyYXdMYXllci5oZWlnaHR9O3JldHVybnt0eXBlOkF0LlRyYW5zZm9ybSxyZWN0Omx9fWdldFJlY3RJbWFnZUJpdG1hcCh0KXtjb25zdHt4OmEseTpsLHc6TSxoOlR9PXQsZD10aGlzLnNjYWxlPDE/dGhpcy5zY2FsZToxK01hdGguYWJzKHRoaXMuc2NhbGUtMSksdT10aGlzLnNjYWxlPDE/TS90aGlzLnNjYWxlOk0qZCxjPXRoaXMuc2NhbGU8MT9UL3RoaXMuc2NhbGU6VCpkLE89KGErdGhpcy50cmFuc2xhdGVbMF0pKnRoaXMuc2NhbGUsZj0obCt0aGlzLnRyYW5zbGF0ZVsxXSkqdGhpcy5zY2FsZTtyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAodGhpcy5nZXRPZmZzY3JlZW4oKSxPKnRoaXMuZHByLGYqdGhpcy5kcHIsdSp0aGlzLmRwcixjKnRoaXMuZHByLHtyZXNpemVRdWFsaXR5OiJsb3cifSl9cG9zdCh0KXt0aGlzLmxvY2tJZCYmKHQubG9ja0lkPXRoaXMubG9ja0lkLHRoaXMubG9ja0lkPXZvaWQgMCk7Y29uc3QgYT10LnJlbmRlcjtpZihhJiYodGhpcy5kcmF3TGF5ZXIucmVuZGVyKCksYS5yZWN0KSl7dGhpcy5nZXRSZWN0SW1hZ2VCaXRtYXAoYS5yZWN0KS50aGVuKGw9PnthLmltYWdlQml0bWFwPWwsdC5yZW5kZXI9YSwkdC5fc2VsZi5wb3N0TWVzc2FnZSh0LFtsXSksbC5jbG9zZSgpfSk7cmV0dXJufSR0Ll9zZWxmLnBvc3RNZXNzYWdlKHQpfW9uKHQpe29ubWVzc2FnZT1hPT57dChhLmRhdGEpfX1jb25zdW1lRHJhdyh0LGEpe2lmKHQ9PT1qdC5Mb2NhbClyZXR1cm4gdGhpcy5sb2NhbFdvcmsuY29uc3VtZURyYXcoYSl9Y29uc3VtZURyYXdBbGwodCxhKXt0aGlzLmxvY2FsV29yay5jb25zdW1lRHJhd0FsbChhKX1jb25zdW1lRnVsbCgpe319O0Z0KCR0LCJfc2VsZiIsc2VsZik7bGV0IHF0PSR0O25ldyBxdH0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlclN1Yi0zMEc3c3Ewai5qcy5tYXAK", Ks = typeof window < "u" && window.Blob && new Blob([atob(Vt)], { type: "text/javascript;charset=utf-8" });
function wb(n) {
  let l;
  try {
    if (l = Ks && (window.URL || window.webkitURL).createObjectURL(Ks), !l)
      throw "";
    const i = new Worker(l, {
      name: n == null ? void 0 : n.name
    });
    return i.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(l);
    }), i;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + Vt,
      {
        name: n == null ? void 0 : n.name
      }
    );
  } finally {
    l && (window.URL || window.webkitURL).revokeObjectURL(l);
  }
}
class ll extends Pb {
  constructor(l, i, c, Z) {
    var K, u;
    super(l, i, c), Object.defineProperty(this, "threadEngine", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "layerOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "msgEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "offscreenCanvasOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cameraOpt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "translate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [0, 0]
    }), Object.defineProperty(this, "localPointsBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "taskBatchData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "currentToolsData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "currentLocalWorkData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "animationId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workerLockId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "isRunSubWork", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "subWorker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "wokerDrawCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "reRenders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this.pluginOptions = Z, ll.maxLastSyncTime = ((K = Z == null ? void 0 : Z.syncOpt) == null ? void 0 : K.interval) || ll.maxLastSyncTime, this.msgEmitter = new Eb();
    const L = {
      ...ll.defaultScreenCanvasOpt,
      ...(u = this.pluginOptions) == null ? void 0 : u.canvasOpt,
      width: l.offsetWidth,
      height: l.offsetHeight
    };
    this.offscreenCanvasOpt = L, this.layerOpt = ll.defauleLayerOpt, this.setLayerOpt(this.layerOpt), this.setCurrentLocalWorkData({
      workId: void 0,
      workState: Bi.Pending
    }), this.createThreadEngine(), this.on(), this.createOptimizationWorker();
  }
  createOptimizationWorker() {
    this.subWorker = new wb(), this.subWorker.onmessage = (l) => {
      if (l.data) {
        const { render: i, drawCount: c } = l.data;
        if (!c && i) {
          this.render(i);
          return;
        }
        c && (c > this.maxDrawCount && (this.maxDrawCount = c), i && (c > this.wokerDrawCount && (i.isUnClose = !0, this.reRenders.push(i)), this.render(i)));
      }
    };
  }
  subPost(l) {
    var c;
    const i = l.filter((Z) => Z.msgType === Fi.UpdateScene || Z.dataType === Ai.Local);
    i.length && ((c = this.subWorker) == null || c.postMessage(i));
  }
  destroySubWorker() {
    this.subWorker && (this.subWorker.terminate(), this.subWorker = void 0, this.isRunSubWork = !1);
  }
  createThreadEngine() {
    this.taskBatchData.push({
      msgType: Fi.Init,
      dataType: Ai.Local,
      offscreenCanvasOpt: this.offscreenCanvasOpt,
      layerOpt: this.layerOpt,
      dpr: this.dpr
    }), this.runAnimation();
  }
  render(l) {
    var e;
    const { rect: i, imageBitmap: c, isClear: Z, isUnClose: L, drawCanvas: K, clearCanvas: u } = l, a = K === Ol.Float ? this.floatCanvas.getContext("2d") : this.displayCanvas.getContext("2d");
    if (i && a && c) {
      const r = ((e = this.cameraOpt) == null ? void 0 : e.scale) || 1, X = r < 1 ? r : 1 + Math.abs(r - 1), W = r < 1 ? i.w / r : i.w * X, p = r < 1 ? i.h / r : i.h * X, C = (i.x + this.translate[0]) * r * this.dpr, I = (i.y + this.translate[1]) * r * this.dpr, o = W * this.dpr, G = p * this.dpr;
      if (Z) {
        const d = u === Ol.Float ? this.floatCanvas.getContext("2d") : this.displayCanvas.getContext("2d");
        d == null || d.clearRect(C, I, o, G);
      }
      if (a.drawImage(c, 0, 0, o, G, C, I, o, G), L)
        return;
      c.close();
    }
  }
  runAnimation() {
    this.animationId || (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  setLayerOpt(l) {
    this.layerOpt = l;
  }
  updateCanvas(l, i) {
    var u;
    if (this.currentLocalWorkData.workState === Bi.Unwritable)
      return;
    const { width: Z, height: L } = l;
    this.displayCanvas.width = Z * this.dpr, this.displayCanvas.height = L * this.dpr, this.floatCanvas.width = Z * this.dpr, this.floatCanvas.height = L * this.dpr, this.offscreenCanvasOpt = l;
    const K = {
      msgType: Fi.UpdateScene,
      offscreenCanvasOpt: this.offscreenCanvasOpt,
      workId: "",
      dataType: i
    };
    this.taskBatchData.push(K), i === Ai.Local && ((u = this.collector) == null || u.dispatch({
      type: Fi.UpdateScene,
      w: Z,
      h: L
    })), this.runAnimation();
  }
  pushPoint(l) {
    this.localPointsBatchData.push(l[0], l[1]);
  }
  transformToScenePoint(l) {
    var c;
    const i = l;
    return (c = this.cameraOpt) != null && c.scale && this.translate && (i[0] = l[0] / this.cameraOpt.scale - this.translate[0], i[1] = l[1] / this.cameraOpt.scale - this.translate[1]), i;
  }
  initSyncData(l) {
    var c, Z;
    const i = (c = this.collector) == null ? void 0 : c.storage;
    if (i) {
      for (const L of Object.keys(i)) {
        if (l(L, i[L]), L === "screen") {
          const { w: u, h: a } = i[L];
          i[L] && u && a && this.updateCanvas({
            ...this.offscreenCanvasOpt,
            width: u,
            height: a
          }, Ai.Service);
          continue;
        }
        const K = (Z = i[L]) == null ? void 0 : Z.type;
        if (K && L) {
          const u = i[L];
          u.workId = L, u.msgType = K, u.dataType = Ai.Service, this.taskBatchData.push(u);
        }
      }
      this.runAnimation();
    }
  }
  onServiceDerive(l, i) {
    const { newValue: c, oldValue: Z } = i, L = c || {}, K = l;
    let u = L.type;
    if (!(!c && Z && (u = Fi.RemoveNode, Z.toolstype === sl.LaserPen))) {
      if (u && K) {
        const a = L;
        a.workId = this.collector.isOwn(l) ? this.collector.getLocalId(l) : K, a.msgType = u, a.dataType = Ai.Service, this.taskBatchData.push(a);
      }
      this.runAnimation();
    }
  }
  onLocalEventEnd(l) {
    const i = this.currentLocalWorkData.workState;
    if (!(i === Bi.Freeze || i === Bi.Unwritable) && (i === Bi.Start || i === Bi.Doing)) {
      const c = this.transformToScenePoint(l);
      this.pushPoint(c), this.maxDrawCount = 0, this.wokerDrawCount = 0, this.reRenders.length = 0, this.setCurrentLocalWorkData({ workId: this.currentLocalWorkData.workId, workState: Bi.Done });
    }
  }
  onLocalEventDoing(l) {
    let i = this.currentLocalWorkData.workState;
    if (!(i === Bi.Freeze || i === Bi.Unwritable) && (i === Bi.Start && (i = Bi.Doing, this.setCurrentLocalWorkData({ workId: this.currentLocalWorkData.workId, workState: i })), i === Bi.Doing)) {
      const c = this.transformToScenePoint(l);
      this.pushPoint(c);
    }
  }
  onLocalEventStart(l) {
    var L;
    const { workState: i } = this.currentLocalWorkData;
    if (i === Bi.Freeze || i === Bi.Unwritable)
      return;
    const c = Date.now();
    this.setCurrentLocalWorkData({
      workId: c,
      workState: Bi.Start
    }, Fi.CreateWork);
    const Z = this.transformToScenePoint(l);
    this.pushPoint(Z), this.runAnimation(), (L = this.collector) == null || L.dispatch({
      type: Fi.CreateWork,
      workId: c,
      toolstype: this.currentToolsData.toolsType,
      opt: this.currentToolsData.toolsOpt
    });
  }
  consume() {
    this.animationId = void 0;
    const l = this.currentLocalWorkData.workState;
    this.workerLockId || (this.localPointsBatchData.length && this.taskBatchData.push({
      op: this.localPointsBatchData,
      workState: l,
      workId: this.currentLocalWorkData.workId,
      dataType: Ai.Local,
      msgType: Fi.DrawWork,
      drawCount: this.maxDrawCount
    }), this.taskBatchData.length && (this.post(this.taskBatchData), this.taskBatchData.length = 0, this.localPointsBatchData.length = 0)), (l === Bi.Doing || l === Bi.Start || this.taskBatchData.length || this.localPointsBatchData.length) && (this.animationId = requestAnimationFrame(this.consume.bind(this)));
  }
  clearAll(l = !1) {
    var Z;
    this.taskBatchData.push({
      dataType: Ai.Local,
      msgType: Fi.Clear
    });
    const i = this.displayCanvas.getContext("2d");
    i == null || i.clearRect(0, 0, this.displayCanvas.width, this.displayCanvas.height);
    const c = this.floatCanvas.getContext("2d");
    c == null || c.clearRect(0, 0, this.floatCanvas.width, this.floatCanvas.height), l || (Z = this.collector) == null || Z.dispatch({
      type: Fi.Clear
    });
  }
  unabled() {
    this.setCurrentLocalWorkData({ workState: Bi.Freeze, workId: void 0 });
  }
  abled() {
    this.setCurrentLocalWorkData({ workState: Bi.Pending, workId: void 0 });
  }
  destroy() {
    this.msgEmitter.terminate(), this.destroySubWorker();
  }
  post(l) {
    this.msgEmitter.postMessage(l), this.isRunSubWork && this.subPost(this.taskBatchData);
  }
  on() {
    this.msgEmitter.onmessage = (l) => {
      if (l.data) {
        const { render: i, sp: c, drawCount: Z } = l.data;
        if (c != null && c.length && this.collectorSyncData(c), !Z && i) {
          this.render(i);
          return;
        }
        Z && (this.wokerDrawCount = Z, Z > this.maxDrawCount && (this.maxDrawCount = Z), i && (this.render(i), Z < this.maxDrawCount && (this.reRenders.forEach((L) => {
          L.isUnClose = !1, this.render(L);
        }), this.reRenders.length = 0)));
      }
    };
  }
  collectorSyncData(l) {
    for (const i of l) {
      const { type: c, op: Z, workId: L, index: K, removeIds: u, ops: a } = i;
      switch (c) {
        case Fi.DrawWork:
          Z != null && Z.length && L && typeof K == "number" && requestIdleCallback(() => {
            var e;
            (e = this.collector) == null || e.dispatch({
              type: c,
              op: Z,
              workId: L,
              index: K
            });
          }, { timeout: ll.maxLastSyncTime });
          break;
        case Fi.FullWork:
          a && requestIdleCallback(() => {
            var e;
            (e = this.collector) == null || e.dispatch({ type: c, ops: a, workId: L });
          }, { timeout: ll.maxLastSyncTime });
          break;
        case Fi.RemoveNode:
          (Z || u != null && u.length) && requestIdleCallback(() => {
            var e;
            (e = this.collector) == null || e.dispatch({ type: c, removeIds: u });
          }, { timeout: ll.maxLastSyncTime });
          break;
      }
    }
  }
  updateNode(l, i) {
    this.taskBatchData.push({
      msgType: Fi.UpdateNode,
      workId: l,
      updateNodeOpt: i,
      dataType: Ai.Local
    }), this.collector.dispatch({
      type: Fi.UpdateNode,
      workId: l,
      updateNodeOpt: i
    }), this.runAnimation();
  }
  setCurrentLocalWorkData(l, i = Fi.None) {
    super.setCurrentLocalWorkData(l);
    const { workState: c, workId: Z } = l;
    c !== Bi.Unwritable && i !== Fi.None && (this.taskBatchData.push({
      msgType: i,
      workId: Z,
      toolsType: this.currentToolsData.toolsType,
      opt: this.currentToolsData.toolsOpt,
      dataType: Ai.Local
    }), this.runAnimation());
  }
  setCurrentToolsData(l) {
    super.setCurrentToolsData(l), this.taskBatchData.push({
      msgType: Fi.UpdateTools,
      dataType: Ai.Local,
      toolsType: l.toolsType,
      opt: l.toolsOpt
    }), (l == null ? void 0 : l.toolsType) === sl.Eraser ? this.isRunSubWork = !1 : this.isRunSubWork = !0, this.runAnimation();
  }
  setCameraOpt(l) {
    if (super.setCameraOpt(l), l.scale && this.offscreenCanvasOpt) {
      const i = this.offscreenCanvasOpt.width, c = this.offscreenCanvasOpt.height, Z = l.scale < 1 ? l.scale : 1 + Math.abs(l.scale - 1);
      this.translate = [i * (1 - Z) * 0.5 / Z, c * (1 - Z) * 0.5 / Z];
      const L = this.cameraOpt.centerX || 0, K = this.cameraOpt.centerY || 0;
      (L || K) && (this.translate = [this.translate[0] - L, this.translate[1] - K]), this.taskBatchData.push({
        msgType: Fi.Transform,
        dataType: Ai.Local,
        scale: Z,
        translate: this.translate
      }), this.runAnimation();
    }
  }
}
Object.defineProperty(ll, "defaultScreenCanvasOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    autoRender: !1,
    contextType: Sd.Canvas2d
  }
});
Object.defineProperty(ll, "defauleLayerOpt", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    offscreen: !0,
    handleEvent: !1,
    depth: !1
  }
});
Object.defineProperty(ll, "maxLastSyncTime", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 500
});
var jb = Object.is, ht = (n, l) => {
  try {
    n(l);
  } catch (i) {
    console.error(i);
  }
}, Bb = /* @__PURE__ */ Promise.resolve(), zd = [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()], Fl = 0, xd, Ob = () => {
  const n = zd[Fl];
  Fl = 1 - Fl, xd = !1;
  for (const l of n)
    l.exec(
      1
      /* Async */
    );
  n.clear();
}, Db = (n) => {
  zd[Fl].add(n), xd = xd || Bb.then(Ob);
}, Ab = (n) => zd[Fl].delete(n), Tl, Rd, Nl, cl, Ll, al, et, qb = (et = class {
  constructor(n, l) {
    Xl(this, Tl);
    dl(this, "dirty", !1);
    dl(this, "subs", /* @__PURE__ */ new Map());
    Xl(this, Nl, void 0);
    dl(this, 1, 0);
    dl(this, 2, 0);
    dl(this, 3, 0);
    Xl(this, cl, /* @__PURE__ */ new Set());
    Xl(this, Ll, void 0);
    Xl(this, al, void 0);
    hl(this, Nl, n), hl(this, Ll, l);
  }
  notify() {
    _i(this, cl).clear(), this.subs.size > 0 ? (this.exec(
      3
      /* Computed */
    ), this.exec(
      2
      /* Eager */
    ), this[
      1
      /* Async */
    ] > 0 && Db(this)) : this.dirty = !1;
  }
  add(n, l) {
    _i(this, Ll) && this.subs.size <= 0 && hl(this, al, _i(this, Ll).call(this, this));
    const i = this.subs.get(n);
    return i && this[i]--, _i(this, cl).add(n), this.subs.set(n, l), this[l]++, () => this.remove(n);
  }
  remove(n) {
    _i(this, cl).delete(n);
    const l = this.subs.get(n);
    l && (this.subs.delete(n), this[l]--, this.subs.size <= 0 && Vd(this, Tl, Rd).call(this));
  }
  clear() {
    this.subs.clear(), _i(this, cl).clear(), this[
      1
      /* Async */
    ] = this[
      2
      /* Eager */
    ] = this[
      3
      /* Computed */
    ] = 0, Ab(this), Vd(this, Tl, Rd).call(this);
  }
  exec(n) {
    if (this[n] > 0) {
      let l;
      if (n === 3)
        this[
          1
          /* Async */
        ] + this[
          2
          /* Eager */
        ] <= 0 && (this.dirty = !1);
      else {
        if (l = _i(this, Nl).call(this), !this.dirty)
          return;
        (n === 1 || /* mode === SubscriberMode.Eager && */
        this[
          1
          /* Async */
        ] <= 0) && (this.dirty = !1);
      }
      for (const [i, c] of this.subs)
        c === n && !_i(this, cl).has(i) && ht(i, l);
    }
  }
}, Tl = new WeakSet(), Rd = function() {
  _i(this, al) && hl(this, al, _i(this, al).call(this));
}, Nl = new WeakMap(), cl = new WeakMap(), Ll = new WeakMap(), al = new WeakMap(), et), yl, Wt, $b = (Wt = class {
  /**
   * @param get A pure function that returns the current value of the val.
   * @param config Custom config for the val.
   * @param start A function that is called when a val get its first subscriber.
   *        The returned disposer will be called when the last subscriber unsubscribed from the val.
   */
  constructor(n, { equal: l, compare: i, eager: c } = {}, Z) {
    /**
     * Manage subscribers for a val.
     */
    dl(this, "_subs");
    Xl(this, yl, void 0);
    dl(this, "get");
    dl(this, "equal");
    /**
     * @ignore
     * @deprecated Use `equal` instead.
     */
    dl(this, "compare");
    this.get = n, this.compare = this.equal = l || i || jb, hl(this, yl, c), this._subs = new qb(n, Z);
  }
  get value() {
    return this.get();
  }
  reaction(n, l = _i(this, yl)) {
    return this._subs.add(
      n,
      l ? 2 : 1
      /* Async */
    );
  }
  subscribe(n, l = _i(this, yl)) {
    const i = this.reaction(n, l);
    return ht(n, this.value), this._subs.dirty = !1, i;
  }
  $valCompute(n) {
    return this._subs.add(
      n,
      3
      /* Computed */
    );
  }
  unsubscribe(n) {
    n ? this._subs.remove(n) : this._subs.clear();
  }
  dispose() {
    this._subs.clear();
  }
  /**
   * @returns the string representation of `this.value`.
   *
   * @example
   * ```js
   * const v$ = val(val(val(1)));
   * console.log(`${v$}`); // "1"
   * ```
   */
  toString() {
    return String(this.value);
  }
  /**
   * @returns the JSON representation of `this.value`.
   *
   * @example
   * ```js
   * const v$ = val(val(val({ a: 1 })));
   * JSON.stringify(v$); // '{"a":1}'
   * ```
   */
  toJSON(n) {
    const l = this.value;
    return l && l.toJSON ? l.toJSON(n) : l;
  }
}, yl = new WeakMap(), Wt), _b = class extends $b {
  constructor(l, i) {
    super(() => l, i);
    dl(this, "set");
    this.set = (Z) => {
      this.equal(Z, l) || (this._subs.dirty = !0, l = Z, this._subs.notify());
    };
  }
  get value() {
    return this.get();
  }
  set value(l) {
    this.set(l);
  }
};
function It(n, l) {
  return new _b(n, l);
}
var i0 = (n, l) => {
  var i;
  return (i = n.set) == null ? void 0 : i.call(n, l);
}, Yd = { exports: {} }, Jl = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Jl.exports;
var Ss;
function l0() {
  return Ss || (Ss = 1, function(n, l) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var i = "18.2.0", c = Symbol.for("react.element"), Z = Symbol.for("react.portal"), L = Symbol.for("react.fragment"), K = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), e = Symbol.for("react.context"), r = Symbol.for("react.forward_ref"), X = Symbol.for("react.suspense"), W = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), C = Symbol.for("react.lazy"), I = Symbol.for("react.offscreen"), o = Symbol.iterator, G = "@@iterator";
      function d(E) {
        if (E === null || typeof E != "object")
          return null;
        var di = o && E[o] || E[G];
        return typeof di == "function" ? di : null;
      }
      var t = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, s = {
        transition: null
      }, b = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, V = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, S = {}, Y = null;
      function T(E) {
        Y = E;
      }
      S.setExtraStackFrame = function(E) {
        Y = E;
      }, S.getCurrentStack = null, S.getStackAddendum = function() {
        var E = "";
        Y && (E += Y);
        var di = S.getCurrentStack;
        return di && (E += di() || ""), E;
      };
      var y = !1, J = !1, N = !1, R = !1, x = !1, M = {
        ReactCurrentDispatcher: t,
        ReactCurrentBatchConfig: s,
        ReactCurrentOwner: V
      };
      M.ReactDebugCurrentFrame = S, M.ReactCurrentActQueue = b;
      function Q(E) {
        {
          for (var di = arguments.length, ei = new Array(di > 1 ? di - 1 : 0), ui = 1; ui < di; ui++)
            ei[ui - 1] = arguments[ui];
          D("warn", E, ei);
        }
      }
      function P(E) {
        {
          for (var di = arguments.length, ei = new Array(di > 1 ? di - 1 : 0), ui = 1; ui < di; ui++)
            ei[ui - 1] = arguments[ui];
          D("error", E, ei);
        }
      }
      function D(E, di, ei) {
        {
          var ui = M.ReactDebugCurrentFrame, hi = ui.getStackAddendum();
          hi !== "" && (di += "%s", ei = ei.concat([hi]));
          var Ki = ei.map(function(pi) {
            return String(pi);
          });
          Ki.unshift("Warning: " + di), Function.prototype.apply.call(console[E], console, Ki);
        }
      }
      var _ = {};
      function F(E, di) {
        {
          var ei = E.constructor, ui = ei && (ei.displayName || ei.name) || "ReactClass", hi = ui + "." + di;
          if (_[hi])
            return;
          P("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", di, ui), _[hi] = !0;
        }
      }
      var v = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(E) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(E, di, ei) {
          F(E, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(E, di, ei, ui) {
          F(E, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(E, di, ei, ui) {
          F(E, "setState");
        }
      }, O = Object.assign, li = {};
      Object.freeze(li);
      function ii(E, di, ei) {
        this.props = E, this.context = di, this.refs = li, this.updater = ei || v;
      }
      ii.prototype.isReactComponent = {}, ii.prototype.setState = function(E, di) {
        if (typeof E != "object" && typeof E != "function" && E != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, E, di, "setState");
      }, ii.prototype.forceUpdate = function(E) {
        this.updater.enqueueForceUpdate(this, E, "forceUpdate");
      };
      {
        var ti = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, $ = function(E, di) {
          Object.defineProperty(ii.prototype, E, {
            get: function() {
              Q("%s(...) is deprecated in plain JavaScript React classes. %s", di[0], di[1]);
            }
          });
        };
        for (var ai in ti)
          ti.hasOwnProperty(ai) && $(ai, ti[ai]);
      }
      function Xi() {
      }
      Xi.prototype = ii.prototype;
      function z(E, di, ei) {
        this.props = E, this.context = di, this.refs = li, this.updater = ei || v;
      }
      var k = z.prototype = new Xi();
      k.constructor = z, O(k, ii.prototype), k.isPureReactComponent = !0;
      function j() {
        var E = {
          current: null
        };
        return Object.seal(E), E;
      }
      var A = Array.isArray;
      function H(E) {
        return A(E);
      }
      function U(E) {
        {
          var di = typeof Symbol == "function" && Symbol.toStringTag, ei = di && E[Symbol.toStringTag] || E.constructor.name || "Object";
          return ei;
        }
      }
      function m(E) {
        try {
          return h(E), !1;
        } catch {
          return !0;
        }
      }
      function h(E) {
        return "" + E;
      }
      function g(E) {
        if (m(E))
          return P("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", U(E)), h(E);
      }
      function f(E, di, ei) {
        var ui = E.displayName;
        if (ui)
          return ui;
        var hi = di.displayName || di.name || "";
        return hi !== "" ? ei + "(" + hi + ")" : ei;
      }
      function w(E) {
        return E.displayName || "Context";
      }
      function B(E) {
        if (E == null)
          return null;
        if (typeof E.tag == "number" && P("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof E == "function")
          return E.displayName || E.name || null;
        if (typeof E == "string")
          return E;
        switch (E) {
          case L:
            return "Fragment";
          case Z:
            return "Portal";
          case u:
            return "Profiler";
          case K:
            return "StrictMode";
          case X:
            return "Suspense";
          case W:
            return "SuspenseList";
        }
        if (typeof E == "object")
          switch (E.$$typeof) {
            case e:
              var di = E;
              return w(di) + ".Consumer";
            case a:
              var ei = E;
              return w(ei._context) + ".Provider";
            case r:
              return f(E, E.render, "ForwardRef");
            case p:
              var ui = E.displayName || null;
              return ui !== null ? ui : B(E.type) || "Memo";
            case C: {
              var hi = E, Ki = hi._payload, pi = hi._init;
              try {
                return B(pi(Ki));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var q = Object.prototype.hasOwnProperty, si = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, bi, Zi, oi;
      oi = {};
      function mi(E) {
        if (q.call(E, "ref")) {
          var di = Object.getOwnPropertyDescriptor(E, "ref").get;
          if (di && di.isReactWarning)
            return !1;
        }
        return E.ref !== void 0;
      }
      function ci(E) {
        if (q.call(E, "key")) {
          var di = Object.getOwnPropertyDescriptor(E, "key").get;
          if (di && di.isReactWarning)
            return !1;
        }
        return E.key !== void 0;
      }
      function ni(E, di) {
        var ei = function() {
          bi || (bi = !0, P("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", di));
        };
        ei.isReactWarning = !0, Object.defineProperty(E, "key", {
          get: ei,
          configurable: !0
        });
      }
      function Gi(E, di) {
        var ei = function() {
          Zi || (Zi = !0, P("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", di));
        };
        ei.isReactWarning = !0, Object.defineProperty(E, "ref", {
          get: ei,
          configurable: !0
        });
      }
      function Vi(E) {
        if (typeof E.ref == "string" && V.current && E.__self && V.current.stateNode !== E.__self) {
          var di = B(V.current.type);
          oi[di] || (P('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', di, E.ref), oi[di] = !0);
        }
      }
      var Wi = function(E, di, ei, ui, hi, Ki, pi) {
        var xi = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: c,
          // Built-in properties that belong on the element
          type: E,
          key: di,
          ref: ei,
          props: pi,
          // Record the component responsible for creating this element.
          _owner: Ki
        };
        return xi._store = {}, Object.defineProperty(xi._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(xi, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: ui
        }), Object.defineProperty(xi, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: hi
        }), Object.freeze && (Object.freeze(xi.props), Object.freeze(xi)), xi;
      };
      function Ii(E, di, ei) {
        var ui, hi = {}, Ki = null, pi = null, xi = null, Ci = null;
        if (di != null) {
          mi(di) && (pi = di.ref, Vi(di)), ci(di) && (g(di.key), Ki = "" + di.key), xi = di.__self === void 0 ? null : di.__self, Ci = di.__source === void 0 ? null : di.__source;
          for (ui in di)
            q.call(di, ui) && !si.hasOwnProperty(ui) && (hi[ui] = di[ui]);
        }
        var Ni = arguments.length - 2;
        if (Ni === 1)
          hi.children = ei;
        else if (Ni > 1) {
          for (var vi = Array(Ni), Ui = 0; Ui < Ni; Ui++)
            vi[Ui] = arguments[Ui + 2];
          Object.freeze && Object.freeze(vi), hi.children = vi;
        }
        if (E && E.defaultProps) {
          var Ei = E.defaultProps;
          for (ui in Ei)
            hi[ui] === void 0 && (hi[ui] = Ei[ui]);
        }
        if (Ki || pi) {
          var Oi = typeof E == "function" ? E.displayName || E.name || "Unknown" : E;
          Ki && ni(hi, Oi), pi && Gi(hi, Oi);
        }
        return Wi(E, Ki, pi, xi, Ci, V.current, hi);
      }
      function Ri(E, di) {
        var ei = Wi(E.type, di, E.ref, E._self, E._source, E._owner, E.props);
        return ei;
      }
      function yi(E, di, ei) {
        if (E == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + E + ".");
        var ui, hi = O({}, E.props), Ki = E.key, pi = E.ref, xi = E._self, Ci = E._source, Ni = E._owner;
        if (di != null) {
          mi(di) && (pi = di.ref, Ni = V.current), ci(di) && (g(di.key), Ki = "" + di.key);
          var vi;
          E.type && E.type.defaultProps && (vi = E.type.defaultProps);
          for (ui in di)
            q.call(di, ui) && !si.hasOwnProperty(ui) && (di[ui] === void 0 && vi !== void 0 ? hi[ui] = vi[ui] : hi[ui] = di[ui]);
        }
        var Ui = arguments.length - 2;
        if (Ui === 1)
          hi.children = ei;
        else if (Ui > 1) {
          for (var Ei = Array(Ui), Oi = 0; Oi < Ui; Oi++)
            Ei[Oi] = arguments[Oi + 2];
          hi.children = Ei;
        }
        return Wi(E.type, Ki, pi, xi, Ci, Ni, hi);
      }
      function Li(E) {
        return typeof E == "object" && E !== null && E.$$typeof === c;
      }
      var ri = ".", Si = ":";
      function wi(E) {
        var di = /[=:]/g, ei = {
          "=": "=0",
          ":": "=2"
        }, ui = E.replace(di, function(hi) {
          return ei[hi];
        });
        return "$" + ui;
      }
      var zi = !1, Qi = /\/+/g;
      function ki(E) {
        return E.replace(Qi, "$&/");
      }
      function Pi(E, di) {
        return typeof E == "object" && E !== null && E.key != null ? (g(E.key), wi("" + E.key)) : di.toString(36);
      }
      function fi(E, di, ei, ui, hi) {
        var Ki = typeof E;
        (Ki === "undefined" || Ki === "boolean") && (E = null);
        var pi = !1;
        if (E === null)
          pi = !0;
        else
          switch (Ki) {
            case "string":
            case "number":
              pi = !0;
              break;
            case "object":
              switch (E.$$typeof) {
                case c:
                case Z:
                  pi = !0;
              }
          }
        if (pi) {
          var xi = E, Ci = hi(xi), Ni = ui === "" ? ri + Pi(xi, 0) : ui;
          if (H(Ci)) {
            var vi = "";
            Ni != null && (vi = ki(Ni) + "/"), fi(Ci, di, vi, "", function(gb) {
              return gb;
            });
          } else
            Ci != null && (Li(Ci) && (Ci.key && (!xi || xi.key !== Ci.key) && g(Ci.key), Ci = Ri(
              Ci,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              ei + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Ci.key && (!xi || xi.key !== Ci.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                ki("" + Ci.key) + "/"
              ) : "") + Ni
            )), di.push(Ci));
          return 1;
        }
        var Ui, Ei, Oi = 0, Di = ui === "" ? ri : ui + Si;
        if (H(E))
          for (var Ql = 0; Ql < E.length; Ql++)
            Ui = E[Ql], Ei = Di + Pi(Ui, Ql), Oi += fi(Ui, di, ei, Ei, hi);
        else {
          var ud = d(E);
          if (typeof ud == "function") {
            var Vs = E;
            ud === Vs.entries && (zi || Q("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), zi = !0);
            for (var Tb = ud.call(Vs), hs, Nb = 0; !(hs = Tb.next()).done; )
              Ui = hs.value, Ei = Di + Pi(Ui, Nb++), Oi += fi(Ui, di, ei, Ei, hi);
          } else if (Ki === "object") {
            var Is = String(E);
            throw new Error("Objects are not valid as a React child (found: " + (Is === "[object Object]" ? "object with keys {" + Object.keys(E).join(", ") + "}" : Is) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Oi;
      }
      function ji(E, di, ei) {
        if (E == null)
          return E;
        var ui = [], hi = 0;
        return fi(E, ui, "", "", function(Ki) {
          return di.call(ei, Ki, hi++);
        }), ui;
      }
      function Ji(E) {
        var di = 0;
        return ji(E, function() {
          di++;
        }), di;
      }
      function $i(E, di, ei) {
        ji(E, function() {
          di.apply(this, arguments);
        }, ei);
      }
      function Zl(E) {
        return ji(E, function(di) {
          return di;
        }) || [];
      }
      function nl(E) {
        if (!Li(E))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return E;
      }
      function Hl(E) {
        var di = {
          $$typeof: e,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: E,
          _currentValue2: E,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        di.Provider = {
          $$typeof: a,
          _context: di
        };
        var ei = !1, ui = !1, hi = !1;
        {
          var Ki = {
            $$typeof: e,
            _context: di
          };
          Object.defineProperties(Ki, {
            Provider: {
              get: function() {
                return ui || (ui = !0, P("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), di.Provider;
              },
              set: function(pi) {
                di.Provider = pi;
              }
            },
            _currentValue: {
              get: function() {
                return di._currentValue;
              },
              set: function(pi) {
                di._currentValue = pi;
              }
            },
            _currentValue2: {
              get: function() {
                return di._currentValue2;
              },
              set: function(pi) {
                di._currentValue2 = pi;
              }
            },
            _threadCount: {
              get: function() {
                return di._threadCount;
              },
              set: function(pi) {
                di._threadCount = pi;
              }
            },
            Consumer: {
              get: function() {
                return ei || (ei = !0, P("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), di.Consumer;
              }
            },
            displayName: {
              get: function() {
                return di.displayName;
              },
              set: function(pi) {
                hi || (Q("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", pi), hi = !0);
              }
            }
          }), di.Consumer = Ki;
        }
        return di._currentRenderer = null, di._currentRenderer2 = null, di;
      }
      var bl = -1, md = 0, Od = 1, Bt = 2;
      function Ot(E) {
        if (E._status === bl) {
          var di = E._result, ei = di();
          if (ei.then(function(Ki) {
            if (E._status === md || E._status === bl) {
              var pi = E;
              pi._status = Od, pi._result = Ki;
            }
          }, function(Ki) {
            if (E._status === md || E._status === bl) {
              var pi = E;
              pi._status = Bt, pi._result = Ki;
            }
          }), E._status === bl) {
            var ui = E;
            ui._status = md, ui._result = ei;
          }
        }
        if (E._status === Od) {
          var hi = E._result;
          return hi === void 0 && P(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, hi), "default" in hi || P(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, hi), hi.default;
        } else
          throw E._result;
      }
      function Dt(E) {
        var di = {
          // We use these fields to store the result.
          _status: bl,
          _result: E
        }, ei = {
          $$typeof: C,
          _payload: di,
          _init: Ot
        };
        {
          var ui, hi;
          Object.defineProperties(ei, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return ui;
              },
              set: function(Ki) {
                P("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), ui = Ki, Object.defineProperty(ei, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return hi;
              },
              set: function(Ki) {
                P("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), hi = Ki, Object.defineProperty(ei, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return ei;
      }
      function At(E) {
        E != null && E.$$typeof === p ? P("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof E != "function" ? P("forwardRef requires a render function but was given %s.", E === null ? "null" : typeof E) : E.length !== 0 && E.length !== 2 && P("forwardRef render functions accept exactly two parameters: props and ref. %s", E.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), E != null && (E.defaultProps != null || E.propTypes != null) && P("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var di = {
          $$typeof: r,
          render: E
        };
        {
          var ei;
          Object.defineProperty(di, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ei;
            },
            set: function(ui) {
              ei = ui, !E.name && !E.displayName && (E.displayName = ui);
            }
          });
        }
        return di;
      }
      var Dd;
      Dd = Symbol.for("react.module.reference");
      function Ad(E) {
        return !!(typeof E == "string" || typeof E == "function" || E === L || E === u || x || E === K || E === X || E === W || R || E === I || y || J || N || typeof E == "object" && E !== null && (E.$$typeof === C || E.$$typeof === p || E.$$typeof === a || E.$$typeof === e || E.$$typeof === r || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        E.$$typeof === Dd || E.getModuleId !== void 0));
      }
      function qt(E, di) {
        Ad(E) || P("memo: The first argument must be a component. Instead received: %s", E === null ? "null" : typeof E);
        var ei = {
          $$typeof: p,
          type: E,
          compare: di === void 0 ? null : di
        };
        {
          var ui;
          Object.defineProperty(ei, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ui;
            },
            set: function(hi) {
              ui = hi, !E.name && !E.displayName && (E.displayName = hi);
            }
          });
        }
        return ei;
      }
      function qi() {
        var E = t.current;
        return E === null && P(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), E;
      }
      function $t(E) {
        var di = qi();
        if (E._context !== void 0) {
          var ei = E._context;
          ei.Consumer === E ? P("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : ei.Provider === E && P("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return di.useContext(E);
      }
      function _t(E) {
        var di = qi();
        return di.useState(E);
      }
      function ib(E, di, ei) {
        var ui = qi();
        return ui.useReducer(E, di, ei);
      }
      function lb(E) {
        var di = qi();
        return di.useRef(E);
      }
      function db(E, di) {
        var ei = qi();
        return ei.useEffect(E, di);
      }
      function sb(E, di) {
        var ei = qi();
        return ei.useInsertionEffect(E, di);
      }
      function tb(E, di) {
        var ei = qi();
        return ei.useLayoutEffect(E, di);
      }
      function bb(E, di) {
        var ei = qi();
        return ei.useCallback(E, di);
      }
      function cb(E, di) {
        var ei = qi();
        return ei.useMemo(E, di);
      }
      function mb(E, di, ei) {
        var ui = qi();
        return ui.useImperativeHandle(E, di, ei);
      }
      function Zb(E, di) {
        {
          var ei = qi();
          return ei.useDebugValue(E, di);
        }
      }
      function nb() {
        var E = qi();
        return E.useTransition();
      }
      function Xb(E) {
        var di = qi();
        return di.useDeferredValue(E);
      }
      function ob() {
        var E = qi();
        return E.useId();
      }
      function ab(E, di, ei) {
        var ui = qi();
        return ui.useSyncExternalStore(E, di, ei);
      }
      var Yl = 0, qd, $d, _d, is, ls, ds, ss;
      function ts() {
      }
      ts.__reactDisabledLog = !0;
      function eb() {
        {
          if (Yl === 0) {
            qd = console.log, $d = console.info, _d = console.warn, is = console.error, ls = console.group, ds = console.groupCollapsed, ss = console.groupEnd;
            var E = {
              configurable: !0,
              enumerable: !0,
              value: ts,
              writable: !0
            };
            Object.defineProperties(console, {
              info: E,
              log: E,
              warn: E,
              error: E,
              group: E,
              groupCollapsed: E,
              groupEnd: E
            });
          }
          Yl++;
        }
      }
      function Wb() {
        {
          if (Yl--, Yl === 0) {
            var E = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: O({}, E, {
                value: qd
              }),
              info: O({}, E, {
                value: $d
              }),
              warn: O({}, E, {
                value: _d
              }),
              error: O({}, E, {
                value: is
              }),
              group: O({}, E, {
                value: ls
              }),
              groupCollapsed: O({}, E, {
                value: ds
              }),
              groupEnd: O({}, E, {
                value: ss
              })
            });
          }
          Yl < 0 && P("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Zd = M.ReactCurrentDispatcher, nd;
      function Ml(E, di, ei) {
        {
          if (nd === void 0)
            try {
              throw Error();
            } catch (hi) {
              var ui = hi.stack.trim().match(/\n( *(at )?)/);
              nd = ui && ui[1] || "";
            }
          return `
` + nd + E;
        }
      }
      var Xd = !1, zl;
      {
        var ub = typeof WeakMap == "function" ? WeakMap : Map;
        zl = new ub();
      }
      function bs(E, di) {
        if (!E || Xd)
          return "";
        {
          var ei = zl.get(E);
          if (ei !== void 0)
            return ei;
        }
        var ui;
        Xd = !0;
        var hi = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Ki;
        Ki = Zd.current, Zd.current = null, eb();
        try {
          if (di) {
            var pi = function() {
              throw Error();
            };
            if (Object.defineProperty(pi.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(pi, []);
              } catch (Di) {
                ui = Di;
              }
              Reflect.construct(E, [], pi);
            } else {
              try {
                pi.call();
              } catch (Di) {
                ui = Di;
              }
              E.call(pi.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Di) {
              ui = Di;
            }
            E();
          }
        } catch (Di) {
          if (Di && ui && typeof Di.stack == "string") {
            for (var xi = Di.stack.split(`
`), Ci = ui.stack.split(`
`), Ni = xi.length - 1, vi = Ci.length - 1; Ni >= 1 && vi >= 0 && xi[Ni] !== Ci[vi]; )
              vi--;
            for (; Ni >= 1 && vi >= 0; Ni--, vi--)
              if (xi[Ni] !== Ci[vi]) {
                if (Ni !== 1 || vi !== 1)
                  do
                    if (Ni--, vi--, vi < 0 || xi[Ni] !== Ci[vi]) {
                      var Ui = `
` + xi[Ni].replace(" at new ", " at ");
                      return E.displayName && Ui.includes("<anonymous>") && (Ui = Ui.replace("<anonymous>", E.displayName)), typeof E == "function" && zl.set(E, Ui), Ui;
                    }
                  while (Ni >= 1 && vi >= 0);
                break;
              }
          }
        } finally {
          Xd = !1, Zd.current = Ki, Wb(), Error.prepareStackTrace = hi;
        }
        var Ei = E ? E.displayName || E.name : "", Oi = Ei ? Ml(Ei) : "";
        return typeof E == "function" && zl.set(E, Oi), Oi;
      }
      function Gb(E, di, ei) {
        return bs(E, !1);
      }
      function Vb(E) {
        var di = E.prototype;
        return !!(di && di.isReactComponent);
      }
      function kl(E, di, ei) {
        if (E == null)
          return "";
        if (typeof E == "function")
          return bs(E, Vb(E));
        if (typeof E == "string")
          return Ml(E);
        switch (E) {
          case X:
            return Ml("Suspense");
          case W:
            return Ml("SuspenseList");
        }
        if (typeof E == "object")
          switch (E.$$typeof) {
            case r:
              return Gb(E.render);
            case p:
              return kl(E.type, di, ei);
            case C: {
              var ui = E, hi = ui._payload, Ki = ui._init;
              try {
                return kl(Ki(hi), di, ei);
              } catch {
              }
            }
          }
        return "";
      }
      var cs = {}, ms = M.ReactDebugCurrentFrame;
      function fl(E) {
        if (E) {
          var di = E._owner, ei = kl(E.type, E._source, di ? di.type : null);
          ms.setExtraStackFrame(ei);
        } else
          ms.setExtraStackFrame(null);
      }
      function hb(E, di, ei, ui, hi) {
        {
          var Ki = Function.call.bind(q);
          for (var pi in E)
            if (Ki(E, pi)) {
              var xi = void 0;
              try {
                if (typeof E[pi] != "function") {
                  var Ci = Error((ui || "React class") + ": " + ei + " type `" + pi + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof E[pi] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Ci.name = "Invariant Violation", Ci;
                }
                xi = E[pi](di, pi, ui, ei, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Ni) {
                xi = Ni;
              }
              xi && !(xi instanceof Error) && (fl(hi), P("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ui || "React class", ei, pi, typeof xi), fl(null)), xi instanceof Error && !(xi.message in cs) && (cs[xi.message] = !0, fl(hi), P("Failed %s type: %s", ei, xi.message), fl(null));
            }
        }
      }
      function Gl(E) {
        if (E) {
          var di = E._owner, ei = kl(E.type, E._source, di ? di.type : null);
          T(ei);
        } else
          T(null);
      }
      var od;
      od = !1;
      function Zs() {
        if (V.current) {
          var E = B(V.current.type);
          if (E)
            return `

Check the render method of \`` + E + "`.";
        }
        return "";
      }
      function Ib(E) {
        if (E !== void 0) {
          var di = E.fileName.replace(/^.*[\\\/]/, ""), ei = E.lineNumber;
          return `

Check your code at ` + di + ":" + ei + ".";
        }
        return "";
      }
      function pb(E) {
        return E != null ? Ib(E.__source) : "";
      }
      var ns = {};
      function Lb(E) {
        var di = Zs();
        if (!di) {
          var ei = typeof E == "string" ? E : E.displayName || E.name;
          ei && (di = `

Check the top-level render call using <` + ei + ">.");
        }
        return di;
      }
      function Xs(E, di) {
        if (!(!E._store || E._store.validated || E.key != null)) {
          E._store.validated = !0;
          var ei = Lb(di);
          if (!ns[ei]) {
            ns[ei] = !0;
            var ui = "";
            E && E._owner && E._owner !== V.current && (ui = " It was passed a child from " + B(E._owner.type) + "."), Gl(E), P('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ei, ui), Gl(null);
          }
        }
      }
      function os(E, di) {
        if (typeof E == "object") {
          if (H(E))
            for (var ei = 0; ei < E.length; ei++) {
              var ui = E[ei];
              Li(ui) && Xs(ui, di);
            }
          else if (Li(E))
            E._store && (E._store.validated = !0);
          else if (E) {
            var hi = d(E);
            if (typeof hi == "function" && hi !== E.entries)
              for (var Ki = hi.call(E), pi; !(pi = Ki.next()).done; )
                Li(pi.value) && Xs(pi.value, di);
          }
        }
      }
      function as(E) {
        {
          var di = E.type;
          if (di == null || typeof di == "string")
            return;
          var ei;
          if (typeof di == "function")
            ei = di.propTypes;
          else if (typeof di == "object" && (di.$$typeof === r || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          di.$$typeof === p))
            ei = di.propTypes;
          else
            return;
          if (ei) {
            var ui = B(di);
            hb(ei, E.props, "prop", ui, E);
          } else if (di.PropTypes !== void 0 && !od) {
            od = !0;
            var hi = B(di);
            P("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", hi || "Unknown");
          }
          typeof di.getDefaultProps == "function" && !di.getDefaultProps.isReactClassApproved && P("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function yb(E) {
        {
          for (var di = Object.keys(E.props), ei = 0; ei < di.length; ei++) {
            var ui = di[ei];
            if (ui !== "children" && ui !== "key") {
              Gl(E), P("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ui), Gl(null);
              break;
            }
          }
          E.ref !== null && (Gl(E), P("Invalid attribute `ref` supplied to `React.Fragment`."), Gl(null));
        }
      }
      function es(E, di, ei) {
        var ui = Ad(E);
        if (!ui) {
          var hi = "";
          (E === void 0 || typeof E == "object" && E !== null && Object.keys(E).length === 0) && (hi += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ki = pb(di);
          Ki ? hi += Ki : hi += Zs();
          var pi;
          E === null ? pi = "null" : H(E) ? pi = "array" : E !== void 0 && E.$$typeof === c ? (pi = "<" + (B(E.type) || "Unknown") + " />", hi = " Did you accidentally export a JSX literal instead of a component?") : pi = typeof E, P("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", pi, hi);
        }
        var xi = Ii.apply(this, arguments);
        if (xi == null)
          return xi;
        if (ui)
          for (var Ci = 2; Ci < arguments.length; Ci++)
            os(arguments[Ci], E);
        return E === L ? yb(xi) : as(xi), xi;
      }
      var Ws = !1;
      function rb(E) {
        var di = es.bind(null, E);
        return di.type = E, Ws || (Ws = !0, Q("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(di, "type", {
          enumerable: !1,
          get: function() {
            return Q("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: E
            }), E;
          }
        }), di;
      }
      function Kb(E, di, ei) {
        for (var ui = yi.apply(this, arguments), hi = 2; hi < arguments.length; hi++)
          os(arguments[hi], ui.type);
        return as(ui), ui;
      }
      function Sb(E, di) {
        var ei = s.transition;
        s.transition = {};
        var ui = s.transition;
        s.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          E();
        } finally {
          if (s.transition = ei, ei === null && ui._updatedFibers) {
            var hi = ui._updatedFibers.size;
            hi > 10 && Q("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), ui._updatedFibers.clear();
          }
        }
      }
      var us = !1, vl = null;
      function xb(E) {
        if (vl === null)
          try {
            var di = ("require" + Math.random()).slice(0, 7), ei = n && n[di];
            vl = ei.call(n, "timers").setImmediate;
          } catch {
            vl = function(hi) {
              us === !1 && (us = !0, typeof MessageChannel > "u" && P("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Ki = new MessageChannel();
              Ki.port1.onmessage = hi, Ki.port2.postMessage(void 0);
            };
          }
        return vl(E);
      }
      var Vl = 0, Gs = !1;
      function Rb(E) {
        {
          var di = Vl;
          Vl++, b.current === null && (b.current = []);
          var ei = b.isBatchingLegacy, ui;
          try {
            if (b.isBatchingLegacy = !0, ui = E(), !ei && b.didScheduleLegacyUpdate) {
              var hi = b.current;
              hi !== null && (b.didScheduleLegacyUpdate = !1, Wd(hi));
            }
          } catch (Ei) {
            throw Ul(di), Ei;
          } finally {
            b.isBatchingLegacy = ei;
          }
          if (ui !== null && typeof ui == "object" && typeof ui.then == "function") {
            var Ki = ui, pi = !1, xi = {
              then: function(Ei, Oi) {
                pi = !0, Ki.then(function(Di) {
                  Ul(di), Vl === 0 ? ad(Di, Ei, Oi) : Ei(Di);
                }, function(Di) {
                  Ul(di), Oi(Di);
                });
              }
            };
            return !Gs && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              pi || (Gs = !0, P("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), xi;
          } else {
            var Ci = ui;
            if (Ul(di), Vl === 0) {
              var Ni = b.current;
              Ni !== null && (Wd(Ni), b.current = null);
              var vi = {
                then: function(Ei, Oi) {
                  b.current === null ? (b.current = [], ad(Ci, Ei, Oi)) : Ei(Ci);
                }
              };
              return vi;
            } else {
              var Ui = {
                then: function(Ei, Oi) {
                  Ei(Ci);
                }
              };
              return Ui;
            }
          }
        }
      }
      function Ul(E) {
        E !== Vl - 1 && P("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Vl = E;
      }
      function ad(E, di, ei) {
        {
          var ui = b.current;
          if (ui !== null)
            try {
              Wd(ui), xb(function() {
                ui.length === 0 ? (b.current = null, di(E)) : ad(E, di, ei);
              });
            } catch (hi) {
              ei(hi);
            }
          else
            di(E);
        }
      }
      var ed = !1;
      function Wd(E) {
        if (!ed) {
          ed = !0;
          var di = 0;
          try {
            for (; di < E.length; di++) {
              var ei = E[di];
              do
                ei = ei(!0);
              while (ei !== null);
            }
            E.length = 0;
          } catch (ui) {
            throw E = E.slice(di + 1), ui;
          } finally {
            ed = !1;
          }
        }
      }
      var Yb = es, Cb = Kb, Jb = rb, Fb = {
        map: ji,
        forEach: $i,
        count: Ji,
        toArray: Zl,
        only: nl
      };
      l.Children = Fb, l.Component = ii, l.Fragment = L, l.Profiler = u, l.PureComponent = z, l.StrictMode = K, l.Suspense = X, l.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = M, l.cloneElement = Cb, l.createContext = Hl, l.createElement = Yb, l.createFactory = Jb, l.createRef = j, l.forwardRef = At, l.isValidElement = Li, l.lazy = Dt, l.memo = qt, l.startTransition = Sb, l.unstable_act = Rb, l.useCallback = bb, l.useContext = $t, l.useDebugValue = Zb, l.useDeferredValue = Xb, l.useEffect = db, l.useId = ob, l.useImperativeHandle = mb, l.useInsertionEffect = sb, l.useLayoutEffect = tb, l.useMemo = cb, l.useReducer = ib, l.useRef = lb, l.useState = _t, l.useSyncExternalStore = ab, l.useTransition = nb, l.version = i, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Jl, Jl.exports)), Jl.exports;
}
var Yi = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xs;
function d0() {
  if (xs)
    return Yi;
  xs = 1;
  var n = Symbol.for("react.element"), l = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), c = Symbol.for("react.strict_mode"), Z = Symbol.for("react.profiler"), L = Symbol.for("react.provider"), K = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), a = Symbol.for("react.suspense"), e = Symbol.for("react.memo"), r = Symbol.for("react.lazy"), X = Symbol.iterator;
  function W(F) {
    return F === null || typeof F != "object" ? null : (F = X && F[X] || F["@@iterator"], typeof F == "function" ? F : null);
  }
  var p = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, I = {};
  function o(F, v, O) {
    this.props = F, this.context = v, this.refs = I, this.updater = O || p;
  }
  o.prototype.isReactComponent = {}, o.prototype.setState = function(F, v) {
    if (typeof F != "object" && typeof F != "function" && F != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, F, v, "setState");
  }, o.prototype.forceUpdate = function(F) {
    this.updater.enqueueForceUpdate(this, F, "forceUpdate");
  };
  function G() {
  }
  G.prototype = o.prototype;
  function d(F, v, O) {
    this.props = F, this.context = v, this.refs = I, this.updater = O || p;
  }
  var t = d.prototype = new G();
  t.constructor = d, C(t, o.prototype), t.isPureReactComponent = !0;
  var s = Array.isArray, b = Object.prototype.hasOwnProperty, V = { current: null }, S = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Y(F, v, O) {
    var li, ii = {}, ti = null, $ = null;
    if (v != null)
      for (li in v.ref !== void 0 && ($ = v.ref), v.key !== void 0 && (ti = "" + v.key), v)
        b.call(v, li) && !S.hasOwnProperty(li) && (ii[li] = v[li]);
    var ai = arguments.length - 2;
    if (ai === 1)
      ii.children = O;
    else if (1 < ai) {
      for (var Xi = Array(ai), z = 0; z < ai; z++)
        Xi[z] = arguments[z + 2];
      ii.children = Xi;
    }
    if (F && F.defaultProps)
      for (li in ai = F.defaultProps, ai)
        ii[li] === void 0 && (ii[li] = ai[li]);
    return { $$typeof: n, type: F, key: ti, ref: $, props: ii, _owner: V.current };
  }
  function T(F, v) {
    return { $$typeof: n, type: F.type, key: v, ref: F.ref, props: F.props, _owner: F._owner };
  }
  function y(F) {
    return typeof F == "object" && F !== null && F.$$typeof === n;
  }
  function J(F) {
    var v = { "=": "=0", ":": "=2" };
    return "$" + F.replace(/[=:]/g, function(O) {
      return v[O];
    });
  }
  var N = /\/+/g;
  function R(F, v) {
    return typeof F == "object" && F !== null && F.key != null ? J("" + F.key) : v.toString(36);
  }
  function x(F, v, O, li, ii) {
    var ti = typeof F;
    (ti === "undefined" || ti === "boolean") && (F = null);
    var $ = !1;
    if (F === null)
      $ = !0;
    else
      switch (ti) {
        case "string":
        case "number":
          $ = !0;
          break;
        case "object":
          switch (F.$$typeof) {
            case n:
            case l:
              $ = !0;
          }
      }
    if ($)
      return $ = F, ii = ii($), F = li === "" ? "." + R($, 0) : li, s(ii) ? (O = "", F != null && (O = F.replace(N, "$&/") + "/"), x(ii, v, O, "", function(z) {
        return z;
      })) : ii != null && (y(ii) && (ii = T(ii, O + (!ii.key || $ && $.key === ii.key ? "" : ("" + ii.key).replace(N, "$&/") + "/") + F)), v.push(ii)), 1;
    if ($ = 0, li = li === "" ? "." : li + ":", s(F))
      for (var ai = 0; ai < F.length; ai++) {
        ti = F[ai];
        var Xi = li + R(ti, ai);
        $ += x(ti, v, O, Xi, ii);
      }
    else if (Xi = W(F), typeof Xi == "function")
      for (F = Xi.call(F), ai = 0; !(ti = F.next()).done; )
        ti = ti.value, Xi = li + R(ti, ai++), $ += x(ti, v, O, Xi, ii);
    else if (ti === "object")
      throw v = String(F), Error("Objects are not valid as a React child (found: " + (v === "[object Object]" ? "object with keys {" + Object.keys(F).join(", ") + "}" : v) + "). If you meant to render a collection of children, use an array instead.");
    return $;
  }
  function M(F, v, O) {
    if (F == null)
      return F;
    var li = [], ii = 0;
    return x(F, li, "", "", function(ti) {
      return v.call(O, ti, ii++);
    }), li;
  }
  function Q(F) {
    if (F._status === -1) {
      var v = F._result;
      v = v(), v.then(function(O) {
        (F._status === 0 || F._status === -1) && (F._status = 1, F._result = O);
      }, function(O) {
        (F._status === 0 || F._status === -1) && (F._status = 2, F._result = O);
      }), F._status === -1 && (F._status = 0, F._result = v);
    }
    if (F._status === 1)
      return F._result.default;
    throw F._result;
  }
  var P = { current: null }, D = { transition: null }, _ = { ReactCurrentDispatcher: P, ReactCurrentBatchConfig: D, ReactCurrentOwner: V };
  return Yi.Children = { map: M, forEach: function(F, v, O) {
    M(F, function() {
      v.apply(this, arguments);
    }, O);
  }, count: function(F) {
    var v = 0;
    return M(F, function() {
      v++;
    }), v;
  }, toArray: function(F) {
    return M(F, function(v) {
      return v;
    }) || [];
  }, only: function(F) {
    if (!y(F))
      throw Error("React.Children.only expected to receive a single React element child.");
    return F;
  } }, Yi.Component = o, Yi.Fragment = i, Yi.Profiler = Z, Yi.PureComponent = d, Yi.StrictMode = c, Yi.Suspense = a, Yi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _, Yi.cloneElement = function(F, v, O) {
    if (F == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + F + ".");
    var li = C({}, F.props), ii = F.key, ti = F.ref, $ = F._owner;
    if (v != null) {
      if (v.ref !== void 0 && (ti = v.ref, $ = V.current), v.key !== void 0 && (ii = "" + v.key), F.type && F.type.defaultProps)
        var ai = F.type.defaultProps;
      for (Xi in v)
        b.call(v, Xi) && !S.hasOwnProperty(Xi) && (li[Xi] = v[Xi] === void 0 && ai !== void 0 ? ai[Xi] : v[Xi]);
    }
    var Xi = arguments.length - 2;
    if (Xi === 1)
      li.children = O;
    else if (1 < Xi) {
      ai = Array(Xi);
      for (var z = 0; z < Xi; z++)
        ai[z] = arguments[z + 2];
      li.children = ai;
    }
    return { $$typeof: n, type: F.type, key: ii, ref: ti, props: li, _owner: $ };
  }, Yi.createContext = function(F) {
    return F = { $$typeof: K, _currentValue: F, _currentValue2: F, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, F.Provider = { $$typeof: L, _context: F }, F.Consumer = F;
  }, Yi.createElement = Y, Yi.createFactory = function(F) {
    var v = Y.bind(null, F);
    return v.type = F, v;
  }, Yi.createRef = function() {
    return { current: null };
  }, Yi.forwardRef = function(F) {
    return { $$typeof: u, render: F };
  }, Yi.isValidElement = y, Yi.lazy = function(F) {
    return { $$typeof: r, _payload: { _status: -1, _result: F }, _init: Q };
  }, Yi.memo = function(F, v) {
    return { $$typeof: e, type: F, compare: v === void 0 ? null : v };
  }, Yi.startTransition = function(F) {
    var v = D.transition;
    D.transition = {};
    try {
      F();
    } finally {
      D.transition = v;
    }
  }, Yi.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, Yi.useCallback = function(F, v) {
    return P.current.useCallback(F, v);
  }, Yi.useContext = function(F) {
    return P.current.useContext(F);
  }, Yi.useDebugValue = function() {
  }, Yi.useDeferredValue = function(F) {
    return P.current.useDeferredValue(F);
  }, Yi.useEffect = function(F, v) {
    return P.current.useEffect(F, v);
  }, Yi.useId = function() {
    return P.current.useId();
  }, Yi.useImperativeHandle = function(F, v, O) {
    return P.current.useImperativeHandle(F, v, O);
  }, Yi.useInsertionEffect = function(F, v) {
    return P.current.useInsertionEffect(F, v);
  }, Yi.useLayoutEffect = function(F, v) {
    return P.current.useLayoutEffect(F, v);
  }, Yi.useMemo = function(F, v) {
    return P.current.useMemo(F, v);
  }, Yi.useReducer = function(F, v, O) {
    return P.current.useReducer(F, v, O);
  }, Yi.useRef = function(F) {
    return P.current.useRef(F);
  }, Yi.useState = function(F) {
    return P.current.useState(F);
  }, Yi.useSyncExternalStore = function(F, v, O) {
    return P.current.useSyncExternalStore(F, v, O);
  }, Yi.useTransition = function() {
    return P.current.useTransition();
  }, Yi.version = "18.2.0", Yi;
}
process.env.NODE_ENV === "production" ? Yd.exports = d0() : Yd.exports = l0();
var pl = Yd.exports;
const s0 = "index-module__Container__nLsM3", t0 = "index-module__FloatCanvas__d1YR7", Id = {
  Container: s0,
  FloatCanvas: t0
};
class il extends pl.Component {
  constructor(l) {
    super(l), Object.defineProperty(this, "containerRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasFloatRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "canvasBgRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    il.instance = this, il.displayState$.set(el.mounted);
  }
  componentWillUnmount() {
    il.displayState$.set(el.unmounted);
  }
  render() {
    return pl.createElement(
      pl.Fragment,
      null,
      this.props.children,
      pl.createElement(
        "div",
        { id: "bezier-pencil-plugin", className: Id.Container, ref: (l) => this.containerRef = l },
        pl.createElement("canvas", { className: Id.FloatCanvas, id: "bezier-pencil-float-canvas", ref: (l) => this.canvasFloatRef = l }),
        pl.createElement("canvas", { className: Id.BgCanvas, id: "bezier-pencil-bg-canvas", ref: (l) => this.canvasBgRef = l })
      )
    );
  }
}
Object.defineProperty(il, "displayState$", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: It(el.pedding)
});
class b0 {
  setNamespace(l) {
    this.namespace = l, this.storage = gd(this.plugin.attributes[l]) || {};
  }
  isLocalId(l) {
    return l.split("@##@").length === 1;
  }
  getLocalId(l) {
    return l.split("@##@")[1];
  }
}
function c0() {
  this.__data__ = [], this.size = 0;
}
var m0 = c0;
function Z0(n, l) {
  return n === l || n !== n && l !== l;
}
var kd = Z0, n0 = kd;
function X0(n, l) {
  for (var i = n.length; i--; )
    if (n0(n[i][0], l))
      return i;
  return -1;
}
var _l = X0, o0 = _l, a0 = Array.prototype, e0 = a0.splice;
function W0(n) {
  var l = this.__data__, i = o0(l, n);
  if (i < 0)
    return !1;
  var c = l.length - 1;
  return i == c ? l.pop() : e0.call(l, i, 1), --this.size, !0;
}
var u0 = W0, G0 = _l;
function V0(n) {
  var l = this.__data__, i = G0(l, n);
  return i < 0 ? void 0 : l[i][1];
}
var h0 = V0, I0 = _l;
function p0(n) {
  return I0(this.__data__, n) > -1;
}
var L0 = p0, y0 = _l;
function r0(n, l) {
  var i = this.__data__, c = y0(i, n);
  return c < 0 ? (++this.size, i.push([n, l])) : i[c][1] = l, this;
}
var K0 = r0, S0 = m0, x0 = u0, R0 = h0, Y0 = L0, C0 = K0;
function rl(n) {
  var l = -1, i = n == null ? 0 : n.length;
  for (this.clear(); ++l < i; ) {
    var c = n[l];
    this.set(c[0], c[1]);
  }
}
rl.prototype.clear = S0;
rl.prototype.delete = x0;
rl.prototype.get = R0;
rl.prototype.has = Y0;
rl.prototype.set = C0;
var id = rl, J0 = id;
function F0() {
  this.__data__ = new J0(), this.size = 0;
}
var T0 = F0;
function N0(n) {
  var l = this.__data__, i = l.delete(n);
  return this.size = l.size, i;
}
var g0 = N0;
function H0(n) {
  return this.__data__.get(n);
}
var M0 = H0;
function z0(n) {
  return this.__data__.has(n);
}
var k0 = z0, f0 = typeof Pl == "object" && Pl && Pl.Object === Object && Pl, pt = f0, v0 = pt, U0 = typeof self == "object" && self && self.Object === Object && self, Q0 = v0 || U0 || Function("return this")(), tl = Q0, P0 = tl, E0 = P0.Symbol, ld = E0, Rs = ld, Lt = Object.prototype, w0 = Lt.hasOwnProperty, j0 = Lt.toString, Cl = Rs ? Rs.toStringTag : void 0;
function B0(n) {
  var l = w0.call(n, Cl), i = n[Cl];
  try {
    n[Cl] = void 0;
    var c = !0;
  } catch {
  }
  var Z = j0.call(n);
  return c && (l ? n[Cl] = i : delete n[Cl]), Z;
}
var O0 = B0, D0 = Object.prototype, A0 = D0.toString;
function q0(n) {
  return A0.call(n);
}
var $0 = q0, Ys = ld, _0 = O0, ic = $0, lc = "[object Null]", dc = "[object Undefined]", Cs = Ys ? Ys.toStringTag : void 0;
function sc(n) {
  return n == null ? n === void 0 ? dc : lc : Cs && Cs in Object(n) ? _0(n) : ic(n);
}
var gl = sc;
function tc(n) {
  var l = typeof n;
  return n != null && (l == "object" || l == "function");
}
var ml = tc, bc = gl, cc = ml, mc = "[object AsyncFunction]", Zc = "[object Function]", nc = "[object GeneratorFunction]", Xc = "[object Proxy]";
function oc(n) {
  if (!cc(n))
    return !1;
  var l = bc(n);
  return l == Zc || l == nc || l == mc || l == Xc;
}
var yt = oc, ac = tl, ec = ac["__core-js_shared__"], Wc = ec, pd = Wc, Js = function() {
  var n = /[^.]+$/.exec(pd && pd.keys && pd.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function uc(n) {
  return !!Js && Js in n;
}
var Gc = uc, Vc = Function.prototype, hc = Vc.toString;
function Ic(n) {
  if (n != null) {
    try {
      return hc.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var rt = Ic, pc = yt, Lc = Gc, yc = ml, rc = rt, Kc = /[\\^$.*+?()[\]{}|]/g, Sc = /^\[object .+?Constructor\]$/, xc = Function.prototype, Rc = Object.prototype, Yc = xc.toString, Cc = Rc.hasOwnProperty, Jc = RegExp(
  "^" + Yc.call(Cc).replace(Kc, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Fc(n) {
  if (!yc(n) || Lc(n))
    return !1;
  var l = pc(n) ? Jc : Sc;
  return l.test(rc(n));
}
var Tc = Fc;
function Nc(n, l) {
  return n == null ? void 0 : n[l];
}
var gc = Nc, Hc = Tc, Mc = gc;
function zc(n, l) {
  var i = Mc(n, l);
  return Hc(i) ? i : void 0;
}
var Wl = zc, kc = Wl, fc = tl, vc = kc(fc, "Map"), fd = vc, Uc = Wl, Qc = Uc(Object, "create"), dd = Qc, Fs = dd;
function Pc() {
  this.__data__ = Fs ? Fs(null) : {}, this.size = 0;
}
var Ec = Pc;
function wc(n) {
  var l = this.has(n) && delete this.__data__[n];
  return this.size -= l ? 1 : 0, l;
}
var jc = wc, Bc = dd, Oc = "__lodash_hash_undefined__", Dc = Object.prototype, Ac = Dc.hasOwnProperty;
function qc(n) {
  var l = this.__data__;
  if (Bc) {
    var i = l[n];
    return i === Oc ? void 0 : i;
  }
  return Ac.call(l, n) ? l[n] : void 0;
}
var $c = qc, _c = dd, im = Object.prototype, lm = im.hasOwnProperty;
function dm(n) {
  var l = this.__data__;
  return _c ? l[n] !== void 0 : lm.call(l, n);
}
var sm = dm, tm = dd, bm = "__lodash_hash_undefined__";
function cm(n, l) {
  var i = this.__data__;
  return this.size += this.has(n) ? 0 : 1, i[n] = tm && l === void 0 ? bm : l, this;
}
var mm = cm, Zm = Ec, nm = jc, Xm = $c, om = sm, am = mm;
function Kl(n) {
  var l = -1, i = n == null ? 0 : n.length;
  for (this.clear(); ++l < i; ) {
    var c = n[l];
    this.set(c[0], c[1]);
  }
}
Kl.prototype.clear = Zm;
Kl.prototype.delete = nm;
Kl.prototype.get = Xm;
Kl.prototype.has = om;
Kl.prototype.set = am;
var em = Kl, Ts = em, Wm = id, um = fd;
function Gm() {
  this.size = 0, this.__data__ = {
    hash: new Ts(),
    map: new (um || Wm)(),
    string: new Ts()
  };
}
var Vm = Gm;
function hm(n) {
  var l = typeof n;
  return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? n !== "__proto__" : n === null;
}
var Im = hm, pm = Im;
function Lm(n, l) {
  var i = n.__data__;
  return pm(l) ? i[typeof l == "string" ? "string" : "hash"] : i.map;
}
var sd = Lm, ym = sd;
function rm(n) {
  var l = ym(this, n).delete(n);
  return this.size -= l ? 1 : 0, l;
}
var Km = rm, Sm = sd;
function xm(n) {
  return Sm(this, n).get(n);
}
var Rm = xm, Ym = sd;
function Cm(n) {
  return Ym(this, n).has(n);
}
var Jm = Cm, Fm = sd;
function Tm(n, l) {
  var i = Fm(this, n), c = i.size;
  return i.set(n, l), this.size += i.size == c ? 0 : 1, this;
}
var Nm = Tm, gm = Vm, Hm = Km, Mm = Rm, zm = Jm, km = Nm;
function Sl(n) {
  var l = -1, i = n == null ? 0 : n.length;
  for (this.clear(); ++l < i; ) {
    var c = n[l];
    this.set(c[0], c[1]);
  }
}
Sl.prototype.clear = gm;
Sl.prototype.delete = Hm;
Sl.prototype.get = Mm;
Sl.prototype.has = zm;
Sl.prototype.set = km;
var Kt = Sl, fm = id, vm = fd, Um = Kt, Qm = 200;
function Pm(n, l) {
  var i = this.__data__;
  if (i instanceof fm) {
    var c = i.__data__;
    if (!vm || c.length < Qm - 1)
      return c.push([n, l]), this.size = ++i.size, this;
    i = this.__data__ = new Um(c);
  }
  return i.set(n, l), this.size = i.size, this;
}
var Em = Pm, wm = id, jm = T0, Bm = g0, Om = M0, Dm = k0, Am = Em;
function xl(n) {
  var l = this.__data__ = new wm(n);
  this.size = l.size;
}
xl.prototype.clear = jm;
xl.prototype.delete = Bm;
xl.prototype.get = Om;
xl.prototype.has = Dm;
xl.prototype.set = Am;
var St = xl, qm = "__lodash_hash_undefined__";
function $m(n) {
  return this.__data__.set(n, qm), this;
}
var _m = $m;
function iZ(n) {
  return this.__data__.has(n);
}
var lZ = iZ, dZ = Kt, sZ = _m, tZ = lZ;
function Dl(n) {
  var l = -1, i = n == null ? 0 : n.length;
  for (this.__data__ = new dZ(); ++l < i; )
    this.add(n[l]);
}
Dl.prototype.add = Dl.prototype.push = sZ;
Dl.prototype.has = tZ;
var bZ = Dl;
function cZ(n, l) {
  for (var i = -1, c = n == null ? 0 : n.length; ++i < c; )
    if (l(n[i], i, n))
      return !0;
  return !1;
}
var mZ = cZ;
function ZZ(n, l) {
  return n.has(l);
}
var nZ = ZZ, XZ = bZ, oZ = mZ, aZ = nZ, eZ = 1, WZ = 2;
function uZ(n, l, i, c, Z, L) {
  var K = i & eZ, u = n.length, a = l.length;
  if (u != a && !(K && a > u))
    return !1;
  var e = L.get(n), r = L.get(l);
  if (e && r)
    return e == l && r == n;
  var X = -1, W = !0, p = i & WZ ? new XZ() : void 0;
  for (L.set(n, l), L.set(l, n); ++X < u; ) {
    var C = n[X], I = l[X];
    if (c)
      var o = K ? c(I, C, X, l, n, L) : c(C, I, X, n, l, L);
    if (o !== void 0) {
      if (o)
        continue;
      W = !1;
      break;
    }
    if (p) {
      if (!oZ(l, function(G, d) {
        if (!aZ(p, d) && (C === G || Z(C, G, i, c, L)))
          return p.push(d);
      })) {
        W = !1;
        break;
      }
    } else if (!(C === I || Z(C, I, i, c, L))) {
      W = !1;
      break;
    }
  }
  return L.delete(n), L.delete(l), W;
}
var xt = uZ, GZ = tl, VZ = GZ.Uint8Array, Rt = VZ;
function hZ(n) {
  var l = -1, i = Array(n.size);
  return n.forEach(function(c, Z) {
    i[++l] = [Z, c];
  }), i;
}
var IZ = hZ;
function pZ(n) {
  var l = -1, i = Array(n.size);
  return n.forEach(function(c) {
    i[++l] = c;
  }), i;
}
var LZ = pZ, Ns = ld, gs = Rt, yZ = kd, rZ = xt, KZ = IZ, SZ = LZ, xZ = 1, RZ = 2, YZ = "[object Boolean]", CZ = "[object Date]", JZ = "[object Error]", FZ = "[object Map]", TZ = "[object Number]", NZ = "[object RegExp]", gZ = "[object Set]", HZ = "[object String]", MZ = "[object Symbol]", zZ = "[object ArrayBuffer]", kZ = "[object DataView]", Hs = Ns ? Ns.prototype : void 0, Ld = Hs ? Hs.valueOf : void 0;
function fZ(n, l, i, c, Z, L, K) {
  switch (i) {
    case kZ:
      if (n.byteLength != l.byteLength || n.byteOffset != l.byteOffset)
        return !1;
      n = n.buffer, l = l.buffer;
    case zZ:
      return !(n.byteLength != l.byteLength || !L(new gs(n), new gs(l)));
    case YZ:
    case CZ:
    case TZ:
      return yZ(+n, +l);
    case JZ:
      return n.name == l.name && n.message == l.message;
    case NZ:
    case HZ:
      return n == l + "";
    case FZ:
      var u = KZ;
    case gZ:
      var a = c & xZ;
      if (u || (u = SZ), n.size != l.size && !a)
        return !1;
      var e = K.get(n);
      if (e)
        return e == l;
      c |= RZ, K.set(n, l);
      var r = rZ(u(n), u(l), c, Z, L, K);
      return K.delete(n), r;
    case MZ:
      if (Ld)
        return Ld.call(n) == Ld.call(l);
  }
  return !1;
}
var vZ = fZ;
function UZ(n, l) {
  for (var i = -1, c = l.length, Z = n.length; ++i < c; )
    n[Z + i] = l[i];
  return n;
}
var Yt = UZ, QZ = Array.isArray, td = QZ, PZ = Yt, EZ = td;
function wZ(n, l, i) {
  var c = l(n);
  return EZ(n) ? c : PZ(c, i(n));
}
var Ct = wZ;
function jZ(n, l) {
  for (var i = -1, c = n == null ? 0 : n.length, Z = 0, L = []; ++i < c; ) {
    var K = n[i];
    l(K, i, n) && (L[Z++] = K);
  }
  return L;
}
var BZ = jZ;
function OZ() {
  return [];
}
var Jt = OZ, DZ = BZ, AZ = Jt, qZ = Object.prototype, $Z = qZ.propertyIsEnumerable, Ms = Object.getOwnPropertySymbols, _Z = Ms ? function(n) {
  return n == null ? [] : (n = Object(n), DZ(Ms(n), function(l) {
    return $Z.call(n, l);
  }));
} : AZ, vd = _Z;
function ln(n, l) {
  for (var i = -1, c = Array(n); ++i < n; )
    c[i] = l(i);
  return c;
}
var dn = ln;
function sn(n) {
  return n != null && typeof n == "object";
}
var ul = sn, tn = gl, bn = ul, cn = "[object Arguments]";
function mn(n) {
  return bn(n) && tn(n) == cn;
}
var Zn = mn, zs = Zn, nn = ul, Ft = Object.prototype, Xn = Ft.hasOwnProperty, on = Ft.propertyIsEnumerable, an = zs(/* @__PURE__ */ function() {
  return arguments;
}()) ? zs : function(n) {
  return nn(n) && Xn.call(n, "callee") && !on.call(n, "callee");
}, en = an, Al = { exports: {} };
function Wn() {
  return !1;
}
var un = Wn;
Al.exports;
(function(n, l) {
  var i = tl, c = un, Z = l && !l.nodeType && l, L = Z && !0 && n && !n.nodeType && n, K = L && L.exports === Z, u = K ? i.Buffer : void 0, a = u ? u.isBuffer : void 0, e = a || c;
  n.exports = e;
})(Al, Al.exports);
var Ud = Al.exports, Gn = 9007199254740991, Vn = /^(?:0|[1-9]\d*)$/;
function hn(n, l) {
  var i = typeof n;
  return l = l ?? Gn, !!l && (i == "number" || i != "symbol" && Vn.test(n)) && n > -1 && n % 1 == 0 && n < l;
}
var In = hn, pn = 9007199254740991;
function Ln(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= pn;
}
var Tt = Ln, yn = gl, rn = Tt, Kn = ul, Sn = "[object Arguments]", xn = "[object Array]", Rn = "[object Boolean]", Yn = "[object Date]", Cn = "[object Error]", Jn = "[object Function]", Fn = "[object Map]", Tn = "[object Number]", Nn = "[object Object]", gn = "[object RegExp]", Hn = "[object Set]", Mn = "[object String]", zn = "[object WeakMap]", kn = "[object ArrayBuffer]", fn = "[object DataView]", vn = "[object Float32Array]", Un = "[object Float64Array]", Qn = "[object Int8Array]", Pn = "[object Int16Array]", En = "[object Int32Array]", wn = "[object Uint8Array]", jn = "[object Uint8ClampedArray]", Bn = "[object Uint16Array]", On = "[object Uint32Array]", Mi = {};
Mi[vn] = Mi[Un] = Mi[Qn] = Mi[Pn] = Mi[En] = Mi[wn] = Mi[jn] = Mi[Bn] = Mi[On] = !0;
Mi[Sn] = Mi[xn] = Mi[kn] = Mi[Rn] = Mi[fn] = Mi[Yn] = Mi[Cn] = Mi[Jn] = Mi[Fn] = Mi[Tn] = Mi[Nn] = Mi[gn] = Mi[Hn] = Mi[Mn] = Mi[zn] = !1;
function Dn(n) {
  return Kn(n) && rn(n.length) && !!Mi[yn(n)];
}
var An = Dn;
function qn(n) {
  return function(l) {
    return n(l);
  };
}
var Qd = qn, ql = { exports: {} };
ql.exports;
(function(n, l) {
  var i = pt, c = l && !l.nodeType && l, Z = c && !0 && n && !n.nodeType && n, L = Z && Z.exports === c, K = L && i.process, u = function() {
    try {
      var a = Z && Z.require && Z.require("util").types;
      return a || K && K.binding && K.binding("util");
    } catch {
    }
  }();
  n.exports = u;
})(ql, ql.exports);
var Pd = ql.exports, $n = An, _n = Qd, ks = Pd, fs = ks && ks.isTypedArray, iX = fs ? _n(fs) : $n, Nt = iX, lX = dn, dX = en, sX = td, tX = Ud, bX = In, cX = Nt, mX = Object.prototype, ZX = mX.hasOwnProperty;
function nX(n, l) {
  var i = sX(n), c = !i && dX(n), Z = !i && !c && tX(n), L = !i && !c && !Z && cX(n), K = i || c || Z || L, u = K ? lX(n.length, String) : [], a = u.length;
  for (var e in n)
    (l || ZX.call(n, e)) && !(K && // Safari 9 has enumerable `arguments.length` in strict mode.
    (e == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    Z && (e == "offset" || e == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    L && (e == "buffer" || e == "byteLength" || e == "byteOffset") || // Skip index properties.
    bX(e, a))) && u.push(e);
  return u;
}
var gt = nX, XX = Object.prototype;
function oX(n) {
  var l = n && n.constructor, i = typeof l == "function" && l.prototype || XX;
  return n === i;
}
var Ed = oX;
function aX(n, l) {
  return function(i) {
    return n(l(i));
  };
}
var Ht = aX, eX = Ht, WX = eX(Object.keys, Object), uX = WX, GX = Ed, VX = uX, hX = Object.prototype, IX = hX.hasOwnProperty;
function pX(n) {
  if (!GX(n))
    return VX(n);
  var l = [];
  for (var i in Object(n))
    IX.call(n, i) && i != "constructor" && l.push(i);
  return l;
}
var LX = pX, yX = yt, rX = Tt;
function KX(n) {
  return n != null && rX(n.length) && !yX(n);
}
var Mt = KX, SX = gt, xX = LX, RX = Mt;
function YX(n) {
  return RX(n) ? SX(n) : xX(n);
}
var wd = YX, CX = Ct, JX = vd, FX = wd;
function TX(n) {
  return CX(n, FX, JX);
}
var zt = TX, vs = zt, NX = 1, gX = Object.prototype, HX = gX.hasOwnProperty;
function MX(n, l, i, c, Z, L) {
  var K = i & NX, u = vs(n), a = u.length, e = vs(l), r = e.length;
  if (a != r && !K)
    return !1;
  for (var X = a; X--; ) {
    var W = u[X];
    if (!(K ? W in l : HX.call(l, W)))
      return !1;
  }
  var p = L.get(n), C = L.get(l);
  if (p && C)
    return p == l && C == n;
  var I = !0;
  L.set(n, l), L.set(l, n);
  for (var o = K; ++X < a; ) {
    W = u[X];
    var G = n[W], d = l[W];
    if (c)
      var t = K ? c(d, G, W, l, n, L) : c(G, d, W, n, l, L);
    if (!(t === void 0 ? G === d || Z(G, d, i, c, L) : t)) {
      I = !1;
      break;
    }
    o || (o = W == "constructor");
  }
  if (I && !o) {
    var s = n.constructor, b = l.constructor;
    s != b && "constructor" in n && "constructor" in l && !(typeof s == "function" && s instanceof s && typeof b == "function" && b instanceof b) && (I = !1);
  }
  return L.delete(n), L.delete(l), I;
}
var zX = MX, kX = Wl, fX = tl, vX = kX(fX, "DataView"), UX = vX, QX = Wl, PX = tl, EX = QX(PX, "Promise"), wX = EX, jX = Wl, BX = tl, OX = jX(BX, "Set"), DX = OX, AX = Wl, qX = tl, $X = AX(qX, "WeakMap"), _X = $X, Cd = UX, Jd = fd, Fd = wX, Td = DX, Nd = _X, kt = gl, Rl = rt, Us = "[object Map]", io = "[object Object]", Qs = "[object Promise]", Ps = "[object Set]", Es = "[object WeakMap]", ws = "[object DataView]", lo = Rl(Cd), so = Rl(Jd), to = Rl(Fd), bo = Rl(Td), co = Rl(Nd), ol = kt;
(Cd && ol(new Cd(new ArrayBuffer(1))) != ws || Jd && ol(new Jd()) != Us || Fd && ol(Fd.resolve()) != Qs || Td && ol(new Td()) != Ps || Nd && ol(new Nd()) != Es) && (ol = function(n) {
  var l = kt(n), i = l == io ? n.constructor : void 0, c = i ? Rl(i) : "";
  if (c)
    switch (c) {
      case lo:
        return ws;
      case so:
        return Us;
      case to:
        return Qs;
      case bo:
        return Ps;
      case co:
        return Es;
    }
  return l;
});
var bd = ol, yd = St, mo = xt, Zo = vZ, no = zX, js = bd, Bs = td, Os = Ud, Xo = Nt, oo = 1, Ds = "[object Arguments]", As = "[object Array]", El = "[object Object]", ao = Object.prototype, qs = ao.hasOwnProperty;
function eo(n, l, i, c, Z, L) {
  var K = Bs(n), u = Bs(l), a = K ? As : js(n), e = u ? As : js(l);
  a = a == Ds ? El : a, e = e == Ds ? El : e;
  var r = a == El, X = e == El, W = a == e;
  if (W && Os(n)) {
    if (!Os(l))
      return !1;
    K = !0, r = !1;
  }
  if (W && !r)
    return L || (L = new yd()), K || Xo(n) ? mo(n, l, i, c, Z, L) : Zo(n, l, a, i, c, Z, L);
  if (!(i & oo)) {
    var p = r && qs.call(n, "__wrapped__"), C = X && qs.call(l, "__wrapped__");
    if (p || C) {
      var I = p ? n.value() : n, o = C ? l.value() : l;
      return L || (L = new yd()), Z(I, o, i, c, L);
    }
  }
  return W ? (L || (L = new yd()), no(n, l, i, c, Z, L)) : !1;
}
var Wo = eo, uo = Wo, $s = ul;
function ft(n, l, i, c, Z) {
  return n === l ? !0 : n == null || l == null || !$s(n) && !$s(l) ? n !== n && l !== l : uo(n, l, i, c, ft, Z);
}
var Go = ft, Vo = Go;
function ho(n, l) {
  return Vo(n, l);
}
var Io = ho;
const _s = /* @__PURE__ */ Hd(Io);
function po(n, l) {
  for (var i = -1, c = n == null ? 0 : n.length; ++i < c && l(n[i], i, n) !== !1; )
    ;
  return n;
}
var Lo = po, yo = Wl, ro = function() {
  try {
    var n = yo(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), Ko = ro, it = Ko;
function So(n, l, i) {
  l == "__proto__" && it ? it(n, l, {
    configurable: !0,
    enumerable: !0,
    value: i,
    writable: !0
  }) : n[l] = i;
}
var vt = So, xo = vt, Ro = kd, Yo = Object.prototype, Co = Yo.hasOwnProperty;
function Jo(n, l, i) {
  var c = n[l];
  (!(Co.call(n, l) && Ro(c, i)) || i === void 0 && !(l in n)) && xo(n, l, i);
}
var Ut = Jo, Fo = Ut, To = vt;
function No(n, l, i, c) {
  var Z = !i;
  i || (i = {});
  for (var L = -1, K = l.length; ++L < K; ) {
    var u = l[L], a = c ? c(i[u], n[u], u, i, n) : void 0;
    a === void 0 && (a = n[u]), Z ? To(i, u, a) : Fo(i, u, a);
  }
  return i;
}
var cd = No, go = cd, Ho = wd;
function Mo(n, l) {
  return n && go(l, Ho(l), n);
}
var zo = Mo;
function ko(n) {
  var l = [];
  if (n != null)
    for (var i in Object(n))
      l.push(i);
  return l;
}
var fo = ko, vo = ml, Uo = Ed, Qo = fo, Po = Object.prototype, Eo = Po.hasOwnProperty;
function wo(n) {
  if (!vo(n))
    return Qo(n);
  var l = Uo(n), i = [];
  for (var c in n)
    c == "constructor" && (l || !Eo.call(n, c)) || i.push(c);
  return i;
}
var jo = wo, Bo = gt, Oo = jo, Do = Mt;
function Ao(n) {
  return Do(n) ? Bo(n, !0) : Oo(n);
}
var jd = Ao, qo = cd, $o = jd;
function _o(n, l) {
  return n && qo(l, $o(l), n);
}
var ia = _o, $l = { exports: {} };
$l.exports;
(function(n, l) {
  var i = tl, c = l && !l.nodeType && l, Z = c && !0 && n && !n.nodeType && n, L = Z && Z.exports === c, K = L ? i.Buffer : void 0, u = K ? K.allocUnsafe : void 0;
  function a(e, r) {
    if (r)
      return e.slice();
    var X = e.length, W = u ? u(X) : new e.constructor(X);
    return e.copy(W), W;
  }
  n.exports = a;
})($l, $l.exports);
var la = $l.exports;
function da(n, l) {
  var i = -1, c = n.length;
  for (l || (l = Array(c)); ++i < c; )
    l[i] = n[i];
  return l;
}
var sa = da, ta = cd, ba = vd;
function ca(n, l) {
  return ta(n, ba(n), l);
}
var ma = ca, Za = Ht, na = Za(Object.getPrototypeOf, Object), Qt = na, Xa = Yt, oa = Qt, aa = vd, ea = Jt, Wa = Object.getOwnPropertySymbols, ua = Wa ? function(n) {
  for (var l = []; n; )
    Xa(l, aa(n)), n = oa(n);
  return l;
} : ea, Pt = ua, Ga = cd, Va = Pt;
function ha(n, l) {
  return Ga(n, Va(n), l);
}
var Ia = ha, pa = Ct, La = Pt, ya = jd;
function ra(n) {
  return pa(n, ya, La);
}
var Ka = ra, Sa = Object.prototype, xa = Sa.hasOwnProperty;
function Ra(n) {
  var l = n.length, i = new n.constructor(l);
  return l && typeof n[0] == "string" && xa.call(n, "index") && (i.index = n.index, i.input = n.input), i;
}
var Ya = Ra, lt = Rt;
function Ca(n) {
  var l = new n.constructor(n.byteLength);
  return new lt(l).set(new lt(n)), l;
}
var Bd = Ca, Ja = Bd;
function Fa(n, l) {
  var i = l ? Ja(n.buffer) : n.buffer;
  return new n.constructor(i, n.byteOffset, n.byteLength);
}
var Ta = Fa, Na = /\w*$/;
function ga(n) {
  var l = new n.constructor(n.source, Na.exec(n));
  return l.lastIndex = n.lastIndex, l;
}
var Ha = ga, dt = ld, st = dt ? dt.prototype : void 0, tt = st ? st.valueOf : void 0;
function Ma(n) {
  return tt ? Object(tt.call(n)) : {};
}
var za = Ma, ka = Bd;
function fa(n, l) {
  var i = l ? ka(n.buffer) : n.buffer;
  return new n.constructor(i, n.byteOffset, n.length);
}
var va = fa, Ua = Bd, Qa = Ta, Pa = Ha, Ea = za, wa = va, ja = "[object Boolean]", Ba = "[object Date]", Oa = "[object Map]", Da = "[object Number]", Aa = "[object RegExp]", qa = "[object Set]", $a = "[object String]", _a = "[object Symbol]", ie = "[object ArrayBuffer]", le = "[object DataView]", de = "[object Float32Array]", se = "[object Float64Array]", te = "[object Int8Array]", be = "[object Int16Array]", ce = "[object Int32Array]", me = "[object Uint8Array]", Ze = "[object Uint8ClampedArray]", ne = "[object Uint16Array]", Xe = "[object Uint32Array]";
function oe(n, l, i) {
  var c = n.constructor;
  switch (l) {
    case ie:
      return Ua(n);
    case ja:
    case Ba:
      return new c(+n);
    case le:
      return Qa(n, i);
    case de:
    case se:
    case te:
    case be:
    case ce:
    case me:
    case Ze:
    case ne:
    case Xe:
      return wa(n, i);
    case Oa:
      return new c();
    case Da:
    case $a:
      return new c(n);
    case Aa:
      return Pa(n);
    case qa:
      return new c();
    case _a:
      return Ea(n);
  }
}
var ae = oe, ee = ml, bt = Object.create, We = /* @__PURE__ */ function() {
  function n() {
  }
  return function(l) {
    if (!ee(l))
      return {};
    if (bt)
      return bt(l);
    n.prototype = l;
    var i = new n();
    return n.prototype = void 0, i;
  };
}(), ue = We, Ge = ue, Ve = Qt, he = Ed;
function Ie(n) {
  return typeof n.constructor == "function" && !he(n) ? Ge(Ve(n)) : {};
}
var pe = Ie, Le = bd, ye = ul, re = "[object Map]";
function Ke(n) {
  return ye(n) && Le(n) == re;
}
var Se = Ke, xe = Se, Re = Qd, ct = Pd, mt = ct && ct.isMap, Ye = mt ? Re(mt) : xe, Ce = Ye, Je = bd, Fe = ul, Te = "[object Set]";
function Ne(n) {
  return Fe(n) && Je(n) == Te;
}
var ge = Ne, He = ge, Me = Qd, Zt = Pd, nt = Zt && Zt.isSet, ze = nt ? Me(nt) : He, ke = ze, fe = St, ve = Lo, Ue = Ut, Qe = zo, Pe = ia, Ee = la, we = sa, je = ma, Be = Ia, Oe = zt, De = Ka, Ae = bd, qe = Ya, $e = ae, _e = pe, iW = td, lW = Ud, dW = Ce, sW = ml, tW = ke, bW = wd, cW = jd, mW = 1, ZW = 2, nW = 4, Et = "[object Arguments]", XW = "[object Array]", oW = "[object Boolean]", aW = "[object Date]", eW = "[object Error]", wt = "[object Function]", WW = "[object GeneratorFunction]", uW = "[object Map]", GW = "[object Number]", jt = "[object Object]", VW = "[object RegExp]", hW = "[object Set]", IW = "[object String]", pW = "[object Symbol]", LW = "[object WeakMap]", yW = "[object ArrayBuffer]", rW = "[object DataView]", KW = "[object Float32Array]", SW = "[object Float64Array]", xW = "[object Int8Array]", RW = "[object Int16Array]", YW = "[object Int32Array]", CW = "[object Uint8Array]", JW = "[object Uint8ClampedArray]", FW = "[object Uint16Array]", TW = "[object Uint32Array]", gi = {};
gi[Et] = gi[XW] = gi[yW] = gi[rW] = gi[oW] = gi[aW] = gi[KW] = gi[SW] = gi[xW] = gi[RW] = gi[YW] = gi[uW] = gi[GW] = gi[jt] = gi[VW] = gi[hW] = gi[IW] = gi[pW] = gi[CW] = gi[JW] = gi[FW] = gi[TW] = !0;
gi[eW] = gi[wt] = gi[LW] = !1;
function jl(n, l, i, c, Z, L) {
  var K, u = l & mW, a = l & ZW, e = l & nW;
  if (i && (K = Z ? i(n, c, Z, L) : i(n)), K !== void 0)
    return K;
  if (!sW(n))
    return n;
  var r = iW(n);
  if (r) {
    if (K = qe(n), !u)
      return we(n, K);
  } else {
    var X = Ae(n), W = X == wt || X == WW;
    if (lW(n))
      return Ee(n, u);
    if (X == jt || X == Et || W && !Z) {
      if (K = a || W ? {} : _e(n), !u)
        return a ? Be(n, Pe(K, n)) : je(n, Qe(K, n));
    } else {
      if (!gi[X])
        return Z ? n : {};
      K = $e(n, X, u);
    }
  }
  L || (L = new fe());
  var p = L.get(n);
  if (p)
    return p;
  L.set(n, K), tW(n) ? n.forEach(function(o) {
    K.add(jl(o, l, i, o, n, L));
  }) : dW(n) && n.forEach(function(o, G) {
    K.set(G, jl(o, l, i, G, n, L));
  });
  var C = e ? a ? De : Oe : a ? cW : bW, I = r ? void 0 : C(n);
  return ve(I || n, function(o, G) {
    I && (G = o, o = n[G]), Ue(K, G, jl(o, l, i, G, n, L));
  }), K;
}
var NW = jl, gW = NW, HW = 1, MW = 4;
function zW(n) {
  return gW(n, HW | MW);
}
var kW = zW;
const wl = /* @__PURE__ */ Hd(kW);
class fW extends b0 {
  // private syncBatchMap: Map<string, BaseCollectorReducerAction> = new Map();
  constructor(l) {
    super(), Object.defineProperty(this, "storage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "namespace", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "stateDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.plugin = l, this.uid = l.displayer.uid;
    const i = l.displayer.state.sceneState.sceneName;
    this.setNamespace(i);
  }
  addStorageStateListener(l) {
    this.stateDisposer = zb(async () => {
      const i = gd(this.plugin.attributes[this.namespace]), c = this.diffFun(this.storage, i);
      this.storage = i;
      for (const Z of Object.keys(c)) {
        const L = c[Z];
        L && l(Z, L);
      }
    });
  }
  removeStorageStateListener() {
    this.stateDisposer && this.stateDisposer();
  }
  diffFun(l, i) {
    const c = hd(l), Z = hd(i), L = {};
    for (const K of c) {
      if (Z.includes(K)) {
        if (_s(l[K], i[K]))
          continue;
        L[K] = {
          oldValue: wl(l[K]),
          newValue: wl(i[K])
        };
        continue;
      }
      L[K] = {
        oldValue: wl(l[K]),
        newValue: void 0
      };
    }
    for (const K of Z) {
      if (c.includes(K)) {
        if (_s(l[K], i[K]))
          continue;
        continue;
      }
      L[K] = {
        oldValue: void 0,
        newValue: wl(i[K])
      };
    }
    return L;
  }
  transformKey(l) {
    return this.uid + "@##@" + l;
  }
  isOwn(l) {
    return l.split("@##@")[0] === this.uid;
  }
  dispatch(l) {
    const { type: i, workId: c, ops: Z, index: L, opt: K, toolstype: u, w: a, h: e, removeIds: r, updateNodeOpt: X, op: W } = l;
    switch (i) {
      case Fi.Clear:
        const p = {};
        Object.keys(this.storage).filter((C) => C !== "scene").map((C) => {
          p[C] = void 0;
        }), this.setState(p);
        break;
      case Fi.UpdateScene:
        a && e && this.updateValue("scene", {
          uid: this.uid,
          w: a,
          h: e
        });
        break;
      case Fi.CreateWork:
        if (c && u && K) {
          const C = this.isLocalId(c.toString()) ? this.transformKey(c) : c;
          this.updateValue(C.toString(), {
            type: Fi.CreateWork,
            workId: c,
            toolstype: u,
            opt: K
          });
        }
        break;
      case Fi.UpdateWork:
        if (c && u && K) {
          const C = this.isLocalId(c.toString()) ? this.transformKey(c) : c, I = this.storage[C];
          this.updateValue(C.toString(), {
            ...I,
            type: Fi.UpdateWork,
            workId: c,
            toolstype: u,
            opt: K
          });
        }
        break;
      case Fi.DrawWork:
        if (c && typeof L == "number" && (W != null && W.length)) {
          const C = this.isLocalId(c.toString()) ? this.transformKey(c) : c, I = this.storage[C], o = ((I == null ? void 0 : I.op) || []).slice(0, L).concat(W);
          I && o && this.updateValue(C.toString(), {
            ...I,
            type: Fi.DrawWork,
            op: o,
            index: L
          });
        }
        break;
      case Fi.FullWork:
        if (c) {
          const C = this.isLocalId(c.toString()) ? this.transformKey(c) : c, I = this.storage[C], o = u || (I == null ? void 0 : I.toolstype), G = K || (I == null ? void 0 : I.opt);
          I && o && G && Z && this.updateValue(C.toString(), {
            type: Fi.FullWork,
            workId: C,
            toolstype: o,
            opt: G,
            ops: Z
          });
        }
        break;
      case Fi.RemoveNode:
        if (r != null && r.length) {
          const C = r.map((I) => this.isLocalId(I + "") ? this.transformKey(I) : I);
          Object.keys(this.storage).filter((I) => I !== "scene").map((I) => {
            C != null && C.includes(I) && this.updateValue(I, void 0);
          });
        }
        break;
      case Fi.UpdateNode:
        if (c && X) {
          const C = this.storage[c];
          C && (C.updateNodeOpt = X, this.updateValue(c.toString(), C));
        }
        break;
    }
  }
  setState(l) {
    const i = hd(l);
    for (let Z = 0; Z < i.length; Z++) {
      const L = i[Z], K = l[L];
      typeof K < "u" ? this.storage[L] = K : delete this.storage[L];
    }
    const c = {};
    c[this.namespace] = this.storage, this.plugin.setAttributes(c);
  }
  updateValue(l, i) {
    this.storage[l] = i, this.plugin.updateAttributes([this.namespace, l], i);
  }
  transformToSerializableData(l) {
    return Qb(l);
  }
  transformToNormalData(l) {
    return Ub(l);
  }
  keyTransformWorkId(l) {
    const i = l.split("@##@");
    return i.length === 2 ? i[1] : l;
  }
  destroy() {
  }
}
var vW = tl, UW = function() {
  return vW.Date.now();
}, QW = UW, PW = /\s/;
function EW(n) {
  for (var l = n.length; l-- && PW.test(n.charAt(l)); )
    ;
  return l;
}
var wW = EW, jW = wW, BW = /^\s+/;
function OW(n) {
  return n && n.slice(0, jW(n) + 1).replace(BW, "");
}
var DW = OW, AW = gl, qW = ul, $W = "[object Symbol]";
function _W(n) {
  return typeof n == "symbol" || qW(n) && AW(n) == $W;
}
var iu = _W, lu = DW, Xt = ml, du = iu, ot = NaN, su = /^[-+]0x[0-9a-f]+$/i, tu = /^0b[01]+$/i, bu = /^0o[0-7]+$/i, cu = parseInt;
function mu(n) {
  if (typeof n == "number")
    return n;
  if (du(n))
    return ot;
  if (Xt(n)) {
    var l = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = Xt(l) ? l + "" : l;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = lu(n);
  var i = tu.test(n);
  return i || bu.test(n) ? cu(n.slice(2), i ? 2 : 8) : su.test(n) ? ot : +n;
}
var Zu = mu, nu = ml, rd = QW, at = Zu, Xu = "Expected a function", ou = Math.max, au = Math.min;
function eu(n, l, i) {
  var c, Z, L, K, u, a, e = 0, r = !1, X = !1, W = !0;
  if (typeof n != "function")
    throw new TypeError(Xu);
  l = at(l) || 0, nu(i) && (r = !!i.leading, X = "maxWait" in i, L = X ? ou(at(i.maxWait) || 0, l) : L, W = "trailing" in i ? !!i.trailing : W);
  function p(V) {
    var S = c, Y = Z;
    return c = Z = void 0, e = V, K = n.apply(Y, S), K;
  }
  function C(V) {
    return e = V, u = setTimeout(G, l), r ? p(V) : K;
  }
  function I(V) {
    var S = V - a, Y = V - e, T = l - S;
    return X ? au(T, L - Y) : T;
  }
  function o(V) {
    var S = V - a, Y = V - e;
    return a === void 0 || S >= l || S < 0 || X && Y >= L;
  }
  function G() {
    var V = rd();
    if (o(V))
      return d(V);
    u = setTimeout(G, I(V));
  }
  function d(V) {
    return u = void 0, W && c ? p(V) : (c = Z = void 0, K);
  }
  function t() {
    u !== void 0 && clearTimeout(u), e = 0, c = a = Z = u = void 0;
  }
  function s() {
    return u === void 0 ? K : d(rd());
  }
  function b() {
    var V = rd(), S = o(V);
    if (c = arguments, Z = this, a = V, S) {
      if (u === void 0)
        return C(a);
      if (X)
        return clearTimeout(u), u = setTimeout(G, l), p(a);
    }
    return u === void 0 && (u = setTimeout(G, l)), K;
  }
  return b.cancel = t, b.flush = s, b;
}
var Wu = eu, uu = Wu, Gu = ml, Vu = "Expected a function";
function hu(n, l, i) {
  var c = !0, Z = !0;
  if (typeof n != "function")
    throw new TypeError(Vu);
  return Gu(i) && (c = "leading" in i ? !!i.leading : c, Z = "trailing" in i ? !!i.trailing : Z), uu(n, l, {
    leading: c,
    maxWait: l,
    trailing: Z
  });
}
var Iu = hu;
const pu = /* @__PURE__ */ Hd(Iu);
function Lu(n, l, i) {
  return "#" + ((n << 16) + (l << 8) + i).toString(16).padStart(6, "0");
}
class yu {
  constructor(l, i) {
    Object.defineProperty(this, "plugin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pluginOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "collector", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "worker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "room", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "disposeDisplayerSubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
      }
    }), Object.defineProperty(this, "resizeChange", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        var Z, L, K, u;
        const c = (Z = il.instance) == null ? void 0 : Z.containerRef;
        if (c) {
          const a = c.offsetWidth, e = c.offsetHeight;
          (L = this.worker) == null || L.updateCanvas({
            width: a,
            height: e
          }, Ai.Local);
          const r = (K = il.instance) == null ? void 0 : K.canvasBgRef, X = (u = il.instance) == null ? void 0 : u.canvasFloatRef;
          r && X && (X.style.width = `${a}px`, X.style.height = `${e}px`, r.style.width = `${a}px`, r.style.height = `${e}px`);
        }
      }
    }), Object.defineProperty(this, "_throttled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pu(this.resizeChange, 500, { leading: !1 })
    }), Object.defineProperty(this, "mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        var Z;
        c.button === 0 && ((Z = this.worker) == null || Z.onLocalEventStart([c.offsetX, c.offsetY]));
      }
    }), Object.defineProperty(this, "mousemove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        var Z;
        (Z = this.worker) == null || Z.onLocalEventDoing([c.offsetX, c.offsetY]);
      }
    }), Object.defineProperty(this, "mouseup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        var Z;
        c.button === 0 && ((Z = this.worker) == null || Z.onLocalEventEnd([c.offsetX, c.offsetY]));
      }
    }), Object.defineProperty(this, "touchstart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        var Z;
        (Z = this.worker) == null || Z.onLocalEventStart([c.targetTouches[0].pageX, c.targetTouches[0].pageY]);
      }
    }), Object.defineProperty(this, "touchmove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        var Z;
        (Z = this.worker) == null || Z.onLocalEventDoing([c.targetTouches[0].pageX, c.targetTouches[0].pageY]);
      }
    }), Object.defineProperty(this, "touchend", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        var Z;
        (Z = this.worker) == null || Z.onLocalEventEnd([c.changedTouches[0].pageX, c.changedTouches[0].pageY]);
      }
    }), this.plugin = l, this.room = Kd(l.displayer) ? l.displayer : void 0, this.pluginOptions = i;
  }
  init() {
    this.disposeDisplayerSubscribe = il.displayState$.subscribe((l) => {
      l === el.mounted && this.onMountDisplayer(), l === el.unmounted && this.onUnMountDisplayer();
    });
  }
  cleanCurrentScene() {
    var l;
    (l = this.worker) == null || l.clearAll();
  }
  destroy() {
    this.disposeDisplayerSubscribe();
  }
  onCameraChange(l) {
    var i;
    (i = this.worker) == null || i.setCameraOpt(gd(l));
  }
  onSceneChange(l) {
    var i, c, Z;
    (i = this.collector) == null || i.setNamespace(l.sceneName), (c = this.worker) == null || c.clearAll(!0), (Z = this.worker) == null || Z.initSyncData(() => {
    });
  }
  onMemberChange(l) {
    var L, K, u;
    if (!this.room)
      return;
    const i = l.currentApplianceName, c = i === Il.pencil && l.useLaserPen ? sl.LaserPen : i === Il.eraser ? sl.Eraser : i === Il.pencil ? sl.Pencil : sl.Clicker, Z = {
      color: Lu(l.strokeColor[0], l.strokeColor[1], l.strokeColor[2]),
      opacity: (l == null ? void 0 : l.strokeOpacity) || 1
    };
    c === sl.Pencil ? (Z.thickness = l.strokeWidth, Z.strokeType = (l == null ? void 0 : l.strokeType) || Bl.Stroke) : c === sl.Eraser ? (Z.thickness = l.strokeWidth, Z.isLine = (l == null ? void 0 : l.isLine) || !1) : c === sl.LaserPen && (Z.thickness = l.strokeWidth, Z.duration = (l == null ? void 0 : l.duration) || 1, Z.strokeType = (l == null ? void 0 : l.strokeType) || Bl.Normal), (L = this.worker) == null || L.setCurrentToolsData({
      toolsType: c,
      toolsOpt: Z
    }), i === Il.eraser || i === Il.pencil ? (i === Il.pencil && (this.room.disableDeviceInputs = !0), (K = this.worker) == null || K.abled()) : (this.room.disableDeviceInputs = !1, (u = this.worker) == null || u.unabled());
  }
  onWritableChange(l) {
    var i, c;
    l ? (c = this.worker) == null || c.abled() : (i = this.worker) == null || i.unabled();
  }
  onMountDisplayer() {
    var Z, L, K;
    const l = (Z = il.instance) == null ? void 0 : Z.containerRef, i = (L = il.instance) == null ? void 0 : L.canvasFloatRef, c = (K = il.instance) == null ? void 0 : K.canvasBgRef;
    i && c && l && (i.width = l.offsetWidth, i.height = l.offsetHeight, c.width = l.offsetWidth, c.height = l.offsetHeight, this.collector = new fW(this.plugin), this.worker = new ll(c, i, this.collector, this.pluginOptions), this.collector.addStorageStateListener((u, a) => {
      var e, r;
      if (u === "screen" && a.newValue) {
        const { w: X, h: W } = a.newValue;
        X && W && (c && i && (c.width = X, c.height = W, i.width = X, i.height = W), (e = this.worker) == null || e.updateCanvas({
          width: X,
          height: W
        }, Ai.Service));
      } else
        (r = this.worker) == null || r.onServiceDerive(u, a);
    }), this.worker.initSyncData((u, a) => {
      if (u === "screen" && a) {
        const { w: e, h: r } = a;
        e && r && c && i && (c.width = e, c.height = r, i.width = e, i.height = r);
      }
    }), this.bindDisplayerEvent(l), this.resizeChange());
  }
  onUnMountDisplayer() {
    var i, c, Z;
    const l = (i = il.instance) == null ? void 0 : i.containerRef;
    l && this.removeDisplayerEvent(l), (c = this.collector) == null || c.destroy(), (Z = this.worker) == null || Z.destroy(), this.collector = void 0, this.worker = void 0;
  }
  bindDisplayerEvent(l) {
    l.addEventListener("mousedown", this.mousedown, !0), l.addEventListener("mousemove", this.mousemove, !0), l.addEventListener("mouseup", this.mouseup, !0), l.addEventListener("mouseleave", this.mouseup, !0), l.addEventListener("touchstart", this.touchstart, !0), l.addEventListener("touchmove", this.touchmove, !0), l.addEventListener("touchend", this.touchend, !0), window.addEventListener("resize", this._throttled);
  }
  removeDisplayerEvent(l) {
    l.removeEventListener("mousedown", this.mousedown), l.removeEventListener("mousemove", this.mousemove), l.removeEventListener("mouseup", this.mouseup), l.removeEventListener("mouseleave", this.mouseup), l.removeEventListener("touchstart", this.touchstart), l.removeEventListener("touchmove", this.touchmove), l.removeEventListener("touchend", this.touchend), window.removeEventListener("resize", this._throttled);
  }
}
class Hi extends kb {
  static async getInstance(l, i) {
    i != null && i.logger && (Hi.logger = i.logger), i != null && i.options && (Hi.options = i.options);
    let c = l.getInvisiblePlugin(Hi.kind);
    if (!c)
      if (Kd(l) && l.isWritable) {
        if (!l.isWritable)
          return l;
        c = await l.createInvisiblePlugin(Hi, {});
      } else
        return l;
    return c == null || c.init(l), Hi.effectInstance(l), l;
  }
  /**
   * 房间实例化时，将当前实例对displayer外部API的添加内部处理逻辑;
   * @param displayer
   */
  static effectInstance(l) {
    const i = l.cleanCurrentScene;
    return l.cleanCurrentScene = function(c) {
      Hi.currentManager.cleanCurrentScene(), Hi.logger.info("[Projector plugin] cleanCurrentScene"), i.call(l, c);
    }, l;
  }
  constructor(l) {
    super(l), Object.defineProperty(this, "onPhaseChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (c) => {
        c === fb.Disconnected && (this.displayer.callbacks.off(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.off("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.off("onPhaseChanged", this.onPhaseChanged), Hi.invisiblePlugins.delete(this.displayer), Hi.currentManager.destroy());
      }
    }), Object.defineProperty(this, "updateRoomWritable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        Hi.currentManager.onWritableChange(this.displayer.isWritable);
      }
    }), Object.defineProperty(this, "roomStateChangeListener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: async (c) => {
        c.cameraState && Hi.currentManager.onCameraChange(c.cameraState), c.memberState && Hi.currentManager.onMemberChange(c.memberState), c.sceneState && Hi.currentManager.onSceneChange(c.sceneState);
      }
    }), Object.defineProperty(this, "createCurrentManager", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        Hi.currentManager && Hi.currentManager.destroy();
        const c = new yu(this, Hi.options);
        c.init(), Hi.currentManager = c, Hi.logger.info("[Projector plugin] refresh currentSlideManager object");
      }
    });
    const i = Hi.invisiblePlugins.get(this.displayer);
    i && i0(i, this);
  }
  get isReplay() {
    return vb(this.displayer);
  }
  get callbackName() {
    return this.isReplay ? "onPlayerStateChanged" : "onRoomStateChanged";
  }
  init(l) {
    const i = It(l.getInvisiblePlugin(Hi.kind));
    Hi.invisiblePlugins.set(l, i), Kd(l) && this.createCurrentManager(), this.displayer.callbacks.on(this.callbackName, this.roomStateChangeListener), this.displayer.callbacks.on("onEnableWriteNowChanged", this.updateRoomWritable), this.displayer.callbacks.on("onPhaseChanged", this.onPhaseChanged);
  }
}
Object.defineProperty(Hi, "kind", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "bezier-pencil-plugin"
});
Object.defineProperty(Hi, "invisiblePlugins", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /* @__PURE__ */ new WeakMap()
});
Object.defineProperty(Hi, "logger", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    info: console.log,
    warn: console.warn,
    error: console.error
  }
});
export {
  il as BezierPencilDisplayer,
  Hi as BezierPencilPlugin,
  el as DisplayStateEnum,
  Sd as ECanvasContextType,
  Ol as ECanvasShowType,
  Ai as EDataType,
  Fi as EPostMessageType,
  Ls as EShapeDataTypeKey,
  ps as ESpriteNodeKey,
  Bl as EStrokeType,
  sl as EToolsKey,
  ys as EanimationMode,
  Bi as EvevtWorkState,
  ll as MainEngineForWorker
};
//# sourceMappingURL=bezier-pencil-plugin.mjs.map
